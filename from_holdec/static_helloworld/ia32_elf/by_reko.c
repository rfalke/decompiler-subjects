// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b80CF300 = 0x00; // 080CF300
Eq_2 output_charset_cache.11629 = // 080CF560
	{
		0
	};
word32 output_charset_cached.11630 = 0x00; // 080CF564
Eq_2 freemem_size.11587 = // 080CF568
	{
		0
	};
word32 * freemem.11586 = null; // 080CF56C
Eq_2 lock.11578 = // 080CF570
	{
		0
	};
Eq_2 transmem_list = // 080CF574
	{
		0
	};
word32 root = 0x00; // 080CF578
Eq_2 _nl_loaded_domains = // 080CF5C0
	{
		0
	};
Eq_2 g_t80CF5C4 = // 080CF5C4
	{
		0
	};
word32 g_dw80CF5C8 = 0x00; // 080CF5C8
Eq_2 g_t80CF5CC = // 080CF5CC
	{
		0
	};
ptr32 locale_alias_path.10080 = 0x00; // 080CF5D0
uint32 maxmap = 0x00; // 080CF5D4
uint32 nmap = 0x00; // 080CF5D8
up32 string_space_max = 0x00; // 080CF5DC
up32 string_space_act = 0x00; // 080CF5E0
Eq_2 lock = // 080CF5E4
	{
		0
	};
Eq_2 __abort_msg = // 080CF5E8
	{
		0
	};
Eq_2 g_t80CF5EC = // 080CF5EC
	{
		0
	};
word32 g_dw80CF5F0 = 0x00; // 080CF5F0
Eq_2 g_t80CF5F4 = // 080CF5F4
	{
		0
	};
word32 stage = 0x00; // 080CF5F8
Eq_10418 phys_pages.8655 = // 080CF5FC
	{
		0
	};
Eq_10314 pagesize.8656 = // 080CF600
	{
		0
	};
byte g_b80CF604 = 0x00; // 080CF604
Eq_2 freeres_list = // 080CF828
	{
		0
	};
byte g_b80CF82C = 0x00; // 080CF82C
word32 stdio_needs_locking = 0x00; // 080CF830
Eq_2 run_fp = // 080CF834
	{
		0
	};
Eq_2 g_t80CF838 = // 080CF838
	{
		0
	};
Eq_2 g_t80CF83C = // 080CF83C
	{
		0
	};
Eq_2 g_t80CF840 = // 080CF840
	{
		0
	};
<anonymous> * __after_morecore_hook = null; // 080CF868
Eq_2 __free_hook = // 080CF86C
	{
		0
	};
Eq_2 next_to_use.12583 = // 080CF870
	{
		0
	};
uint32 narenas_limit.12605 = 0x00; // 080CF874
word32 using_malloc_checking = 0x00; // 080CF878
Eq_2 aligned_heap_area = // 080CF87C
	{
		0
	};
Eq_2 list_lock = // 080CF880
	{
		0
	};
Eq_2 free_list = // 080CF884
	{
		0
	};
Eq_2 free_list_lock = // 080CF888
	{
		0
	};
Eq_2 perturb_byte = // 080CF88C
	{
		0
	};
Eq_2 global_max_fast = // 080CF890
	{
		0
	};
Eq_2 environ = // 080CF89C
	{
		0
	};
word32 timestamp.11438 = 0x00; // 080CF8A0
ui32 g_dw80CF8C8 = 0x00; // 080CF8C8
ui32 g_dw80CF8CC = 0x00; // 080CF8CC
Eq_2 g_t80CF8E0 = // 080CF8E0
	{
		0
	};
Eq_1523 g_t80CF8E4 = // 080CF8E4
	{
		0
	};
word32 g_dw80CF8E8 = 0x00; // 080CF8E8
Eq_2 g_t80CF8EC = // 080CF8EC
	{
		0
	};
Eq_2 g_t80CF8F0 = // 080CF8F0
	{
		0
	};
Eq_2 g_t80CF8F4 = // 080CF8F4
	{
		0
	};
byte g_b80CF8F7 = 0x00; // 080CF8F7
word32 g_dw80CF8F8 = 0x00; // 080CF8F8
Eq_2 g_t80CF8FC = // 080CF8FC
	{
		0
	};
word32 g_dw80CF900 = 0x00; // 080CF900
Eq_2 g_t80CF904 = // 080CF904
	{
		0
	};
ui32 g_dw80CF920 = 0x00; // 080CF920
ui32 g_dw80CF924 = 0x00; // 080CF924
Eq_2 g_t80CF928 = // 080CF928
	{
		0
	};
int32 g_dw80CF92C = 0; // 080CF92C
Eq_2 g_t80CF930 = // 080CF930
	{
		0
	};
word32 __compound_literal.2 = 0x00; // 080CF938
ui32 once = 0x00; // 080CF93C
word32 known_derivations = 0x00; // 080CF940
Eq_2 modcounter.12647 = // 080CF944
	{
		0
	};
Eq_2 lock.12667 = // 080CF948
	{
		0
	};
word32 cache_malloced = 0x00; // 080CF94C
Eq_2 cache_size = // 080CF950
	{
		0
	};
Eq_2 gconv_cache = // 080CF954
	{
		0
	};
Eq_2 release_handle = // 080CF958
	{
		0
	};
Eq_2 loaded = // 080CF95C
	{
		0
	};
Eq_2 archloaded = // 080CF980
	{
		0
	};
Eq_2 g_t80CFA00 = // 080CFA00
	{
		0
	};
Eq_2 g_t80CFA08 = // 080CFA08
	{
		0
	};
ptr32 archmapped = 0x00; // 080CFA10
Eq_2 last_environ = // 080CFA14
	{
		0
	};
Eq_2 known_values = // 080CFA18
	{
		0
	};
Eq_2 envlock = // 080CFA1C
	{
		0
	};
Eq_2 lock = // 080CFA20
	{
		0
	};
up32 next_bit = 0x00; // 080CFA24
Eq_2 lock = // 080CFA28
	{
		0
	};
Eq_2 lock = // 080CFA2C
	{
		0
	};
Eq_44841 __curbrk = // 080CFA40
	{
		0
	};
word32 max_dirnamelen = 0x00; // 080CFA44
Eq_121034 log_hashfraction = // 080CFA48
	{
		0x00
	};
Eq_48913 textsize = // 080CFA4C
	{
		0x00
	};
struct Eq_48912 * lowpc = null; // 080CFA50
Eq_27327 fromidx = // 080CFA54
	{
		0
	};
Eq_27327 fromlimit = // 080CFA58
	{
		0
	};
struct Eq_122216 * froms = null; // 080CFA5C
word32 tos = 0x00; // 080CFA60
union Eq_27327 * narcsp = null; // 080CFA64
Eq_27327 narcs = // 080CFA68
	{
		0
	};
struct Eq_48912 * running = null; // 080CFA6C
struct Eq_122282 * data = null; // 080CFA70
Eq_2 cachesize = // 080CFA74
	{
		0
	};
Eq_2 cache_new = // 080CFA78
	{
		0
	};
Eq_2 cache = // 080CFA7C
	{
		0
	};
ui32 once = 0x00; // 080CFA80
word32 key = 0x00; // 080CFA84
Eq_2 static_buf = // 080CFA88
	{
		0
	};
word32 g_dw80CFB2C = 0x00; // 080CFB2C
uint32 pc_scale = 0x00; // 080CFB3C
word32 pc_offset = 0x00; // 080CFB40
uint32 nsamples = 0x00; // 080CFB44
Eq_2 samples = // 080CFB48
	{
		0
	};
word32 dl_close_state.11755 = 0x00; // 080CFB4C
word32 once_regsizes.8965 = 0x00; // 080CFB50
Eq_143926 g_t80CFB54 = // 080CFB54
	{
		
		{
			0x00
		},
	};
byte g_b80CFB55 = 0x00; // 080CFB55
byte g_b80CFB56 = 0x00; // 080CFB56
byte g_b80CFB57 = 0x00; // 080CFB57
byte g_b80CFB58 = 0x00; // 080CFB58
byte g_b80CFB59 = 0x00; // 080CFB59
byte g_b80CFB5A = 0x00; // 080CFB5A
byte g_b80CFB5B = 0x00; // 080CFB5B
byte g_b80CFB5C = 0x00; // 080CFB5C
byte g_b80CFB5D = 0x00; // 080CFB5D
byte g_b80CFB5F = 0x00; // 080CFB5F
byte g_b80CFB60 = 0x00; // 080CFB60
byte g_b80CFB61 = 0x00; // 080CFB61
byte g_b80CFB62 = 0x00; // 080CFB62
byte g_b80CFB63 = 0x00; // 080CFB63
byte g_b80CFB64 = 0x00; // 080CFB64
word32 marker.8593 = 0x00; // 080CFB80
word32 g_dw80CFB88 = 0x00; // 080CFB88
word32 g_dw80CFB8C = 0x00; // 080CFB8C
Eq_2 frame_hdr_cache_head = // 080CFB90
	{
		0
	};
struct Eq_147381 g_t80CFBB8 = // 080CFBB8
	{
		0x00,
		0x00,
		0x00,
	};
word32 g_dw80CFC5C = 0x00; // 080CFC5C
word32 any_objects_registered = 0x00; // 080CFC78
Eq_2 seen_objects = // 080CFC7C
	{
		0
	};
Eq_2 unseen_objects = // 080CFC80
	{
		0
	};
Eq_2 _dl_tls_static_used = // 080CFCA0
	{
		0
	};
Eq_114606 _dl_tls_static_align = // 080CFCA4
	{
		0
	};
Eq_2 _dl_tls_max_dtv_idx = // 080CFCA8
	{
		0
	};
word32 g_dw80CFCC0 = 0x00; // 080CFCC0
Eq_123327 g_t80CFCC8 = // 080CFCC8
	{
		0x00,
		
		{
		},
	};
Eq_2 g_t80CFCD0 = // 080CFCD0
	{
		0
	};
word32 g_dw80CFCD4 = 0x00; // 080CFCD4
Eq_2 _dl_tls_dtv_slotinfo_list = // 080CFEC0
	{
		0
	};
byte g_b80CFEC4 = 0x00; // 080CFEC4
Eq_123392 _dl_tls_generation = // 080CFEC8
	{
		0x00,
	};
Eq_2 _dl_tls_static_nelem = // 080CFECC
	{
		0
	};
Eq_2 _nl_domain_bindings = // 080CFED0
	{
		0
	};
Eq_2 _nl_msg_cat_cntr = // 080CFED4
	{
		0
	};
Eq_2 __exit_funcs_lock = // 080CFED8
	{
		0
	};
word32 g_dw80CFEE0 = 0x00; // 080CFEE0
word32 g_dw80CFEE4 = 0x00; // 080CFEE4
Eq_47441 g_t80CFEE8 = // 080CFEE8
	{
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
	};
word32 g_dw80CFEEC = 0x00; // 080CFEEC
Eq_2 g_t80CFEF8 = // 080CFEF8
	{
		0
	};
Eq_2 _dl_profile_output = // 080CFEFC
	{
		0
	};
Eq_2 _dl_platformlen = // 080CFF00
	{
		0
	};
Eq_2 _dl_debug_mask = // 080CFF04
	{
		0
	};
byte g_b80CFF05 = 0x00; // 080CFF05
<anonymous> * _dl_wait_lookup_done = null; // 080CFF08
Eq_2 _dl_profile = // 080CFF0C
	{
		0
	};
uint32 _dl_bind_not = 0x00; // 080CFF10
struct Eq_47684 * _dl_auxv = null; // 080CFF14
Eq_2 _dl_platform = // 080CFF18
	{
		0
	};
uint32 g_dw80CFF1C = 0x00; // 080CFF1C
uint32 g_dw80CFF20 = 0x00; // 080CFF20
uint32 _dl_lazy = 0x00; // 080CFF24
Eq_2 _dl_sysinfo_map = // 080CFF28
	{
		0
	};
word32 _dl_inhibit_cache = 0x00; // 080CFF2C
Eq_2 _dl_phdr = // 080CFF30
	{
		0
	};
Eq_2 _dl_scope_free_list = // 080CFF34
	{
		0
	};
Eq_2 _dl_origin_path = // 080CFF38
	{
		0
	};
word32 _dl_clktck = 0x00; // 080CFF3C
uint32 _dl_dynamic_weak = 0x00; // 080CFF40
Eq_2 _dl_sysinfo_dso = // 080CFF44
	{
		0
	};
Eq_2 _dl_init_all_dirs = // 080CFF48
	{
		0
	};
uint32 _dl_verbose = 0x00; // 080CFF4C
Eq_1898 _dl_phnum = // 080CFF50
	{
		0x00
	};
Eq_2 _dl_profile_map = // 080CFF54
	{
		0
	};
Eq_2 _dl_initfirst = // 080CFF58
	{
		0
	};
Eq_2 _dl_all_dirs = // 080CFF5C
	{
		0
	};
uint32 _dl_osversion = 0x00; // 080CFF60
byte * _dl_inhibit_rpath = null; // 080CFF64
Eq_2 g_t80CFF68 = // 080CFF68
	{
		0
	};
Eq_2 g_t80CFF6C = // 080CFF6C
	{
		0
	};
word32 __libc_enable_secure_decided = 0x00; // 080CFF70
word32 __libc_argc = 0x00; // 080CFF74
word32 * __libc_argv = null; // 080CFF78
Eq_2 __gconv_modules_db = // 080CFF7C
	{
		0
	};
Eq_2 __gconv_lock = // 080CFF80
	{
		0
	};
word32 __gconv_alias_db = 0x00; // 080CFF84
Eq_2 __gconv_path_envvar = // 080CFF88
	{
		0
	};
ptr32 __gconv_max_path_elem_len = 0x00; // 080CFF8C
Eq_2 __gconv_path_elem = // 080CFF90
	{
		0
	};
struct Eq_67799 * g_a80CFFA0[] = // 080CFFA0
	{
	};
Eq_2 (* __printf_function_table)[] = null; // 080CFFD4
Eq_2 __printf_modifier_table = // 080CFFD8
	{
		0
	};
word32 __x86_shared_non_temporal_threshold = 0x00; // 080CFFDC
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _dl_tls_static_size = 0x0800; // 080CE024
Eq_2 _nl_current_default_domain = // 080CE028
	{
		-44
	};
word32 __exit_funcs = 0x080CF620; // 080CE02C
Eq_2 DW.ref.__gcc_personality_v0 = // 080CE030
	{
		0
	};
word32 * g_ptr80CE038 = null; // 080CE038
Eq_2 _IO_list_all = // 080CE040
	{
		96
	};
word32 g_dw80CE044 = 0x00; // 080CE044
word32 * g_ptr80CE04C = null; // 080CE04C
Eq_3803 (* g_ptr80CE084)[] = null; // 080CE084
Eq_150877 (* g_ptr80CE088)[] = null; // 080CE088
Eq_2 g_t80CE08C = // 080CE08C
	{
		0
	};
Eq_2 g_a80CE100[] = // 080CE100
	{
	};
word32 g_a80CE140[] = // 080CE140
	{
	};
<anonymous> * g_a80CE180[] = // 080CE180
	{
	};
struct Eq_54727 g_t80CE230 = // 080CE230
	{
		0x00,
	};
uint32 g_dw80CE254 = 0x080CF180; // 080CE254
word32 g_dw80CE2A8 = 0x00; // 080CE2A8
Eq_2 _IO_stderr = // 080CE474
	{
		96
	};
Eq_2 _IO_stdout = // 080CE478
	{
		-64
	};
Eq_2 _IO_stdin = // 080CE47C
	{
		32
	};
word32 may_shrink_heap.11496 = ~0x00; // 080CE480
int32 __libc_malloc_initialized = -1; // 080CE484
Eq_2 narenas = // 080CE488
	{
		1
	};
ui32 g_dw80CE4A0 = 0x00020000; // 080CE4A0
up32 g_dw80CE4A4 = 0x00020000; // 080CE4A4
Eq_2 g_t80CE4A8 = // 080CE4A8
	{
		0
	};
Eq_2 g_t80CE4AC = // 080CE4AC
	{
		2
	};
uint32 g_dw80CE4B0 = 0x00; // 080CE4B0
Eq_27327 g_t80CE4B4 = // 080CE4B4
	{
		0
	};
Eq_27327 g_t80CE4B8 = // 080CE4B8
	{
		0x00010000
	};
Eq_2 g_t80CE4BC = // 080CE4BC
	{
		0
	};
word32 g_dw80CE4C0 = 0x00; // 080CE4C0
Eq_27327 g_t80CE4C4 = // 080CE4C4
	{
		0
	};
Eq_2 g_t80CE4C8 = // 080CE4C8
	{
		0
	};
Eq_2 g_t80CE4CC = // 080CE4CC
	{
		0
	};
uint32 g_dw80CE4D0 = 0x40; // 080CE4D0
up32 g_dw80CE4D4 = 1020; // 080CE4D4
Eq_2 g_t80CE4D8 = // 080CE4D8
	{
		7
	};
word32 g_dw80CE4DC = 0x00; // 080CE4DC
<anonymous> * __memalign_hook = memalign_hook_ini; // 080CE4E0
<anonymous> * __realloc_hook = realloc_hook_ini; // 080CE4E4
<anonymous> * __malloc_hook = malloc_hook_ini; // 080CE4E8
Eq_2 g_t80CE500 = // 080CE500
	{
		0
	};
Eq_27006 g_t80CE504 = // 080CE504
	{
		0x00
	};
word32 g_dw80CE508 = 0x00; // 080CE508
Eq_2 g_t80CE538 = // 080CE538
	{
		0
	};
struct Eq_28484 g_t80CE930 = // 080CE930
	{
		0x00,
		0x00,
		0x00,
	};
Eq_2 g_t80CE948 = // 080CE948
	{
		0
	};
up32 g_dw80CE954 = 0x00; // 080CE954
<anonymous> * __morecore = __default_morecore; // 080CE95C
Eq_2 cached_result.11437 = // 080CE960
	{
		-1
	};
Eq_2 program_invocation_short_name = // 080CE964
	{
		-7
	};
Eq_2 __progname_full = // 080CE968
	{
		-7
	};
ui32 _dl_stack_flags = 0x07; // 080CE9A0
ui32 _dl_correct_cache_id = 0x03; // 080CE9A8
word32 _dl_debug_fd = 0x02; // 080CE9AC
Eq_2 _dl_pagesize = // 080CE9B0
	{
		0
	};
word32 _dl_starting_up = 0x01; // 080CE9B4
up32 g_dw80CE9B8 = 0x01; // 080CE9B8
word32 g_dw80CE9BC = 0x00; // 080CE9BC
Eq_2 _dl_nns = // 080CE9C0
	{
		1
	};
ui32 _dl_use_load_bias = ~0x01; // 080CE9C4
word32 _dl_sysinfo = 0x08063960; // 080CE9E0
<anonymous> * _dl_init_static_tls = _dl_nothread_init_static_tls; // 080CE9E4
Eq_2 g_t80CE9E8 = // 080CE9E8
	{
		-16
	};
word32 g_dw80CE9EC = 0x01; // 080CE9EC
word32 __compound_literal.3 = 0x080CEA60; // 080CE9F0
Eq_2 g_t80CEA00 = // 080CEA00
	{
		96
	};
Eq_151587 g_a80CEA04[] = // 080CEA04
	{
	};
struct Eq_150587 * g_ptr80CEA08 = &g_t80CEBC0; // 080CEA08
word32 g_dw80CEA0C = 0x00; // 080CEA0C
Eq_151581 g_a80CEA30[] = // 080CEA30
	{
	};
Eq_150587 g_t80CEBC0 = // 080CEBC0
	{
		
		{
			-64
		},
		0x01,
	};
word32 __compound_literal.1 = 0x080CEA60; // 080CECC0
<anonymous> * _dl_make_stack_executable_hook = _dl_make_stack_executable; // 080CECD0
word32 __libc_multiple_libcs = 0x01; // 080CECD4
struct Eq_70762 * g_ptr80CEE60 = &g_t80CC740; // 080CEE60
word32 g_dw80CEE94 = 0x080A7940; // 080CEE94
word32 g_dw80CEE98 = 0x080A6A40; // 080CEE98
word32 g_dw80CEE9C = 0x080A7040; // 080CEE9C
Eq_2 g_a80CEEA0[] = // 080CEEA0
	{
	};
word32 pa_next_type = 0x08; // 080CEED8
word32 __x86_raw_shared_cache_size = 0x00100000; // 080CEEDC
word32 __x86_raw_shared_cache_size_half = 0x00080000; // 080CEEE0
word32 __x86_shared_cache_size = 0x00100000; // 080CEEE4
word32 __x86_shared_cache_size_half = 0x00080000; // 080CEEE8
word32 __x86_raw_data_cache_size = 0x8000; // 080CEEEC
word32 __x86_raw_data_cache_size_half = 0x4000; // 080CEEF0
word32 __x86_data_cache_size = 0x8000; // 080CEEF4
word32 __x86_data_cache_size_half = 0x4000; // 080CEEF8
word32 g_dw80CEF58 = ~0x00; // 080CEF58
word32 g_dw80CEF5C = ~0x00; // 080CEF5C
// subject_eh_frame_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw80BA428 = 0x30; // 080BA428
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080A1AB0: void _fini()
// Called from:
//      __libc_csu_fini
void _fini()
{
}

// subject_fini_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a80CC6B8[] = // 080CC6B8
	{
	};
// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __funlockfile_GOT = __funlockfile; // 080CDFD8
<anonymous> * free_GOT = free; // 080CDFEC
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_923 g_t80CE000 = // 080CE000
	{
		
		{
		},
		
		{
			0
		},
		0x00080000,
		0x00100000,
		0x00080000,
		0x00008000,
		0x00004000,
		0x00008000,
		0x00004000,
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049000: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
}

// subject_libc_IO_vtables.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_17524 g_t80CF120 = // 080CF120
	{
		_IO_file_sync_mmap,
	};
struct Eq_17524 g_t80CF180 = // 080CF180
	{
		_IO_new_file_sync,
	};
// subject_libc_atexit.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 __elf_set___libc_atexit_element__IO_cleanup__ = 0x08057410; // 080CF2F4
// subject_libc_freeres_fn.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080A0F10: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 esi_20 = _nl_domain_bindings;
	if (esi_20 == 0x00)
	{
		word32 edx_65;
		fn080A0F73(&g_t80CE000, gs, out edx_65);
	}
	else
	{
		word32 edx_66;
		fn080A0F32(&g_t80CE000, esi_20, &_nl_domain_bindings, gs, out edx_66);
	}
}

// 080A0F32: Register ptr32 fn080A0F32(Register (ptr32 Eq_149575) ebx, Register Eq_2 esi, Register (ptr32 Eq_2) edi, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      __dl_iterate_phdr
//      free_mem
ptr32 fn080A0F32(struct Eq_149575 * ebx, Eq_2 esi, union Eq_2 * edi, struct Eq_9 * gs, ptr32 & edxOut)
{
	Eq_2 esi_57 = esi;
	do
	{
		*edi = (union Eq_2 *) *esi_57;
		Eq_2 eax_13 = *((word32) esi_57 + 4);
		if (eax_13 != (char *) ebx - 0x0002BD40)
		{
			word32 ecx_89;
			word32 edx_90;
			free(gs, dwLoc14, eax_13, out ecx_89, out edx_90);
		}
		word32 edx_92;
		word32 ecx_91;
		free(gs, dwLoc14, *((word32) esi_57 + 8), out ecx_91, out edx_92);
		word32 ecx_93;
		word32 edx_94;
		free(gs, dwLoc14, esi_57, out ecx_93, out edx_94);
		esi_57 = *edi;
	} while (esi_57 != 0x00);
	ptr32 edx_69;
	ptr32 eax_64 = fn080A0F73(ebx, gs, out edx_69);
	edxOut = edx_69;
	return eax_64;
}

// 080A0F73: Register Eq_2 fn080A0F73(Register (ptr32 Eq_149575) ebx, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      __dl_iterate_phdr
//      free_mem
Eq_2 fn080A0F73(struct Eq_149575 * ebx, struct Eq_9 * gs, ptr32 & edxOut)
{
	Eq_2 eax_6 = ebx->t0028;
	if (eax_6 != (char *) ebx - 0x0002BD2C)
	{
		word32 ecx_121;
		word32 edx_122;
		free(gs, dwLoc14, eax_6, out ecx_121, out edx_122);
	}
	ptr32 edx_113;
	tdestroy(gs, ebx->t1578, ebx->ptrFFFFFFEC);
	Eq_2 eax_111 = ebx->t1574;
	ebx->t1578.u0 = 0x00;
	if (eax_111 != 0x00)
	{
		do
		{
			Eq_2 esi_57 = *eax_111;
			ebx->t1574 = esi_57;
			word32 ecx_123;
			free(gs, dwLoc14, eax_111, out ecx_123, out edx_113);
			eax_111 = esi_57;
		} while (esi_57 != 0x00);
	}
	edxOut = edx_113;
	return eax_111;
}

// 080A0FF0: void _nl_finddomain_subfreeres(Register (ptr32 Eq_9) gs)
// Called from:
//      free_mem
void _nl_finddomain_subfreeres(struct Eq_9 * gs)
{
	Eq_2 esi_15 = _nl_loaded_domains;
	if (esi_15 != 0x00)
	{
		while (true)
		{
			Eq_2 eax_21 = *((word32) esi_15 + 8);
			if (eax_21 != 0x00)
				_nl_unload_domain(gs, eax_21);
			Eq_2 edi_45 = *((word32) esi_15 + 0x0C);
			word32 ecx_114;
			word32 edx_115;
			free(gs, dwLoc20, *esi_15, out ecx_114, out edx_115);
			word32 ecx_116;
			word32 edx_117;
			free(gs, dwLoc20, esi_15, out ecx_116, out edx_117);
			if (edi_45 == 0x00)
				break;
			esi_15 = edi_45;
		}
	}
}

// 080A1050: void _nl_unload_domain(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _nl_finddomain_subfreeres
void _nl_unload_domain(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 eax_20 = *((word32) dwArg04 + 96);
	if (eax_20 != 0x080CC6C0)
		__gettext_free_exp(gs, eax_20);
	if (*((word32) dwArg04 + 60) != 0x00)
	{
		Eq_2 esi_106 = 0x00;
		do
		{
			struct Eq_149771 * edi_55 = (word32) *((word32) dwArg04 + 56) + esi_106 * 0x0C;
			word32 edx_308;
			word32 ecx_307;
			free(gs, dwLoc30, edi_55->t0000, out ecx_307, out edx_308);
			Eq_2 eax_67 = edi_55->t0008;
			if (eax_67 <= ~0x01)
			{
				word32 ecx_311;
				word32 edx_312;
				free(gs, dwLoc30, eax_67, out ecx_311, out edx_312);
			}
			Eq_2 eax_87 = edi_55->t0004;
			if (eax_87 != ~0x00)
			{
				word32 ecx_313;
				word32 edx_314;
				__gconv_close(eax_87, out ecx_313, out edx_314);
			}
			esi_106 = (word32) esi_106 + 1;
		} while (*((word32) dwArg04 + 60) > esi_106);
	}
	word32 ecx_305;
	word32 edx_306;
	free(gs, dwLoc30, *((word32) dwArg04 + 56), out ecx_305, out edx_306);
	word32 edx_310;
	word32 ecx_309;
	free(gs, dwLoc30, *((word32) dwArg04 + 16), out ecx_309, out edx_310);
	if (*((word32) dwArg04 + 4) != 0x00)
	{
		word32 ecx_317;
		word32 edx_318;
		word32 ebx_319;
		__munmap(0x080CE000, gs, *dwArg04, *((word32) dwArg04 + 8), out ecx_317, out edx_318, out ebx_319);
	}
	else
	{
		word32 edx_316;
		word32 ecx_315;
		free(gs, dwLoc30, *dwArg04, out ecx_315, out edx_316);
	}
	word32 ecx_320;
	word32 edx_321;
	free(gs, dwLoc30, dwArg04, out ecx_320, out edx_321);
}

// 080A1150: void buffer_free(Register (ptr32 Eq_9) gs)
void buffer_free(struct Eq_9 * gs)
{
	Eq_2 esi_13 = freeres_list;
	g_b80CF82C = 0x01;
	if (esi_13 != 0x00)
	{
		Eq_2 esi_18 = esi_13;
		do
		{
			word32 ecx_72;
			word32 edx_73;
			free(gs, dwLoc20, *((word32) esi_18 + 96), out ecx_72, out edx_73);
			esi_18 = *((word32) esi_18 + 92);
			freeres_list = esi_18;
		} while (esi_18 != 0x00);
	}
}

// 080A11A0: void free_derivation(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void free_derivation(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ecx_21 = *((word32) dwArg04 + 8);
	if (*((word32) dwArg04 + 0x0C) != 0x00)
	{
		Eq_149896 esi_29 = 0x00;
		do
		{
			int32 ebp_31 = esi_29 *s 0x3C;
			struct Eq_149909 * eax_33 = (word32) ecx_21 + ebp_31;
			if (eax_33->dw0008 > 0x00 && eax_33->dw0000 != 0x00)
			{
				Eq_2 edi_46 = __ror(eax_33->t0020, 0x09) ^ gs->t0018;
				if (edi_46 != 0x00)
				{
					word32 ecx_208;
					word32 edx_209;
					_dl_mcount_wrapper_check(gs, dwLoc30, edi_46, out ecx_208, out edx_209);
					edi_46();
					ecx_21 = *((word32) dwArg04 + 8);
				}
			}
			esi_29 = (word32) esi_29 + 1;
		} while (*((word32) dwArg04 + 0x0C) > esi_29);
	}
	if (ecx_21 != 0x00)
	{
		word32 ecx_212;
		word32 edx_213;
		free(gs, dwLoc30, *((word32) ecx_21 + 0x0C), out ecx_212, out edx_213);
		word32 ecx_214;
		word32 edx_215;
		free(gs, dwLoc30, (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 0x0C) *s 0x3C + -44, out ecx_214, out edx_215);
		word32 ecx_216;
		word32 edx_217;
		free(gs, dwLoc30, *((word32) dwArg04 + 8), out ecx_216, out edx_217);
	}
	word32 ecx_210;
	word32 edx_211;
	free(gs, dwLoc30, dwArg04, out ecx_210, out edx_211);
}

// 080A1270: void free_modules_db(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      free_modules_db
//      free_mem
void free_modules_db(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2 esi_11 = eax;
	Eq_2 eax_15 = *((word32) eax + 20);
	if (eax_15 != 0x00)
		free_modules_db(eax_15, gs);
	Eq_2 eax_25 = *((word32) eax + 28);
	if (eax_25 != 0x00)
		free_modules_db(eax_25, gs);
	do
	{
		Eq_2 edi_38 = *((word32) esi_11 + 24);
		if (**((word32) esi_11 + 16) == 0x2F)
		{
			word32 ecx_112;
			word32 edx_113;
			free(gs, dwLoc20, esi_11, out ecx_112, out edx_113);
			esi_11 = edi_38;
			if (edi_38 == 0x00)
				return;
			continue;
		}
		esi_11 = edi_38;
	} while (edi_38 != 0x00);
}

// 080A12D0: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	struct Eq_150032 * ebx_13 = _nl_locale_subfreeres(gs);
	_nl_finddomain_subfreeres(gs);
	Eq_2 eax_28 = ebx_13->t1F84;
	if (eax_28 != 0x00)
		tdestroy(gs, eax_28, ebx_13->ptrFFFFFFEC);
	Eq_2 eax_50 = ebx_13->t1F7C;
	if (eax_50 != 0x00)
		free_modules_db(eax_50, gs);
	Eq_2 eax_64 = ebx_13->t1940;
	if (eax_64 != 0x00)
		tdestroy(gs, eax_64, (char *) ebx_13 - 0x0002CE60);
}

// 080A1340: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 eax_10 = __gconv_path_elem;
	if (eax_10 != 0x00 && eax_10 != 0x080A52A8)
	{
		word32 ecx_51;
		word32 edx_52;
		free(gs, dwLoc20, eax_10, out ecx_51, out edx_52);
	}
}

// 080A1380: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 eax_11 = gconv_cache;
	if (cache_malloced != 0x00)
	{
		word32 ecx_87;
		word32 edx_88;
		free(gs, dwLoc20, eax_11, out ecx_87, out edx_88);
	}
	else if (eax_11 != 0x00)
	{
		word32 ecx_89;
		word32 edx_90;
		word32 ebx_91;
		__munmap(0x080CE000, gs, eax_11, cache_size, out ecx_89, out edx_90, out ebx_91);
	}
}

// 080A13E0: void do_release_all(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void do_release_all(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 8) != 0x00)
	{
		word32 ecx_69;
		__libc_dlclose(out ecx_69);
	}
	word32 edx_68;
	word32 ecx_67;
	free(gs, dwLoc20, dwArg04, out ecx_67, out edx_68);
}

// 080A1420: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	tdestroy(gs, loaded, &g_t80A13E0);
	loaded.u0 = 0x00;
}

// 080A1460: void free_category(Register ui32 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_locale_subfreeres
void free_category(ui32 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 esi_130 = *((char *) g_a80CFFA0 + eax * 0x04);
	if (edx != ecx)
	{
		if (g_a80CE140[eax * 0x04] != 0x00)
		{
			<anonymous> * eax_32 = *((char *) g_a80CE180 + eax * 0x04);
			*((char *) &g_ptr80CEE60 + eax * 0x04) = (struct Eq_70762 **) ecx;
			if (eax_32 != null)
				eax_32();
		}
		Eq_2 ecx_50 = *((char *) &g_ptr80CEE60 + (eax + 0x10) * 0x04);
		if (ecx_50 != 134892338)
		{
			word32 edx_205;
			word32 ecx_204;
			free(gs, dwLoc40, ecx_50, out ecx_204, out edx_205);
			*((char *) &g_ptr80CEE60 + (eax + 0x10) * 0x04) = 134892338;
		}
	}
	if (esi_130 != 0x00)
	{
		while (true)
		{
			Eq_2 eax_79 = *((word32) esi_130 + 8);
			if (eax_79 != 0x00 && ecx != eax_79)
				_nl_unload_locale(gs, eax_79);
			Eq_2 ebp_106 = *((word32) esi_130 + 0x0C);
			word32 edx_201;
			word32 ecx_200;
			free(gs, dwLoc40, *esi_130, out ecx_200, out edx_201);
			word32 ecx_202;
			word32 edx_203;
			free(gs, dwLoc40, esi_130, out ecx_202, out edx_203);
			if (ebp_106 == 0x00)
				break;
			esi_130 = ebp_106;
		}
	}
}

// 080A1520: Register word32 _nl_locale_subfreeres(Register (ptr32 Eq_9) gs)
// Called from:
//      free_mem
word32 _nl_locale_subfreeres(struct Eq_9 * gs)
{
	free_category(0x00, 0x080CC740, gs->ptrFFFFFFD0->t0000, gs);
}

// 080A1720: Register ptr32 _nl_archive_subfreeres(Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_locale_subfreeres
ptr32 _nl_archive_subfreeres(struct Eq_9 * gs)
{
	Eq_2 edi_105 = archloaded;
	if (edi_105 == 0x00)
	{
l080A179F:
		archloaded.u0 = 0x00;
		ptr32 eax_122 = archmapped;
		if (eax_122 == 0x00)
			return ebx;
		if (eax_122 != 0x080CFA00)
		{
			Eq_2 edx_142;
			word32 ecx_328;
			__assert_fail(out ecx_328, out edx_142);
			free_mem(edx_142, gs);
			return 0x080CE000;
		}
		else
		{
			archmapped = 0x00;
			word32 edx_330;
			word32 ecx_329;
			Eq_2 ebx_167;
			__munmap(0x080CE000, gs, g_t80CFA00, g_t80CFA08, out ecx_329, out edx_330, out ebx_167);
			Eq_2 esi_174 = *((word32) ebx_167 + 6668);
			if (esi_174 != 0x00)
			{
				Eq_2 esi_179 = esi_174;
				do
				{
					Eq_2 edi_185 = *((word32) esi_179 + 0x0C);
					word32 ecx_331;
					word32 edx_332;
					__munmap(ebx_167, gs, *esi_179, *((word32) esi_179 + 8), out ecx_331, out edx_332, out ebx_167);
					word32 ecx_333;
					word32 edx_334;
					free(gs, dwLoc30, esi_179, out ecx_333, out edx_334);
					esi_179 = edi_185;
				} while (edi_185 != 0x00);
			}
			return ebx;
		}
	}
l080A1740:
	Eq_2 ebp_27 = *edi_105;
	word32 ecx_326;
	word32 edx_327;
	free(gs, dwLoc30, *((word32) edi_105 + 4), out ecx_326, out edx_327);
	ui32 esi_31 = 0x00;
	while (true)
	{
		if (esi_31 != 0x06)
		{
			Eq_2 eax_49 = *((word32) edi_105 + (esi_31 * 0x04 + 8));
			if (eax_49 != 0x00)
			{
				<anonymous> * edx_53 = *((word32) eax_49 + 16);
				if (edx_53 != null)
				{
					word32 edx_66;
					word32 ecx_67;
					edx_53();
					eax_49 = *((word32) edi_105 + (esi_31 * 0x04 + 8));
				}
				word32 edx_336;
				word32 ecx_335;
				free(gs, dwLoc30, eax_49, out ecx_335, out edx_336);
			}
			if (esi_31 == 0x0C)
			{
				word32 ecx_337;
				word32 edx_338;
				free(gs, dwLoc30, edi_105, out ecx_337, out edx_338);
				edi_105 = ebp_27;
				if (ebp_27 == 0x00)
					goto l080A179F;
				goto l080A1740;
			}
		}
		++esi_31;
	}
}

// 080A1840: void free_mem(Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_archive_subfreeres
void free_mem(Eq_2 edx, struct Eq_9 * gs)
{
	__clearenv(edx, gs);
	tdestroy(gs, known_values, *(<anonymous> **) 0x080CE014);
	known_values.u0 = 0x00;
}

// 080A1880: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 edx_15 = __printf_modifier_table;
	if (edx_15 != 0x00)
	{
		int32 edi_19;
		for (edi_19 = 0x00; edi_19 != 1020; edi_19 += 0x04)
		{
			Eq_2 eax_25 = *((word32) edx_15 + edi_19);
			if (eax_25 != 0x00)
			{
				do
				{
					Eq_2 esi_36 = *eax_25;
					word32 edx_131;
					word32 ecx_130;
					free(gs, dwLoc20, eax_25, out ecx_130, out edx_131);
					eax_25 = esi_36;
				} while (esi_36 != 0x00);
				edx_15 = __printf_modifier_table;
			}
		}
		word32 edx_133;
		word32 ecx_132;
		free(gs, dwLoc20, edx_15, out ecx_132, out edx_133);
	}
}

// 080A18F0: Register byte free_slotinfo(Register (ptr32 Eq_2) eax, Register (ptr32 Eq_9) gs)
// Called from:
//      free_slotinfo
//      free_mem
byte free_slotinfo(union Eq_2 * eax, struct Eq_9 * gs)
{
	Eq_2 edx_17 = *eax;
	if (edx_17 == 0x00)
		return 0x01;
	uint32 eax_133 = (uint32) free_slotinfo((word32) edx_17 + 4, gs);
	byte al_36 = (byte) eax_133;
	if (al_36 == 0x00)
		return (byte) eax_133;
	Eq_2 ecx_40 = *eax;
	ui32 edi_41 = *ecx_40;
	if (edi_41 == 0x00)
	{
l080A193E:
		word32 ecx_162;
		word32 edx_163;
		free(gs, dwLoc30, ecx_40, out ecx_162, out edx_163);
		*eax = (union Eq_2 *) 0x00;
		eax_133 = (word32) al_36;
		return (byte) eax_133;
	}
	else
	{
		if (*((word32) ecx_40 + 0x0C) == 0x00)
		{
			ui32 edx_49 = 0x00;
			do
			{
				++edx_49;
				if (edx_49 == edi_41)
					goto l080A193E;
			} while (*((word32) ecx_40 + (edx_49 * 0x08 + 0x0C)) == 0x00);
		}
		return 0x00;
	}
}

// 080A1980: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 eax_21 = _dl_all_dirs;
	if (eax_21 != _dl_init_all_dirs)
	{
		do
		{
			Eq_2 esi_30 = *eax_21;
			word32 edx_266;
			word32 ecx_265;
			free(gs, dwLoc30, eax_21, out ecx_265, out edx_266);
			eax_21 = esi_30;
		} while (_dl_init_all_dirs != esi_30);
	}
	if (_dl_nns != 0x00)
	{
		Eq_2 ebp_122 = g_t80CEA00;
		while (ebp_122 != 0x00)
		{
			struct Eq_150574 * edx_61 = *((word32) ebp_122 + 28);
			Eq_2 eax_62 = edx_61->t0004;
			edx_61->t0004.u0 = 0x00;
			if (eax_62 != 0x00)
			{
				do
				{
					Eq_2 esi_70 = *((word32) eax_62 + 4);
					if (*((word32) eax_62 + 8) == 0x00)
					{
						word32 ecx_269;
						word32 edx_270;
						free(gs, dwLoc30, eax_62, out ecx_269, out edx_270);
						eax_62 = esi_70;
						if (esi_70 == 0x00)
							break;
						continue;
					}
					eax_62 = esi_70;
				} while (esi_70 != 0x00);
			}
			if ((*((word32) ebp_122 + 410) & 0x01) != 0x00)
			{
				word32 edx_272;
				word32 ecx_271;
				free(gs, dwLoc30, *((word32) ebp_122 + 500), out ecx_271, out edx_272);
			}
			((word32) ebp_122 + 500)->u0 = 0x00;
			ebp_122 = *((word32) ebp_122 + 0x0C);
		}
		if (g_dw80CEA0C != 0x00)
		{
			struct Eq_150587 * eax_137 = g_ptr80CEA08;
			if (eax_137->dw0004 == g_dw80CE9EC)
			{
				Eq_2 ecx_141 = eax_137->t0000;
				eax_137->t0000 = g_t80CE9E8;
				g_dw80CEA0C = 0x00;
				word32 edx_274;
				word32 ecx_273;
				free(gs, dwLoc30, ecx_141, out ecx_273, out edx_274);
			}
		}
	}
	free_slotinfo((word32) _dl_tls_dtv_slotinfo_list + 4, gs);
	Eq_2 edx_182 = _dl_scope_free_list;
	_dl_scope_free_list.u0 = 0x00;
	word32 ecx_267;
	word32 edx_268;
	free(gs, dwLoc30, edx_182, out ecx_267, out edx_268);
}

// subject_libc_freeres_ptrs.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_2 map = // 080CFFE0
	{
		0
	};
Eq_2 string_space = // 080CFFE4
	{
		0
	};
Eq_2 __printf_arginfo_table = // 080CFFE8
	{
		0
	};
word32 __printf_va_arg_table = 0x00; // 080CFFEC
word32 buf = 0x00; // 080CFFF0
// subject_libc_subfreeres.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 __elf_set___libc_subfreeres_element_buffer_free__ = 0x080A1150; // 080CEF64
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A12D0; // 080CEF68
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1340; // 080CEF6C
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1380; // 080CEF70
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1420; // 080CEF74
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1840; // 080CEF78
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1880; // 080CEF7C
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1980; // 080CEF80
// subject_rodata_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _fp_hw = 0x03; // 080A2000
word32 _IO_stdin_used = 0x00020001; // 080A2004
int32 g_a80A2260[] = // 080A2260
	{
	};
cu8 g_b80A22B7 = 0x50; // 080A22B7
Eq_3689 g_t80A2310 = // 080A2310
	{
		0x2F
	};
Eq_2 g_t80A2314 = // 080A2314
	{
		97
	};
Eq_2 g_t80A2318 = // 080A2318
	{
		97
	};
Eq_2 g_t80A231C = // 080A231C
	{
		115
	};
word32 g_a80A2320[] = // 080A2320
	{
	};
int32 g_a80A2358[] = // 080A2358
	{
	};
Eq_9513 g_t80A25C0 = // 080A25C0
	{
		
		{
		},
	};
Eq_9778 g_t80A25F7 = // 080A25F7
	{
		
		{
		},
	};
Eq_9605 g_t80A261C = // 080A261C
	{
		
		{
		},
	};
Eq_9503 g_t80A2640 = // 080A2640
	{
		
		{
		},
	};
word32 g_dw80A3AA0 = 0x4E415254; // 080A3AA0
word32 g_a80A3C28[] = // 080A3C28
	{
	};
cu8 g_b80A4132 = 0x70; // 080A4132
cu8 g_b80A4150 = 99; // 080A4150
word32 g_a80A4500[] = // 080A4500
	{
	};
cu8 g_b80A4B32 = 0x43; // 080A4B32
word32 g_a80A4BD8[] = // 080A4BD8
	{
	};
word32 g_a80A4C34[] = // 080A4C34
	{
	};
cu8 g_b80A4D0B = 0x2D; // 080A4D0B
cu8 g_b80A4E24 = 0x2F; // 080A4E24
word32 gconv_module_ext = 7303982; // 080A4E98
word32 g_dw80A4E9C = 0x6E6F6367; // 080A4E9C
word32 g_dw80A4EA0 = 0x6F6D2D76; // 080A4EA0
word32 g_dw80A4EA4 = 1701606756; // 080A4EA4
word16 g_w80A4EA8 = 115; // 080A4EA8
word32 g_dw80A4EAC = 0x7273752F; // 080A4EAC
Eq_53608 g_t80A4EB0 = // 080A4EB0
	{
		0x2F
	};
Eq_9870 g_t80A4EB4 = // 080A4EB4
	{
		0x2F
	};
Eq_53618 g_t80A4EB8 = // 080A4EB8
	{
		110
	};
Eq_2 g_t80A4EBA = // 080A4EBA
	{
		0
	};
Eq_60612 g_t80A57FE = // 080A57FE
	{
		
		{
		},
	};
Eq_66795 g_t80A58D0 = // 080A58D0
	{
		
		{
		},
	};
word32 slashdot.10224 = 0x2F2E2E2F; // 080A599C
uint32 g_a80A6060[] = // 080A6060
	{
	};
word32 g_dw80B1B80 = ~0x00; // 080B1B80
Eq_11402 g_t80B1C00 = // 080B1C00
	{
		
		{
		},
	};
Eq_11402 g_t80B1C06 = // 080B1C06
	{
		
		{
		},
	};
Eq_11402 g_t80B1C08 = // 080B1C08
	{
		
		{
		},
	};
Eq_2 g_a80B1C38[] = // 080B1C38
	{
	};
Eq_2 g_a80B1C40[] = // 080B1C40
	{
	};
Eq_2 g_t80B1C58 = // 080B1C58
	{
		-1
	};
Eq_2 g_t80B1C60 = // 080B1C60
	{
		-0x0067
	};
word128 g_ow80B1ED0 = // 080B1ED0
	{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
	};
word128 g_ow80B1EE0 = // 080B1EE0
	{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 
	};
Eq_81103 g_t80B1EF0 = // 080B1EF0
	{
		
		{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		}
	};
Eq_81107 g_t80B1F00 = // 080B1F00
	{
		1.7976931348623157e+308
	};
// subject_rodata_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_a80B201C[] = // 080B201C
	{
	};
word32 g_a80B20C4[] = // 080B20C4
	{
	};
word32 g_a80B2180[] = // 080B2180
	{
	};
word32 g_a80B2260[] = // 080B2260
	{
	};
word32 g_a80B2308[] = // 080B2308
	{
	};
word32 g_a80B23C4[] = // 080B23C4
	{
	};
byte g_b80B24A4 = 0x30; // 080B24A4
byte g_b80B24B4 = 0x20; // 080B24B4
word32 g_dw80B24E0 = 0x30; // 080B24E0
word32 g_dw80B2520 = 0x20; // 080B2520
word32 g_a80B2600[] = // 080B2600
	{
	};
Eq_103454 g_t80B29EC = // 080B29EC
	{
		0x2F
	};
struct Eq_109498 g_t80B2BAF = // 080B2BAF
	{
		
		{
			&g_t73006269
		},
		99,
	};
word32 g_dw80B3178 = 0x464C457F; // 080B3178
Eq_104683 g_t80B317C = // 080B317C
	{
		0x01
	};
word32 g_dw80B3184 = 0x464C457F; // 080B3184
Eq_104683 g_t80B3188 = // 080B3188
	{
		0x01
	};
word32 g_dw80B318D = 0x00; // 080B318D
word16 g_w80B3191 = 0x00; // 080B3191
byte g_b80B3193 = 0x00; // 080B3193
word32 dummy_bucket.11389 = 0x00; // 080B31A4
struct Eq_119859 g_t80B3B60 = // 080B3B60
	{
		116,
		0x6C,
		115,
	};
up32 g_dw80B3C20 = 0x07; // 080B3C20
up32 g_dw80B3C98 = 540701477; // 080B3C98
struct Eq_47724 g_t80B3F32 = // 080B3F32
	{
		0x2F,
		1296125529,
		0x4C204349,
		&g_t61646972,
	};
word32 g_dw80B41F9 = 0x25000200; // 080B41F9
struct Eq_81004 g_t80B4E70 = // 080B4E70
	{
		884,
		0x0355,
		0x00006A4A,
	};
Eq_114846 g_t80B8620 = // 080B8620
	{
		
		{
		},
	};
byte g_a80B8660[] = // 080B8660
	{
	};
Eq_2 g_a80B86A0[] = // 080B86A0
	{
	};
Eq_2 g_a80B8740[] = // 080B8740
	{
	};
Eq_2 _sys_nerr_internal = // 080B941C
	{
		-121
	};
cu8 g_b80B9420 = 111; // 080B9420
word32 g_a80B9460[] = // 080B9460
	{
	};
union Eq_113724 g_u80B982E = // 080B982E
	{
		1918986355
	};
word32 g_a80B9E58[] = // 080B9E58
	{
	};
word32 g_a80B9E8C[] = // 080B9E8C
	{
	};
word32 g_a80B9F4C[] = // 080B9F4C
	{
	};
word32 g_a80BA374[] = // 080BA374
	{
	};
struct Eq_147554 g_t80BA3A8 = // 080BA3A8
	{
		0x00,
		0x00,
	};
word32 g_a80BA3B0[] = // 080BA3B0
	{
	};
// subject_tbss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a80CC6B0[] = // 080CC6B0
	{
	};
// subject_text_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049030: void __assert_fail_base.cold.0()
// Called from:
//      __assert_fail_base
void __assert_fail_base.cold.0()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	Eq_2 stackArg4 = <invalid>;
	word32 ecx_21;
	word32 edx_22;
	free(gs, stackArg0, stackArg4, out ecx_21, out edx_22);
	word32 ecx_24;
	word32 edx_25;
	abort(ecx, gs, out ecx_24, out edx_25);
	_nl_load_domain.cold.0();
}

// 08049044: void _nl_load_domain.cold.0()
// Called from:
//      __assert_fail_base
//      _nl_load_domain
void _nl_load_domain.cold.0()
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
	word32 ecx_8;
	word32 edx_9;
	abort(ecx, gs, out ecx_8, out edx_9);
}

// 08049049: Register word32 abort(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _dl_start
//      read_encoded_value_with_base.cold.6
//      execute_cfa_program.cold.7
//      _Unwind_RaiseException_Phase2.cold.12
//      _Unwind_Resume.cold.16
//      _Unwind_Resume_or_Rethrow.cold.17
//      read_encoded_value_with_base.cold.8
//      read_encoded_value_with_base.cold.0
//      __assert_fail_base
//      _nl_load_domain
//      __libc_message
//      __malloc_assert
//      __printf_fp_l
//      __printf_fphex
//      base_of_encoded_value
//      uw_frame_state_for
//      execute_stack_op
//      uw_update_context_1
//      uw_init_context_1
//      uw_update_context
//      uw_install_context_1
//      _Unwind_GetGR
//      _Unwind_SetGR
//      size_of_encoded_value
//      base_from_object
//      base_from_cb_data
//      _Unwind_IteratePhdrCallback
//      search_object
//      __deregister_frame_info_bases
//      base_of_encoded_value
word32 abort(Eq_2 ecx, struct Eq_9 * gs, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_2 edx_110 = gs->t0008;
	if (g_t80CF5F4 != edx_110)
	{
		ecx.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_27;
		if (!__cmpxchg(g_t80CF5EC, 0x01, 0x00, out eax_27))
			ecx = __lll_lock_wait_private(eax_27, 0x080CF5EC, gs);
		g_t80CF5F4 = edx_110;
	}
	++g_dw80CF5F0;
	if (stage == 0x00)
	{
		stage = 0x01;
		ui32 eax_48 = 0x20;
		while (true)
		{
			--eax_48;
			if (eax_48 == ~0x00)
				break;
			(fp - 0x011C)[eax_48] = 0x00;
		}
		ecx = sigprocmask(gs, 0x01, fp - 0x011C, 0x00, out edx_110);
	}
	word32 eax_81 = stage;
	if (eax_81 == 0x01)
	{
		word32 v14_86 = g_dw80CF5F0 - 0x01;
		g_dw80CF5F0 = v14_86;
		stage = 0x00;
		if (v14_86 == 0x00)
		{
			g_t80CF5F4.u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v16_99 = g_t80CF5EC - 0x01;
			g_t80CF5EC = v16_99;
			if (v16_99 != 0x00)
				__lll_unlock_wake_private(0x080CF5EC, ecx, edx_110, gs);
		}
		raise(gs, 0x06);
		Eq_2 edx_144 = gs->t0008;
		if (g_t80CF5F4 != edx_144)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_155;
			if (!__cmpxchg(g_t80CF5EC, 0x01, 0x00, out eax_155))
				__lll_lock_wait_private(eax_155, 0x080CF5EC, gs);
			g_t80CF5F4 = edx_144;
		}
		++g_dw80CF5F0;
	}
	else if (eax_81 != 0x02)
		goto l080491CE;
	stage = 0x03;
	word32 ecx_182;
	word32 * edi_185 = fp - 0x9C;
	for (ecx_182 = 0x23; ecx_182 != 0x00; --ecx_182)
	{
		*edi_185 = 0x00;
		++edi_185;
	}
	ui32 eax_187 = 33;
	while (true)
	{
		--eax_187;
		if (eax_187 == 0x00)
			break;
		(fp - 0x9C)[eax_187] = ~0x00;
	}
	__sigaction(gs, 0x06);
l080491CE:
	if (stage == 0x03)
	{
		stage = 0x04;
		raise(gs, 0x06);
	}
	if (stage != 0x04)
	{
		if (stage != 0x05)
			__hlt();
		else
		{
			stage = 0x06;
			_exit(gs, 0x7F);
		}
	}
	else
	{
		stage = 0x05;
		__hlt();
	}
}

// 08049222: void _IO_new_fclose.cold.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_277) esi, Register (ptr32 Eq_9) gs)
void _IO_new_fclose.cold.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_277 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		edx = esi->t0048;
		Eq_305 v8_10 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx - 0x01;
			*edx = v14_20;
			if (v14_20 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	Eq_2 ecx_47;
	Eq_2 edx_48;
	Eq_2 eax_46 = _Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_47, out edx_48);
	_IO_fflush.cold.0(eax_46, ecx_47, edx_48, esi, gs);
}

// 0804925C: void _IO_fflush.cold.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_277) esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_new_fclose.cold.0
void _IO_fflush.cold.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_277 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		edx = esi->t0048;
		Eq_305 v8_10 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx - 0x01;
			*edx = v14_20;
			if (v14_20 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	Eq_2 ecx_47;
	Eq_2 edx_48;
	Eq_2 eax_46 = _Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_47, out edx_48);
	_IO_puts.cold.0(eax_46, ecx_47, edx_48, esi, gs);
}

// 08049296: void _IO_puts.cold.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_277) esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_fflush.cold.0
void _IO_puts.cold.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_277 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		edx = esi->t0048;
		Eq_305 v8_10 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx - 0x01;
			*edx = v14_20;
			if (v14_20 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	word32 edx_59;
	word32 ecx_58;
	_Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_58, out edx_59);
}

// 080492D0: void _IO_wfile_underflow.cold.2(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_461) ebp, Register Eq_2 esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_puts.cold.0
//      _IO_wfile_underflow
void _IO_wfile_underflow.cold.2(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_461 * ebp, Eq_2 esi, struct Eq_9 * gs)
{
	if ((*esi & 0x8000) == 0x00)
	{
		edx = *((word32) esi + 72);
		Eq_305 v8_16 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_16;
		if (v8_16 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_26 = *edx - 0x01;
			*edx = v14_26;
			if (v14_26 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	Eq_2 ecx_54;
	Eq_2 edx_55;
	_Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_54, out edx_55);
	_IO_new_file_underflow.cold.6(ecx_54, edx_55, ebp, gs);
}

// 0804930B: void _IO_new_file_underflow.cold.6(Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_461) ebp, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_wfile_underflow.cold.2
void _IO_new_file_underflow.cold.6(Eq_2 ecx, Eq_2 edx, struct Eq_461 * ebp, struct Eq_9 * gs)
{
	Eq_2 eax_33 = ebp->tFFFFFFDC;
	int32 ebx_7 = *eax_33;
	ebp->dwFFFFFFE4 = ebx_7;
	if ((SLICE(ebx_7, byte, 8) & 0x80) == 0x00)
	{
		edx = *((word32) eax_33 + 72);
		Eq_305 v11_15 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v11_15;
		if (v11_15 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v16_25 = *edx - 0x01;
			*edx = v16_25;
			if (v16_25 != 0x00)
				eax_33 = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	word32 edx_62;
	Eq_2 ecx_51;
	_Unwind_Resume(eax_33, edx, gs, dwLoc14, ecx, out ecx_51, out edx_62);
	_dl_start(ecx_51, gs);
}

// 0804934A: void _dl_start(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_new_file_underflow.cold.6
void _dl_start(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_14;
	word32 edx_15;
	abort(ecx, gs, out ecx_14, out edx_15);
}

// 08049358: void _IO_fputs.cold.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_596) esi, Register (ptr32 Eq_597) edi, Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_start
void _IO_fputs.cold.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_596 * esi, struct Eq_597 * edi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		edx = esi->t0048;
		Eq_305 v8_10 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx - 0x01;
			*edx = v14_20;
			if (v14_20 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	Eq_2 ecx_47;
	Eq_2 edx_48;
	Eq_2 eax_46 = _Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_47, out edx_48);
	_IO_fwrite.cold.0(eax_46, ecx_47, edx_48, esi, edi, gs);
}

// 08049392: void _IO_fwrite.cold.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_596) esi, Register (ptr32 Eq_597) edi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_fputs.cold.0
void _IO_fwrite.cold.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_596 * esi, struct Eq_597 * edi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		edx = esi->t0048;
		Eq_305 v8_10 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx - 0x01;
			*edx = v14_20;
			if (v14_20 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	Eq_2 ecx_47;
	Eq_2 edx_48;
	Eq_2 eax_46 = _Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_47, out edx_48);
	_IO_getdelim.cold.0(eax_46, ecx_47, edx_48, edi, gs);
}

// 080493CC: void _IO_getdelim.cold.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_597) edi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_fwrite.cold.0
void _IO_getdelim.cold.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_597 * edi, struct Eq_9 * gs)
{
	if ((edi->dw0000 & 0x8000) == 0x00)
	{
		edx = edi->t0048;
		Eq_305 v8_10 = *((word32) edx + 4) - 0x01;
		*((word32) edx + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx - 0x01;
			*edx = v14_20;
			if (v14_20 != 0x00)
				eax = __lll_unlock_wake_private(edx, ecx, edx, gs);
		}
	}
	word32 edx_59;
	Eq_2 ecx_48;
	_Unwind_Resume(eax, edx, gs, dwLoc14, ecx, out ecx_48, out edx_59);
	read_encoded_value_with_base.cold.6(ecx_48, gs);
}

// 08049407: void read_encoded_value_with_base.cold.6(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_getdelim.cold.0
//      read_encoded_value_with_base
void read_encoded_value_with_base.cold.6(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
}

// 0804940C: void execute_cfa_program.cold.7(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      read_encoded_value_with_base.cold.6
//      execute_cfa_program
void execute_cfa_program.cold.7(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_14;
	word32 ecx_13;
	abort(ecx, gs, out ecx_13, out edx_14);
}

// 08049414: void execute_stack_op.cold.8(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      execute_cfa_program.cold.7
//      execute_stack_op
void execute_stack_op.cold.8(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_9;
	word32 edx_10;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 0804941D: void uw_update_context_1.cold.9(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      execute_stack_op
//      uw_update_context_1
void uw_update_context_1.cold.9(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_9;
	word32 edx_10;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 08049426: void uw_init_context_1.cold.10(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_update_context_1
//      uw_init_context_1
void uw_init_context_1.cold.10(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_9;
	word32 ecx_8;
	abort(ecx, gs, out ecx_8, out edx_9);
}

// 0804942B: void uw_update_context.cold.11(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_init_context_1
//      uw_update_context
void uw_update_context.cold.11(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_11;
	word32 ecx_10;
	abort(ecx, gs, out ecx_10, out edx_11);
}

// 08049430: void _Unwind_RaiseException_Phase2.cold.12(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_update_context
//      _Unwind_RaiseException_Phase2
void _Unwind_RaiseException_Phase2.cold.12(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_13;
	word32 edx_14;
	abort(ecx, gs, out ecx_13, out edx_14);
}

// 08049439: void uw_install_context_1.cold.13(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_RaiseException_Phase2.cold.12
//      uw_install_context_1
void uw_install_context_1.cold.13(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_9;
	word32 edx_10;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 08049442: void _Unwind_GetGR.cold.14(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_install_context_1
//      _Unwind_GetGR
void _Unwind_GetGR.cold.14(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
}

// 08049447: void _Unwind_SetGR.cold.15(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_GetGR
//      _Unwind_SetGR
void _Unwind_SetGR.cold.15(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_10;
	word32 ecx_9;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 0804944E: void _Unwind_Resume.cold.16(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_SetGR
//      _Unwind_Resume
void _Unwind_Resume.cold.16(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_12;
	word32 ecx_11;
	abort(ecx, gs, out ecx_11, out edx_12);
}

// 08049459: void _Unwind_Resume_or_Rethrow.cold.17(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_Resume.cold.16
//      _Unwind_Resume_or_Rethrow
void _Unwind_Resume_or_Rethrow.cold.17(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_14;
	word32 ecx_13;
	abort(ecx, gs, out ecx_13, out edx_14);
}

// 08049464: void read_encoded_value_with_base.cold.8(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_Resume_or_Rethrow.cold.17
//      read_encoded_value_with_base
void read_encoded_value_with_base.cold.8(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
}

// 08049469: void read_encoded_value_with_base.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      read_encoded_value_with_base.cold.8
//      read_encoded_value_with_base
void read_encoded_value_with_base.cold.0(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_11;
	word32 ecx_10;
	abort(ecx, gs, out ecx_10, out edx_11);
}

// 08049470: void fini(Register (ptr32 Eq_9) gs)
// Called from:
//      read_encoded_value_with_base.cold.0
void fini(struct Eq_9 * gs)
{
	check_free.isra.0(0x080CFA9C, gs);
}

// 08049490: void main(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void main(struct Eq_9 * gs, Eq_2 dwArg04)
{
	__align(fp);
	_IO_puts(gs, 0x080A200C);
	_IO_printf(dwArg04, gs, 0x080A2018);
}

// 080494D0: void init_cacheinfo(Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 ebx, Register (ptr32 Eq_916) gs, Stack Eq_2 dwArg14, Stack Eq_2 dwArg20)
void init_cacheinfo(Eq_2 ecx, Eq_2 edx, Eq_2 ebx, struct Eq_916 * gs, Eq_2 dwArg14, Eq_2 dwArg20)
{
	Eq_2 ecx_117;
	Eq_2 esi_100;
	Eq_2 eax_506;
	int32 eax_494;
	struct Eq_923 * edi_11 = &g_t80CE000;
	struct Eq_925 * esp_18 = fp - 0x4C;
	struct Eq_929 * ebp_19 = &g_t80CF8E0;
	Eq_2 eax_20 = g_t80CF8E0;
	if (eax_20 != 0x01)
	{
		if (eax_20 != 0x02)
		{
			eax_494 = g_dw80CF92C;
			if (eax_494 == 0x00)
			{
				ecx_117 = g_t80CF930;
				if (ecx_117 == 0x00)
					goto l08049570;
				eax_506 = ecx_117;
				ecx_117.u0 = 0x00;
l0804959D:
				esi_100 = eax_506;
				goto l08049548;
			}
			ecx_117.u0 = 0x00;
			esi_100.u0 = ~0x00;
l08049511:
			esp_18->dw000C = eax_494;
l08049515:
			int32 edx_520 = esp_18->dw000C;
			if (edx_520 > 0x00)
			{
				edi_11->dw0EEC = edx_520;
				edi_11->dw0EF0 = edx_520 >> 0x01;
				int32 eax_540 = SEQ(SLICE(edx_520, word24, 8), 0x00);
				edi_11->dw0EF4 = eax_540;
				edi_11->dw0EF8 = eax_540 >> 0x01;
			}
			eax_506 = ebp_19->t0050;
			if (eax_506 == 0x00)
			{
l08049548:
				if (esi_100 > 0x00)
				{
					edi_11->t0EDC = esi_100;
					edi_11->dw0EE0 = esi_100 >> 0x01;
					int32 eax_573 = SEQ(SLICE(esi_100, word24, 8), 0x00);
					edi_11->dw0EE4 = eax_573;
					edi_11->dw0EE8 = eax_573 >> 0x01;
				}
l08049570:
				uint32 ebx_585 = ebp_19->dw0054;
				if (ebx_585 == 0x00)
					ebx_585 = ecx_117 *s edi_11->dw0EE4 * 0x03 >> 0x02;
				edi_11->dw1FDC = ebx_585;
				return;
			}
			goto l0804959D;
		}
		Eq_2 esp_408 = <invalid>;
		word32 edi_931;
		word32 esi_930;
		Eq_2 ecx_409;
		Eq_2 edx_410;
		*((word32) esp_408 + 16) = handle_amd(188, ecx, edx, ebx, out ecx_409, out edx_410, out esi_930, out edi_931);
		Eq_2 ecx_422;
		Eq_2 edx_423;
		word32 edi_933;
		word32 esi_932;
		handle_amd(191, ecx_409, edx_410, ebx, out ecx_422, out edx_423, out esi_932, out edi_933);
		Eq_2 esp_434 = <invalid>;
		Eq_2 ecx_435;
		ui32 edx_436;
		*((word32) esp_434 + 20) = handle_amd(0xC2, ecx_422, edx_423, ebx, out ecx_435, out edx_436, out esi_100, out edi_11);
		__cpuid(0x80000000, ecx_435, &0x80000000, &ebx, &ecx_435, &edx_436);
		esp_18 = (word32) esp_434 + 4;
		ecx_117.u0 = 0x00;
		if (*((word32) esp_434 + 20) > 0x00)
		{
			__cpuid(0x01, 0x00, &0x01, &ebx, &0x00, &edx_436);
			ecx_117 = edx_436 & 0x10000000;
			if ((edx_436 & 0x10000000) != 0x00)
			{
				ecx_117 = ebx >> 0x10 & 0xFF;
				if (ecx_117 != 0x00)
					*((word32) esp_434 + 20) = (uint32) ((uint64) *((word32) esp_434 + 20) /u ecx_117);
			}
			esi_100 += Mem484[esp_434 + 0x14:word32];
		}
l080496E6:
		eax_494 = ebp_19->dw004C;
		if (eax_494 == 0x00)
			goto l08049515;
		goto l08049511;
	}
	Eq_936 dwArg18_709;
	Eq_936 dwArg28_710;
	Eq_2 esp_34 = <invalid>;
	Eq_2 ebx_30;
	Eq_2 ecx_35;
	word32 edi_925;
	word32 edx_923;
	word32 ebp_924;
	*((word32) esp_34 + 0x0C) = handle_intel.constprop.1(188, ecx, ebx, gs, out ecx_35, out edx_923, out ebx_30, out ebp_924, out edi_925);
	Eq_2 esp_48 = <invalid>;
	Eq_2 ebx_44;
	Eq_2 ecx_49;
	word32 edx_926;
	word32 ebp_927;
	word32 edi_928;
	*((word32) esp_48 + 20) = handle_intel.constprop.1(191, ecx_35, ebx_30, gs, out ecx_49, out edx_926, out ebx_44, out ebp_927, out edi_928);
	word32 ebx_58;
	word32 edx_60;
	word32 ecx_929;
	Eq_2 eax_56 = handle_intel.constprop.1(0xC2, ecx_49, ebx_44, gs, out ecx_929, out edx_60, out ebx_58, out ebp_19, out edi_11);
	esp_18 = fp;
	esi_100 = eax_56;
	if (eax_56 > 0x00)
	{
		dwArg18_709.u0 = 0x00;
		dwArg28_710.u0 = 0x03;
	}
	else
	{
		esi_100 = dwArg14;
		dwArg18_709.u0 = ~0x00;
		dwArg28_710.u0 = 0x02;
	}
	ui32 ecx_78 = ebp_19->dw0014;
	ecx_117 = ecx_78 & 0x10000000;
	if ((ecx_78 & 0x10000000) == 0x00)
		goto l080496E6;
	Eq_2 dwArg1C_749;
	if (dwArg20 <= 0x03)
	{
		Mem116 = Mem87;
		dwArg1C_749.u0 = 0x00;
		ecx_117 = (word32) ebp_19->b000E;
		goto l080496B8;
	}
	Eq_2 dwArg10_718;
	if (dwArg18_709 != 0x00)
	{
		dwArg10_718.u0 = 0x01;
		dwArg18_709.u0 = ~0x00;
	}
	else
		dwArg10_718.u0 = 0x03;
	Eq_2 ecx_102 = 0x00;
	while (true)
	{
		__cpuid(0x04, ecx_102, &0x04, &ebx_58, &ecx_102, &edx_60);
		Eq_2 esi_103 = (word32) ecx_102 + 1;
		Eq_936 dwArg18_739 = dwArg18_709;
		Eq_936 dwArg1C_737 = 0x00;
		if (dwArg10_718 == 0x00)
			break;
		ecx_102 = esi_103;
	}
	if (dwArg20 > 0x0A)
	{
		Eq_936 ebx_161 = dwArg28_710;
		uint32 eax_163 = 0x01;
		if (dwArg18_709 <= 0x00)
			eax_163 = 0x00;
		dwArg20 = esi_100;
		Eq_2 ecx_192 = dwArg10_718;
		ui32 esi_197 = eax_163 * 0x02;
		while (esi_197 != 0x00)
		{
			__cpuid(11, ecx_192, &11, &ebx_161, &ecx_192, &0x00);
			Eq_2 eax_203 = (word32) ecx_192 + 1;
			ui32 ecx_209 = ecx_192 & 0xFF00;
			ebx_161 &= 0xFF;
			if (ebx_161 == 0x00 || ecx_209 == 0x00)
				break;
			if (ecx_209 == 0x0100)
			{
				if ((esi_197 & 0x01) != 0x00)
				{
					ebx_161 = ebx_161 - 0x01 & ~(~0x00 << (byte) __bsr(dwArg1C_737) + 0x01);
					esi_197 &= ~0x01;
					dwArg1C_737 = ebx_161;
				}
			}
			else if (ecx_209 == 0x0200 && (esi_197 & 0x02) != 0x00)
			{
				--ebx_161;
				if (dwArg28_710 != 0x02)
					dwArg18_739 = ~(~0x00 << (byte) __bsr(dwArg18_739) + 0x01) & ebx_161 - 0x01;
				else
					dwArg1C_737 = ~(~0x00 << (byte) __bsr(dwArg1C_737) + 0x01) & ebx_161 - 0x01;
				esi_197 &= ~0x02;
			}
			ecx_192 = eax_203;
		}
	}
	Eq_2 eax_226 = dwArg1C_737 - ~0x00 - (word32) (dwArg1C_737 < 0x01);
	dwArg1C_749 = eax_226;
	if (dwArg18_739 > 0x00)
	{
		if (dwArg28_710 != 0x02)
		{
			ecx_117 = (word32) dwArg18_739.u0 + 1;
			goto l080496B8;
		}
	}
	else if (dwArg28_710 != 0x02)
	{
		ecx_117.u0 = 0x00;
		if (dwArg18_739 == 0x00)
		{
l080496C8:
			if (true)
				goto l080496E6;
			if (dwArg1C_749 != 0x00)
				dwArg14 = (int32) ((int64) dwArg14 /32 dwArg1C_749);
l080496E2:
			esi_100 += dwArg14;
			goto l080496E6;
		}
		ecx_117.u0 = ~0x00;
l080496B8:
		if (esi_100 > 0x00 && ecx_117 != 0x00)
			esi_100 = (uint32) ((uint64) esi_100 /u ecx_117);
		goto l080496C8;
	}
	word32 edx_253 = ebp_19->dw0038;
	uint32 eax_254 = ebp_19->dw003C;
	if (eax_226 == 0x00)
	{
		ecx_117.u0 = 0x00;
		if (true)
			goto l080496E6;
		goto l080496E2;
	}
	ecx_117 = eax_226;
	if (eax_226 > 0x02 && (edx_253 == 0x06 && eax_254 <= 0x5D))
	{
		word32 edx_294;
		edi_11[edi_11->aFFFE46A4[eax_254 - 55] / 8160]();
		return;
	}
	goto l080496B8;
}

// 08049960: void _start(Register word32 edx, Register (ptr16 Eq_1388) gs, Register word32 mxcsr, Stack word32 dwArg00, Stack word32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14, Stack word32 dwArg20)
void _start(word32 edx, struct Eq_1388 * gs, word32 mxcsr, word32 dwArg00, word32 dwArg0C, word32 dwArg10, word32 dwArg14, word32 dwArg20)
{
	__align(fp + 4);
	__libc_start_main(gs, dwArg00, fp + 4, edx, fp, dwArg0C, dwArg10, dwArg14, dwArg20);
	__hlt();
}

// 080499A0: void _dl_relocate_static_pie()
// Called from:
//      __libc_start_main
void _dl_relocate_static_pie()
{
}

// 080499B0: void __x86.get_pc_thunk.bx()
void __x86.get_pc_thunk.bx()
{
}

// 080499C0: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
}

// 08049A00: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
}

// 08049A40: void __do_global_dtors_aux(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
void __do_global_dtors_aux(Eq_2 ecx, struct Eq_9 * gs)
{
	if (g_b80CF300 != 0x00)
		return;
	deregister_tm_clones();
	__deregister_frame_info_bases(ecx, gs, 0x080BA428);
}

// 08049A90: void frame_dummy()
void frame_dummy()
{
	__register_frame_info_bases(&g_dw80BA428, 0x080CF304, 0x00, 0x080CE000);
	register_tm_clones();
}

// 08049AE0: Register Eq_2 get_common_indeces.constprop.1(Register (ptr32 word32) eax, Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 ebx, Stack Eq_2 dwArg04, Register out Eq_2 edxOut)
// Called from:
//      __libc_start_main
Eq_2 get_common_indeces.constprop.1(word32 * eax, Eq_2 ecx, Eq_2 edx, Eq_2 ebx, Eq_2 dwArg04, union Eq_2 & edxOut)
{
	ptr32 fp;
	Eq_2 ebx;
	Eq_2 ecx;
	word32 * eax;
	Eq_2 edx;
	Eq_2 dwArg04;
	word32 dwLoc14;
	word32 dwLoc94;
	if (eax != null)
	{
		__cpuid(0x01, ecx, &0x01, &ebx, &ecx, &edx);
		g_t80CF8F4 = edx;
		g_t80CF8EC = ebx;
		ebx_35 = ecx;
		g_t80CF8F0 = ecx;
		g_dw80CF8E8 = 0x01;
		ecx_40.u0 = 0x01;
		*eax = 0x00;
		*edx = 0x00;
		*ecx = 0x00;
		edx_50 = dwArg04;
		*dwArg04 = 0x01;
		if (*eax == 0x0F)
		{
			*eax = 0x0F;
			eax_59 = (int32) *ecx;
			v16_60 = (word32) *edx + eax_59;
			*edx = v16_60;
		}
	}
	ecx_365 = ϕ(ecx_40, ecx, ecx_40);
	edx_72 = ϕ(edx_50, edx, edx_50);
	ebx_71 = ϕ(ebx_35, ebx, ebx_35);
	Mem64 = ϕ(Mem51, Mem20, Mem61);
	if (g_t80CF8E4 > 0x06)
	{
		ecx_68.u0 = 0x00;
		__cpuid(0x07, 0x00, &0x07, &ebx_71, &0x00, &edx_72);
		g_dw80CF8F8 = 0x07;
		g_t80CF8FC = ebx_71;
		g_dw80CF900 = 0x00;
		g_t80CF904 = edx_72;
	}
	ecx_364 = ϕ(ecx_365, ecx_68);
	Mem78 = ϕ(Mem64, Mem76);
	ebx_79 = g_t80CF8F0;
	bh_105 = SLICE(ebx_79, byte, 8);
	bl_157 = (byte) ebx_79;
	ebx_16_16_159 = SLICE(ebx_79, word16, 16);
	if ((ebx_79 & 0x08000000) != 0x00)
	{
		ecx_83.u0 = 0x00;
		edx_eax_84 = __xgetbv(0x00);
		eax_85 = (word32) edx_eax_84;
		edx_87 = eax_85 & 0x06;
		if ((eax_85 & 0x06) == 0x06)
		{
			if ((ebx_79 & 0x10000000) != 0x00)
			{
				edx_93 = g_t80CF928;
				ecx_95 = edx_93 | 0x40;
				g_t80CF928 = edx_93 | 0x40;
				if ((g_t80CF8FC & 0x20) != 0x00)
				{
					edx_100 = edx_93 | 0x0C40;
					g_t80CF928 = edx_93 | 0x0C40;
				}
				edx_164 = ϕ(edx_93, edx_100);
				Mem111 = ϕ(Mem96, Mem103);
				ebx_160 = SEQ(ebx_16_16_159, bh_105 & 0x10, bl_157);
				if ((bh_105 & 0x10) != 0x00)
				{
					v21_112 = g_t80CF928 | 0x80;
					g_t80CF928 = v21_112;
				}
			}
			ecx_367 = ϕ(ecx_83, ecx_95, ecx_95);
			edx_163 = ϕ(edx_87, edx_164, edx_164);
			ebx_155 = ϕ(ebx_79, ebx_160, ebx_160);
			Mem122 = ϕ(Mem78, Mem111, Mem113);
			if ((eax_85 & 0xE0) == 0xE0)
			{
				edx_123 = g_t80CF8FC;
				if ((edx_123 & 0x00010000) != 0x00)
				{
					eax_127 = g_t80CF928;
					ah_129 = SLICE(eax_127, byte, 8);
					eax_16_16_142 = SLICE(eax_127, word16, 16);
					al_143 = (byte) eax_127;
					ch_131 = SLICE(eax_127, byte, 8);
					ecx_16_16_137 = SLICE(eax_127, word16, 16);
					cl_138 = (byte) eax_127;
					edx_133 = edx_123 & 0x00020000;
					ecx_139 = SEQ(ecx_16_16_137, ch_131 | 0x30, cl_138);
					eax_144 = SEQ(eax_16_16_142, ah_129 | 0x10, al_143);
					if ((edx_123 & 0x00020000) != 0x00)
						eax_140 = ecx_139;
					eax_141 = ϕ(eax_144, eax_140);
					g_t80CF928 = eax_141;
				}
			}
		}
		ecx_366 = ϕ(ecx_83, ecx_367, ecx_367, ecx_139);
		edx_162 = ϕ(edx_87, edx_163, edx_123, edx_133);
		ebx_154 = ϕ(ebx_79, ebx_155, ebx_155, ebx_155);
		Mem148 = ϕ(Mem78, Mem122, Mem122, Mem146);
		if (g_t80CF8E4 > 0x0C)
		{
			ecx_152.u0 = 0x00;
			__cpuid(0x0D, 0x00, &0x0D, &ebx_154, &0x00, &edx_162);
			if (ebx_154 != 0x00)
			{
				ebx_169 = (word32) ebx_154 + 0x007F;
				ecx_171.u0 = 0x01;
				g_dw80CF920 = ebx_169 & ~0x3F;
				g_dw80CF924 = ebx_169 & ~0x3F;
				__cpuid(0x0D, 0x01, &0x0D, &(ebx_169 & ~0x3F), &0x01, &edx_162);
			}
		}
	}
	edx_374 = ϕ(edx_72, edx_162, edx_162, edx_162, edx_162);
	ecx_363 = ϕ(ecx_364, ecx_366, ecx_152, ecx_171, ecx_370, ecx_370);
	edxOut = edx_374;
	return ecx_363;
}

// 08049D30: void __libc_start_main(Register (ptr16 Eq_1388) gs, Stack word32 dwArg08, Stack ptr32 dwArg0C, Stack word32 dwArg18, Stack ptr32 dwArg1C, Stack word32 dwArg2C, Stack word32 dwArg30, Stack word32 dwArg34, Stack word32 dwArg40)
// Called from:
//      _start
void __libc_start_main(struct Eq_1388 * gs, word32 dwArg08, ptr32 dwArg0C, word32 dwArg18, ptr32 dwArg1C, word32 dwArg2C, word32 dwArg30, word32 dwArg34, word32 dwArg40)
{
}

// 0804A4D0: void __x86.get_pc_thunk.ax()
void __x86.get_pc_thunk.ax()
{
}

// 0804A4D4: void __x86.get_pc_thunk.di()
void __x86.get_pc_thunk.di()
{
}

// 0804A4E0: Register word32 check_one_fd(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 edxOut)
// Called from:
//      __libc_check_standard_fds
word32 check_one_fd(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & edxOut)
{
	__fcntl64_nocancel();
	if (eax == ~0x00 && gs->tFFFFFFE0 == 0x09)
	{
		word32 edi_41;
		Eq_2 eax_42;
		if (edx == 0x00020000)
		{
			edi_41 = 0x0103;
			eax_42.u0 = 0x080A2212;
		}
		else
		{
			edi_41 = 0x0107;
			eax_42.u0 = 0x080A2208;
		}
		word32 edx_150;
		word32 ecx_149;
		if (eax != __open_nocancel(gs, eax_42, edx, 0x00, out ecx_149, out edx_150) || (__fxstat64(gs, eax, fp - 0x7C, out ecx, out edx) != 0x00 || ((dwLoc6C & 0xF000) != 0x2000 || (edi_41 ^ dwLoc5C | dwLoc58) != 0x00)))
			__hlt();
	}
	edxOut = edx;
	return ecx;
}

// 0804A590: Register word32 __libc_check_standard_fds(Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
word32 __libc_check_standard_fds(struct Eq_9 * gs, ptr32 & edxOut)
{
	word32 edx_38;
	check_one_fd(0x00, 0x00020001, gs, out edx_38);
	word32 edx_39;
	check_one_fd(0x01, 0x00020000, gs, out edx_39);
	ptr32 edx_32;
	word32 ecx_31 = check_one_fd(0x02, 0x00020000, gs, out edx_32);
	edxOut = edx_32;
	return ecx_31;
}

// 0804A5C4: void __x86.get_pc_thunk.si()
void __x86.get_pc_thunk.si()
{
}

// 0804A5D0: Register (ptr32 Eq_9) __libc_setup_tls(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_start_main
struct Eq_9 * __libc_setup_tls(struct Eq_9 * gs)
{
	Eq_2 dwLoc3C_257;
	ui32 dwLoc4C_263;
	int32 dwLoc48_261;
	Eq_1877 dwLoc44_260;
	Eq_1877 edx_130;
	Eq_1879 ebp_127;
	Eq_2 ebx_133;
	Eq_1877 edx_100;
	Eq_2 eax_20 = g_t80CEA00;
	Eq_2 esi_132 = _dl_phdr;
	word32 eax_24 = _dl_tls_static_size;
	if (esi_132 != 0x00)
	{
		Eq_2 edx_36 = (word32) esi_132 + (_dl_phnum << 0x05);
		if (esi_132 < edx_36)
		{
			do
			{
				if (*esi_132 == 0x07)
				{
					edx_100 = *((word32) esi_132 + 20);
					ebx_133 = Mem21[esi_132 + 0x08:word32] + Mem54[eax_20 + 0x00:word32];
					ebp_127 = *((word32) esi_132 + 28);
					dwLoc3C_257 = *((word32) esi_132 + 16);
					dwLoc44_260 = edx_100;
					esi_132 = ebx_133;
					if (ebp_127 <= 0x40)
						goto l0804A655;
					int32 eax_69 = (uint32) ((uint64) ((word32) ebp_127 + ((edx_100 - 0x01) + eax_24)) /u ebp_127) *s ebp_127;
					word32 edx_327;
					ui32 edx_84 = (word32) ebp_127 + (__sbrk(gs, (word32) ebp_127 + (eax_69 + 0x04C0), out edx_327) - 0x01);
					g_dw80CFCC0 = 0x3E;
					dwLoc48_261 = eax_69;
					dwLoc4C_263 = edx_84 & -ebp_127;
					goto l0804A776;
				}
				esi_132 = (byte) esi_132.u0 + 32;
			} while (edx_36 > esi_132);
		}
		ebp_127.u0 = 0x00;
		esi_132.u0 = 0x00;
		dwLoc3C_257.u0 = 0x00;
		edx_100.u0 = 0x00;
	}
	else
	{
		ebp_127.u0 = 0x00;
		dwLoc3C_257.u0 = 0x00;
		edx_100.u0 = 0x00;
	}
l0804A655:
	ui32 eax_103 = (word32) edx_100.u0 + 63 + eax_24;
	word32 edx_326;
	ui32 eax_123 = __sbrk(gs, (eax_103 & ~0x3F) + 0x0500, out edx_326) + 0x3F & ~0x3F;
	g_dw80CFCC0 = 0x3E;
	dwLoc48_261 = eax_103 & ~0x3F;
	dwLoc4C_263 = eax_123;
	edx_130 = edx_100;
	if (ebp_127 != 0x00)
	{
		ebx_133 = esi_132;
		dwLoc44_260 = edx_100;
l0804A776:
		esi_132 = ebx_133;
		edx_130 = CONVERT(CONVERT(ebp_127 - 0x01 + dwLoc44_260, word32, uint64) /u ebp_127, word32, uint32) *s ebp_127;
	}
	*((word32) eax_20 + 0x0244) = edx_130;
	Eq_2 eax_162 = dwLoc48_261 - edx_130 + dwLoc4C_263;
	g_t80CFCD0 = eax_162;
	g_dw80CFCD4 = 0x00;
	word32 edx_329;
	word32 ecx_328;
	memcpy(eax_162, esi_132, dwLoc3C_257, out ecx_328, out edx_329);
	struct Eq_2017 * eax_192 = dwLoc4C_263 + dwLoc48_261;
	eax_192->ptr0000 = eax_192;
	eax_192->dw0004 = 0x080CFCC8;
	eax_192->ptr0008 = eax_192;
	eax_192->dw0010 = _dl_sysinfo;
	__syscall(0x80);
	__hlt();
}

// 0804A880: Register int32 __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      __libc_start_main
int32 __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	int32 eax_23 = 0x080CC6B0 - 0x080CC6B0;
	if (eax_23 >> 0x02 != 0x00)
	{
		int32 esi_31 = 0x00;
		do
		{
			(*((char *) g_a80CC6B0 + esi_31 * 0x04))();
			++esi_31;
		} while (eax_23 >> 0x02 != esi_31);
	}
	_init();
	int32 eax_62 = 0x080CC6B8 - 0x080CC6B0;
	int32 eax_152 = eax_62 >> 0x02;
	if (eax_62 >> 0x02 != 0x00)
	{
		int32 esi_71 = 0x00;
		do
		{
			(*((char *) g_a80CC6B0 + esi_71 * 0x04))();
			++esi_71;
		} while (eax_62 >> 0x02 != esi_71);
	}
	return eax_152;
}

// 0804A930: void __libc_csu_fini()
void __libc_csu_fini()
{
	int32 eax_15 = 0x080CC6C0 - 0x080CC6B8;
	if (eax_15 >> 0x02 != 0x00)
	{
		int32 esi_20 = (eax_15 >> 0x02) - 0x01;
		do
		{
			(*((char *) g_a80CC6B8 + esi_20 * 0x04))();
			--esi_20;
		} while (esi_20 != ~0x00);
	}
	_fini();
}

// 0804A980: void __assert_fail_base(Register word32 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14)
// Called from:
//      __assert_fail
void __assert_fail_base(word32 ecx, struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, word32 dwArg14)
{
	Mem60 = Mem28;
	*program_invocation_short_name != 0x00;
	if (___asprintf() < 0x00)
	{
		word32 esi_359;
		word32 ebx_358;
		__libc_write(gs, 0x02, 134881868, 0x12, out ebx_358, out esi_359);
		__assert_fail_base.cold.0();
	}
	else
	{
		__fxprintf(gs, 0x00);
		fflush(gs, _IO_stderr);
		Eq_2 edx_164 = _dl_pagesize;
		Eq_2 eax_168 = (word32) edx_164 + dwLoc24 & -edx_164;
		word32 edx_361;
		word32 ecx_360;
		Eq_2 eax_188 = mmap(gs, 0x00, eax_168, 0x03, 0x22, ~0x00, 0x00, out ecx_360, out edx_361);
		if (eax_188 == ~0x00)
			__assert_fail_base.cold.0();
		else
		{
			*eax_188 = eax_168;
			strcpy((word32) eax_188 + 4, dwLoc28);
			Eq_2 v22_224 = __abort_msg;
			__abort_msg = eax_188;
			if (v22_224 == 0x00)
				__assert_fail_base.cold.0();
			else
			{
				word32 ebx_364;
				word32 ecx_362;
				word32 edx_363;
				__munmap(0x080CE000, gs, v22_224, *v22_224, out ecx_362, out edx_363, out ebx_364);
				__assert_fail_base.cold.0();
			}
		}
	}
}

// 0804AAE0: Register Eq_2 __assert_fail(Register out Eq_952 ecxOut, Register out Eq_2240 edxOut)
// Called from:
//      __libc_start_main
//      __new_exitfn
//      _IO_wfile_underflow
//      _IO_file_fopen
//      enlarge_userbuf
//      __mbsrtowcs_l
//      getcwd
//      __getpagesize
//      next_line
//      _dl_non_dynamic_init
//      __gconv
//      __gconv_release_step
//      __gconv_get_path
//      __gconv_get_builtin_trans
//      __gconv_transform_internal_ucs4
//      __gconv_transform_ucs4_internal
//      __gconv_transform_internal_ucs4le
//      __gconv_transform_ucs4le_internal
//      __gconv_transform_ascii_internal
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_utf8_internal
//      __gconv_transform_ucs2_internal
//      __gconv_transform_internal_ucs2
//      __gconv_transform_ucs2reverse_internal
//      __gconv_transform_internal_ucs2reverse
//      do_release_shlib
//      __gconv_find_shlib
//      _nl_find_locale
//      _nl_intern_locale_data
//      _nl_load_locale_from_archive
//      printf_positional
//      vfprintf
//      __printf_fphex
//      printf_positional
//      __vfwprintf
//      _IO_fwide
//      intel_check_word.isra.0
//      __cache_sysconf
//      wcrtomb
//      __wcsrtombs
//      add_name_to_object.isra.4
//      _dl_map_object_from_fd.constprop.8
//      expand_dynamic_string_token
//      _dl_map_object
//      check_match
//      _dl_lookup_symbol_x
//      _dl_setup_hash
//      _dl_relocate_object
//      _dl_important_hwcaps
//      _dl_debug_vdprintf
//      _dl_next_tls_modid
//      _dl_allocate_tls
//      _dl_add_to_slotinfo
//      _dl_get_origin
//      _dl_fixup
//      _dl_profile_fixup
//      _dl_find_dso_for_object
//      _dl_open
//      dl_open_worker
//      remove_slotinfo
//      _dl_close_worker
//      _dl_map_object_deps
//      _dl_check_map_versions
//      _nl_archive_subfreeres
Eq_2 __assert_fail(union Eq_952 & ecxOut, union Eq_2240 & edxOut)
{
	word32 edx_65;
	__assert_fail_base(ecx, gs, dcgettext(out edx_65), dwArg04, dwArg08, dwArg0C, dwArg10);
	Eq_2240 edx_44;
	Eq_2 eax_43 = dcgettext(out edx_44);
	ecxOut.u0 = <invalid>;
	edxOut = edx_44;
	return eax_43;
}

// 0804AB20: Register Eq_2 dcgettext(Register out Eq_952 edxOut)
// Called from:
//      __assert_fail
//      strerror_r
//      __dlerror
//      strerror
//      dlopen_doit
Eq_2 dcgettext(union Eq_952 & edxOut)
{
	__dcigettext(gs, dwArg04, dwArg08, 0x00, 0x00, 0x00, dwArg0C);
	edxOut.u0 = <invalid>;
	return <invalid>;
}

// 0804AB50: Register Eq_2280 plural_eval(Register Eq_2280 eax, Register out Eq_2280 edxOut, Register out Eq_2280 ebxOut, Register out Eq_2280 ebpOut, Register out Eq_2280 esiOut)
// Called from:
//      plural_eval
//      plural_lookup.isra.2
Eq_2280 plural_eval(Eq_2280 eax, union Eq_2280 & edxOut, union Eq_2280 & ebxOut, union Eq_2280 & ebpOut, union Eq_2280 & esiOut)
{
	Eq_2280 edx_124;
	Eq_2280 esi_154;
	int32 eax_133 = *eax;
	Eq_2280 ebx_132 = eax;
	bool v17_171 = eax_133 <= 0x01;
	edx_124 = edx;
	while (eax_133 != 0x01)
	{
		if (v17_171)
		{
			if (eax_133 == 0x00)
			{
				uint32 eax_33 = *((word32) ebx_132 + 4);
				esi_154 = edx;
				if (eax_33 != 0x00)
				{
					&esi_154.u0->dw0000 = 0x00;
					if (eax_33 == 0x01)
						esi_154 = *((word32) ebx_132 + 8);
				}
				goto l0804ABAA;
			}
			goto l0804ABD8;
		}
		if (eax_133 == 0x02)
		{
			word32 ebx_239;
			word32 ebp_240;
			word32 esi_241;
			Eq_2280 eax_52 = plural_eval(*((word32) ebx_132 + 8), out edx_124, out ebx_239, out ebp_240, out esi_241);
			uint32 ecx_55 = *((word32) ebx_132 + 4);
			esi_154 = eax_52;
			if (ecx_55 != 0x0F)
			{
				if (ecx_55 != 0x0E)
				{
					word32 ebx_245;
					word32 ebp_246;
					word32 esi_247;
					Eq_2280 eax_91 = plural_eval(*((word32) ebx_132 + 0x0C), out edx_124, out ebx_245, out ebp_246, out esi_247);
					if (ecx_55 <= 0x0D)
					{
						Eq_2280 edx_101;
						Eq_2280 eax_102;
						word32 ecx_103;
						(0x080CE000 + g_a80A2260[(ecx_55 - 0x03) * 0x04])();
						edxOut = edx_101;
						ebxOut = eax_91;
						ebpOut = edx;
						esiOut = eax_52;
						return eax_102;
					}
l0804ABD8:
					edxOut = edx_124;
					ebxOut = ebx;
					ebpOut = ebp;
					esiOut = esi;
					return 0x00;
				}
				if (eax_52 == 0x00)
					goto l0804ABAA;
			}
			else if (eax_52 != 0x00)
			{
				&esi_154.u0->dw0000 = 0x01;
				goto l0804ABAA;
			}
			word32 ebx_248;
			word32 ebp_249;
			word32 esi_250;
			esi_154 = (word32) (plural_eval(*((word32) ebx_132 + 0x0C), out edx_124, out ebx_248, out ebp_249, out esi_250) != 0x00);
			goto l0804ABAA;
		}
		if (eax_133 != 0x03)
			goto l0804ABD8;
		word32 ebx_242;
		word32 ebp_243;
		word32 esi_244;
		ebx_132 = *((word32) ebx_132 + ((word32) (plural_eval(*((word32) ebx_132 + 8), out edx_124, out ebx_242, out ebp_243, out esi_244) == 0x00) * 0x04 + 0x0C));
		eax_133 = (int32) *ebx_132;
		v17_171 = eax_133 <= 0x01;
	}
	word32 ebx_236;
	word32 ebp_237;
	word32 esi_238;
	esi_154 = (word32) (plural_eval(*((word32) ebx_132 + 8), out edx_124, out ebx_236, out ebp_237, out esi_238) == 0x00);
l0804ABAA:
	edxOut = edx_124;
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	return esi_154;
}

// 0804ACF0: void transcmp(Stack (ptr32 Eq_2428) dwArg04, Stack (ptr32 Eq_2429) dwArg08)
void transcmp(struct Eq_2428 * dwArg04, struct Eq_2429 * dwArg08)
{
	Eq_2 edx_17;
	if (dwArg08->dw0010 != 0x00)
		edx_17 = &dwArg08->t001C;
	else
		edx_17 = dwArg08->t001C;
	Eq_2 eax_25;
	if (dwArg04->dw0010 != 0x00)
		eax_25 = &dwArg04->t001C;
	else
		eax_25 = dwArg04->t001C;
	word32 ecx_131;
	word32 edx_132;
	if (strcmp(eax_25, edx_17, out ecx_131, out edx_132) == 0x00)
	{
		word32 ecx_127;
		word32 edx_128;
		if (strcmp(dwArg04->t0000, dwArg08->t0000, out ecx_127, out edx_128) == 0x00)
		{
			word32 ecx_129;
			word32 edx_130;
			strcmp(dwArg04->t0008, dwArg08->t0008, out ecx_129, out edx_130) != 0x00;
		}
	}
}

// 0804AD70: Register word32 plural_lookup.isra.2(Register Eq_2 eax, Stack Eq_2 dwArg04)
// Called from:
//      __dcigettext
word32 plural_lookup.isra.2(Eq_2 eax, Eq_2 dwArg04)
{
	word32 ebp_18;
	struct Eq_2497 * ebx_23;
	Eq_2 esi_25;
	word32 edx_107;
	Eq_2280 eax_22 = plural_eval(*((word32) eax + 96), out edx_107, out ebx_23, out ebp_18, out esi_25);
	if (eax_22 < ebx_23->t0064)
	{
		Eq_2280 edi_33 = eax_22;
		Eq_2 eax_34 = esi_25;
		word32 ebx_35 = dwArg04 + esi_25;
		do
		{
			--edi_33;
			if (edi_33 == ~0x00)
				return ebp_18;
			Eq_2 eax_50 = rawmemchr(eax_34, 0x00);
			eax_34 = (word32) eax_50 + 1;
		} while ((word32) eax_50 + 1 < ebx_35);
	}
	return ebp_18;
}

// 0804ADC0: Register Eq_2 _nl_find_msg(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_load_domain
Eq_2 _nl_find_msg(Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
_nl_find_msg_entry:
	Eq_2175 edx_30 = gs->t0014
	branch *((word32) dwArg04 + 4) <= 0x00 l0804B038
	goto l0804AE09
l0804ADC0:
l0804AE09:
	Eq_2 dwLoc30_1872
	Eq_2 eax_1311
	Eq_2 edx_1085
	uint32 ebx_1026
	struct Eq_2581 * esp_1059 = fp - 0x6C
	Eq_2 esi_1130 = *((word32) dwArg04 + 8)
	branch esi_1130 == 0x00 l0804AF80
l0804AE17:
	Eq_2 eax_56 = *((word32) esi_1130 + 20)
	edi = *((word32) esi_1130 + 48)
	dwLoc34 = eax_56
	branch edi == 0x00 l0804AFA8
l0804AE28:
	word32 edx_3533
	word32 ecx_3532
	Eq_2 eax_141 = strlen(dwArg0C, out ecx_3532, out edx_3533)
	word32 eax_150 = __hash_string(dwArg0C)
	Eq_2 edi_157 = *((word32) esi_1130 + 44)
	uint32 edx_172 = (uint32) ((uint64) eax_150 % (edi_157 - 0x02))
	Eq_2 eax_174 = *((word32) esi_1130 + 52)
	Eq_2 eax_176 = *((word32) esi_1130 + 48)
	Eq_2 eax_181 = edi_157 - (edx_172 + 0x01)
	Eq_2 eax_184 = edx_172 + 0x01 - edi_157
	dwLoc40 = eax_141
	Eq_2 ebx_166 = (uint32) ((uint64) eax_150 % edi_157)
	dwLoc38 = eax_174
	dwLoc3C = eax_176
	dwLoc44 = eax_181
	dwLoc48 = eax_184
	goto l0804AED5
l0804AE80:
	Eq_2 esi_217
	Eq_2 eax_218
	struct Eq_2670 * eax_212 = (word32) *((word32) esi_1130 + 24) + edi * 0x08
	Eq_2 esi_213 = eax_212->t0000
	branch *((word32) esi_1130 + 0x0C) == 0x00 l0804B020
l0804AE92:
	branch eax_141 > __bswap(esi_213) l0804AEC5
l0804AE99:
	esi_217 = *esi_1130
	eax_218 = __bswap(eax_212->t0004)
l0804AEA0:
	dwLoc54 = esi_1130
	word32 edx_3552
	word32 ecx_3551
	branch strcmp(dwArg0C, eax_218 + esi_217, out ecx_3551, out edx_3552) == 0x00 l0804B050
l0804AEC5:
	Eq_2 esi_322 = (word32) ebx_166 + (edx_172 + 0x01)
	word32 eax_323 = eax_184 + ebx_166
	branch eax_181 <= ebx_166 l0804AED3
l0804AED0_1:
	eax_323 = esi_322
l0804AED3:
	ebx_166 = eax_323
l0804AED5:
	edi = *((word32) eax_176 + ebx_166 * 0x04)
	esp_1059 = fp - 0x6C
	esi_1130 = eax_174
	Eq_2 eax_196 = __bswap(edi)
	branch eax_174 == 0x00 l0804AEE7
l0804AEE4_1:
	edi = eax_196
l0804AEE7:
	branch edi == 0x00 l0804AF80
l0804AEEF:
	edi = edi - 0x01
	branch eax_56 > edi l0804AE80
l0804AEF7:
	struct Eq_2686 * eax_288 = (word32) *((word32) esi_1130 + 36) + (edi - eax_56) * 0x08
	branch eax_288->t0000 <= eax_141 l0804AEC5
l0804AF09:
	dwLoc54 = esi_1130
	word32 edx_3535
	word32 ecx_3534
	branch strcmp(dwArg0C, eax_288->t0004, out ecx_3534, out edx_3535) != 0x00 l0804AEC5
l0804AF2C:
	struct Eq_2896 * eax_338 = (word32) *((word32) esi_1130 + 40) + (edi - eax_56) * 0x08
	dwLoc30_1872 = eax_338->t0004
	dwLoc3C = eax_338->t0000
l0804AF42:
	esp_1059 = fp - 0x6C
	branch dwArg10 != 0x00 l0804B080
l0804AF4D:
	*dwArg14 = dwLoc3C
	goto l0804AF87
l0804AF57:
	branch gs->t000C == 0x00 l0804AF65
l0804AF64:
	__lock()
l0804AF65:
	Eq_2 v33_1595 = lock.11578 - 0x01
	lock.11578 = v33_1595
	branch v33_1595 == 0x00 l0804AF79
l0804AF6E:
	__lll_unlock_wake_private(0x080CF570, ecx_1541, edx_1542, gs)
l0804AF79:
l0804AF80:
	dwLoc30_1872.u0 = 0x00
l0804AF87:
	ebx_1026 = edx_30 ^ gs->t0014
	branch ebx_1026 != 0x00 l0804B919
l0804AF9A:
	return dwLoc30_1872
l0804AFA8:
	dwLoc44 = esi_1130
	Eq_2 ebx_130 = 0x00
	esi_1130 = eax_56
	goto l0804AFC7
l0804AFB8:
	esi_1130 = edi
	edi = esi_84 >> 0x01
	branch eax_110 == 0x00 l0804B278
l0804AFC4:
	ebx_130 = (esi_84 >> 0x01) + 0x01
l0804AFC7:
	esp_1059 = fp - 0x6C
	branch esi_1130 <= ebx_130 l0804AF80
l0804AFCB:
	Eq_2 ecx_76 = *esi_1130
	Eq_2 edx_77 = *((word32) esi_1130 + 0x0C)
	Eq_2 eax_78 = *((word32) esi_1130 + 24)
	edi = esi_1130
	dwLoc38 = ecx_76
	dwLoc3C = edx_77
	dwLoc40 = eax_78
l0804AFE1:
	word32 esi_84 = ebx_130 + edi
	Eq_2 eax_100 = *((word32) eax_78 + ((esi_84 >> 0x01) * 0x08 + 4))
	esi_1130 = esi_84 >> 0x01
	Eq_2 ecx_94 = __bswap(eax_100)
	branch edx_77 == 0x00 l0804AFF9
l0804AFF6_1:
	eax_100 = ecx_94
l0804AFF9:
	word32 ecx_3536
	word32 edx_3537
	word32 eax_110 = strcmp(dwArg0C, eax_100 + ecx_76, out ecx_3536, out edx_3537)
	esp_1059 = fp - 0x6C
	branch eax_110 >= 0x00 l0804AFB8
l0804B00F:
	edi = esi_84 >> 0x01
	branch ebx_130 < esi_84 >> 0x01 l0804AFE1
	goto l0804AF80
l0804B020:
	branch eax_141 > esi_213 l0804AEC5
l0804B029:
	esi_217 = *esi_1130.u0
	eax_218 = eax_212->t0004
	goto l0804AEA0
l0804B038:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg12 = <invalid>
	Eq_2 stackArg36 = <invalid>
	Eq_2 stackArg40 = <invalid>
	Eq_2 stackArg88 = <invalid>
	Eq_2 stackArg92 = <invalid>
	_nl_load_domain(fp - 4, gs, dwArg04, dwArg08, stackArg12, stackArg36, stackArg40, dwLoc44, dwLoc40, dwLoc3C, dwLoc38, stackArg88, stackArg92)
	goto l0804AE09
l0804B050:
	dwLoc38 = esi_217
l0804B055:
	struct Eq_2878 * eax_266 = (word32) *((word32) esi_1130 + 28) + edi * 0x08
	Eq_2 edx_267 = eax_266->t0000
	Eq_2 eax_268 = eax_266->t0004
	branch *((word32) esi_1130 + 0x0C) == 0x00 l0804B1B0
l0804B06B:
	dwLoc30_1872 = __bswap(eax_268) + dwLoc38
	dwLoc3C = (word32) __bswap(edx_267) + 1
	goto l0804AF42
l0804B080:
	branch dwArg08 == 0x00 l0804B170
l0804B08B:
	Eq_2 eax_353 = *((word32) dwArg08 + 8)
	dwLoc38 = eax_353
	branch eax_353 == 0x00 l0804B170
l0804B099:
	Mem536 = Mem497
	Eq_2 edx_537 = *((byte) esi_1130.u0 + 60)
	branch edx_537 == 0x00 l0804B1CE
	goto l0804B0C0
l0804B0B5:
l0804B0C0:
	dwLoc40 = esi_1130
	dwLoc44 = edi
	Eq_2 edi_547 = edx_537
	Eq_2 esi_549 = *((byte) esi_1130.u0 + 56) - 0x0C + edx_537 * 0x0C
	goto l0804B0EB
l0804B0E0:
	esi_549 = esi_549 - 0x0C
	branch edi_547 == 0x00 l0804B1C8
l0804B0EB:
	edi_547 = edi_547 - 0x01
	esp_1059 = fp - 0x6C
	word32 ecx_3569
	word32 edx_3570
	branch strcmp(*esi_549, dwLoc38, out ecx_3569, out edx_3570) != 0x00 l0804B0E0
l0804B104:
	dwLoc38 = esi_549
l0804B12C:
	branch *((word32) dwLoc38 + 4) == ~0x00 l0804AF4D
l0804B139:
	Eq_2 eax_1462
	Eq_2 eax_1364 = *((word32) dwLoc38 + 8)
	branch eax_1364 == 0x00 l0804B72B
l0804B144:
	branch eax_1364 == ~0x00 l0804B2E1
l0804B14D:
	eax_1462 = *((word32) eax_1364 + edi * 0x04)
	branch eax_1462 == 0x00 l0804B32D
l0804B158:
	dwLoc30_1872 = (word32) eax_1462 + 4
	dwLoc3C = *eax_1462
	goto l0804AF4D
l0804B170:
	branch output_charset_cached.11630 == 0x00 l0804B2ED
l0804B181:
	dwLoc38 = output_charset_cache.11629
l0804B18A:
	branch dwLoc38 != 0x00 l0804B099
l0804B195:
	dwLoc38 = *((word32) gs->ptrFFFFFFD0->t0000 + 92)
	goto l0804B099
l0804B1B0:
	dwLoc30_1872 = eax_268 + dwLoc38
	dwLoc3C = (word32) edx_267 + 1
	goto l0804AF42
l0804B1CE:
	dwLoc40.u0 = 0x00
	Mem636 = Mem586
	Eq_2 edx_637 = *((byte) esi_1130.u0 + 60)
	Eq_2 ebx_638 = *((byte) esi_1130.u0 + 56)
	dwLoc54 = edx_637
	branch edx_637 == 0x00 l0804B47C
	goto l0804B220
l0804B1F0:
l0804B20C:
l0804B220:
	dwLoc44 = esi_1130
	dwLoc48 = edi
	Eq_2 edi_650 = edx_637
	Eq_2 esi_651 = ebx_638 - 0x0C + edx_637 * 0x0C
	goto l0804B243
l0804B238:
	esi_651 = esi_651 - 0x0C
	branch edi_650 == 0x00 l0804B476
l0804B243:
	edi_650 = edi_650 - 0x01
	esp_1059 = fp - 0x6C
	word32 edx_3583
	word32 ecx_3582
	branch strcmp(*esi_651, dwLoc38, out ecx_3582, out edx_3583) != 0x00 l0804B238
l0804B25C:
	dwLoc38 = esi_651
l0804B265:
	branch dwLoc40 != 0x00 l0804B11A
	goto l0804B12C
l0804B270:
l0804B278:
	branch eax_56 > esi_84 >> 0x01 l0804B055
	goto l0804AF2C
l0804B290:
	Eq_2 eax_1646 = *edx_1625
	esp_1622->tFFFFFFF8 = edx_1625
	transmem_list = eax_1646
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	word32 ecx_3568
	free(gs, stackArg0, stackArg4, out ecx_3568, out edx_1654)
l0804B2A9:
	freemem.11586 = null
	freemem_size.11587.u0 = 0x00
	branch gs->t000C == 0x00 l0804B2CD
l0804B2CC:
	__lock()
l0804B2CD:
	Eq_2 v35_1689 = lock.11578 - 0x01
	lock.11578 = v35_1689
	branch v35_1689 == 0x00 l0804B2E1
l0804B2D6:
	__lll_unlock_wake_private(0x080CF570, 0x080CE000, edx_1654, gs)
l0804B2E1:
	dwLoc30_1872.u0 = ~0x00
	goto l0804AF87
l0804B2ED:
	Eq_2 eax_375 = getenv(0x080A228C)
	branch eax_375 == 0x00 l0804B30F
l0804B306:
	branch *eax_375 != 0x00 l0804B78D
l0804B30F:
	dwLoc38 = output_charset_cache.11629
l0804B31B:
	output_charset_cached.11630 = 0x01
	goto l0804B18A
l0804B32D:
	branch gs->t000C == 0x00 l0804B340
l0804B33F:
	__lock()
l0804B340:
	word32 eax_1477
	branch __cmpxchg(lock.11578, 0x01, eax_1462, out eax_1477) l0804B354
l0804B349:
	__lll_lock_wait_private(eax_1477, 0x080CF570, gs)
l0804B354:
	dwLoc48 = edi
	Eq_2 dwLoc2C_2557 = dwLoc30_1872
	esi_1130 = freemem_size.11587
	edi.u0 = 0x00
	ptr32 dwLoc28_2558 = freemem.11586 + 1
	dwLoc40 = fp - 0x24
	dwLoc44 = fp - 0x28
	goto l0804B3E1
l0804B388:
	edi = edi + 0x01
	struct Eq_3231 * esp_1622 = esp_1059 - 0x08
	Eq_2 edx_1625 = transmem_list
	esp_1622->dwFFFFFFFC = edi *s 0x0FF0
	esp_1622->tFFFFFFF8 = edx_1625
	freemem_size.11587 = edi *s 0x0FF0
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	esi_1130 = edi *s 0x0FF0
	dwLoc34 = edx_1625
	word32 edx_3555
	word32 ebp_3556
	word32 esi_3557
	word32 edi_3558
	eax_1635 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx_3555, out ebp_3556, out esi_3557, out edi_3558)
	branch eax_1635 == 0x00 l0804B290
l0804B3BD:
	transmem_list = eax_1635
	esi_1130 = edi *s 0x0FF0 - 0x04
l0804B3C9:
	freemem.11586 = (word32) eax_1635 + 4
	freemem_size.11587 = esi_1130
	dwLoc28_2558 = (word32) eax_1635 + 8
l0804B3E1:
	branch esi_1130 <= 0x03 l0804B42A
l0804B3E6:
	struct Eq_3020 * esp_1514 = esp_1059 - 0x08
	esp_1514->ptrFFFFFFFC = fp - 0x24
	esp_1514->dwFFFFFFF8 = (word32) esi_1130 + (dwLoc28_2558 - 0x04)
	esp_1514->ptrFFFFFFF4 = fp - 0x28
	Mem1528[esp_1514 + -16:word32] = dwLoc3C + dwLoc2C_2557
	esp_1514->ptrFFFFFFEC = fp - 44
	esp_1514->tFFFFFFE8 = *((word32) dwLoc38 + 4)
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>
	Eq_2 ecx_1541
	Eq_2 edx_1542
	ui32 eax_1540 = __gconv(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, out ecx_1541, out edx_1542)
	esp_1059 = (struct Eq_2581 *) (&esp_1514->ptrFFFFFFFC + 3)
	branch (eax_1540 & ~0x04) == 0x00 l0804B81D
l0804B41B:
	branch eax_1540 != 0x05 l0804AF57
l0804B424:
	dwLoc2C_2557 = dwLoc30_1872
l0804B42A:
	Eq_2 eax_1635
	Eq_2 edx_1654
	branch edi != 0x00 l0804B388
l0804B432:
	esp_1059->dwFFFFFFF0 = 0x0FF0
	freemem_size.11587.u0 = 0x0FF0
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	edi.u0 = 0x080CE000
	word32 edi_3565
	word32 ebp_3563
	word32 esi_3564
	word32 ebx_3562
	word32 ecx_3561
	eax_1635 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3561, out edx_1654, out ebx_3562, out ebp_3563, out esi_3564, out edi_3565)
	branch eax_1635 == 0x00 l0804B2A9
l0804B459:
	Eq_2 edx_1701 = transmem_list
	transmem_list = eax_1635
	*eax_1635 = edx_1701
	esi_1130.u0 = 0x0FEC
	edi.u0 = 0x01
	goto l0804B3C9
l0804B47C:
	Eq_2 ebx_716
	ui32 eax_688 = (word32) edx_637 + 3 + edx_637 * 0x02
	dwLoc44 = eax_688 << 0x02
	branch ebx_638 == 0x00 l0804B7DC
l0804B494:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	word32 edx_3592
	word32 ebp_3593
	word32 esi_3594
	word32 edi_3595
	ebx_716 = __realloc(gs, stackArg0, ebx_638, eax_688 << 0x02, out edx_3592, out ebp_3593, out esi_3594, out edi_3595)
l0804B4A6:
	branch ebx_716 == 0x00 l0804B7F4
l0804B4AE:
	*((byte) esi_1130.u0 + 56) = ebx_716
	Eq_2 eax_747 = strdup(dwLoc38)
	dwLoc48 = eax_747
	branch eax_747 == 0x00 l0804B7F4
l0804B4CA:
	Eq_2 ecx_784 = ebx_716 - 0x0C + (eax_688 << 0x02)
	*ecx_784 = eax_747
	((word32) ecx_784 + 4)->u0 = ~0x00
	dwLoc38 = ecx_784
	eax_1311 = _nl_find_msg(edi, gs, dwArg04, dwArg08, 134955513, 0x00, fp - 0x24)
	esp_1059 = fp - 0x6C
	branch eax_1311 == ~0x00 l0804B8DF
l0804B507:
	branch eax_1311 == 0x00 l0804B718
l0804B50F:
	word32 edx_3597
	word32 ecx_3596
	Eq_2 eax_820 = strstr(gs, eax_1311, 0x080A229B, out ecx_3596, out edx_3597)
	esp_1059 = fp - 0x6C
	branch eax_820 == 0x00 l0804B718
l0804B52A:
	Eq_2 eax_837 = strcspn((word32) eax_820 + 8, 0x080A22A4)
	struct Eq_3639 * esp_844 = fp - 0x6C
	struct Eq_3639 * ebx_849 = fp - 0x6C - ((word32) eax_837 + 28 & ~0x0FFF)
	ui32 ecx_850 = (word32) eax_837 + 28 & ~0x0F
	branch fp - 0x6C == ebx_849 l0804B570
l0804B55E:
	esp_844 = esp_844 - 0x1000
	esp_844->dw0FFC = esp_844->dw0FFC
	branch esp_844 != ebx_849 l0804B55E
l0804B570:
	branch (ecx_850 & 0x0FFF) == 0x00 l0804B582
l0804B57B:
	esp_844 = esp_844 - (ecx_850 & 0x0FFF)
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_844 - 0x04)[(ecx_850 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_844 - 0x04)[(ecx_850 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]
l0804B582:
	struct Eq_3670 * esp_883 = esp_844 - 0x04
	esp_883->tFFFFFFFC = eax_837
	esp_883->tFFFFFFF8 = (word32) eax_820 + 8
	Eq_3680 edx_882 = (char *) esp_844 + 0x0F
	esp_883->tFFFFFFF4 = edx_882 & ~0x0F
	word32 edx_3598
	*__mempcpy(esp_883->tFFFFFFF4, esp_883->tFFFFFFF8, esp_883->tFFFFFFFC, out edx_3598) = 0x00
	up32 ebx_884 = 0x00
	esp_1059 = (struct Eq_2581 *) ((char *) &esp_883->tFFFFFFFC + 8)
	Eq_2 eax_913 = eax_747
	goto l0804B5BE
l0804B5B0:
	eax_913 = (word32) eax_913 + 1
	ebx_884 = ebx_884 + (word32) (dl_917 == 0x2F)
l0804B5BE:
	byte dl_917 = *eax_913
	branch dl_917 != 0x00 l0804B5B0
l0804B5C5:
	Eq_3739 eax_930 = eax_913 - eax_747
	struct Eq_2581 * ecx_936 = (char *) &esp_883->tFFFFFFFC + 8 - ((word32) eax_930 + 38 & ~0x0FFF)
	ui32 edx_937 = (word32) eax_930 + 38 & ~0x0F
	branch (char *) &esp_883->tFFFFFFFC + 8 == ecx_936 l0804B5F1
l0804B5DF:
	esp_1059 = esp_1059 - 0x1000
	esp_1059[0x03FF] = esp_1059[0x03FF]
	branch esp_1059 != ecx_936 l0804B5DF
l0804B5F1:
	branch (edx_937 & 0x0FFF) == 0x00 l0804B601
l0804B5FA:
	esp_1059 = esp_1059 - (edx_937 & 0x0FFF)
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_937 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_937 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]
l0804B601:
	Eq_3767 eax_965 = (char *) &esp_1059->dwFFFFFFF0 + 31
	Eq_2 edx_970 = eax_747
	struct Eq_3771 * ecx_1009 = eax_965 & ~0x0F
	dwLoc54 = eax_965 & ~0x0F
	byte al_975 = *eax_747
	branch al_975 == 0x00 l0804B940
l0804B61E:
	Eq_3803 eax_986[] = g_ptr80CE084
	int32 eax_1000 = (int32) al_975
l0804B631:
	ecx_1009 = ecx_1009 + 1
	ecx_1009->bFFFFFFFF = (byte) eax_986[eax_1000]
	edx_970 = (word32) edx_970 + 1
	eax_1000 = (int32) *edx_970
	branch (byte) eax_1000 != 0x00 l0804B631
l0804B64A:
	branch ebx_884 <= 0x01 l0804B898
l0804B653:
	ecx_1009->b0000 = 0x00
	byte * eax_1025 = edx_882 & ~0x0F
	ebx_1026 = 0x00
	goto l0804B66B
l0804B65D:
	eax_1025 = eax_1025 + 1
	ebx_1026 = ebx_1026 + (word32) (dl_1032 == 0x2F)
l0804B66B:
	byte dl_1032 = *eax_1025
	branch dl_1032 != 0x00 l0804B65D
l0804B672:
	Eq_3841 eax_1045 = eax_1025 - (edx_882 & ~0x0F)
	struct Eq_2581 * ecx_1054 = esp_1059 - ((word32) eax_1045 + 30 & ~0x0FFF)
	ui32 edx_1055 = (word32) eax_1045 + 30 & ~0x0F
	branch esp_1059 == ecx_1054 l0804B69E
l0804B68C:
	esp_1059 = esp_1059 - 0x1000
	esp_1059[0x03FF] = esp_1059[0x03FF]
	branch esp_1059 != ecx_1054 l0804B68C
l0804B69E:
	branch (edx_1055 & 0x0FFF) == 0x00 l0804B6AE
l0804B6A7:
	esp_1059 = esp_1059 - (edx_1055 & 0x0FFF)
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_1055 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_1055 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]
l0804B6AE:
	Eq_3868 eax_1083 = (char *) &esp_1059->dwFFFFFFF0 + 31
	int32 eax_1091 = (int32) *(edx_882 & ~0x0F)
	edx_1085 = eax_1083 & ~0x0F
	dwLoc44 = eax_1083 & ~0x0F
	branch (byte) eax_1091 == 0x00 l0804B91E
l0804B6C8:
	byte * esi_1112 = edx_882 & ~0x0F
	Eq_3803 ecx_1113[] = g_ptr80CE084
l0804B6D7:
	edx_1085 = edx_1085 + 0x01
	*((word32) edx_1085 - 1) = ecx_1113[eax_1091]
	esi_1112 = esi_1112 + 1
	eax_1091 = (int32) *esi_1112
	branch (byte) eax_1091 != 0x00 l0804B6D7
l0804B6ED:
	branch ebx_1026 <= 0x01 l0804B889
l0804B6F6:
	*edx_1085 = 0x00
	struct Eq_2820 * esp_1196 = esp_1059 - 4
	esp_1196->dw0000 = 0x01
	esp_1196->dwFFFFFFFC = (word32) dwLoc38 + 4
	esp_1196->tFFFFFFF8 = dwLoc44
	esp_1196->tFFFFFFF4 = dwLoc54
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>
	word32 eax_1266 = __gconv_open(gs, stackArg4, dwArg04, dwArg08, dwArg0C)
	esp_1059 = (struct Eq_2581 *) (&esp_1196->dw0000 + 1)
	branch eax_1266 != 0x00 l0804B8AB
l0804B718:
	((word32) dwLoc38 + 8)->u0 = 0x00
	*((word32) esi_1130 + 60) = (word32) *((word32) esi_1130 + 60) + 1
	goto l0804B265
l0804B72B:
	Eq_2 ecx_1368 = 0x01
	branch gs->t000C == 0x00 l0804B73E
l0804B73D:
	__lock()
l0804B73E:
	word32 eax_1377
	branch __cmpxchg(lock.11578, 0x01, eax_1364, out eax_1377) l0804B752
l0804B747:
	ecx_1368 = __lll_lock_wait_private(eax_1377, 0x080CF570, gs)
l0804B752:
	Eq_2 edx_1391 = *((word32) dwLoc38 + 8)
	branch edx_1391 == 0x00 l0804B8E7
l0804B760:
	branch gs->t000C == 0x00 l0804B76E
l0804B76D:
	__lock()
l0804B76E:
	Eq_2 v32_1437 = lock.11578 - 0x01
	lock.11578 = v32_1437
	branch v32_1437 == 0x00 l0804B782
l0804B777:
	__lll_unlock_wake_private(0x080CF570, ecx_1368, edx_1391, gs)
l0804B782:
	eax_1364 = *((word32) dwLoc38 + 8)
	goto l0804B144
l0804B78D:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_3571
	word32 edx_3572
	Eq_2 eax_393 = strlen(eax_375, out ecx_3571, out edx_3572)
	Eq_2 stackArg0 = <invalid>
	word32 ebp_3577
	word32 esi_3578
	word32 edi_3579
	word32 edx_3575
	word32 ebx_3576
	word32 ecx_3574
	Eq_2 eax_434 = __libc_malloc(gs, stackArg0, (word32) eax_393 + 1, out ecx_3574, out edx_3575, out ebx_3576, out ebp_3577, out esi_3578, out edi_3579)
	dwLoc38 = eax_434
	branch eax_434 == 0x00 l0804B7CB
l0804B7B4:
	word32 ecx_3580
	word32 edx_3581
	memcpy(eax_434, eax_375, (word32) eax_393 + 1, out ecx_3580, out edx_3581)
l0804B7CB:
	output_charset_cache.11629 = eax_434
	goto l0804B31B
l0804B7DC:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	word32 ecx_3585
	word32 edx_3586
	word32 edi_3590
	word32 ebx_3587
	word32 esi_3589
	word32 ebp_3588
	ebx_716 = __libc_malloc(gs, stackArg0, eax_688 << 0x02, out ecx_3585, out edx_3586, out ebx_3587, out ebp_3588, out esi_3589, out edi_3590)
	goto l0804B4A6
l0804B7F4:
	esp_1059 = fp - 0x6C
	goto l0804B2E1
l0804B81D:
	word32 * edx_1551 = freemem.11586
	word32 ecx_1553 = dwLoc28_2558 - edx_1551
	*edx_1551 = ecx_1553 - 0x04
	*((word32) *((word32) dwLoc38 + 8) + edi * 0x04) = edx_1551
	ui32 edx_1560 = freemem_size.11587 - ecx_1553
	freemem_size.11587 = edx_1560 & ~0x03
	freemem.11586 = dwLoc28_2558 + (edx_1560 & 0x03)
	esi_1130.u0 = 0x080CE000
	branch gs->t000C == 0x00 l0804B867
l0804B866:
	__lock()
l0804B867:
	Eq_2 v34_1571 = lock.11578 - 0x01
	lock.11578 = v34_1571
	branch v34_1571 == 0x00 l0804B87B
l0804B870:
	__lll_unlock_wake_private(0x080CF570, edx_1560 & 0x03, edx_1560 & ~0x03, gs)
l0804B87B:
	eax_1462 = *((word32) *((word32) dwLoc38 + 8) + edi * 0x04)
	goto l0804B158
l0804B889:
	*edx_1085 = 0x2F
	branch ebx_1026 == 0x00 l0804B90D
l0804B890:
	edx_1085 = (word32) edx_1085 + 1
	goto l0804B6F6
l0804B898:
	ecx_1009->b0000 = 0x2F
	branch ebx_884 == 0x00 l0804B926
l0804B8A3:
	ecx_1009 = ecx_1009 + 1
	goto l0804B653
l0804B8AB:
	branch eax_1266 == 0x01 l0804B957
l0804B8B4:
	branch dwLoc40 == 0x00 l0804B8CC
l0804B8BA:
	Eq_2 eax_1283 = (word32) esi_1130 + 64
	esp_1196->tFFFFFFF4 = eax_1283
	fn00000000()
l0804B8CC:
	struct Eq_2916 * esp_1294 = esp_1059 - 0x0C
	esp_1294->tFFFFFFFC = dwLoc48
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	word32 ecx_3543
	word32 edx_3544
	free(gs, stackArg0, stackArg4, out ecx_3543, out edx_3544)
	esp_1059 = (struct Eq_2581 *) ((char *) &esp_1294->tFFFFFFFC + 16)
	eax_1311.u0 = 0x00
l0804B8DF:
	dwLoc30_1872 = eax_1311
	goto l0804AF87
l0804B8E7:
	struct Eq_3116 * esp_1398 = esp_1059 - 0x08
	esp_1398->dwFFFFFFFC = 0x04
	Mem1409[esp_1398 + -8:word32] = dwLoc34 + Mem1402[esi_1130 + 0x20:word32]
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>
	word32 ebp_3548
	word32 edi_3550
	word32 ebx_3547
	word32 esi_3549
	Eq_2 eax_1417 = __libc_calloc(gs, stackArg4, dwArg04, out ecx_1368, out edx_1391, out ebx_3547, out ebp_3548, out esi_3549, out edi_3550)
	branch eax_1417 == 0x00 l0804B948
l0804B902:
	*((word32) dwLoc38 + 8) = eax_1417
	goto l0804B354
l0804B90D:
	*((word32) edx_1085 + 1) = 0x2F
	edx_1085 = (word32) edx_1085 + 2
	goto l0804B6F6
l0804B919:
	word32 ecx_3538
	word32 edx_3539
	__stack_chk_fail(out ecx_3538, out edx_3539)
l0804B91E:
	edx_1085 = dwLoc44
	goto l0804B6ED
l0804B926:
	ecx_1009[1] = (struct Eq_3771) 0x2F
	ecx_1009 = ecx_1009 + 0x0A
	ecx_1009->dwFFFFFFF8 = 0x4E415254
	ecx_1009->dwFFFFFFFC = 1414089811
	goto l0804B653
l0804B940:
	ecx_1009 = eax_965 & ~0x0F
	goto l0804B64A
l0804B948:
	((word32) dwLoc38 + 8)->u0 = ~0x00
	goto l0804B760
l0804B957:
	((word32) dwLoc38 + 4)->u0 = ~0x00
	goto l0804B718
_nl_find_msg_exit:
}

// 0804B970: void __dcigettext(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack word32 dwArg14, Stack Eq_2 dwArg18)
// Called from:
//      dcgettext
void __dcigettext(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, word32 dwArg14, Eq_2 dwArg18)
{
	struct Eq_3937 * ebp_1188 = fp - 4;
	if (dwArg08 != 0x00)
	{
		if (dwArg18 > 0x0C || dwArg18 == 0x06)
		{
			if (dwArg10 != 0x00 && dwArg14 != 0x01)
				goto l0804BEAD;
			goto l0804BE83;
		}
		Eq_2 eax_52 = gs->tFFFFFFE0;
		Eq_2 eax_76 = dwArg04;
		if (dwArg04 == 0x00)
			eax_76 = _nl_current_default_domain;
		word32 eax_100;
		__current_locale_name(gs, dwArg18, out eax_100);
		Eq_2 eax_146 = __tfind(fp - 0x40, 135067000, 134524144);
		Mem175 = Mem155;
		if (eax_146 == 0x00)
		{
l0804BABA:
			Eq_2 dwLoc60_1406;
			struct Eq_4005 * esp_314;
			Eq_2 eax_250 = _nl_domain_bindings;
			Eq_2 dwLoc54_1399 = eax_250;
			if (eax_250 != 0x00)
			{
				Eq_2 esi_256 = eax_250;
				do
				{
					word32 ecx_2192;
					word32 edx_2193;
					Eq_2 eax_268 = strcmp(eax_76, (word32) esi_256 + 0x0C, out ecx_2192, out edx_2193);
					if (eax_268 == 0x00)
					{
						Eq_2 eax_295 = *((word32) esi_256 + 4);
						dwLoc54_1399 = esi_256;
						dwLoc60_1406 = eax_295;
						if (*eax_295 == 0x2F)
							goto l0804BB58;
						word32 edi_2195;
						word32 edx_2194;
						Eq_2 eax_310 = getcwd(gs, 0x00, 0x00, out edx_2194, out edi_2195);
						esp_314 = fp - 0x9C;
						if (eax_310 == 0x00)
							goto l0804BE38;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2127 eax_330 = ___asprintf();
						Eq_2 stackArg0 = <invalid>;
						word32 ecx_2201;
						word32 edx_2202;
						free(gs, stackArg0, eax_310, out ecx_2201, out edx_2202);
						esp_314 = fp - 0x9C;
						if (eax_330 < 0x00)
							goto l0804BE38;
						dwLoc60_1406.u0 = 0x00;
						goto l0804BB58;
					}
					if (eax_268 < 0x00)
					{
						dwLoc54_1399.u0 = 0x00;
						goto l0804BF07;
					}
					esi_256 = *esi_256;
				} while (esi_256 != 0x00);
				dwLoc54_1399 = esi_256;
				dwLoc60_1406.u0 = 0x080A22C0;
			}
			else
			{
l0804BF07:
				dwLoc60_1406.u0 = 0x080A22C0;
			}
l0804BB58:
			Eq_2 eax_361 = 0x080A58E0 + (word32) (*((word32) dwArg18 + 0x080A58D0));
			Eq_2 eax_365;
			__current_locale_name(gs, dwArg18, out eax_365);
			bool Z_369 = <invalid>;
			bool C_368 = <invalid>;
			cu8 * edi_359 = &g_b80A4B32;
			word32 ecx_371 = 0x02;
			Eq_2 esi_373 = eax_365;
			Eq_2 edx_374 = eax_365;
			bool v57_1304 = Z_369 | C_368;
			while (ecx_371 != 0x00)
			{
				v57_1304 = *esi_2242 > *edi_2243;
				esi_373 = (word32) esi_2242 + 1;
				edi_359 = edi_2243 + 1;
				--ecx_371;
				esi_2242 = esi_373;
				edi_2243 = edi_359;
				if (*esi_2242 == *edi_2243)
					break;
			}
			if ((int8) v57_1304 - (byte) C_368 != 0x00)
			{
				Eq_2 eax_409 = getenv(0x080A22AE);
				edx_374 = eax_365;
				if (eax_409 != 0x00 && *eax_409 != 0x00)
					edx_374 = eax_409;
			}
			word32 edx_2204;
			word32 ecx_2203;
			Eq_2 eax_435 = strlen(eax_76, out ecx_2203, out edx_2204);
			word32 ecx_2205;
			word32 edx_2206;
			ui32 eax_458 = (word32) strlen(eax_361, out ecx_2205, out edx_2206) + ((word32) eax_435 + 32);
			struct Eq_4207 * esp_456 = fp - 0x9C;
			struct Eq_4207 * edi_462 = fp - 0x9C - (eax_458 & ~0x0FFF);
			if (fp - 0x9C != edi_462)
			{
				do
				{
					esp_456 -= 0x1000;
					esp_456->dw0FFC = esp_456->dw0FFC;
				} while (esp_456 != edi_462);
			}
			int32 ecx_478 = eax_458 & ~0x0F & 0x0FFF;
			if (ecx_478 != 0x00)
			{
				esp_456 -= ecx_478;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_456 - 0x04)[ecx_478 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_456 - 0x04)[ecx_478 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			struct Eq_4246 * esp_491 = esp_456 - 0x08;
			esp_491->tFFFFFFFC = eax_361;
			Eq_4252 eax_490 = (char *) esp_456 + 0x0F;
			esp_491->tFFFFFFF8 = eax_490 & ~0x0F;
			word32 ecx_2207;
			Eq_2 eax_510 = __stpcpy(esp_491->tFFFFFFF8, esp_491->tFFFFFFFC, out ecx_2207);
			eax_510->u5 = 0x2F;
			esp_491->t0000 = eax_435;
			esp_491->tFFFFFFFC = eax_76;
			esp_491->tFFFFFFF8 = (word32) eax_510 + 1;
			word32 edx_2208;
			*__mempcpy(esp_491->tFFFFFFF8, esp_491->tFFFFFFFC, esp_491->t0000, out edx_2208) = 0x006F6D2E;
			esp_491->tFFFFFFF8 = edx_374;
			word32 ecx_2209;
			word32 edx_2210;
			Eq_2 eax_542 = strlen(esp_491->tFFFFFFF8, out ecx_2209, out edx_2210);
			struct Eq_4005 * esp_549 = (char *) &esp_491->t0000 + 8;
			Eq_2 edx_550 = edx_374;
			struct Eq_4005 * esi_555 = (char *) &esp_491->t0000 + 8 - ((word32) eax_542 + 28 & ~0x0FFF);
			ui32 ecx_556 = (word32) eax_542 + 28 & ~0x0F;
			if ((char *) &esp_491->t0000 + 8 != esi_555)
			{
				do
				{
					esp_549 -= 0x1000;
					esp_549->dw0FFC = esp_549->dw0FFC;
				} while (esp_549 != esi_555);
			}
			if ((ecx_556 & 0x0FFF) != 0x00)
			{
				esp_549 -= ecx_556 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_549 - 0x04)[(ecx_556 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_549 - 0x04)[(ecx_556 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_4359 eax_583 = (char *) &esp_549->dwFFFFFFF8 + 23;
			do
			{
l0804BCC0:
				while (true)
				{
					cu8 al_605 = *edx_550;
					if (al_605 != 0x3A)
						break;
					edx_550 = (word32) edx_550 + 1;
				}
				bool v61_1308 = al_605 > 0x00;
				if (al_605 == 0x00)
				{
					*(eax_583 & ~0x0F) = 0x43;
					break;
				}
				struct Eq_4382 * ecx_614 = eax_583 & ~0x0F;
				do
				{
					++ecx_614;
					ecx_614->bFFFFFFFF = al_605;
					edx_550 = (word32) edx_550 + 1;
					al_605 = (cu8) *edx_550;
				} while (al_605 != 0x00 && al_605 != 0x3A);
				ecx_614->b0000 = 0x00;
				Eq_4846 esi_636 = *(union Eq_4846 *) 0x080CDDAC;
				v61_1308 = esi_636 > 0x00;
				if (esi_636 == 0x00)
					break;
				struct Eq_4870 * esp_643 = esp_549 - 0x08;
				esp_643->dwFFFFFFFC = 0x2F;
				esp_643->tFFFFFFF8 = eax_583 & ~0x0F;
				word32 ecx_2240;
				word32 edx_2241;
				Eq_2 eax_652 = strchr(esp_643->tFFFFFFF8, esp_643->t0004, out ecx_2240, out edx_2241);
				v61_1308 = eax_652 > 0x00;
			} while (eax_652 != 0x00);
			esp_314 = esp_549;
			cu8 * esi_670 = eax_583 & ~0x0F;
			cu8 * edi_671 = &g_b80A4B32;
			word32 ecx_672 = 0x02;
			while (ecx_672 != 0x00)
			{
				v61_1308 = *esi_2244 > *edi_2245;
				esi_670 = esi_2244 + 1;
				edi_671 = edi_2245 + 1;
				--ecx_672;
				esi_2244 = esi_670;
				edi_2245 = edi_671;
				if (*esi_2244 == *edi_2245)
					break;
			}
			Eq_4390 al_696 = (int8) v61_1308 - (byte) (*esi_2244 < *edi_2245);
			bool v68_1315 = al_696 > 0x00;
			if (al_696 != 0x00)
			{
				cu8 * esi_703 = eax_583 & ~0x0F;
				cu8 * edi_704 = &g_b80A22B7;
				word32 ecx_705 = 0x06;
				while (ecx_705 != 0x00)
				{
					v68_1315 = *esi_2246 > *edi_2247;
					esi_703 = esi_2246 + 1;
					edi_704 = edi_2247 + 1;
					--ecx_705;
					esi_2246 = esi_703;
					edi_2247 = edi_704;
					if (*esi_2246 == *edi_2247)
						break;
				}
				if ((int8) v68_1315 - (byte) (*esi_2246 < *edi_2247) != 0x00)
				{
					struct Eq_4475 * esp_735 = esp_549 - 4;
					esp_735->t0000 = dwLoc54_1399;
					esp_735->dwFFFFFFFC = eax_490 & ~0x0F;
					esp_735->dwFFFFFFF8 = eax_583 & ~0x0F;
					esp_735->tFFFFFFF4 = dwLoc60_1406;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 eax_772 = _nl_find_domain(gs, stackArg4, dwArg04, dwArg08, dwArg0C);
					Eq_2 edi_780 = eax_772;
					if (eax_772 != 0x00)
					{
						Eq_2 esi_850;
						esp_549->dwFFFFFFF0 = fp - 0x44;
						esp_549->dwFFFFFFEC = 0x01;
						esp_549->dwFFFFFFE8 = (word32) dwArg08;
						esp_549->dwFFFFFFE4 = (word32) dwLoc54_1399;
						esp_549->dwFFFFFFE0 = (word32) eax_772;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						Eq_2 eax_797 = _nl_find_msg(eax_772, gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10);
						esp_314 = esp_549;
						if (eax_797 != 0x00)
						{
							esi_850 = eax_797;
							if (eax_797 != ~0x00)
							{
l0804BD60:
								esp_549->dwFFFFFFF0 = 0x00;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg0 = <invalid>;
								Eq_2 stackArg4 = <invalid>;
								word32 ecx_2215;
								word32 edx_2216;
								free(gs, stackArg0, stackArg4, out ecx_2215, out edx_2216);
								if (eax_146 != 0x00)
								{
									struct Eq_4012 * eax_1159 = *eax_146;
									eax_1159->t000C = _nl_msg_cat_cntr;
									eax_1159->t0010 = edi_780;
									eax_1159->t0014 = esi_850;
									eax_1159->t0018 = dwLoc44;
								}
								else
								{
									esp_549->dwFFFFFFF0 = (word32) dwArg08;
									word32 edx_2218;
									word32 ecx_2217;
									Eq_2 eax_949 = strlen(esp_549->dwFFFFFFF0, out ecx_2217, out edx_2218);
									esp_549->dwFFFFFFF0 = eax_100;
									word32 ecx_2219;
									word32 edx_2220;
									esp_549->dwFFFFFFF0 = (word32) strlen(esp_549->dwFFFFFFF0, out ecx_2219, out edx_2220) + ((word32) eax_435 + 30) + ((word32) eax_949 + 1);
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg0 = <invalid>;
									Eq_2 stackArg4 = <invalid>;
									word32 edx_2224;
									word32 ebx_2225;
									word32 esi_2227;
									word32 edi_2228;
									word32 ebp_2226;
									word32 ecx_2223;
									Eq_2 eax_976 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_2223, out edx_2224, out ebx_2225, out ebp_2226, out esi_2227, out edi_2228);
									if (eax_976 != 0x00)
									{
										esp_549->dwFFFFFFF8 = (word32) eax_949 + 1;
										esp_549->dwFFFFFFF4 = (word32) dwArg08;
										esp_549->dwFFFFFFF0 = (word32) eax_976 + 28;
										word32 edx_2229;
										Eq_2 eax_997 = __mempcpy(esp_549->dwFFFFFFF0, esp_549->dwFFFFFFF4, esp_549->dwFFFFFFF8, out edx_2229);
										esp_549->dwFFFFFFF8 = (word32) eax_435 + 1;
										esp_549->dwFFFFFFF4 = (word32) eax_76;
										esp_549->dwFFFFFFF0 = (word32) eax_997;
										word32 ecx_2230;
										word32 edx_2231;
										memcpy(esp_549->dwFFFFFFF0, esp_549->dwFFFFFFF4, esp_549->dwFFFFFFF8, out ecx_2230, out edx_2231);
										esp_549->dwFFFFFFF4 = eax_100;
										Eq_2 ecx_1027 = (word32) eax_997 + ((word32) eax_435 + 1);
										esp_549->dwFFFFFFF0 = (word32) ecx_1027;
										strcpy(esp_549->dwFFFFFFF0, esp_549->dwFFFFFFF4);
										*eax_976 = eax_997;
										*((word32) eax_976 + 8) = ecx_1027;
										*((word32) eax_976 + 4) = dwArg18;
										*((word32) eax_976 + 16) = edi_780;
										Eq_2 eax_1058 = _nl_msg_cat_cntr;
										*((word32) eax_976 + 20) = esi_850;
										*((word32) eax_976 + 0x0C) = eax_1058;
										*((word32) eax_976 + 24) = dwLoc44;
										esp_549->dwFFFFFFF8 = 134524144;
										esp_549->dwFFFFFFF4 = 135067000;
										esp_549->dwFFFFFFF0 = (word32) eax_976;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg4 = <invalid>;
										word32 ecx_2233;
										word32 edx_2234;
										union Eq_2 * eax_1099 = __tsearch(stackArg4, dwArg04, dwArg08, out ecx_2233, out edx_2234);
										Mem1128 = Mem1093;
										if (eax_1099 == null || *eax_1099 != eax_976)
										{
											esp_549->dwFFFFFFF0 = (word32) eax_976;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_2 stackArg0 = <invalid>;
											Eq_2 stackArg4 = <invalid>;
											word32 ecx_2238;
											word32 edx_2239;
											free(gs, stackArg0, stackArg4, out ecx_2238, out edx_2239);
										}
									}
								}
								gs->tFFFFFFE0 = eax_52;
								if (dwArg10 != 0x00)
								{
									struct Eq_4623 * esp_1177 = esp_549 - 0x0C;
									Eq_2 eax_1180 = *((word32) edi_780 + 8);
									esp_1177->tFFFFFFFC = dwLoc44;
									ebp_1188 = plural_lookup.isra.2(eax_1180, esp_1177->tFFFFFFFC);
								}
								if (ebp_1188->dwFFFFFF90 != 0x00)
								{
									struct Eq_4643 * esp_1205 = esp_549 - 0x0C;
									esp_1205->ptrFFFFFFFC = 0x080CF540;
									fn00000000();
									esp_1205->ptrFFFFFFFC = 0x080CF960;
									word32 ecx_1224;
									word32 edx_1225;
									fn00000000();
								}
								goto l0804BE86;
							}
							goto l0804BE38;
						}
						Eq_2 eax_806 = *((word32) eax_772 + 16);
						if (eax_806 != 0x00)
						{
							Eq_2 edi_815 = 0x00;
							do
							{
								esp_549->dwFFFFFFF0 = fp - 0x44;
								esp_549->dwFFFFFFEC = 0x01;
								esp_549->dwFFFFFFE8 = (word32) dwArg08;
								esp_549->dwFFFFFFE4 = (word32) dwLoc54_1399;
								esp_549->dwFFFFFFE0 = (word32) eax_806;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg4 = <invalid>;
								Eq_2 eax_838 = _nl_find_msg(edi_815, gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10);
								esp_314 = esp_549;
								if (eax_838 == ~0x00)
									goto l0804BE38;
								if (eax_838 != 0x00)
								{
									esi_850 = eax_838;
									edi_780 = *((word32) eax_772 + (edi_815 * 0x04 + 16));
									goto l0804BD60;
								}
								edi_815 = (word32) edi_815 + 1;
								eax_806 = *((word32) eax_772 + (edi_815 * 0x04 + 16));
							} while (eax_806 != 0x00);
						}
					}
					goto l0804BCC0;
				}
			}
l0804BE38:
			esp_314->dwFFFFFFF0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_2198;
			word32 edx_2199;
			free(gs, stackArg0, stackArg4, out ecx_2198, out edx_2199);
			gs->tFFFFFFE0 = eax_52;
			if (dwArg14 != 0x01 && dwArg10 != 0x00)
			{
l0804BEAD:
				goto l0804BE86;
			}
l0804BE83:
			goto l0804BE86;
		}
		struct Eq_4012 * edx_180 = *eax_146;
		if (edx_180->t000C != _nl_msg_cat_cntr)
			goto l0804BABA;
		if (dwArg10 != 0x00)
			ebp_1188 = plural_lookup.isra.2(*((word32) edx_180->t0010 + 8), edx_180->t0018);
		if (ebp_1188->dwFFFFFF90 != 0x00)
		{
			fn00000000();
			word32 ecx_237;
			word32 edx_238;
			fn00000000();
		}
		gs->*ebp_1188->ptrFFFFFF80 = ebp_1188->dwFFFFFF84;
	}
l0804BE86:
	if ((ebp_1188->dwFFFFFFE4 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_2190;
	word32 edx_2191;
	__stack_chk_fail(out ecx_2190, out edx_2191);
	_nl_find_domain(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
}

// 0804C140: Register Eq_2 _nl_find_domain(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __dcigettext
Eq_2 _nl_find_domain(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 edi_155 = dwArg08;
	Eq_2175 eax_27 = gs->t0014;
	word32 ebp_903;
	word32 edi_904;
	word32 edx_901;
	word32 ebx_902;
	word32 ecx_900;
	Eq_2 eax_90 = _nl_make_l10nflist(0x080CF5C0, dwArg04, (word32) strlen(dwArg04, out ecx_900, out edx_901) + 1, 0x00, dwArg08, 0x00, 0x00, 0x00, 0x00, dwArg0C, 0x00, out ebx_902, out ebp_903, out edi_904);
	Eq_2 ebp_284 = eax_90;
	Mem430 = Mem97;
	if (eax_90 == 0x00)
	{
		word32 ebp_906;
		word32 ebx_905;
		Eq_2 eax_126 = _nl_expand_alias(gs, out ebx_905, out ebp_906);
		if (eax_126 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			word32 edx_915;
			word32 ecx_914;
			Eq_2 eax_140 = strlen(eax_126, out ecx_914, out edx_915);
			Eq_2 stackArg0 = <invalid>;
			word32 ebp_920;
			word32 esi_921;
			word32 edi_922;
			word32 ebx_919;
			word32 ecx_917;
			word32 edx_918;
			Eq_2 eax_150 = __libc_malloc(gs, stackArg0, (word32) eax_140 + 1, out ecx_917, out edx_918, out ebx_919, out ebp_920, out esi_921, out edi_922);
			edi_155 = eax_150;
			if (eax_150 == 0x00)
				goto l0804C203;
			word32 ecx_923;
			word32 edx_924;
			memcpy(eax_150, eax_126, (word32) eax_140 + 1, out ecx_923, out edx_924);
		}
		Eq_2 eax_205 = _nl_explode_name(edi_155, fp - 0x34, fp - 0x30, fp - 44, fp - 0x28, fp - 0x24);
		byte bLoc40_718 = (byte) eax_205;
		if (eax_205 != ~0x00)
		{
			word32 ebx_937;
			word32 ebp_938;
			word32 edi_939;
			word32 ecx_935;
			word32 edx_936;
			Eq_2 eax_279 = _nl_make_l10nflist(0x080CF5C0, dwArg04, (word32) strlen(dwArg04, out ecx_935, out edx_936) + 1, eax_205, dwLoc34, dwLoc2C, dwLoc28, dwLoc24, dwLoc30, dwArg0C, 0x01, out ebx_937, out ebp_938, out edi_939);
			ebp_284 = eax_279;
			Mem304 = Mem273;
			if (eax_279 != 0x00)
			{
				if (*((word32) eax_279 + 4) <= 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg12 = <invalid>;
					Eq_2 stackArg36 = <invalid>;
					Eq_2 stackArg40 = <invalid>;
					Eq_2 stackArg88 = <invalid>;
					Eq_2 stackArg92 = <invalid>;
					_nl_load_domain(eax_279, gs, eax_279, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
				}
				if (*((word32) eax_279 + 8) == 0x00)
				{
					Eq_2 eax_333 = *((word32) eax_279 + 16);
					if (eax_333 != 0x00)
					{
						struct Eq_5164 ** esi_337 = (word32) eax_279 + 16;
						do
						{
							if (*((word32) eax_333 + 4) <= 0x00)
							{
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg12 = <invalid>;
								Eq_2 stackArg36 = <invalid>;
								Eq_2 stackArg40 = <invalid>;
								Eq_2 stackArg88 = <invalid>;
								Eq_2 stackArg92 = <invalid>;
								_nl_load_domain(eax_279, gs, eax_333, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
							}
							if (*((char *) *esi_337 + 8) != 0x00)
								break;
							esi_337 = (struct Eq_5164 **) ((char *) esi_337 + 4);
							eax_333 = *esi_337;
						} while (eax_333 != 0x00);
					}
				}
				if (eax_126 != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 edx_947;
					word32 ecx_946;
					free(gs, stackArg0, edi_155, out ecx_946, out edx_947);
				}
			}
			if ((bLoc40_718 & 0x01) != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 edx_960;
				word32 ecx_959;
				free(gs, stackArg0, dwLoc24, out ecx_959, out edx_960);
			}
		}
		goto l0804C203;
	}
	else
	{
		if (*((word32) eax_90 + 4) <= 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg12 = <invalid>;
			Eq_2 stackArg36 = <invalid>;
			Eq_2 stackArg40 = <invalid>;
			Eq_2 stackArg88 = <invalid>;
			Eq_2 stackArg92 = <invalid>;
			_nl_load_domain(eax_90, gs, eax_90, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
		}
		if (*((word32) eax_90 + 8) == 0x00)
		{
			Eq_2 eax_453 = *((word32) eax_90 + 16);
			if (eax_453 != 0x00)
			{
				struct Eq_5098 ** esi_457 = (word32) eax_90 + 16;
				do
				{
					if (*((word32) eax_453 + 4) <= 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg12 = <invalid>;
						Eq_2 stackArg36 = <invalid>;
						Eq_2 stackArg40 = <invalid>;
						Eq_2 stackArg88 = <invalid>;
						Eq_2 stackArg92 = <invalid>;
						_nl_load_domain(eax_90, gs, eax_453, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
					}
					if (*((char *) *esi_457 + 8) != 0x00)
						break;
					esi_457 = (struct Eq_5098 **) ((char *) esi_457 + 4);
					eax_453 = *esi_457;
				} while (eax_453 != 0x00);
			}
		}
l0804C203:
		if ((eax_27 ^ gs->t0014) == 0x00)
			return ebp_284;
		word32 ecx_912;
		word32 edx_913;
		__stack_chk_fail(out ecx_912, out edx_913);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg36 = <invalid>;
		Eq_2 stackArg60 = <invalid>;
		Eq_2 stackArg64 = <invalid>;
		Eq_2 stackArg68 = <invalid>;
		Eq_2 stackArg72 = <invalid>;
		Eq_2 stackArg88 = <invalid>;
		Eq_2 stackArg92 = <invalid>;
		return _nl_load_domain(ebp_284, gs, stackArg4, stackArg8, stackArg12, stackArg36, dwLoc34, stackArg60, stackArg64, stackArg68, stackArg72, stackArg88, stackArg92);
	}
}

// 0804C420: Register Eq_2 _nl_load_domain(Register Eq_2 ebp, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg24, Stack Eq_2 dwArg28, Stack Eq_2 dwArg3C, Stack Eq_2 dwArg40, Stack Eq_2 dwArg44, Stack Eq_2 dwArg48, Stack Eq_2 dwArg58, Stack Eq_2 dwArg5C)
// Called from:
//      _nl_find_msg
//      _nl_find_domain
Eq_2 _nl_load_domain(Eq_2 ebp, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg24, Eq_2 dwArg28, Eq_2 dwArg3C, Eq_2 dwArg40, Eq_2 dwArg44, Eq_2 dwArg48, Eq_2 dwArg58, Eq_2 dwArg5C)
{
	Eq_2 ebx_1289 = 0x080CE000;
	Eq_2 edx_19 = gs->t0008;
	Eq_2 edi_1125 = dwArg04;
	Eq_2175 eax_24 = gs->t0014;
	if (g_t80CF5CC != edx_19)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_36;
		if (!__cmpxchg(g_t80CF5C4, 0x01, 0x00, out eax_36))
			__lll_lock_wait_private(eax_36, 0x080CF5C4, gs);
		g_t80CF5CC = edx_19;
	}
	word32 ecx_1565;
	struct Eq_5215 * esi_1573;
	struct Eq_5216 * esp_1248;
	Eq_2 ebp_1273;
	Eq_2 eax_1585;
	Eq_2 eax_1154;
	struct Eq_5220 * esp_1153;
	ptr32 esp_1296;
	struct Eq_5216 * esp_1194;
	word32 eax_1456 = g_dw80CF5C8;
	Eq_2 ecx_100 = *((word32) dwArg04 + 4);
	g_dw80CF5C8 = eax_1456 + 0x01;
	Eq_2 edx_1449 = eax_1456 + 0x01;
	if (ecx_100 != 0x00)
	{
l0804C6B7:
		*((word32) ebx_1289 + 5576) = eax_1456;
		esp_1248 = fp - 0x00EC;
		if (eax_1456 == 0x00)
		{
			*((word32) ebx_1289 + 5580) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v39_1497 = *((word32) ebx_1289 + 5572) - 0x01;
			*((word32) ebx_1289 + 5572) = v39_1497;
			if (v39_1497 != 0x00)
				__lll_unlock_wake_private((word32) ebx_1289 + 5572, ecx_100, edx_1449, gs);
		}
		Eq_2 eax_1525 = eax_24 ^ gs->t0014;
		if (eax_1525 == 0x00)
			return eax_1525;
		word32 edx_4004;
		__stack_chk_fail(out ecx_1565, out edx_4004);
l0804D3F2:
		word32 edi_1570 = esp_1248->dw0008;
		esi_1573 = (word32) __bswap(*esp_1248->ptr000C) + edi_1570;
		esp_1248->t0030 = (word32) __bswap(esi_1573->t0000) + edi_1570;
		esp_1248->t0034 = esp_1248->t004C;
l0804D16F:
		eax_1585 = __bswap(esi_1573->t0004);
		if (esi_1573->dw0008 != ~0x00)
			goto l0804D1D5;
l0804D17A:
		Eq_2 esi_1589 = esp_1248->t0034;
		*esi_1589 = eax_1585;
		*((word32) esi_1589 + 4) = esp_1248->t0030;
l0804D189:
		if (esp_1248->dw0038 != 0x01)
		{
			struct Eq_5790 * eax_1849 = esp_1248->ptr0044;
			esp_1248->dw0038 = 0x01;
			ecx_1565 = eax_1849->dw000C;
			if (ecx_1565 == 0x00)
				goto l0804D1A7;
			goto l0804D144;
		}
		esp_1248->t0034 = ebp;
		ebp_1273 = esp_1248->t0020;
		++esp_1248->dw003C;
l0804D290:
		Eq_2 v31_1607 = (word32) dwArg0C + 4;
		esp_1248 = fp;
		dwArg0C = v31_1607;
		if (dwArg58 == v31_1607)
		{
			if (dwArg28 != dwArg3C)
			{
				_nl_load_domain.cold.0();
				return v31_1607;
			}
			Eq_2 esi_1719 = *((word32) dwArg44 + 44);
			if (esi_1719 != 0x00)
			{
				Eq_2 eax_1723 = *((word32) dwArg44 + 52);
				Eq_2 eax_1727 = *((word32) dwArg44 + 48);
				Eq_2 eax_1730 = 0x00;
				do
				{
					Eq_2 edx_1738 = *((word32) eax_1727 + eax_1730 * 0x04);
					Eq_2 ecx_1740 = __bswap(edx_1738);
					if (eax_1723 != 0x00)
						edx_1738 = ecx_1740;
					*((word32) dwArg40 + eax_1730 * 0x04) = edx_1738;
					eax_1730 = (word32) eax_1730 + 1;
				} while (eax_1730 != esi_1719);
			}
			ui32 dwArg18_3138 = 0x00;
			do
			{
				word32 eax_1777 = __hash_string(*((word32) dwArg24 + (dwArg18_4056 * 0x08 + 4)));
				Eq_2 edi_1788 = *((word32) dwArg44 + 44);
				uint32 edx_1801 = (uint32) ((uint64) eax_1777 % (edi_1788 - 0x02));
				Eq_2 eax_1805 = edi_1788 - (edx_1801 + 0x01);
				esp_1194 = fp;
				Eq_2 ecx_1795 = (uint32) ((uint64) eax_1777 % edi_1788);
				dwArg0C = eax_1805;
				uint32 eax_1808 = edx_1801 + 0x01 - edi_1788;
				while (true)
				{
					word32 * eax_1813 = (word32) dwArg40 + ecx_1795 * 0x04;
					if (*eax_1813 == 0x00)
						break;
					Eq_2 eax_1820 = (word32) ecx_1795 + eax_1808;
					Eq_2 edx_1822 = (word32) ecx_1795 + (edx_1801 + 0x01);
					if (eax_1805 > ecx_1795)
						eax_1820 = edx_1822;
					ecx_1795 = eax_1820;
				}
				*eax_1813 = (word32) *((word32) dwArg44 + 20) + (dwArg18_4056 + 0x01);
				dwArg18_3138 = dwArg18_4056 + 0x01;
				dwArg18_4056 = dwArg18_3138;
			} while (dwArg28 != dwArg18_4056 + 0x01);
			*((word32) dwArg44 + 32) = dwArg28;
			((word32) dwArg44 + 52)->u0 = 0x00;
			*((word32) dwArg44 + 36) = dwArg24;
			*((word32) dwArg44 + 40) = dwArg48;
			*((word32) dwArg44 + 48) = dwArg40;
			ebp = dwArg44;
			edi_1125 = dwArg5C;
l0804CC31:
			struct Eq_6708 * esp_1280 = esp_1194 - 0x0C;
			esp_1280->dwFFFFFFFC = esp_1280->dw0028;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 edx_4037;
			word32 ecx_4036;
			free(gs, stackArg0, stackArg4, out ecx_4036, out edx_4037);
			esp_1296 = &esp_1280->dwFFFFFFFC + 4;
l0804C640:
			((word32) ebp + 56)->u0 = 0x00;
			((word32) ebp + 60)->u0 = 0x00;
			struct Eq_5576 * esp_1336 = esp_1296 - 0x0C;
			esp_1336->tFFFFFFFC = &esp_1336->dw0010 + 23;
			esp_1336->dwFFFFFFF8 = 0x00;
			esp_1336->ptrFFFFFFF4 = (word32) ebx_1289 - 105991;
			esp_1336->dwFFFFFFF0 = esp_1336->dw0010;
			esp_1336->tFFFFFFEC = edi_1125;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg16 = <invalid>;
			Eq_2 stackArg20 = <invalid>;
			Eq_2 eax_1358 = _nl_find_msg(edi_1125, gs, stackArg4, dwArg04, dwArg08, stackArg16, stackArg20);
			esp_1153 = (struct Eq_5220 *) (&esp_1336->ptr0004 + 2);
			if (eax_1358 != ~0x00)
			{
				esp_1336->ptr0004 = (word32) ebp + 100;
				esp_1336->ptr0000 = (word32) ebp + 96;
				esp_1336->tFFFFFFFC = eax_1358;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				__gettext_extract_plural(gs, stackArg4, dwArg04, dwArg08, out ecx_100, out edx_1449);
				eax_1456 = *((word32) ebx_1289 + 5576) - 0x01;
				goto l0804C6B0;
			}
			eax_1154 = *((word32) ebp + 16);
l0804C751:
			struct Eq_6442 * esp_1383 = esp_1153 - 0x0C;
			esp_1383->tFFFFFFFC = eax_1154;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 edx_4025;
			word32 ecx_4024;
			free(gs, stackArg0, stackArg4, out ecx_4024, out edx_4025);
			if (esp_1383->dw001C == 0x00)
			{
				esp_1383->tFFFFFFFC = esp_1383->t0014;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_4030;
				word32 edx_4031;
				free(gs, stackArg0, stackArg4, out ecx_4030, out edx_4031);
			}
			else
			{
				esp_1383->t0000 = esp_1383->t0020;
				esp_1383->tFFFFFFFC = esp_1383->t0014;
				word32 ecx_4026;
				word32 edx_4027;
				__munmap(ebx_1289, gs, esp_1383->tFFFFFFFC, esp_1383->t0000, out ecx_4026, out edx_4027, out ebx_1289);
			}
			esp_1153->tFFFFFFF0 = ebp;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			free(gs, stackArg0, stackArg4, out ecx_100, out edx_1449);
			word32 eax_1453 = *((word32) ebx_1289 + 5576);
			((word32) edi_1125 + 8)->u0 = 0x00;
			eax_1456 = eax_1453 - 0x01;
			goto l0804C6B0;
		}
l0804D0D9:
		word32 esi_1617 = 0x00;
		word32 edi_1620 = esp_1248->ptr0044->dw000C;
		while (true)
		{
			union Eq_2 * eax_1626 = esp_1248->ptr0018;
			if (esi_1617 == 0x00)
				eax_1626 = esp_1248->ptr000C;
			struct Eq_6632 * edx_1638;
			int8 al_1641;
			Eq_2 edx_1631 = *eax_1626;
			if (edi_1620 != 0x00)
			{
				edx_1638 = (word32) __bswap(edx_1631) + esp_1248->dw0008;
				al_1641 = (int8) (edx_1638->dw0008 != ~0x00);
			}
			else
			{
				edx_1638 = (word32) edx_1631 + esp_1248->dw0008;
				al_1641 = (int8) (edx_1638->dw0008 != ~0x00);
			}
			if (al_1641 != 0x00)
			{
				struct Eq_6749 * edx_1652 = (char *) edx_1638 + 4 + 4;
				while (true)
				{
					Eq_2 eax_1656 = edx_1652->dw0000;
					Eq_2 ecx_1661 = __bswap(eax_1656);
					if (edi_1620 != 0x00)
						eax_1656 = ecx_1661;
					if (eax_1656 == ~0x00)
						break;
					if (*((word32) ebp_1273 + eax_1656 * 0x04) == 0x00)
						goto l0804D290;
					++edx_1652;
				}
			}
			if (esi_1617 == 0x01)
				break;
			esi_1617 = 0x01;
		}
		ui32 eax_1691 = esp_1248->dw003C;
		word32 esi_1692 = esp_1248->dw0024;
		esp_1248->t0020 = ebp_1273;
		esp_1248->dw0038 = 0x00;
		ebp = esp_1248->t0034;
		Eq_2 eax_1708 = (eax_1691 << 0x03) + esp_1248->dw0048;
		esp_1248->t004C = esi_1692 + (eax_1691 << 0x03);
		esp_1248->t0050 = eax_1708;
		ecx_1565 = edi_1620;
		if (edi_1620 == 0x00)
		{
l0804D1A7:
			if (esp_1248->dw0038 != 0x00)
			{
				word32 eax_1885 = esp_1248->dw0008;
				esi_1573 = (struct Eq_5215 *) ((char *) *esp_1248->ptr0018 + eax_1885);
				esp_1248->t0030 = (word32) esi_1573->t0000 + eax_1885;
				esp_1248->t0034 = esp_1248->t0050;
			}
			else
			{
				word32 eax_1876 = esp_1248->dw0008;
				esi_1573 = (struct Eq_5215 *) ((char *) *esp_1248->ptr000C + eax_1876);
				esp_1248->t0030 = (word32) esi_1573->t0000 + eax_1876;
				esp_1248->t0034 = esp_1248->t004C;
			}
			eax_1585 = esi_1573->t0004;
			if (esi_1573->dw0008 != ~0x00)
			{
l0804D1D5:
				Eq_2 eax_1902 = esp_1248->t0034;
				esp_1248->dw0054 = ecx_1565;
				*((word32) eax_1902 + 4) = ebp;
				struct Eq_5760 * esi_1904 = &esi_1573->t0004;
				while (true)
				{
					Eq_2 ecx_1924 = esi_1904->dw0000;
					Eq_2 edi_1925 = esi_1904->dw0004;
					if (esp_1248->dw0054 != 0x00)
					{
						ecx_1924 = __bswap(ecx_1924);
						edi_1925 = __bswap(edi_1925);
					}
					if (ecx_1924 != 0x00)
					{
						struct Eq_6040 * esp_1936 = esp_1248 - 0x04;
						esp_1936->tFFFFFFFC = ecx_1924;
						esp_1936->t0030 = ecx_1924;
						esp_1936->tFFFFFFF8 = esp_1936->t0034;
						esp_1936->tFFFFFFF4 = ebp;
						word32 edx_4017;
						word32 ecx_4016;
						memcpy(esp_1936->tFFFFFFF4, esp_1936->tFFFFFFF8, esp_1936->tFFFFFFFC, out ecx_4016, out edx_4017);
						Eq_2 ecx_1956 = esp_1936->t0030;
						Mem1958[esp_1936 + 0x34:word32] = Mem1947[esp_1936 + 0x34:word32] + ecx_1956;
						ebp += ecx_1956;
					}
					if (edi_1925 == ~0x00)
						break;
					struct Eq_6096 * esp_1976 = esp_1248 - 0x0C;
					Eq_2 ecx_1981 = *((word32) esp_1248->t0020 + edi_1925 * 0x04);
					esp_1976->tFFFFFFFC = ecx_1981;
					esp_1976->t0038 = ecx_1981;
					word32 ecx_4018;
					word32 edx_4019;
					Eq_2 eax_1985 = strlen(esp_1976->tFFFFFFFC, out ecx_4018, out edx_4019);
					esp_1976->t0004 = eax_1985;
					esp_1976->t0000 = esp_1976->t0038;
					esp_1976->tFFFFFFFC = ebp;
					word32 ecx_4020;
					word32 edx_4021;
					memcpy(esp_1976->tFFFFFFFC, esp_1976->t0000, esp_1976->t0004, out ecx_4020, out edx_4021);
					++esi_1904;
					ebp += eax_1985;
				}
				Eq_2 esi_1969 = esp_1248->t0034;
				*esi_1969 = ebp - *((word32) esi_1969 + 4);
				goto l0804D189;
			}
			goto l0804D17A;
		}
l0804D144:
		if (esp_1248->dw0038 != 0x00)
		{
			word32 edi_1860 = esp_1248->dw0008;
			esi_1573 = (word32) __bswap(*esp_1248->ptr0018) + edi_1860;
			esp_1248->t0030 = (word32) __bswap(esi_1573->t0000) + edi_1860;
			esp_1248->t0034 = esp_1248->t0050;
			goto l0804D16F;
		}
		goto l0804D3F2;
	}
	edx_1449 = *dwArg04;
	((word32) dwArg04 + 4)->u0 = ~0x00;
	((word32) dwArg04 + 8)->u0 = 0x00;
	if (edx_1449 == 0x00)
	{
l0804C6B0:
		((word32) edi_1125 + 4)->u0 = 0x01;
		goto l0804C6B7;
	}
	Eq_2 eax_79 = __open_nocancel(gs, edx_1449, 0x00, dwLocF4, out ecx_100, out edx_1449);
	if (eax_79 == ~0x00)
	{
l0804C7A0:
		edi_1125 = dwArg04;
		eax_1456 = g_dw80CF5C8 - 0x01;
		goto l0804C6B0;
	}
	else
	{
		word32 edx_3994;
		Eq_2 eax_99 = __fxstat64(gs, eax_79, fp - 0x88, out ecx_100, out edx_3994);
		Eq_2 dwLocDC_2127 = eax_99;
		if (eax_99 == 0x00 && (dwLoc58 == 0x00 && dwLoc5C > 0x2F))
		{
			word32 dwLocE0_2164;
			word32 esi_249;
			word32 edx_3996;
			word32 ecx_3995;
			Eq_2 eax_133 = mmap(gs, 0x00, dwLoc5C, 0x01, 0x02, eax_79, 0x00, out ecx_3995, out edx_3996);
			Eq_2 dwLocE4_2143 = eax_133;
			ebp = eax_133;
			if (eax_133 != ~0x00)
			{
				word32 edx_4003;
				word24 eax_24_8_285 = SLICE(__close_nocancel(gs, eax_79, out edx_4003), word24, 8);
				word32 ecx_279 = *eax_133;
				int8 al_284 = (int8) (ecx_279 != 2500072158);
				dwLocE0_2164 = ecx_279;
				esi_249 = SEQ(eax_24_8_285, al_284);
				if (ecx_279 != 3725722773 && al_284 != 0x00)
				{
					__munmap(0x080CE000, gs, eax_133, dwLoc5C, out ecx_100, out edx_1449, out ebx_1289);
					eax_1456 = *((word32) ebx_1289 + 5576) - 0x01;
					goto l0804C6B0;
				}
				dwLocDC_2127.u0 = 0x01;
l0804C57A:
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ebx_4051;
				word32 ebp_4052;
				word32 esi_4053;
				word32 edi_4054;
				Eq_2 eax_333 = __libc_malloc(gs, stackArg0, 0x68, out ecx_100, out edx_1449, out ebx_4051, out ebp_4052, out esi_4053, out edi_4054);
				edi_1125 = dwArg04;
				esp_1296 = fp - 0xEC;
				ebp = eax_333;
				if (eax_333 != 0x00)
				{
					Eq_2 dwLocC4_2197;
					Eq_2 edx_378;
					*((word32) dwArg04 + 8) = eax_333;
					*eax_333 = dwLocE4_2143;
					((word32) eax_333 + 16)->u0 = 0x00;
					*((word32) eax_333 + 4) = dwLocDC_2127;
					*((word32) eax_333 + 8) = dwLoc5C;
					Eq_2 eax_358 = *((word32) dwLocE4_2143 + 4);
					Eq_2 esi_357 = (word32) (byte) esi_249;
					*((word32) eax_333 + 0x0C) = esi_357;
					word16 ax_404 = (word16) eax_358;
					if (dwLocE0_2164 != 2500072158)
					{
						Eq_2 eax_379 = __bswap(eax_358);
						ax_404 = (word16) eax_379;
						if (eax_379 > 0x0001FFFF)
							goto l0804C74F;
						*((word32) eax_333 + 20) = __bswap(*((word32) dwLocE4_2143 + 8));
						Mem389[eax_333 + 0x18:word32] = __bswap(*((word32) dwLocE4_2143 + 0x0C)) + dwLocE4_2143;
						Mem393[eax_333 + 0x1C:word32] = __bswap(*((word32) dwLocE4_2143 + 16)) + dwLocE4_2143;
						Eq_2 edx_395 = __bswap(*((word32) dwLocE4_2143 + 20));
						*((word32) eax_333 + 44) = edx_395;
						dwLocC4_2197 = edx_395;
						if (edx_395 > 0x02)
						{
							edx_378 = __bswap(*((word32) dwLocE4_2143 + 24));
							goto l0804C7E4;
						}
					}
					else
					{
						if (eax_358 > 0x0001FFFF)
							goto l0804C74F;
						*((word32) eax_333 + 20) = *((word32) dwLocE4_2143 + 8);
						Mem368[eax_333 + 0x18:word32] = Mem365[dwLocE4_2143 + 0x0C:word32] + dwLocE4_2143;
						Eq_2 ecx_371 = *((word32) dwLocE4_2143 + 20);
						Mem372[eax_333 + 0x1C:word32] = Mem368[dwLocE4_2143 + 0x10:word32] + dwLocE4_2143;
						*((word32) eax_333 + 44) = ecx_371;
						dwLocC4_2197 = ecx_371;
						if (ecx_371 > 0x02)
						{
							edx_378 = *((word32) dwLocE4_2143 + 24);
l0804C7E4:
							*((word32) eax_333 + 52) = esi_357;
							word32 edx_420 = edx_378 + dwLocE4_2143;
							*((word32) eax_333 + 48) = edx_420;
							if (ax_404 != 0x00)
							{
								if (edx_420 == 0x00)
								{
l0804C74F:
									edi_1125 = dwArg04;
									ebp = eax_333;
									esp_1153 = fp - 0xEC;
									eax_1154.u0 = 0x00;
									goto l0804C751;
								}
								Eq_2 dwLocD4_2202;
								Eq_2 eax_439;
								Eq_2 eax_429 = *((word32) dwLocE4_2143 + 36);
								Eq_2 dwLocC8_2201 = eax_429;
								if (dwLocE0_2164 != 2500072158)
								{
									Eq_2 eax_441 = __bswap(eax_429);
									dwLocC8_2201 = eax_441;
									if (eax_441 != 0x00)
									{
										dwLocD4_2202 = __bswap(*((word32) dwLocE4_2143 + 28));
										eax_439 = __bswap(*((word32) dwLocE4_2143 + 32));
										goto l0804C836;
									}
								}
								else if (eax_429 != 0x00)
								{
									eax_439 = *((word32) dwLocE4_2143 + 32);
									dwLocD4_2202 = *((word32) dwLocE4_2143 + 28);
l0804C836:
									Eq_150850 eax_459[] = eax_439 + dwLocE4_2143;
									word32 ebp_4041;
									word32 esi_4042;
									word32 edi_4043;
									word32 edx_4039;
									word32 ebx_4040;
									word32 ecx_4038;
									Eq_2 eax_479 = __libc_calloc(gs, dwLocD4_2202, 0x04, out ecx_4038, out edx_4039, out ebx_4040, out ebp_4041, out esi_4042, out edi_4043);
									if (eax_479 != 0x00)
									{
										Eq_2 esi_489 = 0x00;
										if (dwLocD4_2202 != 0x00)
										{
											do
											{
												Eq_2 edi_502 = eax_459[esi_489].t0004;
												Eq_2 edx_503 = eax_459[esi_489].t0000;
												word32 eax_505 = dwLocE4_2143 + edi_502;
												if (dwLocE0_2164 != 2500072158)
												{
													eax_505 = dwLocE4_2143 + __bswap(edi_502);
													edx_503 = __bswap(edx_503);
												}
												if (edx_503 == 0x00 || *((word32) edx_503 + (eax_505 - 0x01)) != 0x00)
												{
l0804CAD8:
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													Eq_2 stackArg0 = <invalid>;
													word32 edx_4048;
													word32 ecx_4047;
													free(gs, stackArg0, eax_479, out ecx_4047, out edx_4048);
													edi_1125 = dwArg04;
													ebp = eax_333;
													esp_1153 = fp - 0xEC;
													eax_1154.u0 = 0x00;
													goto l0804C751;
												}
												Eq_2 edx_529;
												byte dl_524 = eax_505->b0000;
												if (dl_524 == 0x50)
												{
													edx_529.u0 = 0x00;
													if (eax_505->b0001 == 0x52 && eax_505->b0002 == 0x49)
													{
														Eq_2 edi_541 = (word32) eax_505->b0003;
														byte cl_543 = (byte) edi_541;
														byte cl_555 = (byte) edi_541;
														byte cl_552 = (byte) (cl_543 == 100) | (int8) (cl_543 == 0x69);
														byte cl_565 = (byte) (cl_555 == 117) | (int8) (cl_555 == 111) | cl_552;
														if (((byte) edi_541 & 223) == 88 || cl_565 != 0x00)
														{
															byte dl_577 = eax_505->b0004;
															if (dl_577 != 0x38)
															{
																if (dl_577 != 0x31)
																{
																	if (dl_577 == 0x33)
																	{
																		edx_529.u0 = 0x00;
																		if (eax_505->b0005 == 0x32 && eax_505->b0006 == 0x00)
																		{
																			byte al_972 = (byte) edi_541;
																			if (al_972 != 100)
																			{
																				if (cl_552 == 0x00)
																				{
																					if (al_972 != 111)
																					{
																						if (cl_565 == 0x00)
																						{
																							if (al_972 != 0x78)
																							{
																								if (al_972 != 88)
																								{
																									_nl_load_domain.cold.0();
																									return edi_541;
																								}
																								edx_529.u0 = 0x080B3BC4;
																							}
																							else
																								edx_529.u0 = 134888485;
																						}
																						else
																							edx_529.u0 = 0x080B40F6;
																					}
																					else
																						edx_529.u0 = 0x080A4130;
																				}
																				else
																					edx_529.u0 = 0x080A4E47;
																			}
																			else
																				edx_529.u0 = 0x080A4B4A;
																		}
																	}
																	else if (dl_577 == 0x36)
																	{
																		edx_529.u0 = 0x00;
																		if (eax_505->b0005 == 0x34 && eax_505->b0006 == 0x00)
																		{
																			byte al_947 = (byte) edi_541;
																			if (al_947 != 100)
																			{
																				if (cl_552 == 0x00)
																				{
																					if (al_947 != 111)
																					{
																						if (cl_565 == 0x00)
																						{
																							if (al_947 != 0x78)
																							{
																								if (al_947 != 88)
																								{
																									_nl_load_domain.cold.0();
																									return edi_541;
																								}
																								edx_529.u0 = 0x080A22ED;
																							}
																							else
																								edx_529.u0 = 134882033;
																						}
																						else
																							edx_529.u0 = 0x080A22E1;
																					}
																					else
																						edx_529.u0 = 0x080A22E5;
																				}
																				else
																					edx_529.u0 = 0x080A22DD;
																			}
																			else
																				edx_529.u0 = 0x080A22E9;
																		}
																	}
																	else if (dl_577 == 0x4C)
																	{
																		edx_529.u0 = 0x00;
																		if (eax_505->b0005 == 0x45 && (eax_505->b0006 == 0x41 && (eax_505->b0007 == 0x53 && eax_505->b0008 == 0x54)))
																		{
																			byte cl_834 = eax_505->b0009;
																			if (cl_834 != 0x38)
																			{
																				edx_529.u0 = 0x00;
																				if (cl_834 != 0x31)
																				{
																					if (cl_834 == 0x33)
																					{
																						if (eax_505->b000A == 0x32 && eax_505->b000B == 0x00)
																						{
																							byte al_922 = (byte) edi_541;
																							if (al_922 != 100)
																							{
																								if (cl_552 == 0x00)
																								{
																									if (al_922 != 111)
																									{
																										if (cl_565 == 0x00)
																										{
																											if (al_922 != 0x78)
																											{
																												if (al_922 != 88)
																												{
																													_nl_load_domain.cold.0();
																													return edi_541;
																												}
																												edx_529.u0 = 0x080B3BC4;
																											}
																											else
																												edx_529.u0 = 134888485;
																										}
																										else
																											edx_529.u0 = 0x080B40F6;
																									}
																									else
																										edx_529.u0 = 0x080A4130;
																								}
																								else
																									edx_529.u0 = 0x080A4E47;
																							}
																							else
																								edx_529.u0 = 0x080A4B4A;
																						}
																					}
																					else if (cl_834 == 0x36 && (eax_505->b000A == 0x34 && eax_505->b000B == 0x00))
																					{
																						byte al_898 = (byte) edi_541;
																						if (al_898 != 100)
																						{
																							if (cl_552 == 0x00)
																							{
																								if (al_898 != 111)
																								{
																									if (cl_565 == 0x00)
																									{
																										if (al_898 != 0x78)
																										{
																											if (al_898 != 88)
																											{
																												_nl_load_domain.cold.0();
																												return edi_541;
																											}
																											edx_529.u0 = 0x080A22ED;
																										}
																										else
																											edx_529.u0 = 134882033;
																									}
																									else
																										edx_529.u0 = 0x080A22E1;
																								}
																								else
																									edx_529.u0 = 0x080A22E5;
																							}
																							else
																								edx_529.u0 = 0x080A22DD;
																						}
																						else
																							edx_529.u0 = 0x080A22E9;
																					}
																				}
																				else if (eax_505->b000A == 0x36 && eax_505->b000B == 0x00)
																				{
																					byte al_870 = (byte) edi_541;
																					if (al_870 != 100)
																					{
																						if (cl_552 == 0x00)
																						{
																							if (al_870 != 111)
																							{
																								if (cl_565 == 0x00)
																								{
																									if (al_870 != 0x78)
																									{
																										if (al_870 != 88)
																										{
																											_nl_load_domain.cold.0();
																											return edi_541;
																										}
																										edx_529.u0 = 0x080B3BC4;
																									}
																									else
																										edx_529.u0 = 134888485;
																								}
																								else
																									edx_529.u0 = 0x080B40F6;
																							}
																							else
																								edx_529.u0 = 0x080A4130;
																						}
																						else
																							edx_529.u0 = 0x080A4E47;
																					}
																					else
																						edx_529.u0 = 0x080A4B4A;
																				}
																			}
																			else if (eax_505->b000A == 0x00)
																			{
																				byte al_843 = (byte) edi_541;
																				if (al_843 != 100)
																				{
																					if (cl_552 == 0x00)
																					{
																						if (al_843 != 111)
																						{
																							if (cl_565 == 0x00)
																							{
																								if (al_843 != 0x78)
																								{
																									if (al_843 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_541;
																									}
																									edx_529.u0 = 0x080B3BC4;
																								}
																								else
																									edx_529.u0 = 134888485;
																							}
																							else
																								edx_529.u0 = 0x080B40F6;
																						}
																						else
																							edx_529.u0 = 0x080A4130;
																					}
																					else
																						edx_529.u0 = 0x080A4E47;
																				}
																				else
																					edx_529.u0 = 0x080A4B4A;
																			}
																			else
																				edx_529.u0 = 0x00;
																		}
																	}
																	else if (dl_577 == 0x46)
																	{
																		edx_529.u0 = 0x00;
																		if (eax_505->b0005 == 0x41 && (eax_505->b0006 == 0x53 && eax_505->b0007 == 0x54))
																		{
																			byte cl_717 = eax_505->b0008;
																			if (cl_717 != 0x38)
																			{
																				edx_529.u0 = 0x00;
																				if (cl_717 != 0x31)
																				{
																					if (cl_717 == 0x33)
																					{
																						if (eax_505->b0009 == 0x32 && eax_505->b000A == 0x00)
																						{
																							byte al_805 = (byte) edi_541;
																							if (al_805 != 100)
																							{
																								if (cl_552 == 0x00)
																								{
																									if (al_805 != 111)
																									{
																										if (cl_565 == 0x00)
																										{
																											if (al_805 != 0x78)
																											{
																												if (al_805 != 88)
																												{
																													_nl_load_domain.cold.0();
																													return edi_541;
																												}
																												edx_529.u0 = 0x080B3BC4;
																											}
																											else
																												edx_529.u0 = 134888485;
																										}
																										else
																											edx_529.u0 = 0x080B40F6;
																									}
																									else
																										edx_529.u0 = 0x080A4130;
																								}
																								else
																									edx_529.u0 = 0x080A4E47;
																							}
																							else
																								edx_529.u0 = 0x080A4B4A;
																						}
																					}
																					else if (cl_717 == 0x36 && (eax_505->b0009 == 0x34 && eax_505->b000A == 0x00))
																					{
																						byte al_781 = (byte) edi_541;
																						if (al_781 != 100)
																						{
																							if (cl_552 == 0x00)
																							{
																								if (al_781 != 111)
																								{
																									if (cl_565 == 0x00)
																									{
																										if (al_781 != 0x78)
																										{
																											if (al_781 != 88)
																											{
																												_nl_load_domain.cold.0();
																												return edi_541;
																											}
																											edx_529.u0 = 0x080A22ED;
																										}
																										else
																											edx_529.u0 = 134882033;
																									}
																									else
																										edx_529.u0 = 0x080A22E1;
																								}
																								else
																									edx_529.u0 = 0x080A22E5;
																							}
																							else
																								edx_529.u0 = 0x080A22DD;
																						}
																						else
																							edx_529.u0 = 0x080A22E9;
																					}
																				}
																				else if (eax_505->b0009 == 0x36 && eax_505->b000A == 0x00)
																				{
																					byte al_753 = (byte) edi_541;
																					if (al_753 != 100)
																					{
																						if (cl_552 == 0x00)
																						{
																							if (al_753 != 111)
																							{
																								if (cl_565 == 0x00)
																								{
																									if (al_753 != 0x78)
																									{
																										if (al_753 != 88)
																										{
																											_nl_load_domain.cold.0();
																											return edi_541;
																										}
																										edx_529.u0 = 0x080B3BC4;
																									}
																									else
																										edx_529.u0 = 134888485;
																								}
																								else
																									edx_529.u0 = 0x080B40F6;
																							}
																							else
																								edx_529.u0 = 0x080A4130;
																						}
																						else
																							edx_529.u0 = 0x080A4E47;
																					}
																					else
																						edx_529.u0 = 0x080A4B4A;
																				}
																			}
																			else if (eax_505->b0009 == 0x00)
																			{
																				byte al_726 = (byte) edi_541;
																				if (al_726 != 100)
																				{
																					if (cl_552 == 0x00)
																					{
																						if (al_726 != 111)
																						{
																							if (cl_565 == 0x00)
																							{
																								if (al_726 != 0x78)
																								{
																									if (al_726 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_541;
																									}
																									edx_529.u0 = 0x080B3BC4;
																								}
																								else
																									edx_529.u0 = 134888485;
																							}
																							else
																								edx_529.u0 = 0x080B40F6;
																						}
																						else
																							edx_529.u0 = 0x080A4130;
																					}
																					else
																						edx_529.u0 = 0x080A4E47;
																				}
																				else
																					edx_529.u0 = 0x080A4B4A;
																			}
																			else
																				edx_529.u0 = 0x00;
																		}
																	}
																	else if (dl_577 == 77)
																	{
																		edx_529.u0 = 0x00;
																		if (eax_505->b0005 == 0x41 && eax_505->b0006 == 88)
																		{
																			if (eax_505->b0007 == 0x00)
																			{
																				byte al_690 = (byte) edi_541;
																				if (al_690 != 100)
																				{
																					if (cl_552 == 0x00)
																					{
																						if (al_690 != 111)
																						{
																							if (cl_565 == 0x00)
																							{
																								if (al_690 != 0x78)
																								{
																									if (al_690 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_541;
																									}
																									edx_529.u0 = 0x080A22ED;
																								}
																								else
																									edx_529.u0 = 134882033;
																							}
																							else
																								edx_529.u0 = 0x080A22E1;
																						}
																						else
																							edx_529.u0 = 0x080A22E5;
																					}
																					else
																						edx_529.u0 = 0x080A22DD;
																				}
																				else
																					edx_529.u0 = 0x080A22E9;
																			}
																			else
																				edx_529.u0 = 0x00;
																		}
																	}
																	else
																	{
																		edx_529.u0 = 0x00;
																		if (dl_577 == 0x50 && (eax_505->b0005 == 0x54 && eax_505->b0006 == 0x52))
																		{
																			if (eax_505->b0007 == 0x00)
																			{
																				byte al_660 = (byte) edi_541;
																				if (al_660 != 100)
																				{
																					if (cl_552 == 0x00)
																					{
																						if (al_660 != 111)
																						{
																							if (cl_565 == 0x00)
																							{
																								if (al_660 != 0x78)
																								{
																									if (al_660 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_541;
																									}
																									edx_529.u0 = 0x080B3BC4;
																								}
																								else
																									edx_529.u0 = 134888485;
																							}
																							else
																								edx_529.u0 = 0x080B40F6;
																						}
																						else
																							edx_529.u0 = 0x080A4130;
																					}
																					else
																						edx_529.u0 = 0x080A4E47;
																				}
																				else
																					edx_529.u0 = 0x080A4B4A;
																			}
																			else
																				edx_529.u0 = 0x00;
																		}
																	}
																}
																else
																{
																	edx_529.u0 = 0x00;
																	if (eax_505->b0005 == 0x36 && eax_505->b0006 == 0x00)
																	{
																		byte al_618 = (byte) edi_541;
																		if (al_618 != 100)
																		{
																			if (cl_552 == 0x00)
																			{
																				if (al_618 != 111)
																				{
																					if (cl_565 == 0x00)
																					{
																						if (al_618 != 0x78)
																						{
																							if (al_618 != 88)
																							{
																								_nl_load_domain.cold.0();
																								return edi_541;
																							}
																							edx_529.u0 = 0x080B3BC4;
																						}
																						else
																							edx_529.u0 = 134888485;
																					}
																					else
																						edx_529.u0 = 0x080B40F6;
																				}
																				else
																					edx_529.u0 = 0x080A4130;
																			}
																			else
																				edx_529.u0 = 0x080A4E47;
																		}
																		else
																			edx_529.u0 = 0x080A4B4A;
																	}
																}
															}
															else if (eax_505->b0005 == 0x00)
															{
																byte al_587 = (byte) edi_541;
																if (al_587 != 100)
																{
																	if (cl_552 == 0x00)
																	{
																		if (al_587 != 111)
																		{
																			if (cl_565 == 0x00)
																			{
																				if (al_587 != 0x78)
																				{
																					if (al_587 != 88)
																					{
																						_nl_load_domain.cold.0();
																						return edi_541;
																					}
																					edx_529.u0 = 0x080B3BC4;
																				}
																				else
																					edx_529.u0 = 134888485;
																			}
																			else
																				edx_529.u0 = 0x080B40F6;
																		}
																		else
																			edx_529.u0 = 0x080A4130;
																	}
																	else
																		edx_529.u0 = 0x080A4E47;
																}
																else
																	edx_529.u0 = 0x080A4B4A;
															}
															else
																edx_529.u0 = 0x00;
														}
													}
												}
												else if (dl_524 == 0x49)
												{
													edx_529.u0 = 0x00;
													if (eax_505->b0001 == 0x00)
														edx_529.u0 = 0x080A22F5;
												}
												else
													edx_529.u0 = 0x00;
												*((word32) eax_479 + esi_489 * 0x04) = edx_529;
												esi_489 = (word32) esi_489 + 1;
											} while (esi_489 != dwLocD4_2202);
										}
										Eq_2 dwLocBC_2265[];
										Eq_2 eax_1008 = *((word32) dwLocE4_2143 + 40);
										Eq_2 edx_1009 = *((word32) dwLocE4_2143 + 44);
										if (dwLocE0_2164 != 2500072158)
										{
											word32 eax_1015 = __bswap(eax_1008) + dwLocE4_2143;
											edx_1009 = __bswap(edx_1009);
											dwLocBC_2265 = eax_1015;
										}
										else
											dwLocBC_2265 = eax_1008 + dwLocE4_2143;
										Eq_2 edx_1023[] = edx_1009 + dwLocE4_2143;
										Eq_2 dwLocCC_2276 = 0x00;
										ui32 dwLocC4_2278 = 0x00;
										ui32 dwLocB8_2280 = dwLocC4_2197 << 0x02;
										do
										{
											ui32 ebp_1039 = 0x00;
											while (true)
											{
												struct Eq_5645 * edi_1059;
												int8 al_1062;
												if (dwLocE0_2164 != 2500072158)
												{
													Eq_2 edi_1068;
													if (ebp_1039 != 0x00)
														edi_1068 = edx_1023[dwLocCC_2276];
													else
														edi_1068 = dwLocBC_2265[dwLocCC_2276];
													edi_1059 = __bswap(edi_1068) + dwLocE4_2143;
													al_1062 = (int8) (edi_1059->dw0008 != ~0x00);
												}
												else
												{
													Eq_2 edi_1052;
													if (ebp_1039 != 0x00)
														edi_1052 = edx_1023[dwLocCC_2276];
													else
														edi_1052 = dwLocBC_2265[dwLocCC_2276];
													edi_1059 = edi_1052 + dwLocE4_2143;
													al_1062 = (int8) (edi_1059->dw0008 != ~0x00);
												}
												word32 esi_1080 = 0x00;
												if (al_1062 != 0x00)
												{
													struct Eq_5644 * edi_1091 = (char *) edi_1059 + 4;
													word32 eax_1092 = 0x00;
													while (true)
													{
														Eq_2 ecx_1098 = edi_1091->dw0000;
														Eq_2 edx_1101 = edi_1091->dw0004;
														esi_1080 = (word32) ecx_1098 + eax_1092;
														if (dwLocE0_2164 != 2500072158)
														{
															esi_1080 = (word32) __bswap(ecx_1098) + eax_1092;
															edx_1101 = __bswap(edx_1101);
														}
														if (edx_1101 == ~0x00)
															break;
														if (edx_1101 >= dwLocD4_2202)
															goto l0804CAD8;
														Eq_2 eax_1159 = *((word32) eax_479 + edx_1101 * 0x04);
														if (eax_1159 == 0x00)
															goto l0804CBF9;
														++edi_1091;
														word32 ecx_4044;
														word32 edx_4045;
														eax_1092 = (word32) strlen(eax_1159, out ecx_4044, out edx_4045) + esi_1080;
													}
												}
												(fp - 0x28)[ebp_1039] = esi_1080;
												if (ebp_1039 == 0x01)
													break;
												ebp_1039 = 0x01;
											}
											++dwLocC4_2278;
											dwLocB8_2280 += dwLoc24 + dwLoc28;
l0804CBF9:
											Eq_2 v21_1196 = (word32) dwLocCC_2276 + 1;
											esp_1194 = fp - 0xEC;
											dwLocCC_2276 = v21_1196;
										} while (v21_1196 != dwLocC8_2201);
										ebp = eax_333;
										edi_1125 = dwArg04;
										if (dwLocC4_2278 == 0x00)
										{
											((word32) eax_333 + 32)->u0 = 0x00;
											((word32) eax_333 + 36)->u0 = 0x00;
											((word32) eax_333 + 40)->u0 = 0x00;
											goto l0804CC31;
										}
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg0 = <invalid>;
										word32 ebx_4011;
										word32 ebp_4012;
										word32 esi_4013;
										word32 edi_4014;
										word32 edx_4010;
										word32 ecx_4009;
										Eq_2 eax_1243 = __libc_malloc(gs, stackArg0, (dwLocC4_2278 << 0x04) + dwLocB8_2280, out ecx_4009, out edx_4010, out ebx_4011, out ebp_4012, out esi_4013, out edi_4014);
										esp_1248 = fp - 0xEC;
										if (eax_1243 != 0x00)
										{
											*((word32) eax_333 + 16) = eax_1243;
											ebp_1273 = eax_479;
											goto l0804D0D9;
										}
									}
									goto l0804C74F;
								}
							}
l0804C62B:
							((word32) eax_333 + 32)->u0 = 0x00;
							((word32) eax_333 + 36)->u0 = 0x00;
							((word32) eax_333 + 40)->u0 = 0x00;
							goto l0804C640;
						}
					}
					((word32) eax_333 + 48)->u0 = 0x00;
					*((word32) eax_333 + 52) = esi_357;
					if (ax_404 != 0x00)
						goto l0804C74F;
					goto l0804C62B;
				}
				goto l0804C7A0;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_3998;
			word32 esi_4001;
			word32 edi_4002;
			word32 ebx_3999;
			word32 ebp_4000;
			Eq_2 eax_154 = __libc_malloc(gs, stackArg0, dwLoc5C, out ecx_100, out edx_3998, out ebx_3999, out ebp_4000, out esi_4001, out edi_4002);
			dwLocE4_2143 = eax_154;
			if (eax_154 != 0x00)
			{
				Eq_2 esi_167 = eax_154;
				ebp = dwLoc5C;
				do
				{
					Eq_2 eax_183 = __read_nocancel(gs, eax_79, esi_167, ebp, out ecx_100);
					if (eax_183 > 0x00)
					{
						esi_167 += eax_183;
						ebp -= eax_183;
						if (ebp != 0x00)
							continue;
						word32 edx_4049;
						__close_nocancel(gs, eax_79, out edx_4049);
						word32 ecx_241 = *eax_154;
						int8 al_246 = (int8) (ecx_241 != 2500072158);
						edi_1125 = dwArg04;
						dwLocE0_2164 = ecx_241;
						esi_249 = SEQ(SLICE(eax_154, word24, 8), al_246);
						if (ecx_241 == 3725722773 || al_246 == 0x00)
							goto l0804C57A;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						free(gs, stackArg0, eax_154, out ecx_100, out edx_1449);
						eax_1456 = g_dw80CF5C8 - 0x01;
						goto l0804C6B0;
					}
				} while (eax_183 == ~0x00 && gs->tFFFFFFE0 == 0x04);
			}
		}
		__close_nocancel(gs, eax_79, out edx_1449);
		edi_1125 = dwArg04;
		eax_1456 = g_dw80CF5C8 - 0x01;
		goto l0804C6B0;
	}
}

// 0804D970: void alias_compare(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_2) dwArg08)
void alias_compare(union Eq_2 * dwArg04, union Eq_2 * dwArg08)
{
	word32 ecx_37;
	__strcasecmp_l(*dwArg04, *dwArg08, 0x080CE0C0, out ecx_37);
}

// 0804D9A0: Register Eq_2 read_alias_file(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_expand_alias
Eq_2 read_alias_file(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs)
{
	struct Eq_7248 * esp_21 = fp - 0x01FC;
	Eq_2175 ebx_25 = gs->t0014;
	struct Eq_7248 * edi_30 = fp - 0x01FC - ((word32) edx + 41 & ~0x0FFF);
	ui32 ebx_31 = (word32) edx + 41 & ~0x0F;
	if (fp - 0x01FC != edi_30)
	{
		do
		{
			esp_21 -= 0x1000;
			esp_21->dw0FFC = esp_21->dw0FFC;
		} while (esp_21 != edi_30);
	}
	if ((ebx_31 & 0x0FFF) != 0x00)
	{
		esp_21 -= ebx_31 & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_21 - 0x04)[(ebx_31 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_21 - 0x04)[(ebx_31 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	Eq_2 dwLoc01D4_750;
	struct Eq_7294 * esp_59 = esp_21 - 0x04;
	esp_59->tFFFFFFFC = edx;
	esp_59->tFFFFFFF8 = eax;
	Eq_7303 esi_58 = &esp_21->b000C + 3;
	esp_59->tFFFFFFF4 = esi_58 & ~0x0F;
	word32 edx_1073;
	Eq_2 eax_82 = __mempcpy(esp_59->tFFFFFFF4, esp_59->tFFFFFFF8, esp_59->tFFFFFFFC, out edx_1073);
	*eax_82 = g_t80A2310;
	*((word32) eax_82 + 4) = g_t80A2314;
	*((word32) eax_82 + 8) = g_t80A2318;
	*((word32) eax_82 + 0x0C) = g_t80A231C;
	esp_59->tFFFFFFF8.u0 = 0x080A22F7;
	esp_59->tFFFFFFF4 = esi_58 & ~0x0F;
	Eq_2 eax_116 = __new_fopen();
	if (eax_116 != 0x00)
	{
		ui32 eax_126 = *eax_116;
		*eax_116 = SEQ(SLICE(eax_126, word16, 16), SLICE(eax_126, byte, 8) | 0x80, (byte) eax_126);
		dwLoc01D4_750.u0 = 0x00;
		if (((byte) eax_126 & 0x10) == 0x00)
		{
			do
			{
				struct Eq_7401 * esp_159 = esp_21 - 0x04;
				esp_159->tFFFFFFFC = eax_116;
				esp_159->dwFFFFFFF8 = 400;
				esp_159->tFFFFFFF4 = fp - 0x01B0;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 stackArg12 = <invalid>;
				word32 edx_1081;
				if (fgets_unlocked(gs, stackArg4, stackArg8, stackArg12, out edx_1081) == 0x00)
					break;
				Eq_2 esi_204;
				esp_159->dwFFFFFFF8 = 0x0A;
				esp_159->tFFFFFFF4 = fp - 0x01B0;
				ui32 ecx_195 = (word32) bLoc01B0;
				word32 edx_1077;
				word32 ecx_1076;
				Eq_2 eax_188 = strchr(esp_159->tFFFFFFF4, esp_159->t0008, out ecx_1076, out edx_1077);
				byte dl_215 = (byte) ecx_195;
				Eq_150869 eax_200[] = gs->ptrFFFFFFF8;
				if ((eax_200[ecx_195].b0001 & 0x20) != 0x00)
				{
					esi_204 = fp - 0x01B0;
					do
					{
						esi_204 = (word32) esi_204 + 1;
						ui32 ecx_209 = (word32) *esi_204;
						dl_215 = (byte) ecx_209;
					} while ((eax_200[ecx_209].b0001 & 0x20) != 0x00);
				}
				else
					esi_204 = fp - 0x01B0;
				if (dl_215 != 0x00 && dl_215 != 0x23)
				{
					Eq_2 edi_224 = (word32) esi_204 + 1;
					ui32 ecx_226 = (word32) *((word32) esi_204 + 1);
					while (true)
					{
						byte dl_267;
						cui16 cx_232 = eax_200[ecx_226].w0000;
						if ((byte) ecx_226 == 0x00)
							break;
						if ((cx_232 & 0x2000) != 0x00)
						{
							ui32 ecx_244 = (word32) *((word32) edi_224 + 1);
							*edi_224 = 0x00;
							edi_224 = (word32) edi_224 + 1;
							dl_267 = (byte) ecx_244;
							if ((eax_200[ecx_244].b0001 & 0x20) == 0x00)
								goto l0804DBDF;
							goto l0804DBD0;
						}
						edi_224 = (word32) edi_224 + 1;
						ecx_226 = (word32) *edi_224;
					}
					if ((cx_232 & 0x2000) == 0x00)
						goto l0804DB0C;
l0804DBD0:
					do
					{
						edi_224 = (word32) edi_224 + 1;
						ui32 ecx_261 = (word32) *edi_224;
						dl_267 = (byte) ecx_261;
					} while ((eax_200[ecx_261].b0001 & 0x20) != 0x00);
l0804DBDF:
					if (dl_267 == 0x00)
						goto l0804DB0C;
					byte dl_277 = *((word32) edi_224 + 1);
					byte * ecx_276 = (word32) edi_224 + 1;
					while (dl_277 != 0x00)
					{
						if ((eax_200[(word32) dl_277].b0001 & 0x20) != 0x00)
						{
							if (dl_277 == 0x0A)
								*ecx_276 = (byte) 0x0A00;
							else
								*ecx_276 = 0x00;
							break;
						}
						++ecx_276;
						dl_277 = *ecx_276;
					}
					uint32 ebx_310 = nmap;
					uint32 eax_311 = maxmap;
					if (ebx_310 >= eax_311)
					{
						ui32 eax_319;
						uint32 edx_318;
						if (eax_311 == 0x00)
						{
							eax_319 = 800;
							edx_318 = 100;
						}
						else
						{
							edx_318 = eax_311 * 0x02;
							eax_319 = eax_311 << 0x04;
						}
						esp_159->dwFFFFFFF8 = eax_319;
						esp_159->tFFFFFFF4 = map;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						Eq_2 stackArg8 = <invalid>;
						word32 edi_1102;
						word32 edx_1099;
						word32 esi_1101;
						word32 ebp_1100;
						Eq_2 eax_370 = __realloc(gs, stackArg0, stackArg4, stackArg8, out edx_1099, out ebp_1100, out esi_1101, out edi_1102);
						if (eax_370 == 0x00)
							break;
						map = eax_370;
						maxmap = edx_318;
					}
					Eq_2 ebx_459;
					struct Eq_7653 * esp_381 = esp_21 - 0x0C;
					esp_381->tFFFFFFFC = esi_204;
					word32 ecx_1092;
					word32 edx_1093;
					Eq_2 eax_386 = strlen(esp_381->tFFFFFFFC, out ecx_1092, out edx_1093);
					esp_381->tFFFFFFFC = edi_224;
					word32 ecx_1094;
					word32 edx_1095;
					Eq_2 eax_399 = strlen(esp_381->tFFFFFFFC, out ecx_1094, out edx_1095);
					up32 ebx_410 = string_space_act;
					word32 ebx_412 = ebx_410 + ((word32) eax_386 + 1);
					up32 ebx_414 = ebx_412 + ((word32) eax_399 + 1);
					up32 eax_416 = string_space_max;
					Eq_2 edx_418 = string_space;
					if (ebx_414 <= eax_416)
						ebx_459 = map;
					else
					{
						up32 ecx_422 = (word32) eax_386 + 1 + ((word32) eax_399 + 1);
						if (ecx_422 < 0x0400)
							ecx_422 = 0x0400;
						up32 eax_435 = eax_416 + ecx_422;
						esp_381->dw0000 = eax_435;
						esp_381->tFFFFFFFC = edx_418;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						Eq_2 stackArg8 = <invalid>;
						word32 edx_1106;
						word32 edi_1109;
						word32 ebp_1107;
						word32 esi_1108;
						Eq_2 eax_451 = __realloc(gs, stackArg0, stackArg4, stackArg8, out edx_1106, out ebp_1107, out esi_1108, out edi_1109);
						if (eax_451 == 0x00)
							break;
						ebx_459 = map;
						if (eax_451 != edx_418 && ebx_310 != 0x00)
						{
							word32 ecx_467 = eax_451 - edx_418;
							Eq_2 edx_469 = ebx_459;
							Eq_2 ecx_472 = (word32) ebx_459 + ebx_310 * 0x08;
							do
							{
								*edx_469 = (word32) *edx_469 + ecx_467;
								*((word32) edx_469 + 4) = (word32) *((word32) edx_469 + 4) + ecx_467;
								edx_469 = (word32) edx_469 + 8;
							} while (ecx_472 != edx_469);
						}
						string_space = eax_451;
						string_space_max = eax_435;
						edx_418 = eax_451;
					}
					struct Eq_7793 * esp_502 = esp_21 - 0x04;
					esp_502->tFFFFFFFC = (word32) eax_386 + 1;
					esp_502->tFFFFFFF8 = esi_204;
					esp_502->tFFFFFFF4 = (word32) edx_418 + ebx_410;
					struct Eq_7807 * ebx_519 = (word32) ebx_459 + ebx_310 * 0x08;
					word32 ecx_1110;
					word32 edx_1111;
					ebx_519->t0000 = memcpy(esp_502->tFFFFFFF4, esp_502->tFFFFFFF8, esp_502->tFFFFFFFC, out ecx_1110, out edx_1111);
					esp_502->tFFFFFFFC = (word32) eax_399 + 1;
					esp_502->tFFFFFFF8 = edi_224;
					esp_502->tFFFFFFF4 = (word32) edx_418 + ebx_412;
					word32 ecx_1112;
					word32 edx_1113;
					ebx_519->t0004 = memcpy(esp_502->tFFFFFFF4, esp_502->tFFFFFFF8, esp_502->tFFFFFFFC, out ecx_1112, out edx_1113);
					string_space_act = ebx_414;
					nmap = ebx_310 + 0x01;
					dwLoc01D4_750 = (byte) dwLoc01D4_750.u0 + 1;
					if (eax_188 == 0x00)
						goto l0804DD40;
				}
				else
				{
l0804DB0C:
					if (eax_188 == 0x00)
					{
l0804DD40:
						do
						{
							esp_21->dwFFFFFFF8 = (word32) eax_116;
							esp_21->dwFFFFFFF4 = 400;
							esp_21->dwFFFFFFF0 = fp - 0x01B0;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							Eq_2 stackArg8 = <invalid>;
							Eq_2 stackArg12 = <invalid>;
							word32 edx_1087;
							if (fgets_unlocked(gs, stackArg4, stackArg8, stackArg12, out edx_1087) == 0x00)
								break;
							esp_21->dwFFFFFFF4 = 0x0A;
							esp_21->dwFFFFFFF0 = fp - 0x01B0;
							word32 ecx_1090;
							word32 edx_1091;
						} while (strchr(esp_21->dwFFFFFFF0, esp_21->b000C, out ecx_1090, out edx_1091) == 0x00);
					}
				}
			} while ((*eax_116 & 0x10) == 0x00);
			struct Eq_7388 * esp_634 = esp_21 - 0x0C;
			esp_634->tFFFFFFFC = eax_116;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			__new_fclose(gs, stackArg4);
			if (dwLoc01D4_750 != 0x00)
			{
				esp_634->ptr0008 = 134535536;
				esp_634->dw0004 = 0x08;
				esp_634->dw0000 = nmap;
				esp_634->tFFFFFFFC = map;
				qsort();
			}
		}
		else
		{
			esp_59->tFFFFFFF4 = eax_116;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			__new_fclose(gs, stackArg4);
		}
	}
	else
		dwLoc01D4_750.u0 = 0x00;
	if ((ebx_25 ^ gs->t0014) == 0x00)
		return dwLoc01D4_750;
	word32 edx_1083;
	word32 ecx_1082;
	__stack_chk_fail(out ecx_1082, out edx_1083);
	word32 ebp_1089;
	word32 ebx_1088;
	return _nl_expand_alias(gs, out ebx_1088, out ebp_1089);
}

// 0804DF20: Register Eq_2 _nl_expand_alias(Register (ptr32 Eq_9) gs, Register out ptr32 ebxOut, Register out (ptr32 Eq_4959) ebpOut)
// Called from:
//      _nl_find_domain
//      read_alias_file
//      _nl_find_locale
Eq_2 _nl_expand_alias(struct Eq_9 * gs, ptr32 & ebxOut, struct Eq_4959 & ebpOut)
{
	struct Eq_7920 * esp_158 = fp - 44;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_30;
	if (!__cmpxchg(lock, 0x01, 0x00, out eax_30))
		__lll_lock_wait_private(eax_30, 0x080CF5E4, gs);
	if (locale_alias_path.10080 == 0x00)
		locale_alias_path.10080 = 0x080A22FB;
	Eq_2 edx_192;
	Eq_2 ecx_181;
	struct Eq_7950 * eax_146 = &g_t80CE000;
	uint32 esi_147 = nmap;
	if (esi_147 != 0x00)
	{
l0804E057:
		word32 edi_153 = eax_146->dw1FE0;
		esp_158[3] = (struct Eq_7920) (eax_146 - 0xC0);
		esp_158[2] = (struct Eq_7920) edi_153;
		uint32 ebp_155 = 0x00;
		do
		{
			struct Eq_8046 * esp_167 = esp_158 - 0x04;
			word32 eax_163 = esp_158[2];
			esp_167->tFFFFFFFC = esp_167->t0010;
			uint32 ebx_166 = esi_147 + ebp_155;
			struct Eq_8061 * edi_173 = eax_163 + (ebx_166 >> 0x01) * 0x08;
			esp_167->tFFFFFFF8 = edi_173->t0000;
			esp_167->tFFFFFFF4 = esp_167->t0034;
			int32 eax_180 = __strcasecmp_l(esp_167->tFFFFFFF4, esp_167->tFFFFFFF8, esp_167->tFFFFFFFC, out ecx_181);
			esp_158 = (struct Eq_7920 *) ((char *) &esp_167->tFFFFFFFC + 8);
			if (eax_180 < 0x00)
				esi_147 = ebx_166 >> 0x01;
			else
			{
				if (eax_180 == 0x00)
				{
					edx_192 = edi_173->t0004;
					goto l0804DFF1;
				}
				ebp_155 = (ebx_166 >> 0x01) + 0x01;
			}
		} while (esi_147 > ebp_155);
	}
l0804DF81:
	struct Eq_7971 * edx_199 = *((word32) esp_158[1].dw000C + 5572);
	byte cl_207 = 0x00;
	byte al_203 = edx_199->b0000;
	while (al_203 != 0x00)
	{
		struct Eq_7971 * eax_75;
		struct Eq_7971 * ecx_71 = edx_199 + 1;
		if (al_203 == 0x3A)
		{
			do
			{
				ecx_71 = ecx_398 + 1;
				eax_75 = ecx_398;
				byte dl_83 = ecx_71->bFFFFFFFF;
				ecx_398 = ecx_71;
			} while (dl_83 == 0x3A);
			if (dl_83 != 0x00)
				goto l0804DFBA;
			edx_199 = ecx_398;
		}
		else
		{
			eax_75 = edx_199;
l0804DFBA:
			struct Eq_7971 * ecx_91 = eax_75 + 1;
			do
			{
				byte bl_100 = ecx_399->b0000;
				edx_199 = ecx_399;
				ecx_91 = ecx_399 + 1;
				if (bl_100 == 0x00)
					break;
				ecx_399 = ecx_91;
			} while (bl_100 != 0x3A);
			if (ecx_399 > eax_75)
			{
				*((word32) esp_158[1].dw000C + 5572) = (struct Eq_7920) ecx_399;
				if (read_alias_file(eax, ecx_399 - eax_75, gs) == 0x00)
					goto l0804DF81;
				eax_146 = (struct Eq_7950 *) esp_158[1];
				esi_147 = eax_146->dw15D8;
				if (esi_147 != 0x00)
					goto l0804E057;
				goto l0804DF81;
			}
		}
		al_203 = edx_199->b0000;
		cl_207 = 0x01;
	}
	ecx_181 = (uint32) cl_207;
	if (cl_207 != 0x00)
		*((word32) esp_158[1].dw000C + 5572) = (struct Eq_7920) edx_199;
	edx_192.u0 = 0x00;
l0804DFF1:
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v24_241 = lock - 0x01;
	lock = v24_241;
	if (v24_241 != 0x00)
		__lll_unlock_wake_private(0x080CF5E4, ecx_181, edx_192, gs);
	ebxOut = ebx;
	ebpOut = ebp;
	return edx_192;
}

// 0804E0D0: Register Eq_2 _nl_make_l10nflist(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Stack Eq_2 dwArg28, Stack Eq_2 dwArg2C, Register out Eq_952 ebxOut, Register out Eq_952 ebpOut, Register out Eq_952 ediOut)
// Called from:
//      _nl_find_domain
//      _nl_make_l10nflist
//      _nl_find_locale
Eq_2 _nl_make_l10nflist(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, Eq_2 dwArg28, Eq_2 dwArg2C, union Eq_952 & ebxOut, union Eq_952 & ebpOut, union Eq_952 & ediOut)
{
_nl_make_l10nflist_entry:
	def fp
	def ebp
	def edi
	def ebx
	def dwArg14
	def dwArg10
	def dwArg0C
	def dwArg18
	def dwArg1C
	def dwArg20
	def dwArg24
	def dwArg28
	def dwArg08
	def dwArg04
	def dwArg2C
	def gs
	eax_24 = strlen(dwArg14, out ecx_1484, out edx_1485)
	branch (dwArg10 & 0x04) == 0x00 l0804E438
	goto l0804E10B
l0804E0D0:
l0804E10B:
	eax_48 = strlen(dwArg18, out ecx_1486, out edx_1487)
	ebx_57 = (word32) eax_48 + 1
l0804E11D:
	ebx_90 = PHI((ebx_57, l0804E10B), (ebx_40, l0804E438))
	edi_63 = (word32) eax_24 + ((word32) dwArg0C + 2)
	ebp_64 = 0x00
	branch (dwArg10 & 0x02) == 0x00 l0804E140
l0804E12E:
	eax_75 = strlen(dwArg1C, out ecx_1488, out edx_1489)
	ebp_84 = (word32) eax_75 + 1
l0804E140:
	ebp_118 = PHI((ebp_84, l0804E12E), (ebp_64, l0804E11D))
	edi_91 = edi_63 + ebx_90
	ebx_92 = 0x00
	branch (dwArg10 & 0x01) == 0x00 l0804E163
l0804E151:
	eax_103 = strlen(dwArg20, out ecx_1490, out edx_1491)
	ebx_112 = (word32) eax_103 + 1
l0804E163:
	ebx_144 = PHI((ebx_92, l0804E140), (ebx_112, l0804E151))
	edi_119 = edi_91 + ebp_118
	ebp_120 = 0x00
	branch (dwArg10 & 0x08) == 0x00 l0804E186
l0804E174:
	eax_131 = strlen(dwArg24, out ecx_1502, out edx_1503)
	ebp_140 = (word32) eax_131 + 1
l0804E186:
	ebp_151 = PHI((ebp_120, l0804E163), (ebp_140, l0804E174))
	ebx_146 = ebx_144 + edi_119
	ebp_152 = ebp_151 + ebx_146
	eax_154 = strlen(dwArg28, out ecx_1492, out edx_1493)
	ebp_161 = (word32) eax_154 + ebp_152
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	eax_175 = __libc_malloc(gs, stackArg0, ebp_161, out ecx_1496, out edx_1497, out ebx_1498, out ebp_1499, out esi_1500, out edi_1501)
	branch eax_175 == 0x00 l0804E5B0
l0804E1B7:
	memcpy(eax_175, dwArg08, dwArg0C, out ecx_1504, out edx_1505)
	branch dwArg0C == 0x00 l0804E200
l0804E1D3:
	ebx_220 = dwArg0C
	ebp_221 = eax_175
l0804E1E0:
	ebx_239 = PHI((ebx_220, l0804E1D3), (ebx_240, l0804E1F4))
	ebp_227 = PHI((ebp_221, l0804E1D3), (ebp_871, l0804E1F4))
	eax_229 = strlen(ebp_227, out ecx_1507, out edx_1508)
	edx_238 = ~eax_229
	ebx_240 = (word32) ebx_239 + edx_238
	branch ebx_240 == 0x00 l0804E200
l0804E1F4:
	eax_869 = eax_229 + ebp_227
	ebp_871 = eax_869 + 1
	*eax_869 = 0x3A
	goto l0804E1E0
l0804E200:
	eax_250 = dwArg0C + eax_175
	*((word32) dwArg0C + (eax_175 - 0x01)) = 0x2F
	eax_260 = __stpcpy(eax_250, dwArg14, out ecx_1506)
	branch (dwArg10 & 0x04) != 0x00 l0804E560
l0804E22B:
	eax_294 = PHI((eax_260, l0804E200), (eax_283, l0804E560))
	edx_295 = (word32) eax_294 + 1
	branch (dwArg10 & 0x02) != 0x00 l0804E540
l0804E23A:
	edx_332 = PHI((edx_295, l0804E22B), (edx_317, l0804E540))
	eax_326 = PHI((eax_294, l0804E22B), (eax_309, l0804E540))
	branch (dwArg10 & 0x01) != 0x00 l0804E520
l0804E246:
	edx_359 = PHI((edx_332, l0804E23A), (edx_344, l0804E520))
	eax_353 = PHI((eax_326, l0804E23A), (eax_336, l0804E520))
	branch (dwArg10 & 0x08) != 0x00 l0804E500
l0804E252:
	edx_385 = PHI((edx_359, l0804E246), (edx_371, l0804E500))
	eax_372 = PHI((eax_353, l0804E246), (eax_363, l0804E500))
	*eax_372 = 0x2F
	memcpy(edx_385, dwArg28, (word32) eax_154 + 1, out ecx_1513, out edx_1514)
	eax_397 = *dwArg04
	branch eax_397 == 0x00 l0804E5E9
l0804E283:
	ebp_404 = eax_397
	ebx_405.u0 = 0x00
l0804E290:
	ebx_444 = PHI((ebx_405, l0804E283), (ebx_445, l0804E2B0))
	Mem411 = PHI((Mem398, l0804E283), (Mem438, l0804E2B0))
	ebp_410 = PHI((ebp_404, l0804E283), (ebp_439, l0804E2B0))
	eax_412 = *ebp_410
	branch eax_412 == 0x00 l0804E2B0
l0804E297:
	eax_424 = strcmp(eax_412, eax_175, out ecx_1515, out edx_1516)
	branch eax_424 == 0x00 l0804E594
l0804E2AC:
	branch eax_424 < 0x00 l0804E2B7
l0804E2AE:
	ebx_436 = ebp_410
l0804E2B0:
	ebx_445 = PHI((ebx_436, l0804E2AE), (ebx_444, l0804E290))
	Mem438 = PHI((Mem423, l0804E2AE), (Mem411, l0804E290))
	ebp_439 = *((word32) ebp_410 + 0x0C)
	branch ebp_439 != 0x00 l0804E290
l0804E2B7:
	ebx_443 = PHI((ebx_444, l0804E2AC), (ebx_445, l0804E2B0))
	dwLoc2C_1060 = ebx_443
l0804E2BB:
	dwLoc2C_1243 = PHI((dwLoc2C_1060, l0804E2B7), (dwLoc2C_1057, l0804E5E9))
	branch dwArg2C == 0x00 l0804E592
l0804E2C7:
	ebx_507 = 0x00
	ebp_509 = dwArg08
	eax_512 = dwArg10 >> 0x01 & ~0x2AAA
	eax_513 = eax_512 + (dwArg10 & 0x5555)
	edx_517 = eax_513 >> 0x02 & ~0x0CCC
	edx_518 = edx_517 + (eax_513 & 0x3333)
	eax_521 = (edx_518 >> 0x04) + edx_518
	edx_524 = (eax_521 & 0x0F0F) >> 0x08
	eax_525 = (eax_521 & 0x0F0F) + edx_524
	al_526 = (byte) eax_525
	eax_527 = (word32) al_526
	bLoc28_1211 = (byte) eax_527
	branch dwArg0C == 0x00 l0804E5BC
l0804E31C:
	esi_548 = dwArg0C
l0804E320:
	esi_567 = PHI((esi_548, l0804E31C), (esi_568, l0804E320))
	ebp_555 = PHI((ebp_509, l0804E31C), (ebp_565, l0804E320))
	ebx_551 = PHI((ebx_507, l0804E31C), (ebx_552, l0804E320))
	ebx_552 = ebx_551 + 0x01
	eax_557 = strlen(ebp_555, out ecx_1527, out edx_1528)
	ebp_565 = (word32) eax_557 + ((word32) ebp_555 + 1)
	eax_566 = ~eax_557
	esi_568 = (word32) esi_567 + eax_566
	branch esi_568 != 0x00 l0804E320
l0804E339:
	ecx_572 = (word32) bLoc28_1211
	cl_573 = (byte) ecx_572
	ebx_574 = ebx_552 << cl_573
	eax_576 = ebx_574 * 0x04 + 0x14
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	eax_582 = __libc_malloc(gs, stackArg0, eax_576, out ecx_1530, out edx_1531, out ebx_1532, out ebp_1533, out esi_1534, out edi_1535)
	ebp_587 = eax_582
	branch eax_582 == 0x00 l0804E5F6
l0804E361:
	*eax_582 = eax_175
	ebx_609 = dwArg0C
	edi_610 = dwArg08
	esi_611 = esi_568
l0804E370:
	ebx_630 = PHI((ebx_609, l0804E361), (ebx_631, l0804E370))
	edi_618 = PHI((edi_610, l0804E361), (edi_628, l0804E370))
	esi_614 = PHI((esi_611, l0804E361), (esi_615, l0804E370))
	esi_615 = (word32) esi_614 + 1
	eax_620 = strlen(edi_618, out ecx_1539, out edx_1540)
	edi_628 = (word32) eax_620 + ((word32) edi_618 + 1)
	eax_629 = ~eax_620
	ebx_631 = (word32) ebx_630 + eax_629
	branch ebx_631 != 0x00 l0804E370
l0804E389:
	eax_634.u0 = 0x01
	branch esi_615 == 0x01 l0804E440
l0804E397:
	ebp_647 = PHI((ebp_587, l0804E389), (ebp_542, l0804E5D3), (ebp_587, l0804E440))
	eax_646 = PHI((eax_634, l0804E389), (eax_547, l0804E5D3), (eax_642, l0804E440))
	*((word32) ebp_647 + 4) = eax_646
	((word32) ebp_647 + 8)->u0 = 0x00
	branch dwLoc2C_1243 == 0x00 l0804E580
l0804E3AD:
	eax_659 = *((word32) dwLoc2C_1243 + 0x0C)
	*((word32) ebp_647 + 0x0C) = eax_659
	*((word32) dwLoc2C_1243 + 0x0C) = ebp_647
l0804E3BA:
	branch dwArg0C == 0x00 l0804E5E0
l0804E3C6:
	ebx_669 = dwArg0C
	edi_670 = dwArg08
	esi_671 = 0x00
l0804E3D0:
	ebx_692 = PHI((ebx_669, l0804E3C6), (ebx_693, l0804E3D0))
	edi_680 = PHI((edi_670, l0804E3C6), (edi_690, l0804E3D0))
	esi_676 = PHI((esi_671, l0804E3C6), (esi_677, l0804E3D0))
	esi_677 = esi_676 + 0x01
	eax_682 = strlen(edi_680, out ecx_1541, out edx_1542)
	edi_690 = (word32) eax_682 + ((word32) edi_680 + 1)
	eax_691 = ~eax_682
	ebx_693 = (word32) ebx_692 + eax_691
	branch ebx_693 != 0x00 l0804E3D0
l0804E3E9:
	al_700 = (int8) (esi_677 == 0x01)
	eax_702.u1 = (uint32) al_700
	esi_703 = dwArg10 - eax_702
l0804E3F7:
	esi_713 = PHI((esi_703, l0804E3E9), (esi_668, l0804E5E0))
	esp_705 = fp - 0x3C
	ecx_709 = 0x00
	edx_711 = ~dwArg10
	branch esi_713 < 0x00 l0804E423
l0804E40F:
	ebp_721 = edx_711
l0804E415:
	ecx_733 = PHI((ecx_709, l0804E40F), (ecx_851, l0804E419))
	esp_729 = PHI((esp_705, l0804E40F), (esp_855, l0804E419))
	ebp_724 = PHI((ebp_721, l0804E40F), (ebp_873, l0804E419))
	esi_723 = PHI((esi_713, l0804E40F), (esi_844, l0804E419))
	branch (esi_723 & ebp_724) == 0x00 l0804E458
l0804E419:
	ebp_873 = PHI((ebp_724, l0804E415), (ebp_840, l0804E4E8))
	esp_855 = PHI((esp_729, l0804E415), (esp_838, l0804E4E8))
	ecx_851 = PHI((ecx_733, l0804E415), (ecx_837, l0804E4E8))
	esi_843 = PHI((esi_723, l0804E415), (esi_841, l0804E4E8))
	esi_844 = esi_843 - 0x01
	branch esi_844 != ~0x00 l0804E415
l0804E423:
	ecx_850 = PHI((ecx_851, l0804E421), (ecx_709, l0804E3F7))
	ebp_849 = ebp_647
	((word32) ebp_647 + (ecx_850 * 0x04 + 16))->u0 = 0x00
l0804E42B:
	ebp_858 = PHI((ebp_849, l0804E423), (ebp_593, l0804E5F6))
	eax_859 = ebp_858
	ebxOut.u0 = <invalid>
	ebpOut.u0 = <invalid>
	ediOut.u0 = <invalid>
	return eax_859
l0804E438:
	ebx_40 = 0x00
	goto l0804E11D
l0804E440:
	al_641 = (int8) ((dwArg10 & 0x03) == 0x03)
	eax_642 = (word32) al_641
	goto l0804E397
l0804E458:
	esp_729->dw0018 = ebp_724
	ebp_731 = 0x00
	esp_729->t0014 = esi_723
	edi_734 = ecx_733
	goto l0804E4D6
l0804E472:
	esp_745 = esp_741 - 0x0C
	esp_745->tFFFFFFFC = ebp_740
	eax_750 = strlen(esp_745->tFFFFFFFC, out ecx_1543, out edx_1544)
	esp_757 = (struct Eq_8700 *) ((char *) &esp_745->tFFFFFFFC + 16)
	ebp_758 = (word32) eax_750 + ((word32) ebp_740 + 1)
	branch ebp_758 >= esp_745->t001C l0804E4E8
l0804E48C:
	branch ebp_758 == 0x00 l0804E4E8
l0804E490:
	ebp_770 = PHI((ebp_758, l0804E48C), (ebp_842, l0804E4DE))
	edi_766 = PHI((edi_835, l0804E48C), (edi_836, l0804E4DE))
	esp_764 = PHI((esp_757, l0804E48C), (esp_824, l0804E4DE))
	esp_765 = esp_764 - 0x0C
	edi_767 = edi_766 + 0x01
	esp_765->tFFFFFFFC = ebp_770
	eax_772 = strlen(esp_765->tFFFFFFFC, out ecx_1545, out edx_1546)
	esp_765->dw0004 = 0x01
	v27_784 = esp_765->dw0070
	esp_765->dw0000 = v27_784
	v28_787 = esp_765->t006C
	esp_765->tFFFFFFFC = v28_787
	v29_790 = esp_765->dw0068
	esp_765->dwFFFFFFF8 = v29_790
	v30_793 = esp_765->dw0064
	esp_765->dwFFFFFFF4 = v30_793
	v31_796 = esp_765->dw0060
	esp_765->dwFFFFFFF0 = v31_796
	v32_799 = esp_765->dw005C
	esp_765->dwFFFFFFEC = v32_799
	v33_802 = esp_765->dw0020
	esp_765->dwFFFFFFE8 = v33_802
	esp_765->dwFFFFFFE4 = (word32) eax_772 + 1
	esp_765->tFFFFFFE0 = ebp_770
	v34_809 = esp_765->dw004C
	esp_765->dwFFFFFFDC = v34_809
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg4.u0 = <invalid>
	eax_815 = _nl_make_l10nflist(stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20, dwArg24, dwArg28, out ebx_1548, out ebp_1549, out edi_1550)
	esp_819 = (struct Eq_8700 *) (&esp_765->dw0004 + 2)
	*((word32) ebp_647 + (edi_767 * 0x04 + 0x0C)) = eax_815
	branch ebp_770 != 0x00 l0804E46C
l0804E4D6:
	edi_836 = PHI((edi_734, l0804E458), (edi_767, l0804E490))
	Mem825 = PHI((Mem732, l0804E458), (Mem820, l0804E490))
	esp_824 = PHI((esp_729, l0804E458), (esp_819, l0804E490))
	eax_826 = esp_824->dw0048
	branch eax_826 == 0x00 l0804E4E8
l0804E4DE:
	ebp_842 = esp_824->t0044
	goto l0804E490
l0804E4E8:
	Mem839 = PHI((Mem748, l0804E48C), (Mem825, l0804E4D6))
	esp_838 = PHI((esp_757, l0804E48C), (esp_824, l0804E4D6))
	edi_834 = PHI((edi_835, l0804E472), (edi_835, l0804E48C), (edi_836, l0804E4D6))
	ecx_837 = edi_834
	ebp_840 = esp_838->dw0018
	esi_841 = esp_838->t0014
	goto l0804E419
l0804E500:
	*eax_353 = 0x40
	eax_363 = __stpcpy(edx_359, dwArg24, out ecx_1512)
	edx_371 = (word32) eax_363 + 1
	goto l0804E252
l0804E520:
	*eax_326 = 0x2E
	eax_336 = __stpcpy(edx_332, dwArg20, out ecx_1511)
	edx_344 = (word32) eax_336 + 1
	goto l0804E246
l0804E540:
	*eax_294 = 0x2E
	eax_309 = __stpcpy(edx_295, dwArg1C, out ecx_1510)
	edx_317 = (word32) eax_309 + 1
	goto l0804E23A
l0804E560:
	*eax_260 = 0x5F
	eax_283 = __stpcpy((word32) eax_260 + 1, dwArg18, out ecx_1509)
	goto l0804E22B
l0804E580:
	*((word32) ebp_647 + 0x0C) = eax_397
	*dwArg04 = ebp_647
	goto l0804E3BA
l0804E592:
	ebp_455.u0 = 0x00
l0804E594:
	ebp_472 = PHI((ebp_410, l0804E297), (ebp_455, l0804E592))
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	free(gs, stackArg0, eax_175, out ecx_1518, out edx_1519)
	eax_494 = ebp_472
	ebxOut.u0 = <invalid>
	ebpOut.u0 = <invalid>
	ediOut.u0 = <invalid>
	return eax_494
l0804E5B0:
	eax_190.u0 = 0x00
	ebxOut.u0 = <invalid>
	ebpOut.u0 = <invalid>
	ediOut.u0 = <invalid>
	return eax_190
l0804E5BC:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	eax_537 = __libc_malloc(gs, stackArg0, 0x14, out ecx_1521, out edx_1522, out ebx_1523, out ebp_1524, out esi_1525, out edi_1526)
	ebp_542 = eax_537
	branch eax_537 == 0x00 l0804E5F6
l0804E5D3:
	*eax_537 = eax_175
	eax_547.u0 = 0x01
	goto l0804E397
l0804E5E0:
	esi_668 = dwArg10
	goto l0804E3F7
l0804E5E9:
	dwLoc2C_1057.u0 = 0x00
	goto l0804E2BB
l0804E5F6:
	ebp_593.u0 = 0x00
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	free(gs, stackArg0, eax_175, out ecx_1537, out edx_1538)
	goto l0804E42B
_nl_make_l10nflist_exit:
}

// 0804E610: Register Eq_2 _nl_normalize_codeset(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _nl_explode_name
//      _nl_load_locale_from_archive
Eq_2 _nl_normalize_codeset(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebx_108;
	Eq_2 edi_172;
	if (dwArg08 != 0x00)
	{
		Eq_2 esi_40 = g_t80CE08C;
		word32 ecx_42 = 0x00;
		Eq_2 eax_44 = dwArg04;
		word32 ebx_45 = 0x01;
		word32 edi_46 = dwArg08 + dwArg04;
		do
		{
			uint32 edx_50 = (word32) *eax_44;
			if ((*((word32) esi_40 + edx_50 * 0x02) & 0x08) != 0x00)
			{
				++ecx_42;
				if (edx_50 >= 0x3A)
					ebx_45 = 0x00;
			}
			eax_44 = (word32) eax_44 + 1;
		} while (edi_46 != eax_44);
		Eq_2 edi_109;
		if (ebx_45 == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_304;
			word32 edi_307;
			word32 esi_306;
			word32 edx_303;
			word32 ecx_302;
			word32 ebp_305;
			Eq_2 eax_103 = __libc_malloc(gs, stackArg0, ecx_42 + 0x01, out ecx_302, out edx_303, out ebx_304, out ebp_305, out esi_306, out edi_307);
			ebx_108 = eax_103;
			edi_109 = eax_103;
			if (eax_103 == 0x00)
				return 0x00;
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_297;
			word32 ebp_298;
			word32 edx_296;
			word32 esi_299;
			word32 edi_300;
			word32 ecx_295;
			Eq_2 eax_86 = __libc_malloc(gs, stackArg0, ecx_42 + 0x04, out ecx_295, out edx_296, out ebx_297, out ebp_298, out esi_299, out edi_300);
			edi_109 = eax_86;
			if (eax_86 == 0x00)
				return 0x00;
			*eax_86 = 7304041;
			ebx_108 = (word32) eax_86 + 3;
		}
		Eq_2 edx_131 = 0x00;
		Eq_150877 ebp_137[] = g_ptr80CE088;
		do
		{
			word32 eax_141 = CONVERT(Mem140[dwArg04 + edx_131:byte], byte, word32);
			byte cl_164 = (byte) eax_141;
			if ((*((word32) esi_40 + (eax_141 * 0x02 + 1)) & 0x04) == 0x00)
			{
				if (eax_141 <= 0x39)
				{
					*ebx_108 = cl_164;
					edx_131 = (word32) edx_131 + 1;
					ebx_108 = (word32) ebx_108 + 1;
					if (dwArg08 <= edx_131)
						break;
					continue;
				}
			}
			else
			{
				ebx_108 = (word32) ebx_108 + 1;
				*((word32) ebx_108 - 1) = ebp_137[eax_141].b0000;
			}
			edx_131 = (word32) edx_131 + 1;
		} while (dwArg08 > edx_131);
		edi_172 = edi_109;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ebp_291;
		word32 ebx_290;
		word32 edx_289;
		word32 ecx_288;
		word32 esi_292;
		word32 edi_293;
		Eq_2 eax_29 = __libc_malloc(gs, stackArg0, 0x04, out ecx_288, out edx_289, out ebx_290, out ebp_291, out esi_292, out edi_293);
		edi_172 = eax_29;
		if (eax_29 == 0x00)
			return 0x00;
		*eax_29 = 7304041;
		ebx_108 = (word32) eax_29 + 3;
	}
	*ebx_108 = 0x00;
	return edi_172;
}

// 0804E760: Register ui32 _nl_explode_name(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18)
// Called from:
//      _nl_find_domain
//      _nl_find_locale
ui32 _nl_explode_name(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18)
{
	ui32 edi_117;
	*dwArg0C = null;
	dwArg10->u0 = 0x00;
	dwArg14->u0 = 0x00;
	dwArg18->u0 = 0x00;
	*dwArg08 = dwArg04;
	byte al_32 = *dwArg04;
	if ((al_32 & 191) != 0x00 && (al_32 != 0x5F && al_32 != 0x2E))
	{
		Eq_2 ebx_40 = dwArg04;
		do
		{
			byte al_128 = *((word32) ebx_40 + 1);
			Eq_2 esi_104 = (word32) ebx_40 + 1;
			if (al_128 == 0x00 || al_128 == 0x5F)
			{
				if (dwArg04 == esi_104)
					goto l0804E848;
				if (al_128 != 0x5F)
					goto l0804E7ED;
				*esi_104 = 0x00;
				Eq_2 ebx_60 = (word32) ebx_40 + 2;
				*dwArg10 = ebx_60;
				al_128 = (byte) *((word32) esi_104 + 1);
				if ((al_128 & 191) != 0x00)
				{
					while (al_128 != 0x2E)
					{
						ebx_60 = (word32) ebx_60 + 1;
						al_128 = (byte) *ebx_60;
						if ((al_128 & 191) == 0x00)
							break;
					}
				}
				esi_104 = ebx_60;
				edi_117 = 0x04;
				if (al_128 == 0x2E)
					goto l0804E88D;
				goto l0804E7F7;
			}
			ebx_40 = esi_104;
		} while (al_128 != 0x2E && al_128 != 0x40);
		if (dwArg04 != esi_104)
		{
l0804E7ED:
			edi_117 = 0x00;
			if (al_128 == 0x2E)
			{
l0804E88D:
				*esi_104 = 0x00;
				Eq_2 ebx_106 = (word32) esi_104 + 1;
				*dwArg14 = ebx_106;
				al_128 = (byte) *((word32) esi_104 + 1);
				ui32 esi_119 = edi_117 | 0x02;
				if ((al_128 & 191) != 0x00)
				{
					Eq_2 ebp_134 = ebx_106;
					while (true)
					{
						esi_104 = (word32) ebp_134 + 1;
						if ((*((word32) ebp_134 + 1) & 191) == 0x00)
							break;
						ebp_134 = esi_104;
					}
					if (ebx_106 != esi_104)
					{
						Eq_2 eax_174 = _nl_normalize_codeset(ebx_106, esi_104 - ebx_106);
						*dwArg18 = eax_174;
						if (eax_174 == 0x00)
						{
							edi_117 = ~0x00;
							return edi_117;
						}
						word32 ecx_426;
						word32 edx_427;
						if (strcmp(*dwArg14, eax_174, out ecx_426, out edx_427) != 0x00)
						{
							edi_117 |= 0x03;
							al_128 = (byte) *((word32) ebp_134 + 1);
						}
						else
						{
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							word32 ecx_430;
							word32 edx_431;
							free(gs, stackArg0, eax_174, out ecx_430, out edx_431);
							al_128 = (byte) *((word32) ebp_134 + 1);
							edi_117 = esi_119;
						}
					}
					else
						edi_117 = esi_119;
				}
				else
				{
					edi_117 = esi_119;
					esi_104 = ebx_106;
				}
			}
l0804E7F7:
			if (al_128 == 0x40)
			{
				*esi_104 = 0x00;
				*dwArg0C = (word32) esi_104 + 1;
				if (*((word32) esi_104 + 1) != 0x00)
					edi_117 |= 0x08;
			}
l0804E818:
			Eq_2 eax_258 = *dwArg10;
			if (eax_258 != 0x00)
			{
				ui32 ecx_264 = edi_117 & ~0x04;
				if (*eax_258 == 0x00)
					edi_117 = ecx_264;
			}
			Eq_2 eax_273 = *dwArg14;
			if (eax_273 != 0x00)
			{
				ui32 edx_279 = edi_117 & ~0x02;
				if (*eax_273 == 0x00)
					edi_117 = edx_279;
			}
			return edi_117;
		}
	}
l0804E848:
	edi_117 = 0x00;
	goto l0804E818;
}

// 0804E970: void __gettext_free_exp(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __gettext_free_exp
//      new_exp
//      _nl_unload_domain
void __gettext_free_exp(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	word32 eax_17 = *dwArg04;
	if (eax_17 != 0x02)
	{
		if (eax_17 != 0x03)
		{
			if (eax_17 != 0x01)
				goto l0804E99D;
l0804E9CC:
			__gettext_free_exp(gs, *((word32) dwArg04 + 8));
l0804E99D:
			word32 ecx_127;
			word32 edx_128;
			free(gs, dwLoc20, dwArg04, out ecx_127, out edx_128);
			return;
		}
		__gettext_free_exp(gs, *((word32) dwArg04 + 16));
	}
	__gettext_free_exp(gs, *((word32) dwArg04 + 0x0C));
	goto l0804E9CC;
}

// 0804E9E0: void new_exp(Register ui32 eax, Register (arr Eq_2) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
void new_exp(ui32 eax, Eq_2 ecx[], Eq_2 edx, struct Eq_9 * gs)
{
	ui32 esi_14 = eax - 0x01;
	if (eax == 0x00)
	{
		word32 ecx_220;
		word32 esi_224;
		word32 edi_225;
		word32 edx_221;
		word32 ebx_222;
		word32 ebp_223;
		Eq_2 eax_30 = __libc_malloc(gs, dwLoc40, 0x14, out ecx_220, out edx_221, out ebx_222, out ebp_223, out esi_224, out edi_225);
		if (eax_30 == 0x00)
			return;
		*eax_30 = 0x00;
		*((word32) eax_30 + 4) = edx;
	}
	else
	{
		Eq_2 edi_109[] = ecx;
		Eq_2 ecx_110 = ecx[eax - 0x01];
		if (ecx_110 != 0x00)
		{
			ui32 eax_55 = eax - 0x01;
			do
			{
				--eax_55;
				if (eax_55 == ~0x00)
				{
					word32 ebp_75;
					word32 ecx_226;
					word32 edx_227;
					word32 ebx_228;
					Eq_2 eax_74 = __libc_malloc(gs, dwLoc40, 0x14, out ecx_226, out edx_227, out ebx_228, out ebp_75, out esi_14, out edi_109);
					if (eax_74 == 0x00)
						break;
					*eax_74 = ebp_75;
					*((word32) eax_74 + 4) = edx;
					*((word32) eax_74 + (esi_14 * 0x04 + 8)) = ecx_110;
					ui32 esi_118 = esi_14 - 0x01;
					if (esi_14 == 0x00)
						return;
					do
					{
						*((word32) eax_74 + (esi_118 * 0x04 + 8)) = edi_109[esi_118];
						--esi_118;
					} while (esi_118 != ~0x00);
					return;
				}
			} while (ecx[eax_55] != 0x00);
		}
		while (true)
		{
			__gettext_free_exp(gs, ecx_110);
			--esi_14;
			if (esi_14 == ~0x00)
				break;
			ecx_110 = edi_109[esi_14];
		}
	}
}

// 0804EAC0: Register word32 __gettextparse(Register (ptr32 Eq_9) gs, Stack (ptr32 (ptr32 byte)) dwArg04, Register out Eq_2 ecxOut, Register out Eq_9450 edxOut)
// Called from:
//      __gettext_extract_plural
word32 __gettextparse(struct Eq_9 * gs, byte ** dwArg04, union Eq_2 & ecxOut, union Eq_9450 & edxOut)
{
	Eq_2175 eax_26 = gs->t0014;
	Eq_2 dwLoc04FC_584 = fp - 0x0340;
	up32 dwLoc04F4_585 = 0x00;
	int32 dwLoc050C_586 = ~0x01;
	uint32 dwLoc0500_587 = 200;
	Eq_2 dwLoc0510_589 = fp - 0x04D0;
	Eq_2 ebx_126 = fp - 0x04D0;
	Eq_9450 edx_197 = 0x00;
	struct Eq_9471 * esi_276 = fp - 0x0340;
l0804EB3B:
	Eq_2 ecx_177;
	word32 esi_236;
	Eq_2 eax_210;
	word32 ebp_191;
	struct Eq_9471 * ecx_209;
	int32 dwLoc0508_627;
	word32 eax_48 = CONVERT(Mem45[0x080A261C<p32> + edx_197:byte], byte, int32);
	Eq_9506 dwLoc0508_593 = eax_48;
	if (eax_48 == ~0x09)
	{
l0804ECE0:
		ecx_177 = (word32) *((word32) edx_197.u0 + 0x080A2600);
		struct Eq_9471 * esi_186 = esi_276;
		cu8 cl_192 = (byte) ecx_177;
		if (ecx_177 != 0x00)
		{
			ui32 edx_181 = (word32) *((word32) ecx_177 + 134882636);
			ebp_191 = (word32) esi_276[0x01 - edx_181];
			if (cl_192 <= 0x0D)
			{
				<anonymous> * edx_212 = g_a80A2320[ecx_177 * 0x04] + 0x080CE000;
				word32 eax_222;
				Eq_9450 edx_223;
				Eq_2 ecx_224;
				edx_212();
				ecxOut = ecx_224;
				edxOut = edx_223;
				return eax_222;
			}
			int32 edx_195 = (word32) *((byte) ecx_177.u0 + 0x080A255C);
			edx_197.u0 = (int32) (0x080A25EA + edx_195);
			dwLoc0508_627 = edx_195 - 0x10;
			ecx_209 = esi_276 - edx_181 * 0x04 + 0x04;
			eax_210 = ebx_126 - edx_181 * 0x02;
			goto l0804EE13;
		}
		if (dwLoc04F4_585 == 0x03)
		{
			if (dwLoc050C_586 > 0x00)
			{
				dwLoc050C_586 = ~0x01;
l0804ED1D:
				while (true)
				{
					ecx_177.u0 = 134882844;
					word32 eax_245 = CONVERT(Mem244[0x080A261C<p32> + edx_197:byte], byte, int32);
					if (eax_245 != ~0x09)
					{
						edx_197 = (word32) eax_245 + 1;
						if (eax_245 <= 0x35 && *((word32) eax_245 + 0x080A2581) == 0x01)
						{
							edx_197 = (word32) *((word32) eax_245 + 134882753);
							if (edx_197 != 0x00)
							{
								esi_276 = esi_186 + 1;
								esi_276->t0000.u2 = dwLoc04E0;
								dwLoc04F4_585 = 0x03;
								eax_210 = ebx_126;
								goto l0804EBC5;
							}
						}
					}
					if (ebx_126 == dwLoc0510_589)
					{
						esi_236 = 0x01;
						goto l0804ED95;
					}
					ebx_126 -= (struct Eq_9705 *) 0x02;
					edx_197.u0 = (int32) *ebx_126;
					esi_186 -= 0x04;
				}
			}
			if (dwLoc050C_586 == 0x00)
			{
				esi_236 = 0x01;
				ebx_126 = dwLoc0510_589;
				goto l0804ED95;
			}
		}
		goto l0804ED1D;
	}
	int32 eax_114;
	if (dwLoc050C_586 != ~0x01)
	{
		if (dwLoc050C_586 <= 0x00)
		{
			eax_114 = 0x00;
			dwLoc050C_586 = 0x00;
			goto l0804EB77;
		}
		eax_114 = (word32) (&g_t80A2640)[dwLoc050C_586];
	}
	else
	{
		byte * eax_55 = *dwArg04;
		byte * dwLoc04F0_596 = eax_55;
		cu8 al_105 = *eax_55;
		if (al_105 == 0x00)
		{
l0804EEF8:
			*dwArg04 = (byte **) dwLoc04F0_596;
			dwLoc050C_586 = 0x00;
			eax_114 = 0x00;
			goto l0804EB77;
		}
		if (al_105 == 0x09 || al_105 == 0x20)
		{
			byte * ecx_68 = eax_55;
			do
			{
				++ecx_68;
				al_105 = *ecx_68;
				if (al_105 == 0x00)
				{
					dwLoc04F0_596 = ecx_68;
					goto l0804EEF8;
				}
			} while (al_105 == 0x20 || al_105 == 0x09);
			dwLoc04F0_596 = ecx_68;
		}
		byte * dwLoc04EC_609 = dwLoc04F0_596 + 1;
		if (al_105 <= 0x7C)
		{
			word32 eax_137;
			Eq_9450 edx_138;
			Eq_2 ecx_139;
			(g_a80A2358[(word32) al_105 * 0x04] + 0x080CE000)();
			ecxOut = ecx_139;
			edxOut = edx_138;
			return eax_137;
		}
		*dwArg04 = (byte **) dwLoc04EC_609;
		dwLoc050C_586 = 0x0100;
		eax_114 = 0x01;
	}
	dwLoc0508_593 = (word32) eax_48.u0 + eax_114;
l0804EB77:
	if (dwLoc0508_593 <= 0x36 && (int32) (*((word32) dwLoc0508_593 + 0x080A2580)) == eax_114)
	{
		edx_197 = CONVERT(Mem157[0x080A25C0<p32> + dwLoc0508_593:byte], byte, word32);
		if (edx_197 != 0x00)
		{
			++esi_276;
			esi_276->t0000.u2 = dwLoc04E0;
			dwLoc050C_586 = ~0x01;
			dwLoc04F4_585 = dwLoc04F4_585 + ~0x00 + (word32) (dwLoc04F4_585 < 0x01);
			eax_210 = ebx_126;
			goto l0804EBC5;
		}
		ecx_209 = esi_276;
		dwLoc0508_627 = ~0x0F;
		ebp_191 = (word32) esi_276[1];
		eax_210 = ebx_126;
l0804EE13:
		int32 ebx_292 = (int32) *eax_210;
		ecx_209->t0000.u0 = ebp_191;
		esi_276 = ecx_209 + 1;
		Eq_9770 edx_298 = (word32) edx_197.u0 + ebx_292;
		int16 cx_304 = (word16) ebx_292;
		if (edx_298 <= 0x36 && cx_304 == (int16) (*((word32) edx_298 + 0x080A2580)))
			edx_197 = (word32) *((word32) edx_298 + 0x080A25C0);
		else
			edx_197.u0 = (int32) (&g_t80A25F7)[dwLoc0508_627];
l0804EBC5:
		((word32) eax_210 + 2)->u5 = (word16) edx_197;
		struct Eq_9552 * eax_338 = dwLoc0500_587 - 0x02 + dwLoc0500_587;
		ebx_126 = eax_210 + 0x02;
		ecx_177 = dwLoc0510_589 + eax_338;
		if (ebx_126 < ecx_177)
		{
l0804ECC9:
			if (edx_197 == 0x09)
			{
				ebx_126 = dwLoc0510_589;
				esi_236 = 0x00;
l0804ED95:
				if (ebx_126 == fp - 0x04D0)
					goto l0804EDA9;
				goto l0804ED9B;
			}
			goto l0804EB3B;
		}
		else
		{
			int32 esi_351 = (ebx_126 - dwLoc0510_589 >> 0x01) + 0x01;
			if (dwLoc0500_587 <= 9999)
			{
				uint32 ecx_355 = 10000;
				if (eax_338 <= (struct Eq_9552 *) 9998)
					ecx_355 = &eax_338->w0002;
				uint32 eax_365 = ecx_355 * 0x02;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				ui32 eax_368 = eax_365 + ecx_355;
				Eq_2 stackArg0 = <invalid>;
				dwLoc0500_587 = ecx_355;
				word32 esi_991;
				word32 edi_992;
				word32 ebp_990;
				word32 ebx_989;
				Eq_2 eax_390 = __libc_malloc(gs, stackArg0, eax_368 + 0x03 + eax_368, out ecx_177, out edx_197, out ebx_989, out ebp_990, out esi_991, out edi_992);
				if (eax_390 != 0x00)
				{
					word32 ecx_993;
					word32 edx_994;
					memcpy(eax_390, dwLoc0510_589, esi_351 * 0x02, out ecx_993, out edx_994);
					Eq_2 eax_434 = (word32) eax_390 + (eax_365 + 0x03 & ~0x03);
					word32 edx_996;
					word32 ecx_995;
					memcpy(eax_434, dwLoc04FC_584, esi_351 << 0x02, out ecx_995, out edx_996);
					if (dwLoc0510_589 != fp - 0x04D0)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 ecx_998;
						word32 edx_999;
						free(gs, stackArg0, dwLoc0510_589, out ecx_998, out edx_999);
					}
					ecx_177 = eax_390;
					esi_276 = eax_434 - 0x04 + (esi_351 << 0x02);
					ebx_126 = eax_390 - 0x02 + esi_351 * 0x02;
					if (ebx_126 >= (eax_390 - 0x02) + eax_365)
					{
						ebx_126 = eax_390;
						esi_236 = 0x01;
l0804ED9B:
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						free(gs, stackArg0, ebx_126, out ecx_177, out edx_197);
l0804EDA9:
						if ((eax_26 ^ gs->t0014) != 0x00)
						{
							word32 edx_1002;
							word32 ecx_1001;
							__stack_chk_fail(out ecx_1001, out edx_1002);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							Eq_2 stackArg8 = <invalid>;
							Eq_2 stackArg12 = <invalid>;
							Eq_9450 edx_555;
							Eq_2 ecx_556;
							word32 eax_554 = __gettext_extract_plural(gs, stackArg4, stackArg8, stackArg12, out ecx_556, out edx_555);
							ecxOut = ecx_556;
							edxOut = edx_555;
							return eax_554;
						}
						else
						{
							ecxOut = ecx_177;
							edxOut = edx_197;
							return esi_236;
						}
					}
					dwLoc04FC_584 = eax_434;
					dwLoc0510_589 = eax_390;
					goto l0804ECC9;
				}
			}
			ebx_126 = dwLoc0510_589;
			esi_236 = 0x02;
			goto l0804ED95;
		}
	}
	goto l0804ECE0;
}

// 0804F370: Register Eq_2 __gettext_extract_plural(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 (arr Eq_150869)) ecxOut, Register out Eq_5741 edxOut)
// Called from:
//      _nl_load_domain
//      __gettextparse
Eq_2 __gettext_extract_plural(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_150869 (& ecxOut, union Eq_5741 & edxOut)
{
	Eq_2175 eax_20 = gs->t0014;
	if (dwArg04 != 0x00)
	{
		word32 edx_256;
		word32 ecx_255;
		Eq_2 eax_36 = strstr(gs, dwArg04, 134883143, out ecx_255, out edx_256);
		Eq_2 eax_50 = strstr(gs, dwArg04, 134883151, out ecx, out edx);
		if (eax_36 != 0x00 && eax_50 != 0x00)
		{
			word32 eax_252 = (word32) *((word32) eax_50 + 9);
			Eq_2 ebx_62 = (word32) eax_50 + 9;
			if ((byte) eax_252 != 0x00)
			{
				ecx = gs->ptrFFFFFFF8;
				do
				{
					cu8 al_70 = (byte) eax_252;
					edx = (word32) al_70;
					if ((ecx[edx].b0001 & 0x20) == 0x00)
					{
						if (al_70 > 0x39 || al_70 < 0x30)
							break;
						Eq_9843 eax_103 = __strtoul(gs, ebx_62, fp - 44, 0x0A, out ecx, out edx);
						if (dwLoc2C == ebx_62)
							break;
						*dwArg0C = eax_103;
						if (__gettextparse(gs, fp - 0x28, out ecx, out edx) != 0x00)
							break;
						*dwArg08 = dwLoc24;
						goto l0804F45E;
					}
					ebx_62 = (word32) ebx_62 + 1;
					eax_252 = (word32) *ebx_62;
				} while ((byte) eax_252 != 0x00);
			}
		}
	}
	*dwArg08 = 0x080CC6C0;
	*dwArg0C = 0x02;
l0804F45E:
	Eq_2 eax_148 = eax_20 ^ gs->t0014;
	if (eax_148 != 0x00)
	{
		Eq_5741 edx_160;
		Eq_150869 (* ecx_161)[];
		Eq_2 eax_159 = __stack_chk_fail(out ecx_161, out edx_160);
		__x86.get_pc_thunk.bp();
		ecxOut = ecx_161;
		edxOut = edx_160;
		return eax_159;
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx;
		return eax_148;
	}
}

// 0804F478: void __x86.get_pc_thunk.bp()
// Called from:
//      __gettext_extract_plural
void __x86.get_pc_thunk.bp()
{
}

// 0804F480: Register ui32 __hash_string(Stack Eq_2 dwArg04)
// Called from:
//      _nl_find_msg
//      _nl_load_domain
//      find_module_idx
ui32 __hash_string(Eq_2 dwArg04)
{
	Eq_2 ecx_11 = dwArg04;
	ui32 eax_18 = 0x00;
l0804F490:
	word32 edx_13 = (word32) *ecx_11;
	while ((byte) edx_13 != 0x00)
	{
		ecx_11 = (word32) ecx_11 + 1;
		eax_18 = (eax_18 << 0x04) + edx_13;
		if ((eax_18 & 0xF0000000) == 0x00)
			goto l0804F490;
		edx_13 = (word32) *ecx_11;
		eax_18 = eax_18 & 0x0FFFFFFF ^ (eax_18 & 0xF0000000) >> 0x18;
	}
	return eax_18;
}

// 0804F4C0: Register word32 _setjmp(Register word32 ebx, Register word32 ebp, Register word32 esi, Register word32 edi, Register (ptr32 Eq_9995) gs, Stack word32 dwArg00, Stack (ptr32 Eq_9997) dwArg04)
// Called from:
//      __libc_start_main
word32 _setjmp(word32 ebx, word32 ebp, word32 esi, word32 edi, struct Eq_9995 * gs, word32 dwArg00, struct Eq_9997 * dwArg04)
{
	dwArg04->dw0000 = ebx;
	dwArg04->dw0004 = esi;
	dwArg04->dw0008 = edi;
	dwArg04->t0010 = __rol(fp + 0x04 ^ gs->dw0018, 0x09);
	dwArg04->t0014 = __rol(dwArg00 ^ gs->dw0018, 0x09);
	dwArg04->dw000C = ebp;
	dwArg04->dw0018 = 0x00;
	dwArg04->dw0028 = 0x00;
	return 0x00;
}

// 0804F510: void msort_with_tmp.part.0(Register (ptr32 Eq_10043) eax, Register Eq_2 ecx, Register Eq_2 edx)
// Called from:
//      msort_with_tmp.part.0
//      qsort_r
void msort_with_tmp.part.0(struct Eq_10043 * eax, Eq_2 ecx, Eq_2 edx)
{
	Eq_2 edi_27 = ecx - (ecx >> 0x01);
	Eq_10050 dwLoc44_557 = ecx >> 0x01;
	Eq_2 dwLoc48_558 = edi_27;
	Eq_2 ebp_119 = (word32) edx + eax->t0000 *s (ecx >> 0x01);
	if (ecx > 0x03)
		msort_with_tmp.part.0(eax, ecx >> 0x01, edx);
	if (edi_27 > 0x01)
		msort_with_tmp.part.0(eax, edi_27, ebp_119);
	Eq_2 dwLoc34_572;
	Eq_2 esi_101;
	word32 edx_66 = eax->dw000C;
	Eq_10050 ecx_105 = SEQ(SLICE(edi_27, word24, 8), (int8) (edi_27 != 0x00));
	Eq_2 edx_107 = SEQ(SLICE(edx_66, word24, 8), (int8) (ecx >> 0x01 != 0x00)) & ecx_105;
	Eq_2 edx_61 = eax->t0000;
	<anonymous> * ecx_62 = eax->ptr0008;
	Eq_2 edi_104 = eax->t0010;
	word32 eax_70 = eax->dw0004;
	byte dl_86 = (byte) edx_107;
	if (eax_70 != 0x01)
	{
		Eq_2 ebp_155;
		Eq_2 esi_151;
		if (eax_70 == 0x00)
		{
			if (dl_86 == 0x00)
			{
				dwLoc34_572 = edx;
				goto l0804F626;
			}
			esi_151 = edx;
			Eq_2 edi_154 = ebp_119;
			ebp_155 = edi_104;
			do
			{
				word32 eax_184;
				int32 eax_176;
				ecx_62();
				if (eax_176 <= 0x00)
				{
					eax_184 = (word32) *esi_151;
					--dwLoc44_557;
					esi_151 = (word32) esi_151 + 4;
				}
				else
				{
					--dwLoc48_558;
					eax_184 = (word32) *edi_154;
					edi_154 = (word32) edi_154 + 4;
				}
				*ebp_155 = eax_184;
				ecx_105 = dwLoc44_557;
				ebp_155 = (word32) ebp_155 + 4;
				if (dwLoc44_557 == 0x00)
					break;
				edx_107 = dwLoc48_558;
			} while (dwLoc48_558 != 0x00);
l0804F620:
			dwLoc34_572 = esi_151;
			edi_104 = ebp_155;
			goto l0804F626;
		}
		if (eax_70 == 0x02)
		{
			Eq_2 ecx_210 = ebp_119;
			dwLoc34_572 = edx;
			while (dwLoc44_557 != 0x00 && dwLoc48_558 != 0x00)
			{
				int32 eax_244;
				ecx_62();
				word32 ebp_229 = edi_104 + edx_61;
				Eq_2 esi_236 = dwLoc34_572;
				if (eax_244 > 0x00)
				{
					--dwLoc48_558;
					esi_236 = ecx_210;
					ecx_210 += edx_61;
				}
				else
				{
					--dwLoc44_557;
					dwLoc34_572 += edx_61;
				}
				if (ebp_229 > ebp_229 - edx_61)
				{
					Eq_2 esi_271 = esi_236;
					do
					{
						*edi_104 = *esi_271;
						esi_271 = (word32) esi_271 + 4;
						edi_104 = (word32) edi_104 + 4;
					} while (ebp_229 > edi_104);
				}
				edi_104 = ebp_229;
			}
l0804F626:
			if (dwLoc44_557 == 0x00)
				goto l0804F632;
			goto l0804F6C0;
		}
		if (eax_70 == 0x03)
		{
			dwLoc34_572 = edx;
			if (dl_86 == 0x00)
				goto l0804F626;
			esi_151 = edx;
			Eq_2 edi_389 = ebp_119;
			ebp_155 = edi_104;
			do
			{
				word32 eax_421;
				int32 eax_413;
				ecx_62();
				if (eax_413 <= 0x00)
				{
					eax_421 = (word32) *esi_151;
					--dwLoc44_557;
					esi_151 = (word32) esi_151 + 4;
				}
				else
				{
					--dwLoc48_558;
					eax_421 = (word32) *edi_389;
					edi_389 = (word32) edi_389 + 4;
				}
				*ebp_155 = eax_421;
				ebp_155 = (word32) ebp_155 + 4;
			} while (dwLoc44_557 != 0x00 && dwLoc48_558 != 0x00);
			goto l0804F620;
		}
		esi_101 = edx;
l0804F662:
		if (dwLoc44_557 != 0x00)
		{
			while (dwLoc48_558 != 0x00)
			{
				int32 eax_317;
				ecx_62();
				if (eax_317 <= 0x00)
				{
					esi_101 += edx_61;
					--dwLoc44_557;
					word32 edx_840;
					edi_104 = __mempcpy(edi_104, esi_101, edx_61, out edx_840);
					goto l0804F662;
				}
				ebp_119 += edx_61;
				--dwLoc48_558;
				word32 edx_841;
				edi_104 = __mempcpy(edi_104, ebp_119, edx_61, out edx_841);
				if (dwLoc44_557 == 0x00)
					break;
			}
		}
	}
	else
	{
		dwLoc34_572 = edx;
		esi_101 = edx;
		if (dl_86 == 0x00)
			goto l0804F626;
		do
		{
			word32 eax_118;
			int32 eax_110;
			ecx_62();
			if (eax_110 <= 0x00)
			{
				eax_118 = (word32) *esi_101;
				edx_107 = *((word32) esi_101 + 4);
				esi_101 = (word32) esi_101 + 8;
				--dwLoc44_557;
			}
			else
			{
				ebp_119 = (word32) ebp_119 + 8;
				--dwLoc48_558;
				eax_118 = (word32) *ebp_119;
				edx_107 = *((word32) ebp_119 - 4);
			}
			*edi_104 = eax_118;
			edi_104 = (word32) edi_104 + 8;
			*((word32) edi_104 - 4) = edx_107;
		} while (dwLoc44_557 != 0x00 && dwLoc48_558 != 0x00);
	}
	dwLoc34_572 = esi_101;
	if (dwLoc44_557 == 0x00)
		goto l0804F632;
l0804F6C0:
	word32 ecx_844;
	word32 edx_845;
	memcpy(edi_104, dwLoc34_572, dwLoc44_557 *s edx_61, out ecx_844, out edx_845);
l0804F632:
	word32 edx_843;
	word32 ecx_842;
	memcpy(edx, eax->t0010, (ecx - dwLoc48_558) *s edx_61, out ecx_842, out edx_843);
}

// 0804F890: void qsort_r(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      qsort
void qsort_r(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	byte bArg0C_588 = (byte) dwArg0C;
	Eq_2 ebx_33;
	struct Eq_10299 * esp_138 = fp - 0x5C;
	byte bLoc50_592 = (byte) dwArg04;
	Eq_2175 eax_26 = gs->t0014;
	if (dwArg0C <= 0x20)
		ebx_33 = dwArg08 *s dwArg0C;
	else
		ebx_33 = (word32) dwArg0C + dwArg08 * 0x08;
	Eq_2 dwLoc58_559;
	Eq_2 dwLoc24_577;
	if (ebx_33 > 0x03FF)
	{
		Eq_10314 ecx_101 = pagesize.8656;
		if (ecx_101 == 0x00)
		{
			word32 ebp_852;
			word32 esi_853;
			word32 ebx_851;
			Eq_10314 eax_56 = __sysconf(gs, 0x55, out ebx_851, out ebp_852, out esi_853);
			Eq_10418 edx_61 = 0x1FFFFFFF;
			if (eax_56 != ~0x00)
			{
				Eq_10314 edx_66 = (word32) eax_56.u0 + 3;
				if (eax_56 >= 0x00)
					edx_66 = eax_56;
				edx_61 = edx_66 >> 0x02;
			}
			phys_pages.8655 = edx_61;
			word32 ebx_874;
			word32 esi_876;
			word32 ebp_875;
			Eq_10314 eax_95 = __sysconf(gs, 0x1E, out ebx_874, out ebp_875, out esi_876);
			pagesize.8656 = eax_95;
			ecx_101 = eax_95;
		}
		if ((uint32) ((uint64) ebx_33 /u ecx_101) <= phys_pages.8655)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 ecx_123 = gs->tFFFFFFE0;
			Eq_2 stackArg0 = <invalid>;
			word32 edx_857;
			word32 esi_860;
			word32 edi_861;
			word32 ebx_858;
			word32 ebp_859;
			word32 ecx_856;
			Eq_2 eax_132 = __libc_malloc(gs, stackArg0, ebx_33, out ecx_856, out edx_857, out ebx_858, out ebp_859, out esi_860, out edi_861);
			gs->tFFFFFFE0 = ecx_123;
			esp_138 = fp - 0x5C;
			dwLoc58_559 = eax_132;
			if (eax_132 != 0x00)
			{
				dwLoc24_577 = eax_132;
				goto l0804F985;
			}
		}
		word32 edx_854;
		_quicksort(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, out edx_854);
		goto l0804FB0D;
	}
	else
	{
		Eq_10319 ebx_174 = (word32) ebx_33 + 27;
		struct Eq_10299 * edx_178 = fp - 0x5C - (ebx_174 & ~0x0FFF);
		if (fp - 0x5C != edx_178)
		{
			do
			{
				esp_138 -= 0x1000;
				esp_138->dw0FFC = esp_138->dw0FFC;
			} while (esp_138 != edx_178);
		}
		struct Eq_10329 * eax_193 = ebx_174 & ~0x0F & 0x0FFF;
		if (eax_193 != null)
		{
			esp_138 -= eax_193;
			Mem201[esp_138 - 0x04 + eax_193:word32] = Mem199[esp_138 - 0x04 + eax_193:word32];
		}
		dwLoc58_559.u0 = 0x00;
		dwLoc24_577 = esp_138 + 0x0F & ~0x0F;
l0804F985:
		if (dwArg0C > 0x20)
		{
			Eq_2 edx_273;
			Eq_2 eax_267 = (word32) dwLoc24_577 + dwArg08 * 0x04;
			Eq_2 ebx_268 = (word32) eax_267 + dwArg08 * 0x04;
			if (eax_267 < ebx_268)
			{
				Eq_2 ecx_274 = dwArg04;
				eax_277 = eax_267;
				do
				{
					Eq_2 eax_277;
					eax_277 = (word32) eax_277 + 4;
					*((word32) eax_277 - 4) = ecx_274;
					ecx_274 += dwArg0C;
				} while (ebx_268 > eax_277);
				edx_273 = (word32) dwLoc24_577 + dwArg08 * 0x04;
			}
			else
				edx_273 = eax_267;
			if (dwArg08 > 0x01)
				msort_with_tmp.part.0(fp - 0x34, dwArg08, edx_273);
			else if (dwArg08 == 0x00)
				goto l0804FAFC;
			Eq_2 dwLoc4C_624 = 0x00;
			Eq_2 dwLoc44_625 = dwArg04;
			do
			{
				Eq_2 esi_320 = *((word32) eax_267 + dwLoc4C_624 * 0x04);
				if (esi_320 != dwLoc44_625)
				{
					struct Eq_10500 * esp_325 = esp_138 - (struct Eq_10501 *) 0x04;
					esp_325->tFFFFFFFC = dwArg0C;
					esp_325->tFFFFFFF8 = dwLoc44_625;
					esp_325->tFFFFFFF4 = ebx_268;
					word32 ecx_866;
					word32 edx_867;
					memcpy(esp_325->tFFFFFFF4, esp_325->tFFFFFFF8, esp_325->tFFFFFFFC, out ecx_866, out edx_867);
					Eq_2 ecx_346 = dwLoc44_625;
					Eq_2 ebx_347 = dwLoc4C_624;
					while (true)
					{
						*((word32) eax_267 + ebx_347 * 0x04) = ecx_346;
						struct Eq_10532 * esp_355 = esp_138 - (struct Eq_10533 *) 0x04;
						esp_355->tFFFFFFFC = dwArg0C;
						esp_355->tFFFFFFF8 = esi_320;
						esp_355->tFFFFFFF4 = ecx_346;
						word32 ecx_868;
						word32 edx_869;
						memcpy(esp_355->tFFFFFFF4, esp_355->tFFFFFFF8, esp_355->tFFFFFFFC, out ecx_868, out edx_869);
						Eq_2 eax_359 = (uint32) ((uint64) (esi_320 - dwArg04) /u dwArg0C);
						union Eq_2 * edx_386 = (word32) eax_267 + eax_359 * 0x04;
						ebx_347 = eax_359;
						ecx_346 = esi_320;
						Eq_2 eax_387 = *edx_386;
						if (eax_387 == dwLoc44_625)
							break;
						esi_320 = eax_387;
					}
					*edx_386 = (union Eq_2 *) esi_320;
					esp_355->tFFFFFFFC = dwArg0C;
					esp_355->tFFFFFFF8 = ebx_268;
					esp_355->tFFFFFFF4 = esi_320;
					word32 edx_873;
					word32 ecx_872;
					memcpy(esp_355->tFFFFFFF4, esp_355->tFFFFFFF8, esp_355->tFFFFFFFC, out ecx_872, out edx_873);
				}
				Eq_2 v27_415 = (word32) dwLoc4C_624 + 1;
				dwLoc4C_624 = v27_415;
				dwLoc44_625 += dwArg0C;
			} while (dwArg08 > v27_415);
		}
		else
		{
			if ((bArg0C_588 & 0x03) == 0x00 && ((bLoc50_592 & 0x03) == 0x00 && (dwArg0C != 0x04 && (dwArg0C != 0x08 || (bLoc50_592 & 0x07) != 0x00))))
				;
			if (dwArg08 > 0x01)
				msort_with_tmp.part.0(fp - 0x34, dwArg08, dwArg04);
		}
l0804FAFC:
		esp_138->dwFFFFFFF0 = (word32) dwLoc58_559;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_864;
		word32 edx_865;
		free(gs, stackArg0, stackArg4, out ecx_864, out edx_865);
l0804FB0D:
		if ((eax_26 ^ gs->t0014) == 0x00)
			return;
		word32 ecx_870;
		word32 edx_871;
		__stack_chk_fail(out ecx_870, out edx_871);
		qsort();
	}
}

// 0804FBE0: void qsort()
// Called from:
//      read_alias_file
//      qsort_r
//      _nl_load_locale_from_archive
void qsort()
{
	qsort_r(gs, dwArg04, dwArg08, dwArg0C);
}

// 0804FC10: Register (ptr32 Eq_10655) getenv(Stack Eq_2 dwArg04)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _dl_non_dynamic_init
//      __gconv_load_cache
//      setlocale
//      _nl_find_locale
//      __libc_secure_getenv
union Eq_10655 * getenv(Eq_2 dwArg04)
{
	Eq_2 edi_100 = environ;
	if (edi_100 == 0x00)
		return null;
	word32 eax_25 = (word32) *dwArg04;
	byte al_26 = (byte) eax_25;
	byte ah_108 = SLICE(eax_25, byte, 8);
	if (al_26 == 0x00)
		return null;
	union Eq_10655 * ebx_103 = *edi_100;
	if (*((word32) dwArg04 + 1) == 0x00)
	{
		Eq_10655 ax_145 = SEQ(ah_108 | 0x3D, al_26);
		while (ebx_103 != null)
		{
			if (ax_145 == *ebx_103)
			{
				ebx_103 = (union Eq_10655 *) ((char *) ebx_103 + 2);
				return ebx_103;
			}
			edi_100 = (word32) edi_100 + 4;
			ebx_103 = (union Eq_10655 *) *edi_100;
		}
	}
	else
	{
		word32 ecx_218;
		word32 edx_219;
		Eq_2 eax_53 = strlen(dwArg04, out ecx_218, out edx_219);
		Eq_10655 bp_142 = *dwArg04;
		while (ebx_103 != null)
		{
			if (bp_142 == *ebx_103)
			{
				word32 ecx_220;
				if (strncmp((char *) ebx_103 + 2, (word32) dwArg04 + 2, eax_53 - 0x02, out ecx_220) == 0x00 && Mem84[ebx_103 + eax_53:byte] == 0x3D)
				{
					ebx_103 = ebx_103 + 0x01 + eax_53;
					return ebx_103;
				}
			}
			edi_100 = (word32) edi_100 + 4;
			ebx_103 = (union Eq_10655 *) *edi_100;
		}
	}
	return ebx_103;
}

// 0804FCF0: void __run_exit_handlers(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      exit
void __run_exit_handlers(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, word32 dwArg0C, word32 dwArg10)
{
	byte bLoc20_388 = (byte) dwArg0C;
l0804FD30:
	Eq_2 ecx_206 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_43;
	if (!__cmpxchg(__exit_funcs_lock, 0x01, 0x00, out eax_43))
		ecx_206 = __lll_lock_wait_private(eax_43, 0x080CFED8, gs);
	while (true)
	{
		Eq_2 edx_56 = *dwArg08;
		if (edx_56 == 0x00)
			break;
		do
		{
			Eq_2 edx_105 = edx_56;
			Eq_2 ecx_103 = *((word32) edx_56 + 4);
			if (ecx_103 == 0x00)
			{
				Eq_2 eax_66 = *edx_56;
				*dwArg08 = (union Eq_2 *) eax_66;
				if (eax_66 != 0x00)
					free(gs, dwLoc40, edx_56, out ecx_103, out edx_105);
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v26_97 = __exit_funcs_lock - 0x01;
				__exit_funcs_lock = v26_97;
				if (v26_97 != 0x00)
					__lll_unlock_wake_private(0x080CFED8, ecx_103, edx_105, gs);
				goto l0804FD30;
			}
			word32 ebx_109 = g_dw80CFEE0;
			word32 edi_110 = g_dw80CFEE4;
			*((word32) edx_56 + 4) = ecx_103 - 0x01;
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v16_116 = __exit_funcs_lock - 0x01;
			__exit_funcs_lock = v16_116;
			if (v16_116 != 0x00)
				__lll_unlock_wake_private(0x080CFED8, ecx_103, edx_56, gs);
			struct Eq_10826 * ecx_128 = (word32) edx_56 + (ecx_103 << 0x04);
			word32 eax_130 = ecx_128->dwFFFFFFF8;
			if (eax_130 != 0x03)
			{
				if (eax_130 == 0x04)
				{
					Eq_2 eax_185 = ecx_128->tFFFFFFFC;
					ecx_128->dwFFFFFFF8 = 0x00;
					word32 v19_190 = ecx_128->dw0000;
					<anonymous> * eax_195 = __ror(eax_185, 0x09) ^ gs->t0018;
					eax_195();
				}
				else if (eax_130 == 0x02)
				{
					word32 v23_165 = ecx_128->dw0000;
					<anonymous> * eax_173 = __ror(ecx_128->tFFFFFFFC, 0x09) ^ gs->t0018;
					eax_173();
				}
			}
			else
			{
				<anonymous> * eax_140 = __ror(ecx_128->tFFFFFFFC, 0x09) ^ gs->t0018;
				eax_140();
			}
			ecx_206.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_216;
			if (!__cmpxchg(__exit_funcs_lock, 0x01, 0x00, out eax_216))
				ecx_206 = __lll_lock_wait_private(eax_216, 0x080CFED8, gs);
		} while ((edi_110 ^ g_dw80CFEE4 | ebx_109 ^ g_dw80CFEE0) == 0x00);
	}
	g_b80CF604 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v17_258 = __exit_funcs_lock - 0x01;
	__exit_funcs_lock = v17_258;
	if (v17_258 != 0x00)
		__lll_unlock_wake_private(0x080CFED8, ecx_206, edx_56, gs);
	_exit(gs, dwArg04);
}

// 0804FF10: void exit(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __libc_start_main
void exit(struct Eq_9 * gs, Eq_2 dwArg04)
{
	__run_exit_handlers(gs, dwArg04, &__exit_funcs, 0x01, 0x01);
}

// 0804FF40: Register (ptr32 (arr Eq_2)) __new_exitfn(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      exit
//      __internal_atexit
Eq_2 (* __new_exitfn)[](struct Eq_9 * gs, union Eq_2 * dwArg04, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	struct Eq_10964 * ebx_118 = &g_t80CE000;
	if (g_b80CF604 != 0x00)
	{
l0805002A:
		ecxOut = ecx;
		edxOut = edx;
		return null;
	}
	else
	{
		Eq_2 edi_22 = *dwArg04;
		if (edi_22 == 0x00)
		{
			word32 edx_288;
			word32 ecx_287;
			__assert_fail(out ecx_287, out edx_288);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			Eq_2 edx_45;
			Eq_2 ecx_46;
			Eq_2 (* eax_44)[] = __internal_atexit(gs, dwArg04, stackArg8, stackArg12, out ecx_46, out edx_45);
			ecxOut = ecx_46;
			edxOut = edx_45;
			return eax_44;
		}
		Eq_2 ebp_49 = 0x00;
		Eq_2 esi_129 = edi_22;
		while (true)
		{
			Eq_2 eax_151[];
			Eq_2 eax_55 = *((word32) esi_129 + 4);
			if (eax_55 != 0x00)
			{
				edx = eax_55 - 0x01;
				ecx = *((word32) esi_129 + ((eax_55 - 0x01) * 0x10 + 8));
				if (ecx != 0x00)
				{
					edx = eax_55;
l0804FFC8:
					if (edx != 0x20)
					{
						edx = (word32) edx + 1;
						*((word32) esi_129 + 4) = edx;
						eax_151 = (word32) esi_129 + 8 + (edx << 0x04);
						goto l0804FFDC;
					}
					esi_129 = ebp_49;
					if (ebp_49 != 0x00)
					{
l0805001E:
						((word32) esi_129 + 4)->u0 = 0x01;
						eax_151 = (word32) esi_129 + 8;
l0804FFDC:
						eax_151[0].u0 = 0x01;
						up32 v14_168 = ebx_118->dw1EE0 + 0x01;
						ebx_118->dw1EE0 = v14_168;
						ebx_118->dw1EE4 += (word32) (v14_168 < 0x00);
						ecxOut = ecx;
						edxOut = edx;
						return eax_151;
					}
					Eq_2 edi_120;
					word32 ebp_289;
					word32 esi_290;
					Eq_2 eax_116 = __libc_calloc(gs, 0x01, 0x0208, out ecx, out edx, out ebx_118, out ebp_289, out esi_290, out edi_120);
					esi_129 = eax_116;
					if (eax_116 != 0x00)
					{
						*eax_116 = edi_120;
						*dwArg04 = (union Eq_2 *) eax_116;
						goto l0805001E;
					}
					goto l0805002A;
				}
				while (edx != 0x00)
				{
					ecx = edx - 0x01;
					if (*((word32) esi_129 + (ecx * 0x10 + 8)) != 0x00)
						goto l0804FFC8;
					edx = ecx;
				}
			}
			Eq_2 eax_82 = *esi_129;
			((word32) esi_129 + 4)->u0 = 0x00;
			ebp_49 = esi_129;
			if (eax_82 == 0x00)
				goto l0805001E;
			esi_129 = eax_82;
		}
	}
}

// 08050050: Register word32 __internal_atexit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __new_exitfn
//      __cxa_atexit
word32 __internal_atexit(struct Eq_9 * gs, union Eq_2 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_20;
	if (!__cmpxchg(__exit_funcs_lock, 0x01, 0x00, out eax_20))
		__lll_lock_wait_private(eax_20, 0x080CFED8, gs);
	word32 eax_122;
	Eq_2 ecx_41;
	Eq_2 edx_126;
	struct Eq_11126 * eax_40 = __new_exitfn(gs, dwArg10, out ecx_41, out edx_126);
	if (eax_40 != null)
	{
		eax_40->dw0000 = 0x04;
		eax_40->t0004 = __rol(dwArg04 ^ gs->t0018, 0x09);
		eax_40->t0008 = dwArg08;
		eax_40->t000C = dwArg0C;
		edx_126 = dwArg0C;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_76 = __exit_funcs_lock - 0x01;
		__exit_funcs_lock = v14_76;
		if (v14_76 != 0x00)
			__lll_unlock_wake_private(0x080CFED8, ecx_41, dwArg0C, gs);
		eax_122 = 0x00;
	}
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_52 = __exit_funcs_lock - 0x01;
		__exit_funcs_lock = v15_52;
		if (v15_52 != 0x00)
			__lll_unlock_wake_private(0x080CFED8, ecx_41, edx_126, gs);
		eax_122 = ~0x00;
	}
	ecxOut = ecx_41;
	edxOut = edx_126;
	return eax_122;
}

// 08050100: Register (ptr32 (arr Eq_2)) __cxa_atexit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
Eq_2 (* __cxa_atexit)[](struct Eq_9 * gs, union Eq_2 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_22;
	ptr32 edx_23;
	Eq_2 (* eax_21)[] = __internal_atexit(gs, dwArg04, dwArg08, dwArg0C, out ecx_22, out edx_23);
	ecxOut = ecx_22;
	edxOut = edx_23;
	return eax_21;
}

// 08050130: void __strtoul_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10)
void __strtoul_internal(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10)
{
	word32 ecx_48;
	word32 edx_49;
	____strtoul_l_internal(gs, dwArg04, dwArg08, dwArg0C, dwArg10, gs->ptrFFFFFFD4, out ecx_48, out edx_49);
}

// 08050170: Register word32 __strtoul(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_9921) ecxOut, Register out Eq_9922 edxOut)
// Called from:
//      __gettext_extract_plural
//      get_nprocs
//      get_nprocs_conf
//      __readonly_area
word32 __strtoul(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_9921 & ecxOut, union Eq_9922 & edxOut)
{
	Eq_9922 edx_26;
	struct Eq_9921 * ecx_27;
	word32 eax_25 = ____strtoul_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, gs->ptrFFFFFFD4, out ecx_27, out edx_26);
	ecxOut = ecx_27;
	edxOut = edx_26;
	return eax_25;
}

// 080501B0: Register Eq_2 ____strtoul_l_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_11223) dwArg14, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __strtoul_internal
//      __strtoul
//      __strtoul_l
Eq_2 ____strtoul_l_internal(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10, struct Eq_11223 * dwArg14, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 ebp_212 = 0x00;
	Eq_2 dwLoc48_1098 = 0x00;
	if (dwArg10 != 0x00)
	{
		edx = dwArg14->t0004;
		Eq_2 eax_28 = *((word32) edx + 44);
		dwLoc48_1098 = eax_28;
		if (*eax_28 <= 0x7E && *eax_28 >= 0x01)
		{
			ebp_212 = *((word32) edx + 40);
			if (*ebp_212 == 0x00)
			{
				dwLoc48_1098.u0 = 0x00;
				ebp_212.u0 = 0x00;
			}
		}
		else
			dwLoc48_1098.u0 = 0x00;
	}
	Eq_2 eax_1104;
	if (dwArg0C == 0x01 || dwArg0C > 0x24)
	{
		gs->tFFFFFFE0.u0 = 22;
		eax_1104.u0 = 0x00;
		goto l080503A3;
	}
	int32 edx_66 = (int32) *dwArg04;
	Eq_2 esi_63 = dwArg04;
	ecx = dwArg14->t0034;
	byte al_80 = (byte) edx_66;
	if ((*((word32) ecx + (edx_66 * 0x02 + 1)) & 0x20) != 0x00)
	{
		do
		{
			esi_63 = (word32) esi_63 + 1;
			int32 edx_74 = (int32) *esi_63;
			al_80 = (byte) edx_74;
		} while ((*((word32) ecx + (edx_74 * 0x02 + 1)) & 0x20) != 0x00);
	}
	if (al_80 == 0x00)
	{
		edx = dwArg08;
		if (dwArg08 == 0x00)
		{
			eax_1104.u0 = 0x00;
			goto l080503A3;
		}
		goto l0805053C;
	}
	word32 dwLoc24_1049;
	Eq_2 esi_107;
	if (al_80 != 0x2D)
	{
		dwLoc24_1049 = 0x00;
		esi_107 = (word32) esi_63 + (word32) (al_80 == 0x2B);
	}
	else
	{
		esi_107 = (word32) esi_63 + 1;
		dwLoc24_1049 = 0x01;
	}
	Eq_11402 bLoc30_1096;
	Eq_2 dwLoc44_1089;
	Eq_3803 (* dwLoc34_1083)[];
	Eq_2 edi_129;
	Eq_11351 eax_127;
	Eq_2 ecx_111 = (word32) *esi_107;
	byte cl_112 = (byte) ecx_111;
	if (cl_112 != 0x30)
	{
		if (dwArg0C != 0x00 && dwArg0C != 0x0A)
		{
			edi_129.u0 = 0x00;
			dwLoc48_1098.u0 = 0x00;
			eax_127 = dwArg0C - 0x02;
			goto l08050274;
		}
		if (dwLoc48_1098 == 0x00)
		{
			dwArg0C.u0 = 0x0A;
			eax_127.u0 = 0x08;
			edi_129.u0 = 0x00;
			goto l08050274;
		}
l080504C0:
		word32 ecx_1187;
		word32 edx_1188;
		Eq_2 eax_216 = strlen(ebp_212, out ecx_1187, out edx_1188);
		edx = eax_216;
		if (eax_216 == 0x00)
			goto l0805050D;
		byte al_232 = *ebp_212.u0;
		if (cl_112 == al_232)
		{
			Eq_2 eax_237 = 0x00;
			do
			{
				eax_237 = (word32) eax_237 + 1;
				if (eax_216 == eax_237)
					goto l0805050D;
			} while (Mem233[ebp_212 + eax_237:byte] == Mem233[esi_107 + eax_237:byte]);
		}
		ui32 ebx_254 = (word32) cl_112;
		Eq_2 edx_259 = esi_107;
		if ((byte) ebx_254 != 0x00)
		{
			edx_259 = esi_107;
			word32 edi_273 = (word32) al_232;
			Eq_2 ecx_274 = g_t80CE08C;
			Eq_3803 eax_275[] = g_ptr80CE084;
			do
			{
				if ((byte) ebx_254 > 0x39)
				{
					byte cl_292 = (byte) edi_273;
					Eq_2 eax_286 = 0x00;
					while (Mem278[edx_259 + eax_286:byte] == cl_292)
					{
						eax_286 = (word32) eax_286 + 1;
						if (eax_216 == eax_286)
							goto l08050690;
						cl_292 = Mem278[ebp_212 + eax_286:byte];
					}
					if (eax_216 > eax_286 && ((*((word32) ecx_274 + (ebx_254 * 0x02 + 1)) & 0x04) == 0x00 || eax_275[ebx_254] > 0x40))
						break;
				}
l08050690:
				edx_259 = (word32) edx_259 + 1;
				ebx_254 = (word32) *edx_259;
			} while ((byte) ebx_254 != 0x00);
		}
		Eq_2 eax_347 = __correctly_grouped_prefixmb(esi_107, edx_259, ebp_212, dwLoc48_1098);
		edi_129 = eax_216;
		ecx_111 = (word32) *esi_107;
		dwLoc48_1098 = eax_347;
		eax_127.u0 = 0x08;
		dwArg0C.u0 = 0x0A;
l08050274:
		edx = *((char *) g_a80B1C40 + eax_127 * 0x04);
		dwLoc44_1089 = edx;
		bLoc30_1096 = Mem366[0x080B1C00<p32> + eax_127:byte];
		ecx = ecx_111;
		if ((byte) ecx_111 == 0x00 || dwLoc48_1098 == esi_107)
			goto l0805050D;
		goto l080502A1;
	}
	if ((dwArg0C & ~0x10) == 0x00)
	{
		Eq_3803 eax_120[] = g_ptr80CE084;
		dwLoc34_1083 = eax_120;
		if (eax_120[(int32) *((word32) esi_107 + 1)] == 88)
		{
			ecx_111 = (word32) *((word32) esi_107 + 2);
			eax_127.u0 = 0x0E;
			esi_107 = (word32) esi_107 + 2;
			edi_129.u0 = 0x00;
			dwArg0C.u0 = 0x10;
			dwLoc48_1098.u0 = 0x00;
			goto l08050274;
		}
		if (dwArg0C == 0x00)
		{
			dwArg0C.u0 = 0x08;
			ecx.u0 = 0x30;
			dwLoc48_1098.u0 = 0x00;
			dwLoc44_1089 = g_t80B1C58;
			edi_129.u0 = 0x00;
			bLoc30_1096 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&g_t80B1C06.a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			goto l080502AF;
		}
	}
	if (dwArg0C == 0x0A)
	{
		if (dwLoc48_1098 == 0x00)
		{
			ecx.u0 = 0x30;
			dwLoc44_1089 = g_t80B1C60;
			edi_129.u0 = 0x00;
			bLoc30_1096 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&g_t80B1C08.a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
l080502A1:
			dwLoc34_1083 = g_ptr80CE084;
			goto l080502AF;
		}
		goto l080504C0;
	}
	ecx.u0 = 0x30;
	dwLoc48_1098.u0 = 0x00;
	dwLoc44_1089 = *((char *) g_a80B1C38 + dwArg0C * 0x04);
	bLoc30_1096 = (Eq_11402) *((byte) dwArg0C.u0 + 0x080B1BFE);
	edi_129.u0 = 0x00;
	dwLoc34_1083 = g_ptr80CE084;
l080502AF:
	int32 edx_395 = edi_129 - 0x01;
	Eq_2 ebx_398 = esi_107;
	word32 dwLoc40_781 = 0x00;
	Eq_2 eax_402 = g_t80CE08C;
	Eq_2 eax_1105 = 0x00;
	do
	{
		Eq_2 edx_1182 = ecx - 0x30;
		byte cl_417 = (byte) ecx;
		if ((byte) edx_1182 > 0x09)
		{
			if (edi_129 == 0x00)
			{
l08050310:
				edx = eax_402;
				if ((*((word32) eax_402 + (ecx * 0x02 + 1)) & 0x04) == 0x00)
					break;
				Eq_3803 edx_453 = dwLoc34_1083[ecx];
				edx_1182 = SEQ(SLICE(edx_453 - 55, word24, 8), (byte) edx_453 - 55);
				goto l08050325;
			}
			Eq_2 edx_420 = 0x00;
			do
			{
				if (Mem419[ebp_212 + edx_420:byte] != Mem419[ebx_398 + edx_420:byte])
				{
					ecx = (word32) cl_417;
					if (edi_129 == edx_420)
						break;
					goto l08050310;
				}
				edx_420 = (word32) edx_420 + 1;
			} while (edx_420 != edi_129);
			edx = (word32) ebx_398 + edx_395;
			goto l080502EF;
		}
l08050325:
		Eq_11402 dl_456 = (byte) edx_1182;
		ecx = (word32) dl_456;
		edx = edx_1182;
		if (ecx >= dwArg0C)
			break;
		if (eax_1105 > dwLoc44_1089 || eax_1105 == dwLoc44_1089 && dl_456 > bLoc30_1096)
		{
			ecx = (word32) *((word32) ebx_398 + 1);
			edx = ebx_398;
			dwLoc40_781 = 0x01;
			ebx_398 = (word32) ebx_398 + 1;
			if ((byte) ecx == 0x00)
				break;
		}
		else
		{
			edx = ebx_398;
			eax_1105 = (word32) ecx + eax_1105 *s dwArg0C;
l080502EF:
			ecx = (word32) *((word32) edx + 1);
			ebx_398 = (word32) edx + 1;
			if ((byte) ecx == 0x00)
				break;
		}
	} while (ebx_398 != dwLoc48_1098);
	if (ebx_398 != esi_107)
	{
		if (dwArg08 != 0x00)
			*dwArg08 = ebx_398;
		if (dwLoc40_781 == 0x00)
		{
			Eq_2 edx_619 = -eax_1105;
			if (dwLoc24_1049 != 0x00)
				eax_1105 = edx_619;
			ecxOut = ecx;
			edxOut = edx_619;
			return eax_1105;
		}
		gs->tFFFFFFE0.u0 = 0x22;
		eax_1104.u0 = ~0x00;
l080503A3:
		ecxOut = ecx;
		edxOut = edx;
		return eax_1104;
	}
l0805050D:
	ecx = dwArg08;
	if (dwArg08 != 0x00)
	{
		if (esi_107 - dwArg04 <= 0x01)
		{
l0805053C:
			*dwArg08 = dwArg04;
			eax_1104.u0 = 0x00;
			goto l080503A3;
		}
		edx = (int32) *((word32) esi_107 - 1);
		if (g_ptr80CE084[edx] != 88 || *((word32) esi_107 - 2) != 0x30)
			goto l0805053C;
		*dwArg08 = esi_107 - 0x01;
	}
	eax_1104.u0 = 0x00;
	goto l080503A3;
}

// 08050710: void __strtoul_l(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack (ptr32 Eq_11223) dwArg10)
void __strtoul_l(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_11223 * dwArg10)
{
	word32 ecx_44;
	word32 edx_45;
	____strtoul_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, dwArg10, out ecx_44, out edx_45);
}

// 08050740: Register Eq_2 __correctly_grouped_prefixmb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      ____strtoul_l_internal
//      ____strtol_l_internal
Eq_2 __correctly_grouped_prefixmb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 != 0x00)
	{
		word32 edx_768;
		word32 ecx_767;
		Eq_2 eax_26 = strlen(dwArg0C, out ecx_767, out edx_768);
		if (dwArg08 > dwArg04)
		{
l08050784:
			Eq_2 eax_45 = dwArg08 - 0x01;
			if (dwArg04 <= dwArg08 - 0x01)
			{
				byte bl_52 = *dwArg0C;
				do
				{
					if (*((word32) eax_26 + (eax_45 - 0x01)) == bl_52)
					{
						Eq_11702 dl_65 = *((word32) dwArg0C + 1);
						if (dl_65 != 0x00)
						{
							if (Mem54[eax_45 - 0x02 + eax_26:byte] == dl_65)
							{
								byte * edx_71 = (word32) dwArg0C + 2;
								byte * ebx_73 = (word32) eax_45 + (eax_26 - 0x03);
								do
								{
									byte cl_78 = *edx_71;
									if (cl_78 == 0x00)
										goto l08050806;
									++edx_71;
									ebx_73 = ebx_769 - 0x01;
									ebx_769 = ebx_73;
								} while (*ebx_769 == cl_78);
							}
							goto l080507B0;
						}
l08050806:
						Eq_2 eax_102 = eax_45;
						if (dwArg04 > eax_45)
							return dwArg08;
						Eq_11780 (* edx_107)[] = (int32) *dwArg10;
						Eq_11780 (* ecx_108)[] = dwArg08 - eax_45;
						if (ecx_108 != edx_107 + 0x01)
						{
							word32 ebx_295 = eax_45 + (edx_107 + 0x01);
							if (ecx_108 > edx_107 + 0x01)
								eax_102 = ebx_295;
							dwArg08 = eax_102;
							goto l0805082A;
						}
						Eq_2 edi_130;
						ci8 al_131;
						Eq_2 eax_114 = eax_45 - (Eq_11780 (*)[]) 0x01;
						ci8 al_119 = *((word32) dwArg10 + 1);
						Eq_2 dwLoc28_390 = dwArg10;
						Eq_2 edi_113 = dwArg10;
						Eq_2 dwLoc2C_391 = eax_114;
						word32 esi_116 = (word32) bl_52;
						ci8 bLoc2D_395 = al_119;
						if (al_119 != 0x00)
						{
l08050890:
							al_131 = bLoc2D_395;
							dwLoc28_390 = (word32) edi_113 + 1;
							edi_130 = dwLoc2C_391;
							if (bLoc2D_395 != 0x7F)
								goto l080508A8;
						}
						else
						{
l08050930:
							ci8 al_224 = *dwLoc28_390;
							edi_130 = dwLoc2C_391;
							bLoc2D_395 = al_224;
							al_131 = al_224;
							if (al_224 != 0x7F)
							{
l080508A8:
								if (al_131 >= 0x00)
								{
									if (dwArg04 > dwLoc2C_391)
										return dwArg08;
									edi_130 = dwLoc2C_391;
									do
									{
										Eq_11780 al_148 = (byte) esi_116;
										if (al_148 == 0x00)
										{
l080508F8:
											if (dwArg04 > edi_130)
												break;
											if (dwLoc2C_391 - edi_130 != (int32) bLoc2D_395)
												goto l080509C8;
l08050915:
											ci8 al_214 = *((word32) dwLoc28_390 + 1);
											edi_113 = dwLoc28_390;
											dwLoc2C_391 = edi_130 - (Eq_11780 (*)[]) 0x01;
											bLoc2D_395 = al_214;
											if (al_214 == 0x00)
												goto l08050930;
											goto l08050890;
										}
										if (al_148 == Mem139[(edi_130 - 0x01) + eax_26:byte])
										{
											byte * eax_160 = (word32) dwArg0C + 1;
											word32 ecx_162 = edi_130 + (eax_26 - 0x02);
											do
											{
												Eq_11780 dl_166 = *eax_160;
												if (dl_166 == 0x00)
													goto l080508F8;
												++eax_160;
												ecx_162 = ecx_770 - 0x01;
												ecx_770 = ecx_162;
											} while (ecx_770[0].t0000 == dl_166);
										}
										edi_130 -= (Eq_11780 (*)[]) 0x01;
									} while (edi_130 != dwArg04 - 0x01);
									if ((int32) bLoc2D_395 >= dwLoc2C_391 - edi_130)
										return dwArg08;
l080509C8:
									dwArg08 = eax_114;
l0805082A:
									if (dwArg04 >= dwArg08)
										goto l08050838;
									goto l08050784;
								}
							}
						}
						if (dwArg04 > dwLoc2C_391)
							return dwArg08;
						do
						{
							Eq_11780 al_242 = (byte) esi_116;
							if (al_242 == 0x00)
							{
l08050994:
								if (dwArg04 > edi_130)
									return dwArg08;
								goto l08050915;
							}
							if (al_242 == Mem231[(edi_130 - 0x01) + eax_26:byte])
							{
								byte * eax_254 = (word32) dwArg0C + 1;
								word32 ecx_256 = edi_130 + (eax_26 - 0x02);
								do
								{
									Eq_11780 dl_260 = *eax_254;
									if (dl_260 == 0x00)
										goto l08050994;
									++eax_254;
									ecx_256 = ecx_771 - 0x01;
									ecx_771 = ecx_256;
								} while (ecx_771[0].t0000 == dl_260);
							}
							edi_130 -= (Eq_11780 (*)[]) 0x01;
						} while (edi_130 != dwArg04 - 0x01);
						return dwArg08;
					}
l080507B0:
					--eax_45;
				} while (eax_45 != dwArg04 - 0x01);
			}
		}
		else
		{
l08050838:
			Eq_2 eax_310 = dwArg08;
			if (dwArg08 < dwArg04)
				eax_310 = dwArg04;
			dwArg08 = eax_310;
		}
	}
	return dwArg08;
}

// 08050A00: Register word32 _IO_printf(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      main
word32 _IO_printf(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 ebp_22;
	word32 ecx_41;
	word32 edx_42;
	word32 ebx_43;
	word32 edi_44;
	vfprintf(ebx, gs, _IO_stdout, dwArg04, fp + 0x08, out ecx_41, out edx_42, out ebx_43, out ebp_22, out edi_44);
	return ebp_22;
}

// 08050A30: Register word32 ___asprintf()
// Called from:
//      __assert_fail_base
//      __dcigettext
//      __dlerror
word32 ___asprintf()
{
	return vasprintf(gs, dwArg04);
}

// 08050A60: Register Eq_2 locked_vfxprintf(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_11914 ebxOut, Register out Eq_952 ediOut)
// Called from:
//      __fxprintf
//      __fxprintf_nocancel
Eq_2 locked_vfxprintf(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_11914 & ebxOut, union Eq_952 & ediOut)
{
	Eq_2 eax_157;
	Eq_2175 eax_27 = gs->t0014;
	if (*((word32) eax + 0x0068) <= 0x00)
	{
		word32 ebx_396;
		word32 edi_398;
		word32 ebp_397;
		word32 edx_395;
		word32 ecx_394;
		eax_157 = vfprintf(0x080CE000, gs, eax, edx, ecx, out ecx_394, out edx_395, out ebx_396, out ebp_397, out edi_398);
		goto l08050B3D;
	}
	word32 edx_400;
	word32 ecx_399;
	Eq_2 eax_52 = strlen(edx, out ecx_399, out edx_400);
	if (eax_52 > 0x3FFFFFFE)
	{
		gs->tFFFFFFE0.u0 = 0x4B;
		eax_157.u0 = ~0x00;
		goto l08050B3D;
	}
	Eq_2 ecx_66 = ((word32) eax_52 + 1) * 0x04;
	up32 eax_72 = __libc_alloca_cutoff(gs, ecx_66);
	struct Eq_11962 * esp_169 = fp - 0x3C;
	if (ecx_66 > 0x1000 && eax_72 == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_403;
		word32 edi_407;
		word32 esi_406;
		word32 ecx_402;
		word32 ebp_405;
		word32 ebx_404;
		Eq_2 eax_89 = __libc_malloc(gs, stackArg0, ecx_66, out ecx_402, out edx_403, out ebx_404, out ebp_405, out esi_406, out edi_407);
		if (eax_89 != 0x00)
		{
			word32 ecx_418;
			Eq_2 eax_111 = __mbsrtowcs(gs, fp - 0x28, out ecx_418);
			if (eax_111 != ~0x00)
			{
				word32 ecx_422;
				word32 edx_423;
				eax_111 = __vfwprintf(gs, eax, eax_89, ecx, out ecx_422, out edx_423);
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_420;
			word32 edx_421;
			free(gs, stackArg0, eax_89, out ecx_420, out edx_421);
			eax_157 = eax_111;
l08050B3D:
			Eq_11914 ebx_268 = eax_27 ^ gs->t0014;
			if (ebx_268 != 0x00)
			{
				word32 ecx_415;
				word32 edx_416;
				__stack_chk_fail(out ecx_415, out edx_416);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 eax_291 = __fxprintf(gs, stackArg4);
				ebxOut = ebx_268;
				ediOut.u0 = <invalid>;
				return eax_291;
			}
			else
			{
				ebxOut = ebx;
				ediOut.u0 = <invalid>;
				return eax_157;
			}
		}
	}
	else
	{
		struct Eq_11962 * edx_164 = fp - 0x3C - ((word32) ecx_66 + 27 & ~0x0FFF);
		ui32 eax_165 = (word32) ecx_66 + 27 & ~0x0F;
		if (fp - 0x3C != edx_164)
		{
			do
			{
				esp_169 -= 0x1000;
				esp_169->dw0FFC = esp_169->dw0FFC;
			} while (esp_169 != edx_164);
		}
		if ((eax_165 & 0x0FFF) != 0x00)
		{
			esp_169 -= eax_165 & 0x0FFF;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_169 - 0x04)[(eax_165 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_169 - 0x04)[(eax_165 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_12026 * esp_200 = esp_169 - 4;
		esp_200->ptr0000 = fp - 0x28;
		esp_200->tFFFFFFFC = (word32) eax_52 + 1;
		esp_200->tFFFFFFF8 = fp - 0x30;
		Eq_12043 ecx_193 = (char *) esp_169 + 0x0F;
		esp_200->tFFFFFFF4 = ecx_193 & ~0x0F;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg16 = <invalid>;
		word32 ecx_409;
		if (__mbsrtowcs(gs, stackArg16, out ecx_409) != ~0x00)
		{
			esp_200->tFFFFFFFC = ecx;
			esp_200->tFFFFFFF8 = ecx_193 & ~0x0F;
			esp_200->tFFFFFFF4 = eax;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			word32 ecx_413;
			word32 edx_414;
			eax_157 = __vfwprintf(gs, stackArg4, stackArg8, stackArg12, out ecx_413, out edx_414);
			goto l08050B3D;
		}
	}
	eax_157.u0 = ~0x00;
	goto l08050B3D;
}

// 08050C20: Register Eq_2 __fxprintf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __assert_fail_base
//      locked_vfxprintf
//      __malloc_assert
Eq_2 __fxprintf(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ebx_15 = dwArg04;
	if (dwArg04 == 0x00)
		ebx_15 = _IO_stderr;
	ui32 eax_23 = *ebx_15;
	if ((eax_23 & 0x8000) == 0x00)
	{
		Eq_2 edx_30 = *((word32) ebx_15 + 72);
		Eq_2 edi_33 = gs->t0008;
		if (*((word32) edx_30 + 8) != edi_33)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_43;
			if (!__cmpxchg(*edx_30, 0x01, eax_23 & 0x8000, out eax_43))
				__lll_lock_wait_private(eax_43, edx_30, gs);
			edx_30 = *((word32) ebx_15 + 72);
			*((word32) edx_30 + 8) = edi_33;
		}
		*((word32) edx_30 + 4) = (word32) *((word32) edx_30 + 4) + 1;
	}
	word32 ebx_178;
	word32 edi_179;
	Eq_2 eax_90 = locked_vfxprintf(ebx_15, fp + 0x0C, dwArg08, gs, out ebx_178, out edi_179);
	if ((*ebx_15 & 0x8000) == 0x00)
	{
		Eq_2 edx_98 = *((word32) ebx_15 + 72);
		Eq_2 v15_99 = *((word32) edx_98 + 4) - 0x01;
		*((word32) edx_98 + 4) = v15_99;
		if (v15_99 == 0x00)
		{
			((word32) edx_98 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v16_108 = *edx_98 - 0x01;
			*edx_98 = v16_108;
			if (v16_108 != 0x00)
				__lll_unlock_wake_private(edx_98, eax_90, edx_98, gs);
		}
	}
	return eax_90;
}

// 08050CE0: void __fxprintf_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void __fxprintf_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebx_15 = dwArg04;
	if (dwArg04 == 0x00)
		ebx_15 = _IO_stderr;
	ui32 eax_23 = *ebx_15;
	if ((eax_23 & 0x8000) == 0x00)
	{
		Eq_2 edx_30 = *((word32) ebx_15 + 72);
		Eq_2 edi_33 = gs->t0008;
		if (*((word32) edx_30 + 8) != edi_33)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_43;
			if (!__cmpxchg(*edx_30, 0x01, eax_23 & 0x8000, out eax_43))
				__lll_lock_wait_private(eax_43, edx_30, gs);
			edx_30 = *((word32) ebx_15 + 72);
			*((word32) edx_30 + 8) = edi_33;
		}
		*((word32) edx_30 + 4) = (word32) *((word32) edx_30 + 4) + 1;
	}
	*((word32) ebx_15 + 60) |= 0x02;
	struct Eq_12265 * ebx_90;
	word32 edi_92;
	Eq_2 eax_88 = locked_vfxprintf(ebx_15, fp + 0x0C, dwArg08, gs, out ebx_90, out edi_92);
	ebx_90->dw003C = edi_92;
	if ((ebx_90->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_105 = ebx_90->t0048;
		Eq_2 v15_106 = *((word32) edx_105 + 4) - 0x01;
		*((word32) edx_105 + 4) = v15_106;
		if (v15_106 == 0x00)
		{
			((word32) edx_105 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v16_115 = *edx_105 - 0x01;
			*edx_105 = v16_115;
			if (v16_115 != 0x00)
				__lll_unlock_wake_private(edx_105, eax_88, edx_105, gs);
		}
	}
}

// 08050DB0: void __new_fclose(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      read_alias_file
//      __gconv_read_conf
//      __readonly_area
void __new_fclose(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ecx_134;
	ui32 eax_21 = *dwArg04;
	if ((SLICE(eax_21, byte, 8) & 0x20) == 0x00)
	{
		ecx_134 = eax_21 & 0x8000;
		if ((eax_21 & 0x8000) != 0x00)
			goto l08050DE6;
	}
	else
	{
		_IO_un_link(dwArg04);
		eax_21 = (ui32) *dwArg04;
		if ((SLICE(eax_21, byte, 8) & 0x80) != 0x00)
			goto l08050EBC;
	}
	Eq_2 edx_48 = *((word32) dwArg04 + 72);
	Eq_2 ebx_51 = gs->t0008;
	if (*((word32) edx_48 + 8) != ebx_51)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_62;
		if (!__cmpxchg(*edx_48, 0x01, 0x00, out eax_62))
			__lll_lock_wait_private(eax_62, edx_48, gs);
		edx_48 = *((word32) dwArg04 + 72);
		eax_21 = (ui32) *dwArg04;
		*((word32) edx_48 + 8) = ebx_51;
	}
	*((word32) edx_48 + 4) = (word32) *((word32) edx_48 + 4) + 1;
l08050EBC:
	ecx_134 = eax_21 & 0x8000;
	if ((SLICE(eax_21, byte, 8) & 0x20) != 0x00)
	{
		_IO_file_close_it(dwArg04);
		ui32 edx_130 = *dwArg04;
		ecx_134 = edx_130 & 0x8000;
		if ((edx_130 & 0x8000) != 0x00)
		{
l08050DF5:
			Eq_2 ebx_177 = *((word32) dwArg04 + 0x0094);
			if (ebx_177 >= 135066356)
			{
				word32 edx_492;
				word32 ecx_491;
				_IO_vtable_check(out ecx_491, out edx_492);
			}
			(*((word32) ebx_177 + 8))();
			if (*((word32) dwArg04 + 0x0068) <= 0x00)
			{
				if (*((word32) dwArg04 + 36) != 0x00)
					_IO_free_backup_area(dwArg04);
			}
			else
			{
				Eq_2 ebx_231 = *((word32) dwArg04 + 84);
				if (gs->t000C != 0x00)
					__lock();
				word32 eax_240;
				if (!__cmpxchg(__gconv_lock, 0x01, 0x00, out eax_240))
					__lll_lock_wait_private(eax_240, 0x080CFF80, gs);
				word32 edx_496;
				__gconv_release_step(gs, *((word32) ebx_231 + 36), out edx_496);
				Eq_2 edx_278;
				Eq_2 ecx_279 = __gconv_release_step(gs, *((word32) ebx_231 + 76), out edx_278);
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v23_285 = __gconv_lock - 0x01;
				__gconv_lock = v23_285;
				if (v23_285 != 0x00)
					__lll_unlock_wake_private(0x080CFF80, ecx_279, edx_278, gs);
			}
			if (_IO_stdin != dwArg04 && (_IO_stdout != dwArg04 && _IO_stderr != dwArg04))
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 edx_495;
				word32 ecx_494;
				free(gs, stackArg0, dwArg04, out ecx_494, out edx_495);
			}
			return;
		}
l08050EF0:
		Eq_2 edx_151 = *((word32) dwArg04 + 72);
		Eq_2 v19_152 = *((word32) edx_151 + 4) - 0x01;
		*((word32) edx_151 + 4) = v19_152;
		if (v19_152 == 0x00)
		{
			((word32) edx_151 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v20_163 = *edx_151 - 0x01;
			*edx_151 = v20_163;
			if (v20_163 != 0x00)
				__lll_unlock_wake_private(edx_151, ecx_134, edx_151, gs);
		}
		goto l08050DF5;
	}
l08050DE6:
	if (ecx_134 != 0x00)
		goto l08050DF5;
	goto l08050EF0;
}

// 08050FA0: void fflush(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __assert_fail_base
//      __malloc_assert
void fflush(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
		_IO_flush_all();
	else
	{
		ui32 eax_37 = *dwArg04;
		if ((eax_37 & 0x8000) == 0x00)
		{
			Eq_2 edx_42 = *((word32) dwArg04 + 72);
			Eq_2 ebx_44 = gs->t0008;
			if (*((word32) edx_42 + 8) != ebx_44)
			{
				if (gs->t000C != 0x00)
					__lock();
				word32 eax_54;
				if (!__cmpxchg(*edx_42, 0x01, eax_37 & 0x8000, out eax_54))
					__lll_lock_wait_private(eax_54, edx_42, gs);
				edx_42 = *((word32) dwArg04 + 72);
				*((word32) edx_42 + 8) = ebx_44;
			}
			*((word32) edx_42 + 4) = (word32) *((word32) edx_42 + 4) + 1;
		}
		Eq_2 ebx_79 = *((word32) dwArg04 + 0x0094);
		if (ebx_79 >= 135066356)
		{
			word32 ecx_238;
			word32 edx_239;
			_IO_vtable_check(out ecx_238, out edx_239);
		}
		word32 eax_121;
		word32 ecx_123;
		(*((word32) ebx_79 + 48))();
		Eq_2 edx_132 = -(uint32) (int8) (eax_121 != 0x00);
		if ((*dwArg04 & 0x8000) == 0x00)
		{
			Eq_2 ecx_136 = *((word32) dwArg04 + 72);
			Eq_2 v18_137 = *((word32) ecx_136 + 4) - 0x01;
			*((word32) ecx_136 + 4) = v18_137;
			if (v18_137 == 0x00)
			{
				((word32) ecx_136 + 8)->u0 = 0x00;
				if (gs->t000C != 0x00)
					__lock();
				word32 v19_146 = *ecx_136 - 0x01;
				*ecx_136 = v19_146;
				if (v19_146 != 0x00)
					__lll_unlock_wake_private(ecx_136, ecx_136, edx_132, gs);
			}
		}
	}
}

// 080510A0: void __fopen_maybe_mmap(Stack (ptr32 Eq_12726) dwArg04)
void __fopen_maybe_mmap(struct Eq_12726 * dwArg04)
{
	if ((dwArg04->b003C & 0x01) != 0x00 && (dwArg04->b0000 & 0x08) != 0x00)
	{
		ptr32 ecx_17;
		if (dwArg04->dw0068 > 0x00)
			ecx_17 = 0x080CEFA0;
		else
			ecx_17 = 0x080CF0C0;
		dwArg04->ptr0094 = ecx_17;
		dwArg04->ptr0058->ptr00B0 = 0x080CEFA0;
	}
}

// 080510F0: void __fopen_internal()
// Called from:
//      __new_fopen
void __fopen_internal()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 esi_218;
	word32 edi_219;
	word32 ebp_217;
	word32 ebx_216;
	word32 ecx_214;
	word32 edx_215;
	Eq_2 eax_19 = __libc_malloc(gs, stackArg0, 344, out ecx_214, out edx_215, out ebx_216, out ebp_217, out esi_218, out edi_219);
	if (eax_19 == 0x00)
		return;
	*((word32) eax_19 + 72) = (word32) eax_19 + 0x0098;
	_IO_no_init(eax_19, 0x00, 0x00, (word32) eax_19 + 0x00A4, 0x080CF060);
	((word32) eax_19 + 0x0094)->u0 = 0x080CF180;
	_IO_new_file_init_internal(eax_19);
	if (_IO_file_fopen(gs, eax_19, dwArg08) == 0x00)
	{
		_IO_un_link(eax_19);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_221;
		word32 edx_222;
		free(gs, stackArg0, eax_19, out ecx_221, out edx_222);
	}
	else if ((*((word32) eax_19 + 60) & 0x01) != 0x00 && (*eax_19 & 0x08) != 0x00)
	{
		Eq_2 edx_125;
		if (*((word32) eax_19 + 0x0068) > 0x00)
			edx_125.u0 = 0x080CEFA0;
		else
			edx_125.u0 = 0x080CF0C0;
		*((word32) eax_19 + 0x0094) = edx_125;
		*((word32) *((word32) eax_19 + 88) + 0x00B0) = 0x080CEFA0;
	}
}

// 080511E0: Register Eq_2 __new_fopen()
// Called from:
//      read_alias_file
//      __gconv_read_conf
//      __readonly_area
Eq_2 __new_fopen()
{
	__fopen_internal();
	return <invalid>;
}

// 080511FA: void __x86.get_pc_thunk.dx()
void __x86.get_pc_thunk.dx()
{
}

// 08051200: void _IO_puts(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      main
void _IO_puts(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 edx_330;
	word32 ecx_329;
	Eq_2 eax_24 = strlen(dwArg04, out ecx_329, out edx_330);
	Eq_2 esi_31 = _IO_stdout;
	Eq_2 esp_105 = fp - 44;
	Eq_2 eax_34 = *esi_31;
	Eq_2 ecx_113 = esi_31;
	if ((eax_34 & 0x8000) == 0x00)
	{
		Eq_2 edx_40 = *((word32) esi_31 + 72);
		Eq_2 ebx_42 = gs->t0008;
		if (*((word32) edx_40 + 8) != ebx_42)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_52;
			if (!__cmpxchg(*edx_40, 0x01, eax_34 & 0x8000, out eax_52))
				__lll_lock_wait_private(eax_52, edx_40, gs);
			edx_40 = *((word32) esi_31 + 72);
			ecx_113 = _IO_stdout;
			*((word32) edx_40 + 8) = ebx_42;
		}
		*((word32) edx_40 + 4) = (word32) *((word32) edx_40 + 4) + 1;
	}
	Eq_2 eax_80 = *((word32) ecx_113 + 0x0068);
	if (eax_80 == 0x00)
		((word32) ecx_113 + 0x0068)->u0 = ~0x00;
	else if (eax_80 != ~0x00)
		goto l08051329;
	Eq_2 eax_89 = *((word32) ecx_113 + 0x0094);
	if (eax_89 >= 135066356)
	{
		word32 edx_332;
		word32 ecx_331;
		_IO_vtable_check(out ecx_331, out edx_332);
		esp_105.u0 = <invalid>;
		ecx_113 = _IO_stdout;
	}
	struct Eq_12936 * esp_124 = esp_105 - 0x04;
	esp_124->tFFFFFFFC = eax_24;
	esp_124->tFFFFFFF8 = dwArg04;
	esp_124->tFFFFFFF4 = ecx_113;
	Eq_2 eax_150;
	(*((word32) eax_89 + 28))();
	if (eax_24 == eax_150)
	{
		Eq_2 eax_157 = _IO_stdout;
		Eq_2 edx_158 = *((word32) eax_157 + 20);
		if (edx_158 < *((word32) eax_157 + 24))
		{
			*((word32) eax_157 + 20) = (word32) edx_158 + 1;
			*edx_158 = 0x0A;
			ecx_113 = (word32) edx_158 + 1;
l080512E4:
			if ((*esi_31 & 0x8000) == 0x00)
			{
				Eq_2 edx_198 = *((word32) esi_31 + 72);
				Eq_2 v19_199 = *((word32) edx_198 + 4) - 0x01;
				*((word32) edx_198 + 4) = v19_199;
				if (v19_199 == 0x00)
				{
					((word32) edx_198 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v20_211 = *edx_198 - 0x01;
					*edx_198 = v20_211;
					if (v20_211 != 0x00)
						__lll_unlock_wake_private(edx_198, ecx_113, edx_198, gs);
				}
			}
			return;
		}
		esp_124->tFFFFFFF8.u0 = 0x0A;
		esp_124->tFFFFFFF4 = eax_157;
		word32 edx_333;
		if (__overflow(esp_124->tFFFFFFF4, esp_124->tFFFFFFF8, out ecx_113, out edx_333) != ~0x00)
			goto l080512D6;
	}
l08051329:
	goto l080512E4;
}

// 08051360: Register Eq_2 adjust_wide_data(Register Eq_2 eax, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 esiOut)
// Called from:
//      _IO_wfile_seekoff
Eq_2 adjust_wide_data(Eq_2 eax, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & esiOut)
{
	Eq_2 eax_115;
	Eq_2 edx_109;
	Eq_2 ecx_103;
	Eq_2 eax_110;
	Eq_2 edi_21 = *((word32) eax + 84);
	Eq_2175 eax_23 = gs->t0014;
	int32 eax_31;
	(*((word32) edi_21 + 16))();
	if ((byte) edx != 0x01 && eax_31 > 0x00)
	{
		ecx_103 = *((word32) eax + 88);
		edx_109 = *((word32) ecx_103 + 4);
		eax_110 = (word32) edx_109 + (int32) ((int64) (*((word32) eax + 4) - *((word32) eax + 0x0C)) /32 eax_31) * 0x04;
		*((word32) ecx_103 + 4) = eax_110;
l080513EC:
		*ecx_103 = eax_110;
		eax_115.u0 = 0x00;
	}
	else
	{
		Eq_2 edx_44 = *((word32) eax + 0x0C);
		while (true)
		{
			Eq_2 eax_50 = *((word32) eax + 88);
			Eq_2 ebx_52 = *((word32) eax_50 + 48);
			*((word32) eax_50 + 52) = *((word32) eax_50 + 44);
			*((word32) eax_50 + 56) = ebx_52;
			word32 eax_84;
			(*((word32) edi_21 + 0x0C))();
			if (eax_84 == 0x02)
				break;
			if (eax_84 != 0x01)
			{
				ecx_103 = *((word32) eax + 88);
				eax_110 = *((word32) ecx_103 + 4);
				goto l080513EC;
			}
			edx_44 = *((word32) eax + 0x0C);
		}
		*eax |= 0x20;
		eax_115.u0 = ~0x00;
	}
	if ((eax_23 ^ gs->t0014) != 0x00)
	{
		word32 edx_226;
		word32 ecx_225;
		__stack_chk_fail(out ecx_225, out edx_226);
		Eq_2 eax_140 = _IO_wfile_underflow(edx_109, eax, gs, dwArg04);
		esiOut = eax;
		return eax_140;
	}
	else
	{
		esiOut = esi;
		return eax_115;
	}
}

// 08051430: Register Eq_2 _IO_wfile_underflow(Register Eq_2 edx, Register Eq_2 esi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      adjust_wide_data
Eq_2 _IO_wfile_underflow(Eq_2 edx, Eq_2 esi, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 eax_107;
	Eq_2 eax_23 = *dwArg04;
	byte al_28 = (byte) eax_23;
	Eq_2175 ecx_25 = gs->t0014;
	if ((al_28 & 0x10) != 0x00)
	{
l08051566:
		eax_107.u0 = ~0x00;
		goto l08051530;
	}
	if ((al_28 & 0x04) != 0x00)
	{
		*dwArg04 = eax_23 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		eax_107.u0 = ~0x00;
		goto l08051530;
	}
	Eq_2 eax_45 = *((word32) dwArg04 + 88);
	edx = *eax_45;
	if (edx < *((word32) eax_45 + 4))
	{
		eax_107 = *edx;
		goto l08051530;
	}
	Eq_2 eax_140;
	Eq_2 edx_52 = *((word32) dwArg04 + 84);
	Eq_2 edx_54 = *((word32) dwArg04 + 4);
	Eq_2 ecx_55 = *((word32) dwArg04 + 8);
	if (edx_54 < ecx_55)
	{
		Eq_2 ebx_64 = *((word32) eax_45 + 24);
		<anonymous> * edi_66 = *((word32) eax_45 + 48);
		*((word32) eax_45 + 52) = *((word32) eax_45 + 44);
		*eax_45 = ebx_64;
		*((word32) eax_45 + 8) = ebx_64;
		*((word32) eax_45 + 56) = edi_66;
		word32 eax_93;
		(*((word32) edx_52 + 0x0C))();
		Eq_2 edx_99 = *((word32) dwArg04 + 4);
		*((word32) dwArg04 + 4) = edx_54;
		*((word32) dwArg04 + 0x0C) = edx_99;
		edx = *((word32) dwArg04 + 88);
		dwLoc34 = edx_54;
		esi = (word32) eax_45 + 4;
		dwLoc80 = ecx_55;
		Eq_2 ebx_104 = *edx;
		if (ebx_104 < *((word32) edx + 4))
		{
			eax_107 = *ebx_104;
			goto l08051530;
		}
		if (eax_93 == 0x02)
		{
			gs->tFFFFFFE0.u0 = 0x54;
			*dwArg04 |= 0x20;
			eax_107.u0 = ~0x00;
			goto l08051530;
		}
		word32 edx_1253;
		memmove(*((word32) dwArg04 + 28), edx_54, *((word32) dwArg04 + 8) - edx_54, out edx_1253);
		eax_140 = *((word32) dwArg04 + 28);
		word32 edx_144 = Mem131[dwArg04 + 0x08:word32] + eax_140 - Mem131[dwArg04 + 0x04:word32];
		*((word32) dwArg04 + 0x0C) = eax_140;
		*((word32) dwArg04 + 8) = edx_144;
		*((word32) dwArg04 + 4) = eax_140;
	}
	else
	{
		eax_140 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 8) = eax_140;
		*((word32) dwArg04 + 4) = eax_140;
		*((word32) dwArg04 + 0x0C) = eax_140;
	}
	if (eax_140 == 0x00)
	{
		Eq_2 eax_156 = *((word32) dwArg04 + 36);
		if (eax_156 != 0x00)
		{
			word32 ecx_1263;
			word32 edx_1264;
			free(gs, dwLoc80, eax_156, out ecx_1263, out edx_1264);
			*dwArg04 &= ~0x0100;
		}
		_IO_doallocbuf(dwArg04);
		eax_140 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 8) = eax_140;
		*((word32) dwArg04 + 4) = eax_140;
		*((word32) dwArg04 + 0x0C) = eax_140;
		esi = dwArg04;
	}
	*((word32) dwArg04 + 24) = eax_140;
	*((word32) dwArg04 + 20) = eax_140;
	*((word32) dwArg04 + 16) = eax_140;
	Eq_2 eax_208 = *((word32) dwArg04 + 88);
	if (*((word32) eax_208 + 24) == 0x00)
	{
		Eq_2 eax_213 = *((word32) eax_208 + 32);
		if (eax_213 != 0x00)
		{
			word32 edx_1260;
			word32 ecx_1259;
			free(gs, dwLoc80, eax_213, out ecx_1259, out edx_1260);
			*dwArg04 &= ~0x0100;
		}
		_IO_wdoallocbuf(dwArg04);
	}
	Eq_2 esp_334 = fp - 0x6C;
	if ((*dwArg04 & 0x0202) == 0x00)
	{
l08051660:
		struct Eq_13403 * esp_416 = esp_334 - 0x0C;
		esp_416->tFFFFFFFC = dwArg04;
		word32 ecx_1254;
		_IO_switch_to_get_mode(esp_416->tFFFFFFFC, out ecx_1254);
		Eq_2 eax_428 = *((word32) dwArg04 + 88);
		Eq_2 edx_433 = *((word32) eax_428 + 24);
		*eax_428 = edx_433;
		*((word32) eax_428 + 8) = edx_433;
		*((word32) eax_428 + 4) = edx_433;
		*((word32) eax_428 + 20) = edx_433;
		*((word32) eax_428 + 16) = edx_433;
		*((word32) eax_428 + 0x0C) = edx_433;
		Eq_2 esp_429 = (char *) &esp_416->tFFFFFFFC + 16;
		Eq_2 dwLoc44_1007 = 0x00;
		while (true)
		{
			Eq_2 ebx_445 = *((word32) dwArg04 + 0x0094);
			if (ebx_445 >= 135066356)
			{
				word32 ecx_1261;
				word32 edx_1262;
				_IO_vtable_check(out ecx_1261, out edx_1262);
				esp_429.u0 = <invalid>;
			}
			Eq_2 eax_463 = *((word32) dwArg04 + 32);
			Eq_2 edx_464 = *((word32) dwArg04 + 8);
			struct Eq_13641 * esp_462 = esp_429 - 0x04;
			Eq_2 eax_466 = eax_463 - edx_464;
			esp_462->tFFFFFFFC = eax_466;
			esp_462->tFFFFFFF8 = edx_464;
			esp_462->tFFFFFFF4 = dwArg04;
			Eq_2 eax_481;
			(*((word32) ebx_445 + 56))();
			if (eax_481 <= 0x00)
				break;
			Eq_2 ecx_515 = *((word32) dwArg04 + 76);
			word32 edx_516 = Mem473[dwArg04 + 0x08:word32] + eax_481;
			*((word32) dwArg04 + 8) = edx_516;
			Eq_2 ebx_519 = *((word32) dwArg04 + 80);
			if ((ecx_515 & ebx_519) != ~0x00)
			{
				ui64 ebx_ecx_878 = SEQ(ebx_519, ecx_515) + SEQ(eax_481 >> 0x1F, eax_481);
				*((word32) dwArg04 + 76) = (word32) ebx_ecx_878;
				*((word32) dwArg04 + 80) = SLICE(ebx_ecx_878, word32, 32);
			}
			word32 eax_617;
			Eq_2 esi_537 = *((word32) dwArg04 + 88);
			Eq_2 ecx_539 = *((word32) esi_537 + 44);
			*((word32) esi_537 + 56) = *((word32) esi_537 + 48);
			Eq_2 ebx_541 = *((word32) dwArg04 + 4);
			*((word32) esi_537 + 52) = ecx_539;
			*((word32) dwArg04 + 0x0C) = ebx_541;
			if (dwLoc44_1007 == 0x00)
			{
				esp_462->ptr0000 = (word32) esi_537 + 4;
				esp_462->tFFFFFFFC = *((word32) esi_537 + 28);
				esp_462->tFFFFFFF8 = *((word32) esi_537 + 4);
				esp_462->tFFFFFFF4 = fp - 0x34;
				esp_462->tFFFFFFF0 = edx_516;
				esp_462->tFFFFFFEC = ebx_541;
				esp_462->ptrFFFFFFE8 = (word32) esi_537 + 44;
				esp_462->tFFFFFFE4 = edx_52;
				word32 edx_661;
				(*((word32) edx_52 + 0x0C))();
				goto l08051785;
			}
			Eq_2 edx_550 = 0x10 - dwLoc44_1007;
			if (edx_550 <= eax_481)
				eax_481 = edx_550;
			esp_462->tFFFFFFFC = eax_481;
			esp_462->tFFFFFFF8 = ebx_541;
			word32 ecx_561 = dwLoc44_1007 + (fp - 0x30);
			esp_462->tFFFFFFF4 = ecx_561;
			word32 edx_1270;
			Eq_2 eax_575 = __mempcpy(esp_462->tFFFFFFF4, esp_462->tFFFFFFF8, esp_462->tFFFFFFFC, out edx_1270);
			esp_462->ptr0000 = (word32) esi_537 + 4;
			esp_462->tFFFFFFFC = *((word32) esi_537 + 28);
			esp_462->tFFFFFFF8 = *((word32) esi_537 + 4);
			esp_462->tFFFFFFF4 = fp - 0x34;
			esp_462->tFFFFFFF0 = eax_575;
			esp_462->tFFFFFFEC = fp - 0x30;
			esp_462->ptrFFFFFFE8 = (word32) esi_537 + 44;
			esp_462->tFFFFFFE4 = edx_52;
			word32 v33_589 = dwLoc44_1007 + eax_481;
			(*((word32) edx_52 + 0x0C))();
			dwLoc44_1007 = v33_589;
			if (v33_589 != 0x00)
			{
				struct Eq_14070 * edx_628 = dwLoc34 - ecx_561;
				if (edx_628 < null)
					edx_628 = null;
				edx = edx_628 + Mem612[dwArg04 + 0x04:word32];
			}
			else
			{
l08051785:
				dwLoc44_1007.u0 = 0x00;
				edx = dwLoc34;
			}
			Eq_2 ebx_673 = *((word32) dwArg04 + 88);
			*((word32) dwArg04 + 4) = edx;
			esi = *((word32) ebx_673 + 24);
			if (*((word32) ebx_673 + 4) != esi)
			{
				eax_107 = **ebx_673;
				goto l08051530;
			}
			if (eax_617 == 0x02)
			{
l08051550:
				gs->tFFFFFFE0.u0 = 0x54;
				*dwArg04 |= 0x20;
				edx = dwArg04;
				goto l08051566;
			}
			if (eax_617 != 0x01)
			{
				struct Eq_13824 * esp_693 = esp_429 - 4;
				esp_693->ptr0000 = 0x080A27D0;
				esp_693->dwFFFFFFFC = 0x0122;
				esp_693->ptrFFFFFFF8 = 134883241;
				esp_693->ptrFFFFFFF4 = 134883252;
				word32 ecx_1265;
				__assert_fail(out ecx_1265, out edx);
				goto l08051A74;
			}
			if (dwLoc44_1007 != 0x00)
			{
				ui32 edx_772 = dwLoc34 - (fp - 0x30);
				if (edx_772 != 0x00)
				{
					Eq_2 v29_775 = dwLoc44_1007 - edx_772;
					struct Eq_13867 * esp_778 = esp_429 - 0x04;
					esp_778->tFFFFFFFC = v29_775;
					esp_778->tFFFFFFF8 = dwLoc34;
					esp_778->tFFFFFFF4 = fp - 0x30;
					word32 edx_1266;
					memmove(esp_778->tFFFFFFF4, esp_778->tFFFFFFF8, esp_778->tFFFFFFFC, out edx_1266);
					dwLoc44_1007 = v29_775;
				}
				if (dwLoc44_1007 == 0x10)
					goto l08051550;
				esi = *((word32) dwArg04 + 0x0C);
				goto l080516D8;
			}
			esi = *((word32) dwArg04 + 0x0C);
			Eq_2 edi_719 = *((word32) dwArg04 + 8) - edx;
			if (esi < edx)
			{
				struct Eq_13929 * esp_722 = esp_429 - 0x04;
				esp_722->tFFFFFFFC = edi_719;
				esp_722->tFFFFFFF8 = edx;
				esp_722->tFFFFFFF4 = esi;
				word32 edx_1267;
				memmove(esp_722->tFFFFFFF4, esp_722->tFFFFFFF8, esp_722->tFFFFFFFC, out edx_1267);
				Eq_2 eax_740 = *((word32) dwArg04 + 0x0C);
				*((word32) dwArg04 + 8) -= edi_719;
				*((word32) dwArg04 + 4) = eax_740;
				esp_429 = (char *) &esp_722->tFFFFFFFC + 8;
				continue;
			}
			if (edi_719 > 0x0F)
				goto l08051550;
			struct Eq_13972 * esp_747 = esp_429 - 0x04;
			esp_747->tFFFFFFFC = edi_719;
			esp_747->tFFFFFFF8 = edx;
			esp_747->tFFFFFFF4 = fp - 0x30;
			word32 ecx_1268;
			word32 edx_1269;
			memcpy(esp_747->tFFFFFFF4, esp_747->tFFFFFFF8, esp_747->tFFFFFFFC, out ecx_1268, out edx_1269);
			dwLoc44_1007 = edi_719;
l080516D8:
			*((word32) dwArg04 + 8) = esi;
			*((word32) dwArg04 + 4) = esi;
		}
		Eq_2 eax_492 = *dwArg04;
		if ((eax_481 | dwLoc44_1007) == 0x00)
		{
			((word32) dwArg04 + 76)->u0 = ~0x00;
			*dwArg04 = eax_492 | 0x10;
			((word32) dwArg04 + 80)->u0 = ~0x00;
			eax_107.u0 = ~0x00;
			goto l08051530;
		}
		*dwArg04 = eax_492 | 0x20;
		edx = dwArg04;
		if (dwLoc44_1007 != 0x00)
		{
			gs->tFFFFFFE0.u0 = 0x54;
			eax_107.u0 = ~0x00;
l08051530:
			if ((ecx_25 ^ gs->t0014) == 0x00)
				return eax_107;
l08051A74:
			word32 edx_1256;
			word32 ecx_1255;
			Eq_2 eax_827 = __stack_chk_fail(out ecx_1255, out edx_1256);
			_IO_wfile_underflow.cold.2(eax_827, eax_827, edx, fp - 4, esi, gs);
		}
		goto l08051566;
	}
	Eq_2 ecx_276;
	esi = _IO_stdout;
	uint32 eax_267 = *esi;
	if ((eax_267 & 0x8000) == 0x00)
	{
		Eq_2 edx_277 = *((word32) esi + 72);
		ecx_276 = esi;
		Eq_2 ebx_281 = gs->t0008;
		if (*((word32) edx_277 + 8) != ebx_281)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_292;
			if (!__cmpxchg(*edx_277, 0x01, eax_267 & 0x8000, out eax_292))
				__lll_lock_wait_private(eax_292, edx_277, gs);
			edx_277 = *((word32) esi + 72);
			ecx_276 = _IO_stdout;
			*((word32) edx_277 + 8) = ebx_281;
			eax_267 = (uint32) *ecx_276;
		}
		*((word32) edx_277 + 4) = (word32) *((word32) edx_277 + 4) + 1;
		if ((eax_267 & 0x0288) != 0x0280)
		{
l08051631:
			if ((*esi & 0x8000) == 0x00)
			{
				Eq_2 edx_388 = *((word32) esi + 72);
				Eq_2 v20_389 = *((word32) edx_388 + 4) - 0x01;
				*((word32) edx_388 + 4) = v20_389;
				if (v20_389 == 0x00)
				{
					((word32) edx_388 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v21_399 = *edx_388 - 0x01;
					*edx_388 = v21_399;
					if (v21_399 != 0x00)
						__lll_unlock_wake_private(edx_388, ecx_276, edx_388, gs);
				}
			}
			goto l08051660;
		}
	}
	else
	{
		if ((eax_267 & 0x0288) != 0x0280)
			goto l08051660;
		ecx_276 = esi;
	}
	Eq_2 ebx_325 = *((word32) ecx_276 + 0x0094);
	if (ebx_325 >= 135066356)
	{
		word32 edx_1258;
		word32 ecx_1257;
		_IO_vtable_check(out ecx_1257, out edx_1258);
		esp_334.u0 = <invalid>;
	}
	struct Eq_13516 * esp_348 = esp_334 - 0x08;
	esp_348->dwFFFFFFFC = ~0x00;
	esp_348->tFFFFFFF8 = _IO_stdout;
	word32 edx_379;
	(*((word32) ebx_325 + 0x0C))();
	esp_334 = &esp_348->dwFFFFFFFC + 3;
	goto l08051631;
}

// 08051A90: void _IO_wfile_seekoff(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word64 qwArg08, Stack word32 dwArg10, Stack word32 dwArg14)
void _IO_wfile_seekoff(struct Eq_9 * gs, Eq_2 dwArg04, word64 qwArg08, word32 dwArg10, word32 dwArg14)
{
	word32 dwArg08 = (word32) qwArg08;
	word32 dwArg0C = SLICE(qwArg08, word32, 32);
	Eq_2 esp_102 = fp - 188;
	Eq_2175 eax_26 = gs->t0014;
	Eq_2 eax_29 = *((word32) dwArg04 + 88);
	if (dwArg14 != 0x00)
	{
		int64 edx_eax_1921;
		Eq_2 esp_1008;
		Eq_2 ecx_438 = *((word32) eax_29 + 0x0C);
		Eq_2 edx_439 = *((word32) eax_29 + 16);
		if ((*((word32) eax_29 + 8) != *((word32) eax_29 + 4) || ecx_438 != edx_439) && ecx_438 < edx_439 || (*dwArg04 & 0x0800) != 0x00)
		{
			if (_IO_switch_to_wget_mode(dwArg04) != 0x00)
				goto l08051E7E;
			eax_29 = *((word32) dwArg04 + 88);
			if (*((word32) eax_29 + 24) != 0x00)
			{
l08051B3C:
				if (dwArg10 != 0x01)
					goto l08051B4A;
				goto l08051D84;
			}
		}
		else if (*((word32) eax_29 + 24) != 0x00)
			goto l08051B3C;
		Eq_2 eax_492 = *((word32) eax_29 + 8);
		if (eax_492 != 0x00)
		{
			word32 edx_1948;
			word32 ecx_1947;
			free(gs, dwLocD0, eax_492, out ecx_1947, out edx_1948);
			*dwArg04 &= ~0x0100;
		}
		_IO_doallocbuf(dwArg04);
		Eq_2 eax_538 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 20) = eax_538;
		*((word32) dwArg04 + 16) = eax_538;
		*((word32) dwArg04 + 24) = eax_538;
		*((word32) dwArg04 + 0x0C) = eax_538;
		*((word32) dwArg04 + 4) = eax_538;
		*((word32) dwArg04 + 8) = eax_538;
		Eq_2 eax_547 = *((word32) dwArg04 + 88);
		Eq_2 edx_548 = *((word32) eax_547 + 24);
		*((word32) eax_547 + 16) = edx_548;
		*((word32) eax_547 + 0x0C) = edx_548;
		*((word32) eax_547 + 20) = edx_548;
		*((word32) eax_547 + 8) = edx_548;
		*eax_547 = edx_548;
		*((word32) eax_547 + 4) = edx_548;
		if (dwArg10 != 0x01)
		{
l08051B4A:
			esp_1008 = fp - 188;
			if (dwArg10 != 0x02)
				goto l08051BCD;
			Eq_2 ebx_682 = *((word32) dwArg04 + 0x0094);
			if (ebx_682 >= 135066356)
			{
				word32 ecx_1927;
				word32 edx_1928;
				_IO_vtable_check(out ecx_1927, out edx_1928);
				esp_1008.u0 = <invalid>;
			}
			struct Eq_14228 * esp_701 = esp_1008 - 0x08;
			esp_701->ptrFFFFFFFC = &esp_701->dw0018 + 9;
			esp_701->dwFFFFFFF8 = esp_701->dw0018;
			word32 eax_718;
			(*((word32) ebx_682 + 72))();
			esp_1008 = &esp_701->ptrFFFFFFFC + 3;
			if (eax_718 != 0x00 || (esp_701->dw004C & 0xF000) != 0x8000)
				goto l08051E00;
			edx_eax_1921 = esp_701->qw0068;
l08051BBA:
			ui64 v18_v17_1312 = (word32) *((byte) esp_1008.u0 + 8) + edx_eax_1921;
			*((byte) esp_1008.u0 + 8) = (word32) v18_v17_1312;
			*((byte) esp_1008.u0 + 0x0C) = SLICE(v18_v17_1312, word32, 32);
			*((byte) esp_1008.u0 + 0x00CC) = 0x00;
l08051BCD:
			struct Eq_14186 * esp_745 = esp_1008 - 0x0C;
			Eq_2 ebx_748 = esp_745->t001C;
			esp_745->tFFFFFFFC = ebx_748;
			_IO_free_wbackup_area(esp_745->tFFFFFFFC);
			Eq_2 eax_758 = *((word32) ebx_748 + 76);
			Eq_2 edx_759 = *((word32) ebx_748 + 80);
			esp_1008 = &esp_745->t000C;
			if ((eax_758 & edx_759) != ~0x00)
			{
				Eq_2 ecx_768 = *ebx_748;
				Eq_2 esi_769 = *((word32) ebx_748 + 0x0C);
				esp_745->t0024 = ecx_768;
				byte ch_774 = SLICE(ecx_768, byte, 8);
				if (esi_769 != 0x00 && (ch_774 & 0x01) == 0x00)
				{
					Eq_2 esi_779 = *((word32) ebx_748 + 28);
					Eq_2 ecx_780 = *((word32) ebx_748 + 8);
					esp_745->t001C = ebx_748;
					esp_745->t0020 = esi_779;
					ui64 edi_esi_1302 = SEQ(edx_759, eax_758) - SEQ(ecx_783 >> 0x1F, ecx_783);
					Eq_2 esi_788 = (word32) edi_esi_1302;
					ecx_783 = ecx_780 - esi_779;
					if (esp_745->dw0018 - SLICE(edi_esi_1302, word32, 32) - (word32) (esp_745->t0014 < esi_788) >= 0x00 && (esp_745->dw0018 - edx_759) - (word32) (esp_745->t0014 < eax_758) < 0x00)
					{
						Eq_2 esi_1065 = esp_745->t0020;
						Eq_2 edx_1066 = esp_745->t001C;
						Eq_2 eax_1068 = (word32) esi_1065 + (esp_745->t0014 - esi_788);
						*((word32) edx_1066 + 0x0C) = esi_1065;
						*((word32) edx_1066 + 4) = eax_1068;
						Eq_2 eax_1071 = *((word32) edx_1066 + 88);
						*((word32) edx_1066 + 20) = esi_1065;
						*((word32) edx_1066 + 16) = esi_1065;
						*((word32) edx_1066 + 24) = esi_1065;
						Eq_2 edx_1076 = *((word32) eax_1071 + 24);
						*((word32) eax_1071 + 8) = edx_1076;
						*eax_1071 = edx_1076;
						*((word32) eax_1071 + 4) = edx_1076;
						*((word32) eax_1071 + 16) = edx_1076;
						*((word32) eax_1071 + 0x0C) = edx_1076;
						*((word32) eax_1071 + 20) = edx_1076;
						word32 esi_1944;
						if (adjust_wide_data(edx_1066, 0x00, gs, esp_745->t000C, out esi_1944) == 0x00)
						{
							Eq_2 eax_1201 = esp_745->t001C;
							Eq_2 ebx_1202 = *((word32) eax_1201 + 80);
							*eax_1201 &= ~0x10;
							Eq_2 ecx_1206 = *((word32) eax_1201 + 76);
							if (ebx_1202 >= 0x00)
							{
								Eq_2 edi_1212 = *((word32) esp_745->t001C + 0x0094);
								if (edi_1212 >= 135066356)
								{
									word32 edx_1946;
									word32 ecx_1945;
									_IO_vtable_check(out ecx_1945, out edx_1946);
									esp_1008.u0 = <invalid>;
									Eq_2 eax_1226 = *((byte) esp_1008.u0 + 16);
									ecx_1206 = *((word32) eax_1226 + 76);
									ebx_1202 = *((word32) eax_1226 + 80);
								}
								struct Eq_15180 * esp_1230 = esp_1008 - 4;
								esp_1230->dw0000 = 0x00;
								esp_1230->tFFFFFFFC = ebx_1202;
								esp_1230->tFFFFFFF8 = ecx_1206;
								esp_1230->dwFFFFFFF4 = esp_1230->dw0014;
								(*((word32) edi_1212 + 64))();
							}
							goto l08051E7E;
						}
						goto l08051DE2;
					}
				}
			}
			else
				esp_745->t0024 = *esp_745->t001C;
			Eq_2 edi_812 = esp_745->t0024;
			esp_745->dw002C = 0x080CEFA0;
			esp_745->t0020.u0 = 0x0354;
			esp_745->dw0034 = edi_812 & 0x04;
			if ((edi_812 & 0x04) != 0x00)
				goto l08051E00;
			Eq_2 eax_821 = esp_745->t001C;
			Eq_2 ecx_823 = *((word32) eax_821 + 32);
			ui32 edi_825 = *((word32) eax_821 + 28) - ecx_823;
			Eq_2 edi_828 = esp_745->t0014;
			int32 ebp_822 = esp_745->dw0018;
			esp_745->t0024 = edi_825 & edi_828;
			int64 ebp_edi_1314 = SEQ(ebp_822, edi_828) - esp_745->t0024;
			esp_745->dw0028 = SLICE((int64) edi_825, word32, 32) & ebp_822;
			up32 ecx_841 = ecx_823 - *((word32) esp_745->t001C + 28);
			if (SLICE((int64) ecx_841 - ebp_edi_1314, word32, 32) - (word32) (ecx_841 < (word32) ebp_edi_1314) < 0x00)
			{
				int32 ebp_852 = esp_745->dw0018;
				esp_745->t0024 = esp_745->t0014;
				esp_745->dw0028 = ebp_852;
				ebp_edi_1314 = 0x00;
			}
			uint32 edi_893 = (word32) ebp_edi_1314;
			int32 ebp_891 = SLICE(ebp_edi_1314, word32, 32);
			Eq_2 edx_862 = *((word32) esp_745->t001C + 0x0094);
			if (edx_862 - 0x080CEFA0 >= esp_745->t0020)
			{
				esp_745->t0038 = edx_862;
				word32 ecx_1949;
				word32 edx_1950;
				_IO_vtable_check(out ecx_1949, out edx_1950);
				esp_1008.u0 = <invalid>;
				edx_862 = *((byte) esp_1008.u0 + 44);
			}
			struct Eq_15446 * esp_878 = esp_1008 - 4;
			esp_878->dw0000 = 0x00;
			esp_878->dwFFFFFFFC = esp_878->dw0020;
			esp_878->dwFFFFFFF8 = esp_878->dw001C;
			struct Eq_15465 * esi_886 = esp_878->ptr0014;
			esp_878->ptrFFFFFFF4 = esi_886;
			word32 eax_907;
			int32 edx_908;
			(*((word32) edx_862 + 64))();
			esp_878->dw001C = eax_907;
			esp_878->dw0020 = edx_908;
			esp_1008 = &esp_878->dw0000 + 1;
			if (edx_908 >= 0x00)
			{
				uint32 edx_1007;
				if ((ebp_891 | edi_893) == 0x00)
				{
					edx_1007 = 0x00;
					goto l08051FAA;
				}
				struct Eq_15492 * eax_927 = esi_886->ptr0094;
				if (eax_927 - 0x080CEFA0 >= esp_878->dw0018)
				{
					esp_878->ptr002C = eax_927;
					word32 edx_1952;
					word32 ecx_1951;
					_IO_vtable_check(out ecx_1951, out edx_1952);
					esp_1008.u0 = <invalid>;
					eax_927 = (struct Eq_15492 *) *((byte) esp_1008.u0 + 40);
				}
				uint32 eax_952;
				Eq_2 eax_946 = *((byte) esp_1008.u0 + 16);
				<anonymous> * ecx_943 = eax_927->ptr0038;
				Eq_2 edx_947 = *((word32) eax_946 + 28);
				if (*((byte) esp_1008.u0 + 36) != 0x00)
					eax_952 = edi_893;
				else
					eax_952 = *((word32) eax_946 + 32) - edx_947;
				struct Eq_15536 * esp_957 = esp_1008 - 0x04;
				esp_957->dwFFFFFFFC = eax_952;
				esp_957->tFFFFFFF8 = edx_947;
				esp_957->dwFFFFFFF4 = esp_957->dw0014;
				word32 eax_979;
				ecx_943();
				int64 edx_eax_983 = (int64) eax_979;
				uint32 eax_984 = (word32) edx_eax_983;
				esp_957->dw002C = eax_984;
				esp_1008 = &esp_957->dwFFFFFFFC + 2;
				if (SLICE(edx_eax_983, word32, 32) - ebp_891 - (word32) (eax_984 < edi_893) >= 0x00)
				{
					edx_1007 = eax_984;
l08051FAA:
					Eq_2 esi_1010 = *((word32) esp_1008 + 16);
					Eq_2 eax_1011 = *((word32) esi_1010 + 28);
					*((word32) esi_1010 + 0x0C) = eax_1011;
					*((word32) esi_1010 + 20) = eax_1011;
					*((word32) esi_1010 + 16) = eax_1011;
					*((word32) esi_1010 + 24) = eax_1011;
					Eq_2 eax_1021 = *((word32) esi_1010 + 88);
					*((word32) esi_1010 + 8) = (word32) eax_1011 + edx_1007;
					Eq_2 edx_1023 = *((word32) eax_1021 + 24);
					*((word32) esi_1010 + 4) = (word32) eax_1011 + edi_893;
					*((word32) eax_1021 + 8) = edx_1023;
					*eax_1021 = edx_1023;
					*((word32) eax_1021 + 4) = edx_1023;
					*((word32) eax_1021 + 16) = edx_1023;
					*((word32) eax_1021 + 0x0C) = edx_1023;
					*((word32) eax_1021 + 20) = edx_1023;
					struct Eq_15553 * esi_1040;
					if (adjust_wide_data(esi_1010, 0x01, gs, *esp_1008, out esi_1040) == 0x00)
					{
						int64 edx_eax_1316 = (word32) *((byte) esp_1008.u0 + 24) + (int64) (*((byte) esp_1008.u0 + 40));
						esi_1040->t004C = (word32) edx_eax_1316;
						esi_1040->t0050 = SLICE(edx_eax_1316, word32, 32);
						esi_1040->dw0000 &= ~0x10;
						goto l08051E7E;
					}
					goto l08051E00;
				}
				if (esp_957->dw002C != ~0x00)
				{
					esp_957->dw00D0 = 0x01;
					int64 ebp_edi_1319 = ebp_edi_1314 - edx_eax_983;
					esp_957->dw000C = (word32) ebp_edi_1319;
					esp_957->dw0010 = SLICE(ebp_edi_1319, word32, 32);
				}
				else
				{
					esp_957->dw000C = edi_893;
					esp_957->dw0010 = ebp_891;
					esp_957->dw00D0 = 0x01;
				}
l08051E00:
				struct Eq_14250 * esp_1112 = esp_1008 - 0x0C;
				Eq_2 esi_1115 = esp_1112->t001C;
				esp_1112->tFFFFFFFC = esi_1115;
				_IO_unsave_markers(esp_1112->tFFFFFFFC);
				Eq_2 ebx_1125 = *((word32) esi_1115 + 0x0094);
				Eq_2 esp_1128 = (char *) &esp_1112->tFFFFFFFC + 16;
				if (ebx_1125 - esp_1112->dw002C >= esp_1112->dw0020)
				{
					word32 edx_1932;
					word32 ecx_1931;
					_IO_vtable_check(out ecx_1931, out edx_1932);
					esp_1128.u0 = <invalid>;
				}
				struct Eq_14581 * esp_1141 = esp_1128 - 4;
				esp_1141->dw0000 = (word32) *((byte) esp_1128.u0 + 0x00CC);
				esp_1141->dwFFFFFFFC = esp_1141->dw0010;
				esp_1141->dwFFFFFFF8 = esp_1141->dw000C;
				struct Eq_14602 * esi_1149 = esp_1141->ptr0014;
				esp_1141->ptrFFFFFFF4 = esi_1149;
				ui32 eax_1171;
				ui32 edx_1172;
				(*((word32) ebx_1125 + 64))();
				if ((eax_1171 & edx_1172) != ~0x00)
				{
					word32 ecx_1180 = esi_1149->dw001C;
					esi_1149->dw0000 &= ~0x10;
					esi_1149->dw004C = eax_1171;
					esi_1149->dw000C = ecx_1180;
					esi_1149->dw0004 = ecx_1180;
					esi_1149->dw0008 = ecx_1180;
					esi_1149->dw0014 = ecx_1180;
					esi_1149->dw0010 = ecx_1180;
					esi_1149->dw0018 = ecx_1180;
					struct Eq_14650 * ecx_1192 = esi_1149->ptr0058;
					esi_1149->dw0050 = edx_1172;
					word32 ebx_1194 = ecx_1192->dw0018;
					ecx_1192->dw0008 = ebx_1194;
					ecx_1192->dw0000 = ebx_1194;
					ecx_1192->dw0004 = ebx_1194;
					ecx_1192->dw0010 = ebx_1194;
					ecx_1192->dw000C = ebx_1194;
					ecx_1192->dw0014 = ebx_1194;
				}
l08051E7E:
				if ((eax_26 ^ gs->t0014) == 0x00)
					return;
				word32 ecx_1953;
				word32 edx_1954;
				__stack_chk_fail(out ecx_1953, out edx_1954);
				_IO_wfile_underflow_maybe_mmap(dwArg04);
				return;
			}
l080521FC:
			goto l08051E7E;
		}
l08051D84:
		Eq_2 ebx_565 = *((word32) dwArg04 + 84);
		int32 eax_583;
		(*((word32) ebx_565 + 16))();
		if (eax_583 <= 0x00)
		{
			Eq_2 eax_592 = *((word32) dwArg04 + 88);
			Eq_2 edi_594 = *((word32) eax_592 + 56);
			word32 edx_597 = *eax_592 - *((word32) eax_592 + 8);
			*((word32) eax_592 + 44) = *((word32) eax_592 + 52);
			*((word32) eax_592 + 48) = edi_594;
			Eq_2 v37_605 = *((word32) dwArg04 + 8);
			word32 eax_615;
			(*((word32) ebx_565 + 24))();
			*((word32) dwArg04 + 4) = (word32) *((word32) dwArg04 + 0x0C) + eax_615;
			Eq_2 ecx_622 = *((word32) dwArg04 + 88);
			*((word32) ecx_622 + 4) = *ecx_622;
			dwLocD0 = v37_605;
		}
		Eq_2 edx_670 = *((word32) dwArg04 + 80);
		Eq_2 eax_671 = *((word32) dwArg04 + 76);
		esp_1008 = fp - 188;
		edx_eax_1921 = SEQ(edx_670, eax_671);
		if ((eax_671 & edx_670) == ~0x00)
		{
l08051DE2:
			((word32) esp_1008 + 32)->u0 = 0x080CEFA0;
			((word32) esp_1008 + 20)->u0 = 0x0354;
			goto l08051E00;
		}
		goto l08051BBA;
	}
	if (*((word32) eax_29 + 24) != 0x00)
	{
		ui32 edx_43 = *dwArg04;
		Eq_2 ebx_42 = *((word32) eax_29 + 0x0C);
		byte dh_104 = SLICE(edx_43, byte, 8);
		if (*((word32) eax_29 + 16) > ebx_42 && (edx_43 & 0x1000) != 0x00)
		{
			Eq_2 edi_53 = *((word32) dwArg04 + 0x0094);
			if (edi_53 >= 135066356)
			{
				word32 ecx_1929;
				word32 edx_1930;
				_IO_vtable_check(out ecx_1929, out edx_1930);
				esp_102.u0 = <invalid>;
			}
			struct Eq_14337 * esp_69 = esp_102 - 4;
			esp_69->dw0000 = 0x02;
			esp_69->dwFFFFFFFC = 0x00;
			esp_69->dwFFFFFFF8 = 0x00;
			esp_69->ptrFFFFFFF4 = esp_69->ptr0014;
			ui32 eax_84;
			ui32 edx_85;
			(*((word32) edi_53 + 64))();
			esp_102 = &esp_69->dw0000 + 1;
			if ((eax_84 & edx_85) == ~0x00)
				goto l080521FC;
			struct Eq_14354 * ecx_93 = esp_69->ptr0014;
			ecx_93->dw004C = eax_84;
			eax_29 = ecx_93->t0058;
			ecx_93->dw0050 = edx_85;
			dh_104 = ecx_93->b0001;
		}
		Eq_2 edi_100 = *((word32) eax_29 + 4);
		Eq_2 ecx_101 = *eax_29;
		*((word32) esp_102 + 20) = edi_100;
		if ((dh_104 & 0x01) != 0x00)
		{
			if (edi_100 > ecx_101)
				goto l080521EF;
			ecx_101 = *((word32) eax_29 + 32);
			Eq_2 eax_116 = *((word32) eax_29 + 40);
			*((word32) esp_102 + 36) = ecx_101;
			*((word32) esp_102 + 20) = eax_116;
		}
		else
			*((word32) esp_102 + 36) = *((word32) eax_29 + 8);
		Eq_2 esi_121 = *((word32) esp_102 + 16);
		*((word32) esp_102 + 24) = ecx_101;
		struct Eq_14409 * esp_124 = esp_102 - 0x0C;
		Eq_2 edi_126 = *((word32) esi_121 + 84);
		esp_124->tFFFFFFFC = edi_126;
		int32 eax_137;
		(*((word32) edi_126 + 16))();
		esp_102 = (char *) &esp_124->ptr0008 + 4;
		if (esp_124->t0014 <= ebx_42)
		{
			Eq_2 edx_295 = *((word32) esi_121 + 8);
			Eq_2 ecx_296 = esp_124->t0024;
			if (eax_137 > 0x00)
			{
				int32 edi_343 = (esp_124->t0020 - ecx_296 >> 0x02) *s eax_137;
				int64 ebx_ecx_1295 = SEQ(-((edi_343 >> 0x1F) + (edi_343 != 0x00)), -edi_343) - (int64) (edx_295 - *((word32) esi_121 + 4));
				esp_124->t0014 = (word32) ebx_ecx_1295;
				esp_124->dw0018 = SLICE(ebx_ecx_1295, word32, 32);
			}
			else
			{
				struct Eq_14408 * eax_299 = esp_124->ptr001C->ptr0058;
				word32 esi_301 = eax_299->dw0038;
				esp_124->dw00A0 = eax_299->dw0034;
				esp_124->dw00A4 = esi_301;
				esp_124->tFFFFFFFC = ecx_296 - esp_124->ptr0030 >> 0x02;
				esp_124->tFFFFFFF8 = edx_295;
				struct Eq_14412 * ebx_312 = esp_124->ptr001C;
				esp_124->dwFFFFFFF4 = ebx_312->dw000C;
				esp_124->ptrFFFFFFF0 = &esp_124->dw00A0;
				esp_124->tFFFFFFEC = edi_126;
				word32 eax_321;
				(*((word32) edi_126 + 24))();
				int64 edx_eax_329 = (int64) (ebx_312->dw0008 - ebx_312->dw000C - eax_321);
				word32 eax_330 = (word32) edx_eax_329;
				esp_124->t0014 = -eax_330;
				esp_124->dw0018 = -((bool) (eax_330 != 0x00) + SLICE(edx_eax_329, word32, 32));
				esp_102 = (char *) &esp_124->ptr0008 + 4;
			}
		}
		else
		{
			Eq_2 edx_eax_1919;
			struct Eq_14408 * ecx_145 = esp_124->ptr001C->ptr0058;
			Eq_2 ebx_146 = ecx_145->t0010;
			word32 edx_147 = ecx_145->dw000C;
			esp_124->t0020 = ebx_146;
			Eq_2 ebx_149 = ebx_146 - edx_147;
			esp_124->t0014 = ebx_149;
			if (eax_137 > 0x00)
				edx_eax_1919.u1 = (int64) ((ebx_149 >> 0x02) *s eax_137);
			else
			{
				esp_124->dw0034 = edx_147;
				esp_124->ptr0030 = ecx_145;
				esp_124->tFFFFFFFC = esp_124->t0014;
				Eq_2 edi_165;
				word32 ebx_1937;
				word32 ebp_1938;
				word32 esi_1939;
				word32 edx_1936;
				word32 ecx_1935;
				Eq_2 eax_161 = __libc_malloc(gs, esp_124->tFFFFFFF8, esp_124->tFFFFFFFC, out ecx_1935, out edx_1936, out ebx_1937, out ebp_1938, out esi_1939, out edi_165);
				struct Eq_14408 * ecx_172 = esp_124->ptr0030;
				word32 edx_173 = esp_124->dw0034;
				esp_124->t0024 = eax_161;
				word32 ebx_175 = ecx_172->dw0034;
				word32 esi_176 = ecx_172->dw0038;
				esp_124->t003C = eax_161;
				esp_124->dw0040 = edx_173;
				esp_124->dw00A0 = ebx_175;
				esp_124->dw00A4 = esi_176;
				esp_124->ptr0008 = (word32 *) &esp_124->t003C;
				Eq_2 eax_185 = esp_124->t0024;
				word32 ecx_187 = Mem184[esp_124 + 0x14:word32] + eax_185;
				esp_124->dw0004 = ecx_187;
				esp_124->t0000 = eax_185;
				esp_124->tFFFFFFFC = &esp_124->dw0040;
				esp_124->tFFFFFFF8 = esp_124->t0020;
				esp_124->dwFFFFFFF4 = edx_173;
				esp_124->ptrFFFFFFF0 = &esp_124->dw00A0;
				esp_124->tFFFFFFEC = edi_165;
				word32 eax_206;
				(*((word32) edi_165 + 4))();
				if (eax_206 != 0x00)
				{
					esp_124->tFFFFFFFC = esp_124->t0024;
					word32 ecx_1940;
					word32 edx_1941;
					free(gs, esp_124->tFFFFFFF8, esp_124->tFFFFFFFC, out ecx_1940, out edx_1941);
					goto l08051E7E;
				}
				Eq_2 ecx_233 = esp_124->t0024;
				Eq_2 edi_236 = esp_124->t003C - ecx_233;
				esp_124->t0014 = edi_236;
				esp_124->dw0018 = SLICE((int64) edi_236, word32, 32);
				esp_124->tFFFFFFFC = ecx_233;
				word32 edx_1943;
				word32 ecx_1942;
				free(gs, esp_124->tFFFFFFF8, esp_124->tFFFFFFFC, out ecx_1942, out edx_1943);
				edx_eax_1919 = esp_124->t0014;
			}
			Eq_14877 edi_270;
			Eq_2 ecx_264 = *((word32) esp_102 + 16);
			Eq_2 edi_266 = *((word32) ecx_264 + 20);
			if (*((word32) esp_102 + 32) == 0x00)
				edi_270 = edi_266 - *((word32) (*((word32) esp_102 + 16)) + 8);
			else
				edi_270 = edi_266 - *((word32) ecx_264 + 16);
			int64 ebx_ecx_1300 = (word64) edx_eax_1919.u1 + SEQ(edi_270 >> 0x1F, edi_270);
			*((word32) esp_102 + 8) = (word32) ebx_ecx_1300;
			*((word32) esp_102 + 0x0C) = SLICE(ebx_ecx_1300, word32, 32);
		}
	}
	Eq_2 eax_365 = *((word32) esp_102 + 16);
	Eq_2 edx_366 = *((word32) eax_365 + 80);
	Eq_2 eax_367 = *((word32) eax_365 + 76);
	int64 edx_eax_1916 = SEQ(edx_366, eax_367);
	if ((eax_367 & edx_366) == ~0x00)
	{
		Eq_2 ebx_374 = *((word32) *((word32) esp_102 + 16) + 0x0094);
		if (ebx_374 >= 135066356)
		{
			word32 ecx_1933;
			word32 edx_1934;
			_IO_vtable_check(out ecx_1933, out edx_1934);
			esp_102.u0 = <invalid>;
		}
		struct Eq_14724 * esp_389 = esp_102 - 4;
		esp_389->dw0000 = 0x01;
		esp_389->dwFFFFFFFC = 0x00;
		esp_389->dwFFFFFFF8 = 0x00;
		esp_389->dwFFFFFFF4 = esp_389->dw0014;
		int64 edx_eax_1926;
		(*((word32) ebx_374 + 64))();
		esp_102 = &esp_389->dw0000 + 1;
		edx_eax_1916 = edx_eax_1926;
		if (((word32) edx_eax_1926 & SLICE(edx_eax_1926, word32, 32)) == ~0x00)
			goto l080521FC;
	}
	if (SLICE((word32) *((word32) esp_102 + 8) + edx_eax_1916, word32, 32) >= 0x00)
		goto l08051E7E;
l080521EF:
	gs->tFFFFFFE0.u0 = 22;
	goto l080521FC;
}

// 080524E0: void _IO_wfile_underflow_maybe_mmap(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
void _IO_wfile_underflow_maybe_mmap(Eq_2 dwArg04)
{
	if (_IO_file_underflow_maybe_mmap(dwArg04) == ~0x00)
		return;
	Eq_2 eax_37 = *((word32) *((word32) *((word32) dwArg04 + 88) + 0x00B0) + 16);
	eax_37();
}

// 08052530: void _IO_wfile_underflow_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wfile_underflow_mmap(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_24 = *dwArg04;
	Eq_2175 eax_20 = gs->t0014;
	if (((byte) eax_24 & 0x04) != 0x00)
	{
		*dwArg04 = eax_24 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		goto l080525EA;
	}
	Eq_2 eax_110 = *((word32) dwArg04 + 88);
	if (*eax_110 < *((word32) eax_110 + 4))
	{
l080525E8:
		goto l080525EA;
	}
	Eq_2 dwLoc24_229;
	Eq_2 edx_114;
	Eq_2 edi_40 = *((word32) dwArg04 + 84);
	Eq_2 ecx_111 = *((word32) dwArg04 + 4);
	if (ecx_111 < *((word32) dwArg04 + 8))
	{
		edx_114 = *((word32) eax_110 + 24);
		dwLoc24_229 = ecx_111;
		if (edx_114 != 0x00)
			goto l0805258C;
	}
	else
	{
		if (_IO_file_underflow_mmap(&g_t80CE000, dwArg04, edi_40, gs, dwLoc50, dwArg04) == ~0x00)
			goto l080525EA;
		eax_110 = *((word32) dwArg04 + 88);
		ecx_111 = *((word32) dwArg04 + 4);
		edx_114 = *((word32) eax_110 + 24);
		dwLoc24_229 = ecx_111;
		if (edx_114 != 0x00)
		{
l0805258C:
			Eq_2 ebp_117 = *((word32) eax_110 + 48);
			word32 edi_118 = *((word32) eax_110 + 44);
			*eax_110 = edx_114;
			*((word32) eax_110 + 8) = edx_114;
			*((word32) eax_110 + 56) = ebp_117;
			struct Eq_15805 * eax_124 = (word32) eax_110 + 44;
			eax_124->dw0008 = edi_118;
			word32 ecx_160;
			(*((word32) edi_40 + 0x0C))();
			*((word32) dwArg04 + 4) = dwLoc24_229;
			Eq_2 eax_164 = *((word32) dwArg04 + 88);
			if (*eax_164 >= *((word32) eax_164 + 4))
			{
				gs->tFFFFFFE0.u0 = 0x54;
				*dwArg04 |= 0x20;
l080525EA:
				if ((eax_20 ^ gs->t0014) == 0x00)
					return;
				word32 ecx_301;
				word32 edx_302;
				__stack_chk_fail(out ecx_301, out edx_302);
				Eq_2 esp_190 = <invalid>;
				word32 ebx_305;
				word32 esi_306;
				_IO_wdo_write(gs, *((word32) esp_190 + 4), *((word32) esp_190 + 8), *((word32) esp_190 + 0x0C), out ebx_305, out esi_306);
				return;
			}
			goto l080525E8;
		}
	}
	Eq_2 eax_75 = *((word32) eax_110 + 32);
	if (eax_75 != 0x00)
	{
		word32 edx_304;
		word32 ecx_303;
		free(gs, dwLoc50, eax_75, out ecx_303, out edx_304);
		*dwArg04 &= ~0x0100;
	}
	_IO_wdoallocbuf(dwArg04);
	eax_110 = *((word32) dwArg04 + 88);
	ecx_111 = *((word32) dwArg04 + 4);
	edx_114 = *((word32) eax_110 + 24);
	goto l0805258C;
}

// 080526A0: Register Eq_2 _IO_wdo_write(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_952 ebxOut, Register out Eq_2 esiOut)
// Called from:
//      _IO_wfile_underflow_mmap
//      _IO_wfile_overflow
//      _IO_wfile_sync
//      _IO_wfile_xsputn
//      _IO_file_close_it
//      _IO_new_file_finish
//      _IO_new_file_overflow
//      _IO_new_file_sync
Eq_2 _IO_wdo_write(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_952 & ebxOut, union Eq_2 & esiOut)
{
	Eq_2 eax_137;
	Eq_2 edx_160;
	Eq_2 ecx_166;
	Eq_2 ebp_150 = dwArg0C;
	Eq_2 edi_22 = dwArg08;
	Eq_2175 eax_24 = gs->t0014;
	if (dwArg0C != 0x00)
	{
		Eq_2 ecx_30 = *((word32) dwArg04 + 84);
		Eq_2 edx_265 = *((word32) dwArg04 + 20);
		Eq_2 ebx_116 = *((word32) dwArg04 + 16);
		if (*((word32) dwArg04 + 24) == edx_265 && edx_265 != ebx_116)
		{
			eax_137 = _IO_do_write(edx_265 - ebx_116);
			if (eax_137 == ~0x00)
				goto l08052806;
			edx_265 = *((word32) dwArg04 + 20);
			ebx_116 = *((word32) dwArg04 + 16);
		}
		while (true)
		{
			Eq_2 dwLoc34_297;
			Eq_2 eax_76;
			if (edx_265 - ebx_116 > 0x0F)
			{
				dwLoc34_297 = edx_265;
				eax_76 = *((word32) dwArg04 + 32);
			}
			else
			{
				ebx_116 = fp - 0x30;
				eax_76 = fp - 0x20;
				dwLoc34_297 = fp - 0x30;
				edx_265 = fp - 0x30;
			}
			Eq_2 eax_104 = *((word32) dwArg04 + 88);
			word32 eax_121;
			(*((word32) ecx_30 + 4))();
			eax_137 = _IO_do_write(dwLoc34_297 - ebx_116);
			if (eax_137 == ~0x00)
				break;
			ebp_150 -= dwLoc38 - edi_22 >> 0x02;
			if (eax_121 != 0x00 && (dwLoc38 == edi_22 || eax_121 != 0x01))
			{
				edx_160 = *((word32) dwArg04 + 88);
				ecx_166 = *((word32) edx_160 + 24);
				*((word32) edx_160 + 8) = ecx_166;
				*edx_160 = ecx_166;
				*((word32) edx_160 + 4) = ecx_166;
				*((word32) edx_160 + 16) = ecx_166;
				*((word32) edx_160 + 0x0C) = ecx_166;
				eax_137 = -(uint32) (int8) (ebp_150 != 0x00);
				if ((*dwArg04 & 0x0202) == 0x00)
					goto l08052800;
				goto l08052803;
			}
			if (ebp_150 == 0x00)
				goto l080527B0;
			edx_265 = *((word32) dwArg04 + 20);
			ebx_116 = *((word32) dwArg04 + 16);
			edi_22 = dwLoc38;
		}
	}
	else
	{
l080527B0:
		edx_160 = *((word32) dwArg04 + 88);
		ui32 eax_188 = *dwArg04;
		Eq_2 ecx_189 = *((word32) edx_160 + 24);
		*((word32) edx_160 + 8) = ecx_189;
		*edx_160 = ecx_189;
		*((word32) edx_160 + 4) = ecx_189;
		*((word32) edx_160 + 16) = ecx_189;
		*((word32) edx_160 + 0x0C) = ecx_189;
		eax_137 = eax_188 & 0x0202;
		if ((eax_188 & 0x0202) != 0x00)
		{
			*((word32) edx_160 + 20) = ecx_189;
			eax_137.u0 = 0x00;
		}
		else
		{
l08052800:
			ecx_166 = *((word32) edx_160 + 28);
l08052803:
			*((word32) edx_160 + 20) = ecx_166;
		}
	}
l08052806:
	if ((eax_24 ^ gs->t0014) != 0x00)
	{
		word32 ecx_437;
		word32 edx_438;
		__stack_chk_fail(out ecx_437, out edx_438);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 eax_251 = _IO_wfile_overflow(gs, stackArg4, stackArg8);
		ebxOut.u0 = <invalid>;
		esiOut = dwArg04;
		return eax_251;
	}
	else
	{
		ebxOut.u0 = <invalid>;
		esiOut = esi;
		return eax_137;
	}
}

// 08052860: Register Eq_2 _IO_wfile_overflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _IO_wdo_write
Eq_2 _IO_wfile_overflow(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 edx_135 = *dwArg04;
	byte dh_41 = SLICE(edx_135, byte, 8);
	if (((byte) edx_135 & 0x08) != 0x00)
	{
		*dwArg04 = edx_135 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		return ~0x00;
	}
	Eq_2 eax_178;
	if ((dh_41 & 0x08) == 0x00)
	{
		Eq_2 dwLoc24_387;
		Eq_2 dwLoc20_388;
		Eq_2 esi_104;
		Eq_2 ebp_107;
		Eq_2 ecx_100;
		Eq_2 eax_119 = *((word32) dwArg04 + 88);
		if (*((word32) eax_119 + 0x0C) != 0x00)
		{
			Eq_2 edi_99 = *((word32) eax_119 + 28);
			ecx_100 = *eax_119;
			dwLoc24_387 = edi_99;
			if (ecx_100 != edi_99)
			{
				ebp_107 = *((word32) eax_119 + 4);
				esi_104 = *((word32) dwArg04 + 4);
				dwLoc20_388 = *((word32) dwArg04 + 8);
			}
			else
			{
				esi_104 = *((word32) dwArg04 + 28);
				ecx_100 = *((word32) eax_119 + 24);
				*((word32) dwArg04 + 8) = esi_104;
				*eax_119 = ecx_100;
				*((word32) eax_119 + 4) = ecx_100;
				ebp_107 = ecx_100;
				dwLoc20_388 = esi_104;
			}
		}
		else
		{
			_IO_wdoallocbuf(dwArg04);
			_IO_free_wbackup_area(dwArg04);
			eax_119 = *((word32) dwArg04 + 88);
			Eq_2 edi_64 = *((word32) dwArg04 + 16);
			ecx_100 = *((word32) eax_119 + 24);
			*((word32) eax_119 + 8) = ecx_100;
			*eax_119 = ecx_100;
			*((word32) eax_119 + 4) = ecx_100;
			if (edi_64 != 0x00)
			{
				ebp_107 = ecx_100;
				edx_135 = (ui32) *dwArg04;
				dwLoc24_387 = *((word32) eax_119 + 28);
				esi_104 = *((word32) dwArg04 + 4);
				dwLoc20_388 = *((word32) dwArg04 + 8);
			}
			else
			{
				_IO_doallocbuf(dwArg04);
				eax_119 = *((word32) dwArg04 + 88);
				esi_104 = *((word32) dwArg04 + 28);
				edx_135 = (ui32) *dwArg04;
				Eq_2 edi_84 = *((word32) eax_119 + 28);
				ecx_100 = *eax_119;
				*((word32) dwArg04 + 8) = esi_104;
				ebp_107 = *((word32) eax_119 + 4);
				dwLoc24_387 = edi_84;
				dwLoc20_388 = esi_104;
			}
		}
		*((word32) eax_119 + 16) = ecx_100;
		*((word32) eax_119 + 0x0C) = ecx_100;
		*((word32) eax_119 + 20) = dwLoc24_387;
		*eax_119 = ebp_107;
		*((word32) eax_119 + 8) = ebp_107;
		*((word32) dwArg04 + 20) = esi_104;
		*((word32) dwArg04 + 16) = esi_104;
		*((word32) dwArg04 + 24) = *((word32) dwArg04 + 32);
		*((word32) dwArg04 + 4) = dwLoc20_388;
		*((word32) dwArg04 + 0x0C) = dwLoc20_388;
		*dwArg04 = edx_135 | 0x0800;
		if ((edx_135 & 0x0202) != 0x00)
		{
			*((word32) eax_119 + 20) = ecx_100;
			if (dwArg08 != ~0x00)
			{
l080528FE:
				Eq_2 edx_205 = *((word32) dwArg04 + 88);
				Eq_2 eax_206 = *((word32) edx_205 + 16);
				if (eax_206 == *((word32) edx_205 + 28))
				{
					int8 al_237;
					if (*((word32) dwArg04 + 0x0068) > 0x00)
					{
						Eq_2 edx_238 = *((word32) edx_205 + 0x0C);
						word32 ebx_518;
						word32 esi_519;
						al_237 = (int8) (_IO_wdo_write(gs, dwArg04, edx_238, eax_206 - edx_238 >> 0x02, out ebx_518, out esi_519) == ~0x00);
					}
					else
						al_237 = (int8) (_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16)) == ~0x00);
					if (al_237 != 0x00)
						return ~0x00;
					edx_205 = *((word32) dwArg04 + 88);
					eax_206 = *((word32) edx_205 + 16);
				}
				Eq_2 ecx_270 = (word32) eax_206 + 4;
				*((word32) edx_205 + 16) = ecx_270;
				*eax_206 = dwArg08;
				ui32 eax_275 = *dwArg04;
				byte ah_280 = SLICE(eax_275, byte, 8);
				if (((byte) eax_275 & 0x02) != 0x00 || (ah_280 & 0x02) != 0x00 && dwArg08 == 0x0A)
				{
					int8 al_323;
					if (*((word32) dwArg04 + 0x0068) > 0x00)
					{
						Eq_2 eax_325 = *((word32) edx_205 + 0x0C);
						word32 esi_517;
						word32 ebx_516;
						al_323 = (int8) (_IO_wdo_write(gs, dwArg04, eax_325, ecx_270 - eax_325 >> 0x02, out ebx_516, out esi_517) == ~0x00);
					}
					else
						al_323 = (int8) (_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16)) == ~0x00);
					if (al_323 != 0x00)
						return ~0x00;
				}
				eax_178 = dwArg08;
				return eax_178;
			}
l080529AE:
			if (*((word32) dwArg04 + 0x0068) > 0x00)
			{
				Eq_2 eax_184 = *((word32) dwArg04 + 88);
				Eq_2 edx_186 = *((word32) eax_184 + 0x0C);
				word32 ebx_520;
				word32 esi_521;
				eax_178 = _IO_wdo_write(gs, dwArg04, edx_186, *((word32) eax_184 + 16) - edx_186 >> 0x02, out ebx_520, out esi_521);
			}
			else
				eax_178 = _IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16));
			return eax_178;
		}
	}
	if (dwArg08 != ~0x00)
		goto l080528FE;
	goto l080529AE;
}

// 08052B30: void _IO_wfile_sync(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wfile_sync(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_20 = *((word32) dwArg04 + 88);
	Eq_2 esp_18 = fp - 44;
	Eq_2 ebx_19 = dwArg04;
	Eq_2 eax_21 = *((word32) edx_20 + 16);
	Eq_2 ecx_22 = *((word32) edx_20 + 0x0C);
	if (eax_21 > ecx_22)
	{
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			Eq_2 esp_69 = <invalid>;
			esp_18 = (word32) esp_69 + 16;
			word32 esi_315;
			if ((int8) (_IO_wdo_write(gs, dwArg04, ecx_22, eax_21 - ecx_22 >> 0x02, out ebx_19, out esi_315) != 0x00) != 0x00)
				return;
		}
		else
		{
			esp_18 = fp - 44;
			if ((int8) (_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16)) != 0x00) != 0x00)
				return;
		}
		edx_20 = *((word32) ebx_19 + 88);
	}
	Eq_2 edi_87 = *edx_20;
	Eq_2 edx_88 = *((word32) edx_20 + 4);
	*((word32) esp_18 + 0x0C) = edx_88;
	if (edi_87 != edx_88)
	{
		int32 edi_146;
		Eq_2 ebp_95 = *((word32) ebx_19 + 84);
		struct Eq_16510 * esp_96 = esp_18 - 0x0C;
		esp_96->tFFFFFFFC = ebp_95;
		int32 eax_107;
		(*((word32) ebp_95 + 16))();
		if (eax_107 > 0x00)
			edi_146 = (edi_87 - esp_96->dw0018 >> 0x02) *s eax_107;
		else
		{
			Eq_2 ecx_113 = *((word32) ebx_19 + 88);
			Eq_2 edx_115 = *((word32) ecx_113 + 56);
			Eq_2 eax_116 = *((word32) ecx_113 + 52);
			int32 edi_119 = *ecx_113 - *((word32) ecx_113 + 8);
			*((word32) ecx_113 + 48) = edx_115;
			*((word32) ecx_113 + 44) = eax_116;
			esp_96->tFFFFFFFC = edi_119 >> 0x02;
			esp_96->tFFFFFFF8 = *((word32) ebx_19 + 8);
			esp_96->tFFFFFFF4 = *((word32) ebx_19 + 0x0C);
			esp_96->ptrFFFFFFF0 = (word32) ecx_113 + 44;
			esp_96->tFFFFFFEC = ebp_95;
			word32 eax_137;
			(*((word32) ebp_95 + 24))();
			Eq_2 edx_140 = *((word32) ebx_19 + 0x0C);
			word32 edx_142 = edx_140 - *((word32) ebx_19 + 8);
			*((word32) ebx_19 + 4) = (word32) edx_140 + eax_137;
			edi_146 = edx_142 + eax_137;
		}
		Eq_2 esp_164 = esp_18;
		Eq_2 ebp_154 = *((word32) ebx_19 + 0x0094);
		if (ebp_154 >= 135066356)
		{
			word32 edx_317;
			word32 ecx_316;
			_IO_vtable_check(out ecx_316, out edx_317);
			esp_164.u0 = <invalid>;
		}
		struct Eq_16604 * esp_174 = esp_164 - 4;
		esp_174->dw0000 = 0x01;
		int64 edx_eax_176 = (int64) edi_146;
		word32 edx_178 = SLICE(edx_eax_176, word32, 32);
		esp_174->dwFFFFFFFC = edx_178;
		esp_174->dwFFFFFFF8 = edi_146;
		esp_174->tFFFFFFF4 = ebx_19;
		ui32 edx_193;
		ui32 eax_194;
		(*((word32) ebp_154 + 64))();
		if ((eax_194 & edx_193) != ~0x00)
		{
			Eq_2 eax_219 = *((word32) ebx_19 + 88);
			*((word32) eax_219 + 4) = *eax_219;
			*((word32) ebx_19 + 8) = *((word32) ebx_19 + 4);
		}
		else if (gs->tFFFFFFE0 != 0x1D)
			return;
	}
	((word32) ebx_19 + 76)->u0 = ~0x00;
	((word32) ebx_19 + 80)->u0 = ~0x00;
}

// 08052CB0: void _IO_wfile_xsputn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_16661 dwArg0C)
void _IO_wfile_xsputn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_16661 dwArg0C)
{
	if (dwArg0C == 0x00)
		return;
	word32 dwLoc24_256;
	Eq_16661 ebx_33;
	Eq_2 ecx_24 = *((word32) dwArg04 + 88);
	Eq_2 ebx_26 = *((word32) ecx_24 + 20);
	Eq_2 edi_133 = *((word32) ecx_24 + 16);
	if ((*dwArg04 & 0x0A00) != 0x0A00)
	{
		dwLoc24_256 = 0x00;
		ebx_33 = ebx_26 - edi_133 >> 0x02;
	}
	else
	{
		int32 ebx_32 = *((word32) ecx_24 + 28) - edi_133;
		dwLoc24_256 = 0x00;
		ebx_33 = ebx_32 >> 0x02;
		if (dwArg0C <= ebx_32 >> 0x02)
		{
			Eq_2 eax_37 = (word32) dwArg08 + dwArg0C * 0x04;
			if (dwArg08 < eax_37)
			{
				Eq_2 esi_41 = eax_37 - 0x04;
				if (*((word32) eax_37 - 4) != 0x0A)
				{
					do
					{
						if (dwArg08 >= esi_41)
						{
							dwLoc24_256 = 0x00;
							goto l08052CF5;
						}
						esi_41 -= (word32 *) 0x04;
					} while (*esi_41 != 0x0A);
				}
				dwLoc24_256 = 0x01;
				ebx_33 = (esi_41 - dwArg08 >> 0x02) + 0x01;
			}
		}
	}
l08052CF5:
	Eq_16661 ebx_155;
	if (ebx_33 != 0x00)
	{
		if (dwArg0C <= ebx_33)
			ebx_33 = dwArg0C;
		if (ebx_33 <= 0x14)
		{
			ui32 eax_122 = ebx_33 * 0x04;
			Eq_2 eax_127 = (word32) edi_133 + eax_122;
			Eq_2 esi_129 = dwArg08;
			do
			{
				*edi_133 = *esi_129;
				esi_129 = (word32) esi_129 + 4;
				edi_133 = (word32) edi_133 + 4;
			} while (edi_133 != eax_127);
			*((word32) ecx_24 + 16) = edi_133;
			dwArg08 = (word32) dwArg08 + eax_122;
		}
		else
		{
			*((word32) ecx_24 + 16) = __wmempcpy(edi_133, dwArg08, ebx_33);
			dwArg08 = (word32) dwArg08 + ebx_33 * 0x04;
		}
		Eq_16661 eax_153 = dwArg0C - ebx_33;
		ebx_155 = eax_153;
		if (eax_153 == 0x00)
		{
l08052D3C:
			if (dwLoc24_256 != 0x00)
			{
				Eq_2 ecx_195 = *((word32) dwArg04 + 88);
				Eq_2 eax_196 = *((word32) ecx_195 + 16);
				Eq_2 ecx_197 = *((word32) ecx_195 + 0x0C);
				if (eax_196 != ecx_197)
				{
					word32 ebx_362;
					word32 esi_363;
					_IO_wdo_write(gs, dwArg04, ecx_197, eax_196 - ecx_197 >> 0x02, out ebx_362, out esi_363);
				}
			}
			return;
		}
	}
	else
		ebx_155 = dwArg0C;
	_IO_wdefault_xsputn(dwArg04, dwArg08, ebx_155);
	goto l08052D3C;
}

// 08052E50: Register Eq_2 vasprintf(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04)
// Called from:
//      ___asprintf
Eq_2 vasprintf(struct Eq_9 * gs, union Eq_2 * dwArg04)
{
	Eq_2 edi_226;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2175 eax_24 = gs->t0014;
	Eq_2 stackArg0 = <invalid>;
	word32 edi_408;
	word32 edx_404;
	word32 ebx_405;
	word32 ebp_406;
	word32 esi_407;
	word32 ecx_403;
	Eq_2 eax_31 = __libc_malloc(gs, stackArg0, 100, out ecx_403, out edx_404, out ebx_405, out ebp_406, out esi_407, out edi_408);
	if (eax_31 == 0x00)
	{
		edi_226.u0 = ~0x00;
		goto l08052F8F;
	}
	_IO_no_init(fp - 0xC0, 0x8000, ~0x00, 0x00, 0x00);
	_IO_str_init_static_internal(fp - 0xC0, eax_31, 100, eax_31);
	word32 ebp_412;
	word32 edi_413;
	word32 ecx_409;
	word32 edx_410;
	word32 ebx_411;
	Eq_2 eax_94 = vfprintf(0x080CE000, gs, fp - 0xC0, dwArg08, dwArg0C, out ecx_409, out edx_410, out ebx_411, out ebp_412, out edi_413);
	edi_226 = eax_94;
	if (eax_94 < 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_416;
		word32 ecx_415;
		free(gs, stackArg0, dwLocA4, out ecx_415, out edx_416);
		goto l08052F8F;
	}
	Eq_2 eax_131;
	Eq_2 esi_119 = dwLocAC - dwLocB0;
	if (dwLocA8 - dwLocB0 >> 0x01 > (word32) esi_119 + 1)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_423;
		word32 edx_424;
		word32 ebx_425;
		word32 ebp_426;
		word32 esi_427;
		word32 edi_428;
		Eq_2 eax_147 = __libc_malloc(gs, stackArg0, (word32) esi_119 + 1, out ecx_423, out edx_424, out ebx_425, out ebp_426, out esi_427, out edi_428);
		*dwArg04 = (union Eq_2 *) eax_147;
		if (eax_147 != 0x00)
		{
			word32 ecx_434;
			word32 edx_435;
			memcpy(eax_147, dwLocA4, esi_119, out ecx_434, out edx_435);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_437;
			word32 edx_438;
			free(gs, stackArg0, dwLocA4, out ecx_437, out edx_438);
			eax_131 = *dwArg04;
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_430;
			word32 ebp_431;
			word32 esi_432;
			word32 edi_433;
			eax_131 = __realloc(gs, stackArg0, dwLocA4, (word32) esi_119 + 1, out edx_430, out ebp_431, out esi_432, out edi_433);
			*dwArg04 = (union Eq_2 *) eax_131;
		}
		if (eax_131 != 0x00)
		{
l08052F8B:
			Mem214[eax_131 + esi_119:byte] = 0x00;
l08052F8F:
			if ((eax_24 ^ gs->t0014) == 0x00)
				return edi_226;
			word32 ecx_439;
			word32 edx_440;
			Eq_2 eax_245 = __stack_chk_fail(out ecx_439, out edx_440);
			backtrace_and_maps.constprop.0();
			return eax_245;
		}
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_418;
		word32 ebp_419;
		word32 esi_420;
		word32 edi_421;
		eax_131 = __realloc(gs, stackArg0, dwLocA4, (word32) esi_119 + 1, out edx_418, out ebp_419, out esi_420, out edi_421);
		*dwArg04 = (union Eq_2 *) eax_131;
		if (eax_131 != 0x00)
			goto l08052F8B;
	}
	*dwArg04 = (union Eq_2 *) dwLocA4;
	eax_131 = dwLocA4;
	goto l08052F8B;
}

// 08053020: void backtrace_and_maps.constprop.0()
// Called from:
//      vasprintf
void backtrace_and_maps.constprop.0()
{
}

// 08053030: void __libc_message(Register (ptr32 Eq_9) gs, Stack ui32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __libc_fatal
//      malloc_printerr
//      __fortify_fail_abort
void __libc_message(struct Eq_9 * gs, ui32 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edi_147 = dwArg08;
	Eq_2175 eax_23 = gs->t0014;
	word32 * dwLoc40_537 = fp + 0x0C;
	if (((byte) dwArg04 & 0x02) != 0x00)
	{
		Eq_2 eax_37 = __libc_secure_getenv(134883300);
		if (eax_37 == 0x00 || *eax_37 == 0x00)
		{
			word32 ecx_839;
			word32 edx_840;
			if (__open_nocancel(gs, 134883319, 0x0902, dwLoc54, out ecx_839, out edx_840) != ~0x00)
			{
l0805306F:
				byte al_86 = *dwArg08;
				struct Eq_17026 * esp_188 = fp - 0x4C;
				ui32 dwLoc38_545 = 0x00;
				byte bLoc30_547 = al_86;
				struct Eq_17032 * dwLoc34_548 = null;
				if (al_86 != 0x00)
				{
					while (true)
					{
						byte dl_100 = bLoc30_547;
						Eq_2 eax_103 = edi_147;
						while (dl_100 != 0x25 || *((word32) eax_103 + 1) != 115)
						{
							struct Eq_17036 * esp_109 = esp_188 - 0x08;
							esp_109->dwFFFFFFFC = 0x25;
							esp_109->tFFFFFFF8 = (word32) eax_103 + 1;
							eax_103 = strchrnul(esp_109->tFFFFFFF8, esp_109->t0004);
							dl_100 = (byte) *eax_103;
							if (dl_100 == 0x00)
								break;
						}
						Eq_2 ecx_164;
						Eq_2 ebx_151;
						if (bLoc30_547 != 0x25 || *((word32) edi_147 + 1) != 115)
						{
							ebx_151 = edi_147;
							ecx_164 = eax_103 - edi_147;
							edi_147 = eax_103;
						}
						else
						{
							struct Eq_17175 * esp_146 = esp_188 - (struct Eq_17176 *) 0x0C;
							ebx_151 = *dwLoc40_537;
							esp_146->tFFFFFFFC = ebx_151;
							edi_147 = (word32) edi_147 + 2;
							++dwLoc40_537;
							word32 edx_842;
							word32 ecx_841;
							ecx_164 = strlen(esp_146->tFFFFFFFC, out ecx_841, out edx_842);
						}
						esp_188 -= 0x20;
						esp_188->dw001C = esp_188->dw001C;
						word32 edx_201 = esp_188 + 0x0F & ~0x0F;
						edx_201->ptr0008 = dwLoc34_548;
						edx_201->t0000 = ebx_151;
						edx_201->t0004 = ecx_164;
						byte al_218 = *edi_147;
						ui32 dwLoc3C_574 = dwLoc38_545 + 0x01;
						bLoc30_547 = al_218;
						if (al_218 == 0x00)
							break;
						dwLoc34_548 = edx_201;
						dwLoc38_545 = dwLoc3C_574;
					}
					ui32 eax_227 = dwLoc3C_574 * 0x08 + 0x1B;
					Eq_2 ebx_225 = ecx_164;
					struct Eq_17026 * ecx_230 = esp_188 - (eax_227 & ~0x0FFF);
					while (esp_188 != ecx_230)
					{
						esp_188 -= (struct Eq_17129 *) 0x1000;
						esp_188->dw0FFC = esp_188->dw0FFC;
					}
					struct Eq_17122 * eax_253 = eax_227 & ~0x0F & 0x0FFF;
					if (eax_253 != null)
					{
						esp_188 -= eax_253;
						Mem260[esp_188 - 0x04 + eax_253:word32] = Mem249[esp_188 - 0x04 + eax_253:word32];
					}
					word32 eax_264 = esp_188 + 0x0F;
					struct Eq_17032 * edx_273 = dwLoc34_548;
					ui32 dwLoc40_586 = dwLoc38_545 << 0x03;
					struct Eq_17154 * eax_279 = (eax_264 & ~0x0F) + (dwLoc38_545 << 0x03);
					int32 edi_280 = 0x00;
					Eq_2 ecx_284 = ebx_151;
					while (true)
					{
						eax_279->dw0000 = (word32) ecx_284;
						eax_279->dw0004 = (word32) ebx_225;
						int32 ebx_292 = (word32) ebx_225 + edi_280;
						struct Eq_17154 * ecx_288 = eax_279 - 0x08;
						edi_280 = ebx_292;
						if ((eax_264 & ~0x0F) == eax_279)
							break;
						ecx_284 = edx_273->t0000;
						ebx_225 = edx_273->t0004;
						eax_279 = ecx_288;
						edx_273 = edx_273->ptr0008;
					}
					do
					{
						word32 eax_317;
						word32 edx_318;
						word32 ecx_319;
						gs->ptr0010();
					} while (eax_317 == ~0x03);
					if ((dwArg04 & 0x01) == 0x00)
					{
l080532A7:
						if ((eax_23 ^ gs->t0014) == 0x00)
							return;
						word32 ecx_850;
						word32 edx_851;
						__stack_chk_fail(out ecx_850, out edx_851);
						word32 ecx_852;
						__libc_fatal(out ecx_852);
						return;
					}
					struct Eq_17221 * esp_329 = esp_188 - (struct Eq_17222 *) 0x08;
					Eq_2 eax_330 = _dl_pagesize;
					esp_329->tFFFFFFFC.u0 = 0x00;
					esp_329->tFFFFFFF8.u0 = ~0x00;
					esp_329->tFFFFFFF4.u0 = 0x22;
					esp_329->tFFFFFFF0.u0 = 0x03;
					Eq_2 edi_339 = (word32) eax_330 + ebx_292 & -eax_330;
					esp_329->tFFFFFFEC = edi_339;
					esp_329->tFFFFFFE8.u0 = 0x00;
					word32 ecx_843;
					word32 edx_844;
					Eq_2 eax_348 = mmap(gs, esp_329->tFFFFFFE8, esp_329->tFFFFFFEC, esp_329->tFFFFFFF0, esp_329->tFFFFFFF4, esp_329->tFFFFFFF8, esp_329->tFFFFFFFC, out ecx_843, out edx_844);
					if (eax_348 != ~0x00)
					{
						*eax_348 = edi_339;
						Eq_2 eax_361 = (word32) eax_348 + 4;
						struct Eq_17293 * ebx_364 = (eax_264 & ~0x0F) + 0x04;
						struct Eq_17293 * edi_365 = (eax_264 & ~0x0F) + 0x08 + dwLoc40_586;
						do
						{
							struct Eq_17302 * esp_368 = esp_188 - (struct Eq_17303 *) 0x04;
							esp_368->tFFFFFFFC = ebx_364->dw0000;
							++ebx_364;
							esp_368->tFFFFFFF8 = ebx_364->dwFFFFFFF8;
							esp_368->tFFFFFFF4 = eax_361;
							word32 edx_846;
							eax_361 = __mempcpy(esp_368->tFFFFFFF4, esp_368->tFFFFFFF8, esp_368->tFFFFFFFC, out edx_846);
						} while (ebx_364 != edi_365);
						*eax_361 = 0x00;
						Eq_2 v23_398 = __abort_msg;
						__abort_msg = eax_348;
						if (v23_398 != 0x00)
						{
							esp_368->tFFFFFFF8 = *v23_398;
							esp_368->tFFFFFFF4 = v23_398;
							word32 ecx_847;
							word32 edx_848;
							word32 ebx_849;
							__munmap(v23_398, gs, esp_368->tFFFFFFF4, esp_368->tFFFFFFF8, out ecx_847, out edx_848, out ebx_849);
						}
					}
l08053297:
					Eq_2 ecx_431;
					word32 edx_845;
					abort(ecx_431, gs, out ecx_431, out edx_845);
				}
				if ((dwArg04 & 0x01) == 0x00)
					goto l080532A7;
				goto l08053297;
			}
		}
	}
	goto l0805306F;
}

// 08053320: Register word32 __libc_fatal(Register out (ptr32 (arr Eq_2)) ecxOut)
// Called from:
//      __libc_start_main
//      __libc_message
//      _IO_vtable_check
//      printf_positional
//      printf_positional
//      __libc_disable_asynccancel
word32 __libc_fatal(Eq_2 (& ecxOut)
{
	while (true)
		__libc_message(gs, 0x03, 134976566);
}

// 08053360: Register ptr32 _IO_vtable_check(Register out Eq_952 ecxOut, Register out Eq_12431 edxOut)
// Called from:
//      __new_fclose
//      fflush
//      _IO_puts
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_sync
//      _IO_file_seekoff_maybe_mmap
//      new_do_write
//      _IO_new_file_underflow
//      mmap_remap_check
//      decide_maybe_mmap
//      _IO_file_underflow_maybe_mmap
//      _IO_file_xsgetn_maybe_mmap
//      _IO_new_file_seekoff
//      _IO_file_xsgetn_mmap
//      _IO_file_xsgetn
//      _IO_file_seekoff_mmap
//      _IO_file_underflow_mmap
//      _IO_file_xsputn
//      _IO_file_open
//      _IO_file_attach
//      _IO_file_close_it
//      _IO_new_file_finish
//      _IO_new_file_sync
//      _IO_switch_to_get_mode
//      __overflow
//      __underflow
//      __uflow
//      _IO_doallocbuf
//      _IO_default_uflow
//      _IO_default_xsputn
//      _IO_sgetn
//      _IO_default_setbuf
//      _IO_default_seekpos
//      _IO_sputbackc
//      _IO_sungetc
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      _IO_helper_overflow
//      printf_positional
//      vfprintf
//      buffered_vfprintf
//      __printf_fp_l
//      _IO_helper_overflow
//      printf_positional
//      __vfwprintf
//      buffered_vfprintf
//      _IO_file_doallocate
//      fputs
//      fwrite
//      _IO_padn
//      _IO_wpadn
//      _IO_wdefault_uflow
//      __woverflow
//      __wuflow
//      __wunderflow
//      _IO_sputbackwc
//      _IO_sungetwc
ptr32 _IO_vtable_check(union Eq_952 & ecxOut, union Eq_12431 & edxOut)
{
	ecxOut.u0 = <invalid>;
	edxOut.u0 = 0x08099D30;
	return 0x080CE000;
}

// 08053390: Register Eq_2 fgets_unlocked(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_7503 edxOut)
// Called from:
//      read_alias_file
//      _IO_vtable_check
Eq_2 fgets_unlocked(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_7503 & edxOut)
{
	if (dwArg08 <= 0x00)
	{
		edxOut = edx;
		return 0x00;
	}
	Eq_2 ecx_40;
	if (dwArg08 == 0x01)
	{
		*dwArg04 = 0x00;
		ecx_40 = dwArg04;
		goto l080533EC;
	}
	Eq_7503 edx_41 = *dwArg0C;
	*dwArg0C = edx_41 & ~0x20;
	int32 eax_60 = _IO_getline();
	edx = *dwArg0C;
	byte dl_70 = (byte) edx;
	ecx_40.u0 = 0x00;
	if (eax_60 != 0x00)
	{
		if ((dl_70 & 0x20) != 0x00)
		{
			ecx_40.u0 = 0x00;
			if (gs->tFFFFFFE0 != 11)
				goto l080533E7;
		}
		*((word32) dwArg04 + eax_60) = 0x00;
		ecx_40 = dwArg04;
		edx = *dwArg0C;
		goto l080533E7;
	}
	else
	{
l080533E7:
		*dwArg0C = edx_41 & 0x20 | edx;
l080533EC:
		edxOut = edx;
		return ecx_40;
	}
}

// 08053440: void _IO_file_seekoff_maybe_mmap(Stack (ptr32 Eq_17446) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
void _IO_file_seekoff_maybe_mmap(struct Eq_17446 * dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	struct Eq_17450 * ebp_25 = dwArg04->ptr0094;
	if (ebp_25 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 ecx_109;
		word32 edx_110;
		_IO_vtable_check(out ecx_109, out edx_110);
	}
	int32 edx_53;
	word32 eax_54;
	ebp_25->ptr0040();
	if (edx_53 >= 0x00)
	{
		dwArg04->dw004C = eax_54;
		dwArg04->dw0050 = edx_53;
	}
}

// 080534C0: void _IO_file_close(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_17476) dwArg04)
void _IO_file_close(struct Eq_9 * gs, struct Eq_17476 * dwArg04)
{
	Eq_2 eax_6 = dwArg04->t0038;
	word32 edx_17;
	__close_nocancel(gs, eax_6, out edx_17);
}

// 080534E0: void _IO_new_file_setbuf(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_17486) dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
void _IO_new_file_setbuf(struct Eq_9 * gs, struct Eq_17486 * dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	if (_IO_default_setbuf(gs, dwArg04, dwArg08, dwArg0C) != 0x00)
	{
		Eq_2 eax_35 = dwArg04->t001C;
		dwArg04->t0018 = eax_35;
		dwArg04->t0014 = eax_35;
		dwArg04->t0010 = eax_35;
		dwArg04->t000C = eax_35;
		dwArg04->t0004 = eax_35;
		dwArg04->t0008 = eax_35;
	}
}

// 08053530: void _IO_file_setbuf_mmap(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_17486) dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
void _IO_file_setbuf_mmap(struct Eq_9 * gs, struct Eq_17486 * dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	dwArg04->ptr0094 = (struct Eq_17524 *) &g_t80CF180;
	dwArg04->ptr0058->ptr00B0 = 0x080CF060;
	if (_IO_default_setbuf(gs, dwArg04, dwArg08, dwArg0C) != 0x00)
	{
		Eq_2 eax_45 = dwArg04->t001C;
		dwArg04->t0018 = eax_45;
		dwArg04->t0014 = eax_45;
		dwArg04->t0010 = eax_45;
		dwArg04->t000C = eax_45;
		dwArg04->t0004 = eax_45;
		dwArg04->t0008 = eax_45;
	}
	else
	{
		dwArg04->ptr0094 = (struct Eq_17524 *) &g_t80CF120;
		dwArg04->ptr0058->ptr00B0 = 0x080CF000;
	}
}

// 080535C0: Register (ptr32 Eq_17572) new_do_write(Register (ptr32 Eq_17572) eax, Register Eq_2 ecx, Register (ptr32 Eq_17574) edx)
// Called from:
//      _IO_file_xsputn
//      _IO_do_write
struct Eq_17572 * new_do_write(struct Eq_17572 * eax, Eq_2 ecx, struct Eq_17574 * edx)
{
	struct Eq_17572 * ebp_125;
	Eq_2 ecx_100;
	Eq_2 ebp_23 = eax->t0094;
	Eq_2 eax_118 = 0x0354;
	ptr32 edx_116 = ebp_23 - 0x080CEFA0;
	if ((eax->dw0000 & 0x1000) != 0x00)
	{
		eax->t004C.u0 = ~0x00;
		eax->dw0050 = ~0x00;
		ecx_100 = ecx;
	}
	else
	{
		ecx_100 = eax->t0008;
		eax_118 = eax->t0010;
		if (ecx_100 != eax_118)
		{
			if (ebp_23 >= 135066356)
			{
				word32 ecx_260;
				word32 edx_261;
				_IO_vtable_check(out ecx_260, out edx_261);
				eax_118 = eax->t0010;
				ecx_100 = eax->t0008;
			}
			int64 edx_eax_54 = (int64) (eax_118 - ecx_100);
			word32 edx_56 = SLICE(edx_eax_54, word32, 32);
			word32 eax_59 = (word32) edx_eax_54;
			ui32 edx_68;
			(*((word32) ebp_23 + 64))();
			ebp_125 = null;
			ecx_100 = eax_118 & edx_68;
			if (ecx_100 == ~0x00)
				return ebp_125;
			ebp_23 = eax->t0094;
			eax->dw0050 = edx_68;
			eax->t004C = eax_118;
			edx_116 = ebp_23 - 0x080CEFA0;
		}
	}
	if (edx_116 >= 0x0354)
		eax_118 = _IO_vtable_check(out ecx_100, out edx_116);
	struct Eq_17572 * eax_122;
	(*((word32) ebp_23 + 60))();
	word32 eax_126 = (word32) eax->w0044;
	ebp_125 = eax_122;
	if ((word16) eax_126 != 0x00 && eax_122 != null)
		eax->w0044 = _IO_adjust_column(eax_126 - 0x01, edx, eax_122) + 0x01;
	Eq_2 eax_158 = eax->t001C;
	int32 edx_159 = eax->dw0068;
	eax->t000C = eax_158;
	eax->t0004 = eax_158;
	eax->t0008 = eax_158;
	eax->t0014 = eax_158;
	eax->t0010 = eax_158;
	if (edx_159 > 0x00 || (eax->dw0000 & 0x0202) == 0x00)
		eax_158 = eax->t0020;
	eax->t0018 = eax_158;
	return ebp_125;
}

// 080536F0: void _IO_new_file_underflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_new_file_underflow(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_100 = *dwArg04;
	byte al_22 = (byte) eax_100;
	if ((al_22 & 0x10) != 0x00)
		return;
	if ((al_22 & 0x04) != 0x00)
	{
		*dwArg04 = eax_100 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		return;
	}
	if (*((word32) dwArg04 + 4) < *((word32) dwArg04 + 8))
		return;
	if (*((word32) dwArg04 + 28) == 0x00)
	{
		Eq_2 eax_55 = *((word32) dwArg04 + 36);
		if (eax_55 != 0x00)
		{
			word32 edx_566;
			word32 ecx_565;
			free(gs, dwLoc40, eax_55, out ecx_565, out edx_566);
			*dwArg04 &= ~0x0100;
		}
		_IO_doallocbuf(dwArg04);
		eax_100 = (ui32) *dwArg04;
	}
	Eq_2 esp_175 = fp - 44;
	if ((eax_100 & 0x0202) == 0x00)
	{
l080537E0:
		struct Eq_17769 * esp_253 = esp_175 - 0x0C;
		esp_253->tFFFFFFFC = dwArg04;
		word32 ecx_560;
		_IO_switch_to_get_mode(esp_253->tFFFFFFFC, out ecx_560);
		Eq_2 eax_269 = *((word32) dwArg04 + 28);
		Eq_2 ebx_270 = *((word32) dwArg04 + 0x0094);
		*((word32) dwArg04 + 4) = eax_269;
		*((word32) dwArg04 + 0x0C) = eax_269;
		*((word32) dwArg04 + 8) = eax_269;
		*((word32) dwArg04 + 24) = eax_269;
		*((word32) dwArg04 + 20) = eax_269;
		*((word32) dwArg04 + 16) = eax_269;
		Eq_2 esp_271 = (char *) &esp_253->tFFFFFFFC + 16;
		if (ebx_270 >= 135066356)
		{
			word32 ecx_563;
			word32 edx_564;
			_IO_vtable_check(out ecx_563, out edx_564);
			esp_271.u0 = <invalid>;
			eax_269 = *((word32) dwArg04 + 28);
		}
		struct Eq_17964 * esp_297 = esp_271 - 0x04;
		word32 edx_299 = *((word32) dwArg04 + 32) - eax_269;
		esp_297->dwFFFFFFFC = edx_299;
		esp_297->tFFFFFFF8 = eax_269;
		esp_297->tFFFFFFF4 = dwArg04;
		Eq_17981 eax_317;
		word32 ecx_319;
		(*((word32) ebx_270 + 56))();
		if (eax_317 <= 0x00)
		{
			ui32 edx_324 = *dwArg04;
			((word32) dwArg04 + 76)->u0 = ~0x00;
			((word32) dwArg04 + 80)->u0 = ~0x00;
			ui32 edx_328 = edx_324 | 0x10;
			if (eax_317 != 0x00)
				edx_328 = edx_324 | 0x20;
			*dwArg04 = edx_328;
			return;
		}
		else
		{
			Eq_2 ecx_348 = *((word32) dwArg04 + 76);
			Eq_2 ebx_349 = *((word32) dwArg04 + 80);
			Mem351[dwArg04 + 0x08:word32] = Mem306[dwArg04 + 0x08:word32] + eax_317;
			if ((ecx_348 & ebx_349) != ~0x00)
			{
				int64 edx_eax_384 = (int64) eax_317 + SEQ(ebx_349, ecx_348);
				*((word32) dwArg04 + 76) = (word32) edx_eax_384;
				*((word32) dwArg04 + 80) = SLICE(edx_eax_384, word32, 32);
			}
			return;
		}
	}
	Eq_2 ecx_118;
	Eq_2 ecx_106 = _IO_stdout;
	ui32 eax_107 = *ecx_106;
	if ((eax_107 & 0x8000) == 0x00)
	{
		Eq_2 edx_119 = *((word32) ecx_106 + 72);
		Eq_2 ebx_122 = gs->t0008;
		ecx_118 = ecx_106;
		if (*((word32) edx_119 + 8) != ebx_122)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_133;
			if (!__cmpxchg(*edx_119, 0x01, eax_107 & 0x8000, out eax_133))
				__lll_lock_wait_private(eax_133, edx_119, gs);
			edx_119 = *((word32) ecx_106 + 72);
			ecx_118 = _IO_stdout;
			*((word32) edx_119 + 8) = ebx_122;
			eax_107 = (ui32) *ecx_118;
		}
		*((word32) edx_119 + 4) = (word32) *((word32) edx_119 + 4) + 1;
		if ((eax_107 & 0x0288) != 0x0280)
		{
l080537C2:
			if ((*ecx_106 & 0x8000) == 0x00)
			{
				Eq_2 edx_229 = *((word32) ecx_106 + 72);
				Eq_2 v17_230 = *((word32) edx_229 + 4) - 0x01;
				*((word32) edx_229 + 4) = v17_230;
				if (v17_230 == 0x00)
				{
					((word32) edx_229 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v19_240 = *edx_229 - 0x01;
					*edx_229 = v19_240;
					if (v19_240 != 0x00)
						__lll_unlock_wake_private(edx_229, ecx_118, edx_229, gs);
				}
			}
			goto l080537E0;
		}
	}
	else
	{
		if ((eax_107 & 0x0288) != 0x0280)
			goto l080537E0;
		ecx_118 = ecx_106;
	}
	Eq_2 ebx_166 = *((word32) ecx_118 + 0x0094);
	if (ebx_166 >= 135066356)
	{
		word32 edx_562;
		word32 ecx_561;
		_IO_vtable_check(out ecx_561, out edx_562);
		esp_175.u0 = <invalid>;
	}
	struct Eq_17935 * esp_186 = esp_175 - 0x08;
	esp_186->dwFFFFFFFC = ~0x00;
	esp_186->tFFFFFFF8 = _IO_stdout;
	word32 edx_215;
	(*((word32) ebx_166 + 0x0C))();
	esp_175 = &esp_186->dwFFFFFFFC + 3;
	goto l080537C2;
}

// 08053990: void _IO_file_close_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_file_close_mmap(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_9 = *((word32) dwArg04 + 28);
	struct Eq_18066 * ebx_19;
	word32 ecx_45;
	word32 edx_46;
	__munmap(dwArg04, gs, edx_9, *((word32) dwArg04 + 32) - edx_9, out ecx_45, out edx_46, out ebx_19);
	Eq_2 eax_26 = ebx_19->t0038;
	ebx_19->dw0020 = 0x00;
	ebx_19->dw001C = 0x00;
	word32 edx_47;
	__close_nocancel(gs, eax_26, out edx_47);
}

// 080539D0: Register Eq_2 mmap_remap_check(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_15766) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out Eq_2 ebpOut, Register out (ptr32 Eq_18102) ediOut)
// Called from:
//      _IO_file_xsgetn_mmap
//      _IO_file_underflow_mmap
Eq_2 mmap_remap_check(Eq_2 eax, struct Eq_9 * gs, struct Eq_15766 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, union Eq_2 & ebpOut, struct Eq_18102 & ediOut)
{
	Eq_2 ebp_277 = 0x080CE000;
	Eq_2 ebx_149 = eax;
	Eq_2 esp_20 = fp - 0xAC;
	Eq_2 esi_21 = *((word32) eax + 0x0094);
	Eq_2175 eax_23 = gs->t0014;
	if (esi_21 >= 135066356)
	{
		word32 edx_466;
		word32 ecx_465;
		_IO_vtable_check(out ecx_465, out edx_466);
		esp_20.u0 = <invalid>;
	}
	struct Eq_18125 * ebx_102;
	struct Eq_18126 * esp_41 = esp_20 - 0x08;
	esp_41->tFFFFFFFC = (char *) &esp_41->t0020 + 20;
	esp_41->tFFFFFFF8 = eax;
	Eq_2 eax_54;
	(*((word32) esi_21 + 72))();
	Eq_2 eax_60 = *((word32) eax + 28);
	Eq_2 edx_62 = *((word32) eax + 32) - eax_60;
	esp_41->t0020 = eax_60;
	esp_41->t0010 = edx_62;
	Eq_2 esi_239 = eax_54;
	if (eax_54 == 0x00 && (esp_41->dw0044 & 0xF000) == 0x8000)
	{
		uint32 eax_72 = esp_41->dw0060;
		esp_41->dw001C = esp_41->dw0064;
		ui32 ecx_76 = eax_72 | esp_41->dw001C;
		esp_41->dw0018 = eax_72;
		if (ecx_76 != 0x00 && (eax_54 - esp_41->dw001C) - (word32) (esp_41->dw0018 > 0x000FFFFF) >= 0x00)
		{
			Eq_2 eax_111 = __getpagesize();
			Eq_2 esp_113 = <invalid>;
			((word32) esp_113 + 0x0C)->u0 = 0x00;
			word32 edx_122 = eax_111 + Mem118[esp_113 + 0x10:word32];
			*((word32) esp_113 + 28) = -eax_111;
			Eq_2 edi_127 = *((word32) esp_113 + 28) & edx_122 + ~0x00;
			Eq_2 edx_129 = (word32) *((word32) esp_113 + 8) + (eax_111 - 0x01) & *((word32) esp_113 + 28);
			int32 ecx_133 = eax_54 - *((word32) esp_113 + 0x0C) - (word32) (edi_127 < edx_129);
			*((word32) esp_113 + 8) = edx_129;
			if (ecx_133 < 0x00)
			{
				uint32 eax_140 = (word32) *((word32) esp_113 + 16) + (eax_111 - 0x01) & *((word32) esp_113 + 28);
				*((word32) esp_113 - 0x0C) = edx_129 - eax_140;
				*((word32) esp_113 - 16) = (word32) *((word32) esp_113 + 24) + eax_140;
				word32 ecx_469;
				word32 edx_470;
				__munmap(eax, gs, *((word32) esp_113 - 16), *((word32) esp_113 - 0x0C), out ecx_469, out edx_470, out ebx_149);
				Eq_2 eax_156 = *((word32) ebx_149 + 28);
				word32 ecx_158 = Mem147[esp_113 + 88:word32] + eax_156;
				*((word32) esp_113 + 24) = eax_156;
				*((word32) esp_113 + 8) = ecx_158;
				*((word32) ebx_149 + 32) = ecx_158;
				goto l08053B14;
			}
			if (*((word32) esp_113 + 0x0C) - (word32) (edx_129 < edi_127) >= 0x00)
			{
				word32 ecx_171 = Mem135[esp_113 + 0x10:word32] + Mem135[esp_113 + 0x18:word32];
				*((word32) esp_113 + 8) = ecx_171;
				*((word32) eax + 32) = ecx_171;
				goto l08053B14;
			}
			((word32) esp_113 - 4)->u0 = 0x01;
			*((word32) esp_113 - 8) = (word32) *((word32) esp_113 + 16) + (eax_111 - 0x01) & *((word32) esp_113 + 28);
			*((word32) esp_113 - 0x0C) = edx_129;
			*((word32) esp_113 - 16) = *((word32) esp_113 + 24);
			word32 edx_471;
			Eq_2 eax_189 = __mremap(gs, *((word32) esp_113 - 16), *((word32) esp_113 - 0x0C), *((word32) esp_113 - 8), *((word32) esp_113 - 4), *esp_113, out edx_471);
			*((word32) esp_113 + 24) = eax_189;
			if (eax_189 != ~0x00)
			{
				Eq_2 eax_242 = *((word32) esp_113 + 24);
				word32 ecx_244 = Mem196[esp_113 + 88:word32] + eax_242;
				*((word32) eax + 28) = eax_242;
				*((word32) esp_113 + 8) = ecx_244;
				*((word32) eax + 32) = ecx_244;
l08053B14:
				ui64 ebp_edi_373 = *((word32) ebx_149 + 76) - (int64) (*((word32) ebx_149 + 8) - *((word32) ebx_149 + 4));
				Eq_2 edi_257 = (word32) ebp_edi_373;
				Eq_2 ecx_260 = *((word32) esp_113 + 24);
				*((word32) ebx_149 + 76) = edi_257;
				Eq_2 ebp_263 = SLICE(ebp_edi_373, word32, 32);
				*((word32) ebx_149 + 80) = ebp_263;
				Eq_2 ebp_268 = *((word32) esp_113 + 8);
				*((word32) ebx_149 + 0x0C) = ecx_260;
				Eq_2 ebp_270 = ebp_268 - ecx_260;
				*((word32) esp_113 + 16) = ebp_270;
				Eq_2 edi_275 = *((word32) esp_113 + 16);
				*((word32) esp_113 + 20) = ebp_270 >> 0x1F;
				ebp_277 = *((word32) esp_113 + 20);
				if (ebp_263 - ebp_277 - (word32) (edi_257 < ebp_270) < 0x00)
				{
					Mem288[ebx_149 + 0x04:word32] = edi_257 + Mem276[esp_113 + 0x18:word32];
					Eq_2 eax_289 = *((word32) esp_113 + 8);
					((word32) esp_113 - 4)->u0 = 0x00;
					*((word32) ebx_149 + 8) = eax_289;
					*((word32) esp_113 - 8) = ebp_277;
					*((word32) esp_113 - 0x0C) = edi_275;
					*((word32) esp_113 - 16) = *((word32) ebx_149 + 56);
					struct Eq_18494 * ebx_302;
					word32 edx_305;
					word32 edi_474;
					Eq_2 eax_301 = lseek64(gs, *((word32) esp_113 - 16), *((word32) esp_113 - 0x0C), *((word32) esp_113 - 8), *((word32) esp_113 - 4), out edx_305, out ebx_302, out esi_239, out edi_474);
					int32 ecx_313 = ebx_302->dw0020 - ebx_302->dw001C;
					ebp_277 = ecx_313 >> 0x1F;
					if ((edx_305 ^ ecx_313 >> 0x1F | eax_301 ^ ecx_313) != 0x00)
						ebx_302->dw0000 |= 0x20;
					else
					{
						ebx_302->dw004C = ecx_313;
						ebx_302->dw0050 = ecx_313 >> 0x1F;
					}
				}
				else
				{
					Eq_2 eax_283 = *((word32) esp_113 + 8);
					*((word32) ebx_149 + 4) = eax_283;
					*((word32) ebx_149 + 8) = eax_283;
				}
				goto l08053BF9;
			}
			Eq_2 edx_200 = *((word32) eax + 28);
			*((word32) esp_113 - 0x0C) = *((word32) eax + 32) - edx_200;
			*((word32) esp_113 - 16) = edx_200;
			word32 ecx_472;
			word32 edx_473;
			__munmap(eax, gs, *((word32) esp_113 - 16), *((word32) esp_113 - 0x0C), out ecx_472, out edx_473, out ebx_102);
l08053BB3:
			ptr32 edx_231;
			int32 eax_221 = ebx_102->dw0068;
			ebx_102->dw0020 = 0x00;
			ebx_102->dw001C = 0x00;
			ebx_102->dw000C = 0x00;
			ebx_102->dw0004 = 0x00;
			ebx_102->dw0008 = 0x00;
			if (eax_221 > 0x00)
				edx_231 = 0x080CF060;
			else
				edx_231 = 0x080CF180;
			ebx_102->ptr0094 = edx_231;
			ebx_102->ptr0058->ptr00B0 = 0x080CF060;
			esi_239.u0 = 0x01;
l08053BF9:
			if ((eax_23 ^ gs->t0014) != 0x00)
			{
				word32 ecx_475;
				word32 edx_476;
				__stack_chk_fail(out ecx_475, out edx_476);
				ptr32 ebx_352;
				struct Eq_18102 * edi_354;
				Eq_2 eax_351 = _IO_file_seek(gs, dwArg04, dwArg08, dwArg0C, dwArg10, out ebx_352, out edi_354);
				ebxOut = ebx_352;
				ebpOut = ebp_277;
				ediOut = edi_354;
				return eax_351;
			}
			else
			{
				ebxOut = ebx;
				ebpOut = ebp;
				ediOut = edi;
				return esi_239;
			}
		}
	}
	esp_41->tFFFFFFFC = esp_41->t0010;
	esp_41->tFFFFFFF8 = esp_41->t0020;
	word32 edx_468;
	word32 ecx_467;
	__munmap(eax, gs, esp_41->tFFFFFFF8, esp_41->tFFFFFFFC, out ecx_467, out edx_468, out ebx_102);
	goto l08053BB3;
}

// 08053CD0: Register Eq_2 _IO_file_seek(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_15766) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out ptr32 ediOut)
// Called from:
//      mmap_remap_check
Eq_2 _IO_file_seek(struct Eq_9 * gs, struct Eq_15766 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, ptr32 & ediOut)
{
	Eq_2 eax_6 = dwArg04->t0038;
	ptr32 ebx_10;
	ptr32 edi_12;
	word32 edx_27;
	word32 esi_28;
	Eq_2 eax_9 = lseek64(gs, eax_6, dwArg08, dwArg0C, dwArg10, out edx_27, out ebx_10, out esi_28, out edi_12);
	ebxOut = ebx_10;
	ediOut = edi_12;
	return eax_9;
}

// 08053CF0: void _IO_file_sync_mmap(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_18698) dwArg04)
void _IO_file_sync_mmap(struct Eq_9 * gs, struct Eq_18698 * dwArg04)
{
	Eq_2 ecx_14 = dwArg04->t0004;
	int64 edx_eax_17 = (int64) (ecx_14 - dwArg04->t001C);
	struct Eq_18698 * ebx_13 = dwArg04;
	Eq_2 edx_23 = SLICE(edx_eax_17, word32, 32);
	Eq_2 eax_26 = (word32) edx_eax_17;
	if (ecx_14 != dwArg04->t0008)
	{
		word32 esi_110;
		word32 edi_111;
		eax_26 = lseek64(gs, dwArg04->t0038, eax_26, edx_23, 0x00, out edx_23, out ebx_13, out esi_110, out edi_111);
		int32 ecx_44 = ebx_13->t0004 - ebx_13->t001C;
		if ((ecx_44 >> 0x1F ^ edx_23 | ecx_44 ^ eax_26) != 0x00)
		{
			ebx_13->dw0000 |= 0x20;
			return;
		}
	}
	ebx_13->t004C = eax_26;
	Eq_2 eax_63 = ebx_13->t000C;
	ebx_13->t0050 = edx_23;
	ebx_13->t0004 = eax_63;
	ebx_13->t0008 = eax_63;
}

// 08053D60: Register Eq_2 decide_maybe_mmap(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_file_underflow_maybe_mmap
//      _IO_file_xsgetn_maybe_mmap
Eq_2 decide_maybe_mmap(Eq_2 eax, struct Eq_9 * gs)
{
	ptr32 esi_11 = 0x080CE000;
	Eq_2 ebx_129 = eax;
	Eq_2 esp_17 = fp + ~0x8B;
	Eq_2 edi_18 = *((word32) eax + 0x0094);
	Eq_2175 eax_20 = gs->t0014;
	if (edi_18 >= 135066356)
	{
		word32 ecx_313;
		word32 edx_314;
		_IO_vtable_check(out ecx_313, out edx_314);
		esp_17.u0 = <invalid>;
	}
	Eq_2 eax_192;
	Eq_2 edx_191;
	struct Eq_18796 * esp_38 = esp_17 - 0x08;
	esp_38->tFFFFFFFC = (char *) &esp_38->t0004 + 32;
	esp_38->tFFFFFFF8 = eax;
	int32 eax_50;
	(*((word32) edi_18 + 72))();
	if (eax_50 == 0x00 && (esp_38->dw0034 & 0xF000) == 0x8000)
	{
		Eq_2 edx_62 = esp_38->t0050;
		Eq_2 ecx_63 = esp_38->t0054;
		if ((edx_62 | ecx_63) != 0x00 && (eax_50 - ecx_63) - (word32) (edx_62 > 0x000FFFFF) >= 0x00)
		{
			Eq_2 eax_75 = *((word32) eax + 76);
			Eq_2 edi_76 = *((word32) eax + 80);
			if (ecx_63 - edi_76 - (word32) (edx_62 < eax_75) >= 0x00 || (eax_75 & edi_76) == ~0x00)
			{
				esp_38->t0000.u0 = 0x00;
				esp_38->tFFFFFFFC.u0 = 0x00;
				esp_38->tFFFFFFF8 = *((word32) eax + 56);
				esp_38->tFFFFFFF4.u0 = 0x01;
				esp_38->dwFFFFFFF0 = 0x01;
				esp_38->tFFFFFFEC = edx_62;
				esp_38->dwFFFFFFE8 = 0x00;
				if (mmap64(gs, esp_38->dwFFFFFFE8, esp_38->tFFFFFFEC, esp_38->dwFFFFFFF0, esp_38->tFFFFFFF4, esp_38->tFFFFFFF8, esp_38->tFFFFFFFC, esp_38->t0000) != ~0x00)
				{
					esp_38->t0004.u0 = 0x00;
					esp_38->t0000 = esp_38->t0054;
					esp_38->tFFFFFFFC = esp_38->t0050;
					esp_38->tFFFFFFF8 = *((word32) eax + 56);
					Eq_2 edi_131;
					word32 edx_132;
					Eq_2 eax_128 = lseek64(gs, esp_38->tFFFFFFF8, esp_38->tFFFFFFFC, esp_38->t0000, esp_38->t0004, out edx_132, out ebx_129, out esi_11, out edi_131);
					Eq_2 esp_134 = <invalid>;
					Eq_2 ecx_139 = *((word32) esp_134 + 88);
					Eq_2 eax_143 = eax_128 ^ ecx_139 | edx_132 ^ *((word32) esp_134 + 92);
					if (eax_143 == 0x00)
					{
						*((word32) esp_134 + 28) = eax_143;
						((word32) esp_134 + 0x0C)->u0 = 0x00;
						Mem153[esp_134 + 0x08:word32] = ecx_139 + edi_131;
						*((word32) esp_134 + 4) = edi_131;
						*esp_134 = ebx_129;
						_IO_setb(*esp_134, *((word32) esp_134 + 4), *((word32) esp_134 + 8), *((word32) esp_134 + 0x0C));
						Eq_2 edx_166 = *((word32) ebx_129 + 76);
						Eq_2 ecx_167 = *((word32) ebx_129 + 80);
						Eq_2 eax_169 = *((word32) esp_134 + 28);
						*((word32) ebx_129 + 0x0C) = edi_131;
						if ((ecx_167 & edx_166) == ~0x00)
							edx_166 = eax_169;
						Mem179[ebx_129 + 0x04:word32] = edx_166 + edi_131;
						Eq_2 edx_181 = *((word32) esp_134 + 88);
						*((word32) ebx_129 + 76) = edx_181;
						Eq_2 edx_184 = *((word32) ebx_129 + 0x0068);
						Mem185[ebx_129 + 0x08:word32] = edi_131 + edx_181;
						*((word32) ebx_129 + 80) = *((word32) esp_134 + 92);
						if (edx_184 > 0x00)
						{
							eax_192 = esi_11 + 0x1000;
							edx_191 = esi_11 + 0x1000;
						}
						else
						{
							edx_191 = esi_11 + 0x1120;
							eax_192 = esi_11 + 0x1000;
						}
l08053DD3:
						*((word32) ebx_129 + 0x0094) = edx_191;
						*((word32) *((word32) ebx_129 + 88) + 0x00B0) = eax_192;
						if ((eax_20 ^ gs->t0014) == 0x00)
							return ebx;
						word32 ecx_315;
						word32 edx_316;
						__stack_chk_fail(out ecx_315, out edx_316);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						_IO_file_underflow_maybe_mmap(stackArg4);
						return ebx_129;
					}
					*((word32) esp_134 + 4) = ecx_139;
					*esp_134 = edi_131;
					word32 ecx_318;
					word32 edx_319;
					__munmap(ebx_129, gs, *esp_134, *((word32) esp_134 + 4), out ecx_318, out edx_319, out ebx_129);
					((word32) ebx_129 + 76)->u0 = ~0x00;
					((word32) ebx_129 + 80)->u0 = ~0x00;
				}
			}
		}
	}
	if (*((word32) ebx_129 + 0x0068) > 0x00)
	{
		eax_192 = esi_11 + 0x1060;
		edx_191 = eax_192;
	}
	else
	{
		edx_191 = esi_11 + 0x1180;
		eax_192 = esi_11 + 0x1060;
	}
	goto l08053DD3;
}

// 08053F30: Register word32 _IO_file_underflow_maybe_mmap(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow_maybe_mmap
//      decide_maybe_mmap
word32 _IO_file_underflow_maybe_mmap(Eq_2 dwArg04)
{
	decide_maybe_mmap(dwArg04, gs);
	Eq_2 esi_22 = *((word32) dwArg04 + 0x0094);
	if (esi_22 >= 135066356)
	{
		word32 edx_68;
		word32 ecx_67;
		_IO_vtable_check(out ecx_67, out edx_68);
	}
	word32 eax_49;
	(*((word32) esi_22 + 16))();
	return eax_49;
}

// 08053F80: void _IO_file_xsgetn_maybe_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void _IO_file_xsgetn_maybe_mmap(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_19149 * ebp_37 = decide_maybe_mmap(dwArg04, gs)->ptr0094;
	if (ebp_37 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_100;
		word32 ecx_99;
		_IO_vtable_check(out ecx_99, out edx_100);
	}
	ebp_37->ptr0020();
}

// 08053FF0: void _IO_new_file_seekoff(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word64 qwArg08, Stack word32 dwArg10, Stack Eq_2 dwArg14)
void _IO_new_file_seekoff(struct Eq_9 * gs, Eq_2 dwArg04, word64 qwArg08, word32 dwArg10, Eq_2 dwArg14)
{
	word32 dwArg0C = SLICE(qwArg08, word32, 32);
	word32 dwArg08 = (word32) qwArg08;
	int64 ebp_edi_1623;
	uint32 ebx_130;
	ui32 ecx_129;
	Eq_2 edx_688;
	int64 edx_eax_1638;
	int64 edx_eax_1628;
	int64 edx_eax_1634;
	Eq_2 esp_103 = fp - 188;
	Eq_2 ebp_138 = dwArg14;
	Eq_2 esi_170 = dwArg04;
	Eq_2175 eax_27 = gs->t0014;
	if (dwArg14 == 0x00)
	{
		if (*((word32) dwArg04 + 28) == 0x00)
		{
			Eq_2 edx_38 = *((word32) dwArg04 + 80);
			Eq_2 eax_37 = *((word32) dwArg04 + 76);
			ecx_129 = ~edx_38;
			ebx_130 = ~eax_37;
			ebp_edi_1623 = 0x00;
			edx_eax_1628 = SEQ(edx_38, eax_37);
			goto l08054582;
		}
		Eq_2 ecx_47 = *dwArg04;
		ebp_138 = *((word32) dwArg04 + 20);
		Eq_2 ebx_49 = *((word32) dwArg04 + 16);
		if (ebp_138 > ebx_49 && (ecx_47 & 0x1000) != 0x00)
		{
			Eq_2 ebx_93 = *((word32) dwArg04 + 0x0094);
			if (ebx_93 >= 135066356)
			{
				word32 ecx_1644;
				word32 edx_1645;
				_IO_vtable_check(out ecx_1644, out edx_1645);
				esp_103.u0 = <invalid>;
			}
			struct Eq_19435 * esp_109 = esp_103 - 4;
			esp_109->dw0000 = 0x02;
			esp_109->dwFFFFFFFC = 0x00;
			esp_109->dwFFFFFFF8 = 0x00;
			esp_109->tFFFFFFF4 = dwArg04;
			int64 edx_eax_1637;
			(*((word32) ebx_93 + 64))();
			Eq_2 edx_124 = SLICE(edx_eax_1637, word32, 32);
			Eq_2 eax_123 = (word32) edx_eax_1637;
			ecx_129 = ~edx_124;
			ebx_130 = ~eax_123;
			esp_103 = &esp_109->dw0000 + 1;
			if ((ecx_129 | ebx_130) == 0x00)
				goto l080545A3;
			*((word32) dwArg04 + 76) = eax_123;
			ebp_138 = *((word32) dwArg04 + 20);
			*((word32) dwArg04 + 80) = edx_124;
			edx_eax_1634 = edx_eax_1637;
l08054531:
			Eq_19563 ebp_829 = ebp_138 - *((word32) esi_170 + 16);
			ebp_edi_1623 = SEQ(ebp_829 >> 0x1F, ebp_829);
			edx_eax_1628 = edx_eax_1634;
			goto l08054582;
		}
		Eq_2 eax_58 = *((word32) dwArg04 + 76);
		Eq_2 edx_59 = *((word32) dwArg04 + 80);
		if (ebp_138 <= ebx_49)
		{
			int32 ecx_77 = *((word32) dwArg04 + 8) - *((word32) dwArg04 + 4);
			ecx_129 = ~edx_59;
			ebx_130 = ~eax_58;
			ebp_edi_1623 = SEQ(-((ecx_77 >> 0x1F) + (ecx_77 != 0x00)), -ecx_77);
			edx_eax_1628 = SEQ(edx_59, eax_58);
			goto l08054582;
		}
		edx_eax_1638 = SEQ(edx_59, eax_58);
		if ((ecx_47 & 0x1000) == 0x00)
		{
			Eq_19575 ebp_68 = ebp_138 - *((word32) dwArg04 + 8);
			ecx_129 = ~edx_59;
			ebx_130 = ~eax_58;
			ebp_edi_1623 = SEQ(ebp_68 >> 0x1F, ebp_68);
			edx_eax_1628 = SEQ(edx_59, eax_58);
l08054582:
			ebp_138 = SLICE(ebp_edi_1623, word32, 32);
			int64 edx_eax_1620 = edx_eax_1628;
			if ((ecx_129 | ebx_130) != 0x00)
			{
l08054586:
				edx_688 = SLICE(edx_eax_1620 + ebp_edi_1623, word32, 32);
				if (edx_688 < 0x00)
					goto l08054592;
				goto l08054347;
			}
			Eq_2 ebx_848 = *((word32) esi_170 + 0x0094);
			if (ebx_848 >= 135066356)
			{
				word32 ecx_1648;
				word32 edx_1649;
				_IO_vtable_check(out ecx_1648, out edx_1649);
				esp_103.u0 = <invalid>;
			}
			struct Eq_19513 * esp_864 = esp_103 - 4;
			esp_864->dw0000 = 0x01;
			esp_864->dwFFFFFFFC = 0x00;
			esp_864->dwFFFFFFF8 = 0x00;
			esp_864->tFFFFFFF4 = esi_170;
			int64 edx_eax_1633;
			(*((word32) ebx_848 + 64))();
			edx_eax_1620 = edx_eax_1633;
			if (((word32) edx_eax_1633 & SLICE(edx_eax_1633, word32, 32)) != ~0x00)
				goto l08054586;
l080545A3:
			edx_688.u0 = ~0x00;
			goto l08054347;
		}
l0805472B:
		ecx_129 = ~SLICE(edx_eax_1638, word32, 32);
		ebx_130 = ~(word32) edx_eax_1638;
		edx_eax_1634 = edx_eax_1638;
		goto l08054531;
	}
	Eq_2 esp_250;
	Eq_2 edx_140 = *((word32) dwArg04 + 16);
	Eq_2 eax_141 = *((word32) dwArg04 + 20);
	if ((*((word32) dwArg04 + 0x0C) != *((word32) dwArg04 + 8) || edx_140 != eax_141) && edx_140 < eax_141 || (*dwArg04 & 0x0800) != 0x00)
	{
		esi_170 = dwArg04;
		word32 ecx_1641;
		if (_IO_switch_to_get_mode(dwArg04, out ecx_1641) != 0x00)
			goto l080545A3;
		if (*((word32) dwArg04 + 28) != 0x00)
		{
l08054088:
			if (dwArg10 != 0x01)
				goto l08054096;
			goto l08054193;
		}
	}
	else if (*((word32) dwArg04 + 28) != 0x00)
		goto l08054088;
	Eq_2 eax_190 = *((word32) dwArg04 + 0x0C);
	if (eax_190 != 0x00)
	{
		word32 edx_1659;
		word32 ecx_1658;
		free(gs, dwLocD0, eax_190, out ecx_1658, out edx_1659);
		*dwArg04 &= ~0x0100;
	}
	_IO_doallocbuf(dwArg04);
	Eq_2 eax_230 = *((word32) dwArg04 + 28);
	*((word32) dwArg04 + 20) = eax_230;
	*((word32) dwArg04 + 16) = eax_230;
	*((word32) dwArg04 + 24) = eax_230;
	*((word32) dwArg04 + 0x0C) = eax_230;
	*((word32) dwArg04 + 4) = eax_230;
	*((word32) dwArg04 + 8) = eax_230;
	if (dwArg10 != 0x01)
	{
l08054096:
		esp_250 = fp - 188;
		if (dwArg10 != 0x02)
			goto l080541D4;
		Eq_2 ebx_288 = *((word32) dwArg04 + 0x0094);
		if (ebx_288 >= 135066356)
		{
			word32 edx_1643;
			word32 ecx_1642;
			_IO_vtable_check(out ecx_1642, out edx_1643);
			esp_250.u0 = <invalid>;
		}
		struct Eq_19314 * esp_308 = esp_250 - 0x08;
		esp_308->ptrFFFFFFFC = &esp_308->dw0014 + 0x0C;
		esp_308->tFFFFFFF8 = dwArg04;
		word32 eax_335;
		(*((word32) ebx_288 + 72))();
		esp_250 = &esp_308->ptrFFFFFFFC + 3;
		if (eax_335 != 0x00 || (esp_308->dw0054 & 0xF000) != 0x8000)
			goto l080542E8;
		ui64 v16_v15_955 = (word32) esp_308->t0010 + esp_308->qw0070;
		esp_308->t0010 = (word32) v16_v15_955;
		esp_308->dw0014 = SLICE(v16_v15_955, word32, 32);
l080541C9:
		*((word32) esp_250 + 0x00CC) = 0x00;
l080541D4:
		struct Eq_19269 * esp_359 = esp_250 - 0x0C;
		esp_359->tFFFFFFFC = dwArg04;
		_IO_free_backup_area(esp_359->tFFFFFFFC);
		Eq_2 ecx_372 = *((word32) dwArg04 + 76);
		Eq_2 ebx_373 = *((word32) dwArg04 + 80);
		Eq_2 eax_378 = *dwArg04;
		esp_359->t0024 = eax_378;
		esi_170 = dwArg04;
		esp_250 = (char *) &esp_359->tFFFFFFFC + 16;
		byte ah_385 = SLICE(eax_378, byte, 8);
		if ((ecx_372 & ebx_373) != ~0x00 && (*((word32) dwArg04 + 0x0C) != 0x00 && (ah_385 & 0x01) == 0x00))
		{
			Eq_2 edx_389 = *((word32) dwArg04 + 28);
			eax_391 = *((word32) dwArg04 + 8) - edx_389;
			esp_359->t002C = edx_389;
			int64 edx_eax_960 = SEQ(ebx_373, ecx_372) - SEQ(eax_391 >> 0x1F, eax_391);
			Eq_2 edx_401 = SLICE(edx_eax_960, word32, 32);
			Eq_2 eax_398 = (word32) edx_eax_960;
			ebp_138 = edx_401;
			if (esp_359->t0018 - edx_401 - (word32) (esp_359->t0014 < eax_398) >= 0x00 && (esp_359->t0018 - ebx_373) - (word32) (esp_359->t0014 < ecx_372) < 0x00)
			{
				Eq_2 edx_739 = esp_359->t002C;
				ui32 eax_740 = esp_359->t0014 - eax_398;
				*((word32) dwArg04 + 0x0C) = edx_739;
				*((word32) dwArg04 + 20) = edx_739;
				*((word32) dwArg04 + 4) = (word32) edx_739 + eax_740;
				Eq_2 eax_745 = esp_359->t0024;
				*((word32) dwArg04 + 16) = edx_739;
				*((word32) dwArg04 + 24) = edx_739;
				*dwArg04 = eax_745 & ~0x10;
				if (ebx_373 >= 0x00)
				{
					Eq_2 edi_758 = *((word32) dwArg04 + 0x0094);
					ebp_138 = edi_758;
					if (edi_758 >= 135066356)
					{
						word32 ecx_1652;
						word32 edx_1653;
						_IO_vtable_check(out ecx_1652, out edx_1653);
						esp_250.u0 = <invalid>;
						ecx_372 = *((word32) dwArg04 + 76);
						ebx_373 = *((word32) dwArg04 + 80);
					}
					struct Eq_19786 * esp_776 = esp_250 - 4;
					esp_776->dw0000 = 0x00;
					esp_776->tFFFFFFFC = ebx_373;
					esp_776->tFFFFFFF8 = ecx_372;
					esp_776->tFFFFFFF4 = dwArg04;
					(*((word32) edi_758 + 64))();
					edx_688 = esp_776->t0010;
					goto l08054347;
				}
				goto l080544B1;
			}
		}
		esp_359->dw0030 = 0x080CEFA0;
		esp_359->t002C.u0 = 0x0354;
		if ((esp_359->t0024 & 0x04) == 0x00)
		{
			ui32 ecx_433 = *((word32) dwArg04 + 28) - *((word32) dwArg04 + 32);
			Eq_2 edi_435 = esp_359->t0014;
			Eq_2 ebp_436 = esp_359->t0018;
			esp_359->t0024 = ecx_433 & edi_435;
			Eq_2 ecx_444 = *((word32) dwArg04 + 32);
			esp_359->t0028 = SLICE((int64) ecx_433, word32, 32) & ebp_436;
			int64 edx_eax_962 = SEQ(ebp_436, edi_435) - esp_359->t0024;
			up32 ecx_451 = ecx_444 - *((word32) dwArg04 + 28);
			esp_359->dw001C = (word32) edx_eax_962;
			Eq_2 edx_450 = SLICE(edx_eax_962, word32, 32);
			esp_359->t0020 = edx_450;
			ebp_138 = edx_450;
			if (SLICE((int64) ecx_451, word32, 32) - esp_359->t0020 - (word32) (ecx_451 < esp_359->dw001C) < 0x00)
			{
				Eq_2 edi_465 = esp_359->t0014;
				ebp_138 = esp_359->t0018;
				esp_359->dw001C = 0x00;
				esp_359->t0020.u0 = 0x00;
				esp_359->t0024 = edi_465;
				esp_359->t0028 = ebp_138;
			}
			Eq_2 edx_473 = *((word32) dwArg04 + 0x0094);
			if (edx_473 - 0x080CEFA0 >= esp_359->t002C)
			{
				esp_359->t0038 = edx_473;
				word32 edx_1655;
				word32 ecx_1654;
				_IO_vtable_check(out ecx_1654, out edx_1655);
				esp_250.u0 = <invalid>;
				edx_473 = *((byte) esp_250.u0 + 44);
			}
			struct Eq_19915 * esp_490 = esp_250 - 4;
			esp_490->dw0000 = 0x00;
			esp_490->dwFFFFFFFC = esp_490->dw0020;
			esp_490->dwFFFFFFF8 = esp_490->dw001C;
			esp_490->tFFFFFFF4 = dwArg04;
			word32 eax_519;
			int32 edx_520;
			(*((word32) edx_473 + 64))();
			esp_490->dw001C = eax_519;
			esp_490->dw0020 = edx_520;
			esp_250 = &esp_490->dw0000 + 1;
			if (edx_520 < 0x00)
				goto l080545A3;
			Eq_19952 eax_536;
			if ((esp_490->dw0018 | esp_490->dw0014) == 0x00)
			{
				eax_536.u0 = 0x00;
				goto l08054483;
			}
			Eq_2 edx_539 = *((word32) dwArg04 + 0x0094);
			if (edx_539 - 0x080CEFA0 >= esp_490->dw0024)
			{
				esp_490->t0030 = edx_539;
				word32 edx_1657;
				word32 ecx_1656;
				_IO_vtable_check(out ecx_1656, out edx_1657);
				esp_250.u0 = <invalid>;
				edx_539 = *((byte) esp_250.u0 + 44);
			}
			Eq_2 eax_563;
			Eq_2 ecx_557 = *((word32) edx_539 + 56);
			Eq_2 edx_559 = *((word32) dwArg04 + 28);
			if (*((byte) esp_250.u0 + 40) == 0x00)
				eax_563 = *((word32) dwArg04 + 32) - edx_559;
			else
				eax_563 = *((byte) esp_250.u0 + 16);
			struct Eq_20009 * esp_568 = esp_250 - 0x04;
			esp_568->tFFFFFFFC = eax_563;
			esp_568->tFFFFFFF8 = edx_559;
			esp_568->tFFFFFFF4 = dwArg04;
			ecx_557();
			ebp_138 = esp_568->t0018;
			esp_250 = (char *) &esp_568->tFFFFFFFC + 8;
			if ((eax_536 >> 0x1F) - ebp_138 - (word32) (eax_536 < esp_568->t0014) >= 0x00)
			{
				ui64 v29_v28_963 = (word32) esp_568->t001C + SEQ(eax_536 >> 0x1F, eax_536);
				esp_568->t001C = (word32) v29_v28_963;
				esp_568->dw0020 = SLICE(v29_v28_963, word32, 32);
l08054483:
				Eq_2 edx_718 = *((word32) dwArg04 + 28);
				Eq_2 ecx_720 = *((word32) esp_250 + 16);
				*dwArg04 &= ~0x10;
				*((word32) dwArg04 + 0x0C) = edx_718;
				Mem729[dwArg04 + 0x08:word32] = eax_536 + edx_718;
				Eq_2 eax_730 = *((word32) esp_250 + 24);
				*((word32) dwArg04 + 20) = edx_718;
				*((word32) dwArg04 + 16) = edx_718;
				*((word32) dwArg04 + 24) = edx_718;
				Eq_2 edx_734 = *((word32) esp_250 + 28);
				Mem735[dwArg04 + 0x04:word32] = ecx_720 + edx_718;
				*((word32) dwArg04 + 76) = eax_730;
				*((word32) dwArg04 + 80) = edx_734;
l080544B1:
				edx_688 = *((word32) esp_250 + 0x0C);
				goto l08054347;
			}
			if (eax_536 == ~0x00)
			{
				Eq_19952 eax_617 = esp_568->t0014;
				Eq_2 edx_618 = esp_568->t0018;
				esp_568->dw00D0 = 0x01;
				esp_568->t000C = eax_617;
				esp_568->t0010 = edx_618;
			}
			else
			{
				Eq_19952 edi_607 = esp_568->t0014;
				Eq_2 ebp_608 = esp_568->t0018;
				esp_568->dw00D0 = 0x01;
				ui64 ebp_edi_967 = SEQ(ebp_608, edi_607) - SEQ(eax_536 >> 0x1F, eax_536);
				esp_568->t000C = (word32) ebp_edi_967;
				ebp_138 = SLICE(ebp_edi_967, word32, 32);
				esp_568->t0010 = ebp_138;
			}
		}
l080542E8:
		struct Eq_19333 * esp_624 = esp_250 - 0x0C;
		esp_624->tFFFFFFFC = dwArg04;
		_IO_unsave_markers(esp_624->tFFFFFFFC);
		Eq_2 ebx_636 = *((word32) dwArg04 + 0x0094);
		esi_170 = dwArg04;
		Eq_2 esp_639 = (char *) &esp_624->tFFFFFFFC + 16;
		if (esp_624->dw002C <= ebx_636 - esp_624->dw0030)
		{
			word32 ecx_1650;
			word32 edx_1651;
			_IO_vtable_check(out ecx_1650, out edx_1651);
			esp_639.u0 = <invalid>;
		}
		struct Eq_19592 * esp_652 = esp_639 - 4;
		esp_652->dw0000 = (word32) *((byte) esp_639.u0 + 0x00CC);
		esp_652->dwFFFFFFFC = esp_652->dw0010;
		esp_652->dwFFFFFFF8 = esp_652->dw000C;
		esp_652->tFFFFFFF4 = dwArg04;
		Eq_2 eax_687;
		(*((word32) ebx_636 + 64))();
		if ((eax_687 & edx_688) != ~0x00)
		{
			Eq_2 ecx_696 = *((word32) dwArg04 + 28);
			*dwArg04 &= ~0x10;
			*((word32) dwArg04 + 76) = eax_687;
			*((word32) dwArg04 + 80) = edx_688;
			*((word32) dwArg04 + 0x0C) = ecx_696;
			*((word32) dwArg04 + 4) = ecx_696;
			*((word32) dwArg04 + 8) = ecx_696;
			*((word32) dwArg04 + 20) = ecx_696;
			*((word32) dwArg04 + 16) = ecx_696;
			*((word32) dwArg04 + 24) = ecx_696;
		}
l08054347:
		if ((eax_27 ^ gs->t0014) == 0x00)
			return;
		esp_103.u0 = <invalid>;
		word32 ecx_1646;
		word32 edx_1647;
		edx_eax_1638 = SEQ(edx_688, __stack_chk_fail(out ecx_1646, out edx_1647));
		goto l0805472B;
	}
l08054193:
	Eq_2 eax_255 = *((word32) dwArg04 + 76);
	Eq_2 edx_260 = *((word32) dwArg04 + 80);
	esp_250 = fp - 188;
	esi_170 = dwArg04;
	ui64 v32_v31_953 = qwArg08 - (int64) (*((word32) dwArg04 + 8) - *((word32) dwArg04 + 4));
	if ((eax_255 & edx_260) == ~0x00)
		goto l080542E8;
	if (SLICE(v32_v31_953 + SEQ(edx_260, eax_255), word32, 32) < 0x00)
	{
l08054592:
		gs->tFFFFFFE0.u0 = 22;
		goto l080545A3;
	}
	goto l080541C9;
}

// 08054740: void _IO_file_stat(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_20196) dwArg04, Stack Eq_2 dwArg08)
void _IO_file_stat(struct Eq_9 * gs, struct Eq_20196 * dwArg04, Eq_2 dwArg08)
{
	word32 ecx_35;
	word32 edx_36;
	__fxstat64(gs, dwArg04->t0038, dwArg08, out ecx_35, out edx_36);
}

// 08054760: void _IO_new_file_write(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_20208) dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C)
void _IO_new_file_write(struct Eq_9 * gs, struct Eq_20208 * dwArg04, ptr32 dwArg08, int32 dwArg0C)
{
	Eq_20211 eax_108;
	ptr32 esi_19 = dwArg08;
	if (dwArg0C > 0x00)
	{
		int32 ebx_25 = dwArg0C;
		do
		{
			int32 eax_44;
			Eq_2 eax_28 = dwArg04->t0038;
			if ((dwArg04->b003C & 0x02) != 0x00)
			{
				eax_44 = __write_nocancel(gs, eax_28, esi_19, ebx_25);
				if (eax_44 < 0x00)
					goto l080547B8;
			}
			else
			{
				eax_44 = __libc_write(gs, eax_28, esi_19, ebx_25, out ebx_25, out esi_19);
				if (eax_44 < 0x00)
				{
l080547B8:
					dwArg04->dw0000 |= 0x20;
					eax_108 = dwArg0C - ebx_25;
					goto l080547C0;
				}
			}
			ebx_25 -= eax_44;
			esi_19 += eax_44;
		} while (ebx_25 > 0x00);
		eax_108 = dwArg0C - ebx_25;
	}
	else
		eax_108.u0 = 0x00;
l080547C0:
	int32 ebx_103 = dwArg04->dw0050;
	uint32 ecx_104 = dwArg04->dw004C;
	if (ebx_103 >= 0x00)
	{
		int64 ebx_ecx_137 = SEQ(ebx_103, ecx_104) + SEQ(eax_108 >> 0x1F, eax_108);
		dwArg04->dw004C = (word32) ebx_ecx_137;
		dwArg04->dw0050 = SLICE(ebx_ecx_137, word32, 32);
	}
}

// 08054800: void _IO_file_xsgetn_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_xsgetn_mmap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 edx_130 = *((word32) dwArg04 + 4);
	Eq_2 edi_182 = dwArg04;
	Eq_2 ebp_144 = dwArg0C;
	Eq_2 ecx_165 = dwArg08;
	Eq_2 esi_132 = *((word32) dwArg04 + 8) - edx_130;
	if (esi_132 >= dwArg0C)
	{
l08054858:
		if (esi_132 == 0x00)
			return;
		goto l0805489F;
	}
	if ((*dwArg04 & 0x0100) != 0x00)
	{
		word32 edx_288;
		Eq_2 eax_40 = __mempcpy(dwArg08, edx_130, esi_132, out edx_288);
		_IO_switch_to_main_get_area(dwArg04);
		edx_130 = *((word32) dwArg04 + 4);
		ebp_144 = dwArg0C - esi_132;
		ecx_165 = eax_40;
		esi_132 = *((word32) dwArg04 + 8) - edx_130;
		if (ebp_144 <= esi_132)
			goto l0805489F;
	}
	Eq_2 esp_105 = fp - 44;
	word32 ebx_289;
	if (mmap_remap_check(dwArg04, gs, dwLoc2C, dwLoc28, dwLoc24, ecx_165, out ebx_289, out ebp_144, out edi_182) != 0x00)
	{
		Eq_2 eax_104 = *((word32) edi_182 + 0x0094);
		if (eax_104 >= 135066356)
		{
			word32 ecx_291;
			word32 edx_292;
			_IO_vtable_check(out ecx_291, out edx_292);
			esp_105.u0 = <invalid>;
			eax_104 = *((byte) esp_105.u0 + 0x0C);
		}
		struct Eq_20382 * esp_106 = esp_105 - 0x04;
		esp_106->tFFFFFFFC = ebp_144;
		esp_106->dwFFFFFFF8 = esp_106->dw0038;
		esp_106->tFFFFFFF4 = edi_182;
		(*((word32) eax_104 + 32))();
		return;
	}
	edx_130 = *((word32) edi_182 + 4);
	esi_132 = *((word32) edi_182 + 8) - edx_130;
	if (esi_132 < ebp_144)
	{
		*edi_182 |= 0x10;
		goto l08054858;
	}
l0805489F:
	if (esi_132 > ebp_144)
		esi_132 = ebp_144;
	word32 edx_290;
	__mempcpy(ecx_165, edx_130, esi_132, out edx_290);
	Mem184[edi_182 + 0x04:word32] = esi_132 + edx_130;
}

// 08054910: void _IO_file_xsgetn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_xsgetn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 ebp_103 = dwArg08;
	if (*((word32) dwArg04 + 28) == 0x00)
	{
		Eq_2 eax_26 = *((word32) dwArg04 + 36);
		if (eax_26 != 0x00)
		{
			word32 ecx_587;
			word32 edx_588;
			free(gs, dwLoc40, eax_26, out ecx_587, out edx_588);
			*dwArg04 &= ~0x0100;
		}
		_IO_doallocbuf(dwArg04);
	}
	if (dwArg0C != 0x00)
	{
		Eq_2 eax_100 = *((word32) dwArg04 + 4);
		Eq_2 edi_119 = dwArg0C;
		Eq_2 edx_315 = *((word32) dwArg04 + 8) - eax_100;
		if (dwArg0C > edx_315)
		{
			do
			{
				if (edx_315 != 0x00)
				{
					word32 edx_589;
					Eq_2 eax_106 = __mempcpy(ebp_103, eax_100, edx_315, out edx_589);
					Mem117[dwArg04 + 0x04:word32] = Mem104[dwArg04 + 0x04:word32] + edx_315;
					ebp_103 = eax_106;
					edi_119 -= edx_315;
					if ((*dwArg04 & 0x0100) != 0x00)
						goto l08054A61;
					goto l0805498C;
				}
				if ((*dwArg04 & 0x0100) == 0x00)
				{
l0805498C:
					Eq_2 eax_126 = *((word32) dwArg04 + 28);
					if (eax_126 != 0x00)
					{
						Eq_2 ecx_137 = *((word32) dwArg04 + 32) - eax_126;
						if (ecx_137 <= edi_119)
						{
							*((word32) dwArg04 + 0x0C) = eax_126;
							*((word32) dwArg04 + 4) = eax_126;
							*((word32) dwArg04 + 8) = eax_126;
							*((word32) dwArg04 + 20) = eax_126;
							*((word32) dwArg04 + 16) = eax_126;
							*((word32) dwArg04 + 24) = eax_126;
							if (ecx_137 > 0x7F)
								goto l080549CB;
							goto l08054AB2;
						}
						word32 ecx_590;
						if (__underflow(dwArg04, out ecx_590) == ~0x00)
							return;
					}
					else
					{
						((word32) dwArg04 + 0x0C)->u0 = 0x00;
						((word32) dwArg04 + 4)->u0 = 0x00;
						((word32) dwArg04 + 8)->u0 = 0x00;
						((word32) dwArg04 + 20)->u0 = 0x00;
						((word32) dwArg04 + 16)->u0 = 0x00;
						((word32) dwArg04 + 24)->u0 = 0x00;
l080549CB:
						Eq_2 ebx_192 = *((word32) dwArg04 + 0x0094);
						if (ebx_192 >= 135066356)
						{
							word32 ecx_591;
							word32 edx_592;
							_IO_vtable_check(out ecx_591, out edx_592);
						}
						Eq_20571 eax_237;
						(*((word32) ebx_192 + 56))();
						if (eax_237 <= 0x00)
						{
							ui32 edx_245 = *dwArg04;
							ui32 edx_249 = edx_245 | 0x10;
							if (eax_237 != 0x00)
								edx_249 = edx_245 | 0x20;
							*dwArg04 = edx_249;
							return;
						}
						Eq_2 eax_271 = *((word32) dwArg04 + 76);
						Eq_2 edx_272 = *((word32) dwArg04 + 80);
						ebp_103 += eax_237;
						edi_119 -= eax_237;
						if ((eax_271 & edx_272) != ~0x00)
						{
							ui64 edx_eax_379 = SEQ(edx_272, eax_271) + SEQ(eax_237 >> 0x1F, eax_237);
							*((word32) dwArg04 + 76) = (word32) edx_eax_379;
							*((word32) dwArg04 + 80) = SLICE(edx_eax_379, word32, 32);
						}
					}
					if (edi_119 == 0x00)
						goto l08054A78;
				}
				else
				{
l08054A61:
					_IO_switch_to_main_get_area(dwArg04);
					if (edi_119 == 0x00)
						goto l08054A78;
				}
				eax_100 = *((word32) dwArg04 + 4);
				edx_315 = *((word32) dwArg04 + 8) - eax_100;
			} while (edi_119 > edx_315);
		}
		word32 ecx_585;
		word32 edx_586;
		memcpy(ebp_103, eax_100, edi_119, out ecx_585, out edx_586);
		Mem350[dwArg04 + 0x04:word32] = Mem337[dwArg04 + 0x04:word32] + edi_119;
	}
	else
	{
l08054A78:
	}
}

// 08054B70: void _IO_file_seekoff_mmap(Register (ptr32 Eq_20626) gs, Stack (ptr32 Eq_20627) dwArg04, Stack word64 qwArg08, Stack word32 dwArg10, Stack word32 dwArg14)
void _IO_file_seekoff_mmap(struct Eq_20626 * gs, struct Eq_20627 * dwArg04, word64 qwArg08, word32 dwArg10, word32 dwArg14)
{
	up32 dwArg08 = (word32) qwArg08;
	int32 dwArg0C = SLICE(qwArg08, word32, 32);
	Eq_2 esp_18 = fp - 44;
	up32 edi_107 = dwArg08;
	int32 ebp_22 = dwArg0C;
	if (dwArg14 == 0x00)
		return;
	Eq_20643 esi_50;
	if (dwArg10 != 0x01)
	{
		if (dwArg10 != 0x02)
			goto l08054BB3;
		esi_50 = dwArg04->dw0020 - dwArg04->dw001C;
	}
	else
		esi_50 = dwArg04->dw0004 - dwArg04->dw000C;
	ui64 ebp_edi_182 = qwArg08 + SEQ(esi_50 >> 0x1F, esi_50);
	edi_107 = (word32) ebp_edi_182;
	ebp_22 = SLICE(ebp_edi_182, word32, 32);
l08054BB3:
	if (ebp_22 >= 0x00)
	{
		struct Eq_20667 * esi_82 = dwArg04->ptr0094;
		if (esi_82 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 ecx_255;
			word32 edx_256;
			_IO_vtable_check(out ecx_255, out edx_256);
			esp_18.u0 = <invalid>;
		}
		struct Eq_20679 * esp_100 = esp_18 - 4;
		esp_100->dw0000 = 0x00;
		esp_100->dwFFFFFFFC = ebp_22;
		esp_100->dwFFFFFFF8 = edi_107;
		esp_100->ptrFFFFFFF4 = dwArg04;
		word32 eax_117;
		int32 edx_119;
		esi_82->ptr0040();
		esp_100->dw000C = eax_117;
		if (edx_119 >= 0x00)
		{
			word32 eax_129 = dwArg04->dw0020;
			word32 esi_130 = dwArg04->dw001C;
			esp_100->dw0010 = eax_129;
			dwArg04->dw000C = esi_130;
			up32 edx_133 = eax_129 - esi_130;
			esp_100->dw0008 = edx_133;
			if (SLICE((int64) edx_133, word32, 32) - ebp_22 - (word32) (esp_100->dw0008 < edi_107) >= 0x00)
			{
				word32 eax_148 = esi_130 + edi_107;
				dwArg04->dw0004 = eax_148;
				dwArg04->dw0008 = eax_148;
			}
			else
			{
				word32 edx_145 = esp_100->dw0010;
				dwArg04->dw0004 = edx_145;
				dwArg04->dw0008 = edx_145;
			}
			dwArg04->dw0000 &= ~0x10;
			word32 eax_158 = esp_100->dw000C;
			dwArg04->dw0050 = edx_119;
			dwArg04->dw004C = eax_158;
		}
	}
	else
		gs->dwFFFFFFE0 = 22;
}

// 08054CD0: Register word32 _IO_file_underflow_mmap(Register (ptr32 Eq_15766) ebx, Register Eq_2 esi, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow_mmap
word32 _IO_file_underflow_mmap(struct Eq_15766 * ebx, Eq_2 esi, Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04)
{
	word32 eax_105;
	Eq_2 eax_16 = *((word32) dwArg04 + 4);
	if (eax_16 >= *((word32) dwArg04 + 8))
	{
		struct Eq_20788 * ebx_23;
		word32 ebp_151;
		word32 edi_152;
		if (mmap_remap_check(dwArg04, gs, ebx, esi, edi, dwArg00, out ebx_23, out ebp_151, out edi_152) != 0x00)
		{
			struct Eq_20802 * edi_35 = ebx_23->ptr0094;
			if (edi_35 >= &__elf_set___libc_atexit_element__IO_cleanup__)
			{
				word32 ecx_153;
				word32 edx_154;
				_IO_vtable_check(out ecx_153, out edx_154);
			}
			word32 eax_63;
			word32 edx_64;
			word32 ecx_65;
			edi_35->ptr0010();
			return eax_63;
		}
		eax_16 = ebx_23->t0004;
		if (eax_16 >= ebx_23->t0008)
		{
			ebx_23->dw0000 |= 0x10;
			eax_105 = ~0x00;
			return eax_105;
		}
	}
	eax_105 = (word32) *eax_16;
	return eax_105;
}

// 08054D50: void _IO_file_read(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_20837) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_read(struct Eq_9 * gs, struct Eq_20837 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 edx_6 = dwArg04->t0038;
	if ((dwArg04->b003C & 0x02) != 0x00)
	{
		word32 ecx_45;
		__read_nocancel(gs, edx_6, dwArg08, dwArg0C, out ecx_45);
	}
	else
		read(gs, edx_6, dwArg08, dwArg0C);
}

// 08054D80: void _IO_file_xsputn(Stack (ptr32 Eq_17572) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_xsputn(struct Eq_17572 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	if (dwArg0C == 0x00)
		return;
	Eq_2 ebp_133;
	word32 edx_121;
	Eq_2 ebp_31;
	word32 edx_59;
	Eq_2 ecx_26 = dwArg04->t0014;
	if ((dwArg04->dw0000 & 0x0A00) != 0x0A00)
	{
		Eq_2 ebp_67 = dwArg04->t0018;
		if (ebp_67 <= ecx_26)
			goto l08054E60;
		ebp_31 = ebp_67 - ecx_26;
	}
	else
	{
		ebp_31 = dwArg04->t0020 - ecx_26;
		if (dwArg0C <= ebp_31)
		{
			word32 edx_35 = dwArg08 + dwArg0C;
			if (dwArg08 < edx_35)
			{
				Eq_2 eax_39 = edx_35 - 0x01;
				if (*((word32) edx_35 - 1) != 0x0A)
				{
					do
					{
						if (dwArg08 == eax_39)
							goto l08054E50;
						--eax_39;
					} while (*eax_39 != 0x0A);
				}
				up32 eax_54 = eax_39 - dwArg08;
				ebp_31 = eax_54 + 0x01;
				if (eax_54 == 0x01)
				{
					ebp_133 = dwArg0C;
					edx_121 = 0x01;
					goto l08054DF7;
				}
				edx_59 = 0x01;
			}
			else
			{
l08054E50:
				edx_59 = 0x00;
			}
l08054DCC:
			if (dwArg0C <= ebp_31)
				ebp_31 = dwArg0C;
			word32 edx_419;
			dwArg04->t0014 = __mempcpy(ecx_26, dwArg08, ebp_31, out edx_419);
			dwArg08 += ebp_31;
			edx_121 = edx_59;
			ebp_133 = dwArg0C - ebp_31;
l08054DF7:
			if ((word32) ebp_133 + edx_121 == 0x00)
				return;
l08054E62:
			Eq_2 esp_154 = fp - 44;
			Eq_2 eax_146 = dwArg04->t0094;
			if (eax_146 >= 135066356)
			{
				word32 ecx_420;
				word32 edx_421;
				_IO_vtable_check(out ecx_420, out edx_421);
				esp_154.u0 = <invalid>;
				eax_146 = *((byte) esp_154.u0 + 0x0C);
			}
			struct Eq_20922 * esp_167 = esp_154 - 0x08;
			esp_167->tFFFFFFFC.u0 = ~0x00;
			esp_167->ptrFFFFFFF8 = dwArg04;
			word32 eax_192;
			word32 ecx_193;
			(*((word32) eax_146 + 0x0C))();
			if (eax_192 == ~0x00)
				return;
			uint32 ecx_206 = dwArg04->t0020 - dwArg04->t001C;
			Eq_2 ebx_207 = ebp_133;
			if (ecx_206 > 0x7F)
				ebx_207 = ebp_133 - (uint32) ((uint64) ebp_133 % ecx_206);
			if (ebx_207 != 0x00)
			{
				Eq_2 eax_230 = new_do_write(dwArg04, ebx_207, esp_167->ptr003C);
				if (eax_230 < ebx_207)
					return;
				ebp_133 -= eax_230;
			}
			if (ebp_133 != 0x00)
			{
				esp_167->t0014 = dwArg0C;
				esp_167->t0000 = ebp_133;
				Mem259[esp_167 + -4:word32] = ebx_207 + Mem254[esp_167 + 0x3C:word32];
				esp_167->ptrFFFFFFF8 = dwArg04;
				_IO_default_xsputn(esp_167->tFFFFFFFC, esp_167->t0000);
			}
			return;
		}
	}
	edx_59 = 0x00;
	if (ebp_31 != 0x00)
		goto l08054DCC;
l08054E60:
	ebp_133 = dwArg0C;
	goto l08054E62;
}

// 08054F60: void _IO_new_file_init_internal(Stack Eq_2 dwArg04)
// Called from:
//      __fopen_internal
void _IO_new_file_init_internal(Eq_2 dwArg04)
{
	*dwArg04 |= 9228;
	((word32) dwArg04 + 76)->u0 = ~0x00;
	((word32) dwArg04 + 80)->u0 = ~0x00;
	_IO_link_in(ecx, gs, dwArg04);
	((word32) dwArg04 + 56)->u0 = ~0x00;
}

// 08054FA0: void _IO_file_init(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_file_init(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	*dwArg04 |= 9228;
	((word32) dwArg04 + 76)->u0 = ~0x00;
	((word32) dwArg04 + 80)->u0 = ~0x00;
	_IO_link_in(ecx, gs, dwArg04);
	((word32) dwArg04 + 56)->u0 = ~0x00;
}

// 08054FE0: Register Eq_2 _IO_file_open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack ui32 dwArg14, Stack word32 dwArg18)
// Called from:
//      _IO_file_fopen
Eq_2 _IO_file_open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ui32 dwArg14, word32 dwArg18)
{
	Eq_2 eax_19 = dwArg0C;
	if (dwArg18 == 0x00)
		eax_19 = dwArg0C | 0x8000;
	Eq_2 ebp_57;
	if ((*((word32) dwArg04 + 60) & 0x02) == 0x00)
		ebp_57 = open(gs, dwArg08, eax_19, dwArg10);
	else
	{
		word32 edx_285;
		word32 ecx_284;
		ebp_57 = __open_nocancel(gs, dwArg08, eax_19, dwArg10, out ecx_284, out edx_285);
	}
	if (ebp_57 < 0x00)
		return 0x00;
	Eq_2 eax_159;
	ui32 eax_96 = *dwArg04;
	*((word32) dwArg04 + 56) = ebp_57;
	*dwArg04 = eax_96 & ~0x100C | dwArg14 & 0x100C;
	if ((dwArg14 & 0x1004) == 0x1004)
	{
		Eq_2 esi_107 = *((word32) dwArg04 + 0x0094);
		if (esi_107 >= 135066356)
		{
			word32 edx_288;
			word32 ecx_287;
			_IO_vtable_check(out ecx_287, out edx_288);
		}
		ui32 eax_137;
		ui32 edx_138;
		(*((word32) esi_107 + 64))();
		if ((eax_137 & edx_138) == ~0x00 && gs->tFFFFFFE0 != 0x1D)
		{
			word32 edx_289;
			__close_nocancel(gs, ebp_57, out edx_289);
			eax_159.u0 = 0x00;
			return eax_159;
		}
	}
	_IO_link_in(ecx, gs, dwArg04);
	eax_159 = dwArg04;
	return eax_159;
}

// 08055110: void _IO_file_attach(Register (ptr32 Eq_21172) gs, Stack (ptr32 Eq_21173) dwArg04, Stack word32 dwArg08)
void _IO_file_attach(struct Eq_21172 * gs, struct Eq_21173 * dwArg04, word32 dwArg08)
{
	if (dwArg04->dw0038 != ~0x00)
		return;
	struct Eq_21180 * ebp_23 = dwArg04->ptr0094;
	dwArg04->dw004C = ~0x00;
	dwArg04->dw0050 = ~0x00;
	dwArg04->dw0038 = dwArg08;
	dwArg04->dw0000 = dwArg04->dw0000 & ~0x0C | 0x40;
	word32 esi_37 = gs->dwFFFFFFE0;
	if (ebp_23 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_161;
		word32 ecx_160;
		_IO_vtable_check(out ecx_160, out edx_161);
	}
	ui32 edx_67;
	ui32 eax_68;
	word32 ecx_69;
	ebp_23->ptr0024();
	if ((eax_68 & edx_67) == ~0x00 && gs->dwFFFFFFE0 != 0x1D)
		return;
	gs->dwFFFFFFE0 = esi_37;
}

// 080551C0: Register word32 _IO_do_write(Stack Eq_2 dwArg0C)
// Called from:
//      _IO_wdo_write
//      _IO_wfile_overflow
//      _IO_wfile_sync
//      _IO_file_close_it
//      _IO_new_file_finish
//      _IO_new_file_overflow
//      _IO_new_file_sync
word32 _IO_do_write(Eq_2 dwArg0C)
{
	if (dwArg0C != 0x00)
		return -(word32) (dwArg0C != new_do_write(dwArg04, dwArg0C, dwArg08));
	return 0x00;
}

// 08055200: void _IO_file_close_it(Stack Eq_2 dwArg04)
// Called from:
//      __new_fclose
//      _IO_file_fopen
void _IO_file_close_it(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 56) != ~0x00)
	{
		if ((*dwArg04 & 0x0808) == 0x0800)
		{
			if (*((word32) dwArg04 + 0x0068) > 0x00)
			{
				Eq_2 eax_49 = *((word32) dwArg04 + 88);
				Eq_2 edx_51 = *((word32) eax_49 + 0x0C);
				word32 esi_297;
				word32 ebx_296;
				_IO_wdo_write(gs, dwArg04, edx_51, *((word32) eax_49 + 16) - edx_51 >> 0x02, out ebx_296, out esi_297);
			}
			else
				_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16));
		}
		_IO_unsave_markers(dwArg04);
		word32 esi_114 = 0x00;
		if ((*((word32) dwArg04 + 60) & 0x20) == 0x00)
		{
			Eq_2 esi_88 = *((word32) dwArg04 + 0x0094);
			if (esi_88 >= 135066356)
			{
				word32 ecx_292;
				word32 edx_293;
				_IO_vtable_check(out ecx_292, out edx_293);
			}
			word32 eax_110;
			word32 edx_111;
			word32 ecx_112;
			(*((word32) esi_88 + 0x0044))();
			esi_114 = eax_110;
		}
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			if (*((word32) *((word32) dwArg04 + 88) + 32) != 0x00)
				_IO_free_wbackup_area(dwArg04);
			word32 edx_294;
			_IO_wsetb(dwArg04, 0x00, 0x00, 0x00, out edx_294);
			Eq_2 eax_160 = *((word32) dwArg04 + 88);
			((word32) eax_160 + 8)->u0 = 0x00;
			*eax_160 = 0x00;
			((word32) eax_160 + 4)->u0 = 0x00;
			((word32) eax_160 + 16)->u0 = 0x00;
			((word32) eax_160 + 0x0C)->u0 = 0x00;
			((word32) eax_160 + 20)->u0 = 0x00;
		}
		_IO_setb(dwArg04, 0x00, 0x00, 0x00);
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		((word32) dwArg04 + 4)->u0 = 0x00;
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 16)->u0 = 0x00;
		((word32) dwArg04 + 24)->u0 = 0x00;
		_IO_un_link(dwArg04);
		*dwArg04 = 4222428172;
		((word32) dwArg04 + 56)->u0 = ~0x00;
		((word32) dwArg04 + 76)->u0 = ~0x00;
		((word32) dwArg04 + 80)->u0 = ~0x00;
	}
}

// 080553A0: Register (ptr32 Eq_21423) _IO_file_fopen(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 byte) dwArg0C)
// Called from:
//      __fopen_internal
struct Eq_21423 * _IO_file_fopen(struct Eq_9 * gs, Eq_2 dwArg04, byte * dwArg0C)
{
	struct Eq_21423 * dwLoc58_662;
	struct Eq_21425 * esp_455;
	byte * edx_20 = dwArg0C;
	Eq_2175 eax_25 = gs->t0014;
	if (*((word32) dwArg04 + 56) != ~0x00)
	{
l08055630:
		dwLoc58_662 = null;
		goto l08055410;
	}
	ui32 ecx_950;
	ui32 edi_116;
	ui32 dwLoc5C_626;
	byte al_31 = *dwArg0C;
	if (al_31 != 114)
	{
		if (al_31 != 0x77)
		{
			if (al_31 != 0x61)
			{
				gs->tFFFFFFE0.u0 = 22;
				dwLoc58_662 = null;
				goto l08055410;
			}
			edi_116 = 0x1004;
			dwLoc5C_626 = 0x01;
			ecx_950 = 0x0440;
		}
		else
		{
			dwLoc5C_626 = 0x01;
			edi_116 = 0x04;
			ecx_950 = 0x0240;
		}
	}
	else
	{
		edi_116 = 0x08;
		dwLoc5C_626 = 0x00;
		ecx_950 = 0x00;
	}
	byte * ebx_140 = dwArg0C;
	ui32 ecx_121 = ecx_950;
	do
	{
		++edx_20;
		word24 ecx_24_8_80 = SLICE(ecx_121, word24, 8);
		byte cl_73 = (byte) ecx_121;
		ci8 al_56 = *edx_20;
		if (al_56 != 99)
		{
			if (al_56 <= 99)
			{
				if (al_56 != 0x2B)
				{
					if (al_56 != 0x62)
					{
						if (al_56 == 0x00)
							break;
					}
					else
						ebx_140 = edx_20;
				}
				else
				{
					edi_116 &= 0x1000;
					ebx_140 = edx_20;
					dwLoc5C_626 = 0x02;
				}
			}
			else if (al_56 != 0x6D)
			{
				if (al_56 != 0x78)
				{
					if (al_56 == 101)
					{
						*((word32) dwArg04 + 60) |= 0x40;
						ecx_121 |= 0x00080000;
					}
				}
				else
				{
					ebx_140 = edx_20;
					ecx_121 = SEQ(ecx_24_8_80, cl_73 | 0x80);
				}
			}
			else
				*((word32) dwArg04 + 60) |= 0x01;
		}
		else
			*((word32) dwArg04 + 60) |= 0x02;
	} while (edx_20 != dwArg0C + 6);
	struct Eq_21423 * eax_151 = _IO_file_open(gs, dwArg04, dwArg08, ecx_121 | dwLoc5C_626, 0x01B6, edi_116, dwArg10);
	dwLoc58_662 = eax_151;
	if (eax_151 == null)
		goto l08055630;
	word32 ecx_956;
	word32 edx_957;
	Eq_2 eax_169 = strstr(gs, ebx_140 + 1, 134883381, out ecx_956, out edx_957);
	if (eax_169 == 0x00)
	{
l08055410:
		if ((eax_25 ^ gs->t0014) == 0x00)
			return dwLoc58_662;
		word32 ecx_954;
		word32 edx_955;
		__stack_chk_fail(out ecx_954, out edx_955);
		goto l08055862;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 esi_194 = strchrnul((word32) eax_169 + 5, 44) - ((word32) eax_169 + 5);
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_959;
	word32 ebx_961;
	word32 esi_963;
	word32 edi_964;
	word32 ebp_962;
	word32 edx_960;
	Eq_2 eax_198 = __libc_malloc(gs, stackArg0, (word32) esi_194 + 3, out ecx_959, out edx_960, out ebx_961, out ebp_962, out esi_963, out edi_964);
	if (eax_198 == 0x00)
	{
		Eq_2 esi_211 = gs->tFFFFFFE0;
		_IO_file_close_it(dwArg04);
		gs->tFFFFFFE0 = esi_211;
		goto l08055630;
	}
	Eq_2 ecx_257;
	Eq_2 eax_249;
	word32 edx_235;
	*__mempcpy(eax_198, (word32) eax_169 + 5, esi_194, out edx_235) = 0x00;
	word32 eax_243 = (word32) *eax_198;
	if ((byte) eax_243 == 0x00)
	{
		*eax_198 = 0x2F;
		eax_249 = (word32) eax_198 + 1;
		goto l080556BC;
	}
	else
	{
		int32 dwLoc5C_681 = 0x00;
		Eq_2 esi_254 = g_t80CE08C;
		Eq_3803 ecx_255[] = g_ptr80CE084;
		ecx_257 = eax_198;
		Eq_2 ebx_259 = eax_198;
		do
		{
			cu8 al_263 = (byte) eax_243;
			int32 esi_265 = (int32) al_263;
			word32 ebp_269 = dwLoc5C_681 + 0x01;
			if (((int8) (al_263 <= 0x2E) | ((int8) (al_263 == 0x5F) | (int8) (al_263 == 0x3A))) == 0x00 && (*((word32) esi_254 + esi_265 * 0x02) & 0x08) == 0x00)
			{
				if (al_263 == 0x2F)
				{
					if (dwLoc5C_681 == 0x02)
						goto l080556C2;
					*ecx_257 = 0x2F;
					ecx_257 = (word32) ecx_257 + 1;
					++dwLoc5C_681;
					ebp_269 = dwLoc5C_681 + 0x02;
				}
			}
			else
			{
				ecx_257 = (word32) ecx_257 + 1;
				*((word32) ecx_257 - 1) = ecx_255[esi_265];
			}
			ebx_259 = (word32) ebx_259 + 1;
			eax_243 = (word32) *ebx_259;
		} while ((byte) eax_243 != 0x00);
		if (dwLoc5C_681 <= 0x01)
		{
			*ecx_257 = 0x2F;
			eax_249 = (word32) ecx_257 + 1;
			if (ebp_269 == 0x01)
			{
l080556BC:
				*eax_249 = 0x2F;
				ecx_257 = (word32) eax_249 + 1;
				goto l080556C2;
			}
			ecx_257 = eax_249;
		}
l080556C2:
		*ecx_257 = 0x00;
		if (*((word32) eax_198 + 2) == 0x00)
		{
			struct Eq_21709 * edx_353 = (word32) eax_169 + 5;
			Eq_3803 ecx_354[] = g_ptr80CE084;
			Eq_2 eax_355 = eax_198;
			do
			{
				++edx_353;
				eax_355 = (word32) eax_355 + 1;
				Eq_3803 bl_367 = ecx_354[(int32) edx_353->bFFFFFFFF];
				*((word32) eax_355 - 1) = bl_367;
			} while (bl_367 != 0x00);
		}
		if (__wcsmbs_named_conv(fp - 0x30) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_970;
			word32 ecx_969;
			free(gs, stackArg0, eax_198, out ecx_969, out edx_970);
			esp_455 = fp - 0x6C;
			if (dwLoc2C != 0x01)
				goto l08055885;
			if (dwLoc24 != 0x01)
			{
l08055862:
				word32 ecx_973;
				word32 edx_974;
				__assert_fail(out ecx_973, out edx_974);
				esp_455 = fp - 0x7C;
l08055885:
				word32 ebx_564 = esp_455->dw0018;
				struct Eq_21760 * esp_566 = esp_455 - 4;
				esp_566->dw0000 = ebx_564 + 4294789224;
				esp_566->dwFFFFFFFC = 322;
				esp_566->dwFFFFFFF8 = ebx_564 + ~0x0002B855;
				esp_566->dwFFFFFFF4 = ebx_564 + 4294789179;
				word32 edx_972;
				word32 ecx_971;
				__assert_fail(out ecx_971, out edx_972);
			}
			Eq_2 eax_460 = *((word32) dwArg04 + 88);
			Eq_2 edx_462 = *((word32) eax_460 + 4);
			*((word32) eax_460 + 44) = 0x00;
			((word32) eax_460 + 48)->u0 = 0x00;
			*eax_460 = edx_462;
			*((word32) eax_460 + 16) = *((word32) eax_460 + 0x0C);
			Eq_2 eax_470 = *((word32) dwArg04 + 88);
			((word32) eax_470 + 52)->u0 = 0x00;
			((word32) eax_470 + 56)->u0 = 0x00;
			Eq_2 eax_473 = *((word32) dwArg04 + 88);
			*((word32) dwArg04 + 84) = (word32) eax_473 + 60;
			word32 * esi_464 = (word32 *) 0x080CCFC0;
			word32 ecx_465;
			word32 * edi_476 = (word32) eax_473 + 60;
			for (ecx_465 = 0x1C; ecx_465 != 0x00; --ecx_465)
			{
				*edi_476 = *esi_464;
				++esi_464;
				++edi_476;
			}
			((word32) eax_473 + 92)->u0 = 0x01;
			*((word32) eax_473 + 96) = dwLoc30;
			word32 ebx_487 = eax_151->dw0058;
			*((word32) eax_473 + 112) = 0x00;
			*((word32) eax_473 + 116) = 0x01;
			*((word32) eax_473 + 0x006C) = 0x01;
			*((word32) eax_473 + 0x0078) = ebx_487 + 44;
			*((word32) eax_473 + 0x0084) = (struct Eq_21880 *) 0x01;
			*((word32) eax_473 + 0x0088) = dwLoc28;
			((word32) eax_473 + 0x0098)->u0 = 0x00;
			*((word32) eax_473 + 0x009C) = 0x01;
			((word32) eax_473 + 0x0094)->u0 = 0x09;
			*((word32) eax_473 + 0x00A0) = ebx_487 + 44;
			*((word32) dwArg04 + 0x0094) = *((word32) eax_473 + 0x00B0);
			eax_151->dw0068 = 0x01;
			goto l08055410;
		}
		_IO_file_close_it(dwArg04);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_966;
		word32 edx_967;
		free(gs, stackArg0, eax_198, out ecx_966, out edx_967);
		gs->tFFFFFFE0.u0 = 22;
		goto l08055630;
	}
}

// 080558B0: void _IO_new_file_finish(Stack Eq_2 dwArg04)
// Called from:
//      _IO_file_fopen
void _IO_new_file_finish(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 56) != ~0x00)
	{
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			Eq_2 eax_38 = *((word32) dwArg04 + 88);
			Eq_2 edx_40 = *((word32) eax_38 + 0x0C);
			word32 ebx_137;
			word32 esi_138;
			_IO_wdo_write(gs, dwArg04, edx_40, *((word32) eax_38 + 16) - edx_40 >> 0x02, out ebx_137, out esi_138);
		}
		else
			_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16));
		if ((*dwArg04 & 0x40) == 0x00)
		{
			Eq_2 edi_62 = *((word32) dwArg04 + 0x0094);
			if (edi_62 >= 135066356)
			{
				word32 ecx_139;
				word32 edx_140;
				_IO_vtable_check(out ecx_139, out edx_140);
			}
			word32 ecx_88;
			(*((word32) edi_62 + 0x0044))();
		}
	}
	_IO_default_finish(dwArg04);
}

// 08055960: void _IO_new_file_overflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _IO_new_file_overflow(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 eax_21 = *dwArg04;
	Eq_2 ebx_19 = dwArg04;
	word32 esi_20 = dwArg08;
	byte ah_35 = SLICE(eax_21, byte, 8);
	if (((byte) eax_21 & 0x08) != 0x00)
	{
		*dwArg04 = eax_21 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		return;
	}
	Eq_2 edx_102;
	Eq_2 edx_34 = *((word32) dwArg04 + 16);
	if ((ah_35 & 0x08) != 0x00)
	{
		if (edx_34 != 0x00)
		{
			edx_102 = *((word32) dwArg04 + 20);
			goto l0805599B;
		}
	}
	else if (edx_34 != 0x00)
	{
		edx_102 = *((word32) dwArg04 + 4);
l080559EB:
		Eq_2 eax_106 = eax_21;
		if ((SLICE(eax_21, byte, 8) & 0x01) != 0x00)
		{
			uint32 edi_80 = *((word32) dwArg04 + 8) - edx_102;
			_IO_free_backup_area(dwArg04);
			Eq_2 edx_90 = *((word32) dwArg04 + 0x0C);
			uint32 ecx_94 = edx_90 - *((word32) dwArg04 + 28);
			ui32 ebp_91 = -edi_80;
			ui32 eax_101 = -ecx_94;
			if (ecx_94 > edi_80)
				eax_101 = ebp_91;
			edx_102 = (word32) edx_90 + eax_101;
			eax_106 = *dwArg04;
			*((word32) dwArg04 + 0x0C) = edx_102;
			*((word32) dwArg04 + 4) = edx_102;
		}
		Eq_2 ecx_117;
		Eq_2 edi_111 = *((word32) dwArg04 + 32);
		if (edi_111 != edx_102)
			ecx_117 = *((word32) dwArg04 + 8);
		else
		{
			edx_102 = *((word32) dwArg04 + 28);
			*((word32) dwArg04 + 8) = edx_102;
			ecx_117 = edx_102;
		}
		*((word32) dwArg04 + 4) = ecx_117;
		*((word32) dwArg04 + 0x0C) = ecx_117;
		*((word32) dwArg04 + 20) = edx_102;
		*dwArg04 = SEQ(SLICE(eax_106, word16, 16), SLICE(eax_106, byte, 8) | 0x08, (byte) eax_106);
		Eq_2 ecx_140 = *((word32) dwArg04 + 0x0068);
		*((word32) dwArg04 + 16) = edx_102;
		*((word32) dwArg04 + 24) = edi_111;
		if (ecx_140 <= 0x00 && (eax_106 & 0x0202) != 0x00)
		{
			*((word32) dwArg04 + 24) = edx_102;
			if (dwArg08 != ~0x00)
			{
l080559A4:
				ptr32 esp_207 = fp - 0x1C;
				if (*((word32) dwArg04 + 32) == edx_102)
				{
					int8 al_225;
					if (*((word32) dwArg04 + 0x0068) > 0x00)
					{
						Eq_2 eax_226 = *((word32) dwArg04 + 88);
						Eq_2 esp_253 = <invalid>;
						Eq_2 edx_228 = *((word32) eax_226 + 0x0C);
						esp_207 = (word32) esp_253 + 16;
						al_225 = (int8) (_IO_wdo_write(gs, dwArg04, edx_228, *((word32) eax_226 + 16) - edx_228 >> 0x02, out ebx_19, out esi_20) == ~0x00);
					}
					else
					{
						esp_207 = fp - 0x1C;
						al_225 = (int8) (_IO_do_write(edx_102 - *((word32) dwArg04 + 16)) == ~0x00);
					}
					if (al_225 != 0x00)
						return;
					edx_102 = *((word32) ebx_19 + 20);
				}
				*((word32) ebx_19 + 20) = (word32) edx_102 + 1;
				*edx_102 = (byte) esi_20;
				Eq_2 eax_279 = *ebx_19;
				byte ah_284 = SLICE(eax_279, byte, 8);
				if (((byte) eax_279 & 0x02) == 0x00 && ((ah_284 & 0x02) == 0x00 || esi_20 != 0x0A))
					return;
				Eq_2 edx_292 = *((word32) ebx_19 + 16);
				struct Eq_22105 * esp_297 = esp_207 - 0x04;
				esp_297->tFFFFFFFC = *((word32) ebx_19 + 20) - edx_292;
				esp_297->tFFFFFFF8 = edx_292;
				esp_297->tFFFFFFF4 = ebx_19;
				if (_IO_do_write(esp_297->tFFFFFFFC) != ~0x00)
					return;
				return;
			}
l08055A3A:
			_IO_do_write(edx_102 - *((word32) dwArg04 + 16));
			return;
		}
l0805599B:
		if (dwArg08 != ~0x00)
			goto l080559A4;
		goto l08055A3A;
	}
	_IO_doallocbuf(dwArg04);
	edx_102 = *((word32) dwArg04 + 28);
	eax_21 = *dwArg04;
	*((word32) dwArg04 + 0x0C) = edx_102;
	*((word32) dwArg04 + 4) = edx_102;
	*((word32) dwArg04 + 8) = edx_102;
	goto l080559EB;
}

// 08055B70: void _IO_new_file_sync(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_new_file_sync(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_102 = fp - 44;
	Eq_2 ebx_19 = dwArg04;
	Eq_2 eax_20 = *((word32) dwArg04 + 20);
	Eq_2 edx_21 = *((word32) dwArg04 + 16);
	if (eax_20 > edx_21)
	{
		int8 al_45;
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			Eq_2 eax_46 = *((word32) dwArg04 + 88);
			Eq_2 esp_67 = <invalid>;
			Eq_2 edx_48 = *((word32) eax_46 + 0x0C);
			esp_102 = (word32) esp_67 + 16;
			word32 esi_225;
			al_45 = (int8) (_IO_wdo_write(gs, dwArg04, edx_48, *((word32) eax_46 + 16) - edx_48 >> 0x02, out ebx_19, out esi_225) != 0x00);
		}
		else
		{
			esp_102 = fp - 44;
			al_45 = (int8) (_IO_do_write(eax_20 - edx_21) != 0x00);
		}
		if (al_45 != 0x00)
			return;
	}
	Eq_2 eax_107 = *((word32) ebx_19 + 4) - *((word32) ebx_19 + 8);
	if (eax_107 != 0x00)
	{
		Eq_2 edi_89 = *((word32) ebx_19 + 0x0094);
		if (edi_89 >= 135066356)
		{
			*((word32) esp_102 + 0x0C) = eax_107;
			word32 edx_227;
			word32 ecx_226;
			_IO_vtable_check(out ecx_226, out edx_227);
			esp_102.u0 = <invalid>;
			eax_107 = *((byte) esp_102.u0 + 0x0C);
		}
		struct Eq_22361 * esp_111 = esp_102 - 4;
		esp_111->dw0000 = 0x01;
		int64 edx_eax_109 = (int64) eax_107;
		word32 edx_114 = SLICE(edx_eax_109, word32, 32);
		esp_111->dwFFFFFFFC = edx_114;
		word32 eax_117 = (word32) edx_eax_109;
		esp_111->dwFFFFFFF8 = eax_117;
		esp_111->tFFFFFFF4 = ebx_19;
		ui32 eax_133;
		ui32 edx_134;
		word32 ecx_135;
		(*((word32) edi_89 + 64))();
		if ((eax_133 & edx_134) != ~0x00)
			*((word32) ebx_19 + 8) = *((word32) ebx_19 + 4);
		else if (gs->tFFFFFFE0 != 0x1D)
			return;
	}
	((word32) ebx_19 + 76)->u0 = ~0x00;
	((word32) ebx_19 + 80)->u0 = ~0x00;
}

// 08055C60: Register Eq_2 save_for_backup(Register Eq_2 eax, Register Eq_2 edx, Register out Eq_2 ecxOut)
// Called from:
//      __underflow
//      __uflow
//      _IO_str_pbackfail
Eq_2 save_for_backup(Eq_2 eax, Eq_2 edx, union Eq_2 & ecxOut)
{
	Eq_2 eax_300;
	Eq_2 edx_187;
	Eq_2 ebx_192;
	Eq_2 esi_196;
	Eq_2 eax_21 = *((word32) eax + 0x0C);
	Eq_2 eax_188 = *((word32) eax + 48);
	Eq_2 esi_22 = *((word32) eax + 36);
	Eq_2 edx_27 = *((word32) eax + 44);
	Eq_2 edi_181 = edx - eax_21;
	Eq_2 ecx_177 = eax_188;
	Eq_2 edx_191 = edx_27 - esi_22;
	if (eax_188 != 0x00)
	{
		esi_196 = edi_181;
		do
		{
			Eq_2 ebx_49 = *((word32) ecx_177 + 8);
			ecx_177 = *ecx_177;
			if (esi_196 > ebx_49)
				esi_196 = ebx_49;
		} while (ecx_177 != 0x00);
		ecx_177 = edi_181 - esi_196;
		if (ecx_177 > edx_191)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_440;
			word32 edi_443;
			word32 edx_439;
			word32 esi_442;
			word32 ebp_441;
			Eq_2 eax_82 = __libc_malloc(gs, stackArg0, (word32) ecx_177 + 100, out ecx_177, out edx_439, out ebx_440, out ebp_441, out esi_442, out edi_443);
			if (eax_82 == 0x00)
			{
				eax_300.u0 = ~0x00;
l08055CEB:
				ecxOut = ecx_177;
				return eax_300;
			}
			if (esi_196 >= 0x00)
			{
				word32 edx_451;
				word32 ecx_450;
				memcpy((word32) eax_82 + 100, esi_196 + eax_21, ecx_177, out ecx_450, out edx_451);
			}
			else
			{
				word32 edx_449;
				word32 edx_447;
				word32 ecx_448;
				memcpy(__mempcpy((word32) eax_82 + 100, esi_196 + edx_27, -esi_196, out edx_447), eax_21, edi_181, out ecx_448, out edx_449);
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_453;
			free(gs, stackArg0, esi_22, out ecx_177, out edx_453);
			edi_181 = edx - *((word32) eax + 0x0C);
			*((word32) eax + 36) = eax_82;
			*((word32) eax + 44) = (word32) eax_82 + ((word32) ecx_177 + 100);
			edx_187 = (word32) eax_82 + 100;
			eax_188 = *((word32) eax + 48);
			goto l08055D7F;
		}
		edx_191 -= ecx_177;
		ebx_192 = esi_22 + edx_191;
		if (esi_196 >= 0x00)
		{
			if (ecx_177 == 0x00)
			{
				*((word32) eax + 40) = ebx_192;
				goto l08055CE0;
			}
			word32 edx_446;
			memcpy(ebx_192, esi_196 + eax_21, ecx_177, out ecx_177, out edx_446);
			edx_187 = edx_191 + Mem265[eax + 0x24:word32];
			edi_181 = edx - *((word32) eax + 0x0C);
			eax_188 = *((word32) eax + 48);
l08055D7F:
			*((word32) eax + 40) = edx_187;
			if (eax_188 == 0x00)
			{
l08055CE9:
				eax_300.u0 = 0x00;
				goto l08055CEB;
			}
l08055CE0:
			do
			{
				*((word32) eax_188 + 8) -= edi_181;
				eax_188 = *eax_188;
			} while (eax_188 != 0x00);
			goto l08055CE9;
		}
	}
	else
	{
		if (edi_181 >= 0x00)
		{
			*((word32) eax + 40) = edx_27;
			goto l08055CE9;
		}
		ebx_192 = edx_27;
		esi_196 = edi_181;
	}
	word32 edx_444;
	memmove(ebx_192, edx_27 + esi_196, -esi_196, out edx_444);
	Eq_2 ecx_225 = *((word32) eax + 0x0C);
	word32 edx_445;
	memcpy((word32) *((word32) eax + 36) + (edx_191 - esi_196), ecx_225, edx - ecx_225, out ecx_177, out edx_445);
	edi_181 = edx - *((word32) eax + 0x0C);
	edx_187 = edx_191 + Mem237[eax + 0x24:word32];
	eax_188 = *((word32) eax + 48);
	goto l08055D7F;
}

// 08055E80: void flush_cleanup(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
void flush_cleanup(Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_2 eax_7 = run_fp;
	if (eax_7 != 0x00 && (*eax_7 & 0x8000) == 0x00)
	{
		ecx = *((word32) eax_7 + 72);
		Eq_2 v13_15 = *((word32) ecx + 4) - 0x01;
		*((word32) ecx + 4) = v13_15;
		if (v13_15 == 0x00)
		{
			((word32) ecx + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v14_25 = *ecx - 0x01;
			*ecx = v14_25;
			if (v14_25 != 0x00)
				__lll_unlock_wake_private(ecx, ecx, 0x080CE000, gs);
		}
	}
	Eq_2 v9_37 = g_t80CF83C - 0x01;
	g_t80CF83C = v9_37;
	if (v9_37 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v11_48 = g_t80CF838 - 0x01;
		g_t80CF838 = v11_48;
		if (v11_48 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx, 0x080CE000, gs);
	}
}

// 08055F10: void _IO_un_link.part.2(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_un_link
//      _IO_str_finish
void _IO_un_link.part.2(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2175 eax_28 = gs->t0014;
	Mem55 = Mem37;
	Eq_2 edx_56 = gs->t0008;
	if (edx_56 != g_t80CF840)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_68;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_68))
			__lll_lock_wait_private(eax_68, 0x080CF838, gs);
		g_t80CF840 = edx_56;
	}
	Eq_2 edx_151;
	Eq_2 ecx_107;
	Eq_2 ecx_89 = *eax;
	Eq_2 ebp_84 = g_t80CF83C;
	run_fp = eax;
	g_t80CF83C = (word32) ebp_84 + 1;
	byte cl_102 = (byte) ecx_89;
	word24 ecx_24_8_106 = SLICE(ecx_89, word24, 8);
	Eq_2 ebp_243 = (word32) ebp_84 + 1;
	ui32 eax_141 = ecx_89 & 0x8000;
	if ((ecx_89 & 0x8000) == 0x00)
	{
		Eq_2 edx_109 = *((word32) eax + 72);
		Eq_2 ebp_112 = gs->t0008;
		if (ebp_112 != *((word32) edx_109 + 8))
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_122;
			if (!__cmpxchg(*edx_109, 0x01, ecx_89 & 0x8000, out eax_122))
				__lll_lock_wait_private(eax_122, edx_109, gs);
			Eq_2 ecx_136 = *eax;
			edx_109 = *((word32) eax + 72);
			*((word32) edx_109 + 8) = ebp_112;
			cl_102 = (byte) ecx_136;
			ecx_24_8_106 = SLICE(ecx_136, word24, 8);
			eax_141 = ecx_136 & 0x8000;
		}
		*((word32) edx_109 + 4) = (word32) *((word32) edx_109 + 4) + 1;
		edx_151 = _IO_list_all;
		if (edx_151 == 0x00)
			goto l08056031;
	}
	else
	{
		edx_151 = _IO_list_all;
		if (edx_151 == 0x00)
		{
			ecx_107 = SEQ(ecx_24_8_106, cl_102 & 0x7F);
			*eax = ecx_107;
			goto l0805604D;
		}
	}
	Eq_2 ebp_157 = *((word32) edx_151 + 52);
	if (eax != edx_151)
	{
		if (ebp_157 != 0x00)
		{
			word32 * ebp_178;
			if (eax == ebp_157)
			{
				ebp_178 = (word32) edx_151 + 52;
l08056133:
				edx_151 = *((word32) eax + 52);
				*ebp_178 = (word32) edx_151;
			}
			else
			{
				while (true)
				{
					edx_151 = *((word32) ebp_157 + 52);
					if (edx_151 == 0x00)
						break;
					if (eax == edx_151)
					{
						ebp_178 = (word32) ebp_157 + 52;
						goto l08056133;
					}
					ebp_157 = edx_151;
				}
			}
		}
	}
	else
		_IO_list_all = ebp_157;
l08056031:
	ecx_107 = SEQ(ecx_24_8_106, cl_102 & 0x7F);
	*eax = ecx_107;
	if (eax_141 == 0x00)
	{
		edx_151 = *((word32) eax + 72);
		Eq_2 v17_212 = *((word32) edx_151 + 4) - 0x01;
		*((word32) edx_151 + 4) = v17_212;
		if (v17_212 == 0x00)
		{
			((word32) edx_151 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v19_227 = *edx_151 - 0x01;
			*edx_151 = v19_227;
			if (v19_227 != 0x00)
				__lll_unlock_wake_private(edx_151, ecx_107, edx_151, gs);
		}
	}
	ebp_243 = g_t80CF83C;
l0805604D:
	run_fp.u0 = 0x00;
	Eq_2 ebp_247 = ebp_243 - 0x01;
	g_t80CF83C = ebp_247;
	if (ebp_247 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v18_259 = g_t80CF838 - 0x01;
		g_t80CF838 = v18_259;
		if (v18_259 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_107, edx_151, gs);
	}
	if ((eax_28 ^ gs->t0014) == 0x00)
		return;
	word32 edx_515;
	word32 ecx_514;
	__stack_chk_fail(out ecx_514, out edx_515);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	_IO_un_link(stackArg4);
}

// 08056150: void _IO_un_link(Stack Eq_2 dwArg04)
// Called from:
//      __new_fclose
//      __fopen_internal
//      _IO_file_close_it
//      _IO_un_link.part.2
//      _IO_wdefault_finish
void _IO_un_link(Eq_2 dwArg04)
{
	if ((*dwArg04 & 0x80) == 0x00)
		return;
	_IO_un_link.part.2(eax, gs);
}

// 08056170: void _IO_link_in(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _IO_new_file_init_internal
//      _IO_file_init
//      _IO_file_open
void _IO_link_in(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_24 = *dwArg04;
	Eq_2175 eax_20 = gs->t0014;
	byte al_25 = (byte) eax_24;
	word24 eax_24_8_31 = SLICE(eax_24, word24, 8);
	if ((al_25 & 0x80) != 0x00)
	{
l08056303:
		if ((eax_20 ^ gs->t0014) == 0x00)
			return;
		word32 edx_406;
		word32 ecx_405;
		__stack_chk_fail(out ecx_405, out edx_406);
	}
	*dwArg04 = SEQ(eax_24_8_31, al_25 | 0x80);
	Mem57 = Mem39;
	Eq_2 ecx_138 = ecx;
	Eq_2 edx_58 = gs->t0008;
	if (g_t80CF840 != edx_58)
	{
		ecx_138.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_70;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_70))
			ecx_138 = __lll_lock_wait_private(eax_70, 0x080CF838, gs);
		g_t80CF840 = edx_58;
	}
	Eq_2 edx_86 = g_t80CF83C;
	ui32 eax_91 = *dwArg04;
	run_fp = dwArg04;
	g_t80CF83C = (word32) edx_86 + 1;
	Eq_2 edx_180 = (word32) edx_86 + 1;
	if ((eax_91 & 0x8000) != 0x00)
	{
		Eq_2 eax_99 = _IO_list_all;
		_IO_list_all = dwArg04;
		*((word32) dwArg04 + 52) = eax_99;
		goto l080562AF;
	}
	Eq_2 edx_102 = *((word32) dwArg04 + 72);
	Eq_2 ebp_105 = gs->t0008;
	if (*((word32) edx_102 + 8) != ebp_105)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_121;
		if (!__cmpxchg(*edx_102, 0x01, eax_91 & 0x8000, out eax_121))
			__lll_lock_wait_private(eax_121, edx_102, gs);
		edx_102 = *((word32) dwArg04 + 72);
		byte ah_146 = *((word32) dwArg04 + 1);
		ecx_138 = _IO_list_all;
		_IO_list_all = dwArg04;
		*((word32) edx_102 + 8) = ebp_105;
		*((word32) edx_102 + 4) = (word32) *((word32) edx_102 + 4) + 1;
		*((word32) dwArg04 + 52) = ecx_138;
		if ((ah_146 & 0x80) != 0x00)
		{
l08056297:
			edx_180 = g_t80CF83C;
l080562AF:
			run_fp.u0 = 0x00;
			Eq_2 edx_184 = edx_180 - 0x01;
			g_t80CF83C = edx_184;
			if (edx_184 == 0x00)
			{
				g_t80CF840.u0 = 0x00;
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v19_195 = g_t80CF838 - 0x01;
				g_t80CF838 = v19_195;
				if (v19_195 != 0x00)
					__lll_unlock_wake_private(0x080CF838, ecx_138, edx_184, gs);
			}
			goto l08056303;
		}
	}
	else
	{
		Eq_2 eax_108 = _IO_list_all;
		*((word32) edx_102 + 4) = (word32) *((word32) edx_102 + 4) + 1;
		_IO_list_all = dwArg04;
		*((word32) dwArg04 + 52) = eax_108;
	}
	Eq_2 v18_152 = *((word32) edx_102 + 4) - 0x01;
	*((word32) edx_102 + 4) = v18_152;
	if (v18_152 == 0x00)
	{
		((word32) edx_102 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v21_163 = *edx_102 - 0x01;
		*edx_102 = v21_163;
		if (v21_163 != 0x00)
			__lll_unlock_wake_private(edx_102, ecx_138, edx_102, gs);
	}
	goto l08056297;
}

// 08056360: void _IO_least_marker(Stack (ptr32 Eq_23159) dwArg04, Stack word32 dwArg08)
// Called from:
//      _IO_link_in
void _IO_least_marker(struct Eq_23159 * dwArg04, word32 dwArg08)
{
	int32 eax_19 = dwArg08 - dwArg04->dw000C;
	struct Eq_23166 * edx_15 = dwArg04->ptr0030;
	while (edx_15 != null)
	{
		int32 ecx_17 = edx_15->dw0008;
		edx_15 = edx_15->ptr0000;
		if (eax_19 > ecx_17)
			eax_19 = ecx_17;
	}
}

// 08056390: void _IO_switch_to_main_get_area(Stack Eq_2 dwArg04)
// Called from:
//      _IO_file_xsgetn_mmap
//      _IO_file_xsgetn
void _IO_switch_to_main_get_area(Eq_2 dwArg04)
{
	Eq_2 edx_6 = *((word32) dwArg04 + 8);
	Eq_2 ecx_7 = *((word32) dwArg04 + 44);
	*dwArg04 &= ~0x0100;
	*((word32) dwArg04 + 8) = ecx_7;
	Eq_2 ecx_13 = *((word32) dwArg04 + 0x0C);
	*((word32) dwArg04 + 44) = edx_6;
	Eq_2 edx_15 = *((word32) dwArg04 + 36);
	*((word32) dwArg04 + 36) = ecx_13;
	*((word32) dwArg04 + 0x0C) = edx_15;
	*((word32) dwArg04 + 4) = edx_15;
}

// 080563C0: void _IO_switch_to_backup_area(Stack (ptr32 Eq_23221) dwArg04)
void _IO_switch_to_backup_area(struct Eq_23221 * dwArg04)
{
	word32 ecx_8 = dwArg04->dw0008;
	word32 edx_9 = dwArg04->dw002C;
	word32 ebx_10 = dwArg04->dw0024;
	dwArg04->dw0000 |= 0x0100;
	dwArg04->dw002C = ecx_8;
	word32 ecx_16 = dwArg04->dw000C;
	dwArg04->dw0008 = edx_9;
	dwArg04->dw000C = ebx_10;
	dwArg04->dw0024 = ecx_16;
	dwArg04->dw0004 = edx_9;
}

// 080563F0: Register word32 _IO_switch_to_get_mode(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      _IO_wfile_underflow
//      _IO_new_file_underflow
//      _IO_new_file_seekoff
//      __underflow
//      __uflow
//      _IO_init_marker
word32 _IO_switch_to_get_mode(Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 ecx_104;
	word32 eax_103;
	Eq_2 eax_14 = *((word32) dwArg04 + 20);
	if (eax_14 > *((word32) dwArg04 + 16))
	{
		Eq_2 esi_17 = *((word32) dwArg04 + 0x0094);
		if (esi_17 >= 135066356)
		{
			word32 ecx_114;
			word32 edx_115;
			_IO_vtable_check(out ecx_114, out edx_115);
		}
		(*((word32) esi_17 + 0x0C))();
		if (eax_103 == ~0x00)
		{
l08056465:
			ecxOut = ecx_104;
			return eax_103;
		}
		eax_14 = *((word32) dwArg04 + 20);
	}
	word32 edx_49 = *dwArg04;
	byte dh_50 = SLICE(edx_49, byte, 8);
	byte dl_68 = (byte) edx_49;
	word16 edx_16_16_70 = SLICE(edx_49, word16, 16);
	if ((dh_50 & 0x01) == 0x00)
	{
		ecx_104 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 0x0C) = ecx_104;
		if (*((word32) dwArg04 + 8) < eax_14)
			*((word32) dwArg04 + 8) = eax_14;
	}
	else
	{
		ecx_104 = *((word32) dwArg04 + 40);
		*((word32) dwArg04 + 0x0C) = ecx_104;
	}
	*((word32) dwArg04 + 4) = eax_14;
	*dwArg04 = SEQ(edx_16_16_70, dh_50 & ~0x08, dl_68);
	*((word32) dwArg04 + 24) = eax_14;
	*((word32) dwArg04 + 16) = eax_14;
	eax_103 = 0x00;
	goto l08056465;
}

// 08056490: void _IO_free_backup_area(Stack Eq_2 dwArg04)
// Called from:
//      __new_fclose
//      _IO_new_file_seekoff
//      _IO_new_file_overflow
//      __underflow
//      __uflow
//      _IO_unsave_markers
void _IO_free_backup_area(Eq_2 dwArg04)
{
	word32 edx_23 = *dwArg04;
	byte dh_25 = SLICE(edx_23, byte, 8);
	byte dl_33 = (byte) edx_23;
	word16 edx_16_16_34 = SLICE(edx_23, word16, 16);
	Eq_2 eax_24 = *((word32) dwArg04 + 36);
	if ((dh_25 & 0x01) != 0x00)
	{
		*((word32) dwArg04 + 4) = eax_24;
		*dwArg04 = SEQ(edx_16_16_34, dh_25 & ~0x01, dl_33);
		*((word32) dwArg04 + 8) = *((word32) dwArg04 + 44);
		Eq_2 edx_39 = *((word32) dwArg04 + 0x0C);
		*((word32) dwArg04 + 0x0C) = eax_24;
		eax_24 = edx_39;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_79;
	word32 edx_80;
	free(gs, stackArg0, eax_24, out ecx_79, out edx_80);
	((word32) dwArg04 + 36)->u0 = 0x00;
	((word32) dwArg04 + 44)->u0 = 0x00;
	*((word32) dwArg04 + 40) = 0x00;
}

// 080564F0: Register word32 __overflow(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_12977) ecxOut, Register out (ptr32 Eq_12978) edxOut)
// Called from:
//      _IO_puts
//      _IO_helper_overflow
//      printf_positional
//      __printf_fp_l
//      __printf_fphex
word32 __overflow(Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_12977 & ecxOut, struct Eq_12978 & edxOut)
{
	if (*((word32) dwArg04 + 0x0068) == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	Eq_2 esi_24 = *((word32) dwArg04 + 0x0094);
	if (esi_24 >= 135066356)
	{
		word32 ecx_78;
		word32 edx_79;
		_IO_vtable_check(out ecx_78, out edx_79);
	}
	word32 eax_53;
	struct Eq_12978 * edx_54;
	struct Eq_12977 * ecx_55;
	(*((word32) esi_24 + 0x0C))();
	ecxOut = ecx_55;
	edxOut = edx_54;
	return eax_53;
}

// 08056550: Register word32 __underflow(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      _IO_file_xsgetn
//      _IO_default_xsgetn
//      _IO_getdelim
word32 __underflow(Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	word32 eax_109;
	Eq_2 eax_16 = *((word32) dwArg04 + 0x0068);
	if (eax_16 == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	else if (eax_16 != ~0x00)
		goto l08056609;
	if ((*dwArg04 & 0x0800) != 0x00 && _IO_switch_to_get_mode(dwArg04, out ecx) == ~0x00)
	{
l08056609:
		eax_109 = ~0x00;
l0805662B:
		ecxOut = ecx;
		return eax_109;
	}
	Eq_2 eax_45 = *((word32) dwArg04 + 4);
	Eq_2 edx_46 = *((word32) dwArg04 + 8);
	if (eax_45 >= edx_46)
	{
		ui32 eax_49 = *dwArg04;
		byte ah_50 = SLICE(eax_49, byte, 8);
		byte al_57 = (byte) eax_49;
		word16 eax_16_16_58 = SLICE(eax_49, word16, 16);
		if ((ah_50 & 0x01) == 0x00)
		{
l080565BA:
			if (*((word32) dwArg04 + 48) == 0x00)
			{
				if (*((word32) dwArg04 + 36) != 0x00)
					_IO_free_backup_area(dwArg04);
				goto l080565CF;
			}
			if (save_for_backup(dwArg04, *((word32) dwArg04 + 8), out ecx) == 0x00)
			{
l080565CF:
				Eq_2 edi_123 = *((word32) dwArg04 + 0x0094);
				if (edi_123 >= 135066356)
				{
					word32 ecx_247;
					word32 edx_248;
					_IO_vtable_check(out ecx_247, out edx_248);
				}
				word32 eax_150;
				word32 edx_151;
				Eq_2 ecx_152;
				(*((word32) edi_123 + 16))();
				ecxOut = ecx_152;
				return eax_150;
			}
			goto l08056609;
		}
		ecx = *((word32) dwArg04 + 44);
		*((word32) dwArg04 + 44) = edx_46;
		*dwArg04 = SEQ(eax_16_16_58, ah_50 & ~0x01, al_57);
		Eq_2 edx_61 = *((word32) dwArg04 + 0x0C);
		eax_45 = *((word32) dwArg04 + 36);
		*((word32) dwArg04 + 8) = ecx;
		*((word32) dwArg04 + 36) = edx_61;
		*((word32) dwArg04 + 0x0C) = eax_45;
		*((word32) dwArg04 + 4) = eax_45;
		if (ecx <= eax_45)
			goto l080565BA;
	}
	eax_109 = (word32) *eax_45;
	goto l0805662B;
}

// 08056660: Register word32 __uflow(Stack Eq_2 dwArg04)
// Called from:
//      _IO_getline_info
word32 __uflow(Eq_2 dwArg04)
{
	word32 eax_111;
	Eq_2 eax_16 = *((word32) dwArg04 + 0x0068);
	if (eax_16 == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	else if (eax_16 != ~0x00)
		goto l08056719;
	if ((*dwArg04 & 0x0800) != 0x00)
	{
		word32 ecx_247;
		if (_IO_switch_to_get_mode(dwArg04, out ecx_247) == ~0x00)
			goto l08056719;
	}
	Eq_2 eax_45 = *((word32) dwArg04 + 4);
	Eq_2 edx_46 = *((word32) dwArg04 + 8);
	if (eax_45 >= edx_46)
	{
		ui32 eax_49 = *dwArg04;
		byte ah_50 = SLICE(eax_49, byte, 8);
		byte al_57 = (byte) eax_49;
		word16 eax_16_16_58 = SLICE(eax_49, word16, 16);
		if ((ah_50 & 0x01) == 0x00)
		{
l080566CA:
			if (*((word32) dwArg04 + 48) == 0x00)
			{
				if (*((word32) dwArg04 + 36) != 0x00)
					_IO_free_backup_area(dwArg04);
				goto l080566DF;
			}
			word32 ecx_248;
			if (save_for_backup(dwArg04, *((word32) dwArg04 + 8), out ecx_248) == 0x00)
			{
l080566DF:
				Eq_2 edi_125 = *((word32) dwArg04 + 0x0094);
				if (edi_125 >= 135066356)
				{
					word32 edx_250;
					word32 ecx_249;
					_IO_vtable_check(out ecx_249, out edx_250);
				}
				word32 eax_152;
				word32 edx_153;
				word32 ecx_154;
				(*((word32) edi_125 + 20))();
				return eax_152;
			}
l08056719:
			eax_111 = ~0x00;
			return eax_111;
		}
		Eq_2 ecx_55 = *((word32) dwArg04 + 44);
		*((word32) dwArg04 + 44) = edx_46;
		*dwArg04 = SEQ(eax_16_16_58, ah_50 & ~0x01, al_57);
		Eq_2 edx_61 = *((word32) dwArg04 + 0x0C);
		eax_45 = *((word32) dwArg04 + 36);
		*((word32) dwArg04 + 8) = ecx_55;
		*((word32) dwArg04 + 36) = edx_61;
		*((word32) dwArg04 + 0x0C) = eax_45;
		if (ecx_55 <= eax_45)
		{
			*((word32) dwArg04 + 4) = eax_45;
			goto l080566CA;
		}
	}
	*((word32) dwArg04 + 4) = (word32) eax_45 + 1;
	eax_111 = (word32) *eax_45;
	return eax_111;
}

// 08056770: void _IO_setb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      decide_maybe_mmap
//      _IO_file_close_it
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_init_static_internal
//      _IO_file_doallocate
void _IO_setb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	ui32 eax_15 = *dwArg04;
	Eq_2 edx_14 = *((word32) dwArg04 + 28);
	byte al_19 = (byte) eax_15;
	if (edx_14 != 0x00 && (al_19 & 0x01) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_84;
		word32 edx_85;
		free(gs, stackArg0, edx_14, out ecx_84, out edx_85);
		eax_15 = (ui32) *dwArg04;
	}
	*((word32) dwArg04 + 28) = dwArg08;
	*((word32) dwArg04 + 32) = dwArg0C;
	ui32 eax_44 = eax_15 | 0x01;
	ui32 edx_45 = eax_15 & ~0x01;
	if (dwArg10 != 0x00)
		eax_44 = edx_45;
	*dwArg04 = eax_44;
}

// 080567D0: void _IO_doallocbuf(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_overflow
//      _IO_new_file_underflow
//      _IO_new_file_seekoff
//      _IO_file_xsgetn
//      _IO_new_file_overflow
void _IO_doallocbuf(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 28) != 0x00)
		return;
	ui32 eax_24 = *dwArg04;
	if (((byte) eax_24 & 0x02) == 0x00 || *((word32) dwArg04 + 0x0068) > 0x00)
	{
		Eq_2 edi_36 = *((word32) dwArg04 + 0x0094);
		if (edi_36 >= 135066356)
		{
			word32 ecx_177;
			word32 edx_178;
			_IO_vtable_check(out ecx_177, out edx_178);
		}
		word32 eax_63;
		word32 edx_64;
		(*((word32) edi_36 + 52))();
		if (eax_63 != ~0x00)
			return;
		eax_24 = (ui32) *dwArg04;
		Eq_2 edx_69 = *((word32) dwArg04 + 28);
		byte al_76 = (byte) eax_24;
		if (edx_69 != 0x00 && (al_76 & 0x01) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_181;
			word32 edx_182;
			free(gs, stackArg0, edx_69, out ecx_181, out edx_182);
			eax_24 = (ui32) *dwArg04;
		}
	}
	*((word32) dwArg04 + 28) = (word32) dwArg04 + 71;
	*((word32) dwArg04 + 32) = (word32) dwArg04 + 72;
	*dwArg04 = eax_24 | 0x01;
}

// 08056890: void _IO_default_underflow()
void _IO_default_underflow()
{
}

// 080568A0: void _IO_default_uflow(Stack (ptr32 Eq_23811) dwArg04)
void _IO_default_uflow(struct Eq_23811 * dwArg04)
{
	struct Eq_23812 * esi_16 = dwArg04->ptr0094;
	if (esi_16 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 ecx_73;
		word32 edx_74;
		_IO_vtable_check(out ecx_73, out edx_74);
	}
	word32 eax_38;
	esi_16->ptr0010();
	if (eax_38 != ~0x00)
		++dwArg04->dw0004;
}

// 08056900: Register Eq_2 _IO_default_xsputn(Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _IO_file_xsputn
Eq_2 _IO_default_xsputn(Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 esp_175 = fp - 44;
	Eq_2 ecx_110 = dwArg08;
	if (dwArg0C == 0x00)
		return 0x00;
	Eq_2 ebp_117 = dwArg0C;
	while (true)
	{
		struct Eq_23976 * eax_47 = *((word32) esp_175 + 48);
		Eq_2 edi_102 = eax_47->t0014;
		Eq_2 eax_49 = eax_47->t0018;
		if (edi_102 < eax_49)
		{
			Eq_2 eax_52 = eax_49 - edi_102;
			if (ebp_117 <= eax_52)
				eax_52 = ebp_117;
			Eq_2 edx_116 = eax_52;
			if (eax_52 <= 0x14)
			{
				if (eax_52 != 0x00)
				{
					word32 eax_93 = edi_102 + eax_52;
					Eq_2 esi_101 = ecx_110;
					do
					{
						*edi_102 = *esi_101;
						esi_101 = (word32) esi_101 + 1;
						edi_102 = (word32) edi_102 + 1;
					} while (edi_102 != eax_93);
					*((word32) *((word32) esp_175 + 48) + 20) = edi_102;
					ecx_110 += eax_52;
				}
			}
			else
			{
				struct Eq_23859 * esp_62 = esp_175 - 0x04;
				esp_62->tFFFFFFFC = eax_52;
				esp_62->t0010 = eax_52;
				esp_62->tFFFFFFF8 = ecx_110;
				esp_62->t0038 = ecx_110;
				esp_62->tFFFFFFF4 = edi_102;
				word32 edx_281;
				Eq_2 eax_75 = __mempcpy(esp_62->tFFFFFFF4, esp_62->tFFFFFFF8, esp_62->tFFFFFFFC, out edx_281);
				Eq_2 ecx_84 = esp_62->t0038;
				edx_116 = esp_62->t0010;
				esp_62->ptr0034->t0014 = eax_75;
				ecx_110 = ecx_84 + edx_116;
			}
			ebp_117 -= edx_116;
		}
		Eq_2 esp_123 = esp_175;
		if (ebp_117 == 0x00)
			break;
		struct Eq_23911 * esi_129 = *((word32) *((word32) esp_175 + 48) + 0x0094);
		if (*((word32) esp_175 + 8) <= esi_129 - *((word32) esp_175 + 4))
		{
			*((word32) esp_175 + 52) = ecx_110;
			word32 edx_283;
			word32 ecx_282;
			_IO_vtable_check(out ecx_282, out edx_283);
			esp_123.u0 = <invalid>;
			ecx_110 = *((byte) esp_123.u0 + 52);
		}
		word32 eax_147 = (word32) *ecx_110;
		struct Eq_23943 * esp_149 = esp_123 - 0x08;
		esp_149->dwFFFFFFFC = eax_147;
		esp_149->dwFFFFFFF8 = esp_149->dw0038;
		word32 eax_171;
		word32 edx_173;
		esi_129->ptr000C();
		Eq_2 edi_151 = (word32) ecx_110 + 1;
		esp_175 = &esp_149->dwFFFFFFFC + 3;
		if (eax_171 == ~0x00)
		{
			esp_149->dw0040 -= ebp_117;
			return dwArg0C;
		}
		--ebp_117;
		ecx_110 = edi_151;
	}
	return dwArg0C;
}

// 08056A40: void _IO_sgetn(Stack (ptr32 Eq_24005) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void _IO_sgetn(struct Eq_24005 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_24008 * ebx_25 = dwArg04->ptr0094;
	if (ebx_25 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_83;
		word32 ecx_82;
		_IO_vtable_check(out ecx_82, out edx_83);
	}
	ebx_25->ptr0020();
}

// 08056AB0: void _IO_default_xsgetn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_default_xsgetn(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 ebx_142 = dwArg08;
	Eq_2 ecx_123 = dwArg0C;
	do
	{
		Eq_2 esi_27 = *((word32) dwArg04 + 4);
		Eq_2 ebp_28 = *((word32) dwArg04 + 8);
		if (esi_27 < ebp_28)
		{
			Eq_2 ebp_31 = ebp_28 - esi_27;
			if (ecx_123 <= ebp_31)
				ebp_31 = ecx_123;
			if (ebp_31 <= 0x14)
			{
				if (ebp_31 != 0x00)
				{
					word32 eax_75 = esi_27 + ebp_31;
					Eq_2 edi_76 = ebx_142;
					Eq_2 esi_77 = esi_27;
					do
					{
						*edi_76 = *esi_77;
						esi_77 = (word32) esi_77 + 1;
						edi_76 = (word32) edi_76 + 1;
					} while (eax_75 != esi_77);
					*((word32) dwArg04 + 4) = eax_75;
					ebx_142 += ebp_31;
				}
			}
			else
			{
				word32 edx_217;
				ebx_142 = __mempcpy(ebx_142, esi_27, ebp_31, out edx_217);
				Mem70[dwArg04 + 0x04:word32] = Mem55[dwArg04 + 0x04:word32] + ebp_31;
			}
			ecx_123 -= ebp_31;
		}
		if (ecx_123 == 0x00)
			return;
		word32 ecx_216;
	} while (__underflow(dwArg04, out ecx_216) != ~0x00);
}

// 08056B80: Register (ptr32 Eq_17486) _IO_default_setbuf(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_17486) dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
// Called from:
//      _IO_new_file_setbuf
//      _IO_file_setbuf_mmap
struct Eq_17486 * _IO_default_setbuf(struct Eq_9 * gs, struct Eq_17486 * dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	struct Eq_17524 * ebp_21 = dwArg04->ptr0094;
	if (ebp_21 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 ecx_222;
		word32 edx_223;
		_IO_vtable_check(out ecx_222, out edx_223);
	}
	struct Eq_17486 * eax_145;
	word32 eax_47;
	ebp_21->ptr0030();
	if (eax_47 != ~0x00)
	{
		ui32 eax_56 = dwArg04->dw0000;
		byte al_77 = (byte) eax_56;
		Eq_2 ecx_57 = dwArg04->t001C;
		if (dwArg08 != 0x00 && dwArg0C != 0x00)
		{
			dwArg04->dw0000 = eax_56 & ~0x02;
			ui32 edx_110 = eax_56 & ~0x02;
			ptr32 ebp_112 = (word32) dwArg08 + dwArg0C;
			if (ecx_57 != 0x00 && (al_77 & 0x01) == 0x00)
			{
				word32 ecx_224;
				word32 edx_225;
				free(gs, dwLoc30, ecx_57, out ecx_224, out edx_225);
				edx_110 = dwArg04->dw0000;
			}
			dwArg04->t001C = dwArg08;
			dwArg04->ptr0020 = ebp_112;
			dwArg04->dw0000 = edx_110 | 0x01;
		}
		else
		{
			dwArg04->dw0000 = eax_56 | 0x02;
			ui32 edx_67 = eax_56 | 0x02;
			if (ecx_57 != 0x00 && (al_77 & 0x01) == 0x00)
			{
				word32 ecx_226;
				word32 edx_227;
				free(gs, dwLoc30, ecx_57, out ecx_226, out edx_227);
				edx_67 = dwArg04->dw0000;
			}
			dwArg04->t001C = (char *) &dwArg04->ptr0020 + 39;
			dwArg04->ptr0020 = &dwArg04->ptr0020 + 0x0A;
			dwArg04->dw0000 = edx_67 | 0x01;
		}
		dwArg04->t0018.u0 = 0x00;
		dwArg04->t0014.u0 = 0x00;
		dwArg04->t0010.u0 = 0x00;
		dwArg04->t0008.u0 = 0x00;
		dwArg04->t0004.u0 = 0x00;
		dwArg04->t000C.u0 = 0x00;
		eax_145 = dwArg04;
	}
	else
		eax_145 = null;
	return eax_145;
}

// 08056CA0: void _IO_default_seekpos(Stack (ptr32 Eq_24215) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
void _IO_default_seekpos(struct Eq_24215 * dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	struct Eq_24219 * ebx_25 = dwArg04->ptr0094;
	if (ebx_25 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_97;
		word32 ecx_96;
		_IO_vtable_check(out ecx_96, out edx_97);
	}
	ebx_25->ptr0024();
}

// 08056D00: void _IO_default_doallocate(Register (ptr32 Eq_9) gs)
void _IO_default_doallocate(struct Eq_9 * gs)
{
	struct Eq_24235 * esi_27;
	word32 ebx_126;
	word32 ebp_127;
	word32 ecx_124;
	word32 edx_125;
	word32 edi_128;
	Eq_2 eax_21 = __libc_malloc(gs, dwLoc30, 0x2000, out ecx_124, out edx_125, out ebx_126, out ebp_127, out esi_27, out edi_128);
	if (eax_21 == 0x00)
		return;
	ui32 edx_47 = esi_27->dw0000;
	Eq_2 ecx_45 = esi_27->t001C;
	byte dl_51 = (byte) edx_47;
	if (ecx_45 != 0x00 && (dl_51 & 0x01) == 0x00)
	{
		word32 ecx_129;
		word32 edx_130;
		free(gs, dwLoc30, ecx_45, out ecx_129, out edx_130);
		edx_47 = esi_27->dw0000;
	}
	esi_27->t001C = eax_21;
	esi_27->dw0020 = (word32) eax_21 + 0x00002000;
	esi_27->dw0000 = edx_47 & ~0x01;
}

// 08056D80: void _IO_enable_locks()
void _IO_enable_locks()
{
	if (stdio_needs_locking == 0x00)
	{
		stdio_needs_locking = 0x01;
		Eq_2 eax_12 = _IO_list_all;
		while (eax_12 != 0x00)
		{
			*((word32) eax_12 + 60) |= 0x80;
			eax_12 = *((word32) eax_12 + 52);
		}
	}
}

// 08056DC0: void _IO_old_init(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
// Called from:
//      _IO_init_internal
//      _IO_init
//      _IO_no_init
void _IO_old_init(Eq_2 dwArg04, ui32 dwArg08)
{
	((word32) dwArg04 + 60)->u0 = 0x00;
	*dwArg04 = dwArg08 | 0xFBAD0000;
	if (stdio_needs_locking != 0x00)
		((word32) dwArg04 + 60)->u0 = 0x80;
	((word32) dwArg04 + 28)->u0 = 0x00;
	((word32) dwArg04 + 32)->u0 = 0x00;
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	((word32) dwArg04 + 4)->u0 = 0x00;
	((word32) dwArg04 + 8)->u0 = 0x00;
	((word32) dwArg04 + 16)->u0 = 0x00;
	((word32) dwArg04 + 20)->u0 = 0x00;
	((word32) dwArg04 + 24)->u0 = 0x00;
	((word32) dwArg04 + 52)->u0 = 0x00;
	((word32) dwArg04 + 36)->u0 = 0x00;
	*((word32) dwArg04 + 40) = 0x00;
	*((word32) dwArg04 + 44) = 0x00;
	((word32) dwArg04 + 48)->u0 = 0x00;
	((word32) dwArg04 + 0x0044)->u5 = 0x00;
	Eq_2 eax_34 = *((word32) dwArg04 + 72);
	if (eax_34 != 0x00)
	{
		*eax_34 = 0x00;
		((word32) eax_34 + 4)->u0 = 0x00;
		((word32) eax_34 + 8)->u0 = 0x00;
	}
}

// 08056E80: void _IO_init_internal(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
void _IO_init_internal(Eq_2 dwArg04, ui32 dwArg08)
{
	_IO_old_init(dwArg04, dwArg08);
	((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	((word32) dwArg04 + 88)->u0 = ~0x00;
	((word32) dwArg04 + 92)->u0 = 0x00;
}

// 08056EB0: void _IO_init(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
void _IO_init(Eq_2 dwArg04, ui32 dwArg08)
{
	_IO_old_init(dwArg04, dwArg08);
	((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	((word32) dwArg04 + 88)->u0 = ~0x00;
	((word32) dwArg04 + 92)->u0 = 0x00;
}

// 08056EE0: void _IO_no_init(Stack Eq_2 dwArg04, Stack ui32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack ptr32 dwArg14)
// Called from:
//      __fopen_internal
//      vasprintf
void _IO_no_init(Eq_2 dwArg04, ui32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 dwArg14)
{
	_IO_old_init(dwArg04, dwArg08);
	*((word32) dwArg04 + 0x0068) = dwArg0C;
	if (dwArg0C < 0x00)
	{
		((word32) dwArg04 + 88)->u0 = ~0x00;
		((word32) dwArg04 + 92)->u0 = 0x00;
	}
	else
	{
		*((word32) dwArg04 + 88) = dwArg10;
		((word32) dwArg10 + 24)->u0 = 0x00;
		((word32) dwArg10 + 28)->u0 = 0x00;
		((word32) dwArg10 + 8)->u0 = 0x00;
		dwArg10->u0 = 0x00;
		((word32) dwArg10 + 4)->u0 = 0x00;
		((word32) dwArg10 + 0x0C)->u0 = 0x00;
		((word32) dwArg10 + 16)->u0 = 0x00;
		((word32) dwArg10 + 20)->u0 = 0x00;
		((word32) dwArg10 + 32)->u0 = 0x00;
		((word32) dwArg10 + 36)->u0 = 0x00;
		*((word32) dwArg10 + 40) = 0x00;
		*((word32) dwArg10 + 0x00B0) = dwArg14;
		((word32) dwArg04 + 92)->u0 = 0x00;
	}
}

// 08056F90: void _IO_default_sync()
void _IO_default_sync()
{
}

// 08056FA0: void _IO_default_finish(Stack Eq_2 dwArg04)
// Called from:
//      _IO_new_file_finish
//      _IO_str_finish
void _IO_default_finish(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 28) != 0x00 && (*dwArg04 & 0x01) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_124;
		word32 edx_125;
		free(gs, stackArg0, stackArg4, out ecx_124, out edx_125);
		((word32) dwArg04 + 32)->u0 = 0x00;
		((word32) dwArg04 + 28)->u0 = 0x00;
	}
	Eq_2 edx_31 = *((word32) dwArg04 + 48);
	while (edx_31 != 0x00)
	{
		((word32) edx_31 + 4)->u0 = 0x00;
		edx_31 = *edx_31;
	}
	if (*((word32) dwArg04 + 36) != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 edx_120;
		word32 ecx_119;
		free(gs, stackArg0, stackArg4, out ecx_119, out edx_120);
		((word32) dwArg04 + 36)->u0 = 0x00;
	}
	if ((*dwArg04 & 0x80) == 0x00)
		return;
	_IO_un_link.part.2(eax, gs);
}

// 08057040: void _IO_default_seekoff()
void _IO_default_seekoff()
{
}

// 08057050: void _IO_sputbackc(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      _IO_getline_info
void _IO_sputbackc(Eq_2 dwArg04, word32 dwArg08)
{
	byte al_20 = (byte) dwArg08;
	Eq_2 edx_17 = *((word32) dwArg04 + 4);
	if (edx_17 > *((word32) dwArg04 + 0x0C) && *((word32) edx_17 - 1) == al_20)
		*((word32) dwArg04 + 4) = edx_17 - 0x01;
	else
	{
		Eq_2 esi_29 = *((word32) dwArg04 + 0x0094);
		if (esi_29 >= 135066356)
		{
			word32 ecx_122;
			word32 edx_123;
			_IO_vtable_check(out ecx_122, out edx_123);
		}
		word32 eax_59;
		(*((word32) esi_29 + 24))();
		if (eax_59 == ~0x00)
			return;
	}
	*dwArg04 &= ~0x10;
}

// 080570D0: void _IO_sungetc(Stack (ptr32 Eq_24630) dwArg04)
void _IO_sungetc(struct Eq_24630 * dwArg04)
{
	up32 eax_14 = dwArg04->dw0004;
	if (eax_14 > dwArg04->dw000C)
		dwArg04->dw0004 = eax_14 - 0x01;
	else
	{
		struct Eq_24639 * esi_17 = dwArg04->ptr0094;
		if (esi_17 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 edx_105;
			word32 ecx_104;
			_IO_vtable_check(out ecx_104, out edx_105);
		}
		word32 eax_43;
		word32 ecx_44;
		esi_17->ptr0018();
		if (eax_43 == ~0x00)
			return;
	}
	dwArg04->dw0000 &= ~0x10;
}

// 08057150: Register word16 _IO_adjust_column(Stack word32 dwArg04, Stack (ptr32 Eq_17574) dwArg08, Stack (ptr32 Eq_17572) dwArg0C)
// Called from:
//      new_do_write
word16 _IO_adjust_column(word32 dwArg04, struct Eq_17574 * dwArg08, struct Eq_17572 * dwArg0C)
{
	word32 eax_9 = dwArg08 + dwArg0C;
	if (dwArg08 >= eax_9)
		return (word16) (dwArg0C + dwArg04 / 0x0098);
	struct Eq_17574 * edx_13 = eax_9 - 0x01;
	if (eax_9->bFFFFFFFF == 0x0A)
		return 0x00;
	do
	{
		if (dwArg08 == edx_13)
			return (word16) (dwArg0C + dwArg04 / 0x0098);
		--edx_13;
	} while (edx_13->b0000 != 0x0A);
	return (word16) (eax_9 - edx_13) - 0x01;
}

// 080571A0: Register Eq_2 _IO_flush_all_lockp(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      fflush
//      _IO_cleanup
Eq_2 _IO_flush_all_lockp(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2175 eax_20 = gs->t0014;
	Mem49 = Mem31;
	Eq_2 ecx_155 = ecx;
	Eq_2 edx_50 = gs->t0008;
	if (g_t80CF840 != edx_50)
	{
		ecx_155.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_62;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_62))
			ecx_155 = __lll_lock_wait_private(eax_62, 0x080CF838, gs);
		g_t80CF840 = edx_50;
	}
	Eq_2 eax_272 = g_t80CF83C;
	Eq_2 esi_100 = _IO_list_all;
	g_t80CF83C = (word32) eax_272 + 1;
	Eq_2 edx_151 = (word32) eax_272 + 1;
	if (esi_100 != 0x00)
	{
		Eq_2 eax_88 = gs->t0008;
		ecx_155.u0 = 0x080CEFA0;
		do
		{
			run_fp = esi_100;
			if (dwArg04 != 0x00)
			{
				ui32 eax_107 = *esi_100;
				if ((eax_107 & 0x8000) == 0x00)
				{
					Eq_2 edx_112 = *((word32) esi_100 + 72);
					if (*((word32) edx_112 + 8) != eax_88)
					{
						if (gs->t000C != 0x00)
							__lock();
						word32 eax_125;
						if (!__cmpxchg(*edx_112, 0x01, eax_107 & 0x8000, out eax_125))
							__lll_lock_wait_private(eax_125, edx_112, gs);
						edx_112 = *((word32) esi_100 + 72);
						*((word32) edx_112 + 8) = eax_88;
					}
					*((word32) edx_112 + 4) = (word32) *((word32) edx_112 + 4) + 1;
					ecx_155 = eax_88;
				}
			}
			Eq_2 ecx_219;
			edx_151 = *((word32) esi_100 + 0x0068);
			if (edx_151 <= 0x00)
			{
				if (*((word32) esi_100 + 20) <= *((word32) esi_100 + 16))
					goto l080572A8;
				goto l0805727B;
			}
			Eq_2 eax_154 = *((word32) esi_100 + 88);
			ecx_155 = *((word32) eax_154 + 0x0C);
			if (*((word32) eax_154 + 16) > ecx_155)
			{
l0805727B:
				Eq_2 eax_163 = *((word32) esi_100 + 0x0094);
				if (eax_163 >= 135066356)
				{
					word32 ecx_609;
					word32 edx_610;
					_IO_vtable_check(out ecx_609, out edx_610);
				}
				word32 eax_217;
				(*((word32) eax_163 + 0x0C))();
				ecx_155 = ecx_219;
				if (eax_217 == ~0x00)
					ecx_155 = ecx_219;
			}
l080572A8:
			if (dwArg04 != 0x00 && (*esi_100 & 0x8000) == 0x00)
			{
				edx_151 = *((word32) esi_100 + 72);
				Eq_2 v16_236 = *((word32) edx_151 + 4) - 0x01;
				*((word32) edx_151 + 4) = v16_236;
				if (v16_236 == 0x00)
				{
					((word32) edx_151 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v17_246 = *edx_151 - 0x01;
					*edx_151 = v17_246;
					if (v17_246 != 0x00)
						__lll_unlock_wake_private(edx_151, ecx_155, edx_151, gs);
				}
			}
			run_fp.u0 = 0x00;
			esi_100 = *((word32) esi_100 + 52);
		} while (esi_100 != 0x00);
		eax_272 = g_t80CF83C - 0x01;
	}
	g_t80CF83C = eax_272;
	if (eax_272 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v18_288 = g_t80CF838 - 0x01;
		g_t80CF838 = v18_288;
		if (v18_288 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_155, edx_151, gs);
	}
	if ((eax_20 ^ gs->t0014) == 0x00)
		return ecx_155;
	word32 ecx_611;
	word32 edx_612;
	__stack_chk_fail(out ecx_611, out edx_612);
	return _IO_cleanup(gs);
}

// 08057410: Register Eq_2 _IO_cleanup(Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_flush_all_lockp
Eq_2 _IO_cleanup(struct Eq_9 * gs)
{
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 ecx_29 = _IO_flush_all_lockp(ecx, gs, 0x00);
	Mem57 = Mem39;
	Eq_2 ecx_278 = ecx_29;
	Eq_2 edx_58 = gs->t0008;
	if (edx_58 != g_t80CF840)
	{
		ecx_278.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_70;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_70))
			ecx_278 = __lll_lock_wait_private(eax_70, 0x080CF838, gs);
		g_t80CF840 = edx_58;
	}
	Eq_2 eax_346 = g_t80CF83C;
	Eq_2 esi_107 = _IO_list_all;
	g_t80CF83C = (word32) eax_346 + 1;
	Eq_2 edx_114 = (word32) eax_346 + 1;
	if (esi_107 != 0x00)
	{
		ecx_278.u0 = 0x080CEFA0;
		Eq_2 eax_105 = gs->t0008;
		do
		{
			ui32 ebp_109 = *esi_107;
			ui32 ebp_110 = ebp_109 & 0x02;
			if ((ebp_109 & 0x02) == 0x00)
			{
				edx_114 = *((word32) esi_107 + 0x0068);
				if (edx_114 == 0x00)
					goto l080574E8;
				Eq_2 edx_118 = *((word32) esi_107 + 72);
				if (edx_118 != 0x00)
				{
					if (*((word32) edx_118 + 8) != eax_105)
					{
						if (gs->t000C != 0x00)
							__lock();
						ui32 eax_135;
						__cmpxchg(*edx_118, 0x01, ebp_109 & 0x02, out eax_135);
						ebp_110 = eax_135;
						if (eax_135 != 0x00)
						{
							sched_yield(gs);
							edx_118 = *((word32) esi_107 + 72);
							ebp_110 = 0x01;
							if (edx_118 == 0x00)
								goto l08057583;
							if (eax_105 != *((word32) edx_118 + 8))
							{
								if (gs->t000C != 0x00)
									__lock();
								word32 eax_173;
								__cmpxchg(*edx_118, 0x01, 0x00, out eax_173);
								if (eax_173 != 0x00)
								{
									sched_yield(gs);
									ebp_110 = 0x02;
									goto l08057583;
								}
								ebp_110 = 0x01;
								goto l08057705;
							}
							ebp_110 = 0x01;
							goto l080576ED;
						}
l08057705:
						Eq_2 eax_182 = *((word32) esi_107 + 72);
						((word32) eax_182 + 4)->u0 = 0x01;
						*((word32) eax_182 + 8) = eax_105;
					}
					else
					{
l080576ED:
						*((word32) edx_118 + 4) = (word32) *((word32) edx_118 + 4) + 1;
					}
				}
l08057583:
				if (g_b80CF82C == 0x00)
				{
					ui32 eax_207 = *esi_107;
					if (((byte) eax_207 & 0x01) == 0x00)
					{
						*esi_107 = eax_207 | 0x01;
						Eq_2 eax_216 = freeres_list;
						freeres_list = esi_107;
						*((word32) esi_107 + 92) = eax_216;
						*((word32) esi_107 + 96) = *((word32) esi_107 + 28);
					}
				}
				Eq_2 eax_223 = *((word32) esi_107 + 0x0094);
				if (eax_223 >= 135066356)
				{
					word32 edx_695;
					word32 ecx_694;
					_IO_vtable_check(out ecx_694, out edx_695);
				}
				(*((word32) eax_223 + 44))();
				Eq_2 eax_280 = *((word32) esi_107 + 0x0068);
				if (eax_280 > 0x00)
					ecx_278 = _IO_wsetb(esi_107, 0x00, 0x00, 0x00, out edx_114);
				if (ebp_110 != 0x02)
				{
					edx_114 = *((word32) esi_107 + 72);
					if (edx_114 != 0x00)
					{
						Eq_2 v19_307 = *((word32) edx_114 + 4) - 0x01;
						*((word32) edx_114 + 4) = v19_307;
						if (v19_307 == 0x00)
						{
							((word32) edx_114 + 8)->u0 = 0x00;
							if (gs->t000C != 0x00)
								__lock();
							Eq_2 v20_323 = *edx_114 - 0x01;
							*edx_114 = v20_323;
							if (v20_323 != 0x00)
								__lll_unlock_wake_private(edx_114, ecx_278, edx_114, gs);
							((word32) esi_107 + 0x0068)->u0 = ~0x00;
							esi_107 = *((word32) esi_107 + 52);
							if (esi_107 == 0x00)
								break;
							continue;
						}
					}
				}
			}
l080574E8:
			((word32) esi_107 + 0x0068)->u0 = ~0x00;
			esi_107 = *((word32) esi_107 + 52);
		} while (esi_107 != 0x00);
		eax_346 = g_t80CF83C - 0x01;
	}
	g_t80CF83C = eax_346;
	if (eax_346 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_363 = g_t80CF838 - 0x01;
		g_t80CF838 = v15_363;
		if (v15_363 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_278, edx_114, gs);
	}
	if ((eax_20 ^ gs->t0014) == 0x00)
		return ecx_278;
	Eq_2 ecx_467;
	word32 edx_693;
	__stack_chk_fail(out ecx_467, out edx_693);
	_IO_flush_all();
	return ecx_467;
}

// 08057720: void _IO_flush_all()
// Called from:
//      fflush
//      _IO_cleanup
void _IO_flush_all()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	_IO_flush_all_lockp(ecx, gs, stackArg4);
}

// 08057740: void _flushlbf(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _flushlbf(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2175 eax_20 = gs->t0014;
	Mem48 = Mem30;
	Eq_2 ecx_110 = ecx;
	Eq_2 esp_158 = fp - 0x4C;
	Eq_2 edx_49 = gs->t0008;
	if (g_t80CF840 != edx_49)
	{
		ecx_110.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_61;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_61))
			ecx_110 = __lll_lock_wait_private(eax_61, 0x080CF838, gs);
		g_t80CF840 = edx_49;
	}
	Eq_2 eax_246 = g_t80CF83C;
	Eq_2 esi_241 = _IO_list_all;
	g_t80CF83C = (word32) eax_246 + 1;
	Eq_2 edx_106 = (word32) eax_246 + 1;
	if (esi_241 != 0x00)
	{
		Eq_2 ebp_88 = gs->t0008;
		do
		{
			Eq_2 ecx_203;
			ui32 edx_98 = *esi_241;
			run_fp = esi_241;
			if ((edx_98 & 0x8000) != 0x00)
			{
				edx_106 = edx_98 & 0x0208;
				if ((edx_98 & 0x0208) == 0x0200)
					goto l0805789F;
			}
			else
			{
				edx_106 = *((word32) esi_241 + 72);
				if (*((word32) edx_106 + 8) != ebp_88)
				{
					ecx_110.u0 = 0x01;
					if (gs->t000C != 0x00)
						__lock();
					word32 eax_118;
					if (!__cmpxchg(*edx_106, 0x01, edx_98 & 0x8000, out eax_118))
						ecx_110 = __lll_lock_wait_private(eax_118, edx_106, gs);
					edx_106 = *((word32) esi_241 + 72);
					*((word32) edx_106 + 8) = ebp_88;
				}
				ui32 eax_137 = *esi_241;
				*((word32) edx_106 + 4) = (word32) *((word32) edx_106 + 4) + 1;
				if ((eax_137 & 0x0208) == 0x0200)
				{
l0805789F:
					Eq_2 eax_149 = *((word32) esi_241 + 0x0094);
					if (*((word32) esp_158 + 4) <= eax_149 - 0x080CEFA0)
					{
						*((word32) esp_158 + 0x0C) = eax_149;
						word32 ecx_548;
						word32 edx_549;
						_IO_vtable_check(out ecx_548, out edx_549);
						esp_158.u0 = <invalid>;
						eax_149 = *((byte) esp_158.u0 + 0x0C);
					}
					struct Eq_25374 * esp_174 = esp_158 - 0x08;
					esp_174->dwFFFFFFFC = ~0x00;
					esp_174->tFFFFFFF8 = esi_241;
					(*((word32) eax_149 + 0x0C))();
					esp_158 = &esp_174->dwFFFFFFFC + 3;
					ecx_110 = ecx_203;
				}
				if ((*esi_241 & 0x8000) == 0x00)
				{
					edx_106 = *((word32) esi_241 + 72);
					Eq_2 v16_213 = *((word32) edx_106 + 4) - 0x01;
					*((word32) edx_106 + 4) = v16_213;
					if (v16_213 == 0x00)
					{
						((word32) edx_106 + 8)->u0 = 0x00;
						if (gs->t000C != 0x00)
							__lock();
						Eq_2 v17_223 = *edx_106 - 0x01;
						*edx_106 = v17_223;
						if (v17_223 != 0x00)
							__lll_unlock_wake_private(edx_106, ecx_110, edx_106, gs);
					}
				}
			}
			run_fp.u0 = 0x00;
			esi_241 = *((word32) esi_241 + 52);
		} while (esi_241 != 0x00);
		eax_246 = g_t80CF83C - 0x01;
	}
	g_t80CF83C = eax_246;
	if (eax_246 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v19_261 = g_t80CF838 - 0x01;
		g_t80CF838 = v19_261;
		if (v19_261 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_110, edx_106, gs);
	}
	if ((eax_20 ^ gs->t0014) == 0x00)
		return;
	word32 edx_551;
	word32 ecx_550;
	__stack_chk_fail(out ecx_550, out edx_551);
	_IO_init_marker(dwArg04, dwArg08);
}

// 08057970: void _IO_init_marker(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _flushlbf
void _IO_init_marker(Eq_2 dwArg04, Eq_2 dwArg08)
{
	byte dh_15 = *((word32) dwArg08 + 1);
	*((word32) dwArg04 + 4) = dwArg08;
	if ((dh_15 & 0x08) != 0x00)
	{
		word32 ecx_89;
		_IO_switch_to_get_mode(dwArg08, out ecx_89);
		dh_15 = (byte) *((word32) dwArg08 + 1);
	}
	Eq_2 eax_43;
	Eq_2 eax_36 = *((word32) dwArg08 + 4);
	if ((dh_15 & 0x01) != 0x00)
		eax_43 = eax_36 - *((word32) dwArg08 + 8);
	else
		eax_43 = eax_36 - *((word32) dwArg08 + 0x0C);
	*((word32) dwArg04 + 8) = eax_43;
	*dwArg04 = *((word32) dwArg08 + 48);
	*((word32) dwArg08 + 48) = dwArg04;
}

// 080579D0: void _IO_remove_marker(Stack (ptr32 Eq_25561) dwArg04)
void _IO_remove_marker(struct Eq_25561 * dwArg04)
{
	struct Eq_25562 * eax_6 = dwArg04->ptr0004;
	struct Eq_25561 * edx_13 = eax_6->ptr0030;
	if (edx_13 == null)
		return;
	if (dwArg04 != edx_13)
	{
		while (true)
		{
			struct Eq_25561 * eax_15 = edx_13->dw0000;
			if (eax_15 == null)
				break;
			if (dwArg04 == eax_15)
				goto l08057A00;
			edx_13 = eax_15;
		}
	}
	else
	{
		edx_13 = (struct Eq_25561 *) &eax_6->ptr0030;
l08057A00:
		edx_13->dw0000 = dwArg04->dw0000;
	}
}

// 08057A10: void _IO_marker_difference()
void _IO_marker_difference()
{
}

// 08057A30: void _IO_marker_delta(Stack (ptr32 Eq_25588) dwArg04)
void _IO_marker_delta(struct Eq_25588 * dwArg04)
{
	ui32 * eax_6 = dwArg04->ptr0004;
	if (eax_6 == null)
		return;
	if ((*eax_6 & 0x0100) != 0x00)
		;
}

// 08057A70: void _IO_seekmark(Stack (ptr32 Eq_25602) dwArg04, Stack (ptr32 Eq_25603) dwArg08)
void _IO_seekmark(struct Eq_25602 * dwArg04, struct Eq_25603 * dwArg08)
{
	if (dwArg08->ptr0004 == dwArg04)
	{
		word32 ebx_22;
		ui32 edx_16 = dwArg04->dw0000;
		int32 ecx_15 = dwArg08->dw0008;
		byte dh_26 = SLICE(edx_16, byte, 8);
		byte dl_31 = (byte) edx_16;
		word16 edx_16_16_32 = SLICE(edx_16, word16, 16);
		if (ecx_15 >= 0x00)
		{
			ebx_22 = dwArg04->dw000C;
			if ((edx_16 & 0x0100) != 0x00)
			{
				word32 esi_49 = dwArg04->dw002C;
				dwArg04->dw0000 = SEQ(edx_16_16_32, dh_26 & ~0x01, dl_31);
				word32 edx_52 = dwArg04->dw0008;
				dwArg04->dw0008 = esi_49;
				dwArg04->dw002C = edx_52;
				word32 edx_55 = dwArg04->dw0024;
				dwArg04->dw0024 = ebx_22;
				dwArg04->dw000C = edx_55;
				ebx_22 = edx_55;
			}
		}
		else
		{
			ebx_22 = dwArg04->dw0008;
			if ((edx_16 & 0x0100) == 0x00)
			{
				word32 esi_30 = dwArg04->dw0024;
				dwArg04->dw0000 = SEQ(edx_16_16_32, dh_26 | 0x01, dl_31);
				word32 edx_35 = dwArg04->dw002C;
				dwArg04->dw002C = ebx_22;
				word32 ebx_37 = dwArg04->dw000C;
				dwArg04->dw0008 = edx_35;
				dwArg04->dw0024 = ebx_37;
				dwArg04->dw000C = esi_30;
				ebx_22 = edx_35;
			}
		}
		dwArg04->dw0004 = ecx_15 + ebx_22;
	}
}

// 08057B00: void _IO_unsave_markers(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
//      _IO_new_file_seekoff
//      _IO_file_close_it
void _IO_unsave_markers(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 48) != 0x00)
		((word32) dwArg04 + 48)->u0 = 0x00;
	if (*((word32) dwArg04 + 36) == 0x00)
		return;
	_IO_free_backup_area(dwArg04);
}

// 08057B40: void _IO_default_pbackfail(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      _IO_str_pbackfail
void _IO_default_pbackfail(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	byte bArg08_228 = (byte) dwArg08;
	Eq_2 ecx_134;
	Eq_2 eax_118;
	ui32 edx_20 = *dwArg04;
	Eq_2 esi_124 = dwArg04;
	byte dh_157 = SLICE(edx_20, byte, 8);
	byte dl_167 = (byte) edx_20;
	word16 edx_16_16_171 = SLICE(edx_20, word16, 16);
	Eq_2 edi_137 = *((word32) dwArg04 + 4);
	Eq_2 ebp_22 = *((word32) dwArg04 + 0x0C);
	if (edi_137 > ebp_22)
	{
		if ((edx_20 & 0x0100) != 0x00)
			goto l08057B75;
		if ((word32) *((word32) edi_137 - 1) == dwArg08)
		{
			*((word32) dwArg04 + 4) = edi_137 - 0x01;
			return;
		}
		if (*((word32) dwArg04 + 36) != 0x00)
		{
			word32 ecx_283;
			if (save_for_backup(dwArg04, edi_137, out ecx_283) != 0x00)
				return;
			ui32 edx_154 = *dwArg04;
			ecx_134 = *((word32) dwArg04 + 4);
			dh_157 = SLICE(edx_154, byte, 8);
			dl_167 = (byte) edx_154;
			edx_16_16_171 = SLICE(edx_154, word16, 16);
			edi_137 = *((word32) dwArg04 + 44);
			eax_118 = *((word32) dwArg04 + 36);
			goto l08057C3C;
		}
	}
	else
	{
		if ((edx_20 & 0x0100) != 0x00)
		{
			Eq_2 edx_38 = *((word32) dwArg04 + 8) - ebp_22;
			Eq_2 ebp_47;
			word32 edi_50;
			word32 ecx_288;
			word32 edx_289;
			word32 ebx_290;
			Eq_2 eax_46 = __libc_malloc(gs, dwLoc40, edx_38 * 0x02, out ecx_288, out edx_289, out ebx_290, out ebp_47, out esi_124, out edi_50);
			if (eax_46 == 0x00)
				return;
			edi_137 = (word32) eax_46 + (edi_50 - edx_38);
			word32 ecx_291;
			word32 edx_292;
			memcpy(edi_137, ebp_47, edx_38, out ecx_291, out edx_292);
			word32 ecx_293;
			word32 edx_294;
			free(gs, dwLoc40, ebp_47, out ecx_293, out edx_294);
			*((word32) esi_124 + 40) = edi_137;
			*((word32) esi_124 + 0x0C) = eax_46;
			*((word32) esi_124 + 8) = (word32) eax_46 + edi_50;
l08057B75:
			*((word32) esi_124 + 4) = edi_137 - 0x01;
			*((word32) edi_137 - 1) = bArg08_228;
			return;
		}
		eax_118 = *((word32) dwArg04 + 36);
		if (eax_118 != 0x00)
		{
			ecx_134 = edi_137;
			edi_137 = *((word32) dwArg04 + 44);
			goto l08057C3C;
		}
	}
	Eq_2 edi_122;
	word32 ebx_286;
	word32 edx_285;
	word32 ecx_284;
	word32 ebp_287;
	eax_118 = __libc_malloc(gs, dwLoc40, 0x80, out ecx_284, out edx_285, out ebx_286, out ebp_287, out esi_124, out edi_122);
	if (eax_118 == 0x00)
		return;
	*((word32) esi_124 + 40) = (word32) eax_118 + 0x0080;
	ecx_134 = edi_122;
	dh_157 = SLICE(edx_20, byte, 8);
	dl_167 = (byte) edx_20;
	edx_16_16_171 = SLICE(edx_20, word16, 16);
	edi_137 = (word32) eax_118 + 0x0080;
l08057C3C:
	*((word32) esi_124 + 0x0C) = eax_118;
	*esi_124 = SEQ(edx_16_16_171, dh_157 | 0x01, dl_167);
	Eq_2 edx_177 = *((word32) esi_124 + 8);
	*((word32) esi_124 + 36) = ecx_134;
	*((word32) esi_124 + 8) = edi_137;
	*((word32) esi_124 + 44) = edx_177;
	goto l08057B75;
}

// 08057CA0: void _IO_default_seek()
void _IO_default_seek()
{
}

// 08057CB0: void _IO_default_stat()
void _IO_default_stat()
{
}

// 08057CC0: void _IO_default_read()
void _IO_default_read()
{
}

// 08057CD0: void _IO_default_write()
void _IO_default_write()
{
}

// 08057CE0: void _IO_default_showmanyc()
void _IO_default_showmanyc()
{
}

// 08057CF0: void _IO_default_imbue()
void _IO_default_imbue()
{
}

// 08057D00: void _IO_iter_begin()
void _IO_iter_begin()
{
}

// 08057D20: void _IO_iter_end()
void _IO_iter_end()
{
}

// 08057D30: void _IO_iter_next()
void _IO_iter_next()
{
}

// 08057D40: void _IO_iter_file()
void _IO_iter_file()
{
}

// 08057D50: void _IO_list_lock(Register (ptr32 Eq_9) gs)
void _IO_list_lock(struct Eq_9 * gs)
{
	Eq_2 ebx_10 = gs->t0008;
	if (g_t80CF840 != ebx_10)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_21;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_21))
			__lll_lock_wait_private(eax_21, 0x080CF838, gs);
		g_t80CF840 = ebx_10;
	}
	g_t80CF83C = (word32) g_t80CF83C + 1;
}

// 08057DB0: void _IO_list_unlock(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
void _IO_list_unlock(Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_2 v5_7 = g_t80CF83C - 0x01;
	g_t80CF83C = v5_7;
	if (v5_7 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v8_17 = g_t80CF838 - 0x01;
		g_t80CF838 = v8_17;
		if (v8_17 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx, 0x080CE000, gs);
	}
}

// 08057E00: void _IO_list_resetlock()
void _IO_list_resetlock()
{
	g_t80CF838.u0 = 0x00;
	g_t80CF83C.u0 = 0x00;
	g_t80CF840.u0 = 0x00;
}

// 08057E2D: void __x86.get_pc_thunk.cx()
void __x86.get_pc_thunk.cx()
{
}

// 08057E40: void _IO_str_underflow(Stack (ptr32 Eq_25974) dwArg04)
void _IO_str_underflow(struct Eq_25974 * dwArg04)
{
	up32 edx_11 = dwArg04->dw0014;
	up32 ecx_12 = dwArg04->dw0008;
	if (edx_11 > ecx_12)
	{
		dwArg04->dw0008 = edx_11;
		ecx_12 = edx_11;
	}
	ui32 ebx_19 = dwArg04->dw0000;
	byte bh_24 = SLICE(ebx_19, byte, 8);
	byte bl_30 = (byte) ebx_19;
	word16 ebx_16_16_31 = SLICE(ebx_19, word16, 16);
	if ((ebx_19 & 0x0C00) != 0x0C00)
		edx_11 = dwArg04->dw0004;
	else
	{
		dwArg04->dw0004 = edx_11;
		dwArg04->dw0000 = SEQ(ebx_16_16_31, bh_24 & ~0x08, bl_30);
		dwArg04->dw0014 = dwArg04->dw0018;
	}
}

// 08057EA0: void _IO_str_overflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _IO_str_overflow(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	byte bArg08_279 = (byte) dwArg08;
	ui32 eax_20 = *dwArg04;
	Eq_2 esi_19 = dwArg04;
	byte al_21 = (byte) eax_20;
	byte ah_47 = SLICE(eax_20, byte, 8);
	word16 eax_16_16_52 = SLICE(eax_20, word16, 16);
	if ((al_21 & 0x08) != 0x00)
		return;
	Eq_2 ebp_202;
	if ((eax_20 & 0x0C00) != 0x0400)
		ebp_202 = *((word32) dwArg04 + 20);
	else
	{
		ebp_202 = *((word32) dwArg04 + 4);
		*dwArg04 = SEQ(eax_16_16_52, ah_47 | 0x08, al_21);
		Eq_2 eax_55 = *((word32) dwArg04 + 8);
		*((word32) dwArg04 + 20) = ebp_202;
		*((word32) dwArg04 + 4) = eax_55;
	}
	Eq_2 ecx_61 = *((word32) dwArg04 + 28);
	Eq_2 edi_66 = *((word32) dwArg04 + 32) - ecx_61;
	if ((word32) edi_66 + (uint32) ((int8) (dwArg08 == ~0x00)) <= ebp_202 - *((word32) dwArg04 + 16))
	{
		if ((*dwArg04 & 0x01) != 0x00)
			return;
		Eq_2 ebp_80 = (word32) edi_66 + ((word32) edi_66 + 100);
		if (edi_66 > ebp_80)
			return;
		word32 ebp_91;
		Eq_2 edi_94;
		word32 edx_351;
		word32 ebx_352;
		word32 ecx_350;
		Eq_2 eax_90 = __libc_malloc(gs, dwLoc40, ebp_80, out ecx_350, out edx_351, out ebx_352, out ebp_91, out esi_19, out edi_94);
		if (eax_90 == 0x00)
			return;
		if (ecx_61 != 0x00)
		{
			word32 ecx_355;
			word32 edx_356;
			memcpy(eax_90, ecx_61, edi_94, out ecx_355, out edx_356);
			word32 ecx_357;
			word32 edx_358;
			free(gs, dwLoc40, ecx_61, out ecx_357, out edx_358);
			((word32) esi_19 + 28)->u0 = 0x00;
		}
		word32 ecx_353;
		word32 edx_354;
		memset(edi_94 + eax_90, 0x00, ebp_91 - edi_94, out ecx_353, out edx_354);
		_IO_setb(esi_19, eax_90, (word32) eax_90 + ebp_91, 0x01);
		Eq_2 eax_197 = (word32) eax_90 + (*((word32) esi_19 + 0x0C) - ecx_61);
		word32 ebp_198 = *((word32) esi_19 + 20) - ecx_61;
		*((word32) esi_19 + 16) = eax_90;
		*((word32) esi_19 + 0x0C) = eax_197;
		Eq_2 eax_201 = *((word32) esi_19 + 4);
		ebp_202 = (word32) eax_90 + ebp_198;
		*((word32) esi_19 + 20) = ebp_202;
		*((word32) esi_19 + 4) = (word32) eax_90 + (eax_201 - ecx_61);
		*((word32) esi_19 + 8) = (word32) eax_90 + (*((word32) esi_19 + 8) - ecx_61);
		*((word32) esi_19 + 24) = *((word32) esi_19 + 32);
	}
	if (dwArg08 != ~0x00)
	{
		*((word32) esi_19 + 20) = (word32) ebp_202 + 1;
		*ebp_202 = bArg08_279;
		ebp_202 = *((word32) esi_19 + 20);
	}
	if (*((word32) esi_19 + 8) < ebp_202)
		*((word32) esi_19 + 8) = ebp_202;
}

// 08058040: Register (ptr32 Eq_26216) enlarge_userbuf(Register (ptr32 Eq_26216) eax, Register int32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_26216) dwArg04)
// Called from:
//      _IO_str_seekoff
struct Eq_26216 * enlarge_userbuf(struct Eq_26216 * eax, int32 ecx, Eq_2 edx, struct Eq_9 * gs, struct Eq_26216 * dwArg04)
{
	Eq_2 edx_22 = eax->t001C;
	if (eax->dw0020 - edx_22 >= edx)
		return null;
	if ((eax->dw0000 & 0x01) != 0x00)
		return (struct Eq_26216 *) 0x01;
	word32 eax_52 = eax->dw0018;
	Eq_26242 eax_55 = eax->t0010;
	Eq_2 ebp_63;
	struct Eq_26216 * edi_66;
	Eq_2 esi_68;
	word32 edx_412;
	word32 ecx_411;
	word32 ebx_413;
	Eq_2 eax_62 = __libc_malloc(gs, dwLoc50, (word32) edx + 100, out ecx_411, out edx_412, out ebx_413, out ebp_63, out esi_68, out edi_66);
	if (eax_62 == 0x00)
		return (struct Eq_26216 *) 0x01;
	if (edx_22 != 0x00)
	{
		word32 ecx_414;
		word32 edx_415;
		memcpy(eax_62, edx_22, ebp_63, out ecx_414, out edx_415);
		word32 ecx_416;
		word32 edx_417;
		free(gs, dwLoc50, edx_22, out ecx_416, out edx_417);
		((word32) esi_68 + 28)->u0 = 0x00;
	}
	_IO_setb(esi_68, eax_62, (word32) eax_62 + ((word32) edx + 100), 0x01);
	Eq_2 ebp_119 = eax_52 - eax_55;
	if (dwArg04 != null)
	{
		Eq_2 eax_210 = *((word32) esi_68 + 16);
		*((word32) esi_68 + 0x0C) = eax_62;
		*((word32) esi_68 + 16) = (word32) eax_62 + (eax_210 - edx_22);
		*((word32) esi_68 + 20) = (word32) eax_62 + (*((word32) esi_68 + 20) - edx_22);
		*((word32) esi_68 + 24) = (word32) eax_62 + (*((word32) esi_68 + 24) - edx_22);
		*((word32) esi_68 + 4) = (word32) eax_62 + (*((word32) esi_68 + 4) - edx_22);
		*((word32) esi_68 + 8) = *((word32) esi_68 + 32);
		if (ecx - (ebp_119 >> 0x1F) - (word32) (edx < ebp_119) >= 0x00)
		{
			word32 ecx_420;
			word32 edx_421;
			memset(eax_62 + ebp_119, 0x00, edx - ebp_119, out ecx_420, out edx_421);
			return edi_66;
		}
	}
	else
	{
		Eq_2 eax_153 = *((word32) esi_68 + 0x0C);
		*((word32) esi_68 + 16) = eax_62;
		*((word32) esi_68 + 0x0C) = (word32) eax_62 + (eax_153 - edx_22);
		*((word32) esi_68 + 4) = (word32) eax_62 + (*((word32) esi_68 + 4) - edx_22);
		*((word32) esi_68 + 8) = (word32) eax_62 + (*((word32) esi_68 + 8) - edx_22);
		*((word32) esi_68 + 20) = (word32) eax_62 + (*((word32) esi_68 + 20) - edx_22);
		*((word32) esi_68 + 24) = *((word32) esi_68 + 32);
		if (ecx - (ebp_119 >> 0x1F) - (word32) (edx < ebp_119) >= 0x00)
		{
			word32 ecx_422;
			word32 edx_423;
			memset(eax_62 + ebp_119, 0x00, edx - ebp_119, out ecx_422, out edx_423);
			return null;
		}
	}
	word32 ecx_418;
	word32 edx_419;
	__assert_fail(out ecx_418, out edx_419);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	Eq_2 stackArg20 = <invalid>;
	return _IO_str_seekoff(gs, dwArg04, stackArg8, stackArg12, stackArg16, stackArg20);
}

// 08058240: Register Eq_2 _IO_str_seekoff(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_26216) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      enlarge_userbuf
Eq_2 _IO_str_seekoff(struct Eq_9 * gs, struct Eq_26216 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
	Eq_2 dwArg14_435;
	Eq_2 dwLoc2C_430;
	Eq_26242 dwLoc24_429;
	Eq_2 esi_111;
	Eq_2 eax_118;
	ui32 ecx_24 = dwArg04->dw0000;
	byte ch_33 = SLICE(ecx_24, byte, 8);
	byte cl_82 = (byte) ecx_24;
	word16 ecx_16_16_87 = SLICE(ecx_24, word16, 16);
	Eq_26242 edx_110 = dwArg04->t0014;
	Eq_26242 eax_27 = dwArg04->t0010;
	if (dwArg14 == 0x00)
	{
		dwArg14 = ecx_24 & 0x0400;
		if ((ecx_24 & 0x0400) != 0x00)
		{
			if ((ch_33 & 0x08) != 0x00)
			{
				dwArg14.u0 = 0x02;
				if ((ch_33 & 0x01) == 0x00)
					goto l08058349;
				goto l08058380;
			}
			if (eax_27 >= edx_110)
			{
				if (dwArg04->t0008 >= edx_110)
					edx_110 = dwArg04->t0008;
				eax_118 = dwArg04->t000C;
				dwArg14_435.u0 = 0x01;
				dwLoc24_429 = edx_110;
				dwLoc2C_430 = edx_110 - eax_118;
				goto l080582BE;
			}
			dwArg14.u0 = 0x01;
		}
		else if (eax_27 >= edx_110 && (ch_33 & 0x08) == 0x00)
		{
			eax_118 = dwArg04->t000C;
l08058362:
			esi_111 = dwArg04->t0004 - eax_118;
			return esi_111;
		}
	}
	else if (eax_27 >= edx_110 && (ch_33 & 0x08) == 0x00)
	{
		eax_118 = dwArg04->t000C;
l080583A8:
		byte bArg14_432 = (byte) dwArg14;
		if (dwArg04->t0008 >= edx_110)
			edx_110 = dwArg04->t0008;
		esi_111.u0 = ~0x00;
		dwLoc24_429 = edx_110;
		dwLoc2C_430 = edx_110 - eax_118;
		dwArg14_435 = dwArg14;
		dwArg14_435 = dwArg14;
		if ((bArg14_432 & 0x01) == 0x00)
			goto l080583D0;
l080582BE:
		Eq_2 ecx_153;
		int32 edi_155;
		Eq_2 esi_154;
		Eq_2 dwLoc20_447;
		if (dwArg10 != 0x00)
		{
			if (dwArg10 == 0x01)
			{
				Eq_26242 ecx_171 = dwArg04->t0004;
				Eq_2 edx_177 = ecx_171 - eax_118;
				esi_154 = eax_118 - ecx_171;
				dwLoc20_447 = edx_177;
				edi_155 = esi_154 >> 0x1F;
				ecx_153 = 0x7FFFFFFF - edx_177;
			}
			else
			{
				esi_154 = -dwLoc2C_430;
				ecx_153 = 0x7FFFFFFF - dwLoc2C_430;
				dwLoc20_447 = dwLoc2C_430;
				edi_155 = esi_154 >> 0x1F;
			}
		}
		else
		{
			dwLoc20_447.u0 = 0x00;
			ecx_153.u0 = 0x7FFFFFFF;
			esi_154.u0 = 0x00;
			edi_155 = 0x00;
		}
		if (dwArg0C - edi_155 - (word32) (dwArg08 < esi_154) < 0x00 || ((ecx_153 >> 0x1F) - dwArg0C) - (word32) (ecx_153 < dwArg08) < 0x00)
			goto l08058550;
		word32 ecx_211 = dwLoc20_447 + dwArg08;
		esi_111 = ecx_211;
		if (ecx_211 > dwLoc2C_430)
		{
			if (enlarge_userbuf(dwArg04, ecx_211 >> 0x1F, ecx_211, gs, (struct Eq_26216 *) 0x01) != 0x00)
				goto l0805852B;
			eax_118 = dwArg04->t000C;
			dwLoc24_429 = eax_118 + dwLoc2C_430;
		}
		Mem254[dwArg04 + 0x04:word32] = eax_118 + ecx_211;
		dwArg04->t0008 = dwLoc24_429;
l080583D0:
		if (((byte) dwArg14_435 & 0x02) == 0x00)
			return esi_111;
		Eq_2 ecx_266;
		int32 edx_268;
		Eq_2 eax_267;
		if (dwArg10 != 0x00)
		{
			if (dwArg10 == 0x01)
			{
				Eq_26242 edx_283 = dwArg04->t0014;
				Eq_26242 eax_284 = dwArg04->t0010;
				Eq_2 edi_287 = edx_283 - eax_284;
				int64 edx_eax_290 = (int64) (eax_284 - edx_283);
				dwArg10 = edi_287;
				eax_267 = (word32) edx_eax_290;
				edx_268 = SLICE(edx_eax_290, word32, 32);
				ecx_266 = 0x7FFFFFFF - edi_287;
			}
			else
			{
				int64 edx_eax_281 = (int64) -dwLoc2C_430;
				ecx_266 = 0x7FFFFFFF - dwLoc2C_430;
				dwArg10 = dwLoc2C_430;
				eax_267 = (word32) edx_eax_281;
				edx_268 = SLICE(edx_eax_281, word32, 32);
			}
		}
		else
		{
			ecx_266.u0 = 0x7FFFFFFF;
			eax_267.u0 = 0x00;
			edx_268 = 0x00;
		}
		if (dwArg0C - edx_268 - (word32) (dwArg08 < eax_267) >= 0x00 && (SLICE((int64) ecx_266, word32, 32) - dwArg0C) - (word32) (ecx_266 < dwArg08) >= 0x00)
		{
			word32 ebp_342 = dwArg08 + dwArg10;
			if (ebp_342 <= dwLoc2C_430 || enlarge_userbuf(dwArg04, ebp_342 >> 0x1F, ebp_342, gs, null) == 0x00)
			{
				Mem400[dwArg04 + 0x14:word32] = ebp_342 + Mem394[dwArg04 + 0x10:word32];
				return ebp_342;
			}
l0805852B:
			esi_111.u0 = ~0x00;
			return esi_111;
		}
l08058550:
		gs->tFFFFFFE0.u0 = 22;
		esi_111.u0 = ~0x00;
		return esi_111;
	}
	if ((ch_33 & 0x01) == 0x00)
	{
l08058349:
		eax_118 = dwArg04->t001C;
l0805834C:
		dwArg04->t000C = eax_118;
		dwArg04->dw0000 = SEQ(ecx_16_16_87, ch_33 & ~0x08, cl_82);
		dwArg04->t0008 = edx_110;
		dwArg04->t0004 = edx_110;
		if (dwArg14 == 0x00)
			goto l08058362;
		goto l080583A8;
	}
l08058380:
	eax_118 = dwArg04->t0028;
	goto l0805834C;
}

// 08058570: void _IO_str_pbackfail(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _IO_str_pbackfail(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	if ((*dwArg04 & 0x08) != 0x00 && dwArg08 != ~0x00)
		return;
	_IO_default_pbackfail(gs, dwArg04, dwArg08);
}

// 080585A0: void _IO_str_finish(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_str_finish(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 eax_14 = *((word32) dwArg04 + 28);
	if (eax_14 != 0x00 && (*dwArg04 & 0x01) == 0x00)
	{
		word32 ecx_64;
		word32 edx_65;
		free(gs, dwLoc20, eax_14, out ecx_64, out edx_65);
	}
	((word32) dwArg04 + 28)->u0 = 0x00;
	_IO_default_finish(dwArg04);
}

// 08058600: void _IO_str_init_static_internal(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      vasprintf
//      _IO_str_init_static
//      _IO_str_init_readonly
void _IO_str_init_static_internal(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 edi_24;
	if (dwArg0C == 0x00)
		edi_24 = rawmemchr(dwArg08, 0x00);
	else
	{
		edi_24 = (word32) dwArg08 + dwArg0C;
		if (dwArg08 >= edi_24)
			edi_24.u0 = ~0x00;
	}
	_IO_setb(dwArg04, dwArg08, edi_24, 0x00);
	*((word32) dwArg04 + 16) = dwArg08;
	*((word32) dwArg04 + 0x0C) = dwArg08;
	*((word32) dwArg04 + 4) = dwArg08;
	if (dwArg10 != 0x00)
	{
		*((word32) dwArg04 + 20) = dwArg10;
		*((word32) dwArg04 + 24) = edi_24;
		*((word32) dwArg04 + 8) = dwArg10;
	}
	else
	{
		*((word32) dwArg04 + 20) = dwArg08;
		*((word32) dwArg04 + 24) = dwArg08;
		*((word32) dwArg04 + 8) = edi_24;
	}
	((word32) dwArg04 + 0x0098)->u0 = 0x00;
}

// 08058690: void _IO_str_init_static(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C, Stack Eq_2 dwArg10)
void _IO_str_init_static(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C, Eq_2 dwArg10)
{
	int32 eax_10 = dwArg0C;
	if (dwArg0C < 0x00)
		eax_10 = ~0x00;
	_IO_str_init_static_internal(dwArg04, dwArg08, eax_10, dwArg10);
}

// 080586B0: void _IO_str_init_readonly(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C)
void _IO_str_init_readonly(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C)
{
	int32 eax_16 = dwArg0C;
	if (dwArg0C < 0x00)
		eax_16 = ~0x00;
	_IO_str_init_static_internal(dwArg04, dwArg08, eax_16, 0x00);
	*dwArg04 |= 0x08;
}

// 080586E0: void _IO_str_count(Stack (ptr32 Eq_26802) dwArg04)
void _IO_str_count(struct Eq_26802 * dwArg04)
{
	dwArg04->dw0008 < dwArg04->dw0014;
}

// 08058700: Register uint32 __libc_alloca_cutoff(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      locked_vfxprintf
//      get_nprocs
//      __add_to_environ
//      printf_positional
//      __printf_fp_l
//      printf_positional
uint32 __libc_alloca_cutoff(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_14 = 0x00010000;
	if (gs->dw0274 >> 0x02 <= 0x00010000 && gs->dw0274 >> 0x02 >= 0x01)
	{
		uint32 eax_12 = gs->dw0274;
		edx_14 = eax_12 >> 0x02;
		if (eax_12 <= 0x03)
			edx_14.u0 = 0x00040000;
	}
	return (uint32) (int8) (edx_14 >= dwArg04);
}

// 08058740: Register Eq_2 __lll_lock_wait_private(Register word32 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      abort
//      _nl_find_msg
//      _nl_load_domain
//      _nl_expand_alias
//      __run_exit_handlers
//      __internal_atexit
//      __fxprintf
//      __fxprintf_nocancel
//      __new_fclose
//      fflush
//      _IO_puts
//      _IO_wfile_underflow
//      _IO_new_file_underflow
//      _IO_un_link.part.2
//      _IO_link_in
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      _IO_list_lock
//      get_free_list
//      arena_get2.part.5
//      arena_get_retry
//      _int_free
//      malloc_check
//      tcache_init.part.6
//      memalign_check
//      free_check.part.3
//      realloc_check
//      __malloc_fork_lock_parent
//      __libc_malloc
//      _mid_memalign
//      __malloc_arena_thread_freeres
//      __realloc
//      __libc_calloc
//      malloc_trim
//      mallinfo
//      __malloc_stats
//      __mallopt
//      malloc_info
//      __gconv_find_transform
//      __gconv_close_transform
//      __gconv_get_path
//      __add_to_environ
//      __unsetenv
//      __clearenv
//      vfprintf
//      buffered_vfprintf
//      register_printf_specifier
//      register_printf_modifier
//      register_printf_type
//      __vfwprintf
//      buffered_vfprintf
//      fputs
//      fwrite
//      _IO_getdelim
//      __readdir
//      __rewinddir
//      readdir64
Eq_2 __lll_lock_wait_private(word32 eax, Eq_2 ecx, struct Eq_9 * gs)
{
	int32 edx_13 = 0x02;
	Eq_2 ecx_17 = 0x80;
	if (eax == 0x02)
	{
l08058755:
		gs->ptr0010();
	}
	int32 v13_38 = *ecx;
	*ecx = edx_13;
	if (v13_38 == 0x00)
		return ecx_17;
	goto l08058755;
}

// 08058770: Register Eq_2 __lll_unlock_wake_private(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      abort
//      _IO_new_fclose.cold.0
//      _IO_fflush.cold.0
//      _IO_puts.cold.0
//      _IO_wfile_underflow.cold.2
//      _IO_new_file_underflow.cold.6
//      _IO_fputs.cold.0
//      _IO_fwrite.cold.0
//      _IO_getdelim.cold.0
//      _nl_find_msg
//      _nl_load_domain
//      _nl_expand_alias
//      __run_exit_handlers
//      __internal_atexit
//      __fxprintf
//      __fxprintf_nocancel
//      __new_fclose
//      fflush
//      _IO_puts
//      _IO_wfile_underflow
//      _IO_new_file_underflow
//      flush_cleanup
//      _IO_un_link.part.2
//      _IO_link_in
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      _IO_list_unlock
//      get_free_list
//      arena_get2.part.5
//      arena_get_retry
//      _int_free
//      malloc_check
//      tcache_init.part.6
//      memalign_check
//      free_check.part.3
//      realloc_check
//      __malloc_fork_unlock_parent
//      __libc_malloc
//      _mid_memalign
//      __malloc_arena_thread_freeres
//      __realloc
//      __libc_calloc
//      malloc_trim
//      mallinfo
//      __malloc_stats
//      __mallopt
//      malloc_info
//      __gconv_find_transform
//      __gconv_close_transform
//      __gconv_get_path
//      __add_to_environ
//      __unsetenv
//      __clearenv
//      vfprintf
//      buffered_vfprintf
//      register_printf_specifier
//      register_printf_modifier
//      register_printf_type
//      __vfwprintf
//      buffered_vfprintf
//      __funlockfile
//      fputs
//      fwrite
//      _IO_getdelim
//      __readdir
//      __rewinddir
//      readdir64
Eq_2 __lll_unlock_wake_private(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	*eax = 0x00;
	Eq_2 eax_22;
	gs->ptr0010();
	return eax_22;
}

// 080587A0: void _dl_tunable_set_arena_max(Stack (ptr32 uint32) dwArg04)
void _dl_tunable_set_arena_max(uint32 * dwArg04)
{
	g_dw80CE4B0 = *dwArg04;
}

// 080587C0: void _dl_tunable_set_arena_test(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_arena_test(union Eq_2 * dwArg04)
{
	g_t80CE4AC = *dwArg04;
}

// 080587E0: void _dl_tunable_set_tcache_max(Stack (ptr32 up32) dwArg04)
void _dl_tunable_set_tcache_max(up32 * dwArg04)
{
	up32 eax_8 = *dwArg04;
	if (eax_8 <= 1020)
	{
		g_dw80CE4D4 = eax_8;
		g_dw80CE4D0 = ((eax_8 + 0x13 & ~0x0F) - 0x01 >> 0x04) + 0x01;
	}
}

// 08058820: void _dl_tunable_set_tcache_count(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_tcache_count(union Eq_2 * dwArg04)
{
	Eq_2 eax_8 = *dwArg04;
	if (eax_8 <= 0x7F)
		g_t80CE4D8 = eax_8;
}

// 08058850: void _dl_tunable_set_tcache_unsorted_limit(Stack (ptr32 word32) dwArg04)
void _dl_tunable_set_tcache_unsorted_limit(word32 * dwArg04)
{
	g_dw80CE4DC = *dwArg04;
}

// 08058870: void mem2mem_check(Register Eq_2 eax, Register Eq_26908 edx)
// Called from:
//      malloc_check
//      memalign_check
//      realloc_check
void mem2mem_check(Eq_2 eax, Eq_26908 edx)
{
	if (eax == 0x00)
		return;
	byte bl_29 = (byte) (eax - 0x08 >> 0x03 ^ eax - 0x08 >> 11);
	Eq_2 esi_28 = *((word32) eax - 4);
	if (bl_29 == 0x01)
		bl_29 = 0x02;
	Eq_26928 esi_43 = (word32) bl_29;
	ui32 edi_45 = (esi_28 & ~0x07) - 0x08;
	ui32 ebx_46 = (esi_28 & ~0x07) - 0x04;
	if ((esi_28 & 0x02) != 0x00)
		ebx_46 = edi_45;
	Eq_26908 ebx_52 = ebx_46 - 0x01;
	if (ebx_52 > edx)
	{
		do
		{
			Eq_26928 ecx_183 = ebx_52 - edx;
			if (ecx_183 > 0xFF)
				ecx_183.u0 = 0xFF;
			if (ecx_183 == esi_43)
				ecx_183 = SEQ(SLICE(esi_43 - 0x01, word24, 8), (byte) esi_43 - 0x01);
			Mem83[eax + ebx_52:byte] = SLICE(ecx_183, byte, 0);
			ebx_52 -= ecx_183;
		} while (edx < ebx_52);
	}
	Mem106[eax + edx:byte] = bl_29;
}

// 08058900: Register Eq_2 mem2chunk_check(Register Eq_2 eax, Register (ptr32 (ptr32 byte)) edx, Register out Eq_26969 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      free_check.part.3
//      realloc_check
Eq_2 mem2chunk_check(Eq_2 eax, byte ** edx, union Eq_26969 & ecxOut, union Eq_2 & edxOut)
{
	byte al = (byte) eax;
	Eq_2 edx_263;
	if ((al & 0x0F) == 0x00)
	{
		Eq_2 ebx_27 = *((word32) eax - 4);
		Eq_26969 ecx_37 = eax - (struct Eq_26984 *) 0x08 >> 11 ^ eax - (struct Eq_26984 *) 0x08 >> 0x03;
		byte bl_44 = (byte) ebx_27;
		edx_263 = eax - (struct Eq_26984 *) 0x08;
		if ((byte) ecx_37 == 0x01)
			ecx_37.u0 = 0x02;
		byte * edi_117;
		byte cl_122 = (byte) ecx_37;
		if ((bl_44 & 0x02) != 0x00)
		{
			Eq_2 esi_155 = _dl_pagesize;
			uint32 edi_157 = eax & esi_155 - 0x01;
			if ((edi_157 - 0x10 & ~0x10) != 0x00 && (edi_157 <= 0x1FFF && ((edi_157 - 0x40 & ~0x40) != 0x00 && ((edi_157 - 0x0100 & ~0x0100) != 0x00 && (edi_157 - 0x0400 & ~0x0400) != 0x00))))
			{
				ecx = ecx_37;
				if (edi_157 != 0x1000)
					goto l08058A50;
			}
			ecx = ecx_37;
			if ((ebx_27 & 0x03) != 0x02)
				goto l08058A50;
			Eq_2 eax_191 = *((word32) eax - 8);
			ecx = ecx_37;
			if ((((word32) eax_191 + (ebx_27 & ~0x07) | (eax - (struct Eq_26984 *) 0x08) - eax_191) & esi_155 - 0x01) == 0x00)
			{
				edi_117 = eax - (struct Eq_26984 *) 0x08 + ((ebx_27 & ~0x07) - 0x01);
				uint32 esi_206 = (word32) *edi_117;
				uint32 eax_204 = (ebx_27 & ~0x07) - 0x01;
				if (cl_122 != (byte) esi_206)
				{
					ecx = ecx_37;
					if (esi_206 != 0x00)
					{
						ecx = ecx_37;
						if ((ebx_27 & ~0x07) - 0x01 >= esi_206 + 0x08)
						{
							do
							{
								eax_204 -= esi_206;
								edi_117 = eax - (struct Eq_26984 *) 0x08 + eax_204;
								esi_206 = (word32) *edi_117;
								if ((byte) esi_206 == cl_122)
									goto l080589F9;
								ecx = ecx_37;
								if (esi_206 == 0x00)
									break;
								ecx = ecx_37;
							} while (esi_206 + 0x08 <= eax_204);
						}
					}
					goto l08058A50;
				}
l080589F9:
				ecx = ~ecx_37;
				*edi_117 = (byte) ecx;
				if (edx != null)
					*edx = (byte **) edi_117;
l08058A52:
				ecxOut = ecx;
				edxOut = edx_263;
				return edx_263;
			}
			goto l08058A50;
		}
		Eq_27006 edi_50 = g_t80CE504;
		if ((edi_50 & 0x02) != 0x00)
		{
l08058A35:
			ecx = ecx_37;
			if ((ebx_27 & ~0x07) <= 0x0F)
				goto l08058A50;
			ecx = ecx_37;
			if ((bl_44 & 0x08) == 0x00)
			{
				ecx = ecx_37;
				if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(eax - 0x04)[ebx_27 & ~0x07].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & 0x01) == 0x00)
					goto l08058A50;
				if ((ebx_27 & 0x01) != 0x00)
				{
l08058A82:
					edi_117 = eax - (struct Eq_26984 *) 0x08 + ((ebx_27 & ~0x07) + 0x03);
					uint32 esi_118 = (word32) *edi_117;
					uint32 ebx_114 = (ebx_27 & ~0x07) + 0x03;
					if (cl_122 != (byte) esi_118)
					{
						ecx = ecx_37;
						if (esi_118 != 0x00)
						{
							ecx = ecx_37;
							if ((ebx_27 & ~0x07) + 0x03 >= esi_118 + 0x08)
							{
								do
								{
									ebx_114 -= esi_118;
									edi_117 = eax - (struct Eq_26984 *) 0x08 + ebx_114;
									esi_118 = (word32) *edi_117;
									if ((byte) esi_118 == cl_122)
										goto l080589F9;
									ecx = ecx_37;
									if (esi_118 == 0x00)
										break;
									ecx = ecx_37;
								} while (esi_118 + 0x08 <= ebx_114);
							}
						}
						goto l08058A50;
					}
					goto l080589F9;
				}
				Eq_2 eax_89 = *((word32) eax - 8);
				ecx = ecx_37;
				if (((byte) eax_89 & 0x0F) != 0x00)
					goto l08058A50;
				Eq_2 ebx_96 = eax - (struct Eq_26984 *) 0x08 - eax_89;
				if ((edi_50 & 0x02) == 0x00)
				{
					ecx = ecx_37;
					if (g_t80CE4CC > ebx_96)
						goto l08058A50;
				}
				ecx = ecx_37;
				if (eax_89 == (*((word32) ebx_96 + 4) & ~0x07))
					goto l08058A82;
			}
			goto l08058A50;
		}
		Eq_2 edi_57 = g_t80CE4CC;
		ecx = ecx_37;
		if (edi_57 > eax - (struct Eq_26984 *) 0x08)
			goto l08058A50;
		ecx = ecx_37;
		if ((ebx_27 & ~0x07) + (eax - (struct Eq_26984 *) 0x08) < (word32) edi_57 + g_dw80CE954)
			goto l08058A35;
	}
l08058A50:
	edx_263.u0 = 0x00;
	goto l08058A52;
}

// 08058B00: Register word32 int_mallinfo(Register Eq_2 eax, Register (ptr32 Eq_27207) edx, Register out ptr32 edxOut)
// Called from:
//      mallinfo
//      __malloc_stats
word32 int_mallinfo(Eq_2 eax, struct Eq_27207 * edx, ptr32 & edxOut)
{
	word32 ebp_50 = 0x00;
	struct Eq_27211 ** ecx_27 = (word32) eax + 0x0C;
	word32 edi_29 = 0x00;
	Eq_2 eax_30 = *((word32) *((word32) eax + 56) + 4);
	do
	{
		struct Eq_27230 * eax_39 = *ecx_27;
		while (eax_39 != null)
		{
			eax_39 = eax_39->ptr0008;
			++ebp_50;
			edi_29 += eax_39->dw0004 & ~0x07;
		}
		struct Eq_27223 * esi_102 = (word32) eax + 56;
		ecx_27 = (struct Eq_27211 **) ((char *) ecx_27 + 4);
	} while ((word32) eax + 56 != ecx_27);
	ui32 ecx_122 = (eax_30 & ~0x07) + edi_29;
	word32 ebx_115 = 0x01;
	do
	{
		struct Eq_27223 * eax_85 = esi_102->dw000C;
		while (eax_85 != esi_102)
		{
			eax_85 = eax_85->dw000C;
			++ebx_115;
			ecx_122 += eax_85->dw0004 & ~0x07;
		}
		++esi_102;
	} while ((word32) eax + 0x0430 != esi_102);
	edx->dw0004 += ebx_115;
	edx->dw0008 += ebp_50;
	edx->dw0020 += ecx_122;
	Eq_2 eax_126 = *((word32) eax + 0x0454);
	edx->dw0000 = (word32) eax_126 + edx->dw0000;
	edx->dw0018 += edi_29;
	edx->dw001C += eax_126 - ecx_122;
	if (eax != 0x080CE500)
		return;
	edx->t000C = g_t80CE4B4;
	Eq_27327 eax_146 = g_t80CE4C4;
	edx->dw0014 = 0x00;
	edx->t0010 = eax_146;
	edx->dw0024 = eax_30 & ~0x07;
	return;
}

// 08058C20: void _dl_tunable_set_trim_threshold(Stack (ptr32 ui32) dwArg04)
void _dl_tunable_set_trim_threshold(ui32 * dwArg04)
{
	g_dw80CE4A0 = *dwArg04;
	g_dw80CE4C0 = 0x01;
}

// 08058C50: void _dl_tunable_set_top_pad(Stack (ptr32 up32) dwArg04)
void _dl_tunable_set_top_pad(up32 * dwArg04)
{
	g_dw80CE4A4 = *dwArg04;
	g_dw80CE4C0 = 0x01;
}

// 08058C80: void _dl_tunable_set_mmap_threshold(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_mmap_threshold(union Eq_2 * dwArg04)
{
	Eq_2 eax_8 = *dwArg04;
	if (eax_8 > 0x00080000)
		return;
	g_t80CE4A8 = eax_8;
	g_dw80CE4C0 = 0x01;
}

// 08058CC0: void _dl_tunable_set_mmaps_max(Stack (ptr32 Eq_27327) dwArg04)
void _dl_tunable_set_mmaps_max(union Eq_27327 * dwArg04)
{
	g_t80CE4B8 = *dwArg04;
	g_dw80CE4C0 = 0x01;
}

// 08058CF0: void _dl_tunable_set_perturb_byte(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_perturb_byte(union Eq_2 * dwArg04)
{
	perturb_byte = *dwArg04;
}

// 08058D10: FlagGroup byte __malloc_assert(Register Eq_2 eax, Register Eq_2 ecx, Register ptr32 edx, Register out (ptr32 Eq_27395) eaxOut, Register out Eq_27396 ecxOut, Register out Eq_27397 edxOut)
// Called from:
//      detach_arena
//      get_free_list
//      munmap_chunk
//      mremap_chunk
//      arena_get2.part.5
//      _int_free
//      sysmalloc
//      _int_malloc
//      _int_memalign
//      _int_realloc
//      __libc_malloc
//      _mid_memalign
//      __malloc_arena_thread_freeres
//      __realloc
//      __libc_calloc
//      malloc_trim
byte __malloc_assert(Eq_2 eax, Eq_2 ecx, ptr32 edx, struct Eq_27395 & eaxOut, union Eq_27396 & ecxOut, union Eq_27397 & edxOut)
{
	ptr32 ebp_23;
	Eq_2 ecx_71;
	ptr32 esp_18 = fp - 0x1C;
	Eq_2 esi_20 = program_invocation_short_name;
	if (*esi_20 == 0x00)
	{
		ebp_23 = 134955513;
l08058D3B:
		struct Eq_27414 * esp_26 = esp_18 - 0x0C;
		esp_26->tFFFFFFFC = eax;
		esp_26->ptrFFFFFFF8 = 0x080A221C;
		esp_26->dwFFFFFFF4 = esp_26->dw002C;
		esp_26->tFFFFFFF0 = ecx;
		esp_26->ptrFFFFFFEC = edx;
		esp_26->ptrFFFFFFE8 = ebp_23;
		esp_26->tFFFFFFE4 = esi_20;
		esp_26->ptrFFFFFFE0 = 134884312;
		esp_26->dwFFFFFFDC = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		__fxprintf(gs, stackArg4);
		esp_26->tFFFFFFFC = _IO_stderr;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		fflush(gs, stackArg4);
		esp_18 = esp_26 - 4;
		eax = abort(ecx_71, gs, out ecx_71, out edx);
		ecx = ecx_71;
	}
	ebp_23 = 0x080A221C;
	goto l08058D3B;
}

// 08058D80: Register word32 detach_arena(Register Eq_2 eax, Register out ptr32 edxOut)
// Called from:
//      get_free_list
//      arena_get2.part.5
word32 detach_arena(Eq_2 eax, ptr32 & edxOut)
{
	if (eax != 0x00)
	{
		Eq_2 edx_14 = *((word32) eax + 1104);
		if (edx_14 == 0x00)
		{
			word32 edx_73;
			word32 ecx_72;
			word32 eax_71;
			__malloc_assert(0x080A2C00, 0x02A3, 0x080A28A8, out eax_71, out ecx_72, out edx_73);
			ptr32 edx_31;
			word32 ecx_32;
			word32 ebx_75;
			word32 esi_76;
			word32 edi_77;
			get_free_list(gs, out ecx_32, out edx_31, out ebx_75, out esi_76, out edi_77);
			edxOut = edx_31;
			return ecx_32;
		}
		*((word32) eax + 1104) = edx_14 - 0x01;
		edx = edx_14 - 0x01;
	}
	edxOut = edx;
	return ecx;
}

// 08058DD0: Register Eq_2 get_free_list(Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_2 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      detach_arena
//      arena_get_retry
//      tcache_init.part.6
//      __libc_malloc
//      _mid_memalign
//      __libc_calloc
Eq_2 get_free_list(struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_2 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_2 ebx_136 = free_list;
	if (ebx_136 != 0x00)
	{
		ecx.u0 = 0x01;
		edx = gs->tFFFFFFEC;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_30;
		if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_30))
			ecx = __lll_lock_wait_private(eax_30, 0x080CF888, gs);
		ebx_136 = free_list;
		if (ebx_136 != 0x00)
		{
			free_list = *((word32) ebx_136 + 0x044C);
			if (*((word32) ebx_136 + 1104) != 0x00)
			{
				word32 eax_233;
				word32 edx_235;
				word32 ecx_234;
				__malloc_assert(0x080A28B0, 0x0301, 0x080A28A8, out eax_233, out ecx_234, out edx_235);
				Eq_2 ecx_72;
				Eq_2 edx_73;
				Eq_2 eax_71 = malloc_printerr(out ecx_72, out edx_73);
				ecxOut = ecx_72;
				edxOut = edx_73;
				ebxOut = ebx_136;
				esiOut = 0x080CE000;
				ediOut = ~0x13;
				return eax_71;
			}
			((word32) ebx_136 + 1104)->u0 = 0x01;
			ecx = detach_arena(edx, out edx);
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_90 = free_list_lock - 0x01;
		free_list_lock = v14_90;
		if (v14_90 != 0x00)
			__lll_unlock_wake_private(0x080CF888, ecx, edx, gs);
		if (ebx_136 != 0x00)
		{
			ecx.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_118;
			if (!__cmpxchg(*ebx_136, 0x01, 0x00, out eax_118))
				ecx = __lll_lock_wait_private(eax_118, ebx_136, gs);
			gs->tFFFFFFEC = ebx_136;
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	ebxOut = ebx;
	esiOut = esi;
	ediOut = edi;
	return ebx_136;
}

// 08058EC0: Register word32 malloc_printerr(Register out Eq_952 ecxOut, Register out (ptr32 Eq_27603) edxOut)
// Called from:
//      get_free_list
//      top_check
//      malloc_consolidate
//      munmap_chunk
//      mremap_chunk
//      _int_free
//      sysmalloc
//      _int_malloc
//      free_check.part.3
//      _int_realloc
//      realloc_check
//      __realloc
//      __malloc_usable_size
word32 malloc_printerr(union Eq_952 & ecxOut, struct Eq_27603 & edxOut)
{
	__libc_message(gs, 0x01, 134954212);
	struct Eq_27603 * edx_24;
	word32 ebx_38;
	word32 eax_25 = top_check(out edx_24, out ebx_38);
	ecxOut.u0 = <invalid>;
	edxOut = edx_24;
	return eax_25;
}

// 08058EE0: Register Eq_2 top_check(Register out Eq_2 edxOut, Register out Eq_27646 ebxOut)
// Called from:
//      malloc_printerr
//      malloc_check
//      memalign_check
//      realloc_check
Eq_2 top_check(union Eq_2 & edxOut, union Eq_27646 & ebxOut)
{
	Eq_2 edx_32 = g_t80CE538;
	if (edx_32 == 0x080CE538)
	{
		edxOut = edx_32;
		ebxOut = ebx;
		return 0x080CE000;
	}
	Eq_2 ecx_15 = *((word32) edx_32 + 4);
	if (((byte) ecx_15 & 0x02) == 0x00)
	{
		ebx = ecx_15 & ~0x07;
		if ((ecx_15 & ~0x07) > 0x0F && (ecx_15 & 0x01) != 0x00)
		{
			if ((g_t80CE504 & 0x02) != 0x00)
			{
l08058F30:
				edxOut = edx_32;
				ebxOut = ebx;
				return 0x080CE000;
			}
			edx_32 = (word32) edx_32 + (ecx_15 & ~0x07);
			if (edx_32 == (word32) g_t80CE4CC + g_dw80CE954)
				goto l08058F30;
		}
	}
	word32 edx_91;
	word32 ecx_90;
	malloc_printerr(out ecx_90, out edx_91);
	Eq_2 edx_50;
	word32 ecx_94;
	word32 ebx_95;
	word32 ebp_96;
	word32 edi_97;
	Eq_2 eax_49 = malloc_consolidate(eax, gs, out ecx_94, out edx_50, out ebx_95, out ebp_96, out edi_97);
	edxOut = edx_50;
	ebxOut = ebx;
	return eax_49;
}

// 08058F50: Register Eq_2 malloc_consolidate(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out Eq_27707 ecxOut, Register out Eq_2 edxOut, Register out Eq_2 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      top_check
//      _int_free
//      _int_malloc
//      malloc_trim
//      __mallopt
Eq_2 malloc_consolidate(Eq_2 eax, struct Eq_9 * gs, union Eq_27707 & ecxOut, union Eq_2 & edxOut, union Eq_2 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & ediOut)
{
	((word32) eax + 8)->u0 = 0x00;
	Eq_2 dwLoc38_350 = (word32) eax + 0x0C;
	edi_101 = edi;
	do
	{
		Eq_2 edi_101;
		Eq_2 v12_33 = *dwLoc38_350;
		*dwLoc38_350 = 0x00;
		Eq_2 edx_109 = dwLoc38_350;
		Eq_2 ebx_118 = v12_33;
		if (v12_33 != 0x00)
		{
			do
			{
				Eq_2 esi_42 = *((word32) ebx_118 + 4);
				if (dwLoc38_350 != ((word32) eax + 4) + (esi_42 >> 0x03) * 0x04)
				{
					up32 edx_54;
					word32 ecx_522;
					Eq_2 eax_55 = malloc_printerr(out ecx_522, out edx_54);
					Eq_27707 ecx_62;
					Eq_2 edx_63;
					Eq_2 eax_61 = new_heap(eax_55, edx_54, gs, out ecx_62, out edx_63);
					ecxOut = ecx_62;
					edxOut = edx_63;
					ebxOut = ebx_118;
					ebpOut = eax;
					ediOut = edi_101;
					return eax_61;
				}
				Eq_2 esi_121;
				edx_109 = (word32) ebx_118 + (esi_42 & ~0x07);
				Eq_2 edi_73 = *((word32) edx_109 + 4);
				Eq_2 eax_68 = *((word32) ebx_118 + 8);
				Eq_2 eax_112 = esi_42 & ~0x07;
				ecx = edi_73 & ~0x07;
				edi_101 = edi_73;
				if ((esi_42 & 0x01) == 0x00)
				{
					esi_121 = *ebx_118;
					ebx_118 -= esi_121;
					Eq_2 edi_84 = *((word32) ebx_118 + 4);
					eax_112 = (word32) esi_121 + (esi_42 & ~0x07);
					dwLoc28 = edi_84;
					edi_101 = edi_84 & ~0x07;
					if ((edi_84 & ~0x07) != esi_121)
						goto l08059130;
					if ((edi_84 & ~0x07) != *((word32) ebx_118 + (edi_84 & ~0x07)))
						goto l08059120;
					esi_121 = *((word32) ebx_118 + 8);
					edi_101 = *((word32) ebx_118 + 0x0C);
					if (*((word32) esi_121 + 0x0C) != ebx_118 || *((word32) edi_101 + 8) != ebx_118)
						goto l08059110;
					*((word32) esi_121 + 0x0C) = edi_101;
					*((word32) edi_101 + 8) = esi_121;
					if (edi_84 <= 1007)
						goto l080590B0;
					edi_101 = *((word32) ebx_118 + 16);
					dwLoc28 = edi_101;
					if (edi_101 == 0x00)
						goto l080590B0;
					goto l08059140;
				}
				while (true)
				{
l080590B0:
					if (*((word32) eax + 56) == edx_109)
						break;
					esi_121 = edx_109 + ecx;
					if ((*((word32) esi_121 + 4) & 0x01) != 0x00)
					{
						*((word32) edx_109 + 4) = edi_73 & ~0x01;
						goto l08058FE0;
					}
					eax_112 += ecx;
					if (*esi_121 == ecx)
					{
						Eq_2 ecx_134 = *((word32) edx_109 + 8);
						esi_121 = *((word32) edx_109 + 0x0C);
						if (*((word32) ecx_134 + 0x0C) != edx_109 || *((word32) esi_121 + 8) != edx_109)
						{
l08059110:
							word32 ecx_525;
							word32 edx_526;
							malloc_printerr(out ecx_525, out edx_526);
							goto l08059120;
						}
						*((word32) ecx_134 + 0x0C) = esi_121;
						*((word32) esi_121 + 8) = ecx_134;
						if (edi_73 > 1007)
						{
							esi_121 = *((word32) edx_109 + 16);
							if (esi_121 == 0x00)
								goto l08058FE0;
							if (*((word32) esi_121 + 20) != edx_109)
							{
l0805916E:
								eax_112 = malloc_printerr(out ecx, out edx_109);
l0805917D:
								if (dwLoc28 != ebx_118)
								{
									*((word32) esi_121 + 16) = dwLoc28;
									*((word32) esi_121 + 20) = dwLoc20;
									*((word32) *((word32) ebx_118 + 16) + 20) = esi_121;
									edi_101 = *((word32) ebx_118 + 20);
									*((word32) edi_101 + 16) = esi_121;
								}
								else
								{
									*((word32) esi_121 + 20) = esi_121;
									*((word32) esi_121 + 16) = esi_121;
								}
								continue;
							}
							edi_101 = *((word32) edx_109 + 20);
							if (*((word32) edi_101 + 16) != edx_109)
								goto l0805916E;
							if (*((word32) ecx_134 + 16) != 0x00)
							{
								*((word32) esi_121 + 20) = edi_101;
								*((word32) *((word32) edx_109 + 20) + 16) = esi_121;
							}
							else if (esi_121 != edx_109)
							{
								*((word32) ecx_134 + 16) = esi_121;
								Eq_2 esi_252 = *((word32) edx_109 + 16);
								*((word32) ecx_134 + 20) = edi_101;
								*((word32) esi_252 + 20) = ecx_134;
								*((word32) *((word32) edx_109 + 20) + 16) = ecx_134;
							}
							else
							{
								*((word32) ecx_134 + 20) = ecx_134;
								*((word32) ecx_134 + 16) = ecx_134;
							}
						}
l08058FE0:
						edx_109 = *((word32) eax + 64);
						*((word32) eax + 64) = ebx_118;
						*((word32) edx_109 + 0x0C) = ebx_118;
						if (eax_112 > 1007)
						{
							((word32) ebx_118 + 16)->u0 = 0x00;
							((word32) ebx_118 + 20)->u0 = 0x00;
						}
						*((word32) ebx_118 + 8) = edx_109;
						*((word32) ebx_118 + 4) = eax_112 | 0x01;
						*((word32) ebx_118 + 0x0C) = (word32) eax + 56;
						Mem284[ebx_118 + eax_112:word32] = eax_112;
						ecx = (word32) eax + 56;
						goto l08059013;
					}
l08059120:
					word32 ecx_523;
					word32 edx_524;
					malloc_printerr(out ecx_523, out edx_524);
l08059130:
					eax_112 = malloc_printerr(out ecx, out edx_109);
l08059140:
					if (*((word32) edi_101 + 20) != ebx_118)
						goto l0805916E;
					edi_101 = *((word32) ebx_118 + 20);
					dwLoc20 = edi_101;
					if (*((word32) edi_101 + 16) != ebx_118)
						goto l0805916E;
					edi_101 = *((word32) esi_121 + 16);
					if (edi_101 == 0x00)
						goto l0805917D;
					*((word32) dwLoc28 + 20) = edi_101;
					*((word32) *((word32) ebx_118 + 20) + 16) = dwLoc28;
					edi_101 = dwLoc28;
				}
				Mem119[ebx_118 + 0x04:word32] = eax_112 + ecx | 0x01;
				*((word32) eax + 56) = ebx_118;
l08059013:
				ebx_118 = eax_68;
			} while (eax_68 != 0x00);
		}
		Eq_2 v14_293 = (word32) dwLoc38_350 + 4;
		dwLoc38_350 = v14_293;
	} while ((word32) eax + 56 != v14_293);
	ecxOut = ecx;
	edxOut = edx_109;
	ebxOut = ebx;
	ebpOut = ebp;
	ediOut = edi;
	return v14_293;
}

// subject_text_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080591F0: Register Eq_2 new_heap(Register Eq_2 eax, Register up32 edx, Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut, Register out Eq_27868 edxOut)
// Called from:
//      malloc_consolidate
//      arena_get2.part.5
//      sysmalloc
Eq_2 new_heap(Eq_2 eax, up32 edx, struct Eq_9 * gs, ptr32 & ecxOut, union Eq_27868 & edxOut)
{
	Eq_2 ebx_142;
	Eq_27868 edx_133 = (word32) eax + edx;
	ptr32 ecx_132 = 0x080CE9B0;
	Eq_2 esi_23 = _dl_pagesize;
	if (edx_133 > 0x7FFF)
	{
		if (edx_133 > 0x00100000)
		{
			edx_133.u0 = 0x00100000;
			if (eax > 0x00100000)
				goto l08059320;
		}
	}
	else
		edx_133.u0 = 0x8000;
	Eq_2 ebx_139;
	Eq_2 esi_36 = -esi_23 & (word32) esi_23 + (edx_133 - 0x01);
	Eq_2 eax_39 = aligned_heap_area;
	if (eax_39 != 0x00)
	{
		word32 edx_372;
		word32 ecx_371;
		Eq_2 eax_60 = mmap(gs, eax_39, 0x00100000, 0x00, 0x4022, ~0x00, 0x00, out ecx_371, out edx_372);
		aligned_heap_area.u0 = 0x00;
		ebx_139 = eax_60;
		if (eax_60 != ~0x00)
		{
			if ((eax_60 & 0x000FFFFF) == 0x00)
				goto l080592D7;
			word32 edx_374;
			word32 ecx_373;
			word32 ebx_375;
			__munmap(eax_60, gs, eax_60, 0x00100000, out ecx_373, out edx_374, out ebx_375);
		}
	}
	word32 edx_370;
	word32 ecx_369;
	Eq_2 eax_107 = mmap(gs, 0x00, 0x00200000, 0x00, 0x4022, ~0x00, 0x00, out ecx_369, out edx_370);
	if (eax_107 != ~0x00)
	{
		Eq_2 ebx_163;
		Eq_2 ebx_149 = (word32) eax_107 + 0x000FFFFF & 0xFFF00000;
		Eq_2 edx_152 = ebx_149 - eax_107;
		if (edx_152 == 0x00)
		{
			aligned_heap_area = (word32) ebx_149 + 0x00100000;
			ebx_163 = ebx_149;
		}
		else
		{
			word32 ecx_376;
			word32 edx_377;
			__munmap(ebx_149, gs, eax_107, edx_152, out ecx_376, out edx_377, out ebx_163);
		}
		word32 ecx_378;
		word32 edx_379;
		__munmap(ebx_163, gs, (word32) ebx_149 + 0x00100000, 0x00100000 - edx_152, out ecx_378, out edx_379, out ebx_139);
l080592D7:
		ptr32 ecx_213;
		Eq_27868 edx_214;
		if (mprotect(gs, ebx_139, esi_36, 0x03, out ecx_213, out edx_214) == 0x00)
		{
			*((word32) ebx_139 + 8) = esi_36;
			*((word32) ebx_139 + 0x0C) = esi_36;
			ecxOut = ecx_213;
			edxOut = edx_214;
			return ebx_139;
		}
		goto l08059360;
	}
	Eq_2 eax_131 = mmap(gs, 0x00, 0x00100000, 0x00, 0x4022, ~0x00, 0x00, out ecx_132, out edx_133);
	ebx_139 = eax_131;
	if (eax_131 != ~0x00)
	{
		if ((eax_131 & 0x000FFFFF) != 0x00)
		{
l08059360:
			__munmap(0x00, gs, ebx_139, 0x00100000, out ecx_132, out edx_133, out ebx_142);
			goto l08059322;
		}
		goto l080592D7;
	}
l08059320:
	ebx_142.u0 = 0x00;
l08059322:
	ecxOut = ecx_132;
	edxOut = edx_133;
	return ebx_142;
}

// 080593A0: Register Eq_2 munmap_chunk(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out Eq_28218 ecxOut, Register out (ptr32 Eq_28219) edxOut, Register out (ptr32 Eq_28220) ebxOut)
// Called from:
//      _int_free
//      free_check.part.3
//      realloc_check
//      free
//      __realloc
Eq_2 munmap_chunk(Eq_2 eax, struct Eq_9 * gs, union Eq_28218 & ecxOut, struct Eq_28219 & edxOut, struct Eq_28220 & ebxOut)
{
	Eq_2 esi_14 = *((word32) eax + 4);
	Eq_2 ecx_23 = _dl_pagesize;
	if ((esi_14 & 0x02) != 0x00)
	{
		ui32 edx_38 = *eax;
		Eq_2 esi_43 = eax - edx_38;
		Eq_2 edx_44 = edx_38 + (esi_14 & ~0x07);
		word32 eax_42 = eax + 0x08 & ecx_23 - 0x01;
		if ((ecx_23 - 0x01 & (esi_43 | edx_44) | eax_42 & eax_42 - 0x01) == 0x00)
		{
			__lock();
			--g_t80CE4B4;
			__lock();
			g_t80CE4C4 = (word32) g_t80CE4C4 + -edx_44;
			Eq_28218 ecx_84;
			struct Eq_28219 * edx_85;
			word32 ebx_133;
			Eq_2 eax_82 = __munmap(0x080CE000, gs, esi_43, edx_44, out ecx_84, out edx_85, out ebx_133);
			ecxOut = ecx_84;
			edxOut = edx_85;
			ebxOut = ebx;
			return eax_82;
		}
	}
	else
	{
		word32 eax_128;
		word32 ecx_129;
		word32 edx_130;
		__malloc_assert(134883630, 0x0B00, 0x080A2925, out eax_128, out ecx_129, out edx_130);
	}
	word32 ecx_131;
	word32 edx_132;
	Eq_2 eax_60 = malloc_printerr(out ecx_131, out edx_132);
	struct Eq_28219 * edx_66;
	Eq_28218 ecx_67;
	Eq_2 eax_65 = mremap_chunk(eax_60, edx, gs, out ecx_67, out edx_66);
	ecxOut = ecx_67;
	edxOut = edx_66;
	ebxOut = (struct Eq_28220 *) &g_t80CE000;
	return eax_65;
}

// 08059440: Register Eq_2 mremap_chunk(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      munmap_chunk
//      realloc_check
//      __realloc
Eq_2 mremap_chunk(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_225;
	Eq_2 edi_20 = *((word32) eax + 4);
	Eq_2 esi_21 = *eax;
	Eq_2 edx_30 = _dl_pagesize;
	if ((edi_20 & 0x02) != 0x00)
	{
		Eq_2 edx_103;
		Eq_2 ecx_111;
		Eq_2 edi_45 = (word32) esi_21 + (edi_20 & ~0x07);
		Eq_2 ebp_48 = eax - esi_21;
		word32 ecx_51 = eax + 0x08 & edx_30 - 0x01;
		if (((ebp_48 | edi_45) & edx_30 - 0x01 | ecx_51 & ecx_51 - 0x01) != 0x00)
		{
			word32 ecx_270;
			word32 edx_271;
			malloc_printerr(out ecx_270, out edx_271);
			goto l08059590;
		}
		Eq_2 edx_71 = -edx_30 & (word32) esi_21 + ((word32) edx + ((word32) edx_30 + 3));
		edx_225 = edi_45;
		if (edi_45 != edx_71)
		{
			Eq_2 eax_101 = __mremap(gs, ebp_48, edi_45, edx_71, 0x01, dwLoc2C, out edx_103);
			struct Eq_28385 * esp_108 = fp - 44;
			if (eax_101 == ~0x00)
				goto l080595B0;
			ecx_111 = eax_101 + esi_21;
			if (((byte) ecx_111 + 0x08 & 0x0F) == 0x00)
			{
				if (*ecx_111.u0 != esi_21)
				{
					word32 edx_275;
					word32 eax_274;
					__malloc_assert(134883678, 0x0B40, 0x080A2925, out eax_274, out ecx_111, out edx_275);
					esp_108 = fp - 0x3C;
				}
				Eq_2 edi_158 = edx_71 - esp_108->dw0004;
				*((byte) ecx_111.u0 + 4) = edx_71 - esi_21 | 0x02;
				__lock();
				g_t80CE4C4 = __xadd(g_t80CE4C4, edi_158);
				edx_103.u0 = 1224;
				do
				{
					Eq_2 eax_174 = g_t80CE4C8;
					if (edi_158 * 0x02 <= eax_174)
						break;
					__lock();
					word32 eax_178;
				} while (__cmpxchg(g_t80CE4C8, edi_158 * 0x02, eax_174, out eax_178));
l08059539:
				ecxOut = ecx_111;
				edxOut = edx_103;
				return ecx_111;
			}
l08059590:
			word32 eax_272;
			word32 ecx_273;
			__malloc_assert(134883651, 2878, 0x080A2925, out eax_272, out ecx_273, out edx_103);
l080595B0:
			ecx_111.u0 = 0x00;
			goto l08059539;
		}
	}
	else
	{
		word32 ecx_269;
		__malloc_assert(134883630, 0x0B26, 0x080A2925, out eax, out ecx_269, out edx_225);
	}
	ecxOut = eax;
	edxOut = edx_225;
	return eax;
}

// 080595C0: Register ptr32 ptmalloc_init(Register (ptr32 Eq_9) gs)
// Called from:
//      malloc_hook_ini
//      memalign_hook_ini
//      realloc_hook_ini
//      __valloc
//      __pvalloc
//      malloc_trim
//      mallinfo
//      __malloc_stats
//      __mallopt
//      malloc_info
ptr32 ptmalloc_init(struct Eq_9 * gs)
{
	Eq_2175 eax_14 = gs->t0014;
	if (__libc_malloc_initialized < 0x00)
	{
		__libc_malloc_initialized = 0x00;
		gs->tFFFFFFEC.u0 = 0x080CE500;
		struct Eq_28484 * eax_26 = &g_t80CE538;
		do
		{
			eax_26->dw000C = eax_26;
			eax_26[1] = (struct Eq_28484) eax_26;
			++eax_26;
		} while (eax_26 != &g_t80CE930);
		g_t80CE538.u0 = 0x080CE538;
		global_max_fast.u0 = 0x40;
		g_dw80CE508 = 0x00;
		__tunable_get_val(0x17, fp - 0x14, &g_t8059BF0);
		__tunable_get_val(0x09, fp - 0x14, &g_t8058C50);
		__tunable_get_val(0x03, fp - 0x14, &g_t8058CF0);
		__tunable_get_val(0x12, fp - 0x14, &g_t8058C80);
		__tunable_get_val(0x02, fp - 0x14, &g_t8058C20);
		__tunable_get_val(0x0A, fp - 0x14, &g_t8058CC0);
		__tunable_get_val(0x11, fp - 0x14, &g_t80587A0);
		__tunable_get_val(0x14, fp - 0x14, &g_t80587C0);
		__tunable_get_val(22, fp - 0x14, &g_t80587E0);
		__tunable_get_val(0x13, fp - 0x14, &g_t8058820);
		__tunable_get_val(0x0C, fp - 0x14, &g_t8058850);
		__libc_malloc_initialized = 0x01;
	}
	if ((eax_14 ^ gs->t0014) == 0x00)
		return ebx;
	word32 ecx_314;
	word32 edx_315;
	__stack_chk_fail(out ecx_314, out edx_315);
	word32 ebx_317;
	word32 esi_318;
	word32 edi_319;
	arena_get2.part.5(eax, edx_240, gs, out ebx_317, out esi_318, out edi_319);
	return 0x080CE000;
}

// 08059730: Register Eq_2 arena_get2.part.5(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_28583 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      ptmalloc_init
//      arena_get_retry
//      tcache_init.part.6
//      __libc_malloc
//      _mid_memalign
//      __libc_calloc
Eq_2 arena_get2.part.5(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_28583 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_2 edi_13 = eax;
	uint32 eax_23 = narenas_limit.12605;
	Eq_2 edx_24 = narenas;
	if (eax_23 == 0x00)
	{
		eax_23 = g_dw80CE4B0;
		if (eax_23 == 0x00)
			goto l080598A0;
		narenas_limit.12605 = eax_23;
	}
l0805976A:
	while (true)
	{
		Eq_2 esi_318;
		if (eax_23 - 0x01 < edx_24)
			break;
		Eq_2 ecx_38 = (word32) edx_24 + 1;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 eax_49;
		__cmpxchg(narenas, ecx_38, edx_24, out eax_49);
		if (eax_49 == edx_24)
		{
			word32 edx_794;
			word32 ecx_793;
			Eq_2 eax_59 = new_heap((byte) edi_13.u0 + 0x0484, g_dw80CE4A4, gs, out ecx_793, out edx_794);
			Eq_2 edx_66 = eax_59;
			if (eax_59 == 0x00)
			{
				word32 ecx_795;
				word32 edx_796;
				Eq_2 eax_72 = new_heap(0x0484, g_dw80CE4A4, gs, out ecx_795, out edx_796);
				edx_66 = eax_72;
				if (eax_72 == 0x00)
				{
l08059B03:
					if (gs->t000C != 0x00)
						__lock();
					--narenas;
					esi_318.u0 = 0x00;
					goto l08059868;
				}
			}
			Eq_2 esi_84 = (word32) edx_66 + 24;
			*edx_66 = esi_84;
			struct Eq_28718 * eax_85 = (word32) edx_66 + 80;
			struct Eq_28718 * ecx_87 = (word32) edx_66 + 0x0448;
			esi_318 = esi_84;
			do
			{
				eax_85->dw000C = eax_85;
				eax_85[1] = (struct Eq_28718) eax_85;
				++eax_85;
			} while (ecx_87 != eax_85);
			if (esi_84 != 0x080CE500)
				*((word32) edx_66 + 28) |= 0x02;
			else
				global_max_fast.u0 = 0x40;
			Eq_2 eax_110 = *((word32) edx_66 + 8);
			((word32) edx_66 + 32)->u0 = 0x00;
			*((word32) edx_66 + 1128) = 0x01;
			*((word32) edx_66 + 1136) = eax_110;
			*((word32) edx_66 + 1132) = eax_110;
			Eq_28773 ebp_111 = (word32) edx_66 + 1148;
			Eq_2 ecx_113 = (word32) edx_66 + 0x0474;
			if ((ebp_111 & 0x0F) != 0x00)
				ecx_113 = ecx_113 - (ebp_111 & 0x0F) + 0x10;
			*((word32) edx_66 + 80) = ecx_113;
			Mem131[ecx_113 + 0x04:word32] = eax_110 + edx_66 - ecx_113 | 0x01;
			Eq_2 ecx_139 = gs->tFFFFFFEC;
			gs->tFFFFFFEC = esi_84;
			((word32) edx_66 + 24)->u0 = 0x00;
			Eq_2 ecx_147 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_161;
			if (!__cmpxchg(list_lock, 0x01, 0x00, out eax_161))
				ecx_147 = __lll_lock_wait_private(eax_161, 0x080CF880, gs);
			*((word32) edx_66 + 1120) = g_t80CE948;
			g_t80CE948 = esi_84;
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v18_185 = list_lock - 0x01;
			list_lock = v18_185;
			if (v18_185 != 0x00)
				__lll_unlock_wake_private(0x080CF880, ecx_147, edx_66, gs);
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_214;
			if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_214))
				__lll_lock_wait_private(eax_214, 0x080CF888, gs);
			Eq_2 edx_256;
			Eq_2 ecx_258 = detach_arena(ecx_139, out edx_256);
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v20_265 = free_list_lock - 0x01;
			free_list_lock = v20_265;
			if (v20_265 != 0x00)
				__lll_unlock_wake_private(0x080CF888, ecx_258, edx_256, gs);
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_290;
			if (!__cmpxchg(*esi_84, 0x01, 0x00, out eax_290))
				__lll_lock_wait_private(eax_290, esi_84, gs);
			if (esi_84 != 0x00)
				goto l08059868;
			goto l08059B03;
		}
		edx_24 = narenas;
		eax_23 = narenas_limit.12605;
	}
	esi_318 = next_to_use.12583;
	if (esi_318 == 0x00)
	{
		next_to_use.12583.u0 = 0x080CE500;
		esi_318.u0 = 0x080CE500;
	}
	do
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_345;
		__cmpxchg(*esi_318.u0, 0x01, 0x00, out eax_345);
		if (eax_345 == 0x00)
			goto l080597B8;
		esi_318 = *((byte) esi_318.u0 + 0x0448);
		Eq_2 edx_353 = next_to_use.12583;
	} while (esi_318 != edx_353);
	if (edx == edx_353)
		edx_353 = *((word32) edx + 0x0448);
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_375;
	if (!__cmpxchg(*edx_353, 0x01, 0x00, out eax_375))
		__lll_lock_wait_private(eax_375, edx_353, gs);
	esi_318 = edx_353;
l080597B8:
	edi_13.u0 = ~0x13;
	Eq_2 edx_394 = gs->tFFFFFFEC;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_405;
	if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_405))
		__lll_lock_wait_private(eax_405, 0x080CF888, gs);
	Eq_2 edx_448;
	Eq_2 ecx_450 = detach_arena(edx_394, out edx_448);
	Eq_2 eax_453 = free_list;
	if (eax_453 == 0x00)
	{
l08059832:
		*((byte) esi_318.u0 + 1104) = (word32) *((byte) esi_318.u0 + 1104) + 1;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v17_553 = free_list_lock - 0x01;
		free_list_lock = v17_553;
		if (v17_553 != 0x00)
			__lll_unlock_wake_private(0x080CF888, ecx_450, edx_448, gs);
		gs->tFFFFFFEC = esi_318;
		next_to_use.12583 = *((byte) esi_318.u0 + 0x0448);
l08059868:
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return esi_318;
	}
	if (*((word32) eax_453 + 1104) == 0x00)
	{
		if (esi_318 != eax_453)
		{
			edx_448 = *((word32) eax_453 + 0x044C);
			while (edx_448 != 0x00)
			{
				ecx_450 = *((byte) edx_448.u0 + 1104);
				if (ecx_450 != 0x00)
					goto l08059878;
				if (esi_318 == edx_448)
				{
					edx_448 = (word32) eax_453 + 0x044C;
					eax_453 = esi_318;
					goto l08059958;
				}
				eax_453 = edx_448;
				edx_448 = *((word32) edx_448 + 0x044C);
			}
		}
		else
		{
			edx_448.u0 = 0x080CF884;
l08059958:
			*edx_448 = *((word32) eax_453 + 0x044C);
		}
		goto l08059832;
	}
l08059878:
	word32 ecx_797;
	__malloc_assert(0x080A2976, 0x031B, 0x080A28A8, out eax_23, out ecx_797, out edx_24);
l080598A0:
	if (g_t80CE4AC < edx_24)
	{
		int32 eax_511 = get_nprocs(gs);
		if (eax_511 > 0x00)
		{
			edx_24 = narenas;
			narenas_limit.12605 = eax_511 * 0x02;
			eax_23 = eax_511 * 0x02;
		}
		else
		{
			narenas_limit.12605 = 0x04;
			edx_24 = narenas;
			eax_23 = 0x04;
		}
	}
	goto l0805976A;
}

// 08059B50: Register Eq_2 arena_get_retry(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      tcache_init.part.6
//      __libc_malloc
//      _mid_memalign
//      __libc_calloc
Eq_2 arena_get_retry(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 eax_110;
	if (eax == 0x080CE500)
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v11_27 = g_t80CE500 - 0x01;
		g_t80CE500 = v11_27;
		if (v11_27 != 0x00)
			__lll_unlock_wake_private(0x080CE500, ecx, edx, gs);
		word32 edi_196;
		word32 esi_195;
		word32 ebx_194;
		word32 edx_193;
		word32 ecx_192;
		eax_110 = get_free_list(gs, out ecx_192, out edx_193, out ebx_194, out esi_195, out edi_196);
		if (eax_110 != 0x00)
			return eax_110;
		word32 ebx_197;
		word32 esi_198;
		word32 edi_199;
		return arena_get2.part.5(edx, eax, gs, out ebx_197, out esi_198, out edi_199);
	}
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 v12_75 = *eax - 0x01;
		*eax = v12_75;
		if (v12_75 != 0x00)
			__lll_unlock_wake_private(eax, ecx, edx, gs);
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_96;
		if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_96))
			__lll_lock_wait_private(eax_96, 0x080CE500, gs);
		eax_110.u0 = 0x080CE500;
		return eax_110;
	}
}

// 08059BF0: void _dl_tunable_set_mallopt_check(Stack (ptr32 word32) dwArg04)
void _dl_tunable_set_mallopt_check(word32 * dwArg04)
{
	if (*dwArg04 != 0x00)
	{
		using_malloc_checking = 0x01;
		__malloc_hook = &g_t805C510;
		__free_hook.u0 = 0x0805CAB0;
		__realloc_hook = &g_t805CE40;
		__memalign_hook = &g_t805C8C0;
	}
}

// 08059C50: void __malloc_info.part.10(Register (ptr32 Eq_9) gs)
// Called from:
//      malloc_info
void __malloc_info.part.10(struct Eq_9 * gs)
{
	Eq_2175 eax_24 = gs->t0014;
	Eq_2 dwLoc091C_1121 = 0x080CE500;
	do
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		word32 ebx_1359;
		word32 edi_1360;
		__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1359, out edi_1360);
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_74;
		if (!__cmpxchg(*dwLoc091C_1121, 0x01, 0x00, out eax_74))
			__lll_lock_wait_private(eax_74, dwLoc091C_1121, gs);
		struct Eq_29186 * ecx_102 = fp - 0x08C0;
		word32 * ebx_146 = (word32) dwLoc091C_1121 + 0x0C;
		do
		{
			int32 edx_104;
			struct Eq_29194 * eax_115 = *ebx_146;
			if (eax_115 != null)
			{
				ui32 esi_109 = eax_115->dw0004;
				edx_104 = 0x00;
				do
				{
					eax_115 = eax_115->ptr0008;
					++edx_104;
				} while (eax_115 != null);
				ecx_102->dw0004 = esi_109 & ~0x07;
				ecx_102->dw000C = edx_104;
				ecx_102->dw0000 = (esi_109 & ~0x07) - 0x0F;
			}
			else
			{
				ecx_102->dw000C = 0x00;
				ecx_102->dw0004 = 0x00;
				ecx_102->dw0000 = 0x00;
				edx_104 = 0x00;
			}
			++ecx_102;
			ecx_102->dwFFFFFFF8 = edx_104 *s ecx_102->dw0004;
			++ebx_146;
		} while (ecx_102 != fp - 0x0810);
		struct Eq_29240 * esi_155 = fp - 0x0810;
		Eq_2 dwLoc0930_633 = (word32) dwLoc091C_1121 + 56;
		do
		{
			esi_155->dw0000 = ~0x00;
			esi_155->dw000C = 0x00;
			Eq_2 edx_172 = *((word32) dwLoc0930_633 + 8);
			esi_155->dw0008 = 0x00;
			esi_155->dw0004 = 0x00;
			if (edx_172 != 0x00 && edx_172 != dwLoc0930_633)
			{
				word32 edi_181 = 0x01;
				Eq_2 ecx_182 = 0x00;
				Eq_2 ebx_183 = ~0x00;
				word32 ebp_184 = 0x00;
				while (true)
				{
					Eq_2 eax_190 = *((word32) edx_172 + 4);
					edx_172 = *((word32) edx_172 + 8);
					ebp_184 = (word32) eax_190 + ebp_184;
					if (ebx_183 > eax_190)
						ebx_183 = eax_190;
					if (ecx_182 < eax_190)
						ecx_182 = eax_190;
					word32 eax_207 = edi_181 + 0x01;
					if (edx_172 == dwLoc0930_633)
						break;
					edi_181 = eax_207;
				}
				esi_155->dw000C = edi_181;
				esi_155->dw0008 = ebp_184;
				esi_155->dw0000 = (word32) ebx_183;
				esi_155->dw0004 = (word32) ecx_182;
				if (edi_181 == 0x00)
					goto l08059DE8;
			}
			else
			{
l08059DE8:
				esi_155->dw0000 = 0x00;
			}
			++esi_155;
			dwLoc0930_633 = (word32) dwLoc0930_633 + 8;
		} while (esi_155 != fp - 0x20);
		if (dwLoc091C_1121 != 0x080CE500)
		{
			edx_172.u0 = 0x00;
			struct Eq_29446 * eax_259 = *((word32) dwLoc091C_1121 + 56) & 0xFFF00000;
			do
			{
				edx_172 = (byte) edx_172.u0 + eax_259->dw000C;
				eax_259 = eax_259->ptr0004;
			} while (eax_259 != null);
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v21_302 = *dwLoc091C_1121 - 0x01;
		*dwLoc091C_1121 = v21_302;
		if (v21_302 != 0x00)
			__lll_unlock_wake_private(dwLoc091C_1121, dwLoc091C_1121, edx_172, gs);
		struct Eq_29336 * ebp_332 = fp - 0x08C0 + 0x0C;
		word32 ebx_341;
		for (ebx_341 = 0x00; ebx_341 != 0x8A; ++ebx_341)
		{
			word32 eax_347 = ebp_332->dw0000;
			if (ebx_341 != 11 && eax_347 != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				word32 ebx_1363;
				word32 edi_1364;
				__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1363, out edi_1364);
			}
			++ebp_332;
		}
		if (dwLoc0804 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 ebx_1389;
			word32 edi_1390;
			__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1389, out edi_1390);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		word32 edi_1368;
		word32 ebx_1367;
		__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1367, out edi_1368);
		if (dwLoc091C_1121 != 0x080CE500)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 edi_1372;
			word32 ebx_1371;
			__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1371, out edi_1372);
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 ebx_1385;
			word32 edi_1386;
			__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1385, out edi_1386);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		fputs(gs, stackArg4, stackArg8);
		Eq_2 ecx_500 = *((word32) dwLoc091C_1121 + 0x0448);
		dwLoc091C_1121 = ecx_500;
	} while (ecx_500 != 0x080CE500);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	word32 ebx_1377;
	word32 edi_1378;
	__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1377, out edi_1378);
	if ((eax_24 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_1379;
	word32 edx_1380;
	Eq_2 eax_555 = __stack_chk_fail(out ecx_1379, out edx_1380);
	word32 edx_1382;
	word32 ecx_1381;
	systrim.isra.1.constprop.11(eax_555, out ecx_1381, out edx_1382);
}

// 0805A100: Register Eq_2 systrim.isra.1.constprop.11(Register Eq_2 eax, Register out Eq_29424 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _int_free
//      malloc_trim
//      malloc_info
Eq_2 systrim.isra.1.constprop.11(Eq_2 eax, union Eq_29424 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 eax_100;
	Eq_2 ebx_20 = *((word32) g_t80CE538 + 4);
	Eq_2 edx_141 = (ebx_20 & ~0x07) - 0x11;
	if (edx_141 > eax)
	{
		edx_141 -= eax;
		ecx = -_dl_pagesize;
		ui32 edi_31 = ecx & edx_141;
		if (edi_31 != 0x00)
		{
			word32 eax_40;
			__morecore();
			if (eax_40 == (word32) g_t80CE538 + (ebx_20 & ~0x07))
			{
				ui32 eax_52 = -edi_31;
				word32 ecx_58;
				__morecore();
				<anonymous> * eax_60 = __after_morecore_hook;
				if (eax_60 != null)
				{
					word32 ecx_67;
					eax_60();
				}
				word32 eax_81;
				__morecore();
				if (eax_81 != 0x00)
				{
					ui32 ebp_88 = eax_40 - eax_81;
					if (ebp_88 != 0x00)
					{
						Eq_2 eax_91 = g_t80CE538;
						g_dw80CE954 -= ebp_88;
						*((word32) eax_91 + 4) = (ebx_20 & ~0x07) - ebp_88 | 0x01;
						eax_100.u0 = 0x01;
l0805A155:
						ecxOut = ecx;
						edxOut = edx_141;
						return eax_100;
					}
				}
			}
		}
	}
	eax_100.u0 = 0x00;
	goto l0805A155;
}

// 0805A1C0: Register Eq_2 _int_free(Register Eq_2 eax, Register Eq_2 edx, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_29547 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out Eq_2 ediOut, Register out (ptr32 Eq_9) gsOut)
// Called from:
//      sysmalloc
//      _int_memalign
//      free_check.part.3
//      _int_realloc
//      free
//      __realloc
Eq_2 _int_free(Eq_2 eax, Eq_2 edx, Eq_2 edi, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_29547 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, union Eq_2 & ediOut, struct Eq_9 & gsOut)
{
	Eq_2175 dwLoc20_1731;
	ptr32 dwLoc04_1936;
	Eq_2 dwLoc08_1868;
	struct Eq_9 * gs_1004;
	Eq_2 ebp_1028;
	Eq_2 ebx_1006;
	Eq_2 eax_1046;
	struct Eq_29559 * edx_1048;
	Eq_2 edx_1068;
	Eq_2 edi_1031;
	Eq_2 esi_1015;
	Eq_2 ecx_1067;
	Eq_2 ecx_1432;
	Eq_2 eax_1431;
	Eq_2 edx_1404;
	Eq_2 ecx_1403;
	Eq_2 eax_511;
	Eq_29547 dwLoc10_1732;
	byte al_528;
	ptr32 dwLoc0C_1800;
	Eq_2 eax_29 = *((word32) edx + 4);
	struct Eq_29576 * esp_100 = fp - 0x4C;
	Eq_2175 eax_26 = gs->t0014;
	byte al_60 = (byte) eax_29;
	if (edx <= -(eax_29 & ~0x07))
	{
		edx_1068 = edx + 0x08 & 0x0F;
		if (edx_1068 == 0x00)
		{
			if ((eax_29 & ~0x07) > 0x0F && (al_60 & 0x08) == 0x00)
			{
				Eq_2 eax_123 = gs->tFFFFFFE4;
				edi_1031 = edi;
				if (eax_123 == 0x00)
				{
l0805A25C:
					dwLoc20_1731 = eax_26;
					dwLoc04_1936 = ebp;
					dwLoc08_1868 = edi;
					dwLoc0C_1800 = esi;
					dwLoc10_1732 = ebx;
					ebp_1028 = eax;
					gs_1004 = gs;
					ebx_1006.u0 = 0x080CE000;
					esi_1015 = eax_29 & ~0x07;
					struct Eq_29623 * eax_160 = esp_100->ptr0000;
					if ((eax_29 & ~0x07) <= global_max_fast)
					{
						edi_1031 = eax_160 + (eax_29 & ~0x07) / 8;
						Eq_2 eax_394 = *((word32) edi_1031 + 4);
						if (eax_394 > 0x08 && (eax_394 & ~0x07) < *((word32) eax + 0x0454))
							goto l0805A289;
l0805A550:
						dwLoc20_1731 = eax_26;
						dwLoc04_1936 = ebp;
						dwLoc08_1868 = edi;
						dwLoc0C_1800 = esi;
						dwLoc10_1732 = ebx;
						ebx_1006.u0 = 0x080CE000;
						ebp_1028 = eax;
						gs_1004 = gs;
						if (esp_100[1] == 0x00)
						{
							Eq_2 eax_408 = esp_100[1];
							if (gs->t000C != 0x00)
								__lock();
							word32 eax_418;
							if (!__cmpxchg(*eax, 0x01, eax_408, out eax_418))
								__lll_lock_wait_private(eax_418, eax, gs);
							Eq_2 eax_432 = *((word32) edi_1031 + 4);
							Eq_2 ecx_433 = 0x01;
							if (eax_432 > 0x08)
								ecx_433 = (uint32) (int8) ((eax_432 & ~0x07) >= *((word32) eax + 0x0454));
							if (gs->t000C != 0x00)
								__lock();
							Eq_2 v26_450 = *eax - 0x01;
							*eax = v26_450;
							if (v26_450 != 0x00)
								__lll_unlock_wake_private(eax, ecx_433, edx_1068, gs);
							if (ecx_433 == 0x00)
							{
l0805A289:
								Eq_2 eax_519 = perturb_byte;
								al_528 = (byte) eax_519;
								if (eax_519 == 0x00)
									goto l0805A297;
								goto l0805A790;
							}
						}
						word32 edx_2112;
						word32 ecx_2111;
						eax_511 = malloc_printerr(out ecx_2111, out edx_2112);
						esi_1015 = eax_29 & ~0x07;
l0805A5B8:
						Eq_2 ecx_756 = eax_511 & ~0x07;
						if (ecx_756 != Mem758[edi_1031 + ecx_756:word32])
							goto l0805A95C;
						Eq_2 ecx_762 = *((word32) edi_1031 + 8);
						edx_1404 = ecx_762;
						Eq_2 ecx_764 = *((word32) edi_1031 + 0x0C);
						if (*((word32) ecx_762 + 0x0C) == edi_1031 && *((word32) ecx_764 + 8) == edi_1031)
						{
							*((word32) ecx_762 + 0x0C) = ecx_764;
							*((word32) ecx_764 + 8) = ecx_762;
							if (eax_511 <= 1007)
								goto l0805A5F0;
							ecx_1403 = *((word32) edi_1031 + 16);
							if (ecx_1403 == 0x00)
							{
l0805A5F0:
								esi_1015 += Mem1469[esp_100 + 0x04:word32];
								goto l0805A451;
							}
l0805AAC4:
							if (*((word32) ecx_1403 + 20) == edi_1031)
							{
								Eq_2 eax_1411 = *((word32) edi_1031 + 20);
								if (*((word32) eax_1411 + 16) == edi_1031)
								{
									if (*((word32) edx_1404 + 16) != 0x00)
									{
										*((word32) ecx_1403 + 20) = eax_1411;
										*((word32) *((word32) edi_1031 + 20) + 16) = ecx_1403;
									}
									else if (ecx_1403 != edi_1031)
									{
										*((word32) edx_1404 + 20) = eax_1411;
										*((word32) edx_1404 + 16) = ecx_1403;
										*((word32) *((word32) edi_1031 + 16) + 20) = edx_1404;
										*((word32) *((word32) edi_1031 + 20) + 16) = edx_1404;
									}
									else
									{
										*((word32) edx_1404 + 20) = edx_1404;
										*((word32) edx_1404 + 16) = edx_1404;
									}
									goto l0805A5F0;
								}
							}
							goto l0805AB6F;
						}
						goto l0805A628;
					}
					ui32 eax_165 = eax_160->dw0004;
					if ((eax_165 & 0x02) != 0x00)
						goto l0805A4F0;
					if (gs->t000C != 0x00 && (esp_100[1] & 0x01) == 0x00)
					{
						if (gs->t000C != 0x00)
							__lock();
						word32 eax_186;
						if (!__cmpxchg(*eax, 0x01, eax_165 & 0x02, out eax_186))
							__lll_lock_wait_private(eax_186, eax, gs);
					}
					else
						esp_100[2] = (struct Eq_29576) 0x01;
					Eq_2 ecx_203 = esp_100->ptr0000;
					Eq_2 eax_207 = *((word32) eax + 56);
					edi_1031 = (word32) ecx_203 + (eax_29 & ~0x07);
					if (eax_207 != ecx_203)
					{
						if ((*((word32) eax + 4) & 0x02) != 0x00)
							goto l0805A345;
					}
					else
					{
						word32 edx_2115;
						word32 ecx_2114;
						eax_207 = malloc_printerr(out ecx_2114, out edx_2115);
					}
					if (edi_1031 >= (word32) eax_207 + (*((word32) eax_207 + 4) & ~0x07))
					{
						word32 ecx_2125;
						word32 edx_2126;
						malloc_printerr(out ecx_2125, out edx_2126);
l0805A860:
						word32 edx_2117;
						word32 ecx_2116;
						malloc_printerr(out ecx_2116, out edx_2117);
						esi_1015 = eax_29 & ~0x07;
l0805A870:
						word32 ebp_2092;
						word32 edi_2093;
						word32 ebx_2091;
						malloc_consolidate(ebp_1028, gs_1004, out ecx_1067, out edx_1068, out ebx_2091, out ebp_2092, out edi_2093);
l0805A4AA:
						if (ebp_1028 == (word32) ebx_1006 + 0x0500)
							goto l0805A8F8;
						edi_1031 = *((word32) ebp_1028 + 56);
						esp_100->ptr0000 = (struct Eq_152086 *) (edi_1031 & 0xFFF00000);
						if (*(edi_1031 & 0xFFF00000) != ebp_1028)
						{
							struct Eq_30273 * esp_1545 = esp_100 - 0x0C;
							esp_1545->ptrFFFFFFFC = (word32) ebx_1006 - 173700;
							word32 edx_2096;
							word32 ecx_2095;
							word32 eax_2094;
							__malloc_assert((word32) ebx_1006 - 177645, 0x1144, (word32) ebx_1006 - 177883, out eax_2094, out ecx_2095, out edx_2096);
							esp_100 = esp_1545 - 4;
l0805A4F0:
							word32 ebx_2113;
							munmap_chunk(esp_100->ptr0000, gs_1004, out ecx_1067, out edx_1068, out ebx_2113);
							goto l0805A2E4;
						}
						edx_1068 = esp_100->ptr0000;
						ecx_1067 = *((word32) ebx_1006 + 0x04A4);
						Eq_2 eax_876 = _dl_pagesize;
						esp_100[6] = (struct Eq_29576) ecx_1067;
						esp_100[4] = (struct Eq_29576) eax_876;
						esi_1015 = eax_876;
						if (edi_1031 == (word32) edx_1068 + 24)
						{
							Eq_2 eax_883 = *((word32) edx_1068 + 4);
							esi_1015 = ecx_1067 + 0x10 + eax_876;
							esp_100[5] = (struct Eq_29576) esi_1015;
							Eq_2 edx_886 = *((word32) eax_883 + 8);
							esp_100[1] = (struct Eq_29576) eax_883;
							esp_100[3] = (struct Eq_29576) edx_886;
							Eq_30571 eax_890 = (word32) eax_883 + (edx_886 - 0x08);
							eax_1046 = eax_890 & 0x0F;
							edx_1048 = (struct Eq_29559 *) (esp_100[1].ptr0000 + ((edx_886 - 0x08) - (eax_890 & 0x0F)) / 24);
							if (edx_1048->dw0004 != 0x01)
								goto l0805A8D4;
l0805A967:
							esp_100[7] = (struct Eq_29576) edi_1031;
l0805A96B:
							esi_1015 = edx_1048 - edx_1048->dw0000;
							Eq_2 ecx_903 = *((word32) esi_1015 + 4);
							uint32 eax_907 = (word32) eax_1046 + (ecx_903 & ~0x07);
							edx_1068 = eax_907 + 0x07;
							if (eax_907 > 0x17)
							{
l0805AAA4:
								struct Eq_30646 * esp_1389 = esp_100 - 0x0C;
								esp_1389->ptrFFFFFFFC = (word32) ebx_1006 - 173712;
								word32 eax_2107;
								__malloc_assert((word32) ebx_1006 - 175768, 0x0267, (word32) ebx_1006 - 178008, out eax_2107, out ecx_1403, out edx_1404);
								esp_100 = esp_1389 - 4;
								goto l0805AAC4;
							}
							ecx_1067 = ecx_903 & 0x01;
							edi_1031 = eax_907 + 0x08;
							if ((ecx_903 & 0x01) == 0x00)
							{
								Eq_2 eax_917 = (word32) *esi_1015 + (eax_907 + 0x08);
								edi_1031 = eax_917;
								if (eax_917 > 0x000FFFFF)
								{
									struct Eq_30694 * esp_925 = esp_100 - 0x0C;
									esp_925->ptrFFFFFFFC = (word32) ebx_1006 - 173712;
									word32 edx_2110;
									word32 eax_2108;
									word32 ecx_2109;
									__malloc_assert((word32) ebx_1006 - 175720, 0x026A, (word32) ebx_1006 - 178008, out eax_2108, out ecx_2109, out edx_2110);
									esp_100 = esp_925 - 4;
									goto l0805A9BD;
								}
							}
l0805A9D3:
							if (edi_1031 - Mem977[esp_100 + 0x0C:word32] + 0x00100000 >=u Mem977[esp_100 + 0x14:word32])
							{
								struct Eq_30299 * ecx_984 = esp_100->ptr0000;
								*((word32) ebp_1028 + 0x0454) -= ecx_984->t0008;
								if (*((word32) ebx_1006 + 6268) == (char *) (&ecx_984->t0008) + 0x000FFFF8)
									*((word32) ebx_1006 + 6268) = 0x00;
								struct Eq_30323 * esp_995 = esp_100 - 0x08;
								esp_995->tFFFFFFFC.u0 = 0x00100000;
								esp_995->tFFFFFFF8 = esp_995->t0008;
								word32 ecx_2097;
								word32 edx_2098;
								__munmap(ebx_1006, gs_1004, esp_995->tFFFFFFF8, esp_995->tFFFFFFFC, out ecx_2097, out edx_2098, out ebx_1006);
								esp_100 = (struct Eq_29576 *) &esp_995->t0008;
								if ((*((word32) esi_1015 + 4) & 0x01) != 0x00)
								{
l0805AA65:
									word32 eax_1107 = esi_1015 + edi_1031;
									if ((eax_1107 & esp_995->dw0018 - 0x01) != 0x00)
									{
										esp_995->tFFFFFFF8 = (word32) ebx_1006 - 173712;
										word32 eax_2100;
										word32 ecx_2101;
										word32 edx_2102;
										__malloc_assert((word32) ebx_1006 - 175676, 0x0276, (word32) ebx_1006 - 178008, out eax_2100, out ecx_2101, out edx_2102);
										esp_100 = esp_995 - 0x08;
										goto l0805AB6F;
									}
									ecx_1067 = esp_995->t000C;
									edx_1068 = Mem1103[ecx_1067 + 0x08:word32] + ecx_1067;
									if (eax_1107 != edx_1068)
									{
										esp_995->tFFFFFFF8 = (word32) ebx_1006 - 173712;
										word32 ecx_2104;
										word32 edx_2105;
										word32 eax_2103;
										__malloc_assert((word32) ebx_1006 - 175612, 0x0277, (word32) ebx_1006 - 178008, out eax_2103, out ecx_2104, out edx_2105);
										esp_100 = esp_995 - 0x08;
										goto l0805AAA4;
									}
									*((word32) ebp_1028 + 56) = esi_1015;
									*((word32) esi_1015 + 4) = edi_1031 | 0x01;
									if (esi_1015 == (word32) esp_995->t000C + 24)
									{
										edi_1031 = esp_995->t000C;
										esp_995->t0024 = esi_1015;
										Eq_2 ecx_1362 = *((word32) edi_1031 + 4);
										esp_995->t0008 = edi_1031;
										Eq_2 eax_1364 = *((word32) ecx_1362 + 8);
										esp_995->t0014 = eax_1364;
										Eq_30771 eax_1367 = (word32) ecx_1362 + (eax_1364 - 0x08);
										eax_1046 = eax_1367 & 0x0F;
										edx_1048 = (word32) ecx_1362 + ((eax_1364 - 0x08) - (eax_1367 & 0x0F));
										if (edx_1048->dw0004 != 0x01)
										{
l0805A8D4:
											struct Eq_30592 * esp_1475 = esp_100 - 0x0C;
											esp_1475->ptrFFFFFFFC = (word32) ebx_1006 - 173712;
											word32 eax_2106;
											__malloc_assert((word32) ebx_1006 - 175812, 0x0264, (word32) ebx_1006 - 178008, out eax_2106, out ecx_1067, out edx_1068);
											esp_100 = esp_1475 - 4;
l0805A8F8:
											if ((*((word32) *((word32) ebx_1006 + 1336) + 4) & ~0x07) >= *((word32) ebx_1006 + 1184))
												systrim.isra.1.constprop.11(*((word32) ebx_1006 + 0x04A4), out ecx_1067, out edx_1068);
											goto l0805A6C8;
										}
										esp_995->t000C = ecx_1362;
										goto l0805A96B;
									}
									esp_995->t0008 = esp_995->t000C;
									edi_1031 = esi_1015;
									goto l0805A637;
								}
								esi_1015 -= *esi_1015;
								Eq_2 ecx_1020 = *((word32) esi_1015 + 4);
								if ((ecx_1020 & ~0x07) == Mem1001[esi_1015 + (ecx_1020 & ~0x07):word32])
								{
									Eq_2 eax_1050 = *((word32) esi_1015 + 8);
									Eq_2 edx_1051 = *((word32) esi_1015 + 0x0C);
									if (esi_1015 == *((word32) eax_1050 + 0x0C) && esi_1015 == *((word32) edx_1051 + 8))
									{
										*((word32) eax_1050 + 0x0C) = edx_1051;
										*((word32) edx_1051 + 8) = eax_1050;
										if (ecx_1020 <= 1007)
											goto l0805AA65;
										Eq_2 edx_1078 = *((word32) esi_1015 + 16);
										if (edx_1078 == 0x00)
											goto l0805AA65;
										if (esi_1015 != *((word32) edx_1078 + 20))
											goto l0805AB6F;
										Eq_2 ecx_1084 = *((word32) esi_1015 + 20);
										if (esi_1015 == *((word32) ecx_1084 + 16))
										{
											if (*((word32) eax_1050 + 16) != 0x00)
											{
												*((word32) edx_1078 + 20) = ecx_1084;
												*((word32) *((word32) esi_1015 + 20) + 16) = edx_1078;
											}
											else if (esi_1015 != edx_1078)
											{
												*((word32) eax_1050 + 16) = edx_1078;
												Eq_2 edx_1094 = *((word32) esi_1015 + 16);
												*((word32) eax_1050 + 20) = ecx_1084;
												*((word32) edx_1094 + 20) = eax_1050;
												*((word32) *((word32) esi_1015 + 20) + 16) = eax_1050;
											}
											else
											{
												*((word32) eax_1050 + 20) = eax_1050;
												*((word32) eax_1050 + 16) = eax_1050;
											}
											goto l0805AA65;
										}
										goto l0805AB6F;
									}
									goto l0805A628;
								}
l0805A95C:
								word32 ecx_2099;
								eax_1046 = malloc_printerr(out ecx_2099, out edx_1048);
								goto l0805A967;
							}
							goto l0805A633;
						}
						goto l0805A637;
					}
l0805A345:
					Eq_2 eax_264 = *((word32) edi_1031 + 4);
					esi_1015 = eax_29 & ~0x07;
					if (((byte) eax_264 & 0x01) != 0x00)
					{
						esp_100[1] = (struct Eq_29576) (eax_264 & ~0x07);
						edx_1068 = eax_264 & ~0x07;
						if (eax_264 > 0x08 && *((word32) eax + 0x0454) > (eax_264 & ~0x07))
						{
							Eq_2 eax_314 = perturb_byte;
							if (eax_314 != 0x00)
							{
								struct Eq_31074 * esp_318 = esp_100 - 0x04;
								esp_318->tFFFFFFFC = (eax_29 & ~0x07) - 0x08;
								esp_318->tFFFFFFF8 = eax_314;
								esp_318->tFFFFFFF4 = esp_318->t0010;
								word32 ecx_2120;
								memset(esp_318->tFFFFFFF4, esp_318->tFFFFFFF8, esp_318->tFFFFFFFC, out ecx_2120, out edx_1068);
							}
							struct Eq_31106 * ecx_340 = esp_100->ptr0000;
							if ((ecx_340->b0004 & 0x01) != 0x00)
								goto l0805A430;
							ui32 eax_344 = ecx_340->dw0000;
							struct Eq_31121 * ecx_345 = ecx_340 - eax_344;
							esp_100->ptr0000 = (struct Eq_152086 *) ecx_345;
							Eq_31126 ecx_349 = ecx_345->t0004;
							esp_100[3] = (struct Eq_29576) ecx_349;
							esi_1015 = (eax_29 & ~0x07) + eax_344;
							if ((ecx_349 & ~0x07) != eax_344)
							{
l0805A9BD:
								word32 ecx_2121;
								word32 edx_2122;
								malloc_printerr(out ecx_2121, out edx_2122);
								goto l0805A9C8;
							}
							if ((ecx_349 & ~0x07) != (esp_100->ptr0000)[(ecx_349 & ~0x07) / 24])
								goto l0805A95C;
							Eq_2 eax_357 = esp_100->ptr0000;
							ecx_1432 = *((word32) eax_357 + 8);
							edx_1068 = *((word32) eax_357 + 0x0C);
							if (*((word32) ecx_1432 + 0x0C) == eax_357 && *((word32) edx_1068 + 8) == esp_100->ptr0000)
							{
								Eq_31173 eax_365 = esp_100[3];
								*((word32) ecx_1432 + 0x0C) = edx_1068;
								*((word32) edx_1068 + 8) = ecx_1432;
								if (eax_365 > 1007)
								{
									Eq_2 eax_371 = esp_100->ptr0000->t0010;
									esp_100[3] = (struct Eq_29576) eax_371;
									if (eax_371 != 0x00)
									{
										if (*((word32) eax_371 + 20) != esp_100->ptr0000)
											goto l0805AB6F;
										eax_1431 = esp_100->ptr0000;
										edx_1068 = *((word32) eax_1431 + 20);
										if (*((word32) edx_1068 + 16) != eax_1431)
										{
l0805AB6F:
											eax_1431 = malloc_printerr(out ecx_1432, out edx_1068);
											goto l0805AB7A;
										}
										if (*((word32) ecx_1432 + 16) == 0x00)
										{
l0805AB7A:
											if (esp_100[3] != eax_1431)
											{
												*((word32) ecx_1432 + 20) = edx_1068;
												edx_1068 = esp_100->ptr0000;
												*((word32) ecx_1432 + 16) = esp_100[3];
												*((word32) *((word32) edx_1068 + 16) + 20) = ecx_1432;
												*((word32) *((word32) edx_1068 + 20) + 16) = ecx_1432;
												goto l0805A430;
											}
											goto l0805ABC9;
										}
										*esp_100[3].dw0014 = (struct Eq_29576) edx_1068;
										*((word32) esp_100->ptr0000->t0014 + 16) = esp_100[3];
									}
								}
								goto l0805A430;
							}
l0805A628:
							malloc_printerr(out ecx_1067, out edx_1068);
l0805A633:
							edi_1031 = esp_100[7];
l0805A637:
							Eq_2 eax_1146 = *((word32) edi_1031 + 4);
							esp_100[3] = (struct Eq_29576) (eax_1146 & ~0x07);
							if (*((word32) ebx_1006 + 1184) <= (eax_1146 & ~0x07))
							{
								Eq_2 eax_1154 = (eax_1146 & ~0x07) - 0x11;
								if (eax_1154 < 0x00)
									goto l0805A6C8;
								esi_1015 = esp_100[6];
								if (esi_1015 < eax_1154)
								{
									edx_1068 = eax_1154 - esi_1015 & -esp_100[4];
									esp_100[1] = (struct Eq_29576) edx_1068;
									word24 edx_24_8_1312 = SLICE(edx_1068, word24, 8);
									if (edx_1068 == 0x00)
										goto l0805A6C8;
									Eq_2 esi_1170 = esp_100->ptr0000->t0008;
									esp_100[4] = (struct Eq_29576) esi_1170;
									esi_1015 = esi_1170 - edx_1068;
									if (esi_1015 > 0x17)
									{
										word32 edx_2071;
										if (*((byte) ebx_1006.u0 + 1152) >= 0x00)
											edx_2071 = SEQ(edx_24_8_1312, (int8) (*((byte) ebx_1006.u0 + 1152) != 0x00));
										else
										{
											Eq_4846 edx_1178 = *(union Eq_4846 *) 0x080CDDAC;
											*((byte) ebx_1006.u0 + 1152) = edx_1178;
											esp_100[5] = (struct Eq_29576) edx_1178;
											word24 edx_24_8_1313 = SLICE(edx_1178, word24, 8);
											if (edx_1178 == 0x00)
											{
												struct Eq_30125 * esp_1184 = esp_100 - 4;
												esp_1184->t0000.u0 = 0x080CDDAC;
												esp_1184->tFFFFFFFC.u0 = 0x080CDDAC;
												esp_1184->tFFFFFFF8.u0 = 0x00080000;
												esp_1184->tFFFFFFF4 = (word32) ebx_1006 - 175556;
												word32 edx_1198;
												word32 ecx_2089;
												Eq_2 eax_1196 = __open_nocancel(gs_1004, esp_1184->tFFFFFFF4, esp_1184->tFFFFFFF8, esp_1184->tFFFFFFFC, out ecx_2089, out edx_1198);
												edx_24_8_1313 = SLICE(edx_1198, word24, 8);
												ecx_1067 = eax_1196;
												if (eax_1196 >= 0x00)
												{
													esp_1184->t0000 = eax_1196;
													esp_1184->tFFFFFFFC.u0 = 0x01;
													esp_1184->tFFFFFFF8 = &esp_1184->b002F;
													esp_1184->tFFFFFFF4 = eax_1196;
													esp_1184->t0014 = eax_1196;
													word32 ecx_2090;
													Eq_2 eax_1218 = __read_nocancel(gs_1004, esp_1184->tFFFFFFF4, esp_1184->tFFFFFFF8, esp_1184->tFFFFFFFC, out ecx_2090);
													ecx_1067 = esp_1184->t0014;
													Eq_4846 edx_1227 = esp_1184->t0018;
													if (eax_1218 > 0x00)
														edx_1227.u1 = (uint32) (int8) (esp_1184->b002F == 0x32);
													*((word32) ebx_1006 + 1152) = edx_1227;
													esp_1184->tFFFFFFF4 = ecx_1067;
													word32 edx_1247;
													__close_nocancel(gs_1004, esp_1184->tFFFFFFF4, out edx_1247);
													edx_24_8_1313 = SLICE(edx_1247, word24, 8);
												}
											}
											edx_2071 = SEQ(edx_24_8_1313, (int8) (*((word32) ebx_1006 + 1152) != 0x00));
										}
										word32 eax_1268 = Mem1263[esp_100 + 0x00:word32] + esi_1015;
										if ((byte) edx_2071 == 0x00)
										{
											struct Eq_29958 * esp_1310 = esp_100 - 4;
											esp_1310->dw0000 = edx_2071;
											esp_1310->dwFFFFFFFC = 0x04;
											esp_1310->dwFFFFFFF8 = esp_1310->dw0008;
											esp_1310->tFFFFFFF4 = eax_1268;
											ecx_1067 = __madvise(gs_1004, esp_1310->tFFFFFFF4, esp_1310->dwFFFFFFF8, esp_1310->dwFFFFFFFC, out edx_1068);
										}
										else
										{
											struct Eq_29897 * esp_1273 = esp_100 - 4;
											esp_1273->t0000 = ecx_1067;
											esp_1273->tFFFFFFFC = ecx_1067;
											esp_1273->tFFFFFFF8.u0 = 0x00;
											esp_1273->tFFFFFFF4.u0 = ~0x00;
											esp_1273->tFFFFFFF0.u0 = 0x32;
											esp_1273->tFFFFFFEC.u0 = 0x00;
											esp_1273->tFFFFFFE8 = esp_1273->t0008;
											esp_1273->tFFFFFFE4 = eax_1268;
											esp_100 = (struct Eq_29576 *) &esp_1273->ptr0004;
											if (mmap(gs_1004, esp_1273->tFFFFFFE4, esp_1273->tFFFFFFE8, esp_1273->tFFFFFFEC, esp_1273->tFFFFFFF0, esp_1273->tFFFFFFF4, esp_1273->tFFFFFFF8, out ecx_1067, out edx_1068) == 0x01)
												goto l0805A6C8;
											esp_1273->ptr0004->t000C = esi_1015;
										}
										esp_100->ptr0000->t0008 = esi_1015;
										ebx_1006 = esp_100[1];
										ui32 eax_1341 = esp_100[3];
										*((word32) ebp_1028 + 0x0454) -= ebx_1006;
										*((word32) edi_1031 + 4) = eax_1341 - ebx_1006 | 0x01;
									}
								}
							}
l0805A6C8:
							if (esp_100[2] == 0x00)
							{
								if (gs_1004->t000C != 0x00)
									__lock();
								Eq_2 v25_1524 = *ebp_1028 - 0x01;
								*ebp_1028 = v25_1524;
								if (v25_1524 != 0x00)
									__lll_unlock_wake_private(ebp_1028, ecx_1067, edx_1068, gs_1004);
							}
							goto l0805A2E4;
						}
						word32 ecx_2118;
						word32 edx_2119;
						al_528 = (byte) malloc_printerr(out ecx_2118, out edx_2119);
l0805A790:
						word32 * edx_527 = esp_100[3];
						int32 eax_531 = (word32) al_528;
						*edx_527 = (word32) (eax_531 *s 0x01010101);
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(edx_527 - 0x0C)[(eax_29 & ~0x07) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = eax_531 *s 0x01010101;
						word32 edi_537 = edx_527 + 0x04 & ~0x03;
						edx_1068 = edx_527 - edi_537;
						uint32 ecx_542;
						for (ecx_542 = (word32) edx_1068 + ((eax_29 & ~0x07) - 0x08) >> 0x02; ecx_542 != 0x00; --ecx_542)
						{
							*edi_537 = eax_531 *s 0x01010101;
							edi_537 += 4;
						}
l0805A297:
						((word32) eax + 8)->u0 = 0x01;
						edi_1031 = (eax_29 & ~0x07) >> 0x03;
						struct Eq_29741 * eax_559 = (word32) eax + edi_1031 * 0x04;
						dwLoc20_1731 = eax_26;
						dwLoc04_1936 = ebp;
						dwLoc08_1868 = edi;
						dwLoc0C_1800 = esi;
						dwLoc10_1732 = ebx;
						ebx_1006.u0 = 0x080CE000;
						gs_1004 = gs;
						ebp_1028 = eax;
						ecx_1067 = eax_559->t0004;
						esi_1015 = gs->t000C;
						if (esi_1015 == 0x00)
						{
							if (esp_100->ptr0000 != ecx_1067)
							{
								esi_1015 = esp_100->ptr0000;
								*((word32) esi_1015 + 8) = ecx_1067;
								eax_559->t0004 = esi_1015;
								goto l0805A2CB;
							}
						}
						else
						{
							esi_1015 = esp_100->ptr0000;
							if (esi_1015 != ecx_1067)
							{
								*((word32) esi_1015 + 8) = ecx_1067;
								ebp_1028 = (word32) eax + 4 + edi_1031 * 0x04;
								if (gs->t000C != 0x00)
									__lock();
								Eq_2 eax_583;
								__cmpxchg(*ebp_1028, esi_1015, ecx_1067, out eax_583);
								esi_1015 = eax_583;
								edx_1068 = esp_100->ptr0000;
								if (eax_583 == ecx_1067)
								{
l0805A2CB:
									if (ecx_1067 != 0x00 && ((esp_100[1] & 0x01) != 0x00 && edi_1031 != *((word32) ecx_1067 + 4) >> 0x03))
									{
										word32 ecx_2085;
										word32 edx_2086;
										malloc_printerr(out ecx_2085, out edx_2086);
										goto l0805A628;
									}
									goto l0805A2E4;
								}
								while (esi_1015 != edx_1068)
								{
									*((word32) edx_1068 + 8) = esi_1015;
									if (gs->t000C != 0x00)
										__lock();
									Eq_2 eax_605;
									__cmpxchg(*ebp_1028, edx_1068, esi_1015, out eax_605);
									ecx_1067 = eax_605;
									if (esi_1015 == eax_605)
										goto l0805A2CB;
									esi_1015 = eax_605;
								}
							}
						}
						word32 ecx_2084;
						malloc_printerr(out ecx_2084, out edx_1068);
						goto l0805A760;
					}
					goto l0805A860;
				}
				edi_1031 = (eax_29 & ~0x07) - 0x01;
				ecx_1067 = edi_1031 >> 0x04;
				if (g_dw80CE4D0 <= edi_1031 >> 0x04)
					goto l0805A25C;
				if (eax_123 != *((word32) edx + 0x0C))
				{
l0805A24A:
					edi_1031 = CONVERT(Mem94[eax_123 + ecx_1067:byte], byte, int32);
					dwLoc20_1731 = eax_26;
					dwLoc04_1936 = ebp;
					dwLoc08_1868 = edi;
					dwLoc0C_1800 = esi;
					dwLoc10_1732 = ebx;
					gs_1004 = gs;
					ebp_1028 = eax;
					edx_1068 = edi_1031;
					if (edi_1031 >= g_t80CE4D8)
						goto l0805A25C;
					if (esp_100[4] <= 0x03FF)
					{
						ebx_1006 = (word32) eax_123 + ecx_1067 * 0x04;
						struct Eq_31273 * edi_148 = esp_100->ptr0000;
						esi_1015 = *((word32) ebx_1006 + 64);
						edi_148->t000C = eax_123;
						edi_148->t0008 = esi_1015;
						edi_1031 = esp_100[3];
						*((word32) ebx_1006 + 64) = edi_1031;
						Mem157[eax_123 + ecx_1067:byte] = SLICE(edi_1031, byte, 0) + 0x01;
						edx_1068 = edi_1031 + 0x01;
l0805A2E4:
						esp_100 = fp - 76;
						Eq_2 eax_686 = dwLoc20_1731 ^ gs_1004->t0014;
						if (eax_686 == 0x00)
						{
							ecxOut = ecx_1067;
							edxOut = edx_1068;
							ebxOut = dwLoc10_1732;
							ebpOut = dwLoc04_1936;
							esiOut = dwLoc0C_1800;
							ediOut = dwLoc08_1868;
							gsOut = gs_1004;
							return eax_686;
						}
						word32 edx_2088;
						word32 ecx_2087;
						__stack_chk_fail(out ecx_2087, out edx_2088);
l0805ABBE:
						malloc_printerr(out ecx_1432, out edx_1068);
l0805ABC9:
						*((word32) ecx_1432 + 20) = ecx_1432;
						*((word32) ecx_1432 + 16) = ecx_1432;
l0805A430:
						if (*((word32) ebp_1028 + 56) != edi_1031)
						{
							eax_511 = *((word32) edi_1031 + 4);
							if ((Mem729[edi_1031 + 0x04 + Mem729[esp_100 + 0x04:word32]:byte] & 0x01) != 0x00)
							{
								*((word32) edi_1031 + 4) = eax_511 & ~0x01;
l0805A451:
								Eq_2 eax_783 = *((word32) ebp_1028 + 64);
								Eq_2 ecx_784 = (word32) ebp_1028 + 56;
								if (*((word32) eax_783 + 0x0C) != ecx_784)
								{
l0805A9C8:
									malloc_printerr(out ecx_1067, out edx_1068);
									goto l0805A9D3;
								}
								edx_1068 = esp_100->ptr0000;
								*((word32) edx_1068 + 8) = eax_783;
								*((word32) edx_1068 + 0x0C) = ecx_784;
								if (esi_1015 > 1007)
								{
									((word32) edx_1068 + 16)->u0 = 0x00;
									((word32) edx_1068 + 20)->u0 = 0x00;
								}
								ecx_1067 = esp_100->ptr0000;
								*((word32) ebp_1028 + 64) = ecx_1067;
								*((word32) eax_783 + 0x0C) = ecx_1067;
								*((word32) ecx_1067 + 4) = esi_1015 | 0x01;
								Mem809[ecx_1067 + esi_1015:word32] = esi_1015;
l0805A493:
								if (esi_1015 > 0xFFFF)
								{
									if (*((word32) ebp_1028 + 8) == 0x00)
										goto l0805A4AA;
									goto l0805A870;
								}
								goto l0805A6C8;
							}
							goto l0805A5B8;
						}
l0805A760:
						esi_1015 += Mem737[esp_100 + 0x04:word32];
						ecx_1067 = esp_100->ptr0000;
						*((word32) ecx_1067 + 4) = esi_1015 | 0x01;
						*((word32) ebp_1028 + 56) = ecx_1067;
						goto l0805A493;
					}
					struct Eq_31251 * esp_104 = esp_100 - 0x0C;
					esp_104->ptrFFFFFFFC = 0x080A39A0;
					word32 eax_2123;
					word32 edx_2124;
					__malloc_assert(0x080A29DD, 2926, 0x080A2925, out eax_2123, out ecx_1067, out edx_2124);
					esp_100 = esp_104 - 4;
				}
				eax_123 = gs->tFFFFFFE4;
				dwLoc20_1731 = eax_26;
				dwLoc04_1936 = ebp;
				dwLoc08_1868 = edi;
				dwLoc0C_1800 = esi;
				dwLoc10_1732 = ebx;
				esi_1015 = eax_29 & ~0x07;
				ebp_1028 = eax;
				ebx_1006.u0 = 0x080CE000;
				gs_1004 = gs;
				Eq_2 edx_121 = esp_100[3];
				edi_1031 = *((word32) eax_123 + (ecx_1067 * 0x04 + 64));
				if (edi_1031 != 0x00)
				{
					if (edx_121 != edi_1031)
					{
						esp_100[5] = (struct Eq_29576) eax_123;
						struct Eq_29816 * edx_132 = esp_100->ptr0000;
						Eq_2 eax_133 = esp_100[3];
						do
						{
							edi_1031 = *edi_1031;
							if (edi_1031 == 0x00)
							{
								eax_123 = esp_100[5];
								esp_100->ptr0000 = (struct Eq_152086 *) edx_132;
								goto l0805A24A;
							}
						} while (eax_133 != edi_1031);
					}
					goto l0805ABBE;
				}
				goto l0805A24A;
			}
l0805A540:
			word32 ecx_2083;
			malloc_printerr(out ecx_2083, out edx_1068);
			edi_1031 = edi;
			goto l0805A550;
		}
	}
	word32 edx_2082;
	word32 ecx_2081;
	malloc_printerr(out ecx_2081, out edx_2082);
	goto l0805A540;
}

// 0805ACF0: Register Eq_2 sysmalloc(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _int_malloc
Eq_2 sysmalloc(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edi_744;
	Eq_2 edx_1023;
	Eq_2 eax_164;
	struct Eq_31375 * esp_111 = fp - 0x4C;
	Eq_2 edi_137 = _dl_pagesize;
	if (edx == 0x00)
	{
		edx_1023 = (word32) eax + ((word32) edi_137 + 18) & -edi_137;
		if (eax < edx_1023)
		{
			word32 edx_1222;
			eax_164 = mmap(gs, 0x00, edx_1023, 0x03, 0x22, ~0x00, 0x00, out ecx, out edx_1222);
			if (eax_164 != ~0x00)
				goto l0805AEF7;
		}
l0805AF8D:
		edi_744.u0 = 0x00;
		goto l0805AF8F;
	}
	if (g_t80CE4A8 > eax)
	{
l0805AD26:
		esp_111[2] = (struct Eq_31375) 0x00;
l0805AD2B:
		esp_111->t000C.u1 = edi_137;
		esp_111->dw0004 = (word32) edx + 56;
		Mem73[esp_111 + 0x14:word32] = edi_137 + 0x12 + eax;
		while (true)
		{
			edi_137 = *((word32) edx + 56);
			Eq_2 eax_77 = *((word32) edi_137 + 4);
			byte al_91 = (byte) eax_77;
			ecx = eax_77 & ~0x07;
			Eq_31443 edx_80 = (word32) edi_137 + (eax_77 & ~0x07);
			if ((edi_137 != esp_111->dw0004 || (eax_77 & ~0x07) != 0x00) && ((eax_77 & ~0x07) <= 0x0F || ((al_91 & 0x01) == 0x00 || (edx_80 & esp_111->t000C - 0x01) != 0x00)))
				break;
			esp_111[3] = (struct Eq_31375) ((word32) eax + 16);
			if ((word32) eax + 16 <= (eax_77 & ~0x07))
			{
				esp_111->dwFFFFFFF0 = 0x080A3988;
				word32 eax_1219;
				__malloc_assert(0x080A3304, 2388, 0x080A2925, out eax_1219, out ecx, out edx_1023);
				goto l0805AF80;
			}
			Eq_2 edi_249;
			Eq_2 eax_425;
			esp_111[4] = (struct Eq_31375) 0x080CE500;
			if (edx != 0x080CE500)
			{
				int32 edx_642 = esp_111[3] - (eax_77 & ~0x07);
				esp_111->t001C = edi_137 & 0xFFF00000;
				if (edx_642 > 0x00)
				{
					esp_111->dw0024 = (edi_137 & 0xFFF00000)->dw0008;
					Eq_2 eax_649 = *((word32) esp_111[1].dwFFFFFFF0 + 16);
					Eq_2 edx_654 = esp_111->dw0024 + (-eax_649 & (word32) eax_649 + (edx_642 - 0x01));
					if (edx_654 > 0x00100000)
						goto l0805AFA0;
					Eq_2 eax_658 = *((word32) esp_111->t001C + 0x0C);
					if (edx_654 <= eax_658)
						esp_111[1] = (struct Eq_31375) edi_137;
					else
					{
						esp_111[5] = (struct Eq_31375) (eax_77 & ~0x07);
						struct Eq_31578 * esp_662 = esp_111 - 0x04;
						esp_662->tFFFFFFFC.u0 = 0x03;
						esp_662->t0030 = edx_654;
						esp_662->tFFFFFFF8 = edx_654 - eax_658;
						Mem673[esp_662 + -0x0C:word32] = eax_658 + Mem669[esp_662 + 0x20:word32];
						word32 ecx_1220;
						word32 edx_1221;
						Eq_2 eax_674 = mprotect(gs, esp_662->tFFFFFFF4, esp_662->tFFFFFFF8, esp_662->tFFFFFFFC, out ecx_1220, out edx_1221);
						ecx = esp_662->t002C;
						if (eax_674 != 0x00)
							goto l0805AFA0;
						edx_654 = esp_662->t0030;
						struct Eq_31594 * ecx_865 = esp_662->ptr0020;
						esp_662->t000C = edi_137;
						ecx_865->t000C = edx_654;
					}
					ecx = esp_111->t001C;
					*((word32) ecx + 8) = edx_654;
					Eq_2 eax_874 = *((word32) ecx + 8);
					edi_249 = *((word32) edx + 56);
					word32 edx_879 = Mem873[edx + 0x0454:word32] + eax_874 - Mem873[esp_111 + 0x24:word32];
					*((word32) edx + 0x0454) = edx_879;
					esp_111->dw0004 = (word32) edx_879;
					edx_1023 = esp_111[1];
					Mem888[edx_1023 + 0x04:word32] = eax_874 + ecx - edx_1023 | 0x01;
				}
				else
				{
l0805AFA0:
					up32 edx_688 = g_dw80CE4A4;
					esp_111->dw0024 = (ui32) ecx;
					eax_425 = new_heap((word32) eax + 40, edx_688, gs, out ecx, out edx_1023);
					if (eax_425 != 0x00)
					{
						Eq_2 edx_813 = esp_111->t001C;
						ui32 ecx_814 = esp_111->dw0024;
						esp_111[1] = (struct Eq_31375) edi_137;
						Eq_2 edi_817 = *((word32) edx + 0x0454);
						*eax_425 = edx;
						*((word32) eax_425 + 4) = edx_813;
						Eq_2 edx_820 = *((word32) eax_425 + 8);
						word32 edi_821 = edi_817 + edx_820;
						*((word32) edx + 0x0454) = edi_821;
						esp_111->dw0004 = (word32) edi_821;
						*((word32) edx + 56) = (word32) eax_425 + 24;
						*((word32) eax_425 + 28) = edx_820 - 0x18 | 0x01;
						Eq_31858 eax_831 = ecx_814 - 0x10 & ~0x0F;
						struct Eq_31863 * ecx_833 = (word32) esp_111[1].dwFFFFFFF0 + (((word32) eax_831 + 8) + 16);
						esp_111->t000C = ecx_833;
						ecx_833->dw0004 = 0x01;
						edi_249 = (word32) eax_425 + 24;
						edx_1023 = (word32) eax_831 + 8;
						if (eax_831 <= 0x0F)
						{
							ecx = esp_111[1];
							*((word32) ecx + 4) = (word32) eax_831 + 8 | 0x01;
							*esp_111->t000C = (word32) eax_831 + 8;
						}
						else
						{
							Eq_2 edx_838 = esp_111[1];
							Eq_2 edi_839 = esp_111->t000C;
							*((word32) eax_831 + ((word32) edx_838 + 4)) = 0x09;
							*edi_839 = 0x08;
							*((word32) edx_838 + 4) = eax_831 | 0x05;
							word32 ebx_1223;
							word32 ebp_1224;
							word32 esi_1225;
							word32 edi_1226;
							struct Eq_31907 * gs_1227;
							_int_free(edx, edx_838, edi_839, gs, out ecx, out edx_1023, out ebx_1223, out ebp_1224, out esi_1225, out edi_1226, out gs_1227);
							edi_249 = *((word32) edx + 56);
							esp_111->dw0004 = (word32) *((word32) edx + 0x0454);
						}
					}
					else
					{
						if (esp_111[2] == 0x00)
						{
							edi_249 = -esp_111->t000C & esp_111->dw0014;
							if (edi_249 <= eax)
								goto l0805B4B6;
							goto l0805B4CB;
						}
						edi_249 = *((word32) edx + 56);
						esp_111->dw0004 = (word32) *((word32) edx + 0x0454);
					}
				}
				goto l0805AE1C;
			}
			<anonymous> * eax_333;
			Eq_2 ecx_496;
			union Eq_2 * eax_219;
			Eq_2 ecx_513;
			Eq_2 ecx_253;
			esp_111[1] = (struct Eq_31375) edi_137;
			ui32 edi_206 = esp_111->t000C;
			up32 eax_207 = g_dw80CE4A4;
			esp_111[2] = (struct Eq_31375) edx_80;
			esp_111->t001C = edi_206 - 0x01;
			ui32 edi_211 = -edi_206;
			esp_111->dw0024 = edi_211;
			edx_1023 = edi_206 - 0x01;
			up32 eax_214 = (word32) eax + 16 + eax_207;
			if ((g_t80CE504 & 0x02) == 0x00)
			{
				eax_219 = eax_214 - (eax_77 & ~0x07) + (edi_206 - 0x01) & edi_211;
				esp_111->t000C = eax_219;
				if (eax_219 > null)
					goto l0805B110;
				goto l0805B32D;
			}
			eax_219 = eax_214 + (edi_206 - 0x01) & edi_211;
			esp_111->t000C = eax_219;
			if (eax_219 <= null)
			{
l0805B1AE:
				Eq_2 edi_270 = esp_111->t000C;
				Eq_2 eax_271 = 0x00100000;
				if (edi_270 >= 0x00100000)
					eax_271 = edi_270;
				esp_111->t000C.u1 = eax_271;
				if (eax >= eax_271)
					goto l0805B1CC;
				esp_111->dw0004 = (word32) ecx;
				struct Eq_32289 * esp_286 = esp_111 - 0x08;
				esp_286->tFFFFFFFC.u0 = 0x00;
				esp_286->tFFFFFFF8.u0 = ~0x00;
				esp_286->tFFFFFFF4.u0 = 0x22;
				esp_286->tFFFFFFF0.u0 = 0x03;
				esp_286->tFFFFFFEC = esp_286->t0014;
				esp_286->tFFFFFFE8.u0 = 0x00;
				word32 ecx_1235;
				Eq_2 eax_304 = mmap(gs, esp_286->tFFFFFFE8, esp_286->tFFFFFFEC, esp_286->tFFFFFFF0, esp_286->tFFFFFFF4, esp_286->tFFFFFFF8, esp_286->tFFFFFFFC, out ecx_1235, out edx_1023);
				esp_111 = (struct Eq_31375 *) ((char *) &esp_286->tFFFFFFFC + 0x0C);
				ecx = esp_286->t000C;
				edi_249 = eax_304;
				if (eax_304 == ~0x00)
					goto l0805B1CC;
				Eq_2 eax_316 = esp_286->t0014;
				g_t80CE504 |= 0x02;
				Mem324[esp_286 + 0x1C:word32] = eax_316 + eax_304;
				if (eax_304 == 0x00)
					goto l0805B1CC;
				esp_286->b0030 = (int8) (esp_286->dw001C == 0x00);
				goto l0805B14E;
			}
l0805B110:
			esp_111->dw0004 = eax_77 & ~0x07;
			struct Eq_31987 * esp_232 = esp_111 - 0x0C;
			esp_232->dwFFFFFFFC = esp_232->dw0018;
			Eq_2 eax_245;
			__morecore();
			edi_249 = eax_245;
			esp_111 = (struct Eq_31375 *) (&esp_232->dwFFFFFFFC + 4);
			ecx_253 = esp_232->t0010;
			if (eax_245 == 0x00)
			{
				ecx = ecx_253;
				ecx = ecx_253;
				if ((g_t80CE504 & 0x02) == 0x00)
				{
l0805B32D:
					Mem267[esp_111 + 0x0C:word32] = Mem259[esp_111 + 0x1C:word32] + ecx + Mem259[esp_111 + 0x0C:word32] & Mem259[esp_111 + 0x24:word32];
				}
				goto l0805B1AE;
			}
			eax_333 = __after_morecore_hook;
			esp_232->b0034 = 0x01;
			esp_232->dw0020 = 0x00;
			ecx = ecx_253;
			ecx_496 = ecx_253;
			if (eax_333 != null)
			{
l0805B42B:
				esp_111->dw0004 = (word32) ecx_496;
				eax_333();
				ecx_513 = esp_111->dw0004;
				ecx = ecx_513;
			}
l0805B14E:
			if (g_t80CE4CC == 0x00)
				g_t80CE4CC = edi_249;
			edx_1023 = esp_111->t000C;
			up32 eax_353 = (word32) edx_1023 + g_dw80CE954;
			esp_111->dw0004 = eax_353;
			g_dw80CE954 = eax_353;
			if (esp_111[2] == edi_249 && esp_111[5] != 0x00)
			{
				edi_249 = g_t80CE538;
				ecx = esp_111[1];
				Mem638[ecx + 0x04:word32] = edx_1023 + ecx | 0x01;
				goto l0805AE1C;
			}
			if ((g_t80CE504 & 0x02) != 0x00)
			{
				Eq_32082 eax_367 = (word32) edi_249 + 8;
				if ((eax_367 & 0x0F) != 0x00)
					edi_249 = edi_249 - (eax_367 & 0x0F) + 0x10;
				word32 eax_378 = esp_111->dw0014;
				edx_1023.u0 = 0x00;
				if (eax_378 != 0x00)
					goto l0805B2B6;
				esp_111->dw0004 = (word32) ecx;
				struct Eq_32454 * esp_388 = esp_111 - 0x0C;
				esp_388->dwFFFFFFFC = 0x00;
				word32 eax_410;
				__morecore();
				esp_388->dw0020 = eax_410;
				ecx = esp_388->t0010;
				goto l0805B3DD;
			}
			if (ecx == 0x00 || esp_111[2] <= edi_249)
			{
				if (ecx != 0x00)
					g_dw80CE954 = edi_249 - esp_111[2] + esp_111->dw0004;
				Eq_2 edx_449;
				Eq_32104 eax_443 = (word32) edi_249 + 8;
				if ((eax_443 & 0x0F) != 0x00)
				{
					int32 edx_453 = 0x10 - (eax_443 & 0x0F);
					esp_111[2] = (struct Eq_31375) ((word32) edi_249 + edx_453);
					edx_449 = (word32) ecx + edx_453;
				}
				else
				{
					esp_111[2] = (struct Eq_31375) edi_249;
					edx_449 = ecx;
				}
				word32 eax_464 = Mem459[esp_111 + 0x0C:word32] + edx_449 + edi_249;
				Eq_32424 edx_466 = edx_449 - eax_464;
				edi_249 = (Mem459[esp_111 + 0x1C:word32] + eax_464 & Mem459[esp_111 + 0x24:word32]) + edx_466;
				if (edi_249 < 0x00)
				{
					struct Eq_32137 * esp_475 = esp_111 - 0x0C;
					esp_475->ptrFFFFFFFC = 0x080A3988;
					__malloc_assert(134883878, 0x0A2B, 0x080A2925, out eax_333, out ecx_496, out edx_1023);
					esp_111 = esp_475 - 4;
					goto l0805B42B;
				}
				esp_111->t000C.u1 = edi_249;
				struct Eq_32157 * esp_515 = esp_111 - 0x0C;
				esp_515->t0010 = ecx;
				esp_515->tFFFFFFFC = edi_249;
				word32 eax_521;
				__morecore();
				esp_515->dw0020 = eax_521;
				ecx = esp_515->t0010;
				edx_1023 = esp_515->t0018;
				if (eax_521 != 0x00)
				{
					<anonymous> * eax_557 = __after_morecore_hook;
					if (eax_557 == null)
					{
						edi_249 = esp_515->t001C;
						esp_515->t0010 = (word32) edx_1023 + g_dw80CE954;
					}
					else
					{
						esp_515->t0010 = edx_1023;
						esp_515->t0018 = ecx;
						eax_557();
						edx_1023 = esp_515->t0010;
						edi_249 = esp_515->t001C;
						ecx = esp_515->t0018;
						esp_515->t0010 = (word32) edx_1023 + g_dw80CE954;
					}
					goto l0805B2B6;
				}
				esp_515->tFFFFFFFC.u0 = 0x00;
				word32 eax_536;
				__morecore();
				esp_515->dw0020 = eax_536;
				edi_249 = esp_515->t001C;
				ecx = esp_515->t0010;
l0805B3DD:
				edx_1023 = esp_111->dw0014;
				esp_111->dw0004 = g_dw80CE954;
				if (edx_1023 != 0x00)
				{
					edx_1023.u0 = 0x00;
l0805B2B6:
					ui32 eax_581 = esp_111->dw0014;
					g_t80CE538 = edi_249;
					*((word32) edi_249 + 4) = (word32) edx_1023 + (eax_581 - edi_249) | 0x01;
					g_dw80CE954 = esp_111->dw0004;
					if (ecx == 0x00)
						goto l0805AE1C;
					Eq_32231 eax_598 = ecx - 0x10;
					ecx = esp_111[1];
					edx_1023 = eax_598 & ~0x0F | 0x01;
					*((word32) ecx + 4) = edx_1023;
					Mem604[ecx + 0x04 + (eax_598 & ~0x0F):word32] = 0x09;
					Mem605[ecx + 0x0C + (eax_598 & ~0x0F):word32] = 0x09;
					if ((eax_598 & ~0x0F) <= 0x0F)
						goto l0805AE1C;
					word32 esi_1232;
					word32 edi_1233;
					struct Eq_32261 * gs_1234;
					word32 ebx_1230;
					word32 ebp_1231;
					_int_free(0x080CE500, esp_111[1], edi_249, gs, out ecx, out edx_1023, out ebx_1230, out ebp_1231, out esi_1232, out edi_1233, out gs_1234);
l0805B1CC:
					esp_111->dw0004 = g_dw80CE954;
				}
				edi_249 = g_t80CE538;
l0805AE1C:
				Eq_2 ebp_922 = eax;
				up32 eax_892 = esp_111->dw0004;
				if (eax_892 > *((word32) edx + 1112))
					*((word32) edx + 1112) = eax_892;
				ui32 eax_905 = *((word32) edi_249 + 4);
				if (esp_111[3] <= (eax_905 & ~0x07))
				{
					edx_1023 = edi_249 + eax;
					*((word32) edx + 56) = edx_1023;
					ui32 eax_927 = (eax_905 & ~0x07) - eax;
					if (edx != esp_111[4])
						ebp_922 = eax | 0x04;
					edi_744 = (word32) edi_249 + 8;
					ecx = ebp_922 | 0x01;
					*((word32) edi_744 - 4) = ecx;
					*((word32) edx_1023 + 4) = eax_927 | 0x01;
					goto l0805AF8F;
				}
l0805AF80:
				gs->tFFFFFFE0.u0 = 0x0C;
				goto l0805AF8D;
			}
			word32 edx_1229;
			word32 ecx_1228;
			eax_425 = malloc_printerr(out ecx_1228, out edx_1229);
l0805B4CB:
			struct Eq_32488 * esp_713 = esp_111 - 4;
			esp_713->t0000 = eax_425;
			esp_713->tFFFFFFFC = eax_425;
			esp_713->tFFFFFFF8.u0 = 0x00;
			esp_713->tFFFFFFF4.u0 = ~0x00;
			esp_713->tFFFFFFF0.u0 = 0x22;
			esp_713->tFFFFFFEC.u0 = 0x03;
			esp_713->tFFFFFFE8 = edi_249;
			esp_713->tFFFFFFE4.u0 = 0x00;
			word32 edx_1237;
			word32 ecx_1236;
			eax_164 = mmap(gs, esp_713->tFFFFFFE4, esp_713->tFFFFFFE8, esp_713->tFFFFFFEC, esp_713->tFFFFFFF0, esp_713->tFFFFFFF4, esp_713->tFFFFFFF8, out ecx_1236, out edx_1237);
			esp_111 = (struct Eq_31375 *) ((char *) &esp_713->t0000 + 4);
			if (eax_164 != ~0x00)
			{
				edx_1023 = edi_249;
				goto l0805AEF7;
			}
l0805B4B6:
			esp_111[2] = (struct Eq_31375) 0x01;
		}
		struct Eq_31418 * esp_108 = esp_111 - 0x0C;
		esp_108->ptrFFFFFFFC = 0x080A3988;
		word32 eax_1216;
		word32 ecx_1217;
		word32 edx_1218;
		__malloc_assert(134885980, 0x0951, 0x080A2925, out eax_1216, out ecx_1217, out edx_1218);
		esp_111 = esp_108 - 4;
	}
	if (g_t80CE4B4 < g_t80CE4B8)
	{
		struct Eq_32548 * eax_141 = -edi_137;
		word32 edx_142 = edi_137 + 0x12 + eax & eax_141;
		if (edx_142 <= eax)
		{
l0805AEB4:
			esp_111[2] = (struct Eq_31375) 0x01;
			goto l0805AD2B;
		}
		struct Eq_32556 * esp_146 = esp_111 - 4;
		esp_146->ptr0000 = eax_141;
		esp_146->ptrFFFFFFFC = eax_141;
		esp_146->tFFFFFFF8.u0 = 0x00;
		esp_146->tFFFFFFF4.u0 = ~0x00;
		esp_146->tFFFFFFF0.u0 = 0x22;
		esp_146->tFFFFFFEC.u0 = 0x03;
		esp_146->tFFFFFFE8 = edx_142;
		esp_146->t0008 = edx_142;
		esp_146->tFFFFFFE4.u0 = 0x00;
		word32 ecx_1238;
		word32 edx_1239;
		eax_164 = mmap(gs, esp_146->tFFFFFFE4, esp_146->tFFFFFFE8, esp_146->tFFFFFFEC, esp_146->tFFFFFFF0, esp_146->tFFFFFFF4, esp_146->tFFFFFFF8, out ecx_1238, out edx_1239);
		edx_1023 = esp_146->t0008;
		if (eax_164 == ~0x00)
			goto l0805AEB4;
l0805AEF7:
		edi_744 = (word32) eax_164 + 8;
		if ((edi_744 & 0x0F) == 0x00)
		{
			*eax_164 = 0x00;
			*((word32) eax_164 + 4) = edx_1023 | 0x02;
		}
		else
		{
			uint32 ecx_751 = 0x10 - (edi_744 & 0x0F);
			struct Eq_31660 * edi_752 = (word32) eax_164 + ecx_751;
			edi_752->dw0000 = ecx_751;
			edi_752->dw0004 = edx_1023 - ecx_751 | 0x02;
			edi_744 = &edi_752->dw0004 + 1;
		}
		__lock();
		g_t80CE4B4 = __xadd(g_t80CE4B4, 0x01);
		do
		{
			Eq_2 eax_781 = g_t80CE4BC;
			if (eax_781 >= 0x02)
				break;
			__lock();
			word32 eax_785;
		} while (__cmpxchg(g_t80CE4BC, 0x02, eax_781, out eax_785));
		__lock();
		g_t80CE4C4 = __xadd(g_t80CE4C4, edx_1023);
		ecx.u0 = 1224;
		edx_1023 *= 0x02;
		do
		{
			Eq_2 eax_801 = g_t80CE4C8;
			if (edx_1023 <= eax_801)
				break;
			__lock();
			word32 eax_805;
		} while (!__cmpxchg(g_t80CE4C8, edx_1023, eax_801, out eax_805));
l0805AF8F:
		ecxOut = ecx;
		edxOut = edx_1023;
		return edi_744;
	}
	goto l0805AD26;
}

// 0805B4F0: Register Eq_2 _int_malloc(Register Eq_2 eax, Register Eq_2 edx, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_32644) ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out Eq_2 ediOut)
// Called from:
//      malloc_check
//      tcache_init.part.6
//      _int_memalign
//      _int_realloc
//      realloc_check
//      __libc_malloc
//      __libc_calloc
Eq_2 _int_malloc(Eq_2 eax, Eq_2 edx, Eq_2 edi, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, struct Eq_32644 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 ecx_2573;
	Eq_2 esi_1637;
	ptr32 dwLoc04_1913 = ebp;
	struct Eq_32652 * ebp_1474 = &g_t80CE000;
	Eq_2 dwLoc08_1914 = edi;
	ptr32 dwLoc0C_1915 = esi;
	struct Eq_32644 * dwLoc10_1916 = ebx;
	struct Eq_32659 * esp_1027 = fp - 0x9C;
	if (edx > 0x04)
	{
		esi_1637 = (word32) edx + 19 & ~0x0F;
		ecx_2573 = SEQ(ecx_24_8, (int8) (esi_1637 > ~0x20));
	}
	else
	{
		esi_1637.u0 = 0x10;
		ecx_2573.u0 = 0x00;
	}
	byte cl_35 = (byte) ecx_2573;
	if (esi_1637 < edx || cl_35 != 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		ecxOut = ecx_2573;
		edxOut = edx;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return 0x00;
	}
	Eq_2 ecx_1112;
	Eq_2 esi_1435;
	word24 eax_24_8_1815;
	byte al_1800;
	Eq_2 edx_1144;
	Eq_2 edx_1638;
	if (eax == 0x00)
	{
l0805BB90:
		edx_1638.u0 = 0x00;
		goto l0805BB92;
	}
	Eq_2 ecx_1564;
	struct Eq_32693 * ebp_1125;
	Eq_2 esi_1030;
	Eq_2 ebx_1036;
	Eq_2 edi_1065;
	Eq_2 ecx_1464;
	Eq_2 edx_1301;
	Eq_2 eax_1783;
	Eq_2 eax_1200;
	Eq_2 ecx_1302;
	Eq_2 edx_1035;
	Eq_2 eax_1039;
	uint32 edx_942;
	Eq_2 eax_495;
	Eq_2 esi_497;
	if (esi_1637 <= global_max_fast)
	{
		Eq_2 edx_158 = esi_1637 >> 0x03;
		ebx_1036 = (word32) eax + edx_158 * 0x04;
		Eq_2 ecx_160 = *((word32) ebx_1036 + 4);
		Eq_2 dwLoc94_1951 = ecx_160;
		if (ecx_160 != 0x00)
		{
			union Eq_2 * eax_165 = (word32) eax + 4 + edx_158 * 0x04;
			ecx_1112 = *((word32) ecx_160 + 8);
			if (gs->t000C == 0x00)
			{
				*((word32) ebx_1036 + 4) = ecx_1112;
				edi_1065 = edi;
			}
			else
			{
				edi_1065 = ecx_160;
				while (true)
				{
					if (gs->t000C != 0x00)
						__lock();
					Eq_2 eax_187;
					__cmpxchg(*eax_165, ecx_1112, edi_1065, out eax_187);
					if (eax_187 == edi_1065)
						break;
					if (eax_187 == 0x00)
						goto l0805B978;
					ecx_1112 = *((word32) eax_187 + 8);
					edi_1065 = eax_187;
				}
				dwLoc94_1951 = edi_1065;
			}
			edx_1144 = edx_158;
			if (edx_158 == *((word32) dwLoc94_1951 + 4) >> 0x03)
			{
				Eq_2 edi_1687 = gs->tFFFFFFE4;
				if (edi_1687 != 0x00)
				{
					uint32 esi_1692 = esi_1637 - 0x01;
					if (g_dw80CE4D0 > esi_1692 >> 0x04 && CONVERT(Mem358[edi_1687 + (esi_1692 >>u 0x04):byte], byte, int32) <u Mem358[0x080CE4D8<p32>:word32])
					{
						edx_1144 = *((word32) ebx_1036 + 4);
						if (edx_1144 != 0x00)
						{
							struct Eq_32786 * eax_1705 = (word32) edi_1687 + (esi_1692 >> 0x04) * 0x04;
							do
							{
								Eq_32791 esi_1719 = esi_1637 - 0x01 >> 0x04;
								ecx_1112 = *((word32) edx_1144 + 8);
								if (gs->t000C != 0x00)
								{
									while (true)
									{
										if (gs->t000C != 0x00)
											__lock();
										Eq_2 eax_1734;
										__cmpxchg(*eax_165, ecx_1112, edx_1144, out eax_1734);
										if (eax_1734 == edx_1144)
											break;
										if (eax_1734 == 0x00)
											goto l0805B658;
										ecx_1112 = *((word32) eax_1734 + 8);
										edx_1144 = eax_1734;
									}
								}
								else
									*((word32) ebx_1036 + 4) = ecx_1112;
								Eq_2 eax_1747 = eax_1705->t0040;
								*((word32) edx_1144 + 0x0C) = edi_1687;
								edx_1144 = (word32) edx_1144 + 8;
								*edx_1144 = eax_1747;
								eax_1705->t0040 = edx_1144;
								byte al_1760 = Mem1756[edi_1687 + esi_1719:byte] + 0x01;
								Mem1761[edi_1687 + esi_1719:byte] = al_1760;
								if ((int32) al_1760 >= g_t80CE4D8)
									break;
								edx_1144 = *((word32) ebx_1036 + 4);
							} while (edx_1144 != 0x00);
						}
					}
				}
l0805B658:
				eax_1783 = dwLoc94_1951;
l0805B65C:
				Eq_2 eax_1790 = perturb_byte;
				dwLoc04_1913 = ebp;
				dwLoc08_1914 = edi;
				dwLoc0C_1915 = esi;
				dwLoc10_1916 = ebx;
				esi_1435 = (word32) eax_1783 + 8;
				al_1800 = (byte) eax_1790;
				eax_24_8_1815 = SLICE(eax_1790, word24, 8);
				if (eax_1790 == 0x00)
					goto l0805B66F;
				goto l0805BB20;
			}
l0805BF70:
			word32 edx_2585;
			word32 ecx_2584;
			malloc_printerr(out ecx_2584, out edx_2585);
			esi_1030 = esi_1637;
l0805BF80:
			*((word32) edi_1065 + 20) = edi_1065;
			ecx_1564 = esp_1027[3];
			*((word32) edi_1065 + 16) = edi_1065;
			esp_1027[5] = (struct Eq_32659) ebx_1036;
l0805B8A8:
			int32 eax_386 = esp_1027[3];
			++esp_1027->dw0020;
			*((word32) esi_1030 + ((eax_386 >> 0x05) * 0x04 + 1080)) |= 0x01 << (byte) ecx_1564;
			struct Eq_33470 * eax_397 = esp_1027[5];
			word32 edx_398 = esp_1027->dw0040;
			*((word32) edi_1065 + 8) = ebx_1036;
			*((word32) edi_1065 + 0x0C) = eax_397;
			*((word32) ebx_1036 + 0x0C) = edi_1065;
			eax_397->t0008 = edi_1065;
			dwLoc04_1913 = ebp;
			dwLoc08_1914 = edi;
			dwLoc0C_1915 = esi;
			dwLoc10_1916 = ebx;
			up32 eax_405 = esp_1027->dw0020;
			ecx_1112 = ecx_1564;
			if (edx_398 != 0x00)
			{
				if (esp_1027->dw004C < eax_405 && esp_1027->b005B != 0x00)
				{
					byte edi_1579[] = esp_1027->ptr0014;
					struct Eq_33127 * eax_1582 = edi_1579 + esp_1027[2] *32 0x04;
					esi_1435 = eax_1582->t0040;
					if (esp_1027->dw005C <= 0x03FF)
					{
						if (esi_1435 != 0x00)
						{
							edx_1144 = *esi_1435;
							eax_1582->t0040 = edx_1144;
							int32 eax_1681 = esp_1027[2];
							--edi_1579[eax_1681];
							((word32) esi_1435 + 4)->u0 = 0x00;
							goto l0805B66F;
						}
						goto l0805C2C9;
					}
					goto l0805C2A9;
				}
				++esp_1027->dw001C;
				if (esp_1027->dw001C > 9999)
				{
l0805C0AC:
					int32 edi_949 = esp_1027->ptr0014;
					ecx_1112 = esp_1027[2];
					struct Eq_33219 * eax_952 = edi_949 + ecx_1112 * 0x04;
					dwLoc04_1913 = ebp;
					dwLoc08_1914 = edi;
					dwLoc0C_1915 = esi;
					dwLoc10_1916 = ebx;
					esi_1435 = eax_952->t0040;
					if (esp_1027->dw005C <= 0x03FF)
					{
						if (esi_1435 != 0x00)
						{
							edx_1144 = *esi_1435;
							eax_952->t0040 = edx_1144;
							--*((word32) ecx_1112 + edi_949);
							((word32) esi_1435 + 4)->u0 = 0x00;
							goto l0805B66F;
						}
l0805C2C9:
						struct Eq_33164 * esp_1619 = esp_1027 - 0x0C;
						esp_1619->ptrFFFFFFFC = 134887828;
						word32 eax_2601;
						word32 ecx_2602;
						word32 edx_2603;
						__malloc_assert(0x080A2A68, 0x0B80, 0x080A2925, out eax_2601, out ecx_2602, out edx_2603);
						esp_1027 = esp_1619 - 4;
l0805C2E9:
						esi_1637 = esp_1027->t0010;
						edx_1638 = esp_1027->ptr0004;
l0805BB92:
						Eq_2 eax_1663 = sysmalloc(esi_1637, edx_1638, gs, out ecx_1112, out edx_1144);
						dwLoc04_1913 = ebp;
						dwLoc08_1914 = edi;
						dwLoc0C_1915 = esi;
						dwLoc10_1916 = ebx;
						esi_1435 = eax_1663;
						if (eax_1663 == 0x00)
						{
							esi_1435.u0 = 0x00;
							goto l0805B66F;
						}
						Eq_2 eax_1675 = perturb_byte;
						al_1800 = (byte) eax_1675;
						eax_24_8_1815 = SLICE(eax_1675, word24, 8);
						if (eax_1675 == 0x00)
						{
l0805B66F:
							ecxOut = ecx_1112;
							edxOut = edx_1144;
							ebxOut = dwLoc10_1916;
							ebpOut = dwLoc04_1913;
							esiOut = dwLoc0C_1915;
							ediOut = dwLoc08_1914;
							return esi_1435;
						}
l0805BB20:
						struct Eq_32821 * esp_1799 = esp_1027 - 0x04;
						esp_1799->tFFFFFFFC = esp_1799->t0010;
						esp_1799->tFFFFFFF8 = SEQ(eax_24_8_1815, ~al_1800);
						esp_1799->tFFFFFFF4 = esi_1435;
						memset(esp_1799->tFFFFFFF4, esp_1799->tFFFFFFF8, esp_1799->tFFFFFFFC, out ecx_1112, out edx_1144);
						goto l0805B66F;
					}
					goto l0805C2A9;
				}
			}
			else
			{
				++esp_1027->dw001C;
				if (esp_1027->dw001C > 9999)
					goto l0805BC60;
			}
			edi_1065 = *((word32) esi_1030 + 0x0044);
l0805B7DB:
			while (true)
			{
				dwLoc04_1913 = ebp;
				dwLoc08_1914 = edi;
				dwLoc0C_1915 = esi;
				dwLoc10_1916 = ebx;
				ebp_1474 = (struct Eq_32652 *) &g_t80CE000;
				if (edi_1065 == esp_1027->dw0008)
					break;
				ui32 eax_435 = *((word32) edi_1065 + 4);
				esp_1027[5] = (struct Eq_32659) ((word32) edi_1065 + (eax_435 & ~0x07));
				eax_1039 = eax_435 & ~0x07;
				if ((eax_435 & ~0x07) <= 0x08)
				{
l0805BB80:
					word32 edx_2592;
					word32 ecx_2591;
					malloc_printerr(out ecx_2591, out edx_2592);
					esi_1637 = esi_1030;
					goto l0805BB90;
				}
				Eq_2 ebx_442 = *((word32) esi_1030 + 0x0454);
				if (ebx_442 < (eax_435 & ~0x07))
					goto l0805BB80;
				Eq_2 edx_468 = (word32) edi_1065 + (eax_435 & ~0x07) + 0x04;
				byte dl_565 = (byte) edx_468;
				if (edx_468 <= 0x07 || ebx_442 < edx_468)
				{
					word32 edx_2594;
					word32 ecx_2593;
					eax_1039 = malloc_printerr(out ecx_2593, out edx_2594);
					goto l0805BBD0;
				}
				if ((*((word32) edi_1065 + (eax_435 & ~0x07)) & ~0x07) != (eax_435 & ~0x07))
				{
					eax_495 = malloc_printerr(out ecx_1464, out edx_1301);
					esi_497 = esi_1030;
					goto l0805BEF0;
				}
				struct Eq_32972 * ebx_558 = *((word32) edi_1065 + 0x0C);
				esp_1027[3] = (struct Eq_32659) ebx_558;
				if (ebx_558->t0008 != edi_1065)
					goto l0805BCF0;
				ebx_1036 = esp_1027->dw0008;
				if (*((word32) edi_1065 + 8) != ebx_1036)
					goto l0805BCF0;
				if ((dl_565 & 0x01) != 0x00)
				{
					word32 edx_2597;
					word32 ecx_2596;
					malloc_printerr(out ecx_2596, out edx_2597);
					esi_1637 = esi_1030;
					goto l0805BF70;
				}
				if (esp_1027->t0010 <= 1007 && (esp_1027[3] == esp_1027->dw0008 && (*((word32) esi_1030 + 60) == edi_1065 && (word32) esp_1027->t0010 + 16 < (eax_435 & ~0x07))))
				{
					union Eq_2 * esi_586 = esp_1027->t0010;
					word32 ebx_590 = edi_1065 + esi_586;
					struct Eq_34412 * edi_591 = esp_1027->ptr0004;
					edi_591->t0040 = ebx_590;
					edi_591->t0044 = ebx_590;
					edi_591->t003C = ebx_590;
					word32 edi_596 = esp_1027->dw0008;
					*((word32) ebx_590 + 8) = edi_596;
					*((word32) ebx_590 + 0x0C) = edi_596;
					eax_1783 = edi_1065;
					ecx_1112 = (eax_435 & ~0x07) - esi_586;
					if (ecx_1112 > 1007)
					{
						*((word32) ebx_590 + 16) = 0x00;
						*((word32) ebx_590 + 20) = 0x00;
					}
					struct Eq_34439 * esi_614 = esp_1027[5];
					*((byte) edi_1065.u0 + 4) = (word32) (esp_1027->ptr0004 != &g_t80CE500) << 0x02 | esi_586 | 0x01;
					*((word32) ebx_590 + 4) = ecx_1112 | 0x01;
					esi_614->t0000 = ecx_1112;
					edx_1144 = ecx_1112 | 0x01;
					goto l0805B65C;
				}
				Eq_2 ecx_628 = esp_1027[3];
				word32 ebx_629 = esp_1027->dw0008;
				*((word32) esi_1030 + 0x0044) = ecx_628;
				*((word32) ecx_628 + 8) = ebx_629;
				if (esp_1027->t0010 != (eax_435 & ~0x07))
				{
					if ((eax_435 & ~0x07) <= 1007)
					{
						uint32 eax_1571 = (eax_435 & ~0x07) >> 0x04;
						esp_1027[3] = (struct Eq_32659) (eax_1571 + 0x01);
						union Eq_2 * eax_1574 = (word32) esi_1030 + 64 + eax_1571 * 0x08;
						esp_1027[5] = (struct Eq_32659) (eax_1574 - 0x08);
						ebx_1036 = *eax_1574;
						ecx_1564 = SEQ(SLICE(eax_1571 + 0x01, word24, 8), (byte) eax_1571 + 0x01);
						goto l0805B8A8;
					}
l0805BBD0:
					edx_942 = eax_1039 >> 0x06;
					if (edx_942 <= 0x2D)
						goto l0805BD00;
					uint32 edx_1000 = eax_1039 >> 0x09;
					if (edx_1000 <= 0x14)
						esp_1027[3] = (struct Eq_32659) (edx_1000 + 0x5B);
					else
					{
						uint32 edx_1004 = eax_1039 >> 0x0C;
						if (edx_1004 <= 0x0A)
							esp_1027[3] = (struct Eq_32659) (edx_1004 + 110);
						else
						{
							uint32 edx_1008 = eax_1039 >> 0x0F;
							if (edx_1008 <= 0x04)
								esp_1027[3] = (struct Eq_32659) (edx_1008 + 0x77);
							else
							{
								uint32 edx_1013 = eax_1039 >> 0x12;
								if (edx_1013 > 0x02)
									edx_1013 = 0x02;
								esp_1027[3] = (struct Eq_32659) (edx_1013 + 0x7C);
							}
						}
					}
					goto l0805BBF3;
				}
				*esp_1027[5].ptr0004 = (struct Eq_32659) (edx_468 | 0x01);
				edx_1144 = edx_468 | 0x01;
				if (esi_1030 != 0x080CE500)
					*((byte) edi_1065.u0 + 4) |= 0x04;
				ecx_1112 = (byte) edi_1065.u0 + 8;
				if (esp_1027->dw0034 == 0x00)
				{
l0805BB0B:
					Eq_2 eax_980 = perturb_byte;
					al_1800 = (byte) eax_980;
					eax_24_8_1815 = SLICE(eax_980, word24, 8);
					esi_1435 = ecx_1112;
					if (eax_980 == 0x00)
						goto l0805B66F;
					esi_1435 = ecx_1112;
					goto l0805BB20;
				}
				edx_1144 = CONVERT(Mem650[Mem650[esp_1027 + 0x14:word32] + Mem650[esp_1027 + 0x18:word32]:byte], byte, int32);
				if (edx_1144 >= esp_1027[6])
					goto l0805BB0B;
				if (esp_1027->dw005C > 0x03FF)
				{
					struct Eq_34508 * esp_667 = esp_1027 - 0x0C;
					esp_667->ptrFFFFFFFC = 0x080A39A0;
					word32 ecx_2628;
					word32 edx_2629;
					word32 eax_2627;
					__malloc_assert(0x080A29DD, 2926, 0x080A2925, out eax_2627, out ecx_2628, out edx_2629);
					esp_1027 = esp_667 - 4;
					break;
				}
				struct Eq_34528 * edx_964 = esp_1027->ptr0050;
				Eq_34497 ebx_965[] = esp_1027->ptr0014;
				esp_1027->dw0040 = 0x01;
				word32 edx_969 = edx_964->dw0040;
				*((byte) edi_1065.u0 + 0x0C) = ebx_965;
				*((byte) edi_1065.u0 + 8) = edx_969;
				int32 edi_972 = esp_1027[2];
				esp_1027->ptr0050->t0040 = ecx_1112;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&ebx_965[edi_972].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (byte) edx_1144 + 0x01;
				edi_1065 = esp_1027[3];
			}
			if (esp_1027->dw0040 != 0x00)
				goto l0805C0AC;
l0805BC60:
			dwLoc04_1913 = ebp;
			dwLoc08_1914 = edi;
			dwLoc0C_1915 = esi;
			dwLoc10_1916 = ebx;
			Eq_2 edi_691 = esp_1027->t0010;
			if (edi_691 > 1007)
			{
				struct Eq_33273 * ecx_697 = (word32) esi_1030 + 56 + esp_1027[4] *32 0x08;
				struct Eq_33282 * eax_698 = ecx_697->ptr0000;
				if (eax_698 != ecx_697 - 0x08 && eax_698->t0004 >= edi_691)
				{
					esi_1030 = edi_691;
					edi_1065 = eax_698->t0014;
					while (true)
					{
						ui32 edx_708 = *((word32) edi_1065 + 4);
						ebx_1036 = edx_708 & ~0x07;
						if (edi_691 <= (edx_708 & ~0x07))
							break;
						edi_1065 = *((word32) edi_1065 + 20);
					}
					esp_1027->t0010 = edx_708 & ~0x07;
					if (ecx_697->t0004 != edi_1065)
					{
						Eq_2 eax_720 = *((word32) edi_1065 + 8);
						if (edx_708 == *((word32) eax_720 + 4))
							edi_1065 = eax_720;
					}
					uint32 ecx_726 = *((word32) edi_1065 + 4);
					if ((ecx_726 & ~0x07) != *((word32) edi_1065 + (ecx_726 & ~0x07)))
					{
l0805C29E:
						word32 ecx_2618;
						word32 edx_2619;
						malloc_printerr(out ecx_2618, out edx_2619);
l0805C2A9:
						struct Eq_33142 * esp_1590 = esp_1027 - 0x0C;
						esp_1590->ptrFFFFFFFC = 134887828;
						word32 ecx_2599;
						word32 edx_2600;
						word32 eax_2598;
						__malloc_assert(0x080A29DD, 0x0B7F, 0x080A2925, out eax_2598, out ecx_2599, out edx_2600);
						esp_1027 = esp_1590 - 4;
						goto l0805C2C9;
					}
					edx_1301 = *((word32) edi_1065 + 8);
					Eq_2 eax_732 = *((word32) edi_1065 + 0x0C);
					if (*((word32) edx_1301 + 0x0C) == edi_1065 && *((word32) eax_732 + 8) == edi_1065)
					{
						*((word32) edx_1301 + 0x0C) = eax_732;
						*((word32) eax_732 + 8) = edx_1301;
						if (ecx_726 <= 1007)
							goto l0805C3E4;
						ecx_1302 = *((word32) edi_1065 + 16);
						if (ecx_1302 == 0x00)
						{
l0805C3E4:
							dwLoc04_1913 = ebp;
							dwLoc08_1914 = edi;
							dwLoc0C_1915 = esi;
							dwLoc10_1916 = ebx;
							ebp_1474 = (struct Eq_32652 *) &g_t80CE000;
							ecx_1464 = esp_1027->t0010 - esi_1030;
							if (ecx_1464 > 0x0F)
							{
								edx_1301 = edi_1065 + esi_1030;
								Eq_2 eax_1471 = esp_1027->ptr0004->t0040;
								if (*((word32) eax_1471 + 0x0C) == esp_1027->dw0008)
								{
									Eq_2 ebx_1500 = esp_1027->dw0008;
									*((word32) edx_1301 + 8) = eax_1471;
									*((word32) edx_1301 + 0x0C) = ebx_1500;
									esp_1027->ptr0004->t0040 = edx_1301;
									*((word32) eax_1471 + 0x0C) = edx_1301;
									if (ecx_1464 > 1007)
									{
										((word32) edx_1301 + 16)->u0 = 0x00;
										((word32) edx_1301 + 20)->u0 = 0x00;
									}
									*((word32) edi_1065 + 4) = (word32) (esp_1027->ptr0004 != &g_t80CE500) << 0x02 | esi_1030 | 0x01;
									*((word32) edx_1301 + 4) = ecx_1464 | 0x01;
									Mem1532[edi_1065 + Mem1530[esp_1027 + 0x10:word32]:word32] = ecx_1464;
									goto l0805BA28;
								}
								malloc_printerr(out ecx_1464, out edx_1301);
							}
							union Eq_2 * eax_1487 = esp_1027->t0010;
							*((char *) eax_1487 + ((word32) edi_1065 + 4)) |= 0x01;
							if (esp_1027->ptr0004 != &g_t80CE500)
								*((word32) edi_1065 + 4) |= 0x04;
							goto l0805BA28;
						}
l0805C4C4:
						dwLoc04_1913 = ebp;
						dwLoc08_1914 = edi;
						dwLoc0C_1915 = esi;
						dwLoc10_1916 = ebx;
						ebp_1125 = (struct Eq_32693 *) &g_t80CE000;
						if (*((word32) ecx_1302 + 20) == edi_1065)
						{
							Eq_2 eax_1310 = *((word32) edi_1065 + 20);
							if (*((word32) eax_1310 + 16) == edi_1065)
							{
								if (*((word32) edx_1301 + 16) != 0x00)
								{
									*((word32) ecx_1302 + 20) = eax_1310;
									*((word32) *((word32) edi_1065 + 20) + 16) = ecx_1302;
								}
								else if (ecx_1302 != edi_1065)
								{
									*((word32) edx_1301 + 20) = eax_1310;
									*((word32) edx_1301 + 16) = ecx_1302;
									*((word32) *((word32) edi_1065 + 16) + 20) = edx_1301;
									*((word32) *((word32) edi_1065 + 20) + 16) = edx_1301;
								}
								else
								{
									*((word32) edx_1301 + 20) = edx_1301;
									*((word32) edx_1301 + 16) = edx_1301;
								}
								goto l0805C3E4;
							}
						}
l0805C4A3:
						malloc_printerr(out ecx_1112, out edx_1144);
l0805C4AE:
						*((word32) edx_1144 + 20) = edx_1144;
						*((word32) edx_1144 + 16) = edx_1144;
l0805C1AB:
						ebx_1036 -= esi_1030;
						if (ebx_1036 > 0x0F)
						{
							edx_1144 = ecx_1112 + esi_1030;
							Eq_2 eax_1358 = esp_1027->ptr0004->t0040;
							if (*((word32) eax_1358 + 0x0C) == esp_1027->dw0008)
							{
								Eq_2 edi_1390 = esp_1027->dw0008;
								*((word32) edx_1144 + 8) = eax_1358;
								*((word32) edx_1144 + 0x0C) = edi_1390;
								struct Eq_33756 * edi_1393 = esp_1027->ptr0004;
								edi_1393->t0040 = edx_1144;
								*((word32) eax_1358 + 0x0C) = edx_1144;
								if (esi_1030 <= 1007)
									edi_1393->t003C = edx_1144;
								if (ebx_1036 > 1007)
								{
									((word32) edx_1144 + 16)->u0 = 0x00;
									((word32) edx_1144 + 20)->u0 = 0x00;
								}
								*((word32) ecx_1112 + 4) = (word32) (esp_1027->ptr0004 != (char *) ebp_1125 + 0x0500) << 0x02 | esi_1030 | 0x01;
								*((word32) edx_1144 + 4) = ebx_1036 | 0x01;
								esp_1027->t0010->u2 = ebx_1036;
l0805C22B:
								word32 eax_1438 = ebp_1125->dw188C;
								esi_1435 = (word32) ecx_1112 + 8;
								al_1800 = (byte) eax_1438;
								eax_24_8_1815 = SLICE(eax_1438, word24, 8);
								if (eax_1438 == 0x00)
									goto l0805B66F;
								goto l0805BB20;
							}
							eax_1200 = malloc_printerr(out ecx_1112, out edx_1144);
l0805C34D:
							if (*((word32) eax_1200 + 20) == ecx_1112)
							{
								Eq_2 edi_1373 = *((word32) ecx_1112 + 20);
								if (*((word32) edi_1373 + 16) == ecx_1112)
								{
									if (*((word32) edx_1144 + 16) != 0x00)
									{
										*((word32) eax_1200 + 20) = edi_1373;
										edx_1144 = *((word32) ecx_1112 + 20);
										*((word32) edx_1144 + 16) = eax_1200;
										goto l0805C1AB;
									}
									if (eax_1200 != ecx_1112)
									{
										*((word32) edx_1144 + 16) = eax_1200;
										Eq_2 eax_1382 = *((word32) ecx_1112 + 16);
										*((word32) edx_1144 + 20) = edi_1373;
										*((word32) eax_1382 + 20) = edx_1144;
										*((word32) *((word32) ecx_1112 + 20) + 16) = edx_1144;
										goto l0805C1AB;
									}
									goto l0805C4AE;
								}
							}
							goto l0805C4A3;
						}
						goto l0805C279;
					}
l0805C293:
					word32 edx_2621;
					word32 ecx_2620;
					malloc_printerr(out ecx_2620, out edx_2621);
					goto l0805C29E;
				}
			}
			ui32 eax_747 = esp_1027[4];
			edi_1065 = eax_747 + 0x01 >> 0x05;
			Eq_2 edx_1274 = (word32) esi_1030 + 56 + eax_747 * 0x08;
			uint32 eax_754 = 0x01 << (byte) eax_747 + 0x01;
			uint32 ebx_757 = *((word32) esi_1030 + (edi_1065 * 0x04 + 1080));
l0805BCA8:
			if (eax_754 > ebx_757 || eax_754 == 0x00)
			{
				do
				{
					edi_1065 = (word32) edi_1065 + 1;
					if (edi_1065 == 0x04)
					{
						Eq_2 ebx_781 = *((word32) esi_1030 + 56);
						ui32 eax_782 = *((word32) ebx_781 + 4);
						if (*((word32) esi_1030 + 0x0454) < (eax_782 & ~0x07))
							goto l0805C26E;
						union Eq_2 * ecx_788 = esp_1027->t0010;
						if ((char *) ecx_788 + 16 <= (eax_782 & ~0x07))
						{
							edx_1144 = ebx_781 + ecx_788;
							esp_1027->ptr0004->t0038 = edx_1144;
							Eq_2 eax_792 = (eax_782 & ~0x07) - ecx_788;
							ecx_1112 = eax_792;
							if (esp_1027->ptr0004 == &g_t80CE500)
								edi_1065.u0 = 0x00;
							*((word32) ebx_781 + 4) = ecx_788 | edi_1065 | 0x01;
							*((word32) edx_1144 + 4) = eax_792 | 0x01;
							Eq_2 eax_820 = perturb_byte;
							esi_1435 = (word32) ebx_781 + 8;
							al_1800 = (byte) eax_820;
							eax_24_8_1815 = SLICE(eax_820, word24, 8);
							if (eax_820 != 0x00)
								goto l0805BB20;
							goto l0805B66F;
						}
						else
						{
							if (*((word32) esi_1030 + 8) == 0x00)
								goto l0805C2E9;
							word32 ebp_2625;
							word32 edi_2626;
							word32 ebx_2624;
							word32 edx_2623;
							word32 ecx_2622;
							malloc_consolidate(esi_1030, gs, out ecx_2622, out edx_2623, out ebx_2624, out ebp_2625, out edi_2626);
							esp_1027[4] = esp_1027[9];
							if (esp_1027->t0010 > (union Eq_2 *) 1007)
							{
								esp_1027[4] = (struct Eq_32659) esp_1027->dw0038;
								if (esp_1027->dw0070 > 0x2D)
								{
									esp_1027[4] = (struct Eq_32659) esp_1027->dw0044;
									if (esp_1027->dw0074 > 0x14)
									{
										esp_1027[4] = esp_1027[7];
										if (esp_1027[0x0A] > 0x0A)
										{
											ui32 eax_854 = esp_1027->dw0068;
											if (esp_1027[8] > 0x04)
												eax_854 = esp_1027->dw0064;
											esp_1027[4] = (struct Eq_32659) eax_854;
										}
									}
								}
							}
							esp_1027->ptr0014 = (Eq_34497 (*)[]) gs->tFFFFFFE4;
							goto l0805B7A1;
						}
					}
					ebx_757 = (uint32) *((word32) esi_1030 + (edi_1065 * 0x04 + 1080));
				} while (ebx_757 == 0x00);
				edx_1274 = (word32) esi_1030 + 48 + (edi_1065 << 0x06) * 0x04;
				eax_754 = 0x01;
			}
			do
			{
				if ((eax_754 & ebx_757) != 0x00)
				{
					ecx_1112 = *((word32) edx_1274 + 0x0C);
					if (edx_1274 != ecx_1112)
						goto l0805C155;
					ebx_757 &= ~eax_754;
					*((word32) esi_1030 + (edi_1065 * 0x04 + 1080)) = ebx_757;
					edx_1274 = (word32) edx_1274 + 8;
					eax_754 *= 0x02;
					goto l0805BCA8;
				}
				edx_1274 = (word32) edx_1274 + 8;
				eax_754 *= 0x02;
			} while (eax_754 != 0x00);
			struct Eq_33316 * esp_920 = esp_1027 - 0x0C;
			esp_920->ptrFFFFFFFC = 0x080A39AC;
			word32 edx_2606;
			word32 ecx_2605;
			word32 eax_2604;
			__malloc_assert(0x080A2A84, 4024, 0x080A2925, out eax_2604, out ecx_2605, out edx_2606);
			esp_1027 = esp_920 - 4;
l0805BCF0:
			word32 ecx_2595;
			eax_1039 = malloc_printerr(out ecx_2595, out edx_942);
l0805BD00:
			esp_1027[3] = (struct Eq_32659) (edx_942 + 0x31);
l0805BBF3:
			struct Eq_33374 * ecx_1034 = (word32) esi_1030 + 56 + esp_1027[3] *32 0x08;
			edx_1035 = ecx_1034->t0000;
			ebx_1036 = ecx_1034 - 0x08;
			if (ecx_1034 - 0x08 != edx_1035)
			{
				esp_1027->dw007C = eax_1039 | 0x01;
				struct Eq_33373 * eax_1044 = ecx_1034->ptr0004;
				esp_1027[5] = (struct Eq_32659) eax_1044;
				uint32 eax_1046 = eax_1044->dw0004;
				if (((byte) eax_1046 & 0x04) == 0x00)
				{
					if (eax_1046 > esp_1027->dw007C)
					{
						Eq_2 eax_1565 = *((word32) edx_1035 + 20);
						ecx_1564 = esp_1027[3];
						*((word32) edi_1065 + 16) = edx_1035;
						*((word32) edi_1065 + 20) = eax_1565;
						*((word32) eax_1565 + 16) = edi_1065;
						*((word32) edx_1035 + 20) = edi_1065;
						goto l0805B8A8;
					}
l0805BFF0:
					Eq_2 eax_1091 = *((word32) edx_1035 + 4);
					if (((byte) eax_1091 & 0x04) == 0x00)
					{
						Eq_2 ecx_1204 = esp_1027->dw007C;
						do
						{
							bool v46_1911 = ecx_1204 == eax_1091;
							if (ecx_1204 >= eax_1091)
								goto l0805C030;
							edx_1035 = *((word32) edx_1035 + 16);
							eax_1091 = *((word32) edx_1035 + 4);
						} while (((byte) eax_1091 & 0x04) == 0x00);
						struct Eq_33532 * esp_1220 = esp_1027 - 0x0C;
						esp_1220->ptrFFFFFFFC = 0x080A39AC;
						esp_1027 = esp_1220 - 4;
						word32 eax_2611;
						word32 ecx_2612;
						v46_1911 = SLICE(__malloc_assert(0x080A2A51, 3863, 0x080A2925, out eax_2611, out ecx_2612, out edx_1035), bool, 2);
l0805C030:
						if (v46_1911)
						{
							ebx_1036 = *((word32) edx_1035 + 8);
							goto l0805C056;
						}
						Eq_2 eax_1242 = *((word32) edx_1035 + 20);
						*((word32) edi_1065 + 16) = edx_1035;
						*((word32) edi_1065 + 20) = eax_1242;
						if (*((word32) *((word32) edx_1035 + 20) + 16) == edx_1035)
						{
							*((word32) edx_1035 + 20) = edi_1065;
							*((word32) *((word32) edi_1065 + 20) + 16) = edi_1065;
							ebx_1036 = edx_1035;
l0805C056:
							Eq_2 eax_1289 = *((word32) ebx_1036 + 0x0C);
							esp_1027[5] = (struct Eq_32659) eax_1289;
							if (*((word32) eax_1289 + 8) != ebx_1036)
							{
								malloc_printerr(out ecx_1302, out edx_1301);
								goto l0805C4C4;
							}
							ecx_1564 = esp_1027[3];
							goto l0805B8A8;
						}
					}
					else
					{
						struct Eq_33495 * esp_1099 = esp_1027 - 0x0C;
						esp_1099->ptrFFFFFFFC = 0x080A39AC;
						word32 edx_2610;
						word32 eax_2609;
						__malloc_assert(0x080A2A51, 0x0F13, 0x080A2925, out eax_2609, out ecx_1112, out edx_2610);
						esp_1027 = esp_1099 - 4;
l0805C155:
						Eq_2 eax_1117 = *((word32) ecx_1112 + 4);
						dwLoc04_1913 = ebp;
						dwLoc08_1914 = edi;
						dwLoc0C_1915 = esi;
						dwLoc10_1916 = ebx;
						ebp_1125 = (struct Eq_32693 *) &g_t80CE000;
						esi_1030 = esp_1027->t0010;
						ebx_1036 = eax_1117 & ~0x07;
						if (esi_1030 <= (eax_1117 & ~0x07))
						{
							ui32 * eax_1140 = (word32) ecx_1112 + (eax_1117 & ~0x07);
							esp_1027->t0010 = eax_1140;
							if (*eax_1140 != (eax_1117 & ~0x07))
								goto l0805C29E;
							edx_1144 = *((word32) ecx_1112 + 8);
							Eq_2 eax_1145 = *((word32) ecx_1112 + 0x0C);
							if (*((word32) edx_1144 + 0x0C) == ecx_1112 && *((word32) eax_1145 + 8) == ecx_1112)
							{
								*((word32) edx_1144 + 0x0C) = eax_1145;
								*((word32) eax_1145 + 8) = edx_1144;
								if (eax_1117 > 1007)
								{
									eax_1200 = *((word32) ecx_1112 + 16);
									if (eax_1200 != 0x00)
										goto l0805C34D;
								}
								goto l0805C1AB;
							}
							goto l0805C293;
						}
						struct Eq_33629 * esp_1127 = esp_1027 - 0x0C;
						esp_1127->ptrFFFFFFFC = 0x080A39AC;
						word32 edx_2617;
						word32 ecx_2616;
						word32 eax_2615;
						__malloc_assert(0x080A3530, 4043, 0x080A2925, out eax_2615, out ecx_2616, out edx_2617);
						esp_1027 = esp_1127 - 4;
					}
					word32 ecx_2613;
					word32 edx_2614;
					malloc_printerr(out ecx_2613, out edx_2614);
l0805C26E:
					malloc_printerr(out ecx_1112, out edx_1144);
					dwLoc04_1913 = ebp;
					dwLoc08_1914 = edi;
					dwLoc0C_1915 = esi;
					dwLoc10_1916 = ebx;
					ebp_1125 = (struct Eq_32693 *) &g_t80CE000;
l0805C279:
					struct Eq_33709 * eax_1340 = esp_1027->t0010;
					eax_1340->dw0004 |= 0x01;
					if (esp_1027->ptr0004 != (char *) ebp_1125 + 0x0500)
						*((word32) ecx_1112 + 4) |= 0x04;
					goto l0805C22B;
				}
				goto l0805BFC8;
			}
			goto l0805BF80;
		}
	}
	else if (esi_1637 > 1007)
	{
		uint32 ebx_74 = esi_1637 >> 0x06;
		uint32 edi_75 = esi_1637 >> 0x09;
		uint32 ecx_76 = esi_1637 >> 0x0C;
		uint32 eax_84 = esi_1637 >> 0x0F;
		if (*((word32) eax + 8) != 0x00)
		{
			word32 edx_2587;
			word32 ebx_2588;
			word32 ebp_2589;
			word32 edi_2590;
			word32 ecx_2586;
			malloc_consolidate(eax, gs, out ecx_2586, out edx_2587, out ebx_2588, out ebp_2589, out edi_2590);
		}
l0805B73F:
		uint32 eax_254 = esi_1637 - 0x01;
		gs->tFFFFFFE4 == 0x00;
		esi_1030 = eax;
l0805B7A1:
		ptr32 ebx_868 = esp_1027->dw0028;
		edi_1065 = *((word32) esi_1030 + 0x0044);
		esp_1027->dw001C = 0x00;
		esp_1027->dw0040 = 0x00;
		up32 eax_880 = (ebx_868 + 0x3C)->dw80CE000;
		esp_1027->dw004C = eax_880;
		word32 eax_883 = (ebx_868 + 0x38)->dw80CE000;
		esp_1027->b005B = (int8) (eax_880 != 0x00);
		esp_1027[6] = (struct Eq_32659) eax_883;
		esp_1027->ptr0050 = (struct Eq_152146 *) (esp_1027->ptr0014 + esp_1027->dw002C)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
		goto l0805B7DB;
	}
l0805B978:
	edx_1301 = (word32) eax + 64 + (esi_1637 >> 0x04) * 0x08;
	edi_1065 = *((word32) edx_1301 + 4);
	ecx_1464 = edx_1301 - 0x08;
	if (edx_1301 - 0x08 != edi_1065)
	{
		Eq_2 eax_298 = *((word32) edi_1065 + 0x0C);
		if (*((word32) eax_298 + 8) == edi_1065)
		{
			*((word32) esi_1637 + ((word32) edi_1065 + 4)) |= 0x01;
			*((word32) edx_1301 + 4) = eax_298;
			*((word32) eax_298 + 8) = edx_1301 - 0x08;
			if (eax != 0x080CE500)
				*((word32) edi_1065 + 4) |= 0x04;
			if (gs->tFFFFFFE4 != 0x00 && g_dw80CE4D0 > esi_1637 - (struct Eq_34771 *) 0x01 >> 0x04)
			{
				while (true)
				{
					Eq_2 ebx_542 = (int32) esp_1027->t0010;
					esi_497 = esp_1027[2];
					do
					{
						if (ebx_542 >= esi_497)
							goto l0805BA28;
						eax_495 = *((word32) edx_1301 + 4);
						if (ecx_1464 == eax_495)
							goto l0805BA28;
					} while (eax_495 == 0x00);
l0805BEF0:
					esp_1027[2] = (struct Eq_32659) esi_497;
					struct Eq_34678 * ebx_503 = esp_1027->ptr0014;
					esp_1027->dw0028 = (word32) *((word32) eax_495 + 0x0C);
					int32 esi_505 = esp_1027[3];
					(word32) eax_495 + 4 + esi_505 |= 0x01;
					if (esp_1027->ptr0004 != ebx_503)
						*((word32) eax_495 + 4) |= 0x04;
					Eq_2 esi_517 = esp_1027->dw0028;
					word32 ebx_518 = esp_1027->dw0008;
					esp_1027->t0010 = (word32) esp_1027->t0010 + 1;
					*((word32) edx_1301 + 4) = esi_517;
					*((word32) esi_517 + 8) = ecx_1464;
					struct Eq_34590 * eax_520 = (word32) eax_495 + 8;
					struct Eq_34593 * esi_530 = esp_1027->dw0020;
					eax_520->dw0004 = ebx_518;
					eax_520->ptr0000 = esi_530->ptr0040;
					Eq_150975 ebx_534[] = esp_1027->dw0008;
					esi_530->ptr0040 = eax_520;
					ebx_534[esp_1027->dw001C].t0000 = esp_1027->t0010;
				}
			}
l0805BA28:
			Eq_2 eax_1539 = (word32) edi_1065 + 8;
			word32 eax_1547 = ebp_1474->dw188C;
			esp_1027 = fp - 0x009C;
			esi_1435 = eax_1539;
			al_1800 = (byte) eax_1547;
			eax_24_8_1815 = SLICE(eax_1547, word24, 8);
			if (eax_1547 == 0x00)
			{
				ecxOut = ecx_1464;
				edxOut = edx_1301;
				ebxOut = dwLoc10_1916;
				ebpOut = dwLoc04_1913;
				esiOut = dwLoc0C_1915;
				ediOut = dwLoc08_1914;
				return eax_1539;
			}
			goto l0805BB20;
		}
		word32 ecx_2630;
		word32 edx_2631;
		malloc_printerr(out ecx_2630, out edx_2631);
		esi_1030 = esi_1637;
l0805BFC8:
		struct Eq_33390 * esp_1058 = esp_1027 - 0x0C;
		esp_1058->ptrFFFFFFFC = 0x080A39AC;
		word32 ecx_2608;
		word32 eax_2607;
		__malloc_assert(134883894, 0x0F06, 0x080A2925, out eax_2607, out ecx_2608, out edx_1035);
		esp_1027 = esp_1058 - 4;
		goto l0805BFF0;
	}
	goto l0805B73F;
}

// 0805C510: void malloc_check(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_26908 dwArg04)
// Called from:
//      memalign_check
//      realloc_check
void malloc_check(Eq_2 edi, struct Eq_9 * gs, Eq_26908 dwArg04)
{
	if (dwArg04 == ~0x00)
		gs->tFFFFFFE0.u0 = 0x0C;
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_35;
		if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_35))
			__lll_lock_wait_private(eax_35, 0x080CE500, gs);
		word32 ebx_49;
		word32 edx_150;
		top_check(out edx_150, out ebx_49);
		word32 ebp_152;
		word32 ecx_151;
		struct Eq_34817 * ebx_63;
		Eq_2 edx_66;
		Eq_26908 esi_67;
		word32 edi_153;
		Eq_2 eax_68 = _int_malloc(ebx_49 + 0x0500, (word32) dwArg04 + 1, edi, gs, out ecx_151, out edx_66, out ebx_63, out ebp_152, out esi_67, out edi_153);
		if (gs->t000C != 0x00)
			__lock();
		word32 v13_80 = ebx_63->dw0500 - 0x01;
		ebx_63->dw0500 = v13_80;
		if (v13_80 != 0x00)
			__lll_unlock_wake_private(&ebx_63->dw0500, eax_68, edx_66, gs);
		mem2mem_check(eax_68, esi_67);
	}
}

// 0805C5B0: void tcache_init.part.6(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_malloc
//      free
//      __realloc
//      __libc_calloc
void tcache_init.part.6(struct Eq_9 * gs)
{
	Eq_2 ecx_106;
	Eq_2 edx_104;
	Eq_2 ebx_101 = gs->tFFFFFFEC;
	if (ebx_101 != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_58;
		if (!__cmpxchg(*ebx_101, 0x01, 0x00, out eax_58))
			__lll_lock_wait_private(eax_58, ebx_101, gs);
	}
	else
	{
		word32 edx_217;
		word32 esi_219;
		word32 edi_220;
		word32 ebx_218;
		word32 ecx_216;
		Eq_2 eax_19 = get_free_list(gs, out ecx_216, out edx_217, out ebx_218, out esi_219, out edi_220);
		ebx_101 = eax_19;
		if (eax_19 == 0x00)
		{
			word32 edi_228;
			word32 ebx_226;
			word32 esi_227;
			Eq_2 eax_31 = arena_get2.part.5(0x0140, 0x00, gs, out ebx_226, out esi_227, out edi_228);
			word32 edi_234;
			word32 esi_233;
			word32 ebx_231;
			word32 ebp_232;
			word32 ecx_230;
			Eq_2 eax_37 = _int_malloc(eax, 0x0140, edi, gs, out ecx_230, out edx_104, out ebx_231, out ebp_232, out esi_233, out edi_234);
			ebx_101 = eax_31;
			ecx_106 = eax_37;
			if (eax_37 != 0x00 || eax_31 == 0x00)
				goto l0805C6A2;
l0805C688:
			ebx_101 = arena_get_retry(ebx_101, ecx, 0x0140, gs);
			word32 ebx_237;
			word32 ecx_236;
			word32 ebp_238;
			word32 esi_239;
			word32 edi_240;
			ecx_106 = _int_malloc(eax, 0x0140, edi, gs, out ecx_236, out edx_104, out ebx_237, out ebp_238, out esi_239, out edi_240);
l0805C6A2:
			if (ebx_101 == 0x00)
				goto l0805C61B;
l0805C604:
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v14_122 = *ebx_101 - 0x01;
			*ebx_101 = v14_122;
			if (v14_122 != 0x00)
				__lll_unlock_wake_private(ebx_101, ecx_106, edx_104, gs);
l0805C61B:
			if (ecx_106 != 0x00)
			{
				gs->tFFFFFFE4 = ecx_106;
				*ecx_106 = 0x00;
				*((word32) ecx_106 + 316) = 0x00;
				Eq_35001 edi_139 = (word32) ecx_106 + 4;
				word32 * edi_143 = edi_139 & ~0x03;
				word32 ecx_148;
				for (ecx_148 = ecx_106 - (edi_139 & ~0x03) + 0x0140 >>u 0x02; ecx_148 != 0x00; --ecx_148)
				{
					*edi_143 = 0x00;
					++edi_143;
				}
			}
			return;
		}
	}
	word32 ecx_221;
	word32 edi_225;
	word32 ebx_222;
	word32 esi_224;
	word32 ebp_223;
	Eq_2 eax_80 = _int_malloc(ebx_101, 0x0140, edi, gs, out ecx_221, out edx_104, out ebx_222, out ebp_223, out esi_224, out edi_225);
	ecx_106 = eax_80;
	if (eax_80 != 0x00)
		goto l0805C604;
	goto l0805C688;
}

// 0805C6B0: Register Eq_2 _int_memalign(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_9) gsOut)
// Called from:
//      memalign_check
//      _mid_memalign
Eq_2 _int_memalign(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, struct Eq_9 & gsOut)
{
	word24 eax_24_8_33 = SLICE(eax, word24, 8);
	Eq_2 esi_25;
	Eq_2 ebx_28;
	if (ecx > 0x04)
	{
		ebx_28 = (word32) ecx + 19 & ~0x0F;
		esi_25 = SEQ(eax_24_8_33, (int8) (ebx_28 > ~0x20));
	}
	else
	{
		esi_25.u0 = 0x00;
		ebx_28.u0 = 0x10;
	}
	if (ebx_28 >= ecx)
	{
		ecx = esi_25;
		if ((byte) esi_25 == 0x00)
		{
			ecx = ~0x10 - edx;
			if (ecx >= ebx_28)
			{
				Eq_2 edi_79;
				word32 esi_391;
				Eq_2 ebx_181;
				word32 ebp_180;
				Eq_2 edx_124;
				Eq_2 ecx_123;
				Eq_2 eax_82 = _int_malloc(eax, (word32) edx + ((byte) ebx_28.u0 + 16), edx, gs, out ecx_123, out edx_124, out ebx_181, out ebp_180, out esi_391, out edi_79);
				Eq_2 esi_135 = eax_82;
				if (eax_82 != 0x00)
				{
					ecx_123 = eax_82 - (struct Eq_35080 *) 0x08;
					edx_124 = (uint32) ((uint64) eax_82 % edi_79);
					Eq_2 dwLoc34_305 = eax_82 - (struct Eq_35080 *) 0x08;
					if (edx_124 == 0x00)
					{
l0805C726:
						Eq_35104 eax_221 = *((word32) dwLoc34_305 + 4);
						if (((byte) eax_221 & 0x02) == 0x00)
						{
							edx_124 = (word32) ebx_181 + 16;
							if (edx_124 < (eax_221 & ~0x07))
							{
								ui32 eax_231 = (eax_221 & ~0x07) - ebx_181;
								word32 edx_232 = dwLoc34_305 + ebx_181;
								if (eax != ebp_180 + 0x0500)
									eax_231 |= 0x04;
								*((word32) edx_232 + 4) = eax_231 | 0x01;
								*((word32) dwLoc34_305 + 4) = ebx_181 | *((word32) dwLoc34_305 + 4) & 0x07;
								word32 ebx_392;
								word32 ebp_393;
								word32 edi_394;
								_int_free(eax, edx_232, dwLoc34_305, gs, out ecx_123, out edx_124, out ebx_392, out ebp_393, out esi_135, out edi_394, out gs);
							}
						}
						goto l0805C779;
					}
					ui32 eax_105 = (word32) edi_79 + (eax_82 - 0x01) & -edi_79;
					Eq_2 dwLoc2C_306 = eax_105 - 0x08;
					uint32 eax_109 = eax_105 - 0x08 - (eax_82 - (struct Eq_35080 *) 0x08);
					if (eax_109 <= 0x0F)
					{
						Eq_2 edx_112 = (word32) edi_79 + (eax_105 - 0x08);
						dwLoc2C_306 = edx_112;
						eax_109 = edx_112 - (eax_82 - (struct Eq_35080 *) 0x08);
					}
					Eq_2 edx_119 = *((word32) eax_82 - 4);
					ecx_123 = (edx_119 & ~0x07) - eax_109;
					edx_124 = edx_119 & 0x02;
					ui32 dwLoc24_309 = edx_119 & 0x02;
					if ((edx_119 & 0x02) == 0x00)
					{
						Eq_2 dwLoc20_311 = ecx_123;
						if (eax != ebp_180 + 0x0500)
						{
							dwLoc24_309 = 0x04;
							dwLoc20_311 = ecx_123 | 0x04;
						}
						*((word32) dwLoc2C_306 + 4) = dwLoc20_311 | 0x01;
						*((word32) ecx_123 + ((word32) dwLoc2C_306 + 4)) |= 0x01;
						*((word32) eax_82 - 4) = eax_109 | *((word32) eax_82 - 4) & 0x07 | dwLoc24_309;
						ui32 edi_183;
						word32 edx_395;
						word32 esi_396;
						_int_free(eax, eax_82 - (struct Eq_35080 *) 0x08, edi_79, gs, out ecx_123, out edx_395, out ebx_181, out ebp_180, out esi_396, out edi_183, out gs);
						if (ebx_181 <= ecx_123)
						{
							esi_135 = (word32) dwLoc2C_306 + 8;
							edx_124 = (uint32) ((uint64) ((word32) dwLoc2C_306 + 8) % edi_183);
							if (edx_124 == 0x00)
							{
								dwLoc34_305 = dwLoc2C_306;
								goto l0805C726;
							}
						}
						word32 eax_397;
						word32 ecx_398;
						word32 edx_399;
						__malloc_assert(ebp_180 + ~0x0002AA77, 4742, ebp_180 + ~0x0002B6DA, out eax_397, out ecx_398, out edx_399);
					}
					*dwLoc2C_306 = (word32) *((word32) eax_82 - 8) + eax_109;
					*((word32) dwLoc2C_306 + 4) = ecx_123 | 0x02;
					esi_135 = (word32) dwLoc2C_306 + 8;
				}
l0805C779:
				ecxOut = ecx_123;
				edxOut = edx_124;
				gsOut = gs;
				return esi_135;
			}
		}
	}
	gs->tFFFFFFE0.u0 = 0x0C;
	ecxOut = ecx;
	edxOut = edx;
	gsOut = gs;
	return 0x00;
}

// 0805C8C0: void memalign_check(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack uint32 dwArg04, Stack Eq_26908 dwArg08)
// Called from:
//      _int_memalign
void memalign_check(Eq_2 edi, struct Eq_9 * gs, uint32 dwArg04, Eq_26908 dwArg08)
{
	if (dwArg04 <= 0x10)
		malloc_check(edi, gs, dwArg08);
	else if (dwArg04 > 0x80000000)
		gs->tFFFFFFE0.u0 = 22;
	else if (dwArg08 > ~0x10 - dwArg04)
		gs->tFFFFFFE0.u0 = 0x0C;
	else
	{
		if ((dwArg04 - 0x01 & dwArg04) != 0x00 && dwArg04 > 0x20)
		{
			uint32 eax_72 = 0x20;
			do
				eax_72 *= 0x02;
			while (dwArg04 > eax_72);
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_94;
		if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_94))
			__lll_lock_wait_private(eax_94, 0x080CE500, gs);
		Eq_2 ebx_108;
		word32 edx_227;
		top_check(out edx_227, out ebx_108);
		Eq_2 edx_128;
		word32 ecx_228;
		struct Eq_35309 * gs_229;
		Eq_2 eax_126 = _int_memalign(0x080CE500, (word32) dwArg08 + 1, ebx_108, gs, out ecx_228, out edx_128, out gs_229);
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_136 = g_t80CE500 - 0x01;
		g_t80CE500 = v15_136;
		if (v15_136 != 0x00)
			__lll_unlock_wake_private(0x080CE500, eax_126, edx_128, gs);
		mem2mem_check(eax_126, dwArg08);
	}
}

// 0805C9F0: Register (ptr32 Eq_9) free_check.part.3(Register Eq_2 eax, Register Eq_2 edi, Register (ptr32 Eq_9) gs)
// Called from:
//      free_check
//      realloc_check
struct Eq_9 * free_check.part.3(Eq_2 eax, Eq_2 edi, struct Eq_9 * gs)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_24;
	if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_24))
		__lll_lock_wait_private(eax_24, 0x080CE500, gs);
	Eq_2 ecx_42;
	word32 edx_213;
	Eq_2 eax_40 = mem2chunk_check(eax, null, out ecx_42, out edx_213);
	if (eax_40 == 0x00)
	{
		word32 edx_215;
		word32 ecx_214;
		malloc_printerr(out ecx_214, out edx_215);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		free_check(stackArg4);
		return gs;
	}
	else if ((*((word32) eax_40 + 4) & 0x02) != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_75 = g_t80CE500 - 0x01;
		g_t80CE500 = v14_75;
		if (v14_75 != 0x00)
			__lll_unlock_wake_private(0x080CE500, ecx_42, eax_40, gs);
		word32 ecx_220;
		word32 edx_221;
		word32 ebx_222;
		munmap_chunk(eax_40, gs, out ecx_220, out edx_221, out ebx_222);
		return gs;
	}
	else
	{
		word32 edi_218;
		struct Eq_35392 * ebx_115;
		Eq_2 ecx_116;
		Eq_2 edx_118;
		struct Eq_9 * gs_120;
		word32 esi_217;
		word32 ebp_216;
		_int_free(0x080CE500, eax_40, edi, gs, out ecx_116, out edx_118, out ebx_115, out ebp_216, out esi_217, out edi_218, out gs_120);
		if (gs_120->t000C != 0x00)
			__lock();
		word32 v13_131 = ebx_115->dw0500 - 0x01;
		ebx_115->dw0500 = v13_131;
		if (v13_131 != 0x00)
			__lll_unlock_wake_private(&ebx_115->dw0500, ecx_116, edx_118, gs_120);
		return gs_120;
	}
}

// 0805CAB0: void free_check(Stack Eq_2 dwArg04)
// Called from:
//      free_check.part.3
void free_check(Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	free_check.part.3(eax, edi, gs);
}

// 0805CAD0: Register Eq_2 _int_realloc(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 esi, Register Eq_2 edi, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_35471 edxOut)
// Called from:
//      realloc_check
//      __realloc
Eq_2 _int_realloc(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 esi, Eq_2 edi, Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_35471 & edxOut)
{
	Eq_2 edi_112;
	Eq_35471 edx_107;
	Eq_2 ecx_145;
	ptr32 esp_167 = fp - 0x3C;
	Eq_2 eax_23 = *((word32) edx + 4);
	if (eax_23 > 0x08)
	{
		esi = edx;
		Eq_2 edx_27 = *((word32) eax + 0x0454);
		if (edx_27 > ecx)
		{
			Eq_2 ecx_153;
			edi_112 = eax_23 & 0x02;
			dwLoc28 = eax_23 & 0x02;
			if ((eax_23 & 0x02) != 0x00)
			{
l0805CCD8:
				struct Eq_35504 * esp_179 = esp_167 - 0x0C;
				esp_179->ptrFFFFFFFC = 134887744;
				word32 eax_615;
				word32 edx_616;
				__malloc_assert(134884038, 0x11DA, 0x080A2925, out eax_615, out ecx_153, out edx_616);
				esp_167 = esp_179 - 4;
				goto l0805CD00;
			}
			word32 edi_51 = edx + ecx;
			Eq_2 dwLoc2C_439 = edi_51;
			edi = *((word32) edi_51 + 4);
			if (edi > 0x08 && edx_27 > (edi & ~0x07))
			{
				Eq_2 eax_161;
				eax_161 = eax_23;
				if (ecx >= dwArg04)
				{
l0805CBD0:
					Eq_35542 edi_343 = ecx - dwArg04;
					ui32 eax_348 = eax_161 & 0x07;
					if (edi_343 <= 0x0F)
					{
						edx_107.u0 = 0x04;
						if (eax == 0x080CE500)
							edx_107 = eax_23 & 0x02;
						ecx_145 = ecx | eax_348 | edx_107;
						*((word32) edx + 4) = ecx_145;
						*((word32) dwLoc2C_439 + 4) |= 0x01;
					}
					else
					{
						word32 edx_358 = dwArg04 + edx;
						if (eax != 0x080CE500)
						{
							dwLoc28.u0 = 0x04;
							edi_343 |= 0x04;
						}
						*((word32) edx + 4) = eax_348 | dwArg04 | dwLoc28;
						Eq_2 edi_371 = edi_343 | 0x01;
						*((word32) edx_358 + 4) = edi_371;
						*((word32) dwLoc2C_439 + 4) |= 0x01;
						word32 esi_640;
						word32 edi_641;
						struct Eq_35836 * gs_642;
						word32 ebp_639;
						word32 ebx_638;
						_int_free(eax, edx_358, edi_371, gs, out ecx_145, out edx_107, out ebx_638, out ebp_639, out esi_640, out edi_641, out gs_642);
					}
					edi_112 = (word32) edx + 8;
					goto l0805CC04;
				}
				if (*((word32) eax + 56) != edi_51)
				{
					struct Eq_35558 * edx_123 = (word32) edi_51 + (edi & ~0x07);
					if ((edx_123->b0004 & 0x01) == 0x00)
					{
						Eq_2 ebx_127 = (word32) ecx + (edi & ~0x07);
						if (dwArg04 <= ebx_127)
						{
							Eq_2 ecx_233;
							if (edx_123->dw0000 == (edi & ~0x07))
							{
								ecx_233 = *((word32) edi_51 + 8);
								Eq_2 edx_234 = *((word32) edi_51 + 0x0C);
								if (*((word32) ecx_233 + 0x0C) == edi_51 && *((word32) edx_234 + 8) == edi_51)
								{
									*((word32) ecx_233 + 0x0C) = edx_234;
									*((word32) edx_234 + 8) = ecx_233;
									if (edi <= 1007)
									{
l0805CBBB:
										ecx = ebx_127;
										dwLoc2C_439 = edx + ebx_127;
										eax_161 = eax_23;
										goto l0805CBD0;
									}
									edi = *((word32) edi_51 + 16);
									eax_161 = eax_23;
									if (edi == 0x00)
										goto l0805CBBB;
l0805CDA6:
									Eq_2 ebx_278 = edi_51;
									if (*((word32) edi + 20) == edi_51)
									{
										Eq_2 edx_282 = *((word32) edi_51 + 20);
										if (*((word32) edx_282 + 16) == edi_51)
										{
											ebx_278 = ebx_127 + edx;
											if (*((word32) ecx_233 + 16) != 0x00)
											{
												*((word32) edi + 20) = edx_282;
												*((word32) *((word32) edi_51 + 20) + 16) = edi;
												dwLoc2C_439 = ebx_278;
												ecx = ebx_127;
												goto l0805CBD0;
											}
											if (edi != edi_51)
											{
												*((word32) ecx_233 + 16) = edi;
												*((word32) ecx_233 + 20) = edx_282;
												*((word32) *((word32) edi_51 + 16) + 20) = ecx_233;
												*((word32) *((word32) edi_51 + 20) + 16) = ecx_233;
												dwLoc2C_439 = ebx_278;
												ecx = ebx_127;
												goto l0805CBD0;
											}
l0805CE11:
											*((word32) ecx_233 + 20) = ecx_233;
											*((word32) ecx_233 + 16) = ecx_233;
											ecx = ebx_127;
											dwLoc2C_439 = ebx_278;
											goto l0805CBD0;
										}
									}
									word32 edx_627;
									eax_161 = malloc_printerr(out ecx_233, out edx_627);
									goto l0805CE11;
								}
								word32 edx_626;
								word32 ecx_625;
								malloc_printerr(out ecx_625, out edx_626);
							}
							word32 edx_624;
							eax_161 = malloc_printerr(out ecx_233, out edx_624);
							goto l0805CDA6;
						}
					}
l0805CC75:
					word32 esi_622;
					word32 edi_623;
					word32 ebp_621;
					word32 ebx_620;
					Eq_2 eax_143 = _int_malloc(eax, dwArg04 - 0x0F, edi, gs, out ecx_145, out edx_107, out ebx_620, out ebp_621, out esi_622, out edi_623);
					edi_112 = eax_143;
					if (eax_143 == 0x00)
						goto l0805CC04;
					Eq_2 eax_151 = *((word32) eax_143 - 4);
					ecx_153 = ecx;
					if (edi_51 != eax_143 - 0x08)
					{
l0805CD00:
						struct Eq_35701 * esp_196 = esp_167 - 0x04;
						esp_196->tFFFFFFFC = ecx_153 - (struct Eq_35704 *) 0x04;
						Mem207[esp_196 + -8:word32] = edx + 0x08;
						esp_196->tFFFFFFF4 = edi_112;
						word32 edx_629;
						word32 ecx_628;
						memcpy(esp_196->tFFFFFFF4, esp_196->tFFFFFFF8, esp_196->tFFFFFFFC, out ecx_628, out edx_629);
						word32 ebx_630;
						word32 esi_632;
						word32 edi_633;
						struct Eq_35735 * gs_634;
						word32 ebp_631;
						_int_free(esp_196->t0010, edx, edi_112, gs, out ecx_145, out edx_107, out ebx_630, out ebp_631, out esi_632, out edi_633, out gs_634);
						goto l0805CC04;
					}
					ecx += eax_151 & ~0x07;
					if (dwArg04 > ecx)
					{
						word32 ecx_636;
						word32 edx_637;
						word32 eax_635;
						__malloc_assert(134886864, 0x121F, 0x080A2925, out eax_635, out ecx_636, out edx_637);
						esp_167 = fp - 0x4C;
						goto l0805CCD8;
					}
					eax_161 = *((word32) edx + 4);
					dwLoc2C_439 = edx + ecx;
					goto l0805CBD0;
				}
				edi = (word32) ecx + (edi & ~0x07);
				if (dwArg04 + 0x10 >u edi)
					goto l0805CC75;
l0805CD50:
				ecx_145 = eax;
				ui32 eax_95 = eax_23 & 0x07;
				edx_107.u0 = 0x04;
				if (eax == 0x080CE500)
					edx_107 = dwLoc28;
				*((word32) esi + 4) = eax_95 | dwArg04 | edx_107;
				word32 eax_116 = dwArg04 + esi;
				*((word32) eax + 56) = eax_116;
				*((word32) eax_116 + 4) = edi - dwArg04 | 0x01;
				edi_112 = esi + 0x08;
l0805CC04:
				ecxOut = ecx_145;
				edxOut = edx_107;
				return edi_112;
			}
l0805CD40:
			word32 edx_618;
			word32 ecx_617;
			eax_23 = malloc_printerr(out ecx_617, out edx_618);
			goto l0805CD50;
		}
	}
	word32 edx_614;
	word32 ecx_613;
	malloc_printerr(out ecx_613, out edx_614);
	goto l0805CD40;
}

// 0805CE40: void realloc_check(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_26908 dwArg08)
void realloc_check(Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_26908 dwArg08)
{
	struct Eq_35857 * ebx_17 = &g_t80CE000;
	Eq_2 esp_18 = fp - 0x3C;
	Eq_2175 eax_20 = gs->t0014;
	Eq_26908 ebp_23 = dwArg08;
	Eq_2 esi_197 = dwArg04;
	if (dwArg08 == ~0x00)
	{
l0805CEE1:
		gs->tFFFFFFE0.u0 = 0x0C;
		goto l0805CEF0;
	}
	if (dwArg04 == 0x00)
	{
		malloc_check(edi, gs, dwArg08);
		goto l0805CEF0;
	}
	if (dwArg08 == 0x00)
	{
		gs = free_check.part.3(dwArg04, edi, gs);
		goto l0805CEF0;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_76;
	if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_76))
		__lll_lock_wait_private(eax_76, 0x080CE500, gs);
	Eq_2 edx_93;
	Eq_2 ecx_94;
	Eq_2 eax_92 = mem2chunk_check(dwArg04, fp - 0x24, out ecx_94, out edx_93);
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v15_107 = g_t80CE500 - 0x01;
	g_t80CE500 = v15_107;
	if (v15_107 != 0x00)
		__lll_unlock_wake_private(0x080CE500, ecx_94, edx_93, gs);
	if (eax_92 == 0x00)
		goto l0805D058;
	if (dwArg08 <= 0x05)
		goto l0805CEE1;
	Eq_2 eax_128 = (word32) dwArg08 + 20 & ~0x0F;
	if (eax_128 > ~0x20 || eax_128 < (word32) dwArg08 + 1)
		goto l0805CEE1;
	ui32 eax_138 = *((word32) eax_92 + 4);
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_151;
	if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_151))
		__lll_lock_wait_private(eax_151, 0x080CE500, gs);
	Eq_2 edx_190;
	Eq_2 ecx_189;
	if ((*((word32) eax_92 + 4) & 0x02) != 0x00)
	{
		Eq_2 eax_208 = mremap_chunk(eax_92, eax_128, gs, out ecx_189, out edx_190);
		if (eax_208 != 0x00)
		{
			esi_197 = (word32) eax_208 + 8;
			if (eax_208 != 0x08)
				goto l0805CFA6;
		}
		else
		{
			if (eax_128 <= (eax_138 & ~0x07) - 0x04)
				goto l0805CFA6;
			word32 ebx_224;
			word32 edx_536;
			top_check(out edx_536, out ebx_224);
			esp_18.u0 = <invalid>;
			Eq_2 edi_234;
			Eq_2 esi_236;
			word32 edx_537;
			Eq_2 eax_237 = _int_malloc(ebx_224 + 0x0500, *((byte) esp_18.u0 + 0x0C), eax_92, gs, out ecx_189, out edx_537, out ebx_17, out ebp_23, out esi_236, out edi_234);
			edx_190 = eax_237;
			if (eax_237 != 0x00)
			{
				*((byte) esp_18.u0 - 8) = *((byte) esp_18.u0 + 8) - 0x08;
				*((byte) esp_18.u0 - 0x0C) = esi_236;
				*((byte) esp_18.u0 - 16) = eax_237;
				*((byte) esp_18.u0 + 4) = eax_237;
				word32 ecx_538;
				word32 edx_539;
				memcpy(*((byte) esp_18.u0 - 16), *((byte) esp_18.u0 - 0x0C), *((byte) esp_18.u0 - 8), out ecx_538, out edx_539);
				word32 edx_540;
				munmap_chunk(edi_234, gs, out ecx_189, out edx_540, out ebx_17);
				edx_190 = *((byte) esp_18.u0 + 4);
				esi_197 = edx_190;
l0805CFA6:
				if (gs->t000C != 0x00)
					__lock();
				word32 v19_303 = ebx_17->dw0500 - 0x01;
				ebx_17->dw0500 = v19_303;
				if (v19_303 != 0x00)
					__lll_unlock_wake_private(&ebx_17->dw0500, ecx_189, edx_190, gs);
				mem2mem_check(esi_197, ebp_23);
l0805CEF0:
				if ((eax_20 ^ gs->t0014) == 0x00)
					return;
				word32 ecx_531;
				word32 edx_532;
				__stack_chk_fail(out ecx_531, out edx_532);
l0805D058:
				word32 ecx_533;
				word32 edx_534;
				malloc_printerr(out ecx_533, out edx_534);
				__malloc_fork_lock_parent(gs);
				return;
			}
		}
	}
	else
	{
		word32 edx_535;
		top_check(out edx_535, out ebx_17);
		Eq_2 esp_170 = <invalid>;
		*((word32) esp_170 - 16) = *((word32) esp_170 + 4);
		Eq_2 eax_188 = _int_realloc(&ebx_17->dw0500, *((word32) esp_170 + 8), eax_92, dwArg04, eax_92, *((word32) esp_170 - 16), out ecx_189, out edx_190);
		esp_18 = esp_170;
		esi_197 = eax_188;
		if (eax_188 != 0x00)
			goto l0805CFA6;
	}
	Eq_2 eax_287 = *((word32) esp_18 + 24);
	*eax_287 = ~*eax_287;
	esi_197.u0 = 0x00;
	goto l0805CFA6;
}

// 0805D070: void __malloc_fork_lock_parent(Register (ptr32 Eq_9) gs)
// Called from:
//      realloc_check
void __malloc_fork_lock_parent(struct Eq_9 * gs)
{
	if (__libc_malloc_initialized <= 0x00)
		return;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_28;
	if (!__cmpxchg(list_lock, 0x01, 0x00, out eax_28))
		__lll_lock_wait_private(eax_28, 0x080CF880, gs);
	Eq_2 edx_44 = 0x080CE500;
	do
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_59;
		if (!__cmpxchg(*edx_44, 0x01, 0x00, out eax_59))
			__lll_lock_wait_private(eax_59, edx_44, gs);
		edx_44 = *((word32) edx_44 + 0x0448);
	} while (edx_44 != 0x080CE500);
}

// 0805D100: void __malloc_fork_unlock_parent(Register (ptr32 Eq_9) gs)
void __malloc_fork_unlock_parent(struct Eq_9 * gs)
{
	if (__libc_malloc_initialized > 0x00)
	{
		Eq_2 edx_13 = 0x080CE500;
		do
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 v13_23 = *edx_13 - 0x01;
			*edx_13 = v13_23;
			if (v13_23 != 0x00)
				__lll_unlock_wake_private(edx_13, 0x080CE500, edx_13, gs);
			edx_13 = *((word32) edx_13 + 0x0448);
		} while (edx_13 != 0x080CE500);
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_46 = list_lock - 0x01;
		list_lock = v14_46;
		if (v14_46 != 0x00)
			__lll_unlock_wake_private(0x080CF880, 0x080CE500, edx_13, gs);
	}
}

// 0805D170: void __malloc_fork_unlock_child(Register (ptr32 Eq_36231) gs)
void __malloc_fork_unlock_child(struct Eq_36231 * gs)
{
	if (__libc_malloc_initialized > 0x00)
	{
		free_list_lock.u0 = 0x00;
		Eq_2 ecx_21 = gs->tFFFFFFEC;
		if (ecx_21 != 0x00)
			((word32) ecx_21 + 1104)->u0 = 0x01;
		free_list.u0 = 0x00;
		word32 edi_29 = 0x00;
		Eq_2 edx_30 = 0x00;
		Eq_2 eax_33 = 0x080CE500;
		do
		{
			*eax_33 = 0x00;
			if (ecx_21 != eax_33)
			{
				((word32) eax_33 + 1104)->u0 = 0x00;
				*((word32) eax_33 + 0x044C) = edx_30;
				edi_29 = 0x01;
				edx_30 = eax_33;
			}
			eax_33 = *((word32) eax_33 + 0x0448);
		} while (eax_33 != 0x080CE500);
		if ((byte) edi_29 != 0x00)
			free_list = edx_30;
		list_lock.u0 = 0x00;
	}
}

// 0805D210: void __malloc_check_init()
void __malloc_check_init()
{
	using_malloc_checking = 0x01;
	__malloc_hook = &g_t805C510;
	__free_hook.u0 = 0x0805CAB0;
	__realloc_hook = &g_t805CE40;
	__memalign_hook = &g_t805C8C0;
}

// 0805D260: Register Eq_2 __libc_malloc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_3294 ebxOut, Register out Eq_3295 ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      _nl_make_l10nflist
//      _nl_normalize_codeset
//      new_exp
//      __gettextparse
//      qsort_r
//      locked_vfxprintf
//      __fopen_internal
//      _IO_wfile_seekoff
//      vasprintf
//      _IO_file_fopen
//      save_for_backup
//      _IO_default_doallocate
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_pbackfail
//      malloc_hook_ini
//      _mid_memalign
//      __realloc
//      strdup
//      getcwd
//      __tsearch
//      _dl_non_dynamic_init
//      __gconv_open
//      find_derivation
//      add_alias2.isra.1.part.2
//      __gconv_get_path
//      __gconv_load_cache
//      __gconv_lookup_cache
//      __gconv_find_shlib
//      new_composite_name
//      _nl_intern_locale_data
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      printf_positional
//      vfprintf
//      __printf_fp_l
//      register_printf_modifier
//      printf_positional
//      __vfwprintf
//      _IO_file_doallocate
//      _IO_wfile_doallocate
//      _IO_getdelim
//      save_for_wbackup.isra.0
//      _IO_wdefault_pbackfail
//      _IO_wdefault_doallocate
//      __libc_scratch_buffer_grow_preserve
//      __libc_scratch_buffer_set_array_size
//      __strndup
//      argz_create_sep
//      __alloc_dir
//      _dl_process_pt_note
//      add_name_to_object.isra.4
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      expand_dynamic_string_token
//      fillin_rpath
//      cache_rpath.part.6
//      _dl_init_paths
//      _dl_lookup_symbol_x
//      _dl_new_object
//      _dl_important_hwcaps
//      _dl_allocate_tls_storage
//      _dl_allocate_tls
//      _dl_add_to_slotinfo
//      _dl_get_origin
//      _dl_scope_free
//      _dl_exception_create
//      _dl_exception_create_format
//      strerror
//      add_to_global
//      dl_open_worker
//      _dl_close_worker
//      _dl_map_object_deps
//      search_object
//      __register_frame
//      __register_frame_table
Eq_2 __libc_malloc(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_3294 & ebxOut, union Eq_3295 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 edx_100;
	Eq_2 ecx_174;
	Eq_2 esi_19 = dwArg04;
	<anonymous> * eax_20 = __malloc_hook;
	if (eax_20 != null)
	{
		Eq_2 eax_31;
		eax_20();
		edx_100 = eax_31;
		goto l0805D3AA;
	}
	int8 dl_381;
	Eq_2 eax_378;
	ui32 eax_372 = (word32) dwArg04 + 19;
	if (dwArg04 > 0x04)
	{
l0805D340:
		eax_378 = eax_372 & ~0x0F;
		dl_381 = (int8) (eax_378 > ~0x20);
		goto l0805D29B;
	}
	dl_381 = 0x00;
	eax_378.u0 = 0x10;
l0805D29B:
	ptr32 esp_170 = fp + 16;
	if (eax_378 < esi_19 || dl_381 != 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		ecxOut = ecx;
		edxOut.u0 = 0x00;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return 0x00;
	}
	Eq_2 edi_71 = eax_378 - 0x01;
	Eq_2 eax_73 = gs->tFFFFFFE4;
	if (eax_73 == 0x00)
	{
		if (gs->bFFFFFFE8 != 0x00)
			goto l0805D2CD;
		tcache_init.part.6(gs);
		if (g_dw80CE4D0 > edi_71 >> 0x04)
		{
			eax_73 = gs->tFFFFFFE4;
			if (eax_73 != 0x00)
			{
l0805D380:
				ecx_174 = (word32) eax_73 + (edi_71 >> 0x04) * 0x04;
				edx_100 = *((word32) ecx_174 + 64);
				if (edx_100 != 0x00)
				{
					if (edi_71 > 0x03FF)
					{
						word32 ecx_581;
						word32 edx_582;
						word32 eax_580;
						__malloc_assert(0x080A29DD, 0x0B7F, 0x080A2925, out eax_580, out ecx_581, out edx_582);
						Eq_2 edx_125;
						Eq_2 ecx_126;
						Eq_2 eax_124 = malloc_hook_ini(out ecx_126, out edx_125);
						ecxOut = ecx_126;
						edxOut = edx_125;
						ebxOut.u0 = 0x080CE000;
						ebpOut = edi_71 >> 0x04;
						esiOut = esi_19;
						ediOut = edi_71;
						return eax_124;
					}
					*((byte) ecx_174.u0 + 64) = *edx_100;
					Mem131[eax_73 + (edi_71 >>u 0x04):byte] = Mem129[eax_73 + (edi_71 >>u 0x04):byte] - 0x01;
					*((word32) edx_100 + 4) = 0x00;
					goto l0805D3AA;
				}
				goto l0805D2CD;
			}
		}
l0805D2CD:
		Eq_2 esi_164 = esi_19;
		if (gs->t000C == 0x00)
		{
			word32 edi_573;
			word32 ebp_571;
			word32 esi_572;
			word32 ebx_570;
			word32 edx_569;
			Eq_2 eax_312 = _int_malloc(0x080CE500, esi_19, edi_71, gs, out ecx_174, out edx_569, out ebx_570, out ebp_571, out esi_572, out edi_573);
			edx_100 = eax_312;
			if (eax_312 != 0x00)
			{
				byte al_336 = *((word32) eax_312 + 4);
				if ((al_336 & 0x02) == 0x00 && (al_336 & 0x04) != 0x00)
				{
					ecx_174.u0 = 0x080CE500;
					if (*(eax_312 - (struct Eq_36403 *) 0x08 & 0xFFF00000) != 0x080CE500)
					{
						word32 edx_574;
						__malloc_assert(0x080A3604, 0x0BF6, 0x080A2925, out eax_372, out ecx, out edx_574);
						goto l0805D340;
					}
				}
				goto l0805D3AA;
			}
			goto l0805D3B8;
		}
		Eq_2 ecx_302;
		Eq_2 edi_142 = gs->tFFFFFFEC;
		if (edi_142 == 0x00)
		{
l0805D4B0:
			word32 edi_579;
			word32 esi_578;
			word32 edx_576;
			word32 ebx_577;
			word32 ecx_575;
			Eq_2 eax_256 = get_free_list(gs, out ecx_575, out edx_576, out ebx_577, out esi_578, out edi_579);
			edi_142 = eax_256;
			if (eax_256 == 0x00)
			{
				word32 ebx_588;
				word32 esi_589;
				word32 edi_590;
				Eq_2 eax_268 = arena_get2.part.5(esi_164, 0x00, gs, out ebx_588, out esi_589, out edi_590);
				word32 edx_592;
				word32 ebx_593;
				word32 ebp_594;
				word32 esi_595;
				word32 edi_596;
				Eq_2 eax_274 = _int_malloc(eax, esi_164, eax_268, gs, out ecx_174, out edx_592, out ebx_593, out ebp_594, out esi_595, out edi_596);
				edi_142 = eax_268;
				edx_100 = eax_274;
				if (eax_274 != 0x00 || eax_268 == 0x00)
					goto l0805D4F5;
l0805D4E0:
				Eq_2 eax_294 = arena_get_retry(edi_142, ecx_302, esi_164, gs);
				edi_142 = eax_294;
				word32 edx_597;
				word32 ebx_598;
				word32 ebp_599;
				word32 esi_600;
				word32 edi_601;
				edx_100 = _int_malloc(eax, esi_164, eax_294, gs, out ecx_302, out edx_597, out ebx_598, out ebp_599, out esi_600, out edi_601);
				ecx_174 = ecx_302;
l0805D4F5:
				if (edi_142 != 0x00)
					goto l0805D442;
				goto l0805D459;
			}
			goto l0805D42F;
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_154;
		if (!__cmpxchg(*edi_142, 0x01, 0x00, out eax_154))
			__lll_lock_wait_private(eax_154, edi_142, gs);
l0805D42F:
		word32 esi_586;
		word32 ebp_585;
		word32 ebx_584;
		word32 edx_583;
		word32 edi_587;
		Eq_2 eax_172 = _int_malloc(edi_142, esi_164, edi_142, gs, out ecx_174, out edx_583, out ebx_584, out ebp_585, out esi_586, out edi_587);
		edx_100 = eax_172;
		if (eax_172 == 0x00)
			goto l0805D4E0;
l0805D442:
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v20_187 = *edi_142 - 0x01;
		*edi_142 = v20_187;
		if (v20_187 != 0x00)
			__lll_unlock_wake_private(edi_142, ecx_174, edx_100, gs);
l0805D459:
		if (edx_100 == 0x00)
		{
l0805D3B8:
			ecxOut = ecx_174;
			edxOut.u0 = 0x00;
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return 0x00;
		}
		Eq_36489 al_204 = *((word32) edx_100 + 4);
		if ((al_204 & 0x02) == 0x00)
		{
			ecx_174.u0 = 0x080CE500;
			if ((al_204 & 0x04) != 0x00)
				ecx_174 = *(edx_100 - (struct Eq_36604 *) 0x08 & 0xFFF00000);
			if (ecx_174 != edi_142)
			{
				struct Eq_36611 * esp_227 = esp_170 - 0x0C;
				esp_227->ptrFFFFFFFC = 0x080A3930;
				word32 eax_602;
				word32 ecx_603;
				word32 edx_604;
				__malloc_assert(0x080A366C, 0x0C0A, 0x080A2925, out eax_602, out ecx_603, out edx_604);
				esp_170 = esp_227 - 4;
				goto l0805D4B0;
			}
		}
l0805D3AA:
		ecxOut = ecx_174;
		edxOut = edx_100;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return edx_100;
	}
	else
	{
		if (edi_71 >> 0x04 >= g_dw80CE4D0)
			goto l0805D2CD;
		goto l0805D380;
	}
}

// 0805D530: Register Eq_2 malloc_hook_ini(Register out Eq_952 ecxOut, Register out Eq_952 edxOut)
// Called from:
//      __libc_malloc
//      __libc_calloc
Eq_2 malloc_hook_ini(union Eq_952 & ecxOut, union Eq_952 & edxOut)
{
	__malloc_hook = null;
	ptmalloc_init(gs);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_33;
	word32 edx_34;
	word32 ebx_35;
	word32 ebp_36;
	word32 esi_37;
	word32 edi_38;
	Eq_2 eax_20 = __libc_malloc(gs, stackArg0, dwArg04, out ecx_33, out edx_34, out ebx_35, out ebp_36, out esi_37, out edi_38);
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_20;
}

// 0805D570: Register Eq_2 _mid_memalign(Register Eq_2 eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      memalign_hook_ini
//      aligned_alloc
//      __valloc
//      __pvalloc
//      posix_memalign
Eq_2 _mid_memalign(Eq_2 eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 edi_11 = edx;
	Eq_2 ebx_117 = eax;
	Eq_2 esp_135 = fp - 0x1C;
	<anonymous> * eax_23 = __memalign_hook;
	if (eax_23 != null)
	{
		Eq_2 eax_37;
		eax_23();
		return eax_37;
	}
	if (eax <= 0x10)
	{
		word32 esi_513;
		word32 edi_514;
		word32 ebx_511;
		word32 ebp_512;
		word32 ecx_509;
		word32 edx_510;
		return __libc_malloc(gs, dwLoc30, edx, out ecx_509, out edx_510, out ebx_511, out ebp_512, out esi_513, out edi_514);
	}
	if (eax > 0x80000000)
	{
		gs->tFFFFFFE0.u0 = 22;
		return 0x00;
	}
	Eq_2 edx_171;
	if (edx > ~0x10 - eax)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		edx_171.u0 = 0x00;
		return edx_171;
	}
	if ((eax - 0x01 & eax) != 0x00)
	{
		if (eax > 0x20)
		{
			Eq_2 eax_110 = 0x20;
			do
				eax_110 *= 0x02;
			while (eax > eax_110);
			ebx_117 = eax_110;
		}
		else
			ebx_117.u0 = 0x20;
	}
	ptr32 esi_132 = 0x080CE000;
	if (gs->t000C == 0x00)
	{
		struct Eq_36734 * gs_517;
		word32 ecx_515;
		word32 edx_516;
		Eq_2 eax_329 = _int_memalign(0x080CE500, edx, ebx_117, gs, out ecx_515, out edx_516, out gs_517);
		edx_171 = eax_329;
		if (eax_329 == 0x00)
			return 0x00;
		byte al_358 = *((word32) eax_329 + 4);
		if ((al_358 & 0x02) != 0x00 || ((al_358 & 0x04) == 0x00 || *(eax_329 - (struct Eq_36759 *) 0x08 & 0xFFF00000) == 0x080CE500))
			return edx_171;
		word32 eax_518;
		word32 ecx_519;
		word32 edx_520;
		__malloc_assert(0x080A36D0, 0x0CEE, 0x080A2925, out eax_518, out ecx_519, out edx_520);
	}
	Eq_2 ecx_164;
	struct Eq_9 * gs_166;
	Eq_2 ebp_125 = gs->tFFFFFFEC;
	if (ebp_125 != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_186;
		if (!__cmpxchg(*ebp_125, 0x01, 0x00, out eax_186))
			__lll_lock_wait_private(eax_186, ebp_125, gs);
	}
	else
	{
		word32 ecx_521;
		word32 edx_522;
		Eq_2 eax_129 = get_free_list(gs, out ecx_521, out edx_522, out ebx_117, out esi_132, out edi_11);
		esp_135.u0 = <invalid>;
		ebp_125 = eax_129;
		if (eax_129 == 0x00)
		{
			Eq_2 eax_148 = arena_get2.part.5((word32) edi_11 + ((byte) ebx_117.u0 + 16), 0x00, gs, out ebx_117, out esi_132, out edi_11);
			word32 edx_524;
			Eq_2 eax_162 = _int_memalign(eax_148, edi_11, ebx_117, gs, out ecx_164, out edx_524, out gs_166);
			ebp_125 = eax_148;
			edx_171 = eax_162;
			if (eax_162 != 0x00 || eax_148 == 0x00)
				goto l0805D7D0;
l0805D7B9:
			Eq_2 eax_226 = arena_get_retry(ebp_125, ecx_164, edi_11, gs_166);
			ebp_125 = eax_226;
			word32 edx_525;
			edx_171 = _int_memalign(eax_226, edi_11, ebx_117, gs_166, out ecx_164, out edx_525, out gs_166);
l0805D7D0:
			if (ebp_125 == 0x00)
				goto l0805D72F;
l0805D716:
			if (gs_166->t000C != 0x00)
				__lock();
			Eq_2 v17_262 = *ebp_125 - 0x01;
			*ebp_125 = v17_262;
			if (v17_262 != 0x00)
				__lll_unlock_wake_private(ebp_125, ecx_164, edx_171, gs_166);
l0805D72F:
			if (edx_171 == 0x00)
				return 0x00;
			byte al_281 = *((byte) edx_171.u0 + 4);
			if ((al_281 & 0x02) != 0x00)
				return edx_171;
			Eq_2 ecx_293 = esi_132 + 0x0500;
			if ((al_281 & 0x04) != 0x00)
				ecx_293 = *(edx_171 - (struct Eq_36886 *) 0x08 & 0xFFF00000);
			if (ecx_293 == ebp_125)
				return edx_171;
			*((byte) esp_135.u0 - 16) = esi_132 + 4294793432;
			word32 ecx_527;
			word32 edx_528;
			word32 eax_526;
			__malloc_assert(esi_132 + 4294793004, 0x0D01, esi_132 + ~0x0002B6DA, out eax_526, out ecx_527, out edx_528);
		}
	}
	word32 edx_523;
	Eq_2 eax_207 = _int_memalign(ebp_125, edi_11, ebx_117, gs, out ecx_164, out edx_523, out gs_166);
	edx_171 = eax_207;
	if (eax_207 != 0x00)
		goto l0805D716;
	goto l0805D7B9;
}

// 0805D7E0: void memalign_hook_ini(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg08)
void memalign_hook_ini(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg08)
{
	__memalign_hook = null;
	Eq_2 ebx_19 = ptmalloc_init(gs);
	_mid_memalign(ebx_19, dwArg00, dwArg08, gs);
}

// 0805D820: Register Eq_2 free(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out Eq_12 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __assert_fail_base
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      _nl_make_l10nflist
//      _nl_explode_name
//      __gettext_free_exp
//      __gettextparse
//      qsort_r
//      __run_exit_handlers
//      locked_vfxprintf
//      __new_fclose
//      __fopen_internal
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_underflow_mmap
//      vasprintf
//      _IO_new_file_underflow
//      _IO_new_file_seekoff
//      _IO_file_xsgetn
//      _IO_file_fopen
//      save_for_backup
//      _IO_free_backup_area
//      _IO_setb
//      _IO_doallocbuf
//      _IO_default_setbuf
//      _IO_default_doallocate
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_pbackfail
//      _IO_str_finish
//      __malloc_arena_thread_freeres
//      __realloc
//      _nl_cleanup_ctype
//      __wcsmbs_load_conv
//      getcwd
//      __tdelete
//      tdestroy
//      __gconv_open
//      __gconv_close
//      find_derivation
//      insert_module
//      add_alias2.isra.1.part.2
//      __gconv_get_path
//      __gconv_read_conf
//      __gconv_load_cache
//      __gconv_lookup_cache
//      __gconv_release_cache
//      __gconv_find_shlib
//      setlocale
//      _nl_find_locale
//      _nl_intern_locale_data
//      _nl_load_locale
//      _nl_unload_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __clearenv
//      _i18n_number_rewrite
//      printf_positional
//      vfprintf
//      _i18n_number_rewrite
//      __printf_fp_l
//      _i18n_number_rewrite
//      printf_positional
//      __vfwprintf
//      save_for_wbackup.isra.0
//      _IO_wsetb
//      _IO_wdefault_pbackfail
//      _IO_wdefault_finish
//      _IO_free_wbackup_area
//      __libc_scratch_buffer_grow_preserve
//      __libc_scratch_buffer_set_array_size
//      argz_create_sep
//      closedir
//      __readonly_area
//      _dl_process_pt_note
//      lose
//      open_verify.constprop.7
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      fillin_rpath
//      cache_rpath.part.6
//      _dl_init_paths
//      _dl_map_object
//      _dl_new_object
//      _dl_allocate_tls_storage
//      _dl_deallocate_tls
//      _dl_scope_free
//      _dl_exception_free
//      dlerror_run
//      __dlerror
//      check_free.isra.0
//      free_key_mem
//      _dlerror_run
//      add_to_global
//      _dl_close_worker
//      _dl_map_object_deps
//      search_object
//      __deregister_frame_info_bases
//      __deregister_frame
//      __dl_iterate_phdr
//      _nl_finddomain_subfreeres
//      _nl_unload_domain
//      buffer_free
//      free_derivation
//      free_modules_db
//      free_mem
//      free_mem
//      do_release_all
//      free_category
//      _nl_locale_subfreeres
//      _nl_archive_subfreeres
//      free_mem
//      free_slotinfo
//      free_mem
Eq_2 free(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, union Eq_12 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 eax_14 = __free_hook;
	if (eax_14 == 0x00)
	{
		if (dwArg04 != 0x00)
		{
			Eq_2 ecx_42 = *((word32) dwArg04 - 4);
			if (((byte) ecx_42 & 0x02) != 0x00)
			{
				if (g_dw80CE4C0 == 0x00 && (ecx_42 > g_t80CE4A8 && ecx_42 <= 0x00080000))
				{
					g_t80CE4A8 = ecx_42 & ~0x07;
					g_dw80CE4A0 = (ecx_42 & ~0x07) * 0x02;
				}
				Eq_12 ecx_74;
				Eq_2 edx_75;
				word32 ebx_184;
				Eq_2 eax_73 = munmap_chunk(eax, gs, out ecx_74, out edx_75, out ebx_184);
				ecxOut = ecx_74;
				edxOut = edx_75;
				return eax_73;
			}
			else
			{
				if (gs->tFFFFFFE4 == 0x00 && gs->bFFFFFFE8 == 0x00)
				{
					tcache_init.part.6(gs);
					ecx_42 = *((word32) dwArg04 - 4);
				}
				Eq_12 ecx_121;
				Eq_2 edx_122;
				word32 ebx_179;
				word32 ebp_180;
				word32 esi_181;
				word32 edi_182;
				struct Eq_36969 * gs_183;
				Eq_2 eax_120 = _int_free(eax, edx_122, edi, gs, out ecx_121, out edx_122, out ebx_179, out ebp_180, out esi_181, out edi_182, out gs_183);
				ecxOut = ecx_121;
				edxOut = edx_122;
				return eax_120;
			}
		}
	}
	else
		eax_14();
	ecxOut = ecx;
	edxOut = edx;
	return eax_14;
}

// 0805D910: void __malloc_arena_thread_freeres(Register (ptr32 Eq_9) gs)
void __malloc_arena_thread_freeres(struct Eq_9 * gs)
{
	Eq_2 ebp_20 = gs->tFFFFFFE4;
	if (ebp_20 != 0x00)
	{
		gs->tFFFFFFE4.u0 = 0x00;
		gs->bFFFFFFE8 = 0x01;
		word32 * esi_28 = (word32) ebp_20 + 64;
		do
		{
			Eq_2 eax_31 = *esi_28;
			while (eax_31 != 0x00)
			{
				*esi_28 = (word32) *eax_31;
				word32 edx_246;
				word32 ecx_245;
				free(gs, dwLoc30, eax_31, out ecx_245, out edx_246);
				eax_31 = *esi_28;
			}
			++esi_28;
		} while (esi_28 != (word32) ebp_20 + 320);
		word32 ecx_247;
		word32 edx_248;
		free(gs, dwLoc30, ebp_20, out ecx_247, out edx_248);
	}
	Eq_2 edx_90 = gs->tFFFFFFEC;
	gs->tFFFFFFEC.u0 = 0x00;
	if (edx_90 == 0x00)
		return;
	Eq_2 ecx_112 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_107;
	if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_107))
		ecx_112 = __lll_lock_wait_private(eax_107, 0x080CF888, gs);
	Eq_2 eax_120 = *((word32) edx_90 + 1104);
	if (eax_120 == 0x00)
	{
		word32 edx_251;
		word32 eax_249;
		word32 ecx_250;
		__malloc_assert(134884119, 0x03C0, 0x080A28A8, out eax_249, out ecx_250, out edx_251);
	}
	else
	{
		*((word32) edx_90 + 1104) = eax_120 - 0x01;
		if (eax_120 == 0x01)
		{
			Eq_2 eax_140 = free_list;
			free_list = edx_90;
			*((word32) edx_90 + 0x044C) = eax_140;
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_151 = free_list_lock - 0x01;
		free_list_lock = v15_151;
		if (v15_151 != 0x00)
			__lll_unlock_wake_private(0x080CF888, ecx_112, edx_90, gs);
	}
}

// 0805DA40: Register Eq_2 __realloc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 edxOut, Register out Eq_952 ebpOut, Register out Eq_2 esiOut, Register out ptr32 ediOut)
// Called from:
//      _nl_find_msg
//      read_alias_file
//      vasprintf
//      __malloc_arena_thread_freeres
//      realloc_hook_ini
//      getcwd
//      __add_to_environ
//      _IO_getdelim
//      __libc_scratch_buffer_grow_preserve
//      __argz_add_sep
//      open_verify.constprop.7
//      _dl_new_object
//      _dl_allocate_tls
Eq_2 __realloc(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & edxOut, union Eq_952 & ebpOut, union Eq_2 & esiOut, ptr32 & ediOut)
{
	Eq_2 dwLoc28_524;
	Eq_2 edx_201;
	byte bl_128 = (byte) dwArg04;
	Eq_2 esi_165 = dwArg08;
	<anonymous> * eax_21 = __realloc_hook;
	if (eax_21 != null)
	{
		Eq_2 eax_34;
		eax_21();
		word24 edx_24_8_656 = SLICE(edx_201, word24, 8);
		dwLoc28_524 = eax_34;
		goto l0805DBBD;
	}
	byte dl_47 = (int8) (dwArg08 == 0x00) & (int8) (dwArg04 != 0x00);
	if (dl_47 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_769;
		free(gs, stackArg0, dwArg04, out ecx_769, out edx_201);
		dwLoc28_524.u0 = 0x00;
		goto l0805DBBD;
	}
	if (dwArg04 == 0x00)
	{
		Eq_2 edx_77;
		word32 esi_806;
		word32 edi_807;
		word32 ebp_805;
		word32 ebx_804;
		word32 ecx_803;
		Eq_2 eax_76 = __libc_malloc(gs, dwArg00, dwArg08, out ecx_803, out edx_77, out ebx_804, out ebp_805, out esi_806, out edi_807);
		edxOut = edx_77;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return eax_76;
	}
	Eq_2 eax_190;
	Eq_2 eax_83 = *((word32) dwArg04 - 4);
	Eq_2 dwLoc20_530 = 0x00;
	Eq_2 edx_757 = SEQ(edx_24_8, dl_47);
	eax_190 = eax_83;
	if (((byte) eax_83 & 0x02) == 0x00)
	{
		Eq_2 eax_103;
		Eq_2 edx_104 = SEQ(edx_24_8, dl_47);
		eax_103 = eax_83;
		if (gs->tFFFFFFE4 == 0x00)
		{
			edx_104 = SEQ(edx_24_8, dl_47);
			eax_103 = eax_83;
			if (gs->bFFFFFFE8 == 0x00)
			{
				tcache_init.part.6(gs);
				eax_103 = *((word32) dwArg04 - 4);
				edx_104 = (word32) dl_47;
			}
		}
		dwLoc20_530.u0 = 0x080CE500;
		eax_190 = eax_103;
		edx_757 = edx_104;
		if (((byte) eax_103 & 0x04) != 0x00)
		{
			dwLoc20_530 = *(dwArg04 - (struct Eq_37401 *) 0x08 & 0xFFF00000);
			edx_757 = edx_104;
		}
	}
	word24 edx_24_8_626 = SLICE(edx_757, word24, 8);
	if (-(eax_83 & ~0x07) < dwArg04 - 0x08 || (bl_128 & 0x0F) != 0x00)
	{
		word32 edx_771;
		word32 ecx_770;
		malloc_printerr(out ecx_770, out edx_771);
		Eq_2 edx_157;
		Eq_2 eax_156 = realloc_hook_ini(out edx_157);
		edxOut = edx_157;
		ebpOut.u0 = <invalid>;
		esiOut = dwArg08;
		ediOut = 0x080CE000;
		return eax_156;
	}
	ui32 ecx_160 = (word32) dwArg08 + 19;
	Eq_2 ebp_161 = 0x10;
	Eq_2 edx_753 = edx_757;
	if (dwArg08 > 0x04)
	{
l0805DB60:
		Eq_2 ecx_492 = ecx_160 & ~0x0F;
		ebp_161 = ecx_492;
		edx_753 = SEQ(edx_24_8_626, (int8) (ecx_492 > ~0x20));
		goto l0805DAD1;
	}
l0805DAD1:
	byte dl_168 = (byte) edx_753;
	if (ebp_161 < esi_165 || dl_168 != 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		edxOut = edx_753;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return 0x00;
	}
	Eq_2 eax_191 = eax_190 & 0x02;
	if (eax_191 == 0x00)
	{
		if (gs->t000C == 0x00)
		{
			word32 ecx_773;
			Eq_2 eax_431 = _int_realloc(dwLoc20_530, eax_83 & ~0x07, dwArg04 - 0x08, esi_165, 0x080CE000, dwArg00, out ecx_773, out edx_201);
			dwLoc28_524 = eax_431;
			esi_165 = eax_431;
			if (eax_431 != 0x00)
			{
				byte al_442 = *((word32) eax_431 + 4);
				if ((al_442 & 0x02) == 0x00)
				{
					edx_201.u0 = 0x080CE500;
					if ((al_442 & 0x04) != 0x00)
						edx_201 = *(eax_431 - (struct Eq_37276 *) 0x08 & 0xFFF00000);
					if (dwLoc20_530 != edx_201)
					{
						word32 edx_488;
						__malloc_assert(0x080A3780, 3226, 0x080A2925, out eax_190, out ecx_160, out edx_488);
						edx_24_8_626 = SLICE(edx_488, word24, 8);
						goto l0805DB60;
					}
				}
			}
			goto l0805DBBD;
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_268;
		if (!__cmpxchg(*dwLoc20_530, 0x01, eax_191, out eax_268))
			__lll_lock_wait_private(eax_268, dwLoc20_530, gs);
		word32 ecx_774;
		Eq_2 eax_299 = _int_realloc(dwLoc20_530, eax_83 & ~0x07, dwArg04 - 0x08, esi_165, 0x080CE000, dwArg00, out ecx_774, out edx_201);
		dwLoc28_524 = eax_299;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v20_309 = *dwLoc20_530 - 0x01;
		*dwLoc20_530 = v20_309;
		if (v20_309 != 0x00)
			__lll_unlock_wake_private(dwLoc20_530, eax_299, edx_201, gs);
		ptr32 esp_320 = fp - 44;
		if (eax_299 == 0x00)
		{
l0805DD6D:
			struct Eq_37408 * esp_374 = esp_320 - 0x0C;
			esp_374->tFFFFFFFC = esi_165;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edi_791;
			word32 esi_790;
			word32 ecx_787;
			word32 ebx_788;
			word32 ebp_789;
			Eq_2 eax_384 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_787, out edx_201, out ebx_788, out ebp_789, out esi_790, out edi_791);
			esp_374->t0010 = eax_384;
			if (eax_384 != 0x00)
			{
				esp_374->t0004 = esp_374->dw000C - 0x04;
				esp_374->t0000 = dwArg04;
				esp_374->tFFFFFFFC = esp_374->t0010;
				word32 edx_796;
				word32 ecx_795;
				memcpy(esp_374->tFFFFFFFC, esp_374->t0000, esp_374->t0004, out ecx_795, out edx_796);
				struct Eq_37506 * gs_802;
				word32 esi_800;
				word32 edi_801;
				word32 ecx_797;
				word32 ebx_798;
				word32 ebp_799;
				_int_free(esp_374->t0018, esp_374->t0014, 0x080CE000, gs, out ecx_797, out edx_201, out ebx_798, out ebp_799, out esi_800, out edi_801, out gs_802);
			}
			goto l0805DBBD;
		}
		byte al_327 = *((word32) eax_299 + 4);
		if ((al_327 & 0x02) == 0x00)
		{
			edx_201.u0 = 0x080CE500;
			if ((al_327 & 0x04) != 0x00)
				edx_201 = *(eax_299 - (struct Eq_37448 *) 0x08 & 0xFFF00000);
			if (dwLoc20_530 != edx_201)
			{
				word32 ecx_793;
				word32 edx_794;
				word32 eax_792;
				__malloc_assert(0x080A3780, 3237, 0x080A2925, out eax_792, out ecx_793, out edx_794);
				esp_320 = fp - 0x3C;
				goto l0805DD6D;
			}
		}
	}
	else
	{
		word32 ecx_772;
		Eq_2 eax_200 = mremap_chunk(dwArg04 - 0x08, ebp_161, gs, out ecx_772, out edx_201);
		if (eax_200 != 0x00)
			dwLoc28_524 = (word32) eax_200 + 8;
		else
		{
			dwLoc28_524 = dwArg04;
			if ((eax_83 & ~0x07) - 0x04 < ebp_161)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ebp_779;
				word32 esi_780;
				word32 edi_781;
				word32 ebx_778;
				word32 edx_777;
				word32 ecx_776;
				Eq_2 eax_217 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_776, out edx_777, out ebx_778, out ebp_779, out esi_780, out edi_781);
				dwLoc28_524 = eax_217;
				edx_201 = eax_217;
				if (eax_217 != 0x00)
				{
					word32 edx_783;
					word32 ecx_782;
					memcpy(eax_217, dwArg04, (eax_83 & ~0x07) - 0x08, out ecx_782, out edx_783);
					word32 ebx_785;
					word32 ecx_784;
					munmap_chunk(dwArg04 - 0x08, gs, out ecx_784, out edx_201, out ebx_785);
				}
			}
		}
	}
l0805DBBD:
	edxOut = edx_201;
	ebpOut.u0 = <invalid>;
	esiOut = esi;
	ediOut = edi;
	return dwLoc28_524;
}

// 0805DDC0: Register Eq_2 realloc_hook_ini(Register out Eq_952 edxOut)
// Called from:
//      __realloc
Eq_2 realloc_hook_ini(union Eq_952 & edxOut)
{
	__malloc_hook = null;
	__realloc_hook = null;
	ptmalloc_init(gs);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 edx_43;
	word32 ebp_44;
	word32 esi_45;
	word32 edi_46;
	Eq_2 eax_28 = __realloc(gs, stackArg0, dwArg04, dwArg08, out edx_43, out ebp_44, out esi_45, out edi_46);
	edxOut.u0 = <invalid>;
	return eax_28;
}

// 0805DE10: void aligned_alloc(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void aligned_alloc(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08)
{
	_mid_memalign(dwArg04, dwArg00, dwArg08, gs);
}

// 0805DE30: void __valloc(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg04)
void __valloc(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg04)
{
	if (__libc_malloc_initialized < 0x00)
		ptmalloc_init(gs);
	Eq_2 eax_34 = _dl_pagesize;
	_mid_memalign(eax_34, dwArg00, dwArg04, gs);
}

// 0805DE80: void __pvalloc(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack up32 dwArg04)
void __pvalloc(struct Eq_9 * gs, word32 dwArg00, up32 dwArg04)
{
	if (__libc_malloc_initialized < 0x00)
		ptmalloc_init(gs);
	Eq_2 eax_35 = _dl_pagesize;
	if (~0x10 - eax_35 * 0x02 < dwArg04)
		gs->tFFFFFFE0.u0 = 0x0C;
	else
	{
		Eq_2 edx_56 = eax_35 - 0x01 + dwArg04 & -eax_35;
		_mid_memalign(eax_35, dwArg00, edx_56, gs);
	}
}

// 0805DEF0: Register Eq_2 __libc_calloc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_3143) ebxOut, Register out (ptr32 Eq_3144) ebpOut, Register out (ptr32 Eq_3145) esiOut, Register out (ptr32 Eq_3146) ediOut)
// Called from:
//      _nl_find_msg
//      _nl_load_domain
//      __new_exitfn
//      __wcsmbs_load_conv
//      add_module.isra.0
//      register_printf_specifier
//      register_printf_modifier
//      register_printf_type
//      do_lookup_x
//      _dl_new_object
//      _dl_relocate_object
//      _dl_start_profile
//      allocate_dtv
//      _dlerror_run
//      _dl_check_map_versions
Eq_2 __libc_calloc(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut, struct Eq_3143 & ebxOut, struct Eq_3144 & ebpOut, struct Eq_3145 & esiOut, struct Eq_3146 & ediOut)
{
	Eq_2 esi_203;
	Eq_2 edx_198;
	struct Eq_37618 * esp_18 = fp - 44;
	Eq_2 esi_19 = dwArg04;
	Eq_2 ecx_20 = dwArg08;
	Eq_2 ebp_24 = dwArg04 *s dwArg08;
	if ((dwArg04 | dwArg08) > 0xFFFF && dwArg08 != 0x00)
	{
l0805E080:
		uint64 edx_eax_244 = (uint64) ebp_24;
		edx_198 = (uint32) (edx_eax_244 % ecx_20);
		if ((uint32) (edx_eax_244 /u ecx_20) != esi_19)
		{
			gs->tFFFFFFE0.u0 = 0x0C;
			esi_203.u0 = 0x00;
			goto l0805DFB3;
		}
	}
	<anonymous> * eax_32 = __malloc_hook;
	if (eax_32 != null)
	{
		struct Eq_37643 * esp_37 = esp_18 - 0x08;
		esp_37->tFFFFFFFC = esp_37->t0034;
		esp_37->tFFFFFFF8 = ebp_24;
		Eq_2 eax_49;
		eax_32();
		if (eax_49 != 0x00)
		{
			esp_37->t0000 = ebp_24;
			esp_37->tFFFFFFFC.u0 = 0x00;
			esp_37->tFFFFFFF8 = eax_49;
			esi_203 = memset(esp_37->tFFFFFFF8, esp_37->tFFFFFFFC, esp_37->t0000, out ecx_20, out edx_198);
			goto l0805DFB3;
		}
		goto l0805E0D0;
	}
	if (gs->tFFFFFFE4 == 0x00 && gs->bFFFFFFE8 == 0x00)
		tcache_init.part.6(gs);
	Eq_2 edi_106;
	Eq_2 ecx_122;
	if (gs->t000C == 0x00)
	{
		ecx_122 = g_t80CE538;
		esp_18[3] = (struct Eq_37618) (*((word32) ecx_122 + 4) & ~0x07);
		edi_106.u0 = 0x080CE500;
		goto l0805DF66;
	}
	edi_106 = gs->tFFFFFFEC;
	if (edi_106 != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_134;
		if (!__cmpxchg(*edi_106.u0, 0x01, 0x00, out eax_134))
			__lll_lock_wait_private(eax_134, edi_106, gs);
	}
	else
	{
		word32 esi_614;
		word32 edx_612;
		word32 ecx_611;
		word32 edi_615;
		word32 ebx_613;
		Eq_2 eax_103 = get_free_list(gs, out ecx_611, out edx_612, out ebx_613, out esi_614, out edi_615);
		edi_106 = eax_103;
		if (eax_103 == 0x00)
		{
			word32 esi_617;
			word32 ebx_616;
			word32 edi_618;
			Eq_2 eax_115 = arena_get2.part.5(ebp_24, 0x00, gs, out ebx_616, out esi_617, out edi_618);
			edi_106 = eax_115;
			if (eax_115 == 0x00)
			{
				esp_18[3] = (struct Eq_37618) 0x00;
				ecx_122.u0 = 0x00;
l0805DF66:
				esp_18[2] = (struct Eq_37618) ecx_122;
				word32 ecx_619;
				word32 esi_622;
				word32 ebp_621;
				word32 edi_623;
				word32 ebx_620;
				Eq_2 eax_197 = _int_malloc(edi_106, ebp_24, edi_106, gs, out ecx_619, out edx_198, out ebx_620, out ebp_621, out esi_622, out edi_623);
				ecx_20 = esp_18[2];
				esi_203 = eax_197;
				if (eax_197 != 0x00)
				{
					Eq_37691 al_206 = *((word32) eax_197 + 4);
					if ((al_206 & 0x02) != 0x00)
						goto l0805DF88;
					edx_198.u0 = 0x080CE500;
					if ((al_206 & 0x04) != 0x00)
						edx_198 = *(eax_197 - (struct Eq_38023 *) 0x08 & 0xFFF00000);
					if (edx_198 != edi_106)
					{
						struct Eq_38030 * esp_226 = esp_18 - 0x0C;
						esp_226->ptrFFFFFFFC = 0x080A38C8;
						word32 eax_632;
						word32 edx_633;
						__malloc_assert(0x080A37E0, 3442, 0x080A2925, out eax_632, out ecx_20, out edx_633);
						esp_18 = esp_226 - 4;
						esi_19 = eax_197;
						goto l0805E080;
					}
				}
l0805DF88:
				if (gs->t000C != 0x00)
				{
					if (eax_197 == 0x00 && edi_106 != 0x00)
					{
						esp_18[2] = (struct Eq_37618) ecx_20;
						Eq_2 eax_288 = arena_get_retry(edi_106, ecx, ebp_24, gs);
						word32 ecx_627;
						word32 ebx_628;
						word32 esi_630;
						word32 ebp_629;
						word32 edi_631;
						Eq_2 eax_294 = _int_malloc(eax, ebp_24, eax_288, gs, out ecx_627, out edx_198, out ebx_628, out ebp_629, out esi_630, out edi_631);
						edi_106 = eax_288;
						ecx_20 = esp_18[2];
						esi_203 = eax_294;
					}
					if (edi_106 != 0x00)
					{
						if (gs->t000C != 0x00)
							__lock();
						Eq_2 v18_309 = *edi_106.u0 - 0x01;
						*edi_106.u0 = v18_309;
						if (v18_309 != 0x00)
							__lll_unlock_wake_private(edi_106, ecx_20, edx_198, gs);
					}
				}
				if (esi_203 != 0x00)
				{
					Eq_2 eax_330 = *((byte) esi_203.u0 - 4);
					edx_198 = perturb_byte;
					if (((byte) eax_330 & 0x02) != 0x00)
					{
						if (edx_198 != 0x00)
						{
							struct Eq_37728 * esp_434 = esp_18 - 0x04;
							esp_434->tFFFFFFFC = ebp_24;
							esp_434->tFFFFFFF8.u0 = 0x00;
							esp_434->tFFFFFFF4 = esi_203;
							esi_203 = memset(esp_434->tFFFFFFF4, esp_434->tFFFFFFF8, esp_434->tFFFFFFFC, out ecx_20, out edx_198);
						}
						goto l0805DFB3;
					}
					uint32 eax_340 = eax_330 & ~0x07;
					if (edx_198 == 0x00)
					{
						edx_198 = esi_203 - 0x08;
						if (ecx_20 == edx_198)
						{
							uint32 edi_353 = esp_18[3];
							if (edi_353 < (eax_330 & ~0x07))
								eax_340 = edi_353;
						}
					}
					Eq_2 eax_358 = eax_340 - 0x04;
					if (eax_358 > 11)
					{
						if (eax_358 <= 0x27)
						{
							*esi_203.u0 = 0x00;
							*((byte) esi_203.u0 + 4) = 0x00;
							*((byte) esi_203.u0 + 8) = 0x00;
							if (eax_358 > 0x13)
							{
								*((byte) esi_203.u0 + 0x0C) = 0x00;
								*((byte) esi_203.u0 + 16) = 0x00;
								if (eax_358 > 0x1B)
								{
									*((byte) esi_203.u0 + 20) = 0x00;
									((byte) esi_203.u0 + 24)->u0 = 0x00;
									if (eax_358 > 0x23)
									{
										((byte) esi_203.u0 + 28)->u0 = 0x00;
										((byte) esi_203.u0 + 32)->u0 = 0x00;
									}
								}
							}
						}
						else
						{
							struct Eq_37909 * esp_398 = esp_18 - 0x04;
							esp_398->tFFFFFFFC = eax_358;
							esp_398->tFFFFFFF8.u0 = 0x00;
							esp_398->tFFFFFFF4 = esi_203;
							memset(esp_398->tFFFFFFF4, esp_398->tFFFFFFF8, esp_398->tFFFFFFFC, out ecx_20, out edx_198);
						}
l0805DFB3:
						ecxOut = ecx_20;
						edxOut = edx_198;
						ebxOut = ebx;
						ebpOut = ebp;
						esiOut = esi;
						ediOut = edi;
						return esi_203;
					}
					esp_18->dwFFFFFFF0 = 0x080A38C8;
					word32 eax_624;
					__malloc_assert(134884143, 0x0DA0, 0x080A2925, out eax_624, out ecx_20, out edx_198);
				}
l0805E0D0:
				esi_203.u0 = 0x00;
				goto l0805DFB3;
			}
		}
	}
	ecx_122 = *((byte) edi_106.u0 + 56);
	ui32 edx_150 = *((word32) ecx_122 + 4);
	esp_18[3] = (struct Eq_37618) (edx_150 & ~0x07);
	if (edi_106 != 0x080CE500)
	{
		uint32 eax_160 = (ecx_122 & 0xFFF00000) + (ecx_122 & 0xFFF00000)->dw000C - ecx_122;
		if ((edx_150 & ~0x07) >= eax_160)
			eax_160 = edx_150 & ~0x07;
		esp_18[3] = (struct Eq_37618) eax_160;
	}
	goto l0805DF66;
}

// 0805E260: void malloc_trim(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void malloc_trim(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_18 = fp - 0x4C;
	if (__libc_malloc_initialized < 0x00)
	{
		ptmalloc_init(gs);
		esp_18.u0 = <invalid>;
	}
	*((byte) esp_18.u0 + 44) = 0x00;
	*((byte) esp_18.u0 + 40) = 0x080CE500;
	((byte) esp_18.u0 + 16)->u0 = 0x080CE500;
	((byte) esp_18.u0 + 24)->u0 = 0x080CE9B0;
	do
	{
		Eq_2 edx_45 = *((byte) esp_18.u0 + 16);
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_53;
		if (!__cmpxchg(*edx_45, 0x01, 0x00, out eax_53))
			__lll_lock_wait_private(eax_53, edx_45, gs);
		Eq_38097 dwLoc44_339;
		word32 ebp_67;
		word32 ebx_516;
		word32 edi_517;
		word32 edx_515;
		Eq_2 ecx_193;
		malloc_consolidate(edx_45, gs, out ecx_193, out edx_515, out ebx_516, out ebp_67, out edi_517);
		struct Eq_38110 * eax_80 = *dwLoc34;
		if (eax_80 <= (struct Eq_38110 *) 1007)
			dwLoc44_339 = (eax_80 >> 0x04) + 0x01;
		else if (eax_80 >> 0x06 <= 0x2D)
			dwLoc44_339 = (eax_80 >> 0x06) + 0x31;
		else if (eax_80 >> 0x09 > 0x14)
		{
			if (eax_80 >> 0x0C <= 0x0A)
				dwLoc44_339 = (eax_80 >> 0x0C) + 110;
			else if (eax_80 >> 0x0F <= 0x04)
				dwLoc44_339 = (eax_80 >> 0x0F) + 0x77;
			else
			{
				uint32 eax_163 = eax_80 >> 0x12;
				if (eax_80 >> 0x12 > 0x02)
					eax_163 = 0x02;
				dwLoc44_339 = eax_163 + 0x7C;
			}
		}
		else
			dwLoc44_339 = (eax_80 >> 0x09) + 0x5B;
		Eq_38097 ebx_100 = 0x01;
		uint32 eax_95 = -eax_80;
		struct Eq_38140 * edi_108 = (word32) dwLoc3C + 56;
		do
		{
			if (ebx_100 == 0x01 || dwLoc44_339 <= ebx_100)
			{
				struct Eq_38140 * esi_110;
				for (esi_110 = edi_108->dw000C; edi_108 != esi_110; esi_110 = esi_110->dw000C)
				{
					ui32 eax_122 = esi_110->dw0004;
					if ((eax_122 & ~0x07) >u eax_80 + 0x17)
					{
						word32 edx_130 = esi_110 + (eax_80 + 0x17) & eax_95;
						if (edx_130 <u esi_110 + 0x18)
						{
							word32 edx_520;
							word32 eax_518;
							word32 ecx_519;
							__malloc_assert(ebp_67 + 4294793272, 0x12BC, ebp_67 + ~0x0002B6DA, out eax_518, out ecx_519, out edx_520);
						}
						if (edx_130 >=u esi_110 + (eax_122 & ~0x07))
						{
							word32 eax_521;
							word32 edx_523;
							word32 ecx_522;
							__malloc_assert(ebp_67 + ~0x0002A78F, 4797, ebp_67 + ~0x0002B6DA, out eax_521, out ecx_522, out edx_523);
						}
						ecx_193 = edx_130 - esi_110;
						struct Eq_38140 * eax_194 = (eax_122 & ~0x07) - ecx_193;
						if (eax_80 - (struct Eq_38205 *) 0x01 < eax_194)
						{
							word32 edx_524;
							ecx_193 = __madvise(gs, edx_130, eax_194 & eax_95, 0x04, out edx_524);
						}
					}
				}
			}
			esp_18 = fp - 76;
			ebx_100 = (word32) ebx_100.u0 + 1;
			++edi_108;
		} while (ebx_100 != 0x80);
		if (dwLoc3C == dwLoc24)
		{
			word32 edx_525;
			systrim.isra.1.constprop.11(dwArg04, out ecx_193, out edx_525);
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 v19_268 = *dwLoc3C - 0x01;
		*dwLoc3C = v19_268;
		if (v19_268 != 0x00)
			__lll_unlock_wake_private(dwLoc3C, ecx_193, dwLoc3C, gs);
		Eq_2 eax_286 = *((word32) dwLoc3C + 0x0448);
		dwLoc3C = eax_286;
	} while (eax_286 != dwLoc24);
}

// 0805E4F0: void __malloc_usable_size(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_38286) dwArg04, Stack word32 dwArg08)
void __malloc_usable_size(struct Eq_9 * gs, word32 dwArg00, struct Eq_38286 * dwArg04, word32 dwArg08)
{
	if (dwArg04 == null)
		return;
	ui32 eax_37 = dwArg04->dwFFFFFFFC;
	if (using_malloc_checking != 0x01)
		return;
	ui32 esi_48 = dwArg04 - (struct Eq_38299 *) 0x08 >> 0x03 ^ dwArg04 - (struct Eq_38299 *) 0x08 >> 11;
	if ((byte) esi_48 == 0x01)
		esi_48 = 0x02;
	Eq_38324 eax_63 = (eax_37 & ~0x07) - 0x01 + (uint32) ((int8) ((eax_37 & 0x02) == 0x00)) * 0x04;
	word32 edx_68 = CONVERT(Mem36[dwArg04 - 0x08 + eax_63:byte], byte, word32);
	byte dl_69 = (byte) edx_68;
	if (dl_69 == (byte) esi_48)
	{
l0805E5BB:
	}
	else
	{
		if (dl_69 != 0x00 && eax_63 >= (word32) edx_68 + 8)
		{
			do
			{
				eax_63 -= edx_68;
				edx_68 = CONVERT(Mem36[dwArg04 - 0x08 + eax_63:byte], byte, word32);
				byte dl_88 = (byte) edx_68;
				if (dl_88 == (byte) esi_48)
					goto l0805E5BB;
			} while (dl_88 != 0x00 && (word32) edx_68 + 8 <= eax_63);
		}
		word32 ecx_224;
		word32 edx_225;
		malloc_printerr(out ecx_224, out edx_225);
		mallinfo(gs, dwArg00, dwArg04, dwArg08);
	}
}

// 0805E5D0: void mallinfo(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_38286) dwArg04, Stack word32 dwArg08)
// Called from:
//      __malloc_usable_size
void mallinfo(struct Eq_9 * gs, word32 dwArg00, struct Eq_38286 * dwArg04, word32 dwArg08)
{
	Eq_2 ebx_17 = 0x080CE000;
	Eq_2175 eax_20 = gs->t0014;
	if (__libc_malloc_initialized < 0x00)
		ebx_17 = ptmalloc_init(gs);
	word32 ecx_179;
	word32 * edi_176 = fp - 0x48;
	for (ecx_179 = 0x0A; ecx_179 != 0x00; --ecx_179)
	{
		*edi_176 = 0x00;
		++edi_176;
	}
	Eq_2 edi_46 = (word32) ebx_17 + 0x0500;
	Eq_2 ebx_101 = edi_46;
	do
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_61;
		if (!__cmpxchg(*ebx_101, 0x01, 0x00, out eax_61))
			__lll_lock_wait_private(eax_61, ebx_101, gs);
		Eq_2 edx_79;
		Eq_2 ecx_78 = int_mallinfo(ebx_101, fp - 0x48, out edx_79);
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v16_90 = *ebx_101 - 0x01;
		*ebx_101 = v16_90;
		if (v16_90 != 0x00)
			__lll_unlock_wake_private(ebx_101, ecx_78, edx_79, gs);
		ebx_101 = *((word32) ebx_101 + 0x0448);
	} while (ebx_101 != edi_46);
	dwArg04->dw0000 = dwLoc48;
	dwArg04->dw0004 = dwLoc44;
	dwArg04->dw0008 = dwLoc40;
	dwArg04->dw000C = dwLoc3C;
	dwArg04->dw0010 = dwLoc38;
	dwArg04->dw0014 = dwLoc34;
	dwArg04->dw0018 = dwLoc30;
	dwArg04->dw001C = dwLoc2C;
	dwArg04->dw0020 = dwLoc28;
	dwArg04->dw0024 = dwLoc24;
	if ((eax_20 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_357;
	word32 edx_358;
	__stack_chk_fail(out ecx_357, out edx_358);
	__malloc_stats(gs, dwArg00, dwArg04, dwArg08);
}

// 0805E6E0: void __malloc_stats(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_38286) dwArg04, Stack word32 dwArg08)
// Called from:
//      mallinfo
void __malloc_stats(struct Eq_9 * gs, word32 dwArg00, struct Eq_38286 * dwArg04, word32 dwArg08)
{
	Eq_2175 esi_21 = gs->t0014;
	if (__libc_malloc_initialized < 0x00)
		ptmalloc_init(gs);
	Eq_2 eax_44 = _IO_stderr;
	Eq_2 edx_45 = *((word32) eax_44 + 60);
	*((word32) eax_44 + 60) = edx_45 | 0x02;
	Eq_2 ebx_200 = 0x080CE500;
	do
	{
		word32 * edi_349 = fp - 0x48;
		word32 ecx_352;
		for (ecx_352 = 0x0A; ecx_352 != 0x00; --ecx_352)
		{
			*edi_349 = 0x00;
			++edi_349;
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_83;
		if (!__cmpxchg(*ebx_200, 0x01, 0x00, out eax_83))
			__lll_lock_wait_private(eax_83, ebx_200, gs);
		word32 edx_554;
		int_mallinfo(ebx_200, fp - 0x48, out edx_554);
		Eq_2 ebx_126;
		word32 edi_555;
		__fprintf(ebx_200, gs, _IO_stderr, 134884156, out ebx_126, out edi_555);
		Eq_2 ebx_147;
		word32 edi_556;
		__fprintf(ebx_126, gs, _IO_stderr, 134884167, out ebx_147, out edi_556);
		Eq_2 ebx_168;
		word32 edi_557;
		Eq_2 ecx_169 = __fprintf(ebx_147, gs, _IO_stderr, 0x080A2B60, out ebx_168, out edi_557);
		if (gs->t000C != 0x00)
			__lock();
		word32 v26_186 = *ebx_168 - 0x01;
		*ebx_168 = v26_186;
		if (v26_186 != 0x00)
			__lll_unlock_wake_private(ebx_168, ecx_169, dwLoc48, gs);
		ebx_200 = *((word32) ebx_168 + 0x0448);
	} while (ebx_200 != 0x080CE500);
	fwrite(gs, 134884217, 0x01, 0x14, _IO_stderr);
	Eq_2 ebx_242;
	word32 edi_558;
	__fprintf(0x080CE000, gs, _IO_stderr, 134884167, out ebx_242, out edi_558);
	Eq_2 ebx_263;
	word32 edi_265;
	__fprintf(ebx_242, gs, _IO_stderr, 0x080A2B60, out ebx_263, out edi_265);
	Eq_2 ebx_284;
	word32 edi_286;
	__fprintf(ebx_263, gs, _IO_stderr, edi_265 + 4294790030, out ebx_284, out edi_286);
	word32 edi_560;
	word32 ebx_559;
	__fprintf(ebx_284, gs, _IO_stderr, edi_286 + 4294790055, out ebx_559, out edi_560);
	*((word32) _IO_stderr + 60) = edx_45;
	if ((esi_21 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_561;
	word32 edx_562;
	__stack_chk_fail(out ecx_561, out edx_562);
	__mallopt(gs, dwArg00, dwArg04, dwArg08);
}

// 0805E8C0: void __mallopt(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_38286) dwArg04, Stack word32 dwArg08)
// Called from:
//      __malloc_stats
void __mallopt(struct Eq_9 * gs, word32 dwArg00, struct Eq_38286 * dwArg04, word32 dwArg08)
{
	Eq_2 ebx_15 = 0x080CE000;
	if (__libc_malloc_initialized < 0x00)
		ebx_15 = ptmalloc_init(gs);
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_42;
	if (!__cmpxchg(*((word32) ebx_15 + 0x0500), 0x01, 0x00, out eax_42))
		__lll_lock_wait_private(eax_42, (word32) ebx_15 + 0x0500, gs);
	struct Eq_38728 * ebx_57;
	Eq_2 ecx_58;
	up32 edi_61;
	word32 ebp_157;
	word32 edx_156;
	malloc_consolidate((word32) ebx_15 + 0x0500, gs, out ecx_58, out edx_156, out ebx_57, out ebp_157, out edi_61);
	if (edi_61 > 0x01)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 v16_76 = ebx_57->dw0500 - 0x01;
		ebx_57->dw0500 = v16_76;
		if (v16_76 != 0x00)
			__lll_unlock_wake_private(&ebx_57->dw0500, ecx_58, 0x01, gs);
	}
	else
	{
		<anonymous> * ecx_97 = ebx_57 + (ebx_57->aFFFD59E8)[edi_61 + 0x08] / 0x0504;
		ecx_97();
	}
}

// 0805EA70: void posix_memalign(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void posix_memalign(struct Eq_9 * gs, word32 dwArg00, word32 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	if (((dwArg08 >> 0x02) - 0x01 & dwArg08 >> 0x02 | dwArg08 & 0x03) != 0x00 || dwArg08 == 0x00)
		return;
	word32 eax_30 = _mid_memalign(dwArg08, dwArg00, dwArg0C, gs);
	if (eax_30 != 0x00)
		*dwArg04 = eax_30;
}

// 0805EAD0: void malloc_info(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack Eq_2 dwArg08)
void malloc_info(struct Eq_9 * gs, word32 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebx_14 = dwArg08;
	if (dwArg04 != 0x00)
		return;
	if (__libc_malloc_initialized < 0x00)
		ebx_14 = ptmalloc_init(gs);
	fputs(gs, 134884289, ebx_14);
	__malloc_info.part.10(gs);
}

// 0805EB40: void __default_morecore(Register (ptr32 Eq_9) gs, Stack Eq_1921 dwArg04)
void __default_morecore(struct Eq_9 * gs, Eq_1921 dwArg04)
{
	word32 edx_33;
	__sbrk(gs, dwArg04, out edx_33) != ~0x00;
}

// 0805EB60: Register Eq_2 strchr(Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Register out (ptr32 Eq_4888) ecxOut, Register out (ptr32 Eq_4889) edxOut)
// Called from:
//      __dcigettext
//      read_alias_file
//      strstr
//      __gconv_open
//      __gconv_get_path
//      __gconv_read_conf
//      setlocale
//      _nl_load_locale_from_archive
//      __setenv
//      __unsetenv
//      _dl_dst_count
//      _dl_map_object
//      dl_open_worker
Eq_2 strchr(Eq_2 dwArg04, Eq_2 bArg08, struct Eq_4888 & ecxOut, struct Eq_4889 & edxOut)
{
	struct Eq_4888 * ecx_113;
	byte dl_9 = (byte) dwArg08;
	Eq_38836 edx_12 = SEQ(SLICE(dwArg08, word16, 16), dl_9, dl_9);
	struct Eq_4889 * edx_231 = SEQ(edx_12, edx_12);
	Eq_2 eax_137 = dwArg04;
	word24 ecx_24_8_252 = SLICE(edx_12, word24, 8);
	word24 edx_24_8_267 = SLICE(edx_231, word24, 8);
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		byte cl_21 = *dwArg04;
		ecx_113 = SEQ(ecx_24_8_252, cl_21);
		if (dl_9 == cl_21)
			goto l0805ECC5;
		ecx_113 = SEQ(ecx_24_8_252, cl_21);
		if (cl_21 == 0x00)
			goto l0805EC9A;
		eax_137 = (word32) dwArg04 + 1;
		if (((byte) dwArg04 + 0x01 & 0x03) != 0x00)
		{
			byte cl_33 = *((word32) dwArg04 + 1);
			ecx_113 = SEQ(ecx_24_8_252, cl_33);
			if (dl_9 == cl_33)
				goto l0805ECC5;
			ecx_113 = SEQ(ecx_24_8_252, cl_33);
			if (cl_33 == 0x00)
				goto l0805EC9A;
			eax_137 = (word32) dwArg04 + 2;
			if (((byte) dwArg04 + 0x02 & 0x03) != 0x00)
			{
				byte cl_44 = *((word32) dwArg04 + 2);
				ecx_113 = SEQ(ecx_24_8_252, cl_44);
				if (dl_9 == cl_44)
					goto l0805ECC5;
				ecx_113 = SEQ(ecx_24_8_252, cl_44);
				if (cl_44 == 0x00)
					goto l0805EC9A;
				eax_137 = (word32) dwArg04 + 3;
			}
		}
	}
	while (true)
	{
		struct Eq_4888 * ecx_306 = *eax_137 ^ edx_231;
		if (ecx_306 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_306 - 0x01010101 ^ ecx_306 | ~0x01010100) != 0x01)
			break;
		ecx_113 = ecx_306 ^ edx_231;
		if (ecx_113 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		struct Eq_4888 * ecx_308 = *((word32) eax_137 + 4) ^ edx_231;
		if (ecx_308 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_308 - 0x01010101 ^ ecx_308 | ~0x01010100) != 0x01)
		{
l0805ECA4:
			eax_137 = (word32) eax_137 + 4;
			ecx_306 = ecx_308;
			break;
		}
		ecx_113 = ecx_308 ^ edx_231;
		if (ecx_113 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		struct Eq_4888 * ecx_102 = *((word32) eax_137 + 8) ^ edx_231;
		if (ecx_102 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_102 - 0x01010101 ^ ecx_102 | ~0x01010100) != 0x01)
		{
l0805ECA1:
			eax_137 = (word32) eax_137 + 4;
			ecx_308 = ecx_102;
			goto l0805ECA4;
		}
		ecx_113 = ecx_102 ^ edx_231;
		if (ecx_113 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		ecx_102 = *((word32) eax_137 + 0x0C) ^ edx_231;
		if (ecx_102 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_102 - 0x01010101 ^ ecx_102 | ~0x01010100) != 0x01)
		{
			eax_137 = (word32) eax_137 + 4;
			goto l0805ECA1;
		}
		ecx_113 = ecx_102 ^ edx_231;
		if (ecx_113 >= (struct Eq_4888 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		eax_137 = (word32) eax_137 + 16;
	}
	byte ch_165 = SLICE(ecx_306, byte, 8);
	byte cl_145 = (byte) ecx_306;
	ecx_113 = ecx_306;
	edx_231 = SEQ(edx_24_8_267, dl_9);
	if (cl_145 == 0x00)
	{
l0805ECC5:
		ecxOut = ecx_113;
		edxOut = edx_231;
		return eax_137;
	}
	ecx_113 = ecx_306;
	if (cl_145 != dl_9)
	{
		eax_137 = (word32) eax_137 + 1;
		ecx_113 = ecx_306;
		if (ch_165 == 0x00)
			goto l0805ECC5;
		ecx_113 = ecx_306;
		if (ch_165 != dl_9)
		{
			eax_137 = (word32) eax_137 + 1;
			ecx_113 = ecx_306 >> 0x10;
			byte cl_189 = (byte) (ecx_306 >> 0x10);
			if (cl_189 == 0x00)
				goto l0805ECC5;
			if (cl_189 != dl_9)
			{
				eax_137 = (word32) eax_137 + 2;
				goto l0805ECC5;
			}
		}
	}
l0805EC9A:
	ecxOut = ecx_113;
	edxOut = edx_231;
	return 0x00;
}

// 0805ECD0: Register word32 strcmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      transcmp
//      _nl_find_msg
//      __dcigettext
//      _nl_make_l10nflist
//      _nl_explode_name
//      __gconv_alias_compare
//      derivation_compare
//      find_derivation
//      __gconv_compare_alias
//      __gconv_find_transform
//      insert_module
//      detect_conflict
//      __gconv_get_builtin_trans
//      find_module_idx
//      __gconv_compare_alias_cache
//      known_compare
//      new_composite_name
//      setlocale
//      _nl_find_locale
//      _nl_load_locale_from_archive
//      wctrans
//      add_name_to_object.isra.4
//      _dl_map_object
//      check_match
//      do_lookup_x
//      _dl_name_match_p
//      _dl_load_cache_lookup
//      _dl_check_map_versions
word32 strcmp(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 ecx_17 = dwArg04;
	Eq_2 edx_10 = dwArg08;
	do
	{
		cu8 al_9 = *ecx_17;
		if (al_9 != *edx_10)
		{
			word32 eax_13 = 0x01;
			if (al_9 < *edx_10)
				eax_13 = ~0x00;
			ecxOut.u0 = ~0x00;
			edxOut = edx_10;
			return eax_13;
		}
		ecx_17 = (word32) ecx_17 + 1;
		edx_10 = (word32) edx_10 + 1;
	} while (al_9 != 0x00);
	ecxOut = ecx_17;
	edxOut = edx_10;
	return 0x00;
}

// 0805ED00: void strcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __assert_fail_base
//      __dcigettext
void strcpy(Eq_2 dwArg04, Eq_2 dwArg08)
{
	word32 ecx_60;
	word32 edx_61;
	word32 ecx_62;
	word32 edx_63;
	memcpy(dwArg04, dwArg08, (word32) strlen(dwArg08, out ecx_60, out edx_61) + 1, out ecx_62, out edx_63);
}

// 0805ED40: Register word32 strcspn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _nl_find_msg
//      __strtok_r
//      __strsep_g
word32 strcspn(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_138 = dwArg08;
	do
	{
		Eq_39070 cl_140 = *eax_138;
		if (cl_140 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_140].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_140;
		Eq_39077 cl_148 = *((word32) eax_138 + 1);
		if (cl_148 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_148].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_148;
		Eq_39087 cl_154 = *((word32) eax_138 + 2);
		if (cl_154 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_154].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_154;
		Eq_39097 cl_160 = *((word32) eax_138 + 3);
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_160].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_160;
		eax_138 = (word32) eax_138 + 4;
	} while (cl_160 != 0x00);
	struct Eq_39067 * eax_169 = dwArg04 - 0x04;
	do
	{
		++eax_169;
		Eq_39148 cl_173 = eax_169->b0000;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == cl_173)
			return eax_169 - dwArg04;
		Eq_39115 cl_179 = eax_169->b0001;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_179].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == cl_179)
			goto l0805EDE8;
		Eq_39126 cl_183 = eax_169->b0002;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_183].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == cl_183)
			goto l0805EDE7;
		Eq_39137 cl_187 = eax_169->b0003;
	} while ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_187].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] != cl_187);
	eax_169 = (struct Eq_39067 *) &eax_169->b0001;
l0805EDE7:
	eax_169 = (struct Eq_39067 *) &eax_169->b0001;
l0805EDE8:
	eax_169 = (struct Eq_39067 *) &eax_169->b0001;
	return eax_169 - dwArg04;
}

// 0805EE00: Register Eq_2 strdup(Stack Eq_2 dwArg04)
// Called from:
//      _nl_find_msg
//      find_derivation
//      setlocale
//      _nl_load_locale_from_archive
//      expand_dynamic_string_token
//      cache_rpath.part.6
//      _dl_map_object
//      _dl_load_cache_lookup
Eq_2 strdup(Eq_2 dwArg04)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_94;
	word32 edx_95;
	Eq_2 eax_20 = strlen(dwArg04, out ecx_94, out edx_95);
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_98;
	word32 edx_99;
	word32 ebx_100;
	word32 ebp_101;
	word32 esi_102;
	word32 edi_103;
	Eq_2 eax_29 = __libc_malloc(gs, stackArg0, (word32) eax_20 + 1, out ecx_98, out edx_99, out ebx_100, out ebp_101, out esi_102, out edi_103);
	if (eax_29 != 0x00)
	{
		word32 ecx_104;
		word32 edx_105;
		eax_29 = memcpy(eax_29, dwArg04, (word32) eax_20 + 1, out ecx_104, out edx_105);
	}
	return eax_29;
}

// 0805EE50: Register int32 strlen(Stack Eq_2 dwArg04, Register out Eq_2609 ecxOut, Register out Eq_2610 edxOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      read_alias_file
//      _nl_make_l10nflist
//      getenv
//      ____strtoul_l_internal
//      __correctly_grouped_prefixmb
//      locked_vfxprintf
//      _IO_puts
//      __libc_message
//      strcpy
//      strdup
//      __mbsrtowcs_l
//      __sysconf_check_spec
//      getcwd
//      _dl_non_dynamic_init
//      __gconv_open
//      find_derivation
//      __gconv_get_path
//      find_module
//      __gconv_find_shlib
//      new_composite_name
//      _nl_find_locale
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __unsetenv
//      ____strtol_l_internal
//      group_number
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      __printf_fp_l
//      __printf_fphex
//      fputs
//      strerror_r
//      argz_create_sep
//      __argz_add_sep
//      wctrans
//      is_dst
//      add_name_to_object.isra.4
//      open_verify.constprop.7
//      expand_dynamic_string_token
//      fillin_rpath
//      _dl_init_paths
//      _dl_map_object
//      _dl_new_object
//      _dl_important_hwcaps
//      _dl_debug_vdprintf
//      _dl_start_profile
//      _dl_get_origin
//      _dl_exception_create
//      _dl_exception_create_format
//      _dl_load_cache_lookup
//      _dl_map_object_deps
//      uw_frame_state_for
//      get_cie_encoding
int32 strlen(Eq_2 dwArg04, union Eq_2609 & ecxOut, union Eq_2610 & edxOut)
{
	Eq_2 eax_101 = dwArg04;
	Eq_2609 ecx_123 = dwArg04 & 0x03;
	if ((dwArg04 & 0x03) != 0x00)
	{
		if (*dwArg04 == 0x00)
			goto l0805EEFE;
		ecx_123 = dwArg04 & 0x03 ^ 0x03;
		eax_101 = (word32) dwArg04 + 1;
		byte ch_19 = SLICE(ecx_123, byte, 8);
		if (ecx_123 != 0x00)
		{
			if (*((word32) dwArg04 + 1) == ch_19)
				goto l0805EEFE;
			eax_101 = (word32) dwArg04 + 2;
			--ecx_123;
			byte ch_26 = SLICE(ecx_123 - 0x01, byte, 8);
			if (ecx_123 != 0x01)
			{
				if (*((word32) dwArg04 + 2) == ch_26)
					goto l0805EEFE;
				eax_101 = dwArg04 - 0x0D;
l0805EE84:
				eax_101 = (word32) eax_101 + 16;
			}
		}
	}
	Mem35 = Mem0;
	Eq_2609 ecx_171 = *eax_101;
	edx = (word32) ecx_171.u0 - 0x01010101;
	if (ecx_171 >= ~0x01010100)
	{
l0805EEEB:
		byte ch_103 = SLICE(ecx_171, byte, 8);
		ecx_123 = ecx_171;
		if ((byte) ecx_171 != 0x00)
		{
			eax_101 = (word32) eax_101 + 1;
			ecx_123 = ecx_171;
			if (ch_103 != 0x00)
			{
				eax_101 = (word32) eax_101 + 1;
				if ((ecx_171 & 0x00FF0000) != 0x00)
					eax_101 = (word32) eax_101 + 2;
			}
		}
l0805EEFE:
		ecxOut = ecx_123;
		edxOut = edx;
		return eax_101 - dwArg04;
	}
	edx = ((word32) ecx_171.u0 - 0x01010101 ^ ecx_171 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEEB;
	Eq_2609 ecx_173 = *((word32) eax_101 + 4);
	edx = (word32) ecx_173 - 0x01010101;
	if (ecx_173 >= ~0x01010100)
	{
l0805EEE8:
		eax_101 = (word32) eax_101 + 4;
		ecx_171 = ecx_173;
		goto l0805EEEB;
	}
	edx = ((word32) ecx_173 - 0x01010101 ^ ecx_173 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEE8;
	Eq_2609 ecx_175 = *((word32) eax_101 + 8);
	edx = (word32) ecx_175 - 0x01010101;
	if (ecx_175 >= ~0x01010100)
	{
l0805EEE5:
		eax_101 = (word32) eax_101 + 4;
		ecx_173 = ecx_175;
		goto l0805EEE8;
	}
	edx = ((word32) ecx_175 - 0x01010101 ^ ecx_175 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEE5;
	ecx_175 = *((word32) eax_101 + 0x0C);
	edx = (word32) ecx_175 - 0x01010101;
	if (ecx_175 >= ~0x01010100)
	{
l0805EEE2:
		eax_101 = (word32) eax_101 + 4;
		goto l0805EEE5;
	}
	edx = ((word32) ecx_175 - 0x01010101 ^ ecx_175 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEE2;
	goto l0805EE84;
}

// 0805EF10: Register word32 strncmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut)
// Called from:
//      getenv
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __unsetenv
//      is_dst
word32 strncmp(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut)
{
	word32 eax_110;
	word32 edi_112;
	Eq_2 esi_16 = dwArg0C;
	Eq_2 ecx_104 = dwArg04;
	Eq_2 edx_18 = dwArg08;
	if (dwArg0C > 0x03)
	{
		Eq_2 ebp_29 = (word32) dwArg04 + (dwArg0C & ~0x03);
		do
		{
			eax_110 = (word32) *ecx_104;
			byte al_36 = (byte) eax_110;
			edi_112 = (word32) *edx_18;
			if (al_36 == 0x00 || al_36 != (byte) edi_112)
				goto l0805EFE4;
			eax_110 = (word32) *((word32) ecx_104 + 1);
			byte al_46 = (byte) eax_110;
			edi_112 = (word32) *((word32) edx_18 + 1);
			if (al_46 == 0x00 || al_46 != (byte) edi_112)
				goto l0805EFE4;
			eax_110 = (word32) *((word32) ecx_104 + 2);
			byte al_56 = (byte) eax_110;
			edi_112 = (word32) *((word32) edx_18 + 2);
			if (al_56 == 0x00 || al_56 != (byte) edi_112)
				goto l0805EFE4;
			ecx_104 = (word32) ecx_104 + 4;
			eax_110 = (word32) *((word32) ecx_104 - 1);
			edx_18 = (word32) edx_18 + 4;
			byte al_68 = (byte) eax_110;
			edi_112 = (word32) *((word32) edx_18 - 1);
			if (al_68 == 0x00 || al_68 != (byte) edi_112)
				goto l0805EFE4;
		} while (ecx_104 != ebp_29);
		esi_16 = dwArg0C & 0x03;
	}
	else
	{
		edi_112 = 0x00;
		eax_110 = 0x00;
	}
	if (esi_16 != 0x00)
	{
		eax_110 = (word32) *ecx_104;
		edi_112 = (word32) *edx_18;
		byte al_95 = (byte) eax_110;
		struct Eq_39417 * ebp_107 = (word32) ecx_104 + 1;
		ecx_104 = (word32) edx_18 + 1;
		if (al_95 == (byte) edi_112)
		{
			word32 esi_99 = esi_16 + edx_18;
			if (al_95 != 0x00)
			{
				while (esi_99 != ecx_104)
				{
					++ebp_107;
					eax_110 = (word32) ebp_107->bFFFFFFFF;
					ecx_104 = (word32) ecx_104 + 1;
					byte al_113 = (byte) eax_110;
					edi_112 = (word32) *((word32) ecx_104 - 1);
					if (al_113 == 0x00 || al_113 != (byte) edi_112)
						break;
				}
			}
		}
	}
l0805EFE4:
	ecxOut = ecx_104;
	return eax_110 - (word32) ((byte) edi_112);
}

// 0805EFF0: Register Eq_2 critical_factorization(Register Eq_2 eax, Register (ptr32 int32) ecx, Register Eq_2 edx)
// Called from:
//      two_way_long_needle
//      strstr
Eq_2 critical_factorization(Eq_2 eax, int32 * ecx, Eq_2 edx)
{
	int32 ebp_46 = 0x01;
	int32 ebx_18 = 0x01;
	Eq_2 dwLoc20_152 = ~0x00;
	Eq_2 esi_26 = 0x00;
l0805F018:
	Eq_2 ecx_29 = (word32) esi_26 + ebx_18;
	while (ecx_29 < edx)
	{
		byte dl_42 = Mem31[eax + dwLoc20_152 + ebx_18:byte];
		if (Mem31[eax + ecx_29:byte] >=u dl_42)
		{
			if (Mem31[eax + ecx_29:byte] != dl_42)
			{
				dwLoc20_152 = esi_26;
				ebp_46 = 0x01;
				esi_26 = (word32) esi_26 + 1;
				ebx_18 = 0x01;
			}
			else if (ebx_18 != ebp_46)
				++ebx_18;
			else
			{
				esi_26 = ecx_29;
				ebx_18 = 0x01;
			}
			goto l0805F018;
		}
		esi_26 = ecx_29;
		ebx_18 = 0x01;
		ebp_46 = ecx_29 - dwLoc20_152;
		ecx_29 = (word32) ecx_29 + 1;
	}
	*ecx = ebp_46;
	int32 dwLoc18_161 = 0x01;
	int32 ebx_101 = 0x01;
	Eq_2 edi_105 = ~0x00;
	Eq_2 esi_100 = 0x00;
l0805F068:
	Eq_2 ecx_115 = (word32) esi_100 + ebx_101;
	while (ecx_115 < edx)
	{
		byte dl_93 = Mem90[eax + edi_105 + ebx_101:byte];
		if (Mem90[eax + ecx_115:byte] <=u dl_93)
		{
			if (Mem90[eax + ecx_115:byte] != dl_93)
			{
				edi_105 = esi_100;
				dwLoc18_161 = 0x01;
				esi_100 = (word32) esi_100 + 1;
				ebx_101 = 0x01;
			}
			else if (ebx_101 != dwLoc18_161)
				++ebx_101;
			else
			{
				esi_100 = ecx_115;
				ebx_101 = 0x01;
			}
			goto l0805F068;
		}
		ebx_101 = 0x01;
		dwLoc18_161 = ecx_115 - edi_105;
		esi_100 = ecx_115;
		ecx_115 = (word32) ecx_115 + 1;
	}
	Eq_2 edi_123 = (word32) edi_105 + 1;
	Eq_2 eax_124 = (word32) dwLoc20_152 + 1;
	if (edi_123 >= (word32) dwLoc20_152 + 1)
	{
		*ecx = dwLoc18_161;
		eax_124 = edi_123;
	}
	return eax_124;
}

// 0805F140: Register Eq_2 two_way_long_needle(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 byte) ecxOut, Register out Eq_2 edxOut)
// Called from:
//      strstr
Eq_2 two_way_long_needle(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, byte & ecxOut, union Eq_2 & edxOut)
{
	Eq_2175 eax_30 = gs->t0014;
	Eq_2 dwLoc0450_570 = edx;
	Eq_2 eax_36 = critical_factorization(ecx, fp - 0x0424, dwArg04);
	word32 * eax_45 = fp - 0x0420;
	do
	{
		*eax_45 = (word32) dwArg04;
		++eax_45;
	} while (eax_45 != fp - 0x20);
	if (dwArg04 != 0x00)
	{
		word32 ebp_58 = dwArg04 + ecx;
		Eq_2 eax_59 = ecx;
		word32 ebx_60 = (word32) dwArg04 + (ecx - 0x01);
		do
		{
			(fp - 0x0420)[(word32) *eax_59] = ebx_60 - eax_59;
			eax_59 = (word32) eax_59 + 1;
		} while (ebp_58 != eax_59);
	}
	Eq_2 eax_294;
	byte * ecx_143;
	Eq_2 edx_150;
	Eq_39566 ebx_215;
	struct Eq_39567 * esp_154 = fp - 1116;
	word32 edx_849;
	word32 ecx_848;
	if (memcmp(ecx, (word32) ecx + dwLoc0424, eax_36, out ecx_848, out edx_849) != 0x00)
	{
		Eq_2 eax_107 = dwArg04 - eax_36;
		if (eax_107 < eax_36)
			eax_107 = eax_36;
		Eq_39566 ebx_111 = 0x00;
		up32 eax_113 = (word32) eax_107 + 1;
		word32 eax_119 = 0x01 - eax_36;
		while (true)
		{
			word32 ebp_129 = ebx_111 + dwArg04;
			if (ebp_129 > dwLoc0450_570)
			{
				word32 edx_854;
				edx_150 = dwLoc0450_570 + strnlen(eax + dwLoc0450_570, dwArg04 + 0x0200, out ecx_143, out edx_854);
				dwLoc0450_570 = edx_150;
				if (ebp_129 > edx_150)
					goto l0805F377;
			}
			esp_154 = fp - 1116;
			word32 eax_159 = (fp - 0x0420)[(word32) *((word32) ebp_129 + (eax - 0x01))];
			if (eax_159 != 0x00)
				ebx_111 = (word32) ebx_111.u0 + eax_159;
			else
			{
				word32 ecx_168 = ecx + eax_36;
				word32 eax_171 = ebx_111 + eax_36 + eax;
				if (eax_36 < dwArg04 - 0x01)
				{
					Eq_2 eax_178;
					if (*ecx_168 == *eax_171)
					{
						eax_178 = eax_36;
						word32 ecx_183 = eax + ebx_111;
						do
						{
							++eax_178;
							if (eax_178 >= dwArg04 - 0x01)
								goto l0805F466;
						} while (Mem155[ecx + eax_178:byte] == Mem155[ecx_183 + eax_178:byte]);
					}
					else
						eax_178 = eax_36;
					ebx_111 = (word32) eax_178 + ((word32) ebx_111 + eax_119);
				}
				else
				{
l0805F466:
					ebx_215 = ebx_111;
					edx_150 = eax_36;
					byte * eax_214 = eax_36 - (byte *) 0x01;
					word32 ebp_217 = ecx + (eax_36 - 0x01);
					ecx_143 = ebx_111 + (eax_36 - 0x01) + eax;
					if (eax_36 == 0x00)
					{
l0805F4AA:
						eax_294 = Mem408[esp_154 + 0x10:word32] + ebx_215;
l0805F379:
						if ((eax_30 ^ gs->t0014) != 0x00)
						{
							word32 edx_852;
							word32 ecx_851;
							__stack_chk_fail(out ecx_851, out edx_852);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							Eq_2 edx_505;
							byte * ecx_506;
							Eq_2 eax_507 = strstr(gs, dwArg04, stackArg8, out ecx_506, out edx_505);
							ecxOut = ecx_506;
							edxOut = edx_505;
							return eax_507;
						}
						else
						{
							ecxOut = ecx_143;
							edxOut = edx_150;
							return eax_294;
						}
					}
					Eq_2 edi_223 = ecx_143 - eax_36;
					ecx_143 = (word32) *ecx_143;
					edx_150 = edi_223;
					if (*ebp_217 == (byte) ecx_143)
					{
						do
						{
							eax_214 -= (byte *) 0x01;
							if (eax_214 == (byte *) ~0x00)
								goto l0805F4AA;
							ecx_143 = CONVERT(Mem211[eax_214 + 0x01 + edi_223:byte], byte, word32);
						} while (Mem211[ecx + eax_214:byte] == SLICE(ecx_143, byte, 0));
					}
					ebx_111 = (word32) ebx_111 + eax_113;
				}
			}
		}
	}
	else
	{
		Eq_39566 ebx_252 = 0x00;
l0805F208:
		byte * ecx_261 = esp_154->dw000C;
		word32 ebp_264 = ebx_252 + dwArg04;
		if (ebp_264 <= ecx_261)
		{
l0805F240:
			do
			{
				up32 eax_302 = esp_154->a003C[(word32) ebp_264[esp_154[2] - 0x01]];
				if (eax_302 == 0x00)
				{
					Eq_39678 ecx_306 = esp_154->dw0014;
					Eq_39678 eax_307 = esp_154[3];
					esp_154->dw001C = dwArg04 - 0x01;
					if (ecx_306 >= eax_307)
						eax_307 = ecx_306;
					word32 ebp_320 = ecx + eax_307;
					ecx_143 = ebx_252 + eax_307 + Mem310[esp_154 + 0x10:word32];
					if (eax_307 >= dwArg04 - 0x01)
					{
l0805F2DE:
						Eq_2 eax_361 = esp_154[5];
						ebx_215 = ebx_252;
						Eq_2 ebp_362 = esp_154[3];
						edx_150 = eax_361;
						word32 eax_366 = eax_361 + ebx_252 + Mem310[esp_154 + 0x10:word32];
						if (esp_154->dw0014 < ebp_362)
						{
							esp_154->dw001C = eax_366 - ebp_362;
							ecx_143 = (word32) *esp_154->ptr002C;
							if (*eax_366 == (byte) ecx_143)
							{
								Eq_2 ebp_379 = esp_154->dw0014;
								ecx_143 = esp_154->dw001C;
								esp_154->dw0024 = (word32) ebx_252;
								while (true)
								{
									Eq_2 eax_383 = edx_150 - 0x01;
									if (ebp_379 == edx_150 || Mem381[ecx + eax_383:byte] != Mem381[(eax_383 + 0x01) + ecx_143:byte])
										break;
									edx_150 = eax_383;
								}
								ebx_215 = esp_154->dw0024;
							}
							else
								edx_150 = ebp_362;
						}
						else
							edx_150 = esp_154[3];
						if (esp_154->dw0014 + 0x01 > edx_150)
							goto l0805F4AA;
						Eq_39845 eax_519 = esp_154[4];
						esp_154->dw0014 = (up32) (dwArg04 - eax_519);
						ebx_252 = ebx_215 + eax_519;
						goto l0805F208;
					}
					else
					{
						if (*ecx_143 == *ebp_320)
						{
							ecx_143 = Mem310[esp_154 + 0x10:word32] + ebx_252;
							Eq_39678 edx_334 = esp_154->dw001C;
							do
							{
								eax_307 = (word32) eax_307 + 1;
								if (eax_307 >= edx_334)
									goto l0805F2DE;
							} while (Mem310[ecx + eax_307:byte] == Mem310[ecx_143 + eax_307:byte]);
						}
						up32 ebx_353 = ebx_252 - esp_154[3];
						esp_154->dw0014 = 0x00;
						ebx_252 = (word32) eax_307 + 1 + ebx_353;
						goto l0805F208;
					}
				}
				if (esp_154->dw0014 != 0x00)
				{
					up32 ebp_529 = esp_154[4];
					up32 edx_534 = dwArg04 - ebp_529;
					if ((int8) (ebp_529 > eax_302) != 0x00)
						eax_302 = edx_534;
				}
				ecx_261 = esp_154->dw000C;
				esp_154->dw0014 = 0x00;
				ebx_252 = (word32) ebx_252 + eax_302;
				ebp_264 = ebx_252 + dwArg04;
			} while (ebp_264 <= ecx_261);
			goto l0805F213;
		}
l0805F213:
		struct Eq_39628 * esp_268 = esp_154 - 0x08;
		esp_268->tFFFFFFFC = (word32) dwArg04 + 0x0200;
		Eq_2 eax_275 = ecx_261 + esp_268->dw0018;
		esp_268->ptr0014 = ecx_261;
		esp_268->tFFFFFFF8 = eax_275;
		word32 ecx_850;
		Mem289[esp_268 + 0x14:word32] = Mem279[esp_268 + 0x14:word32] + strnlen(esp_268->tFFFFFFF8, esp_268->tFFFFFFFC, out ecx_850, out edx_150);
		esp_154 = (struct Eq_39567 *) ((char *) &esp_268->tFFFFFFFC + 0x0C);
		ecx_143 = esp_268->ptr0014;
		if (ebp_264 <= ecx_143)
			goto l0805F240;
l0805F377:
		eax_294.u0 = 0x00;
		goto l0805F379;
	}
}

// 0805F500: Register Eq_2 strstr(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _nl_find_msg
//      __gettext_extract_plural
//      _IO_file_fopen
//      two_way_long_needle
Eq_2 strstr(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 dwLoc48_693;
	Eq_2 dwLoc4C_684;
	Eq_2 ecx_102 = (word32) *dwArg08;
	word32 eax_27 = (word32) *dwArg04;
	Eq_2 dwLoc40_681 = 0x080CE000;
	word24 nLoc3F_974 = SLICE(0x080CE000, word24, 8);
	Eq_2 cl_28 = (byte) ecx_102;
	Eq_2175 eax_24 = gs->t0014;
	Eq_2 al_30 = (byte) eax_27;
	ui24 eax_24_8_60 = SLICE(eax_27, word24, 8);
	if (al_30 == 0x00)
	{
		Eq_2 eax_35 = 0x00;
		if (cl_28 == 0x00)
			eax_35 = dwArg04;
		dwLoc4C_684 = eax_35;
		goto l0805F5E5;
	}
	if (cl_28 == 0x00)
	{
		dwLoc4C_684 = dwArg04;
		goto l0805F5E5;
	}
	Eq_2 ebx_45 = dwArg08;
	edx = dwArg04;
	ui32 esi_47 = 0x01;
	cl_53 = cl_28;
	do
	{
		Eq_2 cl_53;
		ebx_45 = (word32) ebx_45 + 1;
		edx = (word32) edx + 1;
		ecx_102 = (word32) *ebx_45;
		word32 eax_63 = (word32) *edx;
		cl_53 = (byte) ecx_102;
		esi_47 &= SEQ(eax_24_8_60, (int8) (al_30 == cl_53));
		al_30 = (byte) eax_63;
		eax_24_8_60 = SLICE(eax_63, word24, 8);
		if (al_30 == 0x00)
		{
			dwLoc4C_684.u0 = 0x00;
			dwLoc48_693 = SEQ(nLoc47, cl_28);
			if (cl_53 != 0x00)
				goto l0805F5E5;
			break;
		}
	} while (cl_53 != 0x00);
	dwLoc4C_684 = dwArg04;
	if ((byte) esi_47 != 0x00)
		goto l0805F5E5;
	Eq_2 eax_101 = strchr((word32) dwArg04 + 1, cl_28, out ecx_102, out edx);
	Eq_2 esi_93 = ebx_45 - dwArg08;
	dwLoc4C_684 = eax_101;
	if (eax_101 == 0x00 || esi_93 == 0x01)
	{
l0805F5E5:
		if ((eax_24 ^ gs->t0014) != 0x00)
		{
			word32 ecx_1182;
			word32 edx_1183;
			__stack_chk_fail(out ecx_1182, out edx_1183);
			Eq_2 ecx_655;
			Eq_2 edx_656;
			Eq_2 eax_654 = memcmp(dwLoc48_693, dwLoc44, dwLoc40_681, out ecx_655, out edx_656);
			ecxOut = ecx_655;
			edxOut = edx_656;
			return eax_654;
		}
		else
		{
			ecxOut = ecx_102;
			edxOut = edx;
			return dwLoc4C_684;
		}
	}
	word32 edi_115 = dwArg04 + esi_93;
	Eq_2 ebx_116 = ebx_45 - esi_93;
	Eq_2 edx_119 = edi_115 - eax_101;
	Eq_2 eax_121 = 0x01;
	if (edi_115 >= eax_101)
		eax_121 = edx_119;
	dwLoc48_693 = eax_121;
	if (esi_93 > 0x1F)
	{
		dwLoc4C_684 = two_way_long_needle(eax_101, ebx_116, eax_121, gs, esi_93, out ecx_102, out edx);
		goto l0805F5E5;
	}
	Eq_2 eax_134 = critical_factorization(ebx_116, fp - 0x24, esi_93);
	dwLoc44 = eax_134;
	word32 ecx_1178;
	word32 edx_1179;
	if (memcmp(ebx_116, ebx_116 + dwLoc24, eax_134, out ecx_1178, out edx_1179) == 0x00)
	{
		Eq_2 edi_383 = 0x00;
		struct Eq_4889 * ebx_384 = null;
		word32 eax_387 = eax_134 - 0x01 + ebx_116;
l0805F660:
		dwLoc40_681 = ebx_116;
		word32 edx_396 = esi_93 + ebx_384;
		if (edx_396 <= dwLoc48_693)
		{
l0805F69C:
			Eq_2 eax_427 = eax_134;
			if (eax_134 < edi_383)
				eax_427 = edi_383;
			word32 ecx_440 = ebx_116 + eax_427;
			word32 edx_442 = eax_427 + ebx_384 + eax_101;
			if (esi_93 > eax_427)
			{
				if (edx_442->b0000 == ecx_440->b0000)
				{
					word32 edx_452 = eax_101 + ebx_384;
					do
					{
						++eax_427;
						if (esi_93 == eax_427)
							goto l0805F6E9;
					} while (Mem426[ebx_116 + eax_427:byte] == Mem426[edx_452 + eax_427:byte]);
				}
				edi_383.u0 = 0x00;
				ebx_384 = eax_427 + 0x01 + (ebx_384 - eax_134);
				goto l0805F660;
			}
l0805F6E9:
			edx = eax_134 - (struct Eq_152150 *) 0x01;
			ecx_102 = ebx_384 + (eax_134 - 0x01) + eax_101;
			if (eax_134 > edi_383 && eax_387->b0000 == *ecx_102)
			{
				ecx_102 -= eax_134;
				while (true)
				{
					Eq_2 eax_505 = edx - (struct Eq_152166 *) 0x01;
					if (edi_383 == edx || Mem503[ebx_116 + eax_505:byte] != Mem503[(eax_505 + 0x01) + ecx_102:byte])
						break;
					edx = eax_505;
				}
			}
			else
				edx = eax_134;
			dwLoc40_681 = ebx_116;
			if (edi_383 + 0x01 <=u edx)
			{
				ebx_384 += dwLoc24;
				edi_383 = esi_93 - dwLoc24;
				goto l0805F660;
			}
			dwLoc4C_684 = eax_101 + ebx_384;
			goto l0805F5E5;
		}
		word32 edx_1181;
		word32 ecx_1180;
		ecx_102 = dwLoc48_693 + strnlen(eax_101 + dwLoc48_693, esi_93 + 0x0200, out ecx_1180, out edx_1181);
		edx = edx_396;
		dwLoc48_693 = ecx_102;
		if (edx_396 <= ecx_102)
			goto l0805F69C;
l0805F778:
		dwLoc4C_684.u0 = 0x00;
		goto l0805F5E5;
	}
	byte al_168 = Mem152[ebx_116 + eax_134:byte];
	Eq_2 eax_171 = esi_93 - eax_134;
	if (eax_171 < eax_134)
		eax_171 = eax_134;
	struct Eq_4889 * edi_175 = null;
	word32 eax_177 = eax_171 + 0x01;
l0805F7B0:
	word32 ebx_190 = esi_93 + edi_175;
	if (ebx_190 > dwLoc48_693)
	{
		word32 edx_1184;
		word32 v20_211 = dwLoc48_693 + strnlen(eax_101 + dwLoc48_693, esi_93 + 0x0200, out ecx_102, out edx_1184);
		dwLoc48_693 = v20_211;
		edx = v20_211;
		dwLoc40_681 = SEQ(nLoc3F_974, al_168);
		if (ebx_190 > v20_211)
			goto l0805F778;
	}
	word32 edx_222 = eax_134 + edi_175 + eax_101;
	word32 eax_223 = edx_222 + 0x01;
	if (al_168 != edx_222->b0000)
	{
		word32 eax_234 = strchr(edx_222 + 0x01, al_168, out ecx_102, out edx);
		if (eax_234 == 0x00)
			goto l0805F778;
		eax_223 = (word32) eax_234 + 1;
		edi_175 = eax_234 - (eax_101 + eax_134);
	}
	edx = eax_134 + 0x01;
	word32 ebx_258 = ebx_116 + (eax_134 + 0x01);
	if (esi_93 >u eax_134 + 0x01)
	{
		ecx_102 = eax_223 + 0x01;
		byte al_267 = *eax_223;
		if (al_267 == ebx_258->b0000)
		{
			do
			{
				++edx;
				if (esi_93 <= edx)
					goto l0805F85C;
				++ecx_102;
				al_267 = (byte) *((word32) ecx_102 - 1);
			} while (Mem252[ebx_116 + edx:byte] == al_267);
		}
		if (al_267 == 0x00)
			goto l0805F778;
		if (ecx_102 <=u eax_101 + dwLoc48_693)
		{
l0805F8CA:
			if (esi_93 > edx)
			{
				edi_175 = edx + 0x01 + (edi_175 - eax_134);
				goto l0805F7B0;
			}
			goto l0805F867;
		}
	}
	else
	{
		ecx_102 = eax_223;
l0805F85C:
		if (ecx_102 <=u eax_101 + dwLoc48_693)
		{
l0805F867:
			struct Eq_4889 * eax_333 = eax_134 - (struct Eq_152187 *) 0x01;
			word32 ebx_342 = ebx_116 + (eax_134 - 0x01);
			ecx_102 = eax_134 - 0x01 + edi_175 + eax_101;
			if (eax_134 == 0x00)
			{
l0805F8A3:
				dwLoc4C_684 = eax_101 + edi_175;
				goto l0805F5E5;
			}
			edx = (word32) *ecx_102;
			if (ebx_342->b0000 == (byte) edx)
			{
				ecx_102 -= eax_134;
				do
				{
					eax_333 -= (struct Eq_152193 *) 0x01;
					if (eax_333 == (struct Eq_4889 *) ~0x00)
						goto l0805F8A3;
					edx = CONVERT(Mem331[ecx_102 + 0x01 + eax_333:byte], byte, word32);
				} while (Mem331[ebx_116 + eax_333:byte] == SLICE(edx, byte, 0));
			}
			if ((byte) edx == 0x00)
				goto l0805F778;
			edi_175 += eax_177;
			goto l0805F7B0;
		}
	}
	dwLoc48_693 = ecx_102 - eax_101;
	goto l0805F8CA;
}

// 0805F930: Register word32 memcmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      two_way_long_needle
//      strstr
//      setlocale
//      two_way_long_needle
//      __memmem
//      open_verify.constprop.7
//      fillin_rpath
//      _dl_start_profile
//      _dl_load_cache_lookup
word32 memcmp(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_103 = dwArg08;
	Eq_2 ecx_104 = dwArg0C;
	if (dwArg0C == 0x01)
	{
		ecx_104 = (word32) *dwArg04;
		cu8 cl_651 = (byte) ecx_104;
		if (cl_651 != *dwArg08)
		{
			up32 eax_655 = 0x00 - (word32) (cl_651 < *dwArg08);
			ecxOut = ecx_104;
			edxOut = dwArg08;
			return eax_655 - ~0x00 - (word32) (eax_655 < 0x00);
		}
	}
	else if (dwArg0C >= 0x01)
	{
		Eq_2 eax_102;
		struct Eq_40344 * esi_100;
		cu8 cl_333;
		cu8 al_289;
		Eq_2 esi_16 = dwArg04;
		if (dwArg0C >= 0x20)
		{
			do
			{
				ecx_104 -= 0x20;
				Eq_2 eax_23 = *esi_16;
				if (eax_23 != *edx_103)
				{
l0805FBE6:
					ecx_104 = *edx_103;
					eax_102 = eax_23;
					goto l0805FBE8;
				}
				Eq_2 eax_27 = *((word32) esi_16 + 4);
				if (eax_27 != *((word32) edx_103 + 4))
				{
l0805FBE3:
					edx_103 = (word32) edx_103 + 4;
					eax_23 = eax_27;
					goto l0805FBE6;
				}
				Eq_2 eax_30 = *((word32) esi_16 + 8);
				if (eax_30 != *((word32) edx_103 + 8))
				{
l0805FBE0:
					edx_103 = (word32) edx_103 + 4;
					eax_27 = eax_30;
					goto l0805FBE3;
				}
				Eq_2 eax_33 = *((word32) esi_16 + 0x0C);
				if (eax_33 != *((word32) edx_103 + 0x0C))
				{
l0805FBDD:
					edx_103 = (word32) edx_103 + 4;
					eax_30 = eax_33;
					goto l0805FBE0;
				}
				Eq_2 eax_36 = *((word32) esi_16 + 16);
				if (eax_36 != *((word32) edx_103 + 16))
				{
l0805FBDA:
					edx_103 = (word32) edx_103 + 4;
					eax_33 = eax_36;
					goto l0805FBDD;
				}
				Eq_2 eax_39 = *((word32) esi_16 + 20);
				if (eax_39 != *((word32) edx_103 + 20))
				{
l0805FBD7:
					edx_103 = (word32) edx_103 + 4;
					eax_36 = eax_39;
					goto l0805FBDA;
				}
				Eq_2 eax_42 = *((word32) esi_16 + 24);
				if (eax_42 != *((word32) edx_103 + 24))
				{
l0805FBD4:
					edx_103 = (word32) edx_103 + 4;
					eax_39 = eax_42;
					goto l0805FBD7;
				}
				eax_42 = *((word32) esi_16 + 28);
				if (eax_42 != *((word32) edx_103 + 28))
				{
					edx_103 = (word32) edx_103 + 4;
					goto l0805FBD4;
				}
				esi_16 = (word32) esi_16 + 32;
				edx_103 = (word32) edx_103 + 32;
			} while (ecx_104 >= 0x20);
			edx_103 += ecx_104;
			esi_100 = esi_16 + ecx_104;
			switch (ecx_104)
			{
			case 0x00:
				goto l0805F9E2;
			case 0x01:
				goto l0805FA49;
			case 0x02:
				goto l0805FABD;
			case 0x03:
				goto l0805FB3C;
			case 0x04:
				goto l0805F9D4;
			case 0x05:
				goto l0805FA3B;
			case 0x06:
				goto l0805FAAF;
			case 0x07:
				goto l0805FB2E;
			case 0x08:
				goto l0805F9C6;
			case 0x09:
				goto l0805FA2D;
			case 0x0A:
				goto l0805FAA1;
			case 11:
				goto l0805FB20;
			case 0x0C:
				goto l0805F9B8;
			case 0x0D:
				goto l0805FA1F;
			case 0x0E:
				goto l0805FA93;
			case 0x0F:
				goto l0805FB12;
			case 0x10:
				goto l0805F9AA;
			case 0x11:
				goto l0805FA11;
			case 0x12:
				goto l0805FA85;
			case 0x13:
				goto l0805FB04;
			case 0x14:
				goto l0805F99C;
			case 0x15:
				goto l0805FA03;
			case 22:
				goto l0805FA77;
			case 0x17:
				goto l0805FAF6;
			case 0x18:
				goto l0805F98E;
			case 0x19:
				goto l0805F9F5;
			case 0x1A:
				goto l0805FA69;
			case 0x1B:
				goto l0805FAE8;
			case 0x1C:
l0805F980:
				eax_102 = esi_100->tFFFFFFE4;
				ecx_104 = *((word32) edx_103 - 28);
				if (eax_102 == ecx_104)
				{
l0805F98E:
					eax_102 = esi_100->tFFFFFFE8;
					ecx_104 = *((word32) edx_103 - 24);
					if (eax_102 == ecx_104)
					{
l0805F99C:
						eax_102 = esi_100->tFFFFFFEC;
						ecx_104 = *((word32) edx_103 - 20);
						if (eax_102 == ecx_104)
						{
l0805F9AA:
							eax_102 = esi_100->tFFFFFFF0;
							ecx_104 = *((word32) edx_103 - 16);
							if (eax_102 == ecx_104)
							{
l0805F9B8:
								eax_102 = esi_100->tFFFFFFF4;
								ecx_104 = *((word32) edx_103 - 0x0C);
								if (eax_102 == ecx_104)
								{
l0805F9C6:
									eax_102 = esi_100->tFFFFFFF8;
									ecx_104 = *((word32) edx_103 - 8);
									if (eax_102 == ecx_104)
									{
l0805F9D4:
										eax_102 = esi_100->tFFFFFFFC;
										ecx_104 = *((word32) edx_103 - 4);
										if (eax_102 == ecx_104)
											goto l0805F9E2;
									}
								}
							}
						}
					}
				}
				break;
			case 0x1D:
l0805F9E7:
				eax_102 = esi_100->tFFFFFFE3;
				ecx_104 = *((word32) edx_103 - 29);
				if (eax_102 == ecx_104)
				{
l0805F9F5:
					eax_102 = esi_100->tFFFFFFE7;
					ecx_104 = *((word32) edx_103 - 25);
					if (eax_102 == ecx_104)
					{
l0805FA03:
						eax_102 = esi_100->tFFFFFFEB;
						ecx_104 = *((word32) edx_103 - 21);
						if (eax_102 == ecx_104)
						{
l0805FA11:
							eax_102 = esi_100->tFFFFFFEF;
							ecx_104 = *((word32) edx_103 - 0x0011);
							if (eax_102 == ecx_104)
							{
l0805FA1F:
								eax_102 = esi_100->tFFFFFFF3;
								ecx_104 = *((word32) edx_103 - 0x0D);
								if (eax_102 == ecx_104)
								{
l0805FA2D:
									eax_102 = esi_100->tFFFFFFF7;
									ecx_104 = *((word32) edx_103 - 9);
									if (eax_102 == ecx_104)
									{
l0805FA3B:
										eax_102 = esi_100->tFFFFFFFB;
										ecx_104 = *((word32) edx_103 - 5);
										if (eax_102 == ecx_104)
										{
l0805FA49:
											if (esi_100->bFFFFFFFF != *((word32) edx_103 - 1))
												goto l0805FBFC;
											ecxOut = ecx_104;
											edxOut = edx_103;
											return 0x00;
										}
									}
								}
							}
						}
					}
				}
				break;
			case 0x1E:
l0805FA5B:
				eax_102 = esi_100->tFFFFFFE2;
				ecx_104 = *((word32) edx_103 - 30);
				if (eax_102 == ecx_104)
				{
l0805FA69:
					eax_102 = esi_100->tFFFFFFE6;
					ecx_104 = *((word32) edx_103 - 26);
					if (eax_102 == ecx_104)
					{
l0805FA77:
						eax_102 = esi_100->tFFFFFFEA;
						ecx_104 = *((word32) edx_103 - 22);
						if (eax_102 == ecx_104)
						{
l0805FA85:
							eax_102 = esi_100->tFFFFFFEE;
							ecx_104 = *((word32) edx_103 - 18);
							if (eax_102 == ecx_104)
							{
l0805FA93:
								eax_102 = esi_100->tFFFFFFF2;
								ecx_104 = *((word32) edx_103 - 0x0E);
								if (eax_102 == ecx_104)
								{
l0805FAA1:
									eax_102 = esi_100->tFFFFFFF6;
									ecx_104 = *((word32) edx_103 - 0x0A);
									if (eax_102 == ecx_104)
									{
l0805FAAF:
										eax_102 = esi_100->tFFFFFFFA;
										ecx_104 = *((word32) edx_103 - 6);
										if (eax_102 == ecx_104)
										{
l0805FABD:
											Eq_2 eax_557 = (word32) esi_100->wFFFFFFFE;
											ecx_104 = (word32) *((word32) edx_103 - 2);
											if ((byte) eax_557 != (byte) ecx_104 || eax_557 != ecx_104)
												goto l0805FBFC;
											ecxOut = ecx_104;
											edxOut = edx_103;
											return 0x00;
										}
									}
								}
							}
						}
					}
				}
				break;
			case 0x1F:
l0805FADA:
				eax_102 = esi_100->tFFFFFFE1;
				ecx_104 = *((word32) edx_103 - 31);
				if (eax_102 == ecx_104)
				{
l0805FAE8:
					eax_102 = esi_100->tFFFFFFE5;
					ecx_104 = *((word32) edx_103 - 27);
					if (eax_102 == ecx_104)
					{
l0805FAF6:
						eax_102 = esi_100->tFFFFFFE9;
						ecx_104 = *((word32) edx_103 - 23);
						if (eax_102 == ecx_104)
						{
l0805FB04:
							eax_102 = esi_100->tFFFFFFED;
							ecx_104 = *((word32) edx_103 - 19);
							if (eax_102 == ecx_104)
							{
l0805FB12:
								eax_102 = esi_100->tFFFFFFF1;
								ecx_104 = *((word32) edx_103 - 0x0F);
								if (eax_102 == ecx_104)
								{
l0805FB20:
									eax_102 = esi_100->tFFFFFFF5;
									ecx_104 = *((word32) edx_103 - 11);
									if (eax_102 == ecx_104)
									{
l0805FB2E:
										eax_102 = esi_100->tFFFFFFF9;
										ecx_104 = *((word32) edx_103 - 7);
										if (eax_102 == ecx_104)
										{
l0805FB3C:
											Eq_2 eax_526 = (word32) esi_100->wFFFFFFFD;
											ecx_104 = (word32) *((word32) edx_103 - 3);
											if ((byte) eax_526 != (byte) ecx_104 || (eax_526 != ecx_104 || esi_100->bFFFFFFFF != *((word32) edx_103 - 1)))
												goto l0805FBFC;
											ecxOut = ecx_104;
											edxOut = edx_103;
											return 0x00;
										}
									}
								}
							}
						}
					}
				}
				break;
			}
l0805FBE8:
			byte ch_409 = SLICE(ecx_104, byte, 8);
			byte ah_365 = SLICE(eax_102, byte, 8);
			cl_333 = (byte) ecx_104;
			al_289 = (byte) eax_102;
			if (al_289 == cl_333 && ah_365 == ch_409)
				ecx_104 >>= 0x10;
l0805FBFC:
			ecxOut = ecx_104;
			edxOut = edx_103;
			up32 eax_599 = 0x00 - (word32) (al_289 < cl_333);
			return eax_599 - ~0x00 - (word32) (eax_599 < 0x00);
		}
		else
		{
			edx_103 = dwArg08 + dwArg0C;
			esi_100 = dwArg04 + dwArg0C;
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
				goto l0805FA49;
			case 0x02:
				goto l0805FABD;
			case 0x03:
				goto l0805FB3C;
			case 0x04:
				goto l0805F9D4;
			case 0x05:
				goto l0805FA3B;
			case 0x06:
				goto l0805FAAF;
			case 0x07:
				goto l0805FB2E;
			case 0x08:
				goto l0805F9C6;
			case 0x09:
				goto l0805FA2D;
			case 0x0A:
				goto l0805FAA1;
			case 11:
				goto l0805FB20;
			case 0x0C:
				goto l0805F9B8;
			case 0x0D:
				goto l0805FA1F;
			case 0x0E:
				goto l0805FA93;
			case 0x0F:
				goto l0805FB12;
			case 0x10:
				goto l0805F9AA;
			case 0x11:
				goto l0805FA11;
			case 0x12:
				goto l0805FA85;
			case 0x13:
				goto l0805FB04;
			case 0x14:
				goto l0805F99C;
			case 0x15:
				goto l0805FA03;
			case 22:
				goto l0805FA77;
			case 0x17:
				goto l0805FAF6;
			case 0x18:
				goto l0805F98E;
			case 0x19:
				goto l0805F9F5;
			case 0x1A:
				goto l0805FA69;
			case 0x1B:
				goto l0805FAE8;
			case 0x1C:
				goto l0805F980;
			case 0x1D:
				goto l0805F9E7;
			case 0x1E:
				goto l0805FA5B;
			case 0x1F:
				goto l0805FADA;
			}
l0805F9E2:
			ecxOut = ecx_104;
			edxOut = edx_103;
			return 0x00;
		}
	}
	ecxOut = ecx_104;
	edxOut = dwArg08;
	return 0x00;
}

// 0805FC10: void __memmove_chk(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __memmove_chk(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 < dwArg0C)
		__chk_fail();
	else
	{
		word32 edx_23;
		memmove(dwArg04, dwArg08, dwArg0C, out edx_23);
	}
}

// 0805FC30: Register uint32 memmove(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_952 edxOut)
// Called from:
//      _IO_wfile_underflow
//      save_for_backup
//      __memmove_chk
//      getcwd
//      next_line
//      group_number
//      _IO_helper_overflow
//      group_number
//      wmemmove
//      __getdents
//      _dl_map_object_from_fd.constprop.8
//      _dl_sort_maps
uint32 memmove(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_952 & edxOut)
{
	Eq_2 edi_67 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	if (dwArg0C > dwArg04 - dwArg08)
	{
		byte * edi_17 = (word32) dwArg0C + (dwArg04 - 0x01);
		byte * esi_18 = (word32) dwArg0C + (dwArg08 - 0x01);
		if (dwArg0C >> 0x01 < 0x00)
		{
			*edi_17 = *esi_18;
			--esi_18;
			--edi_17;
		}
		word16 * edi_27 = edi_17 - 0x01;
		word16 * esi_29 = esi_18 - 0x01;
		uint32 ecx_31 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 < 0x00)
		{
			*edi_27 = *esi_29;
			++esi_29;
			++edi_27;
		}
		word32 * edi_40 = edi_27 - 0x02;
		word32 * esi_42 = esi_29 - 0x02;
		for (; ecx_31 != 0x00; --ecx_31)
		{
			*edi_40 = *esi_42;
			++esi_42;
			++edi_40;
		}
		edxOut.u0 = <invalid>;
		return ecx_31;
	}
	else
	{
		if (dwArg0C >> 0x01 < 0x00)
		{
			*dwArg04 = *dwArg08;
			esi_11 = (word32) dwArg08 + 1;
			edi_67 = (word32) dwArg04 + 1;
		}
		uint32 ecx_69 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 < 0x00)
		{
			*edi_67 = *esi_11;
			esi_11 = (word32) esi_11 + 2;
			edi_67 = (word32) edi_67 + 2;
		}
		for (; ecx_69 != 0x00; --ecx_69)
		{
			*edi_67 = *esi_11;
			esi_11 = (word32) esi_11 + 4;
			edi_67 = (word32) edi_67 + 4;
		}
		edxOut.u0 = <invalid>;
		return ecx_69;
	}
}

// 0805FC90: Register Eq_2 memset(Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _IO_str_overflow
//      enlarge_userbuf
//      _int_free
//      _int_malloc
//      __libc_calloc
//      __gconv_open
//      printf_positional
//      printf_positional
//      _dl_map_object_from_fd.constprop.8
//      _dl_nothread_init_static_tls
//      _dl_start_profile
//      _dl_allocate_tls
//      _dl_close_worker
//      _dl_sort_maps
Eq_2 memset(Eq_2 dwArg04, Eq_2 bArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	int32 eax_10 = (word32) bArg08;
	Eq_2 edx_104 = dwArg04;
	Eq_2 ecx_103 = dwArg0C;
	byte al_17 = (byte) eax_10;
	if (dwArg0C != 0x00)
	{
		Eq_2 edi_11 = dwArg04;
		edx_104 = dwArg04 & 0x03;
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (!P)
			{
				*dwArg04 = al_17;
				edi_11 = (word32) dwArg04 + 1;
				ecx_103 = dwArg0C - 0x01;
				if (dwArg0C == 0x01)
					goto l0805FCD1;
			}
			*edi_11 = al_17;
			edi_11 = (word32) edi_11 + 1;
			--ecx_103;
			if (ecx_103 == 0x00)
				goto l0805FCD1;
			if ((dwArg04 & 0x03 ^ 0x01) == 0x00)
			{
				*edi_11 = al_17;
				edi_11 = (word32) edi_11 + 1;
				--ecx_103;
			}
		}
		uint32 ecx_42 = ecx_103 >> 0x02;
		edx_104 = ecx_103 & 0x03;
		while (true)
		{
			int8 al_76 = (byte) eax_10 *s 0x01;
			if (ecx_42 == 0x00)
				break;
			*edi_11 = eax_10 *s 0x01010101;
			edi_11 = (word32) edi_11 + 4;
			--ecx_42;
		}
		for (ecx_103 = edx_104; ecx_103 != 0x00; --ecx_103)
		{
			edi_11->u0 = al_76;
			edi_11 = (word32) edi_11 + 1;
		}
	}
l0805FCD1:
	ecxOut = ecx_103;
	edxOut = edx_104;
	return dwArg04;
}

// 0805FCE0: void __mempcpy_chk(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __mempcpy_chk(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 < dwArg0C)
		__chk_fail();
	else
	{
		word32 edx_23;
		__mempcpy(dwArg04, dwArg08, dwArg0C, out edx_23);
	}
}

// 0805FD00: Register Eq_2 __mempcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      read_alias_file
//      msort_with_tmp.part.0
//      _IO_wfile_underflow
//      __libc_message
//      _IO_file_xsgetn_mmap
//      _IO_file_xsgetn
//      _IO_file_xsputn
//      _IO_file_fopen
//      save_for_backup
//      _IO_default_xsputn
//      _IO_default_xsgetn
//      __mempcpy_chk
//      __wmempcpy
//      __sysconf_check_spec
//      __gconv_open
//      find_derivation
//      add_module.isra.0
//      __gconv_get_path
//      __gconv_read_conf
//      __gconv_transform_internal_ucs4le
//      find_module
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      __printf_fp_l
//      _i18n_number_rewrite
//      strerror_r
//      open_path
//      add_path.isra.3.constprop.9
//      fillin_rpath
//      _dl_new_object
//      _dl_nothread_init_static_tls
//      _dl_important_hwcaps
//      _dl_allocate_tls
//      _dl_get_origin
//      _dl_exception_create
//      _dl_exception_create_format
Eq_2 __mempcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	Eq_2 edi_19 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	if (dwArg0C >> 0x01 < 0x00)
	{
		*dwArg04 = *dwArg08;
		esi_11 = (word32) dwArg08 + 1;
		edi_19 = (word32) dwArg04 + 1;
	}
	uint32 ecx_21 = dwArg0C >> 0x02;
	if (dwArg0C >> 0x02 < 0x00)
	{
		*edi_19 = *esi_11;
		esi_11 = (word32) esi_11 + 2;
		edi_19 = (word32) edi_19 + 2;
	}
	for (; ecx_21 != 0x00; --ecx_21)
	{
		*edi_19 = *esi_11;
		esi_11 = (word32) esi_11 + 4;
		edi_19 = (word32) edi_19 + 4;
	}
	edxOut = esi;
	return edi_19;
}

// 0805FD30: Register (ptr32 Eq_40967) __stpcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_4266 ecxOut)
// Called from:
//      __dcigettext
//      _nl_make_l10nflist
//      __gconv_get_path
//      new_composite_name
//      _dl_dst_substitute
//      _dl_reloc_bad_type
//      _dl_start_profile
struct Eq_40967 * __stpcpy(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_4266 & ecxOut)
{
	Eq_4266 ecx_7 = dwArg08 - dwArg04;
	struct Eq_40967 * eax_10 = dwArg04 - 0x04;
	do
	{
		++eax_10;
		byte dl_14 = Mem13[eax_10 + ecx_7:byte];
		eax_10->t0000.u2 = dl_14;
		if (dl_14 == 0x00)
			goto l0805FD74;
		byte dl_19 = Mem15[eax_10 + 0x01 + ecx_7:byte];
		eax_10->b0001 = dl_19;
		if (dl_19 == 0x00)
			goto l0805FD73;
		byte dl_24 = Mem20[eax_10 + 0x02 + ecx_7:byte];
		eax_10->a0002[0] = dl_24;
		if (dl_24 == 0x00)
			goto l0805FD72;
		byte dl_29 = Mem25[eax_10 + 0x03 + ecx_7:byte];
		eax_10->a0003[0] = dl_29;
	} while (dl_29 != 0x00);
	eax_10 = (struct Eq_40967 *) &eax_10->b0001;
l0805FD72:
	eax_10 = (struct Eq_40967 *) &eax_10->b0001;
l0805FD73:
	eax_10 = (struct Eq_40967 *) &eax_10->b0001;
l0805FD74:
	ecxOut = ecx_7;
	return eax_10;
}

// 0805FD80: Register word32 __strcasecmp_l(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut)
// Called from:
//      alias_compare
//      _nl_expand_alias
//      __gconv_open
//      _nl_find_locale
word32 __strcasecmp_l(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut)
{
	Eq_2 ecx_13 = dwArg04;
	Eq_2 edx_14 = dwArg08;
	if (dwArg04 == dwArg08)
	{
		ecxOut = dwArg04;
		return 0x00;
	}
	else
	{
		Eq_2 ebx_28 = *((word32) dwArg0C + 56);
		do
		{
			edx_14 = (word32) edx_14 + 1;
			word32 edi_31 = (word32) *ecx_13;
			word32 eax_40 = *((word32) ebx_28 + (word32) ((byte) edi_31) * 0x04) - *((word32) ebx_28 + (word32) (*((word32) edx_14 - 1)) * 0x04);
			if (eax_40 != 0x00)
				break;
			ecx_13 = (word32) ecx_13 + 1;
		} while ((byte) edi_31 != 0x00);
		ecxOut = ecx_13;
		return eax_40;
	}
}

// 0805FDE0: void __memcpy_chk(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __memcpy_chk(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 < dwArg0C)
		__chk_fail();
	else
	{
		word32 ecx_23;
		word32 edx_24;
		memcpy(dwArg04, dwArg08, dwArg0C, out ecx_23, out edx_24);
	}
}

// 0805FE00: Register Eq_2 memcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2012 ecxOut, Register out (ptr32 Eq_2013) edxOut)
// Called from:
//      __libc_setup_tls
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      read_alias_file
//      _nl_make_l10nflist
//      __gettextparse
//      msort_with_tmp.part.0
//      qsort_r
//      _IO_wfile_underflow
//      vasprintf
//      _IO_file_xsgetn
//      save_for_backup
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_pbackfail
//      _int_realloc
//      realloc_check
//      __realloc
//      strcpy
//      strdup
//      __memcpy_chk
//      __sysconf_check_spec
//      getcwd
//      __tdelete
//      _dl_non_dynamic_init
//      __gconv_open
//      find_derivation
//      add_module.isra.0
//      add_alias2.isra.1.part.2
//      find_module
//      __gconv_find_shlib
//      new_composite_name
//      _nl_find_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __printf_fp_l
//      _IO_getdelim
//      _IO_getline_info
//      __libc_scratch_buffer_grow_preserve
//      __strndup
//      strerror_r
//      __wmemcpy
//      add_name_to_object.isra.4
//      open_verify.constprop.7
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      fillin_rpath
//      _dl_init_paths
//      _dl_lookup_symbol_x
//      _dl_new_object
//      _dl_relocate_object
//      _dl_allocate_tls
//      _dl_exception_create
//      _dl_exception_create_format
//      _dl_load_cache_lookup
//      add_to_global
//      dl_open_worker
//      _dl_map_object_deps
Eq_2 memcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2012 & ecxOut, struct Eq_2013 & edxOut)
{
	Eq_2012 ecx_118;
	Eq_2 edi_114 = dwArg04;
	Eq_2 esi_10 = dwArg08;
	Eq_2 ecx_16 = dwArg0C;
	if (((dwArg04 ^ dwArg08) & 0x03) == 0x00 && dwArg0C > 0x03)
	{
		if ((dwArg08 & 0x03) != 0x00)
		{
			*dwArg04 = *dwArg08;
			esi_10 = dwArg08 + 1;
			edi_114 = (word32) dwArg04 + 1;
			ecx_16 = dwArg0C - 0x01;
			if ((dwArg08 + 1 & 0x03) != 0x00)
			{
				Mem64[dwArg04 + 1:byte] = Mem56[dwArg08 + 1:byte];
				esi_10 = dwArg08 + 2;
				edi_114 = (word32) dwArg04 + 2;
				ecx_16 = dwArg0C - 0x02;
				if ((dwArg08 + 2 & 0x03) != 0x00)
				{
					Mem72[dwArg04 + 2:byte] = Mem64[dwArg08 + 2:byte];
					esi_10 = dwArg08 + 3;
					edi_114 = (word32) dwArg04 + 3;
					ecx_16 = dwArg0C - 0x03;
				}
			}
		}
		uint32 ecx_126;
		Eq_2012 eax_84 = ecx_16 & 0x03;
		for (ecx_126 = ecx_16 >> 0x02; ecx_126 != 0x00; --ecx_126)
		{
			*edi_114 = *esi_10;
			esi_10 += 4;
			edi_114 = (word32) edi_114 + 4;
		}
		for (ecx_118 = eax_84; ecx_118 != 0x00; --ecx_118)
		{
			*edi_114 = *esi_10;
			++esi_10;
			edi_114 = (word32) edi_114 + 1;
		}
	}
	else
	{
		if (dwArg0C >> 0x01 < 0x00)
		{
			*dwArg04 = *dwArg08;
			esi_10 = dwArg08 + 1;
			edi_114 = (word32) dwArg04 + 1;
		}
		ecx_118 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 < 0x00)
		{
			*edi_114 = *esi_10;
			esi_10 += 2;
			edi_114 = (word32) edi_114 + 2;
		}
		for (; ecx_118 != 0x00; --ecx_118)
		{
			*edi_114 = *esi_10;
			esi_10 += 4;
			edi_114 = (word32) edi_114 + 4;
		}
	}
	ecxOut = ecx_118;
	edxOut = esi;
	return dwArg04;
}

// 0805FE70: Register Eq_2 rawmemchr(Stack Eq_2 dwArg04, Stack byte bArg08)
// Called from:
//      plural_lookup.isra.2
//      _IO_str_init_static_internal
//      _dl_non_dynamic_init
//      __gconv_read_conf
Eq_2 rawmemchr(Eq_2 dwArg04, byte bArg08)
{
	byte dl_9 = (byte) dwArg08;
	Eq_41209 edx_12 = SEQ(SLICE(dwArg08, word16, 16), dl_9, dl_9);
	Eq_2 eax_111 = dwArg04;
	word32 edx_155 = SEQ(edx_12, edx_12);
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		if (*dwArg04 == dl_9)
			return eax_111;
		eax_111 = (word32) dwArg04 + 1;
		if (((byte) dwArg04 + 0x01 & 0x03) != 0x00)
		{
			if (*((word32) dwArg04 + 1) == dl_9)
				return eax_111;
			eax_111 = (word32) dwArg04 + 2;
			if (((byte) dwArg04 + 0x02 & 0x03) != 0x00)
			{
				if (*((word32) dwArg04 + 2) == dl_9)
					return eax_111;
				eax_111 = (word32) dwArg04 + 3;
			}
		}
	}
	while (true)
	{
		uint32 ecx_201 = *eax_111 ^ edx_155;
		if (ecx_201 >= ~0x01010100 || (ecx_201 + ~0x01010100 ^ ecx_201 | ~0x01010100) != 0x01)
			break;
		uint32 ecx_203 = *((word32) eax_111 + 4) ^ edx_155;
		if (ecx_203 >= ~0x01010100 || (ecx_203 + ~0x01010100 ^ ecx_203 | ~0x01010100) != 0x01)
		{
l0805FF1E:
			eax_111 = (word32) eax_111 + 4;
			ecx_201 = ecx_203;
			break;
		}
		uint32 ecx_205 = *((word32) eax_111 + 8) ^ edx_155;
		if (ecx_205 >= ~0x01010100 || (ecx_205 + ~0x01010100 ^ ecx_205 | ~0x01010100) != 0x01)
		{
l0805FF1B:
			eax_111 = (word32) eax_111 + 4;
			ecx_203 = ecx_205;
			goto l0805FF1E;
		}
		ecx_205 = *((word32) eax_111 + 0x0C) ^ edx_155;
		if (ecx_205 >= ~0x01010100 || (ecx_205 + ~0x01010100 ^ ecx_205 | ~0x01010100) != 0x01)
		{
			eax_111 = (word32) eax_111 + 4;
			goto l0805FF1B;
		}
		eax_111 = (word32) eax_111 + 16;
	}
	byte ch_113 = SLICE(ecx_201, byte, 8);
	if ((byte) ecx_201 != 0x00)
	{
		eax_111 = (word32) eax_111 + 1;
		if (ch_113 != 0x00)
		{
			eax_111 = (word32) eax_111 + 1;
			if ((ecx_201 & 0x00FF0000) != 0x00)
				eax_111 = (word32) eax_111 + 2;
		}
	}
	return eax_111;
}

// 0805FF40: Register Eq_2 strchrnul(Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      __libc_message
//      _IO_file_fopen
//      _nl_load_locale_from_archive
//      vfprintf
//      __parse_one_specmb
Eq_2 strchrnul(Eq_2 dwArg04, Eq_2 bArg08)
{
	byte dl_9 = (byte) dwArg08;
	Eq_41334 edx_12 = SEQ(SLICE(dwArg08, word16, 16), dl_9, dl_9);
	Eq_2 eax_147 = dwArg04;
	word32 edx_236 = SEQ(edx_12, edx_12);
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		byte cl_21 = *dwArg04;
		if (dl_9 == cl_21 || cl_21 == 0x00)
			return eax_147;
		eax_147 = (word32) dwArg04 + 1;
		if (((byte) dwArg04 + 0x01 & 0x03) != 0x00)
		{
			byte cl_33 = *((word32) dwArg04 + 1);
			if (dl_9 == cl_33 || cl_33 == 0x00)
				return eax_147;
			eax_147 = (word32) dwArg04 + 2;
			if (((byte) dwArg04 + 0x02 & 0x03) != 0x00)
			{
				byte cl_44 = *((word32) dwArg04 + 2);
				if (dl_9 == cl_44 || cl_44 == 0x00)
					return eax_147;
				eax_147 = (word32) dwArg04 + 3;
			}
		}
	}
	while (true)
	{
		uint32 ecx_308 = *eax_147 ^ edx_236;
		if (ecx_308 >= ~0x01010100 || (ecx_308 + ~0x01010100 ^ ecx_308 | ~0x01010100) != 0x01)
			break;
		ecx_308 = ecx_308 ^ edx_236;
		if (ecx_308 >= ~0x01010100 || (ecx_308 + ~0x01010100 ^ ecx_308 | ~0x01010100) != 0x01)
			break;
		uint32 ecx_310 = *((word32) eax_147 + 4) ^ edx_236;
		if (ecx_310 >= ~0x01010100 || (ecx_310 + ~0x01010100 ^ ecx_310 | ~0x01010100) != 0x01)
		{
l0806007C:
			eax_147 = (word32) eax_147 + 4;
			ecx_308 = ecx_310;
			break;
		}
		ecx_310 = ecx_310 ^ edx_236;
		if (ecx_310 >= ~0x01010100 || (ecx_310 + ~0x01010100 ^ ecx_310 | ~0x01010100) != 0x01)
			goto l0806007C;
		uint32 ecx_102 = *((word32) eax_147 + 8) ^ edx_236;
		if (ecx_102 >= ~0x01010100 || (ecx_102 + ~0x01010100 ^ ecx_102 | ~0x01010100) != 0x01)
		{
l08060079:
			eax_147 = (word32) eax_147 + 4;
			ecx_310 = ecx_102;
			goto l0806007C;
		}
		ecx_102 = ecx_102 ^ edx_236;
		if (ecx_102 >= ~0x01010100 || (ecx_102 + ~0x01010100 ^ ecx_102 | ~0x01010100) != 0x01)
			goto l08060079;
		uint32 ecx_125 = *((word32) eax_147 + 0x0C) ^ edx_236;
		if (ecx_125 >= ~0x01010100 || (ecx_125 + ~0x01010100 ^ ecx_125 | ~0x01010100) != 0x01)
		{
l08060076:
			eax_147 = (word32) eax_147 + 4;
			ecx_102 = ecx_125;
			goto l08060079;
		}
		ecx_125 = ecx_125 ^ edx_236;
		if (ecx_125 >= ~0x01010100 || (ecx_125 + ~0x01010100 ^ ecx_125 | ~0x01010100) != 0x01)
			goto l08060076;
		eax_147 = (word32) eax_147 + 16;
	}
	byte ch_182 = SLICE(ecx_308, byte, 8);
	byte cl_158 = (byte) ecx_308;
	if (cl_158 != 0x00 && cl_158 != dl_9)
	{
		eax_147 = (word32) eax_147 + 1;
		if (ch_182 != 0x00 && ch_182 != dl_9)
		{
			eax_147 = (word32) eax_147 + 1;
			byte cl_214 = (byte) (ecx_308 >> 0x10);
			if (cl_214 != 0x00 && cl_214 != dl_9)
				eax_147 = (word32) eax_147 + 2;
		}
	}
	return eax_147;
}

// 080600A0: Register Eq_2 __wmempcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_16661 dwArg0C)
// Called from:
//      _IO_wfile_xsputn
//      save_for_wbackup.isra.0
//      _IO_wdefault_xsputn
//      _IO_wdefault_xsgetn
Eq_2 __wmempcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_16661 dwArg0C)
{
	word32 edx_44;
	return __mempcpy(dwArg04, dwArg08, dwArg0C << 0x02, out edx_44);
}

// 080600D0: Register word32 __mbsrtowcs(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg10, Register out ptr32 ecxOut)
// Called from:
//      locked_vfxprintf
//      __vfwprintf
word32 __mbsrtowcs(struct Eq_9 * gs, Eq_2 dwArg10, ptr32 & ecxOut)
{
	Eq_2 eax_14 = dwArg10;
	if (dwArg10 == 0x00)
		eax_14.u0 = 0x080CF894;
	ptr32 ecx_38;
	word32 eax_37 = __mbsrtowcs_l(gs, dwArg04, dwArg08, dwArg0C, eax_14, gs->ptrFFFFFFD4, out ecx_38);
	ecxOut = ecx_38;
	return eax_37;
}

// 08060110: void _nl_cleanup_ctype(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_41543) dwArg04)
void _nl_cleanup_ctype(Eq_2 edx, struct Eq_9 * gs, struct Eq_41543 * dwArg04)
{
	Eq_2 esi_14 = dwArg04->t0014;
	if (esi_14 != 0x00)
	{
		dwArg04->t0014.u0 = 0x00;
		dwArg04->dw0010 = 0x00;
		Eq_2 v10_22 = *((word32) esi_14 + 0x0C);
		word32 edx_94;
		__gconv_close_transform(edx, gs, *((word32) esi_14 + 8), v10_22, out edx_94);
		word32 edx_95;
		__gconv_close_transform(v10_22, gs, *esi_14, *((word32) esi_14 + 4), out edx_95);
		word32 ecx_96;
		word32 edx_97;
		free(gs, dwLoc20, esi_14, out ecx_96, out edx_97);
	}
}

// 08060170: Register Eq_2 __wcsmbs_getfct(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg0C)
// Called from:
//      __wcsmbs_load_conv
//      __wcsmbs_named_conv
Eq_2 __wcsmbs_getfct(struct Eq_9 * gs, Eq_2 dwArg0C)
{
	Eq_2 eax_110;
	Eq_2175 eax_9 = gs->t0014;
	word32 ebx_127;
	word32 ebp_128;
	word32 esi_129;
	if (__gconv_find_transform(gs, dwArg04, dwArg08, fp - 0x14, fp - 0x18, 0x00, out ebx_127, out ebp_128, out esi_129) == 0x00)
	{
		eax_110 = dwLoc14;
		if (dwLoc18 <= 0x01)
			*dwArg0C = dwLoc18;
		else
		{
			word32 edx_131;
			__gconv_close_transform(edx, gs, dwLoc14, dwLoc18, out edx_131);
			eax_110.u0 = 0x00;
		}
	}
	else
		eax_110.u0 = 0x00;
	if ((eax_9 ^ gs->t0014) == 0x00)
		return eax_110;
	word32 ecx_132;
	word32 edx_133;
	__stack_chk_fail(out ecx_132, out edx_133);
	word32 ebx_134;
	word32 esi_135;
	word32 edi_136;
	return __wcsmbs_load_conv(gs, dwLoc18, out ebx_134, out esi_135, out edi_136);
}

// 08060200: Register ui32 __wcsmbs_load_conv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_952 ebxOut, Register out Eq_2 esiOut, Register out Eq_952 ediOut)
// Called from:
//      __wcsmbs_getfct
//      __wcsmbs_clone_conv
//      __mbsrtowcs_l
//      btowc
//      wcrtomb
//      __wcsrtombs
ui32 __wcsmbs_load_conv(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_952 & ebxOut, union Eq_2 & esiOut, union Eq_952 & ediOut)
{
	Eq_2175 eax_23 = gs->t0014;
	Eq_2 esi_382;
	Mem42 = Mem24;
	esi_382 = esi;
	if (*((word32) dwArg04 + 20) != 0x00)
	{
l08060381:
		ui32 eax_429 = eax_23 ^ gs->t0014;
		if (eax_429 != 0x00)
		{
			word32 edx_655;
			word32 ecx_654;
			__stack_chk_fail(out ecx_654, out edx_655);
			ui32 eax_442 = __wcsmbs_clone_conv(gs, dwArg04);
			ebxOut.u0 = <invalid>;
			esiOut = esi_382;
			ediOut.u0 = <invalid>;
			return eax_442;
		}
		else
		{
			ebxOut.u0 = <invalid>;
			esiOut = esi;
			ediOut.u0 = <invalid>;
			return eax_429;
		}
	}
	word32 esi_650;
	word32 edi_651;
	word32 ebp_649;
	word32 edx_647;
	word32 ebx_648;
	word32 ecx_646;
	Eq_2 eax_59 = __libc_calloc(gs, 0x01, 0x10, out ecx_646, out edx_647, out ebx_648, out ebp_649, out esi_650, out edi_651);
	struct Eq_41696 * esp_116 = fp - 0x4C;
	if (eax_59 != 0x00)
	{
		word32 * dwLoc3C_469;
		word32 * dwLoc40_470;
		word32 edi_104;
		Eq_2 ecx_171 = *((word32) dwArg04 + 92);
		if (*((word32) dwArg04 + 28) == 0x00)
		{
			dwLoc3C_469 = null;
			edi_104 = 0x03;
			dwLoc40_470 = &g_dw80B41F9;
		}
		else
		{
			dwLoc3C_469 = (word32 *) 0x08;
			edi_104 = 11;
			dwLoc40_470 = &g_dw80A3AA0;
		}
		Eq_2 eax_82 = ecx_171;
		up32 esi_83 = 0x00;
		while (true)
		{
			byte dl_89 = *eax_82;
			if (dl_89 == 0x00)
				break;
			eax_82 = (word32) eax_82 + 1;
			esi_83 += (word32) (dl_89 == 0x2F);
		}
		ui32 eax_105 = edi_104 + 0x1B + (eax_82 - ecx_171);
		struct Eq_41696 * edi_111 = fp - 0x4C - (eax_105 & ~0x0FFF);
		if (fp - 0x4C != edi_111)
		{
			do
			{
				esp_116 -= 0x1000;
				esp_116->dw0FFC = esp_116->dw0FFC;
			} while (esp_116 != edi_111);
		}
		int32 edx_127 = eax_105 & ~0x0F & 0x0FFF;
		if (edx_127 != 0x00)
		{
			esp_116 -= edx_127;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_116 - 0x04)[edx_127 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_116 - 0x04)[edx_127 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		Eq_41783 eax_139 = (char *) &esp_116->dwFFFFFFF0 + 31;
		int32 eax_151 = (int32) *ecx_171;
		struct Eq_41791 * edx_141 = eax_139 & ~0x0F;
		if ((byte) eax_151 != 0x00)
		{
			Eq_3803 edi_162[] = g_ptr80CE084;
			do
			{
				++edx_141;
				edx_141->bFFFFFFFF = (byte) edi_162[eax_151];
				ecx_171 = (word32) ecx_171 + 1;
				eax_151 = (int32) *ecx_171;
			} while ((byte) eax_151 != 0x00);
		}
		else
			edx_141 = eax_139 & ~0x0F;
		if (esi_83 <= 0x01)
		{
			edx_141->b0000 = 0x2F;
			if (esi_83 == 0x00)
			{
				edx_141[1] = (struct Eq_41791) 0x2F;
				struct Eq_41791 * ecx_196 = edx_141 + 2;
				if (dwLoc3C_469 == null)
					edx_141 = ecx_196;
				else
				{
					if (dwLoc3C_469 < (word32 *) 0x04)
					{
						if (dwLoc3C_469 != null)
							ecx_196->b0000 = (byte) *dwLoc40_470;
					}
					else
					{
						ecx_196->b0000 = (byte) *dwLoc40_470;
						Mem209[ecx_196 - 0x04 + dwLoc3C_469:word32] = Mem206[dwLoc40_470 - 0x04 + dwLoc3C_469:word32];
						Eq_41972 esi_210 = edx_141 + 6;
						word32 * eax_213 = ecx_196 - (esi_210 & ~0x03);
						ptr32 edi_214 = dwLoc40_470 - eax_213;
						word32 eax_215 = eax_213 + dwLoc3C_469;
						if ((eax_215 & ~0x03) >= 0x04)
						{
							Eq_41996 eax_221 = eax_215 & ~0x03 & ~0x03;
							Eq_41996 eax_223 = 0x00;
							do
							{
								Mem231[(esi_210 & ~0x03) + eax_223:word32] = Mem228[edi_214 + eax_223:word32];
								eax_223 = (word32) eax_223 + 4;
							} while (eax_223 < eax_221);
						}
					}
					edx_141 = dwLoc3C_469 + ecx_196;
				}
			}
			else
				++edx_141;
		}
		edx_141->b0000 = 0x00;
		struct Eq_41830 * esp_261 = esp_116 - 0x04;
		esp_261->ptrFFFFFFFC = (word32) eax_59 + 4;
		esp_261->tFFFFFFF8 = eax_139 & ~0x0F;
		esp_261->tFFFFFFF4.u0 = 0x080A4DFD;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg12 = <invalid>;
		Eq_2 eax_299 = __wcsmbs_getfct(gs, stackArg12);
		*eax_59 = eax_299;
		if (eax_299 != 0x00)
		{
			esp_261->ptrFFFFFFFC = (word32) eax_59 + 0x0C;
			esp_261->tFFFFFFF8.u1 = 0x080A4DFD;
			esp_261->tFFFFFFF4 = eax_139 & ~0x0F;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg12 = <invalid>;
			Eq_2 eax_334 = __wcsmbs_getfct(gs, stackArg12);
			*((word32) eax_59 + 8) = eax_334;
			if (eax_334 != 0x00)
			{
l0806036F:
				*((word32) dwArg04 + 20) = eax_59;
				*((word32) dwArg04 + 16) = 0x08060110;
				esi_382 = dwArg04;
				goto l08060381;
			}
			Eq_2 eax_344 = *eax_59;
			if (eax_344 != 0x00)
			{
				esp_261->tFFFFFFF8 = *((word32) eax_59 + 4);
				esp_261->tFFFFFFF4 = eax_344;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				word32 edx_662;
				__gconv_close_transform(edx, gs, stackArg4, dwArg04, out edx_662);
			}
			esp_116->dwFFFFFFF0 = (word32) eax_59;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_658;
			word32 edx_659;
			free(gs, stackArg0, stackArg4, out ecx_658, out edx_659);
		}
		else
		{
			if (*((word32) eax_59 + 8) != 0x00)
				goto l0806036F;
			esp_261->tFFFFFFF4 = eax_59;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 edx_666;
			word32 ecx_665;
			free(gs, stackArg0, stackArg4, out ecx_665, out edx_666);
		}
	}
	((word32) dwArg04 + 20)->u0 = 135055060;
	esi_382 = dwArg04;
	goto l08060381;
}

// 080604E0: Register (ptr32 Eq_42011) __wcsmbs_clone_conv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __wcsmbs_load_conv
//      _IO_fwide
struct Eq_42011 * __wcsmbs_clone_conv(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esi_17 = gs->ptrFFFFFFD0->t0000;
	struct Eq_42018 * eax_18 = *((word32) esi_17 + 20);
	if (eax_18 == null)
	{
		if (esi_17 != 0x080CC740)
		{
			word32 ebx_96;
			word32 esi_97;
			word32 edi_98;
			__wcsmbs_load_conv(gs, esi_17, out ebx_96, out esi_97, out edi_98);
			eax_18 = (struct Eq_42018 *) *((word32) esi_17 + 20);
		}
		else
			eax_18 = (struct Eq_42018 *) 135055060;
	}
	struct Eq_42026 * edx_39 = eax_18->ptr0000;
	*dwArg04 = edx_39;
	*((word32) dwArg04 + 4) = eax_18->dw0004;
	*((word32) dwArg04 + 8) = eax_18->ptr0008;
	word32 ecx_46 = edx_39->dw0000;
	*((word32) dwArg04 + 0x0C) = eax_18->dw000C;
	if (ecx_46 != 0x00)
		++edx_39->dw0008;
	struct Eq_42011 * eax_57 = *((word32) dwArg04 + 8);
	if (eax_57->dw0000 != 0x00)
		++eax_57->dw0008;
	return eax_57;
}

// 08060570: Register word32 __wcsmbs_named_conv(Stack (ptr32 Eq_21702) dwArg04)
// Called from:
//      _IO_file_fopen
word32 __wcsmbs_named_conv(struct Eq_21702 * dwArg04)
{
	Eq_2 eax_27 = __wcsmbs_getfct(gs, &dwArg04->t0004);
	dwArg04->t0000 = eax_27;
	word32 ecx_32 = 0x01;
	if (eax_27 != 0x00)
	{
		Eq_2 eax_46 = __wcsmbs_getfct(gs, (char *) &dwArg04->t0008 + 4);
		dwArg04->t0008 = eax_46;
		ecx_32 = 0x00;
		if (eax_46 == 0x00)
		{
			word32 edx_113;
			__gconv_close_transform(edx, gs, dwArg04->t0000, dwArg04->t0004, out edx_113);
			ecx_32 = 0x01;
		}
	}
	return ecx_32;
}

// 080605F0: Register int32 __mbsrtowcs_l(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack word32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_11223) dwArg14, Register out Eq_2 ecxOut)
// Called from:
//      __mbsrtowcs
int32 __mbsrtowcs_l(struct Eq_9 * gs, word32 dwArg04, word32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, struct Eq_11223 * dwArg14, union Eq_2 & ecxOut)
{
	Eq_42132 ebx_154 = dwArg14->t0000;
	struct Eq_42136 * esp_168 = fp - 0x017C;
	Eq_2 ecx_171 = dwArg0C;
	Eq_2175 eax_26 = gs->t0014;
	struct Eq_42144 * eax_183 = *((word32) ebx_154 + 20);
	if (eax_183 != null)
	{
l0806066F:
		struct Eq_42156 * edi_42 = eax_183->ptr0000;
		Eq_2 esi_44 = edi_42->t0014;
		if (edi_42->dw0000 != 0x00)
			esi_44 = __ror(esi_44, 0x09) ^ gs->t0018;
		struct Eq_42169 * esp_271;
		int32 ebp_137;
		Eq_42171 eax_139;
		word24 ecx_24_8_347;
		Eq_2 ebp_225 = *esp_168[6];
		word32 eax_59 = esp_168[5];
		esp_168[0x0C] = (struct Eq_42136) ebp_225;
		if (eax_59 != 0x00)
		{
			word32 eax_201 = esp_168[5];
			esp_168[0x0F] = (struct Eq_42136) eax_201;
			esp_168[16] = (struct Eq_42136) (eax_201 + ecx_171 * 0x04);
			esp_168[2] = (struct Eq_42136) (esp_168 + 11);
			esp_168[3] = (struct Eq_42136) (esp_168 + 0x0C);
			esp_168[4] = (struct Eq_42136) (esp_168 + 0x0F);
			Eq_2 ebx_205 = ecx_171;
			if (ecx_171 == 0x00)
			{
				ebp_137 = 0x00;
				goto l0806079A;
			}
			do
			{
				Eq_2 edx_291;
				struct Eq_42319 * esp_219 = esp_168 - 0x08;
				esp_219->tFFFFFFFC = ebx_205;
				esp_219->tFFFFFFF8 = ebp_225;
				word32 edx_700;
				word32 ecx_699;
				Eq_2 eax_227 = strnlen(esp_219->tFFFFFFF8, esp_219->tFFFFFFFC, out ecx_699, out edx_700);
				esp_219->tFFFFFFF8 = esi_44;
				word32 edx_702;
				word32 ecx_701;
				_dl_mcount_wrapper_check(gs, esp_219->tFFFFFFF4, esp_219->tFFFFFFF8, out ecx_701, out edx_702);
				esp_219->tFFFFFFF4.u0 = 0x01;
				esp_219->dwFFFFFFF0 = 0x00;
				esp_219->dwFFFFFFEC = esp_219->dw0010;
				esp_219->dwFFFFFFE8 = 0x00;
				Eq_2 ebx_236 = (word32) eax_227 + ((word32) ebp_225 + 1);
				esp_219->tFFFFFFE4 = ebx_236;
				esp_219->dwFFFFFFE0 = esp_219->dw0014;
				esp_219->dwFFFFFFDC = esp_219->dw0018;
				esp_219->ptrFFFFFFD8 = edi_42;
				word32 edx_268;
				esi_44();
				ebp_225 = esp_219->t0038;
				esp_271 = (struct Eq_42169 *) ((char *) &esp_219->tFFFFFFFC + 0x0C);
				if (eax_139 != 0x04 && eax_139 != 0x07)
				{
					edx_291 = esp_219->t0044;
					goto l08060732;
				}
				ecx_171 = esp_219->t0044;
				if (ebp_225 != ebx_236 || *((word32) ebx_236 - 1) == 0x00)
					break;
				int32 ebx_286 = esp_219->dw0048 - ecx_171;
				ebx_205 = ebx_286 >> 0x02;
			} while (ebx_286 >> 0x02 != 0x00);
			edx_291 = ecx_171;
l08060732:
			int32 edx_299 = edx_291 - esp_219->ptr001C;
			*esp_219->ptr0020 = (union Eq_2 *) ebp_225;
			ebp_137 = edx_299 >> 0x02;
			if ((eax_139 & ~0x04) != 0x00)
			{
				if ((int8) (eax_139 <= 0x07) != 0x00)
				{
l0806078B:
					if (eax_139 <= 0x07 && !__bt(177, eax_139))
						goto l0806079A;
l080607F0:
					gs->tFFFFFFE0.u0 = 0x54;
					ebp_137 = ~0x00;
l0806079A:
					esp_271 = fp - 380;
					if ((eax_26 ^ gs->t0014) == 0x00)
					{
						ecxOut = ecx_171;
						return ebp_137;
					}
					word32 edx_707;
					word32 ecx_706;
					__stack_chk_fail(out ecx_706, out edx_707);
l0806092C:
					word32 edi_451 = esp_271->dw001C;
					struct Eq_42670 * esp_453 = esp_271 - 4;
					esp_453->dw0000 = edi_451 + 4294794152;
					esp_453->dwFFFFFFFC = 141;
					esp_453->dwFFFFFFF8 = edi_451 + ~0x0002A556;
					esp_453->dwFFFFFFF4 = edi_451 + 4294793911;
					word32 edx_710;
					word32 ecx_709;
					__assert_fail(out ecx_709, out edx_710);
					esp_271 = esp_453 - 0x0C;
					goto l0806094F;
				}
l080607CD:
				word32 edi_363 = esp_168[7];
				struct Eq_42559 * esp_365 = esp_168 - 4;
				esp_365->dw0000 = edi_363 + 4294794152;
				esp_365->dwFFFFFFFC = 0x99;
				esp_365->dwFFFFFFF8 = edi_363 + ~0x0002A556;
				esp_365->dwFFFFFFF4 = edi_363 + 4294793992;
				word32 edx_708;
				__assert_fail(out ecx_171, out edx_708);
				goto l080607F0;
			}
			word32 ecx_319 = (esp_219->ptr001C - 0x04)[edx_299 >> 0x02];
			ecx_24_8_347 = SLICE(ecx_319, word24, 8);
			if (ecx_319 == 0x00)
			{
				if (edx_299 >> 0x02 == 0x00)
					goto l0806092C;
				if (*esp_219->ptr0058 != 0x00)
				{
l0806094F:
					word32 ecx_474 = esp_271->dw001C;
					struct Eq_42599 * esp_476 = esp_271 - 4;
					esp_476->dw0000 = ecx_474 + 4294794152;
					esp_476->dwFFFFFFFC = 0x8E;
					esp_476->tFFFFFFF8 = ecx_474 + ~0x0002A556;
					esp_476->dwFFFFFFF4 = ecx_474 + 4294793922;
					word32 edx_712;
					word32 ecx_711;
					__assert_fail(out ecx_711, out edx_712);
					_exit(gs, esp_476->tFFFFFFF8);
				}
				*esp_219->ptr0020 = (union Eq_2 *) 0x00;
l08060774:
				--ebp_137;
				goto l08060777;
			}
l08060777:
			uint32 edx_338 = eax_139 - 0x04;
			ecx_171 = SEQ(ecx_24_8_347, (int8) (eax_139 == 0x00));
			if (((int8) (edx_338 <= 0x03) | (int8) (eax_139 == 0x00)) != 0x00)
				goto l0806078B;
			goto l080607CD;
		}
		struct Eq_42223 * esp_64 = esp_168 - 0x0C;
		esp_64->tFFFFFFFC = ebp_225;
		word32 ecx_697;
		word32 edx_698;
		esp_64->dw0020 = (word32) strlen(esp_64->tFFFFFFFC, out ecx_697, out edx_698) + ((word32) ebp_225 + 1);
		struct Eq_42244 * eax_82 = esp_64->ptr005C;
		word32 edx_83 = eax_82->dw0004;
		esp_64->dw0040 = eax_82->dw0000;
		esp_64->ptr005C = &esp_64->dw0040;
		esp_64->ptr004C = (char *) &esp_64->ptr005C + 268;
		esp_64->ptr0014 = &esp_64->dw0020 + 6;
		esp_64->ptr0018 = &esp_64->dw0020 + 7;
		esp_64->dw0044 = edx_83;
		esp_64->ptr001C = &esp_64->dw0044 + 1;
		ebp_137 = 0x00;
		do
		{
			Mem102[esp_168 + 0x3C:word32] = esp_64 + 0x68;
			struct Eq_42416 * esp_103 = esp_168 - 0x0C;
			esp_103->tFFFFFFFC = esi_44;
			word32 edx_704;
			word32 ecx_703;
			_dl_mcount_wrapper_check(gs, esp_103->tFFFFFFF8, esp_103->tFFFFFFFC, out ecx_703, out edx_704);
			esp_103->tFFFFFFF8.u0 = 0x01;
			esp_103->dwFFFFFFF4 = 0x00;
			esp_103->dwFFFFFFF0 = esp_103->dw0014;
			esp_103->dwFFFFFFEC = 0x00;
			esp_103->dwFFFFFFE8 = esp_103->dw0020;
			esp_103->dwFFFFFFE4 = esp_103->dw0018;
			esp_103->dwFFFFFFE0 = esp_103->dw001C;
			esp_103->ptrFFFFFFDC = edi_42;
			esi_44();
			struct Eq_42473 * ecx_143 = esp_103->ptr0048;
			word32 edx_146 = ecx_143 - (esp_64 + 0x68);
			ecx_24_8_347 = SLICE(ecx_143, word24, 8);
			ebp_137 += edx_146 >> 0x02;
		} while (eax_139 == 0x05);
		if ((eax_139 & ~0x04) != 0x00)
			goto l08060777;
		ebx_154 = ecx_143->tFFFFFFFC;
		if (ebx_154 == 0x00)
			goto l08060774;
		word32 ecx_158 = esp_103->dw0028;
		esp_103->dw0008 = ecx_158 + 4294794152;
		esp_103->dw0004 = 0x5E;
		esp_103->dw0000 = ecx_158 + ~0x0002A556;
		esp_103->tFFFFFFFC = ecx_158 + 4294793948;
		word32 edx_705;
		__assert_fail(out ecx_171, out edx_705);
		esp_168 = esp_103 - 4;
	}
	if (ebx_154 != (word32) esp_168[7] - 6336)
	{
		struct Eq_42200 * esp_184 = esp_168 - 0x0C;
		esp_184->tFFFFFFFC = ebx_154;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 esi_695;
		word32 edi_696;
		word32 ebx_694;
		__wcsmbs_load_conv(gs, stackArg4, out ebx_694, out esi_695, out edi_696);
		esp_168 = (struct Eq_42136 *) ((char *) &esp_184->tFFFFFFFC + 16);
		eax_183 = (struct Eq_42144 *) *((word32) ebx_154 + 20);
		ecx_171 = esp_184->t0194;
	}
	else
		eax_183 = (word32) esp_168[7] - 6444;
	goto l0806066F;
}

// 08060972: void _exit(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      abort
//      __run_exit_handlers
//      __mbsrtowcs_l
//      _dl_non_dynamic_init
//      do_lookup_x
//      _dl_relocate_object
//      _dl_start_profile
//      oom
//      length_mismatch
//      _dl_exception_create_format
//      fatal_error
//      dl_open_worker
//      _dl_close_worker
void _exit(struct Eq_9 * gs, Eq_2 dwArg04)
{
	gs->ptr0010();
	__syscall(0x80);
	__hlt();
}

// 08060990: void __sysconf_check_spec(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
void __sysconf_check_spec(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2 esi_128;
	Eq_2 dwLoc90_240;
	Eq_2175 eax_23 = gs->t0014;
	Eq_2 eax_30 = gs->tFFFFFFE0;
	Eq_2 eax_35 = __libc_secure_getenv(0x080A3BCB);
	if (eax_35 != 0x00)
	{
		esi_128 = eax_35;
		word32 ecx_299;
		word32 edx_300;
		dwLoc90_240 = strlen(eax_35, out ecx_299, out edx_300);
	}
	else
	{
		dwLoc90_240.u0 = 0x14;
		esi_128.u0 = 134888374;
	}
	word32 ecx_306;
	word32 edx_307;
	Eq_2 eax_69 = strlen(eax, out ecx_306, out edx_307);
	ui32 eax_80 = (word32) eax_69 + ((byte) dwLoc90_240.u0 + 26);
	Eq_2 esp_106 = fp - 0x9C;
	Eq_2 ecx_86 = fp - 0x9C - (eax_80 & ~0x0FFF);
	if (fp - 0x9C != ecx_86)
	{
		do
		{
			esp_106 -= 0x1000;
			*((word32) esp_106 + 0x0FFC) = *((word32) esp_106 + 0x0FFC);
		} while (esp_106 != ecx_86);
	}
	if ((eax_80 & ~0x0F & 0x0FFF) != 0x00)
	{
		esp_106 -= eax_80 & ~0x0F & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_106 - 0x04)[(eax_80 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_106 - 0x04)[(eax_80 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_42810 * esp_115 = esp_106 - 0x04;
	esp_115->tFFFFFFFC = dwLoc90_240;
	esp_115->tFFFFFFF8 = esi_128;
	esp_115->tFFFFFFF4 = esp_106;
	word32 edx_301;
	Eq_2 eax_137 = __mempcpy(esp_115->tFFFFFFF4, esp_115->tFFFFFFF8, esp_115->tFFFFFFFC, out edx_301);
	((word32) eax_137 + 8)->u5 = 24374;
	*eax_137 = 1397706799;
	*((word32) eax_137 + 4) = 1449089097;
	esp_115->tFFFFFFFC = (word32) eax_69 + 1;
	esp_115->tFFFFFFF8 = eax;
	esp_115->tFFFFFFF4 = (word32) eax_137 + 0x0A;
	word32 ecx_302;
	word32 edx_303;
	memcpy(esp_115->tFFFFFFF4, esp_115->tFFFFFFF8, esp_115->tFFFFFFFC, out ecx_302, out edx_303);
	esp_115->tFFFFFFFC = fp - 0x80;
	esp_115->tFFFFFFF8 = esp_106;
	esp_115->tFFFFFFF4.u0 = 0x03;
	__xstat64(gs, esp_115->tFFFFFFF8, esp_115->tFFFFFFFC);
	gs->tFFFFFFE0 = eax_30;
	if ((eax_23 ^ gs->t0014) == 0x00)
		return;
	word32 edx_305;
	word32 ecx_304;
	__stack_chk_fail(out ecx_304, out edx_305);
	Eq_2 esp_205 = <invalid>;
	word32 esi_310;
	word32 ebp_309;
	word32 ebx_308;
	__sysconf(gs, *((word32) esp_205 + 4), out ebx_308, out ebp_309, out esi_310);
}

// 08060B10: Register Eq_2 __sysconf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ebxOut, Register out Eq_2 ebpOut, Register out ptr32 esiOut)
// Called from:
//      qsort_r
//      __sysconf_check_spec
//      _nl_load_locale_from_archive
Eq_2 __sysconf(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ebxOut, union Eq_2 & ebpOut, ptr32 & esiOut)
{
	Eq_2 ebp_105;
	Eq_2175 eax_20 = gs->t0014;
	if (dwArg04 <= 199)
	{
		Eq_2 ecx_32;
		word32 edx_395;
		ebp_105 = __cache_sysconf(ecx_32, dwArg04, dwArg04, out ecx_32, out edx_395);
		goto l08060BA0;
	}
	if (dwArg04 != 0x22)
	{
		if (dwArg04 > 0x22)
		{
			ebp_105 = ebp;
			if (dwArg04 >= 0x8A)
			{
				if (dwArg04 <= 0x8B)
				{
					ebp_105.u0 = 200809;
					goto l08060BA0;
				}
				ebp_105 = ebp;
				if (dwArg04 == 0x95)
				{
					up32 eax_249;
					gs->ptr0010();
					ebp_105 = (0x00 - (word32) (eax_249 < ~0x0FFE) & 200810) - 0x01;
					goto l08060BA0;
				}
			}
			goto l08060C10;
		}
		if (dwArg04 == 0x00)
		{
			ebp_105.u0 = 0x00020000;
			if (__getrlimit(gs, 0x03, fp - 0x48) == 0x00)
			{
				if (dwLoc48 > 0x0007FFFF)
					ebp_105 = dwLoc48 >> 0x02;
			}
			goto l08060BA0;
		}
		ebp_105 = ebp;
		if (dwArg04 != 0x03)
		{
l08060C10:
			if (dwArg04 <= 0xF6)
			{
				<anonymous> * eax_234 = g_a80A3C28[dwArg04 * 0x04] + 0x080CE000;
				Eq_2 eax_242;
				word32 ecx_243;
				eax_234();
				ebxOut = dwArg04;
				ebpOut = ebp_105;
				esiOut = 0x080CE000;
				return eax_242;
			}
			gs->tFFFFFFE0.u0 = 22;
			ebp_105.u0 = ~0x00;
			goto l08060BA0;
		}
		word32 ecx_398;
		word32 edx_399;
		Eq_2 eax_115 = __open_nocancel(gs, 134888407, 0x00, dwLoc64, out ecx_398, out edx_399);
		ebp_105 = eax_115;
		if (eax_115 == ~0x00)
		{
			ebp_105.u0 = 0x00010000;
			goto l08060BA0;
		}
	}
	else
	{
		ebp_105 = dwLoc48;
		if (__getrlimit(gs, 11, fp - 0x48) == 0x00)
			goto l08060BA0;
		word32 ecx_402;
		word32 edx_403;
		Eq_2 eax_66 = __open_nocancel(gs, 0x080A3C0C, 0x00, dwLoc64, out ecx_402, out edx_403);
		ebp_105 = eax_66;
		if (eax_66 == ~0x00)
		{
l08060BA0:
			while ((eax_20 ^ gs->t0014) != 0x00)
			{
				word32 edx_397;
				word32 ecx_396;
				__stack_chk_fail(out ecx_396, out edx_397);
				ebp_105.u0 = ~0x00;
			}
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			return ebp_105;
		}
	}
	do
	{
		dwLoc64.u0 = 0x1F;
		word32 ecx_400;
		Eq_2 eax_142 = __read_nocancel(gs, ebp_105, fp - 0x40, 0x1F, out ecx_400);
		if (eax_142 != ~0x00)
		{
			word32 edx_401;
			__close_nocancel(gs, ebp_105, out edx_401);
			if (eax_142 <= 0x00)
				goto l08060C10;
			Mem185[fp - 0x40 + eax_142:byte] = 0x00;
			dwLoc64.u0 = 0x0A;
			ebp_105 = __strtol(gs, fp - 0x40, fp - 0x48, 0x0A);
			if (dwLoc48 == fp - 0x40)
				goto l08060C10;
			byte al_208 = *dwLoc48;
			if (al_208 != 0x00 && al_208 != 0x0A)
				goto l08060C10;
			goto l08060BA0;
		}
	} while (gs->tFFFFFFE0 == 0x04);
	word32 edx_404;
	__close_nocancel(gs, ebp_105, out edx_404);
	goto l08060C10;
}

// 08060F10: void sched_yield(Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_cleanup
void sched_yield(struct Eq_9 * gs)
{
	struct Eq_224 * eax_7;
	gs->ptr0010();
	if (eax_7 < (struct Eq_224 *) ~0x0FFE)
		return;
	word32 edx_29;
	__syscall_error(eax_7, gs, out edx_29);
}

// 08060F30: void __get_child_max(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void __get_child_max(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2175 eax_7 = gs->t0014;
	__getrlimit(gs, 0x06, fp - 0x18) != 0x00;
	if ((eax_7 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_78;
	word32 edx_79;
	__stack_chk_fail(out ecx_78, out edx_79);
	__xstat64(gs, dwArg08, dwArg0C);
}

// 08060F80: Register (ptr32 Eq_224) __xstat64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __sysconf_check_spec
//      __get_child_max
//      open_path
struct Eq_224 * __xstat64(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	struct Eq_224 * eax_11;
	gs->ptr0010();
	if (eax_11 <= (struct Eq_224 *) ~0x0FFF)
		return eax_11;
	word32 edx_44;
	return __syscall_error(eax_11, gs, out edx_44);
}

// 08060FB0: Register (ptr32 Eq_224) __fxstat64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_952 ecxOut, Register out ptr32 edxOut)
// Called from:
//      check_one_fd
//      _nl_load_domain
//      _IO_file_stat
//      getcwd
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      opendir
//      __fdopendir
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_224 * __fxstat64(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_952 & ecxOut, ptr32 & edxOut)
{
	struct Eq_224 * eax_11;
	ptr32 edx_29;
	gs->ptr0010();
	if (eax_11 > (struct Eq_224 *) ~0x0FFF)
	{
		ptr32 edx_19;
		struct Eq_224 * eax_18 = __syscall_error(eax_11, gs, out edx_19);
		ecxOut.u0 = <invalid>;
		edxOut = edx_19;
		return eax_18;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_29;
		return eax_11;
	}
}

// 08060FE0: Register (ptr32 Eq_224) open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _IO_file_open
struct Eq_224 * open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	struct Eq_43184 * esp_13 = fp - 0x1C;
	if (((byte) dwArg08 & 0x40) != 0x00 || (dwArg08 & 0x00410000) == 0x00410000)
		;
	struct Eq_224 * eax_128;
	if (gs->t000C == 0x00)
	{
		gs->ptr0010();
		if (eax_128 > (struct Eq_224 *) ~0x0FFF)
		{
			word32 edx_149;
			eax_128 = __syscall_error(eax_128, gs, out edx_149);
		}
	}
	else
	{
		word32 ecx_147;
		word32 edx_148;
		word32 eax_46 = __libc_enable_asynccancel(gs, out ecx_147, out edx_148);
		struct Eq_224 * eax_54;
		gs->ptr0010();
		if (eax_54 > (struct Eq_224 *) ~0x0FFF)
		{
			word32 edx_150;
			eax_54 = __syscall_error(eax_54, gs, out edx_150);
			esp_13 = fp - 0x18;
		}
		esp_13->ptr000C = eax_54;
		struct Eq_43235 * esp_69 = esp_13 - 0x0C;
		esp_69->dwFFFFFFFC = eax_46;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_43241 stackArg4 = <invalid>;
		word32 edx_153;
		word32 ecx_152;
		__libc_disable_asynccancel(gs, stackArg4, out ecx_152, out edx_153);
		eax_128 = esp_69->ptr0018;
	}
	return eax_128;
}

// 080610A0: Register (ptr32 Eq_224) read(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _IO_file_read
//      __gconv_load_cache
struct Eq_224 * read(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	struct Eq_224 * eax_100;
	struct Eq_43259 * esp_10 = fp - 0x1C;
	if (gs->t000C != 0x00)
	{
		word32 ecx_120;
		word32 edx_121;
		word32 eax_23 = __libc_enable_asynccancel(gs, out ecx_120, out edx_121);
		struct Eq_224 * eax_31;
		gs->ptr0010();
		if (eax_31 > (struct Eq_224 *) ~0x0FFF)
		{
			word32 edx_122;
			eax_31 = __syscall_error(eax_31, gs, out edx_122);
			esp_10 = fp - 0x18;
		}
		esp_10->ptr0008 = eax_31;
		struct Eq_43292 * esp_45 = esp_10 - 0x0C;
		esp_45->dwFFFFFFFC = eax_23;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_43241 stackArg4 = <invalid>;
		word32 ecx_124;
		word32 edx_125;
		__libc_disable_asynccancel(gs, stackArg4, out ecx_124, out edx_125);
		eax_100 = esp_45->ptr0014;
		return eax_100;
	}
	else
	{
		gs->ptr0010();
		if (eax_100 <= (struct Eq_224 *) ~0x0FFF)
			return eax_100;
		word32 edx_126;
		return __syscall_error(eax_100, gs, out edx_126);
	}
}

// 08061140: Register (ptr32 Eq_224) __libc_write(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C, Register out Eq_952 ebxOut, Register out Eq_952 esiOut)
// Called from:
//      __assert_fail_base
//      _IO_new_file_write
struct Eq_224 * __libc_write(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 dwArg08, int32 dwArg0C, union Eq_952 & ebxOut, union Eq_952 & esiOut)
{
	struct Eq_224 * eax_100;
	struct Eq_43314 * esp_10 = fp - 0x1C;
	if (gs->t000C == 0x00)
	{
		gs->ptr0010();
		if (eax_100 > (struct Eq_224 *) ~0x0FFF)
		{
			word32 edx_128;
			struct Eq_224 * eax_73 = __syscall_error(eax_100, gs, out edx_128);
			ebxOut.u0 = <invalid>;
			esiOut.u0 = <invalid>;
			return eax_73;
		}
	}
	else
	{
		word32 ecx_122;
		word32 edx_123;
		word32 eax_23 = __libc_enable_asynccancel(gs, out ecx_122, out edx_123);
		struct Eq_224 * eax_31;
		gs->ptr0010();
		if (eax_31 > (struct Eq_224 *) ~0x0FFF)
		{
			word32 edx_124;
			eax_31 = __syscall_error(eax_31, gs, out edx_124);
			esp_10 = fp - 0x18;
		}
		esp_10->ptr0008 = eax_31;
		struct Eq_43347 * esp_45 = esp_10 - 0x0C;
		esp_45->dwFFFFFFFC = eax_23;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_43241 stackArg4 = <invalid>;
		word32 ecx_126;
		word32 edx_127;
		__libc_disable_asynccancel(gs, stackArg4, out ecx_126, out edx_127);
		eax_100 = esp_45->ptr0014;
	}
	ebxOut.u0 = <invalid>;
	esiOut.u0 = <invalid>;
	return eax_100;
}

// 080611E0: Register Eq_2 lseek64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 edxOut, Register out Eq_2 ebxOut, Register out ptr32 esiOut, Register out Eq_2 ediOut)
// Called from:
//      mmap_remap_check
//      _IO_file_seek
//      _IO_file_sync_mmap
//      decide_maybe_mmap
//      __getdents
Eq_2 lseek64(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & edxOut, union Eq_2 & ebxOut, ptr32 & esiOut, union Eq_2 & ediOut)
{
	Eq_2175 eax_15 = gs->t0014;
	struct Eq_224 * eax_26;
	gs->ptr0010();
	if (eax_26 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_138;
		eax_26 = __syscall_error(eax_26, gs, out edx_138);
	}
	int64 edx_eax_40 = (int64) eax_26;
	Eq_2 eax_102 = (word32) edx_eax_40;
	ptr32 edx_107 = SLICE(edx_eax_40, word32, 32);
	if (eax_102 == 0x00)
	{
		eax_102 = dwLoc1C;
		edx_107 = dwLoc18;
	}
	if ((eax_15 ^ gs->t0014) != 0x00)
	{
		word32 edx_140;
		word32 ecx_139;
		__stack_chk_fail(out ecx_139, out edx_140);
		ptr32 edx_71;
		word32 edi_141;
		Eq_2 eax_70 = getcwd(gs, dwArg04, dwArg08, out edx_71, out edi_141);
		edxOut = edx_71;
		ebxOut = dwArg04;
		esiOut = fp - 0x1C;
		ediOut = dwArg10;
		return eax_70;
	}
	else
	{
		edxOut = edx_107;
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return eax_102;
	}
}

// 08061250: Register word32 getcwd(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 edxOut, Register out ptr32 ediOut)
// Called from:
//      __dcigettext
//      lseek64
//      __gconv_get_path
//      _dl_new_object
word32 getcwd(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & edxOut, ptr32 & ediOut)
{
	struct Eq_43416 * esp_126;
	struct Eq_43416 * esp_101;
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 edi_160 = dwArg08;
	Eq_2 esi_134 = dwArg04;
	if (dwArg08 == 0x00)
	{
		if (dwArg04 != 0x00)
		{
			gs->tFFFFFFE0.u0 = 22;
			dwLocDC = 0x00;
			goto l08061541;
		}
		Eq_2 eax_39 = __getpagesize();
		edi_160.u0 = 0x1000;
		if (eax_39 >= 0x1000)
			edi_160 = eax_39;
	}
	else
	{
		edi_160 = dwArg08;
		if (dwArg04 != 0x00)
			goto l080612CF;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	esp_101 = fp - 0xEC;
	word32 esi_1320;
	word32 edi_1321;
	word32 ecx_1317;
	word32 ebx_1318;
	word32 ebp_1319;
	if (__libc_malloc(gs, stackArg0, edi_160, out ecx_1317, out edx, out ebx_1318, out ebp_1319, out esi_1320, out edi_1321) == 0x00)
		goto l08061539;
l080612CF:
	struct Eq_224 * eax_77;
	gs->ptr0010();
	esp_101 = fp - 0xEC;
	if (eax_77 > (struct Eq_224 *) ~0x0FFF)
	{
		eax_77 = __syscall_error(eax_77, gs, out edx);
		esp_101 = fp - 232;
	}
	if (eax_77 > null)
	{
		edi_160.u0 = ~0x1F;
		edx = esp_101->t00F4 | dwArg04;
		if (*esp_101->t000C == 0x2F)
		{
			esp_101->t0010 = dwArg04;
			if (edx == 0x00)
			{
				struct Eq_44669 * esp_168 = esp_101 - 0x08;
				esp_168->ptrFFFFFFFC = eax_77;
				esp_168->dwFFFFFFF8 = esp_168->dw0014;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 esi_1377;
				word32 ebp_1376;
				word32 edi_1378;
				esp_168->t0018 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx, out ebp_1376, out esi_1377, out edi_1378);
			}
			Eq_2 eax_185 = esp_101->t0010;
			Eq_2 ebx_186 = esp_101->t000C;
			if (eax_185 != 0x00)
				ebx_186 = eax_185;
			esp_101->t0010 = ebx_186;
l08061541:
			esp_126 = fp - 0x00EC;
			if ((eax_20 ^ gs->t0014) == 0x00)
			{
				edxOut = edx;
				ediOut = edi;
				return dwLocDC;
			}
			word32 ecx_1341;
			word32 edx_1342;
			__stack_chk_fail(out ecx_1341, out edx_1342);
l080619D4:
			edx = gs->*edi_160.u0;
l080617D4:
			esp_126->t0014 = edx;
			struct Eq_44300 * esp_881 = esp_126 - 0x0C;
			esp_881->tFFFFFFFC = esi_134;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			closedir(gs, stackArg4);
			esp_126 = (struct Eq_43416 *) ((char *) &esp_881->tFFFFFFFC + 16);
			edx = esp_881->t0020;
l080617E8:
			if (esp_126->t0010 == 0x00)
			{
				esp_126->t0014 = edx;
				struct Eq_44237 * esp_911 = esp_126 - 0x0C;
				esp_911->dwFFFFFFFC = esp_911->dw0018;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_1355;
				word32 edx_1356;
				free(gs, stackArg0, stackArg4, out ecx_1355, out edx_1356);
				edx = esp_911->t0020;
			}
			gs->*edi_160.u0 = edx;
			esp_101 = esp_126;
			if (esp_126->t00F4 != 0x00 && esp_126->b003E != 0x00)
			{
				struct Eq_44270 * esp_950 = esp_126 - 0x0C;
				esp_950->dwFFFFFFFC = esp_950->dw001C;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_1359;
				free(gs, stackArg0, stackArg4, out ecx_1359, out edx);
				esp_950->dw001C = 0x00;
				goto l08061541;
			}
			goto l08061539;
		}
	}
	else
	{
		edi_160.u0 = ~0x1F;
		if (eax_77 != null)
		{
			Eq_2 eax_97 = gs->tFFFFFFE0;
			if (eax_97 != 0x24)
			{
				if (eax_97 == 0x22 && (dwArg04 | esp_101->t00F4) == 0x00)
				{
					struct Eq_44440 * esp_118 = esp_101 - 4;
					esp_118->ptr0000 = 0x080A4058;
					esp_118->dwFFFFFFFC = 121;
					esp_118->ptrFFFFFFF8 = 0x080A4008;
					esp_118->ptrFFFFFFF4 = 0x080A402C;
					word32 ecx_1364;
					word32 edx_1365;
					__assert_fail(out ecx_1364, out edx_1365);
					esp_126 = esp_118 - 0x0C;
					esi_134 = dwArg04;
					goto l080618A8;
				}
				if (dwArg04 == 0x00)
				{
					struct Eq_43975 * esp_140 = esp_101 - 0x0C;
					esp_140->dwFFFFFFFC = esp_140->dw0018;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_1340;
					free(gs, stackArg0, stackArg4, out ecx_1340, out edx);
					esp_140->dw001C = 0x00;
					goto l08061541;
				}
				goto l08061539;
			}
		}
		edx = esp_101->t00F4 | dwArg04;
	}
	esp_101->b003E = (int8) (dwArg04 == 0x00);
	edi_160.u0 = ~0x1F;
	if (edx != 0x00)
	{
		esi_134 = esp_101->t00F4;
		if (esi_134 != 0x00)
		{
			esp_101->t004C = gs->tFFFFFFE0;
			esp_101->t0010 = esp_101->t000C;
			esp_101->t0030 = esp_101->t00F4;
			goto l08061348;
		}
		gs->tFFFFFFE0.u0 = 22;
	}
	else
	{
		struct Eq_43498 * esp_203 = esp_101 - 0x0C;
		esp_203->tFFFFFFFC = esp_203->t0018;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_1324;
		word32 edx_1325;
		free(gs, stackArg0, stackArg4, out ecx_1324, out edx_1325);
		Eq_2 eax_221 = gs->tFFFFFFE0;
		esp_203->tFFFFFFFC.u0 = 0x1001;
		esp_203->t0058 = eax_221;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 esi_1331;
		word32 edi_1332;
		word32 ebx_1329;
		word32 ecx_1328;
		word32 ebp_1330;
		Eq_2 eax_224 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1328, out edx, out ebx_1329, out ebp_1330, out esi_1331, out edi_1332);
		esp_203->t0018 = eax_224;
		esp_101 = (struct Eq_43416 *) ((char *) &esp_203->tFFFFFFFC + 16);
		if (eax_224 != 0x00)
		{
			esp_203->dw001C = 0x00;
			esp_203->dw003C = 0x1001;
l08061348:
			struct Eq_43577 * esp_249 = esp_101 - 0x04;
			struct Eq_43634 * ebx_250 = (word32) esp_101->t000C + esp_249->dw0034;
			ebx_250->bFFFFFFFF = 0x00;
			esp_249->ptr001C = &esp_249->dw0070;
			esp_249->ptrFFFFFFFC = &esp_249->dw0070;
			esp_249->ptrFFFFFFF8 = 0x080A4005;
			esp_249->dwFFFFFFF4 = 0x03;
			esi_134 = &esp_249->dw0070;
			esp_126 = (struct Eq_43416 *) ((char *) &esp_249->ptrFFFFFFFC + 8);
			if (__lxstat64(gs, esp_249->ptrFFFFFFF8, esp_249->ptrFFFFFFFC) >= 0x00)
			{
				word32 edx_276 = esp_249->dw0070;
				word32 ecx_279 = esp_249->dw00C8;
				esp_249->dw0028 = esp_249->dw0074;
				esp_249->dw0024 = edx_276;
				esp_249->dw0020 = ecx_279;
				esp_249->ptrFFFFFFFC = &esp_249->dw0070;
				esp_249->ptrFFFFFFF8 = 134893093;
				esp_249->dwFFFFFFF4 = 0x03;
				esp_126 = (struct Eq_43416 *) ((char *) &esp_249->ptrFFFFFFFC + 8);
				if (__lxstat64(gs, esp_249->ptrFFFFFFF8, esp_249->ptrFFFFFFFC) >= 0x00)
				{
					word32 edx_301 = esp_249->dw00C8;
					word32 ecx_303 = esp_249->dw0074;
					esp_249->dw0054 = ebx_250 - 0x01;
					word32 eax_305 = esp_249->dw0028;
					word32 esi_306 = esp_249->dw0070;
					esp_249->dw0038 = edx_301;
					word32 edx_308 = esp_249->dw0024;
					esp_249->dw005C = ecx_303;
					word32 ecx_311 = esp_249->dw0038;
					esp_249->dw0058 = esi_306;
					byte dl_321 = (int8) ((edx_308 ^ esi_306 | eax_305 ^ ecx_303) != 0x00) | (int8) (esp_249->dw0020 != ecx_311);
					esp_249->b0043 = dl_321;
					if (dl_321 == 0x00)
					{
l0806174C:
						if (esp_101->t0050 == (word32) esp_101->t0030 + (esp_101->t000C - 0x01))
						{
							Eq_2 eax_774 = esp_101->t0050;
							*((word32) eax_774 - 1) = 0x2F;
							esp_101->t0050 = eax_774 - 0x01;
						}
						Eq_2 eax_781 = esp_101->t0050;
						struct Eq_44543 * esp_782 = esp_101 - 0x04;
						Eq_2 ebx_785 = ebx_250 - eax_781;
						esp_782->tFFFFFFFC = ebx_785;
						esp_782->tFFFFFFF8 = eax_781;
						esp_782->tFFFFFFF4 = esp_782->t0010;
						memmove(esp_782->tFFFFFFF4, esp_782->tFFFFFFF8, esp_782->tFFFFFFFC, out edx);
						esi_134 = esp_782->t00F8;
						if (esi_134 == 0x00)
						{
							esp_782->tFFFFFFF8 = ebx_785;
							esp_782->tFFFFFFF4 = esp_782->t0010;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 ebp_1371;
							word32 esi_1372;
							word32 edi_1373;
							esp_782->t0014 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx, out ebp_1371, out esi_1372, out edi_1373);
						}
						Eq_2 eax_833 = esp_101->t0010;
						Eq_2 ebx_834 = esp_101->t000C;
						if (eax_833 != 0x00)
							ebx_834 = eax_833;
						Eq_2 eax_841 = esp_101->t004C;
						esp_101->t0010 = ebx_834;
						gs->tFFFFFFE0 = eax_841;
						goto l08061541;
					}
					esp_249->dw0018 = ~0x63;
					esp_249->ptr003C = 0x080A4004;
					esi_134.u0 = 0x00;
					do
					{
						struct Eq_43710 * esp_333 = esp_101 - 0x04;
						esp_333->tFFFFFFFC.u0 = 0x00080000;
						esp_333->tFFFFFFF8 = esp_333->t003C;
						esp_333->tFFFFFFF4 = esp_333->t0018;
						Eq_2 eax_344 = __openat64_nocancel(gs, esp_333->tFFFFFFF4, esp_333->tFFFFFFF8, esp_333->tFFFFFFFC, esp_333->dw0000);
						esp_333->t0018 = eax_344;
						esp_126 = (struct Eq_43416 *) (&esp_333->dw0000 + 1);
						if (eax_344 < 0x00)
						{
							edx = gs->tFFFFFFE0;
							if (esi_134 != 0x00)
								goto l080617D4;
							goto l080617E8;
						}
						Eq_2 edx_382;
						esp_333->tFFFFFFFC = esp_333->t001C;
						esp_333->tFFFFFFF8 = eax_344;
						esp_333->tFFFFFFF4.u0 = 0x03;
						word32 edx_1334;
						word32 ecx_1333;
						if (__fxstat64(gs, esp_333->tFFFFFFF8, esp_333->tFFFFFFFC, out ecx_1333, out edx_1334) < 0x00)
						{
							edx_382 = gs->tFFFFFFE0;
							if (esi_134 != 0x00)
							{
								esp_333->t001C = edx_382;
								esp_333->tFFFFFFF4 = esi_134;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg4 = <invalid>;
								closedir(gs, stackArg4);
								edx_382 = esp_333->t001C;
							}
							goto l0806194E;
						}
						if (esi_134 != 0x00)
						{
							esp_333->tFFFFFFF4 = esi_134;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							if (closedir(gs, stackArg4) == 0x00)
								goto l08061465;
l0806194B:
							edx_382 = gs->tFFFFFFE0;
l0806194E:
							esp_101->t0018 = edx_382;
							struct Eq_44493 * esp_451 = esp_101 - 0x0C;
							esp_451->tFFFFFFFC = esp_451->t0020;
							word32 edx_1367;
							__close_nocancel(gs, esp_451->tFFFFFFFC, out edx_1367);
							esp_126 = (struct Eq_43416 *) ((char *) &esp_451->tFFFFFFFC + 16);
							edx = esp_451->t0024;
							goto l080617E8;
						}
l08061465:
						struct Eq_43745 * esp_420 = esp_101 - 0x0C;
						word32 ecx_419 = esp_101->dw0070;
						word32 ebx_422 = esp_420->dw00D0;
						esp_420->dw0050 = esp_101->dw006C;
						esp_420->dw004C = ecx_419;
						esp_420->dw0068 = ebx_422;
						esp_420->dwFFFFFFFC = esp_420->dw0020;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						Eq_2 eax_434 = __fdopendir(gs, stackArg4);
						esi_134 = eax_434;
						if (eax_434 == 0x00)
							goto l0806194B;
						ui32 ecx_469 = esp_420->dw004C ^ esp_420->dw0030;
						esp_420->dw0034 = esp_420->dw0050 ^ esp_420->dw002C;
						word32 ebx_473 = (word32) esp_420->b004B;
						esp_420->dw0038 = ecx_469;
						esi_134 = eax_434;
						do
						{
							gs->tFFFFFFE0.u0 = 0x00;
							struct Eq_43837 * esp_478 = esp_101 - 0x0C;
							esp_478->tFFFFFFFC = eax_434;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							byte bl_501 = (byte) ebx_473;
							struct Eq_43826 * eax_489 = __readdir(gs, stackArg4);
							word24 edx_24_8_850 = SLICE(edx_491, word24, 8);
							esp_126 = (struct Eq_43416 *) ((char *) &esp_478->t0008 + 4);
							if (eax_489 == null)
							{
								edx = gs->tFFFFFFE0;
								if (edx != 0x00)
									goto l080617D4;
								if (bl_501 == 0x00)
								{
									gs->tFFFFFFE0.u0 = 0x02;
									edx.u0 = 0x02;
									goto l080617D4;
								}
								else
								{
									esp_101->tFFFFFFF0 = eax_434;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg4 = <invalid>;
									ebx_473 = 0x00;
									Eq_2 edx_515 = __rewinddir(edx_515, gs, stackArg4);
									continue;
								}
							}
							if ((eax_489->b000A & ~0x04) != 0x00 || eax_489->b000B == 0x2E && (eax_489->t000C == 0x00 || eax_489->t000C == 0x2E))
								continue;
							byte dl_536 = (int8) ((esp_478->dw0034 | esp_478->dw0038) == 0x00) & bl_501;
							word32 edx_851 = SEQ(edx_24_8_850, dl_536);
							if (dl_536 != 0x00 && eax_489->t0000 != esp_478->t0028)
							{
								ebx_473 = edx_851;
								continue;
							}
							esp_478->t0054 = &eax_489->b000B;
							esp_478->tFFFFFFFC.u0 = 0x0100;
							esp_478->dwFFFFFFF8 = esp_478->dw0024;
							esp_478->ptrFFFFFFF4 = &eax_489->b000B;
							esp_478->dwFFFFFFF0 = esp_478->dw0020;
							esp_478->dwFFFFFFEC = 0x03;
						} while (__fxstatat64(gs, esp_478->dwFFFFFFEC, esp_478->dwFFFFFFF0, esp_478->ptrFFFFFFF4, esp_478->dwFFFFFFF8, esp_478->tFFFFFFFC) < 0x00 || ((esp_478->dw0088 & 0xF000) != 0x4000 || ((esp_478->t0030 ^ esp_478->dw007C | esp_478->t002C ^ esp_478->dw0078) != 0x00 || (esp_478->t0028 ^ esp_478->dw00D0 | esp_478->dw00D4) != 0x00)));
						esp_478->tFFFFFFFC = esp_478->t0054;
						word32 edx_1344;
						word32 ecx_1343;
						Eq_2 eax_598 = strlen(esp_478->tFFFFFFFC, out ecx_1343, out edx_1344);
						Eq_2 ebx_606 = esp_478->t005C;
						Eq_2 ecx_607 = esp_478->t0018;
						esp_478->t0030 = eax_598;
						Eq_2 ebx_609 = ebx_606 - ecx_607;
						esp_478->t002C = ebx_609;
						esp_126 = (struct Eq_43416 *) ((char *) &esp_478->t0008 + 4);
						if (eax_598 >= ebx_609)
						{
							if (esp_478->dw0100 != 0x00)
							{
								gs->tFFFFFFE0.u0 = 0x22;
								edx.u0 = 0x22;
								goto l080617D4;
							}
							Eq_2 ebx_619 = esp_478->t003C;
							if (eax_598 >= ebx_619)
								ebx_619 = eax_598;
							Eq_2 eax_625 = ebx_619 * 0x02;
							esp_478->t0028 = eax_625;
							esp_478->t0008 = ebx_619;
							esp_478->t0004 = ebx_619;
							esp_478->t0000 = eax_625;
							esp_478->tFFFFFFFC = ecx_607;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 esi_1351;
							word32 edi_1352;
							word32 edx_1349;
							word32 ebp_1350;
							Eq_2 eax_650 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx_1349, out ebp_1350, out esi_1351, out edi_1352);
							esp_126 = (struct Eq_43416 *) ((char *) &esp_478->t0008 + 4);
							if (eax_650 == 0x00)
								goto l080619D4;
							Eq_2 ebx_659 = esp_478->t0028;
							Eq_2 ecx_660 = esp_478->t0018;
							esp_478->t0018 = eax_650;
							word32 ecx_663 = ecx_660 + Mem661[esp_478 + 0x3C:word32] - Mem661[esp_478 + 0x5C:word32];
							word32 eax_667 = Mem661[esp_478 + 44:word32] + eax_650;
							esp_478->t0008 = eax_650;
							esp_478->t0004 = ecx_663;
							esp_478->t0000 = eax_667;
							esp_478->tFFFFFFFC = (word32) eax_650 + (ebx_659 - ecx_663);
							word32 edx_1362;
							word32 ecx_1361;
							esp_478->t005C = memcpy(esp_478->tFFFFFFFC, esp_478->t0000, esp_478->t0004, out ecx_1361, out edx_1362);
							esp_478->t003C = esp_478->t0028;
						}
						struct Eq_44079 * esp_695 = esp_101 - 0x04;
						Eq_2 ebx_693 = esp_101->t0024;
						ptr32 ecx_696 = esp_695->ptr0054;
						esp_695->dw0020 = esp_101->dw005C;
						esp_695->tFFFFFFFC = ebx_693;
						esp_695->tFFFFFFF8 = esp_695->t004C;
						Eq_2 ecx_698 = ecx_696 - ebx_693;
						esp_695->tFFFFFFF4 = ecx_698;
						esp_695->t0024 = ecx_698;
						word32 ecx_1345;
						word32 edx_1346;
						memcpy(esp_695->tFFFFFFF4, esp_695->tFFFFFFF8, esp_695->tFFFFFFFC, out ecx_1345, out edx_1346);
						Eq_2 ecx_718 = esp_695->t0024;
						word32 edx_719 = esp_695->dw0058;
						*((word32) ecx_718 - 1) = 0x2F;
						word32 ecx_722 = esp_695->dw005C;
						esp_695->ptr0054 = ecx_718 - 0x01;
						Eq_2 ebx_724 = esp_695->t0048;
						word32 eax_727 = esp_695->dw0020;
						ui32 edx_729 = edx_719 ^ ebx_724 | ecx_722 ^ esp_695->dw0044;
						esp_695->t0024 = ebx_724;
						int8 al_737 = (int8) (esp_695->dw0038 != eax_727);
						esp_695->dw0028 = esp_695->dw0044;
					} while (((int8) (edx_729 != 0x00) | al_737) != 0x00);
					esp_101->tFFFFFFF0 = eax_434;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					esp_126 = esp_101;
					if (closedir(gs, stackArg4) == 0x00)
					{
						ebx_250 = Mem747[esp_101 + 0x0C:word32] + Mem747[esp_101 + 0x30:word32];
						goto l0806174C;
					}
				}
			}
l080618A8:
			edi_160.u0 = ~0x1F;
			edx = gs->tFFFFFFE0;
			goto l080617E8;
		}
	}
l08061539:
	esp_101->t0010.u0 = 0x00;
	goto l08061541;
}

// 080619F0: Register (ptr32 Eq_224) __close_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 edxOut)
// Called from:
//      _nl_load_domain
//      _IO_file_close
//      _IO_file_close_mmap
//      _IO_file_open
//      _int_free
//      __sysconf
//      getcwd
//      get_nprocs
//      _dl_discover_osversion
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __alloc_dir
//      opendir
//      closedir
//      lose
//      open_verify.constprop.7
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_224 * __close_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & edxOut)
{
	struct Eq_224 * eax_10;
	ptr32 edx_26;
	gs->ptr0010();
	if (eax_10 > (struct Eq_224 *) ~0x0FFF)
	{
		ptr32 edx_17;
		struct Eq_224 * eax_16 = __syscall_error(eax_10, gs, out edx_17);
		edxOut = edx_17;
		return eax_16;
	}
	else
	{
		edxOut = edx_26;
		return eax_10;
	}
}

// 08061A20: void __fcntl64_nocancel_adjusted(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      __fcntl64_nocancel
void __fcntl64_nocancel_adjusted(struct Eq_9 * gs, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_224 * eax_20;
	Eq_2175 eax_9 = gs->t0014;
	if (dwArg08 != 0x09)
	{
		gs->ptr0010();
		if (eax_20 <= (struct Eq_224 *) ~0x0FFF)
			goto l08061A58;
	}
	else
	{
		gs->ptr0010();
		if (eax_20 <= (struct Eq_224 *) ~0x0FFF)
			goto l08061A58;
	}
	word32 edx_121;
	__syscall_error(eax_20, gs, out edx_121);
l08061A58:
	if ((eax_9 ^ gs->t0014) == 0x00)
		return;
	word32 edx_123;
	word32 ecx_122;
	__stack_chk_fail(out ecx_122, out edx_123);
	__fcntl64_nocancel();
}

// 08061AB0: Register Eq_2 __fcntl64_nocancel()
// Called from:
//      check_one_fd
//      __fcntl64_nocancel_adjusted
//      __alloc_dir
//      __fdopendir
Eq_2 __fcntl64_nocancel()
{
	__fcntl64_nocancel_adjusted(gs, dwArg04, dwArg08, dwArg0C);
	return <invalid>;
}

// 08061AD0: Register (ptr32 Eq_224) __open_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      check_one_fd
//      _nl_load_domain
//      __libc_message
//      _IO_file_open
//      _int_free
//      __sysconf
//      get_nprocs
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      opendir
struct Eq_224 * __open_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	if (((byte) dwArg08 & 0x40) != 0x00 || (dwArg08 & 0x00410000) == 0x00410000)
		;
	ptr32 ecx_37;
	struct Eq_224 * eax_36;
	ptr32 edx_35;
	gs->ptr0010();
	if (eax_36 > (struct Eq_224 *) ~0x0FFF)
		eax_36 = __syscall_error(eax_36, gs, out edx_35);
	ecxOut = ecx_37;
	edxOut = edx_35;
	return eax_36;
}

// 08061B30: Register (ptr32 Eq_224) __openat64_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10)
// Called from:
//      getcwd
struct Eq_224 * __openat64_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10)
{
	byte al_12 = (byte) dwArg0C;
	byte ah_25 = SLICE(dwArg0C, byte, 8);
	word16 eax_16_16_37 = SLICE(dwArg0C, word16, 16);
	if ((al_12 & 0x40) != 0x00 || (dwArg0C & 0x00410000) == 0x00410000)
		;
	struct Eq_224 * eax_48;
	gs->ptr0010();
	if (eax_48 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_97;
		eax_48 = __syscall_error(eax_48, gs, out edx_97);
	}
	return eax_48;
}

// 08061BA0: Register (ptr32 Eq_224) __read_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_952 ecxOut)
// Called from:
//      _nl_load_domain
//      _IO_file_read
//      _int_free
//      __sysconf
//      next_line
//      _dl_discover_osversion
//      _nl_load_locale
//      _dl_process_pt_note
//      open_verify.constprop.7
//      _dl_map_object_from_fd.constprop.8
struct Eq_224 * __read_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_952 & ecxOut)
{
	struct Eq_224 * eax_12;
	gs->ptr0010();
	if (eax_12 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_47;
		struct Eq_224 * eax_20 = __syscall_error(eax_12, gs, out edx_47);
		ecxOut.u0 = <invalid>;
		return eax_20;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		return eax_12;
	}
}

// 08061BE0: Register (ptr32 Eq_224) __write_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C)
// Called from:
//      _IO_new_file_write
//      _dl_start_profile
struct Eq_224 * __write_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 dwArg08, int32 dwArg0C)
{
	struct Eq_224 * eax_12;
	gs->ptr0010();
	if (eax_12 <= (struct Eq_224 *) ~0x0FFF)
		return eax_12;
	word32 edx_46;
	return __syscall_error(eax_12, gs, out edx_46);
}

// 08061C20: Register (ptr32 Eq_224) __getrlimit(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      __sysconf
//      __get_child_max
//      getdtablesize
struct Eq_224 * __getrlimit(struct Eq_9 * gs, word32 dwArg04, ptr32 dwArg08)
{
	struct Eq_224 * eax_11;
	gs->ptr0010();
	if (eax_11 <= (struct Eq_224 *) ~0x0FFF)
		return eax_11;
	word32 edx_44;
	return __syscall_error(eax_11, gs, out edx_44);
}

// 08061C50: Register Eq_44841 __sbrk(Register (ptr32 Eq_9) gs, Stack Eq_1921 dwArg04, Register out ptr32 edxOut)
// Called from:
//      __libc_setup_tls
//      __default_morecore
//      __tunables_init
Eq_44841 __sbrk(struct Eq_9 * gs, Eq_1921 dwArg04, ptr32 & edxOut)
{
	Eq_44841 ebx_105 = __curbrk;
	if (ebx_105 == 0x00 || __libc_multiple_libcs != 0x00)
	{
		if (brk(gs, 0x00, out edx) < null)
			goto l08061C9F;
		ebx_105 = __curbrk;
	}
	if (dwArg04 == 0x00)
		goto l08061CA4;
	if (dwArg04 > 0x00)
	{
		if (CONVERT(ebx_105 + dwArg04 <u 0x00, bool, int8) != 0x00)
		{
l08061C92:
			gs->tFFFFFFE0.u0 = 0x0C;
l08061C9F:
			ebx_105.u0 = ~0x00;
l08061CA4:
			edxOut = edx;
			return ebx_105;
		}
	}
	else if ((int8) (-dwArg04 > ebx_105) != 0x00)
		goto l08061C92;
	if (brk(gs, dwArg04 + ebx_105, out edx) >= 0x00)
	{
		edxOut = edx;
		return ebx_105;
	}
	goto l08061C9F;
}

// 08061D00: Register Eq_2 __getpagesize()
// Called from:
//      mmap_remap_check
//      getcwd
//      sysinfo_mempages
Eq_2 __getpagesize()
{
	Eq_2 eax_8 = _dl_pagesize;
	if (eax_8 != 0x00)
		return eax_8;
	word32 ecx_49;
	word32 edx_50;
	__assert_fail(out ecx_49, out edx_50);
	return getdtablesize(gs);
}

// 08061D40: Register Eq_2 getdtablesize(Register (ptr32 Eq_9) gs)
// Called from:
//      __getpagesize
Eq_2 getdtablesize(struct Eq_9 * gs)
{
	Eq_2175 eax_7 = gs->t0014;
	Eq_2 eax_27 = 0x0100;
	if (__getrlimit(gs, 0x07, fp - 0x18) >= 0x00)
		eax_27 = dwLoc18;
	if ((eax_7 ^ gs->t0014) == 0x00)
		return eax_27;
	word32 edx_82;
	word32 ecx_81;
	__stack_chk_fail(out ecx_81, out edx_82);
	word32 ecx_83;
	word32 edx_84;
	return mmap(gs, dwLoc18, dwLoc14, eax_7, dwLoc0C, dwLoc08, dwLoc04, out ecx_83, out edx_84);
}

// 08061D90: Register (ptr32 Eq_224) mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2175 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Register out Eq_2 ecxOut, Register out Eq_2180 edxOut)
// Called from:
//      __assert_fail_base
//      _nl_load_domain
//      __libc_message
//      new_heap
//      _int_free
//      sysmalloc
//      getdtablesize
//      __gconv_load_cache
//      _nl_load_locale
//      _dl_map_object_from_fd.constprop.8
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_224 * mmap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2175 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, union Eq_2 & ecxOut, union Eq_2180 & edxOut)
{
	struct Eq_224 * eax_25;
	Eq_2 ecx_18 = dwArg08;
	if ((dwArg18 & 0x0FFF) == 0x00)
	{
		Eq_2180 edx_33;
		gs->ptr0010();
		if (eax_25 <= (struct Eq_224 *) ~0x0FFF)
		{
			ecxOut = ecx_18;
			edxOut = edx_33;
			return eax_25;
		}
	}
	else
		eax_25 = (struct Eq_224 *) ~0x15;
	Eq_2180 edx_50;
	struct Eq_224 * eax_49 = __syscall_error(eax_25, gs, out edx_50);
	ecxOut = ecx_18;
	edxOut = edx_50;
	return eax_49;
}

// 08061DF0: Register (ptr32 Eq_224) mmap64(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      decide_maybe_mmap
//      _nl_load_locale_from_archive
struct Eq_224 * mmap64(struct Eq_9 * gs, word32 dwArg04, Eq_2 dwArg08, word32 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C)
{
	struct Eq_224 * eax_33 = (struct Eq_224 *) ~0x15;
	if ((dwArg1C & ~0x0FFF | dwArg18 & 0x0FFF) == 0x00)
	{
		gs->ptr0010();
		if (eax_33 <= (struct Eq_224 *) ~0x0FFF)
			return eax_33;
	}
	word32 edx_115;
	return __syscall_error(eax_33, gs, out edx_115);
}

// 08061E80: Register (ptr32 Eq_224) __munmap(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_952 ecxOut, Register out ptr32 edxOut, Register out Eq_952 ebxOut)
// Called from:
//      __assert_fail_base
//      _nl_load_domain
//      __libc_message
//      _IO_file_close_mmap
//      mmap_remap_check
//      decide_maybe_mmap
//      new_heap
//      munmap_chunk
//      _int_free
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_unload_locale
//      _nl_load_locale_from_archive
//      _dl_map_object_from_fd.constprop.8
//      _dl_start_profile
//      _dl_load_cache_lookup
//      _dl_unload_cache
//      _dl_unmap
//      _nl_unload_domain
//      free_mem
//      _nl_archive_subfreeres
struct Eq_224 * __munmap(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_952 & ecxOut, ptr32 & edxOut, union Eq_952 & ebxOut)
{
	ptr32 edx_11;
	struct Eq_224 * eax_13;
	gs->ptr0010();
	if (eax_13 >= (struct Eq_224 *) ~0x0FFE)
	{
		ptr32 edx_19;
		struct Eq_224 * eax_18 = __syscall_error(eax_13, gs, out edx_19);
		ecxOut.u0 = <invalid>;
		edxOut = edx_19;
		ebxOut.u0 = <invalid>;
		return eax_18;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_11;
		ebxOut.u0 = <invalid>;
		return eax_13;
	}
}

// 08061EB0: Register (ptr32 Eq_224) mprotect(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_952 ecxOut, Register out Eq_28138 edxOut)
// Called from:
//      new_heap
//      sysmalloc
//      _dl_map_object_from_fd.constprop.8
//      _dl_protect_relro
//      _dl_relocate_object
//      _dl_make_stack_executable
//      _dl_cet_open_check
struct Eq_224 * mprotect(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_952 & ecxOut, union Eq_28138 & edxOut)
{
	Eq_28138 edx_12;
	struct Eq_224 * eax_14;
	gs->ptr0010();
	if (eax_14 >= (struct Eq_224 *) ~0x0FFE)
	{
		Eq_28138 edx_21;
		struct Eq_224 * eax_20 = __syscall_error(eax_14, gs, out edx_21);
		ecxOut.u0 = <invalid>;
		edxOut = edx_21;
		return eax_20;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_12;
		return eax_14;
	}
}

// 08061EE0: Register Eq_2 __madvise(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack ui32 dwArg08, Stack word32 dwArg0C, Register out (ptr32 Eq_29983) edxOut)
// Called from:
//      _int_free
//      malloc_trim
Eq_2 __madvise(struct Eq_9 * gs, Eq_2 dwArg04, ui32 dwArg08, word32 dwArg0C, struct Eq_29983 & edxOut)
{
	struct Eq_29983 * edx_12;
	struct Eq_224 * eax_14;
	gs->ptr0010();
	if (eax_14 >= (struct Eq_224 *) ~0x0FFE)
	{
		struct Eq_29983 * edx_21;
		__syscall_error(eax_14, gs, out edx_21);
		edxOut = edx_21;
		return <invalid>;
	}
	else
	{
		edxOut = edx_12;
		return <invalid>;
	}
}

// 08061F10: Register Eq_2 trecurse(Register Eq_2 eax, Register word32 ecx, Register (ptr32 Eq_45015) edx, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      trecurse
//      twalk
Eq_2 trecurse(Eq_2 eax, word32 ecx, union Eq_45015 * edx, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_2 eax_22;
	eax_22 = eax;
	if ((*((word32) eax + 4) & ~0x01) == 0x00)
	{
		eax_22 = *((word32) eax + 8);
		if (eax_22 == 0x00)
		{
			ptr32 ecx_34;
			ptr32 edx_35;
			Eq_2 eax_36;
			edx();
			ecxOut = ecx_34;
			edxOut = edx_35;
			return eax_36;
		}
	}
	word32 ecx_62;
	word32 edx_63;
	edx();
	ui32 eax_66 = *((word32) eax + 4);
	ptr32 esp_67 = fp - 0x0C;
	Eq_2 eax_68 = eax_66 & ~0x01;
	if ((eax_66 & ~0x01) != 0x00)
	{
		eax_68 = trecurse(eax_66 & ~0x01, ecx + 0x01, edx, out ecx_62, out edx_63);
		esp_67 = fp - 0x08;
	}
	struct Eq_45047 * esp_80 = esp_67 - 0x04;
	esp_80->dwFFFFFFFC = ecx;
	esp_80->dwFFFFFFF8 = 0x01;
	esp_80->tFFFFFFF4 = eax;
	word32 ecx_106;
	word32 edx_107;
	edx();
	Eq_2 eax_108 = *((word32) eax + 8);
	if (eax_108 != 0x00)
		eax_108 = trecurse(eax_108, ecx + 0x01, edx, out ecx_106, out edx_107);
	ptr32 ecx_127;
	ptr32 edx_128;
	Eq_2 eax_129;
	edx();
	ecxOut = ecx_127;
	edxOut = edx_128;
	return eax_129;
}

// 08061F90: Register Eq_2 tdestroy_recurse(Register Eq_2 eax, Register (ptr32 code) edx, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      tdestroy_recurse
//      tdestroy
Eq_2 tdestroy_recurse(Eq_2 eax, <anonymous> * edx, struct Eq_9 * gs, ptr32 & edxOut)
{
	Eq_2 eax_28;
	<anonymous> * edx_24;
	ui32 eax_17 = *((word32) eax + 4);
	if ((eax_17 & ~0x01) == 0x00)
	{
		eax_28 = *((word32) eax + 8);
		edx_24 = edx;
		if (eax_28 == 0x00)
			goto l08061FB1;
	}
	else
	{
		tdestroy_recurse(eax_17 & ~0x01, edx, gs, out edx_24);
		eax_28 = *((word32) eax + 8);
		if (eax_28 == 0x00)
		{
l08061FB1:
			edx();
			ptr32 edx_70;
			word32 ecx_105;
			Eq_2 eax_68 = free(gs, dwLoc20, eax, out ecx_105, out edx_70);
			edxOut = edx_70;
			return eax_68;
		}
	}
	eax_28 = tdestroy_recurse(eax_28, edx, gs, out edx_24);
	goto l08061FB1;
}

// 08061FF0: Register Eq_2 maybe_split_for_insert.isra.0(Register ui32 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack int32 dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C, Register out Eq_2 edxOut)
// Called from:
//      __tsearch
Eq_2 maybe_split_for_insert.isra.0(ui32 eax, Eq_2 ecx, Eq_2 edx, int32 dwArg04, int32 dwArg08, word32 dwArg0C, union Eq_2 & edxOut)
{
	ui32 edi_19 = (eax & ~0x01)->dw0004;
	struct Eq_45143 * ebx_20 = (eax & ~0x01)->ptr0008;
	if (dwArg0C != 0x01)
	{
		if (ebx_20 == null || ((edi_19 & ~0x01) == 0x00 || ((ebx_20->b0004 & 0x01) == 0x00 || ((edi_19 & ~0x01)->b0004 & 0x01) == 0x00)))
			goto l080620D4;
		(eax & ~0x01)->dw0004 = edi_19 | 0x01;
	}
	else
	{
		(eax & ~0x01)->dw0004 = edi_19 | 0x01;
		if (ebx_20 == null)
			goto l0806204A;
	}
	ebx_20->b0004 &= ~0x01;
l0806204A:
	if ((edi_19 & ~0x01) != 0x00)
		(edi_19 & ~0x01)->dw0004 = (edi_19 & ~0x01)->dw0004 & ~0x01;
	if (edx != 0x00)
	{
		ui32 edx_70 = *edx;
		edx = edx_70 & ~0x01;
		ui32 ebp_72 = (edx_70 & ~0x01)->dw0004;
		if ((ebp_72 & 0x01) != 0x00)
		{
			edx = (word32) (dwArg08 > 0x00);
			ui32 edx_84 = *ecx;
			if ((int8) (dwArg04 > 0x00) != (byte) edx)
			{
				(edx_70 & ~0x01)->dw0004 = ebp_72 | 0x01;
				(edx_84 & ~0x01)->dw0004 = (edx_84 & ~0x01)->dw0004 | 0x01;
				(eax & ~0x01)->dw0004 = (eax & ~0x01)->dw0004 & ~0x01;
				if (dwArg04 >= 0x00)
				{
					(edx_70 & ~0x01)->dw0008 = edi_19 & ~0x01;
					(eax & ~0x01)->dw0004 = edx_70 & ~0x01;
					(edx_84 & ~0x01)->dw0004 = ebx_20 | (edx_84 & ~0x01)->dw0004 & 0x01;
					(eax & ~0x01)->dw0008 = edx_84 & ~0x01 | ebx_20 & 0x01;
				}
				else
				{
					(edx_70 & ~0x01)->dw0004 = ebx_20 | (edx_70 & ~0x01)->dw0004 & 0x01;
					(eax & ~0x01)->dw0008 = edx_70 & ~0x01 | ebx_20 & 0x01;
					(edx_84 & ~0x01)->dw0008 = edi_19 & ~0x01;
					(eax & ~0x01)->dw0004 = edx_84 & ~0x01;
				}
				ui32 edx_172 = *ecx;
				*ecx = eax & ~0x01 | edx_172 & 0x01;
				edx = edx_172 & 0x01;
			}
			else
			{
				*ecx = edx_84 & 0x01 | edx_70 & ~0x01;
				(edx_70 & ~0x01)->dw0004 = ebp_72 & ~0x01;
				(edx_84 & ~0x01)->dw0004 = (edx_84 & ~0x01)->dw0004 | 0x01;
				if (dwArg04 >= 0x00)
				{
					ui32 eax_120 = (edx_70 & ~0x01)->dw0004;
					(edx_84 & ~0x01)->dw0008 = eax_120 & ~0x01;
					(edx_70 & ~0x01)->dw0004 = edx_84 & ~0x01 | eax_120 & 0x01;
					ecx = eax_120 & ~0x01;
				}
				else
				{
					(edx_84 & ~0x01)->dw0004 = (edx_70 & ~0x01)->dw0008 | 0x01;
					(edx_70 & ~0x01)->dw0008 = edx_84 & ~0x01;
				}
			}
		}
	}
l080620D4:
	edxOut = edx;
	return ecx;
}

// 08062150: Register Eq_2 __tsearch(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __dcigettext
//      find_derivation
//      add_alias2.isra.1.part.2
//      __gconv_find_shlib
//      __add_to_environ
Eq_2 __tsearch(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 ebp_119 = dwArg08;
	if (dwArg08 != 0x00)
	{
		Eq_2 dwLoc30_212;
		int32 dwLoc2C_214;
		Eq_2 ebx_134;
		int32 esi_123;
		Eq_2 edi_104;
		ui32 ebx_200 = *dwArg08;
		if ((ebx_200 & ~0x01) != 0x00)
		{
			(ebx_200 & ~0x01)->dw0004 = (ebx_200 & ~0x01)->dw0004 & ~0x01;
			Eq_2 ecx_202 = 0x00;
			int32 dwLoc24_213 = 0x00;
			dwLoc2C_214 = 0x00;
			dwLoc30_212.u0 = 0x00;
			while (true)
			{
				ebx_134 = ebx_200 & ~0x01;
				if (ebx_134 == 0x00)
					break;
				int32 eax_70;
				dwArg0C();
				esi_123 = eax_70;
				if (eax_70 == 0x00)
					goto l08062284;
				ui32 eax_103;
				word32 edx_310;
				maybe_split_for_insert.isra.0(*ebp_119, ecx_202, dwLoc30_212, dwLoc2C_214, dwLoc24_213, 0x00, out edx_310);
				if (eax_70 < 0x00)
				{
					edi_104 = (word32) ebx_134 + 4;
					eax_103 = (ui32) *((word32) ebx_134 + 4);
				}
				else
				{
					eax_103 = (ui32) *((word32) ebx_134 + 8);
					edi_104 = (word32) ebx_134 + 8;
				}
				if ((eax_103 & ~0x01) == 0x00)
					goto l08062230;
				ebx_200 = (ui32) *edi_104;
				dwLoc2C_214 = eax_70;
				ecx_202 = dwLoc30_212;
				dwLoc30_212 = ebp_119;
				ebp_119 = edi_104;
				dwLoc24_213 = dwLoc2C_214;
			}
			esi_123 = dwLoc2C_214;
		}
		else
		{
			dwLoc30_212.u0 = 0x00;
			esi_123 = 0x00;
		}
		dwLoc2C_214 = esi_123;
		edi_104 = ebp_119;
l08062230:
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edi_317;
		word32 edx_313;
		word32 esi_316;
		word32 ebp_315;
		word32 ebx_314;
		Eq_2 eax_128 = __libc_malloc(gs, stackArg0, 0x0C, out ecx, out edx_313, out ebx_314, out ebp_315, out esi_316, out edi_317);
		edx = eax_128;
		ebx_134 = eax_128;
		if (eax_128 != 0x00)
		{
			*edi_104 = *edi_104 & 0x01 | eax_128;
			*((word32) eax_128 + 4) = 0x01;
			*eax_128 = dwArg04;
			*((word32) eax_128 + 8) = 0x00;
			if (edi_104 != ebp_119)
				ecx = maybe_split_for_insert.isra.0(*edi_104, dwLoc30_212, ebp_119, esi_123, dwLoc2C_214, 0x01, out edx);
l08062284:
			ecxOut = ecx;
			edxOut = edx;
			return ebx_134;
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	return 0x00;
}

// 080622B0: Register ui32 __tfind(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __dcigettext
//      find_derivation
//      __gconv_compare_alias
//      __gconv_find_transform
//      add_module.isra.0
//      __gconv_read_conf
//      __gconv_find_shlib
//      __add_to_environ
ui32 __tfind(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	ui32 ebp_36;
	Eq_2 ebx_17 = dwArg08;
	if (dwArg08 != 0x00)
	{
		while (true)
		{
			ui32 ebx_25 = *ebx_17;
			if ((ebx_25 & ~0x01) == 0x00)
				break;
			int32 eax_42;
			word32 edx_43;
			dwArg0C();
			ebp_36 = ebx_25 & ~0x01;
			if (eax_42 == 0x00)
				return ebp_36;
			Eq_2 edx_49 = (ebx_25 & ~0x01) + 0x04;
			ebx_17 = (ebx_25 & ~0x01) + 0x08;
			if (eax_42 < 0x00)
				ebx_17 = edx_49;
		}
	}
	ebp_36 = 0x00;
	return ebp_36;
}

// 08062300: void __tdelete(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_45015) dwArg08, Stack (ptr32 code) dwArg0C)
void __tdelete(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_45015 * dwArg08, <anonymous> * dwArg0C)
{
	struct Eq_45546 * esp_19 = fp - 0x5C;
	Eq_2175 eax_27 = gs->t0014;
	if (fp - 0x5C != fp - 0x5C)
	{
		do
		{
			esp_19 -= 0x1000;
			esp_19->dw0FFC = esp_19->dw0FFC;
		} while (esp_19 != fp - 0x5C);
	}
	struct Eq_45556 * esp_142 = esp_19 - 0xB0;
	esp_142->dw00AC = esp_142->dw00AC;
	word32 dwLoc38_1101 = esp_142 + 0x0F & ~0x0F;
	if (dwArg08 != null)
	{
		ui32 ebx_58 = *dwArg08;
		if ((ebx_58 & ~0x01) != 0x00)
		{
			union Eq_2 * eax_63 = ebx_58 & ~0x01;
			ui32 esi_128 = 0x00;
			ui32 dwLoc30_1090 = 0x28;
			union Eq_45015 * edx_68 = dwArg08;
			do
			{
				struct Eq_45597 * esp_70 = esp_142 - (struct Eq_45598 *) 0x08;
				esp_70->tFFFFFFFC = *eax_63;
				esp_70->tFFFFFFF8 = dwArg04;
				int32 eax_89;
				word32 ecx_91;
				dwArg0C();
				esp_142 = esp_70 + 0x08;
				if (eax_89 == 0x00)
				{
					Eq_2 dwLoc48_955;
					ui32 eax_99 = *edx_68;
					ui32 ecx_104 = (eax_99 & ~0x01)->dw0004;
					struct Eq_45626 * edx_109 = ecx_104 & ~0x01;
					if ((eax_99 & ~0x01)->dw0008 != 0x00 && (ecx_104 & ~0x01) != 0x00)
					{
						union Eq_45015 * ecx_125 = edx_68;
						union Eq_45015 * edi_127 = (eax_99 & ~0x01) + 0x08;
						while (true)
						{
							Eq_2 edx_129 = esi_128 * 0x04;
							if (dwLoc30_1090 == esi_128)
							{
								ui32 v24_134 = dwLoc30_1090 + 0x14;
								ui32 eax_137 = v24_134 * 0x04 + 0x1B;
								dwLoc30_1090 = v24_134;
								struct Eq_45556 * ebx_144 = esp_142 - (eax_137 & ~0x0FFF);
								while (esp_142 != ebx_144)
								{
									esp_142 -= (struct Eq_45819 *) 0x1000;
									esp_142->dw0FFC = esp_142->dw0FFC;
								}
								if ((eax_137 & ~0x0F & 0x0FFF) != 0x00)
								{
									esp_142 -= eax_137 & ~0x0F & 0x0FFF;
									Mem171[esp_142 - 0x04 + ((eax_137 & ~0x0F) & 0x0FFF):word32] = Mem162[esp_142 - 0x04 + ((eax_137 & ~0x0F) & 0x0FFF):word32];
								}
								struct Eq_45828 * esp_176 = esp_142 - (struct Eq_45829 *) 0x04;
								esp_176->tFFFFFFFC = edx_129;
								esp_176->tFFFFFFF8 = dwLoc38_1101;
								Mem197[esp_176 + -0x0C:word32] = esp_142 + 0x0F & ~0x0F;
								esp_142 = esp_176 + 0x04;
								word32 ecx_1555;
								word32 edx_1556;
								dwLoc38_1101 = memcpy(esp_176->tFFFFFFF4, esp_176->tFFFFFFF8, esp_176->tFFFFFFFC, out ecx_1555, out edx_1556);
							}
							*((word32) dwLoc38_1101 + esi_128 * 0x04) = ecx_125;
							++esi_128;
							ui32 eax_228 = *edi_127;
							if (((eax_228 & ~0x01)->dw0004 & ~0x01) == 0x00)
								break;
							ecx_125 = edi_127;
							edi_127 = (eax_228 & ~0x01) + 0x04;
						}
						dwLoc48_955 = eax_228 & ~0x01;
						goto l080628BE;
					}
					dwLoc48_955 = eax_99 & ~0x01;
					if ((ecx_104 & ~0x01) == 0x00)
					{
l080628BE:
						edx_109 = (struct Eq_45626 *) *((word32) dwLoc48_955 + 8);
					}
					if (esi_128 == 0x00)
						*edx_68 = eax_99 & 0x01 | edx_109;
					else
					{
						ui32 eax_250 = *(dwLoc38_1101 - 0x04)[esi_128];
						if (dwLoc48_955 != (eax_250 & ~0x01)->t0008)
							(eax_250 & ~0x01)->dw0004 = (eax_250 & ~0x01)->dw0004 & 0x01 | edx_109;
						else
							(eax_250 & ~0x01)->ptr0008 = edx_109;
					}
					if ((eax_99 & ~0x01) != dwLoc48_955)
						*(eax_99 & ~0x01) = (word32) *dwLoc48_955;
					if ((*((word32) dwLoc48_955 + 4) & 0x01) == 0x00)
					{
						ui32 eax_301;
						if (esi_128 != 0x00)
						{
							ui32 esi_295 = esi_128;
							do
							{
								if (edx_109 != null)
								{
									eax_301 = edx_109->dw0004;
									if (((byte) eax_301 & 0x01) != 0x00)
										goto l0806273C;
								}
								ui32 eax_308 = esi_295 + 0x3FFFFFFF;
								union Eq_45015 * eax_314 = *((word32) dwLoc38_1101 + eax_308 * 0x04);
								ui32 eax_316 = *eax_314;
								ui32 eax_320 = (eax_316 & ~0x01)->dw0004;
								union Eq_45015 * dwLoc34_1006 = eax_314;
								struct Eq_45958 * edi_322 = eax_320 & ~0x01;
								if ((eax_320 & ~0x01) != edx_109)
								{
									ui32 edx_502 = (eax_320 & ~0x01)->dw0004;
									struct Eq_45998 * dwLoc30_1027 = edx_502 & ~0x01;
									struct Eq_46001 * ecx_506 = (eax_320 & ~0x01)->ptr0008;
									if (((byte) edx_502 & 0x01) != 0x00)
									{
										(eax_320 & ~0x01)->dw0004 = edx_502 & ~0x01;
										(eax_316 & ~0x01)->dw0004 = ecx_506 | 0x01;
										(eax_320 & ~0x01)->dw0008 = eax_316 & ~0x01;
										*eax_314 = eax_316 & 0x01 | eax_320 & ~0x01;
										union Eq_45015 * eax_524 = (eax_320 & ~0x01) + 0x08;
										*((word32) dwLoc38_1101 + (eax_308 * 0x04 + 4)) = eax_524;
										edx_502 = (ecx_506 & ~0x01)->dw0004;
										++esi_295;
										dwLoc34_1006 = eax_524;
										edi_322 = ecx_506 & ~0x01;
										ecx_506 = (ecx_506 & ~0x01)->ptr0008;
										dwLoc30_1027 = edx_502 & ~0x01;
									}
									ui32 esi_595;
									if (ecx_506 != null)
									{
										ui32 eax_542 = ecx_506->dw0004;
										if (((byte) eax_542 & 0x01) == 0x00)
											goto l080626D0;
										ui32 esi_599 = (eax_316 & ~0x01)->dw0004;
										esi_595 = esi_599 & 0x01;
										if (dwLoc30_1027 == null || (dwLoc30_1027->b0004 & 0x01) == 0x00)
										{
											ui32 eax_652 = eax_542 & ~0x01;
											if ((esi_599 & 0x01) != 0x00)
												eax_652 = eax_542 | 0x01;
											ecx_506->dw0004 = eax_652;
											(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & 0x01 | ecx_506->dw0008;
											ui32 eax_672 = ecx_506->dw0004;
											edi_322->dw0008 = eax_672 & ~0x01;
											ecx_506->dw0004 = eax_672 & 0x01 | edi_322;
											ui32 eax_682 = *dwLoc34_1006;
											ecx_506->dw0008 = eax_316 & ~0x01;
											*dwLoc34_1006 = eax_682 & 0x01 | ecx_506;
											(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
											goto l080626B5;
										}
									}
									else
									{
l080626D0:
										if (dwLoc30_1027 == null || (dwLoc30_1027->b0004 & 0x01) == 0x00)
										{
											edi_322->ptr0004 = edx_502 | 0x01;
											goto l0806272E;
										}
										esi_595 = (eax_316 & ~0x01)->dw0004 & 0x01;
									}
									struct Eq_45998 * edx_612 = edx_502 | 0x01;
									if (esi_595 == 0x00)
										edx_612 = dwLoc30_1027;
									edi_322->ptr0004 = edx_612;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
									struct Eq_45998 * eax_630 = edi_322->ptr0004;
									(eax_630 & ~0x01)->dw0004 = (eax_630 & ~0x01)->dw0004 & ~0x01;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & 0x01 | ecx_506;
									ui32 eax_642 = *dwLoc34_1006;
									edi_322->dw0008 = eax_316 & ~0x01;
									*dwLoc34_1006 = eax_642 & 0x01 | edi_322;
									goto l080626B5;
								}
								struct Eq_45976 * edi_326 = (eax_316 & ~0x01)->ptr0008;
								struct Eq_45981 * ecx_327 = edi_326->ptr0004;
								struct Eq_45981 * eax_329 = ecx_327 & ~0x01;
								if (((byte) ecx_327 & 0x01) != 0x00)
								{
									edi_326->ptr0004 = ecx_327 & ~0x01;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 | 0x01;
									struct Eq_45981 * eax_340 = edi_326->ptr0004;
									(eax_316 & ~0x01)->dw0008 = eax_340 & ~0x01;
									edi_326->ptr0004 = eax_340 & 0x01 | eax_316 & ~0x01;
									*eax_314 = eax_316 & 0x01 | edi_326;
									*((word32) dwLoc38_1101 + (eax_308 * 0x04 + 4)) = &edi_326->ptr0004;
									ecx_327 = (eax_340 & ~0x01)->ptr0004;
									++esi_295;
									dwLoc34_1006 = (union Eq_45015 *) &edi_326->ptr0004;
									edi_326 = eax_340 & ~0x01;
									eax_329 = ecx_327 & ~0x01;
								}
								ui32 dwLoc30_1011;
								struct Eq_46255 * dwLoc3C_1009;
								if (eax_329 != null)
								{
									ui32 edx_367 = eax_329->dw0004;
									if (((byte) edx_367 & 0x01) == 0x00)
										goto l08062818;
									ui32 ecx_402 = (eax_316 & ~0x01)->dw0004;
									struct Eq_46255 * esi_403 = edi_326->ptr0008;
									dwLoc30_1011 = ecx_402 & 0x01;
									if (esi_403 != null)
									{
										dwLoc3C_1009 = esi_403;
										if ((esi_403->t0004 & 0x01) != 0x00)
										{
l08062834:
											if (dwLoc30_1011 != 0x00)
												eax_329 = ecx_327 | 0x01;
											edi_326->ptr0004 = eax_329;
											(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
											dwLoc3C_1009->t0004 &= ~0x01;
											struct Eq_45981 * eax_440 = edi_326->ptr0004;
											(eax_316 & ~0x01)->dw0008 = eax_440 & ~0x01;
											edi_326->ptr0004 = eax_440 & 0x01 | eax_316 & ~0x01;
											*dwLoc34_1006 = edi_326 | *dwLoc34_1006 & 0x01;
											goto l080626B5;
										}
									}
									ui32 ecx_463;
									if ((ecx_402 & 0x01) != 0x00)
										ecx_463 = edx_367 | 0x01;
									else
										ecx_463 = edx_367 & ~0x01;
									eax_329->dw0004 = ecx_463;
									(eax_316 & ~0x01)->dw0008 = edx_367 & ~0x01;
									ui32 ecx_484 = *dwLoc34_1006;
									edi_326->ptr0004 = edi_326->ptr0004 & 0x01 | eax_329->ptr0008;
									ui32 edx_488 = eax_329->dw0004;
									eax_329->ptr0008 = edi_326;
									eax_329->dw0004 = edx_488 & 0x01 | eax_316 & ~0x01;
									*dwLoc34_1006 = eax_329 | ecx_484 & 0x01;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
									goto l080626B5;
								}
l08062818:
								struct Eq_46255 * edx_375 = edi_326->ptr0008;
								if (edx_375 != null)
								{
									dwLoc3C_1009 = edx_375;
									if ((edx_375->t0004 & 0x01) == 0x00)
										goto l08062880;
									dwLoc30_1011 = (eax_316 & ~0x01)->dw0004 & 0x01;
									goto l08062834;
								}
l08062880:
								edi_326->ptr0004 = ecx_327 | 0x01;
l0806272E:
								edx_109 = eax_316 & ~0x01;
								--esi_295;
							} while (esi_295 != 0x00);
							goto l08062739;
						}
						if (edx_109 != null)
						{
l08062739:
							eax_301 = edx_109->dw0004;
l0806273C:
							edx_109->dw0004 = eax_301 & ~0x01;
						}
					}
l080626B5:
					struct Eq_45916 * esp_719 = esp_142 - (struct Eq_45917 *) 0x0C;
					esp_719->tFFFFFFFC = dwLoc48_955;
					word32 edx_1558;
					word32 ecx_1557;
					free(gs, esp_719->tFFFFFFF8, esp_719->tFFFFFFFC, out ecx_1557, out edx_1558);
					goto l080623DC;
				}
				Eq_2 ecx_773 = esi_128 * 0x04;
				if (dwLoc30_1090 == esi_128)
				{
					ui32 v20_776 = dwLoc30_1090 + 0x14;
					ui32 eax_779 = v20_776 * 0x04 + 0x1B;
					dwLoc30_1090 = v20_776;
					word32 ebx_785 = esp_70 + 0x08 - (eax_779 & ~0x0FFF);
					if (esp_70 + 0x08 != ebx_785)
					{
						do
						{
							esp_142 -= (struct Eq_45710 *) 0x1000;
							esp_142->dw0FFC = esp_142->dw0FFC;
						} while (esp_142 != ebx_785);
					}
					if ((eax_779 & ~0x0F & 0x0FFF) != 0x00)
					{
						esp_142 -= eax_779 & ~0x0F & 0x0FFF;
						Mem809[esp_142 - 0x04 + ((eax_779 & ~0x0F) & 0x0FFF):word32] = Mem807[esp_142 - 0x04 + ((eax_779 & ~0x0F) & 0x0FFF):word32];
					}
					struct Eq_45719 * esp_814 = esp_142 - (struct Eq_45720 *) 0x04;
					esp_814->tFFFFFFFC = ecx_773;
					esp_814->tFFFFFFF8 = dwLoc38_1101;
					Mem836[esp_814 + -0x0C:word32] = esp_142 + 0x0F & ~0x0F;
					esp_142 = esp_814 + 0x04;
					word32 ecx_1553;
					word32 edx_1554;
					dwLoc38_1101 = memcpy(esp_814->tFFFFFFF4, esp_814->tFFFFFFF8, esp_814->tFFFFFFFC, out ecx_1553, out edx_1554);
				}
				ui32 ebx_855 = *edx_68;
				*((word32) dwLoc38_1101 + esi_128 * 0x04) = edx_68;
				++esi_128;
				if (eax_89 < 0x00)
				{
					ui32 eax_876 = (ebx_855 & ~0x01)->dw0004;
					edx_68 = (ebx_855 & ~0x01) + 0x04;
					eax_63 = eax_876 & ~0x01;
					if ((eax_876 & ~0x01) == 0x00)
						break;
					continue;
				}
				eax_63 = (ebx_855 & ~0x01)->ptr0008;
				edx_68 = (ebx_855 & ~0x01) + 0x08;
			} while (eax_63 != null);
		}
	}
l080623DC:
	if ((eax_27 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_1549;
	word32 edx_1550;
	__stack_chk_fail(out ecx_1549, out edx_1550);
	word32 ecx_1551;
	word32 edx_1552;
	twalk(dwArg04, dwArg08, out ecx_1551, out edx_1552);
}

// 08062920: Register Eq_2 twalk(Stack Eq_2 dwArg04, Stack (ptr32 Eq_45015) dwArg08, Register out ptr32 ecxOut, Register out (ptr32 Eq_45015) edxOut)
// Called from:
//      __tdelete
//      __gconv_find_shlib
//      __gconv_release_shlib
Eq_2 twalk(Eq_2 dwArg04, union Eq_45015 * dwArg08, ptr32 & ecxOut, union Eq_45015 & edxOut)
{
	if (dwArg04 == 0x00 || dwArg08 == null)
	{
		ecxOut = ecx;
		edxOut = dwArg08;
		return dwArg04;
	}
	else
	{
		ptr32 ecx_17;
		union Eq_45015 * edx_18;
		Eq_2 eax_16 = trecurse(dwArg04, 0x00, dwArg08, out ecx_17, out edx_18);
		ecxOut = ecx_17;
		edxOut = edx_18;
		return eax_16;
	}
}

// 08062940: void tdestroy(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 code) dwArg08)
// Called from:
//      __dl_iterate_phdr
//      free_mem
//      free_mem
//      free_mem
void tdestroy(struct Eq_9 * gs, Eq_2 dwArg04, <anonymous> * dwArg08)
{
	if (dwArg04 == 0x00)
		return;
	word32 edx_32;
	tdestroy_recurse(dwArg04, dwArg08, gs, out edx_32);
}

// 08062960: Register Eq_2 next_line(Register Eq_2 eax, Register (ptr32 Eq_2) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      get_nprocs
Eq_2 next_line(Eq_2 eax, union Eq_2 * ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebp_105 = *ecx;
	Eq_2 ebx_103 = *dwArg04;
	Eq_2 edi_30 = ebx_103 - ebp_105;
	Eq_2 eax_115 = __memchr(ebp_105, 0x0A, edi_30);
	if (eax_115 == 0x00)
	{
		if (ebp_105 == edx || ebx_103 != dwArg08)
			goto l0806299F;
		word32 edx_384;
		memmove(edx, ebp_105, edi_30, out edx_384);
		Mem76[dwArg04 + 0x00:word32] = Mem61[dwArg04 + 0x00:word32] + edx - Mem61[ecx + 0x00:word32];
		*ecx = (union Eq_2 *) edx;
		Eq_2 eax_78 = *dwArg04;
		word32 ecx_385;
		Eq_2 eax_89 = __read_nocancel(gs, eax, eax_78, dwArg08 - eax_78, out ecx_385);
		if (eax_89 < 0x00)
			return 0x00;
		word32 eax_102 = eax_89 + Mem87[dwArg04 + 0x00:word32];
		*dwArg04 = eax_102;
		ebp_105 = *ecx;
		ebx_103 = eax_102;
		eax_115 = __memchr(ebp_105, 0x0A, eax_102 - ebp_105);
		if (eax_115 == 0x00)
		{
			if (eax_102 == dwArg08)
			{
				ui32 eax_131 = dwArg08 - edx;
				int32 eax_135 = eax_131 * 0x03 + 0x03;
				if (eax_131 * 0x03 >= 0x00)
					eax_135 = eax_131 * 0x03;
				Eq_2 ebp_141 = (word32) edx + (eax_135 >> 0x02);
				Eq_2 eax_145 = dwArg08 - ebp_141;
				do
				{
					*dwArg04 = ebp_141;
					word32 ecx_386;
					Eq_2 eax_163 = __read_nocancel(gs, eax, ebp_141, eax_145, out ecx_386);
					if (eax_163 < 0x00)
						return 0x00;
					Eq_2 edi_175 = *dwArg04;
					eax_115 = __memchr(edi_175, 0x0A, eax_163);
					*edi_175 = 0x0A;
					word32 edx_194 = Mem191[dwArg04 + 0x00:word32] + eax_163;
					*dwArg04 = edx_194;
					if (eax_115 != 0x00)
					{
						ebp_105 = *ecx;
						goto l0806299C;
					}
				} while (edx_194 == dwArg08);
				ebx_103 = edx_194;
				ebp_105 = *ecx;
			}
l0806299F:
			*ecx = (union Eq_2 *) ebx_103;
			Eq_2 eax_217 = *dwArg04;
			if (eax_217 < ebx_103)
			{
				word32 edx_383;
				word32 ecx_382;
				__assert_fail(out ecx_382, out edx_383);
			}
			else
			{
				if (eax_217 == ebp_105)
					return 0x00;
				return ebp_105;
			}
		}
	}
l0806299C:
	ebx_103 = (word32) eax_115 + 1;
	goto l0806299F;
}

// 08062B00: Register Eq_46659 sysinfo_mempages(Register Eq_46659 eax, Register Eq_46660 edx)
// Called from:
//      next_line
//      __get_phys_pages
//      __get_avphys_pages
Eq_46659 sysinfo_mempages(Eq_46659 eax, Eq_46660 edx)
{
	Eq_2 eax_22 = __getpagesize();
	Eq_46660 ebx_19 = edx;
	Eq_2 ecx_26 = eax_22;
	if (eax_22 > 0x01 && edx > 0x01)
	{
		do
		{
			ebx_19 >>= 0x01;
			ecx_26 >>= 0x01;
		} while (ebx_19 > 0x01 && ecx_26 > 0x01);
	}
	Eq_46659 eax_44 = eax *s ebx_19;
	if (ecx_26 > 0x01)
	{
		do
		{
			ecx_26 >>= 0x01;
			eax_44 >>= 0x01;
		} while (ecx_26 != 0x01);
	}
	return eax_44;
}

// 08062B50: Register Eq_2 get_nprocs(Register (ptr32 Eq_9) gs)
// Called from:
//      arena_get2.part.5
//      get_nprocs_conf
Eq_2 get_nprocs(struct Eq_9 * gs)
{
	Eq_2 ebx_136;
	Eq_2175 eax_22 = gs->t0014;
	word32 eax_29 = time(gs, 0x00);
	if (eax_29 == timestamp.11438)
	{
		ebx_136 = cached_result.11437;
		if (ebx_136 >= 0x00)
			goto l08062D99;
	}
	ui32 eax_59 = (0x00 - (word32) (__libc_alloca_cutoff(gs, 0x2000) < 0x01) & ~0x1DFF) + 0x2000;
	struct Eq_46720 * esp_53 = fp - 0x4C;
	struct Eq_46720 * esi_63 = fp - 0x4C - (eax_59 + 0x10 & ~0x0FFF);
	if (fp - 0x4C != esi_63)
	{
		do
		{
			esp_53 -= 0x1000;
			esp_53->dw0FFC = esp_53->dw0FFC;
		} while (esp_53 != esi_63);
	}
	int32 edx_78 = eax_59 + 0x10 & 0x0FFF;
	if (edx_78 != 0x00)
	{
		esp_53 -= edx_78;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_53 - 0x04)[edx_78 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_53 - 0x04)[edx_78 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_46757 * esp_91 = esp_53 - 0x08;
	esp_91->tFFFFFFFC.u0 = 0x00080000;
	Eq_46764 edx_90 = (char *) esp_53 + 0x0F;
	esp_91->tFFFFFFF8.u0 = 0x080A40E4;
	Eq_2 eax_99 = eax_59 + (edx_90 & ~0x0F);
	word32 ecx_835;
	word32 edx_836;
	Eq_2 eax_117 = __open_nocancel(gs, esp_91->tFFFFFFF8, esp_91->tFFFFFFFC, esp_91->t0000, out ecx_835, out edx_836);
	if (eax_117 == ~0x00)
	{
l08062CE9:
		struct Eq_46793 * esp_282 = esp_53 - 0x08;
		esp_282->tFFFFFFFC.u0 = 0x00080000;
		esp_282->tFFFFFFF8.u0 = 0x080A4119;
		word32 edx_838;
		word32 ecx_837;
		Eq_2 eax_293 = __open_nocancel(gs, esp_282->tFFFFFFF8, esp_282->tFFFFFFFC, esp_282->t0000, out ecx_837, out edx_838);
		Eq_2 dwLoc3C_612 = eax_293;
		if (eax_293 != ~0x00)
		{
			ebx_136.u0 = 0x00;
			while (true)
			{
				struct Eq_47011 * esp_399 = esp_53 - 0x08;
				esp_399->tFFFFFFFC = eax_99;
				esp_399->ptrFFFFFFF8 = fp - 0x28;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 eax_417 = next_line(eax_293, fp - 44, edx_90 & ~0x0F, gs, stackArg4, stackArg8);
				bool v36_563 = eax_417 > 0x00;
				if (eax_417 == 0x00)
					break;
				cu8 * edi_425 = &g_b80A4150;
				word32 ecx_426 = 0x03;
				Eq_2 esi_427 = eax_417;
				while (ecx_426 != 0x00)
				{
					v36_563 = *esi_859 > *edi_860;
					esi_427 = (word32) esi_859 + 1;
					edi_425 = edi_860 + 1;
					--ecx_426;
					esi_859 = esi_427;
					edi_860 = edi_425;
					if (*esi_859 == *edi_860)
						break;
				}
				if ((int8) v36_563 - (byte) (*esi_859 < *edi_860) != 0x00)
					break;
				ebx_136 = (byte) ebx_136.u0 + (word32) ((int32) (*((word32) eax_417 + 3)) < 0x3A);
			}
		}
		else
		{
			esp_282->tFFFFFFFC.u0 = 0x00080000;
			esp_282->tFFFFFFF8.u0 = 0x080A4124;
			word32 edx_851;
			word32 ecx_850;
			Eq_2 eax_313 = __open_nocancel(gs, esp_282->tFFFFFFF8, esp_282->tFFFFFFFC, esp_282->t0000, out ecx_850, out edx_851);
			ebx_136.u0 = 0x02;
			dwLoc3C_612 = eax_313;
			if (eax_313 == ~0x00)
				goto l08062D87;
			ebx_136.u0 = 0x00;
			while (true)
			{
				struct Eq_47036 * esp_335 = esp_53 - 0x08;
				esp_335->tFFFFFFFC = eax_99;
				esp_335->ptrFFFFFFF8 = fp - 0x28;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 eax_353 = next_line(eax_313, fp - 44, edx_90 & ~0x0F, gs, stackArg4, stackArg8);
				Eq_2 esi_358 = eax_353;
				bool v32_559 = eax_353 > 0x00;
				if (eax_353 == 0x00)
					break;
				cu8 * edi_362 = &g_b80A4132;
				word32 ecx_363 = 0x09;
				while (ecx_363 != 0x00)
				{
					v32_559 = *esi_857 > *edi_858;
					esi_358 = (word32) esi_857 + 1;
					edi_362 = edi_858 + 1;
					--ecx_363;
					esi_857 = esi_358;
					edi_858 = edi_362;
					if (*esi_857 == *edi_858)
						break;
				}
				ebx_136 = (word32) ebx_136 + (word32) ((int32) ((int8) v32_559 - (byte) (*esi_857 < *edi_858)) < 0x01);
			}
		}
		struct Eq_47066 * esp_462 = esp_53 - 0x0C;
		esp_462->tFFFFFFFC = dwLoc3C_612;
		word32 edx_856;
		__close_nocancel(gs, esp_462->tFFFFFFFC, out edx_856);
l08062D87:
		cached_result.11437 = ebx_136;
		timestamp.11438 = eax_29;
l08062D99:
		if ((eax_22 ^ gs->t0014) == 0x00)
			return ebx_136;
		word32 ecx_848;
		word32 edx_849;
		__stack_chk_fail(out ecx_848, out edx_849);
		return get_nprocs_conf(gs);
	}
	esp_91->tFFFFFFFC = eax_99;
	esp_91->tFFFFFFF8 = fp - 0x28;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	Eq_2 eax_147 = next_line(eax, fp - 44, edx_90 & ~0x0F, gs, stackArg4, stackArg8);
	ebx_136.u0 = 0x00;
	Eq_2 edi_152 = eax_147;
	if (eax_147 != 0x00)
	{
l08062C60:
		struct Eq_46866 * esp_163 = esp_53 - 0x04;
		esp_163->tFFFFFFFC.u0 = 0x0A;
		esp_163->tFFFFFFF8 = fp - 0x24;
		esp_163->tFFFFFFF4 = edi_152;
		word32 edx_847;
		word32 ecx_846;
		Eq_9843 eax_175 = __strtoul(gs, esp_163->tFFFFFFF4, esp_163->tFFFFFFF8, esp_163->tFFFFFFFC, out ecx_846, out edx_847);
		if (dwLoc24 != edi_152)
		{
			Eq_9843 eax_199;
			eax_199 = eax_175;
			if (*dwLoc24 != 0x2D)
			{
l08062C7F:
				Eq_2 esi_235 = (word32) eax_199 + 1 + (ebx_136 - eax_175);
				Eq_2 edx_237 = dwLoc24;
				ebx_136 = esi_235;
				if (dwLoc24 < eax_99)
				{
					Eq_150869 edi_242[] = gs->ptrFFFFFFF8;
					do
					{
						if ((edi_242[(int32) *edx_237].b0001 & 0x20) == 0x00)
						{
							edi_152 = edx_237;
							goto l08062C60;
						}
						edx_237 = (word32) edx_237 + 1;
					} while (edx_237 != eax_99);
				}
				esp_163->tFFFFFFF4 = eax_117;
				word32 edx_845;
				__close_nocancel(gs, esp_163->tFFFFFFF4, out edx_845);
				if (esi_235 > 0x00)
					goto l08062D87;
				goto l08062CE9;
			}
			esp_163->tFFFFFFFC.u0 = 0x0A;
			esp_163->tFFFFFFF8 = fp - 0x24;
			esp_163->tFFFFFFF4 = (word32) dwLoc24 + 1;
			word32 ecx_843;
			word32 edx_844;
			eax_199 = __strtoul(gs, esp_163->tFFFFFFF4, esp_163->tFFFFFFF8, esp_163->tFFFFFFFC, out ecx_843, out edx_844);
			if (dwLoc24 != (word32) dwLoc24 + 1)
				goto l08062C7F;
		}
	}
	struct Eq_46844 * esp_211 = esp_53 - 0x0C;
	esp_211->tFFFFFFFC = eax_117;
	word32 edx_842;
	__close_nocancel(gs, esp_211->tFFFFFFFC, out edx_842);
	goto l08062CE9;
}

// 08062E90: Register int32 get_nprocs_conf(Register (ptr32 Eq_9) gs)
// Called from:
//      get_nprocs
int32 get_nprocs_conf(struct Eq_9 * gs)
{
	Eq_2175 eax_21 = gs->t0014;
	int32 ebp_125 = 0x00;
	Eq_2 eax_29 = opendir(gs, 134889788);
	if (eax_29 != 0x00)
	{
l08062EE0:
		word32 ecx_297;
		struct Eq_224 * eax_135 = readdir64(gs, eax_29, out ecx_297);
		while (eax_135 != null)
		{
			bool v21_210 = eax_135->b0012 > 0x04;
			if (eax_135->b0012 != 0x04)
				goto l08062EE0;
			cu8 * edi_70 = &g_b80A4150;
			cu8 * esi_71 = &eax_135->b0012 + 1;
			word32 ecx_72 = 0x03;
			while (ecx_72 != 0x00)
			{
				v21_210 = *esi_303 > *edi_304;
				esi_71 = esi_303 + 1;
				edi_70 = edi_304 + 1;
				--ecx_72;
				esi_303 = esi_71;
				edi_304 = edi_70;
				if (*esi_303 == *edi_304)
					break;
			}
			if ((int8) v21_210 - (byte) (eax_135->b0012 < 0x04) != 0x00)
				goto l08062EE0;
			Eq_2 esi_98 = &eax_135->b0012 + 4;
			word32 edx_299;
			word32 ecx_298;
			if (__strtoul(gs, esi_98, fp - 0x24, 0x0A, out ecx_298, out edx_299) == ~0x00 || esi_98 == dwLoc24)
				goto l08062EE0;
			ebp_125 += (word32) (*dwLoc24 < 0x01);
			word32 ecx_300;
			eax_135 = readdir64(gs, eax_29, out ecx_300);
		}
		closedir(gs, eax_29);
	}
	else
		ebp_125 = get_nprocs(gs);
	if ((eax_21 ^ gs->t0014) == 0x00)
		return ebp_125;
	word32 edx_302;
	word32 ecx_301;
	__stack_chk_fail(out ecx_301, out edx_302);
	return __get_phys_pages(eax_29, gs);
}

// 08062F90: Register Eq_46659 __get_phys_pages(Register Eq_2 ebx, Register (ptr32 Eq_9) gs)
// Called from:
//      get_nprocs_conf
Eq_46659 __get_phys_pages(Eq_2 ebx, struct Eq_9 * gs)
{
	Eq_2175 eax_7 = gs->t0014;
	Eq_2 ebx_17 = __sysinfo(ebx, gs, fp - 0x50);
	if ((eax_7 ^ gs->t0014) == 0x00)
		return sysinfo_mempages(eax, edx);
	word32 edx_68;
	word32 ecx_67;
	__stack_chk_fail(out ecx_67, out edx_68);
	return __get_avphys_pages(ebx_17, gs);
}

// 08062FE0: Register Eq_46659 __get_avphys_pages(Register Eq_2 ebx, Register (ptr32 Eq_9) gs)
// Called from:
//      __get_phys_pages
Eq_46659 __get_avphys_pages(Eq_2 ebx, struct Eq_9 * gs)
{
	Eq_2175 eax_7 = gs->t0014;
	__sysinfo(ebx, gs, fp - 0x50);
	if ((eax_7 ^ gs->t0014) == 0x00)
		return sysinfo_mempages(eax, edx);
	word32 edx_63;
	word32 ecx_62;
	__stack_chk_fail(out ecx_62, out edx_63);
	return __getclktck();
}

// 08063030: Register word32 __getclktck()
// Called from:
//      __get_avphys_pages
word32 __getclktck()
{
	word32 eax_13 = _dl_clktck;
	if (eax_13 == 0x00)
		eax_13 = 100;
	return eax_13;
}

// 08063060: void __init_misc(Stack (ptr32 Eq_2) dwArg08)
// Called from:
//      __libc_init_first
void __init_misc(union Eq_2 * dwArg08)
{
	if (dwArg08 != null)
	{
		Eq_2 ebx_19 = *dwArg08;
		if (ebx_19 != 0x00)
		{
			struct Eq_47366 * eax_29 = rindex(ebx_19, 0x2F);
			if (eax_29 != null)
				ebx_19 = &eax_29->bFFFFFFFE + 3;
			program_invocation_short_name = ebx_19;
			__progname_full = *dwArg08;
		}
	}
}

// 080630B0: Register (ptr32 Eq_224) __mremap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack word32 dwArg14, Register out ptr32 edxOut)
// Called from:
//      mmap_remap_check
//      mremap_chunk
struct Eq_224 * __mremap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, word32 dwArg14, ptr32 & edxOut)
{
	ptr32 edx_20;
	struct Eq_224 * eax_22;
	gs->ptr0010();
	if (eax_22 >= (struct Eq_224 *) ~0x0FFE)
	{
		ptr32 edx_33;
		struct Eq_224 * eax_32 = __syscall_error(eax_22, gs, out edx_33);
		edxOut = edx_33;
		return eax_32;
	}
	else
	{
		edxOut = edx_20;
		return eax_22;
	}
}

// 080630F0: Register Eq_2 __sysinfo(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04)
// Called from:
//      __get_phys_pages
//      __get_avphys_pages
Eq_2 __sysinfo(Eq_2 ebx, struct Eq_9 * gs, ptr32 dwArg04)
{
	struct Eq_224 * eax_11;
	gs->ptr0010();
	if (eax_11 < (struct Eq_224 *) ~0x0FFE)
		return;
	word32 edx_35;
	__syscall_error(eax_11, gs, out edx_35);
	return;
}

// 08063120: void __chk_fail()
// Called from:
//      __memmove_chk
//      __mempcpy_chk
//      __memcpy_chk
void __chk_fail()
{
	__fortify_fail();
}

// 08063140: Register word32 __stack_chk_fail(Register out Eq_952 ecxOut, Register out Eq_952 edxOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      read_alias_file
//      __gettextparse
//      __gettext_extract_plural
//      qsort_r
//      locked_vfxprintf
//      adjust_wide_data
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_underflow_mmap
//      _IO_wdo_write
//      vasprintf
//      __libc_message
//      mmap_remap_check
//      decide_maybe_mmap
//      _IO_new_file_seekoff
//      _IO_file_fopen
//      _IO_un_link.part.2
//      _IO_link_in
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      ptmalloc_init
//      _int_free
//      realloc_check
//      mallinfo
//      __malloc_stats
//      malloc_info
//      two_way_long_needle
//      strstr
//      __wcsmbs_getfct
//      __wcsmbs_load_conv
//      __mbsrtowcs_l
//      __sysconf_check_spec
//      __sysconf
//      __get_child_max
//      lseek64
//      getcwd
//      __fcntl64_nocancel_adjusted
//      getdtablesize
//      __tdelete
//      get_nprocs
//      get_nprocs_conf
//      __get_phys_pages
//      __get_avphys_pages
//      __chk_fail
//      __gconv_open
//      find_derivation
//      __gconv_compare_alias
//      __gconv_find_transform
//      add_module.isra.0
//      __gconv_get_path
//      __gconv_read_conf
//      __gconv_transform_internal_ucs4
//      __gconv_transform_ucs4_internal
//      __gconv_transform_internal_ucs4le
//      __gconv_transform_ucs4le_internal
//      __gconv_transform_ascii_internal
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_utf8_internal
//      __gconv_transform_ucs2_internal
//      __gconv_transform_internal_ucs2
//      __gconv_transform_ucs2reverse_internal
//      __gconv_transform_internal_ucs2reverse
//      __gconv_transliterate
//      find_module
//      __gconv_load_cache
//      __gconv_compare_alias_cache
//      __gconv_lookup_cache
//      setlocale
//      _nl_find_locale
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __setfpucw
//      raise
//      __libc_sigaction
//      sigprocmask
//      _quicksort
//      __add_to_environ
//      _i18n_number_rewrite
//      printf_positional
//      vfprintf
//      buffered_vfprintf
//      _i18n_number_rewrite
//      __printf_fp_l
//      __printf_fphex
//      _i18n_number_rewrite
//      printf_positional
//      __vfwprintf
//      buffered_vfprintf
//      _IO_file_doallocate
//      _IO_padn
//      _IO_wpadn
//      do_in
//      do_unshift
//      do_out
//      do_length
//      _IO_fwide
//      strerror_r
//      two_way_long_needle
//      __memmem
//      __cache_sysconf
//      btowc
//      wcrtomb
//      __wcsrtombs
//      opendir
//      __getdents
//      __fdopendir
//      __libc_lseek
//      __isatty
//      tcgetattr
//      __readonly_area
//      dlerror_run
//      __libc_dlsym
//      __libc_dlvsym
//      do_dlsym_private
//      __libc_dlsym_private
//      __libc_dlopen_mode
//      _dl_catch_exception
//      _dl_catch_error
//      __mpn_mul
//      __mpn_mul_n
//      _itoa
//      _fitoa_word
//      _fitoa
//      _itowa
//      __dlerror
//      __dlinfo
//      __dlmopen
//      profil
//      __dlopen
//      __dlsym
//      __dlvsym
//      _dl_vsym
//      _dl_sym
//      __dl_iterate_phdr
word32 __stack_chk_fail(union Eq_952 & ecxOut, union Eq_952 & edxOut)
{
	__fortify_fail_abort(0x00);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_43241 stackArg4 = <invalid>;
	word32 eax_20 = __fortify_fail_abort(stackArg4);
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_20;
}

// 08063170: Register word32 __fortify_fail_abort(Stack Eq_43241 bArg04)
// Called from:
//      __stack_chk_fail
//      __fortify_fail
word32 __fortify_fail_abort(Eq_43241 bArg04)
{
	word32 esi_23 = (word32) bArg04;
	while (true)
	{
		ui32 edx_41;
		if ((byte) esi_23 == 0x00)
			edx_41 = 0x01;
		else
		{
			*__libc_argv == 0x00;
			edx_41 = 0x03;
		}
		__libc_message(gs, edx_41, 0x080A418F);
	}
}

// 080631E0: void __fortify_fail()
// Called from:
//      __chk_fail
void __fortify_fail()
{
	__fortify_fail_abort(0x01);
}

// 08063200: void _dl_debug_state()
// Called from:
//      __fortify_fail
//      lose
//      _dl_map_object_from_fd.constprop.8
//      dl_open_worker
//      _dl_close_worker
void _dl_debug_state()
{
}

// 08063210: Register (ptr32 Eq_47441) _dl_debug_initialize(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __libc_start_main
//      _dl_map_object_from_fd.constprop.8
//      _dl_open
//      dl_open_worker
//      _dl_close_worker
struct Eq_47441 * _dl_debug_initialize(Eq_2 dwArg04, Eq_2 dwArg08)
{
	struct Eq_47441 * eax_17;
	Eq_2 ebx_13 = dwArg04;
	if (dwArg08 != 0x00)
	{
		eax_17 = dwArg08 *s 0x4C + 0x080CEA38;
		if (eax_17->dw0004 != 0x00)
		{
l08063241:
			if (dwArg04 == 0x00)
				return eax_17;
			eax_17->dw0000 = 0x01;
l0806324B:
			eax_17->t0010 = ebx_13;
			eax_17->dw0004 = *((char *) &g_t80CEA00 + dwArg08 * 0x4C);
			eax_17->ptr0008 = 0x08063200;
			return eax_17;
		}
	}
	else
	{
		eax_17 = &g_t80CFEE8;
		if (g_dw80CFEEC != 0x00)
			goto l08063241;
	}
	eax_17->dw0000 = 0x01;
	if (dwArg04 == 0x00)
		ebx_13 = g_t80CFEF8;
	goto l0806324B;
}

// 080632A0: Register Eq_47490 do_tunable_update_val(Register (ptr32 Eq_47491) eax, Register Eq_2 edx, Register out Eq_2 edxOut)
// Called from:
//      tunable_initialize
//      __tunable_set_val
Eq_47490 do_tunable_update_val(struct Eq_47491 * eax, Eq_2 edx, union Eq_2 & edxOut)
{
	Eq_47490 ecx_6 = eax->t0004;
	if (ecx_6 == 0x03)
	{
		eax->t0018 = edx;
		edxOut = edx;
		return ecx_6;
	}
	Eq_47490 ecx_24;
	Eq_2 ebx_14 = *edx;
	Eq_2 edx_15 = *((word32) edx + 4);
	if (ecx_6 != 0x01 && ecx_6 == 0x00)
	{
		ecx_24 = edx_15 - eax->dw000C - (word32) (ebx_14 < eax->t0008);
		if (ecx_24 < 0x00)
			goto l080632D5;
		ecx_24 = eax->dw0014 - edx_15 - (word32) (eax->t0010 < ebx_14);
		if (ecx_24 >= 0x00)
		{
l080632CB:
			eax->t0018 = ebx_14;
			eax->t001C = edx_15;
			eax->b0020 = 0x01;
			goto l080632D5;
		}
	}
	else
	{
		ecx_24 = edx_15 - eax->dw000C - (word32) (ebx_14 < eax->t0008);
		if (ecx_24 < 0x00)
			goto l080632D5;
		ecx_24 = eax->dw0014 - edx_15 - (word32) (eax->t0010 < ebx_14);
		if (ecx_24 >= 0x00)
			goto l080632CB;
	}
l080632D5:
	edxOut = edx_15;
	return ecx_24;
}

// 08063310: Register word32 tunable_initialize(Register (ptr32 Eq_47491) eax, Register Eq_2 edx, Register out ptr32 edxOut)
// Called from:
//      __tunables_init
word32 tunable_initialize(struct Eq_47491 * eax, Eq_2 edx, ptr32 & edxOut)
{
	if (eax->t0004 != 0x03)
	{
		_dl_strtoul(edx, null);
		ptr32 edx_33;
		word32 ecx_32 = do_tunable_update_val(eax, fp - 0x14, out edx_33);
		edxOut = edx_33;
		return ecx_32;
	}
	else
	{
		eax->b0020 = 0x01;
		ptr32 edx_45;
		word32 ecx_44 = do_tunable_update_val(eax, edx, out edx_45);
		edxOut = edx_45;
		return ecx_44;
	}
}

// 08063360: void __tunable_set_val(Stack int32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _dl_important_hwcaps
void __tunable_set_val(int32 dwArg04, Eq_2 dwArg08)
{
	struct Eq_47491 * eax_9 = 0x080CE6C0 + dwArg04 *s 44;
	word32 edx_19;
	do_tunable_update_val(eax_9, dwArg08, out edx_19);
}

// 08063390: Register word32 __tunables_init(Register (ptr16 Eq_47619) gs, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
word32 __tunables_init(struct Eq_47619 * gs, ptr32 & edxOut)
{
	if (*(union Eq_4846 *) 0x080CDDAC != 0x00)
	{
		__syscall(0x80);
		g_dw80CE2A8 = 0x02;
	}
}

// 080638D0: void __tunable_get_val(Stack int32 dwArg04, Stack (ptr32 Eq_28508) dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      __libc_start_main
//      ptmalloc_init
//      _dl_important_hwcaps
//      _dl_load_cache_lookup
void __tunable_get_val(int32 dwArg04, struct Eq_28508 * dwArg08, <anonymous> * dwArg0C)
{
	struct Eq_47631 * edi_22 = 0x080CE6C0 + dwArg04 *s 44;
	word32 edx_23 = edi_22->dw0004;
	if (edx_23 != 0x01)
	{
		if (edx_23 != 0x00)
			dwArg08->dw0000 = edi_22->dw0018;
		else
			dwArg08->dw0000 = edi_22->dw0018;
	}
	else
	{
		word32 edi_27 = edi_22->dw0018;
		dwArg08->dw0004 = edi_22->dw001C;
		dwArg08->dw0000 = edi_27;
	}
	if ((dwArg04 *s 44 - 0x06A0)->b80CE000 == 0x00 || dwArg0C == null)
		return;
	dwArg0C();
}

// 08063960: void _dl_sysinfo_int80()
void _dl_sysinfo_int80()
{
	__syscall(0x80);
}

// 08063970: Register word32 _dl_aux_init(Stack (ptr32 Eq_47684) dwArg04, Register out (ptr32 code) ediOut)
// Called from:
//      __libc_start_main
word32 _dl_aux_init(struct Eq_47684 * dwArg04, <anonymous> & ediOut)
{
	_dl_auxv = dwArg04;
	word32 eax_104 = dwArg04->dw0000;
	if (eax_104 != 0x00)
	{
		struct Eq_47684 * edx_101 = dwArg04;
		do
		{
			uint32 eax_98 = eax_104 - 0x03;
			if (eax_98 <= 0x1E)
			{
				<anonymous> * edi_286 = g_a80A4500[eax_98 * 0x04] + 0x080CE000;
				edi_286();
				ediOut = edi_286;
				return 0x00;
			}
			++edx_101;
			eax_104 = edx_101->dw0000;
		} while (eax_104 != 0x00);
	}
	ediOut = edi;
	return ebp;
}

// 08063E50: Register Eq_2 _dl_non_dynamic_init(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_init_first
Eq_2 _dl_non_dynamic_init(struct Eq_9 * gs)
{
	word32 esi_1854;
	struct Eq_47719 * ebx_22;
	ebx_22->t0C0C = _dl_get_origin(gs, dwLoc3C, out ebx_22, out esi_1854);
	ebx_22->t0BB4 = _dl_phdr;
	ebx_22->t0BBC = _dl_phnum;
	Eq_2 eax_47 = getenv((char *) ebx_22 - 169953);
	uint32 edx_55 = 0x00;
	if (eax_47 != 0x00)
		edx_55 = (uint32) (int8) (*eax_47 != 0x00);
	_dl_verbose = edx_55;
	if (_dl_sysinfo_dso != 0x00)
	{
		Eq_2 dwLoc48_1236 = 0x00;
		Eq_2 eax_94 = _dl_new_object(gs, (char *) ebx_22 - 105991, (char *) ebx_22 - 105991, 0x01, 0x00, 0x00);
		Eq_2 esp_100 = fp - 0x3C;
		if (eax_94 != 0x00)
		{
			Eq_2 esp_163;
			Eq_2 ebp_105 = _dl_sysinfo_dso;
			word32 edi_108 = (word32) *((word32) ebp_105 + 44);
			word32 eax_109 = Mem90[ebp_105 + 0x1C:word32] + ebp_105;
			((word32) eax_94 + 348)->u5 = (word16) edi_108;
			*((word32) eax_94 + 340) = eax_109;
			word32 ecx_106 = 0x00;
			if (edi_108 != 0x00)
			{
				do
				{
					word32 edx_118 = eax_109->dw0000;
					if (edx_118 != 0x02)
					{
						if (edx_118 != 0x01)
						{
							if (edx_118 == 0x07)
							{
								word32 edx_1873;
								word32 ecx_1872;
								__assert_fail(out ecx_1872, out edx_1873);
								esp_163.u0 = <invalid>;
								goto l080645B5;
							}
						}
						else
						{
							Eq_47845 edx_125 = eax_109->dw0008;
							if (*eax_94 == 0x00)
								*eax_94 = edx_125;
							Eq_2 edx_131 = (word32) edx_125 + eax_109->dw0014;
							if (edx_131 >= *((word32) eax_94 + 436))
								*((word32) eax_94 + 436) = edx_131;
							if ((eax_109->b0018 & 0x01) != 0x00 && edx_131 >= *((word32) eax_94 + 440))
								*((word32) eax_94 + 440) = edx_131;
						}
						++ecx_106;
						++eax_109;
						if (ecx_106 != edi_108)
							continue;
						break;
					}
					*((word32) eax_94 + 8) = eax_109->dw0008;
					++eax_109;
					((word32) eax_94 + 350)->u5 = (word16) (eax_109->dwFFFFFFF4 >> 0x03);
					++ecx_106;
				} while (ecx_106 != edi_108);
			}
			*((word32) eax_94 + 432) = ebp_105;
			Eq_47845 ebp_199 = ebp_105 - *eax_94;
			Mem202[eax_94 + 0x01B4:word32] = Mem198[eax_94 + 0x01B4:word32] + ebp_199;
			Mem204[eax_94 + 440:word32] = Mem202[eax_94 + 440:word32] + ebp_199;
			word32 edx_205 = ebp_199 + Mem204[eax_94 + 0x08:word32];
			*eax_94 = ebp_199;
			*((word32) eax_94 + 8) = edx_205;
			if (edx_205 != 0x00)
			{
				uint32 eax_210 = *edx_205;
				Eq_2 edi_1432 = (word32) eax_94 + 32;
				while (eax_210 != 0x00)
				{
					if (eax_210 > 0x22)
					{
						if (0x6FFFFFFF - eax_210 > 0x0F)
						{
							int32 ecx_232 = eax_210 * 0x02;
							if (ecx_232 >> 0x01 > ~0x03)
								*((word32) eax_94 + (~(ecx_232 >> 0x01) * 0x04 + 0x00EC)) = edx_205;
							else if (0x6FFFFDFF - eax_210 <= 11)
								*((word32) eax_94 + (-eax_210 * 0x04 - 0x4000070C)) = edx_205;
							else if (0x6FFFFEFF - eax_210 <= 0x0A)
								*((word32) eax_94 + (-eax_210 * 0x04 - 0x400002DC)) = edx_205;
							goto l080644AC;
						}
						eax_210 = 0x70000022 - eax_210;
					}
					*((word32) eax_94 + (eax_210 * 0x04 + 32)) = edx_205;
l080644AC:
					edx_205 = (word32) edx_205 + 8;
					eax_210 = (uint32) *edx_205;
				}
				if (ebp_199 != 0x00)
				{
					Eq_2 edx_275 = *((word32) eax_94 + 48);
					ui32 eax_276 = 0x00;
					if (edx_275 != 0x00)
					{
						ebx_22->dwFFFFFD60 = (word32) *edx_275;
						Mem293[ebx_22 + -668:word32] = Mem289[edx_275 + 0x04:word32] + ebp_199;
						*((word32) eax_94 + 48) = ebx_22 - 0x02A0;
						eax_276 = 0x01;
					}
					struct Eq_47965 * edx_299 = *((word32) eax_94 + 44);
					if (edx_299 != null)
					{
						struct Eq_47965 * ecx_306 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						ecx_306->dw0000 = edx_299->dw0000;
						edi_1432 = Mem308[edx_299 + 0x04:word32] + ebp_199;
						ecx_306->t0004 = edi_1432;
						*((word32) eax_94 + 44) = ecx_306;
						++eax_276;
					}
					Eq_2 edx_317 = *((word32) eax_94 + 52);
					if (edx_317 != 0x00)
					{
						Eq_2 ecx_324 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						*ecx_324 = *edx_317;
						edi_1432 = Mem326[edx_317 + 0x04:word32] + ebp_199;
						*((word32) ecx_324 + 4) = edi_1432;
						*((word32) eax_94 + 52) = ecx_324;
						++eax_276;
					}
					Eq_2 edx_335 = *((word32) eax_94 + 56);
					if (edx_335 != 0x00)
					{
						Eq_2 ecx_342 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						*ecx_342 = *edx_335;
						edi_1432 = Mem344[edx_335 + 0x04:word32] + ebp_199;
						*((word32) ecx_342 + 4) = edi_1432;
						*((word32) eax_94 + 56) = ecx_342;
						++eax_276;
					}
					Eq_2 edx_353 = *((word32) eax_94 + 60);
					if (edx_353 != 0x00)
					{
						Eq_2 ecx_360 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						*ecx_360 = *edx_353;
						edi_1432 = Mem362[edx_353 + 0x04:word32] + ebp_199;
						*((word32) ecx_360 + 4) = edi_1432;
						*((word32) eax_94 + 60) = ecx_360;
						++eax_276;
					}
					Eq_2 edx_371 = *((word32) eax_94 + 100);
					if (edx_371 != 0x00)
					{
						Eq_2 ecx_378 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						*ecx_378 = *edx_371;
						edi_1432 = Mem380[edx_371 + 0x04:word32] + ebp_199;
						*((word32) ecx_378 + 4) = edi_1432;
						*((word32) eax_94 + 100) = ecx_378;
						++eax_276;
					}
					struct Eq_48546 * edx_389 = *((word32) eax_94 + 0x007C);
					if (edx_389 != null)
					{
						struct Eq_48546 * ecx_396 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						ecx_396->dw0000 = edx_389->dw0000;
						edi_1432 = Mem398[edx_389 + 0x04:word32] + ebp_199;
						ecx_396->t0004 = edi_1432;
						*((word32) eax_94 + 0x007C) = ecx_396;
						++eax_276;
					}
					Eq_2 edx_407 = *((word32) eax_94 + 232);
					if (edx_407 != 0x00)
					{
						Eq_2 ecx_414 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						*ecx_414 = *edx_407;
						edi_1432 = Mem416[edx_407 + 0x04:word32] + ebp_199;
						*((word32) ecx_414 + 4) = edi_1432;
						*((word32) eax_94 + 232) = ecx_414;
						++eax_276;
					}
					Eq_2 edx_425 = *((word32) eax_94 + 336);
					if (edx_425 != 0x00)
					{
						edi_1432 = *edx_425;
						Eq_2 ecx_432 = ebx_22 - 0x02A0 + eax_276 * 0x08;
						Mem435[ecx_432 + 0x04:word32] = ebp_199 + Mem424[edx_425 + 0x04:word32];
						*ecx_432 = edi_1432;
						*((word32) eax_94 + 336) = ecx_432;
						if (eax_276 == 0x08)
						{
l080645ED:
							struct Eq_48816 * esp_716 = esp_100 - 4;
							esp_716->ptr0000 = (char *) ebx_22 - 169516;
							esp_716->dwFFFFFFFC = 115;
							esp_716->ptrFFFFFFF8 = (char *) ebx_22 - 169911;
							esp_716->ptrFFFFFFF4 = (char *) ebx_22 - 169892;
							word32 ecx_1874;
							word32 edx_1875;
							__assert_fail(out ecx_1874, out edx_1875);
							esp_100.u0 = <invalid>;
							goto l08064609;
						}
					}
				}
				Eq_21863 eax_442 = *((word32) eax_94 + 112);
				if (eax_442 != 0x00)
				{
					word32 eax_446 = *((word32) eax_442 + 4);
					if (eax_446 != 0x11 && eax_446 != 0x07)
					{
						word32 edx_1858;
						word32 ecx_1857;
						__assert_fail(out ecx_1857, out edx_1858);
						esp_100.u0 = <invalid>;
						goto l080645ED;
					}
				}
				if (*((word32) eax_94 + 60) != 0x00 && *((word32) (*((word32) eax_94 + 0x0044)) + 4) != 0x0C)
					goto l08064628;
				if (*((word32) eax_94 + 100) != 0x00 && *((word32) (*((word32) eax_94 + 0x006C)) + 4) != 0x08)
				{
l08064609:
					struct Eq_48274 * esp_736 = esp_100 - 4;
					esp_736->ptr0000 = (char *) ebx_22 - 169516;
					esp_736->dwFFFFFFFC = 0x87;
					esp_736->ptrFFFFFFF8 = (char *) ebx_22 - 169911;
					esp_736->ptrFFFFFFF4 = (char *) ebx_22 - 0x0002969C;
					word32 edx_1862;
					word32 ecx_1861;
					__assert_fail(out ecx_1861, out edx_1862);
					esp_100.u0 = <invalid>;
l08064628:
					struct Eq_48232 * esp_756 = esp_100 - 4;
					esp_756->ptr0000 = (char *) ebx_22 - 169516;
					esp_756->dwFFFFFFFC = 131;
					esp_756->ptrFFFFFFF8 = (char *) ebx_22 - 169911;
					esp_756->ptrFFFFFFF4 = (char *) ebx_22 - 169680;
					word32 edx_1860;
					word32 ecx_1859;
					__assert_fail(out ecx_1859, out edx_1860);
					_dl_get_dl_main_map();
					return edi_1432;
				}
				Eq_2 eax_471 = *((word32) eax_94 + 0x0098);
				if (eax_471 != 0x00)
				{
					ui32 edx_475 = *((word32) eax_471 + 4);
					*((word32) eax_94 + 524) = edx_475;
					byte dl_477 = (byte) edx_475;
					if ((dl_477 & 0x02) != 0x00)
						*((word32) eax_94 + 96) = eax_471;
					if ((dl_477 & 0x04) != 0x00)
						*((word32) eax_94 + 0x0078) = eax_471;
					if ((edx_475 & 0x08) != 0x00)
						*((word32) eax_94 + 0x0080) = eax_471;
				}
				Eq_2 eax_504 = *((word32) eax_94 + 188);
				if (eax_504 != 0x00)
				{
					Eq_48454 eax_508 = *((word32) eax_504 + 4);
					*((word32) eax_94 + 520) = eax_508;
					Eq_48454 al_567 = (byte) eax_508;
					if ((_dl_debug_mask & 0x40) != 0x00 && (eax_508 & ~0x08E9) != 0x00)
					{
						word32 edx_1864;
						word32 ecx_1863;
						_dl_debug_printf(out ecx_1863, out edx_1864);
						dwLoc48_1236 = eax_508 & ~0x08E9;
						al_567 = *((word32) eax_94 + 520);
					}
					if ((al_567 & 0x01) != 0x00)
						*((word32) eax_94 + 0x0080) = *((word32) eax_94 + 188);
				}
				if (*((word32) eax_94 + 0x0094) != 0x00)
					((word32) eax_94 + 92)->u0 = 0x00;
			}
			word32 edi_1856;
			word32 ebp_1855;
			Eq_2 esi_598;
			ebx_22 = _dl_setup_hash(eax_94, dwLoc48_1236, out ebp_1855, out esi_598, out edi_1856);
			struct Eq_47909 * eax_603 = *((word32) esi_598 + 468);
			*((word32) esi_598 + 408) |= 0x04;
			*((word32) esi_598 + 0x0200) = 0x01;
			eax_603->dw0004 = 0x01;
			eax_603->ptr0000 = (word32) esi_598 + 20;
			Eq_2 eax_612 = *((word32) esi_598 + 88);
			if (eax_612 != 0x00)
			{
				word32 edx_1868;
				word32 ecx_1867;
				Eq_2 ebp_660;
				Eq_2 edi_663;
				word32 edx_1869;
				word32 eax_659 = __libc_malloc(gs, 0x00, strlen(Mem611[eax_612 + 0x04:word32] + Mem611[Mem611[esi_598 + 0x34:word32] + 0x04:word32], out ecx_1867, out edx_1868) + 0x01, out ecx_106, out edx_1869, out ebx_22, out ebp_660, out esi_598, out edi_663);
				esp_163 = fp - 0x3C;
				if (eax_659 == 0x00)
				{
l080645B5:
					struct Eq_48629 * esp_677 = esp_163 - 4;
					esp_677->dw0000 = ecx_106;
					esp_677->dwFFFFFFFC = ecx_106;
					esp_677->ptrFFFFFFF8 = (char *) ebx_22 - 169866;
					esp_677->tFFFFFFF4.u0 = 0x02;
					_dl_dprintf();
					esp_677->tFFFFFFF4.u0 = 0x7F;
					_exit(gs, esp_677->tFFFFFFF4);
				}
				word32 ecx_1870;
				word32 edx_1871;
				Eq_2 eax_790 = memcpy(eax_659, edi_663, ebp_660, out ecx_1870, out edx_1871);
				Eq_2 edx_798 = *((word32) esi_598 + 28);
				*((word32) esi_598 + 4) = eax_790;
				*edx_798 = eax_790;
			}
			_dl_add_to_namespace_list(esi_598, 0x00);
			ebx_22->dw09C0 = 0x01;
			_dl_sysinfo_map = esi_598;
			if (ebx_22->ptr09E0 == (char *) ebx_22 - 0x0006A6A0)
				Mem831[ebx_22 + 0x09E0:word32] = Mem822[esi_598 + 0x00:word32] + Mem822[Mem822[0x080CFF44:word32] + 0x18:word32];
		}
	}
	getenv((char *) ebx_22 - 0x0002977B);
	struct Eq_47769 * ebx_851 = _dl_init_paths(gs);
	_dl_init_all_dirs = _dl_all_dirs;
	Eq_2 eax_868 = getenv((char *) ebx_851 - 0x0002976B);
	uint32 edx_876 = 0x01;
	if (eax_868 != 0x00)
		edx_876 = (uint32) (int8) (*eax_868 == 0x00);
	_dl_lazy = edx_876;
	Eq_2 eax_896 = getenv((char *) ebx_851 - 0x0002975F);
	uint32 edx_904 = 0x00;
	if (eax_896 != 0x00)
		edx_904 = (uint32) (int8) (*eax_896 != 0x00);
	_dl_bind_not = edx_904;
	Eq_2 eax_924 = getenv((char *) ebx_851 - 169811);
	uint32 edx_932 = 0x01;
	if (eax_924 != 0x00)
		edx_932 = (uint32) (int8) (*eax_924 == 0x00);
	Eq_4846 edx_966;
	_dl_dynamic_weak = edx_932;
	Eq_2 eax_952 = getenv((char *) ebx_851 - 169795);
	_dl_profile_output = eax_952;
	if (eax_952 != 0x00)
	{
		edx_966 = *(union Eq_4846 *) 0x080CDDAC;
		if (*eax_952 != 0x00)
			goto l08064317;
	}
	else
		edx_966 = *(union Eq_4846 *) 0x080CDDAC;
	Eq_2 eax_975 = (char *) ebx_851 - 0x00029A84;
	if (edx_966 != 0x00)
		eax_975 = (char *) ebx_851 - 170619;
	_dl_profile_output = eax_975;
l08064317:
	if (edx_966 != 0x00)
	{
		Eq_2 edi_1023 = (char *) ebx_851 - 0x00029A60;
		do
		{
			__unsetenv(gs, edi_1023);
			Eq_2 eax_1015 = rawmemchr(edi_1023, 0x00);
			edi_1023 = (word32) eax_1015 + 1;
		} while ((word32) eax_1015 + 1 < (char *) ebx_851 - 0x00029928);
	}
	Eq_2 eax_1033 = _dl_platform;
	if (eax_1033 != 0x00 && *eax_1033 == 0x00)
		_dl_platform.u0 = 0x00;
	Eq_2 eax_1050 = getenv((char *) ebx_851 - 169777);
	Eq_2 ebp_1058 = eax_1050;
	if (eax_1050 != 0x00)
	{
		uint32 edi_1063 = 0x00;
		word32 esi_1064 = 0x00;
		while (true)
		{
			uint32 eax_1078 = _dl_strtoul(ebp_1058, fp - 0x20);
			if (eax_1078 > 0xFE || dwLoc20 == ebp_1058)
				break;
			if (esi_1064 == 0x02)
			{
				edi_1063 |= eax_1078;
l08064422:
				if (edi_1063 != 0x00)
					_dl_osversion = edi_1063;
				break;
			}
			word32 ebp_1098 = (word32) *dwLoc20;
			byte cl_1100 = (byte) ebp_1098;
			if (cl_1100 != 0x00 && cl_1100 != 0x2E)
				break;
			edi_1063 |= eax_1078 << (byte) (-esi_1064) * 0x08 + 0x10;
			if ((byte) ebp_1098 == 0x00)
				goto l08064422;
			++esi_1064;
			ebp_1058 = (word32) dwLoc20 + 1;
		}
	}
	Eq_2 eax_1134 = _dl_platform;
	if (eax_1134 != 0x00)
	{
		word32 ecx_1865;
		word32 edx_1866;
		_dl_platformlen = strlen(eax_1134, out ecx_1865, out edx_1866);
	}
	Eq_2 ecx_1156 = _dl_phdr;
	if (ecx_1156 == 0x00)
		return edi;
	Eq_1898 esi_1161 = _dl_phnum;
	if (esi_1161 == 0x00)
		return edi;
	Eq_1898 edx_1165 = 0x00;
	Eq_2 eax_1167 = (word32) ecx_1156 + 32;
	if (*ecx_1156 != 1685382481)
	{
		do
		{
			edx_1165 = (word32) edx_1165 + 1;
			if (edx_1165 == esi_1161)
				return edi;
			ecx_1156 = eax_1167;
			eax_1167 = (word32) eax_1167 + 32;
		} while (*((word32) eax_1167 - 32) != 1685382481);
	}
	ebx_851->t09A0 = *((word32) ecx_1156 + 24);
	return edi;
}

// 08064650: void _dl_get_dl_main_map()
// Called from:
//      _dl_non_dynamic_init
void _dl_get_dl_main_map()
{
}

// 08064670: void __libc_init_secure(Register (ptr32 Eq_48873) gs)
// Called from:
//      __libc_start_main
void __libc_init_secure(struct Eq_48873 * gs)
{
	if (__libc_enable_secure_decided != 0x00)
		return;
	uint32 edx_22 = 0x01;
	if (__geteuid(gs) == __getuid(gs))
		edx_22 = (uint32) (int8) (__getegid(gs) != __getgid(gs));
	g_dw80CE254 = edx_22;
}

// 080646E0: void _dl_mcount_wrapper(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04)
void _dl_mcount_wrapper(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04)
{
	word32 ecx_38;
	word32 edx_39;
	_dl_mcount(gs, dwArg00, dwArg04, out ecx_38, out edx_39);
}

// 08064710: Register Eq_2 _dl_mcount_wrapper_check(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __mbsrtowcs_l
//      __gconv
//      __gconv_release_step
//      find_derivation
//      __gconv_transform_internal_ucs4
//      __gconv_transform_ucs4_internal
//      __gconv_transform_internal_ucs4le
//      __gconv_transform_ucs4le_internal
//      __gconv_transform_ascii_internal
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_utf8_internal
//      __gconv_transform_ucs2_internal
//      __gconv_transform_internal_ucs2
//      __gconv_transform_ucs2reverse_internal
//      __gconv_transform_internal_ucs2reverse
//      __gconv_transliterate
//      find_module
//      do_in
//      do_unshift
//      do_out
//      do_length
//      btowc
//      wcrtomb
//      __wcsrtombs
//      free_derivation
Eq_2 _dl_mcount_wrapper_check(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_2 eax_11 = _dl_profile_map;
	if (eax_11 != 0x00)
		eax_11 = _dl_mcount(gs, dwArg00, dwArg04, out ecx, out edx);
	ecxOut = ecx;
	edxOut = edx;
	return eax_11;
}

// 08064750: void _dl_tunable_set_hwcaps(Stack (ptr32 (ptr32 byte)) dwArg04)
void _dl_tunable_set_hwcaps(byte ** dwArg04)
{
	byte * esi_21 = *dwArg04;
	byte dl_123 = *esi_21;
	do
	{
		if (dl_123 != 44 && dl_123 != 0x00)
		{
			byte * eax_44 = esi_21;
			do
			{
				++eax_44;
				byte cl_49 = *eax_44;
			} while (cl_49 != 0x00 && cl_49 != 44);
			Eq_48960 eax_58 = eax_44 - esi_21;
			if (dl_123 != 0x2D)
			{
				if (eax_58 <= 0x1A)
				{
					<anonymous> * ecx_112 = g_a80A4BD8[(eax_58 - 0x04) * 0x04] + 0x080CE000;
					ecx_112();
					return;
				}
			}
			else if (eax_58 <= 0x1B)
			{
				<anonymous> * ecx_73 = g_a80A4C34[(eax_58 - 0x04) * 0x04] + 0x080CE000;
				ecx_73();
				return;
			}
			esi_21 += (word32) eax_58 + 1;
			dl_123 = *esi_21;
			if (dl_123 == 0x00)
				return;
			continue;
		}
		++esi_21;
		dl_123 = *esi_21;
	} while (dl_123 != 0x00);
}

// 08065450: void _dl_tunable_set_x86_ibt(Stack (ptr32 (ptr32 Eq_48995)) dwArg04)
void _dl_tunable_set_x86_ibt(struct Eq_48995 ** dwArg04)
{
	struct Eq_48995 * eax_8 = *dwArg04;
	if (eax_8->t0000 == 0x6E6F && eax_8->b0002 == 0x00)
		g_dw80CFF20 = g_dw80CFF20 & ~0x07 | 0x02;
	else if (eax_8->t0000 != 0x0066666F)
	{
		if (eax_8->t0000 != 1836213616 || (eax_8->dw0004 != 0x69737369 || (eax_8->w0008 != 0x6576 || eax_8->b000A != 0x00)))
			return;
		g_dw80CFF20 = g_dw80CFF20 & ~0x07 | 0x03;
	}
	else
		g_dw80CFF20 = g_dw80CFF20 & ~0x07 | 0x01;
}

// 080654F0: void _dl_tunable_set_x86_shstk(Stack (ptr32 (ptr32 Eq_49059)) dwArg04)
void _dl_tunable_set_x86_shstk(struct Eq_49059 ** dwArg04)
{
	struct Eq_49059 * eax_8 = *dwArg04;
	if (eax_8->t0000 == 0x6E6F && eax_8->b0002 == 0x00)
		g_dw80CFF20 = g_dw80CFF20 & ~0x38 | 0x10;
	else if (eax_8->t0000 != 0x0066666F)
	{
		if (eax_8->t0000 != 1836213616 || (eax_8->dw0004 != 0x69737369 || (eax_8->w0008 != 0x6576 || eax_8->b000A != 0x00)))
			return;
		g_dw80CFF20 = g_dw80CFF20 & ~0x38 | 0x18;
	}
	else
		g_dw80CFF20 = g_dw80CFF20 & ~0x38 | 0x08;
}

// 08065590: Register ui32 _dl_discover_osversion(Register Eq_2 ebx, Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_start_main
ui32 _dl_discover_osversion(Eq_2 ebx, struct Eq_9 * gs)
{
	ui32 eax_119;
	struct Eq_49126 * ebx_127 = fp - 0x0110;
	if (__uname(ebx, gs, fp - 0x0192) != 0x00)
	{
		word32 edx_251;
		word32 ecx_250;
		Eq_2 eax_40 = __open64_nocancel(gs, 0x080A4BBC, 0x00, dwLoc01E4, out ecx_250, out edx_251);
		if (eax_40 >= 0x00)
		{
			word32 ecx_252;
			Eq_2 eax_61 = __read_nocancel(gs, eax_40, fp - 466, 0x40, out ecx_252);
			word32 edx_253;
			__close_nocancel(gs, eax_40, out edx_253);
			ebx_127 = fp - 466;
			Eq_2 esi_69 = eax_61;
			if (eax_61 > 0x00)
			{
				if (eax_61 >= 0x3F)
					esi_69.u0 = 0x3F;
				*((word32) esi_69 + (fp - 466)) = 0x00;
				goto l080655C4;
			}
		}
		eax_119 = ~0x00;
		return eax_119;
	}
	else
	{
l080655C4:
		word32 edi_123 = 0x00;
		eax_119 = 0x00;
		do
		{
			int32 ecx_93 = (int32) ebx_127->b0000;
			if ((byte) ecx_93 > 0x39 || (byte) ecx_93 < 0x30)
				return eax_119 << (0x03 - (byte) edi_123 << 0x03);
			int32 edx_110 = (int32) ebx_127[1];
			byte * esi_105 = ebx_127 + 1;
			int32 ecx_100 = ecx_93 - 0x30;
			if ((byte) edx_110 <= 0x39 && (byte) edx_110 >= 0x30)
			{
				do
				{
					++esi_105;
					edx_110 = (int32) *esi_105;
					ecx_100 = edx_110 - 0x30 + ecx_100 * 0x0A;
				} while ((byte) edx_110 <= 0x39);
			}
			++edi_123;
			ebx_127 = (struct Eq_49126 *) (esi_105 + 1);
			eax_119 = eax_119 << 0x08 | ecx_100;
			if ((byte) edx_110 != 0x2E)
			{
				if (edi_123 == 0x03)
					return eax_119;
				return eax_119 << (0x03 - (byte) edi_123 << 0x03);
			}
		} while (edi_123 != 0x03);
		return eax_119;
	}
}

// 080656A0: Register word32 __libc_init_first(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
word32 __libc_init_first(struct Eq_9 * gs, word32 dwArg04, word32 * dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	__libc_multiple_libcs = 0x01;
	__libc_argc = dwArg04;
	__libc_argv = dwArg08;
	environ = dwArg0C;
	__init_misc(_dl_non_dynamic_init(gs));
	ptr32 edx_111;
	word32 ecx_110 = __ctype_init(gs, out edx_111);
	edxOut = edx_111;
	return ecx_110;
}

// 08065740: Register (ptr32 Eq_224) __syscall_error(Register (ptr32 Eq_224) eax, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      sched_yield
//      __xstat64
//      __fxstat64
//      open
//      read
//      __libc_write
//      lseek64
//      getcwd
//      __close_nocancel
//      __fcntl64_nocancel_adjusted
//      __open_nocancel
//      __openat64_nocancel
//      __read_nocancel
//      __write_nocancel
//      __getrlimit
//      mmap
//      mmap64
//      __munmap
//      mprotect
//      __madvise
//      __mremap
//      __sysinfo
//      raise
//      __libc_sigaction
//      sigprocmask
//      __getdents
//      __uname
//      __lxstat64
//      __fxstatat64
//      __libc_lseek
//      __open64_nocancel
//      __openat_nocancel
//      tcgetattr
//      brk
//      __getdents64
//      __setitimer
struct Eq_224 * __syscall_error(struct Eq_224 * eax, struct Eq_9 * gs, ptr32 & edxOut)
{
	gs->tFFFFFFE0 = -eax;
	edxOut = ~0x1F;
	return (struct Eq_224 *) ~0x00;
}

// 08065760: Register ui32 __gconv_open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      _nl_find_msg
ui32 __gconv_open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	ui32 dwLoc30_1096;
	byte bLoc34_1095;
	struct Eq_49292 * esp_229;
	Eq_2175 esi_27 = gs->t0014;
	Eq_2 dwLoc38_1079 = dwArg08;
	Eq_2 dwLoc40_1081 = dwArg04;
	word32 ecx_1710;
	word32 edx_1711;
	Eq_2 eax_36 = strchr(dwArg04, 0x2F, out ecx_1710, out edx_1711);
	if (eax_36 != 0x00)
	{
		word32 ecx_1712;
		word32 edx_1713;
		Eq_2 eax_54 = strchr((word32) eax_36 + 1, 0x2F, out ecx_1712, out edx_1713);
		struct Eq_49323 * esp_101 = fp - 0x5C;
		if (eax_54 != 0x00 && *((word32) eax_54 + 1) != 0x00)
		{
			Eq_2 edx_70 = (word32) eax_54 + 1 - dwArg04;
			struct Eq_49323 * edi_74 = fp - 0x5C - ((word32) edx_70 + 28 & ~0x0FFF);
			ui32 ecx_75 = (word32) edx_70 + 28 & ~0x0F;
			if (fp - 0x5C != edi_74)
			{
				do
				{
					esp_101 -= 0x1000;
					esp_101->dw0FFC = esp_101->dw0FFC;
				} while (esp_101 != edi_74);
			}
			if ((ecx_75 & 0x0FFF) != 0x00)
			{
				esp_101 -= ecx_75 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_101 - 0x04)[(ecx_75 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_101 - 0x04)[(ecx_75 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_49675 eax_102 = (char *) esp_101 + 0x0F;
			*((word32) edx_70 + (eax_102 & ~0x0F)) = 0x00;
			struct Eq_49683 * esp_103 = esp_101 - 0x04;
			esp_103->tFFFFFFFC = edx_70;
			esp_103->tFFFFFFF8 = dwArg04;
			esp_103->tFFFFFFF4 = eax_102 & ~0x0F;
			word32 ecx_1734;
			word32 edx_1735;
			Eq_2 eax_122 = memcpy(esp_103->tFFFFFFF4, esp_103->tFFFFFFF8, esp_103->tFFFFFFFC, out ecx_1734, out edx_1735);
			esp_103->tFFFFFFF4 = (word32) eax_54 + 1;
			word32 edx_1737;
			word32 ecx_1736;
			Eq_2 eax_135 = strlen(esp_103->tFFFFFFF4, out ecx_1736, out edx_1737);
			dwLoc24.u0 = 0x00;
			dwLoc40_1081 = eax_122;
			struct Eq_49727 * esp_142 = (char *) &esp_103->tFFFFFFFC + 8;
			struct Eq_49727 * edi_148 = (char *) &esp_103->tFFFFFFFC + 8 - ((word32) eax_135 + 28 & ~0x0FFF);
			ui32 ecx_149 = (word32) eax_135 + 28 & ~0x0F;
			if ((char *) &esp_103->tFFFFFFFC + 8 != edi_148)
			{
				do
				{
					esp_142 -= 0x1000;
					esp_142->dw0FFC = esp_142->dw0FFC;
				} while (esp_142 != edi_148);
			}
			if ((ecx_149 & 0x0FFF) != 0x00)
			{
				esp_142 -= ecx_149 & 0x0FFF;
				Mem172[esp_142 - 0x04 + (ecx_149 & 0x0FFF):word32] = Mem170[esp_142 - 0x04 + (ecx_149 & 0x0FFF):word32];
			}
			struct Eq_49756 * esp_177 = esp_142 - 0x04;
			esp_177->tFFFFFFFC = (word32) eax_135 + 1;
			esp_177->tFFFFFFF8 = (word32) eax_54 + 1;
			Mem196[esp_177 + -0x0C:word32] = esp_142 + 0x0F & ~0x0F;
			word32 ecx_1738;
			word32 edx_1739;
			Eq_2 eax_197 = memcpy(esp_177->tFFFFFFF4, esp_177->tFFFFFFF8, esp_177->tFFFFFFFC, out ecx_1738, out edx_1739);
			esp_177->tFFFFFFFC = fp - 0x24;
			esp_177->tFFFFFFF8.u0 = 0x080A4C94;
			esp_177->tFFFFFFF4 = eax_197;
			Eq_2 eax_222 = __strtok_r(esp_177->tFFFFFFF4, esp_177->tFFFFFFF8, esp_177->tFFFFFFFC);
			esp_229 = (struct Eq_49292 *) ((char *) &esp_177->tFFFFFFFC + 8);
			bLoc34_1095 = 0x00;
			Eq_2 edi_231 = eax_222;
			dwLoc30_1096 = 0x00;
			if (eax_222 != 0x00)
			{
				do
				{
					struct Eq_49938 * esp_242 = esp_142 - (struct Eq_49939 *) 0x04;
					esp_242->tFFFFFFFC.u0 = 0x080CE0C0;
					esp_242->tFFFFFFF8.u0 = 0x080A3AA0;
					esp_242->tFFFFFFF4 = edi_231;
					word32 ecx_1748;
					if (__strcasecmp_l(esp_242->tFFFFFFF4, esp_242->tFFFFFFF8, esp_242->tFFFFFFFC, out ecx_1748) != 0x00)
					{
						esp_242->tFFFFFFFC.u0 = 0x080CE0C0;
						esp_242->tFFFFFFF8.u0 = 0x080A4C96;
						esp_242->tFFFFFFF4 = edi_231;
						ui32 eax_285 = 0x02;
						word32 ecx_1749;
						if (__strcasecmp_l(esp_242->tFFFFFFF4, esp_242->tFFFFFFF8, esp_242->tFFFFFFFC, out ecx_1749) != 0x00)
							eax_285 = dwLoc30_1096;
						dwLoc30_1096 = eax_285;
					}
					else
						bLoc34_1095 = 0x01;
					struct Eq_50045 * esp_293 = esp_142 - (struct Eq_50046 *) 0x04;
					esp_293->tFFFFFFFC = fp - 0x24;
					esp_293->tFFFFFFF8.u0 = 0x080A4C94;
					esp_293->tFFFFFFF4.u0 = 0x00;
					Eq_2 eax_305 = __strtok_r(esp_293->tFFFFFFF4, esp_293->tFFFFFFF8, esp_293->tFFFFFFFC);
					esp_229 = esp_293 + 0x04;
					edi_231 = eax_305;
				} while (eax_305 != 0x00);
			}
l080657D5:
			Eq_2 eax_350;
			struct Eq_49356 * esp_324 = esp_229 - 0x08;
			esp_324->dwFFFFFFFC = 0x2F;
			esp_324->tFFFFFFF8 = dwArg08;
			word32 edx_1747;
			word32 ecx_1746;
			Eq_2 eax_332 = strchr(esp_324->tFFFFFFF8, esp_324->t0004, out ecx_1746, out edx_1747);
			struct Eq_49380 * esp_339 = (char *) &esp_324->t0004 + 4;
			bool v51_1059 = eax_332 > 0x00;
			if (eax_332 != 0x00)
			{
				esp_324->dwFFFFFFFC = 0x2F;
				esp_324->tFFFFFFF8 = (word32) eax_332 + 1;
				word32 edx_1715;
				word32 ecx_1714;
				eax_350 = strchr(esp_324->tFFFFFFF8, esp_324->t0004, out ecx_1714, out edx_1715);
				esp_339 = (struct Eq_49380 *) ((char *) &esp_324->t0004 + 4);
				v51_1059 = eax_350 > 0x00;
				if (eax_350 != 0x00)
				{
					v51_1059 = *((word32) eax_350 + 1) > 0x00;
					if (*((word32) eax_350 + 1) != 0x00)
					{
						Eq_2 eax_364 = (word32) eax_350 + 1 - dwArg08;
						struct Eq_49380 * esi_369 = (char *) &esp_324->t0004 + 4 - ((word32) eax_364 + 28 & ~0x0FFF);
						ui32 ecx_370 = (word32) eax_364 + 28 & ~0x0F;
						if ((char *) &esp_324->t0004 + 4 != esi_369)
						{
							do
							{
								esp_339 -= 0x1000;
								esp_339->dw0FFC = esp_339->dw0FFC;
							} while (esp_339 != esi_369);
						}
						if ((ecx_370 & 0x0FFF) != 0x00)
						{
							esp_339 -= ecx_370 & 0x0FFF;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_339 - 0x04)[(ecx_370 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_339 - 0x04)[(ecx_370 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						Eq_49851 edx_397 = (char *) &esp_339->dwFFFFFFF0 + 31;
						*((word32) eax_364 + (edx_397 & ~0x0F)) = 0x00;
						struct Eq_49859 * esp_398 = esp_339 - 0x04;
						esp_398->tFFFFFFFC = eax_364;
						esp_398->tFFFFFFF8 = dwArg08;
						esp_398->tFFFFFFF4 = edx_397 & ~0x0F;
						esp_339 = (struct Eq_49380 *) ((char *) &esp_398->tFFFFFFFC + 8);
						v51_1059 = esp_398 > (struct Eq_49859 *) 0x04;
						word32 edx_1741;
						word32 ecx_1740;
						dwLoc38_1079 = memcpy(esp_398->tFFFFFFF4, esp_398->tFFFFFFF8, esp_398->tFFFFFFFC, out ecx_1740, out edx_1741);
					}
				}
			}
			Eq_2 esi_439 = dwLoc40_1081;
			word32 ecx_440 = 0x03;
			cu8 * edi_441 = &g_b80A4E24;
			while (ecx_440 != 0x00)
			{
				v51_1059 = *esi_1774 > *edi_1775;
				esi_439 = (word32) esi_1774 + 1;
				edi_441 = edi_1775 + 1;
				--ecx_440;
				esi_1774 = esi_439;
				edi_1775 = edi_441;
				if (*esi_1774 == *edi_1775)
					break;
			}
			struct Eq_49415 * esp_542;
			Eq_49416 al_463 = (int8) v51_1059 - (byte) (*((word32) eax_350 + 1) < 0x00);
			bool v59_1067 = al_463 > 0x00;
			if (al_463 == 0x00)
			{
				struct Eq_49453 * esp_476 = esp_339 - 0x0C;
				Eq_2 edi_497 = *((word32) gs->ptrFFFFFFD0->t0000 + 92);
				esp_476->tFFFFFFFC = edi_497;
				word32 ecx_1716;
				word32 edx_1717;
				Eq_2 eax_500 = strlen(esp_476->tFFFFFFFC, out ecx_1716, out edx_1717);
				struct Eq_49478 * esp_507 = (char *) &esp_476->tFFFFFFFC + 16;
				struct Eq_49478 * edx_512 = (char *) &esp_476->tFFFFFFFC + 16 - ((word32) eax_500 + 30 & ~0x0FFF);
				ui32 esi_513 = (word32) eax_500 + 30 & ~0x0F;
				if ((char *) &esp_476->tFFFFFFFC + 16 != edx_512)
				{
					do
					{
						esp_507 -= 0x1000;
						esp_507->dw0FFC = esp_507->dw0FFC;
					} while (esp_507 != edx_512);
				}
				if ((esi_513 & 0x0FFF) != 0x00)
				{
					esp_507 -= esi_513 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_507 - 0x04)[(esi_513 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_507 - 0x04)[(esi_513 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				esp_542 = esp_507 - 0x04;
				esp_542->tFFFFFFFC = eax_500;
				esp_542->tFFFFFFF8 = edi_497;
				Eq_50327 ecx_541 = (char *) esp_507 + 0x0F;
				esp_542->tFFFFFFF4 = ecx_541 & ~0x0F;
				word32 edx_1773;
				Eq_2 eax_566 = __mempcpy(esp_542->tFFFFFFF4, esp_542->tFFFFFFF8, esp_542->tFFFFFFFC, out edx_1773);
				eax_566->u5 = 0x2F2F;
				*((word32) eax_566 + 2) = 0x00;
				dwLoc40_1081 = ecx_541 & ~0x0F;
				esp_339 = (struct Eq_49380 *) ((char *) &esp_542->tFFFFFFFC + 8);
				v59_1067 = esp_542 > (struct Eq_49415 *) 0x04;
			}
			Eq_2 esi_584 = dwLoc38_1079;
			word32 ecx_585 = 0x03;
			cu8 * edi_587 = &g_b80A4E24;
			while (ecx_585 != 0x00)
			{
				v59_1067 = *esi_1776 > *edi_1777;
				esi_584 = (word32) esi_1776 + 1;
				edi_587 = edi_1777 + 1;
				--ecx_585;
				esi_1776 = esi_584;
				edi_1777 = edi_587;
				if (*esi_1776 == *edi_1777)
					break;
			}
			if ((int8) v59_1067 - (byte) (esp_542 < (struct Eq_49415 *) 0x04) == 0x00)
			{
				struct Eq_49530 * esp_614 = esp_339 - 0x0C;
				Eq_2 esi_625 = *((word32) gs->ptrFFFFFFD0->t0000 + 92);
				esp_614->tFFFFFFFC = esi_625;
				word32 ecx_1718;
				word32 edx_1719;
				Eq_2 eax_628 = strlen(esp_614->tFFFFFFFC, out ecx_1718, out edx_1719);
				struct Eq_49555 * esp_635 = (char *) &esp_614->tFFFFFFFC + 16;
				struct Eq_49555 * edi_640 = (char *) &esp_614->tFFFFFFFC + 16 - ((word32) eax_628 + 30 & ~0x0FFF);
				ui32 ecx_641 = (word32) eax_628 + 30 & ~0x0F;
				if ((char *) &esp_614->tFFFFFFFC + 16 != edi_640)
				{
					do
					{
						esp_635 -= 0x1000;
						esp_635->dw0FFC = esp_635->dw0FFC;
					} while (esp_635 != edi_640);
				}
				if ((ecx_641 & 0x0FFF) != 0x00)
				{
					esp_635 -= ecx_641 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_635 - 0x04)[(ecx_641 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_635 - 0x04)[(ecx_641 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_50101 * esp_669 = esp_635 - 0x04;
				esp_669->tFFFFFFFC = eax_628;
				esp_669->tFFFFFFF8 = esi_625;
				Eq_50110 edx_668 = (char *) esp_635 + 0x0F;
				esp_669->tFFFFFFF4 = edx_668 & ~0x0F;
				word32 edx_1752;
				Eq_2 eax_691 = __mempcpy(esp_669->tFFFFFFF4, esp_669->tFFFFFFF8, esp_669->tFFFFFFFC, out edx_1752);
				eax_691->u5 = 0x2F2F;
				*((word32) eax_691 + 2) = 0x00;
				dwLoc38_1079 = edx_668 & ~0x0F;
				esp_339 = (struct Eq_49380 *) ((char *) &esp_669->tFFFFFFFC + 8);
			}
			struct Eq_49571 * esp_706 = esp_339 - 0x0C;
			esp_706->tFFFFFFFC = dwArg10;
			esp_706->ptrFFFFFFF8 = fp - 0x24;
			esp_706->ptrFFFFFFF4 = fp - 0x28;
			esp_706->tFFFFFFF0 = dwLoc38_1079;
			esp_706->tFFFFFFEC = dwLoc40_1081;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			word32 ebx_1721;
			word32 ebp_1722;
			word32 esi_1723;
			ui32 eax_775 = __gconv_find_transform(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, out ebx_1721, out ebp_1722, out esi_1723);
			Eq_2 dwLoc40_1289 = 0x00;
			ui32 dwLoc48_1290 = eax_775;
			if (eax_775 == 0x00)
			{
				Eq_2 dwLoc30_1348;
				esp_706->tFFFFFFFC = (dwLoc24 << 0x05) + 0x08;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 esi_1730;
				word32 edx_1727;
				word32 edi_1731;
				word32 ebx_1728;
				word32 ebp_1729;
				word32 ecx_1726;
				Eq_2 eax_794 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1726, out edx_1727, out ebx_1728, out ebp_1729, out esi_1730, out edi_1731);
				dwLoc40_1289 = eax_794;
				if (eax_794 != 0x00)
				{
					*((word32) eax_794 + 4) = dwLoc28;
					*eax_794 = dwLoc24;
					esp_706->t0004 = dwLoc24 << 0x05;
					esp_706->t0000.u0 = 0x00;
					esp_706->tFFFFFFFC = (word32) eax_794 + 8;
					word32 ecx_1750;
					word32 edx_1751;
					memset(esp_706->tFFFFFFFC, esp_706->t0000, esp_706->t0004, out ecx_1750, out edx_1751);
					if (dwLoc24 != 0x00)
					{
						struct Eq_50035 * esi_1019 = (word32) eax_794 + 32;
						Eq_49609 edi_1018 = 0x00;
						do
						{
							esi_1019->dwFFFFFFFC = esi_1019;
							if (bLoc34_1095 != 0x00)
							{
								struct Eq_50146 * esp_853 = esp_339 - 0x04;
								esp_853->tFFFFFFFC.u0 = 0x080CE0C0;
								esp_853->tFFFFFFF8.u0 = 0x080A4DFD;
								Mem863[esp_853 + -0x0C:word32] = Mem860[edi_1018 *s 0x3C + dwLoc28 + 0x0C:word32];
								ui32 edx_874 = dwLoc30_1096 | 0x08;
								word32 ecx_1753;
								if (__strcasecmp_l(esp_853->tFFFFFFF4, esp_853->tFFFFFFF8, esp_853->tFFFFFFFC, out ecx_1753) != 0x00)
									edx_874 = dwLoc30_1096;
								dwLoc30_1096 = edx_874;
							}
							if (dwLoc24 - 0x01 <= edi_1018)
							{
								*((word32) eax_794 + (edi_1018 * 0x20 + 16)) = dwLoc30_1096 | 0x01;
								break;
							}
							esi_1019->dwFFFFFFF0 = dwLoc30_1096;
							int32 edx_909 = dwLoc28->a0030[edi_1018].dw0000 *s 0x1FE0;
							esp_339->dwFFFFFFF0 = edx_909;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 ecx_1756;
							word32 ebp_1759;
							word32 esi_1760;
							word32 edi_1761;
							word32 edx_1757;
							word32 ebx_1758;
							Eq_2 eax_923 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1756, out edx_1757, out ebx_1758, out ebp_1759, out esi_1760, out edi_1761);
							esi_1019->dwFFFFFFE8 = (word32) eax_923;
							if (eax_923 == 0x00)
							{
								Eq_50227 esi_934 = edi_1018 - 0x01;
								dwLoc30_1348 = gs->tFFFFFFE0;
								if (edi_1018 != 0x00)
								{
									Eq_50227 esi_942 = esi_934;
									do
									{
										esp_339->dwFFFFFFF0 = (word32) *((word32) eax_794 + (esi_942 * 0x20 + 8));
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg0 = <invalid>;
										Eq_2 stackArg4 = <invalid>;
										word32 ecx_1771;
										word32 edx_1772;
										free(gs, stackArg0, stackArg4, out ecx_1771, out edx_1772);
										--esi_942;
									} while (esi_942 != ~0x00);
								}
								esp_339->dwFFFFFFF0 = (word32) eax_794;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg0 = <invalid>;
								Eq_2 stackArg4 = <invalid>;
								word32 ecx_1767;
								word32 edx_1768;
								free(gs, stackArg0, stackArg4, out ecx_1767, out edx_1768);
								goto l08065CD9;
							}
							++esi_1019;
							esi_1019->dwFFFFFFCC = (word32) eax_923 + edx_909;
							edi_1018 = (word32) edi_1018 + 1;
						} while (dwLoc24 > edi_1018);
					}
				}
				else
				{
					dwLoc30_1348 = gs->tFFFFFFE0;
l08065CD9:
					struct Eq_50243 * esp_992 = esp_339 - 0x08;
					esp_992->tFFFFFFFC = dwLoc24;
					esp_992->ptrFFFFFFF8 = dwLoc28;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 edx_1764;
					__gconv_close_transform(edx, gs, stackArg4, dwArg04, out edx_1764);
					gs->tFFFFFFE0 = dwLoc30_1348;
					dwLoc48_1290 = 0x03;
					dwLoc40_1289.u0 = 0x00;
				}
			}
			*dwArg0C = dwLoc40_1289;
			if ((esi_27 ^ gs->t0014) == 0x00)
				return dwLoc48_1290;
			word32 edx_1733;
			word32 ecx_1732;
			__stack_chk_fail(out ecx_1732, out edx_1733);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg20 = <invalid>;
			Eq_2 stackArg24 = <invalid>;
			word32 ecx_1744;
			word32 edx_1745;
			return __gconv(gs, dwArg04, dwArg08, dwArg0C, dwArg10, stackArg20, stackArg24, out ecx_1744, out edx_1745);
		}
	}
	esp_229 = fp - 0x5C;
	bLoc34_1095 = 0x00;
	dwLoc30_1096 = 0x00;
	goto l080657D5;
}

// 08065D60: Register word32 __gconv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Register out Eq_2 ecxOut, Register out Eq_3066 edxOut)
// Called from:
//      _nl_find_msg
//      __gconv_open
word32 __gconv(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, union Eq_2 & ecxOut, union Eq_3066 & edxOut)
{
	if (dwArg04 == ~0x00)
	{
		ecxOut.u0 = 0x080CE000;
		edxOut = edx;
		return 0x08;
	}
	uint32 eax_34 = *dwArg04;
	if (dwArg18 == 0x00)
	{
		word32 edx_473;
		word32 ecx_472;
		__assert_fail(out ecx_472, out edx_473);
		goto l08065F19;
	}
	else
	{
		*dwArg18 = 0x00;
		Eq_3066 edx_59 = 0x00;
		if (dwArg10 != 0x00)
			edx_59 = *dwArg10;
		struct Eq_50388 * esi_68 = (word32) dwArg04 + (eax_34 << 0x05);
		esi_68->tFFFFFFE8 = edx_59;
		esi_68->tFFFFFFEC = dwArg14;
		Eq_2 eax_75 = *((word32) dwArg04 + 4);
		Eq_2 esi_105 = *((word32) eax_75 + 20);
		if (*eax_75 != 0x00)
			esi_105 = __ror(esi_105, 0x09) ^ gs->t0018;
		Eq_2 ecx_178;
		word32 eax_154;
		if (dwArg08 != 0x00)
		{
			up32 edi_268 = *dwArg08;
			if (edi_268 != 0x00)
			{
				if (dwArg10 != 0x00 && *dwArg10 != 0x00)
				{
					while (true)
					{
						word32 ecx_478;
						word32 edx_479;
						_dl_mcount_wrapper_check(gs, dwLoc40, esi_105, out ecx_478, out edx_479);
						word32 edx_272;
						esi_105();
						dwLoc40.u0 = 0x00;
						if (eax_154 != 0x04)
							break;
						up32 edx_277 = *dwArg08;
						if (edx_277 == edi_268)
							break;
						ecx_178 = *((word32) dwArg04 + 4);
						if (dwArg0C < (word32) (*((word32) ecx_178 + 36)) + edx_277)
							break;
						edi_268 = edx_277;
					}
					goto l08065E60;
				}
l08065F19:
				word32 edx_477;
				word32 ecx_476;
				__assert_fail(out ecx_476, out edx_477);
				Eq_2 ecx_226;
				Eq_3066 edx_228;
				word32 eax_227 = __gconv_close(dwArg04, out ecx_226, out edx_228);
				ecxOut = ecx_226;
				edxOut = edx_228;
				return eax_227;
			}
		}
		word32 edx_475;
		word32 ecx_474;
		_dl_mcount_wrapper_check(gs, dwLoc40, esi_105, out ecx_474, out edx_475);
		Eq_3066 edx_155;
		esi_105();
		if (eax_154 == 0x00)
		{
			edx_155.u0 = 0x00;
			do
			{
				*((word32) dwArg04 + (edx_155 * 0x20 + 20)) = 0x00;
				edx_155 = (word32) edx_155.u0 + 1;
			} while (eax_34 - 0x01 >= edx_155);
		}
		ecx_178 = dwArg10;
		if (dwArg10 == 0x00)
		{
			ecxOut = dwArg10;
			edxOut = edx_155;
			return eax_154;
		}
l08065E60:
		Eq_3066 edx_289 = *dwArg10;
		if (edx_289 != 0x00)
		{
			edx_289 = esi_68->tFFFFFFE8;
			*dwArg10 = edx_289;
		}
		ecxOut = ecx_178;
		edxOut = edx_289;
		return eax_154;
	}
}

// 08065F40: Register Eq_2 __gconv_close(Stack Eq_2 dwArg04, Register out Eq_952 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __gconv
//      _nl_unload_domain
Eq_2 __gconv_close(Eq_2 dwArg04, union Eq_952 & ecxOut, ptr32 & edxOut)
{
	Eq_2 eax_21 = *((word32) dwArg04 + 4);
	Eq_2 ebp_22 = *dwArg04;
	struct Eq_50522 * edi_23 = (word32) dwArg04 + 8;
	while ((edi_23->b0008 & 0x01) == 0x00)
	{
		Eq_2 edx_32 = edi_23->dw0000;
		++edi_23;
		if (edx_32 == 0x00)
			continue;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_124;
		word32 edx_125;
		free(gs, stackArg0, edx_32, out ecx_124, out edx_125);
		if ((edi_23->bFFFFFFE8 & 0x01) != 0x00)
			break;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 edx_122;
	word32 ecx_121;
	free(gs, stackArg0, dwArg04, out ecx_121, out edx_122);
	ptr32 edx_76;
	Eq_2 eax_75 = __gconv_close_transform(dwLoc38, gs, eax_21, ebp_22, out edx_76);
	ecxOut.u0 = <invalid>;
	edxOut = edx_76;
	return eax_75;
}

// 08065FB0: void __gconv_alias_compare(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_2) dwArg08)
void __gconv_alias_compare(union Eq_2 * dwArg04, union Eq_2 * dwArg08)
{
	Eq_2 eax_6 = *dwArg08;
	Eq_2 eax_9 = *dwArg04;
	word32 ecx_22;
	word32 edx_23;
	strcmp(eax_9, eax_6, out ecx_22, out edx_23);
}

// 08065FD0: void derivation_compare(Stack (ptr32 Eq_50584) dwArg04, Stack (ptr32 Eq_50585) dwArg08)
void derivation_compare(struct Eq_50584 * dwArg04, struct Eq_50585 * dwArg08)
{
	word32 ecx_77;
	word32 edx_78;
	if (strcmp(dwArg04->t0000, dwArg08->t0000, out ecx_77, out edx_78) != 0x00)
		return;
	Eq_2 eax_37 = dwArg08->t0004;
	Eq_2 eax_39 = dwArg04->t0004;
	word32 ecx_79;
	word32 edx_80;
	strcmp(eax_39, eax_37, out ecx_79, out edx_80);
}

// 08066020: void __gconv_get_modules_db()
void __gconv_get_modules_db()
{
}

// 08066040: void __gconv_get_alias_db()
void __gconv_get_alias_db()
{
}

// 08066060: Register Eq_2 __gconv_release_step(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 edxOut)
// Called from:
//      __new_fclose
//      find_derivation
//      __gconv_close_transform
//      __gconv_lookup_cache
Eq_2 __gconv_release_step(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & edxOut)
{
	Eq_2 edx_124 = *dwArg04;
	if (edx_124 != 0x00)
	{
		Eq_2 v11_41 = *((word32) dwArg04 + 8) - 0x01;
		*((word32) dwArg04 + 8) = v11_41;
		if (v11_41 == 0x00)
		{
			Eq_2 esi_49 = __ror(*((word32) dwArg04 + 32), 0x09) ^ gs->t0018;
			if (esi_49 != 0x00)
			{
				word32 ecx_140;
				word32 edx_141;
				_dl_mcount_wrapper_check(gs, dwLoc20, esi_49, out ecx_140, out edx_141);
				word32 ecx_67;
				esi_49();
				edx_124 = *dwArg04;
			}
			__gconv_release_shlib(edx_124, out ecx, out edx_124);
			dwArg04->u0 = 0x00;
		}
	}
	else
	{
		edx_124 = *((word32) dwArg04 + 32);
		if (edx_124 != 0x00)
		{
			word32 ecx_142;
			word32 edx_143;
			__assert_fail(out ecx_142, out edx_143);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			Eq_2 edx_39;
			Eq_2 ecx_105;
			find_derivation(eax, ecx_105, edx, gs, stackArg4, stackArg8, stackArg12, out ecx_105, out edx_39);
			edxOut = edx_39;
			return ecx_105;
		}
	}
	edxOut = edx_124;
	return ecx;
}

// 080660F0: Register Eq_2 find_derivation(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __gconv_release_step
//      __gconv_find_transform
Eq_2 find_derivation(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 eax_40;
	Eq_2 dwLoc74_1791 = dwArg04;
	Eq_2175 ecx_34 = gs->t0014;
	eax_40 = eax;
	if (edx != 0x00)
		eax_40 = edx;
	Eq_2 dwLoc40_2047;
	word32 * dwLoc84_1806;
	Eq_2 dwLoc80_2565;
	Eq_2 dwLoc7C_2509;
	Eq_2 dwLoc60_1836;
	Eq_2 dwLoc44_2221;
	Eq_2 edx_1389;
	Eq_2 ecx_1387;
	Eq_2 esi_1148;
	Eq_2 dwLoc70_1805;
	struct Eq_50716 * esp_1182;
	Eq_2 eax_1382;
	if (dwArg04 != 0x00)
	{
		eax_1382 = __tfind(fp - 0x30, 0x080CF940, 0x08065FD0);
		struct Eq_50738 * esp_155 = fp - 0x8C;
		if (eax_1382 != 0x00)
		{
l08066185:
			struct Eq_4012 * eax_1384 = *eax_1382;
			ecx_1387 = eax_1384->t0008;
			*dwArg08 = ecx_1387;
			edx_1389 = eax_1384->t000C;
			*dwArg0C = edx_1389;
			dwLoc80_2565.u0 = 0x080CF940;
			dwLoc7C_2509.u0 = 0x08065FD0;
			esi_1148 = edx_1389;
			dwLoc44_2221 = edx_1389;
			struct Eq_50764 * ebx_1397 = ecx_1387 - 0x3C + edx_1389 *s 0x3C;
			if (edx_1389 != 0x00)
			{
				do
				{
					word32 eax_1403 = ebx_1397->dw0008;
					ebx_1397->dw0008 = eax_1403 + 0x01;
					edx_1389 = eax_1403 + 0x01;
					if (eax_1403 == 0x00)
					{
						Eq_2 eax_1409 = ebx_1397->dw0004;
						if (eax_1409 != 0x00)
						{
							Eq_2 eax_1425 = __gconv_find_shlib(gs, eax_1409, out ecx_1387);
							ebx_1397->dw0000 = (word32) eax_1425;
							if (eax_1425 == 0x00)
							{
								--ebx_1397->dw0008;
								if (edx_1389 > esi_1148)
								{
									esi_1148 = (word32) ecx_1387 + edx_1389 *s 0x3C;
									Eq_2 ebx_1441 = (word32) ecx_1387 + esi_1148 *s 0x3C;
									do
									{
										ebx_1441 = (word32) ebx_1441 + 60;
										ecx_1387 = __gconv_release_step(gs, ebx_1441, out edx_1389);
									} while (esi_1148 != ebx_1441);
								}
								esp_1182 = fp - 0x8C;
								dwLoc40_2047.u0 = 0x01;
								goto l08066AA8;
							}
							ebx_1397->dw0014 = (word32) *((word32) eax_1425 + 0x0C);
							Eq_2 edx_1469 = *((word32) eax_1425 + 16);
							word32 eax_1470 = *((word32) eax_1425 + 20);
							ebx_1397->dw0018 = 0x00;
							ebx_1397->dw001C = (word32) edx_1469;
							ebx_1397->dw0020 = eax_1470;
							<anonymous> * edx_1476 = __ror(edx_1469, 0x09) ^ gs->t0018;
							if (edx_1476 != null)
							{
								word32 ecx_1486;
								edx_1476();
								edx_1476 = ebx_1397->dw0018;
							}
							edx_1389 = __rol(edx_1476 ^ gs->t0018, 0x09);
							ebx_1397->dw0018 = (word32) edx_1389;
						}
					}
					--esi_1148;
					ebx_1397 -= 0x3C;
				} while (esi_1148 != 0x00);
			}
			esp_1182 = fp - 0x8C;
			dwLoc40_2047.u0 = 0x00;
l08066AA8:
			if ((ecx_34 ^ gs->t0014) == 0x00)
			{
				ecxOut = ecx_1387;
				edxOut = edx_1389;
				return dwLoc40_2047;
			}
			word32 ecx_3399;
			word32 edx_3400;
			__stack_chk_fail(out ecx_3399, out edx_3400);
l08066C17:
			dwLoc60_1836 = dwLoc44_2221;
			goto l080668FA;
		}
		if (fp - 0x8C != fp - 0x8C)
		{
			do
			{
				esp_155 -= 0x1000;
				esp_155->dw0FFC = esp_155->dw0FFC;
			} while (esp_155 != fp - 0x8C);
		}
		struct Eq_52148 * esp_172 = esp_155 - 0x30;
		esp_172->dw002C = esp_172->dw002C;
		word32 esi_182 = esp_172 + 0x0F & ~0x0F;
		*esi_182 = dwArg04;
		esp_172->tFFFFFFF0 = dwArg04;
		word32 ecx_3407;
		word32 edx_3408;
		Eq_2 eax_189 = strlen(esp_172->tFFFFFFF0, out ecx_3407, out edx_3408);
		((word32) esi_182 + 0x0C)->u0 = 0x00;
		*((word32) esi_182 + 4) = eax_189;
		*((word32) esi_182 + 8) = 0x00;
		((word32) esi_182 + 16)->u0 = 0x00;
		((word32) esi_182 + 20)->u0 = 0x00;
		((word32) esi_182 + 24)->u0 = 0x00;
		dwLoc70_1805 = esi_182;
		esp_172->tFFFFFFFC = esp_172->tFFFFFFFC;
		Eq_2 edi_223 = esp_172 - (struct Eq_52218 *) 33 & ~0x0F;
		*edi_223 = ecx;
		esp_172->tFFFFFFC0 = ecx;
		word32 ecx_3409;
		word32 edx_3410;
		Eq_2 eax_233 = strlen(esp_172->tFFFFFFC0, out ecx_3409, out edx_3410);
		*((word32) esi_182 + 24) = edi_223;
		*((word32) edi_223 + 4) = eax_233;
		*((word32) edi_223 + 0x0C) = 0x00;
		*((word32) edi_223 + 8) = 0x00;
		*((word32) edi_223 + 16) = 0x00;
		*((word32) edi_223 + 20) = 0x00;
		((word32) edi_223 + 24)->u0 = 0x00;
		esp_1182 = esp_172 - (struct Eq_52264 *) 0x30;
		dwLoc84_1806 = (word32) edi_223 + 24;
	}
	else
	{
		eax_1382 = __tfind(fp - 0x30, 0x080CF940, 0x08065FD0);
		struct Eq_50727 * esp_75 = fp - 0x8C;
		if (eax_1382 != 0x00)
			goto l08066185;
		if (fp - 0x8C != fp - 0x8C)
		{
			do
			{
				esp_75 -= 0x1000;
				esp_75->dw0FFC = esp_75->dw0FFC;
			} while (esp_75 != fp - 0x8C);
		}
		struct Eq_50716 * esp_92 = esp_75 - 0x30;
		esp_92[11] = esp_92[11];
		word32 eax_99 = esp_92 + 0x0F & ~0x0F;
		*eax_99 = ecx;
		esp_92->dwFFFFFFF0 = (word32) ecx;
		word32 edx_3313;
		word32 ecx_3312;
		Eq_2 eax_111 = strlen(esp_92->dwFFFFFFF0, out ecx_3312, out edx_3313);
		((word32) eax_99 + 0x0C)->u0 = 0x00;
		*((word32) eax_99 + 4) = eax_111;
		*((word32) eax_99 + 8) = 0x00;
		((word32) eax_99 + 16)->u0 = 0x00;
		((word32) eax_99 + 20)->u0 = 0x00;
		((word32) eax_99 + 24)->u0 = 0x00;
		dwLoc70_1805 = eax_99;
		esp_1182 = esp_92;
		dwLoc84_1806 = (word32) eax_99 + 24;
		dwLoc74_1791 = ecx;
	}
	dwLoc80_2565.u0 = 0x080CF940;
	dwLoc7C_2509.u0 = 0x08065FD0;
	Eq_2 dwLoc48_1825 = 0x00;
	int32 dwLoc54_1826 = 0x7FFFFFFF;
	Eq_2 dwLoc44_1827 = dwLoc70_1805;
	Eq_2 dwLoc4C_1835 = 0x7FFFFFFF;
	dwLoc60_1836.u0 = 0x00;
l08066412:
	if (dwLoc48_1825 > dwLoc4C_1835 || dwLoc48_1825 == dwLoc4C_1835 && *((word32) dwLoc44_1827 + 8) >= dwLoc54_1826)
	{
l080663FB:
		Eq_2 eax_755 = *((word32) dwLoc44_1827 + 24);
		dwLoc44_1827 = eax_755;
		if (eax_755 != 0x00)
		{
			dwLoc48_1825 = *((word32) eax_755 + 0x0C);
			goto l08066412;
		}
		if (dwLoc60_1836 == 0x00)
		{
			dwArg08->u0 = 0x00;
			dwArg0C->u0 = 0x00;
			dwLoc40_2047.u0 = 0x01;
			esi_1148.u0 = 0x00;
			goto l08066A1B;
		}
		Eq_2 eax_772 = *((word32) dwLoc60_1836 + 24);
		if (eax_772 != 0x00)
		{
			Eq_2 edi_776 = *((word32) dwLoc60_1836 + 0x0C);
			if (*((word32) eax_772 + 0x0C) >= edi_776)
			{
				if (*((word32) eax_772 + 0x0C) == edi_776)
				{
					if (*((word32) eax_772 + 8) >= *((word32) dwLoc60_1836 + 8))
						eax_772 = dwLoc60_1836;
					dwLoc60_1836 = eax_772;
				}
			}
			else
				dwLoc60_1836 = eax_772;
		}
		Eq_2 eax_792 = *((word32) dwLoc60_1836 + 20);
		if (eax_792 != 0x00)
		{
			Eq_2 edi_944 = 0x00;
			while (true)
			{
				eax_792 = *((word32) eax_792 + 20);
				esi_1148 = (word32) edi_944 + 1;
				if (eax_792 == 0x00)
					break;
				edi_944 = esi_1148;
			}
			struct Eq_51199 * esp_958 = esp_1182 - (struct Eq_51200 *) 0x0C;
			esp_958->tFFFFFFFC = esi_1148 *s 0x3C;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_3330;
			word32 edx_3331;
			word32 ebp_3333;
			word32 edi_3335;
			word32 esi_3334;
			word32 ebx_3332;
			Eq_2 eax_969 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3330, out edx_3331, out ebx_3332, out ebp_3333, out esi_3334, out edi_3335);
			esp_1182 = esp_958 + 0x0C;
			dwLoc44_2221 = eax_969;
			if (eax_969 != 0x00)
			{
				*dwArg0C = esi_1148;
				if (esi_1148 == 0x00)
					goto l08066C17;
				Eq_2 ecx_1014 = esi_1148;
				Eq_2 dwLoc54_2230 = 0x00;
				Eq_2 esi_1017 = dwLoc60_1836;
				Eq_2 dwLoc4C_2232 = 0x00;
				Eq_2 edx_1001 = edi_944;
				struct Eq_51251 * ebx_1018 = (word32) eax_969 + edi_944 *s 0x3C;
l08066818:
				Eq_2 edi_1035;
				if (edx_1001 != 0x00)
					ebx_1018->dw000C = (word32) **((word32) esi_1017 + 20);
				else
				{
					esp_1182->dwFFFFFFF0 = (word32) dwLoc74_1791;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 eax_1023 = strdup(stackArg4);
					*((word32) eax_969 + 0x0C) = eax_1023;
					dwLoc4C_2232 = eax_1023;
					if (eax_1023 == 0x00)
					{
						edi_1035.u0 = 0x01;
l08066974:
						dwLoc40_2047.u0 = 0x00;
						if (*dwArg0C <= edi_1035)
						{
							struct Eq_51640 * esp_1143 = esp_1182 - (struct Eq_51641 *) 0x0C;
							esp_1143->tFFFFFFFC = eax_969;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 ecx_3368;
							word32 edx_3369;
							free(gs, stackArg0, stackArg4, out ecx_3368, out edx_3369);
							esp_1143->tFFFFFFFC = dwLoc4C_2232;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 edx_3373;
							word32 ecx_3372;
							free(gs, stackArg0, stackArg4, out ecx_3372, out edx_3373);
							esp_1143->tFFFFFFFC = dwLoc54_2230;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 edx_3377;
							word32 ecx_3376;
							free(gs, stackArg0, stackArg4, out ecx_3376, out edx_3377);
							dwArg0C->u0 = 0x00;
							dwArg08->u0 = 0x00;
							esi_1148.u0 = 0x00;
							esp_1182 = esp_1143 + 0x0C;
							dwLoc60_1836.u0 = 0x00;
							dwLoc40_2047.u0 = 0x01;
							goto l08066A1B;
						}
						goto l08066986;
					}
				}
				if (*dwArg0C != ecx_1014)
					ebx_1018->dw0010 = (word32) *((word32) eax_969 + (ecx_1014 * 0x3C + 0x0C));
				else
				{
					esp_1182->dwFFFFFFF0 = (word32) *esi_1017;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 eax_1060 = strdup(stackArg4);
					ebx_1018->dw0010 = (word32) eax_1060;
					dwLoc54_2230 = eax_1060;
					if (eax_1060 == 0x00)
						goto l0806696F;
				}
				Eq_2 eax_1107;
				Eq_2 eax_1078 = *((word32) esi_1017 + 16);
				ebx_1018->dw0008 = 0x01;
				ebx_1018->dw0038 = 0x00;
				byte * eax_1082 = *((word32) eax_1078 + 16);
				if (*eax_1082 != 0x2F)
				{
					esp_1182->dwFFFFFFF4 = ebx_1018;
					esp_1182->dwFFFFFFF0 = eax_1082;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					__gconv_get_builtin_trans(stackArg4, dwArg04);
					ebx_1018 -= 0x3C;
					esi_1017 = *((word32) esi_1017 + 20);
					eax_1107 = edx_1001 - 0x01;
					if (edx_1001 == 0x00)
						goto l080668EF;
					goto l08066816;
				}
				esp_1182->dwFFFFFFF0 = eax_1082;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_3342;
				Eq_2 eax_1119 = __gconv_find_shlib(gs, stackArg4, out ecx_3342);
				if (eax_1119 != 0x00)
				{
					word32 edi_1189 = *eax_1119;
					ebx_1018->dw0000 = (word32) eax_1119;
					ebx_1018->dw0004 = edi_1189;
					ebx_1018->dw0014 = (word32) *((word32) eax_1119 + 0x0C);
					Eq_2 edi_1195 = *((word32) eax_1119 + 16);
					word32 eax_1196 = *((word32) eax_1119 + 20);
					ebx_1018->dw0018 = 0x00;
					ebx_1018->dw001C = (word32) edi_1195;
					ebx_1018->dw0020 = eax_1196;
					<anonymous> * edi_1202 = __ror(edi_1195, 0x09) ^ gs->t0018;
					if (edi_1202 == null)
					{
l080668CF:
						Eq_2 edi_1359 = __rol(edi_1202 ^ gs->t0018, 0x09);
						esi_1017 = *((word32) esi_1017 + 20);
						ebx_1018->dw0018 = (word32) edi_1359;
						eax_1107 = edx_1001 - 0x01;
						ebx_1018 -= 0x3C;
						if (edx_1001 == 0x00)
						{
l080668EF:
							esi_1148 = *dwArg0C;
							dwLoc60_1836 = eax_969;
							goto l080668FA;
						}
l08066816:
						ecx_1014 = edx_1001;
						edx_1001 = eax_1107;
						goto l08066818;
					}
					esp_1182->dwFFFFFFF0 = edi_1202;
					word32 ecx_1212;
					word32 edx_1213;
					word32 eax_1211 = _dl_mcount_wrapper_check(gs, esp_1182->dwFFFFFFEC, esp_1182->dwFFFFFFF0, out ecx_1212, out edx_1213);
					esp_1182->dwFFFFFFF0 = ebx_1018;
					Eq_2 eax_1220;
					edi_1202();
					if (eax_1220 == 0x00)
					{
						edi_1202 = ebx_1018->dw0018;
						goto l080668CF;
					}
					ebx_1018->dw0020 = (word32) __rol(gs->t0018, 0x09);
					dwLoc40_2047 = eax_1220;
					edi_1035 = ecx_1014 - 0x01;
					if (*dwArg0C <= ecx_1014 - 0x01)
					{
						esp_1182->dwFFFFFFF0 = (word32) eax_969;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 edx_3346;
						word32 ecx_3345;
						free(gs, stackArg0, stackArg4, out ecx_3345, out edx_3346);
						esp_1182->dwFFFFFFF0 = (word32) dwLoc4C_2232;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 ecx_3349;
						word32 edx_3350;
						free(gs, stackArg0, stackArg4, out ecx_3349, out edx_3350);
						esp_1182->dwFFFFFFF0 = (word32) dwLoc54_2230;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 ecx_3353;
						word32 edx_3354;
						free(gs, stackArg0, stackArg4, out ecx_3353, out edx_3354);
						dwArg0C->u0 = 0x00;
						dwArg08->u0 = 0x00;
						esi_1148.u0 = 0x00;
						dwLoc60_1836.u0 = 0x00;
						goto l08066A1B;
					}
l08066986:
					Eq_2 ebx_1243 = (word32) eax_969 + edi_1035 *s 0x3C;
					do
					{
						struct Eq_51689 * esp_1246 = esp_1182 - (struct Eq_51690 *) 0x0C;
						esp_1246->tFFFFFFFC = ebx_1243;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						word32 edx_3379;
						__gconv_release_step(gs, stackArg4, out edx_3379);
						edi_1035 = (word32) edi_1035 + 1;
						ebx_1243 = (word32) ebx_1243 + 60;
					} while (edi_1035 < *dwArg0C);
					esp_1246->tFFFFFFFC = eax_969;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_3382;
					word32 edx_3383;
					free(gs, stackArg0, stackArg4, out ecx_3382, out edx_3383);
					esp_1246->tFFFFFFFC = dwLoc4C_2232;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 edx_3387;
					word32 ecx_3386;
					free(gs, stackArg0, stackArg4, out ecx_3386, out edx_3387);
					esp_1246->tFFFFFFFC = dwLoc54_2230;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_3390;
					word32 edx_3391;
					free(gs, stackArg0, stackArg4, out ecx_3390, out edx_3391);
					dwArg0C->u0 = 0x00;
					dwArg08->u0 = 0x00;
					esi_1148.u0 = 0x00;
					esp_1182 = esp_1246 + 0x0C;
					dwLoc60_1836.u0 = 0x00;
					if (dwLoc40_2047 == 0x00)
					{
						dwLoc40_2047.u0 = 0x01;
						dwLoc60_1836 = dwLoc40_2047;
						esi_1148 = dwLoc40_2047;
					}
l08066A1B:
					struct Eq_51579 * esp_1558 = esp_1182 - (struct Eq_51580 *) 0x0C;
					esp_1558->tFFFFFFFC = dwLoc74_1791;
					word32 ecx_3355;
					word32 edx_3356;
					Eq_2 eax_1565 = strlen(esp_1558->tFFFFFFFC, out ecx_3355, out edx_3356);
					esp_1558->tFFFFFFFC = eax_40;
					word32 edx_3358;
					word32 ecx_3357;
					Eq_2 eax_1578 = strlen(esp_1558->tFFFFFFFC, out ecx_3357, out edx_3358);
					esp_1558->tFFFFFFFC = (word32) eax_1565 + 0x0011 + ((word32) eax_1578 + 1);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 esi_3364;
					word32 edi_3365;
					word32 ebx_3362;
					word32 ecx_3361;
					word32 ebp_3363;
					Eq_2 eax_1606 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3361, out edx_1389, out ebx_3362, out ebp_3363, out esi_3364, out edi_3365);
					dwLoc44_2221 = (word32) eax_1578 + 1;
					esp_1182 = esp_1558 + 0x0C;
					ecx_1387 = eax_1606;
					if (eax_1606 != 0x00)
					{
						*eax_1606 = (word32) eax_1606 + 16;
						esp_1558[1] = (struct Eq_51579) ((word32) eax_1565 + 1);
						esp_1558->t0000 = dwLoc74_1791;
						esp_1558->tFFFFFFFC = (word32) eax_1606 + 16;
						word32 edx_3392;
						Eq_2 eax_1628 = __mempcpy(esp_1558->tFFFFFFFC, esp_1558->t0000, esp_1558[1], out edx_3392);
						esp_1558[1] = (struct Eq_51579) ((word32) eax_1578 + 1);
						esp_1558->t0000 = eax_40;
						esp_1558->tFFFFFFFC = eax_1628;
						word32 ecx_3393;
						word32 edx_3394;
						*((word32) eax_1606 + 4) = memcpy(esp_1558->tFFFFFFFC, esp_1558->t0000, esp_1558[1], out ecx_3393, out edx_3394);
						*((word32) eax_1606 + 0x0C) = esi_1148;
						*((word32) eax_1606 + 8) = dwLoc60_1836;
						esp_1558[1] = (struct Eq_51579) dwLoc7C_2509;
						esp_1558->t0000 = dwLoc80_2565;
						esp_1558->tFFFFFFFC = eax_1606;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						dwLoc44_2221 = eax_1606;
						esp_1182 = esp_1558 + 0x0C;
						ecx_1387 = eax_1606;
						word32 ecx_3396;
						if (__tsearch(stackArg4, dwArg04, dwArg08, out ecx_3396, out edx_1389) == null)
						{
							esp_1558->tFFFFFFFC = eax_1606;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							free(gs, stackArg0, stackArg4, out ecx_1387, out edx_1389);
							esp_1182 = esp_1558 + 0x0C;
						}
					}
					goto l08066AA8;
				}
l0806696F:
				edi_1035 = (word32) edx_1001 + 1;
				goto l08066974;
			}
		}
		else
		{
			struct Eq_51129 * esp_815 = esp_1182 - (struct Eq_51130 *) 0x0C;
			esp_815->tFFFFFFFC.u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 esi_3324;
			word32 ecx_3320;
			word32 edx_3321;
			word32 ebx_3322;
			word32 ebp_3323;
			word32 edi_3325;
			Eq_2 eax_931 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3320, out edx_3321, out ebx_3322, out ebp_3323, out esi_3324, out edi_3325);
			esp_1182 = esp_815 + 0x0C;
			dwLoc60_1836 = eax_931;
			if (eax_931 != 0x00)
			{
				dwArg0C->u0 = 0x00;
				esi_1148.u0 = 0x00;
l080668FA:
				*dwArg08 = dwLoc60_1836;
				dwLoc40_2047.u0 = 0x00;
				goto l08066A1B;
			}
		}
		dwArg0C->u0 = 0x00;
		dwArg08->u0 = 0x00;
		dwLoc60_1836.u0 = 0x00;
		esi_1148.u0 = 0x00;
		dwLoc40_2047.u0 = 0x03;
		goto l08066A1B;
	}
	Eq_2 esi_279 = __gconv_modules_db;
	if (esi_279 == 0x00)
		goto l080663FB;
	Eq_2 ebx_284 = *dwLoc44_1827;
	while (true)
	{
		struct Eq_50959 * esp_286 = esp_1182 - (struct Eq_50960 *) 0x08;
		esp_286->tFFFFFFFC = *esi_279;
		esp_286->tFFFFFFF8 = ebx_284;
		word32 edx_3315;
		word32 ecx_3314;
		Eq_2 eax_296 = strcmp(esp_286->tFFFFFFF8, esp_286->tFFFFFFFC, out ecx_3314, out edx_3315);
		esp_1182 = esp_286 + 0x08;
		bool v61_1774 = eax_296 > 0x00;
		if (eax_296 == 0x00)
			break;
		if (eax_296 < 0x00)
			esi_279 = *((word32) esi_279 + 20);
		else
			esi_279 = *((word32) esi_279 + 28);
		if (esi_279 == 0x00)
			goto l080663FB;
	}
	Eq_2 dwLoc40_1845 = esi_279;
	Eq_2 eax_309 = dwLoc48_1825;
l080664A7:
	Eq_2 ebx_314 = *((word32) dwLoc40_1845 + 4);
	cu8 * edi_313 = &g_b80A4D0B;
	word32 ecx_315 = 0x02;
	Eq_2 esi_316 = ebx_314;
	while (ecx_315 != 0x00)
	{
		v61_1774 = *esi_3411 > *edi_3412;
		esi_316 = (word32) esi_3411 + 1;
		edi_313 = edi_3412 + 1;
		--ecx_315;
		esi_3411 = esi_316;
		edi_3412 = edi_313;
		if (*esi_3411 == *edi_3412)
			break;
	}
	if ((int8) v61_1774 - (byte) (*esi_3411 < *edi_3412) == 0x00)
		ebx_314 = eax_40;
	word32 eax_347 = eax_309 + Mem311[dwLoc40_1845 + 0x08:word32];
	struct Eq_51098 * esp_352 = esp_1182 - (struct Eq_51099 *) 0x08;
	word32 esi_357 = Mem311[dwLoc44_1827 + 0x08:word32] + Mem311[dwLoc40_1845 + 0x0C:word32];
	esp_352->tFFFFFFFC = eax;
	esp_352->tFFFFFFF8 = ebx_314;
	word32 edx_3317;
	word32 ecx_3316;
	if (strcmp(esp_352->tFFFFFFF8, esp_352->tFFFFFFFC, out ecx_3316, out edx_3317) != 0x00)
	{
		if (edx != 0x00)
		{
			esp_352->tFFFFFFFC = edx;
			esp_352->tFFFFFFF8 = ebx_314;
			word32 ecx_3401;
			word32 edx_3402;
			if (strcmp(esp_352->tFFFFFFF8, esp_352->tFFFFFFFC, out ecx_3401, out edx_3402) == 0x00)
				goto l080664F0;
		}
		if (dwLoc4C_1835 > eax_347 || dwLoc4C_1835 == eax_347 && dwLoc54_1826 > esi_357)
		{
			Eq_2 esi_412 = dwLoc70_1805;
			do
			{
				struct Eq_51947 * esp_414 = esp_1182 - (struct Eq_51948 *) 0x08;
				esp_414->tFFFFFFFC = *esi_412;
				esp_414->tFFFFFFF8 = ebx_314;
				esp_1182 = esp_414 + 0x08;
				word32 edx_3404;
				word32 ecx_3403;
				if (strcmp(esp_414->tFFFFFFF8, esp_414->tFFFFFFFC, out ecx_3403, out edx_3404) == 0x00)
				{
					if (*((word32) esi_412 + 0x0C) > eax_347 || *((word32) esi_412 + 0x0C) == eax_347 && *((word32) esi_412 + 8) > esi_357)
					{
						*((word32) esi_412 + 16) = dwLoc40_1845;
						*((word32) esi_412 + 20) = dwLoc44_1827;
						Eq_2 esi_451 = dwLoc70_1805;
						do
						{
							Eq_2 eax_454 = *((word32) esi_451 + 16);
							if (eax_454 != 0x00)
							{
								Eq_2 edx_462 = *((word32) esi_451 + 20);
								Eq_2 ebx_463 = *((word32) eax_454 + 8);
								int32 ecx_464 = *((word32) eax_454 + 0x0C);
								struct Eq_52079 * eax_465 = *((word32) edx_462 + 16);
								while (eax_465 != null)
								{
									edx_462 = *((word32) edx_462 + 20);
									ebx_463 = (word32) ebx_463 + eax_465->dw0008;
									ecx_464 += eax_465->dw000C;
									eax_465 = (struct Eq_52079 *) *((word32) edx_462 + 16);
								}
								*((word32) esi_451 + 0x0C) = ebx_463;
								*((word32) esi_451 + 8) = ecx_464;
								esi_451 = *((word32) esi_451 + 24);
								if (esi_451 == 0x00)
									break;
								continue;
							}
							esi_451 = *((word32) esi_451 + 24);
						} while (esi_451 != 0x00);
						Eq_2 eax_498 = dwLoc60_1836;
						if (dwLoc60_1836 != 0x00)
						{
							Eq_2 esi_502 = dwLoc4C_1835;
							int32 ebx_503 = dwLoc54_1826;
							do
							{
								Eq_2 ecx_507 = *((word32) eax_498 + 20);
								Eq_2 edi_506 = *((word32) eax_498 + 16);
								word32 edx_510 = Mem505[ecx_507 + 0x0C:word32] + Mem505[edi_506 + 0x08:word32];
								word32 ecx_511 = Mem505[ecx_507 + 0x08:word32] + Mem505[edi_506 + 0x0C:word32];
								*((word32) eax_498 + 0x0C) = edx_510;
								*((word32) eax_498 + 8) = ecx_511;
								if (edx_510 >= esi_502)
								{
									if (edx_510 == esi_502 && ecx_511 < ebx_503)
										ebx_503 = ecx_511;
									eax_498 = *((word32) eax_498 + 24);
									if (eax_498 != 0x00)
										continue;
									break;
								}
								eax_498 = *((word32) eax_498 + 24);
								ebx_503 = ecx_511;
								esi_502 = edx_510;
							} while (eax_498 != 0x00);
							dwLoc4C_1835 = esi_502;
							dwLoc54_1826 = ebx_503;
						}
					}
					goto l08066490;
				}
				esi_412 = *((word32) esi_412 + 24);
			} while (esi_412 != 0x00);
			if (esp_414 + 0x08 != esp_414 + 0x08)
			{
				do
				{
					esp_1182 -= (struct Eq_52032 *) 0x1000;
					esp_1182[0x03FF] = esp_1182[0x03FF];
				} while (esp_1182 != esp_414 + 0x08);
			}
			struct Eq_50716 * esp_560 = esp_1182 - (struct Eq_51979 *) 0x30;
			esp_560[11] = esp_560[11];
			word32 edx_567 = esp_560 + 0x0F & ~0x0F;
			edx_567->t0000 = ebx_314;
			esp_560->dwFFFFFFF0 = (word32) ebx_314;
			word32 edx_3406;
			word32 ecx_3405;
			Eq_2 eax_576 = strlen(esp_560->dwFFFFFFF0, out ecx_3405, out edx_3406);
			edx_567->t000C = eax_347;
			edx_567->t0004 = eax_576;
			edx_567->dw0018 = 0x00;
			edx_567->dw0008 = esi_357;
			edx_567->t0010 = dwLoc40_1845;
			edx_567->t0014 = dwLoc44_1827;
			*dwLoc84_1806 = edx_567;
			esp_1182 = esp_560;
			dwLoc84_1806 = &edx_567->dw0018;
		}
		goto l08066490;
	}
	else
	{
l080664F0:
		if (dwLoc60_1836 != 0x00)
		{
			Eq_2 esi_608 = dwLoc60_1836;
			do
			{
				struct Eq_51171 * esp_610 = esp_1182 - (struct Eq_51172 *) 0x08;
				esp_610->tFFFFFFFC = *esi_608;
				esp_610->tFFFFFFF8 = ebx_314;
				esp_1182 = esp_610 + 0x08;
				word32 ecx_3326;
				word32 edx_3327;
				if (strcmp(esp_610->tFFFFFFF8, esp_610->tFFFFFFFC, out ecx_3326, out edx_3327) == 0x00)
				{
					if (*((word32) esi_608 + 0x0C) > eax_347 || *((word32) esi_608 + 0x0C) == eax_347 && *((word32) esi_608 + 8) > esi_357)
					{
						*((word32) esi_608 + 0x0C) = eax_347;
						*((word32) esi_608 + 16) = dwLoc40_1845;
						*((word32) esi_608 + 20) = dwLoc44_1827;
						*((word32) esi_608 + 8) = esi_357;
					}
					goto l0806652C;
				}
				esi_608 = *((word32) esi_608 + 24);
			} while (esi_608 != 0x00);
		}
		struct Eq_50716 * esp_650 = esp_1182 - (struct Eq_51299 *) 0x30;
		esp_650[11] = esp_650[11];
		word32 edx_658 = esp_650 + 0x0F & ~0x0F;
		*edx_658 = ebx_314;
		esp_650->dwFFFFFFF0 = (word32) ebx_314;
		word32 edx_3337;
		word32 ecx_3336;
		Eq_2 eax_669 = strlen(esp_650->dwFFFFFFF0, out ecx_3336, out edx_3337);
		*((word32) edx_658 + 0x0C) = eax_347;
		*((word32) edx_658 + 4) = eax_669;
		*((word32) edx_658 + 8) = esi_357;
		*((word32) edx_658 + 16) = dwLoc40_1845;
		*((word32) edx_658 + 20) = dwLoc44_1827;
		*((word32) edx_658 + 24) = dwLoc60_1836;
		esp_1182 = esp_650;
		dwLoc60_1836 = edx_658;
l0806652C:
		if (dwLoc4C_1835 <= eax_347)
		{
			if (dwLoc4C_1835 == eax_347)
			{
				int32 eax_726 = esi_357;
				if (dwLoc54_1826 <= esi_357)
					eax_726 = dwLoc54_1826;
				dwLoc54_1826 = eax_726;
			}
		}
		else
		{
			dwLoc4C_1835 = eax_347;
			dwLoc54_1826 = esi_357;
		}
l08066490:
		Eq_2 eax_736 = *((word32) dwLoc40_1845 + 24);
		dwLoc40_1845 = eax_736;
		v61_1774 = eax_736 > 0x00;
		if (eax_736 == 0x00)
			goto l080663FB;
		eax_309 = *((word32) dwLoc44_1827 + 0x0C);
		goto l080664A7;
	}
}

// 08066C30: Register Eq_2 __gconv_compare_alias(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_52290) ebxOut, Register out (ptr32 Eq_52291) ebpOut, Register out (ptr32 Eq_52292) esiOut)
// Called from:
//      _nl_find_locale
Eq_2 __gconv_compare_alias(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_52290 & ebxOut, struct Eq_52291 & ebpOut, struct Eq_52292 & esiOut)
{
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 esi_23 = dwArg04;
	Eq_2 edi_24 = dwArg08;
	if (once == 0x00)
	{
		struct Eq_52348 * ebx_35 = __gconv_read_conf(gs, out esi_23, out edi_24);
		ebx_35->dw193C |= 0x02;
	}
	Eq_2 eax_166;
	word32 ebx_78;
	Eq_2 edi_80;
	Eq_2 esi_82;
	if (__gconv_compare_alias_cache(gs, esi_23, edi_24, fp - 44, out ebx_78, out esi_82, out edi_80) == 0x00)
		eax_166 = dwLoc2C;
	else
	{
		Eq_2 ebx_120 = edi_80;
		Eq_2 eax_107 = __tfind(fp - 0x28, ebx_78 + 8068, ebx_78 + ~0x0006804F);
		if (eax_107 != 0x00)
		{
			ebx_120 = *((word32) *eax_107 + 4);
			if (ebx_120 == 0x00)
				ebx_120 = edi_80;
		}
		Eq_2 eax_149;
		Eq_2 eax_139 = __tfind(fp - 0x28, ebx_78 + 8068, ebx_78 + ~0x0006804F);
		if (eax_139 != 0x00)
		{
			eax_149 = *((word32) *eax_139 + 4);
			if (eax_149 == 0x00)
				eax_149 = esi_82;
		}
		else
			eax_149 = esi_82;
		word32 ecx_299;
		word32 edx_300;
		eax_166 = strcmp(eax_149, ebx_120, out ecx_299, out edx_300);
	}
	if ((eax_20 ^ gs->t0014) != 0x00)
	{
		word32 edx_298;
		word32 ecx_297;
		Eq_2 eax_186 = __stack_chk_fail(out ecx_297, out edx_298);
		Eq_2 esp_187 = <invalid>;
		struct Eq_52291 * ebp_196;
		struct Eq_52290 * ebx_197;
		struct Eq_52292 * esi_203;
		__gconv_find_transform(gs, *((word32) esp_187 + 4), *((word32) esp_187 + 8), *((word32) esp_187 + 0x0C), *((word32) esp_187 + 16), *((word32) esp_187 + 20), out ebx_197, out ebp_196, out esi_203);
		ebxOut = ebx_197;
		ebpOut = ebp_196;
		esiOut = esi_203;
		return eax_186;
	}
	else
	{
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		return eax_166;
	}
}

// 08066D60: Register Eq_2 __gconv_find_transform(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out Eq_952 ebxOut, Register out Eq_952 ebpOut, Register out Eq_41612 esiOut)
// Called from:
//      __wcsmbs_getfct
//      __gconv_open
//      __gconv_compare_alias
Eq_2 __gconv_find_transform(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, union Eq_952 & ebxOut, union Eq_952 & ebpOut, union Eq_41612 & esiOut)
{
	byte bArg14_521 = (byte) dwArg14;
	Eq_2175 eax_27 = gs->t0014;
	if (once == 0x00)
	{
		word32 edi_722;
		word32 esi_721;
		__gconv_read_conf(gs, out esi_721, out edi_722);
		once |= 0x02;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_70;
	if (!__cmpxchg(__gconv_lock, 0x01, 0x00, out eax_70))
		__lll_lock_wait_private(eax_70, 0x080CFF80, gs);
	Eq_2 ecx_114;
	Eq_2 eax_113 = __gconv_lookup_cache(gs, dwArg04, dwArg08, dwArg0C, dwArg10, (byte) dwArg14, out ecx_114);
	Eq_2 edx_118 = eax_113;
	if (eax_113 == 0x02)
	{
		Eq_2 edx_134 = __gconv_modules_db;
		if (edx_134 != 0x00)
		{
			Eq_2 eax_166 = __tfind(fp - 0x28, 0x080CFF84, 0x08065FB0);
			Eq_2 edx_176 = eax_166;
			if (eax_166 != 0x00)
				edx_176 = *((word32) *eax_166 + 4);
			Eq_2 eax_196 = __tfind(fp - 0x28, 0x080CFF84, 0x08065FB0);
			Eq_2 ebp_206 = eax_196;
			if (eax_196 != 0x00)
				ebp_206 = *((word32) *eax_196 + 4);
			if ((bArg14_521 & 0x01) == 0x00)
			{
l08066E84:
				Eq_2 ecx_361;
				word32 edx_723;
				Eq_2 eax_360 = find_derivation(dwArg04, dwArg08, ebp_206, gs, edx_176, dwArg0C, dwArg10, out ecx_361, out edx_723);
				edx_118 = eax_360;
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v24_369 = __gconv_lock - 0x01;
				__gconv_lock = v24_369;
				if (v24_369 != 0x00)
					__lll_unlock_wake_private(0x080CFF80, ecx_361, eax_360, gs);
				if (eax_360 == 0x00)
					edx_118 = (uint32) (int8) (*dwArg0C == 0x00);
				goto l08066EF7;
			}
			Eq_2 ecx_227;
			Eq_2 edx_228;
			if (strcmp(dwArg04, dwArg08, out ecx_227, out edx_228) != 0x00)
			{
				if (ebp_206 != 0x00)
				{
					edx_228 = edx_176;
					word32 edx_730;
					if (strcmp(ebp_206, dwArg08, out ecx_227, out edx_730) == 0x00)
						goto l08066FE8;
				}
				if (edx_176 == 0x00)
					goto l08066E84;
				if (strcmp(dwArg04, edx_176, out ecx_227, out edx_228) != 0x00)
				{
					if (ebp_206 == 0x00)
						goto l08066E84;
					edx_228 = edx_176;
					word32 edx_731;
					if (strcmp(ebp_206, edx_176, out ecx_227, out edx_731) != 0x00)
						goto l08066E84;
				}
			}
l08066FE8:
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v26_321 = __gconv_lock - 0x01;
			__gconv_lock = v26_321;
			if (v26_321 != 0x00)
				__lll_unlock_wake_private(0x080CFF80, ecx_227, edx_228, gs);
			edx_118.u0 = ~0x00;
			goto l08066EF7;
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v20_142 = __gconv_lock - 0x01;
		__gconv_lock = v20_142;
		if (v20_142 != 0x00)
			__lll_unlock_wake_private(0x080CFF80, ecx_114, edx_134, gs);
		edx_118.u0 = 0x01;
	}
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v23_125 = __gconv_lock - 0x01;
		__gconv_lock = v23_125;
		if (v23_125 != 0x00)
			__lll_unlock_wake_private(0x080CFF80, ecx_114, eax_113, gs);
	}
l08066EF7:
	Eq_41612 esi_408 = eax_27 ^ gs->t0014;
	if (esi_408 != 0x00)
	{
		word32 edx_725;
		word32 ecx_724;
		__stack_chk_fail(out ecx_724, out edx_725);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		word32 edx_729;
		Eq_2 eax_453 = __gconv_close_transform(edx, gs, stackArg4, stackArg8, out edx_729);
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi_408;
		return eax_453;
	}
	else
	{
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		return edx_118;
	}
}

// 08067020: Register word32 __gconv_close_transform(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 edxOut)
// Called from:
//      _nl_cleanup_ctype
//      __wcsmbs_getfct
//      __wcsmbs_load_conv
//      __wcsmbs_named_conv
//      __gconv_open
//      __gconv_close
//      __gconv_find_transform
word32 __gconv_close_transform(Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & edxOut)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_30;
	if (!__cmpxchg(__gconv_lock, 0x01, 0x00, out eax_30))
		__lll_lock_wait_private(eax_30, 0x080CFF80, gs);
	if (dwArg08 != 0x00)
	{
		Eq_2 ebx_49 = dwArg04 - 0x3C + dwArg08 *s 0x3C;
		while (true)
		{
			word32 edx_177;
			__gconv_release_step(gs, ebx_49, out edx_177);
			Eq_2 eax_64 = ebx_49 - 0x3C;
			if (ebx_49 == dwArg04)
				break;
			ebx_49 = eax_64;
		}
	}
	Eq_2 ecx_91 = __gconv_release_cache();
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v14_97 = __gconv_lock - 0x01;
	__gconv_lock = v14_97;
	if (v14_97 != 0x00)
		__lll_unlock_wake_private(0x080CFF80, ecx_91, edx, gs);
	edxOut = edx;
	return 0x00;
}

// 080670C0: void insert_module(Register Eq_2 eax, Register word32 edx)
// Called from:
//      add_module.isra.0
//      __gconv_read_conf
void insert_module(Eq_2 eax, word32 edx)
{
	struct Eq_52726 * esi_144 = &__gconv_modules_db;
	while (true)
	{
		Eq_2 ebx_143 = esi_144->dw0000;
		if (ebx_143 == 0x00)
			break;
		Eq_2 edi_33 = *eax;
		word32 edx_281;
		word32 ecx_280;
		Eq_2 eax_42 = strcmp(edi_33, *ebx_143, out ecx_280, out edx_281);
		if (eax_42 == 0x00)
		{
			while (true)
			{
				word32 ecx_282;
				word32 edx_283;
				if (strcmp(*((word32) eax + 4), *((word32) ebx_143 + 4), out ecx_282, out edx_283) == 0x00)
					break;
				do
				{
					esi_144 = (word32) ebx_143 + 24;
					ebx_143 = *((word32) ebx_143 + 24);
					if (ebx_143 == 0x00)
						goto l0806710C;
					word32 ecx_284;
					word32 edx_285;
				} while (strcmp(edi_33, *ebx_143, out ecx_284, out edx_285) != 0x00);
			}
			int32 eax_76 = *((word32) ebx_143 + 8);
			if (*((word32) eax + 8) < eax_76 || *((word32) eax + 8) == eax_76 && *((word32) eax + 0x0C) < *((word32) ebx_143 + 0x0C))
			{
				*((word32) eax + 20) = *((word32) ebx_143 + 20);
				*((word32) eax + 28) = *((word32) ebx_143 + 28);
				*((word32) eax + 24) = *((word32) ebx_143 + 24);
				esi_144->dw0000 = (word32) eax;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ecx_288;
				word32 edx_289;
				free(gs, stackArg0, ebx_143, out ecx_288, out edx_289);
				return;
			}
			else
			{
				if (edx != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 ecx_291;
					word32 edx_292;
					free(gs, stackArg0, eax, out ecx_291, out edx_292);
				}
				return;
			}
		}
		esi_144 = (word32) ebx_143 + 20;
		if (eax_42 >= 0x00)
			esi_144 = (word32) ebx_143 + 28;
	}
l0806710C:
	esi_144->dw0000 = (word32) eax;
}

// 080671B0: Register Eq_2 detect_conflict(Register Eq_2 eax)
// Called from:
//      __gconv_read_conf
Eq_2 detect_conflict(Eq_2 eax)
{
	Eq_2 ebx_13 = __gconv_modules_db;
	while (ebx_13 != 0x00)
	{
		word32 ecx_98;
		word32 edx_99;
		Eq_2 eax_30 = strcmp(eax, *ebx_13, out ecx_98, out edx_99);
		if (eax_30 == 0x00)
			return 0x01;
		if (eax_30 < 0x00)
		{
			ebx_13 = *((word32) ebx_13 + 20);
			if (ebx_13 == 0x00)
				return 0x00;
			continue;
		}
		ebx_13 = *((word32) ebx_13 + 28);
	}
	return 0x00;
}

// 08067210: void add_module.isra.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __gconv_read_conf
void add_module.isra.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_12 = eax;
	int32 ecx_888 = (int32) *eax;
	Eq_2175 eax_29 = gs->t0014;
	Eq_2 eax_32 = g_t80CE08C;
	while ((*((word32) eax_32 + (ecx_888 * 0x02 + 1)) & 0x20) != 0x00)
	{
		edi_12 = (word32) edi_12 + 1;
		ecx_888 = (int32) *edi_12;
	}
	if ((byte) ecx_888 != 0x00)
	{
		Eq_2 ebx_520 = edi_12;
		Eq_3803 ecx_58[] = g_ptr80CE084;
		while (true)
		{
			*ebx_520 = ecx_58[ecx_888];
			ecx_888 = (int32) *((word32) ebx_520 + 1);
			Eq_2 esi_64 = (word32) ebx_520 + 1;
			if ((byte) ecx_888 == 0x00)
				break;
			if ((*((word32) eax_32 + (ecx_888 * 0x02 + 1)) & 0x20) != 0x00)
			{
				Eq_2 ebx_111;
				int32 edx_108 = (int32) *((word32) esi_64 + 1);
				*esi_64 = 0x00;
				Eq_2 ebx_77 = (word32) ebx_520 + 2;
				byte bLoc34_605 = (byte) edx_108;
				ebx_111 = ebx_77;
				if ((*((word32) eax_32 + (edx_108 * 0x02 + 1)) & 0x20) != 0x00)
				{
					ebx_111 = ebx_77;
					do
					{
						ebx_111 = (word32) ebx_111 + 1;
						int32 esi_89 = (int32) *ebx_111;
						edx_108 = esi_89;
						byte dl_95 = (byte) esi_89;
					} while ((*((word32) eax_32 + (esi_89 * 0x02 + 1)) & 0x20) != 0x00);
					bLoc34_605 = dl_95;
				}
				struct Eq_52994 * esi_101 = (word32) ebx_77 + 2;
				if (bLoc34_605 != 0x00)
				{
					while (true)
					{
						struct Eq_52994 * edi_114 = &esi_101->b0001;
						edi_114->tFFFFFFFF = ecx_58[edx_108];
						ebx_111 = (word32) ebx_111 + 1;
						edx_108 = (int32) *ebx_111;
						if ((byte) edx_108 == 0x00)
							break;
						if ((*((word32) eax_32 + (edx_108 * 0x02 + 1)) & 0x20) != 0x00)
						{
							edi_114->b0000 = 0x00;
							Eq_2 ecx_128 = &esi_101->b0000;
							do
							{
								ebx_111 = (word32) ebx_111 + 1;
								int32 ecx_137 = (int32) *ebx_111;
								byte cl_143 = (byte) ecx_137;
								byte dl_156 = (byte) ecx_137;
							} while ((*((word32) eax_32 + (ecx_137 * 0x02 + 1)) & 0x20) != 0x00);
							Eq_2 dwLoc48_620;
							struct Eq_53072 * esi_176;
							Eq_2 ecx_148;
							if (cl_143 != 0x00)
							{
								Eq_2 esi_149 = (word32) ecx_128 + 2;
								while (true)
								{
									ecx_148 = (word32) esi_149 + 1;
									*((word32) ecx_148 - 1) = dl_156;
									ebx_111 = (word32) ebx_111 + 1;
									dl_156 = (byte) *ebx_111;
									if (dl_156 == 0x00)
										break;
									if ((*((word32) eax_32 + ((int32) dl_156 * 0x02 + 1)) & 0x20) != 0x00)
									{
										*ecx_148 = 0x00;
										Eq_2 eax_183 = __strtol(gs, ebx_111, fp - 0x28, 0x0A);
										esi_176 = (struct Eq_53072 *) esi_149;
										dwLoc48_620 = eax_183;
										if (dwLoc28 == ebx_111 || eax_183 <= 0x00)
											dwLoc48_620.u0 = 0x01;
										goto l08067370;
									}
									esi_149 = ecx_148;
								}
							}
							else
								ecx_148 = ecx_128;
							*ecx_148 = 0x00;
							esi_176 = (word32) ecx_148 + 1;
							dwLoc48_620.u0 = 0x01;
l08067370:
							byte al_209 = edi_114->b0001;
							if (al_209 != 0x00)
							{
								Eq_2 eax_214 = 0x00;
								if (al_209 != 0x2F)
									eax_214 = ecx;
								ui32 dwLoc40_635 = 0x03;
								Eq_2 eax_225 = esi_176 - ecx_128;
								if (eax_225 > 0x03)
									dwLoc40_635 = (uint32) (int8) (esi_176->tFFFFFFFC != 7303982) * 0x03;
								Eq_2 eax_253 = ebx_77 - edi_12;
								word32 ecx_889;
								word32 edx_890;
								Eq_2 eax_260 = strnlen(edi_12, eax_253, out ecx_889, out edx_890);
								struct Eq_53152 * esp_267 = fp - 0x5C;
								struct Eq_53152 * ebx_272 = fp - 0x5C - ((word32) eax_260 + 28 & ~0x0FFF);
								ui32 ecx_273 = (word32) eax_260 + 28 & ~0x0F;
								if (fp - 0x5C != ebx_272)
								{
									do
									{
										esp_267 -= 0x1000;
										esp_267->dw0FFC = esp_267->dw0FFC;
									} while (esp_267 != ebx_272);
								}
								if ((ecx_273 & 0x0FFF) != 0x00)
								{
									esp_267 -= ecx_273 & 0x0FFF;
									(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_267 - 0x04)[(ecx_273 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_267 - 0x04)[(ecx_273 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
								}
								Eq_53195 edx_300 = (char *) esp_267 + 0x0F;
								Mem313[(edx_300 & ~0x0F) + eax_260:byte] = 0x00;
								struct Eq_53203 * esp_301 = esp_267 - 0x04;
								esp_301->tFFFFFFFC = eax_260;
								esp_301->tFFFFFFF8 = edi_12;
								esp_301->tFFFFFFF4 = edx_300 & ~0x0F;
								word32 edx_892;
								word32 ecx_891;
								memcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out ecx_891, out edx_892);
								esp_301->tFFFFFFFC.u0 = 0x08065FB0;
								esp_301->tFFFFFFF8.u0 = 0x080CFF84;
								esp_301->tFFFFFFF4 = fp - 0x28;
								if (__tfind(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC) == 0x00)
								{
									esp_301->tFFFFFFF8 = esi_176 - edi_12 + ((word32) eax_214 + 32) + dwLoc40_635;
									esp_301->tFFFFFFF4.u0 = 0x01;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg4 = <invalid>;
									word32 edx_895;
									word32 ecx_894;
									word32 edi_899;
									word32 ebx_896;
									word32 ebp_897;
									word32 esi_898;
									Eq_2 eax_390 = __libc_calloc(gs, stackArg4, dwArg04, out ecx_894, out edx_895, out ebx_896, out ebp_897, out esi_898, out edi_899);
									if (eax_390 != 0x00)
									{
										*eax_390 = (word32) eax_390 + 32;
										esp_301->tFFFFFFFC = eax_253;
										esp_301->tFFFFFFF8 = edi_12;
										esp_301->tFFFFFFF4 = (word32) eax_390 + 32;
										word32 edx_900;
										Eq_2 eax_412 = __mempcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out edx_900);
										*((word32) eax_390 + 4) = eax_412;
										esp_301->tFFFFFFFC = ecx_128 - ebx_77;
										esp_301->tFFFFFFF8 = ebx_77;
										esp_301->tFFFFFFF4 = eax_412;
										word32 edx_901;
										Eq_2 eax_432 = __mempcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out edx_901);
										*((word32) eax_390 + 16) = eax_432;
										*((word32) eax_390 + 8) = dwLoc48_620;
										*((word32) eax_390 + 0x0C) = dwArg04;
										if (eax_214 != 0x00)
										{
											esp_301->tFFFFFFFC = eax_214;
											esp_301->tFFFFFFF8 = edx;
											esp_301->tFFFFFFF4 = eax_432;
											word32 edx_902;
											eax_432 = __mempcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out edx_902);
										}
										struct Eq_53376 * esp_472 = esp_267 - 0x04;
										esp_472->tFFFFFFFC = eax_225;
										esp_472->tFFFFFFF8 = ecx_128;
										esp_472->tFFFFFFF4 = eax_432;
										word32 edx_903;
										Eq_2 eax_487 = __mempcpy(esp_472->tFFFFFFF4, esp_472->tFFFFFFF8, esp_472->tFFFFFFFC, out edx_903);
										if (dwLoc40_635 != 0x00)
											*((word32) eax_487 - 1) = gconv_module_ext;
										insert_module(eax_390, 0x01);
									}
								}
							}
							break;
						}
						esi_101 = edi_114;
					}
				}
				break;
			}
			ebx_520 = esi_64;
		}
	}
	if ((eax_29 ^ gs->t0014) == 0x00)
		return;
	struct Eq_52957 * edx_574;
	byte * ecx_575;
	Eq_2 eax_573 = __stack_chk_fail(out ecx_575, out edx_574);
	add_alias2.isra.1.part.2(eax_573, ecx_575, edx_574);
}

// 08067580: void add_alias2.isra.1.part.2(Register Eq_2 eax, Register (ptr32 byte) ecx, Register (ptr32 Eq_52957) edx)
// Called from:
//      add_module.isra.0
//      __gconv_read_conf
void add_alias2.isra.1.part.2(Eq_2 eax, byte * ecx, struct Eq_52957 * edx)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 ecx_9 = ecx - eax;
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_148;
	word32 edx_149;
	word32 ebx_150;
	word32 ebp_151;
	word32 esi_152;
	word32 edi_153;
	Eq_2 eax_31 = __libc_malloc(gs, stackArg0, (word32) ecx_9 + 8, out ecx_148, out edx_149, out ebx_150, out ebp_151, out esi_152, out edi_153);
	if (eax_31 != 0x00)
	{
		word32 ecx_154;
		word32 edx_155;
		Eq_2 eax_48 = memcpy((word32) eax_31 + 8, eax, ecx_9, out ecx_154, out edx_155);
		*eax_31 = eax_48;
		*((word32) eax_31 + 4) = (word32) eax_48 + (edx - eax);
		word32 ecx_156;
		word32 edx_157;
		union Eq_2 * eax_72 = __tsearch(eax_31, 0x080CFF84, 0x08065FB0, out ecx_156, out edx_157);
		if (eax_72 == null || eax_31 != *eax_72)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_159;
			word32 edx_160;
			free(gs, stackArg0, eax_31, out ecx_159, out edx_160);
		}
	}
}

// 08067600: void __gconv_get_path(Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      __gconv_read_conf
void __gconv_get_path(Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 ecx_36 = 0x01;
	struct Eq_53487 * esp_20 = fp - 0x4C;
	Eq_2175 eax_22 = gs->t0014;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_31;
	if (!__cmpxchg(lock.12667, 0x01, 0x00, out eax_31))
		ecx_36 = __lll_lock_wait_private(eax_31, 0x080CF948, gs);
	Eq_2 esi_259 = __gconv_path_elem;
	if (esi_259 == 0x00)
	{
		Eq_2 dwLoc40_647;
		Eq_2 dwLoc44_648;
		int32 dwLoc48_646;
		struct Eq_53519 * esp_201;
		word32 dwLoc3C_650;
		Eq_2 eax_47 = __gconv_path_envvar;
		Eq_2 dwLoc34_645 = eax_47;
		if (eax_47 != 0x00)
		{
			word32 ecx_835;
			word32 edx_836;
			Eq_2 eax_105 = strlen(eax_47, out ecx_835, out edx_836);
			struct Eq_53552 * esp_112 = fp - 0x4C;
			dwLoc3C_650 = (word32) eax_105 + 16;
			struct Eq_53552 * edi_119 = fp - 0x4C - ((word32) eax_105 + 43 & ~0x0FFF);
			ui32 ecx_120 = (word32) eax_105 + 43 & ~0x0F;
			while (esp_112 != edi_119)
			{
				esp_112 -= 0x1000;
				esp_112->dw0FFC = esp_112->dw0FFC;
			}
			if ((ecx_120 & 0x0FFF) != 0x00)
			{
				esp_112 -= ecx_120 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_112 - 0x04)[(ecx_120 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_112 - 0x04)[(ecx_120 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			struct Eq_53897 * esp_141 = esp_112 - 0x04;
			esp_141->tFFFFFFFC = eax_105;
			esp_141->tFFFFFFF8 = eax_47;
			Eq_53906 edx_140 = (char *) esp_112 + 0x0F;
			esp_141->tFFFFFFF4 = edx_140 & ~0x0F;
			word32 edx_859;
			Eq_2 eax_157 = __mempcpy(esp_141->tFFFFFFF4, esp_141->tFFFFFFF8, esp_141->tFFFFFFFC, out edx_859);
			word32 ecx_167 = g_dw80A4EAC;
			*eax_157 = 0x3A;
			*((word32) eax_157 + 1) = ecx_167;
			*((word32) eax_157 + 5) = g_t80A4EB0;
			*((word32) eax_157 + 9) = g_t80A4EB4;
			*((word32) eax_157 + 0x0D) = g_t80A4EB8;
			*((word32) eax_157 + 0x0F) = g_t80A4EBA;
			esp_141->tFFFFFFF8.u0 = 0x00;
			esp_141->tFFFFFFF4.u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 edx_862;
			word32 edi_863;
			Eq_2 eax_198 = getcwd(gs, stackArg4, stackArg8, out edx_862, out edi_863);
			esp_201 = (struct Eq_53519 *) ((char *) &esp_141->tFFFFFFFC + 8);
			dwLoc34_645 = eax_198;
			if (eax_198 != 0x00)
			{
				esp_141->tFFFFFFF4 = eax_198;
				word32 ecx_864;
				word32 edx_865;
				Eq_2 eax_215 = strlen(esp_141->tFFFFFFF4, out ecx_864, out edx_865);
				esp_201 = (struct Eq_53519 *) ((char *) &esp_141->tFFFFFFFC + 8);
				dwLoc40_647 = eax_215;
				dwLoc44_648 = edx_140 & ~0x0F;
				dwLoc48_646 = (word32) eax_215 + 1;
			}
			else
			{
				dwLoc48_646 = 0x01;
				dwLoc40_647.u0 = 0x00;
				dwLoc44_648 = edx_140 & ~0x0F;
			}
		}
		else
		{
			if (fp - 0x4C != fp - 0x4C)
			{
				do
				{
					esp_20 -= 0x1000;
					esp_20->dw0FFC = esp_20->dw0FFC;
				} while (esp_20 != fp - 0x4C);
			}
			esp_201 = esp_20 - 0x20;
			esp_201->dw001C = esp_201->dw001C;
			word32 eax_78 = esp_201 + 0x0F & ~0x0F;
			*eax_78 = g_dw80A4EAC;
			*((word32) eax_78 + 4) = g_t80A4EB0;
			*((word32) eax_78 + 8) = g_t80A4EB4;
			*((word32) eax_78 + 0x0C) = g_t80A4EB8;
			*((word32) eax_78 + 0x0E) = g_t80A4EBA;
			dwLoc48_646 = 0x01;
			dwLoc40_647.u0 = 0x00;
			dwLoc44_648 = eax_78;
			dwLoc3C_650 = 0x0F;
		}
		int32 edx_249;
		int32 esi_252;
		ui32 ecx_253;
		struct Eq_53643 * esp_230 = esp_201 - (struct Eq_53644 *) 0x08;
		esp_230->tFFFFFFFC.u0 = 0x3A;
		esp_230->tFFFFFFF8 = dwLoc44_648;
		word32 ecx_837;
		word32 edx_838;
		Eq_2 eax_238 = strchr(esp_230->tFFFFFFF8, esp_230->t0004, out ecx_837, out edx_838);
		if (eax_238 != 0x00)
		{
			int32 ecx_255 = 0x01;
			Eq_2 edi_256 = eax_238;
			while (true)
			{
				int32 eax_258 = ecx_255 + 0x01;
				int32 dwLoc38_664 = eax_258;
				if (edi_256 != (word32) esi_259 + 1)
				{
					ecx_255 = eax_258;
					dwLoc38_664 = ecx_255 + 0x02;
				}
				struct Eq_53722 * esp_271 = esp_201 - (struct Eq_53723 *) 0x08;
				esp_271->tFFFFFFFC.u0 = 0x3A;
				esp_271->tFFFFFFF8 = (word32) edi_256 + 1;
				esi_259 = edi_256;
				word32 ecx_851;
				word32 edx_852;
				Eq_2 eax_283 = strchr(esp_271->tFFFFFFF8, esp_271->t0004, out ecx_851, out edx_852);
				if (eax_283 == 0x00)
					break;
				edi_256 = eax_283;
			}
			esi_252 = ecx_255;
			edx_249 = dwLoc48_646 *s (ecx_255 - 0x01);
			ecx_253 = dwLoc38_664 << 0x03;
		}
		else
		{
			edx_249 = 0x00;
			esi_252 = 0x01;
			ecx_253 = 0x10;
		}
		struct Eq_53693 * esp_311 = esp_201 - (struct Eq_53694 *) 0x0C;
		esp_311->tFFFFFFFC = dwLoc3C_650 + (ecx_253 + esi_252) + edx_249;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ebx_847;
		word32 edi_850;
		word32 ebp_848;
		word32 esi_849;
		word32 ecx_845;
		word32 edx_846;
		Eq_2 eax_338 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_845, out edx_846, out ebx_847, out ebp_848, out esi_849, out edi_850);
		Eq_2 edi_342 = eax_338;
		if (eax_338 != 0x00)
		{
			__gconv_max_path_elem_len = 0x00;
			esp_311->t0004 = fp - 0x24;
			esp_311->t0000.u0 = 0x080B9575;
			esp_311->tFFFFFFFC = dwLoc44_648;
			Eq_2 eax_363 = __strtok_r(esp_311->tFFFFFFFC, esp_311->t0000, esp_311->t0004);
			Eq_2 edx_371 = (word32) eax_338 + 8 + esi_252 * 0x08;
			Eq_2 ecx_374 = eax_363;
			if (eax_363 == 0x00)
				goto l080679EE;
			ui32 esi_376 = 0x00;
			do
			{
				*((word32) eax_338 + esi_376 * 0x08) = edx_371;
				if (*ecx_374 != 0x2F)
				{
					if (dwLoc34_645 == 0x00)
					{
						struct Eq_53823 * esp_394 = esp_201 - (struct Eq_53824 *) 4;
						esp_394->t0000.u0 = 0x080A4E84;
						esp_394->tFFFFFFFC.u0 = 0x01F5;
						esp_394->tFFFFFFF8.u0 = 0x080A4D25;
						esp_394->tFFFFFFF4.u0 = 0x080A4D3F;
						word32 ecx_856;
						word32 edx_857;
						__assert_fail(out ecx_856, out edx_857);
						goto l080679E9;
					}
					struct Eq_53848 * esp_410 = esp_201 - (struct Eq_53849 *) 0x04;
					esp_410->tFFFFFFFC = dwLoc40_647;
					esp_410->tFFFFFFF8 = dwLoc34_645;
					esp_410->tFFFFFFF4 = edx_371;
					word32 edx_858;
					Eq_2 eax_421 = __mempcpy(esp_410->tFFFFFFF4, esp_410->tFFFFFFF8, esp_410->tFFFFFFFC, out edx_858);
					*eax_421 = 0x2F;
					edx_371 = (word32) eax_421 + 1;
				}
				struct Eq_53796 * esp_435 = esp_201 - (struct Eq_53797 *) 0x08;
				esp_435->tFFFFFFFC = ecx_374;
				esp_435->tFFFFFFF8 = edx_371;
				word32 ecx_855;
				Eq_2 eax_444 = __stpcpy(esp_435->tFFFFFFF8, esp_435->tFFFFFFFC, out ecx_855);
				if (*((word32) eax_444 - 1) != 0x2F)
				{
					*eax_444 = 0x2F;
					eax_444 = (word32) eax_444 + 1;
				}
				ptr32 edx_463 = eax_444 - *((word32) eax_338 + esi_376 * 0x08);
				*((word32) eax_338 + (esi_376 * 0x08 + 4)) = edx_463;
				if (edx_463 > __gconv_max_path_elem_len)
					__gconv_max_path_elem_len = edx_463;
				*eax_444 = 0x00;
				esp_435->t0000 = fp - 0x24;
				esp_435->tFFFFFFFC.u0 = 0x080B9575;
				esp_435->tFFFFFFF8.u0 = 0x00;
				Eq_2 eax_491 = __strtok_r(esp_435->tFFFFFFF8, esp_435->tFFFFFFFC, esp_435->t0000);
				++esi_376;
				edx_371 = (word32) eax_444 + 1;
				ecx_374 = eax_491;
			} while (eax_491 != 0x00);
			struct Eq_54074 * eax_505 = (word32) eax_338 + esi_376 * 0x08;
			eax_505->dw0000 = 0x00;
			eax_505->dw0004 = 0x00;
		}
		else
			edi_342.u0 = 0x080A52A8;
		esp_201->tFFFFFFF0 = dwLoc34_645;
		__gconv_path_elem = edi_342;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		free(gs, stackArg0, stackArg4, out ecx_36, out edx);
	}
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v17_547 = lock.12667 - 0x01;
	lock.12667 = v17_547;
	if (v17_547 != 0x00)
		__lll_unlock_wake_private(0x080CF948, ecx_36, edx, gs);
	if ((eax_22 ^ gs->t0014) == 0x00)
		return;
l080679E9:
	word32 edx_840;
	word32 ecx_839;
	__stack_chk_fail(out ecx_839, out edx_840);
l080679EE:
	word32 ecx_853;
	word32 edx_854;
	__assert_fail(out ecx_853, out edx_854);
	word32 edi_842;
	word32 esi_841;
	__gconv_read_conf(gs, out esi_841, out edi_842);
}

// 08067A10: Register Eq_2 __gconv_read_conf(Register (ptr32 Eq_9) gs, Register out Eq_2 esiOut, Register out (ptr32 byte) ediOut)
// Called from:
//      __gconv_compare_alias
//      __gconv_find_transform
//      __gconv_get_path
Eq_2 __gconv_read_conf(struct Eq_9 * gs, union Eq_2 & esiOut, byte & ediOut)
{
	Eq_2 ebx_610;
	byte * edi_649;
	Eq_2175 esi_23 = gs->t0014;
	Eq_2 eax_29 = gs->tFFFFFFE0;
	struct Eq_54095 * esp_106 = fp - 0x7C;
	Eq_2 esi_25 = 0x00;
	edi_649 = edi;
	ebx_610 = ebx;
	if (__gconv_load_cache(gs) != 0x00)
	{
		Eq_2 eax_39 = __gconv_path_elem;
		if (eax_39 == 0x00)
		{
			__gconv_get_path(edx, gs);
			eax_39 = __gconv_path_elem;
		}
		Eq_2 esi_51 = *eax_39;
		Eq_2 dwLoc44_747 = esi_51;
		if (esi_51 != 0x00)
		{
			word32 dwLoc3C_749 = 0x08;
			do
			{
				Eq_2 eax_78 = *((word32) eax_39 + 4);
				struct Eq_54095 * ecx_86 = esp_106 - ((word32) eax_78 + 41 & ~0x0FFF);
				while (esp_106 != ecx_86)
				{
					esp_106 -= 0x1000;
					esp_106->dw0FFC = esp_106->dw0FFC;
				}
				int32 edx_102 = (word32) eax_78 + 41 & ~0x0F & 0x0FFF;
				if (edx_102 != 0x00)
				{
					esp_106 -= edx_102;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_106 - 0x04)[edx_102 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_106 - 0x04)[edx_102 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_54155 * esp_115 = esp_106 - 0x04;
				esp_115->tFFFFFFFC = eax_78;
				esp_115->tFFFFFFF8 = dwLoc44_747;
				Eq_54164 esi_114 = (char *) esp_106 + 0x0F;
				esp_115->tFFFFFFF4 = esi_114 & ~0x0F;
				word32 edx_1257;
				Eq_2 eax_133 = __mempcpy(esp_115->tFFFFFFF4, esp_115->tFFFFFFF8, esp_115->tFFFFFFFC, out edx_1257);
				*eax_133 = g_dw80A4E9C;
				*((word32) eax_133 + 4) = g_dw80A4EA0;
				*((word32) eax_133 + 8) = g_dw80A4EA4;
				((word32) eax_133 + 0x0C)->u5 = g_w80A4EA8;
				esp_115->tFFFFFFF8.u0 = 0x080A22F7;
				esp_115->tFFFFFFF4 = esi_114 & ~0x0F;
				Eq_2 eax_173 = __new_fopen();
				if (eax_173 != 0x00)
				{
					ui32 eax_184 = *eax_173;
					byte al_189 = (byte) eax_184;
					*eax_173 = SEQ(SLICE(eax_184, word16, 16), SLICE(eax_184, byte, 8) | 0x80, al_189);
					if ((al_189 & 0x10) == 0x00)
					{
						do
						{
							struct Eq_54290 * esp_200 = esp_106 - 4;
							esp_200->t0000 = eax_173;
							esp_200->dwFFFFFFFC = 0x0A;
							esp_200->ptrFFFFFFF8 = fp - 0x28;
							esp_200->tFFFFFFF4 = fp - 44;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							Eq_2 stackArg8 = <invalid>;
							Eq_2 stackArg12 = <invalid>;
							Eq_2 stackArg16 = <invalid>;
							struct Eq_54315 * eax_215 = _IO_getdelim(gs, stackArg4, stackArg8, stackArg12, stackArg16);
							if (eax_215 < null)
								break;
							esp_200->ptrFFFFFFF8 = 0x23;
							esp_200->tFFFFFFF4.u0 = 0x00;
							Eq_2 edi_224 = 0x00;
							word32 ecx_1267;
							word32 edx_1268;
							Eq_2 eax_231 = strchr(esp_200->tFFFFFFF4, esp_200->t0008, out ecx_1267, out edx_1268);
							if (eax_231 != 0x00)
								*eax_231 = 0x00;
							else if (eax_215->bFFFFFFFF == 0x0A)
								eax_215->bFFFFFFFF = 0x00;
							Eq_2 ebx_252 = g_t80CE08C;
							if ((*((word32) ebx_252 + ((int32) null * 0x02 + 1)) & 0x20) != 0x00)
							{
								do
									edi_224 = (word32) edi_224 + 1;
								while ((*((word32) ebx_252 + ((int32) (*edi_224) * 0x02 + 1)) & 0x20) != 0x00);
							}
							if (eax_231 != edi_224)
							{
								int32 eax_273 = (int32) *edi_224;
								if ((byte) eax_273 != 0x00 && (*((word32) ebx_252 + (eax_273 * 0x02 + 1)) & 0x20) == 0x00)
								{
									Eq_2 esi_282 = edi_224;
									do
									{
										esi_282 = (word32) esi_282 + 1;
										byte dl_287 = *esi_282;
									} while (dl_287 != 0x00 && (*((word32) ebx_252 + ((int32) dl_287 * 0x02 + 1)) & 0x20) == 0x00);
									int32 eax_300 = esi_282 - edi_224;
									if (eax_300 != 0x05)
									{
										if (eax_300 == 0x06 && (*edi_224 == 1969516397 && *((word32) edi_224 + 4) == 0x656C))
										{
											Eq_2 eax_491 = modcounter.12647;
											esp_200->tFFFFFFF4 = eax_491;
											modcounter.12647 = (word32) eax_491 + 1;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_2 stackArg4 = <invalid>;
											add_module.isra.0(esi_282, eax_78, dwLoc44_747, gs, stackArg4);
										}
									}
									else if (*edi_224 == 0x61696C61 && *((word32) edi_224 + 4) == 115)
									{
										int32 eax_309 = (int32) dl_287;
										while ((*((word32) ebx_252 + (eax_309 * 0x02 + 1)) & 0x20) != 0x00)
										{
											esi_282 = (word32) esi_282 + 1;
											eax_309 = (int32) *esi_282;
											dl_287 = (byte) eax_309;
										}
										if (dl_287 != 0x00)
										{
											Eq_2 edx_338 = esi_282;
											Eq_3803 edi_339[] = g_ptr80CE084;
											while (true)
											{
												Eq_2 ecx_345 = (word32) edx_338 + 1;
												*((word32) ecx_345 - 1) = edi_339[eax_309];
												eax_309 = (int32) *((word32) edx_338 + 1);
												if ((byte) eax_309 == 0x00)
													break;
												if ((*((word32) ebx_252 + (eax_309 * 0x02 + 1)) & 0x20) != 0x00)
												{
													struct Eq_52957 * edx_369;
													int32 eax_358 = (int32) *((word32) ecx_345 + 1);
													*ecx_345 = 0x00;
													struct Eq_52957 * edx_359 = (word32) edx_338 + 2;
													byte cl_384 = (byte) eax_358;
													edx_369 = edx_359;
													if ((*((word32) ebx_252 + (eax_358 * 0x02 + 1)) & 0x20) != 0x00)
													{
														edx_369 = edx_359;
														do
														{
															++edx_369;
															eax_358 = (int32) edx_369->b0000;
															cl_384 = (byte) eax_358;
														} while ((*((word32) ebx_252 + (eax_358 * 0x02 + 1)) & 0x20) != 0x00);
													}
													if (cl_384 != 0x00)
													{
														int32 eax_393 = eax_358;
														struct Eq_52957 * esi_394 = edx_359 + 2;
														while (true)
														{
															struct Eq_52957 * ecx_402 = esi_394 + 1;
															ecx_402->tFFFFFFFF = edi_339[eax_393];
															++edx_369;
															eax_393 = (int32) edx_369->b0000;
															if ((byte) eax_393 == 0x00 || (*((word32) ebx_252 + (eax_393 * 0x02 + 1)) & 0x20) != 0x00)
																break;
															esi_394 = ecx_402;
														}
														if (edx_359 != ecx_402)
														{
															ecx_402->b0000 = 0x00;
															if (detect_conflict(esi_282) == 0x00)
																add_alias2.isra.1.part.2(esi_282, &esi_394->b0000, edx_359);
														}
													}
													break;
												}
												edx_338 = ecx_345;
											}
										}
									}
								}
							}
						} while ((*eax_173 & 0x10) == 0x00);
					}
					struct Eq_54268 * esp_516 = esp_106 - 0x0C;
					esp_516->tFFFFFFFC.u0 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_1264;
					word32 edx_1265;
					free(gs, stackArg0, stackArg4, out ecx_1264, out edx_1265);
					esp_516->tFFFFFFFC = eax_173;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					__new_fclose(gs, stackArg4);
				}
				eax_39 = (word32) __gconv_path_elem + dwLoc3C_749;
				Eq_2 ebx_548 = *eax_39;
				dwLoc3C_749 += 0x08;
				dwLoc44_747 = ebx_548;
			} while (ebx_548 != 0x00);
		}
		Eq_2 esi_562 = 0x080CECE0;
		do
		{
			struct Eq_54408 * esp_566 = esp_106 - 0x04;
			esp_566->tFFFFFFFC.u0 = 0x08065FB0;
			esp_566->tFFFFFFF8.u0 = 0x080CFF84;
			esp_566->tFFFFFFF4 = fp - 0x28;
			if (__tfind(esp_566->tFFFFFFF4, esp_566->tFFFFFFF8, esp_566->tFFFFFFFC) == 0x00)
			{
				insert_module(esi_562, 0x00);
				esi_562 = (word32) esi_562 + 32;
				if (0x080CEE60 == esi_562)
					break;
				continue;
			}
			esi_562 = (word32) esi_562 + 32;
		} while (0x080CEE60 != esi_562);
		ebx_610.u0 = 0x080A4EC0;
		do
		{
			struct Eq_54564 * esp_614 = esp_106 - 0x08;
			esp_614->dwFFFFFFFC = 0x00;
			esp_614->tFFFFFFF8 = ebx_610;
			Eq_2 eax_621 = rawmemchr(esp_614->tFFFFFFF8, esp_614->b0004);
			esp_614->dwFFFFFFFC = 0x00;
			esp_614->tFFFFFFF8 = (word32) eax_621 + 1;
			Eq_2 eax_639 = rawmemchr(esp_614->tFFFFFFF8, esp_614->b0004);
			esi_25 = eax_639;
			edi_649 = (word32) eax_639 + 1;
			if (detect_conflict(ebx_610) == 0x00)
				add_alias2.isra.1.part.2(ebx_610, (word32) eax_639 + 1, (word32) eax_621 + 1);
			ebx_610 = (word32) eax_639 + 1;
		} while (*((word32) eax_639 + 1) != 0x00);
	}
	gs->tFFFFFFE0 = eax_29;
	if ((esi_23 ^ gs->t0014) != 0x00)
	{
		word32 ecx_1258;
		word32 edx_1259;
		__stack_chk_fail(out ecx_1258, out edx_1259);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		__gconv_get_builtin_trans(stackArg4, stackArg8);
		esiOut = esi_25;
		ediOut = edi_649;
		return ebx_610;
	}
	else
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
}

// 08067EE0: Register word32 __gconv_get_builtin_trans(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      find_derivation
//      __gconv_read_conf
//      __gconv_lookup_cache
word32 __gconv_get_builtin_trans(Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 ebx_18 = 0x00;
	struct Eq_54727 * edi_21 = &g_t80CE230;
	Eq_2 eax_25 = 0x080A4D68;
	while (true)
	{
		word32 edx_139;
		word32 ecx_125;
		if (strcmp(dwArg04, eax_25, out ecx_125, out edx_139) == 0x00)
			break;
		++ebx_18;
		if (ebx_18 == 0x0C)
		{
			word32 edx_140;
			__assert_fail(out ecx_125, out edx_140);
			break;
		}
		eax_25 = edi_21->dw0000;
		++edi_21;
	}
	((word32) dwArg08 + 28)->u0 = 0x00;
	((word32) dwArg08 + 32)->u0 = 0x00;
	*dwArg08 = 0x00;
	struct Eq_54751 * eax_82 = 0x080CE240 + (ebx_18 << 0x04);
	word32 edx_84 = eax_82->dw0004;
	*((word32) dwArg08 + 4) = 0x00;
	((word32) dwArg08 + 52)->u0 = 0x00;
	*((word32) dwArg08 + 20) = edx_84;
	*((word32) dwArg08 + 24) = eax_82->t0008;
	*((word32) dwArg08 + 36) = (int32) eax_82->b000C;
	*((word32) dwArg08 + 40) = (int32) eax_82->b000D;
	Eq_2 eax_95 = (int32) eax_82->b000F;
	*((word32) dwArg08 + 44) = (int32) eax_82->b000E;
	*((word32) dwArg08 + 48) = eax_95;
	return ecx_125;
}

// 08067FC0: void __gconv_btwoc_ascii(Stack byte bArg08)
void __gconv_btwoc_ascii(byte bArg08)
{
}

// 08067FE0: void __gconv_transform_internal_ucs4(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_54826) dwArg04, Stack (ptr32 Eq_54827) dwArg08, Stack (ptr32 (ptr32 Eq_54829)) dwArg0C, Stack (ptr32 Eq_54829) dwArg10, Stack (ptr32 Eq_54827) dwArg14, Stack word32 dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ucs4(struct Eq_9 * gs, struct Eq_54826 * dwArg04, struct Eq_54827 * dwArg08, struct Eq_54829 ** dwArg0C, struct Eq_54829 * dwArg10, struct Eq_54827 * dwArg14, word32 dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x5C;
	Eq_2175 edi_32 = gs->t0014;
	Eq_2 dwLoc44_553 = 0x00;
	if ((dwArg08->b0008 & 0x01) == 0x00)
	{
		Eq_2 edi_43 = dwArg04->t0050;
		dwLoc44_553 = edi_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc44_553 = __ror(edi_43, 0x09) ^ gs->t0018;
	}
	ptr32 esp_482;
	word32 esi_478;
	if (dwArg1C == 0x00)
	{
		struct Eq_54827 * eax_120 = dwArg14;
		if (dwArg14 == null)
			eax_120 = dwArg08;
		struct Eq_54874 * ebp_125 = eax_120->ptr0000;
		Eq_54878 eax_127 = dwArg08->t0004;
		if (dwArg20 != 0x00)
		{
			struct Eq_54884 * ecx_134 = dwArg08->ptr0014;
			ui32 ebx_135 = ecx_134->dw0000;
			byte bl_149 = (byte) ebx_135;
			Eq_54894 edx_137 = ebx_135 & 0x07;
			if ((ebx_135 & 0x07) != 0x00)
			{
				if (dwArg14 != null)
					goto l0806836C;
				struct Eq_54829 * eax_146 = *dwArg0C;
				if (eax_146 < dwArg10)
				{
					if ((bl_149 & 0x04) == 0x00)
					{
						do
						{
							++eax_146;
							*dwArg0C = (struct Eq_54829 **) eax_146;
							edx_137 = (word32) edx_137 + 1;
							Mem167[ecx_134 + 0x03 + edx_137:byte] = Mem163[eax_146 + -1:byte];
							if (dwArg10 == eax_146)
								goto l080680F1;
						} while (edx_137 != 0x04);
					}
				}
				else
				{
l080680F1:
					if (edx_137 <= 0x03)
					{
						ecx_134->dw0000 = edx_137 | ebx_135 & ~0x07;
						goto l0806821E;
					}
				}
				ebp_125->a0000[0].b0000 = ecx_134->t0007.b0000;
				ebp_125->b0001 = ecx_134->b0006;
				ebp_125->b0002 = ecx_134->b0005;
				ebp_125->t0003 = ecx_134->t0004;
				ecx_134->dw0000 &= ~0x07;
				ebp_125 = (struct Eq_54874 *) ((char *) &ebp_125->t0003 + 1);
			}
		}
		while (true)
		{
			struct Eq_54829 * ebx_217 = *dwArg0C;
			int32 ecx_220 = eax_127 - ebp_125;
			int32 eax_221 = dwArg10 - ebx_217;
			if (ecx_220 <= eax_221)
				eax_221 = ecx_220;
			int32 ecx_228 = eax_221 + 0x03;
			if (eax_221 >= 0x00)
				ecx_228 = eax_221;
			struct Eq_54874 * edi_237;
			int32 ecx_232 = ecx_228 >> 0x02;
			if (ecx_232 != 0x00)
			{
				int32 eax_238 = 0x00;
				do
				{
					ebp_125[eax_238 * 0x04 / 7] = (struct Eq_54874) __bswap(ebx_217[eax_238 * 0x04]);
					++eax_238;
				} while (ecx_232 != eax_238);
				edi_237 = ebp_125 + (ecx_232 * 0x04) / 7;
				ebx_217 += ecx_232 * 0x04;
			}
			else
				edi_237 = ebp_125;
			*dwArg0C = (struct Eq_54829 **) ebx_217;
			ui32 edx_264 = 0x04;
			if (dwArg10 != ebx_217)
				edx_264 = (0x00 - (word32) (eax_127 < (char *) (&edi_237->t0003) + 1) & ~0x01) + 0x07;
			if (dwArg14 != null)
				break;
			++dwArg08->dw000C;
			if ((dwArg08->b0008 & 0x01) != 0x00)
			{
				dwArg08->ptr0000 = edi_237;
				goto l0806820D;
			}
			if (edi_237 <= ebp_125)
				goto l0806820D;
			struct Eq_54874 * eax_304 = dwArg08->ptr0000;
			word32 ecx_962;
			word32 edx_963;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc44_553, out ecx_962, out edx_963);
			ui32 eax_353;
			word32 ecx_354;
			fn00000000();
			dwLoc70 = dwArg20;
			if (eax_353 != 0x04)
			{
				if (eax_304 != edi_237)
					*dwArg0C = (struct Eq_54829 **) (*dwArg0C - (edi_237 - eax_304));
				if (eax_353 == 0x00)
					goto l080681FC;
				edx_264 = eax_353;
l0806820D:
				if (dwArg20 == 0x00 || edx_264 != 0x07)
					goto l0806821E;
				struct Eq_54829 * ecx_390 = *dwArg0C;
				if (dwArg10 - ecx_390 > 0x03)
				{
					word32 edx_965;
					word32 ecx_964;
					__assert_fail(out ecx_964, out edx_965);
					goto l08068344;
				}
				else
				{
					struct Eq_55165 * eax_421;
					struct Eq_54884 * ebx_416 = dwArg08->ptr0014;
					struct Eq_54829 * eax_417 = ecx_390;
					struct Eq_55171 * esi_418 = &ebx_416->t0004;
					if (ecx_390 < dwArg10)
					{
						do
						{
							++eax_417;
							*dwArg0C = (struct Eq_54829 **) eax_417;
							++esi_418;
							esi_418->bFFFFFFFF = eax_417->bFFFFFFFF;
						} while (eax_417 != dwArg10);
						eax_421 = eax_417 - ecx_390;
					}
					else
						eax_421 = null;
					ebx_416->dw0000 = eax_421 | ebx_416->dw0000 & ~0x07;
					goto l0806821E;
				}
			}
			if (edx_264 != 0x05)
				goto l0806820D;
l080681FC:
			ebp_125 = dwArg08->ptr0000;
		}
		dwArg14->ptr0000 = edi_237;
	}
	else
	{
		if (dwArg14 != null)
			goto l08068349;
		struct Eq_54884 * eax_67 = dwArg08->ptr0014;
		eax_67->dw0000 = 0x00;
		eax_67->t0004.u1 = 0x00;
		if ((dwArg08->b0008 & 0x01) == 0x00)
		{
			word32 edx_959;
			word32 ecx_958;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc44_553, out ecx_958, out edx_959);
			word32 ecx_110;
			fn00000000();
		}
	}
l0806821E:
	if ((edi_32 ^ gs->t0014) == 0x00)
		return;
l08068344:
	word32 edx_961;
	word32 ecx_960;
	__stack_chk_fail(out ecx_960, out edx_961);
	esp_18.u0 = <invalid>;
l08068349:
	esi_478 = (word32) *((word32) esp_18 + 44);
	struct Eq_54982 * esp_480 = esp_18 - 4;
	esp_480->dw0000 = esi_478 + ~0x0002881F;
	esp_480->dwFFFFFFFC = 0x019F;
	esp_482 = esp_480 - 4;
l08068359:
	struct Eq_55206 * esp_487 = esp_482 - 4;
	esp_487->dw0000 = esi_478 + ~0x00028CFD;
	esp_487->dwFFFFFFFC = esi_478 + ~0x00028CE9;
	word32 ecx_966;
	word32 edx_967;
	__assert_fail(out ecx_966, out edx_967);
	esp_18.u0 = <invalid>;
l0806836C:
	esi_478 = (word32) *((word32) esp_18 + 44);
	struct Eq_54905 * esp_503 = esp_18 - 4;
	esp_503->dw0000 = esi_478 + ~0x0002881F;
	esp_503->dwFFFFFFFC = 0x022F;
	esp_482 = esp_503 - 4;
	goto l08068359;
}

// 08068390: void __gconv_transform_ucs4_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_55226) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 (ptr32 Eq_55229)) dwArg0C, Stack (ptr32 Eq_55229) dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs4_internal(struct Eq_9 * gs, struct Eq_55226 * dwArg04, Eq_2 dwArg08, union Eq_55229 ** dwArg0C, union Eq_55229 * dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x6C;
	Eq_2 edi_22 = dwArg08;
	ui32 ebp_26 = *((word32) dwArg08 + 8);
	Eq_2175 ecx_34 = gs->t0014;
	Eq_2 dwLoc48_666 = 0x00;
	if ((ebp_26 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc48_666 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc48_666 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_2 esi_326;
	Eq_2 esp_270;
	Eq_2 eax_443;
	ptr32 esp_500;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 != 0x00)
			goto l080687ED;
		struct Eq_55312 * eax_68 = *((word32) dwArg08 + 20);
		eax_68->dw0000 = 0x00;
		eax_68->t0004.u1 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_1210;
			word32 edx_1211;
			_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc48_666, out ecx_1210, out edx_1211);
			word32 edx_112;
			fn00000000();
		}
l080685D6:
		if ((ecx_34 ^ gs->t0014) == 0x00)
			return;
		word32 ecx_1212;
		word32 edx_1213;
		__stack_chk_fail(out ecx_1212, out edx_1213);
		esp_18.u0 = <invalid>;
l0806881C:
		edi_22 = *((word32) esp_18 + 52);
		struct Eq_55365 * esp_498 = esp_18 - 4;
		esp_498->dw0000 = (word32) edi_22 - 0x00028840;
		esp_498->dwFFFFFFFC = 0x022F;
		esp_500 = esp_498 - 4;
l080687FD:
		struct Eq_55424 * esp_505 = esp_500 - 4;
		esp_505->dw0000 = (word32) edi_22 - 167166;
		esp_505->dwFFFFFFFC = (word32) edi_22 - 167146;
		word32 edx_1215;
		word32 ecx_1214;
		eax_443 = __assert_fail(out ecx_1214, out edx_1215);
		esp_270.u0 = <invalid>;
l08068810:
		esi_326 = eax_443;
		goto l08068685;
	}
	Eq_2 eax_117 = dwArg14;
	Eq_55276 ecx_118 = *((word32) dwArg08 + 4);
	if (dwArg14 == 0x00)
		eax_117 = dwArg08;
	struct Eq_55282 * esi_126 = *eax_117;
	struct Eq_55282 * dwLoc64_697 = esi_126;
	word32 * ecx_136 = null;
	if (dwArg18 != null)
		ecx_136 = fp - 0x28;
	if (dwArg20 != 0x00)
	{
		struct Eq_55312 * ecx_150 = *((word32) dwArg08 + 20);
		ui32 ebx_151 = ecx_150->dw0000;
		byte bl_166 = (byte) ebx_151;
		if ((ebx_151 & 0x07) != 0x00)
		{
			if (dwArg14 != 0x00)
				goto l0806881C;
			Eq_55379 edx_162 = ebx_151 & 0x07;
			union Eq_55229 * eax_163 = *dwArg0C;
			if (eax_163 < dwArg10)
			{
				if ((bl_166 & 0x04) == 0x00)
				{
					do
					{
						eax_163 = (union Eq_55229 *) ((char *) eax_163 + 1);
						*dwArg0C = (union Eq_55229 **) eax_163;
						edx_162 = (word32) edx_162 + 1;
						Mem188[ecx_150 + 0x03 + edx_162:byte] = Mem184[eax_163 + -1:byte];
						if (dwArg10 == eax_163)
							goto l080684E9;
					} while (edx_162 != 0x04);
				}
			}
			else
			{
l080684E9:
				if (edx_162 <= 0x03)
				{
					ecx_150->dw0000 = edx_162 | ebx_151 & ~0x07;
					goto l080685D6;
				}
			}
			ui32 ebx_250 = ebx_151;
			if (ecx_150->t0004 <= 0x80)
			{
				esi_126->dw0000 = (word32) ecx_150->b0007;
				esi_126->b0001 = ecx_150->b0006;
				esi_126->b0002 = ecx_150->b0005;
				esi_126->t0003 = ecx_150->t0004;
				ebx_250 = ecx_150->dw0000;
				dwLoc64_697 = esi_126 + 1;
			}
			else if ((ebp_26 & 0x02) == 0x00)
			{
				*dwArg0C = (union Eq_55229 **) ((char *) eax_163 + ((ebx_151 & 0x07) - edx_162));
				goto l080685D6;
			}
			ebp_26 = (ui32) *((word32) dwArg08 + 8);
			ecx_150->dw0000 = ebx_250 & ~0x07;
		}
	}
	while (true)
	{
		union Eq_55229 * edx_275 = *dwArg0C;
		esp_270 = fp - 0x6C;
		struct Eq_55282 * ebx_274 = dwLoc64_697;
		int32 esi_277 = ecx_118 - dwLoc64_697;
		int32 eax_278 = dwArg10 - edx_275;
		if (esi_277 <= eax_278)
			eax_278 = esi_277;
		int32 esi_285 = eax_278 + 0x03;
		if (eax_278 >= 0x00)
			esi_285 = eax_278;
		int32 esi_289 = esi_285 >> 0x02;
		if (esi_289 != 0x00)
		{
			int32 ecx_297 = 0x00;
			ui32 ebp_301 = ebp_26 & 0x02;
			do
			{
				Eq_2 eax_307 = __bswap(*edx_275);
				if (eax_307 < 0x00)
				{
					if (ecx_136 == null)
					{
						ebx_274 = dwLoc64_697;
						esi_326.u0 = 0x06;
						goto l08068603;
					}
					if (ebp_301 == 0x00)
					{
						*dwArg0C = (union Eq_55229 **) edx_275;
						esi_326.u0 = 0x06;
						goto l08068603;
					}
					else
					{
						++*ecx_136;
						++ecx_297;
						edx_275 = (union Eq_55229 *) ((char *) edx_275 + 4);
						if (esi_289 == ecx_297)
							break;
						continue;
					}
				}
				ebx_274->dw0000 = (word32) eax_307;
				++ecx_297;
				edx_275 = (union Eq_55229 *) ((char *) edx_275 + 4);
				++ebx_274;
			} while (esi_289 != ecx_297);
		}
		else
			ebx_274 = dwLoc64_697;
		*dwArg0C = (union Eq_55229 **) edx_275;
		esi_326.u0 = 0x04;
		if (edx_275 != dwArg10)
		{
			esi_326 = (0x00 - (word32) (ecx_118 < ebx_274 + 1) & ~0x01) + 0x07;
			if (dwArg14 != 0x00)
			{
l080685D0:
				*dwArg14 = ebx_274;
				goto l080685D6;
			}
		}
		else
		{
l08068603:
			if (dwArg14 != 0x00)
				goto l080685D0;
		}
		*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
		if ((*((word32) dwArg08 + 8) & 0x01) != 0x00)
		{
			*dwArg08 = ebx_274;
			*dwArg18 = *dwArg18;
			goto l08068685;
		}
		if (dwLoc64_697 >= ebx_274)
		{
l08068685:
			if (*((word32) esp_270 + 0x008C) != null && esi_326 == 0x07)
			{
				struct Eq_55447 * ebp_531 = *((byte) esp_270.u0 + 20);
				struct Eq_55447 * edx_532 = **((byte) esp_270.u0 + 0x0C);
				if (ebp_531 - edx_532 <= 0x03)
				{
					ui32 eax_571;
					ui32 * ecx_566 = *((word32) edi_22 + 20);
					struct Eq_55447 * eax_567 = edx_532 + 1;
					struct Eq_55501 * ebx_568 = ecx_566 + 1;
					if (edx_532 < ebp_531)
					{
						while (true)
						{
							**((byte) esp_270.u0 + 0x0C) = eax_567;
							++ebx_568;
							ebx_568->bFFFFFFFF = eax_567->bFFFFFFFF;
							struct Eq_55447 * edi_583 = eax_567 + 1;
							if (*((byte) esp_270.u0 + 20) == eax_567)
								break;
							eax_567 = edi_583;
						}
						eax_571 = *((byte) esp_270.u0 + 20) - edx_532;
					}
					else
						eax_571 = 0x00;
					*ecx_566 = eax_571 | *ecx_566 & ~0x07;
					goto l080685D6;
				}
				Eq_2 edi_537 = *((byte) esp_270.u0 + 52);
				struct Eq_55465 * esp_539 = esp_270 - 4;
				esp_539->dw0000 = (word32) edi_537 - 0x00028840;
				esp_539->dwFFFFFFFC = 777;
				esp_539->dwFFFFFFF8 = (word32) edi_537 - 167166;
				esp_539->dwFFFFFFF4 = (word32) edi_537 - 167126;
				word32 ecx_1216;
				word32 edx_1217;
				__assert_fail(out ecx_1216, out edx_1217);
				esp_18.u0 = <invalid>;
l080687ED:
				edi_22 = *((word32) esp_18 + 52);
				struct Eq_55298 * esp_560 = esp_18 - 4;
				esp_560->dw0000 = (word32) edi_22 - 0x00028840;
				esp_560->dwFFFFFFFC = 0x019F;
				esp_500 = esp_560 - 4;
				goto l080687FD;
			}
			goto l080685D6;
		}
		struct Eq_55282 * eax_392 = *dwArg08;
		word32 ecx_1218;
		word32 edx_1219;
		_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc48_666, out ecx_1218, out edx_1219);
		word32 edx_445;
		fn00000000();
		dwLoc80 = dwArg20;
		esp_270 = fp - 0x6C;
		if (eax_443 != 0x04)
		{
			if (eax_392 != ebx_274)
				*dwArg0C = (union Eq_55229 **) (*dwArg0C - (ebx_274 - eax_392));
			if (eax_443 != 0x00)
				goto l08068810;
		}
		else if (esi_326 != 0x05)
			goto l08068685;
		ebp_26 = (ui32) *((word32) dwArg08 + 8);
		dwLoc64_697 = (struct Eq_55282 *) *dwArg08;
	}
}

// 08068830: void __gconv_transform_internal_ucs4le(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_55743) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack word32 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ucs4le(struct Eq_9 * gs, struct Eq_55743 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x5C;
	Eq_2 esi_20 = dwArg08;
	Eq_2 ebp_129 = dwArg1C;
	Eq_2175 edx_31 = gs->t0014;
	Eq_2 dwLoc40_571 = 0x00;
	if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
	{
		Eq_2 edx_42 = dwArg04->t0050;
		dwLoc40_571 = edx_42;
		if (dwArg04->dw003C != 0x00)
			dwLoc40_571 = __ror(edx_42, 0x09) ^ gs->t0018;
	}
	ptr32 esp_495;
	Eq_2 esp_271;
	Eq_2 edi_303;
	Eq_2 ebx_272;
	Eq_2 eax_355;
	if (dwArg1C == 0x00)
	{
		Eq_2 eax_121 = dwArg14;
		up32 edx_122 = *((word32) dwArg08 + 4);
		if (dwArg14 == 0x00)
			eax_121 = dwArg08;
		ebp_129 = *eax_121;
		if (dwArg20 != 0x00)
		{
			struct Eq_55805 * ebx_138 = *((word32) dwArg08 + 20);
			ui32 edx_139 = ebx_138->dw0000;
			byte dl_153 = (byte) edx_139;
			Eq_55815 ecx_141 = edx_139 & 0x07;
			if ((edx_139 & 0x07) != 0x00)
			{
				if (dwArg14 != 0x00)
					goto l08068BA4;
				Eq_2 eax_150 = *dwArg0C;
				if (dwArg10 > eax_150)
				{
					if ((dl_153 & 0x04) == 0x00)
					{
						do
						{
							eax_150 = (word32) eax_150 + 1;
							*dwArg0C = eax_150;
							ecx_141 = (word32) ecx_141 + 1;
							Mem169[ebx_138 + 0x03 + ecx_141:byte] = Mem165[eax_150 + -1:byte];
							if (dwArg10 == eax_150)
								goto l08068A5F;
						} while (ecx_141 != 0x04);
					}
				}
				else
				{
l08068A5F:
					if (ecx_141 <= 0x03)
					{
						ebx_138->dw0000 = ecx_141 | edx_139 & ~0x07;
						goto l080689E0;
					}
				}
				*ebp_129 = ebx_138->t0004;
				*((word32) ebp_129 + 1) = ebx_138->b0005;
				*((word32) ebp_129 + 2) = ebx_138->b0006;
				*((word32) ebp_129 + 3) = ebx_138->b0007;
				ebx_138->dw0000 &= ~0x07;
				ebp_129 = (word32) ebp_129 + 4;
			}
		}
		Eq_2 edi_221 = ebp_129;
		ebp_129 = dwArg0C;
		while (true)
		{
			Eq_2 ecx_228 = *dwArg0C;
			Eq_55822 eax_230 = edx_122 - edi_221;
			Eq_55822 ebx_231 = dwArg10 - ecx_228;
			if (eax_230 <= ebx_231)
				ebx_231 = eax_230;
			Eq_55822 eax_238 = (word32) ebx_231 + 3;
			if (ebx_231 >= 0x00)
				eax_238 = ebx_231;
			Eq_2 eax_245 = eax_238 & ~0x03;
			Mem253[dwArg0C + 0x00:word32] = ecx_228 + eax_245;
			word32 edx_974;
			Eq_2 eax_263 = __mempcpy(edi_221, ecx_228, eax_245, out edx_974);
			esp_271 = fp - 0x5C;
			ebx_272.u0 = 0x04;
			if (dwArg10 != *dwArg0C)
				ebx_272 = (0x00 - (word32) (edx_122 < (word32) eax_263 + 4) & ~0x01) + 0x07;
			if (dwArg14 != 0x00)
				break;
			*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
			if ((*((word32) dwArg08 + 8) & 0x01) != 0x00)
			{
				*dwArg08 = eax_263;
				edi_303 = dwArg0C;
				goto l080689CF;
			}
			if (eax_263 <= edi_221)
			{
l080689CD:
				esp_271 = fp - 0x5C;
				edi_303 = dwArg0C;
				goto l080689CF;
			}
			Eq_2 eax_309 = *dwArg08;
			word32 ecx_979;
			word32 edx_980;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc40_571, out ecx_979, out edx_980);
			fn00000000();
			dwLoc70 = dwArg20;
			esp_271 = fp - 0x5C;
			if (eax_355 != 0x04)
			{
				if (eax_309 != eax_263)
					*dwArg0C -= eax_263 - eax_309;
				if (eax_355 != 0x00)
					goto l08068BC7;
				goto l080689BD;
			}
			if (ebx_272 != 0x05)
				goto l080689CD;
l080689BD:
			edi_221 = *dwArg08;
		}
		*dwArg14 = eax_263;
	}
	else
	{
		if (dwArg14 != 0x00)
		{
			esi_20.u0 = 0x080CE000;
			esp_495 = fp - 100;
			goto l08068BB4;
		}
		struct Eq_55805 * eax_72 = *((word32) dwArg08 + 20);
		eax_72->dw0000 = 0x00;
		eax_72->t0004.u1 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 edx_973;
			word32 ecx_972;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc40_571, out ecx_972, out edx_973);
			word32 ecx_116;
			fn00000000();
		}
	}
l080689E0:
	if ((edx_31 ^ gs->t0014) == 0x00)
		return;
	word32 edx_978;
	word32 ecx_977;
	__stack_chk_fail(out ecx_977, out edx_978);
	esp_271.u0 = <invalid>;
l08068B81:
	Eq_2 esi_470 = *((byte) esp_271.u0 + 24);
	struct Eq_56093 * esp_472 = esp_271 - 4;
	esp_472->dw0000 = (word32) esi_470 - 0x00028880;
	esp_472->dwFFFFFFFC = 777;
	esp_472->dwFFFFFFF8 = (word32) esi_470 - 167166;
	esp_472->dwFFFFFFF4 = (word32) esi_470 - 167126;
	word32 edx_982;
	word32 ecx_981;
	__assert_fail(out ecx_981, out edx_982);
	esp_18.u0 = <invalid>;
l08068BA4:
	esi_20 = *((word32) esp_18 + 24);
	struct Eq_55871 * esp_493 = esp_18 - 4;
	esp_493->ptr0000 = (ptr32) ((byte) esi_20.u0 - 0x00028880);
	esp_493->dwFFFFFFFC = 0x022F;
	esp_495 = esp_493 - 4;
l08068BB4:
	struct Eq_55965 * esp_500 = esp_495 - 4;
	esp_500->ptr0000 = (ptr32) ((byte) esi_20.u0 - 167166);
	esp_500->ptrFFFFFFFC = (ptr32) ((byte) esi_20.u0 - 167146);
	word32 ecx_975;
	word32 edx_976;
	eax_355 = __assert_fail(out ecx_975, out edx_976);
	esp_271.u0 = <invalid>;
l08068BC7:
	edi_303 = ebp_129;
	ebx_272 = eax_355;
l080689CF:
	if (ebx_272 == 0x07 && *((byte) esp_271.u0 + 0x007C) != null)
	{
		Eq_2 edx_396 = *((byte) esp_271.u0 + 8);
		Eq_2 ebx_398 = *edi_303;
		if (edx_396 - ebx_398 <= 0x03)
		{
			ui32 eax_412;
			ui32 * esi_406 = *((byte) esi_20.u0 + 20);
			Eq_2 eax_407 = ebx_398;
			Eq_2 ecx_408 = *((byte) esp_271.u0 + 8);
			ebp_129 = esi_406 + 1;
			if (ebx_398 < edx_396)
			{
				do
				{
					eax_407 = (word32) eax_407 + 1;
					*edi_303 = eax_407;
					ebp_129 = (word32) ebp_129 + 1;
					*((word32) ebp_129 - 1) = *((word32) eax_407 - 1);
				} while (eax_407 != ecx_408);
				eax_412 = eax_407 - ebx_398;
			}
			else
				eax_412 = 0x00;
			*esi_406 = eax_412 | *esi_406 & ~0x07;
			goto l080689E0;
		}
		goto l08068B81;
	}
	goto l080689E0;
}

// 08068BF0: void __gconv_transform_ucs4le_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_56160) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs4le_internal(struct Eq_9 * gs, struct Eq_56160 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x6C;
	Eq_2 edi_22 = dwArg08;
	ui32 ebp_247 = *((word32) dwArg08 + 8);
	Eq_2175 esi_33 = gs->t0014;
	Eq_2 dwLoc44_675 = 0x00;
	if ((ebp_247 & 0x01) == 0x00)
	{
		Eq_2 esi_44 = dwArg04->t0050;
		dwLoc44_675 = esi_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc44_675 = __ror(esi_44, 0x09) ^ gs->t0018;
	}
	ptr32 esp_377;
	Eq_2 esi_312;
	Eq_2 esp_257;
	Eq_2 eax_459;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == 0x00)
		{
			struct Eq_56246 * eax_68 = *((word32) dwArg08 + 20);
			eax_68->dw0000 = 0x00;
			eax_68->t0004.u1 = 0x00;
			if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
			{
				word32 ecx_1312;
				word32 edx_1313;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc44_675, out ecx_1312, out edx_1313);
				word32 ecx_111;
				word32 edx_112;
				fn00000000();
			}
			goto l08068E2D;
		}
		goto l08069057;
	}
	Eq_2 eax_123 = dwArg14;
	if (dwArg14 == 0x00)
		eax_123 = dwArg08;
	struct Eq_56212 * eax_131 = *eax_123;
	struct Eq_56212 * dwLoc60_706 = eax_131;
	ptr32 eax_136 = *((word32) dwArg08 + 4);
	word32 * eax_138 = null;
	if (dwArg18 != null)
		eax_138 = fp - 0x28;
	if (dwArg20 != 0x00)
	{
		struct Eq_56246 * ecx_151 = *((word32) dwArg08 + 20);
		ui32 ebx_152 = ecx_151->dw0000;
		byte bl_167 = (byte) ebx_152;
		Eq_56302 edx_154 = ebx_152 & 0x07;
		if ((ebx_152 & 0x07) != 0x00)
		{
			if (dwArg14 != 0x00)
				goto l080690A4;
			Eq_2 eax_164 = *dwArg0C;
			if (dwArg10 > eax_164)
			{
				if ((bl_167 & 0x04) == 0x00)
				{
					do
					{
						eax_164 = (word32) eax_164 + 1;
						*dwArg0C = (union Eq_2 *) eax_164;
						edx_154 = (word32) edx_154 + 1;
						Mem185[ecx_151 + 0x03 + edx_154:byte] = Mem181[eax_164 + -1:byte];
						if (dwArg10 == eax_164)
							goto l08068D35;
					} while (edx_154 != 0x04);
				}
			}
			else
			{
l08068D35:
				if (edx_154 <= 0x03)
				{
					ecx_151->dw0000 = edx_154 | ebx_152 & ~0x07;
					goto l08068E2D;
				}
			}
			ui32 ebx_238 = ebx_152;
			if (ecx_151->b0007 <= 0x80)
			{
				eax_131->dw0000 = (word32) ecx_151->t0004;
				eax_131->b0001 = ecx_151->b0005;
				eax_131->b0002 = ecx_151->b0006;
				eax_131->b0003 = ecx_151->b0007;
				dwLoc60_706 = eax_131 + 1;
				ebx_238 = ecx_151->dw0000;
			}
			else if ((ebp_247 & 0x02) == 0x00)
				goto l08068E2D;
			ebp_247 = (ui32) *((word32) dwArg08 + 8);
			ecx_151->dw0000 = ebx_238 & ~0x07;
		}
	}
l08068D80:
	Eq_2 eax_263 = *dwArg0C;
	esp_257 = fp - 0x6C;
	struct Eq_56212 * ebx_261 = dwLoc60_706;
	int32 esi_264 = eax_136 - dwLoc60_706;
	int32 edx_265 = dwArg10 - eax_263;
	if (esi_264 <= edx_265)
		edx_265 = esi_264;
	int32 esi_272 = edx_265 + 0x03;
	if (edx_265 >= 0x00)
		esi_272 = edx_265;
	int32 esi_276 = esi_272 >> 0x02;
	if (esi_276 != 0x00)
	{
		int32 edx_284 = 0x00;
		ui32 ebp_288 = ebp_247 & 0x02;
		do
		{
			int32 ecx_293 = *eax_263;
			if (ecx_293 < 0x00)
			{
				if (eax_138 == null)
				{
					ebx_261 = dwLoc60_706;
					esi_312.u0 = 0x06;
					goto l08068E5B;
				}
				if (ebp_288 == 0x00)
				{
					*dwArg0C = (union Eq_2 *) eax_263;
					esi_312.u0 = 0x06;
					goto l08068E5B;
				}
				else
				{
					++*eax_138;
					++edx_284;
					eax_263 = (word32) eax_263 + 4;
					if (esi_276 == edx_284)
						break;
					continue;
				}
			}
			ebx_261->dw0000 = ecx_293;
			++edx_284;
			eax_263 = (word32) eax_263 + 4;
			++ebx_261;
		} while (esi_276 != edx_284);
	}
	else
		ebx_261 = dwLoc60_706;
	*dwArg0C = (union Eq_2 *) eax_263;
	if (eax_263 != dwArg10)
	{
		if (dwArg10 >= (word32) eax_263 + 4)
		{
			if (eax_136 < ebx_261 + 1)
			{
				esi_312.u0 = 0x05;
				if (dwArg14 != 0x00)
					goto l08068E27;
				goto l08068E63;
			}
			word32 ecx_1320;
			word32 edx_1321;
			__assert_fail(out ecx_1320, out edx_1321);
			esp_18.u0 = <invalid>;
l080690A4:
			edi_22 = *((word32) esp_18 + 52);
			struct Eq_56313 * esp_375 = esp_18 - 4;
			esp_375->dw0000 = (word32) edi_22 - 166080;
			esp_375->dwFFFFFFFC = 0x022F;
			esp_377 = esp_375 - 4;
l08069067:
			struct Eq_56370 * esp_530 = esp_377 - 4;
			esp_530->dw0000 = (word32) edi_22 - 167166;
			esp_530->dwFFFFFFFC = (word32) edi_22 - 167146;
			word32 edx_1317;
			word32 ecx_1316;
			eax_459 = __assert_fail(out ecx_1316, out edx_1317);
			esp_257.u0 = <invalid>;
			goto l0806907A;
		}
		esi_312.u0 = 0x07;
	}
	else
		esi_312.u0 = 0x04;
l08068E5B:
	if (dwArg14 != 0x00)
	{
l08068E27:
		*dwArg14 = ebx_261;
		goto l08068E2D;
	}
l08068E63:
	*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
	if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
	{
		if (dwLoc60_706 < ebx_261)
		{
			struct Eq_56212 * eax_408 = *dwArg08;
			word32 edx_1323;
			word32 ecx_1322;
			_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc44_675, out ecx_1322, out edx_1323);
			word32 ecx_460;
			word32 edx_461;
			fn00000000();
			dwLoc80 = dwArg20;
			esp_257 = fp - 0x6C;
			if (eax_459 != 0x04)
			{
				if (eax_408 != ebx_261)
					*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_261 - eax_408));
				if (eax_459 == 0x00)
				{
l08068EC5:
					ebp_247 = (ui32) *((word32) dwArg08 + 8);
					dwLoc60_706 = (struct Eq_56212 *) *dwArg08;
					goto l08068D80;
				}
l0806907A:
				esi_312 = eax_459;
			}
			else if (esi_312 == 0x05)
				goto l08068EC5;
		}
	}
	else
	{
		*dwArg08 = ebx_261;
		*dwArg18 = *dwArg18;
	}
	if (*((word32) esp_257 + 0x008C) == null || esi_312 != 0x07)
		goto l08068E2D;
	struct Eq_56393 * ebp_494 = *((byte) esp_257.u0 + 20);
	struct Eq_56393 * edx_495 = **((byte) esp_257.u0 + 16);
	if (ebp_494 - edx_495 <= 0x03)
	{
		ui32 eax_550;
		ui32 * ecx_545 = *((word32) edi_22 + 20);
		struct Eq_56393 * eax_546 = edx_495;
		struct Eq_56445 * ebx_547 = ecx_545 + 1;
		if (edx_495 < ebp_494)
		{
			do
			{
				++eax_546;
				**((byte) esp_257.u0 + 16) = eax_546;
				++ebx_547;
				ebx_547->bFFFFFFFF = eax_546->bFFFFFFFF;
			} while (eax_546 != *((byte) esp_257.u0 + 20));
			eax_550 = eax_546 - edx_495;
		}
		else
			eax_550 = 0x00;
		*ecx_545 = eax_550 | *ecx_545 & ~0x07;
l08068E2D:
		if ((esi_33 ^ gs->t0014) == 0x00)
			return;
		word32 ecx_1314;
		word32 edx_1315;
		__stack_chk_fail(out ecx_1314, out edx_1315);
		__gconv_transform_ascii_internal(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
		return;
	}
	Eq_2 edi_500 = *((byte) esp_257.u0 + 52);
	struct Eq_56411 * esp_502 = esp_257 - 4;
	esp_502->dw0000 = (word32) edi_500 - 166080;
	esp_502->dwFFFFFFFC = 777;
	esp_502->dwFFFFFFF8 = (word32) edi_500 - 167166;
	esp_502->dwFFFFFFF4 = (word32) edi_500 - 167126;
	word32 ecx_1318;
	word32 edx_1319;
	__assert_fail(out ecx_1318, out edx_1319);
	esp_18.u0 = <invalid>;
l08069057:
	edi_22 = *((word32) esp_18 + 52);
	struct Eq_56232 * esp_523 = esp_18 - 4;
	esp_523->dw0000 = (word32) edi_22 - 166080;
	esp_523->dwFFFFFFFC = 0x019F;
	esp_377 = esp_523 - 4;
	goto l08069067;
}

// subject_text_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080690C0: void __gconv_transform_ascii_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_56160) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      __gconv_transform_ucs4le_internal
void __gconv_transform_ascii_internal(struct Eq_9 * gs, struct Eq_56160 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2175 esi_31 = gs->t0014;
	ui32 edx_176 = *((word32) dwArg08 + 8);
	Eq_2 esp_170 = fp - 0x5C;
	Eq_2175 dwLoc20_451 = esi_31;
	Eq_2 dwLoc3C_452 = 0x00;
	if (((byte) edx_176 & 0x01) == 0x00)
	{
		Eq_2 esi_43 = dwArg04->t0050;
		dwLoc3C_452 = esi_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc3C_452 = __ror(esi_43, 0x09) ^ gs->t0018;
	}
	Eq_2 eax_294;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 != 0x00)
		{
			word32 ecx_732;
			word32 edx_733;
			__assert_fail(out ecx_732, out edx_733);
			goto l080693D2;
		}
		struct Eq_56739 * eax_86 = *((word32) dwArg08 + 20);
		eax_86->dw0000 = 0x00;
		eax_86->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_734;
			word32 edx_735;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc3C_452, out ecx_734, out edx_735);
			fn00000000();
		}
l080692F7:
		if ((dwLoc20_451 ^ gs->t0014) == 0x00)
			return;
l080693D2:
		word32 ecx_736;
		word32 edx_737;
		eax_294 = __stack_chk_fail(out ecx_736, out edx_737);
		esp_170.u0 = <invalid>;
		goto l080693D7;
	}
	else
	{
		Eq_2 eax_135 = dwArg14;
		if (dwArg14 == 0x00)
			eax_135 = dwArg08;
		Eq_56722 ebx_153 = *eax_135;
		Eq_2 ecx_163 = *dwArg0C;
		while (dwArg10 != ecx_163)
		{
			Eq_56722 esi_169 = (word32) ebx_153 + 4;
			if (esi_169 <= *((word32) esp_170 + 4))
			{
				*((word32) esp_170 + 0x0C) = 0x04;
				*((word32) esp_170 + 24) = edx_176 & 0x02;
				Eq_2 eax_181 = ecx_163;
				do
				{
					word32 edx_186 = (word32) *eax_181;
					ecx_163 = eax_181;
					if ((byte) edx_186 < 0x00)
					{
						word32 * esi_202 = *((byte) esp_170.u0 + 44);
						if (esi_202 == null || *((byte) esp_170.u0 + 24) == 0x00)
						{
							*((byte) esp_170.u0 + 0x0C) = 0x06;
							goto l08069210;
						}
						++*esi_202;
						*((byte) esp_170.u0 + 0x0C) = 0x06;
						eax_181 = (word32) eax_181 + 1;
						ecx_163 = eax_181;
						if (dwArg10 == eax_181)
							goto l08069210;
					}
					else
					{
						*ebx_153 = edx_186;
						eax_181 = (word32) eax_181 + 1;
						ebx_153 = esi_169;
						ecx_163 = eax_181;
						if (dwArg10 == eax_181)
							goto l08069210;
					}
					esi_169 = (word32) ebx_153 + 4;
				} while (*((byte) esp_170.u0 + 4) >= esi_169);
				*((word32) esp_170 + 0x0C) = 0x05;
			}
			else
			{
				ebx_153 = *((word32) esp_170 + 8);
				*((word32) esp_170 + 0x0C) = 0x05;
			}
l08069210:
			**((word32) esp_170 + 16) = ecx_163;
			if (*((word32) esp_170 + 20) != null)
			{
l080692C0:
				**((byte) esp_170.u0 + 20) = ebx_153;
				dwLoc20_451 = esi_31;
				goto l080692F7;
			}
l08069222:
			*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
			dwLoc20_451 = esi_31;
			if ((*((word32) dwArg08 + 8) & 0x01) != 0x00)
			{
				*dwArg08 = ebx_153;
				word32 * edi_248 = *((byte) esp_170.u0 + 28);
				*edi_248 = (word32) *((byte) esp_170.u0 + 52) + *edi_248;
				goto l080692F7;
			}
			if (ebx_153 <= *((byte) esp_170.u0 + 8))
				goto l080692F7;
			struct Eq_56910 * esp_256 = esp_170 - 0x0C;
			esp_256->t0044 = *dwArg08;
			esp_256->tFFFFFFFC = esp_256->t002C;
			word32 edx_739;
			word32 ecx_738;
			_dl_mcount_wrapper_check(gs, esp_256->tFFFFFFF8, esp_256->tFFFFFFFC, out ecx_738, out edx_739);
			esp_256->tFFFFFFF8 = esp_256->t0088;
			esp_256->dwFFFFFFF4 = 0x00;
			esp_256->dwFFFFFFF0 = esp_256->dw0028;
			esp_256->dwFFFFFFEC = 0x00;
			esp_256->tFFFFFFE8 = ebx_153;
			esp_256->ptrFFFFFFE4 = (word32 *) &esp_256->t0044;
			esp_256->dwFFFFFFE0 = esp_256->dw0034;
			esp_256->dwFFFFFFDC = esp_256->dw0030;
			fn00000000();
			esp_170 = (char *) &esp_256->tFFFFFFFC + 16;
			if (eax_294 != 0x04)
			{
				Eq_56722 edx_302 = esp_256->t0044;
				if (ebx_153 != edx_302)
				{
					Eq_56993 ebx_305 = ebx_153 - edx_302;
					union Eq_2 * esi_307 = esp_256->ptr001C;
					if (ebx_305 < 0x00)
						ebx_305 = (word32) ebx_305 + 3;
					*esi_307 = (union Eq_2 *) (*esi_307 - (ebx_305 >> 0x02));
				}
				if (eax_294 != 0x00)
				{
l080693D7:
					*((word32) esp_170 + 0x0C) = eax_294;
					goto l080692F7;
				}
			}
			else if (esp_256->dw0018 != 0x05)
				goto l080692F7;
			edx_176 = (ui32) *((word32) dwArg08 + 8);
			esp_256->t0014 = *dwArg08;
			ebx_153 = esp_256->t0014;
			ecx_163 = *esp_256->ptr001C;
		}
		union Eq_2 * eax_344 = *((word32) esp_170 + 16);
		*((word32) esp_170 + 0x0C) = 0x04;
		*eax_344 = (union Eq_2 *) ecx_163;
		if (*((word32) esp_170 + 20) != 0x00)
			goto l080692C0;
		goto l08069222;
	}
}

// 080693E0: void __gconv_transform_internal_ascii(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57052) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ascii(struct Eq_9 * gs, struct Eq_57052 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - (struct Eq_57062 *) 0x8C;
	Eq_2 esi_23 = dwArg08;
	ui32 ebp_26 = *((word32) dwArg08 + 8);
	Eq_2175 ecx_34 = gs->t0014;
	Eq_2 dwLoc68_1040 = 0x00;
	if ((ebp_26 & 0x01) == 0x00)
	{
		Eq_2 ecx_45 = dwArg04->t0050;
		dwLoc68_1040 = ecx_45;
		if (dwArg04->dw003C != 0x00)
			dwLoc68_1040 = __ror(ecx_45, 0x09) ^ gs->t0018;
	}
	Eq_2 esp_497;
	Eq_2 esp_360;
	ptr32 esp_825;
	Eq_2 esi_821;
	if (dwArg1C == 0x00)
	{
		Eq_2 edx_122 = dwArg14;
		Eq_2 eax_124 = *dwArg0C;
		if (dwArg14 == 0x00)
			edx_122 = dwArg08;
		Eq_2 ebx_131 = *edx_122;
		Eq_2 ebx_136 = *((word32) dwArg08 + 4);
		word32 * ebx_141 = null;
		if (dwArg18 != null)
			ebx_141 = fp - 0x30;
		Eq_2 edi_1001;
		Eq_2 esp_409;
		Eq_2 ebp_488;
		ui32 edx_486;
		if (dwArg20 == 0x00)
		{
l080694E1:
			edx_486 = ebp_26;
			edi_1001 = dwArg10;
			ebp_488 = ebx_131;
			esi_23 = dwArg08;
			goto l080694F0;
		}
		struct Eq_57145 * ebx_153 = *((word32) dwArg08 + 20);
		ui32 edx_154 = ebx_153->dw0000;
		ui32 dwLoc4C_1080 = edx_154;
		struct Eq_57188 * dwLoc7C_1081 = edx_154 & 0x07;
		if ((edx_154 & 0x07) == 0x00)
			goto l080694E1;
		if (dwArg14 != 0x00)
			goto l08069BFD;
		Eq_2 dwLoc28_1084 = ebx_131;
		if ((edx_154 & 0x07) > 0x04)
		{
			word32 ecx_1869;
			word32 edx_1870;
			__assert_fail(out ecx_1869, out edx_1870);
			__gconv_transform_internal_utf8(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
			return;
		}
		up32 edx_210;
		int32 edx_205 = 0x00;
		if ((edx_154 & 0x07) != 0x00)
		{
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[edx_205].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_57512) (&ebx_153->dw0004)[edx_205];
				++edx_205;
			} while ((edx_154 & 0x07) != edx_205);
			edx_210 = 0x04 - (edx_154 & 0x07);
		}
		else
			edx_210 = 0x04;
		if (dwArg10 < (word32) eax_124 + edx_210)
		{
			*dwArg0C = (union Eq_2 *) dwArg10;
			if (eax_124 < dwArg10)
			{
				Eq_2 eax_242 = (word32) eax_124 + 1;
				struct Eq_57817 * ebx_244 = ebx_153 + (edx_154 & 0x07) / 8;
				while (true)
				{
					++ebx_244;
					ebx_244[3] = (struct Eq_57817) *((word32) eax_242 - 1);
					Eq_2 edx_254 = (word32) eax_242 + 1;
					if (dwArg10 == eax_242)
						break;
					eax_242 = edx_254;
				}
			}
			goto l08069A87;
		}
		Eq_2 edx_259 = eax_124;
		if (ebx_131 >= ebx_136)
			goto l08069600;
		Eq_57530 ebx_268 = edx_154 & 0x07;
		do
		{
			edx_259 = (word32) edx_259 + 1;
			ebx_268 = (word32) ebx_268 + 1;
			Mem278[fp - 0x25 + ebx_268:byte] = Mem274[edx_259 + -1:byte];
		} while (ebx_268 <= 0x03 && dwArg10 > edx_259);
		struct Eq_57188 * eax_302;
		byte dl_473 = (byte) dwLoc24;
		struct Eq_57145 * ebx_293 = ebx_153;
		if (dwLoc24 <= 0x7F)
		{
			*ebx_131 = dl_473;
			dwLoc28_1084 = (word32) ebx_131 + 1;
			if (fp - 0x20 != fp - (struct Eq_57564 *) 0x24)
			{
				ui32 ecx_490 = ebx_153->dw0000;
				eax_302 = fp - 0x20 - (fp - (struct Eq_57564 *) 0x24);
				dwLoc4C_1080 = ecx_490;
				dwLoc7C_1081 = ecx_490 & 0x07;
				goto l080697A9;
			}
			goto l08069982;
		}
		if (dwLoc24 >> 0x07 == 0x1C00)
		{
			eax_302 = (struct Eq_57188 *) 0x04;
			goto l080697A9;
		}
		if (ebx_141 == null)
		{
l08069B00:
			goto l08069600;
		}
		struct Eq_57188 * eax_363;
		if ((ebp_26 & 0x08) == 0x00)
		{
			if ((ebp_26 & 0x02) == 0x00)
				goto l08069600;
			goto l08069AC6;
		}
		word32 edi_319 = ebx_268 + (fp - 0x24);
		dwLocA0 = fp - (struct Eq_57643 *) 44;
		ui32 ebp_349;
		word32 edi_1873;
		word32 eax_348 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_57643 *) 44, edi_319, fp - (struct Eq_57650 *) 0x28, ebx_141, out ebx_293, out ebp_349, out esi_23, out edi_1873);
		esp_360 = fp - (struct Eq_57657 *) 0x8C;
		Eq_2 ecx_362 = fp - (struct Eq_57564 *) 0x24;
		eax_363 = fp - (struct Eq_57564 *) 0x24;
		if (eax_348 == 0x06)
		{
			if ((ebp_349 & 0x02) == 0x00)
			{
l08069AD4:
				if (eax_363 != fp - (struct Eq_57564 *) 0x24)
				{
l08069AD8:
					ui32 edi_460 = ebx_293->dw0000;
					eax_302 = eax_363 - (fp - (struct Eq_57564 *) 0x24);
					dwLoc4C_1080 = edi_460;
					dwLoc7C_1081 = edi_460 & 0x07;
l080697A9:
					esp_497 = fp - (struct Eq_57062 *) 0x8C;
					if (eax_302 <= dwLoc7C_1081)
						goto l08069BD5;
					ui32 ebp_508 = *((word32) esi_23 + 8);
					eax_124 = (char *) *dwArg0C + (eax_302 - dwLoc7C_1081);
					*dwArg0C = (union Eq_2 *) eax_124;
					ebx_293->dw0000 = dwLoc4C_1080 & ~0x07;
					edx_486 = ebp_508;
					ebp_488 = dwLoc28_1084;
					edi_1001 = dwArg10;
l080694F0:
					while (true)
					{
						ui32 edx_529 = edx_486 & 0x02;
						Eq_2 dwLoc2C_1209 = eax_124;
						Eq_2 ebx_536 = ebp_488;
						Eq_2 dwLoc28_1210 = ebp_488;
						word32 dwLoc7C_1211 = 0x04;
l08069509:
						if (edi_1001 != eax_124)
						{
							do
							{
								Eq_2 ecx_545 = (word32) eax_124 + 4;
								if (edi_1001 < ecx_545)
								{
									*dwArg0C = (union Eq_2 *) eax_124;
									dwLoc7C_1211 = 0x07;
									if (dwArg14 != 0x00)
										goto l080695FA;
									goto l08069562;
								}
								if (ebx_136 <= ebx_536)
								{
									dwLoc7C_1211 = 0x05;
									break;
								}
								uint32 edx_562 = *eax_124;
								byte dl_638 = (byte) edx_562;
								if (edx_562 > 0x7F)
								{
									if (edx_562 >> 0x07 == 0x1C00)
									{
										dwLoc2C_1209 = ecx_545;
										eax_124 = ecx_545;
										goto l08069509;
									}
									if (ebx_141 != null)
									{
										if ((*((word32) esi_23 + 8) & 0x08) != 0x00)
										{
											word32 ebx_1864;
											word32 eax_601 = __gconv_transliterate(gs, dwArg04, esi_23, fp - 44, edi_1001, fp - 0x28, ebx_141, out ebx_1864, out ebp_488, out esi_23, out edi_1001);
											dwLocA0 = fp - 44;
											dwLoc7C_1211 = eax_601;
											ebx_536 = dwLoc28_1210;
											eax_124 = dwLoc2C_1880;
											if (eax_601 != 0x06)
											{
												if (eax_601 == 0x05)
													break;
												goto l08069509;
											}
										}
										if (edx_529 != 0x00)
										{
											++*ebx_141;
											eax_124 = (word32) eax_124 + 4;
											dwLoc7C_1211 = 0x06;
											dwLoc2C_1209 = eax_124;
											goto l08069509;
										}
									}
									dwLoc7C_1211 = 0x06;
									break;
								}
								Eq_2 eax_636 = (word32) ebx_536 + 1;
								*ebx_536 = dl_638;
								dwLoc28_1210 = eax_636;
								ebx_536 = eax_636;
								eax_124 = (word32) dwLoc2C_1880 + 4;
								dwLoc2C_1209 = (word32) dwLoc2C_1880 + 4;
								dwLoc2C_1880 = dwLoc2C_1209;
							} while (edi_1001 != (word32) dwLoc2C_1880 + 4);
						}
						*dwArg0C = (union Eq_2 *) eax_124;
						if (dwArg14 != 0x00)
							break;
l08069562:
						*((word32) esi_23 + 0x0C) = (word32) *((word32) esi_23 + 0x0C) + 1;
						if ((*((word32) esi_23 + 8) & 0x01) != 0x00)
						{
							*esi_23 = ebx_536;
							*dwArg18 = *dwArg18;
							goto l080697F0;
						}
						word32 eax_701;
						if (ebp_488 < ebx_536)
						{
							Eq_2 eax_702 = *esi_23;
							word32 edx_1866;
							word32 ecx_1865;
							_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc68_1040, out ecx_1865, out edx_1866);
							word32 edx_752;
							fn00000000();
							dwLocA0 = dwArg20;
							if (eax_701 != 0x04)
							{
								if (eax_702 != ebx_536)
									*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_536 - eax_702) * 0x04);
								goto l080695C5;
							}
							eax_701 = dwLoc7C_1211;
							if (dwLoc7C_1211 != 0x05 && dwLoc7C_1211 != 0x00)
								goto l08069685;
							goto l080695CD;
						}
						eax_701 = dwLoc7C_1211;
l080695C5:
						if (eax_701 != 0x00)
						{
l08069685:
							dwLoc7C_1211 = eax_701;
l080697F0:
							esp_409 = fp - (struct Eq_57062 *) 0x8C;
							if (dwLoc7C_1211 != 0x07 || dwArg20 == 0x00)
								goto l08069600;
							Eq_2 ebp_793 = *dwArg0C;
							if (edi_1001 - ebp_793 > 0x03)
								goto l08069B49;
							struct Eq_57435 * eax_835;
							struct Eq_57145 * ebx_830 = *((word32) esi_23 + 20);
							word32 eax_831 = ebp_793 + 0x01;
							union Eq_57443 * edx_832 = &ebx_830->dw0004;
							if (ebp_793 < edi_1001)
							{
								while (true)
								{
									*dwArg0C = (union Eq_2 *) eax_831;
									edx_832 = (union Eq_57443 *) ((char *) edx_832 + 1);
									*((char *) edx_832 - 1) = (union Eq_57443 *) *((word32) eax_831 - 1);
									word32 ecx_848 = eax_831 + 0x01;
									if (eax_831 == edi_1001)
										break;
									eax_831 = ecx_848;
								}
								eax_835 = eax_831 - ebp_793;
							}
							else
								eax_835 = null;
							ebx_830->dw0000 = eax_835 | ebx_830->dw0000 & ~0x07;
							goto l08069600;
						}
l080695CD:
						edx_486 = (ui32) *((word32) esi_23 + 8);
						ebp_488 = *esi_23;
						eax_124 = *dwArg0C;
					}
l080695FA:
					*dwArg14 = ebx_536;
l08069600:
					if ((ecx_34 ^ gs->t0014) == 0x00)
						return;
l08069BF8:
					word32 ecx_1862;
					word32 edx_1863;
					__stack_chk_fail(out ecx_1862, out edx_1863);
					esp_18.u0 = <invalid>;
l08069BFD:
					esi_821 = *((byte) esp_18.u0 + 60);
					struct Eq_57478 * esp_899 = esp_18 - 4;
					esp_899->dw0000 = (word32) esi_821 - 166208;
					esp_899->dwFFFFFFFC = 0x022F;
					esp_825 = esp_899 - 4;
l08069B7C:
					struct Eq_57239 * esp_906 = esp_825 - 4;
					esp_906->dw0000 = (word32) esi_821 - 167166;
					esp_906->dwFFFFFFFC = (word32) esi_821 - 167146;
					word32 ecx_1860;
					word32 edx_1861;
					__assert_fail(out ecx_1860, out edx_1861);
					esp_360.u0 = <invalid>;
					goto l08069B8F;
				}
				goto l08069B00;
			}
l08069AC6:
			++*ebx_141;
			eax_363 = fp - (struct Eq_57676 *) 0x20;
			goto l08069AD4;
		}
		if (fp - (struct Eq_57564 *) 0x24 != fp - (struct Eq_57564 *) 0x24)
			goto l08069AD8;
		if (eax_348 != 0x07)
		{
			if (eax_348 != 0x00)
				goto l08069600;
l08069982:
			edi_1001 = dwArg10;
			edx_486 = (ui32) *((word32) esi_23 + 8);
			eax_124 = *dwArg0C;
			ebp_488 = ebx_131;
			goto l080694F0;
		}
		if (edi_319 == fp - (struct Eq_57699 *) 0x20)
			goto l08069BB2;
		ui32 eax_380 = ebx_293->dw0000;
		Mem390[dwArg0C + 0x00:word32] = Mem359[dwArg0C + 0x00:word32] + (ebx_268 - (eax_380 & 0x07));
		if ((eax_380 & ~0x07) >= ebx_268)
		{
l08069B8F:
			Eq_2 esi_920 = *((byte) esp_360.u0 + 60);
			struct Eq_57755 * esp_922 = esp_360 - (struct Eq_57756 *) 4;
			esp_922->dw0000 = (word32) esi_920 - 166656;
			esp_922->tFFFFFFFC.u0 = 0x01E5;
			esp_922->tFFFFFFF8 = (word32) esi_920 - 167069;
			esp_922->tFFFFFFF4 = (word32) esi_920 - 166884;
			word32 edx_1877;
			word32 ecx_1876;
			__assert_fail(out ecx_1876, out edx_1877);
			esp_360.u0 = <invalid>;
l08069BB2:
			Eq_2 esi_941 = *((byte) esp_360.u0 + 60);
			struct Eq_57706 * esp_943 = esp_360 - (struct Eq_57707 *) 4;
			esp_943->dw0000 = (word32) esi_941 - 166656;
			esp_943->tFFFFFFFC.u0 = 0x01DB;
			esp_943->tFFFFFFF8 = (word32) esi_941 - 167069;
			esp_943->tFFFFFFF4 = (word32) esi_941 - 0x00028C08;
			word32 ecx_1874;
			word32 edx_1875;
			__assert_fail(out ecx_1874, out edx_1875);
			esp_497.u0 = <invalid>;
l08069BD5:
			Eq_2 esi_962 = *((word32) esp_497 + 60);
			struct Eq_57587 * esp_964 = esp_497 - 4;
			esp_964->dw0000 = (word32) esi_962 - 166656;
			esp_964->dwFFFFFFFC = 0x01C9;
			esp_964->dwFFFFFFF8 = (word32) esi_962 - 167069;
			esp_964->dwFFFFFFF4 = (word32) esi_962 - 166960;
			word32 edx_1872;
			word32 ecx_1871;
			__assert_fail(out ecx_1871, out edx_1872);
			goto l08069BF8;
		}
		if (ebx_268 <= 0x04)
		{
			ebx_293->dw0000 = eax_380 & ~0x07 | ebx_268;
			if (edi_319 > fp - (struct Eq_57564 *) 0x24)
			{
				struct Eq_57798 * eax_418 = &ebx_293->dw0004;
				do
				{
					++ecx_362;
					++eax_418;
					eax_418->bFFFFFFFF = (byte) *((word32) ecx_362 - 1);
				} while (edi_319 != ecx_362);
			}
l08069A87:
			goto l08069600;
		}
		word32 edx_1879;
		word32 ecx_1878;
		__assert_fail(out ecx_1878, out edx_1879);
		esp_409.u0 = <invalid>;
l08069B49:
		Eq_2 esi_800 = *((word32) esp_409 + 60);
		struct Eq_57407 * esp_802 = esp_409 - 4;
		esp_802->dw0000 = (word32) esi_800 - 166208;
		esp_802->dwFFFFFFFC = 777;
		esp_802->dwFFFFFFF8 = (word32) esi_800 - 167166;
		esp_802->dwFFFFFFF4 = (word32) esi_800 - 167126;
		word32 edx_1868;
		word32 ecx_1867;
		__assert_fail(out ecx_1867, out edx_1868);
		esp_18.u0 = <invalid>;
	}
	else if (dwArg14 == 0x00)
	{
		struct Eq_57145 * eax_69 = *((word32) dwArg08 + 20);
		eax_69->dw0000 = 0x00;
		eax_69->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 edx_1859;
			word32 ecx_1858;
			_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc68_1040, out ecx_1858, out edx_1859);
			word32 edx_113;
			fn00000000();
		}
		goto l08069600;
	}
	esi_821 = *((word32) esp_18 + 60);
	struct Eq_57131 * esp_823 = esp_18 - 4;
	esp_823->dw0000 = (word32) esi_821 - 166208;
	esp_823->dwFFFFFFFC = 0x019F;
	esp_825 = esp_823 - 4;
	goto l08069B7C;
}

// 08069C40: void __gconv_transform_internal_utf8(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57052) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      __gconv_transform_internal_ascii
void __gconv_transform_internal_utf8(struct Eq_9 * gs, struct Eq_57052 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_1046 = fp - 0x7C;
	Eq_2 edi_1038 = dwArg08;
	Eq_2 ebp_1012 = dwArg10;
	Eq_2175 esi_32 = gs->t0014;
	Eq_2 dwLoc5C_1534 = 0x00;
	Eq_2 esi_1070 = *((word32) dwArg08 + 8);
	if ((esi_1070 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc5C_1534 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc5C_1534 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_57865 edx_1108;
	Eq_57866 eax_1159;
	ptr32 esp_1254;
	Eq_57868 ecx_1114;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 != 0x00)
		{
			edi_1038.u0 = 0x080CE000;
			esp_1254 = fp - 0x84;
			goto l0806A69C;
		}
		struct Eq_57914 * eax_74 = *((word32) dwArg08 + 20);
		eax_74->dw0000 = 0x00;
		eax_74->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_2701;
			word32 edx_2702;
			_dl_mcount_wrapper_check(gs, dwLoc90, dwLoc5C_1534, out ecx_2701, out edx_2702);
			word32 ecx_118;
			word32 edx_119;
			fn00000000();
			dwLoc90 = dwArg20;
		}
l08069E60:
		if ((esi_32 ^ gs->t0014) == 0x00)
			return;
l0806A783:
		word32 ecx_2705;
		word32 edx_2706;
		__stack_chk_fail(out ecx_2705, out edx_2706);
		esp_1046.u0 = <invalid>;
		goto l0806A788;
	}
	Eq_2 eax_127 = *dwArg0C;
	Eq_2 eax_131 = dwArg14;
	if (dwArg14 == 0x00)
		eax_131 = dwArg08;
	byte * eax_136 = *eax_131;
	byte * eax_141 = *((word32) dwArg08 + 4);
	word32 * eax_146 = null;
	if (dwArg18 != null)
		eax_146 = fp - 0x34;
	if (dwArg20 == 0x00)
	{
l08069D40:
		Eq_58004 (* ecx_488)[] = *((word32) esp_1046 + 4);
		Eq_2 eax_1049 = *((word32) esp_1046 + 16);
		*((word32) esp_1046 + 8) = 0x04;
		*((word32) esp_1046 + 20) = esi_1070 & 0x02;
		*((word32) esp_1046 + 80) = eax_1049;
		*((word32) esp_1046 + 84) = ecx_488;
		Eq_58004 ebx_1048[] = ecx_488;
l08069D61:
		if (ebp_1012 != eax_1049)
		{
			do
			{
				if (ebp_1012 < (word32) eax_1049 + 4)
				{
					esi_1070 = *((word32) esp_1046 + 0x0C);
					*((word32) esp_1046 + 8) = 0x07;
					*esi_1070 = eax_1049;
					if (*((word32) esp_1046 + 24) != 0x00)
						goto l08069E5A;
					goto l08069DB2;
				}
				if (*esp_1046 <= ebx_1048)
				{
l08069E80:
					*((word32) esp_1046 + 8) = 0x05;
					break;
				}
				Eq_58000 edx_520 = *eax_1049;
				Eq_58004 dl_589 = (byte) edx_520;
				if (edx_520 <= 0x7F)
				{
					*((word32) esp_1046 + 84) = (char *) ebx_1048 + 1;
					ebx_1048[0] = dl_589;
					goto l08069D8D;
				}
				if (edx_520 <= ~0xDFFE || edx_520 < 0x00)
					goto l0806A1B0;
				Eq_59044 ecx_532;
				if ((edx_520 & ~0x07FF) != 0x00)
				{
					if ((edx_520 & 0xFFFF0000) != 0x00)
					{
						if ((edx_520 & 0xFFE00000) != 0x00)
							ecx_532 = (uint32) (int8) ((edx_520 & 0xFC000000) != 0x00) + 0x05;
						else
							ecx_532.u0 = 0x04;
					}
					else
						ecx_532.u0 = 0x03;
				}
				else
					ecx_532.u0 = 0x02;
				byte cl_560 = (byte) ecx_532;
				if (Mem509[esp_1046 + 0x00:word32] <u ebx_1048 + ecx_532)
					goto l08069E80;
				ui32 * esi_559 = *((word32) esp_1046 + 20);
				ebx_1048[0] = (byte) (~0xFF >> cl_560);
				Mem565[esp_1046 + 0x54:word32] = Mem563[esp_1046 + 0x54:word32] + ecx_532;
				do
				{
					--ecx_532;
					Mem576[ebx_1048 + ecx_532:byte] = SLICE(edx_520, byte, 0) & 0x3F | 0x80;
					edx_520 >>= 0x06;
					byte dl_582 = (byte) edx_520;
				} while (ecx_532 != 0x01);
				*((word32) esp_1046 + 20) = esi_559;
				Mem584[ebx_1048 + 0x00:byte] = Mem581[ebx_1048 + 0x00:byte] | dl_582;
l08069D8D:
				word32 eax_593 = *((word32) esp_1046 + 80);
				ebx_1048 = (Eq_58004 (*)[]) *((word32) esp_1046 + 84);
				*((word32) esp_1046 + 80) = eax_593 + 0x04;
				eax_1049 = eax_593 + 0x04;
			} while (ebp_1012 != eax_593 + 0x04);
		}
		while (true)
		{
			esi_1070 = *((word32) esp_1046 + 0x0C);
			*esi_1070 = eax_1049;
			if (*((word32) esp_1046 + 24) != 0x00)
				break;
l08069DB2:
			*((byte) edi_1038.u0 + 0x0C) = (word32) *((byte) edi_1038.u0 + 0x0C) + 1;
			if ((*((byte) edi_1038.u0 + 8) & 0x01) != 0x00)
			{
				esi_1070 = *((word32) esp_1046 + 28);
				word32 eax_632 = *((word32) esp_1046 + 72);
				*edi_1038.u0 = ebx_1048;
				*esi_1070 = (word32) *esi_1070 + eax_632;
				goto l0806A084;
			}
			if (*((word32) esp_1046 + 4) >= ebx_1048)
			{
				esi_1070 = *((word32) esp_1046 + 8);
				goto l08069E16;
			}
			struct Eq_58063 * esp_642 = esp_1046 - 0x0C;
			esp_642->ptr0058 = (Eq_58004 (*)[]) *edi_1038.u0;
			esp_642->tFFFFFFFC = esp_642->t002C;
			word32 edx_2704;
			word32 ecx_2703;
			_dl_mcount_wrapper_check(gs, esp_642->tFFFFFFF8, esp_642->tFFFFFFFC, out ecx_2703, out edx_2704);
			esp_642->tFFFFFFF8 = esp_642->t00A8;
			esp_642->dwFFFFFFF4 = 0x00;
			esp_642->dwFFFFFFF0 = esp_642->dw0028;
			esp_642->dwFFFFFFEC = 0x00;
			esp_642->ptrFFFFFFE8 = ebx_1048;
			esp_642->ptrFFFFFFE4 = &esp_642->ptr0058;
			esp_642->dwFFFFFFE0 = esp_642->dw0034;
			esp_642->dwFFFFFFDC = esp_642->dw0030;
			Eq_2 eax_692;
			word32 ecx_693;
			word32 edx_694;
			fn00000000();
			esi_1070 = eax_692;
			esp_1046 = (char *) &esp_642->tFFFFFFFC + 16;
			if (eax_692 == 0x04)
			{
				esi_1070 = esp_642->t0014;
				if (esi_1070 == 0x05)
					goto l08069E1E;
				goto l08069E16;
			}
			Eq_58004 (* edx_1488)[] = esp_642->ptr0058;
			if (edx_1488 == ebx_1048)
				goto l08069E16;
			Eq_2 eax_706 = esp_642->t001C;
			union Eq_2 * ecx_707 = esp_642->ptr0018;
			esp_642->t0020 = eax_692;
			esp_642->t001C.u0 = 0x04;
			*ecx_707 = (union Eq_2 *) eax_706;
			Eq_58004 (* ecx_711)[] = esp_642->ptr0010;
			esp_642->t005C = eax_706;
			esp_642->ptr0060 = ecx_711;
			Eq_2 ecx_715 = *((byte) edi_1038.u0 + 8);
			esp_642->t0014 = edi_1038;
			esp_642->dw0044 = ecx_715 & 0x02;
			ebx_1048 = ecx_711;
l0806A12A:
			if (ebp_1012 != eax_706)
			{
				do
				{
					if (ebp_1012 < (word32) eax_706 + 4)
						goto l0806A23E;
					if (edx_1488 <= ebx_1048)
						goto l0806A2C1;
					Eq_58363 esi_735 = *eax_706;
					if (esi_735 <= 0x7F)
					{
						*((byte) esp_1046.u0 + 84) = (char *) ebx_1048 + 1;
						ebx_1048[0] = (byte) esi_735;
					}
					else
					{
						if (esi_735 <= ~0xDFFE || esi_735 < 0x00)
						{
							if (*((byte) esp_1046.u0 + 48) == 0x00)
								goto l0806A23E;
							if ((*((word32) *((byte) esp_1046.u0 + 8) + 8) & 0x08) == 0x00)
								goto l0806A5F7;
							goto l0806A271;
						}
						Eq_58833 ecx_758;
						if ((esi_735 & ~0x07FF) != 0x00)
						{
							if ((esi_735 & 0xFFFF0000) != 0x00)
							{
								if ((esi_735 & 0xFFE00000) != 0x00)
									ecx_758 = (uint32) (int8) ((esi_735 & 0xFC000000) != 0x00) + 0x05;
								else
									ecx_758.u0 = 0x04;
							}
							else
								ecx_758.u0 = 0x03;
						}
						else
							ecx_758.u0 = 0x02;
						byte cl_785 = (byte) ecx_758;
						if (edx_1488 <u ebx_1048 + ecx_758)
							goto l0806A2C1;
						word32 edi_784 = *((byte) esp_1046.u0 + 8);
						ebx_1048[0] = (byte) (~0xFF >> cl_785);
						Mem790[esp_1046 + 0x54:word32] = Mem788[esp_1046 + 0x54:word32] + ecx_758;
						do
						{
							--ecx_758;
							Mem801[ebx_1048 + ecx_758:byte] = SLICE(esi_735, byte, 0) & 0x3F | 0x80;
							esi_735 >>= 0x06;
						} while (ecx_758 != 0x01);
						*((byte) esp_1046.u0 + 8) = edi_784;
						Mem810[ebx_1048 + 0x00:byte] = Mem807[ebx_1048 + 0x00:byte] | SLICE(esi_735, byte, 0);
					}
					word32 eax_820 = *((byte) esp_1046.u0 + 80);
					ebx_1048 = (Eq_58004 (*)[]) *((byte) esp_1046.u0 + 84);
					*((byte) esp_1046.u0 + 80) = eax_820 + 0x04;
					eax_706 = eax_820 + 0x04;
				} while (ebp_1012 != eax_820 + 0x04);
			}
			esi_1070 = *((byte) esp_1046.u0 + 20);
			edi_1038 = *((byte) esp_1046.u0 + 8);
			**((byte) esp_1046.u0 + 0x0C) = ebp_1012;
			if (*((byte) esp_1046.u0 + 76) == ebx_1048)
			{
				if (*((byte) esp_1046.u0 + 16) != 0x05)
					goto l0806A18D;
l0806A2E5:
				if (*((byte) esp_1046.u0 + 4) == ebx_1048)
					--*((byte) edi_1038.u0 + 0x0C);
l08069E16:
				if (esi_1070 != 0x00)
				{
					*((word32) esp_1046 + 8) = esi_1070;
l0806A084:
					if (*((byte) esp_1046.u0 + 0x009C) == 0x00 || *((word32) esp_1046 + 8) != 0x07)
						goto l08069E60;
					esi_1070 = **((word32) esp_1046 + 0x0C);
					if (ebp_1012 - esi_1070 > 0x03)
					{
						edi_1038 = *((word32) esp_1046 + 44);
						struct Eq_58651 * esp_1097 = esp_1046 - 4;
						esp_1097->ptr0000 = (ptr32) ((byte) edi_1038.u0 - 166240);
						esp_1097->dwFFFFFFFC = 777;
						esp_1097->ptrFFFFFFF8 = (ptr32) ((byte) edi_1038.u0 - 167166);
						esp_1097->ptrFFFFFFF4 = (ptr32) ((byte) edi_1038.u0 - 167126);
						word32 ecx_2716;
						__assert_fail(out ecx_2716, out edx_1108);
						esp_1046.u0 = <invalid>;
						goto l0806A74C;
					}
					else
					{
						Eq_58678 eax_1183;
						ui32 * ebx_1177 = *((byte) edi_1038.u0 + 20);
						Eq_2 eax_1178 = (word32) esi_1070 + 1;
						union Eq_2 * edi_1179 = *((byte) esp_1046.u0 + 0x0C);
						struct Eq_58690 * edx_1180 = ebx_1177 + 1;
						if (esi_1070 < ebp_1012)
						{
							while (true)
							{
								*edi_1179 = (union Eq_2 *) eax_1178;
								++edx_1180;
								edx_1180->bFFFFFFFF = (byte) *((word32) eax_1178 - 1);
								Eq_2 ecx_1194 = (word32) eax_1178 + 1;
								if (eax_1178 == ebp_1012)
									break;
								eax_1178 = ecx_1194;
							}
							eax_1183 = eax_1178 - esi_1070;
						}
						else
							eax_1183.u0 = 0x00;
						*ebx_1177 = eax_1183 | *ebx_1177 & ~0x07;
						goto l08069E60;
					}
				}
l08069E1E:
				esi_1070 = *((byte) edi_1038.u0 + 8);
				*((word32) esp_1046 + 16) = **((word32) esp_1046 + 0x0C);
				*((word32) esp_1046 + 4) = *edi_1038.u0;
				goto l08069D40;
			}
			do
			{
				word32 edi_844 = *((byte) esp_1046.u0 + 44);
				struct Eq_58384 * esp_846 = esp_1046 - 4;
				esp_846->dw0000 = edi_844 + ~0x0002895F;
				esp_846->dwFFFFFFFC = 727;
				esp_846->dwFFFFFFF8 = edi_844 + ~0x00028CFD;
				esp_846->dwFFFFFFF4 = edi_844 + ~0x00028C8C;
				word32 ecx_2709;
				__assert_fail(out ecx_2709, out edx_1488);
				esp_1046.u0 = <invalid>;
l0806A271:
				*((byte) esp_1046.u0 + 60) = edx_1488;
				struct Eq_58819 * esp_867 = esp_1046 - 0x04;
				esp_867->ptrFFFFFFFC = esp_867->ptr0034;
				esp_867->tFFFFFFF8 = &esp_867->ptr0058;
				esp_867->tFFFFFFF4 = ebp_1012;
				esp_867->tFFFFFFF0 = &esp_867->t0054;
				esp_867->dwFFFFFFEC = *esp_867->ptr0010;
				esp_867->tFFFFFFE8 = esp_867->t000C;
				esp_867->ptrFFFFFFE4 = esp_867->ptr0038;
				word32 esi_2718;
				word32 edi_2719;
				word32 ebx_2717;
				word32 eax_901 = __gconv_transliterate(gs, esp_867->ptrFFFFFFE4, esp_867->tFFFFFFE8, esp_867->tFFFFFFF0, esp_867->tFFFFFFF4, esp_867->tFFFFFFF8, esp_867->ptrFFFFFFFC, out ebx_2717, out ebp_1012, out esi_2718, out edi_2719);
				esp_867->dw0014 = eax_901;
				esp_1046 = (char *) &esp_867->ptrFFFFFFFC + 8;
				edx_1488 = esp_867->ptr0040;
				eax_706 = esp_867->t0054;
				ebx_1048 = esp_867->ptr0058;
				if (eax_901 != 0x06)
				{
					if (esp_867->dw0014 != 0x05)
						goto l0806A12A;
l0806A2C1:
					union Eq_2 * ecx_948 = *((byte) esp_1046.u0 + 0x0C);
					esi_1070 = *((byte) esp_1046.u0 + 20);
					*((byte) esp_1046.u0 + 16) = eax_706;
					edi_1038 = *((byte) esp_1046.u0 + 8);
					*ecx_948 = (union Eq_2 *) *((byte) esp_1046.u0 + 16);
					ebx_1048 = (Eq_58004 (*)[]) *((byte) esp_1046.u0 + 76);
					if (ebx_1048 == ebx_1048)
						goto l0806A2E5;
					continue;
				}
l0806A5F7:
				if (*((byte) esp_1046.u0 + 56) != 0x00)
				{
					word32 * edi_937 = *((byte) esp_1046.u0 + 48);
					*((byte) esp_1046.u0 + 16) = 0x06;
					eax_706 = (word32) eax_706 + 4;
					*((byte) esp_1046.u0 + 80) = eax_706;
					++*edi_937;
					goto l0806A12A;
				}
l0806A23E:
				**((byte) esp_1046.u0 + 0x0C) = eax_706;
			} while (ebx_1048 != *((byte) esp_1046.u0 + 76));
l0806A18D:
			edi_1038 = *((byte) esp_1046.u0 + 44);
			struct Eq_58423 * esp_976 = esp_1046 - 4;
			esp_976->ptr0000 = (ptr32) ((byte) edi_1038.u0 - 166240);
			esp_976->dwFFFFFFFC = 0x02D8;
			esp_976->ptrFFFFFFF8 = (ptr32) ((byte) edi_1038.u0 - 167166);
			esp_976->ptrFFFFFFF4 = (ptr32) ((byte) edi_1038.u0 - 166800);
			word32 edx_2711;
			word32 ecx_2710;
			eax_1049 = __assert_fail(out ecx_2710, out edx_2711);
			esp_1046.u0 = <invalid>;
l0806A1B0:
			if (*((word32) esp_1046 + 48) != 0x00)
			{
				if ((*((byte) edi_1038.u0 + 8) & 0x08) != 0x00)
				{
					struct Eq_58462 * esp_1003 = esp_1046 - 0x04;
					esp_1003->ptrFFFFFFFC = esp_1003->ptr0034;
					esp_1003->tFFFFFFF8 = &esp_1003->ptr0058;
					esp_1003->tFFFFFFF4 = ebp_1012;
					esp_1003->tFFFFFFF0 = &esp_1003->t0054;
					esp_1003->dwFFFFFFEC = *esp_1003->ptr0010;
					esp_1003->tFFFFFFE8 = edi_1038;
					esp_1003->ptrFFFFFFE4 = esp_1003->ptr0038;
					word32 ebx_2712;
					word32 esi_2713;
					word32 eax_1034 = __gconv_transliterate(gs, esp_1003->ptrFFFFFFE4, esp_1003->tFFFFFFE8, esp_1003->tFFFFFFF0, esp_1003->tFFFFFFF4, esp_1003->tFFFFFFF8, esp_1003->ptrFFFFFFFC, out ebx_2712, out ebp_1012, out esi_2713, out edi_1038);
					esp_1003->dw000C = eax_1034;
					esp_1046 = (char *) &esp_1003->ptrFFFFFFFC + 8;
					ebx_1048 = esp_1003->ptr0058;
					eax_1049 = esp_1003->t0054;
					if (eax_1034 != 0x06)
					{
						if (esp_1003->dw000C == 0x05)
							continue;
						goto l08069D61;
					}
				}
				if (*((word32) esp_1046 + 20) != 0x00)
				{
					word32 * esi_1059 = *((word32) esp_1046 + 48);
					*((word32) esp_1046 + 8) = 0x06;
					eax_1049 = (word32) eax_1049 + 4;
					*((word32) esp_1046 + 80) = eax_1049;
					++*esi_1059;
					goto l08069D61;
				}
			}
			*((byte) esp_1046.u0 + 8) = 0x06;
		}
l08069E5A:
		**((word32) esp_1046 + 24) = ebx_1048;
		goto l08069E60;
	}
	struct Eq_57914 * eax_158 = *((word32) dwArg08 + 20);
	ui32 eax_160 = eax_158->dw0000;
	if ((eax_160 & 0x07) == 0x00)
		goto l08069D40;
	if (dwArg14 != 0x00)
		goto l0806A7AB;
	if ((eax_160 & 0x07) > 0x04)
	{
l0806A788:
		word32 edi_1229 = *((word32) esp_1046 + 44);
		struct Eq_59158 * esp_1231 = esp_1046 - 4;
		esp_1231->dw0000 = edi_1229 + ~0x00028B1B;
		esp_1231->dwFFFFFFFC = 0x018B;
		esp_1231->dwFFFFFFF8 = edi_1229 + ~0x00028C9C;
		esp_1231->dwFFFFFFF4 = edi_1229 + 4294800288;
		word32 ecx_2720;
		word32 edx_2721;
		__assert_fail(out ecx_2720, out edx_2721);
		esp_1046.u0 = <invalid>;
l0806A7AB:
		edi_1038 = *((word32) esp_1046 + 44);
		struct Eq_59137 * esp_1252 = esp_1046 - 4;
		esp_1252->ptr0000 = (ptr32) ((byte) edi_1038.u0 - 166240);
		esp_1252->dwFFFFFFFC = 0x022F;
		esp_1254 = esp_1252 - 4;
l0806A69C:
		struct Eq_58267 * esp_1259 = esp_1254 - 4;
		esp_1259->ptr0000 = (ptr32) ((byte) edi_1038.u0 - 167166);
		esp_1259->ptrFFFFFFFC = (ptr32) ((byte) edi_1038.u0 - 167146);
		word32 edx_2708;
		word32 ecx_2707;
		__assert_fail(out ecx_2707, out edx_2708);
		esp_1046.u0 = <invalid>;
		goto l0806A6AF;
	}
	up32 eax_185;
	int32 eax_180 = 0x00;
	if ((eax_160 & 0x07) != 0x00)
	{
		do
		{
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[eax_180].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_59196) (&eax_158->dw0004)[eax_180];
			++eax_180;
		} while ((eax_160 & 0x07) != eax_180);
		eax_185 = 0x04 - (eax_160 & 0x07);
	}
	else
		eax_185 = 0x04;
	Eq_59222 ebx_1363 = eax_160 & 0x07;
	if (dwArg10 < (word32) eax_127 + eax_185)
	{
		*dwArg0C = (union Eq_2 *) dwArg10;
		if (eax_127 < dwArg10)
		{
			Eq_2 eax_225 = (word32) eax_127 + 1;
			struct Eq_59299 * edx_227 = eax_158 + (eax_160 & 0x07) / 8;
			while (true)
			{
				++edx_227;
				edx_227[3] = (struct Eq_59299) *((word32) eax_225 - 1);
				Eq_2 ecx_237 = (word32) eax_225 + 1;
				if (dwArg10 == eax_225)
					break;
				eax_225 = ecx_237;
			}
		}
		goto l0806A535;
	}
	else
	{
		if (eax_136 >= eax_141)
		{
l0806A402:
			*((byte) esp_1046.u0 + 8) = 0x05;
			goto l08069E60;
		}
		Eq_2 eax_248 = eax_127;
		do
		{
			eax_248 = (word32) eax_248 + 1;
			ebx_1363 = (word32) ebx_1363 + 1;
			*((word32) ebx_1363 + (fp - 0x25)) = *((word32) eax_248 - 1);
		} while (ebx_1363 <= 0x03 && dwArg10 > eax_248);
		edx_1108 = dwLoc24;
		byte dl_483 = (byte) dwLoc24;
		if (dwLoc24 <= 0x7F)
		{
			*eax_136 = dl_483;
			goto l0806A01F;
		}
		if (dwLoc24 > ~0xDFFE && dwLoc24 >= 0x00)
		{
			if ((dwLoc24 & ~0x07FF) == 0x00)
			{
				ecx_1114.u0 = 0x02;
				goto l0806A58D;
			}
			if ((dwLoc24 & 0xFFFF0000) == 0x00)
			{
l0806A74C:
				ecx_1114.u0 = 0x03;
				goto l0806A58D;
			}
			if ((dwLoc24 & 0xFFE00000) != 0x00)
			{
				ecx_1114 = (uint32) (int8) ((dwLoc24 & 0xFC000000) != 0x00) + 0x05;
l0806A58D:
				esi_1070 = *((byte) esp_1046.u0 + 4);
				byte cl_1130 = (byte) ecx_1114;
				if (Mem1118[esp_1046 + 0x00:word32] >=u esi_1070 + ecx_1114)
				{
					*esi_1070 = (byte) (~0xFF >> cl_1130);
					Mem1135[esp_1046 + 0x54:word32] = Mem1133[esp_1046 + 0x54:word32] + ecx_1114;
					do
					{
						--ecx_1114;
						Mem1146[esi_1070 + ecx_1114:byte] = SLICE(edx_1108, byte, 0) & 0x3F | 0x80;
						edx_1108 >>= 0x06;
						byte dl_1151 = (byte) edx_1108;
					} while (ecx_1114 != 0x01);
					byte * eax_1150 = *((byte) esp_1046.u0 + 4);
					*eax_1150 |= dl_1151;
l0806A01F:
					word32 eax_1158 = *((byte) esp_1046.u0 + 80);
					*((byte) esp_1046.u0 + 80) = eax_1158 + 0x04;
					eax_1159 = eax_1158 + 0x04;
					if (eax_1158 + 0x04 != *((byte) esp_1046.u0 + 56))
						goto l0806A034;
					goto l0806A436;
				}
				goto l0806A402;
			}
l0806A71F:
			ecx_1114.u0 = 0x04;
			goto l0806A58D;
		}
		if (eax_146 == null)
		{
l0806A67F:
			*((byte) esp_1046.u0 + 8) = 0x06;
			goto l08069E60;
		}
		if ((esi_1070 & 0x08) == 0x00)
		{
			esi_1070 &= 0x02;
			if ((esi_1070 & 0x02) != 0x00)
				goto l0806A665;
			goto l08069E60;
		}
		word32 ecx_294 = fp - 0x24 + ebx_1363;
		dwLoc90 = fp - 44;
		Eq_59276 ebx_331;
		word32 eax_329 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_152231 *) 44, ecx_294, fp - 0x28, eax_146, out ebx_331, out ebp_1012, out esi_1070, out edi_1038);
		esp_1046 = fp - 0x7C;
		if (eax_329 == 0x06)
		{
l0806A6AF:
			esi_1070 &= 0x02;
			if (esi_1070 == 0x00)
			{
l0806A671:
				eax_1159 = *((word32) esp_1046 + 80);
				if (eax_1159 == *((word32) esp_1046 + 56))
					goto l0806A67F;
				goto l0806A034;
			}
l0806A665:
			word32 * eax_1284 = *((word32) esp_1046 + 48);
			*((word32) esp_1046 + 80) = (word32) *((word32) esp_1046 + 80) + 4;
			++*eax_1284;
			goto l0806A671;
		}
		eax_1159 = fp - (struct Eq_152231 *) 0x24;
		if (fp - (struct Eq_152231 *) 0x24 != fp - (struct Eq_152231 *) 0x24)
		{
l0806A034:
			esi_1070 = *((byte) esp_1046.u0 + 20);
			int32 eax_1299 = eax_1159 - *((byte) esp_1046.u0 + 56);
			Eq_2 edx_1300 = *esi_1070;
			if (eax_1299 > (edx_1300 & 0x07))
			{
				union Eq_2 * esi_1324 = *((word32) esp_1046 + 0x0C);
				Eq_2 eax_1327 = (char *) *esi_1324 + (eax_1299 - (edx_1300 & 0x07));
				*esi_1324 = (union Eq_2 *) eax_1327;
				esi_1070 = *((byte) edi_1038.u0 + 8);
				*((word32) esp_1046 + 16) = eax_1327;
				*((word32) esp_1046 + 4) = *((word32) esp_1046 + 84);
				**((word32) esp_1046 + 20) = edx_1300 & ~0x07;
				goto l08069D40;
			}
			word32 edi_1305 = *((word32) esp_1046 + 44);
			struct Eq_58572 * esp_1307 = esp_1046 - 4;
			esp_1307->dw0000 = edi_1305 + ~0x00028B1B;
			esp_1307->dwFFFFFFFC = 0x01C9;
			esp_1307->dwFFFFFFF8 = edi_1305 + ~0x00028C9C;
			esp_1307->dwFFFFFFF4 = edi_1305 + ~0x00028C2F;
			word32 edx_2715;
			word32 ecx_2714;
			__assert_fail(out ecx_2714, out edx_2715);
			goto l0806A783;
		}
		if (eax_329 != 0x07)
		{
			if (eax_329 != 0x00)
				goto l08069E60;
l0806A436:
			esi_1070 = *((byte) edi_1038.u0 + 8);
			*((byte) esp_1046.u0 + 16) = **((byte) esp_1046.u0 + 0x0C);
			goto l08069D40;
		}
		if (ecx_294 != fp - 0x20)
		{
			ui32 eax_359 = eax_158->dw0000;
			*dwArg0C = (union Eq_2 *) ((char *) *dwArg0C + (ebx_331 - (eax_359 & 0x07)));
			if (ebx_331 > (eax_359 & ~0x07))
			{
				if (ebx_331 <= 0x04)
				{
					eax_158->dw0000 = ebx_331 | eax_359 & ~0x07;
					Eq_2 eax_435 = fp - (struct Eq_152231 *) 0x24;
					if (ecx_294 > fp - (struct Eq_152231 *) 0x24)
					{
						ebp_1012 = &eax_158->dw0004;
						do
						{
							++eax_435;
							++ebp_1012;
							*((word32) ebp_1012 - 1) = *((word32) eax_435 - 1);
						} while (ecx_294 != eax_435);
					}
l0806A535:
					goto l08069E60;
				}
				word32 edx_2726;
				word32 ecx_2725;
				__assert_fail(out ecx_2725, out edx_2726);
				esp_1046.u0 = <invalid>;
			}
			word32 edi_393 = *((byte) esp_1046.u0 + 44);
			Eq_59380 esp_395 = esp_1046 - 4;
			*esp_395 = edi_393 + ~0x00028B1B;
			*((word32) esp_395 - 4) = 0x01E5;
			*((word32) esp_395 - 8) = edi_393 + ~0x00028C9C;
			*((word32) esp_395 - 0x0C) = edi_393 + 4294800412;
			word32 edx_2724;
			word32 ecx_2723;
			__assert_fail(out ecx_2723, out edx_2724);
			esp_1046.u0 = <invalid>;
		}
		edi_1038 = *((byte) esp_1046.u0 + 44);
		Eq_59332 esp_416 = esp_1046 - 4;
		*esp_416 = (byte) edi_1038.u0 - 166684;
		*((word32) esp_416 - 4) = 0x01DB;
		*((word32) esp_416 - 8) = (byte) edi_1038.u0 - 167069;
		*((word32) esp_416 - 0x0C) = (byte) edi_1038.u0 - 0x00028C08;
		word32 ecx_2722;
		__assert_fail(out ecx_2722, out edx_1108);
		esp_1046.u0 = <invalid>;
		goto l0806A71F;
	}
}

// 0806A7C0: void __gconv_transform_utf8_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_59442) dwArg04, Stack Eq_56722 dwArg08, Stack (ptr32 (ptr32 Eq_59445)) dwArg0C, Stack (ptr32 Eq_59445) dwArg10, Stack Eq_56722 dwArg14, Stack word32 dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_utf8_internal(struct Eq_9 * gs, struct Eq_59442 * dwArg04, Eq_56722 dwArg08, struct Eq_59445 ** dwArg0C, struct Eq_59445 * dwArg10, Eq_56722 dwArg14, word32 dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2175 edi_33 = gs->t0014;
	Eq_2 esp_1269 = fp - 0x8C;
	Eq_2175 dwLoc20_1718 = edi_33;
	Eq_2 dwLoc60_1719 = 0x00;
	Eq_56722 edi_1001 = *((word32) dwArg08 + 8);
	if ((edi_1001 & 0x01) == 0x00)
	{
		Eq_2 esi_45 = dwArg04->t0050;
		dwLoc60_1719 = esi_45;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_1719 = __ror(esi_45, 0x09) ^ gs->t0018;
	}
	Eq_56722 edx_1307;
	Eq_56722 eax_1357;
	Eq_56722 ebp_1010;
	Eq_56722 ecx_1016;
	Eq_2 ebx_1336;
	Eq_56722 ebx_1000;
	Eq_2 eax_706;
	ptr32 esp_1280;
	word32 esi_1276;
	Eq_56722 eax_1521;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == 0x00)
		{
			struct Eq_59533 * eax_70 = *((word32) dwArg08 + 20);
			eax_70->dw0000 = 0x00;
			eax_70->dw0004 = 0x00;
			edi_1001 = dwArg08;
			if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
			{
				word32 edx_2806;
				word32 ecx_2805;
				_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1719, out ecx_2805, out edx_2806);
				word32 edx_112;
				word32 ecx_113;
				fn00000000();
				dwLocA0 = dwArg20;
			}
			goto l0806AAB8;
		}
		goto l0806B38F;
	}
	struct Eq_59445 * eax_122 = *dwArg0C;
	Eq_56722 eax_126 = dwArg14;
	if (dwArg14 == 0x00)
		eax_126 = dwArg08;
	uint32 * eax_131 = *eax_126;
	up32 eax_136 = *((word32) dwArg08 + 4);
	if (dwArg20 == 0x00)
	{
l0806A8C4:
		eax_1521 = edi_1001;
		goto l0806A8D0;
	}
	struct Eq_59533 * eax_153 = *((word32) dwArg08 + 20);
	int32 eax_155 = eax_153->dw0000;
	byte al_169 = (byte) eax_155;
	if ((eax_155 & 0x07) == 0x00)
		goto l0806A8C4;
	if (dwArg14 != 0x00)
	{
l0806B339:
		esi_1276 = (word32) *((byte) esp_1269.u0 + 0x0044);
		struct Eq_60589 * esp_833 = esp_1269 - 4;
		esp_833->dw0000 = esi_1276 + ~0x0002897F;
		esp_833->dwFFFFFFFC = 0x022F;
		esp_1280 = esp_833 - 4;
l0806B349:
		struct Eq_59629 * esp_840 = esp_1280 - 4;
		esp_840->dw0000 = esi_1276 + ~0x00028CFD;
		esp_840->dwFFFFFFFC = esi_1276 + ~0x00028CE9;
		word32 ecx_2807;
		eax_706 = __assert_fail(out ecx_2807, out edx_1307);
		esp_1269.u0 = <invalid>;
		goto l0806B35C;
	}
	Eq_2 eax_170 = (word32) al_169;
	Eq_2 edx_171 = eax_155 >> 0x08;
	uint32 ecx_173 = eax_153->dw0004;
	Eq_60612 bl_176 = (&g_t80A57FE)[eax_155 >> 0x08];
	do
	{
		--edx_171;
		if (eax_170 > edx_171)
			Mem191[fp - 0x26 + edx_171:byte] = SLICE(ecx_173, byte, 0) & 0x3F | 0x80;
		ecx_173 >>= 0x06;
		byte cl_201 = (byte) ecx_173;
	} while (edx_171 > 0x01);
	byte cl_202 = cl_201 | bl_176;
	if (eax_136 < eax_131 + 1)
	{
l0806AAB8:
		if ((dwLoc20_1718 ^ gs->t0014) == 0x00)
			return;
		goto l0806B334;
	}
	struct Eq_59445 * edx_209 = eax_122;
	Eq_60641 ebp_210 = fp - 0x26;
	do
	{
		++edx_209;
		eax_170 = (word32) eax_170 + 1;
		Mem233[fp - 0x27 + eax_170:byte] = Mem224[edx_209 + -1:byte];
	} while (((int8) (eax_170 <= 0x05) & (int8) (dwArg10 > edx_209)) != 0x00);
	uint32 ebx_1539;
	Eq_60664 esi_1535;
	uint32 esi_240 = (word32) cl_202;
	uint32 ecx_1536 = esi_240;
	if (esi_240 <= 0x7F)
	{
		*eax_131 = esi_240;
		esi_1535.u0 = 0x01;
l0806ACA4:
		dwLoc20_1718 = edi_33;
		if (esi_1535 > *((byte) esp_1269.u0 + 28))
		{
			union Eq_56722 * edi_627 = *((byte) esp_1269.u0 + 20);
			*((byte) esp_1269.u0 + 24) = (word32) *((byte) esp_1269.u0 + 24) + (esi_1535 - *((byte) esp_1269.u0 + 28));
			*edi_627 = (union Eq_56722 *) *((byte) esp_1269.u0 + 24);
			(*((byte) esp_1269.u0 + 16))->u0 = 0x00;
			Eq_56722 edi_637 = *((word32) *((byte) esp_1269.u0 + 0x0C) + 8);
			*((byte) esp_1269.u0 + 8) = *((byte) esp_1269.u0 + 40);
			eax_1521 = edi_637;
l0806A8D0:
			edx_1307 = *((word32) esp_1269 + 24);
			if (*esp_1269 != edx_1307)
			{
				edi_1001 = *((word32) esp_1269 + 8);
				ebp_1010 = (word32) edi_1001 + 4;
				if (*((word32) esp_1269 + 4) >= (word32) edi_1001 + 4)
				{
					*((word32) esp_1269 + 16) = 0x04;
					*((word32) esp_1269 + 40) = eax_1521 & 0x02;
					do
					{
						eax_1357 = (word32) *edx_1307;
						ecx_1016 = (word32) edx_1307 + 1;
						ebx_1000 = eax_1357;
						if (eax_1357 > 0x7F)
						{
							if (eax_1357 <= 223)
							{
								*((byte) esp_1269.u0 + 28) = 0x02;
								eax_1357 &= 0x1F;
							}
							else
							{
								if (((byte) eax_1357 & 0xF0) != 0xE0)
									goto l0806AEC5;
								*((byte) esp_1269.u0 + 28) = 0x03;
								eax_1357 &= 0x0F;
							}
l0806A944:
							word32 esi_698 = Mem694[esp_1269 + 0x1C:word32] + edx_1307;
							*((byte) esp_1269.u0 + 60) = esi_698;
							ebx_1336.u0 = 0x01;
							if (*esp_1269.u0 >= esi_698)
							{
								*((byte) esp_1269.u0 + 56) = ebp_1010;
								Eq_2 ebp_737 = *((byte) esp_1269.u0 + 28);
								do
								{
									word32 ecx_744 = CONVERT(Mem736[edx_1307 + ebx_1336:byte], byte, word32);
									if (((byte) ecx_744 & 0xC0) != 0x80)
										goto l0806A9C2;
									ebx_1336 = (word32) ebx_1336 + 1;
									eax_1357 = eax_1357 << 0x06 | ecx_744 & 0x3F;
								} while (ebp_737 != ebx_1336);
								ebp_1010 = *((byte) esp_1269.u0 + 56);
								if (ebx_1336 != 0x02 && eax_1357 >> ((byte) ebx_1336 - 0x04) + (byte) ebx_1336 * 0x04 == 0x00 || eax_1357 <= ~0xDFFE)
									goto l0806A9C2;
								ecx_1016 = *((byte) esp_1269.u0 + 60);
								goto l0806A900;
							}
							Eq_56722 esi_702 = *esp_1269.u0;
							if (esi_702 <= ecx_1016)
							{
								eax_706.u0 = 0x01;
l0806AD4A:
								if (*esp_1269.u0 != ecx_1016)
								{
l0806B35C:
									ebx_1336 = eax_706;
									goto l0806A9C2;
								}
								*((byte) esp_1269.u0 + 16) = 0x07;
								goto l0806A9F0;
							}
							if ((*((word32) edx_1307 + 1) & 0xC0) == 0x80)
							{
								eax_706 = esi_702 - edx_1307;
								do
								{
									ebx_1336 = (word32) ebx_1336 + 1;
									ecx_1016 = edx_1307 + ebx_1336;
									if (ebx_1336 == eax_706)
										goto l0806AD4A;
								} while ((Mem699[edx_1307 + ebx_1336:byte] & 0xC0) == 0x80);
							}
l0806A9C2:
							word32 * eax_857 = *((byte) esp_1269.u0 + 64);
							if (eax_857 == null || *((byte) esp_1269.u0 + 40) == 0x00)
							{
								*((byte) esp_1269.u0 + 16) = 0x06;
								goto l0806A9F0;
							}
							++*eax_857;
							*((byte) esp_1269.u0 + 16) = 0x06;
							edx_1307 += ebx_1336;
							if (*esp_1269.u0 == edx_1307)
								goto l0806A9F0;
						}
						else
						{
l0806A900:
							*edi_1001 = eax_1357;
							edx_1307 = ecx_1016;
							edi_1001 = ebp_1010;
							if (*esp_1269.u0 == ecx_1016)
								goto l0806A9F0;
						}
						ebp_1010 = (word32) edi_1001 + 4;
					} while (*((byte) esp_1269.u0 + 4) >= ebp_1010);
					union Eq_56722 * eax_800 = *((byte) esp_1269.u0 + 20);
					union Eq_56722 * ebx_801 = *((byte) esp_1269.u0 + 32);
					*((byte) esp_1269.u0 + 16) = 0x05;
					*eax_800 = (union Eq_56722 *) edx_1307;
					if (ebx_801 != null)
					{
l0806AAB2:
						**((byte) esp_1269.u0 + 32) = edi_1001;
						goto l0806AAB8;
					}
l0806AA02:
					struct Eq_59778 * eax_888 = *((byte) esp_1269.u0 + 0x0C);
					++eax_888->dw000C;
					if ((eax_888->b0008 & 0x01) != 0x00)
					{
						word32 * esi_894 = *((byte) esp_1269.u0 + 36);
						eax_888->t0000 = edi_1001;
						*esi_894 = (word32) *((byte) esp_1269.u0 + 92) + *esi_894;
						goto l0806AB0B;
					}
					if (*((byte) esp_1269.u0 + 8) >= edi_1001)
					{
l0806AB0B:
						if (*((byte) esp_1269.u0 + 0x00AC) != 0x00 && *((word32) esp_1269 + 16) == 0x07)
						{
							edi_1001 = **((word32) esp_1269 + 20);
							struct Eq_60009 * ebp_1395 = *((word32) *((word32) esp_1269 + 0x0C) + 20);
							uint32 edx_1398 = (word32) *edi_1001;
							uint32 esi_1399 = *esp_1269 - edi_1001;
							*((word32) esp_1269 + 4) = esi_1399;
							ebp_1395->dw0000 = esi_1399;
							if (edx_1398 <= 0xC1)
							{
								edi_1001 = *((word32) esp_1269 + 0x0044);
								struct Eq_60037 * esp_1408 = esp_1269 - 4;
								esp_1408->ptr0000 = (word32) edi_1001 - 166272;
								esp_1408->dwFFFFFFFC = 773;
								esp_1408->ptrFFFFFFF8 = (word32) edi_1001 - 167166;
								esp_1408->ptrFFFFFFF4 = (word32) edi_1001 - 0x00028C7C;
								word32 edx_2813;
								word32 ecx_2812;
								__assert_fail(out ecx_2812, out edx_2813);
l0806B334:
								word32 edx_2809;
								word32 ecx_2808;
								__stack_chk_fail(out ecx_2808, out edx_2809);
								esp_1269.u0 = <invalid>;
								goto l0806B339;
							}
							ui32 eax_1443;
							ui32 esi_1447;
							word32 ecx_1446;
							if (edx_1398 <= 223)
							{
								eax_1443 = edx_1398 & 0x1F;
								ecx_1446 = 0x01;
								esi_1447 = 0x0200;
							}
							else if (((byte) edx_1398 & 0xF0) == 0xE0)
							{
								eax_1443 = edx_1398 & 0x0F;
								ecx_1446 = 0x02;
								esi_1447 = 0x0300;
							}
							else if (((byte) edx_1398 & ~0x07) == 0xF0)
							{
								eax_1443 = edx_1398 & 0x07;
								ecx_1446 = 0x03;
								esi_1447 = 0x0400;
							}
							else if (((byte) edx_1398 & 252) == ~0x07)
							{
								eax_1443 = edx_1398 & 0x03;
								ecx_1446 = 0x04;
								esi_1447 = 0x0500;
							}
							else
							{
								eax_1443 = edx_1398 & 0x01;
								ecx_1446 = 0x05;
								esi_1447 = 0x0600;
							}
							**((word32) esp_1269 + 20) = (word32) edi_1001 + 1;
							Eq_56722 edx_1472 = (word32) edi_1001 + 1;
							if (*esp_1269 > (word32) edi_1001 + 1)
							{
								do
								{
									edx_1472 = (word32) edx_1472 + 1;
									eax_1443 = eax_1443 << 0x06 | (word32) (*edx_1472) & 0x3F;
									**((word32) esp_1269 + 20) = edx_1472;
								} while (edx_1472 != *esp_1269);
								edi_1001 -= edx_1472;
								ecx_1446 = (word32) edi_1001 + (ecx_1446 + 0x01);
							}
							ebp_1395->dw0000 = esi_1447 | *((word32) esp_1269 + 4);
							ebp_1395->dw0004 = eax_1443 << (byte) ecx_1446 * 0x06;
						}
						goto l0806AAB8;
					}
					struct Eq_59823 * esp_909 = esp_1269 - 0x0C;
					esp_909->t006C = **((byte) esp_1269.u0 + 0x0C);
					esp_909->tFFFFFFFC = esp_909->t0038;
					word32 edx_2811;
					word32 ecx_2810;
					_dl_mcount_wrapper_check(gs, esp_909->tFFFFFFF8, esp_909->tFFFFFFFC, out ecx_2810, out edx_2811);
					esp_909->tFFFFFFF8 = esp_909->t00B8;
					esp_909->dwFFFFFFF4 = 0x00;
					esp_909->dwFFFFFFF0 = esp_909->dw0030;
					esp_909->dwFFFFFFEC = 0x00;
					esp_909->tFFFFFFE8 = edi_1001;
					esp_909->ptrFFFFFFE4 = (word32 *) &esp_909->t006C;
					esp_909->dwFFFFFFE0 = esp_909->dw0040;
					esp_909->dwFFFFFFDC = esp_909->dw003C;
					Eq_56722 eax_978;
					word32 edx_979;
					Eq_56722 ecx_980;
					fn00000000();
					ebp_1010 = eax_978;
					esp_1269 = &esp_909->t000C;
					if (eax_978 == 0x04)
					{
						if (esp_909->t001C == 0x05)
							goto l0806AA79;
						goto l0806AB0B;
					}
					Eq_56722 esi_1245 = esp_909->t006C;
					if (esi_1245 == edi_1001)
					{
l0806AA71:
						if (ebp_1010 == 0x00)
						{
l0806AA79:
							struct Eq_59925 * esi_1518 = esp_909->ptr0018;
							esp_909->t0024 = *esp_909->ptr0020;
							eax_1521 = esi_1518->t0008;
							esp_909->t0014 = esi_1518->t0000;
							goto l0806A8D0;
						}
						esp_909->t001C = ebp_1010;
						goto l0806AB0B;
					}
					Eq_56722 edx_1013 = esp_909->t0024;
					*esp_909->ptr0020 = (union Eq_56722 *) edx_1013;
					Eq_56722 eax_995 = esp_909->ptr0018->t0008;
					if (esp_909->t000C != edx_1013)
					{
						ebx_1000 = esp_909->t0014;
						edi_1001 = (word32) ebx_1000 + 4;
						if (esi_1245 >= (word32) ebx_1000 + 4)
						{
							esp_909->t0028 = eax_978;
							esp_909->t0034 = eax_995 & 0x02;
							ebp_1010 = esi_1245;
							Eq_56722 esi_1011 = ebx_1000;
							do
							{
								Eq_56722 eax_1015 = (word32) *edx_1013;
								ecx_1016 = (word32) edx_1013 + 1;
								ebx_1000 = eax_1015;
								if (eax_1015 > 0x7F)
								{
									if (eax_1015 <= 223)
									{
										esp_909->t0024.u0 = 0x02;
										eax_1015 &= 0x1F;
										goto l0806ADE2;
									}
									if (((byte) eax_1015 & 0xF0) == 0xE0)
									{
										esp_909->t0024.u0 = 0x03;
										eax_1015 &= 0x0F;
										goto l0806ADE2;
									}
									if (((byte) eax_1015 & ~0x07) == 0xF0)
									{
										esp_909->t0024.u0 = 0x04;
										eax_1015 &= 0x07;
										goto l0806ADE2;
									}
									if (((byte) eax_1015 & 252) == ~0x07)
									{
										esp_909->t0024.u0 = 0x05;
										eax_1015 &= 0x03;
										goto l0806ADE2;
									}
									if (((byte) eax_1015 & ~0x01) != 252)
									{
										ebx_1000.u0 = 0x00;
										do
											ebx_1000 = (char *) ebx_1000.u0 + 1;
										while (Mem1014[esp_909 + 0x0C:word32] >u edx_1013 + ebx_1000 && ((Mem1014[edx_1013 + ebx_1000:byte] & 0xC0) == 0x80 && ebx_1000 != 0x05));
l0806AFA8:
										esp_909->t001C = ebx_1000;
l0806AE74:
										word32 * eax_1187 = esp_909->ptr004C;
										if (eax_1187 == null)
											goto l0806AE88;
										ecx_1016 = esp_909->t0034;
										if (ecx_1016 == 0x00)
											goto l0806AE88;
										edx_1013 += Mem1185[esp_909 + 0x1C:word32];
										++*eax_1187;
										goto l0806ADA6;
									}
									esp_909->t0024.u0 = 0x06;
									eax_1015 &= 0x01;
l0806ADE2:
									Eq_56722 ebx_1089 = esp_909->t0024;
									esp_909->t001C.u0 = 0x01;
									ebx_1000 = ebx_1089 + edx_1013;
									esp_909->t0044 = ebx_1000;
									if (esp_909->t000C >= ebx_1000)
									{
										esp_909->t001C = ebp_1010;
										Eq_56722 ebp_1136 = esp_909->t0024;
										esp_909->t0048 = edi_1001;
										ebx_1000.u0 = 0x01;
										do
										{
											ecx_1016 = CONVERT(Mem1140[edx_1013 + ebx_1000:byte], byte, word32);
											if (((byte) ecx_1016 & 0xC0) != 0x80)
											{
												ebp_1010 = esp_909->t001C;
												goto l0806AFA8;
											}
											ebx_1000 = (char *) ebx_1000.u0 + 1;
											eax_1015 = eax_1015 << 0x06 | ecx_1016 & 0x3F;
										} while (ebp_1136 != ebx_1000);
										ebp_1010 = esp_909->t001C;
										edi_1001 = esp_909->t0048;
										esp_909->t001C = ebx_1000;
										if (ebx_1000 != 0x02)
										{
											Eq_56722 ebx_1171 = esp_909->t001C;
											ecx_1016 = ebx_1171 - 0x04 + ebx_1171 * 0x04;
											ebx_1000 = eax_1015 >> (byte) ecx_1016;
											if (ebx_1000 != 0x00)
												goto l0806AE54;
											goto l0806AE74;
										}
l0806AE54:
										ecx_1016 = (word32) eax_1015 - 0x0000D800;
										if (eax_1015 <= ~0xDFFE)
											goto l0806AE74;
										ecx_1016 = esp_909->t0044;
										goto l0806ADA0;
									}
									Eq_56722 edi_1096 = esp_909->t000C;
									if (edi_1096 > ecx_1016)
									{
										Eq_56722 eax_1105;
										if ((*((word32) edx_1013 + 1) & 0xC0) == 0x80)
										{
											Eq_56722 edi_1106 = edi_1096 - edx_1013;
											eax_1105.u0 = 0x01;
											ebx_1000 = edi_1106;
											do
											{
												eax_1105 = (char *) eax_1105.u0 + 1;
												ecx_1016 = edx_1013 + eax_1105;
												if (eax_1105 == edi_1106)
												{
													esp_909->t001C = edi_1106;
													goto l0806B11F;
												}
												word32 ecx_1118 = CONVERT(Mem1093[edx_1013 + eax_1105:byte], byte, word32);
												ecx_1016 = ecx_1118 & ~0x3F;
											} while (((byte) ecx_1118 & 0xC0) == 0x80);
										}
										else
											eax_1105.u0 = 0x01;
										esp_909->t001C = eax_1105;
										goto l0806AE74;
									}
l0806B11F:
									if (ecx_1016 != esp_909->t000C)
										goto l0806AE74;
l0806AE88:
									esp_909->t0024 = edx_1013;
									ebx_1000 = esi_1011;
									esi_1245 = ebp_1010;
									goto l0806AE90;
								}
l0806ADA0:
								*esi_1011 = eax_1015;
								edx_1013 = ecx_1016;
								esi_1011 = edi_1001;
l0806ADA6:
								if (esp_909->t000C == edx_1013)
									goto l0806AE88;
								edi_1001 = (word32) esi_1011 + 4;
							} while (ebp_1010 >= edi_1001);
							ebp_1010 = esp_909->t0028;
							*esp_909->ptr0020 = (union Eq_56722 *) edx_1013;
							edi_1001 = esi_1011;
							if (ebp_1010 == esi_1011)
							{
								if (ebp_1010 != esp_909->t0014)
									goto l0806AA71;
l0806AFD4:
								struct Eq_59925 * eax_1374 = esp_909->ptr0018;
								--eax_1374->dw000C;
								goto l0806AA71;
							}
						}
						else
						{
							ecx_1016 = ecx_980;
							if (esi_1245 == esp_909->t0014)
								goto l0806AFD4;
						}
l0806AEA2:
						edi_1001 = esp_909->t0050;
						esp_909->ptr0008 = (word32) edi_1001 - 166272;
						esp_909->dw0004 = 727;
						esp_909->ptr0000 = (word32) edi_1001 - 167166;
						esp_909->tFFFFFFFC = (word32) edi_1001 - 0x00028C8D;
						word32 ecx_2816;
						__assert_fail(out ecx_2816, out edx_1307);
						esp_1269.u0 = <invalid>;
l0806AEC5:
						if (((byte) ebx_1000 & ~0x07) == 0xF0)
						{
							*((byte) esp_1269.u0 + 28) = 0x04;
							eax_1357 = ebx_1000 & 0x07;
							goto l0806A944;
						}
						if (((byte) ebx_1000 & 252) == ~0x07)
						{
							*((byte) esp_1269.u0 + 28) = 0x05;
							eax_1357 = ebx_1000 & 0x03;
							goto l0806A944;
						}
						if (((byte) ebx_1000 & ~0x01) == 252)
						{
							*((byte) esp_1269.u0 + 28) = 0x06;
							eax_1357 = ebx_1000 & 0x01;
							goto l0806A944;
						}
						ebx_1336.u0 = 0x00;
						do
							ebx_1336 = (byte) ebx_1336.u0 + 1;
						while (Mem1700[esp_1269 + 0x00:word32] >u edx_1307 + ebx_1336 && ((Mem1700[edx_1307 + ebx_1336:byte] & 0xC0) == 0x80 && ebx_1336 != 0x05));
						goto l0806A9C2;
					}
					ebx_1000 = esp_909->t0014;
					ecx_1016 = ecx_980;
l0806AE90:
					edi_1001 = esp_909->t0024;
					*esp_909->ptr0020 = (union Eq_56722 *) edi_1001;
					if (esi_1245 != ebx_1000)
						goto l0806AEA2;
					Eq_56722 esi_1255 = esp_909->t0050;
					esp_909->ptr0008 = (word32) esi_1255 - 166272;
					esp_909->dw0004 = 0x02D8;
					esp_909->ptr0000 = (word32) esi_1255 - 167166;
					esp_909->tFFFFFFFC = (word32) esi_1255 - 166800;
					word32 edx_2815;
					word32 ecx_2814;
					__assert_fail(out ecx_2814, out edx_2815);
					esp_1269.u0 = <invalid>;
l0806B38F:
					esi_1276 = (word32) *((word32) esp_1269 + 0x0044);
					struct Eq_59519 * esp_1278 = esp_1269 - 4;
					esp_1278->dw0000 = esi_1276 + ~0x0002897F;
					esp_1278->dwFFFFFFFC = 0x019F;
					esp_1280 = esp_1278 - 4;
					goto l0806B349;
				}
				edx_1307 = *((word32) esp_1269 + 24);
				edi_1001 = *((word32) esp_1269 + 8);
				*((word32) esp_1269 + 16) = 0x05;
			}
			else
			{
				edx_1307 = *esp_1269;
				edi_1001 = *((word32) esp_1269 + 8);
				*((word32) esp_1269 + 16) = 0x04;
			}
l0806A9F0:
			word32 ebx_878 = *((byte) esp_1269.u0 + 32);
			**((byte) esp_1269.u0 + 20) = edx_1307;
			if (ebx_878 != 0x00)
				goto l0806AAB2;
			goto l0806AA02;
		}
		edi_1001 = *((byte) esp_1269.u0 + 0x0044);
		struct Eq_60679 * esp_287 = esp_1269 - 4;
		esp_287->ptr0000 = (word32) edi_1001 - 166712;
		esp_287->dwFFFFFFFC = 0x01C9;
		esp_287->ptrFFFFFFF8 = (word32) edi_1001 - 167069;
		esp_287->ptrFFFFFFF4 = (word32) edi_1001 - 166960;
		word32 ecx_2817;
		word32 edx_2818;
		eax_170 = __assert_fail(out ecx_2817, out edx_2818);
		esp_1269.u0 = <invalid>;
	}
	else
	{
		if (esi_240 <= 223)
		{
			ebx_1539 = esi_240 & 0x1F;
			goto l0806B00D;
		}
		if (((byte) esi_240 & 0xF0) == 0xE0)
		{
			ebx_1539 = esi_240 & 0x0F;
			goto l0806B00D;
		}
	}
	if (((byte) ecx_1536 & ~0x07) == 0xF0)
	{
		*((byte) esp_1269.u0 + 72) = 0x04;
		ebx_1539 = ecx_1536 & 0x07;
	}
	else if (((byte) ecx_1536 & 252) == ~0x07)
	{
		*((byte) esp_1269.u0 + 72) = 0x05;
		ebx_1539 = ecx_1536 & 0x03;
	}
	else
	{
		if (((byte) ecx_1536 & ~0x01) != 252)
		{
			esi_1535.u0 = 0x00;
			do
				++esi_1535;
			while (Mem1538[esp_1269 + 0x3C:word32] >u ebp_210 + esi_1535 && ((Mem1538[ebp_210 + esi_1535:byte] & 0xC0) == 0x80 && esi_1535 != 0x05));
l0806B0A3:
			dwLoc20_1718 = edi_33;
			ebp_210 = *((byte) esp_1269.u0 + 64);
			if (ebp_210 == 0x00)
			{
l0806B0B4:
				*((byte) esp_1269.u0 + 16) = (union Eq_2 *) 0x06;
				goto l0806AAB8;
			}
			edi_1001 &= 0x02;
			if (edi_1001 == 0x00)
				goto l0806B0B4;
			word32 * eax_609 = *((byte) esp_1269.u0 + 64);
			++*eax_609;
			*((byte) esp_1269.u0 + 40) = *((byte) esp_1269.u0 + 8);
			goto l0806ACA4;
		}
		*((byte) esp_1269.u0 + 72) = 0x06;
		ebx_1539 = ecx_1536 & 0x01;
	}
l0806B00D:
	dwLoc20_1718 = edi_33;
	esi_1535.u0 = 0x01;
	if (Mem356[esp_1269 + 0x3C:word32] >=u ebp_210 + Mem356[esp_1269 + 0x48:word32])
	{
		Eq_60664 edx_548 = *((byte) esp_1269.u0 + 72);
		do
		{
			word32 eax_552 = CONVERT(Mem356[ebp_210 + esi_1535:byte], byte, word32);
			ecx_1536 = eax_552 & ~0x3F;
			if (((byte) eax_552 & 0xC0) != 0x80)
				goto l0806B0A3;
			++esi_1535.u0;
			ebx_1539 = ebx_1539 << 0x06 | eax_552 & 0x3F;
		} while (edx_548 != esi_1535);
		if (*((byte) esp_1269.u0 + 72) != 0x02)
		{
			Eq_60664 edx_582 = *((byte) esp_1269.u0 + 72);
			ecx_1536 = edx_582 - 0x04 + edx_582 * 0x04;
			if (ebx_1539 >> (byte) ecx_1536 != 0x00 && ebx_1539 > ~0xDFFE)
			{
				**((byte) esp_1269.u0 + 8) = ebx_1539;
				Eq_2 eax_621 = **((byte) esp_1269.u0 + 16);
				*((byte) esp_1269.u0 + 8) = eax_621;
				*((byte) esp_1269.u0 + 28) = eax_621 & 0x07;
				esi_1535 = edx_582;
				goto l0806ACA4;
			}
			goto l0806B0A3;
		}
		if (ebx_1539 <= ~0xDFFE)
			goto l0806B0A3;
		**((byte) esp_1269.u0 + 8) = ebx_1539;
		Eq_2 eax_576 = **((byte) esp_1269.u0 + 16);
		*((byte) esp_1269.u0 + 8) = eax_576;
		*((byte) esp_1269.u0 + 28) = eax_576 & 0x07;
		esi_1535.u0 = 0x02;
		goto l0806ACA4;
	}
	ui32 edx_474;
	ui32 esi_477;
	word32 ebx_478;
	ptr32 ebx_365 = (byte) esp_1269.u0 + 0x0067;
	*((byte) esp_1269.u0 + 40) = ebx_365;
	if (*((byte) esp_1269.u0 + 60) > ebx_365)
	{
		if ((*((byte) esp_1269.u0 + 0x0067) & 0xC0) == 0x80)
		{
			byte * ebx_375 = (byte) esp_1269.u0 + 0x0068;
			do
			{
				++esi_1535;
				if (*((byte) esp_1269.u0 + 60) <= ebx_2823)
				{
					if (*((byte) esp_1269.u0 + 60) != ebx_2823)
						break;
					if (*((byte) esp_1269.u0 + 60) != (byte) esp_1269.u0 + 0x006C)
						goto l0806B1F4;
					goto l0806B2CC;
				}
				ebx_375 = ebx_2823 + 1;
				ebx_2823 = ebx_375;
			} while ((*ebx_2823 & 0xC0) == 0x80);
		}
		goto l0806B0A3;
	}
	if (*((byte) esp_1269.u0 + 60) != ebx_365)
		goto l0806B0A3;
l0806B1F4:
	union Eq_2 * edi_404 = *((byte) esp_1269.u0 + 16);
	Mem405[Mem366[esp_1269 + 0x14:word32] + 0x00:word32] = eax_170 - Mem366[esp_1269 + 0x1C:word32] + Mem366[esp_1269 + 0x18:word32];
	up32 edx_406 = *((byte) esp_1269.u0 + 56);
	*edi_404 = (union Eq_2 *) eax_170;
	if (edx_406 > 0xC1)
	{
		if (*((byte) esp_1269.u0 + 76) <= 0x1D)
		{
			esi_477 = 0x0200;
			ebx_478 = 0x01;
			edx_474 = ecx_1536 & 0x1F;
			goto l0806B233;
		}
		if (((byte) ecx_1536 & 0xF0) == 0xE0)
		{
			esi_477 = 0x0300;
			ebx_478 = 0x02;
			edx_474 = ecx_1536 & 0x0F;
			goto l0806B233;
		}
	}
	else
	{
		word32 edi_411 = *((byte) esp_1269.u0 + 0x0044);
		struct Eq_61052 * esp_413 = esp_1269 - 4;
		esp_413->dw0000 = edi_411 + 4294800584;
		esp_413->dwFFFFFFFC = 0x01E1;
		esp_413->dwFFFFFFF8 = edi_411 + ~0x00028C9C;
		esp_413->dwFFFFFFF4 = edi_411 + 4294800260;
		word32 ecx_2821;
		word32 edx_2822;
		__assert_fail(out ecx_2821, out edx_2822);
		esp_1269.u0 = <invalid>;
l0806B2CC:
		word32 esi_432 = *((byte) esp_1269.u0 + 0x0044);
		struct Eq_61020 * esp_434 = esp_1269 - 4;
		esp_434->dw0000 = esi_432 + 4294800584;
		esp_434->dwFFFFFFFC = 0x01DB;
		esp_434->dwFFFFFFF8 = esi_432 + ~0x00028C9C;
		esp_434->dwFFFFFFF4 = esi_432 + ~0x00028C07;
		word32 edx_2820;
		word32 ecx_2819;
		eax_170 = __assert_fail(out ecx_2819, out edx_2820);
		esp_1269.u0 = <invalid>;
	}
	if (((byte) ecx_1536 & ~0x07) == 0xF0)
	{
		esi_477 = 0x0400;
		ebx_478 = 0x03;
		edx_474 = ecx_1536 & 0x07;
	}
	else if (((byte) ecx_1536 & 252) == ~0x07)
	{
		edx_474 = ecx_1536 & 0x03;
		esi_477 = 0x0500;
		ebx_478 = 0x04;
	}
	else
	{
		edx_474 = ecx_1536 & 0x01;
		esi_477 = 0x0600;
		ebx_478 = 0x05;
	}
l0806B233:
	edi_1001 = *((byte) esp_1269.u0 + 40);
	if (*((byte) esp_1269.u0 + 60) > edi_1001)
	{
		do
		{
			edi_1001 = (word32) edi_1001 + 1;
			edx_474 = edx_474 << 0x06 | (word32) (*edi_1001) & 0x3F;
		} while (*((byte) esp_1269.u0 + 60) != edi_1001);
		ebx_478 += *((byte) esp_1269.u0 + 40) - *((byte) esp_1269.u0 + 60);
	}
	struct Eq_61094 * esi_538 = *((byte) esp_1269.u0 + 16);
	*((byte) esp_1269.u0 + 16) = (union Eq_2 *) 0x07;
	esi_538->t0000 = eax_170 | esi_477;
	esi_538->dw0004 = edx_474 << (byte) ebx_478 * 0x06;
	goto l0806AAB8;
}

// 0806B590: void __gconv_transform_ucs2_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57052) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs2_internal(struct Eq_9 * gs, struct Eq_57052 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x6C;
	Eq_2175 esi_32 = gs->t0014;
	ui32 esi_318 = *((word32) dwArg08 + 8);
	Eq_2 dwLoc50_747 = 0x00;
	if ((esi_318 & 0x01) == 0x00)
	{
		Eq_2 ecx_43 = dwArg04->t0050;
		dwLoc50_747 = ecx_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc50_747 = __ror(ecx_43, 0x09) ^ gs->t0018;
	}
	Eq_2 edi_435;
	ptr32 esp_166;
	Eq_2 edi_162;
	Eq_2 esp_331;
	Eq_2 eax_506;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == 0x00)
		{
			struct Eq_61260 * eax_67 = *((word32) dwArg08 + 20);
			eax_67->dw0000 = 0x00;
			eax_67->t0004.u1 = 0x00;
			if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
			{
				word32 edx_1479;
				word32 ecx_1478;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc50_747, out ecx_1478, out edx_1479);
				word32 edx_112;
				fn00000000();
			}
			goto l0806B73E;
		}
		goto l0806BB16;
	}
	Eq_2 edx_118 = *dwArg0C;
	Eq_2 eax_119 = dwArg14;
	if (dwArg14 == 0x00)
		eax_119 = dwArg08;
	word32 * ecx_126 = *eax_119;
	word32 * dwLoc68_1009 = ecx_126;
	word32 * ecx_132 = *((word32) dwArg08 + 4);
	word32 * ebx_136 = null;
	if (dwArg18 != null)
		ebx_136 = fp - 44;
	if (dwArg20 != 0x00)
	{
		struct Eq_61260 * ebx_150 = *((word32) dwArg08 + 20);
		ui32 dwLoc64_1477 = ebx_150->dw0000;
		byte bLoc64_799 = (byte) dwLoc64_1477;
		uint32 dwLoc58_785 = dwLoc64_1477 & 0x07;
		if ((dwLoc64_1477 & 0x07) != 0x00)
		{
			if (dwArg14 != 0x00)
			{
				edi_162.u0 = 0x080CE000;
				esp_166 = fp - 116;
l0806BB26:
				struct Eq_61730 * esp_580 = esp_166 - 4;
				esp_580->ptr0000 = (ptr32) ((byte) edi_162.u0 - 167166);
				esp_580->ptrFFFFFFFC = (ptr32) ((byte) edi_162.u0 - 167146);
				word32 ecx_1490;
				word32 edx_1491;
				__assert_fail(out ecx_1490, out edx_1491);
				esp_18.u0 = <invalid>;
				goto l0806BB39;
			}
			Eq_61572 dwLoc4C_793 = dwLoc64_1477 & 0x07;
			if ((dwLoc64_1477 & 0x07) > 0x04)
			{
				word32 edx_1487;
				word32 ecx_1486;
				__assert_fail(out ecx_1486, out edx_1487);
l0806BB9A:
				word32 edx_1481;
				word32 ecx_1480;
				__stack_chk_fail(out ecx_1480, out edx_1481);
				__gconv_transform_internal_ucs2(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
				return;
			}
			Eq_2 ecx_193 = (word32) edx_118 + 2;
			if ((dwLoc64_1477 & 0x07) != 0x00)
			{
				Eq_61268 al_198 = ebx_150->t0004;
				if ((bLoc64_799 & 0x06) != 0x00)
				{
					dwLoc4C_793.u0 = 0x02;
					ecx_193 = edx_118;
					wLoc22 = SEQ(ebx_150->b0005, al_198);
				}
				else
				{
					ecx_193 = (word32) edx_118 + 1;
					dwLoc4C_793.u0 = 0x01;
				}
			}
			if (dwArg10 < ecx_193)
			{
				*dwArg0C = (union Eq_2 *) dwArg10;
				if (edx_118 < dwArg10)
				{
					word32 eax_225 = ebx_150 + 0x04 + dwLoc4C_793;
					do
					{
						edx_118 = (word32) edx_118 + 1;
						++eax_225;
						eax_225->bFFFFFFFF = (byte) *((word32) edx_118 - 1);
					} while (dwArg10 != edx_118);
				}
l0806B73E:
				if ((esi_32 ^ gs->t0014) == 0x00)
					return;
				goto l0806BB9A;
			}
			Eq_2 ecx_244 = edx_118;
			if (ecx_132 < ecx_126 + 1)
				goto l0806B73E;
			Eq_61572 eax_249 = dwLoc4C_793;
			do
			{
				ecx_244 = (word32) ecx_244 + 1;
				*((word32) eax_1492 + (fp - 0x22)) = *((word32) ecx_244 - 1);
				eax_249.u0 = 0x01;
				eax_1492 = eax_249;
			} while (((int8) (eax_1492 <= 0x00) & (int8) (dwArg10 > ecx_244)) != 0x00);
			word32 eax_271 = (word32) wLoc22;
			if ((word16) eax_271 > 0x2001)
			{
				*ecx_126 = eax_271;
				dwLoc64_1477 = ebx_150->dw0000;
				dwLoc58_785 = dwLoc64_1477 & 0x07;
				dwLoc68_1009 = ecx_126 + 1;
			}
			else
			{
				if (ebx_136 == null || (esi_318 & 0x02) == 0x00)
					goto l0806B73E;
				++*ebx_136;
			}
			if (((byte) dwLoc64_1477 & 0x06) != 0x00)
			{
l0806BB39:
				edi_435 = *((byte) esp_18.u0 + 48);
				struct Eq_61654 * esp_596 = esp_18 - 4;
				esp_596->ptr0000 = (word32) edi_435 - 166740;
				esp_596->dwFFFFFFFC = 0x01C9;
				esp_596->ptrFFFFFFF8 = (word32) edi_435 - 167069;
				esp_596->ptrFFFFFFF4 = (word32) edi_435 - 166960;
				word32 edx_1489;
				word32 ecx_1488;
				eax_506 = __assert_fail(out ecx_1488, out edx_1489);
				esp_331.u0 = <invalid>;
				goto l0806BB5C;
			}
			up32 edx_313 = edx_118 - dwLoc58_785;
			esi_318 = (ui32) *((word32) dwArg08 + 8);
			*dwArg0C = (union Eq_2 *) (edx_313 + 0x02);
			ebx_150->dw0000 = dwLoc64_1477 & ~0x07;
			edx_118 = edx_313 + 0x02;
		}
	}
l0806B680:
	word32 dwLoc64_1002;
	word32 * ebx_333;
	Eq_2 eax_334;
	esp_331 = fp - 0x6C;
	if (dwArg10 == edx_118)
	{
		ebx_333 = dwLoc68_1009;
		eax_334 = dwArg10;
		dwLoc64_1002 = 0x04;
		goto l0806B76C;
	}
	eax_334 = (word32) edx_118 + 2;
	ebx_333 = dwLoc68_1009;
	if (dwArg10 < eax_334)
	{
		eax_334 = edx_118;
		dwLoc64_1002 = 0x07;
		goto l0806B76C;
	}
	word32 * ecx_342 = dwLoc68_1009 + 1;
	if (ecx_132 < dwLoc68_1009 + 1)
	{
		ebx_333 = dwLoc68_1009;
		eax_334 = edx_118;
		dwLoc64_1002 = 0x05;
		goto l0806B76C;
	}
	ui32 esi_349 = esi_318 & 0x02;
	dwLoc64_1002 = 0x04;
l0806B6B6:
	word32 edx_358 = (word32) *((word32) eax_334 - 2);
	Eq_2 edi_359 = eax_334 - 0x02;
	if ((word16) edx_358 > 0x2001)
	{
		*ebx_333 = edx_358;
		ebx_333 = ecx_342;
		if (eax_334 != dwArg10)
			goto l0806B6D2;
	}
	else
	{
		if (ebx_136 == null || esi_349 == 0x00)
		{
			eax_334 = edi_359;
			dwLoc64_1002 = 0x06;
			goto l0806B76C;
		}
		++*ebx_136;
		dwLoc64_1002 = 0x06;
		if (eax_334 != dwArg10)
		{
l0806B6D2:
			Eq_2 edx_404 = (word32) eax_334 + 2;
			if (dwArg10 >= edx_404)
			{
				ecx_342 = ebx_333 + 1;
				if (ecx_132 >= ecx_342)
				{
					eax_334 = edx_404;
					goto l0806B6B6;
				}
				dwLoc64_1002 = 0x05;
			}
			else
				dwLoc64_1002 = 0x07;
l0806B76C:
			*dwArg0C = (union Eq_2 *) eax_334;
			if (dwArg14 == 0x00)
			{
l0806B77A:
				*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
				edi_435 = dwArg08;
				if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
				{
					if (ebx_333 > dwLoc68_1009)
					{
						word32 * eax_453 = *dwArg08;
						word32 edx_1485;
						word32 ecx_1484;
						_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc50_747, out ecx_1484, out edx_1485);
						word32 edx_508;
						fn00000000();
						dwLoc80 = dwArg20;
						esp_331 = fp - 0x6C;
						if (eax_506 != 0x04)
						{
							if (eax_453 != ebx_333)
							{
								Eq_61524 ebx_518 = ebx_333 - eax_453;
								Mem525[dwArg0C + 0x00:word32] = Mem494[dwArg0C + 0x00:word32] - (ebx_518 + (ebx_518 >>u 0x1F) >> 0x01);
							}
							if (eax_506 == 0x00)
							{
l0806B7E0:
								esi_318 = (ui32) *((word32) dwArg08 + 8);
								edx_118 = *dwArg0C;
								dwLoc68_1009 = (word32 *) *dwArg08;
								goto l0806B680;
							}
l0806BB5C:
							*((word32) esp_331 + 8) = eax_506;
						}
						else if (dwLoc64_1002 == 0x05)
							goto l0806B7E0;
					}
				}
				else
				{
					*dwArg08 = ebx_333;
					*dwArg18 = *dwArg18;
				}
				if (*((word32) esp_331 + 0x008C) == null || *((word32) esp_331 + 8) != 0x07)
					goto l0806B73E;
				Eq_2 esi_543 = **((word32) esp_331 + 0x0C);
				if (dwArg10 - esi_543 <= 0x03)
				{
					struct Eq_61417 * eax_622;
					struct Eq_61260 * ebx_616 = *((word32) edi_435 + 20);
					word32 eax_617 = esi_543 + 0x01;
					struct Eq_61378 * edi_618 = *((word32) esp_331 + 0x0C);
					struct Eq_61429 * edx_619 = &ebx_616->t0004;
					if (esi_543 < dwArg10)
					{
						while (true)
						{
							edi_618->t0000 = eax_617;
							++edx_619;
							edx_619->bFFFFFFFF = (byte) *((word32) eax_617 - 1);
							word32 ecx_633 = eax_617 + 0x01;
							if (eax_617 == dwArg10)
								break;
							eax_617 = ecx_633;
						}
						eax_622 = eax_617 - esi_543;
					}
					else
						eax_622 = null;
					ebx_616->dw0000 = eax_622 | ebx_616->dw0000 & ~0x07;
					goto l0806B73E;
				}
				Eq_2 edi_550 = *((word32) esp_331 + 48);
				struct Eq_61389 * esp_552 = esp_331 - 4;
				esp_552->dw0000 = (word32) edi_550 - 166304;
				esp_552->dwFFFFFFFC = 777;
				esp_552->dwFFFFFFF8 = (word32) edi_550 - 167166;
				esp_552->dwFFFFFFF4 = (word32) edi_550 - 167126;
				word32 ecx_1482;
				word32 edx_1483;
				__assert_fail(out ecx_1482, out edx_1483);
				esp_18.u0 = <invalid>;
l0806BB16:
				edi_162 = *((word32) esp_18 + 48);
				struct Eq_61246 * esp_573 = esp_18 - 4;
				esp_573->dw0000 = (word32) edi_162 - 166304;
				esp_573->dwFFFFFFFC = 0x019F;
				esp_166 = esp_573 - 4;
				goto l0806BB26;
			}
l0806B738:
			*dwArg14 = ebx_333;
			goto l0806B73E;
		}
	}
	*dwArg0C = (union Eq_2 *) eax_334;
	if (dwArg14 == 0x00)
		goto l0806B77A;
	goto l0806B738;
}

// 0806BBA0: void __gconv_transform_internal_ucs2(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57052) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      __gconv_transform_ucs2_internal
void __gconv_transform_internal_ucs2(struct Eq_9 * gs, struct Eq_57052 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - (struct Eq_61751 *) 0x8C;
	Eq_2 edi_26 = dwArg08;
	Eq_2 ebp_1019 = dwArg10;
	Eq_2175 esi_34 = gs->t0014;
	Eq_61758 esi_350 = *((word32) dwArg08 + 8);
	Eq_2 dwLoc60_1063 = 0x00;
	if ((esi_350 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc60_1063 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_1063 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_2 esp_332;
	Eq_2 esp_779;
	ptr32 esp_396;
	Eq_2 ebx_392;
	Eq_2 esp_489;
	if (dwArg1C == 0x00)
	{
		Eq_2 edx_121 = dwArg14;
		Eq_2 eax_122 = *dwArg0C;
		if (dwArg14 == 0x00)
			edx_121 = dwArg08;
		word16 * ecx_127 = *edx_121;
		word16 * edx_129 = *((word32) dwArg08 + 4);
		word16 * dwLoc78_1097 = ecx_127;
		word32 * edx_138 = null;
		if (dwArg18 != null)
			edx_138 = fp - 0x30;
		if (dwArg20 == 0x00)
		{
l0806BCA0:
			while (true)
			{
				word16 * ebx_515 = dwLoc78_1097;
				ui32 esi_517 = esi_350 & 0x02;
				Eq_2 dwLoc2C_1229 = eax_122;
				word32 dwLoc7C_1230 = 0x04;
				word16 * dwLoc28_1231 = dwLoc78_1097;
l0806BCBF:
				if (ebp_1019 != eax_122)
				{
					do
					{
						Eq_2 edx_532 = (word32) eax_122 + 4;
						if (ebp_1019 < edx_532)
						{
							dwLoc7C_1230 = 0x07;
							goto l0806BD54;
						}
						word16 * esi_540 = ebx_515 + 1;
						if (edx_129 < esi_540)
						{
							dwLoc7C_1230 = 0x05;
							goto l0806BD54;
						}
						uint32 ecx_546 = *eax_122;
						word16 cx_651 = (word16) ecx_546;
						if (ecx_546 > 0xFFFF)
						{
							if (ecx_546 >> 0x07 == 0x1C00)
							{
								dwLoc2C_1229 = edx_532;
								eax_122 = edx_532;
								goto l0806BCBF;
							}
							if (edx_138 != null)
							{
								if ((*((word32) edi_26 + 8) & 0x08) != 0x00)
								{
									word32 esi_1897;
									word32 ebx_1896;
									word32 edi_1898;
									word32 eax_586 = __gconv_transliterate(gs, dwArg04, edi_26, fp - 44, ebp_1019, fp - 0x28, edx_138, out ebx_1896, out ebp_1019, out esi_1897, out edi_1898);
									dwLocA0 = fp - 44;
									dwLoc7C_1230 = eax_586;
									ebx_515 = dwLoc28_1231;
									eax_122 = dwLoc2C_1229;
									if (eax_586 != 0x06)
									{
										if (eax_586 == 0x05)
											break;
										goto l0806BCBF;
									}
								}
								if (esi_517 != 0x00)
								{
									++*edx_138;
									eax_122 = (word32) eax_122 + 4;
									dwLoc7C_1230 = 0x06;
									dwLoc2C_1229 = eax_122;
									goto l0806BCBF;
								}
							}
							goto l0806BE31;
						}
						if (ecx_546 <= ~0xDFFE)
						{
							if (edx_138 != null && esi_517 != 0x00)
							{
								++*edx_138;
								dwLoc2C_1229 = edx_532;
								eax_122 = edx_532;
								dwLoc7C_1230 = 0x06;
								goto l0806BCBF;
							}
l0806BE31:
							dwLoc7C_1230 = 0x06;
l0806BD54:
							*dwArg0C = (union Eq_2 *) eax_122;
							if (dwArg14 == 0x00)
								goto l0806BD62;
							goto l0806BD20;
						}
						*ebx_515 = cx_651;
						eax_122 = edx_532;
						ebx_515 = esi_540;
						dwLoc28_1231 = esi_540;
						dwLoc2C_1229 = edx_532;
					} while (ebp_1019 != edx_532);
				}
				*dwArg0C = (union Eq_2 *) eax_122;
				if (dwArg14 != 0x00)
					break;
l0806BD62:
				*((word32) edi_26 + 0x0C) = (word32) *((word32) edi_26 + 0x0C) + 1;
				if ((*((word32) edi_26 + 8) & 0x01) != 0x00)
				{
					*edi_26 = ebx_515;
					*dwArg18 = *dwArg18;
					goto l0806C00C;
				}
				word32 eax_693;
				if (ebx_515 > dwLoc78_1097)
				{
					word16 * eax_694 = *edi_26;
					word32 ecx_1894;
					word32 edx_1895;
					_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1063, out ecx_1894, out edx_1895);
					fn00000000();
					dwLocA0 = dwArg20;
					if (eax_693 != 0x04)
					{
						if (ebx_515 != eax_694)
							*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_515 - eax_694) * 0x02);
						goto l0806BDC7;
					}
					eax_693 = dwLoc7C_1230;
					if (dwLoc7C_1230 != 0x05 && dwLoc7C_1230 != 0x00)
						goto l0806BE85;
					goto l0806BDCF;
				}
				eax_693 = dwLoc7C_1230;
l0806BDC7:
				if (eax_693 != 0x00)
				{
l0806BE85:
					dwLoc7C_1230 = eax_693;
l0806C00C:
					esp_779 = fp - (struct Eq_61751 *) 0x8C;
					if (dwLoc7C_1230 != 0x07 || dwArg20 == 0x00)
						goto l0806BD26;
					Eq_2 esi_788 = *dwArg0C;
					if (ebp_1019 - esi_788 > 0x03)
						goto l0806C396;
					struct Eq_62119 * eax_805;
					ui32 * ebx_799 = *((word32) edi_26 + 20);
					word32 eax_800 = esi_788 + 0x01;
					struct Eq_62127 * edx_802 = ebx_799 + 1;
					if (esi_788 < ebp_1019)
					{
						while (true)
						{
							*dwArg0C = (union Eq_2 *) eax_800;
							++edx_802;
							edx_802->bFFFFFFFF = (byte) *((word32) eax_800 - 1);
							word32 ecx_816 = eax_800 + 0x01;
							if (eax_800 == ebp_1019)
								break;
							eax_800 = ecx_816;
						}
						eax_805 = eax_800 - esi_788;
					}
					else
						eax_805 = null;
					*ebx_799 = eax_805 | *ebx_799 & ~0x07;
					goto l0806BD26;
				}
l0806BDCF:
				esi_350 = *((word32) edi_26 + 8);
				eax_122 = *dwArg0C;
				dwLoc78_1097 = (word16 *) *edi_26;
			}
l0806BD20:
			*dwArg14 = ebx_515;
l0806BD26:
			if ((esi_34 ^ gs->t0014) == 0x00)
				return;
l0806C422:
			word32 ecx_1892;
			word32 edx_1893;
			__stack_chk_fail(out ecx_1892, out edx_1893);
			esp_489.u0 = <invalid>;
l0806C427:
			Eq_2 esi_883 = *((byte) esp_489.u0 + 64);
			struct Eq_62282 * esp_885 = esp_489 - 4;
			esp_885->dw0000 = (word32) esi_883 - 166768;
			esp_885->dwFFFFFFFC = 0x01C9;
			esp_885->dwFFFFFFF8 = (word32) esi_883 - 167069;
			esp_885->dwFFFFFFF4 = (word32) esi_883 - 166960;
			word32 edx_1904;
			word32 ecx_1903;
			__assert_fail(out ecx_1903, out edx_1904);
			esp_18.u0 = <invalid>;
l0806C44A:
			ebx_392 = *((word32) esp_18 + 64);
			struct Eq_62164 * esp_906 = esp_18 - 4;
			esp_906->dw0000 = (word32) ebx_392 - 166336;
			esp_906->dwFFFFFFFC = 0x022F;
			esp_396 = esp_906 - 4;
l0806C383:
			struct Eq_61935 * esp_913 = esp_396 - 4;
			esp_913->dw0000 = (word32) ebx_392 - 167166;
			esp_913->dwFFFFFFFC = (word32) ebx_392 - 167146;
			word32 edx_1891;
			word32 ecx_1890;
			__assert_fail(out ecx_1890, out edx_1891);
			esp_779.u0 = <invalid>;
l0806C396:
			Eq_2 esi_927 = *((byte) esp_779.u0 + 64);
			struct Eq_62091 * esp_929 = esp_779 - 4;
			esp_929->dw0000 = (word32) esi_927 - 166336;
			esp_929->dwFFFFFFFC = 777;
			esp_929->dwFFFFFFF8 = (word32) esi_927 - 167166;
			esp_929->dwFFFFFFF4 = (word32) esi_927 - 167126;
			word32 ecx_1899;
			word32 edx_1900;
			__assert_fail(out ecx_1899, out edx_1900);
			esp_332.u0 = <invalid>;
			goto l0806C3B9;
		}
		struct Eq_61833 * edx_150 = *((word32) dwArg08 + 20);
		ui32 ecx_151 = edx_150->dw0000;
		ui32 dwLoc48_1102 = ecx_151;
		struct Eq_61875 * dwLoc7C_1103 = ecx_151 & 0x07;
		if ((ecx_151 & 0x07) == 0x00)
			goto l0806BCA0;
		if (dwArg14 != 0x00)
			goto l0806C44A;
		word16 * dwLoc28_1106 = ecx_127;
		if ((ecx_151 & 0x07) > 0x04)
			goto l0806C3FF;
		up32 edx_178;
		int32 edx_173 = 0x00;
		if ((ecx_151 & 0x07) != 0x00)
		{
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[edx_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_62224) (&edx_150->dw0004)[edx_173];
				++edx_173;
			} while ((ecx_151 & 0x07) != edx_173);
			edx_178 = 0x04 - (ecx_151 & 0x07);
		}
		else
			edx_178 = 0x04;
		if (dwArg10 < (word32) eax_122 + edx_178)
		{
			*dwArg0C = (union Eq_2 *) dwArg10;
			if (eax_122 < dwArg10)
			{
				Eq_2 eax_221 = (word32) eax_122 + 1;
				struct Eq_62537 * esi_222 = edx_150 + (ecx_151 & 0x07) / 8;
				while (true)
				{
					++esi_222;
					esi_222[3] = (struct Eq_62537) *((word32) eax_221 - 1);
					Eq_2 edx_232 = (word32) eax_221 + 1;
					if (dwArg10 == eax_221)
						break;
					eax_221 = edx_232;
				}
			}
			goto l0806C263;
		}
		Eq_2 edx_238 = eax_122;
		if (edx_129 < ecx_127 + 1)
			goto l0806BD26;
		struct Eq_62244 * ebx_247 = ecx_151 & 0x07;
		do
		{
			edx_238 = (word32) edx_238 + 1;
			ebx_247 = (struct Eq_62244 *) ((char *) &ebx_247->dw0000 + 1);
			Mem257[fp - 0x25 + ebx_247:byte] = Mem253[edx_238 + -1:byte];
		} while (ebx_247 <= (struct Eq_62244 *) 0x03 && dwArg10 > edx_238);
		struct Eq_61875 * eax_447;
		word16 dx_481 = (word16) dwLoc24;
		if (dwLoc24 <= 0xFFFF)
		{
			if (dwLoc24 > ~0xDFFE)
			{
				*ecx_127 = dx_481;
				dwLoc28_1106 = ecx_127 + 1;
l0806BF9F:
				eax_447 = (struct Eq_61875 *) 0x04;
				goto l0806BFAC;
			}
			if (edx_138 != null && (esi_350 & 0x02) != 0x00)
			{
				++*edx_138;
				ui32 eax_471 = edx_150->dw0000;
				dwLoc48_1102 = eax_471;
				dwLoc7C_1103 = eax_471 & 0x07;
				eax_447 = (struct Eq_61875 *) 0x04;
				goto l0806BFAC;
			}
l0806C2DD:
			goto l0806BD26;
		}
		if (dwLoc24 >> 0x07 == 0x1C00)
			goto l0806BF9F;
		if (edx_138 == null)
			goto l0806C2DD;
		struct Eq_61875 * eax_335;
		if ((esi_350 & 0x08) == 0x00)
		{
			if ((esi_350 & 0x02) == 0x00)
				goto l0806BD26;
			goto l0806C2A6;
		}
		word32 ebx_289 = ebx_247 + (fp - 0x24);
		dwLocA0 = fp - (struct Eq_62357 *) 44;
		ui32 esi_326;
		word32 ebx_1905;
		word32 eax_320 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_62357 *) 44, ebx_289, fp - (struct Eq_62364 *) 0x28, edx_138, out ebx_1905, out ebp_1019, out esi_326, out edi_26);
		esp_332 = fp - (struct Eq_62371 *) 0x8C;
		Eq_2 ecx_334 = fp - (struct Eq_62354 *) 0x24;
		eax_335 = fp - (struct Eq_62354 *) 0x24;
		if (eax_320 == 0x06)
		{
			if ((esi_326 & 0x02) == 0x00)
			{
l0806C2B4:
				if (eax_335 == fp - (struct Eq_62354 *) 0x24)
					goto l0806C2DD;
l0806C2B8:
				ui32 ebx_448 = edx_150->dw0000;
				eax_447 = eax_335 - (fp - (struct Eq_62354 *) 0x24);
				dwLoc48_1102 = ebx_448;
				dwLoc7C_1103 = ebx_448 & 0x07;
l0806BFAC:
				esp_489 = fp - (struct Eq_61751 *) 0x8C;
				if (dwLoc7C_1103 >= eax_447)
					goto l0806C427;
				eax_122 = (char *) *dwArg0C + (eax_447 - dwLoc7C_1103);
				*dwArg0C = (union Eq_2 *) eax_122;
				edx_150->dw0000 = dwLoc48_1102 & ~0x07;
				dwLoc78_1097 = dwLoc28_1106;
				esi_350 = *((word32) edi_26 + 8);
				goto l0806BCA0;
			}
l0806C2A6:
			++*edx_138;
			eax_335 = fp - (struct Eq_62390 *) 0x20;
			goto l0806C2B4;
		}
		if (fp - (struct Eq_62354 *) 0x24 != fp - (struct Eq_62354 *) 0x24)
			goto l0806C2B8;
		if (eax_320 != 0x07)
		{
			if (eax_320 != 0x00)
				goto l0806BD26;
			esi_350 = *((word32) edi_26 + 8);
			eax_122 = *dwArg0C;
			goto l0806BCA0;
		}
		if (ebx_289 == fp - (struct Eq_62413 *) 0x20)
			goto l0806C3DC;
		ui32 eax_357 = edx_150->dw0000;
		Mem366[dwArg0C + 0x00:word32] = Mem331[dwArg0C + 0x00:word32] + (ebx_247 - (eax_357 & 0x07));
		if (ebx_247 <= (eax_357 & ~0x07))
		{
l0806C3B9:
			Eq_2 esi_948 = *((byte) esp_332.u0 + 64);
			struct Eq_62469 * esp_950 = esp_332 - (struct Eq_62470 *) 4;
			esp_950->dw0000 = (word32) esi_948 - 166768;
			esp_950->tFFFFFFFC.u0 = 0x01E5;
			esp_950->tFFFFFFF8 = (word32) esi_948 - 167069;
			esp_950->tFFFFFFF4 = (word32) esi_948 - 166884;
			word32 ecx_1908;
			word32 edx_1909;
			__assert_fail(out ecx_1908, out edx_1909);
			esp_332.u0 = <invalid>;
l0806C3DC:
			Eq_2 ebx_969 = *((byte) esp_332.u0 + 64);
			struct Eq_62420 * esp_971 = esp_332 - (struct Eq_62421 *) 4;
			esp_971->dw0000 = (word32) ebx_969 - 166768;
			esp_971->tFFFFFFFC.u0 = 0x01DB;
			esp_971->tFFFFFFF8 = (word32) ebx_969 - 167069;
			esp_971->tFFFFFFF4 = (word32) ebx_969 - 0x00028C08;
			word32 ecx_1906;
			word32 edx_1907;
			__assert_fail(out ecx_1906, out edx_1907);
			esp_18.u0 = <invalid>;
l0806C3FF:
			Eq_2 esi_990 = *((word32) esp_18 + 64);
			struct Eq_62186 * esp_992 = esp_18 - 4;
			esp_992->dw0000 = (word32) esi_990 - 166768;
			esp_992->dwFFFFFFFC = 0x018B;
			esp_992->dwFFFFFFF8 = (word32) esi_990 - 167069;
			esp_992->dwFFFFFFF4 = (word32) esi_990 - 167008;
			word32 edx_1902;
			word32 ecx_1901;
			__assert_fail(out ecx_1901, out edx_1902);
			goto l0806C422;
		}
		if (ebx_247 <= (struct Eq_62244 *) 0x04)
		{
			edx_150->dw0000 = ebx_247 | eax_357 & ~0x07;
			if (ebx_289 > fp - (struct Eq_62354 *) 0x24)
			{
				struct Eq_62512 * ebp_406 = &edx_150->dw0004;
				do
				{
					++ecx_334;
					++ebp_406;
					ebp_406->bFFFFFFFF = (byte) *((word32) ecx_334 - 1);
				} while (ebx_289 != ecx_334);
			}
l0806C263:
			goto l0806BD26;
		}
		word32 edx_1911;
		word32 ecx_1910;
		__assert_fail(out ecx_1910, out edx_1911);
		esp_18.u0 = <invalid>;
	}
	else if (dwArg14 == 0x00)
	{
		struct Eq_61833 * eax_68 = *((word32) dwArg08 + 20);
		eax_68->dw0000 = 0x00;
		eax_68->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_1888;
			word32 edx_1889;
			_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1063, out ecx_1888, out edx_1889);
			fn00000000();
		}
		goto l0806BD26;
	}
	ebx_392 = *((word32) esp_18 + 64);
	struct Eq_61819 * esp_394 = esp_18 - 4;
	esp_394->dw0000 = (word32) ebx_392 - 166336;
	esp_394->dwFFFFFFFC = 0x019F;
	esp_396 = esp_394 - 4;
	goto l0806C383;
}

// 0806C460: void __gconv_transform_ucs2reverse_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_62555) dwArg04, Stack (ptr32 Eq_62556) dwArg08, Stack (ptr32 Eq_62558) dwArg0C, Stack Eq_62558 dwArg10, Stack (ptr32 Eq_62556) dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs2reverse_internal(struct Eq_9 * gs, struct Eq_62555 * dwArg04, struct Eq_62556 * dwArg08, union Eq_62558 * dwArg0C, Eq_62558 dwArg10, struct Eq_62556 * dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x6C;
	Eq_2175 esi_32 = gs->t0014;
	ui32 esi_322 = dwArg08->dw0008;
	Eq_2 dwLoc60_759 = 0x00;
	if ((esi_322 & 0x01) == 0x00)
	{
		Eq_2 ecx_43 = dwArg04->t0050;
		dwLoc60_759 = ecx_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_759 = __ror(ecx_43, 0x09) ^ gs->t0018;
	}
	ptr32 esp_587;
	word32 edi_583;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == null)
		{
			struct Eq_62646 * eax_67 = dwArg08->ptr0014;
			eax_67->dw0000 = 0x00;
			eax_67->t0004.u1 = 0x00;
			if ((dwArg08->dw0008 & 0x01) == 0x00)
			{
				word32 edx_1288;
				word32 ecx_1287;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc60_759, out ecx_1287, out edx_1288);
				word32 edx_111;
				fn00000000();
			}
			goto l0806C691;
		}
		goto l0806C9C5;
	}
	struct Eq_62556 * edx_120 = dwArg14;
	Eq_62558 eax_122 = *dwArg0C;
	if (dwArg14 == null)
		edx_120 = dwArg08;
	word32 * ebx_127 = edx_120->ptr0000;
	word32 * dwLoc68_1002 = ebx_127;
	word32 * ebx_133 = dwArg08->ptr0004;
	word32 * ebx_138 = null;
	if (dwArg18 != null)
		ebx_138 = fp - 44;
	struct Eq_62556 * edi_167;
	Eq_2 esi_334;
	Eq_2 esp_181;
	Eq_2 eax_179;
	if (dwArg20 != 0x00)
	{
		struct Eq_62646 * ebx_151 = dwArg08->ptr0014;
		ui32 dwLoc58_1286 = ebx_151->dw0000;
		byte bLoc58_807 = (byte) dwLoc58_1286;
		uint32 dwLoc50_795 = dwLoc58_1286 & 0x07;
		if ((dwLoc58_1286 & 0x07) != 0x00)
		{
			if (dwArg14 != null)
				goto l0806CA10;
			Eq_62982 dwLoc3C_798 = dwLoc58_1286 & 0x07;
			if ((dwLoc58_1286 & 0x07) > 0x04)
			{
				edi_167 = (struct Eq_62556 *) &g_t80CE000;
				word32 ecx_1297;
				word32 edx_1298;
				eax_179 = __assert_fail(out ecx_1297, out edx_1298);
				esp_181.u0 = <invalid>;
				goto l0806CA45;
			}
			Eq_62558 ecx_188 = (word32) eax_122 + 2;
			if ((dwLoc58_1286 & 0x07) != 0x00)
			{
				Eq_62654 dl_193 = ebx_151->t0004;
				if ((bLoc58_807 & 0x06) != 0x00)
				{
					dwLoc3C_798.u0 = 0x02;
					ecx_188 = eax_122;
					wLoc22 = SEQ(ebx_151->b0005, dl_193);
				}
				else
				{
					ecx_188 = (word32) eax_122 + 1;
					dwLoc3C_798.u0 = 0x01;
				}
			}
			if (dwArg10 < ecx_188)
			{
				*dwArg0C = (union Eq_62558 *) dwArg10;
				if (eax_122 < dwArg10)
				{
					word32 edx_220 = ebx_151 + 0x04 + dwLoc3C_798;
					do
					{
						eax_122 = (word32) eax_122 + 1;
						++edx_220;
						edx_220->bFFFFFFFF = (byte) *((word32) eax_122 - 1);
					} while (dwArg10 != eax_122);
				}
l0806C691:
				if ((esi_32 ^ gs->t0014) == 0x00)
					return;
l0806CA0B:
				word32 ecx_1291;
				word32 edx_1292;
				__stack_chk_fail(out ecx_1291, out edx_1292);
				esp_18.u0 = <invalid>;
l0806CA10:
				edi_583 = (word32) *((byte) esp_18.u0 + 44);
				struct Eq_62968 * esp_670 = esp_18 - 4;
				esp_670->dw0000 = edi_583 + ~0x000289FF;
				esp_670->dwFFFFFFFC = 0x022F;
				esp_587 = esp_670 - 4;
l0806C9D5:
				struct Eq_62749 * esp_677 = esp_587 - 4;
				esp_677->dw0000 = edi_583 + ~0x00028CFD;
				esp_677->dwFFFFFFFC = edi_583 + ~0x00028CE9;
				word32 edx_1290;
				word32 ecx_1289;
				__assert_fail(out ecx_1289, out edx_1290);
				esp_18.u0 = <invalid>;
				goto l0806C9E8;
			}
			Eq_62558 ecx_237 = eax_122;
			if (ebx_133 < ebx_127 + 1)
				goto l0806C691;
			Eq_62982 edx_242 = dwLoc3C_798;
			do
			{
				ecx_237 = (word32) ecx_237 + 1;
				*((word32) edx_1301 + (fp - 0x22)) = *((word32) ecx_237 - 1);
				edx_242.u0 = 0x01;
				edx_1301 = edx_242;
			} while (((int8) (edx_1301 <= 0x00) & (int8) (dwArg10 > ecx_237)) != 0x00);
			cup16 dx_269 = __rol(wLoc22, 0x08);
			if (dx_269 > 0x2001)
			{
				*ebx_127 = (word32) dx_269;
				dwLoc58_1286 = ebx_151->dw0000;
				dwLoc50_795 = dwLoc58_1286 & 0x07;
				dwLoc68_1002 = ebx_127 + 1;
			}
			else
			{
				if (ebx_138 == null || (esi_322 & 0x02) == 0x00)
					goto l0806C691;
				++*ebx_138;
			}
			if (((byte) dwLoc58_1286 & 0x06) != 0x00)
			{
l0806C9E8:
				word32 edi_691 = *((byte) esp_18.u0 + 44);
				struct Eq_63068 * esp_693 = esp_18 - 4;
				esp_693->dw0000 = edi_691 + ~0x00028A3F;
				esp_693->dwFFFFFFFC = 0x01C9;
				esp_693->dwFFFFFFF8 = edi_691 + ~0x00028C9C;
				esp_693->dwFFFFFFF4 = edi_691 + ~0x00028C2F;
				word32 edx_1300;
				word32 ecx_1299;
				__assert_fail(out ecx_1299, out edx_1300);
				goto l0806CA0B;
			}
			up32 eax_313 = eax_122 - dwLoc50_795;
			*dwArg0C = (union Eq_62558 *) (eax_313 + 0x02);
			esi_322 = dwArg08->dw0008;
			ebx_151->dw0000 = dwLoc58_1286 & ~0x07;
			eax_122 = eax_313 + 0x02;
		}
	}
l0806C550:
	word32 * ebx_332;
	Eq_62558 edx_333;
	esp_181 = fp - 0x6C;
	if (dwArg10 == eax_122)
	{
		ebx_332 = dwLoc68_1002;
		edx_333 = dwArg10;
		esi_334.u0 = 0x04;
		goto l0806C5DF;
	}
	edx_333 = (word32) eax_122 + 2;
	ebx_332 = dwLoc68_1002;
	if (dwArg10 < edx_333)
	{
		edx_333 = eax_122;
		esi_334.u0 = 0x07;
		goto l0806C5DF;
	}
	word32 * ecx_341 = dwLoc68_1002 + 1;
	if (ebx_133 < dwLoc68_1002 + 1)
	{
		ebx_332 = dwLoc68_1002;
		edx_333 = eax_122;
		esi_334.u0 = 0x05;
		goto l0806C5DF;
	}
	ui32 esi_348 = esi_322 & 0x02;
l0806C57E:
	Eq_62558 edi_357 = edx_333 - 0x02;
	cup16 ax_360 = __rol(*((word32) edx_333 - 2), 0x08);
	if (ax_360 > 0x2001)
	{
		*ebx_332 = (word32) ax_360;
		ebx_332 = ecx_341;
		if (edx_333 != dwArg10)
			goto l0806C5A5;
	}
	else
	{
		if (ebx_138 == null || esi_348 == 0x00)
		{
			edx_333 = edi_357;
			esi_334.u0 = 0x06;
			goto l0806C5DF;
		}
		++*ebx_138;
		if (edx_333 != dwArg10)
		{
l0806C5A5:
			Eq_62558 eax_400 = (word32) edx_333 + 2;
			if (dwArg10 < eax_400)
			{
				*dwArg0C = (union Eq_62558 *) edx_333;
				esi_334.u0 = 0x07;
				if (dwArg14 == null)
					goto l0806C5F1;
				goto l0806C68B;
			}
			ecx_341 = ebx_332 + 1;
			if (ebx_133 >= ecx_341)
			{
				edx_333 = eax_400;
				goto l0806C57E;
			}
			esi_334.u0 = 0x05;
l0806C5DF:
			*dwArg0C = (union Eq_62558 *) edx_333;
			if (dwArg14 == null)
			{
l0806C5F1:
				++dwArg08->dw000C;
				edi_167 = dwArg08;
				if ((dwArg08->dw0008 & 0x01) != 0x00)
				{
					dwArg08->ptr0000 = ebx_332;
					*dwArg18 = *dwArg18;
					goto l0806C6C5;
				}
				if (ebx_332 <= dwLoc68_1002)
				{
l0806C6C5:
					if (*((word32) esp_181 + 0x008C) == null || esi_334 != 0x07)
						goto l0806C691;
					Eq_62558 ecx_553 = **((word32) esp_181 + 8);
					*esp_181 = ecx_553;
					if (dwArg10 - ecx_553 <= 0x03)
					{
						struct Eq_62918 * eax_598;
						struct Eq_62646 * ebx_592 = edi_167->ptr0014;
						word32 eax_593 = ecx_553 + 0x01;
						union Eq_62558 * edi_594 = *((word32) esp_181 + 8);
						union Eq_62930 * edx_595 = &ebx_592->t0004;
						if (ecx_553 < dwArg10)
						{
							while (true)
							{
								*edi_594 = (union Eq_62558 *) eax_593;
								edx_595 = (union Eq_62930 *) ((char *) edx_595 + 1);
								*((char *) edx_595 - 1) = (union Eq_62930 *) *((word32) eax_593 - 1);
								word32 ecx_609 = eax_593 + 0x01;
								if (dwArg10 == eax_593)
									break;
								eax_593 = ecx_609;
							}
							eax_598 = dwArg10 - *esp_181;
						}
						else
							eax_598 = null;
						ebx_592->dw0000 = eax_598 | ebx_592->dw0000 & ~0x07;
						goto l0806C691;
					}
					word32 edi_562 = *((word32) esp_181 + 44);
					struct Eq_62890 * esp_564 = esp_181 - 4;
					esp_564->dw0000 = edi_562 + ~0x000289FF;
					esp_564->dwFFFFFFFC = 777;
					esp_564->dwFFFFFFF8 = edi_562 + ~0x00028CFD;
					esp_564->dwFFFFFFF4 = edi_562 + ~0x00028CD5;
					word32 edx_1296;
					word32 ecx_1295;
					__assert_fail(out ecx_1295, out edx_1296);
					esp_18.u0 = <invalid>;
l0806C9C5:
					edi_583 = (word32) *((word32) esp_18 + 44);
					struct Eq_62632 * esp_585 = esp_18 - 4;
					esp_585->dw0000 = edi_583 + ~0x000289FF;
					esp_585->dwFFFFFFFC = 0x019F;
					esp_587 = esp_585 - 4;
					goto l0806C9D5;
				}
				word32 * eax_456 = dwArg08->ptr0000;
				word32 ecx_1293;
				word32 edx_1294;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc60_759, out ecx_1293, out edx_1294);
				word32 edx_514;
				fn00000000();
				dwLoc80 = dwArg20;
				esp_181 = fp - 0x6C;
				if (eax_179 == 0x04)
				{
					if (esi_334 == 0x05)
						goto l0806C65A;
					goto l0806C6C5;
				}
				if (ebx_332 != eax_456)
				{
					Eq_62832 ebx_524 = ebx_332 - eax_456;
					Mem531[dwArg0C + 0x00:word32] = Mem497[dwArg0C + 0x00:word32] - (ebx_524 + (ebx_524 >>u 0x1F) >> 0x01);
				}
				if (eax_179 == 0x00)
				{
l0806C65A:
					esi_322 = dwArg08->dw0008;
					eax_122 = *dwArg0C;
					dwLoc68_1002 = dwArg08->ptr0000;
					goto l0806C550;
				}
l0806CA45:
				esi_334 = eax_179;
				goto l0806C6C5;
			}
l0806C68B:
			dwArg14->ptr0000 = ebx_332;
			goto l0806C691;
		}
	}
	esi_334.u0 = 0x04;
	goto l0806C5DF;
}

// 0806CA50: void __gconv_transform_internal_ucs2reverse(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57052) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack (ptr32 word32) dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ucs2reverse(struct Eq_9 * gs, struct Eq_57052 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, word32 * dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_1001 = fp - (struct Eq_63155 *) 0x8C;
	Eq_2 edi_26 = dwArg08;
	Eq_2 ebp_1054 = dwArg10;
	Eq_2175 esi_33 = gs->t0014;
	Eq_63162 esi_346 = *((word32) dwArg08 + 8);
	Eq_2 dwLoc60_1095 = 0x00;
	if ((esi_346 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc60_1095 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_1095 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_2 esp_501;
	Eq_2 esp_328;
	Eq_2 esp_402;
	if (dwArg1C == null)
	{
		Eq_2 edx_121 = dwArg14;
		Eq_2 eax_122 = *dwArg0C;
		if (dwArg14 == 0x00)
			edx_121 = dwArg08;
		word16 * ecx_127 = *edx_121;
		word16 * dwLoc7C_1128 = ecx_127;
		word16 * ecx_133 = *((word32) dwArg08 + 4);
		word32 * edx_136 = null;
		if (dwArg18 != 0x00)
			edx_136 = fp - 0x30;
		if (dwArg20 == 0x00)
		{
l0806CB50:
			while (true)
			{
				ui32 esi_529 = esi_346 & 0x02;
				Eq_2 dwLoc2C_1259 = eax_122;
				word32 dwLoc78_1260 = 0x04;
				word16 * dwLoc28_1261 = dwLoc7C_1128;
				word16 * ebx_536 = dwLoc7C_1128;
l0806CB71:
				if (ebp_1054 != eax_122)
				{
					do
					{
						Eq_2 ecx_545 = (word32) eax_122 + 4;
						if (ebp_1054 < ecx_545)
						{
							dwLoc78_1260 = 0x07;
							goto l0806CC14;
						}
						word16 * esi_553 = ebx_536 + 1;
						if (ecx_133 < esi_553)
						{
							dwLoc78_1260 = 0x05;
							goto l0806CC14;
						}
						uint32 edx_559 = *eax_122;
						word16 dx_662 = (word16) edx_559;
						if (edx_559 > 0xFFFF)
						{
							if (edx_559 >> 0x07 == 0x1C00)
							{
								dwLoc2C_1259 = ecx_545;
								eax_122 = ecx_545;
								goto l0806CB71;
							}
							if (edx_136 != null)
							{
								if ((*((word32) edi_26 + 8) & 0x08) != 0x00)
								{
									word32 ebx_2052;
									word32 esi_2053;
									word32 edi_2054;
									word32 eax_599 = __gconv_transliterate(gs, dwArg04, edi_26, fp - 44, ebp_1054, fp - 0x28, edx_136, out ebx_2052, out ebp_1054, out esi_2053, out edi_2054);
									dwLocA0 = fp - 44;
									dwLoc78_1260 = eax_599;
									ebx_536 = dwLoc28_1261;
									eax_122 = dwLoc2C_1259;
									if (eax_599 != 0x06)
									{
										if (eax_599 == 0x05)
											break;
										goto l0806CB71;
									}
								}
								if (esi_529 != 0x00)
								{
									++*edx_136;
									eax_122 = (word32) eax_122 + 4;
									dwLoc78_1260 = 0x06;
									dwLoc2C_1259 = eax_122;
									goto l0806CB71;
								}
							}
							goto l0806CCF1;
						}
						if (edx_559 <= ~0xDFFE)
						{
							if (edx_136 != null && esi_529 != 0x00)
							{
								++*edx_136;
								dwLoc2C_1259 = ecx_545;
								eax_122 = ecx_545;
								goto l0806CB71;
							}
l0806CCF1:
							dwLoc78_1260 = 0x06;
l0806CC14:
							*dwArg0C = (union Eq_2 *) eax_122;
							if (dwArg14 == 0x00)
								goto l0806CC22;
							goto l0806CBE0;
						}
						*ebx_536 = __rol(dx_662, 0x08);
						eax_122 = ecx_545;
						ebx_536 = esi_553;
						dwLoc28_1261 = esi_553;
						dwLoc2C_1259 = ecx_545;
					} while (ebp_1054 != ecx_545);
				}
				*dwArg0C = (union Eq_2 *) eax_122;
				if (dwArg14 != 0x00)
					break;
l0806CC22:
				*((word32) edi_26 + 0x0C) = (word32) *((word32) edi_26 + 0x0C) + 1;
				if ((*((word32) edi_26 + 8) & 0x01) != 0x00)
				{
					*edi_26 = ebx_536;
					*dwArg18 = *dwArg18;
					goto l0806CEC4;
				}
				word32 eax_707;
				if (ebx_536 > dwLoc7C_1128)
				{
					word16 * eax_708 = *edi_26;
					word32 ecx_2048;
					word32 edx_2049;
					_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1095, out ecx_2048, out edx_2049);
					word32 edx_765;
					fn00000000();
					dwLocA0 = dwArg20;
					if (eax_707 != 0x04)
					{
						if (ebx_536 != eax_708)
							*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_536 - eax_708) * 0x02);
						goto l0806CC87;
					}
					eax_707 = dwLoc78_1260;
					if (dwLoc78_1260 != 0x05 && dwLoc78_1260 != 0x00)
						goto l0806CD45;
					goto l0806CC8F;
				}
				eax_707 = dwLoc78_1260;
l0806CC87:
				if (eax_707 != 0x00)
				{
l0806CD45:
					dwLoc78_1260 = eax_707;
l0806CEC4:
					esp_402 = fp - (struct Eq_63155 *) 0x8C;
					if (dwLoc78_1260 != 0x07 || dwArg20 == 0x00)
						goto l0806CBE6;
					Eq_2 esi_802 = *dwArg0C;
					if (ebp_1054 - esi_802 > 0x03)
						goto l0806D24E;
					struct Eq_63487 * eax_903;
					ui32 * ebx_897 = *((word32) edi_26 + 20);
					word32 eax_898 = esi_802 + 0x01;
					struct Eq_63495 * edx_900 = ebx_897 + 1;
					if (esi_802 < ebp_1054)
					{
						while (true)
						{
							*dwArg0C = (union Eq_2 *) eax_898;
							++edx_900;
							edx_900->bFFFFFFFF = (byte) *((word32) eax_898 - 1);
							word32 ecx_914 = eax_898 + 0x01;
							if (eax_898 == ebp_1054)
								break;
							eax_898 = ecx_914;
						}
						eax_903 = eax_898 - esi_802;
					}
					else
						eax_903 = null;
					*ebx_897 = eax_903 | *ebx_897 & ~0x07;
					goto l0806CBE6;
				}
l0806CC8F:
				esi_346 = *((word32) edi_26 + 8);
				eax_122 = *dwArg0C;
				dwLoc7C_1128 = (word16 *) *edi_26;
			}
l0806CBE0:
			*dwArg14 = ebx_536;
l0806CBE6:
			if ((esi_33 ^ gs->t0014) == 0x00)
				return;
			goto l0806D2DA;
		}
		struct Eq_63250 * ecx_150 = *((word32) dwArg08 + 20);
		ui32 ecx_152 = ecx_150->dw0000;
		ui32 dwLoc68_1134 = ecx_152;
		struct Eq_63293 * dwLoc78_1135 = ecx_152 & 0x07;
		if ((ecx_152 & 0x07) == 0x00)
			goto l0806CB50;
		if (dwArg14 != 0x00)
			goto l0806D302;
		word16 * dwLoc28_1138 = ecx_127;
		if ((ecx_152 & 0x07) > 0x04)
		{
l0806D2B7:
			Eq_2 ebx_875 = *((word32) esp_1001 + 64);
			struct Eq_63613 * esp_877 = esp_1001 - 4;
			esp_877->dw0000 = (word32) ebx_875 - 166592;
			esp_877->dwFFFFFFFC = 0x018B;
			esp_877->dwFFFFFFF8 = (word32) ebx_875 - 167069;
			esp_877->dwFFFFFFF4 = (word32) ebx_875 - 167008;
			word32 edx_2058;
			word32 ecx_2057;
			__assert_fail(out ecx_2057, out edx_2058);
l0806D2DA:
			word32 edx_2047;
			word32 ecx_2046;
			__stack_chk_fail(out ecx_2046, out edx_2047);
			esp_501.u0 = <invalid>;
			goto l0806D2DF;
		}
		up32 edx_178;
		int32 edx_173 = 0x00;
		if ((ecx_152 & 0x07) != 0x00)
		{
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[edx_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_63651) (&ecx_150->dw0004)[edx_173];
				++edx_173;
			} while ((ecx_152 & 0x07) != edx_173);
			edx_178 = 0x04 - (ecx_152 & 0x07);
		}
		else
			edx_178 = 0x04;
		if (dwArg10 < (word32) eax_122 + edx_178)
		{
			*dwArg0C = (union Eq_2 *) dwArg10;
			if (eax_122 < dwArg10)
			{
				Eq_2 eax_216 = (word32) eax_122 + 1;
				struct Eq_63967 * esi_217 = ecx_150 + (ecx_152 & 0x07) / 8;
				while (true)
				{
					++esi_217;
					esi_217[3] = (struct Eq_63967) *((word32) eax_216 - 1);
					Eq_2 edx_227 = (word32) eax_216 + 1;
					if (dwArg10 == eax_216)
						break;
					eax_216 = edx_227;
				}
			}
			goto l0806D11B;
		}
		Eq_2 edx_233 = eax_122;
		if (ecx_133 < ecx_127 + 1)
			goto l0806CBE6;
		struct Eq_63671 * ebx_242 = ecx_152 & 0x07;
		do
		{
			edx_233 = (word32) edx_233 + 1;
			ebx_242 = (struct Eq_63671 *) ((char *) &ebx_242->dw0000 + 1);
			Mem252[fp - 0x25 + ebx_242:byte] = Mem248[edx_233 + -1:byte];
		} while (ebx_242 <= (struct Eq_63671 *) 0x03 && dwArg10 > edx_233);
		struct Eq_63293 * eax_456;
		word16 dx_490 = (word16) dwLoc24;
		if (dwLoc24 <= 0xFFFF)
		{
			if (dwLoc24 > ~0xDFFE)
			{
				*ecx_127 = __rol(dx_490, 0x08);
				dwLoc28_1138 = ecx_127 + 1;
l0806CE53:
				eax_456 = (struct Eq_63293 *) 0x04;
				goto l0806CE60;
			}
			if (edx_136 != null && (esi_346 & 0x02) != 0x00)
			{
				++*edx_136;
				ui32 eax_480 = ecx_150->dw0000;
				dwLoc68_1134 = eax_480;
				dwLoc78_1135 = eax_480 & 0x07;
				eax_456 = (struct Eq_63293 *) 0x04;
				goto l0806CE60;
			}
l0806D195:
			goto l0806CBE6;
		}
		if (dwLoc24 >> 0x07 == 0x1C00)
			goto l0806CE53;
		if (edx_136 == null)
			goto l0806D195;
		struct Eq_63293 * eax_331;
		if ((esi_346 & 0x08) == 0x00)
		{
			if ((esi_346 & 0x02) == 0x00)
				goto l0806CBE6;
			goto l0806D15E;
		}
		word32 ebx_285 = ebx_242 + (fp - 0x24);
		dwLocA0 = fp - (struct Eq_63787 *) 44;
		ui32 esi_322;
		word32 ebx_2061;
		word32 eax_316 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_63787 *) 44, ebx_285, fp - (struct Eq_63794 *) 0x28, edx_136, out ebx_2061, out ebp_1054, out esi_322, out edi_26);
		esp_328 = fp - (struct Eq_63801 *) 0x8C;
		Eq_2 ecx_330 = fp - (struct Eq_63784 *) 0x24;
		eax_331 = fp - (struct Eq_63784 *) 0x24;
		if (eax_316 == 0x06)
		{
			if ((esi_322 & 0x02) == 0x00)
			{
l0806D16C:
				if (eax_331 == fp - (struct Eq_63784 *) 0x24)
					goto l0806D195;
l0806D170:
				ui32 esi_457 = ecx_150->dw0000;
				eax_456 = eax_331 - (fp - (struct Eq_63784 *) 0x24);
				dwLoc68_1134 = esi_457;
				dwLoc78_1135 = esi_457 & 0x07;
l0806CE60:
				esp_501 = fp - (struct Eq_63155 *) 0x8C;
				if (dwLoc78_1135 >= eax_456)
				{
l0806D2DF:
					Eq_2 ebx_982 = *((byte) esp_501.u0 + 64);
					struct Eq_63712 * esp_984 = esp_501 - 4;
					esp_984->dw0000 = (word32) ebx_982 - 166592;
					esp_984->dwFFFFFFFC = 0x01C9;
					esp_984->dwFFFFFFF8 = (word32) ebx_982 - 167069;
					esp_984->dwFFFFFFF4 = (word32) ebx_982 - 166960;
					word32 ecx_2059;
					word32 edx_2060;
					__assert_fail(out ecx_2059, out edx_2060);
					esp_1001.u0 = <invalid>;
l0806D302:
					Eq_2 esi_1003 = *((word32) esp_1001 + 64);
					struct Eq_63577 * esp_1005 = esp_1001 - 4;
					esp_1005->dw0000 = (word32) esi_1003 - 0x00028A80;
					esp_1005->dwFFFFFFFC = 0x022F;
					esp_1005->dwFFFFFFF8 = (word32) esi_1003 - 167166;
					esp_1005->dwFFFFFFF4 = (word32) esi_1003 - 167146;
					word32 ecx_2055;
					word32 edx_2056;
					__assert_fail(out ecx_2055, out edx_2056);
					word32 edi_2045;
					word32 ebx_2042;
					word32 ebp_2043;
					word32 esi_2044;
					__gconv_transliterate(gs, dwArg04, dwArg08, dwArg10, dwArg14, dwArg18, dwArg1C, out ebx_2042, out ebp_2043, out esi_2044, out edi_2045);
					return;
				}
				eax_122 = (char *) *dwArg0C + (eax_456 - dwLoc78_1135);
				*dwArg0C = (union Eq_2 *) eax_122;
				ecx_150->dw0000 = dwLoc68_1134 & ~0x07;
				dwLoc7C_1128 = dwLoc28_1138;
				esi_346 = *((word32) edi_26 + 8);
				goto l0806CB50;
			}
l0806D15E:
			++*edx_136;
			eax_331 = fp - (struct Eq_63820 *) 0x20;
			goto l0806D16C;
		}
		if (fp - (struct Eq_63784 *) 0x24 != fp - (struct Eq_63784 *) 0x24)
			goto l0806D170;
		if (eax_316 != 0x07)
		{
			if (eax_316 != 0x00)
				goto l0806CBE6;
			esi_346 = *((word32) edi_26 + 8);
			eax_122 = *dwArg0C;
			goto l0806CB50;
		}
		if (ebx_285 == fp - (struct Eq_63843 *) 0x20)
		{
l0806D294:
			Eq_2 esi_854 = *((byte) esp_328.u0 + 64);
			struct Eq_63850 * esp_856 = esp_328 - (struct Eq_63851 *) 4;
			esp_856->dw0000 = (word32) esi_854 - 166592;
			esp_856->tFFFFFFFC.u0 = 0x01DB;
			esp_856->tFFFFFFF8 = (word32) esi_854 - 167069;
			esp_856->tFFFFFFF4 = (word32) esi_854 - 0x00028C08;
			word32 ecx_2062;
			word32 edx_2063;
			__assert_fail(out ecx_2062, out edx_2063);
			esp_1001.u0 = <invalid>;
			goto l0806D2B7;
		}
		ui32 eax_353 = ecx_150->dw0000;
		Mem362[dwArg0C + 0x00:word32] = Mem327[dwArg0C + 0x00:word32] + (ebx_242 - (eax_353 & 0x07));
		if (ebx_242 <= (eax_353 & ~0x07))
		{
l0806D271:
			Eq_2 ebx_833 = *((byte) esp_328.u0 + 64);
			struct Eq_63899 * esp_835 = esp_328 - (struct Eq_63900 *) 4;
			esp_835->dw0000 = (word32) ebx_833 - 166592;
			esp_835->tFFFFFFFC.u0 = 0x01E5;
			esp_835->tFFFFFFF8 = (word32) ebx_833 - 167069;
			esp_835->tFFFFFFF4 = (word32) ebx_833 - 166884;
			word32 edx_2065;
			word32 ecx_2064;
			__assert_fail(out ecx_2064, out edx_2065);
			esp_328.u0 = <invalid>;
			goto l0806D294;
		}
		if (ebx_242 <= (struct Eq_63671 *) 0x04)
		{
			ecx_150->dw0000 = ebx_242 | eax_353 & ~0x07;
			if (ebx_285 > fp - (struct Eq_63784 *) 0x24)
			{
				struct Eq_63942 * ebp_415 = &ecx_150->dw0004;
				do
				{
					++ecx_330;
					++ebp_415;
					ebp_415->bFFFFFFFF = (byte) *((word32) ecx_330 - 1);
				} while (ebx_285 != ecx_330);
			}
l0806D11B:
			goto l0806CBE6;
		}
		word32 edx_2067;
		word32 ecx_2066;
		__assert_fail(out ecx_2066, out edx_2067);
		esp_1001.u0 = <invalid>;
	}
	else if (dwArg14 == 0x00)
	{
		struct Eq_63250 * eax_68 = *((word32) dwArg08 + 20);
		eax_68->dw0000 = 0x00;
		eax_68->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 edx_2041;
			word32 ecx_2040;
			_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1095, out ecx_2040, out edx_2041);
			word32 edx_112;
			fn00000000();
		}
		goto l0806CBE6;
	}
	Eq_2 ebx_388 = *((word32) esp_1001 + 64);
	struct Eq_63222 * esp_390 = esp_1001 - 4;
	esp_390->dw0000 = (word32) ebx_388 - 0x00028A80;
	esp_390->dwFFFFFFFC = 0x019F;
	esp_390->dwFFFFFFF8 = (word32) ebx_388 - 167166;
	esp_390->dwFFFFFFF4 = (word32) ebx_388 - 167146;
	word32 ecx_2038;
	word32 edx_2039;
	__assert_fail(out ecx_2038, out edx_2039);
	esp_402.u0 = <invalid>;
l0806D24E:
	Eq_2 ebx_812 = *((byte) esp_402.u0 + 64);
	struct Eq_63459 * esp_814 = esp_402 - 4;
	esp_814->dw0000 = (word32) ebx_812 - 0x00028A80;
	esp_814->dwFFFFFFFC = 777;
	esp_814->dwFFFFFFF8 = (word32) ebx_812 - 167166;
	esp_814->dwFFFFFFF4 = (word32) ebx_812 - 167126;
	word32 edx_2051;
	word32 ecx_2050;
	__assert_fail(out ecx_2050, out edx_2051);
	esp_328.u0 = <invalid>;
	goto l0806D271;
}

// 0806D330: Register Eq_2 __gconv_transliterate(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57052) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack (ptr32 word32) dwArg1C, Register out (ptr32 Eq_57285) ebxOut, Register out (ptr32 Eq_57285) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_internal_ucs2
//      __gconv_transform_internal_ucs2reverse
Eq_2 __gconv_transliterate(struct Eq_9 * gs, struct Eq_57052 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, word32 * dwArg1C, struct Eq_57285 & ebxOut, struct Eq_57285 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 ecx_36 = dwArg04->t0014;
	Eq_2 edx_131 = 0x080CE000;
	Eq_2175 edi_32 = gs->t0014;
	Eq_2 edi_1037 = *dwArg10;
	Eq_2 dwLoc50_555 = ecx_36;
	if (dwArg04->dw0000 != 0x00)
		dwLoc50_555 = __ror(ecx_36, 0x09) ^ gs->t0018;
	struct Eq_57285 * ebp_1016;
	Eq_2 dwLoc24_593;
	struct Eq_57285 * ebx_1028;
	Eq_2 eax_1013;
	struct Eq_64008 * ecx_320;
	Eq_2 esi_1043 = gs->ptrFFFFFFD0->t0000;
	uint32 eax_55 = *((word32) esi_1043 + 0x0118);
	uint32 dwLoc7C_558 = eax_55;
	if (eax_55 != 0x00)
	{
		ebp_1016 = ebp;
		if (dwArg14 >= (word32) edi_1037 + 4)
		{
			ui32 eax_99[] = *((word32) esi_1043 + 0x011C);
			uint32 dwLoc80_562 = 0x00;
			struct Eq_57285 * eax_102 = *((word32) esi_1043 + 288);
			struct Eq_57285 * eax_104[] = *((word32) esi_1043 + 292);
			struct Eq_57285 * eax_106 = *((word32) esi_1043 + 296);
			Eq_2 ecx_113 = (dwArg14 - 0x01 - edi_1037 >> 0x02) + 0x01;
			ebp_1016 = ebp;
l0806D438:
			uint32 eax_124 = dwLoc80_562 + dwLoc7C_558;
			ui32 eax_128 = eax_99[eax_124 >> 0x01];
			edx_131 = eax_102 + eax_128 * 0x04;
			esi_1043.u0 = 0x00;
			ebx_1028 = eax_102;
			Eq_2 eax_132 = *edx_131;
			do
			{
				Eq_2 esi_275;
				Eq_2 eax_278;
				if (*((word32) edi_1037 + esi_1043 * 0x04) != eax_132)
				{
					if (esi_1043 == 0x00)
					{
						eax_278 = edi_1037;
						esi_275.u0 = 0x00;
					}
					else
					{
						if (eax_132 != 0x00)
							break;
l0806D528:
						ebx_1028 = (&eax_104[eax_124 >> 0x01].a0000)[0];
						ebp_1016 = eax_106;
						edi_1037 = dwLoc50_555;
						word32 eax_170 = eax_106[ebx_1028 * 0x04];
						do
						{
							word32 * esi_180;
							int32 edx_173 = ebx_1028 * 0x04;
							word32 * ecx_175 = eax_106 + edx_173;
							if (eax_170 != 0x00)
							{
								++ebx_1028;
								word32 * eax_183 = eax_106 + 4 + edx_173;
								while (true)
								{
									esi_180 = eax_183;
									++eax_183;
									struct Eq_57285 * edx_188 = ebx_1028 + 1;
									if (*eax_183 == 0x00)
										break;
									ebx_1028 = edx_188;
								}
							}
							else
								esi_180 = ecx_175;
							dwLoc24_593 = *dwArg18;
							word32 edx_1068;
							word32 ecx_1067;
							_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc50_555, out ecx_1067, out edx_1068);
							dwLoc50_555();
							dwLocA0.u0 = 0x00;
							if (eax_1013 != 0x06)
							{
								if (eax_1013 == 0x04)
								{
									*dwArg10 = (word32) *dwArg10 + esi_1043 * 0x04;
									++*dwArg1C;
									eax_1013.u0 = 0x00;
									goto l0806D66E;
								}
								else
								{
									if (eax_1013 != 0x05)
										goto l0806D66E;
									goto l0806D4ED;
								}
							}
							++ebx_1028;
							eax_170 = (word32) eax_106[ebx_1028 * 0x04];
						} while (eax_170 != 0x00);
						esi_275 = esi_1043;
						eax_278 = edi_1037 + esi_1043 * 0x04;
					}
					if (dwArg14 > eax_278 && eax_102[((byte) esi_275.u0 + eax_128) *32 0x04] >= *eax_278)
						dwLoc7C_558 = eax_124 >> 0x01;
					else
						dwLoc80_562 = (eax_124 >> 0x01) + 0x01;
					if (dwLoc80_562 < dwLoc7C_558)
						goto l0806D438;
					esi_1043 = gs->ptrFFFFFFD0->t0000;
					ebp_1016 = (struct Eq_57285 *) *((byte) esi_1043.u0 + 308);
					if (ebp_1016 == null)
						goto l0806D648;
					edi_1037 = *dwArg10;
					ecx_320 = (struct Eq_64008 *) *((byte) esi_1043.u0 + 312);
					edx_131 = *edi_1037;
					goto l0806D609;
				}
				esi_1043 = (word32) esi_1043 + 1;
				eax_132 = *((word32) edx_131 + esi_1043 * 0x04);
				if (eax_132 == 0x00)
					goto l0806D528;
			} while (esi_1043 != ecx_113);
			goto l0806D4E8;
		}
		goto l0806D4DA;
	}
	ebp_1016 = (struct Eq_57285 *) *((word32) esi_1043 + 308);
	if (ebp_1016 != null)
	{
		if (dwArg14 < (word32) edi_1037 + 4)
		{
l0806D4DA:
			eax_1013.u0 = 0x04;
			ebx_1028 = ebx;
			if (edi_1037 == dwArg14)
				goto l0806D4ED;
			ebx_1028 = ebx;
l0806D4E8:
			eax_1013.u0 = 0x07;
			goto l0806D4ED;
		}
		ecx_320 = (struct Eq_64008 *) *((word32) esi_1043 + 312);
		edx_131 = *edi_1037;
l0806D609:
		if (ebp_1016 > null)
		{
			Eq_2 eax_329 = ecx_320->dw0000;
			if (eax_329 <= edx_131)
			{
				ebx_1028 = null;
				edi_1037 = edx_131;
				do
				{
					if (ecx_320->dw0004 >= edx_131)
					{
						edx_131 = (uint32) ((uint64) (edx_131 - eax_329) % ecx_320->dw0008);
						if (edx_131 == 0x00)
						{
							Mem363[dwArg10 + 0x00:word32] = edi_1037 + 0x04;
							++*dwArg1C;
							edi_1037 = dwArg10;
							eax_1013.u0 = 0x00;
							goto l0806D4ED;
						}
					}
					++ebx_1028;
					++ecx_320;
					if (ebx_1028 == ebp_1016)
						break;
					eax_329 = ecx_320->dw0000;
				} while (eax_329 <= edx_131);
			}
		}
l0806D648:
		ebx_1028 = (struct Eq_57285 *) *((word32) esi_1043 + 300);
		if (ebx_1028 == null)
		{
l0806D652:
			eax_1013.u0 = 0x06;
			goto l0806D4ED;
		}
		esi_1043 = *((word32) esi_1043 + 304);
	}
	else
	{
		ebx_1028 = (struct Eq_57285 *) *((word32) esi_1043 + 300);
		if (ebx_1028 == null)
			goto l0806D652;
		esi_1043 = *((byte) esi_1043.u0 + 304);
		if (dwArg14 <u edi_1037 + 0x04)
		{
			uint32 eax_80 = (uint32) (int8) (edi_1037 != dwArg14);
			eax_1013 = eax_80 + 0x04 + eax_80 * 0x02;
l0806D4ED:
			if ((edi_32 ^ gs->t0014) != 0x00)
			{
				word32 edx_1065;
				word32 ecx_1064;
				Eq_2 eax_494 = __stack_chk_fail(out ecx_1064, out edx_1065);
				word32 ecx_1066;
				Eq_2 eax_511 = find_module_idx(eax_494, edx_131, out ecx_1066);
				ebxOut = ebx_1028;
				ebpOut = ebp_1016;
				esiOut = esi_1043;
				ediOut = edi_1037;
				return eax_511;
			}
			else
			{
				ebxOut = ebx;
				ebpOut = ebp;
				esiOut = esi;
				ediOut = edi;
				return eax_1013;
			}
		}
	}
	dwLoc24_593 = *dwArg18;
	word32 edx_1070;
	word32 ecx_1069;
	_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc50_555, out ecx_1069, out edx_1070);
	dwLoc50_555();
	edi_1037 = dwLoc50_555;
	if (eax_1013 != 0x06)
	{
		if (eax_1013 == 0x04)
		{
			++*dwArg1C;
			*dwArg10 = (word32) *dwArg10 + 4;
			eax_1013.u0 = 0x00;
		}
l0806D66E:
		*dwArg18 = dwLoc24_593;
		edx_131 = dwLoc24_593;
		edi_1037 = dwArg18;
	}
	goto l0806D4ED;
}

// 0806D760: Register Eq_2 find_module_idx(Register Eq_2 eax, Register Eq_2 edx, Register out Eq_2 ecxOut)
// Called from:
//      __gconv_transliterate
//      __gconv_compare_alias_cache
//      __gconv_lookup_cache
Eq_2 find_module_idx(Eq_2 eax, Eq_2 edx, union Eq_2 & ecxOut)
{
	Eq_2 ebx_22 = gconv_cache;
	up32 ecx_25 = (word32) *((word32) ebx_22 + 4);
	word32 ecx_27 = (word32) *((word32) ebx_22 + 6);
	word32 eax_31 = __hash_string(eax);
	Eq_2 ecx_38 = (word32) *((word32) ebx_22 + 8);
	uint32 edx_53 = (uint32) ((uint64) eax_31 % (ecx_38 - 0x02));
	Eq_2 ebx_117 = (uint32) ((uint64) eax_31 % ecx_38);
	up32 edi_57 = cache_size - (word32) (*((word32) ebx_22 + 4));
	int32 eax_60 = (edx_53 + 0x01) * 0x04;
	ecx_197 = ecx_38;
	while (true)
	{
		Eq_2 ecx_197;
		struct Eq_64396 * esi_122 = (word32) ebx_22 + (ecx_27 + ebx_117 * 0x04);
		do
		{
			up32 eax_74 = (word32) esi_122->w0000;
			if ((word16) eax_74 == 0x00)
			{
				ecxOut = ecx_197;
				return ~0x00;
			}
			if (eax_74 < edi_57)
			{
				word32 edx_220;
				Eq_2 eax_92 = strcmp(eax, (word32) ebx_22 + (eax_74 + ecx_25), out ecx_197, out edx_220);
				if (eax_92 == 0x00)
				{
					*edx = (word32) esi_122->w0002;
					ecxOut = edx;
					return eax_92;
				}
			}
			ebx_117 = (word32) ebx_117 + (edx_53 + 0x01);
			esi_122 += eax_60 / 4;
		} while (ecx_38 > ebx_117);
		ebx_117 -= ecx_38;
	}
}

// 0806D860: Register Eq_2 find_module(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_64436 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __gconv_lookup_cache
Eq_2 find_module(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_64436 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2175 eax_28 = gs->t0014;
	word32 ecx_302;
	word32 edx_303;
	Eq_2 eax_35 = strlen(eax, out ecx_302, out edx_303);
	word32 ecx_304;
	word32 edx_305;
	Eq_2 eax_49 = strlen(edx, out ecx_304, out edx_305);
	ui32 eax_58 = (word32) eax_35 + ((word32) eax_49 + 16);
	Eq_2 esp_56 = fp - 0x3C;
	Eq_2 edi_62 = fp - 0x3C - (eax_58 & ~0x0FFF);
	if (fp - 0x3C != edi_62)
	{
		do
		{
			esp_56 -= 0x1000;
			*((word32) esp_56 + 0x0FFC) = *((word32) esp_56 + 0x0FFC);
		} while (esp_56 != edi_62);
	}
	int32 edx_84 = eax_58 & ~0x0F & 0x0FFF;
	if (edx_84 != 0x00)
	{
		esp_56 -= edx_84;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_56 - 0x04)[edx_84 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_56 - 0x04)[edx_84 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_64495 * esp_96 = esp_56 - 0x04;
	esp_96->tFFFFFFFC = eax_35;
	esp_96->tFFFFFFF8 = eax;
	esp_96->tFFFFFFF4 = esp_56;
	word32 edx_306;
	Eq_2 eax_117 = __mempcpy(esp_96->tFFFFFFF4, esp_96->tFFFFFFF8, esp_96->tFFFFFFFC, out edx_306);
	esp_96->tFFFFFFFC = (word32) eax_49 + 1;
	esp_96->tFFFFFFF8 = edx;
	esp_96->tFFFFFFF4 = eax_117;
	word32 ecx_307;
	word32 edx_308;
	memcpy(esp_96->tFFFFFFF4, esp_96->tFFFFFFF8, esp_96->tFFFFFFFC, out ecx_307, out edx_308);
	esp_96->tFFFFFFF4 = esp_56;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_64436 ecx_154;
	Eq_2 eax_155 = __gconv_find_shlib(gs, stackArg4, out ecx_154);
	*ecx = eax_155;
	Eq_2 edx_159 = eax_155;
	Eq_2 eax_161 = 0x01;
	if (eax_155 != 0x00)
	{
		word32 eax_165 = *((word32) eax_155 + 0x0C);
		Eq_2 ebx_166 = *((word32) eax_155 + 16);
		*((word32) ecx + 4) = 0x00;
		*((word32) ecx + 20) = eax_165;
		Eq_2 eax_169 = *((word32) eax_155 + 20);
		*((word32) ecx + 28) = ebx_166;
		*((word32) ecx + 32) = eax_169;
		((word32) ecx + 24)->u0 = 0x00;
		((word32) ecx + 56)->u0 = 0x00;
		eax_161.u0 = 0x00;
		Eq_2 ebx_177 = __ror(ebx_166, 0x09) ^ gs->t0018;
		if (ebx_177 != 0x00)
		{
			esp_96->tFFFFFFF4 = ebx_177;
			word32 ecx_186;
			word32 edx_187;
			word32 eax_185 = _dl_mcount_wrapper_check(gs, esp_96->tFFFFFFF0, esp_96->tFFFFFFF4, out ecx_186, out edx_187);
			esp_96->tFFFFFFF4 = ecx;
			ebx_177();
			edx_159 = __rol(*((word32) ecx + 24) ^ gs->t0018, 0x09);
			*((word32) ecx + 24) = edx_159;
		}
	}
	if ((eax_28 ^ gs->t0014) != 0x00)
	{
		Eq_64436 ecx_220;
		Eq_2 edx_222;
		__stack_chk_fail(out ecx_220, out edx_222);
		Eq_2 eax_226 = __gconv_get_cache();
		ecxOut = ecx_220;
		edxOut = edx_222;
		return eax_226;
	}
	else
	{
		ecxOut = ecx_154;
		edxOut = edx_159;
		return eax_161;
	}
}

// 0806D9B0: Register Eq_2 __gconv_get_cache()
// Called from:
//      find_module
Eq_2 __gconv_get_cache()
{
	return gconv_cache;
}

// 0806D9D0: Register word32 __gconv_load_cache(Register (ptr32 Eq_9) gs)
// Called from:
//      __gconv_read_conf
word32 __gconv_load_cache(struct Eq_9 * gs)
{
	word32 eax_184;
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 eax_28 = getenv(0x080A5805);
	__gconv_path_envvar = eax_28;
	struct Eq_64667 * ebx_17 = &g_t80CE000;
	if (eax_28 != 0x00)
	{
l0806DB06:
		eax_184 = ~0x00;
		goto l0806DB0B;
	}
	word32 edx_421;
	word32 ecx_420;
	Eq_2 eax_49 = __open_nocancel(gs, 0x080A5810, 0x00, 0x00, out ecx_420, out edx_421);
	if (eax_49 == ~0x00)
		goto l0806DB06;
	word32 edx_423;
	word32 ecx_422;
	if (__fxstat64(gs, eax_49, fp - 0x80, out ecx_422, out edx_423) >= 0x00 && dwLoc54 > 0x0F)
	{
		cache_size = dwLoc54;
		word32 edx_426;
		word32 ecx_425;
		Eq_2 eax_98 = mmap(gs, 0x00, dwLoc54, 0x01, 0x01, eax_49, 0x00, out ecx_425, out edx_426);
		gconv_cache = eax_98;
		if (eax_98 != ~0x00)
		{
l0806DA85:
			word32 edx_434;
			__close_nocancel(gs, eax_49, out edx_434);
			Eq_2 edx_199 = gconv_cache;
			if (*edx_199 != 0x20010324)
			{
l0806DAE0:
				if (cache_malloced == 0x00)
				{
					word32 ecx_446;
					word32 edx_447;
					__munmap(0x080CE000, gs, edx_199, cache_size, out ecx_446, out edx_447, out ebx_17);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 ecx_444;
					word32 edx_445;
					free(gs, stackArg0, edx_199, out ecx_444, out edx_445);
					cache_malloced = 0x00;
				}
				ebx_17->dw1954 = 0x00;
				goto l0806DB06;
			}
			Eq_2 ecx_203 = cache_size;
			if ((word32) *((word32) edx_199 + 4) >= ecx_203)
				goto l0806DAE0;
			Eq_2 esi_207 = (word32) *((word32) edx_199 + 6);
			if (ecx_203 <= esi_207)
				goto l0806DAE0;
			ui32 eax_210 = (word32) *((word32) edx_199 + 8);
			if ((word16) eax_210 == 0x00 || (ecx_203 < (word32) esi_207 + eax_210 * 0x04 || ecx_203 <= (word32) (*((word32) edx_199 + 0x0A))))
				goto l0806DAE0;
			eax_184 = 0x00;
			if (ecx_203 < (word32) (*((word32) edx_199 + 0x0C)))
				goto l0806DAE0;
l0806DB0B:
			if ((eax_20 ^ gs->t0014) == 0x00)
				return eax_184;
			word32 ecx_435;
			word32 edx_436;
			__stack_chk_fail(out ecx_435, out edx_436);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			word32 ebx_440;
			word32 esi_441;
			word32 edi_442;
			return __gconv_compare_alias_cache(gs, stackArg4, stackArg8, stackArg12, out ebx_440, out esi_441, out edi_442);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 edi_109 = cache_size;
		Eq_2 stackArg0 = <invalid>;
		word32 edi_433;
		word32 ebp_431;
		word32 esi_432;
		word32 ecx_428;
		word32 edx_429;
		word32 ebx_430;
		Eq_2 eax_114 = __libc_malloc(gs, stackArg0, edi_109, out ecx_428, out edx_429, out ebx_430, out ebp_431, out esi_432, out edi_433);
		gconv_cache = eax_114;
		if (eax_114 != 0x00)
		{
			Eq_2 ebp_123 = 0x00;
			while (true)
			{
				word32 eax_144 = read(gs, eax_49, eax_114 + ebp_123, edi_109 - ebp_123);
				if (eax_144 == ~0x00)
					break;
				edi_109 = cache_size;
				ebp_123 = (word32) ebp_123 + eax_144;
				if (edi_109 <= ebp_123)
				{
					cache_malloced = 0x01;
					goto l0806DA85;
				}
				eax_114 = gconv_cache;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_449;
			word32 edx_450;
			free(gs, stackArg0, gconv_cache, out ecx_449, out edx_450);
			gconv_cache.u0 = 0x00;
		}
	}
	word32 edx_424;
	__close_nocancel(gs, eax_49, out edx_424);
	eax_184 = ~0x00;
	goto l0806DB0B;
}

// 0806DBE0: Register Eq_2 __gconv_compare_alias_cache(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ebxOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      __gconv_compare_alias
//      __gconv_load_cache
Eq_2 __gconv_compare_alias_cache(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ebxOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 eax_142;
	Eq_2175 ecx_19 = gs->t0014;
	if (gconv_cache == 0x00)
	{
		eax_142.u0 = ~0x00;
		goto l0806DC37;
	}
	word32 ecx_164;
	if (find_module_idx(dwArg04, fp - 0x18, out ecx_164) == 0x00)
	{
		word32 ecx_165;
		eax_142 = find_module_idx(dwArg08, fp - 0x14, out ecx_165);
		if (eax_142 == 0x00)
		{
			*dwArg0C = dwLoc18 - dwLoc14;
l0806DC37:
			if ((ecx_19 ^ gs->t0014) != 0x00)
			{
				word32 ecx_168;
				word32 edx_169;
				__stack_chk_fail(out ecx_168, out edx_169);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg12 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				Eq_43241 stackArg20 = <invalid>;
				word32 ecx_173;
				Eq_2 eax_97 = __gconv_lookup_cache(gs, dwLoc18, dwLoc14, stackArg12, stackArg16, stackArg20, out ecx_173);
				ebxOut = dwArg04;
				esiOut = dwArg08;
				ediOut = dwArg0C;
				return eax_97;
			}
			else
			{
				ebxOut = ebx;
				esiOut = esi;
				ediOut = edi;
				return eax_142;
			}
		}
	}
	word32 ecx_166;
	word32 edx_167;
	*dwArg0C = strcmp(dwArg04, dwArg08, out ecx_166, out edx_167);
	eax_142.u0 = 0x00;
	goto l0806DC37;
}

// 0806DC80: Register Eq_2 __gconv_lookup_cache(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_43241 bArg14, Register out Eq_2 ecxOut)
// Called from:
//      __gconv_find_transform
//      __gconv_compare_alias_cache
Eq_2 __gconv_lookup_cache(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_43241 bArg14, union Eq_2 & ecxOut)
{
	Eq_2 esi_288;
	Eq_2 ecx_155 = dwArg10;
	Eq_2175 ebx_26 = gs->t0014;
	Eq_2 ebx_29 = gconv_cache;
	if (ebx_29 == 0x00)
	{
		esi_288.u0 = 0x02;
		goto l0806DD0B;
	}
	word16 dx_36 = *((word32) ebx_29 + 4);
	int32 ebp_35 = (word32) *((word32) ebx_29 + 0x0A);
	if (find_module_idx(dwArg08, fp - 0x28, out ecx_155) == 0x00)
	{
		ui32 ecx_50 = (word32) dwLoc28 + 3 + dwLoc28 * 0x02;
		ecx_155 = ecx_50 * 0x04;
		if ((word32) *((word32) ebx_29 + 0x0A) + ecx_50 * 0x04 > cache_size)
			goto l0806DD06;
		Eq_2 eax_60 = find_module_idx(dwArg04, fp - 0x24, out ecx_155);
		if (eax_60 == 0x00)
		{
			ui32 eax_73 = (word32) dwLoc24 + 3 + dwLoc24 * 0x02;
			ecx_155 = dwLoc24;
			if ((word32) *((word32) ebx_29 + 0x0A) + (eax_73 << 0x02) > cache_size)
				goto l0806DD06;
			Eq_151179 edx_78[] = (word32) ebx_29 + ebp_35;
			struct Eq_65022 * eax_80 = edx_78 - 0x0C + (eax_73 << 0x02);
			if ((bArg14 & 0x01) != 0x00 && dwLoc24 == dwLoc28)
			{
				esi_288.u0 = ~0x00;
				goto l0806DD0B;
			}
			Eq_2 ebx_302;
			Eq_2 eax_340;
			Eq_2 ebp_253;
			Eq_2 ecx_359;
			ptr32 eax_96 = (word32) ebx_29 + (word32) dx_36;
			struct Eq_65039 * eax_99 = edx_78 - 0x0C + ecx_50 * 0x04;
			if (dwLoc24 == 0x00 || dwLoc28 == 0x00)
			{
l0806DD9F:
				ebp_253 = dwLoc28;
				if (dwLoc28 == 0x00)
				{
					if (dwLoc24 != 0x00 && eax_80->w0008 != 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 edx_874;
						word32 ebx_875;
						word32 esi_877;
						word32 ebp_876;
						word32 edi_878;
						Eq_2 eax_374 = __libc_malloc(gs, stackArg0, 0x78, out ecx_155, out edx_874, out ebx_875, out ebp_876, out esi_877, out edi_878);
						ebx_302 = eax_374;
						if (eax_374 != 0x00)
						{
							*dwArg0C = eax_374;
							*dwArg10 = 0x00;
							ecx_359 = eax_374;
							goto l0806DDF7;
						}
						goto l0806DF90;
					}
					goto l0806DD06;
				}
				if (eax_99->w0004 == 0x00)
					goto l0806DD06;
				if (dwLoc24 == 0x00)
				{
l0806DE90:
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 esi_897;
					word32 edi_898;
					word32 ebp_896;
					word32 ebx_895;
					word32 edx_894;
					Eq_2 eax_298 = __libc_malloc(gs, stackArg0, 0x78, out ecx_155, out edx_894, out ebx_895, out ebp_896, out esi_897, out edi_898);
					esi_288 = eax_60;
					ebx_302 = eax_298;
					if (eax_298 != 0x00)
					{
						*dwArg0C = eax_298;
						*dwArg10 = 0x00;
						word32 eax_312 = (word32) eax_99->w0000;
						*((word32) eax_298 + 8) = 0x01;
						((word32) eax_298 + 56)->u0 = 0x00;
						*((word32) eax_298 + 0x0C) = eax_312 + eax_96;
						*((word32) eax_298 + 16) = 0x080A4DFD;
						Eq_2 edx_323 = (word32) eax_99->w0008 + eax_96;
						if ((word32) eax_99->w0006 + eax_96 != 0x00)
						{
							Eq_2 edx_341;
							word32 ecx_881;
							eax_340 = find_module(eax, eax_298, edx_341, gs, out ecx_881, out edx_341);
							if (eax_340 != 0x00)
								goto l0806DFB2;
						}
						else
							__gconv_get_builtin_trans(edx_323, eax_298);
						int32 edx_350 = *dwArg10;
						*dwArg10 = edx_350 + 0x01;
						ecx_155 = dwLoc24;
						ebp_253 = edx_350 + 0x01;
						if (dwLoc24 == 0x00)
						{
l0806DD0B:
							while ((ebx_26 ^ gs->t0014) != 0x00)
							{
								word32 edx_872;
								__stack_chk_fail(out ecx_155, out edx_872);
l0806E0D5:
								esi_288 = dwLoc30;
							}
							ecxOut = ecx_155;
							return esi_288;
						}
						ecx_359 = (word32) eax_298 + (edx_350 + 0x01) *s 0x3C;
l0806DDF7:
						*((word32) ecx_359 + 0x0C) = 0x080A4DFD;
						word32 eax_397 = (word32) eax_80->w0000 + eax_96;
						*((word32) ecx_359 + 8) = 0x01;
						*((word32) ecx_359 + 16) = eax_397;
						byte * eax_401 = (word32) eax_80->w0002 + eax_96;
						word32 edx_402 = (word32) eax_80->w0004;
						((word32) ecx_359 + 56)->u0 = 0x00;
						esi_288 = eax_60;
						Eq_2 edx_404 = edx_402 + eax_96;
						if (*eax_401 == 0x00)
						{
							ecx_155 = __gconv_get_builtin_trans(edx_404, ecx_359);
							goto l0806DE40;
						}
						Eq_2 edx_431;
						eax_340 = find_module(eax, ecx, edx_431, gs, out ecx_155, out edx_431);
						if (eax_340 == 0x00)
						{
l0806DE40:
							*dwArg10 = (word32) *dwArg10 + 1;
							goto l0806DD0B;
						}
						if (ebp_253 != 0x00)
						{
							word32 edx_884;
							__gconv_release_step(gs, ebx_302, out edx_884);
						}
l0806DFB2:
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 edx_883;
						free(gs, stackArg0, ebx_302, out ecx_155, out edx_883);
						esi_288 = eax_340;
						goto l0806DD0B;
					}
l0806DF90:
					esi_288.u0 = 0x03;
					goto l0806DD0B;
				}
l0806DE7C:
				if (eax_80->w0008 != 0x00)
					goto l0806DE90;
				goto l0806DD06;
			}
			word32 eax_109 = (word32) eax_99->w000A;
			if ((word16) eax_109 != 0x00)
			{
				struct Eq_65119 * eax_117 = (word32) gconv_cache + (((word32) (*((word32) ebx_29 + 0x0C)) - 0x01) + eax_109);
				int32 eax_119 = (word32) eax_117->w0000;
				struct Eq_65119 * ebp_118 = eax_117;
				while ((word16) eax_119 != 0x00)
				{
					if (dwLoc24 == (word32) (ebp_118->a0002)[(eax_119 - 0x03) + eax_119 * 0x02])
					{
						*dwArg10 = eax_119;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 ebx_887;
						word32 ebp_888;
						word32 edx_886;
						word32 esi_889;
						word32 edi_890;
						Eq_2 eax_156 = __libc_malloc(gs, stackArg0, eax_119 *s 0x3C, out ecx_155, out edx_886, out ebx_887, out ebp_888, out esi_889, out edi_890);
						*dwArg0C = eax_156;
						if (eax_156 == 0x00)
							goto l0806DF90;
						Eq_2 ebx_168 = eax_156;
						dwLoc30 = eax_60;
						struct Eq_65317 * ebp_171 = ebp_118->a0002;
						int32 dwLoc3C_586 = 0x00;
						word32 esi_176 = (word32) eax_99->w0000 + eax_96;
						do
						{
							ui32 eax_179 = (word32) ebp_171->t0000;
							*((word32) ebx_168 + 0x0C) = esi_176;
							word32 esi_188 = (word32) edx_78[eax_179].w0000;
							int32 eax_189 = (word32) ebp_171->w0002;
							Eq_2 edx_190 = (word32) ebp_171->w0004 + eax_96;
							*((word32) ebx_168 + 8) = 0x01;
							*((word32) ebx_168 + 56) = 0x00;
							esi_176 = esi_188 + eax_96;
							*((word32) ebx_168 + 16) = esi_176;
							if (eax_189 + eax_96 == 0x00)
								ecx_155 = __gconv_get_builtin_trans(edx_190, ebx_168);
							else
							{
								Eq_2 edx_204;
								if (find_module(eax, ebx_168, edx_204, gs, out ecx_155, out edx_204) != 0x00)
								{
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg0 = <invalid>;
									word32 edx_892;
									free(gs, stackArg0, eax_156, out ecx_155, out edx_892);
									goto l0806DD9F;
								}
							}
							int32 v19_238 = dwLoc3C_586 + 0x01;
							dwLoc3C_586 = v19_238;
							ebx_168 = (word32) ebx_168 + 60;
							++ebp_171;
						} while ((word32) ebp_118->w0000 > v19_238);
						goto l0806E0D5;
					}
					ebp_118 = (struct Eq_65119 *) (ebp_118->a0002 + eax_119 * 3);
					eax_119 = (word32) ebp_118->w0000;
				}
			}
			if (eax_99->w0004 != 0x00)
				goto l0806DE7C;
		}
	}
l0806DD06:
	esi_288.u0 = 0x01;
	goto l0806DD0B;
}

// 0806E100: Register Eq_2 __gconv_release_cache()
// Called from:
//      __gconv_close_transform
Eq_2 __gconv_release_cache()
{
	if (gconv_cache != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_41;
		word32 edx_42;
		free(gs, stackArg0, dwArg04, out ecx_41, out edx_42);
	}
	return <invalid>;
}

// 0806E140: void known_compare(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_2) dwArg08)
void known_compare(union Eq_2 * dwArg04, union Eq_2 * dwArg08)
{
	Eq_2 eax_6 = *dwArg08;
	Eq_2 eax_9 = *dwArg04;
	word32 ecx_22;
	word32 edx_23;
	strcmp(eax_9, eax_6, out ecx_22, out edx_23);
}

// 0806E160: void do_release_shlib(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack word32 dwArg08)
void do_release_shlib(struct Eq_9 * gs, union Eq_2 * dwArg04, word32 dwArg08)
{
	if (dwArg08 != 0x00 && dwArg08 != 0x03)
		return;
	Eq_2 ebx_19 = *dwArg04;
	Eq_65453 eax_20 = *((word32) ebx_19 + 4);
	if (release_handle == ebx_19)
	{
		if (eax_20 <= 0x00)
		{
			word32 ecx_140;
			word32 edx_141;
			__assert_fail(out ecx_140, out edx_141);
			Eq_2 esp_39 = <invalid>;
			word32 ecx_142;
			__gconv_find_shlib(gs, *((word32) esp_39 + 4), out ecx_142);
		}
		else
			*((word32) ebx_19 + 4) = eax_20 - 0x01;
	}
	else if (eax_20 <= 0x00)
	{
		*((word32) ebx_19 + 4) = eax_20 - 0x01;
		if (eax_20 == ~0x01 && *((word32) ebx_19 + 8) != 0x00)
		{
			word32 ecx_139;
			__libc_dlclose(out ecx_139);
			*((word32) ebx_19 + 8) = 0x00;
		}
	}
}

// 0806E200: Register Eq_2 __gconv_find_shlib(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      find_derivation
//      find_module
//      do_release_shlib
Eq_2 __gconv_find_shlib(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 esi_114;
	Eq_2 eax_29 = __tfind(fp + 0x04, 0x080CF95C, 0x0806E140);
	if (eax_29 != 0x00)
	{
		esi_114 = *eax_29;
		if (esi_114 == 0x00)
			goto l0806E396;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		word32 edx_407;
		word32 ecx_406;
		Eq_2 eax_45 = strlen(dwArg04, out ecx_406, out edx_407);
		Eq_2 stackArg0 = <invalid>;
		word32 ebx_411;
		word32 edx_410;
		word32 ecx_409;
		word32 ebp_412;
		word32 esi_413;
		word32 edi_414;
		Eq_2 eax_56 = __libc_malloc(gs, stackArg0, (word32) eax_45 + 25, out ecx_409, out edx_410, out ebx_411, out ebp_412, out esi_413, out edi_414);
		ecx = dwArg04;
		esi_114 = eax_56;
		if (eax_56 == 0x00)
			goto l0806E396;
		word32 ecx_420;
		word32 edx_421;
		Eq_2 eax_77 = memcpy((word32) eax_56 + 24, dwArg04, (word32) eax_45 + 1, out ecx_420, out edx_421);
		*((word32) eax_56 + 4) = ~0x02;
		*eax_56 = eax_77;
		*((word32) eax_56 + 8) = 0x00;
		word32 edx_422;
		if (__tsearch(eax_56, 0x080CF95C, 0x0806E140, out ecx, out edx_422) == null)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_424;
			free(gs, stackArg0, eax_56, out ecx, out edx_424);
			goto l0806E396;
		}
	}
	int32 eax_120 = *((word32) esi_114 + 4);
	word32 edx_121 = *((word32) esi_114 + 8);
	if (eax_120 >= ~0x01)
	{
		if (edx_121 != 0x00)
		{
			if (eax_120 < 0x00)
				eax_120 = 0x00;
			*((byte) esi_114.u0 + 4) = eax_120 + 0x01;
		}
		goto l0806E314;
	}
	if (edx_121 != 0x00)
	{
		word32 ecx_415;
		word32 edx_416;
		__assert_fail(out ecx_415, out edx_416);
		Eq_2 ecx_162;
		word32 edx_425;
		Eq_2 eax_161 = __gconv_release_shlib(0x080A5833, out ecx_162, out edx_425);
		ecxOut = ecx_162;
		return eax_161;
	}
	word32 eax_175 = __libc_dlopen_mode(gs, out ecx);
	*((word32) esi_114 + 8) = eax_175;
	if (eax_175 != 0x00)
	{
		word32 ecx_417;
		Eq_2 eax_206 = __libc_dlsym(gs, out ecx_417);
		*((word32) esi_114 + 0x0C) = eax_206;
		if (eax_206 != 0x00)
		{
			word32 ecx_419;
			*((byte) esi_114.u0 + 16) = __libc_dlsym(gs, out ecx_419);
			Eq_2 ecx_275;
			Eq_2 eax_273 = __libc_dlsym(gs, out ecx_275);
			*((byte) esi_114.u0 + 4) = 0x01;
			Eq_2 edx_279 = *((byte) esi_114.u0 + 0x0C);
			Eq_2 eax_284 = __rol(eax_273 ^ gs->t0018, 0x09);
			Eq_2 edx_287 = __rol(edx_279 ^ gs->t0018, 0x09);
			*((byte) esi_114.u0 + 20) = eax_284;
			*((byte) esi_114.u0 + 0x0C) = edx_287;
			*((byte) esi_114.u0 + 16) = __rol(*((byte) esi_114.u0 + 16) ^ gs->t0018, 0x09);
			ecxOut = ecx_275;
			return esi_114;
		}
		release_handle = esi_114;
		word32 edx_418;
		twalk(loaded, &g_u806E160, out ecx, out edx_418);
		esi_114.u0 = 0x00;
l0806E314:
		ecxOut = ecx;
		return esi_114;
	}
l0806E396:
	ecxOut = ecx;
	return 0x00;
}

// 0806E3F0: Register word32 __gconv_release_shlib(Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __gconv_release_step
//      __gconv_find_shlib
word32 __gconv_release_shlib(Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	release_handle = dwArg04;
	ptr32 edx_18;
	ptr32 ecx_19;
	word32 eax_17 = twalk(loaded, &g_u806E160, out ecx_19, out edx_18);
	ecxOut = ecx_19;
	edxOut = edx_18;
	return eax_17;
}

// 0806E430: Register Eq_2 new_composite_name(Register Eq_2 eax, Register (arr Eq_2) edx, Register (ptr32 Eq_9) gs)
// Called from:
//      setlocale
Eq_2 new_composite_name(Eq_2 eax, Eq_2 edx[], struct Eq_9 * gs)
{
	Eq_2 edi_10 = 0x00;
	Eq_2 esi_14 = 0x00;
	word32 dwLoc28_327 = 0x01;
	while (true)
	{
		if (esi_14 != 0x06)
		{
			Eq_2 ebp_37;
			if (eax == 0x06)
				ebp_37 = edx[esi_14];
			else if (eax != esi_14)
				ebp_37 = *((char *) g_a80CEEA0 + esi_14 * 0x04);
			else
				ebp_37 = edx[0];
			word32 edx_461;
			word32 ecx_460;
			Eq_2 eax_48 = strlen(ebp_37, out ecx_460, out edx_461);
			edi_10 = (word32) eax_48 + (((word32) edi_10 + 2) + (word32) (((word32) esi_14 - 165696) + 0x080CE000));
			if (dwLoc28_327 != 0x00)
			{
				Eq_2 eax_69 = edx[0];
				if (eax_69 != ebp_37)
				{
					word32 ecx_462;
					word32 edx_463;
					dwLoc28_327 = (word32) (strcmp(ebp_37, eax_69, out ecx_462, out edx_463) == 0x00);
				}
			}
			if (esi_14 == 0x0C)
			{
				Eq_2 dwLoc28_368;
				if (dwLoc28_327 != 0x00)
				{
					Eq_2 esi_216 = edx[0];
					dwLoc28_368.u0 = 134892338;
					word32 ecx_469;
					word32 edx_470;
					if (strcmp(esi_216, 134892338, out ecx_469, out edx_470) == 0x00)
						return dwLoc28_368;
					word32 edx_472;
					word32 ecx_471;
					if (strcmp(esi_216, 0x080B1B74, out ecx_471, out edx_472) == 0x00)
						return dwLoc28_368;
					Eq_2 edi_261;
					Eq_2 esi_263;
					word32 ecx_473;
					word32 ebx_475;
					word32 ebp_476;
					word32 edx_474;
					Eq_2 eax_257 = __libc_malloc(gs, dwLoc40, (word32) eax_48 + 1, out ecx_473, out edx_474, out ebx_475, out ebp_476, out esi_263, out edi_261);
					if (eax_257 != 0x00)
					{
						word32 edx_478;
						word32 ecx_477;
						dwLoc28_368 = memcpy(eax_257, esi_263, edi_261, out ecx_477, out edx_478);
						return dwLoc28_368;
					}
				}
				else
				{
					struct Eq_65792 * ebx_115;
					word32 esi_467;
					word32 edx_465;
					word32 ecx_464;
					word32 edi_468;
					word32 ebp_466;
					Eq_2 eax_113 = __libc_malloc(gs, dwLoc40, edi_10, out ecx_464, out edx_465, out ebx_115, out ebp_466, out esi_467, out edi_468);
					Eq_2 edx_125 = eax_113;
					if (eax_113 != 0x00)
					{
						Eq_2 esi_132 = 0x00;
						while (true)
						{
							if (esi_132 != 0x06)
							{
								Eq_2 ebp_147;
								if (eax == 0x06)
									ebp_147 = edx[esi_132];
								else if (esi_132 != eax)
									ebp_147 = ebx_115->a0EA0[esi_132];
								else
									ebp_147 = edx[0];
								word32 ecx_479;
								Eq_2 eax_167 = __stpcpy(edx_125, (char *) ebx_115 - 165664 + (word32) ebx_115[((word32) esi_132 - 165680) / 3744], out ecx_479);
								*eax_167 = 0x3D;
								word32 ecx_480;
								Eq_2 eax_185 = __stpcpy((word32) eax_167 + 1, ebp_147, out ecx_480);
								*eax_185 = 0x3B;
								edx_125 = (word32) eax_185 + 1;
								if (esi_132 == 0x0C)
								{
									*eax_185 = 0x00;
									return eax_113;
								}
							}
							esi_132 = (word32) esi_132 + 1;
						}
					}
				}
				dwLoc28_368.u0 = 0x00;
				return dwLoc28_368;
			}
		}
		esi_14 = (word32) esi_14 + 1;
	}
}

// 0806E630: void setlocale(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void setlocale(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	struct Eq_65920 * ebx_1174 = &g_t80CE000;
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 esi_209 = dwArg04;
	Eq_2 edx_1089 = dwArg08;
	if (dwArg04 > 0x0C)
	{
		gs->tFFFFFFE0.u0 = 22;
		goto l0806E6E7;
	}
	if (dwArg08 == 0x00)
	{
l0806E6E7:
		if ((eax_20 ^ gs->t0014) == 0x00)
			return;
		word32 edx_1893;
		word32 ecx_1892;
		Eq_2 eax_1128 = __stack_chk_fail(out ecx_1892, out edx_1893);
		strip(eax_1128, edx_1089);
		return;
	}
	uint32 edi_207 = (word32) dwArg04 + 16;
	edx_1089 = dwArg08;
	word32 edx_1891;
	word32 ecx_1890;
	if (strcmp(dwArg08, *((char *) &g_ptr80CEE60 + ((word32) dwArg04 + 16) * 0x04), out ecx_1890, out edx_1891) == 0x00)
		goto l0806E6E7;
	Eq_2 eax_89 = getenv(0x080A58A7);
	if (eax_89 != 0x00 && (*eax_89 != 0x00 && (argz_create_sep(gs, eax_89, fp - 0x90, fp - 0x8C) != 0x00 || __argz_add_sep(gs, fp - 0x90, fp - 0x8C, 0x080A59B0) != 0x00)))
	{
		edx_1089 = dwArg08;
		Mem1116 = Mem1117;
		goto l0806E6E7;
	}
	if (dwArg04 == 0x06)
	{
		ui32 eax_447 = 0x00;
		while (true)
		{
			if (eax_447 != 0x06)
			{
				(fp - 0x88)[eax_447] = dwArg08;
				if (eax_447 == 0x0C)
				{
					word32 ecx_1894;
					word32 edx_1895;
					Eq_2 eax_471 = strchr(dwArg08, 0x3B, out ecx_1894, out edx_1895);
					Eq_2 dwLocA4_1308 = eax_471;
					if (eax_471 == 0x00)
					{
l0806E792:
						Eq_2 edi_1167[] = fp - 0x88;
						ui32 esi_715 = 0x0D;
l0806E7A1:
						Eq_2 ebp_1171;
						ui32 eax_822;
						Eq_2 ebp_719 = esi_715 - 0x01;
						while (esi_715 != 0x00)
						{
							Eq_2 esi_729;
							if (ebp_719 == 0x06)
								esi_729.u0 = 0x05;
							else
								esi_729 = ebp_719;
							ui32 ebp_750;
							struct Eq_65989 * eax_749 = _nl_find_locale(gs, 0x00, 0x00, esi_729, edi_1167 + esi_729, out ebx_1174, out ebp_750, out esi_715, out edi_1167);
							(fp - 0x54)[esi_715] = eax_749;
							if (eax_749 == null)
							{
								if ((fp - 0x88)[esi_715] == 134892338)
									goto l0806E7A1;
								goto l0806EAD2;
							}
							if (eax_749->dw0018 != ~0x00)
								eax_749->dw0018 = ~0x00;
							Eq_2 edx_776 = (fp - 0x88)[esi_715];
							if (edx_776 == 134892338)
								goto l0806E7A1;
							Eq_2 ecx_783 = *((char *) g_a80CEEA0 + esi_715 * 0x04);
							word32 ecx_1897;
							word32 edx_1898;
							if (strcmp(edx_776, ecx_783, out ecx_1897, out edx_1898) != 0x00)
							{
								Eq_2 eax_806 = strdup(edx_776);
								(fp - 0x88)[esi_715] = eax_806;
								if (eax_806 != 0x00)
									goto l0806E7A1;
l0806EAD2:
								eax_822 = ebp_750;
								ebp_1171.u0 = 134892338;
								if (ebp_750 == 0x0D)
									goto l0806EB11;
								goto l0806EADD;
							}
							(fp - 0x88)[esi_715] = ecx_783;
							ebp_719 = esi_715 - 0x01;
						}
						Eq_2 eax_847 = new_composite_name(0x06, edi_1167, gs);
						Eq_2 eax_858 = (char *) ebx_1174 - 169166;
						if (eax_847 != 0x00)
						{
							ui32 ebp_908 = 0x00;
							while (true)
							{
								if (ebp_908 != 0x06)
								{
									int32 edx_912 = ebp_908 * 0x04;
									if (ebx_1174[edx_912 - 0x0140] != 0x00)
									{
										ebx_1174[edx_912 + 0x0E60] = (struct Eq_65920) (fp - 0x54)[ebp_908];
										<anonymous> * edx_922 = ebx_1174[edx_912 - 0x0180];
										if (edx_922 != null)
											edx_922();
									}
									Eq_2 esi_937 = edi_1167[ebp_908];
									Eq_2 edx_939 = ebx_1174->a0EA0[ebp_908];
									if (esi_937 != edx_939)
									{
										if (edx_939 != eax_858)
										{
											word32 ecx_1905;
											word32 edx_1906;
											free(gs, dwLocD0, edx_939, out ecx_1905, out edx_1906);
										}
										ebx_1174->a0EA0[ebp_908] = esi_937;
									}
									if (ebp_908 == 0x0C)
									{
										Eq_2 eax_974 = ebx_1174[0x0EB8];
										if (eax_847 != eax_974)
										{
											if (eax_974 != (char *) ebx_1174 - 169166)
											{
												word32 ecx_1913;
												word32 edx_1914;
												free(gs, dwLocD0, eax_974, out ecx_1913, out edx_1914);
											}
											ebx_1174[0x0EB8] = (struct Eq_65920) eax_847;
										}
										_nl_msg_cat_cntr = (word32) _nl_msg_cat_cntr + 1;
l0806EB13:
										word32 edx_1911;
										word32 ecx_1910;
										free(gs, dwLocD0, 0x00, out ecx_1910, out edx_1911);
										word32 ecx_1912;
										free(gs, dwLocD0, dwLocA4_1308, out ecx_1912, out edx_1089);
										goto l0806E6E7;
									}
								}
								++ebp_908;
							}
						}
						eax_822 = 0x00;
						ebp_1171 = (char *) ebx_1174 - 169166;
l0806EADD:
						ui32 esi_870 = eax_822;
						while (true)
						{
							if (esi_870 != 0x06)
							{
								Eq_2 eax_876 = edi_1167[esi_870];
								if (eax_876 != ebp_1171 && eax_876 != (ebx_1174->a0EA0)[esi_870])
								{
									word32 edx_1909;
									word32 ecx_1908;
									free(gs, dwLocD0, eax_876, out ecx_1908, out edx_1909);
								}
								if (esi_870 == 0x0C)
								{
l0806EB11:
									goto l0806EB13;
								}
							}
							++esi_870;
						}
					}
					Eq_2 eax_489 = strdup(dwArg08);
					dwLocA4_1308 = eax_489;
					Eq_2 esi_505 = eax_489;
					edx_1089 = dwArg08;
					if (eax_489 == 0x00)
						goto l0806E6E7;
l0806EC00:
					word32 edx_1904;
					word32 ecx_1903;
					Eq_2 eax_537 = strchr(esi_505, 0x3D, out ecx_1903, out edx_1904);
					if (eax_537 == 0x00)
					{
l0806EC80:
						ui32 eax_616 = 0x00;
						while (true)
						{
							if (eax_616 != 0x06)
							{
								if ((fp - 0x88)[eax_616] == dwArg08)
								{
l0806ECB0:
									word32 ecx_1907;
									free(gs, dwLocD0, eax_489, out ecx_1907, out edx_1089);
									gs->tFFFFFFE0.u0 = 22;
									goto l0806E6E7;
								}
								if (eax_616 == 0x0C)
									goto l0806E792;
							}
							++eax_616;
						}
					}
					else
					{
						Eq_2 eax_549 = eax_537 - esi_505;
						Eq_66131 ebp_550 = 0x00;
						while (true)
						{
							if (ebp_550 != 0x06)
							{
								if ((word32) ((word32) ebp_550 - 165696 + 0x080CE000) == eax_549)
								{
									word32 edx_1900;
									word32 ecx_1899;
									if (memcmp(esi_505, (word32) ((word32) ebp_550 - 165680 + 0x080CE000) + 0x080A58E0, eax_549, out ecx_1899, out edx_1900) == 0x00)
									{
										(fp - 0x88)[ebp_550] = (word32) eax_537 + 1;
										word32 edx_1902;
										word32 ecx_1901;
										Eq_2 eax_601 = strchr((word32) eax_537 + 1, 0x3B, out ecx_1901, out edx_1902);
										if (eax_601 != 0x00)
										{
											*eax_601 = 0x00;
											esi_505 = (word32) eax_601 + 1;
											goto l0806EC00;
										}
										goto l0806EC80;
									}
								}
								if (ebp_550 == 0x0C)
									goto l0806ECB0;
							}
							ebp_550 = (word32) ebp_550 + 1;
						}
					}
				}
			}
			++eax_447;
		}
	}
	struct Eq_65989 * dwLocAC_1225;
	word32 eax_182 = g_a80CE140[dwArg04 * 0x04];
	Eq_2 dwLoc54_1223 = dwArg08;
	if (eax_182 != 0x00)
	{
		word32 ebp_1896;
		struct Eq_65989 * eax_203 = _nl_find_locale(gs, 0x00, 0x00, dwArg04, fp - 0x54, out ebx_1174, out ebp_1896, out esi_209, out edi_207);
		dwLocAC_1225 = eax_203;
		if (eax_203 == null)
			goto l0806EB8C;
		if (eax_203->dw0018 != ~0x00)
			eax_203->dw0018 = ~0x00;
	}
	else
		dwLocAC_1225 = null;
	Eq_2 ebp_224 = (char *) ebx_1174 - 169166;
	if (dwArg08 != ebp_224)
	{
		Eq_2 eax_233 = strdup(dwArg08);
		dwLoc54_1223 = eax_233;
		if (eax_233 == 0x00)
			goto l0806EB8C;
	}
	Eq_2 eax_254 = new_composite_name(esi_209, fp - 0x54, gs);
	if (eax_254 != 0x00)
	{
		if (eax_182 != 0x00)
		{
			*((char *) &g_ptr80CEE60 + esi_209 * 0x04) = (struct Eq_70762 **) dwLocAC_1225;
			<anonymous> * edx_293 = (ebx_1174 - 0x0180)[esi_209];
			if (edx_293 != null)
				edx_293();
		}
		Eq_2 edx_314 = *((char *) &g_ptr80CEE60 + edi_207 * 0x04);
		if (dwLoc54_1223 != edx_314)
		{
			if (edx_314 != ebp_224)
			{
				word32 edx_1916;
				word32 ecx_1915;
				free(gs, dwLocD0, edx_314, out ecx_1915, out edx_1916);
			}
			*((char *) &g_ptr80CEE60 + edi_207 * 0x04) = (struct Eq_70762 **) dwLoc54_1223;
		}
		Eq_2 edx_347 = ebx_1174[0x0EB8];
		if (eax_254 != edx_347)
		{
			if (edx_347 != ebp_224)
			{
				word32 ecx_1920;
				word32 edx_1921;
				free(gs, dwLocD0, edx_347, out ecx_1920, out edx_1921);
			}
			ebx_1174[0x0EB8] = (struct Eq_65920) eax_254;
		}
		_nl_msg_cat_cntr = (word32) _nl_msg_cat_cntr + 1;
l0806EA06:
		word32 ecx_1917;
		free(gs, dwLocD0, 0x00, out ecx_1917, out edx_1089);
		goto l0806E6E7;
	}
	if (dwLoc54_1223 != ebp_224)
	{
		word32 edx_1919;
		word32 ecx_1918;
		free(gs, dwLocD0, dwLoc54_1223, out ecx_1918, out edx_1919);
	}
l0806EB8C:
	goto l0806EA06;
}

// 0806ED30: void strip(Register Eq_2 eax, Register Eq_2 edx)
// Called from:
//      setlocale
//      _nl_find_locale
void strip(Eq_2 eax, Eq_2 edx)
{
	Eq_2 edx_118;
	word32 ecx_101 = (word32) *edx;
	if ((byte) ecx_101 == 0x00)
	{
		*eax = 0x2F;
		edx_118 = (word32) eax + 1;
		goto l0806EDF2;
	}
	else
	{
		Eq_2 esi_28 = g_t80CE08C;
		int32 ebp_107 = 0x00;
		Eq_3803 esi_33[] = g_ptr80CE084;
		do
		{
			cu8 cl_35 = (byte) ecx_101;
			int32 esi_39 = (int32) cl_35;
			word32 dwLoc1C_152 = ebp_107 + 0x01;
			if (((int8) (cl_35 <= 0x2E) | ((int8) (cl_35 == 0x3A) | (int8) (cl_35 == 0x5F))) == 0x00 && (*((word32) esi_28 + esi_39 * 0x02) & 0x08) == 0x00)
			{
				if (cl_35 == 0x2F)
				{
					int32 esi_93 = ebp_107 + 0x01;
					if (esi_93 == 0x03)
						goto l0806EDF8;
					*eax = 0x2F;
					edx = (word32) edx + 1;
					ecx_101 = (word32) *edx;
					ebp_107 = esi_93;
					dwLoc1C_152 = ebp_107 + 0x02;
					eax = (word32) eax + 1;
					if ((byte) ecx_101 == 0x00)
						break;
					continue;
				}
			}
			else
			{
				eax = (word32) eax + 1;
				*((word32) eax - 1) = esi_33[esi_39];
			}
			edx = (word32) edx + 1;
			ecx_101 = (word32) *edx;
		} while ((byte) ecx_101 != 0x00);
		if (ebp_107 <= 0x01)
		{
			*eax = 0x2F;
			edx_118 = (word32) eax + 1;
			if (dwLoc1C_152 == 0x01)
			{
l0806EDF2:
				*edx_118 = 0x2F;
				eax = (word32) edx_118 + 1;
				goto l0806EDF8;
			}
			eax = edx_118;
		}
l0806EDF8:
		*eax = 0x00;
	}
}

// 0806EE10: Register Eq_2 _nl_find_locale(Register (ptr32 Eq_9) gs, Stack ui32 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack (ptr32 Eq_2) dwArg10, Register out (ptr32 Eq_66082) ebxOut, Register out (ptr32 Eq_66083) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      setlocale
Eq_2 _nl_find_locale(struct Eq_9 * gs, ui32 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 * dwArg10, struct Eq_66082 & ebxOut, struct Eq_66083 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	struct Eq_66083 * ebp_1038 = fp - 4;
	Eq_2 esi_1057 = *dwArg10;
	if (*esi_1057 != 0x00)
	{
l0806EE54:
		Eq_2 esp_1121;
		struct Eq_66082 * ebx_1065;
		Eq_2 edi_1060;
		word32 edx_1415;
		word32 ecx_1414;
		if (strcmp(esi_1057, 134892338, out ecx_1414, out edx_1415) != 0x00)
		{
			word32 ecx_1416;
			word32 edx_1417;
			if (strcmp(esi_1057, 0x080B1B74, out ecx_1416, out edx_1417) != 0x00)
			{
				word32 ecx_1418;
				word32 edx_1419;
				Eq_2 eax_169 = strlen(esi_1057, out ecx_1418, out edx_1419);
				if (eax_169 <= 0xFF)
				{
					Eq_2 edi_199;
					if (__memmem(gs, esi_1057, eax_169, 0x080A599C, 0x04, out ebp_1038, out esi_1057, out edi_199) != 0x00)
						goto l0806EF50;
					if (edi_199 != 0x02)
					{
						if (edi_199 > 0x02 && (*esi_1057 == 0x2E && (*((word32) esi_1057 + 1) == 0x2E && *((byte) esi_1057.u0 + 2) == 0x2F) || *((word32) edi_199 + (esi_1057 - 0x03)) == 0x2F && (Mem188[(esi_1057 - 0x02) + edi_199:byte] == 0x2E && Mem188[(esi_1057 - 0x01) + edi_199:byte] == 0x2E)))
							goto l0806EF50;
l0806EED3:
						if (__memchr(esi_1057, 0x2F, edi_199) == 0x00 || *esi_1057 == 0x2F)
							goto l0806EEEA;
						goto l0806EF50;
					}
					if (*esi_1057 != 0x2E)
						goto l0806EED3;
					if (*((byte) esi_1057.u0 + 1) != 0x2E && __memchr(esi_1057, 0x2F, 0x02) == 0x00)
					{
l0806EEEA:
						ptr32 ebx_303;
						Eq_2 edi_315;
						Eq_2 esi_290 = ebp_1038->tFFFFFFC0;
						*ebp_1038->tFFFFFFC4 = ebp_1038->tFFFFFFCC;
						if (esi_290 == 0x00)
						{
							word32 ebx_1420;
							Eq_2 eax_323 = _nl_load_locale_from_archive(gs, out ebx_1420, out ebp_1038, out esi_1057);
							edi_1060 = eax_323;
							if (eax_323 != 0x00)
								goto l0806EF16;
							Eq_2 eax_346 = _nl_expand_alias(gs, out ebx_303, out ebp_1038);
							ebp_1038->tFFFFFFCC = eax_346;
							if (eax_346 == 0x00)
							{
								ebp_1038->t000C.u0 = 0x10;
								ebp_1038->tFFFFFFC0 = ebx_303 + ~0x0002864F;
								goto l0806F310;
							}
							Eq_2 eax_373 = _nl_load_locale_from_archive(gs, out ebx_303, out ebp_1038, out esi_1057);
							edi_1060 = eax_373;
							if (eax_373 != 0x00)
								goto l0806EF16;
							edi_315 = ebp_1038->tFFFFFFCC;
							ebp_1038->t000C.u0 = 0x10;
							ebp_1038->tFFFFFFC0 = ebx_303 + ~0x0002864F;
						}
						else
						{
							Eq_2 eax_301 = _nl_expand_alias(gs, out ebx_303, out ebp_1038);
							ebp_1038->tFFFFFFCC = eax_301;
							edi_315 = eax_301;
						}
						if (edi_315 != 0x00)
							goto l0806F029;
l0806F310:
						edi_315 = *ebp_1038->tFFFFFFC4;
						ebp_1038->tFFFFFFCC = edi_315;
l0806F029:
						word32 ecx_1423;
						word32 edx_1424;
						Eq_2 eax_413 = strlen(edi_315, out ecx_1423, out edx_1424);
						Eq_2 esp_420 = fp - 0x4C;
						esi_1057 = fp - 0x4C - ((word32) eax_413 + 28 & ~0x0FFF);
						ui32 ecx_427 = (word32) eax_413 + 28 & ~0x0F;
						if (fp - 0x4C != esi_1057)
						{
							do
							{
								esp_420 -= 0x1000;
								*((word32) esp_420 + 0x0FFC) = *((word32) esp_420 + 0x0FFC);
							} while (esp_420 != esi_1057);
						}
						if ((ecx_427 & 0x0FFF) != 0x00)
						{
							esp_420 -= ecx_427 & 0x0FFF;
							Mem450[esp_420 - 0x04 + (ecx_427 & 0x0FFF):word32] = Mem448[esp_420 - 0x04 + (ecx_427 & 0x0FFF):word32];
						}
						struct Eq_66906 * esp_455 = esp_420 - 0x04;
						esp_455->tFFFFFFFC = (word32) eax_413 + 1;
						esp_455->tFFFFFFF8 = edi_315;
						Mem470[esp_455 + -0x0C:word32] = esp_420 + 0x0F & ~0x0F;
						word32 edx_1426;
						word32 ecx_1425;
						Eq_2 eax_471 = memcpy(esp_455->tFFFFFFF4, esp_455->tFFFFFFF8, esp_455->tFFFFFFFC, out ecx_1425, out edx_1426);
						esp_455->tFFFFFFF8 = ebp_1038 - 0x20;
						esp_455->tFFFFFFF4 = ebp_1038 - 0x24;
						esp_455->tFFFFFFF0 = ebp_1038 - 0x28;
						esp_455->tFFFFFFEC = ebp_1038 - 44;
						esp_455->tFFFFFFE8 = ebp_1038 - 0x30;
						esp_455->tFFFFFFE4 = eax_471;
						Eq_2 eax_504 = _nl_explode_name(esp_455->tFFFFFFE4, esp_455->tFFFFFFE8, esp_455->tFFFFFFEC, esp_455->tFFFFFFF0, esp_455->tFFFFFFF4, esp_455->tFFFFFFF8);
						if (eax_504 != ~0x00)
						{
							Eq_2 eax_516 = ebp_1038->t0010;
							esp_455->tFFFFFFFC.u0 = 0x00;
							Eq_2 edx_528 = ebx_303 + ~0x0002871F + (word32) (*((word32) eax_516 + (ebx_303 + ~0x0002872F)));
							Eq_2 eax_529 = ebp_1038->t0010;
							esp_455->tFFFFFFF8 = edx_528;
							esp_455->tFFFFFFF4 = ebp_1038->tFFFFFFD4;
							esp_455->tFFFFFFF0 = ebp_1038->tFFFFFFE0;
							esp_455->tFFFFFFEC = ebp_1038->tFFFFFFDC;
							esp_455->tFFFFFFE8 = ebp_1038->tFFFFFFD8;
							esp_455->tFFFFFFE4 = ebp_1038->tFFFFFFD0;
							esp_455->tFFFFFFE0 = eax_504;
							esp_455->tFFFFFFDC = ebp_1038->t000C;
							esp_455->tFFFFFFD8 = ebp_1038->tFFFFFFC0;
							Eq_2 ecx_532 = ebx_303 + 0x1FA0 + eax_529 * 0x04;
							esp_455->tFFFFFFD4 = ecx_532;
							ebp_1038->tFFFFFFBC = edx_528;
							ebp_1038->tFFFFFFC4 = ecx_532;
							Eq_2 edi_564;
							Eq_2 eax_560 = _nl_make_l10nflist(esp_455->tFFFFFFD4, esp_455->tFFFFFFD8, esp_455->tFFFFFFDC, esp_455->tFFFFFFE0, esp_455->tFFFFFFE4, esp_455->tFFFFFFE8, esp_455->tFFFFFFEC, esp_455->tFFFFFFF0, esp_455->tFFFFFFF4, esp_455->tFFFFFFF8, esp_455->tFFFFFFFC, out ebx_1065, out ebp_1038, out edi_564);
							Eq_2 ecx_573 = ebp_1038->tFFFFFFC4;
							Eq_2 edx_574 = ebp_1038->tFFFFFFBC;
							esi_1057 = eax_560;
							if (eax_560 == 0x00)
							{
								esp_455->tFFFFFFFC.u0 = 0x01;
								esp_455->tFFFFFFF8 = edx_574;
								esp_455->tFFFFFFF4 = ebp_1038->tFFFFFFD4;
								esp_455->tFFFFFFF0 = ebp_1038->tFFFFFFE0;
								esp_455->tFFFFFFEC = ebp_1038->tFFFFFFDC;
								esp_455->tFFFFFFE8 = ebp_1038->tFFFFFFD8;
								esp_455->tFFFFFFE4 = ebp_1038->tFFFFFFD0;
								esp_455->tFFFFFFE0 = edi_564;
								esp_455->tFFFFFFDC = ebp_1038->t000C;
								esp_455->tFFFFFFD8 = ebp_1038->tFFFFFFC0;
								esp_455->tFFFFFFD4 = ecx_573;
								Eq_2 eax_610 = _nl_make_l10nflist(esp_455->tFFFFFFD4, esp_455->tFFFFFFD8, esp_455->tFFFFFFDC, esp_455->tFFFFFFE0, esp_455->tFFFFFFE4, esp_455->tFFFFFFE8, esp_455->tFFFFFFEC, esp_455->tFFFFFFF0, esp_455->tFFFFFFF4, esp_455->tFFFFFFF8, esp_455->tFFFFFFFC, out ebx_1065, out ebp_1038, out edi_564);
								esi_1057 = eax_610;
								if (eax_610 == 0x00)
									goto l0806F3A0;
							}
							if ((edi_564 & 0x01) != 0x00)
							{
								struct Eq_67238 * esp_633 = esp_420 - (struct Eq_67239 *) 0x0C;
								esp_633->tFFFFFFFC = ebp_1038->tFFFFFFE0;
								word32 ecx_1427;
								word32 edx_1428;
								free(gs, esp_633->tFFFFFFF8, esp_633->tFFFFFFFC, out ecx_1427, out edx_1428);
							}
							if (*((byte) esi_1057.u0 + 4) == 0x00)
							{
								struct Eq_67264 * esp_664 = esp_420 - (struct Eq_67265 *) 0x08;
								esp_664->tFFFFFFFC = ebp_1038->t0010;
								esp_664->tFFFFFFF8 = esi_1057;
								word32 edi_1429;
								_nl_load_locale(gs, esp_664->tFFFFFFF8, esp_664->tFFFFFFFC, out ebx_1065, out ebp_1038, out esi_1057, out edi_1429);
							}
							edi_1060 = *((byte) esi_1057.u0 + 8);
							if (edi_1060 == 0x00)
							{
								Eq_2 edx_693 = *((byte) esi_1057.u0 + 16);
								if (edx_693 != 0x00)
								{
									word32 eax_697 = esi_1057 + 0x10;
									do
									{
										if (*((word32) edx_693 + 4) == 0x00)
										{
											struct Eq_67703 * esp_705 = esp_420 - (struct Eq_67704 *) 0x08;
											esp_705->tFFFFFFFC = ebp_1038->t0010;
											esp_705->tFFFFFFF8 = edx_693;
											ebp_1038->tFFFFFFC4 = eax_697;
											_nl_load_locale(gs, esp_705->tFFFFFFF8, esp_705->tFFFFFFFC, out ebx_1065, out ebp_1038, out esi_1057, out edi_1060);
											eax_697 = ebp_1038->tFFFFFFC4;
										}
										Eq_2 edx_733 = *eax_697;
										Eq_2 ecx_734 = *((word32) edx_733 + 8);
										if (ecx_734 != 0x00)
										{
											*((byte) esi_1057.u0 + 16) = edx_733;
											edi_1060 = ecx_734;
											esi_1057 = edx_733;
											goto l0806F122;
										}
										eax_697 += 0x04;
										edx_693 = *eax_697;
									} while (edx_693 != 0x00);
								}
								((byte) esi_1057.u0 + 16)->u0 = 0x00;
l0806EF16:
								ebx_1065 = ebp_1038->tFFFFFFE4 ^ gs->t0014;
								if (ebx_1065 == null)
								{
									struct Eq_66772 * esp_1164 = ebp_1038 - 0x0C;
									Eq_2 esi_1167 = esp_1164->t0004;
									Eq_2 edi_1169 = esp_1164->t0008;
									struct Eq_66083 * ebp_1171 = esp_1164->ptr000C;
									ebxOut = esp_1164->ptr0000;
									ebpOut = ebp_1171;
									esiOut = esi_1167;
									ediOut = edi_1169;
									return edi_1060;
								}
								word32 ecx_1421;
								word32 edx_1422;
								__stack_chk_fail(out ecx_1421, out edx_1422);
								esp_1121.u0 = <invalid>;
l0806F489:
								struct Eq_67333 * esp_1129 = esp_1121 - (struct Eq_67334 *) 4;
								esp_1129->a0000[0].t0000 = (char *) ebx_1065 - 0x00028660;
								esp_1129->tFFFFFFFC.u0 = 0x011E;
								esp_1129->tFFFFFFF8 = (char *) ebx_1065 - 165515;
								esp_1129->tFFFFFFF4 = (char *) ebx_1065 - 165502;
								word32 ecx_1430;
								word32 edx_1431;
								__assert_fail(out ecx_1430, out edx_1431);
								Eq_2 eax_1159 = _nl_remove_locale(gs, dwArg04, dwArg08);
								ebxOut = ebx_1065;
								ebpOut = ebp_1038;
								esiOut = esi_1057;
								ediOut = edi_1060;
								return eax_1159;
							}
l0806F122:
							esp_1121 = esp_420;
							if (ebp_1038->tFFFFFFDC == 0x00)
							{
l0806F243:
								if (*edi_1060.u0 == 0x00)
								{
									Eq_2 eax_1014;
									struct Eq_67583 * esp_995 = esp_1121 - (struct Eq_67584 *) 0x08;
									esp_995->tFFFFFFFC.u0 = 0x2F;
									esp_995->tFFFFFFF8 = *esi_1057.u0;
									struct Eq_47366 * eax_1003 = rindex(esp_995->tFFFFFFF8, esp_995->b0004);
									Eq_2 edx_1012 = eax_1003 - 0x01;
									if (eax_1003->bFFFFFFFE != 0x2F)
									{
										do
											--edx_1012;
										while (*((word32) edx_1012 - 1) != 0x2F);
										eax_1014 = eax_1003 - edx_1012;
									}
									else
										eax_1014.u0 = 0x01;
									esp_995->tFFFFFFFC = eax_1014;
									esp_995->tFFFFFFF8 = edx_1012;
									*edi_1060.u0 = __strndup(gs, esp_995->tFFFFFFF8, esp_995->tFFFFFFFC, out ebp_1038);
								}
								Eq_2 eax_1053 = ebp_1038->tFFFFFFD4;
								if (eax_1053 != 0x00)
								{
									struct Eq_67622 * esp_1062 = esp_1121 - (struct Eq_67623 *) 0x04;
									esp_1062->tFFFFFFFC = ebx_1065 - 0xC0;
									esp_1062->tFFFFFFF8 = (char *) ebx_1065 - 0x0002A560;
									esp_1062->tFFFFFFF4 = eax_1053;
									word32 ecx_1436;
									int32 eax_1076 = __strcasecmp_l(esp_1062->tFFFFFFF4, esp_1062->tFFFFFFF8, esp_1062->tFFFFFFFC, out ecx_1436);
									edi_1060 = *((byte) esi_1057.u0 + 8);
									if (eax_1076 == 0x00)
										((byte) edi_1060.u0 + 28)->u0 = 0x01;
								}
								else
									edi_1060 = *((byte) esi_1057.u0 + 8);
								Eq_2 eax_1091 = *((byte) edi_1060.u0 + 24);
								if (eax_1091 <= ~0x02)
									*((byte) edi_1060.u0 + 24) = (word32) eax_1091 + 1;
								goto l0806EF16;
							}
							edi_1060 = *((byte) edi_1060.u0 + ((ebx_1065->aFFFD79C0)[ebp_1038->t0010] * 0x04 + 36));
							if (edi_1060 == 0x00)
								goto l0806F489;
							struct Eq_67361 * esp_774 = esp_420 - (struct Eq_67362 *) 0x0C;
							esp_774->tFFFFFFFC = edi_1060;
							word32 ecx_1432;
							word32 edx_1433;
							Eq_2 eax_778 = strlen(esp_774->tFFFFFFFC, out ecx_1432, out edx_1433);
							word32 esp_785 = esp_774 + 0x0C;
							word32 ecx_790 = esp_774 + 0x0C - (eax_778 + 0x1E & ~0x0FFF);
							ui32 edx_791 = (word32) eax_778 + 30 & ~0x0F;
							if (esp_774 + 0x0C != ecx_790)
							{
								do
								{
									esp_785 -= (struct Eq_67397 *) 0x1000;
									esp_785->dw0FFC = esp_785->dw0FFC;
								} while (esp_785 != ecx_790);
							}
							if ((edx_791 & 0x0FFF) != 0x00)
							{
								esp_785 -= edx_791 & 0x0FFF;
								Mem814[esp_785 - 0x04 + (edx_791 & 0x0FFF):word32] = Mem812[esp_785 - 0x04 + (edx_791 & 0x0FFF):word32];
							}
							word32 eax_818 = esp_785 + 0x0F;
							ebp_1038->tFFFFFFC4 = eax_818 & ~0x0F;
							strip(eax_818 & ~0x0F, edi_1060);
							Eq_2 edx_837 = ebp_1038->tFFFFFFDC;
							struct Eq_67421 * esp_838 = esp_785 - (struct Eq_67422 *) 0x0C;
							esp_838->tFFFFFFFC = edx_837;
							ebp_1038->tFFFFFFC0 = edx_837;
							word32 ecx_1434;
							word32 edx_1435;
							Eq_2 eax_843 = strlen(esp_838->tFFFFFFFC, out ecx_1434, out edx_1435);
							word32 esp_850 = esp_838 + 0x0C;
							word32 edx_855 = esp_838 + 0x0C - (eax_843 + 0x1E & ~0x0FFF);
							ui32 ecx_856 = (word32) eax_843 + 30 & ~0x0F;
							Eq_2 edx_858 = ebp_1038->tFFFFFFC0;
							if (esp_838 + 0x0C != edx_855)
							{
								do
								{
									esp_850 -= (struct Eq_67482 *) 0x1000;
									esp_850->dw0FFC = esp_850->dw0FFC;
								} while (esp_850 != edx_855);
							}
							if ((ecx_856 & 0x0FFF) != 0x00)
							{
								esp_850 -= ecx_856 & 0x0FFF;
								Mem880[esp_850 - 0x04 + (ecx_856 & 0x0FFF):word32] = Mem878[esp_850 - 0x04 + (ecx_856 & 0x0FFF):word32];
							}
							word32 edi_884 = esp_850 + 0x0F;
							strip(edi_884 & ~0x0F, edx_858);
							Eq_151224 edx_906[] = ebx_1065->ptrFFFFFF7C;
							Eq_2 eax_910 = ebp_1038->tFFFFFFC4;
							do
							{
								eax_910 = (word32) eax_910 + 1;
								byte cl_925 = edx_906[(int32) *((word32) eax_910 - 1)].b0000;
								*((word32) eax_910 - 1) = cl_925;
							} while (cl_925 != 0x00);
							struct Eq_67533 * eax_931 = edi_884 & ~0x0F;
							do
							{
								++eax_931;
								byte cl_940 = edx_906[(int32) eax_931->bFFFFFFFF].b0000;
								eax_931->bFFFFFFFF = cl_940;
							} while (cl_940 != 0x00);
							struct Eq_67550 * esp_947 = esp_850 - (struct Eq_67551 *) 0x08;
							esp_947->tFFFFFFFC = ebp_1038->tFFFFFFC4;
							esp_947->tFFFFFFF8 = edi_884 & ~0x0F;
							esp_1121 = esp_947 + 0x08;
							if (__gconv_compare_alias(gs, esp_947->tFFFFFFF8, esp_947->tFFFFFFFC, out ebx_1065, out ebp_1038, out esi_1057) == 0x00)
							{
								edi_1060 = *((byte) esi_1057.u0 + 8);
								goto l0806F243;
							}
						}
l0806F3A0:
						edi_1060.u0 = 0x00;
						goto l0806EF16;
					}
				}
l0806EF50:
				gs->tFFFFFFE0.u0 = 22;
				edi_1060.u0 = 0x00;
				goto l0806EF16;
			}
		}
		*dwArg10 = (union Eq_2 *) 134892338;
		edi_1060 = *((char *) g_a80CE100 + dwArg0C * 0x04);
		goto l0806EF16;
	}
	Eq_2 eax_100;
	Eq_2 eax_38 = getenv(0x080A5969);
	Eq_2 dwLoc38_1184 = eax_38;
	if (eax_38 == 0x00 || *eax_38 == 0x00)
	{
		word32 eax_63 = getenv(0x080A58E0<p32> + CONVERT(Mem46[0x080A58D0<p32> + dwArg0C:byte], byte, word32));
		dwLoc38_1184 = eax_63;
		if (eax_63 == 0x00 || *eax_63 == 0x00)
		{
			eax_100 = getenv(0x080A5970);
			dwLoc38_1184 = eax_100;
			if (eax_100 == 0x00)
				goto l0806EFE3;
l0806EF89:
			if (*eax_100 != 0x00)
			{
				esi_1057 = dwLoc38_1184;
				goto l0806EE54;
			}
l0806EFE3:
			esi_1057.u0 = 134892338;
			goto l0806EE54;
		}
	}
	eax_100 = dwLoc38_1184;
	goto l0806EF89;
}

// 0806F4B0: Register ui32 _nl_remove_locale(Register (ptr32 Eq_9) gs, Stack ui32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _nl_find_locale
ui32 _nl_remove_locale(struct Eq_9 * gs, ui32 dwArg04, Eq_2 dwArg08)
{
	Eq_2 v7_11 = *((word32) dwArg08 + 24) - 0x01;
	*((word32) dwArg08 + 24) = v7_11;
	if (v7_11 != 0x00)
		return eax;
	if (*((word32) dwArg08 + 0x0C) != 0x02)
	{
		struct Eq_67799 * eax_19 = *((char *) g_a80CFFA0 + dwArg04 * 0x04);
		if (dwArg08 != eax_19->t0008)
		{
			do
				eax_19 = eax_19->ptr000C;
			while (eax_19->t0008 != dwArg08);
		}
		eax_19->dw0004 = 0x00;
		eax_19->t0008.u0 = 0x00;
	}
	return _nl_unload_locale(gs, dwArg08);
}

// 0806F510: Register Eq_2 _nl_intern_locale_data(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_67833) ebxOut, Register out Eq_2 ebpOut, Register out (ptr32 Eq_67835) esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_load_locale
//      _nl_load_locale_from_archive
Eq_2 _nl_intern_locale_data(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_67833 & ebxOut, union Eq_2 & ebpOut, struct Eq_67835 & esiOut, union Eq_2 & ediOut)
{
	if (dwArg0C > 0x07)
	{
		ui32 edx_23 = *dwArg08;
		ui32 eax_24 = 0x20051017;
		if (dwArg04 != 0x03)
		{
			eax_24 = dwArg04 ^ 0x20031115;
			if (dwArg04 == 0x00)
				eax_24 = 0x20090720;
		}
		if (edx_23 == eax_24)
		{
			uint32 edi_40 = *((word32) dwArg08 + 4);
			if (edi_40 >= g_a80A6060[dwArg04 * 0x04])
			{
				Eq_2 eax_45 = edi_40 * 0x04 + 0x08;
				if (eax_45 < dwArg0C)
				{
					Eq_2 ebp_73;
					struct Eq_67833 * ebx_74;
					Eq_2 edi_76;
					struct Eq_67835 * esi_78;
					word32 ecx_356;
					word32 edx_357;
					Eq_2 eax_72 = __libc_malloc(gs, dwLoc40, (word32) eax_45 + 28, out ecx_356, out edx_357, out ebx_74, out ebp_73, out esi_78, out edi_76);
					if (eax_72 != 0x00)
					{
						*((word32) eax_72 + 4) = ebp_73;
						*((word32) eax_72 + 20) = 0x00;
						*((word32) eax_72 + 8) = dwArg0C;
						*((word32) eax_72 + 16) = 0x00;
						((word32) eax_72 + 24)->u0 = 0x00;
						((word32) eax_72 + 28)->u0 = 0x00;
						*((word32) eax_72 + 32) = edi_76;
						if (edi_76 != 0x00)
						{
							Eq_2 ecx_176 = *((word32) ebp_73 + 8);
							if (ecx_176 <= dwArg0C)
							{
								Eq_2 edi_101 = esi_78 * 0x04;
								Eq_2 edx_103 = 0x00;
								do
								{
									byte cl_148 = (byte) ecx_176;
									if (esi_78 <= (struct Eq_67835 *) 0x0C)
									{
										Eq_2 edi_212 = ebx_74 + (ebx_74->aFFFD7A20)[esi_78];
										word32 edx_214;
										Eq_2 eax_215;
										word32 ecx_216;
										edi_212();
										ebxOut = ebx_74;
										ebpOut = esi_78 * 0x04;
										esiOut = esi_78;
										ediOut = edi_212;
										return eax_215;
									}
									if (esi_78 != null)
									{
										word32 ecx_360;
										word32 edx_361;
										__assert_fail(out ecx_360, out edx_361);
										word32 ebx_362;
										word32 ebp_363;
										word32 esi_364;
										word32 edi_365;
										Eq_2 eax_138 = _nl_load_locale(gs, dwArg04, ebp_73, out ebx_362, out ebp_363, out esi_364, out edi_365);
										ebxOut = ebx_74;
										ebpOut = ebp_73;
										esiOut = esi_78;
										ediOut = edi_101;
										return eax_138;
									}
									if (edx_103 <= 0x55)
									{
										edi_101 = ebx_74->aFFFFE700[esi_78];
										if (*((word32) edi_101 + edx_103 * 0x04) != 0x05)
											goto l0806F639;
										if ((cl_148 & 0x03) != 0x00)
											break;
										edi_101 = *((word32) eax_72 + 4);
										(eax_72 + 0x24)[edx_103 * 0x04] = Mem144[edi_101 + ecx_176:word32];
									}
									else
									{
l0806F639:
										(eax_72 + 0x24)[edx_103 * 0x04] = ecx_176 + Mem144[eax_72 + 0x04:word32];
									}
									edx_103 = (word32) edx_103 + 1;
									if (*((word32) eax_72 + 32) <= edx_103)
										goto l0806F593;
									ecx_176 = *((word32) ebp_73 + (edx_103 * 0x04 + 8));
								} while (*((word32) eax_72 + 8) >= ecx_176);
							}
							word32 edx_359;
							word32 ecx_358;
							free(gs, dwLoc40, eax_72, out ecx_358, out edx_359);
							gs->tFFFFFFE0.u0 = 22;
							ebxOut = ebx;
							ebpOut = ebp;
							esiOut = esi;
							ediOut = edi;
							return 0x00;
						}
					}
l0806F593:
					ebxOut = ebx;
					ebpOut = ebp;
					esiOut = esi;
					ediOut = edi;
					return eax_72;
				}
			}
		}
	}
	gs->tFFFFFFE0.u0 = 22;
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return 0x00;
}

// 0806F770: Register ui32 _nl_load_locale(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ebxOut, Register out (ptr32 Eq_67283) ebpOut, Register out Eq_67284 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_locale
//      _nl_intern_locale_data
ui32 _nl_load_locale(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ebxOut, struct Eq_67283 & ebpOut, union Eq_67284 & esiOut, union Eq_2 & ediOut)
{
	*((word32) dwArg04 + 8) = 0x00;
	struct Eq_67283 * ebp_302 = fp - 4;
	Eq_67284 esi_155 = 0x00;
	word32 ecx_656;
	word32 edx_657;
	Eq_2 eax_35 = __open_nocancel(gs, *dwArg04, 0x00080000, dwLocB4, out ecx_656, out edx_657);
	if (eax_35 < 0x00)
	{
l0806F873:
		ui32 eax_504 = ebp_302->tFFFFFFE4 ^ gs->t0014;
		if (eax_504 != 0x00)
		{
			word32 ecx_674;
			word32 edx_675;
			__stack_chk_fail(out ecx_674, out edx_675);
			ui32 eax_514 = _nl_unload_locale(gs, dwArg04);
			ebxOut = ebx;
			ebpOut = ebp_302;
			esiOut = esi_155;
			ediOut = edi;
			return eax_514;
		}
		else
		{
			struct Eq_68250 * esp_521 = ebp_302 - 0x0C;
			Eq_67284 esi_524 = esp_521->t0004;
			Eq_2 edi_526 = esp_521->t0008;
			struct Eq_67283 * ebp_528 = esp_521->ptr000C;
			ebxOut = esp_521->t0000;
			ebpOut = ebp_528;
			esiOut = esi_524;
			ediOut = edi_526;
			return eax_504;
		}
	}
	edi = eax_35;
	ptr32 esp_253 = fp - 0xAC;
	word32 ecx_658;
	word32 edx_659;
	if (__fxstat64(gs, eax_35, fp - 0x80, out ecx_658, out edx_659) >= 0x00)
	{
		if ((dwLoc70 & 0xF000) != 0x4000)
		{
l0806F7F8:
			word32 edx_399;
			Eq_2 eax_391;
			struct Eq_68128 * esp_261 = esp_253 - 0x08;
			esp_261->tFFFFFFFC.u0 = 0x00;
			esp_261->tFFFFFFF8 = edi;
			esp_261->tFFFFFFF4.u0 = 0x02;
			esp_261->tFFFFFFF0.u0 = 0x01;
			esp_261->tFFFFFFEC = dwLoc54;
			esp_261->tFFFFFFE8.u0 = 0x00;
			word32 ecx_664;
			word32 edx_665;
			Eq_2 eax_281 = mmap(gs, esp_261->tFFFFFFE8, esp_261->tFFFFFFEC, esp_261->tFFFFFFF0, esp_261->tFFFFFFF4, esp_261->tFFFFFFF8, esp_261->tFFFFFFFC, out ecx_664, out edx_665);
			&esi_155.u0->t0000 = ~0x1F;
			esp_253 = (char *) &esp_261->t0000 + 8;
			ebx = eax_281;
			if (eax_281 != ~0x00)
			{
				esp_261->tFFFFFFF8 = edi;
				word32 edx_666;
				__close_nocancel(gs, esp_261->tFFFFFFF8, out edx_666);
				if (eax_281 == 0x00)
					goto l0806F873;
				esp_261->t0000 = dwLoc54;
				esp_261->tFFFFFFFC = eax_281;
				esp_261->tFFFFFFF8 = dwArg08;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				word32 ebp_669;
				word32 esi_670;
				word32 ebx_668;
				word32 edi_671;
				eax_391 = _nl_intern_locale_data(gs, stackArg4, dwArg04, dwArg08, out ebx_668, out ebp_669, out esi_670, out edi_671);
				if (eax_391 == 0x00)
				{
					esp_261->tFFFFFFFC = dwLoc54;
					esp_261->tFFFFFFF8 = eax_281;
					word32 ecx_672;
					word32 edx_673;
					__munmap(eax_281, gs, esp_261->tFFFFFFF8, esp_261->tFFFFFFFC, out ecx_672, out edx_673, out ebx);
					goto l0806F873;
				}
				edx_399 = 0x01;
l0806F85A:
				Eq_2 ecx_491 = ebp_302->tFFFFFF70;
				*eax_391 = 0x00;
				*((word32) eax_391 + 0x0C) = edx_399;
				*((word32) ecx_491 + 8) = eax_391;
				((word32) ecx_491 + 4)->u0 = 0x01;
				goto l0806F873;
			}
			if (gs->tFFFFFFE0 == 0x26)
			{
				esp_261->tFFFFFFF8 = dwLoc54;
				word32 ecx_676;
				word32 edx_677;
				Eq_2 eax_301 = __libc_malloc(gs, esp_261->tFFFFFFF4, esp_261->tFFFFFFF8, out ecx_676, out edx_677, out ebx, out ebp_302, out esi_155, out edi);
				ebp_302->tFFFFFF64 = eax_301;
				esp_253 = (char *) &esp_261->t0000 + 8;
				if (eax_301 != 0x00)
				{
					Eq_2 ecx_317 = ebp_302->tFFFFFF68;
					ebx = ecx_317;
					if (ecx_317 > 0x00)
					{
						ebp_302->tFFFFFF68 = edi;
						Eq_2 edi_322 = eax_301;
						do
						{
							struct Eq_68358 * esp_324 = esp_253 - 0x04;
							esp_324->tFFFFFFFC = ebx;
							esp_324->tFFFFFFF8 = edi_322;
							esp_324->tFFFFFFF4 = ebp_302->tFFFFFF68;
							word32 ecx_684;
							Eq_2 eax_337 = __read_nocancel(gs, esp_324->tFFFFFFF4, esp_324->tFFFFFFF8, esp_324->tFFFFFFFC, out ecx_684);
							if (eax_337 <= 0x00)
							{
								esp_324->tFFFFFFF4 = ebp_302->tFFFFFF64;
								ebx = ebp_302->tFFFFFF74;
								edi = ebp_302->tFFFFFF68;
								ebp_302->tFFFFFF70 = eax_337;
								word32 ecx_686;
								word32 edx_687;
								free(gs, esp_324->tFFFFFFF0, esp_324->tFFFFFFF4, out ecx_686, out edx_687);
								esp_253 = (char *) &esp_324->tFFFFFFFC + 8;
								if (ebp_302->tFFFFFF70 == 0x00)
									(gs->*esi_155.u0).t0000 = 22;
								goto l0806F940;
							}
							ebx -= eax_337;
							edi_322 += eax_337;
						} while (ebx > 0x00);
						edi = ebp_302->tFFFFFF68;
					}
					(gs->*esi_155.u0).t0000 = ebp_302->dwFFFFFF6C;
					struct Eq_68310 * esp_356 = esp_253 - 0x0C;
					esp_356->tFFFFFFFC = edi;
					word32 edx_678;
					__close_nocancel(gs, esp_356->tFFFFFFFC, out edx_678);
					esp_356->dw0004 = ebp_302->dwFFFFFFB0;
					esp_356->t0000 = ebp_302->tFFFFFF64;
					esp_356->tFFFFFFFC = ebp_302->t000C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 ebx_680;
					word32 ebp_681;
					word32 esi_682;
					word32 edi_683;
					eax_391 = _nl_intern_locale_data(gs, stackArg4, dwArg04, dwArg08, out ebx_680, out ebp_681, out esi_682, out edi_683);
					if (eax_391 != 0x00)
					{
						edx_399 = 0x00;
						goto l0806F85A;
					}
					goto l0806F873;
				}
			}
			goto l0806F940;
		}
		word32 edx_661;
		__close_nocancel(gs, eax_35, out edx_661);
		Eq_2 ebx_83 = *dwArg04;
		word32 ecx_662;
		word32 edx_663;
		Eq_2 eax_85 = strlen(ebx_83, out ecx_662, out edx_663);
		Eq_68107 edi_95 = (word32) *((word32) dwArg08 + 0x080A58C0);
		ui32 edx_97 = (word32) edi_95 + ((word32) eax_85 + 33);
		struct Eq_68116 * esp_105 = fp - 0xAC;
		struct Eq_68116 * esi_100 = fp - 0xAC - (edx_97 & ~0x0FFF);
		if (fp - 0xAC != esi_100)
		{
			do
			{
				esp_105 -= 0x1000;
				esp_105->dw0FFC = esp_105->dw0FFC;
			} while (esp_105 != esi_100);
		}
		int32 ecx_116 = edx_97 & ~0x0F & 0x0FFF;
		if (ecx_116 != 0x00)
		{
			esp_105 -= ecx_116;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_105 - 0x04)[ecx_116 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_105 - 0x04)[ecx_116 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_68405 * esp_134 = esp_105 - 0x04;
		esp_134->tFFFFFFFC = eax_85;
		esp_134->tFFFFFFF8 = ebx_83;
		Eq_68414 edx_128 = (char *) esp_105 + 0x0F;
		esp_134->tFFFFFFF4 = edx_128 & ~0x0F;
		esi_155 = 0x080A58E0<p32> + CONVERT(Mem153[0x080A58D0<p32> + dwArg08:byte], byte, word32);
		word32 edx_685;
		Eq_2 eax_156 = __mempcpy(esp_134->tFFFFFFF4, esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out edx_685);
		*eax_156 = 0x5359532F;
		((word32) eax_156 + 4)->u0 = 0x5F;
		ebx.u0 = 0x080CE000;
		byte dl_199 = (byte) edi_95 + 0x01;
		if (edi_95 < 0x03)
		{
			if (edi_95 != 0x01)
			{
				ebx = (word32) esi_155.u0->t0000;
				*((word32) eax_156 + 5) = (byte) ebx;
				if ((dl_199 & 0x02) != 0x00)
					Mem205[eax_156 + 0x03 + (edi_95 + 0x01):word16] = Mem198[esi_155 - 0x02 + (edi_95 + 0x01):word16];
			}
		}
		else
		{
			*((word32) eax_156 + 5) = esi_155.u0->t0000;
			ebx = Mem176[esi_155 - 0x04 + (edi_95 + 0x01):word32];
			Mem178[eax_156 + 0x01 + (edi_95 + 0x01):word32] = ebx;
			word32 edi_175 = eax_156 + 0x09 & ~0x03;
			word32 ecx_179 = eax_156 + 0x05 - edi_175;
			esi_155 -= ecx_179;
			word32 ecx_182;
			for (ecx_182 = ecx_179 + (edi_95 + 0x01) >>u 0x02; ecx_182 != 0x00; --ecx_182)
			{
				edi_175->dw0000 = (word32) esi_155.u0->t0000;
				esi_155 += 4;
				edi_175 += 4;
			}
		}
		esp_134->tFFFFFFF8.u0 = 0x00080000;
		esp_134->tFFFFFFF4 = edx_128 & ~0x0F;
		word32 ecx_688;
		word32 edx_689;
		Eq_2 eax_225 = __open_nocancel(gs, esp_134->tFFFFFFF4, esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out ecx_688, out edx_689);
		edi = eax_225;
		if (eax_225 < 0x00)
			goto l0806F873;
		esp_134->tFFFFFFFC = fp - 0x80;
		esp_134->tFFFFFFF8 = eax_225;
		esp_134->tFFFFFFF4.u0 = 0x03;
		esp_253 = (char *) &esp_134->tFFFFFFFC + 8;
		word32 ecx_690;
		word32 edx_691;
		if (__fxstat64(gs, esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out ecx_690, out edx_691) >= 0x00)
			goto l0806F7F8;
	}
l0806F940:
	struct Eq_68074 * esp_425 = esp_253 - 0x0C;
	esp_425->tFFFFFFFC = edi;
	word32 edx_660;
	__close_nocancel(gs, esp_425->tFFFFFFFC, out edx_660);
	goto l0806F873;
}

// 0806FB00: Register Eq_2 _nl_unload_locale(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _nl_remove_locale
//      _nl_load_locale
//      free_category
Eq_2 _nl_unload_locale(struct Eq_9 * gs, Eq_2 dwArg04)
{
	<anonymous> * eax_14 = *((word32) dwArg04 + 16);
	if (eax_14 != null)
		eax_14();
	word32 eax_28 = *((word32) dwArg04 + 0x0C);
	if (eax_28 != 0x00)
	{
		if (eax_28 == 0x01)
		{
			word32 ebx_145;
			word32 edx_144;
			word32 ecx_143;
			__munmap(0x080CE000, gs, *((word32) dwArg04 + 4), *((word32) dwArg04 + 8), out ecx_143, out edx_144, out ebx_145);
			eax_28 = (word32) *((word32) dwArg04 + 0x0C);
		}
	}
	else
	{
		word32 ecx_141;
		word32 edx_142;
		free(gs, dwLoc20, *((word32) dwArg04 + 4), out ecx_141, out edx_142);
		eax_28 = (word32) *((word32) dwArg04 + 0x0C);
	}
	if (eax_28 != 0x02)
	{
		word32 ecx_148;
		word32 edx_149;
		free(gs, dwLoc20, *dwArg04, out ecx_148, out edx_149);
	}
	word32 ecx_146;
	word32 edx_147;
	return free(gs, dwLoc20, dwArg04, out ecx_146, out edx_147);
}

// 0806FB90: void rangecmp()
void rangecmp()
{
}

// 0806FBB0: Register Eq_2 _nl_load_locale_from_archive(Register (ptr32 Eq_9) gs, Register out Eq_2 ebxOut, Register out (ptr32 Eq_66740) ebpOut, Register out Eq_2 esiOut)
// Called from:
//      _nl_find_locale
Eq_2 _nl_load_locale_from_archive(struct Eq_9 * gs, union Eq_2 & ebxOut, struct Eq_66740 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2 esp_1181;
	Eq_2 eax_1172;
	Eq_2 eax_1245;
	struct Eq_68720 * ebx_33;
	struct Eq_66740 * ebp_1011;
	Eq_2 esi_1045;
	Eq_10314 eax_32 = __sysconf(gs, 0x1E, out ebx_33, out ebp_1011, out esi_1045);
	struct Eq_68730 * ebx_1403 = ebx_33->ptr1980;
	ebp_1011->tFFFFFE44 = eax_32;
	Eq_2 esp_39 = <invalid>;
	if (ebx_1403 != null)
	{
		Eq_2 edi_1394 = ebx_1403->t0004;
		if (esi_1045 == edi_1394)
		{
l0806FC2E:
			ebp_1011->ptrFFFFFE38->t0000 = edi_1394;
			eax_1245 = ebx_1403->a0008[ebp_1011->t0008];
			goto l0806FC3D;
		}
		while (true)
		{
			*((word32) esp_39 + 4) = edi_1394;
			*esp_39 = esi_1045;
			word32 edx_1607;
			word32 ecx_1606;
			if (strcmp(*esp_39, *((word32) esp_39 + 4), out ecx_1606, out edx_1607) == 0x00)
				goto l0806FC2E;
			ebx_1403 = ebx_1403->ptr0000;
			if (ebx_1403 == null)
				break;
			edi_1394 = ebx_1403->t0004;
			if (edi_1394 == esi_1045)
				goto l0806FC2E;
		}
	}
	((word32) esp_39 + 4)->u0 = 0x2E;
	*esp_39 = esi_1045;
	word32 ecx_1604;
	word32 edx_1605;
	Eq_2 eax_86 = strchr(*esp_39, *((word32) esp_39 + 4), out ecx_1604, out edx_1605);
	Eq_2 esp_334 = (word32) esp_39 + 16;
	if (eax_86 != 0x00 && (*((word32) eax_86 + 1) & 191) != 0x00)
	{
		((word32) esp_39 + 4)->u0 = 0x40;
		*esp_39 = (word32) eax_86 + 1;
		Eq_2 eax_110 = strchrnul(*esp_39, *((word32) esp_39 + 4));
		ebp_1011->tFFFFFE50 = eax_110;
		Eq_2 eax_122 = eax_110 - ((word32) eax_86 + 1);
		*((word32) esp_39 + 4) = eax_122;
		*esp_39 = (word32) eax_86 + 1;
		ebp_1011->tFFFFFE54 = eax_122;
		Eq_2 eax_132 = _nl_normalize_codeset(*esp_39, *((word32) esp_39 + 4));
		if (eax_132 == 0x00)
			goto l0806FE3E;
		Eq_2 ebx_141 = ebp_1011->tFFFFFE54;
		ebp_1011->tFFFFFE54 = eax_132;
		*((word32) esp_39 + 8) = ebx_141;
		*((word32) esp_39 + 4) = (word32) eax_86 + 1;
		*esp_39 = eax_132;
		word32 ecx_1647;
		word32 eax_151 = strncmp(*esp_39, *((word32) esp_39 + 4), *((word32) esp_39 + 8), out ecx_1647);
		ptr32 esp_158 = (word32) esp_39 + 16;
		Eq_2 edx_159 = ebp_1011->tFFFFFE54;
		if (eax_151 != 0x00 || Mem150[edx_159 + ebx_141:byte] != 0x00)
		{
			ebp_1011->tFFFFFE54 = edx_159;
			*esp_39 = edx_159;
			word32 ecx_1648;
			word32 edx_1649;
			Eq_2 eax_173 = strlen(*esp_39, out ecx_1648, out edx_1649);
			*esp_39 = ebp_1011->tFFFFFE50;
			ebp_1011->tFFFFFE48 = eax_173;
			word32 edx_1651;
			word32 ecx_1650;
			Eq_2 eax_187 = strlen(*esp_39, out ecx_1650, out edx_1651);
			ebp_1011->tFFFFFE4C = (word32) eax_187 + 1;
			Eq_2 ecx_198 = (word32) eax_86 + 1 - esi_1045;
			word32 eax_202 = eax_187 + 0x1C + (ecx_198 + eax_173);
			struct Eq_70587 * esp_196 = (word32) esp_39 + 16;
			struct Eq_70587 * edx_206 = (word32) esp_39 + 16 - (eax_202 & ~0x0FFF);
			Eq_2 edx_209 = ebp_1011->tFFFFFE54;
			if ((word32) esp_39 + 16 != edx_206)
			{
				do
				{
					esp_196 -= 0x1000;
					esp_196->dw0FFC = esp_196->dw0FFC;
				} while (esp_196 != edx_206);
			}
			int32 eax_224 = eax_202 & ~0x0F & 0x0FFF;
			if (eax_224 != 0x00)
			{
				esp_196 -= eax_224;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_196 - 0x04)[eax_224 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_196 - 0x04)[eax_224 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			ebp_1011->tFFFFFE54 = edx_209;
			struct Eq_70646 * esp_237 = esp_196 - 0x04;
			esp_237->tFFFFFFFC = ecx_198;
			esp_237->tFFFFFFF8 = esi_1045;
			Eq_70655 eax_236 = (char *) esp_196 + 0x0F;
			esp_237->tFFFFFFF4 = eax_236 & ~0x0F;
			word32 edx_1654;
			Eq_2 eax_264 = __mempcpy(esp_237->tFFFFFFF4, esp_237->tFFFFFFF8, esp_237->tFFFFFFFC, out edx_1654);
			Eq_2 edx_272 = ebp_1011->tFFFFFE54;
			esp_237->tFFFFFFFC = ebp_1011->tFFFFFE48;
			esp_237->tFFFFFFF8 = edx_272;
			esp_237->tFFFFFFF4 = eax_264;
			word32 edx_1655;
			Eq_2 eax_282 = __mempcpy(esp_237->tFFFFFFF4, esp_237->tFFFFFFF8, esp_237->tFFFFFFFC, out edx_1655);
			esp_237->tFFFFFFFC = ebp_1011->tFFFFFE4C;
			esp_237->tFFFFFFF8 = ebp_1011->tFFFFFE50;
			esp_237->tFFFFFFF4 = eax_282;
			word32 edx_1657;
			word32 ecx_1656;
			memcpy(esp_237->tFFFFFFF4, esp_237->tFFFFFFF8, esp_237->tFFFFFFFC, out ecx_1656, out edx_1657);
			esi_1045 = eax_236 & ~0x0F;
			edx_159 = ebp_1011->tFFFFFE54;
			esp_158 = (char *) &esp_237->tFFFFFFFC + 8;
		}
		struct Eq_70607 * esp_312 = esp_158 - 0x0C;
		esp_312->tFFFFFFFC = edx_159;
		word32 edx_1653;
		word32 ecx_1652;
		free(gs, esp_312->tFFFFFFF8, esp_312->tFFFFFFFC, out ecx_1652, out edx_1653);
		esp_334 = (char *) &esp_312->tFFFFFFFC + 16;
	}
	Eq_2 esp_1001;
	struct Eq_68805 * eax_338 = ebp_1011->ptrFFFFFE40;
	if (eax_338->t1A10 != 0x00)
	{
		Eq_2 eax_590 = eax_338->t1A00;
		ebp_1011->tFFFFFE48 = eax_590;
		if (eax_590 == 0x00)
			goto l0806FE3E;
		goto l0806FC9C;
	}
	struct Eq_68805 * edi_343 = ebp_1011->ptrFFFFFE40;
	struct Eq_68870 * esp_345 = esp_334 - 0x08;
	esp_345->tFFFFFFFC.u0 = 0x00088000;
	edi_343->t1A10 = &edi_343->t1A00;
	esp_345->tFFFFFFF8 = (char *) edi_343 - 163516;
	word32 ecx_1608;
	word32 edx_1609;
	Eq_2 eax_355 = __open_nocancel(gs, esp_345->tFFFFFFF8, esp_345->tFFFFFFFC, esp_345->t0000, out ecx_1608, out edx_1609);
	ebp_1011->tFFFFFE2C = eax_355;
	if (eax_355 < 0x00)
		goto l0806FE3E;
	esp_345->t0000 = &edi_343->dw19A0;
	esp_345->tFFFFFFFC = eax_355;
	esp_345->tFFFFFFF8.u0 = 0x03;
	esp_1001 = (char *) &esp_345->t0000 + 8;
	word32 ecx_1612;
	word32 edx_1613;
	if (__fxstat64(gs, esp_345->tFFFFFFFC, esp_345->t0000, out ecx_1612, out edx_1613) != ~0x00)
	{
		struct Eq_68805 * ecx_387 = ebp_1011->ptrFFFFFE40;
		Eq_2 edi_391 = ecx_387->t19CC;
		if (0x00 - ecx_387->dw19D0 - (word32) (edi_391 > 0x00200000) < 0x00)
			edi_391.u0 = 0x00200000;
		esp_345->t0000.u0 = 0x00;
		esp_345->tFFFFFFFC.u0 = 0x00;
		esp_345->tFFFFFFF8 = ebp_1011->tFFFFFE2C;
		esp_345->tFFFFFFF4.u0 = 0x02;
		esp_345->dwFFFFFFF0 = 0x01;
		esp_345->tFFFFFFEC = edi_391;
		esp_345->dwFFFFFFE8 = 0x00;
		Eq_2 eax_419 = mmap64(gs, esp_345->dwFFFFFFE8, esp_345->tFFFFFFEC, esp_345->dwFFFFFFF0, esp_345->tFFFFFFF4, esp_345->tFFFFFFF8, esp_345->tFFFFFFFC, esp_345->t0000);
		ebp_1011->tFFFFFE48 = eax_419;
		esp_1001 = (char *) &esp_345->t0000 + 8;
		if (eax_419 != ~0x00)
		{
			Eq_2 edx_434 = (word32) *((word32) eax_419 + 8) + *((word32) eax_419 + 16) * 0x0C;
			Eq_2 eax_436 = (word32) *((word32) eax_419 + 32) + *((word32) eax_419 + 36) *s 0x6C;
			if (edx_434 >= eax_436)
				eax_436 = edx_434;
			word32 edx_443 = Mem428[eax_419 + 0x18:word32] + Mem428[eax_419 + 0x14:word32];
			if (eax_436 >= edx_443)
				edx_443 = eax_436;
			if (edi_391 >= edx_443)
			{
				struct Eq_68805 * eax_564 = ebp_1011->ptrFFFFFE40;
				if (0x00 - eax_564->dw19D0 - (word32) (edi_391 < eax_564->t19CC) < 0x00)
				{
					Eq_2 edx_587 = ebp_1011->tFFFFFE48;
					eax_564->t1A08 = edi_391;
					eax_564->t1A00 = edx_587;
					goto l0806FCA6;
				}
				esp_345->tFFFFFFF8 = ebp_1011->tFFFFFE2C;
				word32 edx_1620;
				__close_nocancel(gs, esp_345->tFFFFFFF8, out edx_1620);
				struct Eq_68805 * eax_581 = ebp_1011->ptrFFFFFE40;
				eax_581->t1A00 = ebp_1011->tFFFFFE48;
				eax_581->t1A08 = edi_391;
l0806FC9C:
				ebp_1011->tFFFFFE2C.u0 = ~0x00;
				goto l0806FCA6;
			}
			ebp_1011->tFFFFFE54 = edx_443;
			esp_345->tFFFFFFFC = edi_391;
			esp_345->tFFFFFFF8 = eax_419;
			word32 ebx_1619;
			word32 edx_1618;
			word32 ecx_1617;
			__munmap(0x00, gs, esp_345->tFFFFFFF8, esp_345->tFFFFFFFC, out ecx_1617, out edx_1618, out ebx_1619);
			struct Eq_68805 * edi_478 = ebp_1011->ptrFFFFFE40;
			Eq_2 edx_480 = ebp_1011->tFFFFFE54;
			esp_1001 = (char *) &esp_345->t0000 + 8;
			if (edi_478->dw19D0 - (word32) (edi_478->t19CC < edx_480) >= 0x00)
			{
				Eq_10314 eax_487 = ebp_1011->tFFFFFE44;
				esp_345->t0000.u0 = 0x00;
				esp_345->tFFFFFFFC.u0 = 0x00;
				esp_345->tFFFFFFF8 = ebp_1011->tFFFFFE2C;
				esp_345->tFFFFFFF4.u0 = 0x02;
				esp_345->dwFFFFFFF0 = 0x01;
				Eq_2 ebx_495 = (word32) edx_480 + (eax_487 - 0x01) & -eax_487;
				esp_345->tFFFFFFEC = ebx_495;
				esp_345->dwFFFFFFE8 = 0x00;
				Eq_2 eax_509 = mmap64(gs, esp_345->dwFFFFFFE8, esp_345->tFFFFFFEC, esp_345->dwFFFFFFF0, esp_345->tFFFFFFF4, esp_345->tFFFFFFF8, esp_345->tFFFFFFFC, esp_345->t0000);
				ebp_1011->tFFFFFE48 = eax_509;
				esp_1001 = (char *) &esp_345->t0000 + 8;
				if (eax_509 != ~0x00)
				{
					if (0x00 - edi_478->dw19D0 - (word32) (ebx_495 < edi_478->t19CC) >= 0x00)
					{
						esp_345->tFFFFFFF8 = ebp_1011->tFFFFFE2C;
						word32 edx_1623;
						__close_nocancel(gs, esp_345->tFFFFFFF8, out edx_1623);
						struct Eq_68805 * eax_539 = ebp_1011->ptrFFFFFE40;
						Eq_2 ecx_540 = ebp_1011->tFFFFFE48;
						eax_539->t1A00 = ecx_540;
						eax_539->t1A08 = ebx_495;
						if (ecx_540 == 0x00)
						{
							eax_1245.u0 = 0x00;
l0806FC3D:
							if ((ebp_1011->tFFFFFFE4 ^ gs->t0014) == 0x00)
							{
								struct Eq_68964 * esp_1448 = ebp_1011 - 0x0C;
								Eq_2 esi_1451 = esp_1448->t0004;
								struct Eq_66740 * ebp_1455 = esp_1448->ptr000C;
								ebxOut = esp_1448->t0000;
								ebpOut = ebp_1455;
								esiOut = esi_1451;
								return eax_1245;
							}
							goto l0807070C;
						}
						goto l0806FC9C;
					}
					struct Eq_68805 * eax_550 = ebp_1011->ptrFFFFFE40;
					Eq_2 ecx_551 = ebp_1011->tFFFFFE48;
					eax_550->t1A08 = ebx_495;
					eax_550->t1A00 = ecx_551;
					if (ecx_551 != 0x00)
					{
l0806FCA6:
						struct Eq_69407 * esp_599 = esp_334 - 0x0C;
						esp_599->tFFFFFFFC = esi_1045;
						word32 ecx_1621;
						word32 edx_1622;
						Eq_2 eax_605 = strlen(esp_599->tFFFFFFFC, out ecx_1621, out edx_1622);
						esp_1001 = (char *) &esp_599->tFFFFFFFC + 16;
						Eq_2 edi_613 = eax_605;
						if (eax_605 != 0x00)
						{
							Eq_2 eax_618 = esi_1045;
							word32 edx_619 = esi_1045 + eax_605;
							do
							{
								eax_618 = (word32) eax_618 + 1;
								edi_613 = (word32) __rol(edi_613, 0x09) + (word32) (*eax_618);
							} while (edx_619 != eax_618);
							if (edi_613 == 0x00)
								edi_613.u0 = ~0x00;
						}
						else
							edi_613.u0 = ~0x00;
						Eq_2 eax_641 = ebp_1011->tFFFFFE48;
						Eq_2 ebx_643 = *((word32) eax_641 + 16);
						ebp_1011->tFFFFFE34 = *((word32) eax_641 + 8);
						if (ebx_643 == 0x00)
						{
l0806FE30:
							if (ebp_1011->tFFFFFE2C < 0x00)
								goto l0806FE3E;
							goto l0806FEF0;
						}
						ebp_1011->tFFFFFE50 = ebx_643;
						ebp_1011->tFFFFFE3C = esi_1045;
						uint32 edx_665 = (uint32) ((uint64) edi_613 % (ebx_643 - 0x02));
						Eq_2 edi_669 = ebp_1011->tFFFFFE50;
						ebp_1011->tFFFFFE54 = edx_665 + 0x01 + (edx_665 + 0x01) * 0x02 << 0x02;
						esi_1045 = (uint32) ((uint64) edi_613 % ebx_643);
						Eq_2 edx_1459 = edx_665 + 0x01;
						while (true)
						{
							struct Eq_69141 * ebx_683 = (word32) ebp_1011->tFFFFFE48 + ((word32) ebp_1011->tFFFFFE34 + esi_1045 * 0x0C);
							Eq_2 ecx_687 = edi_669;
							do
							{
								esp_1001 = esp_334;
								word32 eax_690 = ebx_683->dw0004;
								if (eax_690 == 0x00)
									goto l0806FE30;
								if (ebx_683->t0000 == edi_613)
								{
									Eq_2 eax_700 = (word32) ebp_1011->tFFFFFE48 + eax_690;
									ebp_1011->tFFFFFE4C = edx_1459;
									struct Eq_69204 * esp_698 = esp_334 - 0x08;
									esp_698->tFFFFFFFC = eax_700;
									esp_698->tFFFFFFF8 = ebp_1011->tFFFFFE3C;
									ebp_1011->tFFFFFE50 = ecx_687;
									word32 ecx_1615;
									word32 edx_1616;
									Eq_2 eax_711 = strcmp(esp_698->tFFFFFFF8, esp_698->tFFFFFFFC, out ecx_1615, out edx_1616);
									esp_1001 = &esp_698->ptr0004 + 1;
									ecx_687 = ebp_1011->tFFFFFE50;
									edx_1459 = ebp_1011->tFFFFFE4C;
									if (eax_711 == 0x00)
									{
										esi_1045 = ebx_683->t0008;
										ebp_1011->tFFFFFE50 = eax_711;
										if (esi_1045 == 0x00)
											goto l0806FE30;
										Eq_151242 esi_746[] = esi_1045 + Mem742[ebp_1011 + -440:word32];
										ui32 ecx_1393 = 0x00;
										Eq_2 edi_1391 = 0x00;
l0806FDFD:
										ebp_1011->tFFFFFE54 = (word32) edi_1391 + 1;
										ui32 eax_756 = ecx_1393 + 0x01;
										if (ecx_1393 == 0x06)
										{
											ebp_1011->tFFFFFE54 = edi_1391;
l0806FDF5:
											edi_1391 = ebp_1011->tFFFFFE54;
											ecx_1393 = eax_756;
											goto l0806FDFD;
										}
										(ebp_1011 - 220)[edi_1391 * 0x10] = (esi_746 - 0x04)[eax_756 * 0x08];
										word32 ebx_764 = esi_746[eax_756].dw0000;
										(ebp_1011 - 212)[edi_1391].dw0000 = ecx_1393;
										(ebp_1011 - 0xD8)[edi_1391].dw0000 = ebx_764;
										(ebp_1011 - 0xD0)[edi_1391].dw0000 = 0x00;
										if (eax_756 != 0x0D)
											goto l0806FDF5;
										struct Eq_68805 * esi_770 = ebp_1011->ptrFFFFFE40;
										ebp_1011->tFFFFFE4C = edi_1391;
										esp_698->ptr0004 = (char *) esi_770 - 386160;
										esp_698->dw0000 = 0x10;
										esp_698->tFFFFFFFC = (word32) edi_1391 + 1;
										esp_698->tFFFFFFF8 = ebp_1011 - 220;
										ebp_1011->tFFFFFE3C = ebp_1011 - 220;
										qsort();
										Eq_10314 ecx_790 = ebp_1011->tFFFFFE44;
										Eq_2 edi_791 = esi_770->t1A10;
										ebp_1011->tFFFFFE48 = edi_791;
										ebp_1011->tFFFFFE34 = ecx_790 - 0x01;
										ebp_1011->dwFFFFFE20 = ecx_790 - 0x01 & ecx_790;
										ebp_1011->tFFFFFE30 = edi_791;
										esp_1001 = &esp_698->ptr0004 + 1;
										Eq_2 edi_1014 = ebp_1011->tFFFFFE50;
										do
										{
											Eq_2 ebx_1083;
											Eq_2 esi_804 = ebp_1011->tFFFFFE30;
											if (esi_804 != 0x00)
											{
												Eq_2 eax_815 = *((word32) esi_804 + 4);
												Eq_2 ecx_817 = (ebp_1011 - 0xD8)[edi_1014].t0000;
												Eq_2 ebx_818 = (ebp_1011 - 220)[edi_1014].t0000;
												Eq_2 edx_819 = *((word32) esi_804 + 8);
												ebp_1011->tFFFFFE54 = ecx_817;
												word32 ecx_821 = ecx_817 + ebx_818;
												if (ecx_821 >=u edx_819 + eax_815)
												{
													ebp_1011->tFFFFFE50 = ebx_818;
													Eq_2 edx_833 = ebp_1011->tFFFFFE30;
													while (true)
													{
														esi_1045 = *((word32) edx_833 + 0x0C);
														if (esi_1045 == 0x00)
															break;
														eax_815 = *((byte) esi_1045.u0 + 4);
														if (Mem832[esi_1045 + 0x08:word32] + eax_815 >u ecx_821)
														{
															ebx_818 = ebp_1011->tFFFFFE50;
															ebp_1011->tFFFFFE30 = edx_833;
															if (eax_815 <= ebx_818)
																goto l080702F4;
															goto l0807021F;
														}
														edx_833 = esi_1045;
													}
													ebp_1011->tFFFFFE30 = edx_833;
													goto l0807021F;
												}
												esi_1045 = ebp_1011->tFFFFFE30;
												if (ebx_818 >= eax_815)
												{
													ebp_1011->tFFFFFE30 = ebp_1011->tFFFFFE48;
l080702F4:
													ui32 edx_862 = (ebp_1011 - 212)[edi_1014].dw0000;
													(ebp_1011 - 0x0144)[edx_862].dw0000 = (word32) *esi_1045.u0 + (ebx_818 - eax_815);
													(ebp_1011 - 0x0140)[edx_862].t0000 = ebp_1011->tFFFFFE54;
													Eq_2 eax_870 = ebp_1011->tFFFFFE30;
													ebp_1011->tFFFFFE30 = esi_1045;
													ebp_1011->tFFFFFE48 = eax_870;
													ebx_1083 = edi_1014;
													edi_1014 = (word32) edi_1014 + 1;
													goto l08070331;
												}
												ebp_1011->tFFFFFE30 = ebp_1011->tFFFFFE48;
											}
											else
											{
												ebp_1011->tFFFFFE30 = ebp_1011->tFFFFFE48;
												esi_1045.u0 = 0x00;
											}
l0807021F:
											if (ebp_1011->dwFFFFFE20 != 0x00)
											{
												struct Eq_68805 * ecx_881 = ebp_1011->ptrFFFFFE40;
												struct Eq_69746 * esp_886 = esp_1001 - 4;
												esp_886->ptr0000 = (char *) ecx_881 - 0x00027EDC;
												esp_886->dwFFFFFFFC = 0x0178;
												esp_886->ptrFFFFFFF8 = (char *) ecx_881 - 163669;
												esp_886->ptrFFFFFFF4 = (char *) ecx_881 - 163655;
												word32 edx_1625;
												word32 ecx_1624;
												__assert_fail(out ecx_1624, out edx_1625);
l0807070C:
												word32 ecx_1610;
												word32 edx_1611;
												eax_1172 = __stack_chk_fail(out ecx_1610, out edx_1611);
												esp_1181.u0 = <invalid>;
												goto l08070711;
											}
											ebp_1011->tFFFFFE24 = edi_1014;
											Eq_2 ecx_908 = (ebp_1011 - 220)[edi_1014].t0000;
											Eq_2 eax_911 = -ebp_1011->tFFFFFE44;
											ebp_1011->tFFFFFE28 = ecx_908;
											ebp_1011->tFFFFFE54 = eax_911;
											ebp_1011->tFFFFFE50 = ebp_1011->ptrFFFFFE40->t19CC;
											ebp_1011->tFFFFFE48 = ebp_1011 - 0xD8;
											Eq_2 edx_1348 = edi_1014;
											while (true)
											{
												word32 eax_928 = Mem919[ebp_1011 + -440:word32][edx_1348 * 0x10] + ecx_908;
												if (ebp_1011->tFFFFFE50 < eax_928)
													goto l0806FE30;
												word32 eax_932 = eax_928 + Mem919[ebp_1011 + -0x01CC:word32] & Mem919[ebp_1011 + -428:word32];
												if (esi_1045 != 0x00 && *((byte) esi_1045.u0 + 4) <= ecx_908)
													break;
												Eq_2 edi_943 = (word32) edx_1348 + 1;
												if (edx_1348 >= ebp_1011->tFFFFFE4C)
												{
l0807042F:
													ebp_1011->tFFFFFE50 = edi_943;
													goto l0807043D;
												}
												ecx_908 = *((word32) ebp_1011->tFFFFFE3C + (edx_1348 * 0x10 + 16));
												if (ecx_908 >=u Mem919[ebp_1011 + -444:word32] + eax_932)
													goto l0807042F;
												edx_1348 = edi_943;
											}
											ebp_1011->tFFFFFE50 = edx_1348;
l0807043D:
											ebx_1083 = eax_932;
											if (ebp_1011->tFFFFFE2C == ~0x00)
											{
l08070570:
												struct Eq_68805 * eax_1270 = ebp_1011->ptrFFFFFE40;
												struct Eq_70059 * esp_1276 = esp_1001 - 0x08;
												esp_1276->tFFFFFFFC.u0 = 0x00088000;
												esp_1276->tFFFFFFF8 = (char *) eax_1270 - 163516;
												word32 ecx_1634;
												word32 edx_1635;
												Eq_2 eax_1288 = __open_nocancel(gs, esp_1276->tFFFFFFF8, esp_1276->tFFFFFFFC, esp_1276->t0000, out ecx_1634, out edx_1635);
												ebp_1011->tFFFFFE2C = eax_1288;
												if (eax_1288 != ~0x00)
												{
													esp_1276->t0000 = ebp_1011 - 0x01A4;
													esp_1276->tFFFFFFFC = ebp_1011->tFFFFFE2C;
													esp_1276->tFFFFFFF8.u0 = 0x03;
													esp_1001 = (char *) &esp_1276->t0000 + 8;
													word32 edx_1646;
													word32 ecx_1645;
													if (__fxstat64(gs, esp_1276->tFFFFFFFC, esp_1276->t0000, out ecx_1645, out edx_1646) < 0x00)
														goto l0806FE30;
													struct Eq_68805 * ecx_1320 = ebp_1011->ptrFFFFFE40;
													if ((ebp_1011->dwFFFFFE8C ^ ecx_1320->dw19D0 | ebp_1011->dwFFFFFE88 ^ ecx_1320->t19CC) != 0x00 || (ebp_1011->dwFFFFFEA4 != ecx_1320->dw19E8 || ((ebp_1011->dwFFFFFE60 ^ ecx_1320->dw19A4 | ebp_1011->dwFFFFFE5C ^ ecx_1320->dw19A0) != 0x00 || (ebp_1011->dwFFFFFEB8 ^ ecx_1320->dw19FC | ebp_1011->dwFFFFFEB4 ^ ecx_1320->dw19F8) != 0x00)))
														goto l0806FE30;
													goto l0807044A;
												}
												goto l0806FE3E;
											}
l0807044A:
											Eq_2 ecx_969 = ebp_1011->tFFFFFE28 & ebp_1011->tFFFFFE54;
											struct Eq_70100 * esp_971 = esp_1001 - 0x04;
											esp_971->tFFFFFFFC.u0 = 0x00;
											esp_971->tFFFFFFF8 = ecx_969;
											esp_971->tFFFFFFF4 = ebp_1011->tFFFFFE2C;
											esp_971->tFFFFFFF0.u0 = 0x02;
											esp_971->dwFFFFFFEC = 0x01;
											Eq_2 ebx_974 = ebx_1083 - ecx_969;
											esp_971->tFFFFFFE8 = ebx_974;
											esp_971->dwFFFFFFE4 = 0x00;
											ebp_1011->tFFFFFE28 = ebx_974;
											ebp_1011->tFFFFFE24 = ecx_969;
											Eq_2 eax_994 = mmap64(gs, esp_971->dwFFFFFFE4, esp_971->tFFFFFFE8, esp_971->dwFFFFFFEC, esp_971->tFFFFFFF0, esp_971->tFFFFFFF4, esp_971->tFFFFFFF8, esp_971->tFFFFFFFC);
											ebp_1011->tFFFFFE54 = eax_994;
											esp_1001 = &esp_971->ptr0000 + 1;
											if (eax_994 == ~0x00)
												goto l0806FE30;
											esp_971->tFFFFFFF4.u0 = 0x10;
											word32 edx_1637;
											word32 ecx_1636;
											Eq_2 ebx_1012;
											Eq_2 esi_1016;
											Eq_2 eax_1010 = __libc_malloc(gs, esp_971->tFFFFFFF0, esp_971->tFFFFFFF4, out ecx_1636, out edx_1637, out ebx_1012, out ebp_1011, out esi_1016, out edi_1014);
											Eq_2 ecx_1022 = ebp_1011->tFFFFFE24;
											ebp_1011->tFFFFFE48 = eax_1010;
											esp_1001 = &esp_971->ptr0000 + 1;
											if (eax_1010 == 0x00)
											{
												esp_971->tFFFFFFF8 = ebp_1011->tFFFFFE28;
												esp_971->tFFFFFFF4 = ebp_1011->tFFFFFE54;
												word32 ebx_1640;
												word32 edx_1639;
												word32 ecx_1638;
												__munmap(ebx_1012, gs, esp_971->tFFFFFFF4, esp_971->tFFFFFFF8, out ecx_1638, out edx_1639, out ebx_1640);
												esp_1001 = &esp_971->ptr0000 + 1;
												esi_1045 = esi_1016;
												goto l0806FE30;
											}
											Eq_2 eax_1046 = ebp_1011->tFFFFFE48;
											*eax_1046 = ebp_1011->tFFFFFE54;
											Eq_2 edx_1049 = ebp_1011->tFFFFFE28;
											*((word32) eax_1046 + 4) = ecx_1022;
											*((word32) eax_1046 + 8) = edx_1049;
											if (*((word32) ebp_1011->tFFFFFE30 + 0x0C) != esi_1016)
											{
												struct Eq_68805 * ecx_1055 = ebp_1011->ptrFFFFFE40;
												esp_971->ptr0000 = (char *) ecx_1055 - 0x00027EDC;
												esp_971->tFFFFFFFC.u0 = 434;
												esp_971->tFFFFFFF8 = (char *) ecx_1055 - 163669;
												esp_971->tFFFFFFF4 = (char *) ecx_1055 - 163641;
												word32 edx_1642;
												word32 ecx_1641;
												__assert_fail(out ecx_1641, out edx_1642);
												Eq_2 eax_1074 = _nl_postload_ctype(gs);
												ebxOut = ebx_1012;
												ebpOut = ebp_1011;
												esiOut = esi_1016;
												return eax_1074;
											}
											Eq_2 edx_1081 = ebp_1011->tFFFFFE30;
											Eq_2 eax_1082 = ebp_1011->tFFFFFE48;
											ebp_1011->tFFFFFE30 = esi_1016;
											*((word32) eax_1082 + 0x0C) = esi_1016;
											*((word32) edx_1081 + 0x0C) = eax_1082;
											ebx_1083 = edi_1014;
											struct Eq_70305 * edx_1089 = (word32) ebp_1011->tFFFFFE3C + (edi_1014 << 0x04);
											while (true)
											{
												Eq_2 eax_1093 = edx_1089->dw0000;
												if (eax_1093 < ecx_1022)
												{
													struct Eq_68805 * ecx_1247 = ebp_1011->ptrFFFFFE40;
													esp_971->ptr0000 = (char *) ecx_1247 - 0x00027EDC;
													esp_971->tFFFFFFFC.u0 = 442;
													esp_971->tFFFFFFF8 = (char *) ecx_1247 - 163669;
													esp_971->tFFFFFFF4 = (char *) ecx_1247 - 0x00027F24;
													word32 edx_1644;
													word32 ecx_1643;
													__assert_fail(out ecx_1643, out edx_1644);
													esp_1001.u0 = <invalid>;
													esi_1045 = esi_1016;
													goto l08070570;
												}
												esi_1016 = edx_1089->dw0008;
												(ebp_1011 - 0x0144)[esi_1016].dw0000 = (word32) ebp_1011->tFFFFFE54 + (eax_1093 - ecx_1022);
												++edx_1089;
												(ebp_1011 - 0x0140)[esi_1016].dw0000 = edx_1089->dwFFFFFFF4;
												edi_1014 = (word32) edi_1014 + 1;
												if (ebp_1011->tFFFFFE50 <= edi_1014)
													break;
												ebx_1083 = edi_1014;
											}
l08070331:
										} while (ebx_1083 < ebp_1011->tFFFFFE4C);
										if (ebp_1011->tFFFFFE2C >= 0x00)
										{
											struct Eq_69867 * esp_1122 = esp_1001 - 0x0C;
											esp_1122->tFFFFFFFC = ebp_1011->tFFFFFE2C;
											word32 edx_1631;
											__close_nocancel(gs, esp_1122->tFFFFFFFC, out edx_1631);
										}
										struct Eq_69838 * esp_1142 = esp_1001 - 0x0C;
										esp_1142->tFFFFFFFC.u0 = 0x3C;
										word32 ecx_1626;
										word32 edx_1627;
										word32 ebx_1628;
										word32 edi_1630;
										word32 esi_1629;
										Eq_2 eax_1150 = __libc_malloc(gs, esp_1142->tFFFFFFF8, esp_1142->tFFFFFFFC, out ecx_1626, out edx_1627, out ebx_1628, out ebp_1011, out esi_1629, out edi_1630);
										esi_1045 = eax_1150;
										if (eax_1150 == 0x00)
										{
l0806FE3E:
											eax_1245.u0 = 0x00;
											goto l0806FC3D;
										}
										esp_1142->tFFFFFFFC = ebp_1011->ptrFFFFFE38->t0000;
										eax_1172 = strdup(esp_1142->tFFFFFFFC);
										*((word32) eax_1150 + 4) = eax_1172;
										esp_1181 = (char *) &esp_1142->tFFFFFFFC + 16;
										if (eax_1172 == 0x00)
										{
l08070711:
											ebp_1011->tFFFFFE54 = eax_1172;
											struct Eq_69918 * esp_1420 = esp_1181 - 0x0C;
											esp_1420->tFFFFFFFC = esi_1045;
											word32 ecx_1632;
											word32 edx_1633;
											free(gs, esp_1420->tFFFFFFF8, esp_1420->tFFFFFFFC, out ecx_1632, out edx_1633);
											eax_1245 = ebp_1011->tFFFFFE54;
											goto l0806FC3D;
										}
										struct Eq_68805 * edx_1186 = ebp_1011->ptrFFFFFE40;
										Eq_2 eax_1191 = edx_1186->t1980;
										edx_1186->t1980 = eax_1150;
										*eax_1150 = eax_1191;
										Eq_2 ebx_1187 = 0x00;
										struct Eq_69955 * edi_1190 = ebp_1011 - 0x0144;
										while (true)
										{
											if (ebx_1187 != 0x06)
											{
												struct Eq_69992 * esp_1198 = esp_1181 - 0x04;
												esp_1198->tFFFFFFFC = edi_1190->a0004[ebx_1187 * 2];
												esp_1198->tFFFFFFF8 = edi_1190[ebx_1187 * 2];
												esp_1198->tFFFFFFF4 = ebx_1187;
												Eq_2 eax_1211 = _nl_intern_locale_data(gs, esp_1198->tFFFFFFF4, esp_1198->tFFFFFFF8, esp_1198->tFFFFFFFC, out ebx_1187, out ebp_1011, out esi_1045, out edi_1190);
												*((byte) esi_1045.u0 + (ebx_1187 * 0x04 + 8)) = eax_1211;
												Eq_2 esp_1217 = <invalid>;
												esp_1181 = (word32) esp_1217 + 16;
												if (eax_1211 != 0x00)
												{
													Eq_2 edx_1228 = *((byte) esi_1045.u0 + 4);
													((word32) eax_1211 + 0x0C)->u0 = 0x02;
													((word32) eax_1211 + 24)->u0 = ~0x00;
													*eax_1211 = edx_1228;
												}
												if (ebx_1187 == 0x0C)
												{
													ebp_1011->ptrFFFFFE38->t0000 = *((byte) esi_1045.u0 + 4);
													eax_1245 = *((byte) esi_1045.u0 + (ebp_1011->t0008 * 0x04 + 8));
													goto l0806FC3D;
												}
											}
											ebx_1187 = (word32) ebx_1187 + 1;
										}
									}
								}
								esi_1045 += edx_1459;
								ebx_683 += Mem730[ebp_1011 + -428:word32];
							} while (ecx_687 > esi_1045);
							esi_1045 -= ecx_687;
							edi_669 = ecx_687;
						}
					}
				}
			}
		}
	}
l0806FEF0:
	struct Eq_69006 * esp_1359 = esp_1001 - 0x0C;
	esp_1359->tFFFFFFFC = ebp_1011->tFFFFFE2C;
	word32 edx_1614;
	__close_nocancel(gs, esp_1359->tFFFFFFFC, out edx_1614);
	eax_1245.u0 = 0x00;
	goto l0806FC3D;
}

// 08070760: Register ptr32 _nl_postload_ctype(Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_load_locale_from_archive
ptr32 _nl_postload_ctype(struct Eq_9 * gs)
{
	struct Eq_70762 * ecx_15 = g_ptr80CEE60;
	word32 edi_17 = ecx_15->dw0024;
	word32 edx_18 = ecx_15->dw0030;
	word32 ecx_19 = ecx_15->dw0028;
	g_dw80CEE94 = edi_17 + 0x0100;
	g_dw80CEE98 = edx_18 + 0x0200;
	g_dw80CEE9C = ecx_19 + 0x0200;
	if (gs->ptrFFFFFFD4 != &g_ptr80CEE60)
		return 0x080CE000;
	gs->ptrFFFFFFF8 = edi_17 + 0x0100;
	gs->dwFFFFFFF4 = ecx_19 + 0x0200;
	gs->ptrFFFFFFF0 = edx_18 + 0x0200;
	return ~0x0F;
}

// 080707E0: FlagGroup Eq_43241 __current_locale_name(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 eaxOut)
// Called from:
//      __dcigettext
Eq_43241 __current_locale_name(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & eaxOut)
{
	eaxOut = gs->ptrFFFFFFD4->a0040[dwArg04];
	return <invalid>;
}

// 08070800: void __ctype_b_loc()
void __ctype_b_loc()
{
}

// 08070820: void __ctype_toupper_loc()
void __ctype_toupper_loc()
{
}

// 08070840: void __ctype_tolower_loc()
void __ctype_tolower_loc()
{
}

// 08070860: Register word32 __ctype_init(Register (ptr32 Eq_9) gs, Register out Eq_2 edxOut)
// Called from:
//      __libc_init_first
word32 __ctype_init(struct Eq_9 * gs, union Eq_2 & edxOut)
{
	Eq_2 edx_13 = gs->ptrFFFFFFD0->t0000;
	gs->ptrFFFFFFF8 = (word32) *((word32) edx_13 + 36) + 0x0100;
	gs->dwFFFFFFF4 = (word32) *((word32) edx_13 + 40) + 0x0200;
	gs->ptrFFFFFFF0 = (word32) *((word32) edx_13 + 48) + 0x0200;
	edxOut = edx_13;
	return ~0x0F;
}

// 080708C0: Register word32 __setfpucw(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
// Called from:
//      __libc_init_first
word32 __setfpucw(struct Eq_9 * gs, word32 dwArg04)
{
	Eq_2175 ebx_11 = gs->t0014;
	word32 edx_16 = (word32) __fstcw();
	word32 ebx_25 = SEQ(SLICE(dwArg04, word16, 16), (word16) dwArg04 & 0x0F3F);
	__fldcw((word16) edx_16 & 0xF0C0 | (word16) dwArg04 & 0x0F3F);
	if ((ebx_11 ^ gs->t0014) == 0x00)
		return ebx;
	word32 ecx_104;
	word32 edx_105;
	__stack_chk_fail(out ecx_104, out edx_105);
	raise(gs, dwArg04);
	return ebx_25;
}

// 08070960: void raise(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
// Called from:
//      abort
//      __setfpucw
void raise(struct Eq_9 * gs, word32 dwArg04)
{
	word32 ecx_122;
	word32 * esi_116 = &g_dw80B1B80;
	Eq_2175 edi_24 = gs->t0014;
	word32 * edi_121 = fp - 0xA0;
	for (ecx_122 = 0x20; ecx_122 != 0x00; --ecx_122)
	{
		*edi_121 = *esi_116;
		++esi_116;
		++edi_121;
	}
	gs->ptr0010();
	gs->ptr0010();
	word32 eax_54;
	gs->ptr0010();
	struct Eq_224 * eax_61;
	gs->ptr0010();
	if (eax_61 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_150;
		__syscall_error(eax_61, gs, out edx_150);
	}
	gs->ptr0010();
	if ((edi_24 ^ gs->t0014) == 0x00)
		return;
	word32 edx_152;
	word32 ecx_151;
	__stack_chk_fail(out ecx_151, out edx_152);
	__syscall(0x80);
	__syscall(0x80);
}

// 08070A70: Register (ptr32 Eq_224) __libc_sigaction(Register (ptr32 Eq_9) gs, Stack up32 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      raise
//      __sigaction
struct Eq_224 * __libc_sigaction(struct Eq_9 * gs, up32 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2175 eax_27 = gs->t0014;
	if (dwArg08 != 0x00)
	{
		word32 * esi_195 = (word32) dwArg08 + 4;
		word32 ecx_200 = 0x20;
		word32 * edi_199 = fp - 300;
		word32 eax_41 = *((word32) dwArg08 + 0x0084);
		while (true)
		{
			byte al_55 = (byte) eax_41;
			if (ecx_200 == 0x00)
				break;
			*edi_199 = *esi_195;
			++esi_195;
			++edi_199;
			--ecx_200;
		}
	}
	struct Eq_224 * eax_106;
	gs->ptr0010();
	if (eax_106 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_350;
		eax_106 = __syscall_error(eax_106, gs, out edx_350);
	}
	if (dwArg0C != 0x00 && eax_106 >= null)
	{
		*dwArg0C = dwLocAC;
		word32 edi_131 = dwArg0C + 0x08 & ~0x03;
		word32 ecx_135 = dwArg0C + 0x04 - edi_131;
		*((word32) dwArg0C + 4) = dwLocA0;
		*((word32) dwArg0C + 0x0080) = dwLoc24;
		word32 * esi_136 = fp - 0xA0 - ecx_135;
		uint32 ecx_140;
		for (ecx_140 = ecx_135 - (struct Eq_71036 *) ~0x7F >> 0x02; ecx_140 != 0x00; --ecx_140)
		{
			edi_131->dw0000 = *esi_136;
			++esi_136;
			edi_131 += 4;
		}
		*((word32) dwArg0C + 0x0084) = dwLocA8;
		*((word32) dwArg0C + 0x0088) = dwLocA4;
	}
	if ((eax_27 ^ gs->t0014) == 0x00)
		return eax_106;
	word32 edx_352;
	word32 ecx_351;
	__stack_chk_fail(out ecx_351, out edx_352);
	return __sigaction(gs, dwArg04);
}

// 08070BE0: Register word32 __sigaction(Register (ptr32 Eq_9) gs, Stack up32 dwArg04)
// Called from:
//      abort
//      __libc_sigaction
//      profil
word32 __sigaction(struct Eq_9 * gs, up32 dwArg04)
{
	if (dwArg04 > 0x40 || dwArg04 <= 33)
	{
		gs->tFFFFFFE0.u0 = 22;
		return ~0x00;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		return __libc_sigaction(gs, dwArg04, stackArg8, stackArg12);
	}
}

// 08070C30: Register word32 sigprocmask(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      abort
//      __sigsetjmp
word32 sigprocmask(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	Eq_2175 eax_16 = gs->t0014;
	Eq_2 esi_19 = dwArg08;
	if (dwArg08 != 0x00 && (*dwArg08 < 0x00 || (*((word32) dwArg08 + 4) & 0x01) != 0x00))
	{
		word32 * edi_32 = fp - 0x90;
		word32 ecx_33;
		for (ecx_33 = 0x20; ecx_33 != 0x00; --ecx_33)
		{
			*edi_32 = (word32) *esi_19;
			esi_19 = (word32) esi_19 + 4;
			++edi_32;
		}
		dwLoc8C &= ~0x01;
	}
	word32 ecx_68;
	struct Eq_224 * eax_69;
	ptr32 edx_144;
	gs->ptr0010();
	if (eax_69 > (struct Eq_224 *) ~0x0FFF)
		__syscall_error(eax_69, gs, out edx_144);
	if ((eax_16 ^ gs->t0014) != 0x00)
	{
		word32 ecx_176;
		word32 edx_177;
		__stack_chk_fail(out ecx_176, out edx_177);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg20 = <invalid>;
		ptr32 edx_98;
		word32 ecx_96 = _quicksort(gs, dwArg04, dwArg08, dwArg0C, dwLoc8C, stackArg20, out edx_98);
		edxOut = edx_98;
		return ecx_96;
	}
	else
	{
		edxOut = edx_144;
		return ecx_68;
	}
}

// 08070CE0: Register Eq_2 _quicksort(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack (ptr32 code) dwArg10, Stack Eq_2 dwArg14, Register out Eq_2 edxOut)
// Called from:
//      qsort_r
//      sigprocmask
Eq_2 _quicksort(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, <anonymous> * dwArg10, Eq_2 dwArg14, union Eq_2 & edxOut)
{
	Eq_2175 edx_23 = gs->t0014;
	Eq_2 edx_1141 = 0x00;
	if (dwArg08 != 0x00)
	{
		Eq_2 edx_34 = (word32) dwArg04 + (dwArg08 - 0x01) *s dwArg0C;
		if (dwArg08 > 0x04)
		{
			struct Eq_71183 * eax_42 = -dwArg0C;
			Eq_2 dwLoc0148_662 = edx_34;
			struct Eq_71186 * dwLoc013C_664 = fp - 0x0118;
			Eq_2 dwLoc0144_665 = dwArg04;
			do
			{
				struct Eq_71334 * eax_65 = ((uint32) ((uint64) (dwLoc0148_662 - dwLoc0144_665) /u dwArg0C) >> 0x01) *s dwArg0C;
				word32 esi_72 = dwLoc0144_665 + eax_65;
				int32 eax_79;
				word32 ecx_81;
				dwArg10();
				if (eax_79 < 0x00)
				{
					Eq_2 edx_100 = dwLoc0144_665;
					Eq_2 eax_89 = esi_72;
					word32 ebx_90 = dwArg0C + esi_72;
					do
					{
						byte cl_103 = *eax_89;
						eax_89 = (word32) eax_89 + 1;
						*((word32) eax_89 - 1) = *edx_100;
						edx_100 = (word32) edx_100 + 1;
						*((word32) edx_100 - 1) = cl_103;
					} while (eax_89 != ebx_90);
				}
				int32 eax_129;
				word32 ecx_131;
				dwArg10();
				if (eax_129 < 0x00)
				{
					Eq_2 edx_138 = dwLoc0148_662;
					Eq_2 eax_139 = esi_72;
					word32 ebx_140 = dwArg0C + esi_72;
					do
					{
						byte cl_154 = *eax_139;
						eax_139 = (word32) eax_139 + 1;
						*((word32) eax_139 - 1) = *edx_138;
						++edx_138;
						*((word32) edx_138 - 1) = cl_154;
					} while (eax_139 != ebx_140);
					int32 eax_174;
					word32 ecx_176;
					dwArg10();
					if (eax_174 < 0x00)
					{
						Eq_2 edx_183 = dwLoc0144_665;
						Eq_2 eax_184 = esi_72;
						do
						{
							byte cl_194 = *eax_184;
							eax_184 = (word32) eax_184 + 1;
							*((word32) eax_184 - 1) = *edx_183;
							++edx_183;
							*((word32) edx_183 - 1) = cl_194;
						} while (eax_184 != ebx_140);
					}
				}
				word32 dwLoc0158_713 = dwLoc0144_665 + dwArg0C;
				word32 ebx_205 = dwLoc0148_662 + eax_42;
				Eq_2 esi_209 = esi_72;
				do
				{
					while (true)
					{
						int32 eax_226;
						word32 ecx_228;
						dwArg10();
						if (eax_226 >= 0x00)
							break;
						dwLoc0158_713 += dwArg0C;
					}
					while (true)
					{
						int32 eax_249;
						word32 ecx_251;
						dwArg10();
						if (eax_249 >= 0x00)
							break;
						ebx_205 += eax_42;
					}
					if (dwLoc0158_713 >= ebx_205)
					{
						if (dwLoc0158_713 == ebx_205)
						{
							ebx_205 += eax_42;
							dwLoc0158_713 += dwArg0C;
							break;
						}
					}
					else
					{
						Eq_2 eax_261 = dwLoc0158_713;
						Eq_2 edx_264 = ebx_205;
						word32 ecx_265 = dwArg0C + dwLoc0158_713;
						do
						{
							byte cl_279 = *eax_261;
							eax_261 = (word32) eax_261 + 1;
							*((word32) eax_261 - 1) = *edx_264;
							++edx_264;
							*((word32) edx_264 - 1) = cl_279;
						} while (eax_261 != ecx_265);
						if (dwLoc0158_713 != esi_209)
						{
							if (ebx_205 == esi_209)
								esi_209 = dwLoc0158_713;
						}
						else
							esi_209 = ebx_205;
						ebx_205 += eax_42;
						dwLoc0158_713 = ecx_265;
					}
				} while (dwLoc0158_713 <= ebx_205);
				struct Eq_71250 * edx_318 = ebx_205 - dwLoc0144_665;
				struct Eq_71250 * eax_319 = dwLoc0148_662 - dwLoc0158_713;
				if (edx_318 <= dwArg0C << 0x02)
				{
					dwLoc0144_665 = dwLoc0158_713;
					if (dwArg0C << 0x02 >= eax_319)
					{
						dwLoc0144_665 = dwLoc013C_664->dwFFFFFFF8;
						dwLoc013C_664 -= 0x08;
						dwLoc0148_662 = dwLoc013C_664->dwFFFFFFFC;
					}
				}
				else if (dwArg0C << 0x02 < eax_319)
				{
					if (edx_318 > eax_319)
					{
						dwLoc013C_664->dw0004 = (word32) ebx_205;
						dwLoc013C_664->dw0000 = (word32) dwLoc0144_665;
						++dwLoc013C_664;
						dwLoc0144_665 = dwLoc0158_713;
					}
					else
					{
						dwLoc013C_664->dw0000 = (word32) dwLoc0158_713;
						dwLoc013C_664->dw0004 = (word32) dwLoc0148_662;
						++dwLoc013C_664;
						dwLoc0148_662 = ebx_205;
					}
				}
				else
					dwLoc0148_662 = ebx_205;
			} while (dwLoc013C_664 > fp - 288);
		}
		Eq_2 ebx_360 = dwArg04;
		Eq_2 eax_363 = (word32) dwArg04 + (dwArg0C << 0x02);
		if (edx_34 < eax_363)
			eax_363 = edx_34;
		word32 edx_371 = dwArg04 + dwArg0C;
		Eq_2 esi_373 = edx_371;
		ecx = eax_363;
		edx_1141 = edx_371;
		if (eax_363 >= edx_371)
		{
			do
			{
				int32 eax_394;
				dwArg10();
				if (eax_394 < 0x00)
					ebx_360 = esi_373;
				esi_373 += dwArg0C;
			} while (eax_363 >= esi_373);
			Eq_2 eax_409 = dwArg04;
			if (ebx_360 != dwArg04)
			{
				word32 edx_414 = dwArg0C + ebx_360;
				do
				{
					ecx = (word32) *ebx_360;
					edx_1141 = (word32) *eax_409;
					++ebx_360;
					*((word32) ebx_360 - 1) = (byte) edx_1141;
					eax_409 = (word32) eax_409 + 1;
					*((word32) eax_409 - 1) = (byte) ecx;
				} while (ebx_360 != edx_414);
			}
		}
		struct Eq_71351 * ebx_461 = -dwArg0C;
		Eq_2 esi_464 = edx_371;
		while (true)
		{
			Eq_2 ecx_533;
			word32 eax_469 = dwArg0C + esi_464;
			if (eax_469 > edx_34)
				break;
			Eq_2 ebx_511 = esi_464;
			while (true)
			{
				int32 eax_531;
				dwArg10();
				if (eax_531 >= 0x00)
					break;
				ebx_511 += ebx_461;
			}
			esi_464 = ebx_511 + dwArg0C;
			ecx = ecx_533;
			if (eax_469 != esi_464)
			{
				word32 edi_549 = eax_469 + (dwArg0C - 0x01);
				ecx = ecx_533;
				if (edi_549 >= null)
				{
					ecx = ecx_533;
					do
					{
						byte al_560 = edi_549->b0000;
						struct Eq_71395 * edx_559 = edi_549;
						Eq_2 eax_565 = edi_549 - dwArg0C;
						if (esi_464 <= eax_565)
						{
							while (true)
							{
								edx_559->b0000 = (byte) *eax_565;
								ecx = eax_565 + ebx_461;
								edx_559 -= dwArg0C;
								if (esi_464 > ecx)
									break;
								eax_565 = ecx;
							}
							edx_1141 = (word32) al_560;
							*eax_565 = (byte) edx_1141;
							edi_549 -= (struct Eq_71433 *) 0x01;
							if (edi_549 == eax_469 - (struct Eq_71420 *) 0x01)
								break;
							continue;
						}
						edx_1141 = (word32) al_560;
						edi_549->b0000 = (byte) edx_1141;
						edi_549 -= (struct Eq_71418 *) 0x01;
					} while (edi_549 != eax_469 - (struct Eq_71420 *) 0x01);
				}
				esi_464 = eax_469;
			}
		}
	}
	if ((edx_23 ^ gs->t0014) != 0x00)
	{
		word32 ecx_1159;
		word32 edx_1160;
		__stack_chk_fail(out ecx_1159, out edx_1160);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg16 = <invalid>;
		Eq_2 edx_496;
		Eq_2 ecx_497 = __add_to_environ(gs, stackArg4, stackArg8, stackArg12, stackArg16, out edx_496);
		edxOut = edx_496;
		return ecx_497;
	}
	else
	{
		edxOut = edx_1141;
		return ecx;
	}
}

// 080711A0: Register ui32 __add_to_environ(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 edxOut)
// Called from:
//      _quicksort
//      __setenv
ui32 __add_to_environ(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & edxOut)
{
	Eq_2175 ecx_28 = gs->t0014;
	Eq_2 dwLoc3C_729 = dwArg0C;
	word32 edx_1146;
	word32 ecx_1145;
	Eq_2 eax_35 = strlen(dwArg04, out ecx_1145, out edx_1146);
	if (dwArg0C == 0x00)
	{
		word32 ecx_1147;
		word32 edx_1148;
		dwLoc4C = (word32) strlen(dwArg08, out ecx_1147, out edx_1148) + 1;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_75;
	if (!__cmpxchg(envlock, 0x01, 0x00, out eax_75))
		__lll_lock_wait_private(eax_75, 0x080CFA1C, gs);
	Eq_2 edx_1130;
	Eq_2 edx_136;
	word32 eax_137;
	ui32 esi_105;
	Eq_2 eax_142;
	Eq_2 edx_87 = environ;
	if (edx_87 != 0x00)
	{
		Eq_2 edi_119 = *edx_87;
		if (edi_119 != 0x00)
		{
			esi_105 = 0x00;
			Eq_2 ebx_106 = edx_87;
			while (true)
			{
				word32 ecx_1149;
				if (strncmp(edi_119, dwArg04, eax_35, out ecx_1149) == 0x00 && Mem120[edi_119 + eax_35:byte] == 0x3D)
					break;
				ebx_106 = (word32) ebx_106 + 4;
				edi_119 = *ebx_106;
				ui32 eax_148 = esi_105 + 0x01;
				if (edi_119 == 0x00)
				{
					esi_105 = eax_148;
					eax_142 = esi_105 * 0x04 + 0x0C;
					goto l0807127C;
				}
				esi_105 = eax_148;
			}
			edx_136 = ebx_106;
			eax_137 = (word32) *ebx_106;
			if (eax_137 != 0x00)
				goto l080712E0;
			eax_142 = esi_105 * 0x04 + 0x08;
l0807127C:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 edx_173 = last_environ;
			Eq_2 stackArg0 = <invalid>;
			word32 ebp_1152;
			word32 esi_1153;
			word32 edx_1151;
			word32 edi_1154;
			Eq_2 eax_195 = __realloc(gs, stackArg0, edx_173, eax_142, out edx_1151, out ebp_1152, out esi_1153, out edi_1154);
			edx_1130 = edx_173;
			if (eax_195 == 0x00)
				goto l080714B2;
			Eq_2 esi_206 = esi_105 << 0x02;
			Eq_2 eax_207 = environ;
			if (edx_173 != eax_207)
			{
				word32 ecx_1155;
				word32 edx_1156;
				memcpy(eax_195, eax_207, esi_206, out ecx_1155, out edx_1156);
			}
			edx_136 = eax_195 + esi_206;
			*edx_136 = 0x00;
			*((word32) eax_195 + (esi_105 * 0x04 + 4)) = 0x00;
			environ = eax_195;
			last_environ = eax_195;
			eax_137 = (word32) *edx_136;
l080712E0:
			if (dwArg10 == 0x00 && eax_137 != 0x00)
			{
l080712FB:
				edx_1130 = edx_136;
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v38_627 = envlock - 0x01;
				envlock = v38_627;
				if (v38_627 != 0x00)
					__lll_unlock_wake_private(0x080CFA1C, 0x080CE000, edx_136, gs);
				goto l0807131F;
			}
			if (dwArg0C != 0x00)
			{
l080712F6:
				*edx_136 = dwLoc3C_729;
				goto l080712FB;
			}
			ptr32 esp_367;
			Eq_2 esi_267 = (word32) eax_35 + ((word32) dwLoc4C + 1);
			up32 eax_273 = __libc_alloca_cutoff(gs, esi_267);
			struct Eq_71628 * esp_279 = fp - 0x4C;
			if (esi_267 > 0x1000 && eax_273 == 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ebx_1160;
				word32 ebp_1161;
				word32 esi_1162;
				word32 edi_1163;
				word32 ecx_1158;
				word32 edx_1159;
				Eq_2 eax_297 = __libc_malloc(gs, stackArg0, esi_267, out ecx_1158, out edx_1159, out ebx_1160, out ebp_1161, out esi_1162, out edi_1163);
				edx_1130 = edx_136;
				dwLoc3C_729 = eax_297;
				if (eax_297 != 0x00)
				{
					word32 edx_1177;
					Eq_2 eax_322 = __mempcpy(eax_297, dwArg04, eax_35, out edx_1177);
					*eax_322 = 0x3D;
					word32 ecx_1178;
					word32 edx_1179;
					memcpy((word32) eax_322 + 1, dwArg08, dwLoc4C, out ecx_1178, out edx_1179);
					Eq_2 eax_361 = __tfind(eax_297, 0x080CFA18, 0x0805ECD0);
					esp_367 = fp - 0x4C;
					if (eax_361 != 0x00)
					{
						Eq_2 eax_372 = *eax_361;
						if (eax_372 != 0x00)
						{
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							word32 ecx_1184;
							word32 edx_1185;
							free(gs, stackArg0, eax_297, out ecx_1184, out edx_1185);
							dwLoc3C_729 = eax_372;
							goto l080712F6;
						}
					}
l08071489:
					struct Eq_71890 * esp_587 = esp_367 - 0x04;
					esp_587->ptrFFFFFFFC = 0x0805ECD0;
					esp_587->ptrFFFFFFF8 = 0x080CFA18;
					esp_587->tFFFFFFF4 = dwLoc3C_729;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_1181;
					word32 edx_1182;
					__tsearch(stackArg4, dwArg04, dwArg08, out ecx_1181, out edx_1182);
					goto l080712F6;
				}
			}
			else
			{
				struct Eq_71628 * ecx_399 = fp - 0x4C - ((word32) esi_267 + 27 & ~0x0FFF);
				ui32 ebx_400 = (word32) esi_267 + 27 & ~0x0F;
				if (fp - 0x4C != ecx_399)
				{
					do
					{
						esp_279 -= 0x1000;
						esp_279->dw0FFC = esp_279->dw0FFC;
					} while (esp_279 != ecx_399);
				}
				if ((ebx_400 & 0x0FFF) != 0x00)
				{
					esp_279 -= ebx_400 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_279 - 0x04)[(ebx_400 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_279 - 0x04)[(ebx_400 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_71713 * esp_429 = esp_279 - 0x04;
				esp_429->tFFFFFFFC = eax_35;
				esp_429->tFFFFFFF8 = dwArg04;
				Eq_71722 eax_428 = (char *) esp_279 + 0x0F;
				esp_429->tFFFFFFF4 = eax_428 & ~0x0F;
				word32 edx_1164;
				Eq_2 eax_454 = __mempcpy(esp_429->tFFFFFFF4, esp_429->tFFFFFFF8, esp_429->tFFFFFFFC, out edx_1164);
				*eax_454 = 0x3D;
				esp_429->tFFFFFFFC = dwLoc4C;
				esp_429->tFFFFFFF8 = dwArg08;
				esp_429->tFFFFFFF4 = (word32) eax_454 + 1;
				word32 ecx_1165;
				word32 edx_1166;
				memcpy(esp_429->tFFFFFFF4, esp_429->tFFFFFFF8, esp_429->tFFFFFFFC, out ecx_1165, out edx_1166);
				esp_429->tFFFFFFFC.u0 = 0x0805ECD0;
				esp_429->tFFFFFFF8.u0 = 0x080CFA18;
				esp_429->tFFFFFFF4 = eax_428 & ~0x0F;
				Eq_2 eax_494 = __tfind(esp_429->tFFFFFFF4, esp_429->tFFFFFFF8, esp_429->tFFFFFFFC);
				if (eax_494 != 0x00)
				{
					Eq_2 eax_505 = *eax_494;
					dwLoc3C_729 = eax_505;
					if (eax_505 != 0x00)
						goto l080712F6;
				}
				esp_429->tFFFFFFF4 = esi_267;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 edx_1170;
				word32 ebx_1171;
				word32 ebp_1172;
				word32 esi_1173;
				word32 edi_1174;
				word32 ecx_1169;
				Eq_2 eax_535 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1169, out edx_1170, out ebx_1171, out ebp_1172, out esi_1173, out edi_1174);
				edx_1130 = edx_136;
				dwLoc3C_729 = eax_535;
				if (eax_535 != 0x00)
				{
					esp_429->tFFFFFFFC = esi_267;
					esp_429->tFFFFFFF8 = eax_428 & ~0x0F;
					esp_429->tFFFFFFF4 = eax_535;
					word32 ecx_1175;
					word32 edx_1176;
					memcpy(esp_429->tFFFFFFF4, esp_429->tFFFFFFF8, esp_429->tFFFFFFFC, out ecx_1175, out edx_1176);
					esp_367 = (char *) &esp_429->tFFFFFFFC + 8;
					goto l08071489;
				}
			}
l080714B2:
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v29_553 = envlock - 0x01;
			envlock = v29_553;
			if (v29_553 != 0x00)
				__lll_unlock_wake_private(0x080CFA1C, 0x080CE000, edx_1130, gs);
l0807131F:
			ui32 ecx_651 = ecx_28 ^ gs->t0014;
			if (ecx_651 != 0x00)
			{
				word32 ecx_1186;
				word32 edx_1187;
				__stack_chk_fail(out ecx_1186, out edx_1187);
				Eq_2 edx_708;
				ui32 ecx_707 = __setenv(gs, dwArg04, out edx_708);
				edxOut = edx_708;
				return ecx_707;
			}
			else
			{
				edxOut = edx_1130;
				return ecx_651;
			}
		}
	}
	eax_142.u0 = 0x08;
	esi_105 = 0x00;
	goto l0807127C;
}

// 08071590: Register Eq_2 __setenv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 edxOut)
// Called from:
//      __add_to_environ
Eq_2 __setenv(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & edxOut)
{
	if (dwArg04 != 0x00 && (*dwArg04 != 0x00 && strchr(dwArg04, 0x3D, out ecx, out edx) == 0x00))
		ecx = __add_to_environ(gs, dwArg04, dwArg08, 0x00, dwArg0C, out edx);
	else
		gs->tFFFFFFE0.u0 = 22;
	edxOut = edx;
	return ecx;
}

// 08071600: void __unsetenv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_non_dynamic_init
void __unsetenv(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 != 0x00 && *dwArg04 != 0x00)
	{
		word32 ecx_271;
		word32 edx_272;
		Eq_2 eax_32 = strchr(dwArg04, 0x3D, out ecx_271, out edx_272);
		if (eax_32 == 0x00)
		{
			word32 edx_274;
			word32 ecx_273;
			Eq_2 eax_56 = strlen(dwArg04, out ecx_273, out edx_274);
			Eq_2 ecx_108 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_74;
			if (!__cmpxchg(envlock, 0x01, eax_32, out eax_74))
				ecx_108 = __lll_lock_wait_private(eax_74, 0x080CFA1C, gs);
			Eq_2 ebp_131 = environ;
			if (ebp_131 != 0x00)
			{
				while (true)
				{
					Eq_2 ebx_92 = *ebp_131;
					if (ebx_92 == 0x00)
						break;
					if (strncmp(ebx_92, dwArg04, eax_56, out ecx_108) == 0x00 && Mem106[ebx_92 + eax_56:byte] == 0x3D)
					{
						struct Eq_72065 * eax_120 = (word32) ebp_131 + 4;
						do
						{
							ecx_108 = eax_120->dw0000;
							++eax_120;
							eax_120->dwFFFFFFFC = (word32) ecx_108;
						} while (ecx_108 != 0x00);
					}
					else
						ebp_131 = (word32) ebp_131 + 4;
				}
			}
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v15_147 = envlock - 0x01;
			envlock = v15_147;
			if (v15_147 != 0x00)
				__lll_unlock_wake_private(0x080CFA1C, ecx_108, 0x080CE000, gs);
			return;
		}
	}
	gs->tFFFFFFE0.u0 = 22;
}

// 08071710: void __clearenv(Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      free_mem
void __clearenv(Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 ecx_27 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_22;
	if (!__cmpxchg(envlock, 0x01, 0x00, out eax_22))
		ecx_27 = __lll_lock_wait_private(eax_22, 0x080CFA1C, gs);
	Eq_2 eax_34 = environ;
	if (last_environ == eax_34 && eax_34 != 0x00)
	{
		free(gs, dwLoc20, eax_34, out ecx_27, out edx);
		last_environ.u0 = 0x00;
	}
	environ.u0 = 0x00;
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v12_66 = envlock - 0x01;
	envlock = v12_66;
	if (v12_66 != 0x00)
		__lll_unlock_wake_private(0x080CFA1C, ecx_27, edx, gs);
}

// 080717B0: Register Eq_2 __libc_secure_getenv(Stack Eq_2 dwArg04)
// Called from:
//      __libc_message
//      __sysconf_check_spec
Eq_2 __libc_secure_getenv(Eq_2 dwArg04)
{
	if (*(union Eq_4846 *) 0x080CDDAC != 0x00)
		return 0x00;
	return getenv(dwArg04);
}

// 080717E0: void __strtol_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_43090 dwArg0C, Stack word32 dwArg10)
void __strtol_internal(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_43090 dwArg0C, word32 dwArg10)
{
	____strtol_l_internal(gs, dwArg04, dwArg08, dwArg0C, dwArg10, gs->ptrFFFFFFD4);
}

// 08071820: Register word32 __strtol(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_43090 dwArg0C)
// Called from:
//      __sysconf
//      add_module.isra.0
word32 __strtol(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_43090 dwArg0C)
{
	return ____strtol_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, gs->ptrFFFFFFD4);
}

// 08071860: Register Eq_72166 ____strtol_l_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_43090 dwArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_11223) dwArg14)
// Called from:
//      __strtol_internal
//      __strtol
//      __strtol_l
Eq_72166 ____strtol_l_internal(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_43090 dwArg0C, word32 dwArg10, struct Eq_11223 * dwArg14)
{
	Eq_2 ebp_212 = 0x00;
	Eq_2 dwLoc48_1111 = 0x00;
	if (dwArg10 != 0x00)
	{
		Eq_2 edx_27 = dwArg14->t0004;
		Eq_2 eax_28 = *((word32) edx_27 + 44);
		dwLoc48_1111 = eax_28;
		if (*eax_28 <= 0x7E && *eax_28 >= 0x01)
		{
			ebp_212 = *((word32) edx_27 + 40);
			if (*ebp_212 == 0x00)
			{
				dwLoc48_1111.u0 = 0x00;
				ebp_212.u0 = 0x00;
			}
		}
		else
			dwLoc48_1111.u0 = 0x00;
	}
	Eq_72166 eax_1116;
	if (dwArg0C == 0x01 || dwArg0C > 0x24)
	{
		gs->tFFFFFFE0.u0 = 22;
		eax_1116.u0 = 0x00;
		return eax_1116;
	}
	int32 edx_66 = (int32) *dwArg04;
	Eq_2 esi_63 = dwArg04;
	Eq_2 ecx_64 = dwArg14->t0034;
	byte al_80 = (byte) edx_66;
	if ((*((word32) ecx_64 + (edx_66 * 0x02 + 1)) & 0x20) != 0x00)
	{
		do
		{
			esi_63 = (word32) esi_63 + 1;
			int32 edx_74 = (int32) *esi_63;
			al_80 = (byte) edx_74;
		} while ((*((word32) ecx_64 + (edx_74 * 0x02 + 1)) & 0x20) != 0x00);
	}
	if (al_80 == 0x00)
	{
		if (dwArg08 == null)
		{
			eax_1116.u0 = 0x00;
			return eax_1116;
		}
		goto l08071C54;
	}
	up32 dwLoc24_704;
	Eq_2 esi_107;
	if (al_80 != 0x2D)
	{
		dwLoc24_704 = 0x00;
		esi_107 = (word32) esi_63 + (word32) (al_80 == 0x2B);
	}
	else
	{
		esi_107 = (word32) esi_63 + 1;
		dwLoc24_704 = 0x01;
	}
	cu8 bLoc30_1108;
	Eq_72166 dwLoc44_1100;
	Eq_3803 (* dwLoc38_1094)[];
	ui32 ecx_143;
	Eq_2 edi_129;
	ui32 ecx_111 = (word32) *esi_107;
	byte cl_112 = (byte) ecx_111;
	if (cl_112 != 0x30)
	{
		if (dwArg0C != 0x00 && dwArg0C != 0x0A)
		{
			dwLoc48_1111.u0 = 0x00;
			bLoc30_1108 = (cu8) *((word32) dwArg0C.u0 + 0x080B1BFE);
			edi_129.u0 = 0x00;
			dwLoc44_1100 = *((char *) g_a80B1C38 + dwArg0C * 0x04);
			goto l0807192C;
		}
		if (dwLoc48_1111 == 0x00)
		{
			dwLoc44_1100.u0 = 0x19999999;
			edi_129.u0 = 0x00;
			bLoc30_1108 = 0x05;
			dwArg0C.u0 = 0x0A;
			goto l0807192C;
		}
l08071BD8:
		word32 ecx_1197;
		word32 edx_1198;
		Eq_2 eax_216 = strlen(ebp_212, out ecx_1197, out edx_1198);
		if (eax_216 == 0x00)
			goto l08071C25;
		byte al_232 = *ebp_212.u0;
		if (cl_112 == al_232)
		{
			Eq_2 eax_237 = 0x00;
			do
			{
				eax_237 = (word32) eax_237 + 1;
				if (eax_216 == eax_237)
					goto l08071C25;
			} while (Mem233[ebp_212 + eax_237:byte] == Mem233[esi_107 + eax_237:byte]);
		}
		ui32 ebx_254 = (word32) cl_112;
		Eq_2 edx_259 = esi_107;
		if ((byte) ebx_254 != 0x00)
		{
			edx_259 = esi_107;
			word32 edi_273 = (word32) al_232;
			Eq_2 ecx_274 = g_t80CE08C;
			Eq_3803 eax_275[] = g_ptr80CE084;
			do
			{
				if ((byte) ebx_254 > 0x39)
				{
					byte cl_292 = (byte) edi_273;
					Eq_2 eax_286 = 0x00;
					while (Mem278[edx_259 + eax_286:byte] == cl_292)
					{
						eax_286 = (word32) eax_286 + 1;
						if (eax_216 == eax_286)
							goto l08071D80;
						cl_292 = Mem278[ebp_212 + eax_286:byte];
					}
					if (eax_216 > eax_286 && ((*((word32) ecx_274 + (ebx_254 * 0x02 + 1)) & 0x04) == 0x00 || eax_275[ebx_254] > 0x40))
						break;
				}
l08071D80:
				edx_259 = (word32) edx_259 + 1;
				ebx_254 = (word32) *edx_259;
			} while ((byte) ebx_254 != 0x00);
		}
		Eq_2 eax_347 = __correctly_grouped_prefixmb(esi_107, edx_259, ebp_212, dwLoc48_1111);
		edi_129 = eax_216;
		ecx_111 = (word32) *esi_107;
		dwLoc48_1111 = eax_347;
		dwLoc44_1100.u0 = 0x19999999;
		bLoc30_1108 = 0x05;
		dwArg0C.u0 = 0x0A;
l0807192C:
		byte cl_372 = (byte) ecx_111;
		if (dwLoc48_1111 == esi_107)
			goto l08071C25;
		ecx_143 = ecx_111;
		if (cl_372 == 0x00)
			goto l08071C25;
l0807193E:
		dwLoc38_1094 = g_ptr80CE084;
		goto l0807194C;
	}
	if ((dwArg0C & ~0x10) == 0x00)
	{
		Eq_3803 eax_120[] = g_ptr80CE084;
		dwLoc38_1094 = eax_120;
		if (eax_120[(int32) *((word32) esi_107 + 1)] == 88)
		{
			ecx_111 = (word32) *((word32) esi_107 + 2);
			bLoc30_1108 = 0x0F;
			esi_107 = (word32) esi_107 + 2;
			edi_129.u0 = 0x00;
			dwLoc44_1100.u0 = 0x0FFFFFFF;
			dwArg0C.u0 = 0x10;
			dwLoc48_1111.u0 = 0x00;
			goto l0807192C;
		}
		if (dwArg0C == 0x00)
		{
			dwArg0C.u0 = 0x08;
			edi_129.u0 = 0x00;
			ecx_143 = 0x30;
			dwLoc48_1111.u0 = 0x00;
			dwLoc44_1100.u0 = 0x1FFFFFFF;
			bLoc30_1108 = 0x07;
			goto l0807194C;
		}
	}
	if (dwArg0C == 0x0A)
	{
		if (dwLoc48_1111 == 0x00)
		{
			dwLoc44_1100.u0 = 0x19999999;
			edi_129.u0 = 0x00;
			ecx_143 = 0x30;
			bLoc30_1108 = 0x05;
			goto l0807193E;
		}
		goto l08071BD8;
	}
	ecx_143 = 0x30;
	dwLoc48_1111.u0 = 0x00;
	dwLoc44_1100 = *((char *) g_a80B1C38 + dwArg0C * 0x04);
	bLoc30_1108 = (cu8) *((word32) dwArg0C.u0 + 0x080B1BFE);
	edi_129.u0 = 0x00;
	dwLoc38_1094 = g_ptr80CE084;
l0807194C:
	int32 edx_390 = edi_129 - 0x01;
	Eq_2 ebx_393 = esi_107;
	word32 dwLoc40_796 = 0x00;
	Eq_2 eax_397 = g_t80CE08C;
	eax_1116.u0 = 0x00;
	do
	{
		Eq_2 edx_438;
		word32 edx_1195 = ecx_143 - 0x30;
		byte cl_412 = (byte) ecx_143;
		if ((byte) edx_1195 > 0x09)
		{
			if (edi_129 == 0x00)
			{
l080719B0:
				if ((*((word32) eax_397 + (ecx_143 * 0x02 + 1)) & 0x04) == 0x00)
					break;
				Eq_3803 edx_448 = dwLoc38_1094[ecx_143];
				edx_1195 = SEQ(SLICE(edx_448 - 55, word24, 8), (byte) edx_448 - 55);
				goto l080719C5;
			}
			Eq_2 edx_415 = 0x00;
			do
			{
				if (Mem414[ebp_212 + edx_415:byte] != Mem414[ebx_393 + edx_415:byte])
				{
					ecx_143 = (word32) cl_412;
					if (edi_129 == edx_415)
						break;
					goto l080719B0;
				}
				edx_415 = (word32) edx_415 + 1;
			} while (edx_415 != edi_129);
			edx_438 = (word32) ebx_393 + edx_390;
			goto l0807198F;
		}
l080719C5:
		cu8 dl_451 = (byte) edx_1195;
		Eq_43090 ecx_453 = (word32) dl_451;
		if (ecx_453 >= dwArg0C)
			break;
		if (eax_1116 > dwLoc44_1100 || eax_1116 == dwLoc44_1100 && dl_451 > bLoc30_1108)
		{
			ecx_143 = (word32) *((word32) ebx_393 + 1);
			dwLoc40_796 = 0x01;
			ebx_393 = (word32) ebx_393 + 1;
			if ((byte) ecx_143 == 0x00)
				break;
		}
		else
		{
			edx_438 = ebx_393;
			eax_1116 = (word32) ecx_453.u0 + eax_1116 *s dwArg0C;
l0807198F:
			ecx_143 = (word32) *((word32) edx_438 + 1);
			ebx_393 = (word32) edx_438 + 1;
			if ((byte) ecx_143 == 0x00)
				break;
		}
	} while (ebx_393 != dwLoc48_1111);
	if (ebx_393 != esi_107)
	{
		if (dwArg08 != null)
			*dwArg08 = (union Eq_2 *) ebx_393;
		if (dwLoc40_796 == 0x00)
		{
			if (dwLoc24_704 == 0x00)
			{
				if (eax_1116 < 0x00)
				{
					gs->tFFFFFFE0.u0 = 0x22;
					eax_1116.u0 = 0x7FFFFFFF;
				}
				return eax_1116;
			}
			else
			{
				if (eax_1116 <= 0x80000000)
					return -eax_1116;
				gs->tFFFFFFE0.u0 = 0x22;
				eax_1116.u0 = 0x80000000;
				return eax_1116;
			}
		}
		else
		{
			gs->tFFFFFFE0.u0 = 0x22;
			eax_1116 = 0x00 - (word32) (dwLoc24_704 < 0x01) + 0x80000000;
			return eax_1116;
		}
	}
l08071C25:
	if (dwArg08 == null)
	{
l08071D02:
		eax_1116.u0 = 0x00;
		return eax_1116;
	}
	if (esi_107 - dwArg04 > 0x01 && (g_ptr80CE084[(int32) (*((word32) esi_107 - 1))] == 88 && *((word32) esi_107 - 2) == 0x30))
	{
		*dwArg08 = (union Eq_2 *) (esi_107 - 0x01);
		goto l08071D02;
	}
l08071C54:
	*dwArg08 = (union Eq_2 *) dwArg04;
	eax_1116.u0 = 0x00;
	return eax_1116;
}

// 08071E20: void __strtol_l(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_43090 dwArg0C, Stack (ptr32 Eq_11223) dwArg10)
void __strtol_l(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_43090 dwArg0C, struct Eq_11223 * dwArg10)
{
	____strtol_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, dwArg10);
}

// 08071E50: void read_int(Register (ptr32 (ptr32 byte)) eax)
void read_int(byte ** eax)
{
	byte * ebx_19 = *eax;
	byte * ebx_21 = ebx_19 + 1;
	Eq_72613 ecx_22 = (word32) *ebx_19 - 0x30;
	while (true)
	{
		*eax = (byte **) ebx_21;
		Eq_72623 edx_27 = (word32) *ebx_21;
		if (edx_27 > 0x39)
			break;
		if (ecx_22 >= 0x00)
		{
			if (ecx_22 > 0x0CCCCCCC)
				ecx_22.u0 = ~0x00;
			else
			{
				ui32 ebp_47 = ecx_22 * 0x05;
				ecx_22 = edx_27 - 0x30 + ebp_47 * 0x02;
				if (0x7FFFFFFF - (edx_27 - 0x30) < ebp_47 * 0x02)
					ecx_22.u0 = ~0x00;
			}
		}
		++ebx_21;
	}
}

// 08071EB0: void group_number(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack (ptr32 byte) dwArg04, Stack Eq_2 dwArg08)
void group_number(Eq_2 eax, Eq_2 ecx, Eq_2 edx, byte * dwArg04, Eq_2 dwArg08)
{
	word32 esi_23 = (word32) *dwArg04;
	if ((byte) esi_23 > 0x7E)
		return;
	Eq_2 esi_51 = ecx - edx;
	word32 ecx_254;
	word32 edx_255;
	Eq_2 eax_35 = strlen(dwArg08, out ecx_254, out edx_255);
	word32 edx_256;
	memmove(eax, edx, esi_51, out edx_256);
	Eq_2 edi_166 = ecx;
	word32 esi_55 = esi_51 + eax;
	int32 ecx_119 = (int32) (byte) esi_23;
	if (eax >= esi_55)
		return;
	struct Eq_72684 * eax_104 = dwArg04 + 1;
	Eq_2 esi_106 = esi_55;
	while (true)
	{
		while (true)
		{
			esi_106 -= (byte *) 0x01;
			*((word32) edi_166 - 1) = *esi_106;
			Eq_2 ebx_109 = edi_166 - 0x01;
			--ecx_119;
			if (ecx_119 == 0x00)
				break;
			if (eax >= esi_106)
				return;
			edi_166 = ebx_109;
		}
		if (eax >= esi_106)
			return;
		if (ebx_109 - esi_106 <= eax_35)
			break;
		Eq_2 ecx_103 = eax_35;
		do
		{
			--ecx_103;
			--ebx_109;
			Mem115[ebx_109 + 0x00:byte] = Mem112[dwArg08 + ecx_103:byte];
		} while (ecx_103 > 0x00);
		ecx_119 = (int32) eax_104->b0000;
		ci8 cl_123 = (byte) ecx_119;
		if (cl_123 == 0x7F || cl_123 < 0x00)
			break;
		if (cl_123 != 0x00)
		{
			++eax_104;
			edi_166 = ebx_109;
		}
		else
		{
			ecx_119 = (int32) eax_104->bFFFFFFFF;
			edi_166 = ebx_109;
		}
	}
	word32 edx_257;
	memmove(ebx_109, esi_106, eax - esi_106, out edx_257);
}

// 08071FE0: void _i18n_number_rewrite(Register Eq_2 eax, Register Eq_2 ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _i18n_number_rewrite(Eq_2 eax, Eq_2 ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	__align(fp - 4);
	struct Eq_72753 * eax_42 = wctrans(gs, 0x080B1CCC);
	Eq_2 eax_58 = __towctrans(0x2E, eax_42);
	__towctrans(44, eax_42);
	struct Eq_72770 * ebp_14 = fp - 0x0C;
	word32 edi_143 = edx;
	Eq_2 esi_145 = eax;
	Eq_2 edx_152 = fp - 0x0464;
	if (eax_42 != null)
	{
		struct Eq_72780 * ebp_102;
		word32 esi_525;
		word32 edi_526;
		int32 eax_101 = wcrtomb(gs, fp - 0x4A, eax_58, fp - 0x0464, dwLoc0488, ecx, out ebp_102, out esi_525, out edi_526);
		Eq_2 edx_114 = ebp_102->tFFFFFB98;
		Eq_2 ecx_115 = ebp_102->tFFFFFB94;
		if (eax_101 != ~0x00)
			ebp_102 - 0x3E + eax_101 = (byte *) 0x00;
		else
			ebp_102->wFFFFFFC2 = 0x2E;
		ebp_102->tFFFFFB98 = edx_114;
		ebp_102->dwFFFFFBA8 = 0x00;
		ebp_102->dwFFFFFBAC = 0x00;
		int32 eax_139 = wcrtomb(gs, ebp_102 - 0x2D, ecx_115, edx_114, dwLoc0488, ecx, out ebp_14, out esi_145, out edi_143);
		edx_152 = ebp_14->tFFFFFB98;
		if (eax_139 != ~0x00)
			ebp_14 - 0x2D + eax_139 = (byte *) 0x00;
		else
			ebp_14->wFFFFFFD3 = 44;
	}
	ebp_14->dwFFFFFBAC = 0x0400;
	Eq_2 eax_166 = ebp_14 - 0x0448;
	ebp_14->tFFFFFB94 = eax_166;
	ebp_14->tFFFFFBA8 = eax_166;
	Eq_2 edi_163 = edi_143 - esi_145;
	word32 edx_528;
	word32 ecx_527;
	if (__libc_scratch_buffer_set_array_size(gs, edx_152, edi_163, 0x01, out ecx_527, out edx_528) != 0x00)
	{
		Eq_2 ecx_191 = ebp_14->tFFFFFBA8;
		ebp_14->tFFFFFB90 = ecx_191;
		word32 edx_529;
		Eq_2 eax_202 = __mempcpy(ecx_191, esi_145, edi_163, out edx_529);
		Eq_2 esi_211 = ebp_14->tFFFFFBA0;
		ebp_14->tFFFFFB8C = ebp_14 - 0x2D;
		Eq_2 ecx_217 = ebp_14->tFFFFFB90;
		ebp_14->tFFFFFB98.u0 = ~0x2F;
		Eq_2 edi_214 = eax_202;
l080720F9:
		for (--edi_214; ecx_217 <= edi_214; --edi_214)
		{
			int32 eax_227 = (int32) *edi_214;
			byte al_280 = (byte) eax_227;
			if ((byte) eax_227 <= 0x39)
			{
				ebp_14->tFFFFFBA0 = ecx_217;
				Eq_2 ebx_242 = (gs->*ebp_14->tFFFFFB98)->ptr0000->a0008[eax_227].t0000;
				word32 edx_533;
				word32 ecx_532;
				Eq_2 eax_245 = strlen(ebx_242, out ecx_532, out edx_533);
				ecx_217 = ebp_14->tFFFFFBA0;
				esi_211 -= eax_245;
				int32 edx_258 = eax_245 - 0x01;
				if (eax_245 != 0x00)
				{
					do
					{
						*((word32) esi_211 + edx_258) = *((word32) ebx_242 + edx_258);
						--edx_258;
					} while (edx_258 != ~0x00);
				}
				goto l080720F9;
			}
			if (ebp_14->dwFFFFFBA4 != 0x00 && ((byte) eax_227 & ~0x02) == 44)
			{
				Eq_2 ebx_282 = ebp_14 - 0x3E;
				if (al_280 != 0x2E)
					ebx_282 = ebp_14->tFFFFFB8C;
				ebp_14->tFFFFFBA0 = ecx_217;
				word32 ecx_536;
				word32 edx_537;
				Eq_2 eax_294 = strlen(ebx_282, out ecx_536, out edx_537);
				ecx_217 = ebp_14->tFFFFFBA0;
				esi_211 -= eax_294;
				int32 edx_307 = eax_294 - 0x01;
				if (eax_294 != 0x00)
				{
					do
					{
						*((word32) esi_211 + edx_307) = *((word32) ebx_282 + edx_307);
						--edx_307;
					} while (edx_307 != ~0x00);
				}
				goto l080720F9;
			}
			*((word32) esi_211 - 1) = al_280;
			--esi_211;
		}
		Eq_2 eax_335 = ebp_14->tFFFFFBA8;
		if (eax_335 != ebp_14->tFFFFFB94)
		{
			word32 ecx_534;
			word32 edx_535;
			free(gs, dwLoc0498, eax_335, out ecx_534, out edx_535);
		}
	}
	if ((ebp_14->dwFFFFFFE4 ^ gs->t0014) == 0x00)
		return;
	word32 edx_531;
	word32 ecx_530;
	__stack_chk_fail(out ecx_530, out edx_531);
	_IO_helper_overflow(dwArg04, dwArg08);
}

// 080722A0: void _IO_helper_overflow(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      _i18n_number_rewrite
void _IO_helper_overflow(Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 ecx_103 = *((word32) dwArg04 + 20);
	Eq_2 eax_22 = *((word32) dwArg04 + 16);
	Eq_2 esp_18 = fp - 44;
	Eq_2 esi_24 = ecx_103 - eax_22;
	if (esi_24 != 0x00)
	{
		if (*((word32) *((word32) dwArg04 + 0x0098) + 0x0094) >= 135066356)
		{
			word32 edx_197;
			word32 ecx_196;
			_IO_vtable_check(out ecx_196, out edx_197);
			esp_18.u0 = <invalid>;
			eax_22 = *((word32) dwArg04 + 16);
		}
		struct Eq_73098 * esp_47 = esp_18 - 0x04;
		esp_47->tFFFFFFFC = esi_24;
		esp_47->tFFFFFFF8 = eax_22;
		esp_47->tFFFFFFF4 = esp_47->t0010;
		struct Eq_73113 * eax_58 = esp_47->ptr000C;
		up32 eax_65;
		eax_58->ptr001C();
		if (eax_65 > ~0x01)
			return;
		Eq_2 eax_73 = *((word32) dwArg04 + 16);
		esp_47->tFFFFFFFC = esi_24 - eax_65;
		esp_47->tFFFFFFF8 = (word32) eax_73 + eax_65;
		esp_47->tFFFFFFF4 = eax_73;
		word32 edx_198;
		memmove(esp_47->tFFFFFFF4, esp_47->tFFFFFFF8, esp_47->tFFFFFFFC, out edx_198);
		ecx_103 = *((word32) dwArg04 + 20) - eax_65;
		*((word32) dwArg04 + 20) = ecx_103;
	}
	Eq_2 eax_100 = (word32) (byte) dwArg08;
	if (*((word32) dwArg04 + 24) <= ecx_103)
	{
		word32 edx_200;
		word32 ecx_199;
		__overflow(dwArg04, eax_100, out ecx_199, out edx_200);
	}
	else
	{
		*((word32) dwArg04 + 20) = (word32) ecx_103 + 1;
		*ecx_103 = (byte) dwArg08;
	}
}

// 08072380: Register Eq_2 printf_positional(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      vfprintf
Eq_2 printf_positional(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	__align(fp - 4);
	struct Eq_73192 * ebp_1027 = fp - 0x0C;
	struct Eq_73188 * esp_1016 = fp - 0x0944;
	if (dwArg20 == ~0x00)
	{
		byte al_72 = **((char *) *gs->ptrFFFFFFDC + 44);
		if (al_72 == 0x00 || al_72 == 0x7F)
			;
	}
	Eq_2 ecx_1009;
	Eq_2 edx_1014;
	struct Eq_73188 * esp_1576;
	Eq_2 edi_1040;
	struct Eq_73188 * esp_1063;
	Eq_2 edi_1058;
	Eq_2 esi_1140;
	Eq_2 edi_104;
	if (*dwArg14 != 0x00)
	{
		edi_104.u0 = 0x00;
		ebx.u0 = 0x00;
		Eq_2 esi_121 = dwArg14;
		while (true)
		{
			Eq_2 edx_108 = (word32) ebp_1027->tFFFFF780 + edi_104 *s 0x34;
			struct Eq_73246 * esp_111 = esp_1016 - 4;
			esp_111->t0000 = ebp_1027->tFFFFF778;
			esp_111->tFFFFFFFC = edx_108;
			esp_111->tFFFFFFF8 = ebx;
			esp_111->tFFFFFFF4 = esi_121;
			ebp_1027->tFFFFF784 = edx_108;
			Eq_2 esp_131 = <invalid>;
			word32 ebx_126;
			ebx = ebx_126 + __parse_one_specmb(esp_111->tFFFFFFF4, esp_111->tFFFFFFF8, esp_111->tFFFFFFFC, esp_111->t0000, out ebx_126, out ebp_1027, out edi_104);
			esp_1016 = (word32) esp_131 + 16;
			esi_121 = *((word32) ebp_1027->tFFFFF784 + 24);
			if (*esi_121 == 0x00)
				break;
			if (ebp_1027->tFFFFF77C != edi_104)
				continue;
			*esp_131 = ebp_1027->ptrFFFFF768;
			esp_1016 = (word32) esp_131 + 16;
			if ((byte) __libc_scratch_buffer_grow_preserve(gs, dwArg00, out ecx_1009, out edx_1014) == 0x00)
				goto l08072AC0;
			ebp_1027->tFFFFF780 = ebp_1027->tFFFFF7A8;
			ebp_1027->tFFFFF77C = SLICE(ebp_1027->dwFFFFF7AC *64 0x4EC4EC4F, word32, 32) >> 0x04;
		}
		if (ebp_1027->tFFFFF794 >= ebx)
			ebx = ebp_1027->tFFFFF794;
		ebp_1027->tFFFFF784 = ebx;
	}
	else
		edi_104.u0 = 0x00;
	Eq_2 esi_150 = ebp_1027->tFFFFF784;
	struct Eq_73403 * esp_155 = esp_1016 - 0x04;
	esp_155->tFFFFFFFC.u0 = 0x14;
	esp_155->tFFFFFFF8 = esi_150;
	esp_155->tFFFFFFF4 = ebp_1027 - 0x0448;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	esp_1016 = (struct Eq_73188 *) ((char *) &esp_155->tFFFFFFFC + 8);
	if (__libc_scratch_buffer_set_array_size(gs, dwArg00, stackArg8, dwArg08, out ecx_1009, out edx_1014) == 0x00)
	{
l08072AC0:
		esi_1140.u0 = ~0x00;
l08072AC5:
		struct Eq_73310 * eax_622 = ebp_1027->ptrFFFFFBB8;
		if (eax_622 != ebp_1027->ptrFFFFF734)
		{
			ebx = ebp_1027->tFFFFF774;
			esp_1016->dwFFFFFFF0 = eax_622;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			free(gs, stackArg0, dwArg00, out ecx_1009, out edx_1014);
		}
		Eq_2 eax_645 = ebp_1027->tFFFFF7A8;
		if (eax_645 != ebp_1027->tFFFFF760)
		{
			ebx = ebp_1027->tFFFFF774;
			esp_1016->dwFFFFFFF0 = (word32) eax_645;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			free(gs, stackArg0, dwArg00, out ecx_1009, out edx_1014);
		}
		edi_1040 = ebp_1027->dwFFFFFFE4 ^ gs->t0014;
		if (edi_1040 == 0x00)
		{
			ecxOut = ecx_1009;
			edxOut = edx_1014;
			return esi_1140;
		}
		Eq_2 ecx_684;
		word32 edx_3776;
		__stack_chk_fail(out ecx_684, out edx_3776);
		if (ecx_684 <= 0x00)
		{
l080733B7:
			ecx_1009.u0 = 0x00;
			if (ebp_1027->tFFFFF750 != 0x00)
			{
				Eq_2 edx_768 = ebp_1027->tFFFFF770;
				Eq_2 eax_769 = *((word32) edx_768 + 20);
				if (eax_769 < *((word32) edx_768 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_769 + 1;
					*eax_769 = 0x2D;
					edx_1014 = (word32) eax_769 + 1;
					goto l080733E6;
				}
				ebp_1027->tFFFFF77C.u0 = 0x00;
				struct Eq_76071 * esp_772 = esp_1016 - (struct Eq_76072 *) 0x08;
				esp_772->tFFFFFFFC.u0 = 0x2D;
				esp_772->tFFFFFFF8 = edx_768;
			}
			else if (ebp_1027->tFFFFF74C != 0x00)
			{
				Eq_2 esi_753 = ebp_1027->tFFFFF770;
				Eq_2 eax_754 = *((word32) esi_753 + 20);
				if (eax_754 < *((word32) esi_753 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_754 + 1;
					*eax_754 = 0x2B;
					edx_1014 = (word32) eax_754 + 1;
					goto l080733E6;
				}
				ebp_1027->tFFFFF77C.u0 = 0x00;
				struct Eq_76126 * esp_757 = esp_1016 - (struct Eq_76127 *) 0x08;
				esp_757->tFFFFFFFC.u0 = 0x2B;
				esp_757->tFFFFFFF8 = esi_753;
			}
			else
			{
				if (ebp_1027->tFFFFF710 == 0x00)
				{
l08073400:
					if (ebp_1027->tFFFFF744 == 0x00 || (ebp_1027->tFFFFF740 != 0x10 || (ebp_1027->dwFFFFF708 & 0x01) == 0x00))
					{
l08073492:
						word32 edx_906 = Mem902[ebp_1027 + ~0x087B:word32] + ecx_1009;
						if (edx_906 <= 0x00)
						{
l080734A2:
							if (ebp_1027->tFFFFF76C < 0x00)
							{
								edi_1058 = ebp_1027->tFFFFF774;
								struct Eq_75784 * esp_970 = esp_1016 - (struct Eq_75785 *) 4;
								esp_970->a0000[0].t0000 = (word32) edi_1058 - 0x0001C23C;
								esp_970->tFFFFFFFC.u0 = 0x07E1;
								esp_1063 = esp_970 - (struct Eq_75796 *) 4;
								goto l08074C01;
							}
							Eq_2 edx_1005 = *((word32) ebp_1027->tFFFFF770 + 0x0094);
							Eq_2 eax_1008 = edx_1005 - ebp_1027->dwFFFFF6F4;
							if (ebp_1027->tFFFFF6F0 <= eax_1008)
							{
								ebp_1027->tFFFFF784 = edx_1005;
								word32 edx_3775;
								eax_1008 = _IO_vtable_check(out ecx_1009, out edx_3775);
								edx_1005 = ebp_1027->tFFFFF784;
							}
							struct Eq_75825 * esp_993 = esp_1016 - (struct Eq_75826 *) 0x04;
							esp_993->tFFFFFFFC = ebx;
							esp_993->tFFFFFFF8 = ebp_1027->tFFFFF754;
							esp_993->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
							Eq_2 eax_1012;
							(*((word32) edx_1005 + 28))();
							esp_1016 = esp_993 + 0x04;
							if (ebx == eax_1012)
							{
								ecx_1009 = ebp_1027->tFFFFF76C;
								if (0x7FFFFFFF - ecx_1009 >= ebx)
								{
									ecx_1009 += ebx;
									ebp_1027->tFFFFF76C = ecx_1009;
l08072FA7:
									if (ebp_1027->tFFFFF75C != 0x00)
									{
										esp_1016->dwFFFFFFF0 = (word32) ebp_1027->tFFFFF75C;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg0 = <invalid>;
										word32 edx_3759;
										free(gs, stackArg0, dwArg00, out ecx_1009, out edx_3759);
									}
									if (ebp_1027->tFFFFF76C >= 0x00)
									{
										ebx = *((word32) ebp_1027->tFFFFF770 + 0x0094);
										if (ebp_1027->ptrFFFFF714 <= ebx - ebp_1027->dwFFFFF718)
										{
											word32 edx_3760;
											_IO_vtable_check(out ecx_1009, out edx_3760);
										}
										Eq_2 edx_1107 = *((word32) edi_1040 + 20);
										struct Eq_75237 * esp_1110 = esp_1016 - (struct Eq_75238 *) 0x04;
										Eq_2 eax_1111 = *((word32) edi_1040 + 24) - edx_1107;
										esp_1110->tFFFFFFFC = eax_1111;
										esp_1110->tFFFFFFF8 = edx_1107;
										esp_1110->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
										Eq_2 eax_1126;
										(*((word32) ebx + 28))();
										edx_1014 = *((word32) edi_1040 + 24) - *((word32) edi_1040 + 20);
										esp_1016 = esp_1110 + 0x04;
										if (edx_1014 == eax_1126)
										{
											if (edx_1014 <= 0x7FFFFFFF - ebp_1027->tFFFFF76C)
											{
												ebp_1027->tFFFFF764 = (word32) ebp_1027->tFFFFF764 + 1;
												Eq_2 eax_1146 = ebp_1027->tFFFFF764;
												Mem1148[ebp_1027 + ~0x0893:word32] = Mem1144[ebp_1027 + ~0x0893:word32] + edx_1014;
												edi_1040 = (word32) edi_1040 + 52;
												if (eax_1146 >= ebp_1027->tFFFFF70C)
													goto l0807303F;
												goto l080727BD;
											}
											gs->tFFFFFFE0.u0 = 0x4B;
											esi_1140.u0 = ~0x00;
											goto l08072AC5;
										}
										goto l08072AC0;
									}
									edi_1058 = ebp_1027->tFFFFF774;
									struct Eq_75200 * esp_1061 = esp_1016 - (struct Eq_75201 *) 4;
									esp_1061->a0000[0].t0000 = (word32) edi_1058 - 0x0001C23C;
									esp_1061->tFFFFFFFC.u0 = 0x0809;
									esp_1063 = esp_1061 - (struct Eq_75212 *) 4;
l08074C01:
									while (true)
									{
										struct Eq_75420 * esp_1068 = esp_1063 - (struct Eq_75421 *) 4;
										esp_1068->a0000[0].t0000 = (word32) edi_1058 - 0x0001C322;
										esp_1068->tFFFFFFFC = (word32) edi_1058 - 0x0001C28C;
										word32 edx_3762;
										word32 ecx_3761;
										__assert_fail(out ecx_3761, out edx_3762);
										edi_1058 = ebp_1027->tFFFFF774;
										esp_1068->tFFFFFFF8 = (word32) edi_1058 - 0x0001C23C;
										esp_1068->dwFFFFFFF4 = 0x07E2;
										esp_1063 = esp_1068 - (struct Eq_75451 *) 0x0C;
									}
								}
								goto l08072A82;
							}
							goto l08072A95;
						}
						ebp_1027->tFFFFF784 = edx_906;
						struct Eq_75728 * esp_911 = esp_1016 - (struct Eq_75729 *) 0x04;
						esp_911->tFFFFFFFC = edx_906;
						esp_911->tFFFFFFF8.u0 = 0x30;
						esp_911->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						word32 esi_3773;
						word32 edi_3774;
						word32 edx_3770;
						word32 ebp_3772;
						word32 ebx_3771;
						Eq_2 eax_934 = _IO_padn(gs, dwArg00, stackArg8, dwArg08, out ecx_1009, out edx_3770, out ebx_3771, out ebp_3772, out esi_3773, out edi_3774);
						edx_1014 = ebp_1027->tFFFFF784;
						esp_1016 = esp_911 + 0x04;
						if (edx_1014 == eax_934)
						{
							ecx_1009 = ebp_1027->tFFFFF76C;
							if (ecx_1009 <= 0x7FFFFFFE)
							{
								if (0x7FFFFFFF - ecx_1009 >= edx_1014)
								{
									ecx_1009 += edx_1014;
									ebp_1027->tFFFFF76C = ecx_1009;
									goto l080734A2;
								}
								goto l08072A82;
							}
							goto l08074B50;
						}
						goto l08072A95;
					}
					Eq_2 esi_827 = ebp_1027->tFFFFF770;
					Eq_2 eax_828 = *((word32) esi_827 + 20);
					if (eax_828 < *((word32) esi_827 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_828 + 1;
						*eax_828 = 0x30;
						edx_1014 = (word32) eax_828 + 1;
l08073441:
						if (ebp_1027->tFFFFF76C != 0x7FFFFFFF)
						{
							Eq_2 esi_860 = ebp_1027->tFFFFF770;
							Eq_2 eax_861 = *((word32) esi_860 + 20);
							if (eax_861 < *((word32) esi_860 + 24))
							{
								*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_861 + 1;
								edx_1014 = (word32) ebp_1027->bFFFFF749;
								*eax_861 = (byte) edx_1014;
l08073478:
								Eq_2 eax_895 = ebp_1027->tFFFFF76C;
								if (eax_895 != 0x7FFFFFFE)
								{
									ebp_1027->tFFFFF76C = (word32) eax_895 + 2;
									goto l08073492;
								}
								goto l08072A95;
							}
							Eq_2 eax_864 = (word32) ebp_1027->bFFFFF749;
							ebp_1027->tFFFFF77C = ecx_1009;
							struct Eq_75604 * esp_866 = esp_1016 - (struct Eq_75605 *) 0x08;
							esp_866->tFFFFFFFC = eax_864;
							esp_866->tFFFFFFF8 = esi_860;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							word32 ecx_3768;
							word32 eax_879 = __overflow(dwArg00, stackArg8, out ecx_3768, out edx_1014);
							esp_1016 = esp_866 + 0x08;
							ecx_1009 = ebp_1027->tFFFFF77C;
							if (eax_879 != ~0x00)
								goto l08073478;
						}
						goto l08072A95;
					}
					ebp_1027->tFFFFF77C = ecx_1009;
					struct Eq_75547 * esp_832 = esp_1016 - (struct Eq_75548 *) 0x08;
					esp_832->tFFFFFFFC.u0 = 0x30;
					esp_832->tFFFFFFF8 = esi_827;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					word32 ecx_3766;
					word32 eax_844 = __overflow(dwArg00, stackArg8, out ecx_3766, out edx_1014);
					esp_1016 = esp_832 + 0x08;
					ecx_1009 = ebp_1027->tFFFFF77C;
					if (eax_844 != ~0x00)
						goto l08073441;
					goto l08072A95;
				}
				Eq_2 esi_736 = ebp_1027->tFFFFF770;
				Eq_2 eax_737 = *((word32) esi_736 + 20);
				if (eax_737 < *((word32) esi_736 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_737 + 1;
					*eax_737 = 0x20;
					edx_1014 = (word32) eax_737 + 1;
					goto l080733E6;
				}
				ebp_1027->tFFFFF77C.u0 = 0x00;
				struct Eq_76165 * esp_741 = esp_1016 - (struct Eq_76166 *) 0x08;
				esp_741->tFFFFFFFC.u0 = 0x20;
				esp_741->tFFFFFFF8 = esi_736;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg8 = <invalid>;
			word32 ecx_3784;
			word32 eax_795 = __overflow(dwArg00, stackArg8, out ecx_3784, out edx_1014);
			ecx_1009 = ebp_1027->tFFFFF77C;
			if (eax_795 != ~0x00)
			{
l080733E6:
				Eq_2 eax_810 = ebp_1027->tFFFFF76C;
				if (eax_810 != 0x7FFFFFFF)
				{
					ebp_1027->tFFFFF76C = (word32) eax_810 + 1;
					goto l08073400;
				}
				goto l08072A95;
			}
			goto l08072A95;
		}
		ebp_1027->tFFFFF77C = ecx_684;
		struct Eq_75991 * esp_689 = esp_1016 - (struct Eq_75992 *) 0x04;
		esp_689->tFFFFFFFC = ecx_684;
		esp_689->tFFFFFFF8.u0 = 0x20;
		esp_689->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		word32 ecx_3778;
		word32 ebx_3779;
		word32 esi_3781;
		word32 ebp_3780;
		word32 edi_3782;
		Eq_2 eax_699 = _IO_padn(gs, dwArg00, stackArg8, dwArg08, out ecx_3778, out edx_1014, out ebx_3779, out ebp_3780, out esi_3781, out edi_3782);
		ecx_1009 = ebp_1027->tFFFFF77C;
		esp_1016 = esp_689 + 0x04;
		if (eax_699 == ecx_1009)
		{
			if (ebp_1027->tFFFFF76C > 0x7FFFFFFE)
			{
l08074B50:
				edi_1040 = ebp_1027->tFFFFF774;
				struct Eq_75959 * esp_950 = esp_1016 - (struct Eq_75960 *) 4;
				esp_950->a0000[0].t0000 = (word32) edi_1040 - 0x0001C23C;
				esp_950->tFFFFFFFC.u0 = 0x07E1;
				esp_1576 = esp_950 - (struct Eq_75971 *) 4;
l08074B62:
				struct Eq_75453 * esp_2320 = esp_1576 - (struct Eq_75454 *) 4;
				esp_2320->a0000[0].t0000 = (word32) edi_1040 - 0x0001C322;
				esp_2320->tFFFFFFFC = (word32) edi_1040 - 115388;
				word32 edx_3764;
				word32 ecx_3763;
				__assert_fail(out ecx_3763, out edx_3764);
				esp_1016 = esp_2320 - (struct Eq_75472 *) 4;
				ecx_1009.u0 = 0x00;
				goto l08073400;
			}
			Eq_2 esi_709 = ebp_1027->tFFFFF76C;
			if (0x7FFFFFFF - esi_709 >= ecx_1009)
			{
				Mem718[ebp_1027 + ~0x0893:word32] = esi_709 + ecx_1009;
				goto l080733B7;
			}
			goto l08072A82;
		}
		goto l08072A95;
	}
	struct Eq_73310 * ecx_194 = ebp_1027->ptrFFFFFBB8;
	ebp_1027->ptrFFFFF768 = ecx_194;
	esp_155->tFFFFFFFC = esi_150 * 0x04;
	Eq_2 ecx_198 = ecx_194 + esi_150;
	ebp_1027->tFFFFF77C = ecx_198;
	Eq_2 ecx_203 = (word32) ecx_198 + esi_150 * 0x04;
	Eq_2 eax_204 = ebp_1027->tFFFFF770;
	ebp_1027->tFFFFF778 = ecx_203;
	esp_155->tFFFFFFF8 = *((word32) eax_204 + 60) << 0x1D >> 0x1F;
	esp_155->tFFFFFFF4 = ecx_203;
	word32 ecx_3738;
	memset(esp_155->tFFFFFFF4, esp_155->tFFFFFFF8, esp_155->tFFFFFFFC, out ecx_3738, out edx_1014);
	esp_1016 = (struct Eq_73188 *) ((char *) &esp_155->tFFFFFFFC + 8);
	ecx_1009 = ebp_1027->tFFFFF778;
	if (edi_104 != 0x00)
	{
		Eq_2 eax_232 = ebp_1027->tFFFFF780;
		ebp_1027->tFFFFF754 = edi_104;
		ebx = eax_232;
		Eq_2 esi_235 = (word32) eax_232 + edi_104 *s 0x34;
		do
		{
			ui32 eax_241 = *((byte) ebx.u0 + 32);
			if (eax_241 != ~0x00)
				((word32) ecx_1009 + eax_241 * 0x04)->u0 = 0x00;
			ui32 eax_248 = *((byte) ebx.u0 + 28);
			if (eax_248 != ~0x00)
				((word32) ecx_1009 + eax_248 * 0x04)->u0 = 0x00;
			Eq_2 eax_255 = *((byte) ebx.u0 + 44);
			if (eax_255 != 0x00)
			{
				if (eax_255 != 0x01)
				{
					ui32 ecx_280 = *((word32) ebx + 36);
					ebp_1027->tFFFFF778 = *((word32) ebx + 8);
					struct Eq_75897 * esp_290 = esp_1016 - (struct Eq_75898 *) 4;
					esp_290->a0000[0].t0000 = (word32) ebp_1027->tFFFFF77C + ecx_280 * 0x04;
					Eq_2 edx_286 = (byte) ecx_1009.u0 + ecx_280 * 0x04;
					Eq_2 ecx_292 = ebp_1027->tFFFFF778;
					esp_290->tFFFFFFFC = edx_286;
					esp_290->tFFFFFFF8 = eax_255;
					Eq_2 eax_297 = ebp_1027->tFFFFF774;
					esp_290->dwFFFFFFF4 = (word32) ebx;
					<anonymous> * eax_302[] = *((word32) eax_297 + 8168);
					eax_302[ecx_292]();
					ebx = (word32) ebx + 52;
					if (esi_235 == ebx)
						break;
					continue;
				}
				Eq_2 ecx_266 = ebp_1027->tFFFFF77C;
				*((byte) ecx_1009.u0 + *((word32) ebx + 36) * 0x04) = *((word32) ebx + 40);
				edx_1014 = *((word32) ebx + 48);
				*((word32) ecx_266 + *((word32) ebx + 36) * 0x04) = edx_1014;
			}
			ebx = (word32) ebx + 52;
		} while (esi_235 != ebx);
		edi_104 = ebp_1027->tFFFFF754;
		if (ebp_1027->tFFFFF784 == 0x00)
		{
l08072728:
			if (edi_104 <= ebp_1027->tFFFFF764)
			{
l0807303F:
				esi_1140 = ebp_1027->tFFFFF76C;
				goto l08072AC5;
			}
			word32 eax_576 = ebp_1027->dwFFFFF72C;
			Eq_2 ecx_577 = ebp_1027->tFFFFF780;
			ebp_1027->tFFFFF70C = edi_104;
			ebp_1027->tFFFFF704 = eax_576 + 1000;
			edi_1040 = (word32) ecx_577 + ebp_1027->tFFFFF764 *s 0x34;
			ebp_1027->dwFFFFF6E4 = 0x080CEFA0;
			ebp_1027->dwFFFFF6E0 = 0x0354;
			ebp_1027->dwFFFFF6D4 = 0x080CEFA0;
			ebp_1027->dwFFFFF6D0 = 0x0354;
			ebp_1027->dwFFFFF6DC = 0x080CEFA0;
			ebp_1027->dwFFFFF6D8 = 0x0354;
			ebp_1027->dwFFFFF6FC = 0x080CEFA0;
			ebp_1027->dwFFFFF6F8 = 0x0354;
			ebp_1027->dwFFFFF6F4 = 0x080CEFA0;
			ebp_1027->tFFFFF6F0.u0 = 0x0354;
			ebp_1027->dwFFFFF718 = 0x080CEFA0;
			ebp_1027->ptrFFFFF714 = 0x0354;
l080727BD:
			word32 eax_1153 = (word32) *((word32) edi_1040 + 0x0C);
			word32 edx_1166 = (word32) *((word32) edi_1040 + 0x0D);
			ebp_1027->tFFFFF754 = (byte) eax_1153 >> 0x03 & 0x01;
			ebp_1027->tFFFFF778 = SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x05) & 0x01;
			Eq_74228 esi_1175 = *((word32) edi_1040 + 16);
			ebp_1027->tFFFFF750 = (byte) eax_1153 >> 0x04 & 0x01;
			ebp_1027->tFFFFF738 = esi_1175;
			ebp_1027->tFFFFF74C = (byte) eax_1153 >> 0x06 & 0x01;
			ebp_1027->bFFFFF74A = (byte) eax_1153 >> 0x07;
			ebp_1027->tFFFFF74B = (byte) eax_1153 & 0x01;
			ebp_1027->tFFFFF744 = (byte) eax_1153 >> 0x01 & 0x01;
			ebp_1027->bFFFFF748 = (byte) edx_1166 >> 0x03 & 0x01;
			ui32 edx_1219 = *((word32) edi_1040 + 32);
			ebp_1027->tFFFFF740 = (byte) edx_1166 >> 0x01 & 0x01;
			ebp_1027->bFFFFF73C = (byte) eax_1153 >> 0x02 & 0x01;
			ebp_1027->tFFFFF784 = *edi_1040;
			ecx_1009 = *((word32) edi_1040 + 8);
			ebp_1027->bFFFFF749 = (byte) ecx_1009;
			if (edx_1219 != ~0x00)
			{
				Eq_2 esi_1241 = ebp_1027->ptrFFFFF768[edx_1219];
				ebp_1027->tFFFFF77C = esi_1241;
				if (esi_1241 >= 0x00)
					*((word32) edi_1040 + 4) = esi_1241;
				else
				{
					ebp_1027->tFFFFF77C = -ebp_1027->tFFFFF77C;
					Eq_2 ebx_1249 = ebp_1027->tFFFFF77C;
					*((word32) edi_1040 + 0x0C) = (byte) eax_1153 | 0x20;
					*((word32) edi_1040 + 4) = ebx_1249;
					ebp_1027->tFFFFF778.u0 = 0x01;
				}
			}
			else
				ebp_1027->tFFFFF77C = *((word32) edi_1040 + 4);
			ui32 eax_1260 = *((word32) edi_1040 + 28);
			if (eax_1260 != ~0x00)
			{
				Eq_2 eax_1266 = ebp_1027->ptrFFFFF768[eax_1260];
				ebp_1027->tFFFFF784 = eax_1266;
				if (eax_1266 >= 0x00)
					*edi_1040 = eax_1266;
				else
				{
					*edi_1040 = ~0x00;
					ebp_1027->tFFFFF784.u0 = ~0x00;
				}
			}
			Eq_2 esi_1276 = ebp_1027->tFFFFF77C;
			Eq_2 eax_1277 = ebp_1027->tFFFFF784;
			if (esi_1276 >= eax_1277)
				eax_1277 = esi_1276;
			if (eax_1277 <= 0x03C8)
			{
				ebp_1027->tFFFFF75C.u0 = 0x00;
				ebp_1027->tFFFFF71C = ebp_1027->tFFFFF704;
				goto l08072B86;
			}
			ebp_1027->tFFFFF75C = ecx_1009;
			struct Eq_74023 * esp_1298 = esp_1016 - 0x0C;
			Eq_2 ebx_1300 = (word32) eax_1277 + 32;
			esp_1298->tFFFFFFFC = ebx_1300;
			up32 eax_1317 = __libc_alloca_cutoff(gs, esp_1298->tFFFFFFFC);
			esp_1016 = (struct Eq_73188 *) ((char *) &esp_1298->tFFFFFFFC + 16);
			ecx_1009 = ebp_1027->tFFFFF75C;
			if (ebx_1300 <= 0x1000 || eax_1317 != 0x00)
			{
				struct Eq_73188 * esi_1377 = (char *) &esp_1298->tFFFFFFFC + 16 - ((word32) ebx_1300 + 27 & ~0x0FFF);
				ui32 edx_1378 = (word32) ebx_1300 + 27 & ~0x0F;
				if ((char *) &esp_1298->tFFFFFFFC + 16 != esi_1377)
				{
					do
					{
						esp_1016 -= 0x1000;
						esp_1016->dw0FFC = esp_1016->dw0FFC;
					} while (esp_1016 != esi_1377);
				}
				if ((edx_1378 & 0x0FFF) != 0x00)
				{
					esp_1016 -= edx_1378 & 0x0FFF;
					Mem1402[esp_1016 - 0x04 + (edx_1378 & 0x0FFF):word32] = Mem1399[esp_1016 - 0x04 + (edx_1378 & 0x0FFF):word32];
				}
				Eq_2 eax_1410 = ebp_1027->tFFFFF77C;
				Eq_2 esi_1413 = ebp_1027->tFFFFF784;
				Mem1415[ebp_1027 + ~0x08A3:word32] = esp_1016 + 0x0F & ~0x0F;
				int32 eax_1419 = (word32) eax_1410 + 32;
				if (eax_1410 < esi_1413)
					eax_1419 = (word32) esi_1413 + 32;
				Eq_2 eax_1425 = (word32) ebp_1027->tFFFFF75C + eax_1419;
				ebp_1027->tFFFFF75C.u0 = 0x00;
				ebp_1027->tFFFFF71C = eax_1425;
l08072B86:
				byte cl_1436 = (byte) ecx_1009;
				<anonymous> * eax_1432[] = *((word32) ebp_1027->tFFFFF774 + 8148);
				if (eax_1432 != null)
				{
					Eq_2 ebx_1445 = (int32) cl_1436;
					<anonymous> * edx_1446 = eax_1432[ebx_1445];
					ebp_1027->tFFFFF710 = ebx_1445;
					if (edx_1446 != null)
					{
						ui32 eax_1458 = *((word32) edi_1040 + 44);
						ebp_1027->dwFFFFF708 = eax_1458;
						ui32 ebx_1461 = (eax_1458 << 0x02) + 0x1B;
						ebp_1027->dwFFFFF700 = ebx_1461 & ~0x0F;
						<anonymous> * eax_1460[] = eax_1458 << 0x02;
						struct Eq_73188 * esi_1470 = esp_1016 - (ebx_1461 & ~0x0FFF);
						ui32 esi_1473 = ebp_1027->dwFFFFF708;
						while (esp_1016 != esi_1470)
						{
							esp_1016 -= (struct Eq_74349 *) 0x1000;
							esp_1016->dw0FFC = esp_1016->dw0FFC;
						}
						ebp_1027->dwFFFFF708 = esi_1473;
						ui32 ebx_1481 = ebp_1027->dwFFFFF700;
						if ((ebx_1481 & 0x0FFF) != 0x00)
						{
							esp_1016 -= ebx_1481 & 0x0FFF;
							Mem1488[esp_1016 - 0x04 + (ebx_1481 & 0x0FFF):word32] = Mem1480[esp_1016 - 0x04 + (ebx_1481 & 0x0FFF):word32];
						}
						word32 ebx_1495 = esp_1016 + 0x0F;
						ebx = ebx_1495 & ~0x0F;
						if (ebp_1027->dwFFFFF708 != 0x00)
						{
							word32 * eax_1506 = (eax_1458 << 0x02) + (ebx_1495 & ~0x0F);
							word32 * edx_1510 = ebx_1495 & ~0x0F;
							word32 esi_1511 = ebp_1027->ptrFFFFF768 + *((word32) edi_1040 + 36);
							do
							{
								*edx_1510 = esi_1511;
								++edx_1510;
								esi_1511 += 0x0C;
							} while (eax_1506 != edx_1510);
							eax_1460 = (<anonymous> * (*)[]) *((word32) ebp_1027->tFFFFF774 + 8148);
							edx_1446 = eax_1460[ebp_1027->tFFFFF710];
						}
						ebp_1027->tFFFFF710 = ecx_1009;
						struct Eq_75083 * esp_1527 = esp_1016 - (struct Eq_75084 *) 0x04;
						esp_1527->tFFFFFFFC = ebx_1495 & ~0x0F;
						esp_1527->tFFFFFFF8 = edi_1040;
						esp_1527->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
						Eq_2 eax_1559;
						edx_1446();
						ecx_1009 = ebp_1027->tFFFFF710;
						esp_1016 = esp_1527 + 0x04;
						if (eax_1559 != ~0x01)
						{
							if (eax_1559 < 0x00)
								goto l08072A95;
							if (ebp_1027->tFFFFF76C > 0x7FFFFFFE)
							{
								edi_1040 = ebp_1027->tFFFFF774;
								esp_1527->a0000[0].t0000 = (word32) edi_1040 - 0x0001C23C;
								esp_1527->tFFFFFFFC.u0 = 2010;
								esp_1576 = esp_1527 - (struct Eq_75162 *) 4;
								goto l08074B62;
							}
							edx_1014 = 0x7FFFFFFF - ebp_1027->tFFFFF76C;
							if (edx_1014 >= eax_1559)
							{
								Mem1583[ebp_1027 + ~0x0893:word32] = Mem1545[ebp_1027 + ~0x0893:word32] + eax_1559;
								goto l08072FA7;
							}
l08072A82:
							gs->tFFFFFFE0.u0 = 0x4B;
							goto l08072A95;
						}
					}
				}
				struct Eq_73188 * esp_1638 = fp;
				byte cl_1622 = (byte) ecx_1009;
				if ((byte) ecx_1009 <= 122)
				{
					Eq_74228 dl_1620 = ebp_1027->tFFFFF738;
					Eq_2 esi_1612 = ebp_1027->tFFFFF774;
					ebp_1027->dwFFFFF708 = (word32) ebp_1027->tFFFFF754;
					ebp_1027->tFFFFF710 = (word32) ebp_1027->tFFFFF750;
					ebp_1027->tFFFFF74C.u1 = (word32) ebp_1027->tFFFFF74C;
					Eq_2 eax_1619 = (word32) ebp_1027->tFFFFF74B;
					ebp_1027->tFFFFF74B = dl_1620;
					ebp_1027->tFFFFF750 = eax_1619;
					ui32 edx_1625 = (word32) ((word32) esi_1612 - 115232 + (int32) cl_1622);
					ebp_1027->tFFFFF744.u1 = (word32) ebp_1027->tFFFFF744;
					Eq_2 eax_1647;
					Eq_2 ecx_1648;
					Eq_2 edx_1649;
					(*((word32) esi_1612 + (edx_1625 * 0x04 - 5952)))();
					ecxOut = ecx_1648;
					edxOut = edx_1649;
					return eax_1647;
				}
				ui32 edx_1651 = *((word32) edi_1040 + 44);
				ui32 eax_1654 = edx_1651 * 0x04 + 0x1B;
				ecx_1009 = edx_1651 * 0x04;
				struct Eq_73188 * esi_1657 = fp - (eax_1654 & ~0x0FFF);
				if (fp != esi_1657)
				{
					do
					{
						esp_1638 -= 0x1000;
						esp_1638->dw0FFC = esp_1638->dw0FFC;
					} while (esp_1638 != esi_1657);
				}
				int32 ebx_1673 = eax_1654 & ~0x0F & 0x0FFF;
				if (ebx_1673 != 0x00)
				{
					esp_1638 -= ebx_1673;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1638 - 0x04)[ebx_1673 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1638 - 0x04)[ebx_1673 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_74321 eax_1685 = (char *) &(esp_1638->a0000 + 3)->t0000 + 3;
				Eq_2 eax_1686 = eax_1685 & ~0x0F;
				if (edx_1651 != 0x00)
				{
					ecx_1009 = edx_1651 * 0x04 + (eax_1685 & ~0x0F);
					word32 edx_1708 = ebp_1027->ptrFFFFF768 + *((word32) edi_1040 + 36);
					do
					{
						*eax_1686 = edx_1708;
						eax_1686 = (word32) eax_1686 + 4;
						edx_1708 += 0x0C;
					} while (ecx_1009 != eax_1686);
				}
				Eq_2 esi_1724 = ebp_1027->tFFFFF770;
				Eq_2 eax_1725 = *((word32) esi_1724 + 20);
				if (eax_1725 < *((word32) esi_1724 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1725 + 1;
					*eax_1725 = 0x25;
					edx_1014 = (word32) eax_1725 + 1;
				}
				else
				{
					struct Eq_74391 * esp_1730 = esp_1638 - 0x08;
					esp_1730->dwFFFFFFFC = 0x25;
					esp_1730->tFFFFFFF8 = ebp_1027->tFFFFF770;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					esp_1016 = (struct Eq_73188 *) (&esp_1730->dwFFFFFFFC + 3);
					if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
						goto l08072A95;
				}
				ci8 al_1768 = *((word32) edi_1040 + 0x0C);
				if ((al_1768 & 0x08) != 0x00)
				{
					Eq_2 ebx_1774 = ebp_1027->tFFFFF770;
					Eq_2 eax_1775 = *((word32) ebx_1774 + 20);
					if (eax_1775 < *((word32) ebx_1774 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1775 + 1;
						*eax_1775 = 0x23;
						edx_1014 = (word32) eax_1775 + 1;
					}
					else
					{
						struct Eq_74439 * esp_1779 = esp_1638 - 0x08;
						esp_1779->dwFFFFFFFC = 0x23;
						esp_1779->tFFFFFFF8 = ebx_1774;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_73188 *) (&esp_1779->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					al_1768 = (ci8) *((word32) edi_1040 + 0x0C);
					ebx.u0 = 0x02;
				}
				else
					ebx.u0 = 0x01;
				if (al_1768 < 0x00)
				{
					Eq_2 esi_1813 = ebp_1027->tFFFFF770;
					Eq_2 eax_1814 = *((word32) esi_1813 + 20);
					if (eax_1814 < *((word32) esi_1813 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1814 + 1;
						*eax_1814 = 0x27;
						edx_1014 = (word32) eax_1814 + 1;
					}
					else
					{
						esp_1638->dwFFFFFFF4 = 0x27;
						esp_1638->dwFFFFFFF0 = (word32) esi_1813;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = esp_1638;
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (byte) ebx.u0 + 1;
					al_1768 = (ci8) *((word32) edi_1040 + 0x0C);
				}
				Eq_2 esi_1863;
				if ((al_1768 & 0x40) != 0x00)
				{
					esi_1863 = ebp_1027->tFFFFF770;
					Eq_2 eax_1878 = *((word32) esi_1863 + 20);
					if (eax_1878 < *((word32) esi_1863 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1878 + 1;
						*eax_1878 = 0x2B;
						edx_1014 = (word32) eax_1878 + 1;
						goto l08072CB4;
					}
					esp_1638->dwFFFFFFF4 = 0x2B;
				}
				else
				{
					if ((al_1768 & 0x10) == 0x00)
						goto l08072CBB;
					esi_1863 = ebp_1027->tFFFFF770;
					Eq_2 eax_1864 = *((word32) esi_1863 + 20);
					if (eax_1864 < *((word32) esi_1863 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1864 + 1;
						*eax_1864 = 0x20;
						edx_1014 = (word32) eax_1864 + 1;
						goto l08072CB4;
					}
					esp_1638->dwFFFFFFF4 = 0x20;
				}
				struct Eq_75029 * esp_1885 = esp_1638 - 0x0C;
				esp_1885->tFFFFFFFC = esi_1863;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				esp_1016 = (struct Eq_73188 *) ((char *) &esp_1885->tFFFFFFFC + 16);
				if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
					goto l08072A95;
l08072CB4:
				al_1768 = (ci8) *((word32) edi_1040 + 0x0C);
				ebx = (byte) ebx.u0 + 1;
l08072CBB:
				if ((al_1768 & 0x20) != 0x00)
				{
					Eq_2 esi_1932 = ebp_1027->tFFFFF770;
					Eq_2 eax_1933 = *((word32) esi_1932 + 20);
					if (eax_1933 < *((word32) esi_1932 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1933 + 1;
						*eax_1933 = 0x2D;
						edx_1014 = (word32) eax_1933 + 1;
					}
					else
					{
						struct Eq_74538 * esp_1938 = esp_1638 - 0x08;
						esp_1938->dwFFFFFFFC = 0x2D;
						esp_1938->tFFFFFFF8 = esi_1932;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_73188 *) (&esp_1938->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word32) ebx + 1;
				}
				if (*((word32) edi_1040 + 16) == 0x30)
				{
					Eq_2 esi_1976 = ebp_1027->tFFFFF770;
					Eq_2 eax_1977 = *((word32) esi_1976 + 20);
					if (eax_1977 < *((word32) esi_1976 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1977 + 1;
						*eax_1977 = 0x30;
						edx_1014 = (word32) eax_1977 + 1;
					}
					else
					{
						struct Eq_74646 * esp_1982 = esp_1638 - 0x08;
						esp_1982->dwFFFFFFFC = 0x30;
						esp_1982->tFFFFFFF8 = esi_1976;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_73188 *) (&esp_1982->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word32) ebx + 1;
				}
				if ((*((word32) edi_1040 + 0x0D) & 0x08) != 0x00)
				{
					Eq_2 esi_2020 = ebp_1027->tFFFFF770;
					Eq_2 eax_2021 = *((word32) esi_2020 + 20);
					if (eax_2021 < *((word32) esi_2020 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_2021 + 1;
						*eax_2021 = 0x49;
						edx_1014 = (word32) eax_2021 + 1;
					}
					else
					{
						struct Eq_74614 * esp_2026 = esp_1638 - 0x08;
						esp_2026->dwFFFFFFFC = 0x49;
						esp_2026->tFFFFFFF8 = esi_2020;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_73188 *) (&esp_2026->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word32) ebx + 1;
				}
				Eq_2 eax_2059 = *((word32) edi_1040 + 4);
				if (eax_2059 != 0x00)
				{
					struct Eq_74680 * esp_2068 = esp_1638 - 4;
					esp_2068->t0000.u0 = 0x00;
					esp_2068->tFFFFFFFC.u0 = 0x0A;
					Eq_2 esi_2065 = ebp_1027 - 0x20;
					esp_2068->tFFFFFFF8 = esi_2065;
					esp_2068->tFFFFFFF4 = eax_2059;
					ebp_1027->tFFFFF784 = esi_2065;
					Eq_2 eax_2077 = _itoa_word(esp_2068->tFFFFFFF4, esp_2068->tFFFFFFF8, esp_2068->tFFFFFFFC, esp_2068->t0000, out ecx_1009, out edx_1014);
					Eq_2 esi_2085 = eax_2077;
					if (eax_2077 < ebp_1027->tFFFFF784)
					{
						ebp_1027->tFFFFF77C = edi_1040;
						Eq_2 edi_2089 = ebp_1027->tFFFFF770;
						do
						{
							esi_2085 = (word32) esi_2085 + 1;
							edx_1014 = (word32) *((word32) esi_2085 - 1);
							byte dl_2100 = (byte) edx_1014;
							Eq_2 eax_2095 = *((word32) edi_2089 + 20);
							if (eax_2095 >= *((word32) edi_2089 + 24))
							{
								struct Eq_74926 * esp_2103 = esp_1638 - 0x08;
								esp_2103->tFFFFFFFC = edx_1014;
								esp_2103->tFFFFFFF8 = edi_2089;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg8 = <invalid>;
								esp_1016 = (struct Eq_73188 *) ((char *) &esp_2103->tFFFFFFFC + 0x0C);
								if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
									goto l08072A95;
							}
							else
							{
								*((word32) edi_2089 + 20) = (word32) eax_2095 + 1;
								*eax_2095 = dl_2100;
								ecx_1009 = (word32) eax_2095 + 1;
							}
							esp_1016 = esp_1638;
							if (ebx == 0x7FFFFFFF)
								goto l08072A95;
							ebx = (word32) ebx + 1;
						} while (esi_2085 != ebp_1027->tFFFFF784);
						edi_1040 = ebp_1027->tFFFFF77C;
					}
				}
				esp_1016 = esp_1638;
				if (*edi_1040 != ~0x00)
				{
					Eq_2 esi_2136 = ebp_1027->tFFFFF770;
					Eq_2 eax_2137 = *((word32) esi_2136 + 20);
					if (eax_2137 < *((word32) esi_2136 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_2137 + 1;
						*eax_2137 = 0x2E;
						edx_1014 = (word32) eax_2137 + 1;
					}
					else
					{
						struct Eq_74756 * esp_2142 = esp_1638 - 0x08;
						esp_2142->dwFFFFFFFC = 0x2E;
						esp_2142->tFFFFFFF8 = esi_2136;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_73188 *) (&esp_2142->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					esp_1016 = esp_1638;
					if (ebx == 0x7FFFFFFF)
						goto l08072A95;
					struct Eq_74788 * esp_2183 = esp_1638 - 4;
					esp_2183->t0000.u0 = 0x00;
					esp_2183->tFFFFFFFC.u0 = 0x0A;
					Eq_2 eax_2181 = ebp_1027 - 0x20;
					esp_2183->tFFFFFFF8 = eax_2181;
					esp_2183->tFFFFFFF4 = *edi_1040;
					ebp_1027->tFFFFF784 = eax_2181;
					Eq_2 eax_2196 = _itoa_word(esp_2183->tFFFFFFF4, esp_2183->tFFFFFFF8, esp_2183->tFFFFFFFC, esp_2183->t0000, out ecx_1009, out edx_1014);
					ebx = (word32) ebx + 1;
					esp_1016 = (struct Eq_73188 *) ((char *) &esp_2183->t0000 + 4);
					Eq_2 esi_2204 = eax_2196;
					if (eax_2196 < ebp_1027->tFFFFF784)
					{
						ebp_1027->tFFFFF77C = edi_1040;
						Eq_2 edi_2208 = ebp_1027->tFFFFF770;
						do
						{
							esi_2204 = (word32) esi_2204 + 1;
							edx_1014 = (word32) *((word32) esi_2204 - 1);
							byte dl_2219 = (byte) edx_1014;
							Eq_2 eax_2214 = *((word32) edi_2208 + 20);
							if (eax_2214 >= *((word32) edi_2208 + 24))
							{
								struct Eq_74897 * esp_2222 = esp_1638 - 0x08;
								esp_2222->tFFFFFFFC = edx_1014;
								esp_2222->tFFFFFFF8 = edi_2208;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg8 = <invalid>;
								esp_1016 = (struct Eq_73188 *) ((char *) &esp_2222->tFFFFFFFC + 0x0C);
								if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
									goto l08072A95;
							}
							else
							{
								*((word32) edi_2208 + 20) = (word32) eax_2214 + 1;
								*eax_2214 = dl_2219;
								ecx_1009 = (word32) eax_2214 + 1;
							}
							esp_1016 = esp_1638;
							if (ebx == 0x7FFFFFFF)
								goto l08072A95;
							ebx = (word32) ebx + 1;
						} while (esi_2204 != ebp_1027->tFFFFF784);
l08072A25:
						edi_1040 = ebp_1027->tFFFFF77C;
					}
				}
				word32 eax_2254 = *((word32) edi_1040 + 8);
				byte al_2268 = (byte) eax_2254;
				if (eax_2254 == 0x00)
				{
l08072A5D:
					if (ebp_1027->tFFFFF76C > 0x7FFFFFFE)
					{
						edi_1040 = ebp_1027->tFFFFF774;
						struct Eq_75478 * esp_2313 = esp_1016 - (struct Eq_75479 *) 4;
						esp_2313->a0000[0].t0000 = (word32) edi_1040 - 0x0001C23C;
						esp_2313->tFFFFFFFC.u0 = 0x07FD;
						esp_1576 = esp_2313 - (struct Eq_75490 *) 4;
						goto l08074B62;
					}
					Eq_2 esi_2374 = ebp_1027->tFFFFF76C;
					if (0x7FFFFFFF - esi_2374 >= ebx)
					{
						Mem2381[ebp_1027 + ~0x0893:word32] = esi_2374 + ebx;
						goto l08072FA7;
					}
					goto l08072A82;
				}
				Eq_2 esi_2259 = ebp_1027->tFFFFF770;
				edx_1014 = *((word32) esi_2259 + 20);
				if (edx_1014 < *((word32) esi_2259 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) edx_1014 + 1;
					*edx_1014 = al_2268;
					ecx_1009 = (word32) edx_1014 + 1;
				}
				else
				{
					struct Eq_73667 * esp_2266 = esp_1016 - 0x08;
					esp_2266->dwFFFFFFFC = (word32) al_2268;
					esp_2266->tFFFFFFF8 = esi_2259;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					esp_1016 = (struct Eq_73188 *) (&esp_2266->dwFFFFFFFC + 3);
					if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
						goto l08072A95;
				}
				if (ebx != 0x7FFFFFFF)
				{
					ebx = (word32) ebx + 1;
					goto l08072A5D;
				}
l08072A95:
				ebx = ebp_1027->tFFFFF75C;
				if (ebx != 0x00)
				{
					struct Eq_73875 * esp_2398 = esp_1016 - 0x0C;
					esp_2398->tFFFFFFFC = ebp_1027->tFFFFF75C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					ebx = ebp_1027->tFFFFF774;
					Eq_2 stackArg0 = <invalid>;
					free(gs, stackArg0, dwArg00, out ecx_1009, out edx_1014);
					esp_1016 = (struct Eq_73188 *) ((char *) &esp_2398->tFFFFFFFC + 16);
				}
				goto l08072AC0;
			}
			ebp_1027->tFFFFF71C = ecx_1009;
			esp_1298->tFFFFFFFC = ebx_1300;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			ebx = ebp_1027->tFFFFF774;
			Eq_2 stackArg0 = <invalid>;
			word32 edi_3747;
			word32 esi_3746;
			word32 ecx_3743;
			word32 ebx_3744;
			word32 ebp_3745;
			Eq_2 eax_1348 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_3743, out edx_1014, out ebx_3744, out ebp_3745, out esi_3746, out edi_3747);
			ecx_1009 = ebp_1027->tFFFFF71C;
			ebp_1027->tFFFFF75C = eax_1348;
			esp_1016 = (struct Eq_73188 *) ((char *) &esp_1298->tFFFFFFFC + 16);
			if (eax_1348 != 0x00)
			{
				Eq_2 esi_1359 = ebp_1027->tFFFFF77C;
				Eq_2 ebx_1358 = ebp_1027->tFFFFF784;
				int32 edx_1362 = (word32) esi_1359 + 32;
				if (esi_1359 < ebx_1358)
					edx_1362 = (word32) ebx_1358 + 32;
				ebp_1027->tFFFFF71C = (word32) ebp_1027->tFFFFF75C + edx_1362;
				goto l08072B86;
			}
			goto l08072AC0;
		}
	}
	else if (ebp_1027->tFFFFF784 == 0x00)
		goto l0807303F;
	ebp_1027->tFFFFF754 = edi_104;
	struct Eq_73310 * esi_332 = ebp_1027->ptrFFFFF768;
	Eq_2 edi_336 = ebp_1027->tFFFFF75C;
	ebp_1027->tFFFFF778.u0 = 0.0F;
	ebx.u0 = 0x00;
	struct Eq_73310 * esi_338 = esi_332;
	do
	{
		Eq_2 eax_342 = *((word32) ecx_1009 + ebx * 0x04);
		if (eax_342 <= 0x05)
		{
			if (eax_342 >= 0x03 || (eax_342 > 0x01 || eax_342 >= 0x00))
				goto l08072998;
			if (eax_342 != ~0x00)
				goto l08072990;
			if ((*((word32) ebp_1027->tFFFFF770 + 60) & 0x04) == 0x00)
			{
				Eq_2 edi_359 = ebp_1027->tFFFFF774;
				struct Eq_73592 * esp_362 = esp_1016 - 4;
				esp_362->dw0000 = (word32) edi_359 - 0x0001C23C;
				esp_362->dwFFFFFFFC = 1887;
				esp_362->dwFFFFFFF8 = (word32) edi_359 - 0x0001C322;
				esp_362->dwFFFFFFF4 = (word32) edi_359 - 115456;
				__assert_fail(out ecx_1009, out edx_1014);
				esp_1016 = esp_362 - 0x0C;
				goto l08072A25;
			}
			struct Eq_73620 * esp_381 = esp_1016 - 0x0C;
			esp_381->dwFFFFFFFC = (word32) ebp_1027->tFFFFF774 - 115424;
			esp_1016 = esp_381 - 4;
			eax_342 = __libc_fatal(out ecx_1009);
		}
		if (eax_342 != 0x0100)
		{
			if (eax_342 > 0x0100)
			{
				if (eax_342 == 0x0200 || eax_342 == 0x0400)
					goto l08072998;
				if (eax_342 != 0x0107)
					goto l08072990;
				struct Eq_73551 * eax_551 = *edi_336;
				real64 rLoc1_2680 = (real64) eax_551->t0000;
				*edi_336 = (char *) &eax_551->t0004 + 8;
				esi_338->t0000 = (real80) rLoc1_2680;
				edx_1014 = (char *) &eax_551->t0004 + 8;
			}
			else if (eax_342 <= 0x07)
			{
				struct Eq_73551 * eax_407 = *edi_336;
				*edi_336 = (char *) &eax_407->t0004 + 4;
				esi_338->t0000 = eax_407->t0000;
				edx_1014 = (char *) &eax_407->t0004 + 4;
			}
			else
			{
l08072990:
				if ((SLICE(eax_342, byte, 8) & 0x08) != 0x00)
				{
l08072998:
					struct Eq_73551 * eax_545 = *edi_336;
					*edi_336 = &eax_545->t0004;
					esi_338->t0000 = eax_545->t0000;
					edx_1014 = &eax_545->t0004;
				}
				else
				{
					edx_1014 = *((word32) ebp_1027->tFFFFF774 + 8172);
					ebp_1027->tFFFFF75C = edx_1014;
					if (edx_1014 == 0x00 || (edx_1014 - 0x20)[eax_342] == 0x00)
						esi_338->t0000 = (real80) ebp_1027->tFFFFF778;
					else
					{
						word32 eax_447 = *((word32) ebp_1027->tFFFFF77C + ebx * 0x04);
						ebp_1027->tFFFFF750 = eax_447 + 0x1B & ~0x0F;
						struct Eq_73188 * edx_456 = esp_1016 - (eax_447 + 0x1B & ~0x0FFF);
						Eq_2 edx_458 = ebp_1027->tFFFFF75C;
						while (esp_1016 != edx_456)
						{
							esp_1016 -= 0x1000;
							esp_1016->dw0FFC = esp_1016->dw0FFC;
						}
						ebp_1027->tFFFFF75C = edx_458;
						Eq_2 eax_475 = ebp_1027->tFFFFF750;
						if ((eax_475 & 0x0FFF) != 0x00)
						{
							esp_1016 -= eax_475 & 0x0FFF;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1016 - 0x04)[(eax_475 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1016 - 0x04)[(eax_475 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						ebp_1027->tFFFFF750 = ecx_1009;
						Eq_73957 eax_487 = (char *) &(esp_1016->a0000 + 3)->t0000 + 3;
						esi_338->t0000 = eax_487 & ~0x0F;
						struct Eq_73965 * esp_488 = esp_1016 - 0x08;
						Eq_2 edx_507 = *((word32) ecx_1009 + ebx * 0x04);
						esp_488->tFFFFFFFC = edi_336;
						esp_488->dwFFFFFFF8 = eax_487 & ~0x0F;
						Eq_2 eax_516 = ebp_1027->tFFFFF75C;
						(eax_516 - 0x20)[edx_507]();
						ecx_1009 = ebp_1027->tFFFFF750;
						esp_1016 = (struct Eq_73188 *) ((char *) &esp_488->tFFFFFFFC + 0x0C);
					}
				}
			}
		}
		else
		{
			struct Eq_73551 * eax_396 = *edi_336;
			*edi_336 = (char *) &eax_396->t0004 + 4;
			edx_1014 = eax_396->t0004;
			Eq_73562 eax_400 = eax_396->t0000;
			esi_338->dw0004 = (word32) edx_1014;
			esi_338->t0000 = eax_400;
		}
		ebx = (byte) ebx.u0 + 1;
		++esi_338;
	} while (ebx < ebp_1027->tFFFFF784);
	edi_104 = ebp_1027->tFFFFF754;
	goto l08072728;
}

// 08074CB0: Register Eq_2 vfprintf(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_11886 ecxOut, Register out Eq_2 edxOut, Register out Eq_2 ebxOut, Register out ptr32 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      _IO_printf
//      locked_vfxprintf
//      vasprintf
//      buffered_vfprintf
//      __fprintf
Eq_2 vfprintf(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_11886 & ecxOut, union Eq_2 & edxOut, union Eq_2 & ebxOut, ptr32 & ebpOut, union Eq_2 & ediOut)
{
	ptr32 fp;
	word32 ebp;
	word32 edi;
	Eq_2 ebx;
	struct Eq_9 * gs;
	Eq_2 dwArg08;
	Eq_2 dwArg04;
	Eq_2 dwArg0C;
	word32 dwLoc04AC;
	word32 dwLoc0498;
	word32 dwLoc04A8;
	word32 dwLoc04B0;
	word32 dwLoc0490;
	word32 dwLoc048C;
	word32 dwLoc0494;
	word32 dwLoc04B8;
	word32 dwLoc0460;
	word32 dwLoc04B4;
	word32 dwLoc0500;
	word32 dwLoc04F0;
	word32 dwLoc04E0;
	word32 dwLoc04D4;
	word32 dwLoc0488;
	word32 dwLoc0478;
	word32 ecx;
	word32 edx;
	edi_12.u0 = 0x080CE000;
	esp_19 = fp - 0x050C;
	esi_21 = dwArg04;
	eax_26 = gs->t0014;
	eax_31 = gs->tFFFFFFE0;
	eax_33 = *((word32) dwArg04 + 0x0068);
	if (eax_33 == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	else if (eax_33 != ~0x00)
	{
		dwLoc0470_1015.u0 = ~0x00;
		goto l08075033;
	}
	Mem42 = ϕ(Mem40, Mem32);
	edx_43 = *dwArg04;
	dl_44 = (byte) edx_43;
	if ((dl_44 & 0x08) != 0x00)
	{
		edx_50 = edx_43 | 0x20;
		*dwArg04 = edx_43 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		dwLoc0470_1017.u0 = ~0x00;
		goto l08075033;
	}
	if (dwArg08 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 22;
		dwLoc0470_1019.u0 = ~0x00;
		goto l08075033;
	}
	dwLoc0498_1020 = edx_43 & 0x02;
	if ((edx_43 & 0x02) != 0x00)
	{
		eax_77 = buffered_vfprintf(dwArg04, gs, out ecx_79, out edx_78);
		dwLoc0470_1025 = eax_77;
		goto l08075033;
	}
	eax_93 = strchrnul(dwArg08, (byte) 0x25);
	dwLoc0488_1030 = eax_93;
	dwLoc0460_1031 = eax_93;
	dwLoc0478_1032 = edx_43 & 0x8000;
	if ((edx_43 & 0x8000) != 0x00)
		dwLoc0478_1039.u0 = 0x00;
	else
	{
		dwLoc0478_1809 = ϕ(dwLoc0478_1038, dwLoc0478_1032);
		Mem136 = ϕ(Mem133, Mem115);
		edx_137 = *((word32) dwArg04 + 72);
		ebx_139 = gs->t0008;
		if (*((word32) edx_137 + 8) != ebx_139)
		{
			if (gs->t000C != 0x00)
				__lock();
			Z_151 = __cmpxchg(*edx_137, 0x01, 0x00, out eax_150);
			if (!Z_151)
				__lll_lock_wait_private(eax_150, edx_137, gs);
			edx_163 = *((word32) dwArg04 + 72);
			*((word32) edx_163 + 8) = ebx_139;
		}
		Mem168 = ϕ(Mem136, Mem166);
		edx_167 = ϕ(edx_137, edx_163);
		v41_169 = (word32) *((word32) edx_167 + 4) + 1;
		*((word32) edx_167 + 4) = v41_169;
	}
	dwLoc0478_1807 = ϕ(dwLoc0478_1039, dwLoc0478_1038, dwLoc0478_1809);
	Mem177 = ϕ(Mem172, Mem133, Mem170);
	ebx_178 = *((word32) dwArg04 + 0x0094);
	dwLoc0490_1040 = 0x080CEFA0;
	dwLoc048C_1041 = 0x0354;
	if (ebx_178 >= 135066356)
		_IO_vtable_check(out ecx_1989, out edx_1990);
	eax_220 = eax_93 - dwArg08;
	dwLoc0470_1072 = eax_220;
	(*((word32) ebx_178 + 28))();
	esp_238 = fp - 0x050C;
	if (eax_220 != eax_234)
	{
l080750B8:
		edx_1957 = ϕ(edx_235, edx_305, edx_1958, edx_934, edx_787);
		dwLoc0488_1933 = ϕ(dwLoc0488_1030, dwLoc0488_1934, dwLoc0488_1934, dwLoc0488_1517, dwLoc0488_1517);
		dwLoc04D4_1926 = ϕ(dwLoc04D4, dwLoc04D4_1927, dwLoc04D4_1927, dwLoc04D4_1472, dwLoc04D4_1472);
		dwLoc04E0_1913 = ϕ(dwLoc04E0, dwLoc04E0_1914, dwLoc04E0_1914, dwLoc04E0_1427, dwLoc04E0_1427);
		dwLoc04F0_1904 = ϕ(dwLoc04F0, dwLoc04F0_1905, dwLoc04F0_1905, dwLoc04F0_1382, dwLoc04F0_1382);
		dwLoc04B4_1898 = ϕ(dwLoc04B4, dwLoc04B4_1899, dwLoc04B4_1899, dwLoc04B4_1345, dwLoc04B4_1343);
		dwLoc0460_1895 = ϕ(dwLoc0460_1031, dwLoc0460_1896, dwLoc0460_1896, dwLoc0460_1304, dwLoc0460_1340);
		dwLoc04B8_1892 = ϕ(dwLoc04B8, dwLoc04B8_1893, dwLoc04B8_1893, dwLoc04B8_1276, dwLoc04B8_1336);
		dwLoc0494_1885 = ϕ(dwLoc0494, dwLoc0494_1095, dwLoc0494_1095, dwLoc0494_1639, dwLoc0494_1374);
		dwLoc048C_1874 = ϕ(dwLoc048C_1041, dwLoc048C_1875, dwLoc048C_1875, dwLoc048C_1177, dwLoc048C_1177);
		dwLoc0490_1871 = ϕ(dwLoc0490_1040, dwLoc0490_1872, dwLoc0490_1872, dwLoc0490_1169, dwLoc0490_1169);
		dwLoc04A8_1865 = ϕ(dwLoc04A8, dwLoc04A8_1866, dwLoc04A8_1866, dwLoc04A8_1153, dwLoc04A8_1153);
		dwLoc0498_1861 = ϕ(dwLoc0498_1020, dwLoc0498_1862, dwLoc0498_1862, dwLoc0498_1281, dwLoc0498_1318);
		dwLoc04AC_1858 = ϕ(dwLoc04AC, dwLoc04AC_1859, dwLoc04AC_1859, dwLoc04AC_1280, dwLoc04AC_1314);
		dwLoc0478_1829 = ϕ(dwLoc0478_1807, dwLoc0478_1830, dwLoc0478_1830, dwLoc0478_1820, dwLoc0478_1820);
		ebx_1002 = ϕ(ebx_178, ebx_300, ebx_289, ebx_938, ebx_779);
		edi_1000 = ϕ(edi_12, edi_299, edi_299, edi_383, edi_383);
		esp_999 = ϕ(esp_238, esp_308, esp_293, esp_937, esp_786);
		ecx_995 = ϕ(ecx_236, ecx_306, ecx_996, ecx_939, ecx_788);
		esi_993 = ϕ(esi_21, esi_310, esi_301, esi_388, esi_388);
		dwLoc0470_1099.u0 = ~0x00;
		goto l08075010;
	}
	else
	{
		edx_241 = eax_93;
		if (*eax_93 == 0x00)
		{
l08075010:
			edx_1956 = ϕ(edx_241, edx_876, edx_1957, edx_934, edx_934);
			dwLoc0488_1520 = ϕ(dwLoc0488_1030, dwLoc0488_1509, dwLoc0488_1933, dwLoc0488_1517, dwLoc0488_1517);
			dwLoc04D4_1475 = ϕ(dwLoc04D4, dwLoc04D4_1465, dwLoc04D4_1926, dwLoc04D4_1472, dwLoc04D4_1472);
			dwLoc04E0_1430 = ϕ(dwLoc04E0, dwLoc04E0_1419, dwLoc04E0_1913, dwLoc04E0_1427, dwLoc04E0_1427);
			dwLoc04F0_1385 = ϕ(dwLoc04F0, dwLoc04F0_1623, dwLoc04F0_1904, dwLoc04F0_1382, dwLoc04F0_1382);
			dwLoc04B4_1350 = ϕ(dwLoc04B4, dwLoc04B4_1607, dwLoc04B4_1898, dwLoc04B4_1345, dwLoc04B4_1345);
			dwLoc0460_1292 = ϕ(dwLoc0460_1031, dwLoc0460_1605, dwLoc0460_1895, dwLoc0460_1304, dwLoc0460_1304);
			dwLoc04B8_1269 = ϕ(dwLoc04B8, dwLoc04B8_1529, dwLoc04B8_1892, dwLoc04B8_1276, dwLoc04B8_1276);
			dwLoc0494_1257 = ϕ(dwLoc0494, dwLoc0494_1597, dwLoc0494_1885, dwLoc0494_1639, dwLoc0494_1639);
			dwLoc048C_1180 = ϕ(dwLoc048C_1041, dwLoc048C_1594, dwLoc048C_1874, dwLoc048C_1177, dwLoc048C_1177);
			dwLoc0490_1172 = ϕ(dwLoc0490_1040, dwLoc0490_1591, dwLoc0490_1871, dwLoc0490_1169, dwLoc0490_1169);
			dwLoc04A8_1149 = ϕ(dwLoc04A8, dwLoc04A8_1575, dwLoc04A8_1865, dwLoc04A8_1153, dwLoc04A8_1153);
			dwLoc0498_1141 = ϕ(dwLoc0498_1020, dwLoc0498_1439, dwLoc0498_1861, dwLoc0498_1281, dwLoc0498_1281);
			dwLoc04AC_1134 = ϕ(dwLoc04AC, dwLoc04AC_1567, dwLoc04AC_1858, dwLoc04AC_1280, dwLoc04AC_1280);
			dwLoc0470_1124 = ϕ(dwLoc0470_1072, dwLoc0470_1631, dwLoc0470_1099, dwLoc0470_1663, dwLoc0470_1662);
			dwLoc0478_1101 = ϕ(dwLoc0478_1807, dwLoc0478_1812, dwLoc0478_1829, dwLoc0478_1820, dwLoc0478_1820);
			ebx_391 = ϕ(ebx_178, ebx_868, ebx_1002, ebx_950, ebx_942);
			edi_356 = ϕ(edi_12, edi_866, edi_1000, edi_383, edi_383);
			esp_349 = ϕ(esp_238, esp_879, esp_999, esp_937, esp_937);
			ecx_335 = ϕ(ecx_236, ecx_877, ecx_995, ecx_939, ecx_939);
			Mem314 = ϕ(Mem229, Mem881, Mem312, Mem952, Mem949);
			esi_313 = ϕ(esi_21, esi_882, esi_993, esi_388, esi_388);
			if ((*esi_313 & 0x8000) == 0x00)
			{
				edx_318 = *((word32) esi_313 + 72);
				v33_319 = *((word32) edx_318 + 4) - 0x01;
				*((word32) edx_318 + 4) = v33_319;
				if (v33_319 == 0x00)
				{
					*((word32) edx_318 + 8) = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					v35_329 = *edx_318 - 0x01;
					*edx_318 = v35_329;
					if (v35_329 != 0x00)
						__lll_unlock_wake_private(edx_318, ecx_335, edx_318, gs);
				}
			}
			edx_1955 = ϕ(edx_1956, edx_318, edx_318);
			Mem342 = ϕ(Mem314, Mem320, Mem330);
			ecx_344 = dwLoc0478_1101;
			if (dwLoc0478_1101 != 0x00)
			{
				esp_352 = esp_349 - 0x08;
				ebx_359 = edi_356;
				esp_352->dwFFFFFFFC = 0x00;
				esp_352->ptrFFFFFFF8 = fp - 0x0444;
				fn00000000();
				esp_377 = &esp_352->dwFFFFFFFC + 3;
			}
l08075033:
			edx_1953 = ϕ(edx, edx_1955, edx_374, edx_78, edx_43, edx_50);
			ecx_1948 = ϕ(ecx, ecx_344, ecx_375, ecx_79, ecx, ecx);
			dwLoc0478_1820 = ϕ(dwLoc0478, dwLoc0478_1101, dwLoc0478_1101, dwLoc0478, dwLoc0478, dwLoc0478);
			dwLoc0488_1517 = ϕ(dwLoc0488, dwLoc0488_1520, dwLoc0488_1520, dwLoc0488, dwLoc0488, dwLoc0488);
			dwLoc04D4_1472 = ϕ(dwLoc04D4, dwLoc04D4_1475, dwLoc04D4_1475, dwLoc04D4, dwLoc04D4, dwLoc04D4);
			dwLoc04E0_1427 = ϕ(dwLoc04E0, dwLoc04E0_1430, dwLoc04E0_1430, dwLoc04E0, dwLoc04E0, dwLoc04E0);
			dwLoc04F0_1382 = ϕ(dwLoc04F0, dwLoc04F0_1385, dwLoc04F0_1385, dwLoc04F0, dwLoc04F0, dwLoc04F0);
			dwLoc04B4_1347 = ϕ(dwLoc04B4, dwLoc04B4_1350, dwLoc04B4_1350, dwLoc04B4, dwLoc04B4, dwLoc04B4);
			dwLoc0460_1289 = ϕ(dwLoc0460, dwLoc0460_1292, dwLoc0460_1292, dwLoc0460, dwLoc0460, dwLoc0460);
			dwLoc04B8_1266 = ϕ(dwLoc04B8, dwLoc04B8_1269, dwLoc04B8_1269, dwLoc04B8, dwLoc04B8, dwLoc04B8);
			dwLoc0494_1254 = ϕ(dwLoc0494, dwLoc0494_1257, dwLoc0494_1257, dwLoc0494, dwLoc0494, dwLoc0494);
			dwLoc048C_1177 = ϕ(dwLoc048C, dwLoc048C_1180, dwLoc048C_1180, dwLoc048C, dwLoc048C, dwLoc048C);
			dwLoc0490_1169 = ϕ(dwLoc0490, dwLoc0490_1172, dwLoc0490_1172, dwLoc0490, dwLoc0490, dwLoc0490);
			dwLoc04A8_1146 = ϕ(dwLoc04A8, dwLoc04A8_1149, dwLoc04A8_1149, dwLoc04A8, dwLoc04A8, dwLoc04A8);
			dwLoc0498_1138 = ϕ(dwLoc0498, dwLoc0498_1141, dwLoc0498_1141, dwLoc0498_1020, dwLoc0498, dwLoc0498);
			dwLoc04AC_1131 = ϕ(dwLoc04AC, dwLoc04AC_1134, dwLoc04AC_1134, dwLoc04AC, dwLoc04AC, dwLoc04AC);
			dwLoc0470_1122 = ϕ(dwLoc0470_1015, dwLoc0470_1124, dwLoc0470_1124, dwLoc0470_1025, dwLoc0470_1019, dwLoc0470_1017);
			esp_394 = ϕ(esp_19, esp_349, esp_377, esp_19, esp_19, esp_19);
			ebx_389 = ϕ(ebx, ebx_391, ebx_359, ebx, ebx, ebx);
			esi_388 = ϕ(esi_21, esi_313, esi_313, esi_21, esi_21, esi_21);
			Mem380 = ϕ(Mem39, Mem342, Mem363, Mem81, Mem63, Mem56);
			ebp_379 = fp - 4;
			edi_383 = eax_26 ^ gs->t0014;
			eax_386 = dwLoc0470_1122;
			if (edi_383 == 0x00)
			{
				ebx_955 = ebx;
				edi_959 = edi;
				ebp_961 = ebp;
				ecxOut = ecx_1948;
				edxOut = edx_1953;
				ebxOut = ebx_955;
				ebpOut = ebp_961;
				ediOut = edi_959;
				return eax_386;
			}
			__stack_chk_fail(out ecx_1991, out edx_1992);
			esp_400 = esp_394 - 0x0C;
			esp_400->tFFFFFFFC = ebx_389;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			stackArg0.u0 = <invalid>;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			stackArg4.u0 = <invalid>;
			eax_405 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_407, out edx_1995, out ebx_1996, out ebp_1997, out esi_1998, out edi_1999);
			esp_409 = (char *) &esp_400->t0008 + 4;
			edx_410 = eax_405;
			if (eax_405 != 0x00)
			{
				dwLoc04A4_1130.u0 = 0x01;
				esp_400->t0008 = dwLoc04AC_1131;
				esp_400->t0004 = dwLoc0498_1138;
				esp_400->t0000 = fp - 0x0434;
				esp_400->tFFFFFFFC = eax_405;
				dwLoc0498_1145 = eax_405;
				nLoc0497_1164 = SLICE(eax_405, word24, 8);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				stackArg4.u0 = <invalid>;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				stackArg44.u0 = <invalid>;
				eax_427 = __wcsrtombs(gs, stackArg4, dwArg04, dwArg08, dwArg0C, stackArg44, out ebp_2004, out esi_2005, out edi_2006);
				esp_431 = (char *) &esp_400->t0008 + 4;
				edx_432 = eax_405;
				ecx_434 = eax_427;
				if (eax_427 != ~0x00)
				{
					v30_436 = dwLoc04A8_1146 - eax_427;
					dwLoc04A8_1153 = v30_436;
					if (v30_436 < 0x00)
					{
						if (dwLoc0470_1122 >= 0x00)
						{
							ebx_641 = *((word32) esi_388 + 0x0094);
							eax_643 = ebx_641 - dwLoc0490_1169;
							if (dwLoc048C_1177 <= eax_643)
							{
								dwLoc04A4_1230 = eax_405;
								_IO_vtable_check(out ecx_2016, out edx_2017);
							}
							dwLoc04A4_1635 = ϕ(dwLoc04A4_1130, dwLoc04A4_1230);
							dwLoc0498_1232 = eax_427;
							esp_400->t0004 = eax_427;
							esp_400->t0000 = eax_405;
							esp_400->tFFFFFFFC = esi_388;
							(*((word32) ebx_641 + 28))();
							ecx_676 = eax_427;
							esp_677 = (char *) &esp_400->t0008 + 4;
							if (eax_427 == eax_672)
							{
								eax_681 = 0x7FFFFFFF - dwLoc0470_1122;
								if (eax_427 <= eax_681)
								{
									v32_689 = dwLoc0470_1122 + eax_427;
									dwLoc0470_1251 = v32_689;
								}
								goto l08076520;
							}
							goto l08075098;
						}
						goto l0807768D;
					}
					bLoc0498_1161 = (int8) (v30_436 != 0x00);
					eax_445 = (word32) bLoc0498_1161;
					al_449 = (byte) eax_445;
					dwLoc0498_1165 = SEQ(nLoc0497_1164, bLoc0498_1161);
					if (dwLoc04B0 != 0x00 || al_449 == 0x00)
					{
l080766A2:
						dwLoc04B4_1356 = ϕ(dwLoc04B4_1347, dwLoc04B4_1347, dwLoc04B4_1162);
						dwLoc04AC_1317 = ϕ(dwLoc04AC_1131, dwLoc04AC_1131, dwLoc04AC_1163);
						dwLoc0470_1167 = ϕ(dwLoc0470_1122, dwLoc0470_1122, dwLoc0470_1166);
						Mem485 = ϕ(Mem444, Mem444, Mem482);
						if (dwLoc0470_1167 < 0x00)
						{
l0807768D:
							dwLoc0470_1535 = ϕ(dwLoc0470_1122, dwLoc0470_1167);
							dwLoc04B4_1355 = ϕ(dwLoc04B4_1347, dwLoc04B4_1356);
							dwLoc04AC_1316 = ϕ(dwLoc04AC_1131, dwLoc04AC_1317);
							esp_637 = esp_394 - 4;
							esp_637->dw0000 = (word32) edi_383 - 0x0001C228;
							esp_637->dwFFFFFFFC = 0x0666;
							goto l080775FF;
						}
						ebx_491 = *((word32) esi_388 + 0x0094);
						eax_493 = ebx_491 - dwLoc0490_1169;
						if (dwLoc048C_1177 <= eax_493)
							_IO_vtable_check(out ecx_2037, out edx_2038);
						esp_511 = esp_394 - 0x04;
						dwLoc04B4_1192 = eax_427;
						esp_511->tFFFFFFFC = eax_427;
						esp_511->tFFFFFFF8 = eax_405;
						esp_511->tFFFFFFF4 = esi_388;
						dwLoc04AC_1193 = eax_405;
						(*((word32) ebx_491 + 28))();
						ecx_533 = eax_427;
						esp_534 = (char *) &esp_511->tFFFFFFFC + 8;
						if (eax_427 == eax_529)
						{
							edx_538 = eax_405;
							eax_540 = 0x7FFFFFFF - dwLoc0470_1167;
							if (eax_427 > eax_540)
								goto l08076520;
							v37_544 = dwLoc0470_1167 + eax_427;
							dwLoc0470_1203 = v37_544;
							dwLoc0498_1225 = SEQ(nLoc0497_1164, bLoc0498_1161);
							if (dwLoc04B0 == 0x00 || bLoc0498_1161 == 0x00)
							{
l08076728:
								dwLoc0470_1303 = ϕ(dwLoc0470_1203, dwLoc0470_1203, dwLoc0470_1215);
								dwLoc0498_1223 = ϕ(dwLoc0498_1225, dwLoc0498_1225, dwLoc0498_1205);
								esp_614 = esp_394 - 0x0C;
								esp_614->tFFFFFFFC = eax_405;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								stackArg0.u0 = <invalid>;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								stackArg4.u0 = <invalid>;
								free(gs, stackArg0, stackArg4, out ecx_2047, out edx_2048);
							}
							esp_511->tFFFFFFFC = v30_436;
							esp_511->tFFFFFFF8.u0 = 0x20;
							esp_511->tFFFFFFF4 = esi_388;
							dwLoc0498_1205 = eax_405;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							stackArg4.u0 = <invalid>;
							eax_561 = _IO_padn(gs, stackArg4, dwArg04, dwArg08, out ecx_2040, out edx_562, out ebx_2041, out ebp_2042, out esi_2043, out edi_2044);
							ecx_565 = v30_436;
							esp_566 = (char *) &esp_511->tFFFFFFFC + 8;
							if (v30_436 == eax_561)
							{
								if (v37_544 <= 0x7FFFFFFE)
								{
									ebx_599 = 0x7FFFFFFF - v37_544;
									edx_600 = eax_405;
									if (ebx_599 >= v30_436)
									{
										v40_604 = v37_544 + v30_436;
										dwLoc0470_1215 = v40_604;
										goto l08076728;
									}
									goto l08076520;
								}
								goto l0807767F;
							}
						}
						goto l08075098;
					}
					dwLoc04B4_1162 = eax_405;
					dwLoc04AC_1163 = eax_427;
					esp_400->t0004 = v30_436;
					esp_400->t0000.u0 = 0x20;
					esp_400->tFFFFFFFC = esi_388;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg4.u0 = <invalid>;
					eax_464 = _IO_padn(gs, stackArg4, dwArg04, dwArg08, out ecx_466, out edx_465, out ebx_2033, out ebp_2034, out esi_2035, out edi_2036);
					esp_468 = (char *) &esp_400->t0008 + 4;
					if (v30_436 == eax_464)
					{
						if (dwLoc0470_1122 > 0x7FFFFFFE)
						{
l0807767F:
							dwLoc0470_1536 = ϕ(dwLoc0470_1203, dwLoc0470_1122);
							dwLoc04B4_1357 = ϕ(dwLoc04B4_1192, dwLoc04B4_1162);
							dwLoc0498_1210 = ϕ(dwLoc0498_1205, dwLoc0498_1165);
							dwLoc04AC_1209 = ϕ(dwLoc04AC_1193, dwLoc04AC_1163);
							esp_575 = esp_394 - 4;
							esp_575->ptr0000 = (word32) edi_383 - 0x0001C228;
							esp_575->dwFFFFFFFC = 0x0666;
							esp_575->ptrFFFFFFF8 = (word32) edi_383 - 0x0001C322;
							esp_575->ptrFFFFFFF4 = (word32) edi_383 - 115388;
							__assert_fail(out ecx_2049, out edx_2050);
							esp_575->ptrFFFFFFF0 = (word32) edi_383 - 0x0001C228;
							esp_575->dwFFFFFFEC = 0x0665;
l080775FF:
							dwLoc04A4_1632 = ϕ(dwLoc04A4_1634, dwLoc04A4_1130, dwLoc04A4_1130);
							dwLoc0470_1534 = ϕ(dwLoc0470_1302, dwLoc0470_1535, dwLoc0470_1536);
							dwLoc04B4_1343 = ϕ(dwLoc04B4_1345, dwLoc04B4_1355, dwLoc04B4_1357);
							dwLoc0460_1340 = ϕ(dwLoc0460_1304, dwLoc0460_1289, dwLoc0460_1289);
							dwLoc04B8_1336 = ϕ(dwLoc04B8_1276, dwLoc04B8_1266, dwLoc04B8_1266);
							dwLoc0498_1318 = ϕ(dwLoc0498_1281, dwLoc0498_1165, dwLoc0498_1210);
							dwLoc04AC_1314 = ϕ(dwLoc04AC_1280, dwLoc04AC_1316, dwLoc04AC_1209);
							__assert_fail(out ecx_2024, out edx_774);
							ebx_779 = edi_383;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							stackArg0.u0 = <invalid>;
							eax_782 = __libc_malloc(gs, stackArg0, edx_774, out ecx_2026, out edx_2027, out ebx_2028, out ebp_2029, out esi_2030, out edi_2031);
							esp_786 = fp;
							edx_787 = dwLoc04B4_1343;
							ecx_788 = dwLoc0500;
							dwLoc0494_1374 = eax_782;
							if (eax_782 != 0x00)
							{
								edx_793 = dwLoc04B4_1343 + eax_782;
								dwLoc04B4_1375 = edx_793;
								ebx_797 = (word32) *dwLoc0460_1340;
								bl_798 = (byte) ebx_797;
								if (bl_798 != 0x24)
								{
									dl_885 = (byte) ebx_797 - 0x20;
									if (dl_885 <= 0x5A)
									{
										eax_889.u0 = (int32) bl_798;
										eax_890 = CONVERT(Mem795[eax_889 - 0x20 + dwLoc04A4_1632:byte], byte, word32);
										(*((word32) edi_383 + (eax_890 * 0x04 - 5312)))();
										ecxOut = ecx_893;
										edxOut = edx_892;
										ebxOut = ebx_797;
										ebpOut = ebp_379;
										ediOut = edi_383;
										return eax_891;
									}
									else
									{
										(*((word32) edi_383 - 364422))();
										ecxOut = ecx_897;
										edxOut = edx_896;
										ebxOut = ebx_797;
										ebpOut = ebp_379;
										ediOut = edi_383;
										return eax_895;
									}
								}
								goto l08075260;
							}
							goto l080750B8;
						}
						edx_475 = eax_405;
						eax_476 = 0x7FFFFFFF - dwLoc0470_1122;
						ecx_477 = eax_427;
						if (eax_476 < v30_436)
						{
l08076520:
							edx_1959 = ϕ(edx_673, edx_538, edx_600, edx_475);
							dwLoc04B4_1900 = ϕ(dwLoc04B4_1347, dwLoc04B4_1192, dwLoc04B4_1192, dwLoc04B4_1162);
							dwLoc0498_1864 = ϕ(dwLoc0498_1232, dwLoc0498_1225, dwLoc0498_1205, dwLoc0498_1165);
							dwLoc04AC_1860 = ϕ(dwLoc04AC_1131, dwLoc04AC_1193, dwLoc04AC_1193, dwLoc04AC_1163);
							ecx_998 = ϕ(ecx_676, ecx_533, ecx_565, ecx_477);
							esp_989 = esp_394;
							gs->tFFFFFFE0.u0 = 0x4B;
							goto l08075098;
						}
						v42_481 = dwLoc0470_1122 + v30_436;
						dwLoc0470_1166 = v42_481;
						goto l080766A2;
					}
				}
			}
			goto l08075098;
		}
		eax_244 = __printf_function_table;
		dwLoc04E0_1082 = eax_244;
		if (eax_244 != null)
		{
			dwLoc04B8_1083 = 0x00;
			dwLoc04E0_1084 = null;
			dwLoc04D4_1085 = ~0x00;
			goto l08074FB4;
		}
		ecx_252 = __printf_modifier_table;
		if (ecx_252 == 0x00)
		{
			eax_256 = __printf_va_arg_table;
			if (eax_256 == 0x00)
			{
				dwLoc04F0_1088.u0 = 0x00;
				dwLoc04B8_1089 = 0x00;
				dwLoc04D4_1090 = ~0x00;
				dwLoc0498_1863 = ϕ(dwLoc0498_1020, dwLoc0498_1281);
				dwLoc0478_1815 = ϕ(dwLoc0478_1807, dwLoc0478_1820);
				dwLoc0470_1533 = ϕ(dwLoc0470_1072, dwLoc0470_1663);
				dwLoc0488_1512 = ϕ(dwLoc0488_1030, dwLoc0488_1517);
				dwLoc04D4_1467 = ϕ(dwLoc04D4_1090, dwLoc04D4_1472);
				dwLoc04E0_1422 = ϕ(dwLoc04E0_1082, dwLoc04E0_1427);
				dwLoc04B4_1416 = ϕ(dwLoc04B4, dwLoc04B4_1345);
				dwLoc04B8_1413 = ϕ(dwLoc04B8_1089, dwLoc04B8_1276);
				dwLoc048C_1411 = ϕ(dwLoc048C_1041, dwLoc048C_1177);
				dwLoc0490_1409 = ϕ(dwLoc0490_1040, dwLoc0490_1169);
				dwLoc04A8_1405 = ϕ(dwLoc04A8, dwLoc04A8_1153);
				dwLoc04AC_1403 = ϕ(dwLoc04AC, dwLoc04AC_1280);
				dwLoc04F0_1377 = ϕ(dwLoc04F0_1088, dwLoc04F0_1382);
				ecx_997 = ϕ(ecx_252, ecx_939);
				edi_814 = ϕ(edi_12, edi_383);
				esp_810 = fp;
				esi_285 = ϕ(esi_21, esi_388);
				ebp_270 = fp - 4;
				edx_268 = ϕ(edx_241, edx_934);
				eax_269 = (word32) edx_268 + 1;
				dwLoc0460_1092 = eax_269;
				ebx_272 = (word32) *((word32) edx_268 + 1);
				bl_278 = (byte) ebx_272;
				al_274 = (byte) ebx_272 - 0x20;
				if (al_274 <= 0x5A)
				{
					eax_963 = (int32) bl_278;
					ecx_964 = (word32) edi_814 - 115200;
					eax_967 = (word32) ((word32) edi_814 - 115232 + eax_963);
					ecx_969 = (word32) edi_814 - 0x00001440;
					eax_971 = ecx_969[eax_967];
					eax_971();
					ecxOut = ecx_987;
					edxOut = edx_986;
					ebxOut = ebx_272;
					ebpOut = ebp_270;
					ediOut = edi_814;
					return eax_985;
				}
				dwLoc0494_1093.u0 = 0x00;
				if (bl_278 != 0x00)
				{
l08075260:
					dwLoc0478_1814 = ϕ(dwLoc0478_1815, dwLoc0478_1820);
					dwLoc0470_1532 = ϕ(dwLoc0470_1533, dwLoc0470_1534);
					dwLoc0488_1511 = ϕ(dwLoc0488_1512, dwLoc0488_1517);
					dwLoc04D4_1466 = ϕ(dwLoc04D4_1467, dwLoc04D4_1472);
					dwLoc04E0_1421 = ϕ(dwLoc04E0_1422, dwLoc04E0_1427);
					dwLoc04B4_1415 = ϕ(dwLoc04B4_1416, dwLoc04B4_1375);
					dwLoc0460_1414 = ϕ(dwLoc0460_1092, dwLoc0460_1340);
					dwLoc04B8_1412 = ϕ(dwLoc04B8_1413, dwLoc04B8_1336);
					dwLoc048C_1410 = ϕ(dwLoc048C_1411, dwLoc048C_1177);
					dwLoc0490_1408 = ϕ(dwLoc0490_1409, dwLoc0490_1169);
					dwLoc04A8_1404 = ϕ(dwLoc04A8_1405, dwLoc04A8_1153);
					dwLoc04AC_1402 = ϕ(dwLoc04AC_1403, dwLoc04AC_1314);
					dwLoc0494_1395 = ϕ(dwLoc0494_1093, dwLoc0494_1374);
					dwLoc04F0_1376 = ϕ(dwLoc04F0_1377, dwLoc04F0_1382);
					ebx_870 = ϕ(ebx_272, ebx_797);
					esi_818 = ϕ(esi_285, esi_388);
					edi_813 = ϕ(edi_814, edi_383);
					esp_809 = fp;
					dwLoc0498_1394 = dwLoc04F0_1376;
					if (dwLoc0494_1395 != 0x00)
					{
						ebx_815 = edi_813;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						free(gs, stackArg0, dwLoc0494_1395, out ecx_2014, out edx_2015);
						esp_826 = fp;
					}
l08074FB4:
					dwLoc0478_1812 = ϕ(dwLoc0478_1807, dwLoc0478_1814, dwLoc0478_1814, dwLoc0478_1807);
					dwLoc04F0_1623 = ϕ(dwLoc04F0, dwLoc04F0_1376, dwLoc04F0_1376, dwLoc04F0);
					dwLoc04B4_1607 = ϕ(dwLoc04B4, dwLoc04B4_1415, dwLoc04B4_1415, dwLoc04B4);
					dwLoc0460_1605 = ϕ(dwLoc0460_1031, dwLoc0460_1414, dwLoc0460_1414, dwLoc0460_1031);
					dwLoc0494_1597 = ϕ(dwLoc0494, dwLoc0494_1395, dwLoc0494_1395, dwLoc0494);
					dwLoc048C_1594 = ϕ(dwLoc048C_1041, dwLoc048C_1410, dwLoc048C_1410, dwLoc048C_1041);
					dwLoc0490_1591 = ϕ(dwLoc0490_1040, dwLoc0490_1408, dwLoc0490_1408, dwLoc0490_1040);
					dwLoc04A8_1575 = ϕ(dwLoc04A8, dwLoc04A8_1404, dwLoc04A8_1404, dwLoc04A8);
					dwLoc04AC_1567 = ϕ(dwLoc04AC, dwLoc04AC_1402, dwLoc04AC_1402, dwLoc04AC);
					dwLoc0470_1530 = ϕ(dwLoc0470_1072, dwLoc0470_1532, dwLoc0470_1532, dwLoc0470_1072);
					dwLoc04B8_1529 = ϕ(dwLoc04B8_1086, dwLoc04B8_1412, dwLoc04B8_1412, dwLoc04B8_1083);
					dwLoc0488_1509 = ϕ(dwLoc0488_1030, dwLoc0488_1511, dwLoc0488_1511, dwLoc0488_1030);
					dwLoc04D4_1465 = ϕ(dwLoc04D4_1087, dwLoc04D4_1466, dwLoc04D4_1466, dwLoc04D4_1085);
					dwLoc0498_1439 = ϕ(dwLoc0498_1020, dwLoc0498_1394, dwLoc0498_1394, dwLoc0498_1020);
					dwLoc04E0_1419 = ϕ(dwLoc04E0_1082, dwLoc04E0_1421, dwLoc04E0_1421, dwLoc04E0_1084);
					ebx_868 = ϕ(ebx_178, ebx_870, ebx_815, ebx_178);
					edi_866 = ϕ(edi_12, edi_813, edi_813, edi_12);
					esi_860 = ϕ(esi_21, esi_818, esi_818, esi_21);
					esp_828 = ϕ(esp_238, esp_809, esp_826, esp_238);
					esp_830 = esp_828 - 0x0C;
					esp_830->ptrFFFFFFFC = dwLoc04E0_1419;
					esp_830->dwFFFFFFF8 = dwLoc04D4_1465;
					esp_830->tFFFFFFF4 = eax_31;
					esp_830->ptrFFFFFFF0 = fp - 0x0408;
					esp_830->tFFFFFFEC = dwLoc0488_1509;
					esp_830->dwFFFFFFE8 = dwLoc04B8_1529;
					esp_830->tFFFFFFE4 = dwLoc0470_1530;
					esp_830->ptrFFFFFFE0 = fp - 1116;
					esp_830->tFFFFFFDC = dwArg0C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg0.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg20.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg24.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg28.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg32.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg36.u0 = <invalid>;
					eax_875 = printf_positional(ebx_868, gs, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, out ecx_877, out edx_876);
					esp_879 = (char *) &esp_830->ptrFFFFFFFC + 16;
					dwLoc0470_1631 = eax_875;
					esi_882 = esi_860;
					goto l08075010;
				}
				gs->tFFFFFFE0.u0 = 22;
				esi_286 = esi_285;
l08075098:
				edx_1958 = ϕ(edx_268, edx_410, edx_432, edx_673, edx_1959, edx_530, edx_562, edx_465);
				dwLoc0488_1934 = ϕ(dwLoc0488_1512, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517);
				dwLoc04D4_1927 = ϕ(dwLoc04D4_1467, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472);
				dwLoc04E0_1914 = ϕ(dwLoc04E0_1422, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427);
				dwLoc04F0_1905 = ϕ(dwLoc04F0_1377, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382);
				dwLoc04B4_1899 = ϕ(dwLoc04B4_1416, dwLoc04B4_1347, dwLoc04B4_1347, dwLoc04B4_1347, dwLoc04B4_1900, dwLoc04B4_1192, dwLoc04B4_1192, dwLoc04B4_1162);
				dwLoc0460_1896 = ϕ(dwLoc0460_1092, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289);
				dwLoc04B8_1893 = ϕ(dwLoc04B8_1413, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266);
				dwLoc048C_1875 = ϕ(dwLoc048C_1411, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177);
				dwLoc0490_1872 = ϕ(dwLoc0490_1409, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169);
				dwLoc04A8_1866 = ϕ(dwLoc04A8_1405, dwLoc04A8_1146, dwLoc04A8_1146, dwLoc04A8_1153, dwLoc04A8_1153, dwLoc04A8_1153, dwLoc04A8_1153, dwLoc04A8_1153);
				dwLoc0498_1862 = ϕ(dwLoc0498_1863, dwLoc0498_1138, dwLoc0498_1145, dwLoc0498_1232, dwLoc0498_1864, dwLoc0498_1165, dwLoc0498_1205, dwLoc0498_1165);
				dwLoc04AC_1859 = ϕ(dwLoc04AC_1403, dwLoc04AC_1131, dwLoc04AC_1131, dwLoc04AC_1131, dwLoc04AC_1860, dwLoc04AC_1193, dwLoc04AC_1193, dwLoc04AC_1163);
				dwLoc0478_1830 = ϕ(dwLoc0478_1815, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820);
				dwLoc0494_1095 = ϕ(dwLoc0494_1093, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254);
				ecx_996 = ϕ(ecx_997, ecx_407, ecx_434, ecx_676, ecx_998, ecx_533, ecx_565, ecx_466);
				esi_301 = ϕ(esi_286, esi_388, esi_388, esi_388, esi_388, esi_388, esi_388, esi_388);
				edi_299 = ϕ(edi_814, edi_383, edi_383, edi_383, edi_383, edi_383, edi_383, edi_383);
				esp_293 = ϕ(esp_810, esp_409, esp_431, esp_677, esp_989, esp_534, esp_566, esp_468);
				ebx_289 = dwLoc0494_1095;
				if (dwLoc0494_1095 != 0x00)
				{
					esp_294 = esp_293 - 0x0C;
					esp_294->tFFFFFFFC = dwLoc0494_1095;
					ebx_300 = edi_299;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg0.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg4.u0 = <invalid>;
					free(gs, stackArg0, stackArg4, out ecx_306, out edx_305);
					esp_308 = (char *) &esp_294->tFFFFFFFC + 16;
					esi_310 = esi_301;
				}
				goto l080750B8;
			}
		}
		dwLoc04B8_1086 = 0x00;
		dwLoc04D4_1087 = ~0x00;
		goto l08074FB4;
	}
}

// 08077700: Register Eq_2 buffered_vfprintf(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      vfprintf
Eq_2 buffered_vfprintf(Eq_2 eax, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 dwLoc20E4_337;
	Eq_2175 eax_30 = gs->t0014;
	Eq_2 eax_33 = *((word32) eax + 0x0068);
	if (eax_33 == 0x00)
		((word32) eax + 0x0068)->u0 = ~0x00;
	else if (eax_33 != ~0x00)
	{
		dwLoc20E4_337.u0 = ~0x00;
l0807787A:
		if ((eax_30 ^ gs->t0014) != 0x00)
		{
			word32 ecx_478;
			word32 edx_479;
			__stack_chk_fail(out ecx_478, out edx_479);
		}
		else
		{
			ecxOut = ecx;
			edxOut = edx;
			return dwLoc20E4_337;
		}
	}
	Eq_2 ecx_75;
	Eq_2 edx_76;
	word32 ebx_475;
	word32 ebp_476;
	word32 edi_477;
	Eq_2 eax_74 = vfprintf(0x080CE000, gs, fp - 0x20C8, edx, ecx, out ecx_75, out edx_76, out ebx_475, out ebp_476, out edi_477);
	dwLoc20E4_337 = eax_74;
	Eq_77540 ebp_145;
	Mem104 = Mem86;
	edx = edx_76;
	ecx = ecx_75;
	ui32 eax_105 = *eax;
	if ((eax_105 & 0x8000) != 0x00)
	{
		ebp_145 = fp - 0x2020 - (fp - 0x2020);
		if (ebp_145 <= 0x00)
			goto l08077864;
	}
	else
	{
		edx = *((word32) eax + 72);
		Eq_2 ebp_112 = gs->t0008;
		if (*((word32) edx + 8) != ebp_112)
		{
			ecx.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_122;
			if (!__cmpxchg(*edx, 0x01, eax_105 & 0x8000, out eax_122))
				ecx = __lll_lock_wait_private(eax_122, edx, gs);
			edx = *((word32) eax + 72);
			*((word32) edx + 8) = ebp_112;
		}
		*((word32) edx + 4) = (word32) *((word32) edx + 4) + 1;
		ebp_145 = fp - 0x2020 - (fp - 0x2020);
		if (ebp_145 <= 0x00)
		{
l08077835:
			if ((*eax & 0x8000) == 0x00)
			{
				edx = *((word32) eax + 72);
				word32 v20_231 = *((word32) edx + 4) - 0x01;
				*((word32) edx + 4) = v20_231;
				if (v20_231 == 0x00)
				{
					((word32) edx + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					Eq_2 v21_242 = *edx - 0x01;
					*edx = v21_242;
					if (v21_242 != 0x00)
						__lll_unlock_wake_private(edx, ecx, edx, gs);
				}
			}
l08077864:
			goto l0807787A;
		}
	}
	Eq_2 ecx_160 = *((word32) eax + 0x0094);
	Eq_2 eax_155 = 0x080CEFA0;
	word32 edx_165 = ecx_160 - 0x080CEFA0;
	if (ecx_160 >= 135066356)
	{
		word32 ecx_474;
		eax_155 = _IO_vtable_check(out ecx_474, out edx_165);
	}
	Eq_77540 eax_212;
	(*((word32) ecx_160 + 28))();
	Eq_2 eax_218 = ~0x00;
	if (eax_212 == ebp_145)
		eax_218 = eax_74;
	dwLoc20E4_337 = eax_218;
	goto l08077835;
}

// 08077940: Register Eq_77687 hack_digit(Register Eq_77687 eax, Register out Eq_2 ecxOut)
// Called from:
//      buffered_vfprintf
//      __printf_fp_l
Eq_77687 hack_digit(Eq_77687 eax, union Eq_2 & ecxOut)
{
	if (*eax != 0x00 && *((word32) eax + 4) == 0x66)
	{
		int32 edx_20 = *((word32) eax + 8);
		*((word32) eax + 8) = edx_20 - 0x01;
		if (edx_20 > 0x00)
		{
			ecxOut = edx_20 - 0x01;
			return 0x30;
		}
	}
	Eq_2 eax_36 = *((word32) eax + 24);
	Eq_2 ecx_105 = *((word32) eax + 16);
	Eq_2 esi_112 = *((word32) eax + 0x0C);
	if (eax_36 == 0x00)
	{
		union Eq_2 * ebx_42 = esi_112 - 0x04 + ecx_105 * 0x04;
		Eq_2 edi_44 = *ebx_42;
		Eq_2 ecx_57;
		*ebx_42 = (union Eq_2 *) __mpn_mul_1(esi_112, esi_112, ecx_105 - 0x01, 0x0A, out ecx_57);
		ecxOut = ecx_57;
		return (word32) edi_44 + 48;
	}
	else
	{
		Eq_77687 edi_113;
		if (eax_36 <= ecx_105)
		{
			uint32 eax_92 = __mpn_divrem(*((word32) eax + 28), 0x00, esi_112, ecx_105, *((word32) eax + 20), eax_36);
			Eq_77786 ecx_99[] = *((word32) eax + 28);
			ecx_99[*((word32) eax + 16) - *((word32) eax + 24)].u0 = eax_92;
			Eq_77786 edi_104 = ecx_99[0];
			ecx_105 = *((word32) eax + 24);
			*((word32) eax + 16) = ecx_105;
			if (ecx_105 == 0x00)
			{
l080779C3:
				*((word32) eax + 16) = 0x01;
				ecxOut = ecx_105;
				return edi_104 + 0x30;
			}
			esi_112 = *((word32) eax + 0x0C);
			edi_113 = edi_104 + 0x30;
			if ((esi_112 - 0x04)[ecx_105] == 0x00)
			{
				Eq_2 edx_118 = ecx_105 - 0x01;
				do
				{
					*((word32) eax + 16) = edx_118;
					ecx_105 = edx_118;
					if (edx_118 == 0x00)
						goto l080779C3;
					--edx_118;
				} while (*((word32) esi_112 + edx_118 * 0x04) == 0x00);
			}
		}
		else
			edi_113.u0->a0000 = 0x30;
		Eq_2 ecx_145;
		Eq_2 eax_144 = __mpn_mul_1(esi_112, esi_112, ecx_105, 0x0A, out ecx_145);
		if (eax_144 != 0x00)
		{
			Eq_2 edx_156 = *((word32) eax + 16);
			ecx_145 = *((word32) eax + 0x0C);
			*((word32) eax + 16) = (word32) edx_156 + 1;
			*((word32) ecx_145 + edx_156 * 0x04) = eax_144;
		}
		ecxOut = ecx_145;
		return edi_113;
	}
}

// 08077A50: Register Eq_2 _i18n_number_rewrite(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_77860) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      __printf_fp_l
Eq_2 _i18n_number_rewrite(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, struct Eq_77860 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	__align(fp - 4);
	struct Eq_72753 * eax_42 = wctrans(gs, 0x080B1CCC);
	Eq_2 eax_58 = __towctrans(0x2E, eax_42);
	__towctrans(44, eax_42);
	struct Eq_77860 * ebp_14 = fp - 0x0C;
	Eq_2 edi_143 = edx;
	Eq_2 esi_145 = eax;
	Eq_2 edx_152 = fp - 0x0464;
	if (eax_42 != null)
	{
		struct Eq_77889 * ebp_102;
		word32 esi_504;
		word32 edi_505;
		int32 eax_101 = wcrtomb(gs, fp - 0x4A, eax_58, fp - 0x0464, dwLoc0488, ecx, out ebp_102, out esi_504, out edi_505);
		Eq_2 edx_114 = ebp_102->tFFFFFB98;
		Eq_2 ecx_115 = ebp_102->tFFFFFB94;
		if (eax_101 != ~0x00)
			ebp_102 - 0x3E + eax_101 = (byte *) 0x00;
		else
			ebp_102->wFFFFFFC2 = 0x2E;
		ebp_102->tFFFFFB98 = edx_114;
		ebp_102->dwFFFFFBA8 = 0x00;
		ebp_102->dwFFFFFBAC = 0x00;
		int32 eax_139 = wcrtomb(gs, ebp_102 - 0x2D, ecx_115, edx_114, dwLoc0488, ecx, out ebp_14, out esi_145, out edi_143);
		edx_152 = ebp_14->tFFFFFB98;
		if (eax_139 != ~0x00)
			ebp_14 - 0x2D + eax_139 = (byte *) 0x00;
		else
			ebp_14->wFFFFFFD3 = 44;
	}
	ebp_14->dwFFFFFBAC = 0x0400;
	Eq_2 eax_166 = ebp_14 - 0x0448;
	ebp_14->tFFFFFB94 = eax_166;
	ebp_14->tFFFFFBA8 = eax_166;
	Eq_2 edi_163 = edi_143 - esi_145;
	word32 ecx_506;
	cu8 * edx_180;
	if (__libc_scratch_buffer_set_array_size(gs, edx_152, edi_163, 0x01, out ecx_506, out edx_180) != 0x00)
	{
		Eq_2 ecx_191 = ebp_14->tFFFFFBA8;
		ebp_14->tFFFFFB90 = ecx_191;
		Eq_2 eax_202 = __mempcpy(ecx_191, esi_145, edi_163, out edx_180);
		esi_145 = ebp_14->tFFFFFBA0;
		ebp_14->tFFFFFB8C = ebp_14 - 0x2D;
		Eq_2 ecx_217 = ebp_14->tFFFFFB90;
		ebp_14->tFFFFFB98.u0 = ~0x2F;
		edi_163 = eax_202;
l08077B69:
		for (--edi_163; ecx_217 <= edi_163; --edi_163)
		{
			int32 eax_227 = (int32) *edi_163;
			byte al_280 = (byte) eax_227;
			if ((byte) eax_227 <= 0x39)
			{
				ebp_14->tFFFFFBA0 = ecx_217;
				Eq_2 ebx_242 = (gs->*ebp_14->tFFFFFB98)->ptr0000->a0008[eax_227].t0000;
				word32 edx_510;
				word32 ecx_509;
				Eq_2 eax_245 = strlen(ebx_242, out ecx_509, out edx_510);
				ecx_217 = ebp_14->tFFFFFBA0;
				esi_145 -= eax_245;
				edx_180 = eax_245 - 0x01;
				if (eax_245 != 0x00)
				{
					do
					{
						Mem267[esi_145 + edx_180:byte] = Mem263[ebx_242 + edx_180:byte];
						--edx_180;
					} while (edx_180 != (cu8 *) ~0x00);
				}
				goto l08077B69;
			}
			edx_180 = ebp_14->ptrFFFFFBA4;
			if (edx_180 != null)
			{
				edx_180 = eax_227 & ~0x02;
				if (((byte) eax_227 & ~0x02) == 44)
				{
					Eq_2 ebx_282 = ebp_14 - 0x3E;
					if (al_280 != 0x2E)
						ebx_282 = ebp_14->tFFFFFB8C;
					ebp_14->tFFFFFBA0 = ecx_217;
					word32 edx_513;
					word32 ecx_512;
					Eq_2 eax_294 = strlen(ebx_282, out ecx_512, out edx_513);
					ecx_217 = ebp_14->tFFFFFBA0;
					esi_145 -= eax_294;
					edx_180 = eax_294 - 0x01;
					if (eax_294 != 0x00)
					{
						do
						{
							Mem315[esi_145 + edx_180:byte] = Mem311[ebx_282 + edx_180:byte];
							--edx_180;
						} while (edx_180 != (cu8 *) ~0x00);
					}
					goto l08077B69;
				}
			}
			*((word32) esi_145 - 1) = al_280;
			--esi_145;
		}
		Eq_2 eax_335 = ebp_14->tFFFFFBA8;
		if (eax_335 != ebp_14->tFFFFFB94)
		{
			word32 ecx_511;
			free(gs, dwLoc0498, eax_335, out ecx_511, out edx_180);
		}
	}
	if ((ebp_14->dwFFFFFFE4 ^ gs->t0014) != 0x00)
	{
		word32 edx_508;
		word32 ecx_507;
		Eq_2 eax_375 = __stack_chk_fail(out ecx_507, out edx_508);
		Eq_2 eax_386 = __guess_grouping.part.0(eax_375, edx_180);
		ebpOut = ebp_14;
		esiOut = esi_145;
		ediOut = edi_163;
		return eax_386;
	}
	else
	{
		struct Eq_77978 * esp_393 = ebp_14 - 0x0C;
		Eq_2 esi_396 = esp_393->t0004;
		Eq_2 edi_402 = esp_393->ptr0008->tFFFFFFF8;
		ebpOut = esp_393->ptr000C;
		esiOut = esi_396;
		ediOut = edi_402;
		return esi_145;
	}
}

// 08077D10: Register Eq_2 __guess_grouping.part.0(Register Eq_2 eax, Register (ptr32 cu8) edx)
// Called from:
//      _i18n_number_rewrite
//      __printf_fp_l
//      __guess_grouping
Eq_2 __guess_grouping.part.0(Eq_2 eax, cu8 * edx)
{
	Eq_2 ebx_10 = 0x00;
	word32 ecx_14 = (word32) *edx;
	do
	{
		Eq_2 esi_16 = (int32) (byte) ecx_14;
		if (eax <= esi_16)
			return ebx_10;
		ebx_10 = (word32) ebx_10 + 1;
		ecx_14 = CONVERT(Mem9[edx + ebx_10:byte], byte, word32);
		eax -= esi_16;
		ci8 cl_26 = (byte) ecx_14;
		if (cl_26 == 0x7F || cl_26 < 0x00)
			return ebx_10;
	} while (cl_26 != 0x00);
	return (word32) ebx_10 + (uint32) ((uint64) (eax - 0x01) /u esi_16);
}

// 08077D50: void __printf_fp_l(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg04, Stack (ptr32 Eq_11223) dwArg08, Stack (ptr32 Eq_78200) dwArg0C, Stack (ptr32 (ptr32 Eq_2)) dwArg10)
// Called from:
//      __printf_fp
void __printf_fp_l(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg04, struct Eq_11223 * dwArg08, struct Eq_78200 * dwArg0C, union Eq_2 ** dwArg10)
{
	Eq_2 ebx_2058;
	Eq_78203 edi_2346;
	Eq_2 esp_3814;
	Eq_2 dwLoc80_5422;
	Eq_2 dwLoc50_5423;
	struct Eq_11223 * dwLoc90_5364;
	ptr32 edi_250;
	Eq_2 edi_296;
	union Eq_2 * edx_162;
	struct Eq_11223 * ebx_101;
	__align(fp);
	ui32 eax_35 = (word32) dwArg0C->b000D;
	struct Eq_78220 * ebp_1126 = fp - 8;
	byte al_177 = (byte) eax_35;
	word16 eax_16_16_340 = SLICE(eax_35, word16, 16);
	struct Eq_11223 * esi_45 = (word32) dwArg0C->b000C;
	ui32 ecx_47 = SEQ(SLICE(eax_35, word24, 8), (byte) eax_35 >> 0x02);
	byte bl_54 = (byte) eax_35 & 0x01;
	if ((eax_35 & 0x01) == 0x00)
	{
		ebx_101 = esi_45;
		Eq_2 ecx_92 = dwArg08->t0004;
		if ((byte) esi_45 >= 0x00)
			goto l08077DF5;
		ebx_101 = (struct Eq_11223 *) *((word32) ecx_92 + 44);
		dwLoc90_5364 = ebx_101;
	}
	else
	{
		struct Eq_78246 * ecx_58 = dwArg08->ptr0010;
		*ecx_58->ptr002C != 0x00;
		ecx_58->dw00D0 != 0x00;
		ebx_101 = esi_45;
		if ((byte) esi_45 >= 0x00)
			goto l08077DF5;
		dwLoc90_5364 = ecx_58->ptr0034;
	}
	if (dwLoc90_5364->t0000 <= 0x7E && dwLoc90_5364->t0000 >= 0x01)
	{
		if ((ecx_47 & 0x01) != 0x00)
		{
			Eq_2 dwLocC0_5384;
			if (bl_54 == 0x00)
				dwLocC0_5384 = *((word32) dwArg08->t0004 + 52);
			else
			{
				ebx_101 = dwArg08;
				dwLocC0_5384 = dwArg08->ptr0010->t00D4;
			}
			edx_162 = (union Eq_2 *) *dwArg10;
			if ((al_177 & 0x10) != 0x00)
			{
l08077E1D:
				Eq_2 xmm2_399 = *edx_162;
				if (__unordtf2((word32) xmm2_399, SLICE(xmm2_399, word32, 32), SLICE(xmm2_399, word32, 64), SLICE(xmm2_399, word32, 96), (word32) xmm2_399, SLICE(xmm2_399, word32, 32), SLICE(xmm2_399, word32, 64), SLICE(xmm2_399, word32, 96)) == 0x00)
				{
					word128 xmm0_452 = __pand(xmm2_399, g_ow80B1ED0);
					word128 xmm3_453 = g_ow80B1EE0;
					if (__unordtf2((word32) xmm0_452, SLICE(xmm0_452, word32, 32), SLICE(xmm0_452, word32, 64), SLICE(xmm0_452, word32, 96), (word32) xmm3_453, SLICE(xmm3_453, word32, 32), SLICE(xmm3_453, word32, 64), SLICE(xmm3_453, word32, 96)) == 0x00 && __lttf2((word32) xmm0_452, SLICE(xmm0_452, word32, 32), SLICE(xmm0_452, word32, 64), SLICE(xmm0_452, word32, 96), (word32) xmm3_453, SLICE(xmm3_453, word32, 32), SLICE(xmm3_453, word32, 64), SLICE(xmm3_453, word32, 96)) > 0x00)
					{
						ui32 edx_3222 = dwArg0C->dw0008;
						ebx_2058 = SEQ(SLICE(0x080CE000, word24, 8), __movmskps(xmm2_399)) & 0x08;
						if ((gs->ptrFFFFFFF8[edx_3222].b0001 & 0x01) != 0x00)
							goto l08077EDB;
						goto l0807807E;
					}
					Eq_2 eax_504 = __mpn_extract_float128(fp - 0x34, fp - 88, fp - 100, xmm2_399);
					dwLoc80_5422 = eax_504;
					dwLoc50_5423 = eax_504;
					edi_296 = (eax_504 << 0x05) - 0x70;
l080783DA:
					ui32 eax_530 = ((dwLoc58 >> 0x1F ^ dwLoc58) - (dwLoc58 >> 0x1F) + 0x1F >> 0x05) * 0x04 + 0x3B;
					struct Eq_80667 * esp_536 = fp - 0x0100;
					struct Eq_80667 * edx_538 = fp - 0x0100 - (eax_530 & ~0x0FFF);
					if (fp - 0x0100 != edx_538)
					{
						do
						{
							esp_536 -= 0x1000;
							esp_536->dw0FFC = esp_536->dw0FFC;
						} while (esp_536 != edx_538);
					}
					if ((eax_530 & ~0x0F & 0x0FFF) != 0x00)
					{
						esp_536 -= eax_530 & ~0x0F & 0x0FFF;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					Eq_80709 edx_566 = (char *) esp_536 + 0x0F;
					struct Eq_80667 * edx_582 = esp_536 - (eax_530 & ~0x0FFF);
					while (esp_536 != edx_582)
					{
						esp_536 -= 0x1000;
						esp_536->dw0FFC = esp_536->dw0FFC;
					}
					if ((eax_530 & ~0x0F & 0x0FFF) != 0x00)
					{
						esp_536 -= eax_530 & ~0x0F & 0x0FFF;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					struct Eq_80667 * ecx_622 = esp_536 - (eax_530 & ~0x0FFF);
					while (esp_536 != ecx_622)
					{
						esp_536 -= 0x1000;
						esp_536->dw0FFC = esp_536->dw0FFC;
					}
					int32 eax_639 = eax_530 & ~0x0F & 0x0FFF;
					if (eax_639 != 0x00)
					{
						esp_536 -= eax_639;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[eax_639 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[eax_639 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					Eq_80842 eax_651 = (char *) esp_536 + 0x0F;
					if (dwLoc58 <= 0x02)
					{
						if (dwLoc58 >= 0x00)
						{
							struct Eq_81006 * esp_1243 = esp_536 - 4;
							esp_1243->t0000 = (word32) edi_296 + dwLoc58;
							esp_1243->tFFFFFFFC = dwLoc80_5422;
							esp_1243->tFFFFFFF8 = fp - 0x34;
							esp_1243->tFFFFFFF4 = edx_566 & ~0x0F;
							__mpn_lshift(esp_1243->tFFFFFFF4, esp_1243->tFFFFFFF8, esp_1243->tFFFFFFFC, esp_1243->t0000);
							(edx_566 & ~0x0F)[dwLoc50_5423] = eax_651 & ~0x0F;
							dwLoc58 = 0x00;
							goto l080787D0;
						}
						struct Eq_80966 * esp_672 = esp_536 - 4;
						esp_672->t0000 = edi_296;
						esp_672->tFFFFFFFC = dwLoc80_5422;
						esp_672->tFFFFFFF8 = fp - 0x34;
						esp_672->tFFFFFFF4 = edx_566 & ~0x0F;
						__mpn_lshift(esp_672->tFFFFFFF4, esp_672->tFFFFFFF8, esp_672->tFFFFFFFC, esp_672->t0000);
						(edx_566 & ~0x0F)[dwLoc50_5423] = eax_651 & ~0x0F;
						dwLoc58 = -dwLoc58;
						struct Eq_81004 * edi_1020 = &g_t80B4E70;
						do
						{
							edi_1020 -= 0x10;
							if (edi_1020->dw000C <= ebp_1126->ptrFFFFFF88)
							{
								ui32 ecx_770;
								word32 edx_773;
								int32 eax_735 = edi_1020->dw0004;
								Eq_2 edx_736 = ebp_1126->dwFFFFFFB8;
								Eq_2 ebx_737 = ebp_1126->ptrFFFFFFB4;
								Eq_2 ecx_738 = ebp_1126->dwFFFFFFC4;
								if (edx_736 >= eax_735 - 0x02)
								{
									struct Eq_81363 * esp_777 = esp_536 - 0x0C;
									word32 esi_779 = ebp_1126->dwFFFFFF80;
									esp_777->tFFFFFFFC = eax_735 - 0x02;
									esp_777->tFFFFFFF8 = esi_779 + ~0x00019157 + edi_1020->dw0000 * 0x04;
									esp_777->tFFFFFFF4 = edx_736;
									esp_777->tFFFFFFF0 = ebx_737;
									esp_777->tFFFFFFEC = ecx_738;
									word32 esi_9255;
									word32 eax_792 = __mpn_mul(gs, esp_777->tFFFFFFEC, esp_777->tFFFFFFF0, esp_777->tFFFFFFF4, esp_777->tFFFFFFF8, esp_777->tFFFFFFFC, out ebp_1126, out esi_9255, out edi_1020);
									ecx_770 = ebp_1126->dwFFFFFFB8;
									edx_773 = edi_1020->dw0004 + ecx_770;
									if (eax_792 == 0x00)
										goto l0807997B;
									goto l080798BC;
								}
								struct Eq_81291 * esp_743 = esp_536 - 0x0C;
								word32 esi_745 = ebp_1126->dwFFFFFF80;
								esp_743->tFFFFFFFC = edx_736;
								esp_743->tFFFFFFF8 = ebx_737;
								esp_743->tFFFFFFF4 = eax_735 - 0x02;
								esp_743->tFFFFFFF0 = esi_745 + ~0x00019157 + edi_1020->dw0000 * 0x04;
								esp_743->tFFFFFFEC = ecx_738;
								word32 esi_9254;
								word32 eax_759 = __mpn_mul(gs, esp_743->tFFFFFFEC, esp_743->tFFFFFFF0, esp_743->tFFFFFFF4, esp_743->tFFFFFFF8, esp_743->tFFFFFFFC, out ebp_1126, out esi_9254, out edi_1020);
								ecx_770 = ebp_1126->dwFFFFFFB8;
								edx_773 = edi_1020->dw0004 + ecx_770;
								if (eax_759 != 0x00)
								{
l080798BC:
									word32 eax_811 = edx_773 - 0x02;
									ebp_1126->dwFFFFFF4C = eax_811;
									ebp_1126->dwFFFFFFC8 = eax_811;
								}
								else
								{
l0807997B:
									word32 eax_816 = edx_773 - 0x03;
									ebp_1126->dwFFFFFF4C = eax_816;
									ebp_1126->dwFFFFFFC8 = eax_816;
								}
								word32 eax_822 = ebp_1126->dwFFFFFFC4;
								ebp_1126->tFFFFFF3C = eax_822;
								ui32 eax_825 = ebp_1126->dwFFFFFF4C;
								union Eq_936 * edx_826 = eax_822 - 0x04 + eax_825 * 0x04;
								word32 ebx_832 = __bsr(*edx_826);
								int32 eax_835 = ebp_1126->dwFFFFFFB0;
								ebp_1126->ptrFFFFFF88 = eax_835;
								ebp_1126->ptrFFFFFF68 = ebx_832 ^ 0x1F;
								int32 esi_839 = (eax_825 - ecx_770 << 0x05) + 0x1F - (ebx_832 ^ 0x1F);
								if (eax_835 + 0x03 != esi_839)
								{
									if (esi_839 > eax_835 + 0x02)
										goto l0807990F;
									goto l080799A0;
								}
								Eq_936 ecx_885;
								if ((ebx_832 ^ 0x1F) <= 0x1C)
								{
									ebp_1126->dwFFFFFFCC = 0x00;
									Eq_936 ebx_892 = 0x0A << 0x1C - ((byte) ebx_832 ^ 0x1F);
									ebp_1126->dwFFFFFFD0 = (word32) ebx_892;
									ecx_885 = ebx_892;
									if (esi_839 > eax_835 + 0x02)
										goto l08079A9E;
									goto l080799A0;
								}
								Eq_2 eax_846 = 0x20 - ebp_1126->ptrFFFFFF68;
								ebp_1126->dwFFFFFFCC = 0xA0000000;
								struct Eq_81718 * esp_852 = esp_536 - 4;
								esp_852->t0000 = eax_846;
								esp_852->tFFFFFFFC.u0 = 0x02;
								Eq_2 eax_854 = ebp_1126 - 0x34;
								esp_852->tFFFFFFF8 = eax_854;
								esp_852->tFFFFFFF4 = eax_854;
								ebp_1126->dwFFFFFFD0 = 0x00;
								__mpn_lshift(esp_852->tFFFFFFF4, esp_852->tFFFFFFF8, esp_852->tFFFFFFFC, esp_852->t0000);
								eax_835 = ebp_1126->dwFFFFFFB0;
								ebp_1126->ptrFFFFFF88 = eax_835;
								if (eax_835 + 0x02 < esi_839)
								{
									if (eax_835 + 0x03 != esi_839)
										goto l0807990F;
									int32 ecx_881 = ebp_1126->dwFFFFFFC8;
									Eq_83517 ebx_882 = ebp_1126->dwFFFFFFC4;
									ebp_1126->dwFFFFFF4C = ecx_881;
									ecx_885 = ebp_1126->dwFFFFFFD0;
									ebp_1126->tFFFFFF3C.u7 = ebx_882;
									edx_826 = ebx_882 - 0x04 + ecx_881 * 0x04;
l08079A9E:
									if (*edx_826 < ecx_885 || *edx_826 == ecx_885 && (ebp_1126->tFFFFFF3C - 0x08)[ebp_1126->dwFFFFFF4C] < ebp_1126->dwFFFFFFCC)
										goto l080799A0;
									ebp_1126->ptrFFFFFF88 = eax_835;
									goto l0807990F;
								}
								ebp_1126->tFFFFFF3C = ebp_1126->dwFFFFFFC4;
								ebp_1126->dwFFFFFF4C = ebp_1126->dwFFFFFFC8;
l080799A0:
								int32 eax_920 = eax_835 - esi_839;
								byte cl_928 = ebp_1126->tFFFFFF58;
								ebp_1126->ptrFFFFFF88 = eax_920;
								ebp_1126->dwFFFFFFB0 = eax_920;
								Eq_2 (* ecx_930)[] = ebp_1126->ptrFFFFFF68;
								ebp_1126->dwFFFFFF38 |= 0x01 << cl_928;
								Eq_2 (* eax_935)[] = ecx_930 - eax_920;
								union Eq_2 * esi_938 = ebp_1126->tFFFFFF3C;
								if (eax_920 >= 0x00)
									eax_935 = ecx_930;
								ui32 ebx_1011;
								Eq_2 edx_1059;
								Eq_2 ecx_1063;
								ui32 ecx_1012;
								ebp_1126->ptrFFFFFF68 = eax_935;
								Eq_2 eax_945 = *esi_938;
								if (eax_945 == 0x00)
								{
									ebp_1126->dwFFFFFF30 = edi_1020;
									struct Eq_82022 * eax_1005 = (char *) esi_938 + 4;
									ui32 esi_1002 = 0x00;
									while (true)
									{
										++eax_1005;
										ebx_1011 = esi_1002 + 0x01;
										Eq_2 edx_1009 = eax_1005->dwFFFFFFFC;
										ecx_1012 = ebx_1011;
										if (edx_1009 != 0x00)
											break;
										esi_1002 = ebx_1011;
									}
									ebp_1126->dwFFFFFF28 = eax_1005;
									edi_1020 = ebp_1126->dwFFFFFF30;
									if (ebp_1126->ptrFFFFFF68 != (Eq_2 (*)[]) 0x1F)
									{
										Eq_2 eax_1058 = __tzcnt(edx_1009);
										edx_1059 = ebp_1126->ptrFFFFFFB4;
										ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) eax_1058;
										Eq_2 eax_1062 = 0x1F - ebp_1126->ptrFFFFFF68;
										ecx_1063 = eax_1062;
										if (eax_1062 > ebp_1126->ptrFFFFFF88)
										{
											struct Eq_82270 * esp_1100 = esp_536 - 4;
											esp_1100->t0000 = eax_1062;
											esp_1100->tFFFFFFFC = ebp_1126->dwFFFFFF4C - esi_1002;
											esp_1100->tFFFFFFF8 = (word32) ebp_1126->tFFFFFF3C + esi_1002 * 0x04;
											esp_1100->tFFFFFFF4 = edx_1059;
											__mpn_rshift(esp_1100->tFFFFFFF4, esp_1100->tFFFFFFF8, esp_1100->tFFFFFFFC, esp_1100->t0000);
											ebp_1126->dwFFFFFFB8 = ebp_1126->dwFFFFFFC8 - esi_1002;
											ebp_1126->ptrFFFFFF88 = ebp_1126->dwFFFFFFB0;
											goto l0807990F;
										}
										ptr32 eax_1066 = ebp_1126->dwFFFFFF28;
										ebp_1126->dwFFFFFF4C -= ebx_1011;
										ebp_1126->tFFFFFF3C.u1 = eax_1066;
										goto l0807A2C0;
									}
									ebp_1126->dwFFFFFF4C -= ebx_1011;
									goto l0807A269;
								}
								Eq_2 (* ebx_949)[] = ebp_1126->ptrFFFFFF68;
								if (ebx_949 != (Eq_2 (*)[]) 0x1F)
								{
									Eq_2 eax_957 = __tzcnt(eax_945);
									edx_1059 = ebp_1126->ptrFFFFFFB4;
									ecx_1063 = 0x1F - ebx_949;
									ebx_1011 = 0x00;
									if (eax_957 < ecx_1063)
									{
										Eq_2 eax_963[] = ebp_1126->ptrFFFFFF68;
										struct Eq_82386 * esp_969 = esp_536 - 4;
										esp_969->t0000 = (char *) eax_963 + 1;
										esp_969->tFFFFFFFC = ebp_1126->dwFFFFFF4C;
										esp_969->tFFFFFFF8 = ebp_1126->tFFFFFF3C;
										esp_969->tFFFFFFF4 = edx_1059;
										__mpn_lshift(esp_969->tFFFFFFF4, esp_969->tFFFFFFF8, esp_969->tFFFFFFFC, esp_969->t0000);
										ui32 edx_985 = ebp_1126->dwFFFFFFC8;
										ebp_1126->dwFFFFFFB8 = edx_985 + 0x01;
										ebp_1126->ptrFFFFFFB4[edx_985] = (char *) eax_963 + 1;
										ebp_1126->ptrFFFFFF88 = ebp_1126->dwFFFFFFB0;
									}
									else
									{
l0807A2C0:
										struct Eq_82334 * esp_1073 = esp_536 - 4;
										esp_1073->t0000 = ecx_1063;
										esp_1073->tFFFFFFFC = ebp_1126->dwFFFFFF4C;
										esp_1073->tFFFFFFF8 = ebp_1126->tFFFFFF3C;
										esp_1073->tFFFFFFF4 = edx_1059;
										__mpn_rshift(esp_1073->tFFFFFFF4, esp_1073->tFFFFFFF8, esp_1073->tFFFFFFFC, esp_1073->t0000);
										ebp_1126->dwFFFFFFB8 = ebp_1126->dwFFFFFFC8 - ebx_1011;
										ebp_1126->ptrFFFFFF88 = ebp_1126->dwFFFFFFB0;
									}
								}
								else
								{
									ecx_1012 = 0x00;
									ebx_1011 = 0x00;
l0807A269:
									if (ebp_1126->dwFFFFFF4C > 0x00)
									{
										Eq_2 edx_1031[] = ebp_1126->ptrFFFFFFB4;
										Eq_2 ecx_1033[] = (word32) ebp_1126->tFFFFFF3C + ecx_1012 * 0x04;
										int32 eax_1034 = 0x00;
										do
										{
											edx_1031[eax_1034] = ecx_1033[eax_1034];
											++eax_1034;
											int32 esi_1049 = ebp_1126->dwFFFFFFC8 - ebx_1011;
										} while (esi_1049 > eax_1034);
										ebp_1126->dwFFFFFF4C = esi_1049;
									}
									ebp_1126->dwFFFFFFB8 = ebp_1126->dwFFFFFF4C;
								}
							}
l0807990F:
							ebp_1126->tFFFFFF58.u0 = ebp_1126->tFFFFFF58 - 0x01;
							if (edi_1020 == ebp_1126->tFFFFFF40)
							{
								if (ebp_1126->ptrFFFFFF88 > 0x00)
								{
									struct Eq_81624 * esp_1146 = esp_536 - 4;
									esp_1146->t0000.u0 = 0x0A;
									esp_1146->tFFFFFFFC = ebp_1126->dwFFFFFFB8;
									esp_1146->tFFFFFFF8 = ebp_1126->ptrFFFFFFB4;
									esp_1146->tFFFFFFF4 = ebp_1126->dwFFFFFFC4;
									word32 ecx_9256;
									__mpn_mul_1(esp_1146->tFFFFFFF4, esp_1146->tFFFFFFF8, esp_1146->tFFFFFFFC, esp_1146->t0000, out ecx_9256);
									Eq_2 edx_1164 = ebp_1126->dwFFFFFFB8;
									Eq_2 ebx_1165 = ebp_1126->dwFFFFFFC4;
									ebp_1126->dwFFFFFFC8 = (word32) edx_1164;
									Eq_2 eax_1168 = 0x04;
									Eq_2 ecx_1170 = __tzcnt(*ebx_1165);
									if (ebp_1126->dwFFFFFFB0 <= 0x04)
										eax_1168 = ebp_1126->dwFFFFFFB0;
									if (eax_1168 > ecx_1170)
									{
										esp_1146->t0000 = 0x20 - eax_1168;
										esp_1146->tFFFFFFFC = edx_1164;
										esp_1146->tFFFFFFF8 = ebx_1165;
										esp_1146->tFFFFFFF4 = ebp_1126->ptrFFFFFFB4;
										__mpn_lshift(esp_1146->tFFFFFFF4, esp_1146->tFFFFFFF8, esp_1146->tFFFFFFFC, esp_1146->t0000);
										if (eax_1168 != 0x00)
										{
											ui32 edx_1221 = ebp_1126->dwFFFFFFC8;
											ebp_1126->dwFFFFFFC8 = edx_1221 + 0x01;
											ebp_1126->ptrFFFFFFB4[edx_1221] = eax_1168;
										}
									}
									else
									{
										esp_1146->t0000 = eax_1168;
										esp_1146->tFFFFFFFC = edx_1164;
										esp_1146->tFFFFFFF8 = ebx_1165;
										esp_1146->tFFFFFFF4 = ebp_1126->ptrFFFFFFB4;
										__mpn_rshift(esp_1146->tFFFFFFF4, esp_1146->tFFFFFFF8, esp_1146->tFFFFFFFC, esp_1146->t0000);
									}
									word32 eax_1228 = ebp_1126->dwFFFFFFC8;
									ebp_1126->dwFFFFFF38 |= 0x01;
									ebp_1126->dwFFFFFFB8 = eax_1228;
								}
								break;
							}
						} while (ebp_1126->ptrFFFFFF88 > 0x00);
						ebp_1126->dwFFFFFFB0 = ebp_1126->dwFFFFFF38;
						goto l080787D0;
					}
					int32 ecx_1267 = (word32) edi_296 + dwLoc58;
					byte cl_1279 = (byte) ecx_1267;
					int32 eax_1270 = ecx_1267 + 0x1F;
					if (ecx_1267 >= 0x00)
						eax_1270 = ecx_1267;
					int32 edx_1323;
					int32 eax_1274 = eax_1270 >> 0x05;
					int32 ecx_1285 = ecx_1267;
					if ((cl_1279 & 0x1F) == 0x00)
					{
						word32 edi_1337[] = (edx_566 & ~0x0F) + eax_1274 * 0x04;
						ui32 eax_1339 = dwLoc80_5422 - 0x01;
						if (dwLoc80_5422 >= 0x01)
						{
							do
							{
								edi_1337[eax_1339] = (fp - 0x34)[eax_1339];
								--eax_1339;
							} while (eax_1339 != ~0x00);
						}
						edx_1323 = eax_1274;
					}
					else
					{
						uint32 eax_1288 = ecx_1267 >> 0x1F >> 0x1B;
						struct Eq_80895 * esp_1295 = esp_536 - 4;
						esp_1295->t0000 = (ecx_1267 + eax_1288 & 0x1F) - eax_1288;
						esp_1295->tFFFFFFFC = dwLoc80_5422;
						esp_1295->tFFFFFFF8 = fp - 0x34;
						Eq_2 eax_1297 = (edx_566 & ~0x0F) + eax_1274 * 0x04;
						esp_1295->tFFFFFFF4 = eax_1297;
						__mpn_lshift(esp_1295->tFFFFFFF4, esp_1295->tFFFFFFF8, esp_1295->tFFFFFFFC, esp_1295->t0000);
						ecx_1285 = (word32) edi_296 + dwLoc58;
						int32 edx_1319 = ecx_1285 + 0x1F;
						if (ecx_1285 >= 0x00)
							edx_1319 = ecx_1285;
						edx_1323 = edx_1319 >> 0x05;
						ui32 esi_1325 = (word32) dwLoc50_5423 + edx_1323;
						if (eax_1297 != 0x00)
							(edx_566 & ~0x0F)[esi_1325] = eax_1297;
					}
					int32 ebx_1399 = dwLoc58;
					int32 eax_1364 = 0x00;
					if (ecx_1285 > 0x1F)
					{
						do
						{
							(edx_566 & ~0x0F)[eax_1364] = 0x00;
							++eax_1364;
						} while (edx_1323 > eax_1364);
					}
					Eq_2 eax_1383 = 0x00;
					word32 edi_1385 = 0x0C;
					struct Eq_83629 * esi_1388 = &g_t80B4E70;
l080785F5:
					esi_1388 -= 0x10;
					if (ebp_1126->ptrFFFFFF88 + esi_1388->dw0008 / 4 - 0x01 > ebx_1399)
					{
l080785E3:
						--edi_1385;
						if (esi_1388 == ebp_1126->ptrFFFFFF68)
							goto l080786A3;
						goto l080785F2;
					}
					bool v162_5336;
					Eq_2 edx_1441;
					Eq_2 edx_1402 = ebp_1126->dwFFFFFFC4;
					if (eax_1383 != 0x00)
					{
						struct Eq_83687 * esp_1471 = esp_536 - 0x0C;
						Eq_83690 ecx_1474 = ebp_1126->tFFFFFF58;
						esp_1471->tFFFFFFFC = esi_1388->dw0004 - 0x02;
						esp_1471->tFFFFFFF8 = (word32) (esi_1388->t0000 * 0x04) + ((word32) ecx_1474 + 8);
						esp_1471->tFFFFFFF4 = eax_1383;
						esp_1471->tFFFFFFF0 = ebp_1126->ptrFFFFFFBC;
						esp_1471->tFFFFFFEC = edx_1402;
						word32 eax_1489 = __mpn_mul(gs, esp_1471->tFFFFFFEC, esp_1471->tFFFFFFF0, esp_1471->tFFFFFFF4, esp_1471->tFFFFFFF8, esp_1471->tFFFFFFFC, out ebp_1126, out esi_1388, out edi_1385);
						int32 edx_1502 = esi_1388->dw0004 + ebp_1126->dwFFFFFFC0;
						if (eax_1489 != 0x00)
						{
							ebp_1126->dwFFFFFFC8 = edx_1502 - 0x02;
							edx_1441 = edx_1502 - 0x02;
							v162_5336 = ebp_1126->dwFFFFFFB8 == edx_1502 - 0x02;
							if (ebp_1126->dwFFFFFFB8 > edx_1502 - 0x02)
								goto l08078650;
							goto l080785DA;
						}
						ebp_1126->dwFFFFFFC8 = edx_1502 - 0x03;
						edx_1441 = edx_1502 - 0x03;
					}
					else
					{
						ui32 eax_1410 = esi_1388->dw0004;
						if ((ebp_1126->ptrFFFFFF84->b000D & 0x10) == 0x00)
						{
							ui32 ebx_1445 = esi_1388->t0000;
							Eq_84567 ecx_1446 = ebp_1126->tFFFFFF58;
							ebp_1126->dwFFFFFFC8 = eax_1410;
							struct Eq_84574 * esp_1447 = esp_536 - 0x04;
							esp_1447->tFFFFFFFC = eax_1410 << 0x02;
							Mem1455[esp_1447 + -8:word32] = ecx_1446 + ebx_1445 * 0x04;
							esp_1447->tFFFFFFF4 = edx_1402;
							word32 ecx_9269;
							word32 edx_9270;
							memcpy(esp_1447->tFFFFFFF4, esp_1447->tFFFFFFF8, esp_1447->tFFFFFFFC, out ecx_9269, out edx_9270);
							edx_1441 = ebp_1126->dwFFFFFFC8;
						}
						else
						{
							ui32 ebx_1412 = esi_1388->t0000;
							Eq_84496 ecx_1413 = ebp_1126->tFFFFFF58;
							ebp_1126->dwFFFFFFC8 = eax_1410 + 0x02;
							struct Eq_84505 * esp_1416 = esp_536 - 0x04;
							esp_1416->tFFFFFFFC = eax_1410 + 0x02 << 0x02;
							Mem1425[esp_1416 + -8:word32] = ecx_1413 + ebx_1412 * 0x04;
							esp_1416->tFFFFFFF4 = (word32) edx_1402 + 8;
							word32 ecx_9267;
							word32 edx_9268;
							memcpy(esp_1416->tFFFFFFF4, esp_1416->tFFFFFFF8, esp_1416->tFFFFFFFC, out ecx_9267, out edx_9268);
							struct Eq_84540 * eax_1437 = ebp_1126->dwFFFFFFC4;
							eax_1437->dw0000 = 0x00;
							eax_1437->dw0004 = 0x00;
							edx_1441 = ebp_1126->dwFFFFFFC8;
							ebp_1126->dwFFFFFFB0 += 0x40;
						}
					}
					v162_5336 = ebp_1126->dwFFFFFFB8 == edx_1441;
					if (ebp_1126->dwFFFFFFB8 > edx_1441)
						goto l08078650;
l080785DA:
					if (!v162_5336)
					{
l080785E0:
						eax_1383 = ebp_1126->dwFFFFFFC0;
						goto l080785E3;
					}
					struct Eq_83872 * esp_1523 = esp_536 - 0x04;
					esp_1523->tFFFFFFFC = edx_1441;
					esp_1523->tFFFFFFF8 = ebp_1126->dwFFFFFFC4;
					esp_1523->tFFFFFFF4 = ebp_1126->ptrFFFFFFB4;
					int32 eax_1535 = __mpn_cmp(esp_1523->tFFFFFFF4, esp_1523->tFFFFFFF8, esp_1523->tFFFFFFFC);
					edx_1441 = ebp_1126->dwFFFFFFC8;
					if (eax_1535 < 0x00)
						goto l080785E0;
l08078650:
					ebp_1126->dwFFFFFFC0 = (word32) edx_1441;
					struct Eq_84334 * esp_1567 = esp_536 - 0x04;
					esp_1567->tFFFFFFFC = edx_1441 << 0x02;
					esp_1567->tFFFFFFF8 = ebp_1126->dwFFFFFFC4;
					esp_1567->tFFFFFFF4 = ebp_1126->ptrFFFFFFBC;
					word32 ecx_9265;
					word32 edx_9266;
					memcpy(esp_1567->tFFFFFFF4, esp_1567->tFFFFFFF8, esp_1567->tFFFFFFFC, out ecx_9265, out edx_9266);
					eax_1383 = ebp_1126->dwFFFFFFC0;
					ebp_1126->ptrFFFFFF88 = (__bsr((ebp_1126->ptrFFFFFFBC - 0x04)[eax_1383]) ^ ~0x1F) + (eax_1383 - 0x02 << 0x05);
					ebp_1126->dwFFFFFF4C |= 0x01 << (byte) edi_1385;
					--edi_1385;
					if (esi_1388 == ebp_1126->ptrFFFFFF68)
					{
l080786A3:
						ebp_1126->dwFFFFFFB0 = ebp_1126->dwFFFFFF4C;
						if (eax_1383 <= 0x00)
						{
l080787D0:
							word32 esi_2085;
							struct Eq_81045 * esi_1991 = ebp_1126->ptrFFFFFF84;
							ebp_1126->dwFFFFFF1C = esi_1991->dw0004;
							ui32 eax_1996 = esi_1991->dw0008;
							Eq_2 esi_2044 = esi_1991->t0000;
							int32 edi_2045 = gs->ptrFFFFFFF0[eax_1996];
							ebp_1126->tFFFFFF58.u2 = esi_2044;
							ebp_1126->dwFFFFFF18 = edi_2045;
							if ((byte) edi_2045 != 101)
							{
								if (ebp_1126->dwFFFFFF18 != 0x66)
								{
									Eq_2 edx_2103;
									Eq_2 esi_2098 = ebp_1126->tFFFFFF58;
									if (esi_2098 >= 0x00)
									{
										if (esi_2098 != 0x00)
										{
											ebp_1126->dwFFFFFF10 = (int32) esi_2098;
											edx_2103 = esi_2098;
										}
										else
										{
											ebp_1126->dwFFFFFF10 = 0x01;
											edx_2103.u0 = 0x01;
										}
									}
									else
									{
										ebp_1126->dwFFFFFF10 = 0x06;
										edx_2103.u0 = 0x06;
									}
									int32 ecx_2112 = ebp_1126->dwFFFFFFB0;
									if (ebp_1126->dwFFFFFFA8 != 0x00)
									{
										if (ecx_2112 <= 0x04)
										{
											Eq_81238 eax_2143 = ebp_1126->dwFFFFFF10;
											ebp_1126->dwFFFFFFAC = 0x66;
											ebp_1126->dwFFFFFF4C = 0x00;
											ebp_1126->tFFFFFF58 = eax_2143;
											ebx_2058 = edx_2103;
											goto l08078866;
										}
									}
									else if (ebp_1126->dwFFFFFF10 > ecx_2112)
									{
										ebp_1126->dwFFFFFFAC = 0x66;
										ebp_1126->dwFFFFFF4C = ecx_2112 + 0x01;
										Eq_2 eax_2123 = ebp_1126->dwFFFFFF10 - (ecx_2112 + 0x01);
										ebp_1126->tFFFFFF58.u2 = eax_2123;
										ebx_2058 = eax_2123;
l08078866:
										ebp_1126->dwFFFFFF30 = (int32) ((byte) edx_2103.u0 + 5);
l0807886F:
										esi_2085 = 0x00;
										Eq_81253 eax_2158 = ebp_1126->tFFFFFF58;
										if ((ebp_1126->ptrFFFFFF84->b000C & 0x08) == 0x00)
											eax_2158.u1 = 0x00;
										ebp_1126->dwFFFFFF38 = (int32) eax_2158;
l08078887:
										ebp_1126->dwFFFFFF28 = 0x00;
										cu8 * ecx_2166 = ebp_1126->ptrFFFFFF78;
										if (ecx_2166 != null)
										{
											word32 eax_2170 = (word32) *ecx_2166;
											ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) (byte) eax_2170;
											Eq_2 eax_2174 = 0x00;
											if ((byte) eax_2170 <= 0x7E && (byte) eax_2170 >= 0x01)
											{
												eax_2174 = __guess_grouping.part.0(ebp_1126->dwFFFFFF4C, ecx_2166);
												ebp_1126->dwFFFFFF28 = (ui32) eax_2174;
											}
											ebp_1126->dwFFFFFF30 = (word32) eax_2174 + (ebp_1126->dwFFFFFF30 + 0x01);
										}
										Eq_2 eax_2196 = ebp_1126->dwFFFFFF30;
										if (eax_2196 > 0x3FFFFFFC || eax_2196 < ebx_2058)
										{
											gs->tFFFFFFE0.u0 = 0x22;
											goto l080782CA;
										}
										struct Eq_81812 * esp_2245 = esp_536 - 0x0C;
										Eq_2 ebx_2247 = ebp_1126->dwFFFFFF30 * 0x04 + 0x08;
										esp_2245->tFFFFFFFC = ebx_2247;
										up32 eax_2250 = __libc_alloca_cutoff(gs, esp_2245->tFFFFFFFC);
										Eq_2 esp_2256 = (char *) &esp_2245->tFFFFFFFC + 16;
										if (ebx_2247 > 0x1000 && eax_2250 == 0x00)
										{
											esp_2245->tFFFFFFFC = ebx_2247;
											word32 ecx_9257;
											word32 edx_9258;
											word32 edi_9259;
											Eq_2 eax_2267 = __libc_malloc(gs, esp_2245->tFFFFFFF8, esp_2245->tFFFFFFFC, out ecx_9257, out edx_9258, out ebx_2058, out ebp_1126, out esi_2085, out edi_9259);
											ebp_1126->ptrFFFFFF20 = (struct Eq_152302 *) eax_2267;
											esp_2256 = (char *) &esp_2245->tFFFFFFFC + 16;
											if (eax_2267 == 0x00)
												goto l08078BC0;
											ebp_1126->dwFFFFFF14 = 0x00;
										}
										else
										{
											Eq_2 edx_2290 = (char *) &esp_2245->tFFFFFFFC + 16 - ((word32) ebx_2247 + 27 & ~0x0FFF);
											ui32 eax_2291 = (word32) ebx_2247 + 27 & ~0x0F;
											if ((char *) &esp_2245->tFFFFFFFC + 16 != edx_2290)
											{
												do
												{
													esp_2256 -= 0x1000;
													*((word32) esp_2256 + 0x0FFC) = *((word32) esp_2256 + 0x0FFC);
												} while (esp_2256 != edx_2290);
											}
											if ((eax_2291 & 0x0FFF) != 0x00)
											{
												esp_2256 -= eax_2291 & 0x0FFF;
												Mem2314[esp_2256 - 0x04 + (eax_2291 & 0x0FFF):word32] = Mem2311[esp_2256 - 0x04 + (eax_2291 & 0x0FFF):word32];
											}
											ebp_1126->dwFFFFFF14 = 0x01;
											Mem2327[ebp_1126 + -224:word32] = esp_2256 + 0x0F & ~0x0F;
										}
										Eq_82165 ebx_2401;
										up32 edi_2331 = ebp_1126->dwFFFFFFA8;
										ebp_1126->tFFFFFF40 = ebp_1126->ptrFFFFFF20->a0008;
										if (edi_2331 != 0x00 && ebp_1126->dwFFFFFFAC == 0x66)
										{
											struct Eq_82058 * eax_2339 = ebp_1126->ptrFFFFFF20;
											word32 ebx_2340 = ebp_1126->dwFFFFFF50;
											ebp_1126->dwFFFFFF24 = 0x00;
											--ebp_1126->dwFFFFFFB0;
											eax_2339->dw0008 = 0x30;
											eax_2339->dw000C = ebx_2340;
											ebp_1126->ptrFFFFFF68 = ebp_1126 - 88;
											edi_2346 = &eax_2339->dw000C + 1;
											goto l08078A02;
										}
										Eq_78203 eax_2358;
										int32 esi_2352 = ebp_1126->dwFFFFFF4C;
										ebp_1126->dwFFFFFF24 = 0x00;
										ebp_1126->ptrFFFFFF68 = ebp_1126 - 88;
										if (esi_2352 > 0x00)
										{
											struct Eq_82095 * ebx_2359 = ebp_1126->ptrFFFFFF20;
											Eq_77687 edi_2360 = ebp_1126->ptrFFFFFF68;
											ui32 esi_2364 = 0x00;
											do
											{
												++esi_2364;
												word32 ecx_9260;
												ebx_2359->a0004[esi_2364] = hack_digit(edi_2360, out ecx_9260);
											} while (ebp_1126->dwFFFFFF4C != esi_2364);
											ebp_1126->dwFFFFFF24 = esi_2364;
											eax_2358 = (word32) ebp_1126->tFFFFFF40 + ebp_1126->dwFFFFFF4C * 0x04;
										}
										else
											eax_2358 = ebp_1126->tFFFFFF40;
										if ((ebp_1126->ptrFFFFFF84->b000C & 0x08) == 0x00 && ebp_1126->dwFFFFFF38 <= 0x00)
										{
											if (ebp_1126->tFFFFFF58 <= 0x00)
											{
												ebp_1126->tFFFFFF3C.u1 = 0x00;
												edi_2346 = eax_2358;
												ebx_2401.u0 = 0x00;
												goto l08078DC5;
											}
											if (ebp_1126->dwFFFFFFB8 <= 0x01 && (ebp_1126->ptrFFFFFFB4)[0] == 0x00)
											{
												edi_2346 = eax_2358;
												esi_2085 = 0x01;
l08078A02:
												int32 eax_2422 = ebp_1126->dwFFFFFF38;
												ebp_1126->tFFFFFF3C.u1 = 0x00;
												ebp_1126->ptrFFFFFF88 = eax_2422;
												ebx_2401.u0 = 0x00;
l08078A17:
												if (ebp_1126->ptrFFFFFF88 > ebx_2401)
												{
l08078A32:
													do
													{
														edi_2346 += 0x04;
														word32 ecx_9261;
														int32 eax_3189 = hack_digit(ebp_1126->ptrFFFFFF68, out ecx_9261);
														*((word32) edi_2346 - 4) = eax_3189;
														ebx_2401 = (word32) ebx_2401.u0 + 1;
														if (esi_2085 == 0x00 && eax_3189 == 0x30)
														{
															int32 eax_3203 = ebp_1126->dwFFFFFF38;
															ebp_1126->tFFFFFF58 = (word32) ebp_1126->tFFFFFF58 + 1;
															if (eax_3203 > 0x00)
															{
																ebp_1126->tFFFFFF3C = (word32) ebp_1126->tFFFFFF3C + 1;
																ebp_1126->ptrFFFFFF88 = (word32) ebp_1126->tFFFFFF3C + eax_3203;
															}
															goto l08078A17;
														}
														esi_2085 = 0x01;
													} while (ebp_1126->ptrFFFFFF88 > ebx_2401);
													goto l08078A1C;
												}
l08078A1C:
												if (ebp_1126->tFFFFFF58 > ebx_2401 && (ebp_1126->dwFFFFFFB8 > 0x01 || (ebp_1126->ptrFFFFFFB4)[0] != 0x00))
													goto l08078A32;
l08078DC5:
												int32 eax_2448 = *((word32) edi_2346 - 4);
												ebp_1126->ptrFFFFFF88 = eax_2448;
												if (eax_2448 == ebp_1126->dwFFFFFF50)
													ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) *((word32) edi_2346 - 8);
												word32 ecx_2459;
												int32 eax_2458 = hack_digit(ebp_1126->ptrFFFFFF68, out ecx_2459);
												int8 cl_2468 = (int8) (eax_2458 != 0x30);
												byte dl_2472 = (int8) (eax_2458 != 0x35) & cl_2468;
												Eq_2 ecx_2486 = SEQ(SLICE(ecx_2459, word24, 8), cl_2468);
												if (dl_2472 == 0x00)
												{
													Eq_2 (* eax_2476)[] = ebp_1126->dwFFFFFFB8;
													if (eax_2476 != (Eq_2 (*)[]) 0x01)
													{
														ecx_2486 = ebp_1126->dwFFFFFFC0;
														if (ecx_2486 == 0x00)
														{
															ebp_1126->ptrFFFFFF68 = eax_2476;
															if (eax_2476 != null)
															{
																ecx_2486 = ebp_1126->ptrFFFFFFB4;
																do
																{
																	if ((ecx_2486 - 0x04)[eax_2476] != 0x00)
																		goto l08079618;
																	--eax_2476;
																} while (eax_2476 != null);
															}
														}
														else
														{
l08079618:
															dl_2472 = 0x01;
														}
													}
													else if (ebp_1126->ptrFFFFFFB4[0] != 0x00)
														dl_2472 = 0x01;
												}
												Eq_82165 edx_2586;
												Eq_78203 eax_2563;
												ebp_1126->wFFFFFFA2 = __fstcw();
												cui16 ax_2511 = ebp_1126->wFFFFFFA2;
												if ((ax_2511 & 0x0C00) == 0x0400)
												{
													if (ebp_1126->dwFFFFFFA4 == 0x00)
														goto l08078E70;
													goto l08078E5C;
												}
												else
												{
													if ((ax_2511 & 0x0C00) > 0x0400)
													{
														if ((ax_2511 & 0x0C00) == 0x0800)
														{
															if (ebp_1126->dwFFFFFFA4 != 0x00)
																goto l08078E70;
l08078E5C:
															if (eax_2458 > 0x34)
																goto l08079368;
															goto l08078E65;
														}
														if ((ax_2511 & 0x0C00) == 0x0C00)
															goto l08078E70;
													}
													else if ((ax_2511 & 0x0C00) == 0x00)
													{
														if (eax_2458 <= 0x34)
														{
l08078E70:
															edx_2586 = (word32) ebp_1126->tFFFFFF3C + ebp_1126->dwFFFFFF38;
															goto l08078E7C;
														}
														if ((ebp_1126->ptrFFFFFF88 & 0x01) != 0x00)
														{
l08079368:
															Eq_78203 eax_2585;
															eax_2563 = edi_2346 - (struct Eq_82649 *) 0x04;
															word32 esi_2567 = *((word32) edi_2346 - 4);
															Eq_78203 ecx_2568 = eax_2563;
															if (ebx_2401 == 0x00)
															{
																eax_2585 = edi_2346;
																edx_2586 = (word32) ebp_1126->tFFFFFF3C + ebp_1126->dwFFFFFF38;
																goto l08079B76;
															}
															word32 esi_2622;
															int32 edx_2588 = 0x00;
															if (esi_2567 != ebp_1126->dwFFFFFF50)
															{
																if (esi_2567 == 0x39)
																{
																	ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) edi_2346;
																	word32 edi_2594 = ebp_1126->dwFFFFFF50;
																	do
																	{
																		*ecx_2568 = 0x30;
																		ecx_2568 -= (struct Eq_82695 *) 0x04;
																		esi_2567 = (word32) *ecx_2568;
																		++edx_2588;
																		if (esi_2567 == edi_2594)
																		{
																			edi_2346 = ebp_1126->ptrFFFFFF88;
																			goto l080793BE;
																		}
																	} while (esi_2567 == 0x39);
																	edi_2346 = ebp_1126->ptrFFFFFF88;
																}
																if (edx_2588 != ebp_1126->dwFFFFFF38 || ebp_1126->tFFFFFF3C <= 0x00)
																{
l08079D57:
																	esi_2622 = esi_2567 + 0x01;
																	*ecx_2568 = esi_2622;
l080793EC:
																	edx_2586 = (word32) ebp_1126->tFFFFFF3C + ebp_1126->dwFFFFFF38;
																	if (esi_2622 != ebp_1126->dwFFFFFF50)
																	{
																		if (edx_2586 >= ebx_2401 || *((word32) edi_2346 - 4) != 0x30)
																		{
l08078EC0:
																			cu8 * edx_2915 = ebp_1126->ptrFFFFFF78;
																			if (edx_2915 != null)
																			{
																				Eq_2 esi_2919 = ebp_1126->dwFFFFFF24;
																				ebp_1126->ptrFFFFFF68 = (Eq_2 (*)[]) esi_2919;
																				if (ebp_1126->dwFFFFFF4C == esi_2919)
																				{
l08078F0C:
																					word32 esi_2943 = ebp_1126->dwFFFFFF28;
																					if (esi_2943 != 0x00)
																					{
																						int32 ecx_2947 = ebp_1126->tFFFFFF40;
																						ui32 ebx_2948 = ebp_1126->dwFFFFFF24;
																						Eq_2 eax_2987 = ecx_2947 + ebx_2948 * 0x04;
																						struct Eq_82885 * esp_2986 = esp_2256 - (struct Eq_82886 *) 0x04;
																						esp_2986->tFFFFFFFC = edi_2346 - eax_2987 >> 0x02;
																						esp_2986->tFFFFFFF8 = eax_2987;
																						ui32 ebx_2988 = ebx_2948 + esi_2943;
																						esp_2986->tFFFFFFF4 = ecx_2947 + (ebx_2988 << 0x02);
																						wmemmove(esp_2986->tFFFFFFF4, esp_2986->tFFFFFFF8, esp_2986->tFFFFFFFC);
																						byte * eax_3010 = ebp_1126->ptrFFFFFF78;
																						ebp_1126->ptrFFFFFF88 = ecx_2947 - 0x04 + (ebx_2988 << 0x02);
																						ebp_1126->tFFFFFF58.u3 = edi_2346;
																						Eq_2 (* edx_3016)[] = (int32) *eax_3010;
																						Eq_2 esi_3017[] = ebp_1126->ptrFFFFFF68;
																						do
																						{
																							ebp_1126->ptrFFFFFF68 = edx_3016;
																							Eq_82988 esi_3028 = esi_3017 + (edx_3016 * 0x3FFFFFFF) / 4;
																							int32 edi_3024 = -edx_3016;
																							Eq_82943 ebx_3031 = (word32) ebp_1126->tFFFFFF40 + esi_3028 * 0x04;
																							Eq_82976 (* ecx_3033)[] = ebp_1126->ptrFFFFFF88 + (edi_3024 << 0x02) / 4;
																							Eq_2 (* eax_3034)[] = edx_3016;
																							do
																							{
																								ecx_3033[eax_3034].u0 = (ebx_3031 - 0x04)[eax_3034];
																								--eax_3034;
																							} while (eax_3034 != null);
																							Eq_2 (* edx_3046)[] = ebp_1126->ptrFFFFFF68;
																							ebp_1126->ptrFFFFFF88 = ebp_1126->ptrFFFFFF88 - 0x04 + (edi_3024 << 0x02);
																							ecx_3033[0].u0 = ebp_1126->dwFFFFFF48;
																							struct Eq_82980 * eax_3055 = ebp_1126->ptrFFFFFF78;
																							edx_3016 = (int32) eax_3055->b0001;
																							esi_3017 = esi_3028 - (edx_3046 << 0x1E);
																							ci8 dl_3057 = (byte) edx_3016;
																							if (dl_3057 == 0x7F || dl_3057 < 0x00)
																								break;
																							if (dl_3057 != 0x00)
																								ebp_1126->ptrFFFFFF78 = &eax_3055->b0001;
																							else
																								edx_3016 = (int32) *ebp_1126->ptrFFFFFF78;
																						} while (edx_3016 < esi_3017);
																						struct Eq_82996 * ecx_3077 = ebp_1126->tFFFFFF40;
																						Eq_83000 edi_3080 = ebp_1126->tFFFFFF58;
																						word32 * eax_3082 = ecx_3077 - 0x04 + esi_3017 *32 0x04;
																						struct Eq_82996 * esi_3083 = ebp_1126->ptrFFFFFF88;
																						do
																						{
																							esi_3083 -= 0x04;
																							esi_3083[1] = (struct Eq_82996) *eax_3082;
																							eax_3082 -= 0x04;
																						} while (esi_3083 > ecx_3077);
																						edi_2346 = edi_3080 + Mem3090[ebp_1126 + -0x00D8:word32] * 0x04;
																					}
																					goto l08079010;
																				}
																				ebp_1126->dwFFFFFF28 = 0x00;
																				word32 ecx_2924 = (word32) *edx_2915;
																				ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) (byte) ecx_2924;
																				if ((byte) ecx_2924 <= 0x7E && (byte) ecx_2924 >= 0x01)
																				{
																					ebp_1126->dwFFFFFF28 = (ui32) __guess_grouping.part.0(esi_2919, edx_2915);
																					goto l08078F0C;
																				}
																			}
l08079010:
																			esp_3814 = esp_2256;
																			word32 eax_3100 = ebp_1126->dwFFFFFFAC;
																			if (eax_3100 == 0x66)
																				goto l08079098;
																			word32 eax_3116;
																			ebx_2058 = ebp_1126->dwFFFFFFB0;
																			if (ebp_1126->dwFFFFFFA8 == 0x00)
																			{
																				*edi_2346 = eax_3100;
																				eax_3116 = 0x2B;
																			}
																			else
																			{
																				if (ebp_1126->dwFFFFFF18 == 0x67 && ebx_2058 == 0x04)
																					goto l0807A5B4;
																				*edi_2346 = eax_3100;
																				eax_3116 = 0x2D;
																			}
																			Eq_83088 esi_3129;
																			*((word32) edi_2346 + 4) = eax_3116;
																			Eq_83088 esi_3120 = (word32) edi_2346 + 8;
																			if (ebx_2058 > 0x09)
																			{
																				int32 ecx_3130 = 0x0A;
																				do
																				{
																					ui32 ecx_3133 = ecx_3130 * 0x05;
																					ecx_3130 = ecx_3133 * 0x02;
																				} while (ecx_3133 * 0x02 <= ebx_2058);
																				ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) ebx_2058;
																				Eq_83088 ebx_3144 = esi_3120;
																				while (true)
																				{
																					int32 esi_3156 = (SLICE(ecx_3130 *s64 0x66666667, word32, 32) >> 0x02) - (ecx_3130 >> 0x1F);
																					int64 edx_eax_3160 = (int64) ebp_1126->ptrFFFFFF88;
																					Eq_2 edx_3164 = (int32) (edx_eax_3160 % esi_3156);
																					ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) edx_3164;
																					ebx_3144 = (word32) ebx_3144 + 4;
																					*((word32) ebx_3144 - 4) = (int32) (edx_eax_3160 /32 esi_3156) + 0x30;
																					if (ecx_3130 <= 0x6D)
																						break;
																					ecx_3130 = esi_3156;
																				}
																				ebp_1126->dwFFFFFFB0 = (int32) edx_3164;
																				esi_3129 = ebx_3144;
																				ebx_2058 = edx_3164;
																			}
																			else
																			{
																				*((word32) edi_2346 + 8) = 0x30;
																				esi_3129 = (word32) edi_2346 + 0x0C;
																			}
																			*esi_3129 = (word32) ebx_2058 + 48;
																			edi_2346 = (word32) esi_3129 + 4;
l08079098:
																			Eq_2 eax_3912;
																			ebx_2058 = ebp_1126->dwFFFFFFA4;
																			ui32 esi_3889 = (word32) ebp_1126->ptrFFFFFF84->b000C;
																			Eq_78726 eax_3892 = edi_2346 - ebp_1126->tFFFFFF40;
																			ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) ebx_2058;
																			ebp_1126->tFFFFFF58 = eax_3892;
																			ui32 edx_3897 = esi_3889;
																			int32 eax_3898 = -(eax_3892 >> 0x02);
																			byte cl_3906 = (byte) esi_3889 & 0x20;
																			if (ebx_2058 != 0x00)
																			{
																				ebp_1126->ptrFFFFFF68 = ebp_1126->dwFFFFFF1C - 0x01 + eax_3898;
																				if (cl_3906 == 0x00)
																				{
																					eax_3912 = ebp_1126->ptrFFFFFF84->t0010;
																					if (ebp_1126->ptrFFFFFF68 > null && eax_3912 != 0x30)
																						goto l080790FC;
																				}
																				ebx_2058.u0 = 0x00;
																				goto l080794B2;
																			}
																			else
																			{
																				if ((esi_3889 & 0x50) != 0x00)
																				{
																					ebx_2058 = ebp_1126->dwFFFFFF1C;
																					ebp_1126->ptrFFFFFF68 = ebx_2058 - 0x01 + eax_3898;
																					if (cl_3906 != 0x00)
																						goto l08079148;
																					eax_3912 = ebp_1126->ptrFFFFFF84->t0010;
																					if (ebp_1126->ptrFFFFFF68 > null && eax_3912 != 0x30)
																					{
l080790FC:
																						Eq_2 eax_3995;
																						if (ebp_1126->dwFFFFFF54 != 0x00)
																						{
																							struct Eq_78855 * esp_4010 = esp_3814 - 0x04;
																							esp_4010->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_4010->tFFFFFFF8 = eax_3912;
																							esp_4010->tFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4028 = <invalid>;
																							word32 esi_9192;
																							word32 edx_9191;
																							word32 ecx_9190;
																							eax_3995 = _IO_wpadn(gs, esp_4010->tFFFFFFF4, esp_4010->tFFFFFFF8, esp_4010->tFFFFFFFC, out ecx_9190, out edx_9191, out ebx_2058, out ebp_1126, out esi_9192, out edi_2346);
																							esp_3814 = (word32) esp_4028 + 16;
																						}
																						else
																						{
																							struct Eq_78814 * esp_3962 = esp_3814 - 0x04;
																							esp_3962->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_3962->tFFFFFFF8 = eax_3912;
																							esp_3962->tFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4002 = <invalid>;
																							word32 ecx_9187;
																							word32 edx_9188;
																							word32 esi_9189;
																							eax_3995 = _IO_padn(gs, esp_3962->tFFFFFFF4, esp_3962->tFFFFFFF8, esp_3962->tFFFFFFFC, out ecx_9187, out edx_9188, out ebx_2058, out ebp_1126, out esi_9189, out edi_2346);
																							esp_3814 = (word32) esp_4002 + 16;
																						}
																						Eq_2 esi_4038 = ebp_1126->ptrFFFFFF68;
																						if (eax_3995 != esi_4038)
																							goto l08078BA2;
																						if (ebp_1126->dwFFFFFFA4 == 0x00)
																						{
																							struct Eq_78909 * eax_4130 = ebp_1126->ptrFFFFFF84;
																							ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) esi_4038;
																							esi_3889 = (word32) eax_4130->b000C;
																							goto l08079148;
																						}
																						ebx_2058 = ebp_1126->ptrFFFFFF68;
l080794B2:
																						int8 al_4079;
																						if (ebp_1126->dwFFFFFF54 != 0x00)
																						{
																							Eq_2 eax_4085 = ebp_1126->ptrFFFFFF7C->t0058;
																							if (eax_4085 != 0x00)
																							{
																								struct Eq_78442 * edx_4089 = *((word32) eax_4085 + 16);
																								if (edx_4089 < *((word32) eax_4085 + 20))
																								{
																									*((word32) eax_4085 + 16) = (char *) &edx_4089->t0000 + 4;
																									edx_4089->t0000.u0 = 0x2D;
																									goto l080794E9;
																								}
																							}
																							struct Eq_79013 * esp_4093 = esp_3814 - 0x08;
																							esp_4093->tFFFFFFFC.u0 = 0x2D;
																							esp_4093->tFFFFFFF8 = ebp_1126->ptrFFFFFF7C;
																							word32 ecx_9195;
																							al_4079 = (int8) (__woverflow(esp_4093->tFFFFFFF8, esp_4093->tFFFFFFFC, out ecx_9195) == ~0x00);
																						}
																						else
																						{
																							Eq_2 esi_4055 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 eax_4056 = *((word32) esi_4055 + 20);
																							if (eax_4056 < *((word32) esi_4055 + 24))
																							{
																								ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_4056 + 1;
																								*eax_4056 = 0x2D;
																								goto l080794E9;
																							}
																							struct Eq_80095 * esp_4062 = esp_3814 - (struct Eq_80096 *) 0x08;
																							esp_4062->tFFFFFFFC.u0 = 0x2D;
																							esp_4062->tFFFFFFF8 = esi_4055;
																							word32 ecx_9232;
																							word32 edx_9233;
																							al_4079 = (int8) (__overflow(esp_4062->tFFFFFFF8, esp_4062->tFFFFFFFC, out ecx_9232, out edx_9233) == ~0x00);
																						}
																						if (al_4079 != 0x00)
																							goto l08078BA2;
l080794E9:
																						ebp_1126->ptrFFFFFF88 = (word32) ebx_2058 + 1;
																						edx_3897 = (word32) ebp_1126->ptrFFFFFF84->b000C;
l08079198:
																						if ((edx_3897 & 0x20) != 0x00 || ((ebp_1126->ptrFFFFFF84)->t0010 != 0x30 || ebp_1126->ptrFFFFFF68 <= null))
																						{
l080791B4:
																							<anonymous> * eax_4441;
																							Eq_2 esi_4409;
																							Eq_2 edi_4430;
																							ebx_2058 = ebp_1126->dwFFFFFF54;
																							struct Eq_79121 * eax_4374 = ebp_1126->ptrFFFFFF84;
																							if (ebx_2058 != 0x00)
																							{
																								if ((eax_4374->b000D & 0x08) == 0x00)
																									ebx_2058.u0 = 0x00;
																								else
																								{
																									esp_3814.u0 = <invalid>;
																									word32 esi_9203;
																									ebx_2058 = _i18n_number_rewrite(0x00, 0x00, 0x00, gs, out ebp_1126, out esi_9203, out edi_2346);
																								}
																								Eq_79344 eax_4407 = ebp_1126->tFFFFFF58;
																								esi_4409 = eax_4407 >> 0x02;
																								if (edi_2346 != ebp_1126->tFFFFFF40)
																								{
																									edi_4430 = ebp_1126->ptrFFFFFF7C->t0094;
																									if (edi_4430 < 135066356)
																									{
																										ebp_1126->ptrFFFFFF78 = 0x00;
																										eax_4441 = (<anonymous> *) *((word32) edi_4430 + 28);
																										goto l08078B2A;
																									}
																									ebp_1126->ptrFFFFFF78 = 0x00;
l0807A185:
																									word32 edx_9226;
																									word32 ecx_9225;
																									_IO_vtable_check(out ecx_9225, out edx_9226);
																									esp_3814.u0 = <invalid>;
																									eax_4441 = (<anonymous> *) *((word32) edi_4430 + 28);
																									if (ebp_1126->dwFFFFFF54 != 0x00)
																										ebx_2058 = ebp_1126->tFFFFFF40;
																									ebp_1126->tFFFFFF40.u2 = ebx_2058;
l08078B2A:
																									struct Eq_79891 * esp_4854 = esp_3814 - (struct Eq_79892 *) 0x04;
																									esp_4854->tFFFFFFFC = esi_4409;
																									esp_4854->tFFFFFFF8 = ebp_1126->tFFFFFF40;
																									esp_4854->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																									Eq_2 eax_5027;
																									eax_4441();
																									esp_3814 = esp_4854 + 0x04;
																									if (eax_5027 != esi_4409)
																										goto l08078BA2;
																									goto l08078B46;
																								}
																								if (eax_4407 >> 0x02 != 0x00)
																								{
																									Eq_2 ecx_4447 = ebp_1126->ptrFFFFFF88;
																									ebp_1126->ptrFFFFFF88 = (word32) ecx_4447 + (eax_4407 >> 0x02);
																									ebx_2058 = ecx_4447;
																									Eq_2 esi_4455[] = (word32) edi_2346 + -ecx_4447 * 0x04;
																									do
																									{
																										int8 al_4473;
																										Eq_2 ecx_4461 = esi_4455[ebx_2058];
																										Eq_2 eax_4462 = ebp_1126->ptrFFFFFF7C->t0058;
																										if (eax_4462 == 0x00)
																										{
l0807957A:
																											struct Eq_79509 * esp_4477 = esp_3814 - (struct Eq_79510 *) 0x08;
																											esp_4477->tFFFFFFFC = ecx_4461;
																											esp_4477->tFFFFFFF8 = ebp_1126->ptrFFFFFF7C;
																											word32 ecx_9210;
																											al_4473 = (int8) (__woverflow(esp_4477->tFFFFFFF8, esp_4477->tFFFFFFFC, out ecx_9210) == ~0x00);
																											goto l08079556;
																										}
																										struct Eq_78442 * edx_4466 = *((word32) eax_4462 + 16);
																										if (edx_4466 >= *((word32) eax_4462 + 20))
																											goto l0807957A;
																										*((word32) eax_4462 + 16) = (char *) &edx_4466->t0000 + 4;
																										edx_4466->t0000 = ecx_4461;
																										al_4473 = (int8) (ecx_4461 == ~0x00);
l08079556:
																										if (al_4473 != 0x00)
																											goto l08078BA2;
																										ebx_2058 = (byte) ebx_2058.u0 + 1;
																									} while (ebx_2058 != ebp_1126->ptrFFFFFF88);
																									ebp_1126->ptrFFFFFF78 = 0x00;
																								}
																								else
																									ebp_1126->ptrFFFFFF78 = 0x00;
l08078B46:
																								if (ebp_1126->dwFFFFFF14 == 0x00)
																								{
																									struct Eq_79593 * esp_5047 = esp_3814 - (struct Eq_79594 *) 0x0C;
																									Eq_2 edi_5049 = ebp_1126->dwFFFFFF80;
																									esp_5047->tFFFFFFFC = ebp_1126->ptrFFFFFF78;
																									word32 ecx_9212;
																									word32 edx_9213;
																									free(gs, esp_5047->tFFFFFFF8, esp_5047->tFFFFFFFC, out ecx_9212, out edx_9213);
																									esp_5047->tFFFFFFFC = ebp_1126->ptrFFFFFF20;
																									word32 edx_9215;
																									word32 ecx_9214;
																									free(gs, esp_5047->tFFFFFFF8, esp_5047->tFFFFFFFC, out ecx_9214, out edx_9215);
																									ebx_2058 = edi_5049;
																								}
																								struct Eq_79636 * eax_5084 = ebp_1126->ptrFFFFFF84;
																								if ((eax_5084->b000C & 0x20) != 0x00)
																								{
																									Eq_2 edi_5088 = ebp_1126->ptrFFFFFF68;
																									if (edi_5088 > 0x00)
																									{
																										Eq_2 eax_5108;
																										Eq_2 eax_5092 = eax_5084->t0010;
																										if (ebp_1126->dwFFFFFF54 != 0x00)
																										{
																											struct Eq_79705 * esp_5123 = esp_3814 - (struct Eq_79706 *) 0x04;
																											esp_5123->tFFFFFFFC = edi_5088;
																											esp_5123->tFFFFFFF8 = eax_5092;
																											esp_5123->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																											Eq_2 esp_5140 = <invalid>;
																											word32 esi_9222;
																											word32 edi_9223;
																											word32 edx_9221;
																											word32 ecx_9220;
																											eax_5108 = _IO_wpadn(gs, esp_5123->dwFFFFFFF4, esp_5123->tFFFFFFF8, esp_5123->tFFFFFFFC, out ecx_9220, out edx_9221, out ebx_2058, out ebp_1126, out esi_9222, out edi_9223);
																											esp_3814 = (word32) esp_5140 + 16;
																										}
																										else
																										{
																											struct Eq_79663 * esp_5097 = esp_3814 - (struct Eq_79664 *) 0x04;
																											esp_5097->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																											esp_5097->tFFFFFFF8 = eax_5092;
																											esp_5097->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																											Eq_2 esp_5115 = <invalid>;
																											word32 edx_9217;
																											word32 esi_9218;
																											word32 edi_9219;
																											word32 ecx_9216;
																											eax_5108 = _IO_padn(gs, esp_5097->dwFFFFFFF4, esp_5097->tFFFFFFF8, esp_5097->tFFFFFFFC, out ecx_9216, out edx_9217, out ebx_2058, out ebp_1126, out esi_9218, out edi_9219);
																											esp_3814 = (word32) esp_5115 + 16;
																										}
																										if (eax_5108 != ebp_1126->ptrFFFFFF68)
																											goto l08078BA2;
																										goto l080782C8;
																									}
																								}
																								goto l080782CA;
																							}
																							if ((eax_4374->b000D & 0x08) != 0x00)
																								ebp_1126->dwFFFFFF30 *= *((char *) *ebp_1126->ptrFFFFFF44 + 88);
																							int32 edx_4544;
																							struct Eq_79161 * esp_4523 = esp_3814 - 0x0C;
																							esp_4523->tFFFFFFFC = ebp_1126->dwFFFFFF34;
																							word32 edx_9197;
																							word32 ecx_9196;
																							ebp_1126->tFFFFFF58.u2 = strlen(esp_4523->tFFFFFFFC, out ecx_9196, out edx_9197);
																							Eq_2 eax_4539 = ebp_1126->dwFFFFFF2C;
																							if (eax_4539 != 0x00)
																							{
																								esp_4523->tFFFFFFFC = eax_4539;
																								word32 ecx_9198;
																								word32 edx_9199;
																								Eq_2 eax_4551 = strlen(esp_4523->tFFFFFFFC, out ecx_9198, out edx_9199);
																								int32 edx_4558 = ebp_1126->dwFFFFFF28;
																								ebp_1126->dwFFFFFF4C = (int32) eax_4551;
																								edx_4544 = edx_4558 *s eax_4551;
																							}
																							else
																							{
																								ebp_1126->dwFFFFFF4C = 0x00;
																								edx_4544 = 0x00;
																							}
																							word32 ecx_4567 = ebp_1126->dwFFFFFF14;
																							Eq_2 eax_4570 = (word32) ebp_1126->tFFFFFF58 + (ebp_1126->dwFFFFFF30 + 0x02) + edx_4544;
																							ebp_1126->ptrFFFFFF44 = (struct Eq_79196 **) eax_4570;
																							if (ecx_4567 != 0x00)
																							{
																								Eq_79278 eax_4599 = ebp_1126->ptrFFFFFF44;
																								word32 esi_4604 = esp_3814 - (eax_4599 + 0x1B & ~0x0FFF);
																								word32 edx_4605 = eax_4599 + 0x1B & ~0x0F;
																								while (esp_3814 != esi_4604)
																								{
																									esp_3814 -= 0x1000;
																									*((word32) esp_3814 + 0x0FFC) = *((word32) esp_3814 + 0x0FFC);
																								}
																								if ((edx_4605 & 0x0FFF) != 0x00)
																								{
																									esp_3814 -= edx_4605 & 0x0FFF;
																									Mem4628[esp_3814 - 0x04 + (edx_4605 & 0x0FFF):word32] = Mem4626[esp_3814 - 0x04 + (edx_4605 & 0x0FFF):word32];
																								}
																								Mem4639[ebp_1126 + -0x0088:word32] = esp_3814 + 0x0F & ~0x0F;
																							}
																							else
																							{
																								struct Eq_79246 * esp_4576 = esp_3814 - 0x0C;
																								esp_4576->tFFFFFFFC = eax_4570;
																								word32 ecx_9200;
																								word32 edx_9201;
																								word32 esi_9202;
																								Eq_2 eax_4583 = __libc_malloc(gs, esp_4576->tFFFFFFF8, esp_4576->tFFFFFFFC, out ecx_9200, out edx_9201, out ebx_2058, out ebp_1126, out esi_9202, out edi_2346);
																								ebp_1126->ptrFFFFFF78 = (cu8 *) eax_4583;
																								esp_3814 = (char *) &esp_4576->tFFFFFFFC + 16;
																								if (eax_4583 == 0x00)
																								{
l08078BAC:
																									struct Eq_78968 * esp_5163 = esp_3814 - 0x0C;
																									esp_5163->tFFFFFFFC = ebp_1126->ptrFFFFFF20;
																									ebx_2058 = ebp_1126->dwFFFFFF80;
																									word32 ecx_9193;
																									word32 edx_9194;
																									free(gs, esp_5163->tFFFFFFF8, esp_5163->tFFFFFFFC, out ecx_9193, out edx_9194);
																									goto l08078BC0;
																								}
																							}
																							Eq_2 eax_4655;
																							Eq_78203 eax_4642 = ebp_1126->tFFFFFF40;
																							if (edi_2346 > eax_4642)
																							{
																								Eq_78203 esi_4656 = eax_4642;
																								eax_4655 = ebp_1126->ptrFFFFFF78;
																								do
																								{
																									word32 ebx_4660 = *esi_4656;
																									byte bl_4689 = (byte) ebx_4660;
																									if (ebx_4660 == ebp_1126->dwFFFFFF50)
																									{
																										struct Eq_79549 * esp_4693 = esp_3814 - (struct Eq_79550 *) 0x04;
																										esp_4693->tFFFFFFFC = ebp_1126->tFFFFFF58;
																										esp_4693->tFFFFFFF8 = ebp_1126->dwFFFFFF34;
																										esp_4693->dwFFFFFFF4 = (word32) eax_4655;
																										word32 edx_9211;
																										eax_4655 = __mempcpy(esp_4693->dwFFFFFFF4, esp_4693->tFFFFFFF8, esp_4693->tFFFFFFFC, out edx_9211);
																									}
																									else if (ebp_1126->dwFFFFFF48 != ebx_4660)
																									{
																										*eax_4655 = bl_4689;
																										eax_4655 = (word32) eax_4655 + 1;
																									}
																									else
																									{
																										struct Eq_79825 * esp_4667 = esp_3814 - (struct Eq_79826 *) 0x04;
																										esp_4667->tFFFFFFFC = ebp_1126->dwFFFFFF4C;
																										esp_4667->tFFFFFFF8 = ebp_1126->dwFFFFFF2C;
																										esp_4667->dwFFFFFFF4 = (word32) eax_4655;
																										word32 edx_9227;
																										eax_4655 = __mempcpy(esp_4667->dwFFFFFFF4, esp_4667->tFFFFFFF8, esp_4667->tFFFFFFFC, out edx_9227);
																									}
																									esi_4656 = (word32) esi_4656 + 4;
																								} while (edi_2346 > esi_4656);
																								if ((ebp_1126->ptrFFFFFF84->b000D & 0x08) == 0x00)
																								{
																									ebx_2058 = ebp_1126->ptrFFFFFF78;
l08078AEB:
																									Eq_2 eax_4762 = eax_4655 - ebx_2058;
																									esi_4409 = eax_4762;
																									if (eax_4762 > 0x14)
																									{
																										edi_4430 = ebp_1126->ptrFFFFFF7C->t0094;
																										if (edi_4430 < 135066356)
																										{
																											ebp_1126->tFFFFFF40.u2 = ebx_2058;
																											eax_4441 = (<anonymous> *) *((word32) edi_4430 + 28);
																											goto l08078B2A;
																										}
																										goto l0807A185;
																									}
																									int32 esi_4768 = ebp_1126->ptrFFFFFF88;
																									ebx_2058 -= esi_4768;
																									word32 edi_4770 = (word32) eax_4762 + esi_4768;
																									if (eax_4762 != 0x00)
																									{
																										ebp_1126->ptrFFFFFF88 = edi_4770;
																										Eq_2 edi_4778 = ebp_1126->ptrFFFFFF7C;
																										do
																										{
																											Eq_2 edx_4782 = (word32) *((word32) ebx_2058 + esi_4768);
																											byte dl_4789 = (byte) edx_4782;
																											Eq_2 eax_4784 = *((word32) edi_4778 + 20);
																											if (eax_4784 >= *((word32) edi_4778 + 24))
																											{
																												struct Eq_79924 * esp_4792 = esp_3814 - (struct Eq_79925 *) 0x08;
																												esp_4792->tFFFFFFFC = edx_4782;
																												esp_4792->tFFFFFFF8 = edi_4778;
																												esp_3814 = esp_4792 + 0x08;
																												word32 ecx_9228;
																												word32 edx_9229;
																												if (__overflow(esp_4792->tFFFFFFF8, esp_4792->tFFFFFFFC, out ecx_9228, out edx_9229) == ~0x00)
																													goto l08078BA2;
																											}
																											else
																											{
																												*((word32) edi_4778 + 20) = (word32) eax_4784 + 1;
																												*eax_4784 = dl_4789;
																											}
																											++esi_4768;
																										} while (esi_4768 != ebp_1126->ptrFFFFFF88);
																										goto l08078B46;
																									}
l0807A155:
																									goto l08078B46;
																								}
																							}
																							else
																							{
																								if ((ebp_1126->ptrFFFFFF84->b000D & 0x08) == 0x00)
																									goto l0807A155;
																								eax_4655 = ebp_1126->ptrFFFFFF78;
																							}
																							Eq_2 edi_4728 = ebp_1126->ptrFFFFFF78;
																							esp_3814.u0 = <invalid>;
																							Eq_2 esi_4751;
																							word32 edi_9224;
																							ebx_2058 = _i18n_number_rewrite(edi_4728, Mem4727[ebp_1126 + -188:word32] + edi_4728, eax_4655, gs, out ebp_1126, out esi_4751, out edi_9224);
																							eax_4655 = esi_4751;
																							goto l08078AEB;
																						}
																						Eq_2 eax_4321;
																						if (ebp_1126->dwFFFFFF54 != 0x00)
																						{
																							struct Eq_79423 * esp_4336 = esp_3814 - (struct Eq_79424 *) 0x04;
																							esp_4336->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_4336->tFFFFFFF8.u0 = 0x30;
																							esp_4336->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4354 = <invalid>;
																							word32 edx_9208;
																							word32 esi_9209;
																							word32 ecx_9207;
																							eax_4321 = _IO_wpadn(gs, esp_4336->dwFFFFFFF4, esp_4336->tFFFFFFF8, esp_4336->tFFFFFFFC, out ecx_9207, out edx_9208, out ebx_2058, out ebp_1126, out esi_9209, out edi_2346);
																							esp_3814 = (word32) esp_4354 + 16;
																						}
																						else
																						{
																							struct Eq_79381 * esp_4297 = esp_3814 - (struct Eq_79382 *) 0x04;
																							esp_4297->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_4297->tFFFFFFF8.u0 = 0x30;
																							esp_4297->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4328 = <invalid>;
																							word32 edx_9205;
																							word32 esi_9206;
																							word32 ecx_9204;
																							eax_4321 = _IO_padn(gs, esp_4297->dwFFFFFFF4, esp_4297->tFFFFFFF8, esp_4297->tFFFFFFFC, out ecx_9204, out edx_9205, out ebx_2058, out ebp_1126, out esi_9206, out edi_2346);
																							esp_3814 = (word32) esp_4328 + 16;
																						}
																						if (eax_4321 == ebp_1126->ptrFFFFFF68)
																						{
																							Mem4369[ebp_1126 + -0x0078:word32] = Mem4364[ebp_1126 + -0x0078:word32] + Mem4364[ebp_1126 + -0x0098:word32];
																							goto l080791B4;
																						}
l08078BA2:
																						if (ebp_1126->dwFFFFFF14 != 0x00)
																							goto l08078BC0;
																						goto l08078BAC;
																					}
																				}
																				else
																				{
																					ebp_1126->ptrFFFFFF68 = eax_3898 + ebp_1126->dwFFFFFF1C;
																					if (cl_3906 != 0x00)
																						goto l0807914A;
																					eax_3912 = ebp_1126->ptrFFFFFF84->t0010;
																					if (eax_3912 != 0x30)
																					{
																						ebx_2058 = ebp_1126->ptrFFFFFF68;
																						if (ebx_2058 > 0x00)
																							goto l080790FC;
																					}
																				}
l08079148:
																				edx_3897 = esi_3889;
l0807914A:
																				int8 al_4174;
																				if ((esi_3889 & 0x40) != 0x00)
																				{
																					if (ebp_1126->dwFFFFFF54 != 0x00)
																					{
																						Eq_2 eax_4226 = ebp_1126->ptrFFFFFF7C->t0058;
																						if (eax_4226 != 0x00)
																						{
																							struct Eq_78442 * edx_4230 = *((word32) eax_4226 + 16);
																							if (edx_4230 < *((word32) eax_4226 + 20))
																							{
																								*((word32) eax_4226 + 16) = (char *) &edx_4230->t0000 + 4;
																								edx_4230->t0000.u0 = 0x2B;
																								goto l0807918D;
																							}
																						}
																						*((word32) esp_3814 - 0x0C) = 0x2B;
																						goto l0807A3B9;
																					}
																					Eq_2 ecx_4199 = ebp_1126->ptrFFFFFF7C;
																					Eq_2 eax_4200 = *((word32) ecx_4199 + 20);
																					if (eax_4200 < *((word32) ecx_4199 + 24))
																					{
																						ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_4200 + 1;
																						*eax_4200 = 0x2B;
																						goto l0807918D;
																					}
																					struct Eq_79997 * esp_4203 = esp_3814 - (struct Eq_79998 *) 0x08;
																					esp_4203->tFFFFFFFC.u0 = 0x2B;
																					esp_4203->tFFFFFFF8 = ecx_4199;
																					word32 edx_9231;
																					word32 ecx_9230;
																					al_4174 = (int8) (__overflow(esp_4203->tFFFFFFF8, esp_4203->tFFFFFFFC, out ecx_9230, out edx_9231) == ~0x00);
																				}
																				else
																				{
																					if ((esi_3889 & 0x10) == 0x00)
																						goto l08079198;
																					if (ebp_1126->dwFFFFFF54 != 0x00)
																					{
																						Eq_2 eax_4180 = ebp_1126->ptrFFFFFF7C->t0058;
																						if (eax_4180 != 0x00)
																						{
																							struct Eq_78442 * edx_4184 = *((word32) eax_4180 + 16);
																							if (edx_4184 < *((word32) eax_4180 + 20))
																							{
																								*((word32) eax_4180 + 16) = (char *) &edx_4184->t0000 + 4;
																								edx_4184->t0000.u0 = 0x20;
																								goto l0807918D;
																							}
																						}
																						*((byte) esp_3814.u0 - 0x0C) = 0x20;
l0807A3B9:
																						struct Eq_80132 * esp_4243 = esp_3814 - (struct Eq_80133 *) 0x0C;
																						esp_4243->tFFFFFFFC = ebp_1126->ptrFFFFFF7C;
																						word32 ecx_9234;
																						al_4174 = (int8) (__woverflow(esp_4243->tFFFFFFFC, esp_4243->a0000[0], out ecx_9234) == ~0x00);
																						goto l0807A3CD;
																					}
																					Eq_2 esi_4151 = ebp_1126->ptrFFFFFF7C;
																					Eq_2 eax_4152 = *((word32) esi_4151 + 20);
																					if (eax_4152 < *((word32) esi_4151 + 24))
																					{
																						ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_4152 + 1;
																						*eax_4152 = 0x20;
l0807918D:
																						struct Eq_79204 * eax_4269 = ebp_1126->ptrFFFFFF84;
																						ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) ((char *) ebp_1126->ptrFFFFFF88 + 1);
																						edx_3897 = (word32) eax_4269->b000C;
																						goto l08079198;
																					}
																					struct Eq_80156 * esp_4157 = esp_3814 - (struct Eq_80157 *) 0x08;
																					esp_4157->tFFFFFFFC.u0 = 0x20;
																					esp_4157->tFFFFFFF8 = esi_4151;
																					word32 ecx_9235;
																					word32 edx_9236;
																					al_4174 = (int8) (__overflow(esp_4157->tFFFFFFF8, esp_4157->tFFFFFFFC, out ecx_9235, out edx_9236) == ~0x00);
																				}
l0807A3CD:
																				if (al_4174 != 0x00)
																					goto l08078BA2;
																				goto l0807918D;
																			}
																		}
																		goto l08078E99;
																	}
																	esi_2567 = (word32) *((word32) ecx_2568 - 4);
																	eax_2585 = ecx_2568;
																	ecx_2568 -= (struct Eq_82811 *) 0x04;
l08079B76:
																	if (esi_2567 == ebp_1126->dwFFFFFF50)
																	{
																		eax_2585 = ecx_2568;
																		ecx_2568 -= (struct Eq_83139 *) 0x04;
																	}
																	if (ebp_1126->tFFFFFF40 <= ecx_2568)
																	{
																		word32 eax_2693 = *((word32) eax_2585 - 4);
																		Eq_78203 esi_2694 = ebp_1126->tFFFFFF40;
																		while (eax_2693 == 0x39)
																		{
																			*ecx_2568 = 0x30;
																			ecx_2568 -= (struct Eq_83217 *) 0x04;
																			if (esi_2694 > ecx_2568)
																				goto l08079BB8;
																			eax_2693 = (word32) *ecx_2568;
																		}
																		*ecx_2568 = eax_2693 + 0x01;
																	}
																	else
																	{
l08079BB8:
																		if (ebp_1126->dwFFFFFFAC != 0x66)
																		{
																			ebp_1126->ptrFFFFFF20->a0008[0] = 0x31;
																			int32 v111_2808 = ebp_1126->dwFFFFFFB0 + ((0x00 - (word32) (ebp_1126->dwFFFFFFA8 < 0x01) & 0x02) - 0x01);
																			ebp_1126->dwFFFFFFB0 = v111_2808;
																			if (v111_2808 == 0x00)
																				ebp_1126->dwFFFFFFA8 = 0x00;
																		}
																		else
																		{
																			struct Eq_83303 * eax_2712 = ebp_1126->ptrFFFFFF20;
																			if (ebp_1126->dwFFFFFF10 != ebp_1126->dwFFFFFF24)
																			{
																				eax_2712->dw0004 = 0x31;
																				ebp_1126->tFFFFFF40 = &eax_2712->dw0004;
																				++ebp_1126->dwFFFFFF24;
																			}
																			else
																			{
																				word32 esi_2715 = ebp_1126->dwFFFFFF50;
																				eax_2712->dw0000 = 0x31;
																				eax_2712->dw0004 = esi_2715;
																				if ((ebp_1126->ptrFFFFFF84->b000C & 0x08) == 0x00 && ebx_2401 == 0x00)
																					ebx_2401.u0 = ebp_1126->dwFFFFFF10;
																				else
																				{
																					ui32 eax_2738 = ebp_1126->dwFFFFFF24;
																					ebp_1126->ptrFFFFFF20->a0008[eax_2738] = 0x30;
																					ebx_2401 = (word32) ebx_2401.u0 + 1 + eax_2738;
																				}
																				struct Eq_83423 * eax_2745 = ebp_1126->ptrFFFFFF84;
																				++ebp_1126->dwFFFFFFB0;
																				ui32 ecx_2748 = eax_2745->dw0008;
																				Eq_150869 eax_2781[] = gs->ptrFFFFFFF8;
																				ebp_1126->dwFFFFFF24 = 0x01;
																				ebp_1126->dwFFFFFFAC = (0x00 - (word32) (((eax_2781)[ecx_2748].w0000 & 0x0100) < 0x01) & 0x20) + 0x45;
																				ebp_1126->tFFFFFF40 = ebp_1126->ptrFFFFFF20;
																			}
																		}
																		int32 esi_2816 = ebp_1126->dwFFFFFF10;
																		int32 eax_2819 = (word32) ebx_2401.u0 + ebp_1126->dwFFFFFF24;
																		if (eax_2819 > esi_2816)
																		{
																			int32 eax_2822 = eax_2819 - esi_2816;
																			ebx_2401 -= eax_2822;
																			edi_2346 -= eax_2822 * 0x04;
																		}
																	}
l08078E7C:
																	if (ebx_2401 <= edx_2586)
																	{
l08078EA2:
																		if (ebx_2401 == 0x00 && (((ebp_1126->ptrFFFFFF84)->b000C & 0x08) == 0x00 && *((word32) edi_2346 - 4) == ebp_1126->dwFFFFFF50))
																			edi_2346 -= (struct Eq_82787 *) 0x04;
																		goto l08078EC0;
																	}
																	eax_2563 = edi_2346 - (struct Eq_82705 *) 0x04;
																	if (*((word32) edi_2346 - 4) != 0x30)
																		goto l08078EA2;
l08078E99:
																	while (true)
																	{
																		--ebx_2401;
																		edi_2346 = eax_2563;
																		if (ebx_2401 <= edx_2586 || *((word32) eax_2563 - 4) != 0x30)
																			break;
																		eax_2563 -= (struct Eq_82867 *) 0x04;
																	}
																	goto l08078EA2;
																}
																ebp_1126->tFFFFFF3C.u5 = ebp_1126->tFFFFFF3C - 0x01;
																if (esi_2567 != ebp_1126->dwFFFFFF50)
																	goto l08079D57;
															}
															else
															{
l080793BE:
																if (edx_2588 == ebp_1126->dwFFFFFF38)
																{
																	Eq_82738 esi_2633 = ebp_1126->tFFFFFF3C;
																	ebp_1126->tFFFFFF3C.u1 = (word32) esi_2633 - 1 + (word32) ((int8) (esi_2633 > 0x00) < 0x01);
																}
															}
															esi_2622 = (word32) *ecx_2568;
															if (ebp_1126->dwFFFFFF18 == 0x67 && (ebp_1126->dwFFFFFFAC == 0x66 && (((ebp_1126->ptrFFFFFF84)->b000C & 0x08) != 0x00 && (ecx_2568 == (ebp_1126->ptrFFFFFF20)->a0008 + 1 && ((ebp_1126->ptrFFFFFF20)->a0008)[0] == 0x30))))
																ebp_1126->tFFFFFF3C.u1 = ebp_1126->tFFFFFF3C - 0x01;
															goto l080793EC;
														}
l08078E65:
														if (dl_2472 == 0x00)
															goto l08078E70;
														goto l08079368;
													}
													word32 edx_9263;
													word32 ecx_9262;
													abort(ecx_2486, gs, out ecx_9262, out edx_9263);
												}
											}
										}
										*eax_2358 = ebp_1126->dwFFFFFF50;
										edi_2346 = (word32) eax_2358 + 4;
										esi_2085 = 0x01;
										goto l08078A02;
									}
									ebp_1126->dwFFFFFF4C = 0x01;
									ebp_1126->dwFFFFFFAC = eax_1996 - 0x02;
									int32 eax_2136 = ebp_1126->dwFFFFFF10;
									ebp_1126->tFFFFFF58 = eax_2136 - 0x01;
									ebp_1126->dwFFFFFF30 = (int32) ((byte) edx_2103.u0 + 7);
									ebx_2058 = eax_2136 - 0x01;
									goto l0807886F;
								}
								ebx_2058 = ebp_1126->tFFFFFF58;
								ebp_1126->dwFFFFFFAC = 0x66;
								if (ebx_2058 < 0x00)
								{
									ebp_1126->tFFFFFF58 = 0x06;
									ebx_2058.u0 = 0x06;
								}
								if (ebp_1126->dwFFFFFFA8 == 0x00)
								{
									int32 eax_2089 = ebp_1126->dwFFFFFFB0;
									ebp_1126->dwFFFFFF10 = 0x7FFFFFFF;
									ebp_1126->dwFFFFFF30 = (int32) ((byte) ebx_2058.u0 + (eax_2089 + 0x02));
									Eq_83596 eax_2095 = ebp_1126->tFFFFFF58;
									ebp_1126->dwFFFFFF4C = eax_2089 + 0x01;
									ebp_1126->dwFFFFFF38 = (int32) eax_2095;
									esi_2085 = 0x01;
									goto l08078887;
								}
								ebp_1126->dwFFFFFF30 = (int32) ((byte) ebx_2058.u0 + 2);
							}
							else
							{
								ebp_1126->dwFFFFFFAC = eax_1996;
								if (esi_2044 >= 0x00)
								{
									ebp_1126->dwFFFFFF30 = (word32) esi_2044 + 8;
									ebx_2058 = esi_2044;
								}
								else
								{
									ebp_1126->dwFFFFFF30 = 0x0E;
									ebp_1126->tFFFFFF58 = 0x06;
									ebx_2058.u0 = 0x06;
								}
							}
							Eq_83609 eax_2084 = ebp_1126->tFFFFFF58;
							ebp_1126->dwFFFFFF10 = 0x7FFFFFFF;
							ebp_1126->dwFFFFFF4C = 0x01;
							ebp_1126->dwFFFFFF38 = (int32) eax_2084;
							esi_2085 = 0x01;
							goto l08078887;
						}
						else
						{
							int32 eax_1866;
							Eq_2 edx_1648;
							Eq_2 esi_1649;
							Eq_83792 ebx_1652;
							Eq_2 edi_1640;
							Eq_2 ecx_1641;
							Eq_83795 esi_1623 = ebp_1126->ptrFFFFFFBC;
							word32 edi_1625 = __bsr((esi_1623 - 0x04)[eax_1383]);
							Eq_83807 ebx_1626 = *esi_1623;
							ebp_1126->tFFFFFF40.u8 = esi_1623;
							ebp_1126->tFFFFFF58.u14 = ebx_1626;
							ebp_1126->dwFFFFFF4C = edi_1625 ^ 0x1F;
							if (ebx_1626 == 0x00)
							{
								Eq_2 ebx_1657[] = ebp_1126->ptrFFFFFFB4;
								Eq_2 edx_1658 = ebx_1657[0];
								ebp_1126->ptrFFFFFF88 = ebx_1657;
								if (edx_1658 == 0x00)
								{
									ebp_1126->tFFFFFF3C.u2 = eax_1383;
									Eq_2 esi_1674 = (word32) esi_1623 + 4;
									ebx_1652.u0 = 0x00;
									do
									{
										Eq_2 ecx_1681 = *esi_1674;
										ebx_1652 = (char *) ebx_1652.u0 + 1;
										ebp_1126->ptrFFFFFF68 = (Eq_2 (*)[]) ebx_1652;
										edx_1648 = esi_1674;
										if (ecx_1681 != 0x00)
										{
											int32 esi_1708 = ebp_1126->dwFFFFFF4C;
											ebp_1126->tFFFFFF58.u15 = ebx_1652 * 0x04;
											eax_1383 = ebp_1126->tFFFFFF3C;
											if (esi_1708 == 0x00)
												goto l08079FAB;
											Eq_2 (* esi_1771)[] = ebp_1126->ptrFFFFFF88;
											edi_1640 = __tzcnt(ecx_1681);
											ecx_1641 = Mem1709[esi_1771 + Mem1709[ebp_1126 + -0x00A8:word32]:word32];
											if (ecx_1641 != 0x00)
												goto l0807875D;
											esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
											goto l08079D8C;
										}
										Eq_2 edi_1692 = ebp_1126->ptrFFFFFF88[ebx_1652];
										esi_1674 = (word32) esi_1674 + 4;
									} while (edi_1692 == 0x00);
									int32 esi_1697 = ebp_1126->dwFFFFFF4C;
									ebp_1126->tFFFFFF58.u19 = ebx_1652 * 0x04;
									eax_1383 = ebp_1126->tFFFFFF3C;
									if (esi_1697 != 0x00)
									{
										Eq_2 ecx_1704 = 0x20 - ebp_1126->dwFFFFFF4C;
										edi_1640 = __tzcnt(edi_1692);
										esi_1649 = ecx_1704;
										goto l08079D8C;
									}
l08079FAB:
									Eq_83939 eax_1716 = eax_1383 - ebx_1652;
									if (eax_1716 > 0x00)
									{
										Eq_84297 edi_1721 = ebp_1126->tFFFFFF40;
										Eq_83939 edx_1723 = 0x00;
										word32 esi_1724 = Mem1720[ebp_1126 + -0x00A8:word32] + edi_1721;
										while (true)
										{
											((word32) edi_1721 + edx_1723 * 0x04)->u3 = ecx_1681;
											edx_1723 = (word32) edx_1723.u0 + 1;
											eax_1716 = ebp_1126->dwFFFFFFC0 - ebx_1652;
											if (eax_1716 <= edx_1723)
												break;
											ecx_1681 = *((word32) esi_1724 + edx_1723 * 0x04);
										}
									}
									int32 edx_1741 = ebp_1126->dwFFFFFFB8;
									ebp_1126->dwFFFFFFC0 = (word32) eax_1716;
									int32 edx_1745 = edx_1741 - ebx_1652;
									if (edx_1745 > 0x00)
									{
										Eq_84414 esi_1749 = ebp_1126->ptrFFFFFF88;
										int32 eax_1750 = 0x00;
										word32 ecx_1751 = Mem1743[ebp_1126 + -0x00A8:word32] + esi_1749;
										do
										{
											*((word32) esi_1749 + eax_1750 * 0x04) = *((word32) ecx_1751 + eax_1750 * 0x04);
											++eax_1750;
											edx_1745 = ebp_1126->dwFFFFFFB8 - ebx_1652;
										} while (edx_1745 > eax_1750);
									}
									ebp_1126->dwFFFFFFB8 = edx_1745;
									goto l080787D0;
								}
								if (ebp_1126->dwFFFFFF4C == 0x00)
									goto l080787D0;
								edi_1640 = __tzcnt(edx_1658);
								edx_1648 = ebp_1126->tFFFFFF40;
								esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
							}
							else
							{
								if (ebp_1126->dwFFFFFF4C == 0x00)
									goto l080787D0;
								Eq_2 edx_1638[] = ebp_1126->ptrFFFFFFB4;
								edi_1640 = __tzcnt(ebp_1126->tFFFFFF58);
								ecx_1641 = edx_1638[0];
								if (ecx_1641 != 0x00)
								{
									edx_1648 = ebp_1126->tFFFFFF40;
									ebp_1126->ptrFFFFFF68 = null;
									ebp_1126->tFFFFFF58.u0 = 0x00;
									ebx_1652.u0 = 0x00;
l0807875D:
									Eq_2 ecx_1783 = __tzcnt(ecx_1641);
									if (edi_1640 > ecx_1783)
										edi_1640 = ecx_1783;
									esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
									if (ebx_1652 != 0x00)
									{
l08079D8C:
										if (esi_1649 > edi_1640)
										{
											Eq_2 (* ecx_1807)[] = ebp_1126->ptrFFFFFF68;
											struct Eq_84177 * esp_1817 = esp_536 - 4;
											esp_1817->t0000 = esi_1649;
											Eq_84183 edi_1809 = ebx_1652 - 0x01;
											Eq_2 ecx_1825 = ebp_1126->tFFFFFF40;
											esp_1817->tFFFFFFFC = eax_1383 - edi_1809;
											Eq_84194 edx_1824 = ecx_1807 * 0x04 + ~0x03;
											ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) edx_1824;
											Mem1831[esp_1817 + -8:word32] = ecx_1825 + edx_1824;
											esp_1817->tFFFFFFF4 = ecx_1825;
											__mpn_rshift(esp_1817->tFFFFFFF4, esp_1817->tFFFFFFF8, esp_1817->tFFFFFFFC, esp_1817->t0000);
											Eq_2 ecx_1840 = ebp_1126->ptrFFFFFFB4;
											int32 eax_1841 = ebp_1126->dwFFFFFFB8;
											esp_1817->tFFFFFFF0 = esi_1649;
											Eq_2 (* edx_1844)[] = ebp_1126->ptrFFFFFF88;
											ebp_1126->dwFFFFFFC0 -= ebx_1652;
											esp_1817->tFFFFFFEC = eax_1841 - edi_1809;
											Mem1853[esp_1817 + -24:word32] = edx_1844 + ecx_1840;
											esp_1817->tFFFFFFE4 = ecx_1840;
											__mpn_rshift(esp_1817->tFFFFFFE4, esp_1817->tFFFFFFE8, esp_1817->tFFFFFFEC, esp_1817->t0010);
											int32 ecx_1862 = ebp_1126->dwFFFFFFB8;
											eax_1866 = ecx_1862 - edi_1809;
											if ((ebp_1126->ptrFFFFFFB4 - 0x04)[eax_1866] == 0x00)
												eax_1866 = ecx_1862 - ebx_1652;
l080787CD:
											ebp_1126->dwFFFFFFB8 = eax_1866;
											goto l080787D0;
										}
l08078785:
										struct Eq_84057 * esp_1929 = esp_536 - 4;
										esp_1929->t0000 = esi_1649;
										esp_1929->tFFFFFFFC = eax_1383 - ebx_1652;
										esp_1929->tFFFFFFF8 = edx_1648;
										esp_1929->tFFFFFFF4 = ebp_1126->tFFFFFF40;
										__mpn_rshift(esp_1929->tFFFFFFF4, esp_1929->tFFFFFFF8, esp_1929->tFFFFFFFC, esp_1929->t0000);
										int32 eax_1952 = ebp_1126->dwFFFFFFB8;
										Eq_2 edx_1953 = ebp_1126->ptrFFFFFFB4;
										esp_1929->tFFFFFFF0 = esi_1649;
										Eq_84101 edi_1932 = (char *) ebx_1652.u0 + 1;
										ebp_1126->dwFFFFFFC0 -= edi_1932;
										esp_1929->tFFFFFFEC = eax_1952 - ebx_1652;
										Mem1965[esp_1929 + -24:word32] = Mem1960[ebp_1126 + -0x00A8:word32] + edx_1953;
										esp_1929->tFFFFFFE4 = edx_1953;
										__mpn_rshift(esp_1929->tFFFFFFE4, esp_1929->tFFFFFFE8, esp_1929->tFFFFFFEC, esp_1929->t0010);
										int32 edx_1974 = ebp_1126->dwFFFFFFB8;
										eax_1866 = edx_1974 - ebx_1652;
										if ((ebp_1126->ptrFFFFFFB4 - 0x04)[eax_1866] == 0x00)
											eax_1866 = edx_1974 - edi_1932;
										goto l080787CD;
									}
								}
								else
								{
									ebp_1126->tFFFFFF58.u0 = 0x00;
									edx_1648 = ebp_1126->tFFFFFF40;
									esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
								}
							}
							ebx_1652.u0 = 0x00;
							if (edi_1640 < esi_1649)
							{
								Eq_2 edi_1881 = ebp_1126->dwFFFFFF4C;
								struct Eq_83989 * esp_1883 = esp_536 - 4;
								esp_1883->t0000 = edi_1881;
								esp_1883->tFFFFFFFC = eax_1383;
								Eq_2 eax_1888 = ebp_1126->tFFFFFF40;
								esp_1883->tFFFFFFF8 = eax_1888;
								esp_1883->tFFFFFFF4 = eax_1888;
								__mpn_lshift(esp_1883->tFFFFFFF4, esp_1883->tFFFFFFF8, esp_1883->tFFFFFFFC, esp_1883->t0000);
								Eq_2 eax_1899 = ebp_1126->ptrFFFFFFB4;
								esp_1883->tFFFFFFF0 = edi_1881;
								esp_1883->tFFFFFFEC = ebp_1126->dwFFFFFFB8;
								esp_1883->tFFFFFFE8 = eax_1899;
								esp_1883->tFFFFFFE4 = eax_1899;
								__mpn_lshift(esp_1883->tFFFFFFE4, esp_1883->tFFFFFFE8, esp_1883->tFFFFFFEC, esp_1883->t0010);
								if (eax_1899 != 0x00)
								{
									int32 edx_1919 = ebp_1126->dwFFFFFFB8;
									ebp_1126->dwFFFFFFB8 = edx_1919 + 0x01;
									ebp_1126->ptrFFFFFFB4[edx_1919] = eax_1899;
								}
								goto l080787D0;
							}
							goto l08078785;
						}
					}
l080785F2:
					ebx_1399 = ebp_1126->dwFFFFFFB0;
					goto l080785F5;
				}
				ebx_2058 = SEQ(SLICE(0x080CE000, word24, 8), __movmskps(xmm2_399)) & 0x08;
l08078A9B:
				if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) == 0x00)
				{
					edi_250 = 134946403;
					goto l08077EF0;
				}
				goto l08078ABB;
			}
l08078030:
			if ((esi_45 & 0x01) == 0x00)
			{
				Eq_80752 xmm0_213 = SEQ(0x00, *edx_162);
				if (!PARITY_EVEN(*edx_162 - *edx_162))
				{
					if ((real64) __andpd(xmm0_213, g_t80B1EF0) <= g_t80B1F00)
					{
						Eq_2 rLoc0110_5415 = *edx_162;
						Eq_2 eax_284 = __mpn_extract_double(fp - 0x34, fp - 88, fp - 100, (word32) rLoc0110_5415, SLICE(rLoc0110_5415, word32, 32));
						dwLoc80_5422 = eax_284;
						dwLoc50_5423 = eax_284;
						edi_296 = (eax_284 << 0x05) - 0x34;
						goto l080783DA;
					}
					ebx_2058 = SEQ(SLICE(ebx_101, word24, 8), __movmskpd(xmm0_213)) & 0x01;
					if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) != 0x00)
						goto l08077EDB;
					edi_250 = 134946407;
				}
				else
				{
					ebx_2058 = SEQ(SLICE(ebx_101, word24, 8), __movmskpd(xmm0_213)) & 0x01;
					if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) != 0x00)
					{
l08078ABB:
						edi_250 = 0x080B1E5B;
						goto l08077EF0;
					}
					edi_250 = 134946403;
				}
l08077EF0:
				Eq_2 dwLoc80_5613;
				int8 al_3460;
				ptr32 esp_3420;
				Eq_2 esi_3394;
				ptr32 esp_3403;
				struct Eq_78432 * esp_3307 = fp - 0x0100;
				struct Eq_11223 * esi_3247 = esi_45;
				int32 edx_3246 = dwArg0C->dw0004;
				byte al_3281 = ((byte) esi_45 >> 0x05 ^ 0x01) & 0x01;
				if (ebx_2058 != 0x00)
				{
					dwLoc80_5613 = edx_3246 - 0x04;
					if (edx_3246 <= 0x04 || al_3281 == 0x00)
					{
						ebx_2058.u0 = 0x00;
						goto l08077F24;
					}
					goto l08078120;
				}
				if ((esi_45 & 0x50) == 0x00)
				{
					dwLoc80_5613 = edx_3246 - 0x03;
					if (edx_3246 <= 0x03)
						goto l080781E5;
				}
				else
				{
					dwLoc80_5613 = edx_3246 - 0x04;
					if (edx_3246 <= 0x04)
						goto l080781E5;
				}
				if (al_3281 != 0x00)
				{
l08078120:
					Eq_2 eax_3329;
					if ((ecx_47 & 0x01) != 0x00)
					{
						Eq_2 esp_3362 = <invalid>;
						word32 ecx_9246;
						word32 esi_9248;
						word32 edx_9247;
						eax_3329 = _IO_wpadn(gs, dwArg04, 0x20, dwLoc80_5613, out ecx_9246, out edx_9247, out ebx_2058, out ebp_1126, out esi_9248, out edi_250);
						esp_3307 = (word32) esp_3362 + 16;
					}
					else
					{
						Eq_2 esp_3336 = <invalid>;
						word32 esi_9245;
						word32 ecx_9243;
						word32 edx_9244;
						eax_3329 = _IO_padn(gs, dwArg04, 0x20, dwLoc80_5613, out ecx_9243, out edx_9244, out ebx_2058, out ebp_1126, out esi_9245, out edi_250);
						esp_3307 = (word32) esp_3336 + 16;
					}
					if (eax_3329 == ebp_1126->ptrFFFFFF88)
					{
						word32 eax_3375 = ebp_1126->dwFFFFFFA4;
						ebx_2058 = ebp_1126->ptrFFFFFF88;
						ebp_1126->tFFFFFF58.u0 = 0x01;
						if (eax_3375 == 0x00)
						{
							esi_3247 = (word32) ebp_1126->ptrFFFFFF84->b000C;
							if ((esi_3247 & 0x40) == 0x00)
								goto l08078174;
							goto l080781ED;
						}
l08077F24:
						if (ebp_1126->dwFFFFFF54 != 0x00)
						{
							Eq_2 eax_3523 = ebp_1126->ptrFFFFFF7C->t0058;
							if (eax_3523 != 0x00)
							{
								struct Eq_78442 * edx_3527 = *((word32) eax_3523 + 16);
								if (edx_3527 < *((word32) eax_3523 + 20))
								{
									*((word32) eax_3523 + 16) = (char *) &edx_3527->t0000 + 4;
									edx_3527->t0000.u0 = 0x2D;
									goto l08078228;
								}
							}
							struct Eq_78431 * esp_3531 = esp_3307 - 0x08;
							esp_3531->dwFFFFFFFC = 0x2D;
							esp_3420 = esp_3531 - 4;
							goto l08079E43;
						}
						esi_3394 = ebp_1126->ptrFFFFFF7C;
						Eq_2 eax_3493 = *((word32) esi_3394 + 20);
						if (eax_3493 < *((word32) esi_3394 + 24))
						{
							ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_3493 + 1;
							*eax_3493 = 0x2D;
							goto l08078228;
						}
						struct Eq_80313 * esp_3498 = esp_3307 - 0x08;
						esp_3498->dwFFFFFFFC = 0x2D;
						esp_3403 = esp_3498 - 4;
						goto l0807A0D4;
					}
l08078BC0:
					goto l080782CA;
				}
l080781E5:
				if ((esi_45 & 0x40) == 0x00)
				{
l08078174:
					if ((esi_3247 & 0x10) == 0x00)
					{
l0807822B:
						Eq_2 eax_3682;
						Eq_2 esi_3586 = (word32) ebx_2058 + 3;
						if (ebp_1126->dwFFFFFF54 != 0x00)
						{
							ebp_1126->ptrFFFFFF68 -= ebx_2058 * 0x04;
							do
							{
								int8 al_3737;
								Eq_2 ecx_3706 = ebp_1126->ptrFFFFFF68[ebx_2058];
								Eq_2 eax_3708 = ebp_1126->ptrFFFFFF7C->t0058;
								if (eax_3708 != 0x00)
								{
									struct Eq_78514 * edx_3712 = *((word32) eax_3708 + 16);
									if (edx_3712 >= *((word32) eax_3708 + 20))
										goto l08078C40;
									*((word32) eax_3708 + 16) = (char *) &edx_3712->t0000 + 4;
									edx_3712->t0000 = ecx_3706;
									al_3737 = (int8) (ecx_3706 == ~0x00);
								}
								else
								{
l08078C40:
									struct Eq_78483 * esp_3717 = esp_3307 - 0x08;
									esp_3717->tFFFFFFFC = ecx_3706;
									esp_3717->tFFFFFFF8 = ebp_1126->ptrFFFFFF7C;
									word32 ecx_9180;
									al_3737 = (int8) (__woverflow(esp_3717->tFFFFFFF8, esp_3717->tFFFFFFFC, out ecx_9180) == ~0x00);
								}
								if (al_3737 != 0x00)
									goto l08078BC0;
								ebx_2058 = (word32) ebx_2058 + 1;
							} while (ebx_2058 != esi_3586);
							if ((ebp_1126->ptrFFFFFF84->b000C & 0x20) != 0x00 && ebp_1126->tFFFFFF58 != 0x00)
							{
								esp_3307->tFFFFFFF8 = ebp_1126->ptrFFFFFF88;
								esp_3307->tFFFFFFF4.u0 = 0x20;
								esp_3307->tFFFFFFF0 = ebp_1126->ptrFFFFFF7C;
								word32 esi_9183;
								word32 edi_9184;
								word32 edx_9182;
								word32 ecx_9181;
								eax_3682 = _IO_wpadn(gs, esp_3307->tFFFFFFF0, esp_3307->tFFFFFFF4, esp_3307->tFFFFFFF8, out ecx_9181, out edx_9182, out ebx_2058, out ebp_1126, out esi_9183, out edi_9184);
								goto l080782BF;
							}
						}
						else
						{
							ebp_1126->ptrFFFFFF68 = edi_250 - ebx_2058;
							Eq_2 edi_3609 = ebp_1126->ptrFFFFFF7C;
							do
							{
								word32 edx_3614 = CONVERT(Mem3611[Mem3611[ebp_1126 + -0x0098:word32] + ebx_2058:byte], byte, word32);
								byte dl_3639 = (byte) edx_3614;
								Eq_2 eax_3616 = *((word32) edi_3609 + 20);
								if (eax_3616 < *((word32) edi_3609 + 24))
								{
									*((word32) edi_3609 + 20) = (word32) eax_3616 + 1;
									*eax_3616 = dl_3639;
								}
								else
								{
									struct Eq_80209 * esp_3620 = esp_3307 - 0x08;
									esp_3620->tFFFFFFFC = edx_3614;
									esp_3620->tFFFFFFF8 = edi_3609;
									word32 edx_9238;
									word32 ecx_9237;
									if (__overflow(esp_3620->tFFFFFFF8, esp_3620->tFFFFFFFC, out ecx_9237, out edx_9238) == ~0x00)
										goto l08078BC0;
								}
								ebx_2058 = (word32) ebx_2058 + 1;
							} while (ebx_2058 != esi_3586);
							if ((ebp_1126->ptrFFFFFF84->b000C & 0x20) != 0x00 && ebp_1126->tFFFFFF58 != 0x00)
							{
								esp_3307->tFFFFFFF8 = ebp_1126->ptrFFFFFF88;
								esp_3307->tFFFFFFF4.u0 = 0x20;
								esp_3307->tFFFFFFF0 = ebp_1126->ptrFFFFFF7C;
								word32 ecx_9239;
								word32 esi_9241;
								word32 edi_9242;
								word32 edx_9240;
								eax_3682 = _IO_padn(gs, esp_3307->tFFFFFFF0, esp_3307->tFFFFFFF4, esp_3307->tFFFFFFF8, out ecx_9239, out edx_9240, out ebx_2058, out ebp_1126, out esi_9241, out edi_9242);
l080782BF:
								if (eax_3682 == ebp_1126->ptrFFFFFF88)
								{
l080782C8:
									goto l080782CA;
								}
								goto l08078BC0;
							}
						}
l080782CA:
						edi_2346 = ebp_1126->dwFFFFFFE4 ^ gs->t0014;
						if (edi_2346 == 0x00)
							return;
						word32 edx_9186;
						word32 ecx_9185;
						__stack_chk_fail(out ecx_9185, out edx_9186);
						esp_3814.u0 = <invalid>;
l0807A5B4:
						word32 eax_3821 = ebp_1126->dwFFFFFF80;
						Eq_78667 esp_3829 = esp_3814 - 4;
						*esp_3829 = ebx_2058;
						Eq_78671 ebx_3833 = ebp_1126->tFFFFFF40;
						*((word32) esp_3829 - 4) = 0x06;
						*((word32) esp_3829 - 8) = eax_3821 + ~0x0001C153;
						*((word32) esp_3829 - 0x0C) = ebx_3833;
						word32 edx_9264;
						Eq_2 ecx_3842 = __wmemcpy(*((word32) esp_3829 - 0x0C), *((word32) esp_3829 - 8), *((word32) esp_3829 - 4), out edx_9264);
						*((word32) ebx_3833 + 4) = ebp_1126->dwFFFFFF50;
						esp_3814 = esp_3829 + 0x04;
						if (ebx_3833 + 0x08 >u edi_2346)
							edi_2346 = (word32) edi_2346 + 20;
						else
						{
							*esp_3829 = ecx_3842;
							Mem3865[esp_3829 + -4:word32] = edi_2346 - (ebx_3833 + 0x08) >> 0x02;
							word32 eax_3866 = ebp_1126->tFFFFFF40;
							*((word32) esp_3829 - 8) = 0x30;
							*((word32) esp_3829 - 0x0C) = eax_3866 + 0x18;
							__wmemset(*((word32) esp_3829 - 0x0C), *((word32) esp_3829 - 8), *((word32) esp_3829 - 4));
							edi_2346 = (word32) edi_2346 + 16;
							esp_3814 = (word32) esp_3829 + 4;
						}
						goto l08079098;
					}
					if (ebp_1126->dwFFFFFF54 != 0x00)
					{
						Eq_2 eax_3466 = ebp_1126->ptrFFFFFF7C->t0058;
						if (eax_3466 != 0x00)
						{
							struct Eq_78442 * edx_3470 = *((word32) eax_3466 + 16);
							if (edx_3470 < *((word32) eax_3466 + 20))
							{
								*((word32) eax_3466 + 16) = (char *) &edx_3470->t0000 + 4;
								edx_3470->t0000.u0 = 0x20;
								goto l08078228;
							}
						}
						struct Eq_80437 * esp_3474 = esp_3307 - 0x08;
						esp_3474->dwFFFFFFFC = 0x20;
						esp_3420 = esp_3474 - 4;
l08079E43:
						struct Eq_80503 * esp_3542 = esp_3420 - 4;
						esp_3542->t0000 = ebp_1126->ptrFFFFFF7C;
						esp_3307 = (struct Eq_78432 *) ((char *) &esp_3542->t0004 + 0x0C);
						word32 ecx_9251;
						al_3460 = (int8) (__woverflow(esp_3542->t0000, esp_3542->t0004, out ecx_9251) == ~0x00);
						goto l08079E57;
					}
					Eq_2 ecx_3438 = ebp_1126->ptrFFFFFF7C;
					Eq_2 eax_3439 = *((word32) ecx_3438 + 20);
					if (eax_3439 < *((word32) ecx_3438 + 24))
					{
						ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_3439 + 1;
						*eax_3439 = 0x20;
						goto l08078228;
					}
					struct Eq_80463 * esp_3443 = esp_3307 - 0x08;
					esp_3443->tFFFFFFFC.u0 = 0x20;
					esp_3443->tFFFFFFF8 = ecx_3438;
					esp_3307 = (struct Eq_78432 *) ((char *) &esp_3443->tFFFFFFFC + 0x0C);
					word32 ecx_9249;
					word32 edx_9250;
					al_3460 = (int8) (__overflow(esp_3443->tFFFFFFF8, esp_3443->tFFFFFFFC, out ecx_9249, out edx_9250) == ~0x00);
l08079E57:
					if (al_3460 != 0x00)
						goto l08078BC0;
					goto l08078228;
				}
l080781ED:
				if (ebp_1126->dwFFFFFF54 != 0x00)
				{
					Eq_2 eax_3410 = ebp_1126->ptrFFFFFF7C->t0058;
					if (eax_3410 != 0x00)
					{
						struct Eq_78442 * edx_3414 = *((word32) eax_3410 + 16);
						if (edx_3414 < *((word32) eax_3410 + 20))
						{
							*((word32) eax_3410 + 16) = (char *) &edx_3414->t0000 + 4;
							edx_3414->t0000.u0 = 0x2B;
							goto l08078228;
						}
					}
					struct Eq_80549 * esp_3418 = esp_3307 - 0x08;
					esp_3418->dwFFFFFFFC = 0x2B;
					esp_3420 = esp_3418 - 4;
					goto l08079E43;
				}
				esi_3394 = ebp_1126->ptrFFFFFF7C;
				Eq_2 eax_3395 = *((word32) esi_3394 + 20);
				if (eax_3395 < *((word32) esi_3394 + 24))
				{
					ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_3395 + 1;
					*eax_3395 = 0x2B;
l08078228:
					ebx_2058 = (byte) ebx_2058.u0 + 1;
					goto l0807822B;
				}
				struct Eq_80575 * esp_3401 = esp_3307 - 0x08;
				esp_3401->dwFFFFFFFC = 0x2B;
				esp_3403 = esp_3401 - 4;
l0807A0D4:
				struct Eq_80600 * esp_3503 = esp_3403 - 4;
				esp_3503->t0000 = esi_3394;
				esp_3307 = (struct Eq_78432 *) ((char *) &esp_3503->t0004 + 0x0C);
				word32 ecx_9252;
				word32 edx_9253;
				al_3460 = (int8) (__overflow(esp_3503->t0000, esp_3503->t0004, out ecx_9252, out edx_9253) == ~0x00);
				goto l08079E57;
			}
			else
			{
				real64 rLoc1_5426 = (real64) *edx_162;
				Eq_80774 FPUF_329 = cond(rLoc1_5426);
				ui32 eax_345 = SEQ(eax_16_16_340, FPUF_329 << 8);
				if (PARITY_EVEN(rLoc1_5426 - rLoc1_5426))
				{
					ebx_2058 = eax_345 & 0x0200;
					goto l08078A9B;
				}
				if ((FPUF_329 & 0x45) != 0x05)
				{
					Eq_2 eax_370 = __mpn_extract_long_double(fp - 0x34, fp - 88, fp - 100, (real80) rLoc1_5426);
					dwLoc80_5422 = eax_370;
					dwLoc50_5423 = eax_370;
					edi_296 = (eax_370 << 0x05) - 0x3F;
					goto l080783DA;
				}
				ebx_2058 = eax_345 & 0x0200;
				if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) == 0x00)
				{
l0807807E:
					edi_250 = 134946407;
					goto l08077EF0;
				}
l08077EDB:
				edi_250 = 134946399;
				goto l08077EF0;
			}
		}
		cu8 * dwLocDC_5378;
		if (bl_54 == 0x00)
			dwLocDC_5378 = (cu8 *) *((word32) dwArg08->t0004 + 40);
		else
			dwLocDC_5378 = dwArg08->ptr0010->ptr0030;
		ebx_101 = ~(0x00 - (word32) (*dwLocDC_5378 < 0x01)) & ~0x01;
		*dwLocDC_5378 == 0x00;
l08077E13:
		edx_162 = (union Eq_2 *) *dwArg10;
		if ((al_177 & 0x10) != 0x00)
			goto l08077E1D;
		goto l08078030;
	}
l08077DF5:
	goto l08077E13;
}

// subject_text_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0807A640: void __printf_fp(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_78200) dwArg08, Stack (ptr32 (ptr32 Eq_2)) dwArg0C)
void __printf_fp(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_78200 * dwArg08, union Eq_2 ** dwArg0C)
{
	__printf_fp_l(gs, dwLoc20, dwArg04, gs->ptrFFFFFFD4, dwArg08, dwArg0C);
}

// 0807A670: void __guess_grouping(Stack Eq_2 dwArg04, Stack (ptr32 cu8) dwArg08)
void __guess_grouping(Eq_2 dwArg04, cu8 * dwArg08)
{
	if (*dwArg08 > 0x7E || *dwArg08 < 0x01)
		return;
	__guess_grouping.part.0(dwArg04, dwArg08);
}

// 0807A6A0: void register_printf_specifier(Register (ptr32 Eq_9) gs, Stack uint32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
// Called from:
//      register_printf_function
void register_printf_specifier(struct Eq_9 * gs, uint32 dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	struct Eq_84649 * ebx_102 = &g_t80CE000;
	uint32 esi_21 = dwArg04;
	if (dwArg04 > 0xFF)
	{
		gs->tFFFFFFE0.u0 = 22;
		return;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_36;
	if (!__cmpxchg(lock, 0x01, 0x00, out eax_36))
		__lll_lock_wait_private(eax_36, 0x080CFA20, gs);
	Eq_2 edx_113;
	Eq_2 ecx_111;
	Eq_2 eax_61;
	Eq_2 edx_48[] = __printf_function_table;
	if (edx_48 != null)
		eax_61 = __printf_arginfo_table;
	else
	{
		word32 edx_187;
		word32 ebp_188;
		word32 edi_189;
		eax_61 = __libc_calloc(gs, 0x0100, 0x08, out ecx_111, out edx_187, out ebx_102, out ebp_188, out esi_21, out edi_189);
		ebx_102->t1FE8 = eax_61;
		if (eax_61 == 0x00)
		{
			edx_113.u0 = ~0x00;
			goto l0807A70A;
		}
		ebx_102->dw1FD4 = (word32) eax_61 + 0x0400;
		edx_48 = (word32) eax_61 + 0x0400;
	}
	edx_48[esi_21] = dwArg08;
	*((word32) eax_61 + esi_21 * 0x04) = dwArg0C;
	ecx_111 = dwArg08;
	edx_113.u0 = 0x00;
l0807A70A:
	if (gs->t000C != 0x00)
		__lock();
	word32 v14_105 = ebx_102->dw1A20 - 0x01;
	ebx_102->dw1A20 = v14_105;
	if (v14_105 != 0x00)
		__lll_unlock_wake_private(&ebx_102->dw1A20, ecx_111, edx_113, gs);
}

// 0807A790: void register_printf_function(Register (ptr32 Eq_9) gs, Stack uint32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
void register_printf_function(struct Eq_9 * gs, uint32 dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	register_printf_specifier(gs, dwArg04, dwArg08, dwArg0C);
}

// 0807A7A0: void __printf_fphex(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_84746) dwArg08, Stack (ptr32 (ptr32 Eq_2)) dwArg0C)
void __printf_fphex(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_84746 * dwArg08, union Eq_2 ** dwArg0C)
{
	word32 dwLoc0148_3452;
	byte * dwLoc014C_3451;
	__align(fp);
	ui32 edx_32 = (word32) dwArg08->b000D;
	struct Eq_84758 * ebp_1004 = fp - 8;
	Eq_2 edi_1297 = dwArg04;
	int32 esi_42 = dwArg08->dw0004;
	ui32 ecx_45 = SEQ(SLICE(edx_32, word24, 8), (byte) edx_32 >> 0x02);
	if (((byte) edx_32 & 0x01) == 0x00)
	{
		struct Eq_73205 * ecx_63 = *gs->ptrFFFFFFDC;
		dwLoc014C_3451 = ecx_63->ptr0024;
		dwLoc0148_3452 = ecx_63->dw0030;
	}
	else
	{
		struct Eq_84777 * ecx_56 = *gs->ptrFFFFFFD8;
		dwLoc014C_3451 = ecx_56->ptr002C;
		dwLoc0148_3452 = ecx_56->dw00D0;
	}
	if (*dwLoc014C_3451 == 0x00 || dwLoc0148_3452 == 0x00)
	{
		word32 ecx_5052;
		word32 edx_5053;
		__assert_fail(out ecx_5052, out edx_5053);
		goto l0807C4D2;
	}
	ui32 edx_110;
	ui32 dwLoc0128_3465;
	Eq_2 ebx_1077;
	Eq_2 edi_1007;
	struct Eq_84813 * esp_1016;
	union Eq_2 * eax_106 = *dwArg0C;
	ui16 eax_16_16_325 = SLICE(eax_106, word16, 16);
	ui32 esi_107 = dwArg08->dw0008;
	if ((edx_32 & 0x10) != 0x00)
	{
		Eq_2 xmm1_534 = *eax_106;
		dwLoc0128_3465 = SEQ(SLICE(eax_106, word24, 8), __movmskps(xmm1_534)) & 0x08;
		word32 dwLoc0140_3583 = (word32) xmm1_534;
		word32 dwLoc013C_3588 = (word32) SLICE(xmm1_534, word96, 32);
		if (__unordtf2((word32) xmm1_534, SLICE(xmm1_534, word32, 32), SLICE(xmm1_534, word32, 64), SLICE(xmm1_534, word32, 96), (word32) xmm1_534, SLICE(xmm1_534, word32, 32), SLICE(xmm1_534, word32, 64), SLICE(xmm1_534, word32, 96)) != 0x00)
		{
			(gs->ptrFFFFFFF8[esi_107].b0001 & 0x01) != 0x00;
			goto l0807AF02;
		}
		word128 xmm0_576 = __pand(xmm1_534, g_ow80B1ED0);
		word128 xmm5_577 = g_ow80B1EE0;
		if (__unordtf2((word32) xmm0_576, SLICE(xmm0_576, word32, 32), SLICE(xmm0_576, word32, 64), SLICE(xmm0_576, word32, 96), (word32) xmm5_577, SLICE(xmm5_577, word32, 32), SLICE(xmm5_577, word32, 64), SLICE(xmm5_577, word32, 96)) == 0x00 && __lttf2((word32) xmm0_576, SLICE(xmm0_576, word32, 32), SLICE(xmm0_576, word32, 64), SLICE(xmm0_576, word32, 96), (word32) xmm5_577, SLICE(xmm5_577, word32, 32), SLICE(xmm5_577, word32, 64), SLICE(xmm5_577, word32, 96)) > 0x00)
		{
			(gs->ptrFFFFFFF8[esi_107].b0001 & 0x01) != 0x00;
l0807AF02:
			edx_110 = (word32) dwArg08->b000C;
			goto l0807AF0C;
		}
		struct Eq_84895 * ebp_870;
		word32 edi_5055;
		word32 ebx_5054;
		_itoa(gs, SEQ(dwLoc013C_3588, dwLoc0140_3583), fp - 0x24, 0x10, (uint32) (int8) (esi_107 == 0x41), out ebx_5054, out ebp_870, out edi_5055);
		Eq_2 esp_876 = <invalid>;
		*((word32) esp_876 + 16) = (word32) (ebp_870->ptrFFFFFEDC->dw0008 == 0x41);
		((word32) esp_876 + 0x0C)->u0 = 0x10;
		*((word32) esp_876 + 8) = ebp_870 - 0x44;
		*((word32) esp_876 + 4) = ebp_870->dwFFFFFE9C;
		*esp_876 = ebp_870->tFFFFFE98;
		ebp_870->ptrFFFFFE80 = ebp_870 - 0x44;
		Eq_2 esp_910 = <invalid>;
		struct Eq_84959 * ebp_904;
		word32 edi_5056;
		Eq_2 esi_909;
		Eq_2 edx_918 = _itowa(gs, *esp_876, *((word32) esp_876 + 8), *((word32) esp_876 + 0x0C), *((word32) esp_876 + 16), out ebp_904, out esi_909, out edi_5056);
		Eq_2 eax_919 = esi_909;
		if (esi_909 > ebp_904 - 44)
		{
			do
			{
				--eax_919;
				*eax_919 = 0x30;
				edx_918 -= 0x04;
				*edx_918 = 0x30;
			} while (eax_919 != ebp_904 - 44);
			esi_909 = eax_919;
		}
		ebp_904->tFFFFFE88 = ebp_904->tFFFFFED0;
		ebp_904->dwFFFFFE8C = (word32) ebp_904->w012C;
		*((word32) esp_910 + 16) = (word32) (ebp_904->ptrFFFFFEDC->dw0008 == 0x41);
		((word32) esp_910 + 0x0C)->u0 = 0x10;
		*((word32) esp_910 + 8) = esi_909;
		*((word32) esp_910 + 4) = ebp_904->dwFFFFFE8C;
		*esp_910 = ebp_904->tFFFFFE88;
		struct Eq_85060 * ebp_971;
		Eq_2 ebx_972;
		word32 edi_5057;
		ebp_971->tFFFFFE94 = _itoa(gs, *esp_910, *((word32) esp_910 + 8), *((word32) esp_910 + 0x0C), *((word32) esp_910 + 16), out ebx_972, out ebp_971, out edi_5057);
		Eq_2 esp_977 = <invalid>;
		*((word32) esp_977 + 16) = (word32) (ebp_971->ptrFFFFFEDC->dw0008 == 0x41);
		((word32) esp_977 + 0x0C)->u0 = 0x10;
		*((word32) esp_977 + 8) = ebx_972;
		*((word32) esp_977 + 4) = ebp_971->dwFFFFFE8C;
		*esp_977 = ebp_971->tFFFFFE88;
		Eq_2 esi_1009;
		Eq_2 eax_1003 = _itowa(gs, *esp_977, *((word32) esp_977 + 8), *((word32) esp_977 + 0x0C), *((word32) esp_977 + 16), out ebp_1004, out esi_1009, out edi_1007);
		ebp_1004->tFFFFFEA8 = eax_1003;
		Eq_2 esp_1010 = <invalid>;
		esp_1016 = (word32) esp_1010 + 32;
		if (esi_1009 > ebp_1004 - 0x38)
		{
			Eq_2 edx_1020 = eax_1003;
			eax_1003 = esi_1009;
			do
			{
				--eax_1003;
				*eax_1003 = 0x30;
				edx_1020 -= 0x04;
				*edx_1020 = 0x30;
			} while (eax_1003 != ebp_1004 - 0x38);
			Eq_2 esi_1033 = ebp_1004->tFFFFFEA8;
			Eq_85238 edx_1035 = eax_1003 - ebp_1004->tFFFFFE94;
			ebp_1004->tFFFFFE94 = eax_1003;
			ebp_1004->tFFFFFEA8 = (word32) esi_1033 + edx_1035 * 0x04;
		}
		Eq_2 ebx_1043 = ebp_1004->tFFFFFE88;
		ui32 esi_1044 = ebp_1004->dwFFFFFE8C;
		ui32 edx_1045 = ebp_1004->dwFFFFFE9C;
		ebp_1004->tFFFFFE93 = (int8) (((word16) __pextrw(eax_1003, ebp_1004->tFFFFFEC8, 0x07) & 0x7FFF) != 0x00) + 0x30;
		ui32 ecx_1064 = ebx_1043 | ebp_1004->tFFFFFE98;
		ui32 eax_1065 = (word32) ebp_1004->wFFFFFF26;
		ebp_1004->tFFFFFE98 = eax_1065 & 0x7FFF;
		ui32 ebx_1062 = esi_1044 | edx_1045;
		if ((eax_1065 & 0x7FFF) != 0x00)
		{
			Eq_85202 eax_1084 = ebp_1004->tFFFFFE98;
			if (eax_1084 > 0x3FFE)
			{
				ebp_1004->tFFFFFE98.u0 = 0x00;
				ebx_1077 = eax_1084 - 0x3FFF;
			}
			else
			{
				ebx_1077 = 0x3FFF - ebp_1004->tFFFFFE98;
				ebp_1004->tFFFFFE98.u0 = 0x01;
			}
		}
		else
		{
			uint32 eax_1072 = ebx_1062 | ecx_1064;
			ebp_1004->tFFFFFE98 = (word32) (eax_1072 != 0x00);
			ebx_1077 = ~(0x00 - (word32) (eax_1072 < 0x01)) & 0x3FFE;
		}
		ebp_1004->tFFFFFE88 = (uint32) (int8) ((ecx_1064 | ebx_1062) == 0x00);
		goto l0807B220;
	}
	edx_110 = (word32) dwArg08->b000C;
	if (((byte) edx_110 & 0x01) != 0x00)
	{
		real64 rLoc1_3484 = (real64) *eax_106;
		Eq_88464 FPUF_323 = cond(rLoc1_3484);
		dwLoc0128_3465 = SEQ(eax_16_16_325, FPUF_323 << 8) & 0x0200;
		if (!PARITY_EVEN(rLoc1_3484 - rLoc1_3484))
		{
			if ((FPUF_323 & 0x45) != 0x05)
			{
				struct Eq_88491 * ebp_405;
				word32 ebx_5150;
				word32 edi_5151;
				_itoa(gs, (word64) (real80) rLoc1_3484, fp - 0x24, 0x10, (uint32) (int8) (esi_107 == 0x41), out ebx_5150, out ebp_405, out edi_5151);
				Eq_2 esp_411 = <invalid>;
				*((word32) esp_411 + 16) = (word32) (ebp_405->ptrFFFFFEDC->dw0008 == 0x41);
				((word32) esp_411 + 0x0C)->u0 = 0x10;
				*((word32) esp_411 + 8) = ebp_405 - 0x44;
				*((word32) esp_411 + 4) = ebp_405->dwFFFFFECC;
				*esp_411 = ebp_405->tFFFFFEC8;
				ebp_405->ptrFFFFFE80 = ebp_405 - 0x44;
				Eq_2 esp_445 = <invalid>;
				byte * esi_444;
				Eq_2 eax_438 = _itowa(gs, *esp_411, *((word32) esp_411 + 8), *((word32) esp_411 + 0x0C), *((word32) esp_411 + 16), out ebp_1004, out esi_444, out edi_1007);
				esp_1016 = (word32) esp_445 + 32;
				Eq_2 edx_453 = eax_438;
				byte * eax_454 = esi_444;
				if (esi_444 > ebp_1004 - 44)
				{
					do
					{
						--eax_454;
						*eax_454 = 0x30;
						edx_453 -= 0x04;
						*edx_453 = 0x30;
					} while (eax_454 != ebp_1004 - 44);
					ebp_1004->tFFFFFE94 = ebp_1004 - 0x2B;
					ebp_1004->tFFFFFEA8 = (word32) eax_438 + 4 + (eax_454 - esi_444) * 0x04;
					esi_444 = eax_454;
				}
				else
				{
					ebp_1004->tFFFFFE94 = esi_444 + 1;
					ebp_1004->tFFFFFEA8 = (word32) eax_438 + 4;
				}
				ui32 ebx_487 = (word32) ebp_1004->wFFFFFF10;
				ebp_1004->tFFFFFE93 = *esi_444;
				ebx_1077 = ebx_487 & 0x7FFF;
				if ((ebx_487 & 0x7FFF) == 0x00)
				{
					uint32 eax_506 = ebp_1004->dwFFFFFECC | ebp_1004->tFFFFFEC8;
					ebp_1004->tFFFFFE98 = 0x00 - (word32) (eax_506 < 0x01) + 0x01;
					if (eax_506 != 0x00)
						ebx_1077.u0 = 0x4001;
				}
				else if ((ebx_487 & 0x7FFF) > 0x4001)
					ebx_1077 = (ebx_487 & 0x7FFF) - 0x4002;
				else
				{
					ebp_1004->tFFFFFE98.u0 = 0x01;
					ebx_1077 = 0x4002 - (ebx_487 & 0x7FFF);
				}
				goto l0807B220;
			}
			(gs->ptrFFFFFFF8[esi_107].b0001 & 0x01) != 0x00;
			goto l0807AF0C;
		}
		if ((gs->ptrFFFFFFF8[esi_107].b0001 & 0x01) == 0x00)
			goto l0807AF0C;
	}
	else
	{
		Eq_80752 xmm0_115 = SEQ(0x00, *eax_106);
		ui32 eax_117 = SEQ(SLICE(eax_106, word24, 8), __movmskpd(xmm0_115));
		Eq_2 rLocF0_3464 = *eax_106;
		uint32 dwLocF0_3472 = (word32) rLocF0_3464;
		ui32 dwLocEC_3474 = SLICE(rLocF0_3464, word32, 32);
		dwLoc0128_3465 = eax_117 & 0x01;
		if (!PARITY_EVEN(*eax_106 - *eax_106))
		{
			if ((real64) __andpd(xmm0_115, g_t80B1EF0) <= g_t80B1F00)
			{
				struct Eq_88686 * ebp_195;
				Eq_2 esi_200;
				word32 edi_5152;
				Eq_2 eax_194 = _itowa(gs, SEQ(dwLocEC_3474 & 0x000FFFFF, dwLocF0_3472), fp - 0x4C, 0x10, (uint32) (int8) (esi_107 == 0x41), out ebp_195, out esi_200, out edi_5152);
				ebp_195->tFFFFFE84 = esi_200;
				ebp_195->tFFFFFEA8 = eax_194;
				Eq_2 esp_201 = <invalid>;
				*((word32) esp_201 + 16) = (word32) (ebp_195->ptrFFFFFEDC->dw0008 == 0x41);
				((word32) esp_201 + 0x0C)->u0 = 0x10;
				*((word32) esp_201 + 8) = esi_200;
				*((word32) esp_201 + 4) = ebp_195->dwFFFFFECC;
				*esp_201 = ebp_195->tFFFFFEC8;
				ptr32 ebx_229;
				ebp_1004->tFFFFFE94 = _itoa(gs, *esp_201, *((word32) esp_201 + 8), *((word32) esp_201 + 0x0C), *((word32) esp_201 + 16), out ebx_229, out ebp_1004, out edi_1007);
				Eq_2 esp_234 = <invalid>;
				esp_1016 = (word32) esp_234 + 32;
				if (ebx_229 > ebp_1004 - 0x78)
				{
					Eq_2 esi_244 = ebp_1004->tFFFFFEA8;
					ptr32 ecx_245 = ~(ebp_1004 - 0x78);
					Eq_2 ebx_246 = ebp_1004->tFFFFFE94;
					Eq_88808 eax_247 = 0x00;
					Eq_88808 edx_251 = ~((word32) esi_244 + ecx_245 >> 0x02);
					do
					{
						(esi_244 - 0x04)[eax_247] = 0x30;
						Mem256[ebx_246 - 0x01 + eax_247:byte] = 0x30;
						--eax_247;
					} while (eax_247 != edx_251);
					Eq_2 edx_262 = ebp_1004->tFFFFFEA8;
					Eq_88833 ecx_264 = (word32) edx_262 + ecx_245;
					ebp_1004->tFFFFFE94 = (word32) ebp_1004->tFFFFFE94 + ~(ecx_264 >> 0x02);
					ebp_1004->tFFFFFEA8 = edx_262 - ((word32) ((ecx_264 >> 0x02) * 0x04) + 4);
				}
				word32 ebx_276 = (word32) ebp_1004->wFFFFFF1E;
				cu16 bx_277 = (word16) ebx_276;
				ebp_1004->tFFFFFE93 = (int8) ((bx_277 & 0x7FF0) != 0x00) + 0x30;
				ui32 ebx_290 = SEQ(SLICE(ebx_276, word16, 16), bx_277 >> 0x04);
				ebx_1077 = ebx_290 & 0x07FF;
				if ((ebx_290 & 0x07FF) == 0x00)
				{
					if ((ebp_1004->dwFFFFFECC | ebp_1004->tFFFFFEC8) != 0x00)
					{
						ebp_1004->tFFFFFE98.u0 = 0x01;
						ebx_1077.u0 = 1022;
l0807B22E:
						if (ebp_1004->dwFFFFFFB8 == 0x30)
						{
							Eq_2 eax_1124 = ebp_1004->tFFFFFE80;
							Eq_2 edx_1125 = ebp_1004->tFFFFFE84;
							do
							{
								eax_1124 -= 0x04;
								--edx_1125;
							} while (*((word32) eax_1124 - 4) == 0x30);
							ebp_1004->tFFFFFE84 = edx_1125;
						}
						Eq_2 edx_1138 = ebp_1004->tFFFFFE94;
						Eq_2 ecx_1139 = ebp_1004->tFFFFFEC4;
						Eq_2 esi_1140 = ebp_1004->tFFFFFE84 - edx_1138;
						if (ecx_1139 == ~0x00)
						{
							ebp_1004->tFFFFFEC4 = esi_1140;
							goto l0807AD70;
						}
						if (ecx_1139 >= esi_1140)
						{
l0807AD70:
							struct Eq_86011 * esp_1821 = esp_1016 - 4;
							esp_1821->t0000.u0 = 0x00;
							esp_1821->tFFFFFFFC.u0 = 0x0A;
							Eq_2 esi_1796 = ebp_1004 - 0x3C;
							esp_1821->tFFFFFFF8 = esi_1796;
							esp_1821->tFFFFFFF4 = ebx_1077;
							word32 ecx_5083;
							word32 edx_5084;
							Eq_2 eax_1833 = _itoa_word(esp_1821->tFFFFFFF4, esp_1821->tFFFFFFF8, esp_1821->tFFFFFFFC, esp_1821->t0000, out ecx_5083, out edx_5084);
							ebp_1004->tFFFFFEC8 = edi_1007;
							ebp_1004->tFFFFFE88 = eax_1833;
							ebp_1004->tFFFFFE80 = esi_1796;
							Eq_2 edi_1851 = ebp_1004 - 0xC4;
							while (true)
							{
								uint32 edx_1860 = SLICE(ebx_1077 *64 ~0x33333332, word32, 32);
								edi_1851 -= 0x04;
								*edi_1851 = *((word32) ebp_1004->tFFFFFEE4 + ((ebx_1077 - ((edx_1860 >> 0x03) + (edx_1860 >> 0x03) * 0x04) * 0x02) * 0x04 - 88256));
								if (ebx_1077 <= 0x09)
									break;
								ebx_1077 = edx_1860 >> 0x03;
							}
							struct Eq_85328 * eax_1874 = ebp_1004->ptrFFFFFEDC;
							Eq_2 edx_1875 = ebp_1004->tFFFFFEE0;
							ebp_1004->tFFFFFE7C = edi_1851;
							ui32 ebx_1879 = (word32) eax_1874->b000C;
							Eq_2 esi_1877 = ebp_1004->tFFFFFE80;
							Eq_2 edi_1878 = ebp_1004->tFFFFFEC8;
							byte bl_1885 = (byte) ebx_1879;
							uint32 eax_1880 = 0x04;
							if (edx_1875 == 0x00)
								eax_1880 = (uint32) (int8) ((bl_1885 & 0x50) != 0x00) + 0x03;
							Eq_2 ecx_1895 = ebp_1004->tFFFFFEC4;
							Eq_2 esi_1897 = esi_1877 - ebp_1004->tFFFFFE88;
							ebp_1004->tFFFFFE80 = esi_1897;
							ebp_1004->tFFFFFEB8 -= (word32) esi_1897 + (((word32) ecx_1895 + 2) + eax_1880);
							if (ecx_1895 > 0x00 || (bl_1885 & 0x08) != 0x00)
							{
								Eq_2 eax_1914 = 0x01;
								if (ebp_1004->tFFFFFED8 == 0x00)
								{
									esp_1821->tFFFFFFF4 = ebp_1004->tFFFFFEBC;
									word32 ecx_5087;
									word32 edx_5088;
									eax_1914 = strlen(esp_1821->tFFFFFFF4, out ecx_5087, out edx_5088);
								}
								ebp_1004->tFFFFFEB8 -= eax_1914;
							}
							Eq_2 esi_1959;
							struct Eq_84813 * esp_1966 = esp_1016;
							if ((ebx_1879 & 0x20) == 0x00 && (ebp_1004->ptrFFFFFEDC)->t0010 != 0x30)
							{
								Eq_2 eax_1956 = ebp_1004->tFFFFFEB8;
								if (eax_1956 > 0x00)
								{
									Eq_2 eax_1990;
									if (ebp_1004->tFFFFFED8 == 0x00)
									{
										struct Eq_86514 * esp_2005 = esp_1016 - 0x04;
										esp_2005->tFFFFFFFC = ebp_1004->tFFFFFEB8;
										esp_2005->tFFFFFFF8.u0 = 0x20;
										esp_2005->tFFFFFFF4 = edi_1878;
										Eq_2 esp_2021 = <invalid>;
										word32 ecx_5093;
										word32 edx_5094;
										word32 ebx_5095;
										word32 esi_5096;
										eax_1990 = _IO_padn(gs, esp_2005->tFFFFFFF4, esp_2005->tFFFFFFF8, esp_2005->tFFFFFFFC, out ecx_5093, out edx_5094, out ebx_5095, out ebp_1004, out esi_5096, out edi_1878);
										esp_1966 = (word32) esp_2021 + 16;
									}
									else
									{
										struct Eq_86476 * esp_1968 = esp_1016 - 0x04;
										esp_1968->tFFFFFFFC = eax_1956;
										esp_1968->tFFFFFFF8.u0 = 0x20;
										esp_1968->tFFFFFFF4 = edi_1878;
										Eq_2 esp_1997 = <invalid>;
										word32 edx_5090;
										word32 ecx_5089;
										word32 esi_5092;
										word32 ebx_5091;
										eax_1990 = _IO_wpadn(gs, esp_1968->tFFFFFFF4, esp_1968->tFFFFFFF8, esp_1968->tFFFFFFFC, out ecx_5089, out edx_5090, out ebx_5091, out ebp_1004, out esi_5092, out edi_1878);
										esp_1966 = (word32) esp_1997 + 16;
									}
									esi_1959 = ebp_1004->tFFFFFEB8;
									if (eax_1990 != esi_1959)
										goto l0807AEB8;
l0807B542:
									int8 al_2142;
									if (ebp_1004->tFFFFFEE0 != 0x00)
									{
										if (ebp_1004->tFFFFFED8 != 0x00)
										{
											Eq_2 eax_2146 = *((word32) edi_1878 + 88);
											if (eax_2146 != 0x00)
											{
												struct Eq_86630 * edx_2150 = *((word32) eax_2146 + 16);
												if (edx_2150 < *((word32) eax_2146 + 20))
												{
													*((word32) eax_2146 + 16) = (char *) &edx_2150->t0000 + 4;
													edx_2150->t0000.u0 = 0x2D;
													goto l0807B581;
												}
											}
											esp_1966->dwFFFFFFF4 = 0x2D;
											goto l0807C303;
										}
										Eq_2 eax_2120 = *((word32) edi_1878 + 20);
										if (eax_2120 < *((word32) edi_1878 + 24))
										{
											*((word32) edi_1878 + 20) = (word32) eax_2120 + 1;
											*eax_2120 = 0x2D;
											goto l0807B581;
										}
										esp_1966->dwFFFFFFF4 = 0x2D;
l0807C3E3:
										struct Eq_88353 * esp_2127 = esp_1966 - 0x0C;
										esp_2127->tFFFFFFFC = edi_1878;
										word32 edx_5149;
										word32 ecx_5148;
										al_2142 = (int8) (__overflow(esp_2127->tFFFFFFFC, esp_2127->t0000, out ecx_5148, out edx_5149) == ~0x00);
l0807C312:
										if (al_2142 != 0x00)
											goto l0807AEB8;
										goto l0807B581;
									}
									byte al_2045 = ebp_1004->ptrFFFFFEDC->b000C;
									if ((al_2045 & 0x40) != 0x00)
									{
										if (ebp_1004->tFFFFFED8 != 0x00)
										{
											Eq_2 eax_2101 = *((word32) edi_1878 + 88);
											if (eax_2101 != 0x00)
											{
												struct Eq_86630 * edx_2105 = *((word32) eax_2101 + 16);
												if (edx_2105 < *((word32) eax_2101 + 20))
												{
													*((word32) eax_2101 + 16) = (char *) &edx_2105->t0000 + 4;
													edx_2105->t0000.u0 = 0x2B;
													goto l0807B581;
												}
											}
											esp_1966->dwFFFFFFF4 = 0x2B;
l0807C303:
											struct Eq_88276 * esp_2158 = esp_1966 - 0x0C;
											esp_2158->tFFFFFFFC = edi_1878;
											word32 ecx_5147;
											al_2142 = (int8) (__woverflow(esp_2158->tFFFFFFFC, esp_2158->t0000, out ecx_5147) == ~0x00);
											goto l0807C312;
										}
										Eq_2 eax_2091 = *((word32) edi_1878 + 20);
										if (eax_2091 >= *((word32) edi_1878 + 24))
										{
											esp_1966->dwFFFFFFF4 = 0x2B;
											goto l0807C3E3;
										}
										*((word32) edi_1878 + 20) = (word32) eax_2091 + 1;
										*eax_2091 = 0x2B;
									}
									else
									{
										if ((al_2045 & 0x10) == 0x00)
										{
l0807B584:
											struct Eq_84813 * esp_2253;
											int8 al_2518;
											Eq_2 eax_2433;
											int8 al_2275;
											if (ebp_1004->tFFFFFED8 == 0x00)
											{
												byte al_2256;
												Eq_2 eax_2212 = *((word32) edi_1878 + 20);
												if (eax_2212 < *((word32) edi_1878 + 24))
												{
													*((word32) edi_1878 + 20) = (word32) eax_2212 + 1;
													*eax_2212 = 0x30;
													Eq_2 eax_2244 = ebp_1004->ptrFFFFFEDC->t0008;
													ebp_1004->tFFFFFEE0 = eax_2244;
													al_2256 = (byte) eax_2244 + 0x17;
												}
												else
												{
													struct Eq_88085 * esp_2218 = esp_1966 - 0x08;
													esp_2218->tFFFFFFFC.u0 = 0x30;
													esp_2218->tFFFFFFF8 = edi_1878;
													word32 edx_5144;
													word32 ecx_5143;
													if (__overflow(esp_2218->tFFFFFFF8, esp_2218->tFFFFFFFC, out ecx_5143, out edx_5144) == ~0x00)
														goto l0807AEB8;
													Eq_2 eax_2236 = ebp_1004->ptrFFFFFEDC->t0008;
													ebp_1004->tFFFFFEE0 = eax_2236;
													al_2256 = (byte) eax_2236 + 0x17;
												}
												esp_2253 = esp_1966;
												Eq_2 edx_2250 = *((word32) edi_1878 + 20);
												if (edx_2250 < *((word32) edi_1878 + 24))
												{
													*((word32) edi_1878 + 20) = (word32) edx_2250 + 1;
													*edx_2250 = al_2256;
													ebp_1004->tFFFFFEC8 = (word32) esi_1959 + 2;
													if ((ebp_1004->ptrFFFFFEDC->b000C & 0x20) != 0x00 || ((ebp_1004->ptrFFFFFEDC)->t0010 != 0x30 || ebp_1004->tFFFFFEB8 <= 0x00))
													{
l0807BA30:
														Eq_2 eax_2493 = *((word32) edi_1878 + 20);
														if (eax_2493 < *((word32) edi_1878 + 24))
														{
															Eq_2 bl_2522 = ebp_1004->tFFFFFE93;
															*((word32) edi_1878 + 20) = (word32) eax_2493 + 1;
															*eax_2493 = bl_2522;
l0807B692:
															struct Eq_84813 * esp_3287;
															Eq_2 ebx_3085;
															Eq_2 eax_3061;
															int8 al_3000;
															byte al_3026;
															Eq_2 eax_2727;
															Eq_2 eax_2569 = ebp_1004->tFFFFFEC8;
															Eq_2 esi_2572 = (word32) eax_2569 + 1;
															if (ebp_1004->tFFFFFEC4 <= 0x00 && ((ebp_1004->ptrFFFFFEDC)->b000C & 0x08) == 0x00)
															{
l0807BA70:
																Eq_2 ecx_2954 = ebp_1004->tFFFFFED8;
																Eq_2 eax_2955 = ebp_1004->ptrFFFFFEDC->t0008;
																ebp_1004->tFFFFFEE0 = eax_2955;
																eax_2727 = (word32) eax_2955 + 0x0F;
																al_3026 = (byte) eax_2955 + 0x0F;
																if (ecx_2954 == 0x00)
																{
																	ebp_1004->tFFFFFEE0 = esi_2572;
l0807BCD6:
																	Eq_2 edx_3019 = *((word32) edi_1878 + 20);
																	if (edx_3019 < *((word32) edi_1878 + 24))
																	{
																		*((word32) edi_1878 + 20) = (word32) edx_3019 + 1;
																		*edx_3019 = al_3026;
																		eax_3061 = (0x00 - (word32) (ebp_1004->tFFFFFE98 < 0x01) & ~0x01) + 0x2D;
																		goto l0807BCF9;
																	}
																	struct Eq_87349 * esp_3024 = esp_2253 - 0x08;
																	esp_3024->tFFFFFFFC = (word32) al_3026;
																	esp_3024->tFFFFFFF8 = edi_1878;
																	word32 edx_5114;
																	word32 ecx_5113;
																	word32 eax_3034 = __overflow(esp_3024->tFFFFFFF8, esp_3024->tFFFFFFFC, out ecx_5113, out edx_5114);
																	esp_2253 = (struct Eq_84813 *) ((char *) &esp_3024->tFFFFFFFC + 0x0C);
																	esi_2572 = ebp_1004->tFFFFFEE0;
																	al_3000 = (int8) (eax_3034 == ~0x00);
l0807BAB5:
																	if (al_3000 != 0x00)
																		goto l0807AEB8;
																	eax_3061 = (0x00 - (word32) (ebp_1004->tFFFFFE98 < 0x01) & ~0x01) + 0x2D;
																	if (ebp_1004->tFFFFFED8 == 0x00)
																	{
																		ebp_1004->tFFFFFEE0 = esi_2572;
l0807BCF9:
																		byte al_3213 = (byte) eax_3061;
																		Eq_2 edx_3185 = *((word32) edi_1878 + 20);
																		if (edx_3185 < *((word32) edi_1878 + 24))
																		{
																			Eq_2 ebx_3211 = ebp_1004->tFFFFFEE0;
																			*((word32) edi_1878 + 20) = (word32) edx_3185 + 1;
																			*edx_3185 = al_3213;
																			ebx_3085 = (word32) ebx_3211 + 2;
																		}
																		else
																		{
																			struct Eq_87401 * esp_3189 = esp_2253 - 0x08;
																			esp_3189->tFFFFFFFC = eax_3061;
																			esp_3189->tFFFFFFF8 = edi_1878;
																			word32 ecx_5115;
																			word32 edx_5116;
																			word32 eax_3196 = __overflow(esp_3189->tFFFFFFF8, esp_3189->tFFFFFFFC, out ecx_5115, out edx_5116);
																			ebx_3085 = (word32) ebp_1004->tFFFFFEE0 + 2;
																			if (eax_3196 == ~0x00)
																				goto l0807AEB8;
																		}
																		Eq_2 eax_3219 = ebp_1004->tFFFFFE80;
																		Mem3222[ebp_1004 + -288:word32] = ebx_3085 + eax_3219;
																		esp_3287 = esp_2253;
																		Eq_87447 esi_3224 = ebp_1004->tFFFFFE88 - ebx_3085;
																		if (eax_3219 == 0x00)
																		{
l0807BB7E:
																			ebp_1004->tFFFFFEE0 = ebx_3085;
																			goto l0807BB88;
																		}
																		do
																		{
																			word32 edx_3231 = CONVERT(Mem3230[esi_3224 + ebx_3085:byte], byte, word32);
																			byte dl_3238 = (byte) edx_3231;
																			Eq_2 eax_3233 = *((word32) edi_1878 + 20);
																			if (eax_3233 >= *((word32) edi_1878 + 24))
																			{
																				struct Eq_87910 * esp_3241 = esp_2253 - 0x08;
																				esp_3241->tFFFFFFFC = edx_3231;
																				esp_3241->tFFFFFFF8 = edi_1878;
																				word32 edx_5137;
																				word32 ecx_5136;
																				if (__overflow(esp_3241->tFFFFFFF8, esp_3241->tFFFFFFFC, out ecx_5136, out edx_5137) == ~0x00)
																					goto l0807AEB8;
																			}
																			else
																			{
																				*((word32) edi_1878 + 20) = (word32) eax_3233 + 1;
																				*eax_3233 = dl_3238;
																			}
																			esp_3287 = esp_2253;
																			ebx_3085 = (word32) ebx_3085 + 1;
																		} while (ebp_1004->tFFFFFEE0 != ebx_3085);
l0807BB88:
																		struct Eq_85328 * eax_3273 = ebp_1004->ptrFFFFFEDC;
																		if ((eax_3273->b000C & 0x20) == 0x00)
																			goto l0807B06E;
																		Eq_2 eax_3277 = eax_3273->t0010;
																		if (eax_3277 == 0x30)
																			goto l0807B06E;
																		Eq_2 ebx_3280 = ebp_1004->tFFFFFEB8;
																		if (ebx_3280 <= 0x00)
																		{
l0807B06E:
																			if ((ebp_1004->dwFFFFFFE4 ^ gs->t0014) == 0x00)
																				return;
l0807C4D2:
																			word32 edx_5071;
																			word32 ecx_5070;
																			__stack_chk_fail(out ecx_5070, out edx_5071);
																			register_printf_modifier(gs, dwArg04);
																			return;
																		}
																		Eq_2 eax_3327;
																		if (ebp_1004->tFFFFFED8 != 0x00)
																		{
																			struct Eq_87611 * esp_3342 = esp_3287 - 0x04;
																			esp_3342->tFFFFFFFC = ebx_3280;
																			esp_3342->tFFFFFFF8 = eax_3277;
																			esp_3342->tFFFFFFF4 = edi_1878;
																			word32 edi_5132;
																			word32 ecx_5128;
																			word32 esi_5131;
																			word32 edx_5129;
																			word32 ebx_5130;
																			eax_3327 = _IO_wpadn(gs, esp_3342->tFFFFFFF4, esp_3342->tFFFFFFF8, esp_3342->tFFFFFFFC, out ecx_5128, out edx_5129, out ebx_5130, out ebp_1004, out esi_5131, out edi_5132);
																		}
																		else
																		{
																			struct Eq_87574 * esp_3293 = esp_3287 - 0x04;
																			esp_3293->tFFFFFFFC = ebp_1004->tFFFFFEB8;
																			esp_3293->tFFFFFFF8 = eax_3277;
																			esp_3293->tFFFFFFF4 = edi_1878;
																			word32 ebx_5125;
																			word32 edx_5124;
																			word32 ecx_5123;
																			word32 esi_5126;
																			word32 edi_5127;
																			eax_3327 = _IO_padn(gs, esp_3293->tFFFFFFF4, esp_3293->tFFFFFFF8, esp_3293->tFFFFFFFC, out ecx_5123, out edx_5124, out ebx_5125, out ebp_1004, out esi_5126, out edi_5127);
																		}
																		Eq_2 edi_3368 = ebp_1004->tFFFFFEB8;
																		if (edi_3368 == eax_3327)
																		{
																			Mem3373[ebp_1004 + -288:word32] = Mem3367[ebp_1004 + -288:word32] + edi_3368;
																			goto l0807B06E;
																		}
																		goto l0807AEB8;
																	}
																	Eq_2 edx_3073 = *((word32) edi_1878 + 88);
																	if (edx_3073 != 0x00)
																	{
																		struct Eq_86630 * ecx_3077 = *((word32) edx_3073 + 16);
																		if (ecx_3077 < *((word32) edx_3073 + 20))
																		{
																			*((word32) edx_3073 + 16) = (char *) &ecx_3077->t0000 + 4;
																			ecx_3077->t0000 = eax_3061;
																			ebx_3085 = (word32) esi_2572 + 2;
l0807BAFC:
																			Eq_2 ecx_3110 = ebp_1004->tFFFFFE80;
																			Eq_2 edx_3111 = ebp_1004->tFFFFFE7C;
																			Mem3114[ebp_1004 + -288:word32] = ebx_3085 + ecx_3110;
																			ebp_1004->tFFFFFEC8 = edx_3111 - ebx_3085 * 0x04;
																			esp_3287 = esp_2253;
																			if (ecx_3110 == 0x00)
																				goto l0807BB7E;
																			do
																			{
																				int8 al_3138;
																				Eq_2 ecx_3125 = *((word32) ebp_1004->tFFFFFEC8 + ebx_3085 * 0x04);
																				Eq_2 eax_3127 = *((word32) edi_1878 + 88);
																				if (eax_3127 == 0x00)
																				{
l0807BB69:
																					struct Eq_87807 * esp_3142 = esp_2253 - 0x08;
																					esp_3142->tFFFFFFFC = ecx_3125;
																					esp_3142->tFFFFFFF8 = edi_1878;
																					word32 ecx_5135;
																					al_3138 = (int8) (__woverflow(esp_3142->tFFFFFFF8, esp_3142->tFFFFFFFC, out ecx_5135) == ~0x00);
																					goto l0807BB46;
																				}
																				struct Eq_86630 * edx_3131 = *((word32) eax_3127 + 16);
																				if (edx_3131 >= *((word32) eax_3127 + 20))
																					goto l0807BB69;
																				*((word32) eax_3127 + 16) = (char *) &edx_3131->t0000 + 4;
																				edx_3131->t0000 = ecx_3125;
																				al_3138 = (int8) (ecx_3125 == ~0x00);
l0807BB46:
																				esp_3287 = esp_2253;
																				if (al_3138 != 0x00)
																					goto l0807AEB8;
																				ebx_3085 = (word32) ebx_3085 + 1;
																			} while (ebp_1004->tFFFFFEE0 != ebx_3085);
																			goto l0807BB88;
																		}
																	}
																	struct Eq_87722 * esp_3082 = esp_2253 - 0x08;
																	esp_3082->tFFFFFFFC = eax_3061;
																	esp_3082->tFFFFFFF8 = edi_1878;
																	ebx_3085 = (word32) esi_2572 + 2;
																	word32 ecx_5134;
																	if (__woverflow(esp_3082->tFFFFFFF8, esp_3082->tFFFFFFFC, out ecx_5134) == ~0x00)
																		goto l0807AEB8;
																	goto l0807BAFC;
																}
l0807BA90:
																Eq_2 edx_2968 = *((word32) edi_1878 + 88);
																if (edx_2968 != 0x00)
																{
																	struct Eq_86630 * ecx_2972 = *((word32) edx_2968 + 16);
																	if (ecx_2972 < *((word32) edx_2968 + 20))
																	{
																		*((word32) edx_2968 + 16) = (char *) &ecx_2972->t0000 + 4;
																		ecx_2972->t0000 = eax_2727;
																		al_3000 = (int8) (eax_2727 == ~0x00);
																		goto l0807BAB5;
																	}
																}
																struct Eq_87653 * esp_2980 = esp_2253 - 0x08;
																esp_2980->tFFFFFFFC = eax_2727;
																esp_2980->tFFFFFFF8 = edi_1878;
																esp_2253 = (struct Eq_84813 *) ((char *) &esp_2980->tFFFFFFFC + 0x0C);
																word32 ecx_5133;
																al_3000 = (int8) (__woverflow(esp_2980->tFFFFFFF8, esp_2980->tFFFFFFFC, out ecx_5133) == ~0x00);
																goto l0807BAB5;
															}
															word32 esi_2767;
															Eq_2 eax_2761;
															Eq_2 eax_2581 = ebp_1004->tFFFFFED8;
															ebp_1004->tFFFFFEE0 = (word32) eax_2569 + 1;
															if (eax_2581 == 0x00)
															{
																Eq_2 ebx_2776 = ebp_1004->tFFFFFEBC;
																struct Eq_87026 * esp_2777 = esp_2253 - 0x0C;
																esp_2777->tFFFFFFFC = ebx_2776;
																word32 edx_5109;
																word32 ecx_5108;
																Eq_2 eax_2781 = strlen(esp_2777->tFFFFFFFC, out ecx_5108, out edx_5109);
																Eq_2 edx_2788 = ebp_1004->tFFFFFEE0;
																ptr32 ebx_2790 = ebx_2776 - ebp_1004->tFFFFFEC8;
																Mem2792[ebp_1004 + -288:word32] = edx_2788 + eax_2781;
																if (eax_2781 == 0x00)
																	ebp_1004->tFFFFFEE0 = edx_2788;
																else
																{
																	do
																	{
																		Eq_2 edx_2799 = (word32) *((word32) esi_2572 + (ebx_2790 - 0x01));
																		byte dl_2807 = (byte) edx_2799;
																		Eq_2 eax_2801 = *((word32) edi_1878 + 20);
																		if (eax_2801 >= *((word32) edi_1878 + 24))
																		{
																			struct Eq_87121 * esp_2813 = esp_2253 - 0x08;
																			esp_2813->tFFFFFFFC = edx_2799;
																			esp_2813->tFFFFFFF8 = edi_1878;
																			word32 ecx_5110;
																			word32 edx_5111;
																			if (__overflow(esp_2813->tFFFFFFF8, esp_2813->tFFFFFFFC, out ecx_5110, out edx_5111) == ~0x00)
																				goto l0807AEB8;
																			esi_2572 = (word32) esi_2572 + 1;
																			if (ebp_1004->tFFFFFEE0 == esi_2572)
																				break;
																			continue;
																		}
																		*((word32) edi_1878 + 20) = (word32) eax_2801 + 1;
																		*eax_2801 = dl_2807;
																		esi_2572 = (word32) esi_2572 + 1;
																	} while (ebp_1004->tFFFFFEE0 != esi_2572);
																}
																if (ebp_1004->tFFFFFEC4 <= 0x00)
																{
l0807BCC4:
																	Eq_2 eax_3012 = ebp_1004->ptrFFFFFEDC->t0008;
																	ebp_1004->tFFFFFEC8 = eax_3012;
																	al_3026 = (byte) eax_3012 + 0x0F;
																	goto l0807BCD6;
																}
																Eq_2 ecx_2841 = ebp_1004->tFFFFFE94;
																Eq_2 esi_2840 = ebp_1004->tFFFFFEC4;
																Eq_2 eax_2844 = ebp_1004->tFFFFFE84 - ecx_2841;
																Eq_2 ebx_2845 = esi_2840 - eax_2844;
																if (esi_2840 <= eax_2844)
																	eax_2844 = esi_2840;
																Eq_2 esi_2851 = ebp_1004->tFFFFFEE0;
																ebp_1004->tFFFFFEC8 = ebx_2845;
																Mem2859[ebp_1004 + -288:word32] = esi_2851 + eax_2844;
																ptr32 ebx_2858 = ecx_2841 - esi_2851;
																if (eax_2844 != 0x00)
																{
																	do
																	{
																		Eq_2 edx_2866 = (word32) *((word32) esi_2851 + ebx_2858);
																		byte dl_2873 = (byte) edx_2866;
																		Eq_2 eax_2868 = *((word32) edi_1878 + 20);
																		if (eax_2868 >= *((word32) edi_1878 + 24))
																		{
																			struct Eq_87961 * esp_2876 = esp_2253 - 0x08;
																			esp_2876->tFFFFFFFC = edx_2866;
																			esp_2876->tFFFFFFF8 = edi_1878;
																			word32 edx_5139;
																			word32 ecx_5138;
																			if (__overflow(esp_2876->tFFFFFFF8, esp_2876->tFFFFFFFC, out ecx_5138, out edx_5139) == ~0x00)
																				goto l0807AEB8;
																		}
																		else
																		{
																			*((word32) edi_1878 + 20) = (word32) eax_2868 + 1;
																			*eax_2868 = dl_2873;
																		}
																		esi_2851 = (word32) esi_2851 + 1;
																	} while (esi_2851 != ebp_1004->tFFFFFEE0);
																}
																if (ebp_1004->tFFFFFEC8 <= 0x00)
																{
																	ebp_1004->tFFFFFEE0 = esi_2851;
																	goto l0807BCC4;
																}
																struct Eq_87513 * esp_2909 = esp_2253 - 0x04;
																esp_2909->tFFFFFFFC = ebp_1004->tFFFFFEC8;
																esp_2909->tFFFFFFF8.u0 = 0x30;
																esp_2909->tFFFFFFF4 = edi_1878;
																Eq_2 esp_2935 = <invalid>;
																word32 ecx_5120;
																word32 edx_5121;
																word32 ebx_5122;
																eax_2761 = _IO_padn(gs, esp_2909->tFFFFFFF4, esp_2909->tFFFFFFF8, esp_2909->tFFFFFFFC, out ecx_5120, out edx_5121, out ebx_5122, out ebp_1004, out esi_2767, out edi_1878);
																esp_2253 = (word32) esp_2935 + 16;
l0807BEC4:
																if (eax_2761 != ebp_1004->tFFFFFEC8)
																	goto l0807AEB8;
																esi_2572 = (word32) eax_2761 + esi_2767;
																goto l0807BA70;
															}
															int8 al_2622;
															Eq_2 eax_2590 = *((word32) edi_1878 + 88);
															if (eax_2590 != 0x00)
															{
																struct Eq_86630 * edx_2594 = *((word32) eax_2590 + 16);
																if (edx_2594 < *((word32) eax_2590 + 20))
																{
																	*((word32) eax_2590 + 16) = (char *) &edx_2594->t0000 + 4;
																	Eq_2 eax_2625 = ebp_1004->tFFFFFEC0;
																	edx_2594->t0000 = eax_2625;
																	al_2622 = (int8) (eax_2625 == ~0x00);
l0807B7F3:
																	if (al_2622 != 0x00)
																		goto l0807AEB8;
																	esi_2572 = (word32) ebp_1004->tFFFFFEC8 + 2;
																	if (ebp_1004->tFFFFFEC4 > 0x00)
																	{
																		Eq_2 ebx_2641 = ebp_1004->tFFFFFEC4;
																		Eq_2 eax_2643 = ebp_1004->tFFFFFE84 - ebp_1004->tFFFFFE94;
																		Eq_2 ecx_2644 = ebp_1004->tFFFFFEC8;
																		ebp_1004->tFFFFFEC0 = eax_2643;
																		if (ebx_2641 <= eax_2643)
																			eax_2643 = ebx_2641;
																		ebp_1004->tFFFFFEE0 = ebp_1004->tFFFFFEA8 - ecx_2644 * 0x04;
																		ebp_1004->tFFFFFEC8 = (word32) eax_2643 + ((word32) ecx_2644 + 2);
																		if (eax_2643 != 0x00)
																		{
																			do
																			{
																				int8 al_2679;
																				Eq_2 ecx_2666 = (ebp_1004->tFFFFFEE0 - 0x08)[esi_2572];
																				Eq_2 eax_2668 = *((word32) edi_1878 + 88);
																				if (eax_2668 == 0x00)
																				{
l0807B89E:
																					struct Eq_87998 * esp_2683 = esp_2253 - 0x08;
																					esp_2683->tFFFFFFFC = ecx_2666;
																					esp_2683->tFFFFFFF8 = edi_1878;
																					word32 ecx_5140;
																					al_2679 = (int8) (__woverflow(esp_2683->tFFFFFFF8, esp_2683->tFFFFFFFC, out ecx_5140) == ~0x00);
																					goto l0807B876;
																				}
																				struct Eq_86630 * edx_2672 = *((word32) eax_2668 + 16);
																				if (edx_2672 >= *((word32) eax_2668 + 20))
																					goto l0807B89E;
																				*((word32) eax_2668 + 16) = (char *) &edx_2672->t0000 + 4;
																				edx_2672->t0000 = ecx_2666;
																				al_2679 = (int8) (ecx_2666 == ~0x00);
l0807B876:
																				if (al_2679 != 0x00)
																					goto l0807AEB8;
																				esi_2572 = (word32) esi_2572 + 1;
																			} while (esi_2572 != ebp_1004->tFFFFFEC8);
																		}
																		Eq_2 eax_2718 = ebp_1004->tFFFFFEC4 - ebp_1004->tFFFFFEC0;
																		ebp_1004->tFFFFFEC8 = eax_2718;
																		if (eax_2718 > 0x00)
																		{
																			struct Eq_87470 * esp_2733 = esp_2253 - 0x04;
																			esp_2733->tFFFFFFFC = ebp_1004->tFFFFFEC8;
																			esp_2733->tFFFFFFF8.u0 = 0x30;
																			esp_2733->tFFFFFFF4 = edi_1878;
																			Eq_2 esp_2768 = <invalid>;
																			word32 ecx_5117;
																			word32 ebx_5119;
																			word32 edx_5118;
																			eax_2761 = _IO_wpadn(gs, esp_2733->tFFFFFFF4, esp_2733->tFFFFFFF8, esp_2733->tFFFFFFFC, out ecx_5117, out edx_5118, out ebx_5119, out ebp_1004, out esi_2767, out edi_1878);
																			esp_2253 = (word32) esp_2768 + 16;
																			goto l0807BEC4;
																		}
																	}
																	Eq_2 eax_2725 = ebp_1004->ptrFFFFFEDC->t0008;
																	ebp_1004->tFFFFFEE0 = eax_2725;
																	eax_2727 = (word32) eax_2725 + 0x0F;
																	goto l0807BA90;
																}
															}
															struct Eq_87150 * esp_2601 = esp_2253 - 0x08;
															esp_2601->tFFFFFFFC = ebp_1004->tFFFFFEC0;
															esp_2601->tFFFFFFF8 = edi_1878;
															word32 ecx_5112;
															al_2622 = (int8) (__woverflow(esp_2601->tFFFFFFF8, esp_2601->tFFFFFFFC, out ecx_5112) == ~0x00);
															goto l0807B7F3;
														}
														struct Eq_88043 * esp_2501 = esp_2253 - 0x08;
														esp_2501->tFFFFFFFC = (word32) ebp_1004->tFFFFFE93;
														esp_2501->tFFFFFFF8 = edi_1878;
														esp_2253 = (struct Eq_84813 *) ((char *) &esp_2501->tFFFFFFFC + 0x0C);
														word32 ecx_5141;
														word32 edx_5142;
														al_2518 = (int8) (__overflow(esp_2501->tFFFFFFF8, esp_2501->tFFFFFFFC, out ecx_5141, out edx_5142) == ~0x00);
l0807B68A:
														if (al_2518 != 0x00)
															goto l0807AEB8;
														goto l0807B692;
													}
													goto l0807BA16;
												}
												struct Eq_88131 * esp_2254 = esp_1966 - 0x08;
												esp_2254->tFFFFFFFC = (word32) al_2256;
												esp_2254->tFFFFFFF8 = edi_1878;
												word32 ecx_5145;
												word32 edx_5146;
												al_2275 = (int8) (__overflow(esp_2254->tFFFFFFF8, esp_2254->tFFFFFFFC, out ecx_5145, out edx_5146) == ~0x00);
l0807B5DF:
												esp_2253 = esp_1966;
												if (al_2275 != 0x00)
													goto l0807AEB8;
												ebp_1004->tFFFFFEC8 = (byte) esi_1959.u0 + 2;
												struct Eq_85328 * eax_2388 = ebp_1004->ptrFFFFFEDC;
												if ((eax_2388->b000C & 0x20) != 0x00 || (eax_2388->t0010 != 0x30 || ebp_1004->tFFFFFEB8 <= 0x00))
												{
l0807B650:
													if (ebp_1004->tFFFFFED8 != 0x00)
													{
														Eq_2 eax_2524 = *((word32) edi_1878 + 88);
														if (eax_2524 != 0x00)
														{
															struct Eq_86630 * edx_2528 = *((word32) eax_2524 + 16);
															if (edx_2528 < *((word32) eax_2524 + 20))
															{
																Eq_2 ecx_2554 = (int32) ebp_1004->tFFFFFE93;
																*((word32) eax_2524 + 16) = (char *) &edx_2528->t0000 + 4;
																edx_2528->t0000 = ecx_2554;
																al_2518 = (int8) (ecx_2554 == ~0x00);
																goto l0807B68A;
															}
														}
														struct Eq_86922 * esp_2535 = esp_2253 - 0x08;
														esp_2535->tFFFFFFFC = (int32) ebp_1004->tFFFFFE93;
														esp_2535->tFFFFFFF8 = edi_1878;
														esp_2253 = (struct Eq_84813 *) ((char *) &esp_2535->tFFFFFFFC + 0x0C);
														word32 ecx_5107;
														al_2518 = (int8) (__woverflow(esp_2535->tFFFFFFF8, esp_2535->tFFFFFFFC, out ecx_5107) == ~0x00);
														goto l0807B68A;
													}
													goto l0807BA30;
												}
												if (ebp_1004->tFFFFFED8 != 0x00)
												{
													struct Eq_86829 * esp_2448 = esp_1966 - 0x04;
													esp_2448->tFFFFFFFC = ebp_1004->tFFFFFEB8;
													esp_2448->tFFFFFFF8.u0 = 0x30;
													esp_2448->tFFFFFFF4 = edi_1878;
													Eq_2 esp_2465 = <invalid>;
													word32 edx_5104;
													word32 ecx_5103;
													word32 esi_5106;
													word32 ebx_5105;
													eax_2433 = _IO_wpadn(gs, esp_2448->tFFFFFFF4, esp_2448->tFFFFFFF8, esp_2448->tFFFFFFFC, out ecx_5103, out edx_5104, out ebx_5105, out ebp_1004, out esi_5106, out edi_1878);
													esp_2253 = (word32) esp_2465 + 16;
l0807B634:
													Eq_2 esi_2475 = ebp_1004->tFFFFFEB8;
													if (esi_2475 != eax_2433)
														goto l0807AEB8;
													Mem2480[ebp_1004 + -312:word32] = Mem2474[ebp_1004 + -312:word32] + esi_2475;
													goto l0807B650;
												}
l0807BA16:
												struct Eq_86787 * esp_2403 = esp_1966 - 0x04;
												esp_2403->tFFFFFFFC = ebp_1004->tFFFFFEB8;
												esp_2403->tFFFFFFF8.u0 = 0x30;
												esp_2403->tFFFFFFF4 = edi_1878;
												Eq_2 esp_2440 = <invalid>;
												word32 ecx_5099;
												word32 ebx_5101;
												word32 edx_5100;
												word32 esi_5102;
												eax_2433 = _IO_padn(gs, esp_2403->tFFFFFFF4, esp_2403->tFFFFFFF8, esp_2403->tFFFFFFFC, out ecx_5099, out edx_5100, out ebx_5101, out ebp_1004, out esi_5102, out edi_1878);
												esp_2253 = (word32) esp_2440 + 16;
												goto l0807B634;
											}
											Eq_2 edx_2325;
											struct Eq_86630 * ebx_2299;
											struct Eq_86630 * ecx_2330;
											Eq_2 eax_2294 = *((word32) edi_1878 + 88);
											if (eax_2294 != 0x00)
											{
												struct Eq_86630 * edx_2298 = *((word32) eax_2294 + 16);
												ebx_2299 = (struct Eq_86630 *) *((word32) eax_2294 + 20);
												if (edx_2298 < ebx_2299)
												{
													*((word32) eax_2294 + 16) = (char *) &edx_2298->t0000 + 4;
													edx_2298->t0000.u0 = 0x30;
													Eq_2 edx_2336 = ebp_1004->ptrFFFFFEDC->t0008;
													ebp_1004->tFFFFFEE0 = edx_2336;
													ecx_2330 = (struct Eq_86630 *) ((char *) &edx_2298->t0000 + 4);
													edx_2325 = (word32) edx_2336 + 23;
													goto l0807B5C9;
												}
											}
											struct Eq_86665 * esp_2303 = esp_1966 - 0x08;
											esp_2303->tFFFFFFFC.u0 = 0x30;
											esp_2303->tFFFFFFF8 = edi_1878;
											word32 ecx_5097;
											if (__woverflow(esp_2303->tFFFFFFF8, esp_2303->tFFFFFFFC, out ecx_5097) == ~0x00)
												goto l0807AEB8;
											Eq_2 eax_2323 = ebp_1004->ptrFFFFFEDC->t0008;
											ebp_1004->tFFFFFEE0 = eax_2323;
											edx_2325 = (word32) eax_2323 + 23;
											eax_2294 = *((word32) edi_1878 + 88);
											if (eax_2294 == 0x00)
											{
l0807C008:
												struct Eq_86717 * esp_2346 = esp_1966 - 0x08;
												esp_2346->tFFFFFFFC = edx_2325;
												esp_2346->tFFFFFFF8 = edi_1878;
												word32 ecx_5098;
												al_2275 = (int8) (__woverflow(esp_2346->tFFFFFFF8, esp_2346->tFFFFFFFC, out ecx_5098) == ~0x00);
												goto l0807B5DF;
											}
											ecx_2330 = (struct Eq_86630 *) *((word32) eax_2294 + 16);
											ebx_2299 = (struct Eq_86630 *) *((word32) eax_2294 + 20);
l0807B5C9:
											if (ecx_2330 < ebx_2299)
											{
												*((word32) eax_2294 + 16) = (char *) &ecx_2330->t0000 + 4;
												ecx_2330->t0000 = edx_2325;
												al_2275 = (int8) (edx_2325 == ~0x00);
												goto l0807B5DF;
											}
											goto l0807C008;
										}
										if (ebp_1004->tFFFFFED8 != 0x00)
										{
											Eq_2 eax_2072 = *((word32) edi_1878 + 88);
											if (eax_2072 != 0x00)
											{
												struct Eq_86630 * edx_2076 = *((word32) eax_2072 + 16);
												if (edx_2076 < *((word32) eax_2072 + 20))
												{
													*((word32) eax_2072 + 16) = (char *) &edx_2076->t0000 + 4;
													edx_2076->t0000.u0 = 0x20;
													goto l0807B581;
												}
											}
											esp_1966->dwFFFFFFF4 = 0x20;
											goto l0807C303;
										}
										Eq_2 eax_2059 = *((word32) edi_1878 + 20);
										if (eax_2059 >= *((word32) edi_1878 + 24))
										{
											esp_1966->dwFFFFFFF4 = 0x20;
											goto l0807C3E3;
										}
										*((word32) edi_1878 + 20) = (word32) eax_2059 + 1;
										*eax_2059 = 0x20;
									}
l0807B581:
									esi_1959 = (byte) esi_1959.u0 + 1;
									goto l0807B584;
								}
							}
							esi_1959.u0 = 0x00;
							goto l0807B542;
						}
						word32 eax_1146 = (word32) ebp_1004->tFFFFFE93;
						if (ecx_1139 > 0x00)
							eax_1146 = CONVERT(Mem1136[edx_1138 - 0x01 + ecx_1139:byte], byte, word32);
						Mem1160[ebp_1004 + -312:byte] = Mem1136[Mem1136[ebp_1004 + -364:word32] + Mem1136[ebp_1004 + -316:word32]:byte];
						cu8 al_1155 = (byte) eax_1146;
						int32 edx_1158 = (int32) al_1155;
						if (al_1155 <= 0x46 && al_1155 >= 0x41)
							ebp_1004->tFFFFFE88 = edx_1158 - 55;
						else
						{
							Eq_2 eax_1170 = edx_1158 - 0x57;
							if (al_1155 > 0x66)
								eax_1170 = edx_1158 - 0x30;
							ebp_1004->tFFFFFE88 = eax_1170;
						}
						Eq_2 ecx_1209;
						int32 edx_1193;
						int32 eax_1183 = (int32) ebp_1004->tFFFFFEC8;
						if ((byte) eax_1183 <= 0x46 && (byte) eax_1183 >= 0x41)
							edx_1193 = eax_1183 - 55;
						else if (ebp_1004->tFFFFFEC8 <= 0x66 && ebp_1004->tFFFFFEC8 >= 0x61)
							edx_1193 = eax_1183 - 0x57;
						else
						{
							edx_1193 = eax_1183 - 0x30;
							if (((byte) eax_1183 - 0x30 & 0x07) == 0x00)
							{
								ecx_1209 = (uint32) (int8) ((word32) ebp_1004->tFFFFFEC4 + 1 < esi_1140);
l0807B2D0:
								ebp_1004->wFFFFFF08 = __fstcw();
								uint16 ax_1214 = ebp_1004->wFFFFFF08;
								if ((ax_1214 & 0x0C00) == 0x0400)
								{
									if (ebp_1004->tFFFFFEE0 == 0x00)
										goto l0807AD70;
									goto l0807B309;
								}
								else
								{
									if ((ax_1214 & 0x0C00) > 0x0400)
									{
										if ((ax_1214 & 0x0C00) == 0x0800)
										{
											if (ebp_1004->tFFFFFEE0 != 0x00)
												goto l0807AD70;
l0807B309:
											if (edx_1193 <= 0x07 && ecx_1209 == 0x00)
												goto l0807AD70;
											goto l0807B316;
										}
										if ((ax_1214 & 0x0C00) == 0x0C00)
											goto l0807AD70;
									}
									else if ((ax_1214 & 0x0C00) == 0x00)
									{
										if (edx_1193 <= 0x07 || ((ebp_1004->tFFFFFE88 | ecx_1209) & 0x01) == 0x00)
											goto l0807AD70;
l0807B316:
										Eq_2 eax_1648 = ebp_1004->tFFFFFEC4;
										Eq_86153 eax_1649 = eax_1648 - 0x01;
										if (eax_1648 >= 0x01)
										{
											word32 esi_1653 = Mem1212[ebp_1004 + -364:word32] + (eax_1648 - 0x01);
											Eq_2 cl_1656 = *esi_1653;
											ebp_1004->tFFFFFEC8 = esi_1653;
											ebp_1004->tFFFFFE88 = cl_1656;
											if (cl_1656 != 0x39)
											{
												if (gs->ptrFFFFFFF0[(int32) cl_1656] > 101)
												{
													Eq_2 edx_1668 = ebp_1004->tFFFFFE94;
													ebp_1004->tFFFFFE80 = ebx_1077;
													ebp_1004->tFFFFFE7C = edi_1007;
													ebp_1004->tFFFFFE88 = edx_1668 - 0x01;
													do
													{
														Eq_2 edx_1707 = ebp_1004->tFFFFFEA8;
														*((word32) eax_1649 + ((word32) ebp_1004->tFFFFFE88 + 1)) = 0x30;
														*((word32) edx_1707 + eax_1649 * 0x04) = 0x30;
														--eax_1649;
														if (eax_1649 == ~0x00)
														{
															ebx_1077 = ebp_1004->tFFFFFE80;
															edi_1007 = ebp_1004->tFFFFFE7C;
															goto l0807B3DA;
														}
														Mem1716[ebp_1004 + -312:word32] = edx_1668 + eax_1649;
														byte cl_1718 = Mem1716[edx_1668 + eax_1649:byte];
														if (cl_1718 == 0x39)
														{
															ebx_1077 = ebp_1004->tFFFFFE80;
															edi_1007 = ebp_1004->tFFFFFE7C;
															goto l0807C244;
														}
													} while (gs->ptrFFFFFFF0[(int32) cl_1718] > 101);
													ebp_1004->tFFFFFE88 = cl_1718;
													ebx_1077 = ebp_1004->tFFFFFE80;
													edi_1007 = ebp_1004->tFFFFFE7C;
												}
												*ebp_1004->tFFFFFEC8 = (word32) ebp_1004->tFFFFFE88 + 1;
												Eq_2 edx_1749 = ebp_1004->tFFFFFEA8;
												*((word32) edx_1749 + eax_1649 * 0x04) = (word32) *((word32) edx_1749 + eax_1649 * 0x04) + 1;
											}
											else
											{
l0807C244:
												Eq_2 edx_1727 = ebp_1004->ptrFFFFFEDC->t0008;
												*((word32) ebp_1004->tFFFFFEA8 + eax_1649 * 0x04) = edx_1727;
												*ebp_1004->tFFFFFEC8 = (byte) edx_1727;
											}
										}
										else
										{
l0807B3DA:
											if (ebp_1004->tFFFFFE93 != 0x39)
											{
												int32 eax_1765 = (int32) ebp_1004->tFFFFFE93;
												if (gs->ptrFFFFFFF0[eax_1765] <= 101)
													ebp_1004->tFFFFFE93 = (byte) eax_1765 + 0x01;
												else if (ebp_1004->tFFFFFE98 != 0x00)
												{
													Eq_2 eax_1780 = ebx_1077 - 0x04;
													if (eax_1780 > 0x00)
													{
														ebp_1004->tFFFFFE93.u0 = 0x31;
														ebx_1077 = eax_1780;
													}
													else
													{
														ebp_1004->tFFFFFE93.u0 = 0x31;
														ebp_1004->tFFFFFE98.u0 = 0x00;
														ebx_1077 = 0x04 - ebx_1077;
													}
												}
												else
												{
													ebp_1004->tFFFFFE93.u0 = 0x31;
													ebx_1077 = (word32) ebx_1077 + 4;
												}
											}
											else
												ebp_1004->tFFFFFE93 = ebp_1004->ptrFFFFFEDC->t0008;
										}
										goto l0807AD70;
									}
									word32 ecx_5085;
									word32 edx_5086;
									abort(ecx_1209, gs, out ecx_5085, out edx_5086);
								}
							}
						}
						ecx_1209.u0 = 0x01;
						goto l0807B2D0;
					}
					ebp_1004->tFFFFFE98.u0 = 0x00;
l0807AD50:
					ebp_1004->tFFFFFE84 = ebp_1004->tFFFFFE94;
					if (ebp_1004->tFFFFFEC4 == ~0x00)
						ebp_1004->tFFFFFEC4.u0 = 0x00;
					goto l0807AD70;
				}
				if ((ebx_290 & 0x07FF) > 1022)
				{
					ebp_1004->tFFFFFE98.u0 = 0x00;
					ebx_1077 = (ebx_290 & 0x07FF) - 0x03FF;
				}
				else
				{
					ebp_1004->tFFFFFE98.u0 = 0x01;
					ebx_1077 = 0x03FF - (ebx_290 & 0x07FF);
				}
l0807B220:
				if (ebp_1004->tFFFFFE88 == 0x00)
					goto l0807B22E;
				goto l0807AD50;
			}
			(gs->ptrFFFFFFF8[esi_107].b0001 & 0x01) != 0x00;
l0807AF0C:
			Eq_2 esi_1531;
			Eq_2 eax_1525;
			Eq_2 esi_1262;
			Eq_2 eax_1261;
			Eq_2 ebx_650;
			int8 al_784;
			struct Eq_85300 * esp_1302 = fp - 400;
			byte dl_654 = (byte) edx_110;
			byte al_641 = (byte) edx_110 & 0x20;
			if (dwLoc0128_3465 == 0x00)
			{
				if ((dl_654 & 0x50) != 0x00)
				{
					esi_1262 = esi_42 - 0x04;
					if (al_641 != 0x00)
						goto l0807B474;
					if (esi_42 <= 0x04)
					{
						eax_1261 = esi_42 - 0x04;
						esi_1262.u0 = 0x00;
						goto l0807B46C;
					}
				}
				else
				{
					esi_1262 = esi_42 - 0x03;
					if (al_641 != 0x00 || esi_42 <= 0x03)
						goto l0807B474;
				}
			}
			else
			{
				esi_1262 = esi_42 - 0x04;
				if (al_641 != 0x00 || esi_42 <= 0x04)
				{
					ebx_650.u0 = 0x00;
					if ((ecx_45 & 0x01) != 0x00)
					{
l0807AF8A:
						Eq_2 eax_790 = *((word32) edi_1297 + 88);
						if (eax_790 != 0x00)
						{
							word32 * edx_794 = *((word32) eax_790 + 16);
							if (edx_794 < *((word32) eax_790 + 20))
							{
								*((word32) eax_790 + 16) = edx_794 + 1;
								*edx_794 = 0x2D;
								goto l0807AFAD;
							}
						}
						struct Eq_85353 * esp_799 = esp_1302 - 0x08;
						esp_799->tFFFFFFFC.u0 = 0x2D;
						esp_799->tFFFFFFF8 = edi_1297;
						esp_1302 = (struct Eq_85300 *) ((char *) &esp_799->tFFFFFFFC + 0x0C);
						word32 ecx_5064;
						al_784 = (int8) (__woverflow(esp_799->tFFFFFFF8, esp_799->tFFFFFFFC, out ecx_5064) == ~0x00);
						goto l0807BFF4;
					}
l0807B445:
					Eq_2 eax_761 = *((word32) edi_1297 + 20);
					if (eax_761 < *((word32) edi_1297 + 24))
					{
						*((word32) edi_1297 + 20) = (word32) eax_761 + 1;
						*eax_761 = 0x2D;
						goto l0807AFAD;
					}
					struct Eq_85681 * esp_767 = esp_1302 - 0x08;
					esp_767->tFFFFFFFC.u0 = 0x2D;
					esp_767->tFFFFFFF8 = edi_1297;
					esp_1302 = (struct Eq_85300 *) ((char *) &esp_767->tFFFFFFFC + 0x0C);
					word32 ecx_5078;
					word32 edx_5079;
					al_784 = (int8) (__overflow(esp_767->tFFFFFFF8, esp_767->tFFFFFFFC, out ecx_5078, out edx_5079) == ~0x00);
l0807BFF4:
					if (al_784 != 0x00)
						goto l0807AEB8;
l0807AFAD:
					ebp_1004->tFFFFFEE0 = (word32) ebx_650 + 1;
					goto l0807AFB6;
				}
			}
			Eq_2 eax_700;
			if ((ecx_45 & 0x01) != 0x00)
			{
				Eq_2 esp_731 = <invalid>;
				word32 edx_5062;
				word32 ebx_5063;
				word32 ecx_5061;
				eax_700 = _IO_wpadn(gs, dwArg04, 0x20, esi_1262, out ecx_5061, out edx_5062, out ebx_5063, out ebp_1004, out esi_1262, out edi_1297);
				esp_1302 = (word32) esp_731 + 16;
			}
			else
			{
				Eq_2 esp_707 = <invalid>;
				word32 ecx_5058;
				word32 ebx_5060;
				word32 edx_5059;
				eax_700 = _IO_padn(gs, dwArg04, 0x20, esi_1262, out ecx_5058, out edx_5059, out ebx_5060, out ebp_1004, out esi_1262, out edi_1297);
				esp_1302 = (word32) esp_707 + 16;
			}
			if (eax_700 == esi_1262)
			{
				if (ebp_1004->tFFFFFEE0 != 0x00)
				{
					ebx_650 = esi_1262;
					if (ebp_1004->tFFFFFED8 != 0x00)
						goto l0807AF8A;
					goto l0807B445;
				}
				eax_1261 = esi_1262;
				edx_110 = (word32) ebp_1004->ptrFFFFFEDC->b000C;
l0807B46C:
				ebp_1004->tFFFFFEE0 = esi_1262;
				esi_1262 = eax_1261;
l0807B474:
				int8 al_1352;
				if (((byte) edx_110 & 0x40) != 0x00)
				{
					if (ebp_1004->tFFFFFED8 != 0x00)
					{
						Eq_2 eax_1356 = *((word32) edi_1297 + 88);
						if (eax_1356 != 0x00)
						{
							word32 * edx_1360 = *((word32) eax_1356 + 16);
							if (edx_1360 < *((word32) eax_1356 + 20))
							{
								*((word32) eax_1356 + 16) = edx_1360 + 1;
								*edx_1360 = 0x2B;
								goto l0807B4AE;
							}
						}
						esp_1302->tFFFFFFF4.u0 = 0x2B;
						goto l0807C216;
					}
					Eq_2 eax_1330 = *((word32) edi_1297 + 20);
					if (eax_1330 < *((word32) edi_1297 + 24))
					{
						*((word32) edi_1297 + 20) = (word32) eax_1330 + 1;
						*eax_1330 = 0x2B;
						goto l0807B4AE;
					}
					esp_1302->tFFFFFFF4.u0 = 0x2B;
				}
				else
				{
					if ((edx_110 & 0x10) == 0x00)
					{
l0807AFB6:
						if (ebp_1004->tFFFFFED8 != 0x00)
							goto l0807AFC4;
						goto l0807B4C3;
					}
					if (ebp_1004->tFFFFFED8 != 0x00)
					{
						Eq_2 eax_1311 = *((word32) edi_1297 + 88);
						if (eax_1311 != 0x00)
						{
							word32 * edx_1315 = *((word32) eax_1311 + 16);
							if (edx_1315 < *((word32) eax_1311 + 20))
							{
								*((word32) eax_1311 + 16) = edx_1315 + 1;
								*edx_1315 = 0x20;
								goto l0807B4AE;
							}
						}
						esp_1302->tFFFFFFF4.u0 = 0x20;
l0807C216:
						struct Eq_85833 * esp_1368 = esp_1302 - 0x0C;
						esp_1368->tFFFFFFFC = edi_1297;
						word32 ecx_5080;
						al_1352 = (int8) (__woverflow(esp_1368->tFFFFFFFC, esp_1368->t0000, out ecx_5080) == ~0x00);
						goto l0807C225;
					}
					Eq_2 eax_1299 = *((word32) edi_1297 + 20);
					if (eax_1299 < *((word32) edi_1297 + 24))
					{
						*((word32) edi_1297 + 20) = (word32) eax_1299 + 1;
						*eax_1299 = 0x20;
						goto l0807B4AE;
					}
					esp_1302->tFFFFFFF4.u0 = 0x20;
				}
				struct Eq_85878 * esp_1337 = esp_1302 - 0x0C;
				esp_1337->tFFFFFFFC = edi_1297;
				word32 edx_5082;
				word32 ecx_5081;
				al_1352 = (int8) (__overflow(esp_1337->tFFFFFFFC, esp_1337->t0000, out ecx_5081, out edx_5082) == ~0x00);
l0807C225:
				if (al_1352 != 0x00)
					goto l0807AEB8;
l0807B4AE:
				Eq_2 eax_1401 = ebp_1004->tFFFFFED8;
				ebp_1004->tFFFFFEE0 = (word32) ebp_1004->tFFFFFEE0 + 1;
				if (eax_1401 != 0x00)
				{
l0807AFC4:
					Eq_2 ebx_1409 = ebp_1004->tFFFFFEE0;
					Eq_2 ecx_1410 = ebp_1004->tFFFFFEC4;
					ebp_1004->tFFFFFEC8 = esi_1262;
					ebp_1004->tFFFFFED8 = (word32) ebx_1409 + 3;
					ebp_1004->tFFFFFEE0 = ecx_1410 - ebx_1409 * 0x04;
					do
					{
						int8 al_1467;
						Eq_2 ecx_1437 = *((word32) ebp_1004->tFFFFFEE0 + ebx_1409 * 0x04);
						Eq_2 eax_1439 = *((word32) edi_1297 + 88);
						if (eax_1439 != 0x00)
						{
							struct Eq_85461 * edx_1443 = *((word32) eax_1439 + 16);
							if (edx_1443 >= *((word32) eax_1439 + 20))
								goto l0807B940;
							*((word32) eax_1439 + 16) = (char *) &edx_1443->t0000 + 4;
							edx_1443->t0000 = ecx_1437;
							al_1467 = (int8) (ecx_1437 == ~0x00);
						}
						else
						{
l0807B940:
							struct Eq_85437 * esp_1448 = esp_1302 - 0x08;
							esp_1448->tFFFFFFFC = ecx_1437;
							esp_1448->tFFFFFFF8 = edi_1297;
							word32 ecx_5065;
							al_1467 = (int8) (__woverflow(esp_1448->tFFFFFFF8, esp_1448->tFFFFFFFC, out ecx_5065) == ~0x00);
						}
						if (al_1467 != 0x00)
							goto l0807AEB8;
						ebx_1409 = (word32) ebx_1409 + 1;
					} while (ebp_1004->tFFFFFED8 != ebx_1409);
					struct Eq_85328 * eax_1486 = ebp_1004->ptrFFFFFEDC;
					Eq_2 esi_1487 = ebp_1004->tFFFFFEC8;
					ebp_1004->tFFFFFEE0 = ebx_1409;
					if ((eax_1486->b000C & 0x20) != 0x00 && esi_1487 > 0x00)
					{
						esp_1302->tFFFFFFF8 = esi_1487;
						esp_1302->tFFFFFFF4.u0 = 0x20;
						esp_1302->tFFFFFFF0 = edi_1297;
						word32 edi_5069;
						word32 ecx_5066;
						word32 edx_5067;
						word32 ebx_5068;
						eax_1525 = _IO_wpadn(gs, esp_1302->tFFFFFFF0, esp_1302->tFFFFFFF4, esp_1302->tFFFFFFF8, out ecx_5066, out edx_5067, out ebx_5068, out ebp_1004, out esi_1531, out edi_5069);
						goto l0807B060;
					}
					goto l0807B06E;
				}
l0807B4C3:
				Eq_2 eax_1542 = ebp_1004->tFFFFFEE0;
				Eq_2 ebx_1543 = ebp_1004->tFFFFFEC8;
				ebp_1004->tFFFFFED8 = esi_1262;
				ebp_1004->tFFFFFEE4 = (word32) eax_1542 + 3;
				Eq_85412 ebx_1547 = ebx_1543 - eax_1542;
				Eq_2 esi_1549 = eax_1542;
				do
				{
					word32 edx_1554 = CONVERT(Mem1553[ebx_1547 + esi_1549:byte], byte, word32);
					byte dl_1579 = (byte) edx_1554;
					Eq_2 eax_1556 = *((word32) edi_1297 + 20);
					if (eax_1556 < *((word32) edi_1297 + 24))
					{
						*((word32) edi_1297 + 20) = (word32) eax_1556 + 1;
						*eax_1556 = dl_1579;
					}
					else
					{
						struct Eq_85579 * esp_1560 = esp_1302 - 0x08;
						esp_1560->tFFFFFFFC = edx_1554;
						esp_1560->tFFFFFFF8 = edi_1297;
						word32 edx_5073;
						word32 ecx_5072;
						if (__overflow(esp_1560->tFFFFFFF8, esp_1560->tFFFFFFFC, out ecx_5072, out edx_5073) == ~0x00)
							goto l0807AEB8;
					}
					esi_1549 = (word32) esi_1549 + 1;
				} while (ebp_1004->tFFFFFEE4 != esi_1549);
				struct Eq_85328 * eax_1588 = ebp_1004->ptrFFFFFEDC;
				ebp_1004->tFFFFFEE0 = esi_1549;
				Eq_2 esi_1590 = ebp_1004->tFFFFFED8;
				if ((eax_1588->b000C & 0x20) != 0x00 && esi_1590 > 0x00)
				{
					esp_1302->tFFFFFFF8 = esi_1590;
					esp_1302->tFFFFFFF4.u0 = 0x20;
					esp_1302->tFFFFFFF0 = edi_1297;
					word32 edi_5077;
					word32 ebx_5076;
					word32 ecx_5074;
					word32 edx_5075;
					eax_1525 = _IO_padn(gs, esp_1302->tFFFFFFF0, esp_1302->tFFFFFFF4, esp_1302->tFFFFFFF8, out ecx_5074, out edx_5075, out ebx_5076, out ebp_1004, out esi_1531, out edi_5077);
l0807B060:
					if (eax_1525 == esi_1531)
					{
						Mem1631[ebp_1004 + -288:word32] = Mem1629[ebp_1004 + -288:word32] + eax_1525;
						goto l0807B06E;
					}
					goto l0807AEB8;
				}
				goto l0807B06E;
			}
l0807AEB8:
			ebp_1004->tFFFFFEE0.u0 = ~0x00;
			goto l0807B06E;
		}
		if ((gs->ptrFFFFFFF8[esi_107].b0001 & 0x01) == 0x00)
			goto l0807AF0C;
	}
	goto l0807AF0C;
}

// 0807C4E0: void register_printf_modifier(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __printf_fphex
void register_printf_modifier(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_113 = dwArg04;
	if (*dwArg04 <= 0xFF)
	{
		Eq_2 esi_110 = dwArg04;
		do
		{
			esi_110 = (word32) esi_110 + 4;
			Eq_2 eax_28 = *esi_110;
			if (eax_28 == 0x00)
			{
				if (next_bit <= 0x17)
				{
					gs->tFFFFFFE0.u0 = 0x1C;
					return;
				}
				if (gs->t000C != 0x00)
					__lock();
				word32 eax_68;
				if (!__cmpxchg(lock, 0x01, eax_28, out eax_68))
					__lll_lock_wait_private(eax_68, 0x080CFA28, gs);
				Eq_2 edx_141;
				Eq_2 ecx_128;
				struct Eq_88955 * ebx_127;
				if (__printf_modifier_table == 0x00)
				{
					word32 ebp_315;
					word32 edx_314;
					Eq_2 eax_93 = __libc_calloc(gs, 0xFF, 0x04, out ecx_128, out edx_314, out ebx_127, out ebp_315, out esi_110, out edi_113);
					ebx_127->t1FD8 = eax_93;
					if (eax_93 == 0x00)
					{
l0807C640:
						edx_141.u0 = ~0x00;
l0807C5D1:
						if (gs->t000C != 0x00)
							__lock();
						word32 v17_188 = ebx_127->dw1A28 - 0x01;
						ebx_127->dw1A28 = v17_188;
						if (v17_188 != 0x00)
							__lll_unlock_wake_private(&ebx_127->dw1A28, ecx_128, edx_141, gs);
						return;
					}
				}
				byte * edi_129;
				int32 esi_131;
				word32 edx_316;
				word32 ebp_317;
				Eq_2 eax_125 = __libc_malloc(gs, dwLoc30, esi_110 - edi_113 + 0x08, out ecx_128, out edx_316, out ebx_127, out ebp_317, out esi_131, out edi_129);
				if (eax_125 == 0x00)
					goto l0807C640;
				word32 ecx_146 = ebx_127->dw1A24;
				*eax_125 = *((word32) ebx_127->t1FD8 + (word32) (*edi_129) * 0x04);
				ebx_127->dw1A24 = ecx_146 + 0x01;
				*((word32) eax_125 + 4) = 0x01 << (byte) ecx_146;
				word32 edx_318;
				ecx_128 = __wmemcpy((word32) eax_125 + 8, edi_129 + 4, esi_131 >> 0x02, out edx_318);
				*((word32) ebx_127->t1FD8 + (word32) (*edi_129) * 0x04) = eax_125;
				edx_141 = *((word32) eax_125 + 4);
				goto l0807C5D1;
			}
		} while (eax_28 <= 0xFF);
	}
	gs->tFFFFFFE0.u0 = 22;
}

// 0807C660: Register word32 __handle_registered_modifier_mb(Stack (ptr32 (ptr32 Eq_89076)) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __parse_one_specmb
word32 __handle_registered_modifier_mb(struct Eq_89076 ** dwArg04, Eq_2 dwArg08)
{
	struct Eq_89076 * ebx_21 = *dwArg04;
	struct Eq_89080 * esi_24 = *((word32) __printf_modifier_table + (word32) ebx_21->b0000 * 0x04);
	if (esi_24 == null)
		return 0x01;
	word32 edi_39 = (word32) ebx_21[1];
	struct Eq_89076 * dwLoc14_162 = null;
	int32 dwLoc20_163 = 0x00;
	byte al_45 = (byte) edi_39;
	word32 dwLoc18_164 = 0x00;
	struct Eq_89080 * esi_112 = esi_24;
	do
	{
		struct Eq_89076 * ecx_106;
		int32 eax_61;
		word32 * ebx_52 = &esi_112->dw0008;
		word32 edx_53 = esi_112->dw0008;
		if (al_45 != 0x00)
		{
			if (edx_53 != 0x00)
			{
				if (edx_53 == edi_39)
				{
					ecx_106 = ebx_21 + 1;
					do
					{
						++ecx_106;
						++ebx_52;
						word32 eax_69 = (word32) ecx_106->b0000;
						edx_53 = *ebx_52;
						if ((byte) eax_69 == 0x00)
							goto l0807C6F7;
						if (edx_53 == 0x00)
							goto l0807C6FB;
					} while (eax_69 == edx_53);
				}
				goto l0807C716;
			}
			ecx_106 = ebx_21 + 1;
			eax_61 = 0x01;
			goto l0807C701;
		}
		ecx_106 = ebx_21 + 1;
l0807C6F7:
		if (edx_53 == 0x00)
		{
l0807C6FB:
			eax_61 = ecx_106 - ebx_21;
l0807C701:
			if (eax_61 > dwLoc20_163)
			{
				dwLoc14_162 = ecx_106;
				dwLoc20_163 = eax_61;
				dwLoc18_164 = esi_112->dw0004;
			}
		}
l0807C716:
		cui16 wLoc18_192 = (word16) dwLoc18_164;
		esi_112 = esi_112->ptr0000;
	} while (esi_112 != null);
	word32 eax_118 = 0x01;
	if (dwLoc18_164 != 0x00)
	{
		*((word32) dwArg08 + 0x0E) |= wLoc18_192;
		*dwArg04 = (struct Eq_89076 **) dwLoc14_162;
		eax_118 = 0x00;
	}
	return eax_118;
}

// 0807C770: Register word32 __handle_registered_modifier_wc(Stack (ptr32 (ptr32 Eq_89176)) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __parse_one_specwc
word32 __handle_registered_modifier_wc(struct Eq_89176 ** dwArg04, Eq_2 dwArg08)
{
	struct Eq_89176 * ebp_21 = *dwArg04;
	struct Eq_89180 * esi_23 = *((word32) __printf_modifier_table + ebp_21->dw0000 * 0x04);
	if (esi_23 == null)
		return 0x01;
	struct Eq_89176 * dwLoc14_160 = null;
	word32 edi_40 = ebp_21[1];
	int32 dwLoc20_161 = 0x00;
	word32 dwLoc18_162 = 0x00;
	struct Eq_89180 * esi_111 = esi_23;
	do
	{
		struct Eq_89176 * edx_105;
		int32 eax_60;
		word32 * ecx_47 = &esi_111->dw0008;
		word32 eax_49 = esi_111->dw0008;
		if (edi_40 != 0x00)
		{
			if (eax_49 != 0x00)
			{
				if (edi_40 == eax_49)
				{
					edx_105 = ebp_21 + 1;
					do
					{
						++edx_105;
						++ecx_47;
						word32 ebx_67 = edx_105->dw0000;
						eax_49 = *ecx_47;
						if (ebx_67 == 0x00)
							goto l0807C7F6;
						if (eax_49 == 0x00)
							goto l0807C7FA;
					} while (eax_49 == ebx_67);
				}
				goto l0807C816;
			}
			edx_105 = ebp_21 + 1;
			eax_60 = 0x01;
			goto l0807C803;
		}
		edx_105 = ebp_21 + 1;
l0807C7F6:
		if (eax_49 == 0x00)
		{
l0807C7FA:
			eax_60 = edx_105 - ebp_21 >> 0x02;
l0807C803:
			if (dwLoc20_161 < eax_60)
			{
				dwLoc14_160 = edx_105;
				dwLoc20_161 = eax_60;
				dwLoc18_162 = esi_111->dw0004;
			}
		}
l0807C816:
		cui16 wLoc18_189 = (word16) dwLoc18_162;
		esi_111 = esi_111->ptr0000;
	} while (esi_111 != null);
	word32 eax_117 = 0x01;
	if (dwLoc18_162 != 0x00)
	{
		*((word32) dwArg08 + 0x0E) |= wLoc18_189;
		*dwArg04 = (struct Eq_89176 **) dwLoc14_160;
		eax_117 = 0x00;
	}
	return eax_117;
}

// 0807C870: void register_printf_type(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void register_printf_type(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ecx_24 = 0x01;
	struct Eq_89273 * ebx_10 = &g_t80CE000;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_19;
	if (!__cmpxchg(lock, 0x01, 0x00, out eax_19))
		ecx_24 = __lll_lock_wait_private(eax_19, 0x080CFA2C, gs);
	Eq_2 edx_61;
	if (__printf_va_arg_table == 0x00)
	{
		word32 edx_161;
		word32 ebp_162;
		word32 esi_163;
		word32 edi_164;
		Eq_2 eax_44 = __libc_calloc(gs, 0xF8, 0x04, out ecx_24, out edx_161, out ebx_10, out ebp_162, out esi_163, out edi_164);
		ebx_10->t1FEC = eax_44;
		if (eax_44 == 0x00)
		{
			edx_61.u0 = ~0x00;
			goto l0807C8D8;
		}
	}
	edx_61 = ebx_10->t0ED8;
	if (edx_61 != 0x0100)
	{
		ebx_10->t0ED8 = (byte) edx_61.u0 + 1;
		(ebx_10->t1FEC - 0x20)[edx_61] = dwArg04;
		ecx_24 = dwArg04;
	}
	else
	{
		gs->tFFFFFFE0.u0 = 0x1C;
		edx_61.u0 = ~0x00;
	}
l0807C8D8:
	if (gs->t000C != 0x00)
		__lock();
	word32 v12_86 = ebx_10->dw1A2C - 0x01;
	ebx_10->dw1A2C = v12_86;
	if (v12_86 != 0x00)
		__lll_unlock_wake_private(&ebx_10->dw1A2C, ecx_24, edx_61, gs);
}

// 0807C940: Register word32 __fprintf(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 ebxOut, Register out ptr32 ediOut)
// Called from:
//      __malloc_stats
//      malloc_info
word32 __fprintf(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & ebxOut, ptr32 & ediOut)
{
	word32 ecx_20;
	ptr32 edi_21;
	ptr32 ebx_23;
	word32 edx_41;
	word32 ebp_42;
	vfprintf(ebx, gs, dwArg04, dwArg08, fp + 0x0C, out ecx_20, out edx_41, out ebx_23, out ebp_42, out edi_21);
	ebxOut = ebx_23;
	ediOut = edi_21;
	return ecx_20;
}

// 0807C960: void read_int(Register (ptr32 (ptr32 Eq_89378)) eax)
void read_int(struct Eq_89378 ** eax)
{
	struct Eq_89378 * ecx_17 = *eax;
	up32 esi_20 = ecx_17->dw0004;
	struct Eq_89378 * ecx_19 = &ecx_17->dw0004;
	struct Eq_89378 * ebx_21 = &ecx_17->dw0004;
	int32 esi_22 = esi_20 - 0x30;
	int32 edx_23 = ecx_17->dw0000 - 0x30;
	if (esi_20 <= 0x39)
	{
		do
		{
			if (edx_23 >= 0x00)
			{
				if (edx_23 <= 0x0CCCCCCC)
				{
					ui32 edx_33 = edx_23 * 0x05;
					if (0x7FFFFFFF - esi_22 < edx_33 * 0x02)
						goto l0807C9B8;
					edx_23 = edx_33 * 0x02 + esi_22;
				}
				else
				{
l0807C9B8:
					struct Eq_89378 * ebx_43 = &ebx_21->dw0004;
					if (ebx_43->dw0000 > 0x39)
					{
						*eax = (struct Eq_89378 **) ebx_43;
						return;
					}
					++ecx_19;
					edx_23 = ~0x00;
					if (ecx_19->dw0000 > 0x39)
					{
						*eax = (struct Eq_89378 **) ecx_19;
						return;
					}
				}
			}
			ecx_19 = (struct Eq_89378 *) &ecx_19->dw0004;
			up32 esi_89 = ecx_19->dw0000;
			ebx_21 = ecx_19;
			esi_22 = esi_89 - 0x30;
		} while (esi_89 <= 0x39);
	}
	*eax = (struct Eq_89378 **) ebx_21;
}

// 0807CA00: void group_number(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack (ptr32 byte) dwArg04, Stack word32 dwArg08)
void group_number(Eq_2 eax, Eq_2 ecx, Eq_2 edx, byte * dwArg04, word32 dwArg08)
{
	int32 ebx_22 = (int32) *dwArg04;
	Eq_2 edi_120 = ecx;
	if ((byte) ebx_22 > 0x7E)
		return;
	Eq_2 esi_32 = ecx - edx;
	word32 edx_233;
	memmove(eax, edx, esi_32, out edx_233);
	word32 esi_35 = esi_32 + eax;
	struct Eq_89472 * ecx_121 = dwArg04 + 1;
	if (eax >= esi_35)
		return;
	*((word32) ecx - 4) = *((word32) esi_35 - 4);
	Eq_2 esi_124 = esi_35 - 0x04;
	Eq_2 edx_130 = ecx - 0x04;
	int32 ebx_119 = ebx_22 - 0x01;
	if (ebx_22 == 0x01)
	{
		esi_124 = esi_35 - 0x04;
		do
		{
			if (eax >= esi_124)
				return;
			if (esi_124 == edx_130)
			{
l0807CAB0:
				word32 edx_234;
				memmove(edx_130, esi_124, eax - esi_124, out edx_234);
				return;
			}
			*((word32) edi_120 - 8) = dwArg08;
			ebx_119 = (int32) ecx_121->b0000;
			edx_130 = edi_120 - 0x08;
			ci8 bl_77 = (byte) ebx_119;
			if (bl_77 == 0x7F || bl_77 < 0x00)
				goto l0807CAB0;
			if (bl_77 != 0x00)
			{
				++ecx_121;
				edi_120 = edx_130;
			}
			else
			{
				ebx_119 = (int32) ecx_121->bFFFFFFFF;
				edi_120 = edx_130;
			}
l0807CA88:
			esi_124 -= (word32 *) 0x04;
			*((word32) edi_120 - 4) = *esi_124;
			edx_130 = edi_120 - 0x04;
			--ebx_119;
		} while (ebx_119 == 0x00);
	}
	if (eax >= esi_124)
		return;
	edi_120 = edx_130;
	goto l0807CA88;
}

// 0807CAE0: void _i18n_number_rewrite(Register Eq_2 eax, Register (ptr32 word32) ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _i18n_number_rewrite(Eq_2 eax, word32 * ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	__align(fp - 4);
	Eq_2175 eax_35 = gs->t0014;
	struct Eq_72753 * eax_43 = wctrans(gs, 0x080B1CCC);
	Eq_2 eax_59 = __towctrans(0x2E, eax_43);
	Eq_2 eax_76 = __towctrans(44, eax_43);
	Eq_2 edx_88 = edx - eax;
	word32 ecx_440;
	word32 edx_441;
	if (__libc_scratch_buffer_set_array_size(gs, fp - 0x0444, edx_88 >> 0x02, 0x04, out ecx_440, out edx_441) != 0x00)
	{
		word32 edx_442;
		Eq_2 eax_125 = __mempcpy(fp - 0x0434, eax, edx_88, out edx_442);
		word32 * esi_137 = ecx;
		struct Eq_3440 * ebx_138 = gs->ptrFFFFFFD0;
l0807CBF5:
		for (eax_125 -= 0x04; fp - 0x0434 <= eax_125; eax_125 -= 0x04)
		{
			uint32 edx_147 = *eax_125;
			esi_137 -= 0x04;
			if (edx_147 <= 0x39)
			{
				*esi_137 = (word32) *((word32) ebx_138->t0000 + (edx_147 * 0x04 + 48));
				goto l0807CBF5;
			}
			if (eax_43 == null || (edx_147 & ~0x02) != 44)
				*esi_137 = edx_147;
			else
			{
				Eq_2 edx_167 = eax_59;
				if (edx_147 != 0x2E)
					edx_167 = eax_76;
				*esi_137 = (word32) edx_167;
			}
		}
		if (fp - 0x0434 != fp - 0x0434)
		{
			word32 ecx_445;
			word32 edx_446;
			free(gs, dwLoc0478, fp - 0x0434, out ecx_445, out edx_446);
		}
	}
	if ((eax_35 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_443;
	word32 edx_444;
	__stack_chk_fail(out ecx_443, out edx_444);
	_IO_helper_overflow(dwArg04, dwArg08);
}

// 0807CC80: void _IO_helper_overflow(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _i18n_number_rewrite
void _IO_helper_overflow(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edx_106 = *((word32) dwArg04 + 88);
	Eq_2 esp_18 = fp - 44;
	Eq_2 esi_22 = *((word32) edx_106 + 16);
	Eq_2 ebx_105 = *((word32) edx_106 + 0x0C);
	if (esi_22 != ebx_105)
	{
		Eq_2 edx_26 = *((word32) dwArg04 + 332);
		Eq_2 eax_36 = ebx_105;
		if (*((word32) edx_26 + 0x0094) >= 135066356)
		{
			word32 edx_206;
			word32 ecx_205;
			_IO_vtable_check(out ecx_205, out edx_206);
			esp_18.u0 = <invalid>;
			edx_26 = *((byte) esp_18.u0 + 0x0C);
			eax_36 = *((word32) *((word32) dwArg04 + 88) + 0x0C);
		}
		int32 esi_52 = esi_22 - ebx_105;
		struct Eq_89707 * esp_54 = esp_18 - 0x04;
		esp_54->tFFFFFFFC = esi_52 >> 0x02;
		esp_54->tFFFFFFF8 = eax_36;
		esp_54->tFFFFFFF4 = edx_26;
		struct Eq_89721 * eax_65 = esp_54->ptr000C;
		Eq_89725 eax_69;
		word32 ecx_71;
		eax_65->ptr001C();
		if (eax_69 > ~0x01)
			return;
		Eq_2 edx_83 = *((word32) *((word32) dwArg04 + 88) + 0x0C);
		esp_54->tFFFFFFFC = (esi_52 >> 0x02) - eax_69;
		esp_54->tFFFFFFF8 = (word32) edx_83 + eax_69 * 0x04;
		esp_54->tFFFFFFF4 = edx_83;
		wmemmove(esp_54->tFFFFFFF4, esp_54->tFFFFFFF8, esp_54->tFFFFFFFC);
		edx_106 = *((word32) dwArg04 + 88);
		Eq_2 eax_102 = *((word32) edx_106 + 16) - eax_69 * 0x04;
		*((word32) edx_106 + 16) = eax_102;
		ebx_105 = eax_102;
	}
	if (*((word32) edx_106 + 20) <= ebx_105)
	{
		word32 ecx_207;
		__woverflow(dwArg04, dwArg08, out ecx_207);
	}
	else
	{
		*((word32) edx_106 + 16) = (word32) ebx_105 + 4;
		*ebx_105 = dwArg08;
	}
}

// 0807CD80: Register Eq_2 printf_positional(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __vfwprintf
Eq_2 printf_positional(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	__align(fp - 4);
	struct Eq_89806 * ebp_106 = fp - 0x0C;
	Eq_2 esp_1019 = fp - 2388;
	if (dwArg20 == ~0x00)
	{
		byte al_72 = **((char *) *gs->ptrFFFFFFDC + 44);
		if (al_72 == 0x00 || al_72 == 0x7F)
			;
	}
	Eq_2 edx_1187;
	Eq_2 ecx_1016;
	ptr32 esp_1052;
	Eq_2 esi_1047;
	ptr32 esp_1032;
	Eq_2 esi_1027;
	Eq_2 esi_1119;
	Eq_2 ecx_1423;
	Eq_2 esi_1196;
	Eq_2 edi_104 = *dwArg14;
	if (edi_104 != 0x00)
	{
		edi_104.u0 = 0x00;
		Eq_2 ebx_118 = 0x00;
		Eq_2 esi_103 = dwArg14;
		do
		{
l0807CE98:
			Eq_2 edx_108 = (word32) ebp_106->tFFFFF770 + edi_104 *s 0x34;
			struct Eq_89862 * esp_111 = esp_1019 - 4;
			esp_111->t0000 = ebp_106->tFFFFF768;
			esp_111->tFFFFFFFC = edx_108;
			esp_111->tFFFFFFF8 = ebx_118;
			esp_111->tFFFFFFF4 = esi_103;
			ebp_106->tFFFFF774 = edx_108;
			word32 ebx_126;
			word32 eax_124 = __parse_one_specwc(esp_111->tFFFFFFF4, esp_111->tFFFFFFF8, esp_111->tFFFFFFFC, esp_111->t0000, out ebx_126, out ebp_106, out edi_104);
			Eq_2 esp_131 = <invalid>;
			esi_103 = *((word32) ebp_106->tFFFFF774 + 24);
			esp_1019 = (word32) esp_131 + 16;
			ebx_118 = ebx_126 + eax_124;
			if (*esi_103 == 0x00)
			{
				if (ebp_106->tFFFFF77C >= ebx_118)
					ebx_118 = ebp_106->tFFFFF77C;
				ebp_106->tFFFFF774 = ebx_118;
				goto l0807CF23;
			}
		} while (ebp_106->tFFFFF76C != edi_104);
		*esp_131 = ebp_106->tFFFFF758;
		esp_1019 = (word32) esp_131 + 16;
		if ((byte) __libc_scratch_buffer_grow_preserve(gs, dwArg00, out ecx_1016, out edx_1187) != 0x00)
		{
			ebp_106->tFFFFF770 = ebp_106->tFFFFF7B8;
			ebp_106->tFFFFF76C = SLICE(ebp_106->dwFFFFF7BC *64 0x4EC4EC4F, word32, 32) >> 0x04;
			goto l0807CE98;
		}
l0807D5D8:
		do
		{
l0807D5D8:
			esi_1196.u0 = ~0x00;
l0807D5DD:
			Eq_2 eax_623 = ebp_106->tFFFFFBC8;
			if (eax_623 != ebp_106->tFFFFF744)
			{
				*((word32) esp_1019 - 16) = eax_623;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				free(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187);
			}
			Eq_2 eax_646 = ebp_106->tFFFFF7B8;
			if (eax_646 != ebp_106->tFFFFF750)
			{
				*((word32) esp_1019 - 16) = eax_646;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				free(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187);
			}
			esi_1119 = ebp_106->dwFFFFFFE4 ^ gs->t0014;
			if (esi_1119 == 0x00)
			{
				ecxOut = ecx_1016;
				edxOut = edx_1187;
				return esi_1196;
			}
			Eq_2 ecx_686;
			word32 edx_4289;
			__stack_chk_fail(out ecx_686, out edx_4289);
			if (ecx_686 > 0x00)
			{
				ebp_106->tFFFFF774 = ecx_686;
				struct Eq_92324 * esp_691 = esp_1019 - 0x04;
				esp_691->tFFFFFFFC = ecx_686;
				esp_691->dwFFFFFFF8 = 0x20;
				esp_691->tFFFFFFF4 = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				word32 ecx_4291;
				word32 ebp_4294;
				word32 ebx_4293;
				word32 edx_4292;
				word32 edi_4296;
				word32 esi_4295;
				Eq_2 eax_702 = _IO_wpadn(gs, dwArg00, stackArg8, dwArg08, out ecx_4291, out edx_4292, out ebx_4293, out ebp_4294, out esi_4295, out edi_4296);
				ecx_1016 = ebp_106->tFFFFF774;
				esp_1019 = (char *) &esp_691->tFFFFFFFC + 8;
				if (ecx_1016 != eax_702)
					goto l0807D5B3;
				if (ebp_106->tFFFFF75C > 0x7FFFFFFE)
				{
l0807F6CF:
					esi_1027 = ebp_106->tFFFFF764;
					struct Eq_92552 * esp_1030 = esp_1019 - 4;
					esp_1030->ptr0000 = (word32) esi_1027 - 0x0001C23C;
					esp_1030->dwFFFFFFFC = 0x07E1;
					esp_1032 = esp_1030 - 4;
					goto l0807F6E1;
				}
				Eq_2 ebx_712 = ebp_106->tFFFFF75C;
				if (0x7FFFFFFF - ebx_712 < ecx_1016)
					goto l0807D5A0;
				Mem721[ebp_106 + ~0x08A3:word32] = ebx_712 + ecx_1016;
			}
			ecx_1016.u0 = 0x00;
			if (ebp_106->tFFFFF768 != 0x00)
			{
				struct Eq_91262 * eax_780 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_780 != null)
				{
					Eq_2 edx_784 = eax_780->t0010;
					if (edx_784 >= eax_780->t0014)
						goto l0807F218;
					eax_780->t0010 = (word32) edx_784 + 4;
					edx_784->u0 = 0x2D;
					goto l0807DF7A;
				}
l0807F218:
				ebp_106->tFFFFF774.u0 = 0x00;
				*((word32) esp_1019 - 0x0C) = 0x2D;
				goto l0807F223;
			}
			if (ebp_106->tFFFFF734 != 0x00)
			{
				struct Eq_91262 * eax_761 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_761 != null)
				{
					Eq_2 edx_765 = eax_761->t0010;
					if (edx_765 >= eax_761->t0014)
						goto l0807F483;
					eax_761->t0010 = (word32) edx_765 + 4;
					*edx_765 = 0x2B;
					goto l0807DF7A;
				}
l0807F483:
				ebp_106->tFFFFF774.u0 = 0x00;
				*((word32) esp_1019 - 0x0C) = 0x2B;
				goto l0807F223;
			}
			if (ebp_106->dwFFFFF72C != 0x00)
			{
				struct Eq_91262 * eax_740 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_740 != null)
				{
					Eq_2 edx_744 = eax_740->t0010;
					if (edx_744 >= eax_740->t0014)
						goto l0807F698;
					eax_740->t0010 = (word32) edx_744 + 4;
					*edx_744 = 0x20;
					goto l0807DF7A;
				}
l0807F698:
				ebp_106->tFFFFF774.u0 = 0x00;
				*((word32) esp_1019 - 0x0C) = 0x20;
l0807F223:
				struct Eq_92621 * esp_798 = esp_1019 - 0x0C;
				esp_798->tFFFFFFFC = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				word32 ecx_4302;
				word32 eax_836 = __woverflow(dwArg00, stackArg8, out ecx_4302);
				esp_1019 = (char *) &esp_798->tFFFFFFFC + 16;
				ecx_1016 = ebp_106->tFFFFF774;
				if (eax_836 == ~0x00)
					goto l0807D5B3;
l0807DF7A:
				Eq_2 eax_849 = ebp_106->tFFFFF75C;
				if (eax_849 == 0x7FFFFFFF)
					goto l0807D5B3;
				ebp_106->tFFFFF75C = (word32) eax_849 + 1;
			}
			if (ebp_106->dwFFFFF704 != 0x00 && (ebp_106->dwFFFFF718 == 0x10 && ebp_106->dwFFFFF724 != 0x00))
			{
				Eq_2 edx_925;
				struct Eq_91262 * eax_868 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_868 == null)
				{
l0807F520:
					ebp_106->tFFFFF774 = ecx_1016;
					struct Eq_92439 * esp_880 = esp_1019 - 0x08;
					esp_880->dwFFFFFFFC = 0x30;
					esp_880->tFFFFFFF8 = ebp_106->tFFFFF760;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					word32 ecx_4298;
					word32 eax_909 = __woverflow(dwArg00, stackArg8, out ecx_4298);
					esp_1019 = &esp_880->dwFFFFFFFC + 3;
					ecx_1016 = ebp_106->tFFFFF774;
					if (eax_909 == ~0x00 || ebp_106->tFFFFF75C == 0x7FFFFFFF)
						goto l0807D5B3;
					eax_868 = (struct Eq_91262 *) *((word32) ebp_106->tFFFFF760 + 88);
					if (eax_868 != null)
					{
						edx_925 = eax_868->t0010;
						ebp_106->tFFFFF774 = eax_868->t0014;
l0807DFF6:
						if (ebp_106->tFFFFF774 <= edx_925)
							goto l0807F4E8;
						eax_868->t0010 = (word32) edx_925 + 4;
						*edx_925 = ebp_106->tFFFFF770;
						goto l0807E010;
					}
l0807F4E8:
					struct Eq_92496 * esp_939 = esp_1019 - 0x08;
					esp_939->tFFFFFFFC = ebp_106->tFFFFF770;
					esp_939->tFFFFFFF8 = ebp_106->tFFFFF760;
					ebp_106->tFFFFF774 = ecx_1016;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					word32 ecx_4300;
					word32 eax_965 = __woverflow(dwArg00, stackArg8, out ecx_4300);
					esp_1019 = (char *) &esp_939->tFFFFFFFC + 0x0C;
					ecx_1016 = ebp_106->tFFFFF774;
					if (eax_965 == ~0x00)
						goto l0807D5B3;
l0807E010:
					Eq_2 eax_979 = ebp_106->tFFFFF75C;
					if (eax_979 == 0x7FFFFFFE)
						goto l0807D5B3;
					ebp_106->tFFFFF75C = (word32) eax_979 + 2;
					goto l0807E02A;
				}
				Eq_2 edx_872 = eax_868->t0014;
				Eq_2 ebx_873 = eax_868->t0010;
				ebp_106->tFFFFF774 = edx_872;
				if (ebx_873 >= edx_872)
					goto l0807F520;
				eax_868->t0010 = (word32) ebx_873 + 4;
				*ebx_873 = 0x30;
				edx_925 = (word32) ebx_873 + 4;
				if (ebp_106->tFFFFF75C != 0x7FFFFFFF)
					goto l0807DFF6;
l0807D5B3:
				edx_1187 = ebp_106->tFFFFF76C;
				if (edx_1187 != 0x00)
				{
					struct Eq_91486 * esp_2670 = esp_1019 - 0x0C;
					esp_2670->tFFFFFFFC = ebp_106->tFFFFF76C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					free(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187);
					esp_1019 = (char *) &esp_2670->tFFFFFFFC + 16;
				}
				goto l0807D5D8;
			}
l0807E02A:
			edi_104 += ecx_1016;
			if (edi_104 > 0x00)
			{
				*((word32) esp_1019 - 8) = edi_104;
				*((word32) esp_1019 - 0x0C) = 0x30;
				*((word32) esp_1019 - 16) = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				word32 ebp_4306;
				word32 esi_4307;
				word32 edi_4308;
				word32 edx_4304;
				word32 ebx_4305;
				if (edi_104 != _IO_wpadn(gs, dwArg00, stackArg8, dwArg08, out ecx_1016, out edx_4304, out ebx_4305, out ebp_4306, out esi_4307, out edi_4308))
					goto l0807D5B3;
				Eq_2 ebx_1022 = ebp_106->tFFFFF75C;
				if (ebx_1022 > 0x7FFFFFFE)
					goto l0807F6CF;
				if (0x7FFFFFFF - ebx_1022 < edi_104)
					goto l0807D5A0;
				Mem1040[ebp_106 + ~0x08A3:word32] = ebx_1022 + edi_104;
			}
			Eq_2 edx_1043 = ebp_106->tFFFFF75C;
			if (edx_1043 < 0x00)
			{
				esi_1047 = ebp_106->tFFFFF764;
				*((word32) esp_1019 - 4) = (word32) esi_1047 - 0x0001C23C;
				*((word32) esp_1019 - 8) = 0x07E1;
				esp_1052 = esp_1019 - 8;
l0807F706:
				struct Eq_91121 * esp_2619 = esp_1052 - 4;
				esp_2619->ptr0000 = (word32) esi_1047 - 0x0001C322;
				esp_2619->ptrFFFFFFFC = (word32) esi_1047 - 0x0001C28C;
				word32 edx_4276;
				word32 ecx_4275;
				__assert_fail(out ecx_4275, out edx_4276);
				esp_1019 = esp_2619 - 4;
				goto l0807F719;
			}
			Eq_2 ebx_1055 = *((word32) ebp_106->tFFFFF760 + 0x0094);
			Eq_2 eax_1057 = ebx_1055 - ebp_106->dwFFFFF6E0;
			if (ebp_106->tFFFFF6DC <= eax_1057)
				eax_1057 = _IO_vtable_check(out ecx_1016, out edx_1043);
			edi_104 = ebp_106->tFFFFF74C;
			*((word32) esp_1019 - 8) = edi_104;
			*((word32) esp_1019 - 0x0C) = ebp_106->dwFFFFF710;
			*((word32) esp_1019 - 16) = ebp_106->tFFFFF760;
			Eq_2 eax_1090;
			(*((word32) ebx_1055 + 28))();
			if (edi_104 != eax_1090)
				goto l0807D5B3;
			ecx_1016 = ebp_106->tFFFFF75C;
			if (edi_104 > 0x7FFFFFFF - ecx_1016)
				goto l0807D5A0;
			Mem1104[ebp_106 + ~0x08A3:word32] = ecx_1016 + edi_104;
l0807DBD9:
			if (ebp_106->tFFFFF76C != 0x00)
			{
				*((word32) esp_1019 - 16) = ebp_106->tFFFFF76C;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ecx_4270;
				word32 edx_4271;
				free(gs, stackArg0, dwArg00, out ecx_4270, out edx_4271);
			}
			Eq_2 ecx_1133 = ebp_106->tFFFFF75C;
			if (ecx_1133 < 0x00)
			{
				esi_1047 = ebp_106->tFFFFF764;
				struct Eq_90851 * esp_1140 = esp_1019 - 4;
				esp_1140->ptr0000 = (word32) esi_1047 - 0x0001C23C;
				esp_1140->dwFFFFFFFC = 0x0809;
				esp_1052 = esp_1140 - 4;
				goto l0807F706;
			}
			Eq_2 ebx_1145 = *((word32) ebp_106->tFFFFF760 + 0x0094);
			if (ebp_106->dwFFFFF708 <= ebx_1145 - ebp_106->dwFFFFF70C)
			{
				word32 edx_4272;
				_IO_vtable_check(out ecx_1133, out edx_4272);
			}
			word32 edx_1161 = *((word32) esi_1119 + 20);
			struct Eq_90889 * esp_1164 = esp_1019 - 0x04;
			int32 eax_1165 = *((word32) esi_1119 + 24) - edx_1161;
			esp_1164->dwFFFFFFFC = eax_1165 >> 0x02;
			esp_1164->dwFFFFFFF8 = edx_1161;
			esp_1164->tFFFFFFF4 = ebp_106->tFFFFF760;
			int32 eax_1181;
			(*((word32) ebx_1145 + 28))();
			int32 edx_1186 = *((word32) esi_1119 + 24) - *((word32) esi_1119 + 20);
			edx_1187 = edx_1186 >> 0x02;
			esp_1019 = &esp_1164->dwFFFFFFFC + 2;
		} while (edx_1186 >> 0x02 != eax_1181);
		if (edx_1186 >> 0x02 <= 0x7FFFFFFF - ebp_106->tFFFFF75C)
		{
			ebp_106->tFFFFF754 = (word32) ebp_106->tFFFFF754 + 1;
			Eq_2 eax_1202 = ebp_106->tFFFFF754;
			ebp_106->tFFFFF75C = (word32) ebp_106->tFFFFF75C + (edx_1186 >> 0x02);
			esi_1119 = (word32) esi_1119 + 52;
			if (eax_1202 >= ebp_106->tFFFFF6FC)
				goto l0807DC77;
			goto l0807D1AE;
		}
		gs->tFFFFFFE0.u0 = 0x4B;
		esi_1196.u0 = ~0x00;
		goto l0807D5DD;
	}
l0807CF23:
	Eq_2 esi_152 = ebp_106->tFFFFF774;
	struct Eq_90009 * esp_157 = esp_1019 - 0x04;
	esp_157->tFFFFFFFC.u0 = 0x14;
	esp_157->tFFFFFFF8 = esi_152;
	esp_157->tFFFFFFF4 = ebp_106 - 1080;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	esp_1019 = (char *) &esp_157->tFFFFFFFC + 8;
	if (__libc_scratch_buffer_set_array_size(gs, dwArg00, stackArg8, dwArg08, out ecx_1016, out edx_1187) == 0x00)
		goto l0807D5D8;
	Eq_2 ebx_196 = ebp_106->tFFFFFBC8;
	ebp_106->tFFFFF758 = ebx_196;
	esp_157->tFFFFFFFC = esi_152 * 0x04;
	Eq_2 esi_200 = (word32) ebx_196 + esi_152 * 0x0C;
	Eq_2 ecx_205 = (word32) esi_200 + esi_152 * 0x04;
	Eq_2 eax_206 = ebp_106->tFFFFF760;
	ebp_106->tFFFFF768 = ecx_205;
	ui32 eax_208 = *((word32) eax_206 + 60);
	ebp_106->tFFFFF76C = esi_200;
	esp_157->tFFFFFFF8 = eax_208 << 0x1D >> 0x1F;
	esp_157->tFFFFFFF4 = ecx_205;
	word32 ecx_4261;
	memset(esp_157->tFFFFFFF4, esp_157->tFFFFFFF8, esp_157->tFFFFFFFC, out ecx_4261, out edx_1187);
	esp_1019 = (char *) &esp_157->tFFFFFFFC + 8;
	ecx_1016 = ebp_106->tFFFFF768;
	if (edi_104 != 0x00)
	{
		Eq_2 eax_235 = ebp_106->tFFFFF770;
		ebp_106->tFFFFF740 = edi_104;
		Eq_2 ebx_237 = eax_235;
		Eq_2 esi_238 = (word32) eax_235 + edi_104 *s 0x34;
		do
		{
			ui32 eax_244 = ebx_237.u22->dw0020;
			if (eax_244 != ~0x00)
				((word32) ecx_1016 + eax_244 * 0x04)->u0 = 0x00;
			ui32 eax_251 = ebx_237.u22->dw001C;
			if (eax_251 != ~0x00)
				((word32) ecx_1016 + eax_251 * 0x04)->u0 = 0x00;
			word32 eax_258 = ebx_237.u22->dw002C;
			if (eax_258 != 0x00)
			{
				if (eax_258 != 0x01)
				{
					ui32 ecx_283 = ebx_237.u22->dw0024;
					ebp_106->tFFFFF768 = ebx_237.u22->dw0008;
					struct Eq_92259 * esp_293 = esp_1019 - 4;
					esp_293->dw0000 = (word32) ebp_106->tFFFFF76C + ecx_283 * 0x04;
					ui32 edx_289 = (word32) ecx_1016 + ecx_283 * 0x04;
					Eq_2 ecx_295 = ebp_106->tFFFFF768;
					esp_293->dwFFFFFFFC = edx_289;
					esp_293->dwFFFFFFF8 = eax_258;
					Eq_2 eax_300 = ebp_106->tFFFFF764;
					esp_293->tFFFFFFF4 = ebx_237;
					<anonymous> * eax_305[] = *((word32) eax_300 + 8168);
					eax_305[ecx_295]();
					++ebx_237.u22;
					if (esi_238 == ebx_237)
						break;
					continue;
				}
				Eq_2 ecx_269 = ebp_106->tFFFFF76C;
				*((word32) ecx_1016 + (ebx_237.u22)->dw0024 * 0x04) = ebx_237.u22->dw0028;
				edx_1187 = ebx_237.u22->dw0030;
				*((word32) ecx_269 + (ebx_237.u22)->dw0024 * 0x04) = edx_1187;
			}
			++ebx_237.u22;
		} while (esi_238 != ebx_237);
		edi_104 = ebp_106->tFFFFF740;
		if (ebp_106->tFFFFF774 == 0x00)
		{
l0807D128:
			if (edi_104 <= ebp_106->tFFFFF754)
			{
l0807DC77:
				esi_1196 = ebp_106->tFFFFF75C;
				goto l0807D5DD;
			}
			word32 eax_580 = ebp_106->dwFFFFF738;
			Eq_2 esi_581 = ebp_106->tFFFFF770;
			ebp_106->tFFFFF6FC = edi_104;
			ebp_106->tFFFFF6F8 = eax_580 + 1000;
			esi_1119 = (word32) esi_581 + ebp_106->tFFFFF754 *s 0x34;
			ebp_106->dwFFFFF6D8 = 0x080CEFA0;
			ebp_106->dwFFFFF6D4 = 0x0354;
			ebp_106->dwFFFFF6D0 = 0x080CEFA0;
			ebp_106->dwFFFFF6CC = 0x0354;
			ebp_106->dwFFFFF6F0 = 0x080CEFA0;
			ebp_106->dwFFFFF6E4 = 0x0354;
			ebp_106->dwFFFFF6E0 = 0x080CEFA0;
			ebp_106->tFFFFF6DC.u0 = 0x0354;
			ebp_106->dwFFFFF70C = 0x080CEFA0;
			ebp_106->dwFFFFF708 = 0x0354;
l0807D1AE:
			ui32 eax_1209 = (word32) *((word32) esi_1119 + 0x0C);
			byte cl_1219 = (byte) eax_1209 >> 0x03 & 0x01;
			ebp_106->bFFFFF700 = cl_1219;
			ebp_106->dwFFFFF724 = (word32) cl_1219;
			ebp_106->dwFFFFF72C = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x04) & 0x01;
			ebp_106->tFFFFF74C = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x05) & 0x01;
			ebp_106->tFFFFF734 = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x06) & 0x01;
			ebp_106->bFFFFF730 = (byte) eax_1209 >> 0x07;
			ebp_106->tFFFFF768 = eax_1209 & 0x01;
			word32 edx_1258 = (word32) *((word32) esi_1119 + 0x0D);
			ebp_106->dwFFFFF704 = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x01) & 0x01;
			ebp_106->bFFFFF72A = (byte) edx_1258 >> 0x03 & 0x01;
			edx_1187 = *((word32) esi_1119 + 32);
			ebp_106->dwFFFFF710 = SEQ(SLICE(edx_1258, word24, 8), (byte) edx_1258 >> 0x01) & 0x01;
			ebp_106->bFFFFF72B = (byte) *((word32) esi_1119 + 16);
			Eq_2 ecx_1286 = *((word32) esi_1119 + 8);
			ebp_106->dwFFFFF718 = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x02) & 0x01;
			edi_104 = *esi_1119;
			ebp_106->tFFFFF770 = ecx_1286;
			if (edx_1187 != ~0x00)
			{
				Eq_2 ecx_1296 = *((word32) ebp_106->tFFFFF758 + edx_1187 * 0x0C);
				ebp_106->tFFFFF774 = ecx_1296;
				edx_1187 *= 0x03;
				if (ecx_1296 >= 0x00)
					*((word32) esi_1119 + 4) = ecx_1296;
				else
				{
					ebp_106->tFFFFF774 = -ebp_106->tFFFFF774;
					Eq_2 ecx_1304 = ebp_106->tFFFFF774;
					*((word32) esi_1119 + 0x0C) = (byte) eax_1209 | 0x20;
					*((word32) esi_1119 + 4) = ecx_1304;
					ebp_106->tFFFFF74C.u0 = 0x01;
				}
			}
			else
				ebp_106->tFFFFF774 = *((word32) esi_1119 + 4);
			ui32 eax_1315 = *((word32) esi_1119 + 28);
			if (eax_1315 != ~0x00)
			{
				edi_104 = *((word32) ebp_106->tFFFFF758 + eax_1315 * 0x0C);
				if (edi_104 >= 0x00)
					*esi_1119 = edi_104;
				else
				{
					*esi_1119 = ~0x00;
					edi_104.u0 = ~0x00;
				}
			}
			Eq_2 eax_1330 = ebp_106->tFFFFF774;
			if (eax_1330 < edi_104)
				eax_1330 = edi_104;
			if (eax_1330 <= 0xDA)
			{
l0807D458:
				ebp_106->tFFFFF76C.u0 = 0x00;
				ebp_106->tFFFFF740 = ebp_106->tFFFFF6F8;
				goto l0807D46E;
			}
			struct Eq_90735 * esp_1354 = esp_1019 - 0x0C;
			Eq_2 ebx_1356 = eax_1330 * 0x04 + 0x80;
			esp_1354->tFFFFFFFC = ebx_1356;
			esp_1019 = (char *) &esp_1354->tFFFFFFFC + 16;
			if (__libc_alloca_cutoff(gs, esp_1354->tFFFFFFFC) != 0x00 || ebx_1356 <= 0x1000)
			{
				Eq_2 edx_1432 = (char *) &esp_1354->tFFFFFFFC + 16 - ((word32) ebx_1356 + 27 & ~0x0FFF);
				ui32 eax_1433 = (word32) ebx_1356 + 27 & ~0x0F;
				if ((char *) &esp_1354->tFFFFFFFC + 16 != edx_1432)
				{
					do
					{
						esp_1019 -= 0x1000;
						*((word32) esp_1019 + 0x0FFC) = *((word32) esp_1019 + 0x0FFC);
					} while (esp_1019 != edx_1432);
				}
				if ((eax_1433 & 0x0FFF) != 0x00)
				{
					esp_1019 -= eax_1433 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_1433 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_1433 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				ui32 eax_1474;
				Eq_90808 edx_1460 = (word32) esp_1019 + 0x0F;
				edx_1187 = edx_1460 & ~0x0F;
				if (ebp_106->tFFFFF774 < edi_104)
					eax_1474 = edi_104 * 0x04 + 0x80;
				else
					eax_1474 = ebp_106->tFFFFF774 * 0x04 + 0x80;
				ecx_1423 = ebp_106->tFFFFF770;
				ebp_106->tFFFFF76C.u0 = 0x00;
				ebp_106->tFFFFF740 = eax_1474 + (edx_1460 & ~0x0F);
				if (ecx_1423 <= 0xFF)
				{
l0807D480:
					struct Eq_90267 * eax_1489 = *((word32) ebp_106->tFFFFF764 + 8148);
					if (eax_1489 != null)
					{
						edx_1187 = eax_1489[ecx_1423 * 0x04];
						if (edx_1187 != 0x00)
						{
							ui32 eax_1508 = *((word32) esi_1119 + 44);
							ebp_106->dwFFFFF6C8 = eax_1508;
							ebp_106->dwFFFFF6F4 = eax_1508 << 0x02;
							ui32 ecx_1511 = (eax_1508 << 0x02) + 0x1B;
							ebp_106->dwFFFFF6C4 = ecx_1511 & ~0x0F;
							Eq_2 eax_1523 = esp_1019 - (ecx_1511 & ~0x0FFF);
							ui32 eax_1525 = ebp_106->dwFFFFF6F4;
							while (esp_1019 != eax_1523)
							{
								esp_1019 -= 0x1000;
								*((word32) esp_1019 + 0x0FFC) = *((word32) esp_1019 + 0x0FFC);
							}
							ebp_106->dwFFFFF6F4 = eax_1525;
							ui32 ecx_1542 = ebp_106->dwFFFFF6C4;
							if ((ecx_1542 & 0x0FFF) != 0x00)
							{
								esp_1019 -= ecx_1542 & 0x0FFF;
								(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(ecx_1542 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(ecx_1542 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
							}
							Eq_90331 ecx_1554 = (word32) esp_1019 + 0x0F;
							ui32 ecx_1558 = ebp_106->dwFFFFF6C8;
							ebp_106->dwFFFFF6C4 = ecx_1554 & ~0x0F;
							struct Eq_90343 * eax_1559 = ecx_1554 & ~0x0F;
							if (ecx_1558 != 0x00)
							{
								ecx_1558 = (word32) ebp_106->tFFFFF758 + *((word32) esi_1119 + 36) * 0x0C;
								word32 * edx_1571 = ecx_1554 & ~0x0F;
								word32 * eax_1572 = (ecx_1554 & ~0x0F) + ebp_106->dwFFFFF6F4;
								do
								{
									*edx_1571 = ecx_1558;
									++edx_1571;
									ecx_1558 += 0x0C;
								} while (eax_1572 != edx_1571);
								eax_1559 = (struct Eq_90343 *) *((word32) ebp_106->tFFFFF764 + 8148);
								edx_1187 = eax_1559[ecx_1423 * 0x04];
							}
							struct Eq_90510 * esp_1593 = esp_1019 - 0x04;
							esp_1593->dwFFFFFFFC = ebp_106->dwFFFFF6C4;
							esp_1593->tFFFFFFF8 = esi_1119;
							esp_1593->tFFFFFFF4 = ebp_106->tFFFFF760;
							Eq_90528 eax_1652;
							edx_1187();
							esp_1019 = &esp_1593->ptr0000 + 1;
							if (eax_1652 != ~0x01)
							{
								if (eax_1652 < 0x00)
									goto l0807D5B3;
								if (ebp_106->tFFFFF75C <= 0x7FFFFFFE)
								{
									if (0x7FFFFFFF - ebp_106->tFFFFF75C < eax_1652)
										goto l0807D5A0;
									Mem1675[ebp_106 + ~0x08A3:word32] = Mem1606[ebp_106 + ~0x08A3:word32] + eax_1652;
									goto l0807DBD9;
								}
								esi_1027 = ebp_106->tFFFFF764;
								esp_1593->ptr0000 = (word32) esi_1027 - 0x0001C23C;
								esp_1593->dwFFFFFFFC = 2010;
								esp_1032 = esp_1593 - 4;
l0807F6E1:
								struct Eq_91088 * esp_2582 = esp_1032 - 4;
								esp_2582->ptr0000 = (word32) esi_1027 - 0x0001C322;
								esp_2582->ptrFFFFFFFC = (word32) esi_1027 - 115388;
								word32 ecx_4273;
								word32 edx_4274;
								__assert_fail(out ecx_4273, out edx_4274);
								esi_1047 = ebp_106->tFFFFF764;
								esp_2582->ptrFFFFFFF8 = (word32) esi_1047 - 0x0001C23C;
								esp_2582->dwFFFFFFF4 = 0x07E2;
								esp_1052 = esp_2582 - 0x0C;
								goto l0807F706;
							}
						}
					}
					goto l0807D354;
				}
l0807D354:
				Eq_2 esp_1696 = fp;
				Eq_2 ecx_1679 = ebp_106->tFFFFF770;
				if (ecx_1679 <= 122)
				{
					Eq_2 ebx_1683 = ebp_106->tFFFFF764;
					ui32 eax_1684 = (word32) *((word32) ecx_1679 + ((word32) ebx_1683 - 114784));
					Eq_2 eax_1698;
					Eq_2 ecx_1699;
					Eq_2 edx_1700;
					(*((word32) ebx_1683 + (eax_1684 * 0x04 - 5056)))();
					ecxOut = ecx_1699;
					edxOut = edx_1700;
					return eax_1698;
				}
				ui32 edx_1702 = *((word32) esi_1119 + 44);
				ui32 eax_1705 = edx_1702 * 0x04 + 0x1B;
				edi_104 = fp - (eax_1705 & ~0x0FFF);
				while (esp_1696 != edi_104)
				{
					esp_1696 -= 0x1000;
					*((word32) esp_1696 + 0x0FFC) = *((word32) esp_1696 + 0x0FFC);
				}
				int32 ebx_1718 = eax_1705 & ~0x0F & 0x0FFF;
				if (ebx_1718 != 0x00)
				{
					esp_1696 -= ebx_1718;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1696 - 0x04)[ebx_1718 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1696 - 0x04)[ebx_1718 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_91227 eax_1729 = (word32) esp_1696 + 0x0F;
				word32 * eax_1730 = eax_1729 & ~0x0F;
				if (edx_1702 != 0x00)
				{
					edi_104 = ebp_106->tFFFFF758;
					word32 * ecx_1745 = edx_1702 * 0x04 + (eax_1729 & ~0x0F);
					ptr32 edx_1748 = (byte) edi_104.u0 + *((word32) esi_1119 + 36) * 0x0C;
					do
					{
						*eax_1730 = edx_1748;
						++eax_1730;
						edx_1748 += 0x0C;
					} while (ecx_1745 != eax_1730);
				}
				ui32 edx_1831;
				ui32 edx_1816;
				Eq_2 ecx_1826;
				Eq_2 ebx_1767;
				struct Eq_91262 * eax_1762 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_1762 != null)
				{
					Eq_2 edx_1766 = eax_1762->t0010;
					ebx_1767 = eax_1762->t0014;
					if (edx_1766 < ebx_1767)
					{
						eax_1762->t0010 = (word32) edx_1766 + 4;
						edx_1766->u0 = 0x25;
						edx_1831 = (word32) *((word32) esi_1119 + 0x0C);
						ecx_1826 = (word32) edx_1766 + 4;
						ci8 dl_1832 = (byte) edx_1831;
						if ((dl_1832 & 0x08) == 0x00)
						{
							ebp_106->tFFFFF770.u0 = 0x01;
							if (dl_1832 >= 0x00)
								goto l0807E7CE;
							goto l0807EFD0;
						}
						goto l0807E7A4;
					}
				}
				struct Eq_91293 * esp_1773 = esp_1696 - 0x08;
				esp_1773->dwFFFFFFFC = 0x25;
				esp_1773->tFFFFFFF8 = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				esp_1019 = &esp_1773->dwFFFFFFFC + 3;
				if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
					goto l0807D5B3;
				ebp_106->tFFFFF770.u0 = 0x01;
				edx_1816 = (word32) *((word32) esi_1119 + 0x0C);
				if (((byte) edx_1816 & 0x08) == 0x00)
					goto l0807F2FA;
				eax_1762 = (struct Eq_91262 *) *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_1762 == null)
				{
l0807F2D0:
					struct Eq_91349 * esp_1846 = esp_1696 - 0x08;
					esp_1846->dwFFFFFFFC = 0x23;
					esp_1846->tFFFFFFF8 = ebp_106->tFFFFF760;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					esp_1019 = &esp_1846->dwFFFFFFFC + 3;
					if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
						goto l0807D5B3;
					ebp_106->tFFFFF770.u0 = 0x02;
					edx_1816 = (word32) *((word32) esi_1119 + 0x0C);
l0807F2FA:
					edx_1831 = edx_1816;
					if ((byte) edx_1816 >= 0x00)
					{
l0807E7CE:
						ui32 edx_2036;
						byte dl_1957 = (byte) edx_1831;
						if ((dl_1957 & 0x40) != 0x00)
						{
							struct Eq_91262 * eax_1986 = *((word32) ebp_106->tFFFFF760 + 88);
							if (eax_1986 != null)
							{
								Eq_2 edx_1990 = eax_1986->t0010;
								if (edx_1990 < eax_1986->t0014)
								{
									eax_1986->t0010 = (word32) edx_1990 + 4;
									edx_1990->u0 = 0x2B;
									goto l0807E800;
								}
							}
							*((word32) esp_1696 - 0x0C) = 0x2B;
						}
						else
						{
							edx_2036 = edx_1831;
							if ((dl_1957 & 0x10) == 0x00)
								goto l0807E80B;
							struct Eq_91262 * eax_1968 = *((word32) ebp_106->tFFFFF760 + 88);
							if (eax_1968 != null)
							{
								Eq_2 edx_1972 = eax_1968->t0010;
								if (edx_1972 < eax_1968->t0014)
								{
									eax_1968->t0010 = (word32) edx_1972 + 4;
									edx_1972->u0 = 0x20;
									goto l0807E800;
								}
							}
							*((word32) esp_1696 - 0x0C) = 0x20;
						}
						struct Eq_92116 * esp_2003 = esp_1696 - 0x0C;
						esp_2003->tFFFFFFFC = ebp_106->tFFFFF760;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1019 = (char *) &esp_2003->tFFFFFFFC + 16;
						if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
							goto l0807D5B3;
l0807E800:
						ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
						edx_2036 = (word32) *((word32) esi_1119 + 0x0C);
l0807E80B:
						if ((edx_2036 & 0x20) == 0x00)
						{
l0807E840:
							if (*((word32) esi_1119 + 16) != 0x30)
							{
l0807E84A:
								if ((*((word32) esi_1119 + 0x0D) & 0x08) == 0x00)
								{
l0807E880:
									uint32 ecx_2248 = *((word32) esi_1119 + 4);
									if (ecx_2248 == 0x00)
									{
l0807EC6C:
										uint32 ecx_2340 = *esi_1119;
										if (ecx_2340 == ~0x00)
										{
l0807EF37:
											esp_1019 = esp_1696;
											Eq_2 eax_2501 = *((word32) esi_1119 + 8);
											if (eax_2501 == 0x00)
											{
l0807EF86:
												esp_1019 = esp_1696;
												if (ebp_106->tFFFFF75C > 0x7FFFFFFE)
												{
l0807F719:
													esi_1027 = ebp_106->tFFFFF764;
													struct Eq_92038 * esp_2575 = esp_1019 - 4;
													esp_2575->ptr0000 = (word32) esi_1027 - 0x0001C23C;
													esp_2575->dwFFFFFFFC = 0x07FD;
													esp_1032 = esp_2575 - 4;
													goto l0807F6E1;
												}
												edi_104 = ebp_106->tFFFFF75C;
												ecx_1016 = ebp_106->tFFFFF770;
												if (0x7FFFFFFF - edi_104 >= ecx_1016)
												{
													edi_104 += ecx_1016;
													ebp_106->tFFFFF75C = edi_104;
													goto l0807DBD9;
												}
l0807D5A0:
												gs->tFFFFFFE0.u0 = 0x4B;
												goto l0807D5B3;
											}
											edi_104 = ebp_106->tFFFFF760;
											struct Eq_91981 * edx_2507 = *((byte) edi_104.u0 + 88);
											if (edx_2507 != null)
											{
												ecx_1016 = edx_2507->t0010;
												if (ecx_1016 < edx_2507->t0014)
												{
													edx_2507->t0010 = (word32) ecx_1016 + 4;
													*ecx_1016 = eax_2501;
													if (eax_2501 == ~0x00)
														goto l0807D5B3;
l0807EF6C:
													esp_1019 = esp_1696;
													Eq_2 eax_2560 = ebp_106->tFFFFF770;
													if (eax_2560 != 0x7FFFFFFF)
													{
														ebp_106->tFFFFF770 = (word32) eax_2560 + 1;
														goto l0807EF86;
													}
													goto l0807D5B3;
												}
											}
											struct Eq_91987 * esp_2519 = esp_1696 - 0x08;
											esp_2519->tFFFFFFFC = eax_2501;
											esp_2519->tFFFFFFF8 = ebp_106->tFFFFF760;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_2 stackArg8 = <invalid>;
											esp_1019 = (char *) &esp_2519->tFFFFFFFC + 0x0C;
											if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
												goto l0807D5B3;
											goto l0807EF6C;
										}
										struct Eq_91262 * eax_2345 = *((word32) ebp_106->tFFFFF760 + 88);
										if (eax_2345 != null)
										{
											Eq_2 edx_2349 = eax_2345->t0010;
											if (edx_2349 < eax_2345->t0014)
											{
												eax_2345->t0010 = (word32) edx_2349 + 4;
												edx_2349->u0 = 0x2E;
												goto l0807ECA0;
											}
										}
										struct Eq_91756 * esp_2358 = esp_1696 - 0x08;
										esp_2358->dwFFFFFFFC = 0x2E;
										esp_2358->tFFFFFFF8 = ebp_106->tFFFFF760;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg8 = <invalid>;
										esp_1019 = &esp_2358->dwFFFFFFFC + 3;
										if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
											goto l0807D5B3;
										ecx_2340 = (uint32) *esi_1119;
l0807ECA0:
										ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
										Eq_2 eax_2407 = &ebp_106->tFFFFF7B8;
										ebp_106->tFFFFF774 = eax_2407;
										Eq_2 ebx_2413 = eax_2407;
										while (true)
										{
											uint32 edx_2420 = SLICE(ecx_2340 *64 ~0x33333332, word32, 32);
											ebx_2413 -= 0x04;
											edi_104 = *((word32) ebp_106->tFFFFF764 + ((ecx_2340 - ((edx_2420 >> 0x03) + (edx_2420 >> 0x03) * 0x04) * 0x02) * 0x04 - 88256));
											*ebx_2413 = edi_104;
											if (ecx_2340 <= 0x09)
												break;
											ecx_2340 = edx_2420 >> 0x03;
										}
										if (ebx_2413 >= ebp_106->tFFFFF774)
											goto l0807EF37;
										ebp_106->tFFFFF768 = esi_1119;
										Eq_2 esi_2439 = ebp_106->tFFFFF770;
l0807ED46:
										esp_1019 = esp_1696;
										ebx_2413 = (word32) ebx_2413 + 4;
										struct Eq_91262 * eax_2445 = *((word32) ebp_106->tFFFFF760 + 88);
										if (eax_2445 != null)
										{
											Eq_2 edx_2449 = eax_2445->t0010;
											if (edx_2449 < eax_2445->t0014)
											{
												eax_2445->t0010 = (word32) edx_2449 + 4;
												*edx_2449 = edi_104;
												ecx_1016 = (word32) edx_2449 + 4;
												if (edi_104 == ~0x00)
													goto l0807D5B3;
l0807ED29:
												esp_1019 = esp_1696;
												if (esi_2439 == 0x7FFFFFFF)
													goto l0807D5B3;
												esi_2439 = (word32) esi_2439 + 1;
												if (ebx_2413 < ebp_106->tFFFFF774)
												{
													edi_104 = *ebx_2413;
													goto l0807ED46;
												}
												ebp_106->tFFFFF770 = esi_2439;
												esi_1119 = ebp_106->tFFFFF768;
												goto l0807EF37;
											}
										}
										struct Eq_91908 * esp_2460 = esp_1696 - 0x08;
										esp_2460->tFFFFFFFC = edi_104;
										esp_2460->tFFFFFFF8 = ebp_106->tFFFFF760;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg8 = <invalid>;
										esp_1019 = (char *) &esp_2460->tFFFFFFFC + 0x0C;
										if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
											goto l0807D5B3;
										goto l0807ED29;
									}
									Eq_2 eax_2253 = &ebp_106->tFFFFF7B8;
									ebp_106->tFFFFF774 = eax_2253;
									Eq_2 ebx_2255 = eax_2253;
									while (true)
									{
										uint32 edx_2262 = SLICE(ecx_2248 *64 ~0x33333332, word32, 32);
										ebx_2255 -= 0x04;
										edi_104 = *((word32) ebp_106->tFFFFF764 + ((ecx_2248 - ((edx_2262 >> 0x03) + (edx_2262 >> 0x03) * 0x04) * 0x02) * 0x04 - 88256));
										*ebx_2255 = edi_104;
										if (ecx_2248 <= 0x09)
											break;
										ecx_2248 = edx_2262 >> 0x03;
									}
									if (ebx_2255 >= ebp_106->tFFFFF774)
										goto l0807EC6C;
									ebp_106->tFFFFF768 = esi_1119;
									Eq_2 esi_2280 = ebp_106->tFFFFF770;
l0807E91A:
									esp_1019 = esp_1696;
									ebx_2255 = (word32) ebx_2255 + 4;
									struct Eq_91262 * eax_2286 = *((word32) ebp_106->tFFFFF760 + 88);
									if (eax_2286 != null)
									{
										Eq_2 edx_2290 = eax_2286->t0010;
										if (edx_2290 < eax_2286->t0014)
										{
											eax_2286->t0010 = (word32) edx_2290 + 4;
											*edx_2290 = edi_104;
											ecx_1016 = (word32) edx_2290 + 4;
											if (edi_104 == ~0x00)
												goto l0807D5B3;
l0807E909:
											esi_2280 = (word32) esi_2280 + 1;
											if (ebx_2255 < ebp_106->tFFFFF774)
											{
												edi_104 = *ebx_2255;
												goto l0807E91A;
											}
											ebp_106->tFFFFF770 = esi_2280;
											esi_1119 = ebp_106->tFFFFF768;
											goto l0807EC6C;
										}
									}
									struct Eq_91831 * esp_2301 = esp_1696 - 0x08;
									esp_2301->tFFFFFFFC = edi_104;
									esp_2301->tFFFFFFF8 = ebp_106->tFFFFF760;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg8 = <invalid>;
									esp_1019 = (char *) &esp_2301->tFFFFFFFC + 0x0C;
									if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
										goto l0807D5B3;
									goto l0807E909;
								}
								struct Eq_91262 * eax_2192 = *((word32) ebp_106->tFFFFF760 + 88);
								if (eax_2192 != null)
								{
									Eq_2 edx_2196 = eax_2192->t0010;
									if (edx_2196 < eax_2192->t0014)
									{
										eax_2192->t0010 = (word32) edx_2196 + 4;
										edx_2196->u0 = 0x49;
l0807E879:
										ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
										goto l0807E880;
									}
								}
								struct Eq_91590 * esp_2202 = esp_1696 - 0x08;
								esp_2202->dwFFFFFFFC = 0x49;
								esp_2202->tFFFFFFF8 = ebp_106->tFFFFF760;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg8 = <invalid>;
								esp_1019 = &esp_2202->dwFFFFFFFC + 3;
								if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
									goto l0807D5B3;
								goto l0807E879;
							}
							struct Eq_91262 * eax_2131 = *((word32) ebp_106->tFFFFF760 + 88);
							if (eax_2131 != null)
							{
								Eq_2 edx_2135 = eax_2131->t0010;
								if (edx_2135 < eax_2131->t0014)
								{
									eax_2131->t0010 = (word32) edx_2135 + 4;
									edx_2135->u0 = 0x30;
l0807F098:
									ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
									goto l0807E84A;
								}
							}
							*((word32) esp_1696 - 0x0C) = 0x30;
							*((word32) esp_1696 - 16) = ebp_106->tFFFFF760;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							esp_1019 = esp_1696;
							if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
								goto l0807D5B3;
							goto l0807F098;
						}
						struct Eq_91262 * eax_2072 = *((word32) ebp_106->tFFFFF760 + 88);
						if (eax_2072 != null)
						{
							Eq_2 edx_2076 = eax_2072->t0010;
							if (edx_2076 < eax_2072->t0014)
							{
								eax_2072->t0010 = (word32) edx_2076 + 4;
								edx_2076->u0 = 0x2D;
l0807E839:
								ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
								goto l0807E840;
							}
						}
						*((word32) esp_1696 - 0x0C) = 0x2D;
						*((word32) esp_1696 - 16) = ebp_106->tFFFFF760;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1019 = esp_1696;
						if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
							goto l0807D5B3;
						goto l0807E839;
					}
					eax_1762 = (struct Eq_91262 *) *((word32) ebp_106->tFFFFF760 + 88);
					if (eax_1762 == null)
					{
l0807F313:
						struct Eq_91518 * esp_1907 = esp_1696 - 0x08;
						esp_1907->dwFFFFFFFC = 0x27;
						esp_1907->tFFFFFFF8 = ebp_106->tFFFFF760;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1019 = &esp_1907->dwFFFFFFFC + 3;
						if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
							goto l0807D5B3;
						goto l0807EFE8;
					}
l0807EFD0:
					Eq_2 edx_1901 = eax_1762->t0010;
					if (edx_1901 < eax_1762->t0014)
					{
						eax_1762->t0010 = (word32) edx_1901 + 4;
						edx_1901->u0 = 0x27;
l0807EFE8:
						ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
						edx_1831 = (word32) *((word32) esi_1119 + 0x0C);
						goto l0807E7CE;
					}
					goto l0807F313;
				}
				ecx_1826 = eax_1762->t0010;
				ebx_1767 = eax_1762->t0014;
l0807E7A4:
				if (ebx_1767 > ecx_1826)
				{
					ebp_106->tFFFFF770.u0 = 0x02;
					eax_1762->t0010 = (word32) ecx_1826 + 4;
					ecx_1826->u0 = 0x23;
					edx_1831 = (word32) *((word32) esi_1119 + 0x0C);
					if ((byte) edx_1831 >= 0x00)
						goto l0807E7CE;
					goto l0807EFD0;
				}
				goto l0807F2D0;
			}
			esp_1354->tFFFFFFFC = ebx_1356;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edi_4268;
			word32 ebp_4266;
			word32 esi_4267;
			word32 ebx_4265;
			Eq_2 eax_1401 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187, out ebx_4265, out ebp_4266, out esi_4267, out edi_4268);
			ebp_106->tFFFFF76C = eax_1401;
			esp_1019 = (char *) &esp_1354->tFFFFFFFC + 16;
			if (eax_1401 != 0x00)
			{
				ui32 eax_1413;
				if (ebp_106->tFFFFF774 < edi_104)
					eax_1413 = edi_104 * 0x04 + 0x80;
				else
					eax_1413 = ebp_106->tFFFFF774 * 0x04 + 0x80;
				ebp_106->tFFFFF740 = (word32) ebp_106->tFFFFF76C + eax_1413;
l0807D46E:
				ecx_1423 = ebp_106->tFFFFF770;
				if (ecx_1423 <= 0xFF)
					goto l0807D480;
				goto l0807D354;
			}
			goto l0807D5D8;
		}
	}
	else if (ebp_106->tFFFFF774 == 0x00)
		goto l0807DC77;
	ebp_106->tFFFFF740 = edi_104;
	Eq_2 esi_335 = ebp_106->tFFFFF758;
	edi_104 = ebp_106->tFFFFF74C;
	ebp_106->tFFFFF768.u0 = 0.0F;
	Eq_2 ebx_336 = 0x00;
	Eq_2 esi_341 = esi_335;
	do
	{
		Eq_2 eax_345 = *((word32) ecx_1016 + ebx_336 * 0x04);
		if (eax_345 <= 0x05)
		{
			if (eax_345 >= 0x03 || (eax_345 > 0x01 || eax_345 >= 0x00))
				goto l0807D3C8;
			if (eax_345 != ~0x00)
				goto l0807D3C0;
			if ((*((word32) ebp_106->tFFFFF760 + 60) & 0x04) == 0x00)
			{
				Eq_2 esi_362 = ebp_106->tFFFFF764;
				struct Eq_90200 * esp_365 = esp_1019 - 4;
				esp_365->dw0000 = (word32) esi_362 - 0x0001C23C;
				esp_365->dwFFFFFFFC = 1887;
				esp_365->dwFFFFFFF8 = (word32) esi_362 - 0x0001C322;
				esp_365->dwFFFFFFF4 = (word32) esi_362 - 115456;
				word32 ecx_4263;
				__assert_fail(out ecx_4263, out edx_1187);
				esp_1019 = esp_365 - 0x0C;
				esi_1119 = esi_362;
				goto l0807D458;
			}
			struct Eq_90229 * esp_385 = esp_1019 - 0x0C;
			esp_385->dwFFFFFFFC = (word32) ebp_106->tFFFFF764 - 115424;
			esp_1019 = esp_385 - 4;
			eax_345 = __libc_fatal(out ecx_1016);
		}
		if (eax_345 != 0x0100)
		{
			if (eax_345 > 0x0100)
			{
				if (eax_345 == 0x0200 || eax_345 == 0x0400)
					goto l0807D3C8;
				if (eax_345 != 0x0107)
					goto l0807D3C0;
				real80 * eax_555 = *edi_104.u0;
				real64 rLoc1_2951 = (real64) *eax_555;
				*edi_104.u0 = (char *) eax_555 + 0x0C;
				esi_341->u4 = (real80) rLoc1_2951;
				edx_1187 = (char *) eax_555 + 0x0C;
			}
			else if (eax_345 <= 0x07)
			{
				union Eq_92834 * eax_411 = *edi_104.u0;
				*edi_104.u0 = (char *) eax_411 + 8;
				*esi_341 = *eax_411;
				edx_1187 = (char *) eax_411 + 8;
			}
			else
			{
l0807D3C0:
				if ((SLICE(eax_345, byte, 8) & 0x08) != 0x00)
				{
l0807D3C8:
					word32 * eax_549 = *edi_104.u0;
					*edi_104.u0 = eax_549 + 1;
					*esi_341 = *eax_549;
					edx_1187 = eax_549 + 1;
				}
				else
				{
					edx_1187 = *((word32) ebp_106->tFFFFF764 + 8172);
					ebp_106->tFFFFF74C = edx_1187;
					if (edx_1187 == 0x00 || *((word32) (edx_1187 - 0x20) + eax_345 * 0x04) == 0x00)
						esi_341->u4 = (real80) ebp_106->tFFFFF768;
					else
					{
						word32 eax_451 = *((word32) ebp_106->tFFFFF76C + ebx_336 * 0x04);
						ebp_106->tFFFFF734 = eax_451 + 0x1B & ~0x0F;
						Eq_2 edx_460 = esp_1019 - (eax_451 + 0x1B & ~0x0FFF);
						Eq_2 edx_462 = ebp_106->tFFFFF74C;
						while (esp_1019 != edx_460)
						{
							esp_1019 -= 0x1000;
							*((word32) esp_1019 + 0x0FFC) = *((word32) esp_1019 + 0x0FFC);
						}
						ebp_106->tFFFFF74C = edx_462;
						Eq_2 eax_479 = ebp_106->tFFFFF734;
						if ((eax_479 & 0x0FFF) != 0x00)
						{
							esp_1019 -= eax_479 & 0x0FFF;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_479 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_479 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						ebp_106->tFFFFF734 = ecx_1016;
						Eq_90628 eax_491 = (word32) esp_1019 + 0x0F;
						*esi_341 = eax_491 & ~0x0F;
						struct Eq_90636 * esp_492 = esp_1019 - 0x08;
						Eq_2 edx_511 = *((word32) ecx_1016 + ebx_336 * 0x04);
						esp_492->tFFFFFFFC = edi_104;
						esp_492->dwFFFFFFF8 = eax_491 & ~0x0F;
						Eq_2 eax_520 = ebp_106->tFFFFF74C;
						(eax_520 - 0x20)[edx_511]();
						ecx_1016 = ebp_106->tFFFFF734;
						esp_1019 = (char *) &esp_492->tFFFFFFFC + 0x0C;
					}
				}
			}
		}
		else
		{
			struct Eq_92172 * eax_400 = *edi_104.u0;
			*edi_104.u0 = (char *) &eax_400->t0004 + 4;
			edx_1187 = eax_400->t0004;
			word32 eax_404 = eax_400->dw0000;
			*((word32) esi_341 + 4) = edx_1187;
			*esi_341 = eax_404;
		}
		ebx_336 = (word32) ebx_336 + 1;
		esi_341 = (word32) esi_341 + 0x0C;
	} while (ebx_336 < ebp_106->tFFFFF774);
	edi_104 = ebp_106->tFFFFF740;
	goto l0807D128;
}

// 0807F7D0: Register Eq_92839 __vfwprintf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_12083 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      locked_vfxprintf
//      buffered_vfprintf
Eq_92839 __vfwprintf(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_12083 & ecxOut, union Eq_2 & edxOut)
{
	ptr32 fp;
	struct Eq_9 * gs;
	Eq_2 dwArg08;
	Eq_2 dwArg04;
	Eq_2 dwArg0C;
	word32 dwLoc0494;
	word32 dwLoc04A0;
	word32 dwLoc0480;
	word32 dwLoc047C;
	word32 dwLoc0484;
	word32 dwLoc04B8;
	word32 dwLoc0450;
	word32 dwLoc04A4;
	word32 dwLoc04D0;
	word32 dwLoc04D8;
	word32 dwLoc04C0;
	word32 dwLoc0478;
	word32 dwLoc0470;
	esi_21 = dwArg04;
	eax_26 = gs->t0014;
	eax_33 = gs->tFFFFFFE0;
	eax_39 = _IO_fwide(gs, dwArg04, 0x01, out ecx_41, out edx_40, out ebp_1926, out esi_1927);
	esp_43 = fp - 0x04FC;
	if (eax_39 == 0x01)
	{
		eax_46 = (ui32) *dwArg04;
		al_47 = (byte) eax_46;
		if ((al_47 & 0x08) == 0x00)
		{
			if (dwArg08 == 0x00)
			{
				edi_62.u0 = ~0x00;
				gs->tFFFFFFE0.u0 = 22;
				goto l0807FB6B;
			}
			eax_70 = _IO_fwide(gs, dwArg04, 0x01, out ecx_72, out edx_71, out ebp_1928, out esi_1929);
			esp_74 = fp - 0x04FC;
			if (eax_70 == 0x01)
			{
				edi_78 = (ui32) *dwArg04;
				dwLoc0474_1029 = edi_78 & 0x02;
				if ((edi_78 & 0x02) != 0x00)
				{
					eax_88 = buffered_vfprintf(dwArg04, dwArg0C, dwArg08, gs, out ecx_90, out edx_89);
					edi_92 = eax_88;
					goto l0807FB6B;
				}
				eax_102 = wcschrnul(dwArg08, 0x25);
				dwLoc0478_1033 = eax_102;
				dwLoc0450_1034 = eax_102;
				dwLoc0470_1035 = edi_78 & 0x8000;
				if ((edi_78 & 0x8000) != 0x00)
					dwLoc0470_1042.u0 = 0x00;
				else
				{
					dwLoc0470_1757 = ϕ(dwLoc0470_1041, dwLoc0470_1035);
					Mem144 = ϕ(Mem141, Mem123);
					edx_145 = *((word32) dwArg04 + 72);
					edi_147 = gs->t0008;
					if (*((word32) edx_145 + 8) != edi_147)
					{
						if (gs->t000C != 0x00)
							__lock();
						Z_159 = __cmpxchg(*edx_145, 0x01, 0x00, out eax_158);
						if (!Z_159)
							__lll_lock_wait_private(eax_158, edx_145, gs);
						edx_171 = *((word32) dwArg04 + 72);
						*((word32) edx_171 + 8) = edi_147;
					}
					Mem176 = ϕ(Mem144, Mem174);
					edx_175 = ϕ(edx_145, edx_171);
					v39_177 = (word32) *((word32) edx_175 + 4) + 1;
					*((word32) edx_175 + 4) = v39_177;
				}
				dwLoc0470_1755 = ϕ(dwLoc0470_1042, dwLoc0470_1041, dwLoc0470_1757);
				Mem185 = ϕ(Mem180, Mem141, Mem178);
				edx_186 = *((word32) dwArg04 + 0x0094);
				dwLoc0480_1043 = 0x080CEFA0;
				dwLoc047C_1044 = 0x0354;
				if (edx_186 >= 135066356)
				{
					dwLoc0484_1045 = edx_186;
					_IO_vtable_check(out ecx_1930, out edx_1931);
				}
				dwLoc0484_1554 = ϕ(dwLoc0484_1045, dwLoc0484);
				eax_230 = eax_102 - dwArg08;
				edi_235 = eax_230 >> 0x02;
				(*((word32) edx_186 + 28))();
				esp_249 = fp - 0x04FC;
				if (eax_230 >> 0x02 != eax_245)
				{
l0807FBD8:
					edx_1897 = ϕ(edx_246, edx_316, edx_1898, edx_944, edx_792);
					dwLoc0478_1874 = ϕ(dwLoc0478_1033, dwLoc0478_1875, dwLoc0478_1875, dwLoc0478_1477, dwLoc0478_1477);
					dwLoc04C0_1867 = ϕ(dwLoc04C0, dwLoc04C0_1868, dwLoc04C0_1868, dwLoc04C0_1431, dwLoc04C0_1431);
					dwLoc04D8_1854 = ϕ(dwLoc04D8, dwLoc04D8_1855, dwLoc04D8_1855, dwLoc04D8_1391, dwLoc04D8_1391);
					dwLoc04D0_1845 = ϕ(dwLoc04D0, dwLoc04D0_1846, dwLoc04D0_1846, dwLoc04D0_1371, dwLoc04D0_1371);
					dwLoc04A4_1836 = ϕ(dwLoc04A4, dwLoc04A4_1837, dwLoc04A4_1837, dwLoc04A4_1326, dwLoc04A4_1323);
					dwLoc0450_1833 = ϕ(dwLoc0450_1034, dwLoc0450_1834, dwLoc0450_1834, dwLoc0450_1266, dwLoc0450_1314);
					dwLoc04B8_1830 = ϕ(dwLoc04B8, dwLoc04B8_1831, dwLoc04B8_1831, dwLoc04B8_1243, dwLoc04B8_1312);
					dwLoc0484_1829 = ϕ(dwLoc0484_1554, dwLoc0484_1097, dwLoc0484_1097, dwLoc0484_1603, dwLoc0484_1340);
					dwLoc047C_1817 = ϕ(dwLoc047C_1044, dwLoc047C_1818, dwLoc047C_1818, dwLoc047C_1160, dwLoc047C_1160);
					dwLoc0480_1814 = ϕ(dwLoc0480_1043, dwLoc0480_1815, dwLoc0480_1815, dwLoc0480_1152, dwLoc0480_1152);
					dwLoc0494_1808 = ϕ(dwLoc0494, dwLoc0494_1809, dwLoc0494_1809, dwLoc0494_1141, dwLoc0494_1141);
					dwLoc0470_1778 = ϕ(dwLoc0470_1755, dwLoc0470_1779, dwLoc0470_1779, dwLoc0470_1764, dwLoc0470_1764);
					esp_1010 = ϕ(esp_249, esp_319, esp_305, esp_948, esp_795);
					ecx_1006 = ϕ(ecx_247, ecx_317, ecx_1007, ecx_950, ecx_796);
					Mem1004 = ϕ(Mem240, Mem310, Mem300, Mem945, Mem799);
					esi_1003 = ϕ(esi_21, esi_321, esi_311, esi_399, esi_399);
					edi_322.u0 = ~0x00;
					goto l0807FB48;
				}
				else
				{
					edx_252 = eax_102;
					ecx_253 = *eax_102;
					if (ecx_253 == 0x00)
					{
l0807FB48:
						edx_1896 = ϕ(edx_252, edx_944, edx_944, edx_883, edx_1897);
						dwLoc0478_1481 = ϕ(dwLoc0478_1033, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1469, dwLoc0478_1874);
						dwLoc04C0_1435 = ϕ(dwLoc04C0, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1423, dwLoc04C0_1867);
						dwLoc04D8_1395 = ϕ(dwLoc04D8, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1383, dwLoc04D8_1854);
						dwLoc04D0_1375 = ϕ(dwLoc04D0, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1363, dwLoc04D0_1845);
						dwLoc04A4_1332 = ϕ(dwLoc04A4, dwLoc04A4_1326, dwLoc04A4_1326, dwLoc04A4_1570, dwLoc04A4_1836);
						dwLoc0450_1258 = ϕ(dwLoc0450_1034, dwLoc0450_1266, dwLoc0450_1266, dwLoc0450_1568, dwLoc0450_1833);
						dwLoc04B8_1237 = ϕ(dwLoc04B8, dwLoc04B8_1243, dwLoc04B8_1243, dwLoc04B8_1560, dwLoc04B8_1830);
						dwLoc0484_1225 = ϕ(dwLoc0484_1554, dwLoc0484_1603, dwLoc0484_1603, dwLoc0484_1552, dwLoc0484_1829);
						dwLoc047C_1164 = ϕ(dwLoc047C_1044, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1549, dwLoc047C_1817);
						dwLoc0480_1156 = ϕ(dwLoc0480_1043, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1546, dwLoc0480_1814);
						dwLoc0494_1138 = ϕ(dwLoc0494, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1530, dwLoc0494_1808);
						dwLoc0470_1102 = ϕ(dwLoc0470_1755, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1770, dwLoc0470_1778);
						edi_370 = ϕ(edi_235, edi_961, edi_958, edi_888, edi_322);
						esp_359 = ϕ(esp_249, esp_948, esp_948, esp_886, esp_1010);
						ecx_345 = ϕ(ecx_253, ecx_950, ecx_950, ecx_884, ecx_1006);
						Mem324 = ϕ(Mem240, Mem945, Mem959, Mem875, Mem1004);
						esi_323 = ϕ(esi_21, esi_399, esi_399, esi_889, esi_1003);
						if ((*esi_323 & 0x8000) == 0x00)
						{
							edx_328 = *((word32) esi_323 + 72);
							v18_329 = *((word32) edx_328 + 4) - 0x01;
							*((word32) edx_328 + 4) = v18_329;
							if (v18_329 == 0x00)
							{
								((word32) edx_328 + 8)->u0 = 0x00;
								if (gs->t000C != 0x00)
									__lock();
								v29_339 = *edx_328 - 0x01;
								*edx_328 = v29_339;
								if (v29_339 != 0x00)
									__lll_unlock_wake_private(edx_328, ecx_345, edx_328, gs);
							}
						}
						edx_1895 = ϕ(edx_1896, edx_328, edx_328);
						Mem352 = ϕ(Mem324, Mem330, Mem340);
						ecx_354 = dwLoc0470_1102;
						if (dwLoc0470_1102 != 0x00)
						{
							esp_362 = esp_359 - 0x08;
							esp_362->dwFFFFFFFC = 0x00;
							esp_362->ptrFFFFFFF8 = fp - 0x0434;
							fn00000000();
							esp_390 = &esp_362->dwFFFFFFFC + 3;
						}
l0807FB6B:
						edx_1893 = ϕ(edx_1894, edx_89, edx_1895, edx_387, edx_40);
						ecx_1889 = ϕ(ecx_1890, ecx_90, ecx_354, ecx_388, ecx_41);
						dwLoc0470_1764 = ϕ(dwLoc0470, dwLoc0470, dwLoc0470_1102, dwLoc0470_1102, dwLoc0470);
						dwLoc0478_1477 = ϕ(dwLoc0478, dwLoc0478, dwLoc0478_1481, dwLoc0478_1481, dwLoc0478);
						dwLoc04C0_1431 = ϕ(dwLoc04C0, dwLoc04C0, dwLoc04C0_1435, dwLoc04C0_1435, dwLoc04C0);
						dwLoc04D8_1391 = ϕ(dwLoc04D8, dwLoc04D8, dwLoc04D8_1395, dwLoc04D8_1395, dwLoc04D8);
						dwLoc04D0_1371 = ϕ(dwLoc04D0, dwLoc04D0, dwLoc04D0_1375, dwLoc04D0_1375, dwLoc04D0);
						dwLoc04A4_1328 = ϕ(dwLoc04A4, dwLoc04A4, dwLoc04A4_1332, dwLoc04A4_1332, dwLoc04A4);
						dwLoc0450_1254 = ϕ(dwLoc0450, dwLoc0450, dwLoc0450_1258, dwLoc0450_1258, dwLoc0450);
						dwLoc04B8_1233 = ϕ(dwLoc04B8, dwLoc04B8, dwLoc04B8_1237, dwLoc04B8_1237, dwLoc04B8);
						dwLoc0484_1221 = ϕ(dwLoc0484, dwLoc0484, dwLoc0484_1225, dwLoc0484_1225, dwLoc0484);
						dwLoc047C_1160 = ϕ(dwLoc047C, dwLoc047C, dwLoc047C_1164, dwLoc047C_1164, dwLoc047C);
						dwLoc0480_1152 = ϕ(dwLoc0480, dwLoc0480, dwLoc0480_1156, dwLoc0480_1156, dwLoc0480);
						dwLoc0494_1134 = ϕ(dwLoc0494, dwLoc0494, dwLoc0494_1138, dwLoc0494_1138, dwLoc0494);
						esp_407 = ϕ(esp_408, esp_74, esp_359, esp_390, esp_43);
						edi_402 = ϕ(edi_77, edi_92, edi_370, edi_370, edi_62);
						Mem394 = ϕ(Mem395, Mem83, Mem352, Mem368, Mem63);
						esi_399 = eax_26 ^ gs->t0014;
						eax_403 = edi_402;
						if (esi_399 == 0x00)
						{
							ecxOut = ecx_1889;
							edxOut = edx_1893;
							return eax_403;
						}
						__stack_chk_fail(out ecx_413, out edx_412);
						esp_415 = esp_407 - 0x0C;
						dwLoc0474_1129 = edx_412;
						nLoc0473_1320 = SLICE(edx_412, word24, 8);
						esp_415->tFFFFFFFC = ecx_413;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg4.u0 = <invalid>;
						eax_420 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_422, out edx_421, out ebx_1934, out ebp_1935, out esi_1936, out edi_1937);
						esp_424 = &esp_415->ptr0008 + 1;
						if (eax_420 != 0x00)
						{
							esp_415->ptr0008 = fp - 0x0410;
							esp_415->t0004 = edx_412;
							esp_415->t0000 = fp - 0x0424;
							esp_415->tFFFFFFFC = eax_420;
							eax_444 = __mbsrtowcs(gs, dwArg0C, out ecx_446);
							esp_448 = &esp_415->ptr0008 + 1;
							edx_449 = eax_444;
							if (eax_444 != ~0x00)
							{
								v21_452 = dwLoc0494_1134 - eax_444;
								dwLoc0494_1141 = v21_452;
								if (v21_452 < 0x00)
								{
									if (edi_402 >= 0x00)
									{
										eax_626 = *((word32) esi_399 + 0x0094);
										ecx_628 = eax_626 - dwLoc0480_1152;
										if (dwLoc047C_1160 <= ecx_628)
											_IO_vtable_check(out ecx_1949, out edx_1950);
										esp_415->t0004 = eax_444;
										esp_415->t0000 = eax_420;
										esp_415->tFFFFFFFC = esi_399;
										(*((word32) eax_626 + 28))();
										edx_662 = eax_444;
										esp_663 = &esp_415->ptr0008 + 1;
										if (eax_444 == eax_658)
										{
											eax_667 = 0x7FFFFFFF - edi_402;
											if (eax_444 <= eax_667)
												edi_675 = edi_402 + eax_444;
											goto l080811B8;
										}
										goto l0807FBB8;
									}
									goto l080822AB;
								}
								bLoc0474_1149 = (int8) (v21_452 != 0x00);
								eax_461 = (word32) bLoc0474_1149;
								al_465 = (byte) eax_461;
								if (dwLoc04A0 != 0x00 || al_465 == 0x00)
								{
l08081248:
									Mem501 = ϕ(Mem460, Mem460, Mem478);
									edi_496 = ϕ(edi_402, edi_402, edi_494);
									dwLoc0474_1321 = SEQ(nLoc0473_1320, bLoc0474_1149);
									if (edi_496 < 0x00)
									{
l080822AB:
										dwLoc0474_1318 = ϕ(dwLoc0474_1129, dwLoc0474_1321);
										edi_745 = ϕ(edi_402, edi_496);
										esp_622 = esp_407 - 4;
										esp_622->ptr0000 = 0x080B1F94;
										esp_624 = esp_622 - 4;
										esp_622->dwFFFFFFFC = 0x0666;
										dwLoc04A4_1324 = ϕ(dwLoc04A4_1326, dwLoc04A4_1328);
										dwLoc0474_1317 = ϕ(dwLoc0474_1264, dwLoc0474_1318);
										dwLoc0450_1294 = ϕ(dwLoc0450_1266, dwLoc0450_1254);
										dwLoc04B8_1291 = ϕ(dwLoc04B8_1243, dwLoc04B8_1233);
										edi_744 = ϕ(edi_691, edi_745);
										esp_736 = ϕ(esp_732, esp_624);
										esp_737 = esp_736 - 4;
										esp_737->ptr0000 = 134946014;
										esp_737->ptrFFFFFFFC = 134946164;
										__assert_fail(out ecx_1957, out edx_1958);
										esp_737->ptrFFFFFFF8 = 0x080B1F94;
										esp_737->dwFFFFFFF4 = 0x0665;
l080821E5:
										dwLoc04A4_1323 = ϕ(dwLoc04A4_1324, dwLoc04A4_1339);
										dwLoc0474_1316 = ϕ(dwLoc0474_1317, dwLoc0474_1322);
										dwLoc0450_1314 = ϕ(dwLoc0450_1294, dwLoc0450_1254);
										dwLoc04B8_1312 = ϕ(dwLoc04B8_1291, dwLoc04B8_1233);
										edi_774 = ϕ(edi_744, edi_775);
										__assert_fail(out ecx_1976, out edx_1977);
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										stackArg0.u0 = <invalid>;
										eax_791 = __libc_malloc(gs, stackArg0, dwLoc0474_1316, out ecx_1979, out edx_792, out ebx_1980, out ebp_1981, out esi_1982, out edi_1983);
										esp_795 = fp;
										ecx_796 = dwLoc04A4_1323;
										dwLoc0484_1340 = eax_791;
										if (eax_791 != 0x00)
										{
											eax_802 = dwLoc0474_1316 + eax_791;
											dwLoc04A4_1341 = eax_802;
											edx_806 = *dwLoc0450_1314;
											if (edx_806 != 0x24)
											{
												if (edx_806 > 122 || edx_806 < 0x20)
												{
													g_t807FB92();
													ecxOut = ecx_899;
													edxOut = edx_898;
													return eax_897;
												}
												else
												{
													eax_902 = (word32) *((word32) edx_806 + (eax_420 - 0x20));
													((<anonymous> *[]) 0x080CCEC0)[eax_902]();
													ecxOut = ecx_905;
													edxOut = edx_904;
													return eax_903;
												}
											}
											goto l0807FD80;
										}
										goto l0807FBD8;
									}
									eax_502 = *((word32) esi_399 + 0x0094);
									ecx_505 = eax_502 - dwLoc0480_1152;
									if (dwLoc047C_1160 <= ecx_505)
									{
										dwLoc04A4_1167 = eax_502;
										_IO_vtable_check(out ecx_1965, out edx_1966);
									}
									dwLoc04A4_1336 = ϕ(dwLoc04A4_1328, dwLoc04A4_1167);
									esp_522 = esp_407 - 0x04;
									esp_522->tFFFFFFFC = eax_444;
									esp_522->tFFFFFFF8 = eax_420;
									esp_522->tFFFFFFF4 = esi_399;
									(*((word32) eax_502 + 28))();
									edx_544 = eax_444;
									esp_545 = (char *) &esp_522->tFFFFFFFC + 8;
									if (eax_444 == eax_540)
									{
										ecx_548.u0 = 0x7FFFFFFF;
										eax_550 = 0x7FFFFFFF - edi_496;
										if (eax_444 > eax_550)
											goto l080811B8;
										edi_554 = edi_496 + eax_444;
										if (dwLoc04A0 == 0x00 || bLoc0474_1149 == 0x00)
										{
l080812B9:
											edi_605 = ϕ(edi_554, edi_554, edi_591);
											esp_600 = esp_407 - 0x0C;
											esp_600->tFFFFFFFC = eax_420;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											stackArg0.u0 = <invalid>;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											stackArg4.u0 = <invalid>;
											free(gs, stackArg0, stackArg4, out ecx_1974, out edx_1975);
										}
										esp_522->tFFFFFFFC = v21_452;
										esp_522->tFFFFFFF8.u0 = 0x20;
										esp_522->tFFFFFFF4 = esi_399;
										dwLoc0474_1186.u0 = 0x7FFFFFFF;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										stackArg4.u0 = <invalid>;
										eax_570 = _IO_wpadn(gs, stackArg4, dwArg04, dwArg08, out ecx_572, out edx_571, out ebx_1968, out ebp_1969, out esi_1970, out edi_1971);
										esp_574 = (char *) &esp_522->tFFFFFFFC + 8;
										if (v21_452 == eax_570)
										{
											if (edi_554 <= 0x7FFFFFFE)
											{
												ecx_586.u0 = 0x7FFFFFFF;
												edx_588 = 0x7FFFFFFF - edi_554;
												if (edx_588 >= v21_452)
												{
													edi_591 = edi_554 + v21_452;
													goto l080812B9;
												}
												goto l080811B8;
											}
											goto l0808229A;
										}
									}
									goto l0807FBB8;
								}
								esp_415->t0004 = v21_452;
								esp_415->t0000.u0 = 0x20;
								esp_415->tFFFFFFFC = esi_399;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								stackArg4.u0 = <invalid>;
								eax_479 = _IO_wpadn(gs, stackArg4, dwArg04, dwArg08, out ecx_1960, out edx_480, out ebx_1961, out ebp_1962, out esi_1963, out edi_1964);
								ecx_483 = v21_452;
								esp_484 = &esp_415->ptr0008 + 1;
								if (v21_452 == eax_479)
								{
									if (edi_402 > 0x7FFFFFFE)
									{
l0808229A:
										dwLoc04A4_1339 = ϕ(dwLoc04A4_1336, dwLoc04A4_1328);
										dwLoc0474_1322 = ϕ(dwLoc0474_1186, dwLoc0474_1321);
										edi_775 = ϕ(edi_554, edi_402);
										esp_582 = esp_407 - 4;
										esp_582->ptr0000 = 0x080B1F94;
										esp_582->dwFFFFFFFC = 0x0666;
										goto l080821E5;
									}
									edx_490 = eax_444;
									eax_491 = 0x7FFFFFFF - edi_402;
									if (eax_491 < v21_452)
									{
l080811B8:
										edx_1899 = ϕ(edx_662, edx_544, edx_588, edx_490);
										dwLoc04A4_1838 = ϕ(dwLoc04A4_1328, dwLoc04A4_1336, dwLoc04A4_1336, dwLoc04A4_1328);
										ecx_1008 = ϕ(ecx_660, ecx_548, ecx_586, ecx_483);
										esp_999 = esp_407;
										gs->tFFFFFFE0.u0 = 0x4B;
										goto l0807FBB8;
									}
									edi_494 = edi_402 + v21_452;
									goto l08081248;
								}
							}
						}
						goto l0807FBB8;
					}
					eax_257 = __printf_function_table;
					if (eax_257 == null)
					{
						eax_261 = __printf_modifier_table;
						if (eax_261 == 0x00)
						{
							eax_265 = __printf_va_arg_table;
							if (eax_265 == 0x00)
							{
								dwLoc04D8_1088 = 0x00;
								dwLoc04B8_1089 = 0x00;
								dwLoc04D0_1090 = 0x00;
								dwLoc04C0_1091 = ~0x00;
								dwLoc0470_1772 = ϕ(dwLoc0470_1755, dwLoc0470_1764);
								dwLoc0478_1471 = ϕ(dwLoc0478_1033, dwLoc0478_1477);
								dwLoc04C0_1425 = ϕ(dwLoc04C0_1091, dwLoc04C0_1431);
								dwLoc04D8_1385 = ϕ(dwLoc04D8_1088, dwLoc04D8_1391);
								dwLoc04D0_1365 = ϕ(dwLoc04D0_1090, dwLoc04D0_1371);
								dwLoc04A4_1362 = ϕ(dwLoc04A4, dwLoc04A4_1326);
								dwLoc047C_1359 = ϕ(dwLoc047C_1044, dwLoc047C_1160);
								dwLoc0480_1357 = ϕ(dwLoc0480_1043, dwLoc0480_1152);
								dwLoc0494_1353 = ϕ(dwLoc0494, dwLoc0494_1141);
								dwLoc04B8_1343 = ϕ(dwLoc04B8_1089, dwLoc04B8_1243);
								edi_824 = ϕ(edi_235, edi_961);
								esp_818 = fp;
								esi_297 = ϕ(esi_21, esi_399);
								Mem280 = ϕ(Mem278, Mem945);
								edx_279 = ϕ(edx_252, edx_944);
								ecx_281 = *((word32) edx_279 + 4);
								eax_282 = (word32) edx_279 + 4;
								dwLoc0450_1093 = eax_282;
								if (ecx_281 <= 122)
								{
									eax_978 = (word32) *((word32) ecx_281 + 0x080B1FA0);
									eax_981 = ((<anonymous> *[]) 0x080CCF40)[eax_978];
									eax_981();
									ecxOut = ecx_997;
									edxOut = edx_996;
									return eax_995;
								}
								dwLoc0484_1095.u0 = 0x00;
								if (ecx_281 != 0x00)
								{
l0807FD80:
									dwLoc0470_1771 = ϕ(dwLoc0470_1772, dwLoc0470_1764);
									dwLoc0478_1470 = ϕ(dwLoc0478_1471, dwLoc0478_1477);
									dwLoc04C0_1424 = ϕ(dwLoc04C0_1425, dwLoc04C0_1431);
									dwLoc04D8_1384 = ϕ(dwLoc04D8_1385, dwLoc04D8_1391);
									dwLoc04D0_1364 = ϕ(dwLoc04D0_1365, dwLoc04D0_1371);
									dwLoc04A4_1361 = ϕ(dwLoc04A4_1362, dwLoc04A4_1341);
									dwLoc0450_1360 = ϕ(dwLoc0450_1093, dwLoc0450_1314);
									dwLoc047C_1358 = ϕ(dwLoc047C_1359, dwLoc047C_1160);
									dwLoc0480_1356 = ϕ(dwLoc0480_1357, dwLoc0480_1152);
									dwLoc0494_1352 = ϕ(dwLoc0494_1353, dwLoc0494_1141);
									dwLoc0484_1345 = ϕ(dwLoc0484_1095, dwLoc0484_1340);
									dwLoc04B8_1342 = ϕ(dwLoc04B8_1343, dwLoc04B8_1312);
									esi_825 = ϕ(esi_297, esi_399);
									edi_823 = ϕ(edi_824, edi_774);
									esp_817 = fp;
									dwLoc0474_1344 = dwLoc04B8_1342;
									if (dwLoc0484_1345 != 0x00)
									{
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										stackArg0.u0 = <invalid>;
										free(gs, stackArg0, dwLoc0484_1345, out ecx_1947, out edx_1948);
										esp_835 = fp;
									}
l0807FAF6:
									dwLoc0470_1770 = ϕ(dwLoc0470_1771, dwLoc0470_1771, dwLoc0470_1755);
									dwLoc04A4_1570 = ϕ(dwLoc04A4_1361, dwLoc04A4_1361, dwLoc04A4);
									dwLoc0450_1568 = ϕ(dwLoc0450_1360, dwLoc0450_1360, dwLoc0450_1034);
									dwLoc04B8_1560 = ϕ(dwLoc04B8_1342, dwLoc04B8_1342, dwLoc04B8);
									dwLoc0484_1552 = ϕ(dwLoc0484_1345, dwLoc0484_1345, dwLoc0484_1554);
									dwLoc047C_1549 = ϕ(dwLoc047C_1358, dwLoc047C_1358, dwLoc047C_1044);
									dwLoc0480_1546 = ϕ(dwLoc0480_1356, dwLoc0480_1356, dwLoc0480_1043);
									dwLoc0494_1530 = ϕ(dwLoc0494_1352, dwLoc0494_1352, dwLoc0494);
									dwLoc0474_1490 = ϕ(dwLoc0474_1344, dwLoc0474_1344, dwLoc0474_1029);
									dwLoc0478_1469 = ϕ(dwLoc0478_1470, dwLoc0478_1470, dwLoc0478_1033);
									dwLoc04C0_1423 = ϕ(dwLoc04C0_1424, dwLoc04C0_1424, dwLoc04C0_1087);
									dwLoc04D8_1383 = ϕ(dwLoc04D8_1384, dwLoc04D8_1384, dwLoc04D8_1086);
									dwLoc04D0_1363 = ϕ(dwLoc04D0_1364, dwLoc04D0_1364, dwLoc04D0_1085);
									esi_870 = ϕ(esi_825, esi_825, esi_21);
									edi_865 = ϕ(edi_823, edi_823, edi_235);
									esp_837 = ϕ(esp_817, esp_835, esp_249);
									esp_839 = esp_837 - 0x0C;
									esp_839->dwFFFFFFFC = dwLoc04D0_1363;
									esp_839->dwFFFFFFF8 = dwLoc04C0_1423;
									esp_839->tFFFFFFF4 = eax_33;
									esp_839->ptrFFFFFFF0 = fp - 0x0408;
									esp_839->tFFFFFFEC = dwLoc0478_1469;
									esp_839->dwFFFFFFE8 = dwLoc0474_1490;
									esp_839->tFFFFFFE4 = edi_865;
									esp_839->ptrFFFFFFE0 = fp - 1100;
									esp_839->tFFFFFFDC = dwArg0C;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg0.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg20.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg24.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg28.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg32.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg36.u0 = <invalid>;
									eax_882 = printf_positional(gs, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, out ecx_884, out edx_883);
									esp_886 = &esp_839->dwFFFFFFFC + 4;
									edi_888 = eax_882;
									esi_889 = esi_870;
									goto l0807FB48;
								}
								gs->tFFFFFFE0.u0 = 22;
								esi_298 = esi_297;
l0807FBB8:
								edx_1898 = ϕ(edx_279, edx_421, edx_449, edx_662, edx_1899, edx_544, edx_571, edx_480);
								dwLoc0478_1875 = ϕ(dwLoc0478_1471, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477);
								dwLoc04C0_1868 = ϕ(dwLoc04C0_1425, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431);
								dwLoc04D8_1855 = ϕ(dwLoc04D8_1385, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391);
								dwLoc04D0_1846 = ϕ(dwLoc04D0_1365, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371);
								dwLoc04A4_1837 = ϕ(dwLoc04A4_1362, dwLoc04A4_1328, dwLoc04A4_1328, dwLoc04A4_1328, dwLoc04A4_1838, dwLoc04A4_1336, dwLoc04A4_1336, dwLoc04A4_1328);
								dwLoc0450_1834 = ϕ(dwLoc0450_1093, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254);
								dwLoc04B8_1831 = ϕ(dwLoc04B8_1343, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233);
								dwLoc047C_1818 = ϕ(dwLoc047C_1359, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160);
								dwLoc0480_1815 = ϕ(dwLoc0480_1357, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152);
								dwLoc0494_1809 = ϕ(dwLoc0494_1353, dwLoc0494_1134, dwLoc0494_1134, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1141);
								dwLoc0470_1779 = ϕ(dwLoc0470_1772, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764);
								dwLoc0484_1097 = ϕ(dwLoc0484_1095, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221);
								ecx_1007 = ϕ(ecx_281, ecx_422, ecx_446, ecx_660, ecx_1008, ecx_542, ecx_572, ecx_483);
								esi_311 = ϕ(esi_298, esi_399, esi_399, esi_399, esi_399, esi_399, esi_399, esi_399);
								esp_305 = ϕ(esp_818, esp_424, esp_448, esp_663, esp_999, esp_545, esp_574, esp_484);
								Mem300 = ϕ(Mem296, Mem425, Mem443, Mem652, Mem674, Mem534, Mem569, Mem478);
								if (dwLoc0484_1097 != 0x00)
								{
									esp_306 = esp_305 - 0x0C;
									esp_306->tFFFFFFFC = dwLoc0484_1097;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg0.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg4.u0 = <invalid>;
									free(gs, stackArg0, stackArg4, out ecx_317, out edx_316);
									esp_319 = (char *) &esp_306->tFFFFFFFC + 16;
									esi_321 = esi_311;
								}
								goto l0807FBD8;
							}
						}
					}
					dwLoc04D0_1085 = 0x00;
					dwLoc04D8_1086 = 0x00;
					dwLoc04C0_1087 = ~0x00;
					goto l0807FAF6;
				}
			}
		}
		else
		{
			*dwArg04 = eax_46 | 0x20;
			gs->tFFFFFFE0.u0 = 0x09;
		}
	}
	edx_1894 = ϕ(edx_40, edx_71, edx_40);
	ecx_1890 = ϕ(ecx_41, ecx_72, ecx_41);
	esp_408 = fp - 0x04FC;
	Mem395 = ϕ(Mem38, Mem69, Mem56);
	edi_77.u0 = ~0x00;
	goto l0807FB6B;
}

<anonymous> g_t807FB92 = <code>; // 0807FB92
// 080822D0: Register Eq_2 buffered_vfprintf(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __vfwprintf
Eq_2 buffered_vfprintf(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	struct Eq_94081 * esp_13 = fp - 16;
	do
	{
		esp_13 = esp_454 - 0x1000;
		esp_13->dw0000 = esp_13->dw0000;
		esp_454 = esp_13;
	} while (esp_13 != fp + ~0x800F);
	esp_13->dw7FF0 = (word32) gs->t0014;
	esp_13->dwFFFFFE68 = 0x01;
	esp_13->dwFFFFFE64 = (word32) eax;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	word32 ecx_447;
	word32 ebp_448;
	word32 esi_449;
	Eq_2 edx_158;
	if (_IO_fwide(gs, stackArg4, stackArg8, out ecx_447, out edx_158, out ebp_448, out esi_449) != 0x01)
	{
		esp_13->dwFFFFFE78 = ~0x00;
		goto l08082473;
	}
	esp_13->dwFFFFFFE0 = (word32) eax;
	esp_13->dwFFFFFEEC = esp_13 - 212;
	esp_13->dwFFFFFF3C = esp_13 - 0x10;
	esp_13->dwFFFFFF38 = esp_13 - 0x10;
	esp_13->dwFFFFFF40 = &esp_13->dw7FF0;
	ui32 eax_69 = *((word32) eax + 60);
	esp_13->dwFFFFFEFC = 0x01;
	esp_13->dwFFFFFED0 = eax_69;
	esp_13->dwFFFFFE94 = 4222451716;
	esp_13->dwFFFFFEDC = 0x00;
	esp_13->dwFFFFFF28 = 0x080CF2A0;
	esp_13->dwFFFFFE6C = (word32) ecx;
	esp_13->dwFFFFFE68 = (word32) edx;
	esp_13->dwFFFFFE64 = esp_13 - 0x016C;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	word32 edx_83;
	Eq_2 ecx_84;
	esp_13->dwFFFFFE78 = (word32) __vfwprintf(gs, stackArg4, stackArg8, stackArg12, out ecx_84, out edx_83);
	esp_13->dwFFFFFE7C = 0x00;
	esp_13->dwFFFFFE88 = (word32) eax;
	esp_13->dwFFFFFE84 = 0x08082540;
	struct Eq_94220 * eax_153;
	Mem113 = Mem95;
	Eq_2 ecx_124 = ecx_84;
	struct Eq_94217 * esp_149 = esp_454 - 0x118C;
	ui32 eax_114 = *eax;
	if ((eax_114 & 0x8000) != 0x00)
	{
		eax_153 = esp_149->ptr0078;
		edx_158 = eax_153->dw0010 - eax_153->dw000C;
		if (edx_158 <= 0x00)
			goto l08082459;
	}
	else
	{
		Eq_2 edx_119 = *((word32) eax + 72);
		Eq_2 ebp_121 = gs->t0008;
		if (*((word32) edx_119 + 8) != ebp_121)
		{
			ecx_124.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_131;
			if (!__cmpxchg(*edx_119, 0x01, eax_114 & 0x8000, out eax_131))
				ecx_124 = __lll_lock_wait_private(eax_131, edx_119, gs);
			edx_119 = *((word32) eax + 72);
			*((word32) edx_119 + 8) = ebp_121;
		}
		eax_153 = esp_149->ptr0078;
		*((word32) edx_119 + 4) = (word32) *((word32) edx_119 + 4) + 1;
		edx_158 = eax_153->dw0010 - eax_153->dw000C;
		if (edx_158 <= 0x00)
		{
l0808242A:
			if ((*eax & 0x8000) == 0x00)
			{
				edx_158 = *((word32) eax + 72);
				Eq_2 v19_239 = *((word32) edx_158 + 4) - 0x01;
				*((word32) edx_158 + 4) = v19_239;
				if (v19_239 == 0x00)
				{
					((word32) edx_158 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v20_250 = *edx_158 - 0x01;
					*edx_158 = v20_250;
					if (v20_250 != 0x00)
						__lll_unlock_wake_private(edx_158, ecx_124, edx_158, gs);
				}
			}
l08082459:
			if (esp_149->dw0008 != 0x00)
			{
				esp_149->dwFFFFFFF4 = 0x00;
				esp_149->tFFFFFFF0 = &esp_149->dw000C + 1;
				fn00000000();
			}
l08082473:
			Eq_2 ecx_317 = dwLoc20 ^ gs->t0014;
			if (ecx_317 != 0x00)
			{
				Eq_2 ecx_330;
				word32 edx_453;
				__stack_chk_fail(out ecx_330, out edx_453);
				Eq_2 edx_333;
				Eq_2 eax_332 = __funlockfile(ecx_330, gs, dwLoc8198, out edx_333);
				ecxOut = ecx_330;
				edxOut = edx_333;
				return eax_332;
			}
			else
			{
				ecxOut = ecx_317;
				edxOut = edx_158;
				return dwLoc8198;
			}
		}
	}
	Eq_2 ebp_171 = *((word32) eax + 0x0094);
	esp_149->dw000C = edx_158 >> 0x02;
	word32 ecx_172 = 0x080CEFA0;
	word32 edx_177 = 0x0354;
	if (ebp_171 >= 135066356)
	{
		_IO_vtable_check(out ecx_172, out edx_177);
		eax_153 = esp_149->ptr0078;
	}
	int32 edi_204 = esp_149->dw000C;
	esp_149->dwFFFFFFF8 = edi_204;
	esp_149->dwFFFFFFF4 = eax_153->dw000C;
	esp_149->tFFFFFFF0 = eax;
	int32 eax_220;
	(*((word32) ebp_171 + 28))();
	word32 eax_226 = ~0x00;
	if (eax_220 == edi_204)
		eax_226 = esp_149->dw0004;
	esp_149->dw0004 = eax_226;
	goto l0808242A;
}

// 08082540: Register Eq_2 __funlockfile(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 edxOut)
// Called from:
//      buffered_vfprintf
Eq_2 __funlockfile(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & edxOut)
{
	Eq_2 edx_6 = *((word32) dwArg04 + 72);
	Eq_2 v5_7 = *((word32) edx_6 + 4) - 0x01;
	*((word32) edx_6 + 4) = v5_7;
	Eq_2 eax_25 = dwArg04;
	if (v5_7 == 0x00)
	{
		((word32) edx_6 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		word32 v9_17 = *edx_6 - 0x01;
		*edx_6 = v9_17;
		if (v9_17 != 0x00)
			eax_25 = __lll_unlock_wake_private(edx_6, ecx, edx_6, gs);
	}
	edxOut = edx_6;
	return eax_25;
}

// 08082570: Register (ptr32 (ptr32 byte)) read_int(Register (ptr32 (ptr32 byte)) eax)
// Called from:
//      __parse_one_specmb
byte ** read_int(byte ** eax)
{
	byte * ebx_19 = *eax;
	byte * ebx_21 = ebx_19 + 1;
	byte ** ecx_22 = (word32) *ebx_19 - 0x30;
	while (true)
	{
		*eax = (byte **) ebx_21;
		Eq_94481 edx_27 = (word32) *ebx_21;
		if (edx_27 > 0x39)
			break;
		if (ecx_22 >= null)
		{
			if (ecx_22 > (byte **) 0x0CCCCCCC)
				ecx_22 = (byte **) ~0x00;
			else
			{
				ui32 ebp_47 = ecx_22 * 0x05;
				ecx_22 = edx_27 - 0x30 + ebp_47 * 0x02;
				if (0x7FFFFFFF - (edx_27 - 0x30) < ebp_47 * 0x02)
					ecx_22 = (byte **) ~0x00;
			}
		}
		++ebx_21;
	}
	return ecx_22;
}

// 080825D0: Register Eq_2 __parse_one_specmb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out (ptr32 Eq_73276) ebpOut, Register out Eq_2 ediOut)
// Called from:
//      printf_positional
Eq_2 __parse_one_specmb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, struct Eq_73276 & ebpOut, union Eq_2 & ediOut)
{
	((word32) dwArg0C + 36)->u0 = ~0x00;
	*((word32) dwArg0C + 16) = 0x20;
	*((word32) dwArg0C + 0x0C) &= 0xE207;
	up32 edx_28 = (word32) *((word32) dwArg04 + 1);
	Eq_2 edi_19 = dwArg04;
	struct Eq_73276 * ebp_146 = (word32) dwArg04 + 1;
	struct Eq_73276 * dwArg04_518 = (word32) dwArg04 + 1;
	up32 eax_29 = edx_28;
	if (edx_28 <= 0x39)
	{
		up32 eax_34 = read_int(fp + 0x04);
		if (eax_34 != 0x00 && *((word32) dwArg04 + 1) == 0x24)
		{
			ebp_146 = (word32) dwArg04 + 2;
			dwArg04_518 = (word32) dwArg04 + 2;
			if (eax_34 != ~0x00)
			{
				*((word32) dwArg0C + 36) = eax_34 - 0x01;
				edi_19 = dwArg10;
				if (*dwArg10 >= eax_34)
					eax_34 = (up32) *dwArg10;
				*dwArg10 = eax_34;
			}
			eax_29 = (word32) *((word32) dwArg04 + 2);
		}
		else
		{
			dwArg04_518 = (word32) dwArg04 + 1;
			eax_29 = (word32) *((word32) dwArg04 + 1);
		}
	}
	cu8 al_72 = (byte) eax_29 - 0x20;
	if (al_72 <= 0x29)
	{
		ui32 eax_502 = (word32) al_72;
		<anonymous> * ecx_504 = g_a80B201C[eax_502 * 0x04] + 0x080CE000;
		Eq_2 eax_509;
		ecx_504();
		ebxOut = 0x080CE000;
		ebpOut = ebp_146;
		ediOut = edi_19;
		return eax_509;
	}
	if ((*((word32) dwArg0C + 0x0C) & 0x20) != 0x00)
		*((word32) dwArg0C + 16) = 0x20;
	Eq_2 edi_147;
	((word32) dwArg0C + 32)->u0 = ~0x00;
	*((word32) dwArg0C + 4) = 0x00;
	up32 eax_91 = (word32) ebp_146->t0000;
	if ((byte) eax_91 != 0x2A)
	{
		edi_147.u0 = 0x00;
		if (eax_91 <= 0x39)
		{
			up32 eax_170 = read_int(fp + 0x04);
			if (eax_170 != ~0x00)
				*((word32) dwArg0C + 4) = eax_170;
			ebp_146 = dwArg04_518;
		}
		goto l0808268C;
	}
	struct Eq_73276 * edi_95 = &ebp_146->b0001;
	dwArg04_518 = edi_95;
	if ((word32) ebp_146->b0001 <= 0x39)
	{
		up32 eax_106 = read_int(fp + 0x04);
		if (eax_106 != 0x00 && edi_95->t0000 == 0x24)
		{
			if (eax_106 != ~0x00)
			{
				*((word32) dwArg0C + 32) = eax_106 - 0x01;
				if (*dwArg10 >= eax_106)
					eax_106 = (up32) *dwArg10;
				*dwArg10 = eax_106;
			}
			dwArg04_518 = (struct Eq_73276 *) &edi_95->b0001;
		}
		if (*((word32) dwArg0C + 32) >= 0x00)
		{
			ebp_146 = dwArg04_518;
			edi_147.u0 = 0x00;
l0808268C:
			((word32) dwArg0C + 28)->u0 = ~0x00;
			*dwArg0C = ~0x00;
			if (ebp_146->t0000 != 0x2E)
			{
l080826A3:
				struct Eq_73276 * edx_338;
				Eq_2 eax_339;
				Eq_2 eax_304 = __printf_modifier_table;
				*((word32) dwArg0C + 0x0C) &= 0xFDF8;
				if (eax_304 != 0x00 && *((word32) eax_304 + (word32) ebp_146->t0000 * 0x04) != 0x00)
				{
					if (__handle_registered_modifier_mb(fp + 0x04, dwArg0C) == 0x00)
					{
						edx_338 = dwArg04_518;
						eax_339 = &dwArg04_518->b0001;
						goto l08082747;
					}
					ebp_146 = dwArg04_518;
				}
				Eq_2 edx_342 = &ebp_146->b0001;
				cu8 al_347 = ebp_146->t0000 - 0x4C;
				if (al_347 <= 0x2E)
				{
					ui32 eax_494 = (word32) al_347;
					<anonymous> * ecx_496 = g_a80B20C4[eax_494 * 0x04] + 0x080CE000;
					Eq_2 eax_499;
					ecx_496();
					ebxOut = 0x080CE000;
					ebpOut = ebp_146;
					ediOut = edi_147;
					return eax_499;
				}
				eax_339 = edx_342;
				edx_338 = ebp_146;
l08082747:
				Eq_2 (* eax_357)[] = __printf_function_table;
				ui32 edx_359 = (word32) edx_338->t0000;
				*((word32) dwArg0C + 48) = ~0x00;
				*((word32) dwArg0C + 8) = edx_359;
				if (eax_357 != null)
				{
					<anonymous> * eax_368 = *((word32) __printf_arginfo_table + edx_359 * 0x04);
					if (eax_368 != null)
					{
						int32 eax_407;
						eax_368();
						edx_359 = (ui32) *((word32) dwArg0C + 8);
						*((word32) dwArg0C + 44) = eax_407;
						if (eax_407 >= 0x00)
						{
							if (*((word32) dwArg0C + 36) == ~0x00 && eax_407 != 0x00)
							{
								*((word32) dwArg0C + 36) = dwArg08;
								edi_147 = (byte) edi_147.u0 + eax_407;
							}
							goto l08082938;
						}
					}
				}
				*((word32) dwArg0C + 44) = 0x01;
				uint32 eax_426 = edx_359 - 0x41;
				if (eax_426 <= 55)
				{
					struct Eq_73276 * ebp_487 = g_a80B2180[eax_426 * 0x04] + 0x080CE000;
					Eq_2 eax_491;
					ebp_487();
					ebxOut = 0x080CE000;
					ebpOut = ebp_487;
					ediOut = edi_147;
					return eax_491;
				}
				*((word32) dwArg0C + 44) = 0x00;
l08082938:
				if (edx_359 != 0x00)
				{
					*((word32) dwArg0C + 20) = eax_339;
					*((word32) dwArg0C + 24) = strchrnul(eax_339, 0x25);
					ebxOut = ebx;
					ebpOut = ebp;
					ediOut = edi;
					return edi_147;
				}
				else
				{
					*((word32) dwArg0C + 24) = eax_339 - 0x01;
					*((word32) dwArg0C + 20) = eax_339 - 0x01;
					ebxOut = ebx;
					ebpOut = ebp;
					ediOut = edi;
					return edi_147;
				}
			}
			struct Eq_73276 * edx_190 = &ebp_146->b0001;
			up32 eax_193 = (word32) ebp_146->b0001;
			dwArg04_518 = edx_190;
			if ((byte) eax_193 == 0x2A)
			{
				struct Eq_73276 * edx_197 = &ebp_146->b0002;
				dwArg04_518 = edx_197;
				if ((word32) ebp_146->b0002 <= 0x39)
				{
					up32 eax_205 = read_int(fp + 0x04);
					if (eax_205 != 0x00 && edx_197->t0000 == 0x24)
					{
						if (eax_205 != ~0x00)
						{
							*((word32) dwArg0C + 28) = eax_205 - 0x01;
							if (*dwArg10 >= eax_205)
								eax_205 = (up32) *dwArg10;
							*dwArg10 = eax_205;
						}
						dwArg04_518 = (struct Eq_73276 *) &edx_197->b0001;
					}
					if (*((word32) dwArg0C + 28) >= 0x00)
						goto l080829B8;
				}
				*((word32) dwArg0C + 28) = dwArg08;
				edi_147 = (word32) edi_147 + 1;
				dwArg04_518 = edx_197;
				ebp_146 = edx_197;
				dwArg08 = (word32) dwArg08 + 1;
				goto l080826A3;
			}
			else
			{
				if (eax_193 > 0x39)
				{
					*dwArg0C = 0x00;
					ebp_146 = edx_190;
					goto l080826A3;
				}
				up32 eax_271 = read_int(fp + 0x04);
				if (eax_271 != ~0x00)
					*dwArg0C = eax_271;
l080829B8:
				ebp_146 = dwArg04_518;
				goto l080826A3;
			}
		}
	}
	*((word32) dwArg0C + 32) = dwArg08;
	dwArg04_518 = edi_95;
	ebp_146 = edi_95;
	edi_147.u0 = 0x01;
	dwArg08 = (word32) dwArg08 + 1;
	goto l0808268C;
}

// 08082BA0: Register (ptr32 (ptr32 Eq_94931)) read_int(Register (ptr32 (ptr32 Eq_94931)) eax)
// Called from:
//      __parse_one_specwc
struct Eq_94931 ** read_int(struct Eq_94931 ** eax)
{
	struct Eq_94931 * ecx_17 = *eax;
	up32 esi_20 = ecx_17->dw0004;
	struct Eq_94931 * ecx_19 = &ecx_17->dw0004;
	struct Eq_94931 * ebx_21 = &ecx_17->dw0004;
	int32 esi_22 = esi_20 - 0x30;
	struct Eq_94931 ** edx_23 = ecx_17->dw0000 - 0x30;
	if (esi_20 <= 0x39)
	{
		do
		{
			if (edx_23 >= null)
			{
				if (edx_23 <= (struct Eq_94931 **) 0x0CCCCCCC)
				{
					ui32 edx_33 = edx_23 * 0x05;
					if (0x7FFFFFFF - esi_22 < edx_33 * 0x02)
						goto l08082BF8;
					edx_23 = edx_33 * 0x02 + esi_22;
				}
				else
				{
l08082BF8:
					struct Eq_94931 * ebx_43 = &ebx_21->dw0004;
					if (ebx_43->dw0000 > 0x39)
					{
						*eax = (struct Eq_94931 **) ebx_43;
						return (struct Eq_94931 **) ~0x00;
					}
					++ecx_19;
					edx_23 = (struct Eq_94931 **) ~0x00;
					if (ecx_19->dw0000 > 0x39)
					{
						*eax = (struct Eq_94931 **) ecx_19;
						return (struct Eq_94931 **) ~0x00;
					}
				}
			}
			ecx_19 = (struct Eq_94931 *) &ecx_19->dw0004;
			up32 esi_89 = ecx_19->dw0000;
			ebx_21 = ecx_19;
			esi_22 = esi_89 - 0x30;
		} while (esi_89 <= 0x39);
	}
	*eax = (struct Eq_94931 **) ebx_21;
	return edx_23;
}

// 08082C40: Register word32 __parse_one_specwc(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      printf_positional
word32 __parse_one_specwc(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & ediOut)
{
	cui16 ax_25 = *((word32) dwArg0C + 0x0C);
	((word32) dwArg0C + 36)->u0 = ~0x00;
	*((word32) dwArg0C + 16) = 0x20;
	*((word32) dwArg0C + 0x0C) = SEQ(SLICE(ax_25, byte, 8) & 226 | 0x04, (byte) ax_25 & 0x07);
	Eq_2 ebp_111 = dwArg04;
	Eq_2 edi_23 = (word32) dwArg04 + 4;
	Eq_2 dwArg04_533 = (word32) dwArg04 + 4;
	up32 eax_33 = *((word32) dwArg04 + 4);
	if (eax_33 <= 0x39)
	{
		up32 eax_38 = read_int(fp + 0x04);
		if (eax_38 != 0x00 && *((word32) dwArg04 + 4) == 0x24)
		{
			edi_23 = (word32) dwArg04 + 8;
			dwArg04_533 = (word32) dwArg04 + 8;
			if (eax_38 != ~0x00)
			{
				*((word32) dwArg0C + 36) = eax_38 - 0x01;
				if (*dwArg10 >= eax_38)
					eax_38 = (up32) *dwArg10;
				*dwArg10 = eax_38;
			}
			eax_33 = (up32) *((word32) dwArg04 + 8);
		}
		else
		{
			dwArg04_533 = (word32) dwArg04 + 4;
			eax_33 = (up32) *((word32) dwArg04 + 4);
		}
	}
	uint32 eax_80 = eax_33 - 0x20;
	if (eax_80 <= 0x29)
	{
		<anonymous> * ecx_521 = g_a80B2260[eax_80 * 0x04] + 0x080CE000;
		word32 eax_523;
		ecx_521();
		ebxOut = 0x080CE000;
		ebpOut = dwArg04;
		ediOut = edi_23;
		return eax_523;
	}
	Eq_2 dwArg04_541 = dwArg04_533;
	Eq_2 edi_106 = dwArg04_533;
	if ((*((word32) dwArg0C + 0x0C) & 0x20) != 0x00)
		*((word32) dwArg0C + 16) = 0x20;
	word32 dwLoc24_550;
	((word32) dwArg0C + 32)->u0 = ~0x00;
	*((word32) dwArg0C + 4) = 0x00;
	up32 eax_107 = *dwArg04_533;
	if (eax_107 != 0x2A)
	{
		dwLoc24_550 = 0x00;
		if (eax_107 <= 0x39)
		{
			up32 eax_181 = read_int(fp + 0x04);
			if (eax_181 != ~0x00)
				*((word32) dwArg0C + 4) = eax_181;
			edi_106 = dwArg04_533;
		}
		goto l08082D04;
	}
	ebp_111 = (word32) dwArg04_533 + 4;
	dwArg04_541 = ebp_111;
	if (*((word32) dwArg04_533 + 4) <= 0x39)
	{
		up32 eax_119 = read_int(fp + 0x04);
		if (eax_119 != 0x00 && *ebp_111 == 0x24)
		{
			if (eax_119 != ~0x00)
			{
				*((word32) dwArg0C + 32) = eax_119 - 0x01;
				if (*dwArg10 >= eax_119)
					eax_119 = (up32) *dwArg10;
				*dwArg10 = eax_119;
			}
			dwArg04_541 = (word32) ebp_111 + 4;
		}
		if (*((word32) dwArg0C + 32) >= 0x00)
		{
			edi_106 = dwArg04_541;
			dwLoc24_550 = 0x00;
l08082D04:
			((word32) dwArg0C + 28)->u0 = ~0x00;
			*dwArg0C = ~0x00;
			if (*edi_106 != 0x2E)
			{
l08082D1A:
				Eq_2 edx_345;
				Eq_2 edx_310 = __printf_modifier_table;
				*((word32) dwArg0C + 0x0C) &= 0xFDF8;
				int32 eax_317 = *edi_106;
				if (edx_310 != 0x00 && *((word32) edx_310 + eax_317 * 0x04) != 0x00)
				{
					if (__handle_registered_modifier_wc(fp + 0x04, dwArg0C) == 0x00)
					{
						edx_345 = (word32) dwArg04_541 + 4;
						eax_317 = (int32) *dwArg04_541;
l08082DE0:
						Eq_2 (* edx_362)[] = __printf_function_table;
						*((word32) dwArg0C + 8) = eax_317;
						*((word32) dwArg0C + 48) = ~0x00;
						if (edx_362 != null && eax_317 <= 0xFF)
						{
							<anonymous> * edx_374 = *((word32) __printf_arginfo_table + eax_317 * 0x04);
							if (edx_374 != null)
							{
								int32 eax_424;
								edx_374();
								*((word32) dwArg0C + 44) = eax_424;
								eax_317 = (int32) *((word32) dwArg0C + 8);
								if (eax_424 >= 0x00)
								{
									if (*((word32) dwArg0C + 36) == ~0x00 && eax_424 != 0x00)
									{
										*((word32) dwArg0C + 36) = dwArg08;
										dwLoc24_550 += eax_424;
									}
									goto l08082F79;
								}
							}
						}
						*((word32) dwArg0C + 44) = 0x01;
						uint32 edx_446 = eax_317 - 0x41;
						if (edx_446 <= 55)
						{
							Eq_2 edi_505 = g_a80B23C4[edx_446 * 0x04] + 0x080CE000;
							word32 eax_509;
							edi_505();
							ebxOut = 0x080CE000;
							ebpOut = ebp_111;
							ediOut = edi_505;
							return eax_509;
						}
						*((word32) dwArg0C + 44) = 0x00;
l08082F79:
						if (eax_317 != 0x00)
						{
							*((word32) dwArg0C + 20) = edx_345;
							*((word32) dwArg0C + 24) = wcschrnul(edx_345, 0x25);
							ebxOut = ebx;
							ebpOut = ebp;
							ediOut = edi;
							return dwLoc24_550;
						}
						else
						{
							*((word32) dwArg0C + 24) = edx_345 - 0x04;
							*((word32) dwArg0C + 20) = edx_345 - 0x04;
							ebxOut = ebx;
							ebpOut = ebp;
							ediOut = edi;
							return dwLoc24_550;
						}
					}
					edi_106 = dwArg04_541;
					eax_317 = (int32) *dwArg04_541;
				}
				edx_345 = (word32) edi_106 + 4;
				uint32 ecx_352 = eax_317 - 0x4C;
				if (ecx_352 <= 0x2E)
				{
					Eq_2 ebp_514 = g_a80B2308[ecx_352 * 0x04] + 0x080CE000;
					word32 eax_516;
					ebp_514();
					ebxOut = 0x080CE000;
					ebpOut = ebp_514;
					ediOut = edi_106;
					return eax_516;
				}
				goto l08082DE0;
			}
			Eq_2 edx_202 = (word32) edi_106 + 4;
			Eq_2 eax_201 = *((word32) edi_106 + 4);
			dwArg04_541 = edx_202;
			if (eax_201 == 0x2A)
			{
				Eq_2 edx_208 = (word32) edi_106 + 8;
				dwArg04_541 = edx_208;
				if (*((word32) edi_106 + 8) <= 0x39)
				{
					up32 eax_215 = read_int(fp + 0x04);
					if (eax_215 != 0x00 && *edx_208 == 0x24)
					{
						if (eax_215 != ~0x00)
						{
							*((word32) dwArg0C + 28) = eax_215 - 0x01;
							if (*dwArg10 >= eax_215)
								eax_215 = (up32) *dwArg10;
							*dwArg10 = eax_215;
						}
						dwArg04_541 = (word32) edx_208 + 4;
					}
					if (*((word32) dwArg0C + 28) >= 0x00)
						goto l08083070;
				}
				*((word32) dwArg0C + 28) = dwArg08;
				++dwLoc24_550;
				edi_106 = edx_208;
				dwArg04_541 = edx_208;
				dwArg08 = (word32) dwArg08 + 1;
				goto l08082D1A;
			}
			else
			{
				if (eax_201 > 0x39)
				{
					*dwArg0C = 0x00;
					edi_106 = edx_202;
					goto l08082D1A;
				}
				up32 eax_276 = read_int(fp + 0x04);
				if (eax_276 != ~0x00)
					*dwArg0C = eax_276;
l08083070:
				edi_106 = dwArg04_541;
				goto l08082D1A;
			}
		}
	}
	*((word32) dwArg0C + 32) = dwArg08;
	dwArg04_541 = ebp_111;
	edi_106 = ebp_111;
	dwLoc24_550 = 0x01;
	dwArg08 = (word32) dwArg08 + 1;
	goto l08082D04;
}

// 08083260: Register word32 _IO_file_doallocate(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _IO_wfile_doallocate
word32 _IO_file_doallocate(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebp_102;
	Eq_2 esp_18 = fp - 0x8C;
	Eq_2175 eax_20 = gs->t0014;
	if (*((word32) dwArg04 + 56) >= 0x00)
	{
		Eq_2 ebx_28 = *((word32) dwArg04 + 0x0094);
		if (ebx_28 >= 135066356)
		{
			word32 ecx_291;
			word32 edx_292;
			_IO_vtable_check(out ecx_291, out edx_292);
			esp_18.u0 = <invalid>;
		}
		struct Eq_95448 * esp_44 = esp_18 - 0x08;
		esp_44->ptrFFFFFFFC = &esp_44->ptrFFFFFFFC + 6;
		esp_44->tFFFFFFF8 = dwArg04;
		int32 eax_57;
		(*((word32) ebx_28 + 72))();
		struct Eq_95463 * esp_100 = &esp_44->ptrFFFFFFFC + 3;
		if (eax_57 >= 0x00)
		{
			if ((esp_44->dw0024 & 0xF000) != 0x2000)
			{
l080832D7:
				ebp_102 = esp_100->t0040;
				if (ebp_102 <= 0x1FFF)
					goto l080832E8;
				goto l08083330;
			}
			uint32 ebx_70 = esp_44->dw0038;
			if ((__shrd(esp_44->dw0034, ebx_70, 0x08) & 0x0FFF | ebx_70 & ~0x0FFF) > 0x8F)
			{
				Eq_2 ebp_83 = gs->tFFFFFFE0;
				esp_44->tFFFFFFF8 = *((word32) dwArg04 + 56);
				word32 ecx_298;
				struct Eq_224 * eax_87 = __isatty(gs, out ecx_298);
				gs->tFFFFFFE0 = ebp_83;
				Eq_2 esp_90 = <invalid>;
				esp_100 = (word32) esp_90 + 16;
				if (eax_87 == null)
					goto l080832D7;
			}
			ebp_102 = esp_100->t0040;
			*dwArg04 |= 0x0200;
			if (ebp_102 <= 0x1FFF)
			{
l080832E8:
				word32 ebp_136;
				word32 edi_139;
				Eq_2 esi_141;
				word32 ebx_297;
				word32 ecx_295;
				word32 edx_296;
				Eq_2 eax_135 = __libc_malloc(gs, dwLocA0, ebp_102, out ecx_295, out edx_296, out ebx_297, out ebp_136, out esi_141, out edi_139);
				if (eax_135 != 0x00)
					_IO_setb(esi_141, eax_135, (word32) eax_135 + ebp_136, 0x01);
				if ((eax_20 ^ gs->t0014) == 0x00)
					return edi;
				word32 ecx_293;
				word32 edx_294;
				__stack_chk_fail(out ecx_293, out edx_294);
				fputs(gs, dwArg04, dwArg08);
				return edi_139;
			}
		}
	}
l08083330:
	ebp_102.u0 = 0x2000;
	goto l080832E8;
}

// 080833D0: void fputs(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      malloc_info
//      _IO_file_doallocate
void fputs(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	word32 edx_325;
	word32 ecx_324;
	Eq_2 eax_25 = strlen(dwArg04, out ecx_324, out edx_325);
	Eq_2 esp_100 = fp - 44;
	ui32 eax_34 = *dwArg08;
	if ((eax_34 & 0x8000) == 0x00)
	{
		Eq_2 edx_39 = *((word32) dwArg08 + 72);
		Eq_2 ecx_41 = gs->t0008;
		if (*((word32) edx_39 + 8) != ecx_41)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_52;
			if (!__cmpxchg(*edx_39, 0x01, eax_34 & 0x8000, out eax_52))
				__lll_lock_wait_private(eax_52, edx_39, gs);
			edx_39 = *((word32) dwArg08 + 72);
			*((word32) edx_39 + 8) = ecx_41;
		}
		*((word32) edx_39 + 4) = (word32) *((word32) edx_39 + 4) + 1;
	}
	Eq_2 ecx_152;
	Eq_2 eax_78 = *((word32) dwArg08 + 0x0068);
	if (eax_78 == 0x00)
		((word32) dwArg08 + 0x0068)->u0 = ~0x00;
	else if (eax_78 != ~0x00)
		goto l0808349D;
	Eq_2 ecx_87 = *((word32) dwArg08 + 0x0094);
	if (ecx_87 >= 135066356)
	{
		word32 edx_327;
		word32 ecx_326;
		_IO_vtable_check(out ecx_326, out edx_327);
		esp_100.u0 = <invalid>;
	}
	struct Eq_95645 * esp_114 = esp_100 - 0x04;
	esp_114->tFFFFFFFC = eax_25;
	esp_114->tFFFFFFF8 = dwArg04;
	esp_114->tFFFFFFF4 = dwArg08;
	Eq_2 eax_147;
	(*((word32) ecx_87 + 28))();
	ecx_152.u0 = 0x01;
	if (eax_25 == eax_147)
	{
		if ((*dwArg08 & 0x8000) != 0x00)
			return;
l080834AA:
		Eq_2 edx_166 = *((word32) dwArg08 + 72);
		Eq_2 v18_167 = *((word32) edx_166 + 4) - 0x01;
		*((word32) edx_166 + 4) = v18_167;
		if (v18_167 != 0x00)
			return;
		((word32) edx_166 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		word32 v19_178 = *edx_166 - 0x01;
		*edx_166 = v19_178;
		if (v19_178 != 0x00)
			__lll_unlock_wake_private(edx_166, ecx_152, edx_166, gs);
		return;
	}
l0808349D:
	ecx_152.u0 = ~0x00;
	if ((*dwArg08 & 0x8000) != 0x00)
		return;
	goto l080834AA;
}

// 08083500: void _IO_wfile_doallocate(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wfile_doallocate(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_13 = dwArg04;
	<anonymous> * eax_16 = *((word32) dwArg04 + 28);
	if (eax_16 == null)
	{
		edi_13 = _IO_file_doallocate(gs, dwArg04, dwLoc18);
		eax_16 = (<anonymous> *) *((word32) edi_13 + 28);
	}
	uint32 ecx_43 = *((word32) edi_13 + 32) - eax_16;
	uint32 eax_45 = ecx_43;
	uint32 edx_46 = ecx_43 + 0x03 >> 0x02;
	if ((*edi_13 & 0x01) != 0x00)
		eax_45 = edx_46;
	Eq_2 edi_65;
	word32 esi_67;
	word32 ebx_153;
	word32 ecx_151;
	word32 edx_152;
	word32 ebp_154;
	Eq_2 eax_61 = __libc_malloc(gs, dwLoc20, eax_45 * 0x04, out ecx_151, out edx_152, out ebx_153, out ebp_154, out esi_67, out edi_65);
	if (eax_61 == 0x00)
		return;
	word32 edx_155;
	_IO_wsetb(edi_65, eax_61, (word32) eax_61 + esi_67, 0x01, out edx_155);
}

// 08083590: void fwrite(Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __malloc_stats
void fwrite(struct Eq_9 * gs, ptr32 dwArg04, int32 dwArg08, int32 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 esp_119 = fp - 44;
	Eq_2 ebx_21 = dwArg08 *s dwArg0C;
	if (ebx_21 == 0x00)
		return;
	ui32 eax_26 = *dwArg10;
	if ((eax_26 & 0x8000) == 0x00)
	{
		Eq_2 edx_31 = *((word32) dwArg10 + 72);
		Eq_2 ecx_33 = gs->t0008;
		if (*((word32) edx_31 + 8) != ecx_33)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_44;
			if (!__cmpxchg(*edx_31, 0x01, eax_26 & 0x8000, out eax_44))
				__lll_lock_wait_private(eax_44, edx_31, gs);
			edx_31 = *((word32) dwArg10 + 72);
			*((word32) edx_31 + 8) = ecx_33;
		}
		*((word32) edx_31 + 4) = (word32) *((word32) edx_31 + 4) + 1;
	}
	word32 edi_101;
	Eq_2 edx_102;
	Eq_2 ecx_181;
	Eq_2 eax_70 = *((word32) dwArg10 + 0x0068);
	if (eax_70 == 0x00)
		((word32) dwArg10 + 0x0068)->u0 = ~0x00;
	else if (eax_70 != ~0x00)
	{
		if ((*dwArg10 & 0x8000) != 0x00)
			return;
		ecx_181 = *((word32) dwArg10 + 72);
		Eq_2 v20_80 = *((word32) ecx_181 + 4) - 0x01;
		*((word32) ecx_181 + 4) = v20_80;
		if (v20_80 != 0x00)
			return;
		edi_101 = 0x00;
		edx_102.u0 = 0x00;
		goto l0808365D;
	}
	Eq_2 ecx_108 = *((word32) dwArg10 + 0x0094);
	if (ecx_108 >= 135066356)
	{
		word32 ecx_389;
		word32 edx_390;
		_IO_vtable_check(out ecx_389, out edx_390);
		esp_119.u0 = <invalid>;
	}
	struct Eq_95869 * esp_133 = esp_119 - 0x04;
	esp_133->tFFFFFFFC = ebx_21;
	esp_133->ptrFFFFFFF8 = dwArg04;
	esp_133->tFFFFFFF4 = dwArg10;
	Eq_2 eax_166;
	word32 ecx_168;
	(*((word32) ecx_108 + 28))();
	edx_102 = eax_166;
	edi_101 = SEQ(SLICE(eax_166, word24, 8), (int8) (eax_166 == ~0x00));
	if ((*dwArg10 & 0x8000) != 0x00)
	{
l0808367B:
		if (ebx_21 == edx_102 || (byte) edi_101 != 0x00)
			;
		return;
	}
	ecx_181 = *((word32) dwArg10 + 72);
	Eq_2 v19_182 = *((word32) ecx_181 + 4) - 0x01;
	*((word32) ecx_181 + 4) = v19_182;
	if (v19_182 != 0x00)
		goto l0808367B;
l0808365D:
	((word32) ecx_181 + 8)->u0 = 0x00;
	if (gs->t000C != 0x00)
		__lock();
	word32 v21_193 = *ecx_181 - 0x01;
	*ecx_181 = v21_193;
	if (v21_193 != 0x00)
		__lll_unlock_wake_private(ecx_181, ecx_181, edx_102, gs);
	goto l0808367B;
}

// 08083700: Register Eq_2 _IO_getdelim(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __gconv_read_conf
//      __readonly_area
Eq_2 _IO_getdelim(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 dwLoc28_414;
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 22;
		dwLoc28_414.u0 = ~0x00;
		return dwLoc28_414;
	}
	Eq_2 ecx_146;
	Eq_2 edx_353;
	byte ah_344;
	ui32 ecx_38 = *dwArg10;
	if ((ecx_38 & 0x8000) != 0x00)
	{
		if ((ecx_38 & 0x20) != 0x00)
			return ~0x00;
	}
	else
	{
		edx_353 = *((word32) dwArg10 + 72);
		Eq_2 ebx_45 = gs->t0008;
		if (*((word32) edx_353 + 8) != ebx_45)
		{
			ecx_146.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_62;
			if (!__cmpxchg(*edx_353, 0x01, ecx_38 & 0x8000, out eax_62))
				ecx_146 = __lll_lock_wait_private(eax_62, edx_353, gs);
			ui32 eax_76 = *dwArg10;
			Eq_2 edx_75 = *((word32) dwArg10 + 72);
			*((word32) edx_75 + 8) = ebx_45;
			*((word32) edx_75 + 4) = (word32) *((word32) edx_75 + 4) + 1;
			ah_344 = SLICE(eax_76, byte, 8);
			if (((byte) eax_76 & 0x20) != 0x00)
			{
				dwLoc28_414.u0 = ~0x00;
				goto l08083885;
			}
		}
		else
		{
			*((word32) edx_353 + 4) = (word32) *((word32) edx_353 + 4) + 1;
			ecx_146 = ecx_38 & 0x20;
			if ((ecx_38 & 0x20) != 0x00)
			{
				dwLoc28_414.u0 = ~0x00;
				goto l0808388D;
			}
		}
	}
	if (*dwArg04 == 0x00 || *dwArg08 == 0x00)
	{
		dwArg08->u0 = 0x78;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ebp_657;
		word32 esi_658;
		word32 edx_655;
		word32 edi_659;
		word32 ebx_656;
		word32 ecx_654;
		Eq_2 eax_142 = __libc_malloc(gs, stackArg0, 0x78, out ecx_654, out edx_655, out ebx_656, out ebp_657, out esi_658, out edi_659);
		*dwArg04 = eax_142;
		ecx_146 = dwArg04;
		if (eax_142 == 0x00)
			goto l0808387C;
	}
	Eq_2 ebx_154 = *((word32) dwArg10 + 4);
	Eq_2 esi_156 = *((word32) dwArg10 + 8) - ebx_154;
	if (esi_156 > 0x00)
	{
l08083793:
		Eq_2 dwLoc20_442 = 0x00;
		while (true)
		{
			Eq_2 eax_194 = __memchr(ebx_154, (byte) dwArg0C, esi_156);
			ecx_146 = eax_194;
			word32 eax_203 = eax_194 - ebx_154;
			if (eax_194 != 0x00)
				esi_156 = eax_203 + 0x01;
			if (esi_156 >= 0x7FFFFFFF - dwLoc20_442)
				break;
			word32 eax_218 = dwLoc20_442 + esi_156;
			Eq_2 edx_219 = *dwArg08;
			dwLoc28_414 = eax_218;
			Eq_2 eax_224 = *dwArg04;
			if (edx_219 <u eax_218 + 0x01)
			{
				Eq_2 edx_228 = edx_219 * 0x02;
				if (edx_219 * 0x02 <u eax_218 + 0x01)
					edx_228 = eax_218 + 0x01;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 esi_665;
				word32 edx_663;
				word32 ebp_664;
				word32 edi_666;
				eax_224 = __realloc(gs, stackArg0, eax_224, edx_228, out edx_663, out ebp_664, out esi_665, out edi_666);
				ecx_146 = eax_194;
				if (eax_224 == 0x00)
					goto l0808387C;
				*dwArg04 = eax_224;
				*dwArg08 = edx_228;
				ebx_154 = *((word32) dwArg10 + 4);
			}
			word32 ecx_660;
			word32 edx_661;
			memcpy(eax_224 + dwLoc20_442, ebx_154, esi_156, out ecx_660, out edx_661);
			Mem303[dwArg10 + 0x04:word32] = Mem291[dwArg10 + 0x04:word32] + esi_156;
			if (eax_194 != 0x00)
			{
l08083928:
				Mem326[Mem322[dwArg04 + 0x00:word32] + eax_218:byte] = 0x00;
				ecx_146 = eax_218;
				goto l08083934;
			}
			word32 ecx_667;
			if (__underflow(dwArg10, out ecx_667) == ~0x00)
				goto l08083928;
			ebx_154 = *((word32) dwArg10 + 4);
			dwLoc20_442 = eax_218;
			esi_156 = *((word32) dwArg10 + 8) - ebx_154;
		}
		gs->tFFFFFFE0.u0 = 0x4B;
l0808387C:
		dwLoc28_414.u0 = ~0x00;
		ah_344 = (byte) *((word32) dwArg10 + 1);
		goto l08083885;
	}
	Eq_2 eax_167 = __underflow(dwArg10, out ecx_146);
	dwLoc28_414 = eax_167;
	if (eax_167 != ~0x00)
	{
		ebx_154 = *((word32) dwArg10 + 4);
		esi_156 = *((word32) dwArg10 + 8) - ebx_154;
		goto l08083793;
	}
l08083934:
	ah_344 = (byte) *((word32) dwArg10 + 1);
l08083885:
	if ((ah_344 & 0x80) != 0x00)
		return dwLoc28_414;
	edx_353 = *((word32) dwArg10 + 72);
l0808388D:
	Eq_2 v18_356 = *((word32) edx_353 + 4) - 0x01;
	*((word32) edx_353 + 4) = v18_356;
	if (v18_356 == 0x00)
	{
		((word32) edx_353 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v19_370 = *edx_353 - 0x01;
		*edx_353 = v19_370;
		if (v19_370 != 0x00)
			__lll_unlock_wake_private(edx_353, ecx_146, edx_353, gs);
	}
	return dwLoc28_414;
}

// 080839B0: void _IO_getline_info(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10, Stack Eq_96269 dwArg14, Stack (ptr32 word32) dwArg18)
// Called from:
//      _IO_getline
void _IO_getline_info(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10, Eq_96269 dwArg14, word32 * dwArg18)
{
	Eq_2 ebp_139 = dwArg0C;
	if (dwArg18 != null)
		*dwArg18 = 0x00;
	if (*((word32) dwArg04 + 0x0068) == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	if (dwArg0C != 0x00)
	{
		Eq_2 dwLoc28_252 = dwArg08;
		do
		{
			Eq_2 ebx_50 = *((word32) dwArg04 + 4);
			byte bArg10_294 = (byte) dwArg10;
			Eq_2 esi_52 = *((word32) dwArg04 + 8) - ebx_50;
			if (esi_52 > 0x00)
			{
				if (esi_52 > ebp_139)
					esi_52 = ebp_139;
				Eq_2 eax_72 = __memchr(ebx_50, (byte) dwArg10, esi_52);
				if (eax_72 != 0x00)
				{
					Eq_2 edx_84 = eax_72;
					Eq_2 esi_103 = eax_72 - ebx_50;
					if (dwArg14 >= 0x00)
					{
						edx_84 = (word32) eax_72 + 1;
						esi_103 = esi_103 - ~0x00 - (word32) (dwArg14 < 0x01);
					}
					word32 ecx_377;
					word32 edx_378;
					memcpy(dwLoc28_252, ebx_50, esi_103, out ecx_377, out edx_378);
					*((word32) dwArg04 + 4) = edx_84;
					return;
				}
				else
				{
					word32 edx_376;
					word32 ecx_375;
					memcpy(dwLoc28_252, ebx_50, esi_52, out ecx_375, out edx_376);
					Mem161[dwArg04 + 0x04:word32] = Mem158[dwArg04 + 0x04:word32] + esi_52;
					ebp_139 -= esi_52;
					dwLoc28_252 += esi_52;
					if (ebp_139 != 0x00)
						continue;
					break;
				}
			}
			word32 eax_170 = __uflow(dwArg04);
			byte al_212 = (byte) eax_170;
			if (eax_170 == ~0x00)
			{
				if (dwArg18 != null)
					*dwArg18 = ~0x00;
				return;
			}
			if (eax_170 == dwArg10)
			{
				if (dwArg14 > 0x00)
					*dwLoc28_252 = bArg10_294;
				else if (dwArg14 != 0x00)
					_IO_sputbackc(dwArg04, dwArg10);
				break;
			}
			*dwLoc28_252 = al_212;
			--ebp_139;
			dwLoc28_252 = (word32) dwLoc28_252 + 1;
		} while (ebp_139 != 0x00);
	}
}

// 08083B50: Register Eq_2 _IO_getline()
// Called from:
//      fgets_unlocked
Eq_2 _IO_getline()
{
	_IO_getline_info(dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, null);
	return <invalid>;
}

// 08083B80: Register Eq_2 _IO_padn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out (ptr32 Eq_75758) edxOut, Register out Eq_952 ebxOut, Register out Eq_952 ebpOut, Register out Eq_2 esiOut, Register out (ptr32 Eq_75762) ediOut)
// Called from:
//      printf_positional
//      vfprintf
//      __printf_fp_l
//      __printf_fphex
Eq_2 _IO_padn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, struct Eq_75758 & edxOut, union Eq_952 & ebxOut, union Eq_952 & ebpOut, union Eq_2 & esiOut, struct Eq_75762 & ediOut)
{
	byte * ebx_131 = &g_b80B24B4;
	byte cl_197 = (byte) dwArg08;
	Eq_2 ebp_107 = dwArg0C;
	Eq_2175 esi_25 = gs->t0014;
	if (dwArg08 != 0x20)
	{
		ebx_131 = &g_b80B24A4;
		if (dwArg08 != 0x30)
		{
			ebx_131 = fp - 33;
			while (true)
			{
				*ebx_131 = cl_197;
				byte * eax_38 = ebx_131 - 0x01;
				if (ebx_131 == fp - 0x30)
					break;
				ebx_131 = eax_38;
			}
		}
	}
	Eq_2 esi_103;
	Eq_2 ecx_100 = dwArg08;
	if (dwArg0C > 0x0F)
	{
		esi_103.u0 = 0x00;
		do
		{
			Eq_2 eax_66 = *((word32) dwArg04 + 0x0094);
			if (eax_66 >= 135066356)
			{
				word32 ecx_323;
				word32 edx_324;
				_IO_vtable_check(out ecx_323, out edx_324);
			}
			word32 eax_99;
			(*((word32) eax_66 + 28))();
			esi_103 = (word32) esi_103 + eax_99;
			if (eax_99 != 0x10)
				goto l08083C86;
			ebp_107 -= 0x10;
		} while (ebp_107 > 0x0F);
	}
	else
		esi_103.u0 = 0x00;
	if (ebp_107 > 0x00)
	{
		Eq_2 edx_119 = *((word32) dwArg04 + 0x0094);
		if (edx_119 >= 135066356)
		{
			word32 ecx_321;
			word32 edx_322;
			_IO_vtable_check(out ecx_321, out edx_322);
		}
		word32 eax_159;
		(*((word32) edx_119 + 28))();
		esi_103 = (byte) esi_103.u0 + eax_159;
	}
l08083C86:
	struct Eq_75762 * edi_170 = esi_25 ^ gs->t0014;
	if (edi_170 != null)
	{
		word32 edx_326;
		word32 ecx_325;
		__stack_chk_fail(out ecx_325, out edx_326);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 ecx_184;
		struct Eq_75758 * edx_185;
		word32 ebx_330;
		word32 edi_333;
		word32 ebp_331;
		word32 esi_332;
		Eq_2 eax_183 = _IO_wpadn(gs, stackArg4, stackArg8, stackArg12, out ecx_184, out edx_185, out ebx_330, out ebp_331, out esi_332, out edi_333);
		ecxOut = ecx_184;
		edxOut = edx_185;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi_103;
		ediOut = edi_170;
		return eax_183;
	}
	else
	{
		ecxOut = ecx_100;
		edxOut = edx;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return esi_103;
	}
}

// 08083CB0: Register (ptr32 word32) _IO_wpadn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out (ptr32 word32) edxOut, Register out Eq_952 ebxOut, Register out Eq_952 ebpOut, Register out (ptr32 word32) esiOut, Register out (ptr32 Eq_78606) ediOut)
// Called from:
//      __printf_fp_l
//      __printf_fphex
//      printf_positional
//      __vfwprintf
//      _IO_padn
word32 * _IO_wpadn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, word32 & edxOut, union Eq_952 & ebxOut, union Eq_952 & ebpOut, word32 & esiOut, struct Eq_78606 & ediOut)
{
	word32 * ebx_129 = &g_dw80B2520;
	Eq_2 ecx_158 = dwArg08;
	Eq_2 ebp_105 = dwArg0C;
	Eq_2175 esi_25 = gs->t0014;
	if (dwArg08 != 0x20)
	{
		ebx_129 = &g_dw80B24E0;
		if (dwArg08 != 0x30)
		{
			ebx_129 = fp - 0x24;
			while (true)
			{
				*ebx_129 = (word32) dwArg08;
				word32 * eax_38 = ebx_129 - 0x04;
				if (ebx_129 == fp - 0x60)
					break;
				ebx_129 = eax_38;
			}
		}
	}
	word32 * esi_101;
	if (dwArg0C > 0x0F)
	{
		esi_101 = null;
		do
		{
			Eq_2 eax_64 = *((word32) dwArg04 + 0x0094);
			if (eax_64 >= 135066356)
			{
				word32 edx_318;
				word32 ecx_317;
				_IO_vtable_check(out ecx_317, out edx_318);
			}
			word32 eax_97;
			(*((word32) eax_64 + 28))();
			esi_101 += eax_97;
			if (eax_97 != 0x10)
				goto l08083DB6;
			ebp_105 -= 0x10;
		} while (ebp_105 > 0x0F);
	}
	else
		esi_101 = null;
	if (ebp_105 > 0x00)
	{
		Eq_2 edx_117 = *((word32) dwArg04 + 0x0094);
		if (edx_117 >= 135066356)
		{
			word32 edx_316;
			word32 ecx_315;
			_IO_vtable_check(out ecx_315, out edx_316);
		}
		word32 eax_157;
		(*((word32) edx_117 + 28))();
		esi_101 += eax_157;
	}
l08083DB6:
	struct Eq_78606 * edi_168 = esi_25 ^ gs->t0014;
	if (edi_168 != null)
	{
		word32 ecx_319;
		word32 edx_320;
		__stack_chk_fail(out ecx_319, out edx_320);
		Eq_2 ecx_182;
		word32 * edx_183;
		word32 * eax_181 = save_for_wbackup.isra.0(eax, ecx, edx_183, out ecx_182, out edx_183);
		ecxOut = ecx_182;
		edxOut = edx_183;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi_101;
		ediOut = edi_168;
		return eax_181;
	}
	else
	{
		ecxOut = ecx_158;
		edxOut = edx;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return esi_101;
	}
}

// 08083DE0: Register (ptr32 word32) save_for_wbackup.isra.0(Register (ptr32 word32) eax, Register Eq_2 ecx, Register (ptr32 word32) edx, Register out Eq_96595 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _IO_wpadn
//      _IO_wdefault_pbackfail
//      __wuflow
//      __wunderflow
word32 * save_for_wbackup.isra.0(word32 * eax, Eq_2 ecx, word32 * edx, union Eq_96595 & ecxOut, union Eq_2 & edxOut)
{
	word32 * eax_310;
	Eq_2 edi_251;
	struct Eq_96603 * ebx_183;
	int32 edi_192;
	struct Eq_96603 * ebx_27 = *edx;
	Eq_2 edi_28 = ebx_27->t0008;
	Eq_2 edx_186 = ebx_27->t0020;
	Eq_2 edi_32 = ebx_27->t0028;
	Eq_96595 ecx_289 = ecx - edi_28;
	int32 edi_36 = edi_32 - edx_186;
	struct Eq_96625 * eax_25 = *eax;
	int32 esi_197 = ecx_289 >> 0x02;
	int32 dwLoc40_343 = edi_36 >> 0x02;
	if (eax_25 != null)
	{
		ecx_289 >>= 0x02;
		struct Eq_96625 * edx_54 = eax_25;
		do
		{
			int32 ebp_57 = edx_54->dw0008;
			edx_54 = edx_54->ptr0000;
			if (esi_197 > ebp_57)
				esi_197 = ebp_57;
		} while (edx_54 != null);
		Eq_2 ebp_72 = (ecx_289 >> 0x02) - esi_197;
		if (ebp_72 > edi_36 >> 0x02)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 eax_77 = ebp_72 * 0x04 + 400;
			Eq_2 stackArg0 = <invalid>;
			word32 edi_471;
			word32 ebx_468;
			word32 edx_467;
			word32 esi_470;
			word32 ebp_469;
			Eq_2 eax_90 = __libc_malloc(gs, stackArg0, eax_77, out ecx_289, out edx_467, out ebx_468, out ebp_469, out esi_470, out edi_471);
			edx_186 = eax_90;
			if (eax_90 == 0x00)
			{
				eax_310 = (word32 *) ~0x00;
l08083E8B:
				ecxOut = ecx_289;
				edxOut = edx_186;
				return eax_310;
			}
			ui32 eax_98 = esi_197 * 0x04;
			edi_251 = (word32) eax_90 + 400;
			if (esi_197 >= 0x00)
			{
				word32 edx_472;
				__wmemcpy((word32) eax_90 + 400, (word32) edi_28 + eax_98, ebp_72, out edx_472);
			}
			else
				__wmempcpy(__wmempcpy((word32) eax_90 + 400, (word32) edi_32 + eax_98, -esi_197), edi_28, ecx_289 >> 0x02);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_474;
			word32 edx_475;
			free(gs, stackArg0, *edx + 0x20, out ecx_474, out edx_475);
			ebx_183 = *edx;
			ebx_183->t0020 = eax_90;
			edx_186 = eax_90 + eax_77;
			ebx_183->t0028 = edx_186;
			goto l08083F15;
		}
		int32 edi_189 = (edi_36 >> 0x02) - ebp_72;
		dwLoc40_343 = edi_189;
		edi_192 = edi_189 << 0x02;
		edx_186 = (word32) edx_186 + (edi_189 << 0x02);
		if (esi_197 >= 0x00)
		{
			if (ebp_72 == 0x00)
			{
				ebx_27->t0024 = edx_186;
				goto l08083E80;
			}
			__wmemcpy(edx_186, (word32) edi_28 + esi_197 * 0x04, ebp_72, out edx_186);
			ebx_183 = *edx;
			edi_251 = (word32) ebx_183->t0020 + (edi_189 << 0x02);
l08083F19:
			ecx_289 = ecx - ebx_183->t0008 >> 0x02;
			eax_25 = *eax;
			ebx_183->t0024 = edi_251;
			if (eax_25 == null)
			{
l08083E89:
				eax_310 = null;
				goto l08083E8B;
			}
l08083E80:
			do
			{
				eax_25->dw0008 -= ecx_289;
				eax_25 = eax_25->ptr0000;
			} while (eax_25 != null);
			goto l08083E89;
		}
	}
	else
	{
		edi_192 = edi_36;
		if (ecx_289 >= 0x00)
		{
			ebx_27->t0024 = edi_32;
			goto l08083E89;
		}
		edx_186 = edi_32;
		esi_197 = ecx_289 >> 0x02;
	}
	wmemmove(edx_186, (word32) edi_32 + esi_197 * 0x04, -esi_197);
	struct Eq_96603 * ecx_224 = *edx;
	Eq_2 edx_226 = ecx_224->t0008;
	__wmemcpy((word32) ecx_224->t0020 + (dwLoc40_343 - esi_197) * 0x04, edx_226, ecx - edx_226 >> 0x02, out edx_186);
	ebx_183 = *edx;
	edi_251 = (word32) ebx_183->t0020 + edi_192;
	goto l08083F19;
}

// 08084020: void _IO_least_wmarker(Stack (ptr32 Eq_96817) dwArg04, Stack int32 dwArg08)
void _IO_least_wmarker(struct Eq_96817 * dwArg04, int32 dwArg08)
{
	struct Eq_96819 * edx_16 = dwArg04->ptr0030;
	int32 eax_10 = dwArg08 - (dwArg04->ptr0058)->dw0008 >> 0x02;
	while (edx_16 != null)
	{
		int32 ecx_18 = edx_16->dw0008;
		edx_16 = edx_16->ptr0000;
		if (eax_10 > ecx_18)
			eax_10 = ecx_18;
	}
}

// 08084050: void _IO_switch_to_main_wget_area(Stack (ptr32 Eq_96845) dwArg04)
void _IO_switch_to_main_wget_area(struct Eq_96845 * dwArg04)
{
	dwArg04->dw0000 &= ~0x0100;
	struct Eq_96854 * eax_10 = dwArg04->ptr0058;
	word32 ecx_12 = eax_10->dw0028;
	eax_10->dw0028 = eax_10->dw0004;
	word32 edx_14 = eax_10->dw0020;
	eax_10->dw0004 = ecx_12;
	word32 ecx_16 = eax_10->dw0008;
	eax_10->dw0000 = edx_14;
	eax_10->dw0008 = edx_14;
	eax_10->dw0020 = ecx_16;
}

// 08084080: void _IO_switch_to_wbackup_area(Stack (ptr32 Eq_96888) dwArg04)
void _IO_switch_to_wbackup_area(struct Eq_96888 * dwArg04)
{
	dwArg04->dw0000 |= 0x0100;
	struct Eq_96897 * eax_12 = dwArg04->ptr0058;
	word32 edx_14 = eax_12->dw0028;
	word32 ebx_15 = eax_12->dw0020;
	eax_12->dw0028 = eax_12->dw0004;
	word32 ecx_17 = eax_12->dw0008;
	eax_12->dw0004 = edx_14;
	eax_12->dw0008 = ebx_15;
	eax_12->dw0020 = ecx_17;
	eax_12->dw0000 = edx_14;
}

// 080840B0: Register word32 _IO_wsetb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack ptr32 dwArg0C, Stack word32 dwArg10, Register out Eq_2 edxOut)
// Called from:
//      _IO_file_close_it
//      _IO_cleanup
//      _IO_wfile_doallocate
//      _IO_wdoallocbuf
//      _IO_wdefault_doallocate
word32 _IO_wsetb(Eq_2 dwArg04, Eq_2 dwArg08, ptr32 dwArg0C, word32 dwArg10, union Eq_2 & edxOut)
{
	Eq_2 eax_15 = *((word32) dwArg04 + 60);
	Eq_2 edx_14 = *((word32) dwArg04 + 88);
	byte al_20 = (byte) eax_15;
	Eq_2 ecx_16 = *((word32) edx_14 + 24);
	if (ecx_16 != 0x00 && (al_20 & 0x08) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_88;
		word32 edx_89;
		free(gs, stackArg0, ecx_16, out ecx_88, out edx_89);
		edx_14 = *((word32) dwArg04 + 88);
		eax_15 = *((word32) dwArg04 + 60);
	}
	*((word32) edx_14 + 24) = dwArg08;
	*((word32) edx_14 + 28) = dwArg0C;
	Eq_2 eax_46 = eax_15 | 0x08;
	Eq_2 edx_47 = eax_15 & ~0x08;
	if (dwArg10 != 0x00)
		eax_46 = edx_47;
	*((word32) dwArg04 + 60) = eax_46;
	edxOut = edx_47;
	return dwArg10;
}

// 08084120: void _IO_wdefault_pbackfail(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_96984) dwArg04, Stack Eq_2 dwArg08)
void _IO_wdefault_pbackfail(struct Eq_9 * gs, struct Eq_96984 * dwArg04, Eq_2 dwArg08)
{
	Eq_2 ecx_143;
	Eq_2 eax_127;
	ui32 edx_21 = dwArg04->dw0000;
	struct Eq_96992 * esi_133 = dwArg04->ptr0058;
	struct Eq_96984 * ebp_128 = dwArg04;
	byte dh_170 = SLICE(edx_21, byte, 8);
	byte dl_177 = (byte) edx_21;
	word16 edx_16_16_181 = SLICE(edx_21, word16, 16);
	Eq_2 edi_147 = esi_133->t0000;
	Eq_2 ecx_23 = esi_133->t0008;
	if (edi_147 > ecx_23)
	{
		if ((edx_21 & 0x0100) != 0x00)
			goto l08084158;
		struct Eq_97019 * ecx_108 = dwArg04->ptr0004;
		if ((int32) ecx_108->bFFFFFFFF == dwArg08)
		{
			dwArg04->ptr0004 = ecx_108 - 0x01;
			return;
		}
		if (esi_133->t0020 != 0x00)
		{
			word32 ecx_292;
			word32 edx_293;
			if (save_for_wbackup.isra.0((char *) &dwArg04->ptr0004 + 44, edi_147, &dwArg04->ptr0058, out ecx_292, out edx_293) != null)
				return;
			ui32 edx_166 = dwArg04->dw0000;
			esi_133 = dwArg04->ptr0058;
			dh_170 = SLICE(edx_166, byte, 8);
			dl_177 = (byte) edx_166;
			edx_16_16_181 = SLICE(edx_166, word16, 16);
			ecx_143 = esi_133->t0000;
			edi_147 = esi_133->t0028;
			eax_127 = esi_133->t0020;
			goto l08084234;
		}
	}
	else
	{
		if ((edx_21 & 0x0100) != 0x00)
		{
			Eq_2 eax_44 = (esi_133->t0004 - ecx_23 >> 0x02) * 0x08;
			struct Eq_97050 * ebp_50;
			word32 edi_53;
			Eq_2 esi_55;
			word32 ebx_285;
			word32 ecx_283;
			word32 edx_284;
			Eq_2 eax_49 = __libc_malloc(gs, dwLoc40, eax_44, out ecx_283, out edx_284, out ebx_285, out ebp_50, out esi_55, out edi_53);
			if (eax_49 == 0x00)
				return;
			edi_147 = (word32) eax_49 + edi_53;
			word32 edx_286;
			__wmemcpy(edi_147, ecx_23, esi_55, out edx_286);
			word32 ecx_287;
			word32 edx_288;
			free(gs, dwLoc40, ebp_50->ptr0058->t0008, out ecx_287, out edx_288);
			esi_133 = ebp_50->ptr0058;
			esi_133->t0008 = eax_49;
			esi_133->t0000 = edi_147;
			Mem103[esi_133 + 0x04:word32] = eax_49 + eax_44;
			esi_133->t0024 = edi_147;
l08084158:
			esi_133->t0000 = edi_147 - 0x04;
			*((word32) edi_147 - 4) = dwArg08;
			return;
		}
		eax_127 = esi_133->t0020;
		if (eax_127 != 0x00)
		{
			ecx_143 = edi_147;
			edi_147 = esi_133->t0028;
			goto l08084234;
		}
	}
	Eq_2 edi_131;
	word32 ecx_289;
	word32 edx_290;
	word32 ebx_291;
	eax_127 = __libc_malloc(gs, dwLoc40, 0x0200, out ecx_289, out edx_290, out ebx_291, out ebp_128, out esi_133, out edi_131);
	if (eax_127 == 0x00)
		return;
	esi_133->t0020 = eax_127;
	esi_133->t0028 = (word32) eax_127 + 0x0200;
	esi_133->t0024 = (word32) eax_127 + 0x0200;
	ecx_143 = edi_131;
	dh_170 = SLICE(edx_21, byte, 8);
	dl_177 = (byte) edx_21;
	edx_16_16_181 = SLICE(edx_21, word16, 16);
	edi_147 = (word32) eax_127 + 0x0200;
l08084234:
	ebp_128->dw0000 = SEQ(edx_16_16_181, dh_170 | 0x01, dl_177);
	Eq_2 edx_189 = esi_133->t0004;
	esi_133->t0008 = eax_127;
	esi_133->t0004 = edi_147;
	esi_133->t0028 = edx_189;
	esi_133->t0020 = ecx_143;
	esi_133->t0000 = edi_147;
	goto l08084158;
}

// 080842B0: void _IO_wdefault_finish(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wdefault_finish(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_14 = *((word32) dwArg04 + 88);
	Eq_2 eax_15 = *((word32) edx_14 + 24);
	if (eax_15 != 0x00 && (*((word32) dwArg04 + 60) & 0x08) == 0x00)
	{
		word32 edx_125;
		word32 ecx_124;
		free(gs, dwLoc20, eax_15, out ecx_124, out edx_125);
		edx_14 = *((word32) dwArg04 + 88);
		*((word32) edx_14 + 28) = 0x00;
		((word32) edx_14 + 24)->u0 = 0x00;
	}
	struct Eq_97213 * eax_41;
	for (eax_41 = *((word32) dwArg04 + 48); eax_41 != null; eax_41 = eax_41->ptr0000)
		eax_41->dw0004 = 0x00;
	if (*((word32) dwArg04 + 36) != 0x00)
	{
		word32 ecx_126;
		word32 edx_127;
		free(gs, dwLoc20, *((word32) edx_14 + 32), out ecx_126, out edx_127);
		*((word32) dwArg04 + 36) = 0x00;
	}
	_IO_un_link(dwArg04);
}

// 08084340: void _IO_wdefault_uflow(Stack (ptr32 Eq_97273) dwArg04)
void _IO_wdefault_uflow(struct Eq_97273 * dwArg04)
{
	struct Eq_97274 * esi_16 = dwArg04->ptr0094;
	if (esi_16 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_89;
		word32 ecx_88;
		_IO_vtable_check(out ecx_88, out edx_89);
	}
	word32 eax_38;
	esi_16->ptr0010();
	if (eax_38 == ~0x00)
		return;
	word32 * edx_51 = dwArg04->ptr0058;
	*edx_51 += 0x04;
}

// 080843B0: Register word32 __woverflow(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 (arr Eq_2)) ecxOut)
// Called from:
//      __printf_fp_l
//      __printf_fphex
//      _IO_helper_overflow
//      printf_positional
//      _IO_wdefault_xsputn
word32 __woverflow(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 (& ecxOut)
{
	if (*((word32) dwArg04 + 0x0068) == 0x00)
	{
		word32 esi_106;
		word32 ebp_105;
		word32 ecx_103;
		word32 edx_104;
		_IO_fwide(gs, dwArg04, 0x01, out ecx_103, out edx_104, out ebp_105, out esi_106);
	}
	Eq_2 ebp_39 = *((word32) dwArg04 + 0x0094);
	if (ebp_39 >= 135066356)
	{
		word32 ecx_107;
		word32 edx_108;
		_IO_vtable_check(out ecx_107, out edx_108);
	}
	word32 eax_73;
	Eq_2 (* ecx_75)[];
	(*((word32) ebp_39 + 0x0C))();
	ecxOut = ecx_75;
	return eax_73;
}

// 08084430: Register Eq_16661 _IO_wdefault_xsputn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_16661 dwArg0C)
// Called from:
//      _IO_wfile_xsputn
Eq_16661 _IO_wdefault_xsputn(Eq_2 dwArg04, Eq_2 dwArg08, Eq_16661 dwArg0C)
{
	if (dwArg0C == 0x00)
		return 0x00;
	Eq_16661 ebp_139 = dwArg0C;
l08084484:
	Eq_2 edx_38 = *((word32) dwArg04 + 88);
	Eq_2 edi_39 = *((word32) edx_38 + 16);
	Eq_2 esi_114 = dwArg08;
	int32 ebx_41 = *((word32) edx_38 + 20) - edi_39;
	if (ebx_41 > 0x00)
	{
		Eq_16661 ebx_44 = ebx_41 >> 0x02;
		if (ebx_41 >> 0x02 > ebp_139)
			ebx_44 = ebp_139;
		if (ebx_44 > 0x14)
		{
			*((word32) edx_38 + 16) = __wmempcpy(edi_39, dwArg08, ebx_44);
			ebp_139 -= ebx_44;
			esi_114 = (word32) dwArg08 + ebx_44 * 0x04;
			if (ebp_139 == 0x00)
				return dwArg0C;
l08084460:
			dwArg08 = (word32) esi_114 + 4;
			word32 ecx_253;
			if (__woverflow(dwArg04, *esi_114, out ecx_253) == ~0x00)
			{
				dwArg0C -= ebp_139;
				return dwArg0C;
			}
			--ebp_139;
			goto l08084484;
		}
		esi_114 = dwArg08;
		if (ebx_44 != 0x00)
		{
			ui32 ecx_58 = ebx_44 * 0x04;
			Eq_2 eax_60 = (word32) edi_39 + ecx_58;
			Eq_2 esi_61 = dwArg08;
			do
			{
				*edi_39 = *esi_61;
				esi_61 = (word32) esi_61 + 4;
				edi_39 = (word32) edi_39 + 4;
			} while (eax_60 != edi_39);
			*((word32) edx_38 + 16) = eax_60;
			ebp_139 -= ebx_44;
			esi_114 = (word32) dwArg08 + ecx_58;
		}
	}
	if (ebp_139 == 0x00)
		return dwArg0C;
	goto l08084460;
}

// 08084520: void _IO_wdoallocbuf(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow
//      _IO_wfile_underflow_mmap
//      _IO_wfile_overflow
void _IO_wdoallocbuf(Eq_2 dwArg04)
{
	Eq_2 eax_28 = *((word32) dwArg04 + 88);
	if (*((word32) eax_28 + 24) != 0x00)
		return;
	if ((*dwArg04 & 0x02) == 0x00)
	{
		Eq_2 eax_19 = *((word32) eax_28 + 0x00B0);
		word32 eax_22;
		(*((word32) eax_19 + 52))();
		if (eax_22 != ~0x00)
			return;
		eax_28 = *((word32) dwArg04 + 88);
	}
	word32 edx_88;
	_IO_wsetb(dwArg04, (word32) eax_28 + 0x00AC, (word32) eax_28 + 0x00B0, 0x00, out edx_88);
}

// 08084580: void _IO_wdefault_doallocate(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wdefault_doallocate(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 ebx_89;
	word32 edx_88;
	word32 ecx_87;
	word32 ebp_90;
	word32 esi_91;
	word32 edi_92;
	Eq_2 eax_14 = __libc_malloc(gs, dwLoc20, 0x2000, out ecx_87, out edx_88, out ebx_89, out ebp_90, out esi_91, out edi_92);
	if (eax_14 == 0x00)
		return;
	word32 edx_93;
	_IO_wsetb(dwArg04, eax_14, (word32) eax_14 + 0x00008000, 0x01, out edx_93);
}

// 080845E0: Register word32 _IO_switch_to_wget_mode(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
//      __wuflow
//      __wunderflow
//      _IO_init_wmarker
word32 _IO_switch_to_wget_mode(Eq_2 dwArg04)
{
	word32 eax_23;
	Eq_2 eax_12 = *((word32) dwArg04 + 88);
	up32 edx_13 = *((word32) eax_12 + 16);
	if (edx_13 > *((word32) eax_12 + 0x0C))
	{
		Eq_2 eax_18 = *((word32) eax_12 + 0x00B0);
		(*((word32) eax_18 + 0x0C))();
		if (eax_23 == ~0x00)
			return eax_23;
		eax_12 = *((word32) dwArg04 + 88);
		edx_13 = (up32) *((word32) eax_12 + 16);
	}
	word32 ecx_34 = *dwArg04;
	byte ch_35 = SLICE(ecx_34, byte, 8);
	byte cl_59 = (byte) ecx_34;
	word16 ecx_16_16_61 = SLICE(ecx_34, word16, 16);
	if ((ch_35 & 0x01) == 0x00)
	{
		*((word32) eax_12 + 8) = *((word32) eax_12 + 24);
		if (*((word32) eax_12 + 4) < edx_13)
			*((word32) eax_12 + 4) = edx_13;
	}
	else
		*((word32) eax_12 + 8) = *((word32) eax_12 + 36);
	*eax_12 = edx_13;
	*((word32) eax_12 + 20) = edx_13;
	*((word32) eax_12 + 0x0C) = edx_13;
	*dwArg04 = SEQ(ecx_16_16_61, ch_35 & ~0x08, cl_59);
	eax_23 = 0x00;
	return eax_23;
}

// 08084650: void _IO_free_wbackup_area(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
//      _IO_wfile_overflow
//      _IO_file_close_it
//      __wuflow
//      __wunderflow
//      _IO_unsave_wmarkers
void _IO_free_wbackup_area(Eq_2 dwArg04)
{
	word32 ecx_17 = *dwArg04;
	Eq_2 eax_16 = *((word32) dwArg04 + 88);
	byte ch_19 = SLICE(ecx_17, byte, 8);
	byte cl_27 = (byte) ecx_17;
	word16 ecx_16_16_28 = SLICE(ecx_17, word16, 16);
	Eq_2 edx_18 = *((word32) eax_16 + 32);
	if ((ch_19 & 0x01) != 0x00)
	{
		word32 edi_26 = *((word32) eax_16 + 40);
		*dwArg04 = SEQ(ecx_16_16_28, ch_19 & ~0x01, cl_27);
		word32 ecx_31 = *((word32) eax_16 + 4);
		*((word32) eax_16 + 4) = edi_26;
		*((word32) eax_16 + 40) = ecx_31;
		Eq_2 ecx_34 = *((word32) eax_16 + 8);
		*eax_16 = edx_18;
		*((word32) eax_16 + 32) = ecx_34;
		*((word32) eax_16 + 8) = edx_18;
		edx_18 = ecx_34;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_80;
	word32 edx_81;
	free(gs, stackArg0, edx_18, out ecx_80, out edx_81);
	Eq_2 eax_53 = *((word32) dwArg04 + 88);
	*((word32) eax_53 + 32) = 0x00;
	*((word32) eax_53 + 40) = 0x00;
	*((word32) eax_53 + 36) = 0x00;
}

// 080846C0: void __wuflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void __wuflow(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esi_13 = dwArg04;
	Eq_2 edi_16 = *((word32) dwArg04 + 0x0068);
	if (edi_16 < 0x00)
		return;
	if (edi_16 == 0x00)
	{
		word32 edx_317;
		word32 ecx_316;
		word32 ebp_318;
		if (_IO_fwide(gs, dwArg04, 0x01, out ecx_316, out edx_317, out ebp_318, out esi_13) != 0x01)
			return;
		if (*((word32) esi_13 + 0x0068) == 0x00)
		{
			word32 ecx_323;
			word32 edx_324;
			word32 ebp_325;
			_IO_fwide(gs, esi_13, 0x01, out ecx_323, out edx_324, out ebp_325, out esi_13);
		}
	}
	if ((*esi_13 & 0x0800) != 0x00 && _IO_switch_to_wget_mode(esi_13) == ~0x00)
		return;
	Eq_2 eax_87 = *((word32) esi_13 + 88);
	Eq_2 edx_103 = *eax_87;
	Eq_2 ecx_89 = *((word32) eax_87 + 4);
	if (edx_103 >= ecx_89)
	{
		ui32 edx_92 = *esi_13;
		byte dh_93 = SLICE(edx_92, byte, 8);
		byte dl_99 = (byte) edx_92;
		word16 edx_16_16_100 = SLICE(edx_92, word16, 16);
		if ((dh_93 & 0x01) == 0x00)
		{
l0808472A:
			if (*((word32) esi_13 + 48) != 0x00)
			{
				word32 ecx_319;
				word32 edx_320;
				if (save_for_wbackup.isra.0((word32) esi_13 + 48, *((word32) eax_87 + 4), (word32) esi_13 + 88, out ecx_319, out edx_320) != null)
					return;
			}
			else if (*((word32) eax_87 + 32) != 0x00)
				_IO_free_wbackup_area(esi_13);
			Eq_2 edi_176 = *((word32) esi_13 + 0x0094);
			if (edi_176 >= 135066356)
			{
				word32 edx_322;
				word32 ecx_321;
				_IO_vtable_check(out ecx_321, out edx_322);
			}
			word32 edx_214;
			word32 ecx_215;
			(*((word32) edi_176 + 20))();
			return;
		}
		Eq_2 edi_98 = *((word32) eax_87 + 40);
		*esi_13 = SEQ(edx_16_16_100, dh_93 & ~0x01, dl_99);
		edx_103 = *((word32) eax_87 + 32);
		*((word32) eax_87 + 40) = ecx_89;
		Eq_2 ecx_105 = *((word32) eax_87 + 8);
		*((word32) eax_87 + 4) = edi_98;
		*((word32) eax_87 + 8) = edx_103;
		*((word32) eax_87 + 32) = ecx_105;
		if (edi_98 <= edx_103)
		{
			*eax_87 = edx_103;
			goto l0808472A;
		}
	}
	*eax_87 = (word32) edx_103 + 4;
}

// 08084820: Register word32 __wunderflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      _IO_wdefault_xsgetn
word32 __wunderflow(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & ebpOut)
{
	Eq_2 esi_13 = dwArg04;
	Eq_2 edi_16 = *((word32) dwArg04 + 0x0068);
	if (edi_16 >= 0x00)
	{
		if (edi_16 == 0x00)
		{
			word32 ecx_316;
			word32 edx_317;
			if (_IO_fwide(gs, dwArg04, 0x01, out ecx_316, out edx_317, out ebp, out esi_13) != 0x01)
				goto l080848ED;
			if (*((word32) esi_13 + 0x0068) == 0x00)
			{
				word32 ecx_322;
				word32 edx_323;
				_IO_fwide(gs, esi_13, 0x01, out ecx_322, out edx_323, out ebp, out esi_13);
			}
		}
		if ((*esi_13 & 0x0800) == 0x00 || _IO_switch_to_wget_mode(esi_13) != ~0x00)
		{
			Eq_2 eax_87 = *((word32) esi_13 + 88);
			Eq_2 edx_103 = *eax_87;
			Eq_2 ecx_89 = *((word32) eax_87 + 4);
			if (edx_103 >= ecx_89)
			{
				ui32 edx_92 = *esi_13;
				byte dh_93 = SLICE(edx_92, byte, 8);
				byte dl_99 = (byte) edx_92;
				word16 edx_16_16_100 = SLICE(edx_92, word16, 16);
				if ((dh_93 & 0x01) == 0x00)
				{
l0808488A:
					if (*((word32) esi_13 + 48) == 0x00)
					{
						if (*((word32) esi_13 + 36) != 0x00)
							_IO_free_wbackup_area(esi_13);
						goto l080848A7;
					}
					word32 ecx_318;
					word32 edx_319;
					if (save_for_wbackup.isra.0((word32) esi_13 + 48, *((word32) eax_87 + 4), (word32) esi_13 + 88, out ecx_318, out edx_319) == null)
					{
l080848A7:
						Eq_2 edi_174 = *((word32) esi_13 + 0x0094);
						if (edi_174 >= 135066356)
						{
							word32 ecx_320;
							word32 edx_321;
							_IO_vtable_check(out ecx_320, out edx_321);
						}
						word32 eax_211;
						word32 edx_212;
						word32 ecx_213;
						(*((word32) edi_174 + 16))();
						ebpOut = ebp;
						return eax_211;
					}
					goto l080848ED;
				}
				Eq_2 edi_98 = *((word32) eax_87 + 40);
				*esi_13 = SEQ(edx_16_16_100, dh_93 & ~0x01, dl_99);
				edx_103 = *((word32) eax_87 + 32);
				*((word32) eax_87 + 40) = ecx_89;
				Eq_2 ecx_105 = *((word32) eax_87 + 8);
				*((word32) eax_87 + 4) = edi_98;
				*((word32) eax_87 + 8) = edx_103;
				*((word32) eax_87 + 32) = ecx_105;
				*eax_87 = edx_103;
				if (edi_98 <= edx_103)
					goto l0808488A;
			}
			word32 eax_118 = *edx_103;
			ebpOut = ebp;
			return eax_118;
		}
	}
l080848ED:
	ebpOut = ebp;
	return ~0x00;
}

// 08084980: void _IO_wdefault_xsgetn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_16661 dwArg0C)
void _IO_wdefault_xsgetn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_16661 dwArg0C)
{
	Eq_16661 ebp_115 = dwArg0C;
	do
	{
		Eq_2 eax_22 = *((word32) dwArg04 + 88);
		Eq_2 esi_23 = *eax_22;
		int32 ebx_25 = *((word32) eax_22 + 4) - esi_23;
		if (ebx_25 > 0x00)
		{
			Eq_16661 ebx_28 = ebx_25 >> 0x02;
			if (ebx_25 >> 0x02 > ebp_115)
				ebx_28 = ebp_115;
			if (ebx_28 > 0x14)
			{
				dwArg08 = __wmempcpy(dwArg08, esi_23, ebx_28);
				Eq_2 eax_93 = *((word32) dwArg04 + 88);
				*eax_93 = (word32) *eax_93 + ebx_28 * 0x04;
				if (ebp_115 - ebx_28 == 0x00)
					return;
				goto l080849A0;
			}
			if (ebx_28 != 0x00)
			{
				ui32 edx_39 = ebx_28 * 0x04;
				Eq_2 edi_42 = dwArg08;
				Eq_2 ecx_44 = (word32) esi_23 + edx_39;
				do
				{
					*edi_42 = *esi_23;
					esi_23 = (word32) esi_23 + 4;
					edi_42 = (word32) edi_42 + 4;
				} while (ecx_44 != esi_23);
				*eax_22 = ecx_44;
				dwArg08 = (word32) dwArg08 + edx_39;
				ebp_115 -= ebx_28;
			}
		}
		if (ebp_115 == 0x00)
			return;
l080849A0:
	} while (__wunderflow(gs, dwArg04, out ebp_115) != ~0x00);
}

// 08084A50: void _IO_sputbackwc(Stack (ptr32 Eq_98036) dwArg04, Stack word32 dwArg08)
void _IO_sputbackwc(struct Eq_98036 * dwArg04, word32 dwArg08)
{
	word32 eax_26;
	struct Eq_98039 * eax_17 = dwArg04->ptr0058;
	Eq_2 esp_12 = fp - 0x0C;
	struct Eq_98047 * edx_18 = eax_17->ptr0000;
	if (edx_18 > eax_17->ptr0008 && edx_18->dwFFFFFFFC == dwArg08)
	{
		eax_17->ptr0000 = edx_18 - 0x04;
		eax_26 = dwArg08;
	}
	else
	{
		struct Eq_98055 * edi_29 = dwArg04->ptr0094;
		if (edi_29 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 ecx_120;
			word32 edx_121;
			_IO_vtable_check(out ecx_120, out edx_121);
			esp_12.u0 = <invalid>;
		}
		struct Eq_98076 * esp_46 = esp_12 - 0x08;
		esp_46->dwFFFFFFFC = dwArg08;
		esp_46->ptrFFFFFFF8 = dwArg04;
		edi_29->ptr0018();
	}
	if (eax_26 != ~0x00)
		dwArg04->dw0000 &= ~0x10;
}

// 08084AD0: void _IO_sungetwc(Stack (ptr32 Eq_98098) dwArg04)
void _IO_sungetwc(struct Eq_98098 * dwArg04)
{
	word32 eax_44;
	struct Eq_98100 * eax_14 = dwArg04->ptr0058;
	Eq_2 esp_12 = fp - 0x0C;
	struct Eq_98108 * edx_15 = eax_14->ptr0000;
	if (edx_15 > eax_14->ptr0008)
	{
		eax_14->ptr0000 = edx_15 - 0x04;
		eax_44 = edx_15->dwFFFFFFFC;
	}
	else
	{
		struct Eq_98116 * esi_18 = dwArg04->ptr0094;
		if (esi_18 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 edx_92;
			word32 ecx_91;
			_IO_vtable_check(out ecx_91, out edx_92);
			esp_12.u0 = <invalid>;
		}
		struct Eq_98144 * esp_34 = esp_12 - 0x08;
		esp_34->dwFFFFFFFC = ~0x00;
		esp_34->ptrFFFFFFF8 = dwArg04;
		esi_18->ptr0018();
	}
	if (eax_44 != ~0x00)
		dwArg04->dw0000 &= ~0x10;
}

// 08084B50: void _IO_adjust_wcolumn(Stack (ptr32 Eq_98159) dwArg08, Stack ui32 dwArg0C)
void _IO_adjust_wcolumn(struct Eq_98159 * dwArg08, ui32 dwArg0C)
{
	struct Eq_98159 * eax_9 = dwArg08 + dwArg0C;
	if (dwArg08 >= eax_9)
		return;
	struct Eq_98159 * edx_13 = eax_9 - 0x04;
	if (eax_9->dwFFFFFFFC == 0x0A)
		return;
	do
	{
		if (dwArg08 >= edx_13)
			return;
		edx_13 -= 0x04;
	} while (edx_13->dw0000 != 0x0A);
}

// 08084BA0: void _IO_init_wmarker(Stack (ptr32 Eq_98182) dwArg04, Stack Eq_2 dwArg08)
void _IO_init_wmarker(struct Eq_98182 * dwArg04, Eq_2 dwArg08)
{
	byte dh_15 = *((word32) dwArg08 + 1);
	dwArg04->t0004 = dwArg08;
	if ((dh_15 & 0x08) != 0x00)
	{
		_IO_switch_to_wget_mode(dwArg08);
		dh_15 = (byte) *((word32) dwArg08 + 1);
	}
	int32 eax_44;
	Eq_2 ecx_35 = *((word32) dwArg08 + 88);
	int32 eax_36 = *ecx_35;
	if ((dh_15 & 0x01) != 0x00)
		eax_44 = eax_36 - *((word32) ecx_35 + 4) >> 0x02;
	else
		eax_44 = eax_36 - *((word32) ecx_35 + 8) >> 0x02;
	dwArg04->dw0008 = eax_44;
	dwArg04->ptr0000 = (struct Eq_98182 *) *((word32) dwArg08 + 48);
	*((word32) dwArg08 + 48) = dwArg04;
}

// 08084C00: void _IO_wmarker_delta(Stack (ptr32 Eq_98237) dwArg04)
void _IO_wmarker_delta(struct Eq_98237 * dwArg04)
{
	struct Eq_98238 * eax_8 = dwArg04->ptr0004;
	if (eax_8 == null)
		return;
	(eax_8->b0001 & 0x01) != 0x00;
}

// 08084C40: void _IO_seekwmark(Stack (ptr32 Eq_98251) dwArg04, Stack (ptr32 Eq_98252) dwArg08)
void _IO_seekwmark(struct Eq_98251 * dwArg04, struct Eq_98252 * dwArg08)
{
	if (dwArg08->ptr0004 == dwArg04)
	{
		word32 edi_26;
		ui32 ecx_18 = dwArg04->dw0000;
		byte ch_30 = SLICE(ecx_18, byte, 8);
		byte cl_35 = (byte) ecx_18;
		word16 ecx_16_16_36 = SLICE(ecx_18, word16, 16);
		int32 ebx_19 = dwArg08->dw0008;
		struct Eq_98272 * eax_20 = dwArg04->ptr0058;
		if (ebx_19 >= 0x00)
		{
			edi_26 = eax_20->dw0008;
			if ((ecx_18 & 0x0100) != 0x00)
			{
				dwArg04->dw0000 = SEQ(ecx_16_16_36, ch_30 & ~0x01, cl_35);
				word32 ecx_56 = eax_20->dw0028;
				eax_20->dw0028 = eax_20->dw0004;
				word32 edx_58 = eax_20->dw0020;
				eax_20->dw0004 = ecx_56;
				eax_20->dw0020 = edi_26;
				eax_20->dw0008 = edx_58;
				edi_26 = edx_58;
			}
		}
		else
		{
			edi_26 = eax_20->dw0004;
			if ((ecx_18 & 0x0100) == 0x00)
			{
				word32 esi_34 = eax_20->dw0020;
				dwArg04->dw0000 = SEQ(ecx_16_16_36, ch_30 | 0x01, cl_35);
				word32 edx_39 = eax_20->dw0028;
				word32 ecx_40 = eax_20->dw0008;
				eax_20->dw0028 = edi_26;
				eax_20->dw0004 = edx_39;
				eax_20->dw0008 = esi_34;
				eax_20->dw0020 = ecx_40;
				edi_26 = edx_39;
			}
		}
		eax_20->dw0000 = edi_26 + ebx_19 * 0x04;
	}
}

// 08084CD0: void _IO_unsave_wmarkers(Stack Eq_2 dwArg04)
void _IO_unsave_wmarkers(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 48) != 0x00)
		*((word32) dwArg04 + 48) = 0x00;
	if (*((word32) dwArg04 + 36) == 0x00)
		return;
	_IO_free_wbackup_area(dwArg04);
}

// 08084D10: void do_encoding(Stack (ptr32 Eq_98373) dwArg04)
void do_encoding(struct Eq_98373 * dwArg04)
{
	struct Eq_98374 * edx_6 = dwArg04->ptr0024;
	if (edx_6->dw0034 != 0x00)
		return;
	edx_6->dw0024 == edx_6->dw0028;
}

// 08084D40: void do_always_noconv()
void do_always_noconv()
{
}

// 08084D50: void do_max_length()
void do_max_length()
{
}

// 08084D60: void do_in(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack (ptr32 Eq_2) dwArg20)
void do_in(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, union Eq_2 * dwArg20)
{
	struct Eq_98399 * eax_25 = *((word32) dwArg04 + 36);
	Eq_2175 eax_18 = gs->t0014;
	Eq_2 ebx_29 = eax_25->t0014;
	*((word32) dwArg04 + 40) = dwArg18;
	*((word32) dwArg04 + 44) = dwArg1C;
	*((word32) dwArg04 + 60) = dwArg08;
	if (eax_25->dw0000 != 0x00)
		ebx_29 = __ror(ebx_29, 0x09) ^ gs->t0018;
	word32 edx_234;
	word32 ecx_233;
	_dl_mcount_wrapper_check(gs, dwLoc50, ebx_29, out ecx_233, out edx_234);
	int32 eax_87;
	ebx_29();
	*dwArg14 = (union Eq_2 *) dwArg0C;
	*dwArg20 = (union Eq_2 *) *((word32) dwArg04 + 40);
	if ((eax_18 ^ gs->t0014) == 0x00)
		return;
	word32 edx_236;
	word32 ecx_235;
	__stack_chk_fail(out ecx_235, out edx_236);
	do_unshift(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
}

// 08084E50: void do_unshift(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack (ptr32 Eq_2) dwArg20)
// Called from:
//      do_in
void do_unshift(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, union Eq_2 * dwArg20)
{
	Eq_2175 eax_18 = gs->t0014;
	*((word32) dwArg04 + 80) = dwArg0C;
	Eq_2 edi_26 = *((word32) dwArg04 + 76);
	*((word32) dwArg04 + 84) = dwArg10;
	Eq_2 ebx_29 = *((word32) edi_26 + 20);
	*((word32) dwArg04 + 100) = dwArg08;
	if (*edi_26 != 0x00)
		ebx_29 = __ror(ebx_29, 0x09) ^ gs->t0018;
	word32 edx_217;
	word32 ecx_216;
	_dl_mcount_wrapper_check(gs, dwLoc40, ebx_29, out ecx_216, out edx_217);
	int32 eax_76;
	ebx_29();
	*dwArg14 = (union Eq_2 *) *((word32) dwArg04 + 80);
	if ((eax_18 ^ gs->t0014) == 0x00)
		return;
	word32 edx_219;
	word32 ecx_218;
	__stack_chk_fail(out ecx_218, out edx_219);
	do_out(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
}

// 08084F20: void do_out(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack (ptr32 Eq_2) dwArg20)
// Called from:
//      do_unshift
void do_out(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, union Eq_2 * dwArg20)
{
	Eq_2 eax_25 = *((word32) dwArg04 + 76);
	Eq_2175 eax_18 = gs->t0014;
	Eq_2 ebx_29 = *((word32) eax_25 + 20);
	*((word32) dwArg04 + 80) = dwArg18;
	*((word32) dwArg04 + 84) = dwArg1C;
	*((word32) dwArg04 + 100) = dwArg08;
	if (*eax_25 != 0x00)
		ebx_29 = __ror(ebx_29, 0x09) ^ gs->t0018;
	word32 edx_231;
	word32 ecx_230;
	_dl_mcount_wrapper_check(gs, dwLoc50, ebx_29, out ecx_230, out edx_231);
	int32 eax_87;
	ebx_29();
	*dwArg14 = (union Eq_2 *) dwArg0C;
	*dwArg20 = (union Eq_2 *) *((word32) dwArg04 + 80);
	if ((eax_18 ^ gs->t0014) == 0x00)
		return;
	word32 edx_233;
	word32 ecx_232;
	__stack_chk_fail(out ecx_232, out edx_233);
	do_length(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
}

// 08085010: void do_length(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14)
// Called from:
//      do_out
void do_length(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14)
{
	ui32 esi_30 = (dwArg14 << 0x02) + 0x0F;
	struct Eq_98626 * esp_17 = fp - 0x3C;
	Eq_2175 eax_24 = gs->t0014;
	struct Eq_98626 * edx_36 = fp - 0x3C - (esi_30 & ~0x0FFF);
	if (fp - 0x3C != edx_36)
	{
		do
		{
			esp_17 -= 0x1000;
			esp_17->dw0FFC = esp_17->dw0FFC;
		} while (esp_17 != edx_36);
	}
	if ((esi_30 & ~0x0F & 0x0FFF) != 0x00)
	{
		esp_17 -= esi_30 & ~0x0F & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[(esi_30 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[(esi_30 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_98670 * esi_67 = *((word32) dwArg04 + 36);
	*((word32) dwArg04 + 60) = dwArg08;
	*((word32) dwArg04 + 40) = esp_17;
	word32 edx_79 = esi_67->dw0000;
	*((word32) dwArg04 + 44) = esp_17 + (dwArg14 << 0x02) / 0x00001000;
	Eq_2 eax_81 = esi_67->t0014;
	if (edx_79 != 0x00)
		eax_81 = __ror(eax_81, 0x09) ^ gs->t0018;
	struct Eq_98695 * esp_94 = esp_17 - 0x0C;
	esp_94->tFFFFFFFC = eax_81;
	word32 ecx_257;
	word32 edx_258;
	_dl_mcount_wrapper_check(gs, esp_94->tFFFFFFF8, esp_94->tFFFFFFFC, out ecx_257, out edx_258);
	esp_94->tFFFFFFF8.u0 = 0x00;
	esp_94->dwFFFFFFF4 = 0x00;
	esp_94->ptrFFFFFFF0 = fp - 0x24;
	esp_94->dwFFFFFFEC = 0x00;
	esp_94->tFFFFFFE8 = dwArg10;
	esp_94->ptrFFFFFFE4 = fp - 0x28;
	esp_94->ptrFFFFFFE0 = (word32) dwArg04 + 40;
	esp_94->ptrFFFFFFDC = esi_67;
	eax_81();
	if ((eax_24 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_259;
	word32 edx_260;
	__stack_chk_fail(out ecx_259, out edx_260);
	word32 ebp_263;
	word32 esi_264;
	word32 ecx_261;
	word32 edx_262;
	_IO_fwide(gs, dwArg04, dwArg08, out ecx_261, out edx_262, out ebp_263, out esi_264);
}

// 080850F0: Register word32 _IO_fwide(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 ecxOut, Register out Eq_2 edxOut, Register out ptr32 ebpOut, Register out Eq_2 esiOut)
// Called from:
//      __vfwprintf
//      buffered_vfprintf
//      __woverflow
//      __wuflow
//      __wunderflow
//      do_length
word32 _IO_fwide(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & ecxOut, union Eq_2 & edxOut, ptr32 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 edx_24 = dwArg08;
	word32 eax_107 = *((word32) dwArg04 + 0x0068);
	if (dwArg08 >= 0x00)
	{
		if (eax_107 != 0x00 || dwArg08 == 0x00)
			goto l08085129;
		struct Eq_91262 * ebx_39 = *((word32) dwArg04 + 88);
		word32 ecx_43 = ebx_39->dw0004;
		*((word32) dwArg04 + 84) = &ebx_39->dw0038 + 1;
		ebx_39->dw0000 = ecx_43;
		Eq_2 ecx_47 = ebx_39->t000C;
		ebx_39->dw002C = 0x00;
		ebx_39->t0010 = ecx_47;
		ebx_39->dw0030 = 0x00;
		struct Eq_91262 * ecx_51 = *((word32) dwArg04 + 88);
		ecx_51->dw0034 = 0x00;
		ecx_51->dw0038 = 0x00;
		__wcsmbs_clone_conv(gs, fp - 0x30);
		if (dwLoc2C != 0x01)
			goto l0808529B;
		if (dwLoc24 != 0x01)
		{
l0808527F:
			word32 ecx_299;
			word32 edx_300;
			__assert_fail(out ecx_299, out edx_300);
l0808529B:
			word32 edx_298;
			word32 ecx_297;
			__assert_fail(out ecx_297, out edx_298);
			Eq_2 edx_184;
			ptr32 ecx_185;
			word32 eax_183 = __libc_enable_asynccancel(gs, out ecx_185, out edx_184);
			ecxOut = ecx_185;
			edxOut = edx_184;
			ebpOut = 0x080CE000;
			esiOut = dwArg04;
			return eax_183;
		}
		word32 * edi_112 = &ebx_39->dw0038 + 1;
		word32 ecx_115;
		for (ecx_115 = 0x1C; ecx_115 != 0x00; --ecx_115)
		{
			*edi_112 = eax_107;
			++edi_112;
		}
		ebx_39->dw005C = 0x01;
		ebx_39->ptr0040 = 0x08084F20;
		ebx_39->ptr0044 = 0x08084E50;
		ebx_39->ptr0048 = 0x08084D60;
		ebx_39->ptr004C = 0x08084D10;
		ebx_39->ptr0050 = 0x08084D40;
		ebx_39->ptr0054 = 0x08085010;
		ebx_39->ptr0058 = 0x08084D50;
		ebx_39->dw0074 = 0x01;
		ebx_39->dw0060 = dwLoc30;
		struct Eq_91262 * eax_96 = *((word32) dwArg04 + 88);
		ebx_39->dw006C = 0x01;
		Eq_2 eax_99 = eax_96->t00B0;
		ebx_39->dw0084 = 0x01;
		ebx_39->ptr0078 = &eax_96->dw002C;
		ebx_39->ptr0088 = dwLoc28;
		ebx_39->dw009C = 0x01;
		ebx_39->dw0094 = 0x09;
		ebx_39->ptr00A0 = &eax_96->dw002C;
		*((word32) dwArg04 + 0x0094) = eax_99;
		ecx = dwLoc28;
		edx_24 = &eax_96->dw002C;
		eax_107 = 0x01;
	}
	else
	{
		if (eax_107 != 0x00)
			goto l08085129;
		eax_107 = ~0x00;
	}
	*((word32) dwArg04 + 0x0068) = eax_107;
l08085129:
	if ((eax_20 ^ gs->t0014) == 0x00)
	{
		ecxOut = ecx;
		edxOut = edx_24;
		ebpOut = ebp;
		esiOut = esi;
		return eax_107;
	}
	word32 ecx_295;
	word32 edx_296;
	__stack_chk_fail(out ecx_295, out edx_296);
	goto l0808527F;
}

// 080852C0: Register Eq_2 __libc_enable_asynccancel(Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      open
//      read
//      __libc_write
//      _IO_fwide
Eq_2 __libc_enable_asynccancel(struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_15 = gs->t0084;
	while (true)
	{
		Eq_2 eax_21;
		Eq_2 ecx_18 = edx_15 | 0x02;
		if (edx_15 == ecx_18)
			break;
		__lock();
		__cmpxchg(gs->t0084, edx_15 | 0x02, edx_15, out eax_21);
		if (edx_15 == eax_21)
		{
			ecx_18 = (edx_15 | 0x02) & ~0x44;
			if (ecx_18 != 0x0A)
				goto l080852FD;
			gs->dw0228 = ~0x00;
			__lock();
			gs->t0084 |= 0x10;
			fn00000000();
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_43241 stackArg4 = <invalid>;
			Eq_2 edx_49;
			Eq_2 ecx_50;
			Eq_2 eax_51 = __libc_disable_asynccancel(gs, stackArg4, out ecx_50, out edx_49);
			ecxOut = ecx_50;
			edxOut = edx_49;
			return eax_51;
		}
		edx_15 = eax_21;
	}
	eax_21 = edx_15;
l080852FD:
	ecxOut = ecx_18;
	edxOut = edx_15;
	return eax_21;
}

// 08085340: Register Eq_2 __libc_disable_asynccancel(Register (ptr32 Eq_9) gs, Stack Eq_43241 bArg04, Register out Eq_43249 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      open
//      read
//      __libc_write
//      __libc_enable_asynccancel
Eq_2 __libc_disable_asynccancel(struct Eq_9 * gs, Eq_43241 bArg04, union Eq_43249 & ecxOut, union Eq_2 & edxOut)
{
	if ((bArg04 & 0x02) == 0x00)
	{
		Eq_2 ecx_24 = gs->t0084;
		while (true)
		{
			__lock();
			edx = ecx_24 & ~0x02;
			__cmpxchg(gs->t0084, edx, ecx_24, out eax);
			if (ecx_24 == eax)
				break;
			ecx_24 = eax;
		}
		ecx = ecx_24 & 0x0C;
		if (ecx == 0x04)
		{
			do
			{
				word32 edx_56;
				up32 eax_57;
				gs->ptr0010();
				if (eax_57 > ~0x0FFF)
				{
					ecx = eax_57 + 11;
					byte cl_65 = (byte) eax_57 + 11;
					if (eax_57 > 0x00 || (0x01 << cl_65 & 0x0881) == 0x00)
					{
						word32 ecx_174;
						__libc_fatal(out ecx_174);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						Eq_43249 ecx_86;
						Eq_2 edx_87;
						Eq_2 eax_88 = __libc_scratch_buffer_grow_preserve(gs, stackArg4, out ecx_86, out edx_87);
						ecxOut = ecx_86;
						edxOut = edx_87;
						return eax_88;
					}
				}
				edx = gs->t0084;
				eax = edx & 0x0C;
			} while ((edx & 0x0C) == 0x04);
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	return eax;
}

// 08085400: Register word32 __libc_scratch_buffer_grow_preserve(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out ptr32 edxOut)
// Called from:
//      printf_positional
//      printf_positional
//      __libc_disable_asynccancel
word32 __libc_scratch_buffer_grow_preserve(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut, ptr32 & edxOut)
{
	Eq_2 ecx_106;
	ptr32 edx_163;
	word32 eax_103;
	Eq_2 edx_20 = *((word32) dwArg04 + 4);
	Eq_2 ebp_21 = *dwArg04;
	if (ebp_21 == (word32) dwArg04 + 16)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_173;
		word32 ebx_174;
		word32 ebp_175;
		word32 esi_176;
		word32 edi_177;
		Eq_2 eax_33 = __libc_malloc(gs, stackArg0, edx_20 * 0x02, out ecx_173, out edx_163, out ebx_174, out ebp_175, out esi_176, out edi_177);
		ecx_106 = eax_33;
		eax_103 = 0x00;
		if (eax_33 == 0x00)
			goto l08085452;
		word32 ecx_182;
		memcpy(eax_33, ebp_21, edx_20, out ecx_182, out edx_163);
		ecx_106 = eax_33;
l08085448:
		*dwArg04 = ecx_106;
		*((word32) dwArg04 + 4) = edx_20 * 0x02;
		eax_103 = 0x01;
		goto l08085452;
	}
	else
	{
		if (edx_20 <= edx_20 * 0x02)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebp_179;
			word32 esi_180;
			word32 edi_181;
			Eq_2 eax_75 = __realloc(gs, stackArg0, ebp_21, edx_20 * 0x02, out edx_163, out ebp_179, out esi_180, out edi_181);
			ecx_106 = eax_75;
			if (eax_75 != 0x00)
				goto l08085448;
			ebp_21 = *dwArg04;
		}
		else
			gs->tFFFFFFE0.u0 = 0x0C;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		free(gs, stackArg0, ebp_21, out ecx_106, out edx_163);
		((word32) dwArg04 + 4)->u0 = 0x0400;
		*dwArg04 = (word32) dwArg04 + 16;
		eax_103 = 0x00;
l08085452:
		ecxOut = ecx_106;
		edxOut = edx_163;
		return eax_103;
	}
}

// 080854D0: Register byte __libc_scratch_buffer_set_array_size(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_72837 edxOut)
// Called from:
//      _i18n_number_rewrite
//      printf_positional
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      printf_positional
//      _dl_map_object_deps
byte __libc_scratch_buffer_set_array_size(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_72837 & edxOut)
{
	Eq_2 ecx_110 = dwArg08;
	Eq_2 edi_25 = dwArg08 *s dwArg0C;
	if ((dwArg08 | dwArg0C) >> 0x10 != 0x00 && dwArg08 != 0x00)
	{
		uint64 edx_eax_34 = (uint64) edi_25;
		edx.u0 = (uint32) (edx_eax_34 % dwArg08);
		if ((uint32) (edx_eax_34 /u dwArg08) != dwArg0C)
		{
			Eq_2 eax_40 = *dwArg04;
			if (eax_40 != (word32) dwArg04 + 16)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				free(gs, stackArg0, eax_40, out ecx_110, out edx);
			}
			*dwArg04 = (word32) dwArg04 + 16;
			((word32) dwArg04 + 4)->u0 = 0x0400;
			gs->tFFFFFFE0.u0 = 0x0C;
			ecxOut = ecx_110;
			edxOut = edx;
			return 0x00;
		}
	}
	if (*((word32) dwArg04 + 4) < edi_25)
	{
		Eq_2 eax_81 = *dwArg04;
		if (eax_81 != (word32) dwArg04 + 16)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_219;
			word32 edx_220;
			free(gs, stackArg0, eax_81, out ecx_219, out edx_220);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ebx_214;
		word32 ebp_215;
		word32 esi_216;
		word32 edi_217;
		Eq_2 eax_111 = __libc_malloc(gs, stackArg0, edi_25, out ecx_110, out edx, out ebx_214, out ebp_215, out esi_216, out edi_217);
		if (eax_111 == 0x00)
		{
			*dwArg04 = (word32) dwArg04 + 16;
			((word32) dwArg04 + 4)->u0 = 0x0400;
			ecxOut = ecx_110;
			edxOut = edx;
			return (byte) eax_111;
		}
		*((word32) dwArg04 + 4) = edi_25;
		*dwArg04 = eax_111;
	}
	ecxOut = ecx_110;
	edxOut = edx;
	return 0x01;
}

// 080855B0: Register Eq_2 __strndup(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_67744) ebpOut)
// Called from:
//      _nl_find_locale
Eq_2 __strndup(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_67744 & ebpOut)
{
	struct Eq_67744 * ebp_36;
	Eq_2 edi_39;
	Eq_2 esi_41;
	word32 ecx_110;
	word32 edx_111;
	word32 ecx_112;
	word32 edx_113;
	word32 ebx_114;
	Eq_2 eax_35 = __libc_malloc(gs, dwLoc20, (word32) strnlen(dwArg04, dwArg08, out ecx_110, out edx_111) + 1, out ecx_112, out edx_113, out ebx_114, out ebp_36, out esi_41, out edi_39);
	if (eax_35 != 0x00)
	{
		Mem52[eax_35 + esi_41:byte] = 0x00;
		word32 ecx_115;
		word32 edx_116;
		eax_35 = memcpy(eax_35, edi_39, esi_41, out ecx_115, out edx_116);
	}
	ebpOut = ebp_36;
	return eax_35;
}

// 08085600: Register Eq_2 strerror_r(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 esiOut)
// Called from:
//      _dl_start_profile
//      fatal_error
//      strerror
Eq_2 strerror_r(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2 eax_241;
	Eq_2 ebp_103;
	Eq_2 edx_101;
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 esi_164 = dwArg04;
	if (dwArg04 >= 0x00)
	{
		if (_sys_nerr_internal > dwArg04 && ((word32[]) 0x080CD6A0)[dwArg04] != 0x00)
		{
			word32 edx_480;
			eax_241 = dcgettext(out edx_480);
			ebp_103 = ebp;
			goto l0808565E;
		}
		word32 edx_475;
		Eq_2 eax_129 = dcgettext(out edx_475);
		word32 edx_477;
		word32 ecx_476;
		Eq_2 eax_135 = strlen(eax_129, out ecx_476, out edx_477);
		ebp_103 = eax_135;
		word32 ecx_478;
		word32 edx_479;
		esi_164 = _itoa_word(dwArg04, fp - 33, 0x0A, 0x00, out ecx_478, out edx_479);
		Eq_2 eax_165 = eax_135;
		if (dwArg0C <= eax_135)
			eax_165 = dwArg0C;
		word32 edx_488;
		edx_101 = __mempcpy(dwArg08, eax_129, eax_165, out edx_488);
		if (dwArg0C <= eax_135)
		{
l08085798:
			if (dwArg0C == 0x00)
			{
				eax_241 = dwArg08;
l0808565E:
				if ((eax_20 ^ gs->t0014) != 0x00)
				{
					word32 ecx_481;
					word32 edx_482;
					__stack_chk_fail(out ecx_481, out edx_482);
					word32 ecx_486;
					word32 edx_487;
					Eq_2 eax_298 = strnlen(dwLoc48, dwLoc44, out ecx_486, out edx_487);
					ebxOut = 0x080CE000;
					ebpOut = ebp_103;
					esiOut = esi_164;
					return eax_298;
				}
				else
				{
					ebxOut = ebx;
					ebpOut = ebp;
					esiOut = esi;
					return eax_241;
				}
			}
			goto l08085716;
		}
	}
	else
	{
		word32 edx_470;
		Eq_2 eax_40 = dcgettext(out edx_470);
		word32 edx_472;
		word32 ecx_471;
		Eq_2 eax_46 = strlen(eax_40, out ecx_471, out edx_472);
		ebp_103 = eax_46;
		word32 ecx_473;
		word32 edx_474;
		esi_164 = _itoa_word(-dwArg04, fp - 33, 0x0A, 0x00, out ecx_473, out edx_474);
		Eq_2 eax_76 = eax_46;
		if (eax_46 > dwArg0C)
			eax_76 = dwArg0C;
		word32 edx_483;
		Eq_2 eax_89 = __mempcpy(dwArg08, eax_40, eax_76, out edx_483);
		if (eax_46 >= dwArg0C)
			goto l08085798;
		*eax_89 = 0x2D;
		edx_101 = (word32) eax_89 + 1;
		ebp_103 = (word32) eax_46 + 1;
		if (dwArg0C <= (word32) eax_46 + 1)
		{
l08085716:
			*((word32) dwArg0C + (dwArg08 - 0x01)) = 0x00;
			eax_241 = dwArg08;
			goto l0808565E;
		}
	}
	Eq_2 ecx_198 = fp - 0x20 - esi_164;
	Eq_2 eax_200 = dwArg0C - ebp_103;
	if (eax_200 > ecx_198)
		eax_200 = ecx_198;
	word32 edx_485;
	word32 ecx_484;
	memcpy(edx_101, esi_164, eax_200, out ecx_484, out edx_485);
	goto l08085716;
}

// 080857B0: Register int32 strnlen(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      two_way_long_needle
//      strstr
//      __mbsrtowcs_l
//      add_module.isra.0
//      __strndup
//      strerror_r
int32 strnlen(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	int32 eax_110 = 0x00;
	Eq_2 edx_101 = dwArg08;
	byte bl_24 = (byte) dwArg04;
	if (dwArg08 != 0x00)
	{
		word32 eax_139 = dwArg08 + dwArg04;
		if (eax_139 < 0x00)
			eax_139.u0 = ~0x00;
		edx_101 = dwArg04;
		if ((bl_24 & 0x03) != 0x00)
		{
			if (*dwArg04 != 0x00)
			{
				do
				{
					edx_101 = (word32) edx_101 + 1;
					if (((byte) edx_101 & 0x03) == 0x00)
						goto l080857ED;
				} while (*edx_101 != 0x00);
			}
			if (eax_139 > edx_101)
				eax_139 = edx_101;
			ecxOut = ecx;
			edxOut = edx_101;
			return eax_139 - dwArg04;
		}
l080857ED:
		if (eax_139 > edx_101)
		{
			do
			{
				ecx = (word32) edx_101 + 4;
				if ((*((word32) ecx - 4) - 0x01010101 & 0x80808080) != 0x00)
				{
					if (*((word32) ecx - 4) == 0x00)
					{
						if (eax_139 > edx_101)
							eax_139 = edx_101;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
					if (*((word32) ecx - 3) == 0x00)
					{
						ecx = (word32) edx_101 + 1;
						if (eax_139 > ecx)
							eax_139 = ecx;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
					if (*((word32) ecx - 2) == 0x00)
					{
						ecx = (word32) edx_101 + 2;
						if (eax_139 > ecx)
							eax_139 = ecx;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
					if (*((word32) ecx - 1) == 0x00)
					{
						ecx = (word32) edx_101 + 3;
						if (eax_139 > ecx)
							eax_139 = ecx;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
				}
				edx_101 = ecx;
			} while (eax_139 > ecx);
		}
		eax_110 = eax_139 - dwArg04;
	}
l0808582C:
	ecxOut = ecx;
	edxOut = edx_101;
	return eax_110;
}

// 08085870: Register Eq_2 rindex(Stack Eq_2 dwArg04, Stack byte bArg08)
// Called from:
//      __init_misc
//      _nl_find_locale
Eq_2 rindex(Eq_2 dwArg04, byte bArg08)
{
	byte cl_13 = (byte) dwArg08;
	Eq_99530 ecx_16 = SEQ(SLICE(dwArg08, word16, 16), cl_13, cl_13);
	Eq_2 eax_10 = 0x00;
	Eq_2 esi_11 = dwArg04;
	word32 ecx_312 = SEQ(ecx_16, ecx_16);
	word24 ecx_24_8_322 = SEQ(ecx_16, cl_13);
	if ((dwArg04 & 0x03) != 0x00)
	{
		byte dl_24 = *dwArg04;
		if (cl_13 == dl_24)
			eax_10 = dwArg04;
		ecx_312 = SEQ(ecx_24_8_322, cl_13);
		if (dl_24 == 0x00)
			return eax_10;
		esi_11 = dwArg04 + 0x01;
		if ((dwArg04 + 0x01 & 0x03) != 0x00)
		{
			byte dl_40 = Mem9[dwArg04 + 0x01:byte];
			if (cl_13 == dl_40)
				eax_10 = dwArg04 + 0x01;
			ecx_312 = SEQ(ecx_24_8_322, cl_13);
			if (dl_40 == 0x00)
				return eax_10;
			esi_11 = dwArg04 + 0x02;
			if ((dwArg04 + 0x02 & 0x03) != 0x00)
			{
				byte dl_56 = Mem9[dwArg04 + 0x02:byte];
				if (cl_13 == dl_56)
					eax_10 = dwArg04 + 0x02;
				if (dl_56 == 0x00)
					return eax_10;
				esi_11 = dwArg04 + 0x03;
			}
		}
	}
	while (true)
	{
		byte cl_183 = (byte) ecx_312;
		uint32 edx_451 = *esi_11;
		if (edx_451 >= ~0x01010100 || (edx_451 + ~0x01010100 ^ edx_451 | ~0x01010100) != 0x01)
			break;
		uint32 edx_109 = edx_451 ^ ecx_312;
		if (edx_109 < ~0x01010100)
		{
			if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) == 0x01)
			{
				uint32 edx_453 = *((word32) esi_11 + 4);
				if (edx_453 < ~0x01010100 && (edx_453 + ~0x01010100 ^ edx_453 | ~0x01010100) == 0x01)
				{
					edx_109 = edx_453 ^ ecx_312;
					if (edx_109 >= ~0x01010100)
						goto l080858E1;
					if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) != 0x01)
						goto l080858F7;
					uint32 edx_126 = *((word32) esi_11 + 8);
					if (edx_126 < ~0x01010100 && (edx_126 + ~0x01010100 ^ edx_126 | ~0x01010100) == 0x01)
					{
						edx_109 = edx_126 ^ ecx_312;
						if (edx_109 >= ~0x01010100)
							goto l080858E4;
						if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) != 0x01)
							goto l080858FA;
						edx_126 = (uint32) *((word32) esi_11 + 0x0C);
						if (edx_126 < ~0x01010100 && (edx_126 + ~0x01010100 ^ edx_126 | ~0x01010100) == 0x01)
						{
							edx_109 = edx_126 ^ ecx_312;
							if (edx_109 >= ~0x01010100)
								goto l080858E7;
							if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) != 0x01)
								goto l080858FD;
							goto l08085914;
						}
						esi_11 = (word32) esi_11 + 4;
					}
					esi_11 = (word32) esi_11 + 4;
					edx_453 = edx_126;
				}
				esi_11 = (word32) esi_11 + 4;
				edx_451 = edx_453;
				break;
			}
			esi_11 -= 0x04;
l080858F7:
			esi_11 -= 0x04;
l080858FA:
			esi_11 -= 0x04;
			goto l080858FD;
		}
		esi_11 -= 0x04;
l080858E1:
		esi_11 -= 0x04;
l080858E4:
		esi_11 -= 0x04;
l080858E7:
		if ((edx_109 & 0xFF000000) == 0x00)
			eax_10 = (word32) esi_11 + 0x0F;
		else
		{
l080858FD:
			byte dh_295 = SLICE(edx_109, byte, 8);
			if ((edx_109 & 0x00FF0000) == 0x00)
				eax_10 = (word32) esi_11 + 0x0E;
			else
			{
				eax_10 = (word32) esi_11 + 0x0C;
				if (dh_295 == 0x00)
					eax_10 = (word32) esi_11 + 0x0D;
			}
		}
l08085914:
		esi_11 = (word32) esi_11 + 16;
	}
	byte dh_196 = SLICE(edx_451, byte, 8);
	byte dl_174 = (byte) edx_451;
	if (dl_174 == cl_183)
		eax_10 = esi_11;
	if (dl_174 != 0x00)
	{
		if (dh_196 == cl_183)
			eax_10 = (word32) esi_11 + 1;
		if (dh_196 != 0x00)
		{
			byte dl_226 = (byte) (edx_451 >> 0x10);
			byte dh_237 = SLICE(edx_451 >> 0x10, byte, 8);
			if (dl_226 == cl_183)
				eax_10 = (word32) esi_11 + 2;
			if (dl_226 != 0x00 && dh_237 == cl_183)
				eax_10 = (word32) esi_11 + 3;
		}
	}
	return eax_10;
}

// 08085A30: Register Eq_2 __strtok_r(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __gconv_open
//      __gconv_get_path
Eq_2 __strtok_r(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 ebx_13 = dwArg04;
	if (dwArg04 == 0x00)
		ebx_13 = *dwArg0C;
	if (*ebx_13 != 0x00)
	{
		ebx_13 = (word32) ebx_13 + strspn(ebx_13, dwArg08);
		if (*ebx_13 != 0x00)
		{
			word32 eax_72 = strcspn(ebx_13, dwArg08) + ebx_13;
			if (*eax_72 != 0x00)
			{
				*eax_72 = 0x00;
				eax_72 = (word32) eax_72 + 1;
			}
			*dwArg0C = eax_72;
			return ebx_13;
		}
	}
	*dwArg0C = ebx_13;
	return 0x00;
}

// 08085AA0: Register Eq_2 __memchr(Stack Eq_2 dwArg04, Stack byte bArg08, Stack Eq_2 dwArg0C)
// Called from:
//      next_line
//      _nl_find_locale
//      _IO_getdelim
//      _IO_getline_info
//      __memmem
Eq_2 __memchr(Eq_2 dwArg04, byte bArg08, Eq_2 dwArg0C)
{
	Eq_2 eax_10 = dwArg04;
	byte al_23 = (byte) dwArg04;
	byte dl_15 = (byte) dwArg08;
	word16 edx_16_16_17 = SLICE(dwArg08, word16, 16);
	Eq_2 esi_12 = dwArg0C;
	if (dwArg0C < 0x04)
	{
l08085BFF:
		ui32 esi_214 = esi_12 & 0x03;
		if (esi_214 != 0x00)
		{
			if (*eax_10 == dl_15)
				return eax_10;
			eax_10 = (word32) eax_10 + 1;
			if (esi_214 != 0x01)
			{
				if (*eax_10 == dl_15)
					return eax_10;
				eax_10 = (word32) eax_10 + 1;
				if (esi_214 != 0x02 && *((word32) eax_10 + 1) == dl_15)
					return eax_10;
			}
		}
		goto l08085C18;
	}
	Eq_99806 edx_18 = SEQ(edx_16_16_17, dl_15, dl_15);
	word32 edx_258 = SEQ(edx_18, edx_18);
	if ((al_23 & 0x03) == 0x00)
	{
l08085B96:
		while (true)
		{
			Eq_99814 ecx_123;
			esi_12 -= 0x10;
			if (esi_12 < 0x00)
				break;
			ecx_123 = *eax_10 ^ edx_258;
			if (ecx_123 >= ~0x01010100 || ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) != 0x01)
				goto l08085C25;
			Eq_99814 ecx_346 = *((word32) eax_10 + 4) ^ edx_258;
			if (ecx_346 >= ~0x01010100 || ((word32) ecx_346.u0 - 0x01010101 ^ ecx_346 | ~0x01010100) != 0x01)
			{
l08085C22:
				eax_10 = (word32) eax_10 + 4;
				ecx_123 = ecx_346;
				goto l08085C25;
			}
			Eq_99814 ecx_348 = *((word32) eax_10 + 8) ^ edx_258;
			if (ecx_348 >= ~0x01010100 || ((word32) ecx_348.u0 - 0x01010101 ^ ecx_348 | ~0x01010100) != 0x01)
			{
l08085C1F:
				eax_10 = (word32) eax_10 + 4;
				ecx_346 = ecx_348;
				goto l08085C22;
			}
			ecx_348 = *((word32) eax_10 + 0x0C) ^ edx_258;
			if (ecx_348 >= ~0x01010100 || ((word32) ecx_348.u0 - 0x01010101 ^ ecx_348 | ~0x01010100) != 0x01)
			{
				eax_10 = (word32) eax_10 + 4;
				goto l08085C1F;
			}
			eax_10 = (word32) eax_10 + 16;
		}
		if (esi_12 >= ~0x0B)
		{
			ecx_123 = *eax_10 ^ edx_258;
			if (ecx_123 < ~0x01010100 && ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) == 0x01)
			{
				eax_10 = (word32) eax_10 + 4;
				if (esi_12 < ~0x07)
					goto l08085BFF;
				ecx_123 = *eax_10 ^ edx_258;
				if (ecx_123 < ~0x01010100 && ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) == 0x01)
				{
					eax_10 = (word32) eax_10 + 4;
					if (esi_12 < ~0x03)
						goto l08085BFF;
					ecx_123 = *((word32) eax_10 + 4) ^ edx_258;
					if (ecx_123 < ~0x01010100 && ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) == 0x01)
					{
						eax_10 = (word32) eax_10 + 8;
						goto l08085BFF;
					}
				}
			}
l08085C25:
			byte ch_179 = SLICE(ecx_123, byte, 8);
			if ((byte) ecx_123 != 0x00)
			{
				eax_10 = (word32) eax_10 + 1;
				if (ch_179 != 0x00)
				{
					eax_10 = (word32) eax_10 + 1;
					if ((ecx_123 & 0x00FF0000) != 0x00)
						eax_10 = (word32) eax_10 + 2;
				}
			}
			return eax_10;
		}
		goto l08085BFF;
	}
	else
	{
		if (*dwArg04 == dl_15)
			return eax_10;
		eax_10 = (word32) dwArg04 + 1;
		byte al_34 = (byte) dwArg04 + 0x01;
		esi_12 = dwArg0C - 0x01;
		if (dwArg0C != 0x01)
		{
			if ((al_34 & 0x03) == 0x00)
				goto l08085B96;
			if (*((word32) dwArg04 + 1) == dl_15)
				return eax_10;
			eax_10 = (word32) dwArg04 + 2;
			byte al_44 = (byte) dwArg04 + 0x02;
			esi_12 = dwArg0C - 0x02;
			if (dwArg0C != 0x02)
			{
				if ((al_44 & 0x03) != 0x00)
				{
					if (*((word32) dwArg04 + 2) == dl_15)
						return eax_10;
					eax_10 = (word32) dwArg04 + 3;
					esi_12 = dwArg0C - 0x03;
				}
				goto l08085B96;
			}
		}
l08085C18:
		eax_10.u0 = 0x00;
		return eax_10;
	}
}

// 08085C40: Register Eq_2 critical_factorization(Register Eq_2 eax, Register (ptr32 int32) ecx, Register Eq_2 edx)
// Called from:
//      two_way_long_needle
//      __memmem
Eq_2 critical_factorization(Eq_2 eax, int32 * ecx, Eq_2 edx)
{
	int32 ebp_46 = 0x01;
	int32 ebx_18 = 0x01;
	Eq_2 dwLoc20_152 = ~0x00;
	Eq_2 esi_26 = 0x00;
l08085C68:
	Eq_2 ecx_29 = (word32) esi_26 + ebx_18;
	while (ecx_29 < edx)
	{
		byte dl_42 = Mem31[eax + dwLoc20_152 + ebx_18:byte];
		if (Mem31[eax + ecx_29:byte] >=u dl_42)
		{
			if (Mem31[eax + ecx_29:byte] != dl_42)
			{
				dwLoc20_152 = esi_26;
				ebp_46 = 0x01;
				esi_26 = (word32) esi_26 + 1;
				ebx_18 = 0x01;
			}
			else if (ebx_18 != ebp_46)
				++ebx_18;
			else
			{
				esi_26 = ecx_29;
				ebx_18 = 0x01;
			}
			goto l08085C68;
		}
		esi_26 = ecx_29;
		ebx_18 = 0x01;
		ebp_46 = ecx_29 - dwLoc20_152;
		ecx_29 = (word32) ecx_29 + 1;
	}
	*ecx = ebp_46;
	int32 dwLoc18_161 = 0x01;
	int32 ebx_101 = 0x01;
	Eq_2 edi_105 = ~0x00;
	Eq_2 esi_100 = 0x00;
l08085CB8:
	Eq_2 ecx_115 = (word32) esi_100 + ebx_101;
	while (ecx_115 < edx)
	{
		byte dl_93 = Mem90[eax + edi_105 + ebx_101:byte];
		if (Mem90[eax + ecx_115:byte] <=u dl_93)
		{
			if (Mem90[eax + ecx_115:byte] != dl_93)
			{
				edi_105 = esi_100;
				dwLoc18_161 = 0x01;
				esi_100 = (word32) esi_100 + 1;
				ebx_101 = 0x01;
			}
			else if (ebx_101 != dwLoc18_161)
				++ebx_101;
			else
			{
				esi_100 = ecx_115;
				ebx_101 = 0x01;
			}
			goto l08085CB8;
		}
		ebx_101 = 0x01;
		dwLoc18_161 = ecx_115 - edi_105;
		esi_100 = ecx_115;
		ecx_115 = (word32) ecx_115 + 1;
	}
	Eq_2 edi_123 = (word32) edi_105 + 1;
	Eq_2 eax_124 = (word32) dwLoc20_152 + 1;
	if (edi_123 >= (word32) dwLoc20_152 + 1)
	{
		*ecx = dwLoc18_161;
		eax_124 = edi_123;
	}
	return eax_124;
}

// 08085D90: Register Eq_2 two_way_long_needle(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __memmem
Eq_2 two_way_long_needle(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2175 eax_30 = gs->t0014;
	Eq_2 eax_36 = critical_factorization(ecx, fp - 0x0424, dwArg04);
	word32 * eax_45 = fp - 0x0420;
	do
	{
		*eax_45 = (word32) dwArg04;
		++eax_45;
	} while (eax_45 != fp - 0x20);
	word32 eax_55 = ecx + dwArg04;
	word32 ebx_58 = (word32) ecx + (dwArg04 - 0x01);
	Eq_2 eax_59 = ecx;
	if (dwArg04 != 0x00)
	{
		do
		{
			(fp - 0x0420)[(word32) *eax_59] = ebx_58 - eax_59;
			eax_59 = (word32) eax_59 + 1;
		} while (eax_59 != eax_55);
	}
	Eq_2 eax_134;
	word32 ecx_897;
	word32 edx_898;
	if (memcmp(ecx, dwLoc0424 + ecx, eax_36, out ecx_897, out edx_898) == 0x00)
	{
		byte * ebx_232 = null;
		Eq_2 esi_233 = 0x00;
		byte * eax_236 = (word32) ecx + (eax_36 - (byte *) 0x01);
		do
		{
			word32 eax_243 = eax + ebx_232;
			byte * eax_247 = (fp - 0x0420)[(word32) *((word32) eax_243 + (dwArg04 - 0x01))];
			if (eax_247 == null)
			{
				Eq_2 eax_271 = eax_36;
				if (esi_233 >= eax_36)
					eax_271 = esi_233;
				word32 ecx_283 = eax_271 + ebx_232 + eax;
				if (eax_271 < dwArg04 - 0x01)
				{
					if (Mem280[ecx_283 + 0x00:byte] == Mem280[ecx + eax_271:byte])
					{
						do
						{
							++eax_271;
							if (eax_271 >= dwArg04 - 0x01)
								goto l08085F08;
						} while (Mem280[ecx + eax_271:byte] == Mem280[eax_243 + eax_271:byte]);
					}
					ebx_232 = eax_271 + 0x01 + (ebx_232 - eax_36);
					goto l08085E8F;
				}
l08085F08:
				Eq_2 dwLoc0440_645;
				word32 eax_333 = eax_36 - 0x01 + ebx_232 + eax;
				if (esi_233 < eax_36)
				{
					byte * ecx_340 = eax_333 - eax_36;
					if (*eax_333 != *eax_236)
						goto l080860D1;
					Eq_2 ecx_352 = eax_36 - (byte *) 0x01;
					while (true)
					{
						Eq_2 eax_355 = ecx_352 - (byte *) 0x01;
						if (esi_233 == ecx_352 || Mem351[ecx + eax_355:byte] != Mem351[(eax_355 + 0x01) + ecx_340:byte])
							break;
						ecx_352 = eax_355;
					}
					dwLoc0440_645 = ecx_352;
				}
				else
				{
l080860D1:
					dwLoc0440_645 = eax_36;
				}
				if (esi_233 + 0x01 >u dwLoc0440_645)
				{
					eax_134 = eax_243;
					goto l08085F9C;
				}
				else
				{
					ebx_232 += dwLoc0424;
					esi_233 = dwArg04 - dwLoc0424;
					if (edx - dwArg04 < ebx_232)
						break;
					continue;
				}
			}
			if (esi_233 != 0x00)
			{
				byte * edx_260 = dwArg04 - dwLoc0424;
				if ((int8) (dwLoc0424 > eax_247) != 0x00)
					eax_247 = edx_260;
			}
			ebx_232 += eax_247;
l08085E8F:
			esi_233.u0 = 0x00;
		} while (edx - dwArg04 >= ebx_232);
	}
	else
	{
		Eq_2 eax_113 = dwArg04 - eax_36;
		if (eax_113 < eax_36)
			eax_113 = eax_36;
		byte * ecx_118 = null;
		byte * eax_120 = (word32) eax_113 + 1;
		byte * eax_125 = 0x01 - eax_36;
		do
		{
			eax_134 = eax + ecx_118;
			word32 edx_137 = (fp - 0x0420)[CONVERT(Mem131[eax_134 + (dwArg04 - 0x01):byte], byte, word32) * 0x04];
			if (edx_137 != 0x00)
			{
l08086012:
				ecx_118 += edx_137;
				goto l08086014;
			}
			word32 ebx_144 = ecx + eax_36;
			word32 edx_145 = ecx_118 + eax_36 + eax;
			if (eax_36 < dwArg04 - 0x01)
			{
				edx_137 = eax_36;
				if (*ebx_144 == *edx_145)
				{
					do
					{
						++edx_137;
						if (edx_137 >= dwArg04 - 0x01)
							goto l08086060;
					} while (Mem131[ecx + edx_137:byte] == Mem131[eax_134 + edx_137:byte]);
				}
				ecx_118 += eax_125;
				goto l08086012;
			}
l08086060:
			word32 ebx_169 = ecx + (eax_36 - 0x01);
			word32 ebx_178 = eax_36 - 0x01 + ecx_118 + eax;
			if (eax_36 == 0x00)
				goto l08085F9C;
			byte * ebx_182 = ebx_178 - eax_36;
			if (*ebx_178 == *ebx_169)
			{
				byte * edx_189 = eax_36 - (byte *) 0x01;
				do
				{
					edx_189 -= (byte *) 0x01;
					if (edx_189 == (byte *) ~0x00)
						goto l08085F9C;
				} while (Mem191[ecx + edx_189:byte] == Mem191[(edx_189 + 0x01) + ebx_182:byte]);
			}
			ecx_118 += eax_120;
l08086014:
		} while (ecx_118 <= edx - dwArg04);
	}
	eax_134.u0 = 0x00;
l08085F9C:
	if ((eax_30 ^ gs->t0014) == 0x00)
		return eax_134;
	word32 edx_900;
	word32 ecx_899;
	__stack_chk_fail(out ecx_899, out edx_900);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	word32 ebp_904;
	word32 esi_905;
	word32 edi_906;
	return __memmem(gs, dwArg04, stackArg8, stackArg12, stackArg16, out ebp_904, out esi_905, out edi_906);
}

// 080860F0: Register Eq_2 __memmem(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 ebpOut, Register out (ptr32 Eq_2) esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_locale
//      two_way_long_needle
Eq_2 __memmem(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 ebp_125 = dwArg04;
	Eq_2 edi_25 = dwArg08;
	Eq_2 eax_257 = dwArg04;
	if (dwArg10 != 0x00)
	{
		if (dwArg10 > dwArg08)
		{
l08086276:
			eax_257.u0 = 0x00;
			goto l08086280;
		}
		if (dwArg10 <= 0x1F)
		{
			eax_257 = __memchr(dwArg04, *dwArg0C, dwArg08);
			if (eax_257 != 0x00 && dwArg10 != 0x01)
			{
				edi_25 = dwArg08 - (eax_257 - dwArg04);
				eax_257.u0 = 0x00;
				if (dwArg10 <= edi_25)
				{
					Eq_2 eax_80 = critical_factorization(dwArg0C, fp - 0x24, dwArg10);
					edi_25 = eax_80;
					word32 ecx_858;
					word32 edx_859;
					word32 eax_281 = memcmp(dwArg0C, dwLoc24 + dwArg0C, eax_80, out ecx_858, out edx_859);
					if (eax_281 == 0x00)
					{
						Eq_2 ecx_267 = 0x00;
						word32 ebx_269 = eax_80 - 0x01 + dwArg0C;
						do
						{
							Eq_2 edx_276 = ecx_267;
							if (eax_80 >= ecx_267)
								edx_276 = eax_80;
							ebp_125 = dwArg0C + edx_276;
							word32 ebx_290 = edx_276 + eax_281 + eax_257;
							if (dwArg10 > edx_276)
							{
								if (*ebp_125 == *ebx_290)
								{
									ebp_125 = ecx_267;
									word32 ebx_300 = eax_257 + eax_281;
									do
									{
										++edx_276;
										if (dwArg10 == edx_276)
											goto l08086208;
									} while (Mem289[dwArg0C + edx_276:byte] == Mem289[ebx_300 + edx_276:byte]);
								}
								ecx_267.u0 = 0x00;
								eax_281 = edx_276 + 0x01 + (eax_281 - eax_80);
							}
							else
							{
l08086208:
								Eq_2 ebx_332 = eax_80 - (byte *) 0x01;
								ebp_125 = eax_80 - 0x01 + eax_281 + eax_257;
								if (eax_80 > ecx_267 && *ebp_125 == *ebx_269)
								{
									ebp_125 -= eax_80;
									while (true)
									{
										Eq_2 edx_349 = ebx_332 - (byte *) 0x01;
										if (ebx_332 == ecx_267 || Mem347[dwArg0C + edx_349:byte] != Mem347[(edx_349 + 0x01) + ebp_125:byte])
											break;
										ebx_332 = edx_349;
									}
								}
								else
									ebx_332 = eax_80;
								if (ebx_332 < (byte) ecx_267.u0 + 1)
								{
									eax_257 = eax_281 + eax_257;
									goto l08086280;
								}
								eax_281 += dwLoc24;
								ecx_267 = dwArg10 - dwLoc24;
							}
						} while (edi_25 - dwArg10 >= eax_281);
						goto l08086276;
					}
					byte al_112 = Mem98[dwArg0C + eax_80:byte];
					Eq_2 eax_115 = dwArg10 - eax_80;
					if (eax_115 < eax_80)
						eax_115 = eax_80;
					byte * ebp_122 = edi_25 - dwArg10;
					byte * edx_123 = null;
					ebp_125 = eax_257;
					byte * eax_127 = (word32) eax_115 + 1;
					byte * eax_131 = 0x01 - eax_80;
					do
					{
						word32 ecx_141 = eax_80 + edx_123 + eax_257;
						word32 eax_142 = ecx_141 + 0x01;
						if (al_112 != *ecx_141)
						{
							word32 eax_157 = __memchr(ecx_141 + 0x01, al_112, ebp_122 - edx_123);
							if (eax_157 == 0x00)
								goto l08086276;
							eax_142 = (word32) eax_157 + 1;
							edx_123 = eax_157 - (eax_257 + eax_80);
						}
						word32 ebx_178 = dwArg0C + (eax_80 + 0x01);
						word32 dwLoc44_508 = eax_80 + 0x01;
						if (dwArg10 >u eax_80 + 0x01)
						{
							if (*ebx_178 == *eax_142)
							{
								byte * eax_188 = eax_142 - eax_80;
								word32 ecx_190 = eax_80 + 0x01;
								do
								{
									++ecx_190;
									if (dwArg10 == ecx_190)
										goto l08086373;
								} while (Mem180[dwArg0C + ecx_190:byte] == Mem180[(ecx_190 - 0x01) + eax_188:byte]);
								dwLoc44_508 = ecx_190;
							}
							edx_123 = edx_123 + eax_131 + dwLoc44_508;
						}
						else
						{
l08086373:
							word32 ebx_220 = dwArg0C + (eax_80 - 0x01);
							word32 ecx_224 = eax_80 - 0x01 + edx_123 + eax_257;
							if (eax_80 == 0x00)
							{
l080863B2:
								eax_257 += edx_123;
								goto l08086280;
							}
							if (*ebx_220 == *ecx_224)
							{
								byte * ecx_231 = ecx_224 - eax_80;
								byte * eax_233 = eax_80 - (byte *) 0x01;
								do
								{
									eax_233 -= (byte *) 0x01;
									if (eax_233 == (byte *) ~0x00)
										goto l080863B2;
								} while (Mem218[dwArg0C + eax_233:byte] == Mem218[(eax_233 + 0x01) + ecx_231:byte]);
							}
							edx_123 += eax_127;
						}
					} while (ebp_122 >= edx_123);
					eax_257.u0 = 0x00;
				}
			}
		}
		else
			eax_257 = two_way_long_needle(eax, dwArg0C, dwArg08, gs, dwArg10);
	}
l08086280:
	union Eq_2 * esi_433 = eax_20 ^ gs->t0014;
	if (esi_433 != null)
	{
		word32 ecx_860;
		word32 edx_861;
		__stack_chk_fail(out ecx_860, out edx_861);
		Eq_2 eax_443 = argz_create_sep(gs, dwArg04, dwArg0C, dwArg10);
		ebpOut = ebp_125;
		esiOut = esi_433;
		ediOut = edi_25;
		return eax_443;
	}
	else
	{
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return eax_257;
	}
}

// 08086410: Register word32 argz_create_sep(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      setlocale
//      __memmem
word32 argz_create_sep(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	word32 eax_153;
	word32 edx_264;
	word32 ecx_263;
	Eq_2 eax_25 = strlen(dwArg04, out ecx_263, out edx_264);
	if (eax_25 != 0x00)
	{
		int32 edi_45;
		word32 edx_266;
		word32 ecx_265;
		word32 ebx_267;
		byte * esi_47;
		word32 ebp_42;
		Eq_2 eax_41 = __libc_malloc(gs, dwLoc40, (word32) eax_25 + 1, out ecx_265, out edx_266, out ebx_267, out ebp_42, out esi_47, out edi_45);
		*dwArg0C = eax_41;
		if (eax_41 == 0x00)
		{
			eax_153 = 0x0C;
			return eax_153;
		}
		else
		{
			Eq_2 ecx_170 = eax_41;
			do
			{
				int32 ebx_62 = (int32) *esi_47;
				byte bl_67 = (byte) ebx_62;
				byte dl_86 = (byte) ebx_62;
				if (ebx_62 != edi_45)
				{
					*ecx_170 = bl_67;
					ecx_170 = (word32) ecx_170 + 1;
					goto l0808648D;
				}
				if (eax_41 >= ecx_170 || *((word32) ecx_170 - 1) == 0x00)
				{
					--ebp_42;
l0808648D:
					++esi_47;
					if (dl_86 != 0x00)
						continue;
					break;
				}
				*ecx_170 = 0x00;
				++esi_47;
				ecx_170 = (word32) ecx_170 + 1;
			} while (dl_86 != 0x00);
			if (ebp_42 == 0x00)
			{
				word32 ecx_268;
				word32 edx_269;
				free(gs, dwLoc40, eax_41, out ecx_268, out edx_269);
				dwArg0C->u0 = 0x00;
			}
			*dwArg10 = ebp_42;
			return 0x00;
		}
	}
	else
	{
		dwArg0C->u0 = 0x00;
		*dwArg10 = 0x00;
		eax_153 = 0x00;
		return eax_153;
	}
}

// 08086510: Register word32 __argz_add_sep(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      setlocale
word32 __argz_add_sep(struct Eq_9 * gs, union Eq_2 * dwArg04, word32 * dwArg08, Eq_2 dwArg0C)
{
	word32 edx_234;
	word32 ecx_233;
	Eq_2 eax_25 = strlen(dwArg0C, out ecx_233, out edx_234);
	word32 eax_177 = 0x00;
	if (eax_25 == 0x00)
		return eax_177;
	union Eq_2 * edi_50;
	int32 esi_52;
	word32 edx_235;
	byte * ebp_107;
	Eq_2 eax_54 = __realloc(gs, dwLoc40, *dwArg04, (word32) eax_25 + 1 + *dwArg08, out edx_235, out ebp_107, out esi_52, out edi_50);
	*edi_50 = (union Eq_2 *) eax_54;
	if (eax_54 == 0x00)
	{
		eax_177 = 0x0C;
		return eax_177;
	}
	else
	{
		Eq_2 eax_106 = (word32) eax_54 + *dwArg08;
		word32 ecx_120 = (word32) eax_25 + 1;
		do
		{
			int32 ebx_74 = (int32) *ebp_236;
			byte bl_79 = (byte) ebx_74;
			if (ebx_74 != esi_52)
			{
				*eax_106 = bl_79;
				ebx_74 = (word32) *ebp_236;
				eax_106 = (word32) eax_106 + 1;
				goto l08086589;
			}
			if (*edi_50 >= eax_106 || *((word32) eax_106 - 1) == 0x00)
			{
				--ecx_120;
l08086589:
				ebp_107 = ebp_236 + 1;
				if ((byte) ebx_74 != 0x00)
					continue;
				break;
			}
			*eax_106 = 0x00;
			eax_106 = (word32) eax_106 + 1;
			ebp_107 = ebp_236 + 1;
			ebp_236 = ebp_107;
		} while (*ebp_236 != 0x00);
		*dwArg08 += ecx_120;
		return 0x00;
	}
}

// 080865E0: Register Eq_2 handle_amd(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 ebx, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_1011 esiOut, Register out ptr32 ediOut)
// Called from:
//      init_cacheinfo
//      __cache_sysconf
Eq_2 handle_amd(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 ebx, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_1011 & esiOut, ptr32 & ediOut)
{
	__cpuid(0x80000000, ecx, &0x80000000, &ebx, &ecx, &edx);
	Eq_2 esi_13 = eax;
	Eq_2 ecx_45;
	if (eax <= 0xBE)
	{
		__cpuid(0x80000005, ecx, &0x80000005, &ebx, &ecx, &edx);
		ecx_45 = ecx;
		if (eax <= 0xBB)
		{
			esi_13 = (word32) eax + 3;
			ecx_45 = edx;
		}
	}
	else
	{
		__cpuid(0x80000006, ecx, &0x80000006, &ebx, &ecx, &edx);
		ecx_45 = ecx;
	}
	Eq_1011 esi_47 = esi_13 - 188;
	if (esi_47 > 0x08)
	{
		word32 ecx_117;
		word32 edx_118;
		__assert_fail(out ecx_117, out edx_118);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		word32 ecx_122;
		word32 edx_123;
		intel_check_word.isra.0(eax, ecx, edx, stackArg4, stackArg8, stackArg12, out ecx_122, out edx_123);
		ecxOut = ecx_45;
		edxOut = edx;
		esiOut = esi_47;
		ediOut = 0x080CE000;
		return 134948313;
	}
	else
	{
		<anonymous> * eax_67 = g_a80B2600[esi_47 * 0x04] + 0x080CE000;
		Eq_2 eax_73;
		Eq_2 ecx_74;
		Eq_2 edx_75;
		eax_67();
		ecxOut = ecx_74;
		edxOut = edx_75;
		esiOut = esi_47;
		ediOut = 0x080CE000;
		return eax_73;
	}
}

// 08086810: Register Eq_2 intel_check_word.isra.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_100850 ecxOut, Register out Eq_100850 edxOut)
// Called from:
//      __cache_sysconf
Eq_2 intel_check_word.isra.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_100850 & ecxOut, union Eq_100850 & edxOut)
{
intel_check_word.isra.0_entry:
	def fp
	def eax
	def ecx
	def edx
	def dwArg04
	def dwArg08
	def dwArg0C
	esp_18 = fp - 44
	dwLoc24_364 = eax
	branch edx < 0x00 l08086920
	ebx_29 = edx
	ecx_32 = eax - 0xB9 >> 0x1F
	edx_eax_33 = (eax - 0xB9) *s64 0x55555556
	edx_34 = SLICE(edx_eax_33, word32, 32)
	edx_35 = edx_34 - ecx_32
	dwLoc2C_367 = edx_35 * 0x03
	branch edx == 0x00 l08086920
	ebp_41 = edx
	goto l0808687A
l08086810:
l08086836:
l0808685A:
l08086860:
	*dwArg04 = 0x01
	branch dwLoc2C_369 == 0x09 l08086920
l08086871:
	ecx_504 = PHI((ecx_503, l08086860), (ecx_290, l080868DA), (ecx_221, l08086905))
	dwLoc24_475 = PHI((dwLoc24_380, l08086860), (dwLoc24_492, l080868DA), (dwLoc24_492, l08086905))
	dwLoc2C_472 = PHI((dwLoc2C_369, l08086860), (dwLoc2C_491, l080868DA), (dwLoc2C_491, l08086905))
	edx_326 = PHI((edx_59, l08086860), (edx_291, l080868DA), (edx_230, l08086905))
	ebx_320 = PHI((ebx_58, l08086860), (ebx_325, l080868DA), (ebx_325, l08086905))
	Mem310 = PHI((Mem52, l08086860), (Mem210, l080868DA), (Mem210, l08086905))
	ebp_296 = ebp_42 >> 0x08
	branch ebp_296 == 0x00 l08086920
l0808687A:
	ecx_503 = PHI((ecx_32, l0808685A), (ecx_504, l08086871), (ecx_221, l0808690E))
	dwLoc24_380 = PHI((dwLoc24_364, l0808685A), (dwLoc24_475, l08086871), (dwLoc24_492, l0808690E))
	dwLoc2C_369 = PHI((dwLoc2C_367, l0808685A), (dwLoc2C_472, l08086871), (dwLoc2C_491, l0808690E))
	edx_59 = PHI((edx_35, l0808685A), (edx_326, l08086871), (edx_230, l0808690E))
	ebx_58 = PHI((ebx_29, l0808685A), (ebx_320, l08086871), (ebx_325, l0808690E))
	Mem49 = PHI((Mem37, l0808685A), (Mem310, l08086871), (Mem285, l0808690E))
	ebp_42 = PHI((ebp_41, l0808685A), (ebp_296, l08086871), (ebp_283, l0808690E))
	al_44 = (byte) ebp_42
	eax_45 = (word32) al_44
	branch eax_45 == 0x40 l08086860
l08086884:
	branch eax_45 == 0xFF l0808693C
l0808688F:
	branch eax_45 != 0x49 l080868C0
l08086894:
	branch dwLoc2C_369 != 0x09 l080868C0
l0808689A:
	branch *dwArg08 != 0x0F l08086930
l080868A7:
	branch *dwArg0C != 0x06 l08086930
l080868B4:
	v17_205 = dwLoc24_380 - 0x03
	dwLoc24_395 = v17_205
	dwLoc2C_396.u0 = 0x06
l080868C0:
	dwLoc24_492 = PHI((dwLoc24_380, l0808688F), (dwLoc24_380, l08086894), (dwLoc24_395, l080868B4), (dwLoc24_380, l08086930))
	dwLoc2C_491 = PHI((dwLoc2C_369, l0808688F), (dwLoc2C_369, l08086894), (dwLoc2C_396, l080868B4), (dwLoc2C_394, l08086930))
	Mem210 = PHI((Mem49, l0808688F), (Mem49, l08086894), (Mem208, l080868B4), (Mem204, l08086930))
	bl_330 = (byte) ebp_42
	ecx_215.u0 = 0x44
	edx_216.u0 = 0x00
	goto l080868DE
l080868D8:
	ecx_288 = eax_222 >> 0x01
l080868DA:
	edx_291 = PHI((edx_289, l080868EC), (edx_220, l080868D8))
	ecx_290 = PHI((ecx_221, l080868EC), (ecx_288, l080868D8))
	branch ecx_290 <= edx_291 l08086871
l080868DE:
	ecx_221 = PHI((ecx_215, l080868C0), (ecx_290, l080868DA))
	edx_220 = PHI((edx_216, l080868C0), (edx_291, l080868DA))
	eax_222 = edx_220 + ecx_221
	esi_225 = 0x080B2740 + (eax_222 >> 0x01) * 0x08
	ebx_325 = ebp_42
	branch bl_330 == esi_225->b0000 l080868F8
l080868EA:
	branch bl_330 < esi_225->b0000 l080868D8
l080868EC:
	edx_289 = (eax_222 >> 0x01) + 0x01
	goto l080868DA
l080868F8:
	edx_230 = (word32) esi_225->b0003
	dl_278 = (byte) edx_230
	branch edx_230 == dwLoc2C_491 l080869DD
l08086905:
	branch dl_278 != 0x06 l08086871
l0808690E:
	ebp_283 = ebp_42 >> 0x08
	*ecx = 0x01
	branch ebp_283 != 0x00 l0808687A
l0808691E:
l08086922:
	edx_505 = PHI((edx_79, l080869CF), (edx_230, l080869F9), (edx_230, l08086A3C), (edx_230, l08086A02))
	ecx_501 = PHI((ecx_338, l080869CF), (ecx_338, l08086A80), (ecx_221, l080869F9), (ecx_221, l08086A3C), (ecx_221, l08086A02))
	eax_500 = PHI((eax_192, l080869CF), (eax_186, l08086A80), (eax_277, l080869F9), (eax_239, l08086A3C), (eax_242, l08086A02))
	ecxOut = ecx_501
	edxOut = edx_505
	return eax_500
l08086930:
	dwLoc2C_394.u0 = 0x09
	goto l080868C0
l0808693C:
	ecx_57 = 0x00
	ecx_24_8_327 = 0x00
	__cpuid(0x04, 0x00, &0x04, &ebx_58, &0x00, &edx_59)
	edx_61 = 0x04
	esi_65.u0 = 0x00
	dwLoc20_370.u0 = 0x00
	goto l0808697E
l0808694C:
l08086964:
	branch dwLoc2C_369 == 0x03 l080869AB
l0808696A:
	esi_132 = (word32) esi_128 + 1
	ecx_140 = esi_132
	ecx_24_8_328 = SLICE(esi_132, word24, 8)
	__cpuid(0x04, esi_132, &0x04, &ebx_58, &esi_132, &0x04)
	dwLoc20_376 = esi_132
	edx_154 = 0x04
l0808697E:
	dwLoc20_387 = PHI((dwLoc20_370, l0808694C), (dwLoc20_376, l0808696A))
	esi_128 = PHI((esi_65, l0808694C), (esi_132, l0808696A))
	Mem86 = PHI((Mem69, l0808694C), (Mem153, l0808696A))
	edx_79.u0 = 0x04
	ecx_24_8_76 = PHI((ecx_24_8_327, l0808694C), (ecx_24_8_328, l0808696A))
	ecx_77 = SEQ(ecx_24_8_76, 0)
	ecx_340 = ecx_77
	ecx_339 = ecx_340
	goto l08086A53
l08086991:
l080869C6:
	branch eax_163 != 0x02 l08086AAE
l080869CF:
	ebx_189 = ebx_58 & 0x0FFF
	eax_192 = ebx_189 + 0x01
	goto l08086922
l080869DD:
	eax_236 = dwLoc24_492 - 0xB9 - dwLoc2C_491
	branch eax_236 == 0x00 l08086A3C
l080869EB:
	branch eax_236 == 0x01 l08086A02
l080869F0:
	branch eax_236 != 0x02 l08086A8B
l080869F9:
	eax_277 = (word32) esi_225->b0002
	goto l08086922
l08086A02:
	eax_242 = (word32) esi_225->b0001
	goto l08086922
l08086A3C:
	eax_239 = esi_225->t0004
	goto l08086922
l08086A44:
l08086A49:
	branch dwLoc2C_369 == 0x06 l080869AB
l08086A53:
	goto l08086A62
l08086A58:
	branch dwLoc2C_369 == 0x09 l080869AB
l08086A62:
	goto l0808696A
l08086A6B:
	branch dwLoc2C_369 == 0x0C l080869AB
	goto l0808696A
l08086A75:
l08086A80:
	ebx_184 = ebx_58 >> 22
	eax_186 = ebx_184 + 0x01
	goto l08086922
l08086A8B:
	ebx_245 = 0x080CE000
	esp_249 = fp - 0x34
l08086A9B:
	esp_253 = PHI((esp_275, l08086AAE), (esp_249, l08086A8B))
	ebx_251 = PHI((ebx_271, l08086AAE), (ebx_245, l08086A8B))
	eax_252 = ebx_251 + ~0x0001BA41
	esp_254 = esp_253 - 4
	esp_254->dw0000 = eax_252
	eax_256 = ebx_251 + ~0x0001BA14
	esp_257 = esp_254 - 4
	esp_254->dwFFFFFFFC = eax_256
	__assert_fail(out ecx_541, out edx_542)
l08086AAE:
	Mem270 = PHI((Mem86, l080869C6), (Mem258, l08086A9B))
	esp_269 = PHI((esp_18, l080869C6), (esp_257, l08086A9B))
	ebx_271 = esp_269->ptr0004
	esp_273 = esp_269 - 4
	esp_273->dw0000 = ebx_271 + 4294855020
	esp_275 = esp_273 - 4
	esp_273->dwFFFFFFFC = 0xC0
	goto l08086A9B
intel_check_word.isra.0_exit:
}

// 08086AC0: Register Eq_2 handle_intel.constprop.1(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 ebx, Register (ptr32 Eq_916) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_952 ebxOut, Register out Eq_952 ebpOut, Register out Eq_954 ediOut)
// Called from:
//      init_cacheinfo
//      __cache_sysconf
Eq_2 handle_intel.constprop.1(Eq_2 eax, Eq_2 ecx, Eq_2 ebx, struct Eq_916 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_952 & ebxOut, union Eq_952 & ebpOut, union Eq_954 & ediOut)
{
	Eq_2 eax_117;
	Eq_2 edx_116 = 0x080CE000;
	word32 eax_22 = gs->dw0014;
	if (g_t80CF8E4 > 0x01)
	{
		up32 dwLoc34_201 = 0x01;
		up32 dwLoc44_202 = 0x01;
		while (true)
		{
			__cpuid(0x02, ecx, &0x02, &ebx, &ecx, &edx_116);
			if (dwLoc44_202 == 0x01)
				dwLoc34_201 = 0x02;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, edx, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			ebx = eax;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, ebx, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, ecx, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, edx_116, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			edx_116 = dwLoc44_202 + 0x01;
			if (dwLoc34_201 <= dwLoc44_202)
			{
				edx_116 = eax - 191;
				if (eax <= 0xC4)
					eax_117 = -0x00;
				break;
			}
			++dwLoc44_202;
		}
	}
	else
		eax_117.u0 = ~0x00;
	Eq_954 edi_161 = eax_22 ^ gs->dw0014;
	if (edi_161 != 0x00)
	{
		word32 ecx_277;
		word32 edx_278;
		__stack_chk_fail(out ecx_277, out edx_278);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 edx_176;
		Eq_2 ecx_178;
		Eq_2 eax_177 = __cache_sysconf(ecx_178, ebx, stackArg4, out ecx_178, out edx_176);
		ecxOut = ecx_178;
		edxOut = edx_176;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		ediOut = edi_161;
		return eax_177;
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx_116;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		ediOut = edi;
		return eax_117;
	}
}

// 08086C20: Register Eq_2 __cache_sysconf(Register Eq_2 ecx, Register Eq_2 ebx, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __sysconf
//      handle_intel.constprop.1
Eq_2 __cache_sysconf(Eq_2 ecx, Eq_2 ebx, Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_9 = g_t80CF8E0;
	if (edx_9 == 0x01)
	{
		Eq_2 edx_12;
		Eq_2 ecx_14;
		word32 ebx_58;
		word32 ebp_59;
		word32 edi_60;
		Eq_2 eax_13 = handle_intel.constprop.1(eax, ecx_14, ebx, gs, out ecx_14, out edx_12, out ebx_58, out ebp_59, out edi_60);
		ecxOut = ecx_14;
		edxOut = edx_12;
		return eax_13;
	}
	else if (edx_9 == 0x02)
	{
		Eq_2 ecx_23;
		Eq_2 edx_24;
		word32 esi_61;
		word32 edi_62;
		Eq_2 eax_20 = handle_amd(dwArg04, ecx, edx_9, ebx, out ecx_23, out edx_24, out esi_61, out edi_62);
		ecxOut = ecx_23;
		edxOut = edx_24;
		return eax_20;
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx_9;
		return 0x00;
	}
}

// 08086C60: Register ui32 __wcslen(Stack (ptr32 Eq_101330) dwArg04)
// Called from:
//      __wcsrtombs
ui32 __wcslen(struct Eq_101330 * dwArg04)
{
	if (dwArg04->a0000[0] == 0x00)
		return 0x00;
	if (dwArg04->a0004[0] == 0x00)
		return 0x01;
	if (dwArg04->a0008[0] == 0x00)
		return 0x02;
	ui32 edx_31 = 0x00;
	while (true)
	{
		ui32 eax_38 = edx_31 + 0x03;
		if (dwArg04->a000C[edx_31] == 0x00)
			break;
		eax_38 = edx_31 + 0x04;
		if (dwArg04[eax_38 * 0x04 / 0x0C] == 0x00)
			return eax_38;
		ui32 ebx_48 = edx_31 + 0x05;
		if (dwArg04->a0004[eax_38] == 0x00)
			return ebx_48;
		ui32 edx_55 = edx_31 + 0x06;
		if (dwArg04->a0008[eax_38] == 0x00)
			return edx_55;
		edx_31 = eax_38;
	}
	return eax_38;
}

// 08086CE0: Register word32 __wmemcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      __printf_fp_l
//      register_printf_modifier
//      save_for_wbackup.isra.0
//      _IO_wdefault_pbackfail
word32 __wmemcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	word32 ecx_22;
	ptr32 edx_23;
	memcpy(dwArg04, dwArg08, dwArg0C << 0x02, out ecx_22, out edx_23);
	edxOut = edx_23;
	return ecx_22;
}

// 08086D10: void wmemmove(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __printf_fp_l
//      _IO_helper_overflow
//      save_for_wbackup.isra.0
void wmemmove(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	word32 edx_20;
	memmove(dwArg04, dwArg08, dwArg0C << 0x02, out edx_20);
}

// 08086D20: void __wmemset(Stack (ptr32 Eq_78689) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __printf_fp_l
void __wmemset(struct Eq_78689 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 esi_11 = dwArg0C;
	struct Eq_78689 * edx_13 = dwArg04;
	if (dwArg0C > 0x03)
	{
		Eq_2 ebx_16 = dwArg0C;
		do
		{
			edx_13->dw0000 = (word32) dwArg08;
			++edx_13;
			edx_13->dwFFFFFFF4 = (word32) dwArg08;
			edx_13->dwFFFFFFF8 = (word32) dwArg08;
			edx_13->dwFFFFFFFC = (word32) dwArg08;
			ebx_16 -= 0x04;
		} while (ebx_16 > 0x03);
		esi_11 = dwArg0C & 0x03;
		edx_13 = dwArg04 + ((dwArg0C - 0x04 >> 0x02) + 0x01 << 0x04) / 16;
	}
	if (esi_11 != 0x00)
	{
		edx_13->dw0000 = (word32) dwArg08;
		if (esi_11 != 0x01)
		{
			edx_13->dw0004 = (word32) dwArg08;
			if (esi_11 == 0x03)
				edx_13->dw0008 = (word32) dwArg08;
		}
	}
}

// 08086D80: void btowc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg2C)
void btowc(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg2C)
{
	struct Eq_101458 * esp_15 = fp - 0x4C;
	Eq_2175 eax_17 = gs->t0014;
	byte bl_97 = (byte) dwArg04;
	if (dwArg04 <= 0xFF && dwArg04 != ~0x00)
	{
		if ((dwArg04 & ~0x7F) != 0x00)
		{
			Eq_2 esi_33 = gs->ptrFFFFFFD0->t0000;
			struct Eq_101486 * edi_34 = *((word32) esi_33 + 20);
			if (edi_34 == null)
			{
				if (esi_33 != 0x080CC740)
				{
					word32 ebx_48;
					struct Eq_101698 * esi_52;
					word32 edi_357;
					__wcsmbs_load_conv(gs, esi_33, out ebx_48, out esi_52, out edi_357);
					Eq_2 esp_53 = <invalid>;
					bl_97 = (byte) ebx_48;
					edi_34 = esi_52->ptr0014;
					esp_15 = (word32) esp_53 + 16;
				}
				else
					edi_34 = (struct Eq_101486 *) 135055060;
			}
			Eq_2 eax_64 = edi_34->t0000;
			Eq_2 esi_65 = *((word32) eax_64 + 24);
			if (*eax_64 != 0x00)
				esi_65 = __ror(esi_65, 0x09) ^ gs->t0018;
			if (edi_34->dw0004 == 0x01 && esi_65 != 0x00)
			{
				struct Eq_101584 * esp_178 = esp_15 - 0x0C;
				esp_178->tFFFFFFFC = esi_65;
				word32 ecx_350;
				word32 edx_351;
				_dl_mcount_wrapper_check(gs, esp_178->tFFFFFFF8, esp_178->tFFFFFFFC, out ecx_350, out edx_351);
				Eq_2 edx_190 = esp_178->tFFFFFFFC;
				word32 ecx_192 = esp_178->dw0000;
				esp_178->dw0000 = (word32) bl_97;
				esp_178->tFFFFFFFC = edi_34->t0000;
				esi_65();
			}
			else
			{
				esp_15->dw0030 = 0x00;
				esp_15->ptr0010 = &esp_15->b003B;
				esp_15->ptr0018 = (char *) esp_15 + 0x0C;
				esp_15->dw0034 = 0x00;
				esp_15->b003B = bl_97;
				esp_15->ptr002C = &esp_15->dw0030;
				word32 * esi_89 = &esp_15->ptr0010;
				Eq_2 eax_103 = edi_34->t0000;
				esp_15->ptr001C = esi_89;
				Eq_2 ebx_105 = *((word32) eax_103 + 20);
				word32 eax_106 = *eax_103;
				esp_15->dw0024 = 0x00;
				esp_15->dw0028 = 0x01;
				esp_15->dw0020 = 0x01;
				if (eax_106 != 0x00)
					ebx_105 = __ror(ebx_105, 0x09) ^ gs->t0018;
				struct Eq_101620 * esp_121 = esp_15 - 0x0C;
				esp_121->tFFFFFFFC = ebx_105;
				word32 ecx_352;
				word32 edx_353;
				_dl_mcount_wrapper_check(gs, esp_121->tFFFFFFF8, esp_121->tFFFFFFFC, out ecx_352, out edx_353);
				esp_121->tFFFFFFF8.u0 = 0x01;
				esp_121->dwFFFFFFF4 = 0x00;
				esp_121->ptrFFFFFFF0 = &esp_121->dw001C + 1;
				esp_121->dwFFFFFFEC = 0x00;
				esp_121->dwFFFFFFE8 = esp_121->dw001C + 0x01;
				esp_121->ptrFFFFFFE4 = esi_89;
				esp_121->ptrFFFFFFE0 = &esp_121->dw001C + 2;
				esp_121->tFFFFFFDC = edi_34->t0000;
				up32 eax_163;
				ebx_105();
				if (eax_163 <= 0x05 || eax_163 == 0x00)
					;
			}
		}
	}
	if ((eax_17 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_348;
	word32 edx_349;
	__stack_chk_fail(out ecx_348, out edx_349);
	word32 esi_355;
	word32 edi_356;
	word32 ebp_354;
	wcrtomb(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg2C, out ebp_354, out esi_355, out edi_356);
}

// 08086F10: Register Eq_2 wcrtomb(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg2C, Register out (ptr32 Eq_72792) ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      btowc
Eq_2 wcrtomb(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg2C, struct Eq_72792 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 edi_11 = 0x080CE000;
	Eq_2175 ecx_20 = gs->t0014;
	Eq_2 esi_24 = dwArg04;
	if (dwArg04 == 0x00)
	{
		dwArg08.u0 = 0x00;
		esi_24 = fp - 0x30;
	}
	Eq_2 esi_140;
	Eq_2 ebx_49 = gs->ptrFFFFFFD0->t0000;
	Eq_2 dwLoc50_293 = esi_24;
	struct Eq_101735 * ebp_51 = *((word32) ebx_49 + 20);
	esi_140 = esi_24;
	if (ebp_51 == null)
	{
		if (ebx_49 != 0x080CC740)
		{
			struct Eq_101840 * ebx_69;
			__wcsmbs_load_conv(gs, ebx_49, out ebx_69, out esi_140, out edi_11);
			ebp_51 = ebx_69->ptr0014;
		}
		else
		{
			ebp_51 = (struct Eq_101735 *) 135055060;
			esi_140 = esi_24;
		}
	}
	struct Eq_101743 * eax_85 = ebp_51->ptr0008;
	Eq_2 ebx_107 = eax_85->t0014;
	if (eax_85->dw0000 != 0x00)
		ebx_107 = __ror(ebx_107, 0x09) ^ gs->t0018;
	Eq_2 esp_208;
	uint32 eax_146;
	Eq_2 eax_214;
	if (dwArg08 != 0x00)
	{
		word32 ecx_431;
		word32 edx_432;
		_dl_mcount_wrapper_check(gs, dwLoc70, ebx_107, out ecx_431, out edx_432);
		ebx_107();
		if ((eax_146 & ~0x04) == 0x00)
			goto l08087062;
	}
	else
	{
		word32 ecx_429;
		word32 edx_430;
		_dl_mcount_wrapper_check(gs, dwLoc70, ebx_107, out ecx_429, out edx_430);
		ebx_107();
		if ((eax_146 & ~0x04) == 0x00)
		{
			*esi_24 = 0x00;
			dwLoc50_293 = (word32) esi_24 + 1;
			goto l08087062;
		}
	}
	esp_208 = fp - 92;
	if (eax_146 > 0x07 || eax_146 < 0x05)
		goto l080870B6;
	if (eax_146 != 0x05)
	{
		gs->tFFFFFFE0.u0 = 0x54;
		eax_214.u0 = ~0x00;
l0808700B:
		if ((ecx_20 ^ gs->t0014) == 0x00)
		{
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return eax_214;
		}
		word32 ecx_435;
		word32 edx_436;
		__stack_chk_fail(out ecx_435, out edx_436);
		esp_208.u0 = <invalid>;
l080870B6:
		struct Eq_101796 * esp_241 = esp_208 - 4;
		esp_241->ptr0000 = edi_11 + ~0x0001B677;
		esp_241->dwFFFFFFFC = 101;
		esp_241->ptrFFFFFFF8 = edi_11 + ~0x0001B682;
		esp_241->ptrFFFFFFF4 = edi_11 + 4294793992;
		word32 ecx_433;
		word32 edx_434;
		__assert_fail(out ecx_433, out edx_434);
		struct Eq_72792 * ebp_260;
		ptr32 edi_263;
		ptr32 esi_265;
		Eq_2 eax_259 = __wcsrtombs(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg2C, out ebp_260, out esi_265, out edi_263);
		ebpOut = ebp_260;
		esiOut = esi_265;
		ediOut = edi_263;
		return eax_259;
	}
l08087062:
	eax_214 = dwLoc50_293 - esi_140;
	goto l0808700B;
}

// 080870E0: Register ui32 __wcsrtombs(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg2C, Register out (ptr32 Eq_76829) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      vfprintf
//      wcrtomb
ui32 __wcsrtombs(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg2C, struct Eq_76829 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 eax_19 = dwArg10;
	Eq_2 edi_113 = dwArg04;
	Eq_2175 esi_25 = gs->t0014;
	if (dwArg10 == 0x00)
		eax_19.u0 = 0x080CFA38;
	Eq_2 ebx_41 = gs->ptrFFFFFFD0->t0000;
	struct Eq_101883 * eax_42 = *((word32) ebx_41 + 20);
	if (eax_42 == null)
	{
		if (ebx_41 != 0x080CC740)
		{
			word32 edi_659;
			word32 esi_658;
			word32 ebx_657;
			__wcsmbs_load_conv(gs, ebx_41, out ebx_657, out esi_658, out edi_659);
			eax_42 = (struct Eq_101883 *) *((word32) ebx_41 + 20);
		}
		else
			eax_42 = (struct Eq_101883 *) 135055060;
	}
	struct Eq_76829 * ebp_72 = eax_42->ptr0008;
	Eq_2 esi_132 = ebp_72->t0014;
	if (ebp_72->dw0000 != 0x00)
		esi_132 = __ror(esi_132, 0x09) ^ gs->t0018;
	struct Eq_101905 * esp_252;
	ui32 ebx_110;
	Eq_2 eax_174;
	struct Eq_101330 * edx_87 = *dwArg08;
	if (dwArg04 != 0x00)
	{
		word32 ebx_210 = edx_87->a0004 + __wcsnlen(edx_87, dwArg0C);
		word32 ecx_660;
		word32 edx_661;
		_dl_mcount_wrapper_check(gs, dwLoc0190, esi_132, out ecx_660, out edx_661);
		esi_132();
		esp_252 = fp - 0x017C;
		ebx_110 = 0x00;
		if ((eax_174 & ~0x04) != 0x00 || *((word32) dwArg04 - 1) != 0x00)
			goto l080871EC;
		if (dwArg04 == dwArg04)
			goto l080873E6;
		if (*eax_19.u0 != 0x00)
		{
l080873C6:
			word32 esi_371 = esp_252->dw001C;
			struct Eq_102064 * esp_373 = esp_252 - (struct Eq_102065 *) 4;
			esp_373->dw0000 = esi_371 + ~0x0001B61F;
			esp_373->dwFFFFFFFC = 0x7B;
			esp_373->dwFFFFFFF8 = esi_371 + ~0x0001B66D;
			esp_373->dwFFFFFFF4 = esi_371 + 4294793922;
			word32 ecx_671;
			word32 edx_672;
			__assert_fail(out ecx_671, out edx_672);
l080873E6:
			word32 edx_670;
			word32 ecx_669;
			__assert_fail(out ecx_669, out edx_670);
			ui32 eax_415 = __wcsnlen((word32) dwArg2C - 112238, 122);
			ebpOut = ebp_72;
			esiOut = dwArg2C;
			ediOut = edi_113;
			return eax_415;
		}
		*dwArg08 = null;
	}
	else
	{
		ebx_110 = 0x00;
		edi_113 = fp - 288;
		word32 eax_114 = edx_87->a0004 + __wcslen(edx_87);
		do
		{
			word32 ecx_663;
			word32 edx_664;
			_dl_mcount_wrapper_check(gs, dwLoc0190, esi_132, out ecx_663, out edx_664);
			esi_132();
			dwLoc0190.u0 = 0x01;
			ebx_110 += fp - (struct Eq_101997 *) 288 - (fp - (struct Eq_101999 *) 288);
		} while (eax_174 == 0x05);
		if ((eax_174 & ~0x04) != 0x00)
		{
l080871EC:
			uint32 edx_273 = eax_174 - 0x04;
			if (eax_174 != 0x00 && edx_273 > 0x03)
			{
				edi_113.u0 = 0x080CE000;
				word32 ecx_662;
				eax_174 = __assert_fail(out ecx_662, out edx_273);
			}
			if (eax_174 != 0x00 && edx_273 > 0x01)
			{
				gs->tFFFFFFE0.u0 = 0x54;
				ebx_110 = ~0x00;
			}
			if ((esi_25 ^ gs->t0014) == 0x00)
			{
				ebpOut = ebp;
				esiOut = esi;
				ediOut = edi;
				return ebx_110;
			}
			word32 ecx_667;
			word32 edx_668;
			__stack_chk_fail(out ecx_667, out edx_668);
l080873A6:
			word32 edx_666;
			word32 ecx_665;
			__assert_fail(out ecx_665, out edx_666);
			esp_252 = fp - (struct Eq_102018 *) 0x018C;
			goto l080873C6;
		}
		if (bLoc0121 != 0x00)
			goto l080873A6;
	}
	--ebx_110;
	goto l080871EC;
}

// 08087410: Register ui32 __wcsnlen(Stack (ptr32 Eq_101330) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __wcsrtombs
ui32 __wcsnlen(struct Eq_101330 * dwArg04, Eq_2 dwArg08)
{
	Eq_2 ecx_48 = dwArg08;
	if (dwArg08 == 0x00 || (dwArg04->a0000)[0] == 0x00)
		return 0x00;
	if (dwArg08 == 0x01 || (dwArg04->a0004)[0] == 0x00)
		return 0x01;
	if (dwArg08 == 0x02)
		return 0x02;
	ui32 edx_39 = 0x02;
	do
	{
		ui32 eax_47;
		if (dwArg04[edx_39 * 0x04 / 0x0C] == 0x00)
			break;
		eax_47 = edx_39 + 0x01;
		if (ecx_48 == 0x03 || (dwArg04->a0004)[edx_39] == 0x00)
			return eax_47;
		eax_47 = edx_39 + 0x02;
		ecx_48 -= 0x04;
		if (ecx_48 == 0x00 || (dwArg04->a0008)[edx_39] == 0x00)
			return eax_47;
		eax_47 = edx_39 + 0x03;
		if (ecx_48 == 0x01 || (dwArg04->a000C)[edx_39] == 0x00)
			return eax_47;
		edx_39 += 0x04;
	} while (ecx_48 != 0x02);
	eax_47 = edx_39;
	return eax_47;
}

// 080874A0: Register Eq_2 wcschrnul(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      __vfwprintf
//      __parse_one_specwc
Eq_2 wcschrnul(Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 eax_14 = dwArg04;
	word32 edx_10 = *dwArg04;
	if (dwArg08 != edx_10)
	{
		while (edx_10 != 0x00)
		{
			eax_14 = (word32) eax_14 + 4;
			edx_10 = (word32) *eax_14;
			if (edx_10 == dwArg08)
				return eax_14;
		}
	}
	return eax_14;
}

// 080874D0: Register word32 time(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
// Called from:
//      get_nprocs
word32 time(struct Eq_9 * gs, word32 dwArg04)
{
	word32 eax_10;
	gs->ptr0010();
	return eax_10;
}

// 080874F0: Register Eq_2 __alloc_dir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_43241 bArg08, Stack Eq_2 dwArg10)
// Called from:
//      opendir
//      __fdopendir
Eq_2 __alloc_dir(struct Eq_9 * gs, Eq_2 dwArg04, Eq_43241 bArg08, Eq_2 dwArg10)
{
	Eq_2 esi_103;
	if ((byte) dwArg08 != 0x00 || __fcntl64_nocancel() >= 0x00)
	{
		Eq_2 eax_42 = 0x801C;
		Eq_2 edi_141 = 0x8000;
		if (dwArg10 != 0x00)
		{
			Eq_2 edx_50 = 0x8000;
			if (*((word32) dwArg10 + 52) >= 0x8000)
				edx_50 = *((word32) dwArg10 + 52);
			edi_141 = edx_50;
			if (edx_50 > 0x00100000)
				edi_141.u0 = 0x00100000;
			eax_42 = (word32) edi_141 + 28;
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_230;
		word32 ebx_231;
		word32 edi_234;
		word32 ebp_232;
		word32 esi_233;
		word32 ecx_229;
		Eq_2 eax_86 = __libc_malloc(gs, stackArg0, eax_42, out ecx_229, out edx_230, out ebx_231, out ebp_232, out esi_233, out edi_234);
		esi_103 = eax_86;
		if (eax_86 != 0x00)
		{
l08087557:
			*((byte) esi_103.u0 + 4) = 0x00;
			*((byte) esi_103.u0 + 8) = edi_141;
			*esi_103.u0 = dwArg04;
			*((byte) esi_103.u0 + 0x0C) = 0x00;
			*((byte) esi_103.u0 + 16) = 0x00;
			*((byte) esi_103.u0 + 20) = 0x00;
			((byte) esi_103.u0 + 24)->u0 = 0x00;
			return esi_103;
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_237;
		word32 ebx_238;
		word32 edi_241;
		word32 ebp_239;
		word32 esi_240;
		word32 ecx_236;
		Eq_2 eax_99 = __libc_malloc(gs, stackArg0, 8220, out ecx_236, out edx_237, out ebx_238, out ebp_239, out esi_240, out edi_241);
		edi_141.u0 = 0x2000;
		esi_103 = eax_99;
		if (eax_99 != 0x00)
			goto l08087557;
		if ((byte) dwArg08 != 0x00)
		{
			Eq_2 ebp_123 = gs->tFFFFFFE0;
			word32 edx_242;
			__close_nocancel(gs, dwArg04, out edx_242);
			gs->tFFFFFFE0 = ebp_123;
			return esi_103;
		}
	}
	esi_103.u0 = 0x00;
	return esi_103;
}

// 08087600: Register Eq_2 opendir_tail(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      __opendirat
//      opendir
Eq_2 opendir_tail(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2175 eax_19 = gs->t0014;
	if (eax >= 0x00)
	{
		word32 ecx_148;
		word32 edx_149;
		if (__fxstat64(gs, eax, fp - 0x70, out ecx_148, out edx_149) >= 0x00)
		{
			if ((dwLoc60 & 0xF000) == 0x4000)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_43241 stackArg8 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				__alloc_dir(gs, stackArg4, stackArg8, stackArg16);
				goto l08087658;
			}
			gs->tFFFFFFE0.u0 = 0x14;
		}
		word32 edx_157;
		__close_nocancel(gs, eax, out edx_157);
	}
l08087658:
	if ((eax_19 ^ gs->t0014) == 0x00)
		return;
	word32 edx_154;
	word32 ecx_153;
	__stack_chk_fail(out ecx_153, out edx_154);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	__opendirat(gs, stackArg4, stackArg8);
	return;
}

// 080876A0: void __opendirat(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      opendir
void __opendirat(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	if (*dwArg08 == 0x00)
		gs->tFFFFFFE0.u0 = 0x02;
	else
	{
		Eq_2 eax_26 = __openat_nocancel(gs, dwArg04, dwArg08, 0x00098800, dwLoc10);
		opendir_tail(eax_26, gs);
	}
}

// 08087700: Register word32 opendir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      get_nprocs_conf
word32 opendir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (*dwArg04 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x02;
		return 0x00;
	}
	else
	{
		word32 ecx_63;
		word32 edx_64;
		Eq_2 eax_23 = __open_nocancel(gs, dwArg04, 0x00098800, dwLoc14, out ecx_63, out edx_64);
		return opendir_tail(eax_23, gs);
	}
}

// 08087750: Register word32 closedir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
//      get_nprocs_conf
word32 closedir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 22;
		return ~0x00;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 esi_29 = *dwArg04;
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_69;
		word32 edx_70;
		free(gs, stackArg0, dwArg04, out ecx_69, out edx_70);
		word32 edx_71;
		return __close_nocancel(gs, esi_29, out edx_71);
	}
}

// 080877A0: Register Eq_2 __readdir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
Eq_2 __readdir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_24 = gs->tFFFFFFE0;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_31;
	if (!__cmpxchg(*((word32) dwArg04 + 4), 0x01, 0x00, out eax_31))
		__lll_lock_wait_private(eax_31, (word32) dwArg04 + 4, gs);
	Eq_102434 eax_43 = *((word32) dwArg04 + 16);
	do
	{
		Eq_2 edx_122;
		Eq_2 ecx_100;
		word32 edx_46 = (word32) eax_43.u1 + 28;
		if (*((word32) dwArg04 + 0x0C) <= eax_43)
		{
			Eq_102434 eax_67 = __getdents(gs, *dwArg04, (word32) dwArg04 + 28, *((word32) dwArg04 + 8), out ecx_100);
			if (eax_67 <= 0x00)
			{
				if (eax_67 != 0x00)
				{
					edx_122.u0 = 0x00;
					if (gs->tFFFFFFE0 != 0x02)
						break;
				}
				gs->tFFFFFFE0 = edi_24;
				edx_122.u0 = 0x00;
				break;
			}
			*((word32) dwArg04 + 0x0C) = eax_67;
			edx_46 = 0x1C;
			eax_43.u0 = 0x00;
		}
		edx_122 = (word32) dwArg04 + edx_46;
		eax_43 = (word32) eax_43.u1 + (word32) (*((word32) edx_122 + 8));
		word32 ecx_97 = *((word32) edx_122 + 4);
		*((word32) dwArg04 + 16) = eax_43;
		*((word32) dwArg04 + 20) = ecx_97;
		ecx_100 = *edx_122;
	} while (ecx_100 == 0x00);
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v18_113 = *((word32) dwArg04 + 4) - 0x01;
	*((word32) dwArg04 + 4) = v18_113;
	if (v18_113 != 0x00)
		__lll_unlock_wake_private((word32) dwArg04 + 4, ecx_100, edx_122, gs);
	return edx_122;
}

// 08087870: Register Eq_2 __rewinddir(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
Eq_2 __rewinddir(Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_18;
	if (!__cmpxchg(*((word32) dwArg04 + 4), 0x01, 0x00, out eax_18))
		__lll_lock_wait_private(eax_18, (word32) dwArg04 + 4, gs);
	word32 ebp_94;
	word32 ebx_93;
	word32 edi_96;
	Eq_2 ecx_42;
	word32 esi_95;
	__libc_lseek(gs, *dwArg04, 0x00, 0x00, out ecx_42, out ebx_93, out ebp_94, out esi_95, out edi_96);
	*((word32) dwArg04 + 20) = 0x00;
	*((word32) dwArg04 + 16) = 0x00;
	*((word32) dwArg04 + 0x0C) = 0x00;
	((word32) dwArg04 + 24)->u0 = 0x00;
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v12_52 = *((word32) dwArg04 + 4) - 0x01;
	*((word32) dwArg04 + 4) = v12_52;
	if (v12_52 != 0x00)
		__lll_unlock_wake_private((word32) dwArg04 + 4, ecx_42, edx, gs);
	return edx;
}

// 080878F0: Register (ptr32 Eq_224) __getdents(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut)
// Called from:
//      __readdir
struct Eq_224 * __getdents(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut)
{
	struct Eq_102612 * esp_16 = fp - 0x016C;
	Eq_2 ecx_19 = fp - 0x0134;
	Eq_2175 esi_23 = gs->t0014;
	if (dwArg0C >= 0x010D)
		ecx_19 = dwArg08;
	struct Eq_224 * eax_135;
	Eq_2 ecx_108;
	gs->ptr0010();
	Eq_2 ebp_120 = ecx_19;
	if (eax_135 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_320;
		eax_135 = __syscall_error(eax_135, gs, out edx_320);
		esp_16 = fp - 0x0168;
	}
	if (eax_135 != (struct Eq_224 *) ~0x00)
	{
		word32 eax_56 = eax_135 + ecx_19;
		ecx_108 = esp_16->t002C;
		esp_16->t0028 = eax_56;
		if (ecx_19 < eax_56)
		{
			esp_16->dw0008 = ~0x00;
			esp_16->dw000C = ~0x00;
			Eq_2 ebx_127 = ecx_108;
			do
			{
				int32 esi_68 = (word32) *((word32) ebp_120 + 16);
				struct Eq_102671 * esp_71 = esp_16 - 0x04;
				Eq_2 ecx_72 = *((word32) ebp_120 + 0x0C);
				Eq_2 edi_73 = *((word32) ebp_120 + 8);
				esp_71->dw0020 = (word32) *((word32) ebp_120 + 4);
				esp_71->t001C = ecx_72;
				esp_71->dw0024 = esi_68 - 0x05 & ~0x03;
				esp_71->t0018 = *ebp_120;
				esp_71->t002B = *((word32) ebp_120 + 18);
				esp_71->tFFFFFFFC = esi_68 - 0x13;
				esp_71->tFFFFFFF8 = (word32) ebp_120 + 19;
				esp_71->tFFFFFFF4 = (word32) ebx_127 + 11;
				word32 edx_321;
				memmove(esp_71->tFFFFFFF4, esp_71->tFFFFFFF8, esp_71->tFFFFFFFC, out edx_321);
				Eq_2 eax_104 = esp_71->t0018;
				word32 edx_106 = esp_71->dw0020;
				*((word32) ebx_127 + 4) = edi_73;
				ecx_108 = esp_71->t001C;
				*ebx_127 = eax_104;
				if (edx_106 != 0x00 || ecx_108 != SLICE((int64) edi_73, word32, 32))
				{
					if ((esp_71->t000C & esp_71->t0010) != ~0x00)
					{
						esp_71->t0018 = ebx_127;
						esp_71->dw0000 = 0x00;
						esp_71->tFFFFFFFC = esp_71->t0010;
						esp_71->tFFFFFFF8 = esp_71->t000C;
						esp_71->tFFFFFFF4 = esp_71->t0174;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						word32 ebx_325;
						word32 edi_327;
						word32 esi_326;
						word32 edx_324;
						lseek64(gs, stackArg4, dwArg04, dwArg08, dwArg0C, out edx_324, out ebx_325, out esi_326, out edi_327);
						ecx_108 = esp_71->t0018;
						eax_135 = ecx_108 - esp_71->dw0030;
					}
					else
					{
						word32 edx_322;
						eax_135 = __syscall_error((struct Eq_224 *) ~0x4A, gs, out edx_322);
					}
					goto l08087A47;
				}
				int32 edx_118 = esp_71->dw0024;
				Eq_64787 al_125 = esp_71->t002B;
				esp_71->t000C = edi_73;
				esp_71->t0010 = ecx_108;
				((word32) ebx_127 + 8)->u5 = (word16) edx_118;
				*((word32) ebx_127 + 0x0A) = al_125;
				ebp_120 = (word32) ebp_120 + esi_68;
				ebx_127 = (word32) ebx_127 + edx_118;
			} while (esp_71->t002C > ebp_120);
			ecx_108 = ebx_127;
		}
		eax_135 = ecx_108 - esp_16->t002C;
	}
l08087A47:
	if ((esi_23 ^ gs->t0014) != 0x00)
	{
		word32 edx_329;
		word32 ecx_328;
		__stack_chk_fail(out ecx_328, out edx_329);
		Eq_2 ecx_206;
		struct Eq_224 * eax_205 = readdir64(gs, dwLoc0168, out ecx_206);
		ecxOut = ecx_206;
		return eax_205;
	}
	else
	{
		ecxOut = ecx_108;
		return eax_135;
	}
}

// 08087AA0: Register Eq_2 readdir64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      get_nprocs_conf
//      __getdents
Eq_2 readdir64(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 edi_24 = gs->tFFFFFFE0;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_31;
	if (!__cmpxchg(*((word32) dwArg04 + 4), 0x01, 0x00, out eax_31))
		__lll_lock_wait_private(eax_31, (word32) dwArg04 + 4, gs);
	Eq_102875 eax_43 = *((word32) dwArg04 + 16);
	do
	{
		Eq_2 edx_125;
		Eq_2 ecx_103;
		word32 edx_46 = (word32) eax_43.u1 + 28;
		if (*((word32) dwArg04 + 0x0C) <= eax_43)
		{
			Eq_102875 eax_64 = __getdents64(gs, *dwArg04, (word32) dwArg04 + 28, *((word32) dwArg04 + 8), out ecx_103);
			if (eax_64 <= 0x00)
			{
				if (eax_64 != 0x00)
				{
					edx_125.u0 = 0x00;
					if (gs->tFFFFFFE0 != 0x02)
						break;
				}
				gs->tFFFFFFE0 = edi_24;
				edx_125.u0 = 0x00;
				break;
			}
			*((word32) dwArg04 + 0x0C) = eax_64;
			edx_46 = 0x1C;
			eax_43.u0 = 0x00;
		}
		edx_125 = (word32) dwArg04 + edx_46;
		eax_43 = (word32) eax_43.u1 + (word32) (*((word32) edx_125 + 16));
		word32 ecx_99 = *((word32) edx_125 + 8);
		*((word32) dwArg04 + 16) = eax_43;
		*((word32) dwArg04 + 20) = ecx_99;
		ecx_103 = *((word32) edx_125 + 4) | *edx_125;
	} while (ecx_103 == 0x00);
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v18_116 = *((word32) dwArg04 + 4) - 0x01;
	*((word32) dwArg04 + 4) = v18_116;
	if (v18_116 != 0x00)
		__lll_unlock_wake_private((word32) dwArg04 + 4, ecx_103, edx_125, gs);
	ecxOut = ecx_103;
	return edx_125;
}

// 08087B70: Register word32 __fdopendir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
word32 __fdopendir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 eax_157;
	Eq_2175 eax_17 = gs->t0014;
	word32 ecx_173;
	word32 edx_174;
	if (__fxstat64(gs, dwArg04, fp - 0x70, out ecx_173, out edx_174) >= 0x00)
	{
		if ((dwLoc60 & 0xF000) == 0x4000)
		{
			int32 eax_53 = __fcntl64_nocancel();
			if (eax_53 != ~0x00)
			{
				if ((eax_53 & 0x03) != 0x01)
					eax_157 = __alloc_dir(gs, dwArg04, 0x00, fp - 0x70);
				else
				{
					gs->tFFFFFFE0.u0 = 22;
					eax_157 = 0x00;
				}
l08087BE6:
				if ((eax_17 ^ gs->t0014) == 0x00)
					return eax_157;
				word32 ecx_175;
				word32 edx_176;
				__stack_chk_fail(out ecx_175, out edx_176);
				return __uname(dwArg04, gs, dwLoc78);
			}
		}
		else
			gs->tFFFFFFE0.u0 = 0x14;
	}
	eax_157 = 0x00;
	goto l08087BE6;
}

// 08087C30: Register (ptr32 Eq_224) __uname(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04)
// Called from:
//      _dl_discover_osversion
//      __fdopendir
struct Eq_224 * __uname(Eq_2 ebx, struct Eq_9 * gs, ptr32 dwArg04)
{
	struct Eq_224 * eax_11;
	gs->ptr0010();
	if (eax_11 < (struct Eq_224 *) ~0x0FFE)
		return eax_11;
	word32 edx_35;
	return __syscall_error(eax_11, gs, out edx_35);
}

// 08087C60: Register word32 __getuid(Register (ptr32 Eq_48873) gs)
// Called from:
//      __libc_init_secure
word32 __getuid(struct Eq_48873 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087C80: Register word32 __geteuid(Register (ptr32 Eq_48873) gs)
// Called from:
//      __libc_init_secure
word32 __geteuid(struct Eq_48873 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087CA0: Register word32 __getgid(Register (ptr32 Eq_48873) gs)
// Called from:
//      __libc_init_secure
word32 __getgid(struct Eq_48873 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087CC0: Register word32 __getegid(Register (ptr32 Eq_48873) gs)
// Called from:
//      __libc_init_secure
word32 __getegid(struct Eq_48873 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087CE0: Register (ptr32 Eq_224) __lxstat64(Register (ptr32 Eq_9) gs, Stack ptr32 dwArg08, Stack (ptr32 word32) dwArg0C)
// Called from:
//      getcwd
struct Eq_224 * __lxstat64(struct Eq_9 * gs, ptr32 dwArg08, word32 * dwArg0C)
{
	struct Eq_224 * eax_11;
	gs->ptr0010();
	if (eax_11 <= (struct Eq_224 *) ~0x0FFF)
		return eax_11;
	word32 edx_44;
	return __syscall_error(eax_11, gs, out edx_44);
}

// 08087D10: Register (ptr32 Eq_224) __fxstatat64(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      getcwd
struct Eq_224 * __fxstatat64(struct Eq_9 * gs, word32 dwArg04, word32 dwArg08, byte * dwArg0C, word32 dwArg10, Eq_2 dwArg14)
{
	if (dwArg04 != 0x03)
	{
		word32 edx_74;
		return __syscall_error((struct Eq_224 *) ~0x15, gs, out edx_74);
	}
	else
	{
		struct Eq_224 * eax_31;
		gs->ptr0010();
		if (eax_31 <= (struct Eq_224 *) ~0x0FFF)
			return null;
		word32 edx_73;
		return __syscall_error(eax_31, gs, out edx_73);
	}
}

// 08087D70: Register (ptr32 Eq_224) __libc_lseek(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out (ptr32 Eq_102555) ebxOut, Register out (ptr32 Eq_102556) ebpOut, Register out (ptr32 Eq_102557) esiOut, Register out Eq_2 ediOut)
// Called from:
//      __rewinddir
//      _dl_process_pt_note
//      open_verify.constprop.7
//      _dl_map_object_from_fd.constprop.8
//      _dl_start_profile
struct Eq_224 * __libc_lseek(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, struct Eq_102555 & ebxOut, union Eq_102556 & ebpOut, struct Eq_102557 & esiOut, union Eq_2 & ediOut)
{
	Eq_2175 eax_20 = gs->t0014;
	ptr32 ecx_36;
	struct Eq_224 * eax_116;
	gs->ptr0010();
	if (eax_116 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_159;
		eax_116 = __syscall_error(eax_116, gs, out edx_159);
	}
	if (eax_116 == null)
	{
		eax_116 = dwLoc2C;
		if (dwLoc28 != dwLoc2C >> 0x1F)
		{
			gs->tFFFFFFE0.u0 = 0x4B;
			eax_116 = (struct Eq_224 *) ~0x00;
		}
	}
	struct Eq_102555 * ebx_66 = eax_20 ^ gs->t0014;
	if (ebx_66 != null)
	{
		word32 ecx_160;
		word32 edx_161;
		__stack_chk_fail(out ecx_160, out edx_161);
		ptr32 ecx_84;
		struct Eq_224 * eax_82 = __isatty(gs, out ecx_84);
		ecxOut = ecx_84;
		ebxOut = ebx_66;
		ebpOut = (union Eq_102556 *) &g_t80CE000;
		esiOut = fp - 44;
		ediOut = dwArg0C;
		return eax_82;
	}
	else
	{
		ecxOut = ecx_36;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return eax_116;
	}
}

// 08087E20: Register Eq_2 __isatty(Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut)
// Called from:
//      _IO_file_doallocate
//      __libc_lseek
Eq_2 __isatty(struct Eq_9 * gs, ptr32 & ecxOut)
{
	Eq_2175 eax_7 = gs->t0014;
	ptr32 ecx_47;
	int8 al_24 = (int8) (tcgetattr(gs, dwArg04, fp - 0x4C, out ecx_47) == 0x00);
	if ((eax_7 ^ gs->t0014) != 0x00)
	{
		word32 ecx_66;
		word32 edx_67;
		__stack_chk_fail(out ecx_66, out edx_67);
		ptr32 ecx_34;
		word32 edx_68;
		Eq_2 eax_33 = __open64_nocancel(gs, dwLoc48, dwLoc44, dwLoc40, out ecx_34, out edx_68);
		ecxOut = ecx_34;
		return eax_33;
	}
	else
	{
		ecxOut = ecx_47;
		return (word32) al_24;
	}
}

// 08087E70: Register (ptr32 Eq_224) __open64_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _dl_discover_osversion
//      __isatty
//      open_verify.constprop.7
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_224 * __open64_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	byte dh_25 = SLICE(dwArg08, byte, 8);
	if (((byte) dwArg08 & 0x40) != 0x00 || (dwArg08 & 0x00410000) == 0x00410000)
		;
	ptr32 ecx_43;
	struct Eq_224 * eax_42;
	ptr32 edx_41;
	gs->ptr0010();
	if (eax_42 > (struct Eq_224 *) ~0x0FFF)
		eax_42 = __syscall_error(eax_42, gs, out edx_41);
	ecxOut = ecx_43;
	edxOut = edx_41;
	return eax_42;
}

// 08087EE0: Register (ptr32 Eq_224) __openat_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack ui32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      __opendirat
struct Eq_224 * __openat_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ui32 dwArg0C, word32 dwArg10)
{
	if (((byte) dwArg0C & 0x40) != 0x00 || (dwArg0C & 0x00410000) == 0x00410000)
		;
	struct Eq_224 * eax_36;
	gs->ptr0010();
	if (eax_36 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_84;
		eax_36 = __syscall_error(eax_36, gs, out edx_84);
	}
	return eax_36;
}

// 08087F40: Register (ptr32 Eq_224) tcgetattr(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 Eq_103143) dwArg08, Register out ptr32 ecxOut)
// Called from:
//      __isatty
struct Eq_224 * tcgetattr(struct Eq_9 * gs, word32 dwArg04, struct Eq_103143 * dwArg08, ptr32 & ecxOut)
{
	Eq_2175 eax_13 = gs->t0014;
	struct Eq_224 * eax_23;
	ptr32 ecx_119;
	gs->ptr0010();
	if (eax_23 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_175;
		eax_23 = __syscall_error(eax_23, gs, out edx_175);
	}
	if (eax_23 == null)
	{
		dwArg08->dw0024 = 0x00;
		dwArg08->dw0028 = 0x00;
		dwArg08->dw000C = dwLoc28;
		dwArg08->dw0000 = dwLoc34;
		dwArg08->b0010 = bLoc24;
		dwArg08->dw0004 = dwLoc30;
		dwArg08->dw0011 = dwLoc23;
		dwArg08->dw0008 = dwLoc2C;
		dwArg08->dw0015 = dwLoc1F;
		dwArg08->dw0034 = dwLoc2C & 4111;
		dwArg08->dw0019 = dwLoc1B;
		dwArg08->dw0038 = dwLoc2C & 4111;
		dwArg08->dw001D = dwLoc17;
		dwArg08->dw002C = 0x00;
		dwArg08->w0021 = wLoc13;
		dwArg08->b0030 = 0x00;
		ecx_119 = (word32) bLoc11;
		dwArg08->b0023 = (byte) ecx_119;
	}
	if ((eax_13 ^ gs->t0014) != 0x00)
	{
		ptr32 ecx_88;
		word32 edx_176;
		__stack_chk_fail(out ecx_88, out edx_176);
		word32 edx_177;
		struct Eq_224 * eax_92 = brk(gs, dwLoc38, out edx_177);
		ecxOut = ecx_88;
		return eax_92;
	}
	else
	{
		ecxOut = ecx_119;
		return eax_23;
	}
}

// 08088020: Register (ptr32 Eq_224) brk(Register (ptr32 Eq_9) gs, Stack Eq_44850 dwArg04, Register out ptr32 edxOut)
// Called from:
//      __sbrk
//      tcgetattr
struct Eq_224 * brk(struct Eq_9 * gs, Eq_44850 dwArg04, ptr32 & edxOut)
{
	__syscall(0x80);
	__curbrk.u0 = 0x2D;
	if (dwArg04 > 0x2D)
	{
		ptr32 edx_19;
		struct Eq_224 * eax_18 = __syscall_error((struct Eq_224 *) ~0x0B, gs, out edx_19);
		edxOut = edx_19;
		return eax_18;
	}
	else
	{
		edxOut = 0x080CE000;
		return null;
	}
}

// 08088060: Register word32 wctrans(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      _i18n_number_rewrite
word32 wctrans(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 eax_23 = gs->ptrFFFFFFD0->t0000;
	Eq_2 ebp_24 = *((word32) eax_23 + 80);
	if (*ebp_24 != 0x00)
	{
		word32 esi_28 = 0x00;
		do
		{
			word32 ecx_139;
			word32 edx_140;
			if (strcmp(dwArg04, ebp_24, out ecx_139, out edx_140) == 0x00)
				return *((word32) eax_23 + (((word32) (*((word32) eax_23 + 0x006C)) + esi_28) * 0x04 + 36));
			++esi_28;
			word32 ecx_141;
			word32 edx_142;
			ebp_24 = (word32) strlen(ebp_24, out ecx_141, out edx_142) + ((word32) ebp_24 + 1);
		} while (*ebp_24 != 0x00);
	}
	return 0x00;
}

// 080880F0: Register uint32 __towctrans(Stack uint32 dwArg04, Stack (ptr32 Eq_72753) dwArg08)
// Called from:
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      _i18n_number_rewrite
uint32 __towctrans(uint32 dwArg04, struct Eq_72753 * dwArg08)
{
	uint32 eax_11 = dwArg04;
	if (dwArg08 != null)
	{
		uint32 ebx_18 = dwArg04 >> dwArg08->b0000;
		if (ebx_18 < dwArg08->dw0004)
		{
			int32 ebx_21 = dwArg08->a0014[ebx_18];
			if (ebx_21 != 0x00)
			{
				int32 ecx_32 = (dwArg08 + ((dwArg08->dw000C & dwArg04 >> dwArg08->b0008) * 0x04) / 20)[ebx_21 / 20];
				if (ecx_32 != 0x00)
					eax_11 = (uint32) ((byte) (dwArg08 + ((dwArg08->dw0010 & dwArg04) * 0x04) / 20)[ecx_32 / 20].b0000 + dwArg04);
			}
		}
	}
	return eax_11;
}

// 08088140: void __readonly_area(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_9843 dwArg04, Stack Eq_2 dwArg08)
void __readonly_area(Eq_2 edx, struct Eq_9 * gs, Eq_9843 dwArg04, Eq_2 dwArg08)
{
	Eq_2175 eax_20 = gs->t0014;
	__new_fopen();
	if (134949356 != 0x00)
	{
		Eq_103454 eax_50 = g_t80B29EC;
		g_t80B29EC = SEQ(SLICE(eax_50, word16, 16), SLICE(eax_50, byte, 8) | 0x80, (byte) eax_50);
		Eq_2 dwLoc50_309 = dwArg08;
		if (((byte) eax_50 & 0x10) == 0x00)
		{
			do
			{
				if (_IO_getdelim(gs, fp - 0x30, fp - 44, 0x0A, 134949356) <= null)
				{
l080882E0:
					break;
				}
				word32 edx_485;
				word32 ecx_484;
				Eq_9843 eax_112 = __strtoul(gs, 0x00, fp - 0x28, 0x10, out ecx_484, out edx_485);
				if (dwLoc28 == null)
					goto l080882E0;
				dwLoc28 = (union Eq_103508 *) ((char *) dwLoc28 + 1);
				if (*dwLoc28 != 0x2D)
					goto l080882E0;
				word32 ecx_486;
				word32 edx_487;
				Eq_9843 eax_137 = __strtoul(gs, (char *) dwLoc28 + 1, fp - 0x24, 0x10, out ecx_486, out edx_487);
				if (dwLoc24 == dwLoc28)
					goto l080882E0;
				dwLoc24 = (union Eq_103508 *) ((char *) dwLoc24 + 1);
				if (*dwLoc24 != 0x20)
					goto l080882E0;
				word32 ecx_154 = dwArg08 + dwArg04;
				if (ecx_154 > eax_112 && dwArg04 < eax_137)
				{
					if (*((char *) dwLoc24 + 1) != 114)
						goto l080882E0;
					dwLoc24 = (union Eq_103508 *) ((char *) dwLoc24 + 3);
					if (*((char *) dwLoc24 + 2) != 0x2D)
						goto l080882E0;
					if (dwArg04 >= eax_112 && ecx_154 <= eax_137)
					{
						dwLoc50_309.u0 = 0x00;
						break;
					}
					if (dwArg04 < eax_112)
					{
						if (ecx_154 <= eax_137)
							dwLoc50_309 = (word32) eax_112.u1 + (dwLoc50_309 - ecx_154);
						else
							dwLoc50_309 = eax_112 + dwLoc50_309 - eax_137;
					}
					else
						dwLoc50_309 = dwLoc50_309 + dwArg04 - eax_137;
					if (dwLoc50_309 != 0x00)
						goto l080881F8;
					goto l080882E0;
				}
l080881F8:
			} while ((g_t80B29EC & 0x10) == 0x00);
		}
		__new_fclose(gs, 134949356);
		word32 ecx_482;
		word32 edx_483;
		free(gs, dwLoc70, 0x00, out ecx_482, out edx_483);
		edx = dwLoc50_309;
		if (dwLoc50_309 != 0x00)
		{
l08088309:
			if ((eax_20 ^ gs->t0014) == 0x00)
				return;
			word32 ecx_488;
			word32 edx_489;
			Eq_2 eax_271 = __stack_chk_fail(out ecx_488, out edx_489);
			word32 ecx_490;
			is_dst(eax_271, edx, out ecx_490);
			return;
		}
	}
	else
	{
		Eq_2 eax_43 = gs->tFFFFFFE0;
		if (eax_43 != 0x02 && eax_43 != 0x0D)
			goto l08088304;
	}
	goto l08088309;
}

// 08088370: Register Eq_2 is_dst(Register Eq_2 eax, Register Eq_2 edx, Register out ptr32 ecxOut)
// Called from:
//      __readonly_area
//      _dl_dst_count
//      _dl_dst_substitute
Eq_2 is_dst(Eq_2 eax, Eq_2 edx, ptr32 & ecxOut)
{
	ptr32 ecx_150;
	word32 ecx_171;
	word32 edx_172;
	Eq_2 eax_24 = strlen(edx, out ecx_171, out edx_172);
	Eq_2 ebx_105 = eax_24;
	if (*eax == 0x7B)
	{
		ebx_105.u0 = 0x00;
		if (strncmp((word32) eax + 1, edx, eax_24, out ecx_150) == 0x00 && *((word32) eax_24 + ((word32) eax + 1)) == 0x7D)
		{
			ecxOut = ecx_150;
			return (word32) eax_24 + 2;
		}
		goto l0808839F;
	}
	if (strncmp(eax, edx, eax_24, out ecx_150) == 0x00)
	{
		word32 edx_91 = CONVERT(Mem79[eax + eax_24:byte], byte, word32);
		byte dl_102 = (byte) edx_91;
		if (((byte) edx_91 & 223) > 0x5A && ((byte) edx_91 > 0x39 && dl_102 != 0x5F))
			goto l0808839F;
	}
	ebx_105.u0 = 0x00;
l0808839F:
	ecxOut = ecx_150;
	return ebx_105;
}

// 08088400: Register byte is_trusted_path_normalize(Register Eq_2 eax, Register int32 edx, Register out (ptr32 Eq_103648) ecxOut)
// Called from:
//      _dl_dst_substitute
byte is_trusted_path_normalize(Eq_2 eax, int32 edx, struct Eq_103648 & ecxOut)
{
	if (edx == 0x00)
	{
		ecxOut = ecx;
		return 0x00;
	}
	ui32 ecx_17 = edx + 0x1D & ~0x0F;
	struct Eq_103658 * esp_28 = fp - 44;
	struct Eq_103658 * edi_30 = fp - 44 - (edx + 0x1D & ~0x0FFF);
	if (fp - 44 != edi_30)
	{
		do
		{
			esp_28 -= 0x1000;
			esp_28->dw0FFC = esp_28->dw0FFC;
		} while (esp_28 != edi_30);
	}
	if ((ecx_17 & 0x0FFF) != 0x00)
	{
		esp_28 -= ecx_17 & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_28 - 0x04)[(ecx_17 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_28 - 0x04)[(ecx_17 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	word32 esi_57 = esp_28 + 0x0F;
	word32 edi_85 = (word32) *eax;
	struct Eq_103648 * ecx_116 = esi_57 & ~0x0F;
l0808846C:
	byte dl_159 = (byte) edi_85;
	if (dl_159 != 0x00)
	{
		do
		{
			byte bl_75 = *((word32) eax + 1);
			if (dl_159 != 0x2F)
			{
				eax = (word32) eax + 1;
l08088463:
				ecx_116->b0000 = dl_159;
				edi_85 = (word32) bl_75;
				++ecx_116;
				goto l0808846C;
			}
			if (bl_75 == 0x2E)
			{
				edi_85 = (word32) *((word32) eax + 2);
				byte bl_87 = (byte) edi_85;
				if (bl_87 != 0x2E)
				{
					if (bl_87 == 0x2F || bl_87 == 0x00)
					{
						eax = (word32) eax + 2;
						goto l0808846C;
					}
				}
				else
				{
					edi_85 = (word32) *((word32) eax + 3);
					byte bl_92 = (byte) edi_85;
					if (bl_92 == 0x2F || bl_92 == 0x00)
					{
						if (ecx_116 > (esi_57 & ~0x0F))
						{
							struct Eq_103648 * edx_106 = ecx_116 - 0x01;
							if (ecx_116->bFFFFFFFF != 0x2F)
							{
								do
								{
									if ((esi_57 & ~0x0F) == edx_106)
									{
										ecx_116 = esi_57 & ~0x0F;
										goto l0808855E;
									}
									--edx_106;
								} while (edx_106->b0000 != 0x2F);
							}
							ecx_116 = edx_106;
						}
l0808855E:
						eax = (word32) eax + 3;
						goto l0808846C;
					}
				}
			}
			eax = (word32) eax + 1;
			if (ecx_116 <= (esi_57 & ~0x0F) || ecx_116->bFFFFFFFF != 0x2F)
				goto l08088463;
			dl_159 = bl_75;
		} while (bl_75 != 0x00);
	}
	struct Eq_103648 * eax_183;
	word32 esi_169 = esp_28 + 0x0F & ~0x0F;
	if (ecx_116 != esi_169)
	{
		eax_183 = ecx_116;
		if (ecx_116->bFFFFFFFF == 0x2F)
		{
l080884B2:
			word32 eax_210;
			ptr32 eax_191 = eax_183 - esi_169;
			if (eax_191 > 0x04 && (esi_169->b0000 == 0x62696C2F && esi_169[4] == 0x2F || eax_191 > 0x08 && (esi_169->b0000 == 0x7273752F && (esi_169[4] == 0x62696C2F && esi_169[8] == 0x2F))))
				eax_210 = 0x01;
			else
				eax_210 = 0x00;
			ecxOut = ecx_116;
			return (byte) eax_210;
		}
	}
	ecx_116->b0000 = 0x2F;
	eax_183 = ecx_116 + 1;
	goto l080884B2;
}

// 08088590: Register Eq_2 _dl_process_pt_note(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 up32) dwArg04, Register out (ptr32 Eq_103839) ebxOut, Register out (ptr32 Eq_103840) ebpOut, Register out (ptr32 Eq_103841) esiOut, Register out (ptr32 Eq_103842) ediOut)
// Called from:
//      _dl_map_object_from_fd.constprop.8
Eq_2 _dl_process_pt_note(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, up32 * dwArg04, struct Eq_103839 & ebxOut, struct Eq_103840 & ebpOut, struct Eq_103841 & esiOut, struct Eq_103842 & ediOut)
{
	Eq_2 ebx_124;
	Eq_2 eax_215;
	Eq_2 eax_125;
	Eq_2 edi_27 = *((word32) edx + 16);
	Eq_2 edi_30 = *((word32) edx + 4);
	struct Eq_103854 * ebp_184 = fp - 4;
	struct Eq_103858 * esp_135 = fp - 0x4C;
	if (edi_27 + edi_30 >u Mem29[dwArg04 + 0x00:word32])
	{
		if (edi_27 <= 0xFFFF)
		{
			struct Eq_103858 * ebx_130 = fp - 0x4C - ((word32) edi_27 + 27 & ~0x0FFF);
			ui32 edx_131 = (word32) edi_27 + 27 & ~0x0F;
			if (fp - 0x4C != ebx_130)
			{
				do
				{
					esp_135 -= 0x1000;
					esp_135->dw0FFC = esp_135->dw0FFC;
				} while (esp_135 != ebx_130);
			}
			if ((edx_131 & 0x0FFF) != 0x00)
			{
				esp_135 -= edx_131 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_135 - 0x04)[(edx_131 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_135 - 0x04)[(edx_131 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			struct Eq_104002 * esp_159 = esp_135 - 0x04;
			esp_159->tFFFFFFFC.u0 = 0x00;
			esp_159->tFFFFFFF8 = edi_30;
			esp_159->tFFFFFFF4 = ecx;
			struct Eq_104015 * esi_189;
			word32 ecx_485;
			word32 edi_486;
			__libc_lseek(gs, esp_159->tFFFFFFF4, esp_159->tFFFFFFF8, esp_159->tFFFFFFFC, out ecx_485, out ebx_124, out ebp_184, out esi_189, out edi_486);
			Eq_2 esp_190 = <invalid>;
			Eq_2 edi_195 = ebp_184->tFFFFFFE4;
			Eq_2 ecx_196 = ebp_184->tFFFFFFE0;
			*((word32) esp_190 + 8) = edi_195;
			*((word32) esp_190 + 4) = ebx_124;
			*esp_190 = ecx_196;
			esp_135 = (word32) esp_190 + 16;
			word32 ecx_487;
			if (edi_195 == __read_nocancel(gs, *esp_190, *((word32) esp_190 + 4), *((word32) esp_190 + 8), out ecx_487))
			{
				if ((ebp_184->ptrFFFFFFDC->b019A & 0x0E) == 0x00 && esi_189->dw001C == 0x04)
				{
					eax_125 = ebx_124;
					if (ebp_184->tFFFFFFE4 > 0x0C)
					{
						ebp_184->tFFFFFFD0.u0 = 0x00;
						goto l080885F4;
					}
				}
				goto l080886DE;
			}
		}
		else
		{
			struct Eq_103907 * ebp_47;
			Eq_2 edi_50;
			word32 ecx_478;
			word32 edx_479;
			word32 esi_481;
			word32 ebx_480;
			Eq_2 eax_46 = __libc_malloc(gs, dwLoc60, edi_27, out ecx_478, out edx_479, out ebx_480, out ebp_47, out esi_481, out edi_50);
			Eq_2 ecx_57 = ebp_47->tFFFFFFE0;
			ebp_47->tFFFFFFD0 = eax_46;
			Eq_2 ebx_70;
			struct Eq_103931 * esi_74;
			word32 edi_483;
			word32 ecx_482;
			__libc_lseek(gs, ecx_57, edi_50, 0x00, out ecx_482, out ebx_70, out ebp_184, out esi_74, out edi_483);
			Eq_2 esp_75 = <invalid>;
			Eq_2 edi_80 = ebp_184->tFFFFFFE4;
			Eq_2 ecx_81 = ebp_184->tFFFFFFE0;
			*((word32) esp_75 + 8) = edi_80;
			*((word32) esp_75 + 4) = ebx_70;
			*esp_75 = ecx_81;
			esp_135 = (word32) esp_75 + 16;
			word32 ecx_484;
			if (__read_nocancel(gs, *esp_75, *((word32) esp_75 + 4), *((word32) esp_75 + 8), out ecx_484) == edi_80)
			{
				if ((ebp_184->ptrFFFFFFDC->b019A & 0x0E) != 0x00 || esi_74->dw001C != 0x04)
					goto l080886C8;
				ebx_124 = ebp_184->tFFFFFFD0;
				eax_125 = ebx_124;
l080885F4:
				ebp_184->dwFFFFFFCC = 0x00;
				ebp_184->dwFFFFFFD4 = 0x0C - eax_125;
				up32 edi_239 = 0x00;
				do
				{
					Eq_103897 esi_257;
					Eq_2 eax_246 = *ebx_124;
					ebp_184->tFFFFFFE0 = eax_246;
					if (eax_246 == 0x04 && (*((word32) ebx_124 + 8) == 0x05 && *((word32) ebx_124 + 0x0C) == 5590599))
					{
						struct Eq_104093 * esi_258 = ebp_184->ptrFFFFFFDC;
						word32 eax_259 = (word32) esi_258->b019A;
						if (((byte) eax_259 & 0x0E) != 0x00)
							goto l080886C8;
						esi_258->b019A = (byte) eax_259 & ~0x0E | 0x02;
						Eq_103897 esi_268 = *((word32) ebx_124 + 4);
						if (esi_268 <= 0x07 || (esi_268 & 0x03) != 0x00)
							goto l080886C8;
						ebp_184->tFFFFFFC4 = esi_268;
						struct Eq_104134 * eax_274 = (word32) ebx_124 + 16;
						ebp_184->tFFFFFFC8 = ebx_124;
						word32 ecx_276 = eax_274 + esi_268;
						do
						{
							up32 edx_281 = eax_274->dw0000;
							int32 ecx_282 = eax_274->dw0004;
							if (edx_281 < edi_239)
								goto l080886C8;
							ptr32 ebx_286 = eax_274 + 1;
							if (ecx_276 < ebx_286 + ecx_282)
								goto l080886C8;
							if (edx_281 == 0xC0000002)
							{
								ebx_124 = ebp_184->tFFFFFFC8;
								esi_257 = ebp_184->tFFFFFFC4;
								if (ecx_282 != 0x04)
									goto l080886C8;
								ebp_184->dwFFFFFFCC = (ui32) eax_274[1];
								edi_239 = 0xC0000002;
								goto l08088613;
							}
							if (edx_281 > 0xC0000002)
								goto l080886C8;
							eax_274 = ebx_286 + (ecx_282 + 0x03 & ~0x03);
							edi_239 = edx_281;
						} while (ecx_276 - eax_274 > 0x07);
						ebx_124 = ebp_184->tFFFFFFC8;
						esi_257 = ebp_184->tFFFFFFC4;
					}
					else
						esi_257 = *((word32) ebx_124 + 4);
l08088613:
					ebx_124 = (word32) ebx_124 + ((word32) esi_257 + ((word32) ebp_184->tFFFFFFE0 + 0x0F | 0x03) & ~0x03);
				} while (ebp_184->tFFFFFFE4 > (word32) ebx_124 + ebp_184->dwFFFFFFD4);
				ui32 ecx_327 = ebp_184->dwFFFFFFCC;
				if ((ecx_327 & 0x01) != 0x00)
				{
					struct Eq_104093 * esi_334 = ebp_184->ptrFFFFFFDC;
					esi_334->b019A |= 0x04;
				}
				if ((ecx_327 & 0x02) != 0x00)
				{
					struct Eq_104093 * eax_345 = ebp_184->ptrFFFFFFDC;
					eax_345->b019A |= 0x08;
				}
l080886C8:
				Eq_2 eax_353 = ebp_184->tFFFFFFD0;
				if (eax_353 != 0x00)
				{
					struct Eq_104224 * esp_364 = esp_135 - 0x0C;
					esp_364->tFFFFFFFC = eax_353;
					word32 ecx_488;
					word32 edx_489;
					free(gs, esp_364->tFFFFFFF8, esp_364->tFFFFFFFC, out ecx_488, out edx_489);
				}
				goto l080886DE;
			}
			Eq_2 eax_100 = ebp_184->tFFFFFFD0;
			if (eax_100 != 0x00)
			{
				*esp_75 = eax_100;
				word32 ecx_490;
				word32 edx_491;
				free(gs, *((word32) esp_75 - 4), *esp_75, out ecx_490, out edx_491);
			}
		}
		eax_215.u0 = ~0x00;
l080886E0:
		struct Eq_104181 * esp_391 = ebp_184 - 0x0C;
		struct Eq_103841 * esi_397 = esp_391->ptr0004;
		struct Eq_103842 * edi_399 = esp_391->ptr0008;
		struct Eq_103840 * ebp_401 = esp_391->ptr000C;
		ebxOut = esp_391->ptr0000;
		ebpOut = ebp_401;
		esiOut = esi_397;
		ediOut = edi_399;
		return eax_215;
	}
	else
	{
		if ((*((word32) eax + 410) & 0x0E) != 0x00 || *((word32) edx + 28) != 0x04)
			goto l080886DE;
		ebx_124 = dwArg04 + 0x04 + edi_30;
		eax_125 = ebx_124;
		if (edi_27 > 0x0C)
			goto l080885F4;
l080886DE:
		eax_215.u0 = 0x00;
		goto l080886E0;
	}
}

// 08088890: Register word32 lose(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      open_verify.constprop.7
//      _dl_map_object_from_fd.constprop.8
word32 lose(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (edx != ~0x00)
	{
		word32 edx_168;
		__close_nocancel(gs, edx, out edx_168);
	}
	if (dwArg08 != 0x00)
	{
		Eq_2 eax_45 = *((word32) dwArg08 + 428);
		if (eax_45 != ~0x00)
		{
			word32 ecx_173;
			word32 edx_174;
			free(gs, dwLoc30, eax_45, out ecx_173, out edx_174);
		}
	}
	word32 edx_170;
	word32 ecx_169;
	free(gs, dwLoc30, dwArg08, out ecx_169, out edx_170);
	word32 ecx_171;
	word32 edx_172;
	free(gs, dwLoc30, dwArg04, out ecx_171, out edx_172);
	if (dwArg10 != 0x00)
	{
		*((word32) dwArg10 + 0x0C) = 0x00;
		_dl_debug_state();
	}
	word32 ebx_176;
	word32 ecx_175;
	word32 edi_177;
	word32 ebp_115;
	Eq_2 edx_119;
	Eq_2 eax_114 = _dl_signal_error(gs, eax, dwArg0C, out ecx_175, out edx_119, out ebx_176, out ebp_115, out edi_177);
	word32 ebp_178;
	word32 edi_179;
	add_name_to_object.isra.4(eax_114, edx_119, gs, out ebp_178, out edi_179);
	return ebp_115;
}

// 08088920: Register word32 add_name_to_object.isra.4(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_104422) ebpOut, Register out (ptr32 Eq_104423) ediOut)
// Called from:
//      lose
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
word32 add_name_to_object.isra.4(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, struct Eq_104422 & ebpOut, struct Eq_104423 & ediOut)
{
	struct Eq_104423 * edi_147;
	struct Eq_104422 * ebp_144;
	ptr32 esp_154;
	word32 ebx_145;
	if (eax == 0x00)
	{
		esp_154 = fp - 44;
		word32 ecx_273;
		word32 edx_274;
		word32 ecx_275;
		word32 edx_276;
		word32 esi_277;
		if (__libc_malloc(gs, dwLoc40, (word32) strlen(edx, out ecx_273, out edx_274) + 0x0D, out ecx_275, out edx_276, out ebx_145, out ebp_144, out esi_277, out edi_147) != 0x00)
			goto l080889E9;
	}
	else
	{
		do
		{
			word32 ecx_271;
			word32 edx_272;
			if (strcmp(edx, *eax, out ecx_271, out edx_272) == 0x00)
			{
				ebpOut = ebp;
				ediOut = edi;
				return ebx;
			}
			eax = *((word32) eax + 4);
		} while (eax != 0x00);
		word32 ecx_281;
		word32 edx_282;
		Eq_2 eax_56 = strlen(edx, out ecx_281, out edx_282);
		Eq_2 edi_74;
		struct Eq_104528 * esi_76;
		word32 ecx_283;
		word32 edx_284;
		word32 ebp_285;
		Eq_2 eax_70 = __libc_malloc(gs, dwLoc40, (word32) eax_56 + 0x0D, out ecx_283, out edx_284, out ebx_145, out ebp_285, out esi_76, out edi_74);
		if (eax_70 != 0x00)
		{
			word32 ecx_292;
			word32 edx_293;
			Eq_2 eax_96 = memcpy((word32) eax_70 + 0x0C, edi_74, (word32) eax_56 + 1, out ecx_292, out edx_293);
			*((word32) eax_70 + 4) = 0x00;
			*eax_70 = eax_96;
			*((word32) eax_70 + 8) = 0x00;
			esi_76->t0004 = eax_70;
			ebpOut = ebp;
			ediOut = edi;
			return ebx;
		}
	}
	word32 ecx_279;
	word32 edx_280;
	_dl_signal_error(gs, 0x0C, ebx_145 + ~0x0001B603, out ecx_279, out edx_280, out ebx_145, out ebp_144, out edi_147);
	esp_154 = fp - 0x3C;
l080889E9:
	struct Eq_104477 * esp_185 = esp_154 - 4;
	esp_185->dw0000 = ebx_145 + ~0x0001AED7;
	esp_185->dwFFFFFFFC = 0x01AF;
	esp_185->dwFFFFFFF8 = ebx_145 + 4294855192;
	esp_185->dwFFFFFFF4 = ebx_145 + ~0x0001B5DD;
	struct Eq_104499 * edx_196;
	word32 ecx_278;
	Eq_2 eax_195 = __assert_fail(out ecx_278, out edx_196);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	word32 ebx_288;
	word32 ebp_289;
	word32 esi_290;
	word32 edi_291;
	open_verify.constprop.7(eax_195, ecx, edx_196, gs, stackArg4, out ebx_288, out ebp_289, out esi_290, out edi_291);
	ebpOut = ebp_144;
	ediOut = edi_147;
	return ebx_145;
}

// 08088A10: Register Eq_2 open_verify.constprop.7(Register Eq_2 eax, Register ui32 ecx, Register (ptr32 Eq_104499) edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_104557) ebxOut, Register out (ptr32 Eq_104558) ebpOut, Register out ptr32 esiOut, Register out (ptr32 Eq_104560) ediOut)
// Called from:
//      add_name_to_object.isra.4
//      open_path
//      _dl_map_object
Eq_2 open_verify.constprop.7(Eq_2 eax, ui32 ecx, struct Eq_104499 * edx, struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_104557 & ebxOut, struct Eq_104558 & ebpOut, ptr32 & esiOut, struct Eq_104560 & ediOut)
{
	struct Eq_104592 * ebp_277 = fp - 4;
	word32 ecx_1139;
	word32 edx_1140;
	Eq_2 eax_36 = __open64_nocancel(gs, eax, 0x00080000, dwLoc64, out ecx_1139, out edx_1140);
	if (eax_36 == ~0x00)
	{
l08088B56:
		struct Eq_104607 * esp_880 = ebp_277 - 0x0C;
		Eq_2 eax_879 = ebp_277->dwFFFFFFD4;
		ptr32 esi_883 = esp_880->ptr0004;
		struct Eq_104560 * edi_885 = esp_880->ptr0008;
		struct Eq_104558 * ebp_887 = esp_880->ptr000C;
		ebxOut = esp_880->ptr0000;
		ebpOut = ebp_887;
		esiOut = esi_883;
		ediOut = edi_885;
		return eax_879;
	}
	gs->tFFFFFFE0.u0 = 0x00;
	edx->t0000.u0 = 0x00;
	Eq_104632 eax_55 = 0x00;
	do
	{
		word32 ecx_1141;
		word32 eax_76 = __read_nocancel(gs, eax_36, eax_55 + (edx + 0x04), 0x0200 - eax_55, out ecx_1141);
		struct Eq_104660 * esp_225 = fp - 0x5C;
		if (eax_76 <= 0x00)
		{
			eax_55 = edx->t0000;
			break;
		}
		eax_55 = eax_76 + Mem74[edx + 0x00:word32];
		edx->t0000 = eax_55;
	} while (eax_55 <= 0x33);
	Eq_104665 esi_104;
	Eq_2 edi_100;
	if (eax_55 <= 0x33)
	{
		edi_100 = gs->tFFFFFFE0;
		esi_104.u1 = 134949424;
		if (edi_100 != 0x00)
			esi_104.u1 = 134949439;
		goto l08088DDA;
	}
	word32 edx_110 = edx->dw0004;
	if (edx_110 != g_dw80B3184)
	{
		if (edx_110 != g_dw80B3178)
			goto l08088AFF;
	}
	else
	{
		if (edx->t0008 == g_t80B3188)
			goto l08088AD8;
		if (edx_110 != g_dw80B3178)
		{
l08088AFF:
			if (edx->dw0004 != 0x464C457F)
			{
				edi_100.u0 = 0x00;
				esi_104.u1 = 0x080B2AB4;
				goto l08088DDA;
			}
			if (edx->t0008 == 0x01)
			{
				if (edx->b0009 != 0x01)
				{
					edi_100.u0 = 0x00;
					esi_104.u1 = 0x080B2C90;
				}
				else if (edx->b000A != 0x01)
				{
					edi_100.u0 = 0x00;
					esi_104.u1 = 0x080B2C5C;
				}
				else
				{
					byte dl_609 = edx->b000B;
					int8 al_612 = (int8) (dl_609 != 0x03);
					if (dl_609 != 0x00 && al_612 != 0x00)
					{
						edi_100.u0 = 0x00;
						esi_104.u1 = 134949461;
					}
					else
					{
						cu8 dl_623 = edx->b000C;
						if (dl_623 != 0x00 && (dl_623 > 0x03 || al_612 != 0x00))
						{
							edi_100.u0 = 0x00;
							esi_104.u1 = 134949485;
						}
						else
						{
							word32 edx_1162;
							word32 ecx_1161;
							Eq_2 eax_654 = memcmp(&edx->dw000D, 0x080B318D, 0x07, out ecx_1161, out edx_1162);
							esi_104.u1 = 134949541;
							esp_225 = fp - 0x5C;
							edi_100 = eax_654;
							if (eax_654 != 0x00)
							{
								edi_100.u0 = 0x00;
								esi_104.u1 = 0x080B2A8A;
							}
						}
					}
				}
				goto l08088DDA;
			}
			*dwArg04 = 0x01;
l08088B26:
			struct Eq_105282 * esp_829 = esp_225 - 0x0C;
			esp_829->tFFFFFFFC = ebp_277->dwFFFFFFD4;
			word32 edx_1154;
			__close_nocancel(gs, esp_829->tFFFFFFFC, out edx_1154);
			(gs->*ebp_277->ptrFFFFFFB8).u0 = 0x02;
			ebp_277->dwFFFFFFD4 = ~0x00;
			esp_225 = (struct Eq_104660 *) ((char *) &esp_829->tFFFFFFFC + 16);
l08088B45:
			struct Eq_104813 * esp_856 = esp_225 - 0x0C;
			esp_856->tFFFFFFFC = ebp_277->dwFFFFFFBC;
			word32 edx_1143;
			word32 ecx_1142;
			free(gs, esp_856->tFFFFFFF8, esp_856->tFFFFFFFC, out ecx_1142, out edx_1143);
			goto l08088B56;
		}
	}
	if (edx->t0008 != g_t80B317C)
		goto l08088AFF;
l08088AD8:
	cu8 dl_138 = edx->b000C;
	if ((dl_138 == 0x00 || edx->b000B == 0x03 && dl_138 <= 0x03) && (edx->dw000D == g_dw80B318D && (edx->w0011 == g_w80B3191 && edx->b0013 == g_b80B3193)))
	{
		edi_100.u0 = 0x00;
		if (edx->dw0018 != 0x01)
		{
			esi_104.u1 = 0x080B2CBC;
			goto l08088DDA;
		}
		if (edx->w0016 == 0x03)
		{
			word32 edx_175 = (word32) edx->w0014;
			word16 dx_182 = (word16) edx_175;
			if ((word16) edx_175 <= 0x03 && (word16) edx_175 >= 0x02)
			{
				if (dx_182 != 0x02 || (ecx & 0x20000000) != 0x00)
				{
					if (edx->w002E == 0x20)
					{
						ui32 edx_200 = (word32) edx->w0030;
						Eq_2 ecx_201 = edx->t0020;
						ui32 esi_203 = edx_200 << 0x05;
						if ((word32) ecx_201 + (edx_200 << 0x05) <= eax_55)
						{
l08088C1A:
							struct Eq_104807 * edi_316 = ebp_277->dwFFFFFFE0;
							ebp_277->dwFFFFFFBC = 0x00;
							if (edi_316 < edi_316 + esi_203 / 4)
							{
								do
								{
									if (edi_316->dw0000 == 0x04)
									{
										Eq_2 ecx_326 = edi_316[4];
										if (ecx_326 > 0x1F)
										{
											uint32 eax_329 = edi_316[7];
											ebp_277->dwFFFFFFD8 = eax_329;
											if (eax_329 > 0x03 && (eax_329 - 0x04 & ~0x04) == 0x00)
											{
												Eq_2 ebx_345;
												Eq_2 esi_339 = edi_316[1];
												if (ecx_326 + esi_339 >u Mem331[Mem331[ebp_277 + -36:word32] + 0x00:word32])
												{
													if (ecx_326 <= 0xFFFF)
													{
														struct Eq_104660 * ebx_383 = esp_225 - ((word32) ecx_326 + 27 & ~0x0FFF);
														ui32 edx_384 = (word32) ecx_326 + 27 & ~0x0F;
														while (esp_225 != ebx_383)
														{
															esp_225 -= 0x1000;
															esp_225[0x03FF] = esp_225[0x03FF];
														}
														if ((edx_384 & 0x0FFF) != 0x00)
														{
															esp_225 -= edx_384 & 0x0FFF;
															(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[(edx_384 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[(edx_384 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
														}
													}
													else
													{
														ebp_277->ptrFFFFFFD0 = (ptr32) ecx_326;
														struct Eq_104977 * esp_349 = esp_225 - 0x08;
														esp_349->tFFFFFFFC = ecx_326;
														esp_349->tFFFFFFF8 = ebp_277->dwFFFFFFBC;
														Eq_2 esp_363 = <invalid>;
														word32 edi_1149;
														word32 edx_1148;
														Eq_2 eax_364 = __realloc(gs, esp_349->tFFFFFFF4, esp_349->tFFFFFFF8, esp_349->tFFFFFFFC, out edx_1148, out ebp_277, out esi_339, out edi_1149);
														esp_225 = (word32) esp_363 + 16;
														if (eax_364 == 0x00)
															goto l08088FE5;
														ebp_277->dwFFFFFFBC = (word32) eax_364;
														ecx_326 = ebp_277->ptrFFFFFFD0;
													}
													ebp_277->ptrFFFFFFD0 = (ptr32) ecx_326;
													struct Eq_105349 * esp_416 = esp_225 - 0x04;
													esp_416->tFFFFFFFC.u0 = 0x00;
													esp_416->tFFFFFFF8 = esi_339;
													esp_416->tFFFFFFF4 = ebp_277->dwFFFFFFD4;
													Eq_2 esi_448;
													word32 ecx_1155;
													__libc_lseek(gs, esp_416->tFFFFFFF4, esp_416->tFFFFFFF8, esp_416->tFFFFFFFC, out ecx_1155, out ebx_345, out ebp_277, out esi_448, out edi_316);
													Eq_2 esp_449 = <invalid>;
													*((word32) esp_449 + 8) = ebp_277->ptrFFFFFFD0;
													*((word32) esp_449 + 4) = ebx_345;
													*esp_449 = esi_448;
													word32 ecx_1156;
													Eq_2 eax_463 = __read_nocancel(gs, *esp_449, *((word32) esp_449 + 4), *((word32) esp_449 + 8), out ecx_1156);
													ecx_326 = ebp_277->ptrFFFFFFD0;
													esp_225 = (word32) esp_449 + 16;
													if (ecx_326 != eax_463)
													{
														*esp_449 = ebp_277->dwFFFFFFBC;
														word32 ecx_1152;
														word32 edx_1153;
														free(gs, *((word32) esp_449 - 4), *esp_449, out ecx_1152, out edx_1153);
														esp_225 = (word32) esp_449 + 16;
														goto l08088FE5;
													}
												}
												else
													ebx_345 = (word32) esi_339 + ebp_277->dwFFFFFFC8;
												word32 eax_498 = ebp_277->dwFFFFFFD8;
												ebp_277->dwFFFFFFB4 = edi_316;
												ebp_277->ptrFFFFFFD0 = ~0x0001AE97;
												ebp_277->dwFFFFFFCC = eax_498 + 11;
												ui32 edx_506 = -eax_498;
												while (*ebx_345 != (ebp_277->ptrFFFFFFE4)[ebp_277->ptrFFFFFFD0] || (*((word32) ebx_345 + 4) != (ebp_277->ptrFFFFFFE4)->dwFFFE516C || (*((word32) ebx_345 + 8) != (ebp_277->ptrFFFFFFE4)->dwFFFE5170 || *((word32) ebx_345 + 0x0C) != (ebp_277->ptrFFFFFFE4)->dwFFFE5174)))
												{
													Eq_105212 eax_544 = ((word32) *ebx_345 + ebp_277->dwFFFFFFCC & edx_506) + ((word32) (*((word32) ebx_345 + 4)) + (ebp_277->dwFFFFFFD8 - 0x01)) & edx_506;
													if (eax_544 > ecx_326 - 0x20)
													{
														edi_316 = ebp_277->dwFFFFFFB4;
														goto l08088EA3;
													}
													ecx_326 -= eax_544;
													ebx_345 += eax_544;
												}
												edi_316 = ebp_277->dwFFFFFFB4;
												if (ecx_326 != 0x00)
												{
													if (*((word32) ebx_345 + 16) != 0x00)
														goto l08088B26;
													uint32 edx_579 = _dl_osversion;
													if ((((word32) *((word32) ebx_345 + 20) << 0x08) + (word32) (*((word32) ebx_345 + 24)) << 0x08) + (word32) (*((word32) ebx_345 + 28)) > edx_579 && edx_579 != 0x00)
														goto l08088B26;
													break;
												}
l08088EA3:
												edx_200 = (word32) ebp_277->ptrFFFFFFDC->w0030;
											}
										}
									}
									edi_316 += 8;
								} while (edi_316 < (edx_200 << 0x05) + ebp_277->dwFFFFFFE0);
							}
							goto l08088B45;
						}
						ui32 eax_211 = (edx_200 << 0x05) + 0x1B;
						struct Eq_104660 * ebx_220 = fp - 0x5C - (eax_211 & 0x003FF000);
						if (fp - 0x5C != ebx_220)
						{
							do
							{
								esp_225 -= 0x1000;
								esp_225[0x03FF] = esp_225[0x03FF];
							} while (esp_225 != ebx_220);
						}
						int32 edx_236 = eax_211 & 0x003FFFF0 & 0x0FFF;
						if (edx_236 != 0x00)
						{
							esp_225 -= edx_236;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[edx_236 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[edx_236 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						struct Eq_105064 * esp_254 = esp_225 - 0x04;
						esp_254->tFFFFFFFC.u0 = 0x00;
						esp_254->tFFFFFFF8 = ecx_201;
						esp_254->tFFFFFFF4 = eax_36;
						word32 ecx_1150;
						Eq_2 ebx_278;
						Eq_2 edi_280;
						Eq_2 esi_282;
						__libc_lseek(gs, esp_254->tFFFFFFF4, esp_254->tFFFFFFF8, esp_254->tFFFFFFFC, out ecx_1150, out ebx_278, out ebp_277, out esi_282, out edi_280);
						Eq_2 esp_283 = <invalid>;
						*((word32) esp_283 + 8) = esi_282;
						*((word32) esp_283 + 4) = ebx_278;
						*esp_283 = edi_280;
						esp_225 = (word32) esp_283 + 16;
						word32 ecx_1151;
						if (__read_nocancel(gs, *esp_283, *((word32) esp_283 + 4), *((word32) esp_283 + 8), out ecx_1151) == esi_282)
						{
							edx_200 = (word32) ebp_277->ptrFFFFFFDC->w0030;
							esi_203 = edx_200 << 0x05;
							goto l08088C1A;
						}
l08088FE5:
						edi_100 = gs->*ebp_277->ptrFFFFFFB8;
						esi_104 = (char *) ebp_277->ptrFFFFFFE4 - 0x0001B5C1;
					}
					else
						esi_104.u1 = 0x080B2CE8;
				}
				else
					esi_104.u1 = 134949904;
			}
			else
				esi_104.u1 = 134949940;
l08088DDA:
			if (ebp_277->bFFFFFFC0 == 0x00)
			{
l08088DE0:
				struct Eq_104879 * esp_698 = esp_225 - 0x0C;
				Eq_2 edx_703 = ebp_277->dwFFFFFFD4;
				esp_698->dwFFFFFFFC = 0x00;
				esp_698->dwFFFFFFF8 = 0x00;
				esp_698->tFFFFFFF4 = esi_104;
				esp_698->dwFFFFFFF0 = 0x00;
				esp_698->dwFFFFFFEC = 0x00;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				lose(edi_100, edx_703, gs, stackArg4, dwArg04, dwArg08, stackArg16);
				esp_225 = esp_698 - 20;
			}
			struct Eq_104846 * esp_729 = esp_225 - 0x0C;
			esp_729->tFFFFFFFC = ebp_277->dwFFFFFFC4;
			word32 ecx_1144;
			word32 edx_1145;
			Eq_2 eax_736 = strlen(esp_729->tFFFFFFFC, out ecx_1144, out edx_1145);
			struct Eq_104865 * esp_743 = (char *) &esp_729->tFFFFFFFC + 16;
			struct Eq_104865 * ebx_749 = (char *) &esp_729->tFFFFFFFC + 16 - ((word32) eax_736 + 28 & ~0x0FFF);
			ui32 ecx_750 = (word32) eax_736 + 28 & ~0x0F;
			while (esp_743 != ebx_749)
			{
				esp_743 -= 0x1000;
				esp_743->dw0FFC = esp_743->dw0FFC;
			}
			if ((ecx_750 & 0x0FFF) != 0x00)
			{
				esp_743 -= ecx_750 & 0x0FFF;
				Mem767[esp_743 - 0x04 + (ecx_750 & 0x0FFF):word32] = Mem765[esp_743 - 0x04 + (ecx_750 & 0x0FFF):word32];
			}
			struct Eq_105439 * esp_772 = esp_743 - 0x04;
			esp_772->tFFFFFFFC = (word32) eax_736 + 1;
			esp_772->tFFFFFFF8 = ebp_277->dwFFFFFFC4;
			Mem788[esp_772 + -0x0C:word32] = esp_743 + 0x0F & ~0x0F;
			word32 ecx_1157;
			word32 edx_1158;
			Eq_2 eax_789 = memcpy(esp_772->tFFFFFFF4, esp_772->tFFFFFFF8, esp_772->tFFFFFFFC, out ecx_1157, out edx_1158);
			esp_772->tFFFFFFF4 = ebp_277->dwFFFFFFC4;
			ebp_277->dwFFFFFFE0 = (word32) eax_789;
			word32 edx_1160;
			word32 ecx_1159;
			free(gs, esp_772->tFFFFFFF0, esp_772->tFFFFFFF4, out ecx_1159, out edx_1160);
			ebp_277->dwFFFFFFC4 = ebp_277->dwFFFFFFE0;
			esp_225 = (struct Eq_104660 *) ((char *) &esp_772->tFFFFFFFC + 8);
			goto l08088DE0;
		}
		goto l08088B26;
	}
	goto l08088AFF;
}

// subject_text_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080890B0: Register word32 open_path(Register word32 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out (ptr32 Eq_105557) ebxOut, Register out (ptr32 Eq_105558) ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      _dl_map_object
word32 open_path(word32 edx, struct Eq_9 * gs, word32 * dwArg04, struct Eq_105557 & ebxOut, struct Eq_105558 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	struct Eq_105561 * ebp_444 = fp - 4;
	struct Eq_105565 * ebx_115 = &g_t80CE000;
	struct Eq_105567 * esp_111 = fp - 0xCC;
	struct Eq_105622 ** eax_23 = *dwArg04;
	if (eax_23 != null)
	{
		ui32 eax_33 = edx + 0x1B + (g_dw80CE044 + max_dirnamelen);
		struct Eq_105567 * ecx_39 = fp - 0xCC - (eax_33 & ~0x0FFF);
		if (fp - 0xCC != ecx_39)
		{
			do
			{
				esp_111 -= 0x1000;
				esp_111->dw0FFC = esp_111->dw0FFC;
			} while (esp_111 != ecx_39);
		}
		if ((eax_33 & ~0x0F & 0x0FFF) != 0x00)
		{
			esp_111 -= eax_33 & ~0x0F & 0x0FFF;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(eax_33 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(eax_33 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_105622 * edi_105 = *eax_23;
		do
		{
			Eq_105779 eax_99 = *ebp_444->ptrFFFFFF74;
			ebp_444->dwFFFFFF7C = eax_99 & 0x01;
			if ((eax_99 & 0x01) != 0x00)
			{
				word32 eax_106 = edi_105->dw0004;
				ebp_444->dwFFFFFF54 = eax_106;
				if (eax_106 != ebp_444->ptrFFFFFF4C)
				{
					word32 eax_110 = edi_105[1];
					ebp_444->dwFFFFFF48 = esp_111;
					ebp_444->ptrFFFFFF4C = eax_110;
					word32 eax_117 = ebx_115->dwFFFFFFBC + ebx_115->dw1A44;
					struct Eq_105567 * ecx_121 = esp_111 - (eax_117 + 0x0F & ~0x0FFF);
					ui32 edx_122 = eax_117 + 0x0F & ~0x0F;
					while (esp_111 != ecx_121)
					{
						esp_111 -= 0x1000;
						esp_111->dw0FFC = esp_111->dw0FFC;
					}
					if ((edx_122 & 0x0FFF) != 0x00)
					{
						esp_111 -= edx_122 & 0x0FFF;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(edx_122 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(edx_122 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					ebp_444->ptrFFFFFF78 = esp_111;
					esp_111->dwFFFFFFF0 = (char *) ebx_115 - 111910;
					word32 edx_1054;
					word32 ecx_1053;
					_dl_debug_printf(out ecx_1053, out edx_1054);
					struct Eq_106333 * eax_171 = *ebp_444->ptrFFFFFF60;
					if (eax_171 != null && ebp_444->dwFFFFFF54 == eax_171->dw0004)
					{
						ebp_444->dwFFFFFF44 = edi_105;
						struct Eq_106369 ** esi_183 = ebp_444->ptrFFFFFF60;
						ebp_444->dwFFFFFF5C = (char *) ebx_115 - 111929;
						struct Eq_106369 ** esi_185 = esi_183;
						do
						{
							struct Eq_106413 * esp_187 = esp_111 - 0x04;
							esp_187->tFFFFFFFC = eax_171->t0010;
							esp_187->tFFFFFFF8 = eax_171->t000C;
							esp_187->tFFFFFFF4 = ebp_444->ptrFFFFFF78;
							word32 edx_1055;
							ebp_444->dwFFFFFF70 = (word32) __mempcpy(esp_187->tFFFFFFF4, esp_187->tFFFFFFF8, esp_187->tFFFFFFFC, out edx_1055);
							if (ebx_115->dwFFFFFFC0 != 0x00)
							{
								ebp_444->ptrFFFFFF68 = (word32 Eq_9::*) ((char *) ebx_115 - 84938);
								uint32 edi_217 = 0x00;
								do
								{
									if (*((char *) *esi_185 + (edi_217 * 0x04 + 20)) != 0x01)
									{
										struct Eq_106461 * eax_232 = ebx_115->dwFFFFFFC4 + edi_217 * 0x08;
										struct Eq_106468 * esp_230 = esp_111 - 0x04;
										esp_230->tFFFFFFFC = eax_232->t0004;
										esp_230->tFFFFFFF8 = eax_232->t0000;
										esp_230->tFFFFFFF4 = ebp_444->dwFFFFFF70;
										word32 edx_1056;
										Eq_2 eax_243 = __mempcpy(esp_230->tFFFFFFF4, esp_230->tFFFFFFF8, esp_230->tFFFFFFFC, out edx_1056);
										Eq_2 edx_251 = ebp_444->ptrFFFFFF78;
										if (edx_251 == eax_243)
											*eax_243 = 0x00;
										else if (eax_243 != (word32) edx_251 + 1 || *edx_251 != 0x2F)
											*((word32) eax_243 - 1) = 0x00;
										else
											*eax_243 = 0x00;
										Eq_2 eax_270 = ebp_444->dwFFFFFF5C;
										if (ebp_444->dwFFFFFF7C != 0x00)
											eax_270 = ebp_444->ptrFFFFFF68;
										esp_230->tFFFFFFF8 = ebp_444->ptrFFFFFF78;
										esp_230->tFFFFFFF4 = eax_270;
										word32 edx_1057;
										_dl_debug_printf_c(out edx_1057);
										ebp_444->dwFFFFFF7C = 0x00;
									}
									++edi_217;
								} while (edi_217 < ebx_115->dwFFFFFFC0);
							}
							esi_185 = (struct Eq_106369 **) ((char *) esi_185 + 4);
							eax_171 = (struct Eq_106333 *) *esi_185;
						} while (eax_171 != null && ebp_444->dwFFFFFF54 == eax_171->dw0004);
						edi_105 = ebp_444->dwFFFFFF44;
					}
					if (ebp_444->ptrFFFFFF4C != 0x00)
					{
						if (*ebp_444->ptrFFFFFF4C == 0x00)
						{
							Eq_2 edx_365 = **(union Eq_2 **) 135060900;
							Eq_2 eax_366 = (char *) ebx_115 - 111925;
							if (edx_365 != 0x00)
								eax_366 = edx_365;
							ebp_444->ptrFFFFFF4C = (byte *) eax_366;
						}
						struct Eq_106585 * esp_376 = esp_111 - 0x04;
						esp_376->ptrFFFFFFFC = ebp_444->ptrFFFFFF4C;
						esp_376->dwFFFFFFF8 = ebp_444->dwFFFFFF54;
						esp_376->ptrFFFFFFF4 = (char *) ebx_115 - 111896;
						word32 edx_1059;
						_dl_debug_printf_c(out edx_1059);
					}
					else
					{
						struct Eq_106559 * esp_339 = esp_111 - 0x08;
						esp_339->dwFFFFFFFC = ebp_444->dwFFFFFF54;
						esp_339->ptrFFFFFFF8 = (char *) ebx_115 - 111875;
						word32 edx_1058;
						_dl_debug_printf_c(out edx_1058);
					}
					esp_111 = ebp_444->dwFFFFFF48;
					ebp_444->ptrFFFFFF4C = ebp_444->dwFFFFFF54;
				}
			}
			struct Eq_105637 * esp_407 = esp_111 - 0x04;
			esp_407->tFFFFFFFC = edi_105[2];
			esp_407->tFFFFFFF8 = edi_105->dw000C;
			esp_407->tFFFFFFF4 = ebp_444->dwFFFFFF84;
			word32 edx_1035;
			Eq_2 eax_427 = __mempcpy(esp_407->tFFFFFFF4, esp_407->tFFFFFFF8, esp_407->tFFFFFFFC, out edx_1035);
			ebp_444->dwFFFFFF7C = 0x00;
			ebp_444->dwFFFFFF70 = (word32) eax_427;
			uint32 esi_439 = 0x00;
l080891B8:
			uint32 eax_443 = ebx_115->dwFFFFFFC0;
			ebp_444->ptrFFFFFF68 = ~0x1F;
			for (; eax_443 > esi_439; ++esi_439)
			{
				if (edi_105->a0014[esi_439] != 0x01)
				{
					struct Eq_105697 * eax_459 = ebx_115->dwFFFFFFC4 + esi_439 * 0x08;
					struct Eq_105704 * esp_457 = esp_111 - 0x04;
					esp_457->tFFFFFFFC = eax_459->t0004;
					esp_457->tFFFFFFF8 = eax_459->t0000;
					esp_457->tFFFFFFF4 = ebp_444->dwFFFFFF70;
					word32 edx_1036;
					Eq_2 eax_470 = __mempcpy(esp_457->tFFFFFFF4, esp_457->tFFFFFFF8, esp_457->tFFFFFFFC, out edx_1036);
					esp_457->tFFFFFFFC = ebp_444->dwFFFFFF6C;
					esp_457->tFFFFFFF8 = ebp_444->dwFFFFFF64;
					esp_457->tFFFFFFF4 = eax_470;
					word32 edx_1037;
					ebp_444->ptrFFFFFF78 = __mempcpy(esp_457->tFFFFFFF4, esp_457->tFFFFFFF8, esp_457->tFFFFFFFC, out edx_1037) - ebp_444->dwFFFFFF84;
					if ((*ebp_444->ptrFFFFFF74 & 0x01) != 0x00)
					{
						esp_457->tFFFFFFF8 = ebp_444->dwFFFFFF84;
						esp_457->tFFFFFFF4 = (char *) ebx_115 - 111867;
						word32 ecx_1038;
						word32 edx_1039;
						_dl_debug_printf(out ecx_1038, out edx_1039);
					}
					struct Eq_105801 * esp_522 = esp_111 - 0x08;
					struct Eq_104499 * edx_526 = ebp_444[2];
					ui32 ecx_527 = ebp_444->dwFFFFFF80;
					esp_522->tFFFFFFFC.u0 = 0x00;
					Eq_2 eax_530 = ebp_444->dwFFFFFF84;
					esp_522->tFFFFFFF8 = ebp_444->dw001C;
					uint32 esi_541;
					Eq_2 eax_542 = open_verify.constprop.7(eax_530, ecx_527, edx_526, gs, esp_522->tFFFFFFF8, out ebx_115, out ebp_444, out esi_541, out edi_105);
					Eq_2 edx_548 = eax_542;
					uint32 eax_549 = edi_105->a0014[esi_541];
					if (eax_549 == 0x00)
					{
						if (eax_542 != ~0x00)
						{
							edi_105->a0014[esi_541] = 0x02;
							ebp_444->dwFFFFFF7C = 0x01;
							goto l0808926B;
						}
						if (ebp_444->ptr0014 != 0x00 && (*((char *) (*((char *) (&g_t80CEA00) + (ebp_444->ptr0014)->dw0018 * 0x4C)) + 0x0199) & 0x08) != 0x00)
							ebp_444->dwFFFFFF7C = 0x01;
						else
						{
							int32 ecx_578 = ebp_444->dwFFFFFF84;
							ebp_444->ptrFFFFFF78 + ecx_578 + ~ebp_444->dwFFFFFF6C = (byte *) 0x00;
							esp_111->dwFFFFFFF8 = ebp_444 - 0x78;
							esp_111->dwFFFFFFF4 = ecx_578;
							esp_111->dwFFFFFFF0 = 0x03;
							uint32 edx_602 = 0x01;
							if (__xstat64(gs, esp_111->dwFFFFFFF4, esp_111->dwFFFFFFF8) == 0x00)
							{
								ui32 eax_606 = ebp_444->dwFFFFFF98;
								edx_602 = (uint32) (int8) ((eax_606 & 0xF000) == 0x4000) + 0x01;
								ui32 eax_616 = 0x01;
								if ((eax_606 & 0xF000) != 0x4000)
									eax_616 = ebp_444->dwFFFFFF7C;
								ebp_444->dwFFFFFF7C = eax_616;
							}
							edi_105->a0014[esi_541] = edx_602;
						}
l080893F8:
						esi_439 = esi_541 + 0x01;
						goto l080891B8;
					}
					ebp_444->dwFFFFFF7C |= (word32) (eax_549 != 0x01);
					if (eax_542 == ~0x00)
						goto l080893F8;
l0808926B:
					if ((ebp_444->dwFFFFFF80 & 0x04000000) != 0x00)
					{
						if (*ebp_444->ptrFFFFFF50 != 0x00)
						{
							esp_522->t0000 = ebp_444 - 0x78;
							esp_522->tFFFFFFFC = eax_542;
							ebp_444->dwFFFFFF5C = (word32) eax_542;
							esp_522->tFFFFFFF8.u0 = 0x03;
							word32 ecx_1045;
							word32 edx_1046;
							Eq_2 eax_660 = __fxstat64(gs, esp_522->tFFFFFFFC, esp_522->t0000, out ecx_1045, out edx_1046);
							edx_548 = ebp_444->dwFFFFFF5C;
							if (eax_660 == 0x00 && (ebp_444->bFFFFFF99 & 0x08) != 0x00)
								goto l08089280;
							esp_111->dwFFFFFFF0 = (word32) edx_548;
							word32 edx_1047;
							__close_nocancel(gs, esp_111->dwFFFFFFF0, out edx_1047);
							gs->*ebp_444->ptrFFFFFF68 = 0x02;
							eax_443 = ebx_115->dwFFFFFFC0;
							esi_439 = esi_541;
							goto l08089340;
						}
l08089280:
						esi_439 = esi_541 + 0x01;
						if (edx_548 == ~0x00)
							goto l080891B8;
					}
					ebp_444->dwFFFFFF80 = (ui32) edx_548;
					struct Eq_105878 * esp_786 = esp_111 - 0x0C;
					esp_786->tFFFFFFFC = ebp_444->ptrFFFFFF78;
					word32 edi_1044;
					word32 ecx_1040;
					word32 edx_1041;
					word32 esi_1043;
					word32 ebx_1042;
					Eq_2 eax_797 = __libc_malloc(gs, esp_786->tFFFFFFF8, esp_786->tFFFFFFFC, out ecx_1040, out edx_1041, out ebx_1042, out ebp_444, out esi_1043, out edi_1044);
					word32 edx_810 = ebp_444->dwFFFFFF80;
					*ebp_444->ptr000C = (union Eq_2 *) eax_797;
					if (eax_797 == 0x00)
					{
						esp_111->dwFFFFFFF0 = edx_810;
						word32 edx_1048;
						__close_nocancel(gs, esp_111->dwFFFFFFF0, out edx_1048);
						goto l080892E1;
					}
					else
					{
						ebp_444->dwFFFFFF80 = edx_810;
						esp_111->dwFFFFFFF8 = ebp_444->ptrFFFFFF78;
						esp_111->dwFFFFFFF4 = ebp_444->dwFFFFFF84;
						esp_111->dwFFFFFFF0 = (word32) eax_797;
						word32 ecx_1049;
						word32 edx_1050;
						memcpy(esp_111->dwFFFFFFF0, esp_111->dwFFFFFFF4, esp_111->dwFFFFFFF8, out ecx_1049, out edx_1050);
						ptr32 esi_868 = ebp_444->dwFFFFFFF8;
						word32 eax_870 = ebp_444->dwFFFFFF80;
						ptr32 edi_871 = ebp_444->dwFFFFFFFC;
						struct Eq_105558 * ebp_873 = ebp_444->dw0000;
						ebxOut = ebp_444->dwFFFFFFF4;
						ebpOut = ebp_873;
						esiOut = esi_868;
						ediOut = edi_871;
						return eax_870;
					}
				}
l08089340:
			}
			if (ebp_444->dwFFFFFF7C != 0x00)
			{
				Eq_2 eax_717 = gs->tFFFFFFE0;
				if (eax_717 != 0x0D && eax_717 != 0x02)
					goto l080892E1;
			}
			ebp_444->ptrFFFFFF60 = (struct Eq_106333 **) ((char *) ebp_444->ptrFFFFFF60 + 4);
			struct Eq_105622 ** eax_726 = ebp_444->ptrFFFFFF60;
			ebp_444->dwFFFFFF58 |= ebp_444->dwFFFFFF7C;
			edi_105 = (struct Eq_105622 *) *eax_726;
		} while (edi_105 != null);
		if (ebp_444->dwFFFFFF58 == 0x00)
		{
			struct Eq_106212 * eax_739 = ebp_444[1];
			if (eax_739->dw0004 != 0x00)
			{
				esp_111->dwFFFFFFF0 = eax_739->dw0000;
				word32 edx_1052;
				word32 ecx_1051;
				free(gs, esp_111->dwFFFFFFEC, esp_111->dwFFFFFFF0, out ecx_1051, out edx_1052);
			}
			if (ebp_444[1] != ebx_115 - 0x38 && ebp_444[1] != ebx_115 - 0x4C)
			{
				*ebp_444[1].dw0000 = (struct Eq_105561) ~0x00;
l080892E6:
				struct Eq_106258 * esp_830 = ebp_444 - 0x0C;
				ptr32 esi_837 = esp_830->ptr0004;
				ptr32 edi_839 = esp_830->ptr0008;
				struct Eq_105558 * ebp_841 = esp_830->ptr000C;
				ebxOut = esp_830->ptr0000;
				ebpOut = ebp_841;
				esiOut = esi_837;
				ediOut = edi_839;
				return ~0x00;
			}
		}
	}
l080892E1:
	goto l080892E6;
}

// 08089720: Register Eq_2 _dl_map_object_from_fd.constprop.8(Register Eq_2 eax, Register (ptr32 Eq_106633) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack ui32 dwArg10, Stack Eq_2 dwArg18)
// Called from:
//      _dl_map_object
Eq_2 _dl_map_object_from_fd.constprop.8(Eq_2 eax, struct Eq_106633 * ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ui32 dwArg10, Eq_2 dwArg18)
{
	Eq_2 edi_1056;
	Eq_2 esi_1041;
	Eq_2 eax_34 = _dl_debug_initialize(0x00, dwArg18);
	struct Eq_104910 * ebp_1045 = fp - 4;
	Eq_2 esp_1061 = fp - 0xEC;
	word32 ecx_2915;
	word32 edx_2916;
	if (__fxstat64(gs, edx, fp - 0x7C, out ecx_2915, out edx_2916) < 0x00)
	{
l08089F62:
		esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B4CB;
		ebp_1045->dwFFFFFF38 = (word32) gs->tFFFFFFE0;
		edi_1056.u0 = 0x00;
		goto l08089F7C;
	}
	Eq_2 edi_128;
	edi_1056 = *((char *) &g_t80CEA00 + dwArg18 * 0x4C);
	while (edi_1056 != 0x00)
	{
		if ((*((word32) edi_1056 + 0x0199) & 0x20) == 0x00 && ((*((word32) edi_1056 + 480) ^ dwLoc78 | *((word32) edi_1056 + 476) ^ dwLoc7C) == 0x00 && (*((word32) edi_1056 + 488) ^ dwLoc20 | dwLoc24 ^ *((word32) edi_1056 + 484)) == 0x00))
		{
			word32 edx_2917;
			__close_nocancel(gs, edx, out edx_2917);
			word32 edx_2919;
			word32 ecx_2918;
			free(gs, dwLoc0100, dwArg04, out ecx_2918, out edx_2919);
			word32 ebp_2920;
			add_name_to_object.isra.4(*((word32) edi_1056 + 28), eax, gs, out ebp_2920, out edi_128);
			return edi_128;
		}
		edi_1056 = *((word32) edi_1056 + 0x0C);
	}
	if ((dwArg10 & 0x04) != 0x00)
	{
		word32 ecx_2921;
		word32 edx_2922;
		free(gs, dwLoc0100, dwArg04, out ecx_2921, out edx_2922);
		word32 edx_2923;
		__close_nocancel(gs, edx, out edx_2923);
		edi_128.u0 = 0x00;
		return edi_128;
	}
	if ((_dl_debug_mask & 0x40) != 0x00)
	{
		word32 edx_2925;
		word32 ecx_2924;
		_dl_debug_printf(out ecx_2924, out edx_2925);
	}
	Eq_2 eax_185 = *((word32) eax_34 + 0x0C);
	if (eax_185 != 0x00)
	{
		if (eax_185 != 0x01)
		{
			word32 edx_2927;
			word32 ecx_2926;
			__assert_fail(out ecx_2926, out edx_2927);
			esp_1061.u0 = <invalid>;
			goto l0808A7AF;
		}
	}
	else
	{
		((word32) eax_34 + 0x0C)->u0 = 0x01;
		_dl_debug_state();
	}
	Eq_2 eax_243 = _dl_new_object(gs, dwArg04, eax, (byte) dwArg0C, (byte) dwArg10, dwArg18);
	esp_1061 = fp - 0xEC;
	edi_1056 = eax_243;
	if (eax_243 == 0x00)
	{
l0808A327:
		esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B2BF;
		goto l0808A330;
	}
	Eq_2 esi_329;
	Eq_2 edx_256 = ecx->t0020;
	*((word32) eax_243 + 344) = ecx->dw001C;
	ui32 eax_261 = (word32) ecx->w0030;
	((word32) eax_243 + 348)->u5 = (word16) eax_261;
	ui32 ebx_265 = eax_261 << 0x05;
	if ((word32) edx_256 + (eax_261 << 0x05) <= ecx->dw0000)
	{
		esi_329 = ecx + 0x04 + edx_256;
		goto l080898F1;
	}
	ui32 eax_269 = (eax_261 << 0x05) + 0x1B;
	Eq_2 esi_273 = fp - 0xEC - (eax_269 & 0x003FF000);
	if (fp - 0xEC != esi_273)
	{
		do
		{
			esp_1061 -= 0x1000;
			*((byte) esp_1061.u0 + 0x0FFC) = *((byte) esp_1061.u0 + 0x0FFC);
		} while (esp_1061 != esi_273);
	}
	int32 ecx_289 = eax_269 & 0x003FFFF0 & 0x0FFF;
	if (ecx_289 != 0x00)
	{
		esp_1061 -= ecx_289;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1061 - 0x04)[ecx_289 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1061 - 0x04)[ecx_289 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_106985 * esp_302 = esp_1061 - 0x04;
	esp_302->tFFFFFFFC.u0 = 0x00;
	esp_302->tFFFFFFF8 = edx_256;
	esp_302->tFFFFFFF4 = edx;
	Eq_2 ebx_325;
	word32 ecx_2928;
	__libc_lseek(gs, esp_302->tFFFFFFF4, esp_302->tFFFFFFF8, esp_302->tFFFFFFFC, out ecx_2928, out ebx_325, out ebp_1045, out esi_329, out edi_1056);
	Eq_2 esp_330 = <invalid>;
	*((word32) esp_330 + 8) = ebx_325;
	*((word32) esp_330 + 4) = esi_329;
	*esp_330 = ebp_1045->dwFFFFFF78;
	esp_1061 = (word32) esp_330 + 16;
	word32 ecx_2929;
	if (__read_nocancel(gs, *esp_330, *((word32) esp_330 + 4), *((word32) esp_330 + 8), out ecx_2929) == ebx_325)
	{
		eax_261 = (word32) *((word32) edi_1056 + 348);
		ebx_265 = eax_261 << 0x05;
l080898F1:
		ebp_1045->dwFFFFFF30 = (word32) esp_1061;
		ui32 eax_369 = eax_261 * 0x18 + 0x0F;
		Eq_2 ecx_372 = esp_1061 - (eax_369 & 0x003FF000);
		while (esp_1061 != ecx_372)
		{
			esp_1061 -= 0x1000;
			*((byte) esp_1061.u0 + 0x0FFC) = *((byte) esp_1061.u0 + 0x0FFC);
		}
		int32 edx_388 = eax_369 & 0x003FFFF0 & 0x0FFF;
		if (edx_388 != 0x00)
		{
			esp_1061 -= edx_388;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1061 - 0x04)[edx_388 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1061 - 0x04)[edx_388 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		Eq_106905 eax_400 = (byte) esp_1061.u0 + 3;
		ebp_1045->dwFFFFFF20 = eax_400 >> 0x02;
		ebp_1045->ptrFFFFFF58 = __align(eax_400, 4);
		if (esi_329 >= (word32) esi_329 + ebx_265)
		{
l0808A480:
			esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B213;
			goto l08089F2B;
		}
		ebp_1045->dwFFFFFF84 = (ui32) esi_329;
		ebp_1045->dwFFFFFF44 = 0x07;
		ebp_1045->bFFFFFF3C = 0x00;
		ebp_1045->dwFFFFFF7C = 0x00;
		ebp_1045->ptrFFFFFF24 = 0x080CFEC0;
		ebp_1045->ptrFFFFFF40 = 0x080CE9B0;
		Eq_2 ebx_420 = esi_329;
		Eq_2 esi_426 = edi_1056;
		do
		{
			up32 eax_436 = *ebx_420;
			if (eax_436 != 0x06)
			{
				if (eax_436 > 0x06)
				{
					if (eax_436 != 1685382481)
					{
						if (eax_436 != 1685382482)
						{
							if (eax_436 == 0x07)
							{
								word32 eax_597 = *((word32) ebx_420 + 20);
								if (eax_597 != 0x00)
								{
									*((word32) esi_426 + 568) = eax_597;
									ui32 eax_602 = *((word32) ebx_420 + 28);
									*((word32) esi_426 + 572) = eax_602;
									ui32 ecx_604 = *((word32) ebx_420 + 8);
									ui32 edx_606 = eax_602 - 0x01 & ecx_604;
									if (eax_602 != 0x00)
										eax_602 = edx_606;
									*((word32) esi_426 + 576) = eax_602;
									word32 eax_615 = *((word32) ebx_420 + 16);
									*((word32) esi_426 + 560) = ecx_604;
									*((word32) esi_426 + 564) = eax_615;
									if ((*((word32) esi_426 + 408) & 0x03) != 0x01 && *ebp_1045->ptrFFFFFF24 == 0x00)
									{
										word32 esi_630 = ebp_1045->dwFFFFFF80;
										struct Eq_107199 * esp_633 = esp_1061 - 4;
										esp_633->dw0000 = esi_630 + ~0x0001AEEF;
										esp_633->dwFFFFFFFC = 0x0484;
										esp_633->dwFFFFFFF8 = esi_630 + 4294855192;
										esp_633->dwFFFFFFF4 = esi_630 + ~0x0001B0EB;
										word32 ecx_2930;
										word32 edx_2931;
										__assert_fail(out ecx_2930, out edx_2931);
										esp_1061.u0 = <invalid>;
										goto l0808A327;
									}
									*((word32) esi_426 + 584) = _dl_next_tls_modid();
								}
							}
						}
						else
						{
							*((word32) esi_426 + 592) = *((word32) ebx_420 + 8);
							*((word32) esi_426 + 596) = *((word32) ebx_420 + 20);
						}
					}
					else
						ebp_1045->dwFFFFFF44 = (word32) *((word32) ebx_420 + 24);
				}
				else if (eax_436 != 0x02)
				{
					if (eax_436 != 0x04)
					{
						if (eax_436 == 0x01)
						{
							ui32 edi_490 = *((word32) ebx_420 + 28);
							ui32 edx_491 = *ebp_1045->ptrFFFFFF40;
							ebp_1045->dwFFFFFF64 = edx_491;
							ebp_1045->dwFFFFFF54 = edx_491 - 0x01;
							if ((edx_491 - 0x01 & edi_490) != 0x00)
							{
								edi_1056 = esi_426;
								esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B1C7;
								goto l08089F2B;
							}
							uint32 ecx_501 = *((word32) ebx_420 + 8);
							ui32 eax_502 = *((word32) ebx_420 + 4);
							ebp_1045->dwFFFFFF74 = eax_502;
							if ((ecx_501 - eax_502 & edi_490 - 0x01) != 0x00)
							{
								edi_1056 = esi_426;
								esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B19B;
								goto l08089F2B;
							}
							up32 edx_514 = *((word32) ebx_420 + 16);
							if (ebp_1045->dwFFFFFFB8 - (word32) (ebp_1045->dwFFFFFFB4 < ebp_1045->dwFFFFFF74 + edx_514) < 0x00)
							{
								edi_1056 = esi_426;
								esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B1EB;
								goto l08089F2B;
							}
							ui32 edi_528 = ebp_1045->dwFFFFFF7C;
							ebp_1045->dwFFFFFF68 = edi_528 + 0x01;
							ebp_1045->dwFFFFFF64 = -ebp_1045->dwFFFFFF64;
							struct Eq_107649 * edx_538 = ebp_1045->ptrFFFFFF58 + (edi_528 * 0x18) / 20;
							uint32 edi_539 = ebp_1045->dwFFFFFF64;
							edx_538->dw0008 = edx_514 + ecx_501;
							ui32 eax_543 = ebp_1045->dwFFFFFF54 + edx_538->dw0008;
							uint32 ecx_544 = (word32) *((word32) ebx_420 + 20) + ecx_501;
							edx_538->dw0000 = edi_539 & ecx_501;
							edi_1056 = ebp_1045->dwFFFFFF64;
							edx_538->dw000C = ecx_544;
							edx_538->dw0004 = eax_543 & edi_1056;
							edx_538->dw0010 = ebp_1045->dwFFFFFF74 & edi_1056;
							if (ebp_1045->dwFFFFFF68 > 0x01)
							{
								byte cl_561 = ebp_1045->bFFFFFF3C;
								if (edx_538->dwFFFFFFEC != edx_538->dw0000)
									cl_561 = 0x01;
								ebp_1045->bFFFFFF3C = cl_561;
							}
							ebp_1045->ptrFFFFFF58->a0014[ebp_1045->dwFFFFFF7C].dw0000 = 1934713408 >> ((*((word32) ebx_420 + 24) & 0x07) << 0x02) & 0x0F;
							ebp_1045->dwFFFFFF7C = ebp_1045->dwFFFFFF68;
						}
					}
					else
					{
						struct Eq_107467 * esp_459 = esp_1061 - 0x0C;
						esp_459->ptrFFFFFFFC = (up32 *) ebp_1045->ptrFFFFFF6C;
						if (_dl_process_pt_note(esi_426, ebp_1045->dwFFFFFF78, ebx_420, gs, esp_459->ptrFFFFFFFC, out ebx_420, out ebp_1045, out esi_426, out edi_1056) != 0x00)
						{
							edi_1056 = esi_426;
							esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B4B1;
							goto l08089F2B;
						}
					}
				}
				else if (*((word32) ebx_420 + 16) != 0x00)
				{
					*((word32) esi_426 + 8) = *((word32) ebx_420 + 8);
					((word32) esi_426 + 350)->u5 = (word16) (*((word32) ebx_420 + 20) >> 0x03);
				}
			}
			else
				*((word32) esi_426 + 340) = *((word32) ebx_420 + 8);
			Eq_2 esp_2000 = esp_1061;
			ebx_420 = (word32) ebx_420 + 32;
		} while (ebx_420 < ((word32) (*((word32) esi_426 + 348)) << 0x05) + ebp_1045->dwFFFFFF84);
		edi_1056 = esi_426;
		if (ebp_1045->dwFFFFFF7C == 0x00)
			goto l0808A480;
		Eq_2 edx_1031;
		Eq_107238 ecx_1007;
		word32 eax_683 = (word32) ebp_1045->ptrFFFFFF2C;
		ebp_1045->dwFFFFFF68 = eax_683;
		if (eax_683 != 0x03)
		{
			if ((ebp_1045->dw0014 & 0x20000000) != 0x00)
			{
				ui32 eax_692 = ebp_1045->dwFFFFFF7C;
				Eq_107238 ebx_693 = ebp_1045->ptrFFFFFF58;
				Eq_2 ecx_695 = *((word32) ebx_693 + (((eax_692 - 0x03) + eax_692 * 0x02) * 0x08 + 0x0C));
				word32 edx_697 = null[ebp_1045->dwFFFFFF20];
				ebp_1045->dwFFFFFF74 = ecx_695 - edx_697;
				up32 eax_701 = *esi_426;
				*((word32) esi_426 + 436) = (word32) ecx_695 + eax_701;
				word32 eax_706 = (word32) ebp_1045->bFFFFFF3C;
				*((word32) esi_426 + 432) = edx_697 + eax_701;
				ui32 eax_709 = (eax_706 ^ 0x01) & 0x01;
				*((word32) esi_426 + 0x0199) = *((word32) esi_426 + 0x0199) & 191 | (byte) eax_709 << 0x06;
				ecx_1007 = ebx_693;
				edx_1031 = eax_709 << 0x06;
l08089E20:
				Eq_2 ebx_1050 = ebp_1045->ptrFFFFFF58;
				edi_1056 = esi_426;
				if (ecx_1007 < (word32) ebx_1050 + ebp_1045->dwFFFFFF7C * 0x18)
				{
					up32 edx_1995 = *((word32) ecx_1007 + 4);
					up32 eax_1996 = *ecx_1007;
					ebp_1045->dwFFFFFF84 = (ui32) *((word32) ecx_1007 + 20);
					if (edx_1995 > eax_1996)
					{
						struct Eq_107893 * esp_2002 = esp_2000 - 0x08;
						esp_2002->tFFFFFFFC = *((word32) ecx_1007 + 16);
						ebp_1045->dwFFFFFF64 = (up32) ecx_1007;
						esp_2002->tFFFFFFF8 = ebp_1045->dwFFFFFF78;
						esp_2002->tFFFFFFF4.u0 = 2066;
						esp_2002->tFFFFFFF0.u0 = ebp_1045->dwFFFFFF84;
						esp_2002->tFFFFFFEC = edx_1995 - eax_1996;
						esp_2002->tFFFFFFE8 = (word32) *esi_426 + eax_1996;
						word32 ecx_2939;
						word32 edx_2940;
						Eq_2 eax_2022 = mmap(gs, esp_2002->tFFFFFFE8, esp_2002->tFFFFFFEC, esp_2002->tFFFFFFF0, esp_2002->tFFFFFFF4, esp_2002->tFFFFFFF8, esp_2002->tFFFFFFFC, out ecx_2939, out edx_2940);
						esp_2000 = (char *) &esp_2002->tFFFFFFFC + 0x0C;
						ecx_1007 = ebp_1045->dwFFFFFF64;
						if (eax_2022 == ~0x00)
						{
l08089E84:
							edi_1056 = esi_426;
							esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B13F;
							goto l08089F2B;
						}
					}
					goto l08089D5C;
				}
				byte al_1345;
				word32 eax_1060 = *((word32) esi_426 + 8);
				esp_1061 = ebp_1045->dwFFFFFF30;
				if (eax_1060 != 0x00)
				{
					ecx_1007 = *esi_426;
					ebp_1045->dwFFFFFF84 = (ui32) ecx_1007;
					edx_1031 = (word32) ecx_1007 + eax_1060;
					*((word32) esi_426 + 8) = edx_1031;
					if (edx_1031 != 0x00)
					{
						Eq_2 eax_1079 = *edx_1031;
						while (eax_1079 == 0x00)
						{
							if (ebp_1045->dwFFFFFF84 != 0x00)
							{
								struct Eq_108081 * eax_1091 = *((word32) esi_426 + 48);
								if (eax_1091 != null)
									eax_1091->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108087 * eax_1101 = *((word32) esi_426 + 44);
								if (eax_1101 != null)
									eax_1101->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108171 * eax_1112 = *((word32) esi_426 + 52);
								if (eax_1112 != null)
									eax_1112->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108273 * eax_1123 = *((word32) esi_426 + 56);
								if (eax_1123 != null)
									eax_1123->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108305 * eax_1134 = *((word32) esi_426 + 60);
								if (eax_1134 != null)
									eax_1134->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108321 * eax_1145 = *((word32) esi_426 + 100);
								if (eax_1145 != null)
									eax_1145->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108391 * eax_1156 = *((word32) esi_426 + 0x007C);
								if (eax_1156 != null)
									eax_1156->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108624 * eax_1167 = *((word32) esi_426 + 232);
								if (eax_1167 != null)
									eax_1167->dw0004 += ebp_1045->dwFFFFFF84;
								struct Eq_108998 * eax_1178 = *((word32) esi_426 + 336);
								if (eax_1178 != null)
									eax_1178->dw0004 += ebp_1045->dwFFFFFF84;
							}
							struct Eq_108075 * eax_1189 = *((word32) esi_426 + 112);
							if (eax_1189 == null)
							{
l0808A0D3:
								ebx_1050 = *((word32) esi_426 + 60);
								if (ebx_1050 != 0x00 && *((word32) (*((word32) esi_426 + 0x0044)) + 4) != 0x0C)
								{
									word32 esi_1209 = ebp_1045->dwFFFFFF80;
									struct Eq_108354 * esp_1222 = esp_1061 - 4;
									esp_1222->dw0000 = esi_1209 + ~0x0002962B;
									esp_1222->dwFFFFFFFC = 131;
									esp_1222->dwFFFFFFF8 = esi_1209 + ~0x000297B6;
									esp_1222->dwFFFFFFF4 = esi_1209 + ~0x000296CF;
									word32 edx_2947;
									word32 ecx_2946;
									__assert_fail(out ecx_2946, out edx_2947);
									esp_1061.u0 = <invalid>;
								}
								ecx_1007 = *((word32) esi_426 + 100);
								if (ecx_1007 != 0x00 && *((word32) (*((word32) esi_426 + 0x006C)) + 4) != 0x08)
								{
									word32 esi_1250 = ebp_1045->dwFFFFFF80;
									struct Eq_108596 * esp_1253 = esp_1061 - 4;
									esp_1253->dw0000 = esi_1250 + ~0x0002962B;
									esp_1253->dwFFFFFFFC = 0x87;
									esp_1253->dwFFFFFFF8 = esi_1250 + ~0x000297B6;
									esp_1253->dwFFFFFFF4 = esi_1250 + ~0x0002969B;
									word32 ecx_2955;
									word32 edx_2956;
									__assert_fail(out ecx_2955, out edx_2956);
									esp_1061.u0 = <invalid>;
								}
								struct Eq_108578 * edx_1273 = *((word32) esi_426 + 0x0098);
								if (edx_1273 != null)
								{
									word32 eax_1277 = edx_1273->dw0004;
									*((word32) esi_426 + 524) = eax_1277;
									byte al_1279 = (byte) eax_1277;
									if ((al_1279 & 0x02) != 0x00)
										*((word32) esi_426 + 96) = edx_1273;
									if ((al_1279 & 0x04) != 0x00)
										*((word32) esi_426 + 0x0078) = edx_1273;
									if ((al_1279 & 0x08) != 0x00)
										*((word32) esi_426 + 0x0080) = edx_1273;
								}
								struct Eq_109014 * eax_1302 = *((word32) esi_426 + 188);
								if (eax_1302 != null)
								{
									Eq_109109 eax_1307 = eax_1302->t0004;
									ecx_1007 = ebp_1045->dwFFFFFF28;
									*((word32) esi_426 + 520) = eax_1307;
									al_1345 = (byte) eax_1307;
									if ((*ecx_1007 & 0x40) != 0x00 && (eax_1307 & ~0x08E9) != 0x00)
									{
										word32 eax_1322 = ebp_1045->dwFFFFFF80;
										struct Eq_109167 * esp_1327 = esp_1061 - 0x08;
										esp_1327->dwFFFFFFFC = eax_1307 & ~0x08E9;
										esp_1327->dwFFFFFFF8 = eax_1322 + 4294797720;
										word32 edx_2967;
										_dl_debug_printf(out ecx_1007, out edx_2967);
										al_1345 = (byte) *((word32) esi_426 + 520);
									}
									if ((al_1345 & 0x01) != 0x00)
										*((word32) esi_426 + 0x0080) = *((word32) esi_426 + 188);
								}
								else
									al_1345 = (byte) *((word32) esi_426 + 520);
								edx_1031 = *((word32) esi_426 + 0x0094);
								if (edx_1031 != 0x00)
									*((word32) esi_426 + 92) = 0x00;
								goto l0808A1B2;
							}
							word32 eax_1193 = eax_1189->dw0004;
							if (eax_1193 == 0x11 || eax_1193 == 0x07)
								goto l0808A0D3;
							word32 esi_1926 = ebp_1045->dwFFFFFF80;
							struct Eq_108210 * esp_1928 = esp_1061 - 4;
							esp_1928->dw0000 = esi_1926 + ~0x0002962B;
							esp_1928->dwFFFFFFFC = 0x7E;
							esp_1928->dwFFFFFFF8 = esi_1926 + ~0x000297B6;
							esp_1928->dwFFFFFFF4 = esi_1926 + ~0x0002971F;
							word32 ecx_2945;
							eax_1079 = __assert_fail(out ecx_2945, out edx_1031);
							esp_1061.u0 = <invalid>;
l0808A090:
							eax_1079 = 0x70000022 - eax_1079;
l0808A099:
							*((word32) esi_426 + (eax_1079 * 0x04 + 32)) = edx_1031;
l0808A09C:
							edx_1031 = (word32) edx_1031 + 8;
							eax_1079 = *edx_1031;
						}
						if (eax_1079 > 0x22)
						{
							if (0x6FFFFFFF - eax_1079 > 0x0F)
							{
								int32 ecx_1969 = eax_1079 * 0x02;
								if (ecx_1969 >> 0x01 > ~0x03)
									*((word32) esi_426 + (~(ecx_1969 >> 0x01) * 0x04 + 0x00EC)) = edx_1031;
								else if (0x6FFFFDFF - eax_1079 > 11)
								{
									if (0x6FFFFEFF - eax_1079 <= 0x0A)
										*((word32) esi_426 + (-eax_1079 * 0x04 - 0x400002DC)) = edx_1031;
								}
								else
									*((word32) esi_426 + (-eax_1079 * 0x04 - 0x4000070C)) = edx_1031;
								goto l0808A09C;
							}
							goto l0808A090;
						}
						goto l0808A099;
					}
				}
				else if (ebp_1045->dwFFFFFF68 == 0x03)
				{
					esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B297;
					goto l08089F31;
				}
				al_1345 = (byte) *((word32) esi_426 + 520);
l0808A1B2:
				edi_1056 = esi_426;
				if ((al_1345 & 0x40) != 0x00 && ebp_1045->dw0014 < 0x00)
				{
					Eq_2 edx_1379 = *((word32) esi_426 + 432);
					struct Eq_108422 * esp_1384 = esp_1061 - 4;
					esp_1384->t0000 = ebx_1050;
					esp_1384->tFFFFFFFC = ebx_1050;
					esp_1384->tFFFFFFF8 = *((word32) esi_426 + 436) - edx_1379;
					esp_1384->tFFFFFFF4 = edx_1379;
					word32 ecx_2948;
					word32 edx_2949;
					word32 ebx_2950;
					__munmap(ebx_1050, gs, esp_1384->tFFFFFFF4, esp_1384->tFFFFFFF8, out ecx_2948, out edx_2949, out ebx_2950);
					Eq_2 eax_1434 = *((word32) esi_426 + 28);
					if (*((word32) eax_1434 + 8) == 0x00)
					{
						esp_1384->tFFFFFFF4 = eax_1434;
						word32 ecx_2957;
						word32 edx_2958;
						free(gs, esp_1384->tFFFFFFF0, esp_1384->tFFFFFFF4, out ecx_2957, out edx_2958);
					}
					esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B273;
					if (*((word32) esi_426 + 408) < 0x00)
					{
						struct Eq_108665 * esp_1460 = esp_1061 - 0x0C;
						esp_1460->tFFFFFFFC = *((word32) esi_426 + 340);
						word32 ecx_2959;
						word32 edx_2960;
						free(gs, esp_1460->tFFFFFFF8, esp_1460->tFFFFFFFC, out ecx_2959, out edx_2960);
						esp_1061 = (char *) &esp_1460->tFFFFFFFC + 16;
					}
l08089F31:
					if (ebp_1045->bFFFFFF37 == 0x00)
					{
l08089F7C:
						ebp_1045->dwFFFFFF60 = 0x00;
						goto l08089F3A;
					}
l08089F3A:
					struct Eq_106694 * esp_2045 = esp_1061 - 0x0C;
					esp_2045->dwFFFFFFFC = ebp_1045->dw001C;
					Eq_2 edx_2053 = ebp_1045->dwFFFFFF78;
					esp_2045->tFFFFFFF8 = ebp_1045->dwFFFFFF60;
					Eq_2 eax_2057 = ebp_1045->dwFFFFFF38;
					esp_2045->tFFFFFFF4 = esi_1041;
					esp_2045->tFFFFFFF0 = edi_1056;
					esp_2045->tFFFFFFEC = ebp_1045->dw0008;
					ebp_1045 = lose(eax_2057, edx_2053, gs, esp_2045->tFFFFFFEC, esp_2045->tFFFFFFF0, esp_2045->tFFFFFFF4, esp_2045->tFFFFFFF8);
					esp_1061.u0 = <invalid>;
					goto l08089F62;
				}
				word32 eax_1478 = *((word32) esi_426 + 340);
				if (eax_1478 != 0x00)
					*((word32) esi_426 + 340) = (word32) *esi_426 + eax_1478;
				else
				{
					struct Eq_108464 * esp_1485 = esp_1061 - 0x0C;
					ui32 eax_1487 = (word32) ebp_1045->ptrFFFFFF6C->w0030;
					esp_1485->tFFFFFFFC = eax_1487 << 0x05;
					ebp_1045->dwFFFFFF84 = eax_1487 << 0x05;
					Eq_2 esi_1500;
					word32 ebx_2953;
					word32 ecx_2951;
					word32 edx_2952;
					Eq_2 eax_1494 = __libc_malloc(gs, esp_1485->tFFFFFFF8, esp_1485->tFFFFFFFC, out ecx_2951, out edx_2952, out ebx_2953, out ebp_1045, out esi_1500, out edi_1056);
					esp_1061 = (char *) &esp_1485->t0004 + 8;
					if (eax_1494 == 0x00)
					{
						esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B2EB;
						goto l0808A330;
					}
					esp_1485->t0004 = ebp_1045->dwFFFFFF84;
					esp_1485->t0000 = esi_1500;
					esp_1485->tFFFFFFFC = eax_1494;
					Eq_2 eax_1521 = memcpy(esp_1485->tFFFFFFFC, esp_1485->t0000, esp_1485->t0004, out ecx_1007, out edx_1031);
					*((word32) edi_1056 + 408) |= 0x80;
					*((word32) edi_1056 + 340) = eax_1521;
				}
				if (((byte) ~_dl_stack_flags & ebp_1045->b00BC & 0x01) != 0x00)
				{
					struct Eq_108514 * eax_1549 = ebp_1045->dwFFFFFF80;
					eax_1549->dwFFFFFFD0 |= 0x07;
					struct Eq_108526 * esp_1551 = esp_1061 - 0x0C;
					esp_1551->dwFFFFFFFC = ebp_1045->dw0018;
					word32 eax_1659;
					_dl_make_stack_executable_hook();
					ebp_1045->dwFFFFFF38 = eax_1659;
					esp_1061 = &esp_1551->dwFFFFFFFC + 4;
					if (eax_1659 != 0x00)
					{
						esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B24F;
						goto l08089F31;
					}
				}
				word32 eax_1670 = *((word32) edi_1056 + 560);
				if (eax_1670 != 0x00)
					*((word32) edi_1056 + 560) = (word32) *edi_1056 + eax_1670;
				struct Eq_108551 * esp_1679 = esp_1061 - 0x0C;
				esp_1679->tFFFFFFFC = ebp_1045->dwFFFFFF78;
				esp_1061 = &esp_1679->dw0008 + 1;
				word32 edx_2954;
				if (__close_nocancel(gs, esp_1679->tFFFFFFFC, out edx_2954) == 0x00)
				{
					if (ebp_1045->dwFFFFFF68 != 0x02 || (*((word32) edi_1056 + 408) & 0x03) == 0x00)
					{
						up32 eax_1743 = *edi_1056;
						byte * esi_1745 = ebp_1045->dwFFFFFF28;
						word32 edx_1746 = (word32) *((word32) edi_1056 + 344) + eax_1743;
						*((word32) edi_1056 + 344) = edx_1746;
						if ((*esi_1745 & 0x40) != 0x00)
						{
							esp_1679->tFFFFFFFC = (word32) *((word32) edi_1056 + 348);
							esp_1679->dwFFFFFFF8 = 0x08;
							esp_1679->dwFFFFFFF4 = (word32) *((word32) edi_1056 + 340);
							esp_1679->dwFFFFFFF0 = 0x08;
							esp_1679->dwFFFFFFEC = edx_1746;
							esp_1679->dwFFFFFFE8 = 0x08;
							esp_1679->dwFFFFFFE4 = ebp_1045->dwFFFFFF74;
							esp_1679->dwFFFFFFE0 = 0x08;
							esp_1679->dwFFFFFFDC = eax_1743;
							word32 eax_1775 = ebp_1045->dwFFFFFF80;
							esp_1679->dwFFFFFFD8 = 0x08;
							esp_1679->dwFFFFFFD4 = (word32) *((word32) edi_1056 + 8);
							esp_1679->dwFFFFFFD0 = 0x08;
							esp_1679->dwFFFFFFCC = eax_1775 + ~0x0001B083;
							word32 ecx_2961;
							word32 edx_2962;
							_dl_debug_printf(out ecx_2961, out edx_2962);
						}
						struct Eq_108798 * esp_1797 = esp_1061 - 0x0C;
						esp_1797->tFFFFFFFC = edi_1056;
						word32 esi_2963;
						struct Eq_108805 * ebp_1806;
						_dl_setup_hash(esp_1797->tFFFFFFFC, esp_1797->t0000, out ebp_1806, out esi_2963, out edi_128);
						if ((ebp_1806->b0014 & 0x08) == 0x00 && *((byte) edi_128.u0 + 96) != 0x00)
						{
							Eq_2 eax_1821 = *((byte) edi_128.u0 + 464);
							if (*eax_1821 != (byte) edi_128.u0 + 352)
							{
								**((byte) edi_128.u0 + 360) = edi_128;
								Eq_2 edx_1828 = *((byte) edi_128.u0 + 0x01CC);
								*((byte) edi_128.u0 + 364) = 0x01;
								esp_1797->t0004 = edx_1828 * 0x04 + ~0x03;
								esp_1797->t0000 = eax_1821;
								esp_1797->tFFFFFFFC = (word32) eax_1821 + 4;
								word32 edx_2964;
								memmove(esp_1797->tFFFFFFFC, esp_1797->t0000, esp_1797->t0004, out edx_2964);
								**((byte) edi_128.u0 + 464) = (byte) edi_128.u0 + 360;
							}
						}
						if ((*((byte) edi_128.u0 + 520) & 0x20) != 0x00)
							_dl_initfirst = edi_128;
						*((byte) edi_128.u0 + 476) = ebp_1806->dwFFFFFF50;
						*((byte) edi_128.u0 + 480) = ebp_1806->dwFFFFFF4C;
						*((byte) edi_128.u0 + 484) = ebp_1806->dwFFFFFF70;
						*((byte) edi_128.u0 + 488) = ebp_1806->dwFFFFFF48;
						if (_dl_profile != 0x00)
						{
							Eq_2 eax_1878 = *((byte) edi_128.u0 + 88);
							if (eax_1878 != 0x00)
								add_name_to_object.isra.4(*((byte) edi_128.u0 + 28), Mem1871[eax_1878 + 0x04:word32] + Mem1871[Mem1871[edi_128 + 0x34:word32] + 0x04:word32], gs, out ebp_1806, out edi_128);
						}
						struct Eq_108882 * esp_1907 = esp_1061 - 0x08;
						esp_1907->tFFFFFFFC = ebp_1806->t001C;
						esp_1907->tFFFFFFF8 = edi_128;
						_dl_add_to_namespace_list(esp_1907->tFFFFFFF8, esp_1907->tFFFFFFFC);
						return edi_128;
					}
					word32 esi_1716 = ebp_1045->dwFFFFFF80;
					esp_1679->dw0008 = esi_1716 + ~0x0001AEEF;
					esp_1679->dw0004 = 1322;
					esp_1679->dw0000 = esi_1716 + 4294855192;
					esp_1679->tFFFFFFFC = esi_1716 + ~0x0001B0B3;
					word32 ecx_2965;
					word32 edx_2966;
					__assert_fail(out ecx_2965, out edx_2966);
					goto l0808A480;
				}
				esi_1041 = ebp_1045->dwFFFFFF80 + 4294855447;
l0808A330:
				ebp_1045->dwFFFFFF38 = (word32) gs->tFFFFFFE0;
				goto l08089F31;
			}
			esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B3EF;
l08089F2B:
			esp_1061 = ebp_1045->dwFFFFFF30;
			goto l08089F31;
		}
		ui32 ecx_720 = ebp_1045->dwFFFFFF20;
		ui32 eax_719 = ebp_1045->dwFFFFFF7C;
		ui32 ebx_728 = null[ecx_720];
		Eq_2175 edx_730 = ((Eq_2175[]) 0x14)[ecx_720];
		Eq_2 eax_731 = ebp_1045->ptrFFFFFF58->a000C[(eax_719 - 0x03 + eax_719 * 0x02) * 2] - ebx_728;
		ebp_1045->dwFFFFFF84 = (ui32) edx_730;
		ebp_1045->dwFFFFFF74 = (uint32) eax_731;
		struct Eq_107295 * esp_725 = esp_1061 - 0x08;
		esp_725->tFFFFFFFC = ((Eq_2[]) 0x10)[ecx_720];
		esp_725->tFFFFFFF8 = ebp_1045->dwFFFFFF78;
		esp_725->tFFFFFFF4.u0 = 0x0802;
		esp_725->tFFFFFFF0 = edx_730;
		esp_725->tFFFFFFEC = eax_731;
		esp_725->tFFFFFFE8 = _dl_use_load_bias & ebx_728;
		word32 ecx_2932;
		word32 edx_2933;
		Eq_2 eax_759 = mmap(gs, esp_725->tFFFFFFE8, esp_725->tFFFFFFEC, esp_725->tFFFFFFF0, esp_725->tFFFFFFF4, esp_725->tFFFFFFF8, esp_725->tFFFFFFFC, out ecx_2932, out edx_2933);
		*((word32) esi_426 + 432) = eax_759;
		if (eax_759 == ~0x00)
			goto l08089E84;
		*((word32) esi_426 + 436) = (word32) eax_759 + ebp_1045->dwFFFFFF74;
		word32 eax_772 = eax_759 - ebx_728;
		*esi_426 = eax_772;
		if (ebp_1045->bFFFFFF3C != 0x00)
		{
			ui32 ebx_777 = ebp_1045->dwFFFFFF7C;
			struct Eq_107394 * ebx_781 = ebp_1045->ptrFFFFFF58;
			word32 ecx_782 = ((word32[]) 0x04)[ebp_1045->dwFFFFFF20];
			esp_725->t0000.u0 = 0x00;
			esp_725->tFFFFFFFC = (ebx_781 - 0x18)[ebx_777].dw0000 - ecx_782;
			esp_725->tFFFFFFF8 = eax_772 + ecx_782;
			word32 ecx_2934;
			word32 edx_2935;
			if (mprotect(gs, esp_725->tFFFFFFF8, esp_725->tFFFFFFFC, esp_725->t0000, out ecx_2934, out edx_2935) < 0x00)
				goto l0808A550;
		}
		*((word32) esi_426 + 0x0199) |= 0x40;
		esp_2000 = esp_1061;
		ecx_1007 = ebp_1045->ptrFFFFFF58;
l08089D5C:
		edi_1056 = esi_426;
		if ((ebp_1045->dwFFFFFF84 & 0x04) != 0x00)
			Mem822[esi_426 + 440:word32] = Mem813[ecx_1007 + 0x04:word32] + Mem813[esi_426 + 0x00:word32];
		if (*((word32) esi_426 + 340) == 0x00)
		{
			up32 eax_832 = *((word32) ecx_1007 + 16);
			up32 ebx_833 = ebp_1045->ptrFFFFFF6C->dw0020;
			if (eax_832 <= ebx_833)
			{
				up32 edx_836 = *ecx_1007;
				ebp_1045->dwFFFFFF54 = eax_832;
				ebp_1045->dwFFFFFF64 = edx_836;
				if ((word32) *((word32) ecx_1007 + 4) + eax_832 - ebp_1045->dwFFFFFF64 >= ((word32) (ebp_1045->ptrFFFFFF6C)->w0030 << 0x05) + ebx_833)
					*((word32) esi_426 + 340) = ebp_1045->dwFFFFFF64 + ebx_833 - ebp_1045->dwFFFFFF54;
			}
		}
		Eq_2 eax_857 = *((word32) ecx_1007 + 0x0C);
		edx_1031 = *((word32) ecx_1007 + 8);
		if (eax_857 <= edx_1031)
		{
l08089E1D:
			ecx_1007 = (word32) ecx_1007 + 24;
			goto l08089E20;
		}
		Eq_107538 ebx_862 = *esi_426;
		Mem867[ebp_1045 + -0x009C:word32] = eax_857 + ebx_862;
		Eq_2 eax_869 = _dl_pagesize;
		ebp_1045->ptrFFFFFF2C = (union Eq_2 *) 0x080CE9B0;
		ebp_1045->ptrFFFFFF40 = (ui32 *) eax_869;
		Eq_107556 eax_872 = -eax_869;
		ebp_1045->bFFFFFF3C = (byte) eax_872;
		edx_1031 += ebx_862;
		Eq_2 eax_877 = ebp_1045->ptrFFFFFF40 + (edx_1031 - 0x01) & eax_872;
		Eq_2 ebx_879 = eax_877;
		if (ebp_1045->dwFFFFFF64 <= eax_877)
			ebx_879 = ebp_1045->dwFFFFFF64;
		ebp_1045->dwFFFFFF54 = (up32) ebx_879;
		if (edx_1031 >= ebx_879)
		{
l08089E0B:
			if (ebp_1045->dwFFFFFF64 <= ebp_1045->dwFFFFFF54)
				goto l08089E1D;
			ebp_1045->ptrFFFFFF40 = (ui32 *) ecx_1007;
			up32 eax_1009 = ebp_1045->dwFFFFFF64;
			struct Eq_108110 * esp_1011 = esp_2000 - 0x08;
			Eq_2 ecx_1012 = ebp_1045->dwFFFFFF54;
			esp_1011->tFFFFFFFC.u0 = 0x00;
			esp_1011->tFFFFFFF8.u0 = ~0x00;
			esp_1011->tFFFFFFF4.u0 = 0x32;
			esp_1011->tFFFFFFF0.u0 = ebp_1045->dwFFFFFF84;
			esp_1011->tFFFFFFEC = eax_1009 - ecx_1012;
			esp_1011->tFFFFFFE8 = ecx_1012;
			word32 ecx_2944;
			Eq_2 eax_1029 = mmap(gs, esp_1011->tFFFFFFE8, esp_1011->tFFFFFFEC, esp_1011->tFFFFFFF0, esp_1011->tFFFFFFF4, esp_1011->tFFFFFFF8, esp_1011->tFFFFFFFC, out ecx_2944, out edx_1031);
			ecx_1007 = ebp_1045->ptrFFFFFF40;
			if (eax_1029 == ~0x00)
			{
				esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B495;
				goto l08089F2B;
			}
			goto l08089E1D;
		}
		if ((ebp_1045->dwFFFFFF84 & 0x02) != 0x00)
		{
			up32 eax_979 = ebp_1045->dwFFFFFF54;
			ebp_1045->ptrFFFFFF40 = (ui32 *) ecx_1007;
			struct Eq_107830 * esp_980 = esp_2000 - 0x04;
			esp_980->tFFFFFFFC = eax_979 - edx_1031;
			esp_980->tFFFFFFF8.u0 = 0x00;
			esp_980->tFFFFFFF4 = edx_1031;
			word32 ecx_2938;
			memset(esp_980->tFFFFFFF4, esp_980->tFFFFFFF8, esp_980->tFFFFFFFC, out ecx_2938, out edx_1031);
			ecx_1007 = ebp_1045->ptrFFFFFF40;
			goto l08089E0B;
		}
		ui32 eax_891 = ebp_1045->dwFFFFFF84;
		ebp_1045->ptrFFFFFF24 = (word32 *) ecx_1007;
		struct Eq_107772 * esp_896 = esp_2000 - 0x04;
		esp_896->tFFFFFFFC = eax_891 | 0x02;
		Eq_107780 eax_902 = ebp_1045->bFFFFFF3C;
		esp_896->tFFFFFFF8 = ebp_1045->ptrFFFFFF40;
		ebp_1045->ptrFFFFFF40 = (ui32 *) edx_1031;
		esp_896->tFFFFFFF4 = eax_902 & edx_1031;
		word32 ecx_2936;
		word32 edx_2937;
		Eq_2 eax_916 = mprotect(gs, esp_896->tFFFFFFF4, esp_896->tFFFFFFF8, esp_896->tFFFFFFFC, out ecx_2936, out edx_2937);
		Eq_2 edx_924 = ebp_1045->ptrFFFFFF40;
		Eq_107817 ecx_925 = ebp_1045->ptrFFFFFF24;
		if (eax_916 >= 0x00)
		{
			uint32 eax_933 = ebp_1045->dwFFFFFF54;
			ebp_1045->bFFFFFF3C = (byte) ecx_925;
			esp_896->tFFFFFFFC = eax_933 - edx_924;
			esp_896->tFFFFFFF8.u0 = 0x00;
			esp_896->tFFFFFFF4 = edx_924;
			ebp_1045->ptrFFFFFF40 = (ui32 *) edx_924;
			word32 ecx_2941;
			word32 edx_2942;
			memset(esp_896->tFFFFFFF4, esp_896->tFFFFFFF8, esp_896->tFFFFFFFC, out ecx_2941, out edx_2942);
			ui32 * edx_956 = ebp_1045->ptrFFFFFF40;
			Eq_2 eax_957 = *ebp_1045->ptrFFFFFF2C;
			esp_896->tFFFFFFFC = ebp_1045->dwFFFFFF84;
			esp_896->tFFFFFFF8 = eax_957;
			esp_896->tFFFFFFF4 = -eax_957 & edx_956;
			word32 ecx_2943;
			mprotect(gs, esp_896->tFFFFFFF4, esp_896->tFFFFFFF8, esp_896->tFFFFFFFC, out ecx_2943, out edx_1031);
			ecx_1007.u0 = ebp_1045->bFFFFFF3C;
			goto l08089E0B;
		}
l0808A550:
		edi_1056 = esi_426;
		esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B163;
		goto l08089F2B;
	}
l0808A7AF:
	esi_1041 = ebp_1045->dwFFFFFF80 + ~0x0001B5C0;
	goto l0808A330;
}

// 0808A7E0: Register Eq_2 add_path.isra.3.constprop.9(Register Eq_2 eax, Register (ptr32 word32) edx)
// Called from:
//      _dl_rtld_di_serinfo
Eq_2 add_path.isra.3.constprop.9(Eq_2 eax, word32 * edx)
{
	if (edx != (word32 *) ~0x00)
	{
		word32 * edi_23 = edx;
		struct Eq_109337 * edx_100 = *edx;
		do
		{
			++edi_23;
			struct Eq_109343 * ecx_32 = *((word32) eax + 8);
			eax = edx_100->t0010;
			if (*eax != 0x00)
			{
				edx_100 = *edi_23;
				++ecx_32->dw0004;
				if (eax < 0x02)
					eax.u0 = 0x02;
				ecx_32->dw0000 = (word32) eax + ecx_32->dw0000;
				if (edx_100 != null)
					continue;
				return eax;
			}
			ui32 ebp_52 = *((word32) eax + 4);
			*((word32) eax + 4) = ebp_52 + 0x01;
			struct Eq_109377 * ebp_54 = ecx_32 + ebp_52;
			Eq_2 ebx_56 = *((word32) eax + 0x0C);
			ebp_54->t0008 = ebx_56;
			if (eax <= 0x01)
			{
				*((word32) eax + 0x0C) = (word32) ebx_56 + 1;
				ebx_56->u0 = (int8) (eax != 0x00) + 0x2E;
				eax = *((word32) eax + 0x0C);
			}
			else
			{
				word32 edx_166;
				eax = __mempcpy(ebx_56, edx_100->t000C, eax - 0x01, out edx_166);
			}
			*((byte) eax.u0 + 0x0C) = (byte) eax.u0 + 1;
			*eax.u0 = 0x00;
			edx_100 = *edi_23;
			ebp_54->dw000C = 0x00;
		} while (edx_100 != null);
	}
	return eax;
}

// 0808A8A0: Register word32 _dl_dst_count(Stack Eq_2 dwArg04)
// Called from:
//      expand_dynamic_string_token
//      _dl_map_object_deps
word32 _dl_dst_count(Eq_2 dwArg04)
{
	word32 ebx_113 = 0x00;
	word32 ecx_168;
	word32 edx_169;
	Eq_2 eax_26 = strchr(dwArg04, 0x24, out ecx_168, out edx_169);
	while (eax_26 != 0x00)
	{
		Eq_2 ebp_42 = (word32) eax_26 + 1;
		word32 ecx_174;
		int32 eax_46 = is_dst(ebp_42, 0x080B2B9A, out ecx_174);
		if (eax_46 == 0x00)
		{
			word32 ecx_170;
			eax_46 = is_dst(ebp_42, 134949793, out ecx_170);
			if (eax_46 != 0x00)
				goto l0808A920;
			word32 ecx_171;
			eax_46 = is_dst(ebp_42, 0x080B2BAA, out ecx_171);
			if (eax_46 != 0x00)
				goto l0808A920;
		}
		else
		{
l0808A920:
			++ebx_113;
			ebp_42 = (word32) ebp_42 + eax_46;
		}
		word32 edx_173;
		word32 ecx_172;
		eax_26 = strchr(ebp_42, 0x24, out ecx_172, out edx_173);
	}
	return ebx_113;
}

// 0808A940: Register Eq_2 _dl_dst_substitute(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_109498) ecxOut)
// Called from:
//      expand_dynamic_string_token
//      _dl_map_object_deps
Eq_2 _dl_dst_substitute(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_109498 & ecxOut)
{
	struct Eq_109498 * ebp_126 = null;
	Eq_2 edi_159 = dwArg0C;
	Eq_2 esi_162 = dwArg08;
	byte al_164 = *dwArg08;
	struct Eq_109498 * ecx_125 = (struct Eq_109498 *) 0x080CDDAC;
	do
	{
		esi_162 = (word32) esi_162 + 1;
		if (al_164 != 0x24)
		{
			*edi_159 = al_164;
			edi_159 = (word32) edi_159 + 1;
			goto l0808A985;
		}
		ptr32 dwLoc28_231;
		Eq_2 eax_116;
		int32 eax_41 = is_dst(esi_162, 0x080B2B9A, out ecx_125);
		int32 edx_138 = eax_41;
		if (eax_41 != 0x00)
		{
			if (*(union Eq_4846 *) 0x080CDDAC == 0x00)
			{
				eax_116 = *((word32) dwArg04 + 428);
				ebp_126 = null;
				ecx_125 = eax_116 - 0x01;
				dwLoc28_231 = eax_116 - 0x01;
			}
			else
			{
				if (esi_162 != (word32) dwArg08 + 1)
					goto l0808AA7E;
				byte al_107 = *((word32) esi_162 + eax_41);
				if (al_107 != 0x00 && al_107 != 0x2F)
					goto l0808AA7E;
				eax_116 = *((word32) dwArg04 + 428);
				ecx_125 = SEQ(SLICE(dwArg04, word24, 8), (int8) ((*((word32) dwArg04 + 408) & 0x03) == 0x00));
				dwLoc28_231 = eax_116 - 0x01;
				ebp_126 = ecx_125;
			}
			goto l0808A9C7;
		}
		word32 ecx_322;
		int32 eax_54 = is_dst(esi_162, 134949793, out ecx_322);
		edx_138 = eax_54;
		if (eax_54 == 0x00)
		{
			int32 eax_73 = is_dst(esi_162, 0x080B2BAA, out ecx_125);
			edx_138 = eax_73;
			if (eax_73 != 0x00)
			{
				eax_116.u0 = 0x080B2BAE;
				ecx_125 = (struct Eq_109498 *) &g_t80B2BAF;
				dwLoc28_231 = 0x080B2BAF;
				goto l0808A9C7;
			}
			*edi_159 = 0x24;
			edi_159 = (word32) edi_159 + 1;
l0808A985:
			al_164 = (byte) *esi_162;
			if (al_164 != 0x00)
				continue;
			break;
		}
		eax_116 = _dl_platform;
		ecx_125 = eax_116 - 0x01;
		dwLoc28_231 = eax_116 - 0x01;
l0808A9C7:
		if (dwLoc28_231 > ~0x02)
			goto l0808AA7E;
		edi_159 = __stpcpy(edi_159, eax_116, out ecx_125);
		esi_162 = (word32) esi_162 + edx_138;
		al_164 = (byte) *esi_162;
	} while (al_164 != 0x00);
	if ((byte) ebp_126 == 0x00 || is_trusted_path_normalize(dwArg0C, edi_159 - dwArg0C, out ecx_125) != 0x00)
		*edi_159 = 0x00;
	else
	{
l0808AA7E:
		*dwArg0C = 0x00;
	}
	ecxOut = ecx_125;
	return dwArg0C;
}

// 0808AAD0: Register Eq_2 expand_dynamic_string_token(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ebpOut, Register out Eq_2 esiOut)
// Called from:
//      fillin_rpath
//      _dl_map_object
Eq_2 expand_dynamic_string_token(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2 eax_163;
	Eq_2 eax_26 = _dl_dst_count(edx);
	if (eax_26 == 0x00)
	{
		eax_163 = strdup(edx);
		goto l0808AAFF;
	}
	Eq_2 eax_103;
	word32 edx_321;
	word32 ecx_320;
	Eq_2 eax_42 = strlen(edx, out ecx_320, out edx_321);
	Eq_2 dwLoc24_228 = eax_42;
	Eq_2 eax_112 = *((word32) eax + 428);
	if (eax_112 != 0x00)
	{
		if (eax_112 != ~0x00)
			goto l0808AB37;
	}
	else
	{
		if (**((word32) eax + 4) != 0x00)
		{
			Eq_2 edx_71;
			word32 ecx_324;
			__assert_fail(out ecx_324, out edx_71);
			Eq_2 eax_79 = fillin_rpath(ecx, edx_71, gs);
			ebpOut = eax;
			esiOut = edx;
			return eax_79;
		}
		word32 ebx_325;
		word32 esi_326;
		eax_112 = _dl_get_origin(gs, dwLoc2C, out ebx_325, out esi_326);
		*((word32) eax + 428) = eax_112;
		if (eax_112 <= ~0x01)
		{
l0808AB37:
			word32 ecx_322;
			word32 edx_323;
			eax_103 = strlen(eax_112, out ecx_322, out edx_323);
l0808AB4B:
			if (_dl_platformlen >= eax_103)
				eax_103 = _dl_platformlen;
			if (eax_103 > 0x04)
				dwLoc24_228 = (word32) eax_42 + eax_26 *s (eax_103 - 0x04);
			Eq_2 ebp_164;
			Eq_2 esi_169;
			word32 ecx_327;
			word32 edx_328;
			word32 ebx_329;
			word32 edi_330;
			eax_163 = __libc_malloc(gs, dwLoc40, (word32) dwLoc24_228 + 1, out ecx_327, out edx_328, out ebx_329, out ebp_164, out esi_169, out edi_330);
			if (eax_163 != 0x00)
			{
				word32 ecx_331;
				eax_163 = _dl_dst_substitute(ebp_164, esi_169, eax_163, out ecx_331);
			}
l0808AAFF:
			ebpOut = ebp;
			esiOut = esi;
			return eax_163;
		}
	}
	eax_103.u0 = 0x00;
	goto l0808AB4B;
}

// 0808ABF0: Register Eq_2 fillin_rpath(Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      expand_dynamic_string_token
//      cache_rpath.part.6
//      _dl_init_paths
Eq_2 fillin_rpath(Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	struct Eq_109737 * ebx_17 = &g_t80CE000;
	while (true)
	{
		Eq_2 eax_42 = __strsep_g(fp - 0x20, ecx);
		struct Eq_109779 * esp_103 = fp - 0x4C;
		Eq_2 edi_149 = eax_42;
		if (eax_42 == 0x00)
			break;
		Eq_2 esi_144;
		struct Eq_109744 * esp_186;
		Eq_2 ebp_162;
		Eq_2 eax_156;
		Eq_2 edx_124;
		if (*eax_42 == 0x00)
		{
			esi_144.u0 = 0x00;
			eax_156 = _dl_all_dirs;
			if (eax_156 != 0x00)
				goto l0808ACCA;
			esi_144.u0 = 0x00;
			goto l0808AD68;
		}
		word32 ebp_722;
		word32 esi_723;
		Eq_2 eax_84 = expand_dynamic_string_token(dwArg0C, eax_42, gs, out ebp_722, out esi_723);
		edi_149 = eax_84;
		if (eax_84 == 0x00)
			continue;
		word32 edx_725;
		word32 ecx_724;
		Eq_2 eax_96 = strlen(eax_84, out ecx_724, out edx_725);
		esp_103 = fp - 0x4C;
		if (eax_96 != 0x00)
		{
			if (eax_96 != 0x01)
			{
				edx_124 = eax_96 - 0x01;
				if (*((word32) eax_96 + (eax_84 - 0x01)) != 0x2F)
				{
					edx_124 = eax_96;
					while (true)
					{
l0808AE78:
						Mem150[edi_149 + edx_124:byte] = 0x2F;
						esp_103->dw0000 = (word32) edi_149;
						esi_144 = (byte) edx_124.u0 + 1;
l0808ACB8:
						eax_156 = *esp_103[4].dw0000;
						esp_103[5] = (struct Eq_109779) eax_156;
						if (eax_156 != 0x00)
						{
l0808ACCA:
							ebp_162 = eax_156;
							do
							{
								if (*((word32) ebp_162 + 16) == esi_144)
								{
									struct Eq_109992 * esp_169 = esp_103 - 0x04;
									esp_169->tFFFFFFFC = esi_144;
									esp_169->tFFFFFFF8 = *((word32) ebp_162 + 0x0C);
									esp_169->tFFFFFFF4 = edi_149;
									word32 edx_735;
									word32 ecx_734;
									Eq_2 eax_179 = memcmp(esp_169->tFFFFFFF4, esp_169->tFFFFFFF8, esp_169->tFFFFFFFC, out ecx_734, out edx_735);
									esp_186 = (struct Eq_109744 *) ((char *) &esp_169->tFFFFFFFC + 8);
									if (eax_179 == 0x00)
									{
										Eq_2 edx_390 = esp_169->t0010;
										if (edx_390 == 0x00)
											goto l0808AD1C;
										Eq_2 ecx_394[] = esp_169->ptr001C;
										if (ebp_162 != ecx_394[0])
										{
											do
											{
												eax_179 = (word32) eax_179 + 1;
												if (edx_390 == eax_179)
													goto l0808AD1C;
											} while (ecx_394[eax_179] != ebp_162);
										}
										goto l0808AD2E;
									}
								}
								ebp_162 = *ebp_162;
							} while (ebp_162 != 0x00);
						}
l0808AD68:
						if (esp_103[21] != 0x00)
						{
							struct Eq_109862 * esp_204 = esp_103 - 0x0C;
							esp_204->tFFFFFFFC = esp_204->t0060;
							word32 ecx_728;
							word32 edx_729;
							esp_204->dw0028 = (word32) strlen(esp_204->tFFFFFFFC, out ecx_728, out edx_729) + 1;
						}
						else
							esp_103[7] = (struct Eq_109779) 0x00;
						ui32 edx_230 = ebx_17->dwFFFFFFC0;
						struct Eq_109887 * esp_232 = esp_103 - 0x0C;
						esp_232->dw0030 = edx_230;
						ui32 ecx_233 = edx_230 * 0x04 + 0x14;
						esp_232->dw002C = ecx_233;
						esp_232->dw0034 = ecx_233 + 0x01;
						esp_232->tFFFFFFFC = (word32) esp_232->t0028 + ((word32) esi_144 + (ecx_233 + 0x01));
						Eq_2 edi_260;
						Eq_2 esi_262;
						word32 ebp_742;
						word32 ecx_740;
						word32 edx_741;
						Eq_2 eax_256 = __libc_malloc(gs, esp_232->tFFFFFFF8, esp_232->tFFFFFFFC, out ecx_740, out edx_741, out ebx_17, out ebp_742, out esi_262, out edi_260);
						ui32 ecx_268 = esp_232->dw002C;
						ui32 edx_269 = esp_232->dw0030;
						ebp_162 = eax_256;
						if (eax_256 != 0x00)
						{
							esp_232->dw002C = edx_269;
							Eq_2 ecx_296 = (word32) eax_256 + ecx_268;
							*((word32) eax_256 + 0x0C) = ecx_296;
							esp_232->t0004 = esi_262;
							esp_232->t0000 = edi_260;
							esp_232->tFFFFFFFC = ecx_296;
							word32 edx_733;
							Eq_2 eax_306 = __mempcpy(esp_232->tFFFFFFFC, esp_232->t0000, esp_232->t0004, out edx_733);
							ui32 edx_316 = esp_232->dw002C;
							*eax_306 = 0x00;
							*((word32) eax_256 + 16) = esi_262;
							if (ebx_17->t1A44 < esi_262)
								ebx_17->t1A44 = esi_262;
							ui32 eax_327 = 0x00;
							uint32 ecx_329 = (uint32) (int8) (*edi_260 != 0x2F);
							if (edx_316 != 0x00)
							{
								do
								{
									*((word32) eax_256 + (eax_327 * 0x04 + 20)) = ecx_329 * 0x02;
									++eax_327;
								} while (edx_316 != eax_327);
							}
							Eq_2 edx_350 = esp_232->t0060;
							*((word32) eax_256 + 4) = esp_232->dw005C;
							if (edx_350 != 0x00)
							{
								Eq_2 esi_362 = (word32) eax_256 + ((word32) esi_262 + esp_232->dw0034);
								esp_232->t0004 = esp_232->t0028;
								esp_232->t0000 = esp_232->t0060;
								esp_232->tFFFFFFFC = esi_362;
								word32 ecx_738;
								word32 edx_739;
								*((word32) eax_256 + 8) = memcpy(esp_232->tFFFFFFFC, esp_232->t0000, esp_232->t0004, out ecx_738, out edx_739);
							}
							else
								((word32) eax_256 + 8)->u0 = 0x00;
							*eax_256 = esp_232->dw0020;
							*esp_232->ptr001C = (union Eq_2 *) eax_256;
							esp_186 = (struct Eq_109744 *) ((char *) &esp_232->t0008 + 4);
l0808AD1C:
							ui32 eax_410 = esp_186->dw000C;
							esp_186->ptr0018[eax_410] = ebp_162;
							esp_186->dw000C = eax_410 + 0x01;
l0808AD2E:
							struct Eq_110059 * esp_418 = esp_186 - 0x0C;
							esp_418->tFFFFFFFC = esp_418->t000C;
							word32 edx_737;
							word32 ecx_736;
							free(gs, esp_418->tFFFFFFF8, esp_418->tFFFFFFFC, out ecx_736, out edx_737);
							continue;
						}
						esp_232->t0008 = (char *) ebx_17 - 0x0001AFF8;
						esp_232->t0004.u0 = 0x00;
						esp_232->t0000.u0 = 0x00;
						esp_232->tFFFFFFFC.u0 = 0x0C;
						word32 ebp_732;
						word32 ecx_730;
						word32 edx_731;
						_dl_signal_error(gs, esp_232->tFFFFFFFC, esp_232->t0008, out ecx_730, out edx_731, out ebx_17, out ebp_732, out edi_149);
						esp_103 = esp_232 - 4;
l0808AEC6:
						edx_124.u0 = 0x01;
					}
				}
				while (edx_124 != 0x01)
				{
					Eq_2 eax_132 = edx_124 - 0x01;
					if (Mem95[eax_84 - 0x01 + edx_124:byte] != 0x2F)
						goto l0808AE78;
					edx_124 = eax_132;
				}
			}
			if (*eax_84 != 0x2F)
				goto l0808AEC6;
			esi_144.u0 = 0x01;
			goto l0808ACB8;
		}
		word32 edx_727;
		word32 ecx_726;
		free(gs, dwLoc60, eax_84, out ecx_726, out edx_727);
	}
	*edx = 0x00;
	return edx;
}

// 0808AED0: Register Eq_2 cache_rpath.part.6(Register Eq_2 eax, Register ui32 ecx, Register (ptr32 word32) edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_map_object
//      _dl_rtld_di_serinfo
Eq_2 cache_rpath.part.6(Eq_2 eax, ui32 ecx, word32 * edx, struct Eq_9 * gs)
{
	ptr32 ebx_19 = 0x080CE000;
	Eq_2 eax_22 = *((word32) eax + (ecx * 0x04 + 32));
	if (eax_22 == 0x00)
	{
		*edx = (struct Eq_105622 **) ~0x00;
		return eax_22;
	}
	word32 eax_40 = Mem17[eax_22 + 0x04:word32] + Mem17[Mem17[eax + 0x34:word32] + 0x04:word32];
	byte * eax_42 = *((word32) eax + 4);
	byte * ecx_100 = _dl_inhibit_rpath;
	if (ecx_100 != null && *((union Eq_4846 *) 0x080CDDAC) == 0x00)
	{
		byte al_111 = *ecx_100;
		word32 edi_61 = (word32) *eax_42;
		do
		{
			byte dl_65 = (byte) edi_61;
			if (dl_65 == al_111)
			{
				if (dl_65 == 0x00)
					goto l0808B090;
				byte * esi_74 = eax_42;
				do
				{
					++ecx_100;
					++esi_74;
					al_111 = *ecx_100;
					dl_65 = *esi_74;
					if (al_111 != dl_65)
						goto l0808B044;
				} while (al_111 != 0x00);
				goto l0808B080;
			}
l0808B044:
			if (dl_65 == 0x00)
			{
l0808B080:
				if (al_111 == 0x00 || al_111 == 0x3A)
				{
l0808B090:
					goto l0808AF1C;
				}
			}
			do
			{
				byte al_103 = *ecx_100;
				if (al_103 == 0x00)
					goto l0808B05E;
				++ecx_100;
			} while (al_103 != 0x3A);
			al_111 = *ecx_100;
		} while (al_111 != 0x00);
l0808B05E:
	}
	if (*eax_40 == 0x00)
	{
l0808AF1C:
		*edx = (struct Eq_105622 **) ~0x00;
		return 0x00;
	}
	Eq_2 eax_236;
	Eq_2 eax_149 = strdup(eax_40);
	ptr32 esp_158 = fp - 44;
	if (eax_149 != 0x00)
	{
		Eq_2 eax_168;
		byte al_164 = *eax_149;
		if (al_164 != 0x00)
		{
			Eq_2 edx_169 = eax_149;
			ui32 ecx_170 = 0x00;
			do
			{
				edx_169 = (word32) edx_169 + 1;
				ecx_170 += (word32) (al_164 == 0x3A);
				al_164 = (byte) *edx_169;
			} while (al_164 != 0x00);
			eax_168 = ecx_170 * 0x04 + 0x08;
		}
		else
			eax_168.u0 = 0x08;
		word32 ebx_209;
		Eq_2 edi_211;
		struct Eq_110345 * esi_213;
		word32 ecx_539;
		word32 ebp_541;
		word32 edx_540;
		Eq_2 eax_207 = __libc_malloc(gs, dwLoc40, eax_168, out ecx_539, out edx_540, out ebx_209, out ebp_541, out esi_213, out edi_211);
		if (eax_207 != 0x00)
		{
			fillin_rpath(ebx_209 + ~0x00014A8A, eax_207, gs);
			word32 ecx_531;
			word32 edx_532;
			free(gs, dwLoc40, edi_211, out ecx_531, out edx_532);
			if (*eax_207 == 0x00)
			{
				word32 edx_534;
				word32 ecx_533;
				free(gs, dwLoc40, eax_207, out ecx_533, out edx_534);
				esi_213->t0000.u0 = ~0x00;
				return 0x00;
			}
			else
			{
				esi_213->t0000 = eax_207;
				esi_213->dw0004 = 0x01;
				return 0x01;
			}
		}
		word32 edx_530;
		word32 ecx_529;
		free(gs, dwLoc40, edi_211, out ecx_529, out edx_530);
		esp_158 = fp - 44;
		eax_236 = ebx_209 + ~0x0001AFF7;
l0808B0DB:
		struct Eq_110383 * esp_238 = esp_158 - 4;
		esp_238->t0000 = eax_236;
		esp_238->dwFFFFFFFC = 0x00;
		esp_238->dwFFFFFFF8 = 0x00;
		esp_238->tFFFFFFF4.u0 = 0x0C;
		word32 ebp_537;
		word32 ecx_535;
		word32 edi_538;
		word32 edx_536;
		_dl_signal_error(gs, esp_238->tFFFFFFF4, esp_238->t0000, out ecx_535, out edx_536, out ebx_19, out ebp_537, out edi_538);
		esp_158 = esp_238 - 0x0C;
	}
	eax_236 = ebx_19 + ~0x0001AFD3;
	goto l0808B0DB;
}

// 0808B0F0: Register word32 _dl_init_paths(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_non_dynamic_init
word32 _dl_init_paths(struct Eq_9 * gs)
{
	Eq_2 eax_305;
	struct Eq_110459 * ebx_38;
	word32 eax_36 = _dl_important_hwcaps(gs, _dl_platform, _dl_platformlen, &_IO_list_all, out ebx_38);
	Eq_2 esp_44 = <invalid>;
	esp_44->u0 = 0x0C;
	ebx_38->dwFFFFFFC4 = eax_36;
	struct Eq_110483 * ebp_52;
	word32 ecx_472;
	word32 edx_473;
	word32 esi_474;
	word32 edi_475;
	struct Eq_110488 * ebx_319;
	Eq_2 eax_51 = __libc_malloc(gs, *((word32) esp_44 - 4), *esp_44, out ecx_472, out edx_473, out ebx_319, out ebp_52, out esi_474, out edi_475);
	ebx_319->tFFFFFFB4 = eax_51;
	ptr32 esp_299 = (word32) esp_44 + 16;
	if (eax_51 != 0x00)
	{
		uint32 edx_73 = SLICE((ebx_319->dwFFFFFFC0 * 0x04 + 0x27) *64 ~0x33333332, word32, 32);
		uint32 edx_76 = (edx_73 >> 0x04) + (edx_73 >> 0x04) * 0x04;
		ebp_52->dwFFFFFFE4 = edx_76;
		*esp_44 = edx_76 * 0x08;
		struct Eq_110540 * ebp_82;
		struct Eq_110541 * edi_85;
		ui32 esi_87;
		word32 edx_477;
		word32 ecx_476;
		struct Eq_110545 * ebx_290;
		Eq_2 eax_81 = __libc_malloc(gs, *((word32) esp_44 - 4), *esp_44, out ecx_476, out edx_477, out ebx_290, out ebp_82, out esi_87, out edi_85);
		Eq_110561 edx_93 = ebp_82->tFFFFFFE4;
		edi_85->t0000 = eax_81;
		esp_299 = (word32) esp_44 + 16;
		if (eax_81 != 0x00)
		{
			struct Eq_110574 * edx_112;
			*((word32) eax_81 + 8) = 0x00;
			ebx_290->dwFFFFFFB8 = 0x00;
			_dl_all_dirs = eax_81;
			ebp_82->tFFFFFFE4 = (char *) ebx_290 - 111694;
			*((word32) eax_81 + 4) = (char *) ebx_290 - 111694;
			*((word32) eax_81 + 0x0C) = (char *) ebx_290 - 110188;
			*((word32) eax_81 + 16) = 0x05;
			if (esi_87 != 0x00)
			{
				ui32 edx_122 = 0x00;
				do
				{
					*((word32) eax_81 + (edx_122 * 0x04 + 20)) = 0x00;
					++edx_122;
				} while (esi_87 != edx_122);
				edx_112 = (word32) eax_81 + edx_93 * 0x04;
				*eax_81 = edx_112;
				edi_85->ptr0004 = edx_112;
				Eq_110561 edi_142 = ebp_82->tFFFFFFE4;
				edx_112->dw0008 = 0x00;
				edx_112->t0004 = edi_142;
				edx_112->dw0010 = 0x09;
				edx_112->ptr000C = (char *) ebx_290 - 110182;
				ui32 ecx_147 = 0x00;
				do
				{
					edx_112->a0014[ecx_147] = 0x00;
					++ecx_147;
				} while (esi_87 != ecx_147);
			}
			else
			{
				edx_112 = (word32) eax_81 + edx_93 * 0x04;
				*eax_81 = edx_112;
				edi_85->ptr0004 = edx_112;
				Eq_110561 edi_117 = ebp_82->tFFFFFFE4;
				edx_112->dw0008 = 0x00;
				edx_112->t0004 = edi_117;
				edx_112->ptr000C = (char *) ebx_290 - 110182;
				edx_112->dw0010 = 0x09;
			}
			Eq_2 ecx_161 = ebp_82->t0008;
			edx_112->dw0000 = 0x00;
			ebx_290->t1A44.u0 = 0x09;
			edi_85->dw0008 = 0x00;
			if (ecx_161 == 0x00)
			{
l0808B24C:
				ebx_290->tFFFFFFC8.u0 = ~0x00;
				return ebp_82->dwFFFFFFF4;
			}
			Eq_2 eax_173 = ebp_82->t0008;
			if (*eax_173 == 0x00)
				goto l0808B24C;
			*esp_44 = eax_173;
			word32 edx_479;
			word32 ecx_478;
			Eq_2 eax_183 = strlen(*esp_44, out ecx_478, out edx_479);
			struct Eq_110731 * esp_190 = (word32) esp_44 + 16;
			struct Eq_110731 * edi_196 = (word32) esp_44 + 16 - ((word32) eax_183 + 28 & ~0x0FFF);
			ui32 ecx_197 = (word32) eax_183 + 28 & ~0x0F;
			while (esp_190 != edi_196)
			{
				esp_190 -= 0x1000;
				esp_190->dw0FFC = esp_190->dw0FFC;
			}
			if ((ecx_197 & 0x0FFF) != 0x00)
			{
				esp_190 -= ecx_197 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[(ecx_197 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[(ecx_197 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_2 ecx_248;
			struct Eq_110808 * esp_218 = esp_190 - 0x04;
			esp_218->tFFFFFFFC = (word32) eax_183 + 1;
			esp_218->tFFFFFFF8 = ebp_82->t0008;
			Mem232[esp_218 + -0x0C:word32] = esp_190 + 0x0F & ~0x0F;
			word32 ecx_484;
			word32 edx_485;
			Eq_2 eax_233 = memcpy(esp_218->tFFFFFFF4, esp_218->tFFFFFFF8, esp_218->tFFFFFFFC, out ecx_484, out edx_485);
			word32 eax_243 = (word32) *eax_233;
			if ((byte) eax_243 != 0x00)
			{
				Eq_2 edx_249 = eax_233;
				ui32 edi_250 = 0x01;
				do
				{
					ui32 ecx_255 = edi_250 + 0x01;
					if ((byte) eax_243 <= 0x3B && (byte) eax_243 >= 0x3A)
					{
						edi_250 = ecx_255;
						ecx_255 = edi_250 + 0x02;
					}
					edx_249 = (word32) edx_249 + 1;
					eax_243 = (word32) *edx_249;
				} while ((byte) eax_243 != 0x00);
				ecx_248 = ecx_255 << 0x02;
			}
			else
				ecx_248.u0 = 0x08;
			esp_218->tFFFFFFF4 = ecx_248;
			word32 esi_488;
			word32 edx_487;
			word32 ecx_486;
			struct Eq_110875 * ebp_289;
			word32 edi_489;
			Eq_2 eax_288 = __libc_malloc(gs, esp_218->tFFFFFFF0, esp_218->tFFFFFFF4, out ecx_486, out edx_487, out ebx_290, out ebp_289, out esi_488, out edi_489);
			ebx_290->tFFFFFFC8 = eax_288;
			esp_299 = (char *) &esp_218->tFFFFFFFC + 8;
			if (eax_288 != 0x00)
			{
				esp_218->tFFFFFFFC.u0 = 0x00;
				esp_218->tFFFFFFF8.u0 = 0x00;
				esp_218->tFFFFFFF4 = (char *) ebx_290 - 0x0002977B;
				fillin_rpath((char *) ebx_290 - 111675, eax_288, gs);
				Eq_2 eax_349 = ebx_290->tFFFFFFC8;
				if (*eax_349 == 0x00)
				{
					esp_218->tFFFFFFF4 = eax_349;
					word32 edx_491;
					word32 ecx_490;
					free(gs, esp_218->tFFFFFFF0, esp_218->tFFFFFFF4, out ecx_490, out edx_491);
					ebx_290->tFFFFFFC8.u0 = ~0x00;
				}
				ebx_290->dwFFFFFFCC = 0x00;
				return ebp_289->dwFFFFFFF4;
			}
		}
		eax_305 = (char *) ebx_290 - 0x0001AFF8;
l0808B3A7:
		struct Eq_110745 * esp_307 = esp_299 - 4;
		esp_307->t0000 = eax_305;
		esp_307->dwFFFFFFFC = 0x00;
		esp_307->dwFFFFFFF8 = 0x00;
		esp_307->tFFFFFFF4.u0 = 0x0C;
		word32 edi_483;
		word32 ecx_480;
		word32 edx_481;
		word32 ebp_482;
		_dl_signal_error(gs, esp_307->tFFFFFFF4, esp_307->t0000, out ecx_480, out edx_481, out ebx_319, out ebp_482, out edi_483);
		esp_299 = esp_307 - 0x0C;
	}
	eax_305 = (char *) ebx_319 - 110512;
	goto l0808B3A7;
}

// 0808B3C0: Register Eq_2 _dl_map_object(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack ui32 dwArg14, Stack Eq_2 dwArg18, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
// Called from:
//      dl_open_worker
//      openaux
Eq_2 _dl_map_object(Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ui32 dwArg14, Eq_2 dwArg18, ptr32 & ebxOut, ptr32 & ebpOut)
{
	struct Eq_110972 * ebp_1054 = &g_t80CE000;
	Eq_2 esp_18 = fp - 588;
	Eq_2 esi_1059 = dwArg08;
	if (dwArg18 >= 0x00)
	{
		if (dwArg18 < _dl_nns)
		{
			Eq_2 ebx_1252 = *((char *) &g_t80CEA00 + dwArg18 * 0x4C);
			while (ebx_1252 != 0x00)
			{
				word32 eax_76 = (word32) *((word32) ebx_1252 + 0x0199);
				if ((((byte) eax_76 >> 0x05 | (byte) eax_76 >> 0x01) & 0x01) == 0x00)
				{
					word32 ecx_1967;
					if (_dl_name_match_p(dwArg08, ebx_1252, out ecx_1967) != 0x00)
						goto l0808B48F;
					if ((*((word32) ebx_1252 + 0x0199) & 0x01) == 0x00)
					{
						Eq_2 eax_113 = *((word32) ebx_1252 + 88);
						if (eax_113 != 0x00)
						{
							word32 edi_120 = Mem98[eax_113 + 0x04:word32] + Mem98[Mem98[ebx_1252 + 0x34:word32] + 0x04:word32];
							word32 edx_1969;
							word32 ecx_1968;
							if (strcmp(dwArg08, edi_120, out ecx_1968, out edx_1969) == 0x00)
							{
								word32 ebp_1970;
								word32 edi_1971;
								ebx_1252 = add_name_to_object.isra.4(*((word32) ebx_1252 + 28), edi_120, gs, out ebp_1970, out edi_1971);
								*((word32) ebx_1252 + 0x0199) |= 0x01;
								goto l0808B48F;
							}
						}
					}
				}
				ebx_1252 = *((word32) ebx_1252 + 0x0C);
			}
			Eq_2 eax_1060;
			struct Eq_106633 * ebx_1206;
			struct Eq_111040 * esp_1065;
			Eq_2 ebx_214;
			struct Eq_111042 * esp_846;
			word32 * edi_523;
			struct Eq_111040 * esp_1191;
			Eq_2 eax_542;
			ui8 al_508;
			Eq_2 ebx_169 = _dl_debug_mask;
			if (((byte) ebx_169 & 0x40) == 0x00)
			{
				word32 ecx_1960;
				word32 edx_1961;
				if (strchr(dwArg08, 0x2F, out ecx_1960, out edx_1961) != 0x00)
				{
					if (dwArg04 != 0x00)
						goto l0808B4EF;
					goto l0808B59C;
				}
				word32 ecx_1962;
				word32 edx_1963;
				strlen(dwArg08, out ecx_1962, out edx_1963);
				ebx_214 = ebx_169 & 0x01;
				if ((ebx_169 & 0x01) == 0x00)
				{
l0808B688:
					if (dwArg04 != 0x00)
						goto l0808B697;
					goto l0808BC17;
				}
			}
			else if (dwArg04 != 0x00)
			{
				Eq_2 edx_220 = *((word32) dwArg04 + 4);
				ebx_214 = *((word32) dwArg04 + 24);
				if (*edx_220 == 0x00)
				{
					edx_220 = **(union Eq_2 **) 135060900;
					if (edx_220 == 0x00)
						edx_220.u0 = 0x080B2ACB;
				}
				word32 ecx_1979;
				word32 edx_1980;
				_dl_debug_printf(out ecx_1979, out edx_1980);
				dwLoc0260 = edx_220;
				word32 edx_1982;
				word32 ecx_1981;
				if (strchr(dwArg08, 0x2F, out ecx_1981, out edx_1982) != 0x00)
				{
l0808B4EF:
					eax_542 = expand_dynamic_string_token(dwArg04, dwArg08, gs, out ebp_1054, out esi_1059);
					dwLoc0228 = eax_542;
					if (eax_542 == 0x00)
						goto l0808B5B4;
l0808B509:
					word32 edi_1964;
					eax_1060 = open_verify.constprop.7(eax_542, dwArg14, fp - 0x0220, gs, fp - 0x0229, out ebx_1206, out ebp_1054, out esi_1059, out edi_1964);
					if (eax_1060 != ~0x00)
					{
						Eq_2 edx_1345 = 0x00;
						if ((dwArg14 & 0x10000000) == 0x00)
							edx_1345 = dwArg04;
						dwArg04 = edx_1345;
l0808B54B:
						Eq_2 eax_1410 = _dl_map_object_from_fd.constprop.8(esi_1059, ebx_1206, eax_1060, gs, dwLoc0228, dwArg04, dwArg0C, dwArg14, dwArg18);
						ebxOut = ebx;
						ebpOut = ebp;
						return eax_1410;
					}
					word32 ecx_1965;
					word32 edx_1966;
					free(gs, dwLoc0260, dwLoc0228, out ecx_1965, out edx_1966);
l0808B5B4:
					esp_1191 = fp - 588;
					Eq_2 eax_628 = 0x00;
					if ((dwArg14 & 0x10000000) == 0x00)
						eax_628 = dwArg04;
					dwArg04 = eax_628;
l0808B5CE:
					if (esp_1191->dw025C != 0x00 && ((esp_1191->ptr0010)->b0001 & 0x08) == 0x00)
					{
						struct Eq_111248 * esp_1207 = esp_1191 - 0x0C;
						esp_1207->tFFFFFFFC = esi_1059;
						Eq_2 eax_1211 = strdup(esp_1207->tFFFFFFFC);
						edi = eax_1211;
						if (eax_1211 != 0x00)
						{
							esp_1207->t0000 = esp_1207->t0270;
							esp_1207->tFFFFFFFC = esp_1207->t026C;
							esp_1207->dwFFFFFFF8 = esp_1207->dw025C;
							esp_1207->tFFFFFFF4 = esp_1207->t0264;
							esp_1207->tFFFFFFF0 = esi_1059;
							esp_1207->tFFFFFFEC = eax_1211;
							Eq_2 eax_1245 = _dl_new_object(gs, esp_1207->tFFFFFFEC, esp_1207->tFFFFFFF0, esp_1207->tFFFFFFF4, esp_1207->tFFFFFFFC, esp_1207->t0000);
							ebx_1252 = eax_1245;
							if (eax_1245 != 0x00)
							{
								*((word32) eax_1245 + 408) |= 0x0204;
								*((word32) eax_1245 + 400) = (char *) ebp_1054 - 110172;
								*((word32) eax_1245 + 380) = 0x01;
								esp_1207->t0000 = esp_1207->t0270;
								esp_1207->tFFFFFFFC = eax_1245;
								_dl_add_to_namespace_list(esp_1207->tFFFFFFFC, esp_1207->t0000);
l0808B48F:
								ebxOut = ebx;
								ebpOut = ebp;
								return ebx_1252;
							}
						}
l0808BCD9:
						word32 ecx_1974;
						word32 edx_1975;
						free(gs, dwArg0C, edi, out ecx_1974, out edx_1975);
						Eq_2 eax_1274 = (char *) ebp_1054 - 111296;
						ptr32 ebp_1286;
						ptr32 ebx_1287;
						word32 edx_1977;
						word32 edi_1978;
						word32 ecx_1976;
						_dl_signal_error(gs, 0x0C, eax_1274, out ecx_1976, out edx_1977, out ebx_1287, out ebp_1286, out edi_1978);
						Eq_2 eax_1298 = _dl_rtld_di_serinfo(gs, esi_1059, null, (byte) eax_1274);
						ebxOut = ebx_1287;
						ebpOut = ebp_1286;
						return eax_1298;
					}
					if (esp_1191->b0023 != 0x00)
					{
						struct Eq_112147 * esp_849 = esp_1191 - 4;
						esp_849->t0000 = (char *) ebp_1054 - 111630;
						esp_849->dwFFFFFFFC = 0x00;
						esp_849->tFFFFFFF8 = esi_1059;
						esp_849->tFFFFFFF4.u0 = 0x00;
						word32 edi_2004;
						word32 edx_2003;
						word32 ecx_2002;
						_dl_signal_error(gs, esp_849->tFFFFFFF4, esp_849->t0000, out ecx_2002, out edx_2003, out ebx_214, out ebp_1054, out edi_2004);
						esp_1065 = esp_849 - 0x0C;
l0808B7AB:
						if (esp_1065->dw0250 == 0x00)
						{
l0808B7BA:
							esp_1065[3] = (struct Eq_111040) 0x00;
							if ((esp_1065->dw0260 & 0x04000000) != 0x00 && *((union Eq_4846 *) 0x080CDDAC) != 0x00 || _dl_inhibit_cache != 0x00)
							{
l0808B957:
								Eq_2 edx_1093 = esp_1065->dw0250;
								if (edx_1093 == 0x00)
								{
									edx_1093 = *((char *) &g_t80CEA00 + esp_1065[0x0033] *32 0x4C);
									if (edx_1093 == 0x00)
										goto l0808B973;
								}
								if ((*((word32) edx_1093 + 521) & 0x08) != 0x00)
								{
									eax_1060.u0 = ~0x00;
									goto l0808B756;
								}
l0808B973:
								eax_1060.u0 = ~0x00;
								if (ebp_1054->tFFFFFFB4 != ~0x00)
								{
									struct Eq_111915 * esp_1118 = esp_1065 - 0x08;
									esp_1118->ptrFFFFFFFC = (char *) &esp_1118->dw0014 + 23;
									esp_1118->dwFFFFFFF8 = 0x40;
									esp_1118->tFFFFFFF4 = edx_1093;
									esp_1118->ptrFFFFFFF0 = &esp_1118->dw0014 + 8;
									esp_1118->ptrFFFFFFEC = &esp_1118->dw0014 + 6;
									esp_1118->ptrFFFFFFE8 = ebp_1054 - 0x4C;
									Eq_2 esp_1157 = <invalid>;
									word32 ebx_1995;
									word32 edi_1996;
									eax_1060 = open_path(esp_1118->dw0014, gs, esp_1118->ptrFFFFFFE8, out ebx_1995, out ebp_1054, out esi_1059, out edi_1996);
									esp_1065 = (word32) esp_1157 + 32;
								}
								goto l0808B756;
							}
							struct Eq_111772 * esp_976 = esp_1065 - 0x0C;
							esp_976->tFFFFFFFC = esi_1059;
							Eq_2 eax_996 = _dl_load_cache_lookup(ebx_214, gs, esp_976->tFFFFFFFC);
							Eq_2 edi_1005 = eax_996;
							if (eax_996 == 0x00)
								goto l0808B957;
							if (esp_976->ptr025C != null)
							{
								if ((esp_976->ptr025C->b0209 & 0x08) == 0x00)
									goto l0808B81C;
							}
							else if ((*((char *) *esp_976->ptr0010 + 521) & 0x08) == 0x00)
								goto l0808B81C;
							if (*eax_996 == 0x62696C2F && *((word32) eax_996 + 4) == 0x2F || *eax_996 == 0x7273752F && (*((word32) eax_996 + 4) == 0x62696C2F && *((word32) eax_996 + 8) == 0x2F))
								goto l0808B949;
l0808B81C:
							esp_976->dw0000 = 0x00;
							esp_976->tFFFFFFFC = (char *) &esp_976->ptr0010 + 31;
							word32 ebx_1992;
							eax_1060 = open_verify.constprop.7(eax_996, esp_976->dw026C, (char *) &esp_976->t0030 + 8, gs, esp_976->tFFFFFFFC, out ebx_1992, out ebp_1054, out esi_1059, out edi_1005);
							esp_1065 = (struct Eq_111040 *) (&esp_976->dw0000 + 3);
							if (eax_1060 != ~0x00)
							{
								esp_976->t0030 = edi_1005;
								goto l0808B756;
							}
l0808B949:
							struct Eq_111852 * esp_1069 = esp_1065 - 0x0C;
							esp_1069->tFFFFFFFC = edi_1005;
							word32 ecx_1993;
							word32 edx_1994;
							free(gs, esp_1069->tFFFFFFF8, esp_1069->tFFFFFFFC, out ecx_1993, out edx_1994);
							goto l0808B957;
						}
l0808B6FC:
						struct Eq_111548 * eax_876 = esp_1065->dw0250;
						word32 eax_878 = eax_876->dw01EC;
						if (eax_878 == ~0x00)
							goto l0808B7BA;
						if (eax_878 == 0x00)
						{
							struct Eq_111629 * esp_884 = esp_1065 - 0x0C;
							esp_884->ptrFFFFFFFC = (char *) ebp_1054 - 111638;
							esp_1065 = (struct Eq_111040 *) (&esp_884->ptrFFFFFFFC + 4);
							if ((byte) cache_rpath.part.6(esp_884->t025C, 0x1D, &eax_876->dw01EC, gs) == 0x00)
								goto l0808B7BA;
						}
						struct Eq_111650 * esp_910 = esp_1065 - 0x08;
						esp_910->ptrFFFFFFFC = (char *) &esp_910->ptrFFFFFFFC + 47;
						esp_910->dwFFFFFFF8 = 0x04;
						esp_910->dwFFFFFFF4 = esp_910->dw0258;
						esp_910->ptrFFFFFFF0 = &esp_910->ptrFFFFFFFC + 0x0E;
						esp_910->ptrFFFFFFEC = &esp_910->ptrFFFFFFFC + 0x0C;
						esp_910->ptrFFFFFFE8 = &eax_876->dw01EC;
						esp_846 = esp_910 - 24;
l0808B73C:
						Eq_2 esp_948 = <invalid>;
						word32 edi_1991;
						eax_1060 = open_path(esp_846->dw002C, gs, esp_846->ptr0000, out ebx_214, out ebp_1054, out esi_1059, out edi_1991);
						esp_1065 = (word32) esp_948 + 32;
l0808B751:
						if (eax_1060 != ~0x00)
							goto l0808B756;
						goto l0808B7BA;
					}
					struct Eq_112110 * esp_655 = esp_1191 - 4;
					esp_655->t0000 = (char *) ebp_1054 - 0x0001AF10;
					esp_655->dwFFFFFFFC = 0x00;
					esp_655->tFFFFFFF8 = esi_1059;
					esp_655->tFFFFFFF4 = gs->tFFFFFFE0;
					word32 ecx_2000;
					word32 edx_2001;
					_dl_signal_error(gs, esp_655->tFFFFFFF4, esp_655->t0000, out ecx_2000, out edx_2001, out ebx_214, out ebp_1054, out edi_523);
					esp_1065 = esp_655 - 0x0C;
					goto l0808BC43;
				}
				word32 ecx_1987;
				word32 edx_1988;
				strlen(dwArg08, out ecx_1987, out edx_1988);
				if ((_dl_debug_mask & 0x01) == 0x00)
				{
l0808B697:
					esp_1065 = fp - 588;
					if (*((word32) dwArg04 + 0x0094) != 0x00)
					{
						if (g_ptr80CE038 == (word32 *) ~0x00)
							goto l0808B6FC;
						goto l0808B6B5;
					}
					Eq_2 ebx_391 = dwArg04;
					ui32 edi_392 = 0x00;
					do
					{
						word32 * eax_408 = *((word32) ebx_391 + 412);
						word32 * esi_409 = (word32) ebx_391 + 412;
						if (eax_408 != (word32 *) ~0x00)
						{
							if (eax_408 == null)
							{
								struct Eq_112077 * esp_416 = esp_1065 - 0x0C;
								esp_416->dwFFFFFFFC = esp_416->dw0028;
								esp_1065 = (struct Eq_111040 *) (&esp_416->dwFFFFFFFC + 4);
								if ((byte) cache_rpath.part.6(ebx_391, 0x0F, esi_409, gs) == 0x00)
									goto l0808BA37;
							}
							struct Eq_112024 * esp_439 = esp_1065 - 0x08;
							esp_439->dwFFFFFFFC = esp_439->dw0020;
							esp_439->dwFFFFFFF8 = 0x04;
							esp_439->dwFFFFFFF4 = esp_439->dw0258;
							esp_439->ptrFFFFFFF0 = &esp_439->dw0020 + 5;
							esp_439->ptrFFFFFFEC = &esp_439->dw0020 + 3;
							esp_439->ptrFFFFFFE8 = esi_409;
							ui32 edi_466;
							word32 esi_1999;
							eax_1060 = open_path(esp_439->dw0014, gs, esp_439->ptrFFFFFFE8, out ebx_391, out ebp_1054, out esi_1999, out edi_466);
							Eq_2 esp_471 = <invalid>;
							ui24 eax_24_8_483 = SLICE(eax_1060, word24, 8);
							esp_1065 = (word32) esp_471 + 32;
							if (eax_1060 != ~0x00)
							{
								esi_1059 = *((word32) esp_471 + 628);
								goto l0808B756;
							}
							edi_392 = edi_466 | SEQ(eax_24_8_483, (int8) (ebx_391 == *((word32) esp_471 + 52)));
						}
l0808BA37:
						ebx_391 = *((word32) ebx_391 + 368);
					} while (ebx_391 != 0x00);
					esi_1059 = esp_1065->dw0254;
					al_508 = (byte) edi_392 ^ 0x01;
l0808BA84:
					ebx_214 = esp_1065->ptr0014;
					if (ebx_214 == 0x00 || al_508 == 0x00)
						goto l0808BB12;
					word32 eax_515 = (word32) esp_1065->ptr0014->b0198;
					esp_1065[2] = (struct Eq_111040) (byte) eax_515;
					if (((byte) eax_515 & 0x03) == 0x02)
					{
l0808BB12:
						if (ebp_1054->tFFFFFFC8 == ~0x00)
							goto l0808B7AB;
						if (esp_1065->dw0250 == 0x00)
						{
							struct Eq_111704 * esp_828 = esp_1065 - 0x08;
							esp_828->ptrFFFFFFFC = (char *) &esp_828->ptr000C + 31;
							esp_828->dwFFFFFFF8 = 0x02;
							esp_828->dwFFFFFFF4 = *esp_828->ptr000C;
							esp_828->ptrFFFFFFF0 = (char *) &esp_828->ptr000C + 40;
							esp_828->ptrFFFFFFEC = (char *) &esp_828->ptr000C + 32;
							esp_828->ptrFFFFFFE8 = ebp_1054 - 0x38;
							esp_846 = esp_828 - 24;
							goto l0808B73C;
						}
l0808B6B5:
						struct Eq_111558 * esp_780 = esp_1065 - 0x08;
						esp_780->ptrFFFFFFFC = (char *) &esp_780->dw0014 + 23;
						esp_780->dwFFFFFFF8 = 0x02;
						esp_780->dwFFFFFFF4 = esp_780->dw0258;
						esp_780->ptrFFFFFFF0 = &esp_780->dw0014 + 8;
						esp_780->ptrFFFFFFEC = &esp_780->dw0014 + 6;
						esp_780->ptrFFFFFFE8 = ebp_1054 - 0x38;
						Eq_2 esp_816 = <invalid>;
						word32 edi_1990;
						eax_1060 = open_path(esp_780->dw0014, gs, esp_780->ptrFFFFFFE8, out ebx_214, out ebp_1054, out esi_1059, out edi_1990);
						esp_1065 = (word32) esp_816 + 32;
						if (eax_1060 != ~0x00 || *((word32) esp_816 + 624) == 0x00)
							goto l0808B751;
						goto l0808B6FC;
					}
					struct Eq_111448 * eax_522 = esp_1065->ptr0014;
					edi_523 = &eax_522->dw019C;
					word32 eax_524 = eax_522->dw019C;
					if (eax_524 == ~0x00)
						goto l0808BB12;
					if (eax_524 != 0x00)
					{
l0808BAC7:
						struct Eq_111482 * eax_717 = esp_1065->ptr0014;
						if (esp_1065->dw0250 != 0x00)
							eax_717 = esp_1065->dw0250;
						struct Eq_111491 * esp_723 = esp_1065 - 0x08;
						esp_723->ptrFFFFFFFC = (char *) &esp_723->dw0014 + 23;
						esp_723->dwFFFFFFF8 = 0x04;
						esp_723->ptrFFFFFFF4 = eax_717;
						esp_723->ptrFFFFFFF0 = &esp_723->dw0014 + 8;
						esp_723->ptrFFFFFFEC = &esp_723->dw0014 + 6;
						esp_723->ptrFFFFFFE8 = edi_523;
						Eq_2 esp_762 = <invalid>;
						word32 edi_1989;
						eax_1060 = open_path(esp_723->dw0014, gs, esp_723->ptrFFFFFFE8, out ebx_214, out ebp_1054, out esi_1059, out edi_1989);
						esp_1065 = (word32) esp_762 + 32;
						if (eax_1060 != ~0x00)
						{
l0808B756:
							if ((esp_1065->ptr0010->b0000 & 0x01) != 0x00)
							{
								esp_1065->dw0004 = (word32) eax_1060;
								struct Eq_111965 * esp_1176 = esp_1065 - 0x0C;
								esp_1176->ptrFFFFFFFC = (char *) ebp_1054 - 0x0002BD5A;
								word32 ecx_1997;
								word32 edx_1998;
								_dl_debug_printf(out ecx_1997, out edx_1998);
								eax_1060 = esp_1176->t0010;
							}
							esp_1191 = esp_1065;
							word32 edx_1196 = 0x00;
							if (esp_1065->dw0008 == 0x00)
								edx_1196 = esp_1065->dw0250;
							esp_1065->dw0250 = edx_1196;
							if (eax_1060 != ~0x00)
							{
								ebx_1206 = (struct Eq_106633 *) (&esp_1065->dw0024 + 2);
								goto l0808B54B;
							}
							goto l0808B5CE;
						}
						goto l0808BB12;
					}
l0808BC43:
					struct Eq_111462 * esp_681 = esp_1065 - 0x0C;
					esp_681->ptrFFFFFFFC = (char *) ebp_1054 - 111644;
					esp_1065 = (struct Eq_111040 *) (&esp_681->ptrFFFFFFFC + 4);
					if ((byte) cache_rpath.part.6(esp_681->t0020, 0x0F, edi_523, gs) == 0x00)
						goto l0808BB12;
					goto l0808BAC7;
				}
			}
			else
			{
				word32 ecx_1972;
				word32 edx_1973;
				if (strchr(dwArg08, 0x2F, out ecx_1972, out edx_1973) != 0x00)
				{
l0808B59C:
					eax_542 = strdup(dwArg08);
					dwLoc0228 = eax_542;
					if (eax_542 == 0x00)
						goto l0808B5B4;
					goto l0808B509;
				}
				word32 ecx_1983;
				word32 edx_1984;
				strlen(dwArg08, out ecx_1983, out edx_1984);
				ebx_214 = ebx_169 & 0x01;
				if ((ebx_169 & 0x01) == 0x00)
				{
l0808BC17:
					esp_1065 = fp - 588;
					al_508 = 0x01;
					goto l0808BA84;
				}
			}
			word32 edx_1986;
			word32 ecx_1985;
			_dl_debug_printf(out ecx_1985, out edx_1986);
			goto l0808B688;
		}
		word32 ecx_1958;
		word32 edx_1959;
		__assert_fail(out ecx_1958, out edx_1959);
		esp_18.u0 = <invalid>;
	}
	struct Eq_110981 * esp_49 = esp_18 - 4;
	esp_49->ptr0000 = 0x080B313C;
	esp_49->dwFFFFFFFC = 0x0797;
	esp_49->ptrFFFFFFF8 = 134949400;
	esp_49->ptrFFFFFFF4 = 0x080B2BC8;
	word32 edx_1957;
	word32 ecx_1956;
	__assert_fail(out ecx_1956, out edx_1957);
	goto l0808BCD9;
}

// 0808BD00: Register ui32 _dl_rtld_di_serinfo(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_111060) dwArg08, Stack byte bArg0C)
// Called from:
//      _dl_map_object
ui32 _dl_rtld_di_serinfo(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_111060 * dwArg08, byte bArg0C)
{
	byte bLoc34_288 = (byte) dwArg0C;
	if ((byte) dwArg0C != 0x00)
	{
		dwArg08->dw0004 = 0x00;
		dwArg08->dw0000 = 0x00;
	}
	if (*((word32) dwArg04 + 0x0094) == 0x00)
	{
		Eq_2 ebx_103 = dwArg04;
		do
		{
			word32 * edx_58 = *((word32) ebx_103 + 412);
			if (edx_58 != (word32 *) ~0x00)
			{
				if (edx_58 == null)
				{
					if ((byte) cache_rpath.part.6(ebx_103, 0x0F, (word32) ebx_103 + 412, gs) == 0x00)
						goto l0808BE47;
					edx_58 = (word32 *) *((word32) ebx_103 + 412);
				}
				add_path.isra.3.constprop.9(fp - 44, edx_58);
			}
l0808BE47:
			ebx_103 = *((word32) ebx_103 + 368);
		} while (ebx_103 != 0x00);
		if (*((word32) dwArg04 + 24) == 0x00)
		{
			Eq_2 ebx_119 = g_t80CEA00;
			if (ebx_119 == 0x00 || ((*((word32) ebx_119 + 408) & 0x03) == 0x02 || dwArg04 == ebx_119))
				goto l0808BD68;
			word32 * edx_130 = *((word32) ebx_119 + 412);
			if (edx_130 != (word32 *) ~0x00)
			{
				if (edx_130 == null)
				{
					if ((byte) cache_rpath.part.6(ebx_119, 0x0F, (word32) ebx_119 + 412, gs) == 0x00)
						goto l0808BD68;
					edx_130 = (word32 *) *((word32) ebx_119 + 412);
				}
				add_path.isra.3.constprop.9(fp - 44, edx_130);
			}
		}
	}
l0808BD68:
	ui32 eax_180 = add_path.isra.3.constprop.9(fp - 44, g_ptr80CE038);
	word32 * edx_188 = *((word32) dwArg04 + 492);
	if (edx_188 != (word32 *) ~0x00)
	{
		if (edx_188 == null)
		{
			eax_180 = cache_rpath.part.6(dwArg04, 0x1D, (word32) dwArg04 + 492, gs);
			if ((byte) eax_180 == 0x00)
				goto l0808BD8F;
			edx_188 = (word32 *) *((word32) dwArg04 + 492);
		}
		eax_180 = add_path.isra.3.constprop.9(fp - 44, edx_188);
	}
l0808BD8F:
	if ((*((word32) dwArg04 + 521) & 0x08) == 0x00)
		eax_180 = add_path.isra.3.constprop.9(fp - 44, g_ptr80CE04C);
	if (bLoc34_288 != 0x00)
	{
		eax_180 = dwArg08->dw0004 * 0x08 + 0x08;
		dwArg08->dw0000 += eax_180;
	}
	return eax_180;
}

// 0808BF20: Register Eq_2 check_match(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack byte bArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack int32 dwArg10, Stack word32 dwArg14, Stack Eq_2 dwArg18, Stack (ptr32 Eq_2) dwArg1C, Stack (ptr32 word32) dwArg20, Register out Eq_2 ecxOut)
// Called from:
//      do_lookup_x
Eq_2 check_match(Eq_2 eax, Eq_2 ecx, Eq_2 edx, byte bArg04, Eq_2 dwArg08, Eq_2 dwArg0C, int32 dwArg10, word32 dwArg14, Eq_2 dwArg18, union Eq_2 * dwArg1C, word32 * dwArg20, union Eq_2 & ecxOut)
{
	ui32 esi_22 = (word32) *((word32) dwArg0C + 0x0C);
	Eq_2 bp_33 = *((word32) dwArg0C + 0x0E);
	if (*((word32) dwArg0C + 4) == 0x00 && (((byte) esi_22 & 0x0F) != 0x06 && bp_33 != ~0x0E))
	{
l0808C032:
		ecxOut = ecx;
		return 0x00;
	}
	if ((dwArg08 & (uint32) ((int8) (bp_33 == 0x00))) == 0x00 && !__bt(1127, esi_22 & 0x0F))
	{
		if (dwArg0C != edx)
		{
			word32 edx_351;
			if (strcmp((word32) *dwArg0C + dwArg14, eax, out ecx, out edx_351) != 0x00)
				goto l0808C030;
		}
		word16 eax_86[] = *((word32) dwArg18 + 424);
		if (ecx != 0x00)
		{
			if (eax_86 == null)
			{
				Eq_2 eax_126 = *((word32) ecx + 0x0C);
				if (eax_126 != 0x00 && _dl_name_match_p(eax_126, dwArg18, out ecx) != 0x00)
				{
					Eq_2 ecx_165;
					Eq_112492 edx_166;
					Eq_2 eax_164 = __assert_fail(out ecx_165, out edx_166);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 stackArg8 = <invalid>;
					Eq_2 stackArg12 = <invalid>;
					Eq_2 stackArg16 = <invalid>;
					Eq_2 stackArg20 = <invalid>;
					Eq_2 stackArg24 = <invalid>;
					Eq_2 stackArg28 = <invalid>;
					Eq_2 stackArg32 = <invalid>;
					Eq_2 stackArg36 = <invalid>;
					Eq_2 ecx_169;
					Eq_2 eax_168 = do_lookup_x(eax_164, ecx_165, edx_166, gs, stackArg4, stackArg8, stackArg12, stackArg16, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, out ecx_169);
					ecxOut = ecx_169;
					return eax_168;
				}
				goto l0808BFDB;
			}
			ui32 edi_174 = (word32) eax_86[dwArg10];
			struct Eq_112408 * eax_178 = (word32) *((word32) dwArg18 + 372) + ((edi_174 & 0x7FFF) << 0x04);
			ecx = dwArg18;
			ci16 di_209 = (word16) edi_174;
			ui32 ebp_179 = eax_178->dw0004;
			if (ebp_179 == *((word32) ecx + 4))
			{
				word32 edx_352;
				if (strcmp(eax_178->t0000, *ecx, out ecx, out edx_352) == 0x00)
					goto l0808BFDB;
			}
			if ((ebp_179 | *((word32) ecx + 8)) == 0x00 && di_209 >= 0x00)
			{
l0808BFDB:
				ecxOut = ecx;
				return dwArg0C;
			}
		}
		else
		{
			if (eax_86 == null)
				goto l0808BFDB;
			ui32 edx_95 = (word32) eax_86[dwArg10];
			ci16 dx_107 = (word16) edx_95;
			ecx = edx_95 & 0x7FFF;
			if ((edx_95 & 0x7FFF) < (uint32) ((int8) ((bArg04 & 0x02) == 0x00)) + 0x02)
				goto l0808BFDB;
			if (dx_107 >= 0x00)
			{
				word32 eax_113 = *dwArg20;
				*dwArg20 = eax_113 + 0x01;
				if (eax_113 == 0x00)
					*dwArg1C = (union Eq_2 *) dwArg0C;
			}
		}
	}
l0808C030:
	goto l0808C032;
}

// 0808C0C0: Register Eq_2 do_lookup_x(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_112492 rdx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Register out Eq_2 ecxOut)
// Called from:
//      check_match
//      _dl_lookup_symbol_x
Eq_2 do_lookup_x(Eq_2 eax, Eq_2 ecx, Eq_112492 rdx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, union Eq_2 & ecxOut)
{
do_lookup_x_entry:
	def fp
	def eax
	def edx
	def ecx
	def gs
	def dwArg0C
	def dwArg10
	def dwArg1C
	def dwArg20
	def dwArg18
	def dwArg14
	def dwArg04
	def dwArg24
	def dwArg08
	def dwLoc78
	esi_24 = dwArg10
	edi_27 = *((word32) dwArg0C + 4)
	edi_30 = (struct Eq_112535 *) *dwArg0C
	goto l0808C18C
l0808C0C0:
l0808C110:
	dwLoc78_2192 = PHI((dwLoc78_2194, l0808C1BD), (dwLoc78_1302, l0808C1D5))
	ecx_1236 = PHI((ecx_109, l0808C1BD), (ecx_117, l0808C1D5))
	Mem122 = PHI((Mem50, l0808C1BD), (Mem94, l0808C1D5))
	eax_123 = *((word32) ebp_42 + 380)
	branch eax_123 == 0x00 l0808C17F
l0808C11E:
	eax_129 = *((word32) ebp_42 + 56)
	ecx_130 = *((word32) ebp_42 + 0x0188)
	eax_133 = (Eq_151584 (*)[]) *((word32) eax_129 + 4)
	eax_135 = *((word32) ebp_42 + 52)
	eax_136 = (word32) *((word32) eax_135 + 4)
	branch ecx_130 == 0x00 l0808C218
l0808C150:
	eax_276 = edx >> 0x05 & *((word32) ebp_42 + 384)
	eax_277 = (uint32) *((word32) ecx_130 + eax_276 * 0x04)
	ecx_278 = (word32) *((word32) ebp_42 + 388)
	cl_280 = (byte) ecx_278
	edx_281 = edx >> cl_280
	cl_284 = (byte) edx_281
	edx_285 = eax_277 >> cl_284
	ecx_286 = edx
	cl_287 = (byte) edx
	eax_288 = eax_277 >> cl_287
	eax_289 = eax_288 & edx_285
	al_290 = (byte) eax_289
	branch (al_290 & 0x01) != 0x00 l0808C320
l0808C17F:
	dwLoc78_2196 = PHI((dwLoc78_2194, l0808C18C), (dwLoc78_2194, l0808C1AB), (dwLoc78_2194, l0808C1B4), (dwLoc78_2192, l0808C110), (dwLoc78_2192, l0808C150), (dwLoc78_2192, l0808C227), (dwLoc78_2192, l0808C320), (dwLoc78_2187, l0808C2F1), (dwLoc78_2187, l0808C53E), (dwLoc78_2187, l0808C54C), (dwLoc78_2189, l0808C698), (dwLoc78_2189, l0808C6AF), (dwLoc78_2200, l0808CA35))
	ecx_1235 = PHI((ecx_109, l0808C18C), (ecx_109, l0808C1AB), (ecx_109, l0808C1B4), (ecx_1236, l0808C110), (ecx_286, l0808C150), (ecx_1237, l0808C227), (ecx_286, l0808C320), (ecx_560, l0808C2F1), (ecx_560, l0808C53E), (ecx_560, l0808C54C), (ecx_1238, l0808C698), (ecx_384, l0808C6AF), (ecx_1241, l0808CA35))
	Mem1207 = PHI((Mem40, l0808C18C), (Mem50, l0808C1AB), (Mem50, l0808C1B4), (Mem125, l0808C110), (Mem137, l0808C150), (Mem198, l0808C227), (Mem137, l0808C320), (Mem561, l0808C2F1), (Mem561, l0808C53E), (Mem587, l0808C54C), (Mem381, l0808C698), (Mem381, l0808C6AF), (Mem548, l0808CA35))
	esi_1205 = (word32) esi_39 + 1
	branch edi_27 <= esi_1205 l0808C3D0
l0808C18C:
	dwLoc78_2194 = PHI((dwLoc78, l0808C0C0), (dwLoc78_2196, l0808C17F))
	ecx_109 = PHI((ecx, l0808C0C0), (ecx_1235, l0808C17F))
	Mem40 = PHI((Mem37, l0808C0C0), (Mem1207, l0808C17F))
	esi_39 = PHI((esi_24, l0808C0C0), (esi_1205, l0808C17F))
	eax_41 = (struct Eq_112553 *) edi_30[esi_39 * 0x04]
	ebp_42 = eax_41->t0014
	branch ebp_42 == dwArg1C l0808C17F
l0808C19B:
	branch (dwArg20 & 0x02) == 0x00 l0808C1B4
l0808C1AB:
	branch (*((word32) ebp_42 + 408) & 0x03) == 0x00 l0808C17F
l0808C1B4:
	branch (*((word32) ebp_42 + 0x0199) & 0x20) != 0x00 l0808C17F
l0808C1BD:
	branch (_dl_debug_mask & 0x08) == 0x00 l0808C110
l0808C1CA:
	eax_65 = (byte *) *((word32) ebp_42 + 4)
	branch *eax_65 == 0x00 l0808C1F8
l0808C1D5:
	dwLoc78_1302 = eax
	_dl_debug_printf(out ecx_117, out edx_2371)
	goto l0808C110
l0808C1F8:
	eax_72 = *(union Eq_2 **) 135060900
	eax_73 = *eax_72
	goto l0808C1D5
l0808C218:
	eax_142 = *ecx
	branch eax_142 == ~0x00 l0808C7DD
l0808C227:
	ecx_1237 = PHI((ecx_130, l0808C218), (ecx_189, l0808C83F))
	Mem198 = PHI((Mem137, l0808C218), (Mem192, l0808C83F))
	eax_194 = PHI((eax_142, l0808C218), (eax_191, l0808C83F))
	edx_eax_195 = (uint64) eax_194
	edx_199 = (uint32) (edx_eax_195 % eax_123)
	eax_204 = (int32 (*)[]) *((word32) ebp_42 + 400)
	ebx_205 = eax_204[edx_199]
	branch ebx_205 == 0x00 l0808C17F
	goto l0808C269
l0808C258:
	eax_263 = (union Eq_112718 *) *((word32) ebp_42 + 396)
	ebx_264 = *((char *) eax_263 + ebx_223 * 0x04)
	branch ebx_264 == 0x00 l0808C690
l0808C269:
	ebx_223 = PHI((ebx_205, l0808C23E), (ebx_264, l0808C258))
	eax_229 = ebx_223 << 0x04
	dwLoc78_1334 = ebp_42
	eax_241 = &(eax_133 + eax_229 / 16)->dw0000
	eax_255 = check_match(eax, dwArg14, dwArg04, (byte) dwArg18, dwArg20, eax_241, ebx_223, eax_136, ebp_42, fp - 0x20, fp - 0x24, out ecx_257)
	branch eax_255 == 0x00 l0808C258
l0808C2A7:
	ecx_272 = eax_255
l0808C2B8:
	dwLoc78_2188 = PHI((dwLoc78_1334, l0808C2A7), (dwLoc78_1366, l0808CA22), (dwLoc78_2189, l0808C6A3))
	ecx_424 = PHI((ecx_272, l0808C2A7), (ecx_364, l0808CA22), (ecx_384, l0808C6A3))
	Mem389 = PHI((Mem250, l0808C2A7), (Mem351, l0808CA22), (Mem381, l0808C6A3))
	branch dwArg24 == 0x00 l0808C3E0
l0808C2F1:
	branch al_568 >> 0x04 != 0x01 l0808C17F
l0808C2FD:
	ecx_2239 = PHI((ecx_560, l0808C2F9), (ecx_1100, l0808C754), (ecx_1269, l0808C734))
	*((word32) dwArg08 + 4) = ebp_42
	*dwArg08 = ecx_424
l0808C30A:
	ecx_2238 = PHI((ecx_1174, l0808C66E), (ecx_2239, l0808C2FD), (ecx_1123, l0808C65C))
	eax_1194.u0 = 0x01
	ecxOut = ecx_2238
	return eax_1194
l0808C320:
	edx_eax_296 = (uint64) edx
	edx_298 = (uint32) (edx_eax_296 % eax_123)
	eax_300 = (union Eq_112718 *) *((word32) ebp_42 + 396)
	eax_301 = *((char *) eax_300 + edx_298 * 0x04)
	branch eax_301 == 0x00 l0808C17F
l0808C339:
	edx_305 = (int32 (*)[]) *((word32) ebp_42 + 400)
	ecx_306 = fp - 0x20
	ebx_310 = (word32 *) (edx_305 + eax_301)
	goto l0808C36B
l0808C360:
	dwLoc78_2190 = PHI((dwLoc78_2191, l0808C36B), (dwLoc78_1366, l0808C3C3))
	ecx_1239 = PHI((ecx_1240, l0808C36B), (ecx_358, l0808C3C3))
	Mem377 = PHI((Mem315, l0808C36B), (Mem351, l0808C3C3))
	al_370 = PHI((al_371, l0808C36B), (al_372, l0808C3C3))
	ebx_369 = ebx_314 + 1
	branch (al_370 & 0x01) != 0x00 l0808C84C
l0808C36B:
	dwLoc78_2191 = PHI((dwLoc78_2192, l0808C339), (dwLoc78_2190, l0808C360))
	ecx_1240 = PHI((ecx_306, l0808C339), (ecx_1239, l0808C360))
	Mem315 = PHI((Mem312, l0808C339), (Mem377, l0808C360))
	ebx_314 = PHI((ebx_310, l0808C339), (ebx_369, l0808C360))
	eax_316 = *ebx_314
	al_371 = (byte) eax_316
	edx_319 = eax_316 ^ edx
	branch edx_319 >> 0x01 != 0x00 l0808C360
l0808C375:
	eax_325 = ebx_314 - *((word32) ebp_42 + 400)
	dwLoc78_1366 = ebp_42
	eax_341 = eax_325 >> 0x02 << 0x04
	eax_342 = &(eax_133 + eax_341 / 16)->dw0000
	eax_356 = check_match(eax, dwArg14, dwArg04, (byte) dwArg18, dwArg20, eax_342, eax_325 >> 0x02, eax_136, ebp_42, fp - 0x20, fp - 0x24, out ecx_358)
	branch eax_356 != 0x00 l0808CA22
l0808C3C3:
	eax_367 = *ebx_314
	al_372 = (byte) eax_367
	goto l0808C360
l0808C3D0:
	eax_1211.u0 = 0x00
	ecxOut = ecx_1235
	return eax_1211
l0808C3ED:
	branch dwArg20 != 0x04 l0808C2C7
	eax_402 = *((word32) ebp_42 + 60)
	branch eax_402 == 0x00 l0808C49C
	goto l0808C406
l0808C3FB:
l0808C406:
	edx_406 = *((word32) ebp_42 + 64)
	branch edx_406 == 0x00 l0808C49C
l0808C411:
	ebx_410 = (uint32) *((word32) edx_406 + 4)
	branch ebx_410 == 0x00 l0808C49C
l0808C41C:
	eax_414 = (struct Eq_113443 *) *((word32) eax_402 + 4)
	edx_419 = SLICE(ebx_410 *64 ~0x55555554, word32, 32)
	branch ebx_410 <= 11 l0808C49C
l0808C436:
	ebx_426 = 0x00
	edi_432 = eax_414
l0808C44A:
	dwLoc78_2203 = PHI((dwLoc78_2188, l0808C436), (dwLoc78_2202, l0808C486))
	ebx_473 = PHI((ebx_426, l0808C436), (ebx_474, l0808C486))
	Mem438 = PHI((Mem435, l0808C436), (Mem482, l0808C486))
	edi_437 = PHI((edi_432, l0808C436), (edi_476, l0808C486))
	eax_439 = edi_437->dw0004
	al_440 = (byte) eax_439
	edx_441 = (word32) al_440
	branch edx_441 <= 0x25 l0808C486
l0808C458:
	branch edx_441 != 0x05 l0808C486
l0808C45D:
	dwLoc78_1419 = eax
	ecx_456 = eax_136 + (eax_133)[eax_439 >> 0x08].dw0000
	eax_460 = strcmp(ecx_456, eax, out ecx_461, out edx_2382)
	branch eax_460 == 0x00 l0808CA31
l0808C486:
	dwLoc78_2202 = PHI((dwLoc78_2203, l0808C458), (dwLoc78_1419, l0808C45D), (dwLoc78_2203, l0808C44A))
	Mem482 = PHI((Mem438, l0808C458), (Mem459, l0808C45D), (Mem438, l0808C44A))
	ebx_474 = ebx_473 + 0x01
	edi_476 = &edi_437->dw0004 + 2
	branch edx_419 >> 0x03 > ebx_474 l0808C44A
l0808C49C:
	dwLoc78_2201 = PHI((dwLoc78_2188, l0808C3FB), (dwLoc78_2188, l0808C406), (dwLoc78_2188, l0808C411), (dwLoc78_2188, l0808C41C), (dwLoc78_2202, l0808C490))
	Mem489 = PHI((Mem389, l0808C3FB), (Mem389, l0808C406), (Mem389, l0808C411), (Mem416, l0808C41C), (Mem482, l0808C490))
	edx_490 = *((word32) ebp_42 + 100)
	branch edx_490 == 0x00 l0808C2C7
	eax_494 = *((word32) ebp_42 + 0x0068)
	branch eax_494 == 0x00 l0808C2C7
	eax_498 = (uint32) *((word32) eax_494 + 4)
	branch eax_498 == 0x00 l0808C2C7
	ebx_504 = (struct Eq_113657 *) *((word32) edx_490 + 4)
	branch eax_498 >> 0x03 == 0x00 l0808C2C7
	eax_509 = ebx_504 + (eax_498 >> 0x03)
	goto l0808C4D6
l0808C4A7:
l0808C4B2:
l0808C4BD:
l0808C4C9:
l0808C4D6:
	dwLoc78_2205 = PHI((dwLoc78_2201, l0808C4C9), (dwLoc78_2204, l0808C512))
	Mem514 = PHI((Mem511, l0808C4C9), (Mem557, l0808C512))
	ebx_513 = PHI((ebx_504, l0808C4C9), (ebx_551, l0808C512))
	eax_515 = ebx_513->dw0004
	al_516 = (byte) eax_515
	edx_517 = (word32) al_516
	branch edx_517 <= 0x25 l0808C512
l0808C4E4:
	branch edx_517 != 0x05 l0808C512
l0808C4E9:
	dwLoc78_1432 = eax
	ecx_532 = eax_136 + (eax_133)[eax_515 >> 0x08].dw0000
	eax_536 = strcmp(ecx_532, eax, out ecx_537, out edx_2383)
	branch eax_536 == 0x00 l0808CA35
l0808C512:
	dwLoc78_2204 = PHI((dwLoc78_2205, l0808C4E4), (dwLoc78_1432, l0808C4E9), (dwLoc78_2205, l0808C4D6))
	Mem557 = PHI((Mem514, l0808C4E4), (Mem535, l0808C4E9), (Mem514, l0808C4D6))
	ebx_551 = &ebx_513->dw0004 + 1
	branch ebx_551 != eax_509 l0808C4D6
l0808C519:
l0808C53E:
	ebx_579 = *dwArg08
	branch ebx_579 != 0x00 l0808C17F
l0808C54C:
	*dwArg08 = ecx_424
	*((word32) dwArg08 + 4) = ebp_42
	goto l0808C17F
l0808C57D:
	dwLoc7C_1498 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
l0808C5A0:
	Mem626 = PHI((Mem608, l0808C57D), (Mem599, l0808C7C7))
	esi_628 = eax_590 *s 0x4C + 0x080CEA00
	eax_629 = esi_628->t0028
	ecx_630 = esi_628->t002C
	dwLoc50_1514 = eax_629
	branch eax_629 == 0x00 l0808C98F
l0808C5BB:
	edx_eax_692 = (uint64) edx
	edx_694 = (uint32) (edx_eax_692 % ecx_630)
	edx_eax_699 = (uint64) edx
	edx_701 = (uint32) (edx_eax_699 % (ecx_630 - 0x02))
	esi_704 = edx_694
	dwLoc3C_1539 = edx_701 + 0x01
	edx_710 = edx_701 + 0x01 << 0x04
l0808C5EE:
	dwLoc78_2185 = PHI((dwLoc78_2187, l0808C5BB), (dwLoc78_2184, l0808C7C0))
	Mem716 = PHI((Mem707, l0808C5BB), (Mem1251, l0808C7C0))
	esi_712 = PHI((esi_704, l0808C5BB), (esi_1138, l0808C7C0))
	ebx_714 = esi_712 << 0x04
	ebx_717 = (word32) eax_629 + ebx_714
	goto l0808C614
l0808C600:
	branch eax_721 == 0x00 l0808C6B8
l0808C608:
	dwLoc78_2184 = PHI((dwLoc78_1778, l0808C61B), (dwLoc78_1547, l0808C600))
	Mem1251 = PHI((Mem1114, l0808C61B), (Mem720, l0808C600))
	esi_1131 = (word32) esi_1129 + (edx_701 + 0x01)
	ebx_1134 = ebx_719 + edx_710 / 16
	branch ecx_630 <= esi_1131 l0808C7C0
l0808C614:
	dwLoc78_1547 = PHI((dwLoc78_2184, l0808C608), (dwLoc78_2185, l0808C5EE))
	esi_1129 = PHI((esi_1131, l0808C608), (esi_712, l0808C5EE))
	Mem720 = PHI((Mem1251, l0808C608), (Mem716, l0808C5EE))
	ebx_719 = PHI((ebx_1134, l0808C608), (ebx_717, l0808C5EE))
	eax_721 = ebx_719->t0004
	branch edx != ebx_719->t0000 l0808C600
l0808C61B:
	dwLoc78_1778 = eax
	eax_1115 = strcmp(eax_721, eax, out ecx_2376, out edx_2377)
	ecx_1123 = edx_701 + 0x01
	branch eax_1115 != 0x00 l0808C608
l0808C63F:
	branch (dwArg20 & 0x02) == 0x00 l0808CA0E
l0808C64F:
	*((word32) dwArg08 + 4) = ebp_42
	*dwArg08 = ecx_424
l0808C65C:
	goto l0808C30A
l0808C66E:
	eax_1165 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
	goto l0808C30A
l0808C698:
	dwLoc78_2189 = PHI((dwLoc78_2190, l0808C84C), (dwLoc78_1334, l0808C690))
	ecx_1238 = PHI((ecx_1239, l0808C84C), (ecx_257, l0808C690))
	Mem381 = PHI((Mem377, l0808C84C), (Mem250, l0808C690))
	goto l0808C17F
l0808C6A3:
	ecx_384.u0 = 0x00
	goto l0808C17F
l0808C6AF:
l0808C6B8:
	ecx_732 = ecx_630
	edi_735 = edx_694
	eax_736 = (ui32) g_a80CEA30[eax_590]
	branch ecx_630 * 0x03 <= eax_736 << 0x02 l0808C859
l0808C6DD:
	dwLoc78_2351 = PHI((dwLoc78_1515, l0808C9B0), (dwLoc78_1547, l0808C6B8), (dwLoc78_1548, l0808C938))
	dwLoc50_2222 = PHI((dwLoc50_1520, l0808C9B0), (dwLoc50_1514, l0808C6B8), (dwLoc50_1642, l0808C938))
	dwLoc3C_1651 = PHI((dwLoc3C_1536, l0808C9B0), (dwLoc3C_1539, l0808C6B8), (dwLoc3C_1641, l0808C938))
	ecx_1269 = PHI((ecx_658, l0808C9B0), (ecx_732, l0808C6B8), (ecx_964, l0808C938))
	edi_1265 = PHI((edi_676, l0808C9B0), (edi_735, l0808C6B8), (edi_974, l0808C938))
	Mem987 = PHI((Mem686, l0808C9B0), (Mem720, l0808C6B8), (Mem985, l0808C938))
	ebx_991 = (word32) *ecx_424 + eax_136
	branch (dwArg20 & 0x02) == 0x00 l0808C76B
l0808C6F8:
	edi_1040 = PHI((edi_1265, l0808C6DD), (edi_1059, l0808C7D6))
	eax_1042 = edi_1040 << 0x04
	eax_1045 = (word32) dwLoc50_2222 + eax_1042
	goto l0808C714
l0808C708:
	edi_1053 = (word32) edi_1051 + dwLoc3C_1651
	eax_1055 = eax_1047 + (dwLoc3C_1651 << 0x04) / 16
	branch ecx_1269 <= edi_1053 l0808C7D6
l0808C714:
	edi_1051 = PHI((edi_1040, l0808C6F8), (edi_1053, l0808C708))
	eax_1047 = PHI((eax_1045, l0808C6F8), (eax_1055, l0808C708))
	branch eax_1047->dw0004 != 0x00 l0808C708
l0808C71A:
	eax_1047->dw0004 = ebx_991
	eax_1047->t0000 = edx
	eax_1047->t0008 = dwArg04
	eax_1047->t000C = dwArg24
l0808C734:
	Mem1072 = PHI((Mem1070, l0808C71A), (Mem1030, l0808C78E), (Mem1037, l0808C7AF))
	v31_1077 = (word32) ((word608) g_a80CEA30[eax_590] + 1)
	g_a80CEA30[eax_590] = (struct Eq_151581) v31_1077
	goto l0808C2FD
l0808C754:
	eax_1084 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
	goto l0808C2FD
l0808C769:
	edi_1017 = edi_1011 - ecx_1269
l0808C76B:
	edi_998 = PHI((edi_1265, l0808C6DD), (edi_1017, l0808C769))
	eax_1000 = edi_998 << 0x04
	eax_1003 = (word32) dwLoc50_2222 + eax_1000
	goto l0808C788
l0808C780:
	edi_1011 = (word32) edi_1009 + dwLoc3C_1651
	eax_1013 = eax_1005 + (dwLoc3C_1651 << 0x04) / 16
	branch ecx_1269 <= edi_1011 l0808C769
l0808C788:
	edi_1009 = PHI((edi_998, l0808C76B), (edi_1011, l0808C780))
	eax_1005 = PHI((eax_1003, l0808C76B), (eax_1013, l0808C780))
	branch eax_1005->dw0004 != 0x00 l0808C780
l0808C78E:
	eax_1005->dw0004 = ebx_991
	eax_1005->t000C = ebp_42
	eax_1005->t0000 = edx
	eax_1005->t0008 = ecx_424
	eax_1031 = (word32) *((word32) ebp_42 + 408)
	al_1033 = (byte) eax_1031 & 0x03
	branch al_1033 != 0x02 l0808C734
l0808C7AF:
	v32_1036 = *((word32) ebp_42 + 520) | 0x08
	*((word32) ebp_42 + 520) = v32_1036
	goto l0808C734
l0808C7C0:
	esi_1138 = esi_1131 - ecx_630
	goto l0808C5EE
l0808C7C7:
	goto l0808C5A0
l0808C7D6:
	edi_1059 = edi_1053 - ecx_1269
	goto l0808C6F8
l0808C7DD:
	edx_145 = ecx_130
	ecx_147 = (word32) *eax
	branch ecx_147 == 0x00 l0808C83F
l0808C7EA:
	edx_151 = ecx_147
	ecx_152 = (word32) *((word32) eax + 1)
	branch ecx_152 == 0x00 l0808C83F
l0808C7F2:
	edx_154 = (ecx_147 << 0x04) + ecx_152
	ecx_156 = (word32) *((word32) eax + 2)
	branch ecx_156 == 0x00 l0808C83F
l0808C7FD:
	edx_158 = (edx_154 << 0x04) + ecx_156
	ecx_160 = (word32) *((word32) eax + 3)
	branch ecx_160 == 0x00 l0808C83F
l0808C808:
	edx_162 = (edx_158 << 0x04) + ecx_160
	ecx_164 = (word32) *((word32) eax + 4)
	branch ecx_164 == 0x00 l0808C83F
l0808C813:
	eax_166 = (word32) eax + 5
	edx_167 = (edx_162 << 0x04) + ecx_164
	ecx_169 = (word32) *((word32) eax + 5)
	branch ecx_169 == 0x00 l0808C83F
l0808C820:
	ecx_175 = PHI((ecx_169, l0808C813), (ecx_181, l0808C820))
	eax_173 = PHI((eax_166, l0808C813), (eax_174, l0808C820))
	edx_170 = PHI((edx_167, l0808C813), (edx_182, l0808C820))
	edx_171 = edx_170 << 0x04
	eax_174 = eax_173 + 1
	edx_176 = edx_171 + ecx_175
	ebx_179 = (edx_176 & 0xF0000000) >> 0x18
	ecx_181 = (word32) *eax_174
	edx_182 = edx_176 & 0x0FFFFFFF ^ ebx_179
	branch ecx_181 != 0x00 l0808C820
l0808C83F:
	edx_190 = PHI((edx_145, l0808C7DD), (edx_151, l0808C7EA), (edx_154, l0808C7F2), (edx_158, l0808C7FD), (edx_162, l0808C808), (edx_167, l0808C813), (edx_182, l0808C820))
	ecx_189 = ecx
	eax_191 = edx_190
	*ecx = edx_190
	goto l0808C227
l0808C859:
	eax_746 = _dl_higher_prime_number((word32) ecx_630 + 1)
	dwLoc78_1548 = eax_746
	eax_764 = __libc_calloc(gs, 0x10, eax_746, out ecx_766, out edx_765, out ebx_2378, out ebp_2379, out esi_2380, out edi_2381)
	branch eax_764 == 0x00 l0808CA3E
l0808C888:
	ecx_845 = ecx_630
	edi_850 = eax_629
	eax_852 = (word32) eax_629 + (ecx_630 << 0x04)
	branch ecx_630 == 0x00 l0808C938
	goto l0808C8C1
l0808C8B8:
	ecx_949 = PHI((ecx_950, l0808C8C1), (ecx_918, l0808C90E))
	edx_946 = PHI((edx_947, l0808C8C1), (edx_885, l0808C90E))
	eax_943 = PHI((eax_944, l0808C8C1), (eax_896, l0808C90E))
	Mem925 = PHI((Mem859, l0808C8C1), (Mem919, l0808C90E))
	edi_923 = (word32) edi_858 + 16
	branch eax_852 == edi_923 l0808C934
l0808C8C1:
	ecx_950 = PHI((ecx_845, l0808C8AC), (ecx_949, l0808C8B8))
	edx_947 = PHI((edx_765, l0808C8AC), (edx_946, l0808C8B8))
	eax_944 = PHI((eax_852, l0808C8AC), (eax_943, l0808C8B8))
	Mem859 = PHI((Mem857, l0808C8AC), (Mem925, l0808C8B8))
	edi_858 = PHI((edi_850, l0808C8AC), (edi_923, l0808C8B8))
	ebx_860 = (word32) *((word32) edi_858 + 4)
	branch ebx_860 == 0x00 l0808C8B8
l0808C8C8:
	eax_864 = *((word32) edi_858 + 0x0C)
	eax_868 = (word32) *((word32) edi_858 + 8)
	eax_870 = (word32) *edi_858
	edx_eax_873 = (uint64) eax_870
	edx_876 = (uint32) (edx_eax_873 % eax_746)
	ecx_879 = edx_876
	edx_eax_881 = (uint64) eax_870
	edx_883 = (uint32) (edx_eax_881 % (eax_746 - 0x02))
	edx_885 = edx_883 + 0x01
	ebp_887 = edx_883 + 0x01 << 0x04
l0808C8F4:
	ecx_889 = PHI((ecx_879, l0808C8C8), (ecx_908, l0808C930))
	eax_891 = ecx_889 << 0x04
	eax_894 = (word32) eax_764 + eax_891
	goto l0808C908
l0808C900:
	ecx_902 = (word32) ecx_900 + (edx_883 + 0x01)
	eax_904 = (word32) eax_896 + ebp_887
	branch eax_746 <= ecx_902 l0808C930
l0808C908:
	ecx_900 = PHI((ecx_902, l0808C900), (ecx_889, l0808C8F4))
	eax_896 = PHI((eax_904, l0808C900), (eax_894, l0808C8F4))
	branch *((word32) eax_896 + 4) != 0x00 l0808C900
l0808C90E:
	*((word32) eax_896 + 4) = ebx_860
	*eax_896 = eax_870
	*((word32) eax_896 + 8) = eax_868
	ecx_918 = eax_864
	*((word32) eax_896 + 0x0C) = eax_864
	goto l0808C8B8
l0808C930:
	ecx_908 = ecx_902 - eax_746
	goto l0808C8F4
l0808C938:
	ecx_948 = PHI((ecx_845, l0808C888), (ecx_949, l0808C934))
	edx_945 = PHI((edx_765, l0808C888), (edx_946, l0808C934))
	eax_942 = PHI((eax_852, l0808C888), (eax_943, l0808C934))
	ebx_933 = eax_590 *s 0x4C + 0x080CEA00
	ebx_933->ptr0034()
	ebx_933->t002C = eax_746
	ecx_964 = eax_746
	ebx_933->t0028 = eax_764
	ebx_933->ptr0034 = &g_t805D820
	edx_eax_969 = (uint64) edx
	edx_971 = (uint32) (edx_eax_969 % eax_746)
	edi_974 = edx_971
	edx_eax_976 = (uint64) edx
	edx_978 = (uint32) (edx_eax_976 % (eax_746 - 0x02))
	dwLoc3C_1641 = edx_978 + 0x01
	dwLoc50_1642 = eax_764
	goto l0808C6DD
l0808C98F:
	dwLoc78_1515.u0 = 0x1F
	eax_646 = __libc_calloc(gs, 0x10, 0x1F, out ecx_648, out edx_647, out ebx_2372, out ebp_2373, out esi_2374, out edi_2375)
	dwLoc50_1520 = eax_646
	branch eax_646 == 0x00 l0808CA3E
l0808C9B0:
	esi_628->t0028 = eax_646
	ecx_658.u0 = 0x1F
	esi_628->t002C.u0 = 0x1F
	esi_628->dw0034 = 0x0805D820
	edx_665 = SLICE(edx *64 138547333, word32, 32)
	eax_666 = edx - edx_665
	edi_669 = (eax_666 >> 0x01) + edx_665
	eax_673 = edi_669 >> 0x04 << 0x05
	eax_674 = eax_673 - (edi_669 >> 0x04)
	edi_676 = edx - eax_674
	edx_679 = SLICE(edx *64 2369637129, word32, 32)
	eax_681 = (edx_679 >> 0x04) *s 0x1D
	esi_682 = edx - eax_681
	dwLoc3C_1536 = esi_682 + 0x01
	goto l0808C6DD
l0808CA0E:
	eax_1145 = ebx_719->t0008
	*dwArg08 = eax_1145
	eax_1148 = ebx_719->t000C
	*((word32) dwArg08 + 4) = eax_1148
	goto l0808C65C
l0808CA22:
	ecx_364 = eax_356
	goto l0808C2B8
l0808CA35:
	dwLoc78_2200 = eax
	ecx_1241 = PHI((ecx_461, l0808CA31), (ecx_537, l0808C4E9))
	Mem548 = PHI((Mem459, l0808CA31), (Mem535, l0808C4E9))
	goto l0808C17F
l0808CA3E:
	dwLoc78_2285 = PHI((dwLoc78_1515, l0808C98F), (dwLoc78_1548, l0808C859))
	ecx_788 = PHI((ecx_648, l0808C98F), (ecx_766, l0808C859))
	edx_787 = PHI((edx_647, l0808C98F), (edx_765, l0808C859))
	Mem774 = PHI((Mem650, l0808C98F), (Mem768, l0808C859))
	branch _dl_tls_static_size == 0x00 l0808CA64
l0808CA4B:
	eax_782 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
l0808CA64:
	_dl_dprintf()
	_exit(gs, 0x7F)
do_lookup_x_exit:
}

// 0808CA90: Register word32 _dl_lookup_symbol_x(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_113724) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      do_lookup_x
//      _dl_lookup_symbol_x
//      _dl_relocate_object
//      do_dlsym_private
//      do_dlsym
//      do_dlvsym
//      _dl_fixup
//      _dl_profile_fixup
//      _dl_tlsdesc_resolve_rel_fixup
//      _dl_tlsdesc_resolve_rela_fixup
//      call_dl_lookup
//      _dl_sym
word32 _dl_lookup_symbol_x(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_113724 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_112492 ebx_26;
	word32 eax_21 = (word32) *dwArg04;
	word32 * esp_18 = fp - 0x5C;
	if ((byte) eax_21 != 0x00)
	{
		Eq_2 edx_27 = dwArg04;
		ebx_26.u0 = 0x1505;
		do
		{
			edx_27 = (word32) edx_27 + 1;
			eax_21 = (word32) *edx_27;
			ebx_26 = ebx_26 * 33 + eax_21;
		} while ((byte) eax_21 != 0x00);
	}
	else
		ebx_26.u0 = 0x1505;
	ptr32 edx_1456;
	ptr32 eax_1454;
	struct Eq_113762 * esp_169;
	Eq_2 ecx_182;
	Eq_2 esi_131 = dwArg14;
	if (dwArg14 != 0x00 && (dwArg1C & ~0x05) != 0x00)
	{
l0808D367:
		word32 edi_248 = *esp_18;
		struct Eq_113787 * esp_250 = esp_18 - 4;
		esp_250->dw0000 = edi_248 + ~0x0001AC6F;
		esp_250->dwFFFFFFFC = 799;
		esp_250->dwFFFFFFF8 = edi_248 + ~0x0001AE57;
		esp_250->dwFFFFFFF4 = edi_248 + ~0x0001AD87;
		word32 edx_2719;
		word32 ecx_2718;
		__assert_fail(out ecx_2718, out edx_2719);
		esp_169 = esp_250 - 0x0C;
		goto l0808D389;
	}
	Eq_2 dwLoc58_1497;
	Eq_2 ecx_115 = dwArg20;
	Eq_2 eax_120 = *dwArg10;
	Eq_2 edx_126 = *dwArg0C;
	if (dwArg20 == 0x00)
	{
		if (eax_120 == 0x00)
			goto l0808CCD0;
	}
	else
	{
		struct Eq_113817 * ecx_66 = *eax_120;
		if (dwArg20 != (ecx_66->a0000)[0])
		{
			Eq_2 esi_74 = 0x00;
			do
				esi_74 = (word32) esi_74 + 1;
			while (ecx_66[esi_74 * 0x04] != dwArg20);
			dwLoc58_1497 = esi_74;
l0808CB29:
			ecx_115 = dwLoc58_1497;
			esi_131 = dwArg10;
			do
			{
				if (do_lookup_x(dwArg04, fp - 0x34, ebx_26, gs, edx_126, fp - 0x30, eax_120, ecx_115, dwArg14, dwArg1C, dwArg20, dwArg18, dwArg08, out ecx_115) != 0x00)
				{
					edx_126 = *dwArg0C;
					break;
				}
				esi_131 = (word32) esi_131 + 4;
				eax_120 = *esi_131;
				ecx_115.u0 = 0x00;
				edx_126 = *dwArg0C;
			} while (eax_120 != 0x00);
l0808CCD0:
			esp_169 = fp - 0x5C;
			if (edx_126 != 0x00 && *((word32) edx_126 + 0x0C) >> 0x04 == 0x02 || (g_b80CFF05 & 0x01) != 0x00)
			{
				*dwArg0C = (union Eq_113724 *) 0x00;
				ecxOut = ecx_115;
				edxOut = edx_126;
				return 0x00;
			}
			if (dwArg08 != 0x00)
			{
				ecx_182 = *((word32) dwArg08 + 4);
				if (dwArg14 != 0x00)
				{
					eax_1454 = (ptr32) *dwArg14;
					if (eax_1454 != 0x00)
						edx_1456 = 0x080B31B4;
					else
					{
						edx_1456 = 0x080B31B4;
						eax_1454 = 134955513;
					}
				}
				else
				{
					edx_1456 = 134955513;
					eax_1454 = 134955513;
				}
				if (*ecx_182 != 0x00)
				{
l0808D335:
					struct Eq_113913 * esp_202 = esp_169 - 4;
					esp_202->t0000 = esi_131;
					esp_202->tFFFFFFFC = esi_131;
					esp_202->ptrFFFFFFF8 = eax_1454;
					esp_202->ptrFFFFFFF4 = edx_1456;
					esp_202->dwFFFFFFF0 = esp_202->dw0064;
					word32 edi_216 = esp_202->dw0004;
					esp_202->dwFFFFFFEC = edi_216 + ~0x0001AE2F;
					esp_202->tFFFFFFE8 = ecx_182;
					esp_202->ptrFFFFFFE4 = &esp_202->dw0004 + 0x0D;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					_dl_exception_create_format(gs, stackArg4, dwArg04, dwArg08);
					esp_202->tFFFFFFFC = edi_216 + ~0x0001AE16;
					esp_202->ptrFFFFFFF8 = &esp_202->dw0004 + 0x0D;
					esp_202->ptrFFFFFFF4 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 ebx_2722;
					_dl_signal_exception(gs, stackArg4, dwArg04, out ebx_2722);
					esi_131 = &esp_202->dw0004 + 0x0D;
					esp_18 = esp_202 - 0x0C;
					goto l0808D367;
				}
l0808D3AD:
				word32 edi_291 = esp_169->dw0000;
				ecx_182 = **(union Eq_2 **) 135060900;
				if (ecx_182 == 0x00)
					ecx_182 = edi_291 + ~0x0001B534;
				goto l0808D335;
			}
l0808D389:
			if (esp_169[28] != 0x00)
			{
				word32 edi_281 = esp_169->dw0000;
				eax_1454 = (ptr32) *esp_169[28].dw0000;
				edx_1456 = edi_281 + ~0x0001AE4B;
				if (eax_1454 == 0x00)
					eax_1454 = edi_281 + ~0x00019E06;
			}
			else
			{
				word32 eax_277 = esp_169->dw0000;
				edx_1456 = eax_277 + ~0x00019E06;
				eax_1454 = eax_277 + ~0x00019E06;
			}
			goto l0808D3AD;
		}
	}
	dwLoc58_1497.u0 = 0x00;
	goto l0808CB29;
}

// 0808D5C0: Register ui32 _dl_setup_hash(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_47902 ebpOut, Register out Eq_47903 esiOut, Register out ptr32 ediOut)
// Called from:
//      _dl_non_dynamic_init
//      _dl_map_object_from_fd.constprop.8
ui32 _dl_setup_hash(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_47902 & ebpOut, union Eq_47903 & esiOut, ptr32 & ediOut)
{
	Eq_2 edx_20 = *((word32) dwArg04 + 336);
	if (edx_20 != 0x00)
	{
		Eq_2 edx_36 = *((word32) edx_20 + 4);
		Eq_111344 ecx_37 = *edx_36;
		*((word32) dwArg04 + 380) = ecx_37;
		ui32 ebx_39 = *((word32) edx_36 + 8);
		Eq_47902 ebp_40 = *((word32) edx_36 + 4);
		if ((ebx_39 - 0x01 & ebx_39) != 0x00)
		{
			word32 ecx_132;
			word32 edx_133;
			__assert_fail(out ecx_132, out edx_133);
			_dl_add_to_namespace_list(dwArg04, dwArg08);
			ebpOut = ebp_40;
			esiOut = ebx_39 - 0x01;
			ediOut = 0x080CE000;
			return ebx_39;
		}
		*((word32) dwArg04 + 384) = ebx_39 - 0x01;
		word32 edx_72 = *((word32) edx_36 + 0x0C);
		*((word32) dwArg04 + 0x0188) = (word32) edx_36 + 16;
		*((word32) dwArg04 + 388) = edx_72;
		union Eq_112718 * edx_77 = (word32) edx_36 + 16 + ebx_39 * 0x04;
		*((word32) dwArg04 + 396) = edx_77;
		*((word32) dwArg04 + 400) = (char *) edx_77 + (ecx_37 - ebp_40) * 0x04;
	}
	else
	{
		Eq_2 edx_24 = *((word32) dwArg04 + 48);
		if (edx_24 != 0x00)
		{
			union Eq_111344 * edx_28 = *((word32) edx_24 + 4);
			Eq_111344 ecx_29 = *edx_28;
			*((word32) dwArg04 + 400) = (char *) edx_28 + 8;
			*((word32) dwArg04 + 380) = ecx_29;
			*((word32) dwArg04 + 396) = (char *) edx_28 + 8 + ecx_29 * 0x04;
		}
	}
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return ebx;
}

// 0808D680: void _dl_add_to_namespace_list(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _dl_non_dynamic_init
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
//      _dl_setup_hash
void _dl_add_to_namespace_list(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Mem36 = Mem12;
	union Eq_2 * eax_35 = dwArg08 *s 0x4C + 0x080CEA00;
	Eq_2 edx_37 = *eax_35;
	if (edx_37 == 0x00)
		*eax_35 = (union Eq_2 *) dwArg04;
	else
	{
		while (true)
		{
			Eq_2 eax_43 = *((word32) edx_37 + 0x0C);
			if (eax_43 == 0x00)
				break;
			edx_37 = eax_43;
		}
		*((word32) dwArg04 + 16) = edx_37;
		*((word32) edx_37 + 0x0C) = dwArg04;
	}
	g_a80CEA04[dwArg08] = (struct Eq_151587) ((word32) g_a80CEA04[dwArg08].dw0000 + 1);
	up32 eax_62 = g_dw80CE9B8;
	word32 edx_63 = g_dw80CE9BC;
	*((word32) dwArg04 + 600) = eax_62;
	g_dw80CE9B8 = eax_62 + 0x01;
	*((word32) dwArg04 + 604) = edx_63;
	g_dw80CE9BC = edx_63 + (word32) (eax_62 < 0x01);
}

// 0808D740: Register Eq_2 _dl_new_object(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_47795 bArg0C, Stack Eq_2 bArg14, Stack Eq_2 dwArg18)
// Called from:
//      _dl_non_dynamic_init
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
Eq_2 _dl_new_object(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_47795 bArg0C, Eq_2 bArg14, Eq_2 dwArg18)
{
	word32 ecx_609;
	word32 edx_610;
	Eq_2 eax_24 = strlen(dwArg08, out ecx_609, out edx_610);
	word32 ebp_46;
	word32 ecx_611;
	word32 edx_612;
	word32 ebx_613;
	word32 edi_614;
	Eq_2 esi_137;
	Eq_2 eax_45 = __libc_calloc(gs, (word32) eax_24 + 625, 0x01, out ecx_611, out edx_612, out ebx_613, out ebp_46, out esi_137, out edi_614);
	Eq_2 edi_240 = eax_45;
	if (eax_45 == 0x00)
		return edi_240;
	*((word32) eax_45 + 20) = eax_45;
	*((word32) eax_45 + 360) = (word32) eax_45 + 608;
	*((word32) eax_45 + 28) = (word32) eax_45 + 612;
	word32 ecx_615;
	word32 edx_616;
	Eq_2 eax_78 = memcpy((word32) eax_45 + 624, dwArg08, (word32) eax_24 + 1, out ecx_615, out edx_616);
	*((word32) eax_45 + 620) = 0x01;
	*((word32) eax_45 + 612) = eax_78;
	Eq_2 eax_100 = (word32) eax_78 + ebp_46;
	byte dl_93 = *dwArg04;
	word32 ecx_92 = (word32) bArg0C;
	if (dl_93 != 0x00)
		eax_100 = dwArg04;
	*((word32) eax_45 + 4) = eax_100;
	*((word32) eax_45 + 408) = *((word32) eax_45 + 408) & 252 | (byte) ecx_92 & 0x03;
	if ((g_b80CFF05 & 0x01) == 0x00)
		*((word32) eax_45 + 0x0200) = 0x01;
	ptr32 esi_158;
	ptr32 eax_138;
	word32 ebp_133;
	*((word32) eax_45 + 368) = esi_137;
	*((word32) eax_45 + 464) = (word32) eax_45 + 444;
	*((word32) eax_45 + 24) = dwArg18;
	((word32) eax_45 + 0x01CC)->u0 = 0x04;
	ptr32 * ecx_120 = (word32) eax_45 + 444;
	word32 eax_129 = *((char *) &g_t80CEA00 + dwArg18 * 0x4C);
	if (eax_129 != 0x00)
	{
		*((word32) eax_45 + 444) = eax_129 + 0x0160;
		eax_138 = eax_129 + 0x0160;
		ebp_133 = 0x01;
		if (esi_137 == 0x00)
		{
			esi_137 = eax_45;
			goto l0808D966;
		}
	}
	else
	{
		ebp_133 = 0x00;
		if (esi_137 == 0x00)
		{
			esi_137 = eax_45;
			goto l0808D874;
		}
	}
	while (true)
	{
		Eq_2 eax_146 = *((word32) esi_137 + 368);
		if (eax_146 == 0x00)
			break;
		esi_137 = eax_146;
	}
	if (ebp_133 != 0x00)
	{
		eax_138 = (ptr32) *((word32) eax_45 + 444);
l0808D966:
		esi_158 = (word32) esi_137 + 352;
		if (esi_158 == eax_138)
			goto l0808D87C;
		if ((bArg14 & 0x08) != 0x00)
			*((word32) eax_45 + 448) = eax_138;
		else
			ecx_120 = (word32) eax_45 + 448;
l0808D87A:
		*ecx_120 = esi_158;
l0808D87C:
		*((word32) eax_45 + 468) = (word32) eax_45 + 352;
		if (dl_93 != 0x00)
		{
			Eq_2 edx_252;
			Eq_2 ecx_253;
			Eq_2 edx_248;
			word32 ecx_617;
			word32 edx_618;
			Eq_2 eax_205 = strlen(dwArg04, out ecx_617, out edx_618);
			struct Eq_114357 * esp_212 = fp - 0x3C;
			word32 esi_218 = (word32) eax_205 + 1;
			if (dl_93 != 0x2F)
			{
				Eq_2 ebp_254 = 0x00;
				do
				{
					struct Eq_114388 * esp_257 = esp_212 - 0x08;
					esp_257->tFFFFFFFC = esi_218 + 0x80;
					esp_257->tFFFFFFF8 = ebp_254;
					word32 esi_270;
					word32 edx_624;
					word32 edi_625;
					Eq_2 eax_272 = __realloc(gs, esp_257->tFFFFFFF4, esp_257->tFFFFFFF8, esp_257->tFFFFFFFC, out edx_624, out ebp_254, out esi_270, out edi_625);
					Eq_2 esp_271 = <invalid>;
					if (eax_272 == 0x00)
						break;
					*((word32) esp_271 + 4) = esi_270 + 0x7F - *((word32) esp_271 + 32);
					*esp_271 = eax_272;
					*((word32) esp_271 + 28) = eax_272;
					word32 edi_297;
					word32 edx_626;
					Eq_2 eax_293 = getcwd(gs, *esp_271, *((word32) esp_271 + 4), out edx_626, out edi_297);
					esp_212 = (word32) esp_271 + 16;
					edx_248 = *((word32) esp_271 + 28);
					if (eax_293 != 0x00)
					{
						edi_240 = *((word32) esp_271 + 44);
						Eq_2 ecx_311 = edx_248;
						do
						{
							word32 esi_314 = *ecx_311;
							ui32 eax_318 = esi_314 + ~0x01010100 & ~esi_314;
							ecx_311 = (word32) ecx_311 + 4;
							uint32 eax_319 = eax_318 & 0x80808080;
						} while ((eax_318 & 0x80808080) == 0x00);
						Eq_2 ebp_324 = ecx_311;
						uint32 esi_325 = (eax_318 & 0x80808080) >> 0x10;
						if ((eax_318 & 0x80808080 & 0x8080) == 0x00)
							eax_319 = esi_325;
						uint8 al_338 = (byte) eax_319;
						if ((eax_318 & 0x80808080 & 0x8080) == 0x00)
							ebp_324 = (word32) ecx_311 + 2;
						ecx_253 = SLICE(SEQ(ebp_324, (byte) eax_319) + SEQ(0x03, al_338), word32, 8);
						if (*((word32) ecx_253 - 1) != 0x2F)
						{
							*ecx_253 = 0x2F;
							ecx_253 = (word32) ecx_253 + 1;
						}
						goto l0808D9D6;
					}
					ebp_254 = edx_248;
					esi_218 = edi_297;
				} while (gs->**((word32) esp_271 + 36) == 0x22);
				edi_240 = *((word32) esp_271 + 44);
				*esp_271 = ebp_254;
				word32 ecx_627;
				word32 edx_628;
				free(gs, *((word32) esp_271 - 4), *esp_271, out ecx_627, out edx_628);
				edx_252.u0 = ~0x00;
			}
			else
			{
				word32 ecx_619;
				word32 ebp_622;
				word32 esi_623;
				word32 edx_620;
				word32 ebx_621;
				Eq_2 eax_236 = __libc_malloc(gs, dwLoc50, (word32) eax_205 + 1, out ecx_619, out edx_620, out ebx_621, out ebp_622, out esi_623, out edi_240);
				esp_212 = fp - 0x3C;
				edx_248 = eax_236;
				if (eax_236 != 0x00)
				{
					ecx_253 = eax_236;
l0808D9D6:
					esp_212->t000C = edx_248;
					struct Eq_114479 * esp_362 = esp_212 - 0x04;
					esp_362->tFFFFFFFC = esp_362->t001C;
					esp_362->tFFFFFFF8 = esp_362->t0044;
					esp_362->tFFFFFFF4 = ecx_253;
					word32 edx_629;
					Eq_2 eax_373 = __mempcpy(esp_362->tFFFFFFF4, esp_362->tFFFFFFF8, esp_362->tFFFFFFFC, out edx_629);
					edx_252 = esp_362->t0010;
					while (true)
					{
						Eq_2 ecx_387 = eax_373 - 0x01;
						if (*((word32) eax_373 - 1) == 0x2F)
							break;
						eax_373 = ecx_387;
					}
					if (edx_252 == ecx_387)
						ecx_387 = eax_373;
					*ecx_387 = 0x00;
				}
				else
					edx_252.u0 = ~0x00;
			}
			*((word32) edi_240 + 428) = edx_252;
		}
		return edi_240;
	}
l0808D874:
	esi_158 = (word32) esi_137 + 352;
	goto l0808D87A;
}

// 0808DA60: Register Eq_2 _dl_try_allocate_static_tls(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_114597 edxOut)
// Called from:
//      _dl_allocate_static_tls
Eq_2 _dl_try_allocate_static_tls(Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_114597 & edxOut)
{
	Eq_2 eax_118 = *((word32) dwArg04 + 0x0244);
	if (eax_118 == ~0x00)
	{
l0808DB09:
		ecxOut = ecx;
		edxOut = edx;
		return eax_118;
	}
	else
	{
		Eq_114606 esi_24 = *((word32) dwArg04 + 572);
		if (esi_24 <= _dl_tls_static_align)
		{
			ecx = _dl_tls_static_used;
			up32 eax_32 = _dl_tls_static_size - ecx;
			if (eax_32 > 1215)
			{
				edx = *((word32) dwArg04 + 576);
				word32 ebp_38 = Mem29[dwArg04 + 0x0238:word32] + edx;
				if (eax_32 - 0x04C0 >= ebp_38)
				{
					uint64 edx_eax_46 = (uint64) (eax_32 - 0x04C0 - ebp_38);
					Eq_2 ecx_51 = (word32) ecx + (eax_32 - 0x04C0) - edx - (uint32) (edx_eax_46 /u esi_24) *s esi_24;
					*((word32) dwArg04 + 0x0244) = ecx_51;
					_dl_tls_static_used = ecx_51;
					Eq_114597 edx_48 = (uint32) (edx_eax_46 % esi_24);
					if ((*((word32) *((word32) dwArg04 + 20) + 408) & 0x04) == 0x00)
					{
						*((word32) dwArg04 + 0x0199) |= 0x04;
						ecxOut = ecx_51;
						edxOut = edx_48;
						return 0x00;
					}
					_dl_init_static_tls();
					eax_118.u0 = 0x00;
					goto l0808DB09;
				}
			}
		}
		eax_118.u0 = ~0x00;
		goto l0808DB09;
	}
}

// 0808DB40: Register word32 _dl_allocate_static_tls(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 edxOut, Register out (ptr32 Eq_114679) ebxOut, Register out (ptr32 Eq_114680) ebpOut, Register out (ptr32 Eq_114681) esiOut, Register out (ptr32 Eq_114682) ediOut)
// Called from:
//      _dl_relocate_object
//      _dl_tlsdesc_resolve_abs_plus_addend_fixup
//      _dl_tlsdesc_resolve_rel_fixup
//      _dl_tlsdesc_resolve_rela_fixup
word32 _dl_allocate_static_tls(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & edxOut, struct Eq_114679 & ebxOut, struct Eq_114680 & ebpOut, struct Eq_114681 & esiOut, struct Eq_114682 & ediOut)
{
	if (*((word32) dwArg04 + 0x0244) != ~0x00)
	{
		word32 ecx_21;
		ptr32 edx_22;
		if (_dl_try_allocate_static_tls(dwArg04, out ecx_21, out edx_22) == 0x00)
		{
			edxOut = edx_22;
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return ecx_21;
		}
	}
	struct Eq_114688 * v10_39 = *((word32) dwArg04 + 4);
	struct Eq_114680 * ebp_47;
	struct Eq_114679 * ebx_48;
	struct Eq_114682 * edi_50;
	word32 ecx_106;
	word32 edx_107;
	_dl_signal_error(gs, 0x00, 134951844, out ecx_106, out edx_107, out ebx_48, out ebp_47, out edi_50);
	ptr32 edx_60;
	word32 ecx_59 = _dl_nothread_init_static_tls(gs, v10_39, out edx_60);
	edxOut = edx_60;
	ebxOut = ebx_48;
	ebpOut = ebp_47;
	esiOut = (struct Eq_114681 *) &g_t80CE000;
	ediOut = edi_50;
	return ecx_59;
}

// 0808DB90: Register word32 _dl_nothread_init_static_tls(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_114688) dwArg04, Register out ptr32 edxOut)
// Called from:
//      _dl_allocate_static_tls
word32 _dl_nothread_init_static_tls(struct Eq_9 * gs, struct Eq_114688 * dwArg04, ptr32 & edxOut)
{
	Eq_2 ecx_16 = dwArg04->t0234;
	word32 ecx_45;
	ptr32 edx_46;
	word32 edx_73;
	memset(__mempcpy(gs->t0008 - dwArg04->dw0244, dwArg04->t0230, ecx_16, out edx_73), 0x00, dwArg04->dw0238 - ecx_16, out ecx_45, out edx_46);
	edxOut = edx_46;
	return ecx_45;
}

// 0808DBF0: Register Eq_2 _dl_protect_relro(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_114761 ecxOut, Register out Eq_952 dlOut)
// Called from:
//      _dl_relocate_object
Eq_2 _dl_protect_relro(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_114761 & ecxOut, union Eq_952 & dlOut)
{
	word32 eax_16 = Mem11[dwArg04 + 0x0250:word32] + Mem11[dwArg04 + 0x00:word32];
	Eq_114761 ecx_103 = -_dl_pagesize;
	Eq_2 edx_21 = eax_16 & ecx_103;
	Eq_2 eax_22 = (word32) *((word32) dwArg04 + 596) + eax_16 & ecx_103;
	if (edx_21 != eax_22)
	{
		word32 edx_37;
		eax_22 = mprotect(gs, edx_21, eax_22 - edx_21, 0x01, out ecx_103, out edx_37);
		if (eax_22 < 0x00)
		{
			word32 ecx_124;
			word32 edx_125;
			word32 ebx_126;
			word32 ebp_127;
			word32 edi_128;
			_dl_signal_error(gs, gs->tFFFFFFE0, 0x080B3B20, out ecx_124, out edx_125, out ebx_126, out ebp_127, out edi_128);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			Eq_114761 ecx_71;
			byte dl_131;
			Eq_2 eax_70 = _dl_reloc_bad_type(gs, stackArg8, stackArg12, out ecx_71, out dl_131);
			ecxOut = ecx_71;
			dlOut.u0 = <invalid>;
			return eax_70;
		}
	}
	ecxOut = ecx_103;
	dlOut.u0 = <invalid>;
	return eax_22;
}

// 0808DC60: Register word32 _dl_reloc_bad_type(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out Eq_952 dlOut)
// Called from:
//      _dl_protect_relro
//      _dl_relocate_object
word32 _dl_reloc_bad_type(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, union Eq_952 & dlOut)
{
	word32 ecx_91;
	Eq_2 eax_27 = __stpcpy(fp - 44, 0x080B3AE0 + (dwArg0C << 0x05), out ecx_91);
	*((word32) eax_27 + 2) = 0x00;
	*eax_27 = (&g_t80B8620)[dwArg08 >> 0x04 & 0x0F];
	*((word32) eax_27 + 1) = (&g_t80B8620)[dwArg08 & 0x0F];
	word32 ecx_92;
	word32 edx_93;
	word32 ebx_94;
	word32 ebp_95;
	word32 edi_96;
	_dl_signal_error(gs, 0x00, fp - 44, out ecx_92, out edx_93, out ebx_94, out ebp_95, out edi_96);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	ptr32 ecx_71;
	byte dl_100;
	word32 ebx_101;
	word32 ebp_102;
	word32 esi_103;
	word32 edi_104;
	word32 eax_69 = _dl_relocate_object(gs, stackArg4, stackArg12, stackArg16, out ecx_71, out dl_100, out ebx_101, out ebp_102, out esi_103, out edi_104);
	ecxOut = ecx_71;
	dlOut.u0 = <invalid>;
	return eax_69;
}

// 0808DCD0: Register ptr32 _dl_relocate_object(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ecxOut, Register out Eq_952 dlOut, Register out Eq_2 ebxOut, Register out (ptr32 Eq_114891) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _dl_reloc_bad_type
//      dl_open_worker
ptr32 _dl_relocate_object(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ecxOut, union Eq_952 & dlOut, union Eq_2 & ebxOut, struct Eq_114891 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	ptr32 eax_2908 = 0x080CE000;
	struct Eq_114891 * ebp_1030 = fp - 4;
	Eq_2 esp_1038 = fp - 0x9C;
	Eq_2 edi_20 = dwArg04;
	if ((*((word32) dwArg04 + 408) & 0x04) != 0x00)
	{
l0808E109:
		struct Eq_114919 * esp_2950 = ebp_1030 - 0x0C;
		Eq_2 ebx_2952 = esp_2950->t0000;
		Eq_2 esi_2954 = esp_2950->t0004;
		Eq_2 edi_2956 = esp_2950->t0008;
		struct Eq_114891 * ebp_2958 = esp_2950->ptr000C;
		ecxOut = ecx;
		dlOut.u0 = <invalid>;
		ebxOut = ebx_2952;
		ebpOut = ebp_2958;
		esiOut = esi_2954;
		ediOut = edi_2956;
		return eax_2908;
	}
	Eq_2 dwLoc78_3465;
	struct Eq_47820 * edx_140;
	ui32 ecx_139;
	struct Eq_47820 * ebx_142;
	Eq_2 eax_228;
	Eq_2 eax_27 = _dl_debug_mask;
	if (dwArg10 != 0x00 || *((word32) dwArg04 + 0x0080) == 0x00)
	{
		dwLoc78_3465 = dwArg0C & 0x01;
		if ((eax_27 & 0x20) == 0x00)
			goto l0808DD24;
	}
	else
	{
		if ((eax_27 & 0x20) == 0x00)
		{
			if (*((word32) dwArg04 + 0x0078) == 0x00)
				dwLoc78_3465.u0 = 0x00;
			else
			{
				edx_140 = (struct Eq_47820 *) *((word32) dwArg04 + 340);
				ecx_139 = (word32) *((word32) dwArg04 + 348);
				dwLoc78_3465.u0 = 0x00;
				ebx_142 = edx_140;
				if (edx_140 < edx_140 + (ecx_139 << 0x05) / 32)
					goto l0808F747;
				dwLoc78_3465 = dwArg10;
			}
l0808DD97:
			Eq_114985 eax_350 = 0x00;
			do
			{
				*((word32) eax_350 + (fp - 0x3C)) = 0x00;
				eax_350 = (word32) eax_350 + 4;
			} while (eax_350 < 0x20);
			Eq_2 ebx_1003;
			ui32 eax_2826;
			word32 esi_369;
			Eq_2 edx_368;
			Eq_2 eax_363 = *((word32) dwArg04 + 100);
			if (eax_363 != 0x00)
			{
				ebx_1003 = *((word32) eax_363 + 4);
				esi_369 = (word32) *((word32) *((word32) dwArg04 + 0x0068) + 4);
				struct Eq_115105 * ecx_375 = *((word32) dwArg04 + 0x00C0);
				eax_2826 = 0x00;
				edx_368 = (byte) ebx_1003.u0 + esi_369;
				if (ecx_375 != null)
					eax_2826 = ecx_375->dw0004;
			}
			else
			{
				eax_2826 = 0x00;
				edx_368.u0 = 0x00;
				esi_369 = 0x00;
				ebx_1003.u0 = 0x00;
			}
			Eq_21863 ecx_388 = *((word32) dwArg04 + 112);
			if (ecx_388 != 0x00 && *((word32) ecx_388 + 4) == 0x11)
			{
				Eq_2 ecx_395 = *((word32) *((word32) dwArg04 + 0x007C) + 4);
				word32 ecx_399 = *((word32) *((word32) dwArg04 + 40) + 4);
				if ((word32) ecx_395 + ecx_399 == edx_368)
				{
					esi_369 -= ecx_399;
					edx_368 = (byte) ebx_1003.u0 + esi_369;
				}
				if (dwLoc78_3465 == 0x00 && ecx_395 == edx_368)
					esi_369 += ecx_399;
			}
			word32 edx_2825 = 0x00;
			word32 edi_2827 = esi_369;
			Eq_2 esi_1647 = dwArg04;
l0808DE20:
			Eq_2 esp_2147;
			Eq_2 edi_1002;
			Eq_2 edx_3277;
			Eq_2 esi_1010;
			Eq_2 edx_2980;
			Eq_2 edx_3018;
			Eq_2 eax_1056;
			Eq_2 ecx_1057;
			Eq_116269 dl_2993;
			Eq_2 edi_460 = (word32) ebx_1003 + edi_2827;
			ebp_1030->tFFFFFFA8 = edi_460;
			struct Eq_9 * gs_2584 = gs;
			Eq_2 ecx_461 = ebx_1003;
			if (edx_2825 != 0x00)
			{
				ebp_1030->tFFFFFFA4.u0 = 135060900;
				ebp_1030->tFFFFFFA0.u0 = 135060900;
				if (ebx_1003 < edi_460)
				{
					Eq_2 ecx_1001 = esi_1647;
					edi_1002 = ebp_1030->tFFFFFFB4;
					do
					{
						uint32 eax_1005 = *((byte) ebx_1003.u0 + 4);
						Eq_2 edx_1008 = (word32) (byte) eax_1005;
						esi_1010 = Mem1004[ebx_1003 + 0x00:word32] + edi_1002;
						if (edx_1008 == 0x07)
						{
							word32 eax_1014 = *((word32) ecx_1001 + 532);
							if (eax_1014 == 0x00)
								Mem1024[esi_1010 + 0x00:word32] = Mem1004[esi_1010 + 0x00:word32] + edi_1002;
							else
								*esi_1010 = eax_1014 + (esi_1010 - *((word32) ecx_1001 + 536)) * 0x04;
							goto l0808DE60;
						}
						if (edx_1008 != 0x29)
						{
							if (edx_1008 == 0x2A)
							{
								Eq_2 ecx_1044;
								word32 eax_1033 = Mem1004[esi_1010 + 0x00:word32] + Mem1004[ecx_1001 + 0x00:word32];
								if (ebp_1030->dwFFFFFF88 == 0x00)
								{
									ebp_1030->t0008 = ecx_1001;
									word32 edx_1042;
									eax_1033();
									ecx_1044 = ebp_1030->t0008;
									ecx_1001 = ecx_1044;
								}
								*esi_1010 = eax_1033;
								goto l0808DE60;
							}
							struct Eq_117510 * esp_1048 = esp_1038 - (struct Eq_117511 *) 0x04;
							esp_1048->tFFFFFFFC.u0 = 0x01;
							esp_1048->tFFFFFFF8 = edx_1008;
							esp_1048->tFFFFFFF4 = ecx_1001;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg12 = <invalid>;
							Eq_2 edx_1058 = <invalid>;
							esp_1038 = esp_1048 - (struct Eq_117525 *) 0x0C;
							byte dl_4164;
							eax_1056 = _dl_reloc_bad_type(gs, dwArg04, stackArg12, out ecx_1057, out dl_4164);
							dl_2993 = (byte) edx_1058;
l0808F714:
							if (0x00 - (word32) (dl_2993 < 0x01) + 0x03 == ecx_1057)
							{
l0808ECE3:
								Eq_2 eax_3033 = ebp_1030->t0008;
								edx_2980 = *((word32) eax_3033 + 556);
								Eq_2 eax_3035 = *((word32) eax_3033 + 552);
								ebp_1030->tFFFFFFC4 = edx_2980;
								ebp_1030->tFFFFFF94 = eax_3035;
							}
							else
							{
l0808E029:
								ptr32 ecx_3047 = esi_1010 - 0x0E;
								byte cl_3068 = (byte) ecx_3047;
								if (ecx_3047 <= 0x1B)
									edx_3018 = 0x08C00001 >> cl_3068 & 0x01;
								else
								{
									edx_3018.u0 = 0x00;
l0808E375:
									if (esi_1010 != 0x05)
									{
										if (esi_1010 == 0x06)
										{
l0808E383:
											edx_3018 |= 0x04;
										}
									}
									else
										edx_3018 |= 0x02;
								}
								Eq_2 ecx_3085 = ebp_1030->t0008;
								*((word32) ecx_3085 + 0x0224) = edx_3018;
								*((word32) ecx_3085 + 544) = ebx_1003;
								Eq_2 eax_3109 = (word32) ebp_1030->tFFFFFFA0 + ((eax_1056 & 0x7FFF) << 0x04);
								if (eax_3109 != 0x00 && *((word32) eax_3109 + 4) == 0x00)
									eax_3109.u0 = 0x00;
								struct Eq_115669 * esp_3128 = esp_1038 - (struct Eq_115670 *) 4;
								esp_3128->t0000.u0 = 0x00;
								esp_3128->tFFFFFFFC.u0 = 0x01;
								esp_3128->tFFFFFFF8 = edx_3018;
								esp_3128->tFFFFFFF4 = eax_3109;
								esp_3128->dwFFFFFFF0 = (word32) ebp_1030->t000C;
								esp_3128->ptrFFFFFFEC = ebp_1030 - 0x3C;
								Eq_2 eax_3147 = (word32) *ebx_1003 + ebp_1030->dwFFFFFF90;
								esp_3128->tFFFFFFE8 = ebp_1030->t0008;
								esp_3128->tFFFFFFE4 = eax_3147;
								word32 ecx_4147;
								word32 edx_4148;
								Eq_2 eax_3164 = _dl_lookup_symbol_x(gs, esp_3128->tFFFFFFE4, esp_3128->tFFFFFFE8, esp_3128->ptrFFFFFFEC, esp_3128->dwFFFFFFF0, esp_3128->tFFFFFFF4, esp_3128->tFFFFFFF8, esp_3128->tFFFFFFFC, esp_3128->t0000, out ecx_4147, out edx_4148);
								edx_2980 = ebp_1030->tFFFFFFC4;
								ebp_1030->tFFFFFF94 = eax_3164;
								Eq_2 eax_3177 = ebp_1030->t0008;
								*((word32) eax_3177 + 556) = edx_2980;
								*((word32) eax_3177 + 552) = eax_3164;
							}
							ebp_1030->tFFFFFFA0.u0 = 0x00;
							if (edx_2980 != 0x00)
							{
l0808E318:
								Eq_2 ax_3190 = *((word32) edx_2980 + 0x0E);
								Eq_2 ecx_3189 = *((word32) edx_2980 + 4);
								ebp_1030->tFFFFFF98 = ax_3190;
								ebp_1030->tFFFFFFA0 = ecx_3189;
								if (ax_3190 != ~0x0E)
								{
									Eq_2 ax_3201 = ebp_1030->tFFFFFF98;
									Mem3200[ebp_1030 + -96:word32] = ecx_3189 + Mem3193[Mem3193[ebp_1030 + -0x006C:word32] + 0x00:word32];
									if (ax_3201 != 0x00)
										goto l0808E343;
								}
								else
								{
l0808E343:
									if ((*((word32) edx_2980 + 0x0C) & 0x0F) == 0x0A && ebp_1030->dwFFFFFF88 == 0x00)
									{
										Eq_2 eax_3265;
										word32 ecx_3266;
										word32 edx_3267;
										ebp_1030->tFFFFFFA0();
										ebp_1030->tFFFFFFA0 = eax_3265;
									}
								}
							}
							esp_2147 = fp;
							uint32 edx_3272 = (word32) *((word32) edi_1002 + 4);
							if (edx_3272 <= 0x2A)
							{
								Eq_2 eax_3301 = ebp_1030->tFFFFFFAC;
								word32 ecx_3303 = (eax_3301 + ~0x0001AA7F)[edx_3272 * 0x04] + eax_3301;
								ptr32 eax_3308;
								ptr32 ecx_3309;
								word32 edx_3310;
								ecx_3303();
								ecxOut = ecx_3309;
								dlOut.u0 = <invalid>;
								ebxOut = ebx_1003;
								ebpOut = ebp_1030;
								esiOut = esi_1010;
								ediOut = edi_1002;
								return eax_3308;
							}
l0808FA70:
							gs_2584 = gs;
							edx_3277 = esi_1010;
							goto l0808FA72;
						}
						ebp_1030->tFFFFFFB4 = eax_1005 >> 0x08;
						if (eax_1005 >> 0x08 != 0x00)
						{
							if (*((word32) esi_1010 + 4) == 0x00)
							{
								Eq_2 eax_1068 = ebp_1030->tFFFFFFAC;
								*((word32) esi_1010 + 4) = ebx_1003;
								*esi_1010 = (word32) eax_1068 - 240672;
								goto l0808DE60;
							}
							Eq_2 ecx_1554;
							Eq_2 ecx_1307;
							Eq_2 eax_1073 = *((word32) ecx_1001 + 56);
							ebp_1030->tFFFFFF9C = *((word32) ecx_1001 + 232);
							Eq_2 edx_1077 = (word32) *((word32) eax_1073 + 4) + (ebp_1030->tFFFFFFB4 << 0x04);
							ebp_1030->tFFFFFFB0 = edx_1077;
							Eq_2 dl_1080 = *((word32) edx_1077 + 0x0C);
							ebp_1030->tFFFFFF74 = dl_1080;
							ebp_1030->tFFFFFF98 = dl_1080 >> 0x04;
							Eq_2 edx_1084 = ebp_1030->tFFFFFF9C;
							if (edx_1084 != 0x00)
							{
								Eq_2 edx_1326;
								ui32 edx_1312 = (word32) *((word32) *((word32) edx_1084 + 4) + ebp_1030->tFFFFFFB4 * 0x02);
								ebp_1030->tFFFFFFB4 = *((word32) ecx_1001 + 372);
								Eq_2 eax_1315 = ebp_1030->tFFFFFFB0;
								ebp_1030->tFFFFFFC4 = eax_1315;
								if (ebp_1030->tFFFFFF98 != 0x00 && ((word32) (*((word32) eax_1315 + 0x0D)) & 0x03) > 0x02)
								{
									if (*((word32) ecx_1001 + 544) != ebp_1030->tFFFFFFB0 || *((word32) ecx_1001 + 0x0224) != 0x01)
									{
										Eq_2 eax_1338 = ebp_1030->tFFFFFFB0;
										((word32) ecx_1001 + 0x0224)->u0 = 0x01;
										*((word32) ecx_1001 + 544) = eax_1338;
										Eq_2 eax_1346 = (word32) ebp_1030->tFFFFFFB4 + ((edx_1312 & 0x7FFF) << 0x04);
										if (eax_1346 != 0x00 && *((word32) eax_1346 + 4) == 0x00)
											eax_1346.u0 = 0x00;
										Eq_2 edx_1357 = ebp_1030->tFFFFFFB0;
										struct Eq_117398 * esp_1360 = esp_1038 - (struct Eq_117399 *) 4;
										esp_1360->t0000.u0 = 0x00;
										esp_1360->tFFFFFFFC.u0 = 0x01;
										esp_1360->tFFFFFFF8.u0 = 0x01;
										esp_1360->tFFFFFFF4 = eax_1346;
										esp_1360->dwFFFFFFF0 = (word32) ebp_1030->t000C;
										esp_1360->ptrFFFFFFEC = ebp_1030 - 0x3C;
										Eq_2 eax_1376 = (word32) *edx_1357 + ebp_1030->dwFFFFFF90;
										esp_1360->tFFFFFFE8 = ecx_1001;
										esp_1360->tFFFFFFE4 = eax_1376;
										ebp_1030->t0008 = ecx_1001;
										word32 ecx_4161;
										word32 edx_4162;
										Eq_2 eax_1386 = _dl_lookup_symbol_x(gs, esp_1360->tFFFFFFE4, esp_1360->tFFFFFFE8, esp_1360->ptrFFFFFFEC, esp_1360->dwFFFFFFF0, esp_1360->tFFFFFFF4, esp_1360->tFFFFFFF8, esp_1360->tFFFFFFFC, esp_1360->t0000, out ecx_4161, out edx_4162);
										ecx_1001 = ebp_1030->t0008;
										edx_1326 = ebp_1030->tFFFFFFC4;
										ebp_1030->tFFFFFFB4 = eax_1386;
										*((word32) ecx_1001 + 556) = edx_1326;
										*((word32) ecx_1001 + 552) = eax_1386;
									}
									else
									{
										edx_1326 = *((word32) ecx_1001 + 556);
										Eq_2 eax_1333 = *((word32) ecx_1001 + 552);
										ebp_1030->tFFFFFFC4 = edx_1326;
										ebp_1030->tFFFFFFB4 = eax_1333;
									}
									if (edx_1326 == 0x00)
										goto l0808EB73;
									ebp_1030->tFFFFFF74 = *((word32) edx_1326 + 0x0C);
								}
								else
								{
									ebp_1030->tFFFFFFB4 = ecx_1001;
									edx_1326 = ebp_1030->tFFFFFFB0;
								}
								Eq_2 ax_1413 = *((word32) edx_1326 + 0x0E);
								ebp_1030->tFFFFFF9C = ax_1413;
								if (ax_1413 != ~0x0E)
									ebp_1030->tFFFFFF98 = *ebp_1030->tFFFFFFB4;
								else
									ebp_1030->tFFFFFF98.u0 = 0x00;
								if ((ebp_1030->tFFFFFF74 & 0x0F) != 0x0A || (ebp_1030->tFFFFFF9C == 0x00 || ebp_1030->dwFFFFFF88 != 0x00))
									goto l0808F63F;
								ebp_1030->tFFFFFF9C = *((word32) edx_1326 + 4);
								Eq_2 eax_1438 = ebp_1030->tFFFFFFB4;
								if (ecx_1001 != eax_1438)
								{
									Eq_47915 al_1445 = *((word32) eax_1438 + 408);
									if ((al_1445 & 0x03) != 0x00 && (al_1445 & 0x04) == 0x00)
									{
										Eq_2 edx_1452 = *((word32) ecx_1001 + 52);
										Eq_2 eax_1453 = ebp_1030->tFFFFFFB0;
										ebp_1030->t0008 = ecx_1001;
										Mem1457[ebp_1030 + -80:word32] = Mem1454[eax_1453 + 0x00:word32] + Mem1454[edx_1452 + 0x04:word32];
										Eq_2 edx_1459 = ebp_1030->tFFFFFFA0;
										ebp_1030->tFFFFFF74 = *((word32) ebp_1030->tFFFFFFB4 + 4);
										Eq_2 edx_1463 = ebp_1030->tFFFFFFAC;
										word32 eax_1464 = **edx_1459;
										if (eax_1464 == 0x00)
											eax_1464 = (word32) edx_1463 - 0x0001AAD3;
										Eq_2 edx_1472 = ebp_1030->tFFFFFFAC;
										struct Eq_117803 * esp_1478 = esp_1038 - (struct Eq_117804 *) 0x08;
										esp_1478->tFFFFFFFC = ebp_1030->tFFFFFFB0;
										esp_1478->tFFFFFFF8 = ebp_1030->tFFFFFF74;
										esp_1478->tFFFFFFF4 = *((word32) ecx_1001 + 4);
										esp_1478->dwFFFFFFF0 = eax_1464;
										esp_1478->ptrFFFFFFEC = (word32) edx_1472 - 0x0001ABDC;
										esp_1478->tFFFFFFE8.u0 = 0x02;
										_dl_dprintf();
										ecx_1001 = ebp_1030->t0008;
									}
								}
								ebp_1030->t0008 = ecx_1001;
								word32 eax_1512 = Mem1510[ebp_1030 + -100:word32] + Mem1510[ebp_1030 + -0x0068:word32];
								word32 edx_1549;
								eax_1512();
								ecx_1554 = ebp_1030->t0008;
								ecx_1001 = ecx_1554;
								if (ebp_1030->tFFFFFFC4 != 0x00)
									goto l0808F63F;
								ecx_1001 = ecx_1554;
								goto l0808EB73;
							}
							Eq_2 eax_1101;
							Eq_2 edx_1088 = ebp_1030->tFFFFFFB0;
							ebp_1030->tFFFFFFC4 = edx_1088;
							if (ebp_1030->tFFFFFF98 == 0x00 || ((word32) (*((word32) edx_1088 + 0x0D)) & 0x03) <= 0x02)
							{
								ebp_1030->tFFFFFFB4 = ecx_1001;
								eax_1101 = ebp_1030->tFFFFFFB0;
								goto l0808EF2E;
							}
							if (*((word32) ecx_1001 + 544) != edx_1088 || *((word32) ecx_1001 + 0x0224) != 0x01)
							{
								Eq_2 edx_1107 = ebp_1030->tFFFFFFB0;
								ebp_1030->t0008 = ecx_1001;
								((word32) ecx_1001 + 0x0224)->u0 = 0x01;
								*((word32) ecx_1001 + 544) = edx_1107;
								struct Eq_118053 * esp_1114 = esp_1038 - (struct Eq_118054 *) 4;
								esp_1114->t0000.u0 = 0x00;
								esp_1114->tFFFFFFFC.u0 = 0x01;
								esp_1114->tFFFFFFF8.u0 = 0x01;
								esp_1114->tFFFFFFF4.u0 = 0x00;
								esp_1114->dwFFFFFFF0 = (word32) ebp_1030->t000C;
								esp_1114->ptrFFFFFFEC = ebp_1030 - 0x3C;
								Eq_2 eax_1128 = (word32) *edx_1107 + ebp_1030->dwFFFFFF90;
								esp_1114->tFFFFFFE8 = ecx_1001;
								esp_1114->tFFFFFFE4 = eax_1128;
								word32 ecx_4166;
								word32 edx_4167;
								Eq_2 eax_1136 = _dl_lookup_symbol_x(gs, esp_1114->tFFFFFFE4, esp_1114->tFFFFFFE8, esp_1114->ptrFFFFFFEC, esp_1114->dwFFFFFFF0, esp_1114->tFFFFFFF4, esp_1114->tFFFFFFF8, esp_1114->tFFFFFFFC, esp_1114->t0000, out ecx_4166, out edx_4167);
								ecx_1001 = ebp_1030->t0008;
								ebp_1030->tFFFFFFB4 = eax_1136;
								eax_1101 = ebp_1030->tFFFFFFC4;
								*((word32) ecx_1001 + 552) = eax_1136;
								*((word32) ecx_1001 + 556) = eax_1101;
							}
							else
							{
								eax_1101 = *((word32) ecx_1001 + 556);
								Eq_2 edx_1102 = *((word32) ecx_1001 + 552);
								ebp_1030->tFFFFFFC4 = eax_1101;
								ebp_1030->tFFFFFFB4 = edx_1102;
							}
							if (eax_1101 != 0x00)
							{
								ebp_1030->tFFFFFF74 = *((word32) eax_1101 + 0x0C);
l0808EF2E:
								Eq_2 dx_1168 = *((word32) eax_1101 + 0x0E);
								ebp_1030->tFFFFFF98 = dx_1168;
								if (dx_1168 != ~0x0E)
									ebp_1030->tFFFFFF9C = *ebp_1030->tFFFFFFB4;
								else
									ebp_1030->tFFFFFF9C.u0 = 0x00;
								if ((ebp_1030->tFFFFFF74 & 0x0F) != 0x0A || (ebp_1030->tFFFFFF98 == 0x00 || ebp_1030->dwFFFFFF88 != 0x00))
								{
l0808F63F:
									Eq_2 eax_1559 = *((word32) ebp_1030->tFFFFFFB4 + 0x0244);
									ebp_1030->tFFFFFFB0 = eax_1559;
									if (eax_1559 <= 0x00)
									{
										struct Eq_117640 * esp_1565 = esp_1038 - (struct Eq_117641 *) 0x0C;
										esp_1565->tFFFFFFFC = ebp_1030->tFFFFFFB4;
										ebp_1030->t0008 = ecx_1001;
										word32 edx_4165;
										_dl_allocate_static_tls(gs, esp_1565->tFFFFFFFC, out edx_4165, out ebx_1003, out ebp_1030, out esi_1010, out edi_1002);
										ecx_1001 = ebp_1030->t0008;
										ebp_1030->tFFFFFFB0 = *((word32) ebp_1030->tFFFFFFB4 + 0x0244);
										Eq_2 esp_1592 = <invalid>;
										esp_1038 = (word32) esp_1592 + 16;
									}
									Mem1613[esi_1010 + 0x04:word32] = Mem1605[esi_1010 + 0x04:word32] + Mem1605[Mem1605[ebp_1030 + -60:word32] + 0x04:word32] - Mem1605[ebp_1030 + -80:word32];
									*esi_1010 = (word32) ebp_1030->tFFFFFFAC - 0x0003AC60;
l0808DE60:
									ebx_1003 = (word32) ebx_1003 + 8;
									if (ebp_1030->tFFFFFFA8 > ebx_1003)
										continue;
									break;
								}
								ebp_1030->tFFFFFF98 = *((word32) eax_1101 + 4);
								Eq_2 eax_1193 = ebp_1030->tFFFFFFB4;
								if (ecx_1001 != eax_1193)
								{
									Eq_47915 al_1200 = *((word32) eax_1193 + 408);
									if ((al_1200 & 0x03) != 0x00 && (al_1200 & 0x04) == 0x00)
									{
										word32 eax_1210 = Mem1192[Mem1192[ebp_1030 + -80:word32] + 0x00:word32] + Mem1192[Mem1192[ecx_1001 + 0x34:word32] + 0x04:word32];
										ebp_1030->tFFFFFFB0 = *((word32) ebp_1030->tFFFFFFB4 + 4);
										ebp_1030->tFFFFFF74 = *((word32) ecx_1001 + 4);
										union Eq_113724 * eax_1219 = **ebp_1030->tFFFFFFA4;
										if (eax_1219 == null)
											eax_1219 = (word32) ebp_1030->tFFFFFFAC - 0x0001AAD3;
										ebp_1030->t0008 = ecx_1001;
										struct Eq_117979 * esp_1233 = esp_1038 - (struct Eq_117980 *) 4;
										esp_1233->t0000 = ecx_1001;
										esp_1233->tFFFFFFFC = ecx_1001;
										esp_1233->tFFFFFFF8 = eax_1210;
										esp_1233->tFFFFFFF4 = ebp_1030->tFFFFFFB0;
										esp_1233->dwFFFFFFF0 = (word32) ebp_1030->tFFFFFF74;
										esp_1233->ptrFFFFFFEC = eax_1219;
										esp_1233->tFFFFFFE8 = (word32) ebp_1030->tFFFFFFAC - 0x0001ABDC;
										esp_1233->tFFFFFFE4.u0 = 0x02;
										_dl_dprintf();
										ecx_1001 = ebp_1030->t0008;
									}
								}
								ebp_1030->t0008 = ecx_1001;
								word32 eax_1269 = Mem1267[ebp_1030 + -0x0068:word32] + Mem1267[ebp_1030 + -100:word32];
								word32 edx_1302;
								eax_1269();
								ecx_1307 = ebp_1030->t0008;
								ecx_1001 = ecx_1307;
								if (ebp_1030->tFFFFFFC4 != 0x00)
									goto l0808F63F;
								ecx_1001 = ecx_1307;
							}
l0808EB73:
							*esi_1010 = (word32) ebp_1030->tFFFFFFAC - 240720;
							goto l0808DE60;
						}
						*esi_1010 = (word32) ebp_1030->tFFFFFFAC - 240704;
						ebx_1003 = (byte) ebx_1003.u0 + 8;
					} while (ebp_1030->tFFFFFFA8 > ebx_1003);
					ebp_1030->tFFFFFFB4 = *ecx_1001;
					esi_1647 = ecx_1001;
				}
				ebp_1030->tFFFFFF94 = (word32) ebp_1030->tFFFFFF94 + 16;
				if (ebp_1030->tFFFFFF94 == ebp_1030->tFFFFFF84)
				{
l0808DEB7:
					Eq_115431 eax_1660 = 0x00;
					do
					{
						*((word32) eax_1660 + (ebp_1030 - 0x38)) = 0x00;
						eax_1660 = (word32) eax_1660 + 4;
					} while (eax_1660 < 0x20);
					Eq_2 ebx_1676;
					Eq_2 eax_1677;
					Eq_2 eax_1671 = *((word32) esi_1647 + 60);
					if (eax_1671 != 0x00)
					{
						eax_1677 = *((word32) eax_1671 + 4);
						struct Eq_115459 * ecx_1682 = *((word32) esi_1647 + 0x00C4);
						ebx_1676 = *((word32) *((word32) esi_1647 + 64) + 4);
						ebp_1030->tFFFFFFC8 = eax_1677;
						ebp_1030->tFFFFFFCC = ebx_1676;
						Mem1687[ebp_1030 + -80:word32] = eax_1677 + ebx_1676;
						if (ecx_1682 != null)
							ebp_1030->tFFFFFFD0 = ecx_1682->t0004;
					}
					else
					{
						ebp_1030->tFFFFFFB0.u0 = 0x00;
						ebx_1676.u0 = 0x00;
						eax_1677.u0 = 0x00;
					}
					Eq_21863 ecx_1695 = *((word32) esi_1647 + 112);
					if (ecx_1695 != 0x00 && *((word32) ecx_1695 + 4) == 0x07)
					{
						Eq_2 ecx_1703 = *((word32) *((word32) esi_1647 + 0x007C) + 4);
						union Eq_2 * esi_1704 = *((word32) *((word32) esi_1647 + 40) + 4);
						if (ecx_1703 + esi_1704 == Mem1694[ebp_1030 + -80:word32])
						{
							ebx_1676 -= esi_1704;
							ebp_1030->tFFFFFFCC = ebx_1676;
							Mem1715[ebp_1030 + -80:word32] = ebx_1676 + eax_1677;
						}
						if (ebp_1030->tFFFFFF8C == 0x00 && ecx_1703 == ebp_1030->tFFFFFFB0)
						{
							ebx_1676 += esi_1704;
							ebp_1030->tFFFFFFCC = ebx_1676;
						}
						else
						{
							ebp_1030->tFFFFFFD8 = ecx_1703;
							ebp_1030->ptrFFFFFFDC = esi_1704;
						}
					}
					Eq_2 esi_1737 = ebp_1030->tFFFFFF80;
					ebp_1030->t0008 = esi_1647;
					ebp_1030->tFFFFFF8C = esi_1737;
					ebp_1030->tFFFFFF84 = ebp_1030 - 0x18;
					ebp_1030->tFFFFFF80.u0 = 0x00;
					ebp_1030->tFFFFFF74.u0 = 135060900;
l0808DF31:
					Eq_2 eax_1799;
					Eq_2 esi_1756 = ebp_1030->tFFFFFF80;
					Mem1757[ebp_1030 + -88:word32] = ebx_1676 + eax_1677;
					ebp_1030->tFFFFFFA4 = *((word32) *((word32) ebp_1030->t0008 + 56) + 4);
					Eq_2 edx_1753 = eax_1677;
					edi_1002 = (byte) eax_1677.u0 + *((word32) ebp_1030->tFFFFFF8C + 8) * 0x0C;
					if (ebp_1030->t0008 != esi_1756 && (ebp_1030->tFFFFFFB4 != 0x00 || *((word32) ebp_1030->t0008 + 288) == 0x00) && eax_1677 < edi_1002)
					{
						Eq_2 eax_1783 = ebp_1030->tFFFFFFB4;
						do
						{
							Mem1793[Mem1787[edx_1753 + 0x00:word32] + eax_1783:word32] = Mem1787[edx_1753 + 0x08:word32] + eax_1783;
							edx_1753 = (word32) edx_1753 + 0x0C;
						} while (edi_1002 > edx_1753);
						eax_1799 = *((word32) ebp_1030->t0008 + 232);
						if (eax_1799 == 0x00)
						{
l0808E952:
							if (ebp_1030->tFFFFFFA8 > edi_1002)
							{
								ebp_1030->tFFFFFF94.u0 = 135060900;
								ebp_1030->dwFFFFFF78 = 0x080CFF4C;
								do
								{
									Mem1827[ebp_1030 + -80:word32] = Mem1823[ebp_1030 + -76:word32] + Mem1823[edi_1002 + 0x00:word32];
									Eq_116248 eax_1828 = *((word32) edi_1002 + 4);
									ebx_1003 = (word32) ebp_1030->tFFFFFFA4 + ((eax_1828 >> 0x08) << 0x04);
									ebp_1030->tFFFFFFC4 = ebx_1003;
									Eq_2 esi_1831 = (word32) (byte) eax_1828;
									if (esi_1831 != 0x08)
									{
										if (esi_1831 == 0x00)
											goto l0808EBA0;
										Eq_2 edx_1859;
										if (*((word32) ebx_1003 + 0x0C) >> 0x04 == 0x00)
										{
											ebp_1030->tFFFFFF98 = ebp_1030->t0008;
											edx_1859 = ebx_1003;
											goto l0808EBD0;
										}
										Eq_2 eax_1865 = ebp_1030->t0008;
										if (((word32) *((word32) ebx_1003 + 0x0D) & 0x03) <= 0x02)
										{
											ebp_1030->tFFFFFF98 = eax_1865;
											edx_1859 = ebx_1003;
											goto l0808EBD0;
										}
										Eq_2 eax_1902;
										if (ebx_1003 != *((word32) eax_1865 + 544))
										{
l0808E9D4:
											if (esi_1831 != 0x07 && esi_1831 != 0x23)
												goto l0808E9E6;
											eax_1902.u0 = 0x01;
											goto l0808EC3D;
										}
										Eq_2 edx_1884;
										Eq_2 ecx_1885;
										if (esi_1831 <= 0x25 && !__bt(0x70000081, esi_1831 - 0x07))
										{
											edx_1884.u0 = 0x01;
											ecx_1885 = *((word32) ebp_1030->t0008 + 0x0224);
											goto l0808F696;
										}
										Eq_116064 al_1883 = (int8) (esi_1831 == 0x29);
										edx_1884 = (word32) al_1883;
										ecx_1885 = *((word32) ebp_1030->t0008 + 0x0224);
										if (esi_1831 != 0x05)
										{
											if (esi_1831 == 0x06)
											{
												if (0x00 - (word32) (al_1883 < 0x01) + 0x05 == ecx_1885)
													goto l0808F69E;
												eax_1902.u0 = 0x00;
												goto l0808EC4B;
											}
l0808F696:
											if (ecx_1885 != edx_1884)
												goto l0808E9D4;
l0808F69E:
											Eq_2 eax_1916 = ebp_1030->t0008;
											edx_1859 = *((word32) eax_1916 + 556);
											Eq_2 eax_1918 = *((word32) eax_1916 + 552);
											ebp_1030->tFFFFFFC4 = edx_1859;
											ebp_1030->tFFFFFF98 = eax_1918;
										}
										else
										{
											if (0x00 - (word32) (al_1883 < 0x01) + 0x03 == ecx_1885)
												goto l0808F69E;
l0808E9E6:
											byte cl_1950 = (byte) esi_1831 - 0x0E;
											if (esi_1831 <= 0x29)
												eax_1902 = 0x08C00001 >> cl_1950 & 0x01;
											else
											{
												eax_1902.u0 = 0x00;
l0808EC3D:
												if (esi_1831 != 0x05)
												{
													if (esi_1831 == 0x06)
													{
l0808EC4B:
														eax_1902 |= 0x04;
													}
												}
												else
													eax_1902 |= 0x02;
											}
											Eq_2 ecx_1968 = ebp_1030->t0008;
											*((word32) ecx_1968 + 0x0224) = eax_1902;
											*((word32) ecx_1968 + 544) = ebx_1003;
											struct Eq_116126 * esp_1995 = esp_1038 - (struct Eq_116127 *) 4;
											esp_1995->t0000.u0 = 0x00;
											esp_1995->tFFFFFFFC.u0 = 0x01;
											esp_1995->tFFFFFFF8 = eax_1902;
											esp_1995->tFFFFFFF4.u0 = 0x00;
											esp_1995->dwFFFFFFF0 = (word32) ebp_1030->t000C;
											esp_1995->ptrFFFFFFEC = ebp_1030 - 0x3C;
											Eq_2 eax_2010 = (word32) *ebx_1003 + ebp_1030->dwFFFFFF90;
											esp_1995->tFFFFFFE8 = ecx_1968;
											esp_1995->tFFFFFFE4 = eax_2010;
											word32 ecx_4152;
											word32 edx_4153;
											Eq_2 eax_2031 = _dl_lookup_symbol_x(gs, esp_1995->tFFFFFFE4, esp_1995->tFFFFFFE8, esp_1995->ptrFFFFFFEC, esp_1995->dwFFFFFFF0, esp_1995->tFFFFFFF4, esp_1995->tFFFFFFF8, esp_1995->tFFFFFFFC, esp_1995->t0000, out ecx_4152, out edx_4153);
											edx_1859 = ebp_1030->tFFFFFFC4;
											ebp_1030->tFFFFFF98 = eax_2031;
											Eq_2 eax_2044 = ebp_1030->t0008;
											*((word32) eax_2044 + 556) = edx_1859;
											*((word32) eax_2044 + 552) = eax_2031;
										}
										ebp_1030->tFFFFFFA0.u0 = 0x00;
										if (edx_1859 != 0x00)
										{
l0808EBD0:
											Eq_2 ax_2057 = *((word32) edx_1859 + 0x0E);
											Eq_2 ecx_2056 = *((word32) edx_1859 + 4);
											ebp_1030->tFFFFFF9C = ax_2057;
											ebp_1030->tFFFFFFA0 = ecx_2056;
											if (ax_2057 != ~0x0E)
											{
												Eq_2 ax_2068 = ebp_1030->tFFFFFF9C;
												Mem2067[ebp_1030 + -96:word32] = ecx_2056 + Mem2060[Mem2060[ebp_1030 + -0x0068:word32] + 0x00:word32];
												if (ax_2068 != 0x00)
													goto l0808EBFB;
											}
											else
											{
l0808EBFB:
												if ((*((word32) edx_1859 + 0x0C) & 0x0F) == 0x0A && ebp_1030->dwFFFFFF88 == 0x00)
												{
													Eq_2 eax_2130;
													word32 ecx_2131;
													word32 edx_2132;
													ebp_1030->tFFFFFFA0();
													ebp_1030->tFFFFFFA0 = eax_2130;
												}
											}
										}
										esp_2147 = esp_1038;
										esi_1010 = esi_1831;
										uint32 edx_2137 = (word32) *((word32) edi_1002 + 4);
										if (edx_2137 > 0x2A)
											goto l0808FA70;
										Eq_2 eax_2141 = ebp_1030->tFFFFFFAC;
										word32 ecx_2143 = (eax_2141 + ~0x0001A7CF)[edx_2137 * 0x04] + eax_2141;
										ptr32 eax_2149;
										ptr32 ecx_2150;
										word32 edx_2151;
										ecx_2143();
										ecxOut = ecx_2150;
										dlOut.u0 = <invalid>;
										ebxOut = ebx_1003;
										ebpOut = ebp_1030;
										esiOut = esi_1831;
										ediOut = edi_1002;
										return eax_2149;
									}
									Mem1843[Mem1835[ebp_1030 + -80:word32] + 0x00:word32] = Mem1835[edi_1002 + 0x08:word32] + Mem1835[Mem1835[ebp_1030 + 0x08:word32] + 0x00:word32];
l0808EBA0:
									edi_1002 = (word32) edi_1002 + 0x0C;
								} while (ebp_1030->tFFFFFFA8 > edi_1002);
							}
							goto l0808E17C;
						}
					}
					else
					{
						eax_1799 = *((word32) ebp_1030->t0008 + 232);
						if (eax_1799 == 0x00)
							goto l0808E952;
					}
					ebp_1030->tFFFFFF9C = *((word32) eax_1799 + 4);
					if (ebp_1030->tFFFFFFA8 > edi_1002)
					{
						ebp_1030->dwFFFFFF78 = 0x080CFF4C;
						do
						{
							Eq_116323 edx_2170 = *((word32) edi_1002 + 4);
							Eq_2 esi_2172 = ebp_1030->t0008;
							Eq_2 eax_2173 = ebp_1030->tFFFFFF9C;
							Mem2178[ebp_1030 + -80:word32] = Mem2169[ebp_1030 + -76:word32] + Mem2169[edi_1002 + 0x00:word32];
							eax_1056 = (word32) *((word32) eax_2173 + (edx_2170 >> 0x08) * 0x02);
							ebx_1003 = (word32) ebp_1030->tFFFFFFA4 + ((edx_2170 >> 0x08) << 0x04);
							ebp_1030->tFFFFFFA0 = *((word32) esi_2172 + 372);
							ebp_1030->tFFFFFFC4 = ebx_1003;
							esi_1010 = (word32) (byte) edx_2170;
							if (esi_1010 != 0x08)
							{
								if (esi_1010 != 0x00)
								{
									if (*((word32) ebx_1003 + 0x0C) >> 0x04 == 0x00 || ((word32) (*((word32) ebx_1003 + 0x0D)) & 0x03) <= 0x02)
									{
										ebp_1030->tFFFFFF94 = ebp_1030->t0008;
										edx_2980 = ebx_1003;
										goto l0808E318;
									}
									if (ebx_1003 == *((word32) ebp_1030->t0008 + 544))
									{
										if (esi_1010 <= 0x25 && !__bt(0x70000081, esi_1010 - 0x07))
										{
											Eq_2 edx_3021 = ebp_1030->t0008;
											ebp_1030->tFFFFFF98.u0 = 0x01;
											ecx_1057 = *((word32) edx_3021 + 0x0224);
										}
										else
										{
											dl_2993.u0 = (int8) (esi_1010 == 0x29);
											ebp_1030->tFFFFFF98 = (word32) dl_2993;
											ecx_1057 = *((word32) ebp_1030->t0008 + 0x0224);
											if (esi_1010 == 0x05)
												goto l0808F714;
											if (esi_1010 == 0x06)
											{
												if (0x00 - (word32) (dl_2993 < 0x01) + 0x05 == ecx_1057)
													goto l0808ECE3;
												edx_3018.u0 = 0x00;
												goto l0808E383;
											}
										}
										if (ecx_1057 == ebp_1030->tFFFFFF98)
											goto l0808ECE3;
									}
									if (esi_1010 != 0x07 && esi_1010 != 0x23)
										goto l0808E029;
									edx_3018.u0 = 0x01;
									goto l0808E375;
								}
							}
							else
								Mem2194[Mem2186[ebp_1030 + -80:word32] + 0x00:word32] = Mem2186[edi_1002 + 0x08:word32] + Mem2186[Mem2186[ebp_1030 + 0x08:word32] + 0x00:word32];
							edi_1002 = (word32) edi_1002 + 0x0C;
						} while (ebp_1030->tFFFFFFA8 > edi_1002);
					}
l0808E17C:
					ebp_1030->tFFFFFF8C = (word32) ebp_1030->tFFFFFF8C + 16;
					if (ebp_1030->tFFFFFF8C != ebp_1030->tFFFFFF84)
					{
						Eq_2 eax_2961 = ebp_1030->tFFFFFF8C;
						ebx_1676 = *((word32) eax_2961 + 4);
						eax_1677 = *eax_2961;
						ebp_1030->tFFFFFFB4 = *ebp_1030->t0008;
						goto l0808DF31;
					}
					ecx = ebp_1030->ptr0014;
					edi_20 = ebp_1030->t0008;
					if (ecx != 0x00)
					{
						struct Eq_116455 * eax_2216 = *((word32) edi_20 + 40);
						if (eax_2216 != null)
						{
							struct Eq_116543 * esp_2232 = esp_1038 - (struct Eq_116544 *) 0x08;
							esp_2232->tFFFFFFFC = (uint32) ((uint64) eax_2216->dw0004 /u ((uint32) ((int8) (*((word32) (*((word32) edi_20 + 112)) + 4) == 0x07)) * 0x04 + 0x08));
							esp_2232->tFFFFFFF8.u0 = 0x18;
							word32 edx_4156;
							word32 esi_4158;
							word32 ebx_4157;
							Eq_2 eax_2249 = __libc_calloc(gs, esp_2232->tFFFFFFF8, esp_2232->tFFFFFFFC, out ecx, out edx_4156, out ebx_4157, out ebp_1030, out esi_4158, out edi_20);
							*((word32) edi_20 + 420) = eax_2249;
							if (eax_2249 == 0x00)
							{
								Eq_2 edx_2267 = *((word32) edi_20 + 4);
								Eq_2 eax_2270 = **(union Eq_2 **) 135060900;
								if (eax_2270 == 0x00)
									eax_2270 = (word32) ebp_1030->tFFFFFFAC - 0x0001AAD3;
								esp_2232[1] = (struct Eq_116543) edx_2267;
								esp_2232->t0000 = eax_2270;
								esp_2232->tFFFFFFFC = (word32) ebp_1030->tFFFFFFAC - 0x0001AB2C;
								esp_2232->tFFFFFFF8.u0 = 0x02;
								_dl_dprintf();
								esp_2232->tFFFFFFF8.u0 = 0x7F;
								_exit(gs, esp_2232->tFFFFFFF8);
							}
						}
					}
					struct Eq_116461 * edx_2831 = ebp_1030->ptrFFFFFF7C;
					*((word32) edi_20 + 408) |= 0x04;
					if (edx_2831 != null)
					{
						struct Eq_116461 * ebx_2839 = ebp_1030->ptrFFFFFF7C;
						do
						{
							struct Eq_116504 * esp_2841 = esp_1038 - (struct Eq_116505 *) 0x04;
							esp_2841->tFFFFFFFC = ebx_2839->t0008;
							esp_2841->tFFFFFFF8 = ebx_2839->t0004;
							esp_2841->tFFFFFFF4 = ebx_2839->t0000;
							esp_1038 = esp_2841 + 0x04;
							word32 edx_2857;
							if (mprotect(gs, esp_2841->tFFFFFFF4, esp_2841->tFFFFFFF8, esp_2841->tFFFFFFFC, out ecx, out edx_2857) < 0x00)
								goto l0808FF3E;
							ebx_2839 = ebx_2839->ptr000C;
						} while (ebx_2839 != null);
					}
					eax_2908 = (ptr32) *((word32) edi_20 + 596);
					if (eax_2908 != 0x00)
					{
						*((word32) esp_1038 - 16) = edi_20;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						byte dl_4155;
						eax_2908 = _dl_protect_relro(gs, stackArg4, out ecx, out dl_4155);
					}
					goto l0808E109;
				}
l0808E5B8:
				Eq_2 ecx_2824 = ebp_1030->tFFFFFF94;
				edx_2825 = (word32) *((word32) ecx_2824 + 0x0C);
				eax_2826 = (ui32) *((word32) ecx_2824 + 8);
				edi_2827 = (word32) *((word32) ecx_2824 + 4);
				ebx_1003 = *ecx_2824;
				goto l0808DE20;
			}
			Eq_2 edi_507;
			Eq_2 edx_469 = *((word32) esi_1647 + 56);
			ebp_1030->tFFFFFFB0 = (byte) ebx_1003.u0 + eax_2826 * 0x08;
			Eq_2 eax_473 = ebp_1030->tFFFFFFB4;
			ebp_1030->tFFFFFFA0 = *((word32) edx_469 + 4);
			if (eax_473 != 0x00 && (esi_1647 != 0x00 && ebx_1003 < ebp_1030->tFFFFFFB0))
			{
				word32 eax_485 = Mem475[ebp_1030 + -76:word32] + Mem475[ebx_1003 + 0x00:word32];
				if (*((word32) ebx_1003 + 4) == 0x08)
				{
					ebx_1003 = ebp_1030->tFFFFFFB0;
					Eq_2 edx_489 = ebp_1030->tFFFFFFB4;
					do
					{
						*eax_485 = (word32) edx_489 + *eax_485;
						ecx_461 = (word32) ecx_461 + 8;
						if (ebx_1003 <= ecx_461)
							goto l0808E407;
						eax_485 = Mem496[ecx_461 + 0x00:word32] + edx_489;
					} while (*((word32) ecx_461 + 4) == 0x08);
				}
				edi_507 = ebp_1030->tFFFFFFAC;
				struct Eq_118203 * esp_512 = esp_1038 - (struct Eq_118204 *) 4;
				esp_512->t0000 = (word32) edi_507 - 109300;
				esp_512->tFFFFFFFC.u0 = 0x0288;
				esp_512->tFFFFFFF8 = (word32) edi_507 - 0x0001AA9E;
				esp_512->tFFFFFFF4 = (word32) edi_507 - 0x0001ABA8;
				word32 edx_4169;
				word32 ecx_4168;
				__assert_fail(out ecx_4168, out edx_4169);
				esp_2147.u0 = <invalid>;
l0808FF17:
				edx_3277 = edi_507;
				while (true)
				{
l0808FA72:
					Eq_2 edi_3280 = ebp_1030->t0008;
					struct Eq_115939 * esp_3282 = esp_2147 - (struct Eq_115940 *) 0x04;
					esp_3282->tFFFFFFFC.u0 = 0x00;
					esp_3282->tFFFFFFF8 = edx_3277;
					esp_3282->tFFFFFFF4 = edi_3280;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg12 = <invalid>;
					byte dl_4151;
					word32 ecx_4150;
					_dl_reloc_bad_type(gs_2584, dwArg04, stackArg12, out ecx_4150, out dl_4151);
					esp_2147 = esp_3282 - (struct Eq_115959 *) 0x0C;
l0808FA81:
					edx_3277 = ebx_1003;
				}
			}
l0808E407:
			Eq_2 eax_532 = *((word32) esi_1647 + 232);
			if (eax_532 != 0x00)
			{
				Eq_2 edi_986 = ebp_1030->tFFFFFFB0;
				ebp_1030->tFFFFFF98 = *((word32) eax_532 + 4);
				if (ebp_1030->tFFFFFFA8 > edi_986)
				{
					ebp_1030->t0008 = esi_1647;
					ebp_1030->tFFFFFF74.u0 = 0x080CFF4C;
					do
					{
						Eq_2 eax_2362 = ebp_1030->tFFFFFFB0;
						uint32 ebx_2365 = *((word32) eax_2362 + 4);
						Eq_2 edi_2363 = ebp_1030->tFFFFFF98;
						word32 ecx_2366 = Mem2361[ebp_1030 + -76:word32] + Mem2361[eax_2362 + 0x00:word32];
						Eq_2 eax_2367 = ebp_1030->t0008;
						ebp_1030->tFFFFFFA4 = ecx_2366;
						Eq_2 edx_2373 = *((word32) eax_2367 + 372);
						Eq_2 di_2378 = *((word32) edi_2363 + (ebx_2365 >> 0x08) * 0x02);
						Eq_2 esi_2376 = (word32) ebp_1030->tFFFFFFA0 + ((ebx_2365 >> 0x08) << 0x04);
						ebp_1030->tFFFFFFC4 = esi_2376;
						ebp_1030->tFFFFFF9C = di_2378;
						gs_2584 = gs;
						ebx_1003 = (word32) (byte) ebx_2365;
						if (ebx_1003 != 0x08)
						{
							if (ebx_1003 == 0x00)
							{
								ebp_1030->tFFFFFFB0 = (word32) ebp_1030->tFFFFFFB0 + 8;
								if (ebp_1030->tFFFFFFA8 <= ebp_1030->tFFFFFFB0)
									break;
								continue;
							}
							<anonymous> * edx_2629;
							Eq_2 edi_2408;
							Eq_2 edx_2405;
							word32 ecx_2393 = (word32) *((word32) esi_2376 + 0x0C);
							if ((byte) ecx_2393 >> 0x04 == 0x00 || ((word32) (*((word32) esi_2376 + 0x0D)) & 0x03) <= 0x02)
							{
								edi_2408 = ebp_1030->t0008;
								Eq_2 ax_2410 = *((word32) esi_2376 + 0x0E);
								ebp_1030->tFFFFFF9C = ax_2410;
								edx_2405 = esi_2376;
								if (ax_2410 != ~0x0E)
									goto l0808E657;
								goto l0808E816;
							}
							Eq_2 edi_2461;
							if (esi_2376 != *((word32) ebp_1030->t0008 + 544))
							{
l0808E4B5:
								if (ebx_1003 != 0x07 && ebx_1003 != 0x23)
									goto l0808E4C7;
								edi_2461.u0 = 0x01;
								goto l0808E7E5;
							}
							Eq_2 edi_2424;
							if (ebx_1003 <= 0x25 && !__bt(0x70000081, ebx_1003 - 0x07))
							{
								ebp_1030->tFFFFFF70.u0 = 0x01;
								edi_2424 = *((word32) ebp_1030->t0008 + 0x0224);
								goto l0808EEA1;
							}
							Eq_117184 cl_2428 = (int8) (ebx_1003 == 0x29);
							ebp_1030->tFFFFFF70 = (word32) cl_2428;
							edi_2424 = *((word32) ebp_1030->t0008 + 0x0224);
							if (ebx_1003 != 0x05)
							{
								if (ebx_1003 == 0x06)
								{
									if (0x00 - (word32) (cl_2428 < 0x01) + 0x05 == edi_2424)
										goto l0808EEAD;
									edi_2461.u0 = 0x00;
									goto l0808E7F7;
								}
l0808EEA1:
								if (edi_2424 != ebp_1030->tFFFFFF70)
									goto l0808E4B5;
l0808EEAD:
								Eq_2 eax_2457 = ebp_1030->t0008;
								edx_2405 = *((word32) eax_2457 + 556);
								edi_2408 = *((word32) eax_2457 + 552);
								ebp_1030->tFFFFFFC4 = edx_2405;
							}
							else
							{
								if (0x00 - (word32) (cl_2428 < 0x01) + 0x03 == edi_2424)
									goto l0808EEAD;
l0808E4C7:
								byte cl_2493 = (byte) ebx_1003 - 0x0E;
								if (ebx_1003 <= 0x29)
									edi_2461 = 0x08C00001 >> cl_2493 & 0x01;
								else
								{
									edi_2461.u0 = 0x00;
l0808E7E5:
									if (ebx_1003 != 0x05)
									{
										if (ebx_1003 == 0x06)
										{
l0808E7F7:
											edi_2461 |= 0x04;
										}
									}
									else
										edi_2461 |= 0x02;
								}
								Eq_2 eax_2515 = ebp_1030->tFFFFFF9C;
								Eq_2 ecx_2516 = ebp_1030->t0008;
								*((word32) ecx_2516 + 0x0224) = edi_2461;
								*((word32) ecx_2516 + 544) = esi_2376;
								Eq_2 edx_2534 = (word32) edx_2373 + ((eax_2515 & 0x7FFF) << 0x04);
								if (edx_2534 != 0x00 && *((word32) edx_2534 + 4) == 0x00)
									edx_2534.u0 = 0x00;
								struct Eq_116834 * esp_2556 = esp_1038 - (struct Eq_116835 *) 4;
								esp_2556->t0000.u0 = 0x00;
								esp_2556->tFFFFFFFC.u0 = 0x01;
								esp_2556->tFFFFFFF8 = edi_2461;
								esp_2556->tFFFFFFF4 = edx_2534;
								esp_2556->dwFFFFFFF0 = (word32) ebp_1030->t000C;
								esp_2556->ptrFFFFFFEC = ebp_1030 - 0x3C;
								Eq_2 eax_2573 = (word32) *esi_2376 + ebp_1030->dwFFFFFF90;
								esp_2556->tFFFFFFE8 = ebp_1030->t0008;
								esp_2556->tFFFFFFE4 = eax_2573;
								word32 ecx_4159;
								word32 edx_4160;
								Eq_2 eax_2593 = _dl_lookup_symbol_x(gs, esp_2556->tFFFFFFE4, esp_2556->tFFFFFFE8, esp_2556->ptrFFFFFFEC, esp_2556->dwFFFFFFF0, esp_2556->tFFFFFFF4, esp_2556->tFFFFFFF8, esp_2556->tFFFFFFFC, esp_2556->t0000, out ecx_4159, out edx_4160);
								edx_2405 = ebp_1030->tFFFFFFC4;
								Eq_2 eax_2605 = ebp_1030->t0008;
								*((word32) eax_2605 + 556) = edx_2405;
								*((word32) eax_2605 + 552) = eax_2593;
								edi_2408 = eax_2593;
							}
							esp_2147 = esp_1038;
							if (edx_2405 == 0x00)
							{
								if (ebx_1003 <= 0x2A)
								{
									Eq_2 eax_2802 = ebp_1030->tFFFFFFAC;
									word32 eax_2803 = eax_2802 + (eax_2802 + 4294858284)[ebx_1003 * 0x04];
									ptr32 eax_2805;
									ptr32 ecx_2806;
									word32 edx_2807;
									eax_2803();
									ecxOut = ecx_2806;
									dlOut.u0 = <invalid>;
									ebxOut = ebx_1003;
									ebpOut = ebp_1030;
									esiOut = esi_2376;
									ediOut = edi_2408;
									return eax_2805;
								}
								goto l0808FA81;
							}
							Eq_2 ax_2615 = *((word32) edx_2405 + 0x0E);
							ecx_2393 = (word32) *((word32) edx_2405 + 0x0C);
							ebp_1030->tFFFFFF9C = ax_2615;
							if (ax_2615 == ~0x0E)
							{
l0808E816:
								edx_2629 = (<anonymous> *) *((word32) edx_2405 + 4);
								if (((byte) ecx_2393 & 0x0F) == 0x0A)
									goto l0808E830;
							}
							else
							{
l0808E657:
								edx_2629 = Mem2622[edi_2408 + 0x00:word32] + Mem2622[edx_2405 + 0x04:word32];
								if (((byte) ecx_2393 & 0x0F) == 0x0A)
								{
l0808E830:
									if (ebp_1030->tFFFFFF9C != 0x00 && ebp_1030->dwFFFFFF88 == 0x00)
									{
										if (ebp_1030->t0008 != edi_2408)
										{
											Eq_47915 al_2714 = *((word32) edi_2408 + 408);
											if ((al_2714 & 0x03) != 0x00 && (al_2714 & 0x04) == 0x00)
											{
												Eq_2 eax_2721 = ebp_1030->t0008;
												word32 ecx_2722 = *esi_2376;
												ebp_1030->ptrFFFFFF6C = edx_2629;
												Eq_2 edx_2725 = ebp_1030->tFFFFFFAC;
												Eq_2 eax_2728 = *((word32) edi_2408 + 4);
												ebp_1030->tFFFFFF9C = (word32) *((word32) *((word32) eax_2721 + 52) + 4) + ecx_2722;
												ebp_1030->tFFFFFF70 = eax_2728;
												Eq_2 eax_2734 = **(union Eq_2 **) 135060900;
												if (eax_2734 == 0x00)
													eax_2734 = (word32) edx_2725 - 0x0001AAD3;
												Eq_2 ecx_2741 = ebp_1030->t0008;
												struct Eq_117106 * esp_2743 = esp_1038 - (struct Eq_117107 *) 0x08;
												esp_2743->tFFFFFFFC = ebp_1030->tFFFFFF9C;
												esp_2743->tFFFFFFF8 = ebp_1030->tFFFFFF70;
												esp_2743->tFFFFFFF4 = *((word32) ecx_2741 + 4);
												esp_2743->dwFFFFFFF0 = (word32) eax_2734;
												esp_2743->ptrFFFFFFEC = (word32) edx_2725 - 0x0001ABDC;
												esp_2743->tFFFFFFE8.u0 = 0x02;
												_dl_dprintf();
												edx_2629 = ebp_1030->ptrFFFFFF6C;
											}
										}
										word32 eax_2785;
										word32 ecx_2786;
										edx_2629();
										esp_2147 = esp_1038;
										if (ebx_1003 <= 0x2A)
										{
											Eq_2 eax_2793 = ebp_1030->tFFFFFFAC;
											word32 eax_2794 = eax_2793 + (eax_2793 + 4294858628)[ebx_1003 * 0x04];
											ptr32 eax_2796;
											ptr32 ecx_2797;
											word32 edx_2798;
											eax_2794();
											ecxOut = ecx_2797;
											dlOut.u0 = <invalid>;
											ebxOut = ebx_1003;
											ebpOut = ebp_1030;
											esiOut = esi_2376;
											ediOut = edi_2408;
											return eax_2796;
										}
										goto l0808FA81;
									}
								}
							}
							esp_2147 = esp_1038;
							if (ebx_1003 <= 0x2A)
							{
								Eq_2 eax_2671 = ebp_1030->tFFFFFFAC;
								word32 eax_2672 = eax_2671 + (eax_2671 + 4294858456)[ebx_1003 * 0x04];
								ptr32 eax_2707;
								ptr32 ecx_2708;
								word32 edx_2709;
								eax_2672();
								ecxOut = ecx_2708;
								dlOut.u0 = <invalid>;
								ebxOut = ebx_1003;
								ebpOut = ebp_1030;
								esiOut = esi_2376;
								ediOut = edi_2408;
								return eax_2707;
							}
							goto l0808FA81;
						}
						word32 eax_2382 = *eax_2367;
						ebp_1030->tFFFFFFB0 = (word32) ebp_1030->tFFFFFFB0 + 8;
						*ecx_2366 = (word32) *ecx_2366 + eax_2382;
					} while (ebp_1030->tFFFFFFA8 > ebp_1030->tFFFFFFB0);
					goto l0808E5A0;
				}
			}
			else
			{
				Eq_2 eax_537 = ebp_1030->tFFFFFFB0;
				if (ebp_1030->tFFFFFFA8 > eax_537)
				{
					ebp_1030->t0008 = esi_1647;
					ebp_1030->tFFFFFF98.u0 = 135060900;
					ebp_1030->tFFFFFF74.u0 = 0x080CFF4C;
					Eq_2 esi_547 = eax_537;
					do
					{
						Mem553[ebp_1030 + -80:word32] = Mem549[ebp_1030 + -76:word32] + Mem549[esi_547 + 0x00:word32];
						uint32 eax_554 = *((word32) esi_547 + 4);
						ebx_1003 = (word32) ebp_1030->tFFFFFFA0 + ((eax_554 >> 0x08) << 0x04);
						ebp_1030->tFFFFFFC4 = ebx_1003;
						edi_507 = (word32) (byte) eax_554;
						if (edi_507 != 0x08)
						{
							if (edi_507 == 0x00)
							{
								esi_547 = (word32) esi_547 + 8;
								if (ebp_1030->tFFFFFFA8 <= esi_547)
									break;
								continue;
							}
							Eq_2 ecx_797;
							Eq_2 ecx_595;
							word32 edx_578 = (word32) *((word32) ebx_1003 + 0x0C);
							if ((byte) edx_578 >> 0x04 == 0x00)
							{
								ebp_1030->tFFFFFFA4 = ebp_1030->t0008;
								goto l0808F270;
							}
							Eq_2 eax_591 = ebp_1030->t0008;
							if (((word32) *((word32) ebx_1003 + 0x0D) & 0x03) <= 0x02)
							{
								ebp_1030->tFFFFFFA4 = eax_591;
l0808F270:
								Eq_2 ax_598 = *((word32) ebx_1003 + 0x0E);
								ebp_1030->tFFFFFF9C = ax_598;
								ecx_595 = ebx_1003;
								if (ax_598 != ~0x0E)
									goto l0808F282;
								goto l0808F3E6;
							}
							Eq_2 eax_635;
							if (ebx_1003 != *((word32) eax_591 + 544))
							{
l0808F0BE:
								if (edi_507 != 0x07 && edi_507 != 0x23)
									goto l0808F0D0;
								eax_635.u0 = 0x01;
								goto l0808F3AD;
							}
							Eq_2 edx_617;
							Eq_2 ecx_618;
							if (edi_507 <= 0x25 && !__bt(0x70000081, edi_507 - 0x07))
							{
								edx_617.u0 = 0x01;
								ecx_618 = *((word32) ebp_1030->t0008 + 0x0224);
								goto l0808F5B9;
							}
							Eq_118716 al_616 = (int8) (edi_507 == 0x29);
							edx_617 = (word32) al_616;
							ecx_618 = *((word32) ebp_1030->t0008 + 0x0224);
							if (edi_507 != 0x05)
							{
								if (edi_507 == 0x06)
								{
									if (0x00 - (word32) (al_616 < 0x01) + 0x05 == ecx_618)
										goto l0808F5C1;
									eax_635.u0 = 0x00;
									goto l0808F3BF;
								}
l0808F5B9:
								if (ecx_618 != edx_617)
									goto l0808F0BE;
l0808F5C1:
								Eq_2 eax_649 = ebp_1030->t0008;
								ecx_595 = *((word32) eax_649 + 556);
								Eq_2 eax_651 = *((word32) eax_649 + 552);
								ebp_1030->tFFFFFFC4 = ecx_595;
								ebp_1030->tFFFFFFA4 = eax_651;
							}
							else
							{
								if (0x00 - (word32) (al_616 < 0x01) + 0x03 == ecx_618)
									goto l0808F5C1;
l0808F0D0:
								byte cl_683 = (byte) edi_507 - 0x0E;
								if (edi_507 <= 0x29)
									eax_635 = 0x08C00001 >> cl_683 & 0x01;
								else
								{
									eax_635.u0 = 0x00;
l0808F3AD:
									if (edi_507 != 0x05)
									{
										if (edi_507 == 0x06)
										{
l0808F3BF:
											eax_635 |= 0x04;
										}
									}
									else
										eax_635 |= 0x02;
								}
								Eq_2 ecx_706 = ebp_1030->t0008;
								*((word32) ecx_706 + 0x0224) = eax_635;
								*((word32) ecx_706 + 544) = ebx_1003;
								struct Eq_118591 * esp_728 = esp_1038 - (struct Eq_118592 *) 4;
								esp_728->t0000.u0 = 0x00;
								esp_728->tFFFFFFFC.u0 = 0x01;
								esp_728->tFFFFFFF8 = eax_635;
								esp_728->tFFFFFFF4.u0 = 0x00;
								esp_728->dwFFFFFFF0 = (word32) ebp_1030->t000C;
								esp_728->ptrFFFFFFEC = ebp_1030 - 0x3C;
								Eq_2 eax_743 = (word32) *ebx_1003 + ebp_1030->dwFFFFFF90;
								esp_728->tFFFFFFE8 = ecx_706;
								esp_728->tFFFFFFE4 = eax_743;
								word32 edx_4171;
								word32 ecx_4170;
								Eq_2 eax_761 = _dl_lookup_symbol_x(gs, esp_728->tFFFFFFE4, esp_728->tFFFFFFE8, esp_728->ptrFFFFFFEC, esp_728->dwFFFFFFF0, esp_728->tFFFFFFF4, esp_728->tFFFFFFF8, esp_728->tFFFFFFFC, esp_728->t0000, out ecx_4170, out edx_4171);
								Eq_2 edx_769 = ebp_1030->t0008;
								ecx_595 = ebp_1030->tFFFFFFC4;
								ebp_1030->tFFFFFFA4 = eax_761;
								*((word32) edx_769 + 556) = ecx_595;
								*((word32) edx_769 + 552) = eax_761;
							}
							esp_2147 = esp_1038;
							if (ecx_595 == 0x00)
							{
								if (edi_507 <= 0x2A)
								{
									Eq_2 eax_978 = ebp_1030->tFFFFFFAC;
									word32 eax_979 = eax_978 + (eax_978 + 4294858972)[edi_507 * 0x04];
									ptr32 eax_981;
									ptr32 ecx_982;
									word32 edx_983;
									eax_979();
									ecxOut = ecx_982;
									dlOut.u0 = <invalid>;
									ebxOut = ebx_1003;
									ebpOut = ebp_1030;
									esiOut = esi_547;
									ediOut = edi_507;
									return eax_981;
								}
								goto l0808FF17;
							}
							Eq_2 ax_783 = *((word32) ecx_595 + 0x0E);
							edx_578 = (word32) *((word32) ecx_595 + 0x0C);
							ebp_1030->tFFFFFF9C = ax_783;
							if (ax_783 == ~0x0E)
							{
l0808F3E6:
								ecx_797 = *((word32) ecx_595 + 4);
								if (((byte) edx_578 & 0x0F) == 0x0A)
									goto l0808F400;
							}
							else
							{
l0808F282:
								ecx_797 = Mem789[Mem789[ebp_1030 + -92:word32] + 0x00:word32] + Mem789[ecx_595 + 0x04:word32];
								if (((byte) edx_578 & 0x0F) == 0x0A)
								{
l0808F400:
									if (ebp_1030->dwFFFFFF88 == 0x00 && ebp_1030->tFFFFFF9C != 0x00)
									{
										Eq_2 eax_885 = ebp_1030->tFFFFFFA4;
										if (ebp_1030->t0008 != eax_885)
										{
											Eq_47915 al_889 = *((word32) eax_885 + 408);
											if ((al_889 & 0x03) != 0x00 && (al_889 & 0x04) == 0x00)
											{
												ebp_1030->tFFFFFF70 = ecx_797;
												Eq_2 ecx_901 = ebp_1030->tFFFFFFAC;
												Eq_2 eax_903 = ebp_1030->tFFFFFFA4;
												Mem904[ebp_1030 + -100:word32] = Mem897[ebx_1003 + 0x00:word32] + Mem897[Mem897[Mem897[ebp_1030 + 0x08:word32] + 0x34:word32] + 0x04:word32];
												Eq_2 edx_905 = *((word32) eax_903 + 4);
												Eq_2 eax_909 = **(union Eq_2 **) 135060900;
												if (eax_909 == 0x00)
													eax_909 = (word32) ecx_901 - 0x0001AAD3;
												struct Eq_118531 * esp_915 = esp_1038 - (struct Eq_118532 *) 0x08;
												Eq_2 ecx_919 = ebp_1030->tFFFFFFAC;
												esp_915->tFFFFFFFC = ebp_1030->tFFFFFF9C;
												esp_915->tFFFFFFF8 = edx_905;
												esp_915->tFFFFFFF4 = *((word32) ebp_1030->t0008 + 4);
												esp_915->dwFFFFFFF0 = (word32) eax_909;
												esp_915->ptrFFFFFFEC = (word32) ecx_919 - 0x0001ABDC;
												esp_915->tFFFFFFE8.u0 = 0x02;
												_dl_dprintf();
												ecx_797 = ebp_1030->tFFFFFF70;
											}
										}
										word32 eax_959;
										word32 edx_961;
										ecx_797();
										esp_2147 = esp_1038;
										if (edi_507 <= 0x2A)
										{
											Eq_2 eax_967 = ebp_1030->tFFFFFFAC;
											word32 eax_968 = eax_967 + (eax_967 + ~0x0001A5CB)[edi_507 * 0x04];
											ptr32 eax_970;
											ptr32 ecx_971;
											word32 edx_972;
											eax_968();
											ecxOut = ecx_971;
											dlOut.u0 = <invalid>;
											ebxOut = ebx_1003;
											ebpOut = ebp_1030;
											esiOut = esi_547;
											ediOut = edi_507;
											return eax_970;
										}
										goto l0808FF17;
									}
								}
							}
							esp_2147 = esp_1038;
							if (edi_507 <= 0x2A)
							{
								Eq_2 eax_842 = ebp_1030->tFFFFFFAC;
								word32 eax_843 = eax_842 + (eax_842 + 4294859144)[edi_507 * 0x04];
								ptr32 eax_881;
								ptr32 ecx_882;
								word32 edx_883;
								eax_843();
								ecxOut = ecx_882;
								dlOut.u0 = <invalid>;
								ebxOut = ebx_1003;
								ebpOut = ebp_1030;
								esiOut = esi_547;
								ediOut = edi_507;
								return eax_881;
							}
							goto l0808FF17;
						}
						Eq_2 edi_565 = ebp_1030->tFFFFFFB0;
						Mem569[edi_565 + 0x00:word32] = Mem561[edi_565 + 0x00:word32] + Mem561[Mem561[ebp_1030 + 0x08:word32] + 0x00:word32];
						esi_547 = (word32) esi_547 + 8;
					} while (ebp_1030->tFFFFFFA8 > esi_547);
l0808E5A0:
					esi_1647 = ebp_1030->t0008;
					goto l0808E5A3;
				}
			}
l0808E5A3:
			Eq_2 eax_2814 = *esi_1647;
			ebp_1030->tFFFFFF94 = (word32) ebp_1030->tFFFFFF94 + 16;
			ebp_1030->tFFFFFFB4 = eax_2814;
			if (ebp_1030->tFFFFFF94 == ebp_1030->tFFFFFF84)
				goto l0808DEB7;
			goto l0808E5B8;
		}
		dwLoc78_3465.u0 = 0x00;
	}
	if (**((word32) dwArg04 + 4) == 0x00)
		**(union Eq_2 **) 135060900 != 0x00;
	word32 ecx_4172;
	word32 edx_4173;
	_dl_debug_printf(out ecx_4172, out edx_4173);
l0808DD24:
	esp_1038 = fp - 0x9C;
	if (*((word32) dwArg04 + 0x0078) == 0x00)
		goto l0808DD35;
	edx_140 = (struct Eq_47820 *) *((word32) dwArg04 + 340);
	ecx_139 = (word32) *((word32) dwArg04 + 348);
	ebx_142 = edx_140;
	if (edx_140 >= edx_140 + (ecx_139 << 0x05) / 32)
	{
l0808DD35:
		if (*((word32) dwArg04 + 0x007C) != null && dwLoc78_3465 != 0x00)
		{
			struct Eq_114989 * edx_274 = *((word32) *((word32) dwArg04 + 44) + 4);
			Eq_2 ecx_276 = edx_274->t0004;
			uint32 eax_277 = g_dw80CFF1C;
			if (ecx_276 != 0x00)
			{
				Mem283[dwArg04 + 0x0214:word32] = ecx_276 + Mem263[dwArg04 + 0x00:word32];
				*((word32) dwArg04 + 536) = &edx_274->ptr0008 + 1;
			}
			edx_274->t0004 = dwArg04;
			if (dwArg10 == 0x00)
			{
				dwLoc78_3465.u0 = 0x01;
				ptr32 eax_342 = 0x08092630;
				if ((eax_277 & 0x02) != 0x00)
					eax_342 = 0x08092660;
				edx_274->ptr0008 = eax_342;
			}
			else
			{
				dwLoc78_3465.u0 = 0x01;
				ptr32 eax_301 = 0x080926E0;
				if ((eax_277 & 0x02) != 0x00)
					eax_301 = 0x08092690;
				edx_274->ptr0008 = eax_301;
				Eq_2 eax_309 = _dl_profile;
				if (eax_309 != 0x00)
				{
					struct Eq_115048 * esp_318 = esp_1038 - 0x08;
					esp_318->tFFFFFFFC = dwArg04;
					esp_318->tFFFFFFF8 = eax_309;
					esp_1038 = (char *) &esp_318->tFFFFFFFC + 0x0C;
					word32 ecx_4141;
					if (_dl_name_match_p(esp_318->tFFFFFFF8, esp_318->tFFFFFFFC, out ecx_4141) != 0x00)
						_dl_profile_map = dwArg04;
				}
			}
		}
		goto l0808DD97;
	}
l0808F747:
	esp_1038 = fp - 0x9C;
	struct Eq_115123 * dwLoc88_3485 = null;
	do
	{
		if (ebx_142->dw0000 == 0x01 && (ebx_142->b0018 & 0x02) == 0x00)
		{
			Eq_2 esp_174 = esp_1038 - 0x20;
			*((word32) esp_174 + 28) = *((word32) esp_174 + 28);
			Eq_2 ecx_183 = _dl_pagesize;
			ui32 edx_190 = -ecx_183;
			ui32 eax_192 = ebx_142->dw0008 & edx_190;
			word32 esi_191 = esp_174 + 0x0F & ~0x0F;
			Eq_2 edx_199 = (edx_190 & ((word32) ecx_183 + (ebx_142->dw0008 - 0x01)) + ebx_142->dw0014) - eax_192;
			Eq_2 eax_203 = (word32) *dwArg04 + eax_192;
			esi_191->t0004 = edx_199;
			esi_191->t0000 = eax_203;
			((word32) esp_174 - 8)->u0 = 0x03;
			*((word32) esp_174 - 0x0C) = edx_199;
			*((word32) esp_174 - 16) = eax_203;
			esp_1038 = esp_174;
			word32 edx_4143;
			word32 ecx_4142;
			if (mprotect(gs, *((word32) esp_174 - 16), *((word32) esp_174 - 0x0C), *((word32) esp_174 - 8), out ecx_4142, out edx_4143) < 0x00)
			{
				eax_228.u0 = 0x080B33D0;
				while (true)
				{
					struct Eq_115335 * esp_2872 = esp_1038 - (struct Eq_115336 *) 4;
					esp_2872->t0000 = eax_228;
					esp_2872->tFFFFFFFC.u0 = 0x00;
					esp_2872->tFFFFFFF8 = *((word32) edi_20 + 4);
					esp_2872->tFFFFFFF4 = gs->tFFFFFFE0;
					word32 edx_4145;
					word32 ebx_4146;
					word32 ecx_4144;
					_dl_signal_error(gs, esp_2872->tFFFFFFF4, esp_2872->t0000, out ecx_4144, out edx_4145, out ebx_4146, out ebp_1030, out edi_20);
					esp_1038 = esp_2872 - (struct Eq_115372 *) 0x0C;
l0808FF3E:
					eax_228 = (word32) ebp_1030->tFFFFFFAC - 0x0001AC04;
				}
			}
			edx_140 = (struct Eq_47820 *) *((word32) dwArg04 + 340);
			ecx_139 = (word32) *((word32) dwArg04 + 348);
			esi_191->dw0008 = 1934713408 >> ((ebx_142->b0018 & 0x07) << 0x02) & 0x0F;
			esi_191->ptr000C = dwLoc88_3485;
			dwLoc88_3485 = esi_191;
		}
		++ebx_142;
	} while (ebx_142 < edx_140 + (ecx_139 << 0x05) / 32);
	goto l0808DD35;
}

// 0808FF70: Register Eq_2 _dl_important_hwcaps(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 ui32) dwArg0C, Register out ptr32 ebxOut)
// Called from:
//      _dl_init_paths
Eq_2 _dl_important_hwcaps(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ui32 * dwArg0C, ptr32 & ebxOut)
{
	uint32 dwLoc44_1292;
	__tunable_get_val(0x10, fp - 0x24, null);
	ui32 edi_43 = g_dw80CF8C8;
	ui32 eax_45 = g_dw80CF8CC;
	uint32 edi_48 = edi_43 & dwLoc24;
	uint32 eax_51 = eax_45 & dwLoc20;
	struct Eq_118882 * ebp_1081 = fp - 4;
	struct Eq_118885 * esp_1256 = fp - 0x7C;
	uint32 dwLoc4C_1289 = edi_48;
	uint32 dwLoc48_1290 = eax_51;
	uint32 ebx_1250 = (uint32) (int8) (dwArg04 != 0x00);
	if ((eax_51 | edi_48) != 0x00)
	{
		uip32 ecx_1785 = 0x00;
		do
		{
			uint32 eax_75 = ebx_1250 + 0x01;
			byte cl_82 = (byte) ecx_1785;
			dwLoc44_1292 = eax_75;
			uint32 eax_83 = __shrd(edi_48, eax_51, cl_82);
			uint32 edx_84 = eax_51 >> cl_82;
			if ((cl_82 & 0x20) != 0x00)
				eax_83 = edx_84;
			if ((eax_83 & 0x01) != 0x00)
			{
				ebx_1250 = eax_75;
				dwLoc44_1292 = ebx_1250 + 0x02;
			}
			word24 ecx_24_8_1255 = SLICE(ecx_1785 + 0x01, word24, 8);
			ui32 edx_108 = __shld(~0x00, ~0x00, cl_82 + 0x01);
			ui32 eax_109 = ~0x00 << cl_82 + 0x01;
			if ((cl_82 + 0x01 & 0x20) != 0x00)
			{
				edx_108 = eax_109;
				eax_109 = 0x00;
			}
			ecx_1785 = SEQ(ecx_24_8_1255, cl_82 + 0x01);
		} while ((edx_108 & eax_51 | eax_109 & edi_48) != 0x00);
	}
	else
		dwLoc44_1292 = ebx_1250 + 0x01;
	uint32 dwLoc40_1517;
	uint32 dwLoc3C_1373;
	uint32 eax_608;
	uint32 ecx_329;
	struct Eq_118885 * edi_328;
	Eq_2 eax_142 = _dl_sysinfo_map;
	if (eax_142 != 0x00)
	{
		struct Eq_47820 * eax_185 = *((word32) eax_142 + 340);
		word32 edi_186 = (word32) *((word32) eax_142 + 348);
		if (edi_186 != 0x00)
		{
			struct Eq_47820 * ecx_191 = eax_185;
			word32 dwLoc40_1308 = 0x00;
			do
			{
				if (ecx_191->dw0000 == 0x04)
				{
					uint32 eax_197 = ecx_191->dw001C;
					uint32 dwLoc54_1309 = eax_197;
					if (eax_197 > 0x03)
					{
						if ((eax_197 - 0x04 & ~0x04) == 0x00)
							goto l080900AF;
					}
					else
					{
						dwLoc54_1309 = 0x04;
l080900AF:
						struct Eq_119064 * esi_215 = (word32) *eax_142 + ecx_191->dw0008;
						ptr32 eax_214 = ecx_191->dw0014;
						int32 ebx_216 = 0x0C - esi_215;
						if (eax_214 > 0x0C)
						{
							ui32 edi_235 = -dwLoc54_1309;
							word32 dwLoc34_1323 = dwLoc54_1309 + 11;
							do
							{
								word32 eax_242 = esi_215->dw0000;
								Eq_119090 edx_243 = esi_215->t0004;
								if (esi_215->dw0008 == 0x02 && (eax_242 == 0x04 && (esi_215->dw000C == 5590599 && edx_243 > 0x0A)))
								{
									struct Eq_119118 * ecx_339 = esi_215 + (dwLoc54_1309 + 0x0F & edi_235) / 16;
									uint32 v21_341 = dwLoc44_1292 + ecx_339->dw0000;
									ui32 eax_346 = v21_341 * 0x08 + 0x0F;
									dwLoc44_1292 = v21_341;
									struct Eq_118885 * edi_349 = fp - 0x7C - (eax_346 & ~0x0FFF);
									if (fp - 0x7C != edi_349)
									{
										do
										{
											esp_1256 -= 0x1000;
											esp_1256->dw0FFC = esp_1256->dw0FFC;
										} while (esp_1256 != edi_349);
									}
									int32 eax_366 = eax_346 & ~0x0F & 0x0FFF;
									if (eax_366 != 0x00)
									{
										esp_1256 -= eax_366;
										(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1256 - 0x04)[eax_366 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1256 - 0x04)[eax_366 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
									}
									ui32 eax_381 = ecx_339->dw0004;
									g_dw80CF8C8 = edi_43;
									g_dw80CF8CC = eax_45 | eax_381 << 0x12;
									struct Eq_119167 * esp_388 = esp_1256 - 0x08;
									esp_388->tFFFFFFFC = fp - 0x24;
									esp_388->dwFFFFFFF8 = 0x10;
									__tunable_set_val(esp_388->dwFFFFFFF8, esp_388->tFFFFFFFC);
									ecx_329 = 0x01;
									dwLoc3C_1373 = 0x00;
									word32 eax_429 = ecx_339 + edx_243;
									if (&ecx_339->dw0004 + 1 < eax_429)
									{
										uint32 edi_434 = 0x00;
										byte * esi_437 = &ecx_339->dw0004 + 1;
										do
										{
											struct Eq_119227 * esp_439 = esp_1256 - 0x0C;
											Eq_2 ebx_442 = esi_437 + 1;
											esp_439->tFFFFFFFC = ebx_442;
											word32 edx_1790;
											word32 ecx_1789;
											Eq_2 eax_445 = strlen(esp_439->tFFFFFFFC, out ecx_1789, out edx_1790);
											uint32 edx_456 = edi_434 + 0x01;
											if ((eax_381 & 0x01 << *esi_437) != 0x00)
											{
												struct Eq_119213 * ecx_468 = esp_1256 + (edi_434 * 0x08) / 0x00001000;
												ecx_468->t0000 = ebx_442;
												ecx_468->t0004 = eax_445;
												ecx_329 = edi_434 + 0x02;
												edi_434 = edx_456;
											}
											else
											{
												--dwLoc44_1292;
												ecx_329 = edx_456;
											}
											esi_437 = (word32) eax_445 + ((word32) ebx_442 + 1);
										} while (esi_437 < eax_429);
										dwLoc3C_1373 = edi_434;
									}
									edi_328 = esp_1256;
									if ((eax_51 | edi_48) != 0x00)
										goto l08090224;
									goto l08090353;
								}
								esi_215 += ((eax_242 + dwLoc34_1323 & edi_235) + ((word32) edx_243 + (dwLoc54_1309 - 0x01)) & edi_235) / 16;
							} while (esi_215 + ebx_216 / 16 < eax_214);
							word32 v27_273 = dwLoc40_1308 + 0x01;
							dwLoc40_1308 = v27_273;
							++ecx_191;
							if (edi_186 == v27_273)
								break;
							continue;
						}
					}
				}
				word32 v26_222 = dwLoc40_1308 + 0x01;
				dwLoc40_1308 = v26_222;
				++ecx_191;
			} while (edi_186 != v26_222);
		}
		ui32 edx_289 = dwLoc44_1292 * 0x08 + 0x0F;
		struct Eq_118885 * edi_292 = fp - 0x7C - (edx_289 & ~0x0FFF);
		if (fp - 0x7C != edi_292)
		{
			do
			{
				esp_1256 -= 0x1000;
				esp_1256->dw0FFC = esp_1256->dw0FFC;
			} while (esp_1256 != edi_292);
		}
		int32 eax_308 = edx_289 & ~0x0F & 0x0FFF;
		if (eax_308 != 0x00)
		{
			esp_1256 -= eax_308;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1256 - 0x04)[eax_308 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1256 - 0x04)[eax_308 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
	}
	else
	{
		ui32 eax_154 = dwLoc44_1292 * 0x08 + 0x0F;
		struct Eq_118885 * edi_157 = fp - 0x7C - (eax_154 & ~0x0FFF);
		if (fp - 0x7C != edi_157)
		{
			do
			{
				esp_1256 -= 0x1000;
				esp_1256->dw0FFC = esp_1256->dw0FFC;
			} while (esp_1256 != edi_157);
		}
		int32 edx_173 = eax_154 & ~0x0F & 0x0FFF;
		if (edx_173 != 0x00)
		{
			esp_1256 -= edx_173;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1256 - 0x04)[edx_173 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1256 - 0x04)[edx_173 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
	}
	edi_328 = esp_1256;
	ecx_329 = 0x01;
	dwLoc3C_1373 = 0x00;
	if ((eax_51 | edi_48) == 0x00)
	{
l08090353:
		dwLoc40_1517 = dwLoc3C_1373;
		if (dwArg04 == 0x00)
			goto l08090360;
	}
	else
	{
l08090224:
		ui32 ebx_506 = 0x00;
		uint32 esi_1245 = dwLoc3C_1373 + 0x01;
		while (true)
		{
			while (true)
			{
				byte cl_522 = (byte) ebx_506;
				dwLoc40_1517 = esi_1245;
				uint32 eax_523 = __shrd(dwLoc4C_1289, dwLoc48_1290, cl_522);
				uint32 edx_524 = dwLoc48_1290 >> cl_522;
				if (((byte) ebx_506 & 0x20) != 0x00)
					eax_523 = edx_524;
				if ((eax_523 & 0x01) != 0x00)
					break;
				++ebx_506;
			}
			ui32 eax_545 = ebx_506 * 0x09;
			struct Eq_119282 * edx_548 = edi_328 + (dwLoc3C_1373 * 0x08) / 0x00001000;
			edx_548->dw0000 = eax_545 + 0x080A4804;
			struct Eq_119291 * esp_544 = esp_1256 - 0x0C;
			esp_544->tFFFFFFFC = eax_545 + 0x080A4804;
			word32 ecx_1791;
			word32 edx_1792;
			edx_548->t0004 = strlen(esp_544->tFFFFFFFC, out ecx_1791, out edx_1792);
			byte cl_566 = (byte) ebx_506;
			esp_1256 = (struct Eq_118885 *) ((char *) &esp_544->tFFFFFFFC + 16);
			ui32 edx_567 = __shld(0x00, 0x01, cl_566);
			ui32 eax_568 = 0x01 << cl_566;
			if ((cl_566 & 0x20) != 0x00)
			{
				edx_567 = eax_568;
				eax_568 = 0x00;
			}
			uint32 eax_586 = eax_568 ^ dwLoc4C_1289;
			uint32 eax_589 = edx_567 ^ dwLoc48_1290;
			++ebx_506;
			ecx_329 = dwLoc3C_1373 + 0x02;
			if ((eax_589 | eax_586) == 0x00)
				break;
			dwLoc3C_1373 = esi_1245;
			++esi_1245;
			dwLoc48_1290 = eax_589;
			dwLoc4C_1289 = eax_586;
		}
		if (dwArg04 == 0x00)
		{
l08090360:
			eax_608 = ecx_329;
			ecx_329 = dwLoc40_1517;
l080903EE:
			struct Eq_119350 * edx_630 = edi_328 + (ecx_329 * 0x08) / 0x00001000;
			edx_630->dw0004 = 0x03;
			edx_630->ptr0000 = 0x080B3B60;
			if (dwLoc44_1292 != eax_608)
			{
				struct Eq_119377 * esp_645 = esp_1256 - 4;
				esp_645->ptr0000 = 0x080B3B98;
				esp_645->dwFFFFFFFC = 0xB8;
				esp_645->ptrFFFFFFF8 = 0x080B3B64;
				esp_645->ptrFFFFFFF4 = 0x080B3B70;
				word32 edx_656;
				word32 ecx_1793;
				__assert_fail(out ecx_1793, out edx_656);
				ptr32 ebx_696;
				word32 ecx_1806;
				word32 edx_1807;
				Eq_2 eax_692 = _dl_debug_vdprintf(&g_t80B3B60, edx_656, gs, dwArg04, out ecx_1806, out edx_1807, out ebx_696);
				ebxOut = ebx_696;
				return eax_692;
			}
			Eq_2 ecx_1239;
			struct Eq_119403 * edi_1058;
			Eq_2 eax_1072;
			ptr32 esp_864;
			word32 eax_703 = edi_328->dw0004;
			if (dwLoc44_1292 == 0x01)
			{
				*dwArg0C = 0x02;
				struct Eq_119416 * esp_708 = esp_1256 - 0x0C;
				esp_708->tFFFFFFFC = eax_703 + 0x11;
				union Eq_2 * edi_720;
				word32 edx_1795;
				word32 ebx_1796;
				word32 ecx_1794;
				Eq_2 eax_716 = __libc_malloc(gs, esp_708->tFFFFFFF8, esp_708->tFFFFFFFC, out ecx_1794, out edx_1795, out ebx_1796, out ebp_1081, out ecx_1239, out edi_720);
				ebp_1081->tFFFFFFD0 = eax_716;
				if (eax_716 != 0x00)
				{
					Eq_2 esi_732 = ebp_1081->tFFFFFFD0;
					Eq_2 ebx_733 = ebp_1081->tFFFFFFB8;
					*((word32) esi_732 + 0x0C) = 0x00;
					*esi_732 = (word32) esi_732 + 16;
					*((word32) esi_732 + 4) = (word32) ebx_733 + 1;
					*((word32) esi_732 + 8) = (word32) esi_732 + 16;
					esp_708->t0004 = ebx_733;
					esp_708->t0000 = *edi_720;
					esp_708->tFFFFFFFC = (word32) esi_732 + 16;
					word32 edx_1805;
					Eq_2 eax_750 = __mempcpy(esp_708->tFFFFFFFC, esp_708->t0000, esp_708->t0004, out edx_1805);
					word32 * edi_758 = ebp_1081->ptr0014;
					*eax_750 = 0x2F;
					*ebp_1081->ptr0010 = 0x02;
					*edi_758 = (word32) *((word32) esi_732 + 4);
					Eq_2 eax_766 = ebp_1081->tFFFFFFD0;
					ebxOut = ebp_1081->ptrFFFFFFF4;
					return eax_766;
				}
				goto l080906C6;
			}
			ui32 edx_784 = (char *) *((char *) (edi_328 + (dwLoc44_1292 * 0x08) / 0x00001000) - 4) + 2 + eax_703;
			if (dwLoc44_1292 > 0x02)
			{
				ui32 edx_788 = edx_784 * 0x02;
				uint32 eax_789 = 0x00;
				ecx_1239 = dwLoc44_1292 - 0x01;
				do
				{
					++eax_789;
					edx_788 = edx_788 + 0x01 + ((edi_328->a000C))[eax_789].dw0000;
				} while (dwLoc44_1292 - 0x02 != eax_789);
				if (dwLoc44_1292 != 0x03 && (dwLoc44_1292 > 0x1F || edx_788 + 0x40 >> 0x23 - (byte) dwLoc44_1292 != 0x00))
				{
l080906C6:
					struct Eq_119533 * esp_875 = esp_1256 - 4;
					esp_875->t0000 = (word32) ebp_1081->tFFFFFFD4 - 107655;
					esp_875->dwFFFFFFFC = 0x00;
					esp_875->dwFFFFFFF8 = 0x00;
					esp_875->tFFFFFFF4.u0 = 0x0C;
					esp_864 = esp_875 - 0x0C;
					word32 edx_1801;
					word32 ecx_1800;
					word32 ebx_1802;
					eax_1072 = _dl_signal_error(gs, esp_875->tFFFFFFF4, esp_875->t0000, out ecx_1800, out edx_1801, out ebx_1802, out ebp_1081, out edi_1058);
					goto l080906DB;
				}
				edx_784 = edx_788 << (byte) dwLoc44_1292 - 0x03;
			}
			*dwArg0C = 0x01 << (byte) dwLoc44_1292;
			struct Eq_119466 * esp_832 = esp_1256 - 0x0C;
			esp_832->tFFFFFFFC = edx_784 + (0x08 << (byte) dwLoc44_1292);
			word32 ebx_1799;
			word32 ecx_1797;
			word32 edx_1798;
			Eq_2 eax_853 = __libc_malloc(gs, esp_832->tFFFFFFF8, esp_832->tFFFFFFFC, out ecx_1797, out edx_1798, out ebx_1799, out ebp_1081, out ecx_1239, out edi_1058);
			Eq_2 ecx_865 = ebp_1081->tFFFFFFB0;
			ebp_1081->tFFFFFFD0 = eax_853;
			esp_864 = (char *) &esp_832->tFFFFFFFC + 16;
			if (eax_853 != 0x00)
			{
				Eq_2 ebx_895 = ebp_1081->tFFFFFFD0;
				eax_1072 = ebx_895 + ecx_865;
				*ebx_895 = eax_1072;
				*((word32) ebx_895 + 8) = eax_1072;
				ebp_1081->tFFFFFFB0 = edi_1058->a0000[0];
				ui32 edx_901 = 0x01 << (byte) ecx_1239;
				if (ebp_1081->dwFFFFFFC0 != 0x02)
				{
					struct Eq_119403 * ebx_955 = ebp_1081->ptrFFFFFFC8;
					ebp_1081->tFFFFFFA4 = ecx_1239;
					ebp_1081->tFFFFFFAC = ebx_955->tFFFFFFF8;
					ebp_1081->dwFFFFFFC0 -= 0x02;
					ui32 esi_1053 = edx_901;
					do
					{
						struct Eq_119967 * esp_966 = esp_1256 - 0x04;
						esp_966->tFFFFFFFC = ebp_1081->tFFFFFFB4;
						esp_966->tFFFFFFF8 = ebp_1081->tFFFFFFAC;
						esp_966->tFFFFFFF4 = eax_1072;
						word32 edx_1810;
						Eq_2 eax_982 = __mempcpy(esp_966->tFFFFFFF4, esp_966->tFFFFFFF8, esp_966->tFFFFFFFC, out edx_1810);
						ui32 ecx_990 = ebp_1081->dwFFFFFFC0;
						*eax_982 = 0x2F;
						ui32 esi_974 = esi_1053 - 0x02;
						struct Eq_119403 * edx_1014 = edi_1058;
						Eq_2 eax_1025 = (word32) eax_982 + 1;
						ui32 esi_1000 = ecx_990;
						do
						{
							if ((0x01 << (byte) esi_1000 & esi_974) != 0x00)
							{
								struct Eq_119875 * esp_1012 = esp_1256 - 0x04;
								esp_1012->tFFFFFFFC = edx_1014->a0004[esi_1000].t0000;
								esp_1012->tFFFFFFF8 = edx_1014[esi_1000 * 0x08 / 16];
								esp_1012->tFFFFFFF4 = eax_1025;
								ebp_1081->ptrFFFFFFC8 = edx_1014;
								word32 edx_1808;
								Eq_2 eax_1028 = __mempcpy(esp_1012->tFFFFFFF4, esp_1012->tFFFFFFF8, esp_1012->tFFFFFFFC, out edx_1808);
								edx_1014 = ebp_1081->ptrFFFFFFC8;
								*eax_1028 = 0x2F;
								eax_1025 = (word32) eax_1028 + 1;
								--esi_1000;
								if (esi_1000 == 0x00)
									break;
								continue;
							}
							--esi_1000;
						} while (esi_1000 != 0x00);
						struct Eq_119927 * esp_1044 = esp_1256 - 0x04;
						esp_1044->tFFFFFFFC = ebp_1081->tFFFFFFB8;
						esp_1044->tFFFFFFF8 = ebp_1081->tFFFFFFB0;
						esp_1044->tFFFFFFF4 = eax_1025;
						word32 edx_1809;
						Eq_2 eax_1062 = __mempcpy(esp_1044->tFFFFFFF4, esp_1044->tFFFFFFF8, esp_1044->tFFFFFFFC, out edx_1809);
						*eax_1062 = 0x2F;
						esi_1053 = esi_974;
						edi_1058 = edx_1014;
						eax_1072 = (word32) eax_1062 + 1;
					} while (esi_974 != 0x00);
					ecx_1239 = ebp_1081->tFFFFFFA4;
					if (ebp_1081->dwFFFFFFC4 == 0x00)
					{
l080905B7:
						while (true)
						{
							uint32 edi_1110 = ebp_1081->dwFFFFFFC4;
							Eq_2 edx_1112 = ebp_1081->tFFFFFFD0;
							ui32 ebx_1114 = 0x01 << (byte) ecx_1239;
							uint32 eax_1115 = edi_1110;
							Eq_2 ecx_1120 = ecx_1239;
							if (edi_1110 != 0x00)
							{
								ebp_1081->tFFFFFFD4 = ecx_1239;
								do
								{
									--eax_1115;
									edx_1112 = (word32) edx_1112 + 8;
									while ((ebx_1114 & eax_1115) != 0x00)
									{
										edx_1112 = (word32) edx_1112 + 8;
										*((word32) edx_1112 - 0x0C) = (word32) edi_1058->a0004[ebp_1081->tFFFFFFD4].t0000 + ((word32) (*((word32) edx_1112 - 4)) + 1);
										--eax_1115;
									}
								} while (eax_1115 != 0x00);
								ecx_1120 = ebp_1081->tFFFFFFD4;
							}
							if (ecx_1120 == 0x00)
								break;
							ecx_1239 = ecx_1120 - 0x01;
						}
						uint32 eax_1162 = ebp_1081->dwFFFFFFC4;
						Eq_2 eax_1165 = ebp_1081->tFFFFFFD0;
						uint32 ebx_1164 = eax_1162 - 0x02;
						struct Eq_120030 * edx_1166 = (word32) eax_1165 + 16;
						uint32 eax_1169 = 0x01 << ebp_1081->bFFFFFFA8;
						if (eax_1162 - 0x02 != eax_1169)
						{
							struct Eq_120063 * ecx_1172 = (word32) eax_1165 + 16;
							do
							{
								--ebx_1164;
								if (((byte) ebx_1164 & 0x01) == 0x00)
								{
									++ecx_1172;
									ecx_1172->dwFFFFFFF8 = ecx_1172->dwFFFFFFF8;
									if (ebx_1164 == eax_1169)
										break;
									continue;
								}
								++ecx_1172;
								ecx_1172->dwFFFFFFF8 = ecx_1172->dwFFFFFFF4 + ecx_1172->dwFFFFFFF0;
							} while (ebx_1164 != eax_1169);
							edx_1166 = (word32) eax_1165 + (ebp_1081->dwFFFFFFC4 - eax_1169) * 0x08;
						}
						byte cl_1208 = ebp_1081->bFFFFFFA8;
						Eq_2 esi_1206 = ebp_1081->tFFFFFFB4;
						do
						{
							++edx_1166;
							edx_1166->dwFFFFFFF8 = edx_1166[(~0x07 << cl_1208) / 8].a0000 + ((word32) esi_1206 + 1) / 4;
							--eax_1169;
						} while (eax_1169 != 0x00);
						*ebp_1081->ptr0014 = (word32) *((word32) ebp_1081->tFFFFFFD0 + 4);
						Eq_2 eax_1229 = ebp_1081->tFFFFFFD0;
						ebxOut = ebp_1081->ptrFFFFFFF4;
						return eax_1229;
					}
l0809059A:
					uint32 edx_1083 = ebp_1081->dwFFFFFFC4;
					Eq_2 ecx_1084 = ebp_1081->tFFFFFFD0;
					uint32 eax_1085 = 0x00;
					do
					{
						*((word32) ecx_1084 + (eax_1085 * 0x08 + 4)) = 0x00;
						++eax_1085;
					} while (eax_1085 < edx_1083);
					goto l080905B7;
				}
l080906DB:
				struct Eq_119672 * esp_908 = esp_864 - 0x04;
				esp_908->tFFFFFFFC = edi_1058->t000C;
				esp_908->tFFFFFFF8 = edi_1058->t0008;
				esp_908->tFFFFFFF4 = eax_1072;
				word32 edx_1803;
				Eq_2 eax_923 = __mempcpy(esp_908->tFFFFFFF4, esp_908->tFFFFFFF8, esp_908->tFFFFFFFC, out edx_1803);
				*eax_923 = 0x2F;
				esp_908->tFFFFFFFC = ebp_1081->tFFFFFFB8;
				esp_908->tFFFFFFF8 = ebp_1081->tFFFFFFB0;
				esp_908->tFFFFFFF4 = (word32) eax_923 + 1;
				word32 edx_1804;
				*__mempcpy(esp_908->tFFFFFFF4, esp_908->tFFFFFFF8, esp_908->tFFFFFFFC, out edx_1804) = 0x2F;
				goto l0809059A;
			}
			goto l080906C6;
		}
	}
	struct Eq_119338 * eax_619 = edi_328 + (dwLoc40_1517 * 0x08) / 0x00001000;
	eax_619->t0000 = dwArg04;
	eax_619->t0004 = dwArg08;
	eax_608 = ecx_329 + 0x01;
	goto l080903EE;
}

// 08090790: Register Eq_2 _dl_debug_vdprintf(Register (ptr32 Eq_119859) ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out (ptr32 Eq_119859) ebxOut)
// Called from:
//      _dl_important_hwcaps
//      _dl_debug_printf
//      _dl_debug_printf_c
//      _dl_dprintf
Eq_2 _dl_debug_vdprintf(struct Eq_119859 * ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut, struct Eq_119859 & ebxOut)
{
	int32 esi_101 = 0x00;
	struct Eq_119859 * ebx_110 = ecx;
	struct Eq_120158 * esp_154 = fp - 0x025C;
	byte al_107 = ecx->b0000;
	Eq_84901 dwLoc0234_1023 = 0x00;
	word32 dwLoc0230_1000 = edx;
	if (al_107 == 0x00)
	{
l0809086F:
		ptr32 ecx_677;
		Eq_2 eax_678;
		ptr32 edx_679;
		gs->ptr0010();
		ecxOut = ecx_677;
		edxOut = edx_679;
		ebxOut = ebx;
		return eax_678;
	}
l080907E0:
	struct Eq_119859 * edx_111;
	struct Eq_120178 * ebp_133;
	ptr32 esp_253;
	ptr32 edi_246;
	if (dwLoc0230_1000 != 0x01)
	{
		if (al_107 != 0x25)
			goto l080907F5;
		goto l080908F8;
	}
	while (true)
	{
		ebp_133 = fp - 4;
		if (dwLoc0234_1023 == 0x00)
		{
			Eq_84901 eax_146 = getpid(gs);
			dwLoc0234_1023 = eax_146;
			if (eax_146 < 0x00)
			{
				word32 ecx_1150;
				word32 edx_1151;
				__assert_fail(out ecx_1150, out edx_1151);
				ptr32 ecx_196;
				ptr32 edx_197;
				Eq_2 eax_195 = _dl_sysdep_read_whole_file(gs, 0x080B3BAD, (union Eq_2 *) 0x62, 0x080B3C04, out ecx_196, out edx_197);
				ecxOut = ecx_196;
				edxOut = edx_197;
				ebxOut = ebx_110;
				return eax_195;
			}
			word32 ebp_1153;
			word32 edi_1154;
			word32 ebx_1152;
			Eq_2 eax_220 = _itoa(gs, eax_146, fp - 0x021E, 0x0A, 0x00, out ebx_1152, out ebp_1153, out edi_1154);
			if (eax_220 > fp - 0x0228)
			{
				do
				{
					--eax_220;
					*eax_220 = 0x20;
				} while (eax_220 != fp - 0x0228);
			}
		}
		esp_154 = fp + 16;
		if (esi_101 > 0x3F)
		{
			edi_246 = 0x080CE000;
			esp_253 = fp + 8;
			while (true)
			{
				struct Eq_120253 * esp_282 = esp_253 - 4;
				esp_282->dw0000 = edi_246 + ~0x0001A452;
				esp_282->dwFFFFFFFC = edi_246 + ~0x0001A448;
				word32 edx_1149;
				word32 ecx_1148;
				__assert_fail(out ecx_1148, out edx_1149);
				esp_154 = esp_282 - 4;
l08090BFF:
				edi_246 = ebp_133->ptrFFFFFDB8;
				struct Eq_120220 * esp_275 = esp_154 - 4;
				esp_275->dw0000 = edi_246 + ~0x0001A3FB;
				esp_275->dwFFFFFFFC = 0x78;
				esp_253 = esp_275 - 4;
			}
		}
		(fp - 0x0218)[esi_101].dw0000 = 0x0C;
		(fp - 0x021C)[esi_101].ptr0000 = fp - 0x0228;
		dwLoc0230_1000 = ~0x00;
		al_107 = ebx_110->b0000;
		++esi_101;
		if (al_107 == 0x25)
		{
l080908F8:
			ebp_133 = fp - 4;
			if (esi_101 > 0x3F)
				goto l08090BFF;
			(fp - 0x0218)[esi_101].dw0000 = 0x00;
			edx_111 = ebx_110;
			if (al_107 == 0x25)
				goto l08090920;
			goto l0809085E;
		}
l080907F5:
		ebp_133 = fp - 4;
		if (al_107 == 0x00)
			goto l080908F8;
		int8 cl_52 = (int8) (dwLoc0230_1000 == 0x00);
		if (al_107 == 0x0A && cl_52 == 0x00)
		{
			if (esi_101 > 0x3F)
				goto l08090BFF;
			(fp - 0x0218)[esi_101].dw0000 = 0x00;
			edx_111 = ebx_110;
			goto l080909C1;
		}
		edx_111 = ebx_110;
		do
		{
			++edx_111;
			al_107 = edx_111->b0000;
		} while (al_107 != 0x00 && (al_107 != 0x25 && (al_107 != 0x0A || cl_52 != 0x00)));
		if (esi_101 > 0x3F)
			goto l08090BFF;
		ptr32 edi_93 = edx_111 - ebx_110;
		(fp - 0x0218)[esi_101].ptr0000 = edi_93;
		if (edi_93 != 0x00)
		{
			(fp - 0x021C)[esi_101].ptr0000.b0000 = (byte) ebx_110;
			++esi_101;
		}
		if (al_107 == 0x25)
			break;
l0809085E:
		if (al_107 != 0x0A)
		{
			ebx_110 = edx_111;
			goto l08090864;
		}
		if (ebx_110 != edx_111)
			(fp - 0x0220)[esi_101].dw0000 = (fp - 0x0220)[esi_101].dw0000 + 0x01;
		else
		{
l080909C1:
			(fp - 0x021C)[esi_101].ptr0000.b0000 = (byte) ebx_110;
			(fp - 0x0218)[esi_101].dw0000 = 0x01;
			++esi_101;
		}
		ebx_110 = edx_111 + 1;
		if (edx_111[1] == 0x00)
			break;
	}
l08090920:
	byte bLoc023D_786;
	struct Eq_120275 * ebx_328;
	ci8 al_322 = edx_111[1];
	if (al_322 != 0x30)
	{
		bLoc023D_786 = 0x20;
		ebx_328 = (struct Eq_120275 *) (edx_111 + 1);
		goto l08090936;
	}
l08090AC0:
	ebx_328 = (struct Eq_120275 *) (edx_111 + 2);
	bLoc023D_786 = 0x30;
	al_322 = (ci8) edx_111[2];
l08090936:
	int32 dwLoc023C_787 = ~0x00;
	if (al_322 == 0x2A)
	{
		++ebx_328;
		dwArg04 = (word32) dwArg04 + 4;
		dwLoc023C_787 = (int32) *dwArg04;
		al_322 = ebx_328->b0000;
	}
	Eq_2 edi_344 = ~0x00;
	if (al_322 == 0x2E)
	{
		if (ebx_328[1] != 0x2A)
			goto l08090A9A;
		ebx_328 += 2;
		edi_344 = *dwArg04;
		al_322 = ebx_328->b0000;
		dwArg04 = (word32) dwArg04 + 4;
	}
	if (al_322 == 0x6C || al_322 == 0x5A)
	{
		al_322 = (ci8) ebx_328[1];
		++ebx_328;
	}
	if (al_322 != 115)
	{
		if (al_322 <= 115)
		{
			if (al_322 == 0x25)
			{
				(fp - 0x021C)[esi_101].ptr0000.b0000 = (byte) ebx_328;
				(fp - 0x0218)[esi_101].dw0000 = 0x01;
				++esi_101;
				goto l080909A1;
			}
l08090A9A:
			struct Eq_120481 * esp_561 = esp_154 - 4;
			esp_561->ptr0000 = 0x080B3C04;
			esp_561->dwFFFFFFFC = 0xD8;
			esp_561->ptrFFFFFFF8 = 0x080B3BAD;
			esp_561->ptrFFFFFFF4 = 0x080B3BC6;
			word32 ecx_1157;
			__assert_fail(out ecx_1157, out edx_111);
			esp_154 = esp_561 - 0x0C;
			goto l08090AC0;
		}
		if (al_322 != 117 && al_322 != 0x78)
			goto l08090A9A;
		Eq_2 dwLoc0244_801 = (word32) dwArg04 + 4;
		word32 ecx_444 = *dwArg04;
		struct Eq_120158 * esp_457 = esp_154 - 0x20;
		esp_457->dw001C = esp_457->dw001C;
		word32 edi_464 = esp_457 + 0x0F & ~0x0F;
		word32 eax_470 = 0x10;
		if (al_322 != 0x78)
			eax_470 = 0x0A;
		esp_457->dwFFFFFFF0 = 0x00;
		esp_457->dwFFFFFFEC = eax_470;
		esp_457->dwFFFFFFE8 = edi_464 + 0x0C;
		esp_457->dwFFFFFFE4 = 0x00;
		esp_457->dwFFFFFFE0 = ecx_444;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_84901 stackArg4 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg16 = <invalid>;
		Eq_2 stackArg20 = <invalid>;
		word32 ebx_1162;
		word32 ebp_1163;
		word32 edi_1164;
		Eq_2 eax_515 = _itoa(gs, stackArg4, stackArg12, stackArg16, stackArg20, out ebx_1162, out ebp_1163, out edi_1164);
		esp_154 = esp_457;
		int32 edx_521 = edi_464 + 0x0C - eax_515;
		if (dwLoc023C_787 != ~0x00 && dwLoc023C_787 > edx_521)
		{
			do
			{
				--eax_515;
				*eax_515 = bLoc023D_786;
				edx_521 = edi_464 + 0x0C - eax_515;
			} while (edx_521 < dwLoc023C_787);
		}
		(fp - 0x021C)[esi_101].t0000 = eax_515;
		(fp - 0x0218)[esi_101].dw0000 = edx_521;
		++esi_101;
		dwArg04 = dwLoc0244_801;
	}
	else
	{
		struct Eq_120444 * esp_389 = esp_154 - 0x0C;
		Eq_2 eax_394 = *dwArg04;
		esp_389->tFFFFFFFC = eax_394;
		(fp - 0x021C)[esi_101].t0000 = eax_394;
		Eq_2 dwLoc023C_796 = (word32) dwArg04 + 4;
		word32 ecx_1155;
		word32 edx_1156;
		Eq_2 eax_403 = strlen(esp_389->tFFFFFFFC, out ecx_1155, out edx_1156);
		esp_154 = (struct Eq_120158 *) ((char *) &esp_389->tFFFFFFFC + 16);
		if (edi_344 != ~0x00)
		{
			if (edi_344 > eax_403)
				edi_344 = eax_403;
			(fp - 0x0218)[esi_101].t0000 = edi_344;
		}
		else
			(fp - 0x0218)[esi_101].t0000 = eax_403;
		++esi_101;
		dwArg04 = dwLoc023C_796;
	}
l080909A1:
	ebx_110 = (struct Eq_119859 *) (ebx_328 + 1);
l08090864:
	al_107 = ebx_110->b0000;
	if (al_107 == 0x00)
		goto l0809086F;
	goto l080907E0;
}

// 08090C40: Register Eq_2 _dl_sysdep_read_whole_file(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_2175 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _dl_debug_vdprintf
//      _dl_load_cache_lookup
Eq_2 _dl_sysdep_read_whole_file(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_2175 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_20;
	ptr32 edx_21;
	Eq_2 eax_19 = __open64_nocancel(gs, dwArg04, 0x00080000, dwLoc74, out ecx_20, out edx_21);
	if (eax_19 < 0x00)
	{
		ecxOut = ecx_20;
		edxOut = edx_21;
		return ~0x00;
	}
	Eq_2 esi_100;
	word32 edx_163;
	ptr32 ecx_144;
	if (__fxstat64(gs, eax_19, fp - 0x6C, out ecx_144, out edx_163) >= 0x00)
	{
		*dwArg08 = (union Eq_2 *) dwLoc40;
		if (dwLoc40 != 0x00)
		{
			word32 edx_164;
			esi_100 = mmap(gs, 0x00, dwLoc40, dwArg0C, 0x02, eax_19, 0x00, out ecx_144, out edx_164);
l08090C9C:
			ptr32 edx_94;
			__close_nocancel(gs, eax_19, out edx_94);
			ecxOut = ecx_144;
			edxOut = edx_94;
			return esi_100;
		}
	}
	esi_100.u0 = ~0x00;
	goto l08090C9C;
}

// 08090CD0: Register byte _dl_debug_printf(Register out Eq_48489 ecxOut, Register out (ptr32 byte) edxOut)
// Called from:
//      _dl_non_dynamic_init
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
//      do_lookup_x
//      _dl_lookup_symbol_x
//      _dl_relocate_object
//      _dl_load_cache_lookup
//      add_to_global
//      _dl_show_scope
//      dl_open_worker
//      _dl_close_worker
//      _dl_map_object_deps
//      call_init.part.0
//      _dl_init
//      _dl_check_map_versions
byte _dl_debug_printf(union Eq_48489 & ecxOut, byte & edxOut)
{
	byte * edx_17;
	Eq_48489 ecx_18;
	word32 ebx_31;
	Eq_2 eax_16 = _dl_debug_vdprintf(dwArg04, 0x01, gs, fp + 0x08, out ecx_18, out edx_17, out ebx_31);
	ecxOut = ecx_18;
	edxOut = edx_17;
	return (byte) eax_16;
}

// 08090D10: Register word32 _dl_debug_printf_c(Register out ptr32 edxOut)
// Called from:
//      open_path
//      _dl_lookup_symbol_x
//      _dl_show_scope
word32 _dl_debug_printf_c(ptr32 & edxOut)
{
	ptr32 edx_17;
	word32 ecx_18;
	word32 ebx_30;
	_dl_debug_vdprintf(dwArg04, ~0x00, gs, fp + 0x08, out ecx_18, out edx_17, out ebx_30);
	edxOut = edx_17;
	return ecx_18;
}

// 08090D50: void _dl_dprintf()
// Called from:
//      _dl_non_dynamic_init
//      do_lookup_x
//      _dl_relocate_object
//      _dl_start_profile
//      oom
//      length_mismatch
//      _dl_exception_create_format
//      fatal_error
//      dl_open_worker
//      _dl_close_worker
void _dl_dprintf()
{
	word32 ecx_27;
	word32 edx_28;
	word32 ebx_29;
	_dl_debug_vdprintf(dwArg08, 0x00, gs, fp + 0x0C, out ecx_27, out edx_28, out ebx_29);
}

// 08090D80: Register word32 _dl_name_match_p(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_111145) ecxOut)
// Called from:
//      _dl_map_object
//      check_match
//      _dl_relocate_object
//      _dl_check_map_versions
word32 _dl_name_match_p(Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_111145 & ecxOut)
{
	word32 edx_121;
	struct Eq_111145 * ecx_102;
	if (strcmp(dwArg04, *((word32) dwArg08 + 4), out ecx_102, out edx_121) == 0x00)
	{
l08090DCE:
		ecxOut = ecx_102;
		return 0x01;
	}
	else
	{
		struct Eq_120753 * ebx_31;
		for (ebx_31 = *((word32) dwArg08 + 28); ebx_31 != null; ebx_31 = ebx_31->ptr0004)
		{
			word32 edx_122;
			if (strcmp(dwArg04, ebx_31->t0000, out ecx_102, out edx_122) == 0x00)
				goto l08090DCE;
		}
		ecxOut = ecx_102;
		return 0x00;
	}
}

// 08090DF0: Register word32 _dl_higher_prime_number(Stack uint32 dwArg04)
// Called from:
//      do_lookup_x
word32 _dl_higher_prime_number(uint32 dwArg04)
{
	up32 * ecx_14 = &g_dw80B3C20;
	up32 * edx_15 = &g_dw80B3C98;
	do
	{
		up32 * eax_41;
		int32 eax_19 = edx_15 - ecx_14;
		word32 ebx_25 = ecx_14 + (((eax_19 >> 0x02) >>u 0x1F) + (eax_19 >> 0x02) >> 0x01) * 0x04;
		if (dwArg04 <= *ebx_25)
		{
			while (ecx_14 != ebx_25)
			{
				int32 eax_35 = ebx_25 - ecx_14;
				eax_41 = ecx_14 + (((eax_35 >> 0x02) >>u 0x1F) + (eax_35 >> 0x02) >> 0x01) * 0x04;
				if (*eax_41 < dwArg04)
				{
					edx_15 = ebx_25;
					goto l08090E5A;
				}
				ebx_25 = eax_41;
			}
			return *ebx_25;
		}
		eax_41 = ebx_25;
l08090E5A:
		ecx_14 = eax_41 + 0x04;
	} while (ecx_14 != edx_15);
	return *edx_15;
}

// 08090E70: Register Eq_120826 _dl_strtoul(Stack Eq_2 dwArg04, Stack (ptr32 (ptr32 Eq_120844)) dwArg08)
// Called from:
//      tunable_initialize
//      _dl_non_dynamic_init
Eq_120826 _dl_strtoul(Eq_2 dwArg04, struct Eq_120844 ** dwArg08)
{
	Eq_2 ebp_19 = dwArg04;
	Eq_2 al_22 = *dwArg04;
	if (al_22 == 0x20)
	{
l08090E98:
		do
		{
			ebp_19 = (word32) ebp_19 + 1;
			al_22 = *ebp_19;
		} while (al_22 == 0x20);
	}
	if (al_22 != 0x09)
	{
		byte bLoc1D_275;
		struct Eq_120844 * ebp_129;
		if (al_22 != 0x2D)
		{
			bLoc1D_275 = 0x01;
			ebp_129 = (word32) ebp_19 + (word32) (al_22 == 0x2B);
		}
		else
		{
			ebp_129 = (word32) ebp_19 + 1;
			bLoc1D_275 = 0x00;
		}
		Eq_120826 esi_138;
		int32 eax_406 = (int32) ebp_129->b0000;
		byte al_67 = (byte) eax_406;
		if ((byte) eax_406 > 0x39 || (byte) eax_406 < 0x30)
		{
			esi_138.u0 = 0x00;
			if (dwArg08 == null)
				return esi_138;
			goto l0809100C;
		}
		Eq_936 ecx_65 = 0x0A;
		word32 edx_66 = 0x09;
		if (al_67 == 0x30)
		{
			if ((ebp_129[1] & 223) == 88)
			{
				eax_406 = (int32) ebp_129[2];
				ecx_65.u0 = 0x10;
				ebp_129 += 2;
			}
			else
			{
				ecx_65.u0 = 0x08;
				edx_66 = 0x07;
			}
		}
		Eq_120873 ebx_82 = edx_66 + 0x30;
		esi_138.u0 = 0x00;
		Eq_120877 edi_144 = 0x00;
		Eq_936 ebx_90 = ecx_65 >> 0x1F;
		int32 eax_257 = eax_406;
l08090F7E:
		Eq_120884 eax_101;
		ci8 al_93 = (byte) eax_257;
		if (al_93 > 0x2F)
		{
			Eq_120873 edx_96 = (int32) al_93;
			if (edx_96 <= ebx_82)
			{
				eax_101 = edx_96 - 0x30;
l08090F0C:
				int32 ebx_158 = eax_101 >> 0x1F;
				int64 qwLoc34_353 = SEQ(ebx_158, eax_101);
				up32 edx_181;
				if (edi_144 - edx_181 - (word32) (esi_138 < __udivdi3(SEQ(~ebx_158, ~eax_101), ecx_65, ebx_90, out edx_181)) < 0x00)
				{
					uint64 edx_eax_245 = ecx_65 *64 esi_138;
					ui64 edi_esi_268 = SEQ(SLICE(edx_eax_245, word32, 32) + (ebx_90 *s esi_138 + edi_144 *s ecx_65), (word32) edx_eax_245) + qwLoc34_353;
					++ebp_129;
					esi_138 = (word32) edi_esi_268;
					edi_144 = SLICE(edi_esi_268, word32, 32);
					eax_257 = (int32) ebp_129->b0000;
					goto l08090F7E;
				}
				esi_138.u0 = ~0x00;
				if (dwArg08 == null)
					return esi_138;
l0809100C:
				*dwArg08 = (struct Eq_120844 **) ebp_129;
				return esi_138;
			}
		}
		if (ecx_65 == 0x10)
		{
			if ((byte) eax_257 <= 0x66 && (byte) eax_257 >= 0x61)
			{
				eax_101 = eax_257 - 0x57;
				goto l08090F0C;
			}
			if ((byte) eax_257 <= 0x46 && (byte) eax_257 >= 0x41)
			{
				eax_101 = eax_257 - 55;
				goto l08090F0C;
			}
		}
		if (dwArg08 != null)
			*dwArg08 = (struct Eq_120844 **) ebp_129;
		if (bLoc1D_275 == 0x00)
			esi_138 = -esi_138;
		return esi_138;
	}
	goto l08090E98;
}

// 08091060: void _dl_start_profile(Register (ptr32 Eq_9) gs)
void _dl_start_profile(struct Eq_9 * gs)
{
	uint32 edi_109;
	uint32 ebx_107;
	Eq_2 edi_21 = _dl_profile_map;
	struct Eq_47820 * eax_23 = *((word32) edi_21 + 340);
	struct Eq_121001 * ebp_424 = fp - 4;
	Eq_2 esi_15 = 0x080CE000;
	struct Eq_47820 * edx_26 = eax_23 + ((word32) (*((word32) edi_21 + 348)) << 0x05) / 32;
	if (eax_23 < edx_26)
	{
		Eq_2 ecx_36 = _dl_pagesize;
		ui32 edi_39 = -ecx_36;
		ebx_107 = ~0x00;
		edi_109 = 0x00;
		do
		{
			if (eax_23->dw0000 == 0x01 && (eax_23->b0018 & 0x01) != 0x00)
			{
				uint32 ecx_61 = edi_39 & eax_23->dw0008;
				if (ebx_107 > ecx_61)
					ebx_107 = ecx_61;
				uint32 ecx_72 = eax_23->dw0008 + eax_23->dw0014 + (ecx_36 - 0x01) & edi_39;
				if (edi_109 < ecx_72)
					edi_109 = ecx_72;
				++eax_23;
				if (eax_23 >= edx_26)
					break;
				continue;
			}
			++eax_23;
		} while (eax_23 < edx_26);
	}
	else
	{
		ebx_107 = ~0x00;
		edi_109 = 0x00;
	}
	int32 dwLoc0258_1040;
	running = null;
	log_hashfraction.u1 = 0x04;
	word32 eax_106 = *edi_21;
	ui32 ebx_108 = ebx_107 + eax_106;
	lowpc = ebx_108 & ~0x03;
	Eq_48913 eax_114 = (eax_106 + 0x03 + edi_109 & ~0x03) - (ebx_108 & ~0x03);
	textsize = eax_114;
	if (eax_114 * 0x03 <= 4999)
	{
		fromlimit.u0 = 0x32;
		dwLoc0258_1040 = 0x1300;
	}
	else
	{
		uint32 edx_124 = SLICE(eax_114 * 0x03 *64 1374389535, word32, 32);
		if (eax_114 * 0x03 > 0x06400063)
		{
			fromlimit.u0 = 0x00100000;
			dwLoc0258_1040 = 0x06000040;
		}
		else
		{
			fromlimit = edx_124 >> 0x05;
			dwLoc0258_1040 = (edx_124 >> 0x05) *s 0x60 + 0x40;
		}
	}
	__profile_frequency();
	Eq_2 ebx_163 = _dl_profile_output;
	word32 ecx_1217;
	word32 edx_1218;
	Eq_2 eax_170 = strlen(ebx_163, out ecx_1217, out edx_1218);
	Eq_2 edi_179 = _dl_profile;
	word32 ecx_1219;
	word32 edx_1220;
	ui32 eax_192 = (word32) strlen(edi_179, out ecx_1219, out edx_1220) + ((word32) eax_170 + 37);
	struct Eq_121110 * esp_190 = fp - 636;
	struct Eq_121110 * ecx_195 = fp - 636 - (eax_192 & ~0x0FFF);
	if (fp - 636 != ecx_195)
	{
		do
		{
			esp_190 -= 0x1000;
			esp_190->dw0FFC = esp_190->dw0FFC;
		} while (esp_190 != ecx_195);
	}
	int32 edx_211 = eax_192 & ~0x0F & 0x0FFF;
	if (edx_211 != 0x00)
	{
		esp_190 -= edx_211;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[edx_211 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[edx_211 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	Eq_2 edi_301;
	struct Eq_121131 * esp_224 = esp_190 - 0x08;
	esp_224->tFFFFFFFC = ebx_163;
	Eq_121138 eax_223 = (char *) esp_190 + 0x0F;
	esp_224->tFFFFFFF8 = eax_223 & ~0x0F;
	word32 ecx_1196;
	Eq_2 eax_245 = __stpcpy(esp_224->tFFFFFFF8, esp_224->tFFFFFFFC, out ecx_1196);
	*eax_245 = 0x2F;
	esp_224->tFFFFFFFC = edi_179;
	esp_224->tFFFFFFF8 = (word32) eax_245 + 1;
	word32 ecx_1197;
	Eq_2 eax_266 = __stpcpy(esp_224->tFFFFFFF8, esp_224->tFFFFFFFC, out ecx_1197);
	*eax_266 = 0x6F72702E;
	*((word32) eax_266 + 4) = 0x656C6966;
	*((word32) eax_266 + 8) = 0x00;
	esp_224->t0000.u0 = 0x01B6;
	esp_224->tFFFFFFFC.u0 = 0x00020042;
	esp_224->tFFFFFFF8 = eax_223 & ~0x0F;
	word32 ecx_1198;
	word32 edx_1199;
	Eq_2 eax_288 = __open64_nocancel(gs, esp_224->tFFFFFFF8, esp_224->tFFFFFFFC, esp_224->t0000, out ecx_1198, out edx_1199);
	ptr32 esp_295 = (char *) &esp_224->t0000 + 8;
	if (eax_288 != ~0x00)
	{
		esp_224->t0000 = fp - 0x020C;
		esp_224->tFFFFFFFC = eax_288;
		esp_224->tFFFFFFF8.u0 = 0x03;
		Eq_2 esp_319 = (char *) &esp_224->t0000 + 8;
		word32 edx_1201;
		word32 ecx_1200;
		if (__fxstat64(gs, esp_224->tFFFFFFFC, esp_224->t0000, out ecx_1200, out edx_1201) >= 0x00 && (dwLoc01FC & 0xF000) == 0x8000)
		{
			ptr32 esp_505;
			ui32 ebx_334 = dwLoc0258_1040 + (eax_114 >> 0x01);
			if ((dwLoc01DC | dwLoc01E0) != 0x00)
			{
				if ((dwLoc01DC ^ SLICE((int64) ebx_334, word32, 32) | dwLoc01E0 ^ ebx_334) != 0x00)
				{
					esp_224->tFFFFFFF8 = eax_288;
					word32 edx_1202;
					__close_nocancel(gs, esp_224->tFFFFFFF8, out edx_1202);
					esp_505 = (char *) &esp_224->t0000 + 8;
					goto l080916C3;
				}
l08091368:
				Eq_2 ebx_509 = ebp_424->tFFFFFDB4;
				struct Eq_121311 * esp_511 = esp_319 - 0x08;
				esp_511->tFFFFFFFC.u0 = 0x00;
				esp_511->tFFFFFFF8 = ebx_509;
				esp_511->tFFFFFFF4.u0 = 0x01;
				esp_511->tFFFFFFF0.u0 = 0x03;
				esp_511->tFFFFFFEC = ebp_424->tFFFFFDAC;
				esp_511->tFFFFFFE8.u0 = 0x00;
				word32 edx_1204;
				word32 ecx_1203;
				Eq_2 eax_527 = mmap(gs, esp_511->tFFFFFFE8, esp_511->tFFFFFFEC, esp_511->tFFFFFFF0, esp_511->tFFFFFFF4, esp_511->tFFFFFFF8, esp_511->tFFFFFFFC, out ecx_1203, out edx_1204);
				esp_319 = (char *) &esp_511->t0000 + 8;
				if (eax_527 != ~0x00)
				{
					esp_511->tFFFFFFF8 = ebx_509;
					word32 edx_1205;
					__close_nocancel(gs, esp_511->tFFFFFFF8, out edx_1205);
					word32 edx_629 = ebp_424->dwFFFFFDA4;
					ebp_424->ptrFFFFFD94 = (word32) eax_527 + 56;
					Eq_2 ecx_633 = (word32) eax_527 + 60 + edx_629;
					*((word32) esi_15 + 6756) = ecx_633;
					*((word32) esi_15 + 6768) = (word32) ecx_633 + 4;
					if ((ebp_424->dwFFFFFE28 | ebp_424->dwFFFFFE24) == 0x00)
					{
						word32 eax_751 = ebp_424->dwFFFFFDC4;
						*((word32) eax_527 + 20) = 0x00;
						*eax_527 = eax_751;
						*((word32) eax_527 + 4) = ebp_424->dwFFFFFDC8;
						*((word32) eax_527 + 8) = ebp_424->dwFFFFFDCC;
						*((word32) eax_527 + 0x0C) = ebp_424->dwFFFFFDD0;
						*((word32) eax_527 + 16) = ebp_424->dwFFFFFDD4;
						*((word32) eax_527 + 24) = ebp_424->tFFFFFDD8;
						*((word32) eax_527 + 28) = ebp_424->dwFFFFFDDC;
						*((word32) eax_527 + 32) = ebp_424->dwFFFFFDE0;
						*((word32) eax_527 + 36) = ebp_424->dwFFFFFDE4;
						*((word32) eax_527 + 40) = ebp_424->dwFFFFFDE8;
						*((word32) eax_527 + 44) = ebp_424->dwFFFFFDEC;
						*((word32) eax_527 + 48) = ebp_424->dwFFFFFDF0;
						*((word32) eax_527 + 52) = ebp_424->tFFFFFDF4;
						((word32) ecx_633 - 4)->u0 = 0x01;
						goto l08091455;
					}
					ebp_424->tFFFFFDB4 = ecx_633;
					esp_511->t0000.u0 = 0x14;
					esp_511->tFFFFFFFC = ebp_424 - 0x023C;
					esp_511->tFFFFFFF8 = eax_527;
					word32 edx_1207;
					word32 ecx_1206;
					if (memcmp(esp_511->tFFFFFFF8, esp_511->tFFFFFFFC, esp_511->t0000, out ecx_1206, out edx_1207) == 0x00 && *((word32) eax_527 + 20) == 0x00)
					{
						esp_511->t0000.u0 = 0x20;
						esp_511->tFFFFFFFC = ebp_424 - 0x0228;
						esp_511->tFFFFFFF8 = (word32) eax_527 + 24;
						word32 edx_1225;
						word32 ecx_1224;
						if (memcmp(esp_511->tFFFFFFF8, esp_511->tFFFFFFFC, esp_511->t0000, out ecx_1224, out edx_1225) == 0x00)
						{
							ecx_633 = ebp_424->tFFFFFDB4;
							if (*((word32) ecx_633 - 4) == 0x01)
							{
l08091455:
								Eq_2 eax_784 = ebp_424->dwFFFFFDA0 + ebp_424->dwFFFFFDA4;
								ebp_424->tFFFFFDA8 = ecx_633;
								struct Eq_121528 * esp_780 = esp_319 - 0x08;
								esp_780->tFFFFFFFC.u0 = 0x01;
								esp_780->tFFFFFFF8 = eax_784;
								word32 ecx_1226;
								word32 edx_1227;
								struct Eq_121535 * ebp_796;
								Eq_2 ebx_797;
								Eq_2 edi_799;
								struct Eq_121561 * esi_801;
								Eq_2 eax_795 = __libc_calloc(gs, esp_780->tFFFFFFF8, esp_780->tFFFFFFFC, out ecx_1226, out edx_1227, out ebx_797, out ebp_796, out esi_801, out edi_799);
								struct Eq_121595 * ecx_808 = ebp_796->ptrFFFFFDA8;
								ebp_796->tFFFFFDB4 = eax_795;
								esi_801->t1A60 = eax_795;
								if (eax_795 == 0x00)
								{
									esp_780->t0004 = eax_795;
									esp_780->t0000 = eax_795;
									esp_780->tFFFFFFFC = ebp_796->tFFFFFDAC;
									esp_780->tFFFFFFF8 = edi_799;
									word32 edx_1209;
									word32 ebx_1210;
									word32 ecx_1208;
									__munmap(ebx_797, gs, esp_780->tFFFFFFF8, esp_780->tFFFFFFFC, out ecx_1208, out edx_1209, out ebx_1210);
									esp_780->tFFFFFFFC = (char *) esi_801 - 107208;
									esp_780->tFFFFFFF8.u0 = 0x02;
									_dl_dprintf();
									esp_780->tFFFFFFF8.u0 = 0x7F;
									_exit(gs, esp_780->tFFFFFFF8);
								}
								else
								{
									esi_801->dw1A54 = 0x00;
									word32 eax_857 = Mem855[ebp_796 + -588:word32] + Mem855[ebp_796 + -604:word32];
									uint32 edx_858 = ecx_808->dw0000;
									ebp_796->tFFFFFDAC = eax_857;
									esi_801->t1A5C = eax_857;
									uint32 eax_861 = esi_801->dw1A58;
									if (edx_858 < eax_861)
										eax_861 = ecx_808->dw0000;
									esi_801->dw1A68 = eax_861;
									if (eax_861 != 0x00)
									{
										ebp_796->ptrFFFFFDA8 = ecx_808 - 0x08;
										struct Eq_121595 * eax_876 = ecx_808 - 0x08 + eax_861 * 0x0C;
										do
										{
											ui32 edx_882 = esi_801->dw1A54;
											uint32 ecx_880 = eax_876->dw0004;
											Eq_2 edi_884 = ebp_796->tFFFFFDB4;
											esi_801->dw1A54 = edx_882 + 0x01;
											word16 * ecx_888 = (word32) edi_884 + (ecx_880 >> 0x02) * 0x02;
											word16 di_894 = *ecx_888;
											struct Eq_121761 * ebx_891 = (word32) ebp_796->tFFFFFDAC + edx_882 * 0x08;
											ebx_891->ptr0000 = eax_876;
											ebx_891->w0004 = di_894;
											*ecx_888 = (word16) edx_882;
											eax_876 -= 0x0C;
										} while (eax_876 != ebp_796->ptrFFFFFDA8);
									}
									Eq_2 ebx_902 = esi_801->t1A50;
									Eq_2 eax_905 = 0x00010000;
									Eq_2 ecx_906 = ebp_796->dwFFFFFD9C - ebx_902;
									if (ecx_906 > ebp_796->tFFFFFDA4)
									{
										uint32 eax_914 = (uint32) ((uint64) ecx_906 /u ebp_796->tFFFFFDA4);
										eax_905.u0 = 0x01;
										if (eax_914 <= 0xFFFF)
										{
											if (eax_914 > 0xFF)
												eax_905 = (uint32) (0x00010000 /u eax_914);
											else if (ecx_906 > 0x00FFFFFF)
												eax_905 = (uint32) (0x01000000 /u (uint32) ((uint64) ecx_906 /u (ebp_796->dwFFFFFDB0 >> 0x09)));
											else
												eax_905 = (uint32) (0x01000000 /u (uint32) ((uint64) (ecx_906 << 0x08) /u ebp_796->tFFFFFDA4));
										}
									}
									esp_780->t0004 = eax_905;
									esp_780->t0000 = ebx_902;
									esp_780->tFFFFFFFC = ebp_796->tFFFFFDA4;
									esp_780->tFFFFFFF8 = ebp_796->tFFFFFD94;
									profil(gs, esp_780->tFFFFFFF8)->dw1A6C = 0x01;
									return;
								}
							}
						}
					}
					struct Eq_122006 * esp_694 = esp_319 - 0x08;
					esp_694->tFFFFFFFC = ebp_424->tFFFFFDAC;
					esp_694->tFFFFFFF8 = eax_527;
					word32 ebx_1223;
					word32 ecx_1221;
					word32 edx_1222;
					__munmap(esi_15, gs, esp_694->tFFFFFFF8, esp_694->tFFFFFFFC, out ecx_1221, out edx_1222, out ebx_1223);
					esp_505 = (char *) &esp_694->tFFFFFFFC + 0x0C;
l080916C3:
					struct Eq_122125 * esp_721 = esp_505 - 4;
					esp_721->dw0000 = *ebp_424->ptrFFFFFD98;
					esp_721->tFFFFFFFC = ebp_424->tFFFFFDA8;
					esp_721->ptrFFFFFFF8 = (word32) esi_15 - 107260;
					esp_721->dwFFFFFFF4 = 0x02;
					_dl_dprintf();
					return;
				}
			}
			else
			{
				Eq_2 ecx_346 = _dl_pagesize;
				Eq_2 edx_350 = (char *) &esp_224->t0000 + 8 - ((word32) ecx_346 + 0x0F & ~0x0FFF);
				ui32 ebx_351 = (word32) ecx_346 + 0x0F & ~0x0F;
				if ((char *) &esp_224->t0000 + 8 != edx_350)
				{
					do
					{
						esp_319 -= 0x1000;
						*((word32) esp_319 + 0x0FFC) = *((word32) esp_319 + 0x0FFC);
					} while (esp_319 != edx_350);
				}
				if ((ebx_351 & 0x0FFF) != 0x00)
				{
					esp_319 -= ebx_351 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_319 - 0x04)[(ebx_351 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_319 - 0x04)[(ebx_351 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_121634 * esp_379 = esp_319 - 0x04;
				esp_379->tFFFFFFFC = ecx_346;
				esp_379->tFFFFFFF8.u0 = 0x00;
				esp_379->tFFFFFFF4 = esp_319;
				word32 edx_1212;
				word32 ecx_1211;
				memset(esp_379->tFFFFFFF4, esp_379->tFFFFFFF8, esp_379->tFFFFFFFC, out ecx_1211, out edx_1212);
				esp_379->tFFFFFFFC.u0 = 0x00;
				esp_379->tFFFFFFF8 = -ecx_346 & ebx_334;
				esp_379->tFFFFFFF4 = eax_288;
				Eq_2 esp_430 = <invalid>;
				ui32 * edi_427;
				word32 ebx_1214;
				word32 ecx_1213;
				if (__libc_lseek(gs, esp_379->tFFFFFFF4, esp_379->tFFFFFFF8, esp_379->tFFFFFFFC, out ecx_1213, out ebx_1214, out ebp_424, out esi_15, out edi_427) != ~0x00)
				{
					do
					{
						*((word32) esp_430 + 8) = *edi_427 - 0x01 & ebp_424->tFFFFFDAC;
						*((word32) esp_430 + 4) = ebp_424->ptrFFFFFD94;
						*esp_430 = ebp_424->tFFFFFDB4;
						int32 eax_458 = __write_nocancel(gs, *esp_430, *((word32) esp_430 + 4), *((word32) esp_430 + 8));
						if (eax_458 != ~0x00)
						{
							if (eax_458 < 0x00)
								break;
							esp_319 = ebp_424->tFFFFFD90;
							goto l08091368;
						}
					} while (gs->tFFFFFFE0 == 0x04);
				}
				esp_319 = ebp_424->tFFFFFD90;
			}
		}
		struct Eq_121891 * esp_543 = esp_319 - 0x0C;
		edi_301 = gs->tFFFFFFE0;
		esp_543->tFFFFFFFC = ebp_424->tFFFFFDB4;
		word32 edx_1215;
		__close_nocancel(gs, esp_543->tFFFFFFFC, out edx_1215);
		esp_295 = (char *) &esp_543->tFFFFFFFC + 16;
	}
	else
		edi_301 = gs->tFFFFFFE0;
	struct Eq_121920 * esp_567 = esp_295 - 0x04;
	esp_567->tFFFFFFFC.u0 = 400;
	esp_567->tFFFFFFF8 = ebp_424 - 424;
	esp_567->tFFFFFFF4 = edi_301;
	Eq_2 esp_586 = <invalid>;
	struct Eq_121936 * ebp_580;
	Eq_2 ebx_581;
	word32 esi_1216;
	*((word32) esp_586 - 4) = strerror_r(gs, esp_567->tFFFFFFF4, esp_567->tFFFFFFF8, esp_567->tFFFFFFFC, out ebx_581, out ebp_580, out esi_1216);
	*((word32) esp_586 - 8) = ebp_580->tFFFFFDA8;
	*((word32) esp_586 - 0x0C) = ebx_581;
	((word32) esp_586 - 16)->u0 = 0x02;
	_dl_dprintf();
}

// 080918B0: Register Eq_2 _dl_mcount(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_48912) ecxOut, Register out Eq_48913 edxOut)
// Called from:
//      _dl_mcount_wrapper
//      _dl_mcount_wrapper_check
//      _dl_profile_fixup
Eq_2 _dl_mcount(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_48912 & ecxOut, union Eq_48913 & edxOut)
{
	struct Eq_48912 * ecx_7 = running;
	if (ecx_7 == null)
	{
		ecxOut = ecx_7;
		edxOut = edx;
		return <invalid>;
	}
	struct Eq_48912 * ecx_197 = lowpc;
	Eq_48913 edx_176 = textsize;
	Eq_48913 ebx_109 = dwArg04 - ecx_197;
	if (edx_176 <= ebx_109)
		ebx_109.u0 = 0x00;
	Eq_48913 edi_35 = dwArg08 - ecx_197;
	if (edx_176 <= edi_35)
	{
l08091AAE:
		ecxOut = ecx_197;
		edxOut = edx_176;
		return <invalid>;
	}
	struct Eq_122187 * esi_248;
	word32 esi_43 = tos;
	struct Eq_122191 * edi_47 = esi_43 + (edi_35 >> log_hashfraction) * 0x02;
	ui32 edx_175 = (word32) edi_47->w0000;
	struct Eq_122191 * dwLoc2C_286 = edi_47;
	if (edx_175 != 0x00)
	{
l08091920:
		struct Eq_122216 * edi_55 = froms;
		ecx_197 = (struct Eq_48912 *) (edi_55 + (edx_175 * 0x08) / 22);
		esi_248 = ecx_197->dw0000;
		edx_176 = esi_248->t0000;
		if (edx_176 == ebx_109)
			goto l08091AA0;
		ui32 edx_63 = (word32) ecx_197[1];
		if ((word16) edx_63 != 0x00)
		{
			do
			{
				ecx_197 = (struct Eq_48912 *) (edi_55 + (edx_63 * 0x08) / 22);
				edx_63 = (word32) ecx_197[1];
				esi_248 = ecx_197->dw0000;
			} while ((word16) edx_63 != 0x00 && esi_248->t0000 != ebx_109);
		}
		edx_176 = esi_248->t0000;
		if (edx_176 == ebx_109)
		{
l08091AA0:
			if (gs->t000C != 0x00)
				__lock();
			++esi_248->dw0008;
			goto l08091AAE;
		}
		dwLoc2C_286 = (struct Eq_122191 *) (ecx_197 + 1);
	}
	union Eq_27327 * esi_98 = narcsp;
	Eq_27327 edx_113 = narcs;
	if (edx_113 != *esi_98 && fromlimit > edx_113)
	{
		struct Eq_122282 * esi_107 = data;
		struct Eq_122216 * edi_108 = froms;
		do
		{
			struct Eq_122295 * ebp_116 = esi_107 + (edx_113 * 0x0C) / 24;
			uint32 ecx_119 = ebp_116->dw0004;
			if (gs->t000C != 0x00)
				__lock();
			fromidx = __xadd(fromidx, 0x01);
			edi_108->ptr0010 = ebp_116;
			word16 * ecx_142 = esi_43 + (ecx_119 >> 0x02) * 0x02;
			edi_108->w0014 = *ecx_142;
			*ecx_142 = 0x02;
			if (gs->t000C != 0x00)
				__lock();
			narcs = (word32) narcs + 1;
			edx_113 = narcs;
		} while (*esi_98 != edx_113 && edx_113 < fromlimit);
	}
	if (dwLoc2C_286->w0000 == 0x00)
	{
		edx_176.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		*esi_98 = (union Eq_27327 *) __xadd(*esi_98, 0x01);
		ecx_197 = (struct Eq_48912 *) 0x01;
		if (fromlimit > 0x01)
		{
			if (gs->t000C != 0x00)
				__lock();
			fromidx = __xadd(fromidx, 0x01);
			struct Eq_122216 * esi_217 = froms;
			dwLoc2C_286->w0000 = 0x02;
			struct Eq_122379 * esi_224 = esi_217 + ((word32) dwLoc2C_286->w0000 * 0x08) / 22;
			struct Eq_122282 * edx_225 = data;
			esi_224->ptr0000 = (struct Eq_122187 *) &edx_225->t000C;
			edx_225->t000C = ebx_109;
			edx_225->dw0014 = 0x00;
			edx_225->t0010 = edi_35;
			esi_224->w0004 = 0x00;
			ecx_197 = (struct Eq_48912 *) 0x03;
			edx_176.u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			narcs = (word32) narcs + 1;
			esi_248 = esi_224->ptr0000;
			goto l08091AA0;
		}
		goto l08091AAE;
	}
	edx_175 = (word32) dwLoc2C_286->w0000;
	goto l08091920;
}

// 08091B00: Register Eq_2 allocate_dtv(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_allocate_tls_storage
//      _dl_allocate_tls
Eq_2 allocate_dtv(struct Eq_9 * gs)
{
	Eq_2 edi_32;
	word32 esi_34;
	word32 ebp_84;
	word32 ebx_83;
	word32 edx_82;
	word32 ecx_81;
	Eq_2 eax_28 = __libc_calloc(gs, (word32) _dl_tls_max_dtv_idx + 16, 0x08, out ecx_81, out edx_82, out ebx_83, out ebp_84, out esi_34, out edi_32);
	if (eax_28 != 0x00)
	{
		*eax_28 = esi_34;
		*((word32) edi_32 + 4) = (word32) eax_28 + 8;
		eax_28 = edi_32;
	}
	return eax_28;
}

// 08091B40: void oom(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_allocate_tls
void oom(struct Eq_9 * gs)
{
	_dl_dprintf();
	_exit(gs, 0x7F);
}

// 08091B70: Register Eq_2 _dl_next_tls_modid()
// Called from:
//      _dl_map_object_from_fd.constprop.8
//      oom
Eq_2 _dl_next_tls_modid()
{
	Eq_2 eax_102;
	Eq_2 esp_18 = fp - 44;
	Eq_2 eax_21 = _dl_tls_max_dtv_idx;
	if (g_b80CFEC4 == 0x00)
	{
		eax_102 = (word32) eax_21 + 1;
		goto l08091BA4;
	}
	Eq_2 eax_28 = _dl_tls_static_nelem;
	eax_102 = (word32) eax_28 + 1;
	if ((word32) eax_28 + 1 <= eax_21)
	{
		Eq_2 edx_38 = _dl_tls_dtv_slotinfo_list;
		up32 edi_34 = 0x00;
		uint32 ebp_130 = *edx_38;
		do
		{
l08091BE0:
			uint32 esi_45 = eax_102 - edi_34;
			if (esi_45 >= ebp_130)
				goto l08091C18;
			if (*((word32) edx_38 + (esi_45 * 0x08 + 0x0C)) == 0x00)
				goto l08091C28;
			eax_102 = (word32) eax_102 + 1;
		} while (*((word32) esp_18 + 0x0C) >= eax_102);
		struct Eq_122541 * esp_61 = esp_18 - 4;
		esp_61->ptr0000 = 134954744;
		esp_61->dwFFFFFFFC = 0x49;
		esp_61->ptrFFFFFFF8 = 0x080B3F0B;
		esp_61->ptrFFFFFFF4 = 134954396;
		word32 ecx_201;
		eax_102 = __assert_fail(out ecx_201, out edx_38);
		esp_18.u0 = <invalid>;
l08091C18:
		edx_38 = *((word32) edx_38 + 4);
		edi_34 += ebp_130;
		if (edx_38 != 0x00)
		{
			ebp_130 = (uint32) *edx_38;
			goto l08091BE0;
		}
l08091C28:
		if (eax_102 <= *((word32) esp_18 + 4))
			return eax_102;
	}
	if ((word32) *((word32) esp_18 + 4) + 1 != eax_102)
	{
		struct Eq_122565 * esp_109 = esp_18 - 4;
		esp_109->ptr0000 = 134954744;
		esp_109->dwFFFFFFFC = 0x57;
		esp_109->ptrFFFFFFF8 = 0x080B3F0B;
		esp_109->ptrFFFFFFF4 = 134954436;
		word32 ecx_202;
		word32 edx_203;
		__assert_fail(out ecx_202, out edx_203);
	}
	**((byte) esp_18.u0 + 8) = 0x00;
l08091BA4:
	_dl_tls_max_dtv_idx = eax_102;
	return eax_102;
}

// 08091C70: void _dl_count_modids()
// Called from:
//      _dl_next_tls_modid
void _dl_count_modids()
{
	if (g_b80CFEC4 == 0x00)
		return;
	Eq_2 ecx_11 = _dl_tls_dtv_slotinfo_list;
	if (ecx_11 == 0x00)
		return;
	do
	{
		word32 ebx_23 = *ecx_11;
		word32 edx_24 = 0x00;
		if (ebx_23 != 0x00)
		{
			do
				++edx_24;
			while (edx_24 != ebx_23);
		}
		ecx_11 = *((word32) ecx_11 + 4);
	} while (ecx_11 != 0x00);
}

// 08091CE0: void _dl_get_tls_static_info(Stack (ptr32 word32) dwArg04, Stack (ptr32 Eq_114606) dwArg08)
void _dl_get_tls_static_info(word32 * dwArg04, union Eq_114606 * dwArg08)
{
	*dwArg04 = _dl_tls_static_size;
	*dwArg08 = (union Eq_114606 *) _dl_tls_static_align;
}

// 08091D10: Register (ptr32 Eq_122639) _dl_allocate_tls_storage(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_allocate_tls
struct Eq_122639 * _dl_allocate_tls_storage(struct Eq_9 * gs)
{
	word32 ebp_29;
	Eq_122642 edi_32;
	word32 ecx_171;
	word32 edx_172;
	word32 ebx_173;
	word32 esi_174;
	Eq_2 eax_28 = __libc_malloc(gs, dwLoc40, (word32) _dl_tls_static_align + (_dl_tls_static_size + 0x04), out ecx_171, out edx_172, out ebx_173, out ebp_29, out esi_174, out edi_32);
	if (eax_28 == 0x00)
		return null;
	struct Eq_122667 * edx_62 = ebp_29 - 0x04C0 + (uint32) ((uint64) ((word32) edi_32 + (eax_28 - 0x01)) /u edi_32) *s edi_32;
	edx_62->dw0000 = 0x00;
	edx_62[303] = (struct Eq_122667) 0x00;
	word32 edi_127 = edx_62 + 0x04 & ~0x03;
	word32 ecx_130;
	for (ecx_130 = edx_62 - edi_127 + 0x04C0 >>u 0x02; ecx_130 != 0x00; --ecx_130)
	{
		edi_127->dw0000 = 0x00;
		edi_127 += 4;
	}
	edx_62[304] = (struct Eq_122667) eax_28;
	struct Eq_122639 * eax_79 = allocate_dtv(gs);
	if (eax_79 != null)
		return eax_79;
	word32 ecx_175;
	word32 edx_176;
	free(gs, dwLoc40, eax_28, out ecx_175, out edx_176);
	return eax_79;
}

// 08091DD0: void _dl_allocate_tls_init(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_122639) dwArg04)
// Called from:
//      _dl_allocate_tls
void _dl_allocate_tls_init(struct Eq_9 * gs, struct Eq_122639 * dwArg04)
{
	Eq_2 esp_25 = fp - 0x3C;
	if (dwArg04 == null)
		return;
	ui32 ebp_323;
	Eq_2 esi_337;
	Eq_2 edi_341;
	struct Eq_122733 * esp_357;
	up32 edx_298;
	Eq_2 eax_238 = _dl_tls_max_dtv_idx;
	if (dwArg04->ptr0004->tFFFFFFF8 >= eax_238)
	{
l08091E15:
		*((word32) esp_25 + 8) = 0x00;
		((word32) esp_25 + 16)->u0 = 0x00;
		Eq_2 ebx_46 = _dl_tls_dtv_slotinfo_list;
		*((word32) esp_25 + 28) = &_dl_tls_generation;
		*((word32) esp_25 + 4) = ebx_46;
		do
		{
			Eq_2 edi_51 = *((word32) esp_25 + 16);
			uint32 ebx_57 = (uint32) (int8) (edi_51 == 0x00);
			uint32 esi_234 = ebx_57;
			Eq_2 ebx_236 = (word32) edi_51 + ebx_57;
			if (ebx_57 < *(*((word32) esp_25 + 4)))
			{
				do
				{
					Eq_2 esp_138 = esp_25;
					if (ebx_236 > eax_238)
						goto l08091F32;
					Eq_2 ecx_69 = *((word32) esp_25 + 4);
					Eq_2 eax_71 = *((word32) ecx_69 + (esi_234 * 0x08 + 0x0C));
					if (eax_71 != 0x00)
					{
						up32 edx_103 = *((word32) ecx_69 + (esi_234 * 0x08 + 8));
						if (edx_103 > *(*((word32) esp_25 + 28)))
						{
							word32 esi_79 = *((word32) esp_25 + 0x0C);
							struct Eq_123281 * esp_81 = esp_25 - 4;
							esp_81->dw0000 = esi_79 + ~0x0001A11F;
							esp_81->dwFFFFFFFC = 0x01E1;
							esp_81->dwFFFFFFF8 = esi_79 + ~0x0001A0F4;
							esp_81->dwFFFFFFF4 = esi_79 + ~0x0001A213;
							word32 ecx_553;
							eax_238 = __assert_fail(out ecx_553, out edx_298);
							esp_25.u0 = <invalid>;
							goto l0809203F;
						}
						up32 edi_98 = *((word32) esp_25 + 8);
						Eq_2 ecx_99 = *((word32) eax_71 + 0x0244);
						if (edi_98 >= edx_103)
							edx_103 = edi_98;
						Eq_2 edi_106 = *((word32) eax_71 + 584);
						*((word32) esp_25 + 8) = edx_103;
						struct Eq_123071 * edx_111 = (word32) *((word32) esp_25 + 24) + edi_106 * 0x08;
						edx_111->t0000.u0 = ~0x00;
						edx_111->dw0004 = 0x00;
						if (ecx_99 <= 0x00)
							goto l08091F12;
						if (edi_106 == ebx_236)
						{
							Eq_2 edi_120 = *((word32) eax_71 + 568);
							Eq_2 ebp_121 = *((word32) eax_71 + 564);
							if (edi_120 >= ebp_121)
							{
								if (ecx_99 < edi_120)
									goto l080920A9;
								Eq_2 ebx_191 = *((word32) esp_25 + 64) - ecx_99;
								edx_111->t0000 = ebx_191;
								struct Eq_123107 * esp_189 = esp_25 - 0x04;
								esp_189->tFFFFFFFC = ebp_121;
								esp_189->tFFFFFFF8 = *((word32) eax_71 + 560);
								esp_189->tFFFFFFF4 = ebx_191;
								word32 edx_544;
								Eq_2 eax_202 = __mempcpy(esp_189->tFFFFFFF4, esp_189->tFFFFFFF8, esp_189->tFFFFFFFC, out edx_544);
								esp_189->tFFFFFFFC = edi_120 - ebp_121;
								esp_189->tFFFFFFF8.u0 = 0x00;
								esp_189->tFFFFFFF4 = eax_202;
								word32 ecx_545;
								word32 edx_546;
								memset(esp_189->tFFFFFFF4, esp_189->tFFFFFFF8, esp_189->tFFFFFFFC, out ecx_545, out edx_546);
								goto l08091F12;
							}
							word32 esi_124 = *((word32) esp_25 + 0x0C);
							struct Eq_123249 * esp_126 = esp_25 - 4;
							esp_126->dw0000 = esi_124 + ~0x0001A11F;
							esp_126->dwFFFFFFFC = 0x01EC;
							esp_126->dwFFFFFFF8 = esi_124 + ~0x0001A0F4;
							esp_126->dwFFFFFFF4 = esi_124 + ~0x0001A1BF;
							word32 ecx_551;
							word32 edx_552;
							__assert_fail(out ecx_551, out edx_552);
							esp_138.u0 = <invalid>;
l080920A9:
							word32 esi_148 = *((word32) esp_138 + 0x0C);
							struct Eq_123185 * esp_150 = esp_138 - 4;
							esp_150->dw0000 = esi_148 + ~0x0001A11F;
							esp_150->dwFFFFFFFC = 0x01EE;
							esp_150->dwFFFFFFF8 = esi_148 + ~0x0001A0F4;
							esp_150->dwFFFFFFF4 = esi_148 + 4294860404;
							word32 ecx_547;
							word32 edx_548;
							__assert_fail(out ecx_547, out edx_548);
							esp_138.u0 = <invalid>;
						}
						word32 esi_169 = *((byte) esp_138.u0 + 0x0C);
						struct Eq_123217 * esp_171 = esp_138 - 4;
						esp_171->dw0000 = esi_169 + ~0x0001A11F;
						esp_171->dwFFFFFFFC = 0x01EB;
						esp_171->dwFFFFFFF8 = esi_169 + ~0x0001A0F4;
						esp_171->dwFFFFFFF4 = esi_169 + ~0x0001A1DF;
						word32 edx_550;
						word32 ecx_549;
						__assert_fail(out ecx_549, out edx_550);
						goto l080920EF;
					}
l08091F12:
					++esi_234;
					ebx_236 = (word32) *((word32) esp_25 + 16) + esi_234;
					eax_238 = **((word32) esp_25 + 20);
				} while (**((word32) esp_25 + 4) > esi_234);
			}
			*((word32) esp_25 + 16) = ebx_236;
			if (eax_238 <= ebx_236)
			{
l08091F32:
				**((word32) esp_25 + 24) = *((word32) esp_25 + 8);
				return;
			}
			Eq_2 esi_267 = *((word32) *((word32) esp_25 + 4) + 4);
			*((word32) esp_25 + 4) = esi_267;
		} while (esi_267 != 0x00);
		word32 esi_272 = *((word32) esp_25 + 0x0C);
		struct Eq_122802 * esp_274 = esp_25 - 4;
		esp_274->dw0000 = esi_272 + ~0x0001A11F;
		esp_274->dwFFFFFFFC = 0x0205;
		esp_274->dwFFFFFFF8 = esi_272 + ~0x0001A0F4;
		esp_274->dwFFFFFFF4 = esi_272 + ~0x0001A0EB;
		word32 edx_531;
		word32 ecx_530;
		eax_238 = __assert_fail(out ecx_530, out edx_531);
		esp_25.u0 = <invalid>;
	}
	*((byte) esp_25.u0 + 4) = (word32) eax_238 + 0x0E;
	edx_298 = 0x080CFCC0;
	if (*((byte) esp_25.u0 + 24) != 0x080CFCC8)
	{
		struct Eq_122841 * esp_359 = esp_25 - 0x08;
		esp_359->tFFFFFFFC = eax_238 * 0x08 + 0x80;
		esp_359->tFFFFFFF8 = esp_359->dw0020 - 0x08;
		Eq_2 esp_373 = <invalid>;
		word32 edi_534;
		word32 esi_533;
		word32 edx_532;
		Eq_2 eax_374 = __realloc(gs, esp_359->tFFFFFFF4, esp_359->tFFFFFFF8, esp_359->tFFFFFFFC, out edx_532, out ebp_323, out esi_533, out edi_534);
		esp_357 = (word32) esp_373 + 16;
		esi_337 = eax_374;
		if (eax_374 != 0x00)
		{
			edi_341 = ebp_323 * 0x08 + 0x10;
			goto l08091FE3;
		}
	}
	else
	{
l0809203F:
		*((word32) esp_25 + 8) = edx_298;
		struct Eq_122953 * esp_308 = esp_25 - 0x0C;
		esp_308->tFFFFFFFC = eax_238 * 0x08 + 0x80;
		word32 esi_540;
		word32 edi_541;
		word32 ecx_537;
		word32 edx_538;
		word32 ebx_539;
		Eq_2 eax_322 = __libc_malloc(gs, esp_308->tFFFFFFF8, esp_308->tFFFFFFFC, out ecx_537, out edx_538, out ebx_539, out ebp_323, out esi_540, out edi_541);
		Eq_2 edx_334 = esp_308->t0014;
		esi_337 = eax_322;
		if (eax_322 != 0x00)
		{
			edi_341 = ebp_323 * 0x08 + 0x10;
			esp_308->t0004 = edi_341;
			esp_308->t0000 = edx_334;
			esp_308->tFFFFFFFC = eax_322;
			word32 ecx_542;
			word32 edx_543;
			memcpy(esp_308->tFFFFFFFC, esp_308->t0000, esp_308->t0004, out ecx_542, out edx_543);
			esp_357 = (struct Eq_122733 *) ((char *) &esp_308->t0004 + 8);
l08091FE3:
			ui32 eax_393 = esp_357->dw0004;
			*esi_337 = eax_393;
			struct Eq_122894 * esp_397 = esp_357 - 0x04;
			esp_397->tFFFFFFFC = eax_393 - ebp_323 << 0x03;
			esp_397->tFFFFFFF8.u0 = 0x00;
			Mem408[esp_397 + -0x0C:word32] = edi_341 + esi_337;
			word32 ecx_535;
			word32 edx_536;
			memset(esp_397->tFFFFFFF4, esp_397->tFFFFFFF8, esp_397->tFFFFFFFC, out ecx_535, out edx_536);
			ptr32 eax_418 = (word32) esi_337 + 8;
			struct Eq_122929 * esi_419 = esp_397->ptr0044;
			esp_397->ptr001C = eax_418;
			esi_419->ptr0004 = eax_418;
			esp_25 = (char *) &esp_397->tFFFFFFFC + 8;
			eax_238 = *esp_397->ptr0018;
			goto l08091E15;
		}
	}
l080920EF:
	oom(gs);
}

// 08092100: void _dl_allocate_tls(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
// Called from:
//      _dl_allocate_tls_init
void _dl_allocate_tls(struct Eq_9 * gs, word32 dwArg04)
{
	if (dwArg04 == 0x00)
	{
		struct Eq_122639 * eax_11 = _dl_allocate_tls_storage(gs);
		_dl_allocate_tls_init(gs, eax_11);
	}
	else
	{
		struct Eq_122639 * eax_25 = allocate_dtv(gs);
		_dl_allocate_tls_init(gs, eax_25);
	}
}

// 08092140: void _dl_deallocate_tls(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_123325) dwArg04, Stack byte bArg08)
void _dl_deallocate_tls(struct Eq_9 * gs, struct Eq_123325 * dwArg04, byte bArg08)
{
	struct Eq_123327 * edi_21 = dwArg04->ptr0004;
	if (edi_21->dwFFFFFFF8 != 0x00)
	{
		uint32 esi_29 = 0x00;
		do
		{
			++esi_29;
			word32 ecx_175;
			word32 edx_176;
			free(gs, dwLoc30, edi_21->a0004[esi_29].t0000, out ecx_175, out edx_176);
		} while (esi_29 < edi_21->dwFFFFFFF8);
	}
	if (edi_21 != &g_t80CFCC8)
	{
		word32 ecx_177;
		word32 edx_178;
		free(gs, dwLoc30, edi_21 - 0x08, out ecx_177, out edx_178);
	}
	if ((byte) dwArg08 == 0x00)
		return;
	word32 ecx_179;
	word32 edx_180;
	free(gs, dwLoc30, dwArg04->t04C0, out ecx_179, out edx_180);
}

// 080921E0: Register word32 _dl_tls_get_addr_soft(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_123381) dwArg04)
// Called from:
//      dlinfo_doit
//      __dl_iterate_phdr
word32 _dl_tls_get_addr_soft(struct Eq_9 * gs, struct Eq_123381 * dwArg04)
{
	uint32 eax_16 = dwArg04->dw0248;
	if (eax_16 == 0x00)
		return 0x00;
	struct Eq_123389 * edx_21 = gs->ptr0004;
	Eq_123392 edi_23 = edx_21->a0000[0].dw0000;
	if (edi_23 != _dl_tls_generation.dw0000)
	{
		if (eax_16 >= edx_21->dwFFFFFFF8)
			return 0x00;
		Eq_2 ecx_30 = _dl_tls_dtv_slotinfo_list;
		uint32 ebx_29 = eax_16;
		uint32 esi_31 = *ecx_30;
		if (eax_16 >= esi_31)
		{
			uint32 esi_34 = esi_31;
			do
			{
				ecx_30 = *((word32) ecx_30 + 4);
				ebx_29 -= esi_34;
				esi_34 = (uint32) *ecx_30;
			} while (esi_34 <= ebx_29);
		}
		if (edi_23 < *((word32) ecx_30 + (ebx_29 * 0x08 + 8)))
			return 0x00;
	}
	word32 eax_103 = edx_21[eax_16 * 0x08];
	if (eax_103 == ~0x00)
		eax_103 = 0x00;
	return eax_103;
}

// 08092260: Register word32 _dl_add_to_slotinfo(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_123437) ebpOut, Register out Eq_123438 esiOut, Register out (ptr32 Eq_123439) ediOut)
// Called from:
//      dl_open_worker
word32 _dl_add_to_slotinfo(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_123437 & ebpOut, union Eq_123438 & esiOut, struct Eq_123439 & ediOut)
{
	ptr32 ebx_17 = 0x080CE000;
	Eq_2 esi_146 = *((word32) dwArg04 + 584);
	Eq_2 edi_129 = _dl_tls_dtv_slotinfo_list;
	while (true)
	{
		word32 edx_138;
		Eq_2 eax_26 = *edi_129;
		if (eax_26 > esi_146)
			break;
		esi_146 -= eax_26;
		Eq_2 eax_31 = *((word32) edi_129 + 4);
		if (eax_31 == 0x00)
		{
			Eq_2 eax_51;
			if (esi_146 == 0x00)
			{
				struct Eq_123474 * edi_67;
				word32 ecx_224;
				word32 edx_225;
				word32 ebp_226;
				Eq_2 eax_63 = __libc_malloc(gs, dwLoc30, 0x01F8, out ecx_224, out edx_225, out ebx_17, out ebp_226, out esi_146, out edi_67);
				edi_67->t0004 = eax_63;
				eax_51.u0 = 0x080CFEC8;
				edx_138 = _dl_tls_generation.dw0000 + 0x01;
				if (eax_63 != 0x00)
				{
					eax_63->u0 = 0x3E;
					((word32) eax_63 + 4)->u0 = 0x00;
					word32 ecx_122;
					word32 * edi_125 = (word32) eax_63 + 8;
					for (ecx_122 = 0x7C; ecx_122 != 0x00; --ecx_122)
					{
						*edi_125 = (word32) esi_146;
						++edi_125;
					}
					edi_129 = eax_63;
					goto l080922AC;
				}
			}
			else
			{
				word32 ecx_223;
				eax_51 = __assert_fail(out ecx_223, out edx_138);
			}
			*eax_51.u0 = edx_138;
			struct Eq_123437 * ebp_100;
			struct Eq_123439 * edi_103;
			word32 ecx_227;
			word32 edx_228;
			word32 ebx_229;
			_dl_signal_error(gs, 0x0C, ebx_17 + ~0x0001A157, out ecx_227, out edx_228, out ebx_229, out ebp_100, out edi_103);
			Eq_2 eax_91 = ebx_17 + ~0x0001A0D4;
			word32 ebx_111;
			Eq_123438 esi_114;
			_dl_get_origin(gs, eax_91, out ebx_111, out esi_114);
			ebpOut = ebp_100;
			esiOut = esi_114;
			ediOut = edi_103;
			return ebx_111;
		}
		edi_129 = eax_31;
	}
	edx_138 = _dl_tls_generation.dw0000 + 0x01;
l080922AC:
	struct Eq_123548 * eax_148 = (word32) edi_129 + esi_146 * 0x08;
	eax_148->dw0008 = edx_138;
	eax_148->t000C = dwArg04;
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return ebx;
}

// 08092350: Register Eq_2 _dl_get_origin(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_47724) ebxOut, Register out (ptr32 Eq_47725) esiOut)
// Called from:
//      _dl_non_dynamic_init
//      expand_dynamic_string_token
//      _dl_add_to_slotinfo
//      _dl_map_object_deps
Eq_2 _dl_get_origin(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_47724 & ebxOut, struct Eq_47725 & esiOut)
{
	Eq_2 ebp_191;
	int32 eax_29;
	Eq_2 ecx_31;
	gs->ptr0010();
	if (eax_29 <= 0x00 || bLoc101C == 0x5B)
	{
		Eq_2 edi_41 = _dl_origin_path;
		if (edi_41 != 0x00)
		{
			word32 ecx_401;
			word32 edx_402;
			Eq_2 eax_52 = strlen(edi_41, out ecx_401, out edx_402);
			Eq_2 edi_68;
			word32 esi_407;
			word32 edx_404;
			word32 ecx_403;
			word32 ebx_405;
			word32 ebp_406;
			Eq_2 eax_64 = __libc_malloc(gs, dwLoc1040, (word32) eax_52 + 1, out ecx_403, out edx_404, out ebx_405, out ebp_406, out esi_407, out edi_68);
			if (eax_64 != 0x00)
			{
				word32 edx_408;
				Eq_2 eax_101 = __mempcpy(eax_64, edi_68, eax_52, out edx_408);
				if ((word32) eax_64 + 1 < eax_101)
				{
					while (*((word32) eax_101 - 1) == 0x2F)
					{
						--eax_101;
						if ((word32) eax_64 + 1 == eax_101)
							break;
					}
				}
				*eax_101 = 0x00;
				ebxOut = ebx;
				esiOut = esi;
				return eax_64;
			}
		}
		goto l08092468;
	}
	if (bLoc101C != 0x2F)
	{
		word32 ecx_393;
		word32 edx_394;
		__assert_fail(out ecx_393, out edx_394);
		word32 ecx_409;
		Eq_2 eax_146 = _dl_scope_free(gs, dwArg04, out ecx_409);
		ebxOut = (struct Eq_47724 *) &g_t80B3F32;
		esiOut = (struct Eq_47725 *) &g_t80CE000;
		return eax_146;
	}
	if (eax_29 != 0x01)
	{
		int32 edi_156 = eax_29 - 0x01;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x101C)[eax_29 - 0x01].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == 0x2F)
		{
			edi_156 = eax_29;
l08092480:
			word32 edi_216;
			word32 ecx_411;
			word32 edx_412;
			word32 ebx_413;
			word32 ebp_414;
			word32 esi_415;
			Eq_2 eax_212 = __libc_malloc(gs, dwLoc1040, edi_156 + 0x01, out ecx_411, out edx_412, out ebx_413, out ebp_414, out esi_415, out edi_216);
			if (eax_212 != 0x00)
			{
				word32 edx_410;
				*__mempcpy(eax_212, ecx_31, edi_216 - 0x01, out edx_410) = 0x00;
				ebxOut = ebx;
				esiOut = esi;
				return eax_212;
			}
l08092468:
			ebp_191.u0 = ~0x00;
			goto l0809246D;
		}
		while (edi_156 != 0x01)
		{
			int32 eax_165 = edi_156 - 0x01;
			if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(ecx_31 - 0x01)[edi_156].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == 0x2F)
				goto l08092480;
			edi_156 = eax_165;
		}
	}
	word32 ebp_398;
	word32 esi_399;
	word32 edi_400;
	word32 edx_396;
	word32 ebx_397;
	word32 ecx_395;
	Eq_2 eax_179 = __libc_malloc(gs, dwLoc1040, 0x02, out ecx_395, out edx_396, out ebx_397, out ebp_398, out esi_399, out edi_400);
	ebp_191 = eax_179;
	if (eax_179 != 0x00)
	{
		eax_179->u5 = 0x2F;
l0809246D:
		ebxOut = ebx;
		esiOut = esi;
		return ebp_191;
	}
	goto l08092468;
}

// 080924E0: Register Eq_2 _dl_scope_free(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      _dl_lookup_symbol_x
//      _dl_get_origin
//      dl_open_worker
//      _dl_close_worker
//      _dl_map_object_deps
Eq_2 _dl_scope_free(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 ecx_110;
	Eq_2 esi_101 = gs->t000C;
	if (esi_101 == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_179;
		free(gs, stackArg0, dwArg04, out ecx_110, out edx_179);
	}
	else
	{
		Eq_2 esi_21 = _dl_scope_free_list;
		if (esi_21 != 0x00)
		{
			uint32 eax_61 = *esi_21;
			if (eax_61 <= 0x31)
			{
				*esi_21 = eax_61 + 0x01;
				*((word32) esi_21 + (eax_61 * 0x04 + 4)) = dwArg04;
				ecx_110 = dwArg04;
				esi_101.u0 = 0x00;
			}
			else
			{
				_dl_wait_lookup_done();
				uint32 eax_69 = *esi_21;
				while (eax_69 != 0x00)
				{
					uint32 eax_74 = eax_69 - 0x01;
					*esi_21 = eax_74;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 edx_189;
					free(gs, stackArg0, *((word32) esi_21 + (eax_74 * 0x04 + 4)), out ecx_110, out edx_189);
					eax_69 = (uint32) *esi_21;
				}
				esi_101.u0 = 0x01;
			}
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_181;
			word32 ebx_182;
			word32 ebp_183;
			word32 esi_184;
			word32 edi_185;
			Eq_2 eax_29 = __libc_malloc(gs, stackArg0, 0xCC, out ecx_110, out edx_181, out ebx_182, out ebp_183, out esi_184, out edi_185);
			_dl_scope_free_list = eax_29;
			if (eax_29 != 0x00)
			{
				*eax_29 = 0x01;
				*((word32) eax_29 + 4) = dwArg04;
				esi_101.u0 = 0x00;
			}
			else
			{
				_dl_wait_lookup_done();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 edx_187;
				free(gs, stackArg0, dwArg04, out ecx_110, out edx_187);
				esi_101.u0 = 0x01;
			}
		}
	}
	ecxOut = ecx_110;
	return esi_101;
}

// 080925D0: void _dl_make_stack_executable(Register (ptr32 Eq_9) gs, Stack (ptr32 ui32) dwArg04)
void _dl_make_stack_executable(struct Eq_9 * gs, ui32 * dwArg04)
{
	Eq_2 eax_15 = _dl_pagesize;
	word32 edx_72;
	word32 ecx_71;
	if (mprotect(gs, -eax_15 & *dwArg04, eax_15, DW.ref.__gcc_personality_v0, out ecx_71, out edx_72) == 0x00)
	{
		*dwArg04 = 0x00;
		_dl_stack_flags |= 0x01;
	}
}

// 08092630: void _dl_runtime_resolve(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack word32 dwArg04)
void _dl_runtime_resolve(struct Eq_9 * gs, Eq_2 dwArg00, word32 dwArg04)
{
	_dl_fixup(dwArg00, dwArg04, gs);
}

// 08092660: void _dl_runtime_resolve_shstk(Register word32 eax, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack word32 dwArg04)
void _dl_runtime_resolve_shstk(word32 eax, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, word32 dwArg04)
{
	_dl_fixup(dwArg00, dwArg04, gs)();
}

// 08092690: void _dl_runtime_profile_shstk(Register word32 eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_123876 dwArg04, Stack Eq_2 dwArg08)
void _dl_runtime_profile_shstk(word32 eax, word32 ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_123876 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_35 = _dl_profile_fixup(dwArg00, dwArg08, dwArg04, gs, fp - 0x18);
	eax_35();
}

// 080926E0: void _dl_runtime_profile(Register word32 eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_123876 dwArg04, Stack Eq_2 dwArg08)
void _dl_runtime_profile(word32 eax, word32 ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_123876 dwArg04, Eq_2 dwArg08)
{
	_dl_profile_fixup(dwArg00, dwArg08, dwArg04, gs, fp - 0x18);
}

// 08092729: void fn08092729(Register (ptr32 code) eax, Register uint32 edx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg18, Stack word32 dwArg1C)
// Called from:
//      _dl_runtime_profile_shstk
//      _dl_runtime_profile
void fn08092729(<anonymous> * eax, uint32 edx, word32 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg18, word32 dwArg1C)
{
	word32 * esi_14 = fp + 0x24;
	word32 * edi_19 = fp - 8 - ((edx | 0x04) & ~0x03);
	uint32 ecx_22;
	for (ecx_22 = edx >> 0x02; ecx_22 != 0x00; --ecx_22)
	{
		*edi_19 = *esi_14;
		++esi_14;
		++edi_19;
	}
	eax();
	_dl_call_pltexit();
}

// 080927C0: void length_mismatch(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_exception_create_format
void length_mismatch(struct Eq_9 * gs)
{
	_dl_dprintf();
	_exit(gs, 0x7F);
}

// 080927F0: void _dl_exception_create(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      length_mismatch
//      _dl_signal_error
//      _dl_check_map_versions
void _dl_exception_create(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 edi_25;
	if (dwArg08 != 0x00)
	{
		word32 ecx_185;
		word32 edx_186;
		edi_25 = (word32) strlen(dwArg08, out ecx_185, out edx_186) + 1;
	}
	else
	{
		edi_25.u0 = 0x01;
		dwArg08.u0 = 134955513;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_190;
	word32 edx_191;
	Eq_2 eax_49 = strlen(dwArg0C, out ecx_190, out edx_191);
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_194;
	word32 edx_195;
	word32 ebx_196;
	word32 ebp_197;
	word32 esi_198;
	word32 edi_199;
	Eq_2 eax_63 = __libc_malloc(gs, stackArg0, (word32) edi_25 + ((word32) eax_49 + 1), out ecx_194, out edx_195, out ebx_196, out ebp_197, out esi_198, out edi_199);
	if (eax_63 == 0x00)
	{
		((word32) dwArg04 + 8)->u0 = 0x00;
		dwArg04->u0 = 134955513;
		((word32) dwArg04 + 4)->u0 = 0x080B4000;
	}
	else
	{
		word32 edx_187;
		word32 ecx_188;
		word32 edx_189;
		*dwArg04 = memcpy(__mempcpy(eax_63, dwArg0C, (word32) eax_49 + 1, out edx_187), dwArg08, edi_25, out ecx_188, out edx_189);
		*((word32) dwArg04 + 4) = eax_63;
		*((word32) dwArg04 + 8) = eax_63;
	}
}

// 080928D0: void _dl_exception_create_format(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _dl_lookup_symbol_x
//      _dl_check_map_versions
void _dl_exception_create_format(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 dwLoc20_359;
	Eq_2 ebp_104;
	Eq_2 edi_183 = dwArg0C;
	if (dwArg08 != 0x00)
	{
		word32 ecx_507;
		word32 edx_508;
		Eq_2 eax_35 = strlen(dwArg08, out ecx_507, out edx_508);
		ebp_104 = (word32) eax_35 + 2;
		dwLoc20_359 = (word32) eax_35 + 1;
	}
	else
	{
		ebp_104.u0 = 0x02;
		dwLoc20_359.u0 = 0x01;
		dwArg08.u0 = 134955513;
	}
	byte dl_54 = *dwArg0C;
	word32 * esi_129 = fp + 0x10;
	if (dl_54 != 0x00)
	{
		Eq_2 ebx_350 = dwArg0C;
		do
		{
			word32 eax_61 = (word32) *((word32) ebx_350 + 1);
			byte al_73 = (byte) eax_61;
			Eq_2 ecx_62 = (word32) ebx_350 + 1;
			if (dl_54 != 0x25)
			{
				ebp_104 = (word32) ebp_104 + 1;
				ebx_350 = ecx_62;
				goto l08092937;
			}
			dl_54 = (byte) *((word32) ebx_350 + 2);
			ebx_350 = (word32) ebx_350 + 2;
			if (al_73 == 115)
			{
				++esi_129;
				eax_61 = (word32) dl_54;
				word32 ecx_516;
				word32 edx_517;
				ebp_104 += strlen(*esi_129, out ecx_516, out edx_517);
l08092937:
				dl_54 = (byte) eax_61;
				if (dl_54 != 0x00)
					continue;
				break;
			}
			ebp_104 = (word32) ebp_104 + 1;
		} while (dl_54 != 0x00);
		if (ebp_104 < 0x00)
		{
l08092A50:
			((word32) dwArg04 + 8)->u0 = 0x00;
			dwArg04->u0 = 134955513;
			((word32) dwArg04 + 4)->u0 = 0x080B4000;
			return;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 edi_515;
	word32 ebx_512;
	word32 ebp_513;
	word32 esi_514;
	word32 edx_511;
	word32 ecx_510;
	Eq_2 eax_135 = __libc_malloc(gs, stackArg0, ebp_104, out ecx_510, out edx_511, out ebx_512, out ebp_513, out esi_514, out edi_515);
	Eq_2 ebx_140 = eax_135;
	if (eax_135 != 0x00)
	{
		*((word32) dwArg04 + 4) = eax_135;
		*((word32) dwArg04 + 8) = eax_135;
		word32 ebp_166 = ebp_104 + eax_135;
		byte dl_171 = *dwArg0C;
		word32 * eax_170 = fp + 0x10;
		while (dl_171 != 0x00)
		{
			Eq_2 esi_184;
			if (dl_171 != 0x25)
			{
				if (ebp_166 == ebx_140)
					goto l08092AE0;
				*ebx_140 = dl_171;
				esi_184 = edi_183;
				++ebx_140;
				goto l080929AF;
			}
			byte dl_190 = *((word32) edi_183 + 1);
			esi_184 = (word32) edi_183 + 1 + 0x01;
			if (dl_190 != 0x25)
			{
				if (dl_190 != 115)
					goto l08092AE5;
				Eq_2 edi_197 = *eax_170;
				word32 * ecx_196 = eax_170 + 1;
				word32 edx_521;
				word32 ecx_520;
				Eq_2 eax_204 = strlen(edi_197, out ecx_520, out edx_521);
				if (ebp_166 - ebx_140 < eax_204)
					goto l08092AE0;
				word32 edx_522;
				ebx_140 = __mempcpy(ebx_140, edi_197, eax_204, out edx_522);
				eax_170 = ecx_196;
l080929AF:
				dl_171 = (byte) *esi_184;
				edi_183 = (word32) esi_184 + 1;
				if (dl_171 != 0x00)
					continue;
				break;
			}
			if (ebp_166 == ebx_140)
				goto l08092AE0;
			dl_171 = (byte) *((word32) esi_184 + 1);
			*ebx_140 = 0x25;
			edi_183 = (word32) esi_184 + 1;
			ebx_140 = (word32) ebx_140 + 1;
		}
		if (ebp_166 != ebx_140)
		{
			*ebx_140 = 0x00;
			Eq_2 ebx_266 = (word32) ebx_140 + 1;
			if (ebp_166 - ebx_266 == dwLoc20_359)
			{
				word32 edx_519;
				word32 ecx_518;
				*dwArg04 = memcpy(ebx_266, dwArg08, dwLoc20_359, out ecx_518, out edx_519);
				return;
			}
		}
l08092AE0:
		length_mismatch(gs);
l08092AE5:
		_dl_dprintf();
		_exit(gs, 0x7F);
	}
	goto l08092A50;
}

// 08092B10: void _dl_exception_free(Stack (ptr32 Eq_124233) dwArg04)
// Called from:
//      _dl_exception_create_format
//      _dl_map_object_deps
void _dl_exception_free(struct Eq_124233 * dwArg04)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_38;
	word32 edx_39;
	free(gs, stackArg0, dwArg04->t0008, out ecx_38, out edx_39);
	dwArg04->dw0000 = 0x00;
	dwArg04->dw0004 = 0x00;
	dwArg04->t0008.u0 = 0x00;
}

// 08092B50: Register int32 _dl_cache_libcmp(Stack Eq_2 dwArg04, Stack (ptr32 Eq_124259) dwArg08)
// Called from:
//      _dl_load_cache_lookup
int32 _dl_cache_libcmp(Eq_2 dwArg04, struct Eq_124259 * dwArg08)
{
	Eq_2 ebx_138 = dwArg04;
	struct Eq_124259 * dwLoc14_180 = dwArg08;
l08092B66:
	int32 eax_108;
	int32 eax_141 = (int32) *ebx_138;
	int32 edx_143 = (int32) dwLoc14_180->b0000;
	while ((byte) eax_141 != 0x00)
	{
		byte dl_124 = (byte) edx_143;
		byte al_123 = (byte) eax_141;
		cu8 cl_40 = (byte) edx_143 - 0x30;
		if ((byte) eax_141 <= 0x39)
		{
			if (cl_40 > 0x09)
			{
				eax_108 = 0x01;
				return eax_108;
			}
			else
			{
				int32 edx_47 = (int32) *((word32) ebx_138 + 1);
				int32 ebp_100 = edx_143 - 0x30;
				int32 eax_104 = eax_141 - 0x30;
				ebx_138 = (word32) ebx_138 + 1;
				if ((byte) edx_47 <= 0x39 && (byte) edx_47 >= 0x30)
				{
					do
					{
						ebx_138 = (word32) ebx_138 + 1;
						edx_47 = (int32) *ebx_138;
						eax_104 = edx_47 - 0x30 + eax_104 * 0x0A;
					} while ((byte) edx_47 <= 0x39);
				}
				int32 edx_78 = (int32) dwLoc14_180[1];
				++dwLoc14_180;
				if ((byte) edx_78 <= 0x39 && (byte) edx_78 >= 0x30)
				{
					do
					{
						struct Eq_124259 * v20_87 = dwLoc14_180 + 1;
						edx_78 = (int32) v20_87->b0000;
						dwLoc14_180 = v20_87;
						ebp_100 = edx_78 - 0x30 + ebp_100 * 0x0A;
					} while ((byte) edx_78 <= 0x39);
				}
				if (ebp_100 == eax_104)
					goto l08092B66;
				eax_108 = eax_104 - ebp_100;
				return eax_108;
			}
		}
		if (cl_40 <= 0x09)
			return ~0x00;
		if (al_123 != dl_124)
			return eax_141 - edx_143;
		ebx_138 = (word32) ebx_138 + 1;
		struct Eq_124259 * v18_139 = dwLoc14_180 + 1;
		eax_141 = (int32) *ebx_138;
		dwLoc14_180 = v18_139;
		edx_143 = (int32) v18_139->b0000;
	}
	eax_108 = -(int32) (byte) edx_143;
	return eax_108;
}

// 08092C60: Register Eq_2 _dl_load_cache_lookup(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_map_object
Eq_2 _dl_load_cache_lookup(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if ((_dl_debug_mask & 0x01) != 0x00)
	{
		word32 edx_1505;
		word32 ecx_1504;
		_dl_debug_printf(out ecx_1504, out edx_1505);
	}
	Eq_2 esi_185;
	Eq_2 edi_189 = cache;
	if (edi_189 == 0x00)
	{
		word32 ecx_1506;
		word32 edx_1507;
		Eq_2 eax_66 = _dl_sysdep_read_whole_file(gs, 0x080B400E, &cachesize, 0x01, out ecx_1506, out edx_1507);
		edi_189 = eax_66;
		if (eax_66 != ~0x00)
		{
			esi_185 = cachesize;
			if (esi_185 > 0x10)
			{
				if (*eax_66 == 1932420204 && (*((word32) eax_66 + 4) == 774974831 && (*((word32) eax_66 + 8) == 11831 && *((word32) eax_66 + 0x0A) == 0x30)))
				{
					cache = eax_66;
					Eq_124962 eax_92 = *((word32) eax_66 + 0x0C) * 0x0C + 0x10;
					word32 ecx_93 = eax_66 + eax_92;
					cache_new = ecx_93;
					if (esi_185 >= (word32) eax_92 + 48)
					{
						word32 ecx_1523;
						word32 edx_1524;
						if (memcmp(ecx_93, 0x080B403D, 0x14, out ecx_1523, out edx_1524) == 0x00)
							goto l08092CAF;
					}
					cache_new.u0 = ~0x00;
					goto l08092CAF;
				}
				if (esi_185 > 0x30)
				{
					ebx.u0 = 0x080CE000;
					word32 edx_1522;
					word32 ecx_1521;
					if (memcmp(eax_66, 0x080B403D, 0x14, out ecx_1521, out edx_1522) == 0x00)
					{
						cache_new = eax_66;
						cache = eax_66;
						goto l08092CAF;
					}
				}
			}
			word32 ecx_1518;
			word32 edx_1519;
			word32 ebx_1520;
			__munmap(ebx, gs, eax_66, esi_185, out ecx_1518, out edx_1519, out ebx_1520);
		}
		cache.u0 = ~0x00;
		return 0x00;
	}
	else
	{
		if (edi_189 == ~0x00)
			return 0x00;
		esi_185 = cachesize;
l08092CAF:
		Eq_2 dwLoc40_1046;
		word32 eax_193 = edi_189 + esi_185;
		Eq_2 ebx_194 = cache_new;
		if (ebx_194 != ~0x00)
		{
			ui32 dwLoc64_1380;
			ui32 dwLoc68_1371;
			Eq_2 eax_404 = eax_193 - ebx_194;
			Eq_2 ebx_407 = _dl_platform;
			if (ebx_407 != 0x00)
			{
				word32 edx_1509;
				word32 ecx_1508;
				if (strcmp(ebx_407, 134891488, out ecx_1508, out edx_1509) != 0x00)
				{
					word32 edx_1511;
					word32 ecx_1510;
					Eq_2 eax_442 = strcmp(ebx_407, 134891497, out ecx_1510, out edx_1511);
					dwLoc64_1380 = ~(0x00 - (word32) (eax_442 < 0x01));
					dwLoc68_1371 = (0x00 - (word32) (eax_442 < 0x01) & 0x00020001) - 0x01;
				}
				else
				{
					dwLoc64_1380 = 0x00;
					dwLoc68_1371 = 0x00010000;
				}
			}
			else
			{
				dwLoc64_1380 = ~0x00;
				dwLoc68_1371 = ~0x00;
			}
			__tunable_get_val(0x10, fp - 0x24, null);
			Eq_2 ebx_484 = cache_new;
			int32 eax_494 = *((word32) ebx_484 + 20);
			ui32 esi_491 = g_dw80CF8C8;
			ui32 eax_492 = g_dw80CF8CC;
			int32 edi_498 = eax_494 - 0x01;
			if (eax_494 >= 0x01)
			{
				int32 esi_502 = eax_494 - 0x01 >> 0x01;
				Eq_2 eax_504 = *((word32) ebx_484 + (esi_502 * 0x18 + 52));
				if (eax_404 > eax_504)
				{
					int32 ebx_507 = 0x00;
					do
					{
						word32 eax_522 = _dl_cache_libcmp(dwArg04, eax_504 + ebx_194);
						if (eax_522 == 0x00)
						{
							int32 edi_539;
							if (esi_502 != 0x00)
							{
								int32 edi_542 = esi_502 - 0x01;
								Eq_2 eax_545 = *((word32) ebx_484 + (edi_542 * 0x18 + 52));
								if (eax_404 > eax_545)
								{
									int32 esi_551 = edi_542;
									struct Eq_124559 * ebx_552 = (word32) ebx_484 + 4 + esi_502 * 0x18;
									while (true)
									{
										edi_539 = esi_551 + 0x01;
										if (_dl_cache_libcmp(dwArg04, eax_545 + ebx_194) != 0x00)
											break;
										if (esi_551 == 0x00)
										{
l08093060:
											edi_539 = esi_551;
											break;
										}
										ebx_552 -= 0x18;
										int32 edi_583 = esi_551 - 0x01;
										eax_545 = ebx_552[1];
										if (eax_404 <= eax_545)
											goto l08093060;
										esi_551 = edi_583;
									}
								}
								else
									edi_539 = esi_502;
							}
							else
								edi_539 = 0x00;
							ui32 eax_599 = _dl_correct_cache_id;
							dwLoc40_1046.u0 = 0x00;
							uint32 eax_604 = _dl_osversion;
							struct Eq_124604 * ebx_609 = (word32) ebx_484 + 48 + edi_539 * 0x18;
							ui32 eax_611 = eax_492 & dwLoc20;
							do
							{
								if (edi_539 > esi_502)
								{
									Eq_2 eax_622 = ebx_609->dw0004;
									if (eax_622 >= eax_404 || _dl_cache_libcmp(dwArg04, eax_622 + ebx_194) != 0x00)
										break;
								}
								ui32 eax_648 = ebx_609->dw0000;
								if ((eax_648 & ~0x02) == 0x01)
								{
									Eq_2 ecx_653 = ebx_609->dw0008;
									if (ecx_653 < eax_404 && (dwLoc40_1046 == 0x00 || eax_599 == eax_648))
									{
										ui32 ecx_669 = ebx_609->dw0014;
										if ((~(eax_611 | 0x80030000) & ecx_669 | ~(esi_491 & dwLoc24) & ebx_609->dw0010) == 0x00 && (eax_604 == 0x00 || eax_604 >= ebx_609->dw000C) && ((dwLoc68_1371 ^ ecx_669 & 0x00030000 | dwLoc64_1380) == 0x00 || (ecx_669 & 0x00030000) == 0x00))
										{
											dwLoc40_1046 = ecx_653 + ebx_194;
											if (eax_599 == eax_648)
												break;
										}
									}
								}
								++edi_539;
								++ebx_609;
							} while (edi_539 <= edi_498);
							goto l08092F40;
						}
						if (eax_522 < 0x00)
						{
							ebx_507 = esi_502 + 0x01;
							if (edi_498 < ebx_507)
								return 0x00;
						}
						else
						{
							edi_498 = esi_502 - 0x01;
							if (edi_498 < ebx_507)
								return 0x00;
						}
						int32 edx_880 = edi_498 + ebx_507;
						esi_502 = edx_880 >> 0x01;
						eax_504 = *((word32) ebx_484 + (((edx_880 >> 0x01) + (edx_880 >> 0x01) * 0x02) * 0x08 + 52));
					} while (eax_404 > eax_504);
				}
			}
		}
		else
		{
			int32 eax_198 = *((word32) edi_189 + 0x0C);
			int32 ecx_200 = eax_198 * 0x0C + 0x10;
			up32 esi_201 = esi_185 - ecx_200;
			ptr32 ebx_202 = (word32) edi_189 + ecx_200;
			if (eax_198 >= 0x01)
			{
				int32 esi_211 = eax_198 - 0x01 >> 0x01;
				up32 eax_213 = *((word32) edi_189 + (esi_211 * 0x0C + 20));
				if (esi_201 > eax_213)
				{
					int32 edi_220 = 0x00;
					int32 ebx_221 = eax_198 - 0x01;
					do
					{
						int32 eax_234 = _dl_cache_libcmp(dwArg04, eax_213 + ebx_202);
						if (eax_234 == 0x00)
						{
							int32 ebx_252;
							if (esi_211 != 0x00)
							{
								int32 ebx_255 = esi_211 - 0x01;
								up32 eax_257 = *((word32) edi_189 + (ebx_255 * 0x0C + 20));
								if (esi_201 > eax_257)
								{
									int32 esi_265 = ebx_255;
									struct Eq_124825 * edi_266 = edi_189 - 0x04 + esi_211 * 0x0C;
									while (true)
									{
										ebx_252 = esi_265 + 0x01;
										if (_dl_cache_libcmp(dwArg04, eax_257 + ebx_202) != 0x00)
											break;
										if (esi_265 == 0x00)
										{
l08093198:
											ebx_252 = esi_265;
											break;
										}
										edi_266 -= 0x0C;
										int32 ebx_297 = esi_265 - 0x01;
										eax_257 = (up32) edi_266[1];
										if (esi_201 <= eax_257)
											goto l08093198;
										esi_265 = ebx_297;
									}
								}
								else
									ebx_252 = esi_211;
							}
							else
								ebx_252 = 0x00;
							dwLoc40_1046.u0 = 0x00;
							ui32 eax_315 = _dl_correct_cache_id;
							struct Eq_124853 * edi_320 = (word32) edi_189 + 16 + ebx_252 * 0x0C;
							do
							{
								if (ebx_252 > esi_211)
								{
									up32 eax_327 = edi_320->dw0004;
									if (eax_327 >= esi_201 || _dl_cache_libcmp(dwArg04, eax_327 + ebx_202) != 0x00)
										break;
								}
								ui32 eax_353 = edi_320->dw0000;
								if ((eax_353 & ~0x02) == 0x01)
								{
									up32 edx_358 = edi_320->dw0008;
									if (edx_358 < esi_201)
									{
										if (dwLoc40_1046 == 0x00)
										{
											dwLoc40_1046 = edx_358 + ebx_202;
											if (eax_315 == eax_353)
												break;
										}
										else if (eax_315 == eax_353)
										{
											dwLoc40_1046 = edx_358 + ebx_202;
											break;
										}
									}
								}
								++ebx_252;
								++edi_320;
							} while (ebx_252 <= ebx_221);
l08092F40:
							if ((_dl_debug_mask & 0x01) == 0x00)
							{
								if (dwLoc40_1046 == 0x00)
									return 0x00;
							}
							else
							{
								if (dwLoc40_1046 == 0x00)
									return 0x00;
								word32 ecx_1516;
								word32 edx_1517;
								_dl_debug_printf(out ecx_1516, out edx_1517);
							}
							word32 ecx_1512;
							word32 edx_1513;
							Eq_2 eax_780 = strlen(dwLoc40_1046, out ecx_1512, out edx_1513);
							struct Eq_124721 * esp_787 = fp - 0x6C;
							struct Eq_124721 * esi_792 = fp - 0x6C - ((word32) eax_780 + 28 & ~0x0FFF);
							ui32 ecx_793 = (word32) eax_780 + 28 & ~0x0F;
							if (fp - 0x6C != esi_792)
							{
								do
								{
									esp_787 -= 0x1000;
									esp_787->dw0FFC = esp_787->dw0FFC;
								} while (esp_787 != esi_792);
							}
							if ((ecx_793 & 0x0FFF) != 0x00)
							{
								esp_787 -= ecx_793 & 0x0FFF;
								(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_787 - 0x04)[(ecx_793 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_787 - 0x04)[(ecx_793 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
							}
							struct Eq_124764 * esp_825 = esp_787 - 0x04;
							esp_825->tFFFFFFFC = (word32) eax_780 + 1;
							esp_825->tFFFFFFF8 = dwLoc40_1046;
							Eq_124775 esi_820 = (char *) esp_787 + 0x0F;
							esp_825->tFFFFFFF4 = esi_820 & ~0x0F;
							word32 edx_1515;
							word32 ecx_1514;
							memcpy(esp_825->tFFFFFFF4, esp_825->tFFFFFFF8, esp_825->tFFFFFFFC, out ecx_1514, out edx_1515);
							esp_825->tFFFFFFF4 = esi_820 & ~0x0F;
							return strdup(esp_825->tFFFFFFF4);
						}
						if (eax_234 < 0x00)
							edi_220 = esi_211 + 0x01;
						else
							ebx_221 = esi_211 - 0x01;
						if (edi_220 > ebx_221)
							return 0x00;
						int32 edx_394 = edi_220 + ebx_221;
						esi_211 = edx_394 >> 0x01;
						eax_213 = (up32) *((word32) edi_189 + (((edx_394 >> 0x01) + (edx_394 >> 0x01) * 0x02) * 0x04 + 20));
					} while (esi_201 > eax_213);
				}
			}
		}
		return 0x00;
	}
}

// 08093340: void _dl_unload_cache(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_open
void _dl_unload_cache(struct Eq_9 * gs)
{
	Eq_2 eax_10 = cache;
	if (eax_10 > ~0x01)
		return;
	struct Eq_124996 * ebx_23;
	word32 ecx_62;
	word32 edx_63;
	__munmap(0x080CE000, gs, eax_10, cachesize, out ecx_62, out edx_63, out ebx_23);
	ebx_23->dw1A7C = 0x00;
}

// 080933A0: void _dl_tlsdesc_return()
void _dl_tlsdesc_return()
{
}

// 080933B0: void _dl_tlsdesc_undefweak()
void _dl_tlsdesc_undefweak()
{
}

// 080933C0: void _dl_tlsdesc_resolve_abs_plus_addend(Register (ptr32 Eq_125011) eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_125014) ebx, Register (ptr32 Eq_9) gs)
void _dl_tlsdesc_resolve_abs_plus_addend(struct Eq_125011 * eax, word32 ecx, word32 edx, struct Eq_125014 * ebx, struct Eq_9 * gs)
{
	_dl_tlsdesc_resolve_abs_plus_addend_fixup(eax, 0x14, ebx->t0004, gs, dwLoc10);
	eax->ptr0000();
}

// 080933E0: void _dl_tlsdesc_resolve_rel(Register (ptr32 Eq_125011) eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_125035) ebx, Register (ptr32 Eq_9) gs)
void _dl_tlsdesc_resolve_rel(struct Eq_125011 * eax, word32 ecx, word32 edx, struct Eq_125035 * ebx, struct Eq_9 * gs)
{
	_dl_tlsdesc_resolve_rel_fixup(eax, 0x14, ebx->t0004, gs, dwLoc10);
	eax->ptr0000();
}

// 08093400: void _dl_tlsdesc_resolve_rela(Register (ptr32 Eq_125011) eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_125056) ebx, Register (ptr32 Eq_9) gs)
void _dl_tlsdesc_resolve_rela(struct Eq_125011 * eax, word32 ecx, word32 edx, struct Eq_125056 * ebx, struct Eq_9 * gs)
{
	_dl_tlsdesc_resolve_rela_fixup(eax, 0x14, ebx->t0004, gs, dwLoc10);
	eax->ptr0000();
}

// 08093420: void _dl_tlsdesc_resolve_hold(Register (ptr32 (ptr32 code)) eax, Register word32 ecx, Register word32 edx)
void _dl_tlsdesc_resolve_hold(<anonymous> ** eax, word32 ecx, word32 edx)
{
	_dl_tlsdesc_resolve_hold_fixup(eax, 0x14, dwLoc10);
	(*eax)();
}

// 08093440: void do_dlopen(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_125089) dwArg04)
void do_dlopen(struct Eq_9 * gs, struct Eq_125089 * dwArg04)
{
	dwArg04->dw000C = _dl_open(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->dw0008, ~0x01, __libc_argc, __libc_argv, environ);
}

// 08093490: Register Eq_2 dlerror_run(Register (ptr32 Eq_9) gs, Register out Eq_125122 ecxOut)
// Called from:
//      __libc_dlclose
//      __libc_dlsym
//      __libc_dlvsym
//      __libc_dlsym_private
//      __libc_dlopen_mode
Eq_2 dlerror_run(struct Eq_9 * gs, union Eq_125122 & ecxOut)
{
	Eq_2175 ecx_11 = gs->t0014;
	word32 ecx_134;
	word32 edx_135;
	word32 esi_136;
	Eq_2 eax_34 = _dl_catch_error(gs, fp - 0x18, fp - 0x14, fp - 0x19, out ecx_134, out edx_135, out esi_136);
	if (eax_34 != 0x00 && bLoc19 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_140;
		word32 edx_141;
		free(gs, stackArg0, 0x00, out ecx_140, out edx_141);
	}
	Eq_125122 ecx_71 = ecx_11 ^ gs->t0014;
	if (ecx_71 != 0x00)
	{
		word32 ecx_137;
		word32 edx_138;
		__stack_chk_fail(out ecx_137, out edx_138);
		Eq_125122 ecx_88;
		Eq_2 eax_90 = __libc_dlclose(out ecx_88);
		ecxOut = ecx_88;
		return eax_90;
	}
	else
	{
		ecxOut = ecx_71;
		return eax_34;
	}
}

// 08093520: Register word32 __libc_dlclose(Register out Eq_952 ecxOut)
// Called from:
//      do_release_shlib
//      dlerror_run
//      do_release_all
word32 __libc_dlclose(union Eq_952 & ecxOut)
{
	word32 ecx_20;
	word32 eax_10 = dlerror_run(gs, out ecx_20);
	ecxOut.u0 = <invalid>;
	return eax_10;
}

// 08093540: Register (ptr32 Eq_125188) __libc_dlsym(Register (ptr32 Eq_9) gs, Register out Eq_65590 ecxOut)
// Called from:
//      __gconv_find_shlib
struct Eq_125188 * __libc_dlsym(struct Eq_9 * gs, union Eq_65590 & ecxOut)
{
	Eq_2175 ecx_9 = gs->t0014;
	word32 ecx_113;
	word32 eax_20 = dlerror_run(gs, out ecx_113);
	struct Eq_125188 * edx_24 = null;
	if (eax_20 == 0x00)
	{
		edx_24 = dwLoc14;
		if (dwLoc14 != null)
		{
			if (dwLoc14->w000E != ~0x0E)
			{
				if (dwLoc18 != null)
					eax_20 = *dwLoc18;
			}
			else
				eax_20 = 0x00;
			edx_24 = eax_20 + dwLoc14->dw0004;
		}
	}
	Eq_65590 ecx_54 = ecx_9 ^ gs->t0014;
	if (ecx_54 != 0x00)
	{
		word32 ecx_114;
		word32 edx_115;
		__stack_chk_fail(out ecx_114, out edx_115);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg12 = <invalid>;
		Eq_65590 ecx_72;
		struct Eq_125188 * eax_71 = __libc_dlvsym(gs, stackArg12, out ecx_72);
		ecxOut = ecx_72;
		return eax_71;
	}
	else
	{
		ecxOut = ecx_54;
		return edx_24;
	}
}

// 080935D0: Register (ptr32 Eq_125242) __libc_dlvsym(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg0C, Register out (ptr32 word32) ecxOut)
// Called from:
//      __libc_dlsym
struct Eq_125242 * __libc_dlvsym(struct Eq_9 * gs, Eq_2 dwArg0C, word32 & ecxOut)
{
	Eq_2175 esi_14 = gs->t0014;
	if ((word32) *dwArg0C != 0x00 && ((word32) (*((word32) dwArg0C + 1)) != 0x00 && ((word32) (*((word32) dwArg0C + 2)) != 0x00 && ((word32) (*((word32) dwArg0C + 3)) != 0x00 && (word32) (*((word32) dwArg0C + 4)) != 0x00))))
	{
		byte * eax_44 = (word32) dwArg0C + 5;
		if ((word32) *((word32) dwArg0C + 5) != 0x00)
		{
			do
				++eax_44;
			while ((word32) *eax_44 != 0x00);
		}
	}
	word32 * ecx_190;
	word32 eax_100 = dlerror_run(gs, out ecx_190);
	struct Eq_125242 * edx_105 = null;
	if (eax_100 == 0x00)
	{
		edx_105 = dwLoc24;
		if (dwLoc24 != null)
		{
			if (dwLoc24->w000E != ~0x0E)
			{
				ecx_190 = dwLoc28;
				if (dwLoc28 != null)
					eax_100 = *dwLoc28;
			}
			else
				eax_100 = 0x00;
			edx_105 = eax_100 + dwLoc24->dw0004;
		}
	}
	if ((esi_14 ^ gs->t0014) != 0x00)
	{
		word32 edx_207;
		word32 ecx_206;
		__stack_chk_fail(out ecx_206, out edx_207);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 * ecx_130;
		struct Eq_125242 * eax_129 = do_dlsym_private(gs, stackArg4, out ecx_130);
		ecxOut = ecx_130;
		return eax_129;
	}
	else
	{
		ecxOut = ecx_190;
		return edx_105;
	}
}

// 080936E0: Register ui32 do_dlsym_private(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      __libc_dlvsym
ui32 do_dlsym_private(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & ecxOut)
{
	Eq_2175 ecx_11 = gs->t0014;
	Eq_2 eax_22 = *dwArg04;
	*((word32) dwArg04 + 0x0C) = 0x00;
	ptr32 ecx_45;
	word32 edx_104;
	*((word32) dwArg04 + 8) = _dl_lookup_symbol_x(gs, *((word32) dwArg04 + 4), eax_22, (word32) dwArg04 + 0x0C, *((word32) eax_22 + 464), fp - 0x20, 0x00, 0x00, 0x00, out ecx_45, out edx_104);
	ui32 eax_51 = ecx_11 ^ gs->t0014;
	if (eax_51 != 0x00)
	{
		word32 ecx_105;
		word32 edx_106;
		__stack_chk_fail(out ecx_105, out edx_106);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		ptr32 ecx_62;
		ui32 eax_61 = do_dlsym(stackArg4, out ecx_62);
		ecxOut = ecx_62;
		return eax_61;
	}
	else
	{
		ecxOut = ecx_45;
		return eax_51;
	}
}

// 08093770: Register Eq_2 do_dlsym(Stack Eq_2 dwArg04, Register out Eq_952 ecxOut)
// Called from:
//      do_dlsym_private
Eq_2 do_dlsym(Eq_2 dwArg04, union Eq_952 & ecxOut)
{
	Eq_2 eax_10 = *dwArg04;
	*((word32) dwArg04 + 0x0C) = 0x00;
	word32 ecx_55;
	word32 edx_56;
	Eq_2 eax_31 = _dl_lookup_symbol_x(gs, *((word32) dwArg04 + 4), eax_10, (word32) dwArg04 + 0x0C, (word32) eax_10 + 468, 0x00, 0x00, 0x02, 0x00, out ecx_55, out edx_56);
	*((word32) dwArg04 + 8) = eax_31;
	ecxOut.u0 = <invalid>;
	return eax_31;
}

// 080937B0: void do_dlvsym(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_125429) dwArg04)
void do_dlvsym(struct Eq_9 * gs, struct Eq_125429 * dwArg04)
{
	Eq_2 eax_10 = dwArg04->t0000;
	dwArg04->dw000C = 0x00;
	word32 ecx_60;
	word32 edx_61;
	dwArg04->t0008 = _dl_lookup_symbol_x(gs, dwArg04->t0004, eax_10, &dwArg04->dw000C, (word32) eax_10 + 468, &dwArg04->dw000C + 1, 0x00, 0x00, 0x00, out ecx_60, out edx_61);
}

// 080937F0: void do_dlclose(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void do_dlclose(struct Eq_9 * gs, Eq_2 dwArg04)
{
	_dl_close(gs, dwArg04);
}

// 08093800: Register (ptr32 Eq_125466) __libc_dlsym_private(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_register_dl_open_hook
//      __libc_register_dlfcn_hook
struct Eq_125466 * __libc_dlsym_private(struct Eq_9 * gs)
{
	Eq_2175 ecx_9 = gs->t0014;
	word32 ecx_112;
	word32 eax_20 = dlerror_run(gs, out ecx_112);
	struct Eq_125466 * edx_24 = null;
	if (eax_20 == 0x00)
	{
		edx_24 = dwLoc14;
		if (dwLoc14 != null)
		{
			if (dwLoc14->w000E != ~0x0E)
			{
				if (dwLoc18 != null)
					eax_20 = *dwLoc18;
			}
			else
				eax_20 = 0x00;
			edx_24 = eax_20 + dwLoc14->dw0004;
		}
	}
	if ((ecx_9 ^ gs->t0014) == 0x00)
		return edx_24;
	word32 ecx_113;
	word32 edx_114;
	__stack_chk_fail(out ecx_113, out edx_114);
	return __libc_register_dl_open_hook();
}

// 08093890: Register (ptr32 ptr32) __libc_register_dl_open_hook()
// Called from:
//      __libc_dlsym_private
//      __libc_dlopen_mode
//      __dlmopen
//      __dlopen
ptr32 * __libc_register_dl_open_hook()
{
	ptr32 * eax_20 = __libc_dlsym_private(gs);
	if (eax_20 != null)
		*eax_20 = 0x080CEEFC;
	ptr32 * eax_40 = __libc_dlsym_private(gs);
	if (eax_40 != null)
		*eax_40 = 0x080CEEFC;
	return eax_40;
}

// 080938F0: Register Eq_2 __libc_dlopen_mode(Register (ptr32 Eq_9) gs, Register out Eq_65577 ecxOut)
// Called from:
//      __gconv_find_shlib
Eq_2 __libc_dlopen_mode(struct Eq_9 * gs, union Eq_65577 & ecxOut)
{
	Eq_2175 ecx_9 = gs->t0014;
	Eq_2 edx_26 = 0x00;
	word32 ecx_105;
	if (dlerror_run(gs, out ecx_105) == 0x00)
	{
		__libc_register_dl_open_hook();
		__libc_register_dlfcn_hook();
		edx_26 = dwLoc14;
	}
	Eq_65577 ecx_55 = ecx_9 ^ gs->t0014;
	if (ecx_55 != 0x00)
	{
		word32 ecx_106;
		word32 edx_107;
		__stack_chk_fail(out ecx_106, out edx_107);
		Eq_65577 ecx_67;
		Eq_2 eax_66 = fatal_error(eax, ecx, edx, gs, out ecx_67);
		ecxOut = ecx_67;
		return eax_66;
	}
	else
	{
		ecxOut = ecx_55;
		return edx_26;
	}
}

// 08093970: Register Eq_2 fatal_error(Register Eq_2 eax, Register word32 ecx, Register (ptr32 byte) edx, Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut)
// Called from:
//      __libc_dlopen_mode
//      _dl_signal_exception
//      _dl_signal_error
Eq_2 fatal_error(Eq_2 eax, word32 ecx, byte * edx, struct Eq_9 * gs, ptr32 & ecxOut)
{
	if (eax != 0x00)
	{
		word32 ebx_171;
		word32 ebp_172;
		word32 esi_173;
		strerror_r(gs, eax, fp - 0x0420, 0x0400, out ebx_171, out ebp_172, out esi_173);
	}
	*edx == 0x00;
	**(union Eq_2 **) 135060900 != 0x00;
	_dl_dprintf();
	_exit(gs, 0x7F);
}

// 08093A30: Register Eq_2 _dl_signal_exception(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ebxOut)
// Called from:
//      _dl_lookup_symbol_x
//      _dl_open
//      _dl_map_object_deps
//      _dl_check_map_versions
//      _dl_sym
Eq_2 _dl_signal_exception(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ebxOut)
{
	Eq_2 ebx_14 = dwArg08;
	struct Eq_125612 * edx_17 = gs->ptrFFFFFFFC;
	if (edx_17 != null)
	{
		Eq_2 ecx_21 = edx_17->t0000;
		*ecx_21 = *dwArg08;
		*((word32) ecx_21 + 4) = *((word32) dwArg08 + 4);
		*((word32) ecx_21 + 8) = *((word32) dwArg08 + 8);
		edx_17->ptr0004->t0000 = dwArg04;
		word32 ebp_92;
		word32 edi_93;
		ebx_14 = __longjmp(gs, (char *) &edx_17->ptr0004 + 4, 0x01, out ebp_92, out edi_93);
	}
	word32 ecx_91;
	fatal_error(eax, dwArg28, *ebx_14, gs, out ecx_91);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg16 = <invalid>;
	word32 ecx_95;
	word32 edx_96;
	word32 ebx_97;
	word32 ebp_98;
	word32 edi_99;
	Eq_2 eax_67 = _dl_signal_error(gs, dwArg04, stackArg16, out ecx_95, out edx_96, out ebx_97, out ebp_98, out edi_99);
	ebxOut = ebx_14;
	return eax_67;
}

// 08093A90: Register Eq_2 _dl_signal_error(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg10, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out Eq_2 ebxOut, Register out (ptr32 Eq_104400) ebpOut, Register out (ptr32 Eq_104401) ediOut)
// Called from:
//      lose
//      add_name_to_object.isra.4
//      fillin_rpath
//      cache_rpath.part.6
//      _dl_init_paths
//      _dl_map_object
//      _dl_allocate_static_tls
//      _dl_protect_relro
//      _dl_reloc_bad_type
//      _dl_relocate_object
//      _dl_important_hwcaps
//      _dl_add_to_slotinfo
//      _dl_signal_exception
//      dlinfo_doit
//      dlmopen_doit
//      add_to_global
//      _dl_open
//      dl_open_worker
//      _dl_close_worker
//      _dl_close
//      _dl_cet_open_check
//      dlopen_doit
//      _dl_map_object_deps
//      _dl_sym
Eq_2 _dl_signal_error(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg10, ptr32 & ecxOut, ptr32 & edxOut, union Eq_2 & ebxOut, union Eq_104400 & ebpOut, struct Eq_104401 & ediOut)
{
	Eq_2 ebx_11 = 0x080CE000;
	Eq_2 eax_13 = dwArg10;
	struct Eq_125612 * esi_19 = gs->ptrFFFFFFFC;
	if (dwArg10 == 0x00)
		eax_13.u0 = 134955153;
	if (esi_19 != null)
	{
		_dl_exception_create(esi_19->t0000, dwArg08, eax_13);
		esi_19->ptr0004->t0000 = dwArg04;
		ebx_11 = __longjmp(gs, (char *) &esi_19->ptr0004 + 4, 0x01, out ebp, out edi);
	}
	word32 ecx_130;
	fatal_error(dwArg20, dwArg28, edx, gs, out ecx_130);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg12 = <invalid>;
	ptr32 edx_88;
	ptr32 ecx_89;
	word32 ebx_132;
	Eq_2 eax_87 = _dl_catch_exception(gs, dwArg04, dwArg08, stackArg12, out ecx_89, out edx_88, out ebx_132);
	ecxOut = ecx_89;
	edxOut = edx_88;
	ebxOut = ebx_11;
	ebpOut = ebp;
	ediOut = edi;
	return eax_87;
}

// 08093B00: Register Eq_2 _dl_catch_exception(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_125734) ecxOut, Register out (ptr32 Eq_125612) edxOut, Register out Eq_125736 ebxOut)
// Called from:
//      _dl_signal_error
//      _dl_catch_error
//      _dl_open
//      _dl_map_object_deps
//      _dl_sym
Eq_2 _dl_catch_exception(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_125734 & ecxOut, struct Eq_125612 & edxOut, union Eq_125736 & ebxOut)
{
	Eq_2 ebx_48;
	Eq_2175 ebx_17 = gs->t0014;
	struct Eq_125612 * edx_25 = gs->ptrFFFFFFFC;
	gs->ptrFFFFFFFC = fp - 0xB4;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	struct Eq_125734 * ecx_124;
	struct Eq_125612 * edx_126;
	Eq_2 eax_38 = __sigsetjmp(0x00, ebp, esi, edi, gs, stackArg0, fp - 0xAC, null, out ecx_124, out edx_126);
	if (eax_38 == 0x00)
	{
		dwArg08();
		gs->ptrFFFFFFFC = edx_25;
		*dwArg04 = 0x00;
		*((word32) dwArg04 + 4) = 0x00;
		*((word32) dwArg04 + 8) = 0x00;
		ebx_48 = eax_38;
		ecx_124 = (struct Eq_125734 *) &g_t80CE000;
		edx_126 = edx_25;
	}
	else
	{
		gs->ptrFFFFFFFC = edx_25;
		ebx_48 = dwLocB8;
	}
	Eq_125736 ebx_76 = ebx_17 ^ gs->t0014;
	if (ebx_76 != 0x00)
	{
		word32 ecx_145;
		word32 edx_146;
		__stack_chk_fail(out ecx_145, out edx_146);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		struct Eq_125734 * ecx_88;
		struct Eq_125612 * edx_89;
		word32 esi_150;
		Eq_2 eax_90 = _dl_catch_error(gs, stackArg4, stackArg8, stackArg12, out ecx_88, out edx_89, out esi_150);
		ecxOut = ecx_88;
		edxOut = edx_89;
		ebxOut = ebx_76;
		return eax_90;
	}
	else
	{
		ecxOut = ecx_124;
		edxOut = edx_126;
		ebxOut = ebx;
		return ebx_48;
	}
}

// 08093C00: Register Eq_2 _dl_catch_error(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_125136 ecxOut, Register out (ptr32 Eq_125137) edxOut, Register out Eq_2 esiOut)
// Called from:
//      dlerror_run
//      _dl_catch_exception
//      _dlerror_run
Eq_2 _dl_catch_error(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_125136 & ecxOut, struct Eq_125137 & edxOut, union Eq_2 & esiOut)
{
	Eq_2175 eax_15 = gs->t0014;
	word32 ecx_103;
	word32 edx_104;
	word32 ebx_105;
	Eq_2 eax_32 = _dl_catch_exception(gs, fp - 0x1C, dwArg10, dwArg14, out ecx_103, out edx_104, out ebx_105);
	*dwArg04 = dwLoc1C;
	*dwArg08 = dwLoc18;
	dwArg0C->u0 = (int8) (dwLoc14 == dwLoc18);
	Eq_125136 ecx_45 = eax_15 ^ gs->t0014;
	if (ecx_45 != 0x00)
	{
		word32 ecx_106;
		word32 edx_107;
		__stack_chk_fail(out ecx_106, out edx_107);
		struct Eq_125137 * edx_54;
		Eq_125136 ecx_55;
		Eq_2 eax_53 = __sigsetjmp(dwArg0C, ebp, dwArg08, dwArg04, gs, dwLoc1C, dwLoc18, dwLoc14, out ecx_55, out edx_54);
		ecxOut = ecx_55;
		edxOut = edx_54;
		esiOut = dwArg08;
		return eax_53;
	}
	else
	{
		ecxOut = ecx_45;
		edxOut = dwLoc18;
		esiOut = esi;
		return eax_32;
	}
}

// 08093C70: Register word32 __sigsetjmp(Register Eq_2 ebx, Register word32 ebp, Register Eq_2 esi, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack (ptr32 Eq_125137) dwArg04, Stack (ptr32 Eq_125137) dwArg08, Register out ptr32 ecxOut, Register out Eq_952 edxOut)
// Called from:
//      _dl_catch_exception
//      _dl_catch_error
word32 __sigsetjmp(Eq_2 ebx, word32 ebp, Eq_2 esi, Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg00, struct Eq_125137 * dwArg04, struct Eq_125137 * dwArg08, ptr32 & ecxOut, union Eq_952 & edxOut)
{
	dwArg04->t0000 = ebx;
	dwArg04->t0004 = esi;
	dwArg04->t0008 = edi;
	dwArg04->t0010 = __rol(fp + 0x04 ^ gs->t0018, 0x09);
	dwArg04->t0014 = __rol(dwArg00 ^ gs->t0018, 0x09);
	dwArg04->dw000C = ebp;
	dwArg04->dw0028 = 0x00;
	word32 eax_29 = __sigjmp_save(dwArg04, dwArg08);
	ecxOut = 0x00;
	edxOut.u0 = <invalid>;
	return eax_29;
}

// 08093CC0: Register word32 __sigjmp_save(Stack (ptr32 Eq_125137) dwArg04, Stack (ptr32 Eq_125137) dwArg08)
// Called from:
//      __sigsetjmp
word32 __sigjmp_save(struct Eq_125137 * dwArg04, struct Eq_125137 * dwArg08)
{
	if (dwArg08 != null)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		word32 edx_65;
		sigprocmask(gs, stackArg4, stackArg8, stackArg12, out edx_65);
		dwArg04->ptr0018 = (word32) (dwArg04 == (struct Eq_125137 *) 0x1C);
		return;
	}
	else
	{
		dwArg04->ptr0018 = dwArg08;
		return;
	}
}

// 08093D10: Register word32 __longjmp(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_125658) dwArg04, Stack word32 dwArg08, Register out ptr32 ebpOut, Register out ptr32 ediOut)
// Called from:
//      _dl_signal_exception
//      _dl_signal_error
word32 __longjmp(struct Eq_9 * gs, struct Eq_125658 * dwArg04, word32 dwArg08, ptr32 & ebpOut, ptr32 & ediOut)
{
	word32 edx_7 = 0x00 - dwArg04->dw0028;
	if (edx_7 != 0x00)
	{
		uint32 edx_12 = (-edx_7 >> 0x02) + 0x01;
		uint32 ebx_14 = 0xFF;
		do
		{
			if (edx_12 < ebx_14)
				ebx_14 = edx_12;
			__lfence();
			edx_12 -= ebx_14;
		} while (edx_12 > 0x00);
	}
	word32 ecx_32 = dwArg04->dw0010;
	<anonymous> * edx_39 = __ror(dwArg04->t0014, 0x09) ^ gs->t0018;
	edx_39();
	word32 ebx_45 = dwArg04->dw0000;
	ptr32 edi_47 = dwArg04->ptr0008;
	ebpOut = dwArg04->ptr000C;
	ediOut = edi_47;
	return ebx_45;
}

// 08093D70: Register ui32 __mpn_cmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __printf_fp_l
//      __mpn_divrem
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n
ui32 __mpn_cmp(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	ui32 eax_13 = dwArg0C - 0x01;
	if (dwArg0C >= 0x01)
	{
		do
		{
			up32 edx_19 = *((word32) dwArg04 + eax_13 * 0x04);
			up32 ecx_21 = *((word32) dwArg08 + eax_13 * 0x04);
			if (edx_19 != ecx_21)
				return (0x00 - (word32) (ecx_21 < edx_19) & 0x02) - 0x01;
			--eax_13;
		} while (eax_13 != ~0x00);
	}
	return 0x00;
}

// 08093DC0: Register word32 __mpn_divrem(Stack (arr Eq_77786) dwArg04, Stack int32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18)
// Called from:
//      hack_digit
word32 __mpn_divrem(Eq_77786 dwArg04[], int32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18)
{
	word32 dwLoc24_586;
	if (dwArg18 == 0x01)
	{
		dwLoc24_586 = 0x00;
		Eq_126024 ebx_22 = *dwArg14;
		Eq_126024 edx_24 = (dwArg0C - 0x04)[dwArg10];
		if (ebx_22 <= edx_24)
		{
			dwLoc24_586 = 0x01;
			edx_24 -= ebx_22;
		}
		uint32 edi_36[] = dwArg04 + dwArg08;
		if (dwArg10 >= 0x02)
		{
			int32 ecx_40 = dwArg10 - 0x02 << 0x02;
			do
			{
				uint64 edx_eax_49 = SEQ(edx_24, *((word32) dwArg0C + ecx_40));
				edi_36[ecx_40 / 4] = (uint32) (edx_eax_49 /u ebx_22);
				edx_24.u0 = (uint32) (edx_eax_49 % ebx_22);
				ecx_40 -= 0x04;
			} while (ecx_40 != ~0x03);
		}
		if (dwArg08 > 0x00)
		{
			struct Eq_126259 * ecx_66 = edi_36 - 0x04;
			ptr32 edi_69 = edi_36 - dwArg08 * 0x04;
			do
			{
				uint64 edx_eax_81 = SEQ(edx_24, 0x00);
				ecx_66 -= 0x04;
				ecx_66[1] = (struct Eq_126259) (uint32) (edx_eax_81 /u ebx_22);
				edx_24.u0 = (uint32) (edx_eax_81 % ebx_22);
			} while (edi_69 - 0x04 != ecx_66);
		}
		*dwArg0C = edx_24;
		return dwLoc24_586;
	}
	if (dwArg18 != 0x02)
	{
		if (dwArg18 != 0x00)
		{
			Eq_2 edi_287 = (word32) dwArg0C + (dwArg10 - dwArg18) * 0x04;
			dwLoc24_586 = 0x00;
			uint32 ebp_292 = *((word32) dwArg14 + ((word32) dwArg18 + 0x3FFFFFFF) * 0x04);
			uint32 ecx_298 = (dwArg14 - 0x04)[(word32) dwArg18 + 0x3FFFFFFF];
			uint32 ebx_299 = *((word32) edi_287 + ((word32) dwArg18 + 0x3FFFFFFF) * 0x04);
			if (ebp_292 <= ebx_299 && (ebp_292 < ebx_299 || __mpn_cmp(edi_287, dwArg14, dwArg18 - 0x01) >= 0x00))
			{
				uint32 * esi_346;
				__mpn_sub_n(edi_287, edi_287, dwArg14, dwArg18, out esi_346, out edi_287);
				ebx_299 = *esi_346;
				dwLoc24_586 = 0x01;
			}
			struct Eq_126092 * esp_356 = fp - 0x3C;
			if ((word32) dwArg10 + dwArg08 - dwArg18 >= 0x01)
			{
				Eq_2 ecx_372 = edi_287;
				uint32 edi_373 = ecx_298;
				do
				{
					if (esp_356[0x0011] <= esp_356[1])
					{
						int32 esi_400 = esp_356[5];
						Eq_2 eax_401 = ecx_372 - 0x04;
						word32 ecx_402 = *((word32) ecx_372 + esi_400);
						esp_356[3] = (struct Eq_126092) ((word32) eax_401 + esi_400);
						esp_356[4] = (struct Eq_126092) ecx_402;
						ecx_372 = eax_401;
					}
					else
					{
						int32 edx_380 = esp_356[21];
						word32 eax_382 = Mem375[esp_356 + 0x14:word32] + ecx_372;
						esp_356[3] = (struct Eq_126092) eax_382;
						esp_356[4] = (struct Eq_126092) *eax_382;
						word32 eax_387 = Mem385[esp_356 + 0x1C:word32] + ecx_372;
						if (edx_380 > 0x00)
						{
							do
							{
								eax_387 -= 0x04;
								*((word32) eax_387 + 4) = *((word32) eax_387 - 4);
							} while (ecx_372 != eax_387);
						}
						*ecx_372 = 0x00;
					}
					Eq_2 esi_408 = ~0x00;
					if (ebp_292 != ebx_299)
					{
						uint64 edx_eax_426 = SEQ(ebx_299, *esp_356[3].dw0000);
						uint32 eax_429 = (uint32) (edx_eax_426 /u ebp_292);
						esp_356->dw0000 = eax_429;
						uint64 edx_eax_438 = eax_429 *64 edi_373;
						uint32 ebx_431 = (uint32) (edx_eax_426 % ebp_292);
						uint32 edx_439 = SLICE(edx_eax_438, word32, 32);
						uint32 eax_440 = (word32) edx_eax_438;
						while (edx_439 > ebx_431 || edx_439 == ebx_431 && Mem448[ecx_372 + Mem448[esp_356 + 0x08:word32]:word32] <u eax_440)
						{
							--esp_356->dw0000;
							ebx_431 += ebp_292;
							if (ebx_431 < 0x00)
								break;
							edx_439 -= (word32) (eax_440 < edi_373);
							eax_440 -= edi_373;
						}
						esi_408 = esp_356->dw0000;
					}
					struct Eq_126159 * esp_477 = esp_356 - 4;
					esp_477->t0000 = esi_408;
					esp_477->tFFFFFFFC = esp_477->t0058;
					esp_477->tFFFFFFF8 = esp_477->t0054;
					esp_477->tFFFFFFF4 = ecx_372;
					esp_477->t0004 = ecx_372;
					word32 eax_493 = __mpn_submul_1(esp_477->tFFFFFFF4, esp_477->tFFFFFFF8, esp_477->tFFFFFFFC, esp_477->t0000);
					esp_356 = (struct Eq_126092 *) &esp_477->t0004;
					ecx_372 = esp_477->t0004;
					if (esp_477->dw0014 != eax_493)
					{
						esp_477->t0000 = esp_477->t0058;
						esp_477->tFFFFFFFC = esp_477->t0054;
						esp_477->tFFFFFFF8 = ecx_372;
						esp_477->tFFFFFFF4 = ecx_372;
						esp_477->t0004 = ecx_372;
						word32 ebx_866;
						__mpn_add_n(esp_477->tFFFFFFF4, esp_477->tFFFFFFF8, esp_477->tFFFFFFFC, esp_477->t0000, out ebx_866, out esi_408, out edi_373);
						Eq_2 esp_520 = <invalid>;
						esp_356 = (word32) esp_520 + 16;
						ecx_372 = *((word32) esp_520 + 16);
					}
					int32 eax_533 = esp_356[1];
					*((word32) esp_356[16].dw0000 + eax_533 * 0x04) = (struct Eq_126092) esi_408;
					uint32 * esi_537 = esp_356[3];
					esp_356[1] = (struct Eq_126092) (eax_533 - 0x01);
					ebx_299 = *esi_537;
				} while (eax_533 != 0x00);
			}
			return dwLoc24_586;
		}
	}
	struct Eq_126037 * eax_101 = dwArg0C - 0x08 + dwArg10 * 0x04;
	uint32 ecx_104 = eax_101[1];
	Eq_126024 ebx_105 = eax_101->dw0000;
	word32 dwLoc24_596 = 0x00;
	uint32 edi_102 = *((word32) dwArg14 + 4);
	struct Eq_126037 * dwLoc34_597 = eax_101;
	Eq_126024 ebp_107 = *dwArg14;
	uint64 ecx_ebx_576 = SEQ(ecx_104, ebx_105);
	if (edi_102 <= ecx_104)
	{
		if (edi_102 >= ecx_104)
		{
			ecx_ebx_576 = SEQ(ecx_104, ebx_105);
			if (ebp_107 > ebx_105)
				goto l08094046;
		}
		ecx_ebx_576 = SEQ(ecx_104, ebx_105) - SEQ(edi_102, ebp_107);
		dwLoc24_596 = 0x01;
		goto l08094046;
	}
	else
	{
l08094046:
		int32 eax_128 = (word32) dwArg10 + (dwArg08 - 0x03);
		uint32 ebx_185 = (word32) ecx_ebx_576;
		uint32 ecx_188 = SLICE(ecx_ebx_576, word32, 32);
		int32 dwLoc3C_603 = eax_128;
		if (eax_128 >= 0x00)
		{
			uint64 ecx_ebx_578 = ecx_ebx_576;
			do
			{
				uint64 edx_ebp_862;
				uint32 dwLoc38_608;
				uint32 ecx_158;
				uint32 ebx_168;
				uint32 eax_176;
				word32 ebx_154 = (word32) ecx_ebx_578;
				uint32 ecx_146 = SLICE(ecx_ebx_578, word32, 32);
				if (dwArg08 > dwLoc3C_603)
				{
					dwLoc34_597->dw0000 = 0x00;
					dwLoc38_608 = 0x00;
					if (edi_102 != ecx_146)
						goto l080940C8;
					goto l0809407A;
				}
				dwLoc34_597 -= 0x04;
				dwLoc38_608 = dwLoc34_597->dwFFFFFFFC;
				if (edi_102 != ecx_146)
				{
l080940C8:
					uint32 eax_199 = (uint32) (ecx_ebx_578 /u edi_102);
					ebx_168 = eax_199;
					ecx_158 = (uint32) (ecx_ebx_578 % edi_102);
					eax_176 = dwLoc38_608;
					edx_ebp_862 = eax_199 *64 ebp_107;
					goto l080940E0;
				}
l0809407A:
				uint32 ebx_156 = ebx_154 + edi_102;
				ecx_158 = ebx_156;
				if (ebx_156 >= 0x00)
				{
					ebx_168 = ~0x00;
					eax_176 = dwLoc38_608;
					edx_ebp_862 = SEQ(ebp_107 - (uint32) ((int8) (ebp_107 != 0x00)), -ebp_107);
l080940E0:
					do
					{
						uint64 edx_ebp_855;
						uint32 ebp_218 = (word32) edx_ebp_862;
						uint32 edx_213 = SLICE(edx_ebp_862, word32, 32);
						if (edx_213 <= ecx_158)
						{
							edx_ebp_855 = edx_ebp_862;
							if (edx_213 != ecx_158)
								break;
							edx_ebp_855 = edx_ebp_862;
							if (ebp_218 <= eax_176)
								break;
						}
						up32 ebp_228 = ebp_218 - ebp_107;
						word32 edx_232 = edx_213 - (word32) (ebp_228 < 0x00);
						--ebx_168;
						ecx_158 += edi_102;
						edx_ebp_855 = SEQ(edx_232, ebp_228);
						edx_ebp_862 = SEQ(edx_232, ebp_228);
					} while (ecx_158 >= 0x00);
					dwArg04[dwLoc3C_603].u0 = ebx_168;
					int32 v29_246 = dwLoc3C_603 - 0x01;
					ecx_ebx_578 = SEQ(ecx_158, dwLoc38_608) - edx_ebp_855;
					dwLoc3C_603 = v29_246;
					ebx_185 = (word32) ecx_ebx_578;
					ecx_188 = SLICE(ecx_ebx_578, word32, 32);
					if (v29_246 == ~0x00)
						break;
					continue;
				}
				dwArg04[dwLoc3C_603].u0 = ~0x00;
				ebx_185 = (word32) ebp_107.u0 + dwLoc38_608;
				int32 v30_180 = dwLoc3C_603 - 0x01;
				ecx_188 = ebx_156 - ebp_107 + (word32) (ebx_185 < 0x00);
				dwLoc3C_603 = v30_180;
				ecx_ebx_578 = SEQ(ecx_188, ebx_185);
			} while (v30_180 != ~0x00);
		}
		dwLoc34_597[1] = (struct Eq_126037) ecx_188;
		dwLoc34_597->dw0000 = ebx_185;
		return dwLoc24_596;
	}
}

// 080941C0: void __mpn_lshift(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 bArg10)
// Called from:
//      __printf_fp_l
void __mpn_lshift(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 bArg10)
{
	byte cl_21 = (byte) dwArg10;
	ui32 esi_17[] = dwArg08 - 0x04;
	ui32 ebx_18 = (dwArg08 - 0x04)[dwArg0C];
	ui32 edx_23 = dwArg0C - 0x01;
	byte dl_37 = (byte) dwArg0C - 0x01;
	if (dwArg0C == 0x01)
	{
		*dwArg04 = ebx_18 << cl_21;
		return;
	}
	ui32 eax_41;
	if ((dl_37 & 0x01) == 0x00)
	{
		eax_41 = ebx_18;
		esi_17 = dwArg08 - 0x04;
l080941F0:
		ebx_18 = esi_17[edx_23];
		*((word32) dwArg04 + edx_23 * 0x04) = __shld(eax_41, ebx_18, cl_21);
		--edx_23;
	}
	eax_41 = esi_17[edx_23];
	*((word32) dwArg04 + edx_23 * 0x04) = __shld(ebx_18, eax_41, cl_21);
	--edx_23;
	if (edx_23 == 0x00)
	{
		*dwArg04 = eax_41 << cl_21;
		return;
	}
	goto l080941F0;
}

// 08094220: void __mpn_rshift(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 bArg10)
// Called from:
//      __printf_fp_l
void __mpn_rshift(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 bArg10)
{
	uint32 esi_18[] = (word32) dwArg08 + dwArg0C * 0x04;
	ui32 edx_19 = -dwArg0C;
	byte cl_23 = (byte) dwArg10;
	Eq_126616 edi_17[] = dwArg04 - 0x04 + dwArg0C * 0x04;
	uint32 ebx_20 = esi_18[edx_19];
	ui32 edx_25 = edx_19 + 0x01;
	byte dl_39 = (byte) edx_19 + 0x01;
	if (edx_19 == 0x01)
	{
		edi_17[0] = ebx_20 >> cl_23;
		return;
	}
	uint32 eax_43;
	if ((dl_39 & 0x01) == 0x00)
	{
		eax_43 = ebx_20;
l08094258:
		ebx_20 = esi_18[edx_25];
		edi_17[edx_25].u0 = __shrd(eax_43, ebx_20, cl_23);
		++edx_25;
	}
	eax_43 = esi_18[edx_25];
	edi_17[edx_25].u0 = __shrd(ebx_20, eax_43, cl_23);
	++edx_25;
	if (edx_25 == 0x00)
	{
		edi_17[0] = eax_43 >> cl_23;
		return;
	}
	goto l08094258;
}

// 08094280: Register Eq_2 __mpn_mul(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out (ptr32 Eq_81332) ebpOut, Register out (ptr32 Eq_81333) esiOut, Register out Eq_2 ediOut)
// Called from:
//      __printf_fp_l
//      __mpn_mul
Eq_2 __mpn_mul(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, struct Eq_81332 & ebpOut, struct Eq_81333 & esiOut, union Eq_2 & ediOut)
{
	struct Eq_126652 * esp_17 = fp - 0x5C;
	Eq_2 edi_103 = dwArg04;
	Eq_2 esi_170 = dwArg14;
	Eq_2175 eax_26 = gs->t0014;
	Eq_2 eax_28 = 0x00;
	if (dwArg14 > 0x1F)
	{
		ui32 eax_31 = dwArg14 * 0x08 + 0x1B;
		struct Eq_126652 * ebx_37 = fp - 0x5C - (eax_31 & ~0x0FFF);
		if (fp - 0x5C != ebx_37)
		{
			do
			{
				esp_17 -= 0x1000;
				esp_17->dw0FFC = esp_17->dw0FFC;
			} while (esp_17 != ebx_37);
		}
		int32 edx_52 = eax_31 & ~0x0F & 0x0FFF;
		if (edx_52 != 0x00)
		{
			esp_17 -= edx_52;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[edx_52 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[edx_52 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		Eq_126725 ecx_70 = (char *) esp_17 + 0x0F;
		struct Eq_126728 * esp_71 = esp_17 - 0x0C;
		esp_71->tFFFFFFFC = ecx_70 & ~0x0F;
		esp_71->tFFFFFFF8 = dwArg14;
		esp_71->tFFFFFFF4 = dwArg10;
		esp_71->tFFFFFFF0 = dwArg08;
		esp_71->tFFFFFFEC = dwArg04;
		__mpn_impn_mul_n(esp_71->tFFFFFFEC, esp_71->tFFFFFFF0, esp_71->tFFFFFFF4, esp_71->tFFFFFFF8, esp_71->tFFFFFFFC);
		edi_103 = (word32) dwArg08 + dwArg14 * 0x04;
		Eq_2 eax_108 = dwArg0C - dwArg14;
		struct Eq_126776 * esp_102 = (char *) &esp_71->tFFFFFFFC + 16;
		Eq_2 ebx_105 = (word32) dwArg04 + dwArg14 * 0x04;
		Eq_2 dwLoc38_674 = edi_103;
		Eq_2 dwLoc30_675 = eax_108;
		if (dwArg14 <= eax_108)
		{
			struct Eq_126776 * ecx_116 = (char *) &esp_71->tFFFFFFFC + 16 - (eax_31 & ~0x0FFF);
			if ((char *) &esp_71->tFFFFFFFC + 16 != ecx_116)
			{
				do
				{
					esp_102 -= 0x1000;
					esp_102->dw0FFC = esp_102->dw0FFC;
				} while (esp_102 != ecx_116);
			}
			int32 edx_132 = eax_31 & ~0x0F & 0x0FFF;
			if (edx_132 != 0x00)
			{
				esp_102 -= edx_132;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_102 - 0x04)[edx_132 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_102 - 0x04)[edx_132 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_126810 eax_144 = (char *) esp_102 + 0x0F;
			word32 * eax_150 = (eax_144 & ~0x0F) + dwArg14 * 0x04;
			do
			{
				int32 edi_225;
				struct Eq_126831 * ecx_226;
				struct Eq_126869 * esp_164 = esp_102 - 0x0C;
				esp_164->tFFFFFFFC = ecx_70 & ~0x0F;
				esp_164->tFFFFFFF8 = esi_170;
				esp_164->tFFFFFFF4 = dwArg10;
				esp_164->tFFFFFFF0 = dwLoc38_674;
				esp_164->tFFFFFFEC = eax_144 & ~0x0F;
				__mpn_impn_mul_n(esp_164->tFFFFFFEC, esp_164->tFFFFFFF0, esp_164->tFFFFFFF4, esp_164->tFFFFFFF8, esp_164->tFFFFFFFC);
				esp_164->t0008 = esi_170;
				esp_164->t0004 = eax_144 & ~0x0F;
				esp_164->t0000 = ebx_105;
				esp_164->tFFFFFFFC = ebx_105;
				ebx_105 = ebx_202 + dwArg14 * 0x04;
				word32 ebx_202;
				Eq_2 esi_204;
				word32 edi_1061;
				up32 eax_214 = (word32) __mpn_add_n(esp_164->tFFFFFFFC, esp_164->t0000, esp_164->t0004, esp_164->t0008, out ebx_202, out esi_204, out edi_1061) + *eax_150;
				*ebx_105 = eax_214;
				Eq_2 esp_201 = <invalid>;
				esp_102 = (word32) esp_201 + 16;
				struct Eq_126831 * edx_213 = (word32) ebx_105 + 4;
				if ((uint32) (int8) (eax_214 < 0x00) != 0x00)
				{
					ecx_226 = (struct Eq_126831 *) (eax_150 + 1);
					word32 edi_230 = esi_204 - 0x01;
					do
					{
						++ecx_226;
						word32 eax_235 = ecx_226->dwFFFFFFFC;
						++edx_213;
						edx_213->dwFFFFFFFC = eax_235 + 0x01;
						if (eax_235 != 0x01)
						{
							if (ecx_226 == edx_213)
								break;
							edi_225 = edi_230 - 0x01;
							if (edi_225 <= 0x00)
								break;
							goto l08094608;
						}
						--edi_230;
					} while (edi_230 != 0x00);
				}
				else
				{
					edi_225 = dwArg14 - 0x01;
					ecx_226 = (struct Eq_126831 *) (eax_150 + 1);
					if (eax_150 + 1 != (word32) ebx_105 + 4)
					{
l08094608:
						int32 eax_254 = 0x00;
						esi_170 = esi_204;
						do
						{
							edx_213[eax_254] = ecx_226[eax_254];
							++eax_254;
						} while (eax_254 < edi_225);
						Eq_2 v30_272 = dwLoc30_675 - esi_204;
						dwLoc30_675 = v30_272;
						edi_103 = dwArg14 * 0x04;
						dwLoc38_674 = (word32) dwLoc38_674 + dwArg14 * 0x04;
						if (esi_204 > v30_272)
							break;
						continue;
					}
				}
				Eq_2 v24_287 = dwLoc30_675 - esi_204;
				esi_170 = esi_204;
				dwLoc30_675 = v24_287;
				edi_103 = dwArg14 * 0x04;
				dwLoc38_674 = (word32) dwLoc38_674 + dwArg14 * 0x04;
			} while (esi_204 <= v24_287);
		}
		if (dwLoc30_675 != 0x00)
		{
			struct Eq_126958 * esp_307 = esp_102 - 0x0C;
			esp_307->tFFFFFFFC = dwLoc30_675;
			esp_307->tFFFFFFF8 = dwLoc38_674;
			esp_307->tFFFFFFF4 = esi_170;
			esp_307->tFFFFFFF0 = dwArg10;
			esp_307->dwFFFFFFEC = ecx_70 & ~0x0F;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			word32 esi_1064;
			word32 edi_1065;
			word32 ebp_1063;
			__mpn_mul(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, out ebp_1063, out esi_1064, out edi_1065);
			esp_307->t0008 = esi_170;
			esp_307->t0004 = ecx_70 & ~0x0F;
			esp_307->t0000 = ebx_105;
			esp_307->tFFFFFFFC = ebx_105;
			word32 * ecx_377 = edi_368 + dwArg14 * 0x04;
			word32 ebx_367;
			word32 edi_368;
			Eq_2 esi_369;
			up32 eax_379 = (word32) __mpn_add_n(esp_307->tFFFFFFFC, esp_307->t0000, esp_307->t0004, esp_307->t0008, out ebx_367, out esi_369, out edi_368) + *ecx_377;
			up32 * ebx_378 = ebx_367 + dwArg14 * 0x04;
			*ebx_378 = eax_379;
			Eq_2 ecx_385 = (word32) (eax_379 < 0x00);
			struct Eq_127037 * edx_381 = ecx_377 + 1;
			edi_103 = ecx_385;
			struct Eq_127037 * ecx_387 = ebx_378 + 1;
			if (ecx_385 != 0x00)
			{
				Eq_2 ebx_391 = dwLoc30_675;
				esi_170 = esi_369;
				do
				{
					--ebx_391;
					if (ebx_391 == 0x00)
						goto l0809445F;
					++edx_381;
					word32 eax_400 = edx_381->dwFFFFFFFC;
					++ecx_387;
					ecx_387->dwFFFFFFFC = eax_400 + 0x01;
				} while (eax_400 == 0x01);
				dwLoc30_675 = ebx_391;
			}
			esi_170 = esi_369;
			if (ecx_387 != edx_381 && dwLoc30_675 > 0x01)
			{
				struct Eq_127037 * eax_419 = edx_381 - 0x04 + dwLoc30_675 * 0x04;
				esi_170 = esi_369;
				do
				{
					++ecx_387;
					ecx_387->dwFFFFFFFC = edx_381->dw0000;
					++edx_381;
				} while (edx_381 != eax_419);
			}
		}
l0809445F:
		eax_28 = *((word32) dwArg04 + ((word32) esi_170 + ((word32) dwArg0C + 0x3FFFFFFF)) * 0x04);
l080942B6:
		struct Eq_81333 * esi_609 = eax_26 ^ gs->t0014;
		if (esi_609 != null)
		{
			word32 edx_1060;
			word32 ecx_1059;
			__stack_chk_fail(out ecx_1059, out edx_1060);
			word32 ecx_1066;
			Eq_2 eax_619 = __mpn_mul_1(dwArg04, dwArg08, dwArg0C, dwArg10, out ecx_1066);
			ebpOut = fp - 4;
			esiOut = esi_609;
			ediOut = edi_103;
			return eax_619;
		}
		else
		{
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return eax_28;
		}
	}
	if (dwArg14 == 0x00)
		goto l080942B6;
	Eq_2 eax_445 = *dwArg10;
	if (eax_445 > 0x01)
	{
		word32 ecx_1067;
		eax_28 = __mpn_mul_1(dwArg04, dwArg08, dwArg0C, eax_445, out ecx_1067);
		goto l0809448A;
	}
	if (eax_445 != 0x01)
	{
		Eq_2 eax_492 = dwArg04;
		Eq_2 edx_493 = (word32) dwArg04 + dwArg0C * 0x04;
		if (dwArg0C > 0x00)
		{
			do
			{
				*eax_492 = 0x00;
				eax_492 = (word32) eax_492 + 4;
			} while (edx_493 != eax_492);
		}
	}
	else if (dwArg0C > 0x00)
	{
		Eq_2 edx_474 = dwArg04;
		Eq_2 eax_475 = dwArg08;
		Eq_2 ecx_476 = (word32) dwArg08 + dwArg0C * 0x04;
		do
		{
			edx_474 = (word32) edx_474 + 4;
			*((word32) edx_474 - 4) = *eax_475;
			eax_475 = (word32) eax_475 + 4;
		} while (eax_475 != ecx_476);
		eax_28.u0 = 0x00;
l0809448A:
		*((word32) dwArg04 + dwArg0C * 0x04) = eax_28;
		ptr32 esp_541 = fp - 0x5C;
		Eq_2 ebx_517 = (word32) dwArg04 + 4;
		if (dwArg14 > 0x01)
		{
			Eq_2 esi_526 = (word32) dwArg04 + dwArg14 * 0x04;
			word32 * esi_530 = (word32) dwArg10 + 4;
			edi_103 = dwArg0C << 0x02;
			do
			{
				uint32 eax_534 = *esi_530;
				if (eax_534 > 0x01)
				{
					struct Eq_127168 * esp_565 = esp_541 - 4;
					esp_565->dw0000 = eax_534;
					esp_565->tFFFFFFFC = dwArg0C;
					esp_565->tFFFFFFF8 = dwArg08;
					esp_565->tFFFFFFF4 = ebx_517;
					eax_28 = __mpn_addmul_1(esp_565->tFFFFFFF4, esp_565->tFFFFFFF8, esp_565->tFFFFFFFC, esp_565->dw0000);
					esp_541 = &esp_565->dw0000 + 1;
				}
				else
				{
					eax_28.u0 = 0x00;
					if (eax_534 == 0x01)
					{
						struct Eq_127229 * esp_542 = esp_541 - 4;
						esp_542->t0000 = dwArg0C;
						esp_542->tFFFFFFFC = dwArg08;
						esp_542->tFFFFFFF8 = ebx_517;
						esp_542->tFFFFFFF4 = ebx_517;
						Eq_2 esp_555 = <invalid>;
						eax_28 = __mpn_add_n(esp_542->tFFFFFFF4, esp_542->tFFFFFFF8, esp_542->tFFFFFFFC, esp_542->t0000, out ebx_517, out esi_530, out edi_103);
						esp_541 = (word32) esp_555 + 16;
					}
				}
				Mem588[ebx_517 + edi_103:word32] = eax_28;
				++esi_530;
				ebx_517 = (word32) ebx_517 + 4;
			} while (esi_526 != ebx_517);
		}
		goto l080942B6;
	}
	eax_28.u0 = 0x00;
	goto l0809448A;
}

// 08094660: Register word32 __mpn_mul_1(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_77741 ecxOut)
// Called from:
//      hack_digit
//      __printf_fp_l
//      __mpn_mul
//      __mpn_impn_mul_n_basecase
//      __mpn_impn_sqr_n_basecase
word32 __mpn_mul_1(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_77741 & ecxOut)
{
	up32 edi_20[] = (word32) dwArg04 + dwArg0C * 0x04;
	uint32 esi_21[] = (word32) dwArg08 + dwArg0C * 0x04;
	Eq_77741 ecx_22 = -dwArg0C;
	word32 ebp_23 = 0x00;
	do
	{
		uint64 edx_eax_32 = dwArg10 *64 esi_21[ecx_22];
		up32 eax_35 = (word32) edx_eax_32 + ebp_23;
		edi_20[ecx_22] = eax_35;
		word32 edx_41 = SLICE(edx_eax_32, word32, 32) + (word32) (eax_35 < 0x00);
		ebp_23 = edx_41;
		ecx_22 = (word32) ecx_22.u0 + 1;
	} while (ecx_22 != 0x00);
	ecxOut = ecx_22;
	return edx_41;
}

// 080946B0: void __mpn_impn_mul_n_basecase(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __mpn_impn_mul_n
//      __mpn_mul_n
void __mpn_impn_mul_n_basecase(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 eax_32;
	Eq_2 eax_19 = *dwArg0C;
	if (eax_19 <= 0x01)
	{
		if (eax_19 != 0x01)
		{
			Eq_2 eax_61 = dwArg04;
			Eq_2 edx_62 = (word32) dwArg04 + dwArg10 * 0x04;
			if (dwArg10 > 0x00)
			{
				do
				{
					*eax_61 = 0x00;
					eax_61 = (word32) eax_61 + 4;
				} while (eax_61 != edx_62);
			}
		}
		else if (dwArg10 > 0x00)
		{
			Eq_2 eax_45 = dwArg08;
			Eq_2 edx_47 = dwArg04;
			Eq_2 ecx_48 = (word32) dwArg08 + dwArg10 * 0x04;
			do
			{
				edx_47 = (word32) edx_47 + 4;
				*((word32) edx_47 - 4) = *eax_45;
				eax_45 = (word32) eax_45 + 4;
			} while (eax_45 != ecx_48);
		}
		eax_32.u0 = 0x00;
	}
	else
	{
		word32 ecx_248;
		eax_32 = __mpn_mul_1(dwArg04, dwArg08, dwArg10, eax_19, out ecx_248);
	}
	Eq_2 edi_126 = (word32) dwArg04 + dwArg10 * 0x04;
	*edi_126 = eax_32;
	struct Eq_127349 * esp_109 = fp - 0x1C;
	Eq_2 ebx_117 = (word32) dwArg04 + 4;
	if (dwArg10 > 0x01)
	{
		int32 esi_100 = dwArg10 * 0x04;
		word32 * ebp_101 = (word32) dwArg0C + 4;
		do
		{
			uint32 eax_104 = *ebp_101;
			if (eax_104 <= 0x01)
			{
				Eq_2 eax_107 = 0x00;
				if (eax_104 == 0x01)
				{
					struct Eq_127407 * esp_111 = esp_109 - 4;
					esp_111->t0000 = esp_109[11];
					esp_111->tFFFFFFFC = esp_111->t0028;
					esp_111->tFFFFFFF8 = ebx_117;
					esp_111->tFFFFFFF4 = ebx_117;
					Eq_2 esp_124 = <invalid>;
					eax_107 = __mpn_add_n(esp_111->tFFFFFFF4, esp_111->tFFFFFFF8, esp_111->tFFFFFFFC, esp_111->t0000, out ebx_117, out esi_100, out edi_126);
					esp_109 = (word32) esp_124 + 16;
				}
				*((word32) ebx_117 + esi_100) = eax_107;
				ebx_117 = (word32) ebx_117 + 4;
				++ebp_101;
				if (edi_126 != ebx_117)
					continue;
				return;
			}
			struct Eq_127361 * esp_146 = esp_109 - 4;
			esp_146->dw0000 = eax_104;
			esp_146->tFFFFFFFC = esp_146->t0030;
			esp_146->tFFFFFFF8 = esp_146->t0028;
			esp_146->tFFFFFFF4 = ebx_117;
			ebx_117 = (word32) ebx_117 + 4;
			(ebx_117 - 0x04)[esi_100 / 4] = __mpn_addmul_1(esp_146->tFFFFFFF4, esp_146->tFFFFFFF8, esp_146->tFFFFFFFC, esp_146->dw0000);
			++ebp_101;
			esp_109 = (struct Eq_127349 *) (&esp_146->dw0000 + 1);
		} while (edi_126 != ebx_117);
	}
}

// 080947E0: void __mpn_impn_mul_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      __mpn_mul
//      __mpn_impn_mul_n
//      __mpn_mul_n
void __mpn_impn_mul_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
	if ((dwArg10 & 0x01) != 0x00)
	{
		if (dwArg10 > 0x20)
			__mpn_impn_mul_n(dwArg04, dwArg08, dwArg0C, dwArg10 - 0x01, dwArg14);
		else
			__mpn_impn_mul_n_basecase(dwArg04, dwArg08, dwArg0C, dwArg10 - 0x01);
		Eq_2 esi_645 = (word32) dwArg04 + (dwArg10 - 0x01) * 0x04;
		*((word32) dwArg04 + (dwArg10 - 0x01) * 0x08) = __mpn_addmul_1(esi_645, dwArg08, dwArg10 - 0x01, *((word32) dwArg0C + (dwArg10 - 0x01) * 0x04));
		*((word32) dwArg04 + ((word32) dwArg10 + (dwArg10 - 0x01)) * 0x04) = __mpn_addmul_1(esi_645, dwArg0C, dwArg10, *((word32) dwArg08 + (dwArg10 - 0x01) * 0x04));
		return;
	}
	ui32 ecx_25 = (dwArg10 >> 0x01) * 0x04;
	Eq_2 eax_26 = (word32) dwArg0C + ecx_25;
	Eq_2 ecx_28 = (word32) dwArg08 + ecx_25;
	Eq_2 edi_34 = (word32) dwArg04 + dwArg10 * 0x04;
	if (dwArg10 >> 0x01 > 0x1F)
		__mpn_impn_mul_n(edi_34, ecx_28, eax_26, dwArg10 >> 0x01, dwArg14);
	else
		__mpn_impn_mul_n_basecase(edi_34, ecx_28, eax_26, dwArg10 >> 0x01);
	Eq_2 esi_112;
	if (__mpn_cmp(ecx_28, dwArg08, dwArg10 >> 0x01) >= 0x00)
	{
		word32 edi_923;
		__mpn_sub_n(dwArg04, ecx_28, dwArg08, dwArg10 >> 0x01, out esi_112, out edi_923);
	}
	else
	{
		word32 edi_922;
		__mpn_sub_n(dwArg04, dwArg08, ecx_28, dwArg10 >> 0x01, out esi_112, out edi_922);
	}
	Eq_2 edi_182;
	Eq_2 esi_183;
	Eq_2 ebp_163 = (word32) dwArg04 + ecx_25;
	if (__mpn_cmp(eax_26, dwArg0C, esi_112) >= 0x00)
		__mpn_sub_n(ebp_163, eax_26, dwArg0C, esi_112, out esi_183, out edi_182);
	else
		__mpn_sub_n(ebp_163, dwArg0C, eax_26, esi_112, out esi_183, out edi_182);
	if (esi_183 <= 0x1F)
	{
		__mpn_impn_mul_n_basecase(dwArg14, dwArg04, ebp_163, esi_183);
		if (esi_183 <= 0x00)
			goto l08094966;
	}
	else
		__mpn_impn_mul_n(dwArg14, dwArg04, ebp_163, esi_183, (word32) dwArg14 + dwArg10 * 0x04);
	Eq_2 eax_268 = 0x00;
	do
	{
		*((word32) ebp_163 + eax_268 * 0x04) = *((word32) edi_182 + eax_268 * 0x04);
		eax_268 = (word32) eax_268 + 1;
	} while (esi_183 > eax_268);
l08094966:
	Eq_2 esi_339;
	struct Eq_127541 * esp_346;
	word32 ecx_348;
	Eq_2 esp_306 = <invalid>;
	word32 esi_925;
	word32 edi_926;
	word32 ebx_924;
	Mem314[esp_306 + 0x1C:word32] = __mpn_add_n(edi_182, edi_182, dwArg04 + (dwArg10 + esi_183) * 0x04, esi_183, out ebx_924, out esi_925, out edi_926);
	word32 ecx_317 = *((word32) esp_306 + 44);
	if (*((word32) esp_306 + 36) != 0x00)
	{
		*((word32) esp_306 + 36) = ecx_317;
		*((word32) esp_306 + 0x0C) = *((word32) esp_306 + 92);
		*((word32) esp_306 + 8) = *((word32) esp_306 + 96);
		*((word32) esp_306 + 4) = ebp_163;
		*esp_306 = ebp_163;
		word32 edi_929;
		*((word32) esp_306 + 28) -= __mpn_sub_n(*esp_306, *((word32) esp_306 + 4), *((word32) esp_306 + 8), *((word32) esp_306 + 0x0C), out esi_339, out edi_929);
		esp_346 = (word32) esp_306 + 16;
		ecx_348 = (word32) *((word32) esp_306 + 36);
	}
	else
	{
		*((word32) esp_306 + 36) = ecx_317;
		*((word32) esp_306 + 0x0C) = *((word32) esp_306 + 92);
		*((word32) esp_306 + 8) = *((word32) esp_306 + 96);
		*((word32) esp_306 + 4) = ebp_163;
		*esp_306 = ebp_163;
		Eq_2 esp_336 = <invalid>;
		word32 edi_928;
		word32 ebx_927;
		Mem345[esp_336 + 0x1C:word32] = __mpn_add_n(*esp_306, *((word32) esp_306 + 4), *((word32) esp_306 + 8), *((word32) esp_306 + 0x0C), out ebx_927, out esi_339, out edi_928) + Mem332[esp_336 + 0x1C:word32];
		esp_346 = (word32) esp_336 + 16;
		ecx_348 = (word32) *((word32) esp_336 + 36);
	}
	Eq_2 ebx_426;
	Eq_2 ecx_434;
	Eq_2 esi_428;
	struct Eq_127760 * esp_433;
	esp_346->dw0014 = ecx_348;
	if (esi_339 <= 0x1F)
	{
		struct Eq_127773 * esp_442 = esp_346 - 4;
		esp_442->t0000 = esi_339;
		esp_442->tFFFFFFFC = esp_442->t004C;
		esp_442->tFFFFFFF8 = esp_442->t0048;
		esp_442->tFFFFFFF4 = esp_442->t0054;
		__mpn_impn_mul_n_basecase(esp_442->tFFFFFFF4, esp_442->tFFFFFFF8, esp_442->tFFFFFFFC, esp_442->t0000);
		esp_442->tFFFFFFF0 = esp_442->t0050;
		esp_442->tFFFFFFEC = esp_442->t0054;
		esp_442->tFFFFFFE8 = ebp_163;
		esp_442->tFFFFFFE4 = ebp_163;
		Eq_2 esp_473 = <invalid>;
		esp_433 = (word32) esp_473 + 32;
		word32 edi_932;
		word32 eax_482 = __mpn_add_n(esp_442->tFFFFFFE4, esp_442->tFFFFFFE8, esp_442->tFFFFFFEC, esp_442->tFFFFFFF0, out ebx_426, out esi_428, out edi_932) + Mem469[esp_473 + 44:word32];
		if (eax_482 == 0x00)
			goto l080949F6;
		ecx_434 = *((word32) esp_473 + 52);
		up32 eax_486 = (word32) *ecx_434 + eax_482;
		*ecx_434 = eax_486;
		if (eax_486 >= 0x00)
		{
l080949F6:
			if (esi_428 <= 0x00)
				goto l08094A15;
			goto l080949FA;
		}
	}
	else
	{
		struct Eq_127682 * esp_382 = esp_346 - 0x0C;
		esp_382->tFFFFFFFC = (word32) esp_382->t005C + esp_382->dw0024;
		esp_382->tFFFFFFF8 = esi_339;
		esp_382->dwFFFFFFF4 = esp_382->dw0054;
		esp_382->dwFFFFFFF0 = esp_382->dw0050;
		esp_382->tFFFFFFEC = esp_382->t005C;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		__mpn_impn_mul_n(stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10);
		esp_382->t0008 = esp_382->t0058;
		esp_382->t0004 = esp_382->t005C;
		esp_382->t0000 = ebp_163;
		esp_382->tFFFFFFFC = ebp_163;
		Eq_2 esp_425 = <invalid>;
		word32 edi_931;
		Eq_2 eax_422 = __mpn_add_n(esp_382->tFFFFFFFC, esp_382->t0000, esp_382->t0004, esp_382->t0008, out ebx_426, out esi_428, out edi_931);
		esp_433 = (word32) esp_425 + 16;
		ecx_434 = *((word32) esp_425 + 36);
		word32 eax_435 = eax_422 + Mem421[esp_425 + 0x1C:word32];
		if (eax_435 == 0x00)
			goto l080949FA;
		up32 eax_438 = (word32) *ecx_434 + eax_435;
		*ecx_434 = eax_438;
		if (eax_438 >= 0x00)
		{
l080949FA:
			word32 edx_522[] = esp_433->ptr0040;
			word32 ecx_523[] = esp_433->ptr0050;
			do
			{
				edx_522[ebx_426] = ecx_523[ebx_426];
				ebx_426 = (word32) ebx_426 + 1;
			} while (esi_428 > ebx_426);
l08094A15:
			struct Eq_127872 * esp_538 = esp_433 - 4;
			esp_538->t0000 = esi_428;
			esp_538->tFFFFFFFC = esp_538->dw0014 + esp_538->dw0054;
			esp_538->tFFFFFFF8 = ebp_163;
			esp_538->tFFFFFFF4 = ebp_163;
			Eq_2 esp_560 = <invalid>;
			struct Eq_127895 * edi_562;
			word32 ebx_933;
			word32 esi_934;
			if (__mpn_add_n(esp_538->tFFFFFFF4, esp_538->tFFFFFFF8, esp_538->tFFFFFFFC, esp_538->t0000, out ebx_933, out esi_934, out edi_562) != 0x00)
			{
				up32 eax_572 = edi_562->dw0000;
				edi_562->dw0000 = eax_572 + 0x01;
				if (eax_572 < 0x01)
				{
					Eq_2 eax_577 = *((word32) esp_560 + 92);
					ui32 eax_579 = 0x00;
					while (eax_579 != eax_577 - 0x01)
					{
						word32 edx_588 = edi_562->a0004[eax_579];
						edi_562->a0004[eax_579] = edx_588 + 0x01;
						++eax_579;
						if (edx_588 != 0x01)
							return;
					}
				}
			}
			return;
		}
	}
	esp_433->t000C = esi_428;
	int32 edx_491 = esi_428 - 0x01;
	int32 eax_494 = 0x00;
	while (edx_491 != eax_494)
	{
		word32 edx_504 = *((word32) ecx_434 + (eax_494 * 0x04 + 4));
		*((word32) ecx_434 + (eax_494 * 0x04 + 4)) = edx_504 + 0x01;
		++eax_494;
		if (edx_504 != 0x01)
			break;
	}
	esi_428 = esp_433->t000C;
	goto l080949F6;
}

// 08094BD0: void __mpn_impn_sqr_n_basecase(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __mpn_impn_sqr_n
//      __mpn_mul_n
void __mpn_impn_sqr_n_basecase(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 eax_32;
	Eq_2 edx_20 = *dwArg08;
	if (edx_20 <= 0x01)
	{
		if (edx_20 != 0x01)
		{
			Eq_2 eax_58 = dwArg04;
			Eq_2 edx_59 = (word32) dwArg04 + dwArg0C * 0x04;
			if (dwArg0C > 0x00)
			{
				do
				{
					*eax_58 = 0x00;
					eax_58 = (word32) eax_58 + 4;
				} while (edx_59 != eax_58);
			}
		}
		else if (dwArg0C > 0x00)
		{
			Eq_2 eax_44 = 0x00;
			while (true)
			{
				*((word32) dwArg04 + eax_44 * 0x04) = edx_20;
				eax_44 = (word32) eax_44 + 1;
				if (dwArg0C == eax_44)
					break;
				edx_20 = *((word32) dwArg08 + eax_44 * 0x04);
			}
		}
		eax_32.u0 = 0x00;
	}
	else
	{
		word32 ecx_240;
		eax_32 = __mpn_mul_1(dwArg04, dwArg08, dwArg0C, edx_20, out ecx_240);
	}
	*((word32) dwArg04 + dwArg0C * 0x04) = eax_32;
	struct Eq_128096 * esp_122 = fp - 44;
	Eq_2 esi_101 = dwArg0C;
	Eq_2 ebx_107 = (word32) dwArg04 + 4;
	word32 * edi_116 = (word32) dwArg08 + 4;
	if (dwArg0C > 0x01)
	{
		do
		{
			uint32 eax_94 = *edi_116;
			if (eax_94 <= 0x01)
			{
				Eq_2 eax_111 = 0x00;
				if (eax_94 == 0x01)
				{
					struct Eq_128158 * esp_100 = esp_122 - 4;
					esp_100->t0000 = esi_101;
					esp_100->tFFFFFFFC = esp_100->t0038;
					esp_100->tFFFFFFF8 = ebx_107;
					esp_100->tFFFFFFF4 = ebx_107;
					Eq_2 esp_114 = <invalid>;
					eax_111 = __mpn_add_n(esp_100->tFFFFFFF4, esp_100->tFFFFFFF8, esp_100->tFFFFFFFC, esp_100->t0000, out ebx_107, out esi_101, out edi_116);
					esp_122 = (word32) esp_114 + 16;
				}
				*((word32) ebx_107 + dwArg0C * 0x04) = eax_111;
				++edi_116;
				ebx_107 = (word32) ebx_107 + 4;
				if (esp_122[3] != edi_116)
					continue;
				return;
			}
			struct Eq_128111 * esp_135 = esp_122 - 4;
			esp_135->dw0000 = eax_94;
			esp_135->tFFFFFFFC = esi_101;
			esp_135->tFFFFFFF8 = esp_135->t0038;
			esp_135->tFFFFFFF4 = ebx_107;
			ebx_107 = (word32) ebx_107 + 4;
			(ebx_107 - 0x04)[dwArg0C] = __mpn_addmul_1(esp_135->tFFFFFFF4, esp_135->tFFFFFFF8, esp_135->tFFFFFFFC, esp_135->dw0000);
			++edi_116;
			esp_122 = (struct Eq_128096 *) (&esp_135->dw0000 + 1);
		} while (esp_135->ptr0010 != edi_116);
	}
}

// 08094CE0: void __mpn_impn_sqr_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __mpn_impn_sqr_n
//      __mpn_mul_n
void __mpn_impn_sqr_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	if ((dwArg0C & 0x01) != 0x00)
	{
		if (dwArg0C > 0x20)
			__mpn_impn_sqr_n(dwArg04, dwArg08, dwArg0C - 0x01);
		else
			__mpn_impn_sqr_n_basecase(dwArg04, dwArg08, dwArg0C - 0x01);
		ui32 esi_599 = (dwArg0C - 0x01) * 0x04;
		uint32 * edi_600 = (word32) dwArg08 + esi_599;
		Eq_2 esi_602 = (word32) dwArg04 + esi_599;
		*((word32) dwArg04 + (dwArg0C - 0x01) * 0x08) = __mpn_addmul_1(esi_602, dwArg08, dwArg0C - 0x01, *edi_600);
		*((word32) dwArg04 + ((word32) dwArg0C + (dwArg0C - 0x01)) * 0x04) = __mpn_addmul_1(esi_602, dwArg08, dwArg0C, *edi_600);
		return;
	}
	ui32 eax_28 = (dwArg0C >> 0x01) * 0x04;
	Eq_2 edx_30 = (word32) dwArg04 + dwArg0C * 0x04;
	Eq_2 eax_32 = (word32) dwArg08 + eax_28;
	if (dwArg0C >> 0x01 > 0x1F)
		__mpn_impn_sqr_n(edx_30, eax_32, dwArg0C >> 0x01);
	else
		__mpn_impn_sqr_n_basecase(edx_30, eax_32, dwArg0C >> 0x01);
	Eq_2 edi_114;
	Eq_2 esi_115;
	if (__mpn_cmp(eax_32, dwArg08, dwArg0C >> 0x01) >= 0x00)
		__mpn_sub_n(dwArg04, eax_32, dwArg08, dwArg0C >> 0x01, out esi_115, out edi_114);
	else
		__mpn_sub_n(dwArg04, dwArg08, eax_32, dwArg0C >> 0x01, out esi_115, out edi_114);
	Eq_2 (* edi_363)[];
	Eq_2 esi_364;
	struct Eq_128496 * esp_369;
	Eq_2 edx_370;
	Eq_2 ebx_362;
	Eq_2 edi_236;
	Eq_2 esi_237;
	struct Eq_128340 * esp_245;
	word32 edx_247;
	if (esi_115 <= 0x1F)
	{
		__mpn_impn_sqr_n_basecase(edi_114, dwArg04, esi_115);
		if (esi_115 <= 0x00)
		{
			Eq_2 edi_213;
			word32 ebx_832;
			word32 esi_833;
			word32 eax_208 = __mpn_add_n(edx_30, edx_30, dwArg04 + (dwArg0C + esi_115) * 0x04, esi_115, out ebx_832, out esi_833, out edi_213);
			Eq_2 esp_211 = <invalid>;
			word32 ecx_219 = *((word32) esp_211 + 28);
			*((word32) esp_211 + 32) = eax_208;
			Eq_2 edx_221 = (word32) dwArg04 + ecx_219;
			*((word32) esp_211 + 24) = edx_221;
			*((word32) esp_211 - 4) = *((word32) esp_211 + 88);
			*((word32) esp_211 - 8) = edi_213;
			*((word32) esp_211 - 0x0C) = edx_221;
			*((word32) esp_211 - 16) = edx_221;
			*((word32) esp_211 + 36) = *((word32) esp_211 + 32) - __mpn_sub_n(*((word32) esp_211 - 16), *((word32) esp_211 - 0x0C), *((word32) esp_211 - 8), *((word32) esp_211 - 4), out esi_237, out edi_236);
			esp_245 = (word32) esp_211 + 16;
			edx_247 = (word32) *((word32) esp_211 + 40);
			goto l08094FB8;
		}
	}
	else
		__mpn_impn_sqr_n(edi_114, dwArg04, esi_115);
	word32 ecx_254[] = (word32) dwArg04 + eax_28;
	Eq_2 eax_255 = 0x00;
	do
	{
		ecx_254[eax_255] = (word32) *((word32) edx_30 + eax_255 * 0x04);
		eax_255 = (word32) eax_255 + 1;
	} while (esi_115 > eax_255);
	Eq_2 edi_293;
	word32 esi_835;
	word32 ebx_834;
	word32 eax_288 = __mpn_add_n(edx_30, edx_30, dwArg04 + (dwArg0C + esi_115) * 0x04, esi_115, out ebx_834, out esi_835, out edi_293);
	Eq_2 esp_291 = <invalid>;
	Eq_2 ecx_299 = *((word32) esp_291 + 24);
	*((word32) esp_291 + 36) = eax_288;
	*((word32) esp_291 - 4) = *((word32) esp_291 + 88);
	*((word32) esp_291 - 8) = edi_293;
	*((word32) esp_291 - 0x0C) = ecx_299;
	*((word32) esp_291 - 16) = ecx_299;
	*((word32) esp_291 + 36) -= __mpn_sub_n(*((word32) esp_291 - 16), *((word32) esp_291 - 0x0C), *((word32) esp_291 - 8), *((word32) esp_291 - 4), out esi_237, out edi_236);
	esp_245 = (word32) esp_291 + 16;
	edx_247 = (word32) *((word32) esp_291 + 40);
	if (esi_237 > 0x1F)
	{
		word32 eax_382 = *((word32) esp_291 + 32);
		*((word32) esp_291 + 40) = edx_247;
		*((word32) esp_291 + 0x0C) = (word32) edi_236 + eax_382;
		*((word32) esp_291 + 8) = esi_237;
		*((word32) esp_291 + 4) = *((word32) esp_291 + 84);
		*esp_291 = edi_236;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		__mpn_impn_sqr_n(stackArg4, dwArg04, dwArg08);
		*((word32) esp_291 - 4) = *((word32) esp_291 + 88);
		*((word32) esp_291 - 8) = edi_236;
		Eq_2 eax_406 = *((word32) esp_291 + 24);
		*((word32) esp_291 - 0x0C) = eax_406;
		*((word32) esp_291 - 16) = eax_406;
		Eq_2 esp_414 = <invalid>;
		Eq_2 eax_411 = __mpn_add_n(*((word32) esp_291 - 16), *((word32) esp_291 - 0x0C), *((word32) esp_291 - 8), *((word32) esp_291 - 4), out ebx_362, out esi_364, out edi_363);
		esp_369 = (word32) esp_414 + 32;
		edx_370 = *((word32) esp_414 + 56);
		word32 eax_424 = eax_411 + Mem410[esp_414 + 0x34:word32];
		if (eax_424 == 0x00)
			goto l08094EC0;
		Eq_2 ecx_427 = *((word32) esp_414 + 60);
		up32 eax_428 = (word32) *ecx_427 + eax_424;
		*ecx_427 = eax_428;
		if (eax_428 >= 0x00)
		{
l08094EC0:
			do
			{
				*((word32) dwArg04 + ebx_362 * 0x04) = edi_363[ebx_362];
				ebx_362 = (word32) ebx_362 + 1;
			} while (esi_364 > ebx_362);
			goto l08094ECE;
		}
l0809505A:
		esp_369->t0010 = esi_364;
		esp_369->t0014 = ebx_362;
		int32 ecx_433 = esi_364 - 0x01;
		int32 eax_436 = 0x00;
		struct Eq_128619 * ebx_442 = esp_369->ptr001C;
		while (ecx_433 != eax_436)
		{
			word32 ecx_449 = ebx_442->a0004[eax_436];
			ebx_442->a0004[eax_436] = ecx_449 + 0x01;
			++eax_436;
			if (ecx_449 != 0x01)
				break;
		}
		esi_364 = esp_369->t0010;
		ebx_362 = esp_369->t0014;
		if (esi_364 <= 0x00)
		{
l08094ECE:
			esp_369->t0010 = edx_370;
			struct Eq_128631 * esp_506 = esp_369 - 4;
			esp_506->t0000 = esi_364;
			esp_506->tFFFFFFFC = edi_363 + esp_506->dw0010 / 4;
			Eq_2 eax_514 = esp_506->t000C;
			esp_506->tFFFFFFF8 = eax_514;
			esp_506->tFFFFFFF4 = eax_514;
			word32 ebx_837;
			word32 edi_839;
			word32 esi_838;
			Eq_2 eax_519 = __mpn_add_n(esp_506->tFFFFFFF4, esp_506->tFFFFFFF8, esp_506->tFFFFFFFC, esp_506->t0000, out ebx_837, out esi_838, out edi_839);
			Eq_2 esp_522 = <invalid>;
			struct Eq_128676 * edx_531 = *((word32) esp_522 + 32);
			if (eax_519 != 0x00)
			{
				up32 eax_535 = edx_531->dw0000;
				edx_531->dw0000 = eax_535 + 0x01;
				if (eax_535 < 0x01)
				{
					Eq_2 eax_540 = *((word32) esp_522 + 88);
					ui32 eax_542 = 0x00;
					while (eax_542 != eax_540 - 0x01)
					{
						word32 edi_551 = edx_531->a0004[eax_542];
						edx_531->a0004[eax_542] = edi_551 + 0x01;
						++eax_542;
						if (edi_551 != 0x01)
							return;
					}
				}
			}
			return;
		}
l08094FEF:
		*((word32) dwArg04 + ebx_362 * 0x04) = edi_363[ebx_362];
		ebx_362 = (word32) ebx_362 + 1;
		if (esi_364 > ebx_362)
			goto l08094EC0;
		goto l08094ECE;
	}
l08094FB8:
	esp_245->dw0010 = edx_247;
	struct Eq_128428 * esp_330 = esp_245 - 0x04;
	esp_330->tFFFFFFFC = esi_237;
	esp_330->tFFFFFFF8 = esp_330->t0048;
	esp_330->tFFFFFFF4 = edi_236;
	__mpn_impn_sqr_n_basecase(esp_330->tFFFFFFF4, esp_330->tFFFFFFF8, esp_330->tFFFFFFFC);
	esp_330->tFFFFFFF0 = esp_330->t004C;
	esp_330->tFFFFFFEC = edi_236;
	Eq_2 eax_353 = esp_330->t000C;
	esp_330->tFFFFFFE8 = eax_353;
	esp_330->tFFFFFFE4 = eax_353;
	Eq_2 esp_361 = <invalid>;
	Eq_2 eax_358 = __mpn_add_n(esp_330->tFFFFFFE4, esp_330->tFFFFFFE8, esp_330->tFFFFFFEC, esp_330->tFFFFFFF0, out ebx_362, out esi_364, out edi_363);
	esp_369 = (word32) esp_361 + 32;
	edx_370 = *((word32) esp_361 + 48);
	word32 eax_371 = eax_358 + Mem357[esp_361 + 0x34:word32];
	if (eax_371 != 0x00)
	{
		Eq_2 ecx_374 = *((word32) esp_361 + 60);
		up32 eax_375 = (word32) *ecx_374 + eax_371;
		*ecx_374 = eax_375;
		if (eax_375 < 0x00)
			goto l0809505A;
	}
	if (esi_364 <= 0x00)
		goto l08094ECE;
	goto l08094FEF;
}

// 080950A0: void __mpn_mul_n(Register (ptr32 Eq_128800) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __mpn_mul_n(struct Eq_128800 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	struct Eq_128805 * esp_138 = fp - 0x3C;
	word32 edi_21 = gs->dw0014;
	if (dwArg08 != dwArg0C)
	{
		if (dwArg10 > 0x1F)
		{
			ui32 ebx_128 = dwArg10 * 0x08 + 0x1B;
			struct Eq_128805 * edi_134 = fp - 0x3C - (ebx_128 & ~0x0FFF);
			if (fp - 0x3C != edi_134)
			{
				do
				{
					esp_138 -= 0x1000;
					esp_138->dw0FFC = esp_138->dw0FFC;
				} while (esp_138 != edi_134);
			}
			if ((ebx_128 & ~0x0F & 0x0FFF) != 0x00)
			{
				esp_138 -= ebx_128 & ~0x0F & 0x0FFF;
				Mem158[esp_138 - 0x04 + ((ebx_128 & ~0x0F) & 0x0FFF):word32] = Mem149[esp_138 - 0x04 + ((ebx_128 & ~0x0F) & 0x0FFF):word32];
			}
			struct Eq_128846 * esp_163 = esp_138 - 0x0C;
			Mem168[esp_163 + -4:word32] = esp_138 + 0x0F & ~0x0F;
			esp_163->tFFFFFFF8 = dwArg10;
			esp_163->tFFFFFFF4 = dwArg0C;
			esp_163->tFFFFFFF0 = dwArg08;
			esp_163->tFFFFFFEC = dwArg04;
			__mpn_impn_mul_n(esp_163->tFFFFFFEC, esp_163->tFFFFFFF0, esp_163->tFFFFFFF4, esp_163->tFFFFFFF8, esp_163->tFFFFFFFC);
		}
		else
			__mpn_impn_mul_n_basecase(dwArg04, dwArg08, dwArg0C, dwArg10);
	}
	else if (dwArg10 > 0x1F)
	{
		ui32 ecx_47 = dwArg10 * 0x08 + 0x1B;
		struct Eq_128805 * edi_51 = fp - 0x3C - (ecx_47 & ~0x0FFF);
		if (fp - 0x3C != edi_51)
		{
			do
			{
				esp_138 -= (struct Eq_128921 *) 0x1000;
				esp_138->dw0FFC = esp_138->dw0FFC;
			} while (esp_138 != edi_51);
		}
		struct Eq_128914 * ebx_67 = ecx_47 & ~0x0F & 0x0FFF;
		if (ebx_67 != null)
		{
			esp_138 -= ebx_67;
			Mem75[esp_138 - 0x04 + ebx_67:word32] = Mem73[esp_138 - 0x04 + ebx_67:word32];
		}
		struct Eq_128930 * esp_83 = esp_138 - (struct Eq_128931 *) 4;
		Mem84[esp_83 + 0x00:word32] = esp_138 + 0x0F & ~0x0F;
		esp_83->tFFFFFFFC = dwArg10;
		esp_83->tFFFFFFF8 = dwArg08;
		esp_83->tFFFFFFF4 = dwArg04;
		__mpn_impn_sqr_n(esp_83->tFFFFFFF4, esp_83->tFFFFFFF8, esp_83->tFFFFFFFC);
	}
	else
		__mpn_impn_sqr_n_basecase(dwArg04, dwArg08, dwArg10);
	if ((edi_21 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_347;
	word32 edx_348;
	__stack_chk_fail(out ecx_347, out edx_348);
	word32 esi_349;
	word32 edi_350;
	__mpn_sub_n(dwArg04, dwArg08, dwArg0C, dwArg10, out esi_349, out edi_350);
}

// 080951D0: Register uint32 __mpn_sub_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 esiOut, Register out (ptr32 (arr Eq_126381)) ediOut)
// Called from:
//      __mpn_divrem
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n
//      __mpn_mul_n
uint32 __mpn_sub_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & esiOut, Eq_126381 (& ediOut)
{
	Eq_2 edi_10 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	Eq_2 edx_12 = dwArg0C;
	uint32 ecx_18 = dwArg10 >> 0x03;
	uint32 eax_19 = -dwArg10;
	if ((eax_19 & 0x07) == 0x00)
	{
		do
		{
			up32 eax_29 = *esi_11 - *edx_12;
			*edi_10 = eax_29;
			up32 eax_35 = *((word32) esi_11 + 4) - *((word32) edx_12 + 4) - (word32) (eax_29 < 0x00);
			*((word32) edi_10 + 4) = eax_35;
			up32 eax_40 = *((word32) esi_11 + 8) - *((word32) edx_12 + 8) - (word32) (eax_35 < 0x00);
			*((word32) edi_10 + 8) = eax_40;
			up32 eax_45 = *((word32) esi_11 + 0x0C) - *((word32) edx_12 + 0x0C) - (word32) (eax_40 < 0x00);
			*((word32) edi_10 + 0x0C) = eax_45;
			up32 eax_50 = *((word32) esi_11 + 16) - *((word32) edx_12 + 16) - (word32) (eax_45 < 0x00);
			*((word32) edi_10 + 16) = eax_50;
			up32 eax_55 = *((word32) esi_11 + 20) - *((word32) edx_12 + 20) - (word32) (eax_50 < 0x00);
			*((word32) edi_10 + 20) = eax_55;
			up32 eax_60 = *((word32) esi_11 + 24) - *((word32) edx_12 + 24) - (word32) (eax_55 < 0x00);
			*((word32) edi_10 + 24) = eax_60;
			up32 eax_65 = *((word32) esi_11 + 28) - *((word32) edx_12 + 28) - (word32) (eax_60 < 0x00);
			*((word32) edi_10 + 28) = eax_65;
			edi_10 = (word32) edi_10 + 32;
			esi_11 = (word32) esi_11 + 32;
			edx_12 = (word32) edx_12 + 32;
			--ecx_18;
		} while (ecx_18 != 0x00);
		esiOut = esi;
		ediOut = edi;
		return (word32) (eax_65 < 0x00);
	}
	else
	{
		uint32 eax_88 = (eax_19 & 0x07) << 0x02;
		ui32 ebx_94 = (eax_88 >> 0x02) * 0x04 + ~0x03;
		Eq_126381 (* edi_89)[] = dwArg04 - eax_88;
		ptr32 esi_90 = dwArg08 - eax_88;
		uint32 eax_95 = fn0809520C(eax_88 >> 0x02, ebx_94, dwLoc10);
		Eq_2 esp_96 = <invalid>;
		uint32 eax_101 = fn0809520C(eax_95, ebx_94, *esp_96);
		esiOut = esi_90;
		ediOut = edi_89;
		return eax_101;
	}
}

// 0809520C: Register uint32 fn0809520C(Register uint32 eax, Register ui32 ebx, Stack word32 dwArg00)
// Called from:
//      __mpn_sub_n
uint32 fn0809520C(uint32 eax, ui32 ebx, word32 dwArg00)
{
	<anonymous> * eax_11 = eax * 0x09 + dwArg00 + 0x11 + ebx;
	uint32 eax_13;
	eax_11();
	return eax_13;
}

// 080952A0: Register word32 __mpn_submul_1(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __mpn_divrem
word32 __mpn_submul_1(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	up32 edi_20[] = (word32) dwArg04 + dwArg0C * 0x04;
	uint32 esi_21[] = (word32) dwArg08 + dwArg0C * 0x04;
	ui32 ecx_22 = -dwArg0C;
	word32 ebp_23 = 0x00;
	do
	{
		uint64 edx_eax_32 = dwArg10 *64 esi_21[ecx_22];
		up32 eax_35 = (word32) edx_eax_32 + ebp_23;
		up32 v14_41 = edi_20[ecx_22] - eax_35;
		edi_20[ecx_22] = v14_41;
		word32 edx_45 = SLICE(edx_eax_32, word32, 32) + (word32) (eax_35 < 0x00) + (word32) (v14_41 < 0x00);
		ebp_23 = edx_45;
		++ecx_22;
	} while (ecx_22 != 0x00);
	return edx_45;
}

// 080952F0: Register word32 __mpn_extract_double(Stack (ptr32 Eq_81118) dwArg04, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 uint32) dwArg10, Stack Eq_936 dwArg14, Stack uint32 dwArg18)
// Called from:
//      __printf_fp_l
word32 __mpn_extract_double(struct Eq_81118 * dwArg04, ui32 * dwArg0C, uint32 * dwArg10, Eq_936 dwArg14, uint32 dwArg18)
{
	*dwArg10 = dwArg18 >> 0x1F;
	*dwArg0C = (dwArg18 >> 0x14 & 0x07FF) - 0x03FF;
	dwArg04->dw0004 = dwArg18 & 0x000FFFFF;
	dwArg04->t0000 = dwArg14;
	if ((dwArg18 >> 0x10 & 0x7FF0) != 0x00)
	{
		dwArg04->dw0004 = dwArg18 & 0x000FFFFF | 0x00100000;
		return;
	}
	else
	{
		if (dwArg14 == 0x00)
		{
			if ((dwArg18 & 0x000FFFFF) == 0x00)
			{
				*dwArg0C = 0x00;
				return;
			}
		}
		else if ((dwArg18 & 0x000FFFFF) == 0x00)
		{
			word32 edx_57 = __bsr(dwArg14);
			if ((edx_57 ^ 0x1F) > 0x0A)
			{
				dwArg04->t0000.u0 = 0x00;
				dwArg04->dw0004 = dwArg14 << ((byte) edx_57 ^ 0x1F) - 11;
			}
			else
			{
				dwArg04->dw0004 = dwArg14 >> 11 - ((byte) edx_57 ^ 0x1F);
				dwArg04->t0000 = dwArg14 << ((byte) edx_57 ^ 0x1F) + 0x15;
			}
			*dwArg0C = ~0x0412 - (edx_57 ^ 0x1F);
			return;
		}
		ui32 edx_103 = (__bsr(dwArg18 & 0x000FFFFF) ^ 0x1F) - 11;
		byte cl_108 = (byte) edx_103;
		dwArg04->t0000 = dwArg14 << cl_108;
		dwArg04->dw0004 = dwArg14 >> 0x20 - (byte) edx_103 | (dwArg18 & 0x000FFFFF) << cl_108;
		*dwArg0C = ~0x03FD - edx_103;
		return;
	}
}

// 08095400: Register word32 __mpn_extract_long_double(Stack (ptr32 Eq_80794) dwArg04, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 word32) dwArg10, Stack real80 rArg14)
// Called from:
//      __printf_fp_l
word32 __mpn_extract_long_double(struct Eq_80794 * dwArg04, ui32 * dwArg0C, word32 * dwArg10, real80 rArg14)
{
	__align(fp - 16);
	real64 rLoc1_161 = (real64) rArg14;
	real80 rLoc20_164 = (real80) rLoc1_161;
	*dwArg10 = (word32) (SLICE(rLoc20_164, byte, 72) >> 0x07);
	*dwArg0C = ((word32) SLICE(rLoc20_164, word16, 64) & 0x7FFF) - 0x3FFF;
	Eq_936 dwLoc30_169 = (word32) (real80) rLoc1_161;
	dwArg04->t0000 = dwLoc30_169;
	ui32 dwLoc3C_172 = SLICE((real80) rLoc1_161, word32, 32);
	dwArg04->dw0004 = dwLoc3C_172;
	cui16 cx_54 = SLICE((real80) rLoc1_161, word16, 64);
	if ((cx_54 & 0x7FFF) != 0x00)
	{
		if ((dwLoc30_169 | dwLoc3C_172) != 0x00)
			return;
		if ((cx_54 & 0x7FFF) == 0x7FFF)
			return;
l08095471:
		*dwArg0C = 0x00;
		return;
	}
	else
	{
		if (dwLoc30_169 == 0x00)
		{
			if (dwLoc3C_172 == 0x00)
				goto l08095471;
			if ((dwLoc3C_172 & 0x7FFFFFFF) == 0x00)
			{
				dwArg04->dw0004 = 0x80000000;
				*dwArg0C = ~0x3FFD;
				return;
			}
		}
		else if ((dwLoc3C_172 & 0x7FFFFFFF) == 0x00)
		{
			word32 ecx_82 = __bsr(dwLoc30_169);
			dwArg04->t0000.u0 = 0x00;
			dwArg04->dw0004 = dwLoc30_169 << ((byte) ecx_82 ^ 0x1F);
			*dwArg0C = ~0x401D - (ecx_82 ^ 0x1F);
			return;
		}
		word32 edi_100 = __bsr(dwLoc3C_172 & 0x7FFFFFFF);
		dwArg04->dw0004 = (dwLoc3C_172 & 0x7FFFFFFF) << ((byte) edi_100 ^ 0x1F) | dwLoc30_169 >> 0x20 - ((byte) edi_100 ^ 0x1F);
		dwArg04->t0000 = dwLoc30_169 << ((byte) edi_100 ^ 0x1F);
		*dwArg0C = ~0x3FFD - (edi_100 ^ 0x1F);
		return;
	}
}

// 08095530: Register word32 __mpn_extract_float128(Stack (ptr32 Eq_78332) dwArg04, Stack (ptr32 Eq_2) dwArg0C, Stack (ptr32 word32) dwArg10, Stack Eq_2 owArg14)
// Called from:
//      __printf_fp_l
word32 __mpn_extract_float128(struct Eq_78332 * dwArg04, union Eq_2 * dwArg0C, word32 * dwArg10, Eq_2 owArg14)
{
	word32 dwArg20_243 = SLICE(owArg14, word32, 96);
	Eq_129464 dwArg14_247 = (word32) owArg14;
	ui32 dwArg1C_248 = SLICE(owArg14, word32, 64);
	ui32 dwArg18_250 = SLICE(owArg14, word32, 32);
	*dwArg10 = (word32) (SLICE(owArg14, byte, 120) >> 0x07);
	Eq_2 edx_35 = ((word32) SLICE(owArg14, word16, 112) & 0x7FFF) - 0x3FFF;
	*dwArg0C = (union Eq_2 *) edx_35;
	cui16 dx_43 = (word16) __pextrw(edx_35, owArg14, 0x07);
	dwArg04->a0000[0] = dwArg14_247;
	dwArg04->dw0004 = dwArg18_250;
	dwArg04->dw0008 = dwArg1C_248;
	word16 bp_32 = (word16) dwArg20_243;
	Eq_936 ecx_33 = (word32) bp_32;
	dwArg04->t000C = ecx_33;
	if ((dx_43 & 0x7FFF) != 0x00)
	{
		dwArg04->t000C = ecx_33 | 0x00010000;
		return;
	}
	int32 esi_111;
	uint32 edi_110;
	int32 edx_77;
	if ((dwArg18_250 | dwArg14_247 | dwArg1C_248) != 0x00)
	{
		if (bp_32 == 0x00)
		{
			if (dwArg1C_248 == 0x00)
			{
				uint32 ecx_91 = (uint32) (int8) (dwArg18_250 != 0x00);
				edi_110 = ecx_91;
				edx_77 = ecx_91 * 0x04;
				esi_111 = 0x03 - ecx_91;
			}
			else
			{
				esi_111 = 0x01;
				edx_77 = 0x08;
				edi_110 = 0x02;
			}
l080955DA:
			int32 edx_154;
			Eq_936 ecx_101 = dwArg04[edx_77 / 16];
			word32 edx_102 = __bsr(ecx_101);
			int32 ebp_105 = (edx_102 ^ 0x1F) - 0x0F;
			if (ebp_105 >= 0x00)
			{
				if (ebp_105 == 0x00)
				{
					dwArg04->t000C = ecx_101;
					int32 ebx_167 = esi_111 * 0x04;
					int32 * edx_168 = &dwArg04->t000C;
					int32 * edi_170 = dwArg04 + ebx_167 / 16;
					int32 ebx_171 = -ebx_167;
					if (edi_170 != &dwArg04->t000C)
					{
						do
						{
							edx_168 -= 0x04;
							*edx_168 = (int32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(edx_168 - 0x04)[ebx_171 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						} while (edi_170 != edx_168);
					}
					edx_154 = esi_111 - 0x01;
					goto l08095619;
				}
				if (esi_111 == 0x03)
				{
					dwArg04->t000C = dwArg14_247 << ((byte) edx_102 ^ 0x1F) - 0x0F;
					edx_154 = 0x02;
					goto l08095620;
				}
			}
			else
			{
				ebp_105 = (edx_102 ^ 0x1F) + 0x11;
				esi_111 = 0x02 - edi_110;
			}
			byte bLoc30_304 = 0x20 - (byte) ebp_105;
			ui32 edi_129[] = dwArg04 - esi_111 * 0x04;
			int32 edx_131 = 0x03;
			do
			{
				dwArg04[edx_131 * 0x04 / 16] = (struct Eq_78332) (edi_129[edx_131] << (byte) ebp_105 | (edi_129 - 0x04)[edx_131] >> bLoc30_304);
				--edx_131;
			} while (esi_111 < edx_131);
			dwArg04[esi_111 * 0x04 / 16] = (struct Eq_78332) (dwArg04->a0000[0] << (byte) ebp_105);
			edx_154 = esi_111 - 0x01;
l08095619:
			if (edx_154 < 0x00)
			{
l0809562F:
				*dwArg0C = (union Eq_2 *) (~0x3FFD - (esi_111 << 0x05) - ebp_105);
				return;
			}
l08095620:
			do
			{
				dwArg04[edx_154 * 0x04 / 16] = (struct Eq_78332) 0x00;
				--edx_154;
			} while (edx_154 != ~0x00);
			goto l0809562F;
		}
	}
	else if (bp_32 == 0x00)
	{
		*dwArg0C = (union Eq_2 *) 0x00;
		return;
	}
	esi_111 = 0x00;
	edx_77 = 0x0C;
	edi_110 = 0x03;
	goto l080955DA;
}

// 08095740: Register Eq_2 _itoa_word(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 ecxOut, Register out (ptr32 Eq_74711) edxOut)
// Called from:
//      printf_positional
//      __printf_fphex
//      strerror_r
//      _fitoa_word
Eq_2 _itoa_word(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & ecxOut, struct Eq_74711 & edxOut)
{
	Eq_2 ecx_109 = dwArg04;
	Eq_2 ebx_122 = dwArg08;
	byte esi_147[] = g_a80B8660;
	if (dwArg10 == 0x00)
		esi_147 = (byte (*)[]) &g_t80B8620;
	if (dwArg0C == 0x0A)
	{
		while (true)
		{
			uint32 edx_39 = SLICE(ecx_109 *64 ~0x33333332, word32, 32);
			--ebx_122;
			Mem48[ebx_122 + 0x00:byte] = Mem45[esi_147 + (ecx_109 - ((edx_39 >>u 0x03) + (edx_39 >>u 0x03) * 0x04) * 0x02):byte];
			if (ecx_109 <= 0x09)
				break;
			ecx_109 = edx_39 >> 0x03;
		}
		ecxOut = ecx_109;
		edxOut = edx_39 >> 0x03;
		return ebx_122;
	}
	else if (dwArg0C == 0x10)
	{
		while (true)
		{
			--ebx_122;
			*ebx_122 = esi_147[ecx_109 & 0x0F];
			Eq_2 eax_76 = ecx_109 >> 0x04;
			if (ecx_109 <= 0x0F)
				break;
			ecx_109 = eax_76;
		}
		ecxOut = ecx_109;
		edxOut = (struct Eq_74711 *) &g_t80B8620;
		return ebx_122;
	}
	else if (dwArg0C != 0x08)
	{
		while (true)
		{
			uint64 edx_eax_97 = (uint64) ecx_109;
			struct Eq_74711 * edx_104 = (word32) esi_147[(uint32) (edx_eax_97 % dwArg0C)];
			--ebx_122;
			*ebx_122 = (byte) edx_104;
			Eq_2 eax_101 = (uint32) (edx_eax_97 /u dwArg0C);
			if (ecx_109 < dwArg0C)
				break;
			ecx_109 = eax_101;
		}
		ecxOut = ecx_109;
		edxOut = edx_104;
		return ebx_122;
	}
	else
	{
		while (true)
		{
			--ebx_122;
			*ebx_122 = esi_147[ecx_109 & 0x07];
			Eq_2 eax_131 = ecx_109 >> 0x03;
			if (ecx_109 <= 0x07)
				break;
			ecx_109 = eax_131;
		}
		ecxOut = ecx_109;
		edxOut = (struct Eq_74711 *) &g_t80B8620;
		return ebx_122;
	}
}

// 08095840: Register Eq_2 _itoa(Register (ptr32 Eq_9) gs, Stack Eq_84901 qwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out Eq_2 ebxOut, Register out (ptr32 Eq_84906) ebpOut, Register out Eq_84907 ediOut)
// Called from:
//      __printf_fphex
//      _dl_debug_vdprintf
//      _fitoa
//      _dl_check_map_versions
Eq_2 _itoa(struct Eq_9 * gs, Eq_84901 qwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, union Eq_2 & ebxOut, struct Eq_84906 & ebpOut, union Eq_84907 & ediOut)
{
	Eq_2 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_2 dwArg04 = (word32) qwArg04;
	struct Eq_84906 * ebp_19 = g_a80B8660;
	Eq_2 esi_211 = dwArg10;
	Eq_2175 eax_26 = gs->t0014;
	Eq_2 ebx_102 = dwArg04;
	if (dwArg14 == 0x00)
		ebp_19 = (struct Eq_84906 *) &g_t80B8620;
	Eq_2 ecx_117;
	if (dwArg10 != 0x08)
	{
		if (dwArg10 != 0x10)
		{
			word32 dwLoc3C_350;
			if (dwArg08 != 0x00)
			{
				Eq_2 edi_139 = (0x080B8460 + ((dwArg10 - 0x02) + (dwArg10 - 0x02) * 0x02) * 0x04)->t0008;
				if (edi_139 <= dwArg08)
				{
					ebx_102 = (uint32) (SEQ((uint32) ((uint64) dwArg08 % edi_139), dwArg04) % edi_139);
					dwLoc3C_350 = 0x03;
				}
				else
				{
					dwLoc3C_350 = 0x02;
					ebx_102 = (uint32) (qwArg04 % edi_139);
				}
			}
			else
				dwLoc3C_350 = 0x01;
			int32 edx_192;
			Eq_2 edi_180 = dwArg0C;
			ui32 dwLoc3C_363 = dwLoc3C_350 - 0x01;
			struct Eq_129873 * eax_185 = 0x080B8460 + (dwArg10 - 0x02) * 0x0C;
			ecx_117 = dwArg0C;
			while (ebx_102 == 0x00)
			{
				edx_192 = 0x00;
l0809593A:
				if (dwLoc3C_363 == 0x00)
				{
					if (dwArg0C == ecx_117)
					{
						*((word32) ecx_117 - 1) = 0x30;
						--ecx_117;
					}
					goto l08095958;
				}
				int32 eax_202 = (int32) eax_185->b0005;
				if (eax_202 > edx_192)
				{
					edi_180 = (word32) ecx_117 + (edx_192 - eax_202);
					do
					{
						--ecx_117;
						*ecx_117 = 0x30;
					} while (edi_180 != ecx_117);
				}
				else
					edi_180 = ecx_117;
				ecx_117 = edi_180;
				--dwLoc3C_363;
				ebx_102 = (fp - 0x30)[dwLoc3C_363];
			}
			while (true)
			{
				uint64 edx_eax_236 = (uint64) ebx_102;
				--ecx_117;
				*ecx_117 = ebp_19[(uint32) (edx_eax_236 % esi_211) / 360];
				Eq_2 eax_240 = (uint32) (edx_eax_236 /u esi_211);
				edx_192 = edi_180 - ecx_117;
				if (ebx_102 < esi_211)
					break;
				ebx_102 = eax_240;
			}
			goto l0809593A;
		}
		Eq_2 eax_100 = dwArg0C;
		ecx_117 = dwArg0C;
		if (dwArg08 != 0x00)
		{
			ecx_117 = dwArg0C - 0x08;
			do
			{
				--eax_100;
				*eax_100 = ebp_19[(ebx_102 & 0x0F) / 360];
				ebx_102 >>= 0x04;
			} while (dwArg0C - 0x08 != eax_100);
			ebx_102 = dwArg08;
		}
		do
		{
			--ecx_117;
			*ecx_117 = ebp_19[(ebx_102 & 0x0F) / 360];
			ebx_102 >>= 0x04;
		} while (ebx_102 != 0x00);
	}
	else
	{
		ecx_117 = dwArg0C;
		if (dwArg08 != 0x00)
		{
			ecx_117 = dwArg0C - 0x0A;
			Eq_2 esi_47 = dwArg0C;
			do
			{
				--esi_47;
				*esi_47 = ebp_19[(ebx_102 & 0x07) / 360];
				ebx_102 >>= 0x03;
			} while (dwArg0C - 0x0A != esi_47);
			ebx_102 |= dwArg08 * 0x04 & 0x04;
			if (dwArg08 >> 0x01 != 0x00)
			{
				Mem74[dwArg0C + -11:byte] = Mem58[ebp_19 + ebx_102:byte];
				ebx_102 = dwArg08 >> 0x01;
				ecx_117 = dwArg0C - 11;
			}
		}
		do
		{
			--ecx_117;
			*ecx_117 = ebp_19[(ebx_102 & 0x07) / 360];
			ebx_102 >>= 0x03;
		} while (ebx_102 != 0x00);
	}
l08095958:
	Eq_84907 edi_276 = eax_26 ^ gs->t0014;
	if (edi_276 != 0x00)
	{
		word32 edx_531;
		word32 ecx_530;
		__stack_chk_fail(out ecx_530, out edx_531);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg16 = <invalid>;
		Eq_2 eax_314 = _fitoa_word(gs, stackArg4, stackArg8, stackArg12, stackArg16);
		ebxOut = ebx_102;
		ebpOut = ebp_19;
		ediOut = edi_276;
		return eax_314;
	}
	else
	{
		ebxOut = ebx;
		ebpOut = ebp;
		ediOut = edi;
		return ecx_117;
	}
}

// 08095AB0: Register Eq_2 _fitoa_word(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      _itoa
Eq_2 _fitoa_word(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 eax_135;
	Eq_2175 eax_18 = gs->t0014;
	word32 edx_156;
	word32 ecx_155;
	Eq_2 eax_36 = _itoa_word(dwArg04, fp - 0x20, dwArg0C, dwArg10, out ecx_155, out edx_156);
	if (eax_36 < fp - 0x20)
	{
		Eq_2 edi_48 = dwArg08;
		Eq_2 esi_49 = eax_36;
		do
		{
			*edi_48 = *esi_49;
			esi_49 = (word32) esi_49 + 1;
			edi_48 = (word32) edi_48 + 1;
		} while (esi_49 != fp - 0x20);
		eax_135 = (word32) dwArg08 + (esi_49 - eax_36);
	}
	else
		eax_135 = dwArg08;
	if ((eax_18 ^ gs->t0014) == 0x00)
		return eax_135;
	word32 ecx_157;
	word32 edx_158;
	__stack_chk_fail(out ecx_157, out edx_158);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg12 = <invalid>;
	return _fitoa(gs, stackArg12);
}

// 08095B20: Register Eq_2 _fitoa(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg0C)
// Called from:
//      _fitoa_word
Eq_2 _fitoa(struct Eq_9 * gs, Eq_2 dwArg0C)
{
	Eq_2 eax_134;
	Eq_2175 eax_18 = gs->t0014;
	word32 ebx_151;
	word32 ebp_152;
	word32 edi_153;
	Eq_2 eax_39 = _itoa(gs, dwArg04, fp - 0x20, dwArg10, dwArg14, out ebx_151, out ebp_152, out edi_153);
	if (eax_39 < fp - 0x20)
	{
		Eq_2 esi_46 = eax_39;
		Eq_2 edi_47 = dwArg0C;
		do
		{
			*edi_47 = *esi_46;
			esi_46 = (word32) esi_46 + 1;
			edi_47 = (word32) edi_47 + 1;
		} while (esi_46 != fp - 0x20);
		eax_134 = (word32) dwArg0C + (esi_46 - eax_39);
	}
	else
		eax_134 = dwArg0C;
	if ((eax_18 ^ gs->t0014) == 0x00)
		return eax_134;
	word32 ecx_154;
	word32 edx_155;
	__stack_chk_fail(out ecx_154, out edx_155);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_84901 stackArg4 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	Eq_2 stackArg20 = <invalid>;
	word32 ebp_160;
	word32 esi_161;
	word32 edi_162;
	return _itowa(gs, stackArg4, stackArg12, stackArg16, stackArg20, out ebp_160, out esi_161, out edi_162);
}

// 08095B90: Register Eq_2 _itowa(Register (ptr32 Eq_9) gs, Stack Eq_84901 qwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out Eq_2 ebpOut, Register out Eq_2 esiOut, Register out Eq_84972 ediOut)
// Called from:
//      __printf_fphex
//      _fitoa
Eq_2 _itowa(struct Eq_9 * gs, Eq_84901 qwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, union Eq_2 & ebpOut, union Eq_2 & esiOut, union Eq_84972 & ediOut)
{
	Eq_2 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_2 dwArg04 = (word32) qwArg04;
	Eq_2 esi_20 = dwArg10;
	Eq_2 ebp_184 = dwArg0C;
	Eq_2175 edi_25 = gs->t0014;
	Eq_2 edi_30[] = g_a80B86A0;
	if (dwArg14 == 0x00)
		edi_30 = g_a80B8740;
	Eq_2 ebx_113;
	Eq_2 ecx_108 = dwArg04;
	if (dwArg10 != 0x08)
	{
		if (dwArg10 != 0x10)
		{
			ui32 dwLoc3C_334;
			if (dwArg08 != 0x00)
			{
				Eq_2 ebx_133 = (0x080B8460 + ((dwArg10 - 0x02) + (dwArg10 - 0x02) * 0x02) * 0x04)->t0008;
				if (ebx_133 <= dwArg08)
				{
					ecx_108 = (uint32) (SEQ((uint32) ((uint64) dwArg08 % ebx_133), dwArg04) % ebx_133);
					dwLoc3C_334 = 0x03;
				}
				else
				{
					dwLoc3C_334 = 0x02;
					ecx_108 = (uint32) (qwArg04 % ebx_133);
				}
			}
			else
				dwLoc3C_334 = 0x01;
			ebx_113 = dwArg0C;
			struct Eq_130212 * eax_178 = 0x080B8460 + (dwArg10 - 0x02) * 0x0C;
			while (true)
			{
				ui32 v20_182 = dwLoc3C_334 - 0x01;
				esi_20 = dwArg10;
				dwLoc3C_334 = v20_182;
				ebp_184.u0 = 0x00;
				if (ecx_108 != 0x00)
				{
					while (true)
					{
						uint64 edx_eax_196 = (uint64) ecx_108;
						ebx_113 -= 0x04;
						*ebx_113 = edi_30[(uint32) (edx_eax_196 % dwArg10)];
						ebp_184 = (word32) ebp_184 + 1;
						Eq_2 eax_200 = (uint32) (edx_eax_196 /u dwArg10);
						if (ecx_108 < dwArg10)
							break;
						ecx_108 = eax_200;
					}
				}
				if (v20_182 == 0x00)
					break;
				Eq_2 ecx_277 = (int32) eax_178->b0005;
				if (ecx_277 > ebp_184)
				{
					Eq_2 edx_283 = (word32) ebx_113 + (ebp_184 - ecx_277) * 0x04;
					Eq_2 eax_284 = ebx_113;
					do
					{
						eax_284 -= 0x04;
						*eax_284 = 0x30;
					} while (eax_284 != edx_283);
					ebx_113 = (word32) ebx_113 + (ebp_184 - ecx_277) * 0x04;
				}
				ecx_108 = (fp - 0x30)[v20_182];
			}
		}
		else
		{
			ebx_113 = dwArg0C;
			if (dwArg08 != 0x00)
			{
				ebx_113 = dwArg0C - 0x20;
				do
				{
					ebp_184 -= 0x04;
					*ebp_184.u0 = edi_30[ecx_108 & 0x0F];
					ecx_108 >>= 0x04;
				} while (dwArg0C - 0x20 != ebp_184);
				ecx_108 = dwArg08;
			}
			do
			{
				ebx_113 -= 0x04;
				*ebx_113 = edi_30[ecx_108 & 0x0F];
				esi_20 = dwArg10;
				ecx_108 >>= 0x04;
			} while (ecx_108 != 0x00);
		}
	}
	else
	{
		ebx_113 = dwArg0C;
		if (dwArg08 != 0x00)
		{
			ebx_113 = dwArg0C - 0x28;
			Eq_2 eax_47 = dwArg0C;
			do
			{
				eax_47 -= 0x04;
				esi_20 = edi_30[ecx_108 & 0x07];
				*eax_47 = esi_20;
				ecx_108 >>= 0x03;
			} while (eax_47 != dwArg0C - 0x28);
			ecx_108 |= dwArg08 * 0x04 & 0x04;
			if (dwArg08 >> 0x01 != 0x00)
			{
				*((word32) dwArg0C - 44) = edi_30[ecx_108];
				ebx_113 = dwArg0C - 44;
				ecx_108 = dwArg08 >> 0x01;
			}
		}
		do
		{
			ebx_113 -= 0x04;
			*ebx_113 = edi_30[ecx_108 & 0x07];
			ecx_108 >>= 0x03;
		} while (ecx_108 != 0x00);
	}
	Eq_84972 edi_231 = edi_25 ^ gs->t0014;
	if (edi_231 != 0x00)
	{
		word32 edx_509;
		word32 ecx_508;
		__stack_chk_fail(out ecx_508, out edx_509);
		Eq_2 eax_261 = init();
		ebpOut = ebp_184;
		esiOut = esi_20;
		ediOut = edi_231;
		return eax_261;
	}
	else
	{
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return ebx_113;
	}
}

// 08095DC0: Register ptr32 init()
// Called from:
//      _itowa
ptr32 init()
{
	static_buf.u0 = 0x080CFA8C;
	return 0x080CFA8C;
}

// 08095E10: void __dlerror(Register (ptr32 Eq_9) gs)
void __dlerror(struct Eq_9 * gs)
{
	Eq_2175 eax_20 = gs->t0014;
	Eq_2 ebp_133;
	ui32 eax_28 = once;
	if (eax_28 != 0x00)
	{
		ebp_133 = static_buf;
		if (ebp_133 == 0x00)
		{
l08095F78:
			Mem136 = Mem101;
			ebp_133.u0 = 0x080CFA8C;
			goto l08095E6F;
		}
	}
	else
	{
		static_buf.u0 = 0x080CFA8C;
		once = eax_28 | 0x02;
		Mem102 = Mem64;
		ebp_133.u0 = 0x080CFA8C;
		if (0x080CFA8C == 0x00)
			goto l08095F78;
	}
l08095E6F:
	Eq_2 eax_138 = *((word32) ebp_133 + 16);
	if (*((word32) ebp_133 + 4) != 0x00)
	{
		bool v27_410 = eax_138 > 0x00;
		if (eax_138 != 0x00)
		{
			word32 ecx_318 = 0x0E;
			cu8 * edi_319 = &g_b80B9420;
			Eq_2 esi_320 = eax_138;
			while (ecx_318 != 0x00)
			{
				v27_410 = *esi_685 > *edi_686;
				esi_320 = (word32) esi_685 + 1;
				edi_319 = edi_686 + 1;
				--ecx_318;
				esi_685 = esi_320;
				edi_686 = edi_319;
				if (*esi_685 == *edi_686)
					break;
			}
			if ((int8) v27_410 - (byte) (*esi_685 < *edi_686) != 0x00)
			{
				word32 ecx_675;
				word32 edx_676;
				free(gs, dwLoc40, eax_138, out ecx_675, out edx_676);
			}
			((word32) ebp_133 + 16)->u0 = 0x00;
		}
	}
	else if (eax_138 != 0x00)
	{
		Eq_2 dwLoc40_433;
		Eq_2 edx_145 = *ebp_133.u0;
		if (edx_145 != 0x00)
		{
			strerror(gs, edx_145);
			word32 edx_680;
			dcgettext(out edx_680);
			Eq_2 edx_216 = 134955513;
			if (**((byte) ebp_133.u0 + 0x0C) != 0x00)
				edx_216.u0 = 0x080A221C;
			dwLoc40_433 = edx_216;
		}
		else
		{
			word32 edx_679;
			dcgettext(out edx_679);
			Eq_2 edx_169 = 134955513;
			if (**((byte) ebp_133.u0 + 0x0C) != 0x00)
				edx_169.u0 = 0x080A221C;
			dwLoc40_433 = edx_169;
		}
		Eq_2127 eax_245 = ___asprintf();
		bool v23_406 = eax_245 > ~0x00;
		if (eax_245 != ~0x00)
		{
			Eq_2 eax_258 = *((byte) ebp_133.u0 + 16);
			word32 ecx_259 = 0x0E;
			cu8 * edi_262 = &g_b80B9420;
			Eq_2 esi_263 = eax_258;
			while (ecx_259 != 0x00)
			{
				v23_406 = *esi_683 > *edi_684;
				esi_263 = (word32) esi_683 + 1;
				edi_262 = edi_684 + 1;
				--ecx_259;
				esi_683 = esi_263;
				edi_684 = edi_262;
				if (*esi_683 == *edi_684)
					break;
			}
			if ((int8) v23_406 - (byte) (eax_245 < ~0x00) != 0x00)
			{
				word32 ecx_681;
				word32 edx_682;
				free(gs, dwLoc40_433, eax_258, out ecx_681, out edx_682);
			}
			*((byte) ebp_133.u0 + 16) = eax_138;
		}
		*((byte) ebp_133.u0 + 4) = 0x01;
l08095EA5:
		if ((eax_20 ^ gs->t0014) == 0x00)
			return;
		word32 edx_678;
		word32 ecx_677;
		Eq_2 eax_381 = __stack_chk_fail(out ecx_677, out edx_678);
		check_free.isra.0(eax_381, gs);
		return;
	}
	goto l08095EA5;
}

// 08096090: void check_free.isra.0(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      fini
//      __dlerror
//      free_key_mem
void check_free.isra.0(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2 edx_6 = *eax;
	bool v19_83 = edx_6 > 0x00;
	if (edx_6 == 0x00)
		return;
	word32 ecx_21 = 0x0E;
	cu8 * edi_22 = &g_b80B9420;
	Eq_2 esi_23 = edx_6;
	while (ecx_21 != 0x00)
	{
		v19_83 = *esi_140 > *edi_141;
		esi_23 = (word32) esi_140 + 1;
		edi_22 = edi_141 + 1;
		--ecx_21;
		esi_140 = esi_23;
		edi_141 = edi_22;
		if (*esi_140 == *edi_141)
			break;
	}
	if ((int8) v19_83 - (byte) (*esi_140 < *edi_141) == 0x00)
		return;
	word32 ecx_138;
	word32 edx_139;
	free(gs, dwLoc20, edx_6, out ecx_138, out edx_139);
	eax->u0 = 0x00;
}

// 080960E0: void free_key_mem(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void free_key_mem(struct Eq_9 * gs, Eq_2 dwArg04)
{
	check_free.isra.0((word32) dwArg04 + 16, gs);
	word32 ecx_78;
	word32 edx_79;
	free(gs, dwLoc20, dwArg04, out ecx_78, out edx_79);
}

// 08096130: Register word32 _dlerror_run(Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      __dlinfo
//      __dlmopen
//      __dlopen
//      __dlclose
//      __dlsym
//      __dlvsym
word32 _dlerror_run(struct Eq_9 * gs, ptr32 dwArg04, ptr32 dwArg08)
{
	Eq_2 esi_135;
	ui32 eax_17 = once;
	if (eax_17 != 0x00)
	{
		esi_135 = static_buf;
		if (esi_135 == 0x00)
		{
l080961E4:
			word32 ebx_124;
			word32 ecx_325;
			word32 edi_329;
			word32 edx_326;
			word32 ebp_327;
			word32 esi_328;
			Eq_2 eax_122 = __libc_calloc(gs, 0x01, 0x14, out ecx_325, out edx_326, out ebx_124, out ebp_327, out esi_328, out edi_329);
			esi_135 = eax_122;
			if (eax_122 == 0x00)
				esi_135 = ebx_124 + 6796;
			goto l08096175;
		}
	}
	else
	{
		static_buf.u0 = 0x080CFA8C;
		once = eax_17 | 0x02;
		Mem91 = Mem53;
		esi_135.u0 = 0x080CFA8C;
		if (0x080CFA8C == 0x00)
			goto l080961E4;
	}
l08096175:
	Eq_2 eax_160 = *((word32) esi_135 + 16);
	if (eax_160 != 0x00)
	{
		if (*((word32) esi_135 + 8) != 0x00)
		{
			word32 ecx_323;
			word32 edx_324;
			free(gs, dwLoc20, eax_160, out ecx_323, out edx_324);
		}
		((word32) esi_135 + 16)->u0 = 0x00;
	}
	word32 ecx_321;
	struct Eq_130603 * esi_211;
	word32 edx_322;
	esi_211->t0000 = _dl_catch_error(gs, (word32) esi_135 + 0x0C, (word32) esi_135 + 16, (word32) esi_135 + 8, out ecx_321, out edx_322, out esi_211);
	word32 eax_219 = esi_211->dw0010;
	esi_211->dw0004 = (uint32) (int8) (eax_219 == 0x00);
	return (word32) (eax_219 != 0x00);
}

// 080962C0: void __libc_register_dlfcn_hook()
// Called from:
//      __libc_dlopen_mode
//      __dlmopen
//      __dlopen
void __libc_register_dlfcn_hook()
{
	ptr32 * eax_17 = __libc_dlsym_private(gs);
	if (eax_17 != null)
		*eax_17 = 0x080CEF20;
}

// 08096300: void __dladdr(Stack Eq_2 dwArg04, Stack (ptr32 Eq_130698) dwArg08)
void __dladdr(Eq_2 dwArg04, struct Eq_130698 * dwArg08)
{
	_dl_addr(dwArg04, dwArg08, null, null);
}

// 08096320: void __dladdr1(Stack Eq_2 dwArg04, Stack (ptr32 Eq_130698) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack word32 dwArg10)
void __dladdr1(Eq_2 dwArg04, struct Eq_130698 * dwArg08, union Eq_2 * dwArg0C, word32 dwArg10)
{
	union Eq_2 * dwArg10_26;
	if (dwArg10 != 0x01)
	{
		dwArg10_26 = null;
		if (dwArg10 == 0x02)
			goto l08096346;
	}
	else
		dwArg10_26 = dwArg0C;
	dwArg0C = null;
l08096346:
	_dl_addr(dwArg04, dwArg08, dwArg0C, dwArg10_26);
}

// 08096360: void dlinfo_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_130722) dwArg04)
void dlinfo_doit(struct Eq_9 * gs, struct Eq_130722 * dwArg04)
{
	if (dwArg04->dw0008 > 0x0A)
	{
		struct Eq_123381 * edx_32;
		word32 ecx_99;
		word32 ebx_100;
		word32 ebp_101;
		word32 edi_102;
		_dl_signal_error(gs, 0x00, 0x080B9445, out ecx_99, out edx_32, out ebx_100, out ebp_101, out edi_102);
		word32 eax_43 = _dl_tls_get_addr_soft(gs, edx_32);
		*dwArg04->ptr000C = eax_43;
	}
	else
	{
		uint32 eax_60 = dwArg04->dw0008;
		<anonymous> * ecx_62 = g_a80B9460[eax_60 * 0x04] + 0x080CE000;
		ecx_62();
	}
}

// 08096490: void __dlinfo(Register (ptr32 Eq_9) gs)
void __dlinfo(struct Eq_9 * gs)
{
	Eq_2175 ecx_9 = gs->t0014;
	_dlerror_run(gs, 0x08096360, fp - 0x20);
	if ((ecx_9 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_99;
	word32 edx_100;
	__stack_chk_fail(out ecx_99, out edx_100);
	Eq_2 esp_50 = <invalid>;
	dlmopen_doit(gs, *((word32) esp_50 + 4));
}

// 08096510: void dlmopen_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_130789) dwArg04)
// Called from:
//      __dlinfo
void dlmopen_doit(struct Eq_9 * gs, struct Eq_130789 * dwArg04)
{
	if (dwArg04->dw0000 != 0x00)
	{
		word32 ebx_144;
		word32 edx_143;
		word32 ecx_142;
		word32 ebp_145;
		word32 edi_146;
		_dl_signal_error(gs, 22, 0x080B948C, out ecx_142, out edx_143, out ebx_144, out ebp_145, out edi_146);
		__dlmopen(gs, 0x00);
	}
	else
	{
		Eq_2 edx_52 = dwArg04->t0004;
		ui32 ecx_53 = dwArg04->dw0008;
		if (edx_52 == 0x00)
			edx_52.u0 = 134955513;
		dwArg04->dw000C = _dl_open(gs, edx_52, ecx_53 | 0x80000000, dwArg04->dw0010, 0x00, __libc_argc, __libc_argv, environ);
	}
}

// 08096590: void __dlmopen(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dlmopen_doit
void __dlmopen(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2175 ecx_9 = gs->t0014;
	if (_dlerror_run(gs, 134833424, fp - 0x24) == 0x00)
	{
		__libc_register_dl_open_hook();
		__libc_register_dlfcn_hook();
	}
	if ((ecx_9 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_133;
	word32 edx_134;
	__stack_chk_fail(out ecx_133, out edx_134);
	strerror(gs, dwArg04);
}

// 08096620: void strerror(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __dlerror
//      __dlmopen
void strerror(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_35 = <invalid>;
	struct Eq_130876 * ebx_30;
	word32 ebp_154;
	Eq_2 esi_34;
	if (strerror_r(gs, dwArg04, 0x00, 0x00, out ebx_30, out ebp_154, out esi_34) != 0x00)
		return;
	Eq_2 eax_46 = ebx_30->t1FF0;
	if (eax_46 == 0x00)
	{
		esp_35->u0 = 0x0400;
		word32 ebp_56;
		struct Eq_130899 * ebx_57;
		word32 Eq_9::* edi_59;
		word32 edx_156;
		word32 ecx_155;
		eax_46 = __libc_malloc(gs, *((word32) esp_35 - 4), *esp_35, out ecx_155, out edx_156, out ebx_57, out ebp_56, out esi_34, out edi_59);
		ebx_57->t1FF0 = eax_46;
		gs->*edi_59 = ebp_56;
		if (eax_46 == 0x00)
		{
			((word32) esp_35 + 8)->u0 = 0x05;
			*((word32) esp_35 + 4) = (char *) ebx_57 - 84834;
			*esp_35 = (char *) ebx_57 - 0x0001C4A4;
			word32 edx_160;
			dcgettext(out edx_160);
			return;
		}
	}
	((word32) esp_35 + 8)->u0 = 0x0400;
	*((word32) esp_35 + 4) = eax_46;
	*esp_35 = esi_34;
	word32 ebp_158;
	word32 esi_159;
	word32 ebx_157;
	strerror_r(gs, *esp_35, *((word32) esp_35 + 4), *((word32) esp_35 + 8), out ebx_157, out ebp_158, out esi_159);
}

// 080966C0: Register word32 strspn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __strtok_r
word32 strspn(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_138 = dwArg08;
	do
	{
		Eq_130975 cl_140 = *eax_138;
		if (cl_140 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_140].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_140;
		Eq_130982 cl_148 = *((word32) eax_138 + 1);
		if (cl_148 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_148].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_148;
		Eq_130992 cl_154 = *((word32) eax_138 + 2);
		if (cl_154 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_154].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_154;
		Eq_131002 cl_160 = *((word32) eax_138 + 3);
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_160].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_160;
		eax_138 = (word32) eax_138 + 4;
	} while (cl_160 != 0x00);
	struct Eq_130972 * eax_169 = dwArg04 - 0x04;
	do
	{
		++eax_169;
		byte cl_173 = eax_169->b0000;
		if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_173) == 0x00)
			return eax_169 - dwArg04;
		byte cl_180 = eax_169->b0001;
		if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_180].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_180) == 0x00)
			goto l08096768;
		byte cl_185 = eax_169->b0002;
		if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_185].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_185) == 0x00)
			goto l08096767;
		byte cl_190 = eax_169->b0003;
	} while (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_190].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_190) != 0x00);
	eax_169 = (struct Eq_130972 *) &eax_169->b0001;
l08096767:
	eax_169 = (struct Eq_130972 *) &eax_169->b0001;
l08096768:
	eax_169 = (struct Eq_130972 *) &eax_169->b0001;
	return eax_169 - dwArg04;
}

// 08096780: Register word32 __strsep_g(Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fillin_rpath
word32 __strsep_g(union Eq_2 * dwArg04, Eq_2 dwArg08)
{
	Eq_2 esi_12 = *dwArg04;
	if (esi_12 == 0x00)
		return;
	word32 eax_31 = strcspn(esi_12, dwArg08) + esi_12;
	if (*eax_31 == 0x00)
	{
		*dwArg04 = (union Eq_2 *) 0x00;
		return;
	}
	else
	{
		*eax_31 = 0x00;
		*dwArg04 = (union Eq_2 *) (eax_31 + 1);
		return;
	}
}

// 080967D0: Register (ptr32 Eq_224) __getdents64(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack ptr32 dwArg08, Stack word32 dwArg0C, Register out Eq_952 ecxOut)
// Called from:
//      readdir64
struct Eq_224 * __getdents64(struct Eq_9 * gs, word32 dwArg04, ptr32 dwArg08, word32 dwArg0C, union Eq_952 & ecxOut)
{
	struct Eq_224 * eax_12;
	gs->ptr0010();
	if (eax_12 > (struct Eq_224 *) ~0x0FFF)
	{
		word32 edx_47;
		struct Eq_224 * eax_20 = __syscall_error(eax_12, gs, out edx_47);
		ecxOut.u0 = <invalid>;
		return eax_20;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		return eax_12;
	}
}

// 08096810: Register word32 getpid(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_debug_vdprintf
word32 getpid(struct Eq_9 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08096830: void __profil_counter(Stack word32 dwArg40)
void __profil_counter(word32 dwArg40)
{
	Eq_131117 eax_13 = dwArg40 - pc_offset;
	word64 edx_eax_18 = Mem11[0x080CFB3C<p32>:word32] *u64 ((eax_13 >>u 0x1F) + eax_13 >> 0x01);
	uint32 eax_21 = __shrd((word32) edx_eax_18, SLICE(edx_eax_18, word32, 32), 0x10);
	if (eax_21 < nsamples)
	{
		Eq_2 edx_24 = samples;
		*((word32) edx_24 + eax_21 * 0x02) = (word32) *((word32) edx_24 + eax_21 * 0x02) + 1;
	}
}

// 08096880: Register Eq_2 profil(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_start_profile
Eq_2 profil(struct Eq_9 * gs, Eq_2 dwArg04)
{
	struct Eq_131151 * esp_109 = fp - 0xAC;
	Eq_2175 eax_17 = gs->t0014;
	Eq_2 edx_21 = samples;
	if (dwArg04 != 0x00)
	{
		if (edx_21 == 0x00)
		{
l08096900:
			uint32 eax_115 = esp_109->dw00B4;
			samples = dwArg04;
			esp_109->dw0094 = 0x10000000;
			nsamples = eax_115 >> 0x01;
			pc_offset = esp_109->dw00B8;
			pc_scale = esp_109->dw00BC;
			esp_109->ptr0010 = 0x08096830;
			word32 * edx_119 = &esp_109->ptr0010;
			word32 * eax_130 = &esp_109->ptr0010 + 32;
			do
			{
				*eax_130 = ~0x00;
				eax_130 -= 0x04;
			} while (eax_130 != edx_119);
			struct Eq_131228 * esp_138 = esp_109 - 0x04;
			esp_138->ptrFFFFFFFC = 0x080CFAA0;
			esp_138->ptrFFFFFFF8 = eax_130;
			esp_138->dwFFFFFFF4 = 0x1B;
			Eq_2 esp_153 = <invalid>;
			if (__sigaction(gs, esp_138->dwFFFFFFF4) >= null)
			{
				((word32) esp_153 + 24)->u0 = 0x00;
				*((word32) esp_153 + 28) = (int32) (1000000 /32 __profile_frequency());
				int32 edx_180 = *((word32) esp_153 + 28);
				*((word32) esp_153 + 16) = *((word32) esp_153 + 24);
				*((word32) esp_153 + 20) = edx_180;
				*((word32) esp_153 + 8) = 0x080CFB2C;
				*((word32) esp_153 + 4) = (word32) esp_153 + 16;
				*esp_153 = 0x02;
				__setitimer(gs, *esp_153, *((word32) esp_153 + 4), *((word32) esp_153 + 8));
				goto l080969B8;
			}
			goto l08096A28;
		}
		if (__setitimer(gs, 0x02, &g_dw80CFB2C, 0x00) < 0x00)
			goto l08096A28;
		Eq_2 esp_104 = <invalid>;
		esp_109 = (word32) esp_104 + 16;
		if (__sigaction(gs, 0x1B) >= null)
			goto l08096900;
	}
	else
	{
		if (edx_21 == 0x00)
			goto l080969B8;
		if (__setitimer(gs, 0x02, &g_dw80CFB2C, 0x00) >= 0x00)
		{
			samples.u0 = 0x00;
			__sigaction(gs, 0x1B);
l080969B8:
			if ((eax_17 ^ gs->t0014) == 0x00)
				return esi;
			word32 ecx_294;
			word32 edx_295;
			__stack_chk_fail(out ecx_294, out edx_295);
			__profile_frequency();
			return dwArg04;
		}
	}
l08096A28:
	goto l080969B8;
}

// 08096A40: Register word32 __profile_frequency()
// Called from:
//      _dl_start_profile
//      profil
word32 __profile_frequency()
{
	return _dl_clktck;
}

// 08096A60: Register Eq_2 _dl_fixup(Register Eq_2 eax, Register word32 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_runtime_resolve
//      _dl_runtime_resolve_shstk
//      _dl_profile_fixup
Eq_2 _dl_fixup(Eq_2 eax, word32 edx, struct Eq_9 * gs)
{
	struct Eq_131328 * edx_26 = (word32) *((word32) *((word32) eax + 0x007C) + 4) + edx;
	uint32 edx_29 = edx_26->dw0004;
	word32 ebx_36 = *eax;
	word32 esi_22 = *((word32) *((word32) eax + 52) + 4);
	struct Eq_131351 * ecx_35 = (word32) *((word32) *((word32) eax + 56) + 4) + ((edx_29 >> 0x08) << 0x04);
	union Eq_2 * edi_38 = edx_26->dw0000 + ebx_36;
	if ((byte) edx_29 != 0x07)
	{
		Eq_123876 edx_55;
		word32 ecx_353;
		Eq_2 eax_54 = __assert_fail(out ecx_353, out edx_55);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		return _dl_profile_fixup(eax_54, ecx, edx_55, gs, stackArg8);
	}
	Eq_2 eax_171;
	word32 eax_181;
	if ((ecx_35->b000D & 0x03) == 0x00)
	{
		Eq_2 edx_113 = *((word32) eax + 232);
		if (edx_113 != 0x00)
		{
			edx_113 = (word32) *((word32) eax + 372) + (((word32) (*((word32) (*((word32) edx_113 + 4)) + (edx_29 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) edx_113 + 4) == null)
				edx_113.u0 = 0x00;
		}
		Eq_2 ebx_101 = 0x01;
		if (gs->t000C != 0x00)
		{
			gs->t001C.u0 = 0x01;
			ebx_101.u0 = 0x05;
		}
		word32 ecx_356;
		word32 edx_357;
		Eq_2 eax_133 = _dl_lookup_symbol_x(gs, esi_22 + ecx_35->dw0000, eax, fp - 0x20, *((word32) eax + 464), edx_113, 0x01, ebx_101, 0x00, out ecx_356, out edx_357);
		if (gs->t000C != 0x00)
		{
			Eq_2 v17_149 = gs->t001C;
			gs->t001C.u0 = 0x00;
			if (v17_149 == 0x02)
				gs->ptr0010();
		}
		eax_171.u0 = 0x00;
		if (ecx_35 == null)
		{
l08096B53:
			if (_dl_bind_not == 0x00)
				*edi_38 = (union Eq_2 *) eax_171;
			return eax_171;
		}
		if (ecx_35->w000E != ~0x0E && eax_133 != 0x00)
			eax_181 = (word32) *eax_133;
		else
			eax_181 = 0x00;
	}
	else
	{
		if (ecx_35->w000E == ~0x0E)
			ebx_36 = 0x00;
		eax_181 = ebx_36;
	}
	word32 edx_191 = (word32) ecx_35->b000C;
	eax_171 = eax_181 + ecx_35->dw0004;
	if (((byte) edx_191 & 0x0F) == 0x0A)
		eax_171();
	goto l08096B53;
}

// 08096C10: Register Eq_2 _dl_profile_fixup(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_123876 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08)
// Called from:
//      _dl_runtime_profile_shstk
//      _dl_runtime_profile
//      _dl_fixup
Eq_2 _dl_profile_fixup(Eq_2 eax, Eq_2 ecx, Eq_123876 edx, struct Eq_9 * gs, Eq_2 dwArg08)
{
	Eq_2 ebp_200;
	Eq_2 ecx_22 = *((word32) eax + 420);
	if (ecx_22 == 0x00)
	{
		*dwArg08 = ~0x00;
		ebp_200 = _dl_fixup(eax, edx_31, gs);
		return ebp_200;
	}
	struct Eq_131516 * edi_38 = (word32) ecx_22 + ((edx >> 0x03) + (edx >> 0x03) * 0x02) * 0x08;
	ebp_200 = edi_38->t0014;
	if (ebp_200 != 0x00)
	{
		ebp_200 = edi_38->t0000;
		goto l08096D42;
	}
	uint32 edx_153 = *((word32) edx + ((word32) (*((word32) (*((word32) eax + 0x007C)) + 4)) + 4));
	word32 esi_45 = *((word32) *((word32) eax + 52) + 4);
	struct Eq_131552 * ecx_152 = (word32) *((word32) *((word32) eax + 56) + 4) + ((edx_153 >> 0x08) << 0x04);
	if ((byte) edx_153 != 0x07)
	{
		word32 ecx_423;
		word32 edx_424;
		Eq_2 eax_72 = __assert_fail(out ecx_423, out edx_424);
		_dl_call_pltexit();
		return eax_72;
	}
	ui32 eax_207;
	if ((ecx_152->t000D & 0x03) == 0x00)
	{
		Eq_2 edx_104 = *((word32) eax + 232);
		if (edx_104 != 0x00)
		{
			edx_104 = (word32) *((word32) eax + 372) + (((word32) (*((word32) (*((word32) edx_104 + 4)) + (edx_153 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) edx_104 + 4) == null)
				edx_104 = ebp_200;
		}
		Eq_2 ebx_114 = 0x01;
		if (gs->t000C != 0x00)
		{
			gs->t001C.u0 = 0x01;
			ebx_114.u0 = 0x05;
		}
		Eq_2 eax_151 = _dl_lookup_symbol_x(gs, esi_45 + ecx_152->dw0000, eax, fp - 0x20, *((word32) eax + 464), edx_104, 0x01, ebx_114, 0x00, out ecx_152, out edx_153);
		if (gs->t000C != 0x00)
		{
			Eq_2 v19_167 = gs->t001C;
			gs->t001C.u0 = 0x00;
			if (v19_167 == 0x02)
				gs->ptr0010();
		}
		if (ecx_152 != null)
		{
			if (ecx_152->t000E != ~0x0E && eax_151 != 0x00)
				ebp_200 = *eax_151;
			ui32 eax_206 = (word32) ecx_152->b000C;
			ebp_200 = (word32) ebp_200 + ecx_152->dw0004;
			eax_207 = eax_206 & 0x0F;
			if (((byte) eax_206 & 0x0F) != 0x0A)
				goto l08096D23;
			goto l08096DA0;
		}
	}
	else
	{
		if (ecx_152->t000E != ~0x0E)
			ebp_200 = *eax;
		ui32 eax_89 = (word32) ecx_152->b000C;
		ebp_200 = (word32) ebp_200 + ecx_152->dw0004;
		eax_207 = eax_89 & 0x0F;
		if (((byte) eax_89 & 0x0F) == 0x0A)
		{
l08096DA0:
			Eq_2 eax_244;
			ebp_200();
			ebp_200 = eax_244;
			goto l08096D23;
		}
	}
l08096D23:
	if (_dl_bind_not == 0x00)
	{
		edi_38->t0000 = ebp_200;
		edi_38->t0014.u0 = 0x01;
	}
l08096D42:
	*dwArg08 = ~0x00;
	word32 ecx_425;
	word32 edx_426;
	_dl_mcount(gs, ecx, ebp_200, out ecx_425, out edx_426);
	return ebp_200;
}

// 08096E30: void _dl_call_pltexit()
// Called from:
//      _dl_runtime_profile
//      _dl_profile_fixup
void _dl_call_pltexit()
{
}

// 08096E40: Register Eq_2 add_to_global(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_131727) ebpOut, Register out (ptr32 Eq_131728) ediOut)
// Called from:
//      dl_open_worker
Eq_2 add_to_global(Eq_2 eax, struct Eq_9 * gs, struct Eq_131727 & ebpOut, struct Eq_131728 & ediOut)
{
	up32 eax_25;
	uint32 ebp_21 = *((word32) eax + 356);
	if (ebp_21 != 0x00)
	{
		union Eq_131737 * edx_28 = *((word32) eax + 352);
		eax_25 = 0x00;
		union Eq_131737 * edi_32 = (char *) edx_28 + ebp_21 * 0x04;
		do
		{
			eax_25 += (word32) ((*((char *) *edx_28 + 408) & 0x10) < 0x01);
			edx_28 = (union Eq_131737 *) ((char *) edx_28 + 4);
		} while (edi_32 != edx_28);
	}
	else
		eax_25 = 0x00;
	word32 ebx_136;
	Eq_2 edi_51 = *((word32) eax + 24);
	struct Eq_131766 * ecx_58 = edi_51 *s 0x4C + 0x080CEA00;
	struct Eq_131771 * edi_59 = ecx_58->ptr0008;
	Eq_2 esi_140 = eax;
	uint32 edx_60 = ecx_58->dw000C;
	uint32 edi_119 = edi_59->dw0004;
	if (edx_60 != 0x00)
	{
		if (edx_60 >= eax_25 + edi_119)
			goto l08096EC1;
		uint32 eax_123 = eax_25 + edx_60;
		Eq_2 ebp_135;
		word32 edx_449;
		word32 ecx_448;
		word32 edi_450;
		Eq_2 eax_134 = __libc_malloc(gs, dwLoc50, eax_123 << 0x03, out ecx_448, out edx_449, out ebx_136, out ebp_135, out esi_140, out edi_450);
		if (eax_134 != 0x00)
		{
			word32 ecx_456;
			word32 edx_457;
			memcpy(eax_134, ebp_135, edx_60 << 0x02, out ecx_456, out edx_457);
			ecx_58->dw000C = eax_123 * 0x02;
			edi_59->t0000 = eax_134;
			if (gs->t000C != 0x00)
				_dl_wait_lookup_done();
			word32 ecx_458;
			word32 edx_459;
			free(gs, dwLoc50, ebp_135, out ecx_458, out edx_459);
			ebp_21 = (uint32) *((word32) esi_140 + 356);
			edi_119 = *((char *) *((char *) &g_ptr80CEA08 + edi_51 * 0x4C) + 4);
l08096EC1:
			if (ebp_21 != 0x00)
			{
				uint32 ebp_249 = 0x00;
				struct Eq_131845 * ecx_250 = edi_51 *s 0x4C + 0x080CEA00;
				do
				{
					struct Eq_131860 * edx_256 = *((word32) *((word32) esi_140 + 352) + ebp_249 * 0x04);
					word32 eax_257 = (word32) edx_256->b0198;
					if (((byte) eax_257 & 0x10) == 0x00)
					{
						edx_256->b0198 = (byte) eax_257 | 0x10;
						*((char *) *ecx_250->ptr0008 + edi_119 * 0x04) = (struct Eq_131860 * (**)[]) edx_256;
						++edi_119;
						if ((g_b80CFF05 & 0x02) != 0x00)
						{
							word32 edx_452;
							word32 ecx_451;
							_dl_debug_printf(out ecx_451, out edx_452);
						}
					}
					++ebp_249;
				} while (*((word32) esi_140 + 356) > ebp_249);
			}
			*((char *) *((char *) &g_ptr80CEA08 + edi_51 * 0x4C) + 4) = edi_119;
			ebpOut = ebp;
			ediOut = edi;
			return 0x00;
		}
	}
	else
	{
		uint32 eax_68 = eax_25 + 0x08 + edi_119;
		ecx_58->dw000C = eax_68;
		ui32 edi_83;
		word32 ecx_446;
		word32 edx_447;
		Eq_2 eax_79 = __libc_malloc(gs, dwLoc50, eax_68 << 0x02, out ecx_446, out edx_447, out ebx_136, out ebp_21, out esi_140, out edi_83);
		if (eax_79 != 0x00)
		{
			word32 ecx_460;
			word32 edx_461;
			edi_59->t0000 = memcpy(eax_79, edi_59->t0000, edi_83 << 0x02, out ecx_460, out edx_461);
			edi_119 = edi_59->dw0004;
			goto l08096EC1;
		}
		ecx_58->dw000C = 0x00;
	}
	Eq_2 v21_159 = **((word32) esi_140 + 28);
	struct Eq_131727 * ebp_166;
	struct Eq_131728 * edi_169;
	word32 ebx_455;
	word32 edx_454;
	word32 ecx_453;
	_dl_signal_error(gs, 0x0C, ebx_136 + ~0x00014AF1, out ecx_453, out edx_454, out ebx_455, out ebp_166, out edi_169);
	Eq_2 eax_176 = _dl_find_dso_for_object(v21_159);
	ebpOut = ebp_166;
	ediOut = edi_169;
	return eax_176;
}

// 08097060: Register Eq_2 _dl_find_dso_for_object(Stack Eq_2 dwArg04)
// Called from:
//      add_to_global
//      dl_open_worker
//      _dl_addr
//      _dl_sym
Eq_2 _dl_find_dso_for_object(Eq_2 dwArg04)
{
	if (_dl_nns != 0x00)
	{
		Eq_2 ebx_22 = g_t80CEA00;
		while (ebx_22 != 0x00)
		{
			if (*((word32) ebx_22 + 432) <= dwArg04 && (*((word32) ebx_22 + 436) > dwArg04 && ((*((word32) ebx_22 + 0x0199) & 0x40) != 0x00 || _dl_addr_inside_object(ebx_22, dwArg04) != 0x00)))
			{
				if (*((word32) ebx_22 + 24) != 0x00)
				{
					word32 ecx_163;
					word32 edx_164;
					__assert_fail(out ecx_163, out edx_164);
				}
				else
					return ebx_22;
			}
			ebx_22 = *((word32) ebx_22 + 0x0C);
		}
	}
	return 0x00;
}

// 08097100: Register word32 _dl_open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack Eq_2 dwArg10, Stack word32 dwArg14, Stack (ptr32 word32) dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      do_dlopen
//      dlmopen_doit
//      _dl_find_dso_for_object
//      dlopen_doit
word32 _dl_open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, word32 dwArg0C, Eq_2 dwArg10, word32 dwArg14, word32 * dwArg18, Eq_2 dwArg1C)
{
	struct Eq_132038 * esp_114;
	Eq_2 ebp_106;
	Eq_2 eax_159;
	struct Eq_132041 * esp_141;
	ptr32 ebx_143 = 0x080CE000;
	Eq_2 esp_153 = fp - 0x4C;
	Eq_2 esi_19 = dwArg08;
	Eq_2 edi_169 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
l080972CF:
		eax_159 = ebx_143 + 4294882625;
		goto l08097231;
	}
	else
	{
		esp_153 = fp - 0x4C;
		if (dwArg10 != ~0x00)
		{
			eax_159.u0 = 0x080B9618;
			if (((word32) dwArg10 + 2 & ~0x02) == 0x00)
			{
				word32 edx_475;
				word32 ecx_474;
				ebp_106 = _dl_catch_exception(gs, fp - 0x48, 0x08097480, fp - 0x3C, out ecx_474, out edx_475, out ebx_143);
				_dl_unload_cache(gs);
				edi_169 = fp - 0x48;
				esp_114 = fp - 0x4C;
				if (dwLoc44 != 0x00)
				{
l08097240:
					Eq_2 esi_203;
					Eq_2 eax_198 = esp_114[7];
					if (eax_198 != 0x00)
					{
						esi_203 = esi_19 & 0x08000000;
						if (esi_203 == 0x00)
							goto l080972A0;
l08097250:
						struct Eq_132127 * esp_208 = esp_114 - 0x08;
						esp_208->tFFFFFFFC.u1 = 0x01;
						esp_208->tFFFFFFF8 = eax_198;
						_dl_close_worker(esi_203, gs, esp_208->tFFFFFFF8, esp_208->tFFFFFFFC, out ebx_143, out ebp_106, out edi_169);
						esp_114 = (struct Eq_132038 *) ((char *) &esp_208->tFFFFFFFC + 0x0C);
					}
					struct Eq_132041 * esp_233 = esp_114 - 0x08;
					esp_233->tFFFFFFFC = esp_233->t0028;
					esp_233->tFFFFFFF8.u0 = 0x00;
					esi_19 = *((word32) _dl_debug_initialize(esp_233->tFFFFFFF8, esp_233->tFFFFFFFC) + 0x0C);
					if (esi_19 == 0x00)
					{
						struct Eq_132213 * esp_284 = esp_114 - 0x04;
						esp_284->dwFFFFFFFC = 0x00;
						esp_284->tFFFFFFF8 = edi_169;
						esp_284->tFFFFFFF4 = ebp_106;
						esp_114 = esp_284 - 0x0C;
						word32 ebx_476;
						eax_198 = _dl_signal_exception(gs, esp_284->tFFFFFFF4, esp_284->tFFFFFFF8, out ebx_476);
						esi_203 = esi_19;
l080972A0:
						g_b80CFEC4 = 0x01;
						goto l08097250;
					}
					esp_233->ptr0004 = ebx_143 + 4294883128;
					esp_233->dw0000 = 0x0267;
					esp_141 = esp_233;
					goto l080972BC;
				}
				if (*((word32) _dl_debug_initialize(0x00, dwArg10) + 0x0C) == 0x00)
					return 0x00;
				esp_141 = fp - 0x54;
l080972BC:
				struct Eq_132238 * esp_146 = esp_141 - 4;
				esp_146->ptr0000 = ebx_143 + ~0x00014AD6;
				esp_146->ptrFFFFFFFC = ebx_143 + 4294882880;
				word32 ecx_477;
				word32 edx_478;
				__assert_fail(out ecx_477, out edx_478);
				esp_153.u0 = <invalid>;
				goto l080972CF;
			}
		}
		else
		{
			esp_153 = fp - 0x4C;
			eax_159.u0 = 134977004;
		}
l08097231:
		struct Eq_132059 * esp_163 = esp_153 - 4;
		esp_163->t0000 = eax_159;
		esp_163->dwFFFFFFFC = 0x00;
		esp_163->tFFFFFFF8 = edi_169;
		esp_163->tFFFFFFF4.u0 = 22;
		word32 edx_473;
		word32 ecx_472;
		_dl_signal_error(gs, esp_163->tFFFFFFF4, esp_163->t0000, out ecx_472, out edx_473, out ebx_143, out ebp_106, out edi_169);
		esp_114 = esp_163 - 0x0C;
		goto l08097240;
	}
}

// 080972F0: void _dl_show_scope(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
// Called from:
//      dl_open_worker
void _dl_show_scope(Eq_2 dwArg04, ui32 dwArg08)
{
	if (**((word32) dwArg04 + 4) == 0x00)
		**(union Eq_2 **) 135060900 != 0x00;
	word32 edx_299;
	word32 ecx_298;
	_dl_debug_printf(out ecx_298, out edx_299);
	Eq_2 eax_57 = *((word32) dwArg04 + 464);
	if (eax_57 != 0x00)
	{
		int32 ebx_113 = dwArg08 * 0x04;
		if (*((word32) eax_57 + dwArg08 * 0x04) != 0x00)
		{
			do
			{
				word32 ecx_306;
				word32 edx_307;
				_dl_debug_printf(out ecx_306, out edx_307);
				Eq_132299 edx_114 = *((word32) *((word32) dwArg04 + 464) + ebx_113);
				if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&edx_114.a0000[1].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] != 0x00)
				{
					uint32 edi_128 = 0x00;
					do
					{
						if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&edx_114.a0000[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000[edi_128].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000[1].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == 0x00)
							**(union Eq_2 **) 135060900 != 0x00;
						word32 edx_303;
						_dl_debug_printf_c(out edx_303);
						++edi_128;
						edx_114 = (Eq_132299) *((word32) *((word32) dwArg04 + 464) + ebx_113);
					} while ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&edx_114.a0000[1].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] > edi_128);
				}
				word32 edx_302;
				_dl_debug_printf_c(out edx_302);
				ebx_113 += 0x04;
			} while (*((word32) *((word32) dwArg04 + 464) + ebx_113) != 0x00);
		}
	}
	else
	{
		word32 ecx_300;
		word32 edx_301;
		_dl_debug_printf(out ecx_300, out edx_301);
	}
	word32 ecx_304;
	word32 edx_305;
	_dl_debug_printf(out ecx_304, out edx_305);
}

// 08097480: void dl_open_worker(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_132377) dwArg04)
void dl_open_worker(struct Eq_9 * gs, struct Eq_132377 * dwArg04)
{
	Eq_2 edi_139;
	Eq_2 esi_102;
	Eq_2 ebx_23 = dwArg04->t0000;
	ui32 eax_24 = dwArg04->dw0004;
	word32 ecx_1406;
	word32 edx_1407;
	Eq_2 eax_30 = strchr(ebx_23, 0x24, out ecx_1406, out edx_1407);
	if (eax_30 == 0x00)
	{
		edi_139 = eax_30;
		esi_102 = dwArg04->t0010;
		if (esi_102 != ~0x01)
		{
			word32 ecx_1408;
			word32 edx_1409;
			if (strchr(ebx_23, 0x2F, out ecx_1408, out edx_1409) != 0x00)
				goto l080974EC;
		}
	}
	Eq_2 esi_70 = g_t80CEA00;
	Eq_2 eax_75 = _dl_find_dso_for_object(dwArg04->t0008);
	edi_139 = eax_75;
	if (eax_75 == 0x00)
		edi_139 = esi_70;
	esi_102 = dwArg04->t0010;
	if (esi_102 == ~0x01)
	{
		esi_102 = *((word32) edi_139 + 24);
		dwArg04->t0010 = esi_102;
	}
l080974EC:
	ui32 esi_1166;
	Eq_2 ecx_1129;
	Eq_2 esp_1014;
	Eq_2 ebx_1197;
	Eq_2 eax_1141;
	Eq_2 esp_1042;
	_dl_debug_initialize(0x00, esi_102);
	word32 ebx_1410;
	struct Eq_132438 * ebp_1007;
	Eq_2 eax_145 = _dl_map_object(edi_139, gs, edi_139, ebx_23, 0x02, eax_24 | 0x10000000, dwArg04->t0010, out ebx_1410, out ebp_1007);
	*((word32) ebp_1007->t0008 + 0x0C) = eax_145;
	Eq_2 edi_1030 = eax_145;
	if (eax_145 == 0x00)
	{
		if ((ebp_1007->tFFFFFFD8 & 0x04) != 0x00)
			return;
		word32 ecx_1411;
		word32 edx_1412;
		__assert_fail(out ecx_1411, out edx_1412);
		esp_1014.u0 = <invalid>;
l08097900:
		ebx_1197 = ebp_1007->tFFFFFFC4;
		edi_1030 = (byte) edi_1030.u0 + 1;
		ecx_1129 = ebp_1007->tFFFFFFCC;
		if (ebx_1197 <= edi_1030)
		{
l08097918:
			edi_1030 = ecx_1129;
			if (ebp_1007->bFFFFFFC3 != 0x00)
			{
				Eq_123392 v17_806 = _dl_tls_generation.dw0000 + 0x01;
				_dl_tls_generation.dw0000 = (up32) v17_806;
				if (v17_806 == 0x00)
				{
					struct Eq_132651 * esp_815 = esp_1014 - 0x08;
					esp_815->dwFFFFFFFC = (word32) ebp_1007->tFFFFFFD4 - 84240;
					esp_815->tFFFFFFF8.u0 = 0x02;
					_dl_dprintf();
					esp_815->tFFFFFFF8.u0 = 0x7F;
					_exit(gs, esp_815->tFFFFFFF8);
				}
			}
			Eq_2 esi_948 = ebp_1007->tFFFFFFBC;
			if (ebx_1197 > esi_948)
			{
				Eq_2 edx_955 = ecx_1129;
				do
				{
					Eq_2 edi_961 = *((word32) *((word32) edx_955 + 352) + esi_948 * 0x04);
					if ((*((word32) edi_961 + 408) & 0x0408) == 0x0400 && *((word32) edi_961 + 568) != 0x00)
					{
						ebp_1007->tFFFFFFE4 = edx_955;
						*((word32) edi_961 + 0x0199) &= ~0x04;
						struct Eq_132790 * esp_972 = esp_1014 - 0x0C;
						esp_972->tFFFFFFFC = edi_961;
						_dl_init_static_tls();
						edx_955 = ebp_1007->tFFFFFFE4;
						if ((*((word32) edi_961 + 0x0199) & 0x04) != 0x00)
						{
							ecx_1129 = ebp_1007->tFFFFFFD4;
							esp_972->ptr0008 = (word32) ecx_1129 - 84184;
							esp_972->dw0004 = 0x01ED;
							esp_972->ptr0000 = (word32) ecx_1129 - 84695;
							esp_972->tFFFFFFFC = (word32) ecx_1129 - 84562;
							word32 edx_1414;
							word32 ecx_1413;
							eax_1141 = __assert_fail(out ecx_1413, out edx_1414);
							esp_1014.u0 = <invalid>;
							goto l080979C8;
						}
					}
					esi_948 = (word32) esi_948 + 1;
				} while (*((word32) edx_955 + 356) > esi_948);
				edi_1030 = edx_955;
			}
			if (ebp_1007->tFFFFFFB4 == 0x00)
			{
l08097855:
				struct Eq_133166 * esp_1019 = esp_1014 - 4;
				esp_1019->dw0000 = (word32) *((word32) ebp_1007->t0008 + 28);
				esp_1019->dwFFFFFFFC = (word32) *((word32) ebp_1007->t0008 + 24);
				esp_1019->dwFFFFFFF8 = (word32) *((word32) ebp_1007->t0008 + 20);
				esp_1019->tFFFFFFF4 = edi_1030;
				_dl_init(esp_1019->tFFFFFFF4, esp_1019->dwFFFFFFF8, esp_1019->dwFFFFFFFC, esp_1019->dw0000);
				esp_1042 = &esp_1019->dw0000 + 1;
				if ((ebp_1007->tFFFFFFD8 & 0x0100) != 0x00)
				{
					esp_1042.u0 = <invalid>;
					if (add_to_global(edi_1030, gs, out ebp_1007, out edi_1030) != 0x00)
						return;
				}
				*((word32) ebp_1007->tFFFFFFD4 + 0x0CD4) = 0x01;
				if ((*ebp_1007->ptrFFFFFFDC & 0x40) != 0x00)
				{
l08097BD0:
					Eq_2 eax_1088 = ebp_1007->tFFFFFFD4;
					struct Eq_133270 * esp_1094 = esp_1042 - 4;
					esp_1094->dw0000 = (word32) *((byte) edi_1030.u0 + 404);
					esp_1094->dwFFFFFFFC = (word32) *((byte) edi_1030.u0 + 24);
					esp_1094->dwFFFFFFF8 = (word32) *((byte) edi_1030.u0 + 4);
					esp_1094->dwFFFFFFF4 = (word32) eax_1088 - 84352;
					word32 ecx_1417;
					word32 edx_1418;
					_dl_debug_printf(out ecx_1417, out edx_1418);
				}
				return;
			}
l08097A08:
			goto l08097855;
		}
		goto l08097771;
	}
	if ((ebp_1007->tFFFFFFD8 & 0x1000) != 0x00)
		*((word32) eax_145 + 520) |= 0x08;
	if ((ebp_1007->tFFFFFFD8 & 0x40000000) != 0x00)
		return;
	Eq_2 esp_318;
	word32 edx_200 = *((word32) eax_145 + 352);
	*((word32) eax_145 + 404) = (word32) *((word32) eax_145 + 404) + 1;
	if (edx_200 == 0x00)
	{
		uint32 ebx_231;
		Eq_2 esp_236 = <invalid>;
		for (ebx_231 = _dl_map_object_deps(gs, 0x00, 0x00, out ebp_1007, out edi_1030); ebx_231 < *((word32) edi_1030 + 356); ++ebx_231)
		{
			Eq_2 eax_252 = *((word32) *((word32) *((word32) edi_1030 + 352) + ebx_231 * 0x04) + 20);
			if (*((word32) eax_252 + 372) == 0x00)
			{
				*((word32) esp_236 + 24) = 0x00;
				((word32) esp_236 + 20)->u0 = 0x00;
				*((word32) esp_236 + 16) = eax_252;
				_dl_check_map_versions(gs, *((word32) esp_236 + 16));
				++ebx_231;
				if (*((word32) edi_1030 + 356) <= ebx_231)
					break;
				continue;
			}
		}
		*((word32) esp_236 + 20) = *((word32) ebp_1007->t0008 + 16);
		((word32) esp_236 + 16)->u0 = 0x00;
		Eq_2 eax_294 = _dl_debug_initialize(*((word32) esp_236 + 16), *((word32) esp_236 + 20));
		((word32) eax_294 + 0x0C)->u0 = 0x00;
		ebp_1007->tFFFFFFD0 = eax_294;
		_dl_debug_state();
		*((word32) esp_236 + 16) = edi_1030;
		_dl_cet_open_check(gs, *((word32) esp_236 + 16));
		ebp_1007->ptrFFFFFFDC = &_dl_debug_mask;
		Eq_2 eax_321 = _dl_debug_mask;
		ebp_1007->tFFFFFFE4 = eax_321;
		esp_318 = (word32) esp_236 + 32;
		if ((SLICE(eax_321, byte, 8) & 0x02) == 0x00)
		{
l0809761D:
			Eq_2 eax_330 = ebp_1007->tFFFFFFD8;
			Eq_2 ecx_334 = eax_330 & 0x08000000;
			if (_dl_lazy != 0x00)
				ecx_334 = eax_330 & 0x08000001;
			ebp_1007->tFFFFFFE4 = ecx_334;
			Eq_2 eax_342 = edi_1030;
			ui32 ecx_346 = 0x00;
			do
			{
				eax_342 = *((word32) eax_342 + 0x0C);
				ecx_346 += (word32) ((*((word32) *((word32) eax_342 + 20) + 408) & 0x04) < 0x01);
			} while (eax_342 != 0x00);
			ebp_1007->tFFFFFFB8 = esp_318;
			ui32 eax_366 = ecx_346 * 0x04 + 0x0F;
			Eq_2 ecx_375 = esp_318 - (eax_366 & ~0x0FFF);
			while (esp_318 != ecx_375)
			{
				esp_318 -= 0x1000;
				*((word32) esp_318 + 0x0FFC) = *((word32) esp_318 + 0x0FFC);
			}
			int32 edx_391 = eax_366 & ~0x0F & 0x0FFF;
			if (edx_391 != 0x00)
			{
				esp_318 -= edx_391;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_318 - 0x04)[edx_391 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_318 - 0x04)[edx_391 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_2 eax_408 = edi_1030;
			Eq_2 esi_412 = 0x00;
			do
			{
				if ((*((word32) *((word32) eax_408 + 20) + 408) & 0x04) == 0x00)
				{
					*((word32) esp_318 + esi_412 * 0x04) = eax_408;
					esi_412 = (word32) esi_412 + 1;
				}
				eax_408 = *((word32) eax_408 + 0x0C);
			} while (eax_408 != 0x00);
			struct Eq_133031 * esp_432 = esp_318 - 4;
			esp_432->t0000.u1 = 0x00;
			esp_432->ptrFFFFFFFC = null;
			esp_432->tFFFFFFF8 = esi_412;
			esp_432->tFFFFFFF4 = esp_318;
			_dl_sort_maps(esp_432->tFFFFFFF4, esp_432->tFFFFFFF8, esp_432->ptrFFFFFFFC, esp_432->t0000);
			ui32 eax_449 = esi_412 - 0x01;
			esp_1014 = (char *) &esp_432->t0000 + 4;
			if (esi_412 != 0x00)
			{
				Eq_2 edx_467 = *((word32) esp_318 + eax_449 * 0x04);
				while (true)
				{
					struct Eq_133090 * esp_471 = esp_1014 - 4;
					esp_471->t0000.u0 = 0x00;
					esp_471->tFFFFFFFC = ebp_1007->tFFFFFFE4;
					esp_471->tFFFFFFF8 = *((word32) edx_467 + 464);
					esp_471->tFFFFFFF4 = edx_467;
					Eq_2 ebx_489[];
					ui32 esi_493;
					byte dl_1416;
					word32 ecx_1415;
					_dl_relocate_object(gs, esp_471->tFFFFFFF4, esp_471->tFFFFFFFC, esp_471->t0000, out ecx_1415, out dl_1416, out ebx_489, out ebp_1007, out esi_493, out edi_1030);
					Eq_2 esp_495 = <invalid>;
					esp_1014 = (word32) esp_495 + 16;
					if (esi_493 == ~0x00)
						break;
					edx_467 = ebx_489[esi_493];
				}
				ebx_1197 = *((byte) edi_1030.u0 + 356);
				ebp_1007->tFFFFFFB4.u0 = 0x01;
				ebp_1007->tFFFFFFBC = ebx_1197;
				if (ebx_1197 == 0x00)
					goto l08097A08;
			}
			else
			{
				ebx_1197 = *((word32) edi_1030 + 356);
				ebp_1007->tFFFFFFB4.u0 = 0x00;
				ebp_1007->tFFFFFFBC = ebx_1197;
				if (ebx_1197 == 0x00)
					goto l08097855;
			}
			ebp_1007->bFFFFFFC3 = 0x00;
			ecx_1129 = edi_1030;
			edi_1030.u0 = 0x00;
l08097771:
			do
			{
				Eq_2 eax_523 = *((word32) *((word32) ecx_1129 + 352) + edi_1030 * 0x04);
				ebp_1007->tFFFFFFE4 = eax_523;
				word32 eax_526 = (word32) *((word32) eax_523 + 408);
				byte al_533 = (byte) eax_526;
				if (((byte) eax_526 & 11) == 0x0A)
				{
					ui32 esi_550;
					Eq_2 edx_549;
					Eq_2 esi_543 = *((word32) ebp_1007->tFFFFFFE4 + 464);
					Eq_2 eax_544 = *esi_543;
					ebp_1007->tFFFFFFC8 = esi_543;
					if (eax_544 != 0x00)
					{
						Eq_2 edx_553 = (word32) ecx_1129 + 352;
						ebp_1007->tFFFFFFE0 = edx_553;
						if (eax_544 != edx_553)
						{
							ebp_1007->tFFFFFFCC = ecx_1129;
							ebp_1007->tFFFFFFC4 = ebx_1197;
							ui32 edx_558 = 0x02;
							Eq_2 ebx_564 = ebp_1007->tFFFFFFE0;
							do
							{
								esi_550 = edx_558 + 0x01;
								Eq_2 eax_569 = *((word32) esi_543 + esi_550 * 0x04);
								if (eax_569 == 0x00)
								{
									ecx_1129 = ebp_1007->tFFFFFFCC;
									edx_549 = edx_558 + 0x00;
									goto l080977DA;
								}
								edx_558 = esi_550;
							} while (eax_569 != ebx_564);
							goto l08097900;
						}
						goto l08097766;
					}
					edx_549.u0 = 0x01;
					esi_550 = 0x00;
l080977DA:
					Eq_2 eax_595 = *((word32) ebp_1007->tFFFFFFE4 + 0x01CC);
					if (eax_595 > edx_549)
					{
						ebp_1007->tFFFFFFE0 = esi_550 * 0x04;
						goto l080977F5;
					}
					Eq_2 ebx_599 = ebp_1007->tFFFFFFE4;
					ebp_1007->tFFFFFFC4 = (word32) ebx_599 + 444;
					if (eax_595 <= 0x03)
					{
						ebp_1007->tFFFFFFCC = (word32) ebx_599 + 444;
						ebp_1007->tFFFFFFB0.u0 = 0x04;
						if ((word32) ebx_599 + 444 != ebp_1007->tFFFFFFC8)
							goto l08097A60;
					}
					ebp_1007->tFFFFFFAC = ecx_1129;
					ebp_1007->tFFFFFFE0 = edx_549;
					ebp_1007->tFFFFFFB0 = eax_595 * 0x02;
					struct Eq_133313 * esp_612 = esp_1014 - 0x0C;
					esp_612->tFFFFFFFC = eax_595 << 0x03;
					word32 ebx_1421;
					word32 edx_1420;
					word32 ecx_1419;
					Eq_2 eax_631 = __libc_malloc(gs, esp_612->tFFFFFFF8, esp_612->tFFFFFFFC, out ecx_1419, out edx_1420, out ebx_1421, out ebp_1007, out esi_550, out edi_1030);
					edx_549 = ebp_1007->tFFFFFFE0;
					ecx_1129 = ebp_1007->tFFFFFFAC;
					ebp_1007->tFFFFFFCC = eax_631;
					if (eax_631 == 0x00)
					{
						Eq_2 ecx_649 = ebp_1007->tFFFFFFD4;
						esp_612->t0008 = (word32) ecx_649 - 84587;
						esp_612->dw0004 = 0x00;
						esp_612->dw0000 = (word32) ecx_649 - 106709;
						esp_612->tFFFFFFFC.u0 = 0x0C;
						word32 ebx_1427;
						word32 ecx_1425;
						word32 edx_1426;
						_dl_signal_error(gs, esp_612->tFFFFFFFC, esp_612->t0008, out ecx_1425, out edx_1426, out ebx_1427, out ebp_1007, out edi_1030);
						esp_1042 = esp_612 - 4;
						goto l08097BD0;
					}
l08097A60:
					ebp_1007->tFFFFFFA8 = ecx_1129;
					ebp_1007->tFFFFFFAC = edx_549;
					Eq_2 eax_677 = esi_550 * 0x04;
					ebp_1007->tFFFFFFE0 = eax_677;
					struct Eq_133375 * esp_673 = esp_1014 - 0x04;
					esp_673->tFFFFFFFC = eax_677;
					esp_673->tFFFFFFF8 = ebp_1007->tFFFFFFC8;
					esp_673->tFFFFFFF4 = ebp_1007->tFFFFFFCC;
					word32 edx_1423;
					word32 ecx_1422;
					memcpy(esp_673->tFFFFFFF4, esp_673->tFFFFFFF8, esp_673->tFFFFFFFC, out ecx_1422, out edx_1423);
					Eq_2 ebx_701 = ebp_1007->tFFFFFFE4;
					Eq_2 ecx_702 = ebp_1007->tFFFFFFCC;
					edx_549 = ebp_1007->tFFFFFFAC;
					Eq_2 eax_705 = *((word32) ebx_701 + 464);
					ebp_1007->tFFFFFFC8 = ecx_702;
					*((word32) ebx_701 + 464) = ecx_702;
					ecx_1129 = ebp_1007->tFFFFFFA8;
					if (ebp_1007->tFFFFFFC4 != eax_705)
					{
						ebp_1007->tFFFFFFC4 = ecx_1129;
						ebp_1007->tFFFFFFCC = edx_549;
						esp_673->tFFFFFFF4 = eax_705;
						word32 ecx_1424;
						_dl_scope_free(gs, esp_673->tFFFFFFF4, out ecx_1424);
						ecx_1129 = ebp_1007->tFFFFFFC4;
						edx_549 = ebp_1007->tFFFFFFCC;
						ebp_1007->tFFFFFFC8 = *((word32) ebx_701 + 464);
					}
					*((word32) ebp_1007->tFFFFFFE4 + 0x01CC) = ebp_1007->tFFFFFFB0;
l080977F5:
					*((word32) ebp_1007->tFFFFFFC8 + edx_549 * 0x04) = 0x00;
					Mem751[Mem744[Mem744[ebp_1007 + -28:word32] + 464:word32] + Mem744[ebp_1007 + -32:word32]:word32] = ecx_1129 + 0x0160;
					Eq_2 eax_753 = *ebp_1007->ptrFFFFFFDC;
					ebp_1007->tFFFFFFE0 = eax_753;
					if ((SLICE(eax_753, byte, 8) & 0x02) == 0x00)
						goto l08097760;
					esi_1166 = esi_550;
					goto l08097828;
				}
				esi_1166 = 0x00;
				if ((al_533 & 0x08) == 0x00)
				{
					eax_1141 = ebp_1007->tFFFFFFE4;
					if (*((word32) eax_1141 + 568) != 0x00)
					{
l080979C8:
						ebp_1007->tFFFFFFE0 = ecx_1129;
						struct Eq_133575 * esp_1150 = esp_1014 - 0x0C;
						esp_1150->tFFFFFFFC = eax_1141;
						struct Eq_133581 * ebx_1162 = _dl_add_to_slotinfo(gs, esp_1150->tFFFFFFFC, out ebp_1007, out esi_1166, out edi_1030);
						ebp_1007->bFFFFFFC3 = 0x01;
						esp_1014 = (char *) &esp_1150->tFFFFFFFC + 16;
						ecx_1129 = ebp_1007->tFFFFFFE0;
						if ((ebx_1162->b0199 & 0x04) != 0x00)
						{
							Eq_2 eax_1178 = ebp_1007->tFFFFFFBC;
							if (*((word32) ecx_1129 + 356) == eax_1178)
								eax_1178 = edi_1030;
							ebp_1007->tFFFFFFBC = eax_1178;
						}
					}
				}
				Eq_2 eax_1188 = *ebp_1007->ptrFFFFFFDC;
				ebp_1007->tFFFFFFE0 = eax_1188;
				if ((SLICE(eax_1188, byte, 8) & 0x02) != 0x00)
				{
l08097828:
					ebp_1007->tFFFFFFE0 = ecx_1129;
					struct Eq_132933 * esp_763 = esp_1014 - 0x08;
					esp_763->dwFFFFFFFC = esi_1166;
					esp_763->tFFFFFFF8 = ebp_1007->tFFFFFFE4;
					_dl_show_scope(esp_763->tFFFFFFF8, esp_763->dwFFFFFFFC);
					esp_1014 = &esp_763->dwFFFFFFFC + 3;
					ecx_1129 = ebp_1007->tFFFFFFE0;
				}
l08097760:
				ebx_1197 = *((word32) ecx_1129 + 356);
l08097766:
				edi_1030 = (word32) edi_1030 + 1;
			} while (ebx_1197 > edi_1030);
			goto l08097918;
		}
	}
	else
	{
		if ((_dl_debug_mask & 0x40) != 0x00)
		{
			word32 ecx_1428;
			word32 edx_1429;
			_dl_debug_printf(out ecx_1428, out edx_1429);
		}
		Eq_2 esp_874 = fp - 0x5C;
		if ((ebp_1007->tFFFFFFD8 & 0x0100) != 0x00 && (*((word32) eax_145 + 408) & 0x10) == 0x00)
		{
			add_to_global(eax_145, gs, out ebp_1007, out edi_1030);
			esp_874.u0 = <invalid>;
		}
		struct Eq_133618 * esp_885 = esp_874 - 0x08;
		esp_885->tFFFFFFFC = *((word32) ebp_1007->t0008 + 16);
		esp_885->tFFFFFFF8.u0 = 0x00;
		if (*((word32) _dl_debug_initialize(esp_885->tFFFFFFF8, esp_885->tFFFFFFFC) + 0x0C) == 0x00)
			return;
		Eq_2 ecx_904 = ebp_1007->tFFFFFFD4;
		esp_885->dw0004 = (word32) ecx_904 - 84184;
		esp_885->dw0000 = 0xFE;
		esp_885->tFFFFFFFC = (word32) ecx_904 - 84695;
		esp_885->tFFFFFFF8 = (word32) ecx_904 - 84304;
		word32 edx_1431;
		word32 ecx_1430;
		__assert_fail(out ecx_1430, out edx_1431);
		esp_318.u0 = <invalid>;
	}
	struct Eq_132697 * esp_928 = esp_318 - 0x08;
	esp_928->dwFFFFFFFC = 0x00;
	esp_928->tFFFFFFF8 = edi_1030;
	_dl_show_scope(esp_928->tFFFFFFF8, esp_928->dwFFFFFFFC);
	esp_318 = &esp_928->dwFFFFFFFC + 3;
	goto l0809761D;
}

// 08097C40: Register byte remove_slotinfo(Register Eq_2 eax, Register up32 ecx, Register Eq_2 edx, Stack Eq_43241 bArg04)
// Called from:
//      remove_slotinfo
//      _dl_close_worker
byte remove_slotinfo(Eq_2 eax, up32 ecx, Eq_2 edx, Eq_43241 bArg04)
{
	uint32 edx_23 = eax - ecx;
	Eq_2 esp_25 = fp - 44;
	uint32 ecx_26 = *edx;
	if (edx_23 < ecx_26)
	{
		struct Eq_133709 * edx_30 = (word32) edx + edx_23 * 0x08;
		struct Eq_133713 * ecx_31 = edx_30->ptr000C;
		if (ecx_31 != null)
		{
			if (ecx_31->t0248 != eax)
			{
				word32 ecx_260;
				word32 edx_261;
				__assert_fail(out ecx_260, out edx_261);
				esp_25.u0 = <invalid>;
				goto l08097D46;
			}
			edx_30->ptr000C = null;
			edx_30->dw0008 = _dl_tls_generation.dw0000 + 0x01;
		}
		if (_dl_tls_max_dtv_idx != eax)
			return 0x01;
		goto l08097CDE;
	}
	else
	{
		Eq_2 edx_66 = *((word32) edx + 4);
		if (edx_66 != 0x00)
		{
			if (remove_slotinfo(eax, ecx_26 + ecx, edx_66, (byte) dwArg04) != 0x00)
				return 0x01;
			eax = (word32) *edx + ecx;
l08097CDE:
			uint32 edx_132 = (word32) _dl_tls_static_nelem + 1;
			if (ecx != 0x00)
				edx_132 = 0x00;
			uint32 eax_142 = eax - ecx;
			do
			{
				if (eax_142 <= edx_132)
					return 0x00;
				--eax_142;
				Eq_2 ecx_150 = ecx - 0x01 + eax_142;
			} while (*((word32) edx + (eax_142 * 0x08 + 0x0C)) == 0x00);
			_dl_tls_max_dtv_idx = ecx_150;
			return 0x01;
		}
		if ((byte) dwArg04 == 0x00)
			goto l08097CDE;
l08097D46:
		struct Eq_133800 * esp_78 = esp_25 - 4;
		esp_78->ptr0000 = 0x080B99A4;
		esp_78->dwFFFFFFFC = 0x3B;
		esp_78->ptrFFFFFFF8 = 134977372;
		esp_78->ptrFFFFFFF4 = 0x080B9767;
		word32 ecx_267;
		word32 edx_268;
		__assert_fail(out ecx_267, out edx_268);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_43241 stackArg8 = <invalid>;
		word32 edi_266;
		word32 ebp_265;
		word32 ebx_264;
		return _dl_close_worker(edx, gs, dwArg04, stackArg8, out ebx_264, out ebp_265, out edi_266);
	}
}

// 08097D70: Register byte _dl_close_worker(Register Eq_2 esi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_43241 bArg08, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 ediOut)
// Called from:
//      _dl_open
//      remove_slotinfo
//      _dl_close
byte _dl_close_worker(Eq_2 esi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_43241 bArg08, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & ediOut)
{
	word32 eax_26 = *((word32) dwArg04 + 404);
	*((word32) dwArg04 + 404) = eax_26 - 0x01;
	struct Eq_133837 * ebp_1017 = fp - 4;
	Eq_2 esp_113 = fp - 0x8C;
	struct Eq_133844 * eax_2176 = eax_26 - 0x01;
	if (eax_26 == 0x01 && (*((word32) dwArg04 + 408) & 0x03) == 0x02)
	{
		if (dl_close_state.11755 == 0x00)
		{
			while (true)
			{
				struct Eq_136156 * eax_96 = ebp_1017->ptrFFFFFFCC;
				ebp_1017->dwFFFFFF8C = (word32) esp_113;
				eax_96->dw1B4C = 0x01;
				up32 eax_102 = ebp_1017->ptrFFFFFFA4->dw0004;
				ebp_1017->dwFFFFFFE4 = eax_102;
				Eq_2 edi_109 = esp_113 - (eax_102 + 0x0F & ~0x0FFF);
				Eq_2 ecx_110 = edi_109;
				while (esp_113 != edi_109)
				{
					esp_113 -= 0x1000;
					*((word32) esp_113 + 0x0FFC) = *((word32) esp_113 + 0x0FFC);
				}
				int32 edx_124 = eax_102 + 0x0F & ~0x0F & 0x0FFF;
				if (edx_124 != 0x00)
				{
					esp_113 -= edx_124;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_113 - 0x04)[edx_124 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_113 - 0x04)[edx_124 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_2 esp_148;
				Eq_2 edi_142 = esp_113;
				Eq_2 ebx_143 = esp_113 - (eax_102 + 0x0F & ~0x0FFF);
				ui32 edx_144 = eax_102 + 0x0F & ~0x0F;
				esp_148 = esp_113;
				esp_148 = esp_113;
				if (esp_113 != ebx_143)
				{
					do
					{
						esp_148 -= 0x1000;
						*((word32) esp_148 + 0x0FFC) = *((word32) esp_148 + 0x0FFC);
					} while (esp_148 != ebx_143);
				}
				if ((edx_144 & 0x0FFF) != 0x00)
				{
					esp_148 -= edx_144 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[(edx_144 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[(edx_144 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				ui32 eax_178 = ebp_1017->dwFFFFFFE4;
				ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) esp_148;
				ui32 edx_182 = eax_178 * 0x04 + 0x0F;
				Eq_2 ebx_1490 = esp_148 - (edx_182 & ~0x0FFF);
				while (esp_148 != ebx_1490)
				{
					esp_148 -= 0x1000;
					*((word32) esp_148 + 0x0FFC) = *((word32) esp_148 + 0x0FFC);
				}
				int32 eax_195 = edx_182 & ~0x0F & 0x0FFF;
				if (eax_195 != 0x00)
				{
					esp_148 -= eax_195;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[eax_195 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[eax_195 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_133987 eax_206 = (word32) esp_148 + 3;
				ebp_1017->dwFFFFFFC8 = eax_206 >> 0x02;
				ebp_1017->ptrFFFFFFDC = __align(eax_206, 4);
				if (ebp_1017->bFFFFFFA3 != 0x00)
				{
					struct Eq_134029 * eax_215 = ebp_1017[2];
					eax_215->dw0208 &= ~0x08;
				}
				ui32 edx_223 = 0x00;
				struct Eq_134020 * eax_224 = ebp_1017->ptrFFFFFFA4->ptr0000;
				if (eax_224 != null)
				{
					ecx_110 = ebp_1017->ptrFFFFFFDC;
					do
					{
						eax_224->dw0210 = edx_223;
						*((word32) ecx_110 + edx_223 * 0x04) = eax_224;
						eax_224 = eax_224->ptr000C;
						++edx_223;
					} while (eax_224 != null);
				}
				struct Eq_134041 * edi_1423;
				Eq_2 esp_1445;
				Eq_2 eax_1527;
				Eq_134044 edx_1537;
				Eq_2 esp_1704;
				if (ebp_1017->dwFFFFFFE4 == edx_223)
				{
					struct Eq_134099 * esp_271 = esp_148 - 0x04;
					esp_271->tFFFFFFFC = ebp_1017->dwFFFFFFE4;
					esp_271->tFFFFFFF8.u0 = 0x00;
					esp_271->tFFFFFFF4 = esp_113;
					word32 edx_2761;
					word32 ecx_2760;
					memset(esp_271->tFFFFFFF4, esp_271->tFFFFFFF8, esp_271->tFFFFFFFC, out ecx_2760, out edx_2761);
					esp_271->tFFFFFFFC = ebp_1017->dwFFFFFFE4;
					esp_271->tFFFFFFF8.u0 = 0x00;
					esp_271->tFFFFFFF4 = ebp_1017->ptrFFFFFFD8;
					word32 edx_2763;
					word32 ecx_2762;
					memset(esp_271->tFFFFFFF4, esp_271->tFFFFFFF8, esp_271->tFFFFFFFC, out ecx_2762, out edx_2763);
					Eq_134161 esi_2215 = ~0x00;
					Eq_2 esp_314 = (char *) &esp_271->tFFFFFFFC + 8;
l08097F90:
					esi_2215 = (word32) esi_2215 + 1;
					while (ebp_1017->dwFFFFFFE4 > esi_2215)
					{
						if (Mem323[Mem323[ebp_1017 + -40:word32] + esi_2215:byte] != 0x00)
							goto l08097F90;
						Eq_2 eax_329 = ebp_1017->ptrFFFFFFDC[esi_2215];
						ebp_1017->ptrFFFFFFE0 = (struct Eq_152384 *) eax_329;
						word32 eax_331 = (word32) *((word32) eax_329 + 408);
						ebp_1017->bFFFFFFD4 = (byte) eax_331;
						if (((byte) eax_331 & 0x03) != 0x02)
						{
l08097FC3:
							Eq_134269 eax_340 = ebp_1017->ptrFFFFFFD8;
							Mem343[edi_142 + esi_2215:byte] = 0x01;
							Mem344[eax_340 + esi_2215:byte] = 0x01;
							struct Eq_134279 * eax_345 = ebp_1017->ptrFFFFFFE0;
							eax_345->dw0210 = ~0x00;
							struct Eq_134287 * edx_347 = eax_345->ptr01F4;
							if (edx_347 != null)
							{
l08098068:
								struct Eq_134293 ** eax_427 = &edx_347->t0004;
								Eq_2 edx_429 = edx_347->t0004;
								if (edx_429 != 0x00)
								{
									Eq_136238 ecx_434 = ebp_1017->dwFFFFFFE4;
									do
									{
										Eq_136238 edx_437 = *((word32) edx_429 + 528);
										if (edx_437 != ~0x00)
										{
											if (edx_437 < 0x00 || ecx_434 <= edx_437)
											{
												edi_142 = ebp_1017->ptrFFFFFFCC;
												struct Eq_136287 * esp_476 = esp_314 - 4;
												esp_476->ptr0000 = (word32) edi_142 - 83532;
												esp_476->dwFFFFFFFC = 0xCF;
												esp_476->ptrFFFFFFF8 = (word32) edi_142 - 0x000148A4;
												esp_476->ptrFFFFFFF4 = (word32) edi_142 - 83856;
												word32 ecx_2813;
												word32 edx_2814;
												__assert_fail(out ecx_2813, out edx_2814);
												esp_314.u0 = <invalid>;
												goto l080980E0;
											}
											if (Mem436[edi_142 + edx_437:byte] == 0x00)
											{
												Mem449[edi_142 + edx_437:byte] = 0x01;
												Eq_134161 edx_452 = *((char *) *eax_427 + 528);
												if (edx_452 <= esi_2215)
													esi_2215 = edx_452 - 0x01;
											}
										}
										eax_427 = (struct Eq_134293 **) ((char *) eax_427 + 4);
										edx_429 = *eax_427;
									} while (edx_429 != 0x00);
								}
							}
							struct Eq_134302 * ecx_354 = ebp_1017->ptrFFFFFFE0->ptr01F8;
							if (ecx_354 != null && ecx_354->dw0000 != 0x00)
							{
								uint32 edx_362 = 0x00;
								do
								{
									struct Eq_134318 * ebx_368 = ecx_354->a0004[edx_362];
									Eq_134161 eax_369 = ebx_368->t0210;
									if (eax_369 != ~0x00)
									{
										if (eax_369 < 0x00 || ebp_1017->dwFFFFFFE4 <= eax_369)
										{
											edi_142 = ebp_1017->ptrFFFFFFCC;
											struct Eq_134442 * esp_407 = esp_314 - 4;
											esp_407->ptr0000 = (word32) edi_142 - 83532;
											esp_407->dwFFFFFFFC = 232;
											esp_407->ptrFFFFFFF8 = (word32) edi_142 - 0x000148A4;
											esp_407->ptrFFFFFFF4 = (word32) edi_142 - 83812;
											word32 ecx_2766;
											__assert_fail(out ecx_2766, out edx_347);
											esp_314.u0 = <invalid>;
											goto l08098068;
										}
										if (Mem367[edi_142 + eax_369:byte] == 0x00)
										{
											Mem381[edi_142 + eax_369:byte] = 0x01;
											Eq_134161 eax_382 = ebx_368->t0210;
											if (eax_382 <= esi_2215)
												esi_2215 = eax_382 - 0x01;
											ecx_354 = ebp_1017->ptrFFFFFFE0->ptr01F8;
										}
									}
									++edx_362;
								} while (edx_362 < ecx_354->dw0000);
							}
							goto l08097F90;
						}
l080980E0:
						struct Eq_134260 * eax_497 = ebp_1017->ptrFFFFFFE0;
						if (eax_497->dw0194 != 0x00 || (eax_497->b0208 & 0x08) != 0x00)
							goto l08097FC3;
						Eq_136255 eax_505 = eax_497->t024C;
						ebp_1017->bFFFFFFD4 = (byte) eax_505;
						if (eax_505 != 0x00 || Mem506[edi_142 + esi_2215:byte] != 0x00)
							goto l08097FC3;
						esi_2215 = (word32) esi_2215 + 1;
					}
					word32 edx_520 = ebp_1017->dwFFFFFFD0;
					word32 ebx_521 = ebp_1017->dwFFFFFFE4;
					struct Eq_134174 * esp_527 = esp_314 - 4;
					esp_527->t0000.u1 = 0x01;
					Eq_134181 eax_534 = (uint32) (int8) (edx_520 == 0x00);
					Mem545[esp_527 + -4:word32] = edi_142 + eax_534;
					esp_527->tFFFFFFF8 = ebx_521 - eax_534;
					esi = ebp_1017->ptrFFFFFFDC + ebp_1017->dwFFFFFF84 / 4;
					esp_527->tFFFFFFF4 = esi;
					_dl_sort_maps(esp_527->tFFFFFFF4, esp_527->tFFFFFFF8, esp_527->ptrFFFFFFFC, esp_527->t0000);
					Eq_2 esp_1025 = (char *) &esp_527->t0000 + 4;
					if (ebx_521 != 0x00)
					{
						esi = null[ebp_1017->dwFFFFFFC8];
						if (ebp_1017->dwFFFFFFD0 == *((word32) esi + 24))
						{
							ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) edi_142;
							ebp_1017->dwFFFFFFC8 = 0x00;
							ebp_1017->bFFFFFFD4 = 0x00;
							ebp_1017->bFFFFFFA2 = 0x00;
							ebp_1017->ptrFFFFFFE0 = (struct Eq_152384 *) (struct Eq_134399 *) ~0x00;
							ebp_1017->ptrFFFFFFBC = 0x080CFF04;
							struct Eq_104401 * edi_1008 = null;
							do
							{
								word32 eax_583 = (word32) *((word32) esi + 408);
								byte al_620 = (byte) eax_583;
								byte dl_591 = (byte) eax_583 & 0x03;
								if (Mem582[Mem582[ebp_1017 + -40:word32] + edi_1008:byte] != 0x00)
								{
									if (dl_591 != 0x02)
										goto l08098208;
									struct Eq_134479 * edx_783;
									if (*((word32) esi + 352) != 0x00)
									{
										struct Eq_134479 ** eax_796 = *((word32) esi + 464);
										ebp_1017->dwFFFFFFC0 = 0x00;
										edx_783 = (struct Eq_134479 *) *eax_796;
										ebp_1017->dwFFFFFFB8 = eax_796;
										ebx_1490.u0 = 0x01;
										if (edx_783 != null)
											goto l08098271;
										goto l080983B3;
									}
									word32 eax_748 = *((word32) esi + 500);
									ebp_1017->dwFFFFFFC0 = eax_748;
									if (eax_748 == 0x00)
									{
										struct Eq_134479 ** eax_789 = *((word32) esi + 464);
										edx_783 = (struct Eq_134479 *) *eax_789;
										ebp_1017->dwFFFFFFB8 = eax_789;
										ebx_1490.u0 = 0x01;
										if (edx_783 == null)
											goto l080983B3;
										goto l08098271;
									}
									ui32 edx_758;
									ui32 eax_759;
									struct Eq_135954 * ecx_753 = ebp_1017->dwFFFFFFC0;
									if (ecx_753->dw0004 != 0x00)
									{
										ui32 edx_760 = 0x01;
										while (true)
										{
											eax_759 = edx_760 + 0x01;
											if (ecx_753[eax_759 * 0x04 / 8] == 0x00)
												break;
											edx_760 = eax_759;
										}
										edx_758 = edx_760 * 0x04 + 0x08;
									}
									else
									{
										edx_758 = 0x08;
										eax_759 = 0x01;
									}
									*((word32) esi + 356) = eax_759;
									ui32 edx_779 = edx_758 + ebp_1017->dwFFFFFFC0;
									ebp_1017->dwFFFFFFC0 = (word32) esi + 352;
									struct Eq_134479 ** eax_781 = *((word32) esi + 464);
									*((word32) esi + 352) = edx_779;
									edx_783 = (struct Eq_134479 *) *eax_781;
									ebp_1017->dwFFFFFFB8 = eax_781;
									if (edx_783 != null)
									{
										ebx_1490.u0 = 0x02;
l08098271:
										word32 ecx_806 = ebp_1017->dwFFFFFFB8;
										ebp_1017->dwFFFFFFB4 = (word32) esi;
										ebp_1017->dwFFFFFFC4 = (word32) esi + 360;
										esi = ebp_1017->dwFFFFFFD0;
										ebp_1017->dwFFFFFFB0 = edx_783;
										struct Eq_134479 * edx_816 = ebp_1017->dwFFFFFFC4;
										ebp_1017->dwFFFFFFAC = edi_1008;
										ebp_1017->dwFFFFFFA8 = ecx_806 + 0x04;
										struct Eq_134479 * eax_813 = edx_783;
										struct Eq_134548 * ecx_814 = ecx_806 + 0x04;
										word32 edi_821 = 0x00;
										do
										{
											if (eax_813 != edx_816)
											{
												if (esi != eax_813->tFFFFFEB8)
												{
													edi_1423 = (struct Eq_134041 *) ebp_1017->ptrFFFFFFCC;
													struct Eq_135911 * esp_2119 = esp_1025 - 4;
													esp_2119->ptr0000 = (char *) edi_1423 - 83532;
													esp_2119->dwFFFFFFFC = 0x016D;
													esp_2119->ptrFFFFFFF8 = (char *) edi_1423 - 0x000148A4;
													esp_2119->ptrFFFFFFF4 = (char *) edi_1423 - 84015;
													word32 edx_2808;
													word32 ecx_2807;
													eax_1527 = __assert_fail(out ecx_2807, out edx_2808);
													esp_1445.u0 = <invalid>;
l08098BC9:
													ebp_1017->dwFFFFFFC8 = (uint32) eax_1527;
													ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) ebp_1017->bFFFFFFD4;
													goto l080984D4;
												}
												if (eax_813->dw00B0 != ~0x00)
												{
													++ecx_814;
													eax_813 = ecx_814->dwFFFFFFFC;
													edi_821 = 0x01;
													if (eax_813 != null)
														continue;
													break;
												}
											}
											++ecx_814;
											eax_813 = ecx_814->dwFFFFFFFC;
											ebx_1490 = (byte) ebx_1490.u0 + 1;
										} while (eax_813 != null);
										Eq_134586 al_862 = (byte) edi_821;
										struct Eq_134588 * edx_2290 = ebp_1017->dwFFFFFFB0;
										esi = ebp_1017->dwFFFFFFB4;
										ebp_1017->dwFFFFFFB0 = (word32) al_862;
										edi_1008 = ebp_1017->dwFFFFFFAC;
										if (al_862 != 0x00)
										{
											ebp_1017->dwFFFFFFAC = (word32) esi + 444;
											if (ebx_1490 <= 0x03)
											{
												ebp_1017->dwFFFFFFB4 = (word32) esi + 444;
												ebp_1017->dwFFFFFF9C = 0x04;
												if ((word32) esi + 444 != ebp_1017->dwFFFFFFB8)
													goto l08098310;
											}
											ui32 eax_886 = *((word32) esi + 0x01CC);
											ebp_1017->dwFFFFFF98 = edx_2290;
											ebp_1017->dwFFFFFF9C = eax_886;
											struct Eq_134625 * esp_894 = esp_1025 - 0x0C;
											esp_894->tFFFFFFFC = eax_886 << 0x02;
											word32 ecx_2767;
											word32 edx_2768;
											word32 ebx_2769;
											Eq_2 eax_912 = __libc_malloc(gs, esp_894->tFFFFFFF8, esp_894->tFFFFFFFC, out ecx_2767, out edx_2768, out ebx_2769, out ebp_1017, out esi, out edi_1008);
											edx_2290 = ebp_1017->dwFFFFFF98;
											ebp_1017->dwFFFFFFB4 = (word32) eax_912;
											if (eax_912 == 0x00)
											{
												struct Eq_134802 * edi_929 = ebp_1017->ptrFFFFFFCC;
												esp_894->t0008 = (char *) edi_929 - 84587;
												esp_894->dw0004 = 0x00;
												esp_894->ptr0000 = (char *) edi_929 - 83996;
												esp_894->tFFFFFFFC.u0 = 0x0C;
												word32 ebx_2773;
												word32 ecx_2771;
												word32 edx_2772;
												_dl_signal_error(gs, esp_894->tFFFFFFFC, esp_894->t0008, out ecx_2771, out edx_2772, out ebx_2773, out ebp_1017, out edi_1008);
												esp_1025 = esp_894 - 4;
												goto l08098810;
											}
l08098310:
											ebp_1017->dwFFFFFF94 = edi_1008;
											word32 edi_957 = ebp_1017->dwFFFFFFB4;
											ebp_1017->dwFFFFFF98 = (word32) esi;
											ui32 ecx_2288 = 0x00;
											struct Eq_134684 * ebx_960 = ebp_1017->dwFFFFFFA8;
											do
											{
												ui32 esi_962 = ecx_2288 * 0x04;
												struct Eq_134588 ** eax_1009 = edi_957 + esi_962;
												if (edx_2290 != ebp_1017->dwFFFFFFC4 && edx_2290->dw00B0 != ~0x00)
												{
													struct Eq_134588 * edx_972 = ebp_1017->dwFFFFFFC0;
													if (edx_972 != null)
													{
														ebp_1017->dwFFFFFFC0 = 0x00;
														*eax_1009 = (struct Eq_134588 **) edx_972;
														++ecx_2288;
														eax_1009 = edi_957 + 0x04 + esi_962;
													}
													++ebx_960;
													edx_2290 = ebx_960->dwFFFFFFFC;
													if (edx_2290 != null)
														continue;
													break;
												}
												*eax_1009 = (struct Eq_134588 **) edx_2290;
												++ebx_960;
												++ecx_2288;
												eax_1009 = edi_957 + 0x04 + esi_962;
												edx_2290 = ebx_960->dwFFFFFFFC;
											} while (edx_2290 != null);
											esi = ebp_1017->dwFFFFFF98;
											edi_1008 = ebp_1017->dwFFFFFF94;
											*eax_1009 = (struct Eq_134588 **) null;
											*((word32) esi + 464) = ebp_1017->dwFFFFFFB4;
											Eq_2 eax_1014 = ebp_1017->dwFFFFFFB8;
											if (ebp_1017->dwFFFFFFAC != eax_1014)
											{
												struct Eq_134767 * esp_1027 = esp_1025 - 0x0C;
												esp_1027->tFFFFFFFC = eax_1014;
												word32 ecx_2770;
												Eq_2 eax_1036 = _dl_scope_free(gs, esp_1027->tFFFFFFFC, out ecx_2770);
												byte bl_1051 = ebp_1017->bFFFFFFA2;
												esp_1025 = (char *) &esp_1027->tFFFFFFFC + 16;
												if (eax_1036 != 0x00)
													bl_1051 = 0x00;
												ebp_1017->bFFFFFFA2 = bl_1051;
											}
											else
											{
l08098810:
												ebp_1017->bFFFFFFA2 = (byte) ebp_1017->dwFFFFFFB0;
											}
											*((word32) esi + 0x01CC) = ebp_1017->dwFFFFFF9C;
											goto l080983B3;
										}
										if (ebp_1017->dwFFFFFFC0 != 0x00)
											goto l0809875E;
									}
									else
									{
l0809875E:
										*((word32) esi + 352) = 0x00;
										*((word32) esi + 356) = 0x00;
									}
l080983B3:
									struct Eq_134511 * eax_1065 = *((word32) esi + 368);
									if (eax_1065 != null && eax_1065->dw0210 != ~0x00)
										*((word32) esi + 368) = 0x00;
									struct Eq_104401 * eax_1076 = ebp_1017->ptrFFFFFFE0;
									if (eax_1076 > edi_1008)
										eax_1076 = edi_1008;
									ebp_1017->ptrFFFFFFE0 = (struct Eq_152384 *) eax_1076;
									++edi_1008;
									if (ebp_1017->dwFFFFFFE4 == edi_1008)
										goto l080983E7;
									goto l08098214;
								}
								if (dl_591 != 0x02 || (*((word32) esi + 520) & 0x08) != 0x00)
								{
									struct Eq_135987 * edi_599 = ebp_1017->ptrFFFFFFCC;
									struct Eq_135991 * esp_603 = esp_1025 - 4;
									esp_603->ptr0000 = (char *) edi_599 - 83532;
									esp_603->dwFFFFFFFC = 0x010B;
									esp_603->ptrFFFFFFF8 = (char *) edi_599 - 0x000148A4;
									esp_603->ptrFFFFFFF4 = (char *) edi_599 - 83768;
									word32 ecx_2809;
									word32 edx_2810;
									__assert_fail(out ecx_2809, out edx_2810);
									esp_1025.u0 = <invalid>;
									break;
								}
								if ((al_620 & 0x08) != 0x00)
								{
									if ((ebp_1017->ptrFFFFFFBC->b0000 & 0x02) != 0x00)
									{
										struct Eq_136072 * eax_628 = ebp_1017->ptrFFFFFFCC;
										struct Eq_136076 * esp_629 = esp_1025 - 0x04;
										esp_629->dwFFFFFFFC = ebp_1017->dwFFFFFFD0;
										esp_629->tFFFFFFF8 = *((word32) esi + 4);
										esp_629->ptrFFFFFFF4 = (char *) eax_628 - 84041;
										word32 ecx_2811;
										word32 edx_2812;
										_dl_debug_printf(out ecx_2811, out edx_2812);
									}
									struct Eq_136102 * eax_652 = *((word32) esi + 0x0088);
									if (eax_652 != null)
									{
										uint32 eax_659 = *((word32) *((word32) esi + 144) + 4);
										word32 ecx_660 = Mem651[esi + 0x00:word32] + Mem651[eax_652 + 0x04:word32];
										if (eax_659 >> 0x02 != 0x00)
										{
											ebp_1017->bFFFFFFD4 = (byte) esi;
											word32 esi_667 = ecx_660 - 0x04 + (eax_659 >>u 0x02) * 0x04;
											while (true)
											{
												word32 ecx_678;
												(*esi_667)();
												Eq_136115 edx_680 = esi_667 - 0x04;
												if (ecx_660 == esi_667)
													break;
												esi_667 = edx_680;
											}
											esi = ebp_1017->bFFFFFFD4;
										}
									}
									struct Eq_136127 * edx_687 = *((word32) esi + 84);
									if (edx_687 != null)
									{
										word32 eax_692 = Mem686[esi + 0x00:word32] + Mem686[edx_687 + 0x04:word32];
										word32 ecx_706;
										eax_692();
									}
									eax_583 = (word32) *((word32) esi + 408);
								}
								*((word32) esi + 0x0199) |= 0x20;
								struct Eq_104401 * eax_722 = ebp_1017->ptrFFFFFFE0;
								ebp_1017->dwFFFFFFC8 = ebp_1017->dwFFFFFFC8 - ~0x00 - (word32) (((byte) eax_583 & 0x10) < 0x01);
								ebp_1017->bFFFFFFD4 = 0x01;
								if (eax_722 > edi_1008)
									eax_722 = edi_1008;
								ebp_1017->ptrFFFFFFE0 = (struct Eq_152384 *) eax_722;
l08098208:
								++edi_1008;
								if (ebp_1017->dwFFFFFFE4 == edi_1008)
								{
l080983E7:
									Eq_134874 edi_1138 = ebp_1017->ptrFFFFFFD8;
									if (ebp_1017->bFFFFFFD4 == 0x00)
										goto l080986F0;
									struct Eq_134883 * esp_1141 = esp_1025 - 0x08;
									esp_1141->tFFFFFFFC = ebp_1017->dwFFFFFFD0;
									esp_1141->tFFFFFFF8.u0 = 0x00;
									Eq_2 eax_1148 = _dl_debug_initialize(esp_1141->tFFFFFFF8, esp_1141->tFFFFFFFC);
									*((word32) eax_1148 + 0x0C) = 0x02;
									ebp_1017->ptrFFFFFFBC = (struct Eq_152381 *) eax_1148;
									_dl_debug_state();
									esi = eax_1148;
									if (ebp_1017->dwFFFFFFC8 != 0x00)
									{
										Eq_2 eax_1171;
										struct Eq_134920 * eax_1165 = ebp_1017->ptrFFFFFFA4->ptr0008;
										Eq_2 ecx_1166 = eax_1165->t0004;
										ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) eax_1165;
										if (ecx_1166 != 0x00)
										{
											struct Eq_135405 * ebx_1174[] = eax_1165->ptr0000;
											if (((ebx_1174 - 0x04)[ecx_1166]->b0199 & 0x20) != 0x00)
											{
												eax_1171 = ecx_1166;
												do
												{
													--eax_1171;
													if (eax_1171 == 0x00)
														goto l080989FE;
												} while (((ebx_1174 - 0x04)[eax_1171]->b0199 & 0x20) != 0x00);
												esi = eax_1171;
											}
											else
												esi = ecx_1166;
											eax_1171 = esi;
											if (ecx_1166 != (word32) esi + ebp_1017->dwFFFFFFC8)
											{
												eax_1171.u0 = 0x00;
												Eq_2 ecx_1204 = 0x00;
												do
												{
													struct Eq_135405 * edx_1210 = ebx_1174[ecx_1204];
													if ((edx_1210->b0199 & 0x20) == 0x00)
													{
														if (eax_1171 != ecx_1204)
															ebx_1174[eax_1171] = edx_1210;
														eax_1171 = (byte) eax_1171.u0 + 1;
													}
													ecx_1204 = (word32) ecx_1204 + 1;
												} while (ecx_1204 != esi);
											}
										}
										else
											eax_1171.u0 = 0x00;
l080989FE:
										ebp_1017->ptrFFFFFFD8->t0004 = eax_1171;
									}
									if (gs->t000C != 0x00)
									{
										if (ebp_1017->dwFFFFFFC8 == 0x00 && ebp_1017->bFFFFFFA2 == 0x00)
										{
											Eq_2 eax_1276 = _dl_scope_free_list;
											if (eax_1276 == 0x00)
												goto l08098432;
											esi = *eax_1276;
											if (esi != 0x00)
												goto l08098A73;
										}
										else
										{
l08098A73:
											word32 ecx_1343;
											_dl_wait_lookup_done();
											esi = _dl_scope_free_list;
											if (esi != 0x00)
											{
												Eq_135024 eax_1349 = *esi;
												while (eax_1349 != 0x00)
												{
													Eq_135024 eax_1354 = eax_1349 - 0x01;
													*esi = eax_1354;
													struct Eq_135036 * esp_1356 = esp_1025 - 0x0C;
													esp_1356->tFFFFFFFC = *((word32) esi + (eax_1354 * 0x04 + 4));
													word32 ecx_2774;
													word32 edx_2775;
													free(gs, esp_1356->tFFFFFFF8, esp_1356->tFFFFFFFC, out ecx_2774, out edx_2775);
													eax_1349.u2 = *esi;
												}
											}
										}
									}
l08098432:
									ebp_1017->dwFFFFFFC0 = 0x00;
									Mem1407 = Mem1383;
									esp_1445 = esp_1025;
									if (ebp_1017->dwFFFFFFE4 <= ebp_1017->ptrFFFFFFE0)
									{
l08098B5E:
										goto l080986D0;
									}
									else
									{
										struct Eq_134964 * eax_1411 = ebp_1017->ptrFFFFFFE0;
										esi = ebp_1017->ptrFFFFFFDC;
										ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) 0x00;
										ebp_1017->dwFFFFFFC8 = 0x00;
										ebp_1017->dwFFFFFFC4 = 0x00;
										ebp_1017->ptrFFFFFFE0 = (word32) esi + eax_1411 * 0x04;
										ebp_1017->dwFFFFFFE4 = (word32) edi_1138 + ebp_1017->dwFFFFFFE4;
										edi_1423 = edi_1138 + eax_1411;
										goto l080984A8;
									}
								}
l08098214:
								esi = ebp_1017->ptrFFFFFFDC[edi_1008];
							} while (ebp_1017->dwFFFFFFD0 == *((word32) esi + 24));
						}
						struct Eq_134352 * edi_1103 = ebp_1017->ptrFFFFFFCC;
						struct Eq_134356 * esp_1118 = esp_1025 - 4;
						esp_1118->ptr0000 = (char *) edi_1103 - 83532;
						esp_1118->dwFFFFFFFC = 262;
						esp_1118->ptrFFFFFFF8 = (char *) edi_1103 - 0x000148A4;
						esp_1118->ptrFFFFFFF4 = (char *) edi_1103 - 84060;
						word32 ecx_2764;
						word32 edx_2765;
						__assert_fail(out ecx_2764, out edx_2765);
l08098B19:
						eax_2176 = (struct Eq_133844 *) ebp_1017->ptrFFFFFFCC;
						eax_2176->dw1B4C = 0x00;
l08097ED6:
						struct Eq_133915 * esp_2180 = ebp_1017 - 0x0C;
						ptr32 edi_2186 = esp_2180->ptr0008;
						ptr32 ebp_2188 = esp_2180->ptr000C;
						ebxOut = esp_2180->ptr0000;
						ebpOut = ebp_2188;
						ediOut = edi_2186;
						return (byte) eax_2176;
					}
				}
				else
				{
					word32 edi_249 = ebp_1017->ptrFFFFFFCC;
					struct Eq_134071 * esp_254 = esp_148 - 4;
					esp_254->dw0000 = edi_249 + ~0x0001464B;
					esp_254->dwFFFFFFFC = 0xA5;
					esp_254->dwFFFFFFF8 = edi_249 + ~0x000148A3;
					esp_254->dwFFFFFFF4 = edi_249 + 4294883221;
					word32 ecx_2758;
					word32 edx_2759;
					__assert_fail(out ecx_2758, out edx_2759);
					esp_1704.u0 = <invalid>;
					do
					{
						struct Eq_135302 * edi_1714 = ebp_1017->ptrFFFFFFCC;
						struct Eq_135306 * esp_1717 = esp_1704 - 4;
						esp_1717->ptr0000 = (char *) edi_1714 - 83532;
						esp_1717->dwFFFFFFFC = 0x02B2;
						esp_1717->ptrFFFFFFF8 = (char *) edi_1714 - 0x000148A4;
						esp_1717->ptrFFFFFFF4 = (char *) edi_1714 - 83943;
						word32 edx_2780;
						word32 ecx_2779;
						__assert_fail(out ecx_2779, out edx_2780);
						esp_1704.u0 = <invalid>;
						do
						{
							edi_1423 = (struct Eq_134041 *) ebp_1017->ptrFFFFFFCC;
							struct Eq_135269 * esp_1739 = esp_1704 - 4;
							esp_1739->ptr0000 = (char *) edi_1423 - 83532;
							esp_1739->dwFFFFFFFC = 0x02B1;
							esp_1739->ptrFFFFFFF8 = (char *) edi_1423 - 0x000148A4;
							esp_1739->ptrFFFFFFF4 = (char *) edi_1423 - 83962;
							word32 ecx_2778;
							__assert_fail(out ecx_2778, out edx_1537);
							esp_1445.u0 = <invalid>;
l08098C3E:
							Eq_135808 al_1768 = ebp_1017->bFFFFFFD4;
							*ecx_110.u0 = edx_1537;
							ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) al_1768;
l080984D4:
							if (ebp_1017->bFFFFFFA3 != 0x00)
							{
								if (ebp_1017->dwFFFFFFC0 != 0x00)
								{
									*((word32) esp_1445 - 16) = ebp_1017->dwFFFFFF88;
									word32 ecx_1600;
									fn00000000();
									ebx_1490 = ebp_1017->ptrFFFFFFCC;
								}
								struct Eq_135192 * eax_1607 = ebp_1017->ptrFFFFFFA4->ptr0028;
								if (eax_1607 != null)
								{
									struct Eq_135239 * ecx_1611 = ebp_1017->ptrFFFFFFA4;
									ui32 edx_1612 = ecx_1611->dw002C;
									if (edx_1612 != 0x00)
									{
										struct Eq_135192 * edx_1617 = eax_1607 + (edx_1612 << 0x04) / 16;
										do
										{
											ebx_1490 = eax_1607->dw0004;
											if (ebx_1490 != 0x00 && esi == eax_1607->dw000C)
											{
												eax_1607->dw0004 = 0x00;
												eax_1607->dw0000 = 0x00;
												--ecx_1611->dw0030;
											}
											++eax_1607;
										} while (eax_1607 != edx_1617);
									}
								}
							}
							struct Eq_135165 * esp_1678 = esp_1445 - 0x0C;
							esp_1678->tFFFFFFFC = esi;
							ebx_1490 = _dl_unmap(ebx_1490, gs, esp_1678->tFFFFFFFC);
							ecx_110 = ebp_1017->dwFFFFFFD0;
							esp_1704 = (char *) &esp_1678->tFFFFFFFC + 16;
						} while (ecx_110 != 0x00);
						struct Eq_135296 * edx_1708 = *((word32) esi + 16);
					} while (edx_1708 == null);
					struct Eq_135334 * eax_1770 = *((word32) esi + 0x0C);
					struct Eq_135338 * ebx_1771 = ebp_1017->dwFFFFFF90;
					edx_1708->ptr000C = eax_1770;
					--ebx_1771->dw0004;
					if (eax_1770 != null)
						eax_1770->ptr0010 = edx_1708;
					esp_1678->tFFFFFFFC = *((word32) esi + 372);
					word32 ecx_2781;
					word32 edx_2782;
					free(gs, esp_1678->tFFFFFFF8, esp_1678->tFFFFFFFC, out ecx_2781, out edx_2782);
					Eq_2 eax_1797 = *((word32) esi + 428);
					if (eax_1797 != ~0x00)
					{
						esp_1678->tFFFFFFFC = eax_1797;
						word32 ecx_2785;
						word32 edx_2786;
						free(gs, esp_1678->tFFFFFFF8, esp_1678->tFFFFFFFC, out ecx_2785, out edx_2786);
					}
					struct Eq_135409 * esp_1816 = esp_1445 - 0x0C;
					esp_1816->tFFFFFFFC = *((word32) esi + 504);
					word32 edx_2784;
					word32 ecx_2783;
					free(gs, esp_1816->tFFFFFFF8, esp_1816->tFFFFFFFC, out ecx_2783, out edx_2784);
					if ((_dl_debug_mask & 0x40) != 0x00)
					{
						struct Eq_135474 * eax_1839 = ebp_1017->ptrFFFFFFCC;
						esp_1816->dw0004 = (word32) *((word32) esi + 24);
						esp_1816->t0000 = *((word32) esi + 4);
						esp_1816->tFFFFFFFC = (char *) eax_1839 - 83700;
						word32 ecx_2787;
						word32 edx_2788;
						_dl_debug_printf(out ecx_2787, out edx_2788);
					}
					struct Eq_135501 * esp_1862 = esp_1445 - 0x0C;
					esp_1862->tFFFFFFFC = *((word32) esi + 4);
					word32 ecx_2789;
					word32 edx_2790;
					free(gs, esp_1862->tFFFFFFF8, esp_1862->tFFFFFFFC, out ecx_2789, out edx_2790);
					Eq_2 eax_1879 = *((word32) esi + 28);
					ebp_1017->ptrFFFFFFDC = (Eq_135024 (*)[]) esi;
					do
					{
						Eq_2 esi_1886 = *((word32) eax_1879 + 4);
						if (*((word32) eax_1879 + 8) == 0x00)
						{
							struct Eq_135550 * esp_1895 = esp_1445 - 0x0C;
							esp_1895->tFFFFFFFC = eax_1879;
							word32 ecx_2791;
							word32 edx_2792;
							free(gs, esp_1895->tFFFFFFF8, esp_1895->tFFFFFFFC, out ecx_2791, out edx_2792);
							eax_1879 = esi_1886;
							if (esi_1886 == 0x00)
								break;
							continue;
						}
						eax_1879 = esi_1886;
					} while (esi_1886 != 0x00);
					esi = ebp_1017->ptrFFFFFFDC;
					struct Eq_135573 * esp_1918 = esp_1445 - 0x0C;
					esp_1918->tFFFFFFFC = *((word32) esi + 500);
					word32 ecx_2793;
					word32 edx_2794;
					free(gs, esp_1918->tFFFFFFF8, esp_1918->tFFFFFFFC, out ecx_2793, out edx_2794);
					Eq_2 eax_1932 = *((word32) esi + 464);
					if (eax_1932 != (word32) esi + 444)
					{
						esp_1918->tFFFFFFFC = eax_1932;
						word32 edx_2796;
						word32 ecx_2795;
						free(gs, esp_1918->tFFFFFFF8, esp_1918->tFFFFFFFC, out ecx_2795, out edx_2796);
					}
					if (*((word32) esi + 408) < 0x00)
					{
						struct Eq_135621 * esp_1956 = esp_1445 - 0x0C;
						esp_1956->tFFFFFFFC = *((word32) esi + 340);
						word32 edx_2798;
						word32 ecx_2797;
						free(gs, esp_1956->tFFFFFFF8, esp_1956->tFFFFFFFC, out ecx_2797, out edx_2798);
					}
					Eq_2 eax_1975 = *((word32) esi + 412);
					if (eax_1975 != ~0x00)
					{
						struct Eq_135654 * esp_1979 = esp_1445 - 0x0C;
						esp_1979->tFFFFFFFC = eax_1975;
						word32 ecx_2799;
						word32 edx_2800;
						free(gs, esp_1979->tFFFFFFF8, esp_1979->tFFFFFFFC, out ecx_2799, out edx_2800);
					}
					Eq_2 eax_1997 = *((word32) esi + 492);
					if (eax_1997 != ~0x00)
					{
						struct Eq_135742 * esp_2001 = esp_1445 - 0x0C;
						esp_2001->tFFFFFFFC = eax_1997;
						word32 edx_2806;
						word32 ecx_2805;
						free(gs, esp_2001->tFFFFFFF8, esp_2001->tFFFFFFFC, out ecx_2805, out edx_2806);
					}
					struct Eq_135708 * esp_2018 = esp_1445 - 0x0C;
					esp_2018->tFFFFFFFC = esi;
					word32 edx_2804;
					word32 ecx_2803;
					free(gs, esp_2018->tFFFFFFF8, esp_2018->tFFFFFFFC, out ecx_2803, out edx_2804);
					ebp_1017->ptrFFFFFFE0 = (struct Eq_152384 *) ((char *) &ebp_1017->ptrFFFFFFE0->t0000 + 4);
					++edi_1423;
					esp_1445 = (char *) &esp_2018->tFFFFFFFC + 16;
					if (ebp_1017->dwFFFFFFE4 != edi_1423)
					{
l080984A8:
						do
						{
							if (edi_1423->b0000 == 0x00)
							{
								esi = ebp_1017->ptrFFFFFFE0->t0000;
								word32 ecx_1437 = (word32) *((word32) esi + 408);
								bcu8 cl_1500 = (byte) ecx_1437;
								ui24 ecx_24_8_1504 = SLICE(ecx_1437, word24, 8);
								if (((byte) ecx_1437 & 0x03) != 0x02)
								{
									struct Eq_135119 * edi_1443 = ebp_1017->ptrFFFFFFCC;
									struct Eq_135123 * esp_1446 = esp_1445 - 4;
									esp_1446->ptr0000 = (char *) edi_1443 - 83532;
									esp_1446->dwFFFFFFFC = 0x0225;
									esp_1446->ptrFFFFFFF8 = (char *) edi_1443 - 0x000148A4;
									esp_1446->ptrFFFFFFF4 = (char *) edi_1443 - 83988;
									word32 edx_2777;
									word32 ecx_2776;
									__assert_fail(out ecx_2776, out edx_2777);
									goto l08098B5E;
								}
								ebx_1490 = *((word32) esi + 568);
								if (ebx_1490 == 0x00)
									goto l080984D4;
								if (_dl_tls_dtv_slotinfo_list != 0x00)
								{
									Eq_2 eax_1503 = *((word32) esi + 584);
									*((byte) esp_1445.u0 - 16) = SEQ(ecx_24_8_1504, cl_1500 >> 0x03) & 0x01;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_43241 stackArg4 = <invalid>;
									if (remove_slotinfo(eax_1503, 0x00, edx, stackArg4) == 0x00)
										_dl_tls_max_dtv_idx = _dl_tls_static_nelem;
								}
								ebx_1490 = (word32) ebp_1017->bFFFFFFD4;
								eax_1527 = *((word32) esi + 0x0244);
								ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) (byte) ebx_1490;
								if (eax_1527 <= 0x00)
									goto l080984D4;
								ebx_1490 = ebp_1017->dwFFFFFFC4;
								edx_1537 = eax_1527 - *((word32) esi + 568);
								if (ebx_1490 == 0x00 || eax_1527 == ebx_1490)
								{
									if (ebp_1017->dwFFFFFFC8 == 0x00)
									{
l080989AF:
										ebp_1017->dwFFFFFFC8 = (uint32) eax_1527;
									}
									Eq_135844 al_1569 = ebp_1017->bFFFFFFD4;
									ebp_1017->dwFFFFFFC4 = (word32) edx_1537;
									ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) al_1569;
									goto l080984D4;
								}
								else
								{
									if (ebp_1017->dwFFFFFFC8 == edx_1537)
										goto l08098BC9;
									ecx_110.u0 = 0x080CFCA0;
									ebx_1490 = _dl_tls_static_used;
									if (ebx_1490 != ebp_1017->dwFFFFFFC8)
									{
										if (eax_1527 == ebx_1490)
											goto l08098C3E;
										ebx_1490 = (word32) ebp_1017->bFFFFFFD4;
										ebp_1017->ptrFFFFFFD8 = (struct Eq_152383 *) (byte) ebx_1490;
										if (eax_1527 > ebp_1017->dwFFFFFFC8)
										{
											ebp_1017->dwFFFFFFC8 = (uint32) eax_1527;
											ebp_1017->dwFFFFFFC4 = (word32) edx_1537;
										}
										goto l080984D4;
									}
									ebx_1490 = ebp_1017->dwFFFFFFC4;
									_dl_tls_static_used = ebx_1490;
									goto l080989AF;
								}
							}
							ebp_1017->ptrFFFFFFE0 = (struct Eq_152384 *) ((char *) &ebp_1017->ptrFFFFFFE0->t0000 + 4);
							++edi_1423;
						} while (ebp_1017->dwFFFFFFE4 != edi_1423);
					}
					Mem2085 = Mem2051;
					if (ebp_1017->ptrFFFFFFD8 != 0x00)
					{
						Eq_123392 v50_2090 = _dl_tls_generation.dw0000 + 0x01;
						_dl_tls_generation.dw0000 = (up32) v50_2090;
						if (v50_2090 == 0x00)
						{
							struct Eq_135863 * esp_2096 = esp_1445 - 0x08;
							esp_2096->ptrFFFFFFFC = (char *) ebp_1017->ptrFFFFFFCC - 83660;
							esp_2096->tFFFFFFF8.u0 = 0x02;
							_dl_dprintf();
							esp_2096->tFFFFFFF8.u0 = 0x7F;
							_exit(gs, esp_2096->tFFFFFFF8);
						}
						if (_dl_tls_static_used == ebp_1017->dwFFFFFFC8)
							_dl_tls_static_used = ebp_1017->dwFFFFFFC4;
					}
l080986D0:
					if (ebp_1017->ptrFFFFFFA4->ptr0000 == null && _dl_nns - 0x01 == ebp_1017->dwFFFFFFD0)
						_dl_nns = ebp_1017->dwFFFFFFD0;
					ebp_1017->ptrFFFFFFBC->dw000C = 0x00;
					_dl_debug_state();
				}
l080986F0:
				if (ebp_1017->ptrFFFFFFCC->dw1B4C != 0x02)
					goto l08098B19;
				esp_113 = ebp_1017->dwFFFFFF8C;
			}
		}
		dl_close_state.11755 = 0x02;
	}
	if ((_dl_debug_mask & 0x40) != 0x00)
	{
		word32 ecx_2756;
		word32 edx_2757;
		eax_2176 = (uint32) _dl_debug_printf(out ecx_2756, out edx_2757);
	}
	goto l08097ED6;
}

// 08098C60: void _dl_close(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      do_dlclose
//      dlclose_doit
void _dl_close(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Mem41 = Mem20;
	if ((*((word32) dwArg04 + 520) & 0x08) != 0x00)
		return;
	if (*((word32) dwArg04 + 404) == 0x00)
	{
		Eq_2 v15_75 = *((word32) dwArg04 + 4);
		word32 edx_225;
		word32 ebx_226;
		word32 ecx_224;
		word32 ebp_227;
		word32 edi_228;
		_dl_signal_error(gs, 0x00, 0x080B982E, out ecx_224, out edx_225, out ebx_226, out ebp_227, out edi_228);
		_dl_sort_maps(v15_75, 0x00, &g_u80B982E, bLoc0C);
	}
	else
	{
		word32 ebx_109;
		word32 edi_223;
		word32 ebp_222;
		_dl_close_worker(dwArg04, gs, dwArg04, 0x00, out ebx_109, out ebp_222, out edi_223);
	}
}

// 08098D10: Register (ptr32 Eq_13333) _dl_sort_maps(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_113724) dwArg0C, Stack Eq_133034 bArg10)
// Called from:
//      dl_open_worker
//      _dl_close_worker
//      _dl_close
//      _dl_map_object_deps
struct Eq_13333 * _dl_sort_maps(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_113724 * dwArg0C, Eq_133034 bArg10)
{
	Eq_2 esp_19 = fp - 0x4C;
	if (dwArg08 > 0x01)
	{
		ui32 eax_30 = dwArg08 * 0x02 + 0x0F;
		Eq_2 esi_33 = fp - 0x4C - (eax_30 & ~0x0FFF);
		if (fp - 0x4C != esi_33)
		{
			do
			{
				esp_19 -= 0x1000;
				*((word32) esp_19 + 0x0FFC) = *((word32) esp_19 + 0x0FFC);
			} while (esp_19 != esi_33);
		}
		int32 ebx_49 = eax_30 & ~0x0F & 0x0FFF;
		if (ebx_49 != 0x00)
		{
			esp_19 -= ebx_49;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_19 - 0x04)[ebx_49 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_19 - 0x04)[ebx_49 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_136413 * esp_62 = esp_19 - 0x04;
		esp_62->tFFFFFFFC = dwArg08 * 0x02;
		esp_62->tFFFFFFF8.u0 = 0x00;
		esp_62->tFFFFFFF4 = esp_19;
		word32 edx_669;
		memset(esp_62->tFFFFFFF4, esp_62->tFFFFFFF8, esp_62->tFFFFFFFC, out ecx, out edx_669);
		Eq_2 dwLoc20_385 = 0x00;
		word32 * eax_95 = dwArg04 - 0x04 + dwArg08 * 0x04;
		Eq_2 dwLoc28_386 = 0x01;
		while (true)
		{
l08098DB0:
			Eq_2 edx_267;
			struct Eq_136605 * eax_102 = (word32) esp_19 + dwLoc20_385 * 0x02;
			word16 si_106 = eax_102->w0000 + 0x01;
			eax_102->w0000 = si_106;
			Eq_2 eax_110 = (word32) dwArg04 + dwLoc20_385 * 0x04;
			struct Eq_13333 * ebx_112 = *eax_110;
			if (bArg10 == 0x00 || ebx_112->ptr0014 == ebx_112 && ebx_112->dw0210 != ~0x00)
			{
				Eq_2 esi_123 = dwArg08 - 0x01;
				if (dwLoc20_385 < dwArg08 - 0x01)
				{
					word32 * edx_126 = eax_95;
					do
					{
						struct Eq_13333 * edi_129 = *edx_126;
						word32 * eax_130 = edi_129->ptr01F4;
						if (eax_130 != null)
						{
							do
							{
								ecx = *eax_130;
								if (ecx == null)
									goto l08098DFF;
								++eax_130;
							} while (ecx != ebx_112);
l08098E45:
							struct Eq_136565 * esp_204 = esp_19 - 0x04;
							uint32 edi_205 = esi_123 - dwLoc20_385;
							esp_204->tFFFFFFFC = edi_205 * 0x04;
							esp_204->tFFFFFFF8 = (word32) dwArg04 + 4 + dwLoc20_385 * 0x04;
							esp_204->tFFFFFFF4 = eax_110;
							word32 edx_671;
							memmove(esp_204->tFFFFFFF4, esp_204->tFFFFFFF8, esp_204->tFFFFFFFC, out edx_671);
							*edx_126 = ebx_112;
							if (dwArg0C != null)
							{
								word32 eax_236 = dwLoc20_385 + dwArg0C;
								byte bl_258 = *eax_236;
								*((word32) esp_19 - 8) = edi_205;
								Mem244[esp_19 + -0x0C:word32] = dwLoc28_386 + dwArg0C;
								*((word32) esp_19 - 16) = eax_236;
								word32 edx_672;
								memmove(*((word32) esp_19 - 16), *((word32) esp_19 - 0x0C), *((word32) esp_19 - 8), out edx_672);
								Mem259[dwArg0C + esi_123:byte] = bl_258;
							}
							edx_267 = (word32) esp_19 + dwLoc28_386 * 0x02;
							if ((word32) eax_102->w0002 > dwArg08 - dwLoc20_385)
								goto l08098EB9;
							struct Eq_136668 * esp_274 = esp_19 - 0x04;
							esp_274->tFFFFFFFC = edi_205 * 0x02;
							esp_274->tFFFFFFF8 = edx_267;
							esp_274->tFFFFFFF4 = esp_19 - 0x02 + dwLoc28_386 * 0x02;
							word32 edx_673;
							ecx = memmove(esp_274->tFFFFFFF4, esp_274->tFFFFFFF8, esp_274->tFFFFFFFC, out edx_673);
							((word32) esp_19 + esi_123 * 0x02)->u5 = si_106;
							goto l08098DB0;
						}
l08098DFF:
						if (bArg10 != 0x00)
						{
							struct Eq_136480 * eax_152 = edi_129->ptr01F8;
							if (eax_152 == null)
								goto l08098E09;
							ecx = eax_152->ptr0000;
							do
							{
								if (ecx == null)
									goto l08098E09;
								--ecx;
							} while (eax_152->a0004[ecx].ptr0000 != ebx_112);
							word32 * eax_167 = ebx_112->ptr01F4;
							if (eax_167 == null)
								goto l08098E45;
							do
							{
								ecx = *eax_167;
								if (ecx == null)
									goto l08098E45;
								++eax_167;
							} while (edi_129 != ecx);
						}
l08098E09:
						--esi_123;
						edx_126 -= 0x04;
					} while (dwLoc20_385 != esi_123);
				}
			}
			if (dwArg08 == dwLoc28_386)
				break;
			edx_267 = (word32) esp_19 + dwLoc28_386 * 0x02;
l08098EB9:
			struct Eq_136504 * esp_335 = esp_19 - 0x04;
			esp_335->tFFFFFFFC = (dwArg08 - dwLoc28_386) * 0x02;
			esp_335->tFFFFFFF8.u0 = 0x00;
			esp_335->tFFFFFFF4 = edx_267;
			word32 edx_670;
			memset(esp_335->tFFFFFFF4, esp_335->tFFFFFFF8, esp_335->tFFFFFFFC, out ecx, out edx_670);
			dwLoc20_385 = dwLoc28_386;
			dwLoc28_386 = (word32) dwLoc28_386 + 1;
		}
	}
	return ecx;
}

// 08098F80: Register (ptr32 Eq_125011) _dl_tlsdesc_resolve_early_return_p(Register (ptr32 Eq_125011) eax, Register (ptr32 code) edx, Register out (ptr32 code) ecxOut)
// Called from:
//      _dl_tlsdesc_resolve_abs_plus_addend_fixup
//      _dl_tlsdesc_resolve_rel_fixup
//      _dl_tlsdesc_resolve_rela_fixup
struct Eq_125011 * _dl_tlsdesc_resolve_early_return_p(struct Eq_125011 * eax, <anonymous> * edx, <anonymous> & ecxOut)
{
	<anonymous> * ecx_100 = eax->ptr0000;
	if (ecx_100 == edx)
	{
		ecx_100 = eax->ptr0000;
		if (edx == ecx_100)
		{
			eax->ptr0000 = &g_t8093420;
			ecxOut = ecx_100;
			return null;
		}
	}
	ecxOut = ecx_100;
	return (struct Eq_125011 *) 0x01;
}

// 08099000: void _dl_tlsdesc_resolve_abs_plus_addend_fixup(Register (ptr32 Eq_125011) eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_abs_plus_addend
void _dl_tlsdesc_resolve_abs_plus_addend_fixup(struct Eq_125011 * eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 edi_23 = eax->t0004;
	struct Eq_125011 * esi_16 = eax;
	ptr32 ebx_21 = 0x080CE000;
	word32 ecx_29;
	if (_dl_tlsdesc_resolve_early_return_p(eax, dwArg00 - ecx, out ecx_29) == 0x00)
	{
		Eq_2 eax_38 = *((word32) edx + 0x0244);
		if (eax_38 <= 0x00)
		{
			struct Eq_136744 * ebp_48;
			word32 edx_52;
			_dl_allocate_static_tls(gs, edx, out edx_52, out ebx_21, out ebp_48, out esi_16, out edi_23);
			eax_38 = ebp_48->t0244;
		}
		esi_16->t0004 = edi_23 - eax_38;
		esi_16->ptr0000 = ebx_21 + ~0x0003AC5F;
	}
}

// subject_text_0005.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08099090: void _dl_tlsdesc_resolve_rel_fixup(Register (ptr32 Eq_125011) eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_rel
void _dl_tlsdesc_resolve_rel_fixup(struct Eq_125011 * eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 ebp_23 = eax->t0004;
	Eq_2 edi_107 = edx;
	struct Eq_125011 * esi_129 = eax;
	ptr32 ebx_125 = 0x080CE000;
	word32 ecx_294;
	Eq_2 eax_28 = _dl_tlsdesc_resolve_early_return_p(eax, dwArg00 - ecx, out ecx_294);
	if (eax_28 != 0x00)
		return;
	uint32 ebp_39 = *((word32) ebp_23 + 4);
	struct Eq_136785 * edx_46 = (word32) *((word32) *((word32) edx + 56) + 4) + ((ebp_39 >> 0x08) << 0x04);
	word32 ecx_40 = *((word32) *((word32) edx + 52) + 4);
	if (edx_46->b000C >> 0x04 != 0x00 && (edx_46->b000D & 0x03) == 0x00)
	{
		Eq_2 ecx_56 = *((word32) edx + 232);
		if (ecx_56 != 0x00)
		{
			ecx_56 = (word32) *((word32) edx + 372) + (((word32) (*((word32) (*((word32) ecx_56 + 4)) + (ebp_39 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) ecx_56 + 4) == null)
				ecx_56 = eax_28;
		}
		word32 ecx_98;
		word32 edx_295;
		edi_107 = _dl_lookup_symbol_x(gs, ecx_40 + edx_46->dw0000, edx, fp - 0x20, *((word32) edx + 464), ecx_56, 0x01, 0x01, 0x00, out ecx_98, out edx_295);
		if (edx_46 == null)
		{
			eax->t0004.u0 = 0x00;
			eax->ptr0000 = &g_t80933B0;
			return;
		}
	}
	struct Eq_136811 * esp_117 = fp - 0x3C;
	Eq_2 edx_113 = *((word32) edi_107 + 0x0244);
	if (edx_113 <= 0x00)
	{
		struct Eq_136883 * edi_127;
		word32 ebp_297;
		word32 edx_296;
		_dl_allocate_static_tls(gs, edi_107, out edx_296, out ebx_125, out ebp_297, out esi_129, out edi_127);
		Eq_2 esp_130 = <invalid>;
		edx_113 = edi_127->t0244;
		esp_117 = (word32) esp_130 + 16;
	}
	esi_129->t0004 = esp_117->ptr001C->dw0004 - edx_113;
	esi_129->ptr0000 = ebx_125 + ~0x0003AC5F;
}

// 080991D0: void _dl_tlsdesc_resolve_rela_fixup(Register (ptr32 Eq_125011) eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_rela
void _dl_tlsdesc_resolve_rela_fixup(struct Eq_125011 * eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 ebp_126 = eax->t0004;
	Eq_2 edi_109 = edx;
	struct Eq_125011 * esi_131 = eax;
	ptr32 ebx_127 = 0x080CE000;
	word32 ecx_295;
	Eq_2 eax_28 = _dl_tlsdesc_resolve_early_return_p(eax, dwArg00 - ecx, out ecx_295);
	if (eax_28 != 0x00)
		return;
	uint32 ecx_40 = *((word32) ebp_126 + 4);
	struct Eq_136934 * edx_48 = (word32) *((word32) *((word32) edx + 56) + 4) + ((ecx_40 >> 0x08) << 0x04);
	word32 eax_41 = *((word32) *((word32) edx + 52) + 4);
	if (edx_48->b000C >> 0x04 != 0x00 && (edx_48->b000D & 0x03) == 0x00)
	{
		Eq_2 ecx_58 = *((word32) edx + 232);
		if (ecx_58 != 0x00)
		{
			ecx_58 = (word32) *((word32) edx + 372) + (((word32) (*((word32) (*((word32) ecx_58 + 4)) + (ecx_40 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) ecx_58 + 4) == null)
				ecx_58 = eax_28;
		}
		word32 ecx_100;
		word32 edx_296;
		edi_109 = _dl_lookup_symbol_x(gs, eax_41 + edx_48->dw0000, edx, fp - 0x20, *((word32) edx + 464), ecx_58, 0x01, 0x01, 0x00, out ecx_100, out edx_296);
		if (edx_48 == null)
		{
			eax->t0004 = *((word32) ebp_126 + 8);
			eax->ptr0000 = &g_t80933B0;
			return;
		}
	}
	struct Eq_136960 * esp_119 = fp - 0x3C;
	Eq_2 edx_115 = *((word32) edi_109 + 0x0244);
	if (edx_115 <= 0x00)
	{
		struct Eq_137034 * edi_129;
		word32 edx_297;
		_dl_allocate_static_tls(gs, edi_109, out edx_297, out ebx_127, out ebp_126, out esi_131, out edi_129);
		Eq_2 esp_132 = <invalid>;
		edx_115 = edi_129->t0244;
		esp_119 = (word32) esp_132 + 16;
	}
	esi_131->t0004 = (word32) *((word32) ebp_126 + 8) + (esp_119->ptr001C)->dw0004 - edx_115;
	esi_131->ptr0000 = ebx_127 + ~0x0003AC5F;
}

// 08099320: void _dl_tlsdesc_resolve_hold_fixup(Register (ptr32 (ptr32 code)) eax, Register word32 ecx, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_hold
void _dl_tlsdesc_resolve_hold_fixup(<anonymous> ** eax, word32 ecx, word32 dwArg00)
{
	*eax == dwArg00 - ecx;
}

// 08099390: Register Eq_2 _dl_unmap(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_close_worker
Eq_2 _dl_unmap(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_7 = *((word32) dwArg04 + 432);
	Eq_2 ebx_18;
	word32 ecx_34;
	word32 edx_35;
	__munmap(ebx, gs, edx_7, *((word32) dwArg04 + 436) - edx_7, out ecx_34, out edx_35, out ebx_18);
	return ebx_18;
}

// 080993C0: void _dl_cet_open_check(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dl_open_worker
void _dl_cet_open_check(struct Eq_9 * gs, Eq_2 dwArg04)
{
	uint32 eax_22 = g_dw80CFF20;
	ui32 eax_26 = eax_22 >> 0x03 & 0x07;
	struct Eq_137097 * esp_174 = fp - 0x6C;
	ui32 * edi_19 = &g_dw80CFF1C;
	byte cl_111 = (int8) ((eax_22 & 0x07) == 0x02) & (int8) (eax_26 == 0x02);
	if (cl_111 != 0x00)
		return;
	uint32 eax_39 = g_dw80CFF1C;
	if (((byte) eax_39 & 0x03) == 0x00)
		return;
	word32 edx_383;
	ui32 ecx_384;
	Eq_2 ebp_186;
	word32 edi_278;
	Eq_2 eax_280;
	Eq_2 eax_218;
	ui32 edx_48 = eax_39 >> 0x01 & 0x01;
	ui32 eax_58 = SEQ(SLICE(eax_39 >> 0x01, word24, 8), (int8) ((eax_22 & 0x07) != 0x01)) & (eax_39 & 0x01);
	byte dl_54 = (byte) edx_48;
	byte al_61 = (byte) eax_58;
	word24 ebx_24_8_74 = SLICE(eax_58, word24, 8);
	byte bl_70 = (byte) eax_58 | (int8) (eax_26 != 0x01) & (byte) edx_48;
	if (bl_70 != 0x00)
	{
		uint32 eax_126 = *((word32) dwArg04 + 356);
		ebp_186.u0 = 0x00;
l08099460:
		for (--eax_126; eax_126 != ~0x00; --eax_126)
		{
			ebp_186 = *((word32) *((word32) dwArg04 + 500) + eax_126 * 0x04);
			if ((*((byte) ebp_186.u0 + 408) & 0x08) != 0x00)
				goto l08099460;
			byte dl_103 = (int8) ((eax_22 & 0x07) != 0x02) & al_61;
			if (dl_103 != 0x00 && (*((byte) ebp_186.u0 + 410) & 0x04) == 0x00)
			{
				dwLoc64 = eax_126;
				if (cl_111 == 0x00)
				{
					dwLoc48 = eax_126;
					cl_111 = dl_103;
				}
			}
			if (eax_26 == 0x02)
				goto l08099460;
		}
		if (cl_111 != 0x00)
		{
			Eq_2 dwLoc50_602;
			Eq_2 eax_148 = g_t80CFF68;
			if (eax_148 == 0x00)
			{
				word32 eax_199;
				word32 edx_201;
				gs->ptr0010();
				if (eax_199 != 0x00)
					goto l08099700;
				g_t80CFF68 = dwLoc2C;
				g_t80CFF6C = dwLoc24;
				dwLoc50_602 = dwLoc2C;
			}
			else
			{
				esp_174 = fp - 0x6C;
				word32 edx_849;
				word32 ecx_848;
				if (mprotect(gs, eax_148, g_t80CFF6C, 0x03, out ecx_848, out edx_849) < 0x00)
					goto l08099762;
				dwLoc50_602 = g_t80CFF68;
			}
			esp_174 = fp - 0x6C;
			if (dwLoc64 <= dwLoc48)
			{
				do
				{
					struct Eq_137276 * esi_231 = *((word32) esp_174[0x0A] + esp_174[2] * 0x04);
					eax_218 = esp_174[7];
					esp_174[8] = (struct Eq_137097) esi_231;
					if ((esi_231->b0198 & 0x08) == 0x00 && (esi_231->b019A & 0x04) == 0x00)
					{
						word32 ecx_240 = (word32) esi_231->w015C;
						struct Eq_137422 * edx_241 = esi_231->ptr0154;
						esp_174[6] = (struct Eq_137097) ecx_240;
						if (ecx_240 != 0x00)
						{
							esp_174[1] = (struct Eq_137097) 0x00;
							struct Eq_137422 * ebp_246 = edx_241;
							do
							{
								if (ebp_246->dw0000 == 0x01 && (ebp_246->b0018 & 0x01) != 0x00)
								{
									uint32 esi_257 = esp_174[0x0E];
									uint32 eax_265 = (uint32) ((uint64) ((word32) *esp_174[8] + ebp_246->dw0008) /u esi_257);
									uint32 eax_272 = (uint32) ((uint64) (esi_257 - 0x01 + ebp_246->dw0014) /u esi_257);
									uint32 edx_273 = eax_265 + eax_272;
									esp_174[0x0D] = (struct Eq_137097) edx_273;
									if (esp_174[0x0C] < edx_273 >> 0x03)
									{
										edi_278 = (word32) esp_174[5];
										ebp_186 = esp_174[8];
										eax_280 = edi_278 + 4294883888;
										goto l0809970A;
									}
									uint32 esi_286 = 0x20 - (eax_265 & 0x1F);
									ui32 * ebx_287 = (word32) esp_174[7] + (eax_265 >> 0x05) * 0x04;
									ui32 edx_290 = ~0x00 << ((byte) eax_265 & 0x1F);
									if (eax_272 >= esi_286)
									{
										do
										{
											*ebx_287 |= edx_290;
											eax_272 -= esi_286;
											esi_286 = 0x20;
											++ebx_287;
											edx_290 = ~0x00;
										} while (eax_272 > 0x1F);
									}
									if (eax_272 != 0x00)
										*ebx_287 |= edx_290 & ~0x00 >> (byte) (-esp_174[0x0D]);
								}
								esp_174[1] = (struct Eq_137097) ((word32) esp_174[1] + 1);
								++ebp_246;
							} while (esp_174[6] != esp_174[1]);
l08099720:
							struct Eq_137639 * eax_339 = esp_174[0x0F];
							eax_218 = eax_339->t0000;
							esp_174[0x0C] = (struct Eq_137097) eax_339->dw0004;
							esp_174[7] = (struct Eq_137097) eax_218;
						}
					}
					esp_174[2] = (struct Eq_137097) ((word32) esp_174[2] + 1);
				} while (esp_174[2] <= esp_174[9]);
				ebp_186 = esp_174[8];
			}
			else
				eax_218 = dwLoc50_602;
			struct Eq_137604 * esp_353 = esp_174 - 0x04;
			esp_353->tFFFFFFFC.u0 = 0x01;
			esp_353->tFFFFFFF8 = esp_353->t0034;
			esp_353->tFFFFFFF4 = eax_218;
			esp_174 = (struct Eq_137097 *) ((char *) &esp_353->tFFFFFFFC + 8);
			word32 ecx_850;
			word32 edx_851;
			if (mprotect(gs, esp_353->tFFFFFFF4, esp_353->tFFFFFFF8, esp_353->tFFFFFFFC, out ecx_850, out edx_851) < 0x00)
			{
l08099762:
				edi_278 = (word32) esp_174[5];
				eax_280 = edi_278 + ~0x0001463A;
				goto l0809970A;
			}
		}
		edx_383 = (word32) esp_174->b002D;
		ecx_384 = (word32) esp_174->b002E ^ edx_383;
	}
	else
	{
		ecx_384 = (word32) dl_54;
		ebp_186.u0 = 0x00;
		edx_383 = SEQ(ebx_24_8_74, bl_70);
	}
	byte dl_407 = (byte) edx_383;
	byte cl_395 = (byte) ecx_384;
	if ((esp_174->b002F & (int8) (esp_174[4] == 0x01)) == 0x00 && cl_395 == 0x00)
		return;
	if (esp_174[3] != 0x03)
	{
		if (esp_174->b002E == dl_407)
			return;
		edi_278 = (word32) esp_174[5];
		eax_280 = edi_278 + ~0x0001461C;
l0809970A:
		struct Eq_137236 * esp_524 = esp_174 - 4;
		esp_524->t0000 = eax_280;
		esp_524->dwFFFFFFFC = edi_278 + ~0x0001A0D4;
		esp_524->dwFFFFFFF8 = (word32) *((byte) ebp_186.u0 + 4);
		esp_524->tFFFFFFF4.u0 = 22;
		word32 edx_841;
		word32 ebx_842;
		word32 ebp_843;
		word32 ecx_840;
		_dl_signal_error(gs, esp_524->tFFFFFFF4, esp_524->t0000, out ecx_840, out edx_841, out ebx_842, out ebp_843, out edi_19);
		esp_174 = esp_524 - 0x0C;
		goto l08099720;
	}
	word32 eax_449;
	word32 ecx_450;
	word32 edx_451;
	gs->ptr0010();
	byte dl_494 = (byte) edx_451;
	if (eax_449 == 0x00)
	{
		ui32 eax_487 = (word32) esp_174[11];
		*edi_19 &= ~ecx_450;
		if (dl_494 != 0x00)
			eax_487 |= 0x02;
		gs->dw0020 = eax_487;
		return;
	}
	word32 edi_456 = esp_174[5];
	struct Eq_137320 * esp_461 = esp_174 - 4;
	esp_461->t0000 = edi_456 + ~0x00014601;
	esp_461->dwFFFFFFFC = edi_456 + ~0x0001A0D4;
	esp_461->dwFFFFFFF8 = (word32) *((word32) ebp_186 + 4);
	esp_461->tFFFFFFF4 = -eax_449;
	word32 edx_845;
	word32 ebx_846;
	word32 edi_847;
	word32 ecx_844;
	_dl_signal_error(gs, esp_461->tFFFFFFF4, esp_461->t0000, out ecx_844, out edx_845, out ebx_846, out ebp_186, out edi_847);
	esp_174 = esp_461 - 0x0C;
l08099700:
	edi_278 = (word32) esp_174[5];
	eax_280 = edi_278 + ~0x000145EF;
	goto l0809970A;
}

// 080997C0: void _dl_addr(Stack Eq_2 dwArg04, Stack (ptr32 Eq_130698) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack (ptr32 Eq_2) dwArg10)
// Called from:
//      __dladdr
//      __dladdr1
void _dl_addr(Eq_2 dwArg04, struct Eq_130698 * dwArg08, union Eq_2 * dwArg0C, union Eq_2 * dwArg10)
{
	Eq_2 eax_46 = _dl_find_dso_for_object(dwArg04);
	if (eax_46 != 0x00)
	{
		Eq_2 edx_57 = *((word32) eax_46 + 4);
		Eq_2 ecx_59 = *((word32) eax_46 + 432);
		dwArg08->t0000 = edx_57;
		dwArg08->t0004 = ecx_59;
		if (*edx_57 == 0x00 && (*((word32) eax_46 + 408) & 0x03) == 0x00)
			dwArg08->t0000 = **(union Eq_2 **) 135060900;
		Eq_2 esi_78 = *((word32) *((word32) eax_46 + 56) + 4);
		Eq_2 ebp_164 = *((word32) eax_46 + 336);
		Eq_2 edx_105 = esi_78;
		Eq_2 esi_82 = *((word32) *((word32) eax_46 + 52) + 4);
		up32 esi_85 = *((word32) *((word32) eax_46 + 72) + 4);
		if (ebp_164 != 0x00)
		{
			Eq_111344 edx_197 = *((word32) eax_46 + 380);
			if (edx_197 != 0x00)
			{
				union Eq_112718 * esi_204 = *((word32) eax_46 + 396);
				Eq_2 dwLoc30_502 = 0x00;
				union Eq_112718 * ebx_209 = (char *) esi_204 + edx_197 * 0x04;
				do
				{
					ui32 edx_213 = *esi_204;
					if (edx_213 != 0x00)
					{
						struct Eq_137761 * ecx_224 = (word32) *((word32) eax_46 + 400) + edx_213 * 0x04;
						Eq_2 edx_226 = (word32) esi_78 + (edx_213 << 0x04);
						do
						{
							word16 bx_231 = *((word32) edx_226 + 0x0E);
							if (bx_231 == 0x00)
							{
								if (*((word32) edx_226 + 4) != 0x00)
								{
l080998B7:
									if ((*((word32) edx_226 + 0x0C) & 0x0F) == 0x06)
										goto l080998F8;
									up32 ebp_249 = *((word32) edx_226 + 4);
									Eq_2 edi_254 = (word32) *eax_46 + ebp_249;
									if (dwArg04 < edi_254)
										goto l080998F8;
									up32 ebx_263;
									if (bx_231 != 0x00)
									{
										ebx_263 = (up32) *((word32) edx_226 + 8);
										if (ebx_263 != 0x00)
											goto l08099A59;
										if (dwArg04 != edi_254)
											goto l080998F8;
										goto l08099A65;
									}
									if (dwArg04 != edi_254)
									{
										ebx_263 = (up32) *((word32) edx_226 + 8);
l08099A59:
										if (dwArg04 < (word32) edi_254 + ebx_263)
											goto l08099A65;
									}
									else
									{
l08099A65:
										if (dwLoc30_502 == 0x00 || ebp_249 > *((word32) dwLoc30_502 + 4))
										{
											Eq_2 eax_294 = dwLoc30_502;
											if (esi_85 > *edx_226)
												eax_294 = edx_226;
											dwLoc30_502 = eax_294;
										}
									}
								}
l080998F8:
								++ecx_224;
								edx_226 = (word32) edx_226 + 16;
								if ((ecx_224->bFFFFFFFC & 0x01) == 0x00)
									continue;
								break;
							}
							if (bx_231 != ~0x0E)
								goto l080998B7;
							++ecx_224;
							edx_226 = (word32) edx_226 + 16;
						} while ((ecx_224->bFFFFFFFC & 0x01) == 0x00);
						esi_204 = (union Eq_112718 *) ((char *) esi_204 + 4);
						if (ebx_209 == esi_204)
							break;
						continue;
					}
					esi_204 = (union Eq_112718 *) ((char *) esi_204 + 4);
				} while (ebx_209 != esi_204);
				ebp_164 = dwLoc30_502;
			}
			else
				ebp_164.u0 = 0x00;
		}
		else
		{
			struct Eq_137718 * ecx_90 = *((word32) eax_46 + 48);
			Eq_2 edi_102 = esi_82;
			if (ecx_90 != null)
				edi_102 = (word32) esi_78 + ((ecx_90->ptr0004)->dw0004 << 0x04);
			if (esi_78 < edi_102)
			{
				do
				{
					word32 ebx_107 = (word32) *((word32) edx_105 + 0x0C);
					if ((byte) ebx_107 >> 0x04 <= 0x02 && (byte) ebx_107 >> 0x04 >= 0x01 && (((word32) (*((word32) edx_105 + 0x0D)) & 0x03) > 0x02 && ((byte) ebx_107 & 0x0F) != 0x06))
					{
						up32 ecx_133;
						up32 esi_140;
						Eq_2 ebx_136;
						word16 cx_127 = *((word32) edx_105 + 0x0E);
						if (cx_127 == 0x00)
						{
							ecx_133 = (up32) *((word32) edx_105 + 4);
							if (ecx_133 == 0x00)
								goto l08099A30;
							ebx_136 = (word32) *eax_46 + ecx_133;
							if (dwArg04 < ebx_136)
								goto l08099A30;
							if (dwArg04 == ebx_136)
								goto l08099A1A;
							esi_140 = (up32) *((word32) edx_105 + 8);
							goto l08099A12;
						}
						if (cx_127 == ~0x0E)
							goto l08099A30;
						ecx_133 = (up32) *((word32) edx_105 + 4);
						ebx_136 = (word32) *eax_46 + ecx_133;
						if (dwArg04 < ebx_136)
							goto l08099A30;
						esi_140 = (up32) *((word32) edx_105 + 8);
						if (esi_140 == 0x00)
						{
							if (dwArg04 == ebx_136)
								goto l08099A1A;
						}
						else
						{
l08099A12:
							if (dwArg04 < (word32) ebx_136 + esi_140)
							{
l08099A1A:
								if (ebp_164 == 0x00 || *((byte) ebp_164.u0 + 4) < ecx_133)
								{
									if (esi_85 > *edx_105)
										ebp_164 = edx_105;
								}
							}
						}
					}
l08099A30:
					edx_105 = (word32) edx_105 + 16;
				} while (edx_105 < edi_102);
			}
		}
		if (dwArg0C != null)
			*dwArg0C = (union Eq_2 *) eax_46;
		if (dwArg10 != null)
			*dwArg10 = (union Eq_2 *) ebp_164;
		if (ebp_164 != 0x00)
		{
			Eq_2 eax_389;
			Mem387[dwArg08 + 0x08:word32] = esi_82 + Mem378[ebp_164 + 0x00:word32];
			if (*((byte) ebp_164.u0 + 0x0E) != ~0x0E)
				eax_389 = *eax_46;
			else
				eax_389.u0 = 0x00;
			Mem402[dwArg08 + 0x0C:word32] = eax_389 + Mem387[ebp_164 + 0x04:word32];
		}
		else
		{
			dwArg08->dw0008 = 0x00;
			dwArg08->dw000C = 0x00;
		}
	}
}

// 08099B20: Register word32 _dl_addr_inside_object(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _dl_find_dso_for_object
word32 _dl_addr_inside_object(Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 edx_12 = (word32) *((word32) dwArg04 + 348);
	up32 esi_13 = dwArg08 - *dwArg04;
	do
	{
		--edx_12;
		if (edx_12 == ~0x00)
			return 0x00;
		struct Eq_137999 * eax_32 = (word32) *((word32) dwArg04 + 340) + (edx_12 << 0x05);
	} while (eax_32->dw0000 != 0x01 || esi_13 - eax_32->dw0008 >= eax_32->dw0014);
	return 0x01;
}

// 08099B80: Register uint32 fn08099B80(Register uint32 eax, Stack word32 dwArg00)
// Called from:
//      __mpn_add_n
uint32 fn08099B80(uint32 eax, word32 dwArg00)
{
	return eax + dwArg00;
}

// 08099B90: Register word32 __mpn_add_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out (ptr32 (arr Eq_2)) ebxOut, Register out (ptr32 word32) esiOut, Register out (ptr32 word32) ediOut)
// Called from:
//      __mpn_divrem
//      __mpn_mul
//      __mpn_impn_mul_n_basecase
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n_basecase
//      __mpn_impn_sqr_n
word32 __mpn_add_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 (& ebxOut, word32 & esiOut, word32 & ediOut)
{
	Eq_2 edi_10 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	Eq_2 edx_12 = dwArg0C;
	uint32 ecx_18 = dwArg10 >> 0x03;
	uint32 eax_19 = -dwArg10;
	if ((eax_19 & 0x07) == 0x00)
	{
		do
		{
			word32 eax_29 = Mem25[esi_11 + 0x00:word32] + Mem25[edx_12 + 0x00:word32];
			*edi_10 = eax_29;
			word32 eax_35 = Mem32[esi_11 + 0x04:word32] + Mem32[edx_12 + 0x04:word32] + CONVERT(eax_29 <u 0x00, bool, word32);
			*((word32) edi_10 + 4) = eax_35;
			word32 eax_40 = Mem37[esi_11 + 0x08:word32] + Mem37[edx_12 + 0x08:word32] + CONVERT(eax_35 <u 0x00, bool, word32);
			*((word32) edi_10 + 8) = eax_40;
			word32 eax_45 = Mem42[esi_11 + 0x0C:word32] + Mem42[edx_12 + 0x0C:word32] + CONVERT(eax_40 <u 0x00, bool, word32);
			*((word32) edi_10 + 0x0C) = eax_45;
			word32 eax_50 = Mem47[esi_11 + 0x10:word32] + Mem47[edx_12 + 0x10:word32] + CONVERT(eax_45 <u 0x00, bool, word32);
			*((word32) edi_10 + 16) = eax_50;
			word32 eax_55 = Mem52[esi_11 + 0x14:word32] + Mem52[edx_12 + 0x14:word32] + CONVERT(eax_50 <u 0x00, bool, word32);
			*((word32) edi_10 + 20) = eax_55;
			word32 eax_60 = Mem57[esi_11 + 0x18:word32] + Mem57[edx_12 + 0x18:word32] + CONVERT(eax_55 <u 0x00, bool, word32);
			*((word32) edi_10 + 24) = eax_60;
			word32 eax_65 = Mem62[esi_11 + 0x1C:word32] + Mem62[edx_12 + 0x1C:word32] + CONVERT(eax_60 <u 0x00, bool, word32);
			*((word32) edi_10 + 28) = eax_65;
			edi_10 = (word32) edi_10 + 32;
			esi_11 = (word32) esi_11 + 32;
			edx_12 = (word32) edx_12 + 32;
			--ecx_18;
		} while (ecx_18 != 0x00);
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return (word32) (eax_65 < 0x00);
	}
	else
	{
		uint32 eax_88 = (eax_19 & 0x07) << 0x02;
		Eq_2 ebx_94[] = (eax_88 >> 0x02) * 0x04 + ~0x03;
		word32 eax_105;
		ebx_94[fn08099B80((eax_88 >> 0x02) + 0x02 + (eax_88 >> 0x02) * 0x08, dwLoc10) / 4]();
		ebxOut = ebx_94;
		esiOut = dwArg08 - eax_88;
		ediOut = dwArg04 - eax_88;
		return eax_105;
	}
}

// 08099C50: Register word32 __mpn_addmul_1(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack uint32 dwArg10)
// Called from:
//      __mpn_mul
//      __mpn_impn_mul_n_basecase
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n_basecase
//      __mpn_impn_sqr_n
word32 __mpn_addmul_1(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, uint32 dwArg10)
{
	up32 edi_20[] = (word32) dwArg04 + dwArg0C * 0x04;
	uint32 esi_21[] = (word32) dwArg08 + dwArg0C * 0x04;
	ui32 ecx_22 = -dwArg0C;
	word32 ebp_23 = 0x00;
	do
	{
		uint64 edx_eax_32 = dwArg10 *64 esi_21[ecx_22];
		up32 eax_35 = (word32) edx_eax_32 + ebp_23;
		up32 v14_41 = edi_20[ecx_22] + eax_35;
		edi_20[ecx_22] = v14_41;
		word32 edx_45 = SLICE(edx_eax_32, word32, 32) + (word32) (eax_35 < 0x00) + (word32) (v14_41 < 0x00);
		ebp_23 = edx_45;
		++ecx_22;
	} while (ecx_22 != 0x00);
	return edx_45;
}

// 08099CA0: void dlopen_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_138242) dwArg04)
void dlopen_doit(struct Eq_9 * gs, struct Eq_138242 * dwArg04)
{
	ui32 edx_14 = dwArg04->dw0004;
	if ((edx_14 & ~0x4000110F) != 0x00)
	{
		word32 edx_161;
		dcgettext(out edx_161);
		word32 edx_163;
		word32 ecx_162;
		word32 ebx_164;
		word32 ebp_165;
		word32 edi_166;
		_dl_signal_error(gs, 0x00, 0x080B1B5C, out ecx_162, out edx_163, out ebx_164, out ebp_165, out edi_166);
		__dlopen(gs, 0x00);
	}
	else
	{
		Eq_2 ecx_100 = dwArg04->t0000;
		if (ecx_100 == 0x00)
			ecx_100.u0 = 134955513;
		dwArg04->dw0008 = _dl_open(gs, ecx_100, edx_14 | 0x80000000, dwArg04->dw000C, 0x00, __libc_argc, __libc_argv, environ);
	}
}

// 08099D30: void __dlopen(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dlopen_doit
void __dlopen(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2175 ecx_9 = gs->t0014;
	if (_dlerror_run(gs, 0x08099CA0, fp - 0x20) == 0x00)
	{
		__libc_register_dl_open_hook();
		__libc_register_dlfcn_hook();
	}
	if ((ecx_9 ^ gs->t0014) == 0x00)
		return;
	word32 edx_140;
	word32 ecx_139;
	__stack_chk_fail(out ecx_139, out edx_140);
	dlclose_doit(gs, dwArg04);
}

// 08099DC0: void dlclose_doit(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __dlopen
void dlclose_doit(struct Eq_9 * gs, Eq_2 dwArg04)
{
	_dl_close(gs, dwArg04);
}

// 08099DD0: void __dlclose(Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04)
void __dlclose(struct Eq_9 * gs, ptr32 dwArg04)
{
	_dlerror_run(gs, 0x08099DC0, dwArg04);
}

// 08099E00: void dlsym_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_138338) dwArg04)
void dlsym_doit(struct Eq_9 * gs, struct Eq_138338 * dwArg04)
{
	struct Eq_138339 * esi_31;
	esi_31->dw000C = _dl_sym(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->t0008, out esi_31);
}

// 08099E30: void __dlsym(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_138362) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __dlsym(struct Eq_9 * gs, struct Eq_138362 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	Eq_2175 eax_14 = gs->t0014;
	_dlerror_run(gs, 0x08099E00, fp - 0x20) != 0x00;
	if ((eax_14 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_181;
	word32 edx_182;
	__stack_chk_fail(out ecx_181, out edx_182);
	dlvsym_doit(gs, dwArg04);
}

// 08099EE0: void dlvsym_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_138362) dwArg04)
// Called from:
//      __dlsym
void dlvsym_doit(struct Eq_9 * gs, struct Eq_138362 * dwArg04)
{
	dwArg04->dw0010 = _dl_vsym(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->t0008, dwArg04->t000C);
}

// 08099F20: void __dlvsym(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 word32) dwArg08, Stack ptr32 dwArg0C, Stack word32 dwArg10)
void __dlvsym(struct Eq_9 * gs, word32 dwArg04, word32 * dwArg08, ptr32 dwArg0C, word32 dwArg10)
{
	Eq_2175 eax_14 = gs->t0014;
	_dlerror_run(gs, 0x08099EE0, fp - 0x24) != 0x00;
	if ((eax_14 ^ gs->t0014) == 0x00)
		return;
	word32 ecx_187;
	word32 edx_188;
	__stack_chk_fail(out ecx_187, out edx_188);
	__setitimer(gs, dwArg04, dwArg08, dwArg0C);
}

// 08099FE0: Register (ptr32 Eq_224) __setitimer(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 word32) dwArg08, Stack ptr32 dwArg0C)
// Called from:
//      profil
//      __dlvsym
struct Eq_224 * __setitimer(struct Eq_9 * gs, word32 dwArg04, word32 * dwArg08, ptr32 dwArg0C)
{
	struct Eq_224 * eax_14;
	gs->ptr0010();
	if (eax_14 < (struct Eq_224 *) ~0x0FFE)
		return eax_14;
	word32 edx_43;
	return __syscall_error(eax_14, gs, out edx_43);
}

// 0809A010: Register (ptr32 Eq_2) _dl_build_local_scope(Register (ptr32 Eq_2) eax, Register Eq_2 edx)
// Called from:
//      _dl_build_local_scope
//      _dl_map_object_deps
union Eq_2 * _dl_build_local_scope(union Eq_2 * eax, Eq_2 edx)
{
	*eax = (union Eq_2 *) edx;
	*((word32) edx + 408) = *((word32) edx + 408) & ~0x60 | 0x20;
	struct Eq_138469 * edx_12 = *((word32) edx + 500);
	if (edx_12 == null)
		return (union Eq_2 *) 0x01;
	union Eq_2 * esi_24 = (char *) eax + 4;
	union Eq_2 * eax_25 = (union Eq_2 *) 0x01;
	word32 * ebx_29 = &edx_12->t0004;
	Eq_2 edx_30 = edx_12->t0004;
	if (edx_30 != 0x00)
	{
		do
		{
			if ((*((word32) edx_30 + 408) & 0x60) == 0x00)
				esi_24 = (union Eq_2 *) ((char *) esi_24 + _dl_build_local_scope(esi_24, edx_30) * 0x04);
			++ebx_29;
			edx_30 = *ebx_29;
		} while (edx_30 != 0x00);
		eax_25 = esi_24 - eax >> 0x02;
	}
	return eax_25;
}

// 0809A080: void openaux(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_138515) dwArg04)
void openaux(Eq_2 edi, struct Eq_9 * gs, struct Eq_138515 * dwArg04)
{
	Eq_2 edx_9 = dwArg04->t0000;
	byte al_21 = *((word32) edx_9 + 408) & 0x03;
	Eq_2 v7_11 = *((word32) edx_9 + 24);
	ui32 v8_14 = dwArg04->dw0008;
	Eq_2 ecx_24 = (word32) al_21;
	Eq_2 eax_25 = 0x01;
	if (al_21 != 0x00)
		eax_25 = ecx_24;
	struct Eq_138540 * ebx_45;
	word32 ebp_75;
	ebx_45->t0014 = _dl_map_object(edi, gs, edx_9, dwArg04->t0010, eax_25, v8_14, v7_11, out ebx_45, out ebp_75);
}

// 0809A0C0: Register word32 _dl_map_object_deps(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack ui32 dwArg0C, Register out (ptr32 Eq_132522) ebpOut, Register out ptr32 ediOut)
// Called from:
//      dl_open_worker
word32 _dl_map_object_deps(struct Eq_9 * gs, Eq_2 dwArg08, ui32 dwArg0C, struct Eq_132522 & ebpOut, ptr32 & ediOut)
{
	__align(fp);
	ui32 edx_36 = dwArg0C * 0x0C + 0x33;
	struct Eq_138561 * ebp_1054 = fp - 8;
	Eq_2 esp_1069 = fp - 0x04B0;
	Eq_2 eax_1247 = dwArg08;
	Eq_2 edi_42 = fp - 0x04B0 - (edx_36 & ~0x0FFF);
	if (fp - 0x04B0 != edi_42)
	{
		do
		{
			esp_1069 -= 0x1000;
			*((word32) esp_1069 + 0x0FFC) = *((word32) esp_1069 + 0x0FFC);
		} while (esp_1069 != edi_42);
	}
	Eq_2 ecx_102 = edx_36 & ~0x0F & 0x0FFF;
	if (ecx_102 != 0x00)
	{
l0809AD78:
		esp_1069 -= ecx_102;
		Mem1275[esp_1069 - 0x04 + ecx_102:word32] = Mem1272[esp_1069 - 0x04 + ecx_102:word32];
		goto l0809A14E;
	}
l0809A14E:
	ecx_102 = ebp_1054->ptrFFFFFB8C;
	word32 ebx_68 = (word32) *((word32) ecx_102 + 408);
	Eq_138608 edx_66 = (word32) esp_1069 + 0x0F;
	(edx_66 & ~0x0F)->t0004 = ecx_102;
	*(edx_66 & ~0x0F) = 0x00;
	ebp_1054->ptrFFFFFB9C = edx_66 & ~0x0F;
	(edx_66 & ~0x0F)->dw0008 = (edx_66 & ~0x0F) + 0x0C;
	ebp_1054->tFFFFFB98.u0 = (byte) ebx_68;
	ui32 ebx_80 = ebp_1054->ptrFFFFFBA0;
	*((word32) ecx_102 + 408) = (byte) ebx_68 & ~0x60 | 0x20;
	if (ebx_80 != 0x00)
	{
		ecx_102 = eax_1247;
		struct Eq_138666 * eax_100 = (edx_66 & ~0x0F) + 0x18;
		Eq_2 esi_95 = (word32) eax_1247 + ebx_80 * 0x04;
		do
		{
			struct Eq_138674 * ebx_99 = *ecx_102;
			eax_100->dwFFFFFFF4 = 0x00;
			eax_100->dwFFFFFFFC = eax_100;
			++eax_100;
			eax_100->dwFFFFFFEC = ebx_99;
			ebx_99->b0198 = ebx_99->b0198 & ~0x60 | 0x20;
			ecx_102 = (word32) ecx_102 + 4;
		} while (esi_95 != ecx_102);
		word32 eax_115 = ebp_1054->ptrFFFFFBA0;
		struct Eq_138707 * ebx_116 = ebp_1054->ptrFFFFFB9C;
		ebp_1054->dwFFFFFB7C = eax_115 + 0x01;
		ebp_1054->dwFFFFFB84 = ebx_116 - 0x0C + ((eax_115 + 0x01) + (eax_115 + 0x01) * 0x02) * 0x04;
		ebp_1054->ptrFFFFFBA0 = ebx_116->dw0004;
	}
	else
	{
		ebp_1054->dwFFFFFB7C = 0x01;
		ebp_1054->ptrFFFFFBA0 = (struct Eq_152401 *) ebp_1054->ptrFFFFFB8C;
		ebp_1054->dwFFFFFB84 = ebp_1054->ptrFFFFFB9C;
	}
	struct Eq_141340 * eax_127 = ebp_1054->dwFFFFFB84;
	ebp_1054->dwFFFFFBDC = 0x0400;
	eax_127->dw0008 = 0x00;
	ptr32 eax_131 = ebp_1054 - 0x0418;
	ebp_1054->dwFFFFFB68 = eax_131;
	ebp_1054->dwFFFFFBD8 = eax_131;
	ebp_1054->dwFFFFFB64 = ~0x1F;
	ebp_1054->dwFFFFFB60 = (word32) gs->tFFFFFFE0;
	gs->tFFFFFFE0.u0 = 0x00;
	struct Eq_141373 * eax_142 = ebp_1054->ptrFFFFFB9C;
	ebp_1054->dwFFFFFB6C = edx_66 & ~0x0F;
	ebp_1054->ptrFFFFFB80 = (struct Eq_152397 *) eax_142;
	ebp_1054->dwFFFFFB5C = 0x080CFF04;
l0809A268:
	Eq_2 esp_1302;
	Eq_2 esp_1099;
	Eq_2 eax_1515;
	ebp_1054->ptrFFFFFB80->dw0000 = 0x01;
	word32 eax_154 = ebp_1054->ptrFFFFFBA0->dw0160;
	ebp_1054->ptrFFFFFB90 = eax_154;
	struct Eq_9 * gs_1087 = gs;
	if (eax_154 != 0x00)
		ebp_1054->ptrFFFFFB90 = 0x00;
	else
	{
		struct Eq_138735 * eax_159 = ebp_1054->ptrFFFFFBA0;
		if (eax_159->dw01F4 == 0x00 && ebp_1054->ptrFFFFFB8C != eax_159)
		{
			Eq_2 eax_166 = (word32) eax_159->w015E;
			if ((word16) eax_166 != 0x00)
			{
				struct Eq_139242 * esp_172 = esp_1069 - 0x04;
				esp_172->tFFFFFFFC.u0 = 0x04;
				esp_172->tFFFFFFF8 = eax_166;
				esp_172->tFFFFFFF4 = ebp_1054 - 0x0428;
				esp_1302 = (char *) &esp_172->tFFFFFFFC + 8;
				word32 edx_2303;
				if (__libc_scratch_buffer_set_array_size(gs, esp_172->tFFFFFFF4, esp_172->tFFFFFFF8, esp_172->tFFFFFFFC, out ecx_102, out edx_2303) == 0x00)
				{
					eax_1515 = ebp_1054->dwFFFFFBA4 + ~0x0001457F;
					goto l0809B176;
				}
				ebp_1054->ptrFFFFFB90 = ebp_1054->dwFFFFFBD8;
			}
		}
	}
	Eq_2 esi_1318;
	Eq_2 ecx_1874;
	Eq_139214 esp_2063;
	word32 edi_2058;
	Eq_139216 esp_2042;
	Eq_2 esp_1420;
	Eq_2 ebx_1309;
	Eq_2 eax_1633;
	Eq_2 esp_1959;
	Eq_2 eax_1044;
	struct Eq_138791 * eax_202 = ebp_1054->ptrFFFFFBA0;
	if (eax_202->dw0024 == 0x00 && eax_202->dw00F4 == 0x00)
	{
		ebp_1054->tFFFFFB98 = 0x00;
		if (eax_202->dw00EC == 0x00)
			goto l0809A2CF;
	}
	struct Eq_138748 * edi_218 = ebp_1054->ptrFFFFFBA0;
	struct Eq_138752 * eax_219 = edi_218->ptr0034;
	ebp_1054->dwFFFFFBC0 = edi_218;
	struct Eq_138759 * edi_2122 = edi_218->ptr0008;
	word32 eax_222 = eax_219->dw0004;
	ebp_1054->dwFFFFFB94 = eax_222;
	ebp_1054->dwFFFFFBCC = eax_222;
	ebp_1054->dwFFFFFBC4 = ebp_1054->dwFFFFFB78;
	ebp_1054->dwFFFFFBC8 = ebp_1054->dwFFFFFB74;
	ui32 eax_229 = edi_2122->dw0000;
	if (eax_229 == 0x00)
	{
		ebp_1054->tFFFFFB98 = 0x00;
l0809A2CF:
		gs_1087 = gs;
		word32 eax_1073[] = ebp_1054->ptrFFFFFB90;
		if (eax_1073 == null)
		{
l0809A36F:
			struct Eq_138813 * eax_1155 = ebp_1054->ptrFFFFFB80;
			if (eax_1155->dw0000 != 0x00)
			{
				do
				{
					eax_1155 = eax_1155->dw0008;
					if (eax_1155 == null)
					{
						ebp_1054->dwFFFFFB84 = 0x00;
						goto l0809A7EA;
					}
					ecx_102 = eax_1155->dw0000;
				} while (ecx_102 != 0x00);
				ebp_1054->ptrFFFFFB80 = (struct Eq_152397 *) eax_1155;
			}
			ebp_1054->ptrFFFFFBA0 = ebp_1054->ptrFFFFFB80->dw0004;
			goto l0809A268;
		}
		Eq_138822 edi_1077 = ebp_1054->tFFFFFB98;
		eax_1073[edi_1077] = 0x00;
		struct Eq_138830 * esp_1079 = esp_1069 - 0x0C;
		esp_1079->tFFFFFFFC = edi_1077 * 0x08 + 0x0C;
		word32 edi_2287;
		int32 esi_1094;
		word32 edx_2285;
		word32 ebx_2286;
		word32 ecx_2284;
		Eq_2 eax_1088 = __libc_malloc(gs, esp_1079->tFFFFFFF8, esp_1079->tFFFFFFFC, out ecx_2284, out edx_2285, out ebx_2286, out ebp_1054, out esi_1094, out edi_2287);
		esp_1099 = (char *) &esp_1079->t0004 + 8;
		if (eax_1088 != 0x00)
		{
			word32 eax_1104 = ebp_1054->ptrFFFFFBA0;
			ebp_1054->ptrFFFFFB9C = esi_1094 + 0x04;
			*eax_1088 = eax_1104;
			esp_1079->t0004 = esi_1094 + 0x04;
			esp_1079->t0000 = ebp_1054->ptrFFFFFB90;
			esp_1079->tFFFFFFFC = (word32) eax_1088 + 4;
			word32 ecx_2288;
			word32 edx_2289;
			memcpy(esp_1079->tFFFFFFFC, esp_1079->t0000, esp_1079->t0004, out ecx_2288, out edx_2289);
			esp_1079->t0004 = ebp_1054->ptrFFFFFB9C;
			esp_1079->t0000 = eax_1088;
			esp_1079->tFFFFFFFC = (word32) eax_1088 + 8 + esi_1094;
			word32 edx_2290;
			memcpy(esp_1079->tFFFFFFFC, esp_1079->t0000, esp_1079->t0004, out ecx_102, out edx_2290);
			struct Eq_138944 * eax_1146 = ebp_1054->ptrFFFFFBA0;
			eax_1146->b019A |= 0x01;
			eax_1146->t01F4 = eax_1088;
			goto l0809A36F;
		}
l0809B189:
		Eq_2 eax_1543 = ebp_1054->dwFFFFFBD8;
		if (eax_1543 != ebp_1054->dwFFFFFB68)
		{
			struct Eq_138966 * esp_1547 = esp_1099 - 0x0C;
			esp_1547->tFFFFFFFC = eax_1543;
			word32 ecx_2291;
			word32 edx_2292;
			free(gs_1087, esp_1547->tFFFFFFF8, esp_1547->tFFFFFFFC, out ecx_2291, out edx_2292);
		}
		esp_1302 = esp_1099;
		eax_1515 = ebp_1054->dwFFFFFBA4 + 4294884212;
l0809B176:
		struct Eq_139034 * esp_1517 = esp_1302 - 4;
		esp_1517->t0000 = eax_1515;
		struct Eq_139040 * eax_1521 = ebp_1054->ptrFFFFFB8C;
		esp_1517->dwFFFFFFFC = 0x00;
		esp_1517->dwFFFFFFF8 = eax_1521->dw0004;
		esp_1517->tFFFFFFF4.u0 = 0x0C;
		word32 ecx_2293;
		word32 edi_2296;
		word32 edx_2294;
		word32 ebx_2295;
		_dl_signal_error(gs_1087, esp_1517->tFFFFFFF4, esp_1517->t0000, out ecx_2293, out edx_2294, out ebx_2295, out ebp_1054, out edi_2296);
		esp_1099 = esp_1517 - 0x0C;
		goto l0809B189;
	}
	else
	{
		Eq_139081 esp_1052;
		Eq_2 eax_500;
		struct Eq_139083 * ebx_234 = ebp_1054->ptrFFFFFB80;
		ebp_1054->tFFFFFB98 = 0x00;
		ebp_1054->ptrFFFFFB70 = (struct Eq_152396 *) ebx_234;
		ebp_1054->ptrFFFFFB58 = 135060900;
		while (eax_229 == 0x01)
		{
			Eq_2 eax_265;
			Eq_139116 esp_244 = esp_1069 - 0x0C;
			esi_1318 = ebp_1054->dwFFFFFB94 + edi_2122->dw0004;
			*((word32) esp_244 - 4) = esi_1318;
			Eq_2 eax_253 = _dl_dst_count(*((word32) esp_244 - 4));
			gs_1087 = gs;
			esp_1069 = esp_244 + 0x0C;
			Eq_2 ebx_261 = eax_253;
			if (eax_253 != 0x00)
			{
				ptr32 esp_280;
				if (*(union Eq_4846 *) 0x080CDDAC != 0x00)
				{
					*((word32) esp_244 + 8) = ebp_1054->dwFFFFFBA4 + 4294884004;
					*((word32) esp_244 + 4) = 0x00;
					*esp_244 = esi_1318;
					*((word32) esp_244 - 4) = 0x00;
					word32 ebx_2298;
					word32 edi_2299;
					word32 edx_2297;
					_dl_signal_error(gs, *((word32) esp_244 - 4), *((word32) esp_244 + 8), out ecx_1874, out edx_2297, out ebx_2298, out ebp_1054, out edi_2299);
					esp_280 = esp_244 - 4;
l0809B0B4:
					edi_2058 = ebp_1054->dwFFFFFBA4;
					struct Eq_141260 * esp_322 = esp_280 - 4;
					esp_322->dw0000 = edi_2058 + 4294884400;
					esp_322->dwFFFFFFFC = 244;
					esp_2063 = esp_322 - 4;
l0809B0C6:
					struct Eq_140543 * esp_2068 = esp_2063 - 4;
					esp_2068->dw0000 = edi_2058 + 4294883945;
					esp_2068->dwFFFFFFFC = edi_2058 + ~0x0001B01F;
					word32 ecx_2331;
					word32 edx_2332;
					__assert_fail(out ecx_2331, out edx_2332);
					esp_1959.u0 = <invalid>;
					goto l0809B0D9;
				}
				Eq_2 eax_346;
				*((word32) esp_244 - 4) = esi_1318;
				word32 edx_2300;
				Eq_2 eax_298 = strlen(*((word32) esp_244 - 4), out ecx_1874, out edx_2300);
				ebp_1054->ptrFFFFFB9C = (uint32 *) eax_298;
				esp_280 = (word32) esp_244 + 0x0C;
				Eq_2 edx_306 = eax_298;
				Eq_2 eax_309 = ebp_1054->ptrFFFFFBA0->t01AC;
				if (eax_309 != 0x00)
				{
					if (eax_309 != ~0x00)
						goto l0809A49E;
					goto l0809A78B;
				}
				if (*ebp_1054->ptrFFFFFBA0->t0004 != 0x00)
					goto l0809B0B4;
				ebp_1054->dwFFFFFB88 = (word32) eax_298;
				eax_309 = _dl_get_origin(gs, *((word32) esp_244 + 0x0C), out ebx_261, out esi_1318);
				edx_306 = ebp_1054->dwFFFFFB88;
				ebp_1054->ptrFFFFFBA0->t01AC = eax_309;
				if (eax_309 > ~0x01)
				{
l0809A78B:
					eax_346.u0 = 0x00;
				}
				else
				{
l0809A49E:
					ebp_1054->dwFFFFFB88 = (word32) edx_306;
					*((word32) esp_244 - 4) = eax_309;
					word32 ecx_2301;
					word32 edx_2302;
					eax_346 = strlen(*((word32) esp_244 - 4), out ecx_2301, out edx_2302);
					edx_306 = ebp_1054->dwFFFFFB88;
				}
				word32 esp_400 = esp_244 + 0x0C;
				if (_dl_platformlen >= eax_346)
					eax_346 = _dl_platformlen;
				if (eax_346 > 0x04)
					ebp_1054->ptrFFFFFB9C = (word32) edx_306 + (eax_346 - 0x04) *s ebx_261;
				word32 ebx_397 = ebp_1054->ptrFFFFFB9C;
				word32 edx_406 = esp_244 + 0x0C - (ebx_397 + 0x1B & ~0x0FFF);
				ui32 eax_407 = ebx_397 + 0x1B & ~0x0F;
				if (esp_244 + 0x0C != edx_406)
				{
					do
					{
						esp_400 -= 0x1000;
						*((word32) esp_400 + 0x0FFC) = *((word32) esp_400 + 0x0FFC);
					} while (esp_400 != edx_406);
				}
				if ((eax_407 & 0x0FFF) != 0x00)
				{
					esp_400 -= eax_407 & 0x0FFF;
					Mem429[esp_400 - 0x04 + (eax_407 & 0x0FFF):word32] = Mem427[esp_400 - 0x04 + (eax_407 & 0x0FFF):word32];
				}
				struct Eq_139374 * esp_434 = esp_400 - 0x04;
				Mem439[esp_434 + -4:word32] = esp_400 + 0x0F & ~0x0F;
				esp_434->tFFFFFFF8 = esi_1318;
				esp_434->tFFFFFFF4 = ebp_1054->ptrFFFFFBA0;
				eax_265 = _dl_dst_substitute(esp_434->tFFFFFFF4, esp_434->tFFFFFFF8, esp_434->tFFFFFFFC, out ecx_102);
				esp_1069 = (char *) &esp_434->tFFFFFFFC + 8;
				if (*eax_265 != 0x00)
					goto l0809A539;
				if ((_dl_debug_mask & 0x01) != 0x00)
				{
					esp_434->tFFFFFFF8 = esi_1318;
					esp_1052 = esp_434 - 0x08;
					goto l0809A7B1;
				}
			}
			else
			{
				eax_265 = esi_1318;
l0809A539:
				ebp_1054->dwFFFFFBD0 = (word32) eax_265;
				struct Eq_139496 * esp_476 = esp_1069 - 0x04;
				esp_476->tFFFFFFFC = ebp_1054 - 0x0440;
				esp_476->tFFFFFFF8 = ebp_1054->dwFFFFFBA4 + ~0x00033F7F;
				esp_476->tFFFFFFF4 = ebp_1054 - 1100;
				Eq_2 esp_504 = <invalid>;
				word32 edx_2309;
				word32 ebx_2310;
				eax_500 = _dl_catch_exception(gs, esp_476->tFFFFFFF4, esp_476->tFFFFFFF8, esp_476->tFFFFFFFC, out ecx_102, out edx_2309, out ebx_2310);
				esp_1069 = (word32) esp_504 + 16;
				if (ebp_1054->dwFFFFFBB8 != 0x00)
					goto l0809A7D0;
				struct Eq_139546 * eax_514 = ebp_1054->dwFFFFFBD4;
				if ((eax_514->b0198 & 0x60) == 0x00)
				{
					if ((word32) esp_504 + 16 != (word32) esp_504 + 16)
					{
						do
						{
							esp_1069 -= 0x1000;
							*((word32) esp_1069 + 0x0FFC) = *((word32) esp_1069 + 0x0FFC);
						} while (esp_1069 != (word32) esp_504 + 16);
					}
					esp_1069 -= 0x20;
					*((word32) esp_1069 + 28) = *((word32) esp_1069 + 28);
					struct Eq_139573 * esi_538 = ebp_1054->dwFFFFFB84;
					++ebp_1054->dwFFFFFB7C;
					word32 edx_542 = esp_1069 + 0x0F & ~0x0F;
					edx_542->ptr0004 = eax_514;
					edx_542->dw0000 = 0x00;
					edx_542->dw0008 = 0x00;
					esi_538->ptr0008 = edx_542;
					word32 ecx_549 = (word32) eax_514->b0198;
					ebp_1054->dwFFFFFB84 = edx_542;
					eax_514->b0198 = (byte) ecx_549 & ~0x60 | 0x20;
				}
				ecx_102 = ebp_1054->ptrFFFFFB90;
				if (ecx_102 != 0x00)
				{
					Eq_139669 ebx_563 = ebp_1054->tFFFFFB98;
					*((word32) ecx_102 + ebx_563 * 0x04) = eax_514;
					ebp_1054->tFFFFFB98 = (word32) ebx_563 + 1;
				}
			}
l0809A5FE:
			++edi_2122;
			eax_229 = edi_2122->dw0000;
			if (eax_229 == 0x00)
				goto l0809A2CF;
		}
		gs_1087 = gs;
		if ((eax_229 & ~0x02) == 0x7FFFFFFD)
		{
			Eq_139714 esp_585 = esp_1069 - 0x0C;
			ebx_1309 = ebp_1054->dwFFFFFB94 + edi_2122->dw0004;
			*((word32) esp_585 - 4) = ebx_1309;
			Eq_2 eax_595 = _dl_dst_count(*((word32) esp_585 - 4));
			esp_1069 = esp_585 + 0x0C;
			esi_1318 = eax_595;
			if (eax_595 == 0x00)
			{
l0809AC00:
				byte * eax_783 = ebp_1054->dwFFFFFB5C;
				ebp_1054->dwFFFFFBD0 = (word32) ebx_1309;
				if ((*eax_783 & 0x01) != 0x00)
				{
					Eq_2 eax_790 = ebp_1054->ptrFFFFFBA0->t0004;
					if (*eax_790 == 0x00)
					{
						word32 esi_794 = ebp_1054->dwFFFFFBA4;
						eax_790 = **ebp_1054->ptrFFFFFB58;
						if (eax_790 == 0x00)
							eax_790 = esi_794 + ~0x0001B534;
					}
					Eq_141177 esp_804 = esp_1069 - 0x04;
					*((word32) esp_804 - 4) = eax_790;
					word32 eax_810 = ebp_1054->dwFFFFFBA4;
					*((word32) esp_804 - 8) = ebx_1309;
					*((word32) esp_804 - 0x0C) = eax_810 + ~0x000144BB;
					word32 edx_2345;
					word32 ecx_2344;
					_dl_debug_printf(out ecx_2344, out edx_2345);
				}
				Eq_140955 esp_828 = esp_1069 - 0x04;
				*((word32) esp_828 - 4) = ebp_1054 - 0x0440;
				*((word32) esp_828 - 8) = ebp_1054->dwFFFFFBA4 + ~0x00033F7F;
				*((word32) esp_828 - 0x0C) = ebp_1054 - 1100;
				Eq_2 esp_856 = <invalid>;
				struct Eq_124233 * ebx_853;
				word32 edx_2343;
				eax_500 = _dl_catch_exception(gs, *((word32) esp_828 - 0x0C), *((word32) esp_828 - 8), *((word32) esp_828 - 4), out ecx_102, out edx_2343, out ebx_853);
				esp_1069 = (word32) esp_856 + 16;
				if (ebp_1054->dwFFFFFBB8 == 0x00)
				{
					if ((word32) esp_856 + 16 != (word32) esp_856 + 16)
					{
						do
						{
							esp_1069 -= 0x1000;
							*((word32) esp_1069 + 0x0FFC) = *((word32) esp_1069 + 0x0FFC);
						} while (esp_1069 != (word32) esp_856 + 16);
					}
					esp_1069 -= 0x20;
					*((word32) esp_1069 + 28) = *((word32) esp_1069 + 28);
					struct Eq_141016 * esi_919 = ebp_1054->ptrFFFFFB70;
					word32 ecx_920[] = ebp_1054->ptrFFFFFB90;
					word32 ebx_923 = esp_1069 + 0x0F & ~0x0F;
					*ebx_923 = esi_919->dw0000;
					*((word32) ebx_923 + 4) = esi_919->ptr0004;
					*((word32) ebx_923 + 8) = esi_919->dw0008;
					struct Eq_141037 * eax_929 = ebp_1054->dwFFFFFBD4;
					esi_919->dw0000 = 0x00;
					esi_919->ptr0004 = eax_929;
					if (ecx_920 != null)
					{
						Eq_141079 esi_935 = ebp_1054->tFFFFFB98;
						ecx_920[esi_935] = eax_929;
						eax_929 = ebp_1054->dwFFFFFBD4;
						ebp_1054->tFFFFFB98 = (word32) esi_935 + 1;
					}
					struct Eq_141070 * ecx_1002;
					struct Eq_141071 * edx_1001;
					if ((eax_929[0x0022] & 0x60) == 0x00)
					{
						struct Eq_141098 * esi_987 = ebp_1054->ptrFFFFFB70;
						ecx_1002 = eax_929->dw0010;
						++ebp_1054->dwFFFFFB7C;
						esi_987->t0008 = ebx_923;
						eax_929[0x0022] = (struct Eq_141037) (eax_929[0x0022] & ~0x60 | 0x20);
						edx_1001 = (struct Eq_141071 *) eax_929[1];
						if (ecx_1002 != null)
						{
l0809ACF1:
							ecx_1002->ptr000C = edx_1001;
							edx_1001 = (struct Eq_141071 *) eax_929[1];
						}
l0809ACF7:
						if (edx_1001 != null)
							edx_1001->ptr0010 = ecx_1002;
						struct Eq_141037 * edx_1018 = *((word32) ebx_923 + 4);
						eax_929->dw0010 = edx_1018->dw0010;
						edx_1018->dw0010 = eax_929;
						ecx_102 = eax_929->dw0010;
						if (ecx_102 != 0x00)
							*((word32) ecx_102 + 0x0C) = eax_929;
						eax_929[1] = (struct Eq_141037) edx_1018;
						if (ebp_1054->dwFFFFFB84 != ebp_1054->ptrFFFFFB70)
							ebp_1054->ptrFFFFFB70 = (struct Eq_152396 *) ebx_923;
						else
						{
							ebp_1054->ptrFFFFFB70 = (struct Eq_152396 *) ebx_923;
							ebp_1054->dwFFFFFB84 = (word32) ebx_923;
						}
					}
					else
					{
						ecx_102 = ebx_923;
						while (true)
						{
							Eq_2 edx_949 = *((word32) ecx_102 + 8);
							if (edx_949 == 0x00)
								break;
							if (eax_929 == *((word32) edx_949 + 4))
							{
								ebp_1054->ptrFFFFFB70->t0008 = ebx_923;
								Eq_2 edx_961 = *((word32) ecx_102 + 8);
								Eq_2 esi_960 = ebp_1054->dwFFFFFB84;
								word32 edx_963 = *((word32) edx_961 + 8);
								if (edx_961 == esi_960)
									esi_960 = ecx_102;
								*((word32) ecx_102 + 8) = edx_963;
								ecx_1002 = eax_929->dw0010;
								ebp_1054->dwFFFFFB84 = (word32) esi_960;
								edx_1001 = (struct Eq_141071 *) eax_929[1];
								if (ecx_1002 == null)
									goto l0809ACF7;
								goto l0809ACF1;
							}
							ecx_102 = edx_949;
						}
						struct Eq_141235 * esi_980 = ebp_1054->ptrFFFFFB70;
						esi_980->dw0000 = (word32) *ebx_923;
						esi_980->ptr0004 = (struct Eq_141037 *) *((word32) ebx_923 + 4);
						esi_980->dw0008 = (word32) *((word32) ebx_923 + 8);
					}
					goto l0809A5FE;
				}
				if (edi_2122->dw0000 == 0x7FFFFFFD)
				{
					*esp_856 = ebx_853;
					_dl_exception_free(*esp_856);
					esp_1069 = (word32) esp_856 + 16;
					goto l0809A5FE;
				}
l0809A7D0:
				ebp_1054->dwFFFFFB84 = (word32) eax_500;
				if (eax_500 == 0x00)
					ebp_1054->dwFFFFFB84 = ~0x00;
l0809A7EA:
				gs_1087 = gs;
				Eq_2 eax_1176 = ebp_1054->dwFFFFFBD8;
				if (eax_1176 != ebp_1054->dwFFFFFB68)
				{
					struct Eq_139295 * esp_1183 = esp_1069 - 0x0C;
					esp_1183->tFFFFFFFC = eax_1176;
					word32 edx_2304;
					free(gs, esp_1183->tFFFFFFF8, esp_1183->tFFFFFFFC, out ecx_102, out edx_2304);
				}
				word32 Eq_9::* eax_1203 = ebp_1054->dwFFFFFB64;
				if (gs->*eax_1203 == 0x00)
				{
					word32 esi_1209 = ebp_1054->dwFFFFFB60;
					if (esi_1209 != 0x00)
						gs->*eax_1203 = esi_1209;
				}
				struct Eq_139338 * esi_1216 = ebp_1054->ptrFFFFFB8C;
				struct Eq_139342 * eax_1217 = esi_1216->ptr01F4;
				ebp_1054->ptrFFFFFB80 = (struct Eq_152397 *) eax_1217;
				if (eax_1217 == null)
				{
l0809A85C:
					struct Eq_139424 * esp_1283 = esp_1069 - 0x0C;
					esp_1283->tFFFFFFFC = ebp_1054->dwFFFFFB7C * 0x08 + 0x04;
					word32 edx_2306;
					word32 esi_2308;
					word32 ecx_2305;
					word32 ebx_2307;
					Eq_139441 edi_1295;
					Eq_2 eax_1291 = __libc_malloc(gs, esp_1283->tFFFFFFF8, esp_1283->tFFFFFFFC, out ecx_2305, out edx_2306, out ebx_2307, out ebp_1054, out esi_2308, out edi_1295);
					ebp_1054->dwFFFFFB94 = (word32) eax_1291;
					esp_1302 = (char *) &esp_1283->tFFFFFFFC + 16;
					if (eax_1291 == 0x00)
					{
l0809B16A:
						eax_1515 = ebp_1054->dwFFFFFBA4 + ~0x00014447;
						goto l0809B176;
					}
					ui32 eax_1308 = ebp_1054->dwFFFFFB7C;
					ebx_1309 = ebp_1054->ptrFFFFFB8C;
					word32 edx_1310 = ebp_1054->dwFFFFFB78;
					Eq_2 ecx_1311[] = ebp_1054->dwFFFFFB94 + 0x04 + eax_1308 * 0x04;
					ebp_1054->ptrFFFFFB90 = (word32 *) ecx_1311;
					*((word32) ebx_1309 + 352) = ecx_1311;
					*((word32) ebx_1309 + 356) = eax_1308;
					esi_1318.u0 = 0x00;
					do
					{
						Eq_2 eax_1321 = *((word32) edi_1295 + 4);
						if (edx_1310 == 0x00 || (*((word32) eax_1321 + 0x0199) & 0x02) == 0x00)
						{
							ecx_1311[esi_1318] = eax_1321;
							eax_1321 = *((word32) edi_1295 + 4);
							esi_1318 = (byte) esi_1318.u0 + 1;
						}
						else
						{
							ebx_1309 = ebp_1054->ptrFFFFFB8C;
							--*((word32) ebx_1309 + 356);
						}
						*((word32) eax_1321 + 408) &= ~0x60;
						edi_1295 = *((word32) edi_1295 + 8);
					} while (edi_1295 != 0x00);
					if ((g_b80CFF05 & 0x08) != 0x00 && (g_t80CEA00 == ebp_1054->ptrFFFFFB8C && esi_1318 != 0x00))
					{
						ebp_1054->dwFFFFFB88 = (word32) edi_1295;
						word32 edx_1376[] = ebp_1054->ptrFFFFFB90;
						ebp_1054->ptrFFFFFBA0 = (struct Eq_152401 *) esi_1318;
						struct Eq_140598 * edi_1377 = null;
						do
						{
							esp_1420 = esp_1069;
							esi_1318 = edx_1376[edi_1377];
							if (ebp_1054->ptrFFFFFB8C != esi_1318)
							{
								struct Eq_140637 * eax_1386 = *((word32) esi_1318 + 468);
								if (eax_1386 == null || eax_1386->dw0004 == 0x00)
								{
									if (*((word32) esi_1318 + 244) != 0x00 || *((word32) esi_1318 + 0x00EC) != 0x00)
										goto l0809B118;
									Eq_138499 eax_1407 = _dl_build_local_scope(ebp_1054->dwFFFFFB94, esi_1318);
									if (eax_1407 > ebp_1054->ptrFFFFFBA0)
									{
										word32 edi_1417 = ebp_1054->dwFFFFFBA4;
										Eq_140715 esp_1421 = esp_1069 - 4;
										*esp_1421 = edi_1417 + 4294884400;
										*((word32) esp_1421 - 4) = 0x0210;
										*((word32) esp_1421 - 8) = edi_1417 + 4294883945;
										*((word32) esp_1421 - 0x0C) = edi_1417 + 4294883955;
										word32 edx_2337;
										word32 ecx_2336;
										__assert_fail(out ecx_2336, out edx_2337);
										esp_1302.u0 = <invalid>;
										goto l0809B16A;
									}
									if (eax_1407 != 0x00)
									{
										struct Eq_140800 ** ebx_1441 = ebp_1054->dwFFFFFB94;
										struct Eq_140800 * eax_1442 = *ebx_1441;
										eax_1442->b0198 &= ~0x60;
										struct Eq_140812 ** eax_1447 = (char *) ebx_1441 + 4;
										struct Eq_140812 ** ebx_1448 = (char *) ebx_1441 + eax_1407 * 0x04;
										while (ebx_1448 != eax_1447)
										{
											struct Eq_140857 * ecx_1454 = *eax_1447;
											ecx_1454->b0198 &= ~0x60;
											if (*((char *) *eax_1447 + 96) != 0x00)
												*((word32) esi_1318 + 0x0199) |= 0x80;
											eax_1447 = (struct Eq_140812 **) ((char *) eax_1447 + 4);
										}
									}
									ebp_1054->tFFFFFB98.u3 = eax_1407;
									Eq_2 ecx_1474 = eax_1407 * 0x04 + 0x08;
									Eq_140753 esp_1478 = esp_1069 - 0x0C;
									*((word32) esp_1478 - 4) = ecx_1474;
									ebp_1054->ptrFFFFFB9C = (uint32 *) ecx_1474;
									struct Eq_140762 * esi_1500;
									word32 ecx_2338;
									word32 edx_2339;
									word32 ebx_2340;
									Eq_2 eax_1494 = __libc_malloc(gs, *((word32) esp_1478 - 8), *((word32) esp_1478 - 4), out ecx_2338, out edx_2339, out ebx_2340, out ebp_1054, out esi_1500, out edi_1377);
									uint32 * ecx_1506 = ebp_1054->ptrFFFFFB9C;
									Eq_140785 edx_1507 = ebp_1054->tFFFFFB98;
									esi_1500->t01D4 = eax_1494;
									esp_1302 = esp_1478 + 0x0C;
									if (eax_1494 == 0x00)
										goto l0809B16A;
									*((word32) eax_1494 + 4) = edx_1507;
									*eax_1494 = (word32) eax_1494 + 8;
									ebx_1309 = ebp_1054->dwFFFFFBA4;
									*((word32) esp_1478 + 4) = ecx_1506 - 0x08;
									*esp_1478 = ebp_1054->dwFFFFFB94;
									*((word32) esp_1478 - 4) = (word32) eax_1494 + 8;
									word32 edx_2342;
									word32 ecx_2341;
									memcpy(*((word32) esp_1478 - 4), *esp_1478, *((word32) esp_1478 + 4), out ecx_2341, out edx_2342);
									edx_1376 = ebp_1054->ptrFFFFFB8C->ptr0160;
								}
							}
							edi_1377 = (struct Eq_140598 *) ((char *) edi_1377->a0000 + 1);
						} while (edi_1377 != ebp_1054->ptrFFFFFBA0);
						ebp_1054->ptrFFFFFB90 = edx_1376;
						edi_1295 = ebp_1054->dwFFFFFB88;
						esi_1318 = ebp_1054->ptrFFFFFBA0;
					}
					if (*ebp_1054->ptrFFFFFB90 != ebp_1054->ptrFFFFFB8C)
					{
						word32 edi_1608 = ebp_1054->dwFFFFFBA4;
						Eq_139906 esp_1615 = esp_1069 - 4;
						*esp_1615 = edi_1608 + 4294884400;
						*((word32) esp_1615 - 4) = 0x0229;
						*((word32) esp_1615 - 8) = edi_1608 + 4294883945;
						*((word32) esp_1615 - 0x0C) = edi_1608 + ~0x000143F3;
						word32 ecx_2317;
						word32 edx_2318;
						eax_1044 = __assert_fail(out ecx_2317, out edx_2318);
						esp_1069.u0 = <invalid>;
						goto l0809B1DC;
					}
					union Eq_139947 * eax_1635 = ebp_1054->ptrFFFFFB8C->ptr01F8;
					ebp_1054->ptrFFFFFB9C = (uint32 *) eax_1635;
					if (eax_1635 == null)
					{
						edi_1295.u0 = 0x00;
						goto l0809AAD1;
					}
					Eq_139947 ecx_1643 = *eax_1635;
					ebp_1054->ptrFFFFFBA0 = (struct Eq_152401 *) ((char *) eax_1635 + 4);
					ebp_1054->tFFFFFB98 = ecx_1643;
					if (esi_1318 > 0x01)
					{
						word32 * eax_1654 = ebp_1054->ptrFFFFFB90;
						word32 * edx_1655 = eax_1654 + 1;
						word32 * ebx_1656 = eax_1654 + esi_1318 * 0x04;
						do
						{
							struct Eq_139977 * ecx_1660 = *edx_1655;
							ecx_1660->b0198 = ecx_1660->b0198 & ~0x60 | 0x20;
							++edx_1655;
						} while (ebx_1656 != edx_1655);
						if (ebp_1054->tFFFFFB98 == 0x00)
							goto l0809AAB1;
					}
					else if (ebp_1054->tFFFFFB98 == 0x00)
						goto l0809AAD1;
					ebp_1054->dwFFFFFB7C = (ui32) esi_1318;
					ebp_1054->tFFFFFB98.u4 = edi_1295;
					uint32 esi_1686 = 0x00;
					do
					{
						ui32 edx_1691 = esi_1686 * 0x04;
						uint32 edi_1692 = esi_1686 + 0x01;
						if ((*((word32) ebp_1054->ptrFFFFFBA0[esi_1686 * 0x04 / 432].dw0160 + 56) & 0x60) != 0x00)
						{
							struct Eq_140058 * eax_1697 = ebp_1054->ptrFFFFFB8C;
							ebp_1054->dwFFFFFB88 = edx_1691;
							Eq_140065 esp_1699 = esp_1069 - 0x0C;
							*((word32) esp_1699 - 4) = eax_1697->dw01FC * 0x04 + 0x04;
							ui32 esi_1714;
							word32 edx_2320;
							word32 ecx_2319;
							word32 ebx_2321;
							Eq_2 eax_1708 = __libc_malloc(gs, *((word32) esp_1699 - 8), *((word32) esp_1699 - 4), out ecx_2319, out edx_2320, out ebx_2321, out ebp_1054, out esi_1714, out edi_1692);
							Eq_2 edx_1720 = ebp_1054->dwFFFFFB88;
							ebp_1054->tFFFFFB98 = eax_1708;
							if (eax_1708 != 0x00)
							{
								ui32 ecx_1758;
								ebp_1054->dwFFFFFB78 = (word32) edx_1720;
								*((word32) esp_1699 + 4) = edx_1720;
								*esp_1699 = ebp_1054->ptrFFFFFBA0;
								*((word32) esp_1699 - 4) = (word32) eax_1708 + 4;
								word32 ecx_2322;
								word32 edx_2323;
								memcpy(*((word32) esp_1699 - 4), *esp_1699, *((word32) esp_1699 + 4), out ecx_2322, out edx_2323);
								uint32 * eax_1752 = ebp_1054->ptrFFFFFB9C;
								uint32 ebx_1754 = *eax_1752;
								ebp_1054->dwFFFFFB88 = ebx_1754;
								if (ebx_1754 > edi_1692)
								{
									int32 edx_1759 = ebp_1054->dwFFFFFB78;
									struct Eq_140155 * ecx_1760 = ebp_1054->ptrFFFFFBA0;
									ebp_1054->dwFFFFFB78 = esi_1714;
									word32 * ebx_1762 = ecx_1760 + (ebx_1754 * 0x04) / 432;
									word32 * eax_1763 = eax_1752 + 2 + edx_1759;
									ecx_1758 = esi_1714;
									do
									{
										Eq_2 edx_1768 = *eax_1763;
										if ((*((word32) edx_1768 + 408) & 0x60) == 0x00)
										{
											*((word32) ebp_1054->tFFFFFB98 + (ecx_1758 * 0x04 + 4)) = edx_1768;
											++ecx_1758;
										}
										++eax_1763;
									} while (eax_1763 != ebx_1762);
									edi_1692 = ebp_1054->dwFFFFFB88 - 0x01 + edi_1692 - ebp_1054->dwFFFFFB78;
								}
								else
									ecx_1758 = esi_1714;
								*ebp_1054->tFFFFFB98 = ecx_1758;
								uint32 edi_1797 = edi_1692 + 0x01;
								esi_1686 = edi_1797;
								if (*ebp_1054->ptrFFFFFB9C <= edi_1797)
									break;
								continue;
							}
						}
						esi_1686 = edi_1692;
					} while (*ebp_1054->ptrFFFFFB9C > edi_1692);
					esi_1318 = ebp_1054->dwFFFFFB7C;
					edi_1295 = ebp_1054->tFFFFFB98;
					if (esi_1318 <= 0x01)
					{
l0809AAD1:
						Eq_140199 esp_1838 = esp_1069 - 0x04;
						*((word32) esp_1838 - 4) = esi_1318 * 0x04;
						*((word32) esp_1838 - 8) = ebp_1054->ptrFFFFFB90;
						*((word32) esp_1838 - 0x0C) = ebp_1054->dwFFFFFB94;
						word32 ecx_2324;
						word32 edx_2325;
						memcpy(*((word32) esp_1838 - 0x0C), *((word32) esp_1838 - 8), *((word32) esp_1838 - 4), out ecx_2324, out edx_2325);
						word32 ebx_1862[] = ebp_1054->dwFFFFFB94;
						*((word32) esp_1838 - 16) = 0x00;
						*((word32) esp_1838 - 20) = null;
						*((word32) esp_1838 - 24) = esi_1318 - (struct Eq_140246 *) 0x01;
						*((word32) esp_1838 - 28) = ebx_1862 + 1;
						ecx_1874 = _dl_sort_maps(*((word32) esp_1838 - 28), *((word32) esp_1838 - 24), *((word32) esp_1838 - 20), *((word32) esp_1838 - 16));
						ebx_1862[esi_1318] = 0x00;
						esi_1318 = ebp_1054->ptrFFFFFB8C;
						*((word32) esi_1318 + 500) = ebx_1862;
						*((word32) esi_1318 + 410) |= 0x01;
						if (edi_1295 != 0x00)
						{
							Eq_2 eax_1893 = *((word32) esi_1318 + 504);
							*((word32) esi_1318 + 504) = edi_1295;
							*((word32) esp_1838 - 0x0C) = eax_1893;
							_dl_scope_free(gs, *((word32) esp_1838 - 0x0C), out ecx_1874);
						}
						Eq_2 eax_1925 = ebp_1054->ptrFFFFFB80;
						if (eax_1925 != 0x00)
						{
							Eq_140440 esp_1930 = esp_1069 - 0x0C;
							*((word32) esp_1930 - 4) = eax_1925;
							_dl_scope_free(gs, *((word32) esp_1930 - 4), out ecx_1874);
						}
						esp_1959 = esp_1069;
						if (ebp_1054->dwFFFFFB84 == 0x00)
						{
							struct Eq_140457 * esp_2080 = ebp_1054 - 0x10;
							word32 ebx_2083 = esp_2080->dw0004;
							ptr32 edi_2087 = esp_2080->ptr000C;
							ebpOut = esp_2080->ptr0010;
							ediOut = edi_2087;
							return ebx_2083;
						}
l0809B0D9:
						if (ebp_1054->dwFFFFFB84 == ~0x00)
							ebp_1054->dwFFFFFB84 = 0x00;
						Eq_140507 esp_1960 = esp_1959 - 4;
						*esp_1960 = ecx_1874;
						*((word32) esp_1960 - 4) = 0x00;
						*((word32) esp_1960 - 8) = ebp_1054 - 1100;
						*((word32) esp_1960 - 0x0C) = ebp_1054->dwFFFFFB84;
						_dl_signal_exception(gs_1087, *((word32) esp_1960 - 0x0C), *((word32) esp_1960 - 8), out ebx_1309);
						esp_1069 = esp_1960 - 0x0C;
l0809B101:
						eax_1633 = ebp_1054->dwFFFFFBA4 + 4294884004;
						goto l0809B10D;
					}
l0809AAB1:
					word32 ecx_1814[] = ebp_1054->ptrFFFFFB90;
					Eq_2 eax_1815 = 0x01;
					do
					{
						struct Eq_140184 * edx_1821 = ecx_1814[eax_1815];
						edx_1821->b0198 &= ~0x60;
						eax_1815 = (word32) eax_1815 + 1;
					} while (eax_1815 < esi_1318);
					goto l0809AAD1;
				}
				word32 eax_1222 = (word32) esi_1216->b0198;
				ebp_1054->ptrFFFFFBA0 = (struct Eq_152401 *) (byte) eax_1222;
				if (((byte) eax_1222 & 0x03) != 0x02)
				{
					ebp_1054->ptrFFFFFB80 = (struct Eq_152397 *) null;
					goto l0809A85C;
				}
				if (esi_1216->dw0160 == 0x00)
					goto l0809A85C;
				word32 edi_1233 = ebp_1054->dwFFFFFBA4;
				Eq_139634 esp_1237 = esp_1069 - 4;
				*esp_1237 = edi_1233 + 4294884400;
				*((word32) esp_1237 - 4) = 0x01D8;
				*((word32) esp_1237 - 8) = edi_1233 + 4294883945;
				*((word32) esp_1237 - 0x0C) = edi_1233 + 4294884244;
				word32 edx_2312;
				word32 ecx_2311;
				eax_1247 = __assert_fail(out ecx_2311, out edx_2312);
				esp_1069.u0 = <invalid>;
				goto l0809AD78;
			}
			if (*(union Eq_4846 *) 0x080CDDAC != 0x00)
				goto l0809B101;
			Eq_2 eax_660;
			*((word32) esp_585 - 4) = ebx_1309;
			word32 ecx_2313;
			word32 edx_2314;
			Eq_2 eax_617 = strlen(*((word32) esp_585 - 4), out ecx_2313, out edx_2314);
			ebp_1054->ptrFFFFFB9C = (uint32 *) eax_617;
			esp_2042 = esp_585 + 0x0C;
			ecx_1874 = eax_617;
			Eq_2 eax_628 = ebp_1054->ptrFFFFFBA0->t01AC;
			if (eax_628 != 0x00)
			{
				if (eax_628 != ~0x00)
					goto l0809A684;
			}
			else
			{
				if (*ebp_1054->ptrFFFFFBA0->t0004 != 0x00)
					goto l0809B131;
				ebp_1054->dwFFFFFB88 = (word32) eax_617;
				eax_628 = _dl_get_origin(gs, Mem636[esp_585 + 0x0C:word32], out ebx_1309, out esi_1318);
				ebp_1054->ptrFFFFFBA0->t01AC = eax_628;
				ecx_1874 = ebp_1054->dwFFFFFB88;
				if (eax_628 <= ~0x01)
				{
l0809A684:
					ebp_1054->dwFFFFFB88 = (word32) ecx_1874;
					*((word32) esp_585 - 4) = eax_628;
					word32 ecx_2315;
					word32 edx_2316;
					eax_660 = strlen(*((word32) esp_585 - 4), out ecx_2315, out edx_2316);
					ecx_1874 = ebp_1054->dwFFFFFB88;
l0809A69C:
					Eq_2 esp_713 = esp_1069;
					if (_dl_platformlen >= eax_660)
						eax_660 = _dl_platformlen;
					if (eax_660 > 0x04)
					{
						esi_1318 *= eax_660 - 0x04;
						ecx_1874 = Mem684[ebp_1054 + -0x0464:word32] + esi_1318;
					}
					ui32 ecx_710 = (word32) ecx_1874 + 27;
					Eq_2 edx_718 = esp_1069 - (ecx_710 & ~0x0FFF);
					if (esp_1069 != edx_718)
					{
						do
						{
							esp_713 -= 0x1000;
							*((word32) esp_713 + 0x0FFC) = *((word32) esp_713 + 0x0FFC);
						} while (esp_713 != edx_718);
					}
					Eq_140312 eax_733 = ecx_710 & ~0x0F & 0x0FFF;
					if (eax_733 != 0x00)
					{
						esp_713 -= eax_733;
						Mem742[esp_713 - 0x04 + eax_733:word32] = Mem739[esp_713 - 0x04 + eax_733:word32];
					}
					Eq_140337 esp_747 = esp_713 - 0x04;
					Mem752[esp_747 + -4:word32] = esp_713 + 0x0F & ~0x0F;
					*((word32) esp_747 - 8) = ebx_1309;
					*((word32) esp_747 - 0x0C) = ebp_1054->ptrFFFFFBA0;
					Eq_2 eax_770 = _dl_dst_substitute(*((word32) esp_747 - 0x0C), *((word32) esp_747 - 8), *((word32) esp_747 - 4), out ecx_102);
					esp_1069 = esp_747 + 0x04;
					if (*eax_770 == 0x00)
					{
						eax_1044 = ebp_1054->dwFFFFFBA4;
						if (edi_2122->dw0000 != 0x7FFFFFFD)
						{
							if ((_dl_debug_mask & 0x01) != 0x00)
							{
								*((word32) esp_747 - 8) = ebx_1309;
								esp_1052 = esp_747 - 0x08;
l0809A7B1:
								Eq_140397 esp_1059 = esp_1052 - 4;
								*esp_1059 = ebp_1054->dwFFFFFBA4 + 4294884044;
								word32 edx_2326;
								_dl_debug_printf(out ecx_102, out edx_2326);
								esp_1069 = esp_1059 + 0x10;
								goto l0809A5FE;
							}
							goto l0809A5FE;
						}
l0809B1DC:
						gs_1087 = gs;
						eax_1633 = (word32) eax_1044 - 0x000144E4;
l0809B10D:
						Eq_140471 esp_1988 = esp_1069 - 4;
						*esp_1988 = eax_1633;
						*((word32) esp_1988 - 4) = 0x00;
						*((word32) esp_1988 - 8) = ebx_1309;
						*((word32) esp_1988 - 0x0C) = 0x00;
						word32 edx_2328;
						word32 ebx_2329;
						word32 edi_2330;
						word32 ecx_2327;
						_dl_signal_error(gs_1087, *((word32) esp_1988 - 0x0C), *esp_1988, out ecx_2327, out edx_2328, out ebx_2329, out ebp_1054, out edi_2330);
						esp_1420 = esp_1988 - 0x0C;
l0809B118:
						Eq_140653 esp_2025 = esp_1420 - 4;
						*esp_2025 = ebp_1054->dwFFFFFBA4 + ~0x00014423;
						*((word32) esp_2025 - 4) = 0x00;
						*((word32) esp_2025 - 8) = *((word32) esi_1318 + 4);
						*((word32) esp_2025 - 0x0C) = 22;
						word32 edi_2335;
						word32 edx_2333;
						word32 ebx_2334;
						_dl_signal_error(gs_1087, *((word32) esp_2025 - 0x0C), *esp_2025, out ecx_1874, out edx_2333, out ebx_2334, out ebp_1054, out edi_2335);
						esp_2042 = esp_2025 - 0x0C;
l0809B131:
						edi_2058 = ebp_1054->dwFFFFFBA4;
						Eq_140823 esp_2061 = esp_2042 - 4;
						*esp_2061 = edi_2058 + 4294884400;
						*((word32) esp_2061 - 4) = 288;
						esp_2063 = esp_2061 - 4;
						goto l0809B0C6;
					}
					ebx_1309 = eax_770;
					goto l0809AC00;
				}
			}
			eax_660.u0 = 0x00;
			goto l0809A69C;
		}
		goto l0809A5FE;
	}
}

// 0809B200: void call_init.part.0(Register Eq_2 eax, Register word32 ecx, Register word32 edx, Stack word32 dwArg04)
// Called from:
//      _dl_init
void call_init.part.0(Eq_2 eax, word32 ecx, word32 edx, word32 dwArg04)
{
	ui32 ebp_24 = (word32) *((word32) eax + 408);
	*((word32) eax + 408) = (byte) ebp_24 | 0x08;
	byte * edx_134 = *((word32) eax + 4);
	byte cl_31 = *edx_134;
	if (cl_31 == 0x00 && ((ebp_24 | 0x08) & 0x03) == 0x00)
		return;
	struct Eq_21880 * eax_107;
	word32 ecx_133;
	Eq_2 eax_102 = *((word32) eax + 80);
	if (eax_102 != 0x00)
	{
		ecx_133 = 0x080CFF04;
		if ((_dl_debug_mask & 0x02) == 0x00)
			goto l0809B24E;
	}
	else
	{
		eax_107 = (struct Eq_21880 *) *((word32) eax + 0x0084);
		if (eax_107 == null)
			return;
		if ((_dl_debug_mask & 0x02) == 0x00)
		{
l0809B26C:
			word32 ecx_153 = *eax;
			uint32 edx_156 = *((word32) *((word32) eax + 0x008C) + 4);
			<anonymous> ** edi_157 = eax_107->dw0004 + ecx_153;
			uint32 edx_158 = edx_156 >> 0x02;
			if (edx_156 >> 0x02 != 0x00)
			{
				word32 eax_163 = ecx;
				<anonymous> ** ebp_164 = (char *) edi_157 + (edx_156 >> 0x02) * 0x04;
				<anonymous> ** ebx_168 = edi_157;
				do
				{
					(*ebx_168)();
					ebx_168 = (<anonymous> **) ((char *) ebx_168 + 4);
				} while (ebp_164 != ebx_168);
			}
			return;
		}
	}
	if (cl_31 == 0x00)
		**(union Eq_2 **) 135060900 != 0x00;
	_dl_debug_printf(out ecx_133, out edx_134);
	eax_102 = *((word32) eax + 80);
	if (eax_102 == 0x00)
	{
		eax_107 = (struct Eq_21880 *) *((word32) eax + 0x0084);
l0809B268:
		if (eax_107 == null)
			return;
		goto l0809B26C;
	}
l0809B24E:
	word32 eax_114 = Mem111[eax_102 + 0x04:word32] + Mem111[eax + 0x00:word32];
	eax_114();
	eax_107 = (struct Eq_21880 *) *((word32) eax + 0x0084);
	goto l0809B268;
}

// 0809B330: void _dl_init(Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      dl_open_worker
void _dl_init(Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	Eq_2 eax_23 = _dl_initfirst;
	struct Eq_21900 * edx_25 = *((word32) dwArg04 + 0x00A0);
	struct Eq_141521 * ecx_26 = *((word32) dwArg04 + 0x00A4);
	if (eax_23 != 0x00)
	{
		if ((*((word32) eax_23 + 408) & 0x08) == 0x00)
			call_init.part.0(eax_23, dwArg0C, dwArg08, dwArg10);
		_dl_initfirst.u0 = 0x00;
	}
	if (edx_25 != null && ecx_26 != null)
	{
		uint32 ecx_65 = ecx_26->dw0004;
		if (ecx_65 > 0x03)
		{
			if ((_dl_debug_mask & 0x02) != 0x00)
			{
				if (**((word32) dwArg04 + 4) == 0x00)
					**(union Eq_2 **) 135060900 != 0x00;
				word32 edx_333;
				word32 ecx_332;
				_dl_debug_printf(out ecx_332, out edx_333);
			}
			<anonymous> ** eax_117 = (word32) *dwArg04 + edx_25->dw0004;
			<anonymous> ** ebx_122 = eax_117;
			<anonymous> ** eax_123 = (char *) eax_117 + (ecx_65 & ~0x03);
			do
			{
				(*ebx_122)();
				ebx_122 = (<anonymous> **) ((char *) ebx_122 + 4);
			} while (eax_123 != ebx_122);
		}
	}
	ui32 edi_158 = *((word32) dwArg04 + 356);
l0809B38F:
	for (--edi_158; edi_158 != ~0x00; --edi_158)
	{
		Eq_2 eax_167 = *((word32) *((word32) dwArg04 + 500) + edi_158 * 0x04);
		if ((*((word32) eax_167 + 408) & 0x08) != 0x00)
			goto l0809B38F;
		call_init.part.0(eax_167, dwArg0C, dwArg08, dwArg10);
	}
	_dl_starting_up = 0x00;
}

// 0809B4B0: Register word32 _dl_check_map_versions(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dl_open_worker
//      _dl_check_all_versions
word32 _dl_check_map_versions(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_163 = fp - 0x7C;
	Eq_2 ebp_19 = dwArg04;
	if (*((word32) dwArg04 + 52) == 0x00)
		return 0x00;
	Eq_2 edx_486;
	Eq_2 eax_472;
	word32 * esp_468;
	Eq_2 eax_459;
	Eq_2 esi_445;
	word32 * esp_457;
	struct Eq_141645 * edi_26 = *((word32) dwArg04 + 0x00B8);
	Eq_2 eax_28 = *((word32) dwArg04 + 0x00B0);
	if (eax_28 != 0x00)
	{
		word32 eax_42 = Mem30[eax_28 + 0x04:word32] + Mem41[dwArg04 + 0x00:word32];
		if (*eax_42 == 0x01)
		{
l0809B52E:
			struct Eq_141697 * edi_1001;
			Eq_2 esi_182;
			struct Eq_141697 * edx_220;
			struct Eq_141700 * ecx_781;
			struct Eq_141700 * ebx_270;
			word32 * esp_253;
			Eq_2 eax_218;
			word32 esi_89 = Mem85[esp_163 + 0x0C:word32] + Mem85[Mem85[esp_163 + 0x1C:word32] + 0x04:word32];
			Eq_2 ebx_100 = *((word32) *((word32) esp_163 + 48) + *((word32) ebp_19 + 24) * 0x4C);
			while (ebx_100 != 0x00)
			{
				struct Eq_141727 * esp_97 = esp_163 - 0x08;
				esp_97->tFFFFFFFC = ebx_100;
				esp_97->tFFFFFFF8 = esi_89;
				word32 ecx_1293;
				if (_dl_name_match_p(esp_97->tFFFFFFF8, esp_97->tFFFFFFFC, out ecx_1293) != 0x00)
				{
l0809B56C:
					if (*((byte) esp_163.u0 + 0x0088) != 0x00 && (*((word32) ebx_100 + 0x0199) & 0x02) != 0x00)
						goto l0809B97B;
					struct Eq_141829 * eax_175 = *((byte) esp_163.u0 + 28);
					*((byte) esp_163.u0 + 20) = ebx_100;
					*((byte) esp_163.u0 + 0x0080) = ebp_19;
					esi_182 = eax_175 + eax_175->dw0008 / 0x0C;
					*((byte) esp_163.u0 + 16) = 0x080CFF04;
					*((byte) esp_163.u0 + 40) = 135060900;
					goto l0809B5A6;
				}
				ebx_100 = *((word32) ebx_100 + 0x0C);
			}
			edi_1001 = (struct Eq_141697 *) *((word32) ebp_19 + 356);
			if (edi_1001 != null)
			{
				edi_1001 = null;
				do
				{
					struct Eq_141785 * esp_134 = esp_163 - 0x08;
					esp_134->tFFFFFFFC = *((word32) *((word32) ebp_19 + 352) + edi_1001 * 0x04);
					esp_134->tFFFFFFF8 = esi_89;
					word32 ecx_1296;
					if (_dl_name_match_p(esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out ecx_1296) != 0x00)
					{
						ebx_100 = *((word32) *((word32) ebp_19 + 352) + edi_1001 * 0x04);
						if (ebx_100 == 0x00)
							break;
						goto l0809B56C;
					}
					++edi_1001;
				} while (edi_1001 < *((word32) ebp_19 + 356));
			}
			esi_182 = *esp_163;
			struct Eq_141756 * esp_194 = esp_163 - 4;
			esp_194->dw0000 = (word32) esi_182 - 0x000141F0;
			esp_194->dwFFFFFFFC = 0xCD;
			esp_194->dwFFFFFFF8 = (word32) esi_182 - 82833;
			esp_194->dwFFFFFFF4 = (word32) esi_182 - 82820;
			word32 edx_1295;
			word32 ecx_1294;
			__assert_fail(out ecx_1294, out edx_1295);
			esp_163.u0 = <invalid>;
			do
			{
				if (*((byte) esp_163.u0 + 0x0084) != 0x00)
				{
					eax_218 = *((word32) ebp_19 + 4);
					edx_220 = edi_1001;
					if (*eax_218 == 0x00)
					{
						eax_218 = **(union Eq_2 **) 135060900;
						if (eax_218 == 0x00)
							goto l0809BB84;
					}
l0809B7C4:
					struct Eq_141969 * esp_231 = esp_163 - 4;
					esp_231->ptr0000 = edx_220;
					esp_231->tFFFFFFFC = esp_231->dw0004 + 4294884644;
					esp_231->tFFFFFFF8 = eax_218;
					esp_231->tFFFFFFF4 = &esp_231->dw0004 + 16;
					_dl_exception_create_format(gs, esp_231->tFFFFFFF4, esp_231->tFFFFFFF8, esp_231->tFFFFFFFC);
					esi_182 = &esp_231->dw0004 + 16;
					esp_253 = &esp_231->dw0004;
l0809B6A9:
					struct Eq_142017 * esp_256 = esp_253 - 0x04;
					esp_256->dwFFFFFFFC = esp_256->dw0004 + ~0x00014364;
					esp_256->tFFFFFFF8 = esi_182;
					esp_256->tFFFFFFF4.u0 = 0x00;
					_dl_signal_exception(gs, esp_256->tFFFFFFF4, esp_256->tFFFFFFF8, out ebx_270);
					esp_163 = esp_256 - 0x0C;
l0809B6C0:
					struct Eq_142125 * esp_281 = esp_163 - 0x08;
					Mem287[esp_281 + -4:word32] = Mem278[ebx_270 + Mem278[ebx_270 + 0x0C:word32]:word32] + ebp_19;
					esp_281->tFFFFFFF8 = esp_281->t0010;
					esp_163 = (char *) &esp_281->tFFFFFFFC + 0x0C;
					word32 ecx_1298;
					word32 edx_1299;
					if (strcmp(esp_281->tFFFFFFF8, esp_281->tFFFFFFFC, out ecx_1298, out edx_1299) != 0x00)
						goto l0809B636;
				}
l0809B6E0:
				ui32 eax_304 = (word32) *((word32) esi_182 + 6);
				uint32 edi_306 = *((byte) esp_163.u0 + 4);
				uint32 eax_307 = eax_304 & 0x7FFF;
				if (edi_306 >= (eax_304 & 0x7FFF))
					eax_307 = edi_306;
				*((word32) esp_163 + 4) = eax_307;
				int32 eax_315 = *((word32) esi_182 + 0x0C);
				if (eax_315 == 0x00)
				{
					ebp_19 = *((word32) esp_163 + 0x0080);
l0809B97B:
					struct Eq_142429 * edi_322 = *((word32) esp_163 + 28);
					word32 eax_323 = edi_322->dw000C;
					if (eax_323 == 0x00)
					{
						if (*((word32) esp_163 + 44) != 0x00)
							goto l0809B842;
						goto l0809B88B;
					}
					else
					{
						*((word32) esp_163 + 28) = edi_322 + eax_323 / 16;
						goto l0809B52E;
					}
				}
				esi_182 = (word32) esi_182 + eax_315;
l0809B5A6:
				struct Eq_141697 * edx_651 = *esi_182;
				*((word32) esp_163 + 26) = *((word32) esi_182 + 4);
				ebp_19 = *((word32) *((word32) esp_163 + 20) + 20);
				Mem659[esp_163 + 0x08:word32] = Mem654[esp_163 + 0x0C:word32] + Mem654[esi_182 + 0x08:word32];
				edi_1001 = (struct Eq_141697 *) *((word32) *((word32) esp_163 + 0x0080) + 4);
				if (edi_1001->b0000 == 0x00)
				{
					edi_1001 = (struct Eq_141697 *) ***((byte) esp_163.u0 + 40);
					word32 eax_667 = *esp_163.u0;
					if (edi_1001 == null)
						edi_1001 = eax_667 + ~0x0001B534;
				}
				Eq_2 ecx_676 = *((word32) *((word32) ebp_19 + 52) + 4);
				if ((**((byte) esp_163.u0 + 16) & 0x10) != 0x00)
				{
					*((byte) esp_163.u0 + 32) = *((word32) ebp_19 + 24);
					Eq_2 eax_684 = *((word32) ebp_19 + 4);
					if (*eax_684 == 0x00)
					{
						word32 ebx_688 = *esp_163;
						eax_684 = ***((word32) esp_163 + 56);
						if (eax_684 == 0x00)
							eax_684 = ebx_688 + ~0x0001B534;
					}
					*((word32) esp_163 + 60) = ecx_676;
					struct Eq_142523 * esp_701 = esp_163 - 0x08;
					esp_701->ptr002C = edx_651;
					esp_701->dwFFFFFFFC = esp_701->ptr0088->dw0018;
					esp_701->ptrFFFFFFF8 = edi_1001;
					esp_701->dwFFFFFFF4 = esp_701->dw0028;
					esp_701->tFFFFFFF0 = eax_684;
					esp_701->dwFFFFFFEC = esp_701->dw0010;
					esp_701->dwFFFFFFE8 = esp_701->dw0008 + ~0x00014323;
					word32 edx_1302;
					word32 ecx_1301;
					_dl_debug_printf(out ecx_1301, out edx_1302);
					ecx_676 = esp_701->t0044;
					edx_651 = esp_701->ptr002C;
				}
				struct Eq_141645 * eax_746 = *((word32) ebp_19 + 0x00B8);
			} while (eax_746 == null);
			word32 ebx_750 = eax_746->dw0004;
			if (ebx_750 != 0x00)
			{
				ebx_270 = (word32) *ebp_19 + ebx_750;
				if (ebx_270->w0000 != 0x01)
				{
					ecx_781 = ebx_270;
					goto l0809B64F;
				}
				*((byte) esp_163.u0 + 32) = ebp_19;
				*((byte) esp_163.u0 + 36) = edi_1001;
				ebp_19 = ecx_676;
				edi_1001 = edx_651;
l0809B62D:
				if (edi_1001 != ebx_270->ptr0008)
				{
l0809B636:
					int32 eax_797 = ebx_270->dw0010;
					if (eax_797 != 0x00)
					{
						ebx_270 += eax_797 / 20;
						if (ebx_270->w0000 != 0x01)
						{
							ecx_781 = ebx_270;
l0809B64F:
							*((word32) esp_163 + 95) = 0x00;
							struct Eq_142330 * esp_895 = esp_163 - 0x0C;
							esp_895->tFFFFFFFC.u0 = 0x00;
							esp_895->tFFFFFFF8.u0 = 0x0A;
							esp_895->tFFFFFFF4 = (char *) &esp_895->tFFFFFFFC + 111;
							Eq_84901 eax_907 = (word32) ecx_781->w0000;
							esp_895->dwFFFFFFF0 = 0x00;
							esp_895->tFFFFFFEC = eax_907;
							word32 ebx_1300;
							Eq_2 eax_919 = _itoa(gs, esp_895->tFFFFFFEC, esp_895->tFFFFFFF4, esp_895->tFFFFFFF8, esp_895->tFFFFFFFC, out ebx_1300, out ebp_19, out edi_1001);
							Eq_2 esp_926 = <invalid>;
							Eq_2 edx_931 = edi_1001[4];
							if (*edx_931 == 0x00)
							{
								word32 esi_935 = *((word32) esp_926 + 32);
								edx_931 = **(union Eq_2 **) 135060900;
								if (edx_931 == 0x00)
									edx_931 = esi_935 + ~0x0001B534;
							}
							*((word32) esp_926 + 28) = eax_919;
							*((word32) esp_926 + 24) = (word32) *((word32) esp_926 + 32) - 82600;
							*((word32) esp_926 + 20) = edx_931;
							*((word32) esp_926 + 16) = (word32) esp_926 + 96;
							_dl_exception_create_format(gs, *((word32) esp_926 + 16), *((word32) esp_926 + 20), *((word32) esp_926 + 24));
							esi_182 = (word32) esp_926 + 96;
							esp_253 = (word32) esp_926 + 32;
							goto l0809B6A9;
						}
						goto l0809B62D;
					}
					Eq_2 eax_808;
					Eq_2 edx_831;
					ebp_19 = *((word32) esp_163 + 32);
					edi_1001 = (struct Eq_141697 *) *((word32) esp_163 + 36);
					if ((*((word32) esp_163 + 26) & 0x02) == 0x00)
					{
						eax_808 = *((word32) ebp_19 + 4);
						if (*eax_808 == 0x00)
						{
							edi_1001 = (struct Eq_141697 *) *esp_163;
							eax_808 = **(union Eq_2 **) 135060900;
							if (eax_808 == 0x00)
								eax_808 = (char *) edi_1001 - 111925;
						}
						struct Eq_142435 * esp_822 = esp_163 - 0x0C;
						esp_822->ptrFFFFFFFC = edi_1001;
						esp_822->dwFFFFFFF8 = esp_822->dw0014;
						edx_831 = esp_822->dw000C + 4294884784;
l0809BAFD:
						struct Eq_142288 * esp_860 = esp_163 - 0x14;
						esp_860->tFFFFFFFC = edx_831;
						esp_860->tFFFFFFF8 = eax_808;
						esp_860->tFFFFFFF4 = (char *) &esp_860->tFFFFFFFC + 88;
						_dl_exception_create_format(gs, esp_860->tFFFFFFF4, esp_860->tFFFFFFF8, esp_860->tFFFFFFFC);
						esi_182 = (char *) &esp_860->tFFFFFFFC + 88;
						esp_253 = (word32 *) ((char *) &esp_860->tFFFFFFFC + 24);
						goto l0809B6A9;
					}
					if (*((word32) esp_163 + 0x0084) != 0x00)
					{
						eax_808 = *((word32) ebp_19 + 4);
						if (*eax_808 == 0x00)
						{
							eax_808 = **(union Eq_2 **) 135060900;
							if (eax_808 == 0x00)
								eax_808 = (word32) *esp_163 - 111925;
						}
						struct Eq_142259 * esp_850 = esp_163 - 0x0C;
						esp_850->ptrFFFFFFFC = edi_1001;
						esp_850->dwFFFFFFF8 = esp_850->dw0014;
						edx_831 = esp_850->dw000C + ~0x0001427F;
						goto l0809BAFD;
					}
					goto l0809B6E0;
				}
				goto l0809B6C0;
			}
			word32 esi_755 = *esp_163.u0;
			struct Eq_142082 * esp_757 = esp_163 - 4;
			esp_757->dw0000 = esi_755 + ~0x000141FF;
			esp_757->dwFFFFFFFC = 88;
			esp_757->dwFFFFFFF8 = esi_755 + ~0x00014390;
			esp_757->dwFFFFFFF4 = esi_755 + 4294884491;
			word32 ecx_1297;
			__assert_fail(out ecx_1297, out edx_220);
			esp_163.u0 = <invalid>;
l0809BB84:
			eax_218 = (word32) *esp_163.u0 - 111925;
			goto l0809B7C4;
		}
		struct Eq_141670 * ebp_69;
		word32 edi_1292;
		word32 ebx_1291;
		eax_472 = _itoa(gs, (uint64) *eax_42, fp - 0x1D, 0x0A, 0x00, out ebx_1291, out ebp_69, out edi_1292);
		Eq_2 esp_75 = <invalid>;
		edx_486 = ebp_69->t0004;
		esp_468 = (word32) esp_75 + 32;
		if (*edx_486 == 0x00)
		{
l0809BAAF:
			word32 esi_482 = *esp_468;
			edx_486 = **(union Eq_2 **) 135060900;
			if (edx_486 == 0x00)
				edx_486 = esi_482 + ~0x0001B534;
			goto l0809BA87;
		}
l0809BA87:
		struct Eq_141896 * esp_493 = esp_468 - 4;
		esp_493->t0000 = eax_472;
		esp_493->tFFFFFFFC = esp_493->dw0004 + ~0x0001434F;
		esp_493->tFFFFFFF8 = edx_486;
		esp_493->tFFFFFFF4 = &esp_493->dw0004 + 16;
		_dl_exception_create_format(gs, esp_493->tFFFFFFF4, esp_493->tFFFFFFF8, esp_493->tFFFFFFFC);
		esi_445 = &esp_493->dw0004 + 16;
		esp_457 = &esp_493->dw0004;
		eax_459.u0 = 0x00;
	}
	else
	{
		if (edi_26 == null)
			return 0x00;
l0809B842:
		word32 edx_338 = Mem332[Mem332[esp_163 + 44:word32] + 0x04:word32] + Mem332[ebp_19 + 0x00:word32];
		ui32 eax_339 = (word32) edx_338->w0004;
		uint32 edi_334 = *((word32) esp_163 + 4);
		uint32 eax_340 = eax_339 & 0x7FFF;
		if (edi_334 >= (eax_339 & 0x7FFF))
			eax_340 = edi_334;
		*((word32) esp_163 + 4) = eax_340;
		uint32 ecx_345 = eax_340;
		int32 eax_349 = edx_338->dw0010;
		if (eax_349 != 0x00)
		{
			do
			{
				edx_338 += eax_349 / 20;
				ui32 eax_361 = (word32) edx_338->w0004;
				if (ecx_345 < (eax_361 & 0x7FFF))
					ecx_345 = eax_361 & 0x7FFF;
				eax_349 = edx_338->dw0010;
			} while (eax_349 != 0x00);
			*((word32) esp_163 + 4) = ecx_345;
		}
l0809B88B:
		word32 eax_379 = *((word32) esp_163 + 4);
		if (eax_379 == 0x00)
			return 0x00;
		struct Eq_142586 * esp_383 = esp_163 - 0x08;
		esp_383->tFFFFFFFC.u0 = 0x10;
		esp_383->tFFFFFFF8 = eax_379 + 0x01;
		uint32 esi_411;
		word32 edx_1304;
		word32 ecx_1303;
		word32 ebx_1305;
		word32 edi_1306;
		struct Eq_142603 * ebp_406;
		Eq_2 eax_405 = __libc_calloc(gs, esp_383->tFFFFFFF8, esp_383->tFFFFFFFC, out ecx_1303, out edx_1304, out ebx_1305, out ebp_406, out esi_411, out edi_1306);
		ebp_406->t0174 = eax_405;
		if (eax_405 != 0x00)
		{
			struct Eq_142633 * edx_524 = ebp_406->ptr00E8;
			struct Eq_142637 * edi_525 = esp_383->ptr003C;
			ebp_406->dw0178 = esi_411;
			ebp_406->dw01A8 = edx_524->dw0004;
			if (edi_525 != null)
			{
				struct Eq_142658 * edi_533 = edi_525->dw0004 + ebp_406->dw0000;
				esp_383->ptr0088 = ebp_406;
				word32 ebp_536 = esp_383->dw0014;
				while (true)
				{
					word32 ebx_539 = edi_533->dw0008;
					esp_383->t0008 = eax_405;
					struct Eq_142674 * ebx_543 = edi_533 + ebx_539 / 16;
					while (true)
					{
						ui32 ecx_547 = (word32) ebx_543->w0006;
						cui16 cx_553 = (word16) ecx_547;
						if (esi_411 > (ecx_547 & 0x7FFF))
						{
							struct Eq_142700 * edx_557 = (word32) esp_383->t0008 + ((ecx_547 & 0x7FFF) << 0x04);
							word32 eax_558 = ebx_543->dw0000;
							edx_557->dw0008 = (word32) (cx_553 & 0x8000);
							word32 ecx_561 = ebx_543->dw0008;
							edx_557->dw0004 = eax_558;
							edx_557->dw0000 = ecx_561 + ebp_536;
							edx_557->dw000C = edi_533->dw0004 + ebp_536;
						}
						int32 edx_573 = ebx_543->dw000C;
						if (edx_573 == 0x00)
							break;
						ebx_543 += edx_573 / 16;
					}
					int32 edx_580 = edi_533->dw000C;
					eax_405 = esp_383->t0008;
					if (edx_580 == 0x00)
						break;
					edi_533 += edx_580 / 16;
				}
				ebp_406 = esp_383->ptr0088;
			}
			struct Eq_142652 * esi_589 = esp_383->ptr0034;
			if (esi_589 != null)
			{
				word32 esi_594 = esp_383->dw0014;
				struct Eq_142740 * edx_596 = esi_589->dw0004 + ebp_406->dw0000;
				while (true)
				{
					if ((edx_596->b0002 & 0x01) == 0x00)
					{
						int32 ebx_604 = edx_596->dw000C;
						struct Eq_142828 * ecx_609 = (word32) eax_405 + (((word32) edx_596->w0004 & 0x7FFF) << 0x04);
						ecx_609->dw0004 = edx_596->dw0008;
						word32 edi_611 = edx_596[ebx_604 / 20];
						ecx_609->dw000C = 0x00;
						ecx_609->dw0000 = edi_611 + esi_594;
					}
					int32 ecx_619 = edx_596->dw0010;
					if (ecx_619 == 0x00)
						break;
					edx_596 += ecx_619 / 20;
				}
			}
			return 0x00;
		}
		Eq_2 eax_422 = ebp_406->t0004;
		if (*eax_422 == 0x00)
		{
			Eq_2 esi_425 = esp_383->t0008;
			eax_422 = **(union Eq_2 **) 135060900;
			if (eax_422 == 0x00)
				eax_422 = (word32) esi_425 - 111925;
		}
		esp_383->t0000 = (word32) esp_383->t0008 - 82472;
		esp_383->tFFFFFFFC = eax_422;
		esp_383->tFFFFFFF8 = (char *) &esp_383->ptr003C + 0x0C;
		_dl_exception_create(esp_383->tFFFFFFF8, esp_383->tFFFFFFFC, esp_383->t0000);
		esi_445 = (char *) &esp_383->ptr003C + 0x0C;
		esp_457 = (word32 *) &esp_383->t0008;
		eax_459.u0 = 0x0C;
	}
	struct Eq_142855 * esp_461 = esp_457 - 0x04;
	esp_461->dwFFFFFFFC = 0x00;
	esp_461->tFFFFFFF8 = esi_445;
	esp_461->tFFFFFFF4 = eax_459;
	esp_468 = esp_461 - 0x0C;
	word32 ebx_1307;
	eax_472 = _dl_signal_exception(gs, esp_461->tFFFFFFF4, esp_461->tFFFFFFF8, out ebx_1307);
	goto l0809BAAF;
}

// 0809BBA0: void _dl_check_all_versions(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _dl_check_all_versions(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ebx_18 = dwArg04;
	if (dwArg04 != 0x00)
	{
		do
		{
			if ((*((word32) ebx_18 + 0x0199) & 0x02) == 0x00)
			{
				_dl_check_map_versions(gs, ebx_18);
				ebx_18 = *((word32) ebx_18 + 0x0C);
				if (ebx_18 == 0x00)
					return;
				continue;
			}
			ebx_18 = *((word32) ebx_18 + 0x0C);
		} while (ebx_18 != 0x00);
	}
}

// 0809BC00: void call_dl_lookup(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_142916) dwArg04)
void call_dl_lookup(struct Eq_9 * gs, struct Eq_142916 * dwArg04)
{
	Eq_2 eax_10 = dwArg04->t0000;
	word32 ecx_60;
	word32 edx_61;
	dwArg04->t0000 = _dl_lookup_symbol_x(gs, dwArg04->t0004, eax_10, dwArg04->ptr0014, *((word32) eax_10 + 464), dwArg04->t0008, 0x00, dwArg04->t000C, 0x00, out ecx_60, out edx_61);
}

// 0809BC40: Register Eq_2 do_sym(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 esiOut)
// Called from:
//      _dl_vsym
//      _dl_sym
Eq_2 do_sym(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & esiOut)
{
	Eq_2175 eax_24 = gs->t0014;
	Eq_2 edi_11 = edx;
	Eq_2 esi_16 = eax;
	ptr32 ebx_152 = 0x080CE000;
	Eq_2 ebp_151 = dwArg04;
	Eq_2 eax_150 = _dl_find_dso_for_object(ecx);
	struct Eq_142965 * esp_147 = fp - 0x5C;
	if (eax_150 == 0x00)
		eax_150 = g_t80CEA00;
	Eq_2 dwLoc70_381;
	Eq_2 dwLoc60_375;
	Eq_2 dwLoc64_378;
	if (eax != 0x00)
	{
		if (eax != ~0x00)
		{
			word32 ecx_522;
			word32 edx_523;
			_dl_lookup_symbol_x(gs, edx, eax, fp - 0x48, (word32) eax + 468, dwArg04, 0x00, dwArg08, 0x00, out ecx_522, out edx_523);
			goto l0809BCB3;
		}
		esi_16.u0 = 0x080CEA00;
		Eq_2 edx_80 = eax_150;
		if (g_t80CEA00 == eax_150 && (eax_150 == 0x00 || (*((word32) eax_150 + 432) > ecx || *((word32) eax_150 + 436) <= ecx)))
		{
			esp_147 = fp - 0x6C;
			word32 edx_531;
			word32 ecx_530;
			eax_150 = _dl_signal_error(gs, 0x00, 0x080B9E28, out ecx_530, out edx_531, out ebx_152, out ebp_151, out edi_11);
			esi_16.u0 = 0x080CEA00;
			goto l0809BDD0;
		}
		while (true)
		{
			Eq_2 ecx_93 = *((word32) edx_80 + 368);
			if (ecx_93 == 0x00)
				break;
			edx_80 = ecx_93;
		}
		dwLoc60_375 = eax_150;
		dwLoc64_378.u0 = 0x00;
		dwLoc70_381 = (word32) edx_80 + 468;
	}
	else
	{
		if (gs->t000C != 0x00)
		{
l0809BDD0:
			esp_147->t0024 = eax_150;
			ui32 eax_166 = esp_147->dw0064;
			esp_147->t0028 = edi_11;
			esp_147->t002C = ebp_151;
			esp_147->dw0030 = eax_166 | 0x05;
			esp_147->ptr0038 = (char *) esp_147 + 20;
			gs->t001C.u0 = 0x01;
			struct Eq_143065 * esp_177 = esp_147 - 0x04;
			esp_177->tFFFFFFFC = (char *) &esp_177->tFFFFFFFC + 44;
			esp_177->tFFFFFFF8 = ebx_152 + ~0x000323FF;
			esp_177->tFFFFFFF4 = (char *) &esp_177->tFFFFFFFC + 32;
			word32 ecx_532;
			word32 ebx_534;
			word32 edx_533;
			Eq_2 eax_189 = _dl_catch_exception(gs, esp_177->tFFFFFFF4, esp_177->tFFFFFFF8, esp_177->tFFFFFFFC, out ecx_532, out edx_533, out ebx_534);
			Eq_2 v18_201 = gs->t001C;
			gs->t001C = esi_16;
			Eq_2 esp_193 = <invalid>;
			if (v18_201 == 0x02)
				gs->ptr0010();
			if (*((word32) esp_193 + 44) != 0x00)
			{
				*((word32) esp_193 + 8) = 0x00;
				*((word32) esp_193 + 4) = (char *) &esp_177->tFFFFFFFC + 32;
				*esp_193 = eax_189;
				word32 ebx_535;
				_dl_signal_exception(gs, *esp_193, *((word32) esp_193 + 4), out ebx_535);
l0809BE62:
				word32 ecx_524;
				word32 edx_525;
				Eq_2 eax_347 = __stack_chk_fail(out ecx_524, out edx_525);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 stackArg12 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				_dl_vsym(gs, stackArg4, stackArg8, stackArg12, stackArg16);
				esiOut = esi_16;
				return eax_347;
			}
l0809BCB3:
			if ((eax_24 ^ gs->t0014) == 0x00)
			{
				esiOut = esi;
				return 0x00;
			}
			goto l0809BE62;
		}
		dwLoc60_375.u0 = 0x00;
		dwLoc64_378 = dwArg08 | 0x01;
		dwLoc70_381 = *((word32) eax_150 + 464);
	}
	word32 ecx_536;
	word32 edx_537;
	_dl_lookup_symbol_x(gs, edx, eax_150, fp - 0x48, dwLoc70_381, dwArg04, 0x00, dwLoc64_378, dwLoc60_375, out ecx_536, out edx_537);
	goto l0809BCB3;
}

// 0809BE70: Register word32 _dl_vsym(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      dlvsym_doit
//      _dl_sym
word32 _dl_vsym(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if ((word32) *dwArg0C != 0x00 && ((word32) (*((word32) dwArg0C + 1)) != 0x00 && ((word32) (*((word32) dwArg0C + 2)) != 0x00 && ((word32) (*((word32) dwArg0C + 3)) != 0x00 && (word32) (*((word32) dwArg0C + 4)) != 0x00))))
	{
		byte * eax_35 = (word32) dwArg0C + 5;
		if ((word32) *((word32) dwArg0C + 5) != 0x00)
		{
			do
				++eax_35;
			while ((word32) *eax_35 != 0x00);
		}
	}
	word32 esi_153;
	word32 eax_70 = do_sym(dwArg04, dwArg10, dwArg08, gs, fp - 0x20, 0x00, out esi_153);
	if ((dwLoc0C ^ gs->t0014) == 0x00)
		return eax_70;
	word32 ecx_154;
	word32 edx_155;
	__stack_chk_fail(out ecx_154, out edx_155);
	word32 esi_156;
	return _dl_sym(gs, dwArg04, dwArg08, dwArg0C, out esi_156);
}

// 0809BF40: Register word32 _dl_sym(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 esiOut)
// Called from:
//      dlsym_doit
//      _dl_vsym
word32 _dl_sym(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & esiOut)
{
	ptr32 esi_17;
	word32 eax_11 = do_sym(dwArg04, dwArg0C, dwArg08, gs, 0x00, 0x02, out esi_17);
	esiOut = esi_17;
	return eax_11;
}

// 0809BF70: Register uint32 __udivdi3(Stack Eq_120921 qwArg04, Stack Eq_936 dwArg0C, Stack Eq_936 dwArg10, Register out Eq_120924 edxOut)
// Called from:
//      _dl_strtoul
uint32 __udivdi3(Eq_120921 qwArg04, Eq_936 dwArg0C, Eq_936 dwArg10, union Eq_120924 & edxOut)
{
	Eq_936 dwArg04 = (word32) qwArg04;
	Eq_936 dwArg08 = SLICE(qwArg04, word32, 32);
	uint32 eax_104;
	Eq_120924 edi_150;
	if (dwArg10 == 0x00)
	{
		if (dwArg0C <= dwArg08)
		{
			Eq_936 ecx_110 = dwArg0C;
			if (dwArg0C == 0x00)
				ecx_110.u1 = (uint32) (0x01 /u dwArg0C);
			uint64 edx_eax_125 = (uint64) dwArg08;
			edxOut.u0 = (uint32) (edx_eax_125 /u ecx_110);
			return (uint32) (SEQ((uint32) (edx_eax_125 % ecx_110), dwArg04) /u ecx_110);
		}
		edi_150.u0 = 0x00;
		eax_104 = (uint32) (qwArg04 /u dwArg0C);
	}
	else
	{
		if (dwArg10 > dwArg08)
		{
			edxOut.u0 = 0x00;
			return 0x00;
		}
		word32 edi_39 = __bsr(dwArg10);
		edi_150 = edi_39 ^ 0x1F;
		if ((edi_39 ^ 0x1F) == 0x00)
		{
			if (dwArg10 >= dwArg08)
			{
				eax_104 = 0x00;
				if (dwArg0C > dwArg04)
					goto l0809BF9B;
			}
			eax_104 = 0x01;
			goto l0809BF9B;
		}
		word32 eax_46 = 0x20 - (edi_39 ^ 0x1F);
		uint32 ecx_55 = dwArg10 << ((byte) edi_39 ^ 0x1F) | dwArg0C >> (byte) eax_46;
		uint64 edx_eax_74 = SEQ(dwArg08 >> (byte) eax_46, dwArg08 << ((byte) edi_39 ^ 0x1F) | dwArg04 >> (byte) eax_46);
		uint32 eax_77 = (uint32) (edx_eax_74 /u ecx_55);
		uint64 edx_eax_80 = (dwArg0C << ((byte) edi_39 ^ 0x1F)) *64 eax_77;
		uint32 edx_76 = (uint32) (edx_eax_74 % ecx_55);
		uint32 edx_81 = SLICE(edx_eax_80, word32, 32);
		uint32 eax_87 = (word32) edx_eax_80;
		if (edx_76 >= edx_81 && (dwArg04 << ((byte) edi_39 ^ 0x1F) >= eax_87 || edx_76 != edx_81))
		{
			eax_104 = eax_77;
			edi_150.u0 = 0x00;
		}
		else
		{
			eax_104 = eax_77 - 0x01;
			edi_150.u0 = 0x00;
		}
	}
l0809BF9B:
	edxOut = edi_150;
	return eax_104;
}

// 0809C080: Register uint32 __lttf2(Stack uint32 dwArg04, Stack uint32 dwArg08, Stack uint32 dwArg0C, Stack uint32 dwArg10, Stack uint32 dwArg14, Stack uint32 dwArg18, Stack uint32 dwArg1C, Stack uint32 dwArg20)
// Called from:
//      __printf_fp_l
//      __printf_fphex
uint32 __lttf2(uint32 dwArg04, uint32 dwArg08, uint32 dwArg0C, uint32 dwArg10, uint32 dwArg14, uint32 dwArg18, uint32 dwArg1C, uint32 dwArg20)
{
	ui32 ecx_112;
	uint32 dwLoc40_410;
	__fstcw();
	uint32 ebx_34 = (word32) (word16) dwArg10;
	uint32 esi_36 = (word32) (word16) dwArg20;
	uint32 eax_148 = dwArg20 >> 0x1F;
	int32 edx_49 = dwArg20 >> 0x10 & 0x7FFF;
	int32 esi_50 = dwArg10 >> 0x10 & 0x7FFF;
	if (esi_50 == 0x00)
	{
		if ((dwArg04 | dwArg08 | dwArg0C | ebx_34) != 0x00)
			ecx_112 = 0x02;
		else
		{
			ecx_112 = 0x00;
			if (edx_49 == 0x00)
			{
				ecx_112 = (word32) ((dwArg18 | dwArg14 | dwArg1C | esi_36) != 0x00) * 0x02;
l0809C136:
				ui32 esi_177 = dwArg04 | dwArg08 | dwArg0C | ebx_34;
				dwLoc40_410 = (uint32) (int8) (esi_177 == 0x00);
				if (edx_49 == 0x00 && (((dwArg18 | dwArg14) | dwArg1C) | esi_36) == 0x00)
				{
					eax_148 = 0x00;
					if (esi_177 != 0x00)
						goto l0809C173;
					goto l0809C287;
				}
				goto l0809C277;
			}
		}
		if (edx_49 != 0x7FFF)
			goto l0809C136;
		goto l0809C248;
	}
	if (edx_49 == 0x00)
	{
		ecx_112 = (word32) ((dwArg18 | dwArg14 | dwArg1C | esi_36) != 0x00) * 0x02;
		if (esi_50 != 0x7FFF)
		{
			if (esi_50 == 0x00)
				goto l0809C136;
			goto l0809C1F8;
		}
	}
	else
	{
		ecx_112 = 0x00;
		if (esi_50 != 0x7FFF)
		{
			if (edx_49 != 0x7FFF)
				goto l0809C20E;
			goto l0809C248;
		}
	}
	if ((dwArg04 | dwArg08 | dwArg0C | ebx_34) != 0x00)
	{
l0809C298:
		ecx_112 |= 0x01;
		eax_148 = 0x02;
l0809C2A0:
		__sfp_handle_exceptions((byte) ecx_112);
		return eax_148;
	}
	if (edx_49 == 0x7FFF)
	{
l0809C248:
		if ((dwArg18 | dwArg14 | dwArg1C | esi_36) == 0x00)
		{
			if (esi_50 == 0x00)
			{
				dwLoc40_410 = (uint32) (int8) ((dwArg04 | dwArg08 | dwArg0C | ebx_34) == 0x00);
l0809C277:
				if (dwLoc40_410 != 0x00)
					goto l0809C27F;
				goto l0809C20E;
			}
l0809C20E:
			if (dwArg10 >> 0x1F != dwArg20 >> 0x1F)
			{
				eax_148 = (0x00 - (word32) (dwArg10 >> 0x1F < 0x01) & 0x02) - 0x01;
				goto l0809C287;
			}
			if (esi_50 > edx_49)
			{
				if (dwArg20 >> 0x1F == 0x00)
				{
					eax_148 = 0x01;
					goto l0809C287;
				}
				goto l0809C317;
			}
			if (esi_50 < edx_49)
			{
l0809C27F:
				if (dwArg20 >> 0x1F != 0x00)
					goto l0809C287;
l0809C317:
				eax_148 = ~0x00;
				goto l0809C287;
			}
			if (ebx_34 <= esi_36)
			{
				if (ebx_34 != esi_36)
				{
					if (ebx_34 < esi_36)
						goto l0809C304;
					goto l0809C333;
				}
				byte SCZO_225 = cond(dwArg1C - dwArg0C);
				bool Z_227 = SLICE(SCZO_225, bool, 2);
				bool C_253 = SLICE(SCZO_225, bool, 1);
				if (dwArg1C >= dwArg0C)
				{
					if (dwArg1C != dwArg0C)
					{
						if (!(Z_227 | C_253))
							goto l0809C333;
						goto l0809C304;
					}
					if (dwArg18 >= dwArg08 && (dwArg18 != dwArg08 || dwArg14 >= dwArg04))
					{
						if (dwArg18 <= dwArg08)
						{
							if (dwArg14 <= dwArg04)
							{
l0809C333:
								eax_148 = 0x00;
								goto l0809C287;
							}
							if (dwArg18 != dwArg08)
							{
								eax_148 = 0x00;
								goto l0809C287;
							}
						}
l0809C304:
						eax_148 = ~0x00;
						if (dwArg10 >> 0x1F != 0x00)
							eax_148 = dwArg10 >> 0x1F;
l0809C287:
						if (ecx_112 == 0x00)
							return eax_148;
						goto l0809C2A0;
					}
				}
			}
l0809C173:
			eax_148 = (0x00 - (word32) (dwArg10 >> 0x1F < 0x01) & 0x02) - 0x01;
			if (ecx_112 == 0x00)
				return eax_148;
			goto l0809C2A0;
		}
		goto l0809C298;
	}
	if (edx_49 != 0x00)
		goto l0809C20E;
l0809C1F8:
	if ((dwArg18 | dwArg14 | dwArg1C | esi_36) == 0x00)
		goto l0809C173;
	goto l0809C20E;
}

// 0809C370: Register ui32 __unordtf2(Stack ui32 dwArg04, Stack ui32 dwArg08, Stack ui32 dwArg0C, Stack uint32 dwArg10, Stack ui32 dwArg14, Stack ui32 dwArg18, Stack ui32 dwArg1C, Stack uint32 dwArg20)
// Called from:
//      __printf_fp_l
//      __printf_fphex
ui32 __unordtf2(ui32 dwArg04, ui32 dwArg08, ui32 dwArg0C, uint32 dwArg10, ui32 dwArg14, ui32 dwArg18, ui32 dwArg1C, uint32 dwArg20)
{
	ui32 eax_192;
	ui32 esi_100;
	__fstcw();
	ci16 bx_34 = (word16) dwArg20;
	ci16 cx_37 = (word16) dwArg10;
	ui32 edx_35 = (word32) bx_34;
	ui32 edi_38 = (word32) cx_37;
	ui32 edx_43 = dwArg20 >> 0x10 & 0x7FFF;
	ui32 eax_121 = dwArg10 >> 0x10 & 0x7FFF;
	if (eax_121 == 0x00)
	{
		if ((dwArg04 | dwArg08 | dwArg0C | edi_38) != 0x00)
		{
			if (edx_43 == 0x7FFF && ((word32) bx_34 | ((dwArg14 | dwArg18) | dwArg1C)) != 0x00)
			{
				esi_100 = 0x02;
				goto l0809C418;
			}
			goto l0809C560;
		}
		if (edx_43 != 0x00)
		{
l0809C44C:
			if (edx_43 != 0x7FFF || (((dwArg14 | dwArg18) | dwArg1C) | edx_35) == 0x00)
				goto l0809C458;
			esi_100 = 0x00;
			if (eax_121 != 0x7FFF)
			{
l0809C418:
				if (bx_34 >= 0x00)
					goto l0809C421;
				goto l0809C4A9;
			}
l0809C523:
			if ((dwArg04 | dwArg08 | dwArg0C | edi_38) == 0x00)
				goto l0809C418;
			if (cx_37 >= 0x00)
			{
l0809C421:
				esi_100 |= 0x01;
				eax_121 = 0x01;
				goto l0809C429;
			}
l0809C53E:
			if (((word32) bx_34 | ((dwArg14 | dwArg18) | dwArg1C)) == 0x00)
				goto l0809C4A9;
			goto l0809C418;
		}
	}
	else if (edx_43 != 0x00)
	{
		if (eax_121 != 0x7FFF)
			goto l0809C44C;
		goto l0809C4CD;
	}
	if ((dwArg14 | dwArg18 | dwArg1C | edx_35) != 0x00)
	{
		if (eax_121 != 0x7FFF)
		{
			eax_121 = 0x00;
l0809C560:
			esi_100 = 0x02;
			goto l0809C429;
		}
		esi_100 = 0x02;
		if ((dwArg04 | dwArg08 | dwArg0C | edi_38) != 0x00)
		{
l0809C498:
			if (cx_37 >= 0x00)
				goto l0809C421;
			if (edx_43 != 0x7FFF)
			{
l0809C4A9:
				eax_121 = 0x01;
				goto l0809C4AE;
			}
			goto l0809C53E;
		}
l0809C4DB:
		if (edx_43 != 0x7FFF)
			eax_121 = 0x00;
		else
		{
			if ((dwArg14 | dwArg18 | dwArg1C | edx_35) != 0x00)
				goto l0809C523;
			eax_121 = 0x00;
		}
l0809C4AE:
		if (esi_100 == 0x00)
			return eax_121;
l0809C429:
		__sfp_handle_exceptions((byte) esi_100);
		eax_192 = eax_121;
		return eax_192;
	}
	if (eax_121 != 0x7FFF)
	{
l0809C458:
		eax_192 = 0x00;
		return eax_192;
	}
l0809C4CD:
	esi_100 = 0x00;
	if ((dwArg04 | dwArg08 | dwArg0C | edi_38) != 0x00)
		goto l0809C498;
	goto l0809C4DB;
}

// 0809C590: void __sfp_handle_exceptions(Stack byte bArg04)
// Called from:
//      __lttf2
//      __unordtf2
void __sfp_handle_exceptions(byte bArg04)
{
	byte al_7 = (byte) dwArg04;
	if ((al_7 & 0x02) != 0x00)
	{
		__fstenv(wLoc1C);
		__fldenv(wLoc1C);
		__wait();
	}
	if ((al_7 & 0x04) != 0x00)
		wLoc1C = 0x00;
	if ((al_7 & 0x08) != 0x00)
	{
		__fstenv(wLoc1C);
		__fldenv(wLoc1C);
		__wait();
	}
	if ((al_7 & 0x10) != 0x00)
	{
		__fstenv(wLoc1C);
		__fldenv(wLoc1C);
		__wait();
	}
}

// 0809C610: Register ptr32 read_encoded_value_with_base(Register ptr32 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out Eq_2 ecxOut, Register out Eq_143697 edxOut, Register out Eq_2 esiOut)
// Called from:
//      uw_frame_state_for
ptr32 read_encoded_value_with_base(ptr32 eax, Eq_2 ecx, struct Eq_9 * gs, word32 * dwArg04, union Eq_2 & ecxOut, union Eq_143697 & edxOut, union Eq_2 & esiOut)
{
	byte al = (byte) eax;
	word24 eax_24_8 = SLICE(eax, word24, 8);
	if (al == 0x50)
	{
		word32 * esi_28 = (word32) ecx + 3 & ~0x03;
		*dwArg04 = *esi_28;
		ecxOut = ecx;
		edxOut = esi_28 + 1;
		esiOut = esi;
		return esi_28 + 1;
	}
	else if ((al & 0x0F) > 0x0C)
		read_encoded_value_with_base.cold.6(ecx, gs);
	else
	{
		ui32 edx_51 = (word32) (al & 0x0F);
		<anonymous> * ecx_53 = g_a80B9E58[edx_51 * 0x04] + 0x080CE000;
		Eq_2 ecx_55;
		Eq_143697 edx_56;
		ptr32 eax_57;
		ecx_53();
		ecxOut = ecx_55;
		edxOut = edx_56;
		esiOut = ecx;
		return eax_57;
	}
}

// 0809C760: void base_of_encoded_value(Register byte al, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_frame_state_for
void base_of_encoded_value(byte al, Eq_2 ecx, struct Eq_9 * gs)
{
	byte al = (byte) eax;
	if (al == ~0x00)
		return;
	if ((al & 0x70) == 0x20)
		return;
	if ((al & 0x70) > 0x20)
	{
		if ((al & 0x70) == 0x40)
			return;
		if ((al & 0x70) == 0x50)
			return;
		if ((al & 0x70) == 0x30)
			return;
	}
	else if ((al & 0x70) == 0x00 || (al & 0x70) == 0x10)
		return;
	word32 edx_76;
	word32 ecx_75;
	abort(ecx, gs, out ecx_75, out edx_76);
}

// 0809C7C0: Register (ptr32 Eq_143773) execute_cfa_program(Register Eq_2 eax, Register (ptr32 Eq_143773) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_143777 dwArg04, Register out Eq_2 edxOut, Register out ptr32 ediOut)
// Called from:
//      base_of_encoded_value
//      uw_frame_state_for
struct Eq_143773 * execute_cfa_program(Eq_2 eax, struct Eq_143773 * ecx, Eq_2 edx, struct Eq_9 * gs, Eq_143777 dwArg04, union Eq_2 & edxOut, ptr32 & ediOut)
{
	*((word32) dwArg04 + 144) = 0x00;
	if (eax < edx)
	{
		edx = *((word32) dwArg04 + 0x00A4);
		if (edx < (ecx->dw0060 >> 0x1F) + ecx->dw004C)
		{
			Eq_2 esi_107 = eax;
			do
			{
				ui32 eax_44 = (word32) *esi_107;
				cu8 al_136 = (byte) eax_44;
				Eq_2 ebx_45 = (word32) esi_107 + 1;
				ecx = eax_44 & ~0x3F;
				byte cl_48 = (byte) eax_44 & 0xC0;
				if (cl_48 != 0x40)
				{
					if (cl_48 != 0x80)
					{
						if (cl_48 != 0xC0)
						{
							if (al_136 > 0x2F)
								execute_cfa_program.cold.7(eax_44 & ~0x3F, gs);
							else
							{
								<anonymous> * ecx_145 = g_a80B9E8C[eax_44 * 0x04] + 0x080CE000;
								Eq_2 edx_153;
								struct Eq_143773 * ecx_154;
								ecx_145();
								edxOut = edx_153;
								ediOut = 0x080CE000;
								return ecx_154;
							}
						}
						cu8 al_102 = (byte) eax_44 & 0x3F;
						edx = (word32) al_102;
						if (al_102 <= 0x11)
						{
							*((word32) dwArg04 + (edx * 0x08 + 4)) = 0x00;
							esi_107 = ebx_45;
						}
						else
							esi_107 = ebx_45;
					}
					else
					{
						cu8 al_67 = (byte) eax_44 & 0x3F;
						int32 edi_63 = 0x00;
						ui32 esi_68 = (word32) al_67;
						esi_107 = ebx_45;
						uip32 ecx_247 = 0x00;
						do
						{
							esi_107 = (word32) esi_107 + 1;
							ui32 ebx_74 = (word32) *((word32) esi_107 - 1);
							byte cl_77 = (byte) ecx_247;
							edx = (ebx_74 & 0x7F) << cl_77;
							ecx = ecx_247 + 0x07;
							edi_63 |= edx;
							ecx_247 = SEQ(SLICE(ecx_247 + 0x07, word24, 8), cl_77 + 0x07);
						} while ((byte) ebx_74 < 0x00);
						int32 edi_90 = edi_63 *s *((word32) dwArg04 + 0x00AC);
						if (al_67 <= 0x11)
						{
							struct Eq_143915 * eax_96 = (word32) dwArg04 + esi_68 * 0x08;
							eax_96->dw0004 = 0x01;
							eax_96->dw0000 = edi_90;
						}
					}
				}
				else
				{
					*((word32) dwArg04 + 0x00A4) = (word32) edx + (eax_44 & 0x3F) *s *((word32) dwArg04 + 0x00B0);
					esi_107 = ebx_45;
				}
				if (edx <= esi_107)
					break;
				edx = *((word32) dwArg04 + 0x00A4);
			} while (edx < (ecx->dw0060 >> 0x1F) + ecx->dw004C);
		}
	}
	edxOut = edx;
	ediOut = edi;
	return ecx;
}

// 0809D050: void init_dwarf_reg_size_table()
void init_dwarf_reg_size_table()
{
	g_t80CFB54.t0000 = 0x04;
	g_b80CFB56 = 0x04;
	g_b80CFB55 = 0x04;
	g_b80CFB57 = 0x04;
	g_b80CFB5A = 0x04;
	g_b80CFB5B = 0x04;
	g_b80CFB59 = 0x04;
	g_b80CFB58 = 0x04;
	g_b80CFB5F = 0x0C;
	g_b80CFB60 = 0x0C;
	g_b80CFB61 = 0x0C;
	g_b80CFB62 = 0x0C;
	g_b80CFB63 = 0x0C;
	g_b80CFB64 = 0x0C;
	g_b80CFB5D = 0x04;
	g_b80CFB5C = 0x04;
}

// 0809D0D0: Register Eq_2 uw_frame_state_for(Register Eq_2 eax, Register Eq_143777 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_143777 edxOut)
// Called from:
//      uw_init_context_1
//      _Unwind_RaiseException_Phase2
//      _Unwind_ForcedUnwind_Phase2
//      __frame_state_for
//      _Unwind_RaiseException
//      _Unwind_Backtrace
Eq_2 uw_frame_state_for(Eq_2 eax, Eq_143777 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_143777 & edxOut)
{
	word32 ecx_27;
	Eq_143777 edi_26 = edx;
	for (ecx_27 = 0x30; ecx_27 != 0x00; --ecx_27)
	{
		*edi_26 = 0x00;
		edi_26 = (word32) edi_26 + 4;
	}
	((word32) eax + 0x0068)->u0 = 0x00;
	((word32) eax + 80)->u0 = 0x00;
	Eq_2 ecx_31 = *((word32) eax + 76);
	if (ecx_31 != 0x00)
	{
		Eq_2 ecx_123;
		Eq_143777 edx_603;
		struct Eq_144009 * eax_54 = _Unwind_Find_FDE(gs, ecx_31 - 0x01 + (*((word32) eax + 96) >> 0x1F), (word32) eax + 84, out edx);
		if (eax_54 != null)
		{
			*((word32) edx + 0x00A4) = *((word32) eax + 92);
			struct Eq_144049 * eax_151 = &eax_54->dw0004 - eax_54->dw0004;
			struct Eq_144056 * dwLoc38_724 = &eax_151->b0009;
			struct Eq_144059 * esp_168 = fp - 0x4C;
			word32 ecx_920;
			Eq_143777 edx_163;
			word32 eax_170 = eax_151 + 0x0A + strlen(&eax_151->b0009, out ecx_920, out edx_163);
			if (eax_151->b0009 == 101 && eax_151->b000A == 0x68)
			{
				edx_163 = *eax_170;
				*((word32) edx + 188) = edx_163;
				eax_170 = (word32) eax_170 + 4;
				dwLoc38_724 = (struct Eq_144056 *) (&eax_151->b000A + 1);
			}
			Eq_2 ecx_184 = (word32) eax_151->b0008;
			ui32 ebx_186 = (word32) *eax_170;
			cu8 cl_187 = (byte) ecx_184;
			byte bl_191 = (byte) ebx_186;
			if (cl_187 > 0x03)
			{
				if (bl_191 != 0x04 || *((word32) eax_170 + 1) != 0x00)
					goto l0809D4EC;
				ebx_186 = (word32) *((word32) eax_170 + 2);
				eax_170 = (word32) eax_170 + 2;
			}
			int32 esi_199 = 0x00;
			uip32 ecx_903 = 0x00;
			while (true)
			{
				byte cl_208 = (byte) ecx_903;
				eax_170 = (word32) eax_170 + 1 + 0x02;
				word24 ecx_24_8_665 = SLICE(ecx_903 + 0x07, word24, 8);
				esi_199 |= (ebx_186 & 0x7F) << cl_208;
				if ((byte) ebx_186 >= 0x00)
					break;
				ebx_186 = (word32) *eax_170;
				ecx_903 = SEQ(ecx_24_8_665, cl_208 + 0x07);
			}
			*((word32) edx + 0x00B0) = esi_199;
			int32 ebp_225 = 0x00;
			up32 ecx_906 = 0x00;
			while (true)
			{
				Eq_2 esi_230 = (word32) eax_170 + 1;
				ui32 ebx_232 = (word32) *((word32) esi_230 - 1);
				byte cl_235 = (byte) ecx_906;
				word24 ecx_24_8_669 = SLICE(ecx_906 + 0x07, word24, 8);
				ebp_225 |= (ebx_232 & 0x7F) << cl_235;
				if ((byte) ebx_232 >= 0x00)
					break;
				eax_170 = esi_230;
				ecx_906 = SEQ(ecx_24_8_669, cl_235 + 0x07);
			}
			Eq_2 ebx_249 = esi_230;
			if (ecx_906 <= 0x18 && (ebx_232 & 0x40) != 0x00)
				ebp_225 |= ~0x00 << cl_235 + 0x07;
			*((word32) edx + 0x00AC) = ebp_225;
			if (cl_187 != 0x01)
			{
				Eq_143777 esi_281 = 0x00;
				uip32 ecx_909 = 0x00;
				do
				{
					ebx_249 = (word32) ebx_249 + 1;
					edx_163 = (word32) *((word32) ebx_249 - 1);
					byte cl_288 = (byte) ecx_909;
					esi_281 |= (edx_163 & 0x7F) << cl_288;
					ecx_909 = SEQ(SLICE(ecx_909 + 0x07, word24, 8), cl_288 + 0x07);
				} while ((byte) edx_163 < 0x00);
				*((word32) edx + 0x00B4) = esi_281;
			}
			else
			{
				edx_163 = (word32) *esi_230;
				*((word32) edx + 0x00B4) = edx_163;
				ebx_249 = eax_170;
			}
			((word32) edx + 0x00B9)->u0 = ~0x00;
			byte al_309 = dwLoc38_724->b0000;
			if (al_309 == 122)
			{
				do
				{
					ebx_249 = (word32) ebx_249 + 1;
					edx_163 = (word32) *((word32) ebx_249 - 1);
				} while ((byte) edx_163 < 0x00);
				((word32) edx + 0x00BA)->u0 = 0x01;
				al_309 = dwLoc38_724->b0001;
				dwLoc38_724 = (struct Eq_144056 *) &dwLoc38_724->b0001;
			}
			ecx_184 = fp - 0x20;
			Eq_2 ebp_351 = ebx_249;
			byte * esi_353 = &dwLoc38_724->b0001;
			while (true)
			{
				Eq_2 ebp_363;
				if (al_309 == 0x00)
					break;
				if (al_309 == 0x4C)
				{
					*((word32) edx + 0x00B9) = *ebp_351;
					ebp_351 = (word32) ebp_351 + 1;
				}
				else if (al_309 != 0x52)
				{
					if (al_309 != 0x50)
					{
						if (al_309 != 0x53)
						{
							ebp_363 = esp_168->t001C;
							goto l0809D4E4;
						}
						((word32) edx + 0x00BB)->u0 = 0x01;
					}
					else
					{
						ptr32 ebx_380 = (word32) *ebp_351;
						base_of_encoded_value((byte) ebx_380, ecx_184, gs);
						struct Eq_144427 * esp_390 = esp_168 - 0x0C;
						esp_390->ptrFFFFFFFC = esp_390->ptr0020;
						Eq_2 esp_402 = <invalid>;
						ebp_351 = read_encoded_value_with_base(ebx_380, (word32) ebp_351 + 1, gs, esp_390->ptrFFFFFFFC, out ecx_184, out edx_163, out esi_353);
						*((word32) edx + 0x00A8) = *((word32) esp_402 + 60);
						esp_168 = (word32) esp_402 + 16;
					}
				}
				else
				{
					*((word32) edx + 0x00B8) = *ebp_351;
					ebp_351 = (word32) ebp_351 + 1;
				}
				al_309 = *esi_353;
				++esi_353;
			}
			ebp_363 = esp_168->t001C;
			if (ebp_363 != 0x00)
			{
l0809D34E:
				word32 ebx_455;
				int32 * ecx_424 = esp_168->ptr0018;
				struct Eq_144470 * esp_425 = esp_168 - 0x0C;
				int32 eax_427 = *ecx_424;
				esp_425->tFFFFFFFC = edx;
				Eq_143777 edi_445;
				word32 edx_921;
				Eq_2 ecx_443 = execute_cfa_program(ebp_363, esp_425->ptr0014, ecx_424 + 1 + eax_427, gs, esp_425->tFFFFFFFC, out edx_921, out edi_445);
				Eq_2 esp_439 = <invalid>;
				word32 eax_450 = (word32) *((word32) edi_445 + 0x00B8);
				struct Eq_144503 * esp_451 = (word32) esp_439 + 16;
				if ((byte) eax_450 == ~0x00)
				{
					ebx_455 = 0x08;
					goto l0809D39F;
				}
				cu8 al_457 = (byte) eax_450 & 0x07;
				if (al_457 == 0x02)
				{
					ebx_455 = 0x0C;
					goto l0809D39F;
				}
				if (al_457 > 0x02)
				{
					if (al_457 != 0x03)
					{
						if (al_457 == 0x04)
						{
							ebx_455 = 0x18;
l0809D39F:
							Eq_2 eax_519;
							Eq_2 esi_518;
							Eq_2 ebx_481 = (word32) *((word32) esp_439 + 28) + ebx_455;
							Eq_2 ebp_485 = (word32) *((word32) edi_445 + 0x00B9);
							if (*((word32) edi_445 + 0x00BA) != 0x00)
							{
								ui32 esi_498 = 0x00;
								uip32 ecx_915 = 0x00;
								do
								{
									ebx_481 = (word32) ebx_481 + 1;
									ui32 edx_502 = (word32) *((word32) ebx_481 - 1);
									byte cl_505 = (byte) ecx_915;
									esi_498 |= (edx_502 & 0x7F) << cl_505;
									ecx_915 = SEQ(SLICE(ecx_915 + 0x07, word24, 8), cl_505 + 0x07);
								} while ((byte) edx_502 < 0x00);
								ecx_443 = ebp_485;
								esi_518 = (word32) ebx_481 + esi_498;
								eax_519 = ebx_481;
								if ((byte) ebp_485 == ~0x00)
								{
l0809D3E2:
									if (esi_518 != 0x00)
										eax_519 = esi_518;
									ebx_481 = eax_519;
l0809D3E9:
									int32 * ecx_582 = esp_451->ptr000C;
									struct Eq_144619 * esp_583 = esp_451 - 0x0C;
									int32 eax_585 = *ecx_582;
									esp_583->tFFFFFFFC = edi_445;
									word32 edi_926;
									ecx_123 = execute_cfa_program(ebx_481, esp_583->ptr0014, ecx_582 + 1 + eax_585, gs, esp_583->tFFFFFFFC, out edx_603, out edi_926);
l0809D407:
									ecxOut = ecx_123;
									edxOut = edx_603;
									return 0x00;
								}
							}
							else if ((byte) ebp_485 == ~0x00)
								goto l0809D3E9;
							ptr32 ebp_530 = (word32) (byte) ebp_485;
							base_of_encoded_value((byte) ebp_530, ecx_443, gs);
							*esp_439 = (word32) esp_439 + 60;
							word32 ecx_924;
							word32 edx_925;
							eax_519 = read_encoded_value_with_base(ebp_530, ebx_481, gs, *esp_439, out ecx_924, out edx_925, out esi_518);
							Eq_2 esp_557 = <invalid>;
							*((word32) *((word32) esp_557 + 24) + 80) = *((word32) esp_557 + 60);
							esp_451 = (word32) esp_557 + 16;
							goto l0809D3E2;
						}
l0809D61E:
						word32 ecx_922;
						word32 edx_923;
						abort(ecx_443, gs, out ecx_922, out edx_923);
					}
				}
				else if (al_457 != 0x00)
					goto l0809D61E;
				ebx_455 = 0x10;
				goto l0809D39F;
			}
			ebp_363 = ebp_351;
l0809D4E4:
			if (ebp_363 != 0x00)
				goto l0809D34E;
l0809D4EC:
			ecxOut = ecx_184;
			edxOut = edx_163;
			return 0x03;
		}
		struct Eq_144030 * eax_73;
		ecx_31 = *((word32) eax + 72);
		Eq_2 eax_66 = *((word32) eax + 76);
		if (*eax_66 == 0xB858 && (*((word32) eax_66 + 2) == 0x77 && *((word32) eax_66 + 6) == 0x80CD))
		{
			eax_73 = (word32) ecx_31 + 4;
l0809D546:
			edx_603 = eax_73->t001C;
			*((word32) edx + 4) = 0x01;
			*((word32) edx + 0x00A0) = 0x01;
			*((word32) edx + 28) = 0x01;
			*((word32) edx + 0x0098) = 0x04;
			*((word32) edx + 0x0094) = edx_603 - ecx_31;
			*edx = (char *) &eax_73->t001C + 16 - edx_603;
			*((word32) edx + 0x0C) = 0x01;
			*((word32) edx + 24) = (char *) &eax_73->t001C + 4 - edx_603;
			*((word32) edx + 20) = 0x01;
			*((word32) edx + 8) = (char *) &eax_73->t001C + 0x0C - edx_603;
			*((word32) edx + 52) = 0x01;
			*((word32) edx + 16) = (char *) &eax_73->t001C + 8 - edx_603;
			*((word32) edx + 60) = 0x01;
			*((word32) edx + 48) = (char *) eax_73 + 20 - edx_603;
			*((word32) edx + 44) = 0x01;
			*((word32) edx + 56) = (char *) eax_73 + 16 - edx_603;
			*((word32) edx + 0x0044) = 0x01;
			*((word32) edx + 64) = (char *) &eax_73->t001C + 28 - edx_603;
			ecx_123 = (char *) eax_73 + 24 - edx_603;
			*((word32) edx + 40) = ecx_123;
			((word32) edx + 0x00B4)->u0 = 0x08;
			((word32) edx + 0x00BB)->u0 = 0x01;
			goto l0809D407;
		}
		if (*eax_66 == 0xB8 && (*((word32) eax_66 + 1) == 0xAD && *((word32) eax_66 + 5) == 0x80CD))
		{
			eax_73 = (word32) ecx_31 + 0x00A0;
			goto l0809D546;
		}
	}
	ecxOut = ecx_31;
	edxOut = edx;
	return 0x05;
}

// 0809D630: Register (ptr32 Eq_144666) execute_stack_op(Register (ptr32 Eq_144666) eax, Register (ptr32 Eq_144666) edx, Stack (ptr32 Eq_144666) dwArg04, Register out (ptr32 Eq_144666) edxOut, Register out (ptr32 Eq_144670) ebpOut)
// Called from:
//      uw_frame_state_for
//      uw_update_context_1
struct Eq_144666 * execute_stack_op(struct Eq_144666 * eax, struct Eq_144666 * edx, struct Eq_144666 * dwArg04, struct Eq_144666 & edxOut, struct Eq_144670 & ebpOut)
{
	if (eax >= edx)
	{
		edxOut = edx;
		ebpOut = ebp;
		return dwArg04;
	}
	else
	{
		Mem35 = Mem32;
		word32 eax_36 = (word32) eax->b0000;
		cu8 cl_40 = (byte) eax_36 - 0x03;
		if (cl_40 > ~0x11)
		{
			word32 ecx_142;
			word32 edx_143;
			abort(eax_36 - 0x03, gs, out ecx_142, out edx_143);
		}
		else
		{
			ui32 ecx_88 = (word32) cl_40;
			struct Eq_144670 * ebp_90 = g_a80B9F4C[ecx_88 * 0x04] + 0x080CE000;
			struct Eq_144666 * eax_94;
			struct Eq_144666 * edx_95;
			ebp_90();
			edxOut = edx_95;
			ebpOut = ebp_90;
			return eax_94;
		}
	}
}

// 0809DD30: Register Eq_2 uw_update_context_1(Register Eq_2 eax, Register Eq_143777 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_144713 ebxOut, Register out Eq_143777 ebpOut, Register out Eq_2 esiOut, Register out (ptr32 code) ediOut)
// Called from:
//      uw_init_context_1
//      uw_update_context
Eq_2 uw_update_context_1(Eq_2 eax, Eq_143777 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_144713 & ebxOut, union Eq_143777 & ebpOut, union Eq_2 & esiOut, <anonymous> & ediOut)
{
	Eq_2 ecx_262;
	Eq_143777 ebp_120 = edx;
	word32 * edi_23 = fp - 0x9C;
	Eq_2 esi_256 = eax;
	for (ecx_262 = 0x20; ecx_262 != 0x00; --ecx_262)
	{
		*edi_23 = (word32) *esi_256;
		esi_256 = (word32) esi_256 + 4;
		++edi_23;
	}
	if (((dwLoc3C & 0x40000000) == 0x00 || bLoc2C == 0x00) && dwLoc8C == 0x00)
	{
		if (g_b80CFB58 != 0x04)
			uw_update_context_1.cold.9(ecx_262, gs);
		if ((dwLoc3C & 0x40000000) != 0x00)
			bLoc2C = 0x00;
		dwLoc8C = fp - 0xA0;
	}
	if ((*((word32) eax + 99) & 0x40) != 0x00)
		*((word32) eax + 112) = 0x00;
	ui32 edx_124;
	*((word32) eax + 16) = 0x00;
	word32 eax_77 = *((word32) edx + 0x00A0);
	if (eax_77 == 0x01)
	{
		int32 eax_134 = *((word32) edx + 0x0098);
		if (eax_134 > 0x11)
			uw_update_context_1.cold.9(ecx_262, gs);
		edx_124 = dwLoc3C & 0x40000000;
		Eq_2 ecx_144 = (fp - 0x9C)[eax_134];
		byte bl_150 = (&g_t80CFB54)[eax_134];
		if (((dwLoc3C & 0x40000000) == 0x00 || (&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((fp - 0x30))[eax_134].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000))[0].a0000)[0] == 0x00) && bl_150 != 0x04)
			uw_update_context_1.cold.9(ecx_144, gs);
	}
	else
	{
		if (eax_77 != 0x02)
		{
			word32 ecx_455;
			word32 edx_456;
			abort(ecx_262, gs, out ecx_455, out edx_456);
		}
		struct Eq_144666 * eax_89 = *((word32) edx + 0x009C);
		int32 esi_106 = 0x00;
		uip32 ecx_448 = 0x00;
		do
		{
			++eax_89;
			ui32 ebx_98 = (word32) eax_89->bFFFFFFFF;
			byte cl_101 = (byte) ecx_448;
			esi_106 |= (ebx_98 & 0x7F) << cl_101;
			ecx_448 = SEQ(SLICE(ecx_448 + 0x07, word24, 8), cl_101 + 0x07);
		} while ((byte) ebx_98 < 0x00);
		Eq_2 esp_126 = <invalid>;
		*((word32) esp_126 + 24) = execute_stack_op(eax_89, eax_89 + esi_106, null, out edx_124, out ebp_120);
	}
	*((word32) dwArg00 + 72) = dwArg08;
	Eq_144713 ebx_170 = 0x00;
	do
	{
		if (*((word32) ebp_120 + (ebx_170 * 0x08 + 4)) <= 0x05)
		{
			ui32 eax_234 = *((word32) ebp_120 + (ebx_170 * 0x08 + 4));
			word32 edi_236 = (dwArg04 + ~0x00013CA3)[eax_234 * 0x04] + dwArg04;
			Eq_2 ecx_252;
			edi_236();
			ebxOut = ebx_170;
			ebpOut = ebp_120;
			esiOut = dwArg04;
			ediOut = edi_236;
			return ecx_252;
		}
		ebx_170 = (word32) ebx_170.u0 + 1;
	} while (ebx_170 != 0x12);
	Eq_2 edx_188 = *((word32) dwArg00 + 96);
	Eq_2 eax_190 = edx_188 & 0x7FFFFFFF;
	if (*((word32) ebp_120 + 0x00BB) != 0x00)
		eax_190 = edx_188 | 0x80000000;
	Eq_2 edx_200 = *((word32) dwArg00 + 76);
	*((word32) dwArg00 + 96) = eax_190;
	if (*edx_200 == 0xB8 && *((word32) edx_200 + 1) == 0xAD)
	{
		Eq_53608 dx_208 = *((word32) edx_200 + 5);
		if (dx_208 == 0x80CD || dx_208 == 0x050F)
			*((word32) dwArg00 + 96) = eax_190 | 0x80000000;
	}
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return dwArg00;
}

// 0809E0B0: void uw_init_context_1(Register Eq_2 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00)
// Called from:
//      uw_update_context_1
//      _Unwind_RaiseException
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
//      _Unwind_Backtrace
void uw_init_context_1(Eq_2 eax, Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg00)
{
	Eq_2 edi_146 = eax;
	word32 ecx_149;
	for (ecx_149 = 0x20; ecx_149 != 0x00; --ecx_149)
	{
		*edi_146 = 0x00;
		edi_146 = (word32) edi_146 + 4;
	}
	((word32) eax + 96)->u0 = 0x40000000;
	*((word32) eax + 76) = dwArg00;
	Eq_2 ecx_40;
	word32 edx_41;
	if (uw_frame_state_for(eax, fp - 220, gs, out ecx_40, out edx_41) != 0x00)
		uw_init_context_1.cold.10(ecx_40, gs);
	else
	{
		Mem73 = Mem36;
		if (g_t80CFB54.t0000 == 0x00)
		{
			g_t80CFB54.t0000 = 0x04;
			g_b80CFB56 = 0x04;
			g_b80CFB55 = 0x04;
			g_b80CFB57 = 0x04;
			g_b80CFB5A = 0x04;
			g_b80CFB5B = 0x04;
			g_b80CFB59 = 0x04;
			g_b80CFB58 = 0x04;
			g_b80CFB5F = 0x0C;
			g_b80CFB60 = 0x0C;
			g_b80CFB61 = 0x0C;
			g_b80CFB62 = 0x0C;
			g_b80CFB63 = 0x0C;
			g_b80CFB64 = 0x0C;
			g_b80CFB5D = 0x04;
			g_b80CFB5C = 0x04;
		}
		if (g_b80CFB58 != 0x04)
			uw_init_context_1.cold.10(ecx_40, gs);
		else
		{
			if ((*((word32) eax + 99) & 0x40) != 0x00)
				*((word32) eax + 112) = 0x00;
			*((word32) eax + 16) = fp - 0xE0;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 esi_197;
			word32 edi_198;
			word32 ebx_195;
			word32 ebp_196;
			uw_update_context_1(eax, fp - 220, gs, stackArg0, stackArg4, stackArg8, out ebx_195, out ebp_196, out esi_197, out edi_198);
			*((word32) eax + 76) = ecx;
		}
	}
}

// 0809E210: Register word32 uw_update_context(Register Eq_2 eax, Register Eq_143777 edx, Register Eq_2 ebx, Register Eq_2 esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_RaiseException_Phase2
//      _Unwind_ForcedUnwind_Phase2
//      _Unwind_RaiseException
//      _Unwind_Backtrace
word32 uw_update_context(Eq_2 eax, Eq_143777 edx, Eq_2 ebx, Eq_2 esi, struct Eq_9 * gs)
{
	word32 ebp_22;
	struct Eq_145086 * ebx_23;
	struct Eq_145087 * edi_26;
	struct Eq_145088 * esi_27;
	Eq_2 ecx_24 = uw_update_context_1(eax, edx, gs, dwLoc10, ebx, esi, out ebx_23, out ebp_22, out esi_27, out edi_26);
	int32 eax_32 = edi_26->dw00B4;
	if (edi_26->a0004[eax_32].dw0000 != 0x06)
	{
		if (eax_32 > 0x11)
			uw_update_context.cold.11(ecx_24, gs);
		else
		{
			Eq_2 ecx_37 = (word32) ebx_23->a1B54[eax_32];
			byte cl_45 = (byte) ecx_37;
			struct Eq_145110 * edx_38 = esi_27[eax_32 * 0x04 / 0x006C];
			if ((esi_27->b0063 & 0x40) == 0x00 || (esi_27->a006C)[eax_32] == 0x00)
			{
				if (cl_45 != 0x04)
					uw_update_context.cold.11(ecx_37, gs);
				edx_38 = edx_38->ptr0000;
			}
			esi_27->ptr004C = edx_38;
			return;
		}
	}
	else
	{
		esi_27->ptr004C = null;
		return;
	}
}

// 0809E280: Register Eq_2 _Unwind_RaiseException_Phase2(Register Eq_2 eax, Register Eq_143777 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut)
// Called from:
//      _Unwind_RaiseException
//      _Unwind_Resume
Eq_2 _Unwind_RaiseException_Phase2(Eq_2 eax, Eq_143777 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut)
{
	struct Eq_145157 * ebp_119 = (struct Eq_145157 *) 0x01;
	while (true)
	{
		word32 ecx_198;
		word32 edx_199;
		Eq_2 eax_34 = uw_frame_state_for(edx, fp - 220, gs, out ecx_198, out edx_199);
		Eq_2 ecx_109 = *((word32) edx + 72) - (*((word32) edx + 96) >> 0x1F);
		ui32 edx_50 = (word32) (*((word32) eax + 16) == ecx_109);
		if (eax_34 != 0x00)
			break;
		if (dwLoc34 != null)
		{
			ui32 ecx_64 = edx_50 << 0x02 | 0x02;
			Eq_2 eax_82;
			dwLoc34();
			if (eax_82 == 0x07)
			{
				*ecx = ebp_119;
				ecxOut = ecx_109;
				return eax_82;
			}
			if (eax_82 != 0x08)
				break;
		}
		if (edx_50 << 0x02 != 0x00)
			_Unwind_RaiseException_Phase2.cold.12(ecx_109, gs);
		ebp_119 = uw_update_context(edx, fp - 220, edx, eax, gs);
	}
	ecxOut = ecx_109;
	return 0x02;
}

// 0809E350: Register Eq_2 _Unwind_ForcedUnwind_Phase2(Register Eq_2 eax, Register (ptr32 (ptr32 Eq_145157)) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut)
// Called from:
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
Eq_2 _Unwind_ForcedUnwind_Phase2(Eq_2 eax, struct Eq_145157 ** ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut)
{
	struct Eq_145157 * ebp_133 = (struct Eq_145157 *) 0x01;
	<anonymous> * eax_23 = *((word32) eax + 0x0C);
	word32 eax_28 = *((word32) eax + 16);
	while (true)
	{
		word32 edx_293;
		word32 ecx_292;
		Eq_2 eax_35 = uw_frame_state_for(edx, fp - 220, gs, out ecx_292, out edx_293);
		Eq_2 ecx_113 = eax_35;
		if (eax_35 != 0x00 && eax_35 != 0x05)
			break;
		Eq_2 ebp_119;
		word32 eax_52 = *eax;
		word32 edx_53 = *((word32) eax + 4);
		if (eax_35 == 0x05)
		{
			word32 eax_161;
			eax_23();
			ebp_119 = eax_35;
			if (eax_161 != 0x00)
				break;
			goto l0809E424;
		}
		word32 edx_83;
		word32 eax_84;
		eax_23();
		if (eax_84 != 0x00)
			break;
		if (dwLoc34 != null)
		{
			Eq_2 eax_112;
			dwLoc34();
			if (eax_112 != 0x07)
			{
				if (eax_112 != 0x08)
					break;
				goto l0809E3C4;
			}
			ebp_119 = eax_112;
l0809E424:
			*ecx = (struct Eq_145157 **) ebp_133;
			ecxOut = ecx_113;
			return ebp_119;
		}
l0809E3C4:
		ebp_133 = uw_update_context(edx, fp - 220, eax, edx, gs);
	}
	ecxOut = ecx_113;
	return 0x02;
}

// 0809E440: Register (ptr32 Eq_145277) uw_install_context_1(Register (ptr32 Eq_145277) eax, Register (ptr32 Eq_145278) edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_RaiseException
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
struct Eq_145277 * uw_install_context_1(struct Eq_145277 * eax, struct Eq_145278 * edx, struct Eq_9 * gs)
{
	ui32 eax_22 = edx->dw0060;
	if (((eax_22 & 0x40000000) == 0x00 || edx->b0070 == 0x00) && edx->ptr0010 == null)
	{
		Eq_2 ecx_37 = edx->t0048;
		if (g_b80CFB58 != 0x04)
			uw_install_context_1.cold.13(ecx_37, gs);
		if ((eax_22 & 0x40000000) != 0x00)
			edx->b0070 = 0x00;
		edx->ptr0010 = fp - 0x20;
	}
	struct Eq_145298 * eax_106 = null;
	do
	{
		Eq_2 ecx_68 = eax[eax_106];
		Eq_2 esi_69 = edx[eax_106 * 0x04 / 113];
		if (Mem63[eax + 0x6C + eax_106:byte] != 0x00)
			uw_install_context_1.cold.13(ecx_68, gs);
		if (Mem63[edx + 0x6C + eax_106:byte] == 0x00)
		{
			if (((int8) (esi_69 != 0x00) & (int8) (ecx_68 != 0x00)) != 0x00 && ecx_68 != esi_69)
			{
				union Eq_2 * ebp_102 = (word32) ((char *) eax_106 + 6996)[0x080CE000];
				if (ebp_102 >= (union Eq_2 *) 0x04)
				{
					*ecx_68 = *esi_69;
					Mem109[ecx_68 - 0x04 + ebp_102:word32] = Mem107[esi_69 - 0x04 + ebp_102:word32];
					word32 edi_111 = ecx_68 + 0x04 & ~0x03;
					word32 * ecx_112 = ecx_68 - edi_111;
					++eax_106;
					word32 * esi_113 = esi_69 - ecx_112;
					word32 ecx_115;
					for (ecx_115 = ecx_112 + ebp_102 >>u 0x02; ecx_115 != 0x00; --ecx_115)
					{
						*edi_111 = *esi_113;
						++esi_113;
						edi_111 += 4;
					}
					if (eax_106 == (struct Eq_145298 *) 0x11)
						break;
					continue;
				}
				if (ebp_102 != null)
				{
					*ecx_68 = *esi_69;
					if ((ebp_102 & 0x02) != 0x00)
						Mem141[ecx_68 - 0x02 + ebp_102:word16] = Mem135[esi_69 - 0x02 + ebp_102:word16];
				}
			}
		}
		else if (ecx_68 != 0x00)
		{
			if (Mem63[eax_106 + 6996 + 0x080CE000<p32>:byte] != 0x04)
				uw_install_context_1.cold.13(ecx_68, gs);
			*ecx_68 = esi_69;
		}
		eax_106 = (struct Eq_145298 *) ((char *) eax_106 + 1);
	} while (eax_106 != (struct Eq_145298 *) 0x11);
	struct Eq_145277 * eax_153 = null;
	if ((eax->b0063 & 0x40) != 0x00 && eax[28] != 0x00)
		return null;
	if (eax[4] != 0x00)
		return eax_153;
	Eq_2 ecx_177 = (word32) g_b80CFB58;
	byte cl_186 = (byte) ecx_177;
	struct Eq_145290 * eax_179 = edx->ptr0010;
	if ((edx->b0063 & 0x40) == 0x00 || edx->b0070 == 0x00)
	{
		if (cl_186 != 0x04)
			uw_install_context_1.cold.13(ecx_177, gs);
		eax_179 = eax_179->ptr0000;
	}
	eax_153 = eax_179 - eax[18] + edx->dw0068;
	return eax_153;
}

// 0809E5D0: void _Unwind_GetGR(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack int32 dwArg08)
void _Unwind_GetGR(struct Eq_9 * gs, Eq_2 dwArg04, int32 dwArg08)
{
	if (dwArg08 > 0x11)
		_Unwind_GetGR.cold.14(dwArg04, gs);
	else
	{
		Eq_2 esi_18 = (word32) (&g_t80CFB54)[dwArg08];
		if ((*((word32) dwArg04 + 99) & 0x40) != 0x00 && ((word32) dwArg04 + 0x006C) + dwArg08 != 0x00)
			return;
		if ((byte) esi_18 == 0x04)
			return;
		_Unwind_GetGR.cold.14(esi_18, gs);
	}
}

// 0809E630: void _Unwind_GetCFA()
void _Unwind_GetCFA()
{
}

// 0809E640: void _Unwind_SetGR(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_21880) dwArg04, Stack int32 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __gcc_personality_v0
void _Unwind_SetGR(struct Eq_9 * gs, struct Eq_21880 * dwArg04, int32 dwArg08, Eq_2 dwArg0C)
{
	if (dwArg08 > 0x11)
		_Unwind_SetGR.cold.15(0x080CE000, gs);
	else
	{
		byte bl_32 = (&g_t80CFB54)[dwArg08];
		if ((dwArg04->b0063 & 0x40) != 0x00 && (dwArg04->a006C)[dwArg08] != 0x00)
			dwArg04[dwArg08 * 0x04 / 0x006C] = (struct Eq_21880) dwArg0C;
		else
		{
			Eq_2 eax_30 = dwArg04[dwArg08 * 0x04 / 0x006C];
			if (bl_32 != 0x04)
				_Unwind_SetGR.cold.15(0x080CE000, gs);
			else
				*eax_30 = dwArg0C;
		}
	}
}

// 0809E6B0: void _Unwind_GetIP()
void _Unwind_GetIP()
{
}

// 0809E6C0: Register word32 _Unwind_GetIPInfo(Stack (ptr32 Eq_145580) dwArg04, Stack (ptr32 uint32) dwArg08, Register out (ptr32 uint32) ecxOut)
// Called from:
//      __gcc_personality_v0
word32 _Unwind_GetIPInfo(struct Eq_145580 * dwArg04, uint32 * dwArg08, uint32 & ecxOut)
{
	*dwArg08 = dwArg04->dw0060 >> 0x1F;
	word32 eax_11 = dwArg04->dw004C;
	ecxOut = dwArg08;
	return eax_11;
}

// 0809E6E0: void _Unwind_SetIP(Stack (ptr32 Eq_21880) dwArg04, Stack int32 dwArg08)
// Called from:
//      __gcc_personality_v0
void _Unwind_SetIP(struct Eq_21880 * dwArg04, int32 dwArg08)
{
	dwArg04->dw004C = dwArg08;
}

// 0809E6F0: Register Eq_2 _Unwind_GetLanguageSpecificData(Stack Eq_2 dwArg04)
// Called from:
//      __gcc_personality_v0
Eq_2 _Unwind_GetLanguageSpecificData(Eq_2 dwArg04)
{
	return *((word32) dwArg04 + 80);
}

// 0809E700: void _Unwind_GetRegionStart()
// Called from:
//      base_of_encoded_value
//      __gcc_personality_v0
void _Unwind_GetRegionStart()
{
}

// 0809E710: void _Unwind_FindEnclosingFunction(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
void _Unwind_FindEnclosingFunction(struct Eq_9 * gs, word32 dwArg04)
{
	word32 edx_50;
	_Unwind_Find_FDE(gs, dwArg04 - 0x01, fp - 0x18, out edx_50) == null;
}

// 0809E750: void _Unwind_GetDataRelBase()
// Called from:
//      base_of_encoded_value
void _Unwind_GetDataRelBase()
{
}

// 0809E760: void _Unwind_GetTextRelBase()
// Called from:
//      base_of_encoded_value
void _Unwind_GetTextRelBase()
{
}

// 0809E770: void __frame_state_for(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_145619) dwArg08)
void __frame_state_for(struct Eq_9 * gs, struct Eq_145619 * dwArg08)
{
	word32 ecx_122;
	word32 * edi_119 = fp - 0x015C;
	for (ecx_122 = 0x20; ecx_122 != 0x00; --ecx_122)
	{
		*edi_119 = 0x00;
		++edi_119;
	}
	word32 edx_213;
	word32 ecx_212;
	if (uw_frame_state_for(fp - 0x015C, fp - 220, gs, out ecx_212, out edx_213) != 0x00 || dwLoc3C == 0x02)
		return;
	int32 edx_63;
	for (edx_63 = 0x00; edx_63 != 0x12; ++edx_63)
	{
		byte cl_70 = (fp - 0xD8)[edx_63].b0000;
		dwArg08->a005C[edx_63] = cl_70;
		if (cl_70 != 0x01 && cl_70 != 0x02)
		{
			dwArg08->a0010[edx_63] = 0x00;
			++edx_63;
			if (edx_63 != 0x12)
				continue;
			break;
		}
		dwArg08->a0010[edx_63] = (fp - 220)[edx_63].dw0000;
	}
	dwArg08->dw0008 = dwLoc48;
	dwArg08->w0058 = (word16) dwLoc44;
	dwArg08->w005A = (word16) dwLoc28;
	dwArg08->dw000C = dwLocF4;
	dwArg08->dw0004 = dwLoc20;
}

// 0809E850: void _Unwind_DebugHook()
// Called from:
//      _Unwind_RaiseException
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
void _Unwind_DebugHook()
{
}

// 0809E860: Register word32 _Unwind_RaiseException(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00)
// Called from:
//      _Unwind_Resume_or_Rethrow
word32 _Unwind_RaiseException(struct Eq_9 * gs, Eq_2 dwArg00)
{
	uw_init_context_1(fp - 0x01DC, dwArg00, gs, dwLoc01F0);
	struct Eq_145157 * ebp_214 = fp - 4;
	Eq_2 esi_14 = fp - 0x01DC;
	word32 * edi_23 = fp - 0x015C;
	word32 ecx_236;
	for (ecx_236 = 0x20; ecx_236 != 0x00; --ecx_236)
	{
		*edi_23 = (word32) *esi_14;
		esi_14 = (word32) esi_14 + 4;
		++edi_23;
	}
	while (true)
	{
		word32 edx_54;
		word32 ecx_318;
		Eq_2 eax_52 = uw_frame_state_for(fp - 0x015C, ebp_214->tFFFFFE24, gs, out ecx_318, out edx_54);
		if (eax_52 == 0x05)
			break;
		if (eax_52 != 0x00)
			return ebp_214->dw0000;
		<anonymous> * eax_64 = ebp_214->ptrFFFFFFD0;
		if (eax_64 != null)
		{
			esi_14 = ebp_214->t0008;
			word32 eax_90;
			eax_64();
			if (eax_90 == 0x06)
			{
				word32 edi_97 = ebp_214->dwFFFFFEF0;
				struct Eq_145277 * esi_100 = ebp_214->ptrFFFFFE20;
				*((word32) ebp_214->t0008 + 0x0C) = 0x00;
				*((word32) ebp_214->t0008 + 16) = edi_97 - (ebp_214->dwFFFFFF08 >> 0x1F);
				word32 ecx_111;
				word32 * edi_109 = fp - 0x015C;
				Eq_2 eax_110 = ebp_214->t0008;
				for (ecx_111 = 0x20; ecx_111 != 0x00; --ecx_111)
				{
					*edi_109 = (word32) esi_100->t0000;
					++esi_100;
					++edi_109;
				}
				word32 ecx_319;
				if (_Unwind_RaiseException_Phase2(eax_110, ebp_214->tFFFFFE24, fp - 0x015C, gs, out ecx_319) != 0x07)
					return ebp_214->dw0000;
				int32 eax_130 = uw_install_context_1(ebp_214->ptrFFFFFE20, fp - 0x015C, gs);
				word32 ebx_136 = ebp_214->dwFFFFFEF4;
				_Unwind_DebugHook();
				ebp_214->a0004[eax_130 / 4] = ebx_136;
				<anonymous> * ecx_176 = ebp_214->a0004[eax_130 / 4];
				ecx_176();
				return ebp_214->dw0000;
			}
			if (eax_90 == 0x08)
				goto l0809E8DD;
			return ebp_214->dw0000;
		}
l0809E8DD:
		ebp_214 = uw_update_context(fp - 0x015C, ebp_214->tFFFFFE24, fp - 0x015C, esi_14, gs);
	}
	return ebp_214->dw0000;
}

// 0809E9E0: void _Unwind_ForcedUnwind(Register word32 eax, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void _Unwind_ForcedUnwind(word32 eax, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	uw_init_context_1(fp - 0x011C, dwArg00, gs, dwLoc0130);
	word32 * edi_137 = fp - 0x9C;
	word32 * esi_135 = fp - 0x011C;
	word32 ecx_141;
	for (ecx_141 = 0x20; ecx_141 != 0x00; --ecx_141)
	{
		*edi_137 = *esi_135;
		++esi_135;
		++edi_137;
	}
	*((word32) dwArg04 + 0x0C) = dwArg08;
	*((word32) dwArg04 + 16) = dwArg0C;
	word32 ecx_235;
	if (_Unwind_ForcedUnwind_Phase2(dwArg04, fp - 288, fp - 0x9C, gs, out ecx_235) != 0x07)
		return;
	int32 eax_66 = uw_install_context_1(fp - 0x011C, fp - 0x9C, gs);
	_Unwind_DebugHook();
	fp[eax_66 / 4] = dwLoc50;
	<anonymous> * ecx_116 = fp[eax_66 / 4];
	ecx_116();
}

// 0809EAC0: Register Eq_2 _Unwind_Resume(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _IO_new_fclose.cold.0
//      _IO_fflush.cold.0
//      _IO_puts.cold.0
//      _IO_wfile_underflow.cold.2
//      _IO_new_file_underflow.cold.6
//      _IO_fputs.cold.0
//      _IO_fwrite.cold.0
//      _IO_getdelim.cold.0
Eq_2 _Unwind_Resume(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	uw_init_context_1(fp - 0x011C, dwArg00, gs, dwLoc0140);
	word32 * esi_14 = fp - 0x011C;
	word32 * edi_149 = fp - 0x9C;
	word32 ecx_153;
	for (ecx_153 = 0x20; ecx_153 != 0x00; --ecx_153)
	{
		*edi_149 = *esi_14;
		++esi_14;
		++edi_149;
	}
	Eq_2 ecx_59;
	word32 eax_58;
	if (*((word32) dwArg04 + 0x0C) == 0x00)
		eax_58 = _Unwind_RaiseException_Phase2(dwArg04, fp - 288, fp - 0x9C, gs, out ecx_59);
	else
		eax_58 = _Unwind_ForcedUnwind_Phase2(dwArg04, fp - 288, fp - 0x9C, gs, out ecx_59);
	if (eax_58 != 0x07)
		_Unwind_Resume.cold.16(ecx_59, gs);
	else
	{
		int32 eax_83 = uw_install_context_1(fp - 0x011C, fp - 0x9C, gs);
		_Unwind_DebugHook();
		fp[eax_83 / 4] = dwLoc50;
		<anonymous> * ecx_133 = fp[eax_83 / 4];
		ptr32 edx_143;
		Eq_2 eax_144;
		ptr32 ecx_145;
		ecx_133();
		ecxOut = ecx_145;
		edxOut = edx_143;
		return eax_144;
	}
}

// 0809EBC0: void _Unwind_Resume_or_Rethrow(Register word32 eax, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04)
void _Unwind_Resume_or_Rethrow(word32 eax, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 0x0C) == 0x00)
		_Unwind_RaiseException(gs, dwLoc0150);
	else
	{
		uw_init_context_1(fp - 0x011C, dwArg00, gs, dwLoc0140);
		word32 * edi_157 = fp - 0x9C;
		word32 * esi_118 = fp - 0x011C;
		word32 ecx_161;
		for (ecx_161 = 0x20; ecx_161 != 0x00; --ecx_161)
		{
			*edi_157 = *esi_118;
			++esi_118;
			++edi_157;
		}
		Eq_2 ecx_81;
		if (_Unwind_ForcedUnwind_Phase2(dwArg04, fp - 288, fp - 0x9C, gs, out ecx_81) != 0x07)
			_Unwind_Resume_or_Rethrow.cold.17(ecx_81, gs);
		else
		{
			int32 eax_92 = uw_install_context_1(fp - 0x011C, fp - 0x9C, gs);
			_Unwind_DebugHook();
			fp[eax_92 / 4] = dwLoc50;
			<anonymous> * ecx_143 = fp[eax_92 / 4];
			ecx_143();
		}
	}
}

// 0809ECD0: void _Unwind_DeleteException(Stack (ptr32 Eq_146071) dwArg04)
void _Unwind_DeleteException(struct Eq_146071 * dwArg04)
{
	<anonymous> * eax_7 = dwArg04->ptr0008;
	if (eax_7 != null)
		eax_7();
}

// 0809ED00: void _Unwind_Backtrace(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00)
void _Unwind_Backtrace(struct Eq_9 * gs, Eq_2 dwArg00)
{
	uw_init_context_1(fp - 0x015C, dwArg00, gs, dwLoc0160);
	struct Eq_145157 * ebp_55 = fp - 4;
	while (true)
	{
		word32 ecx_139;
		word32 edx_140;
		Eq_2 eax_37 = uw_frame_state_for(fp - 0x015C, fp - 220, gs, out ecx_139, out edx_140);
		if (eax_37 != 0x00 && eax_37 != 0x05)
			break;
		word32 eax_70;
		ebp_55->t0008();
		if (eax_70 != 0x00)
			break;
		if (eax_37 == 0x05)
			return;
		ebp_55 = uw_update_context(fp - 0x015C, fp - 220, fp - 0x015C, fp - 220, gs);
	}
}

// 0809ED80: void fde_unencoded_compare(Stack (ptr32 Eq_146117) dwArg08, Stack (ptr32 Eq_146118) dwArg0C)
void fde_unencoded_compare(struct Eq_146117 * dwArg08, struct Eq_146118 * dwArg0C)
{
	dwArg08->dw0008 > dwArg0C->dw0008;
}

// 0809EDA0: void frame_downheap(Register Eq_2 eax, Register (arr Eq_146218) ecx, Register (ptr32 Eq_9) gs, Stack Eq_146129 dwArg04, Stack Eq_146129 dwArg08)
// Called from:
//      frame_heapsort
void frame_downheap(Eq_2 eax, Eq_146218 ecx[], struct Eq_9 * gs, Eq_146129 dwArg04, Eq_146129 dwArg08)
{
	Eq_146129 edx_105 = dwArg04;
	Eq_146129 ebx_104 = (word32) dwArg04 + ((word32) dwArg04 + 1);
	if (ebx_104 < dwArg08)
	{
		do
		{
			ui32 ecx_28 = ebx_104 * 0x04;
			struct Eq_146145 ** edi_100 = ecx + ecx_28 / 4;
			Eq_146129 esi_103 = (word32) ebx_104.u0 + 1;
			struct Eq_146145 * eax_33 = *edi_100;
			if (esi_103 >= dwArg08)
				esi_103 = ebx_104;
			else
			{
				struct Eq_146145 ** ecx_37 = ecx + 1 + ecx_28 / 4;
				if (fde_mixed_encoding_compare(gs, eax, eax_33) >= 0x00)
					esi_103 = ebx_104;
				else
					edi_100 = ecx_37;
			}
			struct Eq_146145 ** ebx_76 = ecx + edx_105;
			if (fde_mixed_encoding_compare(gs, eax, *ebx_76) >= 0x00)
				return;
			struct Eq_146145 * eax_99 = *ebx_76;
			*ebx_76 = *edi_100;
			*edi_100 = (struct Eq_146145 **) eax_99;
			ebx_104 = (word32) esi_103.u0 + ((word32) esi_103.u0 + 1);
			edx_105 = esi_103;
		} while (dwArg08 > ebx_104);
	}
}

// 0809EE60: void frame_heapsort(Register Eq_2 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      search_object
void frame_heapsort(Eq_2 eax, Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_146129 ebx_21 = *((word32) ecx + 4);
	Eq_146129 esi_28 = (ebx_21 >> 0x01) - 0x01;
	if (esi_28 != ~0x00)
	{
		Eq_146129 esi_33 = esi_28;
		do
		{
			frame_downheap(eax, (word32) ecx + 8, gs, esi_33, ebx_21);
			--esi_33;
		} while (esi_33 != ~0x00);
	}
	Eq_146129 ebx_62 = ebx_21 - 0x01;
	if (ebx_21 > 0x01)
	{
		do
		{
			Eq_146218 eax_71 = *((word32) ecx + 8);
			*((word32) ecx + 8) = *((word32) ecx + (ebx_62 * 0x04 + 8));
			*((word32) ecx + (ebx_62 * 0x04 + 8)) = eax_71;
			frame_downheap(eax, (word32) ecx + 8, gs, 0x00, ebx_62);
			--ebx_62;
		} while (ebx_62 != 0x00);
	}
}

// 0809EF00: Register word32 size_of_encoded_value(Register byte al, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      linear_search_fdes
//      _Unwind_IteratePhdrCallback
//      classify_object_over_fdes
//      add_fdes
word32 size_of_encoded_value(byte al, Eq_2 ecx, struct Eq_9 * gs)
{
	byte al = (byte) eax;
	word32 eax_13;
	if (al == ~0x00)
	{
		eax_13 = 0x00;
		return eax_13;
	}
	else if ((al & 0x07) == 0x02)
	{
		eax_13 = 0x02;
		return eax_13;
	}
	else
	{
		if ((al & 0x07) > 0x02)
		{
			if ((al & 0x07) == 0x03)
				return 0x04;
			if ((al & 0x07) == 0x04)
			{
				eax_13 = 0x08;
				return eax_13;
			}
		}
		else if ((al & 0x07) == 0x00)
			return 0x04;
		word32 edx_73;
		word32 ecx_72;
		abort(ecx, gs, out ecx_72, out edx_73);
	}
}

// 0809EF60: Register word32 base_from_object(Register byte al, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      size_of_encoded_value
//      fde_single_encoding_compare
//      linear_search_fdes
//      fde_mixed_encoding_compare
//      classify_object_over_fdes
//      add_fdes
//      search_object
//      _Unwind_Find_FDE
word32 base_from_object(byte al, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	byte al = (byte) eax;
	if (al == ~0x00)
		return 0x00;
	word32 eax_34;
	if ((al & 0x70) == 0x20)
	{
		eax_34 = (word32) *((word32) edx + 4);
		return eax_34;
	}
	else
	{
		if ((al & 0x70) > 0x20)
		{
			if ((al & 0x70) == 0x30)
			{
				eax_34 = (word32) *((word32) edx + 8);
				return eax_34;
			}
			if ((al & 0x70) == 0x50)
				return 0x00;
		}
		else if ((al & 0x70) == 0x00 || (al & 0x70) == 0x10)
			return 0x00;
		word32 edx_73;
		word32 ecx_72;
		abort(ecx, gs, out ecx_72, out edx_73);
	}
}

// 0809EFC0: void base_from_cb_data(Register byte al, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_IteratePhdrCallback
void base_from_cb_data(byte al, Eq_2 ecx, struct Eq_9 * gs)
{
	byte al = (byte) eax;
	if (al == ~0x00)
		return;
	if ((al & 0x70) == 0x20)
		return;
	if ((al & 0x70) > 0x20)
	{
		if ((al & 0x70) == 0x30)
			return;
		if ((al & 0x70) == 0x50)
			return;
	}
	else if ((al & 0x70) == 0x00 || (al & 0x70) == 0x10)
		return;
	word32 edx_73;
	word32 ecx_72;
	abort(ecx, gs, out ecx_72, out edx_73);
}

// 0809F020: Register Eq_146347 read_encoded_value_with_base(Register Eq_146347 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out Eq_2 ecxOut, Register out ptr32 edxOut, Register out (ptr32 Eq_146353) ebxOut, Register out Eq_2 esiOut)
// Called from:
//      fde_single_encoding_compare
//      get_cie_encoding
//      linear_search_fdes
//      _Unwind_IteratePhdrCallback
//      fde_mixed_encoding_compare
//      classify_object_over_fdes
//      add_fdes
//      search_object
//      _Unwind_Find_FDE
Eq_146347 read_encoded_value_with_base(Eq_146347 eax, Eq_2 ecx, struct Eq_9 * gs, word32 * dwArg04, union Eq_2 & ecxOut, ptr32 & edxOut, struct Eq_146353 & ebxOut, union Eq_2 & esiOut)
{
	byte al = (byte) eax;
	word24 eax_24_8 = SLICE(eax, word24, 8);
	if (al == 0x50)
	{
		word32 * esi_28 = (word32) ecx + 3 & ~0x03;
		*dwArg04 = *esi_28;
		ecxOut = ecx;
		edxOut = esi_28 + 1;
		ebxOut = ebx;
		esiOut = esi;
		return esi_28 + 1;
	}
	else if ((al & 0x0F) > 0x0C)
		read_encoded_value_with_base.cold.8(ecx, gs);
	else
	{
		ui32 edx_51 = (word32) (al & 0x0F);
		<anonymous> * ecx_53 = g_a80BA374[edx_51 * 0x04] + 0x080CE000;
		Eq_2 ecx_55;
		ptr32 edx_56;
		Eq_146347 eax_57;
		ecx_53();
		ecxOut = ecx_55;
		edxOut = edx_56;
		ebxOut = (struct Eq_146353 *) &g_t80CE000;
		esiOut = ecx;
		return eax_57;
	}
}

// 0809F170: void fde_single_encoding_compare(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void fde_single_encoding_compare(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	Eq_146347 ebx_21 = (word32) (byte) (*((word32) dwArg04 + 16) >> 0x03);
	base_from_object((byte) ebx_21, ecx, dwArg04, gs);
	word32 ebx_113;
	word32 edx_112;
	word32 ecx_111;
	word32 esi_114;
	read_encoded_value_with_base(ebx_21, dwArg08 + 0x08, gs, fp - 0x14, out ecx_111, out edx_112, out ebx_113, out esi_114);
	Eq_2 esp_44 = <invalid>;
	Eq_2 eax_50 = *((word32) esp_44 + 56);
	cu16 ax_59 = *((word32) dwArg04 + 16);
	*esp_44 = (word32) esp_44 + 28;
	word32 ecx_115;
	word32 edx_116;
	word32 ebx_117;
	word32 esi_118;
	read_encoded_value_with_base((word32) (byte) (ax_59 >> 0x03), (word32) eax_50 + 8, gs, *esp_44, out ecx_115, out edx_116, out ebx_117, out esi_118);
}

// 0809F1F0: Register (ptr32 Eq_146466) get_cie_encoding(Register (ptr32 Eq_146466) eax, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_146468) ecxOut)
// Called from:
//      linear_search_fdes
//      _Unwind_IteratePhdrCallback
//      fde_mixed_encoding_compare
//      classify_object_over_fdes
//      add_fdes
//      search_object
//      _Unwind_Find_FDE
struct Eq_146466 * get_cie_encoding(struct Eq_146466 * eax, struct Eq_9 * gs, struct Eq_146468 & ecxOut)
{
	struct Eq_146466 * eax_149;
	word32 ecx_263;
	word32 edx_264;
	Eq_2 eax_22 = strlen(&eax->b0009, out ecx_263, out edx_264);
	struct Eq_146468 * ecx_127 = (word32) eax->b0008;
	cu8 cl_32 = (byte) ecx_127;
	ptr32 esp_109 = fp - 0x1C;
	word32 edx_164 = eax + 0x0A + eax_22;
	if (cl_32 > 0x03)
	{
		eax_149 = (struct Eq_146466 *) 0xFF;
		if (*edx_164 != 0x04 || *((word32) edx_164 + 1) != 0x00)
			goto l0809F228;
		edx_164 = (word32) edx_164 + 2;
	}
	if (eax->b0009 == 122)
	{
		do
		{
			edx_164 = (word32) edx_164 + 1;
			if (*((word32) edx_164 - 1) >= 0x00)
				break;
			edx_164 = (word32) edx_164 + 1;
		} while (*edx_164 < 0x00);
		while (true)
		{
			Eq_2 eax_104 = (word32) edx_164 + 1;
			if (*((word32) eax_104 - 1) >= 0x00)
				break;
			edx_164 = eax_104;
		}
		if (cl_32 != 0x01)
		{
			do
				eax_104 = (word32) eax_104 + 1;
			while (*((word32) eax_104 - 1) < 0x00);
		}
		else
			eax_104 = (word32) edx_164 + 2;
		byte * ebx_100 = &eax->b000A;
		do
			eax_104 = (word32) eax_104 + 1;
		while (*((word32) eax_104 - 1) < 0x00);
		word32 edx_103 = (word32) eax->b000A;
		word32 * esi_115 = fp - 0x10;
		while ((byte) edx_103 != 0x52)
		{
			byte dl_95 = (byte) edx_103;
			if (dl_95 != 0x50)
			{
				if (dl_95 != 0x4C)
					goto l0809F226;
				++ebx_100;
				edx_103 = (word32) *ebx_100;
				eax_104 = (word32) eax_104 + 1;
				if ((byte) edx_103 != 0x52)
					continue;
				break;
			}
			struct Eq_146580 * esp_110 = esp_109 - 0x0C;
			ui32 eax_112 = (word32) *eax_104;
			esp_110->ptrFFFFFFFC = esi_115;
			word32 edx_265;
			eax_104 = read_encoded_value_with_base(eax_112 & 0x7F, (word32) eax_104 + 1, gs, esp_110->ptrFFFFFFFC, out ecx_127, out edx_265, out ebx_100, out esi_115);
			Eq_2 esp_126 = <invalid>;
			edx_103 = (word32) *ebx_100;
			esp_109 = (word32) esp_126 + 16;
		}
		struct Eq_146466 * eax_139 = (word32) *eax_104;
		ecxOut = ecx_127;
		return eax_139;
	}
l0809F226:
	eax_149 = null;
l0809F228:
	ecxOut = ecx_127;
	return eax_149;
}

// 0809F300: Register Eq_2 linear_search_fdes(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_IteratePhdrCallback
//      search_object
Eq_2 linear_search_fdes(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	ui32 esi_137 = (word32) (byte) (*((word32) eax + 16) >> 0x03);
	base_from_object((byte) esi_137, ecx, eax, gs);
	Eq_2 ebx_135 = edx;
	struct Eq_146642 * esp_150 = fp - 0x4C;
	if (*edx != 0x00)
	{
		do
		{
			ui32 edx_49 = *((word32) ebx_135 + 4);
			if (edx_49 != 0x00)
			{
				if ((*((word32) eax + 16) & 0x04) != 0x00)
				{
					struct Eq_146466 * edi_58 = (word32) ebx_135 + 4 - edx_49;
					if (edi_58 != esp_150->ptr000C)
					{
						Eq_2 ecx_65;
						ui32 eax_64 = get_cie_encoding(edi_58, gs, out ecx_65);
						word32 eax_75 = base_from_object((byte) eax_64, ecx_65, eax, gs);
						esp_150->ptr000C = edi_58;
						esp_150->dw0014 = eax_75;
						esi_137 = eax_64;
					}
				}
				if (esi_137 != 0x00)
				{
					struct Eq_146718 * esp_101 = esp_150 - 0x0C;
					esp_101->ptrFFFFFFFC = esp_101->ptr0024;
					Eq_146347 edi_109 = (word32) (byte) esi_137;
					ui32 esi_116;
					word32 ebx_287;
					word32 edx_286;
					word32 ecx_285;
					Eq_2 eax_113 = read_encoded_value_with_base(edi_109, (word32) ebx_135 + 8, gs, esp_101->ptrFFFFFFFC, out ecx_285, out edx_286, out ebx_287, out esi_116);
					Eq_2 esp_117 = <invalid>;
					*esp_117 = *((word32) esp_117 + 44);
					Eq_2 ecx_139;
					word32 edx_288;
					read_encoded_value_with_base(esi_116 & 0x0F, eax_113, gs, *esp_117, out ecx_139, out edx_288, out ebx_135, out esi_137);
					Eq_2 esp_138 = <invalid>;
					Eq_146767 eax_145 = size_of_encoded_value((byte) edi_109, ecx_139, gs);
					esp_150 = (word32) esp_138 + 16;
					ui32 edx_151 = ~0x00;
					if (eax_145 <= 0x03)
						edx_151 = (0x01 << (byte) eax_145 * 0x08) - 0x01;
					Eq_2 eax_162 = *((word32) esp_138 + 56);
					if ((eax_162 & edx_151) != 0x00 && *((word32) esp_138 + 32) - eax_162 < *((word32) esp_138 + 60))
						return ebx_135;
				}
				else
				{
					up32 eax_89 = *((word32) ebx_135 + 8);
					up32 edx_90 = *((word32) ebx_135 + 0x0C);
					esp_150->dw0028 = eax_89;
					esp_150->dw002C = edx_90;
					if (eax_89 != 0x00 && esp_150->dw0010 - eax_89 < edx_90)
						return ebx_135;
				}
			}
			ebx_135 = (word32) *ebx_135 + ((word32) ebx_135 + 4);
		} while (*ebx_135 != 0x00);
	}
	return 0x00;
}

// 0809F450: void _Unwind_IteratePhdrCallback(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_146806) dwArg04, Stack up32 dwArg08, Stack (ptr32 Eq_146808) dwArg0C)
void _Unwind_IteratePhdrCallback(struct Eq_9 * gs, struct Eq_146806 * dwArg04, up32 dwArg08, struct Eq_146808 * dwArg0C)
{
	word32 dwLoc58_701;
	Eq_2 dwLoc44_699;
	Eq_2 ecx_104;
	struct Eq_146812 * ebx_261;
	Eq_2 dwLoc40_704;
	struct Eq_146812 * dwLoc48_702;
	word32 edi_21 = dwArg04->dw0000;
	struct Eq_146812 * eax_23 = dwArg04->ptr0008;
	if (dwArg0C->dw0014 != 0x00 && dwArg08 > 0x1F)
	{
		word32 ecx_32 = dwArg04->dw0014;
		word32 ebx_31 = dwArg04->dw0010;
		word32 edi_30 = dwArg04->dw0018;
		word32 edi_35 = dwArg04->dw001C;
		if ((g_dw80CEF5C ^ ecx_32 | g_dw80CEF58 ^ ebx_31) != 0x00 || (edi_35 ^ g_dw80CFB8C | edi_30 ^ g_dw80CFB88) != 0x00)
		{
			g_dw80CEF58 = ebx_31;
			g_dw80CEF5C = ecx_32;
			g_dw80CFB8C = edi_35;
			g_dw80CFB88 = edi_30;
			struct Eq_147381 * ecx_119 = &g_t80CFBB8;
			do
			{
				ecx_119->dwFFFFFFE8 = 0x00;
				ecx_119->dwFFFFFFEC = 0x00;
				ecx_119->dwFFFFFFFC = ecx_119;
				++ecx_119;
			} while (&any_objects_registered != ecx_119);
			frame_hdr_cache_head.u0 = 0x080CFBA0;
			g_dw80CFC5C = 0x00;
			dwArg0C->dw0014 = 0x00;
			dwLoc40_704.u0 = 0x00;
			dwLoc44_699.u0 = 0x00;
l0809F4A4:
			ui32 edx_169 = (word32) dwArg04->w000C;
			dwLoc58_701 = edi_21;
			struct Eq_146812 * eax_178 = eax_23;
			if ((word16) edx_169 == 0x00)
				return;
			Eq_2 dwLoc4C_719 = 0x00;
			struct Eq_146812 * edx_186 = eax_23 + (edx_169 << 0x05) / 32;
			Eq_2 dwLoc50_720 = 0x00;
			word32 dwLoc54_721 = 0x00;
			dwLoc48_702 = null;
			struct Eq_146812 * dwLoc5C_723 = null;
			do
			{
				ecx_104 = eax_178->dw0000;
				if (ecx_104 == 0x01)
				{
					Eq_2 esi_210 = edi_21 + eax_178->dw0008;
					ecx_104 = dwArg0C->t0000;
					if (ecx_104 >= esi_210)
					{
						Eq_2 ebx_223 = dwLoc4C_719;
						Eq_2 edi_224 = (word32) esi_210 + eax_178->dw0014;
						if (ecx_104 >= edi_224)
							esi_210 = dwLoc50_720;
						if (ecx_104 < edi_224)
							ebx_223 = edi_224;
						dwLoc50_720 = esi_210;
						dwLoc4C_719 = ebx_223;
						word32 ebx_239 = 0x01;
						if (ecx_104 >= edi_224)
							ebx_239 = dwLoc54_721;
						++eax_178;
						dwLoc54_721 = ebx_239;
						if (eax_178 == edx_186)
							break;
						continue;
					}
				}
				else if (ecx_104 != 0x6474E550)
				{
					struct Eq_146812 * ebx_201 = dwLoc5C_723;
					if (ecx_104 == 0x02)
						ebx_201 = eax_178;
					dwLoc5C_723 = ebx_201;
				}
				else
					dwLoc48_702 = eax_178;
				++eax_178;
			} while (eax_178 != edx_186);
			ebx_261 = dwLoc5C_723;
			if (dwLoc54_721 == 0x00)
				return;
			if (dwArg08 > 0x1F)
			{
				Eq_2 eax_280 = frame_hdr_cache_head;
				if (dwLoc40_704 != 0x00 && dwLoc44_699 != 0x00)
				{
					Eq_2 edx_288 = *((byte) dwLoc40_704.u0 + 20);
					frame_hdr_cache_head = dwLoc40_704;
					*((byte) dwLoc44_699.u0 + 20) = edx_288;
					*((byte) dwLoc40_704.u0 + 20) = eax_280;
					eax_280 = dwLoc40_704;
				}
				*((word32) eax_280 + 16) = dwLoc5C_723;
				*((word32) eax_280 + 8) = edi_21;
				*((word32) eax_280 + 4) = dwLoc4C_719;
				*((word32) eax_280 + 0x0C) = dwLoc48_702;
				*eax_280 = dwLoc50_720;
			}
l0809F5AB:
			if (dwLoc48_702 == null)
				return;
			struct Eq_146950 * esi_327 = dwLoc58_701 + dwLoc48_702->dw0008;
			if (esi_327->b0000 != 0x01)
				return;
			dwArg0C->dw0008 = 0x00;
			if (ebx_261 != null)
			{
				struct Eq_147004 * eax_337 = dwLoc58_701 + ebx_261->dw0008 + 0x04;
				word32 edx_338 = eax_337->dw0000;
				while (edx_338 != 0x00)
				{
					if (edx_338 == 0x03)
					{
						dwArg0C->dw0008 = eax_337->dw0000;
						break;
					}
					++eax_337;
					edx_338 = eax_337->dw0000;
				}
			}
			Eq_2 ecx_457;
			Eq_146347 ebx_359 = (word32) esi_327->b0001;
			base_from_cb_data((byte) ebx_359, ecx_104, gs);
			word32 edx_1006;
			word32 ebx_1007;
			struct Eq_146978 * esi_409;
			Eq_2 ecx_411;
			Eq_2 eax_406 = read_encoded_value_with_base(ebx_359, &esi_327->b0001 + 3, gs, fp - 0x3C, out ecx_411, out edx_1006, out ebx_1007, out esi_409);
			Eq_2 esp_410 = <invalid>;
			Eq_146347 ebx_416 = (word32) esi_409->b0002;
			struct Eq_146998 * esp_417 = (word32) esp_410 + 16;
			if ((byte) ebx_416 != ~0x00 && esi_409->b0003 == 0x3B)
			{
				base_from_cb_data((byte) ebx_416, ecx_411, gs);
				*esp_410 = (word32) esp_410 + 52;
				word32 ecx_1008;
				word32 ebx_1010;
				word32 edx_1009;
				up32 esi_442;
				Eq_2 eax_439 = read_encoded_value_with_base(ebx_416, eax_406, gs, *esp_410, out ecx_1008, out edx_1009, out ebx_1010, out esi_442);
				Eq_2 esp_443 = <invalid>;
				Eq_2 ebx_449 = *((word32) esp_443 + 52);
				*((word32) esp_443 + 16) = eax_439;
				esp_417 = (word32) esp_443 + 16;
				if (ebx_449 == 0x00)
					return;
				ecx_457 = **((word32) esp_443 + 0x0078);
				Eq_2 edi_459 = eax_439 & 0x03;
				if ((eax_439 & 0x03) == 0x00)
				{
					if ((word32) *eax_439 + esi_442 <= ecx_457)
					{
						Eq_2 eax_468 = (word32) eax_439 + (ebx_449 - 0x01) * 0x08;
						up32 edx_469 = *eax_468;
						*((word32) esp_443 + 20) = eax_468;
						if (edx_469 + esi_442 > ecx_457)
						{
							*((word32) esp_443 + 20) = ebx_449 - 0x01;
							do
							{
								Eq_2 eax_477 = *((word32) esp_443 + 20);
								if (edi_459 >= eax_477)
								{
l0809F8D8:
									word32 ecx_1017;
									word32 edx_1018;
									abort(ecx_457, gs, out ecx_1017, out edx_1018);
								}
								word32 eax_481 = eax_477 + edi_459;
								Eq_2 eax_483 = eax_481 >> 0x01;
								if ((word32) *((word32) *((word32) esp_443 + 16) + (eax_481 >> 0x01) * 0x08) + esi_442 > ecx_457)
								{
									*((word32) esp_443 + 20) = ecx_457;
									if (edi_459 < eax_481 >> 0x01)
									{
										do
										{
											word32 edx_495 = edi_459 + eax_483;
											ecx_457 = *((word32) esp_443 + 16);
											if ((word32) *((word32) ecx_457 + (edx_495 >> 0x01) * 0x08) + esi_442 <= *((word32) esp_443 + 20))
											{
												ecx_457 = *((word32) esp_443 + 20);
												*((word32) esp_443 + 20) = eax_483;
												eax_483 = edx_495 >> 0x01;
												goto l0809F8EA;
											}
											eax_483 = edx_495 >> 0x01;
										} while (edi_459 < edx_495 >> 0x01);
									}
									goto l0809F8D8;
								}
l0809F8EA:
								Eq_2 ebx_521 = *((word32) esp_443 + 16);
								edi_459 = (word32) eax_483 + 1;
							} while ((word32) *((word32) ebx_521 + edi_459 * 0x08) + esi_442 <= ecx_457);
							*((word32) esp_443 + 20) = (word32) ebx_521 + eax_483 * 0x08;
						}
						Eq_2 ebp_534 = *((word32) esp_443 + 20);
						struct Eq_147221 * ebx_537 = (word32) *((word32) ebp_534 + 4) + esi_442;
						Eq_2 ecx_544;
						ui32 eax_543 = get_cie_encoding(&ebx_537->dw0004 - ebx_537->dw0004, gs, out ecx_544);
						word32 ecx_560 = ebx_537 + 0x08 + size_of_encoded_value((byte) eax_543, ecx_544, gs);
						*esp_443 = (word32) esp_443 + 56;
						word32 ecx_1015;
						word32 ebx_569;
						word32 esi_571;
						word32 edx_1016;
						read_encoded_value_with_base(eax_543 & 0x0F, ecx_560, gs, *esp_443, out ecx_1015, out edx_1016, out ebx_569, out esi_571);
						Eq_2 esp_572 = <invalid>;
						up32 esi_581 = (word32) *ebp_534 + esi_571;
						Eq_2 edi_580 = *((word32) esp_572 + 0x0078);
						if (*edi_580 < (word32) (*((word32) esp_572 + 56)) + esi_581)
							*((word32) edi_580 + 16) = ebx_569;
						*((word32) *((word32) esp_572 + 0x0078) + 0x0C) = esi_581;
					}
					return;
				}
			}
			else
				ecx_457 = **((word32) esp_410 + 0x0078);
			struct Eq_147100 * eax_597 = esp_417->ptr0068;
			Eq_2 edx_598 = esp_417->t0020;
			esp_417->dw0028 = 0x00;
			esp_417->dw0038 = 0x04;
			word32 eax_601 = eax_597->dw0004;
			esp_417->t0034 = edx_598;
			esp_417->dw002C = eax_601;
			esp_417->dw0030 = esp_417->ptr0068->dw0008;
			Eq_2 eax_611 = linear_search_fdes(&esp_417->dw0028, ecx_457, edx_598, gs);
			esp_417->ptr0068->t0010 = eax_611;
			if (eax_611 != 0x00)
			{
				Eq_2 ecx_628;
				Eq_146347 ebx_636 = (word32) (byte) get_cie_encoding((word32) eax_611 + 4 - *((word32) eax_611 + 4), gs, out ecx_628);
				base_from_cb_data((byte) ebx_636, ecx_628, gs);
				struct Eq_147094 * esp_644 = esp_417 - 0x0C;
				Eq_2 edi_646 = esp_417->ptr0068->t0010;
				esp_644->t000C = edi_646;
				esp_644->ptrFFFFFFFC = (word32 *) ((char *) &esp_644->t000C + 36);
				word32 edx_1012;
				word32 esi_1014;
				word32 ebx_1013;
				word32 ecx_1011;
				read_encoded_value_with_base(ebx_636, (word32) edi_646 + 8, gs, esp_644->ptrFFFFFFFC, out ecx_1011, out edx_1012, out ebx_1013, out esi_1014);
				Eq_2 esp_658 = <invalid>;
				*((word32) *((word32) esp_658 + 0x0078) + 0x0C) = *((word32) esp_658 + 52);
			}
			return;
		}
		Eq_2 edi_52 = frame_hdr_cache_head;
		if (edi_52 != 0x00)
		{
			ecx_104 = edi_52;
			dwLoc44_699.u0 = 0x00;
			Eq_2 edi_106 = *((word32) edi_52 + 4);
			Eq_2 esi_107 = dwArg0C->t0000;
			Eq_2 ebx_105 = *edi_52;
			if (esi_107 >= ebx_105)
			{
l0809F808:
				if (esi_107 < edi_106)
				{
					ebx_261 = (struct Eq_146812 *) *((word32) ecx_104 + 16);
					dwLoc58_701 = (word32) *((word32) ecx_104 + 8);
					dwLoc48_702 = (struct Eq_146812 *) *((word32) ecx_104 + 0x0C);
					if (edi_52 != ecx_104)
					{
						Eq_2 eax_81 = *((word32) ecx_104 + 20);
						frame_hdr_cache_head = ecx_104;
						*((byte) dwLoc44_699.u0 + 20) = eax_81;
						*((word32) ecx_104 + 20) = edi_52;
					}
					goto l0809F5AB;
				}
			}
			do
			{
				if ((ebx_105 | edi_106) == 0x00)
				{
l0809F830:
					dwLoc40_704 = ecx_104;
					goto l0809F4A4;
				}
				Eq_2 ebx_95 = *((word32) ecx_104 + 20);
				if (ebx_95 == 0x00)
					goto l0809F830;
				dwLoc44_699 = ecx_104;
				ecx_104 = ebx_95;
				ebx_105 = *ebx_95;
				edi_106 = *((word32) ebx_95 + 4);
			} while (esi_107 < ebx_105);
			goto l0809F808;
		}
	}
	else if (dwArg08 <= 0x0D)
		return;
	dwLoc40_704.u0 = 0x00;
	dwLoc44_699.u0 = 0x00;
	goto l0809F4A4;
}

// 0809F990: Register word32 fde_mixed_encoding_compare(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_146145) dwArg08)
// Called from:
//      frame_downheap
//      search_object
word32 fde_mixed_encoding_compare(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_146145 * dwArg08)
{
	Eq_2 ecx_25;
	Eq_146347 edi_33 = (word32) (byte) get_cie_encoding(&dwArg08->dw0004 - dwArg08->dw0004, gs, out ecx_25);
	base_from_object((byte) edi_33, ecx_25, dwArg04, gs);
	struct Eq_147492 * ebx_49;
	word32 esi_139;
	word32 edx_138;
	word32 ecx_137;
	read_encoded_value_with_base(edi_33, &dwArg08->dw0004 + 1, gs, fp - 0x24, out ecx_137, out edx_138, out ebx_49, out esi_139);
	Eq_2 ecx_62;
	Eq_146347 esi_70 = (word32) (byte) get_cie_encoding(&ebx_49->dw0004 - ebx_49->dw0004, gs, out ecx_62);
	base_from_object((byte) esi_70, ecx_62, dwArg04, gs);
	Eq_2 esp_52 = <invalid>;
	*esp_52 = (word32) esp_52 + 28;
	word32 ecx_140;
	word32 edx_141;
	word32 ebx_142;
	word32 esi_143;
	read_encoded_value_with_base(esi_70, &ebx_49->dw0004 + 1, gs, *esp_52, out ecx_140, out edx_141, out ebx_142, out esi_143);
	word32 eax_101 = 0x01;
	if (dwLoc24 <= dwLoc20)
		eax_101 = 0x00 - (word32) (dwLoc24 < dwLoc20);
	return eax_101;
}

// 0809FA20: Register Eq_2 classify_object_over_fdes(Register Eq_2 eax, Register (ptr32 Eq_147554) edx, Register (ptr32 Eq_9) gs)
// Called from:
//      search_object
Eq_2 classify_object_over_fdes(Eq_2 eax, struct Eq_147554 * edx, struct Eq_9 * gs)
{
	Eq_2 eax_20 = edx->dw0000;
	Eq_2 dwLoc30_202 = eax_20;
	if (eax_20 != 0x00)
	{
		struct Eq_147554 * ebx_122 = edx;
		struct Eq_146466 * ecx_151 = null;
		byte bLoc3C_240 = 0x00;
		dwLoc30_202.u0 = 0x00;
		do
		{
			ui32 eax_37 = ebx_122[1];
			if (eax_37 != 0x00)
			{
				Eq_146347 edi_113 = (word32) bLoc3C_240;
				struct Eq_146466 * esi_44 = ebx_122 + 1 - eax_37;
				if (esi_44 != ecx_151)
				{
					Eq_2 ecx_51;
					ui32 eax_50 = get_cie_encoding(esi_44, gs, out ecx_51);
					bLoc3C_240 = (byte) eax_50;
					if (eax_50 == 0xFF)
						return ~0x00;
					edi_113 = (word32) bLoc3C_240;
					base_from_object((byte) edi_113, ecx_51, eax, gs);
					word32 eax_82 = (word32) *((word32) eax + 16);
					cu16 ax_89 = (word16) eax_82;
					bLoc3C_240 = (byte) eax_50;
					if (((word16) eax_82 & 2040) != 2040)
					{
						if ((word32) (byte) (ax_89 >> 0x03) != eax_50)
							*((word32) eax + 16) |= 0x04;
					}
					else
						*((word32) eax + 16) = ax_89 & 0xF807 | (word16) bLoc3C_240 << 0x03;
				}
				struct Eq_146466 * esi_124;
				Eq_2 ecx_126;
				word32 edx_294;
				read_encoded_value_with_base(edi_113, ebx_122 + 2, gs, fp - 0x20, out ecx_126, out edx_294, out ebx_122, out esi_124);
				Eq_2 esp_125 = <invalid>;
				Eq_146767 eax_132 = size_of_encoded_value((byte) edi_113, ecx_126, gs);
				ui32 edx_138 = ~0x00;
				if (eax_132 <= 0x03)
					edx_138 = (0x01 << (byte) eax_132 * 0x08) - 0x01;
				uint32 eax_149 = *((word32) esp_125 + 44);
				ecx_151 = esi_124;
				if ((eax_149 & edx_138) != 0x00)
				{
					*((word32) esp_125 + 28) = (word32) *((word32) esp_125 + 28) + 1;
					if (*eax > eax_149)
						*eax = eax_149;
					ecx_151 = esi_124;
				}
			}
			ebx_122 = ebx_122 + 1 + ebx_122->dw0000 / 4;
		} while (ebx_122->dw0000 != 0x00);
	}
	return dwLoc30_202;
}

// 0809FB70: Register Eq_2 add_fdes(Register Eq_2 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      search_object
Eq_2 add_fdes(Eq_2 eax, Eq_2 ecx, struct Eq_9 * gs)
{
	ui32 esi_107 = (word32) (byte) (*((word32) eax + 16) >> 0x03);
	base_from_object((byte) esi_107, ecx, eax, gs);
	Eq_2 ebx_105 = ecx;
	struct Eq_147708 * esp_120 = fp - 0x3C;
	Eq_2 ecx_109 = *ecx;
	if (ecx_109 != 0x00)
	{
		do
		{
			ui32 edx_47 = *((word32) ebx_105 + 4);
			if (edx_47 != 0x00)
			{
				if ((*((word32) eax + 16) & 0x04) != 0x00)
				{
					struct Eq_146466 * ebp_56 = (word32) ebx_105 + 4 - edx_47;
					if (ebp_56 != esp_120->ptr0000)
					{
						ui32 eax_62 = get_cie_encoding(ebp_56, gs, out ecx_109);
						word32 eax_73 = base_from_object((byte) eax_62, ecx_109, eax, gs);
						esp_120->ptr0000 = ebp_56;
						esp_120->dw0008 = eax_73;
						esi_107 = eax_62;
					}
				}
				if (esi_107 != 0x00)
				{
					struct Eq_147771 * esp_92 = esp_120 - 0x0C;
					esp_92->ptrFFFFFFFC = esp_92->ptr0018;
					Eq_146347 ebp_100 = (word32) (byte) esi_107;
					word32 edx_238;
					read_encoded_value_with_base(ebp_100, (word32) ebx_105 + 8, gs, esp_92->ptrFFFFFFFC, out ecx_109, out edx_238, out ebx_105, out esi_107);
					Eq_2 esp_108 = <invalid>;
					Eq_146767 eax_115 = size_of_encoded_value((byte) ebp_100, ecx_109, gs);
					esp_120 = (word32) esp_108 + 16;
					ui32 edx_121 = ~0x00;
					if (eax_115 <= 0x03)
					{
						ecx_109 = eax_115 * 0x08;
						edx_121 = (0x01 << (byte) eax_115 * 0x08) - 0x01;
					}
					if ((*((word32) esp_108 + 44) & edx_121) == 0x00)
					{
						ebx_105 = (word32) *ebx_105 + ((word32) ebx_105 + 4);
						if (*ebx_105 == 0x00)
							return ecx_109;
						continue;
					}
					goto l0809FBBF;
				}
				if (*((word32) ebx_105 + 8) != 0x00)
				{
l0809FBBF:
					struct Eq_147821 * eax_139 = *esp_120->ptr0004;
					if (eax_139 != null)
					{
						ui32 edx_143 = eax_139->dw0004;
						eax_139->dw0004 = edx_143 + 0x01;
						eax_139->a0008[edx_143] = ebx_105;
						ecx_109 = edx_143 + 0x01;
					}
				}
			}
			ebx_105 = (word32) *ebx_105 + ((word32) ebx_105 + 4);
		} while (*ebx_105 != 0x00);
	}
	return ecx_109;
}

// 0809FC80: Register Eq_2 search_object(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_Find_FDE
Eq_2 search_object(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 ebx_574;
	Eq_2 ebp_117 = eax;
	Eq_147861 al_25 = *((word32) eax + 16);
	if ((al_25 & 0x01) != 0x00)
	{
l0809FCA4:
		Eq_2 edi_618 = *((word32) ebp_117 + 0x0C);
		uint32 edi_621 = *((word32) edi_618 + 4);
		struct Eq_147889 * esp_619 = fp - 0x5C;
		uint32 dwLoc54_1179 = edi_621;
		if ((al_25 & 0x04) == 0x00)
		{
			Eq_147861 ax_724 = *((word32) ebp_117 + 16);
			uint32 ecx_723 = 0x00;
			if ((ax_724 & 2040) == 0x00)
			{
				while (ecx_723 < dwLoc54_1179)
				{
					uint32 eax_841;
					Eq_2 esi_845;
					uint32 edx_828 = ecx_723 + dwLoc54_1179;
					ebx_574 = *((word32) edi_618 + ((edx_828 >> 0x01) * 0x04 + 8));
					uint32 edx_829 = edx_828 >> 0x01;
					Eq_2 esi_832 = *((byte) ebx_574.u0 + 8);
					up32 edi_833 = *((byte) ebx_574.u0 + 0x0C);
					if (edx < esi_832)
					{
						while (edx_829 > ecx_723)
						{
							uint32 eax_840 = edx_829 + ecx_723;
							ebx_574 = *((word32) edi_618 + ((eax_840 >> 0x01) * 0x04 + 8));
							eax_841 = eax_840 >> 0x01;
							esi_845 = *((byte) ebx_574.u0 + 8);
							edi_833 = (up32) *((byte) ebx_574.u0 + 0x0C);
							if (edx >= esi_845)
								goto l0809FD90;
							edx_829 = eax_840 >> 0x01;
						}
						break;
					}
					eax_841 = edx_828 >> 0x01;
					edx_829 = dwLoc54_1179;
					esi_845 = esi_832;
l0809FD90:
					if (edx < (word32) esi_845 + edi_833)
						return ebx_574;
					ecx_723 = eax_841 + 0x01;
					dwLoc54_1179 = edx_829;
				}
			}
			else
			{
				base_from_object((byte) (ax_724 >> 0x03), 0x00, ebp_117, gs);
				if (edi_621 != 0x00)
				{
					uint32 ebp_754 = edi_621;
					uint32 edi_756 = 0x00;
					do
					{
						struct Eq_148392 * esp_766 = esp_619 - 0x0C;
						Eq_2 ebx_769 = esp_619->ptr0010->a0008[ebp_754 + edi_756 >> 0x01];
						esp_766->ptrFFFFFFFC = esp_766->ptr0024;
						word32 ebx_1331;
						word32 esi_1332;
						word32 ecx_1329;
						word32 edx_1330;
						Eq_2 eax_777 = read_encoded_value_with_base(esp_766->t0020, (word32) ebx_769 + 8, gs, esp_766->ptrFFFFFFFC, out ecx_1329, out edx_1330, out ebx_1331, out esi_1332);
						Eq_2 esp_781 = <invalid>;
						*esp_781 = *((word32) esp_781 + 44);
						uint32 esi_800;
						word32 edx_1334;
						word32 ecx_1333;
						read_encoded_value_with_base(*((word32) esp_781 + 24), eax_777, gs, *esp_781, out ecx_1333, out edx_1334, out ebx_574, out esi_800);
						Eq_2 esp_801 = <invalid>;
						Eq_2 eax_807 = *((word32) esp_801 + 0x0044);
						esp_619 = (word32) esp_801 + 16;
						Eq_2 edx_809 = *((word32) esp_801 + 28);
						if (eax_807 > edx_809)
							ebp_754 = esi_800;
						else
						{
							if (eax_807 + Mem791[esp_801 + 0x48:word32] >u edx_809)
								return ebx_574;
							edi_756 = esi_800 + 0x01;
						}
					} while (edi_756 < ebp_754);
				}
			}
		}
		else if (edi_621 != 0x00)
		{
			do
			{
				Eq_2 edi_642 = esp_619->ptr0010->a0008[esp_619->dw0008 + esp_619->dw0014 >> 0x01];
				Eq_2 ecx_648;
				Eq_146347 ebp_656 = (word32) (byte) get_cie_encoding((word32) edi_642 + 4 - *((word32) edi_642 + 4), gs, out ecx_648);
				base_from_object((byte) ebp_656, ecx_648, esp_619->t0020, gs);
				struct Eq_148503 * esp_667 = esp_619 - 0x0C;
				esp_667->ptrFFFFFFFC = esp_667->ptr0024;
				Eq_146347 ebx_676;
				word32 ecx_1335;
				word32 edx_1336;
				word32 esi_1337;
				Eq_2 eax_675 = read_encoded_value_with_base(ebp_656, (word32) edi_642 + 8, gs, esp_667->ptrFFFFFFFC, out ecx_1335, out edx_1336, out ebx_676, out esi_1337);
				Eq_2 esp_679 = <invalid>;
				*esp_679 = *((word32) esp_679 + 44);
				up32 esi_698;
				word32 ecx_1338;
				word32 ebx_1340;
				word32 edx_1339;
				read_encoded_value_with_base(ebx_676, eax_675, gs, *esp_679, out ecx_1338, out edx_1339, out ebx_1340, out esi_698);
				Eq_2 esp_699 = <invalid>;
				Eq_2 eax_705 = *((word32) esp_699 + 0x0044);
				esp_619 = (word32) esp_699 + 16;
				Eq_2 ecx_707 = *((word32) esp_699 + 28);
				if (eax_705 > ecx_707)
					*((word32) esp_699 + 24) = esi_698;
				else
				{
					if (eax_705 + Mem689[esp_699 + 0x48:word32] >u ecx_707)
					{
						ebx_574 = edi_642;
						return ebx_574;
					}
					*((word32) esp_699 + 36) = esi_698 + 0x01;
				}
			} while (*((word32) esp_699 + 36) < *((word32) esp_699 + 24));
		}
		goto l0809FD0F;
	}
	Eq_147861 esi_29 = *((word32) eax + 16);
	uint32 esi_30 = esi_29 >> 11;
	uint32 dwLoc3C_900 = esi_29 >> 11;
	if (esi_29 >> 11 == 0x00)
	{
		struct Eq_147554 * ebx_34 = *((word32) eax + 0x0C);
		if ((al_25 & 0x02) != 0x00)
		{
			struct Eq_147554 * edx_51 = ebx_34->dw0000;
			if (edx_51 == null)
				goto l0809FEA7;
			do
			{
				uint32 eax_59 = classify_object_over_fdes(eax, edx_51, gs);
				if (eax_59 == ~0x00)
				{
l0809FD6B:
					*((word32) eax + 16) = 2040;
					*((word32) eax + 0x0C) = &g_t80BA3A8;
					goto l0809FEA7;
				}
				++ebx_34;
				edx_51 = ebx_34->dw0000;
				esi_30 += eax_59;
			} while (edx_51 != null);
			dwLoc3C_900 = esi_30;
		}
		else
		{
			uint32 eax_41 = classify_object_over_fdes(eax, ebx_34, gs);
			dwLoc3C_900 = eax_41;
			if (eax_41 == ~0x00)
				goto l0809FD6B;
		}
		if ((dwLoc3C_900 & 0xFFE00000) != 0x00)
			*((word32) eax + 16) &= 0x07FF;
		else
			*((word32) eax + 16) = *((word32) eax + 16) & 0x07FF | dwLoc3C_900 << 11;
		if (dwLoc3C_900 == 0x00)
		{
l0809FEA7:
			if (*ebp_117 > edx)
				goto l0809FD0F;
			al_25 = *((word32) ebp_117 + 16);
			Eq_2 esi_553 = *((word32) ebp_117 + 0x0C);
			if ((al_25 & 0x01) == 0x00)
			{
				if ((al_25 & 0x02) == 0x00)
				{
					ebx_574 = linear_search_fdes(ebp_117, edx, esi_553, gs);
					return ebx_574;
				}
				Eq_2 edx_575 = *esi_553;
				while (edx_575 != 0x00)
				{
					Eq_2 eax_586 = linear_search_fdes(ebp_117, edx, edx_575, gs);
					if (eax_586 != 0x00)
						return eax_586;
					esi_553 = (word32) esi_553 + 4;
					edx_575 = *esi_553;
				}
l0809FD0F:
				ebx_574.u0 = 0x00;
				return ebx_574;
			}
			goto l0809FCA4;
		}
	}
	Eq_2 esi_122;
	word32 edi_1319;
	word32 ecx_1316;
	word32 ebx_1318;
	word32 edx_1317;
	Eq_2 eax_116 = __libc_malloc(gs, dwLoc70, dwLoc3C_900 * 0x04 + 0x08, out ecx_1316, out edx_1317, out ebx_1318, out ebp_117, out esi_122, out edi_1319);
	if (eax_116 == 0x00)
		goto l0809FEA7;
	*((word32) eax_116 + 4) = 0x00;
	Eq_2 ebp_138;
	word32 ecx_1320;
	word32 edi_1324;
	word32 edx_1321;
	word32 ebx_1322;
	word32 esi_1323;
	Eq_2 eax_137 = __libc_malloc(gs, dwLoc70, esi_122, out ecx_1320, out edx_1321, out ebx_1322, out ebp_138, out esi_1323, out edi_1324);
	if (eax_137 != 0x00)
		*((word32) eax_137 + 4) = 0x00;
	Eq_2 ecx_167;
	Eq_2 ebx_156 = *((word32) ebp_138 + 0x0C);
	if ((*((word32) ebp_138 + 16) & 0x02) != 0x00)
	{
		ecx_167 = *ebx_156;
		if (ecx_167 == 0x00)
			goto l080A0341;
		do
		{
			add_fdes(ebp_138, ecx_167, gs);
			ebx_156 = (word32) ebx_156 + 4;
			ecx_167 = *ebx_156;
		} while (ecx_167 != 0x00);
	}
	else
		ecx_167 = add_fdes(ebp_138, ebx_156, gs);
	if (eax_116 != 0x00 && *((word32) eax_116 + 4) != dwLoc3C_900)
	{
l080A0341:
		word32 ecx_1325;
		word32 edx_1326;
		abort(ecx_167, gs, out ecx_1325, out edx_1326);
	}
	if ((*((word32) ebp_138 + 16) & 0x04) == 0x00)
		(*((word32) ebp_138 + 16) & 2040) != 0x00;
	if (eax_137 == 0x00)
	{
		frame_heapsort(ebp_138, eax_116, gs);
		goto l080A028B;
	}
	ui32 ebx_264;
	uint32 edx_265;
	uint32 eax_258 = *((word32) eax_116 + 4);
	if (eax_258 != 0x00)
	{
		Eq_148187 eax_268 = eax_258 * 0x04 + 0x04;
		Eq_148187 ebx_271 = 0x08;
		Eq_148194 ebp_277 = 0x080CFB80;
		while (true)
		{
l080A00D8:
			Mem284[eax_137 + ebx_271:word32] = ebp_277;
			ebp_277 = eax_116 + ebx_271;
			if (eax_268 == ebx_271)
				break;
			while (ebp_277 != 0x080CFB80)
			{
				if (fde_mixed_encoding_compare(gs, ebp_138, *((word32) ebx_271 + ((word32) eax_116 + 4))) >= 0x00)
				{
					ebx_271 = (word32) ebx_271 + 4;
					goto l080A00D8;
				}
				word32 eax_326 = ebp_277 - (eax_116 + 0x08) + eax_137;
				ebp_277 = eax_326->t0008;
				eax_326->t0008.u0 = 0x00;
			}
			ebp_277.u0 = 0x080CFB80;
			ebx_271 = (word32) ebx_271 + 4;
		}
		ebx_264 = 0x00;
		edx_265 = 0x00;
		uint32 eax_334 = 0x00;
		do
		{
			struct Eq_146145 * ecx_344 = *((word32) eax_116 + (eax_334 * 0x04 + 8));
			if (*((word32) eax_137 + (eax_334 * 0x04 + 8)) == null)
			{
				*((word32) eax_137 + (ebx_264 * 0x04 + 8)) = ecx_344;
				++ebx_264;
			}
			else
			{
				*((word32) eax_116 + (edx_265 * 0x04 + 8)) = ecx_344;
				++edx_265;
			}
			++eax_334;
		} while (eax_258 != eax_334);
	}
	else
	{
		ebx_264 = 0x00;
		edx_265 = 0x00;
	}
	*((word32) eax_116 + 4) = edx_265;
	*((word32) eax_137 + 4) = ebx_264;
	ecx_167 = eax_137;
	if (Mem375[eax_137 + 0x04:word32] + Mem375[eax_116 + 0x04:word32] != dwLoc3C_900)
		goto l080A0341;
	frame_heapsort(ebp_138, eax_137, gs);
	ui32 eax_404 = *((word32) eax_137 + 4);
	if (eax_404 == 0x00)
	{
l080A0278:
		word32 edx_1328;
		word32 ecx_1327;
		free(gs, dwLoc70, eax_137, out ecx_1327, out edx_1328);
l080A028B:
		*eax_116 = *((word32) ebp_138 + 0x0C);
		*((word32) ebp_138 + 0x0C) = eax_116;
		*((word32) ebp_138 + 16) |= 0x01;
		ebp_117 = ebp_138;
		goto l0809FEA7;
	}
	uint32 edi_412 = *((word32) eax_116 + 4);
l080A01D0:
	ui32 esi_433;
	ui32 edx_417 = eax_404 - 0x01;
	struct Eq_148367 * ebx_419 = (word32) eax_137 + eax_404 * 0x04;
	struct Eq_146145 * edx_420 = ebx_419->ptr0004;
	ui32 dwLoc44_1005 = edx_417;
	struct Eq_146145 * dwLoc4C_1006 = edx_420;
	if (edi_412 != 0x00)
	{
		uint32 esi_439 = edi_412;
		ui32 edi_440 = eax_404 - 0x01 + edi_412;
		do
		{
			uint32 ebx_445 = esi_439 - 0x01;
			if (fde_mixed_encoding_compare(gs, ebp_138, *((word32) eax_116 + (ebx_445 * 0x04 + 8))) <= 0x00)
			{
				edi_412 = esi_439;
				esi_433 = edi_440;
				goto l080A0236;
			}
			*((word32) eax_116 + (edi_440 * 0x04 + 8)) = *((word32) eax_116 + (ebx_445 * 0x04 + 8));
			esi_439 = ebx_445;
			--edi_440;
		} while (ebx_445 != 0x00);
		edi_412 = ebx_445;
		esi_433 = edx_417;
	}
	else
	{
		ui32 ecx_427 = eax_404 - 0x01;
		*((word32) eax_116 + (ecx_427 * 0x04 + 8)) = edx_420;
		if (ecx_427 == 0x00)
			goto l080A0260;
		esi_433 = eax_404 - 0x02;
		dwLoc44_1005 = esi_433;
		dwLoc4C_1006 = ebx_419->ptr0000;
	}
l080A0236:
	*((word32) eax_116 + (esi_433 * 0x04 + 8)) = dwLoc4C_1006;
	if (dwLoc44_1005 != 0x00)
	{
		eax_404 = dwLoc44_1005;
		goto l080A01D0;
	}
l080A0260:
	Mem500[eax_116 + 0x04:word32] = Mem493[eax_116 + 0x04:word32] + Mem493[eax_137 + 0x04:word32];
	goto l080A0278;
}

// 080A0350: void __register_frame_info_bases.part.5(Register (ptr32 word32) eax, Register word32 ecx, Register Eq_2 edx, Stack ptr32 dwArg04)
// Called from:
//      search_object
//      __register_frame_info_bases
//      __register_frame_info
//      __register_frame
void __register_frame_info_bases.part.5(word32 * eax, word32 ecx, Eq_2 edx, ptr32 dwArg04)
{
	*edx = ~0x00;
	*((word32) edx + 4) = ecx;
	*((word32) edx + 0x0C) = eax;
	*((word32) edx + 8) = dwArg04;
	*((word32) edx + 16) = 2040;
	Eq_2 eax_48 = unseen_objects;
	unseen_objects = edx;
	*((word32) edx + 20) = eax_48;
	if (any_objects_registered == 0x00)
		any_objects_registered = 0x01;
}

// 080A03E0: void __register_frame_info_bases(Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack ptr32 dwArg10)
// Called from:
//      frame_dummy
void __register_frame_info_bases(word32 * dwArg04, Eq_2 dwArg08, word32 dwArg0C, ptr32 dwArg10)
{
	if (dwArg04 == null || *dwArg04 == 0x00)
		return;
	__register_frame_info_bases.part.5(dwArg04, dwArg0C, dwArg08, dwArg10);
}

// 080A0420: void __register_frame_info(Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08)
void __register_frame_info(word32 * dwArg04, Eq_2 dwArg08)
{
	if (dwArg04 == null || *dwArg04 == 0x00)
		return;
	__register_frame_info_bases.part.5(dwArg04, 0x00, dwArg08, 0x00);
}

// 080A0450: void __register_frame(Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04)
void __register_frame(struct Eq_9 * gs, word32 * dwArg04)
{
	if (*dwArg04 == 0x00)
		return;
	word32 * esi_29;
	word32 ecx_84;
	word32 edx_85;
	word32 ebx_86;
	word32 ebp_87;
	word32 edi_88;
	Eq_2 eax_23 = __libc_malloc(gs, dwLoc20, 0x18, out ecx_84, out edx_85, out ebx_86, out ebp_87, out esi_29, out edi_88);
	__register_frame_info_bases.part.5(esi_29, 0x00, eax_23, 0x00);
}

// 080A04A0: void __register_frame_info_table_bases(Stack word32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      __register_frame_info_table
//      __register_frame_table
void __register_frame_info_table_bases(word32 dwArg04, Eq_2 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	*dwArg08 = ~0x00;
	*((word32) dwArg08 + 4) = dwArg0C;
	*((word32) dwArg08 + 16) = 2042;
	*((word32) dwArg08 + 8) = dwArg10;
	*((word32) dwArg08 + 0x0C) = dwArg04;
	Eq_2 eax_39 = unseen_objects;
	unseen_objects = dwArg08;
	*((word32) dwArg08 + 20) = eax_39;
	if (any_objects_registered == 0x00)
		any_objects_registered = 0x01;
}

// 080A0540: void __register_frame_info_table(Stack word32 dwArg04, Stack Eq_2 dwArg08)
void __register_frame_info_table(word32 dwArg04, Eq_2 dwArg08)
{
	__register_frame_info_table_bases(dwArg04, dwArg08, 0x00, 0x00);
}

// 080A0560: void __register_frame_table(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
void __register_frame_table(struct Eq_9 * gs, word32 dwArg04)
{
	word32 ecx_57;
	word32 edx_58;
	word32 ebx_59;
	word32 ebp_60;
	word32 esi_61;
	word32 edi_62;
	__register_frame_info_table_bases(dwArg04, __libc_malloc(gs, dwLoc20, 0x18, out ecx_57, out edx_58, out ebx_59, out ebp_60, out esi_61, out edi_62), 0x00, 0x00);
}

// 080A0590: Register Eq_2 __deregister_frame_info_bases(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __do_global_dtors_aux
//      __deregister_frame_info
//      __deregister_frame
Eq_2 __deregister_frame_info_bases(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00 || *dwArg04 == 0x00)
		return 0x00;
	Eq_2 esi_100;
	Mem58 = Mem15;
	Eq_2 eax_59 = unseen_objects;
	if (eax_59 != 0x00)
	{
		word32 * eax_178;
		if (dwArg04 == *((word32) eax_59 + 0x0C))
		{
			esi_100 = eax_59;
			eax_178 = (word32 *) &unseen_objects;
l080A063B:
			*eax_178 = (word32) *((word32) esi_100 + 20);
			return esi_100;
		}
		while (true)
		{
			esi_100 = *((word32) eax_59 + 20);
			if (esi_100 == 0x00)
				break;
			if (dwArg04 == *((word32) esi_100 + 0x0C))
			{
				eax_178 = (word32) eax_59 + 20;
				goto l080A063B;
			}
			eax_59 = esi_100;
		}
	}
	esi_100 = seen_objects;
	if (esi_100 != 0x00)
	{
		word32 * edx_162 = &seen_objects;
		do
		{
			Eq_2 eax_88 = *((word32) esi_100 + 0x0C);
			if ((*((word32) esi_100 + 16) & 0x01) == 0x00)
			{
				if (dwArg04 == eax_88)
				{
					*edx_162 = (word32) *((word32) esi_100 + 20);
					return esi_100;
				}
			}
			else if (dwArg04 == *eax_88)
			{
				*edx_162 = (word32) *((word32) esi_100 + 20);
				word32 edx_320;
				word32 ecx_167;
				free(gs, dwLoc30, eax_88, out ecx_167, out edx_320);
				return esi_100;
			}
			edx_162 = (word32) esi_100 + 20;
			esi_100 = *((word32) esi_100 + 20);
		} while (esi_100 != 0x00);
	}
	word32 ecx_318;
	word32 edx_319;
	abort(ecx, gs, out ecx_318, out edx_319);
}

// 080A06B0: void __deregister_frame_info(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void __deregister_frame_info(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	__deregister_frame_info_bases(ecx, gs, dwArg04);
}

// 080A06C0: void __deregister_frame(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void __deregister_frame(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (*dwArg04 == 0x00)
		return;
	word32 ecx_68;
	word32 edx_69;
	free(gs, dwLoc20, __deregister_frame_info_bases(ecx, gs, dwArg04), out ecx_68, out edx_69);
}

// 080A0710: Register (ptr32 Eq_148856) _Unwind_Find_FDE(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 edxOut)
// Called from:
//      uw_frame_state_for
//      _Unwind_FindEnclosingFunction
struct Eq_148856 * _Unwind_Find_FDE(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & edxOut)
{
	struct Eq_148856 * edi_151;
	ptr32 edx_245;
	if (any_objects_registered == 0x00)
	{
l080A0734:
		if (__dl_iterate_phdr(gs, &g_t809F450, fp - 0x34, out edx_245) >= 0x00)
			edi_151 = null;
		else
			edi_151 = null;
	}
	else
	{
		Mem41 = Mem25;
		Eq_2 esi_174 = seen_objects;
		while (esi_174 != 0x00)
		{
			if (dwArg04 >= *esi_174)
			{
				struct Eq_148856 * eax_60 = search_object(esi_174, dwArg04, gs);
				edi_151 = eax_60;
				if (eax_60 != null)
					goto l080A07FE;
				break;
			}
			esi_174 = *((word32) esi_174 + 20);
		}
		do
		{
			esi_174 = unseen_objects;
			if (esi_174 == 0x00)
				goto l080A0734;
			union Eq_2 * edi_125;
			unseen_objects = *((word32) esi_174 + 20);
			struct Eq_148856 * eax_110 = search_object(esi_174, dwArg04, gs);
			Eq_2 edx_117 = seen_objects;
			if (edx_117 != 0x00)
			{
				Eq_2 ecx_121 = *esi_174;
				if (*edx_117 < ecx_121)
					goto l080A08D0;
				do
				{
					edi_125 = (word32) edx_117 + 20;
					edx_117 = *((word32) edx_117 + 20);
				} while (edx_117 != 0x00 && *edx_117 >= ecx_121);
			}
			else
			{
l080A08D0:
				edi_125 = &seen_objects;
			}
			*((word32) esi_174 + 20) = edx_117;
			*edi_125 = (union Eq_2 *) esi_174;
		} while (eax_110 == null);
		edi_151 = eax_110;
l080A07FE:
		Eq_146347 ebx_215;
		*dwArg08 = *((word32) esi_174 + 4);
		*((word32) dwArg08 + 4) = *((word32) esi_174 + 8);
		Eq_2 ecx_195 = dwArg08;
		if ((*((word32) esi_174 + 16) & 0x04) == 0x00)
			ebx_215 = (word32) (byte) (*((word32) esi_174 + 16) >> 0x03);
		else
			ebx_215 = (word32) (byte) get_cie_encoding(&edi_151->dw0004 - edi_151->dw0004, gs, out ecx_195);
		base_from_object((byte) ebx_215, ecx_195, esi_174, gs);
		word32 ecx_435;
		word32 ebx_436;
		word32 esi_437;
		read_encoded_value_with_base(ebx_215, &edi_151->dw0004 + 1, gs, fp - 0x34, out ecx_435, out edx_245, out ebx_436, out esi_437);
		Eq_2 esp_247 = <invalid>;
		*((word32) *((word32) esp_247 + 100) + 8) = *((word32) esp_247 + 40);
	}
	edxOut = edx_245;
	return edi_151;
}

// 080A0930: void base_of_encoded_value(Register byte al, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      __gcc_personality_v0
void base_of_encoded_value(byte al, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	byte al = (byte) eax;
	if (al == ~0x00)
		return;
	if ((al & 0x70) == 0x20)
		_Unwind_GetTextRelBase();
	else
	{
		if ((al & 0x70) > 0x20)
		{
			if ((al & 0x70) == 0x40)
			{
				_Unwind_GetRegionStart();
				return;
			}
			if ((al & 0x70) == 0x50)
				return;
			if ((al & 0x70) == 0x30)
			{
				_Unwind_GetDataRelBase();
				return;
			}
		}
		else if ((al & 0x70) == 0x00 || (al & 0x70) == 0x10)
			return;
		word32 edx_97;
		word32 ecx_96;
		abort(ecx, gs, out ecx_96, out edx_97);
	}
}

// 080A09B0: Register ptr32 read_encoded_value_with_base(Register ptr32 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      base_of_encoded_value
//      __gcc_personality_v0
ptr32 read_encoded_value_with_base(ptr32 eax, Eq_2 ecx, struct Eq_9 * gs, word32 * dwArg04, union Eq_2 & ecxOut)
{
	byte al = (byte) eax;
	word24 eax_24_8 = SLICE(eax, word24, 8);
	if (al == 0x50)
	{
		word32 * esi_28 = (word32) ecx + 3 & ~0x03;
		*dwArg04 = *esi_28;
		ecxOut = ecx;
		return esi_28 + 1;
	}
	else if ((al & 0x0F) > 0x0C)
		read_encoded_value_with_base.cold.0(ecx, gs);
	else
	{
		ui32 edx_51 = (word32) (al & 0x0F);
		<anonymous> * ecx_53 = g_a80BA3B0[edx_51 * 0x04] + 0x080CE000;
		Eq_2 ecx_55;
		ptr32 eax_57;
		ecx_53();
		ecxOut = ecx_55;
		return eax_57;
	}
}

// 080A0B00: void __gcc_personality_v0(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack byte bArg08, Stack Eq_2 dwArg18)
void __gcc_personality_v0(struct Eq_9 * gs, word32 dwArg04, byte bArg08, Eq_2 dwArg18)
{
	if (dwArg04 == 0x01)
	{
		if ((bArg08 & 0x02) != 0x00)
		{
			byte * eax_34 = _Unwind_GetLanguageSpecificData(dwArg18);
			if (eax_34 != null)
			{
				if (dwArg18 != 0x00)
					_Unwind_GetRegionStart();
				struct Eq_149117 * esp_100 = fp - 0x5C;
				byte dl_59 = *eax_34;
				Eq_2 ebx_58 = eax_34 + 1;
				if (dl_59 != ~0x00)
				{
					ptr32 esi_63 = (word32) dl_59;
					base_of_encoded_value((byte) esi_63, dwArg18, dwArg18, gs);
					Eq_2 esp_86 = <invalid>;
					esp_100 = (word32) esp_86 + 16;
					word32 ecx_470;
					ebx_58 = read_encoded_value_with_base(esi_63, eax_34 + 1, gs, fp - 0x30, out ecx_470);
				}
				byte al_99 = *ebx_58;
				esp_100->b003C = al_99;
				struct Eq_149157 * edx_110 = (word32) ebx_58 + 1;
				if (al_99 != ~0x00)
				{
					ui32 esi_109 = 0x00;
					uip32 ecx_464 = 0x00;
					do
					{
						++edx_110;
						ui32 ebx_113 = (word32) edx_110->bFFFFFFFF;
						byte cl_116 = (byte) ecx_464;
						esi_109 |= (ebx_113 & 0x7F) << cl_116;
						ecx_464 = SEQ(SLICE(ecx_464 + 0x07, word24, 8), cl_116 + 0x07);
					} while ((byte) ebx_113 < 0x00);
					esp_100->dw0034 = edx_110 + esi_109;
				}
				else
					esp_100->dw0034 = 0x00;
				esp_100->b003D = edx_110->b0000;
				ui32 ebx_135 = 0x00;
				Eq_2 esi_142 = edx_110 + 1;
				uip32 ecx_467 = 0x00;
				do
				{
					esi_142 = (word32) esi_142 + 1;
					ui32 edx_146 = (word32) *((word32) esi_142 - 1);
					byte cl_149 = (byte) ecx_467;
					ebx_135 |= (edx_146 & 0x7F) << cl_149;
					ecx_467 = SEQ(SLICE(ecx_467 + 0x07, word24, 8), cl_149 + 0x07);
				} while ((byte) edx_146 < 0x00);
				struct Eq_149209 * esp_162 = esp_100 - 0x08;
				esp_162->t0040 = (word32) esi_142 + ebx_135;
				esp_162->ptrFFFFFFFC = &esp_162->dw0020;
				esp_162->ptrFFFFFFF8 = esp_162->ptr007C;
				struct Eq_149227 * esp_179 = (char *) &esp_162->ptrFFFFFFFC + 0x0C;
				Eq_2 ecx_173;
				up32 edi_183 = _Unwind_GetIPInfo(esp_162->ptrFFFFFFF8, esp_162->ptrFFFFFFFC, out ecx_173) - (word32) (esp_162->dw0020 < 0x01);
				if (esp_162->t0040 > esi_142)
				{
					esp_162->ptr000C = &esp_162->dw0020 + 2;
					esp_162->ptr0010 = &esp_162->dw0020 + 3;
					Eq_2 esi_191 = esi_142;
					do
					{
						ptr32 ebx_194 = (word32) esp_179->b003D;
						base_of_encoded_value((byte) ebx_194, ecx_173, 0x00, gs);
						struct Eq_149305 * esp_206 = esp_179 - 0x0C;
						esp_206->ptrFFFFFFFC = (word32 *) (&esp_162->dw0020 + 1);
						Eq_2 ecx_220;
						Eq_2 eax_215 = read_encoded_value_with_base(ebx_194, esi_191, gs, esp_206->ptrFFFFFFFC, out ecx_220);
						Eq_2 esp_219 = <invalid>;
						ptr32 ebx_225 = (word32) *((word32) esp_219 + 77);
						base_of_encoded_value((byte) ebx_225, ecx_220, 0x00, gs);
						*esp_219 = *((word32) esp_219 + 20);
						Eq_2 ecx_249;
						Eq_2 eax_244 = read_encoded_value_with_base(ebx_225, eax_215, gs, *esp_219, out ecx_249);
						Eq_2 esp_248 = <invalid>;
						ptr32 ebx_254 = (word32) *((word32) esp_248 + 77);
						base_of_encoded_value((byte) ebx_254, ecx_249, 0x00, gs);
						*esp_248 = *((word32) esp_248 + 24);
						Eq_2 esp_277 = <invalid>;
						esp_179 = (word32) esp_277 + 16;
						esi_191 = read_encoded_value_with_base(ebx_254, eax_244, gs, *esp_248, out ecx_173);
						do
							esi_191 = (word32) esi_191 + 1;
						while (*((word32) esi_191 - 1) < 0x00);
						word32 eax_294 = Mem270[esp_277 + 44:word32] + Mem270[esp_277 + 0x38:word32];
						if (eax_294 > edi_183)
							break;
						if ((word32) *((word32) esp_277 + 48) + eax_294 > edi_183)
						{
							Eq_2 eax_302 = *((word32) esp_277 + 52);
							if (eax_302 == 0x00)
								break;
							word32 eax_306 = eax_302 + Mem270[esp_277 + 0x3C:word32];
							if (eax_306 == 0x00)
								break;
							*((word32) esp_277 + 8) = *((word32) esp_277 + 0x0080);
							*((word32) esp_277 + 4) = 0x00;
							*esp_277 = *((word32) esp_277 + 0x0084);
							_Unwind_SetGR(gs, *esp_277, *((word32) esp_277 + 4), *((word32) esp_277 + 8));
							((word32) esp_277 + 8)->u0 = 0x00;
							*((word32) esp_277 + 4) = 0x02;
							*esp_277 = *((word32) esp_277 + 0x0084);
							_Unwind_SetGR(gs, *esp_277, *((word32) esp_277 + 4), *((word32) esp_277 + 8));
							*((word32) esp_277 + 4) = eax_306;
							*esp_277 = *((word32) esp_277 + 0x0084);
							_Unwind_SetIP(*esp_277, *((word32) esp_277 + 4));
							return;
						}
					} while (*((word32) esp_277 + 72) > esi_191);
				}
			}
		}
	}
}

// 080A0D90: Register ptr32 __dl_iterate_phdr(Register (ptr32 Eq_9) gs, Stack (ptr32 code) dwArg04, Stack ptr32 dwArg08, Register out ptr32 edxOut)
// Called from:
//      _Unwind_Find_FDE
ptr32 __dl_iterate_phdr(struct Eq_9 * gs, <anonymous> * dwArg04, ptr32 dwArg08, ptr32 & edxOut)
{
	Eq_2175 ebx_23 = gs->t0014;
	ptr32 edx_134;
	Mem43 = Mem24;
	Eq_2 ebx_46 = g_t80CEA00;
	if (ebx_46 != 0x00)
	{
		Eq_2 edi_135 = ebx_46;
		do
		{
			struct Eq_123381 * eax_64 = *((word32) edi_135 + 20);
			if (eax_64->dw0248 != 0x00)
				_dl_tls_get_addr_soft(gs, eax_64);
			ptr32 eax_126;
			dwArg04();
			if (eax_126 != 0x00)
			{
				edx_134 = eax_126;
				goto l080A0EB2;
			}
			edi_135 = *((word32) edi_135 + 0x0C);
		} while (edi_135 != 0x00);
	}
	edx_134 = 0x00;
l080A0EB2:
	Mem180 = Mem144;
	if ((ebx_23 ^ gs->t0014) != 0x00)
	{
		word32 ecx_375;
		word32 edx_376;
		Eq_2 eax_189 = __stack_chk_fail(out ecx_375, out edx_376);
		byte al_195 = (byte) eax_189;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		Eq_2 esi_230 = _nl_domain_bindings;
		if (esi_230 == 0x00)
		{
			ptr32 edx_239;
			ptr32 eax_234 = fn080A0F73(&g_t80CE000, gs, out edx_239);
			edxOut = edx_239;
			return eax_234;
		}
		else
		{
			ptr32 edx_251;
			ptr32 eax_246 = fn080A0F32(&g_t80CE000, esi_230, &_nl_domain_bindings, gs, out edx_251);
			edxOut = edx_251;
			return eax_246;
		}
	}
	else
	{
		edxOut = edx_134;
		return edx_134;
	}
}

