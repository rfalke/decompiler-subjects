// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b80CF300 = 0x00; // 080CF300
Eq_2 output_charset_cache.11629 = // 080CF560
	{
		0
	};
word32 output_charset_cached.11630 = 0x00; // 080CF564
Eq_2 freemem_size.11587 = // 080CF568
	{
		0
	};
word32 * freemem.11586 = null; // 080CF56C
Eq_2 lock.11578 = // 080CF570
	{
		0
	};
Eq_2 transmem_list = // 080CF574
	{
		0
	};
word32 root = 0x00; // 080CF578
Eq_2 _nl_loaded_domains = // 080CF5C0
	{
		0
	};
Eq_2 g_t80CF5C4 = // 080CF5C4
	{
		0
	};
word32 g_dw80CF5C8 = 0x00; // 080CF5C8
Eq_2 g_t80CF5CC = // 080CF5CC
	{
		0
	};
ptr32 locale_alias_path.10080 = 0x00; // 080CF5D0
uint32 maxmap = 0x00; // 080CF5D4
uint32 nmap = 0x00; // 080CF5D8
up32 string_space_max = 0x00; // 080CF5DC
up32 string_space_act = 0x00; // 080CF5E0
Eq_2 lock = // 080CF5E4
	{
		0
	};
Eq_2 __abort_msg = // 080CF5E8
	{
		0
	};
Eq_2 g_t80CF5EC = // 080CF5EC
	{
		0
	};
word32 g_dw80CF5F0 = 0x00; // 080CF5F0
Eq_2 g_t80CF5F4 = // 080CF5F4
	{
		0
	};
word32 stage = 0x00; // 080CF5F8
Eq_10591 phys_pages.8655 = // 080CF5FC
	{
		0
	};
Eq_10487 pagesize.8656 = // 080CF600
	{
		0
	};
byte g_b80CF604 = 0x00; // 080CF604
Eq_2 freeres_list = // 080CF828
	{
		0
	};
byte g_b80CF82C = 0x00; // 080CF82C
word32 stdio_needs_locking = 0x00; // 080CF830
Eq_2 run_fp = // 080CF834
	{
		0
	};
Eq_2 g_t80CF838 = // 080CF838
	{
		0
	};
Eq_2 g_t80CF83C = // 080CF83C
	{
		0
	};
Eq_2 g_t80CF840 = // 080CF840
	{
		0
	};
<anonymous> * __after_morecore_hook = null; // 080CF868
Eq_2 __free_hook = // 080CF86C
	{
		0
	};
Eq_2 next_to_use.12583 = // 080CF870
	{
		0
	};
uint32 narenas_limit.12605 = 0x00; // 080CF874
word32 using_malloc_checking = 0x00; // 080CF878
Eq_2 aligned_heap_area = // 080CF87C
	{
		0
	};
Eq_2 list_lock = // 080CF880
	{
		0
	};
Eq_2 free_list = // 080CF884
	{
		0
	};
Eq_2 free_list_lock = // 080CF888
	{
		0
	};
Eq_2 perturb_byte = // 080CF88C
	{
		0
	};
Eq_2 global_max_fast = // 080CF890
	{
		0
	};
Eq_2 environ = // 080CF89C
	{
		0
	};
word32 timestamp.11438 = 0x00; // 080CF8A0
ui32 g_dw80CF8C8 = 0x00; // 080CF8C8
ui32 g_dw80CF8CC = 0x00; // 080CF8CC
Eq_2 g_t80CF8E0 = // 080CF8E0
	{
		0
	};
Eq_1563 g_t80CF8E4 = // 080CF8E4
	{
		0
	};
word32 g_dw80CF8E8 = 0x00; // 080CF8E8
Eq_2 g_t80CF8EC = // 080CF8EC
	{
		0
	};
Eq_2 g_t80CF8F0 = // 080CF8F0
	{
		0
	};
Eq_2 g_t80CF8F4 = // 080CF8F4
	{
		0
	};
byte g_b80CF8F7 = 0x00; // 080CF8F7
word32 g_dw80CF8F8 = 0x00; // 080CF8F8
Eq_2 g_t80CF8FC = // 080CF8FC
	{
		0
	};
word32 g_dw80CF900 = 0x00; // 080CF900
Eq_2 g_t80CF904 = // 080CF904
	{
		0
	};
ui32 g_dw80CF920 = 0x00; // 080CF920
ui32 g_dw80CF924 = 0x00; // 080CF924
Eq_2 g_t80CF928 = // 080CF928
	{
		0
	};
int32 g_dw80CF92C = 0; // 080CF92C
Eq_2 g_t80CF930 = // 080CF930
	{
		0
	};
word32 __compound_literal.2 = 0x00; // 080CF938
ui32 once = 0x00; // 080CF93C
word32 known_derivations = 0x00; // 080CF940
Eq_2 modcounter.12647 = // 080CF944
	{
		0
	};
Eq_2 lock.12667 = // 080CF948
	{
		0
	};
word32 cache_malloced = 0x00; // 080CF94C
Eq_2 cache_size = // 080CF950
	{
		0
	};
Eq_2 gconv_cache = // 080CF954
	{
		0
	};
Eq_2 release_handle = // 080CF958
	{
		0
	};
Eq_2 loaded = // 080CF95C
	{
		0
	};
Eq_2 archloaded = // 080CF980
	{
		0
	};
Eq_2 g_t80CFA00 = // 080CFA00
	{
		0
	};
Eq_2 g_t80CFA08 = // 080CFA08
	{
		0
	};
ptr32 archmapped = 0x00; // 080CFA10
Eq_2 last_environ = // 080CFA14
	{
		0
	};
Eq_2 known_values = // 080CFA18
	{
		0
	};
Eq_2 envlock = // 080CFA1C
	{
		0
	};
Eq_2 lock = // 080CFA20
	{
		0
	};
up32 next_bit = 0x00; // 080CFA24
Eq_2 lock = // 080CFA28
	{
		0
	};
Eq_2 lock = // 080CFA2C
	{
		0
	};
Eq_46335 __curbrk = // 080CFA40
	{
		0
	};
word32 max_dirnamelen = 0x00; // 080CFA44
Eq_123316 log_hashfraction = // 080CFA48
	{
		0x00
	};
Eq_50407 textsize = // 080CFA4C
	{
		0x00
	};
struct Eq_50406 * lowpc = null; // 080CFA50
Eq_28506 fromidx = // 080CFA54
	{
		0
	};
Eq_28506 fromlimit = // 080CFA58
	{
		0
	};
struct Eq_124498 * froms = null; // 080CFA5C
word32 tos = 0x00; // 080CFA60
union Eq_28506 * narcsp = null; // 080CFA64
Eq_28506 narcs = // 080CFA68
	{
		0
	};
struct Eq_50406 * running = null; // 080CFA6C
struct Eq_124564 * data = null; // 080CFA70
Eq_2 cachesize = // 080CFA74
	{
		0
	};
Eq_2 cache_new = // 080CFA78
	{
		0
	};
Eq_2 cache = // 080CFA7C
	{
		0
	};
ui32 once = 0x00; // 080CFA80
word32 key = 0x00; // 080CFA84
Eq_2 static_buf = // 080CFA88
	{
		0
	};
word32 g_dw80CFB2C = 0x00; // 080CFB2C
uint32 pc_scale = 0x00; // 080CFB3C
word32 pc_offset = 0x00; // 080CFB40
uint32 nsamples = 0x00; // 080CFB44
Eq_2 samples = // 080CFB48
	{
		0
	};
word32 dl_close_state.11755 = 0x00; // 080CFB4C
word32 once_regsizes.8965 = 0x00; // 080CFB50
Eq_146475 g_t80CFB54 = // 080CFB54
	{
		
		{
			0x00
		},
	};
byte g_b80CFB55 = 0x00; // 080CFB55
byte g_b80CFB56 = 0x00; // 080CFB56
byte g_b80CFB57 = 0x00; // 080CFB57
byte g_b80CFB58 = 0x00; // 080CFB58
byte g_b80CFB59 = 0x00; // 080CFB59
byte g_b80CFB5A = 0x00; // 080CFB5A
byte g_b80CFB5B = 0x00; // 080CFB5B
byte g_b80CFB5C = 0x00; // 080CFB5C
byte g_b80CFB5D = 0x00; // 080CFB5D
byte g_b80CFB5F = 0x00; // 080CFB5F
byte g_b80CFB60 = 0x00; // 080CFB60
byte g_b80CFB61 = 0x00; // 080CFB61
byte g_b80CFB62 = 0x00; // 080CFB62
byte g_b80CFB63 = 0x00; // 080CFB63
byte g_b80CFB64 = 0x00; // 080CFB64
word32 marker.8593 = 0x00; // 080CFB80
word32 g_dw80CFB88 = 0x00; // 080CFB88
word32 g_dw80CFB8C = 0x00; // 080CFB8C
Eq_2 frame_hdr_cache_head = // 080CFB90
	{
		0
	};
struct Eq_150058 g_t80CFBB8 = // 080CFBB8
	{
		0x00,
		0x00,
		0x00,
	};
word32 g_dw80CFC5C = 0x00; // 080CFC5C
word32 any_objects_registered = 0x00; // 080CFC78
Eq_2 seen_objects = // 080CFC7C
	{
		0
	};
Eq_2 unseen_objects = // 080CFC80
	{
		0
	};
Eq_2 _dl_tls_static_used = // 080CFCA0
	{
		0
	};
Eq_116890 _dl_tls_static_align = // 080CFCA4
	{
		0
	};
Eq_2 _dl_tls_max_dtv_idx = // 080CFCA8
	{
		0
	};
word32 g_dw80CFCC0 = 0x00; // 080CFCC0
Eq_125016 g_t80CFCC8 = // 080CFCC8
	{
		0x00,
	};
Eq_2 g_t80CFCD0 = // 080CFCD0
	{
		0
	};
word32 g_dw80CFCD4 = 0x00; // 080CFCD4
Eq_2 _dl_tls_dtv_slotinfo_list = // 080CFEC0
	{
		0
	};
byte g_b80CFEC4 = 0x00; // 080CFEC4
Eq_125016 _dl_tls_generation = // 080CFEC8
	{
		0x00,
	};
Eq_2 _dl_tls_static_nelem = // 080CFECC
	{
		0
	};
Eq_2 _nl_domain_bindings = // 080CFED0
	{
		0
	};
Eq_2 _nl_msg_cat_cntr = // 080CFED4
	{
		0
	};
Eq_2 __exit_funcs_lock = // 080CFED8
	{
		0
	};
word32 g_dw80CFEE0 = 0x00; // 080CFEE0
word32 g_dw80CFEE4 = 0x00; // 080CFEE4
Eq_48925 g_t80CFEE8 = // 080CFEE8
	{
		0x00,
		0x00,
		0x00,
		
		{
			0
		},
	};
word32 g_dw80CFEEC = 0x00; // 080CFEEC
Eq_2 g_t80CFEF8 = // 080CFEF8
	{
		0
	};
Eq_2 _dl_profile_output = // 080CFEFC
	{
		0
	};
Eq_2 _dl_platformlen = // 080CFF00
	{
		0
	};
Eq_2 _dl_debug_mask = // 080CFF04
	{
		0
	};
byte g_b80CFF05 = 0x00; // 080CFF05
<anonymous> * _dl_wait_lookup_done = null; // 080CFF08
Eq_2 _dl_profile = // 080CFF0C
	{
		0
	};
uint32 _dl_bind_not = 0x00; // 080CFF10
struct Eq_49164 * _dl_auxv = null; // 080CFF14
Eq_2 _dl_platform = // 080CFF18
	{
		0
	};
uint32 g_dw80CFF1C = 0x00; // 080CFF1C
uint32 g_dw80CFF20 = 0x00; // 080CFF20
uint32 _dl_lazy = 0x00; // 080CFF24
Eq_2 _dl_sysinfo_map = // 080CFF28
	{
		0
	};
word32 _dl_inhibit_cache = 0x00; // 080CFF2C
Eq_2 _dl_phdr = // 080CFF30
	{
		0
	};
Eq_2 _dl_scope_free_list = // 080CFF34
	{
		0
	};
Eq_2 _dl_origin_path = // 080CFF38
	{
		0
	};
word32 _dl_clktck = 0x00; // 080CFF3C
uint32 _dl_dynamic_weak = 0x00; // 080CFF40
Eq_2 _dl_sysinfo_dso = // 080CFF44
	{
		0
	};
Eq_2 _dl_init_all_dirs = // 080CFF48
	{
		0
	};
uint32 _dl_verbose = 0x00; // 080CFF4C
Eq_1938 _dl_phnum = // 080CFF50
	{
		0x00
	};
Eq_2 _dl_profile_map = // 080CFF54
	{
		0
	};
Eq_2 _dl_initfirst = // 080CFF58
	{
		0
	};
Eq_2 _dl_all_dirs = // 080CFF5C
	{
		0
	};
uint32 _dl_osversion = 0x00; // 080CFF60
byte * _dl_inhibit_rpath = null; // 080CFF64
Eq_2 g_t80CFF68 = // 080CFF68
	{
		0
	};
Eq_2 g_t80CFF6C = // 080CFF6C
	{
		0
	};
word32 __libc_enable_secure_decided = 0x00; // 080CFF70
word32 __libc_argc = 0x00; // 080CFF74
word32 * __libc_argv = null; // 080CFF78
Eq_2 __gconv_modules_db = // 080CFF7C
	{
		0
	};
Eq_2 __gconv_lock = // 080CFF80
	{
		0
	};
word32 __gconv_alias_db = 0x00; // 080CFF84
Eq_2 __gconv_path_envvar = // 080CFF88
	{
		0
	};
ptr32 __gconv_max_path_elem_len = 0x00; // 080CFF8C
Eq_2 __gconv_path_elem = // 080CFF90
	{
		0
	};
struct Eq_69708 * g_a80CFFA0[] = // 080CFFA0
	{
	};
Eq_2 (* __printf_function_table)[] = null; // 080CFFD4
Eq_2 __printf_modifier_table = // 080CFFD8
	{
		0
	};
word32 __x86_shared_non_temporal_threshold = 0x00; // 080CFFDC
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _dl_tls_static_size = 0x0800; // 080CE024
Eq_2 _nl_current_default_domain = // 080CE028
	{
		0x80CF620080A22D4
	};
word32 __exit_funcs = 0x080CF620; // 080CE02C
Eq_2 DW.ref.__gcc_personality_v0 = // 080CE030
	{
		0x080A0B00
	};
word32 g_dw80CE038 = 0x00; // 080CE038
Eq_2 _IO_list_all = // 080CE040
	{
		0x080CE060
	};
word32 g_dw80CE044 = 0x00; // 080CE044
word32 * g_ptr80CE04C = null; // 080CE04C
Eq_3851 (* g_ptr80CE084)[] = null; // 080CE084
Eq_153933 (* g_ptr80CE088)[] = null; // 080CE088
Eq_2 g_t80CE08C = // 080CE08C
	{
		0
	};
Eq_2 g_a80CE100[] = // 080CE100
	{
	};
word32 g_a80CE140[] = // 080CE140
	{
	};
<anonymous> * g_a80CE180[] = // 080CE180
	{
	};
struct Eq_56295 g_t80CE230 = // 080CE230
	{
		0x00,
	};
uint32 g_dw80CE254 = 0x080CF180; // 080CE254
word32 g_dw80CE2A8 = 0x00; // 080CE2A8
Eq_2 _IO_stderr = // 080CE474
	{
		0x80CE1C0080CE060
	};
Eq_2 _IO_stdout = // 080CE478
	{
		0x80CE320080CE1C0
	};
Eq_2 _IO_stdin = // 080CE47C
	{
		-4159904992
	};
word32 may_shrink_heap.11496 = ~0x00; // 080CE480
int32 __libc_malloc_initialized = -1; // 080CE484
Eq_2 narenas = // 080CE488
	{
		1
	};
ui32 g_dw80CE4A0 = 0x00020000; // 080CE4A0
up32 g_dw80CE4A4 = 0x00020000; // 080CE4A4
Eq_2 g_t80CE4A8 = // 080CE4A8
	{
		0x200020000
	};
Eq_2 g_t80CE4AC = // 080CE4AC
	{
		2
	};
uint32 g_dw80CE4B0 = 0x00; // 080CE4B0
Eq_28506 g_t80CE4B4 = // 080CE4B4
	{
		0
	};
Eq_28506 g_t80CE4B8 = // 080CE4B8
	{
		0x00010000
	};
Eq_2 g_t80CE4BC = // 080CE4BC
	{
		0
	};
word32 g_dw80CE4C0 = 0x00; // 080CE4C0
Eq_28506 g_t80CE4C4 = // 080CE4C4
	{
		0
	};
Eq_2 g_t80CE4C8 = // 080CE4C8
	{
		0
	};
Eq_2 g_t80CE4CC = // 080CE4CC
	{
		0x4000000000
	};
uint32 g_dw80CE4D0 = 0x40; // 080CE4D0
up32 g_dw80CE4D4 = 1020; // 080CE4D4
Eq_2 g_t80CE4D8 = // 080CE4D8
	{
		7
	};
word32 g_dw80CE4DC = 0x00; // 080CE4DC
<anonymous> * __memalign_hook = memalign_hook_ini; // 080CE4E0
<anonymous> * __realloc_hook = realloc_hook_ini; // 080CE4E4
<anonymous> * __malloc_hook = malloc_hook_ini; // 080CE4E8
Eq_2 g_t80CE500 = // 080CE500
	{
		0
	};
Eq_28185 g_t80CE504 = // 080CE504
	{
		0x00
	};
word32 g_dw80CE508 = 0x00; // 080CE508
Eq_2 g_t80CE538 = // 080CE538
	{
		0
	};
struct Eq_29810 g_t80CE930 = // 080CE930
	{
		0x00,
		0x00,
		0x00,
	};
Eq_2 g_t80CE948 = // 080CE948
	{
		0x080CE500
	};
up32 g_dw80CE954 = 0x00; // 080CE954
<anonymous> * __morecore = __default_morecore; // 080CE95C
Eq_2 cached_result.11437 = // 080CE960
	{
		0x80B41F9FFFFFFFF
	};
Eq_2 program_invocation_short_name = // 080CE964
	{
		0x80B41F9080B41F9
	};
Eq_2 __progname_full = // 080CE968
	{
		134955513
	};
ui32 _dl_stack_flags = 0x07; // 080CE9A0
ui32 _dl_correct_cache_id = 0x03; // 080CE9A8
word32 _dl_debug_fd = 0x02; // 080CE9AC
Eq_2 _dl_pagesize = // 080CE9B0
	{
		0x100001000
	};
word32 _dl_starting_up = 0x01; // 080CE9B4
up32 g_dw80CE9B8 = 0x01; // 080CE9B8
word32 g_dw80CE9BC = 0x00; // 080CE9BC
Eq_2 _dl_nns = // 080CE9C0
	{
		-0x1FFFFFFFF
	};
ui32 _dl_use_load_bias = ~0x01; // 080CE9C4
word32 _dl_sysinfo = 0x08063960; // 080CE9E0
<anonymous> * _dl_init_static_tls = _dl_nothread_init_static_tls; // 080CE9E4
Eq_2 g_t80CE9E8 = // 080CE9E8
	{
		4430031344
	};
word32 g_dw80CE9EC = 0x01; // 080CE9EC
word32 __compound_literal.3 = 0x080CEA60; // 080CE9F0
Eq_2 g_t80CEA00 = // 080CEA00
	{
		4430031456
	};
Eq_154643 g_a80CEA04[] = // 080CEA04
	{
	};
struct Eq_153631 * g_ptr80CEA08 = &g_t80CEBC0; // 080CEA08
word32 g_dw80CEA0C = 0x00; // 080CEA0C
Eq_154637 g_a80CEA30[] = // 080CEA30
	{
	};
Eq_153631 g_t80CEBC0 = // 080CEBC0
	{
		
		{
			0x1080CECC0
		},
		0x01,
	};
word32 __compound_literal.1 = 0x080CEA60; // 080CECC0
<anonymous> * _dl_make_stack_executable_hook = _dl_make_stack_executable; // 080CECD0
word32 __libc_multiple_libcs = 0x01; // 080CECD4
struct Eq_72699 * g_ptr80CEE60 = &g_t80CC740; // 080CEE60
word32 g_dw80CEE94 = 0x080A7940; // 080CEE94
word32 g_dw80CEE98 = 0x080A6A40; // 080CEE98
word32 g_dw80CEE9C = 0x080A7040; // 080CEE9C
Eq_2 g_a80CEEA0[] = // 080CEEA0
	{
	};
word32 pa_next_type = 0x08; // 080CEED8
word32 __x86_raw_shared_cache_size = 0x00100000; // 080CEEDC
word32 __x86_raw_shared_cache_size_half = 0x00080000; // 080CEEE0
word32 __x86_shared_cache_size = 0x00100000; // 080CEEE4
word32 __x86_shared_cache_size_half = 0x00080000; // 080CEEE8
word32 __x86_raw_data_cache_size = 0x8000; // 080CEEEC
word32 __x86_raw_data_cache_size_half = 0x4000; // 080CEEF0
word32 __x86_data_cache_size = 0x8000; // 080CEEF4
word32 __x86_data_cache_size_half = 0x4000; // 080CEEF8
word32 g_dw80CEF58 = ~0x00; // 080CEF58
word32 g_dw80CEF5C = ~0x00; // 080CEF5C
// subject_eh_frame_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw80BA428 = 0x30; // 080BA428
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080A1AB0: void _fini()
// Called from:
//      __libc_csu_fini
void _fini()
{
}

// subject_fini_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a80CC6B8[] = // 080CC6B8
	{
	};
// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __funlockfile_GOT = __funlockfile; // 080CDFD8
<anonymous> * free_GOT = free; // 080CDFEC
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_950 g_t80CE000 = // 080CE000
	{
		
		{
		},
		
		{
			0x8000000100000
		},
		0x00080000,
		0x00100000,
		0x00080000,
		0x00008000,
		0x00004000,
		0x00008000,
		0x00004000,
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049000: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
}

// subject_libc_atexit.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 __elf_set___libc_atexit_element__IO_cleanup__ = 0x08057410; // 080CF2F4
// subject_libc_freeres_fn.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080A0F10: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 esi_20 = _nl_domain_bindings;
	if (esi_20 == 0x00)
	{
		word32 edx_64;
		fn080A0F73(&g_t80CE000, gs, out edx_64);
	}
	else
	{
		word32 edx_65;
		fn080A0F32(&g_t80CE000, esi_20, &_nl_domain_bindings, gs, out edx_65);
	}
}

// 080A0F32: Register ptr32 fn080A0F32(Register (ptr32 Eq_152227) ebx, Register Eq_2 esi, Register (ptr32 Eq_2) edi, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      __dl_iterate_phdr
//      free_mem
ptr32 fn080A0F32(struct Eq_152227 * ebx, Eq_2 esi, union Eq_2 * edi, struct Eq_9 * gs, ptr32 & edxOut)
{
	Eq_2 esi_60 = esi;
	do
	{
		*edi = (union Eq_2 *) *esi_60;
		Eq_2 eax_13 = *((word32) esi_60 + 4);
		if (eax_13 != (char *) ebx - 0x0002BD40)
		{
			word32 ecx_93;
			word32 edx_94;
			free(gs, dwLoc14, eax_13, out ecx_93, out edx_94);
		}
		Eq_2 v11_38 = *((word32) esi_60 + 8);
		word32 ecx_95;
		word32 edx_96;
		free(gs, dwLoc1C, v11_38, out ecx_95, out edx_96);
		word32 ecx_97;
		word32 edx_98;
		free(gs, v11_38, esi_60, out ecx_97, out edx_98);
		dwLoc14 = esi_60;
		esi_60 = *edi;
	} while (esi_60 != 0x00);
	ptr32 edx_72;
	ptr32 eax_67 = fn080A0F73(ebx, gs, out edx_72);
	edxOut = edx_72;
	return eax_67;
}

// 080A0F73: Register Eq_2 fn080A0F73(Register (ptr32 Eq_152227) ebx, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      __dl_iterate_phdr
//      free_mem
Eq_2 fn080A0F73(struct Eq_152227 * ebx, struct Eq_9 * gs, ptr32 & edxOut)
{
	ptr32 esp_2 = fp;
	Eq_2 eax_6 = ebx->t0028;
	if (eax_6 != (char *) ebx - 0x0002BD2C)
	{
		word32 edx_119;
		word32 ecx_118;
		free(gs, dwLoc14, eax_6, out ecx_118, out edx_119);
		esp_2 = fp + 0x04;
	}
	ptr32 edx_38;
	struct Eq_152332 * esp_26 = esp_2 - 0x08;
	esp_26->ptrFFFFFFFC = ebx->ptrFFFFFFEC;
	esp_26->tFFFFFFF8 = ebx->t1578;
	tdestroy(gs, esp_26->tFFFFFFF8, esp_26->ptrFFFFFFFC);
	Eq_2 eax_44 = ebx->t1574;
	ebx->t1578.u0 = 0x00;
	ptr32 esp_45 = (char *) &esp_26->ptrFFFFFFFC + 0x0C;
	if (eax_44 != 0x00)
	{
		do
		{
			struct Eq_152369 * esp_54 = esp_45 - 0x0C;
			Eq_2 esi_58 = *eax_44;
			esp_54->tFFFFFFFC = eax_44;
			ebx->t1574 = esi_58;
			word32 ecx_120;
			free(gs, esp_54->tFFFFFFF8, esp_54->tFFFFFFFC, out ecx_120, out edx_38);
			eax_44 = esi_58;
			esp_45 = (char *) &esp_54->tFFFFFFFC + 20;
		} while (esi_58 != 0x00);
	}
	edxOut = edx_38;
	return eax_44;
}

// 080A0FF0: void _nl_finddomain_subfreeres(Register (ptr32 Eq_9) gs)
// Called from:
//      free_mem
void _nl_finddomain_subfreeres(struct Eq_9 * gs)
{
	ptr32 esp_10 = fp - 0x0C;
	Eq_2 esi_15 = _nl_loaded_domains;
	if (esi_15 != 0x00)
	{
		while (true)
		{
			Eq_2 eax_21 = *((word32) esi_15 + 8);
			if (eax_21 != 0x00)
			{
				struct Eq_152457 * esp_26 = esp_10 - 0x0C;
				esp_26->tFFFFFFFC = eax_21;
				_nl_unload_domain(gs, esp_26->tFFFFFFFC);
			}
			struct Eq_152413 * esp_41 = esp_10 - 0x0C;
			Eq_2 edi_45 = *((word32) esi_15 + 0x0C);
			esp_41->tFFFFFFFC = *esi_15;
			word32 ecx_110;
			word32 edx_111;
			free(gs, esp_41->tFFFFFFF8, esp_41->tFFFFFFFC, out ecx_110, out edx_111);
			esp_41->t0000 = esi_15;
			word32 edx_113;
			word32 ecx_112;
			free(gs, esp_41->tFFFFFFFC, esp_41->t0000, out ecx_112, out edx_113);
			esp_10 = (char *) &esp_41->t0000 + 20;
			if (edi_45 == 0x00)
				break;
			esi_15 = edi_45;
		}
	}
}

// 080A1050: void _nl_unload_domain(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _nl_finddomain_subfreeres
void _nl_unload_domain(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ebx_154 = 0x080CE000;
	Eq_2 ebp_112 = dwArg04;
	Eq_2 eax_20 = *((word32) dwArg04 + 96);
	if (eax_20 != 0x080CC6C0)
		__gettext_free_exp(gs, eax_20);
	ptr32 esp_118 = fp - 0x1C;
	if (*((word32) dwArg04 + 60) != 0x00)
	{
		Eq_2 esi_102 = 0x00;
		do
		{
			struct Eq_152504 * edi_55 = (word32) *((word32) ebp_112 + 56) + esi_102 * 0x0C;
			struct Eq_152511 * esp_53 = esp_118 - 0x0C;
			esp_53->tFFFFFFFC = edi_55->t0000;
			word32 ecx_314;
			word32 edx_315;
			free(gs, esp_53->tFFFFFFF8, esp_53->tFFFFFFFC, out ecx_314, out edx_315);
			Eq_2 eax_68 = edi_55->t0008;
			ptr32 esp_69 = (char *) &esp_53->t0000 + 16;
			if (eax_68 <= ~0x01)
			{
				esp_53->t0000 = eax_68;
				word32 edx_319;
				word32 ecx_318;
				free(gs, esp_53->tFFFFFFFC, esp_53->t0000, out ecx_318, out edx_319);
				esp_69 = (char *) &esp_53->t0000 + 20;
			}
			Eq_2 eax_89 = edi_55->t0004;
			if (eax_89 != ~0x00)
			{
				struct Eq_152586 * esp_93 = esp_69 - 0x0C;
				esp_93->tFFFFFFFC = eax_89;
				word32 ecx_320;
				word32 edx_321;
				__gconv_close(esp_93->tFFFFFFFC, out ecx_320, out edx_321, out ebx_154, out ebp_112, out esi_102);
			}
			esp_118 = esp_69;
			esi_102 = (word32) esi_102 + 1;
		} while (*((word32) ebp_112 + 60) > esi_102);
	}
	Eq_2 v14_124 = *((word32) ebp_112 + 56);
	word32 ecx_312;
	word32 edx_313;
	free(gs, dwLoc40, v14_124, out ecx_312, out edx_313);
	Eq_2 dwLoc34_279;
	Eq_2 v17_175 = *((word32) ebp_112 + 16);
	word32 edx_317;
	word32 ecx_316;
	free(gs, v14_124, v17_175, out ecx_316, out edx_317);
	if (*((word32) ebp_112 + 4) != 0x00)
	{
		Eq_2 v19_212 = *ebp_112;
		word32 ebx_326;
		word32 edx_325;
		word32 ecx_324;
		__munmap(ebx_154, gs, v19_212, *((word32) ebp_112 + 8), out ecx_324, out edx_325, out ebx_326);
		dwLoc34_279 = v19_212;
	}
	else
	{
		Eq_2 v20_194 = *ebp_112;
		word32 ecx_322;
		word32 edx_323;
		free(gs, v17_175, v20_194, out ecx_322, out edx_323);
		dwLoc34_279 = v20_194;
	}
	word32 ecx_327;
	word32 edx_328;
	free(gs, dwLoc34_279, ebp_112, out ecx_327, out edx_328);
}

// 080A1150: void buffer_free(Register (ptr32 Eq_9) gs)
void buffer_free(struct Eq_9 * gs)
{
	Eq_2 esi_13 = freeres_list;
	g_b80CF82C = 0x01;
	ptr32 esp_12 = fp - 0x0C;
	if (esi_13 != 0x00)
	{
		Eq_2 esi_18 = esi_13;
		do
		{
			struct Eq_152649 * esp_20 = esp_12 - 0x0C;
			esp_20->tFFFFFFFC = *((word32) esi_18 + 96);
			word32 ecx_70;
			word32 edx_71;
			free(gs, esp_20->tFFFFFFF8, esp_20->tFFFFFFFC, out ecx_70, out edx_71);
			esi_18 = *((word32) esi_18 + 92);
			freeres_list = esi_18;
			esp_12 = (char *) &esp_20->tFFFFFFFC + 20;
		} while (esi_18 != 0x00);
	}
}

// 080A11A0: void free_derivation(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_152681) dwArg08, Stack (ptr32 Eq_152682) dwArg0C, Stack Eq_2 dwArg10)
void free_derivation(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_152681 * dwArg08, struct Eq_152682 * dwArg0C, Eq_2 dwArg10)
{
	struct Eq_152684 * ecx_21 = *((word32) dwArg04 + 8);
	if (*((word32) dwArg04 + 0x0C) != 0x00)
	{
		Eq_152690 esi_29 = 0x00;
		do
		{
			int32 ebp_31 = esi_29 *s 0x3C;
			struct Eq_152704 * eax_33 = ecx_21 + ebp_31 / 16;
			if (eax_33->dw0008 > 0x00 && eax_33->dw0000 != 0x00)
			{
				Eq_2 edi_46 = __ror(eax_33->t0020, 0x09) ^ gs->t0018;
				if (edi_46 != 0x00)
				{
					word32 ecx_236;
					word32 edx_237;
					_dl_mcount_wrapper_check(gs, dwLoc30, edi_46, out ecx_236, out edx_237);
					edi_46();
					ecx_21 = (struct Eq_152684 *) *((word32) dwArg04 + 8);
				}
			}
			esi_29 = (word32) esi_29 + 1;
		} while (*((word32) dwArg04 + 0x0C) > esi_29);
	}
	Eq_2 edx_143 = dwArg04;
	if (ecx_21 != null)
	{
		Eq_2 v16_95 = ecx_21->t000C;
		word32 ecx_240;
		word32 edx_241;
		free(gs, dwLoc30, v16_95, out ecx_240, out edx_241);
		Eq_2 v17_115 = (word32) (dwArg08->dw000C *s 0x3C) + dwArg08->dw0008 + -44;
		word32 ecx_242;
		word32 edx_243;
		free(gs, v16_95, v17_115, out ecx_242, out edx_243);
		word32 ecx_244;
		word32 edx_245;
		free(gs, v17_115, dwArg0C->t0008, out ecx_244, out edx_245);
		edx_143 = dwArg10;
	}
	word32 ecx_238;
	word32 edx_239;
	free(gs, dwLoc34, edx_143, out ecx_238, out edx_239);
}

// 080A1270: void free_modules_db(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      free_modules_db
//      free_mem
void free_modules_db(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2 esi_11 = eax;
	ptr32 esp_12 = fp - 0x0C;
	Eq_2 eax_15 = *((word32) eax + 20);
	if (eax_15 != 0x00)
		free_modules_db(eax_15, gs);
	Eq_2 eax_25 = *((word32) eax + 28);
	if (eax_25 != 0x00)
		free_modules_db(eax_25, gs);
	do
	{
		Eq_2 edi_38 = *((word32) esi_11 + 24);
		if (**((word32) esi_11 + 16) == 0x2F)
		{
			struct Eq_152824 * esp_46 = esp_12 - 0x0C;
			esp_46->tFFFFFFFC = esi_11;
			word32 ecx_109;
			word32 edx_110;
			free(gs, esp_46->tFFFFFFF8, esp_46->tFFFFFFFC, out ecx_109, out edx_110);
			esi_11 = edi_38;
			esp_12 = (char *) &esp_46->tFFFFFFFC + 20;
			if (edi_38 == 0x00)
				return;
			continue;
		}
		esi_11 = edi_38;
	} while (edi_38 != 0x00);
}

// 080A12D0: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	struct Eq_152847 * ebx_13 = _nl_locale_subfreeres(gs);
	_nl_finddomain_subfreeres(gs);
	Eq_2 eax_29 = ebx_13->t1F84;
	if (eax_29 != 0x00)
		tdestroy(gs, eax_29, ebx_13->ptrFFFFFFEC);
	Eq_2 eax_51 = ebx_13->t1F7C;
	if (eax_51 != 0x00)
		free_modules_db(eax_51, gs);
	Eq_2 eax_65 = ebx_13->t1940;
	if (eax_65 != 0x00)
		tdestroy(gs, eax_65, (char *) ebx_13 - 0x0002CE60);
}

// 080A1340: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 eax_10 = __gconv_path_elem;
	if (eax_10 != 0x00 && eax_10 != 0x080A52A8)
	{
		word32 ecx_52;
		word32 edx_53;
		free(gs, dwLoc20, eax_10, out ecx_52, out edx_53);
	}
}

// 080A1380: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	Eq_2 eax_11 = gconv_cache;
	if (cache_malloced != 0x00)
	{
		word32 ecx_90;
		word32 edx_91;
		free(gs, dwLoc20, eax_11, out ecx_90, out edx_91);
	}
	else if (eax_11 != 0x00)
	{
		word32 ecx_92;
		word32 edx_93;
		word32 ebx_94;
		__munmap(0x080CE000, gs, eax_11, cache_size, out ecx_92, out edx_93, out ebx_94);
	}
}

// 080A13E0: void do_release_all(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void do_release_all(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 8) != 0x00)
	{
		word32 ecx_71;
		__libc_dlclose(out ecx_71);
	}
	word32 edx_70;
	word32 ecx_69;
	free(gs, dwLoc24, dwArg04, out ecx_69, out edx_70);
}

// 080A1420: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	tdestroy(gs, loaded, &g_t80A13E0);
	loaded.u0 = 0x00;
}

// 080A1460: void free_category(Register ui32 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_locale_subfreeres
void free_category(ui32 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	ptr32 esp_129 = fp - 44;
	Eq_2 esi_133 = *((char *) g_a80CFFA0 + eax * 0x04);
	if (edx != ecx)
	{
		if (g_a80CE140[eax * 0x04] != 0x00)
		{
			<anonymous> * eax_32 = *((char *) g_a80CE180 + eax * 0x04);
			*((char *) &g_ptr80CEE60 + eax * 0x04) = (struct Eq_72699 **) ecx;
			if (eax_32 != null)
				eax_32();
		}
		Eq_2 ecx_50 = *((char *) &g_ptr80CEE60 + (eax + 0x10) * 0x04);
		if (ecx_50 != 134892338)
		{
			word32 edx_204;
			word32 ecx_203;
			free(gs, dwLoc40, ecx_50, out ecx_203, out edx_204);
			dwLoc1C[eax + 0x10] = 0x080CEE60;
			esp_129 = fp - 0x28;
		}
	}
	if (esi_133 != 0x00)
	{
		while (true)
		{
			Eq_2 eax_80 = *((word32) esi_133 + 8);
			if (eax_80 != 0x00 && ecx != eax_80)
			{
				struct Eq_153047 * esp_88 = esp_129 - 0x0C;
				esp_88->tFFFFFFFC = eax_80;
				_nl_unload_locale(gs, esp_88->tFFFFFFFC);
			}
			struct Eq_153002 * esp_103 = esp_129 - 0x0C;
			Eq_2 ebp_107 = *((word32) esi_133 + 0x0C);
			esp_103->tFFFFFFFC = *esi_133;
			word32 ecx_199;
			word32 edx_200;
			free(gs, esp_103->tFFFFFFF8, esp_103->tFFFFFFFC, out ecx_199, out edx_200);
			esp_103->t0000 = esi_133;
			word32 edx_202;
			word32 ecx_201;
			free(gs, esp_103->tFFFFFFFC, esp_103->t0000, out ecx_201, out edx_202);
			esp_129 = (char *) &esp_103->t0000 + 20;
			if (ebp_107 == 0x00)
				break;
			esi_133 = ebp_107;
		}
	}
}

// 080A1520: Register word32 _nl_locale_subfreeres(Register (ptr32 Eq_9) gs)
// Called from:
//      free_mem
word32 _nl_locale_subfreeres(struct Eq_9 * gs)
{
	free_category(0x00, 0x080CC740, gs->ptrFFFFFFD0->t0000, gs);
}

// 080A1720: Register ptr32 _nl_archive_subfreeres(Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_locale_subfreeres
ptr32 _nl_archive_subfreeres(struct Eq_9 * gs)
{
	ptr32 esp_117 = fp - 0x1C;
	Eq_2 edi_107 = archloaded;
	if (edi_107 == 0x00)
	{
l080A179F:
		archloaded.u0 = 0x00;
		ptr32 eax_125 = archmapped;
		if (eax_125 == 0x00)
			return ebx;
		if (eax_125 != 0x080CFA00)
		{
			struct Eq_153137 * esp_134 = esp_117 - 4;
			esp_134->ptr0000 = 0x080A610C;
			esp_134->dwFFFFFFFC = 0x0216;
			esp_134->ptrFFFFFFF8 = 0x080A60AB;
			esp_134->ptrFFFFFFF4 = 0x080A60F5;
			Eq_2 edx_145;
			word32 ecx_314;
			__assert_fail(out ecx_314, out edx_145);
			free_mem(edx_145, gs);
			return 0x080CE000;
		}
		else
		{
			archmapped = 0x00;
			struct Eq_153165 * esp_162 = esp_117 - 0x08;
			esp_162->tFFFFFFFC = g_t80CFA08;
			esp_162->tFFFFFFF8 = g_t80CFA00;
			word32 ecx_315;
			word32 edx_316;
			Eq_2 ebx_171;
			__munmap(0x080CE000, gs, esp_162->tFFFFFFF8, esp_162->tFFFFFFFC, out ecx_315, out edx_316, out ebx_171);
			Eq_2 esi_179 = *((word32) ebx_171 + 6668);
			ptr32 esp_180 = (char *) &esp_162->tFFFFFFFC + 16;
			if (esi_179 != 0x00)
			{
				Eq_2 esi_184 = esi_179;
				do
				{
					struct Eq_153203 * esp_186 = esp_180 - 0x08;
					Eq_2 edi_190 = *((word32) esi_184 + 0x0C);
					esp_186->tFFFFFFFC = *((word32) esi_184 + 8);
					esp_186->tFFFFFFF8 = *esi_184;
					word32 ecx_317;
					word32 edx_318;
					__munmap(ebx_171, gs, esp_186->tFFFFFFF8, esp_186->tFFFFFFFC, out ecx_317, out edx_318, out ebx_171);
					esp_186->tFFFFFFFC = esi_184;
					word32 edx_320;
					word32 ecx_319;
					free(gs, esp_186->tFFFFFFF8, esp_186->tFFFFFFFC, out ecx_319, out edx_320);
					esi_184 = edi_190;
					esp_180 = (char *) &esp_186->tFFFFFFFC + 20;
				} while (edi_190 != 0x00);
			}
			return ebx;
		}
	}
l080A1740:
	struct Eq_153103 * esp_24 = esp_117 - 0x0C;
	Eq_2 ebp_27 = *edi_107;
	esp_24->tFFFFFFFC = *((word32) edi_107 + 4);
	word32 ecx_312;
	word32 edx_313;
	free(gs, esp_24->tFFFFFFF8, esp_24->tFFFFFFFC, out ecx_312, out edx_313);
	ui32 esi_31 = 0x00;
	struct Eq_153130 * esp_237 = (char *) &esp_24->tFFFFFFFC + 20;
	while (true)
	{
		if (esi_31 != 0x06)
		{
			Eq_2 eax_50 = *((word32) edi_107 + (esi_31 * 0x04 + 8));
			if (eax_50 != 0x00)
			{
				<anonymous> * edx_54 = *((word32) eax_50 + 16);
				if (edx_54 != null)
				{
					esp_237->dwFFFFFFF0 = (word32) eax_50;
					word32 edx_67;
					word32 ecx_68;
					edx_54();
					eax_50 = *((word32) edi_107 + (esi_31 * 0x04 + 8));
				}
				struct Eq_153272 * esp_74 = esp_237 - 0x0C;
				esp_74->tFFFFFFFC = eax_50;
				word32 edx_322;
				word32 ecx_321;
				free(gs, esp_74->tFFFFFFF8, esp_74->tFFFFFFFC, out ecx_321, out edx_322);
				esp_237 = (struct Eq_153130 *) ((char *) &esp_74->tFFFFFFFC + 20);
			}
			if (esi_31 == 0x0C)
			{
				struct Eq_153302 * esp_99 = esp_237 - 0x0C;
				esp_99->tFFFFFFFC = edi_107;
				word32 ecx_323;
				word32 edx_324;
				free(gs, esp_99->tFFFFFFF8, esp_99->tFFFFFFFC, out ecx_323, out edx_324);
				edi_107 = ebp_27;
				esp_117 = (char *) &esp_99->tFFFFFFFC + 20;
				if (ebp_27 == 0x00)
					goto l080A179F;
				goto l080A1740;
			}
		}
		++esi_31;
	}
}

// 080A1840: void free_mem(Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_archive_subfreeres
void free_mem(Eq_2 edx, struct Eq_9 * gs)
{
	__clearenv(edx, gs);
	tdestroy(gs, known_values, *(<anonymous> **) 0x080CE014);
	known_values.u0 = 0x00;
}

// 080A1880: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	ptr32 esp_10 = fp - 0x0C;
	Eq_2 edx_15 = __printf_modifier_table;
	if (edx_15 != 0x00)
	{
		int32 edi_19;
		for (edi_19 = 0x00; edi_19 != 1020; edi_19 += 0x04)
		{
			Eq_2 eax_25 = *((word32) edx_15 + edi_19);
			if (eax_25 != 0x00)
			{
				do
				{
					struct Eq_153358 * esp_32 = esp_10 - 0x0C;
					Eq_2 esi_36 = *eax_25;
					esp_32->tFFFFFFFC = eax_25;
					word32 ecx_126;
					word32 edx_127;
					free(gs, esp_32->tFFFFFFF8, esp_32->tFFFFFFFC, out ecx_126, out edx_127);
					eax_25 = esi_36;
					esp_10 = (char *) &esp_32->tFFFFFFFC + 20;
				} while (esi_36 != 0x00);
				edx_15 = __printf_modifier_table;
			}
		}
		struct Eq_153391 * esp_63 = esp_10 - 0x0C;
		esp_63->tFFFFFFFC = edx_15;
		word32 edx_129;
		word32 ecx_128;
		free(gs, esp_63->tFFFFFFF8, esp_63->tFFFFFFFC, out ecx_128, out edx_129);
	}
}

// 080A18F0: Register byte free_slotinfo(Register (ptr32 Eq_2) eax, Register ptr32 ebx, Register (ptr32 Eq_9) gs)
// Called from:
//      free_slotinfo
//      free_mem
byte free_slotinfo(union Eq_2 * eax, ptr32 ebx, struct Eq_9 * gs)
{
	byte bLoc09_125 = SLICE(ebx, byte, 24);
	Eq_2 edx_17 = *eax;
	if (edx_17 == 0x00)
		return 0x01;
	uint32 eax_130 = (uint32) free_slotinfo((word32) edx_17 + 4, 0x080CE000, gs);
	if ((byte) eax_130 == 0x00)
		return (byte) eax_130;
	Eq_2 ecx_40 = *eax;
	ui32 edi_41 = *ecx_40;
	if (edi_41 == 0x00)
	{
l080A193E:
		word32 ecx_167;
		word32 edx_168;
		free(gs, dwLoc30, ecx_40, out ecx_167, out edx_168);
		*eax = (union Eq_2 *) 0x00;
		eax_130 = (word32) bLoc09_125;
		return (byte) eax_130;
	}
	else
	{
		if (*((word32) ecx_40 + 0x0C) == 0x00)
		{
			ui32 edx_49 = 0x00;
			do
			{
				++edx_49;
				if (edx_49 == edi_41)
					goto l080A193E;
			} while (*((word32) ecx_40 + (edx_49 * 0x08 + 0x0C)) == 0x00);
		}
		return 0x00;
	}
}

// 080A1980: void free_mem(Register (ptr32 Eq_9) gs)
void free_mem(struct Eq_9 * gs)
{
	ptr32 esp_104 = fp - 0x1C;
	Eq_2 eax_21 = _dl_all_dirs;
	if (eax_21 != _dl_init_all_dirs)
	{
		do
		{
			struct Eq_153489 * esp_26 = esp_104 - 0x0C;
			Eq_2 esi_30 = *eax_21;
			esp_26->tFFFFFFFC = eax_21;
			word32 ecx_274;
			word32 edx_275;
			free(gs, esp_26->tFFFFFFF8, esp_26->tFFFFFFFC, out ecx_274, out edx_275);
			eax_21 = esi_30;
			esp_104 = (char *) &esp_26->tFFFFFFFC + 20;
		} while (_dl_init_all_dirs != esi_30);
	}
	if (_dl_nns != 0x00)
	{
		Eq_2 ebp_125 = g_t80CEA00;
		while (ebp_125 != 0x00)
		{
			struct Eq_153618 * edx_62 = *((word32) ebp_125 + 28);
			Eq_2 eax_63 = edx_62->t0004;
			edx_62->t0004.u0 = 0x00;
			if (eax_63 != 0x00)
			{
				do
				{
					Eq_2 esi_71 = *((word32) eax_63 + 4);
					if (*((word32) eax_63 + 8) == 0x00)
					{
						struct Eq_153564 * esp_80 = esp_104 - 0x0C;
						esp_80->tFFFFFFFC = eax_63;
						word32 ecx_278;
						word32 edx_279;
						free(gs, esp_80->tFFFFFFF8, esp_80->tFFFFFFFC, out ecx_278, out edx_279);
						esp_104 = (char *) &esp_80->tFFFFFFFC + 20;
						eax_63 = esi_71;
						if (esi_71 == 0x00)
							break;
						continue;
					}
					eax_63 = esi_71;
				} while (esi_71 != 0x00);
			}
			if ((*((word32) ebp_125 + 410) & 0x01) != 0x00)
			{
				struct Eq_153586 * esp_106 = esp_104 - 0x0C;
				esp_106->tFFFFFFFC = *((word32) ebp_125 + 500);
				word32 ecx_280;
				word32 edx_281;
				free(gs, esp_106->tFFFFFFF8, esp_106->tFFFFFFFC, out ecx_280, out edx_281);
				esp_104 = (char *) &esp_106->tFFFFFFFC + 20;
			}
			((word32) ebp_125 + 500)->u0 = 0x00;
			ebp_125 = *((word32) ebp_125 + 0x0C);
		}
		if (g_dw80CEA0C != 0x00)
		{
			struct Eq_153631 * eax_140 = g_ptr80CEA08;
			if (eax_140->dw0004 == g_dw80CE9EC)
			{
				Eq_2 ecx_144 = eax_140->t0000;
				eax_140->t0000 = g_t80CE9E8;
				g_dw80CEA0C = 0x00;
				struct Eq_153652 * esp_149 = esp_104 - 0x0C;
				esp_149->tFFFFFFFC = ecx_144;
				word32 ecx_282;
				word32 edx_283;
				free(gs, esp_149->tFFFFFFF8, esp_149->tFFFFFFFC, out ecx_282, out edx_283);
			}
		}
	}
	free_slotinfo((word32) _dl_tls_dtv_slotinfo_list + 4, 0x080CE000, gs);
	Eq_2 edx_194 = _dl_scope_free_list;
	_dl_scope_free_list.u0 = 0x00;
	word32 ecx_276;
	word32 edx_277;
	free(gs, dwLoc34, edx_194, out ecx_276, out edx_277);
}

// subject_libc_freeres_ptrs.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_2 map = // 080CFFE0
	{
		0
	};
Eq_2 string_space = // 080CFFE4
	{
		0
	};
Eq_2 __printf_arginfo_table = // 080CFFE8
	{
		0
	};
word32 __printf_va_arg_table = 0x00; // 080CFFEC
word32 buf = 0x00; // 080CFFF0
// subject_libc_subfreeres.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 __elf_set___libc_subfreeres_element_buffer_free__ = 0x080A1150; // 080CEF64
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A12D0; // 080CEF68
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1340; // 080CEF6C
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1380; // 080CEF70
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1420; // 080CEF74
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1840; // 080CEF78
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1880; // 080CEF7C
word32 __elf_set___libc_subfreeres_element_free_mem__ = 0x080A1980; // 080CEF80
// subject_rodata_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _fp_hw = 0x03; // 080A2000
word32 _IO_stdin_used = 0x00020001; // 080A2004
int32 g_a80A2260[] = // 080A2260
	{
	};
cu8 g_b80A22B7 = 0x50; // 080A22B7
Eq_3736 g_t80A2310 = // 080A2310
	{
		0x2F
	};
Eq_2 g_t80A2314 = // 080A2314
	{
		0x61696C612E656C61
	};
Eq_2 g_t80A2318 = // 080A2318
	{
		0x7361696C61
	};
Eq_2 g_t80A231C = // 080A231C
	{
		-0x7ED72FFFFFF8D
	};
word32 g_a80A2320[] = // 080A2320
	{
	};
int32 g_a80A2358[] = // 080A2358
	{
	};
Eq_9662 g_t80A25C0 = // 080A25C0
	{
		
		{
		},
	};
Eq_9943 g_t80A25F7 = // 080A25F7
	{
		
		{
		},
	};
Eq_9652 g_t80A2640 = // 080A2640
	{
		
		{
		},
	};
word32 g_dw80A3AA0 = 0x4E415254; // 080A3AA0
word32 g_a80A3C28[] = // 080A3C28
	{
	};
cu8 g_b80A4132 = 0x70; // 080A4132
cu8 g_b80A4150 = 99; // 080A4150
word32 g_a80A4500[] = // 080A4500
	{
	};
cu8 g_b80A4B32 = 0x43; // 080A4B32
word32 g_a80A4BD8[] = // 080A4BD8
	{
	};
word32 g_a80A4C34[] = // 080A4C34
	{
	};
cu8 g_b80A4D0B = 0x2D; // 080A4D0B
cu8 g_b80A4E24 = 0x2F; // 080A4E24
word32 gconv_module_ext = 7303982; // 080A4E98
word32 g_dw80A4E9C = 0x6E6F6367; // 080A4E9C
word32 g_dw80A4EA0 = 0x6F6D2D76; // 080A4EA0
word32 g_dw80A4EA4 = 1701606756; // 080A4EA4
word16 g_w80A4EA8 = 115; // 080A4EA8
word32 g_dw80A4EAC = 0x7273752F; // 080A4EAC
Eq_55176 g_t80A4EB0 = // 080A4EB0
	{
		0x2F
	};
Eq_10035 g_t80A4EB4 = // 080A4EB4
	{
		0x2F
	};
Eq_55186 g_t80A4EB8 = // 080A4EB8
	{
		110
	};
Eq_2 g_t80A4EBA = // 080A4EBA
	{
		0x4355000000000000
	};
Eq_62257 g_t80A57FE = // 080A57FE
	{
		
		{
		},
	};
Eq_68689 g_t80A58D0 = // 080A58D0
	{
		
		{
		},
	};
word32 slashdot.10224 = 0x2F2E2E2F; // 080A599C
uint32 g_a80A6060[] = // 080A6060
	{
	};
word32 g_dw80B1B80 = ~0x00; // 080B1B80
Eq_11645 g_t80B1C00 = // 080B1C00
	{
		
		{
		},
	};
Eq_11645 g_t80B1C06 = // 080B1C06
	{
		
		{
		},
	};
Eq_11645 g_t80B1C08 = // 080B1C08
	{
		
		{
		},
	};
Eq_2 g_a80B1C38[] = // 080B1C38
	{
	};
Eq_2 g_a80B1C40[] = // 080B1C40
	{
	};
Eq_2 g_t80B1C58 = // 080B1C58
	{
		0x1C71C71C1FFFFFFF
	};
Eq_2 g_t80B1C60 = // 080B1C60
	{
		0x1745D17419999999
	};
word128 g_ow80B1ED0 = // 080B1ED0
	{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 
	};
word128 g_ow80B1EE0 = // 080B1EE0
	{
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 
	};
Eq_83070 g_t80B1EF0 = // 080B1EF0
	{
		
		{
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		}
	};
Eq_83074 g_t80B1F00 = // 080B1F00
	{
		1.7976931348623157e+308
	};
// subject_rodata_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_a80B201C[] = // 080B201C
	{
	};
word32 g_a80B20C4[] = // 080B20C4
	{
	};
word32 g_a80B2180[] = // 080B2180
	{
	};
word32 g_a80B2260[] = // 080B2260
	{
	};
word32 g_a80B2308[] = // 080B2308
	{
	};
word32 g_a80B23C4[] = // 080B23C4
	{
	};
byte g_b80B24A4 = 0x30; // 080B24A4
byte g_b80B24B4 = 0x20; // 080B24B4
word32 g_dw80B24E0 = 0x30; // 080B24E0
word32 g_dw80B2520 = 0x20; // 080B2520
word32 g_a80B2600[] = // 080B2600
	{
	};
Eq_105488 g_t80B29EC = // 080B29EC
	{
		0x2F
	};
struct Eq_111622 g_t80B2BAF = // 080B2BAF
	{
		
		{
			&g_t73006269
		},
		99,
	};
word32 g_dw80B3178 = 0x464C457F; // 080B3178
Eq_106777 g_t80B317C = // 080B317C
	{
		0x01
	};
word32 g_dw80B3184 = 0x464C457F; // 080B3184
Eq_106777 g_t80B3188 = // 080B3188
	{
		0x01
	};
word32 g_dw80B318D = 0x00; // 080B318D
word16 g_w80B3191 = 0x00; // 080B3191
byte g_b80B3193 = 0x00; // 080B3193
word32 dummy_bucket.11389 = 0x00; // 080B31A4
struct Eq_122143 g_t80B3B60 = // 080B3B60
	{
		116,
		0x6C,
		115,
	};
union Eq_2 g_u80B3BAD = // 080B3BAD
	{
		3342642245079493732
	};
up32 g_dw80B3C20 = 0x07; // 080B3C20
up32 g_dw80B3C98 = 540701477; // 080B3C98
word32 g_dw80B41F9 = 0x25000200; // 080B41F9
struct Eq_82971 g_t80B4E70 = // 080B4E70
	{
		884,
		0x0355,
		0x00006A4A,
	};
Eq_117127 g_t80B8620 = // 080B8620
	{
		
		{
		},
	};
byte g_a80B8660[] = // 080B8660
	{
	};
Eq_2 g_a80B86A0[] = // 080B86A0
	{
	};
Eq_2 g_a80B8740[] = // 080B8740
	{
	};
Eq_2 _sys_nerr_internal = // 080B941C
	{
		0x2074756F00000087
	};
cu8 g_b80B9420 = 111; // 080B9420
word32 g_a80B9460[] = // 080B9460
	{
	};
word32 g_a80B9E58[] = // 080B9E58
	{
	};
word32 g_a80B9E8C[] = // 080B9E8C
	{
	};
word32 g_a80B9F4C[] = // 080B9F4C
	{
	};
word32 g_a80BA374[] = // 080BA374
	{
	};
struct Eq_150224 g_t80BA3A8 = // 080BA3A8
	{
		0x00,
		0x00,
	};
word32 g_a80BA3B0[] = // 080BA3B0
	{
	};
// subject_tbss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a80CC6B0[] = // 080CC6B0
	{
	};
// subject_text_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049030: void __assert_fail_base.cold.0()
// Called from:
//      __assert_fail_base
void __assert_fail_base.cold.0()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	Eq_2 stackArg4 = <invalid>;
	word32 ecx_22;
	word32 edx_23;
	free(gs, stackArg0, stackArg4, out ecx_22, out edx_23);
	word32 ecx_25;
	word32 edx_26;
	abort(ecx, gs, out ecx_25, out edx_26);
	_nl_load_domain.cold.0();
}

// 08049044: void _nl_load_domain.cold.0()
// Called from:
//      __assert_fail_base
//      _nl_load_domain
void _nl_load_domain.cold.0()
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
	word32 ecx_8;
	word32 edx_9;
	abort(ecx, gs, out ecx_8, out edx_9);
}

// 08049049: Register word32 abort(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _dl_start
//      read_encoded_value_with_base.cold.6
//      execute_cfa_program.cold.7
//      _Unwind_RaiseException_Phase2.cold.12
//      _Unwind_Resume.cold.16
//      _Unwind_Resume_or_Rethrow.cold.17
//      read_encoded_value_with_base.cold.8
//      read_encoded_value_with_base.cold.0
//      __assert_fail_base
//      _nl_load_domain
//      __libc_message
//      __malloc_assert
//      __printf_fp_l
//      __printf_fphex
//      base_of_encoded_value
//      uw_frame_state_for
//      execute_stack_op
//      uw_update_context_1
//      uw_init_context_1
//      uw_update_context
//      uw_install_context_1
//      _Unwind_GetGR
//      _Unwind_SetGR
//      size_of_encoded_value
//      base_from_object
//      base_from_cb_data
//      _Unwind_IteratePhdrCallback
//      search_object
//      __deregister_frame_info_bases
//      base_of_encoded_value
word32 abort(Eq_2 ecx, struct Eq_9 * gs, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_2 edx_110 = gs->t0008;
	if (g_t80CF5F4 != edx_110)
	{
		ecx.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_27;
		if (!__cmpxchg(g_t80CF5EC, 0x01, 0x00, out eax_27))
			ecx = __lll_lock_wait_private(eax_27, 0x080CF5EC, gs);
		g_t80CF5F4 = edx_110;
	}
	++g_dw80CF5F0;
	if (stage == 0x00)
	{
		stage = 0x01;
		ui32 eax_48 = 0x20;
		while (true)
		{
			--eax_48;
			if (eax_48 == ~0x00)
				break;
			(fp - 0x011C)[eax_48] = 0x00;
		}
		ecx = sigprocmask(gs, 0x01, fp - 0x011C, 0x00, out edx_110);
	}
	struct Eq_85 * esp_115 = fp - 0x011C;
	word32 eax_81 = stage;
	if (eax_81 == 0x01)
	{
		word32 v14_86 = g_dw80CF5F0 - 0x01;
		g_dw80CF5F0 = v14_86;
		stage = 0x00;
		if (v14_86 == 0x00)
		{
			g_t80CF5F4.u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v16_99 = g_t80CF5EC - 0x01;
			g_t80CF5EC = v16_99;
			if (v16_99 != 0x00)
				__lll_unlock_wake_private(0x080CF5EC, ecx, edx_110, gs);
		}
		raise(gs, 0x06);
		Eq_2 edx_144 = gs->t0008;
		if (g_t80CF5F4 != edx_144)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_155;
			if (!__cmpxchg(g_t80CF5EC, 0x01, 0x00, out eax_155))
				__lll_lock_wait_private(eax_155, 0x080CF5EC, gs);
			g_t80CF5F4 = edx_144;
		}
		++g_dw80CF5F0;
	}
	else if (eax_81 != 0x02)
		goto l080491CE;
	stage = 0x03;
	word32 ecx_182;
	word32 * edi_185 = fp - 0x9C;
	for (ecx_182 = 0x23; ecx_182 != 0x00; --ecx_182)
	{
		*edi_185 = 0x00;
		++edi_185;
	}
	ui32 eax_187 = 33;
	while (true)
	{
		--eax_187;
		if (eax_187 == 0x00)
			break;
		(fp - 0x9C)[eax_187] = ~0x00;
	}
	__sigaction(gs, 0x06);
	esp_115 = fp - 0x0118;
l080491CE:
	if (stage == 0x03)
	{
		stage = 0x04;
		esp_115->dwFFFFFFF0 = 0x06;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		raise(gs, stackArg4);
	}
	if (stage != 0x04)
	{
		if (stage != 0x05)
			__hlt();
		else
		{
			stage = 0x06;
			struct Eq_276 * esp_243 = esp_115 - 0x0C;
			esp_243->tFFFFFFFC.u0 = 0x7F;
			_exit(gs, esp_243->tFFFFFFFC);
		}
	}
	else
	{
		stage = 0x05;
		__hlt();
	}
}

// 08049222: void _IO_new_fclose.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_292) esi, Register (ptr32 Eq_9) gs)
void _IO_new_fclose.cold.0(Eq_2 ecx, struct Eq_292 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_9 = esi->t0048;
		Eq_321 v8_10 = *((word32) edx_9 + 4) - 0x01;
		*((word32) edx_9 + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx_9 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx_9 - 0x01;
			*edx_9 = v14_20;
			if (v14_20 != 0x00)
				__lll_unlock_wake_private(edx_9, ecx, edx_9, gs);
		}
	}
	word32 edi_58;
	word32 ebp_57;
	struct Eq_303 * esi_47;
	Eq_2 ecx_44 = _Unwind_Resume(gs, dwLoc14, out ebp_57, out esi_47, out edi_58);
	_IO_fflush.cold.0(ecx_44, esi_47, gs);
}

// 0804925C: void _IO_fflush.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_303) esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_new_fclose.cold.0
void _IO_fflush.cold.0(Eq_2 ecx, struct Eq_303 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_9 = esi->t0048;
		Eq_321 v8_10 = *((word32) edx_9 + 4) - 0x01;
		*((word32) edx_9 + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx_9 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx_9 - 0x01;
			*edx_9 = v14_20;
			if (v14_20 != 0x00)
				__lll_unlock_wake_private(edx_9, ecx, edx_9, gs);
		}
	}
	word32 edi_58;
	word32 ebp_57;
	struct Eq_370 * esi_47;
	Eq_2 ecx_44 = _Unwind_Resume(gs, dwLoc14, out ebp_57, out esi_47, out edi_58);
	_IO_puts.cold.0(ecx_44, esi_47, gs);
}

// 08049296: void _IO_puts.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_370) esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_fflush.cold.0
void _IO_puts.cold.0(Eq_2 ecx, struct Eq_370 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_9 = esi->t0048;
		Eq_321 v8_10 = *((word32) edx_9 + 4) - 0x01;
		*((word32) edx_9 + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx_9 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx_9 - 0x01;
			*edx_9 = v14_20;
			if (v14_20 != 0x00)
				__lll_unlock_wake_private(edx_9, ecx, edx_9, gs);
		}
	}
	word32 edi_59;
	word32 esi_58;
	word32 ebp_57;
	_Unwind_Resume(gs, dwLoc14, out ebp_57, out esi_58, out edi_59);
}

// 080492D0: void _IO_wfile_underflow.cold.2(Register Eq_2 ecx, Register Eq_2 esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_puts.cold.0
//      _IO_wfile_underflow
void _IO_wfile_underflow.cold.2(Eq_2 ecx, Eq_2 esi, struct Eq_9 * gs)
{
	if ((*esi & 0x8000) == 0x00)
	{
		Eq_2 edx_15 = *((word32) esi + 72);
		Eq_321 v8_16 = *((word32) edx_15 + 4) - 0x01;
		*((word32) edx_15 + 4) = v8_16;
		if (v8_16 == 0x00)
		{
			*((word32) edx_15 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_26 = *edx_15 - 0x01;
			*edx_15 = v14_26;
			if (v14_26 != 0x00)
				__lll_unlock_wake_private(edx_15, ecx, edx_15, gs);
		}
	}
	word32 esi_66;
	word32 edi_67;
	struct Eq_488 * ebp_49;
	Eq_2 ecx_51 = _Unwind_Resume(gs, dwLoc14, out ebp_49, out esi_66, out edi_67);
	_IO_new_file_underflow.cold.6(ecx_51, ebp_49, gs);
}

// 0804930B: void _IO_new_file_underflow.cold.6(Register Eq_2 ecx, Register (ptr32 Eq_488) ebp, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_wfile_underflow.cold.2
void _IO_new_file_underflow.cold.6(Eq_2 ecx, struct Eq_488 * ebp, struct Eq_9 * gs)
{
	struct Eq_540 * eax_6 = ebp->ptrFFFFFFDC;
	word32 ebx_7 = eax_6->dw0000;
	ebp->dwFFFFFFE4 = ebx_7;
	if ((SLICE(ebx_7, byte, 8) & 0x80) == 0x00)
	{
		Eq_2 edx_14 = eax_6->t0048;
		Eq_321 v11_15 = *((word32) edx_14 + 4) - 0x01;
		*((word32) edx_14 + 4) = v11_15;
		if (v11_15 == 0x00)
		{
			*((word32) edx_14 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v16_25 = *edx_14 - 0x01;
			*edx_14 = v16_25;
			if (v16_25 != 0x00)
				__lll_unlock_wake_private(edx_14, ecx, edx_14, gs);
		}
	}
	word32 edi_64;
	word32 esi_63;
	word32 ebp_62;
	Eq_2 ecx_49 = _Unwind_Resume(gs, dwLoc14, out ebp_62, out esi_63, out edi_64);
	_dl_start(ecx_49, gs);
}

// 0804934A: void _dl_start(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_new_file_underflow.cold.6
void _dl_start(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_14;
	word32 edx_15;
	abort(ecx, gs, out ecx_14, out edx_15);
}

// 08049358: void _IO_fputs.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_616) esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_start
void _IO_fputs.cold.0(Eq_2 ecx, struct Eq_616 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_9 = esi->t0048;
		Eq_321 v8_10 = *((word32) edx_9 + 4) - 0x01;
		*((word32) edx_9 + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx_9 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx_9 - 0x01;
			*edx_9 = v14_20;
			if (v14_20 != 0x00)
				__lll_unlock_wake_private(edx_9, ecx, edx_9, gs);
		}
	}
	word32 edi_58;
	word32 ebp_57;
	struct Eq_627 * esi_47;
	Eq_2 ecx_44 = _Unwind_Resume(gs, dwLoc14, out ebp_57, out esi_47, out edi_58);
	_IO_fwrite.cold.0(ecx_44, esi_47, gs);
}

// 08049392: void _IO_fwrite.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_627) esi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_fputs.cold.0
void _IO_fwrite.cold.0(Eq_2 ecx, struct Eq_627 * esi, struct Eq_9 * gs)
{
	if ((esi->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_9 = esi->t0048;
		Eq_321 v8_10 = *((word32) edx_9 + 4) - 0x01;
		*((word32) edx_9 + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx_9 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx_9 - 0x01;
			*edx_9 = v14_20;
			if (v14_20 != 0x00)
				__lll_unlock_wake_private(edx_9, ecx, edx_9, gs);
		}
	}
	word32 esi_58;
	word32 ebp_57;
	struct Eq_688 * edi_45;
	Eq_2 ecx_44 = _Unwind_Resume(gs, dwLoc14, out ebp_57, out esi_58, out edi_45);
	_IO_getdelim.cold.0(ecx_44, edi_45, gs);
}

// 080493CC: void _IO_getdelim.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_688) edi, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_fwrite.cold.0
void _IO_getdelim.cold.0(Eq_2 ecx, struct Eq_688 * edi, struct Eq_9 * gs)
{
	if ((edi->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_9 = edi->t0048;
		Eq_321 v8_10 = *((word32) edx_9 + 4) - 0x01;
		*((word32) edx_9 + 4) = v8_10;
		if (v8_10 == 0x00)
		{
			*((word32) edx_9 + 8) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			int32 v14_20 = *edx_9 - 0x01;
			*edx_9 = v14_20;
			if (v14_20 != 0x00)
				__lll_unlock_wake_private(edx_9, ecx, edx_9, gs);
		}
	}
	word32 edi_60;
	word32 esi_59;
	word32 ebp_58;
	Eq_2 ecx_45 = _Unwind_Resume(gs, dwLoc14, out ebp_58, out esi_59, out edi_60);
	read_encoded_value_with_base.cold.6(ecx_45, gs);
}

// 08049407: void read_encoded_value_with_base.cold.6(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_getdelim.cold.0
//      read_encoded_value_with_base
void read_encoded_value_with_base.cold.6(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
}

// 0804940C: void execute_cfa_program.cold.7(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      read_encoded_value_with_base.cold.6
//      execute_cfa_program
void execute_cfa_program.cold.7(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_14;
	word32 ecx_13;
	abort(ecx, gs, out ecx_13, out edx_14);
}

// 08049414: void execute_stack_op.cold.8(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      execute_cfa_program.cold.7
//      execute_stack_op
void execute_stack_op.cold.8(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_9;
	word32 edx_10;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 0804941D: void uw_update_context_1.cold.9(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      execute_stack_op
//      uw_update_context_1
void uw_update_context_1.cold.9(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_9;
	word32 edx_10;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 08049426: void uw_init_context_1.cold.10(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_update_context_1
//      uw_init_context_1
void uw_init_context_1.cold.10(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_9;
	word32 ecx_8;
	abort(ecx, gs, out ecx_8, out edx_9);
}

// 0804942B: void uw_update_context.cold.11(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_init_context_1
//      uw_update_context
void uw_update_context.cold.11(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_11;
	word32 ecx_10;
	abort(ecx, gs, out ecx_10, out edx_11);
}

// 08049430: void _Unwind_RaiseException_Phase2.cold.12(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_update_context
//      _Unwind_RaiseException_Phase2
void _Unwind_RaiseException_Phase2.cold.12(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_13;
	word32 edx_14;
	abort(ecx, gs, out ecx_13, out edx_14);
}

// 08049439: void uw_install_context_1.cold.13(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_RaiseException_Phase2.cold.12
//      uw_install_context_1
void uw_install_context_1.cold.13(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_9;
	word32 edx_10;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 08049442: void _Unwind_GetGR.cold.14(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_install_context_1
//      _Unwind_GetGR
void _Unwind_GetGR.cold.14(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
}

// 08049447: void _Unwind_SetGR.cold.15(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_GetGR
//      _Unwind_SetGR
void _Unwind_SetGR.cold.15(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_10;
	word32 ecx_9;
	abort(ecx, gs, out ecx_9, out edx_10);
}

// 0804944E: void _Unwind_Resume.cold.16(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_SetGR
//      _Unwind_Resume
void _Unwind_Resume.cold.16(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_12;
	word32 ecx_11;
	abort(ecx, gs, out ecx_11, out edx_12);
}

// 08049459: void _Unwind_Resume_or_Rethrow.cold.17(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_Resume.cold.16
//      _Unwind_Resume_or_Rethrow
void _Unwind_Resume_or_Rethrow.cold.17(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_14;
	word32 ecx_13;
	abort(ecx, gs, out ecx_13, out edx_14);
}

// 08049464: void read_encoded_value_with_base.cold.8(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_Resume_or_Rethrow.cold.17
//      read_encoded_value_with_base
void read_encoded_value_with_base.cold.8(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 ecx_6;
	word32 edx_7;
	abort(ecx, gs, out ecx_6, out edx_7);
}

// 08049469: void read_encoded_value_with_base.cold.0(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      read_encoded_value_with_base.cold.8
//      read_encoded_value_with_base
void read_encoded_value_with_base.cold.0(Eq_2 ecx, struct Eq_9 * gs)
{
	word32 edx_11;
	word32 ecx_10;
	abort(ecx, gs, out ecx_10, out edx_11);
}

// 08049470: void fini(Register (ptr32 Eq_9) gs)
// Called from:
//      read_encoded_value_with_base.cold.0
void fini(struct Eq_9 * gs)
{
	word32 esi_20;
	check_free.isra.0(0x080CFA9C, gs, out esi_20);
}

// 08049490: void main(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void main(struct Eq_9 * gs, Eq_2 dwArg04)
{
	__align(fp);
	_IO_puts(gs, 0x080A200C);
	_IO_printf(dwArg04, gs, 0x080A2018);
}

// 080494D0: void init_cacheinfo(Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 ebx, Register (ptr32 Eq_943) gs, Stack Eq_2 dwArg14, Stack Eq_2 dwArg20)
void init_cacheinfo(Eq_2 ecx, Eq_2 edx, Eq_2 ebx, struct Eq_943 * gs, Eq_2 dwArg14, Eq_2 dwArg20)
{
	Eq_2 ecx_117;
	Eq_2 esi_100;
	Eq_2 eax_506;
	int32 eax_494;
	struct Eq_950 * edi_11 = &g_t80CE000;
	struct Eq_952 * esp_18 = fp - 0x4C;
	struct Eq_956 * ebp_19 = &g_t80CF8E0;
	Eq_2 eax_20 = g_t80CF8E0;
	if (eax_20 != 0x01)
	{
		if (eax_20 != 0x02)
		{
			eax_494 = g_dw80CF92C;
			if (eax_494 == 0x00)
			{
				ecx_117 = g_t80CF930;
				if (ecx_117 == 0x00)
					goto l08049570;
				eax_506 = ecx_117;
				ecx_117.u0 = 0x00;
l0804959D:
				esi_100 = eax_506;
				goto l08049548;
			}
			ecx_117.u0 = 0x00;
			esi_100.u0 = ~0x00;
l08049511:
			esp_18->dw000C = eax_494;
l08049515:
			int32 edx_520 = esp_18->dw000C;
			if (edx_520 > 0x00)
			{
				edi_11->dw0EEC = edx_520;
				edi_11->dw0EF0 = edx_520 >> 0x01;
				int32 eax_540 = SEQ(SLICE(edx_520, word24, 8), 0x00);
				edi_11->dw0EF4 = eax_540;
				edi_11->dw0EF8 = eax_540 >> 0x01;
			}
			eax_506 = ebp_19->t0050;
			if (eax_506 == 0x00)
			{
l08049548:
				if (esi_100 > 0x00)
				{
					edi_11->t0EDC = esi_100;
					edi_11->dw0EE0 = esi_100 >> 0x01;
					int32 eax_573 = SEQ(SLICE(esi_100, word24, 8), 0x00);
					edi_11->dw0EE4 = eax_573;
					edi_11->dw0EE8 = eax_573 >> 0x01;
				}
l08049570:
				uint32 ebx_585 = ebp_19->dw0054;
				if (ebx_585 == 0x00)
					ebx_585 = ecx_117 *s edi_11->dw0EE4 * 0x03 >> 0x02;
				edi_11->dw1FDC = ebx_585;
				return;
			}
			goto l0804959D;
		}
		Eq_2 esp_408 = <invalid>;
		word32 edi_931;
		word32 esi_930;
		Eq_2 ecx_409;
		Eq_2 edx_410;
		*((word32) esp_408 + 16) = handle_amd(188, ecx, edx, ebx, out ecx_409, out edx_410, out esi_930, out edi_931);
		Eq_2 ecx_422;
		Eq_2 edx_423;
		word32 edi_933;
		word32 esi_932;
		handle_amd(191, ecx_409, edx_410, ebx, out ecx_422, out edx_423, out esi_932, out edi_933);
		Eq_2 esp_434 = <invalid>;
		Eq_2 ecx_435;
		ui32 edx_436;
		*((word32) esp_434 + 20) = handle_amd(0xC2, ecx_422, edx_423, ebx, out ecx_435, out edx_436, out esi_100, out edi_11);
		__cpuid(0x80000000, ecx_435, &0x80000000, &ebx, &ecx_435, &edx_436);
		esp_18 = (word32) esp_434 + 4;
		ecx_117.u0 = 0x00;
		if (*((word32) esp_434 + 20) > 0x00)
		{
			__cpuid(0x01, 0x00, &0x01, &ebx, &0x00, &edx_436);
			ecx_117 = edx_436 & 0x10000000;
			if ((edx_436 & 0x10000000) != 0x00)
			{
				ecx_117 = ebx >> 0x10 & 0xFF;
				if (ecx_117 != 0x00)
					*((word32) esp_434 + 20) = (uint32) ((uint64) *((word32) esp_434 + 20) /u ecx_117);
			}
			esi_100 += Mem484[esp_434 + 0x14:word32];
		}
l080496E6:
		eax_494 = ebp_19->dw004C;
		if (eax_494 == 0x00)
			goto l08049515;
		goto l08049511;
	}
	Eq_963 dwArg18_709;
	Eq_963 dwArg28_710;
	Eq_2 esp_34 = <invalid>;
	Eq_2 ebx_30;
	Eq_2 ecx_35;
	word32 edi_925;
	word32 edx_923;
	word32 ebp_924;
	*((word32) esp_34 + 0x0C) = handle_intel.constprop.1(188, ecx, ebx, gs, out ecx_35, out edx_923, out ebx_30, out ebp_924, out edi_925);
	Eq_2 esp_48 = <invalid>;
	Eq_2 ebx_44;
	Eq_2 ecx_49;
	word32 edx_926;
	word32 ebp_927;
	word32 edi_928;
	*((word32) esp_48 + 20) = handle_intel.constprop.1(191, ecx_35, ebx_30, gs, out ecx_49, out edx_926, out ebx_44, out ebp_927, out edi_928);
	word32 ebx_58;
	word32 edx_60;
	word32 ecx_929;
	Eq_2 eax_56 = handle_intel.constprop.1(0xC2, ecx_49, ebx_44, gs, out ecx_929, out edx_60, out ebx_58, out ebp_19, out edi_11);
	esp_18 = fp;
	esi_100 = eax_56;
	if (eax_56 > 0x00)
	{
		dwArg18_709.u0 = 0x00;
		dwArg28_710.u0 = 0x03;
	}
	else
	{
		esi_100 = dwArg14;
		dwArg18_709.u0 = ~0x00;
		dwArg28_710.u0 = 0x02;
	}
	ui32 ecx_78 = ebp_19->dw0014;
	ecx_117 = ecx_78 & 0x10000000;
	if ((ecx_78 & 0x10000000) == 0x00)
		goto l080496E6;
	Eq_2 dwArg1C_749;
	if (dwArg20 <= 0x03)
	{
		Mem116 = Mem87;
		dwArg1C_749.u0 = 0x00;
		ecx_117 = (word32) ebp_19->b000E;
		goto l080496B8;
	}
	Eq_2 dwArg10_718;
	if (dwArg18_709 != 0x00)
	{
		dwArg10_718.u0 = 0x01;
		dwArg18_709.u0 = ~0x00;
	}
	else
		dwArg10_718.u0 = 0x03;
	Eq_2 ecx_102 = 0x00;
	while (true)
	{
		__cpuid(0x04, ecx_102, &0x04, &ebx_58, &ecx_102, &edx_60);
		Eq_2 esi_103 = (word32) ecx_102 + 1;
		Eq_963 dwArg18_739 = dwArg18_709;
		Eq_963 dwArg1C_737 = 0x00;
		if (dwArg10_718 == 0x00)
			break;
		ecx_102 = esi_103;
	}
	if (dwArg20 > 0x0A)
	{
		uint32 ecx_174 = (uint32) (int8) false;
		Eq_963 ebx_161 = dwArg28_710;
		ui32 eax_163 = 0x01;
		ui32 edx_175 = (uint32) (int8) (dwArg28_710 == 0x03) & ecx_174;
		if (dwArg18_709 <= 0x00)
			eax_163 = (uint32) (int8) (dwArg28_710 == 0x02) & ecx_174;
		dwArg20 = esi_100;
		Eq_2 ecx_192 = dwArg10_718;
		ui32 esi_197 = eax_163 * 0x02 | edx_175;
		while (esi_197 != 0x00)
		{
			__cpuid(11, ecx_192, &11, &ebx_161, &ecx_192, &edx_175);
			Eq_2 eax_203 = (word32) ecx_192 + 1;
			ui32 ecx_209 = ecx_192 & 0xFF00;
			ebx_161 &= 0xFF;
			if (ebx_161 == 0x00 || ecx_209 == 0x00)
				break;
			if (ecx_209 == 0x0100)
			{
				if ((esi_197 & 0x01) != 0x00)
				{
					ebx_161 = ebx_161 - 0x01 & ~(~0x00 << (byte) (__bsr(dwArg1C_737) + 0x01));
					esi_197 &= ~0x01;
					dwArg1C_737 = ebx_161;
				}
			}
			else if (ecx_209 == 0x0200 && (esi_197 & 0x02) != 0x00)
			{
				--ebx_161;
				if (dwArg28_710 != 0x02)
					dwArg18_739 = ~(~0x00 << (byte) (__bsr(dwArg18_739) + 0x01)) & ebx_161 - 0x01;
				else
					dwArg1C_737 = ~(~0x00 << (byte) (__bsr(dwArg1C_737) + 0x01)) & ebx_161 - 0x01;
				esi_197 &= ~0x02;
			}
			ecx_192 = eax_203;
		}
	}
	Eq_2 eax_226 = dwArg1C_737 - ~0x00 - (dwArg1C_737 < 0x01);
	dwArg1C_749 = eax_226;
	if (dwArg18_739 > 0x00)
	{
		if (dwArg28_710 != 0x02)
		{
			ecx_117 = (word32) dwArg18_739.u0 + 1;
			goto l080496B8;
		}
	}
	else if (dwArg28_710 != 0x02)
	{
		ecx_117.u0 = 0x00;
		if (dwArg18_739 == 0x00)
		{
l080496C8:
			if (true)
				goto l080496E6;
			if (dwArg1C_749 != 0x00)
				dwArg14 = (int32) ((int64) dwArg14 /32 dwArg1C_749);
l080496E2:
			esi_100 += dwArg14;
			goto l080496E6;
		}
		ecx_117.u0 = ~0x00;
l080496B8:
		if (esi_100 > 0x00 && ecx_117 != 0x00)
			esi_100 = (uint32) ((uint64) esi_100 /u ecx_117);
		goto l080496C8;
	}
	word32 edx_253 = ebp_19->dw0038;
	uint32 eax_254 = ebp_19->dw003C;
	if (eax_226 == 0x00)
	{
		ecx_117.u0 = 0x00;
		if (true)
			goto l080496E6;
		goto l080496E2;
	}
	ecx_117 = eax_226;
	if (eax_226 > 0x02 && (edx_253 == 0x06 && eax_254 <= 0x5D))
	{
		word32 edx_294;
		edi_11[edi_11->aFFFE46A4[eax_254 - 55] / 8160]();
		return;
	}
	goto l080496B8;
}

// 08049960: void _start(Register word32 edx, Register (ptr16 Eq_1428) gs, Register word32 mxcsr, Stack word32 dwArg00, Stack word32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14, Stack word32 dwArg20)
void _start(word32 edx, struct Eq_1428 * gs, word32 mxcsr, word32 dwArg00, word32 dwArg0C, word32 dwArg10, word32 dwArg14, word32 dwArg20)
{
	__align(fp + 4);
	__libc_start_main(gs, dwArg00, fp + 4, edx, fp, dwArg0C, dwArg10, dwArg14, dwArg20);
	__hlt();
}

// 080499A0: void _dl_relocate_static_pie()
// Called from:
//      __libc_start_main
void _dl_relocate_static_pie()
{
}

// 080499B0: void __x86.get_pc_thunk.bx()
void __x86.get_pc_thunk.bx()
{
}

// 080499C0: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
}

// 08049A00: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
}

// 08049A40: void __do_global_dtors_aux(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
void __do_global_dtors_aux(Eq_2 ecx, struct Eq_9 * gs)
{
	if (g_b80CF300 != 0x00)
		return;
	deregister_tm_clones();
	__deregister_frame_info_bases(ecx, gs, 0x080BA428);
}

// 08049A90: void frame_dummy()
void frame_dummy()
{
	__register_frame_info_bases(&g_dw80BA428, 0x080CF304, 0x00, 0x080CE000);
	register_tm_clones();
}

// 08049AE0: Register Eq_2 get_common_indeces.constprop.1(Register (ptr32 word32) eax, Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 ebx, Stack Eq_2 dwArg04, Register out Eq_2 edxOut)
// Called from:
//      __libc_start_main
Eq_2 get_common_indeces.constprop.1(word32 * eax, Eq_2 ecx, Eq_2 edx, Eq_2 ebx, Eq_2 dwArg04, union Eq_2 & edxOut)
{
	ptr32 fp;
	Eq_2 ebx;
	Eq_2 ecx;
	word32 * eax;
	Eq_2 edx;
	Eq_2 dwArg04;
	word32 dwLoc14;
	word32 dwLoc94;
	if (eax != null)
	{
		__cpuid(0x01, ecx, &0x01, &ebx, &ecx, &edx);
		g_t80CF8F4 = edx;
		g_t80CF8EC = ebx;
		ebx_35 = ecx;
		g_t80CF8F0 = ecx;
		g_dw80CF8E8 = 0x01;
		ecx_40.u0 = 0x01;
		*eax = 0x00;
		*edx = 0x00;
		*ecx = 0x00;
		edx_50 = dwArg04;
		*dwArg04 = 0x01;
		if (*eax == 0x0F)
		{
			*eax = 0x0F;
			eax_59 = (int32) *ecx;
			v16_60 = (word32) *edx + eax_59;
			*edx = v16_60;
		}
	}
	ecx_365 = (ecx_40, ecx, ecx_40);
	edx_72 = (edx_50, edx, edx_50);
	ebx_71 = (ebx_35, ebx, ebx_35);
	Mem64 = (Mem51, Mem20, Mem61);
	if (g_t80CF8E4 > 0x06)
	{
		ecx_68.u0 = 0x00;
		__cpuid(0x07, 0x00, &0x07, &ebx_71, &0x00, &edx_72);
		g_dw80CF8F8 = 0x07;
		g_t80CF8FC = ebx_71;
		g_dw80CF900 = 0x00;
		g_t80CF904 = edx_72;
	}
	ecx_364 = (ecx_365, ecx_68);
	Mem78 = (Mem64, Mem76);
	ebx_79 = g_t80CF8F0;
	bh_105 = SLICE(ebx_79, byte, 8);
	bl_157 = (byte) ebx_79;
	ebx_16_16_159 = SLICE(ebx_79, word16, 16);
	if ((ebx_79 & 0x08000000) != 0x00)
	{
		ecx_83.u0 = 0x00;
		edx_eax_84 = __xgetbv(0x00);
		eax_85 = (word32) edx_eax_84;
		edx_87 = eax_85 & 0x06;
		if ((eax_85 & 0x06) == 0x06)
		{
			if ((ebx_79 & 0x10000000) != 0x00)
			{
				edx_93 = g_t80CF928;
				ecx_95 = edx_93 | 0x40;
				g_t80CF928 = edx_93 | 0x40;
				if ((g_t80CF8FC & 0x20) != 0x00)
				{
					edx_100 = edx_93 | 0x0C40;
					g_t80CF928 = edx_93 | 0x0C40;
				}
				edx_164 = (edx_93, edx_100);
				Mem111 = (Mem96, Mem103);
				ebx_160 = SEQ(ebx_16_16_159, bh_105 & 0x10, bl_157);
				if ((bh_105 & 0x10) != 0x00)
				{
					v21_112 = g_t80CF928 | 0x80;
					g_t80CF928 = v21_112;
				}
			}
			ecx_367 = (ecx_83, ecx_95, ecx_95);
			edx_163 = (edx_87, edx_164, edx_164);
			ebx_155 = (ebx_79, ebx_160, ebx_160);
			Mem122 = (Mem78, Mem111, Mem113);
			if ((eax_85 & 0xE0) == 0xE0)
			{
				edx_123 = g_t80CF8FC;
				if ((edx_123 & 0x00010000) != 0x00)
				{
					eax_127 = g_t80CF928;
					ah_129 = SLICE(eax_127, byte, 8);
					eax_16_16_142 = SLICE(eax_127, word16, 16);
					al_143 = (byte) eax_127;
					ch_131 = SLICE(eax_127, byte, 8);
					ecx_16_16_137 = SLICE(eax_127, word16, 16);
					cl_138 = (byte) eax_127;
					edx_133 = edx_123 & 0x00020000;
					ecx_139 = SEQ(ecx_16_16_137, ch_131 | 0x30, cl_138);
					eax_144 = SEQ(eax_16_16_142, ah_129 | 0x10, al_143);
					if ((edx_123 & 0x00020000) != 0x00)
						eax_140 = ecx_139;
					eax_141 = (eax_144, eax_140);
					g_t80CF928 = eax_141;
				}
			}
		}
		ecx_366 = (ecx_83, ecx_367, ecx_367, ecx_139);
		edx_162 = (edx_87, edx_163, edx_123, edx_133);
		ebx_154 = (ebx_79, ebx_155, ebx_155, ebx_155);
		Mem148 = (Mem78, Mem122, Mem122, Mem146);
		if (g_t80CF8E4 > 0x0C)
		{
			ecx_152.u0 = 0x00;
			__cpuid(0x0D, 0x00, &0x0D, &ebx_154, &0x00, &edx_162);
			if (ebx_154 != 0x00)
			{
				ebx_169 = (word32) ebx_154 + 0x007F;
				ecx_171.u0 = 0x01;
				g_dw80CF920 = ebx_169 & ~0x3F;
				g_dw80CF924 = ebx_169 & ~0x3F;
				__cpuid(0x0D, 0x01, &0x0D, &(ebx_169 & ~0x3F), &0x01, &edx_162);
			}
		}
	}
	edx_374 = (edx_72, edx_162, edx_162, edx_162, edx_162);
	ecx_363 = (ecx_364, ecx_366, ecx_152, ecx_171, ecx_370, ecx_370);
	edxOut = edx_374;
	return ecx_363;
}

// 08049D30: void __libc_start_main(Register (ptr16 Eq_1428) gs, Stack word32 dwArg08, Stack ptr32 dwArg0C, Stack word32 dwArg18, Stack ptr32 dwArg1C, Stack word32 dwArg2C, Stack word32 dwArg30, Stack word32 dwArg34, Stack word32 dwArg40)
// Called from:
//      _start
void __libc_start_main(struct Eq_1428 * gs, word32 dwArg08, ptr32 dwArg0C, word32 dwArg18, ptr32 dwArg1C, word32 dwArg2C, word32 dwArg30, word32 dwArg34, word32 dwArg40)
{
}

// 0804A4D0: void __x86.get_pc_thunk.ax()
void __x86.get_pc_thunk.ax()
{
}

// 0804A4D4: void __x86.get_pc_thunk.di()
void __x86.get_pc_thunk.di()
{
}

// 0804A4E0: Register word32 check_one_fd(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 edxOut)
// Called from:
//      __libc_check_standard_fds
word32 check_one_fd(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & edxOut)
{
	__fcntl64_nocancel();
	if (eax == ~0x00 && gs->tFFFFFFE0 == 0x09)
	{
		word32 edi_41;
		Eq_2 eax_42;
		if (edx == 0x00020000)
		{
			edi_41 = 0x0103;
			eax_42.u0 = 0x080A2212;
		}
		else
		{
			edi_41 = 0x0107;
			eax_42.u0 = 0x080A2208;
		}
		word32 edx_150;
		word32 ecx_149;
		if (eax != __open_nocancel(gs, eax_42, edx, 0x00, out ecx_149, out edx_150) || (__fxstat64(gs, eax, fp - 0x7C, out ecx, out edx) != 0x00 || ((dwLoc6C & 0xF000) != 0x2000 || (edi_41 ^ dwLoc5C | dwLoc58) != 0x00)))
			__hlt();
	}
	edxOut = edx;
	return ecx;
}

// 0804A590: Register word32 __libc_check_standard_fds(Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
word32 __libc_check_standard_fds(struct Eq_9 * gs, ptr32 & edxOut)
{
	word32 edx_38;
	check_one_fd(0x00, 0x00020001, gs, out edx_38);
	word32 edx_39;
	check_one_fd(0x01, 0x00020000, gs, out edx_39);
	ptr32 edx_32;
	word32 ecx_31 = check_one_fd(0x02, 0x00020000, gs, out edx_32);
	edxOut = edx_32;
	return ecx_31;
}

// 0804A5C4: void __x86.get_pc_thunk.si()
void __x86.get_pc_thunk.si()
{
}

// 0804A5D0: Register (ptr32 Eq_9) __libc_setup_tls(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_start_main
struct Eq_9 * __libc_setup_tls(struct Eq_9 * gs)
{
	Eq_2 dwLoc3C_257;
	ui32 dwLoc4C_263;
	int32 dwLoc48_261;
	Eq_1917 dwLoc44_260;
	Eq_1917 edx_130;
	Eq_1919 ebp_127;
	Eq_2 ebx_133;
	Eq_1917 edx_100;
	Eq_2 eax_20 = g_t80CEA00;
	Eq_2 esi_132 = _dl_phdr;
	word32 eax_24 = _dl_tls_static_size;
	if (esi_132 != 0x00)
	{
		Eq_2 edx_36 = (word32) esi_132 + (_dl_phnum << 0x05);
		if (esi_132 < edx_36)
		{
			do
			{
				if (*esi_132 == 0x07)
				{
					edx_100 = *((word32) esi_132 + 20);
					ebx_133 = Mem21[esi_132 + 0x08:word32] + Mem54[eax_20 + 0x00:word32];
					ebp_127 = *((word32) esi_132 + 28);
					dwLoc3C_257 = *((word32) esi_132 + 16);
					dwLoc44_260 = edx_100;
					esi_132 = ebx_133;
					if (ebp_127 <= 0x40)
						goto l0804A655;
					int32 eax_69 = (uint32) ((uint64) ((word32) ebp_127 + ((edx_100 - 0x01) + eax_24)) /u ebp_127) *s ebp_127;
					word32 edx_327;
					ui32 edx_84 = (word32) ebp_127 + (__sbrk(gs, (word32) ebp_127 + (eax_69 + 0x04C0), out edx_327) - 0x01);
					g_dw80CFCC0 = 0x3E;
					dwLoc48_261 = eax_69;
					dwLoc4C_263 = edx_84 & -ebp_127;
					goto l0804A776;
				}
				esi_132 = (word64) esi_132.u0 + 32;
			} while (edx_36 > esi_132);
		}
		ebp_127.u0 = 0x00;
		esi_132.u0 = 0x00;
		dwLoc3C_257.u0 = 0x00;
		edx_100.u0 = 0x00;
	}
	else
	{
		ebp_127.u0 = 0x00;
		dwLoc3C_257.u0 = 0x00;
		edx_100.u0 = 0x00;
	}
l0804A655:
	ui32 eax_103 = (word32) edx_100.u0 + 63 + eax_24;
	word32 edx_326;
	ui32 eax_123 = __sbrk(gs, (eax_103 & ~0x3F) + 0x0500, out edx_326) + 0x3F & ~0x3F;
	g_dw80CFCC0 = 0x3E;
	dwLoc48_261 = eax_103 & ~0x3F;
	dwLoc4C_263 = eax_123;
	edx_130 = edx_100;
	if (ebp_127 != 0x00)
	{
		ebx_133 = esi_132;
		dwLoc44_260 = edx_100;
l0804A776:
		esi_132 = ebx_133;
		edx_130 = CONVERT(CONVERT(ebp_127 - 0x01 + dwLoc44_260, word32, uint64) /u ebp_127, word32, uint32) *s ebp_127;
	}
	*((word32) eax_20 + 0x0244) = edx_130;
	Eq_2 eax_162 = dwLoc48_261 - edx_130 + dwLoc4C_263;
	g_t80CFCD0 = eax_162;
	g_dw80CFCD4 = 0x00;
	word32 edx_329;
	word32 ecx_328;
	memcpy(eax_162, esi_132, dwLoc3C_257, out ecx_328, out edx_329);
	struct Eq_2057 * eax_192 = dwLoc4C_263 + dwLoc48_261;
	eax_192->ptr0000 = eax_192;
	eax_192->dw0004 = 0x080CFCC8;
	eax_192->ptr0008 = eax_192;
	eax_192->dw0010 = _dl_sysinfo;
	__syscall(0x80);
	__hlt();
}

// 0804A880: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	int32 eax_23 = 0x080CC6B0 - 0x080CC6B0;
	if (eax_23 >> 0x02 != 0x00)
	{
		int32 esi_31 = 0x00;
		do
		{
			(*((char *) g_a80CC6B0 + esi_31 * 0x04))();
			++esi_31;
		} while (eax_23 >> 0x02 != esi_31);
	}
	_init();
	int32 eax_62 = 0x080CC6B8 - 0x080CC6B0;
	if (eax_62 >> 0x02 != 0x00)
	{
		int32 esi_71 = 0x00;
		do
		{
			(*((char *) g_a80CC6B0 + esi_71 * 0x04))();
			++esi_71;
		} while (eax_62 >> 0x02 != esi_71);
	}
}

// 0804A930: void __libc_csu_fini()
void __libc_csu_fini()
{
	int32 eax_15 = 0x080CC6C0 - 0x080CC6B8;
	if (eax_15 >> 0x02 != 0x00)
	{
		int32 esi_20 = (eax_15 >> 0x02) - 0x01;
		do
		{
			(*((char *) g_a80CC6B8 + esi_20 * 0x04))();
			--esi_20;
		} while (esi_20 != ~0x00);
	}
	_fini();
}

// 0804A980: void __assert_fail_base(Register word32 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14)
// Called from:
//      __assert_fail
void __assert_fail_base(word32 ecx, struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, word32 dwArg14)
{
	Mem60 = Mem28;
	*program_invocation_short_name != 0x00;
	if (___asprintf() < 0x00)
	{
		word32 esi_364;
		word32 ebx_363;
		__libc_write(gs, 0x02, 134881868, 0x12, out ebx_363, out esi_364);
		__assert_fail_base.cold.0();
	}
	else
	{
		__fxprintf(gs, 0x00);
		fflush(gs, _IO_stderr);
		Eq_2 edx_165 = _dl_pagesize;
		Eq_2 eax_169 = (word32) edx_165 + dwLoc24 & -edx_165;
		word32 edx_366;
		word32 ecx_365;
		Eq_2 eax_189 = mmap(gs, 0x00, eax_169, 0x03, 0x22, ~0x00, 0x00, out ecx_365, out edx_366);
		if (eax_189 == ~0x00)
			__assert_fail_base.cold.0();
		else
		{
			*eax_189 = eax_169;
			strcpy((word32) eax_189 + 4, dwLoc28);
			Eq_2 v22_226 = __abort_msg;
			__abort_msg = eax_189;
			if (v22_226 == 0x00)
				__assert_fail_base.cold.0();
			else
			{
				word32 ebx_369;
				word32 ecx_367;
				word32 edx_368;
				__munmap(0x080CE000, gs, v22_226, *v22_226, out ecx_367, out edx_368, out ebx_369);
				__assert_fail_base.cold.0();
			}
		}
	}
}

// 0804AAE0: Register Eq_2 __assert_fail(Register out Eq_979 ecxOut, Register out Eq_2277 edxOut)
// Called from:
//      __libc_start_main
//      __new_exitfn
//      _IO_wfile_underflow
//      _IO_file_fopen
//      enlarge_userbuf
//      __mbsrtowcs_l
//      getcwd
//      __getpagesize
//      next_line
//      _dl_non_dynamic_init
//      __gconv
//      __gconv_release_step
//      __gconv_get_path
//      __gconv_get_builtin_trans
//      __gconv_transform_internal_ucs4
//      __gconv_transform_ucs4_internal
//      __gconv_transform_internal_ucs4le
//      __gconv_transform_ucs4le_internal
//      __gconv_transform_ascii_internal
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_utf8_internal
//      __gconv_transform_ucs2_internal
//      __gconv_transform_internal_ucs2
//      __gconv_transform_ucs2reverse_internal
//      __gconv_transform_internal_ucs2reverse
//      do_release_shlib
//      __gconv_find_shlib
//      _nl_find_locale
//      _nl_intern_locale_data
//      _nl_load_locale_from_archive
//      printf_positional
//      vfprintf
//      __printf_fphex
//      printf_positional
//      __vfwprintf
//      _IO_fwide
//      intel_check_word.isra.0
//      __cache_sysconf
//      wcrtomb
//      __wcsrtombs
//      add_name_to_object.isra.4
//      _dl_map_object_from_fd.constprop.8
//      expand_dynamic_string_token
//      _dl_map_object
//      check_match
//      _dl_lookup_symbol_x
//      _dl_setup_hash
//      _dl_relocate_object
//      _dl_important_hwcaps
//      _dl_debug_vdprintf
//      _dl_next_tls_modid
//      _dl_allocate_tls
//      _dl_add_to_slotinfo
//      _dl_get_origin
//      _dl_fixup
//      _dl_profile_fixup
//      _dl_find_dso_for_object
//      _dl_open
//      dl_open_worker
//      remove_slotinfo
//      _dl_close_worker
//      _dl_map_object_deps
//      _dl_check_map_versions
//      _nl_archive_subfreeres
Eq_2 __assert_fail(union Eq_979 & ecxOut, union Eq_2277 & edxOut)
{
	word32 edx_65;
	__assert_fail_base(ecx, gs, dcgettext(out edx_65), dwArg04, dwArg08, dwArg0C, dwArg10);
	Eq_2277 edx_44;
	Eq_2 eax_43 = dcgettext(out edx_44);
	ecxOut.u0 = <invalid>;
	edxOut = edx_44;
	return eax_43;
}

// 0804AB20: Register Eq_2 dcgettext(Register out Eq_979 edxOut)
// Called from:
//      __assert_fail
//      strerror_r
//      __dlerror
//      strerror
//      dlopen_doit
Eq_2 dcgettext(union Eq_979 & edxOut)
{
	__dcigettext(gs, dwArg04, dwArg08, 0x00, 0x00, 0x00, dwArg0C);
	edxOut.u0 = <invalid>;
	return <invalid>;
}

// 0804AB50: Register Eq_2317 plural_eval(Register Eq_2317 eax, Register out Eq_2317 edxOut, Register out Eq_2317 ebxOut, Register out Eq_2317 ebpOut, Register out Eq_2317 esiOut)
// Called from:
//      plural_eval
//      plural_lookup.isra.2
Eq_2317 plural_eval(Eq_2317 eax, union Eq_2317 & edxOut, union Eq_2317 & ebxOut, union Eq_2317 & ebpOut, union Eq_2317 & esiOut)
{
	Eq_2317 edx_124;
	Eq_2317 esi_154;
	int32 eax_133 = *eax;
	Eq_2317 ebx_132 = eax;
	bool v17_171 = eax_133 <= 0x01;
	edx_124 = edx;
	while (eax_133 != 0x01)
	{
		if (v17_171)
		{
			if (eax_133 == 0x00)
			{
				uint32 eax_33 = *((word32) ebx_132 + 4);
				esi_154 = edx;
				if (eax_33 != 0x00)
				{
					&esi_154.u0->dw0000 = 0x00;
					if (eax_33 == 0x01)
						esi_154 = *((word32) ebx_132 + 8);
				}
				goto l0804ABAA;
			}
			goto l0804ABD8;
		}
		if (eax_133 == 0x02)
		{
			word32 ebx_239;
			word32 ebp_240;
			word32 esi_241;
			Eq_2317 eax_52 = plural_eval(*((word32) ebx_132 + 8), out edx_124, out ebx_239, out ebp_240, out esi_241);
			uint32 ecx_55 = *((word32) ebx_132 + 4);
			esi_154 = eax_52;
			if (ecx_55 != 0x0F)
			{
				if (ecx_55 != 0x0E)
				{
					word32 ebx_245;
					word32 ebp_246;
					word32 esi_247;
					Eq_2317 eax_91 = plural_eval(*((word32) ebx_132 + 0x0C), out edx_124, out ebx_245, out ebp_246, out esi_247);
					if (ecx_55 <= 0x0D)
					{
						Eq_2317 edx_101;
						Eq_2317 eax_102;
						word32 ecx_103;
						(0x080CE000 + g_a80A2260[(ecx_55 - 0x03) * 0x04])();
						edxOut = edx_101;
						ebxOut = eax_91;
						ebpOut = edx;
						esiOut = eax_52;
						return eax_102;
					}
l0804ABD8:
					edxOut = edx_124;
					ebxOut = ebx;
					ebpOut = ebp;
					esiOut = esi;
					return 0x00;
				}
				if (eax_52 == 0x00)
					goto l0804ABAA;
			}
			else if (eax_52 != 0x00)
			{
				&esi_154.u0->dw0000 = 0x01;
				goto l0804ABAA;
			}
			word32 ebx_248;
			word32 ebp_249;
			word32 esi_250;
			esi_154 = (word32) (int8) (plural_eval(*((word32) ebx_132 + 0x0C), out edx_124, out ebx_248, out ebp_249, out esi_250) != 0x00);
			goto l0804ABAA;
		}
		if (eax_133 != 0x03)
			goto l0804ABD8;
		word32 ebx_242;
		word32 ebp_243;
		word32 esi_244;
		ebx_132 = *((word32) ebx_132 + ((word32) ((int8) (plural_eval(*((word32) ebx_132 + 8), out edx_124, out ebx_242, out ebp_243, out esi_244) == 0x00)) * 0x04 + 0x0C));
		eax_133 = (int32) *ebx_132;
		v17_171 = eax_133 <= 0x01;
	}
	word32 ebx_236;
	word32 ebp_237;
	word32 esi_238;
	esi_154 = (word32) (int8) (plural_eval(*((word32) ebx_132 + 8), out edx_124, out ebx_236, out ebp_237, out esi_238) == 0x00);
l0804ABAA:
	edxOut = edx_124;
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	return esi_154;
}

// 0804ACF0: void transcmp(Stack (ptr32 Eq_2468) dwArg04, Stack (ptr32 Eq_2469) dwArg08)
void transcmp(struct Eq_2468 * dwArg04, struct Eq_2469 * dwArg08)
{
	Eq_2 edx_17;
	if (dwArg08->dw0010 != 0x00)
		edx_17 = &dwArg08->t001C;
	else
		edx_17 = dwArg08->t001C;
	Eq_2 eax_25;
	if (dwArg04->dw0010 != 0x00)
		eax_25 = &dwArg04->t001C;
	else
		eax_25 = dwArg04->t001C;
	word32 ecx_131;
	word32 edx_132;
	if (strcmp(eax_25, edx_17, out ecx_131, out edx_132) == 0x00)
	{
		word32 ecx_127;
		word32 edx_128;
		if (strcmp(dwArg04->t0000, dwArg08->t0000, out ecx_127, out edx_128) == 0x00)
		{
			word32 ecx_129;
			word32 edx_130;
			strcmp(dwArg04->t0008, dwArg08->t0008, out ecx_129, out edx_130) != 0x00;
		}
	}
}

// 0804AD70: Register word32 plural_lookup.isra.2(Register Eq_2 eax, Stack Eq_2 dwArg04)
// Called from:
//      __dcigettext
word32 plural_lookup.isra.2(Eq_2 eax, Eq_2 dwArg04)
{
	word32 ebp_18;
	struct Eq_2537 * ebx_23;
	Eq_2 esi_25;
	word32 edx_107;
	Eq_2317 eax_22 = plural_eval(*((word32) eax + 96), out edx_107, out ebx_23, out ebp_18, out esi_25);
	if (eax_22 < ebx_23->t0064)
	{
		Eq_2317 edi_33 = eax_22;
		Eq_2 eax_34 = esi_25;
		word32 ebx_35 = dwArg04 + esi_25;
		do
		{
			--edi_33;
			if (edi_33 == ~0x00)
				return ebp_18;
			Eq_2 eax_50 = rawmemchr(eax_34, 0x00);
			eax_34 = (word32) eax_50 + 1;
		} while ((word32) eax_50 + 1 < ebx_35);
	}
	return ebp_18;
}

// 0804ADC0: Register Eq_2 _nl_find_msg(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_load_domain
Eq_2 _nl_find_msg(Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
_nl_find_msg_entry:
	ui32 edx_30 = gs->dw0014
	branch *((word32) dwArg04 + 4) <= 0x00 l0804B038
	goto l0804AE09
l0804ADC0:
l0804AE09:
	Eq_2 dwLoc30_1874
	Eq_2 eax_1312
	Eq_2 edx_1085
	uint32 ebx_1026
	struct Eq_2621 * esp_1059 = fp - 0x6C
	Eq_2 esi_1130 = *((word32) dwArg04 + 8)
	branch esi_1130 == 0x00 l0804AF80
l0804AE17:
	Eq_2 eax_56 = *((word32) esi_1130 + 20)
	edi = *((word32) esi_1130 + 48)
	dwLoc34 = eax_56
	branch edi == 0x00 l0804AFA8
l0804AE28:
	word32 edx_3535
	word32 ecx_3534
	Eq_2 eax_141 = strlen(dwArg0C, out ecx_3534, out edx_3535)
	word32 eax_150 = __hash_string(dwArg0C)
	Eq_2 edi_157 = *((word32) esi_1130 + 44)
	uint32 edx_172 = (uint32) ((uint64) eax_150 % (edi_157 - 0x02))
	Eq_2 eax_174 = *((word32) esi_1130 + 52)
	Eq_2 eax_176 = *((word32) esi_1130 + 48)
	Eq_2 eax_181 = edi_157 - (edx_172 + 0x01)
	Eq_2 eax_184 = edx_172 + 0x01 - edi_157
	dwLoc40 = eax_141
	Eq_2 ebx_166 = (uint32) ((uint64) eax_150 % edi_157)
	dwLoc38 = eax_174
	dwLoc3C = eax_176
	dwLoc44 = eax_181
	dwLoc48 = eax_184
	goto l0804AED5
l0804AE80:
	Eq_2 esi_217
	Eq_2 eax_218
	struct Eq_2710 * eax_212 = (word32) *((word32) esi_1130 + 24) + edi * 0x08
	Eq_2 esi_213 = eax_212->t0000
	branch *((word32) esi_1130 + 0x0C) == 0x00 l0804B020
l0804AE92:
	branch eax_141 > __bswap(esi_213) l0804AEC5
l0804AE99:
	esi_217 = *esi_1130
	eax_218 = __bswap(eax_212->t0004)
l0804AEA0:
	dwLoc54 = esi_1130
	word32 edx_3554
	word32 ecx_3553
	branch strcmp(dwArg0C, eax_218 + esi_217, out ecx_3553, out edx_3554) == 0x00 l0804B050
l0804AEC5:
	Eq_2 esi_322 = (word32) ebx_166 + (edx_172 + 0x01)
	word32 eax_323 = eax_184 + ebx_166
	branch eax_181 <= ebx_166 l0804AED3
l0804AED0_1:
	eax_323 = esi_322
l0804AED3:
	ebx_166 = eax_323
l0804AED5:
	edi = *((word32) eax_176 + ebx_166 * 0x04)
	esp_1059 = fp - 0x6C
	esi_1130 = eax_174
	Eq_2 eax_196 = __bswap(edi)
	branch eax_174 == 0x00 l0804AEE7
l0804AEE4_1:
	edi = eax_196
l0804AEE7:
	branch edi == 0x00 l0804AF80
l0804AEEF:
	edi = edi - 0x01
	branch eax_56 > edi l0804AE80
l0804AEF7:
	struct Eq_2726 * eax_288 = (word32) *((word32) esi_1130 + 36) + (edi - eax_56) * 0x08
	branch eax_288->t0000 <= eax_141 l0804AEC5
l0804AF09:
	dwLoc54 = esi_1130
	word32 edx_3537
	word32 ecx_3536
	branch strcmp(dwArg0C, eax_288->t0004, out ecx_3536, out edx_3537) != 0x00 l0804AEC5
l0804AF2C:
	struct Eq_2936 * eax_338 = (word32) *((word32) esi_1130 + 40) + (edi - eax_56) * 0x08
	dwLoc30_1874 = eax_338->t0004
	dwLoc3C = eax_338->t0000
l0804AF42:
	esp_1059 = fp - 0x6C
	branch dwArg10 != 0x00 l0804B080
l0804AF4D:
	*dwArg14 = dwLoc3C
	goto l0804AF87
l0804AF57:
	branch gs->t000C == 0x00 l0804AF65
l0804AF64:
	__lock()
l0804AF65:
	Eq_2 v33_1596 = lock.11578 - 0x01
	lock.11578 = v33_1596
	branch v33_1596 == 0x00 l0804AF79
l0804AF6E:
	__lll_unlock_wake_private(0x080CF570, ecx_1542, edx_1543, gs)
l0804AF79:
l0804AF80:
	dwLoc30_1874.u0 = 0x00
l0804AF87:
	ebx_1026 = edx_30 ^ gs->dw0014
	branch ebx_1026 != 0x00 l0804B919
l0804AF9A:
	return dwLoc30_1874
l0804AFA8:
	dwLoc44 = esi_1130
	Eq_2 ebx_130 = 0x00
	esi_1130 = eax_56
	goto l0804AFC7
l0804AFB8:
	esi_1130 = edi
	edi = esi_84 >> 0x01
	branch eax_110 == 0x00 l0804B278
l0804AFC4:
	ebx_130 = (esi_84 >> 0x01) + 0x01
l0804AFC7:
	esp_1059 = fp - 0x6C
	branch esi_1130 <= ebx_130 l0804AF80
l0804AFCB:
	Eq_2 ecx_76 = *esi_1130
	Eq_2 edx_77 = *((word32) esi_1130 + 0x0C)
	Eq_2 eax_78 = *((word32) esi_1130 + 24)
	edi = esi_1130
	dwLoc38 = ecx_76
	dwLoc3C = edx_77
	dwLoc40 = eax_78
l0804AFE1:
	word32 esi_84 = ebx_130 + edi
	Eq_2 eax_100 = *((word32) eax_78 + ((esi_84 >> 0x01) * 0x08 + 4))
	esi_1130 = esi_84 >> 0x01
	Eq_2 ecx_94 = __bswap(eax_100)
	branch edx_77 == 0x00 l0804AFF9
l0804AFF6_1:
	eax_100 = ecx_94
l0804AFF9:
	word32 ecx_3538
	word32 edx_3539
	word32 eax_110 = strcmp(dwArg0C, eax_100 + ecx_76, out ecx_3538, out edx_3539)
	esp_1059 = fp - 0x6C
	branch eax_110 >= 0x00 l0804AFB8
l0804B00F:
	edi = esi_84 >> 0x01
	branch ebx_130 < esi_84 >> 0x01 l0804AFE1
	goto l0804AF80
l0804B020:
	branch eax_141 > esi_213 l0804AEC5
l0804B029:
	esi_217 = *esi_1130.u0
	eax_218 = eax_212->t0004
	goto l0804AEA0
l0804B038:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg12 = <invalid>
	Eq_2 stackArg36 = <invalid>
	Eq_2 stackArg40 = <invalid>
	Eq_2 stackArg88 = <invalid>
	Eq_2 stackArg92 = <invalid>
	_nl_load_domain(fp - 4, gs, dwArg04, dwArg08, stackArg12, stackArg36, stackArg40, dwLoc44, dwLoc40, dwLoc3C, dwLoc38, stackArg88, stackArg92)
	goto l0804AE09
l0804B050:
	dwLoc38 = esi_217
l0804B055:
	struct Eq_2918 * eax_266 = (word32) *((word32) esi_1130 + 28) + edi * 0x08
	Eq_2 edx_267 = eax_266->t0000
	Eq_2 eax_268 = eax_266->t0004
	branch *((word32) esi_1130 + 0x0C) == 0x00 l0804B1B0
l0804B06B:
	dwLoc30_1874 = __bswap(eax_268) + dwLoc38
	dwLoc3C = (word32) __bswap(edx_267) + 1
	goto l0804AF42
l0804B080:
	branch dwArg08 == 0x00 l0804B170
l0804B08B:
	Eq_2 eax_353 = *((word32) dwArg08 + 8)
	dwLoc38 = eax_353
	branch eax_353 == 0x00 l0804B170
l0804B099:
	Mem536 = Mem497
	Eq_2 edx_537 = *((word64) esi_1130.u0 + 60)
	branch edx_537 == 0x00 l0804B1CE
	goto l0804B0C0
l0804B0B5:
l0804B0C0:
	dwLoc40 = esi_1130
	dwLoc44 = edi
	Eq_2 edi_547 = edx_537
	Eq_2 esi_549 = *((word64) esi_1130.u0 + 56) - 0x0C + edx_537 * 0x0C
	goto l0804B0EB
l0804B0E0:
	esi_549 = esi_549 - 0x0C
	branch edi_547 == 0x00 l0804B1C8
l0804B0EB:
	edi_547 = edi_547 - 0x01
	esp_1059 = fp - 0x6C
	word32 ecx_3571
	word32 edx_3572
	branch strcmp(*esi_549, dwLoc38, out ecx_3571, out edx_3572) != 0x00 l0804B0E0
l0804B104:
	dwLoc38 = esi_549
l0804B12C:
	branch *((word32) dwLoc38 + 4) == ~0x00 l0804AF4D
l0804B139:
	Eq_2 eax_1463
	Eq_2 eax_1365 = *((word32) dwLoc38 + 8)
	branch eax_1365 == 0x00 l0804B72B
l0804B144:
	branch eax_1365 == ~0x00 l0804B2E1
l0804B14D:
	eax_1463 = *((word32) eax_1365 + edi * 0x04)
	branch eax_1463 == 0x00 l0804B32D
l0804B158:
	dwLoc30_1874 = (word32) eax_1463 + 4
	dwLoc3C = *eax_1463
	goto l0804AF4D
l0804B170:
	branch output_charset_cached.11630 == 0x00 l0804B2ED
l0804B181:
	dwLoc38 = output_charset_cache.11629
l0804B18A:
	branch dwLoc38 != 0x00 l0804B099
l0804B195:
	dwLoc38 = *((word32) gs->ptrFFFFFFD0->t0000 + 92)
	goto l0804B099
l0804B1B0:
	dwLoc30_1874 = eax_268 + dwLoc38
	dwLoc3C = (word32) edx_267 + 1
	goto l0804AF42
l0804B1CE:
	dwLoc40.u0 = 0x00
	Mem636 = Mem586
	Eq_2 edx_637 = *((word64) esi_1130.u0 + 60)
	Eq_2 ebx_638 = *((word64) esi_1130.u0 + 56)
	dwLoc54 = edx_637
	branch edx_637 == 0x00 l0804B47C
	goto l0804B220
l0804B1F0:
l0804B20C:
l0804B220:
	dwLoc44 = esi_1130
	dwLoc48 = edi
	Eq_2 edi_650 = edx_637
	Eq_2 esi_651 = ebx_638 - 0x0C + edx_637 * 0x0C
	goto l0804B243
l0804B238:
	esi_651 = esi_651 - 0x0C
	branch edi_650 == 0x00 l0804B476
l0804B243:
	edi_650 = edi_650 - 0x01
	esp_1059 = fp - 0x6C
	word32 edx_3585
	word32 ecx_3584
	branch strcmp(*esi_651, dwLoc38, out ecx_3584, out edx_3585) != 0x00 l0804B238
l0804B25C:
	dwLoc38 = esi_651
l0804B265:
	branch dwLoc40 != 0x00 l0804B11A
	goto l0804B12C
l0804B270:
l0804B278:
	branch eax_56 > esi_84 >> 0x01 l0804B055
	goto l0804AF2C
l0804B290:
	Eq_2 eax_1647 = *edx_1626
	esp_1623->tFFFFFFF8 = edx_1626
	transmem_list = eax_1647
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	word32 ecx_3570
	free(gs, stackArg0, stackArg4, out ecx_3570, out edx_1655)
	esp_1059 = (struct Eq_2621 *) (&esp_1623->dwFFFFFFFC + 4)
l0804B2A9:
	freemem.11586 = null
	freemem_size.11587.u0 = 0x00
	branch gs->t000C == 0x00 l0804B2CD
l0804B2CC:
	__lock()
l0804B2CD:
	Eq_2 v35_1691 = lock.11578 - 0x01
	lock.11578 = v35_1691
	branch v35_1691 == 0x00 l0804B2E1
l0804B2D6:
	__lll_unlock_wake_private(0x080CF570, 0x080CE000, edx_1655, gs)
l0804B2E1:
	dwLoc30_1874.u0 = ~0x00
	goto l0804AF87
l0804B2ED:
	Eq_2 eax_375 = getenv(0x080A228C)
	branch eax_375 == 0x00 l0804B30F
l0804B306:
	branch *eax_375 != 0x00 l0804B78D
l0804B30F:
	dwLoc38 = output_charset_cache.11629
l0804B31B:
	output_charset_cached.11630 = 0x01
	goto l0804B18A
l0804B32D:
	branch gs->t000C == 0x00 l0804B340
l0804B33F:
	__lock()
l0804B340:
	word32 eax_1478
	branch __cmpxchg(lock.11578, 0x01, eax_1463, out eax_1478) l0804B354
l0804B349:
	__lll_lock_wait_private(eax_1478, 0x080CF570, gs)
l0804B354:
	dwLoc48 = edi
	Eq_2 dwLoc2C_2559 = dwLoc30_1874
	esi_1130 = freemem_size.11587
	edi.u0 = 0x00
	ptr32 dwLoc28_2560 = freemem.11586 + 1
	dwLoc40 = fp - 0x24
	dwLoc44 = fp - 0x28
	goto l0804B3E1
l0804B388:
	edi = edi + 0x01
	struct Eq_3271 * esp_1623 = esp_1059 - 0x08
	Eq_2 edx_1626 = transmem_list
	esp_1623->dwFFFFFFFC = edi *s 0x0FF0
	esp_1623->tFFFFFFF8 = edx_1626
	freemem_size.11587 = edi *s 0x0FF0
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	esi_1130 = edi *s 0x0FF0
	dwLoc34 = edx_1626
	word32 edx_3557
	word32 ebp_3558
	word32 esi_3559
	word32 edi_3560
	eax_1636 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx_3557, out ebp_3558, out esi_3559, out edi_3560)
	branch eax_1636 == 0x00 l0804B290
l0804B3BD:
	transmem_list = eax_1636
	esi_1130 = edi *s 0x0FF0 - 0x04
l0804B3C9:
	freemem.11586 = (word32) eax_1636 + 4
	freemem_size.11587 = esi_1130
	dwLoc28_2560 = (word32) eax_1636 + 8
l0804B3E1:
	branch esi_1130 <= 0x03 l0804B42A
l0804B3E6:
	struct Eq_3060 * esp_1515 = esp_1059 - 0x08
	esp_1515->ptrFFFFFFFC = fp - 0x24
	esp_1515->dwFFFFFFF8 = (word32) esi_1130 + (dwLoc28_2560 - 0x04)
	esp_1515->ptrFFFFFFF4 = fp - 0x28
	Mem1529[esp_1515 + -16:word32] = dwLoc3C + dwLoc2C_2559
	esp_1515->ptrFFFFFFEC = fp - 44
	esp_1515->tFFFFFFE8 = *((word32) dwLoc38 + 4)
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>
	Eq_2 ecx_1542
	Eq_2 edx_1543
	ui32 eax_1541 = __gconv(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, out ecx_1542, out edx_1543)
	esp_1059 = (struct Eq_2621 *) (&esp_1515->ptrFFFFFFFC + 3)
	branch (eax_1541 & ~0x04) == 0x00 l0804B81D
l0804B41B:
	branch eax_1541 != 0x05 l0804AF57
l0804B424:
	dwLoc2C_2559 = dwLoc30_1874
l0804B42A:
	Eq_2 eax_1636
	Eq_2 edx_1655
	branch edi != 0x00 l0804B388
l0804B432:
	struct Eq_3312 * esp_1664 = esp_1059 - 0x0C
	esp_1664->dwFFFFFFFC = 0x0FF0
	freemem_size.11587.u0 = 0x0FF0
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	edi.u0 = 0x080CE000
	word32 edi_3567
	word32 ebp_3565
	word32 esi_3566
	word32 ebx_3564
	word32 ecx_3563
	eax_1636 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3563, out edx_1655, out ebx_3564, out ebp_3565, out esi_3566, out edi_3567)
	esp_1059 = (struct Eq_2621 *) (&esp_1664->dwFFFFFFFC + 4)
	branch eax_1636 == 0x00 l0804B2A9
l0804B459:
	Eq_2 edx_1703 = transmem_list
	transmem_list = eax_1636
	*eax_1636 = edx_1703
	esi_1130.u0 = 0x0FEC
	edi.u0 = 0x01
	goto l0804B3C9
l0804B47C:
	Eq_2 ebx_716
	ui32 eax_688 = (word32) edx_637 + 3 + edx_637 * 0x02
	dwLoc44 = eax_688 << 0x02
	branch ebx_638 == 0x00 l0804B7DC
l0804B494:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	word32 edx_3594
	word32 ebp_3595
	word32 esi_3596
	word32 edi_3597
	ebx_716 = __realloc(gs, stackArg0, ebx_638, eax_688 << 0x02, out edx_3594, out ebp_3595, out esi_3596, out edi_3597)
l0804B4A6:
	branch ebx_716 == 0x00 l0804B7F4
l0804B4AE:
	*((word64) esi_1130.u0 + 56) = ebx_716
	Eq_2 eax_747 = strdup(dwLoc38)
	dwLoc48 = eax_747
	branch eax_747 == 0x00 l0804B7F4
l0804B4CA:
	Eq_2 ecx_784 = ebx_716 - 0x0C + (eax_688 << 0x02)
	*ecx_784 = eax_747
	((word32) ecx_784 + 4)->u0 = ~0x00
	dwLoc38 = ecx_784
	eax_1312 = _nl_find_msg(edi, gs, dwArg04, dwArg08, 134955513, 0x00, fp - 0x24)
	esp_1059 = fp - 0x6C
	branch eax_1312 == ~0x00 l0804B8DF
l0804B507:
	branch eax_1312 == 0x00 l0804B718
l0804B50F:
	word32 edx_3599
	word32 ecx_3598
	Eq_2 eax_820 = strstr(gs, eax_1312, 0x080A229B, out ecx_3598, out edx_3599)
	esp_1059 = fp - 0x6C
	branch eax_820 == 0x00 l0804B718
l0804B52A:
	Eq_2 eax_837 = strcspn((word32) eax_820 + 8, 0x080A22A4)
	struct Eq_3686 * esp_844 = fp - 0x6C
	struct Eq_3686 * ebx_849 = fp - 0x6C - ((word32) eax_837 + 28 & ~0x0FFF)
	ui32 ecx_850 = (word32) eax_837 + 28 & ~0x0F
	branch fp - 0x6C == ebx_849 l0804B570
l0804B55E:
	esp_844 = esp_844 - 0x1000
	esp_844->dw0FFC = esp_844->dw0FFC
	branch esp_844 != ebx_849 l0804B55E
l0804B570:
	branch (ecx_850 & 0x0FFF) == 0x00 l0804B582
l0804B57B:
	esp_844 = esp_844 - (ecx_850 & 0x0FFF)
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_844 - 0x04)[(ecx_850 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_844 - 0x04)[(ecx_850 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]
l0804B582:
	struct Eq_3717 * esp_883 = esp_844 - 0x04
	esp_883->tFFFFFFFC = eax_837
	esp_883->tFFFFFFF8 = (word32) eax_820 + 8
	Eq_3727 edx_882 = (char *) esp_844 + 0x0F
	esp_883->tFFFFFFF4 = edx_882 & ~0x0F
	word32 edx_3600
	*__mempcpy(esp_883->tFFFFFFF4, esp_883->tFFFFFFF8, esp_883->tFFFFFFFC, out edx_3600) = 0x00
	up32 ebx_884 = 0x00
	esp_1059 = (struct Eq_2621 *) ((char *) &esp_883->tFFFFFFFC + 8)
	Eq_2 eax_913 = eax_747
	goto l0804B5BE
l0804B5B0:
	eax_913 = (word32) eax_913 + 1
	ebx_884 = ebx_884 + (word32) ((int8) (dl_917 == 0x2F))
l0804B5BE:
	byte dl_917 = *eax_913
	branch dl_917 != 0x00 l0804B5B0
l0804B5C5:
	Eq_3787 eax_930 = eax_913 - eax_747
	struct Eq_2621 * ecx_936 = (char *) &esp_883->tFFFFFFFC + 8 - ((word32) eax_930 + 38 & ~0x0FFF)
	ui32 edx_937 = (word32) eax_930 + 38 & ~0x0F
	branch (char *) &esp_883->tFFFFFFFC + 8 == ecx_936 l0804B5F1
l0804B5DF:
	esp_1059 = esp_1059 - 0x1000
	esp_1059[0x03FF] = esp_1059[0x03FF]
	branch esp_1059 != ecx_936 l0804B5DF
l0804B5F1:
	branch (edx_937 & 0x0FFF) == 0x00 l0804B601
l0804B5FA:
	esp_1059 = esp_1059 - (edx_937 & 0x0FFF)
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_937 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_937 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]
l0804B601:
	Eq_3815 eax_965 = (char *) esp_1059 + 0x0F
	Eq_2 edx_970 = eax_747
	struct Eq_3819 * ecx_1009 = eax_965 & ~0x0F
	dwLoc54 = eax_965 & ~0x0F
	byte al_975 = *eax_747
	branch al_975 == 0x00 l0804B940
l0804B61E:
	Eq_3851 eax_986[] = g_ptr80CE084
	int32 eax_1000 = (int32) al_975
l0804B631:
	ecx_1009 = ecx_1009 + 1
	ecx_1009->bFFFFFFFF = (byte) eax_986[eax_1000]
	edx_970 = (word32) edx_970 + 1
	eax_1000 = (int32) *edx_970
	branch (byte) eax_1000 != 0x00 l0804B631
l0804B64A:
	branch ebx_884 <= 0x01 l0804B898
l0804B653:
	ecx_1009->b0000 = 0x00
	byte * eax_1025 = edx_882 & ~0x0F
	ebx_1026 = 0x00
	goto l0804B66B
l0804B65D:
	eax_1025 = eax_1025 + 1
	ebx_1026 = ebx_1026 + (word32) ((int8) (dl_1032 == 0x2F))
l0804B66B:
	byte dl_1032 = *eax_1025
	branch dl_1032 != 0x00 l0804B65D
l0804B672:
	Eq_3890 eax_1045 = eax_1025 - (edx_882 & ~0x0F)
	struct Eq_2621 * ecx_1054 = esp_1059 - ((word32) eax_1045 + 30 & ~0x0FFF)
	ui32 edx_1055 = (word32) eax_1045 + 30 & ~0x0F
	branch esp_1059 == ecx_1054 l0804B69E
l0804B68C:
	esp_1059 = esp_1059 - 0x1000
	esp_1059[0x03FF] = esp_1059[0x03FF]
	branch esp_1059 != ecx_1054 l0804B68C
l0804B69E:
	branch (edx_1055 & 0x0FFF) == 0x00 l0804B6AE
l0804B6A7:
	esp_1059 = esp_1059 - (edx_1055 & 0x0FFF)
	(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_1055 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1059 - 0x04)[(edx_1055 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0]
l0804B6AE:
	Eq_3917 eax_1083 = (char *) esp_1059 + 0x0F
	int32 eax_1091 = (int32) *(edx_882 & ~0x0F)
	edx_1085 = eax_1083 & ~0x0F
	dwLoc44 = eax_1083 & ~0x0F
	branch (byte) eax_1091 == 0x00 l0804B91E
l0804B6C8:
	byte * esi_1112 = edx_882 & ~0x0F
	Eq_3851 ecx_1113[] = g_ptr80CE084
l0804B6D7:
	edx_1085 = edx_1085 + 0x01
	*((word32) edx_1085 - 1) = ecx_1113[eax_1091]
	esi_1112 = esi_1112 + 1
	eax_1091 = (int32) *esi_1112
	branch (byte) eax_1091 != 0x00 l0804B6D7
l0804B6ED:
	branch ebx_1026 <= 0x01 l0804B889
l0804B6F6:
	*edx_1085 = 0x00
	struct Eq_2860 * esp_1196 = esp_1059 - 4
	esp_1196->dw0000 = 0x01
	esp_1196->dwFFFFFFFC = (word32) dwLoc38 + 4
	esp_1196->tFFFFFFF8 = dwLoc44
	esp_1196->tFFFFFFF4 = dwLoc54
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>
	word32 eax_1266 = __gconv_open(gs, stackArg4, dwArg04, dwArg08, dwArg0C)
	esp_1059 = (struct Eq_2621 *) (&esp_1196->dw0000 + 1)
	branch eax_1266 != 0x00 l0804B8AB
l0804B718:
	((word32) dwLoc38 + 8)->u0 = 0x00
	*((word32) esi_1130 + 60) = (word32) *((word32) esi_1130 + 60) + 1
	goto l0804B265
l0804B72B:
	Eq_2 ecx_1369 = 0x01
	branch gs->t000C == 0x00 l0804B73E
l0804B73D:
	__lock()
l0804B73E:
	word32 eax_1378
	branch __cmpxchg(lock.11578, 0x01, eax_1365, out eax_1378) l0804B752
l0804B747:
	ecx_1369 = __lll_lock_wait_private(eax_1378, 0x080CF570, gs)
l0804B752:
	Eq_2 edx_1392 = *((word32) dwLoc38 + 8)
	branch edx_1392 == 0x00 l0804B8E7
l0804B760:
	branch gs->t000C == 0x00 l0804B76E
l0804B76D:
	__lock()
l0804B76E:
	Eq_2 v32_1438 = lock.11578 - 0x01
	lock.11578 = v32_1438
	branch v32_1438 == 0x00 l0804B782
l0804B777:
	__lll_unlock_wake_private(0x080CF570, ecx_1369, edx_1392, gs)
l0804B782:
	eax_1365 = *((word32) dwLoc38 + 8)
	goto l0804B144
l0804B78D:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_3573
	word32 edx_3574
	Eq_2 eax_393 = strlen(eax_375, out ecx_3573, out edx_3574)
	Eq_2 stackArg0 = <invalid>
	word32 ebp_3579
	word32 esi_3580
	word32 edi_3581
	word32 edx_3577
	word32 ebx_3578
	word32 ecx_3576
	Eq_2 eax_434 = __libc_malloc(gs, stackArg0, (word32) eax_393 + 1, out ecx_3576, out edx_3577, out ebx_3578, out ebp_3579, out esi_3580, out edi_3581)
	dwLoc38 = eax_434
	branch eax_434 == 0x00 l0804B7CB
l0804B7B4:
	word32 ecx_3582
	word32 edx_3583
	memcpy(eax_434, eax_375, (word32) eax_393 + 1, out ecx_3582, out edx_3583)
l0804B7CB:
	output_charset_cache.11629 = eax_434
	goto l0804B31B
l0804B7DC:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	word32 ecx_3587
	word32 edx_3588
	word32 edi_3592
	word32 ebx_3589
	word32 esi_3591
	word32 ebp_3590
	ebx_716 = __libc_malloc(gs, stackArg0, eax_688 << 0x02, out ecx_3587, out edx_3588, out ebx_3589, out ebp_3590, out esi_3591, out edi_3592)
	goto l0804B4A6
l0804B7F4:
	esp_1059 = fp - 0x6C
	goto l0804B2E1
l0804B81D:
	word32 * edx_1552 = freemem.11586
	word32 ecx_1554 = dwLoc28_2560 - edx_1552
	*edx_1552 = ecx_1554 - 0x04
	*((word32) *((word32) dwLoc38 + 8) + edi * 0x04) = edx_1552
	ui32 edx_1561 = freemem_size.11587 - ecx_1554
	freemem_size.11587 = edx_1561 & ~0x03
	freemem.11586 = dwLoc28_2560 + (edx_1561 & 0x03)
	esi_1130.u0 = 0x080CE000
	branch gs->t000C == 0x00 l0804B867
l0804B866:
	__lock()
l0804B867:
	Eq_2 v34_1572 = lock.11578 - 0x01
	lock.11578 = v34_1572
	branch v34_1572 == 0x00 l0804B87B
l0804B870:
	__lll_unlock_wake_private(0x080CF570, edx_1561 & 0x03, edx_1561 & ~0x03, gs)
l0804B87B:
	eax_1463 = *((word32) *((word32) dwLoc38 + 8) + edi * 0x04)
	goto l0804B158
l0804B889:
	*edx_1085 = 0x2F
	branch ebx_1026 == 0x00 l0804B90D
l0804B890:
	edx_1085 = (word32) edx_1085 + 1
	goto l0804B6F6
l0804B898:
	ecx_1009->b0000 = 0x2F
	branch ebx_884 == 0x00 l0804B926
l0804B8A3:
	ecx_1009 = ecx_1009 + 1
	goto l0804B653
l0804B8AB:
	branch eax_1266 == 0x01 l0804B957
l0804B8B4:
	branch dwLoc40 == 0x00 l0804B8CC
l0804B8BA:
	Eq_2 eax_1283 = (word32) esi_1130 + 64
	esp_1196->tFFFFFFF4 = eax_1283
	fn00000000()
l0804B8CC:
	struct Eq_2956 * esp_1294 = esp_1059 - 0x0C
	esp_1294->tFFFFFFFC = dwLoc48
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>
	Eq_2 stackArg4 = <invalid>
	word32 ecx_3545
	word32 edx_3546
	free(gs, stackArg0, stackArg4, out ecx_3545, out edx_3546)
	esp_1059 = (struct Eq_2621 *) ((char *) &esp_1294->tFFFFFFFC + 20)
	eax_1312.u0 = 0x00
l0804B8DF:
	dwLoc30_1874 = eax_1312
	goto l0804AF87
l0804B8E7:
	struct Eq_3156 * esp_1399 = esp_1059 - 0x08
	esp_1399->dwFFFFFFFC = 0x04
	Mem1410[esp_1399 + -8:word32] = dwLoc34 + Mem1403[esi_1130 + 0x20:word32]
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>
	word32 ebp_3550
	word32 edi_3552
	word32 ebx_3549
	word32 esi_3551
	Eq_2 eax_1418 = __libc_calloc(gs, stackArg4, dwArg04, out ecx_1369, out edx_1392, out ebx_3549, out ebp_3550, out esi_3551, out edi_3552)
	branch eax_1418 == 0x00 l0804B948
l0804B902:
	*((word32) dwLoc38 + 8) = eax_1418
	goto l0804B354
l0804B90D:
	*((word32) edx_1085 + 1) = 0x2F
	edx_1085 = (word32) edx_1085 + 2
	goto l0804B6F6
l0804B919:
	word32 ecx_3540
	word32 edx_3541
	__stack_chk_fail(out ecx_3540, out edx_3541)
l0804B91E:
	edx_1085 = dwLoc44
	goto l0804B6ED
l0804B926:
	ecx_1009[1] = (struct Eq_3819) 0x2F
	ecx_1009 = ecx_1009 + 0x0A
	ecx_1009->dwFFFFFFF8 = 0x4E415254
	ecx_1009->dwFFFFFFFC = 1414089811
	goto l0804B653
l0804B940:
	ecx_1009 = eax_965 & ~0x0F
	goto l0804B64A
l0804B948:
	((word32) dwLoc38 + 8)->u0 = ~0x00
	goto l0804B760
l0804B957:
	((word32) dwLoc38 + 4)->u0 = ~0x00
	goto l0804B718
_nl_find_msg_exit:
}

// 0804B970: void __dcigettext(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack word32 dwArg14, Stack Eq_2 dwArg18)
// Called from:
//      dcgettext
void __dcigettext(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, word32 dwArg14, Eq_2 dwArg18)
{
	struct Eq_3986 * ebp_1192 = fp - 4;
	if (dwArg08 != 0x00)
	{
		if (dwArg18 > 0x0C || dwArg18 == 0x06)
		{
			if (dwArg10 != 0x00 && dwArg14 != 0x01)
				goto l0804BEAD;
			goto l0804BE83;
		}
		Eq_2 eax_52 = gs->tFFFFFFE0;
		Eq_2 eax_76 = dwArg04;
		if (dwArg04 == 0x00)
			eax_76 = _nl_current_default_domain;
		word32 eax_100;
		__current_locale_name(gs, dwArg18, out eax_100);
		Eq_2 eax_146 = __tfind(fp - 0x40, 135067000, 134524144);
		Mem175 = Mem155;
		if (eax_146 == 0x00)
		{
l0804BABA:
			Eq_2 dwLoc60_1410;
			struct Eq_4054 * esp_275;
			Eq_2 eax_250 = _nl_domain_bindings;
			Eq_2 dwLoc54_1403 = eax_250;
			if (eax_250 != 0x00)
			{
				Eq_2 esi_256 = eax_250;
				do
				{
					word32 ecx_2192;
					word32 edx_2193;
					Eq_2 eax_268 = strcmp(eax_76, (word32) esi_256 + 0x0C, out ecx_2192, out edx_2193);
					esp_275 = fp - 0x9C;
					if (eax_268 == 0x00)
					{
						Eq_2 eax_295 = *((word32) esi_256 + 4);
						dwLoc54_1403 = esi_256;
						dwLoc60_1410 = eax_295;
						if (*eax_295 == 0x2F)
							goto l0804BB58;
						word32 edi_2195;
						word32 edx_2194;
						Eq_2 eax_310 = getcwd(gs, 0x00, 0x00, out edx_2194, out edi_2195);
						esp_275 = fp - 0x9C;
						if (eax_310 == 0x00)
							goto l0804BE38;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2164 eax_330 = ___asprintf();
						Eq_2 stackArg0 = <invalid>;
						word32 ecx_2201;
						word32 edx_2202;
						free(gs, stackArg0, eax_310, out ecx_2201, out edx_2202);
						esp_275 = fp - 0x98;
						if (eax_330 < 0x00)
							goto l0804BE38;
						dwLoc60_1410.u0 = 0x00;
						goto l0804BB58;
					}
					if (eax_268 < 0x00)
					{
						dwLoc54_1403.u0 = 0x00;
						goto l0804BF07;
					}
					esi_256 = *esi_256;
				} while (esi_256 != 0x00);
				dwLoc54_1403 = esi_256;
				dwLoc60_1410.u0 = 0x080A22C0;
			}
			else
			{
l0804BF07:
				esp_275 = fp - 0x9C;
				dwLoc60_1410.u0 = 0x080A22C0;
			}
l0804BB58:
			struct Eq_4133 * esp_354 = esp_275 - 0x0C;
			esp_354->tFFFFFFFC = dwArg18;
			Eq_2 eax_362 = 0x080A58E0 + (word32) (*((word32) dwArg18 + 0x080A58D0));
			Eq_2 eax_366;
			__current_locale_name(gs, esp_354->tFFFFFFFC, out eax_366);
			Eq_4153 Z_370 = <invalid>;
			Eq_4153 C_369 = <invalid>;
			cu8 * edi_360 = &g_b80A4B32;
			word32 ecx_372 = 0x02;
			Eq_2 esi_374 = eax_366;
			Eq_2 edx_375 = eax_366;
			bool v57_1308 = Z_370 | C_369;
			while (ecx_372 != 0x00)
			{
				v57_1308 = *esi_2242 > *edi_2243;
				esi_374 = (word32) esi_2242 + 1;
				edi_360 = edi_2243 + 1;
				--ecx_372;
				esi_2242 = esi_374;
				edi_2243 = edi_360;
				if (*esi_2242 == *edi_2243)
					break;
			}
			if ((int8) v57_1308 - C_369 != 0x00)
			{
				esp_354->tFFFFFFFC.u0 = 0x080A22AE;
				Eq_2 eax_410 = getenv(esp_354->tFFFFFFFC);
				edx_375 = eax_366;
				if (eax_410 != 0x00 && *eax_410 != 0x00)
					edx_375 = eax_410;
			}
			struct Eq_4251 * esp_426 = esp_275 - 0x0C;
			esp_426->tFFFFFFFC = eax_76;
			word32 edx_2204;
			word32 ecx_2203;
			Eq_2 eax_436 = strlen(esp_426->tFFFFFFFC, out ecx_2203, out edx_2204);
			esp_426->tFFFFFFFC = eax_362;
			word32 ecx_2205;
			word32 edx_2206;
			ui32 eax_459 = (word32) strlen(esp_426->tFFFFFFFC, out ecx_2205, out edx_2206) + ((word32) eax_436 + 32);
			struct Eq_4283 * esp_457 = (char *) &esp_426->tFFFFFFFC + 16;
			struct Eq_4283 * edi_463 = (char *) &esp_426->tFFFFFFFC + 16 - (eax_459 & ~0x0FFF);
			if ((char *) &esp_426->tFFFFFFFC + 16 != edi_463)
			{
				do
				{
					esp_457 -= 0x1000;
					esp_457->dw0FFC = esp_457->dw0FFC;
				} while (esp_457 != edi_463);
			}
			int32 ecx_479 = eax_459 & ~0x0F & 0x0FFF;
			if (ecx_479 != 0x00)
			{
				esp_457 -= ecx_479;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_457 - 0x04)[ecx_479 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_457 - 0x04)[ecx_479 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			struct Eq_4326 * esp_492 = esp_457 - 0x08;
			esp_492->tFFFFFFFC = eax_362;
			Eq_4332 eax_491 = (char *) esp_457 + 0x0F;
			esp_492->tFFFFFFF8 = eax_491 & ~0x0F;
			word32 ecx_2207;
			Eq_2 eax_511 = __stpcpy(esp_492->tFFFFFFF8, esp_492->tFFFFFFFC, out ecx_2207);
			eax_511->u4 = 0x2F;
			esp_492->t0000 = eax_436;
			esp_492->tFFFFFFFC = eax_76;
			esp_492->tFFFFFFF8 = (word32) eax_511 + 1;
			word32 edx_2208;
			*__mempcpy(esp_492->tFFFFFFF8, esp_492->tFFFFFFFC, esp_492->t0000, out edx_2208) = 0x006F6D2E;
			esp_492->tFFFFFFF8 = edx_375;
			word32 ecx_2209;
			word32 edx_2210;
			Eq_2 eax_543 = strlen(esp_492->tFFFFFFF8, out ecx_2209, out edx_2210);
			struct Eq_4054 * esp_550 = (char *) &esp_492->t0000 + 8;
			Eq_2 edx_551 = edx_375;
			struct Eq_4054 * esi_556 = (char *) &esp_492->t0000 + 8 - ((word32) eax_543 + 28 & ~0x0FFF);
			ui32 ecx_557 = (word32) eax_543 + 28 & ~0x0F;
			if ((char *) &esp_492->t0000 + 8 != esi_556)
			{
				do
				{
					esp_550 -= 0x1000;
					esp_550->dw0FFC = esp_550->dw0FFC;
				} while (esp_550 != esi_556);
			}
			if ((ecx_557 & 0x0FFF) != 0x00)
			{
				esp_550 -= ecx_557 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_550 - 0x04)[(ecx_557 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_550 - 0x04)[(ecx_557 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_4439 eax_584 = (char *) &esp_550->dwFFFFFFFC + 19;
			do
			{
l0804BCC0:
				while (true)
				{
					cu8 al_606 = *edx_551;
					if (al_606 != 0x3A)
						break;
					edx_551 = (word32) edx_551 + 1;
				}
				bool v61_1312 = al_606 > 0x00;
				if (al_606 == 0x00)
				{
					*(eax_584 & ~0x0F) = 0x43;
					break;
				}
				struct Eq_4462 * ecx_615 = eax_584 & ~0x0F;
				do
				{
					++ecx_615;
					ecx_615->bFFFFFFFF = al_606;
					edx_551 = (word32) edx_551 + 1;
					al_606 = (cu8) *edx_551;
				} while (al_606 != 0x00 && al_606 != 0x3A);
				ecx_615->b0000 = 0x00;
				Eq_4933 esi_637 = *(union Eq_4933 *) 0x080CDDAC;
				v61_1312 = esi_637 > 0x00;
				if (esi_637 == 0x00)
					break;
				struct Eq_4957 * esp_644 = esp_550 - 0x08;
				esp_644->tFFFFFFFC.u0 = 0x2F;
				esp_644->tFFFFFFF8 = eax_584 & ~0x0F;
				word32 ecx_2240;
				word32 edx_2241;
				Eq_2 eax_653 = strchr(esp_644->tFFFFFFF8, esp_644->tFFFFFFFC, out ecx_2240, out edx_2241);
				v61_1312 = eax_653 > 0x00;
			} while (eax_653 != 0x00);
			esp_275 = esp_550;
			cu8 * esi_671 = eax_584 & ~0x0F;
			cu8 * edi_672 = &g_b80A4B32;
			word32 ecx_673 = 0x02;
			while (ecx_673 != 0x00)
			{
				v61_1312 = *esi_2244 > *edi_2245;
				esi_671 = esi_2244 + 1;
				edi_672 = edi_2245 + 1;
				--ecx_673;
				esi_2244 = esi_671;
				edi_2245 = edi_672;
				if (*esi_2244 == *edi_2245)
					break;
			}
			Eq_4470 al_697 = (int8) v61_1312 - (*esi_2244 < *edi_2245);
			bool v68_1319 = al_697 > 0x00;
			if (al_697 != 0x00)
			{
				cu8 * esi_704 = eax_584 & ~0x0F;
				cu8 * edi_705 = &g_b80A22B7;
				word32 ecx_706 = 0x06;
				while (ecx_706 != 0x00)
				{
					v68_1319 = *esi_2246 > *edi_2247;
					esi_704 = esi_2246 + 1;
					edi_705 = edi_2247 + 1;
					--ecx_706;
					esi_2246 = esi_704;
					edi_2247 = edi_705;
					if (*esi_2246 == *edi_2247)
						break;
				}
				if ((int8) v68_1319 - (*esi_2246 < *edi_2247) != 0x00)
				{
					struct Eq_4553 * esp_736 = esp_550 - 4;
					esp_736->t0000 = dwLoc54_1403;
					esp_736->dwFFFFFFFC = eax_491 & ~0x0F;
					esp_736->dwFFFFFFF8 = eax_584 & ~0x0F;
					esp_736->tFFFFFFF4 = dwLoc60_1410;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 eax_773 = _nl_find_domain(gs, stackArg4, dwArg04, dwArg08, dwArg0C);
					Eq_2 edi_781 = eax_773;
					if (eax_773 != 0x00)
					{
						Eq_2 esi_851;
						esp_550->dwFFFFFFF0 = fp - 0x44;
						esp_550->dwFFFFFFEC = 0x01;
						esp_550->dwFFFFFFE8 = (word32) dwArg08;
						esp_550->dwFFFFFFE4 = (word32) dwLoc54_1403;
						esp_550->dwFFFFFFE0 = (word32) eax_773;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						Eq_2 eax_798 = _nl_find_msg(eax_773, gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10);
						esp_275 = esp_550;
						if (eax_798 != 0x00)
						{
							esi_851 = eax_798;
							if (eax_798 != ~0x00)
							{
l0804BD60:
								esp_550->dwFFFFFFF0 = 0x00;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg0 = <invalid>;
								Eq_2 stackArg4 = <invalid>;
								word32 ecx_2215;
								word32 edx_2216;
								free(gs, stackArg0, stackArg4, out ecx_2215, out edx_2216);
								ptr32 esp_1136 = &esp_550->dwFFFFFFFC + 2;
								if (eax_146 != 0x00)
								{
									struct Eq_4061 * eax_1163 = *eax_146;
									eax_1163->t000C = _nl_msg_cat_cntr;
									eax_1163->t0010 = edi_781;
									eax_1163->t0014 = esi_851;
									eax_1163->t0018 = dwLoc44;
								}
								else
								{
									esp_550->dwFFFFFFF4 = (word32) dwArg08;
									word32 edx_2218;
									word32 ecx_2217;
									Eq_2 eax_952 = strlen(esp_550->dwFFFFFFF4, out ecx_2217, out edx_2218);
									esp_550->dwFFFFFFF4 = eax_100;
									word32 ecx_2219;
									word32 edx_2220;
									esp_550->dwFFFFFFF4 = (word32) strlen(esp_550->dwFFFFFFF4, out ecx_2219, out edx_2220) + ((word32) eax_436 + 30) + ((word32) eax_952 + 1);
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg0 = <invalid>;
									Eq_2 stackArg4 = <invalid>;
									word32 edx_2224;
									word32 ebx_2225;
									word32 esi_2227;
									word32 edi_2228;
									word32 ebp_2226;
									word32 ecx_2223;
									Eq_2 eax_979 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_2223, out edx_2224, out ebx_2225, out ebp_2226, out esi_2227, out edi_2228);
									esp_1136 = &esp_550->dwFFFFFFFC + 2;
									if (eax_979 != 0x00)
									{
										esp_550->dwFFFFFFFC = (word32) eax_952 + 1;
										esp_550->dwFFFFFFF8 = (word32) dwArg08;
										esp_550->dwFFFFFFF4 = (word32) eax_979 + 28;
										word32 edx_2229;
										Eq_2 eax_1000 = __mempcpy(esp_550->dwFFFFFFF4, esp_550->dwFFFFFFF8, esp_550->dwFFFFFFFC, out edx_2229);
										esp_550->dwFFFFFFFC = (word32) eax_436 + 1;
										esp_550->dwFFFFFFF8 = (word32) eax_76;
										esp_550->dwFFFFFFF4 = (word32) eax_1000;
										word32 ecx_2230;
										word32 edx_2231;
										memcpy(esp_550->dwFFFFFFF4, esp_550->dwFFFFFFF8, esp_550->dwFFFFFFFC, out ecx_2230, out edx_2231);
										esp_550->dwFFFFFFF8 = eax_100;
										Eq_2 ecx_1030 = (word32) eax_1000 + ((word32) eax_436 + 1);
										esp_550->dwFFFFFFF4 = (word32) ecx_1030;
										strcpy(esp_550->dwFFFFFFF4, esp_550->dwFFFFFFF8);
										*eax_979 = eax_1000;
										*((word32) eax_979 + 8) = ecx_1030;
										*((word32) eax_979 + 4) = dwArg18;
										*((word32) eax_979 + 16) = edi_781;
										Eq_2 eax_1061 = _nl_msg_cat_cntr;
										*((word32) eax_979 + 20) = esi_851;
										*((word32) eax_979 + 0x0C) = eax_1061;
										*((word32) eax_979 + 24) = dwLoc44;
										esp_550->dwFFFFFFFC = 134524144;
										esp_550->dwFFFFFFF8 = 135067000;
										esp_550->dwFFFFFFF4 = (word32) eax_979;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg4 = <invalid>;
										word32 ecx_2233;
										word32 edx_2234;
										union Eq_2 * eax_1102 = __tsearch(stackArg4, dwArg04, dwArg08, out ecx_2233, out edx_2234);
										esp_1136 = &esp_550->dwFFFFFFFC + 2;
										Mem1131 = Mem1096;
										if (eax_1102 == null || *eax_1102 != eax_979)
										{
											esp_550->dwFFFFFFF4 = (word32) eax_979;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_2 stackArg0 = <invalid>;
											Eq_2 stackArg4 = <invalid>;
											word32 ecx_2238;
											word32 edx_2239;
											free(gs, stackArg0, stackArg4, out ecx_2238, out edx_2239);
											esp_1136 = &esp_550->dwFFFFFFFC + 3;
										}
									}
								}
								gs->tFFFFFFE0 = eax_52;
								if (dwArg10 != 0x00)
								{
									struct Eq_4706 * esp_1181 = esp_1136 - 0x0C;
									Eq_2 eax_1184 = *((word32) edi_781 + 8);
									esp_1181->tFFFFFFFC = dwLoc44;
									ebp_1192 = plural_lookup.isra.2(eax_1184, esp_1181->tFFFFFFFC);
								}
								if (ebp_1192->dwFFFFFF90 != 0x00)
								{
									struct Eq_4726 * esp_1209 = esp_1136 - 0x0C;
									esp_1209->ptrFFFFFFFC = 0x080CF540;
									fn00000000();
									esp_1209->ptrFFFFFFFC = 0x080CF960;
									word32 ecx_1228;
									word32 edx_1229;
									fn00000000();
								}
								goto l0804BE86;
							}
							goto l0804BE38;
						}
						Eq_2 eax_807 = *((word32) eax_773 + 16);
						if (eax_807 != 0x00)
						{
							Eq_2 edi_816 = 0x00;
							do
							{
								esp_550->dwFFFFFFF0 = fp - 0x44;
								esp_550->dwFFFFFFEC = 0x01;
								esp_550->dwFFFFFFE8 = (word32) dwArg08;
								esp_550->dwFFFFFFE4 = (word32) dwLoc54_1403;
								esp_550->dwFFFFFFE0 = (word32) eax_807;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg4 = <invalid>;
								Eq_2 eax_839 = _nl_find_msg(edi_816, gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10);
								esp_275 = esp_550;
								if (eax_839 == ~0x00)
									goto l0804BE38;
								if (eax_839 != 0x00)
								{
									esi_851 = eax_839;
									edi_781 = *((word32) eax_773 + (edi_816 * 0x04 + 16));
									goto l0804BD60;
								}
								edi_816 = (word32) edi_816 + 1;
								eax_807 = *((word32) eax_773 + (edi_816 * 0x04 + 16));
							} while (eax_807 != 0x00);
						}
					}
					goto l0804BCC0;
				}
			}
l0804BE38:
			esp_275->dwFFFFFFF0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_2198;
			word32 edx_2199;
			free(gs, stackArg0, stackArg4, out ecx_2198, out edx_2199);
			gs->tFFFFFFE0 = eax_52;
			if (dwArg14 != 0x01 && dwArg10 != 0x00)
			{
l0804BEAD:
				goto l0804BE86;
			}
l0804BE83:
			goto l0804BE86;
		}
		struct Eq_4061 * edx_180 = *eax_146;
		if (edx_180->t000C != _nl_msg_cat_cntr)
			goto l0804BABA;
		if (dwArg10 != 0x00)
			ebp_1192 = plural_lookup.isra.2(*((word32) edx_180->t0010 + 8), edx_180->t0018);
		if (ebp_1192->dwFFFFFF90 != 0x00)
		{
			fn00000000();
			word32 ecx_237;
			word32 edx_238;
			fn00000000();
		}
		gs->*ebp_1192->ptrFFFFFF80 = ebp_1192->dwFFFFFF84;
	}
l0804BE86:
	if ((ebp_1192->dwFFFFFFE4 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_2190;
	word32 edx_2191;
	__stack_chk_fail(out ecx_2190, out edx_2191);
	_nl_find_domain(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
}

// 0804C140: Register Eq_2 _nl_find_domain(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __dcigettext
Eq_2 _nl_find_domain(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 edi_155 = dwArg08;
	ui32 eax_27 = gs->dw0014;
	word32 ebp_897;
	word32 edi_898;
	word32 edx_895;
	word32 ebx_896;
	word32 ecx_894;
	Eq_2 eax_90 = _nl_make_l10nflist(0x080CF5C0, dwArg04, (word32) strlen(dwArg04, out ecx_894, out edx_895) + 1, 0x00, dwArg08, 0x00, 0x00, 0x00, 0x00, dwArg0C, 0x00, out ebx_896, out ebp_897, out edi_898);
	Eq_2 ebp_284 = eax_90;
	Mem432 = Mem97;
	if (eax_90 == 0x00)
	{
		word32 ebx_899;
		word32 ebp_900;
		Eq_2 eax_126 = _nl_expand_alias(gs, out ebx_899, out ebp_900);
		if (eax_126 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			word32 edx_912;
			word32 ecx_911;
			Eq_2 eax_140 = strlen(eax_126, out ecx_911, out edx_912);
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_916;
			word32 ebp_917;
			word32 ecx_914;
			word32 edx_915;
			word32 esi_918;
			word32 edi_919;
			Eq_2 eax_150 = __libc_malloc(gs, stackArg0, (word32) eax_140 + 1, out ecx_914, out edx_915, out ebx_916, out ebp_917, out esi_918, out edi_919);
			edi_155 = eax_150;
			if (eax_150 == 0x00)
				goto l0804C203;
			word32 edx_921;
			word32 ecx_920;
			memcpy(eax_150, eax_126, (word32) eax_140 + 1, out ecx_920, out edx_921);
		}
		word32 esi_910;
		word32 ebp_909;
		word32 ebx_908;
		Eq_2 eax_205 = _nl_explode_name(edi_155, fp - 0x34, fp - 0x30, fp - 44, fp - 0x28, fp - 0x24, out ebx_908, out ebp_909, out esi_910);
		if (eax_205 != ~0x00)
		{
			word32 ebp_932;
			word32 ecx_929;
			word32 edx_930;
			word32 ebx_931;
			word32 edi_933;
			Eq_2 eax_279 = _nl_make_l10nflist(0x080CF5C0, dwArg04, (word32) strlen(dwArg04, out ecx_929, out edx_930) + 1, eax_205, dwLoc34, dwLoc2C, dwLoc28, dwLoc24, dwLoc30, dwArg0C, 0x01, out ebx_931, out ebp_932, out edi_933);
			ebp_284 = eax_279;
			struct Eq_5185 * esp_308 = fp - 0x5C;
			Mem304 = Mem273;
			if (eax_279 != 0x00)
			{
				if (*((word32) eax_279 + 4) <= 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg12 = <invalid>;
					Eq_2 stackArg36 = <invalid>;
					Eq_2 stackArg40 = <invalid>;
					Eq_2 stackArg88 = <invalid>;
					Eq_2 stackArg92 = <invalid>;
					_nl_load_domain(eax_279, gs, eax_279, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
				}
				if (*((word32) eax_279 + 8) == 0x00)
				{
					Eq_2 eax_333 = *((word32) eax_279 + 16);
					if (eax_333 != 0x00)
					{
						struct Eq_5264 ** esi_337 = (word32) eax_279 + 16;
						do
						{
							if (*((word32) eax_333 + 4) <= 0x00)
							{
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg12 = <invalid>;
								Eq_2 stackArg36 = <invalid>;
								Eq_2 stackArg40 = <invalid>;
								Eq_2 stackArg88 = <invalid>;
								Eq_2 stackArg92 = <invalid>;
								_nl_load_domain(eax_279, gs, eax_333, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
							}
							if (*((char *) *esi_337 + 8) != 0x00)
								break;
							esi_337 = (struct Eq_5264 **) ((char *) esi_337 + 4);
							eax_333 = *esi_337;
						} while (eax_333 != 0x00);
					}
				}
				esp_308 = fp - 0x5C;
				if (eax_126 != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 ecx_940;
					word32 edx_941;
					free(gs, stackArg0, edi_155, out ecx_940, out edx_941);
					esp_308 = fp - 88;
				}
			}
			if ((esp_308->b001C & 0x01) != 0x00)
			{
				struct Eq_5287 * esp_414 = esp_308 - 0x0C;
				esp_414->dwFFFFFFFC = esp_414->dw0044;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_954;
				word32 edx_955;
				free(gs, stackArg0, stackArg4, out ecx_954, out edx_955);
			}
		}
		goto l0804C203;
	}
	else
	{
		if (*((word32) eax_90 + 4) <= 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg12 = <invalid>;
			Eq_2 stackArg36 = <invalid>;
			Eq_2 stackArg40 = <invalid>;
			Eq_2 stackArg88 = <invalid>;
			Eq_2 stackArg92 = <invalid>;
			_nl_load_domain(eax_90, gs, eax_90, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
		}
		if (*((word32) eax_90 + 8) == 0x00)
		{
			Eq_2 eax_455 = *((word32) eax_90 + 16);
			if (eax_455 != 0x00)
			{
				struct Eq_5192 ** esi_459 = (word32) eax_90 + 16;
				do
				{
					if (*((word32) eax_455 + 4) <= 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg12 = <invalid>;
						Eq_2 stackArg36 = <invalid>;
						Eq_2 stackArg40 = <invalid>;
						Eq_2 stackArg88 = <invalid>;
						Eq_2 stackArg92 = <invalid>;
						_nl_load_domain(eax_90, gs, eax_455, dwArg10, stackArg12, stackArg36, stackArg40, dwLoc34, dwLoc30, dwLoc2C, dwLoc28, stackArg88, stackArg92);
					}
					if (*((char *) *esi_459 + 8) != 0x00)
						break;
					esi_459 = (struct Eq_5192 **) ((char *) esi_459 + 4);
					eax_455 = *esi_459;
				} while (eax_455 != 0x00);
			}
		}
l0804C203:
		if ((eax_27 ^ gs->dw0014) == 0x00)
			return ebp_284;
		word32 edx_907;
		word32 ecx_906;
		__stack_chk_fail(out ecx_906, out edx_907);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg36 = <invalid>;
		Eq_2 stackArg60 = <invalid>;
		Eq_2 stackArg64 = <invalid>;
		Eq_2 stackArg68 = <invalid>;
		Eq_2 stackArg72 = <invalid>;
		Eq_2 stackArg88 = <invalid>;
		Eq_2 stackArg92 = <invalid>;
		return _nl_load_domain(ebp_284, gs, dwArg04, dwArg08, dwArg0C, stackArg36, dwLoc34, stackArg60, stackArg64, stackArg68, stackArg72, stackArg88, stackArg92);
	}
}

// 0804C420: Register Eq_2 _nl_load_domain(Register Eq_2 ebp, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg24, Stack Eq_2 dwArg28, Stack Eq_2 dwArg3C, Stack Eq_2 dwArg40, Stack Eq_2 dwArg44, Stack Eq_2 dwArg48, Stack Eq_2 dwArg58, Stack Eq_2 dwArg5C)
// Called from:
//      _nl_find_msg
//      _nl_find_domain
Eq_2 _nl_load_domain(Eq_2 ebp, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg24, Eq_2 dwArg28, Eq_2 dwArg3C, Eq_2 dwArg40, Eq_2 dwArg44, Eq_2 dwArg48, Eq_2 dwArg58, Eq_2 dwArg5C)
{
	Eq_2 ebx_1292 = 0x080CE000;
	Eq_2 edx_19 = gs->t0008;
	Eq_2 edi_1127 = dwArg04;
	ui32 eax_24 = gs->dw0014;
	if (g_t80CF5CC != edx_19)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_36;
		if (!__cmpxchg(g_t80CF5C4, 0x01, 0x00, out eax_36))
			__lll_lock_wait_private(eax_36, 0x080CF5C4, gs);
		g_t80CF5CC = edx_19;
	}
	word32 ecx_1573;
	struct Eq_5325 * esi_1581;
	struct Eq_5326 * esp_1251;
	Eq_2 ebp_1276;
	Eq_2 eax_1593;
	Eq_2 eax_1157;
	struct Eq_5330 * esp_1156;
	ptr32 esp_1300;
	struct Eq_5326 * esp_1197;
	word32 eax_1464 = g_dw80CF5C8;
	Eq_2 ecx_100 = *((word32) dwArg04 + 4);
	g_dw80CF5C8 = eax_1464 + 0x01;
	Eq_2 edx_1456 = eax_1464 + 0x01;
	if (ecx_100 != 0x00)
	{
l0804C6B7:
		*((word32) ebx_1292 + 5576) = eax_1464;
		esp_1251 = fp - 0x00EC;
		if (eax_1464 == 0x00)
		{
			*((word32) ebx_1292 + 5580) = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v39_1505 = *((word32) ebx_1292 + 5572) - 0x01;
			*((word32) ebx_1292 + 5572) = v39_1505;
			if (v39_1505 != 0x00)
				__lll_unlock_wake_private((word32) ebx_1292 + 5572, ecx_100, edx_1456, gs);
		}
		Eq_2 eax_1533 = eax_24 ^ gs->dw0014;
		if (eax_1533 == 0x00)
			return eax_1533;
		word32 edx_4012;
		__stack_chk_fail(out ecx_1573, out edx_4012);
l0804D3F2:
		word32 edi_1578 = esp_1251->dw0008;
		esi_1581 = (word32) __bswap(*esp_1251->ptr000C) + edi_1578;
		esp_1251->t0030 = (word32) __bswap(esi_1581->t0000) + edi_1578;
		esp_1251->t0034 = esp_1251->t004C;
l0804D16F:
		eax_1593 = __bswap(esi_1581->t0004);
		if (esi_1581->dw0008 != ~0x00)
			goto l0804D1D5;
l0804D17A:
		Eq_2 esi_1597 = esp_1251->t0034;
		*esi_1597 = eax_1593;
		*((word32) esi_1597 + 4) = esp_1251->t0030;
l0804D189:
		if (esp_1251->dw0038 != 0x01)
		{
			struct Eq_5900 * eax_1857 = esp_1251->ptr0044;
			esp_1251->dw0038 = 0x01;
			ecx_1573 = eax_1857->dw000C;
			if (ecx_1573 == 0x00)
				goto l0804D1A7;
			goto l0804D144;
		}
		esp_1251->t0034 = ebp;
		ebp_1276 = esp_1251->t0020;
		++esp_1251->dw003C;
l0804D290:
		Eq_2 v31_1615 = (word32) dwArg0C + 4;
		esp_1251 = fp;
		dwArg0C = v31_1615;
		if (dwArg58 == v31_1615)
		{
			if (dwArg28 != dwArg3C)
			{
				_nl_load_domain.cold.0();
				return v31_1615;
			}
			Eq_2 esi_1727 = *((word32) dwArg44 + 44);
			if (esi_1727 != 0x00)
			{
				Eq_2 eax_1731 = *((word32) dwArg44 + 52);
				Eq_2 eax_1735 = *((word32) dwArg44 + 48);
				Eq_2 eax_1738 = 0x00;
				do
				{
					Eq_2 edx_1746 = *((word32) eax_1735 + eax_1738 * 0x04);
					Eq_2 ecx_1748 = __bswap(edx_1746);
					if (eax_1731 != 0x00)
						edx_1746 = ecx_1748;
					*((word32) dwArg40 + eax_1738 * 0x04) = edx_1746;
					eax_1738 = (word32) eax_1738 + 1;
				} while (eax_1738 != esi_1727);
			}
			ui32 dwArg18_3146 = 0x00;
			do
			{
				word32 eax_1785 = __hash_string(*((word32) dwArg24 + (dwArg18_4064 * 0x08 + 4)));
				Eq_2 edi_1796 = *((word32) dwArg44 + 44);
				uint32 edx_1809 = (uint32) ((uint64) eax_1785 % (edi_1796 - 0x02));
				Eq_2 eax_1813 = edi_1796 - (edx_1809 + 0x01);
				esp_1197 = fp;
				Eq_2 ecx_1803 = (uint32) ((uint64) eax_1785 % edi_1796);
				dwArg0C = eax_1813;
				uint32 eax_1816 = edx_1809 + 0x01 - edi_1796;
				while (true)
				{
					word32 * eax_1821 = (word32) dwArg40 + ecx_1803 * 0x04;
					if (*eax_1821 == 0x00)
						break;
					Eq_2 eax_1828 = (word32) ecx_1803 + eax_1816;
					Eq_2 edx_1830 = (word32) ecx_1803 + (edx_1809 + 0x01);
					if (eax_1813 > ecx_1803)
						eax_1828 = edx_1830;
					ecx_1803 = eax_1828;
				}
				*eax_1821 = (word32) *((word32) dwArg44 + 20) + (dwArg18_4064 + 0x01);
				dwArg18_3146 = dwArg18_4064 + 0x01;
				dwArg18_4064 = dwArg18_3146;
			} while (dwArg28 != dwArg18_4064 + 0x01);
			*((word32) dwArg44 + 32) = dwArg28;
			((word32) dwArg44 + 52)->u0 = 0x00;
			*((word32) dwArg44 + 36) = dwArg24;
			*((word32) dwArg44 + 40) = dwArg48;
			*((word32) dwArg44 + 48) = dwArg40;
			ebp = dwArg44;
			edi_1127 = dwArg5C;
l0804CC31:
			struct Eq_6822 * esp_1283 = esp_1197 - 0x0C;
			esp_1283->dwFFFFFFFC = esp_1283->dw0028;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 edx_4045;
			word32 ecx_4044;
			free(gs, stackArg0, stackArg4, out ecx_4044, out edx_4045);
			esp_1300 = &esp_1283->dwFFFFFFFC + 5;
l0804C640:
			((word32) ebp + 56)->u0 = 0x00;
			((word32) ebp + 60)->u0 = 0x00;
			struct Eq_5686 * esp_1340 = esp_1300 - 0x0C;
			esp_1340->tFFFFFFFC = &esp_1340->dw0010 + 23;
			esp_1340->dwFFFFFFF8 = 0x00;
			esp_1340->ptrFFFFFFF4 = (word32) ebx_1292 - 105991;
			esp_1340->dwFFFFFFF0 = esp_1340->dw0010;
			esp_1340->tFFFFFFEC = edi_1127;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg16 = <invalid>;
			Eq_2 stackArg20 = <invalid>;
			Eq_2 eax_1362 = _nl_find_msg(edi_1127, gs, stackArg4, dwArg04, dwArg08, stackArg16, stackArg20);
			esp_1156 = (struct Eq_5330 *) (&esp_1340->ptr0004 + 2);
			if (eax_1362 != ~0x00)
			{
				esp_1340->ptr0004 = (word32) ebp + 100;
				esp_1340->ptr0000 = (word32) ebp + 96;
				esp_1340->tFFFFFFFC = eax_1362;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				__gettext_extract_plural(gs, stackArg4, dwArg04, dwArg08, out ecx_100, out edx_1456);
				eax_1464 = *((word32) ebx_1292 + 5576) - 0x01;
				goto l0804C6B0;
			}
			eax_1157 = *((word32) ebp + 16);
l0804C751:
			struct Eq_6556 * esp_1387 = esp_1156 - 0x0C;
			esp_1387->tFFFFFFFC = eax_1157;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 edx_4033;
			word32 ecx_4032;
			free(gs, stackArg0, stackArg4, out ecx_4032, out edx_4033);
			if (esp_1387->dw0020 == 0x00)
			{
				esp_1387->t0000 = esp_1387->t0018;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_4038;
				word32 edx_4039;
				free(gs, stackArg0, stackArg4, out ecx_4038, out edx_4039);
			}
			else
			{
				esp_1387->t0004 = esp_1387->t0024;
				esp_1387->t0000 = esp_1387->t0018;
				word32 ecx_4034;
				word32 edx_4035;
				__munmap(ebx_1292, gs, esp_1387->t0000, esp_1387->t0004, out ecx_4034, out edx_4035, out ebx_1292);
			}
			esp_1156->tFFFFFFF8 = ebp;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			free(gs, stackArg0, stackArg4, out ecx_100, out edx_1456);
			word32 eax_1461 = *((word32) ebx_1292 + 5576);
			((word32) edi_1127 + 8)->u0 = 0x00;
			eax_1464 = eax_1461 - 0x01;
			goto l0804C6B0;
		}
l0804D0D9:
		word32 esi_1625 = 0x00;
		word32 edi_1628 = esp_1251->ptr0044->dw000C;
		while (true)
		{
			union Eq_2 * eax_1634 = esp_1251->ptr0018;
			if (esi_1625 == 0x00)
				eax_1634 = esp_1251->ptr000C;
			struct Eq_6746 * edx_1646;
			int8 al_1649;
			Eq_2 edx_1639 = *eax_1634;
			if (edi_1628 != 0x00)
			{
				edx_1646 = (word32) __bswap(edx_1639) + esp_1251->dw0008;
				al_1649 = (int8) (edx_1646->dw0008 != ~0x00);
			}
			else
			{
				edx_1646 = (word32) edx_1639 + esp_1251->dw0008;
				al_1649 = (int8) (edx_1646->dw0008 != ~0x00);
			}
			if (al_1649 != 0x00)
			{
				struct Eq_6863 * edx_1660 = (char *) edx_1646 + 4 + 4;
				while (true)
				{
					Eq_2 eax_1664 = edx_1660->dw0000;
					Eq_2 ecx_1669 = __bswap(eax_1664);
					if (edi_1628 != 0x00)
						eax_1664 = ecx_1669;
					if (eax_1664 == ~0x00)
						break;
					if (*((word32) ebp_1276 + eax_1664 * 0x04) == 0x00)
						goto l0804D290;
					++edx_1660;
				}
			}
			if (esi_1625 == 0x01)
				break;
			esi_1625 = 0x01;
		}
		ui32 eax_1699 = esp_1251->dw003C;
		word32 esi_1700 = esp_1251->dw0024;
		esp_1251->t0020 = ebp_1276;
		esp_1251->dw0038 = 0x00;
		ebp = esp_1251->t0034;
		Eq_2 eax_1716 = (eax_1699 << 0x03) + esp_1251->dw0048;
		esp_1251->t004C = esi_1700 + (eax_1699 << 0x03);
		esp_1251->t0050 = eax_1716;
		ecx_1573 = edi_1628;
		if (edi_1628 == 0x00)
		{
l0804D1A7:
			if (esp_1251->dw0038 != 0x00)
			{
				word32 eax_1893 = esp_1251->dw0008;
				esi_1581 = (struct Eq_5325 *) ((char *) *esp_1251->ptr0018 + eax_1893);
				esp_1251->t0030 = (word32) esi_1581->t0000 + eax_1893;
				esp_1251->t0034 = esp_1251->t0050;
			}
			else
			{
				word32 eax_1884 = esp_1251->dw0008;
				esi_1581 = (struct Eq_5325 *) ((char *) *esp_1251->ptr000C + eax_1884);
				esp_1251->t0030 = (word32) esi_1581->t0000 + eax_1884;
				esp_1251->t0034 = esp_1251->t004C;
			}
			eax_1593 = esi_1581->t0004;
			if (esi_1581->dw0008 != ~0x00)
			{
l0804D1D5:
				Eq_2 eax_1910 = esp_1251->t0034;
				esp_1251->dw0054 = ecx_1573;
				*((word32) eax_1910 + 4) = ebp;
				struct Eq_5870 * esi_1912 = &esi_1581->t0004;
				while (true)
				{
					Eq_2 ecx_1932 = esi_1912->dw0000;
					Eq_2 edi_1933 = esi_1912->dw0004;
					if (esp_1251->dw0054 != 0x00)
					{
						ecx_1932 = __bswap(ecx_1932);
						edi_1933 = __bswap(edi_1933);
					}
					if (ecx_1932 != 0x00)
					{
						struct Eq_6154 * esp_1944 = esp_1251 - 0x04;
						esp_1944->tFFFFFFFC = ecx_1932;
						esp_1944->t0030 = ecx_1932;
						esp_1944->tFFFFFFF8 = esp_1944->t0034;
						esp_1944->tFFFFFFF4 = ebp;
						word32 edx_4025;
						word32 ecx_4024;
						memcpy(esp_1944->tFFFFFFF4, esp_1944->tFFFFFFF8, esp_1944->tFFFFFFFC, out ecx_4024, out edx_4025);
						Eq_2 ecx_1964 = esp_1944->t0030;
						Mem1966[esp_1944 + 0x34:word32] = Mem1955[esp_1944 + 0x34:word32] + ecx_1964;
						ebp += ecx_1964;
					}
					if (edi_1933 == ~0x00)
						break;
					struct Eq_6210 * esp_1984 = esp_1251 - 0x0C;
					Eq_2 ecx_1989 = *((word32) esp_1251->t0020 + edi_1933 * 0x04);
					esp_1984->tFFFFFFFC = ecx_1989;
					esp_1984->t0038 = ecx_1989;
					word32 ecx_4026;
					word32 edx_4027;
					Eq_2 eax_1993 = strlen(esp_1984->tFFFFFFFC, out ecx_4026, out edx_4027);
					esp_1984->t0004 = eax_1993;
					esp_1984->t0000 = esp_1984->t0038;
					esp_1984->tFFFFFFFC = ebp;
					word32 ecx_4028;
					word32 edx_4029;
					memcpy(esp_1984->tFFFFFFFC, esp_1984->t0000, esp_1984->t0004, out ecx_4028, out edx_4029);
					++esi_1912;
					ebp += eax_1993;
				}
				Eq_2 esi_1977 = esp_1251->t0034;
				*esi_1977 = ebp - *((word32) esi_1977 + 4);
				goto l0804D189;
			}
			goto l0804D17A;
		}
l0804D144:
		if (esp_1251->dw0038 != 0x00)
		{
			word32 edi_1868 = esp_1251->dw0008;
			esi_1581 = (word32) __bswap(*esp_1251->ptr0018) + edi_1868;
			esp_1251->t0030 = (word32) __bswap(esi_1581->t0000) + edi_1868;
			esp_1251->t0034 = esp_1251->t0050;
			goto l0804D16F;
		}
		goto l0804D3F2;
	}
	edx_1456 = *dwArg04;
	((word32) dwArg04 + 4)->u0 = ~0x00;
	((word32) dwArg04 + 8)->u0 = 0x00;
	if (edx_1456 == 0x00)
	{
l0804C6B0:
		((word32) edi_1127 + 4)->u0 = 0x01;
		goto l0804C6B7;
	}
	Eq_2 eax_79 = __open_nocancel(gs, edx_1456, 0x00, dwLocF4, out ecx_100, out edx_1456);
	if (eax_79 == ~0x00)
	{
l0804C7A0:
		edi_1127 = dwArg04;
		eax_1464 = g_dw80CF5C8 - 0x01;
		goto l0804C6B0;
	}
	else
	{
		word32 edx_4002;
		Eq_2 eax_99 = __fxstat64(gs, eax_79, fp - 0x88, out ecx_100, out edx_4002);
		Eq_2 dwLocDC_2135 = eax_99;
		if (eax_99 == 0x00 && (dwLoc58 == 0x00 && dwLoc5C > 0x2F))
		{
			word32 dwLocE0_2172;
			word32 esi_249;
			word32 edx_4004;
			word32 ecx_4003;
			Eq_2 eax_133 = mmap(gs, 0x00, dwLoc5C, 0x01, 0x02, eax_79, 0x00, out ecx_4003, out edx_4004);
			Eq_2 dwLocE4_2151 = eax_133;
			ebp = eax_133;
			if (eax_133 != ~0x00)
			{
				word32 edx_4011;
				word24 eax_24_8_286 = SLICE(__close_nocancel(gs, eax_79, out edx_4011), word24, 8);
				word32 ecx_280 = *eax_133;
				int8 al_285 = (int8) (ecx_280 != 2500072158);
				dwLocE0_2172 = ecx_280;
				esi_249 = SEQ(eax_24_8_286, al_285);
				if (ecx_280 != 3725722773 && al_285 != 0x00)
				{
					__munmap(0x080CE000, gs, eax_133, dwLoc5C, out ecx_100, out edx_1456, out ebx_1292);
					eax_1464 = *((word32) ebx_1292 + 5576) - 0x01;
					goto l0804C6B0;
				}
				dwLocDC_2135.u0 = 0x01;
l0804C57A:
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ebx_4059;
				word32 ebp_4060;
				word32 esi_4061;
				word32 edi_4062;
				Eq_2 eax_335 = __libc_malloc(gs, stackArg0, 0x68, out ecx_100, out edx_1456, out ebx_4059, out ebp_4060, out esi_4061, out edi_4062);
				edi_1127 = dwArg04;
				esp_1300 = fp - 0xEC;
				ebp = eax_335;
				if (eax_335 != 0x00)
				{
					Eq_2 dwLocC4_2205;
					Eq_2 edx_380;
					*((word32) dwArg04 + 8) = eax_335;
					*eax_335 = dwLocE4_2151;
					((word32) eax_335 + 16)->u0 = 0x00;
					*((word32) eax_335 + 4) = dwLocDC_2135;
					*((word32) eax_335 + 8) = dwLoc5C;
					Eq_2 eax_360 = *((word32) dwLocE4_2151 + 4);
					Eq_2 esi_359 = (word32) (byte) esi_249;
					*((word32) eax_335 + 0x0C) = esi_359;
					word16 ax_406 = (word16) eax_360;
					if (dwLocE0_2172 != 2500072158)
					{
						Eq_2 eax_381 = __bswap(eax_360);
						ax_406 = (word16) eax_381;
						if (eax_381 > 0x0001FFFF)
							goto l0804C74F;
						*((word32) eax_335 + 20) = __bswap(*((word32) dwLocE4_2151 + 8));
						Mem391[eax_335 + 0x18:word32] = __bswap(*((word32) dwLocE4_2151 + 0x0C)) + dwLocE4_2151;
						Mem395[eax_335 + 0x1C:word32] = __bswap(*((word32) dwLocE4_2151 + 16)) + dwLocE4_2151;
						Eq_2 edx_397 = __bswap(*((word32) dwLocE4_2151 + 20));
						*((word32) eax_335 + 44) = edx_397;
						dwLocC4_2205 = edx_397;
						if (edx_397 > 0x02)
						{
							edx_380 = __bswap(*((word32) dwLocE4_2151 + 24));
							goto l0804C7E4;
						}
					}
					else
					{
						if (eax_360 > 0x0001FFFF)
							goto l0804C74F;
						*((word32) eax_335 + 20) = *((word32) dwLocE4_2151 + 8);
						Mem370[eax_335 + 0x18:word32] = Mem367[dwLocE4_2151 + 0x0C:word32] + dwLocE4_2151;
						Eq_2 ecx_373 = *((word32) dwLocE4_2151 + 20);
						Mem374[eax_335 + 0x1C:word32] = Mem370[dwLocE4_2151 + 0x10:word32] + dwLocE4_2151;
						*((word32) eax_335 + 44) = ecx_373;
						dwLocC4_2205 = ecx_373;
						if (ecx_373 > 0x02)
						{
							edx_380 = *((word32) dwLocE4_2151 + 24);
l0804C7E4:
							*((word32) eax_335 + 52) = esi_359;
							word32 edx_422 = edx_380 + dwLocE4_2151;
							*((word32) eax_335 + 48) = edx_422;
							if (ax_406 != 0x00)
							{
								if (edx_422 == 0x00)
								{
l0804C74F:
									edi_1127 = dwArg04;
									ebp = eax_335;
									esp_1156 = fp - 0xEC;
									eax_1157.u0 = 0x00;
									goto l0804C751;
								}
								Eq_2 dwLocD4_2210;
								Eq_2 eax_441;
								Eq_2 eax_431 = *((word32) dwLocE4_2151 + 36);
								Eq_2 dwLocC8_2209 = eax_431;
								if (dwLocE0_2172 != 2500072158)
								{
									Eq_2 eax_443 = __bswap(eax_431);
									dwLocC8_2209 = eax_443;
									if (eax_443 != 0x00)
									{
										dwLocD4_2210 = __bswap(*((word32) dwLocE4_2151 + 28));
										eax_441 = __bswap(*((word32) dwLocE4_2151 + 32));
										goto l0804C836;
									}
								}
								else if (eax_431 != 0x00)
								{
									eax_441 = *((word32) dwLocE4_2151 + 32);
									dwLocD4_2210 = *((word32) dwLocE4_2151 + 28);
l0804C836:
									Eq_153906 eax_461[] = eax_441 + dwLocE4_2151;
									word32 ebp_4049;
									word32 esi_4050;
									word32 edi_4051;
									word32 edx_4047;
									word32 ebx_4048;
									word32 ecx_4046;
									Eq_2 eax_481 = __libc_calloc(gs, dwLocD4_2210, 0x04, out ecx_4046, out edx_4047, out ebx_4048, out ebp_4049, out esi_4050, out edi_4051);
									if (eax_481 != 0x00)
									{
										Eq_2 esi_1001 = 0x00;
										if (dwLocD4_2210 != 0x00)
										{
											do
											{
												Eq_2 edi_504 = eax_461[esi_1001].t0004;
												Eq_2 edx_505 = eax_461[esi_1001].t0000;
												word32 eax_507 = dwLocE4_2151 + edi_504;
												if (dwLocE0_2172 != 2500072158)
												{
													eax_507 = dwLocE4_2151 + __bswap(edi_504);
													edx_505 = __bswap(edx_505);
												}
												if (edx_505 == 0x00 || *((word32) edx_505 + (eax_507 - 0x01)) != 0x00)
												{
l0804CAD8:
													// Failed to bind call argument.
													// Please report this issue at https://github.com/uxmal/reko
													Eq_2 stackArg0 = <invalid>;
													word32 edx_4056;
													word32 ecx_4055;
													free(gs, stackArg0, eax_481, out ecx_4055, out edx_4056);
													edi_1127 = dwArg04;
													ebp = eax_335;
													esp_1156 = fp - 232;
													eax_1157.u0 = 0x00;
													goto l0804C751;
												}
												Eq_2 edx_531;
												byte dl_526 = eax_507->b0000;
												if (dl_526 == 0x50)
												{
													edx_531.u0 = 0x00;
													if (eax_507->b0001 == 0x52 && eax_507->b0002 == 0x49)
													{
														Eq_2 edi_543 = (word32) eax_507->b0003;
														byte cl_545 = (byte) edi_543;
														byte cl_557 = (byte) edi_543;
														byte cl_554 = (byte) (word32) (int8) (cl_545 == 100) | (int8) (cl_545 == 0x69);
														byte cl_567 = (byte) (word32) (int8) (cl_557 == 117) | (int8) (cl_557 == 111) | cl_554;
														if ((byte) (edi_543 & ~0x20) == 88 || cl_567 != 0x00)
														{
															byte dl_579 = eax_507->b0004;
															if (dl_579 != 0x38)
															{
																if (dl_579 != 0x31)
																{
																	if (dl_579 == 0x33)
																	{
																		edx_531.u0 = 0x00;
																		if (eax_507->b0005 == 0x32 && eax_507->b0006 == 0x00)
																		{
																			byte al_974 = (byte) edi_543;
																			if (al_974 != 100)
																			{
																				if (cl_554 == 0x00)
																				{
																					if (al_974 != 111)
																					{
																						if (cl_567 == 0x00)
																						{
																							if (al_974 != 0x78)
																							{
																								if (al_974 != 88)
																								{
																									_nl_load_domain.cold.0();
																									return edi_543;
																								}
																								edx_531.u0 = 0x080B3BC4;
																							}
																							else
																								edx_531.u0 = 134888485;
																						}
																						else
																							edx_531.u0 = 0x080B40F6;
																					}
																					else
																						edx_531.u0 = 0x080A4130;
																				}
																				else
																					edx_531.u0 = 0x080A4E47;
																			}
																			else
																				edx_531.u0 = 0x080A4B4A;
																		}
																	}
																	else if (dl_579 == 0x36)
																	{
																		edx_531.u0 = 0x00;
																		if (eax_507->b0005 == 0x34 && eax_507->b0006 == 0x00)
																		{
																			byte al_949 = (byte) edi_543;
																			if (al_949 != 100)
																			{
																				if (cl_554 == 0x00)
																				{
																					if (al_949 != 111)
																					{
																						if (cl_567 == 0x00)
																						{
																							if (al_949 != 0x78)
																							{
																								if (al_949 != 88)
																								{
																									_nl_load_domain.cold.0();
																									return edi_543;
																								}
																								edx_531.u0 = 0x080A22ED;
																							}
																							else
																								edx_531.u0 = 134882033;
																						}
																						else
																							edx_531.u0 = 0x080A22E1;
																					}
																					else
																						edx_531.u0 = 0x080A22E5;
																				}
																				else
																					edx_531.u0 = 0x080A22DD;
																			}
																			else
																				edx_531.u0 = 0x080A22E9;
																		}
																	}
																	else if (dl_579 == 0x4C)
																	{
																		edx_531.u0 = 0x00;
																		if (eax_507->b0005 == 0x45 && (eax_507->b0006 == 0x41 && (eax_507->b0007 == 0x53 && eax_507->b0008 == 0x54)))
																		{
																			byte cl_836 = eax_507->b0009;
																			if (cl_836 != 0x38)
																			{
																				edx_531.u0 = 0x00;
																				if (cl_836 != 0x31)
																				{
																					if (cl_836 == 0x33)
																					{
																						if (eax_507->b000A == 0x32 && eax_507->b000B == 0x00)
																						{
																							byte al_924 = (byte) edi_543;
																							if (al_924 != 100)
																							{
																								if (cl_554 == 0x00)
																								{
																									if (al_924 != 111)
																									{
																										if (cl_567 == 0x00)
																										{
																											if (al_924 != 0x78)
																											{
																												if (al_924 != 88)
																												{
																													_nl_load_domain.cold.0();
																													return edi_543;
																												}
																												edx_531.u0 = 0x080B3BC4;
																											}
																											else
																												edx_531.u0 = 134888485;
																										}
																										else
																											edx_531.u0 = 0x080B40F6;
																									}
																									else
																										edx_531.u0 = 0x080A4130;
																								}
																								else
																									edx_531.u0 = 0x080A4E47;
																							}
																							else
																								edx_531.u0 = 0x080A4B4A;
																						}
																					}
																					else if (cl_836 == 0x36 && (eax_507->b000A == 0x34 && eax_507->b000B == 0x00))
																					{
																						byte al_900 = (byte) edi_543;
																						if (al_900 != 100)
																						{
																							if (cl_554 == 0x00)
																							{
																								if (al_900 != 111)
																								{
																									if (cl_567 == 0x00)
																									{
																										if (al_900 != 0x78)
																										{
																											if (al_900 != 88)
																											{
																												_nl_load_domain.cold.0();
																												return edi_543;
																											}
																											edx_531.u0 = 0x080A22ED;
																										}
																										else
																											edx_531.u0 = 134882033;
																									}
																									else
																										edx_531.u0 = 0x080A22E1;
																								}
																								else
																									edx_531.u0 = 0x080A22E5;
																							}
																							else
																								edx_531.u0 = 0x080A22DD;
																						}
																						else
																							edx_531.u0 = 0x080A22E9;
																					}
																				}
																				else if (eax_507->b000A == 0x36 && eax_507->b000B == 0x00)
																				{
																					byte al_872 = (byte) edi_543;
																					if (al_872 != 100)
																					{
																						if (cl_554 == 0x00)
																						{
																							if (al_872 != 111)
																							{
																								if (cl_567 == 0x00)
																								{
																									if (al_872 != 0x78)
																									{
																										if (al_872 != 88)
																										{
																											_nl_load_domain.cold.0();
																											return edi_543;
																										}
																										edx_531.u0 = 0x080B3BC4;
																									}
																									else
																										edx_531.u0 = 134888485;
																								}
																								else
																									edx_531.u0 = 0x080B40F6;
																							}
																							else
																								edx_531.u0 = 0x080A4130;
																						}
																						else
																							edx_531.u0 = 0x080A4E47;
																					}
																					else
																						edx_531.u0 = 0x080A4B4A;
																				}
																			}
																			else if (eax_507->b000A == 0x00)
																			{
																				byte al_845 = (byte) edi_543;
																				if (al_845 != 100)
																				{
																					if (cl_554 == 0x00)
																					{
																						if (al_845 != 111)
																						{
																							if (cl_567 == 0x00)
																							{
																								if (al_845 != 0x78)
																								{
																									if (al_845 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_543;
																									}
																									edx_531.u0 = 0x080B3BC4;
																								}
																								else
																									edx_531.u0 = 134888485;
																							}
																							else
																								edx_531.u0 = 0x080B40F6;
																						}
																						else
																							edx_531.u0 = 0x080A4130;
																					}
																					else
																						edx_531.u0 = 0x080A4E47;
																				}
																				else
																					edx_531.u0 = 0x080A4B4A;
																			}
																			else
																				edx_531.u0 = 0x00;
																		}
																	}
																	else if (dl_579 == 0x46)
																	{
																		edx_531.u0 = 0x00;
																		if (eax_507->b0005 == 0x41 && (eax_507->b0006 == 0x53 && eax_507->b0007 == 0x54))
																		{
																			byte cl_719 = eax_507->b0008;
																			if (cl_719 != 0x38)
																			{
																				edx_531.u0 = 0x00;
																				if (cl_719 != 0x31)
																				{
																					if (cl_719 == 0x33)
																					{
																						if (eax_507->b0009 == 0x32 && eax_507->b000A == 0x00)
																						{
																							byte al_807 = (byte) edi_543;
																							if (al_807 != 100)
																							{
																								if (cl_554 == 0x00)
																								{
																									if (al_807 != 111)
																									{
																										if (cl_567 == 0x00)
																										{
																											if (al_807 != 0x78)
																											{
																												if (al_807 != 88)
																												{
																													_nl_load_domain.cold.0();
																													return edi_543;
																												}
																												edx_531.u0 = 0x080B3BC4;
																											}
																											else
																												edx_531.u0 = 134888485;
																										}
																										else
																											edx_531.u0 = 0x080B40F6;
																									}
																									else
																										edx_531.u0 = 0x080A4130;
																								}
																								else
																									edx_531.u0 = 0x080A4E47;
																							}
																							else
																								edx_531.u0 = 0x080A4B4A;
																						}
																					}
																					else if (cl_719 == 0x36 && (eax_507->b0009 == 0x34 && eax_507->b000A == 0x00))
																					{
																						byte al_783 = (byte) edi_543;
																						if (al_783 != 100)
																						{
																							if (cl_554 == 0x00)
																							{
																								if (al_783 != 111)
																								{
																									if (cl_567 == 0x00)
																									{
																										if (al_783 != 0x78)
																										{
																											if (al_783 != 88)
																											{
																												_nl_load_domain.cold.0();
																												return edi_543;
																											}
																											edx_531.u0 = 0x080A22ED;
																										}
																										else
																											edx_531.u0 = 134882033;
																									}
																									else
																										edx_531.u0 = 0x080A22E1;
																								}
																								else
																									edx_531.u0 = 0x080A22E5;
																							}
																							else
																								edx_531.u0 = 0x080A22DD;
																						}
																						else
																							edx_531.u0 = 0x080A22E9;
																					}
																				}
																				else if (eax_507->b0009 == 0x36 && eax_507->b000A == 0x00)
																				{
																					byte al_755 = (byte) edi_543;
																					if (al_755 != 100)
																					{
																						if (cl_554 == 0x00)
																						{
																							if (al_755 != 111)
																							{
																								if (cl_567 == 0x00)
																								{
																									if (al_755 != 0x78)
																									{
																										if (al_755 != 88)
																										{
																											_nl_load_domain.cold.0();
																											return edi_543;
																										}
																										edx_531.u0 = 0x080B3BC4;
																									}
																									else
																										edx_531.u0 = 134888485;
																								}
																								else
																									edx_531.u0 = 0x080B40F6;
																							}
																							else
																								edx_531.u0 = 0x080A4130;
																						}
																						else
																							edx_531.u0 = 0x080A4E47;
																					}
																					else
																						edx_531.u0 = 0x080A4B4A;
																				}
																			}
																			else if (eax_507->b0009 == 0x00)
																			{
																				byte al_728 = (byte) edi_543;
																				if (al_728 != 100)
																				{
																					if (cl_554 == 0x00)
																					{
																						if (al_728 != 111)
																						{
																							if (cl_567 == 0x00)
																							{
																								if (al_728 != 0x78)
																								{
																									if (al_728 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_543;
																									}
																									edx_531.u0 = 0x080B3BC4;
																								}
																								else
																									edx_531.u0 = 134888485;
																							}
																							else
																								edx_531.u0 = 0x080B40F6;
																						}
																						else
																							edx_531.u0 = 0x080A4130;
																					}
																					else
																						edx_531.u0 = 0x080A4E47;
																				}
																				else
																					edx_531.u0 = 0x080A4B4A;
																			}
																			else
																				edx_531.u0 = 0x00;
																		}
																	}
																	else if (dl_579 == 77)
																	{
																		edx_531.u0 = 0x00;
																		if (eax_507->b0005 == 0x41 && eax_507->b0006 == 88)
																		{
																			if (eax_507->b0007 == 0x00)
																			{
																				byte al_692 = (byte) edi_543;
																				if (al_692 != 100)
																				{
																					if (cl_554 == 0x00)
																					{
																						if (al_692 != 111)
																						{
																							if (cl_567 == 0x00)
																							{
																								if (al_692 != 0x78)
																								{
																									if (al_692 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_543;
																									}
																									edx_531.u0 = 0x080A22ED;
																								}
																								else
																									edx_531.u0 = 134882033;
																							}
																							else
																								edx_531.u0 = 0x080A22E1;
																						}
																						else
																							edx_531.u0 = 0x080A22E5;
																					}
																					else
																						edx_531.u0 = 0x080A22DD;
																				}
																				else
																					edx_531.u0 = 0x080A22E9;
																			}
																			else
																				edx_531.u0 = 0x00;
																		}
																	}
																	else
																	{
																		edx_531.u0 = 0x00;
																		if (dl_579 == 0x50 && (eax_507->b0005 == 0x54 && eax_507->b0006 == 0x52))
																		{
																			if (eax_507->b0007 == 0x00)
																			{
																				byte al_662 = (byte) edi_543;
																				if (al_662 != 100)
																				{
																					if (cl_554 == 0x00)
																					{
																						if (al_662 != 111)
																						{
																							if (cl_567 == 0x00)
																							{
																								if (al_662 != 0x78)
																								{
																									if (al_662 != 88)
																									{
																										_nl_load_domain.cold.0();
																										return edi_543;
																									}
																									edx_531.u0 = 0x080B3BC4;
																								}
																								else
																									edx_531.u0 = 134888485;
																							}
																							else
																								edx_531.u0 = 0x080B40F6;
																						}
																						else
																							edx_531.u0 = 0x080A4130;
																					}
																					else
																						edx_531.u0 = 0x080A4E47;
																				}
																				else
																					edx_531.u0 = 0x080A4B4A;
																			}
																			else
																				edx_531.u0 = 0x00;
																		}
																	}
																}
																else
																{
																	edx_531.u0 = 0x00;
																	if (eax_507->b0005 == 0x36 && eax_507->b0006 == 0x00)
																	{
																		byte al_620 = (byte) edi_543;
																		if (al_620 != 100)
																		{
																			if (cl_554 == 0x00)
																			{
																				if (al_620 != 111)
																				{
																					if (cl_567 == 0x00)
																					{
																						if (al_620 != 0x78)
																						{
																							if (al_620 != 88)
																							{
																								_nl_load_domain.cold.0();
																								return edi_543;
																							}
																							edx_531.u0 = 0x080B3BC4;
																						}
																						else
																							edx_531.u0 = 134888485;
																					}
																					else
																						edx_531.u0 = 0x080B40F6;
																				}
																				else
																					edx_531.u0 = 0x080A4130;
																			}
																			else
																				edx_531.u0 = 0x080A4E47;
																		}
																		else
																			edx_531.u0 = 0x080A4B4A;
																	}
																}
															}
															else if (eax_507->b0005 == 0x00)
															{
																byte al_589 = (byte) edi_543;
																if (al_589 != 100)
																{
																	if (cl_554 == 0x00)
																	{
																		if (al_589 != 111)
																		{
																			if (cl_567 == 0x00)
																			{
																				if (al_589 != 0x78)
																				{
																					if (al_589 != 88)
																					{
																						_nl_load_domain.cold.0();
																						return edi_543;
																					}
																					edx_531.u0 = 0x080B3BC4;
																				}
																				else
																					edx_531.u0 = 134888485;
																			}
																			else
																				edx_531.u0 = 0x080B40F6;
																		}
																		else
																			edx_531.u0 = 0x080A4130;
																	}
																	else
																		edx_531.u0 = 0x080A4E47;
																}
																else
																	edx_531.u0 = 0x080A4B4A;
															}
															else
																edx_531.u0 = 0x00;
														}
													}
												}
												else if (dl_526 == 0x49)
												{
													edx_531.u0 = 0x00;
													if (eax_507->b0001 == 0x00)
														edx_531.u0 = 0x080A22F5;
												}
												else
													edx_531.u0 = 0x00;
												*((word32) eax_481 + esi_1001 * 0x04) = edx_531;
												esi_1001 = (word32) esi_1001 + 1;
											} while (esi_1001 != dwLocD4_2210);
										}
										Eq_2 dwLocBC_2273[];
										Eq_2 eax_1010 = *((word32) dwLocE4_2151 + 40);
										Eq_2 edx_1011 = *((word32) dwLocE4_2151 + 44);
										if (dwLocE0_2172 != 2500072158)
										{
											word32 eax_1017 = __bswap(eax_1010) + dwLocE4_2151;
											edx_1011 = __bswap(edx_1011);
											dwLocBC_2273 = eax_1017;
										}
										else
											dwLocBC_2273 = eax_1010 + dwLocE4_2151;
										Eq_2 edx_1025[] = edx_1011 + dwLocE4_2151;
										Eq_2 dwLocCC_2284 = 0x00;
										ui32 dwLocC4_2286 = 0x00;
										ui32 dwLocB8_2288 = dwLocC4_2205 << 0x02;
										do
										{
											ui32 ebp_1041 = 0x00;
											while (true)
											{
												struct Eq_5755 * edi_1061;
												int8 al_1064;
												if (dwLocE0_2172 != 2500072158)
												{
													Eq_2 edi_1070;
													if (ebp_1041 != 0x00)
														edi_1070 = edx_1025[dwLocCC_2284];
													else
														edi_1070 = dwLocBC_2273[dwLocCC_2284];
													edi_1061 = __bswap(edi_1070) + dwLocE4_2151;
													al_1064 = (int8) (edi_1061->dw0008 != ~0x00);
												}
												else
												{
													Eq_2 edi_1054;
													if (ebp_1041 != 0x00)
														edi_1054 = edx_1025[dwLocCC_2284];
													else
														edi_1054 = dwLocBC_2273[dwLocCC_2284];
													edi_1061 = edi_1054 + dwLocE4_2151;
													al_1064 = (int8) (edi_1061->dw0008 != ~0x00);
												}
												word32 esi_1082 = 0x00;
												if (al_1064 != 0x00)
												{
													struct Eq_5754 * edi_1093 = (char *) edi_1061 + 4;
													word32 eax_1094 = 0x00;
													while (true)
													{
														Eq_2 ecx_1100 = edi_1093->dw0000;
														Eq_2 edx_1103 = edi_1093->dw0004;
														esi_1082 = (word32) ecx_1100 + eax_1094;
														if (dwLocE0_2172 != 2500072158)
														{
															esi_1082 = (word32) __bswap(ecx_1100) + eax_1094;
															edx_1103 = __bswap(edx_1103);
														}
														if (edx_1103 == ~0x00)
															break;
														if (edx_1103 >= dwLocD4_2210)
															goto l0804CAD8;
														Eq_2 eax_1162 = *((word32) eax_481 + edx_1103 * 0x04);
														if (eax_1162 == 0x00)
															goto l0804CBF9;
														++edi_1093;
														word32 ecx_4052;
														word32 edx_4053;
														eax_1094 = (word32) strlen(eax_1162, out ecx_4052, out edx_4053) + esi_1082;
													}
												}
												(fp - 0x28)[ebp_1041] = esi_1082;
												if (ebp_1041 == 0x01)
													break;
												ebp_1041 = 0x01;
											}
											++dwLocC4_2286;
											dwLocB8_2288 += dwLoc24 + dwLoc28;
l0804CBF9:
											Eq_2 v21_1199 = (word32) dwLocCC_2284 + 1;
											esp_1197 = fp - 0xEC;
											dwLocCC_2284 = v21_1199;
										} while (v21_1199 != dwLocC8_2209);
										ebp = eax_335;
										edi_1127 = dwArg04;
										if (dwLocC4_2286 == 0x00)
										{
											((word32) eax_335 + 32)->u0 = 0x00;
											((word32) eax_335 + 36)->u0 = 0x00;
											((word32) eax_335 + 40)->u0 = 0x00;
											goto l0804CC31;
										}
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg0 = <invalid>;
										word32 ebx_4019;
										word32 ebp_4020;
										word32 esi_4021;
										word32 edi_4022;
										word32 edx_4018;
										word32 ecx_4017;
										Eq_2 eax_1246 = __libc_malloc(gs, stackArg0, (dwLocC4_2286 << 0x04) + dwLocB8_2288, out ecx_4017, out edx_4018, out ebx_4019, out ebp_4020, out esi_4021, out edi_4022);
										esp_1251 = fp - 0xEC;
										if (eax_1246 != 0x00)
										{
											*((word32) eax_335 + 16) = eax_1246;
											ebp_1276 = eax_481;
											goto l0804D0D9;
										}
									}
									goto l0804C74F;
								}
							}
l0804C62B:
							((word32) eax_335 + 32)->u0 = 0x00;
							((word32) eax_335 + 36)->u0 = 0x00;
							((word32) eax_335 + 40)->u0 = 0x00;
							goto l0804C640;
						}
					}
					((word32) eax_335 + 48)->u0 = 0x00;
					*((word32) eax_335 + 52) = esi_359;
					if (ax_406 != 0x00)
						goto l0804C74F;
					goto l0804C62B;
				}
				goto l0804C7A0;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_4006;
			word32 esi_4009;
			word32 edi_4010;
			word32 ebx_4007;
			word32 ebp_4008;
			Eq_2 eax_154 = __libc_malloc(gs, stackArg0, dwLoc5C, out ecx_100, out edx_4006, out ebx_4007, out ebp_4008, out esi_4009, out edi_4010);
			dwLocE4_2151 = eax_154;
			if (eax_154 != 0x00)
			{
				Eq_2 esi_167 = eax_154;
				ebp = dwLoc5C;
				do
				{
					Eq_2 eax_183 = __read_nocancel(gs, eax_79, esi_167, ebp, out ecx_100);
					if (eax_183 > 0x00)
					{
						esi_167 += eax_183;
						ebp -= eax_183;
						if (ebp != 0x00)
							continue;
						word32 edx_4057;
						__close_nocancel(gs, eax_79, out edx_4057);
						word32 ecx_241 = *eax_154;
						int8 al_246 = (int8) (ecx_241 != 2500072158);
						edi_1127 = dwArg04;
						dwLocE0_2172 = ecx_241;
						esi_249 = SEQ(SLICE(eax_154, word24, 8), al_246);
						if (ecx_241 == 3725722773 || al_246 == 0x00)
							goto l0804C57A;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						free(gs, stackArg0, eax_154, out ecx_100, out edx_1456);
						eax_1464 = g_dw80CF5C8 - 0x01;
						goto l0804C6B0;
					}
				} while (eax_183 == ~0x00 && gs->tFFFFFFE0 == 0x04);
			}
		}
		__close_nocancel(gs, eax_79, out edx_1456);
		edi_1127 = dwArg04;
		eax_1464 = g_dw80CF5C8 - 0x01;
		goto l0804C6B0;
	}
}

// 0804D970: void alias_compare(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_2) dwArg08)
void alias_compare(union Eq_2 * dwArg04, union Eq_2 * dwArg08)
{
	word32 ecx_37;
	__strcasecmp_l(*dwArg04, *dwArg08, 0x080CE0C0, out ecx_37);
}

// 0804D9A0: Register Eq_2 read_alias_file(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_expand_alias
Eq_2 read_alias_file(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs)
{
	struct Eq_7362 * esp_21 = fp - 0x01FC;
	ui32 ebx_25 = gs->dw0014;
	struct Eq_7362 * edi_30 = fp - 0x01FC - ((word32) edx + 41 & ~0x0FFF);
	ui32 ebx_31 = (word32) edx + 41 & ~0x0F;
	if (fp - 0x01FC != edi_30)
	{
		do
		{
			esp_21 -= 0x1000;
			esp_21->dw0FFC = esp_21->dw0FFC;
		} while (esp_21 != edi_30);
	}
	if ((ebx_31 & 0x0FFF) != 0x00)
	{
		esp_21 -= ebx_31 & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_21 - 0x04)[(ebx_31 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_21 - 0x04)[(ebx_31 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	Eq_2 dwLoc01D4_750;
	struct Eq_7408 * esp_59 = esp_21 - 0x04;
	esp_59->tFFFFFFFC = edx;
	esp_59->tFFFFFFF8 = eax;
	Eq_7417 esi_58 = (char *) &esp_21->dwFFFFFFF8 + 23;
	esp_59->tFFFFFFF4 = esi_58 & ~0x0F;
	word32 edx_1073;
	Eq_2 eax_82 = __mempcpy(esp_59->tFFFFFFF4, esp_59->tFFFFFFF8, esp_59->tFFFFFFFC, out edx_1073);
	*eax_82 = g_t80A2310;
	*((word32) eax_82 + 4) = g_t80A2314;
	*((word32) eax_82 + 8) = g_t80A2318;
	*((word32) eax_82 + 0x0C) = g_t80A231C;
	esp_59->tFFFFFFF8.u0 = 0x080A22F7;
	esp_59->tFFFFFFF4 = esi_58 & ~0x0F;
	Eq_2 eax_116 = __new_fopen();
	if (eax_116 != 0x00)
	{
		ui32 eax_126 = *eax_116;
		*eax_116 = SEQ(SLICE(eax_126, word16, 16), SLICE(eax_126, byte, 8) | 0x80, (byte) eax_126);
		dwLoc01D4_750.u0 = 0x00;
		if (((byte) eax_126 & 0x10) == 0x00)
		{
			do
			{
				struct Eq_7515 * esp_159 = esp_21 - 0x04;
				esp_159->tFFFFFFFC = eax_116;
				esp_159->tFFFFFFF8.u0 = 400;
				esp_159->tFFFFFFF4 = fp - 0x01B0;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 stackArg12 = <invalid>;
				word32 edx_1081;
				if (fgets_unlocked(gs, stackArg4, stackArg8, stackArg12, out edx_1081) == 0x00)
					break;
				Eq_2 esi_204;
				esp_159->tFFFFFFF8.u0 = 0x0A;
				esp_159->tFFFFFFF4 = fp - 0x01B0;
				ui32 ecx_195 = (word32) bLoc01B0;
				word32 edx_1077;
				word32 ecx_1076;
				Eq_2 eax_188 = strchr(esp_159->tFFFFFFF4, esp_159->tFFFFFFF8, out ecx_1076, out edx_1077);
				byte dl_215 = (byte) ecx_195;
				Eq_153925 eax_200[] = gs->ptrFFFFFFF8;
				if ((eax_200[ecx_195].b0001 & 0x20) != 0x00)
				{
					esi_204 = fp - 0x01B0;
					do
					{
						esi_204 = (word32) esi_204 + 1;
						ui32 ecx_209 = (word32) *esi_204;
						dl_215 = (byte) ecx_209;
					} while ((eax_200[ecx_209].b0001 & 0x20) != 0x00);
				}
				else
					esi_204 = fp - 0x01B0;
				if (dl_215 != 0x00 && dl_215 != 0x23)
				{
					Eq_2 edi_224 = (word32) esi_204 + 1;
					ui32 ecx_226 = (word32) *((word32) esi_204 + 1);
					while (true)
					{
						byte dl_267;
						cui16 cx_232 = eax_200[ecx_226].w0000;
						if ((byte) ecx_226 == 0x00)
							break;
						if ((cx_232 & 0x2000) != 0x00)
						{
							ui32 ecx_244 = (word32) *((word32) edi_224 + 1);
							*edi_224 = 0x00;
							edi_224 = (word32) edi_224 + 1;
							dl_267 = (byte) ecx_244;
							if ((eax_200[ecx_244].b0001 & 0x20) == 0x00)
								goto l0804DBDF;
							goto l0804DBD0;
						}
						edi_224 = (word32) edi_224 + 1;
						ecx_226 = (word32) *edi_224;
					}
					if ((cx_232 & 0x2000) == 0x00)
						goto l0804DB0C;
l0804DBD0:
					do
					{
						edi_224 = (word32) edi_224 + 1;
						ui32 ecx_261 = (word32) *edi_224;
						dl_267 = (byte) ecx_261;
					} while ((eax_200[ecx_261].b0001 & 0x20) != 0x00);
l0804DBDF:
					if (dl_267 == 0x00)
						goto l0804DB0C;
					byte dl_277 = *((word32) edi_224 + 1);
					byte * ecx_276 = (word32) edi_224 + 1;
					while (dl_277 != 0x00)
					{
						if ((eax_200[(word32) dl_277].b0001 & 0x20) != 0x00)
						{
							if (dl_277 == 0x0A)
								*ecx_276 = (byte) 0x0A00;
							else
								*ecx_276 = 0x00;
							break;
						}
						++ecx_276;
						dl_277 = *ecx_276;
					}
					uint32 ebx_310 = nmap;
					uint32 eax_311 = maxmap;
					if (ebx_310 >= eax_311)
					{
						Eq_2 eax_319;
						uint32 edx_318;
						if (eax_311 == 0x00)
						{
							eax_319.u0 = 800;
							edx_318 = 100;
						}
						else
						{
							edx_318 = eax_311 * 0x02;
							eax_319 = eax_311 << 0x04;
						}
						esp_159->tFFFFFFF8 = eax_319;
						esp_159->tFFFFFFF4 = map;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						Eq_2 stackArg8 = <invalid>;
						word32 edi_1102;
						word32 edx_1099;
						word32 esi_1101;
						word32 ebp_1100;
						Eq_2 eax_370 = __realloc(gs, stackArg0, stackArg4, stackArg8, out edx_1099, out ebp_1100, out esi_1101, out edi_1102);
						if (eax_370 == 0x00)
							break;
						map = eax_370;
						maxmap = edx_318;
					}
					Eq_2 ebx_459;
					struct Eq_7767 * esp_381 = esp_21 - 0x0C;
					esp_381->tFFFFFFFC = esi_204;
					word32 ecx_1092;
					word32 edx_1093;
					Eq_2 eax_386 = strlen(esp_381->tFFFFFFFC, out ecx_1092, out edx_1093);
					esp_381->tFFFFFFFC = edi_224;
					word32 ecx_1094;
					word32 edx_1095;
					Eq_2 eax_399 = strlen(esp_381->tFFFFFFFC, out ecx_1094, out edx_1095);
					up32 ebx_410 = string_space_act;
					word32 ebx_412 = ebx_410 + ((word32) eax_386 + 1);
					up32 ebx_414 = ebx_412 + ((word32) eax_399 + 1);
					up32 eax_416 = string_space_max;
					Eq_2 edx_418 = string_space;
					if (ebx_414 <= eax_416)
						ebx_459 = map;
					else
					{
						up32 ecx_422 = (word32) eax_386 + 1 + ((word32) eax_399 + 1);
						if (ecx_422 < 0x0400)
							ecx_422 = 0x0400;
						up32 eax_435 = eax_416 + ecx_422;
						esp_381->dw0000 = eax_435;
						esp_381->tFFFFFFFC = edx_418;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						Eq_2 stackArg8 = <invalid>;
						word32 edx_1106;
						word32 edi_1109;
						word32 ebp_1107;
						word32 esi_1108;
						Eq_2 eax_451 = __realloc(gs, stackArg0, stackArg4, stackArg8, out edx_1106, out ebp_1107, out esi_1108, out edi_1109);
						if (eax_451 == 0x00)
							break;
						ebx_459 = map;
						if (eax_451 != edx_418 && ebx_310 != 0x00)
						{
							word32 ecx_467 = eax_451 - edx_418;
							Eq_2 edx_469 = ebx_459;
							Eq_2 ecx_472 = (word32) ebx_459 + ebx_310 * 0x08;
							do
							{
								*edx_469 = (word32) *edx_469 + ecx_467;
								*((word32) edx_469 + 4) = (word32) *((word32) edx_469 + 4) + ecx_467;
								edx_469 = (word32) edx_469 + 8;
							} while (ecx_472 != edx_469);
						}
						string_space = eax_451;
						string_space_max = eax_435;
						edx_418 = eax_451;
					}
					struct Eq_7907 * esp_502 = esp_21 - 0x04;
					esp_502->tFFFFFFFC = (word32) eax_386 + 1;
					esp_502->tFFFFFFF8 = esi_204;
					esp_502->tFFFFFFF4 = (word32) edx_418 + ebx_410;
					struct Eq_7921 * ebx_519 = (word32) ebx_459 + ebx_310 * 0x08;
					word32 ecx_1110;
					word32 edx_1111;
					ebx_519->t0000 = memcpy(esp_502->tFFFFFFF4, esp_502->tFFFFFFF8, esp_502->tFFFFFFFC, out ecx_1110, out edx_1111);
					esp_502->tFFFFFFFC = (word32) eax_399 + 1;
					esp_502->tFFFFFFF8 = edi_224;
					esp_502->tFFFFFFF4 = (word32) edx_418 + ebx_412;
					word32 ecx_1112;
					word32 edx_1113;
					ebx_519->t0004 = memcpy(esp_502->tFFFFFFF4, esp_502->tFFFFFFF8, esp_502->tFFFFFFFC, out ecx_1112, out edx_1113);
					string_space_act = ebx_414;
					nmap = ebx_310 + 0x01;
					dwLoc01D4_750 = (word64) dwLoc01D4_750.u0 + 1;
					if (eax_188 == 0x00)
						goto l0804DD40;
				}
				else
				{
l0804DB0C:
					if (eax_188 == 0x00)
					{
l0804DD40:
						do
						{
							esp_21->dwFFFFFFF8 = (word32) eax_116;
							esp_21->dwFFFFFFF4 = 400;
							esp_21->dwFFFFFFF0 = fp - 0x01B0;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							Eq_2 stackArg8 = <invalid>;
							Eq_2 stackArg12 = <invalid>;
							word32 edx_1087;
							if (fgets_unlocked(gs, stackArg4, stackArg8, stackArg12, out edx_1087) == 0x00)
								break;
							esp_21->dwFFFFFFF4 = 0x0A;
							esp_21->dwFFFFFFF0 = fp - 0x01B0;
							word32 ecx_1090;
							word32 edx_1091;
						} while (strchr(esp_21->dwFFFFFFF0, esp_21->dwFFFFFFF4, out ecx_1090, out edx_1091) == 0x00);
					}
				}
			} while ((*eax_116 & 0x10) == 0x00);
			struct Eq_7502 * esp_634 = esp_21 - 0x0C;
			esp_634->tFFFFFFFC = eax_116;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			__new_fclose(gs, stackArg4);
			if (dwLoc01D4_750 != 0x00)
			{
				esp_634->ptr0008 = 134535536;
				esp_634->dw0004 = 0x08;
				esp_634->dw0000 = nmap;
				esp_634->tFFFFFFFC = map;
				qsort();
			}
		}
		else
		{
			esp_59->tFFFFFFF4 = eax_116;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			__new_fclose(gs, stackArg4);
		}
	}
	else
		dwLoc01D4_750.u0 = 0x00;
	if ((ebx_25 ^ gs->dw0014) == 0x00)
		return dwLoc01D4_750;
	word32 edx_1083;
	word32 ecx_1082;
	__stack_chk_fail(out ecx_1082, out edx_1083);
	word32 ebp_1089;
	word32 ebx_1088;
	return _nl_expand_alias(gs, out ebx_1088, out ebp_1089);
}

// 0804DF20: Register Eq_2 _nl_expand_alias(Register (ptr32 Eq_9) gs, Register out ptr32 ebxOut, Register out (ptr32 Eq_5046) ebpOut)
// Called from:
//      _nl_find_domain
//      read_alias_file
//      _nl_find_locale
Eq_2 _nl_expand_alias(struct Eq_9 * gs, ptr32 & ebxOut, struct Eq_5046 & ebpOut)
{
	struct Eq_8034 * esp_158 = fp - 44;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_30;
	if (!__cmpxchg(lock, 0x01, 0x00, out eax_30))
		__lll_lock_wait_private(eax_30, 0x080CF5E4, gs);
	if (locale_alias_path.10080 == 0x00)
		locale_alias_path.10080 = 0x080A22FB;
	Eq_2 edx_192;
	Eq_2 ecx_181;
	struct Eq_8064 * eax_146 = &g_t80CE000;
	uint32 esi_147 = nmap;
	if (esi_147 != 0x00)
	{
l0804E057:
		word32 edi_153 = eax_146->dw1FE0;
		esp_158[3] = (struct Eq_8034) (eax_146 - 0xC0);
		esp_158[2] = (struct Eq_8034) edi_153;
		uint32 ebp_155 = 0x00;
		do
		{
			struct Eq_8160 * esp_167 = esp_158 - 0x04;
			word32 eax_163 = esp_158[2];
			esp_167->tFFFFFFFC = esp_167->t0010;
			uint32 ebx_166 = esi_147 + ebp_155;
			struct Eq_8175 * edi_173 = eax_163 + (ebx_166 >> 0x01) * 0x08;
			esp_167->tFFFFFFF8 = edi_173->t0000;
			esp_167->tFFFFFFF4 = esp_167->t0034;
			int32 eax_180 = __strcasecmp_l(esp_167->tFFFFFFF4, esp_167->tFFFFFFF8, esp_167->tFFFFFFFC, out ecx_181);
			esp_158 = (struct Eq_8034 *) ((char *) &esp_167->tFFFFFFFC + 8);
			if (eax_180 < 0x00)
				esi_147 = ebx_166 >> 0x01;
			else
			{
				if (eax_180 == 0x00)
				{
					edx_192 = edi_173->t0004;
					goto l0804DFF1;
				}
				ebp_155 = (ebx_166 >> 0x01) + 0x01;
			}
		} while (esi_147 > ebp_155);
	}
l0804DF81:
	struct Eq_8085 * edx_199 = *((word32) esp_158[1].dw000C + 5572);
	byte cl_207 = 0x00;
	byte al_203 = edx_199->b0000;
	while (al_203 != 0x00)
	{
		struct Eq_8085 * eax_75;
		struct Eq_8085 * ecx_71 = edx_199 + 1;
		if (al_203 == 0x3A)
		{
			do
			{
				ecx_71 = ecx_398 + 1;
				eax_75 = ecx_398;
				byte dl_83 = ecx_71->bFFFFFFFF;
				ecx_398 = ecx_71;
			} while (dl_83 == 0x3A);
			if (dl_83 != 0x00)
				goto l0804DFBA;
			edx_199 = ecx_398;
		}
		else
		{
			eax_75 = edx_199;
l0804DFBA:
			struct Eq_8085 * ecx_91 = eax_75 + 1;
			do
			{
				byte bl_100 = ecx_399->b0000;
				edx_199 = ecx_399;
				ecx_91 = ecx_399 + 1;
				if (bl_100 == 0x00)
					break;
				ecx_399 = ecx_91;
			} while (bl_100 != 0x3A);
			if (ecx_399 > eax_75)
			{
				*((word32) esp_158[1].dw000C + 5572) = (struct Eq_8034) ecx_399;
				if (read_alias_file(eax, ecx_399 - eax_75, gs) == 0x00)
					goto l0804DF81;
				eax_146 = (struct Eq_8064 *) esp_158[1];
				esi_147 = eax_146->dw15D8;
				if (esi_147 != 0x00)
					goto l0804E057;
				goto l0804DF81;
			}
		}
		al_203 = edx_199->b0000;
		cl_207 = 0x01;
	}
	ecx_181 = (uint32) cl_207;
	if (cl_207 != 0x00)
		*((word32) esp_158[1].dw000C + 5572) = (struct Eq_8034) edx_199;
	edx_192.u0 = 0x00;
l0804DFF1:
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v24_241 = lock - 0x01;
	lock = v24_241;
	if (v24_241 != 0x00)
		__lll_unlock_wake_private(0x080CF5E4, ecx_181, edx_192, gs);
	ebxOut = ebx;
	ebpOut = ebp;
	return edx_192;
}

// 0804E0D0: Register Eq_2 _nl_make_l10nflist(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Stack Eq_2 dwArg28, Stack Eq_2 dwArg2C, Register out Eq_5014 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_domain
//      _nl_make_l10nflist
//      _nl_find_locale
Eq_2 _nl_make_l10nflist(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, Eq_2 dwArg28, Eq_2 dwArg2C, union Eq_5014 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & ediOut)
{
_nl_make_l10nflist_entry:
	def fp
	def ebp
	def edi
	def esi
	def ebx
	def dwArg14
	def dwArg10
	def dwArg0C
	def dwArg18
	def dwArg1C
	def dwArg20
	def dwArg24
	def dwArg28
	def dwArg08
	def dwArg04
	def dwArg2C
	def dwArg00
	def gs
	eax_24 = strlen(dwArg14, out ecx_1514, out edx_1515)
	branch (dwArg10 & 0x04) == 0x00 l0804E438
	goto l0804E10B
l0804E0D0:
l0804E10B:
	eax_48 = strlen(dwArg18, out ecx_1516, out edx_1517)
	ebx_57 = (word32) eax_48 + 1
l0804E11D:
	ebx_90 = PHI((ebx_57, l0804E10B), (ebx_40, l0804E438))
	edi_63 = (word32) eax_24 + ((word32) dwArg0C + 2)
	ebp_64 = 0x00
	branch (dwArg10 & 0x02) == 0x00 l0804E140
l0804E12E:
	eax_75 = strlen(dwArg1C, out ecx_1518, out edx_1519)
	ebp_84 = (word32) eax_75 + 1
l0804E140:
	ebp_118 = PHI((ebp_84, l0804E12E), (ebp_64, l0804E11D))
	edi_91 = edi_63 + ebx_90
	ebx_92 = 0x00
	branch (dwArg10 & 0x01) == 0x00 l0804E163
l0804E151:
	eax_103 = strlen(dwArg20, out ecx_1520, out edx_1521)
	ebx_112 = (word32) eax_103 + 1
l0804E163:
	ebx_144 = PHI((ebx_92, l0804E140), (ebx_112, l0804E151))
	edi_119 = edi_91 + ebp_118
	ebp_120 = 0x00
	branch (dwArg10 & 0x08) == 0x00 l0804E186
l0804E174:
	eax_131 = strlen(dwArg24, out ecx_1532, out edx_1533)
	ebp_140 = (word32) eax_131 + 1
l0804E186:
	ebp_151 = PHI((ebp_120, l0804E163), (ebp_140, l0804E174))
	ebx_146 = ebx_144 + edi_119
	ebp_152 = ebp_151 + ebx_146
	eax_154 = strlen(dwArg28, out ecx_1522, out edx_1523)
	ebp_161 = (word32) eax_154 + ebp_152
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	eax_175 = __libc_malloc(gs, stackArg0, ebp_161, out ecx_1526, out edx_1527, out ebx_1528, out ebp_1529, out esi_1530, out edi_1531)
	branch eax_175 == 0x00 l0804E5B0
l0804E1B7:
	memcpy(eax_175, dwArg08, dwArg0C, out ecx_1534, out edx_1535)
	branch dwArg0C == 0x00 l0804E200
l0804E1D3:
	ebx_220 = dwArg0C
	ebp_221 = eax_175
l0804E1E0:
	ebx_239 = PHI((ebx_220, l0804E1D3), (ebx_240, l0804E1F4))
	ebp_227 = PHI((ebp_221, l0804E1D3), (ebp_873, l0804E1F4))
	eax_229 = strlen(ebp_227, out ecx_1537, out edx_1538)
	edx_238 = ~eax_229
	ebx_240 = (word32) ebx_239 + edx_238
	branch ebx_240 == 0x00 l0804E200
l0804E1F4:
	eax_871 = eax_229 + ebp_227
	ebp_873 = eax_871 + 1
	*eax_871 = 0x3A
	goto l0804E1E0
l0804E200:
	eax_250 = dwArg0C + eax_175
	*((word32) dwArg0C + (eax_175 - 0x01)) = 0x2F
	eax_260 = __stpcpy(eax_250, dwArg14, out ecx_1536)
	branch (dwArg10 & 0x04) != 0x00 l0804E560
l0804E22B:
	eax_294 = PHI((eax_260, l0804E200), (eax_283, l0804E560))
	edx_295 = (word32) eax_294 + 1
	branch (dwArg10 & 0x02) != 0x00 l0804E540
l0804E23A:
	edx_332 = PHI((edx_295, l0804E22B), (edx_317, l0804E540))
	eax_326 = PHI((eax_294, l0804E22B), (eax_309, l0804E540))
	branch (dwArg10 & 0x01) != 0x00 l0804E520
l0804E246:
	edx_359 = PHI((edx_332, l0804E23A), (edx_344, l0804E520))
	eax_353 = PHI((eax_326, l0804E23A), (eax_336, l0804E520))
	branch (dwArg10 & 0x08) != 0x00 l0804E500
l0804E252:
	edx_385 = PHI((edx_359, l0804E246), (edx_371, l0804E500))
	eax_372 = PHI((eax_353, l0804E246), (eax_363, l0804E500))
	*eax_372 = 0x2F
	memcpy(edx_385, dwArg28, (word32) eax_154 + 1, out ecx_1543, out edx_1544)
	eax_397 = *dwArg04
	branch eax_397 == 0x00 l0804E5E9
l0804E283:
	ebp_404 = eax_397
	ebx_405.u0 = 0x00
l0804E290:
	ebx_444 = PHI((ebx_405, l0804E283), (ebx_445, l0804E2B0))
	Mem411 = PHI((Mem398, l0804E283), (Mem438, l0804E2B0))
	ebp_410 = PHI((ebp_404, l0804E283), (ebp_439, l0804E2B0))
	eax_412 = *ebp_410
	branch eax_412 == 0x00 l0804E2B0
l0804E297:
	eax_424 = strcmp(eax_412, eax_175, out ecx_1545, out edx_1546)
	branch eax_424 == 0x00 l0804E594
l0804E2AC:
	branch eax_424 < 0x00 l0804E2B7
l0804E2AE:
	ebx_436 = ebp_410
l0804E2B0:
	ebx_445 = PHI((ebx_436, l0804E2AE), (ebx_444, l0804E290))
	Mem438 = PHI((Mem423, l0804E2AE), (Mem411, l0804E290))
	ebp_439 = *((word32) ebp_410 + 0x0C)
	branch ebp_439 != 0x00 l0804E290
l0804E2B7:
	ebx_443 = PHI((ebx_444, l0804E2AC), (ebx_445, l0804E2B0))
	dwLoc2C_1062 = ebx_443
l0804E2BB:
	dwLoc2C_1252 = PHI((dwLoc2C_1062, l0804E2B7), (dwLoc2C_1059, l0804E5E9))
	branch dwArg2C == 0x00 l0804E592
l0804E2C7:
	ebx_508 = 0x00
	ebp_510 = dwArg08
	eax_513 = dwArg10 >> 0x01 & ~0x2AAA
	eax_514 = eax_513 + (dwArg10 & 0x5555)
	edx_518 = eax_514 >> 0x02 & ~0x0CCC
	edx_519 = edx_518 + (eax_514 & 0x3333)
	eax_522 = (edx_519 >> 0x04) + edx_519
	edx_525 = (eax_522 & 0x0F0F) >> 0x08
	eax_526 = (eax_522 & 0x0F0F) + edx_525
	al_527 = (byte) eax_526
	eax_528 = (word32) al_527
	bLoc28_1218 = (byte) eax_528
	branch dwArg0C == 0x00 l0804E5BC
l0804E31C:
	esi_549 = dwArg0C
l0804E320:
	esi_568 = PHI((esi_549, l0804E31C), (esi_569, l0804E320))
	ebp_556 = PHI((ebp_510, l0804E31C), (ebp_566, l0804E320))
	ebx_552 = PHI((ebx_508, l0804E31C), (ebx_553, l0804E320))
	ebx_553 = ebx_552 + 0x01
	eax_558 = strlen(ebp_556, out ecx_1557, out edx_1558)
	ebp_566 = (word32) eax_558 + ((word32) ebp_556 + 1)
	eax_567 = ~eax_558
	esi_569 = (word32) esi_568 + eax_567
	branch esi_569 != 0x00 l0804E320
l0804E339:
	ecx_573 = (word32) bLoc28_1218
	cl_574 = (byte) ecx_573
	ebx_575 = ebx_553 << cl_574
	eax_577 = ebx_575 * 0x04 + 0x14
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	eax_583 = __libc_malloc(gs, stackArg0, eax_577, out ecx_1560, out edx_1561, out ebx_1562, out ebp_1563, out esi_1564, out edi_1565)
	ebp_588 = eax_583
	branch eax_583 == 0x00 l0804E5F6
l0804E361:
	*eax_583 = eax_175
	ebx_611 = dwArg0C
	edi_612 = dwArg08
	esi_613 = esi_569
l0804E370:
	ebx_632 = PHI((ebx_611, l0804E361), (ebx_633, l0804E370))
	edi_620 = PHI((edi_612, l0804E361), (edi_630, l0804E370))
	esi_616 = PHI((esi_613, l0804E361), (esi_617, l0804E370))
	esi_617 = (word32) esi_616 + 1
	eax_622 = strlen(edi_620, out ecx_1569, out edx_1570)
	edi_630 = (word32) eax_622 + ((word32) edi_620 + 1)
	eax_631 = ~eax_622
	ebx_633 = (word32) ebx_632 + eax_631
	branch ebx_633 != 0x00 l0804E370
l0804E389:
	eax_636.u0 = 0x01
	branch esi_617 == 0x01 l0804E440
l0804E397:
	ebp_649 = PHI((ebp_588, l0804E389), (ebp_543, l0804E5D3), (ebp_588, l0804E440))
	eax_648 = PHI((eax_636, l0804E389), (eax_548, l0804E5D3), (eax_644, l0804E440))
	*((word32) ebp_649 + 4) = eax_648
	((word32) ebp_649 + 8)->u0 = 0x00
	branch dwLoc2C_1252 == 0x00 l0804E580
l0804E3AD:
	eax_661 = *((word32) dwLoc2C_1252 + 0x0C)
	*((word32) ebp_649 + 0x0C) = eax_661
	*((word32) dwLoc2C_1252 + 0x0C) = ebp_649
l0804E3BA:
	branch dwArg0C == 0x00 l0804E5E0
l0804E3C6:
	ebx_671 = dwArg0C
	edi_672 = dwArg08
	esi_673 = 0x00
l0804E3D0:
	ebx_694 = PHI((ebx_671, l0804E3C6), (ebx_695, l0804E3D0))
	edi_682 = PHI((edi_672, l0804E3C6), (edi_692, l0804E3D0))
	esi_678 = PHI((esi_673, l0804E3C6), (esi_679, l0804E3D0))
	esi_679 = esi_678 + 0x01
	eax_684 = strlen(edi_682, out ecx_1571, out edx_1572)
	edi_692 = (word32) eax_684 + ((word32) edi_682 + 1)
	eax_693 = ~eax_684
	ebx_695 = (word32) ebx_694 + eax_693
	branch ebx_695 != 0x00 l0804E3D0
l0804E3E9:
	al_702 = (int8) (esi_679 == 0x01)
	eax_704.u1 = (uint32) al_702
	esi_705 = dwArg10 - eax_704
l0804E3F7:
	esi_715 = PHI((esi_705, l0804E3E9), (esi_670, l0804E5E0))
	esp_707 = fp - 0x3C
	ecx_711 = 0x00
	edx_713 = ~dwArg10
	branch esi_715 < 0x00 l0804E423
l0804E40F:
	ebp_723 = edx_713
l0804E415:
	ecx_735 = PHI((ecx_711, l0804E40F), (ecx_853, l0804E419))
	esp_731 = PHI((esp_707, l0804E40F), (esp_857, l0804E419))
	ebp_726 = PHI((ebp_723, l0804E40F), (ebp_875, l0804E419))
	esi_725 = PHI((esi_715, l0804E40F), (esi_846, l0804E419))
	branch (esi_725 & ebp_726) == 0x00 l0804E458
l0804E419:
	ebp_875 = PHI((ebp_726, l0804E415), (ebp_842, l0804E4E8))
	esp_857 = PHI((esp_731, l0804E415), (esp_840, l0804E4E8))
	ecx_853 = PHI((ecx_735, l0804E415), (ecx_839, l0804E4E8))
	esi_845 = PHI((esi_725, l0804E415), (esi_843, l0804E4E8))
	esi_846 = esi_845 - 0x01
	branch esi_846 != ~0x00 l0804E415
l0804E423:
	ecx_852 = PHI((ecx_853, l0804E421), (ecx_711, l0804E3F7))
	ebp_851 = ebp_649
	((word32) ebp_649 + (ecx_852 * 0x04 + 16))->u0 = 0x00
l0804E42B:
	ebp_860 = PHI((ebp_851, l0804E423), (ebp_594, l0804E5F6))
	eax_861 = ebp_860
	ebx_863 = ebx
	edi_867 = edi
	ebp_869 = ebp
	esp_870 = fp
	ebxOut = ebx_863
	ebpOut = ebp_869
	ediOut = edi_867
	return eax_861
l0804E438:
	ebx_40 = 0x00
	goto l0804E11D
l0804E440:
	al_643 = (int8) ((dwArg10 & 0x03) == 0x03)
	eax_644 = (word32) al_643
	goto l0804E397
l0804E458:
	esp_731->dw0018 = ebp_726
	ebp_733 = 0x00
	esp_731->t0014 = esi_725
	edi_736 = ecx_735
	goto l0804E4D6
l0804E472:
	esp_747 = esp_743 - 0x0C
	esp_747->tFFFFFFFC = ebp_742
	eax_752 = strlen(esp_747->tFFFFFFFC, out ecx_1573, out edx_1574)
	esp_759 = (struct Eq_8830 *) ((char *) &esp_747->tFFFFFFFC + 16)
	ebp_760 = (word32) eax_752 + ((word32) ebp_742 + 1)
	branch ebp_760 >= esp_747->t001C l0804E4E8
l0804E48C:
	branch ebp_760 == 0x00 l0804E4E8
l0804E490:
	ebp_772 = PHI((ebp_760, l0804E48C), (ebp_844, l0804E4DE))
	edi_768 = PHI((edi_837, l0804E48C), (edi_838, l0804E4DE))
	esp_766 = PHI((esp_759, l0804E48C), (esp_826, l0804E4DE))
	esp_767 = esp_766 - 0x0C
	edi_769 = edi_768 + 0x01
	esp_767->tFFFFFFFC = ebp_772
	eax_774 = strlen(esp_767->tFFFFFFFC, out ecx_1575, out edx_1576)
	esp_767->dw0004 = 0x01
	v27_786 = esp_767->dw0070
	esp_767->dw0000 = v27_786
	v28_789 = esp_767->t006C
	esp_767->tFFFFFFFC = v28_789
	v29_792 = esp_767->dw0068
	esp_767->dwFFFFFFF8 = v29_792
	v30_795 = esp_767->dw0064
	esp_767->dwFFFFFFF4 = v30_795
	v31_798 = esp_767->dw0060
	esp_767->dwFFFFFFF0 = v31_798
	v32_801 = esp_767->dw005C
	esp_767->dwFFFFFFEC = v32_801
	v33_804 = esp_767->dw0020
	esp_767->dwFFFFFFE8 = v33_804
	esp_767->dwFFFFFFE4 = (word32) eax_774 + 1
	esp_767->tFFFFFFE0 = ebp_772
	v34_811 = esp_767->dw004C
	esp_767->dwFFFFFFDC = v34_811
	eax_817 = _nl_make_l10nflist(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20, dwArg24, dwArg28, out ebx_1577, out ebp_1578, out edi_1579)
	esp_821 = (struct Eq_8830 *) (&esp_767->dw0004 + 2)
	*((word32) ebp_649 + (edi_769 * 0x04 + 0x0C)) = eax_817
	branch ebp_772 != 0x00 l0804E46C
l0804E4D6:
	edi_838 = PHI((edi_736, l0804E458), (edi_769, l0804E490))
	Mem827 = PHI((Mem734, l0804E458), (Mem822, l0804E490))
	esp_826 = PHI((esp_731, l0804E458), (esp_821, l0804E490))
	eax_828 = esp_826->dw0048
	branch eax_828 == 0x00 l0804E4E8
l0804E4DE:
	ebp_844 = esp_826->t0044
	goto l0804E490
l0804E4E8:
	Mem841 = PHI((Mem750, l0804E48C), (Mem827, l0804E4D6))
	esp_840 = PHI((esp_759, l0804E48C), (esp_826, l0804E4D6))
	edi_836 = PHI((edi_837, l0804E472), (edi_837, l0804E48C), (edi_838, l0804E4D6))
	ecx_839 = edi_836
	ebp_842 = esp_840->dw0018
	esi_843 = esp_840->t0014
	goto l0804E419
l0804E500:
	*eax_353 = 0x40
	eax_363 = __stpcpy(edx_359, dwArg24, out ecx_1542)
	edx_371 = (word32) eax_363 + 1
	goto l0804E252
l0804E520:
	*eax_326 = 0x2E
	eax_336 = __stpcpy(edx_332, dwArg20, out ecx_1541)
	edx_344 = (word32) eax_336 + 1
	goto l0804E246
l0804E540:
	*eax_294 = 0x2E
	eax_309 = __stpcpy(edx_295, dwArg1C, out ecx_1540)
	edx_317 = (word32) eax_309 + 1
	goto l0804E23A
l0804E560:
	*eax_260 = 0x5F
	eax_283 = __stpcpy((word32) eax_260 + 1, dwArg18, out ecx_1539)
	goto l0804E22B
l0804E580:
	*((word32) ebp_649 + 0x0C) = eax_397
	*dwArg04 = ebp_649
	goto l0804E3BA
l0804E592:
	ebp_455.u0 = 0x00
l0804E594:
	ebp_472 = PHI((ebp_410, l0804E297), (ebp_455, l0804E592))
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	free(gs, stackArg0, eax_175, out ecx_1548, out edx_1549)
	eax_495 = ebp_472
	ebx_498 = esi
	edi_502 = ebp
	ebp_504 = dwArg00
	esp_505 = fp + 0x04
	ebxOut = ebx_498
	ebpOut = ebp_504
	ediOut = edi_502
	return eax_495
l0804E5B0:
	ebx_188 = ebx
	eax_190.u0 = 0x00
	edi_193 = edi
	ebp_195 = ebp
	esp_196 = fp
	ebxOut = ebx_188
	ebpOut = ebp_195
	ediOut = edi_193
	return eax_190
l0804E5BC:
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	eax_538 = __libc_malloc(gs, stackArg0, 0x14, out ecx_1551, out edx_1552, out ebx_1553, out ebp_1554, out esi_1555, out edi_1556)
	ebp_543 = eax_538
	branch eax_538 == 0x00 l0804E5F6
l0804E5D3:
	*eax_538 = eax_175
	eax_548.u0 = 0x01
	goto l0804E397
l0804E5E0:
	esi_670 = dwArg10
	goto l0804E3F7
l0804E5E9:
	dwLoc2C_1059.u0 = 0x00
	goto l0804E2BB
l0804E5F6:
	ebp_594.u0 = 0x00
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	stackArg0.u0 = <invalid>
	free(gs, stackArg0, eax_175, out ecx_1567, out edx_1568)
	goto l0804E42B
_nl_make_l10nflist_exit:
}

// 0804E610: Register Eq_2 _nl_normalize_codeset(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _nl_explode_name
//      _nl_load_locale_from_archive
Eq_2 _nl_normalize_codeset(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebx_108;
	Eq_2 edi_172;
	if (dwArg08 != 0x00)
	{
		Eq_2 esi_40 = g_t80CE08C;
		word32 ecx_42 = 0x00;
		Eq_2 eax_44 = dwArg04;
		word32 ebx_45 = 0x01;
		word32 edi_46 = dwArg08 + dwArg04;
		do
		{
			uint32 edx_50 = (word32) *eax_44;
			if ((*((word32) esi_40 + edx_50 * 0x02) & 0x08) != 0x00)
			{
				++ecx_42;
				if (edx_50 >= 0x3A)
					ebx_45 = 0x00;
			}
			eax_44 = (word32) eax_44 + 1;
		} while (edi_46 != eax_44);
		Eq_2 edi_109;
		if (ebx_45 == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_304;
			word32 edi_307;
			word32 esi_306;
			word32 edx_303;
			word32 ecx_302;
			word32 ebp_305;
			Eq_2 eax_103 = __libc_malloc(gs, stackArg0, ecx_42 + 0x01, out ecx_302, out edx_303, out ebx_304, out ebp_305, out esi_306, out edi_307);
			ebx_108 = eax_103;
			edi_109 = eax_103;
			if (eax_103 == 0x00)
				return 0x00;
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_297;
			word32 ebp_298;
			word32 edx_296;
			word32 esi_299;
			word32 edi_300;
			word32 ecx_295;
			Eq_2 eax_86 = __libc_malloc(gs, stackArg0, ecx_42 + 0x04, out ecx_295, out edx_296, out ebx_297, out ebp_298, out esi_299, out edi_300);
			edi_109 = eax_86;
			if (eax_86 == 0x00)
				return 0x00;
			*eax_86 = 7304041;
			ebx_108 = (word32) eax_86 + 3;
		}
		Eq_2 edx_131 = 0x00;
		Eq_153933 ebp_137[] = g_ptr80CE088;
		do
		{
			word32 eax_141 = CONVERT(Mem140[dwArg04 + edx_131:byte], byte, word32);
			byte cl_164 = (byte) eax_141;
			if ((*((word32) esi_40 + (eax_141 * 0x02 + 1)) & 0x04) == 0x00)
			{
				if (eax_141 <= 0x39)
				{
					*ebx_108 = cl_164;
					edx_131 = (word32) edx_131 + 1;
					ebx_108 = (word32) ebx_108 + 1;
					if (dwArg08 <= edx_131)
						break;
					continue;
				}
			}
			else
			{
				ebx_108 = (word32) ebx_108 + 1;
				*((word32) ebx_108 - 1) = ebp_137[eax_141].b0000;
			}
			edx_131 = (word32) edx_131 + 1;
		} while (dwArg08 > edx_131);
		edi_172 = edi_109;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ebp_291;
		word32 ebx_290;
		word32 edx_289;
		word32 ecx_288;
		word32 esi_292;
		word32 edi_293;
		Eq_2 eax_29 = __libc_malloc(gs, stackArg0, 0x04, out ecx_288, out edx_289, out ebx_290, out ebp_291, out esi_292, out edi_293);
		edi_172 = eax_29;
		if (eax_29 == 0x00)
			return 0x00;
		*eax_29 = 7304041;
		ebx_108 = (word32) eax_29 + 3;
	}
	*ebx_108 = 0x00;
	return edi_172;
}

// 0804E760: Register ui32 _nl_explode_name(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Register out ptr32 ebxOut, Register out (ptr32 Eq_5103) ebpOut, Register out (ptr32 Eq_5104) esiOut)
// Called from:
//      _nl_find_domain
//      _nl_find_locale
ui32 _nl_explode_name(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, ptr32 & ebxOut, struct Eq_5103 & ebpOut, struct Eq_5104 & esiOut)
{
	ui32 edi_117;
	*dwArg0C = 0x00;
	dwArg10->u0 = 0x00;
	dwArg14->u0 = 0x00;
	dwArg18->u0 = 0x00;
	*dwArg08 = dwArg04;
	struct Eq_9252 * esp_18 = fp - 44;
	Eq_2 ecx_19 = dwArg10;
	Eq_2 edx_20 = dwArg14;
	byte al_32 = *dwArg04;
	if ((al_32 & 191) != 0x00 && (al_32 != 0x5F && al_32 != 0x2E))
	{
		Eq_2 ebx_40 = dwArg04;
		do
		{
			byte al_128 = *((word32) ebx_40 + 1);
			Eq_2 esi_104 = (word32) ebx_40 + 1;
			if (al_128 == 0x00 || al_128 == 0x5F)
			{
				if (dwArg04 == esi_104)
					goto l0804E848;
				if (al_128 != 0x5F)
					goto l0804E7ED;
				*esi_104 = 0x00;
				Eq_2 ebx_60 = (word32) ebx_40 + 2;
				*dwArg10 = ebx_60;
				al_128 = (byte) *((word32) esi_104 + 1);
				if ((al_128 & 191) != 0x00)
				{
					while (al_128 != 0x2E)
					{
						ebx_60 = (word32) ebx_60 + 1;
						al_128 = (byte) *ebx_60;
						if ((al_128 & 191) == 0x00)
							break;
					}
				}
				esi_104 = ebx_60;
				edi_117 = 0x04;
				if (al_128 == 0x2E)
					goto l0804E88D;
				goto l0804E7F7;
			}
			ebx_40 = esi_104;
		} while (al_128 != 0x2E && al_128 != 0x40);
		if (dwArg04 != esi_104)
		{
l0804E7ED:
			edi_117 = 0x00;
			if (al_128 == 0x2E)
			{
l0804E88D:
				*esi_104 = 0x00;
				Eq_2 ebx_106 = (word32) esi_104 + 1;
				*dwArg14 = ebx_106;
				al_128 = (byte) *((word32) esi_104 + 1);
				ui32 esi_119 = edi_117 | 0x02;
				if ((al_128 & 191) != 0x00)
				{
					Eq_2 ebp_134 = ebx_106;
					while (true)
					{
						esi_104 = (word32) ebp_134 + 1;
						if ((*((word32) ebp_134 + 1) & 191) == 0x00)
							break;
						ebp_134 = esi_104;
					}
					if (ebx_106 != esi_104)
					{
						Eq_2 eax_174 = _nl_normalize_codeset(ebx_106, esi_104 - ebx_106);
						*dwArg18 = eax_174;
						if (eax_174 == 0x00)
						{
							edi_117 = ~0x00;
							goto l0804E83A;
						}
						esp_18 = fp - 44;
						edx_20 = dwArg14;
						ecx_19 = dwArg10;
						word32 ecx_438;
						word32 edx_439;
						if (strcmp(*dwArg14, eax_174, out ecx_438, out edx_439) != 0x00)
						{
							edi_117 |= 0x03;
							al_128 = (byte) *((word32) ebp_134 + 1);
						}
						else
						{
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							word32 edx_443;
							word32 ecx_442;
							free(gs, stackArg0, eax_174, out ecx_442, out edx_443);
							esp_18 = fp - 0x28;
							al_128 = (byte) *((word32) ebp_134 + 1);
							edi_117 = dwLoc1C;
							ecx_19 = dwArg14;
							edx_20 = dwArg18;
						}
					}
					else
						edi_117 = esi_119;
				}
				else
				{
					edi_117 = esi_119;
					esi_104 = ebx_106;
				}
			}
l0804E7F7:
			if (al_128 == 0x40)
			{
				byte ** ebx_242 = esp_18->ptr0038;
				*esi_104 = 0x00;
				*ebx_242 = (word32) esi_104 + 1;
				if (*((word32) esi_104 + 1) != 0x00)
					edi_117 |= 0x08;
			}
l0804E818:
			Eq_2 eax_259 = *ecx_19;
			if (eax_259 != 0x00)
			{
				ui32 ecx_265 = edi_117 & ~0x04;
				if (*eax_259 == 0x00)
					edi_117 = ecx_265;
			}
			Eq_2 eax_274 = *edx_20;
			if (eax_274 != 0x00)
			{
				ui32 edx_280 = edi_117 & ~0x02;
				if (*eax_274 == 0x00)
					edi_117 = edx_280;
			}
l0804E83A:
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			return edi_117;
		}
	}
l0804E848:
	edi_117 = 0x00;
	goto l0804E818;
}

// 0804E970: void __gettext_free_exp(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __gettext_free_exp
//      new_exp
//      _nl_unload_domain
void __gettext_free_exp(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	word32 eax_17 = *dwArg04;
	if (eax_17 != 0x02)
	{
		if (eax_17 != 0x03)
		{
			if (eax_17 != 0x01)
				goto l0804E99D;
l0804E9CC:
			__gettext_free_exp(gs, *((word32) dwArg04 + 8));
l0804E99D:
			word32 ecx_128;
			word32 edx_129;
			free(gs, dwLoc20, dwArg04, out ecx_128, out edx_129);
			return;
		}
		__gettext_free_exp(gs, *((word32) dwArg04 + 16));
	}
	__gettext_free_exp(gs, *((word32) dwArg04 + 0x0C));
	goto l0804E9CC;
}

// 0804E9E0: void new_exp(Register ui32 eax, Register (arr Eq_2) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
void new_exp(ui32 eax, Eq_2 ecx[], Eq_2 edx, struct Eq_9 * gs)
{
	ui32 esi_14 = eax - 0x01;
	if (eax == 0x00)
	{
		word32 ecx_220;
		word32 esi_224;
		word32 edi_225;
		word32 edx_221;
		word32 ebx_222;
		word32 ebp_223;
		Eq_2 eax_30 = __libc_malloc(gs, dwLoc40, 0x14, out ecx_220, out edx_221, out ebx_222, out ebp_223, out esi_224, out edi_225);
		if (eax_30 == 0x00)
			return;
		*eax_30 = 0x00;
		*((word32) eax_30 + 4) = edx;
	}
	else
	{
		Eq_2 edi_109[] = ecx;
		Eq_2 ecx_110 = ecx[eax - 0x01];
		if (ecx_110 != 0x00)
		{
			ui32 eax_55 = eax - 0x01;
			do
			{
				--eax_55;
				if (eax_55 == ~0x00)
				{
					word32 ebp_75;
					word32 ecx_226;
					word32 edx_227;
					word32 ebx_228;
					Eq_2 eax_74 = __libc_malloc(gs, dwLoc40, 0x14, out ecx_226, out edx_227, out ebx_228, out ebp_75, out esi_14, out edi_109);
					if (eax_74 == 0x00)
						break;
					*eax_74 = ebp_75;
					*((word32) eax_74 + 4) = edx;
					*((word32) eax_74 + (esi_14 * 0x04 + 8)) = ecx_110;
					ui32 esi_118 = esi_14 - 0x01;
					if (esi_14 == 0x00)
						return;
					do
					{
						*((word32) eax_74 + (esi_118 * 0x04 + 8)) = edi_109[esi_118];
						--esi_118;
					} while (esi_118 != ~0x00);
					return;
				}
			} while (ecx[eax_55] != 0x00);
		}
		while (true)
		{
			__gettext_free_exp(gs, ecx_110);
			--esi_14;
			if (esi_14 == ~0x00)
				break;
			ecx_110 = edi_109[esi_14];
		}
	}
}

// 0804EAC0: Register word32 __gettextparse(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Stack up32 dwArg28, Stack Eq_2 dwArg38, Stack Eq_2 dwArg3C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __gettext_extract_plural
word32 __gettextparse(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, up32 dwArg28, Eq_2 dwArg38, Eq_2 dwArg3C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	ui32 eax_26 = gs->dw0014;
	Eq_2 ebx_126 = fp - 0x04D0;
	Eq_2 edx_197 = 0x00;
	struct Eq_9619 * esi_276 = fp - 0x0340;
l0804EB3B:
	int32 dwArg14_712;
	word32 esi_236;
	Eq_2 ecx_177;
	Eq_2 eax_210;
	word32 ebp_191;
	struct Eq_9619 * ecx_209;
	word32 eax_48 = CONVERT(Mem45[dwArg18 + edx_197:byte], byte, int32);
	struct Eq_9614 * esp_398 = fp;
	Eq_9655 dwArg14_683 = eax_48;
	if (eax_48 == ~0x09)
	{
l0804ECE0:
		ecx_177 = (word32) *((word32) edx_197 + 0x080A2600);
		struct Eq_9619 * esi_186 = esi_276;
		cu8 cl_192 = (byte) ecx_177;
		if (ecx_177 != 0x00)
		{
			ui32 edx_181 = (word32) *((word32) ecx_177 + 134882636);
			ebp_191 = (word32) esi_276[0x01 - edx_181];
			if (cl_192 <= 0x0D)
			{
				<anonymous> * edx_212 = g_a80A2320[ecx_177 * 0x04] + 0x080CE000;
				word32 eax_222;
				Eq_2 edx_223;
				Eq_2 ecx_224;
				edx_212();
				ecxOut = ecx_224;
				edxOut = edx_223;
				return eax_222;
			}
			int32 edx_195 = (word32) *((word32) ecx_177 + 0x080A255C);
			edx_197 = (int32) (0x080A25EA + edx_195);
			dwArg14_712 = edx_195 - 0x10;
			ecx_209 = esi_276 - edx_181 * 0x04 + 0x04;
			eax_210 = ebx_126 - edx_181 * 0x02;
			goto l0804EE13;
		}
		if (dwArg28 == 0x03)
		{
			if (dwArg10 > 0x00)
			{
				dwArg10.u0 = ~0x01;
l0804ED1D:
				while (true)
				{
					ecx_177 = dwArg18;
					word32 eax_245 = CONVERT(Mem244[dwArg18 + edx_197:byte], byte, int32);
					if (eax_245 != ~0x09)
					{
						edx_197 = (word32) eax_245 + 1;
						if (eax_245 <= 0x35 && *((word32) eax_245 + 0x080A2581) == 0x01)
						{
							edx_197 = (word32) *((word32) eax_245 + 134882753);
							if (edx_197 != 0x00)
							{
								esi_276 = esi_186 + 1;
								esi_276->t0000.u2 = dwArg3C;
								dwArg28 = 0x03;
								eax_210 = ebx_126;
								goto l0804EBC5;
							}
						}
					}
					if (ebx_126 == dwArg0C)
					{
						esi_236 = 0x01;
						goto l0804ED95;
					}
					ebx_126 -= (struct Eq_9869 *) 0x02;
					edx_197 = (int32) *ebx_126;
					esi_186 -= 0x04;
				}
			}
			if (dwArg10 == 0x00)
			{
				esi_236 = 0x01;
				ebx_126 = dwArg0C;
				goto l0804ED95;
			}
		}
		goto l0804ED1D;
	}
	int32 eax_114;
	if (dwArg10 != ~0x01)
	{
		if (dwArg10 <= 0x00)
		{
			eax_114 = 0x00;
			dwArg10.u0 = 0x00;
			goto l0804EB77;
		}
		eax_114 = CONVERT(Mem49[0x080A2640<p32> + dwArg10:byte], byte, word32);
	}
	else
	{
		byte * eax_55 = *dwArg38;
		byte * dwArg2C_686 = eax_55;
		cu8 al_105 = *eax_55;
		if (al_105 == 0x00)
		{
l0804EEF8:
			*dwArg38 = dwArg2C_686;
			dwArg10.u0 = 0x00;
			eax_114 = 0x00;
			goto l0804EB77;
		}
		if (al_105 == 0x09 || al_105 == 0x20)
		{
			byte * ecx_68 = eax_55;
			do
			{
				++ecx_68;
				al_105 = *ecx_68;
				if (al_105 == 0x00)
				{
					dwArg2C_686 = ecx_68;
					goto l0804EEF8;
				}
			} while (al_105 == 0x20 || al_105 == 0x09);
			dwArg2C_686 = ecx_68;
		}
		byte * dwArg30_699 = dwArg2C_686 + 1;
		if (al_105 <= 0x7C)
		{
			word32 eax_137;
			Eq_2 edx_138;
			Eq_2 ecx_139;
			(g_a80A2358[(word32) al_105 * 0x04] + 0x080CE000)();
			ecxOut = ecx_139;
			edxOut = edx_138;
			return eax_137;
		}
		*dwArg38 = dwArg30_699;
		dwArg10.u0 = 0x0100;
		eax_114 = 0x01;
	}
	dwArg14_683 = (word32) eax_48.u0 + eax_114;
l0804EB77:
	if (dwArg14_683 <= 0x36 && (int32) (*((word32) dwArg14_683 + 0x080A2580)) == eax_114)
	{
		edx_197 = CONVERT(Mem157[0x080A25C0<p32> + dwArg14_683:byte], byte, word32);
		if (edx_197 != 0x00)
		{
			++esi_276;
			esi_276->t0000.u2 = dwArg3C;
			dwArg10.u0 = ~0x01;
			dwArg28 = (up32) ((bool) (dwArg28 < 0x01) + (dwArg28 + ~0x00));
			eax_210 = ebx_126;
			goto l0804EBC5;
		}
		ecx_209 = esi_276;
		dwArg14_712 = ~0x0F;
		ebp_191 = (word32) esi_276[1];
		eax_210 = ebx_126;
l0804EE13:
		int32 ebx_292 = (int32) *eax_210;
		ecx_209->t0000.u0 = ebp_191;
		esi_276 = ecx_209 + 1;
		Eq_9935 edx_298 = (word32) edx_197 + ebx_292;
		int16 cx_304 = (word16) ebx_292;
		if (edx_298 <= 0x36 && cx_304 == (int16) (*((word32) edx_298 + 0x080A2580)))
			edx_197 = (word32) *((word32) edx_298 + 0x080A25C0);
		else
			edx_197 = (int32) (&g_t80A25F7)[dwArg14_712];
l0804EBC5:
		((word32) eax_210 + 2)->u4 = (word16) edx_197;
		struct Eq_9700 * eax_338 = (word32) dwArg1C + (dwArg1C - 0x02);
		ebx_126 = eax_210 + 0x02;
		ecx_177 = dwArg0C + eax_338;
		if (ebx_126 < ecx_177)
		{
l0804ECC9:
			if (edx_197 == 0x09)
			{
				ebx_126 = esp_398->t000C;
				esi_236 = 0x00;
l0804ED95:
				if (ebx_126 == esp_398->t0024)
					goto l0804EDA9;
				goto l0804ED9B;
			}
			goto l0804EB3B;
		}
		else
		{
			int32 esi_351 = (ebx_126 - dwArg0C >> 0x01) + 0x01;
			if (dwArg1C <= 9999)
			{
				Eq_2 ecx_355 = 10000;
				if (eax_338 <= (struct Eq_9700 *) 9998)
					ecx_355 = &eax_338->w0002;
				ui32 eax_365 = ecx_355 * 0x02;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				ui32 eax_368 = (word32) ecx_355 + eax_365;
				Eq_2 stackArg0 = <invalid>;
				dwArg1C = ecx_355;
				word32 edi_992;
				word32 esi_991;
				word32 ebx_989;
				word32 ebp_990;
				Eq_2 eax_390 = __libc_malloc(gs, stackArg0, eax_368 + 0x03 + eax_368, out ecx_177, out edx_197, out ebx_989, out ebp_990, out esi_991, out edi_992);
				if (eax_390 != 0x00)
				{
					word32 ecx_993;
					word32 edx_994;
					memcpy(eax_390, dwArg0C, esi_351 * 0x02, out ecx_993, out edx_994);
					Eq_2 eax_434 = (word32) eax_390 + (eax_365 + 0x03 & ~0x03);
					word32 edx_996;
					word32 ecx_995;
					memcpy(eax_434, dwArg20, esi_351 << 0x02, out ecx_995, out edx_996);
					esp_398 = fp;
					ecx_177 = eax_390;
					if (dwArg0C != dwArg24)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 edx_999;
						word32 ecx_998;
						free(gs, stackArg0, dwArg0C, out ecx_998, out edx_999);
						dwArg0C = edx_197;
						esp_398 = (struct Eq_9614 *) ((char *) &fp->tFFFFFFF0 + 20);
						ecx_177 = dwArg18;
						edx_197 = dwArg10;
					}
					esi_276 = eax_434 - 0x04 + (esi_351 << 0x02);
					ebx_126 = ecx_177 - 0x02 + esp_398->dw0030;
					if (ebx_126 >=u (ecx_177 - 0x02) + Mem471[esp_398 + 44:word32])
					{
						ebx_126 = ecx_177;
						esi_236 = 0x01;
l0804ED9B:
						esp_398->tFFFFFFF0 = ebx_126;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						free(gs, stackArg0, stackArg4, out ecx_177, out edx_197);
l0804EDA9:
						if ((eax_26 ^ gs->dw0014) != 0x00)
						{
							word32 ecx_1002;
							word32 edx_1003;
							__stack_chk_fail(out ecx_1002, out edx_1003);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							Eq_2 stackArg12 = <invalid>;
							Eq_2 edx_557;
							Eq_2 ecx_558;
							word32 eax_556 = __gettext_extract_plural(gs, dwArg04, stackArg8, stackArg12, out ecx_558, out edx_557);
							ecxOut = ecx_558;
							edxOut = edx_557;
							return eax_556;
						}
						else
						{
							ecxOut = ecx_177;
							edxOut = edx_197;
							return esi_236;
						}
					}
					esp_398->t0020 = eax_434;
					esp_398->t000C = ecx_177;
					goto l0804ECC9;
				}
			}
			esp_398 = fp;
			ebx_126 = dwArg0C;
			esi_236 = 0x02;
			goto l0804ED95;
		}
	}
	goto l0804ECE0;
}

// 0804F370: Register Eq_2 __gettext_extract_plural(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 (arr Eq_153925)) ecxOut, Register out Eq_5851 edxOut)
// Called from:
//      _nl_load_domain
//      __gettextparse
Eq_2 __gettext_extract_plural(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_153925 (& ecxOut, union Eq_5851 & edxOut)
{
	ui32 eax_20 = gs->dw0014;
	if (dwArg04 != 0x00)
	{
		word32 edx_256;
		word32 ecx_255;
		Eq_2 eax_36 = strstr(gs, dwArg04, 134883143, out ecx_255, out edx_256);
		Eq_2 eax_50 = strstr(gs, dwArg04, 134883151, out ecx, out edx);
		if (eax_36 != 0x00 && eax_50 != 0x00)
		{
			word32 eax_252 = (word32) *((word32) eax_50 + 9);
			Eq_2 ebx_62 = (word32) eax_50 + 9;
			if ((byte) eax_252 != 0x00)
			{
				ecx = gs->ptrFFFFFFF8;
				do
				{
					edx = (word32) (byte) eax_252;
					if ((ecx[edx].b0001 & 0x20) == 0x00)
					{
						if ((byte) (eax_252 - 0x30) > 0x09)
							break;
						Eq_10008 eax_103 = __strtoul(gs, ebx_62, fp - 44, 0x0A, out ecx, out edx);
						if (dwLoc2C == ebx_62)
							break;
						*dwArg0C = eax_103;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg12 = <invalid>;
						Eq_2 stackArg16 = <invalid>;
						Eq_2 stackArg24 = <invalid>;
						Eq_2 stackArg28 = <invalid>;
						Eq_2 stackArg32 = <invalid>;
						Eq_2 stackArg56 = <invalid>;
						Eq_2 stackArg60 = <invalid>;
						if (__gettextparse(gs, fp - 0x28, stackArg12, stackArg16, stackArg24, stackArg28, stackArg32, dwLoc2C, (word32) eax_36 + 7, stackArg56, stackArg60, out ecx, out edx) != 0x00)
							break;
						*dwArg08 = dwLoc24;
						goto l0804F45E;
					}
					ebx_62 = (word32) ebx_62 + 1;
					eax_252 = (word32) *ebx_62;
				} while ((byte) eax_252 != 0x00);
			}
		}
	}
	*dwArg08 = 0x080CC6C0;
	*dwArg0C = 0x02;
l0804F45E:
	Eq_2 eax_148 = eax_20 ^ gs->dw0014;
	if (eax_148 != 0x00)
	{
		Eq_5851 edx_160;
		Eq_153925 (* ecx_161)[];
		Eq_2 eax_159 = __stack_chk_fail(out ecx_161, out edx_160);
		__x86.get_pc_thunk.bp();
		ecxOut = ecx_161;
		edxOut = edx_160;
		return eax_159;
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx;
		return eax_148;
	}
}

// 0804F478: void __x86.get_pc_thunk.bp()
// Called from:
//      __gettext_extract_plural
void __x86.get_pc_thunk.bp()
{
}

// 0804F480: Register ui32 __hash_string(Stack Eq_2 dwArg04)
// Called from:
//      _nl_find_msg
//      _nl_load_domain
//      find_module_idx
ui32 __hash_string(Eq_2 dwArg04)
{
	Eq_2 ecx_11 = dwArg04;
	ui32 eax_18 = 0x00;
l0804F490:
	word32 edx_13 = (word32) *ecx_11;
	while ((byte) edx_13 != 0x00)
	{
		ecx_11 = (word32) ecx_11 + 1;
		eax_18 = (eax_18 << 0x04) + edx_13;
		if ((eax_18 & 0xF0000000) == 0x00)
			goto l0804F490;
		edx_13 = (word32) *ecx_11;
		eax_18 = eax_18 & 0x0FFFFFFF ^ (eax_18 & 0xF0000000) >> 0x18;
	}
	return eax_18;
}

// 0804F4C0: Register word32 _setjmp(Register word32 ebx, Register word32 ebp, Register word32 esi, Register word32 edi, Register (ptr32 Eq_10168) gs, Stack word32 dwArg00, Stack (ptr32 Eq_10170) dwArg04)
// Called from:
//      __libc_start_main
word32 _setjmp(word32 ebx, word32 ebp, word32 esi, word32 edi, struct Eq_10168 * gs, word32 dwArg00, struct Eq_10170 * dwArg04)
{
	dwArg04->dw0000 = ebx;
	dwArg04->dw0004 = esi;
	dwArg04->dw0008 = edi;
	dwArg04->t0010 = __rol(fp + 0x04 ^ gs->dw0018, 0x09);
	dwArg04->t0014 = __rol(dwArg00 ^ gs->dw0018, 0x09);
	dwArg04->dw000C = ebp;
	dwArg04->dw0018 = 0x00;
	dwArg04->dw0028 = 0x00;
	return 0x00;
}

// 0804F510: void msort_with_tmp.part.0(Register (ptr32 Eq_10216) eax, Register Eq_2 ecx, Register Eq_2 edx)
// Called from:
//      msort_with_tmp.part.0
//      qsort_r
void msort_with_tmp.part.0(struct Eq_10216 * eax, Eq_2 ecx, Eq_2 edx)
{
	Eq_2 edi_27 = ecx - (ecx >> 0x01);
	Eq_10223 dwLoc44_557 = ecx >> 0x01;
	Eq_2 dwLoc48_558 = edi_27;
	Eq_2 ebp_119 = (word32) edx + eax->t0000 *s (ecx >> 0x01);
	if (ecx > 0x03)
		msort_with_tmp.part.0(eax, ecx >> 0x01, edx);
	if (edi_27 > 0x01)
		msort_with_tmp.part.0(eax, edi_27, ebp_119);
	Eq_2 dwLoc34_572;
	Eq_2 esi_101;
	word32 edx_66 = eax->dw000C;
	Eq_10223 ecx_105 = SEQ(SLICE(edi_27, word24, 8), (int8) (edi_27 != 0x00));
	Eq_2 edx_107 = SEQ(SLICE(edx_66, word24, 8), (int8) (ecx >> 0x01 != 0x00)) & ecx_105;
	Eq_2 edx_61 = eax->t0000;
	<anonymous> * ecx_62 = eax->ptr0008;
	Eq_2 edi_104 = eax->t0010;
	word32 eax_70 = eax->dw0004;
	byte dl_86 = (byte) edx_107;
	if (eax_70 != 0x01)
	{
		Eq_2 ebp_155;
		Eq_2 esi_151;
		if (eax_70 == 0x00)
		{
			if (dl_86 == 0x00)
			{
				dwLoc34_572 = edx;
				goto l0804F626;
			}
			esi_151 = edx;
			Eq_2 edi_154 = ebp_119;
			ebp_155 = edi_104;
			do
			{
				word32 eax_184;
				int32 eax_176;
				ecx_62();
				if (eax_176 <= 0x00)
				{
					eax_184 = (word32) *esi_151;
					--dwLoc44_557;
					esi_151 = (word32) esi_151 + 4;
				}
				else
				{
					--dwLoc48_558;
					eax_184 = (word32) *edi_154;
					edi_154 = (word32) edi_154 + 4;
				}
				*ebp_155 = eax_184;
				ecx_105 = dwLoc44_557;
				ebp_155 = (word32) ebp_155 + 4;
				if (dwLoc44_557 == 0x00)
					break;
				edx_107 = dwLoc48_558;
			} while (dwLoc48_558 != 0x00);
l0804F620:
			dwLoc34_572 = esi_151;
			edi_104 = ebp_155;
			goto l0804F626;
		}
		if (eax_70 == 0x02)
		{
			Eq_2 ecx_210 = ebp_119;
			dwLoc34_572 = edx;
			while (dwLoc44_557 != 0x00 && dwLoc48_558 != 0x00)
			{
				int32 eax_244;
				ecx_62();
				word32 ebp_229 = edi_104 + edx_61;
				Eq_2 esi_236 = dwLoc34_572;
				if (eax_244 > 0x00)
				{
					--dwLoc48_558;
					esi_236 = ecx_210;
					ecx_210 += edx_61;
				}
				else
				{
					--dwLoc44_557;
					dwLoc34_572 += edx_61;
				}
				if (ebp_229 > ebp_229 - edx_61)
				{
					Eq_2 esi_271 = esi_236;
					do
					{
						*edi_104 = *esi_271;
						esi_271 = (word32) esi_271 + 4;
						edi_104 = (word32) edi_104 + 4;
					} while (ebp_229 > edi_104);
				}
				edi_104 = ebp_229;
			}
l0804F626:
			if (dwLoc44_557 == 0x00)
				goto l0804F632;
			goto l0804F6C0;
		}
		if (eax_70 == 0x03)
		{
			dwLoc34_572 = edx;
			if (dl_86 == 0x00)
				goto l0804F626;
			esi_151 = edx;
			Eq_2 edi_389 = ebp_119;
			ebp_155 = edi_104;
			do
			{
				word32 eax_421;
				int32 eax_413;
				ecx_62();
				if (eax_413 <= 0x00)
				{
					eax_421 = (word32) *esi_151;
					--dwLoc44_557;
					esi_151 = (word32) esi_151 + 4;
				}
				else
				{
					--dwLoc48_558;
					eax_421 = (word32) *edi_389;
					edi_389 = (word32) edi_389 + 4;
				}
				*ebp_155 = eax_421;
				ebp_155 = (word32) ebp_155 + 4;
			} while (dwLoc44_557 != 0x00 && dwLoc48_558 != 0x00);
			goto l0804F620;
		}
		esi_101 = edx;
l0804F662:
		if (dwLoc44_557 != 0x00)
		{
			while (dwLoc48_558 != 0x00)
			{
				int32 eax_317;
				ecx_62();
				if (eax_317 <= 0x00)
				{
					esi_101 += edx_61;
					--dwLoc44_557;
					word32 edx_840;
					edi_104 = __mempcpy(edi_104, esi_101, edx_61, out edx_840);
					goto l0804F662;
				}
				ebp_119 += edx_61;
				--dwLoc48_558;
				word32 edx_841;
				edi_104 = __mempcpy(edi_104, ebp_119, edx_61, out edx_841);
				if (dwLoc44_557 == 0x00)
					break;
			}
		}
	}
	else
	{
		dwLoc34_572 = edx;
		esi_101 = edx;
		if (dl_86 == 0x00)
			goto l0804F626;
		do
		{
			word32 eax_118;
			int32 eax_110;
			ecx_62();
			if (eax_110 <= 0x00)
			{
				eax_118 = (word32) *esi_101;
				edx_107 = *((word32) esi_101 + 4);
				esi_101 = (word32) esi_101 + 8;
				--dwLoc44_557;
			}
			else
			{
				ebp_119 = (word32) ebp_119 + 8;
				--dwLoc48_558;
				eax_118 = (word32) *ebp_119;
				edx_107 = *((word32) ebp_119 - 4);
			}
			*edi_104 = eax_118;
			edi_104 = (word32) edi_104 + 8;
			*((word32) edi_104 - 4) = edx_107;
		} while (dwLoc44_557 != 0x00 && dwLoc48_558 != 0x00);
	}
	dwLoc34_572 = esi_101;
	if (dwLoc44_557 == 0x00)
		goto l0804F632;
l0804F6C0:
	word32 ecx_844;
	word32 edx_845;
	memcpy(edi_104, dwLoc34_572, dwLoc44_557 *s edx_61, out ecx_844, out edx_845);
l0804F632:
	word32 edx_843;
	word32 ecx_842;
	memcpy(edx, eax->t0010, (ecx - dwLoc48_558) *s edx_61, out ecx_842, out edx_843);
}

// 0804F890: void qsort_r(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      qsort
void qsort_r(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	byte bArg0C_589 = (byte) dwArg0C;
	Eq_2 ebx_33;
	struct Eq_10472 * esp_138 = fp - 0x5C;
	byte bLoc50_593 = (byte) dwArg04;
	ui32 eax_26 = gs->dw0014;
	if (dwArg0C <= 0x20)
		ebx_33 = dwArg08 *s dwArg0C;
	else
		ebx_33 = (word32) dwArg0C + dwArg08 * 0x08;
	Eq_2 dwLoc58_560;
	Eq_2 dwLoc24_578;
	if (ebx_33 > 0x03FF)
	{
		Eq_10487 ecx_101 = pagesize.8656;
		if (ecx_101 == 0x00)
		{
			word32 ebp_853;
			word32 esi_854;
			word32 ebx_852;
			Eq_10487 eax_56 = __sysconf(gs, 0x55, out ebx_852, out ebp_853, out esi_854);
			Eq_10591 edx_61 = 0x1FFFFFFF;
			if (eax_56 != ~0x00)
			{
				Eq_10487 edx_66 = (word32) eax_56.u0 + 3;
				if (eax_56 >= 0x00)
					edx_66 = eax_56;
				edx_61 = edx_66 >> 0x02;
			}
			phys_pages.8655 = edx_61;
			word32 ebx_875;
			word32 esi_877;
			word32 ebp_876;
			Eq_10487 eax_95 = __sysconf(gs, 0x1E, out ebx_875, out ebp_876, out esi_877);
			pagesize.8656 = eax_95;
			ecx_101 = eax_95;
		}
		if ((uint32) ((uint64) ebx_33 /u ecx_101) <= phys_pages.8655)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 ecx_123 = gs->tFFFFFFE0;
			Eq_2 stackArg0 = <invalid>;
			word32 edx_858;
			word32 esi_861;
			word32 edi_862;
			word32 ebx_859;
			word32 ebp_860;
			word32 ecx_857;
			Eq_2 eax_132 = __libc_malloc(gs, stackArg0, ebx_33, out ecx_857, out edx_858, out ebx_859, out ebp_860, out esi_861, out edi_862);
			gs->tFFFFFFE0 = ecx_123;
			esp_138 = fp - 0x5C;
			dwLoc58_560 = eax_132;
			if (eax_132 != 0x00)
			{
				dwLoc24_578 = eax_132;
				goto l0804F985;
			}
		}
		word32 edx_855;
		_quicksort(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, out edx_855);
		goto l0804FB0D;
	}
	else
	{
		Eq_10492 ebx_174 = (word32) ebx_33 + 27;
		struct Eq_10472 * edx_178 = fp - 0x5C - (ebx_174 & ~0x0FFF);
		if (fp - 0x5C != edx_178)
		{
			do
			{
				esp_138 -= 0x1000;
				esp_138->dw0FFC = esp_138->dw0FFC;
			} while (esp_138 != edx_178);
		}
		struct Eq_10502 * eax_193 = ebx_174 & ~0x0F & 0x0FFF;
		if (eax_193 != null)
		{
			esp_138 -= eax_193;
			Mem201[esp_138 - 0x04 + eax_193:word32] = Mem199[esp_138 - 0x04 + eax_193:word32];
		}
		dwLoc58_560.u0 = 0x00;
		dwLoc24_578 = esp_138 + 0x0F & ~0x0F;
l0804F985:
		if (dwArg0C > 0x20)
		{
			Eq_2 edx_273;
			Eq_2 eax_267 = (word32) dwLoc24_578 + dwArg08 * 0x04;
			Eq_2 ebx_268 = (word32) eax_267 + dwArg08 * 0x04;
			if (eax_267 < ebx_268)
			{
				Eq_2 ecx_274 = dwArg04;
				eax_277 = eax_267;
				do
				{
					Eq_2 eax_277;
					eax_277 = (word32) eax_277 + 4;
					*((word32) eax_277 - 4) = ecx_274;
					ecx_274 += dwArg0C;
				} while (ebx_268 > eax_277);
				edx_273 = (word32) dwLoc24_578 + dwArg08 * 0x04;
			}
			else
				edx_273 = eax_267;
			if (dwArg08 > 0x01)
				msort_with_tmp.part.0(fp - 0x34, dwArg08, edx_273);
			else if (dwArg08 == 0x00)
				goto l0804FAFC;
			Eq_2 dwLoc4C_625 = 0x00;
			Eq_2 dwLoc44_626 = dwArg04;
			do
			{
				Eq_2 esi_320 = *((word32) eax_267 + dwLoc4C_625 * 0x04);
				if (esi_320 != dwLoc44_626)
				{
					struct Eq_10673 * esp_325 = esp_138 - (struct Eq_10674 *) 0x04;
					esp_325->tFFFFFFFC = dwArg0C;
					esp_325->tFFFFFFF8 = dwLoc44_626;
					esp_325->tFFFFFFF4 = ebx_268;
					word32 ecx_867;
					word32 edx_868;
					memcpy(esp_325->tFFFFFFF4, esp_325->tFFFFFFF8, esp_325->tFFFFFFFC, out ecx_867, out edx_868);
					Eq_2 ecx_346 = dwLoc44_626;
					Eq_2 ebx_347 = dwLoc4C_625;
					while (true)
					{
						*((word32) eax_267 + ebx_347 * 0x04) = ecx_346;
						struct Eq_10705 * esp_355 = esp_138 - (struct Eq_10706 *) 0x04;
						esp_355->tFFFFFFFC = dwArg0C;
						esp_355->tFFFFFFF8 = esi_320;
						esp_355->tFFFFFFF4 = ecx_346;
						word32 ecx_869;
						word32 edx_870;
						memcpy(esp_355->tFFFFFFF4, esp_355->tFFFFFFF8, esp_355->tFFFFFFFC, out ecx_869, out edx_870);
						Eq_2 eax_359 = (uint32) ((uint64) (esi_320 - dwArg04) /u dwArg0C);
						union Eq_2 * edx_386 = (word32) eax_267 + eax_359 * 0x04;
						ebx_347 = eax_359;
						ecx_346 = esi_320;
						Eq_2 eax_387 = *edx_386;
						if (eax_387 == dwLoc44_626)
							break;
						esi_320 = eax_387;
					}
					*edx_386 = (union Eq_2 *) esi_320;
					esp_355->tFFFFFFFC = dwArg0C;
					esp_355->tFFFFFFF8 = ebx_268;
					esp_355->tFFFFFFF4 = esi_320;
					word32 edx_874;
					word32 ecx_873;
					memcpy(esp_355->tFFFFFFF4, esp_355->tFFFFFFF8, esp_355->tFFFFFFFC, out ecx_873, out edx_874);
				}
				Eq_2 v27_415 = (word32) dwLoc4C_625 + 1;
				dwLoc4C_625 = v27_415;
				dwLoc44_626 += dwArg0C;
			} while (dwArg08 > v27_415);
		}
		else
		{
			if ((bArg0C_589 & 0x03) == 0x00 && ((bLoc50_593 & 0x03) == 0x00 && (dwArg0C != 0x04 && (dwArg0C != 0x08 || (bLoc50_593 & 0x07) != 0x00))))
				;
			if (dwArg08 > 0x01)
				msort_with_tmp.part.0(fp - 0x34, dwArg08, dwArg04);
		}
l0804FAFC:
		esp_138->dwFFFFFFF0 = (word32) dwLoc58_560;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_865;
		word32 edx_866;
		free(gs, stackArg0, stackArg4, out ecx_865, out edx_866);
l0804FB0D:
		if ((eax_26 ^ gs->dw0014) == 0x00)
			return;
		word32 ecx_871;
		word32 edx_872;
		__stack_chk_fail(out ecx_871, out edx_872);
		qsort();
	}
}

// 0804FBE0: void qsort()
// Called from:
//      read_alias_file
//      qsort_r
//      _nl_load_locale_from_archive
void qsort()
{
	qsort_r(gs, dwArg04, dwArg08, dwArg0C);
}

// 0804FC10: Register (ptr32 Eq_10828) getenv(Stack Eq_2 dwArg04)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _dl_non_dynamic_init
//      __gconv_load_cache
//      setlocale
//      _nl_find_locale
//      __libc_secure_getenv
union Eq_10828 * getenv(Eq_2 dwArg04)
{
	Eq_2 edi_100 = environ;
	if (edi_100 == 0x00)
		return null;
	word32 eax_25 = (word32) *dwArg04;
	byte al_26 = (byte) eax_25;
	byte ah_108 = SLICE(eax_25, byte, 8);
	if (al_26 == 0x00)
		return null;
	union Eq_10828 * ebx_103 = *edi_100;
	if (*((word32) dwArg04 + 1) == 0x00)
	{
		Eq_10828 ax_145 = SEQ(ah_108 | 0x3D, al_26);
		while (ebx_103 != null)
		{
			if (ax_145 == *ebx_103)
			{
				ebx_103 = (union Eq_10828 *) ((char *) ebx_103 + 2);
				return ebx_103;
			}
			edi_100 = (word32) edi_100 + 4;
			ebx_103 = (union Eq_10828 *) *edi_100;
		}
	}
	else
	{
		word32 ecx_218;
		word32 edx_219;
		Eq_2 eax_53 = strlen(dwArg04, out ecx_218, out edx_219);
		Eq_10828 bp_142 = *dwArg04;
		while (ebx_103 != null)
		{
			if (bp_142 == *ebx_103)
			{
				word32 ecx_220;
				if (strncmp((char *) ebx_103 + 2, (word32) dwArg04 + 2, eax_53 - 0x02, out ecx_220) == 0x00 && Mem84[ebx_103 + eax_53:byte] == 0x3D)
				{
					ebx_103 = ebx_103 + 0x01 + eax_53;
					return ebx_103;
				}
			}
			edi_100 = (word32) edi_100 + 4;
			ebx_103 = (union Eq_10828 *) *edi_100;
		}
	}
	return ebx_103;
}

// 0804FCF0: void __run_exit_handlers(Register (ptr32 Eq_9) gs, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      exit
void __run_exit_handlers(struct Eq_9 * gs, word32 dwArg0C, word32 dwArg10)
{
	struct Eq_10915 * esp_18 = fp - 44;
l0804FD30:
	Eq_2 ecx_207 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_43;
	if (!__cmpxchg(__exit_funcs_lock, 0x01, 0x00, out eax_43))
		ecx_207 = __lll_lock_wait_private(eax_43, 0x080CFED8, gs);
	while (true)
	{
		Eq_2 edx_106 = *esp_18->ptr0034;
		if (edx_106 == 0x00)
			break;
		do
		{
			Eq_2 ecx_104 = *((word32) edx_106 + 4);
			if (ecx_104 == 0x00)
			{
				Eq_2 eax_66 = *edx_106;
				*esp_18->ptr0034 = (union Eq_2 *) eax_66;
				if (eax_66 != 0x00)
				{
					struct Eq_11161 * esp_73 = esp_18 - 0x0C;
					esp_73->tFFFFFFFC = edx_106;
					free(gs, esp_73->tFFFFFFF8, esp_73->tFFFFFFFC, out ecx_104, out edx_106);
					esp_18 = (struct Eq_10915 *) ((char *) &esp_73->tFFFFFFFC + 20);
				}
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v26_98 = __exit_funcs_lock - 0x01;
				__exit_funcs_lock = v26_98;
				if (v26_98 != 0x00)
					__lll_unlock_wake_private(0x080CFED8, ecx_104, edx_106, gs);
				goto l0804FD30;
			}
			word32 ebx_110 = g_dw80CFEE0;
			word32 edi_111 = g_dw80CFEE4;
			*((word32) edx_106 + 4) = ecx_104 - 0x01;
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v16_117 = __exit_funcs_lock - 0x01;
			__exit_funcs_lock = v16_117;
			if (v16_117 != 0x00)
				__lll_unlock_wake_private(0x080CFED8, ecx_104, edx_106, gs);
			struct Eq_11004 * ecx_129 = (word32) edx_106 + (ecx_104 << 0x04);
			word32 eax_131 = ecx_129->dwFFFFFFF8;
			if (eax_131 != 0x03)
			{
				if (eax_131 == 0x04)
				{
					esp_18->dw0008 = (word32) edx_106;
					Eq_2 eax_186 = ecx_129->tFFFFFFFC;
					ecx_129->dwFFFFFFF8 = 0x00;
					struct Eq_11059 * esp_185 = esp_18 - 0x08;
					esp_185->dwFFFFFFFC = esp_185->dw0038;
					esp_185->dwFFFFFFF8 = ecx_129->dw0000;
					<anonymous> * eax_196 = __ror(eax_186, 0x09) ^ gs->t0018;
					eax_196();
					edx_106 = esp_185->t0010;
				}
				else if (eax_131 == 0x02)
				{
					esp_18->dw0008 = (word32) edx_106;
					struct Eq_11128 * esp_164 = esp_18 - 0x08;
					Eq_2 eax_165 = ecx_129->tFFFFFFFC;
					esp_164->dwFFFFFFFC = ecx_129->dw0000;
					esp_164->dwFFFFFFF8 = esp_164->dw0038;
					<anonymous> * eax_174 = __ror(eax_165, 0x09) ^ gs->t0018;
					eax_174();
					edx_106 = esp_164->t0010;
				}
			}
			else
			{
				esp_18->dw0008 = (word32) edx_106;
				<anonymous> * eax_141 = __ror(ecx_129->tFFFFFFFC, 0x09) ^ gs->t0018;
				eax_141();
				edx_106 = esp_18->dw0008;
			}
			ecx_207.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_217;
			if (!__cmpxchg(__exit_funcs_lock, 0x01, 0x00, out eax_217))
				ecx_207 = __lll_lock_wait_private(eax_217, 0x080CFED8, gs);
		} while ((edi_111 ^ g_dw80CFEE4 | ebx_110 ^ g_dw80CFEE0) == 0x00);
	}
	g_b80CF604 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v17_259 = __exit_funcs_lock - 0x01;
	__exit_funcs_lock = v17_259;
	if (v17_259 != 0x00)
		__lll_unlock_wake_private(0x080CFED8, ecx_207, edx_106, gs);
	struct Eq_11089 * esp_300 = esp_18 - 0x0C;
	esp_300->tFFFFFFFC = esp_300->t003C;
	_exit(gs, esp_300->tFFFFFFFC);
}

// 0804FF10: void exit(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_start_main
void exit(struct Eq_9 * gs)
{
	__run_exit_handlers(gs, 0x01, 0x01);
}

// 0804FF40: Register (ptr32 (arr Eq_2)) __new_exitfn(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      exit
//      __internal_atexit
Eq_2 (* __new_exitfn)[](struct Eq_9 * gs, union Eq_2 * dwArg04, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	struct Eq_11209 * ebx_119 = &g_t80CE000;
	if (g_b80CF604 != 0x00)
	{
l0805002A:
		ecxOut = ecx;
		edxOut = edx;
		return null;
	}
	else
	{
		Eq_2 edi_22 = *dwArg04;
		if (edi_22 == 0x00)
		{
			word32 edx_289;
			word32 ecx_288;
			__assert_fail(out ecx_288, out edx_289);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			Eq_2 edx_46;
			Eq_2 ecx_47;
			Eq_2 (* eax_45)[] = __internal_atexit(gs, dwArg04, stackArg8, stackArg12, out ecx_47, out edx_46);
			ecxOut = ecx_47;
			edxOut = edx_46;
			return eax_45;
		}
		Eq_2 ebp_50 = 0x00;
		Eq_2 esi_130 = edi_22;
		while (true)
		{
			Eq_2 eax_152[];
			Eq_2 eax_56 = *((word32) esi_130 + 4);
			if (eax_56 != 0x00)
			{
				edx = eax_56 - 0x01;
				ecx = *((word32) esi_130 + ((eax_56 - 0x01) * 0x10 + 8));
				if (ecx != 0x00)
				{
					edx = eax_56;
l0804FFC8:
					if (edx != 0x20)
					{
						edx = (word32) edx + 1;
						*((word32) esi_130 + 4) = edx;
						eax_152 = (word32) esi_130 + 8 + (edx << 0x04);
						goto l0804FFDC;
					}
					esi_130 = ebp_50;
					if (ebp_50 != 0x00)
					{
l0805001E:
						((word32) esi_130 + 4)->u0 = 0x01;
						eax_152 = (word32) esi_130 + 8;
l0804FFDC:
						eax_152[0].u0 = 0x01;
						up32 v14_169 = ebx_119->dw1EE0 + 0x01;
						ebx_119->dw1EE0 = v14_169;
						ebx_119->dw1EE4 = (word32) ((bool) (v14_169 < 0x00) + ebx_119->dw1EE4);
						ecxOut = ecx;
						edxOut = edx;
						return eax_152;
					}
					Eq_2 edi_121;
					word32 ebp_290;
					word32 esi_291;
					Eq_2 eax_117 = __libc_calloc(gs, 0x01, 0x0208, out ecx, out edx, out ebx_119, out ebp_290, out esi_291, out edi_121);
					esi_130 = eax_117;
					if (eax_117 != 0x00)
					{
						*eax_117 = edi_121;
						*dwArg04 = (union Eq_2 *) eax_117;
						goto l0805001E;
					}
					goto l0805002A;
				}
				while (edx != 0x00)
				{
					ecx = edx - 0x01;
					if (*((word32) esi_130 + (ecx * 0x10 + 8)) != 0x00)
						goto l0804FFC8;
					edx = ecx;
				}
			}
			Eq_2 eax_83 = *esi_130;
			((word32) esi_130 + 4)->u0 = 0x00;
			ebp_50 = esi_130;
			if (eax_83 == 0x00)
				goto l0805001E;
			esi_130 = eax_83;
		}
	}
}

// 08050050: Register word32 __internal_atexit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __new_exitfn
//      __cxa_atexit
word32 __internal_atexit(struct Eq_9 * gs, union Eq_2 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_20;
	if (!__cmpxchg(__exit_funcs_lock, 0x01, 0x00, out eax_20))
		__lll_lock_wait_private(eax_20, 0x080CFED8, gs);
	word32 eax_122;
	Eq_2 ecx_41;
	Eq_2 edx_126;
	struct Eq_11370 * eax_40 = __new_exitfn(gs, dwArg10, out ecx_41, out edx_126);
	if (eax_40 != null)
	{
		eax_40->dw0000 = 0x04;
		eax_40->t0004 = __rol(dwArg04 ^ gs->t0018, 0x09);
		eax_40->t0008 = dwArg08;
		eax_40->t000C = dwArg0C;
		edx_126 = dwArg0C;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_76 = __exit_funcs_lock - 0x01;
		__exit_funcs_lock = v14_76;
		if (v14_76 != 0x00)
			__lll_unlock_wake_private(0x080CFED8, ecx_41, dwArg0C, gs);
		eax_122 = 0x00;
	}
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_52 = __exit_funcs_lock - 0x01;
		__exit_funcs_lock = v15_52;
		if (v15_52 != 0x00)
			__lll_unlock_wake_private(0x080CFED8, ecx_41, edx_126, gs);
		eax_122 = ~0x00;
	}
	ecxOut = ecx_41;
	edxOut = edx_126;
	return eax_122;
}

// 08050100: Register (ptr32 (arr Eq_2)) __cxa_atexit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
Eq_2 (* __cxa_atexit)[](struct Eq_9 * gs, union Eq_2 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_22;
	ptr32 edx_23;
	Eq_2 (* eax_21)[] = __internal_atexit(gs, dwArg04, dwArg08, dwArg0C, out ecx_22, out edx_23);
	ecxOut = ecx_22;
	edxOut = edx_23;
	return eax_21;
}

// 08050130: void __strtoul_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10)
void __strtoul_internal(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10)
{
	word32 ecx_48;
	word32 edx_49;
	____strtoul_l_internal(gs, dwArg04, dwArg08, dwArg0C, dwArg10, gs->ptrFFFFFFD4, out ecx_48, out edx_49);
}

// 08050170: Register word32 __strtoul(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_10085) ecxOut, Register out Eq_10086 edxOut)
// Called from:
//      __gettext_extract_plural
//      get_nprocs
//      get_nprocs_conf
//      __readonly_area
word32 __strtoul(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_10085 & ecxOut, union Eq_10086 & edxOut)
{
	Eq_10086 edx_26;
	struct Eq_10085 * ecx_27;
	word32 eax_25 = ____strtoul_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, gs->ptrFFFFFFD4, out ecx_27, out edx_26);
	ecxOut = ecx_27;
	edxOut = edx_26;
	return eax_25;
}

// 080501B0: Register Eq_2 ____strtoul_l_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_11467) dwArg14, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __strtoul_internal
//      __strtoul
//      __strtoul_l
Eq_2 ____strtoul_l_internal(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10, struct Eq_11467 * dwArg14, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 ebp_212 = 0x00;
	Eq_2 dwLoc48_1098 = 0x00;
	if (dwArg10 != 0x00)
	{
		edx = dwArg14->t0004;
		Eq_2 eax_28 = *((word32) edx + 44);
		dwLoc48_1098 = eax_28;
		if ((byte) ((word32) *eax_28 - 0x01) <= 0x7D)
		{
			ebp_212 = *((word32) edx + 40);
			if (*ebp_212 == 0x00)
			{
				dwLoc48_1098.u0 = 0x00;
				ebp_212.u0 = 0x00;
			}
		}
		else
			dwLoc48_1098.u0 = 0x00;
	}
	Eq_2 eax_1104;
	if (dwArg0C == 0x01 || dwArg0C > 0x24)
	{
		gs->tFFFFFFE0.u0 = 22;
		eax_1104.u0 = 0x00;
		goto l080503A3;
	}
	int32 edx_66 = (int32) *dwArg04;
	Eq_2 esi_63 = dwArg04;
	ecx = dwArg14->t0034;
	byte al_80 = (byte) edx_66;
	if ((*((word32) ecx + (edx_66 * 0x02 + 1)) & 0x20) != 0x00)
	{
		do
		{
			esi_63 = (word32) esi_63 + 1;
			int32 edx_74 = (int32) *esi_63;
			al_80 = (byte) edx_74;
		} while ((*((word32) ecx + (edx_74 * 0x02 + 1)) & 0x20) != 0x00);
	}
	if (al_80 == 0x00)
	{
		edx = dwArg08;
		if (dwArg08 == 0x00)
		{
			eax_1104.u0 = 0x00;
			goto l080503A3;
		}
		goto l0805053C;
	}
	word32 dwLoc24_1049;
	Eq_2 esi_107;
	if (al_80 != 0x2D)
	{
		dwLoc24_1049 = 0x00;
		esi_107 = (word32) esi_63 + (word32) ((int8) (al_80 == 0x2B));
	}
	else
	{
		esi_107 = (word32) esi_63 + 1;
		dwLoc24_1049 = 0x01;
	}
	Eq_11645 bLoc30_1096;
	Eq_2 dwLoc44_1089;
	Eq_3851 (* dwLoc34_1083)[];
	Eq_2 edi_129;
	Eq_11594 eax_127;
	Eq_2 ecx_111 = (word32) *esi_107;
	byte cl_112 = (byte) ecx_111;
	if (cl_112 != 0x30)
	{
		if (dwArg0C != 0x00 && dwArg0C != 0x0A)
		{
			edi_129.u0 = 0x00;
			dwLoc48_1098.u0 = 0x00;
			eax_127 = dwArg0C - 0x02;
			goto l08050274;
		}
		if (dwLoc48_1098 == 0x00)
		{
			dwArg0C.u0 = 0x0A;
			eax_127.u0 = 0x08;
			edi_129.u0 = 0x00;
			goto l08050274;
		}
l080504C0:
		word32 ecx_1187;
		word32 edx_1188;
		Eq_2 eax_216 = strlen(ebp_212, out ecx_1187, out edx_1188);
		edx = eax_216;
		if (eax_216 == 0x00)
			goto l0805050D;
		byte al_232 = *ebp_212.u0;
		if (cl_112 == al_232)
		{
			Eq_2 eax_237 = 0x00;
			do
			{
				eax_237 = (word32) eax_237 + 1;
				if (eax_216 == eax_237)
					goto l0805050D;
			} while (Mem233[ebp_212 + eax_237:byte] == Mem233[esi_107 + eax_237:byte]);
		}
		ui32 ebx_254 = (word32) cl_112;
		Eq_2 edx_259 = esi_107;
		if ((byte) ebx_254 != 0x00)
		{
			edx_259 = esi_107;
			word32 edi_273 = (word32) al_232;
			Eq_2 ecx_274 = g_t80CE08C;
			Eq_3851 eax_275[] = g_ptr80CE084;
			do
			{
				if ((byte) (ebx_254 - 0x30) > 0x09)
				{
					byte cl_292 = (byte) edi_273;
					Eq_2 eax_286 = 0x00;
					while (Mem278[edx_259 + eax_286:byte] == cl_292)
					{
						eax_286 = (word32) eax_286 + 1;
						if (eax_216 == eax_286)
							goto l08050690;
						cl_292 = Mem278[ebp_212 + eax_286:byte];
					}
					if (eax_216 > eax_286 && ((*((word32) ecx_274 + (ebx_254 * 0x02 + 1)) & 0x04) == 0x00 || eax_275[ebx_254] > 0x40))
						break;
				}
l08050690:
				edx_259 = (word32) edx_259 + 1;
				ebx_254 = (word32) *edx_259;
			} while ((byte) ebx_254 != 0x00);
		}
		Eq_2 eax_347 = __correctly_grouped_prefixmb(esi_107, edx_259, ebp_212, dwLoc48_1098);
		edi_129 = eax_216;
		ecx_111 = (word32) *esi_107;
		dwLoc48_1098 = eax_347;
		eax_127.u0 = 0x08;
		dwArg0C.u0 = 0x0A;
l08050274:
		edx = *((char *) g_a80B1C40 + eax_127 * 0x04);
		dwLoc44_1089 = edx;
		bLoc30_1096 = Mem366[0x080B1C00<p32> + eax_127:byte];
		ecx = ecx_111;
		if ((byte) ecx_111 == 0x00 || dwLoc48_1098 == esi_107)
			goto l0805050D;
		goto l080502A1;
	}
	if ((dwArg0C & ~0x10) == 0x00)
	{
		Eq_3851 eax_120[] = g_ptr80CE084;
		dwLoc34_1083 = eax_120;
		if (eax_120[(int32) *((word32) esi_107 + 1)] == 88)
		{
			ecx_111 = (word32) *((word32) esi_107 + 2);
			eax_127.u0 = 0x0E;
			esi_107 = (word32) esi_107 + 2;
			edi_129.u0 = 0x00;
			dwArg0C.u0 = 0x10;
			dwLoc48_1098.u0 = 0x00;
			goto l08050274;
		}
		if (dwArg0C == 0x00)
		{
			dwArg0C.u0 = 0x08;
			ecx.u0 = 0x30;
			dwLoc48_1098.u0 = 0x00;
			dwLoc44_1089 = g_t80B1C58;
			edi_129.u0 = 0x00;
			bLoc30_1096 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&g_t80B1C06.a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			goto l080502AF;
		}
	}
	if (dwArg0C == 0x0A)
	{
		if (dwLoc48_1098 == 0x00)
		{
			ecx.u0 = 0x30;
			dwLoc44_1089 = g_t80B1C60;
			edi_129.u0 = 0x00;
			bLoc30_1096 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&g_t80B1C08.a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
l080502A1:
			dwLoc34_1083 = g_ptr80CE084;
			goto l080502AF;
		}
		goto l080504C0;
	}
	ecx.u0 = 0x30;
	dwLoc48_1098.u0 = 0x00;
	dwLoc44_1089 = *((char *) g_a80B1C38 + dwArg0C * 0x04);
	bLoc30_1096 = (Eq_11645) *((word64) dwArg0C.u0 + 0x080B1BFE);
	edi_129.u0 = 0x00;
	dwLoc34_1083 = g_ptr80CE084;
l080502AF:
	int32 edx_395 = edi_129 - 0x01;
	Eq_2 ebx_398 = esi_107;
	word32 dwLoc40_781 = 0x00;
	Eq_2 eax_402 = g_t80CE08C;
	Eq_2 eax_1105 = 0x00;
	do
	{
		Eq_2 edx_1182 = ecx - 0x30;
		byte cl_417 = (byte) ecx;
		if ((byte) edx_1182 > 0x09)
		{
			if (edi_129 == 0x00)
			{
l08050310:
				edx = eax_402;
				if ((*((word32) eax_402 + (ecx * 0x02 + 1)) & 0x04) == 0x00)
					break;
				edx_1182 = dwLoc34_1083[ecx] - 55;
				goto l08050325;
			}
			Eq_2 edx_420 = 0x00;
			do
			{
				if (Mem419[ebp_212 + edx_420:byte] != Mem419[ebx_398 + edx_420:byte])
				{
					ecx = (word32) cl_417;
					if (edi_129 == edx_420)
						break;
					goto l08050310;
				}
				edx_420 = (word32) edx_420 + 1;
			} while (edx_420 != edi_129);
			edx = (word32) ebx_398 + edx_395;
			goto l080502EF;
		}
l08050325:
		Eq_11645 dl_456 = (byte) edx_1182;
		ecx = (word32) dl_456;
		edx = edx_1182;
		if (ecx >= dwArg0C)
			break;
		if (eax_1105 > dwLoc44_1089 || eax_1105 == dwLoc44_1089 && dl_456 > bLoc30_1096)
		{
			ecx = (word32) *((word32) ebx_398 + 1);
			edx = ebx_398;
			dwLoc40_781 = 0x01;
			ebx_398 = (word32) ebx_398 + 1;
			if ((byte) ecx == 0x00)
				break;
		}
		else
		{
			edx = ebx_398;
			eax_1105 = (word32) ecx + eax_1105 *s dwArg0C;
l080502EF:
			ecx = (word32) *((word32) edx + 1);
			ebx_398 = (word32) edx + 1;
			if ((byte) ecx == 0x00)
				break;
		}
	} while (ebx_398 != dwLoc48_1098);
	if (ebx_398 != esi_107)
	{
		if (dwArg08 != 0x00)
			*dwArg08 = ebx_398;
		if (dwLoc40_781 == 0x00)
		{
			Eq_2 edx_619 = -eax_1105;
			if (dwLoc24_1049 != 0x00)
				eax_1105 = edx_619;
			ecxOut = ecx;
			edxOut = edx_619;
			return eax_1105;
		}
		gs->tFFFFFFE0.u0 = 0x22;
		eax_1104.u0 = ~0x00;
l080503A3:
		ecxOut = ecx;
		edxOut = edx;
		return eax_1104;
	}
l0805050D:
	ecx = dwArg08;
	if (dwArg08 != 0x00)
	{
		if (esi_107 - dwArg04 <= 0x01)
		{
l0805053C:
			*dwArg08 = dwArg04;
			eax_1104.u0 = 0x00;
			goto l080503A3;
		}
		edx = (int32) *((word32) esi_107 - 1);
		if (g_ptr80CE084[edx] != 88 || *((word32) esi_107 - 2) != 0x30)
			goto l0805053C;
		*dwArg08 = esi_107 - 0x01;
	}
	eax_1104.u0 = 0x00;
	goto l080503A3;
}

// 08050710: void __strtoul_l(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack (ptr32 Eq_11467) dwArg10)
void __strtoul_l(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_11467 * dwArg10)
{
	word32 ecx_44;
	word32 edx_45;
	____strtoul_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, dwArg10, out ecx_44, out edx_45);
}

// 08050740: Register Eq_2 __correctly_grouped_prefixmb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      ____strtoul_l_internal
//      ____strtol_l_internal
Eq_2 __correctly_grouped_prefixmb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 != 0x00)
	{
		word32 edx_768;
		word32 ecx_767;
		Eq_2 eax_26 = strlen(dwArg0C, out ecx_767, out edx_768);
		if (dwArg08 > dwArg04)
		{
l08050784:
			Eq_2 eax_45 = dwArg08 - 0x01;
			if (dwArg04 <= dwArg08 - 0x01)
			{
				byte bl_52 = *dwArg0C;
				do
				{
					if (*((word32) eax_26 + (eax_45 - 0x01)) == bl_52)
					{
						Eq_11941 dl_65 = *((word32) dwArg0C + 1);
						if (dl_65 != 0x00)
						{
							if (Mem54[eax_45 - 0x02 + eax_26:byte] == dl_65)
							{
								byte * edx_71 = (word32) dwArg0C + 2;
								byte * ebx_73 = (word32) eax_45 + (eax_26 - 0x03);
								do
								{
									byte cl_78 = *edx_71;
									if (cl_78 == 0x00)
										goto l08050806;
									++edx_71;
									ebx_73 = ebx_769 - 0x01;
									ebx_769 = ebx_73;
								} while (*ebx_769 == cl_78);
							}
							goto l080507B0;
						}
l08050806:
						Eq_2 eax_102 = eax_45;
						if (dwArg04 > eax_45)
							return dwArg08;
						Eq_12019 (* edx_107)[] = (int32) *dwArg10;
						Eq_12019 (* ecx_108)[] = dwArg08 - eax_45;
						if (ecx_108 != edx_107 + 0x01)
						{
							word32 ebx_295 = eax_45 + (edx_107 + 0x01);
							if (ecx_108 > edx_107 + 0x01)
								eax_102 = ebx_295;
							dwArg08 = eax_102;
							goto l0805082A;
						}
						Eq_2 edi_130;
						ci8 al_131;
						Eq_2 eax_114 = eax_45 - (Eq_12019 (*)[]) 0x01;
						ci8 al_119 = *((word32) dwArg10 + 1);
						Eq_2 dwLoc28_390 = dwArg10;
						Eq_2 edi_113 = dwArg10;
						Eq_2 dwLoc2C_391 = eax_114;
						word32 esi_116 = (word32) bl_52;
						ci8 bLoc2D_395 = al_119;
						if (al_119 != 0x00)
						{
l08050890:
							al_131 = bLoc2D_395;
							dwLoc28_390 = (word32) edi_113 + 1;
							edi_130 = dwLoc2C_391;
							if (bLoc2D_395 != 0x7F)
								goto l080508A8;
						}
						else
						{
l08050930:
							ci8 al_224 = *dwLoc28_390;
							edi_130 = dwLoc2C_391;
							bLoc2D_395 = al_224;
							al_131 = al_224;
							if (al_224 != 0x7F)
							{
l080508A8:
								if (al_131 >= 0x00)
								{
									if (dwArg04 > dwLoc2C_391)
										return dwArg08;
									edi_130 = dwLoc2C_391;
									do
									{
										Eq_12019 al_148 = (byte) esi_116;
										if (al_148 == 0x00)
										{
l080508F8:
											if (dwArg04 > edi_130)
												break;
											if (dwLoc2C_391 - edi_130 != (int32) bLoc2D_395)
												goto l080509C8;
l08050915:
											ci8 al_214 = *((word32) dwLoc28_390 + 1);
											edi_113 = dwLoc28_390;
											dwLoc2C_391 = edi_130 - (Eq_12019 (*)[]) 0x01;
											bLoc2D_395 = al_214;
											if (al_214 == 0x00)
												goto l08050930;
											goto l08050890;
										}
										if (al_148 == Mem139[(edi_130 - 0x01) + eax_26:byte])
										{
											byte * eax_160 = (word32) dwArg0C + 1;
											word32 ecx_162 = edi_130 + (eax_26 - 0x02);
											do
											{
												Eq_12019 dl_166 = *eax_160;
												if (dl_166 == 0x00)
													goto l080508F8;
												++eax_160;
												ecx_162 = ecx_770 - 0x01;
												ecx_770 = ecx_162;
											} while (ecx_770[0].t0000 == dl_166);
										}
										edi_130 -= (Eq_12019 (*)[]) 0x01;
									} while (edi_130 != dwArg04 - 0x01);
									if ((int32) bLoc2D_395 >= dwLoc2C_391 - edi_130)
										return dwArg08;
l080509C8:
									dwArg08 = eax_114;
l0805082A:
									if (dwArg04 >= dwArg08)
										goto l08050838;
									goto l08050784;
								}
							}
						}
						if (dwArg04 > dwLoc2C_391)
							return dwArg08;
						do
						{
							Eq_12019 al_242 = (byte) esi_116;
							if (al_242 == 0x00)
							{
l08050994:
								if (dwArg04 > edi_130)
									return dwArg08;
								goto l08050915;
							}
							if (al_242 == Mem231[(edi_130 - 0x01) + eax_26:byte])
							{
								byte * eax_254 = (word32) dwArg0C + 1;
								word32 ecx_256 = edi_130 + (eax_26 - 0x02);
								do
								{
									Eq_12019 dl_260 = *eax_254;
									if (dl_260 == 0x00)
										goto l08050994;
									++eax_254;
									ecx_256 = ecx_771 - 0x01;
									ecx_771 = ecx_256;
								} while (ecx_771[0].t0000 == dl_260);
							}
							edi_130 -= (Eq_12019 (*)[]) 0x01;
						} while (edi_130 != dwArg04 - 0x01);
						return dwArg08;
					}
l080507B0:
					--eax_45;
				} while (eax_45 != dwArg04 - 0x01);
			}
		}
		else
		{
l08050838:
			Eq_2 eax_310 = dwArg08;
			if (dwArg08 < dwArg04)
				eax_310 = dwArg04;
			dwArg08 = eax_310;
		}
	}
	return dwArg08;
}

// 08050A00: Register word32 _IO_printf(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      main
word32 _IO_printf(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 ebp_22;
	word32 ecx_41;
	word32 edx_42;
	word32 ebx_43;
	word32 edi_44;
	vfprintf(ebx, gs, _IO_stdout, dwArg04, fp + 0x08, out ecx_41, out edx_42, out ebx_43, out ebp_22, out edi_44);
	return ebp_22;
}

// 08050A30: Register word32 ___asprintf()
// Called from:
//      __assert_fail_base
//      __dcigettext
//      __dlerror
word32 ___asprintf()
{
	return vasprintf(gs, dwArg04);
}

// 08050A60: Register Eq_2 locked_vfxprintf(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_12153 ebxOut, Register out Eq_979 ediOut)
// Called from:
//      __fxprintf
//      __fxprintf_nocancel
Eq_2 locked_vfxprintf(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_12153 & ebxOut, union Eq_979 & ediOut)
{
	Eq_2 eax_157;
	ui32 eax_27 = gs->dw0014;
	if (*((word32) eax + 0x0068) <= 0x00)
	{
		word32 ebx_396;
		word32 edi_398;
		word32 ebp_397;
		word32 edx_395;
		word32 ecx_394;
		eax_157 = vfprintf(0x080CE000, gs, eax, edx, ecx, out ecx_394, out edx_395, out ebx_396, out ebp_397, out edi_398);
		goto l08050B3D;
	}
	word32 edx_400;
	word32 ecx_399;
	Eq_2 eax_52 = strlen(edx, out ecx_399, out edx_400);
	if (eax_52 > 0x3FFFFFFE)
	{
		gs->tFFFFFFE0.u0 = 0x4B;
		eax_157.u0 = ~0x00;
		goto l08050B3D;
	}
	Eq_2 ecx_66 = ((word32) eax_52 + 1) * 0x04;
	up32 eax_72 = __libc_alloca_cutoff(gs, ecx_66);
	struct Eq_12201 * esp_169 = fp - 0x3C;
	if (ecx_66 > 0x1000 && eax_72 == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_403;
		word32 edi_407;
		word32 esi_406;
		word32 ecx_402;
		word32 ebp_405;
		word32 ebx_404;
		Eq_2 eax_89 = __libc_malloc(gs, stackArg0, ecx_66, out ecx_402, out edx_403, out ebx_404, out ebp_405, out esi_406, out edi_407);
		if (eax_89 != 0x00)
		{
			word32 ecx_418;
			Eq_2 eax_111 = __mbsrtowcs(gs, fp - 0x28, out ecx_418);
			if (eax_111 != ~0x00)
			{
				word32 ecx_422;
				word32 edx_423;
				eax_111 = __vfwprintf(gs, eax, eax_89, ecx, out ecx_422, out edx_423);
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_420;
			word32 edx_421;
			free(gs, stackArg0, eax_89, out ecx_420, out edx_421);
			eax_157 = eax_111;
l08050B3D:
			Eq_12153 ebx_268 = eax_27 ^ gs->dw0014;
			if (ebx_268 != 0x00)
			{
				word32 ecx_415;
				word32 edx_416;
				__stack_chk_fail(out ecx_415, out edx_416);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 eax_291 = __fxprintf(gs, stackArg4);
				ebxOut = ebx_268;
				ediOut.u0 = <invalid>;
				return eax_291;
			}
			else
			{
				ebxOut = ebx;
				ediOut.u0 = <invalid>;
				return eax_157;
			}
		}
	}
	else
	{
		struct Eq_12201 * edx_164 = fp - 0x3C - ((word32) ecx_66 + 27 & ~0x0FFF);
		ui32 eax_165 = (word32) ecx_66 + 27 & ~0x0F;
		if (fp - 0x3C != edx_164)
		{
			do
			{
				esp_169 -= 0x1000;
				esp_169->dw0FFC = esp_169->dw0FFC;
			} while (esp_169 != edx_164);
		}
		if ((eax_165 & 0x0FFF) != 0x00)
		{
			esp_169 -= eax_165 & 0x0FFF;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_169 - 0x04)[(eax_165 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_169 - 0x04)[(eax_165 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_12265 * esp_200 = esp_169 - 4;
		esp_200->ptr0000 = fp - 0x28;
		esp_200->tFFFFFFFC = (word32) eax_52 + 1;
		esp_200->tFFFFFFF8 = fp - 0x30;
		Eq_12282 ecx_193 = (char *) esp_169 + 0x0F;
		esp_200->tFFFFFFF4 = ecx_193 & ~0x0F;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg16 = <invalid>;
		word32 ecx_409;
		if (__mbsrtowcs(gs, stackArg16, out ecx_409) != ~0x00)
		{
			esp_200->tFFFFFFFC = ecx;
			esp_200->tFFFFFFF8 = ecx_193 & ~0x0F;
			esp_200->tFFFFFFF4 = eax;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			word32 ecx_413;
			word32 edx_414;
			eax_157 = __vfwprintf(gs, stackArg4, stackArg8, stackArg12, out ecx_413, out edx_414);
			goto l08050B3D;
		}
	}
	eax_157.u0 = ~0x00;
	goto l08050B3D;
}

// 08050C20: Register Eq_2 __fxprintf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __assert_fail_base
//      locked_vfxprintf
//      __malloc_assert
Eq_2 __fxprintf(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ebx_15 = dwArg04;
	if (dwArg04 == 0x00)
		ebx_15 = _IO_stderr;
	ui32 eax_23 = *ebx_15;
	if ((eax_23 & 0x8000) == 0x00)
	{
		Eq_2 edx_30 = *((word32) ebx_15 + 72);
		Eq_2 edi_33 = gs->t0008;
		if (*((word32) edx_30 + 8) != edi_33)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_43;
			if (!__cmpxchg(*edx_30, 0x01, eax_23 & 0x8000, out eax_43))
				__lll_lock_wait_private(eax_43, edx_30, gs);
			edx_30 = *((word32) ebx_15 + 72);
			*((word32) edx_30 + 8) = edi_33;
		}
		*((word32) edx_30 + 4) = (word32) *((word32) edx_30 + 4) + 1;
	}
	word32 ebx_178;
	word32 edi_179;
	Eq_2 eax_90 = locked_vfxprintf(ebx_15, fp + 0x0C, dwArg08, gs, out ebx_178, out edi_179);
	if ((*ebx_15 & 0x8000) == 0x00)
	{
		Eq_2 edx_98 = *((word32) ebx_15 + 72);
		Eq_2 v15_99 = *((word32) edx_98 + 4) - 0x01;
		*((word32) edx_98 + 4) = v15_99;
		if (v15_99 == 0x00)
		{
			((word32) edx_98 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v16_108 = *edx_98 - 0x01;
			*edx_98 = v16_108;
			if (v16_108 != 0x00)
				__lll_unlock_wake_private(edx_98, eax_90, edx_98, gs);
		}
	}
	return eax_90;
}

// 08050CE0: void __fxprintf_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void __fxprintf_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebx_15 = dwArg04;
	if (dwArg04 == 0x00)
		ebx_15 = _IO_stderr;
	ui32 eax_23 = *ebx_15;
	if ((eax_23 & 0x8000) == 0x00)
	{
		Eq_2 edx_30 = *((word32) ebx_15 + 72);
		Eq_2 edi_33 = gs->t0008;
		if (*((word32) edx_30 + 8) != edi_33)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_43;
			if (!__cmpxchg(*edx_30, 0x01, eax_23 & 0x8000, out eax_43))
				__lll_lock_wait_private(eax_43, edx_30, gs);
			edx_30 = *((word32) ebx_15 + 72);
			*((word32) edx_30 + 8) = edi_33;
		}
		*((word32) edx_30 + 4) = (word32) *((word32) edx_30 + 4) + 1;
	}
	*((word32) ebx_15 + 60) |= 0x02;
	struct Eq_12504 * ebx_90;
	word32 edi_92;
	Eq_2 eax_88 = locked_vfxprintf(ebx_15, fp + 0x0C, dwArg08, gs, out ebx_90, out edi_92);
	ebx_90->dw003C = edi_92;
	if ((ebx_90->dw0000 & 0x8000) == 0x00)
	{
		Eq_2 edx_105 = ebx_90->t0048;
		Eq_2 v15_106 = *((word32) edx_105 + 4) - 0x01;
		*((word32) edx_105 + 4) = v15_106;
		if (v15_106 == 0x00)
		{
			((word32) edx_105 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v16_115 = *edx_105 - 0x01;
			*edx_105 = v16_115;
			if (v16_115 != 0x00)
				__lll_unlock_wake_private(edx_105, eax_88, edx_105, gs);
		}
	}
}

// 08050DB0: void __new_fclose(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      read_alias_file
//      __gconv_read_conf
//      __readonly_area
void __new_fclose(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ecx_135;
	ui32 eax_21 = *dwArg04;
	ptr32 esp_133 = fp - 44;
	if ((SLICE(eax_21, byte, 8) & 0x20) == 0x00)
	{
		ecx_135 = eax_21 & 0x8000;
		if ((eax_21 & 0x8000) != 0x00)
			goto l08050DE6;
	}
	else
	{
		_IO_un_link(dwArg04);
		eax_21 = (ui32) *dwArg04;
		esp_133 = fp - 0x28;
		if ((SLICE(eax_21, byte, 8) & 0x80) != 0x00)
			goto l08050EBC;
	}
	Eq_2 edx_49 = *((word32) dwArg04 + 72);
	Eq_2 ebx_52 = gs->t0008;
	if (*((word32) edx_49 + 8) != ebx_52)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_63;
		if (!__cmpxchg(*edx_49, 0x01, 0x00, out eax_63))
			__lll_lock_wait_private(eax_63, edx_49, gs);
		edx_49 = *((word32) dwArg04 + 72);
		eax_21 = (ui32) *dwArg04;
		*((word32) edx_49 + 8) = ebx_52;
	}
	*((word32) edx_49 + 4) = (word32) *((word32) edx_49 + 4) + 1;
l08050EBC:
	ecx_135 = eax_21 & 0x8000;
	if ((SLICE(eax_21, byte, 8) & 0x20) != 0x00)
	{
		struct Eq_12768 * esp_101 = esp_133 - 0x0C;
		esp_101->tFFFFFFFC = dwArg04;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		_IO_file_close_it(stackArg4);
		ui32 edx_131 = *dwArg04;
		esp_133 = (char *) &esp_101->tFFFFFFFC + 16;
		ecx_135 = edx_131 & 0x8000;
		if ((edx_131 & 0x8000) != 0x00)
		{
l08050DF5:
			Eq_2 ebx_178 = *((word32) dwArg04 + 0x0094);
			if (ebx_178 >= 135066356)
			{
				word32 edx_488;
				word32 ecx_487;
				_IO_vtable_check(out ecx_487, out edx_488);
			}
			struct Eq_12680 * esp_212 = esp_133 - 0x08;
			esp_212->tFFFFFFFC.u0 = 0x00;
			esp_212->tFFFFFFF8 = dwArg04;
			(*((word32) ebx_178 + 8))();
			struct Eq_12693 * esp_229 = (char *) &esp_212->tFFFFFFFC + 0x0C;
			if (*((word32) dwArg04 + 0x0068) <= 0x00)
			{
				if (*((word32) dwArg04 + 36) != 0x00)
				{
					esp_212->tFFFFFFF8 = dwArg04;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					_IO_free_backup_area(stackArg4);
					esp_229 = (struct Eq_12693 *) ((char *) &esp_212->tFFFFFFFC + 0x0C);
				}
			}
			else
			{
				Eq_2 ebx_232 = *((word32) dwArg04 + 84);
				if (gs->t000C != 0x00)
					__lock();
				word32 eax_241;
				if (!__cmpxchg(__gconv_lock, 0x01, 0x00, out eax_241))
					__lll_lock_wait_private(eax_241, 0x080CFF80, gs);
				esp_212->tFFFFFFF8 = *((word32) ebx_232 + 36);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				word32 edx_496;
				__gconv_release_step(gs, stackArg4, out edx_496);
				esp_212->tFFFFFFFC = *((word32) ebx_232 + 76);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 edx_280;
				Eq_2 ecx_281 = __gconv_release_step(gs, stackArg4, out edx_280);
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v23_288 = __gconv_lock - 0x01;
				__gconv_lock = v23_288;
				if (v23_288 != 0x00)
					__lll_unlock_wake_private(0x080CFF80, ecx_281, edx_280, gs);
				esp_229 = (struct Eq_12693 *) ((char *) &esp_212->tFFFFFFFC + 20);
			}
			if (_IO_stdin != dwArg04 && (_IO_stdout != dwArg04 && _IO_stderr != dwArg04))
			{
				esp_229->tFFFFFFF0 = dwArg04;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_493;
				word32 edx_494;
				free(gs, stackArg0, stackArg4, out ecx_493, out edx_494);
			}
			return;
		}
l08050EF0:
		Eq_2 edx_152 = *((word32) dwArg04 + 72);
		Eq_2 v19_153 = *((word32) edx_152 + 4) - 0x01;
		*((word32) edx_152 + 4) = v19_153;
		if (v19_153 == 0x00)
		{
			((word32) edx_152 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v20_164 = *edx_152 - 0x01;
			*edx_152 = v20_164;
			if (v20_164 != 0x00)
				__lll_unlock_wake_private(edx_152, ecx_135, edx_152, gs);
		}
		goto l08050DF5;
	}
l08050DE6:
	if (ecx_135 != 0x00)
		goto l08050DF5;
	goto l08050EF0;
}

// 08050FA0: void fflush(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __assert_fail_base
//      __malloc_assert
void fflush(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
		_IO_flush_all();
	else
	{
		ui32 eax_37 = *dwArg04;
		if ((eax_37 & 0x8000) == 0x00)
		{
			Eq_2 edx_42 = *((word32) dwArg04 + 72);
			Eq_2 ebx_44 = gs->t0008;
			if (*((word32) edx_42 + 8) != ebx_44)
			{
				if (gs->t000C != 0x00)
					__lock();
				word32 eax_54;
				if (!__cmpxchg(*edx_42, 0x01, eax_37 & 0x8000, out eax_54))
					__lll_lock_wait_private(eax_54, edx_42, gs);
				edx_42 = *((word32) dwArg04 + 72);
				*((word32) edx_42 + 8) = ebx_44;
			}
			*((word32) edx_42 + 4) = (word32) *((word32) edx_42 + 4) + 1;
		}
		Eq_2 ebx_79 = *((word32) dwArg04 + 0x0094);
		if (ebx_79 >= 135066356)
		{
			word32 ecx_238;
			word32 edx_239;
			_IO_vtable_check(out ecx_238, out edx_239);
		}
		word32 eax_121;
		word32 ecx_123;
		(*((word32) ebx_79 + 48))();
		Eq_2 edx_132 = -(uint32) (int8) (eax_121 != 0x00);
		if ((*dwArg04 & 0x8000) == 0x00)
		{
			Eq_2 ecx_136 = *((word32) dwArg04 + 72);
			Eq_2 v18_137 = *((word32) ecx_136 + 4) - 0x01;
			*((word32) ecx_136 + 4) = v18_137;
			if (v18_137 == 0x00)
			{
				((word32) ecx_136 + 8)->u0 = 0x00;
				if (gs->t000C != 0x00)
					__lock();
				word32 v19_146 = *ecx_136 - 0x01;
				*ecx_136 = v19_146;
				if (v19_146 != 0x00)
					__lll_unlock_wake_private(ecx_136, ecx_136, edx_132, gs);
			}
		}
	}
}

// 080510A0: void __fopen_maybe_mmap(Stack (ptr32 Eq_13013) dwArg04)
void __fopen_maybe_mmap(struct Eq_13013 * dwArg04)
{
	if ((dwArg04->b003C & 0x01) != 0x00 && (dwArg04->b0000 & 0x08) != 0x00)
	{
		ptr32 ecx_17;
		if (dwArg04->dw0068 > 0x00)
			ecx_17 = 0x080CEFA0;
		else
			ecx_17 = 0x080CF0C0;
		dwArg04->ptr0094 = ecx_17;
		dwArg04->ptr0058->ptr00B0 = 0x080CEFA0;
	}
}

// 080510F0: void __fopen_internal()
// Called from:
//      __new_fopen
void __fopen_internal()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 esi_220;
	word32 edi_221;
	word32 ebp_219;
	word32 ebx_218;
	word32 ecx_216;
	word32 edx_217;
	Eq_2 eax_19 = __libc_malloc(gs, stackArg0, 344, out ecx_216, out edx_217, out ebx_218, out ebp_219, out esi_220, out edi_221);
	if (eax_19 == 0x00)
		return;
	*((word32) eax_19 + 72) = (word32) eax_19 + 0x0098;
	_IO_no_init(eax_19, 0x00, 0x00, (word32) eax_19 + 0x00A4, 0x080CF060);
	((word32) eax_19 + 0x0094)->u0 = 0x080CF180;
	_IO_new_file_init_internal(eax_19);
	if (_IO_file_fopen(gs, eax_19, dwArg08) == 0x00)
	{
		_IO_un_link(eax_19);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_223;
		word32 edx_224;
		free(gs, stackArg0, eax_19, out ecx_223, out edx_224);
	}
	else if ((*((word32) eax_19 + 60) & 0x01) != 0x00 && (*eax_19 & 0x08) != 0x00)
	{
		Eq_2 edx_126;
		if (*((word32) eax_19 + 0x0068) > 0x00)
			edx_126.u0 = 0x080CEFA0;
		else
			edx_126.u0 = 0x080CF0C0;
		*((word32) eax_19 + 0x0094) = edx_126;
		((word32) *((word32) eax_19 + 88) + 0x00B0)->u0 = 0x080CEFA0;
	}
}

// 080511E0: Register Eq_2 __new_fopen()
// Called from:
//      read_alias_file
//      __gconv_read_conf
//      __readonly_area
Eq_2 __new_fopen()
{
	__fopen_internal();
	return <invalid>;
}

// 080511FA: void __x86.get_pc_thunk.dx()
void __x86.get_pc_thunk.dx()
{
}

// 08051200: void _IO_puts(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      main
void _IO_puts(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 edx_330;
	word32 ecx_329;
	Eq_2 eax_24 = strlen(dwArg04, out ecx_329, out edx_330);
	Eq_2 esi_31 = _IO_stdout;
	Eq_2 esp_105 = fp - 44;
	Eq_2 eax_34 = *esi_31;
	Eq_2 ecx_113 = esi_31;
	if ((eax_34 & 0x8000) == 0x00)
	{
		Eq_2 edx_40 = *((word32) esi_31 + 72);
		Eq_2 ebx_42 = gs->t0008;
		if (*((word32) edx_40 + 8) != ebx_42)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_52;
			if (!__cmpxchg(*edx_40, 0x01, eax_34 & 0x8000, out eax_52))
				__lll_lock_wait_private(eax_52, edx_40, gs);
			edx_40 = *((word32) esi_31 + 72);
			ecx_113 = _IO_stdout;
			*((word32) edx_40 + 8) = ebx_42;
		}
		*((word32) edx_40 + 4) = (word32) *((word32) edx_40 + 4) + 1;
	}
	Eq_2 eax_80 = *((word32) ecx_113 + 0x0068);
	if (eax_80 == 0x00)
		((word32) ecx_113 + 0x0068)->u0 = ~0x00;
	else if (eax_80 != ~0x00)
		goto l08051329;
	Eq_2 eax_89 = *((word32) ecx_113 + 0x0094);
	if (eax_89 >= 135066356)
	{
		word32 edx_332;
		word32 ecx_331;
		_IO_vtable_check(out ecx_331, out edx_332);
		esp_105.u0 = <invalid>;
		ecx_113 = _IO_stdout;
	}
	struct Eq_13223 * esp_124 = esp_105 - 0x04;
	esp_124->tFFFFFFFC = eax_24;
	esp_124->tFFFFFFF8 = dwArg04;
	esp_124->tFFFFFFF4 = ecx_113;
	Eq_2 eax_150;
	(*((word32) eax_89 + 28))();
	if (eax_24 == eax_150)
	{
		Eq_2 eax_157 = _IO_stdout;
		Eq_2 edx_158 = *((word32) eax_157 + 20);
		if (edx_158 < *((word32) eax_157 + 24))
		{
			*((word32) eax_157 + 20) = (word32) edx_158 + 1;
			*edx_158 = 0x0A;
			ecx_113 = (word32) edx_158 + 1;
l080512E4:
			if ((*esi_31 & 0x8000) == 0x00)
			{
				Eq_2 edx_198 = *((word32) esi_31 + 72);
				Eq_2 v19_199 = *((word32) edx_198 + 4) - 0x01;
				*((word32) edx_198 + 4) = v19_199;
				if (v19_199 == 0x00)
				{
					((word32) edx_198 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v20_211 = *edx_198 - 0x01;
					*edx_198 = v20_211;
					if (v20_211 != 0x00)
						__lll_unlock_wake_private(edx_198, ecx_113, edx_198, gs);
				}
			}
			return;
		}
		esp_124->tFFFFFFF8.u0 = 0x0A;
		esp_124->tFFFFFFF4 = eax_157;
		word32 edx_333;
		if (__overflow(esp_124->tFFFFFFF4, esp_124->tFFFFFFF8, out ecx_113, out edx_333) != ~0x00)
			goto l080512D6;
	}
l08051329:
	goto l080512E4;
}

// 08051360: Register Eq_2 adjust_wide_data(Register Eq_2 eax, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_13353) esiOut)
// Called from:
//      _IO_wfile_seekoff
Eq_2 adjust_wide_data(Eq_2 eax, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_13353 & esiOut)
{
	Eq_2 eax_115;
	Eq_2 ecx_103;
	Eq_2 eax_110;
	Eq_2 edi_21 = *((word32) eax + 84);
	ui32 eax_23 = gs->dw0014;
	int32 eax_31;
	(*((word32) edi_21 + 16))();
	if ((byte) edx != 0x01 && eax_31 > 0x00)
	{
		ecx_103 = *((word32) eax + 88);
		eax_110 = (word32) *((word32) ecx_103 + 4) + (int32) ((int64) (*((word32) eax + 4) - *((word32) eax + 0x0C)) /32 eax_31) * 0x04;
		*((word32) ecx_103 + 4) = eax_110;
l080513EC:
		*ecx_103 = eax_110;
		eax_115.u0 = 0x00;
	}
	else
	{
		Eq_2 edx_44 = *((word32) eax + 0x0C);
		while (true)
		{
			Eq_2 eax_50 = *((word32) eax + 88);
			Eq_2 ebx_52 = *((word32) eax_50 + 48);
			*((word32) eax_50 + 52) = *((word32) eax_50 + 44);
			*((word32) eax_50 + 56) = ebx_52;
			word32 eax_84;
			(*((word32) edi_21 + 0x0C))();
			if (eax_84 == 0x02)
				break;
			if (eax_84 != 0x01)
			{
				ecx_103 = *((word32) eax + 88);
				eax_110 = *((word32) ecx_103 + 4);
				goto l080513EC;
			}
			edx_44 = *((word32) eax + 0x0C);
		}
		*eax |= 0x20;
		eax_115.u0 = ~0x00;
	}
	if ((eax_23 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_235;
		word32 edx_236;
		__stack_chk_fail(out ecx_235, out edx_236);
		struct Eq_13353 * esi_143;
		Eq_2 eax_138 = _IO_wfile_underflow(eax, gs, dwArg04, out esi_143);
		esiOut = esi_143;
		return eax_138;
	}
	else
	{
		esiOut = esi;
		return eax_115;
	}
}

// 08051430: Register word32 _IO_wfile_underflow(Register Eq_2 esi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 esiOut)
// Called from:
//      adjust_wide_data
word32 _IO_wfile_underflow(Eq_2 esi, struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & esiOut)
{
	word32 eax_107;
	ui32 eax_23 = *dwArg04;
	struct Eq_13474 * ebp_189 = fp - 4;
	byte al_28 = (byte) eax_23;
	if ((al_28 & 0x10) != 0x00)
	{
l08051566:
		eax_107 = ~0x00;
		goto l08051530;
	}
	if ((al_28 & 0x04) != 0x00)
	{
		*dwArg04 = eax_23 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		eax_107 = ~0x00;
		goto l08051530;
	}
	Eq_2 eax_45 = *((word32) dwArg04 + 88);
	Eq_2 edx_46 = *eax_45;
	if (edx_46 < *((word32) eax_45 + 4))
	{
		eax_107 = (word32) *edx_46;
		goto l08051530;
	}
	Eq_2 eax_140;
	Eq_2 edx_52 = *((word32) dwArg04 + 84);
	Eq_2 edx_54 = *((word32) dwArg04 + 4);
	Eq_2 ecx_55 = *((word32) dwArg04 + 8);
	if (edx_54 < ecx_55)
	{
		Eq_2 ebx_64 = *((word32) eax_45 + 24);
		Eq_2 edi_66 = *((word32) eax_45 + 48);
		*((word32) eax_45 + 52) = *((word32) eax_45 + 44);
		*eax_45 = ebx_64;
		*((word32) eax_45 + 8) = ebx_64;
		*((word32) eax_45 + 56) = edi_66;
		word32 eax_93;
		(*((word32) edx_52 + 0x0C))();
		Eq_2 edx_99 = *((word32) dwArg04 + 4);
		*((word32) dwArg04 + 4) = edx_54;
		*((word32) dwArg04 + 0x0C) = edx_99;
		Eq_2 edx_103 = *((word32) dwArg04 + 88);
		esi = (word32) eax_45 + 4;
		dwLoc80 = ecx_55;
		Eq_2 ebx_104 = *edx_103;
		if (ebx_104 < *((word32) edx_103 + 4))
		{
			eax_107 = (word32) *ebx_104;
			goto l08051530;
		}
		if (eax_93 == 0x02)
		{
			gs->tFFFFFFE0.u0 = 0x54;
			*dwArg04 |= 0x20;
			eax_107 = ~0x00;
			goto l08051530;
		}
		word32 edx_975;
		memmove(*((word32) dwArg04 + 28), edx_54, *((word32) dwArg04 + 8) - edx_54, out edx_975);
		eax_140 = *((word32) dwArg04 + 28);
		word32 edx_144 = Mem131[dwArg04 + 0x08:word32] + eax_140 - Mem131[dwArg04 + 0x04:word32];
		*((word32) dwArg04 + 0x0C) = eax_140;
		*((word32) dwArg04 + 8) = edx_144;
		*((word32) dwArg04 + 4) = eax_140;
	}
	else
	{
		eax_140 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 8) = eax_140;
		*((word32) dwArg04 + 4) = eax_140;
		*((word32) dwArg04 + 0x0C) = eax_140;
	}
	Eq_2 esp_160 = fp - 0x6C;
	if (eax_140 == 0x00)
	{
		Eq_2 eax_156 = *((word32) dwArg04 + 36);
		if (eax_156 != 0x00)
		{
			word32 edx_987;
			word32 ecx_986;
			free(gs, dwLoc80, eax_156, out ecx_986, out edx_987);
			*dwArg04 &= ~0x0100;
			esp_160 = fp - 0x68;
		}
		struct Eq_14142 * esp_184 = esp_160 - 0x0C;
		esp_184->tFFFFFFFC = dwArg04;
		word32 edi_985;
		_IO_doallocbuf(esp_184->tFFFFFFFC, out ebp_189, out esi, out edi_985);
		eax_140 = *((word32) esi + 28);
		*((word32) esi + 8) = eax_140;
		*((word32) esi + 4) = eax_140;
		*((word32) esi + 0x0C) = eax_140;
		esp_160 = (char *) &esp_184->tFFFFFFFC + 16;
	}
	Eq_2 edx_208 = ebp_189->tFFFFFFC4;
	*((word32) edx_208 + 24) = eax_140;
	*((word32) edx_208 + 20) = eax_140;
	*((word32) edx_208 + 16) = eax_140;
	Eq_2 eax_213 = *((word32) edx_208 + 88);
	if (*((word32) eax_213 + 24) == 0x00)
	{
		Eq_2 eax_218 = *((word32) eax_213 + 32);
		if (eax_218 != 0x00)
		{
			struct Eq_13978 * esp_223 = esp_160 - 0x0C;
			esp_223->tFFFFFFFC = eax_218;
			word32 edx_982;
			word32 ecx_981;
			free(gs, esp_223->tFFFFFFF8, esp_223->tFFFFFFFC, out ecx_981, out edx_982);
			Eq_2 eax_238 = ebp_189->tFFFFFFC4;
			*eax_238 &= ~0x0100;
			esp_160 = (char *) &esp_223->tFFFFFFFC + 20;
		}
		struct Eq_13960 * esp_245 = esp_160 - 0x0C;
		esp_245->tFFFFFFFC = ebp_189->tFFFFFFC4;
		_IO_wdoallocbuf(esp_245->tFFFFFFFC);
		esp_160 = (char *) &esp_245->tFFFFFFFC + 16;
	}
	struct Eq_13692 * ecx_262 = ebp_189->ptrFFFFFFA8;
	ebp_189->dwFFFFFFB0 = 0x080CEFA0;
	ebp_189->ptrFFFFFFB4 = 0x0354;
	if ((*ebp_189->tFFFFFFC4 & 0x0202) == 0x00)
	{
l08051660:
		Eq_2 ebx_418 = ebp_189->tFFFFFFC4;
		struct Eq_13718 * esp_422 = esp_160 - 0x0C;
		esp_422->tFFFFFFFC = ebx_418;
		word32 ecx_976;
		_IO_switch_to_get_mode(esp_422->tFFFFFFFC, out ecx_976);
		Eq_2 eax_434 = *((word32) ebx_418 + 88);
		ebp_189->tFFFFFFC4 = ebx_418;
		ebp_189->tFFFFFFC0.u0 = 0x00;
		Eq_2 edx_439 = *((word32) eax_434 + 24);
		*eax_434 = edx_439;
		*((word32) eax_434 + 8) = edx_439;
		*((word32) eax_434 + 4) = edx_439;
		*((word32) eax_434 + 20) = edx_439;
		*((word32) eax_434 + 16) = edx_439;
		*((word32) eax_434 + 0x0C) = edx_439;
		ebp_189->tFFFFFFAC = ebp_189 - 0x30;
		Eq_2 esp_435 = (char *) &esp_422->tFFFFFFFC + 16;
		while (true)
		{
			Eq_2 ebx_451 = *((word32) ebp_189->tFFFFFFC4 + 0x0094);
			if (ebx_451 - ebp_189->dwFFFFFFB0 >= ebp_189->ptrFFFFFFB4)
			{
				word32 ecx_983;
				word32 edx_984;
				_IO_vtable_check(out ecx_983, out edx_984);
				esp_435.u0 = <invalid>;
			}
			Eq_2 edi_465 = ebp_189->tFFFFFFC4;
			Eq_2 eax_469 = *((word32) edi_465 + 32);
			Eq_2 edx_470 = *((word32) edi_465 + 8);
			ebp_189->tFFFFFFBC = eax_469;
			struct Eq_14031 * esp_468 = esp_435 - 0x04;
			Eq_2 eax_472 = eax_469 - edx_470;
			esp_468->tFFFFFFFC = eax_472;
			esp_468->tFFFFFFF8 = edx_470;
			esp_468->tFFFFFFF4 = edi_465;
			Eq_2 eax_487;
			(*((word32) ebx_451 + 56))();
			if (eax_487 <= 0x00)
				break;
			Eq_2 ebx_519 = ebp_189->tFFFFFFC4;
			Eq_2 ecx_521 = *((word32) ebx_519 + 76);
			word32 edx_522 = Mem479[ebx_519 + 0x08:word32] + eax_487;
			*((word32) ebx_519 + 8) = edx_522;
			Eq_2 ebx_525 = *((word32) ebx_519 + 80);
			if ((ecx_521 & ebx_525) != ~0x00)
			{
				ui64 ebx_ecx_880 = SEQ(ebx_525, ecx_521) + SEQ(eax_487 >> 0x1F, eax_487);
				Eq_2 esi_530 = ebp_189->tFFFFFFC4;
				*((word32) esi_530 + 76) = (word32) ebx_ecx_880;
				*((word32) esi_530 + 80) = SLICE(ebx_ecx_880, word32, 32);
			}
			Eq_2 ecx_631;
			word32 eax_623;
			Eq_2 edx_642;
			Eq_2 edi_541 = ebp_189->tFFFFFFC4;
			Eq_2 esi_543 = *((word32) edi_541 + 88);
			Eq_2 ecx_545 = *((word32) esi_543 + 44);
			*((word32) esi_543 + 56) = *((word32) esi_543 + 48);
			Eq_2 ebx_547 = *((word32) edi_541 + 4);
			*((word32) esi_543 + 52) = ecx_545;
			*((word32) edi_541 + 0x0C) = ebx_547;
			if (ebp_189->tFFFFFFC0 == 0x00)
			{
				struct Eq_14205 * eax_644 = ebp_189->ptrFFFFFFB8;
				esp_468->ptr0000 = (word32) esi_543 + 4;
				esp_468->tFFFFFFFC = *((word32) esi_543 + 28);
				esp_468->tFFFFFFF8 = *((word32) esi_543 + 4);
				esp_468->tFFFFFFF4 = ebp_189->tFFFFFFAC;
				esp_468->tFFFFFFF0 = edx_522;
				esp_468->tFFFFFFEC = ebx_547;
				esp_468->ptrFFFFFFE8 = (word32) esi_543 + 44;
				esp_468->ptrFFFFFFE4 = eax_644;
				word32 edx_667;
				eax_644->ptr000C();
				goto l08051785;
			}
			ebp_189->ptrFFFFFF9C = (word32) esi_543 + 44;
			Eq_2 ecx_554 = ebp_189->tFFFFFFC0;
			Eq_2 edx_556 = 0x10 - ecx_554;
			if (edx_556 <= eax_487)
				eax_487 = edx_556;
			Eq_2 edx_562 = ebp_189 - 44;
			ebp_189->tFFFFFFA0 = edx_562;
			esp_468->tFFFFFFFC = eax_487;
			esp_468->tFFFFFFF8 = ebx_547;
			word32 ecx_567 = ecx_554 + edx_562;
			esp_468->tFFFFFFF4 = ecx_567;
			ebp_189->tFFFFFFBC = ecx_567;
			ebp_189->tFFFFFFA4 = eax_487;
			word32 edx_994;
			Eq_2 eax_581 = __mempcpy(esp_468->tFFFFFFF4, esp_468->tFFFFFFF8, esp_468->tFFFFFFFC, out edx_994);
			Eq_2 edx_590 = ebp_189->tFFFFFFA4;
			word32 * ecx_591 = ebp_189->ptrFFFFFF9C;
			esp_468->ptr0000 = (word32) esi_543 + 4;
			Mem596[ebp_189 + -64:word32] = Mem594[ebp_189 + -64:word32] + edx_590;
			Eq_2 edx_598 = ebp_189->tFFFFFFA0;
			esp_468->tFFFFFFFC = *((word32) esi_543 + 28);
			Eq_2 ebx_603 = ebp_189->tFFFFFFC0;
			esp_468->tFFFFFFF8 = *((word32) esi_543 + 4);
			esp_468->tFFFFFFF4 = ebp_189->tFFFFFFAC;
			esp_468->tFFFFFFF0 = eax_581;
			struct Eq_14205 * eax_612 = ebp_189->ptrFFFFFFB8;
			esp_468->tFFFFFFEC = edx_598;
			esp_468->ptrFFFFFFE8 = ecx_591;
			esp_468->ptrFFFFFFE4 = eax_612;
			eax_612->ptr000C();
			if (ebx_603 != 0x00)
			{
				ecx_631 = ebp_189->tFFFFFFD0;
				int32 edx_634 = ecx_631 - ebp_189->tFFFFFFBC;
				if (edx_634 < 0x00)
					edx_634 = 0x00;
				edx_642 = (word32) *((word32) ebp_189->tFFFFFFC4 + 4) + edx_634;
			}
			else
			{
l08051785:
				ecx_631 = ebp_189->tFFFFFFD0;
				ebp_189->tFFFFFFC0.u0 = 0x00;
				edx_642 = ecx_631;
			}
			Eq_2 esi_678 = ebp_189->tFFFFFFC4;
			Eq_2 ebx_679 = *((word32) esi_678 + 88);
			*((word32) esi_678 + 4) = edx_642;
			esi = *((word32) ebx_679 + 24);
			if (*((word32) ebx_679 + 4) != esi)
			{
				eax_107 = (word32) **ebx_679;
				goto l08051530;
			}
			if (eax_623 == 0x02)
			{
l08051550:
				Eq_2 edx_810 = ebp_189->tFFFFFFC4;
				gs->tFFFFFFE0.u0 = 0x54;
				*edx_810 |= 0x20;
				goto l08051566;
			}
			if (eax_623 != 0x01)
			{
				struct Eq_13692 * edx_694 = ebp_189->ptrFFFFFFA8;
				struct Eq_14279 * esp_699 = esp_435 - 4;
				esp_699->ptr0000 = (char *) edx_694 - 178224;
				esp_699->dwFFFFFFFC = 0x0122;
				esp_699->ptrFFFFFFF8 = (char *) edx_694 - 0x0002B857;
				esp_699->ptrFFFFFFF4 = (char *) edx_694 - 178252;
				word32 edx_989;
				word32 ecx_988;
				__assert_fail(out ecx_988, out edx_989);
				goto l08051A74;
			}
			if (ebp_189->tFFFFFFC0 != 0x00)
			{
				Eq_2 eax_775 = ebp_189 - 44;
				ui32 edx_779 = ecx_631 - eax_775;
				if (edx_779 != 0x00)
				{
					ebp_189->tFFFFFFC0 -= edx_779;
					struct Eq_14343 * esp_785 = esp_435 - 0x04;
					esp_785->tFFFFFFFC = ebp_189->tFFFFFFC0;
					esp_785->tFFFFFFF8 = ecx_631;
					esp_785->tFFFFFFF4 = eax_775;
					word32 edx_990;
					memmove(esp_785->tFFFFFFF4, esp_785->tFFFFFFF8, esp_785->tFFFFFFFC, out edx_990);
				}
				if (ebp_189->tFFFFFFC0 == 0x10)
					goto l08051550;
				esi = *((word32) ebp_189->tFFFFFFC4 + 0x0C);
				goto l080516D8;
			}
			Eq_2 eax_721 = ebp_189->tFFFFFFC4;
			esi = *((word32) eax_721 + 0x0C);
			Eq_2 eax_723 = *((word32) eax_721 + 8);
			ebp_189->tFFFFFFBC = eax_723;
			Eq_2 edi_726 = eax_723 - edx_642;
			if (esi < edx_642)
			{
				struct Eq_14423 * esp_729 = esp_435 - 0x04;
				esp_729->tFFFFFFFC = edi_726;
				esp_729->tFFFFFFF8 = edx_642;
				esp_729->tFFFFFFF4 = esi;
				word32 edx_991;
				memmove(esp_729->tFFFFFFF4, esp_729->tFFFFFFF8, esp_729->tFFFFFFFC, out edx_991);
				Eq_2 ecx_745 = ebp_189->tFFFFFFC4;
				Eq_2 eax_747 = *((word32) ecx_745 + 0x0C);
				*((word32) ecx_745 + 8) -= edi_726;
				*((word32) ecx_745 + 4) = eax_747;
				esp_435 = (char *) &esp_729->tFFFFFFFC + 8;
				continue;
			}
			if (edi_726 > 0x0F)
				goto l08051550;
			struct Eq_14470 * esp_754 = esp_435 - 0x04;
			esp_754->tFFFFFFFC = edi_726;
			esp_754->tFFFFFFF8 = edx_642;
			esp_754->tFFFFFFF4 = ebp_189 - 44;
			word32 ecx_992;
			word32 edx_993;
			memcpy(esp_754->tFFFFFFF4, esp_754->tFFFFFFF8, esp_754->tFFFFFFFC, out ecx_992, out edx_993);
			ebp_189->tFFFFFFC0 = edi_726;
l080516D8:
			Eq_2 eax_860 = ebp_189->tFFFFFFC4;
			*((word32) eax_860 + 8) = esi;
			*((word32) eax_860 + 4) = esi;
		}
		ui32 ebx_495 = eax_487 | ebp_189->tFFFFFFC0;
		ui32 eax_498 = *edi_465;
		ebp_189->tFFFFFFC4 = edi_465;
		if (ebx_495 == 0x00)
		{
			((word32) edi_465 + 76)->u0 = ~0x00;
			*edi_465 = eax_498 | 0x10;
			((word32) edi_465 + 80)->u0 = ~0x00;
			eax_107 = ~0x00;
			goto l08051530;
		}
		*ebp_189->tFFFFFFC4 = eax_498 | 0x20;
		if (ebp_189->tFFFFFFC0 != 0x00)
		{
			gs->tFFFFFFE0.u0 = 0x54;
			eax_107 = ~0x00;
l08051530:
			if ((ebp_189->dwFFFFFFE4 ^ gs->dw0014) != 0x00)
			{
l08051A74:
				word32 ecx_977;
				word32 edx_978;
				Eq_2 eax_834 = __stack_chk_fail(out ecx_977, out edx_978);
				_IO_wfile_underflow.cold.2(eax_834, esi, gs);
			}
			else
			{
				esiOut = ebp_189->ptrFFFFFFF8;
				return eax_107;
			}
		}
		goto l08051566;
	}
	Eq_2 ecx_282;
	esi = ecx_262->t0478;
	uint32 eax_273 = *esi;
	if ((eax_273 & 0x8000) == 0x00)
	{
		Eq_2 edx_283 = *((word32) esi + 72);
		ecx_282 = esi;
		Eq_2 ebx_287 = gs->t0008;
		if (*((word32) edx_283 + 8) != ebx_287)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_298;
			if (!__cmpxchg(*edx_283, 0x01, eax_273 & 0x8000, out eax_298))
				__lll_lock_wait_private(eax_298, edx_283, gs);
			edx_283 = *((word32) esi + 72);
			ecx_282 = ebp_189->ptrFFFFFFA8->t0478;
			*((word32) edx_283 + 8) = ebx_287;
			eax_273 = (uint32) *ecx_282;
		}
		*((word32) edx_283 + 4) = (word32) *((word32) edx_283 + 4) + 1;
		if ((eax_273 & 0x0288) != 0x0280)
		{
l08051631:
			if ((*esi & 0x8000) == 0x00)
			{
				Eq_2 edx_394 = *((word32) esi + 72);
				Eq_2 v20_395 = *((word32) edx_394 + 4) - 0x01;
				*((word32) edx_394 + 4) = v20_395;
				if (v20_395 == 0x00)
				{
					((word32) edx_394 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v21_405 = *edx_394 - 0x01;
					*edx_394 = v21_405;
					if (v21_405 != 0x00)
						__lll_unlock_wake_private(edx_394, ecx_282, edx_394, gs);
				}
			}
			goto l08051660;
		}
	}
	else
	{
		if ((eax_273 & 0x0288) != 0x0280)
			goto l08051660;
		ecx_282 = esi;
	}
	Eq_2 ebx_331 = *((word32) ecx_282 + 0x0094);
	if (ebx_331 - ebp_189->dwFFFFFFB0 >= ebp_189->ptrFFFFFFB4)
	{
		word32 ecx_979;
		word32 edx_980;
		_IO_vtable_check(out ecx_979, out edx_980);
		esp_160.u0 = <invalid>;
	}
	struct Eq_13692 * eax_347 = ebp_189->ptrFFFFFFA8;
	struct Eq_13849 * esp_354 = esp_160 - 0x08;
	esp_354->dwFFFFFFFC = ~0x00;
	esp_354->tFFFFFFF8 = eax_347->t0478;
	word32 edx_385;
	(*((word32) ebx_331 + 0x0C))();
	esp_160 = &esp_354->dwFFFFFFFC + 3;
	goto l08051631;
}

// 08051A90: void _IO_wfile_seekoff(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Stack word32 dwArg14)
void _IO_wfile_seekoff(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, word32 dwArg14)
{
	Eq_2 esp_102 = fp - 188;
	ui32 eax_26 = gs->dw0014;
	Eq_2 eax_29 = *((word32) dwArg04 + 88);
	if (dwArg14 != 0x00)
	{
		int64 edx_eax_1961;
		Eq_2 esp_1012;
		Eq_2 ecx_440 = *((word32) eax_29 + 0x0C);
		Eq_2 edx_441 = *((word32) eax_29 + 16);
		if ((*((word32) eax_29 + 8) != *((word32) eax_29 + 4) || ecx_440 != edx_441) && ecx_440 < edx_441 || (*dwArg04 & 0x0800) != 0x00)
		{
			if (_IO_switch_to_wget_mode(dwArg04) != 0x00)
				goto l08051E7E;
			eax_29 = *((word32) dwArg04 + 88);
			if (*((word32) eax_29 + 24) != 0x00)
			{
l08051B3C:
				esp_1012 = fp - 188;
				if (dwArg10 != 0x01)
					goto l08051B4A;
				goto l08051D84;
			}
		}
		else if (*((word32) eax_29 + 24) != 0x00)
			goto l08051B3C;
		ptr32 esp_498 = fp - 188;
		Eq_2 eax_494 = *((word32) eax_29 + 8);
		if (eax_494 != 0x00)
		{
			word32 edx_1990;
			word32 ecx_1989;
			free(gs, dwLocD0, eax_494, out ecx_1989, out edx_1990);
			*dwLocA8 &= ~0x0100;
			esp_498 = fp - 0xB8;
		}
		struct Eq_15929 * esp_527 = esp_498 - 0x0C;
		esp_527->tFFFFFFFC = esp_527->t001C;
		struct Eq_15938 * esi_539;
		word32 ebp_1987;
		word32 edi_1988;
		_IO_doallocbuf(esp_527->tFFFFFFFC, out ebp_1987, out esi_539, out edi_1988);
		word32 eax_545 = esi_539->dw001C;
		esi_539->dw0014 = eax_545;
		esi_539->dw0010 = eax_545;
		esi_539->dw0018 = eax_545;
		esi_539->dw000C = eax_545;
		esi_539->dw0004 = eax_545;
		esi_539->dw0008 = eax_545;
		struct Eq_15971 * eax_554 = esi_539->ptr0058;
		word32 edx_555 = eax_554->dw0018;
		eax_554->dw0010 = edx_555;
		eax_554->dw000C = edx_555;
		eax_554->dw0014 = edx_555;
		eax_554->dw0008 = edx_555;
		eax_554->dw0000 = edx_555;
		eax_554->dw0004 = edx_555;
		esp_1012 = (char *) &esp_527->tFFFFFFFC + 16;
		if (esp_527->dw00D8 != 0x01)
		{
l08051B4A:
			if (*((word32) esp_1012 + 0x00CC) != 0x02)
				goto l08051BCD;
			Eq_2 ebx_686 = *((word32) *((word32) esp_1012 + 16) + 0x0094);
			((word32) esp_1012 + 32)->u0 = 0x080CEFA0;
			((word32) esp_1012 + 20)->u0 = 0x0354;
			if (ebx_686 >= 135066356)
			{
				word32 ecx_1967;
				word32 edx_1968;
				_IO_vtable_check(out ecx_1967, out edx_1968);
				esp_1012.u0 = <invalid>;
			}
			struct Eq_14806 * esp_705 = esp_1012 - 0x08;
			esp_705->ptrFFFFFFFC = &esp_705->dw0018 + 9;
			esp_705->dwFFFFFFF8 = esp_705->dw0018;
			word32 eax_722;
			(*((word32) ebx_686 + 72))();
			esp_1012 = &esp_705->ptrFFFFFFFC + 3;
			if (eax_722 != 0x00 || (esp_705->dw004C & 0xF000) != 0x8000)
				goto l08051E00;
			edx_eax_1961 = esp_705->qw0068;
l08051BBA:
			ui64 v18_v17_1320 = (word32) *((word64) esp_1012.u0 + 8) + edx_eax_1961;
			*((word64) esp_1012.u0 + 8) = (word32) v18_v17_1320;
			*((word64) esp_1012.u0 + 0x0C) = SLICE(v18_v17_1320, word32, 32);
			*((word64) esp_1012.u0 + 0x00CC) = 0x00;
l08051BCD:
			struct Eq_14753 * esp_749 = esp_1012 - 0x0C;
			Eq_2 ebx_752 = esp_749->t001C;
			esp_749->tFFFFFFFC = ebx_752;
			_IO_free_wbackup_area(esp_749->tFFFFFFFC);
			Eq_2 eax_762 = *((word32) ebx_752 + 76);
			Eq_2 edx_763 = *((word32) ebx_752 + 80);
			esp_1012 = &esp_749->t000C;
			if ((eax_762 & edx_763) != ~0x00)
			{
				Eq_2 ecx_772 = *ebx_752;
				Eq_2 esi_773 = *((word32) ebx_752 + 0x0C);
				esp_749->t0024 = ecx_772;
				byte ch_778 = SLICE(ecx_772, byte, 8);
				if (esi_773 != 0x00 && (ch_778 & 0x01) == 0x00)
				{
					Eq_2 esi_783 = *((word32) ebx_752 + 28);
					Eq_2 ecx_784 = *((word32) ebx_752 + 8);
					esp_749->t001C = ebx_752;
					esp_749->t0020 = esi_783;
					ui64 edi_esi_1310 = SEQ(edx_763, eax_762) - SEQ(ecx_787 >> 0x1F, ecx_787);
					Eq_2 esi_792 = (word32) edi_esi_1310;
					ecx_787 = ecx_784 - esi_783;
					if (esp_749->dw0018 - SLICE(edi_esi_1310, word32, 32) - (esp_749->t0014 < esi_792) >= 0x00 && (esp_749->dw0018 - edx_763) - (esp_749->t0014 < eax_762) < 0x00)
					{
						Eq_2 esi_1071 = esp_749->t0020;
						Eq_2 edx_1072 = esp_749->t001C;
						Eq_2 eax_1074 = (word32) esi_1071 + (esp_749->t0014 - esi_792);
						*((word32) edx_1072 + 0x0C) = esi_1071;
						*((word32) edx_1072 + 4) = eax_1074;
						Eq_2 eax_1077 = *((word32) edx_1072 + 88);
						*((word32) edx_1072 + 20) = esi_1071;
						*((word32) edx_1072 + 16) = esi_1071;
						*((word32) edx_1072 + 24) = esi_1071;
						Eq_2 edx_1082 = *((word32) eax_1077 + 24);
						*((word32) eax_1077 + 8) = edx_1082;
						*eax_1077 = edx_1082;
						*((word32) eax_1077 + 4) = edx_1082;
						*((word32) eax_1077 + 16) = edx_1082;
						*((word32) eax_1077 + 0x0C) = edx_1082;
						*((word32) eax_1077 + 20) = edx_1082;
						word32 esi_1984;
						if (adjust_wide_data(edx_1072, 0x00, gs, esp_749->t000C, out esi_1984) == 0x00)
						{
							Eq_2 eax_1209 = esp_749->t001C;
							Eq_2 ebx_1210 = *((word32) eax_1209 + 80);
							*eax_1209 &= ~0x10;
							Eq_2 ecx_1214 = *((word32) eax_1209 + 76);
							if (ebx_1210 >= 0x00)
							{
								Eq_2 edi_1220 = *((word32) esp_749->t001C + 0x0094);
								if (edi_1220 >= 135066356)
								{
									word32 edx_1986;
									word32 ecx_1985;
									_IO_vtable_check(out ecx_1985, out edx_1986);
									esp_1012.u0 = <invalid>;
									Eq_2 eax_1234 = *((word64) esp_1012.u0 + 16);
									ecx_1214 = *((word32) eax_1234 + 76);
									ebx_1210 = *((word32) eax_1234 + 80);
								}
								struct Eq_15759 * esp_1238 = esp_1012 - 4;
								esp_1238->dw0000 = 0x00;
								esp_1238->tFFFFFFFC = ebx_1210;
								esp_1238->tFFFFFFF8 = ecx_1214;
								esp_1238->dwFFFFFFF4 = esp_1238->dw0014;
								(*((word32) edi_1220 + 64))();
							}
							goto l08051E7E;
						}
						goto l08051DE2;
					}
				}
			}
			else
				esp_749->t0024 = *esp_749->t001C;
			Eq_2 edi_816 = esp_749->t0024;
			esp_749->dw002C = 0x080CEFA0;
			esp_749->t0020.u0 = 0x0354;
			esp_749->dw0034 = edi_816 & 0x04;
			if ((edi_816 & 0x04) != 0x00)
				goto l08051E00;
			Eq_2 eax_825 = esp_749->t001C;
			Eq_2 ecx_827 = *((word32) eax_825 + 32);
			ui32 edi_829 = *((word32) eax_825 + 28) - ecx_827;
			Eq_2 edi_832 = esp_749->t0014;
			int32 ebp_826 = esp_749->dw0018;
			esp_749->t0024 = edi_829 & edi_832;
			int64 ebp_edi_1322 = SEQ(ebp_826, edi_832) - esp_749->t0024;
			esp_749->dw0028 = SLICE((int64) edi_829, word32, 32) & ebp_826;
			up32 ecx_845 = ecx_827 - *((word32) esp_749->t001C + 28);
			if (SLICE((int64) ecx_845 - ebp_edi_1322, word32, 32) - (ecx_845 < (word32) ebp_edi_1322) < 0x00)
			{
				int32 ebp_856 = esp_749->dw0018;
				esp_749->t0024 = esp_749->t0014;
				esp_749->dw0028 = ebp_856;
				ebp_edi_1322 = 0x00;
			}
			uint32 edi_897 = (word32) ebp_edi_1322;
			int32 ebp_895 = SLICE(ebp_edi_1322, word32, 32);
			Eq_2 edx_866 = *((word32) esp_749->t001C + 0x0094);
			if (edx_866 - 0x080CEFA0 >= esp_749->t0020)
			{
				esp_749->t0038 = edx_866;
				word32 ecx_1991;
				word32 edx_1992;
				_IO_vtable_check(out ecx_1991, out edx_1992);
				esp_1012.u0 = <invalid>;
				edx_866 = *((word64) esp_1012.u0 + 44);
			}
			struct Eq_16134 * esp_882 = esp_1012 - 4;
			esp_882->dw0000 = 0x00;
			esp_882->dwFFFFFFFC = esp_882->dw0020;
			esp_882->dwFFFFFFF8 = esp_882->dw001C;
			struct Eq_16153 * esi_890 = esp_882->ptr0014;
			esp_882->ptrFFFFFFF4 = esi_890;
			word32 eax_911;
			int32 edx_912;
			(*((word32) edx_866 + 64))();
			esp_882->dw001C = eax_911;
			esp_882->dw0020 = edx_912;
			esp_1012 = &esp_882->dw0000 + 1;
			if (edx_912 >= 0x00)
			{
				uint32 edx_1011;
				if ((ebp_895 | edi_897) == 0x00)
				{
					edx_1011 = 0x00;
					goto l08051FAA;
				}
				struct Eq_16180 * eax_931 = esi_890->ptr0094;
				if (eax_931 - 0x080CEFA0 >= esp_882->dw0018)
				{
					esp_882->ptr002C = eax_931;
					word32 ecx_1993;
					word32 edx_1994;
					_IO_vtable_check(out ecx_1993, out edx_1994);
					esp_1012.u0 = <invalid>;
					eax_931 = (struct Eq_16180 *) *((word64) esp_1012.u0 + 40);
				}
				uint32 eax_956;
				Eq_2 eax_950 = *((word64) esp_1012.u0 + 16);
				<anonymous> * ecx_947 = eax_931->ptr0038;
				Eq_2 edx_951 = *((word32) eax_950 + 28);
				if (*((word64) esp_1012.u0 + 36) != 0x00)
					eax_956 = edi_897;
				else
					eax_956 = *((word32) eax_950 + 32) - edx_951;
				struct Eq_16224 * esp_961 = esp_1012 - 0x04;
				esp_961->dwFFFFFFFC = eax_956;
				esp_961->tFFFFFFF8 = edx_951;
				esp_961->dwFFFFFFF4 = esp_961->dw0014;
				word32 eax_983;
				ecx_947();
				int64 edx_eax_987 = (int64) eax_983;
				uint32 eax_988 = (word32) edx_eax_987;
				esp_961->dw002C = eax_988;
				esp_1012 = &esp_961->dwFFFFFFFC + 2;
				if (SLICE(edx_eax_987, word32, 32) - ebp_895 - (eax_988 < edi_897) >= 0x00)
				{
					edx_1011 = eax_988;
l08051FAA:
					Eq_2 esi_1014 = *((word32) esp_1012 + 16);
					Eq_2 eax_1015 = *((word32) esi_1014 + 28);
					*((word32) esi_1014 + 0x0C) = eax_1015;
					*((word32) esi_1014 + 20) = eax_1015;
					*((word32) esi_1014 + 16) = eax_1015;
					*((word32) esi_1014 + 24) = eax_1015;
					Eq_2 eax_1025 = *((word32) esi_1014 + 88);
					*((word32) esi_1014 + 8) = (word32) eax_1015 + edx_1011;
					Eq_2 edx_1027 = *((word32) eax_1025 + 24);
					*((word32) esi_1014 + 4) = (word32) eax_1015 + edi_897;
					*((word32) eax_1025 + 8) = edx_1027;
					*eax_1025 = edx_1027;
					*((word32) eax_1025 + 4) = edx_1027;
					*((word32) eax_1025 + 16) = edx_1027;
					*((word32) eax_1025 + 0x0C) = edx_1027;
					*((word32) eax_1025 + 20) = edx_1027;
					struct Eq_16241 * esi_1044;
					if (adjust_wide_data(esi_1014, 0x01, gs, *esp_1012, out esi_1044) == 0x00)
					{
						int64 edx_eax_1324 = (word32) *((word64) esp_1012.u0 + 24) + (int64) (*((word64) esp_1012.u0 + 40));
						esi_1044->dw004C = (word32) edx_eax_1324;
						esi_1044->dw0050 = SLICE(edx_eax_1324, word32, 32);
						esi_1044->dw0000 &= ~0x10;
						goto l08051E7E;
					}
					goto l08051E00;
				}
				if (esp_961->dw002C != ~0x00)
				{
					esp_961->dw00D0 = 0x01;
					int64 ebp_edi_1327 = ebp_edi_1322 - edx_eax_987;
					esp_961->dw000C = (word32) ebp_edi_1327;
					esp_961->dw0010 = SLICE(ebp_edi_1327, word32, 32);
				}
				else
				{
					esp_961->dw000C = edi_897;
					esp_961->dw0010 = ebp_895;
					esp_961->dw00D0 = 0x01;
				}
l08051E00:
				struct Eq_14828 * esp_1120 = esp_1012 - 0x0C;
				Eq_2 esi_1123 = esp_1120->t001C;
				esp_1120->tFFFFFFFC = esi_1123;
				_IO_unsave_markers(esp_1120->tFFFFFFFC);
				Eq_2 ebx_1134 = *((word32) esi_1123 + 0x0094);
				Eq_2 esp_1137 = (char *) &esp_1120->tFFFFFFFC + 20;
				if (ebx_1134 - esp_1120->dw0030 >= esp_1120->dw0024)
				{
					word32 ecx_1971;
					word32 edx_1972;
					_IO_vtable_check(out ecx_1971, out edx_1972);
					esp_1137.u0 = <invalid>;
				}
				struct Eq_15160 * esp_1150 = esp_1137 - 4;
				esp_1150->dw0000 = (word32) *((word64) esp_1137.u0 + 0x00CC);
				esp_1150->dwFFFFFFFC = esp_1150->dw0010;
				esp_1150->dwFFFFFFF8 = esp_1150->dw000C;
				struct Eq_15181 * esi_1158 = esp_1150->ptr0014;
				esp_1150->ptrFFFFFFF4 = esi_1158;
				ui32 eax_1179;
				ui32 edx_1180;
				(*((word32) ebx_1134 + 64))();
				if ((eax_1179 & edx_1180) != ~0x00)
				{
					word32 ecx_1188 = esi_1158->dw001C;
					esi_1158->dw0000 &= ~0x10;
					esi_1158->dw004C = eax_1179;
					esi_1158->dw000C = ecx_1188;
					esi_1158->dw0004 = ecx_1188;
					esi_1158->dw0008 = ecx_1188;
					esi_1158->dw0014 = ecx_1188;
					esi_1158->dw0010 = ecx_1188;
					esi_1158->dw0018 = ecx_1188;
					struct Eq_15229 * ecx_1200 = esi_1158->ptr0058;
					esi_1158->dw0050 = edx_1180;
					word32 ebx_1202 = ecx_1200->dw0018;
					ecx_1200->dw0008 = ebx_1202;
					ecx_1200->dw0000 = ebx_1202;
					ecx_1200->dw0004 = ebx_1202;
					ecx_1200->dw0010 = ebx_1202;
					ecx_1200->dw000C = ebx_1202;
					ecx_1200->dw0014 = ebx_1202;
				}
l08051E7E:
				if ((eax_26 ^ gs->dw0014) == 0x00)
					return;
				word32 edx_1996;
				word32 ecx_1995;
				__stack_chk_fail(out ecx_1995, out edx_1996);
				_IO_wfile_underflow_maybe_mmap(dwArg04);
				return;
			}
l080521FC:
			goto l08051E7E;
		}
l08051D84:
		Eq_2 esi_569 = *((word32) esp_1012 + 16);
		struct Eq_14732 * esp_570 = esp_1012 - 0x0C;
		Eq_2 ebx_572 = *((word32) esi_569 + 84);
		esp_570->tFFFFFFFC = ebx_572;
		int32 eax_587;
		(*((word32) ebx_572 + 16))();
		if (eax_587 > 0x00)
		{
			Eq_2 edx_645 = *((word32) esi_569 + 88);
			ui64 ebx_ecx_1318 = esp_570->t0014 - (int64) (eax_587 *s (*((word32) edx_645 + 4) - *edx_645 >> 0x02)) - (int64) (*((word32) esi_569 + 8) - *((word32) esi_569 + 4));
			esp_570->t0014 = (word32) ebx_ecx_1318;
			esp_570->dw0018 = SLICE(ebx_ecx_1318, word32, 32);
		}
		else
		{
			struct Eq_15781 * ecx_594 = esp_570->ptr001C;
			struct Eq_15785 * eax_596 = ecx_594->ptr0058;
			word32 edi_598 = eax_596->dw0038;
			int32 edx_601 = eax_596->dw0000 - eax_596->dw0008;
			eax_596->dw002C = eax_596->dw0034;
			eax_596->dw0030 = edi_598;
			esp_570->tFFFFFFFC = edx_601 >> 0x02;
			esp_570->dwFFFFFFF8 = ecx_594->dw0008;
			esp_570->dwFFFFFFF4 = ecx_594->dw000C;
			esp_570->ptrFFFFFFF0 = &eax_596->dw002C;
			esp_570->tFFFFFFEC = ebx_572;
			word32 eax_619;
			(*((word32) ebx_572 + 24))();
			word32 edx_623 = ecx_594->dw000C;
			ecx_594->dw0004 = edx_623 + eax_619;
			struct Eq_15785 * ecx_626 = ecx_594->ptr0058;
			ecx_626->dw0004 = ecx_626->dw0000;
			ui64 v40_v39_1312 = esp_570->t0014 - (int64) ((ecx_594->dw0008 - edx_623) - eax_619);
			esp_570->t0014 = (word32) v40_v39_1312;
			esp_570->dw0018 = SLICE(v40_v39_1312, word32, 32);
		}
		Eq_2 eax_673 = *((word32) esp_1012 + 16);
		Eq_2 edx_674 = *((word32) eax_673 + 80);
		Eq_2 eax_675 = *((word32) eax_673 + 76);
		edx_eax_1961 = SEQ(edx_674, eax_675);
		if ((eax_675 & edx_674) == ~0x00)
		{
l08051DE2:
			((word32) esp_1012 + 32)->u0 = 0x080CEFA0;
			((word32) esp_1012 + 20)->u0 = 0x0354;
			goto l08051E00;
		}
		goto l08051BBA;
	}
	if (*((word32) eax_29 + 24) != 0x00)
	{
		ui32 edx_43 = *dwArg04;
		Eq_2 ebx_42 = *((word32) eax_29 + 0x0C);
		byte dh_104 = SLICE(edx_43, byte, 8);
		if (*((word32) eax_29 + 16) > ebx_42 && (edx_43 & 0x1000) != 0x00)
		{
			Eq_2 edi_53 = *((word32) dwArg04 + 0x0094);
			if (edi_53 >= 135066356)
			{
				word32 ecx_1969;
				word32 edx_1970;
				_IO_vtable_check(out ecx_1969, out edx_1970);
				esp_102.u0 = <invalid>;
			}
			struct Eq_14915 * esp_69 = esp_102 - 4;
			esp_69->dw0000 = 0x02;
			esp_69->dwFFFFFFFC = 0x00;
			esp_69->dwFFFFFFF8 = 0x00;
			esp_69->ptrFFFFFFF4 = esp_69->ptr0014;
			ui32 eax_84;
			ui32 edx_85;
			(*((word32) edi_53 + 64))();
			esp_102 = &esp_69->dw0000 + 1;
			if ((eax_84 & edx_85) == ~0x00)
				goto l080521FC;
			struct Eq_14932 * ecx_93 = esp_69->ptr0014;
			ecx_93->dw004C = eax_84;
			eax_29 = ecx_93->t0058;
			ecx_93->dw0050 = edx_85;
			dh_104 = ecx_93->b0001;
		}
		Eq_2 edi_100 = *((word32) eax_29 + 4);
		Eq_2 ecx_101 = *eax_29;
		*((word32) esp_102 + 20) = edi_100;
		if ((dh_104 & 0x01) != 0x00)
		{
			if (edi_100 > ecx_101)
				goto l080521EF;
			ecx_101 = *((word32) eax_29 + 32);
			Eq_2 eax_116 = *((word32) eax_29 + 40);
			*((word32) esp_102 + 36) = ecx_101;
			*((word32) esp_102 + 20) = eax_116;
		}
		else
			*((word32) esp_102 + 36) = *((word32) eax_29 + 8);
		Eq_2 esi_121 = *((word32) esp_102 + 16);
		*((word32) esp_102 + 24) = ecx_101;
		struct Eq_14987 * esp_124 = esp_102 - 0x0C;
		Eq_2 edi_126 = *((word32) esi_121 + 84);
		esp_124->tFFFFFFFC = edi_126;
		int32 eax_137;
		(*((word32) edi_126 + 16))();
		esp_102 = (char *) &esp_124->ptr0008 + 4;
		if (esp_124->t0014 <= ebx_42)
		{
			Eq_2 edx_297 = *((word32) esi_121 + 8);
			Eq_2 ecx_298 = esp_124->t0024;
			if (eax_137 > 0x00)
			{
				int32 edi_345 = (esp_124->t0020 - ecx_298 >> 0x02) *s eax_137;
				Eq_15113 ecx_349 = -edi_345;
				int64 ebx_ecx_1303 = SEQ(-((edi_345 >> 0x1F) + (ecx_349 == 0x00)), ecx_349) - (int64) (edx_297 - *((word32) esi_121 + 4));
				esp_124->t0014 = (word32) ebx_ecx_1303;
				esp_124->t0018.u1 = SLICE(ebx_ecx_1303, word32, 32);
			}
			else
			{
				struct Eq_14986 * eax_301 = esp_124->ptr001C->ptr0058;
				word32 esi_303 = eax_301->dw0038;
				esp_124->dw00A0 = eax_301->dw0034;
				esp_124->dw00A4 = esi_303;
				esp_124->tFFFFFFFC = ecx_298 - esp_124->ptr0030 >> 0x02;
				esp_124->tFFFFFFF8 = edx_297;
				struct Eq_14990 * ebx_314 = esp_124->ptr001C;
				esp_124->dwFFFFFFF4 = ebx_314->dw000C;
				esp_124->ptrFFFFFFF0 = &esp_124->dw00A0;
				esp_124->tFFFFFFEC = edi_126;
				word32 eax_323;
				(*((word32) edi_126 + 24))();
				int64 edx_eax_331 = (int64) (ebx_314->dw0008 - ebx_314->dw000C - eax_323);
				Eq_2 eax_333 = -(word32) edx_eax_331;
				esp_124->t0014 = eax_333;
				esp_124->t0018 = -((bool) (eax_333 == 0x00) + SLICE(edx_eax_331, word32, 32));
				esp_102 = (char *) &esp_124->ptr0008 + 4;
			}
		}
		else
		{
			Eq_14985 edx_eax_1959;
			struct Eq_14986 * ecx_145 = esp_124->ptr001C->ptr0058;
			Eq_2 ebx_146 = ecx_145->t0010;
			word32 edx_147 = ecx_145->dw000C;
			esp_124->t0020 = ebx_146;
			Eq_2 ebx_149 = ebx_146 - edx_147;
			esp_124->t0014 = ebx_149;
			if (eax_137 > 0x00)
				edx_eax_1959.u0 = (int64) ((ebx_149 >> 0x02) *s eax_137);
			else
			{
				esp_124->dw0034 = edx_147;
				esp_124->ptr0030 = ecx_145;
				esp_124->tFFFFFFFC = esp_124->t0014;
				Eq_2 edi_165;
				word32 ebp_1978;
				word32 esi_1979;
				word32 ebx_1977;
				word32 ecx_1975;
				word32 edx_1976;
				Eq_2 eax_161 = __libc_malloc(gs, esp_124->tFFFFFFF8, esp_124->tFFFFFFFC, out ecx_1975, out edx_1976, out ebx_1977, out ebp_1978, out esi_1979, out edi_165);
				struct Eq_14986 * ecx_172 = esp_124->ptr0030;
				word32 edx_173 = esp_124->dw0034;
				esp_124->t0024 = eax_161;
				word32 ebx_175 = ecx_172->dw0034;
				word32 esi_176 = ecx_172->dw0038;
				esp_124->t003C = eax_161;
				esp_124->dw0040 = edx_173;
				esp_124->dw00A0 = ebx_175;
				esp_124->dw00A4 = esi_176;
				esp_124->ptr0008 = (word32 *) &esp_124->t003C;
				Eq_2 eax_185 = esp_124->t0024;
				word32 ecx_187 = Mem184[esp_124 + 0x14:word32] + eax_185;
				esp_124->dw0004 = ecx_187;
				esp_124->t0000 = eax_185;
				esp_124->tFFFFFFFC = &esp_124->dw0040;
				esp_124->tFFFFFFF8 = esp_124->t0020;
				esp_124->dwFFFFFFF4 = edx_173;
				esp_124->ptrFFFFFFF0 = &esp_124->dw00A0;
				esp_124->tFFFFFFEC = edi_165;
				word32 eax_206;
				(*((word32) edi_165 + 4))();
				if (eax_206 != 0x00)
				{
					esp_124->tFFFFFFFC = esp_124->t0024;
					word32 edx_1981;
					word32 ecx_1980;
					free(gs, esp_124->tFFFFFFF8, esp_124->tFFFFFFFC, out ecx_1980, out edx_1981);
					goto l08051E7E;
				}
				Eq_2 ecx_234 = esp_124->t0024;
				Eq_2 edi_237 = esp_124->t003C - ecx_234;
				esp_124->t0014 = edi_237;
				esp_124->t0018.u1 = SLICE((int64) edi_237, word32, 32);
				esp_124->tFFFFFFFC = ecx_234;
				word32 ecx_1982;
				word32 edx_1983;
				free(gs, esp_124->tFFFFFFF8, esp_124->tFFFFFFFC, out ecx_1982, out edx_1983);
				esp_102 = (char *) &esp_124->ptr0008 + 8;
				edx_eax_1959 = esp_124->t0018;
			}
			Eq_15456 edi_272;
			Eq_2 ecx_266 = *((word32) esp_102 + 16);
			Eq_2 edi_268 = *((word32) ecx_266 + 20);
			if (*((word32) esp_102 + 32) == 0x00)
				edi_272 = edi_268 - *((word32) (*((word32) esp_102 + 16)) + 8);
			else
				edi_272 = edi_268 - *((word32) ecx_266 + 16);
			int64 ebx_ecx_1308 = (word64) edx_eax_1959.u0 + SEQ(edi_272 >> 0x1F, edi_272);
			*((word32) esp_102 + 8) = (word32) ebx_ecx_1308;
			*((word32) esp_102 + 0x0C) = SLICE(ebx_ecx_1308, word32, 32);
		}
	}
	Eq_2 eax_367 = *((word32) esp_102 + 16);
	Eq_2 edx_368 = *((word32) eax_367 + 80);
	Eq_2 eax_369 = *((word32) eax_367 + 76);
	int64 edx_eax_1956 = SEQ(edx_368, eax_369);
	if ((eax_369 & edx_368) == ~0x00)
	{
		Eq_2 ebx_376 = *((word32) *((word32) esp_102 + 16) + 0x0094);
		if (ebx_376 >= 135066356)
		{
			word32 edx_1974;
			word32 ecx_1973;
			_IO_vtable_check(out ecx_1973, out edx_1974);
			esp_102.u0 = <invalid>;
		}
		struct Eq_15303 * esp_391 = esp_102 - 4;
		esp_391->dw0000 = 0x01;
		esp_391->dwFFFFFFFC = 0x00;
		esp_391->dwFFFFFFF8 = 0x00;
		esp_391->dwFFFFFFF4 = esp_391->dw0014;
		int64 edx_eax_1966;
		(*((word32) ebx_376 + 64))();
		esp_102 = &esp_391->dw0000 + 1;
		edx_eax_1956 = edx_eax_1966;
		if (((word32) edx_eax_1966 & SLICE(edx_eax_1966, word32, 32)) == ~0x00)
			goto l080521FC;
	}
	if (SLICE((word32) *((word32) esp_102 + 8) + edx_eax_1956, word32, 32) >= 0x00)
		goto l08051E7E;
l080521EF:
	gs->tFFFFFFE0.u0 = 22;
	goto l080521FC;
}

// 080524E0: void _IO_wfile_underflow_maybe_mmap(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
void _IO_wfile_underflow_maybe_mmap(Eq_2 dwArg04)
{
	if (_IO_file_underflow_maybe_mmap(dwArg04) == ~0x00)
		return;
	Eq_2 eax_37 = *((word32) *((word32) *((word32) dwArg04 + 88) + 0x00B0) + 16);
	eax_37();
}

// 08052530: void _IO_wfile_underflow_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wfile_underflow_mmap(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_24 = *dwArg04;
	ptr32 esp_113 = fp - 0x3C;
	ui32 eax_20 = gs->dw0014;
	if (((byte) eax_24 & 0x04) != 0x00)
	{
		*dwArg04 = eax_24 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		goto l080525EA;
	}
	Eq_2 eax_111 = *((word32) dwArg04 + 88);
	if (*eax_111 < *((word32) eax_111 + 4))
	{
l080525E8:
		goto l080525EA;
	}
	Eq_2 edx_115;
	Eq_2 edi_40 = *((word32) dwArg04 + 84);
	Eq_2 ecx_112 = *((word32) dwArg04 + 4);
	if (ecx_112 < *((word32) dwArg04 + 8))
	{
		edx_115 = *((word32) eax_111 + 24);
		if (edx_115 != 0x00)
			goto l0805258C;
	}
	else
	{
		esp_113 = fp - 0x3C;
		if (_IO_file_underflow_mmap(&g_t80CE000, dwArg04, edi_40, gs, dwLoc50, dwArg04) == ~0x00)
			goto l080525EA;
		eax_111 = *((word32) dwArg04 + 88);
		ecx_112 = *((word32) dwArg04 + 4);
		edx_115 = *((word32) eax_111 + 24);
		if (edx_115 != 0x00)
		{
l0805258C:
			Eq_2 ebp_118 = *((word32) eax_111 + 48);
			Eq_2 edi_119 = *((word32) eax_111 + 44);
			*eax_111 = edx_115;
			*((word32) eax_111 + 8) = edx_115;
			*((word32) eax_111 + 56) = ebp_118;
			struct Eq_16499 * eax_125 = (word32) eax_111 + 44;
			eax_125->t0008 = edi_119;
			struct Eq_16505 * esp_129 = esp_113 - 4;
			esp_129->ptr0000 = (word32) eax_111 + 4;
			esp_129->dwFFFFFFFC = eax_125->dwFFFFFFF0;
			esp_129->tFFFFFFF8 = edx_115;
			esp_129->ptrFFFFFFF4 = &esp_129->t001C;
			esp_129->tFFFFFFF0 = *((word32) dwArg04 + 8);
			esp_129->tFFFFFFEC = ecx_112;
			esp_129->ptrFFFFFFE8 = eax_125;
			struct Eq_16539 * eax_148 = esp_129->ptr0010;
			esp_129->ptrFFFFFFE4 = eax_148;
			word32 ecx_161;
			eax_148->ptr000C();
			*((word32) dwArg04 + 4) = esp_129->t001C;
			Eq_2 eax_165 = *((word32) dwArg04 + 88);
			if (*eax_165 >= *((word32) eax_165 + 4))
			{
				gs->tFFFFFFE0.u0 = 0x54;
				*dwArg04 |= 0x20;
l080525EA:
				if ((eax_20 ^ gs->dw0014) == 0x00)
					return;
				word32 ecx_289;
				word32 edx_290;
				__stack_chk_fail(out ecx_289, out edx_290);
				Eq_2 esp_191 = <invalid>;
				word32 esi_294;
				word32 ebx_293;
				_IO_wdo_write(gs, *((word32) esp_191 + 4), *((word32) esp_191 + 8), *((word32) esp_191 + 0x0C), out ebx_293, out esi_294);
				return;
			}
			goto l080525E8;
		}
	}
	ptr32 esp_79 = fp - 0x3C;
	Eq_2 eax_75 = *((word32) eax_111 + 32);
	if (eax_75 != 0x00)
	{
		word32 ecx_291;
		word32 edx_292;
		free(gs, dwLoc50, eax_75, out ecx_291, out edx_292);
		*dwArg04 &= ~0x0100;
		esp_79 = fp - 0x38;
	}
	struct Eq_16590 * esp_100 = esp_79 - 0x0C;
	esp_100->tFFFFFFFC = dwArg04;
	_IO_wdoallocbuf(esp_100->tFFFFFFFC);
	eax_111 = *((word32) dwArg04 + 88);
	ecx_112 = *((word32) dwArg04 + 4);
	esp_113 = (char *) &esp_100->tFFFFFFFC + 16;
	edx_115 = *((word32) eax_111 + 24);
	goto l0805258C;
}

// 080526A0: Register Eq_2 _IO_wdo_write(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_979 ebxOut, Register out Eq_2 esiOut)
// Called from:
//      _IO_wfile_underflow_mmap
//      _IO_wfile_overflow
//      _IO_wfile_sync
//      _IO_wfile_xsputn
//      _IO_file_close_it
//      _IO_new_file_finish
//      _IO_new_file_overflow
//      _IO_new_file_sync
Eq_2 _IO_wdo_write(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_979 & ebxOut, union Eq_2 & esiOut)
{
	Eq_2 eax_137;
	Eq_2 edx_160;
	Eq_2 ecx_166;
	Eq_2 ebp_150 = dwArg0C;
	Eq_2 edi_22 = dwArg08;
	ui32 eax_24 = gs->dw0014;
	if (dwArg0C != 0x00)
	{
		Eq_2 ecx_30 = *((word32) dwArg04 + 84);
		Eq_2 edx_265 = *((word32) dwArg04 + 20);
		Eq_2 ebx_116 = *((word32) dwArg04 + 16);
		if (*((word32) dwArg04 + 24) == edx_265 && edx_265 != ebx_116)
		{
			eax_137 = _IO_do_write(edx_265 - ebx_116);
			if (eax_137 == ~0x00)
				goto l08052806;
			edx_265 = *((word32) dwArg04 + 20);
			ebx_116 = *((word32) dwArg04 + 16);
		}
		while (true)
		{
			Eq_2 dwLoc34_297;
			Eq_2 eax_76;
			if (edx_265 - ebx_116 > 0x0F)
			{
				dwLoc34_297 = edx_265;
				eax_76 = *((word32) dwArg04 + 32);
			}
			else
			{
				ebx_116 = fp - 0x30;
				eax_76 = fp - 0x20;
				dwLoc34_297 = fp - 0x30;
				edx_265 = fp - 0x30;
			}
			Eq_2 eax_104 = *((word32) dwArg04 + 88);
			word32 eax_121;
			(*((word32) ecx_30 + 4))();
			eax_137 = _IO_do_write(dwLoc34_297 - ebx_116);
			if (eax_137 == ~0x00)
				break;
			ebp_150 -= dwLoc38 - edi_22 >> 0x02;
			if (eax_121 != 0x00 && (dwLoc38 == edi_22 || eax_121 != 0x01))
			{
				edx_160 = *((word32) dwArg04 + 88);
				ecx_166 = *((word32) edx_160 + 24);
				*((word32) edx_160 + 8) = ecx_166;
				*edx_160 = ecx_166;
				*((word32) edx_160 + 4) = ecx_166;
				*((word32) edx_160 + 16) = ecx_166;
				*((word32) edx_160 + 0x0C) = ecx_166;
				eax_137 = -(uint32) (int8) (ebp_150 != 0x00);
				if ((*dwArg04 & 0x0202) == 0x00)
					goto l08052800;
				goto l08052803;
			}
			if (ebp_150 == 0x00)
				goto l080527B0;
			edx_265 = *((word32) dwArg04 + 20);
			ebx_116 = *((word32) dwArg04 + 16);
			edi_22 = dwLoc38;
		}
	}
	else
	{
l080527B0:
		edx_160 = *((word32) dwArg04 + 88);
		ui32 eax_188 = *dwArg04;
		Eq_2 ecx_189 = *((word32) edx_160 + 24);
		*((word32) edx_160 + 8) = ecx_189;
		*edx_160 = ecx_189;
		*((word32) edx_160 + 4) = ecx_189;
		*((word32) edx_160 + 16) = ecx_189;
		*((word32) edx_160 + 0x0C) = ecx_189;
		eax_137 = eax_188 & 0x0202;
		if ((eax_188 & 0x0202) != 0x00)
		{
			*((word32) edx_160 + 20) = ecx_189;
			eax_137.u0 = 0x00;
		}
		else
		{
l08052800:
			ecx_166 = *((word32) edx_160 + 28);
l08052803:
			*((word32) edx_160 + 20) = ecx_166;
		}
	}
l08052806:
	if ((eax_24 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_437;
		word32 edx_438;
		__stack_chk_fail(out ecx_437, out edx_438);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 eax_251 = _IO_wfile_overflow(gs, stackArg4, stackArg8);
		ebxOut.u0 = <invalid>;
		esiOut = dwArg04;
		return eax_251;
	}
	else
	{
		ebxOut.u0 = <invalid>;
		esiOut = esi;
		return eax_137;
	}
}

// 08052860: Register Eq_2 _IO_wfile_overflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _IO_wdo_write
Eq_2 _IO_wfile_overflow(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 edx_135 = *dwArg04;
	byte dh_41 = SLICE(edx_135, byte, 8);
	if (((byte) edx_135 & 0x08) != 0x00)
	{
		*dwArg04 = edx_135 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		return ~0x00;
	}
	Eq_2 eax_178;
	if ((dh_41 & 0x08) == 0x00)
	{
		Eq_2 dwLoc24_387;
		Eq_2 dwLoc20_388;
		Eq_2 esi_104;
		Eq_2 ebp_107;
		Eq_2 ecx_100;
		Eq_2 eax_119 = *((word32) dwArg04 + 88);
		if (*((word32) eax_119 + 0x0C) != 0x00)
		{
			Eq_2 edi_99 = *((word32) eax_119 + 28);
			ecx_100 = *eax_119;
			dwLoc24_387 = edi_99;
			if (ecx_100 != edi_99)
			{
				ebp_107 = *((word32) eax_119 + 4);
				esi_104 = *((word32) dwArg04 + 4);
				dwLoc20_388 = *((word32) dwArg04 + 8);
			}
			else
			{
				esi_104 = *((word32) dwArg04 + 28);
				ecx_100 = *((word32) eax_119 + 24);
				*((word32) dwArg04 + 8) = esi_104;
				*eax_119 = ecx_100;
				*((word32) eax_119 + 4) = ecx_100;
				ebp_107 = ecx_100;
				dwLoc20_388 = esi_104;
			}
		}
		else
		{
			_IO_wdoallocbuf(dwArg04);
			_IO_free_wbackup_area(dwArg04);
			eax_119 = *((word32) dwArg04 + 88);
			Eq_2 edi_64 = *((word32) dwArg04 + 16);
			ecx_100 = *((word32) eax_119 + 24);
			*((word32) eax_119 + 8) = ecx_100;
			*eax_119 = ecx_100;
			*((word32) eax_119 + 4) = ecx_100;
			if (edi_64 != 0x00)
			{
				ebp_107 = ecx_100;
				edx_135 = (ui32) *dwArg04;
				dwLoc24_387 = *((word32) eax_119 + 28);
				esi_104 = *((word32) dwArg04 + 4);
				dwLoc20_388 = *((word32) dwArg04 + 8);
			}
			else
			{
				word32 edi_524;
				word32 ebp_522;
				word32 esi_523;
				_IO_doallocbuf(dwArg04, out ebp_522, out esi_523, out edi_524);
				eax_119 = *((word32) dwArg04 + 88);
				esi_104 = *((word32) dwArg04 + 28);
				edx_135 = (ui32) *dwArg04;
				Eq_2 edi_84 = *((word32) eax_119 + 28);
				ecx_100 = *eax_119;
				*((word32) dwArg04 + 8) = esi_104;
				ebp_107 = *((word32) eax_119 + 4);
				dwLoc24_387 = edi_84;
				dwLoc20_388 = esi_104;
			}
		}
		*((word32) eax_119 + 16) = ecx_100;
		*((word32) eax_119 + 0x0C) = ecx_100;
		*((word32) eax_119 + 20) = dwLoc24_387;
		*eax_119 = ebp_107;
		*((word32) eax_119 + 8) = ebp_107;
		*((word32) dwArg04 + 20) = esi_104;
		*((word32) dwArg04 + 16) = esi_104;
		*((word32) dwArg04 + 24) = *((word32) dwArg04 + 32);
		*((word32) dwArg04 + 4) = dwLoc20_388;
		*((word32) dwArg04 + 0x0C) = dwLoc20_388;
		*dwArg04 = edx_135 | 0x0800;
		if ((edx_135 & 0x0202) != 0x00)
		{
			*((word32) eax_119 + 20) = ecx_100;
			if (dwArg08 != ~0x00)
			{
l080528FE:
				Eq_2 edx_205 = *((word32) dwArg04 + 88);
				Eq_2 eax_206 = *((word32) edx_205 + 16);
				if (eax_206 == *((word32) edx_205 + 28))
				{
					int8 al_237;
					if (*((word32) dwArg04 + 0x0068) > 0x00)
					{
						Eq_2 edx_238 = *((word32) edx_205 + 0x0C);
						word32 ebx_518;
						word32 esi_519;
						al_237 = (int8) (_IO_wdo_write(gs, dwArg04, edx_238, eax_206 - edx_238 >> 0x02, out ebx_518, out esi_519) == ~0x00);
					}
					else
						al_237 = (int8) (_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16)) == ~0x00);
					if (al_237 != 0x00)
						return ~0x00;
					edx_205 = *((word32) dwArg04 + 88);
					eax_206 = *((word32) edx_205 + 16);
				}
				Eq_2 ecx_270 = (word32) eax_206 + 4;
				*((word32) edx_205 + 16) = ecx_270;
				*eax_206 = dwArg08;
				ui32 eax_275 = *dwArg04;
				byte ah_280 = SLICE(eax_275, byte, 8);
				if (((byte) eax_275 & 0x02) != 0x00 || (ah_280 & 0x02) != 0x00 && dwArg08 == 0x0A)
				{
					int8 al_323;
					if (*((word32) dwArg04 + 0x0068) > 0x00)
					{
						Eq_2 eax_325 = *((word32) edx_205 + 0x0C);
						word32 esi_517;
						word32 ebx_516;
						al_323 = (int8) (_IO_wdo_write(gs, dwArg04, eax_325, ecx_270 - eax_325 >> 0x02, out ebx_516, out esi_517) == ~0x00);
					}
					else
						al_323 = (int8) (_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16)) == ~0x00);
					if (al_323 != 0x00)
						return ~0x00;
				}
				eax_178 = dwArg08;
				return eax_178;
			}
l080529AE:
			if (*((word32) dwArg04 + 0x0068) > 0x00)
			{
				Eq_2 eax_184 = *((word32) dwArg04 + 88);
				Eq_2 edx_186 = *((word32) eax_184 + 0x0C);
				word32 ebx_520;
				word32 esi_521;
				eax_178 = _IO_wdo_write(gs, dwArg04, edx_186, *((word32) eax_184 + 16) - edx_186 >> 0x02, out ebx_520, out esi_521);
			}
			else
				eax_178 = _IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16));
			return eax_178;
		}
	}
	if (dwArg08 != ~0x00)
		goto l080528FE;
	goto l080529AE;
}

// 08052B30: void _IO_wfile_sync(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wfile_sync(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_20 = *((word32) dwArg04 + 88);
	Eq_2 esp_18 = fp - 44;
	Eq_2 ebx_19 = dwArg04;
	Eq_2 eax_21 = *((word32) edx_20 + 16);
	Eq_2 ecx_22 = *((word32) edx_20 + 0x0C);
	if (eax_21 > ecx_22)
	{
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			Eq_2 esp_69 = <invalid>;
			esp_18 = (word32) esp_69 + 16;
			word32 esi_315;
			if ((int8) (_IO_wdo_write(gs, dwArg04, ecx_22, eax_21 - ecx_22 >> 0x02, out ebx_19, out esi_315) != 0x00) != 0x00)
				return;
		}
		else
		{
			esp_18 = fp - 44;
			if ((int8) (_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16)) != 0x00) != 0x00)
				return;
		}
		edx_20 = *((word32) ebx_19 + 88);
	}
	Eq_2 edi_87 = *edx_20;
	Eq_2 edx_88 = *((word32) edx_20 + 4);
	*((word32) esp_18 + 0x0C) = edx_88;
	if (edi_87 != edx_88)
	{
		int32 edi_146;
		Eq_2 ebp_95 = *((word32) ebx_19 + 84);
		struct Eq_17267 * esp_96 = esp_18 - 0x0C;
		esp_96->tFFFFFFFC = ebp_95;
		int32 eax_107;
		(*((word32) ebp_95 + 16))();
		if (eax_107 > 0x00)
			edi_146 = (edi_87 - esp_96->dw0018 >> 0x02) *s eax_107;
		else
		{
			Eq_2 ecx_113 = *((word32) ebx_19 + 88);
			Eq_2 edx_115 = *((word32) ecx_113 + 56);
			Eq_2 eax_116 = *((word32) ecx_113 + 52);
			int32 edi_119 = *ecx_113 - *((word32) ecx_113 + 8);
			*((word32) ecx_113 + 48) = edx_115;
			*((word32) ecx_113 + 44) = eax_116;
			esp_96->tFFFFFFFC = edi_119 >> 0x02;
			esp_96->tFFFFFFF8 = *((word32) ebx_19 + 8);
			esp_96->tFFFFFFF4 = *((word32) ebx_19 + 0x0C);
			esp_96->ptrFFFFFFF0 = (word32) ecx_113 + 44;
			esp_96->tFFFFFFEC = ebp_95;
			word32 eax_137;
			(*((word32) ebp_95 + 24))();
			Eq_2 edx_140 = *((word32) ebx_19 + 0x0C);
			word32 edx_142 = edx_140 - *((word32) ebx_19 + 8);
			*((word32) ebx_19 + 4) = (word32) edx_140 + eax_137;
			edi_146 = edx_142 + eax_137;
		}
		Eq_2 esp_164 = esp_18;
		Eq_2 ebp_154 = *((word32) ebx_19 + 0x0094);
		if (ebp_154 >= 135066356)
		{
			word32 edx_317;
			word32 ecx_316;
			_IO_vtable_check(out ecx_316, out edx_317);
			esp_164.u0 = <invalid>;
		}
		struct Eq_17361 * esp_174 = esp_164 - 4;
		esp_174->dw0000 = 0x01;
		int64 edx_eax_176 = (int64) edi_146;
		word32 edx_178 = SLICE(edx_eax_176, word32, 32);
		esp_174->dwFFFFFFFC = edx_178;
		esp_174->dwFFFFFFF8 = edi_146;
		esp_174->tFFFFFFF4 = ebx_19;
		ui32 edx_193;
		ui32 eax_194;
		(*((word32) ebp_154 + 64))();
		if ((eax_194 & edx_193) != ~0x00)
		{
			Eq_2 eax_219 = *((word32) ebx_19 + 88);
			*((word32) eax_219 + 4) = *eax_219;
			*((word32) ebx_19 + 8) = *((word32) ebx_19 + 4);
		}
		else if (gs->tFFFFFFE0 != 0x1D)
			return;
	}
	((word32) ebx_19 + 76)->u0 = ~0x00;
	((word32) ebx_19 + 80)->u0 = ~0x00;
}

// 08052CB0: void _IO_wfile_xsputn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_17418 dwArg0C)
void _IO_wfile_xsputn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_17418 dwArg0C)
{
	if (dwArg0C == 0x00)
		return;
	word32 dwLoc24_256;
	Eq_17418 ebx_33;
	Eq_2 ecx_24 = *((word32) dwArg04 + 88);
	Eq_2 ebx_26 = *((word32) ecx_24 + 20);
	Eq_2 edi_133 = *((word32) ecx_24 + 16);
	if ((*dwArg04 & 0x0A00) != 0x0A00)
	{
		dwLoc24_256 = 0x00;
		ebx_33 = ebx_26 - edi_133 >> 0x02;
	}
	else
	{
		int32 ebx_32 = *((word32) ecx_24 + 28) - edi_133;
		dwLoc24_256 = 0x00;
		ebx_33 = ebx_32 >> 0x02;
		if (dwArg0C <= ebx_32 >> 0x02)
		{
			Eq_2 eax_37 = (word32) dwArg08 + dwArg0C * 0x04;
			if (dwArg08 < eax_37)
			{
				Eq_2 esi_41 = eax_37 - 0x04;
				if (*((word32) eax_37 - 4) != 0x0A)
				{
					do
					{
						if (dwArg08 >= esi_41)
						{
							dwLoc24_256 = 0x00;
							goto l08052CF5;
						}
						esi_41 -= (word32 *) 0x04;
					} while (*esi_41 != 0x0A);
				}
				dwLoc24_256 = 0x01;
				ebx_33 = (esi_41 - dwArg08 >> 0x02) + 0x01;
			}
		}
	}
l08052CF5:
	Eq_17418 ebx_155;
	if (ebx_33 != 0x00)
	{
		if (dwArg0C <= ebx_33)
			ebx_33 = dwArg0C;
		if (ebx_33 <= 0x14)
		{
			ui32 eax_122 = ebx_33 * 0x04;
			Eq_2 eax_127 = (word32) edi_133 + eax_122;
			Eq_2 esi_129 = dwArg08;
			do
			{
				*edi_133 = *esi_129;
				esi_129 = (word32) esi_129 + 4;
				edi_133 = (word32) edi_133 + 4;
			} while (edi_133 != eax_127);
			*((word32) ecx_24 + 16) = edi_133;
			dwArg08 = (word32) dwArg08 + eax_122;
		}
		else
		{
			*((word32) ecx_24 + 16) = __wmempcpy(edi_133, dwArg08, ebx_33);
			dwArg08 = (word32) dwArg08 + ebx_33 * 0x04;
		}
		Eq_17418 eax_153 = dwArg0C - ebx_33;
		ebx_155 = eax_153;
		if (eax_153 == 0x00)
		{
l08052D3C:
			if (dwLoc24_256 != 0x00)
			{
				Eq_2 ecx_195 = *((word32) dwArg04 + 88);
				Eq_2 eax_196 = *((word32) ecx_195 + 16);
				Eq_2 ecx_197 = *((word32) ecx_195 + 0x0C);
				if (eax_196 != ecx_197)
				{
					word32 ebx_362;
					word32 esi_363;
					_IO_wdo_write(gs, dwArg04, ecx_197, eax_196 - ecx_197 >> 0x02, out ebx_362, out esi_363);
				}
			}
			return;
		}
	}
	else
		ebx_155 = dwArg0C;
	_IO_wdefault_xsputn(dwArg04, dwArg08, ebx_155);
	goto l08052D3C;
}

// 08052E50: Register Eq_2 vasprintf(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04)
// Called from:
//      ___asprintf
Eq_2 vasprintf(struct Eq_9 * gs, union Eq_2 * dwArg04)
{
	Eq_2 edi_228;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	ui32 eax_24 = gs->dw0014;
	Eq_2 stackArg0 = <invalid>;
	word32 ebp_406;
	word32 esi_407;
	word32 edi_408;
	word32 ecx_403;
	word32 edx_404;
	word32 ebx_405;
	Eq_2 eax_31 = __libc_malloc(gs, stackArg0, 100, out ecx_403, out edx_404, out ebx_405, out ebp_406, out esi_407, out edi_408);
	if (eax_31 == 0x00)
	{
		edi_228.u0 = ~0x00;
		goto l08052F8F;
	}
	_IO_no_init(fp - 0xC0, 0x8000, ~0x00, 0x00, 0x00);
	_IO_str_init_static_internal(fp - 0xC0, eax_31, 100, eax_31);
	word32 edx_410;
	word32 ebx_411;
	word32 ebp_412;
	word32 edi_413;
	word32 ecx_409;
	Eq_2 eax_94 = vfprintf(0x080CE000, gs, fp - 0xC0, dwArg08, dwArg0C, out ecx_409, out edx_410, out ebx_411, out ebp_412, out edi_413);
	edi_228 = eax_94;
	if (eax_94 < 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_415;
		word32 edx_416;
		free(gs, stackArg0, dwLocA4, out ecx_415, out edx_416);
		goto l08052F8F;
	}
	Eq_2 eax_132;
	struct Eq_17628 * esp_137;
	Eq_2 esi_120 = dwLocAC - dwLocB0;
	if (dwLocA8 - dwLocB0 >> 0x01 > (word32) esi_120 + 1)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_423;
		word32 edx_424;
		word32 ebx_425;
		word32 ebp_426;
		word32 esi_427;
		word32 edi_428;
		Eq_2 eax_148 = __libc_malloc(gs, stackArg0, (word32) esi_120 + 1, out ecx_423, out edx_424, out ebx_425, out ebp_426, out esi_427, out edi_428);
		*dwArg04 = (union Eq_2 *) eax_148;
		if (eax_148 != 0x00)
		{
			word32 ecx_434;
			word32 edx_435;
			memcpy(eax_148, dwLocA4, esi_120, out ecx_434, out edx_435);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_437;
			word32 edx_438;
			free(gs, stackArg0, dwLocA4, out ecx_437, out edx_438);
			eax_132 = *dwArg04;
			esp_137 = fp - 0xD8;
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_430;
			word32 ebp_431;
			word32 esi_432;
			word32 edi_433;
			eax_132 = __realloc(gs, stackArg0, dwLocA4, (word32) esi_120 + 1, out edx_430, out ebp_431, out esi_432, out edi_433);
			*dwArg04 = (union Eq_2 *) eax_132;
			esp_137 = fp - 220;
		}
		if (eax_132 != 0x00)
		{
l08052F8B:
			Mem216[eax_132 + esi_120:byte] = 0x00;
l08052F8F:
			if ((eax_24 ^ gs->dw0014) == 0x00)
				return edi_228;
			word32 ecx_439;
			word32 edx_440;
			Eq_2 eax_247 = __stack_chk_fail(out ecx_439, out edx_440);
			backtrace_and_maps.constprop.0();
			return eax_247;
		}
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_418;
		word32 ebp_419;
		word32 esi_420;
		word32 edi_421;
		eax_132 = __realloc(gs, stackArg0, dwLocA4, (word32) esi_120 + 1, out edx_418, out ebp_419, out esi_420, out edi_421);
		*dwArg04 = (union Eq_2 *) eax_132;
		esp_137 = fp - 220;
		if (eax_132 != 0x00)
			goto l08052F8B;
	}
	eax_132 = esp_137->t0038;
	*esp_137->ptr0004 = (union Eq_2 *) eax_132;
	goto l08052F8B;
}

// 08053020: void backtrace_and_maps.constprop.0()
// Called from:
//      vasprintf
void backtrace_and_maps.constprop.0()
{
}

// 08053030: void __libc_message(Register (ptr32 Eq_9) gs, Stack ui32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __libc_fatal
//      malloc_printerr
//      __fortify_fail_abort
void __libc_message(struct Eq_9 * gs, ui32 dwArg04, Eq_2 dwArg08)
{
	struct Eq_17748 * esp_189 = fp - 0x4C;
	Eq_2 edi_148 = dwArg08;
	ui32 eax_23 = gs->dw0014;
	word32 * dwLoc40_539 = fp + 0x0C;
	if (((byte) dwArg04 & 0x02) != 0x00)
	{
		Eq_2 eax_37 = __libc_secure_getenv(134883300);
		esp_189 = fp - 0x48;
		if (eax_37 == 0x00 || *eax_37 == 0x00)
		{
			esp_189 = fp - 0x48;
			word32 ecx_841;
			word32 edx_842;
			if (__open_nocancel(gs, 134883319, 0x0902, dwLoc50, out ecx_841, out edx_842) != ~0x00)
			{
l0805306F:
				byte al_87 = *dwArg08;
				ui32 dwLoc38_547 = 0x00;
				byte bLoc30_549 = al_87;
				struct Eq_17806 * dwLoc34_550 = null;
				if (al_87 != 0x00)
				{
					while (true)
					{
						byte dl_101 = bLoc30_549;
						Eq_2 eax_100 = edi_148;
						while (dl_101 != 0x25 || *((word32) eax_100 + 1) != 115)
						{
							struct Eq_17810 * esp_110 = esp_189 - 0x08;
							esp_110->tFFFFFFFC.u0 = 0x25;
							esp_110->tFFFFFFF8 = (word32) eax_100 + 1;
							eax_100 = strchrnul(esp_110->tFFFFFFF8, esp_110->tFFFFFFFC);
							dl_101 = (byte) *eax_100;
							if (dl_101 == 0x00)
								break;
						}
						Eq_2 ecx_165;
						Eq_2 ebx_152;
						if (bLoc30_549 != 0x25 || *((word32) edi_148 + 1) != 115)
						{
							ebx_152 = edi_148;
							ecx_165 = eax_100 - edi_148;
							edi_148 = eax_100;
						}
						else
						{
							struct Eq_17949 * esp_147 = esp_189 - (struct Eq_17950 *) 0x0C;
							ebx_152 = *dwLoc40_539;
							esp_147->tFFFFFFFC = ebx_152;
							edi_148 = (word32) edi_148 + 2;
							++dwLoc40_539;
							word32 edx_844;
							word32 ecx_843;
							ecx_165 = strlen(esp_147->tFFFFFFFC, out ecx_843, out edx_844);
						}
						esp_189 -= 0x20;
						esp_189->dw001C = esp_189->dw001C;
						word32 edx_202 = esp_189 + 0x0F & ~0x0F;
						edx_202->ptr0008 = dwLoc34_550;
						edx_202->t0000 = ebx_152;
						edx_202->t0004 = ecx_165;
						byte al_219 = *edi_148;
						ui32 dwLoc3C_576 = dwLoc38_547 + 0x01;
						bLoc30_549 = al_219;
						if (al_219 == 0x00)
							break;
						dwLoc34_550 = edx_202;
						dwLoc38_547 = dwLoc3C_576;
					}
					ui32 eax_228 = dwLoc3C_576 * 0x08 + 0x1B;
					Eq_2 ebx_226 = ecx_165;
					struct Eq_17748 * ecx_231 = esp_189 - (eax_228 & ~0x0FFF);
					while (esp_189 != ecx_231)
					{
						esp_189 -= (struct Eq_17903 *) 0x1000;
						esp_189->dw0FFC = esp_189->dw0FFC;
					}
					struct Eq_17896 * eax_254 = eax_228 & ~0x0F & 0x0FFF;
					if (eax_254 != null)
					{
						esp_189 -= eax_254;
						Mem261[esp_189 - 0x04 + eax_254:word32] = Mem250[esp_189 - 0x04 + eax_254:word32];
					}
					word32 eax_265 = esp_189 + 0x0F;
					struct Eq_17806 * edx_274 = dwLoc34_550;
					ui32 dwLoc40_588 = dwLoc38_547 << 0x03;
					struct Eq_17928 * eax_280 = (eax_265 & ~0x0F) + (dwLoc38_547 << 0x03);
					int32 edi_281 = 0x00;
					Eq_2 ecx_285 = ebx_152;
					while (true)
					{
						eax_280->dw0000 = (word32) ecx_285;
						eax_280->dw0004 = (word32) ebx_226;
						int32 ebx_293 = (word32) ebx_226 + edi_281;
						struct Eq_17928 * ecx_289 = eax_280 - 0x08;
						edi_281 = ebx_293;
						if ((eax_265 & ~0x0F) == eax_280)
							break;
						ecx_285 = edx_274->t0000;
						ebx_226 = edx_274->t0004;
						eax_280 = ecx_289;
						edx_274 = edx_274->ptr0008;
					}
					do
					{
						word32 eax_318;
						word32 edx_319;
						word32 ecx_320;
						gs->ptr0010();
					} while (eax_318 == ~0x03);
					if ((dwArg04 & 0x01) == 0x00)
					{
l080532A7:
						if ((eax_23 ^ gs->dw0014) == 0x00)
							return;
						word32 ecx_852;
						word32 edx_853;
						__stack_chk_fail(out ecx_852, out edx_853);
						word32 ecx_854;
						__libc_fatal(out ecx_854);
						return;
					}
					struct Eq_17995 * esp_330 = esp_189 - (struct Eq_17996 *) 0x08;
					Eq_2 eax_331 = _dl_pagesize;
					esp_330->tFFFFFFFC.u0 = 0x00;
					esp_330->tFFFFFFF8.u0 = ~0x00;
					esp_330->tFFFFFFF4.u0 = 0x22;
					esp_330->dwFFFFFFF0 = 0x03;
					Eq_2 edi_340 = (word32) eax_331 + ebx_293 & -eax_331;
					esp_330->tFFFFFFEC = edi_340;
					esp_330->tFFFFFFE8.u0 = 0x00;
					word32 ecx_845;
					word32 edx_846;
					Eq_2 eax_349 = mmap(gs, esp_330->tFFFFFFE8, esp_330->tFFFFFFEC, esp_330->dwFFFFFFF0, esp_330->tFFFFFFF4, esp_330->tFFFFFFF8, esp_330->tFFFFFFFC, out ecx_845, out edx_846);
					if (eax_349 != ~0x00)
					{
						*eax_349 = edi_340;
						Eq_2 eax_362 = (word32) eax_349 + 4;
						struct Eq_18067 * ebx_365 = (eax_265 & ~0x0F) + 0x04;
						struct Eq_18067 * edi_366 = (eax_265 & ~0x0F) + 0x08 + dwLoc40_588;
						do
						{
							struct Eq_18076 * esp_369 = esp_189 - (struct Eq_18077 *) 0x04;
							esp_369->tFFFFFFFC = ebx_365->dw0000;
							++ebx_365;
							esp_369->tFFFFFFF8 = ebx_365->dwFFFFFFF8;
							esp_369->tFFFFFFF4 = eax_362;
							word32 edx_848;
							eax_362 = __mempcpy(esp_369->tFFFFFFF4, esp_369->tFFFFFFF8, esp_369->tFFFFFFFC, out edx_848);
						} while (ebx_365 != edi_366);
						*eax_362 = 0x00;
						Eq_2 v23_399 = __abort_msg;
						__abort_msg = eax_349;
						if (v23_399 != 0x00)
						{
							esp_369->tFFFFFFF8 = *v23_399;
							esp_369->tFFFFFFF4 = v23_399;
							word32 ecx_849;
							word32 edx_850;
							word32 ebx_851;
							__munmap(v23_399, gs, esp_369->tFFFFFFF4, esp_369->tFFFFFFF8, out ecx_849, out edx_850, out ebx_851);
						}
					}
l08053297:
					Eq_2 ecx_433;
					word32 edx_847;
					abort(ecx_433, gs, out ecx_433, out edx_847);
				}
				if ((dwArg04 & 0x01) == 0x00)
					goto l080532A7;
				goto l08053297;
			}
		}
	}
	goto l0805306F;
}

// 08053320: Register word32 __libc_fatal(Register out (ptr32 (arr Eq_2)) ecxOut)
// Called from:
//      __libc_start_main
//      __libc_message
//      _IO_vtable_check
//      printf_positional
//      printf_positional
//      __libc_disable_asynccancel
word32 __libc_fatal(Eq_2 (& ecxOut)
{
	while (true)
		__libc_message(gs, 0x03, 134976566);
}

// 08053360: Register ptr32 _IO_vtable_check(Register out Eq_979 ecxOut, Register out Eq_12676 edxOut)
// Called from:
//      __new_fclose
//      fflush
//      _IO_puts
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_sync
//      _IO_file_seekoff_maybe_mmap
//      new_do_write
//      _IO_new_file_underflow
//      mmap_remap_check
//      decide_maybe_mmap
//      _IO_file_underflow_maybe_mmap
//      _IO_file_xsgetn_maybe_mmap
//      _IO_new_file_seekoff
//      _IO_file_xsgetn_mmap
//      _IO_file_xsgetn
//      _IO_file_seekoff_mmap
//      _IO_file_underflow_mmap
//      _IO_file_xsputn
//      _IO_file_open
//      _IO_file_attach
//      _IO_file_close_it
//      _IO_new_file_finish
//      _IO_new_file_sync
//      _IO_switch_to_get_mode
//      __overflow
//      __underflow
//      __uflow
//      _IO_doallocbuf
//      _IO_default_uflow
//      _IO_default_xsputn
//      _IO_sgetn
//      _IO_default_setbuf
//      _IO_default_seekpos
//      _IO_sputbackc
//      _IO_sungetc
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      _IO_helper_overflow
//      printf_positional
//      vfprintf
//      buffered_vfprintf
//      __printf_fp_l
//      _IO_helper_overflow
//      printf_positional
//      __vfwprintf
//      buffered_vfprintf
//      _IO_file_doallocate
//      fputs
//      fwrite
//      _IO_padn
//      _IO_wpadn
//      _IO_wdefault_uflow
//      __woverflow
//      __wuflow
//      __wunderflow
//      _IO_sputbackwc
//      _IO_sungetwc
ptr32 _IO_vtable_check(union Eq_979 & ecxOut, union Eq_12676 & edxOut)
{
	ecxOut.u0 = <invalid>;
	edxOut.u0 = 0x08099D30;
	return 0x080CE000;
}

// 08053390: Register Eq_2 fgets_unlocked(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_7617 edxOut)
// Called from:
//      read_alias_file
//      _IO_vtable_check
Eq_2 fgets_unlocked(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_7617 & edxOut)
{
	if (dwArg08 <= 0x00)
	{
		edxOut = edx;
		return 0x00;
	}
	Eq_2 ecx_40;
	if (dwArg08 == 0x01)
	{
		*dwArg04 = 0x00;
		ecx_40 = dwArg04;
		goto l080533EC;
	}
	Eq_7617 edx_41 = *dwArg0C;
	*dwArg0C = edx_41 & ~0x20;
	int32 eax_60 = _IO_getline();
	edx = *dwArg0C;
	byte dl_70 = (byte) edx;
	ecx_40.u0 = 0x00;
	if (eax_60 != 0x00)
	{
		if ((dl_70 & 0x20) != 0x00)
		{
			ecx_40.u0 = 0x00;
			if (gs->tFFFFFFE0 != 11)
				goto l080533E7;
		}
		*((word32) dwArg04 + eax_60) = 0x00;
		ecx_40 = dwArg04;
		edx = *dwArg0C;
		goto l080533E7;
	}
	else
	{
l080533E7:
		*dwArg0C = edx_41 & 0x20 | edx;
l080533EC:
		edxOut = edx;
		return ecx_40;
	}
}

// 08053440: void _IO_file_seekoff_maybe_mmap(Stack (ptr32 Eq_18220) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
void _IO_file_seekoff_maybe_mmap(struct Eq_18220 * dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	struct Eq_18224 * ebp_25 = dwArg04->ptr0094;
	if (ebp_25 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 ecx_109;
		word32 edx_110;
		_IO_vtable_check(out ecx_109, out edx_110);
	}
	int32 edx_53;
	word32 eax_54;
	ebp_25->ptr0040();
	if (edx_53 >= 0x00)
	{
		dwArg04->dw004C = eax_54;
		dwArg04->dw0050 = edx_53;
	}
}

// 080534C0: void _IO_file_close(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_18250) dwArg04)
void _IO_file_close(struct Eq_9 * gs, struct Eq_18250 * dwArg04)
{
	Eq_2 eax_6 = dwArg04->t0038;
	word32 edx_17;
	__close_nocancel(gs, eax_6, out edx_17);
}

// 080534E0: void _IO_new_file_setbuf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _IO_new_file_setbuf(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	if (_IO_default_setbuf(gs, dwArg04, dwArg08) != 0x00)
	{
		Eq_2 eax_35 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 24) = eax_35;
		*((word32) dwArg04 + 20) = eax_35;
		*((word32) dwArg04 + 16) = eax_35;
		*((word32) dwArg04 + 0x0C) = eax_35;
		*((word32) dwArg04 + 4) = eax_35;
		*((word32) dwArg04 + 8) = eax_35;
	}
}

// 08053530: void _IO_file_setbuf_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _IO_file_setbuf_mmap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	((word32) dwArg04 + 0x0094)->u0 = 0x080CF180;
	((word32) *((word32) dwArg04 + 88) + 0x00B0)->u0 = 0x080CF060;
	if (_IO_default_setbuf(gs, dwArg04, dwArg08) != 0x00)
	{
		Eq_2 eax_45 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 24) = eax_45;
		*((word32) dwArg04 + 20) = eax_45;
		*((word32) dwArg04 + 16) = eax_45;
		*((word32) dwArg04 + 0x0C) = eax_45;
		*((word32) dwArg04 + 4) = eax_45;
		*((word32) dwArg04 + 8) = eax_45;
	}
	else
	{
		((word32) dwArg04 + 0x0094)->u0 = 0x080CF120;
		((word32) *((word32) dwArg04 + 88) + 0x00B0)->u0 = 0x080CF000;
	}
}

// 080535C0: Register (ptr32 Eq_18343) new_do_write(Register (ptr32 Eq_18343) eax, Register Eq_2 ecx, Register (ptr32 Eq_18345) edx)
// Called from:
//      _IO_file_xsputn
//      _IO_do_write
struct Eq_18343 * new_do_write(struct Eq_18343 * eax, Eq_2 ecx, struct Eq_18345 * edx)
{
	struct Eq_18343 * ebp_125;
	Eq_2 ecx_100;
	Eq_2 ebp_23 = eax->t0094;
	Eq_2 eax_118 = 0x0354;
	ptr32 edx_116 = ebp_23 - 0x080CEFA0;
	if ((eax->dw0000 & 0x1000) != 0x00)
	{
		eax->t004C.u0 = ~0x00;
		eax->dw0050 = ~0x00;
		ecx_100 = ecx;
	}
	else
	{
		ecx_100 = eax->t0008;
		eax_118 = eax->t0010;
		if (ecx_100 != eax_118)
		{
			if (ebp_23 >= 135066356)
			{
				word32 ecx_260;
				word32 edx_261;
				_IO_vtable_check(out ecx_260, out edx_261);
				eax_118 = eax->t0010;
				ecx_100 = eax->t0008;
			}
			int64 edx_eax_54 = (int64) (eax_118 - ecx_100);
			word32 edx_56 = SLICE(edx_eax_54, word32, 32);
			word32 eax_59 = (word32) edx_eax_54;
			ui32 edx_68;
			(*((word32) ebp_23 + 64))();
			ebp_125 = null;
			ecx_100 = eax_118 & edx_68;
			if (ecx_100 == ~0x00)
				return ebp_125;
			ebp_23 = eax->t0094;
			eax->dw0050 = edx_68;
			eax->t004C = eax_118;
			edx_116 = ebp_23 - 0x080CEFA0;
		}
	}
	if (edx_116 >= 0x0354)
		eax_118 = _IO_vtable_check(out ecx_100, out edx_116);
	struct Eq_18343 * eax_122;
	(*((word32) ebp_23 + 60))();
	word32 eax_126 = (word32) eax->w0044;
	ebp_125 = eax_122;
	if ((word16) eax_126 != 0x00 && eax_122 != null)
		eax->w0044 = (word16) ((uint32) _IO_adjust_column(eax_126 - 0x01, edx, eax_122) + 0x01);
	Eq_2 eax_158 = eax->t001C;
	int32 edx_159 = eax->dw0068;
	eax->t000C = eax_158;
	eax->t0004 = eax_158;
	eax->t0008 = eax_158;
	eax->t0014 = eax_158;
	eax->t0010 = eax_158;
	if (edx_159 > 0x00 || (eax->dw0000 & 0x0202) == 0x00)
		eax_158 = eax->t0020;
	eax->t0018 = eax_158;
	return ebp_125;
}

// 080536F0: void _IO_new_file_underflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_new_file_underflow(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_104 = *dwArg04;
	struct Eq_18498 * ebp_101 = fp - 4;
	struct Eq_18502 * edi_108 = &g_t80CE000;
	Eq_2 esp_178 = fp - 44;
	Eq_2 esi_20 = dwArg04;
	byte al_22 = (byte) eax_104;
	if ((al_22 & 0x10) != 0x00)
		return;
	if ((al_22 & 0x04) != 0x00)
	{
		*dwArg04 = eax_104 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		return;
	}
	if (*((word32) dwArg04 + 4) < *((word32) dwArg04 + 8))
		return;
	if (*((word32) dwArg04 + 28) == 0x00)
	{
		Eq_2 eax_55 = *((word32) dwArg04 + 36);
		if (eax_55 != 0x00)
		{
			word32 edx_479;
			word32 ecx_478;
			free(gs, dwLoc40, eax_55, out ecx_478, out edx_479);
			*dwArg04 &= ~0x0100;
			esp_178 = fp - 0x28;
		}
		struct Eq_18866 * esp_78 = esp_178 - 0x0C;
		esp_78->tFFFFFFFC = dwArg04;
		_IO_doallocbuf(esp_78->tFFFFFFFC, out ebp_101, out esi_20, out edi_108);
		eax_104 = (ui32) *esi_20;
		esp_178 = (char *) &esp_78->tFFFFFFFC + 16;
	}
	ebp_101->dwFFFFFFE0 = 0x080CEFA0;
	ebp_101->dwFFFFFFE4 = 0x0354;
	if ((eax_104 & 0x0202) == 0x00)
	{
l080537E0:
		struct Eq_18556 * esp_256 = esp_178 - 0x0C;
		esp_256->tFFFFFFFC = esi_20;
		word32 ecx_473;
		_IO_switch_to_get_mode(esp_256->tFFFFFFFC, out ecx_473);
		Eq_2 eax_272 = *((word32) esi_20 + 28);
		Eq_2 ebx_273 = *((word32) esi_20 + 0x0094);
		*((word32) esi_20 + 4) = eax_272;
		up32 edx_280 = ebx_273 - ebp_101->dwFFFFFFE0;
		*((word32) esi_20 + 0x0C) = eax_272;
		*((word32) esi_20 + 8) = eax_272;
		*((word32) esi_20 + 24) = eax_272;
		*((word32) esi_20 + 20) = eax_272;
		*((word32) esi_20 + 16) = eax_272;
		Eq_2 esp_274 = (char *) &esp_256->tFFFFFFFC + 16;
		if (edx_280 >= ebp_101->dwFFFFFFE4)
		{
			word32 ecx_476;
			word32 edx_477;
			_IO_vtable_check(out ecx_476, out edx_477);
			esp_274.u0 = <invalid>;
			eax_272 = *((word32) esi_20 + 28);
		}
		struct Eq_18790 * esp_300 = esp_274 - 0x04;
		word32 edx_302 = *((word32) esi_20 + 32) - eax_272;
		esp_300->dwFFFFFFFC = edx_302;
		esp_300->tFFFFFFF8 = eax_272;
		esp_300->tFFFFFFF4 = esi_20;
		int32 eax_320;
		word32 ecx_322;
		(*((word32) ebx_273 + 56))();
		if (eax_320 <= 0x00)
		{
			ui32 edx_327 = *esi_20;
			((word32) esi_20 + 76)->u0 = ~0x00;
			((word32) esi_20 + 80)->u0 = ~0x00;
			ui32 edx_331 = edx_327 | 0x10;
			if (eax_320 != 0x00)
				edx_331 = edx_327 | 0x20;
			*esi_20 = edx_331;
			return;
		}
		else
		{
			Eq_2 ecx_351 = *((word32) esi_20 + 76);
			Eq_2 ebx_352 = *((word32) esi_20 + 80);
			*((word32) esi_20 + 8) = (word32) *((word32) esi_20 + 8) + eax_320;
			if ((ecx_351 & ebx_352) != ~0x00)
			{
				int64 edx_eax_387 = (int64) eax_320 + SEQ(ebx_352, ecx_351);
				*((word32) esi_20 + 76) = (word32) edx_eax_387;
				*((word32) esi_20 + 80) = SLICE(edx_eax_387, word32, 32);
			}
			return;
		}
	}
	Eq_2 ecx_109 = edi_108->t0478;
	ui32 eax_110 = *ecx_109;
	ebp_101->tFFFFFFDC = ecx_109;
	ebp_101->tFFFFFFD8 = eax_110 & 0x8000;
	if ((eax_110 & 0x8000) == 0x00)
	{
		Eq_2 edx_122 = *((word32) ecx_109 + 72);
		Eq_2 ebx_125 = gs->t0008;
		if (*((word32) edx_122 + 8) != ebx_125)
		{
			Eq_2 eax_128 = ebp_101->tFFFFFFD8;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_136;
			if (!__cmpxchg(*edx_122, 0x01, eax_128, out eax_136))
				__lll_lock_wait_private(eax_136, edx_122, gs);
			edx_122 = *((word32) ebp_101->tFFFFFFDC + 72);
			ecx_109 = edi_108->t0478;
			*((word32) edx_122 + 8) = ebx_125;
			eax_110 = (ui32) *ecx_109;
		}
		*((word32) edx_122 + 4) = (word32) *((word32) edx_122 + 4) + 1;
		if ((eax_110 & 0x0288) != 0x0280)
		{
l080537C2:
			Eq_2 eax_225 = ebp_101->tFFFFFFDC;
			Eq_2 edi_226 = *eax_225;
			ebp_101->tFFFFFFDC = edi_226;
			if ((edi_226 & 0x8000) == 0x00)
			{
				Eq_2 edx_232 = *((word32) eax_225 + 72);
				Eq_2 v17_233 = *((word32) edx_232 + 4) - 0x01;
				*((word32) edx_232 + 4) = v17_233;
				if (v17_233 == 0x00)
				{
					((word32) edx_232 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v19_243 = *edx_232 - 0x01;
					*edx_232 = v19_243;
					if (v19_243 != 0x00)
						__lll_unlock_wake_private(edx_232, ecx_109, edx_232, gs);
				}
			}
			goto l080537E0;
		}
	}
	else
	{
		if ((eax_110 & 0x0288) != 0x0280)
			goto l080537E0;
		ecx_109 = ebp_101->tFFFFFFDC;
	}
	Eq_2 ebx_169 = *((word32) ecx_109 + 0x0094);
	if (ebx_169 - ebp_101->dwFFFFFFE0 >= ebp_101->dwFFFFFFE4)
	{
		word32 edx_475;
		word32 ecx_474;
		_IO_vtable_check(out ecx_474, out edx_475);
		esp_178.u0 = <invalid>;
	}
	struct Eq_18760 * esp_189 = esp_178 - 0x08;
	esp_189->dwFFFFFFFC = ~0x00;
	esp_189->tFFFFFFF8 = edi_108->t0478;
	word32 edx_218;
	(*((word32) ebx_169 + 0x0C))();
	esp_178 = &esp_189->dwFFFFFFFC + 3;
	goto l080537C2;
}

// 08053990: void _IO_file_close_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_file_close_mmap(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_9 = *((word32) dwArg04 + 28);
	struct Eq_18908 * ebx_19;
	word32 ecx_47;
	word32 edx_48;
	__munmap(dwArg04, gs, edx_9, *((word32) dwArg04 + 32) - edx_9, out ecx_47, out edx_48, out ebx_19);
	Eq_2 eax_27 = ebx_19->t0038;
	ebx_19->dw0020 = 0x00;
	ebx_19->dw001C = 0x00;
	word32 edx_49;
	__close_nocancel(gs, eax_27, out edx_49);
}

// 080539D0: Register Eq_2 mmap_remap_check(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_16458) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out Eq_2 ebpOut, Register out (ptr32 Eq_18944) ediOut)
// Called from:
//      _IO_file_xsgetn_mmap
//      _IO_file_underflow_mmap
Eq_2 mmap_remap_check(Eq_2 eax, struct Eq_9 * gs, struct Eq_16458 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, union Eq_2 & ebpOut, struct Eq_18944 & ediOut)
{
	Eq_2 ebp_281 = 0x080CE000;
	Eq_2 ebx_150 = eax;
	Eq_2 esp_20 = fp - 0xAC;
	Eq_2 esi_21 = *((word32) eax + 0x0094);
	ui32 eax_23 = gs->dw0014;
	if (esi_21 >= 135066356)
	{
		word32 edx_470;
		word32 ecx_469;
		_IO_vtable_check(out ecx_469, out edx_470);
		esp_20.u0 = <invalid>;
	}
	struct Eq_18967 * ebx_102;
	struct Eq_18968 * esp_41 = esp_20 - 0x08;
	esp_41->tFFFFFFFC = (char *) &esp_41->t0020 + 20;
	esp_41->tFFFFFFF8 = eax;
	Eq_2 eax_54;
	(*((word32) esi_21 + 72))();
	Eq_2 eax_60 = *((word32) eax + 28);
	Eq_2 edx_62 = *((word32) eax + 32) - eax_60;
	esp_41->t0020 = eax_60;
	esp_41->t0010 = edx_62;
	Eq_2 esi_243 = eax_54;
	if (eax_54 == 0x00 && (esp_41->dw0044 & 0xF000) == 0x8000)
	{
		uint32 eax_72 = esp_41->dw0060;
		esp_41->dw001C = esp_41->dw0064;
		ui32 ecx_76 = eax_72 | esp_41->dw001C;
		esp_41->dw0018 = eax_72;
		if (ecx_76 != 0x00 && (eax_54 - esp_41->dw001C) - (esp_41->dw0018 > 0x000FFFFF) >= 0x00)
		{
			Eq_2 eax_112 = __getpagesize();
			Eq_2 esp_114 = <invalid>;
			((word32) esp_114 + 0x0C)->u0 = 0x00;
			word32 edx_123 = eax_112 + Mem119[esp_114 + 0x10:word32];
			*((word32) esp_114 + 28) = -eax_112;
			Eq_2 edi_128 = *((word32) esp_114 + 28) & edx_123 + ~0x00;
			Eq_2 edx_130 = (word32) *((word32) esp_114 + 8) + (eax_112 - 0x01) & *((word32) esp_114 + 28);
			int32 ecx_134 = eax_54 - *((word32) esp_114 + 0x0C) - (edi_128 < edx_130);
			*((word32) esp_114 + 8) = edx_130;
			if (ecx_134 < 0x00)
			{
				uint32 eax_141 = (word32) *((word32) esp_114 + 16) + (eax_112 - 0x01) & *((word32) esp_114 + 28);
				*((word32) esp_114 - 0x0C) = edx_130 - eax_141;
				*((word32) esp_114 - 16) = (word32) *((word32) esp_114 + 24) + eax_141;
				word32 ecx_473;
				word32 edx_474;
				__munmap(eax, gs, *((word32) esp_114 - 16), *((word32) esp_114 - 0x0C), out ecx_473, out edx_474, out ebx_150);
				Eq_2 eax_158 = *((word32) ebx_150 + 28);
				word32 ecx_160 = Mem148[esp_114 + 0x5C:word32] + eax_158;
				*((word32) esp_114 + 28) = eax_158;
				*((word32) esp_114 + 0x0C) = ecx_160;
				*((word32) ebx_150 + 32) = ecx_160;
				esp_114 = (word32) esp_114 + 4;
				goto l08053B14;
			}
			if (*((word32) esp_114 + 0x0C) - (edx_130 < edi_128) >= 0x00)
			{
				word32 ecx_173 = Mem136[esp_114 + 0x10:word32] + Mem136[esp_114 + 0x18:word32];
				*((word32) esp_114 + 8) = ecx_173;
				*((word32) eax + 32) = ecx_173;
				goto l08053B14;
			}
			((word32) esp_114 - 4)->u0 = 0x01;
			*((word32) esp_114 - 8) = (word32) *((word32) esp_114 + 16) + (eax_112 - 0x01) & *((word32) esp_114 + 28);
			*((word32) esp_114 - 0x0C) = edx_130;
			*((word32) esp_114 - 16) = *((word32) esp_114 + 24);
			word32 edx_475;
			Eq_2 eax_191 = __mremap(gs, *((word32) esp_114 - 16), *((word32) esp_114 - 0x0C), *((word32) esp_114 - 8), *((word32) esp_114 - 4), *esp_114, out edx_475);
			*((word32) esp_114 + 28) = eax_191;
			esp_114 = (word32) esp_114 + 4;
			if (eax_191 != ~0x00)
			{
				Eq_2 eax_246 = *((word32) esp_114 + 28);
				word32 ecx_248 = Mem199[esp_114 + 0x5C:word32] + eax_246;
				*((word32) eax + 28) = eax_246;
				*((word32) esp_114 + 0x0C) = ecx_248;
				*((word32) eax + 32) = ecx_248;
l08053B14:
				ui64 ebp_edi_377 = *((word32) ebx_150 + 76) - (int64) (*((word32) ebx_150 + 8) - *((word32) ebx_150 + 4));
				Eq_2 edi_261 = (word32) ebp_edi_377;
				Eq_2 ecx_264 = *((word32) esp_114 + 24);
				*((word32) ebx_150 + 76) = edi_261;
				Eq_2 ebp_267 = SLICE(ebp_edi_377, word32, 32);
				*((word32) ebx_150 + 80) = ebp_267;
				Eq_2 ebp_272 = *((word32) esp_114 + 8);
				*((word32) ebx_150 + 0x0C) = ecx_264;
				Eq_2 ebp_274 = ebp_272 - ecx_264;
				*((word32) esp_114 + 16) = ebp_274;
				Eq_2 edi_279 = *((word32) esp_114 + 16);
				*((word32) esp_114 + 20) = ebp_274 >> 0x1F;
				ebp_281 = *((word32) esp_114 + 20);
				if (ebp_267 - ebp_281 - (edi_261 < ebp_274) < 0x00)
				{
					Mem292[ebx_150 + 0x04:word32] = edi_261 + Mem280[esp_114 + 0x18:word32];
					Eq_2 eax_293 = *((word32) esp_114 + 8);
					struct Eq_19317 * esp_294 = esp_114 - 4;
					esp_294->t0000.u0 = 0x00;
					*((word32) ebx_150 + 8) = eax_293;
					esp_294->tFFFFFFFC = ebp_281;
					esp_294->tFFFFFFF8 = edi_279;
					esp_294->tFFFFFFF4 = *((word32) ebx_150 + 56);
					struct Eq_19340 * ebx_306;
					word32 edx_309;
					word32 edi_478;
					Eq_2 eax_305 = lseek64(gs, esp_294->tFFFFFFF4, esp_294->tFFFFFFF8, esp_294->tFFFFFFFC, esp_294->t0000, out edx_309, out ebx_306, out esi_243, out edi_478);
					int32 ecx_317 = ebx_306->dw0020 - ebx_306->dw001C;
					ebp_281 = ecx_317 >> 0x1F;
					if ((edx_309 ^ ecx_317 >> 0x1F | eax_305 ^ ecx_317) != 0x00)
						ebx_306->dw0000 |= 0x20;
					else
					{
						ebx_306->dw004C = ecx_317;
						ebx_306->dw0050 = ecx_317 >> 0x1F;
					}
				}
				else
				{
					Eq_2 eax_287 = *((word32) esp_114 + 8);
					*((word32) ebx_150 + 4) = eax_287;
					*((word32) ebx_150 + 8) = eax_287;
				}
				goto l08053BF9;
			}
			Eq_2 edx_203 = *((word32) eax + 28);
			*((word32) esp_114 - 8) = *((word32) eax + 32) - edx_203;
			*((word32) esp_114 - 0x0C) = edx_203;
			word32 ecx_476;
			word32 edx_477;
			__munmap(eax, gs, *((word32) esp_114 - 0x0C), *((word32) esp_114 - 8), out ecx_476, out edx_477, out ebx_102);
l08053BB3:
			ptr32 edx_235;
			int32 eax_225 = ebx_102->dw0068;
			ebx_102->dw0020 = 0x00;
			ebx_102->dw001C = 0x00;
			ebx_102->dw000C = 0x00;
			ebx_102->dw0004 = 0x00;
			ebx_102->dw0008 = 0x00;
			if (eax_225 > 0x00)
				edx_235 = 0x080CF060;
			else
				edx_235 = 0x080CF180;
			ebx_102->ptr0094 = edx_235;
			ebx_102->ptr0058->ptr00B0 = 0x080CF060;
			esi_243.u0 = 0x01;
l08053BF9:
			if ((eax_23 ^ gs->dw0014) != 0x00)
			{
				word32 ecx_479;
				word32 edx_480;
				__stack_chk_fail(out ecx_479, out edx_480);
				ptr32 ebx_356;
				struct Eq_18944 * edi_358;
				Eq_2 eax_355 = _IO_file_seek(gs, dwArg04, dwArg08, dwArg0C, dwArg10, out ebx_356, out edi_358);
				ebxOut = ebx_356;
				ebpOut = ebp_281;
				ediOut = edi_358;
				return eax_355;
			}
			else
			{
				ebxOut = ebx;
				ebpOut = ebp;
				ediOut = edi;
				return esi_243;
			}
		}
	}
	esp_41->tFFFFFFFC = esp_41->t0010;
	esp_41->tFFFFFFF8 = esp_41->t0020;
	word32 edx_472;
	word32 ecx_471;
	__munmap(eax, gs, esp_41->tFFFFFFF8, esp_41->tFFFFFFFC, out ecx_471, out edx_472, out ebx_102);
	goto l08053BB3;
}

// 08053CD0: Register Eq_2 _IO_file_seek(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_16458) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out ptr32 ediOut)
// Called from:
//      mmap_remap_check
Eq_2 _IO_file_seek(struct Eq_9 * gs, struct Eq_16458 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, ptr32 & ediOut)
{
	Eq_2 eax_6 = dwArg04->t0038;
	ptr32 ebx_10;
	ptr32 edi_12;
	word32 edx_27;
	word32 esi_28;
	Eq_2 eax_9 = lseek64(gs, eax_6, dwArg08, dwArg0C, dwArg10, out edx_27, out ebx_10, out esi_28, out edi_12);
	ebxOut = ebx_10;
	ediOut = edi_12;
	return eax_9;
}

// 08053CF0: void _IO_file_sync_mmap(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_19543) dwArg04)
void _IO_file_sync_mmap(struct Eq_9 * gs, struct Eq_19543 * dwArg04)
{
	Eq_2 ecx_14 = dwArg04->t0004;
	int64 edx_eax_17 = (int64) (ecx_14 - dwArg04->t001C);
	struct Eq_19543 * ebx_13 = dwArg04;
	Eq_2 edx_23 = SLICE(edx_eax_17, word32, 32);
	Eq_2 eax_26 = (word32) edx_eax_17;
	if (ecx_14 != dwArg04->t0008)
	{
		word32 esi_110;
		word32 edi_111;
		eax_26 = lseek64(gs, dwArg04->t0038, eax_26, edx_23, 0x00, out edx_23, out ebx_13, out esi_110, out edi_111);
		int32 ecx_44 = ebx_13->t0004 - ebx_13->t001C;
		if ((ecx_44 >> 0x1F ^ edx_23 | ecx_44 ^ eax_26) != 0x00)
		{
			ebx_13->dw0000 |= 0x20;
			return;
		}
	}
	ebx_13->t004C = eax_26;
	Eq_2 eax_63 = ebx_13->t000C;
	ebx_13->t0050 = edx_23;
	ebx_13->t0004 = eax_63;
	ebx_13->t0008 = eax_63;
}

// 08053D60: Register Eq_2 decide_maybe_mmap(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_file_underflow_maybe_mmap
//      _IO_file_xsgetn_maybe_mmap
Eq_2 decide_maybe_mmap(Eq_2 eax, struct Eq_9 * gs)
{
	ptr32 esi_11 = 0x080CE000;
	Eq_2 ebx_129 = eax;
	Eq_2 esp_17 = fp + ~0x8B;
	Eq_2 edi_18 = *((word32) eax + 0x0094);
	ui32 eax_20 = gs->dw0014;
	if (edi_18 >= 135066356)
	{
		word32 ecx_314;
		word32 edx_315;
		_IO_vtable_check(out ecx_314, out edx_315);
		esp_17.u0 = <invalid>;
	}
	Eq_2 eax_192;
	Eq_2 edx_191;
	struct Eq_19641 * esp_38 = esp_17 - 0x08;
	esp_38->tFFFFFFFC = (char *) &esp_38->t0004 + 32;
	esp_38->tFFFFFFF8 = eax;
	int32 eax_50;
	(*((word32) edi_18 + 72))();
	if (eax_50 == 0x00 && (esp_38->dw0034 & 0xF000) == 0x8000)
	{
		Eq_2 edx_62 = esp_38->t0050;
		Eq_2 ecx_63 = esp_38->t0054;
		if ((edx_62 | ecx_63) != 0x00 && (eax_50 - ecx_63) - (edx_62 > 0x000FFFFF) >= 0x00)
		{
			Eq_2 eax_75 = *((word32) eax + 76);
			Eq_2 edi_76 = *((word32) eax + 80);
			if (ecx_63 - edi_76 - (edx_62 < eax_75) >= 0x00 || (eax_75 & edi_76) == ~0x00)
			{
				esp_38->t0000.u0 = 0x00;
				esp_38->tFFFFFFFC.u0 = 0x00;
				esp_38->tFFFFFFF8 = *((word32) eax + 56);
				esp_38->tFFFFFFF4.u0 = 0x01;
				esp_38->tFFFFFFF0.u0 = 0x01;
				esp_38->tFFFFFFEC = edx_62;
				esp_38->tFFFFFFE8.u0 = 0x00;
				if (mmap64(gs, esp_38->tFFFFFFE8, esp_38->tFFFFFFEC, esp_38->tFFFFFFF0, esp_38->tFFFFFFF4, esp_38->tFFFFFFF8, esp_38->tFFFFFFFC, esp_38->t0000) != ~0x00)
				{
					esp_38->t0004.u0 = 0x00;
					esp_38->t0000 = esp_38->t0054;
					esp_38->tFFFFFFFC = esp_38->t0050;
					esp_38->tFFFFFFF8 = *((word32) eax + 56);
					Eq_2 edi_131;
					word32 edx_132;
					Eq_2 eax_128 = lseek64(gs, esp_38->tFFFFFFF8, esp_38->tFFFFFFFC, esp_38->t0000, esp_38->t0004, out edx_132, out ebx_129, out esi_11, out edi_131);
					Eq_2 esp_134 = <invalid>;
					Eq_2 ecx_139 = *((word32) esp_134 + 88);
					Eq_2 eax_143 = eax_128 ^ ecx_139 | edx_132 ^ *((word32) esp_134 + 92);
					if (eax_143 == 0x00)
					{
						*((word32) esp_134 + 28) = eax_143;
						((word32) esp_134 + 0x0C)->u0 = 0x00;
						Mem153[esp_134 + 0x08:word32] = ecx_139 + edi_131;
						*((word32) esp_134 + 4) = edi_131;
						*esp_134 = ebx_129;
						_IO_setb(*esp_134, *((word32) esp_134 + 4), *((word32) esp_134 + 8), *((word32) esp_134 + 0x0C));
						Eq_2 edx_166 = *((word32) ebx_129 + 76);
						Eq_2 ecx_167 = *((word32) ebx_129 + 80);
						Eq_2 eax_169 = *((word32) esp_134 + 28);
						*((word32) ebx_129 + 0x0C) = edi_131;
						if ((ecx_167 & edx_166) == ~0x00)
							edx_166 = eax_169;
						Mem179[ebx_129 + 0x04:word32] = edx_166 + edi_131;
						Eq_2 edx_181 = *((word32) esp_134 + 88);
						*((word32) ebx_129 + 76) = edx_181;
						Eq_2 edx_184 = *((word32) ebx_129 + 0x0068);
						Mem185[ebx_129 + 0x08:word32] = edi_131 + edx_181;
						*((word32) ebx_129 + 80) = *((word32) esp_134 + 92);
						if (edx_184 > 0x00)
						{
							eax_192 = esi_11 + 0x1000;
							edx_191 = esi_11 + 0x1000;
						}
						else
						{
							edx_191 = esi_11 + 0x1120;
							eax_192 = esi_11 + 0x1000;
						}
l08053DD3:
						*((word32) ebx_129 + 0x0094) = edx_191;
						*((word32) *((word32) ebx_129 + 88) + 0x00B0) = eax_192;
						if ((eax_20 ^ gs->dw0014) == 0x00)
							return ebx;
						word32 ecx_316;
						word32 edx_317;
						__stack_chk_fail(out ecx_316, out edx_317);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						_IO_file_underflow_maybe_mmap(stackArg4);
						return ebx_129;
					}
					*((word32) esp_134 + 4) = ecx_139;
					*esp_134 = edi_131;
					word32 ecx_319;
					word32 edx_320;
					__munmap(ebx_129, gs, *esp_134, *((word32) esp_134 + 4), out ecx_319, out edx_320, out ebx_129);
					((word32) ebx_129 + 76)->u0 = ~0x00;
					((word32) ebx_129 + 80)->u0 = ~0x00;
				}
			}
		}
	}
	if (*((word32) ebx_129 + 0x0068) > 0x00)
	{
		eax_192 = esi_11 + 0x1060;
		edx_191 = eax_192;
	}
	else
	{
		edx_191 = esi_11 + 0x1180;
		eax_192 = esi_11 + 0x1060;
	}
	goto l08053DD3;
}

// 08053F30: Register word32 _IO_file_underflow_maybe_mmap(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow_maybe_mmap
//      decide_maybe_mmap
word32 _IO_file_underflow_maybe_mmap(Eq_2 dwArg04)
{
	decide_maybe_mmap(dwArg04, gs);
	Eq_2 esi_22 = *((word32) dwArg04 + 0x0094);
	if (esi_22 >= 135066356)
	{
		word32 edx_68;
		word32 ecx_67;
		_IO_vtable_check(out ecx_67, out edx_68);
	}
	word32 eax_49;
	(*((word32) esi_22 + 16))();
	return eax_49;
}

// 08053F80: void _IO_file_xsgetn_maybe_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void _IO_file_xsgetn_maybe_mmap(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_19992 * ebp_37 = decide_maybe_mmap(dwArg04, gs)->ptr0094;
	if (ebp_37 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_100;
		word32 ecx_99;
		_IO_vtable_check(out ecx_99, out edx_100);
	}
	ebp_37->ptr0020();
}

// 08053FF0: void _IO_new_file_seekoff(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10, Stack Eq_2 dwArg14)
void _IO_new_file_seekoff(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10, Eq_2 dwArg14)
{
	int64 ebp_edi_1602;
	uint32 ebx_130;
	int32 ecx_129;
	Eq_2 edx_690;
	int64 edx_eax_1607;
	int64 edx_eax_1613;
	int64 edx_eax_1617;
	Eq_2 esp_103 = fp - 188;
	Eq_2 ebp_138 = dwArg14;
	Eq_2 esi_170 = dwArg04;
	ui32 eax_27 = gs->dw0014;
	if (dwArg14 == 0x00)
	{
		if (*((word32) dwArg04 + 28) == 0x00)
		{
			Eq_2 edx_38 = *((word32) dwArg04 + 80);
			Eq_2 eax_37 = *((word32) dwArg04 + 76);
			ecx_129 = ~edx_38;
			ebx_130 = ~eax_37;
			ebp_edi_1602 = 0x00;
			edx_eax_1607 = SEQ(edx_38, eax_37);
			goto l08054582;
		}
		Eq_2 ecx_47 = *dwArg04;
		ebp_138 = *((word32) dwArg04 + 20);
		Eq_2 ebx_49 = *((word32) dwArg04 + 16);
		if (ebp_138 > ebx_49 && (ecx_47 & 0x1000) != 0x00)
		{
			Eq_2 ebx_93 = *((word32) dwArg04 + 0x0094);
			if (ebx_93 >= 135066356)
			{
				word32 ecx_1623;
				word32 edx_1624;
				_IO_vtable_check(out ecx_1623, out edx_1624);
				esp_103.u0 = <invalid>;
			}
			struct Eq_20298 * esp_109 = esp_103 - 4;
			esp_109->dw0000 = 0x02;
			esp_109->dwFFFFFFFC = 0x00;
			esp_109->dwFFFFFFF8 = 0x00;
			esp_109->tFFFFFFF4 = dwArg04;
			int64 edx_eax_1616;
			(*((word32) ebx_93 + 64))();
			Eq_2 edx_124 = SLICE(edx_eax_1616, word32, 32);
			Eq_2 eax_123 = (word32) edx_eax_1616;
			ecx_129 = ~edx_124;
			ebx_130 = ~eax_123;
			esp_103 = &esp_109->dw0000 + 1;
			if ((ecx_129 | ebx_130) == 0x00)
				goto l080545A3;
			*((word32) dwArg04 + 76) = eax_123;
			ebp_138 = *((word32) dwArg04 + 20);
			*((word32) dwArg04 + 80) = edx_124;
			edx_eax_1613 = edx_eax_1616;
l08054531:
			Eq_20427 ebp_831 = ebp_138 - *((word32) esi_170 + 16);
			ebp_edi_1602 = SEQ(ebp_831 >> 0x1F, ebp_831);
			edx_eax_1607 = edx_eax_1613;
			goto l08054582;
		}
		Eq_2 eax_58 = *((word32) dwArg04 + 76);
		Eq_2 edx_59 = *((word32) dwArg04 + 80);
		if (ebp_138 <= ebx_49)
		{
			int32 ecx_77 = *((word32) dwArg04 + 8) - *((word32) dwArg04 + 4);
			uint32 edi_82 = -ecx_77;
			ecx_129 = ~edx_59;
			ebx_130 = ~eax_58;
			ebp_edi_1602 = SEQ(-((ecx_77 >> 0x1F) + (edi_82 == 0x00)), edi_82);
			edx_eax_1607 = SEQ(edx_59, eax_58);
			goto l08054582;
		}
		edx_eax_1617 = SEQ(edx_59, eax_58);
		if ((ecx_47 & 0x1000) == 0x00)
		{
			Eq_20439 ebp_68 = ebp_138 - *((word32) dwArg04 + 8);
			ecx_129 = ~edx_59;
			ebx_130 = ~eax_58;
			ebp_edi_1602 = SEQ(ebp_68 >> 0x1F, ebp_68);
			edx_eax_1607 = SEQ(edx_59, eax_58);
l08054582:
			ebp_138 = SLICE(ebp_edi_1602, word32, 32);
			int64 edx_eax_1599 = edx_eax_1607;
			if ((ecx_129 | ebx_130) != 0x00)
			{
l08054586:
				edx_690 = SLICE(edx_eax_1599 + ebp_edi_1602, word32, 32);
				if (edx_690 < 0x00)
					goto l08054592;
				goto l08054347;
			}
			Eq_2 ebx_850 = *((word32) esi_170 + 0x0094);
			if (ebx_850 >= 135066356)
			{
				word32 edx_1628;
				word32 ecx_1627;
				_IO_vtable_check(out ecx_1627, out edx_1628);
				esp_103.u0 = <invalid>;
			}
			struct Eq_20376 * esp_866 = esp_103 - 4;
			esp_866->dw0000 = 0x01;
			esp_866->dwFFFFFFFC = 0x00;
			esp_866->dwFFFFFFF8 = 0x00;
			esp_866->tFFFFFFF4 = esi_170;
			int64 edx_eax_1612;
			(*((word32) ebx_850 + 64))();
			edx_eax_1599 = edx_eax_1612;
			if (((word32) edx_eax_1612 & SLICE(edx_eax_1612, word32, 32)) != ~0x00)
				goto l08054586;
l080545A3:
			edx_690.u0 = ~0x00;
			goto l08054347;
		}
l0805472B:
		ecx_129 = ~SLICE(edx_eax_1617, word32, 32);
		ebx_130 = ~(word32) edx_eax_1617;
		edx_eax_1613 = edx_eax_1617;
		goto l08054531;
	}
	Eq_2 esp_236;
	Eq_2 edx_140 = *((word32) dwArg04 + 16);
	Eq_2 eax_141 = *((word32) dwArg04 + 20);
	if ((*((word32) dwArg04 + 0x0C) != *((word32) dwArg04 + 8) || edx_140 != eax_141) && edx_140 < eax_141 || (*dwArg04 & 0x0800) != 0x00)
	{
		esi_170 = dwArg04;
		word32 ecx_1620;
		if (_IO_switch_to_get_mode(dwArg04, out ecx_1620) != 0x00)
			goto l080545A3;
		if (*((word32) dwArg04 + 28) != 0x00)
		{
l08054088:
			esi_170 = dwArg04;
			esp_236 = fp - 188;
			if (dwArg10 != 0x01)
				goto l08054096;
			goto l08054193;
		}
	}
	else if (*((word32) dwArg04 + 28) != 0x00)
		goto l08054088;
	ptr32 esp_194 = fp - 188;
	Eq_2 eax_190 = *((word32) dwArg04 + 0x0C);
	if (eax_190 != 0x00)
	{
		word32 edx_1639;
		word32 ecx_1638;
		free(gs, dwLocD0, eax_190, out ecx_1638, out edx_1639);
		*dwArg04 &= ~0x0100;
		esp_194 = fp - 0xB8;
	}
	struct Eq_20913 * esp_218 = esp_194 - 0x0C;
	esp_218->tFFFFFFFC = dwArg04;
	word32 edi_1637;
	_IO_doallocbuf(esp_218->tFFFFFFFC, out ebp_138, out esi_170, out edi_1637);
	Eq_2 eax_235 = *((word32) esi_170 + 28);
	*((word32) esi_170 + 20) = eax_235;
	*((word32) esi_170 + 16) = eax_235;
	*((word32) esi_170 + 24) = eax_235;
	*((word32) esi_170 + 0x0C) = eax_235;
	*((word32) esi_170 + 4) = eax_235;
	*((word32) esi_170 + 8) = eax_235;
	esp_236 = (char *) &esp_218->tFFFFFFFC + 16;
	if (esp_218->dw00D8 != 0x01)
	{
l08054096:
		if (*((word32) esp_236 + 0x00CC) != 0x02)
			goto l080541D4;
		Eq_2 ebx_293 = *((word32) esi_170 + 0x0094);
		((word32) esp_236 + 36)->u0 = 0x080CEFA0;
		((word32) esp_236 + 32)->u0 = 0x0354;
		if (ebx_293 >= 135066356)
		{
			word32 edx_1622;
			word32 ecx_1621;
			_IO_vtable_check(out ecx_1621, out edx_1622);
			esp_236.u0 = <invalid>;
		}
		struct Eq_20177 * esp_313 = esp_236 - 0x08;
		esp_313->ptrFFFFFFFC = &esp_313->dw0014 + 0x0C;
		esp_313->tFFFFFFF8 = esi_170;
		word32 eax_338;
		(*((word32) ebx_293 + 72))();
		esp_236 = &esp_313->ptrFFFFFFFC + 3;
		if (eax_338 != 0x00 || (esp_313->dw0054 & 0xF000) != 0x8000)
			goto l080542E8;
		ui64 v16_v15_957 = (word32) esp_313->t0010 + esp_313->qw0070;
		esp_313->t0010 = (word32) v16_v15_957;
		esp_313->dw0014 = SLICE(v16_v15_957, word32, 32);
l080541C9:
		*((word32) esp_236 + 0x00CC) = 0x00;
l080541D4:
		struct Eq_20124 * esp_362 = esp_236 - 0x0C;
		esp_362->tFFFFFFFC = esi_170;
		_IO_free_backup_area(esp_362->tFFFFFFFC);
		Eq_2 ecx_375 = *((word32) esi_170 + 76);
		Eq_2 ebx_376 = *((word32) esi_170 + 80);
		Eq_2 eax_381 = *esi_170;
		esp_362->t0024 = eax_381;
		esp_236 = (char *) &esp_362->tFFFFFFFC + 16;
		byte ah_388 = SLICE(eax_381, byte, 8);
		if ((ecx_375 & ebx_376) != ~0x00 && (*((word32) esi_170 + 0x0C) != 0x00 && (ah_388 & 0x01) == 0x00))
		{
			Eq_2 edx_392 = *((word32) esi_170 + 28);
			eax_394 = *((word32) esi_170 + 8) - edx_392;
			esp_362->t002C = edx_392;
			int64 edx_eax_962 = SEQ(ebx_376, ecx_375) - SEQ(eax_394 >> 0x1F, eax_394);
			Eq_2 edx_404 = SLICE(edx_eax_962, word32, 32);
			Eq_2 eax_401 = (word32) edx_eax_962;
			ebp_138 = edx_404;
			if (esp_362->t0018 - edx_404 - (esp_362->t0014 < eax_401) >= 0x00 && (esp_362->t0018 - ebx_376) - (esp_362->t0014 < ecx_375) < 0x00)
			{
				Eq_2 edx_741 = esp_362->t002C;
				ui32 eax_742 = esp_362->t0014 - eax_401;
				*((word32) esi_170 + 0x0C) = edx_741;
				*((word32) esi_170 + 20) = edx_741;
				*((word32) esi_170 + 4) = (word32) edx_741 + eax_742;
				Eq_2 eax_747 = esp_362->t0024;
				*((word32) esi_170 + 16) = edx_741;
				*((word32) esi_170 + 24) = edx_741;
				*esi_170 = eax_747 & ~0x10;
				if (ebx_376 >= 0x00)
				{
					Eq_2 edi_760 = *((word32) esi_170 + 0x0094);
					ebp_138 = edi_760;
					if (edi_760 >= 135066356)
					{
						word32 edx_1632;
						word32 ecx_1631;
						_IO_vtable_check(out ecx_1631, out edx_1632);
						esp_236.u0 = <invalid>;
						ecx_375 = *((word32) esi_170 + 76);
						ebx_376 = *((word32) esi_170 + 80);
					}
					struct Eq_20648 * esp_778 = esp_236 - 4;
					esp_778->dw0000 = 0x00;
					esp_778->tFFFFFFFC = ebx_376;
					esp_778->tFFFFFFF8 = ecx_375;
					esp_778->tFFFFFFF4 = esi_170;
					(*((word32) edi_760 + 64))();
					edx_690 = esp_778->t0010;
					goto l08054347;
				}
				goto l080544B1;
			}
		}
		esp_362->dw0030 = 0x080CEFA0;
		esp_362->t002C.u0 = 0x0354;
		if ((esp_362->t0024 & 0x04) == 0x00)
		{
			ui32 ecx_436 = *((word32) esi_170 + 28) - *((word32) esi_170 + 32);
			Eq_2 edi_438 = esp_362->t0014;
			Eq_2 ebp_439 = esp_362->t0018;
			esp_362->t0024 = ecx_436 & edi_438;
			Eq_2 ecx_447 = *((word32) esi_170 + 32);
			esp_362->t0028 = SLICE((int64) ecx_436, word32, 32) & ebp_439;
			int64 edx_eax_964 = SEQ(ebp_439, edi_438) - esp_362->t0024;
			up32 ecx_454 = ecx_447 - *((word32) esi_170 + 28);
			esp_362->dw001C = (word32) edx_eax_964;
			Eq_2 edx_453 = SLICE(edx_eax_964, word32, 32);
			esp_362->t0020 = edx_453;
			ebp_138 = edx_453;
			if (SLICE((int64) ecx_454, word32, 32) - esp_362->t0020 - (ecx_454 < esp_362->dw001C) < 0x00)
			{
				Eq_2 edi_468 = esp_362->t0014;
				ebp_138 = esp_362->t0018;
				esp_362->dw001C = 0x00;
				esp_362->t0020.u0 = 0x00;
				esp_362->t0024 = edi_468;
				esp_362->t0028 = ebp_138;
			}
			Eq_2 edx_476 = *((word32) esi_170 + 0x0094);
			if (edx_476 - 0x080CEFA0 >= esp_362->t002C)
			{
				esp_362->t0038 = edx_476;
				word32 edx_1634;
				word32 ecx_1633;
				_IO_vtable_check(out ecx_1633, out edx_1634);
				esp_236.u0 = <invalid>;
				edx_476 = *((word64) esp_236.u0 + 44);
			}
			struct Eq_20776 * esp_493 = esp_236 - 4;
			esp_493->dw0000 = 0x00;
			esp_493->dwFFFFFFFC = esp_493->dw0020;
			esp_493->dwFFFFFFF8 = esp_493->dw001C;
			esp_493->tFFFFFFF4 = esi_170;
			word32 eax_522;
			int32 edx_523;
			(*((word32) edx_476 + 64))();
			esp_493->dw001C = eax_522;
			esp_493->dw0020 = edx_523;
			esp_236 = &esp_493->dw0000 + 1;
			if (edx_523 < 0x00)
				goto l080545A3;
			Eq_20813 eax_539;
			if ((esp_493->dw0018 | esp_493->dw0014) == 0x00)
			{
				eax_539.u0 = 0x00;
				goto l08054483;
			}
			Eq_2 edx_542 = *((word32) esi_170 + 0x0094);
			if (edx_542 - 0x080CEFA0 >= esp_493->dw0024)
			{
				esp_493->t0030 = edx_542;
				word32 ecx_1635;
				word32 edx_1636;
				_IO_vtable_check(out ecx_1635, out edx_1636);
				esp_236.u0 = <invalid>;
				edx_542 = *((word64) esp_236.u0 + 44);
			}
			Eq_2 eax_566;
			Eq_2 ecx_560 = *((word32) edx_542 + 56);
			Eq_2 edx_562 = *((word32) esi_170 + 28);
			if (*((word64) esp_236.u0 + 40) == 0x00)
				eax_566 = *((word32) esi_170 + 32) - edx_562;
			else
				eax_566 = *((word64) esp_236.u0 + 16);
			struct Eq_20870 * esp_571 = esp_236 - 0x04;
			esp_571->tFFFFFFFC = eax_566;
			esp_571->tFFFFFFF8 = edx_562;
			esp_571->tFFFFFFF4 = esi_170;
			ecx_560();
			ebp_138 = esp_571->t0018;
			esp_236 = (char *) &esp_571->tFFFFFFFC + 8;
			if ((eax_539 >> 0x1F) - ebp_138 - (eax_539 < esp_571->t0014) >= 0x00)
			{
				ui64 v29_v28_965 = (word32) esp_571->t001C + SEQ(eax_539 >> 0x1F, eax_539);
				esp_571->t001C = (word32) v29_v28_965;
				esp_571->dw0020 = SLICE(v29_v28_965, word32, 32);
l08054483:
				Eq_2 edx_720 = *((word32) esi_170 + 28);
				Eq_2 ecx_722 = *((word32) esp_236 + 16);
				*esi_170 &= ~0x10;
				*((word32) esi_170 + 0x0C) = edx_720;
				Mem731[esi_170 + 0x08:word32] = eax_539 + edx_720;
				Eq_2 eax_732 = *((word32) esp_236 + 24);
				*((word32) esi_170 + 20) = edx_720;
				*((word32) esi_170 + 16) = edx_720;
				*((word32) esi_170 + 24) = edx_720;
				Eq_2 edx_736 = *((word32) esp_236 + 28);
				Mem737[esi_170 + 0x04:word32] = ecx_722 + edx_720;
				*((word32) esi_170 + 76) = eax_732;
				*((word32) esi_170 + 80) = edx_736;
l080544B1:
				edx_690 = *((word32) esp_236 + 0x0C);
				goto l08054347;
			}
			if (eax_539 == ~0x00)
			{
				Eq_20813 eax_620 = esp_571->t0014;
				Eq_2 edx_621 = esp_571->t0018;
				esp_571->dw00D0 = 0x01;
				esp_571->t000C = eax_620;
				esp_571->t0010 = edx_621;
			}
			else
			{
				Eq_20813 edi_610 = esp_571->t0014;
				Eq_2 ebp_611 = esp_571->t0018;
				esp_571->dw00D0 = 0x01;
				ui64 ebp_edi_969 = SEQ(ebp_611, edi_610) - SEQ(eax_539 >> 0x1F, eax_539);
				esp_571->t000C = (word32) ebp_edi_969;
				ebp_138 = SLICE(ebp_edi_969, word32, 32);
				esp_571->t0010 = ebp_138;
			}
		}
l080542E8:
		struct Eq_20196 * esp_627 = esp_236 - 0x0C;
		esp_627->tFFFFFFFC = esi_170;
		_IO_unsave_markers(esp_627->tFFFFFFFC);
		Eq_2 ebx_640 = *((word32) esi_170 + 0x0094);
		Eq_2 esp_643 = (char *) &esp_627->tFFFFFFFC + 20;
		if (esp_627->dw0030 <= ebx_640 - esp_627->dw0034)
		{
			word32 edx_1630;
			word32 ecx_1629;
			_IO_vtable_check(out ecx_1629, out edx_1630);
			esp_643.u0 = <invalid>;
		}
		struct Eq_20456 * esp_656 = esp_643 - 4;
		esp_656->dw0000 = (word32) *((word64) esp_643.u0 + 0x00CC);
		esp_656->dwFFFFFFFC = esp_656->dw0010;
		esp_656->dwFFFFFFF8 = esp_656->dw000C;
		esp_656->tFFFFFFF4 = esi_170;
		Eq_2 eax_689;
		(*((word32) ebx_640 + 64))();
		if ((eax_689 & edx_690) != ~0x00)
		{
			Eq_2 ecx_698 = *((word32) esi_170 + 28);
			*esi_170 &= ~0x10;
			*((word32) esi_170 + 76) = eax_689;
			*((word32) esi_170 + 80) = edx_690;
			*((word32) esi_170 + 0x0C) = ecx_698;
			*((word32) esi_170 + 4) = ecx_698;
			*((word32) esi_170 + 8) = ecx_698;
			*((word32) esi_170 + 20) = ecx_698;
			*((word32) esi_170 + 16) = ecx_698;
			*((word32) esi_170 + 24) = ecx_698;
		}
l08054347:
		if ((eax_27 ^ gs->dw0014) == 0x00)
			return;
		esp_103.u0 = <invalid>;
		word32 ecx_1625;
		word32 edx_1626;
		edx_eax_1617 = SEQ(edx_690, __stack_chk_fail(out ecx_1625, out edx_1626));
		goto l0805472B;
	}
l08054193:
	ui64 v32_v31_955 = *((word32) esp_236 + 8) - (int64) (*((word32) esi_170 + 8) - *((word32) esi_170 + 4));
	*((word32) esp_236 + 8) = (word32) v32_v31_955;
	Eq_2 eax_260 = *((word32) esi_170 + 76);
	*((word32) esp_236 + 0x0C) = SLICE(v32_v31_955, word32, 32);
	Eq_2 edx_265 = *((word32) esi_170 + 80);
	if ((eax_260 & edx_265) == ~0x00)
	{
		((word64) esp_236.u0 + 36)->u0 = 0x080CEFA0;
		((word64) esp_236.u0 + 32)->u0 = 0x0354;
		goto l080542E8;
	}
	ui64 v34_v33_967 = (word32) *((word64) esp_236.u0 + 8) + SEQ(edx_265, eax_260);
	*((word64) esp_236.u0 + 8) = (word32) v34_v33_967;
	*((word64) esp_236.u0 + 0x0C) = SLICE(v34_v33_967, word32, 32);
	if (*((word64) esp_236.u0 + 0x0C) < 0x00)
	{
l08054592:
		gs->tFFFFFFE0.u0 = 22;
		goto l080545A3;
	}
	goto l080541C9;
}

// 08054740: void _IO_file_stat(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_21098) dwArg04, Stack Eq_2 dwArg08)
void _IO_file_stat(struct Eq_9 * gs, struct Eq_21098 * dwArg04, Eq_2 dwArg08)
{
	word32 ecx_35;
	word32 edx_36;
	__fxstat64(gs, dwArg04->t0038, dwArg08, out ecx_35, out edx_36);
}

// 08054760: void _IO_new_file_write(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_21110) dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C)
void _IO_new_file_write(struct Eq_9 * gs, struct Eq_21110 * dwArg04, ptr32 dwArg08, int32 dwArg0C)
{
	Eq_21113 eax_108;
	ptr32 esi_19 = dwArg08;
	if (dwArg0C > 0x00)
	{
		int32 ebx_25 = dwArg0C;
		do
		{
			int32 eax_44;
			Eq_2 eax_28 = dwArg04->t0038;
			if ((dwArg04->b003C & 0x02) != 0x00)
			{
				eax_44 = __write_nocancel(gs, eax_28, esi_19, ebx_25);
				if (eax_44 < 0x00)
					goto l080547B8;
			}
			else
			{
				eax_44 = __libc_write(gs, eax_28, esi_19, ebx_25, out ebx_25, out esi_19);
				if (eax_44 < 0x00)
				{
l080547B8:
					dwArg04->dw0000 |= 0x20;
					eax_108 = dwArg0C - ebx_25;
					goto l080547C0;
				}
			}
			ebx_25 -= eax_44;
			esi_19 += eax_44;
		} while (ebx_25 > 0x00);
		eax_108 = dwArg0C - ebx_25;
	}
	else
		eax_108.u0 = 0x00;
l080547C0:
	int32 ebx_103 = dwArg04->dw0050;
	uint32 ecx_104 = dwArg04->dw004C;
	if (ebx_103 >= 0x00)
	{
		int64 ebx_ecx_137 = SEQ(ebx_103, ecx_104) + SEQ(eax_108 >> 0x1F, eax_108);
		dwArg04->dw004C = (word32) ebx_ecx_137;
		dwArg04->dw0050 = SLICE(ebx_ecx_137, word32, 32);
	}
}

// 08054800: void _IO_file_xsgetn_mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_xsgetn_mmap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 edx_130 = *((word32) dwArg04 + 4);
	Eq_2 edi_182 = dwArg04;
	Eq_2 ebp_144 = dwArg0C;
	Eq_2 ecx_165 = dwArg08;
	Eq_2 esi_132 = *((word32) dwArg04 + 8) - edx_130;
	if (esi_132 >= dwArg0C)
	{
l08054858:
		if (esi_132 == 0x00)
			return;
		goto l0805489F;
	}
	if ((*dwArg04 & 0x0100) != 0x00)
	{
		word32 edx_288;
		Eq_2 eax_40 = __mempcpy(dwArg08, edx_130, esi_132, out edx_288);
		_IO_switch_to_main_get_area(dwArg04);
		edx_130 = *((word32) dwArg04 + 4);
		ebp_144 = dwArg0C - esi_132;
		ecx_165 = eax_40;
		esi_132 = *((word32) dwArg04 + 8) - edx_130;
		if (ebp_144 <= esi_132)
			goto l0805489F;
	}
	Eq_2 esp_105 = fp - 44;
	word32 ebx_289;
	if (mmap_remap_check(dwArg04, gs, dwLoc2C, dwLoc28, dwLoc24, ecx_165, out ebx_289, out ebp_144, out edi_182) != 0x00)
	{
		Eq_2 eax_104 = *((word32) edi_182 + 0x0094);
		if (eax_104 >= 135066356)
		{
			word32 ecx_291;
			word32 edx_292;
			_IO_vtable_check(out ecx_291, out edx_292);
			esp_105.u0 = <invalid>;
			eax_104 = *((word64) esp_105.u0 + 0x0C);
		}
		struct Eq_21284 * esp_106 = esp_105 - 0x04;
		esp_106->tFFFFFFFC = ebp_144;
		esp_106->dwFFFFFFF8 = esp_106->dw0038;
		esp_106->tFFFFFFF4 = edi_182;
		(*((word32) eax_104 + 32))();
		return;
	}
	edx_130 = *((word32) edi_182 + 4);
	esi_132 = *((word32) edi_182 + 8) - edx_130;
	if (esi_132 < ebp_144)
	{
		*edi_182 |= 0x10;
		goto l08054858;
	}
l0805489F:
	if (esi_132 > ebp_144)
		esi_132 = ebp_144;
	word32 edx_290;
	__mempcpy(ecx_165, edx_130, esi_132, out edx_290);
	Mem184[edi_182 + 0x04:word32] = esi_132 + edx_130;
}

// 08054910: void _IO_file_xsgetn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _IO_file_xsgetn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	struct Eq_21305 * esp_18 = fp - 44;
	Eq_2 esi_19 = dwArg04;
	Eq_2 ebp_108 = dwArg08;
	if (*((word32) dwArg04 + 28) == 0x00)
	{
		Eq_2 eax_26 = *((word32) dwArg04 + 36);
		if (eax_26 != 0x00)
		{
			word32 edx_590;
			word32 ecx_589;
			free(gs, dwLoc40, eax_26, out ecx_589, out edx_590);
			*dwArg04 &= ~0x0100;
			esp_18 = fp - 0x28;
		}
		struct Eq_21392 * esp_50 = esp_18 - 0x0C;
		esp_50->tFFFFFFFC = dwArg04;
		word32 edi_588;
		_IO_doallocbuf(esp_50->tFFFFFFFC, out ebp_108, out esi_19, out edi_588);
		esp_18 = (struct Eq_21305 *) ((char *) &esp_50->tFFFFFFFC + 16);
	}
	if (esp_18->t0038 != 0x00)
	{
		Eq_2 eax_105 = *((word32) esi_19 + 4);
		Eq_2 edi_124 = esp_18->t0038;
		Eq_2 edx_320 = *((word32) esi_19 + 8) - eax_105;
		if (esp_18->t0038 > edx_320)
		{
			esp_18->dw0000 = 0x080CEFA0;
			esp_18->dw0008 = 135066356 - esp_18->dw0000;
			do
			{
				if (edx_320 != 0x00)
				{
					word32 edx_591;
					Eq_2 eax_111 = __mempcpy(ebp_108, eax_105, edx_320, out edx_591);
					Mem122[esi_19 + 0x04:word32] = Mem109[esi_19 + 0x04:word32] + edx_320;
					ebp_108 = eax_111;
					edi_124 -= edx_320;
					if ((*esi_19 & 0x0100) != 0x00)
						goto l08054A61;
					goto l0805498C;
				}
				if ((*esi_19 & 0x0100) == 0x00)
				{
l0805498C:
					Eq_2 eax_131 = *((word32) esi_19 + 28);
					if (eax_131 != 0x00)
					{
						Eq_2 ecx_142 = *((word32) esi_19 + 32) - eax_131;
						if (ecx_142 <= edi_124)
						{
							*((word32) esi_19 + 0x0C) = eax_131;
							*((word32) esi_19 + 4) = eax_131;
							*((word32) esi_19 + 8) = eax_131;
							*((word32) esi_19 + 20) = eax_131;
							*((word32) esi_19 + 16) = eax_131;
							*((word32) esi_19 + 24) = eax_131;
							if (ecx_142 > 0x7F)
								goto l080549CB;
							goto l08054AB2;
						}
						word32 ecx_592;
						if (__underflow(esi_19, out ecx_592) == ~0x00)
							return;
					}
					else
					{
						((word32) esi_19 + 0x0C)->u0 = 0x00;
						((word32) esi_19 + 4)->u0 = 0x00;
						((word32) esi_19 + 8)->u0 = 0x00;
						((word32) esi_19 + 20)->u0 = 0x00;
						((word32) esi_19 + 16)->u0 = 0x00;
						((word32) esi_19 + 24)->u0 = 0x00;
l080549CB:
						Eq_2 ebx_197 = *((word32) esi_19 + 0x0094);
						if (dwLoc24 <= ebx_197 - dwLoc2C)
						{
							word32 ecx_593;
							word32 edx_594;
							_IO_vtable_check(out ecx_593, out edx_594);
						}
						Eq_21538 eax_242;
						(*((word32) ebx_197 + 56))();
						if (eax_242 <= 0x00)
						{
							ui32 edx_250 = *esi_19;
							ui32 edx_254 = edx_250 | 0x10;
							if (eax_242 != 0x00)
								edx_254 = edx_250 | 0x20;
							*esi_19 = edx_254;
							return;
						}
						Eq_2 eax_276 = *((word32) esi_19 + 76);
						Eq_2 edx_277 = *((word32) esi_19 + 80);
						ebp_108 += eax_242;
						edi_124 -= eax_242;
						if ((eax_276 & edx_277) != ~0x00)
						{
							ui64 edx_eax_383 = SEQ(edx_277, eax_276) + SEQ(eax_242 >> 0x1F, eax_242);
							*((word32) esi_19 + 76) = (word32) edx_eax_383;
							*((word32) esi_19 + 80) = SLICE(edx_eax_383, word32, 32);
						}
					}
					if (edi_124 == 0x00)
						goto l08054A78;
				}
				else
				{
l08054A61:
					_IO_switch_to_main_get_area(esi_19);
					if (edi_124 == 0x00)
						goto l08054A78;
				}
				eax_105 = *((word32) esi_19 + 4);
				esp_18 = fp - 44;
				edx_320 = *((word32) esi_19 + 8) - eax_105;
			} while (edi_124 > edx_320);
		}
		struct Eq_21344 * esp_327 = esp_18 - 0x04;
		esp_327->tFFFFFFFC = edi_124;
		esp_327->tFFFFFFF8 = eax_105;
		esp_327->tFFFFFFF4 = ebp_108;
		word32 ecx_586;
		word32 edx_587;
		memcpy(esp_327->tFFFFFFF4, esp_327->tFFFFFFF8, esp_327->tFFFFFFFC, out ecx_586, out edx_587);
		Mem354[esi_19 + 0x04:word32] = Mem341[esi_19 + 0x04:word32] + edi_124;
	}
	else
	{
l08054A78:
	}
}

// 08054B70: void _IO_file_seekoff_mmap(Register (ptr32 Eq_21595) gs, Stack (ptr32 Eq_21596) dwArg04, Stack word64 qwArg08, Stack word32 dwArg10, Stack word32 dwArg14)
void _IO_file_seekoff_mmap(struct Eq_21595 * gs, struct Eq_21596 * dwArg04, word64 qwArg08, word32 dwArg10, word32 dwArg14)
{
	up32 dwArg08 = (word32) qwArg08;
	int32 dwArg0C = SLICE(qwArg08, word32, 32);
	Eq_2 esp_18 = fp - 44;
	up32 edi_107 = dwArg08;
	int32 ebp_22 = dwArg0C;
	if (dwArg14 == 0x00)
		return;
	Eq_21612 esi_50;
	if (dwArg10 != 0x01)
	{
		if (dwArg10 != 0x02)
			goto l08054BB3;
		esi_50 = dwArg04->dw0020 - dwArg04->dw001C;
	}
	else
		esi_50 = dwArg04->dw0004 - dwArg04->dw000C;
	ui64 ebp_edi_182 = qwArg08 + SEQ(esi_50 >> 0x1F, esi_50);
	edi_107 = (word32) ebp_edi_182;
	ebp_22 = SLICE(ebp_edi_182, word32, 32);
l08054BB3:
	if (ebp_22 >= 0x00)
	{
		struct Eq_21636 * esi_82 = dwArg04->ptr0094;
		if (esi_82 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 ecx_255;
			word32 edx_256;
			_IO_vtable_check(out ecx_255, out edx_256);
			esp_18.u0 = <invalid>;
		}
		struct Eq_21648 * esp_100 = esp_18 - 4;
		esp_100->dw0000 = 0x00;
		esp_100->dwFFFFFFFC = ebp_22;
		esp_100->dwFFFFFFF8 = edi_107;
		esp_100->ptrFFFFFFF4 = dwArg04;
		word32 eax_117;
		int32 edx_119;
		esi_82->ptr0040();
		esp_100->dw000C = eax_117;
		if (edx_119 >= 0x00)
		{
			word32 eax_129 = dwArg04->dw0020;
			word32 esi_130 = dwArg04->dw001C;
			esp_100->dw0010 = eax_129;
			dwArg04->dw000C = esi_130;
			up32 edx_133 = eax_129 - esi_130;
			esp_100->dw0008 = edx_133;
			if (SLICE((int64) edx_133, word32, 32) - ebp_22 - (esp_100->dw0008 < edi_107) >= 0x00)
			{
				word32 eax_148 = esi_130 + edi_107;
				dwArg04->dw0004 = eax_148;
				dwArg04->dw0008 = eax_148;
			}
			else
			{
				word32 edx_145 = esp_100->dw0010;
				dwArg04->dw0004 = edx_145;
				dwArg04->dw0008 = edx_145;
			}
			dwArg04->dw0000 &= ~0x10;
			word32 eax_158 = esp_100->dw000C;
			dwArg04->dw0050 = edx_119;
			dwArg04->dw004C = eax_158;
		}
	}
	else
		gs->dwFFFFFFE0 = 22;
}

// 08054CD0: Register word32 _IO_file_underflow_mmap(Register (ptr32 Eq_16458) ebx, Register Eq_2 esi, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow_mmap
word32 _IO_file_underflow_mmap(struct Eq_16458 * ebx, Eq_2 esi, Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04)
{
	word32 eax_105;
	Eq_2 eax_16 = *((word32) dwArg04 + 4);
	if (eax_16 >= *((word32) dwArg04 + 8))
	{
		struct Eq_21756 * ebx_23;
		word32 ebp_151;
		word32 edi_152;
		if (mmap_remap_check(dwArg04, gs, ebx, esi, edi, dwArg00, out ebx_23, out ebp_151, out edi_152) != 0x00)
		{
			struct Eq_21770 * edi_35 = ebx_23->ptr0094;
			if (edi_35 >= &__elf_set___libc_atexit_element__IO_cleanup__)
			{
				word32 ecx_153;
				word32 edx_154;
				_IO_vtable_check(out ecx_153, out edx_154);
			}
			word32 eax_63;
			word32 edx_64;
			word32 ecx_65;
			edi_35->ptr0010();
			return eax_63;
		}
		eax_16 = ebx_23->t0004;
		if (eax_16 >= ebx_23->t0008)
		{
			ebx_23->dw0000 |= 0x10;
			eax_105 = ~0x00;
			return eax_105;
		}
	}
	eax_105 = (word32) *eax_16;
	return eax_105;
}

// 08054D50: void _IO_file_read(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_21805) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_read(struct Eq_9 * gs, struct Eq_21805 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 edx_6 = dwArg04->t0038;
	if ((dwArg04->b003C & 0x02) != 0x00)
	{
		word32 ecx_45;
		__read_nocancel(gs, edx_6, dwArg08, dwArg0C, out ecx_45);
	}
	else
		read(gs, edx_6, dwArg08, dwArg0C);
}

// 08054D80: void _IO_file_xsputn(Stack (ptr32 Eq_18343) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_file_xsputn(struct Eq_18343 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	if (dwArg0C == 0x00)
		return;
	Eq_2 ebp_133;
	word32 edx_121;
	Eq_2 ebp_31;
	word32 edx_59;
	Eq_2 ecx_26 = dwArg04->t0014;
	if ((dwArg04->dw0000 & 0x0A00) != 0x0A00)
	{
		Eq_2 ebp_67 = dwArg04->t0018;
		if (ebp_67 <= ecx_26)
			goto l08054E60;
		ebp_31 = ebp_67 - ecx_26;
	}
	else
	{
		ebp_31 = dwArg04->t0020 - ecx_26;
		if (dwArg0C <= ebp_31)
		{
			word32 edx_35 = dwArg08 + dwArg0C;
			if (dwArg08 < edx_35)
			{
				Eq_2 eax_39 = edx_35 - 0x01;
				if (*((word32) edx_35 - 1) != 0x0A)
				{
					do
					{
						if (dwArg08 == eax_39)
							goto l08054E50;
						--eax_39;
					} while (*eax_39 != 0x0A);
				}
				up32 eax_54 = eax_39 - dwArg08;
				ebp_31 = eax_54 + 0x01;
				if (eax_54 == 0x01)
				{
					ebp_133 = dwArg0C;
					edx_121 = 0x01;
					goto l08054DF7;
				}
				edx_59 = 0x01;
			}
			else
			{
l08054E50:
				edx_59 = 0x00;
			}
l08054DCC:
			if (dwArg0C <= ebp_31)
				ebp_31 = dwArg0C;
			word32 edx_419;
			dwArg04->t0014 = __mempcpy(ecx_26, dwArg08, ebp_31, out edx_419);
			dwArg08 += ebp_31;
			edx_121 = edx_59;
			ebp_133 = dwArg0C - ebp_31;
l08054DF7:
			if ((word32) ebp_133 + edx_121 == 0x00)
				return;
l08054E62:
			Eq_2 esp_154 = fp - 44;
			Eq_2 eax_146 = dwArg04->t0094;
			if (eax_146 >= 135066356)
			{
				word32 ecx_420;
				word32 edx_421;
				_IO_vtable_check(out ecx_420, out edx_421);
				esp_154.u0 = <invalid>;
				eax_146 = *((word64) esp_154.u0 + 0x0C);
			}
			struct Eq_21890 * esp_167 = esp_154 - 0x08;
			esp_167->tFFFFFFFC.u0 = ~0x00;
			esp_167->ptrFFFFFFF8 = dwArg04;
			word32 eax_192;
			word32 ecx_193;
			(*((word32) eax_146 + 0x0C))();
			if (eax_192 == ~0x00)
				return;
			uint32 ecx_206 = dwArg04->t0020 - dwArg04->t001C;
			Eq_2 ebx_207 = ebp_133;
			if (ecx_206 > 0x7F)
				ebx_207 = ebp_133 - (uint32) ((uint64) ebp_133 % ecx_206);
			if (ebx_207 != 0x00)
			{
				Eq_2 eax_230 = new_do_write(dwArg04, ebx_207, esp_167->ptr003C);
				if (eax_230 < ebx_207)
					return;
				ebp_133 -= eax_230;
			}
			if (ebp_133 != 0x00)
			{
				esp_167->t0014 = dwArg0C;
				esp_167->t0000 = ebp_133;
				Mem259[esp_167 + -4:word32] = ebx_207 + Mem254[esp_167 + 0x3C:word32];
				esp_167->ptrFFFFFFF8 = dwArg04;
				_IO_default_xsputn(esp_167->tFFFFFFFC, esp_167->t0000);
			}
			return;
		}
	}
	edx_59 = 0x00;
	if (ebp_31 != 0x00)
		goto l08054DCC;
l08054E60:
	ebp_133 = dwArg0C;
	goto l08054E62;
}

// 08054F60: void _IO_new_file_init_internal(Stack Eq_2 dwArg04)
// Called from:
//      __fopen_internal
void _IO_new_file_init_internal(Eq_2 dwArg04)
{
	*dwArg04 |= 9228;
	((word32) dwArg04 + 76)->u0 = ~0x00;
	((word32) dwArg04 + 80)->u0 = ~0x00;
	_IO_link_in(ecx, gs, dwArg04);
	((word32) dwArg04 + 56)->u0 = ~0x00;
}

// 08054FA0: void _IO_file_init(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_file_init(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	*dwArg04 |= 9228;
	((word32) dwArg04 + 76)->u0 = ~0x00;
	((word32) dwArg04 + 80)->u0 = ~0x00;
	_IO_link_in(ecx, gs, dwArg04);
	((word32) dwArg04 + 56)->u0 = ~0x00;
}

// 08054FE0: Register Eq_2 _IO_file_open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack ui32 dwArg14, Stack word32 dwArg18)
// Called from:
//      _IO_file_fopen
Eq_2 _IO_file_open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ui32 dwArg14, word32 dwArg18)
{
	Eq_2 eax_19 = dwArg0C;
	if (dwArg18 == 0x00)
		eax_19 = dwArg0C | 0x8000;
	Eq_2 ebp_57;
	if ((*((word32) dwArg04 + 60) & 0x02) == 0x00)
		ebp_57 = open(gs, dwArg08, eax_19, dwArg10);
	else
	{
		word32 edx_285;
		word32 ecx_284;
		ebp_57 = __open_nocancel(gs, dwArg08, eax_19, dwArg10, out ecx_284, out edx_285);
	}
	if (ebp_57 < 0x00)
		return 0x00;
	Eq_2 eax_159;
	ui32 eax_96 = *dwArg04;
	*((word32) dwArg04 + 56) = ebp_57;
	*dwArg04 = eax_96 & ~0x100C | dwArg14 & 0x100C;
	if ((dwArg14 & 0x1004) == 0x1004)
	{
		Eq_2 esi_107 = *((word32) dwArg04 + 0x0094);
		if (esi_107 >= 135066356)
		{
			word32 edx_288;
			word32 ecx_287;
			_IO_vtable_check(out ecx_287, out edx_288);
		}
		ui32 eax_137;
		ui32 edx_138;
		(*((word32) esi_107 + 64))();
		if ((eax_137 & edx_138) == ~0x00 && gs->tFFFFFFE0 != 0x1D)
		{
			word32 edx_289;
			__close_nocancel(gs, ebp_57, out edx_289);
			eax_159.u0 = 0x00;
			return eax_159;
		}
	}
	_IO_link_in(ecx, gs, dwArg04);
	eax_159 = dwArg04;
	return eax_159;
}

// 08055110: void _IO_file_attach(Register (ptr32 Eq_22140) gs, Stack (ptr32 Eq_22141) dwArg04, Stack word32 dwArg08)
void _IO_file_attach(struct Eq_22140 * gs, struct Eq_22141 * dwArg04, word32 dwArg08)
{
	if (dwArg04->dw0038 != ~0x00)
		return;
	struct Eq_22148 * ebp_23 = dwArg04->ptr0094;
	dwArg04->dw004C = ~0x00;
	dwArg04->dw0050 = ~0x00;
	dwArg04->dw0038 = dwArg08;
	dwArg04->dw0000 = dwArg04->dw0000 & ~0x0C | 0x40;
	word32 esi_37 = gs->dwFFFFFFE0;
	if (ebp_23 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_161;
		word32 ecx_160;
		_IO_vtable_check(out ecx_160, out edx_161);
	}
	ui32 edx_67;
	ui32 eax_68;
	word32 ecx_69;
	ebp_23->ptr0024();
	if ((eax_68 & edx_67) == ~0x00 && gs->dwFFFFFFE0 != 0x1D)
		return;
	gs->dwFFFFFFE0 = esi_37;
}

// 080551C0: Register word32 _IO_do_write(Stack Eq_2 dwArg0C)
// Called from:
//      _IO_wdo_write
//      _IO_wfile_overflow
//      _IO_wfile_sync
//      _IO_file_close_it
//      _IO_new_file_finish
//      _IO_new_file_overflow
//      _IO_new_file_sync
word32 _IO_do_write(Eq_2 dwArg0C)
{
	if (dwArg0C != 0x00)
		return -(word32) (int8) (dwArg0C != new_do_write(dwArg04, dwArg0C, dwArg08));
	return 0x00;
}

// 08055200: void _IO_file_close_it(Stack Eq_2 dwArg04)
// Called from:
//      __new_fclose
//      _IO_file_fopen
void _IO_file_close_it(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 56) != ~0x00)
	{
		if ((*dwArg04 & 0x0808) == 0x0800)
		{
			if (*((word32) dwArg04 + 0x0068) > 0x00)
			{
				Eq_2 eax_49 = *((word32) dwArg04 + 88);
				Eq_2 edx_51 = *((word32) eax_49 + 0x0C);
				word32 ebx_298;
				word32 esi_299;
				_IO_wdo_write(gs, dwArg04, edx_51, *((word32) eax_49 + 16) - edx_51 >> 0x02, out ebx_298, out esi_299);
			}
			else
				_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16));
		}
		_IO_unsave_markers(dwArg04);
		word32 esi_115 = 0x00;
		if ((*((word32) dwArg04 + 60) & 0x20) == 0x00)
		{
			Eq_2 esi_89 = *((word32) dwArg04 + 0x0094);
			if (esi_89 >= 135066356)
			{
				word32 ecx_294;
				word32 edx_295;
				_IO_vtable_check(out ecx_294, out edx_295);
			}
			word32 eax_111;
			word32 edx_112;
			word32 ecx_113;
			(*((word32) esi_89 + 0x0044))();
			esi_115 = eax_111;
		}
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			if (*((word32) *((word32) dwArg04 + 88) + 32) != 0x00)
				_IO_free_wbackup_area(dwArg04);
			word32 edx_296;
			_IO_wsetb(dwArg04, 0x00, 0x00, 0x00, out edx_296);
			Eq_2 eax_161 = *((word32) dwArg04 + 88);
			((word32) eax_161 + 8)->u0 = 0x00;
			*eax_161 = 0x00;
			((word32) eax_161 + 4)->u0 = 0x00;
			((word32) eax_161 + 16)->u0 = 0x00;
			((word32) eax_161 + 0x0C)->u0 = 0x00;
			((word32) eax_161 + 20)->u0 = 0x00;
		}
		_IO_setb(dwArg04, 0x00, 0x00, 0x00);
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		((word32) dwArg04 + 4)->u0 = 0x00;
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 16)->u0 = 0x00;
		((word32) dwArg04 + 24)->u0 = 0x00;
		_IO_un_link(dwArg04);
		*dwArg04 = 4222428172;
		((word32) dwArg04 + 56)->u0 = ~0x00;
		((word32) dwArg04 + 76)->u0 = ~0x00;
		((word32) dwArg04 + 80)->u0 = ~0x00;
	}
}

// 080553A0: Register (ptr32 Eq_22392) _IO_file_fopen(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 byte) dwArg0C)
// Called from:
//      __fopen_internal
struct Eq_22392 * _IO_file_fopen(struct Eq_9 * gs, Eq_2 dwArg04, byte * dwArg0C)
{
	struct Eq_22392 * dwLoc58_662;
	struct Eq_22394 * esp_455;
	byte * edx_20 = dwArg0C;
	ui32 eax_25 = gs->dw0014;
	if (*((word32) dwArg04 + 56) != ~0x00)
	{
l08055630:
		dwLoc58_662 = null;
		goto l08055410;
	}
	ui32 ecx_950;
	ui32 edi_116;
	ui32 dwLoc5C_626;
	byte al_31 = *dwArg0C;
	if (al_31 != 114)
	{
		if (al_31 != 0x77)
		{
			if (al_31 != 0x61)
			{
				gs->tFFFFFFE0.u0 = 22;
				dwLoc58_662 = null;
				goto l08055410;
			}
			edi_116 = 0x1004;
			dwLoc5C_626 = 0x01;
			ecx_950 = 0x0440;
		}
		else
		{
			dwLoc5C_626 = 0x01;
			edi_116 = 0x04;
			ecx_950 = 0x0240;
		}
	}
	else
	{
		edi_116 = 0x08;
		dwLoc5C_626 = 0x00;
		ecx_950 = 0x00;
	}
	byte * ebx_140 = dwArg0C;
	ui32 ecx_121 = ecx_950;
	do
	{
		++edx_20;
		word24 ecx_24_8_80 = SLICE(ecx_121, word24, 8);
		byte cl_73 = (byte) ecx_121;
		ci8 al_56 = *edx_20;
		if (al_56 != 99)
		{
			if (al_56 <= 99)
			{
				if (al_56 != 0x2B)
				{
					if (al_56 != 0x62)
					{
						if (al_56 == 0x00)
							break;
					}
					else
						ebx_140 = edx_20;
				}
				else
				{
					edi_116 &= 0x1000;
					ebx_140 = edx_20;
					dwLoc5C_626 = 0x02;
				}
			}
			else if (al_56 != 0x6D)
			{
				if (al_56 != 0x78)
				{
					if (al_56 == 101)
					{
						*((word32) dwArg04 + 60) |= 0x40;
						ecx_121 |= 0x00080000;
					}
				}
				else
				{
					ebx_140 = edx_20;
					ecx_121 = SEQ(ecx_24_8_80, cl_73 | 0x80);
				}
			}
			else
				*((word32) dwArg04 + 60) |= 0x01;
		}
		else
			*((word32) dwArg04 + 60) |= 0x02;
	} while (edx_20 != dwArg0C + 6);
	struct Eq_22392 * eax_151 = _IO_file_open(gs, dwArg04, dwArg08, ecx_121 | dwLoc5C_626, 0x01B6, edi_116, dwArg10);
	dwLoc58_662 = eax_151;
	if (eax_151 == null)
		goto l08055630;
	word32 ecx_956;
	word32 edx_957;
	Eq_2 eax_169 = strstr(gs, ebx_140 + 1, 134883381, out ecx_956, out edx_957);
	if (eax_169 == 0x00)
	{
l08055410:
		if ((eax_25 ^ gs->dw0014) == 0x00)
			return dwLoc58_662;
		word32 ecx_954;
		word32 edx_955;
		__stack_chk_fail(out ecx_954, out edx_955);
		goto l08055862;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 esi_194 = strchrnul((word32) eax_169 + 5, 44) - ((word32) eax_169 + 5);
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_959;
	word32 ebx_961;
	word32 esi_963;
	word32 edi_964;
	word32 ebp_962;
	word32 edx_960;
	Eq_2 eax_198 = __libc_malloc(gs, stackArg0, (word32) esi_194 + 3, out ecx_959, out edx_960, out ebx_961, out ebp_962, out esi_963, out edi_964);
	if (eax_198 == 0x00)
	{
		Eq_2 esi_211 = gs->tFFFFFFE0;
		_IO_file_close_it(dwArg04);
		gs->tFFFFFFE0 = esi_211;
		goto l08055630;
	}
	Eq_2 ecx_257;
	Eq_2 eax_249;
	word32 edx_235;
	*__mempcpy(eax_198, (word32) eax_169 + 5, esi_194, out edx_235) = 0x00;
	word32 eax_243 = (word32) *eax_198;
	ui24 edx_24_8_270 = SLICE(edx_235, word24, 8);
	if ((byte) eax_243 == 0x00)
	{
		*eax_198 = 0x2F;
		eax_249 = (word32) eax_198 + 1;
		goto l080556BC;
	}
	else
	{
		int32 dwLoc5C_681 = 0x00;
		Eq_2 esi_254 = g_t80CE08C;
		Eq_3851 ecx_255[] = g_ptr80CE084;
		ecx_257 = eax_198;
		Eq_2 ebx_259 = eax_198;
		do
		{
			byte al_263 = (byte) eax_243;
			int32 esi_265 = (int32) al_263;
			word32 ebp_269 = dwLoc5C_681 + 0x01;
			edx_24_8_270 = SLICE(eax_243 - 44, word24, 8);
			if (((int8) ((byte) (eax_243 - 44) <= 0x02) | (byte) (SEQ(edx_24_8_270, (int8) (al_263 == 0x5F)) | SEQ(edx_24_8_270, (int8) (al_263 == 0x3A)))) == 0x00 && (*((word32) esi_254 + esi_265 * 0x02) & 0x08) == 0x00)
			{
				if (al_263 == 0x2F)
				{
					if (dwLoc5C_681 == 0x02)
						goto l080556C2;
					*ecx_257 = 0x2F;
					ecx_257 = (word32) ecx_257 + 1;
					++dwLoc5C_681;
					ebp_269 = dwLoc5C_681 + 0x02;
				}
			}
			else
			{
				ecx_257 = (word32) ecx_257 + 1;
				*((word32) ecx_257 - 1) = ecx_255[esi_265];
			}
			ebx_259 = (word32) ebx_259 + 1;
			eax_243 = (word32) *ebx_259;
		} while ((byte) eax_243 != 0x00);
		if (dwLoc5C_681 <= 0x01)
		{
			*ecx_257 = 0x2F;
			eax_249 = (word32) ecx_257 + 1;
			if (ebp_269 == 0x01)
			{
l080556BC:
				*eax_249 = 0x2F;
				ecx_257 = (word32) eax_249 + 1;
				goto l080556C2;
			}
			ecx_257 = eax_249;
		}
l080556C2:
		*ecx_257 = 0x00;
		if (*((word32) eax_198 + 2) == 0x00)
		{
			struct Eq_22688 * edx_353 = (word32) eax_169 + 5;
			Eq_3851 ecx_354[] = g_ptr80CE084;
			Eq_2 eax_355 = eax_198;
			do
			{
				++edx_353;
				eax_355 = (word32) eax_355 + 1;
				Eq_3851 bl_367 = ecx_354[(int32) edx_353->bFFFFFFFF];
				*((word32) eax_355 - 1) = bl_367;
			} while (bl_367 != 0x00);
		}
		if (__wcsmbs_named_conv(fp - 0x30) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_970;
			word32 ecx_969;
			free(gs, stackArg0, eax_198, out ecx_969, out edx_970);
			esp_455 = fp - 0x6C;
			if (dwLoc2C != 0x01)
				goto l08055885;
			if (dwLoc24 != 0x01)
			{
l08055862:
				word32 ecx_973;
				word32 edx_974;
				__assert_fail(out ecx_973, out edx_974);
				esp_455 = fp - 0x7C;
l08055885:
				word32 ebx_564 = esp_455->dw0018;
				struct Eq_22739 * esp_566 = esp_455 - 4;
				esp_566->dw0000 = ebx_564 + 4294789224;
				esp_566->dwFFFFFFFC = 322;
				esp_566->dwFFFFFFF8 = ebx_564 + ~0x0002B855;
				esp_566->dwFFFFFFF4 = ebx_564 + 4294789179;
				word32 edx_972;
				word32 ecx_971;
				__assert_fail(out ecx_971, out edx_972);
			}
			Eq_2 eax_460 = *((word32) dwArg04 + 88);
			Eq_2 edx_462 = *((word32) eax_460 + 4);
			*((word32) eax_460 + 44) = 0x00;
			((word32) eax_460 + 48)->u0 = 0x00;
			*eax_460 = edx_462;
			*((word32) eax_460 + 16) = *((word32) eax_460 + 0x0C);
			Eq_2 eax_470 = *((word32) dwArg04 + 88);
			((word32) eax_470 + 52)->u0 = 0x00;
			((word32) eax_470 + 56)->u0 = 0x00;
			Eq_2 eax_473 = *((word32) dwArg04 + 88);
			*((word32) dwArg04 + 84) = (word32) eax_473 + 60;
			word32 * esi_464 = (word32 *) 0x080CCFC0;
			word32 ecx_465;
			word32 * edi_476 = (word32) eax_473 + 60;
			for (ecx_465 = 0x1C; ecx_465 != 0x00; --ecx_465)
			{
				*edi_476 = *esi_464;
				++esi_464;
				++edi_476;
			}
			((word32) eax_473 + 92)->u0 = 0x01;
			*((word32) eax_473 + 96) = dwLoc30;
			word32 ebx_487 = eax_151->dw0058;
			*((word32) eax_473 + 112) = 0x00;
			*((word32) eax_473 + 116) = 0x01;
			*((word32) eax_473 + 0x006C) = 0x01;
			*((word32) eax_473 + 0x0078) = ebx_487 + 44;
			*((word32) eax_473 + 0x0084) = (struct Eq_22859 *) 0x01;
			*((word32) eax_473 + 0x0088) = dwLoc28;
			((word32) eax_473 + 0x0098)->u0 = 0x00;
			*((word32) eax_473 + 0x009C) = (struct Eq_22871 *) 0x01;
			((word32) eax_473 + 0x0094)->u0 = 0x09;
			*((word32) eax_473 + 0x00A0) = ebx_487 + 44;
			*((word32) dwArg04 + 0x0094) = *((word32) eax_473 + 0x00B0);
			eax_151->dw0068 = 0x01;
			goto l08055410;
		}
		_IO_file_close_it(dwArg04);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_966;
		word32 edx_967;
		free(gs, stackArg0, eax_198, out ecx_966, out edx_967);
		gs->tFFFFFFE0.u0 = 22;
		goto l08055630;
	}
}

// 080558B0: void _IO_new_file_finish(Stack Eq_2 dwArg04)
// Called from:
//      _IO_file_fopen
void _IO_new_file_finish(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 56) != ~0x00)
	{
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			Eq_2 eax_38 = *((word32) dwArg04 + 88);
			Eq_2 edx_40 = *((word32) eax_38 + 0x0C);
			word32 ebx_137;
			word32 esi_138;
			_IO_wdo_write(gs, dwArg04, edx_40, *((word32) eax_38 + 16) - edx_40 >> 0x02, out ebx_137, out esi_138);
		}
		else
			_IO_do_write(*((word32) dwArg04 + 20) - *((word32) dwArg04 + 16));
		if ((*dwArg04 & 0x40) == 0x00)
		{
			Eq_2 edi_62 = *((word32) dwArg04 + 0x0094);
			if (edi_62 >= 135066356)
			{
				word32 ecx_139;
				word32 edx_140;
				_IO_vtable_check(out ecx_139, out edx_140);
			}
			word32 ecx_88;
			(*((word32) edi_62 + 0x0044))();
		}
	}
	_IO_default_finish(dwArg04);
}

// 08055960: void _IO_new_file_overflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _IO_new_file_overflow(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 eax_21 = *dwArg04;
	Eq_2 ebx_164 = dwArg04;
	word32 esi_156 = dwArg08;
	byte ah_35 = SLICE(eax_21, byte, 8);
	if (((byte) eax_21 & 0x08) != 0x00)
	{
		*dwArg04 = eax_21 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		return;
	}
	Eq_2 edx_106;
	Eq_2 edx_34 = *((word32) dwArg04 + 16);
	if ((ah_35 & 0x08) != 0x00)
	{
		if (edx_34 != 0x00)
		{
			edx_106 = *((word32) dwArg04 + 20);
			goto l0805599B;
		}
	}
	else if (edx_34 != 0x00)
	{
		edx_106 = *((word32) dwArg04 + 4);
l080559EB:
		Eq_2 eax_110 = eax_21;
		if ((SLICE(eax_21, byte, 8) & 0x01) != 0x00)
		{
			uint32 edi_84 = *((word32) ebx_164 + 8) - edx_106;
			_IO_free_backup_area(ebx_164);
			Eq_2 edx_94 = *((word32) ebx_164 + 0x0C);
			uint32 ecx_98 = edx_94 - *((word32) ebx_164 + 28);
			ui32 ebp_95 = -edi_84;
			ui32 eax_100 = -ecx_98;
			if (ecx_98 > edi_84)
				eax_100 = ebp_95;
			edx_106 = (word32) edx_94 + eax_100;
			eax_110 = *ebx_164;
			*((word32) ebx_164 + 0x0C) = edx_106;
			*((word32) ebx_164 + 4) = edx_106;
		}
		Eq_2 ecx_121;
		Eq_2 edi_115 = *((word32) ebx_164 + 32);
		if (edi_115 != edx_106)
			ecx_121 = *((word32) ebx_164 + 8);
		else
		{
			edx_106 = *((word32) ebx_164 + 28);
			*((word32) ebx_164 + 8) = edx_106;
			ecx_121 = edx_106;
		}
		*((word32) ebx_164 + 4) = ecx_121;
		*((word32) ebx_164 + 0x0C) = ecx_121;
		*((word32) ebx_164 + 20) = edx_106;
		*ebx_164 = SEQ(SLICE(eax_110, word16, 16), SLICE(eax_110, byte, 8) | 0x08, (byte) eax_110);
		Eq_2 ecx_144 = *((word32) ebx_164 + 0x0068);
		*((word32) ebx_164 + 16) = edx_106;
		*((word32) ebx_164 + 24) = edi_115;
		if (ecx_144 <= 0x00 && (eax_110 & 0x0202) != 0x00)
		{
			*((word32) ebx_164 + 24) = edx_106;
			if (esi_156 != ~0x00)
			{
l080559A4:
				ptr32 esp_210 = fp - 0x1C;
				if (*((word32) ebx_164 + 32) == edx_106)
				{
					int8 al_228;
					if (*((word32) ebx_164 + 0x0068) > 0x00)
					{
						Eq_2 eax_229 = *((word32) ebx_164 + 88);
						Eq_2 esp_256 = <invalid>;
						Eq_2 edx_231 = *((word32) eax_229 + 0x0C);
						esp_210 = (word32) esp_256 + 16;
						al_228 = (int8) (_IO_wdo_write(gs, ebx_164, edx_231, *((word32) eax_229 + 16) - edx_231 >> 0x02, out ebx_164, out esi_156) == ~0x00);
					}
					else
					{
						esp_210 = fp - 0x1C;
						al_228 = (int8) (_IO_do_write(edx_106 - *((word32) ebx_164 + 16)) == ~0x00);
					}
					if (al_228 != 0x00)
						return;
					edx_106 = *((word32) ebx_164 + 20);
				}
				*((word32) ebx_164 + 20) = (word32) edx_106 + 1;
				*edx_106 = (byte) esi_156;
				Eq_2 eax_282 = *ebx_164;
				byte ah_287 = SLICE(eax_282, byte, 8);
				if (((byte) eax_282 & 0x02) == 0x00 && ((ah_287 & 0x02) == 0x00 || esi_156 != 0x0A))
					return;
				Eq_2 edx_295 = *((word32) ebx_164 + 16);
				struct Eq_23089 * esp_300 = esp_210 - 0x04;
				esp_300->tFFFFFFFC = *((word32) ebx_164 + 20) - edx_295;
				esp_300->tFFFFFFF8 = edx_295;
				esp_300->tFFFFFFF4 = ebx_164;
				if (_IO_do_write(esp_300->tFFFFFFFC) != ~0x00)
					return;
				return;
			}
l08055A3A:
			_IO_do_write(edx_106 - *((word32) ebx_164 + 16));
			return;
		}
l0805599B:
		if (esi_156 != ~0x00)
			goto l080559A4;
		goto l08055A3A;
	}
	word32 edi_463;
	word32 ebp_462;
	ebx_164 = _IO_doallocbuf(dwArg04, out ebp_462, out esi_156, out edi_463);
	edx_106 = *((word32) ebx_164 + 28);
	eax_21 = *ebx_164;
	*((word32) ebx_164 + 0x0C) = edx_106;
	*((word32) ebx_164 + 4) = edx_106;
	*((word32) ebx_164 + 8) = edx_106;
	goto l080559EB;
}

// 08055B70: void _IO_new_file_sync(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_new_file_sync(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_102 = fp - 44;
	Eq_2 ebx_19 = dwArg04;
	Eq_2 eax_20 = *((word32) dwArg04 + 20);
	Eq_2 edx_21 = *((word32) dwArg04 + 16);
	if (eax_20 > edx_21)
	{
		int8 al_45;
		if (*((word32) dwArg04 + 0x0068) > 0x00)
		{
			Eq_2 eax_46 = *((word32) dwArg04 + 88);
			Eq_2 esp_67 = <invalid>;
			Eq_2 edx_48 = *((word32) eax_46 + 0x0C);
			esp_102 = (word32) esp_67 + 16;
			word32 esi_225;
			al_45 = (int8) (_IO_wdo_write(gs, dwArg04, edx_48, *((word32) eax_46 + 16) - edx_48 >> 0x02, out ebx_19, out esi_225) != 0x00);
		}
		else
		{
			esp_102 = fp - 44;
			al_45 = (int8) (_IO_do_write(eax_20 - edx_21) != 0x00);
		}
		if (al_45 != 0x00)
			return;
	}
	Eq_2 eax_107 = *((word32) ebx_19 + 4) - *((word32) ebx_19 + 8);
	if (eax_107 != 0x00)
	{
		Eq_2 edi_89 = *((word32) ebx_19 + 0x0094);
		if (edi_89 >= 135066356)
		{
			*((word32) esp_102 + 0x0C) = eax_107;
			word32 edx_227;
			word32 ecx_226;
			_IO_vtable_check(out ecx_226, out edx_227);
			esp_102.u0 = <invalid>;
			eax_107 = *((word64) esp_102.u0 + 0x0C);
		}
		struct Eq_23345 * esp_111 = esp_102 - 4;
		esp_111->dw0000 = 0x01;
		int64 edx_eax_109 = (int64) eax_107;
		word32 edx_114 = SLICE(edx_eax_109, word32, 32);
		esp_111->dwFFFFFFFC = edx_114;
		word32 eax_117 = (word32) edx_eax_109;
		esp_111->dwFFFFFFF8 = eax_117;
		esp_111->tFFFFFFF4 = ebx_19;
		ui32 eax_133;
		ui32 edx_134;
		word32 ecx_135;
		(*((word32) edi_89 + 64))();
		if ((eax_133 & edx_134) != ~0x00)
			*((word32) ebx_19 + 8) = *((word32) ebx_19 + 4);
		else if (gs->tFFFFFFE0 != 0x1D)
			return;
	}
	((word32) ebx_19 + 76)->u0 = ~0x00;
	((word32) ebx_19 + 80)->u0 = ~0x00;
}

// 08055C60: Register Eq_2 save_for_backup(Register Eq_2 eax, Register Eq_2 edx, Register out Eq_2 ecxOut)
// Called from:
//      __underflow
//      __uflow
//      _IO_str_pbackfail
Eq_2 save_for_backup(Eq_2 eax, Eq_2 edx, union Eq_2 & ecxOut)
{
	Eq_2 eax_300;
	Eq_2 edx_187;
	Eq_2 ebx_192;
	Eq_2 esi_196;
	Eq_2 eax_21 = *((word32) eax + 0x0C);
	Eq_2 eax_188 = *((word32) eax + 48);
	Eq_2 esi_22 = *((word32) eax + 36);
	Eq_2 edx_27 = *((word32) eax + 44);
	Eq_2 edi_181 = edx - eax_21;
	Eq_2 ecx_177 = eax_188;
	Eq_2 edx_191 = edx_27 - esi_22;
	if (eax_188 != 0x00)
	{
		esi_196 = edi_181;
		do
		{
			Eq_2 ebx_49 = *((word32) ecx_177 + 8);
			ecx_177 = *ecx_177;
			if (esi_196 > ebx_49)
				esi_196 = ebx_49;
		} while (ecx_177 != 0x00);
		ecx_177 = edi_181 - esi_196;
		if (ecx_177 > edx_191)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebx_440;
			word32 edi_443;
			word32 edx_439;
			word32 esi_442;
			word32 ebp_441;
			Eq_2 eax_82 = __libc_malloc(gs, stackArg0, (word32) ecx_177 + 100, out ecx_177, out edx_439, out ebx_440, out ebp_441, out esi_442, out edi_443);
			if (eax_82 == 0x00)
			{
				eax_300.u0 = ~0x00;
l08055CEB:
				ecxOut = ecx_177;
				return eax_300;
			}
			if (esi_196 >= 0x00)
			{
				word32 edx_451;
				word32 ecx_450;
				memcpy((word32) eax_82 + 100, esi_196 + eax_21, ecx_177, out ecx_450, out edx_451);
			}
			else
			{
				word32 edx_449;
				word32 edx_447;
				word32 ecx_448;
				memcpy(__mempcpy((word32) eax_82 + 100, esi_196 + edx_27, -esi_196, out edx_447), eax_21, edi_181, out ecx_448, out edx_449);
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_453;
			free(gs, stackArg0, esi_22, out ecx_177, out edx_453);
			edi_181 = edx - *((word32) eax + 0x0C);
			*((word32) eax + 36) = eax_82;
			*((word32) eax + 44) = (word32) eax_82 + ((word32) ecx_177 + 100);
			edx_187 = (word32) eax_82 + 100;
			eax_188 = *((word32) eax + 48);
			goto l08055D7F;
		}
		edx_191 -= ecx_177;
		ebx_192 = esi_22 + edx_191;
		if (esi_196 >= 0x00)
		{
			if (ecx_177 == 0x00)
			{
				*((word32) eax + 40) = ebx_192;
				goto l08055CE0;
			}
			word32 edx_446;
			memcpy(ebx_192, esi_196 + eax_21, ecx_177, out ecx_177, out edx_446);
			edx_187 = edx_191 + Mem265[eax + 0x24:word32];
			edi_181 = edx - *((word32) eax + 0x0C);
			eax_188 = *((word32) eax + 48);
l08055D7F:
			*((word32) eax + 40) = edx_187;
			if (eax_188 == 0x00)
			{
l08055CE9:
				eax_300.u0 = 0x00;
				goto l08055CEB;
			}
l08055CE0:
			do
			{
				*((word32) eax_188 + 8) -= edi_181;
				eax_188 = *eax_188;
			} while (eax_188 != 0x00);
			goto l08055CE9;
		}
	}
	else
	{
		if (edi_181 >= 0x00)
		{
			*((word32) eax + 40) = edx_27;
			goto l08055CE9;
		}
		ebx_192 = edx_27;
		esi_196 = edi_181;
	}
	word32 edx_444;
	memmove(ebx_192, edx_27 + esi_196, -esi_196, out edx_444);
	Eq_2 ecx_225 = *((word32) eax + 0x0C);
	word32 edx_445;
	memcpy((word32) *((word32) eax + 36) + (edx_191 - esi_196), ecx_225, edx - ecx_225, out ecx_177, out edx_445);
	edi_181 = edx - *((word32) eax + 0x0C);
	edx_187 = edx_191 + Mem237[eax + 0x24:word32];
	eax_188 = *((word32) eax + 48);
	goto l08055D7F;
}

// 08055E80: void flush_cleanup(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
void flush_cleanup(Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_2 eax_7 = run_fp;
	if (eax_7 != 0x00 && (*eax_7 & 0x8000) == 0x00)
	{
		ecx = *((word32) eax_7 + 72);
		Eq_2 v13_15 = *((word32) ecx + 4) - 0x01;
		*((word32) ecx + 4) = v13_15;
		if (v13_15 == 0x00)
		{
			((word32) ecx + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v14_25 = *ecx - 0x01;
			*ecx = v14_25;
			if (v14_25 != 0x00)
				__lll_unlock_wake_private(ecx, ecx, 0x080CE000, gs);
		}
	}
	Eq_2 v9_37 = g_t80CF83C - 0x01;
	g_t80CF83C = v9_37;
	if (v9_37 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v11_48 = g_t80CF838 - 0x01;
		g_t80CF838 = v11_48;
		if (v11_48 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx, 0x080CE000, gs);
	}
}

// 08055F10: void _IO_un_link.part.2(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_un_link
//      _IO_str_finish
void _IO_un_link.part.2(Eq_2 eax, struct Eq_9 * gs)
{
	ui32 eax_28 = gs->dw0014;
	Mem55 = Mem37;
	Eq_2 edx_56 = gs->t0008;
	if (edx_56 != g_t80CF840)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_68;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_68))
			__lll_lock_wait_private(eax_68, 0x080CF838, gs);
		g_t80CF840 = edx_56;
	}
	Eq_2 edx_151;
	Eq_2 ecx_107;
	Eq_2 ecx_89 = *eax;
	Eq_2 ebp_84 = g_t80CF83C;
	run_fp = eax;
	g_t80CF83C = (word32) ebp_84 + 1;
	byte cl_102 = (byte) ecx_89;
	word24 ecx_24_8_106 = SLICE(ecx_89, word24, 8);
	Eq_2 ebp_243 = (word32) ebp_84 + 1;
	ui32 eax_141 = ecx_89 & 0x8000;
	if ((ecx_89 & 0x8000) == 0x00)
	{
		Eq_2 edx_109 = *((word32) eax + 72);
		Eq_2 ebp_112 = gs->t0008;
		if (ebp_112 != *((word32) edx_109 + 8))
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_122;
			if (!__cmpxchg(*edx_109, 0x01, ecx_89 & 0x8000, out eax_122))
				__lll_lock_wait_private(eax_122, edx_109, gs);
			Eq_2 ecx_136 = *eax;
			edx_109 = *((word32) eax + 72);
			*((word32) edx_109 + 8) = ebp_112;
			cl_102 = (byte) ecx_136;
			ecx_24_8_106 = SLICE(ecx_136, word24, 8);
			eax_141 = ecx_136 & 0x8000;
		}
		*((word32) edx_109 + 4) = (word32) *((word32) edx_109 + 4) + 1;
		edx_151 = _IO_list_all;
		if (edx_151 == 0x00)
			goto l08056031;
	}
	else
	{
		edx_151 = _IO_list_all;
		if (edx_151 == 0x00)
		{
			ecx_107 = SEQ(ecx_24_8_106, cl_102 & 0x7F);
			*eax = ecx_107;
			goto l0805604D;
		}
	}
	Eq_2 ebp_157 = *((word32) edx_151 + 52);
	if (eax != edx_151)
	{
		if (ebp_157 != 0x00)
		{
			word32 * ebp_178;
			if (eax == ebp_157)
			{
				ebp_178 = (word32) edx_151 + 52;
l08056133:
				edx_151 = *((word32) eax + 52);
				*ebp_178 = (word32) edx_151;
			}
			else
			{
				while (true)
				{
					edx_151 = *((word32) ebp_157 + 52);
					if (edx_151 == 0x00)
						break;
					if (eax == edx_151)
					{
						ebp_178 = (word32) ebp_157 + 52;
						goto l08056133;
					}
					ebp_157 = edx_151;
				}
			}
		}
	}
	else
		_IO_list_all = ebp_157;
l08056031:
	ecx_107 = SEQ(ecx_24_8_106, cl_102 & 0x7F);
	*eax = ecx_107;
	if (eax_141 == 0x00)
	{
		edx_151 = *((word32) eax + 72);
		Eq_2 v17_212 = *((word32) edx_151 + 4) - 0x01;
		*((word32) edx_151 + 4) = v17_212;
		if (v17_212 == 0x00)
		{
			((word32) edx_151 + 8)->u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			word32 v19_227 = *edx_151 - 0x01;
			*edx_151 = v19_227;
			if (v19_227 != 0x00)
				__lll_unlock_wake_private(edx_151, ecx_107, edx_151, gs);
		}
	}
	ebp_243 = g_t80CF83C;
l0805604D:
	run_fp.u0 = 0x00;
	Eq_2 ebp_247 = ebp_243 - 0x01;
	g_t80CF83C = ebp_247;
	if (ebp_247 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v18_259 = g_t80CF838 - 0x01;
		g_t80CF838 = v18_259;
		if (v18_259 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_107, edx_151, gs);
	}
	if ((eax_28 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_515;
	word32 ecx_514;
	__stack_chk_fail(out ecx_514, out edx_515);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	_IO_un_link(stackArg4);
}

// 08056150: void _IO_un_link(Stack Eq_2 dwArg04)
// Called from:
//      __new_fclose
//      __fopen_internal
//      _IO_file_close_it
//      _IO_un_link.part.2
//      _IO_wdefault_finish
void _IO_un_link(Eq_2 dwArg04)
{
	if ((*dwArg04 & 0x80) == 0x00)
		return;
	_IO_un_link.part.2(eax, gs);
}

// 08056170: void _IO_link_in(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _IO_new_file_init_internal
//      _IO_file_init
//      _IO_file_open
void _IO_link_in(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_24 = *dwArg04;
	ui32 eax_20 = gs->dw0014;
	byte al_25 = (byte) eax_24;
	word24 eax_24_8_31 = SLICE(eax_24, word24, 8);
	if ((al_25 & 0x80) != 0x00)
	{
l08056303:
		if ((eax_20 ^ gs->dw0014) == 0x00)
			return;
		word32 edx_406;
		word32 ecx_405;
		__stack_chk_fail(out ecx_405, out edx_406);
	}
	*dwArg04 = SEQ(eax_24_8_31, al_25 | 0x80);
	Mem57 = Mem39;
	Eq_2 ecx_138 = ecx;
	Eq_2 edx_58 = gs->t0008;
	if (g_t80CF840 != edx_58)
	{
		ecx_138.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_70;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_70))
			ecx_138 = __lll_lock_wait_private(eax_70, 0x080CF838, gs);
		g_t80CF840 = edx_58;
	}
	Eq_2 edx_86 = g_t80CF83C;
	ui32 eax_91 = *dwArg04;
	run_fp = dwArg04;
	g_t80CF83C = (word32) edx_86 + 1;
	Eq_2 edx_180 = (word32) edx_86 + 1;
	if ((eax_91 & 0x8000) != 0x00)
	{
		Eq_2 eax_99 = _IO_list_all;
		_IO_list_all = dwArg04;
		*((word32) dwArg04 + 52) = eax_99;
		goto l080562AF;
	}
	Eq_2 edx_102 = *((word32) dwArg04 + 72);
	Eq_2 ebp_105 = gs->t0008;
	if (*((word32) edx_102 + 8) != ebp_105)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_121;
		if (!__cmpxchg(*edx_102, 0x01, eax_91 & 0x8000, out eax_121))
			__lll_lock_wait_private(eax_121, edx_102, gs);
		edx_102 = *((word32) dwArg04 + 72);
		byte ah_146 = *((word32) dwArg04 + 1);
		ecx_138 = _IO_list_all;
		_IO_list_all = dwArg04;
		*((word32) edx_102 + 8) = ebp_105;
		*((word32) edx_102 + 4) = (word32) *((word32) edx_102 + 4) + 1;
		*((word32) dwArg04 + 52) = ecx_138;
		if ((ah_146 & 0x80) != 0x00)
		{
l08056297:
			edx_180 = g_t80CF83C;
l080562AF:
			run_fp.u0 = 0x00;
			Eq_2 edx_184 = edx_180 - 0x01;
			g_t80CF83C = edx_184;
			if (edx_184 == 0x00)
			{
				g_t80CF840.u0 = 0x00;
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v19_195 = g_t80CF838 - 0x01;
				g_t80CF838 = v19_195;
				if (v19_195 != 0x00)
					__lll_unlock_wake_private(0x080CF838, ecx_138, edx_184, gs);
			}
			goto l08056303;
		}
	}
	else
	{
		Eq_2 eax_108 = _IO_list_all;
		*((word32) edx_102 + 4) = (word32) *((word32) edx_102 + 4) + 1;
		_IO_list_all = dwArg04;
		*((word32) dwArg04 + 52) = eax_108;
	}
	Eq_2 v18_152 = *((word32) edx_102 + 4) - 0x01;
	*((word32) edx_102 + 4) = v18_152;
	if (v18_152 == 0x00)
	{
		((word32) edx_102 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v21_163 = *edx_102 - 0x01;
		*edx_102 = v21_163;
		if (v21_163 != 0x00)
			__lll_unlock_wake_private(edx_102, ecx_138, edx_102, gs);
	}
	goto l08056297;
}

// 08056360: void _IO_least_marker(Stack (ptr32 Eq_24143) dwArg04, Stack word32 dwArg08)
// Called from:
//      _IO_link_in
void _IO_least_marker(struct Eq_24143 * dwArg04, word32 dwArg08)
{
	int32 eax_19 = dwArg08 - dwArg04->dw000C;
	struct Eq_24150 * edx_15 = dwArg04->ptr0030;
	while (edx_15 != null)
	{
		int32 ecx_17 = edx_15->dw0008;
		edx_15 = edx_15->ptr0000;
		if (eax_19 > ecx_17)
			eax_19 = ecx_17;
	}
}

// 08056390: void _IO_switch_to_main_get_area(Stack Eq_2 dwArg04)
// Called from:
//      _IO_file_xsgetn_mmap
//      _IO_file_xsgetn
void _IO_switch_to_main_get_area(Eq_2 dwArg04)
{
	Eq_2 edx_6 = *((word32) dwArg04 + 8);
	Eq_2 ecx_7 = *((word32) dwArg04 + 44);
	*dwArg04 &= ~0x0100;
	*((word32) dwArg04 + 8) = ecx_7;
	Eq_2 ecx_13 = *((word32) dwArg04 + 0x0C);
	*((word32) dwArg04 + 44) = edx_6;
	Eq_2 edx_15 = *((word32) dwArg04 + 36);
	*((word32) dwArg04 + 36) = ecx_13;
	*((word32) dwArg04 + 0x0C) = edx_15;
	*((word32) dwArg04 + 4) = edx_15;
}

// 080563C0: void _IO_switch_to_backup_area(Stack (ptr32 Eq_24205) dwArg04)
void _IO_switch_to_backup_area(struct Eq_24205 * dwArg04)
{
	word32 ecx_8 = dwArg04->dw0008;
	word32 edx_9 = dwArg04->dw002C;
	word32 ebx_10 = dwArg04->dw0024;
	dwArg04->dw0000 |= 0x0100;
	dwArg04->dw002C = ecx_8;
	word32 ecx_16 = dwArg04->dw000C;
	dwArg04->dw0008 = edx_9;
	dwArg04->dw000C = ebx_10;
	dwArg04->dw0024 = ecx_16;
	dwArg04->dw0004 = edx_9;
}

// 080563F0: Register word32 _IO_switch_to_get_mode(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      _IO_wfile_underflow
//      _IO_new_file_underflow
//      _IO_new_file_seekoff
//      __underflow
//      __uflow
//      _IO_init_marker
word32 _IO_switch_to_get_mode(Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 ecx_104;
	word32 eax_103;
	Eq_2 eax_14 = *((word32) dwArg04 + 20);
	if (eax_14 > *((word32) dwArg04 + 16))
	{
		Eq_2 esi_17 = *((word32) dwArg04 + 0x0094);
		if (esi_17 >= 135066356)
		{
			word32 ecx_114;
			word32 edx_115;
			_IO_vtable_check(out ecx_114, out edx_115);
		}
		(*((word32) esi_17 + 0x0C))();
		if (eax_103 == ~0x00)
		{
l08056465:
			ecxOut = ecx_104;
			return eax_103;
		}
		eax_14 = *((word32) dwArg04 + 20);
	}
	word32 edx_49 = *dwArg04;
	byte dh_50 = SLICE(edx_49, byte, 8);
	byte dl_68 = (byte) edx_49;
	word16 edx_16_16_70 = SLICE(edx_49, word16, 16);
	if ((dh_50 & 0x01) == 0x00)
	{
		ecx_104 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 0x0C) = ecx_104;
		if (*((word32) dwArg04 + 8) < eax_14)
			*((word32) dwArg04 + 8) = eax_14;
	}
	else
	{
		ecx_104 = *((word32) dwArg04 + 40);
		*((word32) dwArg04 + 0x0C) = ecx_104;
	}
	*((word32) dwArg04 + 4) = eax_14;
	*dwArg04 = SEQ(edx_16_16_70, dh_50 & ~0x08, dl_68);
	*((word32) dwArg04 + 24) = eax_14;
	*((word32) dwArg04 + 16) = eax_14;
	eax_103 = 0x00;
	goto l08056465;
}

// 08056490: void _IO_free_backup_area(Stack Eq_2 dwArg04)
// Called from:
//      __new_fclose
//      _IO_new_file_seekoff
//      _IO_new_file_overflow
//      __underflow
//      __uflow
//      _IO_unsave_markers
void _IO_free_backup_area(Eq_2 dwArg04)
{
	word32 edx_23 = *dwArg04;
	byte dh_25 = SLICE(edx_23, byte, 8);
	byte dl_33 = (byte) edx_23;
	word16 edx_16_16_34 = SLICE(edx_23, word16, 16);
	Eq_2 eax_24 = *((word32) dwArg04 + 36);
	if ((dh_25 & 0x01) != 0x00)
	{
		*((word32) dwArg04 + 4) = eax_24;
		*dwArg04 = SEQ(edx_16_16_34, dh_25 & ~0x01, dl_33);
		*((word32) dwArg04 + 8) = *((word32) dwArg04 + 44);
		Eq_2 edx_39 = *((word32) dwArg04 + 0x0C);
		*((word32) dwArg04 + 0x0C) = eax_24;
		eax_24 = edx_39;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_79;
	word32 edx_80;
	free(gs, stackArg0, eax_24, out ecx_79, out edx_80);
	((word32) dwArg04 + 36)->u0 = 0x00;
	((word32) dwArg04 + 44)->u0 = 0x00;
	*((word32) dwArg04 + 40) = 0x00;
}

// 080564F0: Register word32 __overflow(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_13264) ecxOut, Register out (ptr32 Eq_13265) edxOut)
// Called from:
//      _IO_puts
//      _IO_helper_overflow
//      printf_positional
//      __printf_fp_l
//      __printf_fphex
word32 __overflow(Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_13264 & ecxOut, struct Eq_13265 & edxOut)
{
	if (*((word32) dwArg04 + 0x0068) == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	Eq_2 esi_24 = *((word32) dwArg04 + 0x0094);
	if (esi_24 >= 135066356)
	{
		word32 ecx_78;
		word32 edx_79;
		_IO_vtable_check(out ecx_78, out edx_79);
	}
	word32 eax_53;
	struct Eq_13265 * edx_54;
	struct Eq_13264 * ecx_55;
	(*((word32) esi_24 + 0x0C))();
	ecxOut = ecx_55;
	edxOut = edx_54;
	return eax_53;
}

// 08056550: Register word32 __underflow(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      _IO_file_xsgetn
//      _IO_default_xsgetn
//      _IO_getdelim
word32 __underflow(Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	word32 eax_109;
	Eq_2 eax_16 = *((word32) dwArg04 + 0x0068);
	if (eax_16 == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	else if (eax_16 != ~0x00)
		goto l08056609;
	if ((*dwArg04 & 0x0800) != 0x00 && _IO_switch_to_get_mode(dwArg04, out ecx) == ~0x00)
	{
l08056609:
		eax_109 = ~0x00;
l0805662B:
		ecxOut = ecx;
		return eax_109;
	}
	Eq_2 eax_45 = *((word32) dwArg04 + 4);
	Eq_2 edx_46 = *((word32) dwArg04 + 8);
	if (eax_45 >= edx_46)
	{
		ui32 eax_49 = *dwArg04;
		byte ah_50 = SLICE(eax_49, byte, 8);
		byte al_57 = (byte) eax_49;
		word16 eax_16_16_58 = SLICE(eax_49, word16, 16);
		if ((ah_50 & 0x01) == 0x00)
		{
l080565BA:
			if (*((word32) dwArg04 + 48) == 0x00)
			{
				if (*((word32) dwArg04 + 36) != 0x00)
					_IO_free_backup_area(dwArg04);
				goto l080565CF;
			}
			if (save_for_backup(dwArg04, *((word32) dwArg04 + 8), out ecx) == 0x00)
			{
l080565CF:
				Eq_2 edi_123 = *((word32) dwArg04 + 0x0094);
				if (edi_123 >= 135066356)
				{
					word32 ecx_247;
					word32 edx_248;
					_IO_vtable_check(out ecx_247, out edx_248);
				}
				word32 eax_150;
				word32 edx_151;
				Eq_2 ecx_152;
				(*((word32) edi_123 + 16))();
				ecxOut = ecx_152;
				return eax_150;
			}
			goto l08056609;
		}
		ecx = *((word32) dwArg04 + 44);
		*((word32) dwArg04 + 44) = edx_46;
		*dwArg04 = SEQ(eax_16_16_58, ah_50 & ~0x01, al_57);
		Eq_2 edx_61 = *((word32) dwArg04 + 0x0C);
		eax_45 = *((word32) dwArg04 + 36);
		*((word32) dwArg04 + 8) = ecx;
		*((word32) dwArg04 + 36) = edx_61;
		*((word32) dwArg04 + 0x0C) = eax_45;
		*((word32) dwArg04 + 4) = eax_45;
		if (ecx <= eax_45)
			goto l080565BA;
	}
	eax_109 = (word32) *eax_45;
	goto l0805662B;
}

// 08056660: Register word32 __uflow(Stack Eq_2 dwArg04)
// Called from:
//      _IO_getline_info
word32 __uflow(Eq_2 dwArg04)
{
	word32 eax_111;
	Eq_2 eax_16 = *((word32) dwArg04 + 0x0068);
	if (eax_16 == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	else if (eax_16 != ~0x00)
		goto l08056719;
	if ((*dwArg04 & 0x0800) != 0x00)
	{
		word32 ecx_247;
		if (_IO_switch_to_get_mode(dwArg04, out ecx_247) == ~0x00)
			goto l08056719;
	}
	Eq_2 eax_45 = *((word32) dwArg04 + 4);
	Eq_2 edx_46 = *((word32) dwArg04 + 8);
	if (eax_45 >= edx_46)
	{
		ui32 eax_49 = *dwArg04;
		byte ah_50 = SLICE(eax_49, byte, 8);
		byte al_57 = (byte) eax_49;
		word16 eax_16_16_58 = SLICE(eax_49, word16, 16);
		if ((ah_50 & 0x01) == 0x00)
		{
l080566CA:
			if (*((word32) dwArg04 + 48) == 0x00)
			{
				if (*((word32) dwArg04 + 36) != 0x00)
					_IO_free_backup_area(dwArg04);
				goto l080566DF;
			}
			word32 ecx_248;
			if (save_for_backup(dwArg04, *((word32) dwArg04 + 8), out ecx_248) == 0x00)
			{
l080566DF:
				Eq_2 edi_125 = *((word32) dwArg04 + 0x0094);
				if (edi_125 >= 135066356)
				{
					word32 edx_250;
					word32 ecx_249;
					_IO_vtable_check(out ecx_249, out edx_250);
				}
				word32 eax_152;
				word32 edx_153;
				word32 ecx_154;
				(*((word32) edi_125 + 20))();
				return eax_152;
			}
l08056719:
			eax_111 = ~0x00;
			return eax_111;
		}
		Eq_2 ecx_55 = *((word32) dwArg04 + 44);
		*((word32) dwArg04 + 44) = edx_46;
		*dwArg04 = SEQ(eax_16_16_58, ah_50 & ~0x01, al_57);
		Eq_2 edx_61 = *((word32) dwArg04 + 0x0C);
		eax_45 = *((word32) dwArg04 + 36);
		*((word32) dwArg04 + 8) = ecx_55;
		*((word32) dwArg04 + 36) = edx_61;
		*((word32) dwArg04 + 0x0C) = eax_45;
		if (ecx_55 <= eax_45)
		{
			*((word32) dwArg04 + 4) = eax_45;
			goto l080566CA;
		}
	}
	*((word32) dwArg04 + 4) = (word32) eax_45 + 1;
	eax_111 = (word32) *eax_45;
	return eax_111;
}

// 08056770: void _IO_setb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      decide_maybe_mmap
//      _IO_file_close_it
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_init_static_internal
//      _IO_file_doallocate
void _IO_setb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	ui32 eax_15 = *dwArg04;
	Eq_2 edx_14 = *((word32) dwArg04 + 28);
	byte al_19 = (byte) eax_15;
	if (edx_14 != 0x00 && (al_19 & 0x01) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_84;
		word32 edx_85;
		free(gs, stackArg0, edx_14, out ecx_84, out edx_85);
		eax_15 = (ui32) *dwArg04;
	}
	*((word32) dwArg04 + 28) = dwArg08;
	*((word32) dwArg04 + 32) = dwArg0C;
	ui32 eax_44 = eax_15 | 0x01;
	ui32 edx_45 = eax_15 & ~0x01;
	if (dwArg10 != 0x00)
		eax_44 = edx_45;
	*dwArg04 = eax_44;
}

// 080567D0: Register word32 _IO_doallocbuf(Stack Eq_2 dwArg04, Register out (ptr32 Eq_14152) ebpOut, Register out (ptr32 Eq_14153) esiOut, Register out (ptr32 Eq_14154) ediOut)
// Called from:
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_overflow
//      _IO_new_file_underflow
//      _IO_new_file_seekoff
//      _IO_file_xsgetn
//      _IO_new_file_overflow
word32 _IO_doallocbuf(Eq_2 dwArg04, struct Eq_14152 & ebpOut, struct Eq_14153 & esiOut, struct Eq_14154 & ediOut)
{
	if (*((word32) dwArg04 + 28) != 0x00)
		return;
	ui32 eax_24 = *dwArg04;
	if (((byte) eax_24 & 0x02) == 0x00 || *((word32) dwArg04 + 0x0068) > 0x00)
	{
		Eq_2 edi_36 = *((word32) dwArg04 + 0x0094);
		if (edi_36 >= 135066356)
		{
			word32 ecx_181;
			word32 edx_182;
			_IO_vtable_check(out ecx_181, out edx_182);
		}
		word32 eax_63;
		word32 edx_64;
		(*((word32) edi_36 + 52))();
		if (eax_63 != ~0x00)
			return;
		eax_24 = (ui32) *dwArg04;
		Eq_2 edx_69 = *((word32) dwArg04 + 28);
		byte al_76 = (byte) eax_24;
		if (edx_69 != 0x00 && (al_76 & 0x01) == 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_185;
			word32 edx_186;
			free(gs, stackArg0, edx_69, out ecx_185, out edx_186);
			eax_24 = (ui32) *dwArg04;
		}
	}
	*((word32) dwArg04 + 28) = (word32) dwArg04 + 71;
	*((word32) dwArg04 + 32) = (word32) dwArg04 + 72;
	*dwArg04 = eax_24 | 0x01;
	return;
}

// 08056890: void _IO_default_underflow()
void _IO_default_underflow()
{
}

// 080568A0: void _IO_default_uflow(Stack (ptr32 Eq_24796) dwArg04)
void _IO_default_uflow(struct Eq_24796 * dwArg04)
{
	struct Eq_24797 * esi_16 = dwArg04->ptr0094;
	if (esi_16 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 ecx_73;
		word32 edx_74;
		_IO_vtable_check(out ecx_73, out edx_74);
	}
	word32 eax_38;
	esi_16->ptr0010();
	if (eax_38 != ~0x00)
		++dwArg04->dw0004;
}

// 08056900: Register Eq_2 _IO_default_xsputn(Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _IO_file_xsputn
Eq_2 _IO_default_xsputn(Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 esp_175 = fp - 44;
	Eq_2 ecx_110 = dwArg08;
	if (dwArg0C == 0x00)
		return 0x00;
	Eq_2 ebp_117 = dwArg0C;
	while (true)
	{
		struct Eq_24961 * eax_47 = *((word32) esp_175 + 48);
		Eq_2 edi_102 = eax_47->t0014;
		Eq_2 eax_49 = eax_47->t0018;
		if (edi_102 < eax_49)
		{
			Eq_2 eax_52 = eax_49 - edi_102;
			if (ebp_117 <= eax_52)
				eax_52 = ebp_117;
			Eq_2 edx_116 = eax_52;
			if (eax_52 <= 0x14)
			{
				if (eax_52 != 0x00)
				{
					word32 eax_93 = edi_102 + eax_52;
					Eq_2 esi_101 = ecx_110;
					do
					{
						*edi_102 = *esi_101;
						esi_101 = (word32) esi_101 + 1;
						edi_102 = (word32) edi_102 + 1;
					} while (edi_102 != eax_93);
					*((word32) *((word32) esp_175 + 48) + 20) = edi_102;
					ecx_110 += eax_52;
				}
			}
			else
			{
				struct Eq_24844 * esp_62 = esp_175 - 0x04;
				esp_62->tFFFFFFFC = eax_52;
				esp_62->t0010 = eax_52;
				esp_62->tFFFFFFF8 = ecx_110;
				esp_62->t0038 = ecx_110;
				esp_62->tFFFFFFF4 = edi_102;
				word32 edx_281;
				Eq_2 eax_75 = __mempcpy(esp_62->tFFFFFFF4, esp_62->tFFFFFFF8, esp_62->tFFFFFFFC, out edx_281);
				Eq_2 ecx_84 = esp_62->t0038;
				edx_116 = esp_62->t0010;
				esp_62->ptr0034->t0014 = eax_75;
				ecx_110 = ecx_84 + edx_116;
			}
			ebp_117 -= edx_116;
		}
		Eq_2 esp_123 = esp_175;
		if (ebp_117 == 0x00)
			break;
		struct Eq_24896 * esi_129 = *((word32) *((word32) esp_175 + 48) + 0x0094);
		if (*((word32) esp_175 + 8) <= esi_129 - *((word32) esp_175 + 4))
		{
			*((word32) esp_175 + 52) = ecx_110;
			word32 edx_283;
			word32 ecx_282;
			_IO_vtable_check(out ecx_282, out edx_283);
			esp_123.u0 = <invalid>;
			ecx_110 = *((word64) esp_123.u0 + 52);
		}
		word32 eax_147 = (word32) *ecx_110;
		struct Eq_24928 * esp_149 = esp_123 - 0x08;
		esp_149->dwFFFFFFFC = eax_147;
		esp_149->dwFFFFFFF8 = esp_149->dw0038;
		word32 eax_171;
		word32 edx_173;
		esi_129->ptr000C();
		Eq_2 edi_151 = (word32) ecx_110 + 1;
		esp_175 = &esp_149->dwFFFFFFFC + 3;
		if (eax_171 == ~0x00)
		{
			esp_149->dw0040 -= ebp_117;
			return dwArg0C;
		}
		--ebp_117;
		ecx_110 = edi_151;
	}
	return dwArg0C;
}

// 08056A40: void _IO_sgetn(Stack (ptr32 Eq_24990) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void _IO_sgetn(struct Eq_24990 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_24993 * ebx_25 = dwArg04->ptr0094;
	if (ebx_25 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_83;
		word32 ecx_82;
		_IO_vtable_check(out ecx_82, out edx_83);
	}
	ebx_25->ptr0020();
}

// 08056AB0: void _IO_default_xsgetn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void _IO_default_xsgetn(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 ebx_142 = dwArg08;
	Eq_2 ecx_123 = dwArg0C;
	do
	{
		Eq_2 esi_27 = *((word32) dwArg04 + 4);
		Eq_2 ebp_28 = *((word32) dwArg04 + 8);
		if (esi_27 < ebp_28)
		{
			Eq_2 ebp_31 = ebp_28 - esi_27;
			if (ecx_123 <= ebp_31)
				ebp_31 = ecx_123;
			if (ebp_31 <= 0x14)
			{
				if (ebp_31 != 0x00)
				{
					word32 eax_75 = esi_27 + ebp_31;
					Eq_2 edi_76 = ebx_142;
					Eq_2 esi_77 = esi_27;
					do
					{
						*edi_76 = *esi_77;
						esi_77 = (word32) esi_77 + 1;
						edi_76 = (word32) edi_76 + 1;
					} while (eax_75 != esi_77);
					*((word32) dwArg04 + 4) = eax_75;
					ebx_142 += ebp_31;
				}
			}
			else
			{
				word32 edx_217;
				ebx_142 = __mempcpy(ebx_142, esi_27, ebp_31, out edx_217);
				Mem70[dwArg04 + 0x04:word32] = Mem55[dwArg04 + 0x04:word32] + ebp_31;
			}
			ecx_123 -= ebp_31;
		}
		if (ecx_123 == 0x00)
			return;
		word32 ecx_216;
	} while (__underflow(dwArg04, out ecx_216) != ~0x00);
}

// 08056B80: Register Eq_2 _IO_default_setbuf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _IO_new_file_setbuf
//      _IO_file_setbuf_mmap
Eq_2 _IO_default_setbuf(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 esp_18 = fp - 0x1C;
	Eq_2 ebp_21 = *((word32) dwArg04 + 0x0094);
	if (ebp_21 >= 135066356)
	{
		word32 ecx_216;
		word32 edx_217;
		_IO_vtable_check(out ecx_216, out edx_217);
		esp_18.u0 = <invalid>;
	}
	Eq_2 eax_147;
	struct Eq_25086 * esp_37 = esp_18 - 0x0C;
	esp_37->tFFFFFFFC = dwArg04;
	word32 eax_47;
	(*((word32) ebp_21 + 48))();
	if (eax_47 != ~0x00)
	{
		ui32 eax_56 = *dwArg04;
		byte al_77 = (byte) eax_56;
		Eq_2 ecx_57 = *((word32) dwArg04 + 28);
		if (dwArg08 != 0x00 && esp_37->dw0034 != 0x00)
		{
			word32 ebp_110 = esp_37->dw0034;
			*dwArg04 = eax_56 & ~0x02;
			ui32 edx_111 = eax_56 & ~0x02;
			Eq_2 ebp_113 = (word32) dwArg08 + ebp_110;
			if (ecx_57 != 0x00 && (al_77 & 0x01) == 0x00)
			{
				esp_37->tFFFFFFFC = ecx_57;
				word32 ecx_218;
				word32 edx_219;
				free(gs, esp_37->tFFFFFFF8, esp_37->tFFFFFFFC, out ecx_218, out edx_219);
				edx_111 = (ui32) *dwArg04;
			}
			*((word32) dwArg04 + 28) = dwArg08;
			*((word32) dwArg04 + 32) = ebp_113;
			*dwArg04 = edx_111 | 0x01;
		}
		else
		{
			*dwArg04 = eax_56 | 0x02;
			ui32 edx_100 = eax_56 | 0x02;
			if (ecx_57 != 0x00 && (al_77 & 0x01) == 0x00)
			{
				esp_37->tFFFFFFFC = ecx_57;
				word32 ecx_220;
				word32 edx_221;
				free(gs, esp_37->tFFFFFFF8, esp_37->tFFFFFFFC, out ecx_220, out edx_221);
				edx_100 = (ui32) *dwArg04;
			}
			*((word32) dwArg04 + 28) = (word32) dwArg04 + 71;
			*((word32) dwArg04 + 32) = (word32) dwArg04 + 72;
			*dwArg04 = edx_100 | 0x01;
		}
		((word32) dwArg04 + 24)->u0 = 0x00;
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 16)->u0 = 0x00;
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 4)->u0 = 0x00;
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
		eax_147 = dwArg04;
	}
	else
		eax_147.u0 = 0x00;
	return eax_147;
}

// 08056CA0: void _IO_default_seekpos(Stack (ptr32 Eq_25234) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
void _IO_default_seekpos(struct Eq_25234 * dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	struct Eq_25238 * ebx_25 = dwArg04->ptr0094;
	if (ebx_25 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_97;
		word32 ecx_96;
		_IO_vtable_check(out ecx_96, out edx_97);
	}
	ebx_25->ptr0024();
}

// 08056D00: void _IO_default_doallocate(Register Eq_2 ebx, Register (ptr32 Eq_9) gs)
void _IO_default_doallocate(Eq_2 ebx, struct Eq_9 * gs)
{
	struct Eq_25255 * esi_27;
	word32 ecx_125;
	word32 ebp_128;
	word32 ebx_127;
	word32 edx_126;
	word32 edi_129;
	Eq_2 eax_21 = __libc_malloc(gs, dwLoc30, 0x2000, out ecx_125, out edx_126, out ebx_127, out ebp_128, out esi_27, out edi_129);
	if (eax_21 == 0x00)
		return;
	Eq_2 eax_71;
	ui32 edx_47 = esi_27->dw0000;
	Eq_2 ecx_45 = esi_27->t001C;
	byte dl_51 = (byte) edx_47;
	eax_71 = eax_21;
	if (ecx_45 != 0x00)
	{
		eax_71 = eax_21;
		if ((dl_51 & 0x01) == 0x00)
		{
			word32 ecx_130;
			word32 edx_131;
			free(gs, dwLoc30, ecx_45, out ecx_130, out edx_131);
			edx_47 = esi_27->dw0000;
			eax_71 = ebx;
		}
	}
	esi_27->t001C = eax_71;
	esi_27->dw0020 = (word32) eax_21 + 0x00002000;
	esi_27->dw0000 = edx_47 & ~0x01;
}

// 08056D80: void _IO_enable_locks()
void _IO_enable_locks()
{
	if (stdio_needs_locking == 0x00)
	{
		stdio_needs_locking = 0x01;
		Eq_2 eax_12 = _IO_list_all;
		while (eax_12 != 0x00)
		{
			*((word32) eax_12 + 60) |= 0x80;
			eax_12 = *((word32) eax_12 + 52);
		}
	}
}

// 08056DC0: void _IO_old_init(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
// Called from:
//      _IO_init_internal
//      _IO_init
//      _IO_no_init
void _IO_old_init(Eq_2 dwArg04, ui32 dwArg08)
{
	((word32) dwArg04 + 60)->u0 = 0x00;
	*dwArg04 = dwArg08 | 0xFBAD0000;
	if (stdio_needs_locking != 0x00)
		((word32) dwArg04 + 60)->u0 = 0x80;
	((word32) dwArg04 + 28)->u0 = 0x00;
	((word32) dwArg04 + 32)->u0 = 0x00;
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	((word32) dwArg04 + 4)->u0 = 0x00;
	((word32) dwArg04 + 8)->u0 = 0x00;
	((word32) dwArg04 + 16)->u0 = 0x00;
	((word32) dwArg04 + 20)->u0 = 0x00;
	((word32) dwArg04 + 24)->u0 = 0x00;
	((word32) dwArg04 + 52)->u0 = 0x00;
	((word32) dwArg04 + 36)->u0 = 0x00;
	*((word32) dwArg04 + 40) = 0x00;
	*((word32) dwArg04 + 44) = 0x00;
	((word32) dwArg04 + 48)->u0 = 0x00;
	((word32) dwArg04 + 0x0044)->u4 = 0x00;
	Eq_2 eax_34 = *((word32) dwArg04 + 72);
	if (eax_34 != 0x00)
	{
		*eax_34 = 0x00;
		((word32) eax_34 + 4)->u0 = 0x00;
		((word32) eax_34 + 8)->u0 = 0x00;
	}
}

// 08056E80: void _IO_init_internal(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
void _IO_init_internal(Eq_2 dwArg04, ui32 dwArg08)
{
	_IO_old_init(dwArg04, dwArg08);
	((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	((word32) dwArg04 + 88)->u0 = ~0x00;
	((word32) dwArg04 + 92)->u0 = 0x00;
}

// 08056EB0: void _IO_init(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
void _IO_init(Eq_2 dwArg04, ui32 dwArg08)
{
	_IO_old_init(dwArg04, dwArg08);
	((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	((word32) dwArg04 + 88)->u0 = ~0x00;
	((word32) dwArg04 + 92)->u0 = 0x00;
}

// 08056EE0: void _IO_no_init(Stack Eq_2 dwArg04, Stack ui32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      __fopen_internal
//      vasprintf
void _IO_no_init(Eq_2 dwArg04, ui32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
	_IO_old_init(dwArg04, dwArg08);
	*((word32) dwArg04 + 0x0068) = dwArg0C;
	if (dwArg0C < 0x00)
	{
		((word32) dwArg04 + 88)->u0 = ~0x00;
		((word32) dwArg04 + 92)->u0 = 0x00;
	}
	else
	{
		*((word32) dwArg04 + 88) = dwArg10;
		((word32) dwArg10 + 24)->u0 = 0x00;
		((word32) dwArg10 + 28)->u0 = 0x00;
		((word32) dwArg10 + 8)->u0 = 0x00;
		dwArg10->u0 = 0x00;
		((word32) dwArg10 + 4)->u0 = 0x00;
		((word32) dwArg10 + 0x0C)->u0 = 0x00;
		((word32) dwArg10 + 16)->u0 = 0x00;
		((word32) dwArg10 + 20)->u0 = 0x00;
		((word32) dwArg10 + 32)->u0 = 0x00;
		((word32) dwArg10 + 36)->u0 = 0x00;
		((word32) dwArg10 + 40)->u0 = 0x00;
		*((word32) dwArg10 + 0x00B0) = dwArg14;
		((word32) dwArg04 + 92)->u0 = 0x00;
	}
}

// 08056F90: void _IO_default_sync()
void _IO_default_sync()
{
}

// 08056FA0: void _IO_default_finish(Stack Eq_2 dwArg04)
// Called from:
//      _IO_new_file_finish
//      _IO_str_finish
void _IO_default_finish(Eq_2 dwArg04)
{
	struct Eq_25533 * esp_12 = fp - 0x0C;
	if (*((word32) dwArg04 + 28) != 0x00 && (*dwArg04 & 0x01) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_125;
		word32 edx_126;
		free(gs, stackArg0, stackArg4, out ecx_125, out edx_126);
		((word32) dwArg04 + 32)->u0 = 0x00;
		((word32) dwArg04 + 28)->u0 = 0x00;
		esp_12 = fp - 0x08;
	}
	Eq_2 edx_32 = *((word32) dwArg04 + 48);
	while (edx_32 != 0x00)
	{
		((word32) edx_32 + 4)->u0 = 0x00;
		edx_32 = *edx_32;
	}
	Eq_2 eax_46 = *((word32) dwArg04 + 36);
	if (eax_46 != 0x00)
	{
		esp_12->tFFFFFFF0 = eax_46;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_120;
		word32 edx_121;
		free(gs, stackArg0, stackArg4, out ecx_120, out edx_121);
		((word32) dwArg04 + 36)->u0 = 0x00;
	}
	if ((*dwArg04 & 0x80) == 0x00)
		return;
	_IO_un_link.part.2(eax, gs);
}

// 08057040: void _IO_default_seekoff()
void _IO_default_seekoff()
{
}

// 08057050: void _IO_sputbackc(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _IO_getline_info
void _IO_sputbackc(Eq_2 dwArg04, Eq_2 dwArg08)
{
	byte al_20 = (byte) dwArg08;
	Eq_2 edx_17 = *((word32) dwArg04 + 4);
	if (edx_17 > *((word32) dwArg04 + 0x0C) && *((word32) edx_17 - 1) == al_20)
		*((word32) dwArg04 + 4) = edx_17 - 0x01;
	else
	{
		Eq_2 esi_29 = *((word32) dwArg04 + 0x0094);
		if (esi_29 >= 135066356)
		{
			word32 ecx_122;
			word32 edx_123;
			_IO_vtable_check(out ecx_122, out edx_123);
		}
		word32 eax_59;
		(*((word32) esi_29 + 24))();
		if (eax_59 == ~0x00)
			return;
	}
	*dwArg04 &= ~0x10;
}

// 080570D0: void _IO_sungetc(Stack (ptr32 Eq_25661) dwArg04)
void _IO_sungetc(struct Eq_25661 * dwArg04)
{
	up32 eax_14 = dwArg04->dw0004;
	if (eax_14 > dwArg04->dw000C)
		dwArg04->dw0004 = eax_14 - 0x01;
	else
	{
		struct Eq_25670 * esi_17 = dwArg04->ptr0094;
		if (esi_17 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 edx_105;
			word32 ecx_104;
			_IO_vtable_check(out ecx_104, out edx_105);
		}
		word32 eax_43;
		word32 ecx_44;
		esi_17->ptr0018();
		if (eax_43 == ~0x00)
			return;
	}
	dwArg04->dw0000 &= ~0x10;
}

// 08057150: Register word16 _IO_adjust_column(Stack word32 dwArg04, Stack (ptr32 Eq_18345) dwArg08, Stack (ptr32 Eq_18343) dwArg0C)
// Called from:
//      new_do_write
word16 _IO_adjust_column(word32 dwArg04, struct Eq_18345 * dwArg08, struct Eq_18343 * dwArg0C)
{
	word32 eax_9 = dwArg08 + dwArg0C;
	if (dwArg08 >= eax_9)
		return (word16) (dwArg0C + dwArg04 / 0x0098);
	struct Eq_18345 * edx_13 = eax_9 - 0x01;
	if (eax_9->bFFFFFFFF == 0x0A)
		return 0x00;
	do
	{
		if (dwArg08 == edx_13)
			return (word16) (dwArg0C + dwArg04 / 0x0098);
		--edx_13;
	} while (edx_13->b0000 != 0x0A);
	return (word16) (eax_9 - edx_13 - 0x01);
}

// 080571A0: Register Eq_2 _IO_flush_all_lockp(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      fflush
//      _IO_cleanup
Eq_2 _IO_flush_all_lockp(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_20 = gs->dw0014;
	Mem49 = Mem31;
	Eq_2 ecx_155 = ecx;
	Eq_2 edx_50 = gs->t0008;
	if (g_t80CF840 != edx_50)
	{
		ecx_155.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_62;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_62))
			ecx_155 = __lll_lock_wait_private(eax_62, 0x080CF838, gs);
		g_t80CF840 = edx_50;
	}
	Eq_2 eax_272 = g_t80CF83C;
	Eq_2 esi_100 = _IO_list_all;
	g_t80CF83C = (word32) eax_272 + 1;
	Eq_2 edx_151 = (word32) eax_272 + 1;
	if (esi_100 != 0x00)
	{
		Eq_2 eax_88 = gs->t0008;
		ecx_155.u0 = 0x080CEFA0;
		do
		{
			run_fp = esi_100;
			if (dwArg04 != 0x00)
			{
				ui32 eax_107 = *esi_100;
				if ((eax_107 & 0x8000) == 0x00)
				{
					Eq_2 edx_112 = *((word32) esi_100 + 72);
					if (*((word32) edx_112 + 8) != eax_88)
					{
						if (gs->t000C != 0x00)
							__lock();
						word32 eax_125;
						if (!__cmpxchg(*edx_112, 0x01, eax_107 & 0x8000, out eax_125))
							__lll_lock_wait_private(eax_125, edx_112, gs);
						edx_112 = *((word32) esi_100 + 72);
						*((word32) edx_112 + 8) = eax_88;
					}
					*((word32) edx_112 + 4) = (word32) *((word32) edx_112 + 4) + 1;
					ecx_155 = eax_88;
				}
			}
			Eq_2 ecx_219;
			edx_151 = *((word32) esi_100 + 0x0068);
			if (edx_151 <= 0x00)
			{
				if (*((word32) esi_100 + 20) <= *((word32) esi_100 + 16))
					goto l080572A8;
				goto l0805727B;
			}
			Eq_2 eax_154 = *((word32) esi_100 + 88);
			ecx_155 = *((word32) eax_154 + 0x0C);
			if (*((word32) eax_154 + 16) > ecx_155)
			{
l0805727B:
				Eq_2 eax_163 = *((word32) esi_100 + 0x0094);
				if (eax_163 >= 135066356)
				{
					word32 ecx_609;
					word32 edx_610;
					_IO_vtable_check(out ecx_609, out edx_610);
				}
				word32 eax_217;
				(*((word32) eax_163 + 0x0C))();
				ecx_155 = ecx_219;
				if (eax_217 == ~0x00)
					ecx_155 = ecx_219;
			}
l080572A8:
			if (dwArg04 != 0x00 && (*esi_100 & 0x8000) == 0x00)
			{
				edx_151 = *((word32) esi_100 + 72);
				Eq_2 v16_236 = *((word32) edx_151 + 4) - 0x01;
				*((word32) edx_151 + 4) = v16_236;
				if (v16_236 == 0x00)
				{
					((word32) edx_151 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v17_246 = *edx_151 - 0x01;
					*edx_151 = v17_246;
					if (v17_246 != 0x00)
						__lll_unlock_wake_private(edx_151, ecx_155, edx_151, gs);
				}
			}
			run_fp.u0 = 0x00;
			esi_100 = *((word32) esi_100 + 52);
		} while (esi_100 != 0x00);
		eax_272 = g_t80CF83C - 0x01;
	}
	g_t80CF83C = eax_272;
	if (eax_272 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v18_288 = g_t80CF838 - 0x01;
		g_t80CF838 = v18_288;
		if (v18_288 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_155, edx_151, gs);
	}
	if ((eax_20 ^ gs->dw0014) == 0x00)
		return ecx_155;
	word32 ecx_611;
	word32 edx_612;
	__stack_chk_fail(out ecx_611, out edx_612);
	return _IO_cleanup(gs);
}

// 08057410: Register Eq_2 _IO_cleanup(Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_flush_all_lockp
Eq_2 _IO_cleanup(struct Eq_9 * gs)
{
	ui32 eax_20 = gs->dw0014;
	Eq_2 ecx_29 = _IO_flush_all_lockp(ecx, gs, 0x00);
	Mem57 = Mem39;
	Eq_2 ecx_280 = ecx_29;
	struct Eq_26014 * esp_122 = fp - 0x5C;
	Eq_2 edx_58 = gs->t0008;
	if (edx_58 != g_t80CF840)
	{
		ecx_280.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_70;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_70))
			ecx_280 = __lll_lock_wait_private(eax_70, 0x080CF838, gs);
		g_t80CF840 = edx_58;
	}
	Eq_2 eax_348 = g_t80CF83C;
	Eq_2 esi_107 = _IO_list_all;
	g_t80CF83C = (word32) eax_348 + 1;
	Eq_2 edx_114 = (word32) eax_348 + 1;
	if (esi_107 != 0x00)
	{
		ecx_280.u0 = 0x080CEFA0;
		do
		{
			ui32 ebp_109 = *esi_107;
			ui32 ebp_110 = ebp_109 & 0x02;
			if ((ebp_109 & 0x02) == 0x00)
			{
				edx_114 = *((word32) esi_107 + 0x0068);
				if (edx_114 == 0x00)
					goto l080574E8;
				Eq_2 edx_118 = *((word32) esi_107 + 72);
				if (edx_118 != 0x00)
				{
					if (*((word32) edx_118 + 8) != esp_122[3])
					{
						if (gs->t000C != 0x00)
							__lock();
						ui32 eax_135;
						__cmpxchg(*edx_118, 0x01, ebp_109 & 0x02, out eax_135);
						esp_122[5] = (struct Eq_26014) 0x01;
						ebp_110 = eax_135;
						if (eax_135 != 0x00)
						{
							sched_yield(gs);
							++esp_122;
							edx_118 = *((word32) esi_107 + 72);
							ebp_110 = 0x01;
							Eq_2 ecx_154 = esp_122[5];
							if (edx_118 == 0x00)
								goto l08057583;
							if (esp_122[3] != *((word32) edx_118 + 8))
							{
								if (gs->t000C != 0x00)
									__lock();
								word32 eax_174;
								__cmpxchg(*edx_118, ecx_154, 0x00, out eax_174);
								if (eax_174 != 0x00)
								{
									sched_yield(gs);
									++esp_122;
									ebp_110 = 0x02;
									goto l08057583;
								}
								ebp_110 = 0x01;
								goto l08057705;
							}
							ebp_110 = 0x01;
							goto l080576ED;
						}
l08057705:
						Eq_2 eax_183 = *((word32) esi_107 + 72);
						Eq_2 ecx_186 = esp_122[3];
						((word32) eax_183 + 4)->u0 = 0x01;
						*((word32) eax_183 + 8) = ecx_186;
					}
					else
					{
l080576ED:
						*((word32) edx_118 + 4) = (word32) *((word32) edx_118 + 4) + 1;
					}
				}
l08057583:
				if (g_b80CF82C == 0x00)
				{
					ui32 eax_209 = *esi_107;
					if (((byte) eax_209 & 0x01) == 0x00)
					{
						*esi_107 = eax_209 | 0x01;
						Eq_2 eax_218 = freeres_list;
						freeres_list = esi_107;
						*((word32) esi_107 + 92) = eax_218;
						*((word32) esi_107 + 96) = *((word32) esi_107 + 28);
					}
				}
				Eq_2 eax_225 = *((word32) esi_107 + 0x0094);
				if (esp_122[7] <= eax_225 - esp_122[6])
				{
					esp_122[5] = (struct Eq_26014) eax_225;
					word32 edx_652;
					word32 ecx_651;
					_IO_vtable_check(out ecx_651, out edx_652);
					eax_225 = esp_122[5];
				}
				struct Eq_26253 * esp_263 = esp_122 - 0x04;
				esp_263->dwFFFFFFFC = 0x00;
				esp_263->dwFFFFFFF8 = 0x00;
				esp_263->tFFFFFFF4 = esi_107;
				(*((word32) eax_225 + 44))();
				if (*((word32) esi_107 + 0x0068) > 0x00)
				{
					esp_263->dw0000 = 0x00;
					esp_263->dwFFFFFFFC = 0x00;
					esp_263->dwFFFFFFF8 = 0x00;
					esp_263->tFFFFFFF4 = esi_107;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 stackArg8 = <invalid>;
					Eq_2 stackArg12 = <invalid>;
					Eq_2 stackArg16 = <invalid>;
					ecx_280 = _IO_wsetb(stackArg4, stackArg8, stackArg12, stackArg16, out edx_114);
				}
				if (ebp_110 != 0x02)
				{
					edx_114 = *((word32) esi_107 + 72);
					if (edx_114 != 0x00)
					{
						Eq_2 v19_309 = *((word32) edx_114 + 4) - 0x01;
						*((word32) edx_114 + 4) = v19_309;
						if (v19_309 == 0x00)
						{
							((word32) edx_114 + 8)->u0 = 0x00;
							if (gs->t000C != 0x00)
								__lock();
							Eq_2 v20_325 = *edx_114 - 0x01;
							*edx_114 = v20_325;
							if (v20_325 != 0x00)
								__lll_unlock_wake_private(edx_114, ecx_280, edx_114, gs);
							((word32) esi_107 + 0x0068)->u0 = ~0x00;
							esi_107 = *((word32) esi_107 + 52);
							if (esi_107 == 0x00)
								break;
							continue;
						}
					}
				}
			}
l080574E8:
			((word32) esi_107 + 0x0068)->u0 = ~0x00;
			esi_107 = *((word32) esi_107 + 52);
		} while (esi_107 != 0x00);
		eax_348 = g_t80CF83C - 0x01;
	}
	g_t80CF83C = eax_348;
	if (eax_348 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_365 = g_t80CF838 - 0x01;
		g_t80CF838 = v15_365;
		if (v15_365 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_280, edx_114, gs);
	}
	if ((eax_20 ^ gs->dw0014) == 0x00)
		return ecx_280;
	word32 edx_650;
	Eq_2 ecx_469;
	__stack_chk_fail(out ecx_469, out edx_650);
	_IO_flush_all();
	return ecx_469;
}

// 08057720: void _IO_flush_all()
// Called from:
//      fflush
//      _IO_cleanup
void _IO_flush_all()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	_IO_flush_all_lockp(ecx, gs, stackArg4);
}

// 08057740: void _flushlbf(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _flushlbf(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 eax_20 = gs->dw0014;
	Mem48 = Mem30;
	Eq_2 ecx_110 = ecx;
	Eq_2 esp_158 = fp - 0x4C;
	Eq_2 edx_49 = gs->t0008;
	if (g_t80CF840 != edx_49)
	{
		ecx_110.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_61;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_61))
			ecx_110 = __lll_lock_wait_private(eax_61, 0x080CF838, gs);
		g_t80CF840 = edx_49;
	}
	Eq_2 eax_246 = g_t80CF83C;
	Eq_2 esi_241 = _IO_list_all;
	g_t80CF83C = (word32) eax_246 + 1;
	Eq_2 edx_106 = (word32) eax_246 + 1;
	if (esi_241 != 0x00)
	{
		Eq_2 ebp_88 = gs->t0008;
		do
		{
			Eq_2 ecx_203;
			ui32 edx_98 = *esi_241;
			run_fp = esi_241;
			if ((edx_98 & 0x8000) != 0x00)
			{
				edx_106 = edx_98 & 0x0208;
				if ((edx_98 & 0x0208) == 0x0200)
					goto l0805789F;
			}
			else
			{
				edx_106 = *((word32) esi_241 + 72);
				if (*((word32) edx_106 + 8) != ebp_88)
				{
					ecx_110.u0 = 0x01;
					if (gs->t000C != 0x00)
						__lock();
					word32 eax_118;
					if (!__cmpxchg(*edx_106, 0x01, edx_98 & 0x8000, out eax_118))
						ecx_110 = __lll_lock_wait_private(eax_118, edx_106, gs);
					edx_106 = *((word32) esi_241 + 72);
					*((word32) edx_106 + 8) = ebp_88;
				}
				ui32 eax_137 = *esi_241;
				*((word32) edx_106 + 4) = (word32) *((word32) edx_106 + 4) + 1;
				if ((eax_137 & 0x0208) == 0x0200)
				{
l0805789F:
					Eq_2 eax_149 = *((word32) esi_241 + 0x0094);
					if (*((word32) esp_158 + 4) <= eax_149 - 0x080CEFA0)
					{
						*((word32) esp_158 + 0x0C) = eax_149;
						word32 ecx_548;
						word32 edx_549;
						_IO_vtable_check(out ecx_548, out edx_549);
						esp_158.u0 = <invalid>;
						eax_149 = *((word64) esp_158.u0 + 0x0C);
					}
					struct Eq_26468 * esp_174 = esp_158 - 0x08;
					esp_174->dwFFFFFFFC = ~0x00;
					esp_174->tFFFFFFF8 = esi_241;
					(*((word32) eax_149 + 0x0C))();
					esp_158 = &esp_174->dwFFFFFFFC + 3;
					ecx_110 = ecx_203;
				}
				if ((*esi_241 & 0x8000) == 0x00)
				{
					edx_106 = *((word32) esi_241 + 72);
					Eq_2 v16_213 = *((word32) edx_106 + 4) - 0x01;
					*((word32) edx_106 + 4) = v16_213;
					if (v16_213 == 0x00)
					{
						((word32) edx_106 + 8)->u0 = 0x00;
						if (gs->t000C != 0x00)
							__lock();
						Eq_2 v17_223 = *edx_106 - 0x01;
						*edx_106 = v17_223;
						if (v17_223 != 0x00)
							__lll_unlock_wake_private(edx_106, ecx_110, edx_106, gs);
					}
				}
			}
			run_fp.u0 = 0x00;
			esi_241 = *((word32) esi_241 + 52);
		} while (esi_241 != 0x00);
		eax_246 = g_t80CF83C - 0x01;
	}
	g_t80CF83C = eax_246;
	if (eax_246 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v19_261 = g_t80CF838 - 0x01;
		g_t80CF838 = v19_261;
		if (v19_261 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx_110, edx_106, gs);
	}
	if ((eax_20 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_551;
	word32 ecx_550;
	__stack_chk_fail(out ecx_550, out edx_551);
	_IO_init_marker(dwArg04, dwArg08);
}

// 08057970: void _IO_init_marker(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _flushlbf
void _IO_init_marker(Eq_2 dwArg04, Eq_2 dwArg08)
{
	byte dh_15 = *((word32) dwArg08 + 1);
	*((word32) dwArg04 + 4) = dwArg08;
	if ((dh_15 & 0x08) != 0x00)
	{
		word32 ecx_89;
		_IO_switch_to_get_mode(dwArg08, out ecx_89);
		dh_15 = (byte) *((word32) dwArg08 + 1);
	}
	Eq_2 eax_43;
	Eq_2 eax_36 = *((word32) dwArg08 + 4);
	if ((dh_15 & 0x01) != 0x00)
		eax_43 = eax_36 - *((word32) dwArg08 + 8);
	else
		eax_43 = eax_36 - *((word32) dwArg08 + 0x0C);
	*((word32) dwArg04 + 8) = eax_43;
	*dwArg04 = *((word32) dwArg08 + 48);
	*((word32) dwArg08 + 48) = dwArg04;
}

// 080579D0: void _IO_remove_marker(Stack (ptr32 Eq_26655) dwArg04)
void _IO_remove_marker(struct Eq_26655 * dwArg04)
{
	struct Eq_26656 * eax_6 = dwArg04->ptr0004;
	struct Eq_26655 * edx_13 = eax_6->ptr0030;
	if (edx_13 == null)
		return;
	if (dwArg04 != edx_13)
	{
		while (true)
		{
			struct Eq_26655 * eax_15 = edx_13->dw0000;
			if (eax_15 == null)
				break;
			if (dwArg04 == eax_15)
				goto l08057A00;
			edx_13 = eax_15;
		}
	}
	else
	{
		edx_13 = (struct Eq_26655 *) &eax_6->ptr0030;
l08057A00:
		edx_13->dw0000 = dwArg04->dw0000;
	}
}

// 08057A10: void _IO_marker_difference()
void _IO_marker_difference()
{
}

// 08057A30: void _IO_marker_delta(Stack (ptr32 Eq_26682) dwArg04)
void _IO_marker_delta(struct Eq_26682 * dwArg04)
{
	ui32 * eax_6 = dwArg04->ptr0004;
	if (eax_6 == null)
		return;
	if ((*eax_6 & 0x0100) != 0x00)
		;
}

// 08057A70: void _IO_seekmark(Stack (ptr32 Eq_26696) dwArg04, Stack (ptr32 Eq_26697) dwArg08)
void _IO_seekmark(struct Eq_26696 * dwArg04, struct Eq_26697 * dwArg08)
{
	if (dwArg08->ptr0004 == dwArg04)
	{
		word32 ebx_22;
		ui32 edx_16 = dwArg04->dw0000;
		int32 ecx_15 = dwArg08->dw0008;
		byte dh_26 = SLICE(edx_16, byte, 8);
		byte dl_31 = (byte) edx_16;
		word16 edx_16_16_32 = SLICE(edx_16, word16, 16);
		if (ecx_15 >= 0x00)
		{
			ebx_22 = dwArg04->dw000C;
			if ((edx_16 & 0x0100) != 0x00)
			{
				word32 esi_49 = dwArg04->dw002C;
				dwArg04->dw0000 = SEQ(edx_16_16_32, dh_26 & ~0x01, dl_31);
				word32 edx_52 = dwArg04->dw0008;
				dwArg04->dw0008 = esi_49;
				dwArg04->dw002C = edx_52;
				word32 edx_55 = dwArg04->dw0024;
				dwArg04->dw0024 = ebx_22;
				dwArg04->dw000C = edx_55;
				ebx_22 = edx_55;
			}
		}
		else
		{
			ebx_22 = dwArg04->dw0008;
			if ((edx_16 & 0x0100) == 0x00)
			{
				word32 esi_30 = dwArg04->dw0024;
				dwArg04->dw0000 = SEQ(edx_16_16_32, dh_26 | 0x01, dl_31);
				word32 edx_35 = dwArg04->dw002C;
				dwArg04->dw002C = ebx_22;
				word32 ebx_37 = dwArg04->dw000C;
				dwArg04->dw0008 = edx_35;
				dwArg04->dw0024 = ebx_37;
				dwArg04->dw000C = esi_30;
				ebx_22 = edx_35;
			}
		}
		dwArg04->dw0004 = ecx_15 + ebx_22;
	}
}

// 08057B00: void _IO_unsave_markers(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
//      _IO_new_file_seekoff
//      _IO_file_close_it
void _IO_unsave_markers(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 48) != 0x00)
		((word32) dwArg04 + 48)->u0 = 0x00;
	if (*((word32) dwArg04 + 36) == 0x00)
		return;
	_IO_free_backup_area(dwArg04);
}

// 08057B40: void _IO_default_pbackfail(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      _IO_str_pbackfail
void _IO_default_pbackfail(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 ecx_135;
	Eq_2 eax_119;
	ui32 edx_20 = *dwArg04;
	struct Eq_26821 * esp_18 = fp - 44;
	Eq_2 esi_125 = dwArg04;
	byte dh_158 = SLICE(edx_20, byte, 8);
	byte dl_168 = (byte) edx_20;
	word16 edx_16_16_172 = SLICE(edx_20, word16, 16);
	Eq_2 edi_138 = *((word32) dwArg04 + 4);
	Eq_2 ebp_22 = *((word32) dwArg04 + 0x0C);
	if (edi_138 > ebp_22)
	{
		if ((edx_20 & 0x0100) != 0x00)
			goto l08057B75;
		if ((word32) *((word32) edi_138 - 1) == dwArg08)
		{
			*((word32) dwArg04 + 4) = edi_138 - 0x01;
			return;
		}
		if (*((word32) dwArg04 + 36) != 0x00)
		{
			word32 ecx_280;
			if (save_for_backup(dwArg04, edi_138, out ecx_280) != 0x00)
				return;
			ui32 edx_155 = *dwArg04;
			ecx_135 = *((word32) dwArg04 + 4);
			dh_158 = SLICE(edx_155, byte, 8);
			dl_168 = (byte) edx_155;
			edx_16_16_172 = SLICE(edx_155, word16, 16);
			edi_138 = *((word32) dwArg04 + 44);
			eax_119 = *((word32) dwArg04 + 36);
			goto l08057C3C;
		}
	}
	else
	{
		if ((edx_20 & 0x0100) != 0x00)
		{
			Eq_2 edx_38 = *((word32) dwArg04 + 8) - ebp_22;
			Eq_2 ebp_47;
			Eq_2 edi_50;
			word32 edx_286;
			word32 ebx_287;
			word32 ecx_285;
			Eq_2 eax_46 = __libc_malloc(gs, dwLoc40, edx_38 * 0x02, out ecx_285, out edx_286, out ebx_287, out ebp_47, out esi_125, out edi_50);
			if (eax_46 == 0x00)
				return;
			edi_138 = (word32) eax_46 + (edi_50 - edx_38);
			word32 ecx_288;
			word32 edx_289;
			memcpy(edi_138, ebp_47, edx_38, out ecx_288, out edx_289);
			word32 ecx_290;
			word32 edx_291;
			free(gs, dwLoc40, ebp_47, out ecx_290, out edx_291);
			*((word32) esi_125 + 40) = edi_138;
			*((word32) esi_125 + 0x0C) = edi_50;
			*((word32) esi_125 + 8) = (word32) edi_50 + dwLoc1C;
			esp_18 = fp - 0x28;
l08057B75:
			*((word32) esi_125 + 4) = edi_138 - 0x01;
			*((word32) edi_138 - 1) = esp_18->b0034;
			return;
		}
		eax_119 = *((word32) dwArg04 + 36);
		if (eax_119 != 0x00)
		{
			ecx_135 = edi_138;
			edi_138 = *((word32) dwArg04 + 44);
			goto l08057C3C;
		}
	}
	Eq_2 edi_123;
	word32 edx_282;
	word32 ebx_283;
	word32 ebp_284;
	word32 ecx_281;
	eax_119 = __libc_malloc(gs, dwLoc40, 0x80, out ecx_281, out edx_282, out ebx_283, out ebp_284, out esi_125, out edi_123);
	if (eax_119 == 0x00)
		return;
	*((word32) esi_125 + 40) = (word32) eax_119 + 0x0080;
	ecx_135 = edi_123;
	dh_158 = SLICE(edx_20, byte, 8);
	dl_168 = (byte) edx_20;
	edx_16_16_172 = SLICE(edx_20, word16, 16);
	edi_138 = (word32) eax_119 + 0x0080;
l08057C3C:
	*((word32) esi_125 + 0x0C) = eax_119;
	*esi_125 = SEQ(edx_16_16_172, dh_158 | 0x01, dl_168);
	Eq_2 edx_178 = *((word32) esi_125 + 8);
	*((word32) esi_125 + 36) = ecx_135;
	*((word32) esi_125 + 8) = edi_138;
	*((word32) esi_125 + 44) = edx_178;
	esp_18 = fp - 44;
	goto l08057B75;
}

// 08057CA0: void _IO_default_seek()
void _IO_default_seek()
{
}

// 08057CB0: void _IO_default_stat()
void _IO_default_stat()
{
}

// 08057CC0: void _IO_default_read()
void _IO_default_read()
{
}

// 08057CD0: void _IO_default_write()
void _IO_default_write()
{
}

// 08057CE0: void _IO_default_showmanyc()
void _IO_default_showmanyc()
{
}

// 08057CF0: void _IO_default_imbue()
void _IO_default_imbue()
{
}

// 08057D00: void _IO_iter_begin()
void _IO_iter_begin()
{
}

// 08057D20: void _IO_iter_end()
void _IO_iter_end()
{
}

// 08057D30: void _IO_iter_next()
void _IO_iter_next()
{
}

// 08057D40: void _IO_iter_file()
void _IO_iter_file()
{
}

// 08057D50: void _IO_list_lock(Register (ptr32 Eq_9) gs)
void _IO_list_lock(struct Eq_9 * gs)
{
	Eq_2 ebx_10 = gs->t0008;
	if (g_t80CF840 != ebx_10)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_21;
		if (!__cmpxchg(g_t80CF838, 0x01, 0x00, out eax_21))
			__lll_lock_wait_private(eax_21, 0x080CF838, gs);
		g_t80CF840 = ebx_10;
	}
	g_t80CF83C = (word32) g_t80CF83C + 1;
}

// 08057DB0: void _IO_list_unlock(Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
void _IO_list_unlock(Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_2 v5_7 = g_t80CF83C - 0x01;
	g_t80CF83C = v5_7;
	if (v5_7 == 0x00)
	{
		g_t80CF840.u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v8_17 = g_t80CF838 - 0x01;
		g_t80CF838 = v8_17;
		if (v8_17 != 0x00)
			__lll_unlock_wake_private(0x080CF838, ecx, 0x080CE000, gs);
	}
}

// 08057E00: void _IO_list_resetlock()
void _IO_list_resetlock()
{
	g_t80CF838.u0 = 0x00;
	g_t80CF83C.u0 = 0x00;
	g_t80CF840.u0 = 0x00;
}

// 08057E2D: void __x86.get_pc_thunk.cx()
void __x86.get_pc_thunk.cx()
{
}

// 08057E40: void _IO_str_underflow(Stack (ptr32 Eq_27077) dwArg04)
void _IO_str_underflow(struct Eq_27077 * dwArg04)
{
	up32 edx_11 = dwArg04->dw0014;
	up32 ecx_12 = dwArg04->dw0008;
	if (edx_11 > ecx_12)
	{
		dwArg04->dw0008 = edx_11;
		ecx_12 = edx_11;
	}
	ui32 ebx_19 = dwArg04->dw0000;
	byte bh_24 = SLICE(ebx_19, byte, 8);
	byte bl_30 = (byte) ebx_19;
	word16 ebx_16_16_31 = SLICE(ebx_19, word16, 16);
	if ((ebx_19 & 0x0C00) != 0x0C00)
		edx_11 = dwArg04->dw0004;
	else
	{
		dwArg04->dw0004 = edx_11;
		dwArg04->dw0000 = SEQ(ebx_16_16_31, bh_24 & ~0x08, bl_30);
		dwArg04->dw0014 = dwArg04->dw0018;
	}
}

// 08057EA0: void _IO_str_overflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _IO_str_overflow(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	ui32 eax_20 = *dwArg04;
	struct Eq_27130 * esp_18 = fp - 44;
	Eq_2 esi_19 = dwArg04;
	byte al_21 = (byte) eax_20;
	byte ah_47 = SLICE(eax_20, byte, 8);
	word16 eax_16_16_52 = SLICE(eax_20, word16, 16);
	if ((al_21 & 0x08) != 0x00)
		return;
	Eq_2 ebp_203;
	if ((eax_20 & 0x0C00) != 0x0400)
		ebp_203 = *((word32) dwArg04 + 20);
	else
	{
		ebp_203 = *((word32) dwArg04 + 4);
		*dwArg04 = SEQ(eax_16_16_52, ah_47 | 0x08, al_21);
		Eq_2 eax_55 = *((word32) dwArg04 + 8);
		*((word32) dwArg04 + 20) = ebp_203;
		*((word32) dwArg04 + 4) = eax_55;
	}
	Eq_2 ecx_61 = *((word32) dwArg04 + 28);
	Eq_2 edi_66 = *((word32) dwArg04 + 32) - ecx_61;
	if ((word32) edi_66 + (uint32) ((int8) (dwArg08 == ~0x00)) <= ebp_203 - *((word32) dwArg04 + 16))
	{
		if ((*dwArg04 & 0x01) != 0x00)
			return;
		Eq_2 ebp_80 = (word32) edi_66 + ((word32) edi_66 + 100);
		if (edi_66 > ebp_80)
			return;
		word32 ebp_91;
		Eq_2 edi_94;
		word32 ecx_336;
		word32 edx_337;
		word32 ebx_338;
		Eq_2 eax_90 = __libc_malloc(gs, dwLoc40, ebp_80, out ecx_336, out edx_337, out ebx_338, out ebp_91, out esi_19, out edi_94);
		struct Eq_27205 * esp_101 = fp - 44;
		Eq_2 edx_102 = eax_90;
		if (eax_90 == 0x00)
			return;
		Eq_2 ecx_107 = ecx_61;
		if (ecx_61 != 0x00)
		{
			word32 edx_342;
			word32 ecx_341;
			memcpy(eax_90, ecx_61, edi_94, out ecx_341, out edx_342);
			word32 ecx_343;
			word32 edx_344;
			free(gs, dwLoc40, ecx_61, out ecx_343, out edx_344);
			((word32) esi_19 + 28)->u0 = 0x00;
			esp_101 = fp - 0x28;
			edx_102 = dwLoc1C;
			ecx_107 = eax_90;
		}
		esp_101->t000C = ecx_107;
		struct Eq_27218 * esp_150 = esp_101 - 0x04;
		esp_150->t000C = edx_102;
		esp_150->tFFFFFFFC = ebp_91 - edi_94;
		esp_150->tFFFFFFF8.u0 = 0x00;
		Mem162[esp_150 + -0x0C:word32] = edi_94 + edx_102;
		word32 edx_340;
		word32 ecx_339;
		memset(esp_150->tFFFFFFF4, esp_150->tFFFFFFF8, esp_150->tFFFFFFFC, out ecx_339, out edx_340);
		esp_150->tFFFFFFF0.u0 = 0x01;
		Eq_2 edx_173 = esp_150->t000C;
		esp_150->tFFFFFFEC = (word32) edx_173 + ebp_91;
		esp_150->tFFFFFFE8 = edx_173;
		esp_150->t000C = edx_173;
		esp_150->tFFFFFFE4 = esi_19;
		_IO_setb(esp_150->tFFFFFFE4, esp_150->tFFFFFFE8, esp_150->tFFFFFFEC, esp_150->tFFFFFFF0);
		word32 ecx_192 = esp_150->dw0010;
		Eq_2 edx_194 = esp_150->t000C;
		Eq_2 eax_198 = (word32) edx_194 + (*((word32) esi_19 + 0x0C) - ecx_192);
		word32 ebp_199 = *((word32) esi_19 + 20) - ecx_192;
		*((word32) esi_19 + 16) = edx_194;
		*((word32) esi_19 + 0x0C) = eax_198;
		Eq_2 eax_202 = *((word32) esi_19 + 4);
		ebp_203 = (word32) edx_194 + ebp_199;
		*((word32) esi_19 + 20) = ebp_203;
		*((word32) esi_19 + 4) = (word32) edx_194 + (eax_202 - ecx_192);
		*((word32) esi_19 + 8) = (word32) edx_194 + (*((word32) esi_19 + 8) - ecx_192);
		*((word32) esi_19 + 24) = *((word32) esi_19 + 32);
		esp_18 = (struct Eq_27130 *) ((char *) &esp_150->tFFFFFFFC + 8);
	}
	if (esp_18->t0034 != ~0x00)
	{
		*((word32) esi_19 + 20) = (word32) ebp_203 + 1;
		*ebp_203 = esp_18->t0034;
		ebp_203 = *((word32) esi_19 + 20);
	}
	if (*((word32) esi_19 + 8) < ebp_203)
		*((word32) esi_19 + 8) = ebp_203;
}

// 08058040: Register (ptr32 Eq_27403) enlarge_userbuf(Register (ptr32 Eq_27403) eax, Register int32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_27403) dwArg04)
// Called from:
//      _IO_str_seekoff
struct Eq_27403 * enlarge_userbuf(struct Eq_27403 * eax, int32 ecx, Eq_2 edx, struct Eq_9 * gs, struct Eq_27403 * dwArg04)
{
	Eq_2 edx_22 = eax->t001C;
	if (eax->dw0020 - edx_22 >= edx)
		return null;
	if ((eax->dw0000 & 0x01) != 0x00)
		return (struct Eq_27403 *) 0x01;
	word32 eax_52 = eax->dw0018;
	Eq_27429 eax_55 = eax->t0010;
	Eq_2 ebp_63;
	struct Eq_27403 * edi_66;
	Eq_2 esi_68;
	word32 ebx_418;
	word32 edx_417;
	word32 ecx_416;
	Eq_2 eax_62 = __libc_malloc(gs, dwLoc50, (word32) edx + 100, out ecx_416, out edx_417, out ebx_418, out ebp_63, out esi_68, out edi_66);
	Eq_2 ecx_113 = eax_62;
	if (eax_62 == 0x00)
		return (struct Eq_27403 *) 0x01;
	Eq_2 edx_114 = edx_22;
	if (edx_22 != 0x00)
	{
		word32 edx_420;
		word32 ecx_419;
		memcpy(eax_62, edx_22, ebp_63, out ecx_419, out edx_420);
		word32 edx_422;
		word32 ecx_421;
		free(gs, dwLoc50, edx_22, out ecx_421, out edx_422);
		((word32) esi_68 + 28)->u0 = 0x00;
		ecx_113 = dwLoc1C;
		edx_114 = eax_62;
	}
	_IO_setb(esi_68, ecx_113, (word32) ecx_113 + ((word32) edx + 100), 0x01);
	Eq_2 ebp_120 = eax_52 - eax_55;
	if (dwArg04 != null)
	{
		Eq_2 eax_211 = *((word32) esi_68 + 16);
		*((word32) esi_68 + 0x0C) = ecx_113;
		*((word32) esi_68 + 16) = (word32) ecx_113 + (eax_211 - edx_114);
		*((word32) esi_68 + 20) = (word32) ecx_113 + (*((word32) esi_68 + 20) - edx_114);
		*((word32) esi_68 + 24) = (word32) ecx_113 + (*((word32) esi_68 + 24) - edx_114);
		*((word32) esi_68 + 4) = (word32) ecx_113 + (*((word32) esi_68 + 4) - edx_114);
		*((word32) esi_68 + 8) = *((word32) esi_68 + 32);
		if (ecx - (ebp_120 >> 0x1F) - (edx < ebp_120) >= 0x00)
		{
			word32 edx_426;
			word32 ecx_425;
			memset(ecx_113 + ebp_120, 0x00, edx - ebp_120, out ecx_425, out edx_426);
			return edi_66;
		}
	}
	else
	{
		Eq_2 eax_154 = *((word32) esi_68 + 0x0C);
		*((word32) esi_68 + 16) = ecx_113;
		*((word32) esi_68 + 0x0C) = (word32) ecx_113 + (eax_154 - edx_114);
		*((word32) esi_68 + 4) = (word32) ecx_113 + (*((word32) esi_68 + 4) - edx_114);
		*((word32) esi_68 + 8) = (word32) ecx_113 + (*((word32) esi_68 + 8) - edx_114);
		*((word32) esi_68 + 20) = (word32) ecx_113 + (*((word32) esi_68 + 20) - edx_114);
		*((word32) esi_68 + 24) = *((word32) esi_68 + 32);
		if (ecx - (ebp_120 >> 0x1F) - (edx < ebp_120) >= 0x00)
		{
			word32 ecx_427;
			word32 edx_428;
			memset(ecx_113 + ebp_120, 0x00, edx - ebp_120, out ecx_427, out edx_428);
			return null;
		}
	}
	word32 edx_424;
	word32 ecx_423;
	__assert_fail(out ecx_423, out edx_424);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	Eq_2 stackArg20 = <invalid>;
	return _IO_str_seekoff(gs, dwArg04, stackArg8, stackArg12, stackArg16, stackArg20);
}

// 08058240: Register Eq_2 _IO_str_seekoff(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_27403) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      enlarge_userbuf
Eq_2 _IO_str_seekoff(struct Eq_9 * gs, struct Eq_27403 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14)
{
	Eq_2 dwArg14_435;
	Eq_2 dwLoc2C_430;
	Eq_27429 dwLoc24_429;
	Eq_2 esi_111;
	Eq_2 eax_118;
	ui32 ecx_24 = dwArg04->dw0000;
	byte ch_33 = SLICE(ecx_24, byte, 8);
	byte cl_82 = (byte) ecx_24;
	word16 ecx_16_16_87 = SLICE(ecx_24, word16, 16);
	Eq_27429 edx_110 = dwArg04->t0014;
	Eq_27429 eax_27 = dwArg04->t0010;
	if (dwArg14 == 0x00)
	{
		dwArg14 = ecx_24 & 0x0400;
		if ((ecx_24 & 0x0400) != 0x00)
		{
			if ((ch_33 & 0x08) != 0x00)
			{
				dwArg14.u0 = 0x02;
				if ((ch_33 & 0x01) == 0x00)
					goto l08058349;
				goto l08058380;
			}
			if (eax_27 >= edx_110)
			{
				if (dwArg04->t0008 >= edx_110)
					edx_110 = dwArg04->t0008;
				eax_118 = dwArg04->t000C;
				dwArg14_435.u0 = 0x01;
				dwLoc24_429 = edx_110;
				dwLoc2C_430 = edx_110 - eax_118;
				goto l080582BE;
			}
			dwArg14.u0 = 0x01;
		}
		else if (eax_27 >= edx_110 && (ch_33 & 0x08) == 0x00)
		{
			eax_118 = dwArg04->t000C;
l08058362:
			esi_111 = dwArg04->t0004 - eax_118;
			return esi_111;
		}
	}
	else if (eax_27 >= edx_110 && (ch_33 & 0x08) == 0x00)
	{
		eax_118 = dwArg04->t000C;
l080583A8:
		byte bArg14_432 = (byte) dwArg14;
		if (dwArg04->t0008 >= edx_110)
			edx_110 = dwArg04->t0008;
		esi_111.u0 = ~0x00;
		dwLoc24_429 = edx_110;
		dwLoc2C_430 = edx_110 - eax_118;
		dwArg14_435 = dwArg14;
		dwArg14_435 = dwArg14;
		if ((bArg14_432 & 0x01) == 0x00)
			goto l080583D0;
l080582BE:
		Eq_2 ecx_153;
		int32 edi_155;
		Eq_2 esi_154;
		Eq_2 dwLoc20_447;
		if (dwArg10 != 0x00)
		{
			if (dwArg10 == 0x01)
			{
				Eq_27429 ecx_171 = dwArg04->t0004;
				Eq_2 edx_177 = ecx_171 - eax_118;
				esi_154 = eax_118 - ecx_171;
				dwLoc20_447 = edx_177;
				edi_155 = esi_154 >> 0x1F;
				ecx_153 = 0x7FFFFFFF - edx_177;
			}
			else
			{
				esi_154 = -dwLoc2C_430;
				ecx_153 = 0x7FFFFFFF - dwLoc2C_430;
				dwLoc20_447 = dwLoc2C_430;
				edi_155 = esi_154 >> 0x1F;
			}
		}
		else
		{
			dwLoc20_447.u0 = 0x00;
			ecx_153.u0 = 0x7FFFFFFF;
			esi_154.u0 = 0x00;
			edi_155 = 0x00;
		}
		if (dwArg0C - edi_155 - (dwArg08 < esi_154) < 0x00 || ((ecx_153 >> 0x1F) - dwArg0C) - (ecx_153 < dwArg08) < 0x00)
			goto l08058550;
		word32 ecx_211 = dwLoc20_447 + dwArg08;
		esi_111 = ecx_211;
		if (ecx_211 > dwLoc2C_430)
		{
			if (enlarge_userbuf(dwArg04, ecx_211 >> 0x1F, ecx_211, gs, (struct Eq_27403 *) 0x01) != 0x00)
				goto l0805852B;
			eax_118 = dwArg04->t000C;
			dwLoc24_429 = eax_118 + dwLoc2C_430;
		}
		Mem254[dwArg04 + 0x04:word32] = eax_118 + ecx_211;
		dwArg04->t0008 = dwLoc24_429;
l080583D0:
		if (((byte) dwArg14_435 & 0x02) == 0x00)
			return esi_111;
		Eq_2 ecx_266;
		int32 edx_268;
		Eq_2 eax_267;
		if (dwArg10 != 0x00)
		{
			if (dwArg10 == 0x01)
			{
				Eq_27429 edx_283 = dwArg04->t0014;
				Eq_27429 eax_284 = dwArg04->t0010;
				Eq_2 edi_287 = edx_283 - eax_284;
				int64 edx_eax_290 = (int64) (eax_284 - edx_283);
				dwArg10 = edi_287;
				eax_267 = (word32) edx_eax_290;
				edx_268 = SLICE(edx_eax_290, word32, 32);
				ecx_266 = 0x7FFFFFFF - edi_287;
			}
			else
			{
				int64 edx_eax_281 = (int64) -dwLoc2C_430;
				ecx_266 = 0x7FFFFFFF - dwLoc2C_430;
				dwArg10 = dwLoc2C_430;
				eax_267 = (word32) edx_eax_281;
				edx_268 = SLICE(edx_eax_281, word32, 32);
			}
		}
		else
		{
			ecx_266.u0 = 0x7FFFFFFF;
			eax_267.u0 = 0x00;
			edx_268 = 0x00;
		}
		if (dwArg0C - edx_268 - (dwArg08 < eax_267) >= 0x00 && (SLICE((int64) ecx_266, word32, 32) - dwArg0C) - (ecx_266 < dwArg08) >= 0x00)
		{
			word32 ebp_342 = dwArg08 + dwArg10;
			if (ebp_342 <= dwLoc2C_430 || enlarge_userbuf(dwArg04, ebp_342 >> 0x1F, ebp_342, gs, null) == 0x00)
			{
				Mem400[dwArg04 + 0x14:word32] = ebp_342 + Mem394[dwArg04 + 0x10:word32];
				return ebp_342;
			}
l0805852B:
			esi_111.u0 = ~0x00;
			return esi_111;
		}
l08058550:
		gs->tFFFFFFE0.u0 = 22;
		esi_111.u0 = ~0x00;
		return esi_111;
	}
	if ((ch_33 & 0x01) == 0x00)
	{
l08058349:
		eax_118 = dwArg04->t001C;
l0805834C:
		dwArg04->t000C = eax_118;
		dwArg04->dw0000 = SEQ(ecx_16_16_87, ch_33 & ~0x08, cl_82);
		dwArg04->t0008 = edx_110;
		dwArg04->t0004 = edx_110;
		if (dwArg14 == 0x00)
			goto l08058362;
		goto l080583A8;
	}
l08058380:
	eax_118 = dwArg04->t0028;
	goto l0805834C;
}

// 08058570: void _IO_str_pbackfail(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _IO_str_pbackfail(struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	if ((*dwArg04 & 0x08) != 0x00 && dwArg08 != ~0x00)
		return;
	_IO_default_pbackfail(gs, dwArg04, dwArg08);
}

// 080585A0: void _IO_str_finish(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_str_finish(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 eax_14 = *((word32) dwArg04 + 28);
	if (eax_14 != 0x00 && (*dwArg04 & 0x01) == 0x00)
	{
		word32 edx_66;
		word32 ecx_65;
		free(gs, dwLoc20, eax_14, out ecx_65, out edx_66);
	}
	((word32) dwArg04 + 28)->u0 = 0x00;
	_IO_default_finish(dwArg04);
}

// 08058600: void _IO_str_init_static_internal(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      vasprintf
//      _IO_str_init_static
//      _IO_str_init_readonly
void _IO_str_init_static_internal(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 edi_24;
	if (dwArg0C == 0x00)
		edi_24 = rawmemchr(dwArg08, 0x00);
	else
	{
		edi_24 = (word32) dwArg08 + dwArg0C;
		if (dwArg08 >= edi_24)
			edi_24.u0 = ~0x00;
	}
	_IO_setb(dwArg04, dwArg08, edi_24, 0x00);
	*((word32) dwArg04 + 16) = dwArg08;
	*((word32) dwArg04 + 0x0C) = dwArg08;
	*((word32) dwArg04 + 4) = dwArg08;
	if (dwArg10 != 0x00)
	{
		*((word32) dwArg04 + 20) = dwArg10;
		*((word32) dwArg04 + 24) = edi_24;
		*((word32) dwArg04 + 8) = dwArg10;
	}
	else
	{
		*((word32) dwArg04 + 20) = dwArg08;
		*((word32) dwArg04 + 24) = dwArg08;
		*((word32) dwArg04 + 8) = edi_24;
	}
	((word32) dwArg04 + 0x0098)->u0 = 0x00;
}

// 08058690: void _IO_str_init_static(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C, Stack Eq_2 dwArg10)
void _IO_str_init_static(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C, Eq_2 dwArg10)
{
	int32 eax_10 = dwArg0C;
	if (dwArg0C < 0x00)
		eax_10 = ~0x00;
	_IO_str_init_static_internal(dwArg04, dwArg08, eax_10, dwArg10);
}

// 080586B0: void _IO_str_init_readonly(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C)
void _IO_str_init_readonly(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C)
{
	int32 eax_16 = dwArg0C;
	if (dwArg0C < 0x00)
		eax_16 = ~0x00;
	_IO_str_init_static_internal(dwArg04, dwArg08, eax_16, 0x00);
	*dwArg04 |= 0x08;
}

// 080586E0: void _IO_str_count(Stack (ptr32 Eq_27986) dwArg04)
void _IO_str_count(struct Eq_27986 * dwArg04)
{
	dwArg04->dw0008 < dwArg04->dw0014;
}

// 08058700: Register uint32 __libc_alloca_cutoff(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      locked_vfxprintf
//      get_nprocs
//      __add_to_environ
//      printf_positional
//      __printf_fp_l
//      printf_positional
uint32 __libc_alloca_cutoff(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_14 = 0x00010000;
	if (gs->dw0274 >> 0x02 <= 0x00010000 && gs->dw0274 >> 0x02 >= 0x01)
	{
		uint32 eax_12 = gs->dw0274;
		edx_14 = eax_12 >> 0x02;
		if (eax_12 <= 0x03)
			edx_14.u0 = 0x00040000;
	}
	return (uint32) (int8) (edx_14 >= dwArg04);
}

// 08058740: Register Eq_2 __lll_lock_wait_private(Register word32 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      abort
//      _nl_find_msg
//      _nl_load_domain
//      _nl_expand_alias
//      __run_exit_handlers
//      __internal_atexit
//      __fxprintf
//      __fxprintf_nocancel
//      __new_fclose
//      fflush
//      _IO_puts
//      _IO_wfile_underflow
//      _IO_new_file_underflow
//      _IO_un_link.part.2
//      _IO_link_in
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      _IO_list_lock
//      get_free_list
//      arena_get2.part.5
//      arena_get_retry
//      _int_free
//      malloc_check
//      tcache_init.part.6
//      memalign_check
//      free_check.part.3
//      realloc_check
//      __malloc_fork_lock_parent
//      __libc_malloc
//      _mid_memalign
//      __malloc_arena_thread_freeres
//      __realloc
//      __libc_calloc
//      malloc_trim
//      mallinfo
//      __malloc_stats
//      __mallopt
//      malloc_info
//      __gconv_find_transform
//      __gconv_close_transform
//      __gconv_get_path
//      __add_to_environ
//      __unsetenv
//      __clearenv
//      vfprintf
//      buffered_vfprintf
//      register_printf_specifier
//      register_printf_modifier
//      register_printf_type
//      __vfwprintf
//      buffered_vfprintf
//      fputs
//      fwrite
//      _IO_getdelim
//      __readdir
//      __rewinddir
//      readdir64
Eq_2 __lll_lock_wait_private(word32 eax, Eq_2 ecx, struct Eq_9 * gs)
{
	int32 edx_13 = 0x02;
	Eq_2 ecx_17 = 0x80;
	if (eax == 0x02)
	{
l08058755:
		gs->ptr0010();
	}
	int32 v13_38 = *ecx;
	*ecx = edx_13;
	if (v13_38 == 0x00)
		return ecx_17;
	goto l08058755;
}

// 08058770: Register Eq_2 __lll_unlock_wake_private(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      abort
//      _IO_new_fclose.cold.0
//      _IO_fflush.cold.0
//      _IO_puts.cold.0
//      _IO_wfile_underflow.cold.2
//      _IO_new_file_underflow.cold.6
//      _IO_fputs.cold.0
//      _IO_fwrite.cold.0
//      _IO_getdelim.cold.0
//      _nl_find_msg
//      _nl_load_domain
//      _nl_expand_alias
//      __run_exit_handlers
//      __internal_atexit
//      __fxprintf
//      __fxprintf_nocancel
//      __new_fclose
//      fflush
//      _IO_puts
//      _IO_wfile_underflow
//      _IO_new_file_underflow
//      flush_cleanup
//      _IO_un_link.part.2
//      _IO_link_in
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      _IO_list_unlock
//      get_free_list
//      arena_get2.part.5
//      arena_get_retry
//      _int_free
//      malloc_check
//      tcache_init.part.6
//      memalign_check
//      free_check.part.3
//      realloc_check
//      __malloc_fork_unlock_parent
//      __libc_malloc
//      _mid_memalign
//      __malloc_arena_thread_freeres
//      __realloc
//      __libc_calloc
//      malloc_trim
//      mallinfo
//      __malloc_stats
//      __mallopt
//      malloc_info
//      __gconv_find_transform
//      __gconv_close_transform
//      __gconv_get_path
//      __add_to_environ
//      __unsetenv
//      __clearenv
//      vfprintf
//      buffered_vfprintf
//      register_printf_specifier
//      register_printf_modifier
//      register_printf_type
//      __vfwprintf
//      buffered_vfprintf
//      __funlockfile
//      fputs
//      fwrite
//      _IO_getdelim
//      __readdir
//      __rewinddir
//      readdir64
Eq_2 __lll_unlock_wake_private(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	*eax = 0x00;
	Eq_2 eax_22;
	gs->ptr0010();
	return eax_22;
}

// 080587A0: void _dl_tunable_set_arena_max(Stack (ptr32 uint32) dwArg04)
void _dl_tunable_set_arena_max(uint32 * dwArg04)
{
	g_dw80CE4B0 = *dwArg04;
}

// 080587C0: void _dl_tunable_set_arena_test(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_arena_test(union Eq_2 * dwArg04)
{
	g_t80CE4AC = *dwArg04;
}

// 080587E0: void _dl_tunable_set_tcache_max(Stack (ptr32 up32) dwArg04)
void _dl_tunable_set_tcache_max(up32 * dwArg04)
{
	up32 eax_8 = *dwArg04;
	if (eax_8 <= 1020)
	{
		g_dw80CE4D4 = eax_8;
		g_dw80CE4D0 = ((eax_8 + 0x13 & ~0x0F) - 0x01 >> 0x04) + 0x01;
	}
}

// 08058820: void _dl_tunable_set_tcache_count(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_tcache_count(union Eq_2 * dwArg04)
{
	Eq_2 eax_8 = *dwArg04;
	if (eax_8 <= 0x7F)
		g_t80CE4D8 = eax_8;
}

// 08058850: void _dl_tunable_set_tcache_unsorted_limit(Stack (ptr32 word32) dwArg04)
void _dl_tunable_set_tcache_unsorted_limit(word32 * dwArg04)
{
	g_dw80CE4DC = *dwArg04;
}

// 08058870: void mem2mem_check(Register Eq_2 eax, Register Eq_28092 edx)
// Called from:
//      malloc_check
//      memalign_check
//      realloc_check
void mem2mem_check(Eq_2 eax, Eq_28092 edx)
{
	if (eax == 0x00)
		return;
	byte bl_29 = (byte) (eax - 0x08 >> 0x03 ^ eax - 0x08 >> 11);
	Eq_2 esi_28 = *((word32) eax - 4);
	if (bl_29 == 0x01)
		bl_29 = 0x02;
	Eq_28112 esi_43 = (word32) bl_29;
	ui32 edi_45 = (esi_28 & ~0x07) - 0x08;
	ui32 ebx_46 = (esi_28 & ~0x07) - 0x04;
	if ((esi_28 & 0x02) != 0x00)
		ebx_46 = edi_45;
	Eq_28092 ebx_52 = ebx_46 - 0x01;
	if (ebx_52 > edx)
	{
		do
		{
			Eq_28112 ecx_183 = ebx_52 - edx;
			if (ecx_183 > 0xFF)
				ecx_183.u0 = 0xFF;
			if (ecx_183 == esi_43)
				ecx_183 = esi_43 - 0x01;
			Mem83[eax + ebx_52:byte] = SLICE(ecx_183, byte, 0);
			ebx_52 -= ecx_183;
		} while (edx < ebx_52);
	}
	Mem106[eax + edx:byte] = bl_29;
}

// 08058900: Register Eq_2 mem2chunk_check(Register Eq_2 eax, Register (ptr32 (ptr32 byte)) edx, Register out Eq_28148 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      free_check.part.3
//      realloc_check
Eq_2 mem2chunk_check(Eq_2 eax, byte ** edx, union Eq_28148 & ecxOut, union Eq_2 & edxOut)
{
	byte al = (byte) eax;
	Eq_2 edx_263;
	if ((al & 0x0F) == 0x00)
	{
		Eq_2 ebx_27 = *((word32) eax - 4);
		Eq_28148 ecx_37 = eax - (struct Eq_28163 *) 0x08 >> 11 ^ eax - (struct Eq_28163 *) 0x08 >> 0x03;
		byte bl_44 = (byte) ebx_27;
		edx_263 = eax - (struct Eq_28163 *) 0x08;
		if ((byte) ecx_37 == 0x01)
			ecx_37.u0 = 0x02;
		byte * edi_117;
		byte cl_122 = (byte) ecx_37;
		if ((bl_44 & 0x02) != 0x00)
		{
			Eq_2 esi_155 = _dl_pagesize;
			uint32 edi_157 = eax & esi_155 - 0x01;
			if ((edi_157 - 0x10 & ~0x10) != 0x00 && (edi_157 <= 0x1FFF && ((edi_157 - 0x40 & ~0x40) != 0x00 && ((edi_157 - 0x0100 & ~0x0100) != 0x00 && (edi_157 - 0x0400 & ~0x0400) != 0x00))))
			{
				ecx = ecx_37;
				if (edi_157 != 0x1000)
					goto l08058A50;
			}
			ecx = ecx_37;
			if ((ebx_27 & 0x03) != 0x02)
				goto l08058A50;
			Eq_2 eax_191 = *((word32) eax - 8);
			ecx = ecx_37;
			if ((((word32) eax_191 + (ebx_27 & ~0x07) | (eax - (struct Eq_28163 *) 0x08) - eax_191) & esi_155 - 0x01) == 0x00)
			{
				edi_117 = eax - (struct Eq_28163 *) 0x08 + ((ebx_27 & ~0x07) - 0x01);
				uint32 esi_206 = (word32) *edi_117;
				uint32 eax_204 = (ebx_27 & ~0x07) - 0x01;
				if (cl_122 != (byte) esi_206)
				{
					ecx = ecx_37;
					if (esi_206 != 0x00)
					{
						ecx = ecx_37;
						if ((ebx_27 & ~0x07) - 0x01 >= esi_206 + 0x08)
						{
							do
							{
								eax_204 -= esi_206;
								edi_117 = eax - (struct Eq_28163 *) 0x08 + eax_204;
								esi_206 = (word32) *edi_117;
								if ((byte) esi_206 == cl_122)
									goto l080589F9;
								ecx = ecx_37;
								if (esi_206 == 0x00)
									break;
								ecx = ecx_37;
							} while (esi_206 + 0x08 <= eax_204);
						}
					}
					goto l08058A50;
				}
l080589F9:
				ecx = ~ecx_37;
				*edi_117 = (byte) ecx;
				if (edx != null)
					*edx = (byte **) edi_117;
l08058A52:
				ecxOut = ecx;
				edxOut = edx_263;
				return edx_263;
			}
			goto l08058A50;
		}
		Eq_28185 edi_50 = g_t80CE504;
		if ((edi_50 & 0x02) != 0x00)
		{
l08058A35:
			ecx = ecx_37;
			if ((ebx_27 & ~0x07) <= 0x0F)
				goto l08058A50;
			ecx = ecx_37;
			if ((bl_44 & 0x08) == 0x00)
			{
				ecx = ecx_37;
				if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(eax - 0x04)[ebx_27 & ~0x07].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & 0x01) == 0x00)
					goto l08058A50;
				if ((ebx_27 & 0x01) != 0x00)
				{
l08058A82:
					edi_117 = eax - (struct Eq_28163 *) 0x08 + ((ebx_27 & ~0x07) + 0x03);
					uint32 esi_118 = (word32) *edi_117;
					uint32 ebx_114 = (ebx_27 & ~0x07) + 0x03;
					if (cl_122 != (byte) esi_118)
					{
						ecx = ecx_37;
						if (esi_118 != 0x00)
						{
							ecx = ecx_37;
							if ((ebx_27 & ~0x07) + 0x03 >= esi_118 + 0x08)
							{
								do
								{
									ebx_114 -= esi_118;
									edi_117 = eax - (struct Eq_28163 *) 0x08 + ebx_114;
									esi_118 = (word32) *edi_117;
									if ((byte) esi_118 == cl_122)
										goto l080589F9;
									ecx = ecx_37;
									if (esi_118 == 0x00)
										break;
									ecx = ecx_37;
								} while (esi_118 + 0x08 <= ebx_114);
							}
						}
						goto l08058A50;
					}
					goto l080589F9;
				}
				Eq_2 eax_89 = *((word32) eax - 8);
				ecx = ecx_37;
				if (((byte) eax_89 & 0x0F) != 0x00)
					goto l08058A50;
				Eq_2 ebx_96 = eax - (struct Eq_28163 *) 0x08 - eax_89;
				if ((edi_50 & 0x02) == 0x00)
				{
					ecx = ecx_37;
					if (g_t80CE4CC > ebx_96)
						goto l08058A50;
				}
				ecx = ecx_37;
				if (eax_89 == (*((word32) ebx_96 + 4) & ~0x07))
					goto l08058A82;
			}
			goto l08058A50;
		}
		Eq_2 edi_57 = g_t80CE4CC;
		ecx = ecx_37;
		if (edi_57 > eax - (struct Eq_28163 *) 0x08)
			goto l08058A50;
		ecx = ecx_37;
		if ((ebx_27 & ~0x07) + (eax - (struct Eq_28163 *) 0x08) < (word32) edi_57 + g_dw80CE954)
			goto l08058A35;
	}
l08058A50:
	edx_263.u0 = 0x00;
	goto l08058A52;
}

// 08058B00: Register word32 int_mallinfo(Register Eq_2 eax, Register (ptr32 Eq_28386) edx, Register out ptr32 edxOut)
// Called from:
//      mallinfo
//      __malloc_stats
word32 int_mallinfo(Eq_2 eax, struct Eq_28386 * edx, ptr32 & edxOut)
{
	word32 ebp_50 = 0x00;
	struct Eq_28390 ** ecx_27 = (word32) eax + 0x0C;
	word32 edi_29 = 0x00;
	Eq_2 eax_30 = *((word32) *((word32) eax + 56) + 4);
	do
	{
		struct Eq_28409 * eax_39 = *ecx_27;
		while (eax_39 != null)
		{
			eax_39 = eax_39->ptr0008;
			++ebp_50;
			edi_29 += eax_39->dw0004 & ~0x07;
		}
		struct Eq_28402 * esi_102 = (word32) eax + 56;
		ecx_27 = (struct Eq_28390 **) ((char *) ecx_27 + 4);
	} while ((word32) eax + 56 != ecx_27);
	ui32 ecx_122 = (eax_30 & ~0x07) + edi_29;
	word32 ebx_115 = 0x01;
	do
	{
		struct Eq_28402 * eax_85 = esi_102->dw000C;
		while (eax_85 != esi_102)
		{
			eax_85 = eax_85->dw000C;
			++ebx_115;
			ecx_122 += eax_85->dw0004 & ~0x07;
		}
		++esi_102;
	} while ((word32) eax + 0x0430 != esi_102);
	edx->dw0004 += ebx_115;
	edx->dw0008 += ebp_50;
	edx->dw0020 += ecx_122;
	Eq_2 eax_126 = *((word32) eax + 0x0454);
	edx->dw0000 = (word32) eax_126 + edx->dw0000;
	edx->dw0018 += edi_29;
	edx->dw001C += eax_126 - ecx_122;
	if (eax != 0x080CE500)
		return;
	edx->t000C = g_t80CE4B4;
	Eq_28506 eax_146 = g_t80CE4C4;
	edx->dw0014 = 0x00;
	edx->t0010 = eax_146;
	edx->dw0024 = eax_30 & ~0x07;
	return;
}

// 08058C20: void _dl_tunable_set_trim_threshold(Stack (ptr32 ui32) dwArg04)
void _dl_tunable_set_trim_threshold(ui32 * dwArg04)
{
	g_dw80CE4A0 = *dwArg04;
	g_dw80CE4C0 = 0x01;
}

// 08058C50: void _dl_tunable_set_top_pad(Stack (ptr32 up32) dwArg04)
void _dl_tunable_set_top_pad(up32 * dwArg04)
{
	g_dw80CE4A4 = *dwArg04;
	g_dw80CE4C0 = 0x01;
}

// 08058C80: void _dl_tunable_set_mmap_threshold(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_mmap_threshold(union Eq_2 * dwArg04)
{
	Eq_2 eax_8 = *dwArg04;
	if (eax_8 > 0x00080000)
		return;
	g_t80CE4A8 = eax_8;
	g_dw80CE4C0 = 0x01;
}

// 08058CC0: void _dl_tunable_set_mmaps_max(Stack (ptr32 Eq_28506) dwArg04)
void _dl_tunable_set_mmaps_max(union Eq_28506 * dwArg04)
{
	g_t80CE4B8 = *dwArg04;
	g_dw80CE4C0 = 0x01;
}

// 08058CF0: void _dl_tunable_set_perturb_byte(Stack (ptr32 Eq_2) dwArg04)
void _dl_tunable_set_perturb_byte(union Eq_2 * dwArg04)
{
	perturb_byte = *dwArg04;
}

// 08058D10: FlagGroup byte __malloc_assert(Register Eq_2 eax, Register Eq_2 ecx, Register ptr32 edx, Register out (ptr32 Eq_28574) eaxOut, Register out Eq_28575 ecxOut, Register out Eq_28576 edxOut)
// Called from:
//      detach_arena
//      get_free_list
//      munmap_chunk
//      mremap_chunk
//      arena_get2.part.5
//      _int_free
//      sysmalloc
//      _int_malloc
//      _int_memalign
//      _int_realloc
//      __libc_malloc
//      _mid_memalign
//      __malloc_arena_thread_freeres
//      __realloc
//      __libc_calloc
//      malloc_trim
byte __malloc_assert(Eq_2 eax, Eq_2 ecx, ptr32 edx, struct Eq_28574 & eaxOut, union Eq_28575 & ecxOut, union Eq_28576 & edxOut)
{
	ptr32 ebp_23;
	Eq_2 ecx_71;
	ptr32 esp_18 = fp - 0x1C;
	Eq_2 esi_20 = program_invocation_short_name;
	if (*esi_20 == 0x00)
	{
		ebp_23 = 134955513;
l08058D3B:
		struct Eq_28593 * esp_26 = esp_18 - 0x0C;
		esp_26->tFFFFFFFC = eax;
		esp_26->ptrFFFFFFF8 = 0x080A221C;
		esp_26->dwFFFFFFF4 = esp_26->dw002C;
		esp_26->tFFFFFFF0 = ecx;
		esp_26->ptrFFFFFFEC = edx;
		esp_26->ptrFFFFFFE8 = ebp_23;
		esp_26->tFFFFFFE4 = esi_20;
		esp_26->ptrFFFFFFE0 = 134884312;
		esp_26->dwFFFFFFDC = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		__fxprintf(gs, stackArg4);
		esp_26->tFFFFFFFC = _IO_stderr;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		fflush(gs, stackArg4);
		esp_18 = esp_26 - 4;
		eax = abort(ecx_71, gs, out ecx_71, out edx);
		ecx = ecx_71;
	}
	ebp_23 = 0x080A221C;
	goto l08058D3B;
}

// 08058D80: Register word32 detach_arena(Register Eq_2 eax, Register out ptr32 edxOut)
// Called from:
//      get_free_list
//      arena_get2.part.5
word32 detach_arena(Eq_2 eax, ptr32 & edxOut)
{
	if (eax != 0x00)
	{
		Eq_2 edx_14 = *((word32) eax + 1104);
		if (edx_14 == 0x00)
		{
			word32 edx_73;
			word32 ecx_72;
			word32 eax_71;
			__malloc_assert(0x080A2C00, 0x02A3, 0x080A28A8, out eax_71, out ecx_72, out edx_73);
			ptr32 edx_31;
			word32 ecx_32;
			word32 ebx_75;
			word32 esi_76;
			word32 edi_77;
			get_free_list(gs, out ecx_32, out edx_31, out ebx_75, out esi_76, out edi_77);
			edxOut = edx_31;
			return ecx_32;
		}
		*((word32) eax + 1104) = edx_14 - 0x01;
		edx = edx_14 - 0x01;
	}
	edxOut = edx;
	return ecx;
}

// 08058DD0: Register Eq_2 get_free_list(Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_2 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      detach_arena
//      arena_get_retry
//      tcache_init.part.6
//      __libc_malloc
//      _mid_memalign
//      __libc_calloc
Eq_2 get_free_list(struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_2 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_2 ebx_136 = free_list;
	if (ebx_136 != 0x00)
	{
		ecx.u0 = 0x01;
		edx = gs->tFFFFFFEC;
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_30;
		if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_30))
			ecx = __lll_lock_wait_private(eax_30, 0x080CF888, gs);
		ebx_136 = free_list;
		if (ebx_136 != 0x00)
		{
			free_list = *((word32) ebx_136 + 0x044C);
			if (*((word32) ebx_136 + 1104) != 0x00)
			{
				word32 eax_233;
				word32 edx_235;
				word32 ecx_234;
				__malloc_assert(0x080A28B0, 0x0301, 0x080A28A8, out eax_233, out ecx_234, out edx_235);
				Eq_2 ecx_72;
				Eq_2 edx_73;
				Eq_2 eax_71 = malloc_printerr(out ecx_72, out edx_73);
				ecxOut = ecx_72;
				edxOut = edx_73;
				ebxOut = ebx_136;
				esiOut = 0x080CE000;
				ediOut = ~0x13;
				return eax_71;
			}
			((word32) ebx_136 + 1104)->u0 = 0x01;
			ecx = detach_arena(edx, out edx);
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_90 = free_list_lock - 0x01;
		free_list_lock = v14_90;
		if (v14_90 != 0x00)
			__lll_unlock_wake_private(0x080CF888, ecx, edx, gs);
		if (ebx_136 != 0x00)
		{
			ecx.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_118;
			if (!__cmpxchg(*ebx_136, 0x01, 0x00, out eax_118))
				ecx = __lll_lock_wait_private(eax_118, ebx_136, gs);
			gs->tFFFFFFEC = ebx_136;
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	ebxOut = ebx;
	esiOut = esi;
	ediOut = edi;
	return ebx_136;
}

// 08058EC0: Register word32 malloc_printerr(Register out Eq_979 ecxOut, Register out (ptr32 Eq_28782) edxOut)
// Called from:
//      get_free_list
//      top_check
//      malloc_consolidate
//      munmap_chunk
//      mremap_chunk
//      _int_free
//      sysmalloc
//      _int_malloc
//      free_check.part.3
//      _int_realloc
//      realloc_check
//      __realloc
//      __malloc_usable_size
word32 malloc_printerr(union Eq_979 & ecxOut, struct Eq_28782 & edxOut)
{
	__libc_message(gs, 0x01, 134954212);
	struct Eq_28782 * edx_24;
	word32 ebx_38;
	word32 eax_25 = top_check(out edx_24, out ebx_38);
	ecxOut.u0 = <invalid>;
	edxOut = edx_24;
	return eax_25;
}

// 08058EE0: Register Eq_2 top_check(Register out Eq_2 edxOut, Register out Eq_28825 ebxOut)
// Called from:
//      malloc_printerr
//      malloc_check
//      memalign_check
//      realloc_check
Eq_2 top_check(union Eq_2 & edxOut, union Eq_28825 & ebxOut)
{
	Eq_2 edx_32 = g_t80CE538;
	if (edx_32 == 0x080CE538)
	{
		edxOut = edx_32;
		ebxOut = ebx;
		return 0x080CE000;
	}
	Eq_2 ecx_15 = *((word32) edx_32 + 4);
	if (((byte) ecx_15 & 0x02) == 0x00)
	{
		ebx = ecx_15 & ~0x07;
		if ((ecx_15 & ~0x07) > 0x0F && (ecx_15 & 0x01) != 0x00)
		{
			if ((g_t80CE504 & 0x02) != 0x00)
			{
l08058F30:
				edxOut = edx_32;
				ebxOut = ebx;
				return 0x080CE000;
			}
			edx_32 = (word32) edx_32 + (ecx_15 & ~0x07);
			if (edx_32 == (word32) g_t80CE4CC + g_dw80CE954)
				goto l08058F30;
		}
	}
	word32 edx_91;
	word32 ecx_90;
	malloc_printerr(out ecx_90, out edx_91);
	Eq_2 edx_50;
	word32 ecx_94;
	word32 ebx_95;
	word32 ebp_96;
	word32 edi_97;
	Eq_2 eax_49 = malloc_consolidate(eax, gs, out ecx_94, out edx_50, out ebx_95, out ebp_96, out edi_97);
	edxOut = edx_50;
	ebxOut = ebx;
	return eax_49;
}

// 08058F50: Register Eq_2 malloc_consolidate(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out Eq_28886 ecxOut, Register out Eq_2 edxOut, Register out Eq_2 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      top_check
//      _int_free
//      _int_malloc
//      malloc_trim
//      __mallopt
Eq_2 malloc_consolidate(Eq_2 eax, struct Eq_9 * gs, union Eq_28886 & ecxOut, union Eq_2 & edxOut, union Eq_2 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & ediOut)
{
	((word32) eax + 8)->u0 = 0x00;
	Eq_2 dwLoc38_350 = (word32) eax + 0x0C;
	edi_101 = edi;
	do
	{
		Eq_2 edi_101;
		Eq_2 v12_33 = *dwLoc38_350;
		*dwLoc38_350 = 0x00;
		Eq_2 edx_109 = dwLoc38_350;
		Eq_2 ebx_118 = v12_33;
		if (v12_33 != 0x00)
		{
			do
			{
				Eq_2 esi_42 = *((word32) ebx_118 + 4);
				if (dwLoc38_350 != ((word32) eax + 4) + (esi_42 >> 0x03) * 0x04)
				{
					up32 edx_54;
					word32 ecx_522;
					Eq_2 eax_55 = malloc_printerr(out ecx_522, out edx_54);
					Eq_28886 ecx_62;
					Eq_2 edx_63;
					Eq_2 eax_61 = new_heap(eax_55, edx_54, gs, out ecx_62, out edx_63);
					ecxOut = ecx_62;
					edxOut = edx_63;
					ebxOut = ebx_118;
					ebpOut = eax;
					ediOut = edi_101;
					return eax_61;
				}
				Eq_2 esi_121;
				edx_109 = (word32) ebx_118 + (esi_42 & ~0x07);
				Eq_2 edi_73 = *((word32) edx_109 + 4);
				Eq_2 eax_68 = *((word32) ebx_118 + 8);
				Eq_2 eax_112 = esi_42 & ~0x07;
				ecx = edi_73 & ~0x07;
				edi_101 = edi_73;
				if ((esi_42 & 0x01) == 0x00)
				{
					esi_121 = *ebx_118;
					ebx_118 -= esi_121;
					Eq_2 edi_84 = *((word32) ebx_118 + 4);
					eax_112 = (word32) esi_121 + (esi_42 & ~0x07);
					dwLoc28 = edi_84;
					edi_101 = edi_84 & ~0x07;
					if ((edi_84 & ~0x07) != esi_121)
						goto l08059130;
					if ((edi_84 & ~0x07) != *((word32) ebx_118 + (edi_84 & ~0x07)))
						goto l08059120;
					esi_121 = *((word32) ebx_118 + 8);
					edi_101 = *((word32) ebx_118 + 0x0C);
					if (*((word32) esi_121 + 0x0C) != ebx_118 || *((word32) edi_101 + 8) != ebx_118)
						goto l08059110;
					*((word32) esi_121 + 0x0C) = edi_101;
					*((word32) edi_101 + 8) = esi_121;
					if (edi_84 <= 1007)
						goto l080590B0;
					edi_101 = *((word32) ebx_118 + 16);
					dwLoc28 = edi_101;
					if (edi_101 == 0x00)
						goto l080590B0;
					goto l08059140;
				}
				while (true)
				{
l080590B0:
					if (*((word32) eax + 56) == edx_109)
						break;
					esi_121 = edx_109 + ecx;
					if ((*((word32) esi_121 + 4) & 0x01) != 0x00)
					{
						*((word32) edx_109 + 4) = edi_73 & ~0x01;
						goto l08058FE0;
					}
					eax_112 += ecx;
					if (*esi_121 == ecx)
					{
						Eq_2 ecx_134 = *((word32) edx_109 + 8);
						esi_121 = *((word32) edx_109 + 0x0C);
						if (*((word32) ecx_134 + 0x0C) != edx_109 || *((word32) esi_121 + 8) != edx_109)
						{
l08059110:
							word32 ecx_525;
							word32 edx_526;
							malloc_printerr(out ecx_525, out edx_526);
							goto l08059120;
						}
						*((word32) ecx_134 + 0x0C) = esi_121;
						*((word32) esi_121 + 8) = ecx_134;
						if (edi_73 > 1007)
						{
							esi_121 = *((word32) edx_109 + 16);
							if (esi_121 == 0x00)
								goto l08058FE0;
							if (*((word32) esi_121 + 20) != edx_109)
							{
l0805916E:
								eax_112 = malloc_printerr(out ecx, out edx_109);
l0805917D:
								if (dwLoc28 != ebx_118)
								{
									*((word32) esi_121 + 16) = dwLoc28;
									*((word32) esi_121 + 20) = dwLoc20;
									*((word32) *((word32) ebx_118 + 16) + 20) = esi_121;
									edi_101 = *((word32) ebx_118 + 20);
									*((word32) edi_101 + 16) = esi_121;
								}
								else
								{
									*((word32) esi_121 + 20) = esi_121;
									*((word32) esi_121 + 16) = esi_121;
								}
								continue;
							}
							edi_101 = *((word32) edx_109 + 20);
							if (*((word32) edi_101 + 16) != edx_109)
								goto l0805916E;
							if (*((word32) ecx_134 + 16) != 0x00)
							{
								*((word32) esi_121 + 20) = edi_101;
								*((word32) *((word32) edx_109 + 20) + 16) = esi_121;
							}
							else if (esi_121 != edx_109)
							{
								*((word32) ecx_134 + 16) = esi_121;
								Eq_2 esi_252 = *((word32) edx_109 + 16);
								*((word32) ecx_134 + 20) = edi_101;
								*((word32) esi_252 + 20) = ecx_134;
								*((word32) *((word32) edx_109 + 20) + 16) = ecx_134;
							}
							else
							{
								*((word32) ecx_134 + 20) = ecx_134;
								*((word32) ecx_134 + 16) = ecx_134;
							}
						}
l08058FE0:
						edx_109 = *((word32) eax + 64);
						*((word32) eax + 64) = ebx_118;
						*((word32) edx_109 + 0x0C) = ebx_118;
						if (eax_112 > 1007)
						{
							((word32) ebx_118 + 16)->u0 = 0x00;
							((word32) ebx_118 + 20)->u0 = 0x00;
						}
						*((word32) ebx_118 + 8) = edx_109;
						*((word32) ebx_118 + 4) = eax_112 | 0x01;
						*((word32) ebx_118 + 0x0C) = (word32) eax + 56;
						Mem284[ebx_118 + eax_112:word32] = eax_112;
						ecx = (word32) eax + 56;
						goto l08059013;
					}
l08059120:
					word32 ecx_523;
					word32 edx_524;
					malloc_printerr(out ecx_523, out edx_524);
l08059130:
					eax_112 = malloc_printerr(out ecx, out edx_109);
l08059140:
					if (*((word32) edi_101 + 20) != ebx_118)
						goto l0805916E;
					edi_101 = *((word32) ebx_118 + 20);
					dwLoc20 = edi_101;
					if (*((word32) edi_101 + 16) != ebx_118)
						goto l0805916E;
					edi_101 = *((word32) esi_121 + 16);
					if (edi_101 == 0x00)
						goto l0805917D;
					*((word32) dwLoc28 + 20) = edi_101;
					*((word32) *((word32) ebx_118 + 20) + 16) = dwLoc28;
					edi_101 = dwLoc28;
				}
				Mem119[ebx_118 + 0x04:word32] = eax_112 + ecx | 0x01;
				*((word32) eax + 56) = ebx_118;
l08059013:
				ebx_118 = eax_68;
			} while (eax_68 != 0x00);
		}
		Eq_2 v14_293 = (word32) dwLoc38_350 + 4;
		dwLoc38_350 = v14_293;
	} while ((word32) eax + 56 != v14_293);
	ecxOut = ecx;
	edxOut = edx_109;
	ebxOut = ebx;
	ebpOut = ebp;
	ediOut = edi;
	return v14_293;
}

// subject_text_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080591F0: Register Eq_2 new_heap(Register Eq_2 eax, Register up32 edx, Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut, Register out Eq_29047 edxOut)
// Called from:
//      malloc_consolidate
//      arena_get2.part.5
//      sysmalloc
Eq_2 new_heap(Eq_2 eax, up32 edx, struct Eq_9 * gs, ptr32 & ecxOut, union Eq_29047 & edxOut)
{
	Eq_2 ebx_143;
	Eq_29047 edx_134 = (word32) eax + edx;
	ptr32 esp_21 = fp - 44;
	ptr32 ecx_133 = 0x080CE9B0;
	Eq_2 esi_23 = _dl_pagesize;
	if (edx_134 > 0x7FFF)
	{
		if (edx_134 > 0x00100000)
		{
			edx_134.u0 = 0x00100000;
			if (eax > 0x00100000)
				goto l08059320;
		}
	}
	else
		edx_134.u0 = 0x8000;
	Eq_2 ebx_140;
	ptr32 esp_139;
	Eq_2 esi_36 = -esi_23 & (word32) esi_23 + (edx_134 - 0x01);
	Eq_2 eax_39 = aligned_heap_area;
	if (eax_39 != 0x00)
	{
		word32 ecx_357;
		word32 edx_358;
		Eq_2 eax_60 = mmap(gs, eax_39, 0x00100000, 0x00, 0x4022, ~0x00, 0x00, out ecx_357, out edx_358);
		aligned_heap_area.u0 = 0x00;
		esp_21 = fp - 44;
		ebx_140 = eax_60;
		if (eax_60 != ~0x00)
		{
			if ((eax_60 & 0x000FFFFF) == 0x00)
				goto l080592D7;
			word32 edx_360;
			word32 ebx_361;
			word32 ecx_359;
			__munmap(eax_60, gs, eax_60, 0x00100000, out ecx_359, out edx_360, out ebx_361);
			esp_21 = fp - 0x28;
		}
	}
	struct Eq_29277 * esp_93 = esp_21 - 0x08;
	esp_93->tFFFFFFFC.u0 = 0x00;
	esp_93->tFFFFFFF8.u0 = ~0x00;
	esp_93->tFFFFFFF4.u0 = 0x4022;
	esp_93->dwFFFFFFF0 = 0x00;
	esp_93->tFFFFFFEC.u0 = 0x00200000;
	esp_93->tFFFFFFE8.u0 = 0x00;
	word32 ecx_355;
	word32 edx_356;
	Eq_2 eax_108 = mmap(gs, esp_93->tFFFFFFE8, esp_93->tFFFFFFEC, esp_93->dwFFFFFFF0, esp_93->tFFFFFFF4, esp_93->tFFFFFFF8, esp_93->tFFFFFFFC, out ecx_355, out edx_356);
	ptr32 esp_115 = (char *) &esp_93->tFFFFFFFC + 0x0C;
	if (eax_108 != ~0x00)
	{
		Eq_2 ebx_164;
		Eq_2 ebx_150 = (word32) eax_108 + 0x000FFFFF & 0xFFF00000;
		Eq_2 edx_153 = ebx_150 - eax_108;
		if (edx_153 == 0x00)
		{
			aligned_heap_area = (word32) ebx_150 + 0x00100000;
			ebx_164 = ebx_150;
		}
		else
		{
			esp_93->tFFFFFFFC = edx_153;
			esp_93->t0014 = edx_153;
			esp_93->tFFFFFFF8 = eax_108;
			word32 ecx_362;
			word32 edx_363;
			__munmap(ebx_150, gs, esp_93->tFFFFFFF8, esp_93->tFFFFFFFC, out ecx_362, out edx_363, out ebx_164);
			esp_115 = (char *) &esp_93->tFFFFFFFC + 16;
			edx_153 = esp_93->t0018;
		}
		struct Eq_29507 * esp_179 = esp_115 - 0x08;
		esp_179->tFFFFFFFC = 0x00100000 - edx_153;
		esp_179->tFFFFFFF8 = (word32) ebx_150 + 0x00100000;
		word32 ecx_364;
		word32 edx_365;
		__munmap(ebx_164, gs, esp_179->tFFFFFFF8, esp_179->tFFFFFFFC, out ecx_364, out edx_365, out ebx_140);
l080592D7:
		esp_139 = fp - 44;
		ptr32 ecx_216;
		Eq_29047 edx_217;
		if (mprotect(gs, ebx_140, esi_36, 0x03, out ecx_216, out edx_217) == 0x00)
		{
			*((word32) ebx_140 + 8) = esi_36;
			*((word32) ebx_140 + 0x0C) = esi_36;
			ecxOut = ecx_216;
			edxOut = edx_217;
			return ebx_140;
		}
		goto l08059360;
	}
	esp_93->tFFFFFFFC.u0 = 0x00;
	esp_93->tFFFFFFF8.u0 = ~0x00;
	esp_93->tFFFFFFF4.u0 = 0x4022;
	esp_93->dwFFFFFFF0 = 0x00;
	esp_93->tFFFFFFEC.u0 = 0x00100000;
	esp_93->tFFFFFFE8.u0 = 0x00;
	Eq_2 eax_132 = mmap(gs, esp_93->tFFFFFFE8, esp_93->tFFFFFFEC, esp_93->dwFFFFFFF0, esp_93->tFFFFFFF4, esp_93->tFFFFFFF8, esp_93->tFFFFFFFC, out ecx_133, out edx_134);
	esp_139 = (char *) &esp_93->tFFFFFFFC + 0x0C;
	ebx_140 = eax_132;
	if (eax_132 != ~0x00)
	{
		if ((eax_132 & 0x000FFFFF) != 0x00)
		{
l08059360:
			struct Eq_29386 * esp_228 = esp_139 - 0x08;
			esp_228->tFFFFFFFC.u0 = 0x00100000;
			esp_228->tFFFFFFF8 = ebx_140;
			__munmap(0x00, gs, esp_228->tFFFFFFF8, esp_228->tFFFFFFFC, out ecx_133, out edx_134, out ebx_143);
			goto l08059322;
		}
		goto l080592D7;
	}
l08059320:
	ebx_143.u0 = 0x00;
l08059322:
	ecxOut = ecx_133;
	edxOut = edx_134;
	return ebx_143;
}

// 080593A0: Register Eq_2 munmap_chunk(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out Eq_29538 ecxOut, Register out (ptr32 Eq_29539) edxOut, Register out (ptr32 Eq_29540) ebxOut)
// Called from:
//      _int_free
//      free_check.part.3
//      realloc_check
//      free
//      __realloc
Eq_2 munmap_chunk(Eq_2 eax, struct Eq_9 * gs, union Eq_29538 & ecxOut, struct Eq_29539 & edxOut, struct Eq_29540 & ebxOut)
{
	Eq_2 esi_14 = *((word32) eax + 4);
	Eq_2 ecx_23 = _dl_pagesize;
	if ((esi_14 & 0x02) != 0x00)
	{
		ui32 edx_38 = *eax;
		Eq_2 esi_43 = eax - edx_38;
		Eq_2 edx_44 = edx_38 + (esi_14 & ~0x07);
		word32 eax_42 = eax + 0x08 & ecx_23 - 0x01;
		if ((ecx_23 - 0x01 & (esi_43 | edx_44) | eax_42 & eax_42 - 0x01) == 0x00)
		{
			__lock();
			--g_t80CE4B4;
			__lock();
			g_t80CE4C4 = (word32) g_t80CE4C4 + -edx_44;
			Eq_29538 ecx_84;
			struct Eq_29539 * edx_85;
			word32 ebx_136;
			Eq_2 eax_82 = __munmap(0x080CE000, gs, esi_43, edx_44, out ecx_84, out edx_85, out ebx_136);
			ecxOut = ecx_84;
			edxOut = edx_85;
			ebxOut = esi;
			return eax_82;
		}
	}
	else
	{
		word32 eax_131;
		word32 ecx_132;
		word32 edx_133;
		__malloc_assert(134883630, 0x0B00, 0x080A2925, out eax_131, out ecx_132, out edx_133);
	}
	word32 ecx_134;
	word32 edx_135;
	Eq_2 eax_60 = malloc_printerr(out ecx_134, out edx_135);
	struct Eq_29539 * edx_66;
	Eq_29538 ecx_67;
	Eq_2 eax_65 = mremap_chunk(eax_60, edx, gs, out ecx_67, out edx_66);
	ecxOut = ecx_67;
	edxOut = edx_66;
	ebxOut = (struct Eq_29540 *) &g_t80CE000;
	return eax_65;
}

// 08059440: Register Eq_2 mremap_chunk(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      munmap_chunk
//      realloc_check
//      __realloc
Eq_2 mremap_chunk(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_225;
	struct Eq_29638 * esp_109 = fp - 44;
	Eq_2 edi_20 = *((word32) eax + 4);
	Eq_2 esi_21 = *eax;
	Eq_2 edx_30 = _dl_pagesize;
	if ((edi_20 & 0x02) != 0x00)
	{
		Eq_2 edx_103;
		Eq_2 ecx_112;
		Eq_2 edi_45 = (word32) esi_21 + (edi_20 & ~0x07);
		Eq_2 ebp_48 = eax - esi_21;
		word32 ecx_51 = eax + 0x08 & edx_30 - 0x01;
		if (((ebp_48 | edi_45) & edx_30 - 0x01 | ecx_51 & ecx_51 - 0x01) != 0x00)
		{
			word32 ecx_270;
			word32 edx_271;
			malloc_printerr(out ecx_270, out edx_271);
			goto l08059590;
		}
		Eq_2 edx_71 = -edx_30 & (word32) esi_21 + ((word32) edx + ((word32) edx_30 + 3));
		edx_225 = edi_45;
		if (edi_45 != edx_71)
		{
			Eq_2 eax_101 = __mremap(gs, ebp_48, edi_45, edx_71, 0x01, dwLoc2C, out edx_103);
			esp_109 = fp - 0x28;
			if (eax_101 == ~0x00)
				goto l080595B0;
			ecx_112 = eax_101 + esi_21;
			if (((byte) ((word64) ecx_112.u0 + 8) & 0x0F) == 0x00)
			{
				if (*ecx_112.u0 != esi_21)
				{
					word32 edx_275;
					word32 eax_274;
					__malloc_assert(134883678, 0x0B40, 0x080A2925, out eax_274, out ecx_112, out edx_275);
					esp_109 = fp - 0x38;
				}
				Eq_2 edi_159 = edx_71 - esp_109->dw0004;
				*((word64) ecx_112.u0 + 4) = edx_71 - esi_21 | 0x02;
				__lock();
				g_t80CE4C4 = __xadd(g_t80CE4C4, edi_159);
				edx_103.u0 = 1224;
				do
				{
					Eq_2 eax_175 = g_t80CE4C8;
					if (edi_159 * 0x02 <= eax_175)
						break;
					__lock();
					word32 eax_179;
				} while (__cmpxchg(g_t80CE4C8, edi_159 * 0x02, eax_175, out eax_179));
l08059539:
				ecxOut = ecx_112;
				edxOut = edx_103;
				return ecx_112;
			}
l08059590:
			esp_109->ptrFFFFFFF0 = 0x080A3950;
			word32 eax_272;
			word32 ecx_273;
			__malloc_assert(134883651, 2878, 0x080A2925, out eax_272, out ecx_273, out edx_103);
l080595B0:
			ecx_112.u0 = 0x00;
			goto l08059539;
		}
	}
	else
	{
		word32 ecx_269;
		__malloc_assert(134883630, 0x0B26, 0x080A2925, out eax, out ecx_269, out edx_225);
	}
	ecxOut = eax;
	edxOut = edx_225;
	return eax;
}

// 080595C0: Register ptr32 ptmalloc_init(Register (ptr32 Eq_9) gs)
// Called from:
//      malloc_hook_ini
//      memalign_hook_ini
//      realloc_hook_ini
//      __valloc
//      __pvalloc
//      malloc_trim
//      mallinfo
//      __malloc_stats
//      __mallopt
//      malloc_info
ptr32 ptmalloc_init(struct Eq_9 * gs)
{
	ui32 eax_14 = gs->dw0014;
	if (__libc_malloc_initialized < 0x00)
	{
		__libc_malloc_initialized = 0x00;
		gs->tFFFFFFEC.u0 = 0x080CE500;
		struct Eq_29810 * eax_26 = &g_t80CE538;
		do
		{
			eax_26->dw000C = eax_26;
			eax_26[1] = (struct Eq_29810) eax_26;
			++eax_26;
		} while (eax_26 != &g_t80CE930);
		g_t80CE538.u0 = 0x080CE538;
		global_max_fast.u0 = 0x40;
		g_dw80CE508 = 0x00;
		__tunable_get_val(0x17, fp - 0x14, &g_t8059BF0);
		__tunable_get_val(0x09, fp - 0x14, &g_t8058C50);
		__tunable_get_val(0x03, fp - 0x14, &g_t8058CF0);
		__tunable_get_val(0x12, fp - 0x14, &g_t8058C80);
		__tunable_get_val(0x02, fp - 0x14, &g_t8058C20);
		__tunable_get_val(0x0A, fp - 0x14, &g_t8058CC0);
		__tunable_get_val(0x11, fp - 0x14, &g_t80587A0);
		__tunable_get_val(0x14, fp - 0x14, &g_t80587C0);
		__tunable_get_val(22, fp - 0x14, &g_t80587E0);
		__tunable_get_val(0x13, fp - 0x14, &g_t8058820);
		__tunable_get_val(0x0C, fp - 0x14, &g_t8058850);
		__libc_malloc_initialized = 0x01;
	}
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return ebx;
	word32 ecx_314;
	word32 edx_315;
	__stack_chk_fail(out ecx_314, out edx_315);
	word32 ebx_317;
	word32 esi_318;
	word32 edi_319;
	arena_get2.part.5(eax, edx_240, gs, out ebx_317, out esi_318, out edi_319);
	return 0x080CE000;
}

// 08059730: Register Eq_2 arena_get2.part.5(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_29909 ebxOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      ptmalloc_init
//      arena_get_retry
//      tcache_init.part.6
//      __libc_malloc
//      _mid_memalign
//      __libc_calloc
Eq_2 arena_get2.part.5(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_29909 & ebxOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_2 edi_13 = eax;
	uint32 eax_23 = narenas_limit.12605;
	Eq_2 edx_24 = narenas;
	if (eax_23 == 0x00)
	{
		eax_23 = g_dw80CE4B0;
		if (eax_23 == 0x00)
			goto l080598A0;
		narenas_limit.12605 = eax_23;
	}
l0805976A:
	while (true)
	{
		Eq_2 esi_318;
		if (eax_23 - 0x01 < edx_24)
			break;
		Eq_2 ecx_38 = (word32) edx_24 + 1;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 eax_49;
		__cmpxchg(narenas, ecx_38, edx_24, out eax_49);
		if (eax_49 == edx_24)
		{
			word32 edx_794;
			word32 ecx_793;
			Eq_2 eax_59 = new_heap((word64) edi_13.u0 + 0x0484, g_dw80CE4A4, gs, out ecx_793, out edx_794);
			Eq_2 edx_66 = eax_59;
			if (eax_59 == 0x00)
			{
				word32 ecx_795;
				word32 edx_796;
				Eq_2 eax_72 = new_heap(0x0484, g_dw80CE4A4, gs, out ecx_795, out edx_796);
				edx_66 = eax_72;
				if (eax_72 == 0x00)
				{
l08059B03:
					if (gs->t000C != 0x00)
						__lock();
					--narenas;
					esi_318.u0 = 0x00;
					goto l08059868;
				}
			}
			Eq_2 esi_84 = (word32) edx_66 + 24;
			*edx_66 = esi_84;
			struct Eq_30044 * eax_85 = (word32) edx_66 + 80;
			struct Eq_30044 * ecx_87 = (word32) edx_66 + 0x0448;
			esi_318 = esi_84;
			do
			{
				eax_85->dw000C = eax_85;
				eax_85[1] = (struct Eq_30044) eax_85;
				++eax_85;
			} while (ecx_87 != eax_85);
			if (esi_84 != 0x080CE500)
				*((word32) edx_66 + 28) |= 0x02;
			else
				global_max_fast.u0 = 0x40;
			Eq_2 eax_110 = *((word32) edx_66 + 8);
			((word32) edx_66 + 32)->u0 = 0x00;
			*((word32) edx_66 + 1128) = 0x01;
			*((word32) edx_66 + 1136) = eax_110;
			*((word32) edx_66 + 1132) = eax_110;
			Eq_30099 ebp_111 = (word32) edx_66 + 1148;
			Eq_2 ecx_113 = (word32) edx_66 + 0x0474;
			if ((ebp_111 & 0x0F) != 0x00)
				ecx_113 = ecx_113 - (ebp_111 & 0x0F) + 0x10;
			*((word32) edx_66 + 80) = ecx_113;
			Mem131[ecx_113 + 0x04:word32] = eax_110 + edx_66 - ecx_113 | 0x01;
			Eq_2 ecx_139 = gs->tFFFFFFEC;
			gs->tFFFFFFEC = esi_84;
			((word32) edx_66 + 24)->u0 = 0x00;
			Eq_2 ecx_147 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_161;
			if (!__cmpxchg(list_lock, 0x01, 0x00, out eax_161))
				ecx_147 = __lll_lock_wait_private(eax_161, 0x080CF880, gs);
			*((word32) edx_66 + 1120) = g_t80CE948;
			g_t80CE948 = esi_84;
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v18_185 = list_lock - 0x01;
			list_lock = v18_185;
			if (v18_185 != 0x00)
				__lll_unlock_wake_private(0x080CF880, ecx_147, edx_66, gs);
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_214;
			if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_214))
				__lll_lock_wait_private(eax_214, 0x080CF888, gs);
			Eq_2 edx_256;
			Eq_2 ecx_258 = detach_arena(ecx_139, out edx_256);
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v20_265 = free_list_lock - 0x01;
			free_list_lock = v20_265;
			if (v20_265 != 0x00)
				__lll_unlock_wake_private(0x080CF888, ecx_258, edx_256, gs);
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_290;
			if (!__cmpxchg(*esi_84, 0x01, 0x00, out eax_290))
				__lll_lock_wait_private(eax_290, esi_84, gs);
			if (esi_84 != 0x00)
				goto l08059868;
			goto l08059B03;
		}
		edx_24 = narenas;
		eax_23 = narenas_limit.12605;
	}
	esi_318 = next_to_use.12583;
	if (esi_318 == 0x00)
	{
		next_to_use.12583.u0 = 0x080CE500;
		esi_318.u0 = 0x080CE500;
	}
	do
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_345;
		__cmpxchg(*esi_318.u0, 0x01, 0x00, out eax_345);
		if (eax_345 == 0x00)
			goto l080597B8;
		esi_318 = *((word64) esi_318.u0 + 0x0448);
		Eq_2 edx_353 = next_to_use.12583;
	} while (esi_318 != edx_353);
	if (edx == edx_353)
		edx_353 = *((word32) edx + 0x0448);
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_375;
	if (!__cmpxchg(*edx_353, 0x01, 0x00, out eax_375))
		__lll_lock_wait_private(eax_375, edx_353, gs);
	esi_318 = edx_353;
l080597B8:
	edi_13.u0 = ~0x13;
	Eq_2 edx_394 = gs->tFFFFFFEC;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_405;
	if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_405))
		__lll_lock_wait_private(eax_405, 0x080CF888, gs);
	Eq_2 edx_448;
	Eq_2 ecx_450 = detach_arena(edx_394, out edx_448);
	Eq_2 eax_453 = free_list;
	if (eax_453 == 0x00)
	{
l08059832:
		*((word64) esi_318.u0 + 1104) = (word32) *((word64) esi_318.u0 + 1104) + 1;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v17_553 = free_list_lock - 0x01;
		free_list_lock = v17_553;
		if (v17_553 != 0x00)
			__lll_unlock_wake_private(0x080CF888, ecx_450, edx_448, gs);
		gs->tFFFFFFEC = esi_318;
		next_to_use.12583 = *((word64) esi_318.u0 + 0x0448);
l08059868:
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return esi_318;
	}
	if (*((word32) eax_453 + 1104) == 0x00)
	{
		if (esi_318 != eax_453)
		{
			edx_448 = *((word32) eax_453 + 0x044C);
			while (edx_448 != 0x00)
			{
				ecx_450 = *((word64) edx_448.u0 + 1104);
				if (ecx_450 != 0x00)
					goto l08059878;
				if (esi_318 == edx_448)
				{
					edx_448 = (word32) eax_453 + 0x044C;
					eax_453 = esi_318;
					goto l08059958;
				}
				eax_453 = edx_448;
				edx_448 = *((word32) edx_448 + 0x044C);
			}
		}
		else
		{
			edx_448.u0 = 0x080CF884;
l08059958:
			*edx_448 = *((word32) eax_453 + 0x044C);
		}
		goto l08059832;
	}
l08059878:
	word32 ecx_797;
	__malloc_assert(0x080A2976, 0x031B, 0x080A28A8, out eax_23, out ecx_797, out edx_24);
l080598A0:
	if (g_t80CE4AC < edx_24)
	{
		int32 eax_511 = get_nprocs(gs);
		if (eax_511 > 0x00)
		{
			edx_24 = narenas;
			narenas_limit.12605 = eax_511 * 0x02;
			eax_23 = eax_511 * 0x02;
		}
		else
		{
			narenas_limit.12605 = 0x04;
			edx_24 = narenas;
			eax_23 = 0x04;
		}
	}
	goto l0805976A;
}

// 08059B50: Register Eq_2 arena_get_retry(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      tcache_init.part.6
//      __libc_malloc
//      _mid_memalign
//      __libc_calloc
Eq_2 arena_get_retry(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 eax_110;
	if (eax == 0x080CE500)
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v11_27 = g_t80CE500 - 0x01;
		g_t80CE500 = v11_27;
		if (v11_27 != 0x00)
			__lll_unlock_wake_private(0x080CE500, ecx, edx, gs);
		word32 edi_196;
		word32 esi_195;
		word32 ebx_194;
		word32 edx_193;
		word32 ecx_192;
		eax_110 = get_free_list(gs, out ecx_192, out edx_193, out ebx_194, out esi_195, out edi_196);
		if (eax_110 != 0x00)
			return eax_110;
		word32 ebx_197;
		word32 esi_198;
		word32 edi_199;
		return arena_get2.part.5(edx, eax, gs, out ebx_197, out esi_198, out edi_199);
	}
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 v12_75 = *eax - 0x01;
		*eax = v12_75;
		if (v12_75 != 0x00)
			__lll_unlock_wake_private(eax, ecx, edx, gs);
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_96;
		if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_96))
			__lll_lock_wait_private(eax_96, 0x080CE500, gs);
		eax_110.u0 = 0x080CE500;
		return eax_110;
	}
}

// 08059BF0: void _dl_tunable_set_mallopt_check(Stack (ptr32 word32) dwArg04)
void _dl_tunable_set_mallopt_check(word32 * dwArg04)
{
	if (*dwArg04 != 0x00)
	{
		using_malloc_checking = 0x01;
		__malloc_hook = &g_t805C510;
		__free_hook.u0 = 0x0805CAB0;
		__realloc_hook = &g_t805CE40;
		__memalign_hook = &g_t805C8C0;
	}
}

// 08059C50: void __malloc_info.part.10(Register (ptr32 Eq_9) gs)
// Called from:
//      malloc_info
void __malloc_info.part.10(struct Eq_9 * gs)
{
	ui32 eax_24 = gs->dw0014;
	Eq_2 dwLoc091C_1121 = 0x080CE500;
	do
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		word32 ebx_1359;
		word32 edi_1360;
		__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1359, out edi_1360);
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_74;
		if (!__cmpxchg(*dwLoc091C_1121, 0x01, 0x00, out eax_74))
			__lll_lock_wait_private(eax_74, dwLoc091C_1121, gs);
		struct Eq_30512 * ecx_102 = fp - 0x08C0;
		word32 * ebx_146 = (word32) dwLoc091C_1121 + 0x0C;
		do
		{
			int32 edx_104;
			struct Eq_30520 * eax_115 = *ebx_146;
			if (eax_115 != null)
			{
				ui32 esi_109 = eax_115->dw0004;
				edx_104 = 0x00;
				do
				{
					eax_115 = eax_115->ptr0008;
					++edx_104;
				} while (eax_115 != null);
				ecx_102->dw0004 = esi_109 & ~0x07;
				ecx_102->dw000C = edx_104;
				ecx_102->dw0000 = (esi_109 & ~0x07) - 0x0F;
			}
			else
			{
				ecx_102->dw000C = 0x00;
				ecx_102->dw0004 = 0x00;
				ecx_102->dw0000 = 0x00;
				edx_104 = 0x00;
			}
			++ecx_102;
			ecx_102->dwFFFFFFF8 = edx_104 *s ecx_102->dw0004;
			++ebx_146;
		} while (ecx_102 != fp - 0x0810);
		struct Eq_30566 * esi_155 = fp - 0x0810;
		Eq_2 dwLoc0930_633 = (word32) dwLoc091C_1121 + 56;
		do
		{
			esi_155->dw0000 = ~0x00;
			esi_155->dw000C = 0x00;
			Eq_2 edx_172 = *((word32) dwLoc0930_633 + 8);
			esi_155->dw0008 = 0x00;
			esi_155->dw0004 = 0x00;
			if (edx_172 != 0x00 && edx_172 != dwLoc0930_633)
			{
				word32 edi_181 = 0x01;
				Eq_2 ecx_182 = 0x00;
				Eq_2 ebx_183 = ~0x00;
				word32 ebp_184 = 0x00;
				while (true)
				{
					Eq_2 eax_190 = *((word32) edx_172 + 4);
					edx_172 = *((word32) edx_172 + 8);
					ebp_184 = (word32) eax_190 + ebp_184;
					if (ebx_183 > eax_190)
						ebx_183 = eax_190;
					if (ecx_182 < eax_190)
						ecx_182 = eax_190;
					word32 eax_207 = edi_181 + 0x01;
					if (edx_172 == dwLoc0930_633)
						break;
					edi_181 = eax_207;
				}
				esi_155->dw000C = edi_181;
				esi_155->dw0008 = ebp_184;
				esi_155->dw0000 = (word32) ebx_183;
				esi_155->dw0004 = (word32) ecx_182;
				if (edi_181 == 0x00)
					goto l08059DE8;
			}
			else
			{
l08059DE8:
				esi_155->dw0000 = 0x00;
			}
			++esi_155;
			dwLoc0930_633 = (word32) dwLoc0930_633 + 8;
		} while (esi_155 != fp - 0x20);
		if (dwLoc091C_1121 != 0x080CE500)
		{
			edx_172.u0 = 0x00;
			struct Eq_30772 * eax_259 = *((word32) dwLoc091C_1121 + 56) & 0xFFF00000;
			do
			{
				edx_172 = (word64) edx_172.u0 + eax_259->dw000C;
				eax_259 = eax_259->ptr0004;
			} while (eax_259 != null);
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v21_302 = *dwLoc091C_1121 - 0x01;
		*dwLoc091C_1121 = v21_302;
		if (v21_302 != 0x00)
			__lll_unlock_wake_private(dwLoc091C_1121, dwLoc091C_1121, edx_172, gs);
		struct Eq_30662 * ebp_332 = fp - 0x08C0 + 0x0C;
		word32 ebx_341;
		for (ebx_341 = 0x00; ebx_341 != 0x8A; ++ebx_341)
		{
			word32 eax_347 = ebp_332->dw0000;
			if (ebx_341 != 11 && eax_347 != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				word32 ebx_1363;
				word32 edi_1364;
				__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1363, out edi_1364);
			}
			++ebp_332;
		}
		if (dwLoc0804 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 ebx_1389;
			word32 edi_1390;
			__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1389, out edi_1390);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		word32 edi_1368;
		word32 ebx_1367;
		__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1367, out edi_1368);
		if (dwLoc091C_1121 != 0x080CE500)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 edi_1372;
			word32 ebx_1371;
			__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1371, out edi_1372);
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 ebx_1385;
			word32 edi_1386;
			__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1385, out edi_1386);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		fputs(gs, stackArg4, stackArg8);
		Eq_2 ecx_500 = *((word32) dwLoc091C_1121 + 0x0448);
		dwLoc091C_1121 = ecx_500;
	} while (ecx_500 != 0x080CE500);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	word32 ebx_1377;
	word32 edi_1378;
	__fprintf(ebx, gs, stackArg4, stackArg8, out ebx_1377, out edi_1378);
	if ((eax_24 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_1379;
	word32 edx_1380;
	Eq_2 eax_555 = __stack_chk_fail(out ecx_1379, out edx_1380);
	word32 edx_1382;
	word32 ecx_1381;
	systrim.isra.1.constprop.11(eax_555, out ecx_1381, out edx_1382);
}

// 0805A100: Register Eq_2 systrim.isra.1.constprop.11(Register Eq_2 eax, Register out Eq_30750 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _int_free
//      malloc_trim
//      malloc_info
Eq_2 systrim.isra.1.constprop.11(Eq_2 eax, union Eq_30750 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 eax_100;
	Eq_2 ebx_20 = *((word32) g_t80CE538 + 4);
	Eq_2 edx_141 = (ebx_20 & ~0x07) - 0x11;
	if (edx_141 > eax)
	{
		edx_141 -= eax;
		ecx = -_dl_pagesize;
		ui32 edi_31 = ecx & edx_141;
		if (edi_31 != 0x00)
		{
			word32 eax_40;
			__morecore();
			if (eax_40 == (word32) g_t80CE538 + (ebx_20 & ~0x07))
			{
				ui32 eax_51 = -edi_31;
				word32 ecx_58;
				__morecore();
				<anonymous> * eax_60 = __after_morecore_hook;
				if (eax_60 != null)
				{
					word32 ecx_67;
					eax_60();
				}
				word32 eax_81;
				__morecore();
				if (eax_81 != 0x00)
				{
					ui32 ebp_88 = eax_40 - eax_81;
					if (ebp_88 != 0x00)
					{
						Eq_2 eax_91 = g_t80CE538;
						g_dw80CE954 -= ebp_88;
						*((word32) eax_91 + 4) = (ebx_20 & ~0x07) - ebp_88 | 0x01;
						eax_100.u0 = 0x01;
l0805A155:
						ecxOut = ecx;
						edxOut = edx_141;
						return eax_100;
					}
				}
			}
		}
	}
	eax_100.u0 = 0x00;
	goto l0805A155;
}

// 0805A1C0: Register Eq_2 _int_free(Register Eq_2 eax, Register Eq_2 edx, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_30873 ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out Eq_2 ediOut, Register out (ptr32 Eq_9) gsOut)
// Called from:
//      sysmalloc
//      _int_memalign
//      free_check.part.3
//      _int_realloc
//      free
//      __realloc
Eq_2 _int_free(Eq_2 eax, Eq_2 edx, Eq_2 edi, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_30873 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, union Eq_2 & ediOut, struct Eq_9 & gsOut)
{
	ui32 dwLoc20_1733;
	ptr32 dwLoc04_1938;
	Eq_2 dwLoc08_1870;
	struct Eq_9 * gs_1004;
	Eq_2 ebp_1029;
	Eq_2 ebx_1006;
	Eq_2 eax_1047;
	struct Eq_30885 * edx_1049;
	Eq_2 edx_1069;
	Eq_2 edi_1032;
	Eq_2 esi_1016;
	Eq_2 ecx_1068;
	Eq_2 ecx_1434;
	Eq_2 eax_1433;
	Eq_2 edx_1406;
	Eq_2 ecx_1405;
	Eq_2 eax_511;
	Eq_30873 dwLoc10_1734;
	byte al_528;
	ptr32 dwLoc0C_1802;
	Eq_2 eax_29 = *((word32) edx + 4);
	struct Eq_30902 * esp_100 = fp - 0x4C;
	ui32 eax_26 = gs->dw0014;
	byte al_60 = (byte) eax_29;
	if (edx <= -(eax_29 & ~0x07))
	{
		edx_1069 = edx + 0x08 & 0x0F;
		if (edx_1069 == 0x00)
		{
			if ((eax_29 & ~0x07) > 0x0F && (al_60 & 0x08) == 0x00)
			{
				Eq_2 eax_123 = gs->tFFFFFFE4;
				edi_1032 = edi;
				if (eax_123 == 0x00)
				{
l0805A25C:
					dwLoc20_1733 = eax_26;
					dwLoc04_1938 = ebp;
					dwLoc08_1870 = edi;
					dwLoc0C_1802 = esi;
					dwLoc10_1734 = ebx;
					ebp_1029 = eax;
					gs_1004 = gs;
					ebx_1006.u0 = 0x080CE000;
					esi_1016 = eax_29 & ~0x07;
					struct Eq_30949 * eax_160 = esp_100->ptr0000;
					if ((eax_29 & ~0x07) <= global_max_fast)
					{
						edi_1032 = eax_160 + (eax_29 & ~0x07) / 8;
						Eq_2 eax_394 = *((word32) edi_1032 + 4);
						if (eax_394 > 0x08 && (eax_394 & ~0x07) < *((word32) eax + 0x0454))
							goto l0805A289;
l0805A550:
						dwLoc20_1733 = eax_26;
						dwLoc04_1938 = ebp;
						dwLoc08_1870 = edi;
						dwLoc0C_1802 = esi;
						dwLoc10_1734 = ebx;
						ebx_1006.u0 = 0x080CE000;
						ebp_1029 = eax;
						gs_1004 = gs;
						if (esp_100[1] == 0x00)
						{
							Eq_2 eax_408 = esp_100[1];
							if (gs->t000C != 0x00)
								__lock();
							word32 eax_418;
							if (!__cmpxchg(*eax, 0x01, eax_408, out eax_418))
								__lll_lock_wait_private(eax_418, eax, gs);
							Eq_2 eax_432 = *((word32) edi_1032 + 4);
							Eq_2 ecx_433 = 0x01;
							if (eax_432 > 0x08)
								ecx_433 = (uint32) (int8) ((eax_432 & ~0x07) >= *((word32) eax + 0x0454));
							if (gs->t000C != 0x00)
								__lock();
							Eq_2 v26_450 = *eax - 0x01;
							*eax = v26_450;
							if (v26_450 != 0x00)
								__lll_unlock_wake_private(eax, ecx_433, edx_1069, gs);
							if (ecx_433 == 0x00)
							{
l0805A289:
								Eq_2 eax_519 = perturb_byte;
								al_528 = (byte) eax_519;
								if (eax_519 == 0x00)
									goto l0805A297;
								goto l0805A790;
							}
						}
						word32 edx_2114;
						word32 ecx_2113;
						eax_511 = malloc_printerr(out ecx_2113, out edx_2114);
						esi_1016 = eax_29 & ~0x07;
l0805A5B8:
						Eq_2 ecx_756 = eax_511 & ~0x07;
						if (ecx_756 != Mem758[edi_1032 + ecx_756:word32])
							goto l0805A95C;
						Eq_2 ecx_762 = *((word32) edi_1032 + 8);
						edx_1406 = ecx_762;
						Eq_2 ecx_764 = *((word32) edi_1032 + 0x0C);
						if (*((word32) ecx_762 + 0x0C) == edi_1032 && *((word32) ecx_764 + 8) == edi_1032)
						{
							*((word32) ecx_762 + 0x0C) = ecx_764;
							*((word32) ecx_764 + 8) = ecx_762;
							if (eax_511 <= 1007)
								goto l0805A5F0;
							ecx_1405 = *((word32) edi_1032 + 16);
							if (ecx_1405 == 0x00)
							{
l0805A5F0:
								esi_1016 += Mem1471[esp_100 + 0x04:word32];
								goto l0805A451;
							}
l0805AAC4:
							if (*((word32) ecx_1405 + 20) == edi_1032)
							{
								Eq_2 eax_1413 = *((word32) edi_1032 + 20);
								if (*((word32) eax_1413 + 16) == edi_1032)
								{
									if (*((word32) edx_1406 + 16) != 0x00)
									{
										*((word32) ecx_1405 + 20) = eax_1413;
										*((word32) *((word32) edi_1032 + 20) + 16) = ecx_1405;
									}
									else if (ecx_1405 != edi_1032)
									{
										*((word32) edx_1406 + 20) = eax_1413;
										*((word32) edx_1406 + 16) = ecx_1405;
										*((word32) *((word32) edi_1032 + 16) + 20) = edx_1406;
										*((word32) *((word32) edi_1032 + 20) + 16) = edx_1406;
									}
									else
									{
										*((word32) edx_1406 + 20) = edx_1406;
										*((word32) edx_1406 + 16) = edx_1406;
									}
									goto l0805A5F0;
								}
							}
							goto l0805AB6F;
						}
						goto l0805A628;
					}
					ui32 eax_165 = eax_160->dw0004;
					if ((eax_165 & 0x02) != 0x00)
						goto l0805A4F0;
					if (gs->t000C != 0x00 && (esp_100[1] & 0x01) == 0x00)
					{
						if (gs->t000C != 0x00)
							__lock();
						word32 eax_186;
						if (!__cmpxchg(*eax, 0x01, eax_165 & 0x02, out eax_186))
							__lll_lock_wait_private(eax_186, eax, gs);
					}
					else
						esp_100[2] = (struct Eq_30902) 0x01;
					Eq_2 ecx_203 = esp_100->ptr0000;
					Eq_2 eax_207 = *((word32) eax + 56);
					edi_1032 = (word32) ecx_203 + (eax_29 & ~0x07);
					if (eax_207 != ecx_203)
					{
						if ((*((word32) eax + 4) & 0x02) != 0x00)
							goto l0805A345;
					}
					else
					{
						word32 edx_2117;
						word32 ecx_2116;
						eax_207 = malloc_printerr(out ecx_2116, out edx_2117);
					}
					if (edi_1032 >= (word32) eax_207 + (*((word32) eax_207 + 4) & ~0x07))
					{
						word32 ecx_2127;
						word32 edx_2128;
						malloc_printerr(out ecx_2127, out edx_2128);
l0805A860:
						word32 edx_2119;
						word32 ecx_2118;
						malloc_printerr(out ecx_2118, out edx_2119);
						esi_1016 = eax_29 & ~0x07;
l0805A870:
						word32 ebp_2094;
						word32 edi_2095;
						word32 ebx_2093;
						malloc_consolidate(ebp_1029, gs_1004, out ecx_1068, out edx_1069, out ebx_2093, out ebp_2094, out edi_2095);
l0805A4AA:
						if (ebp_1029 == (word32) ebx_1006 + 0x0500)
							goto l0805A8F8;
						edi_1032 = *((word32) ebp_1029 + 56);
						esp_100->ptr0000 = (struct Eq_155142 *) (edi_1032 & 0xFFF00000);
						if (*(edi_1032 & 0xFFF00000) != ebp_1029)
						{
							struct Eq_31601 * esp_1547 = esp_100 - 0x0C;
							esp_1547->ptrFFFFFFFC = (word32) ebx_1006 - 173700;
							word32 edx_2098;
							word32 ecx_2097;
							word32 eax_2096;
							__malloc_assert((word32) ebx_1006 - 177645, 0x1144, (word32) ebx_1006 - 177883, out eax_2096, out ecx_2097, out edx_2098);
							esp_100 = esp_1547 - 4;
l0805A4F0:
							word32 ebx_2115;
							munmap_chunk(esp_100->ptr0000, gs_1004, out ecx_1068, out edx_1069, out ebx_2115);
							goto l0805A2E4;
						}
						edx_1069 = esp_100->ptr0000;
						ecx_1068 = *((word32) ebx_1006 + 0x04A4);
						Eq_2 eax_876 = _dl_pagesize;
						esp_100[6] = (struct Eq_30902) ecx_1068;
						esp_100[4] = (struct Eq_30902) eax_876;
						esi_1016 = eax_876;
						if (edi_1032 == (word32) edx_1069 + 24)
						{
							Eq_2 eax_883 = *((word32) edx_1069 + 4);
							esi_1016 = ecx_1068 + 0x10 + eax_876;
							esp_100[5] = (struct Eq_30902) esi_1016;
							Eq_2 edx_886 = *((word32) eax_883 + 8);
							esp_100[1] = (struct Eq_30902) eax_883;
							esp_100[3] = (struct Eq_30902) edx_886;
							Eq_31899 eax_890 = (word32) eax_883 + (edx_886 - 0x08);
							eax_1047 = eax_890 & 0x0F;
							edx_1049 = (struct Eq_30885 *) (esp_100[1].ptr0000 + ((edx_886 - 0x08) - (eax_890 & 0x0F)) / 24);
							if (edx_1049->dw0004 != 0x01)
								goto l0805A8D4;
l0805A967:
							esp_100[7] = (struct Eq_30902) edi_1032;
l0805A96B:
							esi_1016 = edx_1049 - edx_1049->dw0000;
							Eq_2 ecx_903 = *((word32) esi_1016 + 4);
							uint32 eax_907 = (word32) eax_1047 + (ecx_903 & ~0x07);
							edx_1069 = eax_907 + 0x07;
							if (eax_907 > 0x17)
							{
l0805AAA4:
								struct Eq_31974 * esp_1391 = esp_100 - 0x0C;
								esp_1391->ptrFFFFFFFC = (word32) ebx_1006 - 173712;
								word32 eax_2109;
								__malloc_assert((word32) ebx_1006 - 175768, 0x0267, (word32) ebx_1006 - 178008, out eax_2109, out ecx_1405, out edx_1406);
								esp_100 = esp_1391 - 4;
								goto l0805AAC4;
							}
							ecx_1068 = ecx_903 & 0x01;
							edi_1032 = eax_907 + 0x08;
							if ((ecx_903 & 0x01) == 0x00)
							{
								Eq_2 eax_917 = (word32) *esi_1016 + (eax_907 + 0x08);
								edi_1032 = eax_917;
								if (eax_917 > 0x000FFFFF)
								{
									struct Eq_32022 * esp_925 = esp_100 - 0x0C;
									esp_925->ptrFFFFFFFC = (word32) ebx_1006 - 173712;
									word32 edx_2112;
									word32 eax_2110;
									word32 ecx_2111;
									__malloc_assert((word32) ebx_1006 - 175720, 0x026A, (word32) ebx_1006 - 178008, out eax_2110, out ecx_2111, out edx_2112);
									esp_100 = esp_925 - 4;
									goto l0805A9BD;
								}
							}
l0805A9D3:
							if (edi_1032 - Mem977[esp_100 + 0x0C:word32] + 0x00100000 >=u Mem977[esp_100 + 0x14:word32])
							{
								struct Eq_31627 * ecx_984 = esp_100->ptr0000;
								*((word32) ebp_1029 + 0x0454) -= ecx_984->t0008;
								if (*((word32) ebx_1006 + 6268) == (char *) (&ecx_984->t0008) + 0x000FFFF8)
									*((word32) ebx_1006 + 6268) = 0x00;
								struct Eq_31651 * esp_995 = esp_100 - 0x08;
								esp_995->tFFFFFFFC.u0 = 0x00100000;
								esp_995->tFFFFFFF8 = esp_995->t0008;
								word32 ecx_2099;
								word32 edx_2100;
								__munmap(ebx_1006, gs_1004, esp_995->tFFFFFFF8, esp_995->tFFFFFFFC, out ecx_2099, out edx_2100, out ebx_1006);
								esp_100 = (struct Eq_30902 *) &esp_995->t000C;
								if ((*((word32) esi_1016 + 4) & 0x01) != 0x00)
								{
l0805AA65:
									word32 eax_1108 = esi_1016 + edi_1032;
									if ((eax_1108 & esp_995->dw001C - 0x01) != 0x00)
									{
										esp_995->tFFFFFFFC = (word32) ebx_1006 - 173712;
										word32 eax_2102;
										word32 ecx_2103;
										word32 edx_2104;
										__malloc_assert((word32) ebx_1006 - 175676, 0x0276, (word32) ebx_1006 - 178008, out eax_2102, out ecx_2103, out edx_2104);
										esp_100 = esp_995 - 4;
										goto l0805AB6F;
									}
									ecx_1068 = esp_995->t0010;
									edx_1069 = Mem1104[ecx_1068 + 0x08:word32] + ecx_1068;
									if (eax_1108 != edx_1069)
									{
										esp_995->tFFFFFFFC = (word32) ebx_1006 - 173712;
										word32 ecx_2106;
										word32 edx_2107;
										word32 eax_2105;
										__malloc_assert((word32) ebx_1006 - 175612, 0x0277, (word32) ebx_1006 - 178008, out eax_2105, out ecx_2106, out edx_2107);
										esp_100 = esp_995 - 4;
										goto l0805AAA4;
									}
									*((word32) ebp_1029 + 56) = esi_1016;
									*((word32) esi_1016 + 4) = edi_1032 | 0x01;
									if (esi_1016 == (word32) esp_995->t0010 + 24)
									{
										edi_1032 = esp_995->t0010;
										esp_995->t0028 = esi_1016;
										Eq_2 ecx_1364 = *((word32) edi_1032 + 4);
										esp_995->t000C = edi_1032;
										Eq_2 eax_1366 = *((word32) ecx_1364 + 8);
										esp_995->t0018 = eax_1366;
										Eq_32099 eax_1369 = (word32) ecx_1364 + (eax_1366 - 0x08);
										eax_1047 = eax_1369 & 0x0F;
										edx_1049 = (word32) ecx_1364 + ((eax_1366 - 0x08) - (eax_1369 & 0x0F));
										if (edx_1049->dw0004 != 0x01)
										{
l0805A8D4:
											struct Eq_31920 * esp_1477 = esp_100 - 0x0C;
											esp_1477->ptrFFFFFFFC = (word32) ebx_1006 - 173712;
											word32 eax_2108;
											__malloc_assert((word32) ebx_1006 - 175812, 0x0264, (word32) ebx_1006 - 178008, out eax_2108, out ecx_1068, out edx_1069);
											esp_100 = esp_1477 - 4;
l0805A8F8:
											if ((*((word32) *((word32) ebx_1006 + 1336) + 4) & ~0x07) >= *((word32) ebx_1006 + 1184))
												systrim.isra.1.constprop.11(*((word32) ebx_1006 + 0x04A4), out ecx_1068, out edx_1069);
											goto l0805A6C8;
										}
										esp_995->t0010 = ecx_1364;
										goto l0805A96B;
									}
									esp_995->t000C = esp_995->t0010;
									edi_1032 = esi_1016;
									goto l0805A637;
								}
								esi_1016 -= *esi_1016;
								Eq_2 ecx_1021 = *((word32) esi_1016 + 4);
								if ((ecx_1021 & ~0x07) == Mem1001[esi_1016 + (ecx_1021 & ~0x07):word32])
								{
									Eq_2 eax_1051 = *((word32) esi_1016 + 8);
									Eq_2 edx_1052 = *((word32) esi_1016 + 0x0C);
									if (esi_1016 == *((word32) eax_1051 + 0x0C) && esi_1016 == *((word32) edx_1052 + 8))
									{
										*((word32) eax_1051 + 0x0C) = edx_1052;
										*((word32) edx_1052 + 8) = eax_1051;
										if (ecx_1021 <= 1007)
											goto l0805AA65;
										Eq_2 edx_1079 = *((word32) esi_1016 + 16);
										if (edx_1079 == 0x00)
											goto l0805AA65;
										if (esi_1016 != *((word32) edx_1079 + 20))
											goto l0805AB6F;
										Eq_2 ecx_1085 = *((word32) esi_1016 + 20);
										if (esi_1016 == *((word32) ecx_1085 + 16))
										{
											if (*((word32) eax_1051 + 16) != 0x00)
											{
												*((word32) edx_1079 + 20) = ecx_1085;
												*((word32) *((word32) esi_1016 + 20) + 16) = edx_1079;
											}
											else if (esi_1016 != edx_1079)
											{
												*((word32) eax_1051 + 16) = edx_1079;
												Eq_2 edx_1095 = *((word32) esi_1016 + 16);
												*((word32) eax_1051 + 20) = ecx_1085;
												*((word32) edx_1095 + 20) = eax_1051;
												*((word32) *((word32) esi_1016 + 20) + 16) = eax_1051;
											}
											else
											{
												*((word32) eax_1051 + 20) = eax_1051;
												*((word32) eax_1051 + 16) = eax_1051;
											}
											goto l0805AA65;
										}
										goto l0805AB6F;
									}
									goto l0805A628;
								}
l0805A95C:
								word32 ecx_2101;
								eax_1047 = malloc_printerr(out ecx_2101, out edx_1049);
								goto l0805A967;
							}
							goto l0805A633;
						}
						goto l0805A637;
					}
l0805A345:
					Eq_2 eax_264 = *((word32) edi_1032 + 4);
					esi_1016 = eax_29 & ~0x07;
					if (((byte) eax_264 & 0x01) != 0x00)
					{
						esp_100[1] = (struct Eq_30902) (eax_264 & ~0x07);
						edx_1069 = eax_264 & ~0x07;
						if (eax_264 > 0x08 && *((word32) eax + 0x0454) > (eax_264 & ~0x07))
						{
							Eq_2 eax_314 = perturb_byte;
							if (eax_314 != 0x00)
							{
								struct Eq_32402 * esp_318 = esp_100 - 0x04;
								esp_318->tFFFFFFFC = (eax_29 & ~0x07) - 0x08;
								esp_318->tFFFFFFF8 = eax_314;
								esp_318->tFFFFFFF4 = esp_318->t0010;
								word32 ecx_2122;
								memset(esp_318->tFFFFFFF4, esp_318->tFFFFFFF8, esp_318->tFFFFFFFC, out ecx_2122, out edx_1069);
							}
							struct Eq_32434 * ecx_340 = esp_100->ptr0000;
							if ((ecx_340->b0004 & 0x01) != 0x00)
								goto l0805A430;
							ui32 eax_344 = ecx_340->dw0000;
							struct Eq_32449 * ecx_345 = ecx_340 - eax_344;
							esp_100->ptr0000 = (struct Eq_155142 *) ecx_345;
							Eq_32454 ecx_349 = ecx_345->t0004;
							esp_100[3] = (struct Eq_30902) ecx_349;
							esi_1016 = (eax_29 & ~0x07) + eax_344;
							if ((ecx_349 & ~0x07) != eax_344)
							{
l0805A9BD:
								word32 ecx_2123;
								word32 edx_2124;
								malloc_printerr(out ecx_2123, out edx_2124);
								goto l0805A9C8;
							}
							if ((ecx_349 & ~0x07) != (esp_100->ptr0000)[(ecx_349 & ~0x07) / 24])
								goto l0805A95C;
							Eq_2 eax_357 = esp_100->ptr0000;
							ecx_1434 = *((word32) eax_357 + 8);
							edx_1069 = *((word32) eax_357 + 0x0C);
							if (*((word32) ecx_1434 + 0x0C) == eax_357 && *((word32) edx_1069 + 8) == esp_100->ptr0000)
							{
								Eq_32501 eax_365 = esp_100[3];
								*((word32) ecx_1434 + 0x0C) = edx_1069;
								*((word32) edx_1069 + 8) = ecx_1434;
								if (eax_365 > 1007)
								{
									Eq_2 eax_371 = esp_100->ptr0000->t0010;
									esp_100[3] = (struct Eq_30902) eax_371;
									if (eax_371 != 0x00)
									{
										if (*((word32) eax_371 + 20) != esp_100->ptr0000)
											goto l0805AB6F;
										eax_1433 = esp_100->ptr0000;
										edx_1069 = *((word32) eax_1433 + 20);
										if (*((word32) edx_1069 + 16) != eax_1433)
										{
l0805AB6F:
											eax_1433 = malloc_printerr(out ecx_1434, out edx_1069);
											goto l0805AB7A;
										}
										if (*((word32) ecx_1434 + 16) == 0x00)
										{
l0805AB7A:
											if (esp_100[3] != eax_1433)
											{
												*((word32) ecx_1434 + 20) = edx_1069;
												edx_1069 = esp_100->ptr0000;
												*((word32) ecx_1434 + 16) = esp_100[3];
												*((word32) *((word32) edx_1069 + 16) + 20) = ecx_1434;
												*((word32) *((word32) edx_1069 + 20) + 16) = ecx_1434;
												goto l0805A430;
											}
											goto l0805ABC9;
										}
										*esp_100[3].dw0014 = (struct Eq_30902) edx_1069;
										*((word32) esp_100->ptr0000->t0014 + 16) = esp_100[3];
									}
								}
								goto l0805A430;
							}
l0805A628:
							malloc_printerr(out ecx_1068, out edx_1069);
l0805A633:
							edi_1032 = esp_100[7];
l0805A637:
							Eq_2 eax_1147 = *((word32) edi_1032 + 4);
							esp_100[3] = (struct Eq_30902) (eax_1147 & ~0x07);
							if (*((word32) ebx_1006 + 1184) <= (eax_1147 & ~0x07))
							{
								Eq_2 eax_1155 = (eax_1147 & ~0x07) - 0x11;
								if (eax_1155 < 0x00)
									goto l0805A6C8;
								esi_1016 = esp_100[6];
								if (esi_1016 < eax_1155)
								{
									edx_1069 = eax_1155 - esi_1016 & -esp_100[4];
									esp_100[1] = (struct Eq_30902) edx_1069;
									word24 edx_24_8_1313 = SLICE(edx_1069, word24, 8);
									if (edx_1069 == 0x00)
										goto l0805A6C8;
									Eq_2 esi_1171 = esp_100->ptr0000->t0008;
									esp_100[4] = (struct Eq_30902) esi_1171;
									esi_1016 = esi_1171 - edx_1069;
									if (esi_1016 > 0x17)
									{
										word32 edx_2073;
										if (*((word64) ebx_1006.u0 + 1152) >= 0x00)
											edx_2073 = SEQ(edx_24_8_1313, (int8) (*((word64) ebx_1006.u0 + 1152) != 0x00));
										else
										{
											Eq_4933 edx_1179 = *(union Eq_4933 *) 0x080CDDAC;
											*((word64) ebx_1006.u0 + 1152) = edx_1179;
											esp_100[5] = (struct Eq_30902) edx_1179;
											word24 edx_24_8_1314 = SLICE(edx_1179, word24, 8);
											if (edx_1179 == 0x00)
											{
												struct Eq_31453 * esp_1185 = esp_100 - 4;
												esp_1185->t0000.u0 = 0x080CDDAC;
												esp_1185->tFFFFFFFC.u0 = 0x080CDDAC;
												esp_1185->tFFFFFFF8.u0 = 0x00080000;
												esp_1185->tFFFFFFF4 = (word32) ebx_1006 - 175556;
												word32 edx_1199;
												word32 ecx_2091;
												Eq_2 eax_1197 = __open_nocancel(gs_1004, esp_1185->tFFFFFFF4, esp_1185->tFFFFFFF8, esp_1185->tFFFFFFFC, out ecx_2091, out edx_1199);
												edx_24_8_1314 = SLICE(edx_1199, word24, 8);
												ecx_1068 = eax_1197;
												if (eax_1197 >= 0x00)
												{
													esp_1185->t0000 = eax_1197;
													esp_1185->tFFFFFFFC.u0 = 0x01;
													esp_1185->tFFFFFFF8 = &esp_1185->b002F;
													esp_1185->tFFFFFFF4 = eax_1197;
													esp_1185->t0014 = eax_1197;
													word32 ecx_2092;
													Eq_2 eax_1219 = __read_nocancel(gs_1004, esp_1185->tFFFFFFF4, esp_1185->tFFFFFFF8, esp_1185->tFFFFFFFC, out ecx_2092);
													ecx_1068 = esp_1185->t0014;
													Eq_4933 edx_1228 = esp_1185->t0018;
													if (eax_1219 > 0x00)
														edx_1228.u1 = (uint32) (int8) (esp_1185->b002F == 0x32);
													*((word32) ebx_1006 + 1152) = edx_1228;
													esp_1185->tFFFFFFF4 = ecx_1068;
													word32 edx_1248;
													__close_nocancel(gs_1004, esp_1185->tFFFFFFF4, out edx_1248);
													edx_24_8_1314 = SLICE(edx_1248, word24, 8);
												}
											}
											edx_2073 = SEQ(edx_24_8_1314, (int8) (*((word32) ebx_1006 + 1152) != 0x00));
										}
										word32 eax_1269 = Mem1264[esp_100 + 0x00:word32] + esi_1016;
										if ((byte) edx_2073 == 0x00)
										{
											struct Eq_31284 * esp_1311 = esp_100 - 4;
											esp_1311->dw0000 = edx_2073;
											esp_1311->dwFFFFFFFC = 0x04;
											esp_1311->dwFFFFFFF8 = esp_1311->dw0008;
											esp_1311->tFFFFFFF4 = eax_1269;
											ecx_1068 = __madvise(gs_1004, esp_1311->tFFFFFFF4, esp_1311->dwFFFFFFF8, esp_1311->dwFFFFFFFC, out edx_1069);
											esp_100 = (struct Eq_30902 *) &esp_1311->dw0008;
										}
										else
										{
											struct Eq_31223 * esp_1274 = esp_100 - 4;
											esp_1274->t0000 = ecx_1068;
											esp_1274->tFFFFFFFC = ecx_1068;
											esp_1274->tFFFFFFF8.u0 = 0x00;
											esp_1274->tFFFFFFF4.u0 = ~0x00;
											esp_1274->tFFFFFFF0.u0 = 0x32;
											esp_1274->dwFFFFFFEC = 0x00;
											esp_1274->tFFFFFFE8 = esp_1274->t0008;
											esp_1274->tFFFFFFE4 = eax_1269;
											esp_100 = (struct Eq_30902 *) &esp_1274->ptr0004;
											if (mmap(gs_1004, esp_1274->tFFFFFFE4, esp_1274->tFFFFFFE8, esp_1274->dwFFFFFFEC, esp_1274->tFFFFFFF0, esp_1274->tFFFFFFF4, esp_1274->tFFFFFFF8, out ecx_1068, out edx_1069) == 0x01)
												goto l0805A6C8;
											esp_1274->ptr0004->t000C = esi_1016;
										}
										esp_100->ptr0000->t0008 = esi_1016;
										ebx_1006 = esp_100[1];
										ui32 eax_1343 = esp_100[3];
										*((word32) ebp_1029 + 0x0454) -= ebx_1006;
										*((word32) edi_1032 + 4) = eax_1343 - ebx_1006 | 0x01;
									}
								}
							}
l0805A6C8:
							if (esp_100[2] == 0x00)
							{
								if (gs_1004->t000C != 0x00)
									__lock();
								Eq_2 v25_1526 = *ebp_1029 - 0x01;
								*ebp_1029 = v25_1526;
								if (v25_1526 != 0x00)
									__lll_unlock_wake_private(ebp_1029, ecx_1068, edx_1069, gs_1004);
							}
							goto l0805A2E4;
						}
						word32 ecx_2120;
						word32 edx_2121;
						al_528 = (byte) malloc_printerr(out ecx_2120, out edx_2121);
l0805A790:
						word32 * edx_527 = esp_100[3];
						int32 eax_531 = (word32) al_528;
						*edx_527 = (word32) (eax_531 *s 0x01010101);
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(edx_527 - 0x0C)[(eax_29 & ~0x07) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = eax_531 *s 0x01010101;
						word32 edi_537 = edx_527 + 0x04 & ~0x03;
						edx_1069 = edx_527 - edi_537;
						uint32 ecx_542;
						for (ecx_542 = (word32) edx_1069 + ((eax_29 & ~0x07) - 0x08) >> 0x02; ecx_542 != 0x00; --ecx_542)
						{
							*edi_537 = eax_531 *s 0x01010101;
							edi_537 += 4;
						}
l0805A297:
						((word32) eax + 8)->u0 = 0x01;
						edi_1032 = (eax_29 & ~0x07) >> 0x03;
						struct Eq_31067 * eax_559 = (word32) eax + edi_1032 * 0x04;
						dwLoc20_1733 = eax_26;
						dwLoc04_1938 = ebp;
						dwLoc08_1870 = edi;
						dwLoc0C_1802 = esi;
						dwLoc10_1734 = ebx;
						ebx_1006.u0 = 0x080CE000;
						gs_1004 = gs;
						ebp_1029 = eax;
						ecx_1068 = eax_559->t0004;
						esi_1016 = gs->t000C;
						if (esi_1016 == 0x00)
						{
							if (esp_100->ptr0000 != ecx_1068)
							{
								esi_1016 = esp_100->ptr0000;
								*((word32) esi_1016 + 8) = ecx_1068;
								eax_559->t0004 = esi_1016;
								goto l0805A2CB;
							}
						}
						else
						{
							esi_1016 = esp_100->ptr0000;
							if (esi_1016 != ecx_1068)
							{
								*((word32) esi_1016 + 8) = ecx_1068;
								ebp_1029 = (word32) eax + 4 + edi_1032 * 0x04;
								if (gs->t000C != 0x00)
									__lock();
								Eq_2 eax_583;
								__cmpxchg(*ebp_1029, esi_1016, ecx_1068, out eax_583);
								esi_1016 = eax_583;
								edx_1069 = esp_100->ptr0000;
								if (eax_583 == ecx_1068)
								{
l0805A2CB:
									if (ecx_1068 != 0x00 && ((esp_100[1] & 0x01) != 0x00 && edi_1032 != *((word32) ecx_1068 + 4) >> 0x03))
									{
										word32 ecx_2087;
										word32 edx_2088;
										malloc_printerr(out ecx_2087, out edx_2088);
										goto l0805A628;
									}
									goto l0805A2E4;
								}
								while (esi_1016 != edx_1069)
								{
									*((word32) edx_1069 + 8) = esi_1016;
									if (gs->t000C != 0x00)
										__lock();
									Eq_2 eax_605;
									__cmpxchg(*ebp_1029, edx_1069, esi_1016, out eax_605);
									ecx_1068 = eax_605;
									if (esi_1016 == eax_605)
										goto l0805A2CB;
									esi_1016 = eax_605;
								}
							}
						}
						word32 ecx_2086;
						malloc_printerr(out ecx_2086, out edx_1069);
						goto l0805A760;
					}
					goto l0805A860;
				}
				edi_1032 = (eax_29 & ~0x07) - 0x01;
				ecx_1068 = edi_1032 >> 0x04;
				if (g_dw80CE4D0 <= edi_1032 >> 0x04)
					goto l0805A25C;
				if (eax_123 != *((word32) edx + 0x0C))
				{
l0805A24A:
					edi_1032 = CONVERT(Mem94[eax_123 + ecx_1068:byte], byte, int32);
					dwLoc20_1733 = eax_26;
					dwLoc04_1938 = ebp;
					dwLoc08_1870 = edi;
					dwLoc0C_1802 = esi;
					dwLoc10_1734 = ebx;
					gs_1004 = gs;
					ebp_1029 = eax;
					edx_1069 = edi_1032;
					if (edi_1032 >= g_t80CE4D8)
						goto l0805A25C;
					if (esp_100[4] <= 0x03FF)
					{
						ebx_1006 = (word32) eax_123 + ecx_1068 * 0x04;
						struct Eq_32601 * edi_148 = esp_100->ptr0000;
						esi_1016 = *((word32) ebx_1006 + 64);
						edi_148->t000C = eax_123;
						edi_148->t0008 = esi_1016;
						edi_1032 = esp_100[3];
						*((word32) ebx_1006 + 64) = edi_1032;
						Mem157[eax_123 + ecx_1068:byte] = SLICE(edi_1032 + 0x01, byte, 0);
						edx_1069 = edi_1032 + 0x01;
l0805A2E4:
						esp_100 = fp - 76;
						Eq_2 eax_686 = dwLoc20_1733 ^ gs_1004->dw0014;
						if (eax_686 == 0x00)
						{
							ecxOut = ecx_1068;
							edxOut = edx_1069;
							ebxOut = dwLoc10_1734;
							ebpOut = dwLoc04_1938;
							esiOut = dwLoc0C_1802;
							ediOut = dwLoc08_1870;
							gsOut = gs_1004;
							return eax_686;
						}
						word32 edx_2090;
						word32 ecx_2089;
						__stack_chk_fail(out ecx_2089, out edx_2090);
l0805ABBE:
						malloc_printerr(out ecx_1434, out edx_1069);
l0805ABC9:
						*((word32) ecx_1434 + 20) = ecx_1434;
						*((word32) ecx_1434 + 16) = ecx_1434;
l0805A430:
						if (*((word32) ebp_1029 + 56) != edi_1032)
						{
							eax_511 = *((word32) edi_1032 + 4);
							if ((Mem729[edi_1032 + 0x04 + Mem729[esp_100 + 0x04:word32]:byte] & 0x01) != 0x00)
							{
								*((word32) edi_1032 + 4) = eax_511 & ~0x01;
l0805A451:
								Eq_2 eax_783 = *((word32) ebp_1029 + 64);
								Eq_2 ecx_784 = (word32) ebp_1029 + 56;
								if (*((word32) eax_783 + 0x0C) != ecx_784)
								{
l0805A9C8:
									malloc_printerr(out ecx_1068, out edx_1069);
									goto l0805A9D3;
								}
								edx_1069 = esp_100->ptr0000;
								*((word32) edx_1069 + 8) = eax_783;
								*((word32) edx_1069 + 0x0C) = ecx_784;
								if (esi_1016 > 1007)
								{
									((word32) edx_1069 + 16)->u0 = 0x00;
									((word32) edx_1069 + 20)->u0 = 0x00;
								}
								ecx_1068 = esp_100->ptr0000;
								*((word32) ebp_1029 + 64) = ecx_1068;
								*((word32) eax_783 + 0x0C) = ecx_1068;
								*((word32) ecx_1068 + 4) = esi_1016 | 0x01;
								Mem809[ecx_1068 + esi_1016:word32] = esi_1016;
l0805A493:
								if (esi_1016 > 0xFFFF)
								{
									if (*((word32) ebp_1029 + 8) == 0x00)
										goto l0805A4AA;
									goto l0805A870;
								}
								goto l0805A6C8;
							}
							goto l0805A5B8;
						}
l0805A760:
						esi_1016 += Mem737[esp_100 + 0x04:word32];
						ecx_1068 = esp_100->ptr0000;
						*((word32) ecx_1068 + 4) = esi_1016 | 0x01;
						*((word32) ebp_1029 + 56) = ecx_1068;
						goto l0805A493;
					}
					struct Eq_32579 * esp_104 = esp_100 - 0x0C;
					esp_104->ptrFFFFFFFC = 0x080A39A0;
					word32 eax_2125;
					word32 edx_2126;
					__malloc_assert(0x080A29DD, 2926, 0x080A2925, out eax_2125, out ecx_1068, out edx_2126);
					esp_100 = esp_104 - 4;
				}
				eax_123 = gs->tFFFFFFE4;
				dwLoc20_1733 = eax_26;
				dwLoc04_1938 = ebp;
				dwLoc08_1870 = edi;
				dwLoc0C_1802 = esi;
				dwLoc10_1734 = ebx;
				esi_1016 = eax_29 & ~0x07;
				ebp_1029 = eax;
				ebx_1006.u0 = 0x080CE000;
				gs_1004 = gs;
				Eq_2 edx_121 = esp_100[3];
				edi_1032 = *((word32) eax_123 + (ecx_1068 * 0x04 + 64));
				if (edi_1032 != 0x00)
				{
					if (edx_121 != edi_1032)
					{
						esp_100[5] = (struct Eq_30902) eax_123;
						struct Eq_31142 * edx_132 = esp_100->ptr0000;
						Eq_2 eax_133 = esp_100[3];
						do
						{
							edi_1032 = *edi_1032;
							if (edi_1032 == 0x00)
							{
								eax_123 = esp_100[5];
								esp_100->ptr0000 = (struct Eq_155142 *) edx_132;
								goto l0805A24A;
							}
						} while (eax_133 != edi_1032);
					}
					goto l0805ABBE;
				}
				goto l0805A24A;
			}
l0805A540:
			word32 ecx_2085;
			malloc_printerr(out ecx_2085, out edx_1069);
			edi_1032 = edi;
			goto l0805A550;
		}
	}
	word32 edx_2084;
	word32 ecx_2083;
	malloc_printerr(out ecx_2083, out edx_2084);
	goto l0805A540;
}

// 0805ACF0: Register Eq_2 sysmalloc(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _int_malloc
Eq_2 sysmalloc(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edi_745;
	Eq_2 edx_1024;
	Eq_2 eax_164;
	struct Eq_32702 * esp_111 = fp - 0x4C;
	Eq_2 edi_137 = _dl_pagesize;
	if (edx == 0x00)
	{
		edx_1024 = (word32) eax + ((word32) edi_137 + 18) & -edi_137;
		if (eax < edx_1024)
		{
			word32 edx_1223;
			eax_164 = mmap(gs, 0x00, edx_1024, 0x03, 0x22, ~0x00, 0x00, out ecx, out edx_1223);
			if (eax_164 != ~0x00)
				goto l0805AEF7;
		}
l0805AF8D:
		edi_745.u0 = 0x00;
		goto l0805AF8F;
	}
	if (g_t80CE4A8 > eax)
	{
l0805AD26:
		esp_111[4] = (struct Eq_32702) 0x00;
l0805AD2B:
		esp_111[3] = (struct Eq_32702) edi_137;
		esp_111[1] = (struct Eq_32702) ((word32) edx + 56);
		Mem73[esp_111 + 0x14:word32] = edi_137 + 0x12 + eax;
		while (true)
		{
			edi_137 = *((word32) edx + 56);
			Eq_2 eax_77 = *((word32) edi_137 + 4);
			byte al_91 = (byte) eax_77;
			ecx = eax_77 & ~0x07;
			Eq_32770 edx_80 = (word32) edi_137 + (eax_77 & ~0x07);
			if ((edi_137 != esp_111[1] || (eax_77 & ~0x07) != 0x00) && ((eax_77 & ~0x07) <= 0x0F || ((al_91 & 0x01) == 0x00 || (edx_80 & esp_111[3] - 0x01) != 0x00)))
				break;
			esp_111[6] = (struct Eq_32702) ((word32) eax + 16);
			if ((word32) eax + 16 <= (eax_77 & ~0x07))
			{
				esp_111->dwFFFFFFF0 = 0x080A3988;
				word32 eax_1220;
				__malloc_assert(0x080A3304, 2388, 0x080A2925, out eax_1220, out ecx, out edx_1024);
				goto l0805AF80;
			}
			Eq_2 edi_249;
			Eq_2 eax_425;
			esp_111[8] = (struct Eq_32702) 0x080CE500;
			if (edx != 0x080CE500)
			{
				int32 edx_642 = esp_111[6] - (eax_77 & ~0x07);
				esp_111[7] = (struct Eq_32702) (edi_137 & 0xFFF00000);
				if (edx_642 > 0x00)
				{
					esp_111[9] = (struct Eq_32702) (edi_137 & 0xFFF00000)->dw0008;
					Eq_2 eax_649 = *((word32) esp_111[2].dwFFFFFFF0 + 16);
					Eq_2 edx_654 = (word32) esp_111[9].dwFFFFFFF0 + ((-eax_649 & (word32) eax_649 + (edx_642 - 0x01)) + 16);
					if (edx_654 > 0x00100000)
						goto l0805AFA0;
					Eq_2 eax_658 = *esp_111[7].t000C;
					if (edx_654 <= eax_658)
						esp_111[2] = (struct Eq_32702) edi_137;
					else
					{
						esp_111[0x0A] = (struct Eq_32702) (eax_77 & ~0x07);
						struct Eq_32905 * esp_662 = esp_111 - 0x04;
						esp_662->tFFFFFFFC.u0 = 0x03;
						esp_662->t0030 = edx_654;
						esp_662->tFFFFFFF8 = edx_654 - eax_658;
						esp_662->tFFFFFFF4 = (word32) eax_658 + esp_662->dw0020;
						word32 ecx_1221;
						word32 edx_1222;
						Eq_2 eax_674 = mprotect(gs, esp_662->tFFFFFFF4, esp_662->tFFFFFFF8, esp_662->tFFFFFFFC, out ecx_1221, out edx_1222);
						esp_111 = (struct Eq_32702 *) ((char *) &esp_662->tFFFFFFFC + 0x0C);
						ecx = esp_662->t0030;
						if (eax_674 != 0x00)
							goto l0805AFA0;
						edx_654 = esp_662->t0034;
						struct Eq_33089 * ecx_866 = esp_662->ptr0024;
						esp_662->t0010 = edi_137;
						ecx_866->t000C = edx_654;
					}
					ecx = esp_111[7];
					*((word32) ecx + 8) = edx_654;
					Eq_2 eax_875 = *((word32) ecx + 8);
					edi_249 = *((word32) edx + 56);
					word32 edx_880 = Mem874[edx + 0x0454:word32] + eax_875 - Mem874[esp_111 + 0x24:word32];
					*((word32) edx + 0x0454) = edx_880;
					esp_111[1] = (struct Eq_32702) edx_880;
					edx_1024 = esp_111[2];
					Mem889[edx_1024 + 0x04:word32] = eax_875 + ecx - edx_1024 | 0x01;
				}
				else
				{
l0805AFA0:
					up32 edx_689 = g_dw80CE4A4;
					esp_111[9] = (struct Eq_32702) ecx;
					eax_425 = new_heap((word32) eax + 40, edx_689, gs, out ecx, out edx_1024);
					if (eax_425 != 0x00)
					{
						Eq_2 edx_814 = esp_111[7];
						ui32 ecx_815 = esp_111[9];
						esp_111[2] = (struct Eq_32702) edi_137;
						Eq_2 edi_818 = *((word32) edx + 0x0454);
						*eax_425 = edx;
						*((word32) eax_425 + 4) = edx_814;
						Eq_2 edx_821 = *((word32) eax_425 + 8);
						word32 edi_822 = edi_818 + edx_821;
						*((word32) edx + 0x0454) = edi_822;
						esp_111[1] = (struct Eq_32702) edi_822;
						*((word32) edx + 56) = (word32) eax_425 + 24;
						*((word32) eax_425 + 28) = edx_821 - 0x18 | 0x01;
						Eq_33187 eax_832 = ecx_815 - 0x10 & ~0x0F;
						struct Eq_33192 * ecx_834 = (word32) esp_111[2].dwFFFFFFF0 + (((word32) eax_832 + 8) + 16);
						esp_111[3] = (struct Eq_32702) ecx_834;
						ecx_834->dw0004 = 0x01;
						edi_249 = (word32) eax_425 + 24;
						edx_1024 = (word32) eax_832 + 8;
						if (eax_832 <= 0x0F)
						{
							ecx = esp_111[2];
							*((word32) ecx + 4) = (word32) eax_832 + 8 | 0x01;
							*((word32) esp_111[3].dwFFFFFFF0 + 16) = (struct Eq_32702) ((word32) eax_832 + 8);
						}
						else
						{
							Eq_2 edx_839 = esp_111[2];
							Eq_2 edi_840 = esp_111[3];
							*((word32) eax_832 + ((word32) edx_839 + 4)) = 0x09;
							*edi_840 = 0x08;
							*((word32) edx_839 + 4) = eax_832 | 0x05;
							word32 ebx_1224;
							word32 ebp_1225;
							word32 esi_1226;
							word32 edi_1227;
							struct Eq_33236 * gs_1228;
							_int_free(edx, edx_839, edi_840, gs, out ecx, out edx_1024, out ebx_1224, out ebp_1225, out esi_1226, out edi_1227, out gs_1228);
							edi_249 = *((word32) edx + 56);
							esp_111[1] = (struct Eq_32702) *((word32) edx + 0x0454);
						}
					}
					else
					{
						if (esp_111[4] == 0x00)
						{
							edi_249 = -esp_111[3] & esp_111[5];
							if (edi_249 <= eax)
								goto l0805B4B6;
							goto l0805B4CB;
						}
						edi_249 = *((word32) edx + 56);
						esp_111[1] = (struct Eq_32702) *((word32) edx + 0x0454);
					}
				}
				goto l0805AE1C;
			}
			<anonymous> * eax_333;
			Eq_2 ecx_496;
			union Eq_2 * eax_219;
			Eq_2 ecx_513;
			Eq_2 ecx_253;
			esp_111[2] = (struct Eq_32702) edi_137;
			ui32 edi_206 = esp_111[3];
			up32 eax_207 = g_dw80CE4A4;
			esp_111[4] = (struct Eq_32702) edx_80;
			esp_111[7] = (struct Eq_32702) (edi_206 - 0x01);
			ui32 edi_211 = -edi_206;
			esp_111[9] = (struct Eq_32702) edi_211;
			edx_1024 = edi_206 - 0x01;
			up32 eax_214 = (word32) eax + 16 + eax_207;
			if ((g_t80CE504 & 0x02) == 0x00)
			{
				eax_219 = eax_214 - (eax_77 & ~0x07) + (edi_206 - 0x01) & edi_211;
				esp_111[3] = (struct Eq_32702) eax_219;
				if (eax_219 > null)
					goto l0805B110;
				goto l0805B32D;
			}
			eax_219 = eax_214 + (edi_206 - 0x01) & edi_211;
			esp_111[3] = (struct Eq_32702) eax_219;
			if (eax_219 <= null)
			{
l0805B1AE:
				Eq_2 edi_270 = esp_111[3];
				Eq_2 eax_271 = 0x00100000;
				if (edi_270 >= 0x00100000)
					eax_271 = edi_270;
				esp_111[3] = (struct Eq_32702) eax_271;
				if (eax >= eax_271)
					goto l0805B1CC;
				esp_111[1] = (struct Eq_32702) ecx;
				struct Eq_33618 * esp_286 = esp_111 - 0x08;
				esp_286->tFFFFFFFC.u0 = 0x00;
				esp_286->tFFFFFFF8.u0 = ~0x00;
				esp_286->tFFFFFFF4.u0 = 0x22;
				esp_286->dwFFFFFFF0 = 0x03;
				esp_286->tFFFFFFEC = esp_286->t0014;
				esp_286->tFFFFFFE8.u0 = 0x00;
				word32 ecx_1236;
				Eq_2 eax_304 = mmap(gs, esp_286->tFFFFFFE8, esp_286->tFFFFFFEC, esp_286->dwFFFFFFF0, esp_286->tFFFFFFF4, esp_286->tFFFFFFF8, esp_286->tFFFFFFFC, out ecx_1236, out edx_1024);
				esp_111 = (struct Eq_32702 *) ((char *) &esp_286->tFFFFFFFC + 0x0C);
				ecx = esp_286->t000C;
				edi_249 = eax_304;
				if (eax_304 == ~0x00)
					goto l0805B1CC;
				Eq_2 eax_316 = esp_286->t0014;
				g_t80CE504 |= 0x02;
				Mem324[esp_286 + 0x1C:word32] = eax_316 + eax_304;
				if (eax_304 == 0x00)
					goto l0805B1CC;
				esp_286->b0030 = (int8) (esp_286->dw001C == 0x00);
				goto l0805B14E;
			}
l0805B110:
			esp_111[1] = (struct Eq_32702) (eax_77 & ~0x07);
			struct Eq_33316 * esp_232 = esp_111 - 0x0C;
			esp_232->dwFFFFFFFC = esp_232->dw0018;
			Eq_2 eax_245;
			__morecore();
			edi_249 = eax_245;
			esp_111 = (struct Eq_32702 *) (&esp_232->dwFFFFFFFC + 4);
			ecx_253 = esp_232->t0010;
			if (eax_245 == 0x00)
			{
				ecx = ecx_253;
				ecx = ecx_253;
				if ((g_t80CE504 & 0x02) == 0x00)
				{
l0805B32D:
					Mem267[esp_111 + 0x0C:word32] = Mem259[esp_111 + 0x1C:word32] + ecx + Mem259[esp_111 + 0x0C:word32] & Mem259[esp_111 + 0x24:word32];
				}
				goto l0805B1AE;
			}
			eax_333 = __after_morecore_hook;
			esp_232->b0034 = 0x01;
			esp_232->dw0020 = 0x00;
			ecx = ecx_253;
			ecx_496 = ecx_253;
			if (eax_333 != null)
			{
l0805B42B:
				esp_111[1] = (struct Eq_32702) ecx_496;
				eax_333();
				ecx_513 = esp_111[1];
				ecx = ecx_513;
			}
l0805B14E:
			if (g_t80CE4CC == 0x00)
				g_t80CE4CC = edi_249;
			edx_1024 = esp_111[3];
			up32 eax_353 = (word32) edx_1024 + g_dw80CE954;
			esp_111[1] = (struct Eq_32702) eax_353;
			g_dw80CE954 = eax_353;
			if (esp_111[4] == edi_249 && esp_111[0x0A] != 0x00)
			{
				edi_249 = g_t80CE538;
				ecx = esp_111[2];
				Mem638[ecx + 0x04:word32] = edx_1024 + ecx | 0x01;
				goto l0805AE1C;
			}
			if ((g_t80CE504 & 0x02) != 0x00)
			{
				Eq_33411 eax_367 = (word32) edi_249 + 8;
				if ((eax_367 & 0x0F) != 0x00)
					edi_249 = edi_249 - (eax_367 & 0x0F) + 0x10;
				word32 eax_378 = esp_111[5];
				edx_1024.u0 = 0x00;
				if (eax_378 != 0x00)
					goto l0805B2B6;
				esp_111[1] = (struct Eq_32702) ecx;
				struct Eq_33783 * esp_388 = esp_111 - 0x0C;
				esp_388->dwFFFFFFFC = 0x00;
				word32 eax_410;
				__morecore();
				esp_388->dw0020 = eax_410;
				ecx = esp_388->t0010;
				goto l0805B3DD;
			}
			if (ecx == 0x00 || esp_111[4] <= edi_249)
			{
				if (ecx != 0x00)
					g_dw80CE954 = (word32) esp_111[1].dwFFFFFFF0 + ((edi_249 - esp_111[4]) + 16);
				Eq_2 edx_449;
				Eq_33433 eax_443 = (word32) edi_249 + 8;
				if ((eax_443 & 0x0F) != 0x00)
				{
					int32 edx_453 = 0x10 - (eax_443 & 0x0F);
					esp_111[4] = (struct Eq_32702) ((word32) edi_249 + edx_453);
					edx_449 = (word32) ecx + edx_453;
				}
				else
				{
					esp_111[4] = (struct Eq_32702) edi_249;
					edx_449 = ecx;
				}
				word32 eax_464 = Mem459[esp_111 + 0x0C:word32] + edx_449 + edi_249;
				Eq_33753 edx_466 = edx_449 - eax_464;
				edi_249 = (Mem459[esp_111 + 0x1C:word32] + eax_464 & Mem459[esp_111 + 0x24:word32]) + edx_466;
				if (edi_249 < 0x00)
				{
					struct Eq_33466 * esp_475 = esp_111 - 0x0C;
					esp_475->ptrFFFFFFFC = 0x080A3988;
					__malloc_assert(134883878, 0x0A2B, 0x080A2925, out eax_333, out ecx_496, out edx_1024);
					esp_111 = esp_475 - 4;
					goto l0805B42B;
				}
				esp_111[3] = (struct Eq_32702) edi_249;
				struct Eq_33486 * esp_515 = esp_111 - 0x0C;
				esp_515->t0010 = ecx;
				esp_515->tFFFFFFFC = edi_249;
				word32 eax_521;
				__morecore();
				esp_515->dw0020 = eax_521;
				ecx = esp_515->t0010;
				edx_1024 = esp_515->t0018;
				if (eax_521 != 0x00)
				{
					<anonymous> * eax_557 = __after_morecore_hook;
					if (eax_557 == null)
					{
						edi_249 = esp_515->t001C;
						esp_515->t0010 = (word32) edx_1024 + g_dw80CE954;
					}
					else
					{
						esp_515->t0010 = edx_1024;
						esp_515->t0018 = ecx;
						eax_557();
						edx_1024 = esp_515->t0010;
						edi_249 = esp_515->t001C;
						ecx = esp_515->t0018;
						esp_515->t0010 = (word32) edx_1024 + g_dw80CE954;
					}
					goto l0805B2B6;
				}
				esp_515->tFFFFFFFC.u0 = 0x00;
				word32 eax_536;
				__morecore();
				esp_515->dw0020 = eax_536;
				edi_249 = esp_515->t001C;
				ecx = esp_515->t0010;
l0805B3DD:
				edx_1024 = esp_111[5];
				esp_111[1] = (struct Eq_32702) g_dw80CE954;
				if (edx_1024 != 0x00)
				{
					edx_1024.u0 = 0x00;
l0805B2B6:
					ui32 eax_581 = esp_111[5];
					g_t80CE538 = edi_249;
					*((word32) edi_249 + 4) = (word32) edx_1024 + (eax_581 - edi_249) | 0x01;
					g_dw80CE954 = (up32) esp_111[1];
					if (ecx == 0x00)
						goto l0805AE1C;
					Eq_33560 eax_598 = ecx - 0x10;
					ecx = esp_111[2];
					edx_1024 = eax_598 & ~0x0F | 0x01;
					*((word32) ecx + 4) = edx_1024;
					Mem604[ecx + 0x04 + (eax_598 & ~0x0F):word32] = 0x09;
					Mem605[ecx + 0x0C + (eax_598 & ~0x0F):word32] = 0x09;
					if ((eax_598 & ~0x0F) <= 0x0F)
						goto l0805AE1C;
					word32 esi_1233;
					word32 edi_1234;
					struct Eq_33590 * gs_1235;
					word32 ebx_1231;
					word32 ebp_1232;
					_int_free(0x080CE500, esp_111[2], edi_249, gs, out ecx, out edx_1024, out ebx_1231, out ebp_1232, out esi_1233, out edi_1234, out gs_1235);
l0805B1CC:
					esp_111[1] = (struct Eq_32702) g_dw80CE954;
				}
				edi_249 = g_t80CE538;
l0805AE1C:
				Eq_2 ebp_923 = eax;
				up32 eax_893 = esp_111[1];
				if (eax_893 > *((word32) edx + 1112))
					*((word32) edx + 1112) = eax_893;
				ui32 eax_906 = *((word32) edi_249 + 4);
				if (esp_111[6] <= (eax_906 & ~0x07))
				{
					edx_1024 = edi_249 + eax;
					*((word32) edx + 56) = edx_1024;
					ui32 eax_928 = (eax_906 & ~0x07) - eax;
					if (edx != esp_111[8])
						ebp_923 = eax | 0x04;
					edi_745 = (word32) edi_249 + 8;
					ecx = ebp_923 | 0x01;
					*((word32) edi_745 - 4) = ecx;
					*((word32) edx_1024 + 4) = eax_928 | 0x01;
					goto l0805AF8F;
				}
l0805AF80:
				gs->tFFFFFFE0.u0 = 0x0C;
				goto l0805AF8D;
			}
			word32 edx_1230;
			word32 ecx_1229;
			eax_425 = malloc_printerr(out ecx_1229, out edx_1230);
l0805B4CB:
			struct Eq_33817 * esp_714 = esp_111 - 4;
			esp_714->t0000 = eax_425;
			esp_714->tFFFFFFFC = eax_425;
			esp_714->tFFFFFFF8.u0 = 0x00;
			esp_714->tFFFFFFF4.u0 = ~0x00;
			esp_714->tFFFFFFF0.u0 = 0x22;
			esp_714->dwFFFFFFEC = 0x03;
			esp_714->tFFFFFFE8 = edi_249;
			esp_714->tFFFFFFE4.u0 = 0x00;
			word32 edx_1238;
			word32 ecx_1237;
			eax_164 = mmap(gs, esp_714->tFFFFFFE4, esp_714->tFFFFFFE8, esp_714->dwFFFFFFEC, esp_714->tFFFFFFF0, esp_714->tFFFFFFF4, esp_714->tFFFFFFF8, out ecx_1237, out edx_1238);
			esp_111 = (struct Eq_32702 *) ((char *) &esp_714->t0000 + 4);
			if (eax_164 != ~0x00)
			{
				edx_1024 = edi_249;
				goto l0805AEF7;
			}
l0805B4B6:
			esp_111[4] = (struct Eq_32702) 0x01;
		}
		struct Eq_32745 * esp_108 = esp_111 - 0x0C;
		esp_108->ptrFFFFFFFC = 0x080A3988;
		word32 eax_1217;
		word32 ecx_1218;
		word32 edx_1219;
		__malloc_assert(134885980, 0x0951, 0x080A2925, out eax_1217, out ecx_1218, out edx_1219);
		esp_111 = esp_108 - 4;
	}
	if (g_t80CE4B4 < g_t80CE4B8)
	{
		struct Eq_33877 * eax_141 = -edi_137;
		word32 edx_142 = edi_137 + 0x12 + eax & eax_141;
		if (edx_142 <= eax)
		{
l0805AEB4:
			esp_111[4] = (struct Eq_32702) 0x01;
			goto l0805AD2B;
		}
		struct Eq_33885 * esp_146 = esp_111 - 4;
		esp_146->ptr0000 = eax_141;
		esp_146->ptrFFFFFFFC = eax_141;
		esp_146->tFFFFFFF8.u0 = 0x00;
		esp_146->tFFFFFFF4.u0 = ~0x00;
		esp_146->tFFFFFFF0.u0 = 0x22;
		esp_146->dwFFFFFFEC = 0x03;
		esp_146->tFFFFFFE8 = edx_142;
		esp_146->t0008 = edx_142;
		esp_146->tFFFFFFE4.u0 = 0x00;
		word32 ecx_1239;
		word32 edx_1240;
		eax_164 = mmap(gs, esp_146->tFFFFFFE4, esp_146->tFFFFFFE8, esp_146->dwFFFFFFEC, esp_146->tFFFFFFF0, esp_146->tFFFFFFF4, esp_146->tFFFFFFF8, out ecx_1239, out edx_1240);
		edx_1024 = esp_146->t0008;
		if (eax_164 == ~0x00)
			goto l0805AEB4;
l0805AEF7:
		edi_745 = (word32) eax_164 + 8;
		if ((edi_745 & 0x0F) == 0x00)
		{
			*eax_164 = 0x00;
			*((word32) eax_164 + 4) = edx_1024 | 0x02;
		}
		else
		{
			uint32 ecx_752 = 0x10 - (edi_745 & 0x0F);
			struct Eq_32989 * edi_753 = (word32) eax_164 + ecx_752;
			edi_753->dw0000 = ecx_752;
			edi_753->dw0004 = edx_1024 - ecx_752 | 0x02;
			edi_745 = &edi_753->dw0004 + 1;
		}
		__lock();
		g_t80CE4B4 = __xadd(g_t80CE4B4, 0x01);
		do
		{
			Eq_2 eax_782 = g_t80CE4BC;
			if (eax_782 >= 0x02)
				break;
			__lock();
			word32 eax_786;
		} while (__cmpxchg(g_t80CE4BC, 0x02, eax_782, out eax_786));
		__lock();
		g_t80CE4C4 = __xadd(g_t80CE4C4, edx_1024);
		ecx.u0 = 1224;
		edx_1024 *= 0x02;
		do
		{
			Eq_2 eax_802 = g_t80CE4C8;
			if (edx_1024 <= eax_802)
				break;
			__lock();
			word32 eax_806;
		} while (!__cmpxchg(g_t80CE4C8, edx_1024, eax_802, out eax_806));
l0805AF8F:
		ecxOut = ecx;
		edxOut = edx_1024;
		return edi_745;
	}
	goto l0805AD26;
}

// 0805B4F0: Register Eq_2 _int_malloc(Register Eq_2 eax, Register Eq_2 edx, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_33973) ebxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out Eq_2 ediOut)
// Called from:
//      malloc_check
//      tcache_init.part.6
//      _int_memalign
//      _int_realloc
//      realloc_check
//      __libc_malloc
//      __libc_calloc
Eq_2 _int_malloc(Eq_2 eax, Eq_2 edx, Eq_2 edi, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, struct Eq_33973 & ebxOut, ptr32 & ebpOut, ptr32 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 ecx_2573;
	Eq_2 esi_1637;
	ptr32 dwLoc04_1913 = ebp;
	struct Eq_33981 * ebp_1474 = &g_t80CE000;
	Eq_2 dwLoc08_1914 = edi;
	ptr32 dwLoc0C_1915 = esi;
	struct Eq_33973 * dwLoc10_1916 = ebx;
	struct Eq_33988 * esp_1027 = fp - 0x9C;
	if (edx > 0x04)
	{
		esi_1637 = (word32) edx + 19 & ~0x0F;
		ecx_2573 = SEQ(ecx_24_8, (int8) (esi_1637 > ~0x20));
	}
	else
	{
		esi_1637.u0 = 0x10;
		ecx_2573.u0 = 0x00;
	}
	byte cl_35 = (byte) ecx_2573;
	if (esi_1637 < edx || cl_35 != 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		ecxOut = ecx_2573;
		edxOut = edx;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return 0x00;
	}
	Eq_2 ecx_1112;
	Eq_2 esi_1435;
	word24 eax_24_8_1815;
	byte al_1800;
	Eq_2 edx_1144;
	Eq_2 edx_1638;
	if (eax == 0x00)
	{
l0805BB90:
		edx_1638.u0 = 0x00;
		goto l0805BB92;
	}
	Eq_2 ecx_1564;
	struct Eq_34022 * ebp_1125;
	Eq_2 esi_1030;
	Eq_2 ebx_1036;
	Eq_2 edi_1065;
	Eq_2 ecx_1464;
	Eq_2 edx_1301;
	Eq_2 eax_1783;
	Eq_2 eax_1200;
	Eq_2 ecx_1302;
	Eq_2 edx_1035;
	Eq_2 eax_1039;
	uint32 edx_942;
	Eq_2 eax_495;
	Eq_2 esi_497;
	if (esi_1637 <= global_max_fast)
	{
		Eq_2 edx_158 = esi_1637 >> 0x03;
		ebx_1036 = (word32) eax + edx_158 * 0x04;
		Eq_2 ecx_160 = *((word32) ebx_1036 + 4);
		Eq_2 dwLoc94_1951 = ecx_160;
		if (ecx_160 != 0x00)
		{
			union Eq_2 * eax_165 = (word32) eax + 4 + edx_158 * 0x04;
			ecx_1112 = *((word32) ecx_160 + 8);
			if (gs->t000C == 0x00)
			{
				*((word32) ebx_1036 + 4) = ecx_1112;
				edi_1065 = edi;
			}
			else
			{
				edi_1065 = ecx_160;
				while (true)
				{
					if (gs->t000C != 0x00)
						__lock();
					Eq_2 eax_187;
					__cmpxchg(*eax_165, ecx_1112, edi_1065, out eax_187);
					if (eax_187 == edi_1065)
						break;
					if (eax_187 == 0x00)
						goto l0805B978;
					ecx_1112 = *((word32) eax_187 + 8);
					edi_1065 = eax_187;
				}
				dwLoc94_1951 = edi_1065;
			}
			edx_1144 = edx_158;
			if (edx_158 == *((word32) dwLoc94_1951 + 4) >> 0x03)
			{
				Eq_2 edi_1687 = gs->tFFFFFFE4;
				if (edi_1687 != 0x00)
				{
					uint32 esi_1692 = esi_1637 - 0x01;
					if (g_dw80CE4D0 > esi_1692 >> 0x04 && CONVERT(Mem358[edi_1687 + (esi_1692 >>u 0x04):byte], byte, int32) <u Mem358[0x080CE4D8<p32>:word32])
					{
						edx_1144 = *((word32) ebx_1036 + 4);
						if (edx_1144 != 0x00)
						{
							struct Eq_34115 * eax_1705 = (word32) edi_1687 + (esi_1692 >> 0x04) * 0x04;
							do
							{
								Eq_34120 esi_1719 = esi_1637 - 0x01 >> 0x04;
								ecx_1112 = *((word32) edx_1144 + 8);
								if (gs->t000C != 0x00)
								{
									while (true)
									{
										if (gs->t000C != 0x00)
											__lock();
										Eq_2 eax_1734;
										__cmpxchg(*eax_165, ecx_1112, edx_1144, out eax_1734);
										if (eax_1734 == edx_1144)
											break;
										if (eax_1734 == 0x00)
											goto l0805B658;
										ecx_1112 = *((word32) eax_1734 + 8);
										edx_1144 = eax_1734;
									}
								}
								else
									*((word32) ebx_1036 + 4) = ecx_1112;
								Eq_2 eax_1747 = eax_1705->t0040;
								*((word32) edx_1144 + 0x0C) = edi_1687;
								edx_1144 = (word32) edx_1144 + 8;
								*edx_1144 = eax_1747;
								eax_1705->t0040 = edx_1144;
								byte al_1760 = SLICE(CONVERT(Mem1756[edi_1687 + esi_1719:byte], byte, word32) + 0x01, byte, 0);
								Mem1761[edi_1687 + esi_1719:byte] = al_1760;
								if ((int32) al_1760 >= g_t80CE4D8)
									break;
								edx_1144 = *((word32) ebx_1036 + 4);
							} while (edx_1144 != 0x00);
						}
					}
				}
l0805B658:
				eax_1783 = dwLoc94_1951;
l0805B65C:
				Eq_2 eax_1790 = perturb_byte;
				dwLoc04_1913 = ebp;
				dwLoc08_1914 = edi;
				dwLoc0C_1915 = esi;
				dwLoc10_1916 = ebx;
				esi_1435 = (word32) eax_1783 + 8;
				al_1800 = (byte) eax_1790;
				eax_24_8_1815 = SLICE(eax_1790, word24, 8);
				if (eax_1790 == 0x00)
					goto l0805B66F;
				goto l0805BB20;
			}
l0805BF70:
			word32 edx_2585;
			word32 ecx_2584;
			malloc_printerr(out ecx_2584, out edx_2585);
			esi_1030 = esi_1637;
l0805BF80:
			*((word32) edi_1065 + 20) = edi_1065;
			ecx_1564 = esp_1027[3];
			*((word32) edi_1065 + 16) = edi_1065;
			esp_1027[5] = (struct Eq_33988) ebx_1036;
l0805B8A8:
			int32 eax_386 = esp_1027[3];
			++esp_1027->dw0020;
			*((word32) esi_1030 + ((eax_386 >> 0x05) * 0x04 + 1080)) |= 0x01 << (byte) ecx_1564;
			struct Eq_34793 * eax_397 = esp_1027[5];
			word32 edx_398 = esp_1027->dw0040;
			*((word32) edi_1065 + 8) = ebx_1036;
			*((word32) edi_1065 + 0x0C) = eax_397;
			*((word32) ebx_1036 + 0x0C) = edi_1065;
			eax_397->t0008 = edi_1065;
			dwLoc04_1913 = ebp;
			dwLoc08_1914 = edi;
			dwLoc0C_1915 = esi;
			dwLoc10_1916 = ebx;
			up32 eax_405 = esp_1027->dw0020;
			ecx_1112 = ecx_1564;
			if (edx_398 != 0x00)
			{
				if (esp_1027->dw004C < eax_405 && esp_1027->b005B != 0x00)
				{
					byte edi_1579[] = esp_1027->ptr0014;
					struct Eq_34451 * eax_1582 = edi_1579 + esp_1027[2] *32 0x04;
					esi_1435 = eax_1582->t0040;
					if (esp_1027->dw005C <= 0x03FF)
					{
						if (esi_1435 != 0x00)
						{
							edx_1144 = *esi_1435;
							eax_1582->t0040 = edx_1144;
							int32 eax_1681 = esp_1027[2];
							--edi_1579[eax_1681];
							((word32) esi_1435 + 4)->u0 = 0x00;
							goto l0805B66F;
						}
						goto l0805C2C9;
					}
					goto l0805C2A9;
				}
				++esp_1027->dw001C;
				if (esp_1027->dw001C > 9999)
				{
l0805C0AC:
					int32 edi_949 = esp_1027->ptr0014;
					ecx_1112 = esp_1027[2];
					struct Eq_34543 * eax_952 = edi_949 + ecx_1112 * 0x04;
					dwLoc04_1913 = ebp;
					dwLoc08_1914 = edi;
					dwLoc0C_1915 = esi;
					dwLoc10_1916 = ebx;
					esi_1435 = eax_952->t0040;
					if (esp_1027->dw005C <= 0x03FF)
					{
						if (esi_1435 != 0x00)
						{
							edx_1144 = *esi_1435;
							eax_952->t0040 = edx_1144;
							--*((word32) ecx_1112 + edi_949);
							((word32) esi_1435 + 4)->u0 = 0x00;
							goto l0805B66F;
						}
l0805C2C9:
						struct Eq_34488 * esp_1619 = esp_1027 - 0x0C;
						esp_1619->ptrFFFFFFFC = 134887828;
						word32 eax_2601;
						word32 ecx_2602;
						word32 edx_2603;
						__malloc_assert(0x080A2A68, 0x0B80, 0x080A2925, out eax_2601, out ecx_2602, out edx_2603);
						esp_1027 = esp_1619 - 4;
l0805C2E9:
						esi_1637 = esp_1027->t0010;
						edx_1638 = esp_1027->ptr0004;
l0805BB92:
						Eq_2 eax_1663 = sysmalloc(esi_1637, edx_1638, gs, out ecx_1112, out edx_1144);
						dwLoc04_1913 = ebp;
						dwLoc08_1914 = edi;
						dwLoc0C_1915 = esi;
						dwLoc10_1916 = ebx;
						esi_1435 = eax_1663;
						if (eax_1663 == 0x00)
						{
							esi_1435.u0 = 0x00;
							goto l0805B66F;
						}
						Eq_2 eax_1675 = perturb_byte;
						al_1800 = (byte) eax_1675;
						eax_24_8_1815 = SLICE(eax_1675, word24, 8);
						if (eax_1675 == 0x00)
						{
l0805B66F:
							ecxOut = ecx_1112;
							edxOut = edx_1144;
							ebxOut = dwLoc10_1916;
							ebpOut = dwLoc04_1913;
							esiOut = dwLoc0C_1915;
							ediOut = dwLoc08_1914;
							return esi_1435;
						}
l0805BB20:
						struct Eq_34150 * esp_1799 = esp_1027 - 0x04;
						esp_1799->tFFFFFFFC = esp_1799->t0010;
						esp_1799->tFFFFFFF8 = SEQ(eax_24_8_1815, ~al_1800);
						esp_1799->tFFFFFFF4 = esi_1435;
						memset(esp_1799->tFFFFFFF4, esp_1799->tFFFFFFF8, esp_1799->tFFFFFFFC, out ecx_1112, out edx_1144);
						goto l0805B66F;
					}
					goto l0805C2A9;
				}
			}
			else
			{
				++esp_1027->dw001C;
				if (esp_1027->dw001C > 9999)
					goto l0805BC60;
			}
			edi_1065 = *((word32) esi_1030 + 0x0044);
l0805B7DB:
			while (true)
			{
				dwLoc04_1913 = ebp;
				dwLoc08_1914 = edi;
				dwLoc0C_1915 = esi;
				dwLoc10_1916 = ebx;
				ebp_1474 = (struct Eq_33981 *) &g_t80CE000;
				if (edi_1065 == esp_1027->dw0008)
					break;
				ui32 eax_435 = *((word32) edi_1065 + 4);
				esp_1027[5] = (struct Eq_33988) ((word32) edi_1065 + (eax_435 & ~0x07));
				eax_1039 = eax_435 & ~0x07;
				if ((eax_435 & ~0x07) <= 0x08)
				{
l0805BB80:
					word32 edx_2592;
					word32 ecx_2591;
					malloc_printerr(out ecx_2591, out edx_2592);
					esi_1637 = esi_1030;
					goto l0805BB90;
				}
				Eq_2 ebx_442 = *((word32) esi_1030 + 0x0454);
				if (ebx_442 < (eax_435 & ~0x07))
					goto l0805BB80;
				Eq_2 edx_468 = (word32) edi_1065 + (eax_435 & ~0x07) + 0x04;
				byte dl_565 = (byte) edx_468;
				if (edx_468 <= 0x07 || ebx_442 < edx_468)
				{
					word32 edx_2594;
					word32 ecx_2593;
					eax_1039 = malloc_printerr(out ecx_2593, out edx_2594);
					goto l0805BBD0;
				}
				if ((*((word32) edi_1065 + (eax_435 & ~0x07)) & ~0x07) != (eax_435 & ~0x07))
				{
					eax_495 = malloc_printerr(out ecx_1464, out edx_1301);
					esi_497 = esi_1030;
					goto l0805BEF0;
				}
				struct Eq_34301 * ebx_558 = *((word32) edi_1065 + 0x0C);
				esp_1027[3] = (struct Eq_33988) ebx_558;
				if (ebx_558->t0008 != edi_1065)
					goto l0805BCF0;
				ebx_1036 = esp_1027->dw0008;
				if (*((word32) edi_1065 + 8) != ebx_1036)
					goto l0805BCF0;
				if ((dl_565 & 0x01) != 0x00)
				{
					word32 edx_2597;
					word32 ecx_2596;
					malloc_printerr(out ecx_2596, out edx_2597);
					esi_1637 = esi_1030;
					goto l0805BF70;
				}
				if (esp_1027->t0010 <= 1007 && (esp_1027[3] == esp_1027->dw0008 && (*((word32) esi_1030 + 60) == edi_1065 && (word32) esp_1027->t0010 + 16 < (eax_435 & ~0x07))))
				{
					union Eq_2 * esi_586 = esp_1027->t0010;
					word32 ebx_590 = edi_1065 + esi_586;
					struct Eq_35737 * edi_591 = esp_1027->ptr0004;
					edi_591->t0040 = ebx_590;
					edi_591->t0044 = ebx_590;
					edi_591->t003C = ebx_590;
					word32 edi_596 = esp_1027->dw0008;
					*((word32) ebx_590 + 8) = edi_596;
					*((word32) ebx_590 + 0x0C) = edi_596;
					eax_1783 = edi_1065;
					ecx_1112 = (eax_435 & ~0x07) - esi_586;
					if (ecx_1112 > 1007)
					{
						*((word32) ebx_590 + 16) = 0x00;
						*((word32) ebx_590 + 20) = 0x00;
					}
					struct Eq_35764 * esi_614 = esp_1027[5];
					*((word64) edi_1065.u0 + 4) = (word32) (int8) (esp_1027->ptr0004 != &g_t80CE500) << 0x02 | esi_586 | 0x01;
					*((word32) ebx_590 + 4) = ecx_1112 | 0x01;
					esi_614->t0000 = ecx_1112;
					edx_1144 = ecx_1112 | 0x01;
					goto l0805B65C;
				}
				Eq_2 ecx_628 = esp_1027[3];
				word32 ebx_629 = esp_1027->dw0008;
				*((word32) esi_1030 + 0x0044) = ecx_628;
				*((word32) ecx_628 + 8) = ebx_629;
				if (esp_1027->t0010 != (eax_435 & ~0x07))
				{
					if ((eax_435 & ~0x07) <= 1007)
					{
						uint32 eax_1571 = (eax_435 & ~0x07) >> 0x04;
						esp_1027[3] = (struct Eq_33988) (eax_1571 + 0x01);
						union Eq_2 * eax_1574 = (word32) esi_1030 + 64 + eax_1571 * 0x08;
						esp_1027[5] = (struct Eq_33988) (eax_1574 - 0x08);
						ebx_1036 = *eax_1574;
						ecx_1564 = eax_1571 + 0x01;
						goto l0805B8A8;
					}
l0805BBD0:
					edx_942 = eax_1039 >> 0x06;
					if (edx_942 <= 0x2D)
						goto l0805BD00;
					uint32 edx_1000 = eax_1039 >> 0x09;
					if (edx_1000 <= 0x14)
						esp_1027[3] = (struct Eq_33988) (edx_1000 + 0x5B);
					else
					{
						uint32 edx_1004 = eax_1039 >> 0x0C;
						if (edx_1004 <= 0x0A)
							esp_1027[3] = (struct Eq_33988) (edx_1004 + 110);
						else
						{
							uint32 edx_1008 = eax_1039 >> 0x0F;
							if (edx_1008 <= 0x04)
								esp_1027[3] = (struct Eq_33988) (edx_1008 + 0x77);
							else
							{
								uint32 edx_1013 = eax_1039 >> 0x12;
								if (edx_1013 > 0x02)
									edx_1013 = 0x02;
								esp_1027[3] = (struct Eq_33988) (edx_1013 + 0x7C);
							}
						}
					}
					goto l0805BBF3;
				}
				*esp_1027[5].ptr0004 = (struct Eq_33988) (edx_468 | 0x01);
				edx_1144 = edx_468 | 0x01;
				if (esi_1030 != 0x080CE500)
					*((word64) edi_1065.u0 + 4) |= 0x04;
				ecx_1112 = (word64) edi_1065.u0 + 8;
				if (esp_1027->dw0034 == 0x00)
				{
l0805BB0B:
					Eq_2 eax_980 = perturb_byte;
					al_1800 = (byte) eax_980;
					eax_24_8_1815 = SLICE(eax_980, word24, 8);
					esi_1435 = ecx_1112;
					if (eax_980 == 0x00)
						goto l0805B66F;
					esi_1435 = ecx_1112;
					goto l0805BB20;
				}
				edx_1144 = CONVERT(Mem650[Mem650[esp_1027 + 0x14:word32] + Mem650[esp_1027 + 0x18:word32]:byte], byte, int32);
				if (edx_1144 >= esp_1027[6])
					goto l0805BB0B;
				if (esp_1027->dw005C > 0x03FF)
				{
					struct Eq_35834 * esp_667 = esp_1027 - 0x0C;
					esp_667->ptrFFFFFFFC = 0x080A39A0;
					word32 ecx_2628;
					word32 edx_2629;
					word32 eax_2627;
					__malloc_assert(0x080A29DD, 2926, 0x080A2925, out eax_2627, out ecx_2628, out edx_2629);
					esp_1027 = esp_667 - 4;
					break;
				}
				struct Eq_35854 * edx_964 = esp_1027->ptr0050;
				Eq_35823 ebx_965[] = esp_1027->ptr0014;
				esp_1027->dw0040 = 0x01;
				word32 edx_969 = edx_964->dw0040;
				*((word64) edi_1065.u0 + 0x0C) = ebx_965;
				*((word64) edi_1065.u0 + 8) = edx_969;
				int32 edi_972 = esp_1027[2];
				esp_1027->ptr0050->t0040 = ecx_1112;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&ebx_965[edi_972].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (byte) ((word32) edx_1144 + 1);
				edi_1065 = esp_1027[3];
			}
			if (esp_1027->dw0040 != 0x00)
				goto l0805C0AC;
l0805BC60:
			dwLoc04_1913 = ebp;
			dwLoc08_1914 = edi;
			dwLoc0C_1915 = esi;
			dwLoc10_1916 = ebx;
			Eq_2 edi_691 = esp_1027->t0010;
			if (edi_691 > 1007)
			{
				struct Eq_34596 * ecx_697 = (word32) esi_1030 + 56 + esp_1027[4] *32 0x08;
				struct Eq_34605 * eax_698 = ecx_697->ptr0000;
				if (eax_698 != ecx_697 - 0x08 && eax_698->t0004 >= edi_691)
				{
					esi_1030 = edi_691;
					edi_1065 = eax_698->t0014;
					while (true)
					{
						ui32 edx_708 = *((word32) edi_1065 + 4);
						ebx_1036 = edx_708 & ~0x07;
						if (edi_691 <= (edx_708 & ~0x07))
							break;
						edi_1065 = *((word32) edi_1065 + 20);
					}
					esp_1027->t0010 = edx_708 & ~0x07;
					if (ecx_697->t0004 != edi_1065)
					{
						Eq_2 eax_720 = *((word32) edi_1065 + 8);
						if (edx_708 == *((word32) eax_720 + 4))
							edi_1065 = eax_720;
					}
					uint32 ecx_726 = *((word32) edi_1065 + 4);
					if ((ecx_726 & ~0x07) != *((word32) edi_1065 + (ecx_726 & ~0x07)))
					{
l0805C29E:
						word32 ecx_2618;
						word32 edx_2619;
						malloc_printerr(out ecx_2618, out edx_2619);
l0805C2A9:
						struct Eq_34466 * esp_1590 = esp_1027 - 0x0C;
						esp_1590->ptrFFFFFFFC = 134887828;
						word32 ecx_2599;
						word32 edx_2600;
						word32 eax_2598;
						__malloc_assert(0x080A29DD, 0x0B7F, 0x080A2925, out eax_2598, out ecx_2599, out edx_2600);
						esp_1027 = esp_1590 - 4;
						goto l0805C2C9;
					}
					edx_1301 = *((word32) edi_1065 + 8);
					Eq_2 eax_732 = *((word32) edi_1065 + 0x0C);
					if (*((word32) edx_1301 + 0x0C) == edi_1065 && *((word32) eax_732 + 8) == edi_1065)
					{
						*((word32) edx_1301 + 0x0C) = eax_732;
						*((word32) eax_732 + 8) = edx_1301;
						if (ecx_726 <= 1007)
							goto l0805C3E4;
						ecx_1302 = *((word32) edi_1065 + 16);
						if (ecx_1302 == 0x00)
						{
l0805C3E4:
							dwLoc04_1913 = ebp;
							dwLoc08_1914 = edi;
							dwLoc0C_1915 = esi;
							dwLoc10_1916 = ebx;
							ebp_1474 = (struct Eq_33981 *) &g_t80CE000;
							ecx_1464 = esp_1027->t0010 - esi_1030;
							if (ecx_1464 > 0x0F)
							{
								edx_1301 = edi_1065 + esi_1030;
								Eq_2 eax_1471 = esp_1027->ptr0004->t0040;
								if (*((word32) eax_1471 + 0x0C) == esp_1027->dw0008)
								{
									Eq_2 ebx_1500 = esp_1027->dw0008;
									*((word32) edx_1301 + 8) = eax_1471;
									*((word32) edx_1301 + 0x0C) = ebx_1500;
									esp_1027->ptr0004->t0040 = edx_1301;
									*((word32) eax_1471 + 0x0C) = edx_1301;
									if (ecx_1464 > 1007)
									{
										((word32) edx_1301 + 16)->u0 = 0x00;
										((word32) edx_1301 + 20)->u0 = 0x00;
									}
									*((word32) edi_1065 + 4) = (word32) (int8) (esp_1027->ptr0004 != &g_t80CE500) << 0x02 | esi_1030 | 0x01;
									*((word32) edx_1301 + 4) = ecx_1464 | 0x01;
									Mem1532[edi_1065 + Mem1530[esp_1027 + 0x10:word32]:word32] = ecx_1464;
									goto l0805BA28;
								}
								malloc_printerr(out ecx_1464, out edx_1301);
							}
							union Eq_2 * eax_1487 = esp_1027->t0010;
							*((char *) eax_1487 + ((word32) edi_1065 + 4)) |= 0x01;
							if (esp_1027->ptr0004 != &g_t80CE500)
								*((word32) edi_1065 + 4) |= 0x04;
							goto l0805BA28;
						}
l0805C4C4:
						dwLoc04_1913 = ebp;
						dwLoc08_1914 = edi;
						dwLoc0C_1915 = esi;
						dwLoc10_1916 = ebx;
						ebp_1125 = (struct Eq_34022 *) &g_t80CE000;
						if (*((word32) ecx_1302 + 20) == edi_1065)
						{
							Eq_2 eax_1310 = *((word32) edi_1065 + 20);
							if (*((word32) eax_1310 + 16) == edi_1065)
							{
								if (*((word32) edx_1301 + 16) != 0x00)
								{
									*((word32) ecx_1302 + 20) = eax_1310;
									*((word32) *((word32) edi_1065 + 20) + 16) = ecx_1302;
								}
								else if (ecx_1302 != edi_1065)
								{
									*((word32) edx_1301 + 20) = eax_1310;
									*((word32) edx_1301 + 16) = ecx_1302;
									*((word32) *((word32) edi_1065 + 16) + 20) = edx_1301;
									*((word32) *((word32) edi_1065 + 20) + 16) = edx_1301;
								}
								else
								{
									*((word32) edx_1301 + 20) = edx_1301;
									*((word32) edx_1301 + 16) = edx_1301;
								}
								goto l0805C3E4;
							}
						}
l0805C4A3:
						malloc_printerr(out ecx_1112, out edx_1144);
l0805C4AE:
						*((word32) edx_1144 + 20) = edx_1144;
						*((word32) edx_1144 + 16) = edx_1144;
l0805C1AB:
						ebx_1036 -= esi_1030;
						if (ebx_1036 > 0x0F)
						{
							edx_1144 = ecx_1112 + esi_1030;
							Eq_2 eax_1358 = esp_1027->ptr0004->t0040;
							if (*((word32) eax_1358 + 0x0C) == esp_1027->dw0008)
							{
								Eq_2 edi_1390 = esp_1027->dw0008;
								*((word32) edx_1144 + 8) = eax_1358;
								*((word32) edx_1144 + 0x0C) = edi_1390;
								struct Eq_35079 * edi_1393 = esp_1027->ptr0004;
								edi_1393->t0040 = edx_1144;
								*((word32) eax_1358 + 0x0C) = edx_1144;
								if (esi_1030 <= 1007)
									edi_1393->t003C = edx_1144;
								if (ebx_1036 > 1007)
								{
									((word32) edx_1144 + 16)->u0 = 0x00;
									((word32) edx_1144 + 20)->u0 = 0x00;
								}
								*((word32) ecx_1112 + 4) = (word32) (int8) (esp_1027->ptr0004 != (char *) ebp_1125 + 0x0500) << 0x02 | esi_1030 | 0x01;
								*((word32) edx_1144 + 4) = ebx_1036 | 0x01;
								esp_1027->t0010->u2 = ebx_1036;
l0805C22B:
								word32 eax_1438 = ebp_1125->dw188C;
								esi_1435 = (word32) ecx_1112 + 8;
								al_1800 = (byte) eax_1438;
								eax_24_8_1815 = SLICE(eax_1438, word24, 8);
								if (eax_1438 == 0x00)
									goto l0805B66F;
								goto l0805BB20;
							}
							eax_1200 = malloc_printerr(out ecx_1112, out edx_1144);
l0805C34D:
							if (*((word32) eax_1200 + 20) == ecx_1112)
							{
								Eq_2 edi_1373 = *((word32) ecx_1112 + 20);
								if (*((word32) edi_1373 + 16) == ecx_1112)
								{
									if (*((word32) edx_1144 + 16) != 0x00)
									{
										*((word32) eax_1200 + 20) = edi_1373;
										edx_1144 = *((word32) ecx_1112 + 20);
										*((word32) edx_1144 + 16) = eax_1200;
										goto l0805C1AB;
									}
									if (eax_1200 != ecx_1112)
									{
										*((word32) edx_1144 + 16) = eax_1200;
										Eq_2 eax_1382 = *((word32) ecx_1112 + 16);
										*((word32) edx_1144 + 20) = edi_1373;
										*((word32) eax_1382 + 20) = edx_1144;
										*((word32) *((word32) ecx_1112 + 20) + 16) = edx_1144;
										goto l0805C1AB;
									}
									goto l0805C4AE;
								}
							}
							goto l0805C4A3;
						}
						goto l0805C279;
					}
l0805C293:
					word32 edx_2621;
					word32 ecx_2620;
					malloc_printerr(out ecx_2620, out edx_2621);
					goto l0805C29E;
				}
			}
			ui32 eax_747 = esp_1027[4];
			edi_1065 = eax_747 + 0x01 >> 0x05;
			Eq_2 edx_1274 = (word32) esi_1030 + 56 + eax_747 * 0x08;
			uint32 eax_754 = 0x01 << (byte) (eax_747 + 0x01);
			uint32 ebx_757 = *((word32) esi_1030 + (edi_1065 * 0x04 + 1080));
l0805BCA8:
			if (eax_754 > ebx_757 || eax_754 == 0x00)
			{
				do
				{
					edi_1065 = (word32) edi_1065 + 1;
					if (edi_1065 == 0x04)
					{
						Eq_2 ebx_781 = *((word32) esi_1030 + 56);
						ui32 eax_782 = *((word32) ebx_781 + 4);
						if (*((word32) esi_1030 + 0x0454) < (eax_782 & ~0x07))
							goto l0805C26E;
						union Eq_2 * ecx_788 = esp_1027->t0010;
						if ((char *) ecx_788 + 16 <= (eax_782 & ~0x07))
						{
							edx_1144 = ebx_781 + ecx_788;
							esp_1027->ptr0004->t0038 = edx_1144;
							Eq_2 eax_792 = (eax_782 & ~0x07) - ecx_788;
							ecx_1112 = eax_792;
							if (esp_1027->ptr0004 == &g_t80CE500)
								edi_1065.u0 = 0x00;
							*((word32) ebx_781 + 4) = ecx_788 | edi_1065 | 0x01;
							*((word32) edx_1144 + 4) = eax_792 | 0x01;
							Eq_2 eax_820 = perturb_byte;
							esi_1435 = (word32) ebx_781 + 8;
							al_1800 = (byte) eax_820;
							eax_24_8_1815 = SLICE(eax_820, word24, 8);
							if (eax_820 != 0x00)
								goto l0805BB20;
							goto l0805B66F;
						}
						else
						{
							if (*((word32) esi_1030 + 8) == 0x00)
								goto l0805C2E9;
							word32 ebp_2625;
							word32 edi_2626;
							word32 ebx_2624;
							word32 edx_2623;
							word32 ecx_2622;
							malloc_consolidate(esi_1030, gs, out ecx_2622, out edx_2623, out ebx_2624, out ebp_2625, out edi_2626);
							esp_1027[4] = esp_1027[9];
							if (esp_1027->t0010 > (union Eq_2 *) 1007)
							{
								esp_1027[4] = (struct Eq_33988) esp_1027->dw0038;
								if (esp_1027->dw0070 > 0x2D)
								{
									esp_1027[4] = (struct Eq_33988) esp_1027->dw0044;
									if (esp_1027->dw0074 > 0x14)
									{
										esp_1027[4] = esp_1027[7];
										if (esp_1027[0x0A] > 0x0A)
										{
											ui32 eax_854 = esp_1027->dw0068;
											if (esp_1027[8] > 0x04)
												eax_854 = esp_1027->dw0064;
											esp_1027[4] = (struct Eq_33988) eax_854;
										}
									}
								}
							}
							esp_1027->ptr0014 = (Eq_35823 (*)[]) gs->tFFFFFFE4;
							goto l0805B7A1;
						}
					}
					ebx_757 = (uint32) *((word32) esi_1030 + (edi_1065 * 0x04 + 1080));
				} while (ebx_757 == 0x00);
				edx_1274 = (word32) esi_1030 + 48 + (edi_1065 << 0x06) * 0x04;
				eax_754 = 0x01;
			}
			do
			{
				if ((eax_754 & ebx_757) != 0x00)
				{
					ecx_1112 = *((word32) edx_1274 + 0x0C);
					if (edx_1274 != ecx_1112)
						goto l0805C155;
					ebx_757 &= ~eax_754;
					*((word32) esi_1030 + (edi_1065 * 0x04 + 1080)) = ebx_757;
					edx_1274 = (word32) edx_1274 + 8;
					eax_754 *= 0x02;
					goto l0805BCA8;
				}
				edx_1274 = (word32) edx_1274 + 8;
				eax_754 *= 0x02;
			} while (eax_754 != 0x00);
			struct Eq_34639 * esp_920 = esp_1027 - 0x0C;
			esp_920->ptrFFFFFFFC = 0x080A39AC;
			word32 edx_2606;
			word32 ecx_2605;
			word32 eax_2604;
			__malloc_assert(0x080A2A84, 4024, 0x080A2925, out eax_2604, out ecx_2605, out edx_2606);
			esp_1027 = esp_920 - 4;
l0805BCF0:
			word32 ecx_2595;
			eax_1039 = malloc_printerr(out ecx_2595, out edx_942);
l0805BD00:
			esp_1027[3] = (struct Eq_33988) (edx_942 + 0x31);
l0805BBF3:
			struct Eq_34697 * ecx_1034 = (word32) esi_1030 + 56 + esp_1027[3] *32 0x08;
			edx_1035 = ecx_1034->t0000;
			ebx_1036 = ecx_1034 - 0x08;
			if (ecx_1034 - 0x08 != edx_1035)
			{
				esp_1027->dw007C = eax_1039 | 0x01;
				struct Eq_34696 * eax_1044 = ecx_1034->ptr0004;
				esp_1027[5] = (struct Eq_33988) eax_1044;
				uint32 eax_1046 = eax_1044->dw0004;
				if (((byte) eax_1046 & 0x04) == 0x00)
				{
					if (eax_1046 > esp_1027->dw007C)
					{
						Eq_2 eax_1565 = *((word32) edx_1035 + 20);
						ecx_1564 = esp_1027[3];
						*((word32) edi_1065 + 16) = edx_1035;
						*((word32) edi_1065 + 20) = eax_1565;
						*((word32) eax_1565 + 16) = edi_1065;
						*((word32) edx_1035 + 20) = edi_1065;
						goto l0805B8A8;
					}
l0805BFF0:
					Eq_2 eax_1091 = *((word32) edx_1035 + 4);
					if (((byte) eax_1091 & 0x04) == 0x00)
					{
						Eq_2 ecx_1204 = esp_1027->dw007C;
						do
						{
							bool v46_1911 = ecx_1204 == eax_1091;
							if (ecx_1204 >= eax_1091)
								goto l0805C030;
							edx_1035 = *((word32) edx_1035 + 16);
							eax_1091 = *((word32) edx_1035 + 4);
						} while (((byte) eax_1091 & 0x04) == 0x00);
						struct Eq_34855 * esp_1220 = esp_1027 - 0x0C;
						esp_1220->ptrFFFFFFFC = 0x080A39AC;
						esp_1027 = esp_1220 - 4;
						word32 eax_2611;
						word32 ecx_2612;
						v46_1911 = SLICE(__malloc_assert(0x080A2A51, 3863, 0x080A2925, out eax_2611, out ecx_2612, out edx_1035), bool, 2);
l0805C030:
						if (v46_1911)
						{
							ebx_1036 = *((word32) edx_1035 + 8);
							goto l0805C056;
						}
						Eq_2 eax_1242 = *((word32) edx_1035 + 20);
						*((word32) edi_1065 + 16) = edx_1035;
						*((word32) edi_1065 + 20) = eax_1242;
						if (*((word32) *((word32) edx_1035 + 20) + 16) == edx_1035)
						{
							*((word32) edx_1035 + 20) = edi_1065;
							*((word32) *((word32) edi_1065 + 20) + 16) = edi_1065;
							ebx_1036 = edx_1035;
l0805C056:
							Eq_2 eax_1289 = *((word32) ebx_1036 + 0x0C);
							esp_1027[5] = (struct Eq_33988) eax_1289;
							if (*((word32) eax_1289 + 8) != ebx_1036)
							{
								malloc_printerr(out ecx_1302, out edx_1301);
								goto l0805C4C4;
							}
							ecx_1564 = esp_1027[3];
							goto l0805B8A8;
						}
					}
					else
					{
						struct Eq_34818 * esp_1099 = esp_1027 - 0x0C;
						esp_1099->ptrFFFFFFFC = 0x080A39AC;
						word32 edx_2610;
						word32 eax_2609;
						__malloc_assert(0x080A2A51, 0x0F13, 0x080A2925, out eax_2609, out ecx_1112, out edx_2610);
						esp_1027 = esp_1099 - 4;
l0805C155:
						Eq_2 eax_1117 = *((word32) ecx_1112 + 4);
						dwLoc04_1913 = ebp;
						dwLoc08_1914 = edi;
						dwLoc0C_1915 = esi;
						dwLoc10_1916 = ebx;
						ebp_1125 = (struct Eq_34022 *) &g_t80CE000;
						esi_1030 = esp_1027->t0010;
						ebx_1036 = eax_1117 & ~0x07;
						if (esi_1030 <= (eax_1117 & ~0x07))
						{
							ui32 * eax_1140 = (word32) ecx_1112 + (eax_1117 & ~0x07);
							esp_1027->t0010 = eax_1140;
							if (*eax_1140 != (eax_1117 & ~0x07))
								goto l0805C29E;
							edx_1144 = *((word32) ecx_1112 + 8);
							Eq_2 eax_1145 = *((word32) ecx_1112 + 0x0C);
							if (*((word32) edx_1144 + 0x0C) == ecx_1112 && *((word32) eax_1145 + 8) == ecx_1112)
							{
								*((word32) edx_1144 + 0x0C) = eax_1145;
								*((word32) eax_1145 + 8) = edx_1144;
								if (eax_1117 > 1007)
								{
									eax_1200 = *((word32) ecx_1112 + 16);
									if (eax_1200 != 0x00)
										goto l0805C34D;
								}
								goto l0805C1AB;
							}
							goto l0805C293;
						}
						struct Eq_34952 * esp_1127 = esp_1027 - 0x0C;
						esp_1127->ptrFFFFFFFC = 0x080A39AC;
						word32 edx_2617;
						word32 ecx_2616;
						word32 eax_2615;
						__malloc_assert(0x080A3530, 4043, 0x080A2925, out eax_2615, out ecx_2616, out edx_2617);
						esp_1027 = esp_1127 - 4;
					}
					word32 ecx_2613;
					word32 edx_2614;
					malloc_printerr(out ecx_2613, out edx_2614);
l0805C26E:
					malloc_printerr(out ecx_1112, out edx_1144);
					dwLoc04_1913 = ebp;
					dwLoc08_1914 = edi;
					dwLoc0C_1915 = esi;
					dwLoc10_1916 = ebx;
					ebp_1125 = (struct Eq_34022 *) &g_t80CE000;
l0805C279:
					struct Eq_35032 * eax_1340 = esp_1027->t0010;
					eax_1340->dw0004 |= 0x01;
					if (esp_1027->ptr0004 != (char *) ebp_1125 + 0x0500)
						*((word32) ecx_1112 + 4) |= 0x04;
					goto l0805C22B;
				}
				goto l0805BFC8;
			}
			goto l0805BF80;
		}
	}
	else if (esi_1637 > 1007)
	{
		uint32 ebx_74 = esi_1637 >> 0x06;
		uint32 edi_75 = esi_1637 >> 0x09;
		uint32 ecx_76 = esi_1637 >> 0x0C;
		uint32 eax_84 = esi_1637 >> 0x0F;
		if (*((word32) eax + 8) != 0x00)
		{
			word32 edx_2587;
			word32 ebx_2588;
			word32 ebp_2589;
			word32 edi_2590;
			word32 ecx_2586;
			malloc_consolidate(eax, gs, out ecx_2586, out edx_2587, out ebx_2588, out ebp_2589, out edi_2590);
		}
l0805B73F:
		uint32 eax_254 = esi_1637 - 0x01;
		gs->tFFFFFFE4 == 0x00;
		esi_1030 = eax;
l0805B7A1:
		ptr32 ebx_868 = esp_1027->dw0028;
		edi_1065 = *((word32) esi_1030 + 0x0044);
		esp_1027->dw001C = 0x00;
		esp_1027->dw0040 = 0x00;
		up32 eax_880 = (ebx_868 + 0x3C)->dw80CE000;
		esp_1027->dw004C = eax_880;
		word32 eax_883 = (ebx_868 + 0x38)->dw80CE000;
		esp_1027->b005B = (int8) (eax_880 != 0x00);
		esp_1027[6] = (struct Eq_33988) eax_883;
		esp_1027->ptr0050 = (struct Eq_155202 *) (esp_1027->ptr0014 + esp_1027->dw002C)->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000->a0000;
		goto l0805B7DB;
	}
l0805B978:
	edx_1301 = (word32) eax + 64 + (esi_1637 >> 0x04) * 0x08;
	edi_1065 = *((word32) edx_1301 + 4);
	ecx_1464 = edx_1301 - 0x08;
	if (edx_1301 - 0x08 != edi_1065)
	{
		Eq_2 eax_298 = *((word32) edi_1065 + 0x0C);
		if (*((word32) eax_298 + 8) == edi_1065)
		{
			*((word32) esi_1637 + ((word32) edi_1065 + 4)) |= 0x01;
			*((word32) edx_1301 + 4) = eax_298;
			*((word32) eax_298 + 8) = edx_1301 - 0x08;
			if (eax != 0x080CE500)
				*((word32) edi_1065 + 4) |= 0x04;
			if (gs->tFFFFFFE4 != 0x00 && g_dw80CE4D0 > esi_1637 - (struct Eq_36099 *) 0x01 >> 0x04)
			{
				while (true)
				{
					Eq_2 ebx_542 = (int32) esp_1027->t0010;
					esi_497 = esp_1027[2];
					do
					{
						if (ebx_542 >= esi_497)
							goto l0805BA28;
						eax_495 = *((word32) edx_1301 + 4);
						if (ecx_1464 == eax_495)
							goto l0805BA28;
					} while (eax_495 == 0x00);
l0805BEF0:
					esp_1027[2] = (struct Eq_33988) esi_497;
					struct Eq_36006 * ebx_503 = esp_1027->ptr0014;
					esp_1027->dw0028 = (word32) *((word32) eax_495 + 0x0C);
					int32 esi_505 = esp_1027[3];
					(word32) eax_495 + 4 + esi_505 |= 0x01;
					if (esp_1027->ptr0004 != ebx_503)
						*((word32) eax_495 + 4) |= 0x04;
					Eq_2 esi_517 = esp_1027->dw0028;
					word32 ebx_518 = esp_1027->dw0008;
					esp_1027->t0010 = (word32) esp_1027->t0010 + 1;
					*((word32) edx_1301 + 4) = esi_517;
					*((word32) esi_517 + 8) = ecx_1464;
					struct Eq_35916 * eax_520 = (word32) eax_495 + 8;
					struct Eq_35919 * esi_530 = esp_1027->dw0020;
					eax_520->dw0004 = ebx_518;
					eax_520->ptr0000 = esi_530->ptr0040;
					Eq_154031 ebx_534[] = esp_1027->dw0008;
					esi_530->ptr0040 = eax_520;
					ebx_534[esp_1027->dw001C].t0000 = esp_1027->t0010;
				}
			}
l0805BA28:
			Eq_2 eax_1539 = (word32) edi_1065 + 8;
			word32 eax_1547 = ebp_1474->dw188C;
			esp_1027 = fp - 0x009C;
			esi_1435 = eax_1539;
			al_1800 = (byte) eax_1547;
			eax_24_8_1815 = SLICE(eax_1547, word24, 8);
			if (eax_1547 == 0x00)
			{
				ecxOut = ecx_1464;
				edxOut = edx_1301;
				ebxOut = dwLoc10_1916;
				ebpOut = dwLoc04_1913;
				esiOut = dwLoc0C_1915;
				ediOut = dwLoc08_1914;
				return eax_1539;
			}
			goto l0805BB20;
		}
		word32 ecx_2630;
		word32 edx_2631;
		malloc_printerr(out ecx_2630, out edx_2631);
		esi_1030 = esi_1637;
l0805BFC8:
		struct Eq_34713 * esp_1058 = esp_1027 - 0x0C;
		esp_1058->ptrFFFFFFFC = 0x080A39AC;
		word32 ecx_2608;
		word32 eax_2607;
		__malloc_assert(134883894, 0x0F06, 0x080A2925, out eax_2607, out ecx_2608, out edx_1035);
		esp_1027 = esp_1058 - 4;
		goto l0805BFF0;
	}
	goto l0805B73F;
}

// 0805C510: void malloc_check(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_28092 dwArg04)
// Called from:
//      memalign_check
//      realloc_check
void malloc_check(Eq_2 edi, struct Eq_9 * gs, Eq_28092 dwArg04)
{
	if (dwArg04 == ~0x00)
		gs->tFFFFFFE0.u0 = 0x0C;
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_35;
		if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_35))
			__lll_lock_wait_private(eax_35, 0x080CE500, gs);
		word32 ebx_49;
		word32 edx_150;
		top_check(out edx_150, out ebx_49);
		word32 ebp_152;
		word32 ecx_151;
		struct Eq_36145 * ebx_63;
		Eq_2 edx_66;
		Eq_28092 esi_67;
		word32 edi_153;
		Eq_2 eax_68 = _int_malloc(ebx_49 + 0x0500, (word32) dwArg04 + 1, edi, gs, out ecx_151, out edx_66, out ebx_63, out ebp_152, out esi_67, out edi_153);
		if (gs->t000C != 0x00)
			__lock();
		word32 v13_80 = ebx_63->dw0500 - 0x01;
		ebx_63->dw0500 = v13_80;
		if (v13_80 != 0x00)
			__lll_unlock_wake_private(&ebx_63->dw0500, eax_68, edx_66, gs);
		mem2mem_check(eax_68, esi_67);
	}
}

// 0805C5B0: void tcache_init.part.6(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_malloc
//      free
//      __realloc
//      __libc_calloc
void tcache_init.part.6(struct Eq_9 * gs)
{
	Eq_2 ecx_106;
	Eq_2 edx_104;
	Eq_2 ebx_101 = gs->tFFFFFFEC;
	if (ebx_101 != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_58;
		if (!__cmpxchg(*ebx_101, 0x01, 0x00, out eax_58))
			__lll_lock_wait_private(eax_58, ebx_101, gs);
	}
	else
	{
		word32 edx_217;
		word32 esi_219;
		word32 edi_220;
		word32 ebx_218;
		word32 ecx_216;
		Eq_2 eax_19 = get_free_list(gs, out ecx_216, out edx_217, out ebx_218, out esi_219, out edi_220);
		ebx_101 = eax_19;
		if (eax_19 == 0x00)
		{
			word32 edi_228;
			word32 ebx_226;
			word32 esi_227;
			Eq_2 eax_31 = arena_get2.part.5(0x0140, 0x00, gs, out ebx_226, out esi_227, out edi_228);
			word32 edi_234;
			word32 esi_233;
			word32 ebx_231;
			word32 ebp_232;
			word32 ecx_230;
			Eq_2 eax_37 = _int_malloc(eax, 0x0140, edi, gs, out ecx_230, out edx_104, out ebx_231, out ebp_232, out esi_233, out edi_234);
			ebx_101 = eax_31;
			ecx_106 = eax_37;
			if (eax_37 != 0x00 || eax_31 == 0x00)
				goto l0805C6A2;
l0805C688:
			ebx_101 = arena_get_retry(ebx_101, ecx, 0x0140, gs);
			word32 ebx_237;
			word32 ecx_236;
			word32 ebp_238;
			word32 esi_239;
			word32 edi_240;
			ecx_106 = _int_malloc(eax, 0x0140, edi, gs, out ecx_236, out edx_104, out ebx_237, out ebp_238, out esi_239, out edi_240);
l0805C6A2:
			if (ebx_101 == 0x00)
				goto l0805C61B;
l0805C604:
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v14_122 = *ebx_101 - 0x01;
			*ebx_101 = v14_122;
			if (v14_122 != 0x00)
				__lll_unlock_wake_private(ebx_101, ecx_106, edx_104, gs);
l0805C61B:
			if (ecx_106 != 0x00)
			{
				gs->tFFFFFFE4 = ecx_106;
				*ecx_106 = 0x00;
				*((word32) ecx_106 + 316) = 0x00;
				Eq_36329 edi_139 = (word32) ecx_106 + 4;
				word32 * edi_143 = edi_139 & ~0x03;
				word32 ecx_148;
				for (ecx_148 = ecx_106 - (edi_139 & ~0x03) + 0x0140 >>u 0x02; ecx_148 != 0x00; --ecx_148)
				{
					*edi_143 = 0x00;
					++edi_143;
				}
			}
			return;
		}
	}
	word32 ecx_221;
	word32 edi_225;
	word32 ebx_222;
	word32 esi_224;
	word32 ebp_223;
	Eq_2 eax_80 = _int_malloc(ebx_101, 0x0140, edi, gs, out ecx_221, out edx_104, out ebx_222, out ebp_223, out esi_224, out edi_225);
	ecx_106 = eax_80;
	if (eax_80 != 0x00)
		goto l0805C604;
	goto l0805C688;
}

// 0805C6B0: Register Eq_2 _int_memalign(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_9) gsOut)
// Called from:
//      memalign_check
//      _mid_memalign
Eq_2 _int_memalign(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, struct Eq_9 & gsOut)
{
	word24 eax_24_8_33 = SLICE(eax, word24, 8);
	Eq_2 esi_25;
	Eq_2 ebx_28;
	if (ecx > 0x04)
	{
		ebx_28 = (word32) ecx + 19 & ~0x0F;
		esi_25 = SEQ(eax_24_8_33, (int8) (ebx_28 > ~0x20));
	}
	else
	{
		esi_25.u0 = 0x00;
		ebx_28.u0 = 0x10;
	}
	if (ebx_28 >= ecx)
	{
		ecx = esi_25;
		if ((byte) esi_25 == 0x00)
		{
			ecx = ~0x10 - edx;
			if (ecx >= ebx_28)
			{
				Eq_2 edi_79;
				word32 esi_391;
				Eq_2 ebx_181;
				word32 ebp_180;
				Eq_2 edx_124;
				Eq_2 ecx_123;
				Eq_2 eax_82 = _int_malloc(eax, (word32) edx + ((word64) ebx_28.u0 + 16), edx, gs, out ecx_123, out edx_124, out ebx_181, out ebp_180, out esi_391, out edi_79);
				Eq_2 esi_135 = eax_82;
				if (eax_82 != 0x00)
				{
					ecx_123 = eax_82 - (struct Eq_36408 *) 0x08;
					edx_124 = (uint32) ((uint64) eax_82 % edi_79);
					Eq_2 dwLoc34_305 = eax_82 - (struct Eq_36408 *) 0x08;
					if (edx_124 == 0x00)
					{
l0805C726:
						Eq_36432 eax_221 = *((word32) dwLoc34_305 + 4);
						if (((byte) eax_221 & 0x02) == 0x00)
						{
							edx_124 = (word32) ebx_181 + 16;
							if (edx_124 < (eax_221 & ~0x07))
							{
								ui32 eax_231 = (eax_221 & ~0x07) - ebx_181;
								word32 edx_232 = dwLoc34_305 + ebx_181;
								if (eax != ebp_180 + 0x0500)
									eax_231 |= 0x04;
								*((word32) edx_232 + 4) = eax_231 | 0x01;
								*((word32) dwLoc34_305 + 4) = ebx_181 | *((word32) dwLoc34_305 + 4) & 0x07;
								word32 ebx_392;
								word32 ebp_393;
								word32 edi_394;
								_int_free(eax, edx_232, dwLoc34_305, gs, out ecx_123, out edx_124, out ebx_392, out ebp_393, out esi_135, out edi_394, out gs);
							}
						}
						goto l0805C779;
					}
					ui32 eax_105 = (word32) edi_79 + (eax_82 - 0x01) & -edi_79;
					Eq_2 dwLoc2C_306 = eax_105 - 0x08;
					uint32 eax_109 = eax_105 - 0x08 - (eax_82 - (struct Eq_36408 *) 0x08);
					if (eax_109 <= 0x0F)
					{
						Eq_2 edx_112 = (word32) edi_79 + (eax_105 - 0x08);
						dwLoc2C_306 = edx_112;
						eax_109 = edx_112 - (eax_82 - (struct Eq_36408 *) 0x08);
					}
					Eq_2 edx_119 = *((word32) eax_82 - 4);
					ecx_123 = (edx_119 & ~0x07) - eax_109;
					edx_124 = edx_119 & 0x02;
					ui32 dwLoc24_309 = edx_119 & 0x02;
					if ((edx_119 & 0x02) == 0x00)
					{
						Eq_2 dwLoc20_311 = ecx_123;
						if (eax != ebp_180 + 0x0500)
						{
							dwLoc24_309 = 0x04;
							dwLoc20_311 = ecx_123 | 0x04;
						}
						*((word32) dwLoc2C_306 + 4) = dwLoc20_311 | 0x01;
						*((word32) ecx_123 + ((word32) dwLoc2C_306 + 4)) |= 0x01;
						*((word32) eax_82 - 4) = eax_109 | *((word32) eax_82 - 4) & 0x07 | dwLoc24_309;
						ui32 edi_183;
						word32 edx_395;
						word32 esi_396;
						_int_free(eax, eax_82 - (struct Eq_36408 *) 0x08, edi_79, gs, out ecx_123, out edx_395, out ebx_181, out ebp_180, out esi_396, out edi_183, out gs);
						if (ebx_181 <= ecx_123)
						{
							esi_135 = (word32) dwLoc2C_306 + 8;
							edx_124 = (uint32) ((uint64) ((word32) dwLoc2C_306 + 8) % edi_183);
							if (edx_124 == 0x00)
							{
								dwLoc34_305 = dwLoc2C_306;
								goto l0805C726;
							}
						}
						word32 eax_397;
						word32 ecx_398;
						word32 edx_399;
						__malloc_assert(ebp_180 + ~0x0002AA77, 4742, ebp_180 + ~0x0002B6DA, out eax_397, out ecx_398, out edx_399);
					}
					*dwLoc2C_306 = (word32) *((word32) eax_82 - 8) + eax_109;
					*((word32) dwLoc2C_306 + 4) = ecx_123 | 0x02;
					esi_135 = (word32) dwLoc2C_306 + 8;
				}
l0805C779:
				ecxOut = ecx_123;
				edxOut = edx_124;
				gsOut = gs;
				return esi_135;
			}
		}
	}
	gs->tFFFFFFE0.u0 = 0x0C;
	ecxOut = ecx;
	edxOut = edx;
	gsOut = gs;
	return 0x00;
}

// 0805C8C0: void memalign_check(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack uint32 dwArg04, Stack Eq_28092 dwArg08)
// Called from:
//      _int_memalign
void memalign_check(Eq_2 edi, struct Eq_9 * gs, uint32 dwArg04, Eq_28092 dwArg08)
{
	if (dwArg04 <= 0x10)
		malloc_check(edi, gs, dwArg08);
	else if (dwArg04 > 0x80000000)
		gs->tFFFFFFE0.u0 = 22;
	else if (dwArg08 > ~0x10 - dwArg04)
		gs->tFFFFFFE0.u0 = 0x0C;
	else
	{
		if ((dwArg04 - 0x01 & dwArg04) != 0x00 && dwArg04 > 0x20)
		{
			uint32 eax_72 = 0x20;
			do
				eax_72 *= 0x02;
			while (dwArg04 > eax_72);
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_94;
		if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_94))
			__lll_lock_wait_private(eax_94, 0x080CE500, gs);
		Eq_2 ebx_108;
		word32 edx_227;
		top_check(out edx_227, out ebx_108);
		Eq_2 edx_128;
		word32 ecx_228;
		struct Eq_36637 * gs_229;
		Eq_2 eax_126 = _int_memalign(0x080CE500, (word32) dwArg08 + 1, ebx_108, gs, out ecx_228, out edx_128, out gs_229);
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_136 = g_t80CE500 - 0x01;
		g_t80CE500 = v15_136;
		if (v15_136 != 0x00)
			__lll_unlock_wake_private(0x080CE500, eax_126, edx_128, gs);
		mem2mem_check(eax_126, dwArg08);
	}
}

// 0805C9F0: Register (ptr32 Eq_9) free_check.part.3(Register Eq_2 eax, Register Eq_2 edi, Register (ptr32 Eq_9) gs)
// Called from:
//      free_check
//      realloc_check
struct Eq_9 * free_check.part.3(Eq_2 eax, Eq_2 edi, struct Eq_9 * gs)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_24;
	if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_24))
		__lll_lock_wait_private(eax_24, 0x080CE500, gs);
	Eq_2 ecx_42;
	word32 edx_214;
	Eq_2 eax_40 = mem2chunk_check(eax, null, out ecx_42, out edx_214);
	if (eax_40 == 0x00)
	{
		word32 edx_216;
		word32 ecx_215;
		malloc_printerr(out ecx_215, out edx_216);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		free_check(stackArg4);
		return gs;
	}
	else if ((*((word32) eax_40 + 4) & 0x02) != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_75 = g_t80CE500 - 0x01;
		g_t80CE500 = v14_75;
		if (v14_75 != 0x00)
			__lll_unlock_wake_private(0x080CE500, ecx_42, eax_40, gs);
		word32 ecx_221;
		word32 edx_222;
		word32 ebx_223;
		munmap_chunk(eax_40, gs, out ecx_221, out edx_222, out ebx_223);
		return gs;
	}
	else
	{
		word32 edi_219;
		struct Eq_36720 * ebx_116;
		Eq_2 ecx_117;
		Eq_2 edx_119;
		struct Eq_9 * gs_121;
		word32 esi_218;
		word32 ebp_217;
		_int_free(0x080CE500, eax_40, edi, gs, out ecx_117, out edx_119, out ebx_116, out ebp_217, out esi_218, out edi_219, out gs_121);
		if (gs_121->t000C != 0x00)
			__lock();
		word32 v13_132 = ebx_116->dw0500 - 0x01;
		ebx_116->dw0500 = v13_132;
		if (v13_132 != 0x00)
			__lll_unlock_wake_private(&ebx_116->dw0500, ecx_117, edx_119, gs_121);
		return gs_121;
	}
}

// 0805CAB0: void free_check(Stack Eq_2 dwArg04)
// Called from:
//      free_check.part.3
void free_check(Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	free_check.part.3(eax, edi, gs);
}

// 0805CAD0: Register Eq_2 _int_realloc(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 esi, Register Eq_2 edi, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_36799 edxOut)
// Called from:
//      realloc_check
//      __realloc
Eq_2 _int_realloc(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 esi, Eq_2 edi, Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_36799 & edxOut)
{
	Eq_2 edi_112;
	Eq_36799 edx_107;
	Eq_2 ecx_145;
	ptr32 esp_167 = fp - 0x3C;
	Eq_2 eax_23 = *((word32) edx + 4);
	if (eax_23 > 0x08)
	{
		esi = edx;
		Eq_2 edx_27 = *((word32) eax + 0x0454);
		if (edx_27 > ecx)
		{
			Eq_2 ecx_153;
			edi_112 = eax_23 & 0x02;
			dwLoc28 = eax_23 & 0x02;
			if ((eax_23 & 0x02) != 0x00)
			{
l0805CCD8:
				struct Eq_36832 * esp_179 = esp_167 - 0x0C;
				esp_179->ptrFFFFFFFC = 134887744;
				word32 eax_615;
				word32 edx_616;
				__malloc_assert(134884038, 0x11DA, 0x080A2925, out eax_615, out ecx_153, out edx_616);
				esp_167 = esp_179 - 4;
				goto l0805CD00;
			}
			word32 edi_51 = edx + ecx;
			Eq_2 dwLoc2C_439 = edi_51;
			edi = *((word32) edi_51 + 4);
			if (edi > 0x08 && edx_27 > (edi & ~0x07))
			{
				Eq_2 eax_161;
				eax_161 = eax_23;
				if (ecx >= dwArg04)
				{
l0805CBD0:
					Eq_36870 edi_343 = ecx - dwArg04;
					ui32 eax_348 = eax_161 & 0x07;
					if (edi_343 <= 0x0F)
					{
						edx_107.u0 = 0x04;
						if (eax == 0x080CE500)
							edx_107 = eax_23 & 0x02;
						ecx_145 = ecx | eax_348 | edx_107;
						*((word32) edx + 4) = ecx_145;
						*((word32) dwLoc2C_439 + 4) |= 0x01;
					}
					else
					{
						word32 edx_358 = dwArg04 + edx;
						if (eax != 0x080CE500)
						{
							dwLoc28.u0 = 0x04;
							edi_343 |= 0x04;
						}
						*((word32) edx + 4) = eax_348 | dwArg04 | dwLoc28;
						Eq_2 edi_371 = edi_343 | 0x01;
						*((word32) edx_358 + 4) = edi_371;
						*((word32) dwLoc2C_439 + 4) |= 0x01;
						word32 esi_640;
						word32 edi_641;
						struct Eq_37164 * gs_642;
						word32 ebp_639;
						word32 ebx_638;
						_int_free(eax, edx_358, edi_371, gs, out ecx_145, out edx_107, out ebx_638, out ebp_639, out esi_640, out edi_641, out gs_642);
					}
					edi_112 = (word32) edx + 8;
					goto l0805CC04;
				}
				if (*((word32) eax + 56) != edi_51)
				{
					struct Eq_36886 * edx_123 = (word32) edi_51 + (edi & ~0x07);
					if ((edx_123->b0004 & 0x01) == 0x00)
					{
						Eq_2 ebx_127 = (word32) ecx + (edi & ~0x07);
						if (dwArg04 <= ebx_127)
						{
							Eq_2 ecx_233;
							if (edx_123->dw0000 == (edi & ~0x07))
							{
								ecx_233 = *((word32) edi_51 + 8);
								Eq_2 edx_234 = *((word32) edi_51 + 0x0C);
								if (*((word32) ecx_233 + 0x0C) == edi_51 && *((word32) edx_234 + 8) == edi_51)
								{
									*((word32) ecx_233 + 0x0C) = edx_234;
									*((word32) edx_234 + 8) = ecx_233;
									if (edi <= 1007)
									{
l0805CBBB:
										ecx = ebx_127;
										dwLoc2C_439 = edx + ebx_127;
										eax_161 = eax_23;
										goto l0805CBD0;
									}
									edi = *((word32) edi_51 + 16);
									eax_161 = eax_23;
									if (edi == 0x00)
										goto l0805CBBB;
l0805CDA6:
									Eq_2 ebx_278 = edi_51;
									if (*((word32) edi + 20) == edi_51)
									{
										Eq_2 edx_282 = *((word32) edi_51 + 20);
										if (*((word32) edx_282 + 16) == edi_51)
										{
											ebx_278 = ebx_127 + edx;
											if (*((word32) ecx_233 + 16) != 0x00)
											{
												*((word32) edi + 20) = edx_282;
												*((word32) *((word32) edi_51 + 20) + 16) = edi;
												dwLoc2C_439 = ebx_278;
												ecx = ebx_127;
												goto l0805CBD0;
											}
											if (edi != edi_51)
											{
												*((word32) ecx_233 + 16) = edi;
												*((word32) ecx_233 + 20) = edx_282;
												*((word32) *((word32) edi_51 + 16) + 20) = ecx_233;
												*((word32) *((word32) edi_51 + 20) + 16) = ecx_233;
												dwLoc2C_439 = ebx_278;
												ecx = ebx_127;
												goto l0805CBD0;
											}
l0805CE11:
											*((word32) ecx_233 + 20) = ecx_233;
											*((word32) ecx_233 + 16) = ecx_233;
											ecx = ebx_127;
											dwLoc2C_439 = ebx_278;
											goto l0805CBD0;
										}
									}
									word32 edx_627;
									eax_161 = malloc_printerr(out ecx_233, out edx_627);
									goto l0805CE11;
								}
								word32 edx_626;
								word32 ecx_625;
								malloc_printerr(out ecx_625, out edx_626);
							}
							word32 edx_624;
							eax_161 = malloc_printerr(out ecx_233, out edx_624);
							goto l0805CDA6;
						}
					}
l0805CC75:
					word32 esi_622;
					word32 edi_623;
					word32 ebp_621;
					word32 ebx_620;
					Eq_2 eax_143 = _int_malloc(eax, dwArg04 - 0x0F, edi, gs, out ecx_145, out edx_107, out ebx_620, out ebp_621, out esi_622, out edi_623);
					edi_112 = eax_143;
					if (eax_143 == 0x00)
						goto l0805CC04;
					Eq_2 eax_151 = *((word32) eax_143 - 4);
					ecx_153 = ecx;
					if (edi_51 != eax_143 - 0x08)
					{
l0805CD00:
						struct Eq_37029 * esp_196 = esp_167 - 0x04;
						esp_196->tFFFFFFFC = ecx_153 - (struct Eq_37032 *) 0x04;
						Mem207[esp_196 + -8:word32] = edx + 0x08;
						esp_196->tFFFFFFF4 = edi_112;
						word32 edx_629;
						word32 ecx_628;
						memcpy(esp_196->tFFFFFFF4, esp_196->tFFFFFFF8, esp_196->tFFFFFFFC, out ecx_628, out edx_629);
						word32 ebx_630;
						word32 esi_632;
						word32 edi_633;
						struct Eq_37063 * gs_634;
						word32 ebp_631;
						_int_free(esp_196->t0010, edx, edi_112, gs, out ecx_145, out edx_107, out ebx_630, out ebp_631, out esi_632, out edi_633, out gs_634);
						goto l0805CC04;
					}
					ecx += eax_151 & ~0x07;
					if (dwArg04 > ecx)
					{
						word32 ecx_636;
						word32 edx_637;
						word32 eax_635;
						__malloc_assert(134886864, 0x121F, 0x080A2925, out eax_635, out ecx_636, out edx_637);
						esp_167 = fp - 0x4C;
						goto l0805CCD8;
					}
					eax_161 = *((word32) edx + 4);
					dwLoc2C_439 = edx + ecx;
					goto l0805CBD0;
				}
				edi = (word32) ecx + (edi & ~0x07);
				if (dwArg04 + 0x10 >u edi)
					goto l0805CC75;
l0805CD50:
				ecx_145 = eax;
				ui32 eax_95 = eax_23 & 0x07;
				edx_107.u0 = 0x04;
				if (eax == 0x080CE500)
					edx_107 = dwLoc28;
				*((word32) esi + 4) = eax_95 | dwArg04 | edx_107;
				word32 eax_116 = dwArg04 + esi;
				*((word32) eax + 56) = eax_116;
				*((word32) eax_116 + 4) = edi - dwArg04 | 0x01;
				edi_112 = esi + 0x08;
l0805CC04:
				ecxOut = ecx_145;
				edxOut = edx_107;
				return edi_112;
			}
l0805CD40:
			word32 edx_618;
			word32 ecx_617;
			eax_23 = malloc_printerr(out ecx_617, out edx_618);
			goto l0805CD50;
		}
	}
	word32 edx_614;
	word32 ecx_613;
	malloc_printerr(out ecx_613, out edx_614);
	goto l0805CD40;
}

// 0805CE40: void realloc_check(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_28092 dwArg08)
void realloc_check(Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_28092 dwArg08)
{
	struct Eq_37185 * ebx_17 = &g_t80CE000;
	Eq_2 esp_18 = fp - 0x3C;
	ui32 eax_20 = gs->dw0014;
	Eq_28092 ebp_23 = dwArg08;
	Eq_2 esi_198 = dwArg04;
	if (dwArg08 == ~0x00)
	{
l0805CEE1:
		gs->tFFFFFFE0.u0 = 0x0C;
		goto l0805CEF0;
	}
	if (dwArg04 == 0x00)
	{
		malloc_check(edi, gs, dwArg08);
		goto l0805CEF0;
	}
	if (dwArg08 == 0x00)
	{
		gs = free_check.part.3(dwArg04, edi, gs);
		goto l0805CEF0;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_77;
	if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_77))
		__lll_lock_wait_private(eax_77, 0x080CE500, gs);
	Eq_2 edx_94;
	Eq_2 ecx_95;
	Eq_2 eax_93 = mem2chunk_check(dwArg04, fp - 0x24, out ecx_95, out edx_94);
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v15_108 = g_t80CE500 - 0x01;
	g_t80CE500 = v15_108;
	if (v15_108 != 0x00)
		__lll_unlock_wake_private(0x080CE500, ecx_95, edx_94, gs);
	if (eax_93 == 0x00)
		goto l0805D058;
	if (dwArg08 <= 0x05)
		goto l0805CEE1;
	Eq_2 eax_129 = (word32) dwArg08 + 20 & ~0x0F;
	if (eax_129 > ~0x20 || eax_129 < (word32) dwArg08 + 1)
		goto l0805CEE1;
	ui32 eax_139 = *((word32) eax_93 + 4);
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_152;
	if (!__cmpxchg(g_t80CE500, 0x01, 0x00, out eax_152))
		__lll_lock_wait_private(eax_152, 0x080CE500, gs);
	Eq_2 edx_191;
	Eq_2 ecx_190;
	if ((*((word32) eax_93 + 4) & 0x02) != 0x00)
	{
		Eq_2 eax_209 = mremap_chunk(eax_93, eax_129, gs, out ecx_190, out edx_191);
		if (eax_209 != 0x00)
		{
			esi_198 = (word32) eax_209 + 8;
			if (eax_209 != 0x08)
				goto l0805CFA6;
		}
		else
		{
			if (eax_129 <= (eax_139 & ~0x07) - 0x04)
				goto l0805CFA6;
			word32 ebx_225;
			word32 edx_538;
			top_check(out edx_538, out ebx_225);
			esp_18.u0 = <invalid>;
			Eq_2 edi_235;
			Eq_2 esi_237;
			word32 edx_539;
			Eq_2 eax_238 = _int_malloc(ebx_225 + 0x0500, *((word64) esp_18.u0 + 0x0C), eax_93, gs, out ecx_190, out edx_539, out ebx_17, out ebp_23, out esi_237, out edi_235);
			edx_191 = eax_238;
			if (eax_238 != 0x00)
			{
				*((word64) esp_18.u0 - 8) = *((word64) esp_18.u0 + 8) - 0x08;
				*((word64) esp_18.u0 - 0x0C) = esi_237;
				*((word64) esp_18.u0 - 16) = eax_238;
				*((word64) esp_18.u0 + 4) = eax_238;
				word32 ecx_540;
				word32 edx_541;
				memcpy(*((word64) esp_18.u0 - 16), *((word64) esp_18.u0 - 0x0C), *((word64) esp_18.u0 - 8), out ecx_540, out edx_541);
				word32 edx_542;
				munmap_chunk(edi_235, gs, out ecx_190, out edx_542, out ebx_17);
				Eq_2 esp_274 = <invalid>;
				edx_191 = *((word32) esp_274 + 20);
				esi_198 = edx_191;
l0805CFA6:
				if (gs->t000C != 0x00)
					__lock();
				word32 v19_305 = ebx_17->dw0500 - 0x01;
				ebx_17->dw0500 = v19_305;
				if (v19_305 != 0x00)
					__lll_unlock_wake_private(&ebx_17->dw0500, ecx_190, edx_191, gs);
				mem2mem_check(esi_198, ebp_23);
l0805CEF0:
				if ((eax_20 ^ gs->dw0014) == 0x00)
					return;
				word32 ecx_533;
				word32 edx_534;
				__stack_chk_fail(out ecx_533, out edx_534);
l0805D058:
				word32 ecx_535;
				word32 edx_536;
				malloc_printerr(out ecx_535, out edx_536);
				__malloc_fork_lock_parent(gs);
				return;
			}
		}
	}
	else
	{
		word32 edx_537;
		top_check(out edx_537, out ebx_17);
		Eq_2 esp_171 = <invalid>;
		*((word32) esp_171 - 16) = *((word32) esp_171 + 4);
		Eq_2 eax_189 = _int_realloc(&ebx_17->dw0500, *((word32) esp_171 + 8), eax_93, dwArg04, eax_93, *((word32) esp_171 - 16), out ecx_190, out edx_191);
		esp_18 = esp_171;
		esi_198 = eax_189;
		if (eax_189 != 0x00)
			goto l0805CFA6;
	}
	Eq_2 eax_289 = *((word32) esp_18 + 24);
	*eax_289 = ~*eax_289;
	esi_198.u0 = 0x00;
	goto l0805CFA6;
}

// 0805D070: void __malloc_fork_lock_parent(Register (ptr32 Eq_9) gs)
// Called from:
//      realloc_check
void __malloc_fork_lock_parent(struct Eq_9 * gs)
{
	if (__libc_malloc_initialized <= 0x00)
		return;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_28;
	if (!__cmpxchg(list_lock, 0x01, 0x00, out eax_28))
		__lll_lock_wait_private(eax_28, 0x080CF880, gs);
	Eq_2 edx_44 = 0x080CE500;
	do
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_59;
		if (!__cmpxchg(*edx_44, 0x01, 0x00, out eax_59))
			__lll_lock_wait_private(eax_59, edx_44, gs);
		edx_44 = *((word32) edx_44 + 0x0448);
	} while (edx_44 != 0x080CE500);
}

// 0805D100: void __malloc_fork_unlock_parent(Register (ptr32 Eq_9) gs)
void __malloc_fork_unlock_parent(struct Eq_9 * gs)
{
	if (__libc_malloc_initialized > 0x00)
	{
		Eq_2 edx_13 = 0x080CE500;
		do
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 v13_23 = *edx_13 - 0x01;
			*edx_13 = v13_23;
			if (v13_23 != 0x00)
				__lll_unlock_wake_private(edx_13, 0x080CE500, edx_13, gs);
			edx_13 = *((word32) edx_13 + 0x0448);
		} while (edx_13 != 0x080CE500);
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v14_46 = list_lock - 0x01;
		list_lock = v14_46;
		if (v14_46 != 0x00)
			__lll_unlock_wake_private(0x080CF880, 0x080CE500, edx_13, gs);
	}
}

// 0805D170: void __malloc_fork_unlock_child(Register (ptr32 Eq_37560) gs)
void __malloc_fork_unlock_child(struct Eq_37560 * gs)
{
	if (__libc_malloc_initialized > 0x00)
	{
		free_list_lock.u0 = 0x00;
		Eq_2 ecx_21 = gs->tFFFFFFEC;
		if (ecx_21 != 0x00)
			((word32) ecx_21 + 1104)->u0 = 0x01;
		free_list.u0 = 0x00;
		word32 edi_29 = 0x00;
		Eq_2 edx_30 = 0x00;
		Eq_2 eax_33 = 0x080CE500;
		do
		{
			*eax_33 = 0x00;
			if (ecx_21 != eax_33)
			{
				((word32) eax_33 + 1104)->u0 = 0x00;
				*((word32) eax_33 + 0x044C) = edx_30;
				edi_29 = 0x01;
				edx_30 = eax_33;
			}
			eax_33 = *((word32) eax_33 + 0x0448);
		} while (eax_33 != 0x080CE500);
		if ((byte) edi_29 != 0x00)
			free_list = edx_30;
		list_lock.u0 = 0x00;
	}
}

// 0805D210: void __malloc_check_init()
void __malloc_check_init()
{
	using_malloc_checking = 0x01;
	__malloc_hook = &g_t805C510;
	__free_hook.u0 = 0x0805CAB0;
	__realloc_hook = &g_t805CE40;
	__memalign_hook = &g_t805C8C0;
}

// 0805D260: Register Eq_2 __libc_malloc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_3337 ebxOut, Register out Eq_3338 ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      _nl_make_l10nflist
//      _nl_normalize_codeset
//      new_exp
//      __gettextparse
//      qsort_r
//      locked_vfxprintf
//      __fopen_internal
//      _IO_wfile_seekoff
//      vasprintf
//      _IO_file_fopen
//      save_for_backup
//      _IO_default_doallocate
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_pbackfail
//      malloc_hook_ini
//      _mid_memalign
//      __realloc
//      strdup
//      getcwd
//      __tsearch
//      _dl_non_dynamic_init
//      __gconv_open
//      find_derivation
//      add_alias2.isra.1.part.2
//      __gconv_get_path
//      __gconv_load_cache
//      __gconv_lookup_cache
//      __gconv_find_shlib
//      new_composite_name
//      _nl_intern_locale_data
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      printf_positional
//      vfprintf
//      __printf_fp_l
//      register_printf_modifier
//      printf_positional
//      __vfwprintf
//      _IO_file_doallocate
//      _IO_wfile_doallocate
//      _IO_getdelim
//      save_for_wbackup.isra.0
//      _IO_wdefault_pbackfail
//      _IO_wdefault_doallocate
//      __libc_scratch_buffer_grow_preserve
//      __libc_scratch_buffer_set_array_size
//      __strndup
//      argz_create_sep
//      __alloc_dir
//      _dl_process_pt_note
//      add_name_to_object.isra.4
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      expand_dynamic_string_token
//      fillin_rpath
//      cache_rpath.part.6
//      _dl_init_paths
//      _dl_lookup_symbol_x
//      _dl_new_object
//      _dl_important_hwcaps
//      _dl_allocate_tls_storage
//      _dl_allocate_tls
//      _dl_add_to_slotinfo
//      _dl_get_origin
//      _dl_scope_free
//      _dl_exception_create
//      _dl_exception_create_format
//      strerror
//      add_to_global
//      dl_open_worker
//      _dl_close_worker
//      _dl_map_object_deps
//      search_object
//      __register_frame
//      __register_frame_table
Eq_2 __libc_malloc(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_3337 & ebxOut, union Eq_3338 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 edx_100;
	Eq_2 ecx_174;
	Eq_2 esi_19 = dwArg04;
	<anonymous> * eax_20 = __malloc_hook;
	if (eax_20 != null)
	{
		Eq_2 eax_31;
		eax_20();
		edx_100 = eax_31;
		goto l0805D3AA;
	}
	int8 dl_381;
	Eq_2 eax_378;
	ui32 eax_372 = (word32) dwArg04 + 19;
	if (dwArg04 > 0x04)
	{
l0805D340:
		eax_378 = eax_372 & ~0x0F;
		dl_381 = (int8) (eax_378 > ~0x20);
		goto l0805D29B;
	}
	dl_381 = 0x00;
	eax_378.u0 = 0x10;
l0805D29B:
	ptr32 esp_170 = fp + 16;
	if (eax_378 < esi_19 || dl_381 != 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		ecxOut = ecx;
		edxOut.u0 = 0x00;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return 0x00;
	}
	Eq_2 edi_71 = eax_378 - 0x01;
	Eq_2 eax_73 = gs->tFFFFFFE4;
	if (eax_73 == 0x00)
	{
		if (gs->bFFFFFFE8 != 0x00)
			goto l0805D2CD;
		tcache_init.part.6(gs);
		if (g_dw80CE4D0 > edi_71 >> 0x04)
		{
			eax_73 = gs->tFFFFFFE4;
			if (eax_73 != 0x00)
			{
l0805D380:
				ecx_174 = (word32) eax_73 + (edi_71 >> 0x04) * 0x04;
				edx_100 = *((word32) ecx_174 + 64);
				if (edx_100 != 0x00)
				{
					if (edi_71 > 0x03FF)
					{
						word32 ecx_581;
						word32 edx_582;
						word32 eax_580;
						__malloc_assert(0x080A29DD, 0x0B7F, 0x080A2925, out eax_580, out ecx_581, out edx_582);
						Eq_2 edx_125;
						Eq_2 ecx_126;
						Eq_2 eax_124 = malloc_hook_ini(out ecx_126, out edx_125);
						ecxOut = ecx_126;
						edxOut = edx_125;
						ebxOut.u0 = 0x080CE000;
						ebpOut = edi_71 >> 0x04;
						esiOut = esi_19;
						ediOut = edi_71;
						return eax_124;
					}
					*((word64) ecx_174.u0 + 64) = *edx_100;
					Mem131[eax_73 + (edi_71 >>u 0x04):byte] = Mem129[eax_73 + (edi_71 >>u 0x04):byte] - 0x01;
					*((word32) edx_100 + 4) = 0x00;
					goto l0805D3AA;
				}
				goto l0805D2CD;
			}
		}
l0805D2CD:
		Eq_2 esi_164 = esi_19;
		if (gs->t000C == 0x00)
		{
			word32 edi_573;
			word32 ebp_571;
			word32 esi_572;
			word32 ebx_570;
			word32 edx_569;
			Eq_2 eax_312 = _int_malloc(0x080CE500, esi_19, edi_71, gs, out ecx_174, out edx_569, out ebx_570, out ebp_571, out esi_572, out edi_573);
			edx_100 = eax_312;
			if (eax_312 != 0x00)
			{
				byte al_336 = *((word32) eax_312 + 4);
				if ((al_336 & 0x02) == 0x00 && (al_336 & 0x04) != 0x00)
				{
					ecx_174.u0 = 0x080CE500;
					if (*(eax_312 - (struct Eq_37732 *) 0x08 & 0xFFF00000) != 0x080CE500)
					{
						word32 edx_574;
						__malloc_assert(0x080A3604, 0x0BF6, 0x080A2925, out eax_372, out ecx, out edx_574);
						goto l0805D340;
					}
				}
				goto l0805D3AA;
			}
			goto l0805D3B8;
		}
		Eq_2 ecx_302;
		Eq_2 edi_142 = gs->tFFFFFFEC;
		if (edi_142 == 0x00)
		{
l0805D4B0:
			word32 edi_579;
			word32 esi_578;
			word32 edx_576;
			word32 ebx_577;
			word32 ecx_575;
			Eq_2 eax_256 = get_free_list(gs, out ecx_575, out edx_576, out ebx_577, out esi_578, out edi_579);
			edi_142 = eax_256;
			if (eax_256 == 0x00)
			{
				word32 ebx_588;
				word32 esi_589;
				word32 edi_590;
				Eq_2 eax_268 = arena_get2.part.5(esi_164, 0x00, gs, out ebx_588, out esi_589, out edi_590);
				word32 edx_592;
				word32 ebx_593;
				word32 ebp_594;
				word32 esi_595;
				word32 edi_596;
				Eq_2 eax_274 = _int_malloc(eax, esi_164, eax_268, gs, out ecx_174, out edx_592, out ebx_593, out ebp_594, out esi_595, out edi_596);
				edi_142 = eax_268;
				edx_100 = eax_274;
				if (eax_274 != 0x00 || eax_268 == 0x00)
					goto l0805D4F5;
l0805D4E0:
				Eq_2 eax_294 = arena_get_retry(edi_142, ecx_302, esi_164, gs);
				edi_142 = eax_294;
				word32 edx_597;
				word32 ebx_598;
				word32 ebp_599;
				word32 esi_600;
				word32 edi_601;
				edx_100 = _int_malloc(eax, esi_164, eax_294, gs, out ecx_302, out edx_597, out ebx_598, out ebp_599, out esi_600, out edi_601);
				ecx_174 = ecx_302;
l0805D4F5:
				if (edi_142 != 0x00)
					goto l0805D442;
				goto l0805D459;
			}
			goto l0805D42F;
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_154;
		if (!__cmpxchg(*edi_142, 0x01, 0x00, out eax_154))
			__lll_lock_wait_private(eax_154, edi_142, gs);
l0805D42F:
		word32 esi_586;
		word32 ebp_585;
		word32 ebx_584;
		word32 edx_583;
		word32 edi_587;
		Eq_2 eax_172 = _int_malloc(edi_142, esi_164, edi_142, gs, out ecx_174, out edx_583, out ebx_584, out ebp_585, out esi_586, out edi_587);
		edx_100 = eax_172;
		if (eax_172 == 0x00)
			goto l0805D4E0;
l0805D442:
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v20_187 = *edi_142 - 0x01;
		*edi_142 = v20_187;
		if (v20_187 != 0x00)
			__lll_unlock_wake_private(edi_142, ecx_174, edx_100, gs);
l0805D459:
		if (edx_100 == 0x00)
		{
l0805D3B8:
			ecxOut = ecx_174;
			edxOut.u0 = 0x00;
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return 0x00;
		}
		Eq_37818 al_204 = *((word32) edx_100 + 4);
		if ((al_204 & 0x02) == 0x00)
		{
			ecx_174.u0 = 0x080CE500;
			if ((al_204 & 0x04) != 0x00)
				ecx_174 = *(edx_100 - (struct Eq_37933 *) 0x08 & 0xFFF00000);
			if (ecx_174 != edi_142)
			{
				struct Eq_37940 * esp_227 = esp_170 - 0x0C;
				esp_227->ptrFFFFFFFC = 0x080A3930;
				word32 eax_602;
				word32 ecx_603;
				word32 edx_604;
				__malloc_assert(0x080A366C, 0x0C0A, 0x080A2925, out eax_602, out ecx_603, out edx_604);
				esp_170 = esp_227 - 4;
				goto l0805D4B0;
			}
		}
l0805D3AA:
		ecxOut = ecx_174;
		edxOut = edx_100;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return edx_100;
	}
	else
	{
		if (edi_71 >> 0x04 >= g_dw80CE4D0)
			goto l0805D2CD;
		goto l0805D380;
	}
}

// 0805D530: Register Eq_2 malloc_hook_ini(Register out Eq_979 ecxOut, Register out Eq_979 edxOut)
// Called from:
//      __libc_malloc
Eq_2 malloc_hook_ini(union Eq_979 & ecxOut, union Eq_979 & edxOut)
{
	__malloc_hook = null;
	ptmalloc_init(gs);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_33;
	word32 edx_34;
	word32 ebx_35;
	word32 ebp_36;
	word32 esi_37;
	word32 edi_38;
	Eq_2 eax_20 = __libc_malloc(gs, stackArg0, dwArg04, out ecx_33, out edx_34, out ebx_35, out ebp_36, out esi_37, out edi_38);
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_20;
}

// 0805D570: Register Eq_2 _mid_memalign(Register Eq_2 eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      memalign_hook_ini
//      aligned_alloc
//      __valloc
//      __pvalloc
//      posix_memalign
Eq_2 _mid_memalign(Eq_2 eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 edi_11 = edx;
	Eq_2 ebx_117 = eax;
	Eq_2 esp_135 = fp - 0x1C;
	<anonymous> * eax_23 = __memalign_hook;
	if (eax_23 != null)
	{
		Eq_2 eax_37;
		eax_23();
		return eax_37;
	}
	if (eax <= 0x10)
	{
		word32 esi_513;
		word32 edi_514;
		word32 ebx_511;
		word32 ebp_512;
		word32 ecx_509;
		word32 edx_510;
		return __libc_malloc(gs, dwLoc30, edx, out ecx_509, out edx_510, out ebx_511, out ebp_512, out esi_513, out edi_514);
	}
	if (eax > 0x80000000)
	{
		gs->tFFFFFFE0.u0 = 22;
		return 0x00;
	}
	Eq_2 edx_171;
	if (edx > ~0x10 - eax)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		edx_171.u0 = 0x00;
		return edx_171;
	}
	if ((eax - 0x01 & eax) != 0x00)
	{
		if (eax > 0x20)
		{
			Eq_2 eax_110 = 0x20;
			do
				eax_110 *= 0x02;
			while (eax > eax_110);
			ebx_117 = eax_110;
		}
		else
			ebx_117.u0 = 0x20;
	}
	ptr32 esi_130 = 0x080CE000;
	if (gs->t000C == 0x00)
	{
		struct Eq_38063 * gs_517;
		word32 ecx_515;
		word32 edx_516;
		Eq_2 eax_329 = _int_memalign(0x080CE500, edx, ebx_117, gs, out ecx_515, out edx_516, out gs_517);
		edx_171 = eax_329;
		if (eax_329 == 0x00)
			return 0x00;
		byte al_358 = *((word32) eax_329 + 4);
		if ((al_358 & 0x02) != 0x00 || ((al_358 & 0x04) == 0x00 || *(eax_329 - (struct Eq_38088 *) 0x08 & 0xFFF00000) == 0x080CE500))
			return edx_171;
		word32 eax_518;
		word32 ecx_519;
		word32 edx_520;
		__malloc_assert(0x080A36D0, 0x0CEE, 0x080A2925, out eax_518, out ecx_519, out edx_520);
	}
	Eq_2 ecx_164;
	struct Eq_9 * gs_166;
	Eq_2 ebp_125 = gs->tFFFFFFEC;
	if (ebp_125 != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_186;
		if (!__cmpxchg(*ebp_125, 0x01, 0x00, out eax_186))
			__lll_lock_wait_private(eax_186, ebp_125, gs);
	}
	else
	{
		word32 ecx_521;
		word32 edx_522;
		Eq_2 eax_129 = get_free_list(gs, out ecx_521, out edx_522, out ebx_117, out esi_130, out edi_11);
		esp_135.u0 = <invalid>;
		ebp_125 = eax_129;
		if (eax_129 == 0x00)
		{
			Eq_2 eax_148 = arena_get2.part.5((word32) edi_11 + ((word64) ebx_117.u0 + 16), 0x00, gs, out ebx_117, out esi_130, out edi_11);
			word32 edx_524;
			Eq_2 eax_162 = _int_memalign(eax_148, edi_11, ebx_117, gs, out ecx_164, out edx_524, out gs_166);
			ebp_125 = eax_148;
			edx_171 = eax_162;
			if (eax_162 != 0x00 || eax_148 == 0x00)
				goto l0805D7D0;
l0805D7B9:
			Eq_2 eax_226 = arena_get_retry(ebp_125, ecx_164, edi_11, gs_166);
			ebp_125 = eax_226;
			word32 edx_525;
			edx_171 = _int_memalign(eax_226, edi_11, ebx_117, gs_166, out ecx_164, out edx_525, out gs_166);
l0805D7D0:
			if (ebp_125 == 0x00)
				goto l0805D72F;
l0805D716:
			if (gs_166->t000C != 0x00)
				__lock();
			Eq_2 v17_262 = *ebp_125 - 0x01;
			*ebp_125 = v17_262;
			if (v17_262 != 0x00)
				__lll_unlock_wake_private(ebp_125, ecx_164, edx_171, gs_166);
l0805D72F:
			if (edx_171 == 0x00)
				return 0x00;
			byte al_281 = *((word64) edx_171.u0 + 4);
			if ((al_281 & 0x02) != 0x00)
				return edx_171;
			Eq_2 ecx_293 = esi_130 + 0x0500;
			if ((al_281 & 0x04) != 0x00)
				ecx_293 = *(edx_171 - (struct Eq_38215 *) 0x08 & 0xFFF00000);
			if (ecx_293 == ebp_125)
				return edx_171;
			*((word64) esp_135.u0 - 16) = esi_130 + 4294793432;
			word32 ecx_527;
			word32 edx_528;
			word32 eax_526;
			__malloc_assert(esi_130 + 4294793004, 0x0D01, esi_130 + ~0x0002B6DA, out eax_526, out ecx_527, out edx_528);
		}
	}
	word32 edx_523;
	Eq_2 eax_207 = _int_memalign(ebp_125, edi_11, ebx_117, gs, out ecx_164, out edx_523, out gs_166);
	edx_171 = eax_207;
	if (eax_207 != 0x00)
		goto l0805D716;
	goto l0805D7B9;
}

// 0805D7E0: void memalign_hook_ini(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg08)
void memalign_hook_ini(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg08)
{
	__memalign_hook = null;
	Eq_2 ebx_19 = ptmalloc_init(gs);
	_mid_memalign(ebx_19, dwArg00, dwArg08, gs);
}

// 0805D820: Register Eq_2 free(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out Eq_12 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __assert_fail_base
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      _nl_make_l10nflist
//      _nl_explode_name
//      __gettext_free_exp
//      __gettextparse
//      qsort_r
//      __run_exit_handlers
//      locked_vfxprintf
//      __new_fclose
//      __fopen_internal
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_underflow_mmap
//      vasprintf
//      _IO_new_file_underflow
//      _IO_new_file_seekoff
//      _IO_file_xsgetn
//      _IO_file_fopen
//      save_for_backup
//      _IO_free_backup_area
//      _IO_setb
//      _IO_doallocbuf
//      _IO_default_setbuf
//      _IO_default_doallocate
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_pbackfail
//      _IO_str_finish
//      __malloc_arena_thread_freeres
//      __realloc
//      _nl_cleanup_ctype
//      __wcsmbs_load_conv
//      getcwd
//      __tdelete
//      tdestroy
//      __gconv_open
//      __gconv_close
//      find_derivation
//      insert_module
//      add_alias2.isra.1.part.2
//      __gconv_get_path
//      __gconv_read_conf
//      __gconv_load_cache
//      __gconv_lookup_cache
//      __gconv_release_cache
//      __gconv_find_shlib
//      setlocale
//      _nl_find_locale
//      _nl_intern_locale_data
//      _nl_load_locale
//      _nl_unload_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __clearenv
//      _i18n_number_rewrite
//      printf_positional
//      vfprintf
//      _i18n_number_rewrite
//      __printf_fp_l
//      _i18n_number_rewrite
//      printf_positional
//      __vfwprintf
//      save_for_wbackup.isra.0
//      _IO_wsetb
//      _IO_wdefault_pbackfail
//      _IO_wdefault_finish
//      _IO_free_wbackup_area
//      __libc_scratch_buffer_grow_preserve
//      __libc_scratch_buffer_set_array_size
//      argz_create_sep
//      closedir
//      __readonly_area
//      _dl_process_pt_note
//      lose
//      open_verify.constprop.7
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      fillin_rpath
//      cache_rpath.part.6
//      _dl_init_paths
//      _dl_map_object
//      _dl_new_object
//      _dl_allocate_tls_storage
//      _dl_deallocate_tls
//      _dl_scope_free
//      _dl_exception_free
//      dlerror_run
//      __dlerror
//      check_free.isra.0
//      free_key_mem
//      _dlerror_run
//      add_to_global
//      _dl_close_worker
//      _dl_map_object_deps
//      search_object
//      __deregister_frame_info_bases
//      __deregister_frame
//      __dl_iterate_phdr
//      _nl_finddomain_subfreeres
//      _nl_unload_domain
//      buffer_free
//      free_derivation
//      free_modules_db
//      free_mem
//      free_mem
//      do_release_all
//      free_category
//      _nl_locale_subfreeres
//      _nl_archive_subfreeres
//      free_mem
//      free_slotinfo
//      free_mem
Eq_2 free(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, union Eq_12 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 eax_14 = __free_hook;
	if (eax_14 == 0x00)
	{
		if (dwArg04 != 0x00)
		{
			Eq_2 ecx_42 = *((word32) dwArg04 - 4);
			if (((byte) ecx_42 & 0x02) != 0x00)
			{
				if (g_dw80CE4C0 == 0x00 && (ecx_42 > g_t80CE4A8 && ecx_42 <= 0x00080000))
				{
					g_t80CE4A8 = ecx_42 & ~0x07;
					g_dw80CE4A0 = (ecx_42 & ~0x07) * 0x02;
				}
				Eq_12 ecx_74;
				Eq_2 edx_75;
				word32 ebx_184;
				Eq_2 eax_73 = munmap_chunk(eax, gs, out ecx_74, out edx_75, out ebx_184);
				ecxOut = ecx_74;
				edxOut = edx_75;
				return eax_73;
			}
			else
			{
				if (gs->tFFFFFFE4 == 0x00 && gs->bFFFFFFE8 == 0x00)
				{
					tcache_init.part.6(gs);
					ecx_42 = *((word32) dwArg04 - 4);
				}
				Eq_12 ecx_121;
				Eq_2 edx_122;
				word32 ebx_179;
				word32 ebp_180;
				word32 esi_181;
				word32 edi_182;
				struct Eq_38298 * gs_183;
				Eq_2 eax_120 = _int_free(eax, edx_122, edi, gs, out ecx_121, out edx_122, out ebx_179, out ebp_180, out esi_181, out edi_182, out gs_183);
				ecxOut = ecx_121;
				edxOut = edx_122;
				return eax_120;
			}
		}
	}
	else
		eax_14();
	ecxOut = ecx;
	edxOut = edx;
	return eax_14;
}

// 0805D910: void __malloc_arena_thread_freeres(Register (ptr32 Eq_9) gs)
void __malloc_arena_thread_freeres(struct Eq_9 * gs)
{
	ptr32 esp_18 = fp - 0x1C;
	Eq_2 ebp_20 = gs->tFFFFFFE4;
	if (ebp_20 != 0x00)
	{
		gs->tFFFFFFE4.u0 = 0x00;
		gs->bFFFFFFE8 = 0x01;
		word32 * esi_28 = (word32) ebp_20 + 64;
		do
		{
			Eq_2 eax_31 = *esi_28;
			while (eax_31 != 0x00)
			{
				*esi_28 = (word32) *eax_31;
				struct Eq_38372 * esp_41 = esp_18 - 0x0C;
				esp_41->tFFFFFFFC = eax_31;
				word32 ecx_241;
				word32 edx_242;
				free(gs, esp_41->tFFFFFFF8, esp_41->tFFFFFFFC, out ecx_241, out edx_242);
				eax_31 = *esi_28;
				esp_18 = (char *) &esp_41->tFFFFFFFC + 20;
			}
			++esi_28;
		} while (esi_28 != (word32) ebp_20 + 320);
		struct Eq_38402 * esp_70 = esp_18 - 0x0C;
		esp_70->tFFFFFFFC = ebp_20;
		word32 ecx_243;
		word32 edx_244;
		free(gs, esp_70->tFFFFFFF8, esp_70->tFFFFFFFC, out ecx_243, out edx_244);
	}
	Eq_2 edx_92 = gs->tFFFFFFEC;
	gs->tFFFFFFEC.u0 = 0x00;
	if (edx_92 == 0x00)
		return;
	Eq_2 ecx_114 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_109;
	if (!__cmpxchg(free_list_lock, 0x01, 0x00, out eax_109))
		ecx_114 = __lll_lock_wait_private(eax_109, 0x080CF888, gs);
	Eq_2 eax_122 = *((word32) edx_92 + 1104);
	if (eax_122 == 0x00)
	{
		word32 ecx_246;
		word32 edx_247;
		word32 eax_245;
		__malloc_assert(134884119, 0x03C0, 0x080A28A8, out eax_245, out ecx_246, out edx_247);
	}
	else
	{
		*((word32) edx_92 + 1104) = eax_122 - 0x01;
		if (eax_122 == 0x01)
		{
			Eq_2 eax_142 = free_list;
			free_list = edx_92;
			*((word32) edx_92 + 0x044C) = eax_142;
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v15_153 = free_list_lock - 0x01;
		free_list_lock = v15_153;
		if (v15_153 != 0x00)
			__lll_unlock_wake_private(0x080CF888, ecx_114, edx_92, gs);
	}
}

// 0805DA40: Register Eq_2 __realloc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 edxOut, Register out Eq_979 ebpOut, Register out Eq_2 esiOut, Register out ptr32 ediOut)
// Called from:
//      _nl_find_msg
//      read_alias_file
//      vasprintf
//      __malloc_arena_thread_freeres
//      realloc_hook_ini
//      getcwd
//      __add_to_environ
//      _IO_getdelim
//      __libc_scratch_buffer_grow_preserve
//      __argz_add_sep
//      open_verify.constprop.7
//      _dl_new_object
//      _dl_allocate_tls
Eq_2 __realloc(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & edxOut, union Eq_979 & ebpOut, union Eq_2 & esiOut, ptr32 & ediOut)
{
	Eq_2 dwLoc28_524;
	Eq_2 edx_201;
	byte bl_128 = (byte) dwArg04;
	Eq_2 esi_165 = dwArg08;
	<anonymous> * eax_21 = __realloc_hook;
	if (eax_21 != null)
	{
		Eq_2 eax_34;
		eax_21();
		word24 edx_24_8_656 = SLICE(edx_201, word24, 8);
		dwLoc28_524 = eax_34;
		goto l0805DBBD;
	}
	byte dl_47 = (int8) (dwArg08 == 0x00) & (int8) (dwArg04 != 0x00);
	if (dl_47 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_769;
		free(gs, stackArg0, dwArg04, out ecx_769, out edx_201);
		dwLoc28_524.u0 = 0x00;
		goto l0805DBBD;
	}
	if (dwArg04 == 0x00)
	{
		Eq_2 edx_77;
		word32 esi_806;
		word32 edi_807;
		word32 ebp_805;
		word32 ebx_804;
		word32 ecx_803;
		Eq_2 eax_76 = __libc_malloc(gs, dwArg00, dwArg08, out ecx_803, out edx_77, out ebx_804, out ebp_805, out esi_806, out edi_807);
		edxOut = edx_77;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return eax_76;
	}
	Eq_2 eax_190;
	Eq_2 eax_83 = *((word32) dwArg04 - 4);
	Eq_2 dwLoc20_530 = 0x00;
	Eq_2 edx_757 = SEQ(edx_24_8, dl_47);
	eax_190 = eax_83;
	if (((byte) eax_83 & 0x02) == 0x00)
	{
		Eq_2 eax_103;
		Eq_2 edx_104 = SEQ(edx_24_8, dl_47);
		eax_103 = eax_83;
		if (gs->tFFFFFFE4 == 0x00)
		{
			edx_104 = SEQ(edx_24_8, dl_47);
			eax_103 = eax_83;
			if (gs->bFFFFFFE8 == 0x00)
			{
				tcache_init.part.6(gs);
				eax_103 = *((word32) dwArg04 - 4);
				edx_104 = (word32) dl_47;
			}
		}
		dwLoc20_530.u0 = 0x080CE500;
		eax_190 = eax_103;
		edx_757 = edx_104;
		if (((byte) eax_103 & 0x04) != 0x00)
		{
			dwLoc20_530 = *(dwArg04 - (struct Eq_38759 *) 0x08 & 0xFFF00000);
			edx_757 = edx_104;
		}
	}
	word24 edx_24_8_626 = SLICE(edx_757, word24, 8);
	if (-(eax_83 & ~0x07) < dwArg04 - 0x08 || (bl_128 & 0x0F) != 0x00)
	{
		word32 edx_771;
		word32 ecx_770;
		malloc_printerr(out ecx_770, out edx_771);
		Eq_2 edx_157;
		Eq_2 eax_156 = realloc_hook_ini(out edx_157);
		edxOut = edx_157;
		ebpOut.u0 = <invalid>;
		esiOut = dwArg08;
		ediOut = 0x080CE000;
		return eax_156;
	}
	ui32 ecx_160 = (word32) dwArg08 + 19;
	Eq_2 ebp_161 = 0x10;
	Eq_2 edx_753 = edx_757;
	if (dwArg08 > 0x04)
	{
l0805DB60:
		Eq_2 ecx_492 = ecx_160 & ~0x0F;
		ebp_161 = ecx_492;
		edx_753 = SEQ(edx_24_8_626, (int8) (ecx_492 > ~0x20));
		goto l0805DAD1;
	}
l0805DAD1:
	byte dl_168 = (byte) edx_753;
	if (ebp_161 < esi_165 || dl_168 != 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x0C;
		edxOut = edx_753;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return 0x00;
	}
	Eq_2 eax_191 = eax_190 & 0x02;
	if (eax_191 == 0x00)
	{
		if (gs->t000C == 0x00)
		{
			word32 ecx_773;
			Eq_2 eax_431 = _int_realloc(dwLoc20_530, eax_83 & ~0x07, dwArg04 - 0x08, esi_165, 0x080CE000, dwArg00, out ecx_773, out edx_201);
			dwLoc28_524 = eax_431;
			esi_165 = eax_431;
			if (eax_431 != 0x00)
			{
				byte al_442 = *((word32) eax_431 + 4);
				if ((al_442 & 0x02) == 0x00)
				{
					edx_201.u0 = 0x080CE500;
					if ((al_442 & 0x04) != 0x00)
						edx_201 = *(eax_431 - (struct Eq_38634 *) 0x08 & 0xFFF00000);
					if (dwLoc20_530 != edx_201)
					{
						word32 edx_488;
						__malloc_assert(0x080A3780, 3226, 0x080A2925, out eax_190, out ecx_160, out edx_488);
						edx_24_8_626 = SLICE(edx_488, word24, 8);
						goto l0805DB60;
					}
				}
			}
			goto l0805DBBD;
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_268;
		if (!__cmpxchg(*dwLoc20_530, 0x01, eax_191, out eax_268))
			__lll_lock_wait_private(eax_268, dwLoc20_530, gs);
		word32 ecx_774;
		Eq_2 eax_299 = _int_realloc(dwLoc20_530, eax_83 & ~0x07, dwArg04 - 0x08, esi_165, 0x080CE000, dwArg00, out ecx_774, out edx_201);
		dwLoc28_524 = eax_299;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v20_309 = *dwLoc20_530 - 0x01;
		*dwLoc20_530 = v20_309;
		if (v20_309 != 0x00)
			__lll_unlock_wake_private(dwLoc20_530, eax_299, edx_201, gs);
		ptr32 esp_320 = fp - 44;
		if (eax_299 == 0x00)
		{
l0805DD6D:
			struct Eq_38766 * esp_374 = esp_320 - 0x0C;
			esp_374->tFFFFFFFC = esi_165;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edi_791;
			word32 esi_790;
			word32 ecx_787;
			word32 ebx_788;
			word32 ebp_789;
			Eq_2 eax_384 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_787, out edx_201, out ebx_788, out ebp_789, out esi_790, out edi_791);
			esp_374->t0010 = eax_384;
			if (eax_384 != 0x00)
			{
				esp_374->t0004 = esp_374->dw000C - 0x04;
				esp_374->t0000 = dwArg04;
				esp_374->tFFFFFFFC = esp_374->t0010;
				word32 edx_796;
				word32 ecx_795;
				memcpy(esp_374->tFFFFFFFC, esp_374->t0000, esp_374->t0004, out ecx_795, out edx_796);
				struct Eq_38864 * gs_802;
				word32 esi_800;
				word32 edi_801;
				word32 ecx_797;
				word32 ebx_798;
				word32 ebp_799;
				_int_free(esp_374->t0018, esp_374->t0014, 0x080CE000, gs, out ecx_797, out edx_201, out ebx_798, out ebp_799, out esi_800, out edi_801, out gs_802);
			}
			goto l0805DBBD;
		}
		byte al_327 = *((word32) eax_299 + 4);
		if ((al_327 & 0x02) == 0x00)
		{
			edx_201.u0 = 0x080CE500;
			if ((al_327 & 0x04) != 0x00)
				edx_201 = *(eax_299 - (struct Eq_38806 *) 0x08 & 0xFFF00000);
			if (dwLoc20_530 != edx_201)
			{
				word32 ecx_793;
				word32 edx_794;
				word32 eax_792;
				__malloc_assert(0x080A3780, 3237, 0x080A2925, out eax_792, out ecx_793, out edx_794);
				esp_320 = fp - 0x3C;
				goto l0805DD6D;
			}
		}
	}
	else
	{
		word32 ecx_772;
		Eq_2 eax_200 = mremap_chunk(dwArg04 - 0x08, ebp_161, gs, out ecx_772, out edx_201);
		if (eax_200 != 0x00)
			dwLoc28_524 = (word32) eax_200 + 8;
		else
		{
			dwLoc28_524 = dwArg04;
			if ((eax_83 & ~0x07) - 0x04 < ebp_161)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ebp_779;
				word32 esi_780;
				word32 edi_781;
				word32 ebx_778;
				word32 edx_777;
				word32 ecx_776;
				Eq_2 eax_217 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_776, out edx_777, out ebx_778, out ebp_779, out esi_780, out edi_781);
				dwLoc28_524 = eax_217;
				edx_201 = eax_217;
				if (eax_217 != 0x00)
				{
					word32 edx_783;
					word32 ecx_782;
					memcpy(eax_217, dwArg04, (eax_83 & ~0x07) - 0x08, out ecx_782, out edx_783);
					word32 ebx_785;
					word32 ecx_784;
					munmap_chunk(dwArg04 - 0x08, gs, out ecx_784, out edx_201, out ebx_785);
				}
			}
		}
	}
l0805DBBD:
	edxOut = edx_201;
	ebpOut.u0 = <invalid>;
	esiOut = esi;
	ediOut = edi;
	return dwLoc28_524;
}

// 0805DDC0: Register Eq_2 realloc_hook_ini(Register out Eq_979 edxOut)
// Called from:
//      __realloc
Eq_2 realloc_hook_ini(union Eq_979 & edxOut)
{
	__malloc_hook = null;
	__realloc_hook = null;
	ptmalloc_init(gs);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 edx_43;
	word32 ebp_44;
	word32 esi_45;
	word32 edi_46;
	Eq_2 eax_28 = __realloc(gs, stackArg0, dwArg04, dwArg08, out edx_43, out ebp_44, out esi_45, out edi_46);
	edxOut.u0 = <invalid>;
	return eax_28;
}

// 0805DE10: void aligned_alloc(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void aligned_alloc(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08)
{
	_mid_memalign(dwArg04, dwArg00, dwArg08, gs);
}

// 0805DE30: void __valloc(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg04)
void __valloc(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg04)
{
	if (__libc_malloc_initialized < 0x00)
		ptmalloc_init(gs);
	Eq_2 eax_34 = _dl_pagesize;
	_mid_memalign(eax_34, dwArg00, dwArg04, gs);
}

// 0805DE80: void __pvalloc(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack up32 dwArg04)
void __pvalloc(struct Eq_9 * gs, word32 dwArg00, up32 dwArg04)
{
	if (__libc_malloc_initialized < 0x00)
		ptmalloc_init(gs);
	Eq_2 eax_35 = _dl_pagesize;
	if (~0x10 - eax_35 * 0x02 < dwArg04)
		gs->tFFFFFFE0.u0 = 0x0C;
	else
	{
		Eq_2 edx_56 = eax_35 - 0x01 + dwArg04 & -eax_35;
		_mid_memalign(eax_35, dwArg00, edx_56, gs);
	}
}

// 0805DEF0: Register Eq_2 __libc_calloc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_3183) ebxOut, Register out (ptr32 Eq_3184) ebpOut, Register out (ptr32 Eq_3185) esiOut, Register out (ptr32 Eq_3186) ediOut)
// Called from:
//      _nl_find_msg
//      _nl_load_domain
//      __new_exitfn
//      __wcsmbs_load_conv
//      add_module.isra.0
//      register_printf_specifier
//      register_printf_modifier
//      register_printf_type
//      do_lookup_x
//      _dl_new_object
//      _dl_relocate_object
//      _dl_start_profile
//      allocate_dtv
//      _dlerror_run
//      _dl_check_map_versions
Eq_2 __libc_calloc(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut, struct Eq_3183 & ebxOut, struct Eq_3184 & ebpOut, struct Eq_3185 & esiOut, struct Eq_3186 & ediOut)
{
	Eq_2 esi_203;
	Eq_2 edx_198;
	struct Eq_38976 * esp_18 = fp - 44;
	Eq_2 esi_19 = dwArg04;
	Eq_2 ecx_20 = dwArg08;
	Eq_2 ebp_24 = dwArg04 *s dwArg08;
	if ((dwArg04 | dwArg08) > 0xFFFF && dwArg08 != 0x00)
	{
l0805E080:
		uint64 edx_eax_244 = (uint64) ebp_24;
		edx_198 = (uint32) (edx_eax_244 % ecx_20);
		if ((uint32) (edx_eax_244 /u ecx_20) != esi_19)
		{
			gs->tFFFFFFE0.u0 = 0x0C;
			esi_203.u0 = 0x00;
			goto l0805DFB3;
		}
	}
	<anonymous> * eax_32 = __malloc_hook;
	if (eax_32 != null)
	{
		struct Eq_39001 * esp_37 = esp_18 - 0x08;
		esp_37->tFFFFFFFC = esp_37->t0034;
		esp_37->tFFFFFFF8 = ebp_24;
		Eq_2 eax_49;
		eax_32();
		if (eax_49 != 0x00)
		{
			esp_37->t0000 = ebp_24;
			esp_37->tFFFFFFFC.u0 = 0x00;
			esp_37->tFFFFFFF8 = eax_49;
			esi_203 = memset(esp_37->tFFFFFFF8, esp_37->tFFFFFFFC, esp_37->t0000, out ecx_20, out edx_198);
			goto l0805DFB3;
		}
		goto l0805E0D0;
	}
	if (gs->tFFFFFFE4 == 0x00 && gs->bFFFFFFE8 == 0x00)
		tcache_init.part.6(gs);
	Eq_2 edi_106;
	Eq_2 ecx_122;
	if (gs->t000C == 0x00)
	{
		ecx_122 = g_t80CE538;
		esp_18[3] = (struct Eq_38976) (*((word32) ecx_122 + 4) & ~0x07);
		edi_106.u0 = 0x080CE500;
		goto l0805DF66;
	}
	edi_106 = gs->tFFFFFFEC;
	if (edi_106 != 0x00)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_134;
		if (!__cmpxchg(*edi_106.u0, 0x01, 0x00, out eax_134))
			__lll_lock_wait_private(eax_134, edi_106, gs);
	}
	else
	{
		word32 esi_614;
		word32 edx_612;
		word32 ecx_611;
		word32 edi_615;
		word32 ebx_613;
		Eq_2 eax_103 = get_free_list(gs, out ecx_611, out edx_612, out ebx_613, out esi_614, out edi_615);
		edi_106 = eax_103;
		if (eax_103 == 0x00)
		{
			word32 esi_617;
			word32 ebx_616;
			word32 edi_618;
			Eq_2 eax_115 = arena_get2.part.5(ebp_24, 0x00, gs, out ebx_616, out esi_617, out edi_618);
			edi_106 = eax_115;
			if (eax_115 == 0x00)
			{
				esp_18[3] = (struct Eq_38976) 0x00;
				ecx_122.u0 = 0x00;
l0805DF66:
				esp_18[2] = (struct Eq_38976) ecx_122;
				word32 ecx_619;
				word32 esi_622;
				word32 ebp_621;
				word32 edi_623;
				word32 ebx_620;
				Eq_2 eax_197 = _int_malloc(edi_106, ebp_24, edi_106, gs, out ecx_619, out edx_198, out ebx_620, out ebp_621, out esi_622, out edi_623);
				ecx_20 = esp_18[2];
				esi_203 = eax_197;
				if (eax_197 != 0x00)
				{
					Eq_39049 al_206 = *((word32) eax_197 + 4);
					if ((al_206 & 0x02) != 0x00)
						goto l0805DF88;
					edx_198.u0 = 0x080CE500;
					if ((al_206 & 0x04) != 0x00)
						edx_198 = *(eax_197 - (struct Eq_39381 *) 0x08 & 0xFFF00000);
					if (edx_198 != edi_106)
					{
						struct Eq_39388 * esp_226 = esp_18 - 0x0C;
						esp_226->ptrFFFFFFFC = 0x080A38C8;
						word32 eax_632;
						word32 edx_633;
						__malloc_assert(0x080A37E0, 3442, 0x080A2925, out eax_632, out ecx_20, out edx_633);
						esp_18 = esp_226 - 4;
						esi_19 = eax_197;
						goto l0805E080;
					}
				}
l0805DF88:
				if (gs->t000C != 0x00)
				{
					if (eax_197 == 0x00 && edi_106 != 0x00)
					{
						esp_18[2] = (struct Eq_38976) ecx_20;
						Eq_2 eax_288 = arena_get_retry(edi_106, ecx, ebp_24, gs);
						word32 ecx_627;
						word32 ebx_628;
						word32 esi_630;
						word32 ebp_629;
						word32 edi_631;
						Eq_2 eax_294 = _int_malloc(eax, ebp_24, eax_288, gs, out ecx_627, out edx_198, out ebx_628, out ebp_629, out esi_630, out edi_631);
						edi_106 = eax_288;
						ecx_20 = esp_18[2];
						esi_203 = eax_294;
					}
					if (edi_106 != 0x00)
					{
						if (gs->t000C != 0x00)
							__lock();
						Eq_2 v18_309 = *edi_106.u0 - 0x01;
						*edi_106.u0 = v18_309;
						if (v18_309 != 0x00)
							__lll_unlock_wake_private(edi_106, ecx_20, edx_198, gs);
					}
				}
				if (esi_203 != 0x00)
				{
					Eq_2 eax_330 = *((word64) esi_203.u0 - 4);
					edx_198 = perturb_byte;
					if (((byte) eax_330 & 0x02) != 0x00)
					{
						if (edx_198 != 0x00)
						{
							struct Eq_39086 * esp_434 = esp_18 - 0x04;
							esp_434->tFFFFFFFC = ebp_24;
							esp_434->tFFFFFFF8.u0 = 0x00;
							esp_434->tFFFFFFF4 = esi_203;
							esi_203 = memset(esp_434->tFFFFFFF4, esp_434->tFFFFFFF8, esp_434->tFFFFFFFC, out ecx_20, out edx_198);
						}
						goto l0805DFB3;
					}
					uint32 eax_340 = eax_330 & ~0x07;
					if (edx_198 == 0x00)
					{
						edx_198 = esi_203 - 0x08;
						if (ecx_20 == edx_198)
						{
							uint32 edi_353 = esp_18[3];
							if (edi_353 < (eax_330 & ~0x07))
								eax_340 = edi_353;
						}
					}
					Eq_2 eax_358 = eax_340 - 0x04;
					if (eax_358 > 11)
					{
						if (eax_358 <= 0x27)
						{
							*esi_203.u0 = 0x00;
							*((word64) esi_203.u0 + 4) = 0x00;
							*((word64) esi_203.u0 + 8) = 0x00;
							if (eax_358 > 0x13)
							{
								*((word64) esi_203.u0 + 0x0C) = 0x00;
								*((word64) esi_203.u0 + 16) = 0x00;
								if (eax_358 > 0x1B)
								{
									*((word64) esi_203.u0 + 20) = 0x00;
									((word64) esi_203.u0 + 24)->u0 = 0x00;
									if (eax_358 > 0x23)
									{
										((word64) esi_203.u0 + 28)->u0 = 0x00;
										((word64) esi_203.u0 + 32)->u0 = 0x00;
									}
								}
							}
						}
						else
						{
							struct Eq_39267 * esp_398 = esp_18 - 0x04;
							esp_398->tFFFFFFFC = eax_358;
							esp_398->tFFFFFFF8.u0 = 0x00;
							esp_398->tFFFFFFF4 = esi_203;
							memset(esp_398->tFFFFFFF4, esp_398->tFFFFFFF8, esp_398->tFFFFFFFC, out ecx_20, out edx_198);
						}
l0805DFB3:
						ecxOut = ecx_20;
						edxOut = edx_198;
						ebxOut = ebx;
						ebpOut = ebp;
						esiOut = esi;
						ediOut = edi;
						return esi_203;
					}
					esp_18->dwFFFFFFF0 = 0x080A38C8;
					word32 eax_624;
					__malloc_assert(134884143, 0x0DA0, 0x080A2925, out eax_624, out ecx_20, out edx_198);
				}
l0805E0D0:
				esi_203.u0 = 0x00;
				goto l0805DFB3;
			}
		}
	}
	ecx_122 = *((word64) edi_106.u0 + 56);
	ui32 edx_150 = *((word32) ecx_122 + 4);
	esp_18[3] = (struct Eq_38976) (edx_150 & ~0x07);
	if (edi_106 != 0x080CE500)
	{
		uint32 eax_160 = (ecx_122 & 0xFFF00000) + (ecx_122 & 0xFFF00000)->dw000C - ecx_122;
		if ((edx_150 & ~0x07) >= eax_160)
			eax_160 = edx_150 & ~0x07;
		esp_18[3] = (struct Eq_38976) eax_160;
	}
	goto l0805DF66;
}

// 0805E260: void malloc_trim(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void malloc_trim(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_103 = fp - 0x4C;
	if (__libc_malloc_initialized < 0x00)
	{
		ptmalloc_init(gs);
		esp_103.u0 = <invalid>;
	}
	*((word64) esp_103.u0 + 44) = 0x00;
	*((word64) esp_103.u0 + 40) = 0x080CE500;
	*((word64) esp_103.u0 + 16) = 0x080CE500;
	*((word64) esp_103.u0 + 24) = 0x080CE9B0;
	do
	{
		Eq_2 edx_45 = *((word32) esp_103 + 16);
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_53;
		if (!__cmpxchg(*edx_45, 0x01, 0x00, out eax_53))
			__lll_lock_wait_private(eax_53, edx_45, gs);
		word32 ebp_67;
		word32 ebx_469;
		word32 edi_470;
		word32 edx_468;
		Eq_2 ecx_193;
		malloc_consolidate(edx_45, gs, out ecx_193, out edx_468, out ebx_469, out ebp_67, out edi_470);
		esp_103.u0 = <invalid>;
		Eq_59608 (* eax_80)[] = **((word64) esp_103.u0 + 24);
		*((word64) esp_103.u0 + 0x0C) = eax_80;
		if (eax_80 <= (Eq_59608 (*)[]) 1007)
			*((word64) esp_103.u0 + 8) = (eax_80 >> 0x04) + 0x01;
		else
		{
			uint32 eax_142 = *((word64) esp_103.u0 + 0x0C);
			if (eax_142 >> 0x06 <= 0x2D)
				*((word64) esp_103.u0 + 8) = (eax_142 >> 0x06) + 0x31;
			else
			{
				uint32 eax_146 = *((word64) esp_103.u0 + 0x0C);
				if (eax_146 >> 0x09 > 0x14)
				{
					uint32 eax_153 = *((word32) esp_103 + 0x0C);
					if (eax_153 >> 0x0C <= 0x0A)
						*((word32) esp_103 + 8) = (eax_153 >> 0x0C) + 110;
					else
					{
						uint32 eax_157 = *((word32) esp_103 + 0x0C);
						if (eax_157 >> 0x0F <= 0x04)
							*((word32) esp_103 + 8) = (eax_157 >> 0x0F) + 0x77;
						else
						{
							uint32 eax_161 = *((word32) esp_103 + 0x0C);
							uint32 eax_163 = eax_161 >> 0x12;
							if (eax_161 >> 0x12 > 0x02)
								eax_163 = 0x02;
							*((word32) esp_103 + 8) = eax_163 + 0x7C;
						}
					}
				}
				else
					*((word32) esp_103 + 8) = (eax_146 >> 0x09) + 0x5B;
			}
		}
		word32 eax_90 = *((word64) esp_103.u0 + 0x0C);
		word32 edi_91 = *((word64) esp_103.u0 + 16);
		*((word64) esp_103.u0 + 36) = 0x00;
		*((word64) esp_103.u0 + 28) = eax_90 - 0x01;
		*((word64) esp_103.u0 + 20) = -eax_90;
		int32 ebx_100;
		struct Eq_39535 * edi_108 = edi_91 + 0x38;
		for (ebx_100 = 0x01; ebx_100 != 0x80; ++ebx_100)
		{
			if (ebx_100 == 0x01 || *((word64) esp_103.u0 + 8) <= ebx_100)
			{
				struct Eq_39535 * esi_110 = edi_108->dw000C;
				if (edi_108 != esi_110)
				{
					struct Eq_39555 * eax_114 = *((word64) esp_103.u0 + 0x0C);
					*((word64) esp_103.u0 + 32) = ebx_100;
					do
					{
						ui32 eax_122 = esi_110->dw0004;
						if ((eax_122 & ~0x07) >u eax_114 + 0x17)
						{
							word32 edx_130 = esi_110 + (eax_114 + 0x17) & Mem121[esp_103 + 0x14:word32];
							if (edx_130 <u esi_110 + 0x18)
							{
								*((word64) esp_103.u0 - 16) = ebp_67 + ~0x0002A73F;
								word32 ecx_472;
								word32 edx_473;
								word32 eax_471;
								__malloc_assert(ebp_67 + 4294793272, 0x12BC, ebp_67 + ~0x0002B6DA, out eax_471, out ecx_472, out edx_473);
							}
							if (edx_130 >=u esi_110 + (eax_122 & ~0x07))
							{
								*((word64) esp_103.u0 - 16) = ebp_67 + ~0x0002A73F;
								word32 edx_476;
								word32 eax_474;
								word32 ecx_475;
								__malloc_assert(ebp_67 + ~0x0002A78F, 4797, ebp_67 + ~0x0002B6DA, out eax_474, out ecx_475, out edx_476);
							}
							ecx_193 = edx_130 - esi_110;
							uint32 eax_194 = (eax_122 & ~0x07) - ecx_193;
							if (*((word64) esp_103.u0 + 28) < eax_194)
							{
								struct Eq_39626 * esp_197 = esp_103 - 0x04;
								esp_197->dwFFFFFFFC = 0x04;
								esp_197->dwFFFFFFF8 = eax_194 & esp_197->dw0018;
								esp_197->tFFFFFFF4 = edx_130;
								word32 edx_477;
								ecx_193 = __madvise(gs, esp_197->tFFFFFFF4, esp_197->dwFFFFFFF8, esp_197->dwFFFFFFFC, out edx_477);
								esp_197->dw002C = 0x01;
								esp_103 = &esp_197->dwFFFFFFFC + 3;
							}
						}
						esi_110 = esi_110->dw000C;
					} while (edi_108 != esi_110);
					ebx_100 = (int32) *((word32) esp_103 + 32);
				}
			}
			esp_103 = fp - 76;
			++edi_108;
		}
		if (dwLoc3C == dwLoc24)
		{
			word32 edx_478;
			systrim.isra.1.constprop.11(dwArg04, out ecx_193, out edx_478);
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 v19_269 = *dwLoc3C - 0x01;
		*dwLoc3C = v19_269;
		if (v19_269 != 0x00)
			__lll_unlock_wake_private(dwLoc3C, ecx_193, dwLoc3C, gs);
		Eq_2 eax_287 = *((word32) dwLoc3C + 0x0448);
		dwLoc3C = eax_287;
	} while (eax_287 != dwLoc24);
}

// 0805E4F0: void __malloc_usable_size(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_39762) dwArg04, Stack word32 dwArg08)
void __malloc_usable_size(struct Eq_9 * gs, word32 dwArg00, struct Eq_39762 * dwArg04, word32 dwArg08)
{
	if (dwArg04 == null)
		return;
	ui32 eax_37 = dwArg04->dwFFFFFFFC;
	if (using_malloc_checking != 0x01)
		return;
	ui32 esi_48 = dwArg04 - (struct Eq_39775 *) 0x08 >> 0x03 ^ dwArg04 - (struct Eq_39775 *) 0x08 >> 11;
	if ((byte) esi_48 == 0x01)
		esi_48 = 0x02;
	Eq_39800 eax_63 = (eax_37 & ~0x07) - 0x01 + (uint32) ((int8) ((eax_37 & 0x02) == 0x00)) * 0x04;
	word32 edx_68 = CONVERT(Mem36[dwArg04 - 0x08 + eax_63:byte], byte, word32);
	byte dl_69 = (byte) edx_68;
	if (dl_69 == (byte) esi_48)
	{
l0805E5BB:
	}
	else
	{
		if (dl_69 != 0x00 && eax_63 >= (word32) edx_68 + 8)
		{
			do
			{
				eax_63 -= edx_68;
				edx_68 = CONVERT(Mem36[dwArg04 - 0x08 + eax_63:byte], byte, word32);
				byte dl_88 = (byte) edx_68;
				if (dl_88 == (byte) esi_48)
					goto l0805E5BB;
			} while (dl_88 != 0x00 && (word32) edx_68 + 8 <= eax_63);
		}
		word32 ecx_224;
		word32 edx_225;
		malloc_printerr(out ecx_224, out edx_225);
		mallinfo(gs, dwArg00, dwArg04, dwArg08);
	}
}

// 0805E5D0: void mallinfo(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_39762) dwArg04, Stack word32 dwArg08)
// Called from:
//      __malloc_usable_size
void mallinfo(struct Eq_9 * gs, word32 dwArg00, struct Eq_39762 * dwArg04, word32 dwArg08)
{
	Eq_2 ebx_17 = 0x080CE000;
	ui32 eax_20 = gs->dw0014;
	if (__libc_malloc_initialized < 0x00)
		ebx_17 = ptmalloc_init(gs);
	word32 ecx_179;
	word32 * edi_176 = fp - 0x48;
	for (ecx_179 = 0x0A; ecx_179 != 0x00; --ecx_179)
	{
		*edi_176 = 0x00;
		++edi_176;
	}
	Eq_2 edi_46 = (word32) ebx_17 + 0x0500;
	Eq_2 ebx_101 = edi_46;
	do
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_61;
		if (!__cmpxchg(*ebx_101, 0x01, 0x00, out eax_61))
			__lll_lock_wait_private(eax_61, ebx_101, gs);
		Eq_2 edx_79;
		Eq_2 ecx_78 = int_mallinfo(ebx_101, fp - 0x48, out edx_79);
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v16_90 = *ebx_101 - 0x01;
		*ebx_101 = v16_90;
		if (v16_90 != 0x00)
			__lll_unlock_wake_private(ebx_101, ecx_78, edx_79, gs);
		ebx_101 = *((word32) ebx_101 + 0x0448);
	} while (ebx_101 != edi_46);
	dwArg04->dw0000 = dwLoc48;
	dwArg04->dw0004 = dwLoc44;
	dwArg04->dw0008 = dwLoc40;
	dwArg04->dw000C = dwLoc3C;
	dwArg04->dw0010 = dwLoc38;
	dwArg04->dw0014 = dwLoc34;
	dwArg04->dw0018 = dwLoc30;
	dwArg04->dw001C = dwLoc2C;
	dwArg04->dw0020 = dwLoc28;
	dwArg04->dw0024 = dwLoc24;
	if ((eax_20 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_357;
	word32 edx_358;
	__stack_chk_fail(out ecx_357, out edx_358);
	__malloc_stats(gs, dwArg00, dwArg04, dwArg08);
}

// 0805E6E0: void __malloc_stats(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_39762) dwArg04, Stack word32 dwArg08)
// Called from:
//      mallinfo
void __malloc_stats(struct Eq_9 * gs, word32 dwArg00, struct Eq_39762 * dwArg04, word32 dwArg08)
{
	ui32 esi_21 = gs->dw0014;
	if (__libc_malloc_initialized < 0x00)
		ptmalloc_init(gs);
	Eq_2 eax_44 = _IO_stderr;
	Eq_2 edx_45 = *((word32) eax_44 + 60);
	*((word32) eax_44 + 60) = edx_45 | 0x02;
	Eq_2 ebx_200 = 0x080CE500;
	do
	{
		word32 * edi_349 = fp - 0x48;
		word32 ecx_352;
		for (ecx_352 = 0x0A; ecx_352 != 0x00; --ecx_352)
		{
			*edi_349 = 0x00;
			++edi_349;
		}
		if (gs->t000C != 0x00)
			__lock();
		word32 eax_83;
		if (!__cmpxchg(*ebx_200, 0x01, 0x00, out eax_83))
			__lll_lock_wait_private(eax_83, ebx_200, gs);
		word32 edx_554;
		int_mallinfo(ebx_200, fp - 0x48, out edx_554);
		Eq_2 ebx_126;
		word32 edi_555;
		__fprintf(ebx_200, gs, _IO_stderr, 134884156, out ebx_126, out edi_555);
		Eq_2 ebx_147;
		word32 edi_556;
		__fprintf(ebx_126, gs, _IO_stderr, 134884167, out ebx_147, out edi_556);
		Eq_2 ebx_168;
		word32 edi_557;
		Eq_2 ecx_169 = __fprintf(ebx_147, gs, _IO_stderr, 0x080A2B60, out ebx_168, out edi_557);
		if (gs->t000C != 0x00)
			__lock();
		word32 v26_186 = *ebx_168 - 0x01;
		*ebx_168 = v26_186;
		if (v26_186 != 0x00)
			__lll_unlock_wake_private(ebx_168, ecx_169, dwLoc48, gs);
		ebx_200 = *((word32) ebx_168 + 0x0448);
	} while (ebx_200 != 0x080CE500);
	fwrite(gs, 134884217, 0x01, 0x14, _IO_stderr);
	Eq_2 ebx_242;
	word32 edi_558;
	__fprintf(0x080CE000, gs, _IO_stderr, 134884167, out ebx_242, out edi_558);
	Eq_2 ebx_263;
	word32 edi_265;
	__fprintf(ebx_242, gs, _IO_stderr, 0x080A2B60, out ebx_263, out edi_265);
	Eq_2 ebx_284;
	word32 edi_286;
	__fprintf(ebx_263, gs, _IO_stderr, edi_265 + 4294790030, out ebx_284, out edi_286);
	word32 edi_560;
	word32 ebx_559;
	__fprintf(ebx_284, gs, _IO_stderr, edi_286 + 4294790055, out ebx_559, out edi_560);
	*((word32) _IO_stderr + 60) = edx_45;
	if ((esi_21 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_561;
	word32 edx_562;
	__stack_chk_fail(out ecx_561, out edx_562);
	__mallopt(gs, dwArg00, dwArg04, dwArg08);
}

// 0805E8C0: void __mallopt(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_39762) dwArg04, Stack word32 dwArg08)
// Called from:
//      __malloc_stats
void __mallopt(struct Eq_9 * gs, word32 dwArg00, struct Eq_39762 * dwArg04, word32 dwArg08)
{
	Eq_2 ebx_15 = 0x080CE000;
	if (__libc_malloc_initialized < 0x00)
		ebx_15 = ptmalloc_init(gs);
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_42;
	if (!__cmpxchg(*((word32) ebx_15 + 0x0500), 0x01, 0x00, out eax_42))
		__lll_lock_wait_private(eax_42, (word32) ebx_15 + 0x0500, gs);
	struct Eq_40204 * ebx_57;
	Eq_2 ecx_58;
	up32 edi_61;
	word32 ebp_157;
	word32 edx_156;
	malloc_consolidate((word32) ebx_15 + 0x0500, gs, out ecx_58, out edx_156, out ebx_57, out ebp_157, out edi_61);
	if (edi_61 > 0x01)
	{
		if (gs->t000C != 0x00)
			__lock();
		word32 v16_76 = ebx_57->dw0500 - 0x01;
		ebx_57->dw0500 = v16_76;
		if (v16_76 != 0x00)
			__lll_unlock_wake_private(&ebx_57->dw0500, ecx_58, 0x01, gs);
	}
	else
	{
		<anonymous> * ecx_97 = ebx_57 + (ebx_57->aFFFD59E8)[edi_61 + 0x08] / 0x0504;
		ecx_97();
	}
}

// 0805EA70: void posix_memalign(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void posix_memalign(struct Eq_9 * gs, word32 dwArg00, word32 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	if (((dwArg08 >> 0x02) - 0x01 & dwArg08 >> 0x02 | dwArg08 & 0x03) != 0x00 || dwArg08 == 0x00)
		return;
	word32 eax_30 = _mid_memalign(dwArg08, dwArg00, dwArg0C, gs);
	if (eax_30 != 0x00)
		*dwArg04 = eax_30;
}

// 0805EAD0: void malloc_info(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack Eq_2 dwArg08)
void malloc_info(struct Eq_9 * gs, word32 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebx_14 = dwArg08;
	if (dwArg04 != 0x00)
		return;
	if (__libc_malloc_initialized < 0x00)
		ebx_14 = ptmalloc_init(gs);
	fputs(gs, 134884289, ebx_14);
	__malloc_info.part.10(gs);
}

// 0805EB40: void __default_morecore(Register (ptr32 Eq_9) gs, Stack Eq_1961 dwArg04)
void __default_morecore(struct Eq_9 * gs, Eq_1961 dwArg04)
{
	word32 edx_33;
	__sbrk(gs, dwArg04, out edx_33) != ~0x00;
}

// 0805EB60: Register Eq_2 strchr(Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Register out (ptr32 Eq_4975) ecxOut, Register out (ptr32 Eq_4976) edxOut)
// Called from:
//      __dcigettext
//      read_alias_file
//      strstr
//      __gconv_open
//      __gconv_get_path
//      __gconv_read_conf
//      setlocale
//      _nl_load_locale_from_archive
//      __setenv
//      __unsetenv
//      _dl_dst_count
//      _dl_map_object
//      dl_open_worker
Eq_2 strchr(Eq_2 dwArg04, Eq_2 bArg08, struct Eq_4975 & ecxOut, struct Eq_4976 & edxOut)
{
	struct Eq_4975 * ecx_113;
	byte dl_9 = (byte) dwArg08;
	Eq_40312 edx_12 = SEQ(SLICE(dwArg08, word16, 16), dl_9, dl_9);
	struct Eq_4976 * edx_231 = SEQ(edx_12, edx_12);
	Eq_2 eax_137 = dwArg04;
	word24 ecx_24_8_252 = SLICE(edx_12, word24, 8);
	word24 edx_24_8_267 = SLICE(edx_231, word24, 8);
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		byte cl_21 = *dwArg04;
		ecx_113 = SEQ(ecx_24_8_252, cl_21);
		if (dl_9 == cl_21)
			goto l0805ECC5;
		ecx_113 = SEQ(ecx_24_8_252, cl_21);
		if (cl_21 == 0x00)
			goto l0805EC9A;
		eax_137 = (word32) dwArg04 + 1;
		if (((byte) ((word32) dwArg04 + 1) & 0x03) != 0x00)
		{
			byte cl_33 = *((word32) dwArg04 + 1);
			ecx_113 = SEQ(ecx_24_8_252, cl_33);
			if (dl_9 == cl_33)
				goto l0805ECC5;
			ecx_113 = SEQ(ecx_24_8_252, cl_33);
			if (cl_33 == 0x00)
				goto l0805EC9A;
			eax_137 = (word32) dwArg04 + 2;
			if (((byte) ((word32) dwArg04 + 2) & 0x03) != 0x00)
			{
				byte cl_44 = *((word32) dwArg04 + 2);
				ecx_113 = SEQ(ecx_24_8_252, cl_44);
				if (dl_9 == cl_44)
					goto l0805ECC5;
				ecx_113 = SEQ(ecx_24_8_252, cl_44);
				if (cl_44 == 0x00)
					goto l0805EC9A;
				eax_137 = (word32) dwArg04 + 3;
			}
		}
	}
	while (true)
	{
		struct Eq_4975 * ecx_306 = *eax_137 ^ edx_231;
		if (ecx_306 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_306 - 0x01010101 ^ ecx_306 | ~0x01010100) != 0x01)
			break;
		ecx_113 = ecx_306 ^ edx_231;
		if (ecx_113 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		struct Eq_4975 * ecx_308 = *((word32) eax_137 + 4) ^ edx_231;
		if (ecx_308 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_308 - 0x01010101 ^ ecx_308 | ~0x01010100) != 0x01)
		{
l0805ECA4:
			eax_137 = (word32) eax_137 + 4;
			ecx_306 = ecx_308;
			break;
		}
		ecx_113 = ecx_308 ^ edx_231;
		if (ecx_113 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		struct Eq_4975 * ecx_102 = *((word32) eax_137 + 8) ^ edx_231;
		if (ecx_102 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_102 - 0x01010101 ^ ecx_102 | ~0x01010100) != 0x01)
		{
l0805ECA1:
			eax_137 = (word32) eax_137 + 4;
			ecx_308 = ecx_102;
			goto l0805ECA4;
		}
		ecx_113 = ecx_102 ^ edx_231;
		if (ecx_113 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		ecx_102 = *((word32) eax_137 + 0x0C) ^ edx_231;
		if (ecx_102 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_102 - 0x01010101 ^ ecx_102 | ~0x01010100) != 0x01)
		{
			eax_137 = (word32) eax_137 + 4;
			goto l0805ECA1;
		}
		ecx_113 = ecx_102 ^ edx_231;
		if (ecx_113 >= (struct Eq_4975 *) ~0x01010100 || ((char *) ecx_113 - 0x01010101 ^ ecx_113 | ~0x01010100) != 0x01)
			goto l0805EC9A;
		eax_137 = (word32) eax_137 + 16;
	}
	byte ch_165 = SLICE(ecx_306, byte, 8);
	byte cl_145 = (byte) ecx_306;
	ecx_113 = ecx_306;
	edx_231 = SEQ(edx_24_8_267, dl_9);
	if (cl_145 == 0x00)
	{
l0805ECC5:
		ecxOut = ecx_113;
		edxOut = edx_231;
		return eax_137;
	}
	ecx_113 = ecx_306;
	if (cl_145 != dl_9)
	{
		eax_137 = (word32) eax_137 + 1;
		ecx_113 = ecx_306;
		if (ch_165 == 0x00)
			goto l0805ECC5;
		ecx_113 = ecx_306;
		if (ch_165 != dl_9)
		{
			eax_137 = (word32) eax_137 + 1;
			ecx_113 = ecx_306 >> 0x10;
			byte cl_189 = (byte) (ecx_306 >> 0x10);
			if (cl_189 == 0x00)
				goto l0805ECC5;
			if (cl_189 != dl_9)
			{
				eax_137 = (word32) eax_137 + 2;
				goto l0805ECC5;
			}
		}
	}
l0805EC9A:
	ecxOut = ecx_113;
	edxOut = edx_231;
	return 0x00;
}

// 0805ECD0: Register word32 strcmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      transcmp
//      _nl_find_msg
//      __dcigettext
//      _nl_make_l10nflist
//      _nl_explode_name
//      __gconv_alias_compare
//      derivation_compare
//      find_derivation
//      __gconv_compare_alias
//      __gconv_find_transform
//      insert_module
//      detect_conflict
//      __gconv_get_builtin_trans
//      find_module_idx
//      __gconv_compare_alias_cache
//      known_compare
//      new_composite_name
//      setlocale
//      _nl_find_locale
//      _nl_load_locale_from_archive
//      wctrans
//      add_name_to_object.isra.4
//      _dl_map_object
//      check_match
//      do_lookup_x
//      _dl_name_match_p
//      _dl_load_cache_lookup
//      _dl_check_map_versions
word32 strcmp(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 ecx_17 = dwArg04;
	Eq_2 edx_10 = dwArg08;
	do
	{
		cu8 al_9 = *ecx_17;
		if (al_9 != *edx_10)
		{
			word32 eax_13 = 0x01;
			if (al_9 < *edx_10)
				eax_13 = ~0x00;
			ecxOut.u0 = ~0x00;
			edxOut = edx_10;
			return eax_13;
		}
		ecx_17 = (word32) ecx_17 + 1;
		edx_10 = (word32) edx_10 + 1;
	} while (al_9 != 0x00);
	ecxOut = ecx_17;
	edxOut = edx_10;
	return 0x00;
}

// 0805ED00: void strcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __assert_fail_base
//      __dcigettext
void strcpy(Eq_2 dwArg04, Eq_2 dwArg08)
{
	word32 ecx_60;
	word32 edx_61;
	word32 ecx_62;
	word32 edx_63;
	memcpy(dwArg04, dwArg08, (word32) strlen(dwArg08, out ecx_60, out edx_61) + 1, out ecx_62, out edx_63);
}

// 0805ED40: Register word32 strcspn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _nl_find_msg
//      __strtok_r
//      __strsep_g
word32 strcspn(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_138 = dwArg08;
	do
	{
		Eq_40544 cl_140 = *eax_138;
		if (cl_140 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_140].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_140;
		Eq_40551 cl_148 = *((word32) eax_138 + 1);
		if (cl_148 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_148].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_148;
		Eq_40561 cl_154 = *((word32) eax_138 + 2);
		if (cl_154 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_154].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_154;
		Eq_40571 cl_160 = *((word32) eax_138 + 3);
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_160].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_160;
		eax_138 = (word32) eax_138 + 4;
	} while (cl_160 != 0x00);
	struct Eq_40541 * eax_169 = dwArg04 - 0x04;
	do
	{
		++eax_169;
		Eq_40622 cl_173 = eax_169->b0000;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == cl_173)
			return eax_169 - dwArg04;
		Eq_40589 cl_179 = eax_169->b0001;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_179].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == cl_179)
			goto l0805EDE8;
		Eq_40600 cl_183 = eax_169->b0002;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_183].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == cl_183)
			goto l0805EDE7;
		Eq_40611 cl_187 = eax_169->b0003;
	} while ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_187].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] != cl_187);
	eax_169 = (struct Eq_40541 *) &eax_169->b0001;
l0805EDE7:
	eax_169 = (struct Eq_40541 *) &eax_169->b0001;
l0805EDE8:
	eax_169 = (struct Eq_40541 *) &eax_169->b0001;
	return eax_169 - dwArg04;
}

// 0805EE00: Register Eq_2 strdup(Stack Eq_2 dwArg04)
// Called from:
//      _nl_find_msg
//      find_derivation
//      setlocale
//      _nl_load_locale_from_archive
//      expand_dynamic_string_token
//      cache_rpath.part.6
//      _dl_map_object
//      _dl_load_cache_lookup
Eq_2 strdup(Eq_2 dwArg04)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_94;
	word32 edx_95;
	Eq_2 eax_20 = strlen(dwArg04, out ecx_94, out edx_95);
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_98;
	word32 edx_99;
	word32 ebx_100;
	word32 ebp_101;
	word32 esi_102;
	word32 edi_103;
	Eq_2 eax_29 = __libc_malloc(gs, stackArg0, (word32) eax_20 + 1, out ecx_98, out edx_99, out ebx_100, out ebp_101, out esi_102, out edi_103);
	if (eax_29 != 0x00)
	{
		word32 ecx_104;
		word32 edx_105;
		eax_29 = memcpy(eax_29, dwArg04, (word32) eax_20 + 1, out ecx_104, out edx_105);
	}
	return eax_29;
}

// 0805EE50: Register int32 strlen(Stack Eq_2 dwArg04, Register out Eq_2649 ecxOut, Register out Eq_2650 edxOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      read_alias_file
//      _nl_make_l10nflist
//      getenv
//      ____strtoul_l_internal
//      __correctly_grouped_prefixmb
//      locked_vfxprintf
//      _IO_puts
//      __libc_message
//      strcpy
//      strdup
//      __mbsrtowcs_l
//      __sysconf_check_spec
//      getcwd
//      _dl_non_dynamic_init
//      __gconv_open
//      find_derivation
//      __gconv_get_path
//      find_module
//      __gconv_find_shlib
//      new_composite_name
//      _nl_find_locale
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __unsetenv
//      ____strtol_l_internal
//      group_number
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      __printf_fp_l
//      __printf_fphex
//      fputs
//      strerror_r
//      argz_create_sep
//      __argz_add_sep
//      wctrans
//      is_dst
//      add_name_to_object.isra.4
//      open_verify.constprop.7
//      expand_dynamic_string_token
//      fillin_rpath
//      _dl_init_paths
//      _dl_map_object
//      _dl_new_object
//      _dl_important_hwcaps
//      _dl_debug_vdprintf
//      _dl_start_profile
//      _dl_get_origin
//      _dl_exception_create
//      _dl_exception_create_format
//      _dl_load_cache_lookup
//      _dl_map_object_deps
//      uw_frame_state_for
//      get_cie_encoding
int32 strlen(Eq_2 dwArg04, union Eq_2649 & ecxOut, union Eq_2650 & edxOut)
{
	Eq_2 eax_101 = dwArg04;
	Eq_2649 ecx_123 = dwArg04 & 0x03;
	byte ch_11 = SLICE(dwArg04 & 0x03, byte, 8);
	if ((dwArg04 & 0x03) != 0x00)
	{
		if (*dwArg04 == ch_11)
			goto l0805EEFE;
		ecx_123 = dwArg04 & 0x03 ^ 0x03;
		eax_101 = (word32) dwArg04 + 1;
		byte ch_19 = SLICE(ecx_123, byte, 8);
		if (ecx_123 != 0x00)
		{
			if (*((word32) dwArg04 + 1) == ch_19)
				goto l0805EEFE;
			eax_101 = (word32) dwArg04 + 2;
			--ecx_123;
			byte ch_26 = SLICE(ecx_123 - 0x01, byte, 8);
			if (ecx_123 != 0x01)
			{
				if (*((word32) dwArg04 + 2) == ch_26)
					goto l0805EEFE;
				eax_101 = dwArg04 - 0x0D;
l0805EE84:
				eax_101 = (word32) eax_101 + 16;
			}
		}
	}
	Mem35 = Mem0;
	Eq_2649 ecx_171 = *eax_101;
	edx = (word32) ecx_171.u0 - 0x01010101;
	if (ecx_171 >= ~0x01010100)
	{
l0805EEEB:
		byte ch_103 = SLICE(ecx_171, byte, 8);
		ecx_123 = ecx_171;
		if ((byte) ecx_171 != 0x00)
		{
			eax_101 = (word32) eax_101 + 1;
			ecx_123 = ecx_171;
			if (ch_103 != 0x00)
			{
				eax_101 = (word32) eax_101 + 1;
				if ((ecx_171 & 0x00FF0000) != 0x00)
					eax_101 = (word32) eax_101 + 2;
			}
		}
l0805EEFE:
		ecxOut = ecx_123;
		edxOut = edx;
		return eax_101 - dwArg04;
	}
	edx = ((word32) ecx_171.u0 - 0x01010101 ^ ecx_171 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEEB;
	Eq_2649 ecx_173 = *((word32) eax_101 + 4);
	edx = (word32) ecx_173 - 0x01010101;
	if (ecx_173 >= ~0x01010100)
	{
l0805EEE8:
		eax_101 = (word32) eax_101 + 4;
		ecx_171 = ecx_173;
		goto l0805EEEB;
	}
	edx = ((word32) ecx_173 - 0x01010101 ^ ecx_173 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEE8;
	Eq_2649 ecx_175 = *((word32) eax_101 + 8);
	edx = (word32) ecx_175 - 0x01010101;
	if (ecx_175 >= ~0x01010100)
	{
l0805EEE5:
		eax_101 = (word32) eax_101 + 4;
		ecx_173 = ecx_175;
		goto l0805EEE8;
	}
	edx = ((word32) ecx_175 - 0x01010101 ^ ecx_175 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEE5;
	ecx_175 = *((word32) eax_101 + 0x0C);
	edx = (word32) ecx_175 - 0x01010101;
	if (ecx_175 >= ~0x01010100)
	{
l0805EEE2:
		eax_101 = (word32) eax_101 + 4;
		goto l0805EEE5;
	}
	edx = ((word32) ecx_175 - 0x01010101 ^ ecx_175 | ~0x01010100) + 0x01;
	if (edx != 0x00)
		goto l0805EEE2;
	goto l0805EE84;
}

// 0805EF10: Register word32 strncmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut)
// Called from:
//      getenv
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __unsetenv
//      is_dst
word32 strncmp(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut)
{
	word32 eax_110;
	word32 edi_112;
	Eq_2 esi_16 = dwArg0C;
	Eq_2 ecx_104 = dwArg04;
	Eq_2 edx_18 = dwArg08;
	if (dwArg0C > 0x03)
	{
		Eq_2 ebp_29 = (word32) dwArg04 + (dwArg0C & ~0x03);
		do
		{
			eax_110 = (word32) *ecx_104;
			byte al_36 = (byte) eax_110;
			edi_112 = (word32) *edx_18;
			if (al_36 == 0x00 || al_36 != (byte) edi_112)
				goto l0805EFE4;
			eax_110 = (word32) *((word32) ecx_104 + 1);
			byte al_46 = (byte) eax_110;
			edi_112 = (word32) *((word32) edx_18 + 1);
			if (al_46 == 0x00 || al_46 != (byte) edi_112)
				goto l0805EFE4;
			eax_110 = (word32) *((word32) ecx_104 + 2);
			byte al_56 = (byte) eax_110;
			edi_112 = (word32) *((word32) edx_18 + 2);
			if (al_56 == 0x00 || al_56 != (byte) edi_112)
				goto l0805EFE4;
			ecx_104 = (word32) ecx_104 + 4;
			eax_110 = (word32) *((word32) ecx_104 - 1);
			edx_18 = (word32) edx_18 + 4;
			byte al_68 = (byte) eax_110;
			edi_112 = (word32) *((word32) edx_18 - 1);
			if (al_68 == 0x00 || al_68 != (byte) edi_112)
				goto l0805EFE4;
		} while (ecx_104 != ebp_29);
		esi_16 = dwArg0C & 0x03;
	}
	else
	{
		edi_112 = 0x00;
		eax_110 = 0x00;
	}
	if (esi_16 != 0x00)
	{
		eax_110 = (word32) *ecx_104;
		edi_112 = (word32) *edx_18;
		byte al_95 = (byte) eax_110;
		struct Eq_40893 * ebp_107 = (word32) ecx_104 + 1;
		ecx_104 = (word32) edx_18 + 1;
		if (al_95 == (byte) edi_112)
		{
			word32 esi_99 = esi_16 + edx_18;
			if (al_95 != 0x00)
			{
				while (esi_99 != ecx_104)
				{
					++ebp_107;
					eax_110 = (word32) ebp_107->bFFFFFFFF;
					ecx_104 = (word32) ecx_104 + 1;
					byte al_113 = (byte) eax_110;
					edi_112 = (word32) *((word32) ecx_104 - 1);
					if (al_113 == 0x00 || al_113 != (byte) edi_112)
						break;
				}
			}
		}
	}
l0805EFE4:
	ecxOut = ecx_104;
	return eax_110 - (word32) ((byte) edi_112);
}

// 0805EFF0: Register Eq_2 critical_factorization(Register Eq_2 eax, Register (ptr32 int32) ecx, Register Eq_2 edx)
// Called from:
//      two_way_long_needle
//      strstr
Eq_2 critical_factorization(Eq_2 eax, int32 * ecx, Eq_2 edx)
{
	int32 ebp_46 = 0x01;
	int32 ebx_18 = 0x01;
	Eq_2 dwLoc20_152 = ~0x00;
	Eq_2 esi_26 = 0x00;
l0805F018:
	Eq_2 ecx_29 = (word32) esi_26 + ebx_18;
	while (ecx_29 < edx)
	{
		byte dl_42 = Mem31[eax + dwLoc20_152 + ebx_18:byte];
		if (Mem31[eax + ecx_29:byte] >=u dl_42)
		{
			if (Mem31[eax + ecx_29:byte] != dl_42)
			{
				dwLoc20_152 = esi_26;
				ebp_46 = 0x01;
				esi_26 = (word32) esi_26 + 1;
				ebx_18 = 0x01;
			}
			else if (ebx_18 != ebp_46)
				++ebx_18;
			else
			{
				esi_26 = ecx_29;
				ebx_18 = 0x01;
			}
			goto l0805F018;
		}
		esi_26 = ecx_29;
		ebx_18 = 0x01;
		ebp_46 = ecx_29 - dwLoc20_152;
		ecx_29 = (word32) ecx_29 + 1;
	}
	*ecx = ebp_46;
	int32 dwLoc18_161 = 0x01;
	int32 ebx_101 = 0x01;
	Eq_2 edi_105 = ~0x00;
	Eq_2 esi_100 = 0x00;
l0805F068:
	Eq_2 ecx_115 = (word32) esi_100 + ebx_101;
	while (ecx_115 < edx)
	{
		byte dl_93 = Mem90[eax + edi_105 + ebx_101:byte];
		if (Mem90[eax + ecx_115:byte] <=u dl_93)
		{
			if (Mem90[eax + ecx_115:byte] != dl_93)
			{
				edi_105 = esi_100;
				dwLoc18_161 = 0x01;
				esi_100 = (word32) esi_100 + 1;
				ebx_101 = 0x01;
			}
			else if (ebx_101 != dwLoc18_161)
				++ebx_101;
			else
			{
				esi_100 = ecx_115;
				ebx_101 = 0x01;
			}
			goto l0805F068;
		}
		ebx_101 = 0x01;
		dwLoc18_161 = ecx_115 - edi_105;
		esi_100 = ecx_115;
		ecx_115 = (word32) ecx_115 + 1;
	}
	Eq_2 edi_123 = (word32) edi_105 + 1;
	Eq_2 eax_124 = (word32) dwLoc20_152 + 1;
	if (edi_123 >= (word32) dwLoc20_152 + 1)
	{
		*ecx = dwLoc18_161;
		eax_124 = edi_123;
	}
	return eax_124;
}

// 0805F140: Register Eq_2 two_way_long_needle(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 byte) ecxOut, Register out Eq_2 edxOut)
// Called from:
//      strstr
Eq_2 two_way_long_needle(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, byte & ecxOut, union Eq_2 & edxOut)
{
	ui32 eax_30 = gs->dw0014;
	Eq_2 dwLoc0450_570 = edx;
	Eq_2 eax_36 = critical_factorization(ecx, fp - 0x0424, dwArg04);
	word32 * eax_45 = fp - 0x0420;
	do
	{
		*eax_45 = (word32) dwArg04;
		++eax_45;
	} while (eax_45 != fp - 0x20);
	if (dwArg04 != 0x00)
	{
		word32 ebp_58 = dwArg04 + ecx;
		Eq_2 eax_59 = ecx;
		word32 ebx_60 = (word32) dwArg04 + (ecx - 0x01);
		do
		{
			(fp - 0x0420)[(word32) *eax_59] = ebx_60 - eax_59;
			eax_59 = (word32) eax_59 + 1;
		} while (ebp_58 != eax_59);
	}
	Eq_2 eax_294;
	byte * ecx_143;
	Eq_2 edx_150;
	Eq_41042 ebx_215;
	struct Eq_41043 * esp_154 = fp - 1116;
	word32 edx_849;
	word32 ecx_848;
	if (memcmp(ecx, (word32) ecx + dwLoc0424, eax_36, out ecx_848, out edx_849) != 0x00)
	{
		Eq_2 eax_107 = dwArg04 - eax_36;
		if (eax_107 < eax_36)
			eax_107 = eax_36;
		Eq_41042 ebx_111 = 0x00;
		up32 eax_113 = (word32) eax_107 + 1;
		word32 eax_119 = 0x01 - eax_36;
		while (true)
		{
			word32 ebp_129 = ebx_111 + dwArg04;
			if (ebp_129 > dwLoc0450_570)
			{
				word32 edx_854;
				edx_150 = dwLoc0450_570 + strnlen(eax + dwLoc0450_570, dwArg04 + 0x0200, out ecx_143, out edx_854);
				dwLoc0450_570 = edx_150;
				if (ebp_129 > edx_150)
					goto l0805F377;
			}
			esp_154 = fp - 1116;
			word32 eax_159 = (fp - 0x0420)[(word32) *((word32) ebp_129 + (eax - 0x01))];
			if (eax_159 != 0x00)
				ebx_111 = (word32) ebx_111.u0 + eax_159;
			else
			{
				word32 ecx_168 = ecx + eax_36;
				word32 eax_171 = ebx_111 + eax_36 + eax;
				if (eax_36 < dwArg04 - 0x01)
				{
					Eq_2 eax_178;
					if (*ecx_168 == *eax_171)
					{
						eax_178 = eax_36;
						word32 ecx_183 = eax + ebx_111;
						do
						{
							++eax_178;
							if (eax_178 >= dwArg04 - 0x01)
								goto l0805F466;
						} while (Mem155[ecx + eax_178:byte] == Mem155[ecx_183 + eax_178:byte]);
					}
					else
						eax_178 = eax_36;
					ebx_111 = (word32) eax_178 + ((word32) ebx_111 + eax_119);
				}
				else
				{
l0805F466:
					ebx_215 = ebx_111;
					edx_150 = eax_36;
					byte * eax_214 = eax_36 - (byte *) 0x01;
					word32 ebp_217 = ecx + (eax_36 - 0x01);
					ecx_143 = ebx_111 + (eax_36 - 0x01) + eax;
					if (eax_36 == 0x00)
					{
l0805F4AA:
						eax_294 = Mem408[esp_154 + 0x10:word32] + ebx_215;
l0805F379:
						if ((eax_30 ^ gs->dw0014) != 0x00)
						{
							word32 edx_852;
							word32 ecx_851;
							__stack_chk_fail(out ecx_851, out edx_852);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							Eq_2 edx_505;
							byte * ecx_506;
							Eq_2 eax_507 = strstr(gs, dwArg04, stackArg8, out ecx_506, out edx_505);
							ecxOut = ecx_506;
							edxOut = edx_505;
							return eax_507;
						}
						else
						{
							ecxOut = ecx_143;
							edxOut = edx_150;
							return eax_294;
						}
					}
					Eq_2 edi_223 = ecx_143 - eax_36;
					ecx_143 = (word32) *ecx_143;
					edx_150 = edi_223;
					if (*ebp_217 == (byte) ecx_143)
					{
						do
						{
							eax_214 -= (byte *) 0x01;
							if (eax_214 == (byte *) ~0x00)
								goto l0805F4AA;
							ecx_143 = CONVERT(Mem211[eax_214 + 0x01 + edi_223:byte], byte, word32);
						} while (Mem211[ecx + eax_214:byte] == SLICE(ecx_143, byte, 0));
					}
					ebx_111 = (word32) ebx_111 + eax_113;
				}
			}
		}
	}
	else
	{
		Eq_41042 ebx_252 = 0x00;
l0805F208:
		byte * ecx_261 = esp_154->dw000C;
		word32 ebp_264 = ebx_252 + dwArg04;
		if (ebp_264 <= ecx_261)
		{
l0805F240:
			do
			{
				up32 eax_302 = esp_154->a003C[(word32) ebp_264[esp_154[2] - 0x01]];
				if (eax_302 == 0x00)
				{
					Eq_41154 ecx_306 = esp_154->dw0014;
					Eq_41154 eax_307 = esp_154[3];
					esp_154->dw001C = dwArg04 - 0x01;
					if (ecx_306 >= eax_307)
						eax_307 = ecx_306;
					word32 ebp_320 = ecx + eax_307;
					ecx_143 = ebx_252 + eax_307 + Mem310[esp_154 + 0x10:word32];
					if (eax_307 >= dwArg04 - 0x01)
					{
l0805F2DE:
						Eq_2 eax_361 = esp_154[5];
						ebx_215 = ebx_252;
						Eq_2 ebp_362 = esp_154[3];
						edx_150 = eax_361;
						word32 eax_366 = eax_361 + ebx_252 + Mem310[esp_154 + 0x10:word32];
						if (esp_154->dw0014 < ebp_362)
						{
							esp_154->dw001C = eax_366 - ebp_362;
							ecx_143 = (word32) *esp_154->ptr002C;
							if (*eax_366 == (byte) ecx_143)
							{
								Eq_2 ebp_379 = esp_154->dw0014;
								ecx_143 = esp_154->dw001C;
								esp_154->dw0024 = (word32) ebx_252;
								while (true)
								{
									Eq_2 eax_383 = edx_150 - 0x01;
									if (ebp_379 == edx_150 || Mem381[ecx + eax_383:byte] != Mem381[(eax_383 + 0x01) + ecx_143:byte])
										break;
									edx_150 = eax_383;
								}
								ebx_215 = esp_154->dw0024;
							}
							else
								edx_150 = ebp_362;
						}
						else
							edx_150 = esp_154[3];
						if (esp_154->dw0014 + 0x01 > edx_150)
							goto l0805F4AA;
						Eq_41321 eax_519 = esp_154[4];
						esp_154->dw0014 = (up32) (dwArg04 - eax_519);
						ebx_252 = ebx_215 + eax_519;
						goto l0805F208;
					}
					else
					{
						if (*ecx_143 == *ebp_320)
						{
							ecx_143 = Mem310[esp_154 + 0x10:word32] + ebx_252;
							Eq_41154 edx_334 = esp_154->dw001C;
							do
							{
								eax_307 = (word32) eax_307 + 1;
								if (eax_307 >= edx_334)
									goto l0805F2DE;
							} while (Mem310[ecx + eax_307:byte] == Mem310[ecx_143 + eax_307:byte]);
						}
						up32 ebx_353 = ebx_252 - esp_154[3];
						esp_154->dw0014 = 0x00;
						ebx_252 = (word32) eax_307 + 1 + ebx_353;
						goto l0805F208;
					}
				}
				if (esp_154->dw0014 != 0x00)
				{
					up32 ebp_529 = esp_154[4];
					up32 edx_534 = dwArg04 - ebp_529;
					if ((int8) (ebp_529 > eax_302) != 0x00)
						eax_302 = edx_534;
				}
				ecx_261 = esp_154->dw000C;
				esp_154->dw0014 = 0x00;
				ebx_252 = (word32) ebx_252 + eax_302;
				ebp_264 = ebx_252 + dwArg04;
			} while (ebp_264 <= ecx_261);
			goto l0805F213;
		}
l0805F213:
		struct Eq_41104 * esp_268 = esp_154 - 0x08;
		esp_268->tFFFFFFFC = (word32) dwArg04 + 0x0200;
		Eq_2 eax_275 = ecx_261 + esp_268->dw0018;
		esp_268->ptr0014 = ecx_261;
		esp_268->tFFFFFFF8 = eax_275;
		word32 ecx_850;
		Mem289[esp_268 + 0x14:word32] = Mem279[esp_268 + 0x14:word32] + strnlen(esp_268->tFFFFFFF8, esp_268->tFFFFFFFC, out ecx_850, out edx_150);
		esp_154 = (struct Eq_41043 *) ((char *) &esp_268->tFFFFFFFC + 0x0C);
		ecx_143 = esp_268->ptr0014;
		if (ebp_264 <= ecx_143)
			goto l0805F240;
l0805F377:
		eax_294.u0 = 0x00;
		goto l0805F379;
	}
}

// 0805F500: Register Eq_2 strstr(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _nl_find_msg
//      __gettext_extract_plural
//      _IO_file_fopen
//      two_way_long_needle
Eq_2 strstr(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 dwLoc48_693;
	Eq_2 dwLoc4C_684;
	Eq_2 ecx_102 = (word32) *dwArg08;
	word32 eax_27 = (word32) *dwArg04;
	Eq_2 dwLoc40_681 = 0x080CE000;
	word24 nLoc3F_974 = SLICE(0x080CE000, word24, 8);
	byte cl_28 = (byte) ecx_102;
	ui32 eax_24 = gs->dw0014;
	byte al_30 = (byte) eax_27;
	ui24 eax_24_8_60 = SLICE(eax_27, word24, 8);
	if (al_30 == 0x00)
	{
		Eq_2 eax_35 = 0x00;
		if (cl_28 == 0x00)
			eax_35 = dwArg04;
		dwLoc4C_684 = eax_35;
		goto l0805F5E5;
	}
	if (cl_28 == 0x00)
	{
		dwLoc4C_684 = dwArg04;
		goto l0805F5E5;
	}
	Eq_2 ebx_45 = dwArg08;
	edx = dwArg04;
	ui32 esi_47 = 0x01;
	cl_53 = cl_28;
	do
	{
		byte cl_53;
		ebx_45 = (word32) ebx_45 + 1;
		edx = (word32) edx + 1;
		ecx_102 = (word32) *ebx_45;
		word32 eax_63 = (word32) *edx;
		cl_53 = (byte) ecx_102;
		esi_47 &= SEQ(eax_24_8_60, (int8) (al_30 == cl_53));
		al_30 = (byte) eax_63;
		eax_24_8_60 = SLICE(eax_63, word24, 8);
		if (al_30 == 0x00)
		{
			dwLoc4C_684.u0 = 0x00;
			dwLoc48_693 = SEQ(nLoc47, cl_28);
			if (cl_53 != 0x00)
				goto l0805F5E5;
			break;
		}
	} while (cl_53 != 0x00);
	dwLoc4C_684 = dwArg04;
	if ((byte) esi_47 != 0x00)
		goto l0805F5E5;
	Eq_2 eax_101 = strchr((word32) dwArg04 + 1, (int32) cl_28, out ecx_102, out edx);
	Eq_2 esi_93 = ebx_45 - dwArg08;
	dwLoc4C_684 = eax_101;
	if (eax_101 == 0x00 || esi_93 == 0x01)
	{
l0805F5E5:
		if ((eax_24 ^ gs->dw0014) != 0x00)
		{
			word32 ecx_1182;
			word32 edx_1183;
			__stack_chk_fail(out ecx_1182, out edx_1183);
			Eq_2 ecx_655;
			Eq_2 edx_656;
			Eq_2 eax_654 = memcmp(dwLoc48_693, dwLoc44, dwLoc40_681, out ecx_655, out edx_656);
			ecxOut = ecx_655;
			edxOut = edx_656;
			return eax_654;
		}
		else
		{
			ecxOut = ecx_102;
			edxOut = edx;
			return dwLoc4C_684;
		}
	}
	word32 edi_115 = dwArg04 + esi_93;
	Eq_2 ebx_116 = ebx_45 - esi_93;
	Eq_2 edx_119 = edi_115 - eax_101;
	Eq_2 eax_121 = 0x01;
	if (edi_115 >= eax_101)
		eax_121 = edx_119;
	dwLoc48_693 = eax_121;
	if (esi_93 > 0x1F)
	{
		dwLoc4C_684 = two_way_long_needle(eax_101, ebx_116, eax_121, gs, esi_93, out ecx_102, out edx);
		goto l0805F5E5;
	}
	Eq_2 eax_134 = critical_factorization(ebx_116, fp - 0x24, esi_93);
	dwLoc44 = eax_134;
	word32 ecx_1178;
	word32 edx_1179;
	if (memcmp(ebx_116, ebx_116 + dwLoc24, eax_134, out ecx_1178, out edx_1179) == 0x00)
	{
		Eq_2 edi_383 = 0x00;
		struct Eq_4976 * ebx_384 = null;
		word32 eax_387 = eax_134 - 0x01 + ebx_116;
l0805F660:
		dwLoc40_681 = ebx_116;
		word32 edx_396 = esi_93 + ebx_384;
		if (edx_396 <= dwLoc48_693)
		{
l0805F69C:
			Eq_2 eax_427 = eax_134;
			if (eax_134 < edi_383)
				eax_427 = edi_383;
			word32 ecx_440 = ebx_116 + eax_427;
			word32 edx_442 = eax_427 + ebx_384 + eax_101;
			if (esi_93 > eax_427)
			{
				if (edx_442->b0000 == ecx_440->b0000)
				{
					word32 edx_452 = eax_101 + ebx_384;
					do
					{
						++eax_427;
						if (esi_93 == eax_427)
							goto l0805F6E9;
					} while (Mem426[ebx_116 + eax_427:byte] == Mem426[edx_452 + eax_427:byte]);
				}
				edi_383.u0 = 0x00;
				ebx_384 = eax_427 + 0x01 + (ebx_384 - eax_134);
				goto l0805F660;
			}
l0805F6E9:
			edx = eax_134 - (struct Eq_155206 *) 0x01;
			ecx_102 = ebx_384 + (eax_134 - 0x01) + eax_101;
			if (eax_134 > edi_383 && eax_387->b0000 == *ecx_102)
			{
				ecx_102 -= eax_134;
				while (true)
				{
					Eq_2 eax_505 = edx - (struct Eq_155222 *) 0x01;
					if (edi_383 == edx || Mem503[ebx_116 + eax_505:byte] != Mem503[(eax_505 + 0x01) + ecx_102:byte])
						break;
					edx = eax_505;
				}
			}
			else
				edx = eax_134;
			dwLoc40_681 = ebx_116;
			if (edi_383 + 0x01 <=u edx)
			{
				ebx_384 += dwLoc24;
				edi_383 = esi_93 - dwLoc24;
				goto l0805F660;
			}
			dwLoc4C_684 = eax_101 + ebx_384;
			goto l0805F5E5;
		}
		word32 edx_1181;
		word32 ecx_1180;
		ecx_102 = dwLoc48_693 + strnlen(eax_101 + dwLoc48_693, esi_93 + 0x0200, out ecx_1180, out edx_1181);
		edx = edx_396;
		dwLoc48_693 = ecx_102;
		if (edx_396 <= ecx_102)
			goto l0805F69C;
l0805F778:
		dwLoc4C_684.u0 = 0x00;
		goto l0805F5E5;
	}
	byte al_168 = Mem152[ebx_116 + eax_134:byte];
	Eq_2 eax_171 = esi_93 - eax_134;
	if (eax_171 < eax_134)
		eax_171 = eax_134;
	struct Eq_4976 * edi_175 = null;
	word32 eax_177 = eax_171 + 0x01;
l0805F7B0:
	word32 ebx_190 = esi_93 + edi_175;
	if (ebx_190 > dwLoc48_693)
	{
		word32 edx_1184;
		word32 v20_211 = dwLoc48_693 + strnlen(eax_101 + dwLoc48_693, esi_93 + 0x0200, out ecx_102, out edx_1184);
		dwLoc48_693 = v20_211;
		edx = v20_211;
		dwLoc40_681 = SEQ(nLoc3F_974, al_168);
		if (ebx_190 > v20_211)
			goto l0805F778;
	}
	word32 edx_222 = eax_134 + edi_175 + eax_101;
	word32 eax_223 = edx_222 + 0x01;
	if (al_168 != edx_222->b0000)
	{
		word32 eax_234 = strchr(edx_222 + 0x01, CONVERT(al_168, byte, word32), out ecx_102, out edx);
		if (eax_234 == 0x00)
			goto l0805F778;
		eax_223 = (word32) eax_234 + 1;
		edi_175 = eax_234 - (eax_101 + eax_134);
	}
	edx = eax_134 + 0x01;
	word32 ebx_258 = ebx_116 + (eax_134 + 0x01);
	if (esi_93 >u eax_134 + 0x01)
	{
		ecx_102 = eax_223 + 0x01;
		byte al_267 = *eax_223;
		if (al_267 == ebx_258->b0000)
		{
			do
			{
				++edx;
				if (esi_93 <= edx)
					goto l0805F85C;
				++ecx_102;
				al_267 = (byte) *((word32) ecx_102 - 1);
			} while (Mem252[ebx_116 + edx:byte] == al_267);
		}
		if (al_267 == 0x00)
			goto l0805F778;
		if (ecx_102 <=u eax_101 + dwLoc48_693)
		{
l0805F8CA:
			if (esi_93 > edx)
			{
				edi_175 = edx + 0x01 + (edi_175 - eax_134);
				goto l0805F7B0;
			}
			goto l0805F867;
		}
	}
	else
	{
		ecx_102 = eax_223;
l0805F85C:
		if (ecx_102 <=u eax_101 + dwLoc48_693)
		{
l0805F867:
			struct Eq_4976 * eax_333 = eax_134 - (struct Eq_155243 *) 0x01;
			word32 ebx_342 = ebx_116 + (eax_134 - 0x01);
			ecx_102 = eax_134 - 0x01 + edi_175 + eax_101;
			if (eax_134 == 0x00)
			{
l0805F8A3:
				dwLoc4C_684 = eax_101 + edi_175;
				goto l0805F5E5;
			}
			edx = (word32) *ecx_102;
			if (ebx_342->b0000 == (byte) edx)
			{
				ecx_102 -= eax_134;
				do
				{
					eax_333 -= (struct Eq_155249 *) 0x01;
					if (eax_333 == (struct Eq_4976 *) ~0x00)
						goto l0805F8A3;
					edx = CONVERT(Mem331[ecx_102 + 0x01 + eax_333:byte], byte, word32);
				} while (Mem331[ebx_116 + eax_333:byte] == SLICE(edx, byte, 0));
			}
			if ((byte) edx == 0x00)
				goto l0805F778;
			edi_175 += eax_177;
			goto l0805F7B0;
		}
	}
	dwLoc48_693 = ecx_102 - eax_101;
	goto l0805F8CA;
}

// 0805F930: Register word32 memcmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      two_way_long_needle
//      strstr
//      setlocale
//      two_way_long_needle
//      __memmem
//      open_verify.constprop.7
//      fillin_rpath
//      _dl_start_profile
//      _dl_load_cache_lookup
word32 memcmp(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_103 = dwArg08;
	Eq_2 ecx_104 = dwArg0C;
	if (dwArg0C == 0x01)
	{
		ecx_104 = (word32) *dwArg04;
		cu8 cl_651 = (byte) ecx_104;
		if (cl_651 != *dwArg08)
		{
			up32 eax_655 = 0x00 - (cl_651 < *dwArg08);
			ecxOut = ecx_104;
			edxOut = dwArg08;
			return eax_655 - ~0x00 - (eax_655 < 0x00);
		}
	}
	else if (dwArg0C >= 0x01)
	{
		Eq_2 eax_102;
		struct Eq_41820 * esi_100;
		cu8 cl_333;
		cu8 al_289;
		Eq_2 esi_16 = dwArg04;
		if (dwArg0C >= 0x20)
		{
			do
			{
				ecx_104 -= 0x20;
				Eq_2 eax_23 = *esi_16;
				if (eax_23 != *edx_103)
				{
l0805FBE6:
					ecx_104 = *edx_103;
					eax_102 = eax_23;
					goto l0805FBE8;
				}
				Eq_2 eax_27 = *((word32) esi_16 + 4);
				if (eax_27 != *((word32) edx_103 + 4))
				{
l0805FBE3:
					edx_103 = (word32) edx_103 + 4;
					eax_23 = eax_27;
					goto l0805FBE6;
				}
				Eq_2 eax_30 = *((word32) esi_16 + 8);
				if (eax_30 != *((word32) edx_103 + 8))
				{
l0805FBE0:
					edx_103 = (word32) edx_103 + 4;
					eax_27 = eax_30;
					goto l0805FBE3;
				}
				Eq_2 eax_33 = *((word32) esi_16 + 0x0C);
				if (eax_33 != *((word32) edx_103 + 0x0C))
				{
l0805FBDD:
					edx_103 = (word32) edx_103 + 4;
					eax_30 = eax_33;
					goto l0805FBE0;
				}
				Eq_2 eax_36 = *((word32) esi_16 + 16);
				if (eax_36 != *((word32) edx_103 + 16))
				{
l0805FBDA:
					edx_103 = (word32) edx_103 + 4;
					eax_33 = eax_36;
					goto l0805FBDD;
				}
				Eq_2 eax_39 = *((word32) esi_16 + 20);
				if (eax_39 != *((word32) edx_103 + 20))
				{
l0805FBD7:
					edx_103 = (word32) edx_103 + 4;
					eax_36 = eax_39;
					goto l0805FBDA;
				}
				Eq_2 eax_42 = *((word32) esi_16 + 24);
				if (eax_42 != *((word32) edx_103 + 24))
				{
l0805FBD4:
					edx_103 = (word32) edx_103 + 4;
					eax_39 = eax_42;
					goto l0805FBD7;
				}
				eax_42 = *((word32) esi_16 + 28);
				if (eax_42 != *((word32) edx_103 + 28))
				{
					edx_103 = (word32) edx_103 + 4;
					goto l0805FBD4;
				}
				esi_16 = (word32) esi_16 + 32;
				edx_103 = (word32) edx_103 + 32;
			} while (ecx_104 >= 0x20);
			edx_103 += ecx_104;
			esi_100 = esi_16 + ecx_104;
			switch (ecx_104)
			{
			case 0x00:
				goto l0805F9E2;
			case 0x01:
				goto l0805FA49;
			case 0x02:
				goto l0805FABD;
			case 0x03:
				goto l0805FB3C;
			case 0x04:
				goto l0805F9D4;
			case 0x05:
				goto l0805FA3B;
			case 0x06:
				goto l0805FAAF;
			case 0x07:
				goto l0805FB2E;
			case 0x08:
				goto l0805F9C6;
			case 0x09:
				goto l0805FA2D;
			case 0x0A:
				goto l0805FAA1;
			case 11:
				goto l0805FB20;
			case 0x0C:
				goto l0805F9B8;
			case 0x0D:
				goto l0805FA1F;
			case 0x0E:
				goto l0805FA93;
			case 0x0F:
				goto l0805FB12;
			case 0x10:
				goto l0805F9AA;
			case 0x11:
				goto l0805FA11;
			case 0x12:
				goto l0805FA85;
			case 0x13:
				goto l0805FB04;
			case 0x14:
				goto l0805F99C;
			case 0x15:
				goto l0805FA03;
			case 22:
				goto l0805FA77;
			case 0x17:
				goto l0805FAF6;
			case 0x18:
				goto l0805F98E;
			case 0x19:
				goto l0805F9F5;
			case 0x1A:
				goto l0805FA69;
			case 0x1B:
				goto l0805FAE8;
			case 0x1C:
l0805F980:
				eax_102 = esi_100->tFFFFFFE4;
				ecx_104 = *((word32) edx_103 - 28);
				if (eax_102 == ecx_104)
				{
l0805F98E:
					eax_102 = esi_100->tFFFFFFE8;
					ecx_104 = *((word32) edx_103 - 24);
					if (eax_102 == ecx_104)
					{
l0805F99C:
						eax_102 = esi_100->tFFFFFFEC;
						ecx_104 = *((word32) edx_103 - 20);
						if (eax_102 == ecx_104)
						{
l0805F9AA:
							eax_102 = esi_100->tFFFFFFF0;
							ecx_104 = *((word32) edx_103 - 16);
							if (eax_102 == ecx_104)
							{
l0805F9B8:
								eax_102 = esi_100->tFFFFFFF4;
								ecx_104 = *((word32) edx_103 - 0x0C);
								if (eax_102 == ecx_104)
								{
l0805F9C6:
									eax_102 = esi_100->tFFFFFFF8;
									ecx_104 = *((word32) edx_103 - 8);
									if (eax_102 == ecx_104)
									{
l0805F9D4:
										eax_102 = esi_100->tFFFFFFFC;
										ecx_104 = *((word32) edx_103 - 4);
										if (eax_102 == ecx_104)
											goto l0805F9E2;
									}
								}
							}
						}
					}
				}
				break;
			case 0x1D:
l0805F9E7:
				eax_102 = esi_100->tFFFFFFE3;
				ecx_104 = *((word32) edx_103 - 29);
				if (eax_102 == ecx_104)
				{
l0805F9F5:
					eax_102 = esi_100->tFFFFFFE7;
					ecx_104 = *((word32) edx_103 - 25);
					if (eax_102 == ecx_104)
					{
l0805FA03:
						eax_102 = esi_100->tFFFFFFEB;
						ecx_104 = *((word32) edx_103 - 21);
						if (eax_102 == ecx_104)
						{
l0805FA11:
							eax_102 = esi_100->tFFFFFFEF;
							ecx_104 = *((word32) edx_103 - 0x0011);
							if (eax_102 == ecx_104)
							{
l0805FA1F:
								eax_102 = esi_100->tFFFFFFF3;
								ecx_104 = *((word32) edx_103 - 0x0D);
								if (eax_102 == ecx_104)
								{
l0805FA2D:
									eax_102 = esi_100->tFFFFFFF7;
									ecx_104 = *((word32) edx_103 - 9);
									if (eax_102 == ecx_104)
									{
l0805FA3B:
										eax_102 = esi_100->tFFFFFFFB;
										ecx_104 = *((word32) edx_103 - 5);
										if (eax_102 == ecx_104)
										{
l0805FA49:
											if (esi_100->bFFFFFFFF != *((word32) edx_103 - 1))
												goto l0805FBFC;
											ecxOut = ecx_104;
											edxOut = edx_103;
											return 0x00;
										}
									}
								}
							}
						}
					}
				}
				break;
			case 0x1E:
l0805FA5B:
				eax_102 = esi_100->tFFFFFFE2;
				ecx_104 = *((word32) edx_103 - 30);
				if (eax_102 == ecx_104)
				{
l0805FA69:
					eax_102 = esi_100->tFFFFFFE6;
					ecx_104 = *((word32) edx_103 - 26);
					if (eax_102 == ecx_104)
					{
l0805FA77:
						eax_102 = esi_100->tFFFFFFEA;
						ecx_104 = *((word32) edx_103 - 22);
						if (eax_102 == ecx_104)
						{
l0805FA85:
							eax_102 = esi_100->tFFFFFFEE;
							ecx_104 = *((word32) edx_103 - 18);
							if (eax_102 == ecx_104)
							{
l0805FA93:
								eax_102 = esi_100->tFFFFFFF2;
								ecx_104 = *((word32) edx_103 - 0x0E);
								if (eax_102 == ecx_104)
								{
l0805FAA1:
									eax_102 = esi_100->tFFFFFFF6;
									ecx_104 = *((word32) edx_103 - 0x0A);
									if (eax_102 == ecx_104)
									{
l0805FAAF:
										eax_102 = esi_100->tFFFFFFFA;
										ecx_104 = *((word32) edx_103 - 6);
										if (eax_102 == ecx_104)
										{
l0805FABD:
											Eq_2 eax_557 = (word32) esi_100->wFFFFFFFE;
											ecx_104 = (word32) *((word32) edx_103 - 2);
											if ((byte) eax_557 != (byte) ecx_104 || eax_557 != ecx_104)
												goto l0805FBFC;
											ecxOut = ecx_104;
											edxOut = edx_103;
											return 0x00;
										}
									}
								}
							}
						}
					}
				}
				break;
			case 0x1F:
l0805FADA:
				eax_102 = esi_100->tFFFFFFE1;
				ecx_104 = *((word32) edx_103 - 31);
				if (eax_102 == ecx_104)
				{
l0805FAE8:
					eax_102 = esi_100->tFFFFFFE5;
					ecx_104 = *((word32) edx_103 - 27);
					if (eax_102 == ecx_104)
					{
l0805FAF6:
						eax_102 = esi_100->tFFFFFFE9;
						ecx_104 = *((word32) edx_103 - 23);
						if (eax_102 == ecx_104)
						{
l0805FB04:
							eax_102 = esi_100->tFFFFFFED;
							ecx_104 = *((word32) edx_103 - 19);
							if (eax_102 == ecx_104)
							{
l0805FB12:
								eax_102 = esi_100->tFFFFFFF1;
								ecx_104 = *((word32) edx_103 - 0x0F);
								if (eax_102 == ecx_104)
								{
l0805FB20:
									eax_102 = esi_100->tFFFFFFF5;
									ecx_104 = *((word32) edx_103 - 11);
									if (eax_102 == ecx_104)
									{
l0805FB2E:
										eax_102 = esi_100->tFFFFFFF9;
										ecx_104 = *((word32) edx_103 - 7);
										if (eax_102 == ecx_104)
										{
l0805FB3C:
											Eq_2 eax_526 = (word32) esi_100->wFFFFFFFD;
											ecx_104 = (word32) *((word32) edx_103 - 3);
											if ((byte) eax_526 != (byte) ecx_104 || (eax_526 != ecx_104 || esi_100->bFFFFFFFF != *((word32) edx_103 - 1)))
												goto l0805FBFC;
											ecxOut = ecx_104;
											edxOut = edx_103;
											return 0x00;
										}
									}
								}
							}
						}
					}
				}
				break;
			}
l0805FBE8:
			byte ch_409 = SLICE(ecx_104, byte, 8);
			byte ah_365 = SLICE(eax_102, byte, 8);
			cl_333 = (byte) ecx_104;
			al_289 = (byte) eax_102;
			if (al_289 == cl_333 && ah_365 == ch_409)
				ecx_104 >>= 0x10;
l0805FBFC:
			ecxOut = ecx_104;
			edxOut = edx_103;
			up32 eax_599 = 0x00 - (al_289 < cl_333);
			return eax_599 - ~0x00 - (eax_599 < 0x00);
		}
		else
		{
			edx_103 = dwArg08 + dwArg0C;
			esi_100 = dwArg04 + dwArg0C;
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
				goto l0805FA49;
			case 0x02:
				goto l0805FABD;
			case 0x03:
				goto l0805FB3C;
			case 0x04:
				goto l0805F9D4;
			case 0x05:
				goto l0805FA3B;
			case 0x06:
				goto l0805FAAF;
			case 0x07:
				goto l0805FB2E;
			case 0x08:
				goto l0805F9C6;
			case 0x09:
				goto l0805FA2D;
			case 0x0A:
				goto l0805FAA1;
			case 11:
				goto l0805FB20;
			case 0x0C:
				goto l0805F9B8;
			case 0x0D:
				goto l0805FA1F;
			case 0x0E:
				goto l0805FA93;
			case 0x0F:
				goto l0805FB12;
			case 0x10:
				goto l0805F9AA;
			case 0x11:
				goto l0805FA11;
			case 0x12:
				goto l0805FA85;
			case 0x13:
				goto l0805FB04;
			case 0x14:
				goto l0805F99C;
			case 0x15:
				goto l0805FA03;
			case 22:
				goto l0805FA77;
			case 0x17:
				goto l0805FAF6;
			case 0x18:
				goto l0805F98E;
			case 0x19:
				goto l0805F9F5;
			case 0x1A:
				goto l0805FA69;
			case 0x1B:
				goto l0805FAE8;
			case 0x1C:
				goto l0805F980;
			case 0x1D:
				goto l0805F9E7;
			case 0x1E:
				goto l0805FA5B;
			case 0x1F:
				goto l0805FADA;
			}
l0805F9E2:
			ecxOut = ecx_104;
			edxOut = edx_103;
			return 0x00;
		}
	}
	ecxOut = ecx_104;
	edxOut = dwArg08;
	return 0x00;
}

// 0805FC10: void __memmove_chk(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __memmove_chk(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 < dwArg0C)
		__chk_fail();
	else
	{
		word32 edx_23;
		memmove(dwArg04, dwArg08, dwArg0C, out edx_23);
	}
}

// 0805FC30: Register uint32 memmove(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_979 edxOut)
// Called from:
//      _IO_wfile_underflow
//      save_for_backup
//      __memmove_chk
//      getcwd
//      next_line
//      group_number
//      _IO_helper_overflow
//      group_number
//      wmemmove
//      __getdents
//      _dl_map_object_from_fd.constprop.8
//      _dl_sort_maps
uint32 memmove(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_979 & edxOut)
{
	Eq_2 edi_67 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	if (dwArg0C > dwArg04 - dwArg08)
	{
		byte * edi_17 = (word32) dwArg0C + (dwArg04 - 0x01);
		byte * esi_18 = (word32) dwArg0C + (dwArg08 - 0x01);
		if (dwArg0C >> 0x01 < 0x00)
		{
			*edi_17 = *esi_18;
			--esi_18;
			--edi_17;
		}
		word16 * edi_27 = edi_17 - 0x01;
		word16 * esi_29 = esi_18 - 0x01;
		uint32 ecx_31 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 < 0x00)
		{
			*edi_27 = *esi_29;
			++esi_29;
			++edi_27;
		}
		word32 * edi_40 = edi_27 - 0x02;
		word32 * esi_42 = esi_29 - 0x02;
		for (; ecx_31 != 0x00; --ecx_31)
		{
			*edi_40 = *esi_42;
			++esi_42;
			++edi_40;
		}
		edxOut.u0 = <invalid>;
		return ecx_31;
	}
	else
	{
		if (dwArg0C >> 0x01 < 0x00)
		{
			*dwArg04 = *dwArg08;
			esi_11 = (word32) dwArg08 + 1;
			edi_67 = (word32) dwArg04 + 1;
		}
		uint32 ecx_69 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 < 0x00)
		{
			*edi_67 = *esi_11;
			esi_11 = (word32) esi_11 + 2;
			edi_67 = (word32) edi_67 + 2;
		}
		for (; ecx_69 != 0x00; --ecx_69)
		{
			*edi_67 = *esi_11;
			esi_11 = (word32) esi_11 + 4;
			edi_67 = (word32) edi_67 + 4;
		}
		edxOut.u0 = <invalid>;
		return ecx_69;
	}
}

// 0805FC90: Register Eq_2 memset(Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      _IO_str_overflow
//      enlarge_userbuf
//      _int_free
//      _int_malloc
//      __libc_calloc
//      __gconv_open
//      printf_positional
//      printf_positional
//      _dl_map_object_from_fd.constprop.8
//      _dl_nothread_init_static_tls
//      _dl_start_profile
//      _dl_allocate_tls
//      _dl_close_worker
//      _dl_sort_maps
Eq_2 memset(Eq_2 dwArg04, Eq_2 bArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	int32 eax_10 = (word32) bArg08;
	Eq_2 edx_104 = dwArg04;
	Eq_2 ecx_103 = dwArg0C;
	byte al_17 = (byte) eax_10;
	if (dwArg0C != 0x00)
	{
		Eq_2 edi_11 = dwArg04;
		edx_104 = dwArg04 & 0x03;
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (!P)
			{
				*dwArg04 = al_17;
				edi_11 = (word32) dwArg04 + 1;
				ecx_103 = dwArg0C - 0x01;
				if (dwArg0C == 0x01)
					goto l0805FCD1;
			}
			*edi_11 = al_17;
			edi_11 = (word32) edi_11 + 1;
			--ecx_103;
			if (ecx_103 == 0x00)
				goto l0805FCD1;
			if ((dwArg04 & 0x03 ^ 0x01) == 0x00)
			{
				*edi_11 = al_17;
				edi_11 = (word32) edi_11 + 1;
				--ecx_103;
			}
		}
		uint32 ecx_42 = ecx_103 >> 0x02;
		edx_104 = ecx_103 & 0x03;
		while (true)
		{
			byte al_76 = (byte) (eax_10 *s 0x01010101);
			if (ecx_42 == 0x00)
				break;
			*edi_11 = eax_10 *s 0x01010101;
			edi_11 = (word32) edi_11 + 4;
			--ecx_42;
		}
		for (ecx_103 = edx_104; ecx_103 != 0x00; --ecx_103)
		{
			*edi_11 = al_76;
			edi_11 = (word32) edi_11 + 1;
		}
	}
l0805FCD1:
	ecxOut = ecx_103;
	edxOut = edx_104;
	return dwArg04;
}

// 0805FCE0: void __mempcpy_chk(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __mempcpy_chk(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 < dwArg0C)
		__chk_fail();
	else
	{
		word32 edx_23;
		__mempcpy(dwArg04, dwArg08, dwArg0C, out edx_23);
	}
}

// 0805FD00: Register Eq_2 __mempcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      read_alias_file
//      msort_with_tmp.part.0
//      _IO_wfile_underflow
//      __libc_message
//      _IO_file_xsgetn_mmap
//      _IO_file_xsgetn
//      _IO_file_xsputn
//      _IO_file_fopen
//      save_for_backup
//      _IO_default_xsputn
//      _IO_default_xsgetn
//      __mempcpy_chk
//      __wmempcpy
//      __sysconf_check_spec
//      __gconv_open
//      find_derivation
//      add_module.isra.0
//      __gconv_get_path
//      __gconv_read_conf
//      __gconv_transform_internal_ucs4le
//      find_module
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      __printf_fp_l
//      _i18n_number_rewrite
//      strerror_r
//      open_path
//      add_path.isra.3.constprop.9
//      fillin_rpath
//      _dl_new_object
//      _dl_nothread_init_static_tls
//      _dl_important_hwcaps
//      _dl_allocate_tls
//      _dl_get_origin
//      _dl_exception_create
//      _dl_exception_create_format
Eq_2 __mempcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	Eq_2 edi_19 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	if (dwArg0C >> 0x01 < 0x00)
	{
		*dwArg04 = *dwArg08;
		esi_11 = (word32) dwArg08 + 1;
		edi_19 = (word32) dwArg04 + 1;
	}
	uint32 ecx_21 = dwArg0C >> 0x02;
	if (dwArg0C >> 0x02 < 0x00)
	{
		*edi_19 = *esi_11;
		esi_11 = (word32) esi_11 + 2;
		edi_19 = (word32) edi_19 + 2;
	}
	for (; ecx_21 != 0x00; --ecx_21)
	{
		*edi_19 = *esi_11;
		esi_11 = (word32) esi_11 + 4;
		edi_19 = (word32) edi_19 + 4;
	}
	edxOut = esi;
	return edi_19;
}

// 0805FD30: Register (ptr32 Eq_42440) __stpcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_4346 ecxOut)
// Called from:
//      __dcigettext
//      _nl_make_l10nflist
//      __gconv_get_path
//      new_composite_name
//      _dl_dst_substitute
//      _dl_reloc_bad_type
//      _dl_start_profile
struct Eq_42440 * __stpcpy(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_4346 & ecxOut)
{
	Eq_4346 ecx_7 = dwArg08 - dwArg04;
	struct Eq_42440 * eax_10 = dwArg04 - 0x04;
	do
	{
		++eax_10;
		byte dl_14 = Mem13[eax_10 + ecx_7:byte];
		eax_10->t0000.u2 = dl_14;
		if (dl_14 == 0x00)
			goto l0805FD74;
		byte dl_19 = Mem15[eax_10 + 0x01 + ecx_7:byte];
		eax_10->b0001 = dl_19;
		if (dl_19 == 0x00)
			goto l0805FD73;
		byte dl_24 = Mem20[eax_10 + 0x02 + ecx_7:byte];
		eax_10->a0002[0] = dl_24;
		if (dl_24 == 0x00)
			goto l0805FD72;
		byte dl_29 = Mem25[eax_10 + 0x03 + ecx_7:byte];
		eax_10->a0003[0] = dl_29;
	} while (dl_29 != 0x00);
	eax_10 = (struct Eq_42440 *) &eax_10->b0001;
l0805FD72:
	eax_10 = (struct Eq_42440 *) &eax_10->b0001;
l0805FD73:
	eax_10 = (struct Eq_42440 *) &eax_10->b0001;
l0805FD74:
	ecxOut = ecx_7;
	return eax_10;
}

// 0805FD80: Register word32 __strcasecmp_l(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut)
// Called from:
//      alias_compare
//      _nl_expand_alias
//      __gconv_open
//      _nl_find_locale
word32 __strcasecmp_l(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut)
{
	Eq_2 ecx_13 = dwArg04;
	Eq_2 edx_14 = dwArg08;
	if (dwArg04 == dwArg08)
	{
		ecxOut = dwArg04;
		return 0x00;
	}
	else
	{
		Eq_2 ebx_28 = *((word32) dwArg0C + 56);
		do
		{
			edx_14 = (word32) edx_14 + 1;
			word32 edi_31 = (word32) *ecx_13;
			word32 eax_40 = *((word32) ebx_28 + (word32) ((byte) edi_31) * 0x04) - *((word32) ebx_28 + (word32) (*((word32) edx_14 - 1)) * 0x04);
			if (eax_40 != 0x00)
				break;
			ecx_13 = (word32) ecx_13 + 1;
		} while ((byte) edi_31 != 0x00);
		ecxOut = ecx_13;
		return eax_40;
	}
}

// 0805FDE0: void __memcpy_chk(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __memcpy_chk(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if (dwArg10 < dwArg0C)
		__chk_fail();
	else
	{
		word32 ecx_23;
		word32 edx_24;
		memcpy(dwArg04, dwArg08, dwArg0C, out ecx_23, out edx_24);
	}
}

// 0805FE00: Register Eq_2 memcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2052 ecxOut, Register out (ptr32 Eq_2053) edxOut)
// Called from:
//      __libc_setup_tls
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      read_alias_file
//      _nl_make_l10nflist
//      __gettextparse
//      msort_with_tmp.part.0
//      qsort_r
//      _IO_wfile_underflow
//      vasprintf
//      _IO_file_xsgetn
//      save_for_backup
//      _IO_str_overflow
//      enlarge_userbuf
//      _IO_str_pbackfail
//      _int_realloc
//      realloc_check
//      __realloc
//      strcpy
//      strdup
//      __memcpy_chk
//      __sysconf_check_spec
//      getcwd
//      __tdelete
//      _dl_non_dynamic_init
//      __gconv_open
//      find_derivation
//      add_module.isra.0
//      add_alias2.isra.1.part.2
//      find_module
//      __gconv_find_shlib
//      new_composite_name
//      _nl_find_locale
//      _nl_load_locale_from_archive
//      __add_to_environ
//      __printf_fp_l
//      _IO_getdelim
//      _IO_getline_info
//      __libc_scratch_buffer_grow_preserve
//      __strndup
//      strerror_r
//      __wmemcpy
//      add_name_to_object.isra.4
//      open_verify.constprop.7
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      fillin_rpath
//      _dl_init_paths
//      _dl_lookup_symbol_x
//      _dl_new_object
//      _dl_relocate_object
//      _dl_allocate_tls
//      _dl_exception_create
//      _dl_exception_create_format
//      _dl_load_cache_lookup
//      add_to_global
//      dl_open_worker
//      _dl_map_object_deps
Eq_2 memcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2052 & ecxOut, struct Eq_2053 & edxOut)
{
	Eq_2052 ecx_118;
	Eq_2 edi_114 = dwArg04;
	Eq_2 esi_10 = dwArg08;
	Eq_2 ecx_16 = dwArg0C;
	if (((dwArg04 ^ dwArg08) & 0x03) == 0x00 && dwArg0C > 0x03)
	{
		if ((dwArg08 & 0x03) != 0x00)
		{
			*dwArg04 = *dwArg08;
			esi_10 = dwArg08 + 1;
			edi_114 = (word32) dwArg04 + 1;
			ecx_16 = dwArg0C - 0x01;
			if ((dwArg08 + 1 & 0x03) != 0x00)
			{
				Mem64[dwArg04 + 1:byte] = Mem56[dwArg08 + 1:byte];
				esi_10 = dwArg08 + 2;
				edi_114 = (word32) dwArg04 + 2;
				ecx_16 = dwArg0C - 0x02;
				if ((dwArg08 + 2 & 0x03) != 0x00)
				{
					Mem72[dwArg04 + 2:byte] = Mem64[dwArg08 + 2:byte];
					esi_10 = dwArg08 + 3;
					edi_114 = (word32) dwArg04 + 3;
					ecx_16 = dwArg0C - 0x03;
				}
			}
		}
		uint32 ecx_126;
		Eq_2052 eax_84 = ecx_16 & 0x03;
		for (ecx_126 = ecx_16 >> 0x02; ecx_126 != 0x00; --ecx_126)
		{
			*edi_114 = *esi_10;
			esi_10 += 4;
			edi_114 = (word32) edi_114 + 4;
		}
		for (ecx_118 = eax_84; ecx_118 != 0x00; --ecx_118)
		{
			*edi_114 = *esi_10;
			++esi_10;
			edi_114 = (word32) edi_114 + 1;
		}
	}
	else
	{
		if (dwArg0C >> 0x01 < 0x00)
		{
			*dwArg04 = *dwArg08;
			esi_10 = dwArg08 + 1;
			edi_114 = (word32) dwArg04 + 1;
		}
		ecx_118 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 < 0x00)
		{
			*edi_114 = *esi_10;
			esi_10 += 2;
			edi_114 = (word32) edi_114 + 2;
		}
		for (; ecx_118 != 0x00; --ecx_118)
		{
			*edi_114 = *esi_10;
			esi_10 += 4;
			edi_114 = (word32) edi_114 + 4;
		}
	}
	ecxOut = ecx_118;
	edxOut = esi;
	return dwArg04;
}

// 0805FE70: Register Eq_2 rawmemchr(Stack Eq_2 dwArg04, Stack Eq_2562 bArg08)
// Called from:
//      plural_lookup.isra.2
//      _IO_str_init_static_internal
//      _dl_non_dynamic_init
//      __gconv_read_conf
Eq_2 rawmemchr(Eq_2 dwArg04, Eq_2562 bArg08)
{
	byte dl_9 = (byte) dwArg08;
	Eq_42682 edx_12 = SEQ(SLICE(dwArg08, word16, 16), dl_9, dl_9);
	Eq_2 eax_111 = dwArg04;
	word32 edx_155 = SEQ(edx_12, edx_12);
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		if (*dwArg04 == dl_9)
			return eax_111;
		eax_111 = (word32) dwArg04 + 1;
		if (((byte) ((word32) dwArg04 + 1) & 0x03) != 0x00)
		{
			if (*((word32) dwArg04 + 1) == dl_9)
				return eax_111;
			eax_111 = (word32) dwArg04 + 2;
			if (((byte) ((word32) dwArg04 + 2) & 0x03) != 0x00)
			{
				if (*((word32) dwArg04 + 2) == dl_9)
					return eax_111;
				eax_111 = (word32) dwArg04 + 3;
			}
		}
	}
	while (true)
	{
		uint32 ecx_201 = *eax_111 ^ edx_155;
		if (ecx_201 >= ~0x01010100 || (ecx_201 + ~0x01010100 ^ ecx_201 | ~0x01010100) != 0x01)
			break;
		uint32 ecx_203 = *((word32) eax_111 + 4) ^ edx_155;
		if (ecx_203 >= ~0x01010100 || (ecx_203 + ~0x01010100 ^ ecx_203 | ~0x01010100) != 0x01)
		{
l0805FF1E:
			eax_111 = (word32) eax_111 + 4;
			ecx_201 = ecx_203;
			break;
		}
		uint32 ecx_205 = *((word32) eax_111 + 8) ^ edx_155;
		if (ecx_205 >= ~0x01010100 || (ecx_205 + ~0x01010100 ^ ecx_205 | ~0x01010100) != 0x01)
		{
l0805FF1B:
			eax_111 = (word32) eax_111 + 4;
			ecx_203 = ecx_205;
			goto l0805FF1E;
		}
		ecx_205 = *((word32) eax_111 + 0x0C) ^ edx_155;
		if (ecx_205 >= ~0x01010100 || (ecx_205 + ~0x01010100 ^ ecx_205 | ~0x01010100) != 0x01)
		{
			eax_111 = (word32) eax_111 + 4;
			goto l0805FF1B;
		}
		eax_111 = (word32) eax_111 + 16;
	}
	byte ch_113 = SLICE(ecx_201, byte, 8);
	if ((byte) ecx_201 != 0x00)
	{
		eax_111 = (word32) eax_111 + 1;
		if (ch_113 != 0x00)
		{
			eax_111 = (word32) eax_111 + 1;
			if ((ecx_201 & 0x00FF0000) != 0x00)
				eax_111 = (word32) eax_111 + 2;
		}
	}
	return eax_111;
}

// 0805FF40: Register Eq_2 strchrnul(Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      __libc_message
//      _IO_file_fopen
//      _nl_load_locale_from_archive
//      vfprintf
//      __parse_one_specmb
Eq_2 strchrnul(Eq_2 dwArg04, Eq_2 bArg08)
{
	byte dl_9 = (byte) dwArg08;
	Eq_42805 edx_12 = SEQ(SLICE(dwArg08, word16, 16), dl_9, dl_9);
	Eq_2 eax_147 = dwArg04;
	word32 edx_236 = SEQ(edx_12, edx_12);
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		byte cl_21 = *dwArg04;
		if (dl_9 == cl_21 || cl_21 == 0x00)
			return eax_147;
		eax_147 = (word32) dwArg04 + 1;
		if (((byte) ((word32) dwArg04 + 1) & 0x03) != 0x00)
		{
			byte cl_33 = *((word32) dwArg04 + 1);
			if (dl_9 == cl_33 || cl_33 == 0x00)
				return eax_147;
			eax_147 = (word32) dwArg04 + 2;
			if (((byte) ((word32) dwArg04 + 2) & 0x03) != 0x00)
			{
				byte cl_44 = *((word32) dwArg04 + 2);
				if (dl_9 == cl_44 || cl_44 == 0x00)
					return eax_147;
				eax_147 = (word32) dwArg04 + 3;
			}
		}
	}
	while (true)
	{
		uint32 ecx_308 = *eax_147 ^ edx_236;
		if (ecx_308 >= ~0x01010100 || (ecx_308 + ~0x01010100 ^ ecx_308 | ~0x01010100) != 0x01)
			break;
		ecx_308 = ecx_308 ^ edx_236;
		if (ecx_308 >= ~0x01010100 || (ecx_308 + ~0x01010100 ^ ecx_308 | ~0x01010100) != 0x01)
			break;
		uint32 ecx_310 = *((word32) eax_147 + 4) ^ edx_236;
		if (ecx_310 >= ~0x01010100 || (ecx_310 + ~0x01010100 ^ ecx_310 | ~0x01010100) != 0x01)
		{
l0806007C:
			eax_147 = (word32) eax_147 + 4;
			ecx_308 = ecx_310;
			break;
		}
		ecx_310 = ecx_310 ^ edx_236;
		if (ecx_310 >= ~0x01010100 || (ecx_310 + ~0x01010100 ^ ecx_310 | ~0x01010100) != 0x01)
			goto l0806007C;
		uint32 ecx_102 = *((word32) eax_147 + 8) ^ edx_236;
		if (ecx_102 >= ~0x01010100 || (ecx_102 + ~0x01010100 ^ ecx_102 | ~0x01010100) != 0x01)
		{
l08060079:
			eax_147 = (word32) eax_147 + 4;
			ecx_310 = ecx_102;
			goto l0806007C;
		}
		ecx_102 = ecx_102 ^ edx_236;
		if (ecx_102 >= ~0x01010100 || (ecx_102 + ~0x01010100 ^ ecx_102 | ~0x01010100) != 0x01)
			goto l08060079;
		uint32 ecx_125 = *((word32) eax_147 + 0x0C) ^ edx_236;
		if (ecx_125 >= ~0x01010100 || (ecx_125 + ~0x01010100 ^ ecx_125 | ~0x01010100) != 0x01)
		{
l08060076:
			eax_147 = (word32) eax_147 + 4;
			ecx_102 = ecx_125;
			goto l08060079;
		}
		ecx_125 = ecx_125 ^ edx_236;
		if (ecx_125 >= ~0x01010100 || (ecx_125 + ~0x01010100 ^ ecx_125 | ~0x01010100) != 0x01)
			goto l08060076;
		eax_147 = (word32) eax_147 + 16;
	}
	byte ch_182 = SLICE(ecx_308, byte, 8);
	byte cl_158 = (byte) ecx_308;
	if (cl_158 != 0x00 && cl_158 != dl_9)
	{
		eax_147 = (word32) eax_147 + 1;
		if (ch_182 != 0x00 && ch_182 != dl_9)
		{
			eax_147 = (word32) eax_147 + 1;
			byte cl_214 = (byte) (ecx_308 >> 0x10);
			if (cl_214 != 0x00 && cl_214 != dl_9)
				eax_147 = (word32) eax_147 + 2;
		}
	}
	return eax_147;
}

// 080600A0: Register Eq_2 __wmempcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_17418 dwArg0C)
// Called from:
//      _IO_wfile_xsputn
//      save_for_wbackup.isra.0
//      _IO_wdefault_xsputn
//      _IO_wdefault_xsgetn
Eq_2 __wmempcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_17418 dwArg0C)
{
	word32 edx_44;
	return __mempcpy(dwArg04, dwArg08, dwArg0C << 0x02, out edx_44);
}

// 080600D0: Register word32 __mbsrtowcs(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg10, Register out ptr32 ecxOut)
// Called from:
//      locked_vfxprintf
//      __vfwprintf
word32 __mbsrtowcs(struct Eq_9 * gs, Eq_2 dwArg10, ptr32 & ecxOut)
{
	Eq_2 eax_14 = dwArg10;
	if (dwArg10 == 0x00)
		eax_14.u0 = 0x080CF894;
	ptr32 ecx_38;
	word32 eax_37 = __mbsrtowcs_l(gs, dwArg04, dwArg08, dwArg0C, eax_14, gs->ptrFFFFFFD4, out ecx_38);
	ecxOut = ecx_38;
	return eax_37;
}

// 08060110: void _nl_cleanup_ctype(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_43012) dwArg04)
void _nl_cleanup_ctype(Eq_2 edx, struct Eq_9 * gs, struct Eq_43012 * dwArg04)
{
	struct Eq_43013 * esi_14 = dwArg04->ptr0014;
	if (esi_14 != null)
	{
		dwArg04->ptr0014 = null;
		dwArg04->dw0010 = 0x00;
		Eq_2 v10_22 = esi_14->t000C;
		struct Eq_43031 * esi_36;
		word32 edx_107;
		__gconv_close_transform(edx, gs, esi_14->t0008, v10_22, out edx_107, out esi_36);
		Eq_2 esi_58;
		word32 edx_108;
		__gconv_close_transform(v10_22, gs, esi_36->t0000, esi_36->t0004, out edx_108, out esi_58);
		word32 ecx_109;
		word32 edx_110;
		free(gs, dwLoc20, esi_58, out ecx_109, out edx_110);
	}
}

// 08060170: Register Eq_2 __wcsmbs_getfct(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg0C)
// Called from:
//      __wcsmbs_load_conv
//      __wcsmbs_named_conv
Eq_2 __wcsmbs_getfct(struct Eq_9 * gs, Eq_2 dwArg0C)
{
	Eq_2 eax_110;
	ui32 eax_9 = gs->dw0014;
	word32 ebx_127;
	word32 ebp_128;
	word32 esi_129;
	if (__gconv_find_transform(gs, dwArg04, dwArg08, fp - 0x14, fp - 0x18, 0x00, out ebx_127, out ebp_128, out esi_129) == 0x00)
	{
		eax_110 = dwLoc14;
		if (dwLoc18 <= 0x01)
			*dwArg0C = dwLoc18;
		else
		{
			word32 edx_131;
			word32 esi_132;
			__gconv_close_transform(edx, gs, dwLoc14, dwLoc18, out edx_131, out esi_132);
			eax_110.u0 = 0x00;
		}
	}
	else
		eax_110.u0 = 0x00;
	if ((eax_9 ^ gs->dw0014) == 0x00)
		return eax_110;
	word32 ecx_133;
	word32 edx_134;
	__stack_chk_fail(out ecx_133, out edx_134);
	word32 ebx_135;
	word32 esi_136;
	word32 edi_137;
	return __wcsmbs_load_conv(gs, dwLoc18, out ebx_135, out esi_136, out edi_137);
}

// 08060200: Register ui32 __wcsmbs_load_conv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_979 ebxOut, Register out Eq_2 esiOut, Register out Eq_979 ediOut)
// Called from:
//      __wcsmbs_getfct
//      __wcsmbs_clone_conv
//      __mbsrtowcs_l
//      btowc
//      wcrtomb
//      __wcsrtombs
ui32 __wcsmbs_load_conv(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_979 & ebxOut, union Eq_2 & esiOut, union Eq_979 & ediOut)
{
	ui32 eax_23 = gs->dw0014;
	Eq_2 esi_382;
	Mem42 = Mem24;
	esi_382 = esi;
	if (*((word32) dwArg04 + 20) != 0x00)
	{
l08060381:
		ui32 eax_429 = eax_23 ^ gs->dw0014;
		if (eax_429 != 0x00)
		{
			word32 edx_655;
			word32 ecx_654;
			__stack_chk_fail(out ecx_654, out edx_655);
			ui32 eax_442 = __wcsmbs_clone_conv(gs, dwArg04);
			ebxOut.u0 = <invalid>;
			esiOut = esi_382;
			ediOut.u0 = <invalid>;
			return eax_442;
		}
		else
		{
			ebxOut.u0 = <invalid>;
			esiOut = esi;
			ediOut.u0 = <invalid>;
			return eax_429;
		}
	}
	word32 esi_650;
	word32 edi_651;
	word32 ebp_649;
	word32 edx_647;
	word32 ebx_648;
	word32 ecx_646;
	Eq_2 eax_59 = __libc_calloc(gs, 0x01, 0x10, out ecx_646, out edx_647, out ebx_648, out ebp_649, out esi_650, out edi_651);
	struct Eq_43172 * esp_116 = fp - 0x4C;
	if (eax_59 != 0x00)
	{
		word32 * dwLoc3C_469;
		word32 * dwLoc40_470;
		word32 edi_104;
		Eq_2 ecx_171 = *((word32) dwArg04 + 92);
		if (*((word32) dwArg04 + 28) == 0x00)
		{
			dwLoc3C_469 = null;
			edi_104 = 0x03;
			dwLoc40_470 = &g_dw80B41F9;
		}
		else
		{
			dwLoc3C_469 = (word32 *) 0x08;
			edi_104 = 11;
			dwLoc40_470 = &g_dw80A3AA0;
		}
		Eq_2 eax_82 = ecx_171;
		up32 esi_83 = 0x00;
		while (true)
		{
			byte dl_89 = *eax_82;
			if (dl_89 == 0x00)
				break;
			eax_82 = (word32) eax_82 + 1;
			esi_83 += (word32) (int8) (dl_89 == 0x2F);
		}
		ui32 eax_105 = edi_104 + 0x1B + (eax_82 - ecx_171);
		struct Eq_43172 * edi_111 = fp - 0x4C - (eax_105 & ~0x0FFF);
		if (fp - 0x4C != edi_111)
		{
			do
			{
				esp_116 -= 0x1000;
				esp_116->dw0FFC = esp_116->dw0FFC;
			} while (esp_116 != edi_111);
		}
		int32 edx_127 = eax_105 & ~0x0F & 0x0FFF;
		if (edx_127 != 0x00)
		{
			esp_116 -= edx_127;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_116 - 0x04)[edx_127 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_116 - 0x04)[edx_127 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		Eq_43260 eax_139 = (char *) &esp_116->dwFFFFFFF0 + 31;
		int32 eax_151 = (int32) *ecx_171;
		struct Eq_43268 * edx_141 = eax_139 & ~0x0F;
		if ((byte) eax_151 != 0x00)
		{
			Eq_3851 edi_162[] = g_ptr80CE084;
			do
			{
				++edx_141;
				edx_141->bFFFFFFFF = (byte) edi_162[eax_151];
				ecx_171 = (word32) ecx_171 + 1;
				eax_151 = (int32) *ecx_171;
			} while ((byte) eax_151 != 0x00);
		}
		else
			edx_141 = eax_139 & ~0x0F;
		if (esi_83 <= 0x01)
		{
			edx_141->b0000 = 0x2F;
			if (esi_83 == 0x00)
			{
				edx_141[1] = (struct Eq_43268) 0x2F;
				struct Eq_43268 * ecx_196 = edx_141 + 2;
				if (dwLoc3C_469 == null)
					edx_141 = ecx_196;
				else
				{
					if (dwLoc3C_469 < (word32 *) 0x04)
					{
						if (dwLoc3C_469 != null)
							ecx_196->b0000 = (byte) *dwLoc40_470;
					}
					else
					{
						ecx_196->b0000 = (byte) *dwLoc40_470;
						Mem209[ecx_196 - 0x04 + dwLoc3C_469:word32] = Mem206[dwLoc40_470 - 0x04 + dwLoc3C_469:word32];
						Eq_43451 esi_210 = edx_141 + 6;
						word32 * eax_213 = ecx_196 - (esi_210 & ~0x03);
						ptr32 edi_214 = dwLoc40_470 - eax_213;
						word32 eax_215 = eax_213 + dwLoc3C_469;
						if ((eax_215 & ~0x03) >= 0x04)
						{
							Eq_43475 eax_221 = eax_215 & ~0x03 & ~0x03;
							Eq_43475 eax_223 = 0x00;
							do
							{
								Mem231[(esi_210 & ~0x03) + eax_223:word32] = Mem228[edi_214 + eax_223:word32];
								eax_223 = (word32) eax_223 + 4;
							} while (eax_223 < eax_221);
						}
					}
					edx_141 = dwLoc3C_469 + ecx_196;
				}
			}
			else
				++edx_141;
		}
		edx_141->b0000 = 0x00;
		struct Eq_43307 * esp_261 = esp_116 - 0x04;
		esp_261->ptrFFFFFFFC = (word32) eax_59 + 4;
		esp_261->tFFFFFFF8 = eax_139 & ~0x0F;
		esp_261->tFFFFFFF4.u0 = 0x080A4DFD;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg12 = <invalid>;
		Eq_2 eax_299 = __wcsmbs_getfct(gs, stackArg12);
		*eax_59 = eax_299;
		if (eax_299 != 0x00)
		{
			esp_261->ptrFFFFFFFC = (word32) eax_59 + 0x0C;
			esp_261->tFFFFFFF8.u1 = 0x080A4DFD;
			esp_261->tFFFFFFF4 = eax_139 & ~0x0F;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg12 = <invalid>;
			Eq_2 eax_334 = __wcsmbs_getfct(gs, stackArg12);
			*((word32) eax_59 + 8) = eax_334;
			if (eax_334 != 0x00)
			{
l0806036F:
				*((word32) dwArg04 + 20) = eax_59;
				*((word32) dwArg04 + 16) = 0x08060110;
				esi_382 = dwArg04;
				goto l08060381;
			}
			Eq_2 eax_344 = *eax_59;
			if (eax_344 != 0x00)
			{
				esp_261->tFFFFFFF8 = *((word32) eax_59 + 4);
				esp_261->tFFFFFFF4 = eax_344;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				word32 esi_663;
				word32 edx_662;
				__gconv_close_transform(edx, gs, stackArg4, dwArg04, out edx_662, out esi_663);
			}
			esp_116->dwFFFFFFF0 = (word32) eax_59;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_658;
			word32 edx_659;
			free(gs, stackArg0, stackArg4, out ecx_658, out edx_659);
		}
		else
		{
			if (*((word32) eax_59 + 8) != 0x00)
				goto l0806036F;
			esp_261->tFFFFFFF4 = eax_59;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_666;
			word32 edx_667;
			free(gs, stackArg0, stackArg4, out ecx_666, out edx_667);
		}
	}
	((word32) dwArg04 + 20)->u0 = 135055060;
	esi_382 = dwArg04;
	goto l08060381;
}

// 080604E0: Register (ptr32 Eq_43490) __wcsmbs_clone_conv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __wcsmbs_load_conv
//      _IO_fwide
struct Eq_43490 * __wcsmbs_clone_conv(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esi_17 = gs->ptrFFFFFFD0->t0000;
	struct Eq_43497 * eax_18 = *((word32) esi_17 + 20);
	if (eax_18 == null)
	{
		if (esi_17 != 0x080CC740)
		{
			word32 ebx_96;
			word32 esi_97;
			word32 edi_98;
			__wcsmbs_load_conv(gs, esi_17, out ebx_96, out esi_97, out edi_98);
			eax_18 = (struct Eq_43497 *) *((word32) esi_17 + 20);
		}
		else
			eax_18 = (struct Eq_43497 *) 135055060;
	}
	struct Eq_43505 * edx_39 = eax_18->ptr0000;
	*dwArg04 = edx_39;
	*((word32) dwArg04 + 4) = eax_18->dw0004;
	*((word32) dwArg04 + 8) = eax_18->ptr0008;
	word32 ecx_46 = edx_39->dw0000;
	*((word32) dwArg04 + 0x0C) = eax_18->dw000C;
	if (ecx_46 != 0x00)
		++edx_39->dw0008;
	struct Eq_43490 * eax_57 = *((word32) dwArg04 + 8);
	if (eax_57->dw0000 != 0x00)
		++eax_57->dw0008;
	return eax_57;
}

// 08060570: Register word32 __wcsmbs_named_conv(Stack (ptr32 Eq_22681) dwArg04)
// Called from:
//      _IO_file_fopen
word32 __wcsmbs_named_conv(struct Eq_22681 * dwArg04)
{
	Eq_2 eax_27 = __wcsmbs_getfct(gs, &dwArg04->t0004);
	dwArg04->t0000 = eax_27;
	word32 ecx_32 = 0x01;
	if (eax_27 != 0x00)
	{
		Eq_2 eax_46 = __wcsmbs_getfct(gs, (char *) &dwArg04->t0008 + 4);
		dwArg04->t0008 = eax_46;
		ecx_32 = 0x00;
		if (eax_46 == 0x00)
		{
			word32 edx_113;
			word32 esi_114;
			__gconv_close_transform(edx, gs, dwArg04->t0000, dwArg04->t0004, out edx_113, out esi_114);
			ecx_32 = 0x01;
		}
	}
	return ecx_32;
}

// 080605F0: Register int32 __mbsrtowcs_l(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack word32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_11467) dwArg14, Register out Eq_2 ecxOut)
// Called from:
//      __mbsrtowcs
int32 __mbsrtowcs_l(struct Eq_9 * gs, word32 dwArg04, word32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, struct Eq_11467 * dwArg14, union Eq_2 & ecxOut)
{
	Eq_43613 ebx_154 = dwArg14->t0000;
	struct Eq_43617 * esp_168 = fp - 0x017C;
	Eq_2 ecx_171 = dwArg0C;
	ui32 eax_26 = gs->dw0014;
	struct Eq_43625 * eax_183 = *((word32) ebx_154 + 20);
	if (eax_183 != null)
	{
l0806066F:
		struct Eq_43637 * edi_42 = eax_183->ptr0000;
		Eq_2 esi_44 = edi_42->t0014;
		if (edi_42->dw0000 != 0x00)
			esi_44 = __ror(esi_44, 0x09) ^ gs->t0018;
		struct Eq_43650 * esp_271;
		int32 ebp_137;
		Eq_43652 eax_139;
		word24 ecx_24_8_347;
		Eq_2 ebp_225 = *esp_168[6];
		word32 eax_59 = esp_168[5];
		esp_168[0x0C] = (struct Eq_43617) ebp_225;
		if (eax_59 != 0x00)
		{
			word32 eax_201 = esp_168[5];
			esp_168[0x0F] = (struct Eq_43617) eax_201;
			esp_168[16] = (struct Eq_43617) (eax_201 + ecx_171 * 0x04);
			esp_168[2] = (struct Eq_43617) (esp_168 + 11);
			esp_168[3] = (struct Eq_43617) (esp_168 + 0x0C);
			esp_168[4] = (struct Eq_43617) (esp_168 + 0x0F);
			Eq_2 ebx_205 = ecx_171;
			if (ecx_171 == 0x00)
			{
				ebp_137 = 0x00;
				goto l0806079A;
			}
			do
			{
				Eq_2 edx_291;
				struct Eq_43800 * esp_219 = esp_168 - 0x08;
				esp_219->tFFFFFFFC = ebx_205;
				esp_219->tFFFFFFF8 = ebp_225;
				word32 edx_700;
				word32 ecx_699;
				Eq_2 eax_227 = strnlen(esp_219->tFFFFFFF8, esp_219->tFFFFFFFC, out ecx_699, out edx_700);
				esp_219->tFFFFFFF8 = esi_44;
				word32 edx_702;
				word32 ecx_701;
				_dl_mcount_wrapper_check(gs, esp_219->tFFFFFFF4, esp_219->tFFFFFFF8, out ecx_701, out edx_702);
				esp_219->tFFFFFFF4.u0 = 0x01;
				esp_219->dwFFFFFFF0 = 0x00;
				esp_219->dwFFFFFFEC = esp_219->dw0010;
				esp_219->dwFFFFFFE8 = 0x00;
				Eq_2 ebx_236 = (word32) eax_227 + ((word32) ebp_225 + 1);
				esp_219->tFFFFFFE4 = ebx_236;
				esp_219->dwFFFFFFE0 = esp_219->dw0014;
				esp_219->dwFFFFFFDC = esp_219->dw0018;
				esp_219->ptrFFFFFFD8 = edi_42;
				word32 edx_268;
				esi_44();
				ebp_225 = esp_219->t0038;
				esp_271 = (struct Eq_43650 *) ((char *) &esp_219->tFFFFFFFC + 0x0C);
				if (eax_139 != 0x04 && eax_139 != 0x07)
				{
					edx_291 = esp_219->t0044;
					goto l08060732;
				}
				ecx_171 = esp_219->t0044;
				if (ebp_225 != ebx_236 || *((word32) ebx_236 - 1) == 0x00)
					break;
				int32 ebx_286 = esp_219->dw0048 - ecx_171;
				ebx_205 = ebx_286 >> 0x02;
			} while (ebx_286 >> 0x02 != 0x00);
			edx_291 = ecx_171;
l08060732:
			int32 edx_299 = edx_291 - esp_219->ptr001C;
			*esp_219->ptr0020 = (union Eq_2 *) ebp_225;
			ebp_137 = edx_299 >> 0x02;
			if ((eax_139 & ~0x04) != 0x00)
			{
				if ((int8) (eax_139 <= 0x07) != 0x00)
				{
l0806078B:
					if (eax_139 <= 0x07 && !__bt(177, eax_139))
						goto l0806079A;
l080607F0:
					gs->tFFFFFFE0.u0 = 0x54;
					ebp_137 = ~0x00;
l0806079A:
					esp_271 = fp - 380;
					if ((eax_26 ^ gs->dw0014) == 0x00)
					{
						ecxOut = ecx_171;
						return ebp_137;
					}
					word32 edx_707;
					word32 ecx_706;
					__stack_chk_fail(out ecx_706, out edx_707);
l0806092C:
					word32 edi_451 = esp_271->dw001C;
					struct Eq_44152 * esp_453 = esp_271 - 4;
					esp_453->dw0000 = edi_451 + 4294794152;
					esp_453->dwFFFFFFFC = 141;
					esp_453->dwFFFFFFF8 = edi_451 + ~0x0002A556;
					esp_453->dwFFFFFFF4 = edi_451 + 4294793911;
					word32 edx_710;
					word32 ecx_709;
					__assert_fail(out ecx_709, out edx_710);
					esp_271 = esp_453 - 0x0C;
					goto l0806094F;
				}
l080607CD:
				word32 edi_363 = esp_168[7];
				struct Eq_44041 * esp_365 = esp_168 - 4;
				esp_365->dw0000 = edi_363 + 4294794152;
				esp_365->dwFFFFFFFC = 0x99;
				esp_365->dwFFFFFFF8 = edi_363 + ~0x0002A556;
				esp_365->dwFFFFFFF4 = edi_363 + 4294793992;
				word32 edx_708;
				__assert_fail(out ecx_171, out edx_708);
				goto l080607F0;
			}
			word32 ecx_319 = (esp_219->ptr001C - 0x04)[edx_299 >> 0x02];
			ecx_24_8_347 = SLICE(ecx_319, word24, 8);
			if (ecx_319 == 0x00)
			{
				if (edx_299 >> 0x02 == 0x00)
					goto l0806092C;
				if (*esp_219->ptr0058 != 0x00)
				{
l0806094F:
					word32 ecx_474 = esp_271->dw001C;
					struct Eq_44081 * esp_476 = esp_271 - 4;
					esp_476->dw0000 = ecx_474 + 4294794152;
					esp_476->dwFFFFFFFC = 0x8E;
					esp_476->tFFFFFFF8 = ecx_474 + ~0x0002A556;
					esp_476->dwFFFFFFF4 = ecx_474 + 4294793922;
					word32 edx_712;
					word32 ecx_711;
					__assert_fail(out ecx_711, out edx_712);
					_exit(gs, esp_476->tFFFFFFF8);
				}
				*esp_219->ptr0020 = (union Eq_2 *) 0x00;
l08060774:
				--ebp_137;
				goto l08060777;
			}
l08060777:
			uint32 edx_338 = eax_139 - 0x04;
			ecx_171 = SEQ(ecx_24_8_347, (int8) (eax_139 == 0x00));
			if ((byte) (SEQ(SLICE(edx_338, word24, 8), (int8) (edx_338 <= 0x03)) | ecx_171) != 0x00)
				goto l0806078B;
			goto l080607CD;
		}
		struct Eq_43704 * esp_64 = esp_168 - 0x0C;
		esp_64->tFFFFFFFC = ebp_225;
		word32 ecx_697;
		word32 edx_698;
		esp_64->dw0020 = (word32) strlen(esp_64->tFFFFFFFC, out ecx_697, out edx_698) + ((word32) ebp_225 + 1);
		struct Eq_43725 * eax_82 = esp_64->ptr005C;
		word32 edx_83 = eax_82->dw0004;
		esp_64->dw0040 = eax_82->dw0000;
		esp_64->ptr005C = &esp_64->dw0040;
		esp_64->ptr004C = (char *) &esp_64->ptr005C + 268;
		esp_64->ptr0014 = &esp_64->dw0020 + 6;
		esp_64->ptr0018 = &esp_64->dw0020 + 7;
		esp_64->dw0044 = edx_83;
		esp_64->ptr001C = &esp_64->dw0044 + 1;
		ebp_137 = 0x00;
		do
		{
			Mem102[esp_168 + 0x3C:word32] = esp_64 + 0x68;
			struct Eq_43897 * esp_103 = esp_168 - 0x0C;
			esp_103->tFFFFFFFC = esi_44;
			word32 edx_704;
			word32 ecx_703;
			_dl_mcount_wrapper_check(gs, esp_103->tFFFFFFF8, esp_103->tFFFFFFFC, out ecx_703, out edx_704);
			esp_103->tFFFFFFF8.u0 = 0x01;
			esp_103->dwFFFFFFF4 = 0x00;
			esp_103->dwFFFFFFF0 = esp_103->dw0014;
			esp_103->dwFFFFFFEC = 0x00;
			esp_103->dwFFFFFFE8 = esp_103->dw0020;
			esp_103->dwFFFFFFE4 = esp_103->dw0018;
			esp_103->dwFFFFFFE0 = esp_103->dw001C;
			esp_103->ptrFFFFFFDC = edi_42;
			esi_44();
			struct Eq_43954 * ecx_143 = esp_103->ptr0048;
			word32 edx_146 = ecx_143 - (esp_64 + 0x68);
			ecx_24_8_347 = SLICE(ecx_143, word24, 8);
			ebp_137 += edx_146 >> 0x02;
		} while (eax_139 == 0x05);
		if ((eax_139 & ~0x04) != 0x00)
			goto l08060777;
		ebx_154 = ecx_143->tFFFFFFFC;
		if (ebx_154 == 0x00)
			goto l08060774;
		word32 ecx_158 = esp_103->dw0028;
		esp_103->dw0008 = ecx_158 + 4294794152;
		esp_103->dw0004 = 0x5E;
		esp_103->dw0000 = ecx_158 + ~0x0002A556;
		esp_103->tFFFFFFFC = ecx_158 + 4294793948;
		word32 edx_705;
		__assert_fail(out ecx_171, out edx_705);
		esp_168 = esp_103 - 4;
	}
	if (ebx_154 != (word32) esp_168[7] - 6336)
	{
		struct Eq_43681 * esp_184 = esp_168 - 0x0C;
		esp_184->tFFFFFFFC = ebx_154;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 esi_695;
		word32 edi_696;
		word32 ebx_694;
		__wcsmbs_load_conv(gs, stackArg4, out ebx_694, out esi_695, out edi_696);
		esp_168 = (struct Eq_43617 *) ((char *) &esp_184->tFFFFFFFC + 16);
		eax_183 = (struct Eq_43625 *) *((word32) ebx_154 + 20);
		ecx_171 = esp_184->t0194;
	}
	else
		eax_183 = (word32) esp_168[7] - 6444;
	goto l0806066F;
}

// 08060972: void _exit(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      abort
//      __run_exit_handlers
//      __mbsrtowcs_l
//      _dl_non_dynamic_init
//      do_lookup_x
//      _dl_relocate_object
//      _dl_start_profile
//      oom
//      length_mismatch
//      _dl_exception_create_format
//      fatal_error
//      dl_open_worker
//      _dl_close_worker
void _exit(struct Eq_9 * gs, Eq_2 dwArg04)
{
	gs->ptr0010();
	__syscall(0x80);
	__hlt();
}

// 08060990: void __sysconf_check_spec(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
void __sysconf_check_spec(Eq_2 eax, struct Eq_9 * gs)
{
	Eq_2 esi_129;
	Eq_2 dwLoc90_241;
	ui32 eax_23 = gs->dw0014;
	Eq_2 eax_30 = gs->tFFFFFFE0;
	Eq_2 eax_35 = __libc_secure_getenv(0x080A3BCB);
	if (eax_35 != 0x00)
	{
		esi_129 = eax_35;
		word32 ecx_300;
		word32 edx_301;
		dwLoc90_241 = strlen(eax_35, out ecx_300, out edx_301);
	}
	else
	{
		dwLoc90_241.u0 = 0x14;
		esi_129.u0 = 134888374;
	}
	word32 ecx_307;
	word32 edx_308;
	Eq_2 eax_70 = strlen(eax, out ecx_307, out edx_308);
	ui32 eax_81 = (word32) eax_70 + ((word64) dwLoc90_241.u0 + 26);
	Eq_2 esp_107 = fp - 0x98;
	Eq_2 ecx_87 = fp - 0x98 - (eax_81 & ~0x0FFF);
	if (fp - 0x98 != ecx_87)
	{
		do
		{
			esp_107 -= 0x1000;
			*((word32) esp_107 + 0x0FFC) = *((word32) esp_107 + 0x0FFC);
		} while (esp_107 != ecx_87);
	}
	if ((eax_81 & ~0x0F & 0x0FFF) != 0x00)
	{
		esp_107 -= eax_81 & ~0x0F & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_107 - 0x04)[(eax_81 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_107 - 0x04)[(eax_81 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_44292 * esp_116 = esp_107 - 0x04;
	esp_116->tFFFFFFFC = dwLoc90_241;
	esp_116->tFFFFFFF8 = esi_129;
	esp_116->tFFFFFFF4 = esp_107;
	word32 edx_302;
	Eq_2 eax_138 = __mempcpy(esp_116->tFFFFFFF4, esp_116->tFFFFFFF8, esp_116->tFFFFFFFC, out edx_302);
	((word32) eax_138 + 8)->u4 = 24374;
	*eax_138 = 1397706799;
	*((word32) eax_138 + 4) = 1449089097;
	esp_116->tFFFFFFFC = (word32) eax_70 + 1;
	esp_116->tFFFFFFF8 = eax;
	esp_116->tFFFFFFF4 = (word32) eax_138 + 0x0A;
	word32 ecx_303;
	word32 edx_304;
	memcpy(esp_116->tFFFFFFF4, esp_116->tFFFFFFF8, esp_116->tFFFFFFFC, out ecx_303, out edx_304);
	esp_116->tFFFFFFFC = fp - 0x80;
	esp_116->tFFFFFFF8 = esp_107;
	esp_116->tFFFFFFF4.u0 = 0x03;
	__xstat64(gs, esp_116->tFFFFFFF8, esp_116->tFFFFFFFC);
	gs->tFFFFFFE0 = eax_30;
	if ((eax_23 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_306;
	word32 ecx_305;
	__stack_chk_fail(out ecx_305, out edx_306);
	Eq_2 esp_206 = <invalid>;
	word32 esi_311;
	word32 ebp_310;
	word32 ebx_309;
	__sysconf(gs, *((word32) esp_206 + 4), out ebx_309, out ebp_310, out esi_311);
}

// 08060B10: Register Eq_2 __sysconf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ebxOut, Register out Eq_2 ebpOut, Register out ptr32 esiOut)
// Called from:
//      qsort_r
//      __sysconf_check_spec
//      _nl_load_locale_from_archive
Eq_2 __sysconf(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ebxOut, union Eq_2 & ebpOut, ptr32 & esiOut)
{
	Eq_2 ebp_105;
	ui32 eax_20 = gs->dw0014;
	if (dwArg04 <= 199)
	{
		Eq_2 ecx_32;
		word32 edx_395;
		ebp_105 = __cache_sysconf(ecx_32, dwArg04, dwArg04, out ecx_32, out edx_395);
		goto l08060BA0;
	}
	if (dwArg04 != 0x22)
	{
		if (dwArg04 > 0x22)
		{
			ebp_105 = ebp;
			if (dwArg04 >= 0x8A)
			{
				if (dwArg04 <= 0x8B)
				{
					ebp_105.u0 = 200809;
					goto l08060BA0;
				}
				ebp_105 = ebp;
				if (dwArg04 == 0x95)
				{
					up32 eax_249;
					gs->ptr0010();
					ebp_105 = (0x00 - (eax_249 < ~0x0FFE) & 200810) - 0x01;
					goto l08060BA0;
				}
			}
			goto l08060C10;
		}
		if (dwArg04 == 0x00)
		{
			ebp_105.u0 = 0x00020000;
			if (__getrlimit(gs, 0x03, fp - 0x48) == 0x00)
			{
				if (dwLoc48 > 0x0007FFFF)
					ebp_105 = dwLoc48 >> 0x02;
			}
			goto l08060BA0;
		}
		ebp_105 = ebp;
		if (dwArg04 != 0x03)
		{
l08060C10:
			if (dwArg04 <= 0xF6)
			{
				<anonymous> * eax_234 = g_a80A3C28[dwArg04 * 0x04] + 0x080CE000;
				Eq_2 eax_242;
				word32 ecx_243;
				eax_234();
				ebxOut = dwArg04;
				ebpOut = ebp_105;
				esiOut = 0x080CE000;
				return eax_242;
			}
			gs->tFFFFFFE0.u0 = 22;
			ebp_105.u0 = ~0x00;
			goto l08060BA0;
		}
		word32 ecx_398;
		word32 edx_399;
		Eq_2 eax_115 = __open_nocancel(gs, 134888407, 0x00, dwLoc64, out ecx_398, out edx_399);
		ebp_105 = eax_115;
		if (eax_115 == ~0x00)
		{
			ebp_105.u0 = 0x00010000;
			goto l08060BA0;
		}
	}
	else
	{
		ebp_105 = dwLoc48;
		if (__getrlimit(gs, 11, fp - 0x48) == 0x00)
			goto l08060BA0;
		word32 ecx_402;
		word32 edx_403;
		Eq_2 eax_66 = __open_nocancel(gs, 0x080A3C0C, 0x00, dwLoc64, out ecx_402, out edx_403);
		ebp_105 = eax_66;
		if (eax_66 == ~0x00)
		{
l08060BA0:
			while ((eax_20 ^ gs->dw0014) != 0x00)
			{
				word32 edx_397;
				word32 ecx_396;
				__stack_chk_fail(out ecx_396, out edx_397);
				ebp_105.u0 = ~0x00;
			}
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			return ebp_105;
		}
	}
	do
	{
		dwLoc64.u0 = 0x1F;
		word32 ecx_400;
		Eq_2 eax_142 = __read_nocancel(gs, ebp_105, fp - 0x40, 0x1F, out ecx_400);
		if (eax_142 != ~0x00)
		{
			word32 edx_401;
			__close_nocancel(gs, ebp_105, out edx_401);
			if (eax_142 <= 0x00)
				goto l08060C10;
			Mem185[fp - 0x40 + eax_142:byte] = 0x00;
			dwLoc64.u0 = 0x0A;
			ebp_105 = __strtol(gs, fp - 0x40, fp - 0x48, 0x0A);
			if (dwLoc48 == fp - 0x40)
				goto l08060C10;
			byte al_208 = *dwLoc48;
			if (al_208 != 0x00 && al_208 != 0x0A)
				goto l08060C10;
			goto l08060BA0;
		}
	} while (gs->tFFFFFFE0 == 0x04);
	word32 edx_404;
	__close_nocancel(gs, ebp_105, out edx_404);
	goto l08060C10;
}

// 08060F10: void sched_yield(Register (ptr32 Eq_9) gs)
// Called from:
//      _IO_cleanup
void sched_yield(struct Eq_9 * gs)
{
	struct Eq_226 * eax_7;
	gs->ptr0010();
	if (eax_7 < (struct Eq_226 *) ~0x0FFE)
		return;
	word32 edx_29;
	__syscall_error(eax_7, gs, out edx_29);
}

// 08060F30: void __get_child_max(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
void __get_child_max(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	ui32 eax_7 = gs->dw0014;
	__getrlimit(gs, 0x06, fp - 0x18) != 0x00;
	if ((eax_7 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_78;
	word32 edx_79;
	__stack_chk_fail(out ecx_78, out edx_79);
	__xstat64(gs, dwArg08, dwArg0C);
}

// 08060F80: Register (ptr32 Eq_226) __xstat64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __sysconf_check_spec
//      __get_child_max
//      open_path
struct Eq_226 * __xstat64(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	struct Eq_226 * eax_11;
	gs->ptr0010();
	if (eax_11 <= (struct Eq_226 *) ~0x0FFF)
		return eax_11;
	word32 edx_44;
	return __syscall_error(eax_11, gs, out edx_44);
}

// 08060FB0: Register (ptr32 Eq_226) __fxstat64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_979 ecxOut, Register out ptr32 edxOut)
// Called from:
//      check_one_fd
//      _nl_load_domain
//      _IO_file_stat
//      getcwd
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      opendir
//      __fdopendir
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_226 * __fxstat64(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_979 & ecxOut, ptr32 & edxOut)
{
	struct Eq_226 * eax_11;
	ptr32 edx_29;
	gs->ptr0010();
	if (eax_11 > (struct Eq_226 *) ~0x0FFF)
	{
		ptr32 edx_19;
		struct Eq_226 * eax_18 = __syscall_error(eax_11, gs, out edx_19);
		ecxOut.u0 = <invalid>;
		edxOut = edx_19;
		return eax_18;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_29;
		return eax_11;
	}
}

// 08060FE0: Register (ptr32 Eq_226) open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _IO_file_open
struct Eq_226 * open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	struct Eq_44665 * esp_13 = fp - 0x1C;
	if (((byte) dwArg08 & 0x40) != 0x00 || (dwArg08 & 0x00410000) == 0x00410000)
		;
	struct Eq_226 * eax_128;
	if (gs->t000C == 0x00)
	{
		gs->ptr0010();
		if (eax_128 > (struct Eq_226 *) ~0x0FFF)
		{
			word32 edx_149;
			eax_128 = __syscall_error(eax_128, gs, out edx_149);
		}
	}
	else
	{
		word32 ecx_147;
		word32 edx_148;
		word32 eax_46 = __libc_enable_asynccancel(gs, out ecx_147, out edx_148);
		struct Eq_226 * eax_54;
		gs->ptr0010();
		if (eax_54 > (struct Eq_226 *) ~0x0FFF)
		{
			word32 edx_150;
			eax_54 = __syscall_error(eax_54, gs, out edx_150);
			esp_13 = fp - 0x18;
		}
		esp_13->ptr000C = eax_54;
		struct Eq_44716 * esp_69 = esp_13 - 0x0C;
		esp_69->dwFFFFFFFC = eax_46;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 edx_153;
		word32 ecx_152;
		__libc_disable_asynccancel(gs, stackArg4, out ecx_152, out edx_153);
		eax_128 = esp_69->ptr0018;
	}
	return eax_128;
}

// 080610A0: Register (ptr32 Eq_226) read(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _IO_file_read
//      __gconv_load_cache
struct Eq_226 * read(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	struct Eq_226 * eax_100;
	struct Eq_44740 * esp_10 = fp - 0x1C;
	if (gs->t000C != 0x00)
	{
		word32 ecx_120;
		word32 edx_121;
		word32 eax_23 = __libc_enable_asynccancel(gs, out ecx_120, out edx_121);
		struct Eq_226 * eax_31;
		gs->ptr0010();
		if (eax_31 > (struct Eq_226 *) ~0x0FFF)
		{
			word32 edx_122;
			eax_31 = __syscall_error(eax_31, gs, out edx_122);
			esp_10 = fp - 0x18;
		}
		esp_10->ptr0008 = eax_31;
		struct Eq_44773 * esp_45 = esp_10 - 0x0C;
		esp_45->dwFFFFFFFC = eax_23;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_124;
		word32 edx_125;
		__libc_disable_asynccancel(gs, stackArg4, out ecx_124, out edx_125);
		eax_100 = esp_45->ptr0014;
		return eax_100;
	}
	else
	{
		gs->ptr0010();
		if (eax_100 <= (struct Eq_226 *) ~0x0FFF)
			return eax_100;
		word32 edx_126;
		return __syscall_error(eax_100, gs, out edx_126);
	}
}

// 08061140: Register (ptr32 Eq_226) __libc_write(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C, Register out Eq_979 ebxOut, Register out Eq_979 esiOut)
// Called from:
//      __assert_fail_base
//      _IO_new_file_write
struct Eq_226 * __libc_write(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 dwArg08, int32 dwArg0C, union Eq_979 & ebxOut, union Eq_979 & esiOut)
{
	struct Eq_226 * eax_100;
	struct Eq_44795 * esp_10 = fp - 0x1C;
	if (gs->t000C == 0x00)
	{
		gs->ptr0010();
		if (eax_100 > (struct Eq_226 *) ~0x0FFF)
		{
			word32 edx_128;
			struct Eq_226 * eax_73 = __syscall_error(eax_100, gs, out edx_128);
			ebxOut.u0 = <invalid>;
			esiOut.u0 = <invalid>;
			return eax_73;
		}
	}
	else
	{
		word32 ecx_122;
		word32 edx_123;
		word32 eax_23 = __libc_enable_asynccancel(gs, out ecx_122, out edx_123);
		struct Eq_226 * eax_31;
		gs->ptr0010();
		if (eax_31 > (struct Eq_226 *) ~0x0FFF)
		{
			word32 edx_124;
			eax_31 = __syscall_error(eax_31, gs, out edx_124);
			esp_10 = fp - 0x18;
		}
		esp_10->ptr0008 = eax_31;
		struct Eq_44828 * esp_45 = esp_10 - 0x0C;
		esp_45->dwFFFFFFFC = eax_23;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_126;
		word32 edx_127;
		__libc_disable_asynccancel(gs, stackArg4, out ecx_126, out edx_127);
		eax_100 = esp_45->ptr0014;
	}
	ebxOut.u0 = <invalid>;
	esiOut.u0 = <invalid>;
	return eax_100;
}

// 080611E0: Register Eq_2 lseek64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 edxOut, Register out Eq_2 ebxOut, Register out ptr32 esiOut, Register out Eq_2 ediOut)
// Called from:
//      mmap_remap_check
//      _IO_file_seek
//      _IO_file_sync_mmap
//      decide_maybe_mmap
//      __getdents
Eq_2 lseek64(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & edxOut, union Eq_2 & ebxOut, ptr32 & esiOut, union Eq_2 & ediOut)
{
	ui32 eax_15 = gs->dw0014;
	struct Eq_226 * eax_26;
	gs->ptr0010();
	if (eax_26 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_138;
		eax_26 = __syscall_error(eax_26, gs, out edx_138);
	}
	int64 edx_eax_40 = (int64) eax_26;
	Eq_2 eax_102 = (word32) edx_eax_40;
	ptr32 edx_107 = SLICE(edx_eax_40, word32, 32);
	if (eax_102 == 0x00)
	{
		eax_102 = dwLoc1C;
		edx_107 = dwLoc18;
	}
	if ((eax_15 ^ gs->dw0014) != 0x00)
	{
		word32 edx_140;
		word32 ecx_139;
		__stack_chk_fail(out ecx_139, out edx_140);
		ptr32 edx_71;
		word32 edi_141;
		Eq_2 eax_70 = getcwd(gs, dwArg04, dwArg08, out edx_71, out edi_141);
		edxOut = edx_71;
		ebxOut = dwArg04;
		esiOut = fp - 0x1C;
		ediOut = dwArg10;
		return eax_70;
	}
	else
	{
		edxOut = edx_107;
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return eax_102;
	}
}

// 08061250: Register word32 getcwd(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 edxOut, Register out ptr32 ediOut)
// Called from:
//      __dcigettext
//      lseek64
//      __gconv_get_path
//      _dl_new_object
word32 getcwd(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & edxOut, ptr32 & ediOut)
{
	struct Eq_44897 * esp_101;
	ui32 eax_20 = gs->dw0014;
	Eq_2 edi_161 = dwArg08;
	Eq_2 esi_134 = dwArg04;
	if (dwArg08 == 0x00)
	{
		if (dwArg04 != 0x00)
		{
			gs->tFFFFFFE0.u0 = 22;
			dwLocDC = 0x00;
			goto l08061541;
		}
		Eq_2 eax_39 = __getpagesize();
		edi_161.u0 = 0x1000;
		if (eax_39 >= 0x1000)
			edi_161 = eax_39;
	}
	else
	{
		edi_161 = dwArg08;
		if (dwArg04 != 0x00)
			goto l080612CF;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	esp_101 = fp - 0xEC;
	word32 esi_1325;
	word32 edi_1326;
	word32 ecx_1322;
	word32 ebx_1323;
	word32 ebp_1324;
	if (__libc_malloc(gs, stackArg0, edi_161, out ecx_1322, out edx, out ebx_1323, out ebp_1324, out esi_1325, out edi_1326) == 0x00)
		goto l08061539;
l080612CF:
	struct Eq_226 * eax_77;
	gs->ptr0010();
	esp_101 = fp - 0xEC;
	if (eax_77 > (struct Eq_226 *) ~0x0FFF)
	{
		eax_77 = __syscall_error(eax_77, gs, out edx);
		esp_101 = fp - 232;
	}
	if (eax_77 > null)
	{
		edi_161.u0 = ~0x1F;
		edx = esp_101->dw00F4 | dwArg04;
		if (*esp_101[1].dw0000 == 0x2F)
		{
			esp_101->dw0010 = (word32) dwArg04;
			if (edx == 0x00)
			{
				struct Eq_46163 * esp_169 = esp_101 - 0x08;
				esp_169->ptrFFFFFFFC = eax_77;
				esp_169->dwFFFFFFF8 = esp_169->dw0014;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 esi_1382;
				word32 ebp_1381;
				word32 edi_1383;
				esp_169->t0018 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx, out ebp_1381, out esi_1382, out edi_1383);
			}
			byte * eax_186 = esp_101->dw0010;
			byte * ebx_187 = esp_101[1];
			if (eax_186 != null)
				ebx_187 = eax_186;
			esp_101->dw0010 = ebx_187;
l08061541:
			esp_101 = fp - 0x00EC;
			if ((eax_20 ^ gs->dw0014) == 0x00)
			{
				edxOut = edx;
				ediOut = edi;
				return dwLocDC;
			}
			word32 ecx_1346;
			word32 edx_1347;
			__stack_chk_fail(out ecx_1346, out edx_1347);
l080619D4:
			edx = gs->*edi_161.u0;
l080617D4:
			esp_101->dw0014 = (word32) edx;
			struct Eq_45792 * esp_884 = esp_101 - 0x0C;
			esp_884->tFFFFFFFC = esi_134;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			closedir(gs, stackArg4);
			esp_101 = (struct Eq_44897 *) ((char *) &esp_884->tFFFFFFFC + 16);
			edx = esp_884->t0020;
l080617E8:
			if (esp_101->dw0010 == 0x00)
			{
				esp_101->dw0014 = (word32) edx;
				struct Eq_45727 * esp_914 = esp_101 - 0x0C;
				esp_914->dwFFFFFFFC = esp_914->dw0018;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_1360;
				word32 edx_1361;
				free(gs, stackArg0, stackArg4, out ecx_1360, out edx_1361);
				esp_101 = (struct Eq_44897 *) (&esp_914->dwFFFFFFFC + 5);
				edx = esp_914->t0024;
			}
			gs->*edi_161.u0 = edx;
			if (esp_101->dw00F4 != 0x00 && esp_101->b003E != 0x00)
			{
				struct Eq_45762 * esp_954 = esp_101 - 0x0C;
				esp_954->dwFFFFFFFC = esp_954->dw001C;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_1364;
				free(gs, stackArg0, stackArg4, out ecx_1364, out edx);
				esp_954->dw0020 = 0x00;
				goto l08061541;
			}
			goto l08061539;
		}
	}
	else
	{
		edi_161.u0 = ~0x1F;
		if (eax_77 != null)
		{
			Eq_2 eax_97 = gs->tFFFFFFE0;
			if (eax_97 != 0x24)
			{
				if (eax_97 == 0x22 && (dwArg04 | esp_101->dw00F4) == 0x00)
				{
					struct Eq_45932 * esp_118 = esp_101 - 4;
					esp_118->ptr0000 = 0x080A4058;
					esp_118->dwFFFFFFFC = 121;
					esp_118->ptrFFFFFFF8 = 0x080A4008;
					esp_118->ptrFFFFFFF4 = 0x080A402C;
					word32 ecx_1369;
					word32 edx_1370;
					__assert_fail(out ecx_1369, out edx_1370);
					esp_101 = esp_118 - 0x0C;
					esi_134 = dwArg04;
					goto l080618A8;
				}
				if (dwArg04 == 0x00)
				{
					struct Eq_45462 * esp_140 = esp_101 - 0x0C;
					esp_140->dwFFFFFFFC = esp_140->dw0018;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_1345;
					free(gs, stackArg0, stackArg4, out ecx_1345, out edx);
					esp_140->dw0020 = 0x00;
					goto l08061541;
				}
				goto l08061539;
			}
		}
		edx = esp_101->dw00F4 | dwArg04;
	}
	esp_101->b003E = (int8) (dwArg04 == 0x00);
	edi_161.u0 = ~0x1F;
	if (edx != 0x00)
	{
		esi_134 = esp_101->dw00F4;
		if (esi_134 != 0x00)
		{
			esp_101->dw004C = (word32) gs->tFFFFFFE0;
			esp_101->dw0010 = (word32) esp_101[1];
			esp_101[4] = (struct Eq_44897) esp_101->dw00F4;
			goto l08061348;
		}
		gs->tFFFFFFE0.u0 = 22;
	}
	else
	{
		struct Eq_44978 * esp_204 = esp_101 - 0x0C;
		esp_204->dwFFFFFFFC = esp_204->dw0018;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_1329;
		word32 edx_1330;
		free(gs, stackArg0, stackArg4, out ecx_1329, out edx_1330);
		Eq_2 eax_223 = gs->tFFFFFFE0;
		esp_204->dw0000 = 0x1001;
		esp_204->t005C = eax_223;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 esi_1336;
		word32 edi_1337;
		word32 ebx_1334;
		word32 ecx_1333;
		word32 ebp_1335;
		Eq_2 eax_226 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1333, out edx, out ebx_1334, out ebp_1335, out esi_1336, out edi_1337);
		esp_204->t001C = eax_226;
		esp_101 = (struct Eq_44897 *) (&esp_204->dw0000 + 4);
		if (eax_226 != 0x00)
		{
			esp_204->dw0020 = 0x00;
			esp_204->dw0040 = 0x1001;
l08061348:
			struct Eq_45057 * esp_251 = esp_101 - 0x04;
			struct Eq_45114 * ebx_252 = (word32) esp_101[1].dw0000 + esp_251->dw0034;
			ebx_252->bFFFFFFFF = 0x00;
			esp_251->ptr001C = &esp_251->dw0070;
			esp_251->ptrFFFFFFFC = &esp_251->dw0070;
			esp_251->ptrFFFFFFF8 = 0x080A4005;
			esp_251->dwFFFFFFF4 = 0x03;
			esi_134 = &esp_251->dw0070;
			esp_101 = (struct Eq_44897 *) ((char *) &esp_251->ptrFFFFFFFC + 8);
			if (__lxstat64(gs, esp_251->ptrFFFFFFF8, esp_251->ptrFFFFFFFC) >= 0x00)
			{
				word32 edx_278 = esp_251->dw0070;
				word32 ecx_281 = esp_251->dw00C8;
				esp_251->dw0028 = esp_251->dw0074;
				esp_251->dw0024 = edx_278;
				esp_251->dw0020 = ecx_281;
				esp_251->ptrFFFFFFFC = &esp_251->dw0070;
				esp_251->ptrFFFFFFF8 = 134893093;
				esp_251->dwFFFFFFF4 = 0x03;
				esp_101 = (struct Eq_44897 *) ((char *) &esp_251->ptrFFFFFFFC + 8);
				if (__lxstat64(gs, esp_251->ptrFFFFFFF8, esp_251->ptrFFFFFFFC) >= 0x00)
				{
					word32 edx_303 = esp_251->dw00C8;
					word32 ecx_305 = esp_251->dw0074;
					esp_251->dw0054 = ebx_252 - 0x01;
					word32 eax_307 = esp_251->dw0028;
					word32 esi_308 = esp_251->dw0070;
					esp_251->dw0038 = edx_303;
					word32 edx_310 = esp_251->dw0024;
					esp_251->dw005C = ecx_305;
					word32 ecx_313 = esp_251->dw0038;
					esp_251->dw0058 = esi_308;
					byte dl_323 = (int8) ((edx_310 ^ esi_308 | eax_307 ^ ecx_305) != 0x00) | (int8) (esp_251->dw0020 != ecx_313);
					esp_251->b0043 = dl_323;
					if (dl_323 == 0x00)
					{
l0806174C:
						if (esp_101->dw0050 == (word32) (esp_101)[4].dw0000 + (esp_101[1] - 0x01))
						{
							struct Eq_46020 * eax_777 = esp_101->dw0050;
							eax_777->bFFFFFFFF = 0x2F;
							esp_101->dw0050 = eax_777 - 0x01;
						}
						Eq_2 eax_784 = esp_101->dw0050;
						struct Eq_46037 * esp_785 = esp_101 - 0x04;
						Eq_2 ebx_788 = ebx_252 - eax_784;
						esp_785->tFFFFFFFC = ebx_788;
						esp_785->tFFFFFFF8 = eax_784;
						esp_785->tFFFFFFF4 = esp_785->t0010;
						memmove(esp_785->tFFFFFFF4, esp_785->tFFFFFFF8, esp_785->tFFFFFFFC, out edx);
						esi_134 = esp_785->t00F8;
						if (esi_134 == 0x00)
						{
							esp_785->tFFFFFFF8 = ebx_788;
							esp_785->tFFFFFFF4 = esp_785->t0010;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 ebp_1376;
							word32 esi_1377;
							word32 edi_1378;
							esp_785->t0014 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx, out ebp_1376, out esi_1377, out edi_1378);
						}
						byte * eax_836 = esp_101->dw0010;
						byte * ebx_837 = esp_101[1];
						if (eax_836 != null)
							ebx_837 = eax_836;
						Eq_2 eax_844 = esp_101->dw004C;
						esp_101->dw0010 = ebx_837;
						gs->tFFFFFFE0 = eax_844;
						goto l08061541;
					}
					esp_251->dw0018 = ~0x63;
					esp_251->ptr003C = 0x080A4004;
					esi_134.u0 = 0x00;
					do
					{
						struct Eq_45190 * esp_335 = esp_101 - 0x04;
						esp_335->tFFFFFFFC.u0 = 0x00080000;
						esp_335->tFFFFFFF8 = esp_335->t003C;
						esp_335->tFFFFFFF4 = esp_335->t0018;
						Eq_2 eax_346 = __openat64_nocancel(gs, esp_335->tFFFFFFF4, esp_335->tFFFFFFF8, esp_335->tFFFFFFFC, esp_335->dw0000);
						esp_335->t0018 = eax_346;
						esp_101 = (struct Eq_44897 *) (&esp_335->dw0000 + 1);
						if (eax_346 < 0x00)
						{
							edx = gs->tFFFFFFE0;
							if (esi_134 != 0x00)
								goto l080617D4;
							goto l080617E8;
						}
						Eq_2 edx_384;
						esp_335->tFFFFFFFC = esp_335->t001C;
						esp_335->tFFFFFFF8 = eax_346;
						esp_335->tFFFFFFF4.u0 = 0x03;
						word32 edx_1339;
						word32 ecx_1338;
						if (__fxstat64(gs, esp_335->tFFFFFFF8, esp_335->tFFFFFFFC, out ecx_1338, out edx_1339) < 0x00)
						{
							edx_384 = gs->tFFFFFFE0;
							if (esi_134 != 0x00)
							{
								esp_335->t001C = edx_384;
								esp_335->tFFFFFFF4 = esi_134;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg4 = <invalid>;
								closedir(gs, stackArg4);
								edx_384 = esp_335->t001C;
							}
							goto l0806194E;
						}
						if (esi_134 != 0x00)
						{
							esp_335->tFFFFFFF4 = esi_134;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							if (closedir(gs, stackArg4) == 0x00)
								goto l08061465;
l0806194B:
							edx_384 = gs->tFFFFFFE0;
l0806194E:
							esp_101[2] = (struct Eq_44897) edx_384;
							struct Eq_45987 * esp_453 = esp_101 - 0x0C;
							esp_453->tFFFFFFFC = esp_453->t0020;
							word32 edx_1372;
							__close_nocancel(gs, esp_453->tFFFFFFFC, out edx_1372);
							esp_101 = (struct Eq_44897 *) ((char *) &esp_453->tFFFFFFFC + 16);
							edx = esp_453->t0024;
							goto l080617E8;
						}
l08061465:
						struct Eq_45225 * esp_422 = esp_101 - 0x0C;
						word32 ecx_421 = esp_101->dw0070;
						word32 ebx_424 = esp_422->dw00D0;
						esp_422->dw0050 = (word32) esp_101[9];
						esp_422->dw004C = ecx_421;
						esp_422->dw0068 = ebx_424;
						esp_422->dwFFFFFFFC = esp_422->dw0020;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						Eq_2 eax_436 = __fdopendir(gs, stackArg4);
						esp_101 = (struct Eq_44897 *) (&esp_422->dwFFFFFFFC + 4);
						esi_134 = eax_436;
						if (eax_436 == 0x00)
							goto l0806194B;
						ui32 ecx_471 = esp_422->dw004C ^ esp_422->dw0030;
						esp_422->dw0034 = esp_422->dw0050 ^ esp_422->dw002C;
						word32 ebx_475 = (word32) esp_422->b004B;
						esp_422->dw0038 = ecx_471;
						esi_134 = eax_436;
						do
						{
							gs->tFFFFFFE0.u0 = 0x00;
							struct Eq_45320 * esp_480 = esp_1384 - 0x0C;
							esp_480->tFFFFFFFC = eax_436;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							byte bl_503 = (byte) ebx_475;
							struct Eq_45309 * eax_491 = __readdir(gs, stackArg4);
							word24 edx_24_8_853 = SLICE(edx_493, word24, 8);
							esp_101 = (struct Eq_44897 *) &esp_480->t000C;
							if (eax_491 == null)
							{
								edx = gs->tFFFFFFE0;
								if (edx != 0x00)
									goto l080617D4;
								if (bl_503 == 0x00)
								{
									gs->tFFFFFFE0.u0 = 0x02;
									edx.u0 = 0x02;
									goto l080617D4;
								}
								else
								{
									esp_480->tFFFFFFFC = eax_436;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg4 = <invalid>;
									ebx_475 = 0x00;
									Eq_2 edx_517 = __rewinddir(edx_517, gs, stackArg4);
									esp_101 = (struct Eq_44897 *) &esp_480->t000C;
									continue;
								}
							}
							esp_1384 = esp_101;
							if ((eax_491->b000A & ~0x04) != 0x00)
								continue;
							if (eax_491->b000B == 0x2E)
							{
								esp_1389 = esp_101;
								if (eax_491->t000C == 0x00 || eax_491->t000C == 0x2E)
									continue;
							}
							byte dl_538 = (int8) ((esp_480->t0034 | esp_480->dw0038) == 0x00) & bl_503;
							word32 edx_854 = SEQ(edx_24_8_853, dl_538);
							if (dl_538 != 0x00 && eax_491->dw0000 != esp_480->dw0028)
							{
								ebx_475 = edx_854;
								continue;
							}
							esp_480->ptr0054 = &eax_491->b000B;
							esp_480->tFFFFFFFC.u0 = 0x0100;
							esp_480->dwFFFFFFF8 = esp_480->dw0024;
							esp_480->ptrFFFFFFF4 = &eax_491->b000B;
							esp_480->dwFFFFFFF0 = esp_480->dw0020;
							esp_480->dwFFFFFFEC = 0x03;
							esp_101 = (struct Eq_44897 *) ((char *) &esp_480->t000C + 4);
							esp_1385 = esp_101;
							if (__fxstatat64(gs, esp_480->dwFFFFFFEC, esp_480->dwFFFFFFF0, esp_480->ptrFFFFFFF4, esp_480->dwFFFFFFF8, esp_480->tFFFFFFFC) < 0x00)
								continue;
							esp_1386 = esp_101;
							if ((esp_480->dw008C & 0xF000) != 0x4000)
								continue;
							esp_1387 = esp_101;
							if ((esp_480->t0034 ^ esp_480->dw0080 | esp_480->t0030 ^ esp_480->dw007C) != 0x00)
								continue;
							esp_1388 = esp_101;
						} while ((esp_480->t002C ^ esp_480->dw00D4 | esp_480->dw00D8) != 0x00);
						esp_480->t0000 = esp_480->t0058;
						word32 edx_1349;
						word32 ecx_1348;
						Eq_2 eax_601 = strlen(esp_480->t0000, out ecx_1348, out edx_1349);
						Eq_2 ebx_609 = esp_480->t0060;
						Eq_2 ecx_610 = esp_480->t001C;
						esp_480->t0034 = eax_601;
						Eq_2 ebx_612 = ebx_609 - ecx_610;
						esp_480->t0030 = ebx_612;
						esp_101 = (struct Eq_44897 *) ((char *) &esp_480->t000C + 4);
						if (eax_601 >= ebx_612)
						{
							if (esp_480->dw0104 != 0x00)
							{
								gs->tFFFFFFE0.u0 = 0x22;
								edx.u0 = 0x22;
								goto l080617D4;
							}
							Eq_2 ebx_622 = esp_480->t0040;
							if (eax_601 >= ebx_622)
								ebx_622 = eax_601;
							Eq_2 eax_628 = ebx_622 * 0x02;
							esp_480->t002C = eax_628;
							esp_480->t000C = ebx_622;
							esp_480->t0008 = ebx_622;
							esp_480->t0004 = eax_628;
							esp_480->t0000 = ecx_610;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 esi_1356;
							word32 edi_1357;
							word32 edx_1354;
							word32 ebp_1355;
							Eq_2 eax_653 = __realloc(gs, stackArg0, stackArg4, dwArg04, out edx_1354, out ebp_1355, out esi_1356, out edi_1357);
							esp_101 = (struct Eq_44897 *) ((char *) &esp_480->t000C + 4);
							if (eax_653 == 0x00)
								goto l080619D4;
							Eq_2 ebx_662 = esp_480->t002C;
							Eq_2 ecx_663 = esp_480->t001C;
							esp_480->t001C = eax_653;
							word32 ecx_666 = ecx_663 + Mem664[esp_480 + 0x40:word32] - Mem664[esp_480 + 0x60:word32];
							word32 eax_670 = Mem664[esp_480 + 0x30:word32] + eax_653;
							esp_480->t000C = eax_653;
							esp_480->t0008 = ecx_666;
							esp_480->t0004 = eax_670;
							esp_480->t0000 = (word32) eax_653 + (ebx_662 - ecx_666);
							word32 edx_1367;
							word32 ecx_1366;
							esp_480->t0060 = memcpy(esp_480->t0000, esp_480->t0004, esp_480->t0008, out ecx_1366, out edx_1367);
							esp_480->t0040 = esp_480->t002C;
						}
						struct Eq_44897 * esp_694 = &esp_1384->dw0000 + 1;
						Eq_2 ebx_696 = esp_694[3];
						ptr32 ecx_699 = esp_694->dw0050;
						esp_694->dw001C = esp_694->dw005C;
						esp_694->tFFFFFFF8 = ebx_696;
						esp_694->tFFFFFFF4 = esp_694[6];
						Eq_2 ecx_701 = ecx_699 - ebx_696;
						esp_694->tFFFFFFF0 = ecx_701;
						esp_694->t0020 = ecx_701;
						word32 ecx_1350;
						word32 edx_1351;
						memcpy(esp_694->tFFFFFFF0, esp_694->tFFFFFFF4, esp_694->tFFFFFFF8, out ecx_1350, out edx_1351);
						Eq_2 ecx_721 = esp_694->t0020;
						word32 edx_722 = esp_694[7];
						*((word32) ecx_721 - 1) = 0x2F;
						word32 ecx_725 = esp_694->dw0058;
						esp_694->dw0050 = ecx_721 - 0x01;
						Eq_2 ebx_727 = esp_694->t0044;
						word32 eax_730 = esp_694->dw001C;
						ui32 edx_732 = edx_722 ^ ebx_727 | ecx_725 ^ esp_694->t0040;
						esp_694->t0020 = ebx_727;
						int8 al_740 = (int8) (esp_694->dw0034 != eax_730);
						esp_694[3] = (struct Eq_44897) esp_694->t0040;
						esp_101 = esp_694;
					} while (((int8) (edx_732 != 0x00) | al_740) != 0x00);
					esp_694->tFFFFFFF0 = eax_436;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					esp_101 = esp_694;
					if (closedir(gs, stackArg4) == 0x00)
					{
						ebx_252 = Mem750[esp_694 + 0x0C:word32] + Mem750[esp_694 + 0x30:word32];
						goto l0806174C;
					}
				}
			}
l080618A8:
			edi_161.u0 = ~0x1F;
			edx = gs->tFFFFFFE0;
			goto l080617E8;
		}
	}
l08061539:
	esp_101->dw0010 = 0x00;
	goto l08061541;
}

// 080619F0: Register (ptr32 Eq_226) __close_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 edxOut)
// Called from:
//      _nl_load_domain
//      _IO_file_close
//      _IO_file_close_mmap
//      _IO_file_open
//      _int_free
//      __sysconf
//      getcwd
//      get_nprocs
//      _dl_discover_osversion
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __alloc_dir
//      opendir
//      closedir
//      lose
//      open_verify.constprop.7
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_226 * __close_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & edxOut)
{
	struct Eq_226 * eax_10;
	ptr32 edx_26;
	gs->ptr0010();
	if (eax_10 > (struct Eq_226 *) ~0x0FFF)
	{
		ptr32 edx_17;
		struct Eq_226 * eax_16 = __syscall_error(eax_10, gs, out edx_17);
		edxOut = edx_17;
		return eax_16;
	}
	else
	{
		edxOut = edx_26;
		return eax_10;
	}
}

// 08061A20: void __fcntl64_nocancel_adjusted(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      __fcntl64_nocancel
void __fcntl64_nocancel_adjusted(struct Eq_9 * gs, word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	struct Eq_226 * eax_20;
	ui32 eax_9 = gs->dw0014;
	if (dwArg08 != 0x09)
	{
		gs->ptr0010();
		if (eax_20 <= (struct Eq_226 *) ~0x0FFF)
			goto l08061A58;
	}
	else
	{
		gs->ptr0010();
		if (eax_20 <= (struct Eq_226 *) ~0x0FFF)
			goto l08061A58;
	}
	word32 edx_121;
	__syscall_error(eax_20, gs, out edx_121);
l08061A58:
	if ((eax_9 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_123;
	word32 ecx_122;
	__stack_chk_fail(out ecx_122, out edx_123);
	__fcntl64_nocancel();
}

// 08061AB0: Register Eq_2 __fcntl64_nocancel()
// Called from:
//      check_one_fd
//      __fcntl64_nocancel_adjusted
//      __alloc_dir
//      __fdopendir
Eq_2 __fcntl64_nocancel()
{
	__fcntl64_nocancel_adjusted(gs, dwArg04, dwArg08, dwArg0C);
	return <invalid>;
}

// 08061AD0: Register (ptr32 Eq_226) __open_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      check_one_fd
//      _nl_load_domain
//      __libc_message
//      _IO_file_open
//      _int_free
//      __sysconf
//      get_nprocs
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      opendir
struct Eq_226 * __open_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	if (((byte) dwArg08 & 0x40) != 0x00 || (dwArg08 & 0x00410000) == 0x00410000)
		;
	ptr32 ecx_37;
	struct Eq_226 * eax_36;
	ptr32 edx_35;
	gs->ptr0010();
	if (eax_36 > (struct Eq_226 *) ~0x0FFF)
		eax_36 = __syscall_error(eax_36, gs, out edx_35);
	ecxOut = ecx_37;
	edxOut = edx_35;
	return eax_36;
}

// 08061B30: Register (ptr32 Eq_226) __openat64_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack word32 dwArg10)
// Called from:
//      getcwd
struct Eq_226 * __openat64_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, word32 dwArg10)
{
	byte al_12 = (byte) dwArg0C;
	byte ah_25 = SLICE(dwArg0C, byte, 8);
	word16 eax_16_16_37 = SLICE(dwArg0C, word16, 16);
	if ((al_12 & 0x40) != 0x00 || (dwArg0C & 0x00410000) == 0x00410000)
		;
	struct Eq_226 * eax_48;
	gs->ptr0010();
	if (eax_48 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_97;
		eax_48 = __syscall_error(eax_48, gs, out edx_97);
	}
	return eax_48;
}

// 08061BA0: Register (ptr32 Eq_226) __read_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_979 ecxOut)
// Called from:
//      _nl_load_domain
//      _IO_file_read
//      _int_free
//      __sysconf
//      next_line
//      _dl_discover_osversion
//      _nl_load_locale
//      _dl_process_pt_note
//      open_verify.constprop.7
//      _dl_map_object_from_fd.constprop.8
struct Eq_226 * __read_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_979 & ecxOut)
{
	struct Eq_226 * eax_12;
	gs->ptr0010();
	if (eax_12 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_47;
		struct Eq_226 * eax_20 = __syscall_error(eax_12, gs, out edx_47);
		ecxOut.u0 = <invalid>;
		return eax_20;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		return eax_12;
	}
}

// 08061BE0: Register (ptr32 Eq_226) __write_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack ptr32 dwArg08, Stack int32 dwArg0C)
// Called from:
//      _IO_new_file_write
//      _dl_start_profile
struct Eq_226 * __write_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 dwArg08, int32 dwArg0C)
{
	struct Eq_226 * eax_12;
	gs->ptr0010();
	if (eax_12 <= (struct Eq_226 *) ~0x0FFF)
		return eax_12;
	word32 edx_46;
	return __syscall_error(eax_12, gs, out edx_46);
}

// 08061C20: Register (ptr32 Eq_226) __getrlimit(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      __sysconf
//      __get_child_max
//      getdtablesize
struct Eq_226 * __getrlimit(struct Eq_9 * gs, word32 dwArg04, ptr32 dwArg08)
{
	struct Eq_226 * eax_11;
	gs->ptr0010();
	if (eax_11 <= (struct Eq_226 *) ~0x0FFF)
		return eax_11;
	word32 edx_44;
	return __syscall_error(eax_11, gs, out edx_44);
}

// 08061C50: Register Eq_46335 __sbrk(Register (ptr32 Eq_9) gs, Stack Eq_1961 dwArg04, Register out ptr32 edxOut)
// Called from:
//      __libc_setup_tls
//      __default_morecore
//      __tunables_init
Eq_46335 __sbrk(struct Eq_9 * gs, Eq_1961 dwArg04, ptr32 & edxOut)
{
	Eq_46335 ebx_105 = __curbrk;
	if (ebx_105 == 0x00 || __libc_multiple_libcs != 0x00)
	{
		if (brk(gs, 0x00, out edx) < null)
			goto l08061C9F;
		ebx_105 = __curbrk;
	}
	if (dwArg04 == 0x00)
		goto l08061CA4;
	if (dwArg04 > 0x00)
	{
		if (CONVERT(ebx_105 + dwArg04 <u 0x00, bool, int8) != 0x00)
		{
l08061C92:
			gs->tFFFFFFE0.u0 = 0x0C;
l08061C9F:
			ebx_105.u0 = ~0x00;
l08061CA4:
			edxOut = edx;
			return ebx_105;
		}
	}
	else if ((int8) (-dwArg04 > ebx_105) != 0x00)
		goto l08061C92;
	if (brk(gs, dwArg04 + ebx_105, out edx) >= 0x00)
	{
		edxOut = edx;
		return ebx_105;
	}
	goto l08061C9F;
}

// 08061D00: Register Eq_2 __getpagesize()
// Called from:
//      mmap_remap_check
//      getcwd
//      sysinfo_mempages
Eq_2 __getpagesize()
{
	Eq_2 eax_8 = _dl_pagesize;
	if (eax_8 != 0x00)
		return eax_8;
	word32 ecx_49;
	word32 edx_50;
	__assert_fail(out ecx_49, out edx_50);
	return getdtablesize(gs);
}

// 08061D40: Register Eq_2 getdtablesize(Register (ptr32 Eq_9) gs)
// Called from:
//      __getpagesize
Eq_2 getdtablesize(struct Eq_9 * gs)
{
	ui32 eax_7 = gs->dw0014;
	Eq_2 eax_27 = 0x0100;
	if (__getrlimit(gs, 0x07, fp - 0x18) >= 0x00)
		eax_27 = dwLoc18;
	if ((eax_7 ^ gs->dw0014) == 0x00)
		return eax_27;
	word32 edx_82;
	word32 ecx_81;
	__stack_chk_fail(out ecx_81, out edx_82);
	word32 ecx_83;
	word32 edx_84;
	return mmap(gs, dwLoc18, dwLoc14, eax_7, dwLoc0C, dwLoc08, dwLoc04, out ecx_83, out edx_84);
}

// 08061D90: Register (ptr32 Eq_226) mmap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack ui32 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Register out Eq_2 ecxOut, Register out Eq_2217 edxOut)
// Called from:
//      __assert_fail_base
//      _nl_load_domain
//      __libc_message
//      new_heap
//      _int_free
//      sysmalloc
//      getdtablesize
//      __gconv_load_cache
//      _nl_load_locale
//      _dl_map_object_from_fd.constprop.8
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_226 * mmap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ui32 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, union Eq_2 & ecxOut, union Eq_2217 & edxOut)
{
	struct Eq_226 * eax_25;
	Eq_2 ecx_18 = dwArg08;
	if ((dwArg18 & 0x0FFF) == 0x00)
	{
		Eq_2217 edx_33;
		gs->ptr0010();
		if (eax_25 <= (struct Eq_226 *) ~0x0FFF)
		{
			ecxOut = ecx_18;
			edxOut = edx_33;
			return eax_25;
		}
	}
	else
		eax_25 = (struct Eq_226 *) ~0x15;
	Eq_2217 edx_50;
	struct Eq_226 * eax_49 = __syscall_error(eax_25, gs, out edx_50);
	ecxOut = ecx_18;
	edxOut = edx_50;
	return eax_49;
}

// 08061DF0: Register (ptr32 Eq_226) mmap64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      decide_maybe_mmap
//      _nl_load_locale_from_archive
struct Eq_226 * mmap64(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C)
{
	struct Eq_226 * eax_33 = (struct Eq_226 *) ~0x15;
	if ((dwArg1C & ~0x0FFF | dwArg18 & 0x0FFF) == 0x00)
	{
		gs->ptr0010();
		if (eax_33 <= (struct Eq_226 *) ~0x0FFF)
			return eax_33;
	}
	word32 edx_115;
	return __syscall_error(eax_33, gs, out edx_115);
}

// 08061E80: Register (ptr32 Eq_226) __munmap(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_979 ecxOut, Register out ptr32 edxOut, Register out Eq_979 ebxOut)
// Called from:
//      __assert_fail_base
//      _nl_load_domain
//      __libc_message
//      _IO_file_close_mmap
//      mmap_remap_check
//      decide_maybe_mmap
//      new_heap
//      munmap_chunk
//      _int_free
//      __gconv_load_cache
//      _nl_load_locale
//      _nl_unload_locale
//      _nl_load_locale_from_archive
//      _dl_map_object_from_fd.constprop.8
//      _dl_start_profile
//      _dl_load_cache_lookup
//      _dl_unload_cache
//      _dl_unmap
//      _nl_unload_domain
//      free_mem
//      _nl_archive_subfreeres
struct Eq_226 * __munmap(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_979 & ecxOut, ptr32 & edxOut, union Eq_979 & ebxOut)
{
	ptr32 edx_11;
	struct Eq_226 * eax_13;
	gs->ptr0010();
	if (eax_13 >= (struct Eq_226 *) ~0x0FFE)
	{
		ptr32 edx_19;
		struct Eq_226 * eax_18 = __syscall_error(eax_13, gs, out edx_19);
		ecxOut.u0 = <invalid>;
		edxOut = edx_19;
		ebxOut.u0 = <invalid>;
		return eax_18;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_11;
		ebxOut.u0 = <invalid>;
		return eax_13;
	}
}

// 08061EB0: Register (ptr32 Eq_226) mprotect(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_979 ecxOut, Register out Eq_29368 edxOut)
// Called from:
//      new_heap
//      sysmalloc
//      _dl_map_object_from_fd.constprop.8
//      _dl_protect_relro
//      _dl_relocate_object
//      _dl_make_stack_executable
//      _dl_cet_open_check
struct Eq_226 * mprotect(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_979 & ecxOut, union Eq_29368 & edxOut)
{
	Eq_29368 edx_12;
	struct Eq_226 * eax_14;
	gs->ptr0010();
	if (eax_14 >= (struct Eq_226 *) ~0x0FFE)
	{
		Eq_29368 edx_21;
		struct Eq_226 * eax_20 = __syscall_error(eax_14, gs, out edx_21);
		ecxOut.u0 = <invalid>;
		edxOut = edx_21;
		return eax_20;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		edxOut = edx_12;
		return eax_14;
	}
}

// 08061EE0: Register Eq_2 __madvise(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack ui32 dwArg08, Stack word32 dwArg0C, Register out (ptr32 Eq_31309) edxOut)
// Called from:
//      _int_free
//      malloc_trim
Eq_2 __madvise(struct Eq_9 * gs, Eq_2 dwArg04, ui32 dwArg08, word32 dwArg0C, struct Eq_31309 & edxOut)
{
	struct Eq_31309 * edx_12;
	struct Eq_226 * eax_14;
	gs->ptr0010();
	if (eax_14 >= (struct Eq_226 *) ~0x0FFE)
	{
		struct Eq_31309 * edx_21;
		__syscall_error(eax_14, gs, out edx_21);
		edxOut = edx_21;
		return <invalid>;
	}
	else
	{
		edxOut = edx_12;
		return <invalid>;
	}
}

// 08061F10: Register Eq_2 trecurse(Register Eq_2 eax, Register word32 ecx, Register (ptr32 Eq_46509) edx, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      trecurse
//      twalk
Eq_2 trecurse(Eq_2 eax, word32 ecx, union Eq_46509 * edx, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_2 eax_22;
	eax_22 = eax;
	if ((*((word32) eax + 4) & ~0x01) == 0x00)
	{
		eax_22 = *((word32) eax + 8);
		if (eax_22 == 0x00)
		{
			ptr32 ecx_34;
			ptr32 edx_35;
			Eq_2 eax_36;
			edx();
			ecxOut = ecx_34;
			edxOut = edx_35;
			return eax_36;
		}
	}
	word32 ecx_62;
	word32 edx_63;
	edx();
	ui32 eax_66 = *((word32) eax + 4);
	ptr32 esp_67 = fp - 0x0C;
	Eq_2 eax_68 = eax_66 & ~0x01;
	if ((eax_66 & ~0x01) != 0x00)
	{
		eax_68 = trecurse(eax_66 & ~0x01, ecx + 0x01, edx, out ecx_62, out edx_63);
		esp_67 = fp - 0x08;
	}
	struct Eq_46541 * esp_80 = esp_67 - 0x04;
	esp_80->dwFFFFFFFC = ecx;
	esp_80->dwFFFFFFF8 = 0x01;
	esp_80->tFFFFFFF4 = eax;
	word32 ecx_106;
	word32 edx_107;
	edx();
	Eq_2 eax_108 = *((word32) eax + 8);
	if (eax_108 != 0x00)
		eax_108 = trecurse(eax_108, ecx + 0x01, edx, out ecx_106, out edx_107);
	ptr32 ecx_127;
	ptr32 edx_128;
	Eq_2 eax_129;
	edx();
	ecxOut = ecx_127;
	edxOut = edx_128;
	return eax_129;
}

// 08061F90: Register Eq_2 tdestroy_recurse(Register Eq_2 eax, Register (ptr32 code) edx, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      tdestroy_recurse
//      tdestroy
Eq_2 tdestroy_recurse(Eq_2 eax, <anonymous> * edx, struct Eq_9 * gs, ptr32 & edxOut)
{
	Eq_2 eax_28;
	<anonymous> * edx_24;
	ui32 eax_17 = *((word32) eax + 4);
	if ((eax_17 & ~0x01) == 0x00)
	{
		eax_28 = *((word32) eax + 8);
		edx_24 = edx;
		if (eax_28 == 0x00)
			goto l08061FB1;
	}
	else
	{
		tdestroy_recurse(eax_17 & ~0x01, edx, gs, out edx_24);
		eax_28 = *((word32) eax + 8);
		if (eax_28 == 0x00)
		{
l08061FB1:
			edx();
			ptr32 edx_70;
			word32 ecx_106;
			Eq_2 eax_68 = free(gs, dwLoc24, eax, out ecx_106, out edx_70);
			edxOut = edx_70;
			return eax_68;
		}
	}
	eax_28 = tdestroy_recurse(eax_28, edx, gs, out edx_24);
	goto l08061FB1;
}

// 08061FF0: Register Eq_2 maybe_split_for_insert.isra.0(Register ui32 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack int32 dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C, Register out Eq_2 edxOut)
// Called from:
//      __tsearch
Eq_2 maybe_split_for_insert.isra.0(ui32 eax, Eq_2 ecx, Eq_2 edx, int32 dwArg04, int32 dwArg08, word32 dwArg0C, union Eq_2 & edxOut)
{
	ui32 edi_19 = (eax & ~0x01)->dw0004;
	struct Eq_46637 * ebx_20 = (eax & ~0x01)->ptr0008;
	if (dwArg0C != 0x01)
	{
		if (ebx_20 == null || ((edi_19 & ~0x01) == 0x00 || ((ebx_20->b0004 & 0x01) == 0x00 || ((edi_19 & ~0x01)->b0004 & 0x01) == 0x00)))
			goto l080620D4;
		(eax & ~0x01)->dw0004 = edi_19 | 0x01;
	}
	else
	{
		(eax & ~0x01)->dw0004 = edi_19 | 0x01;
		if (ebx_20 == null)
			goto l0806204A;
	}
	ebx_20->b0004 &= ~0x01;
l0806204A:
	if ((edi_19 & ~0x01) != 0x00)
		(edi_19 & ~0x01)->dw0004 = (edi_19 & ~0x01)->dw0004 & ~0x01;
	if (edx != 0x00)
	{
		ui32 edx_70 = *edx;
		edx = edx_70 & ~0x01;
		ui32 ebp_72 = (edx_70 & ~0x01)->dw0004;
		if ((ebp_72 & 0x01) != 0x00)
		{
			edx = (word32) (int8) (dwArg08 > 0x00);
			ui32 edx_84 = *ecx;
			if ((int8) (dwArg04 > 0x00) != (byte) edx)
			{
				(edx_70 & ~0x01)->dw0004 = ebp_72 | 0x01;
				(edx_84 & ~0x01)->dw0004 = (edx_84 & ~0x01)->dw0004 | 0x01;
				(eax & ~0x01)->dw0004 = (eax & ~0x01)->dw0004 & ~0x01;
				if (dwArg04 >= 0x00)
				{
					(edx_70 & ~0x01)->dw0008 = edi_19 & ~0x01;
					(eax & ~0x01)->dw0004 = edx_70 & ~0x01;
					(edx_84 & ~0x01)->dw0004 = ebx_20 | (edx_84 & ~0x01)->dw0004 & 0x01;
					(eax & ~0x01)->dw0008 = edx_84 & ~0x01 | ebx_20 & 0x01;
				}
				else
				{
					(edx_70 & ~0x01)->dw0004 = ebx_20 | (edx_70 & ~0x01)->dw0004 & 0x01;
					(eax & ~0x01)->dw0008 = edx_70 & ~0x01 | ebx_20 & 0x01;
					(edx_84 & ~0x01)->dw0008 = edi_19 & ~0x01;
					(eax & ~0x01)->dw0004 = edx_84 & ~0x01;
				}
				ui32 edx_172 = *ecx;
				*ecx = eax & ~0x01 | edx_172 & 0x01;
				edx = edx_172 & 0x01;
			}
			else
			{
				*ecx = edx_84 & 0x01 | edx_70 & ~0x01;
				(edx_70 & ~0x01)->dw0004 = ebp_72 & ~0x01;
				(edx_84 & ~0x01)->dw0004 = (edx_84 & ~0x01)->dw0004 | 0x01;
				if (dwArg04 >= 0x00)
				{
					ui32 eax_120 = (edx_70 & ~0x01)->dw0004;
					(edx_84 & ~0x01)->dw0008 = eax_120 & ~0x01;
					(edx_70 & ~0x01)->dw0004 = edx_84 & ~0x01 | eax_120 & 0x01;
					ecx = eax_120 & ~0x01;
				}
				else
				{
					(edx_84 & ~0x01)->dw0004 = (edx_70 & ~0x01)->dw0008 | 0x01;
					(edx_70 & ~0x01)->dw0008 = edx_84 & ~0x01;
				}
			}
		}
	}
l080620D4:
	edxOut = edx;
	return ecx;
}

// 08062150: Register Eq_2 __tsearch(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __dcigettext
//      find_derivation
//      add_alias2.isra.1.part.2
//      __gconv_find_shlib
//      __add_to_environ
Eq_2 __tsearch(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 ebp_119 = dwArg08;
	if (dwArg08 != 0x00)
	{
		Eq_2 dwLoc30_212;
		int32 dwLoc2C_214;
		Eq_2 ebx_134;
		int32 esi_123;
		Eq_2 edi_104;
		ui32 ebx_200 = *dwArg08;
		if ((ebx_200 & ~0x01) != 0x00)
		{
			(ebx_200 & ~0x01)->dw0004 = (ebx_200 & ~0x01)->dw0004 & ~0x01;
			Eq_2 ecx_202 = 0x00;
			int32 dwLoc24_213 = 0x00;
			dwLoc2C_214 = 0x00;
			dwLoc30_212.u0 = 0x00;
			while (true)
			{
				ebx_134 = ebx_200 & ~0x01;
				if (ebx_134 == 0x00)
					break;
				int32 eax_70;
				dwArg0C();
				esi_123 = eax_70;
				if (eax_70 == 0x00)
					goto l08062284;
				ui32 eax_103;
				word32 edx_310;
				maybe_split_for_insert.isra.0(*ebp_119, ecx_202, dwLoc30_212, dwLoc2C_214, dwLoc24_213, 0x00, out edx_310);
				if (eax_70 < 0x00)
				{
					edi_104 = (word32) ebx_134 + 4;
					eax_103 = (ui32) *((word32) ebx_134 + 4);
				}
				else
				{
					eax_103 = (ui32) *((word32) ebx_134 + 8);
					edi_104 = (word32) ebx_134 + 8;
				}
				if ((eax_103 & ~0x01) == 0x00)
					goto l08062230;
				ebx_200 = (ui32) *edi_104;
				dwLoc2C_214 = eax_70;
				ecx_202 = dwLoc30_212;
				dwLoc30_212 = ebp_119;
				ebp_119 = edi_104;
				dwLoc24_213 = dwLoc2C_214;
			}
			esi_123 = dwLoc2C_214;
		}
		else
		{
			dwLoc30_212.u0 = 0x00;
			esi_123 = 0x00;
		}
		dwLoc2C_214 = esi_123;
		edi_104 = ebp_119;
l08062230:
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edi_317;
		word32 edx_313;
		word32 esi_316;
		word32 ebp_315;
		word32 ebx_314;
		Eq_2 eax_128 = __libc_malloc(gs, stackArg0, 0x0C, out ecx, out edx_313, out ebx_314, out ebp_315, out esi_316, out edi_317);
		edx = eax_128;
		ebx_134 = eax_128;
		if (eax_128 != 0x00)
		{
			*edi_104 = *edi_104 & 0x01 | eax_128;
			*((word32) eax_128 + 4) = 0x01;
			*eax_128 = dwArg04;
			*((word32) eax_128 + 8) = 0x00;
			if (edi_104 != ebp_119)
				ecx = maybe_split_for_insert.isra.0(*edi_104, dwLoc30_212, ebp_119, esi_123, dwLoc2C_214, 0x01, out edx);
l08062284:
			ecxOut = ecx;
			edxOut = edx;
			return ebx_134;
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	return 0x00;
}

// 080622B0: Register ui32 __tfind(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __dcigettext
//      find_derivation
//      __gconv_compare_alias
//      __gconv_find_transform
//      add_module.isra.0
//      __gconv_read_conf
//      __gconv_find_shlib
//      __add_to_environ
ui32 __tfind(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	ui32 ebp_36;
	Eq_2 ebx_17 = dwArg08;
	if (dwArg08 != 0x00)
	{
		while (true)
		{
			ui32 ebx_25 = *ebx_17;
			if ((ebx_25 & ~0x01) == 0x00)
				break;
			int32 eax_42;
			word32 edx_43;
			dwArg0C();
			ebp_36 = ebx_25 & ~0x01;
			if (eax_42 == 0x00)
				return ebp_36;
			Eq_2 edx_49 = (ebx_25 & ~0x01) + 0x04;
			ebx_17 = (ebx_25 & ~0x01) + 0x08;
			if (eax_42 < 0x00)
				ebx_17 = edx_49;
		}
	}
	ebp_36 = 0x00;
	return ebp_36;
}

// 08062300: void __tdelete(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_46509) dwArg08, Stack (ptr32 code) dwArg0C)
void __tdelete(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_46509 * dwArg08, <anonymous> * dwArg0C)
{
	struct Eq_47041 * esp_19 = fp - 0x5C;
	ui32 eax_27 = gs->dw0014;
	if (fp - 0x5C != fp - 0x5C)
	{
		do
		{
			esp_19 -= 0x1000;
			esp_19->dw0FFC = esp_19->dw0FFC;
		} while (esp_19 != fp - 0x5C);
	}
	struct Eq_47051 * esp_142 = esp_19 - 0xB0;
	esp_142->dw00AC = esp_142->dw00AC;
	word32 dwLoc38_1102 = esp_142 + 0x0F & ~0x0F;
	if (dwArg08 != null)
	{
		ui32 ebx_58 = *dwArg08;
		if ((ebx_58 & ~0x01) != 0x00)
		{
			union Eq_2 * eax_63 = ebx_58 & ~0x01;
			ui32 esi_128 = 0x00;
			ui32 dwLoc30_1091 = 0x28;
			union Eq_46509 * edx_68 = dwArg08;
			do
			{
				struct Eq_47092 * esp_70 = esp_142 - (struct Eq_47093 *) 0x08;
				esp_70->tFFFFFFFC = *eax_63;
				esp_70->tFFFFFFF8 = dwArg04;
				int32 eax_89;
				word32 ecx_91;
				dwArg0C();
				esp_142 = esp_70 + 0x08;
				if (eax_89 == 0x00)
				{
					Eq_2 dwLoc48_956;
					ui32 eax_99 = *edx_68;
					ui32 ecx_104 = (eax_99 & ~0x01)->dw0004;
					struct Eq_47121 * edx_109 = ecx_104 & ~0x01;
					if ((eax_99 & ~0x01)->dw0008 != 0x00 && (ecx_104 & ~0x01) != 0x00)
					{
						union Eq_46509 * ecx_125 = edx_68;
						union Eq_46509 * edi_127 = (eax_99 & ~0x01) + 0x08;
						while (true)
						{
							Eq_2 edx_129 = esi_128 * 0x04;
							if (dwLoc30_1091 == esi_128)
							{
								ui32 v24_134 = dwLoc30_1091 + 0x14;
								ui32 eax_137 = v24_134 * 0x04 + 0x1B;
								dwLoc30_1091 = v24_134;
								struct Eq_47051 * ebx_144 = esp_142 - (eax_137 & ~0x0FFF);
								while (esp_142 != ebx_144)
								{
									esp_142 -= (struct Eq_47314 *) 0x1000;
									esp_142->dw0FFC = esp_142->dw0FFC;
								}
								if ((eax_137 & ~0x0F & 0x0FFF) != 0x00)
								{
									esp_142 -= eax_137 & ~0x0F & 0x0FFF;
									Mem171[esp_142 - 0x04 + ((eax_137 & ~0x0F) & 0x0FFF):word32] = Mem162[esp_142 - 0x04 + ((eax_137 & ~0x0F) & 0x0FFF):word32];
								}
								struct Eq_47323 * esp_176 = esp_142 - (struct Eq_47324 *) 0x04;
								esp_176->tFFFFFFFC = edx_129;
								esp_176->tFFFFFFF8 = dwLoc38_1102;
								Mem197[esp_176 + -0x0C:word32] = esp_142 + 0x0F & ~0x0F;
								esp_142 = esp_176 + 0x04;
								word32 ecx_1556;
								word32 edx_1557;
								dwLoc38_1102 = memcpy(esp_176->tFFFFFFF4, esp_176->tFFFFFFF8, esp_176->tFFFFFFFC, out ecx_1556, out edx_1557);
							}
							*((word32) dwLoc38_1102 + esi_128 * 0x04) = ecx_125;
							++esi_128;
							ui32 eax_228 = *edi_127;
							if (((eax_228 & ~0x01)->dw0004 & ~0x01) == 0x00)
								break;
							ecx_125 = edi_127;
							edi_127 = (eax_228 & ~0x01) + 0x04;
						}
						dwLoc48_956 = eax_228 & ~0x01;
						goto l080628BE;
					}
					dwLoc48_956 = eax_99 & ~0x01;
					if ((ecx_104 & ~0x01) == 0x00)
					{
l080628BE:
						edx_109 = (struct Eq_47121 *) *((word32) dwLoc48_956 + 8);
					}
					if (esi_128 == 0x00)
						*edx_68 = eax_99 & 0x01 | edx_109;
					else
					{
						ui32 eax_250 = *(dwLoc38_1102 - 0x04)[esi_128];
						if (dwLoc48_956 != (eax_250 & ~0x01)->t0008)
							(eax_250 & ~0x01)->dw0004 = (eax_250 & ~0x01)->dw0004 & 0x01 | edx_109;
						else
							(eax_250 & ~0x01)->ptr0008 = edx_109;
					}
					if ((eax_99 & ~0x01) != dwLoc48_956)
						*(eax_99 & ~0x01) = (word32) *dwLoc48_956;
					if ((*((word32) dwLoc48_956 + 4) & 0x01) == 0x00)
					{
						ui32 eax_301;
						if (esi_128 != 0x00)
						{
							ui32 esi_295 = esi_128;
							do
							{
								if (edx_109 != null)
								{
									eax_301 = edx_109->dw0004;
									if (((byte) eax_301 & 0x01) != 0x00)
										goto l0806273C;
								}
								ui32 eax_308 = esi_295 + 0x3FFFFFFF;
								union Eq_46509 * eax_314 = *((word32) dwLoc38_1102 + eax_308 * 0x04);
								ui32 eax_316 = *eax_314;
								ui32 eax_320 = (eax_316 & ~0x01)->dw0004;
								union Eq_46509 * dwLoc34_1007 = eax_314;
								struct Eq_47453 * edi_322 = eax_320 & ~0x01;
								if ((eax_320 & ~0x01) != edx_109)
								{
									ui32 edx_502 = (eax_320 & ~0x01)->dw0004;
									struct Eq_47493 * dwLoc30_1028 = edx_502 & ~0x01;
									struct Eq_47496 * ecx_506 = (eax_320 & ~0x01)->ptr0008;
									if (((byte) edx_502 & 0x01) != 0x00)
									{
										(eax_320 & ~0x01)->dw0004 = edx_502 & ~0x01;
										(eax_316 & ~0x01)->dw0004 = ecx_506 | 0x01;
										(eax_320 & ~0x01)->dw0008 = eax_316 & ~0x01;
										*eax_314 = eax_316 & 0x01 | eax_320 & ~0x01;
										union Eq_46509 * eax_524 = (eax_320 & ~0x01) + 0x08;
										*((word32) dwLoc38_1102 + (eax_308 * 0x04 + 4)) = eax_524;
										edx_502 = (ecx_506 & ~0x01)->dw0004;
										++esi_295;
										dwLoc34_1007 = eax_524;
										edi_322 = ecx_506 & ~0x01;
										ecx_506 = (ecx_506 & ~0x01)->ptr0008;
										dwLoc30_1028 = edx_502 & ~0x01;
									}
									ui32 esi_595;
									if (ecx_506 != null)
									{
										ui32 eax_542 = ecx_506->dw0004;
										if (((byte) eax_542 & 0x01) == 0x00)
											goto l080626D0;
										ui32 esi_599 = (eax_316 & ~0x01)->dw0004;
										esi_595 = esi_599 & 0x01;
										if (dwLoc30_1028 == null || (dwLoc30_1028->b0004 & 0x01) == 0x00)
										{
											ui32 eax_652 = eax_542 & ~0x01;
											if ((esi_599 & 0x01) != 0x00)
												eax_652 = eax_542 | 0x01;
											ecx_506->dw0004 = eax_652;
											(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & 0x01 | ecx_506->dw0008;
											ui32 eax_672 = ecx_506->dw0004;
											edi_322->dw0008 = eax_672 & ~0x01;
											ecx_506->dw0004 = eax_672 & 0x01 | edi_322;
											ui32 eax_682 = *dwLoc34_1007;
											ecx_506->dw0008 = eax_316 & ~0x01;
											*dwLoc34_1007 = eax_682 & 0x01 | ecx_506;
											(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
											goto l080626B5;
										}
									}
									else
									{
l080626D0:
										if (dwLoc30_1028 == null || (dwLoc30_1028->b0004 & 0x01) == 0x00)
										{
											edi_322->ptr0004 = edx_502 | 0x01;
											goto l0806272E;
										}
										esi_595 = (eax_316 & ~0x01)->dw0004 & 0x01;
									}
									struct Eq_47493 * edx_612 = edx_502 | 0x01;
									if (esi_595 == 0x00)
										edx_612 = dwLoc30_1028;
									edi_322->ptr0004 = edx_612;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
									struct Eq_47493 * eax_630 = edi_322->ptr0004;
									(eax_630 & ~0x01)->dw0004 = (eax_630 & ~0x01)->dw0004 & ~0x01;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & 0x01 | ecx_506;
									ui32 eax_642 = *dwLoc34_1007;
									edi_322->dw0008 = eax_316 & ~0x01;
									*dwLoc34_1007 = eax_642 & 0x01 | edi_322;
									goto l080626B5;
								}
								struct Eq_47471 * edi_326 = (eax_316 & ~0x01)->ptr0008;
								struct Eq_47476 * ecx_327 = edi_326->ptr0004;
								struct Eq_47476 * eax_329 = ecx_327 & ~0x01;
								if (((byte) ecx_327 & 0x01) != 0x00)
								{
									edi_326->ptr0004 = ecx_327 & ~0x01;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 | 0x01;
									struct Eq_47476 * eax_340 = edi_326->ptr0004;
									(eax_316 & ~0x01)->dw0008 = eax_340 & ~0x01;
									edi_326->ptr0004 = eax_340 & 0x01 | eax_316 & ~0x01;
									*eax_314 = eax_316 & 0x01 | edi_326;
									*((word32) dwLoc38_1102 + (eax_308 * 0x04 + 4)) = &edi_326->ptr0004;
									ecx_327 = (eax_340 & ~0x01)->ptr0004;
									++esi_295;
									dwLoc34_1007 = (union Eq_46509 *) &edi_326->ptr0004;
									edi_326 = eax_340 & ~0x01;
									eax_329 = ecx_327 & ~0x01;
								}
								ui32 dwLoc30_1012;
								struct Eq_47750 * dwLoc3C_1010;
								if (eax_329 != null)
								{
									ui32 edx_367 = eax_329->dw0004;
									if (((byte) edx_367 & 0x01) == 0x00)
										goto l08062818;
									ui32 ecx_402 = (eax_316 & ~0x01)->dw0004;
									struct Eq_47750 * esi_403 = edi_326->ptr0008;
									dwLoc30_1012 = ecx_402 & 0x01;
									if (esi_403 != null)
									{
										dwLoc3C_1010 = esi_403;
										if ((esi_403->t0004 & 0x01) != 0x00)
										{
l08062834:
											if (dwLoc30_1012 != 0x00)
												eax_329 = ecx_327 | 0x01;
											edi_326->ptr0004 = eax_329;
											(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
											dwLoc3C_1010->t0004 &= ~0x01;
											struct Eq_47476 * eax_440 = edi_326->ptr0004;
											(eax_316 & ~0x01)->dw0008 = eax_440 & ~0x01;
											edi_326->ptr0004 = eax_440 & 0x01 | eax_316 & ~0x01;
											*dwLoc34_1007 = edi_326 | *dwLoc34_1007 & 0x01;
											goto l080626B5;
										}
									}
									ui32 ecx_463;
									if ((ecx_402 & 0x01) != 0x00)
										ecx_463 = edx_367 | 0x01;
									else
										ecx_463 = edx_367 & ~0x01;
									eax_329->dw0004 = ecx_463;
									(eax_316 & ~0x01)->dw0008 = edx_367 & ~0x01;
									ui32 ecx_484 = *dwLoc34_1007;
									edi_326->ptr0004 = edi_326->ptr0004 & 0x01 | eax_329->ptr0008;
									ui32 edx_488 = eax_329->dw0004;
									eax_329->ptr0008 = edi_326;
									eax_329->dw0004 = edx_488 & 0x01 | eax_316 & ~0x01;
									*dwLoc34_1007 = eax_329 | ecx_484 & 0x01;
									(eax_316 & ~0x01)->dw0004 = (eax_316 & ~0x01)->dw0004 & ~0x01;
									goto l080626B5;
								}
l08062818:
								struct Eq_47750 * edx_375 = edi_326->ptr0008;
								if (edx_375 != null)
								{
									dwLoc3C_1010 = edx_375;
									if ((edx_375->t0004 & 0x01) == 0x00)
										goto l08062880;
									dwLoc30_1012 = (eax_316 & ~0x01)->dw0004 & 0x01;
									goto l08062834;
								}
l08062880:
								edi_326->ptr0004 = ecx_327 | 0x01;
l0806272E:
								edx_109 = eax_316 & ~0x01;
								--esi_295;
							} while (esi_295 != 0x00);
							goto l08062739;
						}
						if (edx_109 != null)
						{
l08062739:
							eax_301 = edx_109->dw0004;
l0806273C:
							edx_109->dw0004 = eax_301 & ~0x01;
						}
					}
l080626B5:
					struct Eq_47411 * esp_719 = esp_142 - (struct Eq_47412 *) 0x0C;
					esp_719->tFFFFFFFC = dwLoc48_956;
					word32 edx_1559;
					word32 ecx_1558;
					free(gs, esp_719->tFFFFFFF8, esp_719->tFFFFFFFC, out ecx_1558, out edx_1559);
					goto l080623DC;
				}
				Eq_2 ecx_774 = esi_128 * 0x04;
				if (dwLoc30_1091 == esi_128)
				{
					ui32 v20_777 = dwLoc30_1091 + 0x14;
					ui32 eax_780 = v20_777 * 0x04 + 0x1B;
					dwLoc30_1091 = v20_777;
					word32 ebx_786 = esp_70 + 0x08 - (eax_780 & ~0x0FFF);
					if (esp_70 + 0x08 != ebx_786)
					{
						do
						{
							esp_142 -= (struct Eq_47205 *) 0x1000;
							esp_142->dw0FFC = esp_142->dw0FFC;
						} while (esp_142 != ebx_786);
					}
					if ((eax_780 & ~0x0F & 0x0FFF) != 0x00)
					{
						esp_142 -= eax_780 & ~0x0F & 0x0FFF;
						Mem810[esp_142 - 0x04 + ((eax_780 & ~0x0F) & 0x0FFF):word32] = Mem808[esp_142 - 0x04 + ((eax_780 & ~0x0F) & 0x0FFF):word32];
					}
					struct Eq_47214 * esp_815 = esp_142 - (struct Eq_47215 *) 0x04;
					esp_815->tFFFFFFFC = ecx_774;
					esp_815->tFFFFFFF8 = dwLoc38_1102;
					Mem837[esp_815 + -0x0C:word32] = esp_142 + 0x0F & ~0x0F;
					esp_142 = esp_815 + 0x04;
					word32 ecx_1554;
					word32 edx_1555;
					dwLoc38_1102 = memcpy(esp_815->tFFFFFFF4, esp_815->tFFFFFFF8, esp_815->tFFFFFFFC, out ecx_1554, out edx_1555);
				}
				ui32 ebx_856 = *edx_68;
				*((word32) dwLoc38_1102 + esi_128 * 0x04) = edx_68;
				++esi_128;
				if (eax_89 < 0x00)
				{
					ui32 eax_877 = (ebx_856 & ~0x01)->dw0004;
					edx_68 = (ebx_856 & ~0x01) + 0x04;
					eax_63 = eax_877 & ~0x01;
					if ((eax_877 & ~0x01) == 0x00)
						break;
					continue;
				}
				eax_63 = (ebx_856 & ~0x01)->ptr0008;
				edx_68 = (ebx_856 & ~0x01) + 0x08;
			} while (eax_63 != null);
		}
	}
l080623DC:
	if ((eax_27 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_1550;
	word32 edx_1551;
	__stack_chk_fail(out ecx_1550, out edx_1551);
	word32 ecx_1552;
	word32 edx_1553;
	twalk(dwArg04, dwArg08, out ecx_1552, out edx_1553);
}

// 08062920: Register Eq_2 twalk(Stack Eq_2 dwArg04, Stack (ptr32 Eq_46509) dwArg08, Register out ptr32 ecxOut, Register out (ptr32 Eq_46509) edxOut)
// Called from:
//      __tdelete
//      __gconv_find_shlib
//      __gconv_release_shlib
Eq_2 twalk(Eq_2 dwArg04, union Eq_46509 * dwArg08, ptr32 & ecxOut, union Eq_46509 & edxOut)
{
	if (dwArg04 == 0x00 || dwArg08 == null)
	{
		ecxOut = ecx;
		edxOut = dwArg08;
		return dwArg04;
	}
	else
	{
		ptr32 ecx_17;
		union Eq_46509 * edx_18;
		Eq_2 eax_16 = trecurse(dwArg04, 0x00, dwArg08, out ecx_17, out edx_18);
		ecxOut = ecx_17;
		edxOut = edx_18;
		return eax_16;
	}
}

// 08062940: void tdestroy(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 code) dwArg08)
// Called from:
//      __dl_iterate_phdr
//      free_mem
//      free_mem
//      free_mem
void tdestroy(struct Eq_9 * gs, Eq_2 dwArg04, <anonymous> * dwArg08)
{
	if (dwArg04 == 0x00)
		return;
	word32 edx_32;
	tdestroy_recurse(dwArg04, dwArg08, gs, out edx_32);
}

// 08062960: Register Eq_2 next_line(Register Eq_2 eax, Register (ptr32 Eq_2) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      get_nprocs
Eq_2 next_line(Eq_2 eax, union Eq_2 * ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebp_105 = *ecx;
	Eq_2 ebx_103 = *dwArg04;
	Eq_2 edi_30 = ebx_103 - ebp_105;
	Eq_2 eax_115 = __memchr(ebp_105, 0x0A, edi_30);
	if (eax_115 == 0x00)
	{
		if (ebp_105 == edx || ebx_103 != dwArg08)
			goto l0806299F;
		word32 edx_384;
		memmove(edx, ebp_105, edi_30, out edx_384);
		Mem76[dwArg04 + 0x00:word32] = Mem61[dwArg04 + 0x00:word32] + edx - Mem61[ecx + 0x00:word32];
		*ecx = (union Eq_2 *) edx;
		Eq_2 eax_78 = *dwArg04;
		word32 ecx_385;
		Eq_2 eax_89 = __read_nocancel(gs, eax, eax_78, dwArg08 - eax_78, out ecx_385);
		if (eax_89 < 0x00)
			return 0x00;
		word32 eax_102 = eax_89 + Mem87[dwArg04 + 0x00:word32];
		*dwArg04 = eax_102;
		ebp_105 = *ecx;
		ebx_103 = eax_102;
		eax_115 = __memchr(ebp_105, 0x0A, eax_102 - ebp_105);
		if (eax_115 == 0x00)
		{
			if (eax_102 == dwArg08)
			{
				ui32 eax_131 = dwArg08 - edx;
				int32 eax_135 = eax_131 * 0x03 + 0x03;
				if (eax_131 * 0x03 >= 0x00)
					eax_135 = eax_131 * 0x03;
				Eq_2 ebp_141 = (word32) edx + (eax_135 >> 0x02);
				Eq_2 eax_145 = dwArg08 - ebp_141;
				do
				{
					*dwArg04 = ebp_141;
					word32 ecx_386;
					Eq_2 eax_163 = __read_nocancel(gs, eax, ebp_141, eax_145, out ecx_386);
					if (eax_163 < 0x00)
						return 0x00;
					Eq_2 edi_175 = *dwArg04;
					eax_115 = __memchr(edi_175, 0x0A, eax_163);
					*edi_175 = 0x0A;
					word32 edx_194 = Mem191[dwArg04 + 0x00:word32] + eax_163;
					*dwArg04 = edx_194;
					if (eax_115 != 0x00)
					{
						ebp_105 = *ecx;
						goto l0806299C;
					}
				} while (edx_194 == dwArg08);
				ebx_103 = edx_194;
				ebp_105 = *ecx;
			}
l0806299F:
			*ecx = (union Eq_2 *) ebx_103;
			Eq_2 eax_217 = *dwArg04;
			if (eax_217 < ebx_103)
			{
				word32 edx_383;
				word32 ecx_382;
				__assert_fail(out ecx_382, out edx_383);
			}
			else
			{
				if (eax_217 == ebp_105)
					return 0x00;
				return ebp_105;
			}
		}
	}
l0806299C:
	ebx_103 = (word32) eax_115 + 1;
	goto l0806299F;
}

// 08062B00: Register Eq_48154 sysinfo_mempages(Register Eq_48154 eax, Register Eq_48155 edx)
// Called from:
//      next_line
//      __get_phys_pages
//      __get_avphys_pages
Eq_48154 sysinfo_mempages(Eq_48154 eax, Eq_48155 edx)
{
	Eq_2 eax_22 = __getpagesize();
	Eq_48155 ebx_19 = edx;
	Eq_2 ecx_26 = eax_22;
	if (eax_22 > 0x01 && edx > 0x01)
	{
		do
		{
			ebx_19 >>= 0x01;
			ecx_26 >>= 0x01;
		} while (ebx_19 > 0x01 && ecx_26 > 0x01);
	}
	Eq_48154 eax_44 = eax *s ebx_19;
	if (ecx_26 > 0x01)
	{
		do
		{
			ecx_26 >>= 0x01;
			eax_44 >>= 0x01;
		} while (ecx_26 != 0x01);
	}
	return eax_44;
}

// 08062B50: Register Eq_2 get_nprocs(Register (ptr32 Eq_9) gs)
// Called from:
//      arena_get2.part.5
//      get_nprocs_conf
Eq_2 get_nprocs(struct Eq_9 * gs)
{
	Eq_2 ebx_136;
	ui32 eax_22 = gs->dw0014;
	word32 eax_29 = time(gs, 0x00);
	if (eax_29 == timestamp.11438)
	{
		ebx_136 = cached_result.11437;
		if (ebx_136 >= 0x00)
			goto l08062D99;
	}
	ui32 eax_59 = (0x00 - (__libc_alloca_cutoff(gs, 0x2000) < 0x01) & ~0x1DFF) + 0x2000;
	struct Eq_48214 * esp_53 = fp - 0x4C;
	struct Eq_48214 * esi_63 = fp - 0x4C - (eax_59 + 0x10 & ~0x0FFF);
	if (fp - 0x4C != esi_63)
	{
		do
		{
			esp_53 -= 0x1000;
			esp_53->dw0FFC = esp_53->dw0FFC;
		} while (esp_53 != esi_63);
	}
	int32 edx_78 = eax_59 + 0x10 & 0x0FFF;
	if (edx_78 != 0x00)
	{
		esp_53 -= edx_78;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_53 - 0x04)[edx_78 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_53 - 0x04)[edx_78 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_48251 * esp_91 = esp_53 - 0x08;
	esp_91->tFFFFFFFC.u0 = 0x00080000;
	Eq_48258 edx_90 = (char *) esp_53 + 0x0F;
	esp_91->tFFFFFFF8.u0 = 0x080A40E4;
	Eq_2 eax_99 = eax_59 + (edx_90 & ~0x0F);
	word32 ecx_835;
	word32 edx_836;
	Eq_2 eax_117 = __open_nocancel(gs, esp_91->tFFFFFFF8, esp_91->tFFFFFFFC, esp_91->t0000, out ecx_835, out edx_836);
	if (eax_117 == ~0x00)
	{
l08062CE9:
		struct Eq_48287 * esp_282 = esp_53 - 0x08;
		esp_282->tFFFFFFFC.u0 = 0x00080000;
		esp_282->tFFFFFFF8.u0 = 0x080A4119;
		word32 edx_838;
		word32 ecx_837;
		Eq_2 eax_293 = __open_nocancel(gs, esp_282->tFFFFFFF8, esp_282->tFFFFFFFC, esp_282->t0000, out ecx_837, out edx_838);
		Eq_2 dwLoc3C_612 = eax_293;
		if (eax_293 != ~0x00)
		{
			ebx_136.u0 = 0x00;
			while (true)
			{
				struct Eq_48505 * esp_399 = esp_53 - 0x08;
				esp_399->tFFFFFFFC = eax_99;
				esp_399->ptrFFFFFFF8 = fp - 0x28;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 eax_417 = next_line(eax_293, fp - 44, edx_90 & ~0x0F, gs, stackArg4, stackArg8);
				bool v36_563 = eax_417 > 0x00;
				if (eax_417 == 0x00)
					break;
				cu8 * edi_425 = &g_b80A4150;
				word32 ecx_426 = 0x03;
				Eq_2 esi_427 = eax_417;
				while (ecx_426 != 0x00)
				{
					v36_563 = *esi_859 > *edi_860;
					esi_427 = (word32) esi_859 + 1;
					edi_425 = edi_860 + 1;
					--ecx_426;
					esi_859 = esi_427;
					edi_860 = edi_425;
					if (*esi_859 == *edi_860)
						break;
				}
				if ((int8) v36_563 - (*esi_859 < *edi_860) != 0x00)
					break;
				ebx_136 = (word64) ebx_136.u0 + ((int32) (*((word32) eax_417 + 3)) < 0x3A);
			}
		}
		else
		{
			esp_282->tFFFFFFFC.u0 = 0x00080000;
			esp_282->tFFFFFFF8.u0 = 0x080A4124;
			word32 edx_851;
			word32 ecx_850;
			Eq_2 eax_313 = __open_nocancel(gs, esp_282->tFFFFFFF8, esp_282->tFFFFFFFC, esp_282->t0000, out ecx_850, out edx_851);
			ebx_136.u0 = 0x02;
			dwLoc3C_612 = eax_313;
			if (eax_313 == ~0x00)
				goto l08062D87;
			ebx_136.u0 = 0x00;
			while (true)
			{
				struct Eq_48530 * esp_335 = esp_53 - 0x08;
				esp_335->tFFFFFFFC = eax_99;
				esp_335->ptrFFFFFFF8 = fp - 0x28;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 eax_353 = next_line(eax_313, fp - 44, edx_90 & ~0x0F, gs, stackArg4, stackArg8);
				Eq_2 esi_358 = eax_353;
				bool v32_559 = eax_353 > 0x00;
				if (eax_353 == 0x00)
					break;
				cu8 * edi_362 = &g_b80A4132;
				word32 ecx_363 = 0x09;
				while (ecx_363 != 0x00)
				{
					v32_559 = *esi_857 > *edi_858;
					esi_358 = (word32) esi_857 + 1;
					edi_362 = edi_858 + 1;
					--ecx_363;
					esi_857 = esi_358;
					edi_858 = edi_362;
					if (*esi_857 == *edi_858)
						break;
				}
				ebx_136 = (word32) ebx_136 + ((int32) ((int8) v32_559 - (*esi_857 < *edi_858)) < 0x01);
			}
		}
		struct Eq_48560 * esp_462 = esp_53 - 0x0C;
		esp_462->tFFFFFFFC = dwLoc3C_612;
		word32 edx_856;
		__close_nocancel(gs, esp_462->tFFFFFFFC, out edx_856);
l08062D87:
		cached_result.11437 = ebx_136;
		timestamp.11438 = eax_29;
l08062D99:
		if ((eax_22 ^ gs->dw0014) == 0x00)
			return ebx_136;
		word32 ecx_848;
		word32 edx_849;
		__stack_chk_fail(out ecx_848, out edx_849);
		return get_nprocs_conf(gs);
	}
	esp_91->tFFFFFFFC = eax_99;
	esp_91->tFFFFFFF8 = fp - 0x28;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	Eq_2 eax_147 = next_line(eax, fp - 44, edx_90 & ~0x0F, gs, stackArg4, stackArg8);
	ebx_136.u0 = 0x00;
	Eq_2 edi_152 = eax_147;
	if (eax_147 != 0x00)
	{
l08062C60:
		struct Eq_48360 * esp_163 = esp_53 - 0x04;
		esp_163->tFFFFFFFC.u0 = 0x0A;
		esp_163->tFFFFFFF8 = fp - 0x24;
		esp_163->tFFFFFFF4 = edi_152;
		word32 edx_847;
		word32 ecx_846;
		Eq_10008 eax_175 = __strtoul(gs, esp_163->tFFFFFFF4, esp_163->tFFFFFFF8, esp_163->tFFFFFFFC, out ecx_846, out edx_847);
		if (dwLoc24 != edi_152)
		{
			Eq_10008 eax_199;
			eax_199 = eax_175;
			if (*dwLoc24 != 0x2D)
			{
l08062C7F:
				Eq_2 esi_235 = (word32) eax_199 + 1 + (ebx_136 - eax_175);
				Eq_2 edx_237 = dwLoc24;
				ebx_136 = esi_235;
				if (dwLoc24 < eax_99)
				{
					Eq_153925 edi_242[] = gs->ptrFFFFFFF8;
					do
					{
						if ((edi_242[(int32) *edx_237].b0001 & 0x20) == 0x00)
						{
							edi_152 = edx_237;
							goto l08062C60;
						}
						edx_237 = (word32) edx_237 + 1;
					} while (edx_237 != eax_99);
				}
				esp_163->tFFFFFFF4 = eax_117;
				word32 edx_845;
				__close_nocancel(gs, esp_163->tFFFFFFF4, out edx_845);
				if (esi_235 > 0x00)
					goto l08062D87;
				goto l08062CE9;
			}
			esp_163->tFFFFFFFC.u0 = 0x0A;
			esp_163->tFFFFFFF8 = fp - 0x24;
			esp_163->tFFFFFFF4 = (word32) dwLoc24 + 1;
			word32 ecx_843;
			word32 edx_844;
			eax_199 = __strtoul(gs, esp_163->tFFFFFFF4, esp_163->tFFFFFFF8, esp_163->tFFFFFFFC, out ecx_843, out edx_844);
			if (dwLoc24 != (word32) dwLoc24 + 1)
				goto l08062C7F;
		}
	}
	struct Eq_48338 * esp_211 = esp_53 - 0x0C;
	esp_211->tFFFFFFFC = eax_117;
	word32 edx_842;
	__close_nocancel(gs, esp_211->tFFFFFFFC, out edx_842);
	goto l08062CE9;
}

// 08062E90: Register int32 get_nprocs_conf(Register (ptr32 Eq_9) gs)
// Called from:
//      get_nprocs
int32 get_nprocs_conf(struct Eq_9 * gs)
{
	ui32 eax_21 = gs->dw0014;
	int32 ebp_125 = 0x00;
	Eq_2 eax_29 = opendir(gs, 134889788);
	if (eax_29 != 0x00)
	{
l08062EE0:
		word32 ecx_297;
		struct Eq_226 * eax_135 = readdir64(gs, eax_29, out ecx_297);
		while (eax_135 != null)
		{
			bool v21_210 = eax_135->b0012 > 0x04;
			if (eax_135->b0012 != 0x04)
				goto l08062EE0;
			cu8 * edi_70 = &g_b80A4150;
			cu8 * esi_71 = &eax_135->b0012 + 1;
			word32 ecx_72 = 0x03;
			while (ecx_72 != 0x00)
			{
				v21_210 = *esi_303 > *edi_304;
				esi_71 = esi_303 + 1;
				edi_70 = edi_304 + 1;
				--ecx_72;
				esi_303 = esi_71;
				edi_304 = edi_70;
				if (*esi_303 == *edi_304)
					break;
			}
			if ((int8) v21_210 - (eax_135->b0012 < 0x04) != 0x00)
				goto l08062EE0;
			Eq_2 esi_98 = &eax_135->b0012 + 4;
			word32 edx_299;
			word32 ecx_298;
			if (__strtoul(gs, esi_98, fp - 0x24, 0x0A, out ecx_298, out edx_299) == ~0x00 || esi_98 == dwLoc24)
				goto l08062EE0;
			ebp_125 = (int32) ((bool) (*dwLoc24 < 0x01) + ebp_125);
			word32 ecx_300;
			eax_135 = readdir64(gs, eax_29, out ecx_300);
		}
		closedir(gs, eax_29);
	}
	else
		ebp_125 = get_nprocs(gs);
	if ((eax_21 ^ gs->dw0014) == 0x00)
		return ebp_125;
	word32 edx_302;
	word32 ecx_301;
	__stack_chk_fail(out ecx_301, out edx_302);
	return __get_phys_pages(eax_29, gs);
}

// 08062F90: Register Eq_48154 __get_phys_pages(Register Eq_2 ebx, Register (ptr32 Eq_9) gs)
// Called from:
//      get_nprocs_conf
Eq_48154 __get_phys_pages(Eq_2 ebx, struct Eq_9 * gs)
{
	Eq_2 ebx_17 = __sysinfo(ebx, gs, fp - 0x50);
	if ((dwLoc0C ^ gs->dw0014) == 0x00)
		return sysinfo_mempages(eax, edx);
	word32 edx_70;
	word32 ecx_69;
	__stack_chk_fail(out ecx_69, out edx_70);
	return __get_avphys_pages(ebx_17, gs);
}

// 08062FE0: Register Eq_48154 __get_avphys_pages(Register Eq_2 ebx, Register (ptr32 Eq_9) gs)
// Called from:
//      __get_phys_pages
Eq_48154 __get_avphys_pages(Eq_2 ebx, struct Eq_9 * gs)
{
	__sysinfo(ebx, gs, fp - 0x50);
	if ((dwLoc0C ^ gs->dw0014) == 0x00)
		return sysinfo_mempages(eax, edx);
	word32 edx_65;
	word32 ecx_64;
	__stack_chk_fail(out ecx_64, out edx_65);
	return __getclktck();
}

// 08063030: Register word32 __getclktck()
// Called from:
//      __get_avphys_pages
word32 __getclktck()
{
	word32 eax_13 = _dl_clktck;
	if (eax_13 == 0x00)
		eax_13 = 100;
	return eax_13;
}

// 08063060: void __init_misc(Stack (ptr32 Eq_2) dwArg08)
// Called from:
//      __libc_init_first
void __init_misc(union Eq_2 * dwArg08)
{
	if (dwArg08 != null)
	{
		Eq_2 ebx_19 = *dwArg08;
		if (ebx_19 != 0x00)
		{
			struct Eq_48850 * eax_29 = rindex(ebx_19, 0x2F);
			if (eax_29 != null)
				ebx_19 = &eax_29->bFFFFFFFE + 3;
			program_invocation_short_name = ebx_19;
			__progname_full = *dwArg08;
		}
	}
}

// 080630B0: Register (ptr32 Eq_226) __mremap(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack word32 dwArg14, Register out ptr32 edxOut)
// Called from:
//      mmap_remap_check
//      mremap_chunk
struct Eq_226 * __mremap(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, word32 dwArg14, ptr32 & edxOut)
{
	ptr32 edx_20;
	struct Eq_226 * eax_22;
	gs->ptr0010();
	if (eax_22 >= (struct Eq_226 *) ~0x0FFE)
	{
		ptr32 edx_33;
		struct Eq_226 * eax_32 = __syscall_error(eax_22, gs, out edx_33);
		edxOut = edx_33;
		return eax_32;
	}
	else
	{
		edxOut = edx_20;
		return eax_22;
	}
}

// 080630F0: Register Eq_2 __sysinfo(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04)
// Called from:
//      __get_phys_pages
//      __get_avphys_pages
Eq_2 __sysinfo(Eq_2 ebx, struct Eq_9 * gs, ptr32 dwArg04)
{
	struct Eq_226 * eax_11;
	gs->ptr0010();
	if (eax_11 < (struct Eq_226 *) ~0x0FFE)
		return;
	word32 edx_35;
	__syscall_error(eax_11, gs, out edx_35);
	return;
}

// 08063120: void __chk_fail()
// Called from:
//      __memmove_chk
//      __mempcpy_chk
//      __memcpy_chk
void __chk_fail()
{
	__fortify_fail();
}

// 08063140: Register word32 __stack_chk_fail(Register out Eq_979 ecxOut, Register out Eq_979 edxOut)
// Called from:
//      _nl_find_msg
//      __dcigettext
//      _nl_find_domain
//      _nl_load_domain
//      read_alias_file
//      __gettextparse
//      __gettext_extract_plural
//      qsort_r
//      locked_vfxprintf
//      adjust_wide_data
//      _IO_wfile_underflow
//      _IO_wfile_seekoff
//      _IO_wfile_underflow_mmap
//      _IO_wdo_write
//      vasprintf
//      __libc_message
//      mmap_remap_check
//      decide_maybe_mmap
//      _IO_new_file_seekoff
//      _IO_file_fopen
//      _IO_un_link.part.2
//      _IO_link_in
//      _IO_flush_all_lockp
//      _IO_cleanup
//      _flushlbf
//      ptmalloc_init
//      _int_free
//      realloc_check
//      mallinfo
//      __malloc_stats
//      malloc_info
//      two_way_long_needle
//      strstr
//      __wcsmbs_getfct
//      __wcsmbs_load_conv
//      __mbsrtowcs_l
//      __sysconf_check_spec
//      __sysconf
//      __get_child_max
//      lseek64
//      getcwd
//      __fcntl64_nocancel_adjusted
//      getdtablesize
//      __tdelete
//      get_nprocs
//      get_nprocs_conf
//      __get_phys_pages
//      __get_avphys_pages
//      __chk_fail
//      __gconv_open
//      find_derivation
//      __gconv_compare_alias
//      __gconv_find_transform
//      add_module.isra.0
//      __gconv_get_path
//      __gconv_read_conf
//      __gconv_transform_internal_ucs4
//      __gconv_transform_ucs4_internal
//      __gconv_transform_internal_ucs4le
//      __gconv_transform_ucs4le_internal
//      __gconv_transform_ascii_internal
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_utf8_internal
//      __gconv_transform_ucs2_internal
//      __gconv_transform_internal_ucs2
//      __gconv_transform_ucs2reverse_internal
//      __gconv_transform_internal_ucs2reverse
//      __gconv_transliterate
//      find_module
//      __gconv_load_cache
//      __gconv_compare_alias_cache
//      __gconv_lookup_cache
//      setlocale
//      _nl_find_locale
//      _nl_load_locale
//      _nl_load_locale_from_archive
//      __setfpucw
//      raise
//      __libc_sigaction
//      sigprocmask
//      _quicksort
//      __add_to_environ
//      _i18n_number_rewrite
//      printf_positional
//      vfprintf
//      buffered_vfprintf
//      _i18n_number_rewrite
//      __printf_fp_l
//      __printf_fphex
//      _i18n_number_rewrite
//      printf_positional
//      __vfwprintf
//      buffered_vfprintf
//      _IO_file_doallocate
//      _IO_padn
//      _IO_wpadn
//      do_in
//      do_unshift
//      do_out
//      do_length
//      _IO_fwide
//      strerror_r
//      two_way_long_needle
//      __memmem
//      __cache_sysconf
//      btowc
//      wcrtomb
//      __wcsrtombs
//      opendir
//      __getdents
//      __fdopendir
//      __libc_lseek
//      __isatty
//      tcgetattr
//      __readonly_area
//      dlerror_run
//      __libc_dlsym
//      __libc_dlvsym
//      do_dlsym_private
//      __libc_dlsym_private
//      __libc_dlopen_mode
//      _dl_catch_exception
//      _dl_catch_error
//      __mpn_mul
//      __mpn_mul_n
//      _itoa
//      _fitoa_word
//      _fitoa
//      _itowa
//      __dlerror
//      __dlinfo
//      __dlmopen
//      profil
//      __dlopen
//      __dlsym
//      __dlvsym
//      _dl_vsym
//      _dl_sym
//      __dl_iterate_phdr
word32 __stack_chk_fail(union Eq_979 & ecxOut, union Eq_979 & edxOut)
{
	__fortify_fail_abort(0x00);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	word32 eax_20 = __fortify_fail_abort(stackArg4);
	ecxOut.u0 = <invalid>;
	edxOut.u0 = <invalid>;
	return eax_20;
}

// 08063170: Register word32 __fortify_fail_abort(Stack Eq_2 bArg04)
// Called from:
//      __stack_chk_fail
//      __fortify_fail
word32 __fortify_fail_abort(Eq_2 bArg04)
{
	word32 esi_23 = (word32) bArg04;
	while (true)
	{
		ui32 edx_41;
		if ((byte) esi_23 == 0x00)
			edx_41 = 0x01;
		else
		{
			*__libc_argv == 0x00;
			edx_41 = 0x03;
		}
		__libc_message(gs, edx_41, 0x080A418F);
	}
}

// 080631E0: void __fortify_fail()
// Called from:
//      __chk_fail
void __fortify_fail()
{
	__fortify_fail_abort(0x01);
}

// 08063200: void _dl_debug_state()
// Called from:
//      __fortify_fail
//      lose
//      _dl_map_object_from_fd.constprop.8
//      dl_open_worker
//      _dl_close_worker
void _dl_debug_state()
{
}

// 08063210: Register (ptr32 Eq_48925) _dl_debug_initialize(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __libc_start_main
//      _dl_map_object_from_fd.constprop.8
//      _dl_open
//      dl_open_worker
//      _dl_close_worker
struct Eq_48925 * _dl_debug_initialize(Eq_2 dwArg04, Eq_2 dwArg08)
{
	struct Eq_48925 * eax_17;
	Eq_2 ebx_13 = dwArg04;
	if (dwArg08 != 0x00)
	{
		eax_17 = dwArg08 *s 0x4C + 0x080CEA38;
		if (eax_17->dw0004 != 0x00)
		{
l08063241:
			if (dwArg04 == 0x00)
				return eax_17;
			eax_17->dw0000 = 0x01;
l0806324B:
			eax_17->t0010 = ebx_13;
			eax_17->dw0004 = *((char *) &g_t80CEA00 + dwArg08 * 0x4C);
			eax_17->ptr0008 = 0x08063200;
			return eax_17;
		}
	}
	else
	{
		eax_17 = &g_t80CFEE8;
		if (g_dw80CFEEC != 0x00)
			goto l08063241;
	}
	eax_17->dw0000 = 0x01;
	if (dwArg04 == 0x00)
		ebx_13 = g_t80CFEF8;
	goto l0806324B;
}

// 080632A0: Register Eq_48974 do_tunable_update_val(Register (ptr32 Eq_48975) eax, Register Eq_2 edx, Register out Eq_2 edxOut)
// Called from:
//      tunable_initialize
//      __tunable_set_val
Eq_48974 do_tunable_update_val(struct Eq_48975 * eax, Eq_2 edx, union Eq_2 & edxOut)
{
	Eq_48974 ecx_6 = eax->t0004;
	if (ecx_6 == 0x03)
	{
		eax->t0018 = edx;
		edxOut = edx;
		return ecx_6;
	}
	Eq_48974 ecx_24;
	Eq_2 ebx_14 = *edx;
	Eq_2 edx_15 = *((word32) edx + 4);
	if (ecx_6 != 0x01 && ecx_6 == 0x00)
	{
		ecx_24 = edx_15 - eax->dw000C - (ebx_14 < eax->t0008);
		if (ecx_24 < 0x00)
			goto l080632D5;
		ecx_24 = eax->dw0014 - edx_15 - (eax->t0010 < ebx_14);
		if (ecx_24 >= 0x00)
		{
l080632CB:
			eax->t0018 = ebx_14;
			eax->t001C = edx_15;
			eax->b0020 = 0x01;
			goto l080632D5;
		}
	}
	else
	{
		ecx_24 = edx_15 - eax->dw000C - (ebx_14 < eax->t0008);
		if (ecx_24 < 0x00)
			goto l080632D5;
		ecx_24 = eax->dw0014 - edx_15 - (eax->t0010 < ebx_14);
		if (ecx_24 >= 0x00)
			goto l080632CB;
	}
l080632D5:
	edxOut = edx_15;
	return ecx_24;
}

// 08063310: Register word32 tunable_initialize(Register (ptr32 Eq_48975) eax, Register Eq_2 edx, Register out ptr32 edxOut)
// Called from:
//      __tunables_init
word32 tunable_initialize(struct Eq_48975 * eax, Eq_2 edx, ptr32 & edxOut)
{
	if (eax->t0004 != 0x03)
	{
		_dl_strtoul(edx, null);
		ptr32 edx_33;
		word32 ecx_32 = do_tunable_update_val(eax, fp - 0x14, out edx_33);
		edxOut = edx_33;
		return ecx_32;
	}
	else
	{
		eax->b0020 = 0x01;
		ptr32 edx_45;
		word32 ecx_44 = do_tunable_update_val(eax, edx, out edx_45);
		edxOut = edx_45;
		return ecx_44;
	}
}

// 08063360: void __tunable_set_val(Stack int32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _dl_important_hwcaps
void __tunable_set_val(int32 dwArg04, Eq_2 dwArg08)
{
	struct Eq_48975 * eax_9 = 0x080CE6C0 + dwArg04 *s 44;
	word32 edx_19;
	do_tunable_update_val(eax_9, dwArg08, out edx_19);
}

// 08063390: Register word32 __tunables_init(Register (ptr16 Eq_49099) gs, Register out ptr32 edxOut)
// Called from:
//      __libc_start_main
word32 __tunables_init(struct Eq_49099 * gs, ptr32 & edxOut)
{
	if (*(union Eq_4933 *) 0x080CDDAC != 0x00)
	{
		__syscall(0x80);
		g_dw80CE2A8 = 0x02;
	}
}

// 080638D0: void __tunable_get_val(Stack int32 dwArg04, Stack (ptr32 Eq_29834) dwArg08, Stack (ptr32 code) dwArg0C)
// Called from:
//      __libc_start_main
//      ptmalloc_init
//      _dl_important_hwcaps
//      _dl_load_cache_lookup
void __tunable_get_val(int32 dwArg04, struct Eq_29834 * dwArg08, <anonymous> * dwArg0C)
{
	struct Eq_49111 * edi_22 = 0x080CE6C0 + dwArg04 *s 44;
	word32 edx_23 = edi_22->dw0004;
	if (edx_23 != 0x01)
	{
		if (edx_23 != 0x00)
			dwArg08->dw0000 = edi_22->dw0018;
		else
			dwArg08->dw0000 = edi_22->dw0018;
	}
	else
	{
		word32 edi_27 = edi_22->dw0018;
		dwArg08->dw0004 = edi_22->dw001C;
		dwArg08->dw0000 = edi_27;
	}
	if ((dwArg04 *s 44 - 0x06A0)->b80CE000 == 0x00 || dwArg0C == null)
		return;
	dwArg0C();
}

// 08063960: void _dl_sysinfo_int80()
void _dl_sysinfo_int80()
{
	__syscall(0x80);
}

// 08063970: Register (ptr32 code) _dl_aux_init(Stack (ptr32 Eq_49164) dwArg04)
// Called from:
//      __libc_start_main
<anonymous> * _dl_aux_init(struct Eq_49164 * dwArg04)
{
	_dl_auxv = dwArg04;
	word32 eax_104 = dwArg04->dw0000;
	if (eax_104 != 0x00)
	{
		struct Eq_49164 * edx_101 = dwArg04;
		do
		{
			uint32 eax_98 = eax_104 - 0x03;
			if (eax_98 <= 0x1E)
			{
				<anonymous> * edi_286 = g_a80A4500[eax_98 * 0x04] + 0x080CE000;
				edi_286();
				return edi_286;
			}
			++edx_101;
			eax_104 = edx_101->dw0000;
		} while (eax_104 != 0x00);
	}
	return edi;
}

// 08063E50: Register Eq_2 _dl_non_dynamic_init(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_init_first
Eq_2 _dl_non_dynamic_init(struct Eq_9 * gs)
{
	word32 edi_1860;
	word32 esi_1859;
	struct Eq_49197 * ebx_25;
	ebx_25->t0C0C = _dl_get_origin(gs, dwLoc3C, out ebx_25, out esi_1859, out edi_1860);
	ebx_25->t0BB4 = _dl_phdr;
	ebx_25->t0BBC = _dl_phnum;
	Eq_2 eax_49 = getenv((char *) ebx_25 - 169953);
	uint32 edx_57 = 0x00;
	if (eax_49 != 0x00)
		edx_57 = (uint32) (int8) (*eax_49 != 0x00);
	_dl_verbose = edx_57;
	if (_dl_sysinfo_dso != 0x00)
	{
		Eq_2 dwLoc44_1243 = 0x00;
		Eq_2 eax_96 = _dl_new_object(gs, (char *) ebx_25 - 105991, (char *) ebx_25 - 105991, 0x01, 0x00, 0x00);
		ptr32 esp_102 = fp - 0x38;
		if (eax_96 != 0x00)
		{
			ptr32 esp_170;
			Eq_2 ebp_107 = _dl_sysinfo_dso;
			word32 edi_110 = (word32) *((word32) ebp_107 + 44);
			word32 eax_111 = Mem92[ebp_107 + 0x1C:word32] + ebp_107;
			((word32) eax_96 + 348)->u4 = (word16) edi_110;
			*((word32) eax_96 + 340) = eax_111;
			word32 ecx_108 = 0x00;
			if (edi_110 != 0x00)
			{
				do
				{
					word32 edx_120 = eax_111->dw0000;
					if (edx_120 != 0x02)
					{
						if (edx_120 != 0x01)
						{
							if (edx_120 == 0x07)
							{
								word32 ecx_1878;
								word32 edx_1879;
								__assert_fail(out ecx_1878, out edx_1879);
								Eq_2 esp_165 = <invalid>;
								esp_170 = (word32) esp_165 - 4;
								goto l080645B5;
							}
						}
						else
						{
							Eq_49325 edx_127 = eax_111->dw0008;
							if (*eax_96 == 0x00)
								*eax_96 = edx_127;
							Eq_2 edx_133 = (word32) edx_127 + eax_111->dw0014;
							if (edx_133 >= *((word32) eax_96 + 436))
								*((word32) eax_96 + 436) = edx_133;
							if ((eax_111->t0018 & 0x01) != 0x00 && edx_133 >= *((word32) eax_96 + 440))
								*((word32) eax_96 + 440) = edx_133;
						}
						++ecx_108;
						++eax_111;
						if (ecx_108 != edi_110)
							continue;
						break;
					}
					*((word32) eax_96 + 8) = eax_111->dw0008;
					++eax_111;
					((word32) eax_96 + 350)->u4 = (word16) (eax_111->dwFFFFFFF4 >> 0x03);
					++ecx_108;
				} while (ecx_108 != edi_110);
			}
			*((word32) eax_96 + 432) = ebp_107;
			Eq_49325 ebp_202 = ebp_107 - *eax_96;
			Mem205[eax_96 + 0x01B4:word32] = Mem201[eax_96 + 0x01B4:word32] + ebp_202;
			Mem207[eax_96 + 440:word32] = Mem205[eax_96 + 440:word32] + ebp_202;
			word32 edx_208 = ebp_202 + Mem207[eax_96 + 0x08:word32];
			*eax_96 = ebp_202;
			*((word32) eax_96 + 8) = edx_208;
			if (edx_208 != 0x00)
			{
				uint32 eax_213 = *edx_208;
				Eq_2 edi_1439 = (word32) eax_96 + 32;
				while (eax_213 != 0x00)
				{
					if (eax_213 > 0x22)
					{
						if (0x6FFFFFFF - eax_213 > 0x0F)
						{
							int32 ecx_235 = eax_213 * 0x02;
							if (ecx_235 >> 0x01 > ~0x03)
								*((word32) eax_96 + (~(ecx_235 >> 0x01) * 0x04 + 0x00EC)) = edx_208;
							else if (0x6FFFFDFF - eax_213 <= 11)
								*((word32) eax_96 + (-eax_213 * 0x04 - 0x4000070C)) = edx_208;
							else if (0x6FFFFEFF - eax_213 <= 0x0A)
								*((word32) eax_96 + (-eax_213 * 0x04 - 0x400002DC)) = edx_208;
							goto l080644AC;
						}
						eax_213 = 0x70000022 - eax_213;
					}
					*((word32) eax_96 + (eax_213 * 0x04 + 32)) = edx_208;
l080644AC:
					edx_208 = (word32) edx_208 + 8;
					eax_213 = (uint32) *edx_208;
				}
				if (ebp_202 != 0x00)
				{
					Eq_2 edx_278 = *((word32) eax_96 + 48);
					ui32 eax_279 = 0x00;
					if (edx_278 != 0x00)
					{
						ebx_25->dwFFFFFD60 = (word32) *edx_278;
						Mem296[ebx_25 + -668:word32] = Mem292[edx_278 + 0x04:word32] + ebp_202;
						*((word32) eax_96 + 48) = ebx_25 - 0x02A0;
						eax_279 = 0x01;
					}
					struct Eq_49445 * edx_302 = *((word32) eax_96 + 44);
					if (edx_302 != null)
					{
						struct Eq_49445 * ecx_309 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						ecx_309->dw0000 = edx_302->dw0000;
						edi_1439 = Mem311[edx_302 + 0x04:word32] + ebp_202;
						ecx_309->t0004 = edi_1439;
						*((word32) eax_96 + 44) = ecx_309;
						++eax_279;
					}
					Eq_2 edx_320 = *((word32) eax_96 + 52);
					if (edx_320 != 0x00)
					{
						Eq_2 ecx_327 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						*ecx_327 = *edx_320;
						edi_1439 = Mem329[edx_320 + 0x04:word32] + ebp_202;
						*((word32) ecx_327 + 4) = edi_1439;
						*((word32) eax_96 + 52) = ecx_327;
						++eax_279;
					}
					Eq_2 edx_338 = *((word32) eax_96 + 56);
					if (edx_338 != 0x00)
					{
						Eq_2 ecx_345 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						*ecx_345 = *edx_338;
						edi_1439 = Mem347[edx_338 + 0x04:word32] + ebp_202;
						*((word32) ecx_345 + 4) = edi_1439;
						*((word32) eax_96 + 56) = ecx_345;
						++eax_279;
					}
					Eq_2 edx_356 = *((word32) eax_96 + 60);
					if (edx_356 != 0x00)
					{
						Eq_2 ecx_363 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						*ecx_363 = *edx_356;
						edi_1439 = Mem365[edx_356 + 0x04:word32] + ebp_202;
						*((word32) ecx_363 + 4) = edi_1439;
						*((word32) eax_96 + 60) = ecx_363;
						++eax_279;
					}
					Eq_2 edx_374 = *((word32) eax_96 + 100);
					if (edx_374 != 0x00)
					{
						Eq_2 ecx_381 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						*ecx_381 = *edx_374;
						edi_1439 = Mem383[edx_374 + 0x04:word32] + ebp_202;
						*((word32) ecx_381 + 4) = edi_1439;
						*((word32) eax_96 + 100) = ecx_381;
						++eax_279;
					}
					struct Eq_50034 * edx_392 = *((word32) eax_96 + 0x007C);
					if (edx_392 != null)
					{
						struct Eq_50034 * ecx_399 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						ecx_399->t0000 = edx_392->t0000;
						edi_1439 = Mem401[edx_392 + 0x04:word32] + ebp_202;
						ecx_399->t0004 = edi_1439;
						*((word32) eax_96 + 0x007C) = ecx_399;
						++eax_279;
					}
					Eq_2 edx_410 = *((word32) eax_96 + 232);
					if (edx_410 != 0x00)
					{
						Eq_2 ecx_417 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						*ecx_417 = *edx_410;
						edi_1439 = Mem419[edx_410 + 0x04:word32] + ebp_202;
						*((word32) ecx_417 + 4) = edi_1439;
						*((word32) eax_96 + 232) = ecx_417;
						++eax_279;
					}
					Eq_2 edx_428 = *((word32) eax_96 + 336);
					if (edx_428 != 0x00)
					{
						edi_1439 = *edx_428;
						Eq_2 ecx_435 = ebx_25 - 0x02A0 + eax_279 * 0x08;
						Mem438[ecx_435 + 0x04:word32] = ebp_202 + Mem427[edx_428 + 0x04:word32];
						*ecx_435 = edi_1439;
						*((word32) eax_96 + 336) = ecx_435;
						if (eax_279 == 0x08)
						{
l080645ED:
							struct Eq_50307 * esp_720 = esp_102 - 4;
							esp_720->ptr0000 = (char *) ebx_25 - 169516;
							esp_720->dwFFFFFFFC = 115;
							esp_720->ptrFFFFFFF8 = (char *) ebx_25 - 169911;
							esp_720->ptrFFFFFFF4 = (char *) ebx_25 - 169892;
							word32 edx_1881;
							word32 ecx_1880;
							__assert_fail(out ecx_1880, out edx_1881);
							Eq_2 esp_732 = <invalid>;
							esp_102 = (word32) esp_732 - 4;
							goto l08064609;
						}
					}
				}
				Eq_22842 eax_445 = *((word32) eax_96 + 112);
				if (eax_445 != 0x00)
				{
					word32 eax_449 = *((word32) eax_445 + 4);
					if (eax_449 != 0x11 && eax_449 != 0x07)
					{
						word32 edx_1864;
						word32 ecx_1863;
						__assert_fail(out ecx_1863, out edx_1864);
						Eq_2 esp_711 = <invalid>;
						esp_102 = (word32) esp_711 - 4;
						goto l080645ED;
					}
				}
				if (*((word32) eax_96 + 60) != 0x00 && *((word32) (*((word32) eax_96 + 0x0044)) + 4) != 0x0C)
					goto l08064628;
				if (*((word32) eax_96 + 100) != 0x00 && *((word32) (*((word32) eax_96 + 0x006C)) + 4) != 0x08)
				{
l08064609:
					struct Eq_49757 * esp_741 = esp_102 - 4;
					esp_741->ptr0000 = (char *) ebx_25 - 169516;
					esp_741->dwFFFFFFFC = 0x87;
					esp_741->ptrFFFFFFF8 = (char *) ebx_25 - 169911;
					esp_741->ptrFFFFFFF4 = (char *) ebx_25 - 0x0002969C;
					word32 edx_1868;
					word32 ecx_1867;
					__assert_fail(out ecx_1867, out edx_1868);
					Eq_2 esp_753 = <invalid>;
					esp_102 = (word32) esp_753 - 4;
l08064628:
					struct Eq_49715 * esp_762 = esp_102 - 4;
					esp_762->ptr0000 = (char *) ebx_25 - 169516;
					esp_762->dwFFFFFFFC = 131;
					esp_762->ptrFFFFFFF8 = (char *) ebx_25 - 169911;
					esp_762->ptrFFFFFFF4 = (char *) ebx_25 - 169680;
					word32 edx_1866;
					word32 ecx_1865;
					__assert_fail(out ecx_1865, out edx_1866);
					_dl_get_dl_main_map();
					return edi_1439;
				}
				Eq_2 eax_474 = *((word32) eax_96 + 0x0098);
				if (eax_474 != 0x00)
				{
					ui32 edx_478 = *((word32) eax_474 + 4);
					*((word32) eax_96 + 524) = edx_478;
					byte dl_480 = (byte) edx_478;
					if ((dl_480 & 0x02) != 0x00)
						*((word32) eax_96 + 96) = eax_474;
					if ((dl_480 & 0x04) != 0x00)
						*((word32) eax_96 + 0x0078) = eax_474;
					if ((edx_478 & 0x08) != 0x00)
						*((word32) eax_96 + 0x0080) = eax_474;
				}
				Eq_2 eax_507 = *((word32) eax_96 + 188);
				if (eax_507 != 0x00)
				{
					Eq_49940 eax_511 = *((word32) eax_507 + 4);
					*((word32) eax_96 + 520) = eax_511;
					Eq_49940 al_570 = (byte) eax_511;
					if ((_dl_debug_mask & 0x40) != 0x00 && (eax_511 & ~0x08E9) != 0x00)
					{
						word32 edx_1870;
						word32 ecx_1869;
						_dl_debug_printf(out ecx_1869, out edx_1870);
						dwLoc44_1243 = eax_511 & ~0x08E9;
						al_570 = *((word32) eax_96 + 520);
					}
					if ((al_570 & 0x01) != 0x00)
						*((word32) eax_96 + 0x0080) = *((word32) eax_96 + 188);
				}
				if (*((word32) eax_96 + 0x0094) != 0x00)
					((word32) eax_96 + 92)->u0 = 0x00;
			}
			word32 edi_1862;
			word32 ebp_1861;
			Eq_2 esi_601;
			ebx_25 = _dl_setup_hash(eax_96, dwLoc44_1243, out ebp_1861, out esi_601, out edi_1862);
			struct Eq_49389 * eax_606 = *((word32) esi_601 + 468);
			*((word32) esi_601 + 408) |= 0x04;
			*((word32) esi_601 + 0x0200) = 0x01;
			eax_606->dw0004 = 0x01;
			eax_606->ptr0000 = (word32) esi_601 + 20;
			Eq_2 eax_615 = *((word32) esi_601 + 88);
			if (eax_615 != 0x00)
			{
				word32 ecx_1873;
				Eq_2 ebp_663;
				Eq_2 edi_666;
				word32 edx_1875;
				word32 edx_1874;
				word32 eax_662 = __libc_malloc(gs, 0x00, strlen(Mem614[eax_615 + 0x04:word32] + Mem614[Mem614[esi_601 + 0x34:word32] + 0x04:word32], out ecx_1873, out edx_1874) + 0x01, out ecx_108, out edx_1875, out ebx_25, out ebp_663, out esi_601, out edi_666);
				esp_170 = fp - 0x38;
				if (eax_662 == 0x00)
				{
l080645B5:
					struct Eq_50117 * esp_680 = esp_170 - 4;
					esp_680->dw0000 = ecx_108;
					esp_680->dwFFFFFFFC = ecx_108;
					esp_680->ptrFFFFFFF8 = (char *) ebx_25 - 169866;
					esp_680->tFFFFFFF4.u0 = 0x02;
					_dl_dprintf();
					esp_680->tFFFFFFF4.u0 = 0x7F;
					_exit(gs, esp_680->tFFFFFFF4);
				}
				word32 ecx_1876;
				word32 edx_1877;
				Eq_2 eax_797 = memcpy(eax_662, edi_666, ebp_663, out ecx_1876, out edx_1877);
				Eq_2 edx_805 = *((word32) esi_601 + 28);
				*((word32) esi_601 + 4) = eax_797;
				*edx_805 = eax_797;
			}
			_dl_add_to_namespace_list(esi_601, 0x00);
			ebx_25->dw09C0 = 0x01;
			_dl_sysinfo_map = esi_601;
			if (ebx_25->ptr09E0 == (char *) ebx_25 - 0x0006A6A0)
				Mem838[ebx_25 + 0x09E0:word32] = Mem829[esi_601 + 0x00:word32] + Mem829[Mem829[0x080CFF44:word32] + 0x18:word32];
		}
	}
	getenv((char *) ebx_25 - 0x0002977B);
	struct Eq_49249 * ebx_858 = _dl_init_paths(gs);
	_dl_init_all_dirs = _dl_all_dirs;
	Eq_2 eax_875 = getenv((char *) ebx_858 - 0x0002976B);
	uint32 edx_883 = 0x01;
	if (eax_875 != 0x00)
		edx_883 = (uint32) (int8) (*eax_875 == 0x00);
	_dl_lazy = edx_883;
	Eq_2 eax_903 = getenv((char *) ebx_858 - 0x0002975F);
	uint32 edx_911 = 0x00;
	if (eax_903 != 0x00)
		edx_911 = (uint32) (int8) (*eax_903 != 0x00);
	_dl_bind_not = edx_911;
	Eq_2 eax_931 = getenv((char *) ebx_858 - 169811);
	uint32 edx_939 = 0x01;
	if (eax_931 != 0x00)
		edx_939 = (uint32) (int8) (*eax_931 == 0x00);
	Eq_4933 edx_973;
	_dl_dynamic_weak = edx_939;
	Eq_2 eax_959 = getenv((char *) ebx_858 - 169795);
	_dl_profile_output = eax_959;
	if (eax_959 != 0x00)
	{
		edx_973 = *(union Eq_4933 *) 0x080CDDAC;
		if (*eax_959 != 0x00)
			goto l08064317;
	}
	else
		edx_973 = *(union Eq_4933 *) 0x080CDDAC;
	Eq_2 eax_982 = (char *) ebx_858 - 0x00029A84;
	if (edx_973 != 0x00)
		eax_982 = (char *) ebx_858 - 170619;
	_dl_profile_output = eax_982;
l08064317:
	if (edx_973 != 0x00)
	{
		Eq_2 edi_1004 = (char *) ebx_858 - 0x00029A60;
		do
		{
			__unsetenv(gs, edi_1004);
			Eq_2 eax_1022 = rawmemchr(edi_1004, 0x00);
			edi_1004 = (word32) eax_1022 + 1;
		} while ((word32) eax_1022 + 1 < (char *) ebx_858 - 0x00029928);
	}
	Eq_2 eax_1040 = _dl_platform;
	if (eax_1040 != 0x00 && *eax_1040 == 0x00)
		_dl_platform.u0 = 0x00;
	Eq_2 eax_1057 = getenv((char *) ebx_858 - 169777);
	Eq_2 ebp_1065 = eax_1057;
	if (eax_1057 != 0x00)
	{
		uint32 edi_1070 = 0x00;
		word32 esi_1071 = 0x00;
		while (true)
		{
			uint32 eax_1085 = _dl_strtoul(ebp_1065, fp - 0x20);
			if (eax_1085 > 0xFE || dwLoc20 == ebp_1065)
				break;
			if (esi_1071 == 0x02)
			{
				edi_1070 |= eax_1085;
l08064422:
				if (edi_1070 != 0x00)
					_dl_osversion = edi_1070;
				break;
			}
			word32 ebp_1105 = (word32) *dwLoc20;
			byte cl_1107 = (byte) ebp_1105;
			if (cl_1107 != 0x00 && cl_1107 != 0x2E)
				break;
			edi_1070 |= eax_1085 << (byte) (-esi_1071 * 0x08 + 0x10);
			if ((byte) ebp_1105 == 0x00)
				goto l08064422;
			++esi_1071;
			ebp_1065 = (word32) dwLoc20 + 1;
		}
	}
	Eq_2 eax_1141 = _dl_platform;
	if (eax_1141 != 0x00)
	{
		word32 edx_1872;
		word32 ecx_1871;
		_dl_platformlen = strlen(eax_1141, out ecx_1871, out edx_1872);
	}
	struct Eq_49988 * ecx_1163 = *dwLoc34;
	if (ecx_1163 == null)
		return edi;
	Eq_2 esi_1168 = _dl_phdr;
	if (esi_1168 == 0x00)
		return edi;
	Eq_2 edx_1172 = 0x00;
	struct Eq_49988 * eax_1174 = ecx_1163 + 1;
	if (ecx_1163->dw0000 != 1685382481)
	{
		do
		{
			edx_1172 = (word32) edx_1172 + 1;
			if (edx_1172 == esi_1168)
				return edi;
			ecx_1163 = eax_1174;
			++eax_1174;
		} while (eax_1174->dwFFFFFFE0 != 1685382481);
	}
	ebx_858->dw09A0 = ecx_1163->dw0018;
	return edi;
}

// 08064650: void _dl_get_dl_main_map()
// Called from:
//      _dl_non_dynamic_init
void _dl_get_dl_main_map()
{
}

// 08064670: void __libc_init_secure(Register (ptr32 Eq_50367) gs)
// Called from:
//      __libc_start_main
void __libc_init_secure(struct Eq_50367 * gs)
{
	if (__libc_enable_secure_decided != 0x00)
		return;
	uint32 edx_22 = 0x01;
	if (__geteuid(gs) == __getuid(gs))
		edx_22 = (uint32) (int8) (__getegid(gs) != __getgid(gs));
	g_dw80CE254 = edx_22;
}

// 080646E0: void _dl_mcount_wrapper(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04)
void _dl_mcount_wrapper(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04)
{
	word32 ecx_38;
	word32 edx_39;
	_dl_mcount(gs, dwArg00, dwArg04, out ecx_38, out edx_39);
}

// 08064710: Register Eq_2 _dl_mcount_wrapper_check(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __mbsrtowcs_l
//      __gconv
//      __gconv_release_step
//      find_derivation
//      __gconv_transform_internal_ucs4
//      __gconv_transform_ucs4_internal
//      __gconv_transform_internal_ucs4le
//      __gconv_transform_ucs4le_internal
//      __gconv_transform_ascii_internal
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_utf8_internal
//      __gconv_transform_ucs2_internal
//      __gconv_transform_internal_ucs2
//      __gconv_transform_ucs2reverse_internal
//      __gconv_transform_internal_ucs2reverse
//      __gconv_transliterate
//      find_module
//      do_in
//      do_unshift
//      do_out
//      do_length
//      btowc
//      wcrtomb
//      __wcsrtombs
//      free_derivation
Eq_2 _dl_mcount_wrapper_check(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	Eq_2 eax_11 = _dl_profile_map;
	if (eax_11 != 0x00)
		eax_11 = _dl_mcount(gs, dwArg00, dwArg04, out ecx, out edx);
	ecxOut = ecx;
	edxOut = edx;
	return eax_11;
}

// 08064750: void _dl_tunable_set_hwcaps(Stack (ptr32 (ptr32 byte)) dwArg04)
void _dl_tunable_set_hwcaps(byte ** dwArg04)
{
	byte * esi_21 = *dwArg04;
	byte dl_123 = *esi_21;
	do
	{
		if (dl_123 != 44 && dl_123 != 0x00)
		{
			byte * eax_44 = esi_21;
			do
			{
				++eax_44;
				byte cl_49 = *eax_44;
			} while (cl_49 != 0x00 && cl_49 != 44);
			Eq_50454 eax_58 = eax_44 - esi_21;
			if (dl_123 != 0x2D)
			{
				if (eax_58 <= 0x1A)
				{
					<anonymous> * ecx_112 = g_a80A4BD8[(eax_58 - 0x04) * 0x04] + 0x080CE000;
					ecx_112();
					return;
				}
			}
			else if (eax_58 <= 0x1B)
			{
				<anonymous> * ecx_73 = g_a80A4C34[(eax_58 - 0x04) * 0x04] + 0x080CE000;
				ecx_73();
				return;
			}
			esi_21 += (word32) eax_58 + 1;
			dl_123 = *esi_21;
			if (dl_123 == 0x00)
				return;
			continue;
		}
		++esi_21;
		dl_123 = *esi_21;
	} while (dl_123 != 0x00);
}

// 08065450: void _dl_tunable_set_x86_ibt(Stack (ptr32 (ptr32 Eq_50489)) dwArg04)
void _dl_tunable_set_x86_ibt(struct Eq_50489 ** dwArg04)
{
	struct Eq_50489 * eax_8 = *dwArg04;
	if (eax_8->t0000 == 0x6E6F && eax_8->b0002 == 0x00)
		g_dw80CFF20 = g_dw80CFF20 & ~0x07 | 0x02;
	else if (eax_8->t0000 != 0x0066666F)
	{
		if (eax_8->t0000 != 1836213616 || (eax_8->dw0004 != 0x69737369 || (eax_8->w0008 != 0x6576 || eax_8->b000A != 0x00)))
			return;
		g_dw80CFF20 = g_dw80CFF20 & ~0x07 | 0x03;
	}
	else
		g_dw80CFF20 = g_dw80CFF20 & ~0x07 | 0x01;
}

// 080654F0: void _dl_tunable_set_x86_shstk(Stack (ptr32 (ptr32 Eq_50553)) dwArg04)
void _dl_tunable_set_x86_shstk(struct Eq_50553 ** dwArg04)
{
	struct Eq_50553 * eax_8 = *dwArg04;
	if (eax_8->t0000 == 0x6E6F && eax_8->b0002 == 0x00)
		g_dw80CFF20 = g_dw80CFF20 & ~0x38 | 0x10;
	else if (eax_8->t0000 != 0x0066666F)
	{
		if (eax_8->t0000 != 1836213616 || (eax_8->dw0004 != 0x69737369 || (eax_8->w0008 != 0x6576 || eax_8->b000A != 0x00)))
			return;
		g_dw80CFF20 = g_dw80CFF20 & ~0x38 | 0x18;
	}
	else
		g_dw80CFF20 = g_dw80CFF20 & ~0x38 | 0x08;
}

// 08065590: Register ui32 _dl_discover_osversion(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Register out Eq_979 ediOut)
// Called from:
//      __libc_start_main
ui32 _dl_discover_osversion(Eq_2 ebx, struct Eq_9 * gs, union Eq_979 & ediOut)
{
	ui32 eax_120;
	struct Eq_50621 * ebx_128 = fp - 0x010C;
	if (__uname(ebx, gs, fp - 0x0192) != 0x00)
	{
		word32 ecx_253;
		word32 edx_254;
		Eq_2 eax_41 = __open64_nocancel(gs, 0x080A4BBC, 0x00, dwLoc01E0, out ecx_253, out edx_254);
		if (eax_41 >= 0x00)
		{
			word32 ecx_255;
			Eq_2 eax_62 = __read_nocancel(gs, eax_41, fp - 0x01CE, 0x40, out ecx_255);
			word32 edx_256;
			__close_nocancel(gs, eax_41, out edx_256);
			ebx_128 = fp - 0x01CE;
			Eq_2 esi_70 = eax_62;
			if (eax_62 > 0x00)
			{
				if (eax_62 >= 0x3F)
					esi_70.u0 = 0x3F;
				*((word32) esi_70 + (fp - 0x01CE)) = 0x00;
				goto l080655C4;
			}
		}
		eax_120 = ~0x00;
		goto l08065612;
	}
	else
	{
l080655C4:
		ui32 edi_124 = 0x00;
		eax_120 = 0x00;
		do
		{
			int32 ecx_94 = (int32) ebx_128->b0000;
			if ((byte) (ecx_94 - 0x30) > 0x09)
			{
l08065621:
				ediOut.u0 = <invalid>;
				return eax_120 << (byte) (0x03 - edi_124 << 0x03);
			}
			int32 edx_111 = (int32) ebx_128[1];
			byte * esi_100 = ebx_128 + 1;
			int32 ecx_101 = ecx_94 - 0x30;
			while ((byte) (edx_111 - 0x30) <= 0x09)
			{
				++esi_100;
				edx_111 = (int32) *esi_100;
				ecx_101 = edx_111 - 0x30 + ecx_101 * 0x0A;
			}
			++edi_124;
			ebx_128 = (struct Eq_50621 *) (esi_100 + 1);
			eax_120 = eax_120 << 0x08 | ecx_101;
			if ((byte) edx_111 != 0x2E)
			{
				if (edi_124 == 0x03)
					break;
				goto l08065621;
			}
		} while (edi_124 != 0x03);
l08065612:
		ediOut.u0 = <invalid>;
		return eax_120;
	}
}

// 080656A0: Register word32 __libc_init_first(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      __libc_start_main
word32 __libc_init_first(struct Eq_9 * gs, word32 dwArg04, word32 * dwArg08, Eq_2 dwArg0C, ptr32 & edxOut, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	__libc_multiple_libcs = 0x01;
	__libc_argc = dwArg04;
	__libc_argv = dwArg08;
	environ = dwArg0C;
	__init_misc(_dl_non_dynamic_init(gs));
	ptr32 edx_112;
	word32 ecx_111 = __ctype_init(gs, out edx_112);
	edxOut = edx_112;
	ebpOut = dwArg00;
	esiOut = edi;
	ediOut = ebp;
	return ecx_111;
}

// 08065740: Register (ptr32 Eq_226) __syscall_error(Register (ptr32 Eq_226) eax, Register (ptr32 Eq_9) gs, Register out ptr32 edxOut)
// Called from:
//      sched_yield
//      __xstat64
//      __fxstat64
//      open
//      read
//      __libc_write
//      lseek64
//      getcwd
//      __close_nocancel
//      __fcntl64_nocancel_adjusted
//      __open_nocancel
//      __openat64_nocancel
//      __read_nocancel
//      __write_nocancel
//      __getrlimit
//      mmap
//      mmap64
//      __munmap
//      mprotect
//      __madvise
//      __mremap
//      __sysinfo
//      raise
//      __libc_sigaction
//      sigprocmask
//      __getdents
//      __uname
//      __lxstat64
//      __fxstatat64
//      __libc_lseek
//      __open64_nocancel
//      __openat_nocancel
//      tcgetattr
//      brk
//      __getdents64
//      __setitimer
struct Eq_226 * __syscall_error(struct Eq_226 * eax, struct Eq_9 * gs, ptr32 & edxOut)
{
	gs->tFFFFFFE0 = -eax;
	edxOut = ~0x1F;
	return (struct Eq_226 *) ~0x00;
}

// 08065760: Register ui32 __gconv_open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      _nl_find_msg
ui32 __gconv_open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	ui32 dwLoc30_1098;
	byte bLoc34_1097;
	struct Eq_50791 * esp_229;
	ui32 esi_27 = gs->dw0014;
	Eq_2 dwLoc38_1081 = dwArg08;
	Eq_2 dwLoc40_1083 = dwArg04;
	word32 ecx_1712;
	word32 edx_1713;
	Eq_2 eax_36 = strchr(dwArg04, 0x2F, out ecx_1712, out edx_1713);
	if (eax_36 != 0x00)
	{
		word32 ecx_1714;
		word32 edx_1715;
		Eq_2 eax_54 = strchr((word32) eax_36 + 1, 0x2F, out ecx_1714, out edx_1715);
		struct Eq_50822 * esp_101 = fp - 0x5C;
		if (eax_54 != 0x00 && *((word32) eax_54 + 1) != 0x00)
		{
			Eq_2 edx_70 = (word32) eax_54 + 1 - dwArg04;
			struct Eq_50822 * edi_74 = fp - 0x5C - ((word32) edx_70 + 28 & ~0x0FFF);
			ui32 ecx_75 = (word32) edx_70 + 28 & ~0x0F;
			if (fp - 0x5C != edi_74)
			{
				do
				{
					esp_101 -= 0x1000;
					esp_101->dw0FFC = esp_101->dw0FFC;
				} while (esp_101 != edi_74);
			}
			if ((ecx_75 & 0x0FFF) != 0x00)
			{
				esp_101 -= ecx_75 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_101 - 0x04)[(ecx_75 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_101 - 0x04)[(ecx_75 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_51175 eax_102 = (char *) esp_101 + 0x0F;
			*((word32) edx_70 + (eax_102 & ~0x0F)) = 0x00;
			struct Eq_51183 * esp_103 = esp_101 - 0x04;
			esp_103->tFFFFFFFC = edx_70;
			esp_103->tFFFFFFF8 = dwArg04;
			esp_103->tFFFFFFF4 = eax_102 & ~0x0F;
			word32 ecx_1736;
			word32 edx_1737;
			Eq_2 eax_122 = memcpy(esp_103->tFFFFFFF4, esp_103->tFFFFFFF8, esp_103->tFFFFFFFC, out ecx_1736, out edx_1737);
			esp_103->tFFFFFFF4 = (word32) eax_54 + 1;
			word32 edx_1739;
			word32 ecx_1738;
			Eq_2 eax_135 = strlen(esp_103->tFFFFFFF4, out ecx_1738, out edx_1739);
			dwLoc24.u0 = 0x00;
			dwLoc40_1083 = eax_122;
			struct Eq_51227 * esp_142 = (char *) &esp_103->tFFFFFFFC + 8;
			struct Eq_51227 * edi_148 = (char *) &esp_103->tFFFFFFFC + 8 - ((word32) eax_135 + 28 & ~0x0FFF);
			ui32 ecx_149 = (word32) eax_135 + 28 & ~0x0F;
			if ((char *) &esp_103->tFFFFFFFC + 8 != edi_148)
			{
				do
				{
					esp_142 -= 0x1000;
					esp_142->dw0FFC = esp_142->dw0FFC;
				} while (esp_142 != edi_148);
			}
			if ((ecx_149 & 0x0FFF) != 0x00)
			{
				esp_142 -= ecx_149 & 0x0FFF;
				Mem172[esp_142 - 0x04 + (ecx_149 & 0x0FFF):word32] = Mem170[esp_142 - 0x04 + (ecx_149 & 0x0FFF):word32];
			}
			struct Eq_51256 * esp_177 = esp_142 - 0x04;
			esp_177->tFFFFFFFC = (word32) eax_135 + 1;
			esp_177->tFFFFFFF8 = (word32) eax_54 + 1;
			Mem196[esp_177 + -0x0C:word32] = esp_142 + 0x0F & ~0x0F;
			word32 ecx_1740;
			word32 edx_1741;
			Eq_2 eax_197 = memcpy(esp_177->tFFFFFFF4, esp_177->tFFFFFFF8, esp_177->tFFFFFFFC, out ecx_1740, out edx_1741);
			esp_177->tFFFFFFFC = fp - 0x24;
			esp_177->tFFFFFFF8.u0 = 0x080A4C94;
			esp_177->tFFFFFFF4 = eax_197;
			Eq_2 eax_222 = __strtok_r(esp_177->tFFFFFFF4, esp_177->tFFFFFFF8, esp_177->tFFFFFFFC);
			esp_229 = (struct Eq_50791 *) ((char *) &esp_177->tFFFFFFFC + 8);
			bLoc34_1097 = 0x00;
			Eq_2 edi_231 = eax_222;
			dwLoc30_1098 = 0x00;
			if (eax_222 != 0x00)
			{
				do
				{
					struct Eq_51438 * esp_242 = esp_142 - (struct Eq_51439 *) 0x04;
					esp_242->tFFFFFFFC.u0 = 0x080CE0C0;
					esp_242->tFFFFFFF8.u0 = 0x080A3AA0;
					esp_242->tFFFFFFF4 = edi_231;
					word32 ecx_1750;
					if (__strcasecmp_l(esp_242->tFFFFFFF4, esp_242->tFFFFFFF8, esp_242->tFFFFFFFC, out ecx_1750) != 0x00)
					{
						esp_242->tFFFFFFFC.u0 = 0x080CE0C0;
						esp_242->tFFFFFFF8.u0 = 0x080A4C96;
						esp_242->tFFFFFFF4 = edi_231;
						ui32 eax_285 = 0x02;
						word32 ecx_1751;
						if (__strcasecmp_l(esp_242->tFFFFFFF4, esp_242->tFFFFFFF8, esp_242->tFFFFFFFC, out ecx_1751) != 0x00)
							eax_285 = dwLoc30_1098;
						dwLoc30_1098 = eax_285;
					}
					else
						bLoc34_1097 = 0x01;
					struct Eq_51545 * esp_293 = esp_142 - (struct Eq_51546 *) 0x04;
					esp_293->tFFFFFFFC = fp - 0x24;
					esp_293->tFFFFFFF8.u0 = 0x080A4C94;
					esp_293->tFFFFFFF4.u0 = 0x00;
					Eq_2 eax_305 = __strtok_r(esp_293->tFFFFFFF4, esp_293->tFFFFFFF8, esp_293->tFFFFFFFC);
					esp_229 = esp_293 + 0x04;
					edi_231 = eax_305;
				} while (eax_305 != 0x00);
			}
l080657D5:
			Eq_2 eax_350;
			struct Eq_50855 * esp_324 = esp_229 - 0x08;
			esp_324->tFFFFFFFC.u0 = 0x2F;
			esp_324->tFFFFFFF8 = dwArg08;
			word32 edx_1749;
			word32 ecx_1748;
			Eq_2 eax_332 = strchr(esp_324->tFFFFFFF8, esp_324->tFFFFFFFC, out ecx_1748, out edx_1749);
			struct Eq_50879 * esp_339 = (char *) &esp_324->tFFFFFFFC + 0x0C;
			bool v51_1061 = eax_332 > 0x00;
			if (eax_332 != 0x00)
			{
				esp_324->tFFFFFFFC.u0 = 0x2F;
				esp_324->tFFFFFFF8 = (word32) eax_332 + 1;
				word32 edx_1717;
				word32 ecx_1716;
				eax_350 = strchr(esp_324->tFFFFFFF8, esp_324->tFFFFFFFC, out ecx_1716, out edx_1717);
				esp_339 = (struct Eq_50879 *) ((char *) &esp_324->tFFFFFFFC + 0x0C);
				v51_1061 = eax_350 > 0x00;
				if (eax_350 != 0x00)
				{
					v51_1061 = *((word32) eax_350 + 1) > 0x00;
					if (*((word32) eax_350 + 1) != 0x00)
					{
						Eq_2 eax_364 = (word32) eax_350 + 1 - dwArg08;
						struct Eq_50879 * esi_369 = (char *) &esp_324->tFFFFFFFC + 0x0C - ((word32) eax_364 + 28 & ~0x0FFF);
						ui32 ecx_370 = (word32) eax_364 + 28 & ~0x0F;
						if ((char *) &esp_324->tFFFFFFFC + 0x0C != esi_369)
						{
							do
							{
								esp_339 -= 0x1000;
								esp_339->dw0FFC = esp_339->dw0FFC;
							} while (esp_339 != esi_369);
						}
						if ((ecx_370 & 0x0FFF) != 0x00)
						{
							esp_339 -= ecx_370 & 0x0FFF;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_339 - 0x04)[(ecx_370 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_339 - 0x04)[(ecx_370 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						Eq_51351 edx_397 = (char *) esp_339 + 0x0F;
						*((word32) eax_364 + (edx_397 & ~0x0F)) = 0x00;
						struct Eq_51359 * esp_398 = esp_339 - 0x04;
						esp_398->tFFFFFFFC = eax_364;
						esp_398->tFFFFFFF8 = dwArg08;
						esp_398->tFFFFFFF4 = edx_397 & ~0x0F;
						esp_339 = (struct Eq_50879 *) ((char *) &esp_398->tFFFFFFFC + 8);
						v51_1061 = esp_398 > (struct Eq_51359 *) 0x04;
						word32 edx_1743;
						word32 ecx_1742;
						dwLoc38_1081 = memcpy(esp_398->tFFFFFFF4, esp_398->tFFFFFFF8, esp_398->tFFFFFFFC, out ecx_1742, out edx_1743);
					}
				}
			}
			Eq_2 esi_439 = dwLoc40_1083;
			word32 ecx_440 = 0x03;
			cu8 * edi_441 = &g_b80A4E24;
			while (ecx_440 != 0x00)
			{
				v51_1061 = *esi_1777 > *edi_1778;
				esi_439 = (word32) esi_1777 + 1;
				edi_441 = edi_1778 + 1;
				--ecx_440;
				esi_1777 = esi_439;
				edi_1778 = edi_441;
				if (*esi_1777 == *edi_1778)
					break;
			}
			struct Eq_50914 * esp_542;
			Eq_50915 al_463 = (int8) v51_1061 - (*((word32) eax_350 + 1) < 0x00);
			bool v59_1069 = al_463 > 0x00;
			if (al_463 == 0x00)
			{
				struct Eq_50951 * esp_476 = esp_339 - 0x0C;
				Eq_2 edi_497 = *((word32) gs->ptrFFFFFFD0->t0000 + 92);
				esp_476->tFFFFFFFC = edi_497;
				word32 ecx_1718;
				word32 edx_1719;
				Eq_2 eax_500 = strlen(esp_476->tFFFFFFFC, out ecx_1718, out edx_1719);
				struct Eq_50976 * esp_507 = (char *) &esp_476->tFFFFFFFC + 16;
				struct Eq_50976 * edx_512 = (char *) &esp_476->tFFFFFFFC + 16 - ((word32) eax_500 + 30 & ~0x0FFF);
				ui32 esi_513 = (word32) eax_500 + 30 & ~0x0F;
				if ((char *) &esp_476->tFFFFFFFC + 16 != edx_512)
				{
					do
					{
						esp_507 -= 0x1000;
						esp_507->dw0FFC = esp_507->dw0FFC;
					} while (esp_507 != edx_512);
				}
				if ((esi_513 & 0x0FFF) != 0x00)
				{
					esp_507 -= esi_513 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_507 - 0x04)[(esi_513 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_507 - 0x04)[(esi_513 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				esp_542 = esp_507 - 0x04;
				esp_542->tFFFFFFFC = eax_500;
				esp_542->tFFFFFFF8 = edi_497;
				Eq_51845 ecx_541 = (char *) esp_507 + 0x0F;
				esp_542->tFFFFFFF4 = ecx_541 & ~0x0F;
				word32 edx_1776;
				Eq_2 eax_566 = __mempcpy(esp_542->tFFFFFFF4, esp_542->tFFFFFFF8, esp_542->tFFFFFFFC, out edx_1776);
				eax_566->u4 = 0x2F2F;
				*((word32) eax_566 + 2) = 0x00;
				dwLoc40_1083 = ecx_541 & ~0x0F;
				esp_339 = (struct Eq_50879 *) ((char *) &esp_542->tFFFFFFFC + 8);
				v59_1069 = esp_542 > (struct Eq_50914 *) 0x04;
			}
			Eq_2 esi_584 = dwLoc38_1081;
			word32 ecx_585 = 0x03;
			cu8 * edi_587 = &g_b80A4E24;
			while (ecx_585 != 0x00)
			{
				v59_1069 = *esi_1779 > *edi_1780;
				esi_584 = (word32) esi_1779 + 1;
				edi_587 = edi_1780 + 1;
				--ecx_585;
				esi_1779 = esi_584;
				edi_1780 = edi_587;
				if (*esi_1779 == *edi_1780)
					break;
			}
			if ((int8) v59_1069 - (esp_542 < (struct Eq_50914 *) 0x04) == 0x00)
			{
				struct Eq_51027 * esp_614 = esp_339 - 0x0C;
				Eq_2 esi_625 = *((word32) gs->ptrFFFFFFD0->t0000 + 92);
				esp_614->tFFFFFFFC = esi_625;
				word32 ecx_1720;
				word32 edx_1721;
				Eq_2 eax_628 = strlen(esp_614->tFFFFFFFC, out ecx_1720, out edx_1721);
				struct Eq_51052 * esp_635 = (char *) &esp_614->tFFFFFFFC + 16;
				struct Eq_51052 * edi_640 = (char *) &esp_614->tFFFFFFFC + 16 - ((word32) eax_628 + 30 & ~0x0FFF);
				ui32 ecx_641 = (word32) eax_628 + 30 & ~0x0F;
				if ((char *) &esp_614->tFFFFFFFC + 16 != edi_640)
				{
					do
					{
						esp_635 -= 0x1000;
						esp_635->dw0FFC = esp_635->dw0FFC;
					} while (esp_635 != edi_640);
				}
				if ((ecx_641 & 0x0FFF) != 0x00)
				{
					esp_635 -= ecx_641 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_635 - 0x04)[(ecx_641 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_635 - 0x04)[(ecx_641 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_51601 * esp_669 = esp_635 - 0x04;
				esp_669->tFFFFFFFC = eax_628;
				esp_669->tFFFFFFF8 = esi_625;
				Eq_51610 edx_668 = (char *) esp_635 + 0x0F;
				esp_669->tFFFFFFF4 = edx_668 & ~0x0F;
				word32 edx_1754;
				Eq_2 eax_691 = __mempcpy(esp_669->tFFFFFFF4, esp_669->tFFFFFFF8, esp_669->tFFFFFFFC, out edx_1754);
				eax_691->u4 = 0x2F2F;
				*((word32) eax_691 + 2) = 0x00;
				dwLoc38_1081 = edx_668 & ~0x0F;
				esp_339 = (struct Eq_50879 *) ((char *) &esp_669->tFFFFFFFC + 8);
			}
			struct Eq_51068 * esp_706 = esp_339 - 0x0C;
			esp_706->tFFFFFFFC = dwArg10;
			esp_706->ptrFFFFFFF8 = fp - 0x24;
			esp_706->ptrFFFFFFF4 = fp - 0x28;
			esp_706->tFFFFFFF0 = dwLoc38_1081;
			esp_706->tFFFFFFEC = dwLoc40_1083;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			word32 ebx_1723;
			word32 ebp_1724;
			word32 esi_1725;
			ui32 eax_775 = __gconv_find_transform(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, out ebx_1723, out ebp_1724, out esi_1725);
			Eq_2 dwLoc40_1291 = 0x00;
			ui32 dwLoc48_1292 = eax_775;
			if (eax_775 == 0x00)
			{
				Eq_2 dwLoc30_1350;
				esp_706->tFFFFFFFC = (dwLoc24 << 0x05) + 0x08;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 esi_1732;
				word32 edx_1729;
				word32 edi_1733;
				word32 ebx_1730;
				word32 ebp_1731;
				word32 ecx_1728;
				Eq_2 eax_794 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1728, out edx_1729, out ebx_1730, out ebp_1731, out esi_1732, out edi_1733);
				ptr32 esp_798 = (char *) &esp_706->t0004 + 8;
				dwLoc40_1291 = eax_794;
				if (eax_794 != 0x00)
				{
					*((word32) eax_794 + 4) = dwLoc28;
					*eax_794 = dwLoc24;
					esp_706->t0004 = dwLoc24 << 0x05;
					esp_706->t0000.u0 = 0x00;
					esp_706->tFFFFFFFC = (word32) eax_794 + 8;
					word32 ecx_1752;
					word32 edx_1753;
					memset(esp_706->tFFFFFFFC, esp_706->t0000, esp_706->t0004, out ecx_1752, out edx_1753);
					if (dwLoc24 != 0x00)
					{
						struct Eq_51535 * esi_1021 = (word32) eax_794 + 32;
						Eq_51106 edi_1020 = 0x00;
						do
						{
							esi_1021->dwFFFFFFFC = esi_1021;
							if (bLoc34_1097 != 0x00)
							{
								struct Eq_51646 * esp_853 = esp_339 - 0x04;
								esp_853->tFFFFFFFC.u0 = 0x080CE0C0;
								esp_853->tFFFFFFF8.u0 = 0x080A4DFD;
								Mem863[esp_853 + -0x0C:word32] = Mem860[edi_1020 *s 0x3C + dwLoc28 + 0x0C:word32];
								ui32 edx_874 = dwLoc30_1098 | 0x08;
								word32 ecx_1755;
								if (__strcasecmp_l(esp_853->tFFFFFFF4, esp_853->tFFFFFFF8, esp_853->tFFFFFFFC, out ecx_1755) != 0x00)
									edx_874 = dwLoc30_1098;
								dwLoc30_1098 = edx_874;
							}
							if (dwLoc24 - 0x01 <= edi_1020)
							{
								*((word32) eax_794 + (edi_1020 * 0x20 + 16)) = dwLoc30_1098 | 0x01;
								break;
							}
							esi_1021->dwFFFFFFF0 = dwLoc30_1098;
							struct Eq_51694 * esp_901 = esp_339 - 0x0C;
							int32 edx_909 = dwLoc28->a0030[edi_1020].dw0000 *s 0x1FE0;
							esp_901->dwFFFFFFFC = edx_909;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 ecx_1758;
							word32 ebp_1761;
							word32 esi_1762;
							word32 edi_1763;
							word32 edx_1759;
							word32 ebx_1760;
							Eq_2 eax_923 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1758, out edx_1759, out ebx_1760, out ebp_1761, out esi_1762, out edi_1763);
							esi_1021->dwFFFFFFE8 = (word32) eax_923;
							ptr32 esp_927 = &esp_901->dwFFFFFFFC + 4;
							if (eax_923 == 0x00)
							{
								Eq_51733 esi_934 = edi_1020 - 0x01;
								dwLoc30_1350 = gs->tFFFFFFE0;
								if (edi_1020 != 0x00)
								{
									Eq_51733 esi_942 = esi_934;
									do
									{
										struct Eq_51787 * esp_946 = esp_927 - 0x0C;
										esp_946->dwFFFFFFFC = (word32) *((word32) eax_794 + (esi_942 * 0x20 + 8));
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg0 = <invalid>;
										Eq_2 stackArg4 = <invalid>;
										word32 edx_1775;
										word32 ecx_1774;
										free(gs, stackArg0, stackArg4, out ecx_1774, out edx_1775);
										--esi_942;
										esp_927 = &esp_946->dwFFFFFFFC + 5;
									} while (esi_942 != ~0x00);
								}
								struct Eq_51770 * esp_971 = esp_927 - 0x0C;
								esp_971->tFFFFFFFC = eax_794;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg0 = <invalid>;
								Eq_2 stackArg4 = <invalid>;
								word32 edx_1771;
								word32 ecx_1770;
								free(gs, stackArg0, stackArg4, out ecx_1770, out edx_1771);
								esp_798 = (char *) &esp_971->tFFFFFFFC + 20;
								goto l08065CD9;
							}
							++esi_1021;
							esi_1021->dwFFFFFFCC = (word32) eax_923 + edx_909;
							edi_1020 = (word32) edi_1020 + 1;
						} while (dwLoc24 > edi_1020);
					}
				}
				else
				{
					dwLoc30_1350 = gs->tFFFFFFE0;
l08065CD9:
					struct Eq_51749 * esp_994 = esp_798 - 0x08;
					esp_994->tFFFFFFFC = dwLoc24;
					esp_994->ptrFFFFFFF8 = dwLoc28;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 edx_1766;
					word32 esi_1767;
					__gconv_close_transform(edx, gs, stackArg4, dwArg04, out edx_1766, out esi_1767);
					gs->tFFFFFFE0 = dwLoc30_1350;
					dwLoc48_1292 = 0x03;
					dwLoc40_1291.u0 = 0x00;
				}
			}
			*dwArg0C = dwLoc40_1291;
			if ((esi_27 ^ gs->dw0014) == 0x00)
				return dwLoc48_1292;
			word32 edx_1735;
			word32 ecx_1734;
			__stack_chk_fail(out ecx_1734, out edx_1735);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg20 = <invalid>;
			Eq_2 stackArg24 = <invalid>;
			word32 ecx_1746;
			word32 edx_1747;
			return __gconv(gs, dwArg04, dwArg08, dwArg0C, dwArg10, stackArg20, stackArg24, out ecx_1746, out edx_1747);
		}
	}
	esp_229 = fp - 0x5C;
	bLoc34_1097 = 0x00;
	dwLoc30_1098 = 0x00;
	goto l080657D5;
}

// 08065D60: Register word32 __gconv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Register out Eq_2 ecxOut, Register out Eq_3106 edxOut)
// Called from:
//      _nl_find_msg
//      __gconv_open
word32 __gconv(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, union Eq_2 & ecxOut, union Eq_3106 & edxOut)
{
	if (dwArg04 == ~0x00)
	{
		ecxOut.u0 = 0x080CE000;
		edxOut = edx;
		return 0x08;
	}
	uint32 eax_34 = *dwArg04;
	if (dwArg18 == 0x00)
	{
		word32 edx_473;
		word32 ecx_472;
		__assert_fail(out ecx_472, out edx_473);
		goto l08065F19;
	}
	else
	{
		*dwArg18 = 0x00;
		Eq_3106 edx_59 = 0x00;
		if (dwArg10 != 0x00)
			edx_59 = *dwArg10;
		struct Eq_51906 * esi_68 = (word32) dwArg04 + (eax_34 << 0x05);
		esi_68->tFFFFFFE8 = edx_59;
		esi_68->tFFFFFFEC = dwArg14;
		Eq_2 eax_75 = *((word32) dwArg04 + 4);
		Eq_2 esi_105 = *((word32) eax_75 + 20);
		if (*eax_75 != 0x00)
			esi_105 = __ror(esi_105, 0x09) ^ gs->t0018;
		Eq_2 ecx_178;
		word32 eax_154;
		if (dwArg08 != 0x00)
		{
			up32 edi_268 = *dwArg08;
			if (edi_268 != 0x00)
			{
				if (dwArg10 != 0x00 && *dwArg10 != 0x00)
				{
					while (true)
					{
						word32 edx_482;
						word32 ecx_481;
						_dl_mcount_wrapper_check(gs, dwLoc40, esi_105, out ecx_481, out edx_482);
						word32 edx_272;
						esi_105();
						dwLoc40.u0 = 0x00;
						if (eax_154 != 0x04)
							break;
						up32 edx_277 = *dwArg08;
						if (edx_277 == edi_268)
							break;
						ecx_178 = *((word32) dwArg04 + 4);
						if (dwArg0C < (word32) (*((word32) ecx_178 + 36)) + edx_277)
							break;
						edi_268 = edx_277;
					}
					goto l08065E60;
				}
l08065F19:
				word32 edx_480;
				word32 ecx_479;
				__assert_fail(out ecx_479, out edx_480);
				Eq_2 ecx_226;
				Eq_3106 edx_228;
				word32 ebp_475;
				word32 esi_476;
				word32 ebx_474;
				word32 eax_227 = __gconv_close(dwArg04, out ecx_226, out edx_228, out ebx_474, out ebp_475, out esi_476);
				ecxOut = ecx_226;
				edxOut = edx_228;
				return eax_227;
			}
		}
		word32 ecx_477;
		word32 edx_478;
		_dl_mcount_wrapper_check(gs, dwLoc40, esi_105, out ecx_477, out edx_478);
		Eq_3106 edx_155;
		esi_105();
		if (eax_154 == 0x00)
		{
			edx_155.u0 = 0x00;
			do
			{
				*((word32) dwArg04 + (edx_155 * 0x20 + 20)) = 0x00;
				edx_155 = (word32) edx_155.u0 + 1;
			} while (eax_34 - 0x01 >= edx_155);
		}
		ecx_178 = dwArg10;
		if (dwArg10 == 0x00)
		{
			ecxOut = dwArg10;
			edxOut = edx_155;
			return eax_154;
		}
l08065E60:
		Eq_3106 edx_289 = *dwArg10;
		if (edx_289 != 0x00)
		{
			edx_289 = esi_68->tFFFFFFE8;
			*dwArg10 = edx_289;
		}
		ecxOut = ecx_178;
		edxOut = edx_289;
		return eax_154;
	}
}

// 08065F40: Register Eq_2 __gconv_close(Stack Eq_2 dwArg04, Register out Eq_979 ecxOut, Register out ptr32 edxOut, Register out ptr32 ebxOut, Register out (ptr32 Eq_51954) ebpOut, Register out Eq_51955 esiOut)
// Called from:
//      __gconv
//      _nl_unload_domain
Eq_2 __gconv_close(Eq_2 dwArg04, union Eq_979 & ecxOut, ptr32 & edxOut, ptr32 & ebxOut, struct Eq_51954 & ebpOut, union Eq_51955 & esiOut)
{
	ptr32 esp_18 = fp - 44;
	Eq_2 eax_21 = *((word32) dwArg04 + 4);
	struct Eq_52049 * edi_23 = (word32) dwArg04 + 8;
	while ((edi_23->b0008 & 0x01) == 0x00)
	{
		word32 edx_32 = edi_23->dw0000;
		++edi_23;
		if (edx_32 == 0x00)
			continue;
		struct Eq_52086 * esp_38 = esp_18 - 0x0C;
		esp_38->dwFFFFFFFC = edx_32;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ecx_133;
		word32 edx_134;
		free(gs, stackArg0, stackArg4, out ecx_133, out edx_134);
		esp_18 = &esp_38->dwFFFFFFFC + 5;
		if ((edi_23->bFFFFFFE8 & 0x01) != 0x00)
			break;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 edx_129;
	word32 ecx_128;
	free(gs, stackArg0, dwArg04, out ecx_128, out edx_129);
	ptr32 edx_78;
	word32 esi_130;
	Eq_2 eax_77 = __gconv_close_transform(dwLoc38, gs, eax_21, dwArg04, out edx_78, out esi_130);
	ecxOut.u0 = <invalid>;
	edxOut = edx_78;
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	return eax_77;
}

// 08065FB0: void __gconv_alias_compare(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_2) dwArg08)
void __gconv_alias_compare(union Eq_2 * dwArg04, union Eq_2 * dwArg08)
{
	Eq_2 eax_6 = *dwArg08;
	Eq_2 eax_9 = *dwArg04;
	word32 ecx_22;
	word32 edx_23;
	strcmp(eax_9, eax_6, out ecx_22, out edx_23);
}

// 08065FD0: void derivation_compare(Stack (ptr32 Eq_52125) dwArg04, Stack (ptr32 Eq_52126) dwArg08)
void derivation_compare(struct Eq_52125 * dwArg04, struct Eq_52126 * dwArg08)
{
	word32 ecx_77;
	word32 edx_78;
	if (strcmp(dwArg04->t0000, dwArg08->t0000, out ecx_77, out edx_78) != 0x00)
		return;
	Eq_2 eax_37 = dwArg08->t0004;
	Eq_2 eax_39 = dwArg04->t0004;
	word32 ecx_79;
	word32 edx_80;
	strcmp(eax_39, eax_37, out ecx_79, out edx_80);
}

// 08066020: void __gconv_get_modules_db()
void __gconv_get_modules_db()
{
}

// 08066040: void __gconv_get_alias_db()
void __gconv_get_alias_db()
{
}

// 08066060: Register Eq_2 __gconv_release_step(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 edxOut)
// Called from:
//      __new_fclose
//      find_derivation
//      __gconv_close_transform
//      __gconv_lookup_cache
Eq_2 __gconv_release_step(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & edxOut)
{
	Eq_2 edx_124 = *dwArg04;
	if (edx_124 != 0x00)
	{
		Eq_2 v11_41 = *((word32) dwArg04 + 8) - 0x01;
		*((word32) dwArg04 + 8) = v11_41;
		if (v11_41 == 0x00)
		{
			Eq_2 esi_49 = __ror(*((word32) dwArg04 + 32), 0x09) ^ gs->t0018;
			if (esi_49 != 0x00)
			{
				word32 ecx_140;
				word32 edx_141;
				_dl_mcount_wrapper_check(gs, dwLoc20, esi_49, out ecx_140, out edx_141);
				word32 ecx_67;
				esi_49();
				edx_124 = *dwArg04;
			}
			__gconv_release_shlib(edx_124, out ecx, out edx_124);
			dwArg04->u0 = 0x00;
		}
	}
	else
	{
		edx_124 = *((word32) dwArg04 + 32);
		if (edx_124 != 0x00)
		{
			word32 ecx_142;
			word32 edx_143;
			__assert_fail(out ecx_142, out edx_143);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			Eq_2 edx_39;
			Eq_2 ecx_105;
			find_derivation(eax, ecx_105, edx, gs, stackArg4, stackArg8, stackArg12, out ecx_105, out edx_39);
			edxOut = edx_39;
			return ecx_105;
		}
	}
	edxOut = edx_124;
	return ecx;
}

// 080660F0: Register Eq_2 find_derivation(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __gconv_release_step
//      __gconv_find_transform
Eq_2 find_derivation(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 eax_40;
	Eq_2 dwLoc74_1793 = dwArg04;
	ui32 ecx_34 = gs->dw0014;
	eax_40 = eax;
	if (edx != 0x00)
		eax_40 = edx;
	Eq_2 dwLoc40_2049;
	word32 * dwLoc84_1808;
	Eq_2 dwLoc80_2566;
	Eq_2 dwLoc7C_2510;
	Eq_2 dwLoc60_1838;
	Eq_2 dwLoc44_2223;
	struct Eq_52253 * esp_1182;
	Eq_2 edx_1390;
	Eq_2 ecx_1388;
	Eq_2 esi_1148;
	Eq_2 dwLoc70_1807;
	Eq_2 eax_1383;
	if (dwArg04 != 0x00)
	{
		eax_1383 = __tfind(fp - 0x30, 0x080CF940, 0x08065FD0);
		struct Eq_52279 * esp_155 = fp - 0x8C;
		if (eax_1383 != 0x00)
		{
l08066185:
			struct Eq_4061 * eax_1385 = *eax_1383;
			ecx_1388 = eax_1385->t0008;
			*dwArg08 = ecx_1388;
			edx_1390 = eax_1385->t000C;
			*dwArg0C = edx_1390;
			dwLoc80_2566.u0 = 0x080CF940;
			dwLoc7C_2510.u0 = 0x08065FD0;
			esi_1148 = edx_1390;
			dwLoc44_2223 = edx_1390;
			struct Eq_52305 * ebx_1398 = ecx_1388 - 0x3C + edx_1390 *s 0x3C;
			if (edx_1390 != 0x00)
			{
				do
				{
					word32 eax_1404 = ebx_1398->dw0008;
					ebx_1398->dw0008 = eax_1404 + 0x01;
					edx_1390 = eax_1404 + 0x01;
					if (eax_1404 == 0x00)
					{
						Eq_2 eax_1410 = ebx_1398->dw0004;
						if (eax_1410 != 0x00)
						{
							Eq_2 eax_1426 = __gconv_find_shlib(gs, eax_1410, out ecx_1388);
							ebx_1398->dw0000 = (word32) eax_1426;
							esp_1182 = fp - 0x8C;
							if (eax_1426 == 0x00)
							{
								--ebx_1398->dw0008;
								if (edx_1390 > esi_1148)
								{
									esi_1148 = (word32) ecx_1388 + edx_1390 *s 0x3C;
									Eq_2 ebx_1442 = (word32) ecx_1388 + esi_1148 *s 0x3C;
									do
									{
										struct Eq_53476 * esp_1445 = esp_1182 - (struct Eq_53477 *) 0x0C;
										esp_1445->tFFFFFFFC = ebx_1442;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg4 = <invalid>;
										ebx_1442 = (word32) ebx_1442 + 60;
										ecx_1388 = __gconv_release_step(gs, stackArg4, out edx_1390);
										esp_1182 = esp_1445 + 0x10;
									} while (esi_1148 != ebx_1442);
								}
								dwLoc40_2049.u0 = 0x01;
								goto l08066AA8;
							}
							ebx_1398->dw0014 = (word32) *((word32) eax_1426 + 0x0C);
							Eq_2 edx_1471 = *((word32) eax_1426 + 16);
							word32 eax_1472 = *((word32) eax_1426 + 20);
							ebx_1398->dw0018 = 0x00;
							ebx_1398->dw001C = (word32) edx_1471;
							ebx_1398->dw0020 = eax_1472;
							<anonymous> * edx_1478 = __ror(edx_1471, 0x09) ^ gs->t0018;
							if (edx_1478 != null)
							{
								word32 ecx_1488;
								edx_1478();
								edx_1478 = ebx_1398->dw0018;
							}
							edx_1390 = __rol(edx_1478 ^ gs->t0018, 0x09);
							ebx_1398->dw0018 = (word32) edx_1390;
						}
					}
					--esi_1148;
					ebx_1398 -= 0x3C;
				} while (esi_1148 != 0x00);
			}
			esp_1182 = fp - 0x8C;
			dwLoc40_2049.u0 = 0x00;
l08066AA8:
			if ((ecx_34 ^ gs->dw0014) == 0x00)
			{
				ecxOut = ecx_1388;
				edxOut = edx_1390;
				return dwLoc40_2049;
			}
			word32 ecx_3400;
			word32 edx_3401;
			__stack_chk_fail(out ecx_3400, out edx_3401);
l08066C17:
			dwLoc60_1838 = dwLoc44_2223;
			goto l080668FA;
		}
		if (fp - 0x8C != fp - 0x8C)
		{
			do
			{
				esp_155 -= 0x1000;
				esp_155->dw0FFC = esp_155->dw0FFC;
			} while (esp_155 != fp - 0x8C);
		}
		struct Eq_53701 * esp_172 = esp_155 - 0x30;
		esp_172->dw002C = esp_172->dw002C;
		word32 esi_182 = esp_172 + 0x0F & ~0x0F;
		*esi_182 = dwArg04;
		esp_172->tFFFFFFF0 = dwArg04;
		word32 edx_3410;
		word32 ecx_3409;
		Eq_2 eax_189 = strlen(esp_172->tFFFFFFF0, out ecx_3409, out edx_3410);
		((word32) esi_182 + 0x0C)->u0 = 0x00;
		*((word32) esi_182 + 4) = eax_189;
		*((word32) esi_182 + 8) = 0x00;
		((word32) esi_182 + 16)->u0 = 0x00;
		((word32) esi_182 + 20)->u0 = 0x00;
		((word32) esi_182 + 24)->u0 = 0x00;
		dwLoc70_1807 = esi_182;
		esp_172->tFFFFFFFC = esp_172->tFFFFFFFC;
		Eq_2 edi_223 = esp_172 - (struct Eq_53771 *) 33 & ~0x0F;
		*edi_223 = ecx;
		esp_172->tFFFFFFC0 = ecx;
		word32 ecx_3411;
		word32 edx_3412;
		Eq_2 eax_233 = strlen(esp_172->tFFFFFFC0, out ecx_3411, out edx_3412);
		*((word32) esi_182 + 24) = edi_223;
		*((word32) edi_223 + 4) = eax_233;
		*((word32) edi_223 + 0x0C) = 0x00;
		*((word32) edi_223 + 8) = 0x00;
		*((word32) edi_223 + 16) = 0x00;
		*((word32) edi_223 + 20) = 0x00;
		((word32) edi_223 + 24)->u0 = 0x00;
		esp_1182 = esp_172 - (struct Eq_53817 *) 0x30;
		dwLoc84_1808 = (word32) edi_223 + 24;
	}
	else
	{
		eax_1383 = __tfind(fp - 0x30, 0x080CF940, 0x08065FD0);
		struct Eq_52268 * esp_75 = fp - 0x8C;
		if (eax_1383 != 0x00)
			goto l08066185;
		if (fp - 0x8C != fp - 0x8C)
		{
			do
			{
				esp_75 -= 0x1000;
				esp_75->dw0FFC = esp_75->dw0FFC;
			} while (esp_75 != fp - 0x8C);
		}
		struct Eq_52253 * esp_92 = esp_75 - 0x30;
		esp_92[11] = esp_92[11];
		word32 eax_99 = esp_92 + 0x0F & ~0x0F;
		*eax_99 = ecx;
		esp_92->dwFFFFFFF0 = (word32) ecx;
		word32 edx_3314;
		word32 ecx_3313;
		Eq_2 eax_111 = strlen(esp_92->dwFFFFFFF0, out ecx_3313, out edx_3314);
		((word32) eax_99 + 0x0C)->u0 = 0x00;
		*((word32) eax_99 + 4) = eax_111;
		*((word32) eax_99 + 8) = 0x00;
		((word32) eax_99 + 16)->u0 = 0x00;
		((word32) eax_99 + 20)->u0 = 0x00;
		((word32) eax_99 + 24)->u0 = 0x00;
		dwLoc70_1807 = eax_99;
		esp_1182 = esp_92;
		dwLoc84_1808 = (word32) eax_99 + 24;
		dwLoc74_1793 = ecx;
	}
	dwLoc80_2566.u0 = 0x080CF940;
	dwLoc7C_2510.u0 = 0x08065FD0;
	Eq_2 dwLoc48_1827 = 0x00;
	int32 dwLoc54_1828 = 0x7FFFFFFF;
	Eq_2 dwLoc44_1829 = dwLoc70_1807;
	Eq_2 dwLoc4C_1837 = 0x7FFFFFFF;
	dwLoc60_1838.u0 = 0x00;
l08066412:
	if (dwLoc48_1827 > dwLoc4C_1837 || dwLoc48_1827 == dwLoc4C_1837 && *((word32) dwLoc44_1829 + 8) >= dwLoc54_1828)
	{
l080663FB:
		Eq_2 eax_755 = *((word32) dwLoc44_1829 + 24);
		dwLoc44_1829 = eax_755;
		if (eax_755 != 0x00)
		{
			dwLoc48_1827 = *((word32) eax_755 + 0x0C);
			goto l08066412;
		}
		if (dwLoc60_1838 == 0x00)
		{
			dwArg08->u0 = 0x00;
			dwArg0C->u0 = 0x00;
			dwLoc40_2049.u0 = 0x01;
			esi_1148.u0 = 0x00;
			goto l08066A1B;
		}
		Eq_2 eax_772 = *((word32) dwLoc60_1838 + 24);
		if (eax_772 != 0x00)
		{
			Eq_2 edi_776 = *((word32) dwLoc60_1838 + 0x0C);
			if (*((word32) eax_772 + 0x0C) >= edi_776)
			{
				if (*((word32) eax_772 + 0x0C) == edi_776)
				{
					if (*((word32) eax_772 + 8) >= *((word32) dwLoc60_1838 + 8))
						eax_772 = dwLoc60_1838;
					dwLoc60_1838 = eax_772;
				}
			}
			else
				dwLoc60_1838 = eax_772;
		}
		Eq_2 eax_792 = *((word32) dwLoc60_1838 + 20);
		if (eax_792 != 0x00)
		{
			Eq_2 edi_944 = 0x00;
			while (true)
			{
				eax_792 = *((word32) eax_792 + 20);
				esi_1148 = (word32) edi_944 + 1;
				if (eax_792 == 0x00)
					break;
				edi_944 = esi_1148;
			}
			struct Eq_52741 * esp_958 = esp_1182 - (struct Eq_52742 *) 0x0C;
			esp_958->tFFFFFFFC = esi_1148 *s 0x3C;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 ecx_3331;
			word32 edx_3332;
			word32 ebp_3334;
			word32 edi_3336;
			word32 esi_3335;
			word32 ebx_3333;
			Eq_2 eax_969 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3331, out edx_3332, out ebx_3333, out ebp_3334, out esi_3335, out edi_3336);
			esp_1182 = esp_958 + 0x0C;
			dwLoc44_2223 = eax_969;
			if (eax_969 != 0x00)
			{
				*dwArg0C = esi_1148;
				if (esi_1148 == 0x00)
					goto l08066C17;
				Eq_2 ecx_1014 = esi_1148;
				Eq_2 dwLoc54_2232 = 0x00;
				Eq_2 esi_1017 = dwLoc60_1838;
				Eq_2 dwLoc4C_2234 = 0x00;
				Eq_2 edx_1001 = edi_944;
				struct Eq_52793 * ebx_1018 = (word32) eax_969 + edi_944 *s 0x3C;
l08066818:
				Eq_2 edi_1035;
				if (edx_1001 != 0x00)
					ebx_1018->dw000C = (word32) **((word32) esi_1017 + 20);
				else
				{
					esp_1182->dwFFFFFFF0 = (word32) dwLoc74_1793;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 eax_1023 = strdup(stackArg4);
					*((word32) eax_969 + 0x0C) = eax_1023;
					dwLoc4C_2234 = eax_1023;
					if (eax_1023 == 0x00)
					{
						edi_1035.u0 = 0x01;
l08066974:
						dwLoc40_2049.u0 = 0x00;
						if (*dwArg0C <= edi_1035)
						{
							struct Eq_53183 * esp_1143 = esp_1182 - (struct Eq_53184 *) 0x0C;
							esp_1143->tFFFFFFFC = eax_969;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 ecx_3369;
							word32 edx_3370;
							free(gs, stackArg0, stackArg4, out ecx_3369, out edx_3370);
							esp_1143->tFFFFFFFC = dwLoc4C_2234;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 edx_3374;
							word32 ecx_3373;
							free(gs, stackArg0, stackArg4, out ecx_3373, out edx_3374);
							esp_1143->tFFFFFFFC = dwLoc54_2232;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							word32 edx_3378;
							word32 ecx_3377;
							free(gs, stackArg0, stackArg4, out ecx_3377, out edx_3378);
							dwArg0C->u0 = 0x00;
							dwArg08->u0 = 0x00;
							esi_1148.u0 = 0x00;
							esp_1182 = esp_1143 + 0x0C;
							dwLoc60_1838.u0 = 0x00;
							dwLoc40_2049.u0 = 0x01;
							goto l08066A1B;
						}
						goto l08066986;
					}
				}
				if (*dwArg0C != ecx_1014)
					ebx_1018->dw0010 = (word32) *((word32) eax_969 + (ecx_1014 * 0x3C + 0x0C));
				else
				{
					esp_1182->dwFFFFFFF0 = (word32) *esi_1017;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 eax_1060 = strdup(stackArg4);
					ebx_1018->dw0010 = (word32) eax_1060;
					dwLoc54_2232 = eax_1060;
					if (eax_1060 == 0x00)
						goto l0806696F;
				}
				Eq_2 eax_1107;
				Eq_2 eax_1078 = *((word32) esi_1017 + 16);
				ebx_1018->dw0008 = 0x01;
				ebx_1018->dw0038 = 0x00;
				byte * eax_1082 = *((word32) eax_1078 + 16);
				if (*eax_1082 != 0x2F)
				{
					esp_1182->dwFFFFFFF4 = ebx_1018;
					esp_1182->dwFFFFFFF0 = eax_1082;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					__gconv_get_builtin_trans(stackArg4, dwArg04);
					ebx_1018 -= 0x3C;
					esi_1017 = *((word32) esi_1017 + 20);
					eax_1107 = edx_1001 - 0x01;
					if (edx_1001 == 0x00)
						goto l080668EF;
					goto l08066816;
				}
				esp_1182->dwFFFFFFF0 = eax_1082;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				word32 ecx_3343;
				Eq_2 eax_1119 = __gconv_find_shlib(gs, stackArg4, out ecx_3343);
				if (eax_1119 != 0x00)
				{
					word32 edi_1189 = *eax_1119;
					ebx_1018->dw0000 = (word32) eax_1119;
					ebx_1018->dw0004 = edi_1189;
					ebx_1018->dw0014 = (word32) *((word32) eax_1119 + 0x0C);
					Eq_2 edi_1195 = *((word32) eax_1119 + 16);
					word32 eax_1196 = *((word32) eax_1119 + 20);
					ebx_1018->dw0018 = 0x00;
					ebx_1018->dw001C = (word32) edi_1195;
					ebx_1018->dw0020 = eax_1196;
					<anonymous> * edi_1202 = __ror(edi_1195, 0x09) ^ gs->t0018;
					if (edi_1202 == null)
					{
l080668CF:
						Eq_2 edi_1360 = __rol(edi_1202 ^ gs->t0018, 0x09);
						esi_1017 = *((word32) esi_1017 + 20);
						ebx_1018->dw0018 = (word32) edi_1360;
						eax_1107 = edx_1001 - 0x01;
						ebx_1018 -= 0x3C;
						if (edx_1001 == 0x00)
						{
l080668EF:
							esi_1148 = *dwArg0C;
							dwLoc60_1838 = eax_969;
							goto l080668FA;
						}
l08066816:
						ecx_1014 = edx_1001;
						edx_1001 = eax_1107;
						goto l08066818;
					}
					esp_1182->dwFFFFFFF0 = edi_1202;
					word32 ecx_1212;
					word32 edx_1213;
					word32 eax_1211 = _dl_mcount_wrapper_check(gs, esp_1182->dwFFFFFFEC, esp_1182->dwFFFFFFF0, out ecx_1212, out edx_1213);
					esp_1182->dwFFFFFFF0 = ebx_1018;
					Eq_2 eax_1220;
					edi_1202();
					if (eax_1220 == 0x00)
					{
						edi_1202 = ebx_1018->dw0018;
						goto l080668CF;
					}
					ebx_1018->dw0020 = (word32) __rol(gs->t0018, 0x09);
					dwLoc40_2049 = eax_1220;
					edi_1035 = ecx_1014 - 0x01;
					if (*dwArg0C <= ecx_1014 - 0x01)
					{
						esp_1182->dwFFFFFFF0 = (word32) eax_969;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 edx_3347;
						word32 ecx_3346;
						free(gs, stackArg0, stackArg4, out ecx_3346, out edx_3347);
						esp_1182->dwFFFFFFF0 = (word32) dwLoc4C_2234;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 ecx_3350;
						word32 edx_3351;
						free(gs, stackArg0, stackArg4, out ecx_3350, out edx_3351);
						esp_1182->dwFFFFFFF0 = (word32) dwLoc54_2232;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 ecx_3354;
						word32 edx_3355;
						free(gs, stackArg0, stackArg4, out ecx_3354, out edx_3355);
						dwArg0C->u0 = 0x00;
						dwArg08->u0 = 0x00;
						esi_1148.u0 = 0x00;
						dwLoc60_1838.u0 = 0x00;
						goto l08066A1B;
					}
l08066986:
					struct Eq_52253 * esp_1245 = esp_1182;
					Eq_2 ebx_1243 = (word32) eax_969 + edi_1035 *s 0x3C;
					do
					{
						struct Eq_53232 * esp_1246 = esp_1245 - (struct Eq_53233 *) 0x0C;
						esp_1246->tFFFFFFFC = ebx_1243;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						word32 edx_3380;
						__gconv_release_step(gs, stackArg4, out edx_3380);
						edi_1035 = (word32) edi_1035 + 1;
						ebx_1243 = (word32) ebx_1243 + 60;
						esp_1245 = esp_1246 + 0x10;
					} while (edi_1035 < *dwArg0C);
					esp_1246->t0000 = eax_969;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_3383;
					word32 edx_3384;
					free(gs, stackArg0, stackArg4, out ecx_3383, out edx_3384);
					esp_1246->t0000 = dwLoc4C_2234;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 edx_3388;
					word32 ecx_3387;
					free(gs, stackArg0, stackArg4, out ecx_3387, out edx_3388);
					esp_1246->t0000 = dwLoc54_2232;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_3391;
					word32 edx_3392;
					free(gs, stackArg0, stackArg4, out ecx_3391, out edx_3392);
					dwArg0C->u0 = 0x00;
					dwArg08->u0 = 0x00;
					esi_1148.u0 = 0x00;
					esp_1182 = esp_1246 + 0x10;
					dwLoc60_1838.u0 = 0x00;
					if (dwLoc40_2049 == 0x00)
					{
						dwLoc40_2049.u0 = 0x01;
						dwLoc60_1838 = dwLoc40_2049;
						esi_1148 = dwLoc40_2049;
					}
l08066A1B:
					struct Eq_53122 * esp_1560 = esp_1182 - (struct Eq_53123 *) 0x0C;
					esp_1560->tFFFFFFFC = dwLoc74_1793;
					word32 ecx_3356;
					word32 edx_3357;
					Eq_2 eax_1567 = strlen(esp_1560->tFFFFFFFC, out ecx_3356, out edx_3357);
					esp_1560->tFFFFFFFC = eax_40;
					word32 edx_3359;
					word32 ecx_3358;
					Eq_2 eax_1580 = strlen(esp_1560->tFFFFFFFC, out ecx_3358, out edx_3359);
					esp_1560->tFFFFFFFC = (word32) eax_1567 + 0x0011 + ((word32) eax_1580 + 1);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 esi_3365;
					word32 edi_3366;
					word32 ebx_3363;
					word32 ecx_3362;
					word32 ebp_3364;
					Eq_2 eax_1608 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3362, out edx_1390, out ebx_3363, out ebp_3364, out esi_3365, out edi_3366);
					dwLoc44_2223 = (word32) eax_1580 + 1;
					esp_1182 = esp_1560 + 0x0C;
					ecx_1388 = eax_1608;
					if (eax_1608 != 0x00)
					{
						*eax_1608 = (word32) eax_1608 + 16;
						esp_1560[1] = (struct Eq_53122) ((word32) eax_1567 + 1);
						esp_1560->t0000 = dwLoc74_1793;
						esp_1560->tFFFFFFFC = (word32) eax_1608 + 16;
						word32 edx_3393;
						Eq_2 eax_1630 = __mempcpy(esp_1560->tFFFFFFFC, esp_1560->t0000, esp_1560[1], out edx_3393);
						esp_1560[1] = (struct Eq_53122) ((word32) eax_1580 + 1);
						esp_1560->t0000 = eax_40;
						esp_1560->tFFFFFFFC = eax_1630;
						word32 ecx_3394;
						word32 edx_3395;
						*((word32) eax_1608 + 4) = memcpy(esp_1560->tFFFFFFFC, esp_1560->t0000, esp_1560[1], out ecx_3394, out edx_3395);
						*((word32) eax_1608 + 0x0C) = esi_1148;
						*((word32) eax_1608 + 8) = dwLoc60_1838;
						esp_1560[1] = (struct Eq_53122) dwLoc7C_2510;
						esp_1560->t0000 = dwLoc80_2566;
						esp_1560->tFFFFFFFC = eax_1608;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						dwLoc44_2223 = eax_1608;
						esp_1182 = esp_1560 + 0x0C;
						ecx_1388 = eax_1608;
						word32 ecx_3397;
						if (__tsearch(stackArg4, dwArg04, dwArg08, out ecx_3397, out edx_1390) == null)
						{
							esp_1560->tFFFFFFFC = eax_1608;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							Eq_2 stackArg4 = <invalid>;
							free(gs, stackArg0, stackArg4, out ecx_1388, out edx_1390);
							esp_1182 = esp_1560 + 0x0C;
						}
					}
					goto l08066AA8;
				}
l0806696F:
				edi_1035 = (word32) edx_1001 + 1;
				goto l08066974;
			}
		}
		else
		{
			struct Eq_52671 * esp_815 = esp_1182 - (struct Eq_52672 *) 0x0C;
			esp_815->tFFFFFFFC.u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			word32 esi_3325;
			word32 ecx_3321;
			word32 edx_3322;
			word32 ebx_3323;
			word32 ebp_3324;
			word32 edi_3326;
			Eq_2 eax_931 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_3321, out edx_3322, out ebx_3323, out ebp_3324, out esi_3325, out edi_3326);
			esp_1182 = esp_815 + 0x0C;
			dwLoc60_1838 = eax_931;
			if (eax_931 != 0x00)
			{
				dwArg0C->u0 = 0x00;
				esi_1148.u0 = 0x00;
l080668FA:
				*dwArg08 = dwLoc60_1838;
				dwLoc40_2049.u0 = 0x00;
				goto l08066A1B;
			}
		}
		dwArg0C->u0 = 0x00;
		dwArg08->u0 = 0x00;
		dwLoc60_1838.u0 = 0x00;
		esi_1148.u0 = 0x00;
		dwLoc40_2049.u0 = 0x03;
		goto l08066A1B;
	}
	Eq_2 esi_279 = __gconv_modules_db;
	if (esi_279 == 0x00)
		goto l080663FB;
	Eq_2 ebx_284 = *dwLoc44_1829;
	while (true)
	{
		struct Eq_52502 * esp_286 = esp_1182 - (struct Eq_52503 *) 0x08;
		esp_286->tFFFFFFFC = *esi_279;
		esp_286->tFFFFFFF8 = ebx_284;
		word32 edx_3316;
		word32 ecx_3315;
		Eq_2 eax_296 = strcmp(esp_286->tFFFFFFF8, esp_286->tFFFFFFFC, out ecx_3315, out edx_3316);
		esp_1182 = esp_286 + 0x08;
		bool v61_1776 = eax_296 > 0x00;
		if (eax_296 == 0x00)
			break;
		if (eax_296 < 0x00)
			esi_279 = *((word32) esi_279 + 20);
		else
			esi_279 = *((word32) esi_279 + 28);
		if (esi_279 == 0x00)
			goto l080663FB;
	}
	Eq_2 dwLoc40_1847 = esi_279;
	Eq_2 eax_309 = dwLoc48_1827;
l080664A7:
	Eq_2 ebx_314 = *((word32) dwLoc40_1847 + 4);
	cu8 * edi_313 = &g_b80A4D0B;
	word32 ecx_315 = 0x02;
	Eq_2 esi_316 = ebx_314;
	while (ecx_315 != 0x00)
	{
		v61_1776 = *esi_3413 > *edi_3414;
		esi_316 = (word32) esi_3413 + 1;
		edi_313 = edi_3414 + 1;
		--ecx_315;
		esi_3413 = esi_316;
		edi_3414 = edi_313;
		if (*esi_3413 == *edi_3414)
			break;
	}
	if ((int8) v61_1776 - (*esi_3413 < *edi_3414) == 0x00)
		ebx_314 = eax_40;
	word32 eax_347 = eax_309 + Mem311[dwLoc40_1847 + 0x08:word32];
	struct Eq_52640 * esp_352 = esp_1182 - (struct Eq_52641 *) 0x08;
	word32 esi_357 = Mem311[dwLoc44_1829 + 0x08:word32] + Mem311[dwLoc40_1847 + 0x0C:word32];
	esp_352->tFFFFFFFC = eax;
	esp_352->tFFFFFFF8 = ebx_314;
	word32 edx_3318;
	word32 ecx_3317;
	if (strcmp(esp_352->tFFFFFFF8, esp_352->tFFFFFFFC, out ecx_3317, out edx_3318) != 0x00)
	{
		if (edx != 0x00)
		{
			esp_352->tFFFFFFFC = edx;
			esp_352->tFFFFFFF8 = ebx_314;
			word32 ecx_3402;
			word32 edx_3403;
			if (strcmp(esp_352->tFFFFFFF8, esp_352->tFFFFFFFC, out ecx_3402, out edx_3403) == 0x00)
				goto l080664F0;
		}
		if (dwLoc4C_1837 > eax_347 || dwLoc4C_1837 == eax_347 && dwLoc54_1828 > esi_357)
		{
			Eq_2 esi_412 = dwLoc70_1807;
			do
			{
				struct Eq_53500 * esp_414 = esp_1182 - (struct Eq_53501 *) 0x08;
				esp_414->tFFFFFFFC = *esi_412;
				esp_414->tFFFFFFF8 = ebx_314;
				esp_1182 = esp_414 + 0x08;
				word32 edx_3406;
				word32 ecx_3405;
				if (strcmp(esp_414->tFFFFFFF8, esp_414->tFFFFFFFC, out ecx_3405, out edx_3406) == 0x00)
				{
					if (*((word32) esi_412 + 0x0C) > eax_347 || *((word32) esi_412 + 0x0C) == eax_347 && *((word32) esi_412 + 8) > esi_357)
					{
						*((word32) esi_412 + 16) = dwLoc40_1847;
						*((word32) esi_412 + 20) = dwLoc44_1829;
						Eq_2 esi_451 = dwLoc70_1807;
						do
						{
							Eq_2 eax_454 = *((word32) esi_451 + 16);
							if (eax_454 != 0x00)
							{
								Eq_2 edx_462 = *((word32) esi_451 + 20);
								Eq_2 ebx_463 = *((word32) eax_454 + 8);
								int32 ecx_464 = *((word32) eax_454 + 0x0C);
								struct Eq_53632 * eax_465 = *((word32) edx_462 + 16);
								while (eax_465 != null)
								{
									edx_462 = *((word32) edx_462 + 20);
									ebx_463 = (word32) ebx_463 + eax_465->dw0008;
									ecx_464 += eax_465->dw000C;
									eax_465 = (struct Eq_53632 *) *((word32) edx_462 + 16);
								}
								*((word32) esi_451 + 0x0C) = ebx_463;
								*((word32) esi_451 + 8) = ecx_464;
								esi_451 = *((word32) esi_451 + 24);
								if (esi_451 == 0x00)
									break;
								continue;
							}
							esi_451 = *((word32) esi_451 + 24);
						} while (esi_451 != 0x00);
						Eq_2 eax_498 = dwLoc60_1838;
						if (dwLoc60_1838 != 0x00)
						{
							Eq_2 esi_502 = dwLoc4C_1837;
							int32 ebx_503 = dwLoc54_1828;
							do
							{
								Eq_2 ecx_507 = *((word32) eax_498 + 20);
								Eq_2 edi_506 = *((word32) eax_498 + 16);
								word32 edx_510 = Mem505[ecx_507 + 0x0C:word32] + Mem505[edi_506 + 0x08:word32];
								word32 ecx_511 = Mem505[ecx_507 + 0x08:word32] + Mem505[edi_506 + 0x0C:word32];
								*((word32) eax_498 + 0x0C) = edx_510;
								*((word32) eax_498 + 8) = ecx_511;
								if (edx_510 >= esi_502)
								{
									if (edx_510 == esi_502 && ecx_511 < ebx_503)
										ebx_503 = ecx_511;
									eax_498 = *((word32) eax_498 + 24);
									if (eax_498 != 0x00)
										continue;
									break;
								}
								eax_498 = *((word32) eax_498 + 24);
								ebx_503 = ecx_511;
								esi_502 = edx_510;
							} while (eax_498 != 0x00);
							dwLoc4C_1837 = esi_502;
							dwLoc54_1828 = ebx_503;
						}
					}
					goto l08066490;
				}
				esi_412 = *((word32) esi_412 + 24);
			} while (esi_412 != 0x00);
			if (esp_414 + 0x08 != esp_414 + 0x08)
			{
				do
				{
					esp_1182 -= (struct Eq_53585 *) 0x1000;
					esp_1182[0x03FF] = esp_1182[0x03FF];
				} while (esp_1182 != esp_414 + 0x08);
			}
			struct Eq_52253 * esp_560 = esp_1182 - (struct Eq_53532 *) 0x30;
			esp_560[11] = esp_560[11];
			word32 edx_567 = esp_560 + 0x0F & ~0x0F;
			edx_567->t0000 = ebx_314;
			esp_560->dwFFFFFFF0 = (word32) ebx_314;
			word32 ecx_3407;
			word32 edx_3408;
			Eq_2 eax_576 = strlen(esp_560->dwFFFFFFF0, out ecx_3407, out edx_3408);
			edx_567->t000C = eax_347;
			edx_567->t0004 = eax_576;
			edx_567->dw0018 = 0x00;
			edx_567->dw0008 = esi_357;
			edx_567->t0010 = dwLoc40_1847;
			edx_567->t0014 = dwLoc44_1829;
			*dwLoc84_1808 = edx_567;
			esp_1182 = esp_560;
			dwLoc84_1808 = &edx_567->dw0018;
		}
		goto l08066490;
	}
	else
	{
l080664F0:
		if (dwLoc60_1838 != 0x00)
		{
			Eq_2 esi_608 = dwLoc60_1838;
			do
			{
				struct Eq_52713 * esp_610 = esp_1182 - (struct Eq_52714 *) 0x08;
				esp_610->tFFFFFFFC = *esi_608;
				esp_610->tFFFFFFF8 = ebx_314;
				esp_1182 = esp_610 + 0x08;
				word32 ecx_3327;
				word32 edx_3328;
				if (strcmp(esp_610->tFFFFFFF8, esp_610->tFFFFFFFC, out ecx_3327, out edx_3328) == 0x00)
				{
					if (*((word32) esi_608 + 0x0C) > eax_347 || *((word32) esi_608 + 0x0C) == eax_347 && *((word32) esi_608 + 8) > esi_357)
					{
						*((word32) esi_608 + 0x0C) = eax_347;
						*((word32) esi_608 + 16) = dwLoc40_1847;
						*((word32) esi_608 + 20) = dwLoc44_1829;
						*((word32) esi_608 + 8) = esi_357;
					}
					goto l0806652C;
				}
				esi_608 = *((word32) esi_608 + 24);
			} while (esi_608 != 0x00);
		}
		struct Eq_52253 * esp_650 = esp_1182 - (struct Eq_52841 *) 0x30;
		esp_650[11] = esp_650[11];
		word32 edx_658 = esp_650 + 0x0F & ~0x0F;
		*edx_658 = ebx_314;
		esp_650->dwFFFFFFF0 = (word32) ebx_314;
		word32 edx_3338;
		word32 ecx_3337;
		Eq_2 eax_669 = strlen(esp_650->dwFFFFFFF0, out ecx_3337, out edx_3338);
		*((word32) edx_658 + 0x0C) = eax_347;
		*((word32) edx_658 + 4) = eax_669;
		*((word32) edx_658 + 8) = esi_357;
		*((word32) edx_658 + 16) = dwLoc40_1847;
		*((word32) edx_658 + 20) = dwLoc44_1829;
		*((word32) edx_658 + 24) = dwLoc60_1838;
		esp_1182 = esp_650;
		dwLoc60_1838 = edx_658;
l0806652C:
		if (dwLoc4C_1837 <= eax_347)
		{
			if (dwLoc4C_1837 == eax_347)
			{
				int32 eax_726 = esi_357;
				if (dwLoc54_1828 <= esi_357)
					eax_726 = dwLoc54_1828;
				dwLoc54_1828 = eax_726;
			}
		}
		else
		{
			dwLoc4C_1837 = eax_347;
			dwLoc54_1828 = esi_357;
		}
l08066490:
		Eq_2 eax_736 = *((word32) dwLoc40_1847 + 24);
		dwLoc40_1847 = eax_736;
		v61_1776 = eax_736 > 0x00;
		if (eax_736 == 0x00)
			goto l080663FB;
		eax_309 = *((word32) dwLoc44_1829 + 0x0C);
		goto l080664A7;
	}
}

// 08066C30: Register Eq_2 __gconv_compare_alias(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_53843) ebxOut, Register out (ptr32 Eq_53844) ebpOut, Register out (ptr32 Eq_53845) esiOut)
// Called from:
//      _nl_find_locale
Eq_2 __gconv_compare_alias(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_53843 & ebxOut, struct Eq_53844 & ebpOut, struct Eq_5104 & esiOut)
{
	ui32 eax_20 = gs->dw0014;
	Eq_2 esi_23 = dwArg04;
	Eq_2 edi_24 = dwArg08;
	if (once == 0x00)
	{
		struct Eq_53901 * ebx_35 = __gconv_read_conf(gs, out esi_23, out edi_24);
		ebx_35->dw193C |= 0x02;
	}
	Eq_2 eax_166;
	word32 ebx_78;
	Eq_2 edi_80;
	Eq_2 esi_82;
	if (__gconv_compare_alias_cache(gs, esi_23, edi_24, fp - 44, out ebx_78, out esi_82, out edi_80) == 0x00)
		eax_166 = dwLoc2C;
	else
	{
		Eq_2 ebx_120 = edi_80;
		Eq_2 eax_107 = __tfind(fp - 0x28, ebx_78 + 8068, ebx_78 + ~0x0006804F);
		if (eax_107 != 0x00)
		{
			ebx_120 = *((word32) *eax_107 + 4);
			if (ebx_120 == 0x00)
				ebx_120 = edi_80;
		}
		Eq_2 eax_149;
		Eq_2 eax_139 = __tfind(fp - 0x28, ebx_78 + 8068, ebx_78 + ~0x0006804F);
		if (eax_139 != 0x00)
		{
			eax_149 = *((word32) *eax_139 + 4);
			if (eax_149 == 0x00)
				eax_149 = esi_82;
		}
		else
			eax_149 = esi_82;
		word32 ecx_299;
		word32 edx_300;
		eax_166 = strcmp(eax_149, ebx_120, out ecx_299, out edx_300);
	}
	if ((eax_20 ^ gs->dw0014) != 0x00)
	{
		word32 edx_298;
		word32 ecx_297;
		Eq_2 eax_186 = __stack_chk_fail(out ecx_297, out edx_298);
		Eq_2 esp_187 = <invalid>;
		struct Eq_53844 * ebp_196;
		struct Eq_53843 * ebx_197;
		struct Eq_5104 * esi_203;
		__gconv_find_transform(gs, *((word32) esp_187 + 4), *((word32) esp_187 + 8), *((word32) esp_187 + 0x0C), *((word32) esp_187 + 16), *((word32) esp_187 + 20), out ebx_197, out ebp_196, out esi_203);
		ebxOut = ebx_197;
		ebpOut = ebp_196;
		esiOut = esi_203;
		return eax_186;
	}
	else
	{
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		return eax_166;
	}
}

// 08066D60: Register Eq_2 __gconv_find_transform(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out Eq_979 ebxOut, Register out Eq_979 ebpOut, Register out Eq_43086 esiOut)
// Called from:
//      __wcsmbs_getfct
//      __gconv_open
//      __gconv_compare_alias
Eq_2 __gconv_find_transform(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, union Eq_979 & ebxOut, union Eq_979 & ebpOut, union Eq_43086 & esiOut)
{
	byte bArg14_521 = (byte) dwArg14;
	ui32 eax_27 = gs->dw0014;
	if (once == 0x00)
	{
		word32 edi_722;
		word32 esi_721;
		__gconv_read_conf(gs, out esi_721, out edi_722);
		once |= 0x02;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_70;
	if (!__cmpxchg(__gconv_lock, 0x01, 0x00, out eax_70))
		__lll_lock_wait_private(eax_70, 0x080CFF80, gs);
	Eq_2 ecx_114;
	Eq_2 eax_113 = __gconv_lookup_cache(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, out ecx_114);
	Eq_2 edx_118 = eax_113;
	if (eax_113 == 0x02)
	{
		Eq_2 edx_134 = __gconv_modules_db;
		if (edx_134 != 0x00)
		{
			Eq_2 eax_166 = __tfind(fp - 0x28, 0x080CFF84, 0x08065FB0);
			Eq_2 edx_176 = eax_166;
			if (eax_166 != 0x00)
				edx_176 = *((word32) *eax_166 + 4);
			Eq_2 eax_196 = __tfind(fp - 0x28, 0x080CFF84, 0x08065FB0);
			Eq_2 ebp_206 = eax_196;
			if (eax_196 != 0x00)
				ebp_206 = *((word32) *eax_196 + 4);
			if ((bArg14_521 & 0x01) == 0x00)
			{
l08066E84:
				Eq_2 ecx_361;
				word32 edx_723;
				Eq_2 eax_360 = find_derivation(dwArg04, dwArg08, ebp_206, gs, edx_176, dwArg0C, dwArg10, out ecx_361, out edx_723);
				edx_118 = eax_360;
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v24_369 = __gconv_lock - 0x01;
				__gconv_lock = v24_369;
				if (v24_369 != 0x00)
					__lll_unlock_wake_private(0x080CFF80, ecx_361, eax_360, gs);
				if (eax_360 == 0x00)
					edx_118 = (uint32) (int8) (*dwArg0C == 0x00);
				goto l08066EF7;
			}
			Eq_2 ecx_227;
			Eq_2 edx_228;
			if (strcmp(dwArg04, dwArg08, out ecx_227, out edx_228) != 0x00)
			{
				if (ebp_206 != 0x00)
				{
					edx_228 = edx_176;
					word32 edx_731;
					if (strcmp(ebp_206, dwArg08, out ecx_227, out edx_731) == 0x00)
						goto l08066FE8;
				}
				if (edx_176 == 0x00)
					goto l08066E84;
				if (strcmp(dwArg04, edx_176, out ecx_227, out edx_228) != 0x00)
				{
					if (ebp_206 == 0x00)
						goto l08066E84;
					edx_228 = edx_176;
					word32 edx_732;
					if (strcmp(ebp_206, edx_176, out ecx_227, out edx_732) != 0x00)
						goto l08066E84;
				}
			}
l08066FE8:
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v26_321 = __gconv_lock - 0x01;
			__gconv_lock = v26_321;
			if (v26_321 != 0x00)
				__lll_unlock_wake_private(0x080CFF80, ecx_227, edx_228, gs);
			edx_118.u0 = ~0x00;
			goto l08066EF7;
		}
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v20_142 = __gconv_lock - 0x01;
		__gconv_lock = v20_142;
		if (v20_142 != 0x00)
			__lll_unlock_wake_private(0x080CFF80, ecx_114, edx_134, gs);
		edx_118.u0 = 0x01;
	}
	else
	{
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v23_125 = __gconv_lock - 0x01;
		__gconv_lock = v23_125;
		if (v23_125 != 0x00)
			__lll_unlock_wake_private(0x080CFF80, ecx_114, eax_113, gs);
	}
l08066EF7:
	Eq_43086 esi_408 = eax_27 ^ gs->dw0014;
	if (esi_408 != 0x00)
	{
		word32 edx_725;
		word32 ecx_724;
		__stack_chk_fail(out ecx_724, out edx_725);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		word32 edx_729;
		word32 esi_730;
		Eq_2 eax_453 = __gconv_close_transform(edx, gs, stackArg4, stackArg8, out edx_729, out esi_730);
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi_408;
		return eax_453;
	}
	else
	{
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		return edx_118;
	}
}

// 08067020: Register word32 __gconv_close_transform(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 edxOut, Register out ptr32 esiOut)
// Called from:
//      _nl_cleanup_ctype
//      __wcsmbs_getfct
//      __wcsmbs_load_conv
//      __wcsmbs_named_conv
//      __gconv_open
//      __gconv_close
//      __gconv_find_transform
word32 __gconv_close_transform(Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & edxOut, ptr32 & esiOut)
{
	ptr32 esp_20 = fp - 0x1C;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_30;
	if (!__cmpxchg(__gconv_lock, 0x01, 0x00, out eax_30))
		__lll_lock_wait_private(eax_30, 0x080CFF80, gs);
	if (dwArg08 != 0x00)
	{
		Eq_2 ebx_49 = dwArg04 - 0x3C + dwArg08 *s 0x3C;
		while (true)
		{
			struct Eq_54259 * esp_51 = esp_20 - 0x0C;
			esp_51->tFFFFFFFC = ebx_49;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			word32 edx_179;
			__gconv_release_step(gs, stackArg4, out edx_179);
			Eq_2 eax_65 = ebx_49 - 0x3C;
			esp_20 = (char *) &esp_51->tFFFFFFFC + 20;
			if (ebx_49 == dwArg04)
				break;
			ebx_49 = eax_65;
		}
	}
	Eq_2 ecx_92 = __gconv_release_cache();
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v14_98 = __gconv_lock - 0x01;
	__gconv_lock = v14_98;
	if (v14_98 != 0x00)
		__lll_unlock_wake_private(0x080CFF80, ecx_92, edx, gs);
	edxOut = edx;
	esiOut = esi;
	return 0x00;
}

// 080670C0: void insert_module(Register Eq_2 eax, Register word32 edx)
// Called from:
//      add_module.isra.0
//      __gconv_read_conf
void insert_module(Eq_2 eax, word32 edx)
{
	struct Eq_54294 * esi_144 = &__gconv_modules_db;
	while (true)
	{
		Eq_2 ebx_143 = esi_144->dw0000;
		if (ebx_143 == 0x00)
			break;
		Eq_2 edi_33 = *eax;
		word32 edx_281;
		word32 ecx_280;
		Eq_2 eax_42 = strcmp(edi_33, *ebx_143, out ecx_280, out edx_281);
		if (eax_42 == 0x00)
		{
			while (true)
			{
				word32 ecx_282;
				word32 edx_283;
				if (strcmp(*((word32) eax + 4), *((word32) ebx_143 + 4), out ecx_282, out edx_283) == 0x00)
					break;
				do
				{
					esi_144 = (word32) ebx_143 + 24;
					ebx_143 = *((word32) ebx_143 + 24);
					if (ebx_143 == 0x00)
						goto l0806710C;
					word32 ecx_284;
					word32 edx_285;
				} while (strcmp(edi_33, *ebx_143, out ecx_284, out edx_285) != 0x00);
			}
			int32 eax_76 = *((word32) ebx_143 + 8);
			if (*((word32) eax + 8) < eax_76 || *((word32) eax + 8) == eax_76 && *((word32) eax + 0x0C) < *((word32) ebx_143 + 0x0C))
			{
				*((word32) eax + 20) = *((word32) ebx_143 + 20);
				*((word32) eax + 28) = *((word32) ebx_143 + 28);
				*((word32) eax + 24) = *((word32) ebx_143 + 24);
				esi_144->dw0000 = (word32) eax;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ecx_288;
				word32 edx_289;
				free(gs, stackArg0, ebx_143, out ecx_288, out edx_289);
				return;
			}
			else
			{
				if (edx != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 ecx_291;
					word32 edx_292;
					free(gs, stackArg0, eax, out ecx_291, out edx_292);
				}
				return;
			}
		}
		esi_144 = (word32) ebx_143 + 20;
		if (eax_42 >= 0x00)
			esi_144 = (word32) ebx_143 + 28;
	}
l0806710C:
	esi_144->dw0000 = (word32) eax;
}

// 080671B0: Register Eq_2 detect_conflict(Register Eq_2 eax)
// Called from:
//      __gconv_read_conf
Eq_2 detect_conflict(Eq_2 eax)
{
	Eq_2 ebx_13 = __gconv_modules_db;
	while (ebx_13 != 0x00)
	{
		word32 ecx_98;
		word32 edx_99;
		Eq_2 eax_30 = strcmp(eax, *ebx_13, out ecx_98, out edx_99);
		if (eax_30 == 0x00)
			return 0x01;
		if (eax_30 < 0x00)
		{
			ebx_13 = *((word32) ebx_13 + 20);
			if (ebx_13 == 0x00)
				return 0x00;
			continue;
		}
		ebx_13 = *((word32) ebx_13 + 28);
	}
	return 0x00;
}

// 08067210: void add_module.isra.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __gconv_read_conf
void add_module.isra.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_12 = eax;
	int32 ecx_888 = (int32) *eax;
	ui32 eax_29 = gs->dw0014;
	Eq_2 eax_32 = g_t80CE08C;
	while ((*((word32) eax_32 + (ecx_888 * 0x02 + 1)) & 0x20) != 0x00)
	{
		edi_12 = (word32) edi_12 + 1;
		ecx_888 = (int32) *edi_12;
	}
	if ((byte) ecx_888 != 0x00)
	{
		Eq_2 ebx_520 = edi_12;
		Eq_3851 ecx_58[] = g_ptr80CE084;
		while (true)
		{
			*ebx_520 = ecx_58[ecx_888];
			ecx_888 = (int32) *((word32) ebx_520 + 1);
			Eq_2 esi_64 = (word32) ebx_520 + 1;
			if ((byte) ecx_888 == 0x00)
				break;
			if ((*((word32) eax_32 + (ecx_888 * 0x02 + 1)) & 0x20) != 0x00)
			{
				Eq_2 ebx_111;
				int32 edx_108 = (int32) *((word32) esi_64 + 1);
				*esi_64 = 0x00;
				Eq_2 ebx_77 = (word32) ebx_520 + 2;
				byte bLoc34_605 = (byte) edx_108;
				ebx_111 = ebx_77;
				if ((*((word32) eax_32 + (edx_108 * 0x02 + 1)) & 0x20) != 0x00)
				{
					ebx_111 = ebx_77;
					do
					{
						ebx_111 = (word32) ebx_111 + 1;
						int32 esi_89 = (int32) *ebx_111;
						edx_108 = esi_89;
						byte dl_95 = (byte) esi_89;
					} while ((*((word32) eax_32 + (esi_89 * 0x02 + 1)) & 0x20) != 0x00);
					bLoc34_605 = dl_95;
				}
				struct Eq_54562 * esi_101 = (word32) ebx_77 + 2;
				if (bLoc34_605 != 0x00)
				{
					while (true)
					{
						struct Eq_54562 * edi_114 = &esi_101->b0001;
						edi_114->tFFFFFFFF = ecx_58[edx_108];
						ebx_111 = (word32) ebx_111 + 1;
						edx_108 = (int32) *ebx_111;
						if ((byte) edx_108 == 0x00)
							break;
						if ((*((word32) eax_32 + (edx_108 * 0x02 + 1)) & 0x20) != 0x00)
						{
							edi_114->b0000 = 0x00;
							Eq_2 ecx_128 = &esi_101->b0000;
							do
							{
								ebx_111 = (word32) ebx_111 + 1;
								int32 ecx_137 = (int32) *ebx_111;
								byte cl_143 = (byte) ecx_137;
								byte dl_156 = (byte) ecx_137;
							} while ((*((word32) eax_32 + (ecx_137 * 0x02 + 1)) & 0x20) != 0x00);
							Eq_2 dwLoc48_620;
							struct Eq_54640 * esi_176;
							Eq_2 ecx_148;
							if (cl_143 != 0x00)
							{
								Eq_2 esi_149 = (word32) ecx_128 + 2;
								while (true)
								{
									ecx_148 = (word32) esi_149 + 1;
									*((word32) ecx_148 - 1) = dl_156;
									ebx_111 = (word32) ebx_111 + 1;
									dl_156 = (byte) *ebx_111;
									if (dl_156 == 0x00)
										break;
									if ((*((word32) eax_32 + ((int32) dl_156 * 0x02 + 1)) & 0x20) != 0x00)
									{
										*ecx_148 = 0x00;
										Eq_2 eax_183 = __strtol(gs, ebx_111, fp - 0x28, 0x0A);
										esi_176 = (struct Eq_54640 *) esi_149;
										dwLoc48_620 = eax_183;
										if (dwLoc28 == ebx_111 || eax_183 <= 0x00)
											dwLoc48_620.u0 = 0x01;
										goto l08067370;
									}
									esi_149 = ecx_148;
								}
							}
							else
								ecx_148 = ecx_128;
							*ecx_148 = 0x00;
							esi_176 = (word32) ecx_148 + 1;
							dwLoc48_620.u0 = 0x01;
l08067370:
							byte al_209 = edi_114->b0001;
							if (al_209 != 0x00)
							{
								Eq_2 eax_214 = 0x00;
								if (al_209 != 0x2F)
									eax_214 = ecx;
								ui32 dwLoc40_635 = 0x03;
								Eq_2 eax_225 = esi_176 - ecx_128;
								if (eax_225 > 0x03)
									dwLoc40_635 = (uint32) (int8) (esi_176->tFFFFFFFC != 7303982) * 0x03;
								Eq_2 eax_253 = ebx_77 - edi_12;
								word32 ecx_889;
								word32 edx_890;
								Eq_2 eax_260 = strnlen(edi_12, eax_253, out ecx_889, out edx_890);
								struct Eq_54720 * esp_267 = fp - 0x5C;
								struct Eq_54720 * ebx_272 = fp - 0x5C - ((word32) eax_260 + 28 & ~0x0FFF);
								ui32 ecx_273 = (word32) eax_260 + 28 & ~0x0F;
								if (fp - 0x5C != ebx_272)
								{
									do
									{
										esp_267 -= 0x1000;
										esp_267->dw0FFC = esp_267->dw0FFC;
									} while (esp_267 != ebx_272);
								}
								if ((ecx_273 & 0x0FFF) != 0x00)
								{
									esp_267 -= ecx_273 & 0x0FFF;
									(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_267 - 0x04)[(ecx_273 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_267 - 0x04)[(ecx_273 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
								}
								Eq_54763 edx_300 = (char *) esp_267 + 0x0F;
								Mem313[(edx_300 & ~0x0F) + eax_260:byte] = 0x00;
								struct Eq_54771 * esp_301 = esp_267 - 0x04;
								esp_301->tFFFFFFFC = eax_260;
								esp_301->tFFFFFFF8 = edi_12;
								esp_301->tFFFFFFF4 = edx_300 & ~0x0F;
								word32 edx_892;
								word32 ecx_891;
								memcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out ecx_891, out edx_892);
								esp_301->tFFFFFFFC.u0 = 0x08065FB0;
								esp_301->tFFFFFFF8.u0 = 0x080CFF84;
								esp_301->tFFFFFFF4 = fp - 0x28;
								if (__tfind(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC) == 0x00)
								{
									esp_301->tFFFFFFF8 = esi_176 - edi_12 + ((word32) eax_214 + 32) + dwLoc40_635;
									esp_301->tFFFFFFF4.u0 = 0x01;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg4 = <invalid>;
									word32 edx_895;
									word32 ecx_894;
									word32 edi_899;
									word32 ebx_896;
									word32 ebp_897;
									word32 esi_898;
									Eq_2 eax_390 = __libc_calloc(gs, stackArg4, dwArg04, out ecx_894, out edx_895, out ebx_896, out ebp_897, out esi_898, out edi_899);
									if (eax_390 != 0x00)
									{
										*eax_390 = (word32) eax_390 + 32;
										esp_301->tFFFFFFFC = eax_253;
										esp_301->tFFFFFFF8 = edi_12;
										esp_301->tFFFFFFF4 = (word32) eax_390 + 32;
										word32 edx_900;
										Eq_2 eax_412 = __mempcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out edx_900);
										*((word32) eax_390 + 4) = eax_412;
										esp_301->tFFFFFFFC = ecx_128 - ebx_77;
										esp_301->tFFFFFFF8 = ebx_77;
										esp_301->tFFFFFFF4 = eax_412;
										word32 edx_901;
										Eq_2 eax_432 = __mempcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out edx_901);
										*((word32) eax_390 + 16) = eax_432;
										*((word32) eax_390 + 8) = dwLoc48_620;
										*((word32) eax_390 + 0x0C) = dwArg04;
										if (eax_214 != 0x00)
										{
											esp_301->tFFFFFFFC = eax_214;
											esp_301->tFFFFFFF8 = edx;
											esp_301->tFFFFFFF4 = eax_432;
											word32 edx_902;
											eax_432 = __mempcpy(esp_301->tFFFFFFF4, esp_301->tFFFFFFF8, esp_301->tFFFFFFFC, out edx_902);
										}
										struct Eq_54944 * esp_472 = esp_267 - 0x04;
										esp_472->tFFFFFFFC = eax_225;
										esp_472->tFFFFFFF8 = ecx_128;
										esp_472->tFFFFFFF4 = eax_432;
										word32 edx_903;
										Eq_2 eax_487 = __mempcpy(esp_472->tFFFFFFF4, esp_472->tFFFFFFF8, esp_472->tFFFFFFFC, out edx_903);
										if (dwLoc40_635 != 0x00)
											*((word32) eax_487 - 1) = gconv_module_ext;
										insert_module(eax_390, 0x01);
									}
								}
							}
							break;
						}
						esi_101 = edi_114;
					}
				}
				break;
			}
			ebx_520 = esi_64;
		}
	}
	if ((eax_29 ^ gs->dw0014) == 0x00)
		return;
	struct Eq_54525 * edx_574;
	byte * ecx_575;
	Eq_2 eax_573 = __stack_chk_fail(out ecx_575, out edx_574);
	add_alias2.isra.1.part.2(eax_573, ecx_575, edx_574);
}

// 08067580: void add_alias2.isra.1.part.2(Register Eq_2 eax, Register (ptr32 byte) ecx, Register (ptr32 Eq_54525) edx)
// Called from:
//      add_module.isra.0
//      __gconv_read_conf
void add_alias2.isra.1.part.2(Eq_2 eax, byte * ecx, struct Eq_54525 * edx)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 ecx_9 = ecx - eax;
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_148;
	word32 edx_149;
	word32 ebx_150;
	word32 ebp_151;
	word32 esi_152;
	word32 edi_153;
	Eq_2 eax_31 = __libc_malloc(gs, stackArg0, (word32) ecx_9 + 8, out ecx_148, out edx_149, out ebx_150, out ebp_151, out esi_152, out edi_153);
	if (eax_31 != 0x00)
	{
		word32 ecx_154;
		word32 edx_155;
		Eq_2 eax_48 = memcpy((word32) eax_31 + 8, eax, ecx_9, out ecx_154, out edx_155);
		*eax_31 = eax_48;
		*((word32) eax_31 + 4) = (word32) eax_48 + (edx - eax);
		word32 ecx_156;
		word32 edx_157;
		union Eq_2 * eax_72 = __tsearch(eax_31, 0x080CFF84, 0x08065FB0, out ecx_156, out edx_157);
		if (eax_72 == null || eax_31 != *eax_72)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_159;
			word32 edx_160;
			free(gs, stackArg0, eax_31, out ecx_159, out edx_160);
		}
	}
}

// 08067600: void __gconv_get_path(Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      __gconv_read_conf
void __gconv_get_path(Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 ecx_36 = 0x01;
	struct Eq_55055 * esp_20 = fp - 0x4C;
	ui32 eax_22 = gs->dw0014;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_31;
	if (!__cmpxchg(lock.12667, 0x01, 0x00, out eax_31))
		ecx_36 = __lll_lock_wait_private(eax_31, 0x080CF948, gs);
	Eq_2 esi_259 = __gconv_path_elem;
	if (esi_259 == 0x00)
	{
		Eq_2 dwLoc40_647;
		Eq_2 dwLoc44_648;
		int32 dwLoc48_646;
		struct Eq_55087 * esp_201;
		word32 dwLoc3C_650;
		Eq_2 eax_47 = __gconv_path_envvar;
		Eq_2 dwLoc34_645 = eax_47;
		if (eax_47 != 0x00)
		{
			word32 ecx_835;
			word32 edx_836;
			Eq_2 eax_105 = strlen(eax_47, out ecx_835, out edx_836);
			struct Eq_55120 * esp_112 = fp - 0x4C;
			dwLoc3C_650 = (word32) eax_105 + 16;
			struct Eq_55120 * edi_119 = fp - 0x4C - ((word32) eax_105 + 43 & ~0x0FFF);
			ui32 ecx_120 = (word32) eax_105 + 43 & ~0x0F;
			while (esp_112 != edi_119)
			{
				esp_112 -= 0x1000;
				esp_112->dw0FFC = esp_112->dw0FFC;
			}
			if ((ecx_120 & 0x0FFF) != 0x00)
			{
				esp_112 -= ecx_120 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_112 - 0x04)[(ecx_120 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_112 - 0x04)[(ecx_120 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			struct Eq_55465 * esp_141 = esp_112 - 0x04;
			esp_141->tFFFFFFFC = eax_105;
			esp_141->tFFFFFFF8 = eax_47;
			Eq_55474 edx_140 = (char *) esp_112 + 0x0F;
			esp_141->tFFFFFFF4 = edx_140 & ~0x0F;
			word32 edx_859;
			Eq_2 eax_157 = __mempcpy(esp_141->tFFFFFFF4, esp_141->tFFFFFFF8, esp_141->tFFFFFFFC, out edx_859);
			word32 ecx_167 = g_dw80A4EAC;
			*eax_157 = 0x3A;
			*((word32) eax_157 + 1) = ecx_167;
			*((word32) eax_157 + 5) = g_t80A4EB0;
			*((word32) eax_157 + 9) = g_t80A4EB4;
			*((word32) eax_157 + 0x0D) = g_t80A4EB8;
			*((word32) eax_157 + 0x0F) = g_t80A4EBA;
			esp_141->tFFFFFFF8.u0 = 0x00;
			esp_141->tFFFFFFF4.u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 edx_862;
			word32 edi_863;
			Eq_2 eax_198 = getcwd(gs, stackArg4, stackArg8, out edx_862, out edi_863);
			esp_201 = (struct Eq_55087 *) ((char *) &esp_141->tFFFFFFFC + 8);
			dwLoc34_645 = eax_198;
			if (eax_198 != 0x00)
			{
				esp_141->tFFFFFFF4 = eax_198;
				word32 ecx_864;
				word32 edx_865;
				Eq_2 eax_215 = strlen(esp_141->tFFFFFFF4, out ecx_864, out edx_865);
				esp_201 = (struct Eq_55087 *) ((char *) &esp_141->tFFFFFFFC + 8);
				dwLoc40_647 = eax_215;
				dwLoc44_648 = edx_140 & ~0x0F;
				dwLoc48_646 = (word32) eax_215 + 1;
			}
			else
			{
				dwLoc48_646 = 0x01;
				dwLoc40_647.u0 = 0x00;
				dwLoc44_648 = edx_140 & ~0x0F;
			}
		}
		else
		{
			if (fp - 0x4C != fp - 0x4C)
			{
				do
				{
					esp_20 -= 0x1000;
					esp_20->dw0FFC = esp_20->dw0FFC;
				} while (esp_20 != fp - 0x4C);
			}
			esp_201 = esp_20 - 0x20;
			esp_201->dw001C = esp_201->dw001C;
			word32 eax_78 = esp_201 + 0x0F & ~0x0F;
			*eax_78 = g_dw80A4EAC;
			*((word32) eax_78 + 4) = g_t80A4EB0;
			*((word32) eax_78 + 8) = g_t80A4EB4;
			*((word32) eax_78 + 0x0C) = g_t80A4EB8;
			*((word32) eax_78 + 0x0E) = g_t80A4EBA;
			dwLoc48_646 = 0x01;
			dwLoc40_647.u0 = 0x00;
			dwLoc44_648 = eax_78;
			dwLoc3C_650 = 0x0F;
		}
		int32 edx_249;
		int32 esi_252;
		ui32 ecx_253;
		struct Eq_55211 * esp_230 = esp_201 - (struct Eq_55212 *) 0x08;
		esp_230->tFFFFFFFC.u0 = 0x3A;
		esp_230->tFFFFFFF8 = dwLoc44_648;
		word32 ecx_837;
		word32 edx_838;
		Eq_2 eax_238 = strchr(esp_230->tFFFFFFF8, esp_230->tFFFFFFFC, out ecx_837, out edx_838);
		if (eax_238 != 0x00)
		{
			int32 ecx_255 = 0x01;
			Eq_2 edi_256 = eax_238;
			while (true)
			{
				int32 eax_258 = ecx_255 + 0x01;
				int32 dwLoc38_664 = eax_258;
				if (edi_256 != (word32) esi_259 + 1)
				{
					ecx_255 = eax_258;
					dwLoc38_664 = ecx_255 + 0x02;
				}
				struct Eq_55290 * esp_271 = esp_201 - (struct Eq_55291 *) 0x08;
				esp_271->tFFFFFFFC.u0 = 0x3A;
				esp_271->tFFFFFFF8 = (word32) edi_256 + 1;
				esi_259 = edi_256;
				word32 ecx_851;
				word32 edx_852;
				Eq_2 eax_283 = strchr(esp_271->tFFFFFFF8, esp_271->tFFFFFFFC, out ecx_851, out edx_852);
				if (eax_283 == 0x00)
					break;
				edi_256 = eax_283;
			}
			esi_252 = ecx_255;
			edx_249 = dwLoc48_646 *s (ecx_255 - 0x01);
			ecx_253 = dwLoc38_664 << 0x03;
		}
		else
		{
			edx_249 = 0x00;
			esi_252 = 0x01;
			ecx_253 = 0x10;
		}
		struct Eq_55261 * esp_311 = esp_201 - (struct Eq_55262 *) 0x0C;
		esp_311->tFFFFFFFC = dwLoc3C_650 + (ecx_253 + esi_252) + edx_249;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		word32 ebx_847;
		word32 edi_850;
		word32 ebp_848;
		word32 esi_849;
		word32 ecx_845;
		word32 edx_846;
		Eq_2 eax_338 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_845, out edx_846, out ebx_847, out ebp_848, out esi_849, out edi_850);
		Eq_2 edi_342 = eax_338;
		if (eax_338 != 0x00)
		{
			__gconv_max_path_elem_len = 0x00;
			esp_311->t0004 = fp - 0x24;
			esp_311->t0000.u0 = 0x080B9575;
			esp_311->tFFFFFFFC = dwLoc44_648;
			Eq_2 eax_363 = __strtok_r(esp_311->tFFFFFFFC, esp_311->t0000, esp_311->t0004);
			Eq_2 edx_371 = (word32) eax_338 + 8 + esi_252 * 0x08;
			Eq_2 ecx_374 = eax_363;
			if (eax_363 == 0x00)
				goto l080679EE;
			ui32 esi_376 = 0x00;
			do
			{
				*((word32) eax_338 + esi_376 * 0x08) = edx_371;
				if (*ecx_374 != 0x2F)
				{
					if (dwLoc34_645 == 0x00)
					{
						struct Eq_55391 * esp_394 = esp_201 - (struct Eq_55392 *) 4;
						esp_394->t0000.u0 = 0x080A4E84;
						esp_394->tFFFFFFFC.u0 = 0x01F5;
						esp_394->tFFFFFFF8.u0 = 0x080A4D25;
						esp_394->tFFFFFFF4.u0 = 0x080A4D3F;
						word32 ecx_856;
						word32 edx_857;
						__assert_fail(out ecx_856, out edx_857);
						goto l080679E9;
					}
					struct Eq_55416 * esp_410 = esp_201 - (struct Eq_55417 *) 0x04;
					esp_410->tFFFFFFFC = dwLoc40_647;
					esp_410->tFFFFFFF8 = dwLoc34_645;
					esp_410->tFFFFFFF4 = edx_371;
					word32 edx_858;
					Eq_2 eax_421 = __mempcpy(esp_410->tFFFFFFF4, esp_410->tFFFFFFF8, esp_410->tFFFFFFFC, out edx_858);
					*eax_421 = 0x2F;
					edx_371 = (word32) eax_421 + 1;
				}
				struct Eq_55364 * esp_435 = esp_201 - (struct Eq_55365 *) 0x08;
				esp_435->tFFFFFFFC = ecx_374;
				esp_435->tFFFFFFF8 = edx_371;
				word32 ecx_855;
				Eq_2 eax_444 = __stpcpy(esp_435->tFFFFFFF8, esp_435->tFFFFFFFC, out ecx_855);
				if (*((word32) eax_444 - 1) != 0x2F)
				{
					*eax_444 = 0x2F;
					eax_444 = (word32) eax_444 + 1;
				}
				ptr32 edx_463 = eax_444 - *((word32) eax_338 + esi_376 * 0x08);
				*((word32) eax_338 + (esi_376 * 0x08 + 4)) = edx_463;
				if (edx_463 > __gconv_max_path_elem_len)
					__gconv_max_path_elem_len = edx_463;
				*eax_444 = 0x00;
				esp_435->t0000 = fp - 0x24;
				esp_435->tFFFFFFFC.u0 = 0x080B9575;
				esp_435->tFFFFFFF8.u0 = 0x00;
				Eq_2 eax_491 = __strtok_r(esp_435->tFFFFFFF8, esp_435->tFFFFFFFC, esp_435->t0000);
				++esi_376;
				edx_371 = (word32) eax_444 + 1;
				ecx_374 = eax_491;
			} while (eax_491 != 0x00);
			struct Eq_55642 * eax_505 = (word32) eax_338 + esi_376 * 0x08;
			eax_505->dw0000 = 0x00;
			eax_505->dw0004 = 0x00;
		}
		else
			edi_342.u0 = 0x080A52A8;
		esp_201->tFFFFFFF0 = dwLoc34_645;
		__gconv_path_elem = edi_342;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		Eq_2 stackArg4 = <invalid>;
		free(gs, stackArg0, stackArg4, out ecx_36, out edx);
	}
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v17_547 = lock.12667 - 0x01;
	lock.12667 = v17_547;
	if (v17_547 != 0x00)
		__lll_unlock_wake_private(0x080CF948, ecx_36, edx, gs);
	if ((eax_22 ^ gs->dw0014) == 0x00)
		return;
l080679E9:
	word32 edx_840;
	word32 ecx_839;
	__stack_chk_fail(out ecx_839, out edx_840);
l080679EE:
	word32 ecx_853;
	word32 edx_854;
	__assert_fail(out ecx_853, out edx_854);
	word32 edi_842;
	word32 esi_841;
	__gconv_read_conf(gs, out esi_841, out edi_842);
}

// 08067A10: Register Eq_2 __gconv_read_conf(Register (ptr32 Eq_9) gs, Register out Eq_2 esiOut, Register out (ptr32 byte) ediOut)
// Called from:
//      __gconv_compare_alias
//      __gconv_find_transform
//      __gconv_get_path
Eq_2 __gconv_read_conf(struct Eq_9 * gs, union Eq_2 & esiOut, byte & ediOut)
{
	Eq_2 ebx_610;
	byte * edi_649;
	ui32 esi_23 = gs->dw0014;
	Eq_2 eax_29 = gs->tFFFFFFE0;
	struct Eq_55663 * esp_106 = fp - 0x7C;
	Eq_2 esi_25 = 0x00;
	edi_649 = edi;
	ebx_610 = ebx;
	if (__gconv_load_cache(gs) != 0x00)
	{
		Eq_2 eax_39 = __gconv_path_elem;
		if (eax_39 == 0x00)
		{
			__gconv_get_path(edx, gs);
			eax_39 = __gconv_path_elem;
		}
		Eq_2 esi_51 = *eax_39;
		Eq_2 dwLoc44_747 = esi_51;
		if (esi_51 != 0x00)
		{
			word32 dwLoc3C_749 = 0x08;
			do
			{
				Eq_2 eax_78 = *((word32) eax_39 + 4);
				struct Eq_55663 * ecx_86 = esp_106 - ((word32) eax_78 + 41 & ~0x0FFF);
				while (esp_106 != ecx_86)
				{
					esp_106 -= 0x1000;
					esp_106->dw0FFC = esp_106->dw0FFC;
				}
				int32 edx_102 = (word32) eax_78 + 41 & ~0x0F & 0x0FFF;
				if (edx_102 != 0x00)
				{
					esp_106 -= edx_102;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_106 - 0x04)[edx_102 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_106 - 0x04)[edx_102 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_55723 * esp_115 = esp_106 - 0x04;
				esp_115->tFFFFFFFC = eax_78;
				esp_115->tFFFFFFF8 = dwLoc44_747;
				Eq_55732 esi_114 = (char *) esp_106 + 0x0F;
				esp_115->tFFFFFFF4 = esi_114 & ~0x0F;
				word32 edx_1257;
				Eq_2 eax_133 = __mempcpy(esp_115->tFFFFFFF4, esp_115->tFFFFFFF8, esp_115->tFFFFFFFC, out edx_1257);
				*eax_133 = g_dw80A4E9C;
				*((word32) eax_133 + 4) = g_dw80A4EA0;
				*((word32) eax_133 + 8) = g_dw80A4EA4;
				((word32) eax_133 + 0x0C)->u4 = g_w80A4EA8;
				esp_115->tFFFFFFF8.u0 = 0x080A22F7;
				esp_115->tFFFFFFF4 = esi_114 & ~0x0F;
				Eq_2 eax_173 = __new_fopen();
				if (eax_173 != 0x00)
				{
					ui32 eax_184 = *eax_173;
					byte al_189 = (byte) eax_184;
					*eax_173 = SEQ(SLICE(eax_184, word16, 16), SLICE(eax_184, byte, 8) | 0x80, al_189);
					if ((al_189 & 0x10) == 0x00)
					{
						do
						{
							struct Eq_55858 * esp_200 = esp_106 - 4;
							esp_200->t0000 = eax_173;
							esp_200->dwFFFFFFFC = 0x0A;
							esp_200->tFFFFFFF8 = fp - 0x28;
							esp_200->tFFFFFFF4 = fp - 44;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg4 = <invalid>;
							Eq_2 stackArg8 = <invalid>;
							Eq_2 stackArg12 = <invalid>;
							Eq_2 stackArg16 = <invalid>;
							struct Eq_55883 * eax_215 = _IO_getdelim(gs, stackArg4, stackArg8, stackArg12, stackArg16);
							if (eax_215 < null)
								break;
							esp_200->tFFFFFFF8.u0 = 0x23;
							esp_200->tFFFFFFF4.u0 = 0x00;
							Eq_2 edi_224 = 0x00;
							word32 ecx_1267;
							word32 edx_1268;
							Eq_2 eax_231 = strchr(esp_200->tFFFFFFF4, esp_200->tFFFFFFF8, out ecx_1267, out edx_1268);
							if (eax_231 != 0x00)
								*eax_231 = 0x00;
							else if (eax_215->bFFFFFFFF == 0x0A)
								eax_215->bFFFFFFFF = 0x00;
							Eq_2 ebx_252 = g_t80CE08C;
							if ((*((word32) ebx_252 + ((int32) null * 0x02 + 1)) & 0x20) != 0x00)
							{
								do
									edi_224 = (word32) edi_224 + 1;
								while ((*((word32) ebx_252 + ((int32) (*edi_224) * 0x02 + 1)) & 0x20) != 0x00);
							}
							if (eax_231 != edi_224)
							{
								int32 eax_273 = (int32) *edi_224;
								if ((byte) eax_273 != 0x00 && (*((word32) ebx_252 + (eax_273 * 0x02 + 1)) & 0x20) == 0x00)
								{
									Eq_2 esi_282 = edi_224;
									do
									{
										esi_282 = (word32) esi_282 + 1;
										byte dl_287 = *esi_282;
									} while (dl_287 != 0x00 && (*((word32) ebx_252 + ((int32) dl_287 * 0x02 + 1)) & 0x20) == 0x00);
									int32 eax_300 = esi_282 - edi_224;
									if (eax_300 != 0x05)
									{
										if (eax_300 == 0x06 && (*edi_224 == 1969516397 && *((word32) edi_224 + 4) == 0x656C))
										{
											Eq_2 eax_491 = modcounter.12647;
											esp_200->tFFFFFFF4 = eax_491;
											modcounter.12647 = (word32) eax_491 + 1;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_2 stackArg4 = <invalid>;
											add_module.isra.0(esi_282, eax_78, dwLoc44_747, gs, stackArg4);
										}
									}
									else if (*edi_224 == 0x61696C61 && *((word32) edi_224 + 4) == 115)
									{
										int32 eax_309 = (int32) dl_287;
										while ((*((word32) ebx_252 + (eax_309 * 0x02 + 1)) & 0x20) != 0x00)
										{
											esi_282 = (word32) esi_282 + 1;
											eax_309 = (int32) *esi_282;
											dl_287 = (byte) eax_309;
										}
										if (dl_287 != 0x00)
										{
											Eq_2 edx_338 = esi_282;
											Eq_3851 edi_339[] = g_ptr80CE084;
											while (true)
											{
												Eq_2 ecx_345 = (word32) edx_338 + 1;
												*((word32) ecx_345 - 1) = edi_339[eax_309];
												eax_309 = (int32) *((word32) edx_338 + 1);
												if ((byte) eax_309 == 0x00)
													break;
												if ((*((word32) ebx_252 + (eax_309 * 0x02 + 1)) & 0x20) != 0x00)
												{
													struct Eq_54525 * edx_369;
													int32 eax_358 = (int32) *((word32) ecx_345 + 1);
													*ecx_345 = 0x00;
													struct Eq_54525 * edx_359 = (word32) edx_338 + 2;
													byte cl_384 = (byte) eax_358;
													edx_369 = edx_359;
													if ((*((word32) ebx_252 + (eax_358 * 0x02 + 1)) & 0x20) != 0x00)
													{
														edx_369 = edx_359;
														do
														{
															++edx_369;
															eax_358 = (int32) edx_369->b0000;
															cl_384 = (byte) eax_358;
														} while ((*((word32) ebx_252 + (eax_358 * 0x02 + 1)) & 0x20) != 0x00);
													}
													if (cl_384 != 0x00)
													{
														int32 eax_393 = eax_358;
														struct Eq_54525 * esi_394 = edx_359 + 2;
														while (true)
														{
															struct Eq_54525 * ecx_402 = esi_394 + 1;
															ecx_402->tFFFFFFFF = edi_339[eax_393];
															++edx_369;
															eax_393 = (int32) edx_369->b0000;
															if ((byte) eax_393 == 0x00 || (*((word32) ebx_252 + (eax_393 * 0x02 + 1)) & 0x20) != 0x00)
																break;
															esi_394 = ecx_402;
														}
														if (edx_359 != ecx_402)
														{
															ecx_402->b0000 = 0x00;
															if (detect_conflict(esi_282) == 0x00)
																add_alias2.isra.1.part.2(esi_282, &esi_394->b0000, edx_359);
														}
													}
													break;
												}
												edx_338 = ecx_345;
											}
										}
									}
								}
							}
						} while ((*eax_173 & 0x10) == 0x00);
					}
					struct Eq_55836 * esp_516 = esp_106 - 0x0C;
					esp_516->tFFFFFFFC.u0 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_1264;
					word32 edx_1265;
					free(gs, stackArg0, stackArg4, out ecx_1264, out edx_1265);
					esp_516->tFFFFFFFC = eax_173;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					__new_fclose(gs, stackArg4);
				}
				eax_39 = (word32) __gconv_path_elem + dwLoc3C_749;
				Eq_2 ebx_548 = *eax_39;
				dwLoc3C_749 += 0x08;
				dwLoc44_747 = ebx_548;
			} while (ebx_548 != 0x00);
		}
		Eq_2 esi_562 = 0x080CECE0;
		do
		{
			struct Eq_55976 * esp_566 = esp_106 - 0x04;
			esp_566->tFFFFFFFC.u0 = 0x08065FB0;
			esp_566->tFFFFFFF8.u0 = 0x080CFF84;
			esp_566->tFFFFFFF4 = fp - 0x28;
			if (__tfind(esp_566->tFFFFFFF4, esp_566->tFFFFFFF8, esp_566->tFFFFFFFC) == 0x00)
			{
				insert_module(esi_562, 0x00);
				esi_562 = (word32) esi_562 + 32;
				if (0x080CEE60 == esi_562)
					break;
				continue;
			}
			esi_562 = (word32) esi_562 + 32;
		} while (0x080CEE60 != esi_562);
		ebx_610.u0 = 0x080A4EC0;
		do
		{
			struct Eq_56132 * esp_614 = esp_106 - 0x08;
			esp_614->tFFFFFFFC.u1 = 0x00;
			esp_614->tFFFFFFF8 = ebx_610;
			Eq_2 eax_621 = rawmemchr(esp_614->tFFFFFFF8, esp_614->tFFFFFFFC);
			esp_614->tFFFFFFFC.u1 = 0x00;
			esp_614->tFFFFFFF8 = (word32) eax_621 + 1;
			Eq_2 eax_639 = rawmemchr(esp_614->tFFFFFFF8, esp_614->tFFFFFFFC);
			esi_25 = eax_639;
			edi_649 = (word32) eax_639 + 1;
			if (detect_conflict(ebx_610) == 0x00)
				add_alias2.isra.1.part.2(ebx_610, (word32) eax_639 + 1, (word32) eax_621 + 1);
			ebx_610 = (word32) eax_639 + 1;
		} while (*((word32) eax_639 + 1) != 0x00);
	}
	gs->tFFFFFFE0 = eax_29;
	if ((esi_23 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_1258;
		word32 edx_1259;
		__stack_chk_fail(out ecx_1258, out edx_1259);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		__gconv_get_builtin_trans(stackArg4, stackArg8);
		esiOut = esi_25;
		ediOut = edi_649;
		return ebx_610;
	}
	else
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
}

// 08067EE0: Register word32 __gconv_get_builtin_trans(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      find_derivation
//      __gconv_read_conf
//      __gconv_lookup_cache
word32 __gconv_get_builtin_trans(Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 ebx_18 = 0x00;
	struct Eq_56295 * edi_21 = &g_t80CE230;
	Eq_2 eax_25 = 0x080A4D68;
	while (true)
	{
		word32 edx_139;
		word32 ecx_125;
		if (strcmp(dwArg04, eax_25, out ecx_125, out edx_139) == 0x00)
			break;
		++ebx_18;
		if (ebx_18 == 0x0C)
		{
			word32 edx_140;
			__assert_fail(out ecx_125, out edx_140);
			break;
		}
		eax_25 = edi_21->dw0000;
		++edi_21;
	}
	((word32) dwArg08 + 28)->u0 = 0x00;
	((word32) dwArg08 + 32)->u0 = 0x00;
	*dwArg08 = 0x00;
	struct Eq_56319 * eax_82 = 0x080CE240 + (ebx_18 << 0x04);
	word32 edx_84 = eax_82->dw0004;
	*((word32) dwArg08 + 4) = 0x00;
	((word32) dwArg08 + 52)->u0 = 0x00;
	*((word32) dwArg08 + 20) = edx_84;
	*((word32) dwArg08 + 24) = eax_82->t0008;
	*((word32) dwArg08 + 36) = (int32) eax_82->b000C;
	*((word32) dwArg08 + 40) = (int32) eax_82->b000D;
	Eq_2 eax_95 = (int32) eax_82->b000F;
	*((word32) dwArg08 + 44) = (int32) eax_82->b000E;
	*((word32) dwArg08 + 48) = eax_95;
	return ecx_125;
}

// 08067FC0: void __gconv_btwoc_ascii(Stack byte bArg08)
void __gconv_btwoc_ascii(byte bArg08)
{
}

// 08067FE0: void __gconv_transform_internal_ucs4(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_56394) dwArg04, Stack (ptr32 Eq_56395) dwArg08, Stack (ptr32 (ptr32 Eq_56397)) dwArg0C, Stack (ptr32 Eq_56397) dwArg10, Stack (ptr32 Eq_56395) dwArg14, Stack word32 dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ucs4(struct Eq_9 * gs, struct Eq_56394 * dwArg04, struct Eq_56395 * dwArg08, struct Eq_56397 ** dwArg0C, struct Eq_56397 * dwArg10, struct Eq_56395 * dwArg14, word32 dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x5C;
	ui32 edi_32 = gs->dw0014;
	Eq_2 dwLoc44_555 = 0x00;
	if ((dwArg08->b0008 & 0x01) == 0x00)
	{
		Eq_2 edi_43 = dwArg04->t0050;
		dwLoc44_555 = edi_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc44_555 = __ror(edi_43, 0x09) ^ gs->t0018;
	}
	ptr32 esp_483;
	word32 esi_479;
	if (dwArg1C == 0x00)
	{
		struct Eq_56395 * eax_120 = dwArg14;
		if (dwArg14 == null)
			eax_120 = dwArg08;
		struct Eq_56442 * ebp_125 = eax_120->ptr0000;
		Eq_56446 eax_127 = dwArg08->t0004;
		if (dwArg20 != 0x00)
		{
			struct Eq_56452 * ecx_134 = dwArg08->ptr0014;
			ui32 ebx_135 = ecx_134->dw0000;
			byte bl_149 = (byte) ebx_135;
			Eq_56462 edx_137 = ebx_135 & 0x07;
			if ((ebx_135 & 0x07) != 0x00)
			{
				if (dwArg14 != null)
					goto l0806836C;
				struct Eq_56397 * eax_146 = *dwArg0C;
				if (eax_146 < dwArg10)
				{
					if ((bl_149 & 0x04) == 0x00)
					{
						do
						{
							++eax_146;
							*dwArg0C = (struct Eq_56397 **) eax_146;
							edx_137 = (word32) edx_137 + 1;
							Mem167[ecx_134 + 0x03 + edx_137:byte] = Mem163[eax_146 + -1:byte];
							if (dwArg10 == eax_146)
								goto l080680F1;
						} while (edx_137 != 0x04);
					}
				}
				else
				{
l080680F1:
					if (edx_137 <= 0x03)
					{
						ecx_134->dw0000 = edx_137 | ebx_135 & ~0x07;
						goto l0806821E;
					}
				}
				ebp_125->a0000[0].b0000 = ecx_134->t0007.b0000;
				ebp_125->b0001 = ecx_134->b0006;
				ebp_125->b0002 = ecx_134->b0005;
				ebp_125->t0003 = ecx_134->t0004;
				ecx_134->dw0000 &= ~0x07;
				ebp_125 = (struct Eq_56442 *) ((char *) &ebp_125->t0003 + 1);
			}
		}
		while (true)
		{
			struct Eq_56397 * ebx_217 = *dwArg0C;
			int32 ecx_220 = eax_127 - ebp_125;
			int32 eax_221 = dwArg10 - ebx_217;
			if (ecx_220 <= eax_221)
				eax_221 = ecx_220;
			int32 ecx_228 = eax_221 + 0x03;
			if (eax_221 >= 0x00)
				ecx_228 = eax_221;
			struct Eq_56442 * edi_237;
			int32 ecx_232 = ecx_228 >> 0x02;
			if (ecx_232 != 0x00)
			{
				int32 eax_238 = 0x00;
				do
				{
					ebp_125[eax_238 * 0x04 / 7] = (struct Eq_56442) __bswap(ebx_217[eax_238 * 0x04]);
					++eax_238;
				} while (ecx_232 != eax_238);
				edi_237 = ebp_125 + (ecx_232 * 0x04) / 7;
				ebx_217 += ecx_232 * 0x04;
			}
			else
				edi_237 = ebp_125;
			*dwArg0C = (struct Eq_56397 **) ebx_217;
			ui32 edx_264 = 0x04;
			if (dwArg10 != ebx_217)
				edx_264 = (0x00 - (eax_127 < (char *) (&edi_237->t0003) + 1) & ~0x01) + 0x07;
			if (dwArg14 != null)
				break;
			++dwArg08->dw000C;
			if ((dwArg08->b0008 & 0x01) != 0x00)
			{
				dwArg08->ptr0000 = edi_237;
				goto l0806820D;
			}
			if (edi_237 <= ebp_125)
				goto l0806820D;
			struct Eq_56442 * eax_304 = dwArg08->ptr0000;
			word32 ecx_964;
			word32 edx_965;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc44_555, out ecx_964, out edx_965);
			ui32 eax_353;
			word32 ecx_354;
			fn00000000();
			dwLoc70 = dwArg20;
			if (eax_353 != 0x04)
			{
				if (eax_304 != edi_237)
					*dwArg0C = (struct Eq_56397 **) (*dwArg0C - (edi_237 - eax_304));
				if (eax_353 == 0x00)
					goto l080681FC;
				edx_264 = eax_353;
l0806820D:
				if (dwArg20 == 0x00 || edx_264 != 0x07)
					goto l0806821E;
				struct Eq_56397 * ecx_390 = *dwArg0C;
				if (dwArg10 - ecx_390 > 0x03)
				{
					word32 edx_967;
					word32 ecx_966;
					__assert_fail(out ecx_966, out edx_967);
					goto l08068344;
				}
				else
				{
					struct Eq_56732 * eax_422;
					struct Eq_56452 * ebx_417 = dwArg08->ptr0014;
					struct Eq_56397 * eax_418 = ecx_390;
					struct Eq_56738 * esi_419 = &ebx_417->t0004;
					if (ecx_390 < dwArg10)
					{
						do
						{
							++eax_418;
							*dwArg0C = (struct Eq_56397 **) eax_418;
							++esi_419;
							esi_419->bFFFFFFFF = eax_418->bFFFFFFFF;
						} while (eax_418 != dwArg10);
						eax_422 = eax_418 - ecx_390;
					}
					else
						eax_422 = null;
					ebx_417->dw0000 = eax_422 | ebx_417->dw0000 & ~0x07;
					goto l0806821E;
				}
			}
			if (edx_264 != 0x05)
				goto l0806820D;
l080681FC:
			ebp_125 = dwArg08->ptr0000;
		}
		dwArg14->ptr0000 = edi_237;
	}
	else
	{
		if (dwArg14 != null)
			goto l08068349;
		struct Eq_56452 * eax_67 = dwArg08->ptr0014;
		eax_67->dw0000 = 0x00;
		eax_67->t0004.u1 = 0x00;
		if ((dwArg08->b0008 & 0x01) == 0x00)
		{
			word32 edx_961;
			word32 ecx_960;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc44_555, out ecx_960, out edx_961);
			word32 ecx_110;
			fn00000000();
		}
	}
l0806821E:
	if ((edi_32 ^ gs->dw0014) == 0x00)
		return;
l08068344:
	word32 edx_963;
	word32 ecx_962;
	__stack_chk_fail(out ecx_962, out edx_963);
	esp_18.u0 = <invalid>;
l08068349:
	esi_479 = (word32) *((word32) esp_18 + 44);
	struct Eq_56550 * esp_481 = esp_18 - 4;
	esp_481->dw0000 = esi_479 + ~0x0002881F;
	esp_481->dwFFFFFFFC = 0x019F;
	esp_483 = esp_481 - 4;
l08068359:
	struct Eq_56773 * esp_488 = esp_483 - 4;
	esp_488->dw0000 = esi_479 + ~0x00028CFD;
	esp_488->dwFFFFFFFC = esi_479 + ~0x00028CE9;
	word32 ecx_968;
	word32 edx_969;
	__assert_fail(out ecx_968, out edx_969);
	Eq_2 esp_495 = <invalid>;
	esp_18 = (word32) esp_495 - 4;
l0806836C:
	esi_479 = (word32) *((word32) esp_18 + 44);
	struct Eq_56473 * esp_505 = esp_18 - 4;
	esp_505->dw0000 = esi_479 + ~0x0002881F;
	esp_505->dwFFFFFFFC = 0x022F;
	esp_483 = esp_505 - 4;
	goto l08068359;
}

// 08068390: void __gconv_transform_ucs4_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_56796) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 (ptr32 Eq_56799)) dwArg0C, Stack (ptr32 Eq_56799) dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs4_internal(struct Eq_9 * gs, struct Eq_56796 * dwArg04, Eq_2 dwArg08, union Eq_56799 ** dwArg0C, union Eq_56799 * dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x6C;
	Eq_2 edi_22 = dwArg08;
	ui32 ebp_26 = *((word32) dwArg08 + 8);
	ui32 ecx_34 = gs->dw0014;
	Eq_2 dwLoc48_668 = 0x00;
	if ((ebp_26 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc48_668 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc48_668 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_2 esi_326;
	struct Eq_56823 * esp_270;
	Eq_2 eax_443;
	ptr32 esp_500;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 != 0x00)
			goto l080687ED;
		struct Eq_56882 * eax_68 = *((word32) dwArg08 + 20);
		eax_68->dw0000 = 0x00;
		eax_68->t0004.u1 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_1212;
			word32 edx_1213;
			_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc48_668, out ecx_1212, out edx_1213);
			word32 edx_112;
			fn00000000();
		}
l080685D6:
		if ((ecx_34 ^ gs->dw0014) == 0x00)
			return;
		word32 ecx_1214;
		word32 edx_1215;
		__stack_chk_fail(out ecx_1214, out edx_1215);
		esp_18.u0 = <invalid>;
l0806881C:
		edi_22 = *((word32) esp_18 + 52);
		struct Eq_56935 * esp_498 = esp_18 - 4;
		esp_498->dw0000 = (word32) edi_22 - 0x00028840;
		esp_498->dwFFFFFFFC = 0x022F;
		esp_500 = esp_498 - 4;
l080687FD:
		struct Eq_56994 * esp_505 = esp_500 - 4;
		esp_505->dw0000 = (word32) edi_22 - 167166;
		esp_505->dwFFFFFFFC = (word32) edi_22 - 167146;
		Eq_2 esp_512 = <invalid>;
		word32 edx_1217;
		word32 ecx_1216;
		eax_443 = __assert_fail(out ecx_1216, out edx_1217);
		esp_270 = (word32) esp_512 - 4;
l08068810:
		esi_326 = eax_443;
		goto l08068685;
	}
	Eq_2 eax_117 = dwArg14;
	Eq_56846 ecx_118 = *((word32) dwArg08 + 4);
	if (dwArg14 == 0x00)
		eax_117 = dwArg08;
	struct Eq_56852 * esi_126 = *eax_117;
	struct Eq_56852 * dwLoc64_699 = esi_126;
	word32 * ecx_136 = null;
	if (dwArg18 != null)
		ecx_136 = fp - 0x28;
	if (dwArg20 != 0x00)
	{
		struct Eq_56882 * ecx_150 = *((word32) dwArg08 + 20);
		ui32 ebx_151 = ecx_150->dw0000;
		byte bl_166 = (byte) ebx_151;
		if ((ebx_151 & 0x07) != 0x00)
		{
			if (dwArg14 != 0x00)
				goto l0806881C;
			Eq_56949 edx_162 = ebx_151 & 0x07;
			union Eq_56799 * eax_163 = *dwArg0C;
			if (eax_163 < dwArg10)
			{
				if ((bl_166 & 0x04) == 0x00)
				{
					do
					{
						eax_163 = (union Eq_56799 *) ((char *) eax_163 + 1);
						*dwArg0C = (union Eq_56799 **) eax_163;
						edx_162 = (word32) edx_162 + 1;
						Mem188[ecx_150 + 0x03 + edx_162:byte] = Mem184[eax_163 + -1:byte];
						if (dwArg10 == eax_163)
							goto l080684E9;
					} while (edx_162 != 0x04);
				}
			}
			else
			{
l080684E9:
				if (edx_162 <= 0x03)
				{
					ecx_150->dw0000 = edx_162 | ebx_151 & ~0x07;
					goto l080685D6;
				}
			}
			ui32 ebx_250 = ebx_151;
			if (ecx_150->t0004 <= 0x80)
			{
				esi_126->dw0000 = (word32) ecx_150->b0007;
				esi_126->b0001 = ecx_150->b0006;
				esi_126->b0002 = ecx_150->b0005;
				esi_126->t0003 = ecx_150->t0004;
				ebx_250 = ecx_150->dw0000;
				dwLoc64_699 = esi_126 + 1;
			}
			else if ((ebp_26 & 0x02) == 0x00)
			{
				*dwArg0C = (union Eq_56799 **) ((char *) eax_163 + ((ebx_151 & 0x07) - edx_162));
				goto l080685D6;
			}
			ebp_26 = (ui32) *((word32) dwArg08 + 8);
			ecx_150->dw0000 = ebx_250 & ~0x07;
		}
	}
	while (true)
	{
		union Eq_56799 * edx_275 = *dwArg0C;
		esp_270 = fp - 0x6C;
		struct Eq_56852 * ebx_274 = dwLoc64_699;
		int32 esi_277 = ecx_118 - dwLoc64_699;
		int32 eax_278 = dwArg10 - edx_275;
		if (esi_277 <= eax_278)
			eax_278 = esi_277;
		int32 esi_285 = eax_278 + 0x03;
		if (eax_278 >= 0x00)
			esi_285 = eax_278;
		int32 esi_289 = esi_285 >> 0x02;
		if (esi_289 != 0x00)
		{
			int32 ecx_297 = 0x00;
			ui32 ebp_301 = ebp_26 & 0x02;
			do
			{
				Eq_2 eax_307 = __bswap(*edx_275);
				if (eax_307 < 0x00)
				{
					if (ecx_136 == null)
					{
						ebx_274 = dwLoc64_699;
						esi_326.u0 = 0x06;
						goto l08068603;
					}
					if (ebp_301 == 0x00)
					{
						*dwArg0C = (union Eq_56799 **) edx_275;
						esi_326.u0 = 0x06;
						goto l08068603;
					}
					else
					{
						++*ecx_136;
						++ecx_297;
						edx_275 = (union Eq_56799 *) ((char *) edx_275 + 4);
						if (esi_289 == ecx_297)
							break;
						continue;
					}
				}
				ebx_274->dw0000 = (word32) eax_307;
				++ecx_297;
				edx_275 = (union Eq_56799 *) ((char *) edx_275 + 4);
				++ebx_274;
			} while (esi_289 != ecx_297);
		}
		else
			ebx_274 = dwLoc64_699;
		*dwArg0C = (union Eq_56799 **) edx_275;
		esi_326.u0 = 0x04;
		if (edx_275 != dwArg10)
		{
			esi_326 = (0x00 - (ecx_118 < ebx_274 + 1) & ~0x01) + 0x07;
			if (dwArg14 != 0x00)
			{
l080685D0:
				*dwArg14 = ebx_274;
				goto l080685D6;
			}
		}
		else
		{
l08068603:
			if (dwArg14 != 0x00)
				goto l080685D0;
		}
		*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
		if ((*((word32) dwArg08 + 8) & 0x01) != 0x00)
		{
			*dwArg08 = ebx_274;
			*dwArg18 = *dwArg18;
			goto l08068685;
		}
		if (dwLoc64_699 >= ebx_274)
		{
l08068685:
			if (esp_270->dw008C != 0x00 && esi_326 == 0x07)
			{
				struct Eq_57020 * ebp_532 = esp_270->ptr0014;
				struct Eq_57020 * edx_533 = *esp_270->ptr000C;
				if (ebp_532 - edx_533 <= 0x03)
				{
					ui32 eax_573;
					ui32 * ecx_568 = *((word32) edi_22 + 20);
					struct Eq_57020 * eax_569 = edx_533 + 1;
					struct Eq_57077 * ebx_570 = ecx_568 + 1;
					if (edx_533 < ebp_532)
					{
						while (true)
						{
							*esp_270->ptr000C = (struct Eq_57020 **) eax_569;
							++ebx_570;
							ebx_570->bFFFFFFFF = eax_569->bFFFFFFFF;
							struct Eq_57020 * edi_585 = eax_569 + 1;
							if (esp_270->ptr0014 == eax_569)
								break;
							eax_569 = edi_585;
						}
						eax_573 = esp_270->ptr0014 - edx_533;
					}
					else
						eax_573 = 0x00;
					*ecx_568 = eax_573 | *ecx_568 & ~0x07;
					goto l080685D6;
				}
				word32 edi_538 = esp_270->dw0034;
				struct Eq_57038 * esp_540 = esp_270 - 4;
				esp_540->dw0000 = edi_538 + ~0x0002883F;
				esp_540->dwFFFFFFFC = 777;
				esp_540->dwFFFFFFF8 = edi_538 + ~0x00028CFD;
				esp_540->dwFFFFFFF4 = edi_538 + ~0x00028CD5;
				word32 ecx_1218;
				word32 edx_1219;
				__assert_fail(out ecx_1218, out edx_1219);
				Eq_2 esp_552 = <invalid>;
				esp_18 = (word32) esp_552 - 4;
l080687ED:
				edi_22 = *((word32) esp_18 + 52);
				struct Eq_56868 * esp_562 = esp_18 - 4;
				esp_562->dw0000 = (word32) edi_22 - 0x00028840;
				esp_562->dwFFFFFFFC = 0x019F;
				esp_500 = esp_562 - 4;
				goto l080687FD;
			}
			goto l080685D6;
		}
		struct Eq_56852 * eax_392 = *dwArg08;
		word32 ecx_1220;
		word32 edx_1221;
		_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc48_668, out ecx_1220, out edx_1221);
		word32 edx_445;
		fn00000000();
		dwLoc80 = dwArg20;
		esp_270 = fp - 0x6C;
		if (eax_443 != 0x04)
		{
			if (eax_392 != ebx_274)
				*dwArg0C = (union Eq_56799 **) (*dwArg0C - (ebx_274 - eax_392));
			if (eax_443 != 0x00)
				goto l08068810;
		}
		else if (esi_326 != 0x05)
			goto l08068685;
		ebp_26 = (ui32) *((word32) dwArg08 + 8);
		dwLoc64_699 = (struct Eq_56852 *) *dwArg08;
	}
}

// 08068830: void __gconv_transform_internal_ucs4le(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57318) dwArg04, Stack (ptr32 Eq_57319) dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_57319) dwArg14, Stack word32 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ucs4le(struct Eq_9 * gs, struct Eq_57318 * dwArg04, struct Eq_57319 * dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, struct Eq_57319 * dwArg14, word32 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20)
{
	struct Eq_57326 * esp_18 = fp - 0x5C;
	struct Eq_57319 * esi_20 = dwArg08;
	Eq_2 ebp_129 = dwArg1C;
	ui32 edx_31 = gs->dw0014;
	Eq_2 dwLoc40_573 = 0x00;
	if ((dwArg08->b0008 & 0x01) == 0x00)
	{
		Eq_2 edx_42 = dwArg04->t0050;
		dwLoc40_573 = edx_42;
		if (dwArg04->dw003C != 0x00)
			dwLoc40_573 = __ror(edx_42, 0x09) ^ gs->t0018;
	}
	ptr32 esp_496;
	Eq_2 esp_271;
	Eq_2 edi_303;
	Eq_2 ebx_272;
	Eq_2 eax_355;
	if (dwArg1C == 0x00)
	{
		struct Eq_57319 * eax_121 = dwArg14;
		up32 edx_122 = dwArg08->dw0004;
		if (dwArg14 == null)
			eax_121 = dwArg08;
		ebp_129 = eax_121->t0000;
		if (dwArg20 != 0x00)
		{
			struct Eq_57380 * ebx_138 = dwArg08->ptr0014;
			ui32 edx_139 = ebx_138->dw0000;
			byte dl_153 = (byte) edx_139;
			Eq_57390 ecx_141 = edx_139 & 0x07;
			if ((edx_139 & 0x07) != 0x00)
			{
				if (dwArg14 != null)
					goto l08068BA4;
				Eq_2 eax_150 = *dwArg0C;
				if (dwArg10 > eax_150)
				{
					if ((dl_153 & 0x04) == 0x00)
					{
						do
						{
							eax_150 = (word32) eax_150 + 1;
							*dwArg0C = eax_150;
							ecx_141 = (word32) ecx_141 + 1;
							Mem169[ebx_138 + 0x03 + ecx_141:byte] = Mem165[eax_150 + -1:byte];
							if (dwArg10 == eax_150)
								goto l08068A5F;
						} while (ecx_141 != 0x04);
					}
				}
				else
				{
l08068A5F:
					if (ecx_141 <= 0x03)
					{
						ebx_138->dw0000 = ecx_141 | edx_139 & ~0x07;
						goto l080689E0;
					}
				}
				*ebp_129 = ebx_138->t0004;
				*((word32) ebp_129 + 1) = ebx_138->b0005;
				*((word32) ebp_129 + 2) = ebx_138->b0006;
				*((word32) ebp_129 + 3) = ebx_138->b0007;
				ebx_138->dw0000 &= ~0x07;
				ebp_129 = (word32) ebp_129 + 4;
			}
		}
		Eq_2 edi_221 = ebp_129;
		ebp_129 = dwArg0C;
		while (true)
		{
			Eq_2 ecx_228 = *dwArg0C;
			Eq_57397 eax_230 = edx_122 - edi_221;
			Eq_57397 ebx_231 = dwArg10 - ecx_228;
			if (eax_230 <= ebx_231)
				ebx_231 = eax_230;
			Eq_57397 eax_238 = (word32) ebx_231 + 3;
			if (ebx_231 >= 0x00)
				eax_238 = ebx_231;
			Eq_2 eax_245 = eax_238 & ~0x03;
			Mem253[dwArg0C + 0x00:word32] = ecx_228 + eax_245;
			word32 edx_976;
			Eq_2 eax_263 = __mempcpy(edi_221, ecx_228, eax_245, out edx_976);
			esp_271 = fp - 0x5C;
			ebx_272.u0 = 0x04;
			if (dwArg10 != *dwArg0C)
				ebx_272 = (0x00 - (edx_122 < (word32) eax_263 + 4) & ~0x01) + 0x07;
			if (dwArg14 != null)
				break;
			++dwArg08->dw000C;
			if ((dwArg08->b0008 & 0x01) != 0x00)
			{
				dwArg08->t0000 = eax_263;
				edi_303 = dwArg0C;
				goto l080689CF;
			}
			if (eax_263 <= edi_221)
			{
l080689CD:
				esp_271 = fp - 0x5C;
				edi_303 = dwArg0C;
				goto l080689CF;
			}
			Eq_2 eax_309 = dwArg08->t0000;
			word32 ecx_981;
			word32 edx_982;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc40_573, out ecx_981, out edx_982);
			fn00000000();
			dwLoc70 = dwArg20;
			esp_271 = fp - 0x5C;
			if (eax_355 != 0x04)
			{
				if (eax_309 != eax_263)
					*dwArg0C -= eax_263 - eax_309;
				if (eax_355 != 0x00)
					goto l08068BC7;
				goto l080689BD;
			}
			if (ebx_272 != 0x05)
				goto l080689CD;
l080689BD:
			edi_221 = dwArg08->t0000;
		}
		dwArg14->t0000 = eax_263;
	}
	else
	{
		if (dwArg14 != null)
		{
			esi_20 = (struct Eq_57319 *) &g_t80CE000;
			esp_496 = fp - 100;
			goto l08068BB4;
		}
		struct Eq_57380 * eax_72 = dwArg08->ptr0014;
		eax_72->dw0000 = 0x00;
		eax_72->t0004.u1 = 0x00;
		if ((dwArg08->b0008 & 0x01) == 0x00)
		{
			word32 edx_975;
			word32 ecx_974;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc40_573, out ecx_974, out edx_975);
			word32 ecx_116;
			fn00000000();
		}
	}
l080689E0:
	if ((edx_31 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_980;
	word32 ecx_979;
	__stack_chk_fail(out ecx_979, out edx_980);
	esp_271.u0 = <invalid>;
l08068B81:
	Eq_2 esi_470 = *((word64) esp_271.u0 + 24);
	struct Eq_57670 * esp_472 = esp_271 - 4;
	esp_472->dw0000 = (word32) esi_470 - 0x00028880;
	esp_472->dwFFFFFFFC = 777;
	esp_472->dwFFFFFFF8 = (word32) esi_470 - 167166;
	esp_472->dwFFFFFFF4 = (word32) esi_470 - 167126;
	word32 edx_984;
	word32 ecx_983;
	__assert_fail(out ecx_983, out edx_984);
	Eq_2 esp_484 = <invalid>;
	esp_18 = (word32) esp_484 - 4;
l08068BA4:
	esi_20 = esp_18->ptr0018;
	struct Eq_57446 * esp_494 = esp_18 - 4;
	esp_494->ptr0000 = (char *) esi_20 - 0x00028880;
	esp_494->dwFFFFFFFC = 0x022F;
	esp_496 = esp_494 - 4;
l08068BB4:
	struct Eq_57540 * esp_501 = esp_496 - 4;
	esp_501->ptr0000 = (char *) esi_20 - 167166;
	esp_501->ptrFFFFFFFC = (char *) esi_20 - 167146;
	Eq_2 esp_508 = <invalid>;
	word32 ecx_977;
	word32 edx_978;
	eax_355 = __assert_fail(out ecx_977, out edx_978);
	esp_271 = (word32) esp_508 - 4;
l08068BC7:
	edi_303 = ebp_129;
	ebx_272 = eax_355;
l080689CF:
	if (ebx_272 == 0x07 && *((word32) esp_271 + 0x007C) != null)
	{
		Eq_2 edx_396 = *((word32) esp_271 + 8);
		Eq_2 ebx_398 = *edi_303;
		if (edx_396 - ebx_398 <= 0x03)
		{
			ui32 eax_412;
			struct Eq_57380 * esi_406 = esi_20->ptr0014;
			Eq_2 eax_407 = ebx_398;
			Eq_2 ecx_408 = *((word64) esp_271.u0 + 8);
			ebp_129 = &esi_406->t0004;
			if (ebx_398 < edx_396)
			{
				do
				{
					eax_407 = (word32) eax_407 + 1;
					*edi_303 = eax_407;
					ebp_129 = (word32) ebp_129 + 1;
					*((word32) ebp_129 - 1) = *((word32) eax_407 - 1);
				} while (eax_407 != ecx_408);
				eax_412 = eax_407 - ebx_398;
			}
			else
				eax_412 = 0x00;
			esi_406->dw0000 = eax_412 | esi_406->dw0000 & ~0x07;
			goto l080689E0;
		}
		goto l08068B81;
	}
	goto l080689E0;
}

// 08068BF0: void __gconv_transform_ucs4le_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57740) dwArg04, Stack (ptr32 Eq_57741) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_57741) dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs4le_internal(struct Eq_9 * gs, struct Eq_57740 * dwArg04, struct Eq_57741 * dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, struct Eq_57741 * dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	struct Eq_57748 * esp_18 = fp - 0x6C;
	struct Eq_57741 * edi_22 = dwArg08;
	ui32 ebp_247 = dwArg08->dw0008;
	ui32 esi_33 = gs->dw0014;
	Eq_2 dwLoc44_678 = 0x00;
	if ((ebp_247 & 0x01) == 0x00)
	{
		Eq_2 esi_44 = dwArg04->t0050;
		dwLoc44_678 = esi_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc44_678 = __ror(esi_44, 0x09) ^ gs->t0018;
	}
	ptr32 esp_378;
	Eq_2 esi_312;
	struct Eq_57768 * esp_257;
	Eq_2 eax_460;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == null)
		{
			struct Eq_57826 * eax_68 = dwArg08->ptr0014;
			eax_68->dw0000 = 0x00;
			eax_68->t0004.u1 = 0x00;
			if ((dwArg08->dw0008 & 0x01) == 0x00)
			{
				word32 ecx_1315;
				word32 edx_1316;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc44_678, out ecx_1315, out edx_1316);
				word32 ecx_111;
				word32 edx_112;
				fn00000000();
			}
			goto l08068E2D;
		}
		goto l08069057;
	}
	struct Eq_57741 * eax_123 = dwArg14;
	if (dwArg14 == null)
		eax_123 = dwArg08;
	Eq_57792 eax_131 = eax_123->t0000;
	Eq_57792 dwLoc60_709 = eax_131;
	ptr32 eax_136 = dwArg08->ptr0004;
	word32 * eax_138 = null;
	if (dwArg18 != null)
		eax_138 = fp - 0x28;
	if (dwArg20 != 0x00)
	{
		struct Eq_57826 * ecx_151 = dwArg08->ptr0014;
		ui32 ebx_152 = ecx_151->dw0000;
		byte bl_167 = (byte) ebx_152;
		Eq_57882 edx_154 = ebx_152 & 0x07;
		if ((ebx_152 & 0x07) != 0x00)
		{
			if (dwArg14 != null)
				goto l080690A4;
			Eq_2 eax_164 = *dwArg0C;
			if (dwArg10 > eax_164)
			{
				if ((bl_167 & 0x04) == 0x00)
				{
					do
					{
						eax_164 = (word32) eax_164 + 1;
						*dwArg0C = (union Eq_2 *) eax_164;
						edx_154 = (word32) edx_154 + 1;
						Mem185[ecx_151 + 0x03 + edx_154:byte] = Mem181[eax_164 + -1:byte];
						if (dwArg10 == eax_164)
							goto l08068D35;
					} while (edx_154 != 0x04);
				}
			}
			else
			{
l08068D35:
				if (edx_154 <= 0x03)
				{
					ecx_151->dw0000 = edx_154 | ebx_152 & ~0x07;
					goto l08068E2D;
				}
			}
			ui32 ebx_238 = ebx_152;
			if (ecx_151->b0007 <= 0x80)
			{
				*eax_131 = ecx_151->t0004;
				*((word32) eax_131 + 1) = ecx_151->b0005;
				*((word32) eax_131 + 2) = ecx_151->b0006;
				*((word32) eax_131 + 3) = ecx_151->b0007;
				dwLoc60_709 = (word32) eax_131 + 4;
				ebx_238 = ecx_151->dw0000;
			}
			else if ((ebp_247 & 0x02) == 0x00)
				goto l08068E2D;
			ebp_247 = dwArg08->dw0008;
			ecx_151->dw0000 = ebx_238 & ~0x07;
		}
	}
l08068D80:
	Eq_2 eax_263 = *dwArg0C;
	esp_257 = fp - 0x6C;
	Eq_57792 ebx_261 = dwLoc60_709;
	int32 esi_264 = eax_136 - dwLoc60_709;
	int32 edx_265 = dwArg10 - eax_263;
	if (esi_264 <= edx_265)
		edx_265 = esi_264;
	int32 esi_272 = edx_265 + 0x03;
	if (edx_265 >= 0x00)
		esi_272 = edx_265;
	int32 esi_276 = esi_272 >> 0x02;
	if (esi_276 != 0x00)
	{
		int32 edx_284 = 0x00;
		ui32 ebp_288 = ebp_247 & 0x02;
		do
		{
			int32 ecx_293 = *eax_263;
			if (ecx_293 < 0x00)
			{
				if (eax_138 == null)
				{
					ebx_261 = dwLoc60_709;
					esi_312.u0 = 0x06;
					goto l08068E5B;
				}
				if (ebp_288 == 0x00)
				{
					*dwArg0C = (union Eq_2 *) eax_263;
					esi_312.u0 = 0x06;
					goto l08068E5B;
				}
				else
				{
					++*eax_138;
					++edx_284;
					eax_263 = (word32) eax_263 + 4;
					if (esi_276 == edx_284)
						break;
					continue;
				}
			}
			*ebx_261 = ecx_293;
			++edx_284;
			eax_263 = (word32) eax_263 + 4;
			ebx_261 = (word32) ebx_261 + 4;
		} while (esi_276 != edx_284);
	}
	else
		ebx_261 = dwLoc60_709;
	*dwArg0C = (union Eq_2 *) eax_263;
	if (eax_263 != dwArg10)
	{
		if (dwArg10 >= (word32) eax_263 + 4)
		{
			if (eax_136 < (word32) ebx_261 + 4)
			{
				esi_312.u0 = 0x05;
				if (dwArg14 != null)
					goto l08068E27;
				goto l08068E63;
			}
			word32 ecx_1323;
			word32 edx_1324;
			__assert_fail(out ecx_1323, out edx_1324);
			Eq_2 esp_366 = <invalid>;
			esp_18 = (word32) esp_366 - 4;
l080690A4:
			edi_22 = esp_18->ptr0034;
			struct Eq_57893 * esp_376 = esp_18 - 4;
			esp_376->dw0000 = (char *) edi_22 - 166080;
			esp_376->dwFFFFFFFC = 0x022F;
			esp_378 = esp_376 - 4;
l08069067:
			struct Eq_57950 * esp_532 = esp_378 - 4;
			esp_532->dw0000 = (char *) edi_22 - 167166;
			esp_532->dwFFFFFFFC = (char *) edi_22 - 167146;
			Eq_2 esp_539 = <invalid>;
			word32 edx_1320;
			word32 ecx_1319;
			eax_460 = __assert_fail(out ecx_1319, out edx_1320);
			esp_257 = (word32) esp_539 - 4;
			goto l0806907A;
		}
		esi_312.u0 = 0x07;
	}
	else
		esi_312.u0 = 0x04;
l08068E5B:
	if (dwArg14 != null)
	{
l08068E27:
		dwArg14->t0000 = ebx_261;
		goto l08068E2D;
	}
l08068E63:
	++dwArg08->dw000C;
	if ((dwArg08->dw0008 & 0x01) == 0x00)
	{
		if (dwLoc60_709 < ebx_261)
		{
			Eq_57792 eax_409 = dwArg08->t0000;
			word32 edx_1326;
			word32 ecx_1325;
			_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc44_678, out ecx_1325, out edx_1326);
			word32 ecx_461;
			word32 edx_462;
			fn00000000();
			dwLoc80 = dwArg20;
			esp_257 = fp - 0x6C;
			if (eax_460 != 0x04)
			{
				if (eax_409 != ebx_261)
					*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_261 - eax_409));
				if (eax_460 == 0x00)
				{
l08068EC5:
					ebp_247 = dwArg08->dw0008;
					dwLoc60_709 = dwArg08->t0000;
					goto l08068D80;
				}
l0806907A:
				esi_312 = eax_460;
			}
			else if (esi_312 == 0x05)
				goto l08068EC5;
		}
	}
	else
	{
		dwArg08->t0000 = ebx_261;
		*dwArg18 = *dwArg18;
	}
	if (esp_257->dw008C == 0x00 || esi_312 != 0x07)
		goto l08068E2D;
	struct Eq_57976 * ebp_495 = esp_257->ptr0014;
	struct Eq_57976 * edx_496 = *esp_257->ptr0010;
	if (ebp_495 - edx_496 <= 0x03)
	{
		ui32 eax_553;
		struct Eq_57826 * ecx_548 = edi_22->ptr0014;
		struct Eq_57976 * eax_549 = edx_496;
		struct Eq_58031 * ebx_550 = &ecx_548->t0004;
		if (edx_496 < ebp_495)
		{
			do
			{
				++eax_549;
				*esp_257->ptr0010 = (struct Eq_57976 **) eax_549;
				++ebx_550;
				ebx_550->bFFFFFFFF = eax_549->bFFFFFFFF;
			} while (eax_549 != esp_257->ptr0014);
			eax_553 = eax_549 - edx_496;
		}
		else
			eax_553 = 0x00;
		ecx_548->dw0000 = eax_553 | ecx_548->dw0000 & ~0x07;
l08068E2D:
		if ((esi_33 ^ gs->dw0014) == 0x00)
			return;
		word32 ecx_1317;
		word32 edx_1318;
		__stack_chk_fail(out ecx_1317, out edx_1318);
		__gconv_transform_ascii_internal(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
		return;
	}
	word32 edi_501 = esp_257->dw0034;
	struct Eq_57994 * esp_503 = esp_257 - 4;
	esp_503->dw0000 = edi_501 + ~0x000288BF;
	esp_503->dwFFFFFFFC = 777;
	esp_503->dwFFFFFFF8 = edi_501 + ~0x00028CFD;
	esp_503->dwFFFFFFF4 = edi_501 + ~0x00028CD5;
	word32 ecx_1321;
	word32 edx_1322;
	__assert_fail(out ecx_1321, out edx_1322);
	Eq_2 esp_515 = <invalid>;
	esp_18 = (word32) esp_515 - 4;
l08069057:
	edi_22 = esp_18->ptr0034;
	struct Eq_57812 * esp_525 = esp_18 - 4;
	esp_525->dw0000 = (char *) edi_22 - 166080;
	esp_525->dwFFFFFFFC = 0x019F;
	esp_378 = esp_525 - 4;
	goto l08069067;
}

// subject_text_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080690C0: void __gconv_transform_ascii_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_57740) dwArg04, Stack (ptr32 Eq_57741) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_57741) dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      __gconv_transform_ucs4le_internal
void __gconv_transform_ascii_internal(struct Eq_9 * gs, struct Eq_57740 * dwArg04, struct Eq_57741 * dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, struct Eq_57741 * dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	ui32 esi_31 = gs->dw0014;
	ui32 edx_177 = dwArg08->dw0008;
	Eq_2 esp_171 = fp - 0x5C;
	ui32 dwLoc20_452 = esi_31;
	Eq_2 dwLoc3C_453 = 0x00;
	if (((byte) edx_177 & 0x01) == 0x00)
	{
		Eq_2 esi_43 = dwArg04->t0050;
		dwLoc3C_453 = esi_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc3C_453 = __ror(esi_43, 0x09) ^ gs->t0018;
	}
	Eq_2 eax_295;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 != null)
		{
			word32 ecx_733;
			word32 edx_734;
			__assert_fail(out ecx_733, out edx_734);
			goto l080693D2;
		}
		struct Eq_57826 * eax_87 = dwArg08->ptr0014;
		eax_87->dw0000 = 0x00;
		eax_87->t0004.u1 = 0x00;
		if ((dwArg08->dw0008 & 0x01) == 0x00)
		{
			word32 ecx_735;
			word32 edx_736;
			_dl_mcount_wrapper_check(gs, dwLoc70, dwLoc3C_453, out ecx_735, out edx_736);
			fn00000000();
		}
l080692F7:
		if ((dwLoc20_452 ^ gs->dw0014) == 0x00)
			return;
l080693D2:
		word32 ecx_737;
		word32 edx_738;
		eax_295 = __stack_chk_fail(out ecx_737, out edx_738);
		esp_171.u0 = <invalid>;
		goto l080693D7;
	}
	else
	{
		struct Eq_57741 * eax_136 = dwArg14;
		if (dwArg14 == null)
			eax_136 = dwArg08;
		Eq_57792 ebx_154 = eax_136->t0000;
		Eq_2 ecx_164 = *dwArg0C;
		while (dwArg10 != ecx_164)
		{
			Eq_57792 esi_170 = (word32) ebx_154 + 4;
			if (esi_170 <= *((word32) esp_171 + 4))
			{
				*((word32) esp_171 + 0x0C) = 0x04;
				*((word32) esp_171 + 24) = edx_177 & 0x02;
				Eq_2 eax_182 = ecx_164;
				do
				{
					word32 edx_187 = (word32) *eax_182;
					ecx_164 = eax_182;
					if ((byte) edx_187 < 0x00)
					{
						word32 * esi_203 = *((word64) esp_171.u0 + 44);
						if (esi_203 == null || *((word64) esp_171.u0 + 24) == 0x00)
						{
							*((word64) esp_171.u0 + 0x0C) = 0x06;
							goto l08069210;
						}
						++*esi_203;
						*((word64) esp_171.u0 + 0x0C) = 0x06;
						eax_182 = (word32) eax_182 + 1;
						ecx_164 = eax_182;
						if (dwArg10 == eax_182)
							goto l08069210;
					}
					else
					{
						*ebx_154 = edx_187;
						eax_182 = (word32) eax_182 + 1;
						ebx_154 = esi_170;
						ecx_164 = eax_182;
						if (dwArg10 == eax_182)
							goto l08069210;
					}
					esi_170 = (word32) ebx_154 + 4;
				} while (*((word64) esp_171.u0 + 4) >= esi_170);
				*((word32) esp_171 + 0x0C) = 0x05;
			}
			else
			{
				ebx_154 = *((word32) esp_171 + 8);
				*((word32) esp_171 + 0x0C) = 0x05;
			}
l08069210:
			**((word32) esp_171 + 16) = ecx_164;
			if (*((word32) esp_171 + 20) != null)
			{
l080692C0:
				**((word64) esp_171.u0 + 20) = ebx_154;
				dwLoc20_452 = esi_31;
				goto l080692F7;
			}
l08069222:
			++dwArg08->dw000C;
			dwLoc20_452 = esi_31;
			if ((dwArg08->dw0008 & 0x01) != 0x00)
			{
				dwArg08->t0000 = ebx_154;
				word32 * edi_249 = *((word64) esp_171.u0 + 28);
				*edi_249 = (word32) *((word64) esp_171.u0 + 52) + *edi_249;
				goto l080692F7;
			}
			if (ebx_154 <= *((word64) esp_171.u0 + 8))
				goto l080692F7;
			struct Eq_58499 * esp_257 = esp_171 - 0x0C;
			esp_257->t0044 = dwArg08->t0000;
			esp_257->tFFFFFFFC = esp_257->t002C;
			word32 edx_740;
			word32 ecx_739;
			_dl_mcount_wrapper_check(gs, esp_257->tFFFFFFF8, esp_257->tFFFFFFFC, out ecx_739, out edx_740);
			esp_257->tFFFFFFF8 = esp_257->t0088;
			esp_257->dwFFFFFFF4 = 0x00;
			esp_257->dwFFFFFFF0 = esp_257->dw0028;
			esp_257->dwFFFFFFEC = 0x00;
			esp_257->tFFFFFFE8 = ebx_154;
			esp_257->ptrFFFFFFE4 = (word32 *) &esp_257->t0044;
			esp_257->dwFFFFFFE0 = esp_257->dw0034;
			esp_257->dwFFFFFFDC = esp_257->dw0030;
			fn00000000();
			esp_171 = (char *) &esp_257->tFFFFFFFC + 16;
			if (eax_295 != 0x04)
			{
				Eq_57792 edx_303 = esp_257->t0044;
				if (ebx_154 != edx_303)
				{
					Eq_58582 ebx_306 = ebx_154 - edx_303;
					union Eq_2 * esi_308 = esp_257->ptr001C;
					if (ebx_306 < 0x00)
						ebx_306 = (word32) ebx_306 + 3;
					*esi_308 = (union Eq_2 *) (*esi_308 - (ebx_306 >> 0x02));
				}
				if (eax_295 != 0x00)
				{
l080693D7:
					*((word32) esp_171 + 0x0C) = eax_295;
					goto l080692F7;
				}
			}
			else if (esp_257->dw0018 != 0x05)
				goto l080692F7;
			edx_177 = dwArg08->dw0008;
			esp_257->t0014 = dwArg08->t0000;
			ebx_154 = esp_257->t0014;
			ecx_164 = *esp_257->ptr001C;
		}
		union Eq_2 * eax_345 = *((word32) esp_171 + 16);
		*((word32) esp_171 + 0x0C) = 0x04;
		*eax_345 = (union Eq_2 *) ecx_164;
		if (*((word32) esp_171 + 20) != 0x00)
			goto l080692C0;
		goto l08069222;
	}
}

// 080693E0: void __gconv_transform_internal_ascii(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_58641) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ascii(struct Eq_9 * gs, struct Eq_58641 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - (struct Eq_58651 *) 0x8C;
	Eq_2 esi_23 = dwArg08;
	ui32 ebp_26 = *((word32) dwArg08 + 8);
	ui32 ecx_34 = gs->dw0014;
	Eq_2 dwLoc68_1047 = 0x00;
	if ((ebp_26 & 0x01) == 0x00)
	{
		Eq_2 ecx_45 = dwArg04->t0050;
		dwLoc68_1047 = ecx_45;
		if (dwArg04->dw003C != 0x00)
			dwLoc68_1047 = __ror(ecx_45, 0x09) ^ gs->t0018;
	}
	struct Eq_58667 * esp_499;
	struct Eq_58668 * esp_361;
	ptr32 esp_828;
	Eq_2 esi_824;
	if (dwArg1C == 0x00)
	{
		Eq_2 edx_122 = dwArg14;
		Eq_2 eax_1006 = *dwArg0C;
		if (dwArg14 == 0x00)
			edx_122 = dwArg08;
		Eq_2 ebx_131 = *edx_122;
		Eq_2 ebx_136 = *((word32) dwArg08 + 4);
		word32 * ebx_141 = null;
		if (dwArg18 != null)
			ebx_141 = fp - 0x30;
		Eq_2 edi_1008;
		struct Eq_58710 * esp_415;
		Eq_2 ebp_1005;
		ui32 edx_1004;
		if (dwArg20 == 0x00)
		{
l080694E1:
			edx_1004 = ebp_26;
			edi_1008 = dwArg10;
			ebp_1005 = ebx_131;
			esi_23 = dwArg08;
			goto l080694F0;
		}
		struct Eq_58734 * ebx_153 = *((word32) dwArg08 + 20);
		ui32 edx_154 = ebx_153->dw0000;
		ui32 dwLoc4C_1087 = edx_154;
		struct Eq_58777 * dwLoc7C_1088 = edx_154 & 0x07;
		if ((edx_154 & 0x07) == 0x00)
			goto l080694E1;
		if (dwArg14 != 0x00)
			goto l08069BFD;
		Eq_2 dwLoc28_1091 = ebx_131;
		if ((edx_154 & 0x07) > 0x04)
		{
			word32 ecx_1876;
			word32 edx_1877;
			__assert_fail(out ecx_1876, out edx_1877);
			__gconv_transform_internal_utf8(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
			return;
		}
		up32 edx_211;
		int32 edx_206 = 0x00;
		if ((edx_154 & 0x07) != 0x00)
		{
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[edx_206].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_59107) (&ebx_153->dw0004)[edx_206];
				++edx_206;
			} while ((edx_154 & 0x07) != edx_206);
			edx_211 = 0x04 - (edx_154 & 0x07);
		}
		else
			edx_211 = 0x04;
		if (dwArg10 < (word32) eax_1006 + edx_211)
		{
			*dwArg0C = (union Eq_2 *) dwArg10;
			if (eax_1006 < dwArg10)
			{
				Eq_2 eax_243 = (word32) eax_1006 + 1;
				struct Eq_59421 * ebx_245 = ebx_153 + (edx_154 & 0x07) / 8;
				while (true)
				{
					++ebx_245;
					ebx_245[3] = (struct Eq_59421) *((word32) eax_243 - 1);
					Eq_2 edx_255 = (word32) eax_243 + 1;
					if (dwArg10 == eax_243)
						break;
					eax_243 = edx_255;
				}
			}
			goto l08069A87;
		}
		Eq_2 edx_260 = eax_1006;
		if (ebx_131 >= ebx_136)
			goto l08069600;
		Eq_59125 ebx_269 = edx_154 & 0x07;
		do
		{
			edx_260 = (word32) edx_260 + 1;
			ebx_269 = (word32) ebx_269 + 1;
			Mem279[fp - 0x25 + ebx_269:byte] = Mem275[edx_260 + -1:byte];
		} while (ebx_269 <= 0x03 && dwArg10 > edx_260);
		struct Eq_58777 * eax_303;
		byte dl_475 = (byte) dwLoc24;
		struct Eq_58734 * ebx_294 = ebx_153;
		if (dwLoc24 <= 0x7F)
		{
			*ebx_131 = dl_475;
			dwLoc28_1091 = (word32) ebx_131 + 1;
			if (fp - 0x20 != fp - (struct Eq_59159 *) 0x24)
			{
				ui32 ecx_492 = ebx_153->dw0000;
				eax_303 = fp - 0x20 - (fp - (struct Eq_59159 *) 0x24);
				dwLoc4C_1087 = ecx_492;
				dwLoc7C_1088 = ecx_492 & 0x07;
				goto l080697A9;
			}
			goto l08069982;
		}
		if (dwLoc24 >> 0x07 == 0x1C00)
		{
			eax_303 = (struct Eq_58777 *) 0x04;
			goto l080697A9;
		}
		if (ebx_141 == null)
		{
l08069B00:
			goto l08069600;
		}
		struct Eq_58777 * eax_364;
		if ((ebp_26 & 0x08) == 0x00)
		{
			if ((ebp_26 & 0x02) == 0x00)
				goto l08069600;
			goto l08069AC6;
		}
		word32 edi_320 = ebx_269 + (fp - 0x24);
		dwLocA0 = fp - (struct Eq_59238 *) 44;
		ui32 ebp_350;
		word32 edi_1880;
		word32 eax_349 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_59238 *) 44, edi_320, fp - (struct Eq_59245 *) 0x28, ebx_141, out ebx_294, out ebp_350, out esi_23, out edi_1880);
		esp_361 = fp - (struct Eq_59252 *) 0x8C;
		Eq_2 ecx_363 = fp - (struct Eq_59159 *) 0x24;
		eax_364 = fp - (struct Eq_59159 *) 0x24;
		if (eax_349 == 0x06)
		{
			if ((ebp_350 & 0x02) == 0x00)
			{
l08069AD4:
				if (eax_364 != fp - (struct Eq_59159 *) 0x24)
				{
l08069AD8:
					ui32 edi_462 = ebx_294->dw0000;
					eax_303 = eax_364 - (fp - (struct Eq_59159 *) 0x24);
					dwLoc4C_1087 = edi_462;
					dwLoc7C_1088 = edi_462 & 0x07;
l080697A9:
					esp_499 = fp - (struct Eq_58651 *) 0x8C;
					if (eax_303 <= dwLoc7C_1088)
						goto l08069BD5;
					ui32 ebp_510 = *((word32) esi_23 + 8);
					eax_1006 = (char *) *dwArg0C + (eax_303 - dwLoc7C_1088);
					*dwArg0C = (union Eq_2 *) eax_1006;
					ebx_294->dw0000 = dwLoc4C_1087 & ~0x07;
					edx_1004 = ebp_510;
					ebp_1005 = dwLoc28_1091;
					edi_1008 = dwArg10;
l080694F0:
					while (true)
					{
						ui32 edx_531 = edx_1004 & 0x02;
						Eq_2 dwLoc2C_1216 = eax_1006;
						Eq_2 ebx_538 = ebp_1005;
						Eq_2 dwLoc28_1217 = ebp_1005;
						word32 dwLoc7C_1218 = 0x04;
l08069509:
						if (edi_1008 != eax_1006)
						{
							do
							{
								Eq_2 ecx_547 = (word32) eax_1006 + 4;
								if (edi_1008 < ecx_547)
								{
									*dwArg0C = (union Eq_2 *) eax_1006;
									dwLoc7C_1218 = 0x07;
									if (dwArg14 != 0x00)
										goto l080695FA;
									goto l08069562;
								}
								if (ebx_136 <= ebx_538)
								{
									dwLoc7C_1218 = 0x05;
									break;
								}
								uint32 edx_564 = *eax_1006;
								byte dl_640 = (byte) edx_564;
								if (edx_564 > 0x7F)
								{
									if (edx_564 >> 0x07 == 0x1C00)
									{
										dwLoc2C_1216 = ecx_547;
										eax_1006 = ecx_547;
										goto l08069509;
									}
									if (ebx_141 != null)
									{
										if ((*((word32) esi_23 + 8) & 0x08) != 0x00)
										{
											word32 ebx_1871;
											word32 eax_603 = __gconv_transliterate(gs, dwArg04, esi_23, fp - 44, edi_1008, fp - 0x28, ebx_141, out ebx_1871, out ebp_1005, out esi_23, out edi_1008);
											dwLocA0 = fp - 44;
											dwLoc7C_1218 = eax_603;
											ebx_538 = dwLoc28_1217;
											eax_1006 = dwLoc2C_1887;
											if (eax_603 != 0x06)
											{
												if (eax_603 == 0x05)
													break;
												goto l08069509;
											}
										}
										if (edx_531 != 0x00)
										{
											++*ebx_141;
											eax_1006 = (word32) eax_1006 + 4;
											dwLoc7C_1218 = 0x06;
											dwLoc2C_1216 = eax_1006;
											goto l08069509;
										}
									}
									dwLoc7C_1218 = 0x06;
									break;
								}
								Eq_2 eax_638 = (word32) ebx_538 + 1;
								*ebx_538 = dl_640;
								dwLoc28_1217 = eax_638;
								ebx_538 = eax_638;
								eax_1006 = (word32) dwLoc2C_1887 + 4;
								dwLoc2C_1216 = (word32) dwLoc2C_1887 + 4;
								dwLoc2C_1887 = dwLoc2C_1216;
							} while (edi_1008 != (word32) dwLoc2C_1887 + 4);
						}
						*dwArg0C = (union Eq_2 *) eax_1006;
						if (dwArg14 != 0x00)
							break;
l08069562:
						*((word32) esi_23 + 0x0C) = (word32) *((word32) esi_23 + 0x0C) + 1;
						if ((*((word32) esi_23 + 8) & 0x01) != 0x00)
						{
							*esi_23 = ebx_538;
							*dwArg18 = *dwArg18;
							goto l080697F0;
						}
						word32 eax_703;
						if (ebp_1005 < ebx_538)
						{
							Eq_2 eax_704 = *esi_23;
							word32 edx_1873;
							word32 ecx_1872;
							_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc68_1047, out ecx_1872, out edx_1873);
							word32 edx_754;
							fn00000000();
							dwLocA0 = dwArg20;
							if (eax_703 != 0x04)
							{
								if (eax_704 != ebx_538)
									*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_538 - eax_704) * 0x04);
								goto l080695C5;
							}
							eax_703 = dwLoc7C_1218;
							if (dwLoc7C_1218 != 0x05 && dwLoc7C_1218 != 0x00)
								goto l08069685;
							goto l080695CD;
						}
						eax_703 = dwLoc7C_1218;
l080695C5:
						if (eax_703 != 0x00)
						{
l08069685:
							dwLoc7C_1218 = eax_703;
l080697F0:
							esp_415 = fp - (struct Eq_58651 *) 0x8C;
							if (dwLoc7C_1218 != 0x07 || dwArg20 == 0x00)
								goto l08069600;
							Eq_2 ebp_795 = *dwArg0C;
							if (edi_1008 - ebp_795 > 0x03)
								goto l08069B49;
							struct Eq_59030 * eax_838;
							struct Eq_58734 * ebx_833 = *((word32) esi_23 + 20);
							word32 eax_834 = ebp_795 + 0x01;
							union Eq_59038 * edx_835 = &ebx_833->dw0004;
							if (ebp_795 < edi_1008)
							{
								while (true)
								{
									*dwArg0C = (union Eq_2 *) eax_834;
									edx_835 = (union Eq_59038 *) ((char *) edx_835 + 1);
									*((char *) edx_835 - 1) = (union Eq_59038 *) *((word32) eax_834 - 1);
									word32 ecx_851 = eax_834 + 0x01;
									if (eax_834 == edi_1008)
										break;
									eax_834 = ecx_851;
								}
								eax_838 = eax_834 - ebp_795;
							}
							else
								eax_838 = null;
							ebx_833->dw0000 = eax_838 | ebx_833->dw0000 & ~0x07;
							goto l08069600;
						}
l080695CD:
						edx_1004 = (ui32) *((word32) esi_23 + 8);
						ebp_1005 = *esi_23;
						eax_1006 = *dwArg0C;
					}
l080695FA:
					*dwArg14 = ebx_538;
l08069600:
					if ((ecx_34 ^ gs->dw0014) == 0x00)
						return;
l08069BF8:
					word32 ecx_1869;
					word32 edx_1870;
					__stack_chk_fail(out ecx_1869, out edx_1870);
					esp_18.u0 = <invalid>;
l08069BFD:
					esi_824 = *((word32) esp_18 + 60);
					struct Eq_59073 * esp_902 = esp_18 - 4;
					esp_902->dw0000 = (word32) esi_824 - 166208;
					esp_902->dwFFFFFFFC = 0x022F;
					esp_828 = esp_902 - 4;
l08069B7C:
					struct Eq_58828 * esp_909 = esp_828 - 4;
					esp_909->dw0000 = (word32) esi_824 - 167166;
					esp_909->dwFFFFFFFC = (word32) esi_824 - 167146;
					word32 ecx_1867;
					word32 edx_1868;
					__assert_fail(out ecx_1867, out edx_1868);
					Eq_2 esp_916 = <invalid>;
					esp_361 = (word32) esp_916 - 4;
					goto l08069B8F;
				}
				goto l08069B00;
			}
l08069AC6:
			++*ebx_141;
			eax_364 = fp - (struct Eq_59271 *) 0x20;
			goto l08069AD4;
		}
		if (fp - (struct Eq_59159 *) 0x24 != fp - (struct Eq_59159 *) 0x24)
			goto l08069AD8;
		if (eax_349 != 0x07)
		{
			if (eax_349 != 0x00)
				goto l08069600;
l08069982:
			edi_1008 = dwArg10;
			edx_1004 = (ui32) *((word32) esi_23 + 8);
			eax_1006 = *dwArg0C;
			ebp_1005 = ebx_131;
			goto l080694F0;
		}
		if (edi_320 == fp - (struct Eq_59294 *) 0x20)
			goto l08069BB2;
		ui32 eax_381 = ebx_294->dw0000;
		Mem391[dwArg0C + 0x00:word32] = Mem360[dwArg0C + 0x00:word32] + (ebx_269 - (eax_381 & 0x07));
		if ((eax_381 & ~0x07) >= ebx_269)
		{
l08069B8F:
			Eq_2 esi_924 = esp_361[60];
			struct Eq_59353 * esp_926 = esp_361 - (struct Eq_59354 *) 4;
			esp_926->dw0000 = (word32) esi_924 - 166656;
			esp_926->tFFFFFFFC.u0 = 0x01E5;
			esp_926->tFFFFFFF8 = (word32) esi_924 - 167069;
			esp_926->tFFFFFFF4 = (word32) esi_924 - 166884;
			word32 edx_1884;
			word32 ecx_1883;
			__assert_fail(out ecx_1883, out edx_1884);
			Eq_2 esp_938 = <invalid>;
			esp_361 = (word32) esp_938 - 4;
l08069BB2:
			Eq_2 esi_946 = esp_361[60];
			struct Eq_59301 * esp_948 = esp_361 - (struct Eq_59302 *) 4;
			esp_948->dw0000 = (word32) esi_946 - 166656;
			esp_948->tFFFFFFFC.u0 = 0x01DB;
			esp_948->tFFFFFFF8 = (word32) esi_946 - 167069;
			esp_948->tFFFFFFF4 = (word32) esi_946 - 0x00028C08;
			word32 ecx_1881;
			word32 edx_1882;
			__assert_fail(out ecx_1881, out edx_1882);
			Eq_2 esp_960 = <invalid>;
			esp_499 = (word32) esp_960 - 4;
l08069BD5:
			Eq_2 esi_968 = esp_499[60];
			struct Eq_59182 * esp_970 = esp_499 - 4;
			esp_970->dw0000 = (word32) esi_968 - 166656;
			esp_970->dwFFFFFFFC = 0x01C9;
			esp_970->dwFFFFFFF8 = (word32) esi_968 - 167069;
			esp_970->dwFFFFFFF4 = (word32) esi_968 - 166960;
			word32 edx_1879;
			word32 ecx_1878;
			__assert_fail(out ecx_1878, out edx_1879);
			goto l08069BF8;
		}
		if (ebx_269 <= 0x04)
		{
			ebx_294->dw0000 = eax_381 & ~0x07 | ebx_269;
			if (edi_320 > fp - (struct Eq_59159 *) 0x24)
			{
				struct Eq_59402 * eax_420 = &ebx_294->dw0004;
				do
				{
					++ecx_363;
					++eax_420;
					eax_420->bFFFFFFFF = (byte) *((word32) ecx_363 - 1);
				} while (edi_320 != ecx_363);
			}
l08069A87:
			goto l08069600;
		}
		word32 edx_1886;
		word32 ecx_1885;
		__assert_fail(out ecx_1885, out edx_1886);
		Eq_2 esp_410 = <invalid>;
		esp_415 = (word32) esp_410 - 4;
l08069B49:
		word32 esi_802 = esp_415->dw003C;
		struct Eq_58999 * esp_804 = esp_415 - 4;
		esp_804->dw0000 = esi_802 + ~0x0002893F;
		esp_804->dwFFFFFFFC = 777;
		esp_804->dwFFFFFFF8 = esi_802 + ~0x00028CFD;
		esp_804->dwFFFFFFF4 = esi_802 + ~0x00028CD5;
		word32 edx_1875;
		word32 ecx_1874;
		__assert_fail(out ecx_1874, out edx_1875);
		Eq_2 esp_816 = <invalid>;
		esp_18 = (word32) esp_816 - 4;
	}
	else if (dwArg14 == 0x00)
	{
		struct Eq_58734 * eax_69 = *((word32) dwArg08 + 20);
		eax_69->dw0000 = 0x00;
		eax_69->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 edx_1866;
			word32 ecx_1865;
			_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc68_1047, out ecx_1865, out edx_1866);
			word32 edx_113;
			fn00000000();
		}
		goto l08069600;
	}
	esi_824 = *((word32) esp_18 + 60);
	struct Eq_58720 * esp_826 = esp_18 - 4;
	esp_826->dw0000 = (word32) esi_824 - 166208;
	esp_826->dwFFFFFFFC = 0x019F;
	esp_828 = esp_826 - 4;
	goto l08069B7C;
}

// 08069C40: void __gconv_transform_internal_utf8(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_58641) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      __gconv_transform_internal_ascii
void __gconv_transform_internal_utf8(struct Eq_9 * gs, struct Eq_58641 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_1051 = fp - 0x7C;
	Eq_2 edi_1004 = dwArg08;
	Eq_2 ebp_1017 = dwArg10;
	ui32 esi_32 = gs->dw0014;
	Eq_2 dwLoc5C_1543 = 0x00;
	Eq_2 esi_1075 = *((word32) dwArg08 + 8);
	if ((esi_1075 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc5C_1543 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc5C_1543 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_59469 edx_1113;
	Eq_59470 eax_1165;
	ptr32 esp_1261;
	Eq_59472 ecx_1120;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 != 0x00)
		{
			edi_1004.u0 = 0x080CE000;
			esp_1261 = fp - 0x84;
			goto l0806A69C;
		}
		struct Eq_59518 * eax_74 = *((word32) dwArg08 + 20);
		eax_74->dw0000 = 0x00;
		eax_74->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_2710;
			word32 edx_2711;
			_dl_mcount_wrapper_check(gs, dwLoc90, dwLoc5C_1543, out ecx_2710, out edx_2711);
			word32 ecx_118;
			word32 edx_119;
			fn00000000();
			dwLoc90 = dwArg20;
		}
l08069E60:
		if ((esi_32 ^ gs->dw0014) == 0x00)
			return;
l0806A783:
		word32 ecx_2714;
		word32 edx_2715;
		__stack_chk_fail(out ecx_2714, out edx_2715);
		esp_1051.u0 = <invalid>;
		goto l0806A788;
	}
	Eq_2 eax_127 = *dwArg0C;
	Eq_2 eax_131 = dwArg14;
	if (dwArg14 == 0x00)
		eax_131 = dwArg08;
	byte * eax_136 = *eax_131;
	byte * eax_141 = *((word32) dwArg08 + 4);
	word32 * eax_146 = null;
	if (dwArg18 != null)
		eax_146 = fp - 0x34;
	if (dwArg20 == 0x00)
	{
l08069D40:
		Eq_59608 (* ecx_491)[] = *((word32) esp_1051 + 4);
		Eq_2 eax_1054 = *((word32) esp_1051 + 16);
		*((word32) esp_1051 + 8) = 0x04;
		*((word32) esp_1051 + 20) = esi_1075 & 0x02;
		*((word32) esp_1051 + 80) = eax_1054;
		*((word32) esp_1051 + 84) = ecx_491;
		Eq_59608 ebx_1053[] = ecx_491;
l08069D61:
		if (ebp_1017 != eax_1054)
		{
			do
			{
				if (ebp_1017 < (word32) eax_1054 + 4)
				{
					esi_1075 = *((word32) esp_1051 + 0x0C);
					*((word32) esp_1051 + 8) = 0x07;
					*esi_1075 = eax_1054;
					if (*((word32) esp_1051 + 24) != 0x00)
						goto l08069E5A;
					goto l08069DB2;
				}
				if (*esp_1051 <= ebx_1053)
				{
l08069E80:
					*((word32) esp_1051 + 8) = 0x05;
					break;
				}
				Eq_59604 edx_523 = *eax_1054;
				Eq_59608 dl_592 = (byte) edx_523;
				if (edx_523 <= 0x7F)
				{
					*((word32) esp_1051 + 84) = (char *) ebx_1053 + 1;
					ebx_1053[0] = dl_592;
					goto l08069D8D;
				}
				if (edx_523 <= ~0xDFFE || edx_523 < 0x00)
					goto l0806A1B0;
				Eq_60660 ecx_535;
				if ((edx_523 & ~0x07FF) != 0x00)
				{
					if ((edx_523 & 0xFFFF0000) != 0x00)
					{
						if ((edx_523 & 0xFFE00000) != 0x00)
							ecx_535 = (uint32) (int8) ((edx_523 & 0xFC000000) != 0x00) + 0x05;
						else
							ecx_535.u0 = 0x04;
					}
					else
						ecx_535.u0 = 0x03;
				}
				else
					ecx_535.u0 = 0x02;
				byte cl_563 = (byte) ecx_535;
				if (Mem512[esp_1051 + 0x00:word32] <u ebx_1053 + ecx_535)
					goto l08069E80;
				ui32 * esi_562 = *((word32) esp_1051 + 20);
				ebx_1053[0] = (byte) (~0xFF >> cl_563);
				Mem568[esp_1051 + 0x54:word32] = Mem566[esp_1051 + 0x54:word32] + ecx_535;
				do
				{
					--ecx_535;
					Mem579[ebx_1053 + ecx_535:byte] = SLICE(edx_523 & 0x3F | ~0x7F, byte, 0);
					edx_523 >>= 0x06;
					byte dl_585 = (byte) edx_523;
				} while (ecx_535 != 0x01);
				*((word32) esp_1051 + 20) = esi_562;
				Mem587[ebx_1053 + 0x00:byte] = Mem584[ebx_1053 + 0x00:byte] | dl_585;
l08069D8D:
				word32 eax_596 = *((word32) esp_1051 + 80);
				ebx_1053 = (Eq_59608 (*)[]) *((word32) esp_1051 + 84);
				*((word32) esp_1051 + 80) = eax_596 + 0x04;
				eax_1054 = eax_596 + 0x04;
			} while (ebp_1017 != eax_596 + 0x04);
		}
		while (true)
		{
			esi_1075 = *((word32) esp_1051 + 0x0C);
			*esi_1075 = eax_1054;
			if (*((word32) esp_1051 + 24) != 0x00)
				break;
l08069DB2:
			*((word64) edi_1004.u0 + 0x0C) = (word32) *((word64) edi_1004.u0 + 0x0C) + 1;
			if ((*((word64) edi_1004.u0 + 8) & 0x01) != 0x00)
			{
				esi_1075 = *((word32) esp_1051 + 28);
				word32 eax_635 = *((word32) esp_1051 + 72);
				*edi_1004.u0 = ebx_1053;
				*esi_1075 = (word32) *esi_1075 + eax_635;
				goto l0806A084;
			}
			if (*((word32) esp_1051 + 4) >= ebx_1053)
			{
				esi_1075 = *((word32) esp_1051 + 8);
				goto l08069E16;
			}
			struct Eq_59667 * esp_645 = esp_1051 - 0x0C;
			esp_645->ptr0058 = (Eq_59608 (*)[]) *edi_1004.u0;
			esp_645->tFFFFFFFC = esp_645->t002C;
			word32 edx_2713;
			word32 ecx_2712;
			_dl_mcount_wrapper_check(gs, esp_645->tFFFFFFF8, esp_645->tFFFFFFFC, out ecx_2712, out edx_2713);
			esp_645->tFFFFFFF8 = esp_645->t00A8;
			esp_645->dwFFFFFFF4 = 0x00;
			esp_645->dwFFFFFFF0 = esp_645->dw0028;
			esp_645->dwFFFFFFEC = 0x00;
			esp_645->ptrFFFFFFE8 = ebx_1053;
			esp_645->ptrFFFFFFE4 = &esp_645->ptr0058;
			esp_645->dwFFFFFFE0 = esp_645->dw0034;
			esp_645->dwFFFFFFDC = esp_645->dw0030;
			Eq_2 eax_695;
			word32 ecx_696;
			word32 edx_697;
			fn00000000();
			esi_1075 = eax_695;
			esp_1051 = (char *) &esp_645->tFFFFFFFC + 16;
			if (eax_695 == 0x04)
			{
				esi_1075 = esp_645->t0014;
				if (esi_1075 == 0x05)
					goto l08069E1E;
				goto l08069E16;
			}
			Eq_59608 (* edx_1497)[] = esp_645->ptr0058;
			if (edx_1497 == ebx_1053)
				goto l08069E16;
			Eq_2 eax_709 = esp_645->t001C;
			union Eq_2 * ecx_710 = esp_645->ptr0018;
			esp_645->t0020 = eax_695;
			esp_645->t001C.u0 = 0x04;
			*ecx_710 = (union Eq_2 *) eax_709;
			Eq_59608 (* ecx_714)[] = esp_645->ptr0010;
			esp_645->t005C = eax_709;
			esp_645->ptr0060 = ecx_714;
			Eq_2 ecx_718 = *((word64) edi_1004.u0 + 8);
			esp_645->t0014 = edi_1004;
			esp_645->dw0044 = ecx_718 & 0x02;
			ebx_1053 = ecx_714;
l0806A12A:
			if (ebp_1017 != eax_709)
			{
				do
				{
					if (ebp_1017 < (word32) eax_709 + 4)
						goto l0806A23E;
					if (edx_1497 <= ebx_1053)
						goto l0806A2C1;
					Eq_59970 esi_738 = *eax_709;
					if (esi_738 <= 0x7F)
					{
						*((word32) esp_1051 + 84) = (char *) ebx_1053 + 1;
						ebx_1053[0] = (byte) esi_738;
					}
					else
					{
						if (esi_738 <= ~0xDFFE || esi_738 < 0x00)
						{
							if (*((word32) esp_1051 + 48) == 0x00)
								goto l0806A23E;
							if ((*((word32) *((word32) esp_1051 + 8) + 8) & 0x08) == 0x00)
								goto l0806A5F7;
							goto l0806A271;
						}
						Eq_60449 ecx_761;
						if ((esi_738 & ~0x07FF) != 0x00)
						{
							if ((esi_738 & 0xFFFF0000) != 0x00)
							{
								if ((esi_738 & 0xFFE00000) != 0x00)
									ecx_761 = (uint32) (int8) ((esi_738 & 0xFC000000) != 0x00) + 0x05;
								else
									ecx_761.u0 = 0x04;
							}
							else
								ecx_761.u0 = 0x03;
						}
						else
							ecx_761.u0 = 0x02;
						byte cl_788 = (byte) ecx_761;
						if (edx_1497 <u ebx_1053 + ecx_761)
							goto l0806A2C1;
						word32 edi_787 = *((word32) esp_1051 + 8);
						ebx_1053[0] = (byte) (~0xFF >> cl_788);
						Mem793[esp_1051 + 0x54:word32] = Mem791[esp_1051 + 0x54:word32] + ecx_761;
						do
						{
							--ecx_761;
							Mem804[ebx_1053 + ecx_761:byte] = SLICE(esi_738 & 0x3F | ~0x7F, byte, 0);
							esi_738 >>= 0x06;
						} while (ecx_761 != 0x01);
						*((word32) esp_1051 + 8) = edi_787;
						Mem813[ebx_1053 + 0x00:byte] = Mem810[ebx_1053 + 0x00:byte] | SLICE(esi_738, byte, 0);
					}
					word32 eax_823 = *((word32) esp_1051 + 80);
					ebx_1053 = (Eq_59608 (*)[]) *((word32) esp_1051 + 84);
					*((word32) esp_1051 + 80) = eax_823 + 0x04;
					eax_709 = eax_823 + 0x04;
				} while (ebp_1017 != eax_823 + 0x04);
			}
			esi_1075 = *((word32) esp_1051 + 20);
			edi_1004 = *((word32) esp_1051 + 8);
			**((word32) esp_1051 + 0x0C) = ebp_1017;
			if (*((word32) esp_1051 + 76) == ebx_1053)
			{
				if (*((word32) esp_1051 + 16) != 0x05)
					goto l0806A18D;
l0806A2E5:
				if (*((word32) esp_1051 + 4) == ebx_1053)
					--*((word64) edi_1004.u0 + 0x0C);
l08069E16:
				if (esi_1075 != 0x00)
				{
					*((word32) esp_1051 + 8) = esi_1075;
l0806A084:
					if (*((word32) esp_1051 + 0x009C) == 0x00 || *((word32) esp_1051 + 8) != 0x07)
						goto l08069E60;
					esi_1075 = **((word32) esp_1051 + 0x0C);
					if (ebp_1017 - esi_1075 > 0x03)
					{
						edi_1004 = *((word32) esp_1051 + 44);
						struct Eq_60264 * esp_1102 = esp_1051 - 4;
						esp_1102->ptr0000 = (ptr32) ((word64) edi_1004.u0 - 166240);
						esp_1102->dwFFFFFFFC = 777;
						esp_1102->ptrFFFFFFF8 = (ptr32) ((word64) edi_1004.u0 - 167166);
						esp_1102->ptrFFFFFFF4 = (ptr32) ((word64) edi_1004.u0 - 167126);
						word32 ecx_2725;
						__assert_fail(out ecx_2725, out edx_1113);
						Eq_2 esp_1114 = <invalid>;
						esp_1051 = (word32) esp_1114 - 4;
						goto l0806A74C;
					}
					else
					{
						Eq_60294 eax_1189;
						ui32 * ebx_1183 = *((word64) edi_1004.u0 + 20);
						Eq_2 eax_1184 = (word32) esi_1075 + 1;
						union Eq_2 * edi_1185 = *((word32) esp_1051 + 0x0C);
						struct Eq_60306 * edx_1186 = ebx_1183 + 1;
						if (esi_1075 < ebp_1017)
						{
							while (true)
							{
								*edi_1185 = (union Eq_2 *) eax_1184;
								++edx_1186;
								edx_1186->bFFFFFFFF = (byte) *((word32) eax_1184 - 1);
								Eq_2 ecx_1200 = (word32) eax_1184 + 1;
								if (eax_1184 == ebp_1017)
									break;
								eax_1184 = ecx_1200;
							}
							eax_1189 = eax_1184 - esi_1075;
						}
						else
							eax_1189.u0 = 0x00;
						*ebx_1183 = eax_1189 | *ebx_1183 & ~0x07;
						goto l08069E60;
					}
				}
l08069E1E:
				esi_1075 = *((word64) edi_1004.u0 + 8);
				*((word32) esp_1051 + 16) = **((word32) esp_1051 + 0x0C);
				*((word32) esp_1051 + 4) = *edi_1004.u0;
				goto l08069D40;
			}
			do
			{
				word32 edi_847 = *((word32) esp_1051 + 44);
				struct Eq_59991 * esp_849 = esp_1051 - 4;
				esp_849->dw0000 = edi_847 + ~0x0002895F;
				esp_849->dwFFFFFFFC = 727;
				esp_849->dwFFFFFFF8 = edi_847 + ~0x00028CFD;
				esp_849->dwFFFFFFF4 = edi_847 + ~0x00028C8C;
				word32 ecx_2718;
				__assert_fail(out ecx_2718, out edx_1497);
				Eq_2 esp_861 = <invalid>;
				esp_1051 = (word32) esp_861 - 4;
l0806A271:
				*((word32) esp_1051 + 60) = edx_1497;
				struct Eq_60435 * esp_871 = esp_1051 - 0x04;
				esp_871->ptrFFFFFFFC = esp_871->ptr0034;
				esp_871->tFFFFFFF8 = &esp_871->ptr0058;
				esp_871->tFFFFFFF4 = ebp_1017;
				esp_871->tFFFFFFF0 = &esp_871->t0054;
				esp_871->dwFFFFFFEC = *esp_871->ptr0010;
				esp_871->tFFFFFFE8 = esp_871->t000C;
				esp_871->ptrFFFFFFE4 = esp_871->ptr0038;
				word32 esi_2727;
				word32 edi_2728;
				word32 ebx_2726;
				word32 eax_905 = __gconv_transliterate(gs, esp_871->ptrFFFFFFE4, esp_871->tFFFFFFE8, esp_871->tFFFFFFF0, esp_871->tFFFFFFF4, esp_871->tFFFFFFF8, esp_871->ptrFFFFFFFC, out ebx_2726, out ebp_1017, out esi_2727, out edi_2728);
				esp_871->dw0014 = eax_905;
				esp_1051 = (char *) &esp_871->ptrFFFFFFFC + 8;
				edx_1497 = esp_871->ptr0040;
				eax_709 = esp_871->t0054;
				ebx_1053 = esp_871->ptr0058;
				if (eax_905 != 0x06)
				{
					if (esp_871->dw0014 != 0x05)
						goto l0806A12A;
l0806A2C1:
					union Eq_2 * ecx_952 = *((word32) esp_1051 + 0x0C);
					esi_1075 = *((word32) esp_1051 + 20);
					*((word32) esp_1051 + 16) = eax_709;
					edi_1004 = *((word32) esp_1051 + 8);
					*ecx_952 = (union Eq_2 *) *((word32) esp_1051 + 16);
					ebx_1053 = (Eq_59608 (*)[]) *((word32) esp_1051 + 76);
					if (ebx_1053 == ebx_1053)
						goto l0806A2E5;
					continue;
				}
l0806A5F7:
				if (*((word32) esp_1051 + 56) != 0x00)
				{
					word32 * edi_941 = *((word32) esp_1051 + 48);
					*((word32) esp_1051 + 16) = 0x06;
					eax_709 = (word32) eax_709 + 4;
					*((word32) esp_1051 + 80) = eax_709;
					++*edi_941;
					goto l0806A12A;
				}
l0806A23E:
				**((word32) esp_1051 + 0x0C) = eax_709;
			} while (ebx_1053 != *((word32) esp_1051 + 76));
l0806A18D:
			edi_1004 = *((word32) esp_1051 + 44);
			struct Eq_60033 * esp_980 = esp_1051 - 4;
			esp_980->ptr0000 = (ptr32) ((word64) edi_1004.u0 - 166240);
			esp_980->dwFFFFFFFC = 0x02D8;
			esp_980->ptrFFFFFFF8 = (ptr32) ((word64) edi_1004.u0 - 167166);
			esp_980->ptrFFFFFFF4 = (ptr32) ((word64) edi_1004.u0 - 166800);
			Eq_2 esp_992 = <invalid>;
			word32 edx_2720;
			word32 ecx_2719;
			eax_1054 = __assert_fail(out ecx_2719, out edx_2720);
			esp_1051 = (word32) esp_992 - 4;
l0806A1B0:
			if (*((word32) esp_1051 + 48) != 0x00)
			{
				if ((*((word64) edi_1004.u0 + 8) & 0x08) != 0x00)
				{
					struct Eq_60075 * esp_1008 = esp_1051 - 0x04;
					esp_1008->ptrFFFFFFFC = esp_1008->ptr0034;
					esp_1008->tFFFFFFF8 = &esp_1008->ptr0058;
					esp_1008->tFFFFFFF4 = ebp_1017;
					esp_1008->tFFFFFFF0 = &esp_1008->t0054;
					esp_1008->dwFFFFFFEC = *esp_1008->ptr0010;
					esp_1008->tFFFFFFE8 = edi_1004;
					esp_1008->ptrFFFFFFE4 = esp_1008->ptr0038;
					word32 ebx_2721;
					word32 esi_2722;
					word32 eax_1039 = __gconv_transliterate(gs, esp_1008->ptrFFFFFFE4, esp_1008->tFFFFFFE8, esp_1008->tFFFFFFF0, esp_1008->tFFFFFFF4, esp_1008->tFFFFFFF8, esp_1008->ptrFFFFFFFC, out ebx_2721, out ebp_1017, out esi_2722, out edi_1004);
					esp_1008->dw000C = eax_1039;
					esp_1051 = (char *) &esp_1008->ptrFFFFFFFC + 8;
					ebx_1053 = esp_1008->ptr0058;
					eax_1054 = esp_1008->t0054;
					if (eax_1039 != 0x06)
					{
						if (esp_1008->dw000C == 0x05)
							continue;
						goto l08069D61;
					}
				}
				if (*((word32) esp_1051 + 20) != 0x00)
				{
					word32 * esi_1064 = *((word32) esp_1051 + 48);
					*((word32) esp_1051 + 8) = 0x06;
					eax_1054 = (word32) eax_1054 + 4;
					*((word32) esp_1051 + 80) = eax_1054;
					++*esi_1064;
					goto l08069D61;
				}
			}
			*((word32) esp_1051 + 8) = 0x06;
		}
l08069E5A:
		**((word32) esp_1051 + 24) = ebx_1053;
		goto l08069E60;
	}
	struct Eq_59518 * eax_158 = *((word32) dwArg08 + 20);
	ui32 eax_160 = eax_158->dw0000;
	if ((eax_160 & 0x07) == 0x00)
		goto l08069D40;
	if (dwArg14 != 0x00)
		goto l0806A7AB;
	if ((eax_160 & 0x07) > 0x04)
	{
l0806A788:
		word32 edi_1235 = *((word32) esp_1051 + 44);
		struct Eq_60774 * esp_1237 = esp_1051 - 4;
		esp_1237->dw0000 = edi_1235 + ~0x00028B1B;
		esp_1237->dwFFFFFFFC = 0x018B;
		esp_1237->dwFFFFFFF8 = edi_1235 + ~0x00028C9C;
		esp_1237->dwFFFFFFF4 = edi_1235 + 4294800288;
		word32 ecx_2729;
		word32 edx_2730;
		__assert_fail(out ecx_2729, out edx_2730);
		Eq_2 esp_1249 = <invalid>;
		esp_1051 = (word32) esp_1249 - 4;
l0806A7AB:
		edi_1004 = *((word32) esp_1051 + 44);
		struct Eq_60753 * esp_1259 = esp_1051 - 4;
		esp_1259->ptr0000 = (ptr32) ((word64) edi_1004.u0 - 166240);
		esp_1259->dwFFFFFFFC = 0x022F;
		esp_1261 = esp_1259 - 4;
l0806A69C:
		struct Eq_59871 * esp_1266 = esp_1261 - 4;
		esp_1266->ptr0000 = (ptr32) ((word64) edi_1004.u0 - 167166);
		esp_1266->ptrFFFFFFFC = (ptr32) ((word64) edi_1004.u0 - 167146);
		word32 edx_2717;
		word32 ecx_2716;
		__assert_fail(out ecx_2716, out edx_2717);
		Eq_2 esp_1273 = <invalid>;
		esp_1051 = (word32) esp_1273 - 4;
		goto l0806A6AF;
	}
	up32 eax_185;
	int32 eax_180 = 0x00;
	if ((eax_160 & 0x07) != 0x00)
	{
		do
		{
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[eax_180].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_60815) (&eax_158->dw0004)[eax_180];
			++eax_180;
		} while ((eax_160 & 0x07) != eax_180);
		eax_185 = 0x04 - (eax_160 & 0x07);
	}
	else
		eax_185 = 0x04;
	Eq_60841 ebx_1372 = eax_160 & 0x07;
	if (dwArg10 < (word32) eax_127 + eax_185)
	{
		*dwArg0C = (union Eq_2 *) dwArg10;
		if (eax_127 < dwArg10)
		{
			Eq_2 eax_225 = (word32) eax_127 + 1;
			struct Eq_60918 * edx_227 = eax_158 + (eax_160 & 0x07) / 8;
			while (true)
			{
				++edx_227;
				edx_227[3] = (struct Eq_60918) *((word32) eax_225 - 1);
				Eq_2 ecx_237 = (word32) eax_225 + 1;
				if (dwArg10 == eax_225)
					break;
				eax_225 = ecx_237;
			}
		}
		goto l0806A535;
	}
	else
	{
		if (eax_136 >= eax_141)
		{
l0806A402:
			*((word32) esp_1051 + 8) = 0x05;
			goto l08069E60;
		}
		Eq_2 eax_248 = eax_127;
		do
		{
			eax_248 = (word32) eax_248 + 1;
			ebx_1372 = (word32) ebx_1372 + 1;
			*((word32) ebx_1372 + (fp - 0x25)) = *((word32) eax_248 - 1);
		} while (ebx_1372 <= 0x03 && dwArg10 > eax_248);
		edx_1113 = dwLoc24;
		byte dl_486 = (byte) dwLoc24;
		if (dwLoc24 <= 0x7F)
		{
			*eax_136 = dl_486;
			goto l0806A01F;
		}
		if (dwLoc24 > ~0xDFFE && dwLoc24 >= 0x00)
		{
			if ((dwLoc24 & ~0x07FF) == 0x00)
			{
				ecx_1120.u0 = 0x02;
				goto l0806A58D;
			}
			if ((dwLoc24 & 0xFFFF0000) == 0x00)
			{
l0806A74C:
				ecx_1120.u0 = 0x03;
				goto l0806A58D;
			}
			if ((dwLoc24 & 0xFFE00000) != 0x00)
			{
				ecx_1120 = (uint32) (int8) ((dwLoc24 & 0xFC000000) != 0x00) + 0x05;
l0806A58D:
				esi_1075 = *((word32) esp_1051 + 4);
				byte cl_1136 = (byte) ecx_1120;
				if (Mem1124[esp_1051 + 0x00:word32] >=u esi_1075 + ecx_1120)
				{
					*esi_1075 = (byte) (~0xFF >> cl_1136);
					Mem1141[esp_1051 + 0x54:word32] = Mem1139[esp_1051 + 0x54:word32] + ecx_1120;
					do
					{
						--ecx_1120;
						Mem1152[esi_1075 + ecx_1120:byte] = SLICE(edx_1113 & 0x3F | ~0x7F, byte, 0);
						edx_1113 >>= 0x06;
						byte dl_1157 = (byte) edx_1113;
					} while (ecx_1120 != 0x01);
					byte * eax_1156 = *((word32) esp_1051 + 4);
					*eax_1156 |= dl_1157;
l0806A01F:
					word32 eax_1164 = *((word32) esp_1051 + 80);
					*((word32) esp_1051 + 80) = eax_1164 + 0x04;
					eax_1165 = eax_1164 + 0x04;
					if (eax_1164 + 0x04 != *((word32) esp_1051 + 56))
						goto l0806A034;
					goto l0806A436;
				}
				goto l0806A402;
			}
l0806A71F:
			ecx_1120.u0 = 0x04;
			goto l0806A58D;
		}
		if (eax_146 == null)
		{
l0806A67F:
			*((word32) esp_1051 + 8) = 0x06;
			goto l08069E60;
		}
		if ((esi_1075 & 0x08) == 0x00)
		{
			esi_1075 &= 0x02;
			if ((esi_1075 & 0x02) != 0x00)
				goto l0806A665;
			goto l08069E60;
		}
		word32 ecx_294 = fp - 0x24 + ebx_1372;
		dwLoc90 = fp - 44;
		Eq_60895 ebx_331;
		word32 eax_329 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_155289 *) 44, ecx_294, fp - 0x28, eax_146, out ebx_331, out ebp_1017, out esi_1075, out edi_1004);
		esp_1051 = fp - 0x7C;
		if (eax_329 == 0x06)
		{
l0806A6AF:
			esi_1075 &= 0x02;
			if (esi_1075 == 0x00)
			{
l0806A671:
				eax_1165 = *((word32) esp_1051 + 80);
				if (eax_1165 == *((word32) esp_1051 + 56))
					goto l0806A67F;
				goto l0806A034;
			}
l0806A665:
			word32 * eax_1292 = *((word32) esp_1051 + 48);
			*((word32) esp_1051 + 80) = (word32) *((word32) esp_1051 + 80) + 4;
			++*eax_1292;
			goto l0806A671;
		}
		eax_1165 = fp - (struct Eq_155289 *) 0x24;
		if (fp - (struct Eq_155289 *) 0x24 != fp - (struct Eq_155289 *) 0x24)
		{
l0806A034:
			esi_1075 = *((word32) esp_1051 + 20);
			int32 eax_1307 = eax_1165 - *((word32) esp_1051 + 56);
			Eq_2 edx_1308 = *esi_1075;
			if (eax_1307 > (edx_1308 & 0x07))
			{
				union Eq_2 * esi_1333 = *((word32) esp_1051 + 0x0C);
				Eq_2 eax_1336 = (char *) *esi_1333 + (eax_1307 - (edx_1308 & 0x07));
				*esi_1333 = (union Eq_2 *) eax_1336;
				esi_1075 = *((word64) edi_1004.u0 + 8);
				*((word32) esp_1051 + 16) = eax_1336;
				*((word32) esp_1051 + 4) = *((word32) esp_1051 + 84);
				**((word32) esp_1051 + 20) = edx_1308 & ~0x07;
				goto l08069D40;
			}
			word32 edi_1313 = *((word32) esp_1051 + 44);
			struct Eq_60185 * esp_1315 = esp_1051 - 4;
			esp_1315->dw0000 = edi_1313 + ~0x00028B1B;
			esp_1315->dwFFFFFFFC = 0x01C9;
			esp_1315->dwFFFFFFF8 = edi_1313 + ~0x00028C9C;
			esp_1315->dwFFFFFFF4 = edi_1313 + ~0x00028C2F;
			word32 edx_2724;
			word32 ecx_2723;
			__assert_fail(out ecx_2723, out edx_2724);
			goto l0806A783;
		}
		if (eax_329 != 0x07)
		{
			if (eax_329 != 0x00)
				goto l08069E60;
l0806A436:
			esi_1075 = *((word64) edi_1004.u0 + 8);
			*((word32) esp_1051 + 16) = **((word32) esp_1051 + 0x0C);
			goto l08069D40;
		}
		if (ecx_294 != fp - 0x20)
		{
			ui32 eax_359 = eax_158->dw0000;
			*dwArg0C = (union Eq_2 *) ((char *) *dwArg0C + (ebx_331 - (eax_359 & 0x07)));
			if (ebx_331 > (eax_359 & ~0x07))
			{
				if (ebx_331 <= 0x04)
				{
					eax_158->dw0000 = ebx_331 | eax_359 & ~0x07;
					Eq_2 eax_438 = fp - (struct Eq_155289 *) 0x24;
					if (ecx_294 > fp - (struct Eq_155289 *) 0x24)
					{
						ebp_1017 = &eax_158->dw0004;
						do
						{
							++eax_438;
							++ebp_1017;
							*((word32) ebp_1017 - 1) = *((word32) eax_438 - 1);
						} while (ecx_294 != eax_438);
					}
l0806A535:
					goto l08069E60;
				}
				word32 edx_2735;
				word32 ecx_2734;
				__assert_fail(out ecx_2734, out edx_2735);
				Eq_2 esp_386 = <invalid>;
				esp_1051 = (word32) esp_386 - 4;
			}
			word32 edi_394 = *((word32) esp_1051 + 44);
			Eq_61002 esp_396 = esp_1051 - 4;
			*esp_396 = edi_394 + ~0x00028B1B;
			*((word32) esp_396 - 4) = 0x01E5;
			*((word32) esp_396 - 8) = edi_394 + ~0x00028C9C;
			*((word32) esp_396 - 0x0C) = edi_394 + 4294800412;
			word32 edx_2733;
			word32 ecx_2732;
			__assert_fail(out ecx_2732, out edx_2733);
			Eq_2 esp_408 = <invalid>;
			esp_1051 = (word32) esp_408 - 4;
		}
		edi_1004 = *((word32) esp_1051 + 44);
		Eq_60951 esp_418 = esp_1051 - 4;
		*esp_418 = (word64) edi_1004.u0 - 166684;
		*((word32) esp_418 - 4) = 0x01DB;
		*((word32) esp_418 - 8) = (word64) edi_1004.u0 - 167069;
		*((word32) esp_418 - 0x0C) = (word64) edi_1004.u0 - 0x00028C08;
		word32 ecx_2731;
		__assert_fail(out ecx_2731, out edx_1113);
		Eq_2 esp_430 = <invalid>;
		esp_1051 = (word32) esp_430 - 4;
		goto l0806A71F;
	}
}

// 0806A7C0: void __gconv_transform_utf8_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_61070) dwArg04, Stack Eq_57792 dwArg08, Stack (ptr32 (ptr32 Eq_61073)) dwArg0C, Stack (ptr32 Eq_61073) dwArg10, Stack Eq_57792 dwArg14, Stack word32 dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_utf8_internal(struct Eq_9 * gs, struct Eq_61070 * dwArg04, Eq_57792 dwArg08, struct Eq_61073 ** dwArg0C, struct Eq_61073 * dwArg10, Eq_57792 dwArg14, word32 dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	ui32 edi_33 = gs->dw0014;
	Eq_2 esp_1278 = fp - 0x8C;
	ui32 dwLoc20_1725 = edi_33;
	Eq_2 dwLoc60_1726 = 0x00;
	Eq_57792 edi_1005 = *((word32) dwArg08 + 8);
	if ((edi_1005 & 0x01) == 0x00)
	{
		Eq_2 esi_45 = dwArg04->t0050;
		dwLoc60_1726 = esi_45;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_1726 = __ror(esi_45, 0x09) ^ gs->t0018;
	}
	Eq_57792 edx_1312;
	Eq_57792 eax_1363;
	Eq_57792 ebp_1014;
	Eq_57792 ecx_1020;
	Eq_2 ebx_1342;
	Eq_57792 ebx_1003;
	Eq_2 eax_709;
	ptr32 esp_1285;
	word32 esi_1281;
	Eq_57792 eax_1528;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == 0x00)
		{
			struct Eq_61161 * eax_70 = *((word32) dwArg08 + 20);
			eax_70->dw0000 = 0x00;
			eax_70->dw0004 = 0x00;
			edi_1005 = dwArg08;
			if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
			{
				word32 edx_2813;
				word32 ecx_2812;
				_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1726, out ecx_2812, out edx_2813);
				word32 edx_112;
				word32 ecx_113;
				fn00000000();
				dwLocA0 = dwArg20;
			}
			goto l0806AAB8;
		}
		goto l0806B38F;
	}
	struct Eq_61073 * eax_122 = *dwArg0C;
	Eq_57792 eax_126 = dwArg14;
	if (dwArg14 == 0x00)
		eax_126 = dwArg08;
	uint32 * eax_131 = *eax_126;
	up32 eax_136 = *((word32) dwArg08 + 4);
	if (dwArg20 == 0x00)
	{
l0806A8C4:
		eax_1528 = edi_1005;
		goto l0806A8D0;
	}
	struct Eq_61161 * eax_153 = *((word32) dwArg08 + 20);
	int32 eax_155 = eax_153->dw0000;
	byte al_169 = (byte) eax_155;
	if ((eax_155 & 0x07) == 0x00)
		goto l0806A8C4;
	if (dwArg14 != 0x00)
	{
l0806B339:
		esi_1281 = (word32) *((word32) esp_1278 + 0x0044);
		struct Eq_62234 * esp_836 = esp_1278 - 4;
		esp_836->dw0000 = esi_1281 + ~0x0002897F;
		esp_836->dwFFFFFFFC = 0x022F;
		esp_1285 = esp_836 - 4;
l0806B349:
		struct Eq_61257 * esp_843 = esp_1285 - 4;
		esp_843->dw0000 = esi_1281 + ~0x00028CFD;
		esp_843->dwFFFFFFFC = esi_1281 + ~0x00028CE9;
		Eq_2 esp_850 = <invalid>;
		word32 ecx_2814;
		eax_709 = __assert_fail(out ecx_2814, out edx_1312);
		esp_1278 = (word32) esp_850 - 4;
		goto l0806B35C;
	}
	Eq_2 eax_170 = (word32) al_169;
	Eq_2 edx_171 = eax_155 >> 0x08;
	uint32 ecx_173 = eax_153->dw0004;
	Eq_62257 bl_176 = (&g_t80A57FE)[eax_155 >> 0x08];
	do
	{
		--edx_171;
		if (eax_170 > edx_171)
			Mem191[fp - 0x26 + edx_171:byte] = SLICE(ecx_173 & 0x3F | ~0x7F, byte, 0);
		ecx_173 >>= 0x06;
		byte cl_201 = (byte) ecx_173;
	} while (edx_171 > 0x01);
	byte cl_202 = cl_201 | bl_176;
	if (eax_136 < eax_131 + 1)
	{
l0806AAB8:
		if ((dwLoc20_1725 ^ gs->dw0014) == 0x00)
			return;
		goto l0806B334;
	}
	struct Eq_61073 * edx_209 = eax_122;
	Eq_62286 ebp_210 = fp - 0x26;
	do
	{
		++edx_209;
		eax_170 = (word32) eax_170 + 1;
		Mem233[fp - 0x27 + eax_170:byte] = Mem224[edx_209 + -1:byte];
	} while (((int8) (eax_170 <= 0x05) & (int8) (dwArg10 > edx_209)) != 0x00);
	uint32 ebx_1546;
	Eq_62309 esi_1542;
	uint32 esi_240 = (word32) cl_202;
	uint32 ecx_1543 = esi_240;
	if (esi_240 <= 0x7F)
	{
		*eax_131 = esi_240;
		esi_1542.u0 = 0x01;
l0806ACA4:
		dwLoc20_1725 = edi_33;
		if (esi_1542 > *((word32) esp_1278 + 28))
		{
			union Eq_57792 * edi_630 = *((word32) esp_1278 + 20);
			*((word32) esp_1278 + 24) = (word32) *((word32) esp_1278 + 24) + (esi_1542 - *((word32) esp_1278 + 28));
			*edi_630 = (union Eq_57792 *) *((word32) esp_1278 + 24);
			(*((word32) esp_1278 + 16))->u0 = 0x00;
			Eq_57792 edi_640 = *((word32) *((word32) esp_1278 + 0x0C) + 8);
			*((word32) esp_1278 + 8) = *((word32) esp_1278 + 40);
			eax_1528 = edi_640;
l0806A8D0:
			edx_1312 = *((word32) esp_1278 + 24);
			if (*esp_1278 != edx_1312)
			{
				edi_1005 = *((word32) esp_1278 + 8);
				ebp_1014 = (word32) edi_1005 + 4;
				if (*((word32) esp_1278 + 4) >= (word32) edi_1005 + 4)
				{
					*((word32) esp_1278 + 16) = 0x04;
					*((word32) esp_1278 + 40) = eax_1528 & 0x02;
					do
					{
						eax_1363 = (word32) *edx_1312;
						ecx_1020 = (word32) edx_1312 + 1;
						ebx_1003 = eax_1363;
						if (eax_1363 > 0x7F)
						{
							if (eax_1363 <= 223)
							{
								*((word64) esp_1278.u0 + 28) = 0x02;
								eax_1363 &= 0x1F;
							}
							else
							{
								if ((byte) (eax_1363 & ~0x0F) != 0xE0)
									goto l0806AEC5;
								*((word32) esp_1278 + 28) = 0x03;
								eax_1363 &= 0x0F;
							}
l0806A944:
							word32 esi_701 = Mem697[esp_1278 + 0x1C:word32] + edx_1312;
							*((word32) esp_1278 + 60) = esi_701;
							ebx_1342.u0 = 0x01;
							if (*esp_1278 >= esi_701)
							{
								*((word64) esp_1278.u0 + 56) = ebp_1014;
								Eq_2 ebp_740 = *((word64) esp_1278.u0 + 28);
								do
								{
									word32 ecx_747 = CONVERT(Mem739[edx_1312 + ebx_1342:byte], byte, word32);
									if ((byte) (ecx_747 & ~0x3F) != 0x80)
										goto l0806A9C2;
									ebx_1342 = (word32) ebx_1342 + 1;
									eax_1363 = eax_1363 << 0x06 | ecx_747 & 0x3F;
								} while (ebp_740 != ebx_1342);
								ebp_1014 = *((word64) esp_1278.u0 + 56);
								if (ebx_1342 != 0x02 && eax_1363 >> (byte) ((ebx_1342 - 0x04) + ebx_1342 * 0x04) == 0x00 || eax_1363 <= ~0xDFFE)
									goto l0806A9C2;
								ecx_1020 = *((word64) esp_1278.u0 + 60);
								goto l0806A900;
							}
							Eq_57792 esi_705 = *esp_1278.u0;
							if (esi_705 <= ecx_1020)
							{
								eax_709.u0 = 0x01;
l0806AD4A:
								if (*esp_1278 != ecx_1020)
								{
l0806B35C:
									ebx_1342 = eax_709;
									goto l0806A9C2;
								}
								*((word32) esp_1278 + 16) = 0x07;
								goto l0806A9F0;
							}
							if ((byte) ((word32) *((word32) edx_1312 + 1) & ~0x3F) == 0x80)
							{
								eax_709 = esi_705 - edx_1312;
								do
								{
									ebx_1342 = (word32) ebx_1342 + 1;
									ecx_1020 = edx_1312 + ebx_1342;
									if (ebx_1342 == eax_709)
										goto l0806AD4A;
								} while (SLICE(CONVERT(Mem702[edx_1312 + ebx_1342:byte], byte, word32) & ~0x3F, byte, 0) == 0x80);
							}
l0806A9C2:
							word32 * eax_861 = *((word64) esp_1278.u0 + 64);
							if (eax_861 == null || *((word64) esp_1278.u0 + 40) == 0x00)
							{
								*((word64) esp_1278.u0 + 16) = 0x06;
								goto l0806A9F0;
							}
							++*eax_861;
							*((word64) esp_1278.u0 + 16) = 0x06;
							edx_1312 += ebx_1342;
							if (*esp_1278.u0 == edx_1312)
								goto l0806A9F0;
						}
						else
						{
l0806A900:
							*edi_1005 = eax_1363;
							edx_1312 = ecx_1020;
							edi_1005 = ebp_1014;
							if (*esp_1278.u0 == ecx_1020)
								goto l0806A9F0;
						}
						ebp_1014 = (word32) edi_1005 + 4;
					} while (*((word64) esp_1278.u0 + 4) >= ebp_1014);
					union Eq_57792 * eax_803 = *((word32) esp_1278 + 20);
					union Eq_57792 * ebx_804 = *((word32) esp_1278 + 32);
					*((word32) esp_1278 + 16) = 0x05;
					*eax_803 = (union Eq_57792 *) edx_1312;
					if (ebx_804 != null)
					{
l0806AAB2:
						**((word64) esp_1278.u0 + 32) = edi_1005;
						goto l0806AAB8;
					}
l0806AA02:
					struct Eq_61408 * eax_892 = *((word64) esp_1278.u0 + 0x0C);
					++eax_892->dw000C;
					if ((eax_892->b0008 & 0x01) != 0x00)
					{
						word32 * esi_898 = *((word64) esp_1278.u0 + 36);
						eax_892->t0000 = edi_1005;
						*esi_898 = (word32) *((word64) esp_1278.u0 + 92) + *esi_898;
						goto l0806AB0B;
					}
					if (*((word64) esp_1278.u0 + 8) >= edi_1005)
					{
l0806AB0B:
						if (*((word64) esp_1278.u0 + 0x00AC) != 0x00 && *((word32) esp_1278 + 16) == 0x07)
						{
							edi_1005 = **((word32) esp_1278 + 20);
							struct Eq_61639 * ebp_1401 = *((word32) *((word32) esp_1278 + 0x0C) + 20);
							uint32 edx_1404 = (word32) *edi_1005;
							uint32 esi_1405 = *esp_1278 - edi_1005;
							*((word32) esp_1278 + 4) = esi_1405;
							ebp_1401->dw0000 = esi_1405;
							if (edx_1404 <= 0xC1)
							{
								edi_1005 = *((word32) esp_1278 + 0x0044);
								struct Eq_61667 * esp_1414 = esp_1278 - 4;
								esp_1414->ptr0000 = (word32) edi_1005 - 166272;
								esp_1414->dwFFFFFFFC = 773;
								esp_1414->ptrFFFFFFF8 = (word32) edi_1005 - 167166;
								esp_1414->ptrFFFFFFF4 = (word32) edi_1005 - 0x00028C7C;
								word32 edx_2820;
								word32 ecx_2819;
								__assert_fail(out ecx_2819, out edx_2820);
l0806B334:
								word32 edx_2816;
								word32 ecx_2815;
								__stack_chk_fail(out ecx_2815, out edx_2816);
								esp_1278.u0 = <invalid>;
								goto l0806B339;
							}
							ui32 eax_1450;
							ui32 esi_1454;
							ui32 ecx_1453;
							if (edx_1404 <= 223)
							{
								eax_1450 = edx_1404 & 0x1F;
								ecx_1453 = 0x01;
								esi_1454 = 0x0200;
							}
							else if ((byte) (edx_1404 & ~0x0F) == 0xE0)
							{
								eax_1450 = edx_1404 & 0x0F;
								ecx_1453 = 0x02;
								esi_1454 = 0x0300;
							}
							else if ((byte) (edx_1404 & ~0x07) == 0xF0)
							{
								eax_1450 = edx_1404 & 0x07;
								ecx_1453 = 0x03;
								esi_1454 = 0x0400;
							}
							else if ((byte) (edx_1404 & ~0x03) == ~0x07)
							{
								eax_1450 = edx_1404 & 0x03;
								ecx_1453 = 0x04;
								esi_1454 = 0x0500;
							}
							else
							{
								eax_1450 = edx_1404 & 0x01;
								ecx_1453 = 0x05;
								esi_1454 = 0x0600;
							}
							**((word32) esp_1278 + 20) = (word32) edi_1005 + 1;
							Eq_57792 edx_1479 = (word32) edi_1005 + 1;
							if (*esp_1278 > (word32) edi_1005 + 1)
							{
								do
								{
									edx_1479 = (word32) edx_1479 + 1;
									eax_1450 = eax_1450 << 0x06 | (word32) (*edx_1479) & 0x3F;
									**((word32) esp_1278 + 20) = edx_1479;
								} while (edx_1479 != *esp_1278);
								edi_1005 -= edx_1479;
								ecx_1453 = (word32) edi_1005 + (ecx_1453 + 0x01);
							}
							ebp_1401->dw0000 = esi_1454 | *((word32) esp_1278 + 4);
							ebp_1401->dw0004 = eax_1450 << (byte) (ecx_1453 * 0x06);
						}
						goto l0806AAB8;
					}
					struct Eq_61453 * esp_913 = esp_1278 - 0x0C;
					esp_913->t006C = **((word64) esp_1278.u0 + 0x0C);
					esp_913->tFFFFFFFC = esp_913->t0038;
					word32 edx_2818;
					word32 ecx_2817;
					_dl_mcount_wrapper_check(gs, esp_913->tFFFFFFF8, esp_913->tFFFFFFFC, out ecx_2817, out edx_2818);
					esp_913->tFFFFFFF8 = esp_913->t00B8;
					esp_913->dwFFFFFFF4 = 0x00;
					esp_913->dwFFFFFFF0 = esp_913->dw0030;
					esp_913->dwFFFFFFEC = 0x00;
					esp_913->tFFFFFFE8 = edi_1005;
					esp_913->ptrFFFFFFE4 = (word32 *) &esp_913->t006C;
					esp_913->dwFFFFFFE0 = esp_913->dw0040;
					esp_913->dwFFFFFFDC = esp_913->dw003C;
					Eq_57792 eax_982;
					word32 edx_983;
					Eq_57792 ecx_984;
					fn00000000();
					ebp_1014 = eax_982;
					esp_1278 = &esp_913->t000C;
					if (eax_982 == 0x04)
					{
						if (esp_913->t001C == 0x05)
							goto l0806AA79;
						goto l0806AB0B;
					}
					Eq_57792 esi_1249 = esp_913->t006C;
					if (esi_1249 == edi_1005)
					{
l0806AA71:
						if (ebp_1014 == 0x00)
						{
l0806AA79:
							struct Eq_61555 * esi_1525 = esp_913->ptr0018;
							esp_913->t0024 = *esp_913->ptr0020;
							eax_1528 = esi_1525->t0008;
							esp_913->t0014 = esi_1525->t0000;
							goto l0806A8D0;
						}
						esp_913->t001C = ebp_1014;
						goto l0806AB0B;
					}
					Eq_57792 edx_1017 = esp_913->t0024;
					*esp_913->ptr0020 = (union Eq_57792 *) edx_1017;
					Eq_57792 eax_999 = esp_913->ptr0018->t0008;
					if (esp_913->t000C != edx_1017)
					{
						ebx_1003 = esp_913->t0014;
						edi_1005 = (word32) ebx_1003 + 4;
						if (esi_1249 >= (word32) ebx_1003 + 4)
						{
							esp_913->t0028 = eax_982;
							esp_913->t0034 = eax_999 & 0x02;
							ebp_1014 = esi_1249;
							Eq_57792 esi_1015 = ebx_1003;
							do
							{
								Eq_57792 eax_1019 = (word32) *edx_1017;
								ecx_1020 = (word32) edx_1017 + 1;
								ebx_1003 = eax_1019;
								if (eax_1019 > 0x7F)
								{
									if (eax_1019 <= 223)
									{
										esp_913->t0024.u0 = 0x02;
										eax_1019 &= 0x1F;
										goto l0806ADE2;
									}
									if ((byte) (eax_1019 & ~0x0F) == 0xE0)
									{
										esp_913->t0024.u0 = 0x03;
										eax_1019 &= 0x0F;
										goto l0806ADE2;
									}
									if ((byte) (eax_1019 & ~0x07) == 0xF0)
									{
										esp_913->t0024.u0 = 0x04;
										eax_1019 &= 0x07;
										goto l0806ADE2;
									}
									if ((byte) (eax_1019 & ~0x03) == ~0x07)
									{
										esp_913->t0024.u0 = 0x05;
										eax_1019 &= 0x03;
										goto l0806ADE2;
									}
									if ((byte) (eax_1019 & ~0x01) != 252)
									{
										ebx_1003.u0 = 0x00;
										do
											ebx_1003 = (char *) ebx_1003.u0 + 1;
										while (Mem1018[esp_913 + 0x0C:word32] >u edx_1017 + ebx_1003 && (SLICE(CONVERT(Mem1018[edx_1017 + ebx_1003:byte], byte, word32) & ~0x3F, byte, 0) == 0x80 && ebx_1003 != 0x05));
l0806AFA8:
										esp_913->t001C = ebx_1003;
l0806AE74:
										word32 * eax_1191 = esp_913->ptr004C;
										if (eax_1191 == null)
											goto l0806AE88;
										ecx_1020 = esp_913->t0034;
										if (ecx_1020 == 0x00)
											goto l0806AE88;
										edx_1017 += Mem1189[esp_913 + 0x1C:word32];
										++*eax_1191;
										goto l0806ADA6;
									}
									esp_913->t0024.u0 = 0x06;
									eax_1019 &= 0x01;
l0806ADE2:
									Eq_57792 ebx_1093 = esp_913->t0024;
									esp_913->t001C.u0 = 0x01;
									ebx_1003 = ebx_1093 + edx_1017;
									esp_913->t0044 = ebx_1003;
									if (esp_913->t000C >= ebx_1003)
									{
										esp_913->t001C = ebp_1014;
										Eq_57792 ebp_1140 = esp_913->t0024;
										esp_913->t0048 = edi_1005;
										ebx_1003.u0 = 0x01;
										do
										{
											ecx_1020 = CONVERT(Mem1144[edx_1017 + ebx_1003:byte], byte, word32);
											if ((byte) (ecx_1020 & ~0x3F) != 0x80)
											{
												ebp_1014 = esp_913->t001C;
												goto l0806AFA8;
											}
											ebx_1003 = (char *) ebx_1003.u0 + 1;
											eax_1019 = eax_1019 << 0x06 | ecx_1020 & 0x3F;
										} while (ebp_1140 != ebx_1003);
										ebp_1014 = esp_913->t001C;
										edi_1005 = esp_913->t0048;
										esp_913->t001C = ebx_1003;
										if (ebx_1003 != 0x02)
										{
											Eq_57792 ebx_1175 = esp_913->t001C;
											ecx_1020 = ebx_1175 - 0x04 + ebx_1175 * 0x04;
											ebx_1003 = eax_1019 >> (byte) ecx_1020;
											if (ebx_1003 != 0x00)
												goto l0806AE54;
											goto l0806AE74;
										}
l0806AE54:
										ecx_1020 = (word32) eax_1019 - 0x0000D800;
										if (eax_1019 <= ~0xDFFE)
											goto l0806AE74;
										ecx_1020 = esp_913->t0044;
										goto l0806ADA0;
									}
									Eq_57792 edi_1100 = esp_913->t000C;
									if (edi_1100 > ecx_1020)
									{
										Eq_57792 eax_1109;
										if ((byte) ((word32) *((word32) edx_1017 + 1) & ~0x3F) == 0x80)
										{
											Eq_57792 edi_1110 = edi_1100 - edx_1017;
											eax_1109.u0 = 0x01;
											ebx_1003 = edi_1110;
											do
											{
												eax_1109 = (char *) eax_1109.u0 + 1;
												ecx_1020 = edx_1017 + eax_1109;
												if (eax_1109 == edi_1110)
												{
													esp_913->t001C = edi_1110;
													goto l0806B11F;
												}
												word32 ecx_1122 = CONVERT(Mem1097[edx_1017 + eax_1109:byte], byte, word32);
												ecx_1020 = ecx_1122 & ~0x3F;
											} while ((byte) (ecx_1122 & ~0x3F) == 0x80);
										}
										else
											eax_1109.u0 = 0x01;
										esp_913->t001C = eax_1109;
										goto l0806AE74;
									}
l0806B11F:
									if (ecx_1020 != esp_913->t000C)
										goto l0806AE74;
l0806AE88:
									esp_913->t0024 = edx_1017;
									ebx_1003 = esi_1015;
									esi_1249 = ebp_1014;
									goto l0806AE90;
								}
l0806ADA0:
								*esi_1015 = eax_1019;
								edx_1017 = ecx_1020;
								esi_1015 = edi_1005;
l0806ADA6:
								if (esp_913->t000C == edx_1017)
									goto l0806AE88;
								edi_1005 = (word32) esi_1015 + 4;
							} while (ebp_1014 >= edi_1005);
							ebp_1014 = esp_913->t0028;
							*esp_913->ptr0020 = (union Eq_57792 *) edx_1017;
							edi_1005 = esi_1015;
							if (ebp_1014 == esi_1015)
							{
								if (ebp_1014 != esp_913->t0014)
									goto l0806AA71;
l0806AFD4:
								struct Eq_61555 * eax_1380 = esp_913->ptr0018;
								--eax_1380->dw000C;
								goto l0806AA71;
							}
						}
						else
						{
							ecx_1020 = ecx_984;
							if (esi_1249 == esp_913->t0014)
								goto l0806AFD4;
						}
l0806AEA2:
						edi_1005 = esp_913->t0050;
						esp_913->ptr0008 = (word32) edi_1005 - 166272;
						esp_913->dw0004 = 727;
						esp_913->ptr0000 = (word32) edi_1005 - 167166;
						esp_913->tFFFFFFFC = (word32) edi_1005 - 0x00028C8D;
						word32 ecx_2823;
						__assert_fail(out ecx_2823, out edx_1312);
						Eq_2 esp_1313 = <invalid>;
						esp_1278 = (word32) esp_1313 - 4;
l0806AEC5:
						if ((byte) (ebx_1003 & ~0x07) == 0xF0)
						{
							*((word32) esp_1278 + 28) = 0x04;
							eax_1363 = ebx_1003 & 0x07;
							goto l0806A944;
						}
						if ((byte) (ebx_1003 & ~0x03) == ~0x07)
						{
							*((word32) esp_1278 + 28) = 0x05;
							eax_1363 = ebx_1003 & 0x03;
							goto l0806A944;
						}
						if ((byte) (ebx_1003 & ~0x01) == 252)
						{
							*((word32) esp_1278 + 28) = 0x06;
							eax_1363 = ebx_1003 & 0x01;
							goto l0806A944;
						}
						ebx_1342.u0 = 0x00;
						do
							ebx_1342 = (word64) ebx_1342.u0 + 1;
						while (Mem1707[esp_1278 + 0x00:word32] >u edx_1312 + ebx_1342 && (SLICE(CONVERT(Mem1707[edx_1312 + ebx_1342:byte], byte, word32) & ~0x3F, byte, 0) == 0x80 && ebx_1342 != 0x05));
						goto l0806A9C2;
					}
					ebx_1003 = esp_913->t0014;
					ecx_1020 = ecx_984;
l0806AE90:
					edi_1005 = esp_913->t0024;
					*esp_913->ptr0020 = (union Eq_57792 *) edi_1005;
					if (esi_1249 != ebx_1003)
						goto l0806AEA2;
					Eq_57792 esi_1259 = esp_913->t0050;
					esp_913->ptr0008 = (word32) esi_1259 - 166272;
					esp_913->dw0004 = 0x02D8;
					esp_913->ptr0000 = (word32) esi_1259 - 167166;
					esp_913->tFFFFFFFC = (word32) esi_1259 - 166800;
					word32 edx_2822;
					word32 ecx_2821;
					__assert_fail(out ecx_2821, out edx_2822);
					Eq_2 esp_1273 = <invalid>;
					esp_1278 = (word32) esp_1273 - 4;
l0806B38F:
					esi_1281 = (word32) *((word32) esp_1278 + 0x0044);
					struct Eq_61147 * esp_1283 = esp_1278 - 4;
					esp_1283->dw0000 = esi_1281 + ~0x0002897F;
					esp_1283->dwFFFFFFFC = 0x019F;
					esp_1285 = esp_1283 - 4;
					goto l0806B349;
				}
				edx_1312 = *((word32) esp_1278 + 24);
				edi_1005 = *((word32) esp_1278 + 8);
				*((word32) esp_1278 + 16) = 0x05;
			}
			else
			{
				edx_1312 = *esp_1278;
				edi_1005 = *((word32) esp_1278 + 8);
				*((word32) esp_1278 + 16) = 0x04;
			}
l0806A9F0:
			word32 ebx_882 = *((word64) esp_1278.u0 + 32);
			**((word64) esp_1278.u0 + 20) = edx_1312;
			if (ebx_882 != 0x00)
				goto l0806AAB2;
			goto l0806AA02;
		}
		edi_1005 = *((word32) esp_1278 + 0x0044);
		struct Eq_62324 * esp_287 = esp_1278 - 4;
		esp_287->ptr0000 = (word32) edi_1005 - 166712;
		esp_287->dwFFFFFFFC = 0x01C9;
		esp_287->ptrFFFFFFF8 = (word32) edi_1005 - 167069;
		esp_287->ptrFFFFFFF4 = (word32) edi_1005 - 166960;
		Eq_2 esp_299 = <invalid>;
		word32 ecx_2824;
		word32 edx_2825;
		eax_170 = __assert_fail(out ecx_2824, out edx_2825);
		esp_1278 = (word32) esp_299 - 4;
	}
	else
	{
		if (esi_240 <= 223)
		{
			ebx_1546 = esi_240 & 0x1F;
			goto l0806B00D;
		}
		if ((byte) (esi_240 & ~0x0F) == 0xE0)
		{
			ebx_1546 = esi_240 & 0x0F;
			goto l0806B00D;
		}
	}
	if ((byte) (ecx_1543 & ~0x07) == 0xF0)
	{
		*((word32) esp_1278 + 72) = 0x04;
		ebx_1546 = ecx_1543 & 0x07;
	}
	else if ((byte) (ecx_1543 & ~0x03) == ~0x07)
	{
		*((word32) esp_1278 + 72) = 0x05;
		ebx_1546 = ecx_1543 & 0x03;
	}
	else
	{
		if ((byte) (ecx_1543 & ~0x01) != 252)
		{
			esi_1542.u0 = 0x00;
			do
				++esi_1542;
			while (Mem1545[esp_1278 + 0x3C:word32] >u ebp_210 + esi_1542 && (SLICE(CONVERT(Mem1545[ebp_210 + esi_1542:byte], byte, word32) & ~0x3F, byte, 0) == 0x80 && esi_1542 != 0x05));
l0806B0A3:
			dwLoc20_1725 = edi_33;
			ebp_210 = *((word32) esp_1278 + 64);
			if (ebp_210 == 0x00)
			{
l0806B0B4:
				*((word32) esp_1278 + 16) = (union Eq_2 *) 0x06;
				goto l0806AAB8;
			}
			edi_1005 &= 0x02;
			if (edi_1005 == 0x00)
				goto l0806B0B4;
			word32 * eax_612 = *((word32) esp_1278 + 64);
			++*eax_612;
			*((word32) esp_1278 + 40) = *((word32) esp_1278 + 8);
			goto l0806ACA4;
		}
		*((word32) esp_1278 + 72) = 0x06;
		ebx_1546 = ecx_1543 & 0x01;
	}
l0806B00D:
	dwLoc20_1725 = edi_33;
	esi_1542.u0 = 0x01;
	if (Mem357[esp_1278 + 0x3C:word32] >=u ebp_210 + Mem357[esp_1278 + 0x48:word32])
	{
		Eq_62309 edx_551 = *((word32) esp_1278 + 72);
		do
		{
			word32 eax_555 = CONVERT(Mem357[ebp_210 + esi_1542:byte], byte, word32);
			ecx_1543 = eax_555 & ~0x3F;
			if ((byte) (eax_555 & ~0x3F) != 0x80)
				goto l0806B0A3;
			++esi_1542.u0;
			ebx_1546 = ebx_1546 << 0x06 | eax_555 & 0x3F;
		} while (edx_551 != esi_1542);
		if (*((word32) esp_1278 + 72) != 0x02)
		{
			Eq_62309 edx_585 = *((word32) esp_1278 + 72);
			ecx_1543 = edx_585 - 0x04 + edx_585 * 0x04;
			if (ebx_1546 >> (byte) ecx_1543 != 0x00 && ebx_1546 > ~0xDFFE)
			{
				**((word32) esp_1278 + 8) = ebx_1546;
				Eq_2 eax_624 = **((word32) esp_1278 + 16);
				*((word32) esp_1278 + 8) = eax_624;
				*((word32) esp_1278 + 28) = eax_624 & 0x07;
				esi_1542 = edx_585;
				goto l0806ACA4;
			}
			goto l0806B0A3;
		}
		if (ebx_1546 <= ~0xDFFE)
			goto l0806B0A3;
		**((word32) esp_1278 + 8) = ebx_1546;
		Eq_2 eax_579 = **((word32) esp_1278 + 16);
		*((word32) esp_1278 + 8) = eax_579;
		*((word32) esp_1278 + 28) = eax_579 & 0x07;
		esi_1542.u0 = 0x02;
		goto l0806ACA4;
	}
	ui32 edx_477;
	ui32 esi_480;
	ui32 ebx_481;
	ptr32 ebx_366 = (word32) esp_1278 + 0x0067;
	*((word32) esp_1278 + 40) = ebx_366;
	if (*((word32) esp_1278 + 60) > ebx_366)
	{
		if ((byte) ((word32) *((word32) esp_1278 + 0x0067) & ~0x3F) == 0x80)
		{
			byte * ebx_376 = (word32) esp_1278 + 0x0068;
			do
			{
				++esi_1542;
				if (*((word32) esp_1278 + 60) <= ebx_2830)
				{
					if (*((word32) esp_1278 + 60) != ebx_2830)
						break;
					if (*((word32) esp_1278 + 60) != (word32) esp_1278 + 0x006C)
						goto l0806B1F4;
					goto l0806B2CC;
				}
				ebx_376 = ebx_2830 + 1;
				ebx_2830 = ebx_376;
			} while ((byte) ((word32) *ebx_2830 & ~0x3F) == 0x80);
		}
		goto l0806B0A3;
	}
	if (*((word32) esp_1278 + 60) != ebx_366)
		goto l0806B0A3;
l0806B1F4:
	union Eq_2 * edi_405 = *((word32) esp_1278 + 16);
	Mem406[Mem367[esp_1278 + 0x14:word32] + 0x00:word32] = eax_170 - Mem367[esp_1278 + 0x1C:word32] + Mem367[esp_1278 + 0x18:word32];
	up32 edx_407 = *((word32) esp_1278 + 56);
	*edi_405 = (union Eq_2 *) eax_170;
	if (edx_407 > 0xC1)
	{
		if (*((word32) esp_1278 + 76) <= 0x1D)
		{
			esi_480 = 0x0200;
			ebx_481 = 0x01;
			edx_477 = ecx_1543 & 0x1F;
			goto l0806B233;
		}
		if ((byte) (ecx_1543 & ~0x0F) == 0xE0)
		{
			esi_480 = 0x0300;
			ebx_481 = 0x02;
			edx_477 = ecx_1543 & 0x0F;
			goto l0806B233;
		}
	}
	else
	{
		word32 edi_412 = *((word32) esp_1278 + 0x0044);
		struct Eq_62708 * esp_414 = esp_1278 - 4;
		esp_414->dw0000 = edi_412 + 4294800584;
		esp_414->dwFFFFFFFC = 0x01E1;
		esp_414->dwFFFFFFF8 = edi_412 + ~0x00028C9C;
		esp_414->dwFFFFFFF4 = edi_412 + 4294800260;
		word32 ecx_2828;
		word32 edx_2829;
		__assert_fail(out ecx_2828, out edx_2829);
		Eq_2 esp_426 = <invalid>;
		esp_1278 = (word32) esp_426 - 4;
l0806B2CC:
		word32 esi_434 = *((word32) esp_1278 + 0x0044);
		struct Eq_62673 * esp_436 = esp_1278 - 4;
		esp_436->dw0000 = esi_434 + 4294800584;
		esp_436->dwFFFFFFFC = 0x01DB;
		esp_436->dwFFFFFFF8 = esi_434 + ~0x00028C9C;
		esp_436->dwFFFFFFF4 = esi_434 + ~0x00028C07;
		Eq_2 esp_448 = <invalid>;
		word32 edx_2827;
		word32 ecx_2826;
		eax_170 = __assert_fail(out ecx_2826, out edx_2827);
		esp_1278 = (word32) esp_448 - 4;
	}
	if ((byte) (ecx_1543 & ~0x07) == 0xF0)
	{
		esi_480 = 0x0400;
		ebx_481 = 0x03;
		edx_477 = ecx_1543 & 0x07;
	}
	else if ((byte) (ecx_1543 & ~0x03) == ~0x07)
	{
		edx_477 = ecx_1543 & 0x03;
		esi_480 = 0x0500;
		ebx_481 = 0x04;
	}
	else
	{
		edx_477 = ecx_1543 & 0x01;
		esi_480 = 0x0600;
		ebx_481 = 0x05;
	}
l0806B233:
	edi_1005 = *((word32) esp_1278 + 40);
	if (*((word32) esp_1278 + 60) > edi_1005)
	{
		do
		{
			edi_1005 = (word32) edi_1005 + 1;
			edx_477 = edx_477 << 0x06 | (word32) (*edi_1005) & 0x3F;
		} while (*((word32) esp_1278 + 60) != edi_1005);
		ebx_481 += *((word32) esp_1278 + 40) - *((word32) esp_1278 + 60);
	}
	struct Eq_62753 * esi_541 = *((word32) esp_1278 + 16);
	*((word32) esp_1278 + 16) = (union Eq_2 *) 0x07;
	esi_541->t0000 = eax_170 | esi_480;
	esi_541->dw0004 = edx_477 << (byte) (ebx_481 * 0x06);
	goto l0806AAB8;
}

// 0806B590: void __gconv_transform_ucs2_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_58641) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs2_internal(struct Eq_9 * gs, struct Eq_58641 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	struct Eq_62837 * esp_18 = fp - 0x6C;
	ui32 esi_32 = gs->dw0014;
	ui32 esi_319 = *((word32) dwArg08 + 8);
	Eq_2 dwLoc50_751 = 0x00;
	if ((esi_319 & 0x01) == 0x00)
	{
		Eq_2 ecx_43 = dwArg04->t0050;
		dwLoc50_751 = ecx_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc50_751 = __ror(ecx_43, 0x09) ^ gs->t0018;
	}
	Eq_2 edi_436;
	ptr32 esp_166;
	Eq_2 edi_162;
	struct Eq_62857 * esp_332;
	Eq_2 eax_507;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == 0x00)
		{
			struct Eq_62919 * eax_67 = *((word32) dwArg08 + 20);
			eax_67->dw0000 = 0x00;
			eax_67->t0004.u1 = 0x00;
			if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
			{
				word32 edx_1483;
				word32 ecx_1482;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc50_751, out ecx_1482, out edx_1483);
				word32 edx_112;
				fn00000000();
			}
			goto l0806B73E;
		}
		goto l0806BB16;
	}
	Eq_2 edx_118 = *dwArg0C;
	Eq_2 eax_119 = dwArg14;
	if (dwArg14 == 0x00)
		eax_119 = dwArg08;
	word32 * ecx_126 = *eax_119;
	word32 * dwLoc68_1013 = ecx_126;
	word32 * ecx_132 = *((word32) dwArg08 + 4);
	word32 * ebx_136 = null;
	if (dwArg18 != null)
		ebx_136 = fp - 44;
	if (dwArg20 != 0x00)
	{
		struct Eq_62919 * ebx_150 = *((word32) dwArg08 + 20);
		ui32 dwLoc64_1481 = ebx_150->dw0000;
		byte bLoc64_803 = (byte) dwLoc64_1481;
		uint32 dwLoc58_789 = dwLoc64_1481 & 0x07;
		if ((dwLoc64_1481 & 0x07) != 0x00)
		{
			if (dwArg14 != 0x00)
			{
				edi_162.u0 = 0x080CE000;
				esp_166 = fp - 116;
l0806BB26:
				struct Eq_63399 * esp_582 = esp_166 - 4;
				esp_582->ptr0000 = (ptr32) ((word64) edi_162.u0 - 167166);
				esp_582->ptrFFFFFFFC = (ptr32) ((word64) edi_162.u0 - 167146);
				word32 ecx_1494;
				word32 edx_1495;
				__assert_fail(out ecx_1494, out edx_1495);
				Eq_2 esp_589 = <invalid>;
				esp_18 = (word32) esp_589 - 4;
				goto l0806BB39;
			}
			Eq_63236 dwLoc4C_797 = dwLoc64_1481 & 0x07;
			if ((dwLoc64_1481 & 0x07) > 0x04)
			{
				word32 edx_1491;
				word32 ecx_1490;
				__assert_fail(out ecx_1490, out edx_1491);
l0806BB9A:
				word32 edx_1485;
				word32 ecx_1484;
				__stack_chk_fail(out ecx_1484, out edx_1485);
				__gconv_transform_internal_ucs2(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
				return;
			}
			Eq_2 ecx_194 = (word32) edx_118 + 2;
			if ((dwLoc64_1481 & 0x07) != 0x00)
			{
				Eq_62927 al_199 = ebx_150->t0004;
				if ((bLoc64_803 & 0x06) != 0x00)
				{
					dwLoc4C_797.u0 = 0x02;
					ecx_194 = edx_118;
					wLoc22 = SEQ(ebx_150->b0005, al_199);
				}
				else
				{
					ecx_194 = (word32) edx_118 + 1;
					dwLoc4C_797.u0 = 0x01;
				}
			}
			if (dwArg10 < ecx_194)
			{
				*dwArg0C = (union Eq_2 *) dwArg10;
				if (edx_118 < dwArg10)
				{
					word32 eax_226 = ebx_150 + 0x04 + dwLoc4C_797;
					do
					{
						edx_118 = (word32) edx_118 + 1;
						++eax_226;
						eax_226->bFFFFFFFF = (byte) *((word32) edx_118 - 1);
					} while (dwArg10 != edx_118);
				}
l0806B73E:
				if ((esi_32 ^ gs->dw0014) == 0x00)
					return;
				goto l0806BB9A;
			}
			Eq_2 ecx_245 = edx_118;
			if (ecx_132 < ecx_126 + 1)
				goto l0806B73E;
			Eq_63236 eax_250 = dwLoc4C_797;
			do
			{
				ecx_245 = (word32) ecx_245 + 1;
				*((word32) eax_1496 + (fp - 0x22)) = *((word32) ecx_245 - 1);
				eax_250.u0 = 0x01;
				eax_1496 = eax_250;
			} while (((int8) (eax_1496 <= 0x00) & (int8) (dwArg10 > ecx_245)) != 0x00);
			word32 eax_272 = (word32) wLoc22;
			if ((word16) (eax_272 + 0x2800) > 0x07FF)
			{
				*ecx_126 = eax_272;
				dwLoc64_1481 = ebx_150->dw0000;
				dwLoc58_789 = dwLoc64_1481 & 0x07;
				dwLoc68_1013 = ecx_126 + 1;
			}
			else
			{
				if (ebx_136 == null || (esi_319 & 0x02) == 0x00)
					goto l0806B73E;
				++*ebx_136;
			}
			if (((byte) dwLoc64_1481 & 0x06) != 0x00)
			{
l0806BB39:
				edi_436 = esp_18->t0030;
				struct Eq_63320 * esp_599 = esp_18 - 4;
				esp_599->ptr0000 = (word32) edi_436 - 166740;
				esp_599->dwFFFFFFFC = 0x01C9;
				esp_599->ptrFFFFFFF8 = (word32) edi_436 - 167069;
				esp_599->ptrFFFFFFF4 = (word32) edi_436 - 166960;
				Eq_2 esp_611 = <invalid>;
				word32 edx_1493;
				word32 ecx_1492;
				eax_507 = __assert_fail(out ecx_1492, out edx_1493);
				esp_332 = (word32) esp_611 - 4;
				goto l0806BB5C;
			}
			up32 edx_314 = edx_118 - dwLoc58_789;
			esi_319 = (ui32) *((word32) dwArg08 + 8);
			*dwArg0C = (union Eq_2 *) (edx_314 + 0x02);
			ebx_150->dw0000 = dwLoc64_1481 & ~0x07;
			edx_118 = edx_314 + 0x02;
		}
	}
l0806B680:
	word32 dwLoc64_1006;
	word32 * ebx_334;
	Eq_2 eax_335;
	esp_332 = fp - 0x6C;
	if (dwArg10 == edx_118)
	{
		ebx_334 = dwLoc68_1013;
		eax_335 = dwArg10;
		dwLoc64_1006 = 0x04;
		goto l0806B76C;
	}
	eax_335 = (word32) edx_118 + 2;
	ebx_334 = dwLoc68_1013;
	if (dwArg10 < eax_335)
	{
		eax_335 = edx_118;
		dwLoc64_1006 = 0x07;
		goto l0806B76C;
	}
	word32 * ecx_343 = dwLoc68_1013 + 1;
	if (ecx_132 < dwLoc68_1013 + 1)
	{
		ebx_334 = dwLoc68_1013;
		eax_335 = edx_118;
		dwLoc64_1006 = 0x05;
		goto l0806B76C;
	}
	ui32 esi_350 = esi_319 & 0x02;
	dwLoc64_1006 = 0x04;
l0806B6B6:
	word32 edx_359 = (word32) *((word32) eax_335 - 2);
	Eq_2 edi_360 = eax_335 - 0x02;
	if ((word16) (edx_359 + 0x2800) > 0x07FF)
	{
		*ebx_334 = edx_359;
		ebx_334 = ecx_343;
		if (eax_335 != dwArg10)
			goto l0806B6D2;
	}
	else
	{
		if (ebx_136 == null || esi_350 == 0x00)
		{
			eax_335 = edi_360;
			dwLoc64_1006 = 0x06;
			goto l0806B76C;
		}
		++*ebx_136;
		dwLoc64_1006 = 0x06;
		if (eax_335 != dwArg10)
		{
l0806B6D2:
			Eq_2 edx_405 = (word32) eax_335 + 2;
			if (dwArg10 >= edx_405)
			{
				ecx_343 = ebx_334 + 1;
				if (ecx_132 >= ecx_343)
				{
					eax_335 = edx_405;
					goto l0806B6B6;
				}
				dwLoc64_1006 = 0x05;
			}
			else
				dwLoc64_1006 = 0x07;
l0806B76C:
			*dwArg0C = (union Eq_2 *) eax_335;
			if (dwArg14 == 0x00)
			{
l0806B77A:
				*((word32) dwArg08 + 0x0C) = (word32) *((word32) dwArg08 + 0x0C) + 1;
				edi_436 = dwArg08;
				if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
				{
					if (ebx_334 > dwLoc68_1013)
					{
						word32 * eax_454 = *dwArg08;
						word32 edx_1489;
						word32 ecx_1488;
						_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc50_751, out ecx_1488, out edx_1489);
						word32 edx_509;
						fn00000000();
						dwLoc80 = dwArg20;
						esp_332 = fp - 0x6C;
						if (eax_507 != 0x04)
						{
							if (eax_454 != ebx_334)
							{
								Eq_63188 ebx_519 = ebx_334 - eax_454;
								Mem526[dwArg0C + 0x00:word32] = Mem495[dwArg0C + 0x00:word32] - (ebx_519 + (ebx_519 >>u 0x1F) >> 0x01);
							}
							if (eax_507 == 0x00)
							{
l0806B7E0:
								esi_319 = (ui32) *((word32) dwArg08 + 8);
								edx_118 = *dwArg0C;
								dwLoc68_1013 = (word32 *) *dwArg08;
								goto l0806B680;
							}
l0806BB5C:
							esp_332->t0008 = eax_507;
						}
						else if (dwLoc64_1006 == 0x05)
							goto l0806B7E0;
					}
				}
				else
				{
					*dwArg08 = ebx_334;
					*dwArg18 = *dwArg18;
				}
				if (esp_332->dw008C == 0x00 || esp_332->t0008 != 0x07)
					goto l0806B73E;
				Eq_2 esi_544 = *esp_332->ptr000C;
				if (dwArg10 - esi_544 <= 0x03)
				{
					struct Eq_63081 * eax_626;
					struct Eq_62919 * ebx_620 = *((word32) edi_436 + 20);
					word32 eax_621 = esi_544 + 0x01;
					union Eq_2 * edi_622 = esp_332->ptr000C;
					struct Eq_63093 * edx_623 = &ebx_620->t0004;
					if (esi_544 < dwArg10)
					{
						while (true)
						{
							*edi_622 = (union Eq_2 *) eax_621;
							++edx_623;
							edx_623->bFFFFFFFF = (byte) *((word32) eax_621 - 1);
							word32 ecx_637 = eax_621 + 0x01;
							if (eax_621 == dwArg10)
								break;
							eax_621 = ecx_637;
						}
						eax_626 = eax_621 - esi_544;
					}
					else
						eax_626 = null;
					ebx_620->dw0000 = eax_626 | ebx_620->dw0000 & ~0x07;
					goto l0806B73E;
				}
				word32 edi_551 = esp_332->dw0030;
				struct Eq_63050 * esp_553 = esp_332 - 4;
				esp_553->dw0000 = edi_551 + ~0x0002899F;
				esp_553->dwFFFFFFFC = 777;
				esp_553->dwFFFFFFF8 = edi_551 + ~0x00028CFD;
				esp_553->dwFFFFFFF4 = edi_551 + ~0x00028CD5;
				word32 ecx_1486;
				word32 edx_1487;
				__assert_fail(out ecx_1486, out edx_1487);
				Eq_2 esp_565 = <invalid>;
				esp_18 = (word32) esp_565 - 4;
l0806BB16:
				edi_162 = esp_18->t0030;
				struct Eq_62905 * esp_575 = esp_18 - 4;
				esp_575->dw0000 = (word32) edi_162 - 166304;
				esp_575->dwFFFFFFFC = 0x019F;
				esp_166 = esp_575 - 4;
				goto l0806BB26;
			}
l0806B738:
			*dwArg14 = ebx_334;
			goto l0806B73E;
		}
	}
	*dwArg0C = (union Eq_2 *) eax_335;
	if (dwArg14 == 0x00)
		goto l0806B77A;
	goto l0806B738;
}

// 0806BBA0: void __gconv_transform_internal_ucs2(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_58641) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
// Called from:
//      __gconv_transform_ucs2_internal
void __gconv_transform_internal_ucs2(struct Eq_9 * gs, struct Eq_58641 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	struct Eq_63421 * esp_18 = fp - (struct Eq_63423 *) 0x8C;
	Eq_2 edi_26 = dwArg08;
	Eq_2 ebp_1026 = dwArg10;
	ui32 esi_34 = gs->dw0014;
	Eq_63430 esi_350 = *((word32) dwArg08 + 8);
	Eq_2 dwLoc60_1070 = 0x00;
	if ((esi_350 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc60_1070 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_1070 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	struct Eq_63440 * esp_332;
	struct Eq_63441 * esp_780;
	ptr32 esp_397;
	word32 ebx_393;
	Eq_2 esp_490;
	if (dwArg1C == 0x00)
	{
		Eq_2 edx_121 = dwArg14;
		Eq_2 eax_122 = *dwArg0C;
		if (dwArg14 == 0x00)
			edx_121 = dwArg08;
		word16 * ecx_127 = *edx_121;
		word16 * edx_129 = *((word32) dwArg08 + 4);
		word16 * dwLoc78_1104 = ecx_127;
		word32 * edx_138 = null;
		if (dwArg18 != null)
			edx_138 = fp - 0x30;
		if (dwArg20 == 0x00)
		{
l0806BCA0:
			while (true)
			{
				word16 * ebx_516 = dwLoc78_1104;
				ui32 esi_518 = esi_350 & 0x02;
				Eq_2 dwLoc2C_1236 = eax_122;
				word32 dwLoc7C_1237 = 0x04;
				word16 * dwLoc28_1238 = dwLoc78_1104;
l0806BCBF:
				if (ebp_1026 != eax_122)
				{
					do
					{
						Eq_2 edx_533 = (word32) eax_122 + 4;
						if (ebp_1026 < edx_533)
						{
							dwLoc7C_1237 = 0x07;
							goto l0806BD54;
						}
						word16 * esi_541 = ebx_516 + 1;
						if (edx_129 < esi_541)
						{
							dwLoc7C_1237 = 0x05;
							goto l0806BD54;
						}
						uint32 ecx_547 = *eax_122;
						word16 cx_652 = (word16) ecx_547;
						if (ecx_547 > 0xFFFF)
						{
							if (ecx_547 >> 0x07 == 0x1C00)
							{
								dwLoc2C_1236 = edx_533;
								eax_122 = edx_533;
								goto l0806BCBF;
							}
							if (edx_138 != null)
							{
								if ((*((word32) edi_26 + 8) & 0x08) != 0x00)
								{
									word32 esi_1904;
									word32 ebx_1903;
									word32 edi_1905;
									word32 eax_587 = __gconv_transliterate(gs, dwArg04, edi_26, fp - 44, ebp_1026, fp - 0x28, edx_138, out ebx_1903, out ebp_1026, out esi_1904, out edi_1905);
									dwLocA0 = fp - 44;
									dwLoc7C_1237 = eax_587;
									ebx_516 = dwLoc28_1238;
									eax_122 = dwLoc2C_1236;
									if (eax_587 != 0x06)
									{
										if (eax_587 == 0x05)
											break;
										goto l0806BCBF;
									}
								}
								if (esi_518 != 0x00)
								{
									++*edx_138;
									eax_122 = (word32) eax_122 + 4;
									dwLoc7C_1237 = 0x06;
									dwLoc2C_1236 = eax_122;
									goto l0806BCBF;
								}
							}
							goto l0806BE31;
						}
						if (ecx_547 <= ~0xDFFE)
						{
							if (edx_138 != null && esi_518 != 0x00)
							{
								++*edx_138;
								dwLoc2C_1236 = edx_533;
								eax_122 = edx_533;
								dwLoc7C_1237 = 0x06;
								goto l0806BCBF;
							}
l0806BE31:
							dwLoc7C_1237 = 0x06;
l0806BD54:
							*dwArg0C = (union Eq_2 *) eax_122;
							if (dwArg14 == 0x00)
								goto l0806BD62;
							goto l0806BD20;
						}
						*ebx_516 = cx_652;
						eax_122 = edx_533;
						ebx_516 = esi_541;
						dwLoc28_1238 = esi_541;
						dwLoc2C_1236 = edx_533;
					} while (ebp_1026 != edx_533);
				}
				*dwArg0C = (union Eq_2 *) eax_122;
				if (dwArg14 != 0x00)
					break;
l0806BD62:
				*((word32) edi_26 + 0x0C) = (word32) *((word32) edi_26 + 0x0C) + 1;
				if ((*((word32) edi_26 + 8) & 0x01) != 0x00)
				{
					*edi_26 = ebx_516;
					*dwArg18 = *dwArg18;
					goto l0806C00C;
				}
				word32 eax_694;
				if (ebx_516 > dwLoc78_1104)
				{
					word16 * eax_695 = *edi_26;
					word32 ecx_1901;
					word32 edx_1902;
					_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1070, out ecx_1901, out edx_1902);
					fn00000000();
					dwLocA0 = dwArg20;
					if (eax_694 != 0x04)
					{
						if (ebx_516 != eax_695)
							*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_516 - eax_695) * 0x02);
						goto l0806BDC7;
					}
					eax_694 = dwLoc7C_1237;
					if (dwLoc7C_1237 != 0x05 && dwLoc7C_1237 != 0x00)
						goto l0806BE85;
					goto l0806BDCF;
				}
				eax_694 = dwLoc7C_1237;
l0806BDC7:
				if (eax_694 != 0x00)
				{
l0806BE85:
					dwLoc7C_1237 = eax_694;
l0806C00C:
					esp_780 = fp - (struct Eq_63423 *) 0x8C;
					if (dwLoc7C_1237 != 0x07 || dwArg20 == 0x00)
						goto l0806BD26;
					Eq_2 esi_789 = *dwArg0C;
					if (ebp_1026 - esi_789 > 0x03)
						goto l0806C396;
					struct Eq_63797 * eax_806;
					ui32 * ebx_800 = *((word32) edi_26 + 20);
					word32 eax_801 = esi_789 + 0x01;
					struct Eq_63805 * edx_803 = ebx_800 + 1;
					if (esi_789 < ebp_1026)
					{
						while (true)
						{
							*dwArg0C = (union Eq_2 *) eax_801;
							++edx_803;
							edx_803->bFFFFFFFF = (byte) *((word32) eax_801 - 1);
							word32 ecx_817 = eax_801 + 0x01;
							if (eax_801 == ebp_1026)
								break;
							eax_801 = ecx_817;
						}
						eax_806 = eax_801 - esi_789;
					}
					else
						eax_806 = null;
					*ebx_800 = eax_806 | *ebx_800 & ~0x07;
					goto l0806BD26;
				}
l0806BDCF:
				esi_350 = *((word32) edi_26 + 8);
				eax_122 = *dwArg0C;
				dwLoc78_1104 = (word16 *) *edi_26;
			}
l0806BD20:
			*dwArg14 = ebx_516;
l0806BD26:
			if ((esi_34 ^ gs->dw0014) == 0x00)
				return;
l0806C422:
			word32 ecx_1899;
			word32 edx_1900;
			__stack_chk_fail(out ecx_1899, out edx_1900);
			esp_490.u0 = <invalid>;
l0806C427:
			Eq_2 esi_884 = *((word64) esp_490.u0 + 64);
			struct Eq_63960 * esp_886 = esp_490 - 4;
			esp_886->dw0000 = (word32) esi_884 - 166768;
			esp_886->dwFFFFFFFC = 0x01C9;
			esp_886->dwFFFFFFF8 = (word32) esi_884 - 167069;
			esp_886->dwFFFFFFF4 = (word32) esi_884 - 166960;
			word32 edx_1911;
			word32 ecx_1910;
			__assert_fail(out ecx_1910, out edx_1911);
			Eq_2 esp_898 = <invalid>;
			esp_18 = (word32) esp_898 - 4;
l0806C44A:
			ebx_393 = esp_18->dw0040;
			struct Eq_63842 * esp_908 = esp_18 - 4;
			esp_908->dw0000 = ebx_393 + ~0x000289BF;
			esp_908->dwFFFFFFFC = 0x022F;
			esp_397 = esp_908 - 4;
l0806C383:
			struct Eq_63607 * esp_915 = esp_397 - 4;
			esp_915->dw0000 = ebx_393 + ~0x00028CFD;
			esp_915->dwFFFFFFFC = ebx_393 + ~0x00028CE9;
			word32 edx_1898;
			word32 ecx_1897;
			__assert_fail(out ecx_1897, out edx_1898);
			Eq_2 esp_922 = <invalid>;
			esp_780 = (word32) esp_922 - 4;
l0806C396:
			word32 esi_930 = esp_780->dw0040;
			struct Eq_63766 * esp_932 = esp_780 - 4;
			esp_932->dw0000 = esi_930 + ~0x000289BF;
			esp_932->dwFFFFFFFC = 777;
			esp_932->dwFFFFFFF8 = esi_930 + ~0x00028CFD;
			esp_932->dwFFFFFFF4 = esi_930 + ~0x00028CD5;
			word32 ecx_1906;
			word32 edx_1907;
			__assert_fail(out ecx_1906, out edx_1907);
			Eq_2 esp_944 = <invalid>;
			esp_332 = (word32) esp_944 - 4;
			goto l0806C3B9;
		}
		struct Eq_63505 * edx_150 = *((word32) dwArg08 + 20);
		ui32 ecx_151 = edx_150->dw0000;
		ui32 dwLoc48_1109 = ecx_151;
		struct Eq_63547 * dwLoc7C_1110 = ecx_151 & 0x07;
		if ((ecx_151 & 0x07) == 0x00)
			goto l0806BCA0;
		if (dwArg14 != 0x00)
			goto l0806C44A;
		word16 * dwLoc28_1113 = ecx_127;
		if ((ecx_151 & 0x07) > 0x04)
			goto l0806C3FF;
		up32 edx_178;
		int32 edx_173 = 0x00;
		if ((ecx_151 & 0x07) != 0x00)
		{
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[edx_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_63902) (&edx_150->dw0004)[edx_173];
				++edx_173;
			} while ((ecx_151 & 0x07) != edx_173);
			edx_178 = 0x04 - (ecx_151 & 0x07);
		}
		else
			edx_178 = 0x04;
		if (dwArg10 < (word32) eax_122 + edx_178)
		{
			*dwArg0C = (union Eq_2 *) dwArg10;
			if (eax_122 < dwArg10)
			{
				Eq_2 eax_221 = (word32) eax_122 + 1;
				struct Eq_64227 * esi_222 = edx_150 + (ecx_151 & 0x07) / 8;
				while (true)
				{
					++esi_222;
					esi_222[3] = (struct Eq_64227) *((word32) eax_221 - 1);
					Eq_2 edx_232 = (word32) eax_221 + 1;
					if (dwArg10 == eax_221)
						break;
					eax_221 = edx_232;
				}
			}
			goto l0806C263;
		}
		Eq_2 edx_238 = eax_122;
		if (edx_129 < ecx_127 + 1)
			goto l0806BD26;
		struct Eq_63922 * ebx_247 = ecx_151 & 0x07;
		do
		{
			edx_238 = (word32) edx_238 + 1;
			ebx_247 = (struct Eq_63922 *) ((char *) &ebx_247->dw0000 + 1);
			Mem257[fp - 0x25 + ebx_247:byte] = Mem253[edx_238 + -1:byte];
		} while (ebx_247 <= (struct Eq_63922 *) 0x03 && dwArg10 > edx_238);
		struct Eq_63547 * eax_448;
		word16 dx_482 = (word16) dwLoc24;
		if (dwLoc24 <= 0xFFFF)
		{
			if (dwLoc24 > ~0xDFFE)
			{
				*ecx_127 = dx_482;
				dwLoc28_1113 = ecx_127 + 1;
l0806BF9F:
				eax_448 = (struct Eq_63547 *) 0x04;
				goto l0806BFAC;
			}
			if (edx_138 != null && (esi_350 & 0x02) != 0x00)
			{
				++*edx_138;
				ui32 eax_472 = edx_150->dw0000;
				dwLoc48_1109 = eax_472;
				dwLoc7C_1110 = eax_472 & 0x07;
				eax_448 = (struct Eq_63547 *) 0x04;
				goto l0806BFAC;
			}
l0806C2DD:
			goto l0806BD26;
		}
		if (dwLoc24 >> 0x07 == 0x1C00)
			goto l0806BF9F;
		if (edx_138 == null)
			goto l0806C2DD;
		struct Eq_63547 * eax_335;
		if ((esi_350 & 0x08) == 0x00)
		{
			if ((esi_350 & 0x02) == 0x00)
				goto l0806BD26;
			goto l0806C2A6;
		}
		word32 ebx_289 = ebx_247 + (fp - 0x24);
		dwLocA0 = fp - (struct Eq_64038 *) 44;
		ui32 esi_326;
		word32 ebx_1912;
		word32 eax_320 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_64038 *) 44, ebx_289, fp - (struct Eq_64045 *) 0x28, edx_138, out ebx_1912, out ebp_1026, out esi_326, out edi_26);
		esp_332 = fp - (struct Eq_64052 *) 0x8C;
		Eq_2 ecx_334 = fp - (struct Eq_64035 *) 0x24;
		eax_335 = fp - (struct Eq_64035 *) 0x24;
		if (eax_320 == 0x06)
		{
			if ((esi_326 & 0x02) == 0x00)
			{
l0806C2B4:
				if (eax_335 == fp - (struct Eq_64035 *) 0x24)
					goto l0806C2DD;
l0806C2B8:
				ui32 ebx_449 = edx_150->dw0000;
				eax_448 = eax_335 - (fp - (struct Eq_64035 *) 0x24);
				dwLoc48_1109 = ebx_449;
				dwLoc7C_1110 = ebx_449 & 0x07;
l0806BFAC:
				esp_490 = fp - (struct Eq_63423 *) 0x8C;
				if (dwLoc7C_1110 >= eax_448)
					goto l0806C427;
				eax_122 = (char *) *dwArg0C + (eax_448 - dwLoc7C_1110);
				*dwArg0C = (union Eq_2 *) eax_122;
				edx_150->dw0000 = dwLoc48_1109 & ~0x07;
				dwLoc78_1104 = dwLoc28_1113;
				esi_350 = *((word32) edi_26 + 8);
				goto l0806BCA0;
			}
l0806C2A6:
			++*edx_138;
			eax_335 = fp - (struct Eq_64071 *) 0x20;
			goto l0806C2B4;
		}
		if (fp - (struct Eq_64035 *) 0x24 != fp - (struct Eq_64035 *) 0x24)
			goto l0806C2B8;
		if (eax_320 != 0x07)
		{
			if (eax_320 != 0x00)
				goto l0806BD26;
			esi_350 = *((word32) edi_26 + 8);
			eax_122 = *dwArg0C;
			goto l0806BCA0;
		}
		if (ebx_289 == fp - (struct Eq_64094 *) 0x20)
			goto l0806C3DC;
		ui32 eax_357 = edx_150->dw0000;
		Mem366[dwArg0C + 0x00:word32] = Mem331[dwArg0C + 0x00:word32] + (ebx_247 - (eax_357 & 0x07));
		if (ebx_247 <= (eax_357 & ~0x07))
		{
l0806C3B9:
			Eq_2 esi_952 = esp_332[64];
			struct Eq_64153 * esp_954 = esp_332 - (struct Eq_64154 *) 4;
			esp_954->dw0000 = (word32) esi_952 - 166768;
			esp_954->tFFFFFFFC.u0 = 0x01E5;
			esp_954->tFFFFFFF8 = (word32) esi_952 - 167069;
			esp_954->tFFFFFFF4 = (word32) esi_952 - 166884;
			word32 ecx_1915;
			word32 edx_1916;
			__assert_fail(out ecx_1915, out edx_1916);
			Eq_2 esp_966 = <invalid>;
			esp_332 = (word32) esp_966 - 4;
l0806C3DC:
			Eq_2 ebx_974 = esp_332[64];
			struct Eq_64101 * esp_976 = esp_332 - (struct Eq_64102 *) 4;
			esp_976->dw0000 = (word32) ebx_974 - 166768;
			esp_976->tFFFFFFFC.u0 = 0x01DB;
			esp_976->tFFFFFFF8 = (word32) ebx_974 - 167069;
			esp_976->tFFFFFFF4 = (word32) ebx_974 - 0x00028C08;
			word32 ecx_1913;
			word32 edx_1914;
			__assert_fail(out ecx_1913, out edx_1914);
			Eq_2 esp_988 = <invalid>;
			esp_18 = (word32) esp_988 - 4;
l0806C3FF:
			word32 esi_996 = esp_18->dw0040;
			struct Eq_63864 * esp_998 = esp_18 - 4;
			esp_998->dw0000 = esi_996 + ~0x00028B6F;
			esp_998->dwFFFFFFFC = 0x018B;
			esp_998->dwFFFFFFF8 = esi_996 + ~0x00028C9C;
			esp_998->dwFFFFFFF4 = esi_996 + 4294800288;
			word32 edx_1909;
			word32 ecx_1908;
			__assert_fail(out ecx_1908, out edx_1909);
			goto l0806C422;
		}
		if (ebx_247 <= (struct Eq_63922 *) 0x04)
		{
			edx_150->dw0000 = ebx_247 | eax_357 & ~0x07;
			if (ebx_289 > fp - (struct Eq_64035 *) 0x24)
			{
				struct Eq_64202 * ebp_407 = &edx_150->dw0004;
				do
				{
					++ecx_334;
					++ebp_407;
					ebp_407->bFFFFFFFF = (byte) *((word32) ecx_334 - 1);
				} while (ebx_289 != ecx_334);
			}
l0806C263:
			goto l0806BD26;
		}
		word32 edx_1918;
		word32 ecx_1917;
		__assert_fail(out ecx_1917, out edx_1918);
		Eq_2 esp_385 = <invalid>;
		esp_18 = (word32) esp_385 - 4;
	}
	else if (dwArg14 == 0x00)
	{
		struct Eq_63505 * eax_68 = *((word32) dwArg08 + 20);
		eax_68->dw0000 = 0x00;
		eax_68->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 ecx_1895;
			word32 edx_1896;
			_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1070, out ecx_1895, out edx_1896);
			fn00000000();
		}
		goto l0806BD26;
	}
	ebx_393 = esp_18->dw0040;
	struct Eq_63491 * esp_395 = esp_18 - 4;
	esp_395->dw0000 = ebx_393 + ~0x000289BF;
	esp_395->dwFFFFFFFC = 0x019F;
	esp_397 = esp_395 - 4;
	goto l0806C383;
}

// 0806C460: void __gconv_transform_ucs2reverse_internal(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_64245) dwArg04, Stack (ptr32 Eq_64246) dwArg08, Stack (ptr32 Eq_64248) dwArg0C, Stack Eq_64248 dwArg10, Stack (ptr32 Eq_64246) dwArg14, Stack (ptr32 word32) dwArg18, Stack word32 dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_ucs2reverse_internal(struct Eq_9 * gs, struct Eq_64245 * dwArg04, struct Eq_64246 * dwArg08, union Eq_64248 * dwArg0C, Eq_64248 dwArg10, struct Eq_64246 * dwArg14, word32 * dwArg18, word32 dwArg1C, Eq_2 dwArg20)
{
	Eq_2 esp_18 = fp - 0x6C;
	ui32 esi_32 = gs->dw0014;
	ui32 esi_323 = dwArg08->dw0008;
	Eq_2 dwLoc60_763 = 0x00;
	if ((esi_323 & 0x01) == 0x00)
	{
		Eq_2 ecx_43 = dwArg04->t0050;
		dwLoc60_763 = ecx_43;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_763 = __ror(ecx_43, 0x09) ^ gs->t0018;
	}
	ptr32 esp_589;
	word32 edi_585;
	if (dwArg1C != 0x00)
	{
		if (dwArg14 == null)
		{
			struct Eq_64336 * eax_67 = dwArg08->ptr0014;
			eax_67->dw0000 = 0x00;
			eax_67->t0004.u1 = 0x00;
			if ((dwArg08->dw0008 & 0x01) == 0x00)
			{
				word32 edx_1292;
				word32 ecx_1291;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc60_763, out ecx_1291, out edx_1292);
				word32 edx_111;
				fn00000000();
			}
			goto l0806C691;
		}
		goto l0806C9C5;
	}
	struct Eq_64246 * edx_120 = dwArg14;
	Eq_64248 eax_122 = *dwArg0C;
	if (dwArg14 == null)
		edx_120 = dwArg08;
	word32 * ebx_127 = edx_120->ptr0000;
	word32 * dwLoc68_1006 = ebx_127;
	word32 * ebx_133 = dwArg08->ptr0004;
	word32 * ebx_138 = null;
	if (dwArg18 != null)
		ebx_138 = fp - 44;
	struct Eq_64246 * edi_167;
	Eq_2 esi_335;
	struct Eq_64313 * esp_186;
	Eq_2 eax_179;
	if (dwArg20 != 0x00)
	{
		struct Eq_64336 * ebx_151 = dwArg08->ptr0014;
		ui32 dwLoc58_1290 = ebx_151->dw0000;
		byte bLoc58_811 = (byte) dwLoc58_1290;
		uint32 dwLoc50_799 = dwLoc58_1290 & 0x07;
		if ((dwLoc58_1290 & 0x07) != 0x00)
		{
			if (dwArg14 != null)
				goto l0806CA10;
			Eq_64686 dwLoc3C_802 = dwLoc58_1290 & 0x07;
			if ((dwLoc58_1290 & 0x07) > 0x04)
			{
				Eq_2 esp_181 = <invalid>;
				edi_167 = (struct Eq_64246 *) &g_t80CE000;
				word32 ecx_1301;
				word32 edx_1302;
				eax_179 = __assert_fail(out ecx_1301, out edx_1302);
				esp_186 = (word32) esp_181 - 4;
				goto l0806CA45;
			}
			Eq_64248 ecx_189 = (word32) eax_122 + 2;
			if ((dwLoc58_1290 & 0x07) != 0x00)
			{
				Eq_64344 dl_194 = ebx_151->t0004;
				if ((bLoc58_811 & 0x06) != 0x00)
				{
					dwLoc3C_802.u0 = 0x02;
					ecx_189 = eax_122;
					wLoc22 = SEQ(ebx_151->b0005, dl_194);
				}
				else
				{
					ecx_189 = (word32) eax_122 + 1;
					dwLoc3C_802.u0 = 0x01;
				}
			}
			if (dwArg10 < ecx_189)
			{
				*dwArg0C = (union Eq_64248 *) dwArg10;
				if (eax_122 < dwArg10)
				{
					word32 edx_221 = ebx_151 + 0x04 + dwLoc3C_802;
					do
					{
						eax_122 = (word32) eax_122 + 1;
						++edx_221;
						edx_221->bFFFFFFFF = (byte) *((word32) eax_122 - 1);
					} while (dwArg10 != eax_122);
				}
l0806C691:
				if ((esi_32 ^ gs->dw0014) == 0x00)
					return;
l0806CA0B:
				word32 ecx_1295;
				word32 edx_1296;
				__stack_chk_fail(out ecx_1295, out edx_1296);
				esp_18.u0 = <invalid>;
l0806CA10:
				edi_585 = (word32) *((word32) esp_18 + 44);
				struct Eq_64672 * esp_672 = esp_18 - 4;
				esp_672->dw0000 = edi_585 + ~0x000289FF;
				esp_672->dwFFFFFFFC = 0x022F;
				esp_589 = esp_672 - 4;
l0806C9D5:
				struct Eq_64447 * esp_679 = esp_589 - 4;
				esp_679->dw0000 = edi_585 + ~0x00028CFD;
				esp_679->dwFFFFFFFC = edi_585 + ~0x00028CE9;
				word32 edx_1294;
				word32 ecx_1293;
				__assert_fail(out ecx_1293, out edx_1294);
				Eq_2 esp_686 = <invalid>;
				esp_18 = (word32) esp_686 - 4;
				goto l0806C9E8;
			}
			Eq_64248 ecx_238 = eax_122;
			if (ebx_133 < ebx_127 + 1)
				goto l0806C691;
			Eq_64686 edx_243 = dwLoc3C_802;
			do
			{
				ecx_238 = (word32) ecx_238 + 1;
				*((word32) edx_1305 + (fp - 0x22)) = *((word32) ecx_238 - 1);
				edx_243.u0 = 0x01;
				edx_1305 = edx_243;
			} while (((int8) (edx_1305 <= 0x00) & (int8) (dwArg10 > ecx_238)) != 0x00);
			word32 edx_265 = (word32) wLoc22;
			word16 dx_270 = __rol((word16) edx_265, 0x08);
			if ((word16) (SEQ(SLICE(edx_265, word16, 16), dx_270) + 0x2800) > 0x07FF)
			{
				*ebx_127 = (word32) dx_270;
				dwLoc58_1290 = ebx_151->dw0000;
				dwLoc50_799 = dwLoc58_1290 & 0x07;
				dwLoc68_1006 = ebx_127 + 1;
			}
			else
			{
				if (ebx_138 == null || (esi_323 & 0x02) == 0x00)
					goto l0806C691;
				++*ebx_138;
			}
			if (((byte) dwLoc58_1290 & 0x06) != 0x00)
			{
l0806C9E8:
				word32 edi_694 = *((word32) esp_18 + 44);
				struct Eq_64783 * esp_696 = esp_18 - 4;
				esp_696->dw0000 = edi_694 + ~0x00028A3F;
				esp_696->dwFFFFFFFC = 0x01C9;
				esp_696->dwFFFFFFF8 = edi_694 + ~0x00028C9C;
				esp_696->dwFFFFFFF4 = edi_694 + ~0x00028C2F;
				word32 edx_1304;
				word32 ecx_1303;
				__assert_fail(out ecx_1303, out edx_1304);
				goto l0806CA0B;
			}
			up32 eax_314 = eax_122 - dwLoc50_799;
			*dwArg0C = (union Eq_64248 *) (eax_314 + 0x02);
			esi_323 = dwArg08->dw0008;
			ebx_151->dw0000 = dwLoc58_1290 & ~0x07;
			eax_122 = eax_314 + 0x02;
		}
	}
l0806C550:
	word32 * ebx_333;
	Eq_64248 edx_334;
	esp_186 = fp - 0x6C;
	if (dwArg10 == eax_122)
	{
		ebx_333 = dwLoc68_1006;
		edx_334 = dwArg10;
		esi_335.u0 = 0x04;
		goto l0806C5DF;
	}
	edx_334 = (word32) eax_122 + 2;
	ebx_333 = dwLoc68_1006;
	if (dwArg10 < edx_334)
	{
		edx_334 = eax_122;
		esi_335.u0 = 0x07;
		goto l0806C5DF;
	}
	word32 * ecx_342 = dwLoc68_1006 + 1;
	if (ebx_133 < dwLoc68_1006 + 1)
	{
		ebx_333 = dwLoc68_1006;
		edx_334 = eax_122;
		esi_335.u0 = 0x05;
		goto l0806C5DF;
	}
	ui32 esi_349 = esi_323 & 0x02;
l0806C57E:
	word32 eax_357 = (word32) *((word32) edx_334 - 2);
	word16 ax_361 = __rol((word16) eax_357, 0x08);
	Eq_64248 edi_358 = edx_334 - 0x02;
	if ((word16) (SEQ(SLICE(eax_357, word16, 16), ax_361) + 0x2800) > 0x07FF)
	{
		*ebx_333 = (word32) ax_361;
		ebx_333 = ecx_342;
		if (edx_334 != dwArg10)
			goto l0806C5A5;
	}
	else
	{
		if (ebx_138 == null || esi_349 == 0x00)
		{
			edx_334 = edi_358;
			esi_335.u0 = 0x06;
			goto l0806C5DF;
		}
		++*ebx_138;
		if (edx_334 != dwArg10)
		{
l0806C5A5:
			Eq_64248 eax_401 = (word32) edx_334 + 2;
			if (dwArg10 < eax_401)
			{
				*dwArg0C = (union Eq_64248 *) edx_334;
				esi_335.u0 = 0x07;
				if (dwArg14 == null)
					goto l0806C5F1;
				goto l0806C68B;
			}
			ecx_342 = ebx_333 + 1;
			if (ebx_133 >= ecx_342)
			{
				edx_334 = eax_401;
				goto l0806C57E;
			}
			esi_335.u0 = 0x05;
l0806C5DF:
			*dwArg0C = (union Eq_64248 *) edx_334;
			if (dwArg14 == null)
			{
l0806C5F1:
				++dwArg08->dw000C;
				edi_167 = dwArg08;
				if ((dwArg08->dw0008 & 0x01) != 0x00)
				{
					dwArg08->ptr0000 = ebx_333;
					*dwArg18 = *dwArg18;
					goto l0806C6C5;
				}
				if (ebx_333 <= dwLoc68_1006)
				{
l0806C6C5:
					if (esp_186->dw008C == 0x00 || esi_335 != 0x07)
						goto l0806C691;
					Eq_64248 ecx_554 = *esp_186->ptr0008;
					esp_186->t0000 = ecx_554;
					if (dwArg10 - ecx_554 <= 0x03)
					{
						struct Eq_64622 * eax_600;
						struct Eq_64336 * ebx_594 = edi_167->ptr0014;
						word32 eax_595 = ecx_554 + 0x01;
						union Eq_64248 * edi_596 = esp_186->ptr0008;
						union Eq_64634 * edx_597 = &ebx_594->t0004;
						if (ecx_554 < dwArg10)
						{
							while (true)
							{
								*edi_596 = (union Eq_64248 *) eax_595;
								edx_597 = (union Eq_64634 *) ((char *) edx_597 + 1);
								*((char *) edx_597 - 1) = (union Eq_64634 *) *((word32) eax_595 - 1);
								word32 ecx_611 = eax_595 + 0x01;
								if (dwArg10 == eax_595)
									break;
								eax_595 = ecx_611;
							}
							eax_600 = dwArg10 - esp_186->t0000;
						}
						else
							eax_600 = null;
						ebx_594->dw0000 = eax_600 | ebx_594->dw0000 & ~0x07;
						goto l0806C691;
					}
					word32 edi_563 = esp_186->dw002C;
					struct Eq_64591 * esp_565 = esp_186 - 4;
					esp_565->dw0000 = edi_563 + ~0x000289FF;
					esp_565->dwFFFFFFFC = 777;
					esp_565->dwFFFFFFF8 = edi_563 + ~0x00028CFD;
					esp_565->dwFFFFFFF4 = edi_563 + ~0x00028CD5;
					word32 edx_1300;
					word32 ecx_1299;
					__assert_fail(out ecx_1299, out edx_1300);
					Eq_2 esp_577 = <invalid>;
					esp_18 = (word32) esp_577 - 4;
l0806C9C5:
					edi_585 = (word32) *((word32) esp_18 + 44);
					struct Eq_64322 * esp_587 = esp_18 - 4;
					esp_587->dw0000 = edi_585 + ~0x000289FF;
					esp_587->dwFFFFFFFC = 0x019F;
					esp_589 = esp_587 - 4;
					goto l0806C9D5;
				}
				word32 * eax_457 = dwArg08->ptr0000;
				word32 ecx_1297;
				word32 edx_1298;
				_dl_mcount_wrapper_check(gs, dwLoc80, dwLoc60_763, out ecx_1297, out edx_1298);
				word32 edx_515;
				fn00000000();
				dwLoc80 = dwArg20;
				esp_186 = fp - 0x6C;
				if (eax_179 == 0x04)
				{
					if (esi_335 == 0x05)
						goto l0806C65A;
					goto l0806C6C5;
				}
				if (ebx_333 != eax_457)
				{
					Eq_64533 ebx_525 = ebx_333 - eax_457;
					Mem532[dwArg0C + 0x00:word32] = Mem498[dwArg0C + 0x00:word32] - (ebx_525 + (ebx_525 >>u 0x1F) >> 0x01);
				}
				if (eax_179 == 0x00)
				{
l0806C65A:
					esi_323 = dwArg08->dw0008;
					eax_122 = *dwArg0C;
					dwLoc68_1006 = dwArg08->ptr0000;
					goto l0806C550;
				}
l0806CA45:
				esi_335 = eax_179;
				goto l0806C6C5;
			}
l0806C68B:
			dwArg14->ptr0000 = ebx_333;
			goto l0806C691;
		}
	}
	esi_335.u0 = 0x04;
	goto l0806C5DF;
}

// 0806CA50: void __gconv_transform_internal_ucs2reverse(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_58641) dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack (ptr32 word32) dwArg1C, Stack Eq_2 dwArg20)
void __gconv_transform_internal_ucs2reverse(struct Eq_9 * gs, struct Eq_58641 * dwArg04, Eq_2 dwArg08, union Eq_2 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, word32 * dwArg1C, Eq_2 dwArg20)
{
	struct Eq_64868 * esp_1007 = fp - (struct Eq_64870 *) 0x8C;
	Eq_2 edi_26 = dwArg08;
	Eq_2 ebp_1062 = dwArg10;
	ui32 esi_33 = gs->dw0014;
	Eq_64877 esi_346 = *((word32) dwArg08 + 8);
	Eq_2 dwLoc60_1103 = 0x00;
	if ((esi_346 & 0x01) == 0x00)
	{
		Eq_2 ecx_44 = dwArg04->t0050;
		dwLoc60_1103 = ecx_44;
		if (dwArg04->dw003C != 0x00)
			dwLoc60_1103 = __ror(ecx_44, 0x09) ^ gs->t0018;
	}
	Eq_2 esp_503;
	struct Eq_64888 * esp_328;
	struct Eq_64889 * esp_408;
	if (dwArg1C == null)
	{
		Eq_2 edx_121 = dwArg14;
		Eq_2 eax_122 = *dwArg0C;
		if (dwArg14 == 0x00)
			edx_121 = dwArg08;
		word16 * ecx_127 = *edx_121;
		word16 * dwLoc7C_1136 = ecx_127;
		word16 * ecx_133 = *((word32) dwArg08 + 4);
		word32 * edx_136 = null;
		if (dwArg18 != 0x00)
			edx_136 = fp - 0x30;
		if (dwArg20 == 0x00)
		{
l0806CB50:
			while (true)
			{
				ui32 esi_531 = esi_346 & 0x02;
				Eq_2 dwLoc2C_1267 = eax_122;
				word32 dwLoc78_1268 = 0x04;
				word16 * dwLoc28_1269 = dwLoc7C_1136;
				word16 * ebx_538 = dwLoc7C_1136;
l0806CB71:
				if (ebp_1062 != eax_122)
				{
					do
					{
						Eq_2 ecx_547 = (word32) eax_122 + 4;
						if (ebp_1062 < ecx_547)
						{
							dwLoc78_1268 = 0x07;
							goto l0806CC14;
						}
						word16 * esi_555 = ebx_538 + 1;
						if (ecx_133 < esi_555)
						{
							dwLoc78_1268 = 0x05;
							goto l0806CC14;
						}
						uint32 edx_561 = *eax_122;
						word16 dx_664 = (word16) edx_561;
						if (edx_561 > 0xFFFF)
						{
							if (edx_561 >> 0x07 == 0x1C00)
							{
								dwLoc2C_1267 = ecx_547;
								eax_122 = ecx_547;
								goto l0806CB71;
							}
							if (edx_136 != null)
							{
								if ((*((word32) edi_26 + 8) & 0x08) != 0x00)
								{
									word32 ebx_2060;
									word32 esi_2061;
									word32 edi_2062;
									word32 eax_601 = __gconv_transliterate(gs, dwArg04, edi_26, fp - 44, ebp_1062, fp - 0x28, edx_136, out ebx_2060, out ebp_1062, out esi_2061, out edi_2062);
									dwLocA0 = fp - 44;
									dwLoc78_1268 = eax_601;
									ebx_538 = dwLoc28_1269;
									eax_122 = dwLoc2C_1267;
									if (eax_601 != 0x06)
									{
										if (eax_601 == 0x05)
											break;
										goto l0806CB71;
									}
								}
								if (esi_531 != 0x00)
								{
									++*edx_136;
									eax_122 = (word32) eax_122 + 4;
									dwLoc78_1268 = 0x06;
									dwLoc2C_1267 = eax_122;
									goto l0806CB71;
								}
							}
							goto l0806CCF1;
						}
						if (edx_561 <= ~0xDFFE)
						{
							if (edx_136 != null && esi_531 != 0x00)
							{
								++*edx_136;
								dwLoc2C_1267 = ecx_547;
								eax_122 = ecx_547;
								goto l0806CB71;
							}
l0806CCF1:
							dwLoc78_1268 = 0x06;
l0806CC14:
							*dwArg0C = (union Eq_2 *) eax_122;
							if (dwArg14 == 0x00)
								goto l0806CC22;
							goto l0806CBE0;
						}
						*ebx_538 = __rol(dx_664, 0x08);
						eax_122 = ecx_547;
						ebx_538 = esi_555;
						dwLoc28_1269 = esi_555;
						dwLoc2C_1267 = ecx_547;
					} while (ebp_1062 != ecx_547);
				}
				*dwArg0C = (union Eq_2 *) eax_122;
				if (dwArg14 != 0x00)
					break;
l0806CC22:
				*((word32) edi_26 + 0x0C) = (word32) *((word32) edi_26 + 0x0C) + 1;
				if ((*((word32) edi_26 + 8) & 0x01) != 0x00)
				{
					*edi_26 = ebx_538;
					*dwArg18 = *dwArg18;
					goto l0806CEC4;
				}
				word32 eax_709;
				if (ebx_538 > dwLoc7C_1136)
				{
					word16 * eax_710 = *edi_26;
					word32 ecx_2056;
					word32 edx_2057;
					_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1103, out ecx_2056, out edx_2057);
					word32 edx_767;
					fn00000000();
					dwLocA0 = dwArg20;
					if (eax_709 != 0x04)
					{
						if (ebx_538 != eax_710)
							*dwArg0C = (union Eq_2 *) (*dwArg0C - (ebx_538 - eax_710) * 0x02);
						goto l0806CC87;
					}
					eax_709 = dwLoc78_1268;
					if (dwLoc78_1268 != 0x05 && dwLoc78_1268 != 0x00)
						goto l0806CD45;
					goto l0806CC8F;
				}
				eax_709 = dwLoc78_1268;
l0806CC87:
				if (eax_709 != 0x00)
				{
l0806CD45:
					dwLoc78_1268 = eax_709;
l0806CEC4:
					esp_408 = fp - (struct Eq_64870 *) 0x8C;
					if (dwLoc78_1268 != 0x07 || dwArg20 == 0x00)
						goto l0806CBE6;
					Eq_2 esi_804 = *dwArg0C;
					if (ebp_1062 - esi_804 > 0x03)
						goto l0806D24E;
					struct Eq_65208 * eax_909;
					ui32 * ebx_903 = *((word32) edi_26 + 20);
					word32 eax_904 = esi_804 + 0x01;
					struct Eq_65216 * edx_906 = ebx_903 + 1;
					if (esi_804 < ebp_1062)
					{
						while (true)
						{
							*dwArg0C = (union Eq_2 *) eax_904;
							++edx_906;
							edx_906->bFFFFFFFF = (byte) *((word32) eax_904 - 1);
							word32 ecx_920 = eax_904 + 0x01;
							if (eax_904 == ebp_1062)
								break;
							eax_904 = ecx_920;
						}
						eax_909 = eax_904 - esi_804;
					}
					else
						eax_909 = null;
					*ebx_903 = eax_909 | *ebx_903 & ~0x07;
					goto l0806CBE6;
				}
l0806CC8F:
				esi_346 = *((word32) edi_26 + 8);
				eax_122 = *dwArg0C;
				dwLoc7C_1136 = (word16 *) *edi_26;
			}
l0806CBE0:
			*dwArg14 = ebx_538;
l0806CBE6:
			if ((esi_33 ^ gs->dw0014) == 0x00)
				return;
			goto l0806D2DA;
		}
		struct Eq_64968 * ecx_150 = *((word32) dwArg08 + 20);
		ui32 ecx_152 = ecx_150->dw0000;
		ui32 dwLoc68_1142 = ecx_152;
		struct Eq_65011 * dwLoc78_1143 = ecx_152 & 0x07;
		if ((ecx_152 & 0x07) == 0x00)
			goto l0806CB50;
		if (dwArg14 != 0x00)
			goto l0806D302;
		word16 * dwLoc28_1146 = ecx_127;
		if ((ecx_152 & 0x07) > 0x04)
		{
l0806D2B7:
			word32 ebx_880 = esp_1007->dw0040;
			struct Eq_65334 * esp_882 = esp_1007 - 4;
			esp_882->dw0000 = ebx_880 + ~0x00028ABF;
			esp_882->dwFFFFFFFC = 0x018B;
			esp_882->dwFFFFFFF8 = ebx_880 + ~0x00028C9C;
			esp_882->dwFFFFFFF4 = ebx_880 + 4294800288;
			word32 edx_2066;
			word32 ecx_2065;
			__assert_fail(out ecx_2065, out edx_2066);
l0806D2DA:
			word32 edx_2055;
			word32 ecx_2054;
			__stack_chk_fail(out ecx_2054, out edx_2055);
			esp_503.u0 = <invalid>;
			goto l0806D2DF;
		}
		up32 edx_178;
		int32 edx_173 = 0x00;
		if ((ecx_152 & 0x07) != 0x00)
		{
			do
			{
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x24)[edx_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (Eq_65372) (&ecx_150->dw0004)[edx_173];
				++edx_173;
			} while ((ecx_152 & 0x07) != edx_173);
			edx_178 = 0x04 - (ecx_152 & 0x07);
		}
		else
			edx_178 = 0x04;
		if (dwArg10 < (word32) eax_122 + edx_178)
		{
			*dwArg0C = (union Eq_2 *) dwArg10;
			if (eax_122 < dwArg10)
			{
				Eq_2 eax_216 = (word32) eax_122 + 1;
				struct Eq_65700 * esi_217 = ecx_150 + (ecx_152 & 0x07) / 8;
				while (true)
				{
					++esi_217;
					esi_217[3] = (struct Eq_65700) *((word32) eax_216 - 1);
					Eq_2 edx_227 = (word32) eax_216 + 1;
					if (dwArg10 == eax_216)
						break;
					eax_216 = edx_227;
				}
			}
			goto l0806D11B;
		}
		Eq_2 edx_233 = eax_122;
		if (ecx_133 < ecx_127 + 1)
			goto l0806CBE6;
		struct Eq_65392 * ebx_242 = ecx_152 & 0x07;
		do
		{
			edx_233 = (word32) edx_233 + 1;
			ebx_242 = (struct Eq_65392 *) ((char *) &ebx_242->dw0000 + 1);
			Mem252[fp - 0x25 + ebx_242:byte] = Mem248[edx_233 + -1:byte];
		} while (ebx_242 <= (struct Eq_65392 *) 0x03 && dwArg10 > edx_233);
		struct Eq_65011 * eax_458;
		word16 dx_492 = (word16) dwLoc24;
		if (dwLoc24 <= 0xFFFF)
		{
			if (dwLoc24 > ~0xDFFE)
			{
				*ecx_127 = __rol(dx_492, 0x08);
				dwLoc28_1146 = ecx_127 + 1;
l0806CE53:
				eax_458 = (struct Eq_65011 *) 0x04;
				goto l0806CE60;
			}
			if (edx_136 != null && (esi_346 & 0x02) != 0x00)
			{
				++*edx_136;
				ui32 eax_482 = ecx_150->dw0000;
				dwLoc68_1142 = eax_482;
				dwLoc78_1143 = eax_482 & 0x07;
				eax_458 = (struct Eq_65011 *) 0x04;
				goto l0806CE60;
			}
l0806D195:
			goto l0806CBE6;
		}
		if (dwLoc24 >> 0x07 == 0x1C00)
			goto l0806CE53;
		if (edx_136 == null)
			goto l0806D195;
		struct Eq_65011 * eax_331;
		if ((esi_346 & 0x08) == 0x00)
		{
			if ((esi_346 & 0x02) == 0x00)
				goto l0806CBE6;
			goto l0806D15E;
		}
		word32 ebx_285 = ebx_242 + (fp - 0x24);
		dwLocA0 = fp - (struct Eq_65511 *) 44;
		ui32 esi_322;
		word32 ebx_2069;
		word32 eax_316 = __gconv_transliterate(gs, dwArg04, dwArg08, fp - (struct Eq_65511 *) 44, ebx_285, fp - (struct Eq_65518 *) 0x28, edx_136, out ebx_2069, out ebp_1062, out esi_322, out edi_26);
		esp_328 = fp - (struct Eq_65525 *) 0x8C;
		Eq_2 ecx_330 = fp - (struct Eq_65508 *) 0x24;
		eax_331 = fp - (struct Eq_65508 *) 0x24;
		if (eax_316 == 0x06)
		{
			if ((esi_322 & 0x02) == 0x00)
			{
l0806D16C:
				if (eax_331 == fp - (struct Eq_65508 *) 0x24)
					goto l0806D195;
l0806D170:
				ui32 esi_459 = ecx_150->dw0000;
				eax_458 = eax_331 - (fp - (struct Eq_65508 *) 0x24);
				dwLoc68_1142 = esi_459;
				dwLoc78_1143 = esi_459 & 0x07;
l0806CE60:
				esp_503 = fp - (struct Eq_64870 *) 0x8C;
				if (dwLoc78_1143 >= eax_458)
				{
l0806D2DF:
					Eq_2 ebx_988 = *((word64) esp_503.u0 + 64);
					struct Eq_65433 * esp_990 = esp_503 - 4;
					esp_990->dw0000 = (word32) ebx_988 - 166592;
					esp_990->dwFFFFFFFC = 0x01C9;
					esp_990->dwFFFFFFF8 = (word32) ebx_988 - 167069;
					esp_990->dwFFFFFFF4 = (word32) ebx_988 - 166960;
					word32 ecx_2067;
					word32 edx_2068;
					__assert_fail(out ecx_2067, out edx_2068);
					Eq_2 esp_1002 = <invalid>;
					esp_1007 = (word32) esp_1002 - 4;
l0806D302:
					word32 esi_1010 = esp_1007->dw0040;
					struct Eq_65298 * esp_1012 = esp_1007 - 4;
					esp_1012->dw0000 = esi_1010 + ~0x00028A7F;
					esp_1012->dwFFFFFFFC = 0x022F;
					esp_1012->dwFFFFFFF8 = esi_1010 + ~0x00028CFD;
					esp_1012->dwFFFFFFF4 = esi_1010 + ~0x00028CE9;
					word32 ecx_2063;
					word32 edx_2064;
					__assert_fail(out ecx_2063, out edx_2064);
					word32 edi_2053;
					word32 ebx_2050;
					word32 ebp_2051;
					word32 esi_2052;
					__gconv_transliterate(gs, dwArg04, dwArg08, dwArg10, dwArg14, dwArg18, dwArg1C, out ebx_2050, out ebp_2051, out esi_2052, out edi_2053);
					return;
				}
				eax_122 = (char *) *dwArg0C + (eax_458 - dwLoc78_1143);
				*dwArg0C = (union Eq_2 *) eax_122;
				ecx_150->dw0000 = dwLoc68_1142 & ~0x07;
				dwLoc7C_1136 = dwLoc28_1146;
				esi_346 = *((word32) edi_26 + 8);
				goto l0806CB50;
			}
l0806D15E:
			++*edx_136;
			eax_331 = fp - (struct Eq_65544 *) 0x20;
			goto l0806D16C;
		}
		if (fp - (struct Eq_65508 *) 0x24 != fp - (struct Eq_65508 *) 0x24)
			goto l0806D170;
		if (eax_316 != 0x07)
		{
			if (eax_316 != 0x00)
				goto l0806CBE6;
			esi_346 = *((word32) edi_26 + 8);
			eax_122 = *dwArg0C;
			goto l0806CB50;
		}
		if (ebx_285 == fp - (struct Eq_65567 *) 0x20)
		{
l0806D294:
			Eq_2 esi_858 = esp_328[64];
			struct Eq_65574 * esp_860 = esp_328 - (struct Eq_65575 *) 4;
			esp_860->dw0000 = (word32) esi_858 - 166592;
			esp_860->tFFFFFFFC.u0 = 0x01DB;
			esp_860->tFFFFFFF8 = (word32) esi_858 - 167069;
			esp_860->tFFFFFFF4 = (word32) esi_858 - 0x00028C08;
			word32 ecx_2070;
			word32 edx_2071;
			__assert_fail(out ecx_2070, out edx_2071);
			Eq_2 esp_872 = <invalid>;
			esp_1007 = (word32) esp_872 - 4;
			goto l0806D2B7;
		}
		ui32 eax_353 = ecx_150->dw0000;
		Mem362[dwArg0C + 0x00:word32] = Mem327[dwArg0C + 0x00:word32] + (ebx_242 - (eax_353 & 0x07));
		if (ebx_242 <= (eax_353 & ~0x07))
		{
l0806D271:
			Eq_2 ebx_836 = esp_328[64];
			struct Eq_65626 * esp_838 = esp_328 - (struct Eq_65627 *) 4;
			esp_838->dw0000 = (word32) ebx_836 - 166592;
			esp_838->tFFFFFFFC.u0 = 0x01E5;
			esp_838->tFFFFFFF8 = (word32) ebx_836 - 167069;
			esp_838->tFFFFFFF4 = (word32) ebx_836 - 166884;
			word32 edx_2073;
			word32 ecx_2072;
			__assert_fail(out ecx_2072, out edx_2073);
			Eq_2 esp_850 = <invalid>;
			esp_328 = (word32) esp_850 - 4;
			goto l0806D294;
		}
		if (ebx_242 <= (struct Eq_65392 *) 0x04)
		{
			ecx_150->dw0000 = ebx_242 | eax_353 & ~0x07;
			if (ebx_285 > fp - (struct Eq_65508 *) 0x24)
			{
				struct Eq_65675 * ebp_417 = &ecx_150->dw0004;
				do
				{
					++ecx_330;
					++ebp_417;
					ebp_417->bFFFFFFFF = (byte) *((word32) ecx_330 - 1);
				} while (ebx_285 != ecx_330);
			}
l0806D11B:
			goto l0806CBE6;
		}
		word32 edx_2075;
		word32 ecx_2074;
		__assert_fail(out ecx_2074, out edx_2075);
		Eq_2 esp_381 = <invalid>;
		esp_1007 = (word32) esp_381 - 4;
	}
	else if (dwArg14 == 0x00)
	{
		struct Eq_64968 * eax_68 = *((word32) dwArg08 + 20);
		eax_68->dw0000 = 0x00;
		eax_68->dw0004 = 0x00;
		if ((*((word32) dwArg08 + 8) & 0x01) == 0x00)
		{
			word32 edx_2049;
			word32 ecx_2048;
			_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc60_1103, out ecx_2048, out edx_2049);
			word32 edx_112;
			fn00000000();
		}
		goto l0806CBE6;
	}
	word32 ebx_389 = esp_1007->dw0040;
	struct Eq_64937 * esp_391 = esp_1007 - 4;
	esp_391->dw0000 = ebx_389 + ~0x00028A7F;
	esp_391->dwFFFFFFFC = 0x019F;
	esp_391->dwFFFFFFF8 = ebx_389 + ~0x00028CFD;
	esp_391->dwFFFFFFF4 = ebx_389 + ~0x00028CE9;
	word32 ecx_2046;
	word32 edx_2047;
	__assert_fail(out ecx_2046, out edx_2047);
	Eq_2 esp_403 = <invalid>;
	esp_408 = (word32) esp_403 - 4;
l0806D24E:
	word32 ebx_814 = esp_408->dw0040;
	struct Eq_65177 * esp_816 = esp_408 - 4;
	esp_816->dw0000 = ebx_814 + ~0x00028A7F;
	esp_816->dwFFFFFFFC = 777;
	esp_816->dwFFFFFFF8 = ebx_814 + ~0x00028CFD;
	esp_816->dwFFFFFFF4 = ebx_814 + ~0x00028CD5;
	word32 edx_2059;
	word32 ecx_2058;
	__assert_fail(out ecx_2058, out edx_2059);
	Eq_2 esp_828 = <invalid>;
	esp_328 = (word32) esp_828 - 4;
	goto l0806D271;
}

// 0806D330: Register Eq_2 __gconv_transliterate(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_58641) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack (ptr32 word32) dwArg1C, Register out (ptr32 Eq_58877) ebxOut, Register out (ptr32 Eq_58877) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      __gconv_transform_internal_ascii
//      __gconv_transform_internal_utf8
//      __gconv_transform_internal_ucs2
//      __gconv_transform_internal_ucs2reverse
Eq_2 __gconv_transliterate(struct Eq_9 * gs, struct Eq_58641 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, word32 * dwArg1C, struct Eq_58877 & ebxOut, struct Eq_58877 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 ecx_36 = dwArg04->t0014;
	Eq_2 edx_131 = 0x080CE000;
	ui32 edi_32 = gs->dw0014;
	Eq_2 edi_1037 = *dwArg10;
	Eq_2 dwLoc50_555 = ecx_36;
	if (dwArg04->dw0000 != 0x00)
		dwLoc50_555 = __ror(ecx_36, 0x09) ^ gs->t0018;
	struct Eq_58877 * ebp_1016;
	Eq_2 dwLoc24_593;
	struct Eq_58877 * ebx_1028;
	Eq_2 eax_1013;
	struct Eq_65741 * ecx_320;
	Eq_2 esi_1043 = gs->ptrFFFFFFD0->t0000;
	uint32 eax_55 = *((word32) esi_1043 + 0x0118);
	uint32 dwLoc7C_558 = eax_55;
	if (eax_55 != 0x00)
	{
		ebp_1016 = ebp;
		if (dwArg14 >= (word32) edi_1037 + 4)
		{
			ui32 eax_99[] = *((word32) esi_1043 + 0x011C);
			uint32 dwLoc80_562 = 0x00;
			struct Eq_58877 * eax_102 = *((word32) esi_1043 + 288);
			struct Eq_58877 * eax_104[] = *((word32) esi_1043 + 292);
			struct Eq_58877 * eax_106 = *((word32) esi_1043 + 296);
			Eq_2 ecx_113 = (dwArg14 - 0x01 - edi_1037 >> 0x02) + 0x01;
			ebp_1016 = ebp;
l0806D438:
			uint32 eax_124 = dwLoc80_562 + dwLoc7C_558;
			ui32 eax_128 = eax_99[eax_124 >> 0x01];
			edx_131 = eax_102 + eax_128 * 0x04;
			esi_1043.u0 = 0x00;
			ebx_1028 = eax_102;
			Eq_2 eax_132 = *edx_131;
			do
			{
				Eq_2 esi_275;
				Eq_2 eax_278;
				if (*((word32) edi_1037 + esi_1043 * 0x04) != eax_132)
				{
					if (esi_1043 == 0x00)
					{
						eax_278 = edi_1037;
						esi_275.u0 = 0x00;
					}
					else
					{
						if (eax_132 != 0x00)
							break;
l0806D528:
						ebx_1028 = (&eax_104[eax_124 >> 0x01].a0000)[0];
						ebp_1016 = eax_106;
						edi_1037 = dwLoc50_555;
						word32 eax_170 = eax_106[ebx_1028 * 0x04];
						do
						{
							word32 * esi_180;
							int32 edx_173 = ebx_1028 * 0x04;
							word32 * ecx_175 = eax_106 + edx_173;
							if (eax_170 != 0x00)
							{
								++ebx_1028;
								word32 * eax_183 = eax_106 + 4 + edx_173;
								while (true)
								{
									esi_180 = eax_183;
									++eax_183;
									struct Eq_58877 * edx_188 = ebx_1028 + 1;
									if (*eax_183 == 0x00)
										break;
									ebx_1028 = edx_188;
								}
							}
							else
								esi_180 = ecx_175;
							dwLoc24_593 = *dwArg18;
							word32 edx_1068;
							word32 ecx_1067;
							_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc50_555, out ecx_1067, out edx_1068);
							dwLoc50_555();
							dwLocA0.u0 = 0x00;
							if (eax_1013 != 0x06)
							{
								if (eax_1013 == 0x04)
								{
									*dwArg10 = (word32) *dwArg10 + esi_1043 * 0x04;
									++*dwArg1C;
									eax_1013.u0 = 0x00;
									goto l0806D66E;
								}
								else
								{
									if (eax_1013 != 0x05)
										goto l0806D66E;
									goto l0806D4ED;
								}
							}
							++ebx_1028;
							eax_170 = (word32) eax_106[ebx_1028 * 0x04];
						} while (eax_170 != 0x00);
						esi_275 = esi_1043;
						eax_278 = edi_1037 + esi_1043 * 0x04;
					}
					if (dwArg14 > eax_278 && eax_102[((word64) esi_275.u0 + eax_128) *32 0x04] >= *eax_278)
						dwLoc7C_558 = eax_124 >> 0x01;
					else
						dwLoc80_562 = (eax_124 >> 0x01) + 0x01;
					if (dwLoc80_562 < dwLoc7C_558)
						goto l0806D438;
					esi_1043 = gs->ptrFFFFFFD0->t0000;
					ebp_1016 = (struct Eq_58877 *) *((word64) esi_1043.u0 + 308);
					if (ebp_1016 == null)
						goto l0806D648;
					edi_1037 = *dwArg10;
					ecx_320 = (struct Eq_65741 *) *((word64) esi_1043.u0 + 312);
					edx_131 = *edi_1037;
					goto l0806D609;
				}
				esi_1043 = (word32) esi_1043 + 1;
				eax_132 = *((word32) edx_131 + esi_1043 * 0x04);
				if (eax_132 == 0x00)
					goto l0806D528;
			} while (esi_1043 != ecx_113);
			goto l0806D4E8;
		}
		goto l0806D4DA;
	}
	ebp_1016 = (struct Eq_58877 *) *((word32) esi_1043 + 308);
	if (ebp_1016 != null)
	{
		if (dwArg14 < (word32) edi_1037 + 4)
		{
l0806D4DA:
			eax_1013.u0 = 0x04;
			ebx_1028 = ebx;
			if (edi_1037 == dwArg14)
				goto l0806D4ED;
			ebx_1028 = ebx;
l0806D4E8:
			eax_1013.u0 = 0x07;
			goto l0806D4ED;
		}
		ecx_320 = (struct Eq_65741 *) *((word32) esi_1043 + 312);
		edx_131 = *edi_1037;
l0806D609:
		if (ebp_1016 > null)
		{
			Eq_2 eax_329 = ecx_320->dw0000;
			if (eax_329 <= edx_131)
			{
				ebx_1028 = null;
				edi_1037 = edx_131;
				do
				{
					if (ecx_320->dw0004 >= edx_131)
					{
						edx_131 = (uint32) ((uint64) (edx_131 - eax_329) % ecx_320->dw0008);
						if (edx_131 == 0x00)
						{
							Mem363[dwArg10 + 0x00:word32] = edi_1037 + 0x04;
							++*dwArg1C;
							edi_1037 = dwArg10;
							eax_1013.u0 = 0x00;
							goto l0806D4ED;
						}
					}
					++ebx_1028;
					++ecx_320;
					if (ebx_1028 == ebp_1016)
						break;
					eax_329 = ecx_320->dw0000;
				} while (eax_329 <= edx_131);
			}
		}
l0806D648:
		ebx_1028 = (struct Eq_58877 *) *((word32) esi_1043 + 300);
		if (ebx_1028 == null)
		{
l0806D652:
			eax_1013.u0 = 0x06;
			goto l0806D4ED;
		}
		esi_1043 = *((word32) esi_1043 + 304);
	}
	else
	{
		ebx_1028 = (struct Eq_58877 *) *((word32) esi_1043 + 300);
		if (ebx_1028 == null)
			goto l0806D652;
		esi_1043 = *((word64) esi_1043.u0 + 304);
		if (dwArg14 <u edi_1037 + 0x04)
		{
			uint32 eax_80 = (uint32) (int8) (edi_1037 != dwArg14);
			eax_1013 = eax_80 + 0x04 + eax_80 * 0x02;
l0806D4ED:
			if ((edi_32 ^ gs->dw0014) != 0x00)
			{
				word32 edx_1065;
				word32 ecx_1064;
				Eq_2 eax_494 = __stack_chk_fail(out ecx_1064, out edx_1065);
				word32 ecx_1066;
				Eq_2 eax_511 = find_module_idx(eax_494, edx_131, out ecx_1066);
				ebxOut = ebx_1028;
				ebpOut = ebp_1016;
				esiOut = esi_1043;
				ediOut = edi_1037;
				return eax_511;
			}
			else
			{
				ebxOut = ebx;
				ebpOut = ebp;
				esiOut = esi;
				ediOut = edi;
				return eax_1013;
			}
		}
	}
	dwLoc24_593 = *dwArg18;
	word32 edx_1070;
	word32 ecx_1069;
	_dl_mcount_wrapper_check(gs, dwLocA0, dwLoc50_555, out ecx_1069, out edx_1070);
	dwLoc50_555();
	edi_1037 = dwLoc50_555;
	if (eax_1013 != 0x06)
	{
		if (eax_1013 == 0x04)
		{
			++*dwArg1C;
			*dwArg10 = (word32) *dwArg10 + 4;
			eax_1013.u0 = 0x00;
		}
l0806D66E:
		*dwArg18 = dwLoc24_593;
		edx_131 = dwLoc24_593;
		edi_1037 = dwArg18;
	}
	goto l0806D4ED;
}

// 0806D760: Register Eq_2 find_module_idx(Register Eq_2 eax, Register Eq_2 edx, Register out Eq_2 ecxOut)
// Called from:
//      __gconv_transliterate
//      __gconv_compare_alias_cache
//      __gconv_lookup_cache
Eq_2 find_module_idx(Eq_2 eax, Eq_2 edx, union Eq_2 & ecxOut)
{
	Eq_2 ebx_22 = gconv_cache;
	up32 ecx_25 = (word32) *((word32) ebx_22 + 4);
	word32 ecx_27 = (word32) *((word32) ebx_22 + 6);
	word32 eax_31 = __hash_string(eax);
	Eq_2 ecx_38 = (word32) *((word32) ebx_22 + 8);
	uint32 edx_53 = (uint32) ((uint64) eax_31 % (ecx_38 - 0x02));
	Eq_2 ebx_117 = (uint32) ((uint64) eax_31 % ecx_38);
	up32 edi_57 = cache_size - (word32) (*((word32) ebx_22 + 4));
	int32 eax_60 = (edx_53 + 0x01) * 0x04;
	ecx_197 = ecx_38;
	while (true)
	{
		Eq_2 ecx_197;
		struct Eq_66129 * esi_122 = (word32) ebx_22 + (ecx_27 + ebx_117 * 0x04);
		do
		{
			up32 eax_74 = (word32) esi_122->w0000;
			if ((word16) eax_74 == 0x00)
			{
				ecxOut = ecx_197;
				return ~0x00;
			}
			if (eax_74 < edi_57)
			{
				word32 edx_220;
				Eq_2 eax_92 = strcmp(eax, (word32) ebx_22 + (eax_74 + ecx_25), out ecx_197, out edx_220);
				if (eax_92 == 0x00)
				{
					*edx = (word32) esi_122->w0002;
					ecxOut = edx;
					return eax_92;
				}
			}
			ebx_117 = (word32) ebx_117 + (edx_53 + 0x01);
			esi_122 += eax_60 / 4;
		} while (ecx_38 > ebx_117);
		ebx_117 -= ecx_38;
	}
}

// 0806D860: Register Eq_2 find_module(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_66169 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __gconv_lookup_cache
Eq_2 find_module(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_66169 & ecxOut, union Eq_2 & edxOut)
{
	ui32 eax_28 = gs->dw0014;
	word32 ecx_302;
	word32 edx_303;
	Eq_2 eax_35 = strlen(eax, out ecx_302, out edx_303);
	word32 ecx_304;
	word32 edx_305;
	Eq_2 eax_49 = strlen(edx, out ecx_304, out edx_305);
	ui32 eax_58 = (word32) eax_35 + ((word32) eax_49 + 16);
	Eq_2 esp_56 = fp - 0x3C;
	Eq_2 edi_62 = fp - 0x3C - (eax_58 & ~0x0FFF);
	if (fp - 0x3C != edi_62)
	{
		do
		{
			esp_56 -= 0x1000;
			*((word32) esp_56 + 0x0FFC) = *((word32) esp_56 + 0x0FFC);
		} while (esp_56 != edi_62);
	}
	int32 edx_84 = eax_58 & ~0x0F & 0x0FFF;
	if (edx_84 != 0x00)
	{
		esp_56 -= edx_84;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_56 - 0x04)[edx_84 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_56 - 0x04)[edx_84 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_66228 * esp_96 = esp_56 - 0x04;
	esp_96->tFFFFFFFC = eax_35;
	esp_96->tFFFFFFF8 = eax;
	esp_96->tFFFFFFF4 = esp_56;
	word32 edx_306;
	Eq_2 eax_117 = __mempcpy(esp_96->tFFFFFFF4, esp_96->tFFFFFFF8, esp_96->tFFFFFFFC, out edx_306);
	esp_96->tFFFFFFFC = (word32) eax_49 + 1;
	esp_96->tFFFFFFF8 = edx;
	esp_96->tFFFFFFF4 = eax_117;
	word32 ecx_307;
	word32 edx_308;
	memcpy(esp_96->tFFFFFFF4, esp_96->tFFFFFFF8, esp_96->tFFFFFFFC, out ecx_307, out edx_308);
	esp_96->tFFFFFFF4 = esp_56;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_66169 ecx_154;
	Eq_2 eax_155 = __gconv_find_shlib(gs, stackArg4, out ecx_154);
	*ecx = eax_155;
	Eq_2 edx_159 = eax_155;
	Eq_2 eax_161 = 0x01;
	if (eax_155 != 0x00)
	{
		word32 eax_165 = *((word32) eax_155 + 0x0C);
		Eq_2 ebx_166 = *((word32) eax_155 + 16);
		*((word32) ecx + 4) = 0x00;
		*((word32) ecx + 20) = eax_165;
		Eq_2 eax_169 = *((word32) eax_155 + 20);
		*((word32) ecx + 28) = ebx_166;
		*((word32) ecx + 32) = eax_169;
		((word32) ecx + 24)->u0 = 0x00;
		((word32) ecx + 56)->u0 = 0x00;
		eax_161.u0 = 0x00;
		Eq_2 ebx_177 = __ror(ebx_166, 0x09) ^ gs->t0018;
		if (ebx_177 != 0x00)
		{
			esp_96->tFFFFFFF4 = ebx_177;
			word32 ecx_186;
			word32 edx_187;
			word32 eax_185 = _dl_mcount_wrapper_check(gs, esp_96->tFFFFFFF0, esp_96->tFFFFFFF4, out ecx_186, out edx_187);
			esp_96->tFFFFFFF4 = ecx;
			ebx_177();
			edx_159 = __rol(*((word32) ecx + 24) ^ gs->t0018, 0x09);
			*((word32) ecx + 24) = edx_159;
		}
	}
	if ((eax_28 ^ gs->dw0014) != 0x00)
	{
		Eq_66169 ecx_220;
		Eq_2 edx_222;
		__stack_chk_fail(out ecx_220, out edx_222);
		Eq_2 eax_226 = __gconv_get_cache();
		ecxOut = ecx_220;
		edxOut = edx_222;
		return eax_226;
	}
	else
	{
		ecxOut = ecx_154;
		edxOut = edx_159;
		return eax_161;
	}
}

// 0806D9B0: Register Eq_2 __gconv_get_cache()
// Called from:
//      find_module
Eq_2 __gconv_get_cache()
{
	return gconv_cache;
}

// 0806D9D0: Register word32 __gconv_load_cache(Register (ptr32 Eq_9) gs)
// Called from:
//      __gconv_read_conf
word32 __gconv_load_cache(struct Eq_9 * gs)
{
	word32 eax_184;
	ui32 eax_20 = gs->dw0014;
	Eq_2 eax_28 = getenv(0x080A5805);
	__gconv_path_envvar = eax_28;
	struct Eq_66400 * ebx_17 = &g_t80CE000;
	if (eax_28 != 0x00)
	{
l0806DB06:
		eax_184 = ~0x00;
		goto l0806DB0B;
	}
	word32 ecx_421;
	word32 edx_422;
	Eq_2 eax_49 = __open_nocancel(gs, 0x080A5810, 0x00, 0x00, out ecx_421, out edx_422);
	if (eax_49 == ~0x00)
		goto l0806DB06;
	word32 ecx_423;
	word32 edx_424;
	if (__fxstat64(gs, eax_49, fp - 0x80, out ecx_423, out edx_424) >= 0x00 && dwLoc54 > 0x0F)
	{
		cache_size = dwLoc54;
		word32 ecx_426;
		word32 edx_427;
		Eq_2 eax_98 = mmap(gs, 0x00, dwLoc54, 0x01, 0x01, eax_49, 0x00, out ecx_426, out edx_427);
		gconv_cache = eax_98;
		if (eax_98 != ~0x00)
		{
l0806DA85:
			word32 edx_435;
			__close_nocancel(gs, eax_49, out edx_435);
			Eq_2 edx_199 = gconv_cache;
			if (*edx_199 != 0x20010324)
			{
l0806DAE0:
				if (cache_malloced == 0x00)
				{
					word32 ecx_447;
					word32 edx_448;
					__munmap(0x080CE000, gs, edx_199, cache_size, out ecx_447, out edx_448, out ebx_17);
				}
				else
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 ecx_445;
					word32 edx_446;
					free(gs, stackArg0, edx_199, out ecx_445, out edx_446);
					cache_malloced = 0x00;
				}
				ebx_17->dw1954 = 0x00;
				goto l0806DB06;
			}
			Eq_2 ecx_203 = cache_size;
			if ((word32) *((word32) edx_199 + 4) >= ecx_203)
				goto l0806DAE0;
			Eq_2 esi_207 = (word32) *((word32) edx_199 + 6);
			if (ecx_203 <= esi_207)
				goto l0806DAE0;
			ui32 eax_210 = (word32) *((word32) edx_199 + 8);
			if ((word16) eax_210 == 0x00 || (ecx_203 < (word32) esi_207 + eax_210 * 0x04 || ecx_203 <= (word32) (*((word32) edx_199 + 0x0A))))
				goto l0806DAE0;
			eax_184 = 0x00;
			if (ecx_203 < (word32) (*((word32) edx_199 + 0x0C)))
				goto l0806DAE0;
l0806DB0B:
			if ((eax_20 ^ gs->dw0014) == 0x00)
				return eax_184;
			word32 edx_437;
			word32 ecx_436;
			__stack_chk_fail(out ecx_436, out edx_437);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			word32 esi_442;
			word32 edi_443;
			word32 ebx_441;
			return __gconv_compare_alias_cache(gs, stackArg4, stackArg8, stackArg12, out ebx_441, out esi_442, out edi_443);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 edi_109 = cache_size;
		Eq_2 stackArg0 = <invalid>;
		word32 esi_433;
		word32 edi_434;
		word32 edx_430;
		word32 ebx_431;
		word32 ebp_432;
		word32 ecx_429;
		Eq_2 eax_114 = __libc_malloc(gs, stackArg0, edi_109, out ecx_429, out edx_430, out ebx_431, out ebp_432, out esi_433, out edi_434);
		gconv_cache = eax_114;
		if (eax_114 != 0x00)
		{
			Eq_2 ebp_123 = 0x00;
			while (true)
			{
				word32 eax_144 = read(gs, eax_49, eax_114 + ebp_123, edi_109 - ebp_123);
				if (eax_144 == ~0x00)
					break;
				edi_109 = cache_size;
				ebp_123 = (word32) ebp_123 + eax_144;
				if (edi_109 <= ebp_123)
				{
					cache_malloced = 0x01;
					goto l0806DA85;
				}
				eax_114 = gconv_cache;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_451;
			word32 ecx_450;
			free(gs, stackArg0, gconv_cache, out ecx_450, out edx_451);
			gconv_cache.u0 = 0x00;
		}
	}
	word32 edx_425;
	__close_nocancel(gs, eax_49, out edx_425);
	eax_184 = ~0x00;
	goto l0806DB0B;
}

// 0806DBE0: Register Eq_2 __gconv_compare_alias_cache(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ebxOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      __gconv_compare_alias
//      __gconv_load_cache
Eq_2 __gconv_compare_alias_cache(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ebxOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 eax_142;
	ui32 ecx_19 = gs->dw0014;
	if (gconv_cache == 0x00)
	{
		eax_142.u0 = ~0x00;
		goto l0806DC37;
	}
	word32 ecx_164;
	if (find_module_idx(dwArg04, fp - 0x18, out ecx_164) == 0x00)
	{
		word32 ecx_165;
		eax_142 = find_module_idx(dwArg08, fp - 0x14, out ecx_165);
		if (eax_142 == 0x00)
		{
			*dwArg0C = dwLoc18 - dwLoc14;
l0806DC37:
			if ((ecx_19 ^ gs->dw0014) != 0x00)
			{
				word32 ecx_168;
				word32 edx_169;
				__stack_chk_fail(out ecx_168, out edx_169);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg12 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				Eq_2 stackArg20 = <invalid>;
				word32 ecx_173;
				Eq_2 eax_97 = __gconv_lookup_cache(gs, dwLoc18, dwLoc14, stackArg12, stackArg16, stackArg20, out ecx_173);
				ebxOut = dwArg04;
				esiOut = dwArg08;
				ediOut = dwArg0C;
				return eax_97;
			}
			else
			{
				ebxOut = ebx;
				esiOut = esi;
				ediOut = edi;
				return eax_142;
			}
		}
	}
	word32 ecx_166;
	word32 edx_167;
	*dwArg0C = strcmp(dwArg04, dwArg08, out ecx_166, out edx_167);
	eax_142.u0 = 0x00;
	goto l0806DC37;
}

// 0806DC80: Register Eq_2 __gconv_lookup_cache(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 bArg14, Register out Eq_2 ecxOut)
// Called from:
//      __gconv_find_transform
//      __gconv_compare_alias_cache
Eq_2 __gconv_lookup_cache(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 bArg14, union Eq_2 & ecxOut)
{
	Eq_2 esi_288;
	Eq_2 ecx_155 = dwArg10;
	ui32 ebx_26 = gs->dw0014;
	Eq_2 ebx_29 = gconv_cache;
	if (ebx_29 == 0x00)
	{
		esi_288.u0 = 0x02;
		goto l0806DD0B;
	}
	word16 dx_36 = *((word32) ebx_29 + 4);
	int32 ebp_35 = (word32) *((word32) ebx_29 + 0x0A);
	if (find_module_idx(dwArg08, fp - 0x28, out ecx_155) == 0x00)
	{
		ui32 ecx_50 = (word32) dwLoc28 + 3 + dwLoc28 * 0x02;
		ecx_155 = ecx_50 * 0x04;
		if ((word32) *((word32) ebx_29 + 0x0A) + ecx_50 * 0x04 > cache_size)
			goto l0806DD06;
		Eq_2 eax_60 = find_module_idx(dwArg04, fp - 0x24, out ecx_155);
		if (eax_60 == 0x00)
		{
			ui32 eax_73 = (word32) dwLoc24 + 3 + dwLoc24 * 0x02;
			ecx_155 = dwLoc24;
			if ((word32) *((word32) ebx_29 + 0x0A) + (eax_73 << 0x02) > cache_size)
				goto l0806DD06;
			Eq_154235 edx_78[] = (word32) ebx_29 + ebp_35;
			struct Eq_66755 * eax_80 = edx_78 - 0x0C + (eax_73 << 0x02);
			if ((bArg14 & 0x01) != 0x00 && dwLoc24 == dwLoc28)
			{
				esi_288.u0 = ~0x00;
				goto l0806DD0B;
			}
			Eq_2 ebx_302;
			struct Eq_66766 * esp_301;
			ptr32 eax_340;
			Eq_2 ebp_253;
			Eq_2 ecx_359;
			ptr32 eax_96 = (word32) ebx_29 + (word32) dx_36;
			struct Eq_66773 * eax_99 = edx_78 - 0x0C + ecx_50 * 0x04;
			if (dwLoc24 == 0x00 || dwLoc28 == 0x00)
			{
l0806DD9F:
				ebp_253 = dwLoc28;
				if (dwLoc28 == 0x00)
				{
					if (dwLoc24 != 0x00 && eax_80->w0008 != 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 edx_873;
						word32 ebx_874;
						word32 esi_876;
						word32 ebp_875;
						word32 edi_877;
						Eq_2 eax_374 = __libc_malloc(gs, stackArg0, 0x78, out ecx_155, out edx_873, out ebx_874, out ebp_875, out esi_876, out edi_877);
						ebx_302 = eax_374;
						if (eax_374 != 0x00)
						{
							*dwArg0C = eax_374;
							*dwArg10 = 0x00;
							ecx_359 = eax_374;
							goto l0806DDF7;
						}
						goto l0806DF90;
					}
					goto l0806DD06;
				}
				if (eax_99->w0004 == 0x00)
					goto l0806DD06;
				if (dwLoc24 == 0x00)
				{
l0806DE90:
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					word32 ebp_896;
					word32 esi_897;
					word32 ebx_895;
					word32 edx_894;
					word32 edi_898;
					Eq_2 eax_298 = __libc_malloc(gs, stackArg0, 0x78, out ecx_155, out edx_894, out ebx_895, out ebp_896, out esi_897, out edi_898);
					esi_288 = eax_60;
					esp_301 = fp - 0x5C;
					ebx_302 = eax_298;
					if (eax_298 != 0x00)
					{
						*dwArg0C = eax_298;
						*dwArg10 = 0x00;
						word32 eax_312 = (word32) eax_99->w0000;
						*((word32) eax_298 + 8) = 0x01;
						((word32) eax_298 + 56)->u0 = 0x00;
						*((word32) eax_298 + 0x0C) = eax_312 + eax_96;
						*((word32) eax_298 + 16) = 0x080A4DFD;
						Eq_2 edx_323 = (word32) eax_99->w0008 + eax_96;
						if ((word32) eax_99->w0006 + eax_96 != 0x00)
						{
							Eq_2 edx_341;
							word32 ecx_880;
							eax_340 = find_module(eax, eax_298, edx_341, gs, out ecx_880, out edx_341);
							if (eax_340 != 0x00)
								goto l0806DFB2;
						}
						else
							__gconv_get_builtin_trans(edx_323, eax_298);
						int32 edx_350 = *dwArg10;
						*dwArg10 = edx_350 + 0x01;
						ecx_155 = dwLoc24;
						ebp_253 = edx_350 + 0x01;
						if (dwLoc24 == 0x00)
						{
l0806DD0B:
							while ((ebx_26 ^ gs->dw0014) != 0x00)
							{
								word32 edx_871;
								__stack_chk_fail(out ecx_155, out edx_871);
l0806E0D5:
								esi_288 = dwLoc30;
							}
							ecxOut = ecx_155;
							return esi_288;
						}
						ecx_359 = (word32) eax_298 + (edx_350 + 0x01) *s 0x3C;
l0806DDF7:
						*((word32) ecx_359 + 0x0C) = 0x080A4DFD;
						word32 eax_397 = (word32) eax_80->w0000 + eax_96;
						*((word32) ecx_359 + 8) = 0x01;
						*((word32) ecx_359 + 16) = eax_397;
						byte * eax_401 = (word32) eax_80->w0002 + eax_96;
						word32 edx_402 = (word32) eax_80->w0004;
						((word32) ecx_359 + 56)->u0 = 0x00;
						esi_288 = eax_60;
						esp_301 = fp - 0x5C;
						Eq_2 edx_404 = edx_402 + eax_96;
						if (*eax_401 == 0x00)
						{
							ecx_155 = __gconv_get_builtin_trans(edx_404, ecx_359);
							goto l0806DE40;
						}
						Eq_2 edx_431;
						eax_340 = find_module(eax, ecx, edx_431, gs, out ecx_155, out edx_431);
						if (eax_340 == 0x00)
						{
l0806DE40:
							*dwArg10 = (word32) *dwArg10 + 1;
							goto l0806DD0B;
						}
						if (ebp_253 != 0x00)
						{
							word32 edx_884;
							__gconv_release_step(gs, ebx_302, out edx_884);
							esp_301 = fp - 88;
							eax_340 = 0x080A4DFD;
						}
l0806DFB2:
						esp_301->ptr0008 = eax_340;
						struct Eq_66939 * esp_455 = esp_301 - 0x0C;
						esp_455->tFFFFFFFC = ebx_302;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						Eq_2 stackArg4 = <invalid>;
						word32 edx_883;
						free(gs, stackArg0, stackArg4, out ecx_155, out edx_883);
						esi_288 = esp_455->t0014;
						goto l0806DD0B;
					}
l0806DF90:
					esi_288.u0 = 0x03;
					goto l0806DD0B;
				}
l0806DE7C:
				if (eax_80->w0008 != 0x00)
					goto l0806DE90;
				goto l0806DD06;
			}
			word32 eax_109 = (word32) eax_99->w000A;
			if ((word16) eax_109 != 0x00)
			{
				struct Eq_66853 * eax_117 = (word32) gconv_cache + (((word32) (*((word32) ebx_29 + 0x0C)) - 0x01) + eax_109);
				int32 eax_119 = (word32) eax_117->w0000;
				struct Eq_66853 * ebp_118 = eax_117;
				while ((word16) eax_119 != 0x00)
				{
					if (dwLoc24 == (word32) (ebp_118->a0002)[(eax_119 - 0x03) + eax_119 * 0x02])
					{
						*dwArg10 = eax_119;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg0 = <invalid>;
						word32 edx_886;
						word32 ebx_887;
						word32 ebp_888;
						word32 esi_889;
						word32 edi_890;
						Eq_2 eax_156 = __libc_malloc(gs, stackArg0, eax_119 *s 0x3C, out ecx_155, out edx_886, out ebx_887, out ebp_888, out esi_889, out edi_890);
						*dwArg0C = eax_156;
						if (eax_156 == 0x00)
							goto l0806DF90;
						Eq_2 ebx_168 = eax_156;
						dwLoc30 = eax_60;
						struct Eq_67069 * ebp_171 = ebp_118->a0002;
						int32 dwLoc3C_587 = 0x00;
						word32 esi_176 = (word32) eax_99->w0000 + eax_96;
						do
						{
							ui32 eax_179 = (word32) ebp_171->t0000;
							*((word32) ebx_168 + 0x0C) = esi_176;
							word32 esi_188 = (word32) edx_78[eax_179].w0000;
							int32 eax_189 = (word32) ebp_171->w0002;
							Eq_2 edx_190 = (word32) ebp_171->w0004 + eax_96;
							*((word32) ebx_168 + 8) = 0x01;
							*((word32) ebx_168 + 56) = 0x00;
							esi_176 = esi_188 + eax_96;
							*((word32) ebx_168 + 16) = esi_176;
							if (eax_189 + eax_96 == 0x00)
								ecx_155 = __gconv_get_builtin_trans(edx_190, ebx_168);
							else
							{
								Eq_2 edx_204;
								if (find_module(eax, ebx_168, edx_204, gs, out ecx_155, out edx_204) != 0x00)
								{
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg0 = <invalid>;
									word32 edx_892;
									free(gs, stackArg0, eax_156, out ecx_155, out edx_892);
									goto l0806DD9F;
								}
							}
							int32 v19_238 = dwLoc3C_587 + 0x01;
							dwLoc3C_587 = v19_238;
							ebx_168 = (word32) ebx_168 + 60;
							++ebp_171;
						} while ((word32) ebp_118->w0000 > v19_238);
						goto l0806E0D5;
					}
					ebp_118 = (struct Eq_66853 *) (ebp_118->a0002 + eax_119 * 3);
					eax_119 = (word32) ebp_118->w0000;
				}
			}
			if (eax_99->w0004 != 0x00)
				goto l0806DE7C;
		}
	}
l0806DD06:
	esi_288.u0 = 0x01;
	goto l0806DD0B;
}

// 0806E100: Register Eq_2 __gconv_release_cache()
// Called from:
//      __gconv_close_transform
Eq_2 __gconv_release_cache()
{
	if (gconv_cache != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_41;
		word32 edx_42;
		free(gs, stackArg0, dwArg04, out ecx_41, out edx_42);
	}
	return <invalid>;
}

// 0806E140: void known_compare(Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 Eq_2) dwArg08)
void known_compare(union Eq_2 * dwArg04, union Eq_2 * dwArg08)
{
	Eq_2 eax_6 = *dwArg08;
	Eq_2 eax_9 = *dwArg04;
	word32 ecx_22;
	word32 edx_23;
	strcmp(eax_9, eax_6, out ecx_22, out edx_23);
}

// 0806E160: void do_release_shlib(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack word32 dwArg08)
void do_release_shlib(struct Eq_9 * gs, union Eq_2 * dwArg04, word32 dwArg08)
{
	if (dwArg08 != 0x00 && dwArg08 != 0x03)
		return;
	Eq_2 ebx_19 = *dwArg04;
	Eq_67207 eax_20 = *((word32) ebx_19 + 4);
	if (release_handle == ebx_19)
	{
		if (eax_20 <= 0x00)
		{
			word32 ecx_142;
			word32 edx_143;
			__assert_fail(out ecx_142, out edx_143);
			Eq_2 esp_39 = <invalid>;
			word32 ecx_144;
			__gconv_find_shlib(gs, *esp_39, out ecx_144);
		}
		else
			*((word32) ebx_19 + 4) = eax_20 - 0x01;
	}
	else if (eax_20 <= 0x00)
	{
		*((word32) ebx_19 + 4) = eax_20 - 0x01;
		if (eax_20 == ~0x01 && *((word32) ebx_19 + 8) != 0x00)
		{
			word32 ecx_141;
			__libc_dlclose(out ecx_141);
			*((word32) ebx_19 + 8) = 0x00;
		}
	}
}

// 0806E200: Register Eq_2 __gconv_find_shlib(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      find_derivation
//      find_module
//      do_release_shlib
Eq_2 __gconv_find_shlib(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 esi_114;
	Eq_2 eax_29 = __tfind(fp + 0x04, 0x080CF95C, 0x0806E140);
	if (eax_29 != 0x00)
	{
		esi_114 = *eax_29;
		if (esi_114 == 0x00)
			goto l0806E396;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		word32 edx_407;
		word32 ecx_406;
		Eq_2 eax_45 = strlen(dwArg04, out ecx_406, out edx_407);
		Eq_2 stackArg0 = <invalid>;
		word32 ebx_411;
		word32 edx_410;
		word32 ecx_409;
		word32 ebp_412;
		word32 esi_413;
		word32 edi_414;
		Eq_2 eax_56 = __libc_malloc(gs, stackArg0, (word32) eax_45 + 25, out ecx_409, out edx_410, out ebx_411, out ebp_412, out esi_413, out edi_414);
		ecx = dwArg04;
		esi_114 = eax_56;
		if (eax_56 == 0x00)
			goto l0806E396;
		word32 ecx_420;
		word32 edx_421;
		Eq_2 eax_77 = memcpy((word32) eax_56 + 24, dwArg04, (word32) eax_45 + 1, out ecx_420, out edx_421);
		*((word32) eax_56 + 4) = ~0x02;
		*eax_56 = eax_77;
		*((word32) eax_56 + 8) = 0x00;
		word32 edx_422;
		if (__tsearch(eax_56, 0x080CF95C, 0x0806E140, out ecx, out edx_422) == null)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_424;
			free(gs, stackArg0, eax_56, out ecx, out edx_424);
			goto l0806E396;
		}
	}
	int32 eax_120 = *((word32) esi_114 + 4);
	word32 edx_121 = *((word32) esi_114 + 8);
	if (eax_120 >= ~0x01)
	{
		if (edx_121 != 0x00)
		{
			if (eax_120 < 0x00)
				eax_120 = 0x00;
			*((word64) esi_114.u0 + 4) = eax_120 + 0x01;
		}
		goto l0806E314;
	}
	if (edx_121 != 0x00)
	{
		word32 ecx_415;
		word32 edx_416;
		__assert_fail(out ecx_415, out edx_416);
		Eq_2 ecx_162;
		word32 edx_425;
		Eq_2 eax_161 = __gconv_release_shlib(0x080A5833, out ecx_162, out edx_425);
		ecxOut = ecx_162;
		return eax_161;
	}
	word32 eax_175 = __libc_dlopen_mode(gs, out ecx);
	*((word32) esi_114 + 8) = eax_175;
	if (eax_175 != 0x00)
	{
		word32 ecx_417;
		Eq_2 eax_206 = __libc_dlsym(gs, out ecx_417);
		*((word32) esi_114 + 0x0C) = eax_206;
		if (eax_206 != 0x00)
		{
			word32 ecx_419;
			*((word64) esi_114.u0 + 16) = __libc_dlsym(gs, out ecx_419);
			Eq_2 ecx_275;
			Eq_2 eax_273 = __libc_dlsym(gs, out ecx_275);
			*((word64) esi_114.u0 + 4) = 0x01;
			Eq_2 edx_279 = *((word64) esi_114.u0 + 0x0C);
			Eq_2 eax_284 = __rol(eax_273 ^ gs->t0018, 0x09);
			Eq_2 edx_287 = __rol(edx_279 ^ gs->t0018, 0x09);
			*((word64) esi_114.u0 + 20) = eax_284;
			*((word64) esi_114.u0 + 0x0C) = edx_287;
			*((word64) esi_114.u0 + 16) = __rol(*((word64) esi_114.u0 + 16) ^ gs->t0018, 0x09);
			ecxOut = ecx_275;
			return esi_114;
		}
		release_handle = esi_114;
		word32 edx_418;
		twalk(loaded, &g_u806E160, out ecx, out edx_418);
		esi_114.u0 = 0x00;
l0806E314:
		ecxOut = ecx;
		return esi_114;
	}
l0806E396:
	ecxOut = ecx;
	return 0x00;
}

// 0806E3F0: Register word32 __gconv_release_shlib(Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      __gconv_release_step
//      __gconv_find_shlib
word32 __gconv_release_shlib(Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut)
{
	release_handle = dwArg04;
	ptr32 edx_18;
	ptr32 ecx_19;
	word32 eax_17 = twalk(loaded, &g_u806E160, out ecx_19, out edx_18);
	ecxOut = ecx_19;
	edxOut = edx_18;
	return eax_17;
}

// 0806E430: Register Eq_2 new_composite_name(Register Eq_2 eax, Register (arr Eq_2) edx, Register (ptr32 Eq_9) gs)
// Called from:
//      setlocale
Eq_2 new_composite_name(Eq_2 eax, Eq_2 edx[], struct Eq_9 * gs)
{
	Eq_2 edi_10 = 0x00;
	Eq_2 esi_14 = 0x00;
	word32 dwLoc28_327 = 0x01;
	while (true)
	{
		if (esi_14 != 0x06)
		{
			Eq_2 ebp_37;
			if (eax == 0x06)
				ebp_37 = edx[esi_14];
			else if (eax != esi_14)
				ebp_37 = *((char *) g_a80CEEA0 + esi_14 * 0x04);
			else
				ebp_37 = edx[0];
			word32 edx_461;
			word32 ecx_460;
			Eq_2 eax_48 = strlen(ebp_37, out ecx_460, out edx_461);
			edi_10 = (word32) eax_48 + (((word32) edi_10 + 2) + (word32) (((word32) esi_14 - 165696) + 0x080CE000));
			if (dwLoc28_327 != 0x00)
			{
				Eq_2 eax_69 = edx[0];
				if (eax_69 != ebp_37)
				{
					word32 ecx_462;
					word32 edx_463;
					dwLoc28_327 = (word32) (int8) (strcmp(ebp_37, eax_69, out ecx_462, out edx_463) == 0x00);
				}
			}
			if (esi_14 == 0x0C)
			{
				Eq_2 dwLoc28_368;
				if (dwLoc28_327 != 0x00)
				{
					Eq_2 esi_216 = edx[0];
					dwLoc28_368.u0 = 134892338;
					word32 ecx_469;
					word32 edx_470;
					if (strcmp(esi_216, 134892338, out ecx_469, out edx_470) == 0x00)
						return dwLoc28_368;
					word32 edx_472;
					word32 ecx_471;
					if (strcmp(esi_216, 0x080B1B74, out ecx_471, out edx_472) == 0x00)
						return dwLoc28_368;
					Eq_2 edi_261;
					Eq_2 esi_263;
					word32 ecx_473;
					word32 ebx_475;
					word32 ebp_476;
					word32 edx_474;
					Eq_2 eax_257 = __libc_malloc(gs, dwLoc40, (word32) eax_48 + 1, out ecx_473, out edx_474, out ebx_475, out ebp_476, out esi_263, out edi_261);
					if (eax_257 != 0x00)
					{
						word32 edx_478;
						word32 ecx_477;
						dwLoc28_368 = memcpy(eax_257, esi_263, edi_261, out ecx_477, out edx_478);
						return dwLoc28_368;
					}
				}
				else
				{
					struct Eq_67547 * ebx_115;
					word32 esi_467;
					word32 edx_465;
					word32 ecx_464;
					word32 edi_468;
					word32 ebp_466;
					Eq_2 eax_113 = __libc_malloc(gs, dwLoc40, edi_10, out ecx_464, out edx_465, out ebx_115, out ebp_466, out esi_467, out edi_468);
					Eq_2 edx_125 = eax_113;
					if (eax_113 != 0x00)
					{
						Eq_2 esi_132 = 0x00;
						while (true)
						{
							if (esi_132 != 0x06)
							{
								Eq_2 ebp_147;
								if (eax == 0x06)
									ebp_147 = edx[esi_132];
								else if (esi_132 != eax)
									ebp_147 = ebx_115->a0EA0[esi_132];
								else
									ebp_147 = edx[0];
								word32 ecx_479;
								Eq_2 eax_167 = __stpcpy(edx_125, (char *) ebx_115 - 165664 + (word32) ebx_115[((word32) esi_132 - 165680) / 3744], out ecx_479);
								*eax_167 = 0x3D;
								word32 ecx_480;
								Eq_2 eax_185 = __stpcpy((word32) eax_167 + 1, ebp_147, out ecx_480);
								*eax_185 = 0x3B;
								edx_125 = (word32) eax_185 + 1;
								if (esi_132 == 0x0C)
								{
									*eax_185 = 0x00;
									return eax_113;
								}
							}
							esi_132 = (word32) esi_132 + 1;
						}
					}
				}
				dwLoc28_368.u0 = 0x00;
				return dwLoc28_368;
			}
		}
		esi_14 = (word32) esi_14 + 1;
	}
}

// 0806E630: void setlocale(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void setlocale(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	struct Eq_67675 * ebx_1184 = &g_t80CE000;
	ui32 eax_20 = gs->dw0014;
	Eq_2 esi_209 = dwArg04;
	Eq_2 edx_1098 = dwArg08;
	if (dwArg04 > 0x0C)
	{
		gs->tFFFFFFE0.u0 = 22;
		goto l0806E6E7;
	}
	if (dwArg08 == 0x00)
	{
l0806E6E7:
		if ((eax_20 ^ gs->dw0014) == 0x00)
			return;
		word32 ecx_1825;
		word32 edx_1826;
		Eq_2 eax_1138 = __stack_chk_fail(out ecx_1825, out edx_1826);
		strip(eax_1138, edx_1098);
		return;
	}
	uint32 edi_207 = (word32) dwArg04 + 16;
	edx_1098 = dwArg08;
	word32 ecx_1823;
	word32 edx_1824;
	if (strcmp(dwArg08, *((char *) &g_ptr80CEE60 + ((word32) dwArg04 + 16) * 0x04), out ecx_1823, out edx_1824) == 0x00)
		goto l0806E6E7;
	Eq_2 eax_89 = getenv(0x080A58A7);
	if (eax_89 != 0x00 && (*eax_89 != 0x00 && (argz_create_sep(gs, eax_89, fp - 0x90, fp - 0x8C) != 0x00 || __argz_add_sep(gs, fp - 0x90, fp - 0x8C, 0x080A59B0) != 0x00)))
	{
		edx_1098 = dwArg08;
		Mem1126 = Mem1127;
		goto l0806E6E7;
	}
	if (dwArg04 == 0x06)
	{
		ui32 eax_451 = 0x00;
		while (true)
		{
			if (eax_451 != 0x06)
			{
				(fp - 0x88)[eax_451] = dwArg08;
				if (eax_451 == 0x0C)
				{
					word32 edx_1828;
					word32 ecx_1827;
					if (strchr(dwArg08, 0x3B, out ecx_1827, out edx_1828) == 0x00)
					{
l0806E792:
						Eq_2 edi_1177[] = fp - 0x88;
						ui32 esi_720 = 0x0D;
l0806E7A1:
						struct Eq_67787 * esp_1001;
						Eq_2 ebp_1181;
						ui32 eax_827;
						Eq_2 ebp_724 = esi_720 - 0x01;
						while (esi_720 != 0x00)
						{
							Eq_2 esi_734;
							if (ebp_724 == 0x06)
								esi_734.u0 = 0x05;
							else
								esi_734 = ebp_724;
							ui32 ebp_755;
							struct Eq_67744 * eax_754 = _nl_find_locale(gs, 0x00, 0x00, esi_734, edi_1177 + esi_734, out ebx_1184, out ebp_755, out esi_720, out edi_1177);
							(fp - 0x54)[esi_720] = eax_754;
							if (eax_754 == null)
							{
								if ((fp - 0x88)[esi_720] == 134892338)
									goto l0806E7A1;
								goto l0806EAD2;
							}
							if (eax_754->dw0018 != ~0x00)
								eax_754->dw0018 = ~0x00;
							Eq_2 edx_781 = (fp - 0x88)[esi_720];
							if (edx_781 == 134892338)
								goto l0806E7A1;
							Eq_2 ecx_788 = *((char *) g_a80CEEA0 + esi_720 * 0x04);
							word32 edx_1831;
							word32 ecx_1830;
							if (strcmp(edx_781, ecx_788, out ecx_1830, out edx_1831) != 0x00)
							{
								Eq_2 eax_811 = strdup(edx_781);
								(fp - 0x88)[esi_720] = eax_811;
								if (eax_811 != 0x00)
									goto l0806E7A1;
l0806EAD2:
								esp_1001 = fp - 188;
								eax_827 = ebp_755;
								ebp_1181.u0 = 134892338;
								if (ebp_755 == 0x0D)
									goto l0806EB11;
								goto l0806EADD;
							}
							(fp - 0x88)[esi_720] = ecx_788;
							ebp_724 = esi_720 - 0x01;
						}
						esp_1001 = fp - 188;
						if (new_composite_name(0x06, edi_1177, gs) != 0x00)
						{
							ui32 ebp_914 = 0x00;
							while (true)
							{
								if (ebp_914 != 0x06)
								{
									int32 edx_918 = ebp_914 * 0x04;
									if (ebx_1184[edx_918 - 0x0140] != 0x00)
									{
										ebx_1184[edx_918 + 0x0E60] = (struct Eq_67675) esp_1001->a0068[ebp_914];
										<anonymous> * edx_928 = ebx_1184[edx_918 - 0x0180];
										if (edx_928 != null)
											edx_928();
									}
									Eq_2 esi_943 = edi_1177[ebp_914];
									Eq_2 edx_945 = ebx_1184->a0EA0[ebp_914];
									if (esi_943 != edx_945)
									{
										if (edx_945 != esp_1001[2])
										{
											struct Eq_68057 * esp_951 = esp_1001 - 0x0C;
											esp_951->tFFFFFFFC = edx_945;
											word32 ecx_1838;
											word32 edx_1839;
											free(gs, esp_951->tFFFFFFF8, esp_951->tFFFFFFFC, out ecx_1838, out edx_1839);
											esp_1001 = (struct Eq_67787 *) ((char *) &esp_951->tFFFFFFFC + 20);
										}
										ebx_1184->a0EA0[ebp_914] = esi_943;
									}
									if (ebp_914 == 0x0C)
									{
										Eq_2 ebp_979 = esp_1001[3];
										Eq_2 eax_981 = ebx_1184[0x0EB8];
										if (ebp_979 != eax_981)
										{
											if (eax_981 != (char *) ebx_1184 - 169166)
											{
												struct Eq_68180 * esp_987 = esp_1001 - 0x0C;
												esp_987->tFFFFFFFC = eax_981;
												word32 ecx_1846;
												word32 edx_1847;
												free(gs, esp_987->tFFFFFFF8, esp_987->tFFFFFFFC, out ecx_1846, out edx_1847);
												esp_1001 = (struct Eq_67787 *) ((char *) &esp_987->tFFFFFFFC + 20);
											}
											ebx_1184[0x0EB8] = (struct Eq_67675) ebp_979;
										}
										_nl_msg_cat_cntr = (word32) _nl_msg_cat_cntr + 1;
l0806EB13:
										struct Eq_68121 * esp_1073 = esp_1001 - 0x0C;
										esp_1073->tFFFFFFFC = esp_1073->t0038;
										word32 ecx_1843;
										word32 edx_1844;
										free(gs, esp_1073->tFFFFFFF8, esp_1073->tFFFFFFFC, out ecx_1843, out edx_1844);
										esp_1073->t0000 = esp_1073->t0028;
										word32 ecx_1845;
										free(gs, esp_1073->tFFFFFFFC, esp_1073->t0000, out ecx_1845, out edx_1098);
										goto l0806E6E7;
									}
								}
								++ebp_914;
							}
						}
						eax_827 = 0x00;
						ebp_1181 = (char *) ebx_1184 - 169166;
l0806EADD:
						esp_1001 = fp - 188;
						ui32 esi_875 = eax_827;
						while (true)
						{
							if (esi_875 != 0x06)
							{
								Eq_2 eax_881 = edi_1177[esi_875];
								if (eax_881 != ebp_1181 && eax_881 != (ebx_1184->a0EA0)[esi_875])
								{
									struct Eq_68101 * esp_889 = esp_1001 - 0x0C;
									esp_889->tFFFFFFFC = eax_881;
									word32 edx_1842;
									word32 ecx_1841;
									free(gs, esp_889->tFFFFFFF8, esp_889->tFFFFFFFC, out ecx_1841, out edx_1842);
									esp_1001 = (struct Eq_67787 *) ((char *) &esp_889->tFFFFFFFC + 20);
								}
								if (esi_875 == 0x0C)
								{
l0806EB11:
									goto l0806EB13;
								}
							}
							++esi_875;
						}
					}
					Eq_2 eax_493 = strdup(dwArg08);
					Eq_2 esi_509 = eax_493;
					edx_1098 = dwArg08;
					if (eax_493 == 0x00)
						goto l0806E6E7;
l0806EC00:
					word32 ecx_1836;
					word32 edx_1837;
					Eq_2 eax_541 = strchr(esi_509, 0x3D, out ecx_1836, out edx_1837);
					if (eax_541 == 0x00)
					{
l0806EC80:
						ui32 eax_620 = 0x00;
						while (true)
						{
							if (eax_620 != 0x06)
							{
								if ((fp - 0x88)[eax_620] == dwArg08)
								{
l0806ECB0:
									word32 ecx_1840;
									free(gs, dwLocD0, eax_493, out ecx_1840, out edx_1098);
									gs->tFFFFFFE0.u0 = 22;
									goto l0806E6E7;
								}
								if (eax_620 == 0x0C)
									goto l0806E792;
							}
							++eax_620;
						}
					}
					else
					{
						Eq_2 eax_553 = eax_541 - esi_509;
						Eq_67890 ebp_554 = 0x00;
						while (true)
						{
							if (ebp_554 != 0x06)
							{
								if ((word32) ((word32) ebp_554 - 165696 + 0x080CE000) == eax_553)
								{
									word32 edx_1833;
									word32 ecx_1832;
									if (memcmp(esi_509, (word32) ((word32) ebp_554 - 165680 + 0x080CE000) + 0x080A58E0, eax_553, out ecx_1832, out edx_1833) == 0x00)
									{
										(fp - 0x88)[ebp_554] = (word32) eax_541 + 1;
										word32 ecx_1834;
										word32 edx_1835;
										Eq_2 eax_605 = strchr((word32) eax_541 + 1, 0x3B, out ecx_1834, out edx_1835);
										if (eax_605 != 0x00)
										{
											*eax_605 = 0x00;
											esi_509 = (word32) eax_605 + 1;
											goto l0806EC00;
										}
										goto l0806EC80;
									}
								}
								if (ebp_554 == 0x0C)
									goto l0806ECB0;
							}
							ebp_554 = (word32) ebp_554 + 1;
						}
					}
				}
			}
			++eax_451;
		}
	}
	struct Eq_67744 * dwLocAC_1235;
	struct Eq_67745 * esp_215;
	word32 eax_182 = g_a80CE140[dwArg04 * 0x04];
	Eq_2 dwLoc54_1233 = dwArg08;
	if (eax_182 != 0x00)
	{
		word32 ebp_1829;
		struct Eq_67744 * eax_203 = _nl_find_locale(gs, 0x00, 0x00, dwArg04, fp - 0x54, out ebx_1184, out ebp_1829, out esi_209, out edi_207);
		dwLocAC_1235 = eax_203;
		esp_215 = fp - 188;
		if (eax_203 == null)
			goto l0806EB8C;
		if (eax_203->dw0018 != ~0x00)
			eax_203->dw0018 = ~0x00;
	}
	else
		dwLocAC_1235 = null;
	Eq_2 ebp_224 = (char *) ebx_1184 - 169166;
	if (dwArg08 != ebp_224)
	{
		Eq_2 eax_233 = strdup(dwArg08);
		dwLoc54_1233 = eax_233;
		esp_215 = fp - 188;
		if (eax_233 == 0x00)
			goto l0806EB8C;
	}
	esp_215 = fp - 188;
	Eq_2 eax_254 = new_composite_name(esi_209, fp - 0x54, gs);
	if (eax_254 != 0x00)
	{
		if (eax_182 != 0x00)
		{
			*((char *) &g_ptr80CEE60 + esi_209 * 0x04) = (struct Eq_72699 **) dwLocAC_1235;
			<anonymous> * edx_294 = (ebx_1184 - 0x0180)[esi_209];
			if (edx_294 != null)
				edx_294();
		}
		Eq_2 eax_321 = eax_254;
		Eq_2 edx_315 = *((char *) &g_ptr80CEE60 + edi_207 * 0x04);
		if (dwLoc54_1233 != edx_315)
		{
			if (edx_315 != ebp_224)
			{
				word32 edx_1849;
				word32 ecx_1848;
				free(gs, dwLocD0, edx_315, out ecx_1848, out edx_1849);
				esp_215 = fp - 0xB8;
				eax_321.u0 = 0x080CEE60;
			}
			esp_215->ptr000C[edi_207] = dwLoc54_1233;
		}
		Eq_2 edx_349 = ebx_1184[0x0EB8];
		if (eax_321 != edx_349)
		{
			if (edx_349 != ebp_224)
			{
				esp_215->t0008 = eax_321;
				struct Eq_68311 * esp_360 = esp_215 - 0x0C;
				esp_360->tFFFFFFFC = edx_349;
				word32 ecx_1853;
				word32 edx_1854;
				free(gs, esp_360->tFFFFFFF8, esp_360->tFFFFFFFC, out ecx_1853, out edx_1854);
				esp_215 = (struct Eq_67745 *) ((char *) &esp_360->tFFFFFFFC + 20);
				eax_321 = esp_360->t0018;
			}
			ebx_1184[0x0EB8] = (struct Eq_67675) eax_321;
		}
		_nl_msg_cat_cntr = (word32) _nl_msg_cat_cntr + 1;
l0806EA06:
		struct Eq_68270 * esp_432 = esp_215 - 0x0C;
		esp_432->tFFFFFFFC = esp_432->t0038;
		word32 ecx_1850;
		free(gs, esp_432->tFFFFFFF8, esp_432->tFFFFFFFC, out ecx_1850, out edx_1098);
		goto l0806E6E7;
	}
	if (dwLoc54_1233 != ebp_224)
	{
		word32 ecx_1851;
		word32 edx_1852;
		free(gs, dwLocD0, dwLoc54_1233, out ecx_1851, out edx_1852);
		esp_215 = fp - 0xB8;
	}
l0806EB8C:
	esp_215->dw0068 = 0x00;
	goto l0806EA06;
}

// 0806ED30: void strip(Register Eq_2 eax, Register Eq_2 edx)
// Called from:
//      setlocale
//      _nl_find_locale
void strip(Eq_2 eax, Eq_2 edx)
{
	Eq_2 edx_118;
	word32 ecx_101 = (word32) *edx;
	ui24 ebx_24_8_139 = SLICE(0x080CE000, word24, 8);
	if ((byte) ecx_101 == 0x00)
	{
		*eax = 0x2F;
		edx_118 = (word32) eax + 1;
		goto l0806EDF2;
	}
	else
	{
		Eq_2 esi_28 = g_t80CE08C;
		int32 ebp_107 = 0x00;
		Eq_3851 esi_33[] = g_ptr80CE084;
		do
		{
			byte cl_35 = (byte) ecx_101;
			int32 esi_39 = (int32) cl_35;
			word32 dwLoc1C_152 = ebp_107 + 0x01;
			ebx_24_8_139 = SLICE(ecx_101 - 44, word24, 8);
			if (((int8) ((byte) (ecx_101 - 44) <= 0x02) | (byte) (SEQ(ebx_24_8_139, (int8) (cl_35 == 0x3A)) | SEQ(ebx_24_8_139, (int8) (cl_35 == 0x5F)))) == 0x00 && (*((word32) esi_28 + esi_39 * 0x02) & 0x08) == 0x00)
			{
				if (cl_35 == 0x2F)
				{
					int32 esi_93 = ebp_107 + 0x01;
					if (esi_93 == 0x03)
						goto l0806EDF8;
					*eax = 0x2F;
					edx = (word32) edx + 1;
					ecx_101 = (word32) *edx;
					ebp_107 = esi_93;
					dwLoc1C_152 = ebp_107 + 0x02;
					eax = (word32) eax + 1;
					if ((byte) ecx_101 == 0x00)
						break;
					continue;
				}
			}
			else
			{
				eax = (word32) eax + 1;
				*((word32) eax - 1) = esi_33[esi_39];
			}
			edx = (word32) edx + 1;
			ecx_101 = (word32) *edx;
		} while ((byte) ecx_101 != 0x00);
		if (ebp_107 <= 0x01)
		{
			*eax = 0x2F;
			edx_118 = (word32) eax + 1;
			if (dwLoc1C_152 == 0x01)
			{
l0806EDF2:
				*edx_118 = 0x2F;
				eax = (word32) edx_118 + 1;
				goto l0806EDF8;
			}
			eax = edx_118;
		}
l0806EDF8:
		*eax = 0x00;
	}
}

// 0806EE10: Register Eq_2 _nl_find_locale(Register (ptr32 Eq_9) gs, Stack ui32 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack (ptr32 Eq_2) dwArg10, Register out (ptr32 Eq_67835) ebxOut, Register out (ptr32 Eq_67836) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      setlocale
Eq_2 _nl_find_locale(struct Eq_9 * gs, ui32 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 * dwArg10, struct Eq_67835 & ebxOut, struct Eq_67836 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	struct Eq_67836 * ebp_1039 = fp - 4;
	Eq_2 esi_1000 = *dwArg10;
	if (*esi_1000 != 0x00)
	{
l0806EE54:
		Eq_2 esp_1122;
		struct Eq_67835 * ebx_1066;
		Eq_2 edi_1061;
		word32 edx_1414;
		word32 ecx_1413;
		if (strcmp(esi_1000, 134892338, out ecx_1413, out edx_1414) != 0x00)
		{
			word32 ecx_1415;
			word32 edx_1416;
			if (strcmp(esi_1000, 0x080B1B74, out ecx_1415, out edx_1416) != 0x00)
			{
				word32 ecx_1417;
				word32 edx_1418;
				Eq_2 eax_169 = strlen(esi_1000, out ecx_1417, out edx_1418);
				if (eax_169 <= 0xFF)
				{
					Eq_2 edi_199;
					if (__memmem(gs, esi_1000, eax_169, 0x080A599C, 0x04, out ebp_1039, out esi_1000, out edi_199) != 0x00)
						goto l0806EF50;
					if (edi_199 != 0x02)
					{
						if (edi_199 > 0x02 && (*esi_1000 == 0x2E && (*((word32) esi_1000 + 1) == 0x2E && *((word64) esi_1000.u0 + 2) == 0x2F) || *((word32) edi_199 + (esi_1000 - 0x03)) == 0x2F && (Mem188[(esi_1000 - 0x02) + edi_199:byte] == 0x2E && Mem188[(esi_1000 - 0x01) + edi_199:byte] == 0x2E)))
							goto l0806EF50;
l0806EED3:
						if (__memchr(esi_1000, 0x2F, edi_199) == 0x00 || *esi_1000 == 0x2F)
							goto l0806EEEA;
						goto l0806EF50;
					}
					if (*esi_1000 != 0x2E)
						goto l0806EED3;
					if (*((word64) esi_1000.u0 + 1) != 0x2E && __memchr(esi_1000, 0x2F, 0x02) == 0x00)
					{
l0806EEEA:
						Eq_2 edi_315;
						Eq_2 esi_290 = ebp_1039->tFFFFFFC0;
						*ebp_1039->tFFFFFFC4 = ebp_1039->tFFFFFFCC;
						if (esi_290 == 0x00)
						{
							word32 ebx_1420;
							Eq_2 eax_323 = _nl_load_locale_from_archive(gs, out ebx_1420, out ebp_1039, out esi_1000);
							edi_1061 = eax_323;
							if (eax_323 != 0x00)
								goto l0806EF16;
							word32 ebx_348;
							Eq_2 eax_346 = _nl_expand_alias(gs, out ebx_348, out ebp_1039);
							ebp_1039->tFFFFFFCC = eax_346;
							if (eax_346 == 0x00)
							{
								ebp_1039->t000C.u0 = 0x10;
								ebp_1039->tFFFFFFC0 = ebx_348 + ~0x0002864F;
								goto l0806F310;
							}
							word32 ebx_375;
							Eq_2 eax_373 = _nl_load_locale_from_archive(gs, out ebx_375, out ebp_1039, out esi_1000);
							edi_1061 = eax_373;
							if (eax_373 != 0x00)
								goto l0806EF16;
							edi_315 = ebp_1039->tFFFFFFCC;
							ebp_1039->t000C.u0 = 0x10;
							ebp_1039->tFFFFFFC0 = ebx_375 + ~0x0002864F;
						}
						else
						{
							word32 ebx_1419;
							Eq_2 eax_301 = _nl_expand_alias(gs, out ebx_1419, out ebp_1039);
							ebp_1039->tFFFFFFCC = eax_301;
							edi_315 = eax_301;
						}
						if (edi_315 != 0x00)
							goto l0806F029;
l0806F310:
						edi_315 = *ebp_1039->tFFFFFFC4;
						ebp_1039->tFFFFFFCC = edi_315;
l0806F029:
						word32 ecx_1423;
						word32 edx_1424;
						Eq_2 eax_413 = strlen(edi_315, out ecx_1423, out edx_1424);
						struct Eq_68771 * esp_420 = fp - 0x4C;
						struct Eq_68771 * esi_426 = fp - 0x4C - ((word32) eax_413 + 28 & ~0x0FFF);
						ui32 ecx_427 = (word32) eax_413 + 28 & ~0x0F;
						if (fp - 0x4C != esi_426)
						{
							do
							{
								esp_420 -= 0x1000;
								esp_420->dw0FFC = esp_420->dw0FFC;
							} while (esp_420 != esi_426);
						}
						if ((ecx_427 & 0x0FFF) != 0x00)
						{
							esp_420 -= ecx_427 & 0x0FFF;
							Mem450[esp_420 - 0x04 + (ecx_427 & 0x0FFF):word32] = Mem448[esp_420 - 0x04 + (ecx_427 & 0x0FFF):word32];
						}
						struct Eq_68802 * esp_455 = esp_420 - 0x04;
						esp_455->tFFFFFFFC = (word32) eax_413 + 1;
						esp_455->tFFFFFFF8 = edi_315;
						Mem470[esp_455 + -0x0C:word32] = esp_420 + 0x0F & ~0x0F;
						word32 ecx_1425;
						word32 edx_1426;
						Eq_2 eax_471 = memcpy(esp_455->tFFFFFFF4, esp_455->tFFFFFFF8, esp_455->tFFFFFFFC, out ecx_1425, out edx_1426);
						esp_455->tFFFFFFF8 = ebp_1039 - 0x20;
						esp_455->tFFFFFFF4 = ebp_1039 - 0x24;
						esp_455->tFFFFFFF0 = ebp_1039 - 0x28;
						esp_455->tFFFFFFEC = ebp_1039 - 44;
						esp_455->tFFFFFFE8 = ebp_1039 - 0x30;
						esp_455->tFFFFFFE4 = eax_471;
						ptr32 ebx_506;
						Eq_2 eax_504 = _nl_explode_name(esp_455->tFFFFFFE4, esp_455->tFFFFFFE8, esp_455->tFFFFFFEC, esp_455->tFFFFFFF0, esp_455->tFFFFFFF4, esp_455->tFFFFFFF8, out ebx_506, out ebp_1039, out esi_1000);
						if (eax_504 != ~0x00)
						{
							Eq_2 eax_520 = ebp_1039->t0010;
							esp_455->tFFFFFFFC.u0 = 0x00;
							Eq_2 edx_526 = ebx_506 + ~0x0002871F + (word32) (*((word32) eax_520 + (ebx_506 + ~0x0002872F)));
							Eq_2 eax_527 = ebp_1039->t0010;
							esp_455->tFFFFFFF8 = edx_526;
							esp_455->tFFFFFFF4 = ebp_1039->tFFFFFFD4;
							esp_455->tFFFFFFF0 = ebp_1039->tFFFFFFE0;
							esp_455->tFFFFFFEC = ebp_1039->tFFFFFFDC;
							esp_455->tFFFFFFE8 = ebp_1039->tFFFFFFD8;
							esp_455->tFFFFFFE4 = ebp_1039->tFFFFFFD0;
							esp_455->tFFFFFFE0 = eax_504;
							esp_455->tFFFFFFDC = ebp_1039->t000C;
							esp_455->tFFFFFFD8 = ebp_1039->tFFFFFFC0;
							Eq_2 ecx_530 = ebx_506 + 0x1FA0 + eax_527 * 0x04;
							esp_455->tFFFFFFD4 = ecx_530;
							ebp_1039->tFFFFFFBC = edx_526;
							ebp_1039->tFFFFFFC4 = ecx_530;
							Eq_2 esp_565 = <invalid>;
							Eq_2 edi_562;
							Eq_2 eax_558 = _nl_make_l10nflist(esp_455->tFFFFFFD4, esp_455->tFFFFFFD8, esp_455->tFFFFFFDC, esp_455->tFFFFFFE0, esp_455->tFFFFFFE4, esp_455->tFFFFFFE8, esp_455->tFFFFFFEC, esp_455->tFFFFFFF0, esp_455->tFFFFFFF4, esp_455->tFFFFFFF8, esp_455->tFFFFFFFC, out ebx_1066, out ebp_1039, out edi_562);
							Eq_2 esp_571 = (word32) esp_565 + 48;
							Eq_2 ecx_572 = ebp_1039->tFFFFFFC4;
							Eq_2 edx_573 = ebp_1039->tFFFFFFBC;
							esi_1000 = eax_558;
							if (eax_558 == 0x00)
							{
								((word32) esp_565 + 40)->u0 = 0x01;
								*((word32) esp_565 + 36) = edx_573;
								*((word32) esp_565 + 32) = ebp_1039->tFFFFFFD4;
								*((word32) esp_565 + 28) = ebp_1039->tFFFFFFE0;
								*((word32) esp_565 + 24) = ebp_1039->tFFFFFFDC;
								*((word32) esp_565 + 20) = ebp_1039->tFFFFFFD8;
								*((word32) esp_565 + 16) = ebp_1039->tFFFFFFD0;
								*((word32) esp_565 + 0x0C) = edi_562;
								*((word32) esp_565 + 8) = ebp_1039->t000C;
								*((word32) esp_565 + 4) = ebp_1039->tFFFFFFC0;
								*esp_565 = ecx_572;
								Eq_2 esp_616 = <invalid>;
								Eq_2 eax_609 = _nl_make_l10nflist(*esp_565, *((word32) esp_565 + 4), *((word32) esp_565 + 8), *((word32) esp_565 + 0x0C), *((word32) esp_565 + 16), *((word32) esp_565 + 20), *((word32) esp_565 + 24), *((word32) esp_565 + 28), *((word32) esp_565 + 32), *((word32) esp_565 + 36), *((word32) esp_565 + 40), out ebx_1066, out ebp_1039, out edi_562);
								esp_571 = (word32) esp_616 + 48;
								esi_1000 = eax_609;
								if (eax_609 == 0x00)
									goto l0806F3A0;
							}
							if ((edi_562 & 0x01) != 0x00)
							{
								struct Eq_69145 * esp_633 = esp_571 - 0x0C;
								esp_633->tFFFFFFFC = ebp_1039->tFFFFFFE0;
								word32 edx_1428;
								word32 ecx_1427;
								free(gs, esp_633->tFFFFFFF8, esp_633->tFFFFFFFC, out ecx_1427, out edx_1428);
								esp_571 = (char *) &esp_633->tFFFFFFFC + 20;
							}
							if (*((word64) esi_1000.u0 + 4) == 0x00)
							{
								struct Eq_69173 * esp_665 = esp_571 - 0x08;
								esp_665->tFFFFFFFC = ebp_1039->t0010;
								esp_665->tFFFFFFF8 = esi_1000;
								word32 edi_1429;
								_nl_load_locale(gs, esp_665->tFFFFFFF8, esp_665->tFFFFFFFC, out ebx_1066, out ebp_1039, out esi_1000, out edi_1429);
							}
							edi_1061 = *((word64) esi_1000.u0 + 8);
							if (edi_1061 == 0x00)
							{
								Eq_2 edx_694 = *((word64) esi_1000.u0 + 16);
								if (edx_694 != 0x00)
								{
									word32 eax_698 = esi_1000 + 0x10;
									do
									{
										if (*((word32) edx_694 + 4) == 0x00)
										{
											struct Eq_69612 * esp_706 = esp_571 - 0x08;
											esp_706->tFFFFFFFC = ebp_1039->t0010;
											esp_706->tFFFFFFF8 = edx_694;
											ebp_1039->tFFFFFFC4 = eax_698;
											_nl_load_locale(gs, esp_706->tFFFFFFF8, esp_706->tFFFFFFFC, out ebx_1066, out ebp_1039, out esi_1000, out edi_1061);
											eax_698 = ebp_1039->tFFFFFFC4;
										}
										Eq_2 edx_734 = *eax_698;
										Eq_2 ecx_735 = *((word32) edx_734 + 8);
										if (ecx_735 != 0x00)
										{
											*((word64) esi_1000.u0 + 16) = edx_734;
											edi_1061 = ecx_735;
											esi_1000 = edx_734;
											goto l0806F122;
										}
										eax_698 += 0x04;
										edx_694 = *eax_698;
									} while (edx_694 != 0x00);
								}
								((word64) esi_1000.u0 + 16)->u0 = 0x00;
l0806EF16:
								ebx_1066 = ebp_1039->dwFFFFFFE4 ^ gs->dw0014;
								if (ebx_1066 == null)
								{
									struct Eq_68666 * esp_1163 = ebp_1039 - 0x0C;
									Eq_2 esi_1166 = esp_1163->t0004;
									Eq_2 edi_1168 = esp_1163->t0008;
									struct Eq_67836 * ebp_1170 = esp_1163->ptr000C;
									ebxOut = esp_1163->ptr0000;
									ebpOut = ebp_1170;
									esiOut = esi_1166;
									ediOut = edi_1168;
									return edi_1061;
								}
								word32 ecx_1421;
								word32 edx_1422;
								__stack_chk_fail(out ecx_1421, out edx_1422);
								esp_1122.u0 = <invalid>;
l0806F489:
								struct Eq_69242 * esp_1130 = esp_1122 - 4;
								esp_1130->ptr0000 = (char *) ebx_1066 - 0x00028660;
								esp_1130->dwFFFFFFFC = 0x011E;
								esp_1130->ptrFFFFFFF8 = (char *) ebx_1066 - 165515;
								esp_1130->ptrFFFFFFF4 = (char *) ebx_1066 - 165502;
								word32 edx_1431;
								word32 ecx_1430;
								__assert_fail(out ecx_1430, out edx_1431);
								Eq_2 eax_1158 = _nl_remove_locale(gs, dwArg04, dwArg08);
								ebxOut = ebx_1066;
								ebpOut = ebp_1039;
								esiOut = esi_1000;
								ediOut = edi_1061;
								return eax_1158;
							}
l0806F122:
							esp_1122 = esp_571;
							if (ebp_1039->tFFFFFFDC == 0x00)
							{
l0806F243:
								if (*edi_1061.u0 == 0x00)
								{
									Eq_2 eax_1015;
									struct Eq_69492 * esp_996 = esp_1122 - 0x08;
									esp_996->tFFFFFFFC.u0 = 0x2F;
									esp_996->tFFFFFFF8 = *esi_1000.u0;
									struct Eq_48850 * eax_1004 = rindex(esp_996->tFFFFFFF8, esp_996->tFFFFFFFC);
									Eq_2 edx_1013 = eax_1004 - 0x01;
									if (eax_1004->bFFFFFFFE != 0x2F)
									{
										do
											--edx_1013;
										while (*((word32) edx_1013 - 1) != 0x2F);
										eax_1015 = eax_1004 - edx_1013;
									}
									else
										eax_1015.u0 = 0x01;
									esp_996->tFFFFFFFC = eax_1015;
									esp_996->tFFFFFFF8 = edx_1013;
									*edi_1061.u0 = __strndup(gs, esp_996->tFFFFFFF8, esp_996->tFFFFFFFC, out ebp_1039);
								}
								Eq_2 eax_1054 = ebp_1039->tFFFFFFD4;
								if (eax_1054 != 0x00)
								{
									struct Eq_69531 * esp_1063 = esp_1122 - 0x04;
									esp_1063->tFFFFFFFC = ebx_1066 - 0xC0;
									esp_1063->tFFFFFFF8 = (char *) ebx_1066 - 0x0002A560;
									esp_1063->tFFFFFFF4 = eax_1054;
									word32 ecx_1436;
									int32 eax_1077 = __strcasecmp_l(esp_1063->tFFFFFFF4, esp_1063->tFFFFFFF8, esp_1063->tFFFFFFFC, out ecx_1436);
									edi_1061 = *((word64) esi_1000.u0 + 8);
									if (eax_1077 == 0x00)
										((word64) edi_1061.u0 + 28)->u0 = 0x01;
								}
								else
									edi_1061 = *((word64) esi_1000.u0 + 8);
								Eq_2 eax_1092 = *((word64) edi_1061.u0 + 24);
								if (eax_1092 <= ~0x02)
									*((word64) edi_1061.u0 + 24) = (word32) eax_1092 + 1;
								goto l0806EF16;
							}
							edi_1061 = *((word64) edi_1061.u0 + ((ebx_1066->aFFFD79C0)[ebp_1039->t0010] * 0x04 + 36));
							if (edi_1061 == 0x00)
								goto l0806F489;
							struct Eq_69270 * esp_775 = esp_571 - 0x0C;
							esp_775->tFFFFFFFC = edi_1061;
							word32 ecx_1432;
							word32 edx_1433;
							Eq_2 eax_779 = strlen(esp_775->tFFFFFFFC, out ecx_1432, out edx_1433);
							struct Eq_69286 * esp_786 = (char *) &esp_775->tFFFFFFFC + 16;
							struct Eq_69286 * ecx_791 = (char *) &esp_775->tFFFFFFFC + 16 - ((word32) eax_779 + 30 & ~0x0FFF);
							ui32 edx_792 = (word32) eax_779 + 30 & ~0x0F;
							if ((char *) &esp_775->tFFFFFFFC + 16 != ecx_791)
							{
								do
								{
									esp_786 -= 0x1000;
									esp_786->dw0FFC = esp_786->dw0FFC;
								} while (esp_786 != ecx_791);
							}
							if ((edx_792 & 0x0FFF) != 0x00)
							{
								esp_786 -= edx_792 & 0x0FFF;
								(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_786 - 0x04)[(edx_792 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_786 - 0x04)[(edx_792 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
							}
							Eq_69315 eax_819 = (char *) esp_786 + 0x0F;
							ebp_1039->tFFFFFFC4 = eax_819 & ~0x0F;
							strip(eax_819 & ~0x0F, edi_1061);
							Eq_2 edx_838 = ebp_1039->tFFFFFFDC;
							struct Eq_69330 * esp_839 = esp_786 - 0x0C;
							esp_839->tFFFFFFFC = edx_838;
							ebp_1039->tFFFFFFC0 = edx_838;
							word32 ecx_1434;
							word32 edx_1435;
							Eq_2 eax_844 = strlen(esp_839->tFFFFFFFC, out ecx_1434, out edx_1435);
							struct Eq_69349 * esp_851 = (char *) &esp_839->tFFFFFFFC + 16;
							struct Eq_69349 * edx_856 = (char *) &esp_839->tFFFFFFFC + 16 - ((word32) eax_844 + 30 & ~0x0FFF);
							ui32 ecx_857 = (word32) eax_844 + 30 & ~0x0F;
							Eq_2 edx_859 = ebp_1039->tFFFFFFC0;
							if ((char *) &esp_839->tFFFFFFFC + 16 != edx_856)
							{
								do
								{
									esp_851 -= 0x1000;
									esp_851->dw0FFC = esp_851->dw0FFC;
								} while (esp_851 != edx_856);
							}
							if ((ecx_857 & 0x0FFF) != 0x00)
							{
								esp_851 -= ecx_857 & 0x0FFF;
								(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_851 - 0x04)[(ecx_857 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_851 - 0x04)[(ecx_857 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
							}
							Eq_69400 edi_885 = (char *) esp_851 + 0x0F;
							strip(edi_885 & ~0x0F, edx_859);
							Eq_154280 edx_907[] = ebx_1066->ptrFFFFFF7C;
							Eq_2 eax_911 = ebp_1039->tFFFFFFC4;
							do
							{
								eax_911 = (word32) eax_911 + 1;
								byte cl_926 = edx_907[(int32) *((word32) eax_911 - 1)].b0000;
								*((word32) eax_911 - 1) = cl_926;
							} while (cl_926 != 0x00);
							struct Eq_69442 * eax_932 = edi_885 & ~0x0F;
							do
							{
								++eax_932;
								byte cl_941 = edx_907[(int32) eax_932->bFFFFFFFF].b0000;
								eax_932->bFFFFFFFF = cl_941;
							} while (cl_941 != 0x00);
							struct Eq_69459 * esp_948 = esp_851 - 0x08;
							esp_948->tFFFFFFFC = ebp_1039->tFFFFFFC4;
							esp_948->tFFFFFFF8 = edi_885 & ~0x0F;
							esp_1122 = (char *) &esp_948->tFFFFFFFC + 0x0C;
							if (__gconv_compare_alias(gs, esp_948->tFFFFFFF8, esp_948->tFFFFFFFC, out ebx_1066, out ebp_1039, out esi_1000) == 0x00)
							{
								edi_1061 = *((word64) esi_1000.u0 + 8);
								goto l0806F243;
							}
						}
l0806F3A0:
						edi_1061.u0 = 0x00;
						goto l0806EF16;
					}
				}
l0806EF50:
				gs->tFFFFFFE0.u0 = 22;
				edi_1061.u0 = 0x00;
				goto l0806EF16;
			}
		}
		*dwArg10 = (union Eq_2 *) 134892338;
		edi_1061 = *((char *) g_a80CE100 + dwArg0C * 0x04);
		goto l0806EF16;
	}
	Eq_2 eax_100;
	Eq_2 eax_38 = getenv(0x080A5969);
	Eq_2 dwLoc38_1183 = eax_38;
	if (eax_38 == 0x00 || *eax_38 == 0x00)
	{
		word32 eax_63 = getenv(0x080A58E0<p32> + CONVERT(Mem46[0x080A58D0<p32> + dwArg0C:byte], byte, word32));
		dwLoc38_1183 = eax_63;
		if (eax_63 == 0x00 || *eax_63 == 0x00)
		{
			eax_100 = getenv(0x080A5970);
			dwLoc38_1183 = eax_100;
			if (eax_100 == 0x00)
				goto l0806EFE3;
l0806EF89:
			if (*eax_100 != 0x00)
			{
				esi_1000 = dwLoc38_1183;
				goto l0806EE54;
			}
l0806EFE3:
			esi_1000.u0 = 134892338;
			goto l0806EE54;
		}
	}
	eax_100 = dwLoc38_1183;
	goto l0806EF89;
}

// 0806F4B0: Register ui32 _nl_remove_locale(Register (ptr32 Eq_9) gs, Stack ui32 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _nl_find_locale
ui32 _nl_remove_locale(struct Eq_9 * gs, ui32 dwArg04, Eq_2 dwArg08)
{
	Eq_2 v7_11 = *((word32) dwArg08 + 24) - 0x01;
	*((word32) dwArg08 + 24) = v7_11;
	if (v7_11 != 0x00)
		return eax;
	if (*((word32) dwArg08 + 0x0C) != 0x02)
	{
		struct Eq_69708 * eax_19 = *((char *) g_a80CFFA0 + dwArg04 * 0x04);
		if (dwArg08 != eax_19->t0008)
		{
			do
				eax_19 = eax_19->ptr000C;
			while (eax_19->t0008 != dwArg08);
		}
		eax_19->dw0004 = 0x00;
		eax_19->t0008.u0 = 0x00;
	}
	return _nl_unload_locale(gs, dwArg08);
}

// 0806F510: Register Eq_2 _nl_intern_locale_data(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_load_locale
//      _nl_load_locale_from_archive
Eq_2 _nl_intern_locale_data(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	if (dwArg0C > 0x07)
	{
		ui32 edx_23 = *dwArg08;
		ui32 eax_24 = 0x20051017;
		if (dwArg04 != 0x03)
		{
			eax_24 = dwArg04 ^ 0x20031115;
			if (dwArg04 == 0x00)
				eax_24 = 0x20090720;
		}
		if (edx_23 == eax_24)
		{
			uint32 edi_40 = *((word32) dwArg08 + 4);
			if (edi_40 >= g_a80A6060[dwArg04 * 0x04])
			{
				Eq_2 eax_45 = edi_40 * 0x04 + 0x08;
				if (eax_45 < dwArg0C)
				{
					Eq_2 ebp_73;
					Eq_2 ebx_74;
					Eq_2 edi_76;
					Eq_2 esi_78;
					word32 edx_364;
					word32 ecx_363;
					Eq_2 eax_72 = __libc_malloc(gs, dwLoc40, (word32) eax_45 + 28, out ecx_363, out edx_364, out ebx_74, out ebp_73, out esi_78, out edi_76);
					if (eax_72 != 0x00)
					{
						*((word32) eax_72 + 4) = ebp_73;
						*((word32) eax_72 + 20) = 0x00;
						*((word32) eax_72 + 8) = dwArg0C;
						*((word32) eax_72 + 16) = 0x00;
						((word32) eax_72 + 24)->u0 = 0x00;
						((word32) eax_72 + 28)->u0 = 0x00;
						*((word32) eax_72 + 32) = edi_76;
						if (edi_76 != 0x00)
						{
							Eq_2 ecx_177 = *((word32) ebp_73 + 8);
							if (ecx_177 <= dwArg0C)
							{
								Eq_2 edi_101 = esi_78 * 0x04;
								Eq_2 edx_103 = 0x00;
								do
								{
									byte cl_149 = (byte) ecx_177;
									if (esi_78 <= 0x0C)
									{
										word32 edi_214 = (ebx_74 + ~0x000285DF)[esi_78 * 0x04] + ebx_74;
										word32 edx_216;
										Eq_2 eax_217;
										word32 ecx_218;
										edi_214();
										ebxOut = ebx_74;
										ebpOut = esi_78 * 0x04;
										esiOut = esi_78;
										ediOut = edi_214;
										return eax_217;
									}
									if (esi_78 != 0x00)
									{
										word32 ecx_367;
										word32 edx_368;
										__assert_fail(out ecx_367, out edx_368);
										word32 ebp_370;
										word32 ebx_369;
										word32 esi_371;
										word32 edi_372;
										Eq_2 eax_139 = _nl_load_locale(gs, dwArg04, ebp_73, out ebx_369, out ebp_370, out esi_371, out edi_372);
										ebxOut = ebx_74;
										ebpOut = ebp_73;
										esiOut = esi_78;
										ediOut = edi_101;
										return eax_139;
									}
									if (edx_103 <= 0x55)
									{
										edi_101 = *((word32) ebx_74 + (esi_78 * 0x04 - 6400));
										if (*((word32) edi_101 + edx_103 * 0x04) != 0x05)
											goto l0806F639;
										if ((cl_149 & 0x03) != 0x00)
											break;
										edi_101 = *((word32) eax_72 + 4);
										(eax_72 + 0x24)[edx_103 * 0x04] = Mem145[edi_101 + ecx_177:word32];
									}
									else
									{
l0806F639:
										(eax_72 + 0x24)[edx_103 * 0x04] = ecx_177 + Mem145[eax_72 + 0x04:word32];
									}
									edx_103 = (word32) edx_103 + 1;
									if (*((word32) eax_72 + 32) <= edx_103)
										goto l0806F593;
									ecx_177 = *((word32) ebp_73 + (edx_103 * 0x04 + 8));
								} while (*((word32) eax_72 + 8) >= ecx_177);
							}
							word32 ecx_365;
							word32 edx_366;
							free(gs, dwLoc40, eax_72, out ecx_365, out edx_366);
							gs->tFFFFFFE0.u0 = 22;
							ebxOut = esi;
							ebpOut = dwArg00;
							esiOut = edi;
							ediOut = ebp;
							return 0x00;
						}
					}
l0806F593:
					ebxOut = ebx;
					ebpOut = ebp;
					esiOut = esi;
					ediOut = edi;
					return eax_72;
				}
			}
		}
	}
	gs->tFFFFFFE0.u0 = 22;
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return 0x00;
}

// 0806F770: Register ui32 _nl_load_locale(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ebxOut, Register out (ptr32 Eq_69192) ebpOut, Register out Eq_69193 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_locale
//      _nl_intern_locale_data
ui32 _nl_load_locale(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ebxOut, struct Eq_69192 & ebpOut, union Eq_69193 & esiOut, union Eq_2 & ediOut)
{
	*((word32) dwArg04 + 8) = 0x00;
	struct Eq_69192 * ebp_302 = fp - 4;
	Eq_69193 esi_155 = 0x00;
	word32 ecx_658;
	word32 edx_659;
	Eq_2 eax_35 = __open_nocancel(gs, *dwArg04, 0x00080000, dwLocB4, out ecx_658, out edx_659);
	if (eax_35 < 0x00)
	{
l0806F873:
		ui32 eax_506 = ebp_302->dwFFFFFFE4 ^ gs->dw0014;
		if (eax_506 != 0x00)
		{
			word32 ecx_677;
			word32 edx_678;
			__stack_chk_fail(out ecx_677, out edx_678);
			ui32 eax_516 = _nl_unload_locale(gs, dwArg04);
			ebxOut = ebx;
			ebpOut = ebp_302;
			esiOut = esi_155;
			ediOut = edi;
			return eax_516;
		}
		else
		{
			struct Eq_70161 * esp_523 = ebp_302 - 0x0C;
			Eq_69193 esi_526 = esp_523->t0004;
			Eq_2 edi_528 = esp_523->t0008;
			struct Eq_69192 * ebp_530 = esp_523->ptr000C;
			ebxOut = esp_523->t0000;
			ebpOut = ebp_530;
			esiOut = esi_526;
			ediOut = edi_528;
			return eax_506;
		}
	}
	edi = eax_35;
	ptr32 esp_253 = fp - 0xAC;
	word32 ecx_660;
	word32 edx_661;
	if (__fxstat64(gs, eax_35, fp - 0x80, out ecx_660, out edx_661) >= 0x00)
	{
		if ((dwLoc70 & 0xF000) != 0x4000)
		{
l0806F7F8:
			word32 edx_399;
			Eq_2 eax_391;
			struct Eq_70038 * esp_261 = esp_253 - 0x08;
			esp_261->tFFFFFFFC.u0 = 0x00;
			esp_261->tFFFFFFF8 = edi;
			esp_261->tFFFFFFF4.u0 = 0x02;
			esp_261->dwFFFFFFF0 = 0x01;
			esp_261->tFFFFFFEC = dwLoc54;
			esp_261->tFFFFFFE8.u0 = 0x00;
			word32 ecx_666;
			word32 edx_667;
			Eq_2 eax_281 = mmap(gs, esp_261->tFFFFFFE8, esp_261->tFFFFFFEC, esp_261->dwFFFFFFF0, esp_261->tFFFFFFF4, esp_261->tFFFFFFF8, esp_261->tFFFFFFFC, out ecx_666, out edx_667);
			&esi_155.u0->t0000 = ~0x1F;
			esp_253 = (char *) &esp_261->t0000 + 8;
			ebx = eax_281;
			if (eax_281 != ~0x00)
			{
				esp_261->tFFFFFFF8 = edi;
				word32 edx_668;
				__close_nocancel(gs, esp_261->tFFFFFFF8, out edx_668);
				if (eax_281 == 0x00)
					goto l0806F873;
				esp_261->t0000 = dwLoc54;
				esp_261->tFFFFFFFC = eax_281;
				esp_261->tFFFFFFF8 = dwArg08;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 ebx_671;
				word32 ebp_672;
				word32 esi_673;
				word32 edi_674;
				eax_391 = _nl_intern_locale_data(gs, stackArg0, stackArg4, dwArg04, dwArg08, out ebx_671, out ebp_672, out esi_673, out edi_674);
				if (eax_391 == 0x00)
				{
					esp_261->tFFFFFFFC = dwLoc54;
					esp_261->tFFFFFFF8 = eax_281;
					word32 ecx_675;
					word32 edx_676;
					__munmap(eax_281, gs, esp_261->tFFFFFFF8, esp_261->tFFFFFFFC, out ecx_675, out edx_676, out ebx);
					goto l0806F873;
				}
				edx_399 = 0x01;
l0806F85A:
				Eq_2 ecx_493 = ebp_302->tFFFFFF70;
				*eax_391 = 0x00;
				*((word32) eax_391 + 0x0C) = edx_399;
				*((word32) ecx_493 + 8) = eax_391;
				((word32) ecx_493 + 4)->u0 = 0x01;
				goto l0806F873;
			}
			if (gs->tFFFFFFE0 == 0x26)
			{
				esp_261->tFFFFFFF8 = dwLoc54;
				word32 ecx_679;
				word32 edx_680;
				Eq_2 eax_301 = __libc_malloc(gs, esp_261->tFFFFFFF4, esp_261->tFFFFFFF8, out ecx_679, out edx_680, out ebx, out ebp_302, out esi_155, out edi);
				ebp_302->tFFFFFF64 = eax_301;
				esp_253 = (char *) &esp_261->t0000 + 8;
				if (eax_301 != 0x00)
				{
					Eq_2 ecx_317 = ebp_302->tFFFFFF68;
					ebx = ecx_317;
					if (ecx_317 > 0x00)
					{
						ebp_302->tFFFFFF68 = edi;
						Eq_2 edi_322 = eax_301;
						do
						{
							struct Eq_70270 * esp_324 = esp_253 - 0x04;
							esp_324->tFFFFFFFC = ebx;
							esp_324->tFFFFFFF8 = edi_322;
							esp_324->tFFFFFFF4 = ebp_302->tFFFFFF68;
							word32 ecx_688;
							Eq_2 eax_337 = __read_nocancel(gs, esp_324->tFFFFFFF4, esp_324->tFFFFFFF8, esp_324->tFFFFFFFC, out ecx_688);
							if (eax_337 <= 0x00)
							{
								esp_324->tFFFFFFF4 = ebp_302->tFFFFFF64;
								ebx = ebp_302->tFFFFFF74;
								edi = ebp_302->tFFFFFF68;
								ebp_302->tFFFFFF70 = eax_337;
								word32 ecx_690;
								word32 edx_691;
								free(gs, esp_324->tFFFFFFF0, esp_324->tFFFFFFF4, out ecx_690, out edx_691);
								esp_253 = (char *) &esp_324->tFFFFFFFC + 0x0C;
								if (ebp_302->tFFFFFF70 == 0x00)
									(gs->*esi_155.u0).t0000 = 22;
								goto l0806F940;
							}
							ebx -= eax_337;
							edi_322 += eax_337;
						} while (ebx > 0x00);
						edi = ebp_302->tFFFFFF68;
					}
					(gs->*esi_155.u0).t0000 = ebp_302->dwFFFFFF6C;
					struct Eq_70221 * esp_356 = esp_253 - 0x0C;
					esp_356->tFFFFFFFC = edi;
					word32 edx_681;
					__close_nocancel(gs, esp_356->tFFFFFFFC, out edx_681);
					esp_356->dw0004 = ebp_302->dwFFFFFFB0;
					esp_356->t0000 = ebp_302->tFFFFFF64;
					esp_356->tFFFFFFFC = ebp_302->t000C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 ebx_684;
					word32 ebp_685;
					word32 esi_686;
					word32 edi_687;
					eax_391 = _nl_intern_locale_data(gs, stackArg0, stackArg4, dwArg04, dwArg08, out ebx_684, out ebp_685, out esi_686, out edi_687);
					if (eax_391 != 0x00)
					{
						edx_399 = 0x00;
						goto l0806F85A;
					}
					goto l0806F873;
				}
			}
			goto l0806F940;
		}
		word32 edx_663;
		__close_nocancel(gs, eax_35, out edx_663);
		Eq_2 ebx_83 = *dwArg04;
		word32 ecx_664;
		word32 edx_665;
		Eq_2 eax_85 = strlen(ebx_83, out ecx_664, out edx_665);
		Eq_70017 edi_95 = (word32) *((word32) dwArg08 + 0x080A58C0);
		ui32 edx_97 = (word32) edi_95 + ((word32) eax_85 + 33);
		struct Eq_70026 * esp_105 = fp - 0xAC;
		struct Eq_70026 * esi_100 = fp - 0xAC - (edx_97 & ~0x0FFF);
		if (fp - 0xAC != esi_100)
		{
			do
			{
				esp_105 -= 0x1000;
				esp_105->dw0FFC = esp_105->dw0FFC;
			} while (esp_105 != esi_100);
		}
		int32 ecx_116 = edx_97 & ~0x0F & 0x0FFF;
		if (ecx_116 != 0x00)
		{
			esp_105 -= ecx_116;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_105 - 0x04)[ecx_116 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_105 - 0x04)[ecx_116 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_70317 * esp_134 = esp_105 - 0x04;
		esp_134->tFFFFFFFC = eax_85;
		esp_134->tFFFFFFF8 = ebx_83;
		Eq_70326 edx_128 = (char *) esp_105 + 0x0F;
		esp_134->tFFFFFFF4 = edx_128 & ~0x0F;
		esi_155 = 0x080A58E0<p32> + CONVERT(Mem153[0x080A58D0<p32> + dwArg08:byte], byte, word32);
		word32 edx_689;
		Eq_2 eax_156 = __mempcpy(esp_134->tFFFFFFF4, esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out edx_689);
		*eax_156 = 0x5359532F;
		((word32) eax_156 + 4)->u0 = 0x5F;
		ebx.u0 = 0x080CE000;
		byte dl_199 = SLICE(edi_95 + 0x01, byte, 0);
		if (edi_95 < 0x03)
		{
			if (edi_95 != 0x01)
			{
				ebx = (word32) esi_155.u0->t0000;
				*((word32) eax_156 + 5) = (byte) ebx;
				if ((dl_199 & 0x02) != 0x00)
					Mem205[eax_156 + 0x03 + (edi_95 + 0x01):word16] = Mem198[esi_155 - 0x02 + (edi_95 + 0x01):word16];
			}
		}
		else
		{
			*((word32) eax_156 + 5) = esi_155.u0->t0000;
			ebx = Mem176[esi_155 - 0x04 + (edi_95 + 0x01):word32];
			Mem178[eax_156 + 0x01 + (edi_95 + 0x01):word32] = ebx;
			word32 edi_175 = eax_156 + 0x09 & ~0x03;
			word32 ecx_179 = eax_156 + 0x05 - edi_175;
			esi_155 -= ecx_179;
			word32 ecx_182;
			for (ecx_182 = ecx_179 + (edi_95 + 0x01) >>u 0x02; ecx_182 != 0x00; --ecx_182)
			{
				edi_175->dw0000 = (word32) esi_155.u0->t0000;
				esi_155 += 4;
				edi_175 += 4;
			}
		}
		esp_134->tFFFFFFF8.u0 = 0x00080000;
		esp_134->tFFFFFFF4 = edx_128 & ~0x0F;
		word32 ecx_692;
		word32 edx_693;
		Eq_2 eax_225 = __open_nocancel(gs, esp_134->tFFFFFFF4, esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out ecx_692, out edx_693);
		edi = eax_225;
		if (eax_225 < 0x00)
			goto l0806F873;
		esp_134->tFFFFFFFC = fp - 0x80;
		esp_134->tFFFFFFF8 = eax_225;
		esp_134->tFFFFFFF4.u0 = 0x03;
		esp_253 = (char *) &esp_134->tFFFFFFFC + 8;
		word32 ecx_694;
		word32 edx_695;
		if (__fxstat64(gs, esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out ecx_694, out edx_695) >= 0x00)
			goto l0806F7F8;
	}
l0806F940:
	struct Eq_69984 * esp_426 = esp_253 - 0x0C;
	esp_426->tFFFFFFFC = edi;
	word32 edx_662;
	__close_nocancel(gs, esp_426->tFFFFFFFC, out edx_662);
	goto l0806F873;
}

// 0806FB00: Register Eq_2 _nl_unload_locale(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _nl_remove_locale
//      _nl_load_locale
//      free_category
Eq_2 _nl_unload_locale(struct Eq_9 * gs, Eq_2 dwArg04)
{
	<anonymous> * eax_14 = *((word32) dwArg04 + 16);
	if (eax_14 != null)
		eax_14();
	ptr32 esp_32 = fp - 0x0C;
	word32 eax_28 = *((word32) dwArg04 + 0x0C);
	if (eax_28 != 0x00)
	{
		if (eax_28 == 0x01)
		{
			word32 edx_149;
			word32 ebx_150;
			word32 ecx_148;
			__munmap(0x080CE000, gs, *((word32) dwArg04 + 4), *((word32) dwArg04 + 8), out ecx_148, out edx_149, out ebx_150);
			eax_28 = (word32) *((word32) dwArg04 + 0x0C);
			esp_32 = fp - 0x08;
		}
	}
	else
	{
		word32 ecx_146;
		word32 edx_147;
		free(gs, dwLoc20, *((word32) dwArg04 + 4), out ecx_146, out edx_147);
		eax_28 = (word32) *((word32) dwArg04 + 0x0C);
		esp_32 = fp - 0x08;
	}
	if (eax_28 != 0x02)
	{
		struct Eq_70627 * esp_78 = esp_32 - 0x0C;
		esp_78->tFFFFFFFC = *dwArg04;
		word32 ecx_153;
		word32 edx_154;
		free(gs, esp_78->tFFFFFFF8, esp_78->tFFFFFFFC, out ecx_153, out edx_154);
	}
	word32 edx_152;
	word32 ecx_151;
	return free(gs, dwLoc24, dwArg04, out ecx_151, out edx_152);
}

// 0806FB90: void rangecmp()
void rangecmp()
{
}

// 0806FBB0: Register Eq_2 _nl_load_locale_from_archive(Register (ptr32 Eq_9) gs, Register out Eq_2 ebxOut, Register out (ptr32 Eq_68633) ebpOut, Register out Eq_2 esiOut)
// Called from:
//      _nl_find_locale
Eq_2 _nl_load_locale_from_archive(struct Eq_9 * gs, union Eq_2 & ebxOut, struct Eq_68633 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2 esp_1186;
	Eq_2 eax_1177;
	Eq_2 eax_1250;
	struct Eq_70652 * ebx_33;
	struct Eq_68633 * ebp_1014;
	Eq_2 esi_1049;
	Eq_10487 eax_32 = __sysconf(gs, 0x1E, out ebx_33, out ebp_1014, out esi_1049);
	struct Eq_70662 * ebx_1409 = ebx_33->ptr1980;
	ebp_1014->tFFFFFE44 = eax_32;
	Eq_2 esp_39 = <invalid>;
	if (ebx_1409 != null)
	{
		Eq_2 edi_1400 = ebx_1409->t0004;
		if (esi_1049 == edi_1400)
		{
l0806FC2E:
			ebp_1014->ptrFFFFFE38->t0000 = edi_1400;
			eax_1250 = ebx_1409->a0008[ebp_1014->t0008];
			goto l0806FC3D;
		}
		while (true)
		{
			*((word32) esp_39 + 4) = edi_1400;
			*esp_39 = esi_1049;
			word32 edx_1614;
			word32 ecx_1613;
			if (strcmp(*esp_39, *((word32) esp_39 + 4), out ecx_1613, out edx_1614) == 0x00)
				goto l0806FC2E;
			ebx_1409 = ebx_1409->ptr0000;
			if (ebx_1409 == null)
				break;
			edi_1400 = ebx_1409->t0004;
			if (edi_1400 == esi_1049)
				goto l0806FC2E;
		}
	}
	((word32) esp_39 + 4)->u0 = 0x2E;
	*esp_39 = esi_1049;
	word32 ecx_1611;
	word32 edx_1612;
	Eq_2 eax_86 = strchr(*esp_39, *((word32) esp_39 + 4), out ecx_1611, out edx_1612);
	ptr32 esp_1004 = (word32) esp_39 + 16;
	if (eax_86 != 0x00 && (*((word32) eax_86 + 1) & 191) != 0x00)
	{
		((word32) esp_39 + 4)->u0 = 0x40;
		*esp_39 = (word32) eax_86 + 1;
		Eq_2 eax_110 = strchrnul(*esp_39, *((word32) esp_39 + 4));
		ebp_1014->tFFFFFE50 = eax_110;
		Eq_2 eax_122 = eax_110 - ((word32) eax_86 + 1);
		*((word32) esp_39 + 4) = eax_122;
		*esp_39 = (word32) eax_86 + 1;
		ebp_1014->tFFFFFE54 = eax_122;
		Eq_2 eax_132 = _nl_normalize_codeset(*esp_39, *((word32) esp_39 + 4));
		if (eax_132 == 0x00)
			goto l0806FE3E;
		Eq_2 ebx_141 = ebp_1014->tFFFFFE54;
		ebp_1014->tFFFFFE54 = eax_132;
		*((word32) esp_39 + 8) = ebx_141;
		*((word32) esp_39 + 4) = (word32) eax_86 + 1;
		*esp_39 = eax_132;
		word32 ecx_1654;
		word32 eax_151 = strncmp(*esp_39, *((word32) esp_39 + 4), *((word32) esp_39 + 8), out ecx_1654);
		ptr32 esp_158 = (word32) esp_39 + 16;
		Eq_2 edx_159 = ebp_1014->tFFFFFE54;
		if (eax_151 != 0x00 || Mem150[edx_159 + ebx_141:byte] != 0x00)
		{
			ebp_1014->tFFFFFE54 = edx_159;
			*esp_39 = edx_159;
			word32 ecx_1655;
			word32 edx_1656;
			Eq_2 eax_173 = strlen(*esp_39, out ecx_1655, out edx_1656);
			*esp_39 = ebp_1014->tFFFFFE50;
			ebp_1014->tFFFFFE48 = eax_173;
			word32 edx_1658;
			word32 ecx_1657;
			Eq_2 eax_187 = strlen(*esp_39, out ecx_1657, out edx_1658);
			ebp_1014->tFFFFFE4C = (word32) eax_187 + 1;
			Eq_2 ecx_198 = (word32) eax_86 + 1 - esi_1049;
			word32 eax_202 = eax_187 + 0x1C + (ecx_198 + eax_173);
			struct Eq_72524 * esp_196 = (word32) esp_39 + 16;
			struct Eq_72524 * edx_206 = (word32) esp_39 + 16 - (eax_202 & ~0x0FFF);
			Eq_2 edx_209 = ebp_1014->tFFFFFE54;
			if ((word32) esp_39 + 16 != edx_206)
			{
				do
				{
					esp_196 -= 0x1000;
					esp_196->dw0FFC = esp_196->dw0FFC;
				} while (esp_196 != edx_206);
			}
			int32 eax_224 = eax_202 & ~0x0F & 0x0FFF;
			if (eax_224 != 0x00)
			{
				esp_196 -= eax_224;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_196 - 0x04)[eax_224 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_196 - 0x04)[eax_224 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			ebp_1014->tFFFFFE54 = edx_209;
			struct Eq_72583 * esp_237 = esp_196 - 0x04;
			esp_237->tFFFFFFFC = ecx_198;
			esp_237->tFFFFFFF8 = esi_1049;
			Eq_72592 eax_236 = (char *) esp_196 + 0x0F;
			esp_237->tFFFFFFF4 = eax_236 & ~0x0F;
			word32 edx_1661;
			Eq_2 eax_264 = __mempcpy(esp_237->tFFFFFFF4, esp_237->tFFFFFFF8, esp_237->tFFFFFFFC, out edx_1661);
			Eq_2 edx_272 = ebp_1014->tFFFFFE54;
			esp_237->tFFFFFFFC = ebp_1014->tFFFFFE48;
			esp_237->tFFFFFFF8 = edx_272;
			esp_237->tFFFFFFF4 = eax_264;
			word32 edx_1662;
			Eq_2 eax_282 = __mempcpy(esp_237->tFFFFFFF4, esp_237->tFFFFFFF8, esp_237->tFFFFFFFC, out edx_1662);
			esp_237->tFFFFFFFC = ebp_1014->tFFFFFE4C;
			esp_237->tFFFFFFF8 = ebp_1014->tFFFFFE50;
			esp_237->tFFFFFFF4 = eax_282;
			word32 edx_1664;
			word32 ecx_1663;
			memcpy(esp_237->tFFFFFFF4, esp_237->tFFFFFFF8, esp_237->tFFFFFFFC, out ecx_1663, out edx_1664);
			esi_1049 = eax_236 & ~0x0F;
			edx_159 = ebp_1014->tFFFFFE54;
			esp_158 = (char *) &esp_237->tFFFFFFFC + 8;
		}
		struct Eq_72544 * esp_312 = esp_158 - 0x0C;
		esp_312->tFFFFFFFC = edx_159;
		word32 edx_1660;
		word32 ecx_1659;
		free(gs, esp_312->tFFFFFFF8, esp_312->tFFFFFFFC, out ecx_1659, out edx_1660);
		esp_1004 = (char *) &esp_312->tFFFFFFFC + 20;
	}
	struct Eq_70736 * eax_339 = ebp_1014->ptrFFFFFE40;
	if (eax_339->t1A10 != 0x00)
	{
		Eq_2 eax_592 = eax_339->t1A00;
		ebp_1014->tFFFFFE48 = eax_592;
		if (eax_592 == 0x00)
			goto l0806FE3E;
		goto l0806FC9C;
	}
	struct Eq_70736 * edi_344 = ebp_1014->ptrFFFFFE40;
	struct Eq_70801 * esp_346 = esp_1004 - 0x08;
	esp_346->tFFFFFFFC.u0 = 0x00088000;
	edi_344->t1A10 = &edi_344->t1A00;
	esp_346->tFFFFFFF8 = (char *) edi_344 - 163516;
	word32 ecx_1615;
	word32 edx_1616;
	Eq_2 eax_356 = __open_nocancel(gs, esp_346->tFFFFFFF8, esp_346->tFFFFFFFC, esp_346->t0000, out ecx_1615, out edx_1616);
	ebp_1014->tFFFFFE2C = eax_356;
	if (eax_356 < 0x00)
		goto l0806FE3E;
	esp_346->t0000 = &edi_344->dw19A0;
	esp_346->tFFFFFFFC = eax_356;
	esp_346->tFFFFFFF8.u0 = 0x03;
	esp_1004 = (char *) &esp_346->t0004 + 4;
	word32 ecx_1619;
	word32 edx_1620;
	if (__fxstat64(gs, esp_346->tFFFFFFFC, esp_346->t0000, out ecx_1619, out edx_1620) != ~0x00)
	{
		struct Eq_70736 * ecx_388 = ebp_1014->ptrFFFFFE40;
		Eq_2 edi_392 = ecx_388->t19CC;
		if (0x00 - ecx_388->dw19D0 - (edi_392 > 0x00200000) < 0x00)
			edi_392.u0 = 0x00200000;
		esp_346->t0000.u0 = 0x00;
		esp_346->tFFFFFFFC.u0 = 0x00;
		esp_346->tFFFFFFF8 = ebp_1014->tFFFFFE2C;
		esp_346->tFFFFFFF4.u0 = 0x02;
		esp_346->tFFFFFFF0.u0 = 0x01;
		esp_346->tFFFFFFEC = edi_392;
		esp_346->tFFFFFFE8.u0 = 0x00;
		Eq_2 eax_420 = mmap64(gs, esp_346->tFFFFFFE8, esp_346->tFFFFFFEC, esp_346->tFFFFFFF0, esp_346->tFFFFFFF4, esp_346->tFFFFFFF8, esp_346->tFFFFFFFC, esp_346->t0000);
		ebp_1014->tFFFFFE48 = eax_420;
		esp_1004 = (char *) &esp_346->t0004 + 4;
		if (eax_420 != ~0x00)
		{
			Eq_2 edx_435 = (word32) *((word32) eax_420 + 8) + *((word32) eax_420 + 16) * 0x0C;
			Eq_2 eax_437 = (word32) *((word32) eax_420 + 32) + *((word32) eax_420 + 36) *s 0x6C;
			if (edx_435 >= eax_437)
				eax_437 = edx_435;
			word32 edx_444 = Mem429[eax_420 + 0x18:word32] + Mem429[eax_420 + 0x14:word32];
			if (eax_437 >= edx_444)
				edx_444 = eax_437;
			if (edi_392 >= edx_444)
			{
				struct Eq_70736 * eax_566 = ebp_1014->ptrFFFFFE40;
				if (0x00 - eax_566->dw19D0 - (edi_392 < eax_566->t19CC) < 0x00)
				{
					Eq_2 edx_589 = ebp_1014->tFFFFFE48;
					eax_566->t1A08 = edi_392;
					eax_566->t1A00 = edx_589;
					goto l0806FCA6;
				}
				esp_346->tFFFFFFF8 = ebp_1014->tFFFFFE2C;
				word32 edx_1627;
				__close_nocancel(gs, esp_346->tFFFFFFF8, out edx_1627);
				struct Eq_70736 * eax_583 = ebp_1014->ptrFFFFFE40;
				eax_583->t1A00 = ebp_1014->tFFFFFE48;
				eax_583->t1A08 = edi_392;
				esp_1004 = (char *) &esp_346->t0004 + 4;
l0806FC9C:
				ebp_1014->tFFFFFE2C.u0 = ~0x00;
				goto l0806FCA6;
			}
			ebp_1014->tFFFFFE54 = edx_444;
			esp_346->tFFFFFFFC = edi_392;
			esp_346->tFFFFFFF8 = eax_420;
			word32 ebx_1626;
			word32 edx_1625;
			word32 ecx_1624;
			__munmap(0x00, gs, esp_346->tFFFFFFF8, esp_346->tFFFFFFFC, out ecx_1624, out edx_1625, out ebx_1626);
			struct Eq_70736 * edi_480 = ebp_1014->ptrFFFFFE40;
			Eq_2 edx_482 = ebp_1014->tFFFFFE54;
			esp_1004 = (char *) &esp_346->t0004 + 8;
			if (edi_480->dw19D0 - (edi_480->t19CC < edx_482) >= 0x00)
			{
				Eq_10487 eax_489 = ebp_1014->tFFFFFE44;
				esp_346->t0004.u0 = 0x00;
				esp_346->t0000.u0 = 0x00;
				esp_346->tFFFFFFFC = ebp_1014->tFFFFFE2C;
				esp_346->tFFFFFFF8.u0 = 0x02;
				esp_346->tFFFFFFF4.u0 = 0x01;
				Eq_2 ebx_497 = (word32) edx_482 + (eax_489 - 0x01) & -eax_489;
				esp_346->tFFFFFFF0 = ebx_497;
				esp_346->tFFFFFFEC.u0 = 0x00;
				Eq_2 eax_511 = mmap64(gs, esp_346->tFFFFFFEC, esp_346->tFFFFFFF0, esp_346->tFFFFFFF4, esp_346->tFFFFFFF8, esp_346->tFFFFFFFC, esp_346->t0000, esp_346->t0004);
				ebp_1014->tFFFFFE48 = eax_511;
				esp_1004 = (char *) &esp_346->t0004 + 8;
				if (eax_511 != ~0x00)
				{
					if (0x00 - edi_480->dw19D0 - (ebx_497 < edi_480->t19CC) >= 0x00)
					{
						esp_346->tFFFFFFFC = ebp_1014->tFFFFFE2C;
						word32 edx_1630;
						__close_nocancel(gs, esp_346->tFFFFFFFC, out edx_1630);
						struct Eq_70736 * eax_541 = ebp_1014->ptrFFFFFE40;
						Eq_2 ecx_542 = ebp_1014->tFFFFFE48;
						eax_541->t1A00 = ecx_542;
						eax_541->t1A08 = ebx_497;
						esp_1004 = (char *) &esp_346->t0004 + 8;
						if (ecx_542 == 0x00)
						{
							eax_1250.u0 = 0x00;
l0806FC3D:
							if ((ebp_1014->dwFFFFFFE4 ^ gs->dw0014) == 0x00)
							{
								struct Eq_70895 * esp_1455 = ebp_1014 - 0x0C;
								Eq_2 esi_1458 = esp_1455->t0004;
								struct Eq_68633 * ebp_1462 = esp_1455->ptr000C;
								ebxOut = esp_1455->t0000;
								ebpOut = ebp_1462;
								esiOut = esi_1458;
								return eax_1250;
							}
							goto l0807070C;
						}
						goto l0806FC9C;
					}
					struct Eq_70736 * eax_552 = ebp_1014->ptrFFFFFE40;
					Eq_2 ecx_553 = ebp_1014->tFFFFFE48;
					eax_552->t1A08 = ebx_497;
					eax_552->t1A00 = ecx_553;
					if (ecx_553 != 0x00)
					{
l0806FCA6:
						struct Eq_71337 * esp_601 = esp_1004 - 0x0C;
						esp_601->tFFFFFFFC = esi_1049;
						word32 ecx_1628;
						word32 edx_1629;
						Eq_2 eax_607 = strlen(esp_601->tFFFFFFFC, out ecx_1628, out edx_1629);
						esp_1004 = (char *) &esp_601->tFFFFFFFC + 16;
						Eq_2 edi_615 = eax_607;
						if (eax_607 != 0x00)
						{
							Eq_2 eax_620 = esi_1049;
							word32 edx_621 = esi_1049 + eax_607;
							do
							{
								eax_620 = (word32) eax_620 + 1;
								edi_615 = (word32) __rol(edi_615, 0x09) + (word32) (*eax_620);
							} while (edx_621 != eax_620);
							if (edi_615 == 0x00)
								edi_615.u0 = ~0x00;
						}
						else
							edi_615.u0 = ~0x00;
						Eq_2 eax_643 = ebp_1014->tFFFFFE48;
						Eq_2 ebx_645 = *((word32) eax_643 + 16);
						ebp_1014->tFFFFFE34 = *((word32) eax_643 + 8);
						if (ebx_645 == 0x00)
						{
l0806FE30:
							if (ebp_1014->tFFFFFE2C < 0x00)
								goto l0806FE3E;
							goto l0806FEF0;
						}
						ebp_1014->tFFFFFE50 = ebx_645;
						ebp_1014->tFFFFFE3C = esi_1049;
						uint32 edx_667 = (uint32) ((uint64) edi_615 % (ebx_645 - 0x02));
						Eq_2 edi_671 = ebp_1014->tFFFFFE50;
						ebp_1014->tFFFFFE54 = edx_667 + 0x01 + (edx_667 + 0x01) * 0x02 << 0x02;
						esi_1049 = (uint32) ((uint64) edi_615 % ebx_645);
						Eq_2 edx_1466 = edx_667 + 0x01;
						while (true)
						{
							struct Eq_71071 * ebx_685 = (word32) ebp_1014->tFFFFFE48 + ((word32) ebp_1014->tFFFFFE34 + esi_1049 * 0x0C);
							Eq_2 ecx_689 = edi_671;
							do
							{
								word32 eax_692 = ebx_685->dw0004;
								if (eax_692 == 0x00)
									goto l0806FE30;
								if (ebx_685->t0000 == edi_615)
								{
									Eq_2 eax_702 = (word32) ebp_1014->tFFFFFE48 + eax_692;
									ebp_1014->tFFFFFE4C = edx_1466;
									struct Eq_71134 * esp_700 = esp_1004 - 0x08;
									esp_700->tFFFFFFFC = eax_702;
									esp_700->tFFFFFFF8 = ebp_1014->tFFFFFE3C;
									ebp_1014->tFFFFFE50 = ecx_689;
									word32 ecx_1622;
									word32 edx_1623;
									Eq_2 eax_713 = strcmp(esp_700->tFFFFFFF8, esp_700->tFFFFFFFC, out ecx_1622, out edx_1623);
									esp_1004 = &esp_700->ptr0004 + 1;
									ecx_689 = ebp_1014->tFFFFFE50;
									edx_1466 = ebp_1014->tFFFFFE4C;
									if (eax_713 == 0x00)
									{
										esi_1049 = ebx_685->t0008;
										ebp_1014->tFFFFFE50 = eax_713;
										if (esi_1049 == 0x00)
											goto l0806FE30;
										Eq_154298 esi_748[] = esi_1049 + Mem744[ebp_1014 + -440:word32];
										ui32 ecx_1399 = 0x00;
										Eq_2 edi_1397 = 0x00;
l0806FDFD:
										ebp_1014->tFFFFFE54 = (word32) edi_1397 + 1;
										ui32 eax_758 = ecx_1399 + 0x01;
										if (ecx_1399 == 0x06)
										{
											ebp_1014->tFFFFFE54 = edi_1397;
l0806FDF5:
											edi_1397 = ebp_1014->tFFFFFE54;
											ecx_1399 = eax_758;
											goto l0806FDFD;
										}
										(ebp_1014 - 220)[edi_1397 * 0x10] = (esi_748 - 0x04)[eax_758 * 0x08];
										word32 ebx_766 = esi_748[eax_758].dw0000;
										(ebp_1014 - 212)[edi_1397].dw0000 = ecx_1399;
										(ebp_1014 - 0xD8)[edi_1397].dw0000 = ebx_766;
										(ebp_1014 - 0xD0)[edi_1397].dw0000 = 0x00;
										if (eax_758 != 0x0D)
											goto l0806FDF5;
										struct Eq_70736 * esi_772 = ebp_1014->ptrFFFFFE40;
										ebp_1014->tFFFFFE4C = edi_1397;
										esp_700->ptr0004 = (char *) esi_772 - 386160;
										esp_700->dw0000 = 0x10;
										esp_700->tFFFFFFFC = (word32) edi_1397 + 1;
										esp_700->tFFFFFFF8 = ebp_1014 - 220;
										ebp_1014->tFFFFFE3C = ebp_1014 - 220;
										qsort();
										Eq_10487 ecx_792 = ebp_1014->tFFFFFE44;
										Eq_2 edi_793 = esi_772->t1A10;
										ebp_1014->tFFFFFE48 = edi_793;
										ebp_1014->tFFFFFE34 = ecx_792 - 0x01;
										ebp_1014->dwFFFFFE20 = ecx_792 - 0x01 & ecx_792;
										ebp_1014->tFFFFFE30 = edi_793;
										esp_1004 = &esp_700->ptr0004 + 1;
										Eq_2 edi_1017 = ebp_1014->tFFFFFE50;
										do
										{
											Eq_2 ebx_1088;
											Eq_2 esi_806 = ebp_1014->tFFFFFE30;
											if (esi_806 != 0x00)
											{
												Eq_2 eax_817 = *((word32) esi_806 + 4);
												Eq_2 ecx_819 = (ebp_1014 - 0xD8)[edi_1017].t0000;
												Eq_2 ebx_820 = (ebp_1014 - 220)[edi_1017].t0000;
												Eq_2 edx_821 = *((word32) esi_806 + 8);
												ebp_1014->tFFFFFE54 = ecx_819;
												word32 ecx_823 = ecx_819 + ebx_820;
												if (ecx_823 >=u edx_821 + eax_817)
												{
													ebp_1014->tFFFFFE50 = ebx_820;
													Eq_2 edx_835 = ebp_1014->tFFFFFE30;
													while (true)
													{
														esi_1049 = *((word32) edx_835 + 0x0C);
														if (esi_1049 == 0x00)
															break;
														eax_817 = *((word64) esi_1049.u0 + 4);
														if (Mem834[esi_1049 + 0x08:word32] + eax_817 >u ecx_823)
														{
															ebx_820 = ebp_1014->tFFFFFE50;
															ebp_1014->tFFFFFE30 = edx_835;
															if (eax_817 <= ebx_820)
																goto l080702F4;
															goto l0807021F;
														}
														edx_835 = esi_1049;
													}
													ebp_1014->tFFFFFE30 = edx_835;
													goto l0807021F;
												}
												esi_1049 = ebp_1014->tFFFFFE30;
												if (ebx_820 >= eax_817)
												{
													ebp_1014->tFFFFFE30 = ebp_1014->tFFFFFE48;
l080702F4:
													ui32 edx_864 = (ebp_1014 - 212)[edi_1017].dw0000;
													(ebp_1014 - 0x0144)[edx_864].dw0000 = (word32) *esi_1049.u0 + (ebx_820 - eax_817);
													(ebp_1014 - 0x0140)[edx_864].t0000 = ebp_1014->tFFFFFE54;
													Eq_2 eax_872 = ebp_1014->tFFFFFE30;
													ebp_1014->tFFFFFE30 = esi_1049;
													ebp_1014->tFFFFFE48 = eax_872;
													ebx_1088 = edi_1017;
													edi_1017 = (word32) edi_1017 + 1;
													goto l08070331;
												}
												ebp_1014->tFFFFFE30 = ebp_1014->tFFFFFE48;
											}
											else
											{
												ebp_1014->tFFFFFE30 = ebp_1014->tFFFFFE48;
												esi_1049.u0 = 0x00;
											}
l0807021F:
											if (ebp_1014->dwFFFFFE20 != 0x00)
											{
												struct Eq_70736 * ecx_883 = ebp_1014->ptrFFFFFE40;
												struct Eq_71677 * esp_888 = esp_1004 - 4;
												esp_888->ptr0000 = (char *) ecx_883 - 0x00027EDC;
												esp_888->dwFFFFFFFC = 0x0178;
												esp_888->ptrFFFFFFF8 = (char *) ecx_883 - 163669;
												esp_888->ptrFFFFFFF4 = (char *) ecx_883 - 163655;
												word32 edx_1632;
												word32 ecx_1631;
												__assert_fail(out ecx_1631, out edx_1632);
l0807070C:
												word32 ecx_1617;
												word32 edx_1618;
												eax_1177 = __stack_chk_fail(out ecx_1617, out edx_1618);
												esp_1186.u0 = <invalid>;
												goto l08070711;
											}
											ebp_1014->tFFFFFE24 = edi_1017;
											Eq_2 ecx_911 = (ebp_1014 - 220)[edi_1017].t0000;
											Eq_2 eax_913 = -ebp_1014->tFFFFFE44;
											ebp_1014->tFFFFFE28 = ecx_911;
											ebp_1014->tFFFFFE54 = eax_913;
											ebp_1014->tFFFFFE50 = ebp_1014->ptrFFFFFE40->t19CC;
											ebp_1014->tFFFFFE48 = ebp_1014 - 0xD8;
											Eq_2 edx_1354 = edi_1017;
											while (true)
											{
												word32 eax_931 = Mem922[ebp_1014 + -440:word32][edx_1354 * 0x10] + ecx_911;
												if (ebp_1014->tFFFFFE50 < eax_931)
													goto l0806FE30;
												word32 eax_935 = eax_931 + Mem922[ebp_1014 + -0x01CC:word32] & Mem922[ebp_1014 + -428:word32];
												if (esi_1049 != 0x00 && *((word64) esi_1049.u0 + 4) <= ecx_911)
													break;
												Eq_2 edi_946 = (word32) edx_1354 + 1;
												if (edx_1354 >= ebp_1014->tFFFFFE4C)
												{
l0807042F:
													ebp_1014->tFFFFFE50 = edi_946;
													goto l0807043D;
												}
												ecx_911 = *((word32) ebp_1014->tFFFFFE3C + (edx_1354 * 0x10 + 16));
												if (ecx_911 >=u Mem922[ebp_1014 + -444:word32] + eax_935)
													goto l0807042F;
												edx_1354 = edi_946;
											}
											ebp_1014->tFFFFFE50 = edx_1354;
l0807043D:
											ebx_1088 = eax_935;
											if (ebp_1014->tFFFFFE2C == ~0x00)
											{
l08070570:
												struct Eq_70736 * eax_1276 = ebp_1014->ptrFFFFFE40;
												struct Eq_71993 * esp_1282 = esp_1004 - 0x08;
												esp_1282->tFFFFFFFC.u0 = 0x00088000;
												esp_1282->tFFFFFFF8 = (char *) eax_1276 - 163516;
												word32 ecx_1641;
												word32 edx_1642;
												Eq_2 eax_1294 = __open_nocancel(gs, esp_1282->tFFFFFFF8, esp_1282->tFFFFFFFC, esp_1282->t0000, out ecx_1641, out edx_1642);
												ebp_1014->tFFFFFE2C = eax_1294;
												if (eax_1294 != ~0x00)
												{
													esp_1282->t0000 = ebp_1014 - 0x01A4;
													esp_1282->tFFFFFFFC = ebp_1014->tFFFFFE2C;
													esp_1282->tFFFFFFF8.u0 = 0x03;
													esp_1004 = (char *) &esp_1282->t0000 + 8;
													word32 edx_1653;
													word32 ecx_1652;
													if (__fxstat64(gs, esp_1282->tFFFFFFFC, esp_1282->t0000, out ecx_1652, out edx_1653) < 0x00)
														goto l0806FE30;
													struct Eq_70736 * ecx_1326 = ebp_1014->ptrFFFFFE40;
													if ((ebp_1014->dwFFFFFE8C ^ ecx_1326->dw19D0 | ebp_1014->dwFFFFFE88 ^ ecx_1326->t19CC) != 0x00 || (ebp_1014->dwFFFFFEA4 != ecx_1326->dw19E8 || ((ebp_1014->dwFFFFFE60 ^ ecx_1326->dw19A4 | ebp_1014->dwFFFFFE5C ^ ecx_1326->dw19A0) != 0x00 || (ebp_1014->dwFFFFFEB8 ^ ecx_1326->dw19FC | ebp_1014->dwFFFFFEB4 ^ ecx_1326->dw19F8) != 0x00)))
														goto l0806FE30;
													goto l0807044A;
												}
												goto l0806FE3E;
											}
l0807044A:
											Eq_2 ecx_972 = ebp_1014->tFFFFFE28 & ebp_1014->tFFFFFE54;
											struct Eq_72034 * esp_974 = esp_1004 - 0x04;
											esp_974->tFFFFFFFC.u0 = 0x00;
											esp_974->tFFFFFFF8 = ecx_972;
											esp_974->tFFFFFFF4 = ebp_1014->tFFFFFE2C;
											esp_974->tFFFFFFF0.u0 = 0x02;
											esp_974->tFFFFFFEC.u0 = 0x01;
											Eq_2 ebx_977 = ebx_1088 - ecx_972;
											esp_974->tFFFFFFE8 = ebx_977;
											esp_974->tFFFFFFE4.u0 = 0x00;
											ebp_1014->tFFFFFE28 = ebx_977;
											ebp_1014->tFFFFFE24 = ecx_972;
											Eq_2 eax_997 = mmap64(gs, esp_974->tFFFFFFE4, esp_974->tFFFFFFE8, esp_974->tFFFFFFEC, esp_974->tFFFFFFF0, esp_974->tFFFFFFF4, esp_974->tFFFFFFF8, esp_974->tFFFFFFFC);
											ebp_1014->tFFFFFE54 = eax_997;
											esp_1004 = &esp_974->ptr0000 + 1;
											if (eax_997 == ~0x00)
												goto l0806FE30;
											esp_974->tFFFFFFF4.u0 = 0x10;
											word32 edx_1644;
											word32 ecx_1643;
											Eq_2 ebx_1015;
											Eq_2 esi_1019;
											Eq_2 eax_1013 = __libc_malloc(gs, esp_974->tFFFFFFF0, esp_974->tFFFFFFF4, out ecx_1643, out edx_1644, out ebx_1015, out ebp_1014, out esi_1019, out edi_1017);
											Eq_2 ecx_1025 = ebp_1014->tFFFFFE24;
											ebp_1014->tFFFFFE48 = eax_1013;
											esp_1004 = &esp_974->ptr0000 + 1;
											if (eax_1013 == 0x00)
											{
												esp_974->tFFFFFFF8 = ebp_1014->tFFFFFE28;
												esp_974->tFFFFFFF4 = ebp_1014->tFFFFFE54;
												word32 ebx_1647;
												word32 edx_1646;
												word32 ecx_1645;
												__munmap(ebx_1015, gs, esp_974->tFFFFFFF4, esp_974->tFFFFFFF8, out ecx_1645, out edx_1646, out ebx_1647);
												esp_1004 = &esp_974->ptr0000 + 2;
												esi_1049 = esi_1019;
												goto l0806FE30;
											}
											Eq_2 eax_1050 = ebp_1014->tFFFFFE48;
											*eax_1050 = ebp_1014->tFFFFFE54;
											Eq_2 edx_1053 = ebp_1014->tFFFFFE28;
											*((word32) eax_1050 + 4) = ecx_1025;
											*((word32) eax_1050 + 8) = edx_1053;
											if (*((word32) ebp_1014->tFFFFFE30 + 0x0C) != esi_1019)
											{
												struct Eq_70736 * ecx_1059 = ebp_1014->ptrFFFFFE40;
												esp_974->ptr0000 = (char *) ecx_1059 - 0x00027EDC;
												esp_974->tFFFFFFFC.u0 = 434;
												esp_974->tFFFFFFF8 = (char *) ecx_1059 - 163669;
												esp_974->tFFFFFFF4 = (char *) ecx_1059 - 163641;
												word32 edx_1649;
												word32 ecx_1648;
												__assert_fail(out ecx_1648, out edx_1649);
												Eq_2 eax_1079 = _nl_postload_ctype(gs);
												ebxOut = ebx_1015;
												ebpOut = ebp_1014;
												esiOut = esi_1019;
												return eax_1079;
											}
											Eq_2 edx_1086 = ebp_1014->tFFFFFE30;
											Eq_2 eax_1087 = ebp_1014->tFFFFFE48;
											ebp_1014->tFFFFFE30 = esi_1019;
											*((word32) eax_1087 + 0x0C) = esi_1019;
											*((word32) edx_1086 + 0x0C) = eax_1087;
											ebx_1088 = edi_1017;
											struct Eq_72239 * edx_1094 = (word32) ebp_1014->tFFFFFE3C + (edi_1017 << 0x04);
											while (true)
											{
												Eq_2 eax_1098 = edx_1094->dw0000;
												if (eax_1098 < ecx_1025)
												{
													struct Eq_70736 * ecx_1252 = ebp_1014->ptrFFFFFE40;
													esp_974->ptr0000 = (char *) ecx_1252 - 0x00027EDC;
													esp_974->tFFFFFFFC.u0 = 442;
													esp_974->tFFFFFFF8 = (char *) ecx_1252 - 163669;
													esp_974->tFFFFFFF4 = (char *) ecx_1252 - 0x00027F24;
													word32 edx_1651;
													word32 ecx_1650;
													__assert_fail(out ecx_1650, out edx_1651);
													Eq_2 esp_1266 = <invalid>;
													esp_1004 = (word32) esp_1266 - 4;
													esi_1049 = esi_1019;
													goto l08070570;
												}
												esi_1019 = edx_1094->dw0008;
												(ebp_1014 - 0x0144)[esi_1019].dw0000 = (word32) ebp_1014->tFFFFFE54 + (eax_1098 - ecx_1025);
												++edx_1094;
												(ebp_1014 - 0x0140)[esi_1019].dw0000 = edx_1094->dwFFFFFFF4;
												edi_1017 = (word32) edi_1017 + 1;
												if (ebp_1014->tFFFFFE50 <= edi_1017)
													break;
												ebx_1088 = edi_1017;
											}
l08070331:
										} while (ebx_1088 < ebp_1014->tFFFFFE4C);
										if (ebp_1014->tFFFFFE2C >= 0x00)
										{
											struct Eq_71798 * esp_1127 = esp_1004 - 0x0C;
											esp_1127->tFFFFFFFC = ebp_1014->tFFFFFE2C;
											word32 edx_1638;
											__close_nocancel(gs, esp_1127->tFFFFFFFC, out edx_1638);
										}
										struct Eq_71769 * esp_1147 = esp_1004 - 0x0C;
										esp_1147->tFFFFFFFC.u0 = 0x3C;
										word32 ecx_1633;
										word32 edx_1634;
										word32 ebx_1635;
										word32 edi_1637;
										word32 esi_1636;
										Eq_2 eax_1155 = __libc_malloc(gs, esp_1147->tFFFFFFF8, esp_1147->tFFFFFFFC, out ecx_1633, out edx_1634, out ebx_1635, out ebp_1014, out esi_1636, out edi_1637);
										esi_1049 = eax_1155;
										if (eax_1155 == 0x00)
										{
l0806FE3E:
											eax_1250.u0 = 0x00;
											goto l0806FC3D;
										}
										esp_1147->tFFFFFFFC = ebp_1014->ptrFFFFFE38->t0000;
										eax_1177 = strdup(esp_1147->tFFFFFFFC);
										*((word32) eax_1155 + 4) = eax_1177;
										esp_1186 = (char *) &esp_1147->tFFFFFFFC + 16;
										if (eax_1177 == 0x00)
										{
l08070711:
											ebp_1014->tFFFFFE54 = eax_1177;
											struct Eq_71849 * esp_1426 = esp_1186 - 0x0C;
											esp_1426->tFFFFFFFC = esi_1049;
											word32 ecx_1639;
											word32 edx_1640;
											free(gs, esp_1426->tFFFFFFF8, esp_1426->tFFFFFFFC, out ecx_1639, out edx_1640);
											eax_1250 = ebp_1014->tFFFFFE54;
											goto l0806FC3D;
										}
										struct Eq_70736 * edx_1191 = ebp_1014->ptrFFFFFE40;
										Eq_2 eax_1196 = edx_1191->t1980;
										edx_1191->t1980 = eax_1155;
										*eax_1155 = eax_1196;
										Eq_2 ebx_1192 = 0x00;
										struct Eq_71886 * edi_1195 = ebp_1014 - 0x0144;
										while (true)
										{
											if (ebx_1192 != 0x06)
											{
												struct Eq_71923 * esp_1203 = esp_1186 - 0x04;
												esp_1203->tFFFFFFFC = edi_1195->a0004[ebx_1192 * 2];
												esp_1203->tFFFFFFF8 = edi_1195[ebx_1192 * 2];
												esp_1203->tFFFFFFF4 = ebx_1192;
												Eq_2 eax_1216 = _nl_intern_locale_data(gs, esp_1203->tFFFFFFF0, esp_1203->tFFFFFFF4, esp_1203->tFFFFFFF8, esp_1203->tFFFFFFFC, out ebx_1192, out ebp_1014, out esi_1049, out edi_1195);
												*((word64) esi_1049.u0 + (ebx_1192 * 0x04 + 8)) = eax_1216;
												Eq_2 esp_1223 = <invalid>;
												esp_1186 = (word32) esp_1223 + 16;
												if (eax_1216 != 0x00)
												{
													Eq_2 edx_1233 = *((word64) esi_1049.u0 + 4);
													((word32) eax_1216 + 0x0C)->u0 = 0x02;
													((word32) eax_1216 + 24)->u0 = ~0x00;
													*eax_1216 = edx_1233;
												}
												if (ebx_1192 == 0x0C)
												{
													ebp_1014->ptrFFFFFE38->t0000 = *((word64) esi_1049.u0 + 4);
													eax_1250 = *((word64) esi_1049.u0 + (ebp_1014->t0008 * 0x04 + 8));
													goto l0806FC3D;
												}
											}
											ebx_1192 = (word32) ebx_1192 + 1;
										}
									}
								}
								esi_1049 += edx_1466;
								ebx_685 += Mem732[ebp_1014 + -428:word32];
							} while (ecx_689 > esi_1049);
							esi_1049 -= ecx_689;
							edi_671 = ecx_689;
						}
					}
				}
			}
		}
	}
l0806FEF0:
	struct Eq_70937 * esp_1365 = esp_1004 - 0x0C;
	esp_1365->tFFFFFFFC = ebp_1014->tFFFFFE2C;
	word32 edx_1621;
	__close_nocancel(gs, esp_1365->tFFFFFFFC, out edx_1621);
	eax_1250.u0 = 0x00;
	goto l0806FC3D;
}

// 08070760: Register ptr32 _nl_postload_ctype(Register (ptr32 Eq_9) gs)
// Called from:
//      _nl_load_locale_from_archive
ptr32 _nl_postload_ctype(struct Eq_9 * gs)
{
	struct Eq_72699 * ecx_15 = g_ptr80CEE60;
	word32 edi_17 = ecx_15->dw0024;
	word32 edx_18 = ecx_15->dw0030;
	word32 ecx_19 = ecx_15->dw0028;
	g_dw80CEE94 = edi_17 + 0x0100;
	g_dw80CEE98 = edx_18 + 0x0200;
	g_dw80CEE9C = ecx_19 + 0x0200;
	if (gs->ptrFFFFFFD4 != &g_ptr80CEE60)
		return 0x080CE000;
	gs->ptrFFFFFFF8 = edi_17 + 0x0100;
	gs->dwFFFFFFF4 = ecx_19 + 0x0200;
	gs->ptrFFFFFFF0 = edx_18 + 0x0200;
	return ~0x0F;
}

// 080707E0: FlagGroup Eq_2 __current_locale_name(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 eaxOut)
// Called from:
//      __dcigettext
Eq_2 __current_locale_name(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & eaxOut)
{
	eaxOut = gs->ptrFFFFFFD4->a0040[dwArg04];
	return <invalid>;
}

// 08070800: void __ctype_b_loc()
void __ctype_b_loc()
{
}

// 08070820: void __ctype_toupper_loc()
void __ctype_toupper_loc()
{
}

// 08070840: void __ctype_tolower_loc()
void __ctype_tolower_loc()
{
}

// 08070860: Register word32 __ctype_init(Register (ptr32 Eq_9) gs, Register out Eq_2 edxOut)
// Called from:
//      __libc_init_first
word32 __ctype_init(struct Eq_9 * gs, union Eq_2 & edxOut)
{
	Eq_2 edx_13 = gs->ptrFFFFFFD0->t0000;
	gs->ptrFFFFFFF8 = (word32) *((word32) edx_13 + 36) + 0x0100;
	gs->dwFFFFFFF4 = (word32) *((word32) edx_13 + 40) + 0x0200;
	gs->ptrFFFFFFF0 = (word32) *((word32) edx_13 + 48) + 0x0200;
	edxOut = edx_13;
	return ~0x0F;
}

// 080708C0: Register ui32 __setfpucw(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __libc_init_first
ui32 __setfpucw(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 ebx_11 = gs->dw0014;
	word32 edx_16 = (word32) __fstcw();
	ui32 ebx_25 = SEQ(SLICE(dwArg04, word16, 16), (word16) dwArg04 & 0x0F3F);
	__fldcw((word16) (SEQ(SLICE(edx_16, word16, 16), (word16) edx_16 & 0xF0C0) | ebx_25));
	if ((ebx_11 ^ gs->dw0014) == 0x00)
		return ebx;
	word32 ecx_104;
	word32 edx_105;
	__stack_chk_fail(out ecx_104, out edx_105);
	raise(gs, dwArg04);
	return ebx_25;
}

// 08070960: void raise(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      abort
//      __setfpucw
void raise(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 ecx_122;
	word32 * esi_116 = &g_dw80B1B80;
	ui32 edi_24 = gs->dw0014;
	word32 * edi_121 = fp - 0xA0;
	for (ecx_122 = 0x20; ecx_122 != 0x00; --ecx_122)
	{
		*edi_121 = *esi_116;
		++esi_116;
		++edi_121;
	}
	gs->ptr0010();
	gs->ptr0010();
	word32 eax_54;
	gs->ptr0010();
	struct Eq_226 * eax_61;
	gs->ptr0010();
	if (eax_61 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_150;
		__syscall_error(eax_61, gs, out edx_150);
	}
	gs->ptr0010();
	if ((edi_24 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_152;
	word32 ecx_151;
	__stack_chk_fail(out ecx_151, out edx_152);
	__syscall(0x80);
	__syscall(0x80);
}

// 08070A70: Register (ptr32 Eq_226) __libc_sigaction(Register (ptr32 Eq_9) gs, Stack up32 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      raise
//      __sigaction
struct Eq_226 * __libc_sigaction(struct Eq_9 * gs, up32 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	ui32 eax_27 = gs->dw0014;
	if (dwArg08 != 0x00)
	{
		word32 * esi_195 = (word32) dwArg08 + 4;
		word32 ecx_200 = 0x20;
		word32 * edi_199 = fp - 300;
		word32 eax_41 = *((word32) dwArg08 + 0x0084);
		while (true)
		{
			byte al_55 = (byte) eax_41;
			if (ecx_200 == 0x00)
				break;
			*edi_199 = *esi_195;
			++esi_195;
			++edi_199;
			--ecx_200;
		}
	}
	struct Eq_226 * eax_106;
	gs->ptr0010();
	if (eax_106 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_350;
		eax_106 = __syscall_error(eax_106, gs, out edx_350);
	}
	if (dwArg0C != 0x00 && eax_106 >= null)
	{
		*dwArg0C = dwLocAC;
		word32 edi_131 = dwArg0C + 0x08 & ~0x03;
		word32 ecx_135 = dwArg0C + 0x04 - edi_131;
		*((word32) dwArg0C + 4) = dwLocA0;
		*((word32) dwArg0C + 0x0080) = dwLoc24;
		word32 * esi_136 = fp - 0xA0 - ecx_135;
		uint32 ecx_140;
		for (ecx_140 = ecx_135 - (struct Eq_72974 *) ~0x7F >> 0x02; ecx_140 != 0x00; --ecx_140)
		{
			edi_131->dw0000 = *esi_136;
			++esi_136;
			edi_131 += 4;
		}
		*((word32) dwArg0C + 0x0084) = dwLocA8;
		*((word32) dwArg0C + 0x0088) = dwLocA4;
	}
	if ((eax_27 ^ gs->dw0014) == 0x00)
		return eax_106;
	word32 edx_352;
	word32 ecx_351;
	__stack_chk_fail(out ecx_351, out edx_352);
	return __sigaction(gs, dwArg04);
}

// 08070BE0: Register word32 __sigaction(Register (ptr32 Eq_9) gs, Stack up32 dwArg04)
// Called from:
//      abort
//      __libc_sigaction
//      profil
word32 __sigaction(struct Eq_9 * gs, up32 dwArg04)
{
	if (dwArg04 > 0x40 || dwArg04 <= 33)
	{
		gs->tFFFFFFE0.u0 = 22;
		return ~0x00;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		return __libc_sigaction(gs, dwArg04, stackArg8, stackArg12);
	}
}

// 08070C30: Register word32 sigprocmask(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      abort
//      __sigsetjmp
word32 sigprocmask(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	ui32 eax_16 = gs->dw0014;
	Eq_2 esi_19 = dwArg08;
	if (dwArg08 != 0x00 && (*dwArg08 < 0x00 || (*((word32) dwArg08 + 4) & 0x01) != 0x00))
	{
		word32 * edi_32 = fp - 0x90;
		word32 ecx_33;
		for (ecx_33 = 0x20; ecx_33 != 0x00; --ecx_33)
		{
			*edi_32 = (word32) *esi_19;
			esi_19 = (word32) esi_19 + 4;
			++edi_32;
		}
		dwLoc8C &= ~0x01;
	}
	word32 ecx_68;
	struct Eq_226 * eax_69;
	ptr32 edx_144;
	gs->ptr0010();
	if (eax_69 > (struct Eq_226 *) ~0x0FFF)
		__syscall_error(eax_69, gs, out edx_144);
	if ((eax_16 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_176;
		word32 edx_177;
		__stack_chk_fail(out ecx_176, out edx_177);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg20 = <invalid>;
		ptr32 edx_98;
		word32 ecx_96 = _quicksort(gs, dwArg04, dwArg08, dwArg0C, dwLoc8C, stackArg20, out edx_98);
		edxOut = edx_98;
		return ecx_96;
	}
	else
	{
		edxOut = edx_144;
		return ecx_68;
	}
}

// 08070CE0: Register Eq_2 _quicksort(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack (ptr32 code) dwArg10, Stack Eq_2 dwArg14, Register out Eq_2 edxOut)
// Called from:
//      qsort_r
//      sigprocmask
Eq_2 _quicksort(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, <anonymous> * dwArg10, Eq_2 dwArg14, union Eq_2 & edxOut)
{
	ui32 edx_23 = gs->dw0014;
	Eq_2 edx_1141 = 0x00;
	if (dwArg08 != 0x00)
	{
		Eq_2 edx_34 = (word32) dwArg04 + (dwArg08 - 0x01) *s dwArg0C;
		if (dwArg08 > 0x04)
		{
			struct Eq_73121 * eax_41 = -dwArg0C;
			Eq_2 dwLoc0148_662 = edx_34;
			struct Eq_73124 * dwLoc013C_664 = fp - 0x0118;
			Eq_2 dwLoc0144_665 = dwArg04;
			do
			{
				struct Eq_73272 * eax_65 = ((uint32) ((uint64) (dwLoc0148_662 - dwLoc0144_665) /u dwArg0C) >> 0x01) *s dwArg0C;
				word32 esi_72 = dwLoc0144_665 + eax_65;
				int32 eax_79;
				word32 ecx_81;
				dwArg10();
				if (eax_79 < 0x00)
				{
					Eq_2 edx_100 = dwLoc0144_665;
					Eq_2 eax_89 = esi_72;
					word32 ebx_90 = dwArg0C + esi_72;
					do
					{
						byte cl_103 = *eax_89;
						eax_89 = (word32) eax_89 + 1;
						*((word32) eax_89 - 1) = *edx_100;
						edx_100 = (word32) edx_100 + 1;
						*((word32) edx_100 - 1) = cl_103;
					} while (eax_89 != ebx_90);
				}
				int32 eax_129;
				word32 ecx_131;
				dwArg10();
				if (eax_129 < 0x00)
				{
					Eq_2 edx_138 = dwLoc0148_662;
					Eq_2 eax_139 = esi_72;
					word32 ebx_140 = dwArg0C + esi_72;
					do
					{
						byte cl_154 = *eax_139;
						eax_139 = (word32) eax_139 + 1;
						*((word32) eax_139 - 1) = *edx_138;
						++edx_138;
						*((word32) edx_138 - 1) = cl_154;
					} while (eax_139 != ebx_140);
					int32 eax_174;
					word32 ecx_176;
					dwArg10();
					if (eax_174 < 0x00)
					{
						Eq_2 edx_183 = dwLoc0144_665;
						Eq_2 eax_184 = esi_72;
						do
						{
							byte cl_194 = *eax_184;
							eax_184 = (word32) eax_184 + 1;
							*((word32) eax_184 - 1) = *edx_183;
							++edx_183;
							*((word32) edx_183 - 1) = cl_194;
						} while (eax_184 != ebx_140);
					}
				}
				word32 dwLoc0158_713 = dwLoc0144_665 + dwArg0C;
				word32 ebx_205 = dwLoc0148_662 + eax_41;
				Eq_2 esi_209 = esi_72;
				do
				{
					while (true)
					{
						int32 eax_226;
						word32 ecx_228;
						dwArg10();
						if (eax_226 >= 0x00)
							break;
						dwLoc0158_713 += dwArg0C;
					}
					while (true)
					{
						int32 eax_249;
						word32 ecx_251;
						dwArg10();
						if (eax_249 >= 0x00)
							break;
						ebx_205 += eax_41;
					}
					if (dwLoc0158_713 >= ebx_205)
					{
						if (dwLoc0158_713 == ebx_205)
						{
							ebx_205 += eax_41;
							dwLoc0158_713 += dwArg0C;
							break;
						}
					}
					else
					{
						Eq_2 eax_261 = dwLoc0158_713;
						Eq_2 edx_264 = ebx_205;
						word32 ecx_265 = dwArg0C + dwLoc0158_713;
						do
						{
							byte cl_279 = *eax_261;
							eax_261 = (word32) eax_261 + 1;
							*((word32) eax_261 - 1) = *edx_264;
							++edx_264;
							*((word32) edx_264 - 1) = cl_279;
						} while (eax_261 != ecx_265);
						if (dwLoc0158_713 != esi_209)
						{
							if (ebx_205 == esi_209)
								esi_209 = dwLoc0158_713;
						}
						else
							esi_209 = ebx_205;
						ebx_205 += eax_41;
						dwLoc0158_713 = ecx_265;
					}
				} while (dwLoc0158_713 <= ebx_205);
				struct Eq_73188 * edx_318 = ebx_205 - dwLoc0144_665;
				struct Eq_73188 * eax_319 = dwLoc0148_662 - dwLoc0158_713;
				if (edx_318 <= dwArg0C << 0x02)
				{
					dwLoc0144_665 = dwLoc0158_713;
					if (dwArg0C << 0x02 >= eax_319)
					{
						dwLoc0144_665 = dwLoc013C_664->dwFFFFFFF8;
						dwLoc013C_664 -= 0x08;
						dwLoc0148_662 = dwLoc013C_664->dwFFFFFFFC;
					}
				}
				else if (dwArg0C << 0x02 < eax_319)
				{
					if (edx_318 > eax_319)
					{
						dwLoc013C_664->dw0004 = (word32) ebx_205;
						dwLoc013C_664->dw0000 = (word32) dwLoc0144_665;
						++dwLoc013C_664;
						dwLoc0144_665 = dwLoc0158_713;
					}
					else
					{
						dwLoc013C_664->dw0000 = (word32) dwLoc0158_713;
						dwLoc013C_664->dw0004 = (word32) dwLoc0148_662;
						++dwLoc013C_664;
						dwLoc0148_662 = ebx_205;
					}
				}
				else
					dwLoc0148_662 = ebx_205;
			} while (dwLoc013C_664 > fp - 288);
		}
		Eq_2 ebx_360 = dwArg04;
		Eq_2 eax_363 = (word32) dwArg04 + (dwArg0C << 0x02);
		if (edx_34 < eax_363)
			eax_363 = edx_34;
		word32 edx_371 = dwArg04 + dwArg0C;
		Eq_2 esi_373 = edx_371;
		ecx = eax_363;
		edx_1141 = edx_371;
		if (eax_363 >= edx_371)
		{
			do
			{
				int32 eax_394;
				dwArg10();
				if (eax_394 < 0x00)
					ebx_360 = esi_373;
				esi_373 += dwArg0C;
			} while (eax_363 >= esi_373);
			Eq_2 eax_409 = dwArg04;
			if (ebx_360 != dwArg04)
			{
				word32 edx_414 = dwArg0C + ebx_360;
				do
				{
					ecx = (word32) *ebx_360;
					edx_1141 = (word32) *eax_409;
					++ebx_360;
					*((word32) ebx_360 - 1) = (byte) edx_1141;
					eax_409 = (word32) eax_409 + 1;
					*((word32) eax_409 - 1) = (byte) ecx;
				} while (ebx_360 != edx_414);
			}
		}
		struct Eq_73289 * ebx_460 = -dwArg0C;
		Eq_2 esi_464 = edx_371;
		while (true)
		{
			Eq_2 ecx_533;
			word32 eax_469 = dwArg0C + esi_464;
			if (eax_469 > edx_34)
				break;
			Eq_2 ebx_511 = esi_464;
			while (true)
			{
				int32 eax_531;
				dwArg10();
				if (eax_531 >= 0x00)
					break;
				ebx_511 += ebx_460;
			}
			esi_464 = ebx_511 + dwArg0C;
			ecx = ecx_533;
			if (eax_469 != esi_464)
			{
				word32 edi_549 = eax_469 + (dwArg0C - 0x01);
				ecx = ecx_533;
				if (edi_549 >= null)
				{
					ecx = ecx_533;
					do
					{
						byte al_560 = edi_549->b0000;
						struct Eq_73333 * edx_559 = edi_549;
						Eq_2 eax_565 = edi_549 - dwArg0C;
						if (esi_464 <= eax_565)
						{
							while (true)
							{
								edx_559->b0000 = (byte) *eax_565;
								ecx = eax_565 + ebx_460;
								edx_559 -= dwArg0C;
								if (esi_464 > ecx)
									break;
								eax_565 = ecx;
							}
							edx_1141 = (word32) al_560;
							*eax_565 = (byte) edx_1141;
							edi_549 -= (struct Eq_73371 *) 0x01;
							if (edi_549 == eax_469 - (struct Eq_73358 *) 0x01)
								break;
							continue;
						}
						edx_1141 = (word32) al_560;
						edi_549->b0000 = (byte) edx_1141;
						edi_549 -= (struct Eq_73356 *) 0x01;
					} while (edi_549 != eax_469 - (struct Eq_73358 *) 0x01);
				}
				esi_464 = eax_469;
			}
		}
	}
	if ((edx_23 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_1159;
		word32 edx_1160;
		__stack_chk_fail(out ecx_1159, out edx_1160);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg16 = <invalid>;
		Eq_2 edx_496;
		Eq_2 ecx_497 = __add_to_environ(gs, stackArg4, stackArg8, stackArg12, stackArg16, out edx_496);
		edxOut = edx_496;
		return ecx_497;
	}
	else
	{
		edxOut = edx_1141;
		return ecx;
	}
}

// 080711A0: Register ui32 __add_to_environ(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 edxOut)
// Called from:
//      _quicksort
//      __setenv
ui32 __add_to_environ(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & edxOut)
{
	ui32 ecx_28 = gs->dw0014;
	Eq_2 dwLoc3C_730 = dwArg0C;
	word32 edx_1147;
	word32 ecx_1146;
	Eq_2 eax_35 = strlen(dwArg04, out ecx_1146, out edx_1147);
	if (dwArg0C == 0x00)
	{
		word32 ecx_1148;
		word32 edx_1149;
		dwLoc4C = (word32) strlen(dwArg08, out ecx_1148, out edx_1149) + 1;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_75;
	if (!__cmpxchg(envlock, 0x01, 0x00, out eax_75))
		__lll_lock_wait_private(eax_75, 0x080CFA1C, gs);
	Eq_2 edx_1131;
	Eq_2 edx_136;
	word32 eax_137;
	ui32 esi_105;
	Eq_2 eax_142;
	Eq_2 edx_87 = environ;
	if (edx_87 != 0x00)
	{
		Eq_2 edi_119 = *edx_87;
		if (edi_119 != 0x00)
		{
			esi_105 = 0x00;
			Eq_2 ebx_106 = edx_87;
			while (true)
			{
				word32 ecx_1150;
				if (strncmp(edi_119, dwArg04, eax_35, out ecx_1150) == 0x00 && Mem120[edi_119 + eax_35:byte] == 0x3D)
					break;
				ebx_106 = (word32) ebx_106 + 4;
				edi_119 = *ebx_106;
				ui32 eax_148 = esi_105 + 0x01;
				if (edi_119 == 0x00)
				{
					esi_105 = eax_148;
					eax_142 = esi_105 * 0x04 + 0x0C;
					goto l0807127C;
				}
				esi_105 = eax_148;
			}
			edx_136 = ebx_106;
			eax_137 = (word32) *ebx_106;
			if (eax_137 != 0x00)
				goto l080712E0;
			eax_142 = esi_105 * 0x04 + 0x08;
l0807127C:
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 edx_173 = last_environ;
			Eq_2 stackArg0 = <invalid>;
			word32 ebp_1153;
			word32 esi_1154;
			word32 edx_1152;
			word32 edi_1155;
			Eq_2 eax_195 = __realloc(gs, stackArg0, edx_173, eax_142, out edx_1152, out ebp_1153, out esi_1154, out edi_1155);
			edx_1131 = edx_173;
			if (eax_195 == 0x00)
				goto l080714B2;
			Eq_2 esi_206 = esi_105 << 0x02;
			Eq_2 eax_207 = environ;
			if (edx_173 != eax_207)
			{
				word32 ecx_1156;
				word32 edx_1157;
				memcpy(eax_195, eax_207, esi_206, out ecx_1156, out edx_1157);
			}
			edx_136 = eax_195 + esi_206;
			*edx_136 = 0x00;
			*((word32) eax_195 + (esi_105 * 0x04 + 4)) = 0x00;
			environ = eax_195;
			last_environ = eax_195;
			eax_137 = (word32) *edx_136;
l080712E0:
			if (dwArg10 == 0x00 && eax_137 != 0x00)
			{
l080712FB:
				edx_1131 = edx_136;
				if (gs->t000C != 0x00)
					__lock();
				Eq_2 v38_628 = envlock - 0x01;
				envlock = v38_628;
				if (v38_628 != 0x00)
					__lll_unlock_wake_private(0x080CFA1C, 0x080CE000, edx_136, gs);
				goto l0807131F;
			}
			if (dwArg0C != 0x00)
			{
l080712F6:
				*edx_136 = dwLoc3C_730;
				goto l080712FB;
			}
			ptr32 esp_367;
			Eq_2 esi_267 = (word32) eax_35 + ((word32) dwLoc4C + 1);
			up32 eax_273 = __libc_alloca_cutoff(gs, esi_267);
			struct Eq_73566 * esp_279 = fp - 0x4C;
			if (esi_267 > 0x1000 && eax_273 == 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ebx_1161;
				word32 ebp_1162;
				word32 esi_1163;
				word32 edi_1164;
				word32 ecx_1159;
				word32 edx_1160;
				Eq_2 eax_297 = __libc_malloc(gs, stackArg0, esi_267, out ecx_1159, out edx_1160, out ebx_1161, out ebp_1162, out esi_1163, out edi_1164);
				edx_1131 = edx_136;
				dwLoc3C_730 = eax_297;
				if (eax_297 != 0x00)
				{
					word32 edx_1178;
					Eq_2 eax_322 = __mempcpy(eax_297, dwArg04, eax_35, out edx_1178);
					*eax_322 = 0x3D;
					word32 ecx_1179;
					word32 edx_1180;
					memcpy((word32) eax_322 + 1, dwArg08, dwLoc4C, out ecx_1179, out edx_1180);
					Eq_2 eax_361 = __tfind(eax_297, 0x080CFA18, 0x0805ECD0);
					esp_367 = fp - 0x4C;
					if (eax_361 != 0x00)
					{
						Eq_2 eax_372 = *eax_361;
						if (eax_372 != 0x00)
						{
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg0 = <invalid>;
							word32 ecx_1185;
							word32 edx_1186;
							free(gs, stackArg0, eax_297, out ecx_1185, out edx_1186);
							dwLoc3C_730 = eax_372;
							goto l080712F6;
						}
					}
l08071489:
					struct Eq_73828 * esp_588 = esp_367 - 0x04;
					esp_588->ptrFFFFFFFC = 0x0805ECD0;
					esp_588->ptrFFFFFFF8 = 0x080CFA18;
					esp_588->tFFFFFFF4 = dwLoc3C_730;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 ecx_1182;
					word32 edx_1183;
					__tsearch(stackArg4, dwArg04, dwArg08, out ecx_1182, out edx_1183);
					goto l080712F6;
				}
			}
			else
			{
				struct Eq_73566 * ecx_400 = fp - 0x4C - ((word32) esi_267 + 27 & ~0x0FFF);
				ui32 ebx_401 = (word32) esi_267 + 27 & ~0x0F;
				if (fp - 0x4C != ecx_400)
				{
					do
					{
						esp_279 -= 0x1000;
						esp_279->dw0FFC = esp_279->dw0FFC;
					} while (esp_279 != ecx_400);
				}
				if ((ebx_401 & 0x0FFF) != 0x00)
				{
					esp_279 -= ebx_401 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_279 - 0x04)[(ebx_401 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_279 - 0x04)[(ebx_401 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_73651 * esp_430 = esp_279 - 0x04;
				esp_430->tFFFFFFFC = eax_35;
				esp_430->tFFFFFFF8 = dwArg04;
				Eq_73660 eax_429 = (char *) esp_279 + 0x0F;
				esp_430->tFFFFFFF4 = eax_429 & ~0x0F;
				word32 edx_1165;
				Eq_2 eax_455 = __mempcpy(esp_430->tFFFFFFF4, esp_430->tFFFFFFF8, esp_430->tFFFFFFFC, out edx_1165);
				*eax_455 = 0x3D;
				esp_430->tFFFFFFFC = dwLoc4C;
				esp_430->tFFFFFFF8 = dwArg08;
				esp_430->tFFFFFFF4 = (word32) eax_455 + 1;
				word32 ecx_1166;
				word32 edx_1167;
				memcpy(esp_430->tFFFFFFF4, esp_430->tFFFFFFF8, esp_430->tFFFFFFFC, out ecx_1166, out edx_1167);
				esp_430->tFFFFFFFC.u0 = 0x0805ECD0;
				esp_430->tFFFFFFF8.u0 = 0x080CFA18;
				esp_430->tFFFFFFF4 = eax_429 & ~0x0F;
				Eq_2 eax_495 = __tfind(esp_430->tFFFFFFF4, esp_430->tFFFFFFF8, esp_430->tFFFFFFFC);
				if (eax_495 != 0x00)
				{
					Eq_2 eax_506 = *eax_495;
					dwLoc3C_730 = eax_506;
					if (eax_506 != 0x00)
						goto l080712F6;
				}
				esp_430->tFFFFFFF4 = esi_267;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				Eq_2 stackArg4 = <invalid>;
				word32 edx_1171;
				word32 ebx_1172;
				word32 ebp_1173;
				word32 esi_1174;
				word32 edi_1175;
				word32 ecx_1170;
				Eq_2 eax_536 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_1170, out edx_1171, out ebx_1172, out ebp_1173, out esi_1174, out edi_1175);
				edx_1131 = edx_136;
				dwLoc3C_730 = eax_536;
				if (eax_536 != 0x00)
				{
					esp_430->tFFFFFFFC = esi_267;
					esp_430->tFFFFFFF8 = eax_429 & ~0x0F;
					esp_430->tFFFFFFF4 = eax_536;
					word32 ecx_1176;
					word32 edx_1177;
					memcpy(esp_430->tFFFFFFF4, esp_430->tFFFFFFF8, esp_430->tFFFFFFFC, out ecx_1176, out edx_1177);
					esp_367 = (char *) &esp_430->tFFFFFFFC + 8;
					goto l08071489;
				}
			}
l080714B2:
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v29_554 = envlock - 0x01;
			envlock = v29_554;
			if (v29_554 != 0x00)
				__lll_unlock_wake_private(0x080CFA1C, 0x080CE000, edx_1131, gs);
l0807131F:
			ui32 ecx_652 = ecx_28 ^ gs->dw0014;
			if (ecx_652 != 0x00)
			{
				word32 ecx_1187;
				word32 edx_1188;
				__stack_chk_fail(out ecx_1187, out edx_1188);
				Eq_2 edx_709;
				ui32 ecx_708 = __setenv(gs, dwArg04, out edx_709);
				edxOut = edx_709;
				return ecx_708;
			}
			else
			{
				edxOut = edx_1131;
				return ecx_652;
			}
		}
	}
	eax_142.u0 = 0x08;
	esi_105 = 0x00;
	goto l0807127C;
}

// 08071590: Register Eq_2 __setenv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 edxOut)
// Called from:
//      __add_to_environ
Eq_2 __setenv(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & edxOut)
{
	if (dwArg04 != 0x00 && (*dwArg04 != 0x00 && strchr(dwArg04, 0x3D, out ecx, out edx) == 0x00))
		ecx = __add_to_environ(gs, dwArg04, dwArg08, 0x00, dwArg0C, out edx);
	else
		gs->tFFFFFFE0.u0 = 22;
	edxOut = edx;
	return ecx;
}

// 08071600: void __unsetenv(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_non_dynamic_init
void __unsetenv(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 != 0x00 && *dwArg04 != 0x00)
	{
		word32 ecx_271;
		word32 edx_272;
		Eq_2 eax_32 = strchr(dwArg04, 0x3D, out ecx_271, out edx_272);
		if (eax_32 == 0x00)
		{
			word32 edx_274;
			word32 ecx_273;
			Eq_2 eax_56 = strlen(dwArg04, out ecx_273, out edx_274);
			Eq_2 ecx_108 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_74;
			if (!__cmpxchg(envlock, 0x01, eax_32, out eax_74))
				ecx_108 = __lll_lock_wait_private(eax_74, 0x080CFA1C, gs);
			Eq_2 ebp_131 = environ;
			if (ebp_131 != 0x00)
			{
				while (true)
				{
					Eq_2 ebx_92 = *ebp_131;
					if (ebx_92 == 0x00)
						break;
					if (strncmp(ebx_92, dwArg04, eax_56, out ecx_108) == 0x00 && Mem106[ebx_92 + eax_56:byte] == 0x3D)
					{
						struct Eq_74003 * eax_120 = (word32) ebp_131 + 4;
						do
						{
							ecx_108 = eax_120->dw0000;
							++eax_120;
							eax_120->dwFFFFFFFC = (word32) ecx_108;
						} while (ecx_108 != 0x00);
					}
					else
						ebp_131 = (word32) ebp_131 + 4;
				}
			}
			if (gs->t000C != 0x00)
				__lock();
			Eq_2 v15_147 = envlock - 0x01;
			envlock = v15_147;
			if (v15_147 != 0x00)
				__lll_unlock_wake_private(0x080CFA1C, ecx_108, 0x080CE000, gs);
			return;
		}
	}
	gs->tFFFFFFE0.u0 = 22;
}

// 08071710: void __clearenv(Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      free_mem
void __clearenv(Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 ecx_27 = 0x01;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_22;
	if (!__cmpxchg(envlock, 0x01, 0x00, out eax_22))
		ecx_27 = __lll_lock_wait_private(eax_22, 0x080CFA1C, gs);
	Eq_2 eax_34 = environ;
	if (last_environ == eax_34 && eax_34 != 0x00)
	{
		free(gs, dwLoc20, eax_34, out ecx_27, out edx);
		last_environ.u0 = 0x00;
	}
	environ.u0 = 0x00;
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v12_67 = envlock - 0x01;
	envlock = v12_67;
	if (v12_67 != 0x00)
		__lll_unlock_wake_private(0x080CFA1C, ecx_27, edx, gs);
}

// 080717B0: Register Eq_2 __libc_secure_getenv(Stack Eq_2 dwArg04)
// Called from:
//      __libc_message
//      __sysconf_check_spec
Eq_2 __libc_secure_getenv(Eq_2 dwArg04)
{
	if (*(union Eq_4933 *) 0x080CDDAC != 0x00)
		return 0x00;
	return getenv(dwArg04);
}

// 080717E0: void __strtol_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_44571 dwArg0C, Stack word32 dwArg10)
void __strtol_internal(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_44571 dwArg0C, word32 dwArg10)
{
	____strtol_l_internal(gs, dwArg04, dwArg08, dwArg0C, dwArg10, gs->ptrFFFFFFD4);
}

// 08071820: Register word32 __strtol(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_44571 dwArg0C)
// Called from:
//      __sysconf
//      add_module.isra.0
word32 __strtol(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_44571 dwArg0C)
{
	return ____strtol_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, gs->ptrFFFFFFD4);
}

// 08071860: Register Eq_74104 ____strtol_l_internal(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_44571 dwArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_11467) dwArg14)
// Called from:
//      __strtol_internal
//      __strtol
//      __strtol_l
Eq_74104 ____strtol_l_internal(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_44571 dwArg0C, word32 dwArg10, struct Eq_11467 * dwArg14)
{
	Eq_2 ebp_212 = 0x00;
	Eq_2 dwLoc48_1111 = 0x00;
	if (dwArg10 != 0x00)
	{
		Eq_2 edx_27 = dwArg14->t0004;
		Eq_2 eax_28 = *((word32) edx_27 + 44);
		dwLoc48_1111 = eax_28;
		if ((byte) ((word32) *eax_28 - 0x01) <= 0x7D)
		{
			ebp_212 = *((word32) edx_27 + 40);
			if (*ebp_212 == 0x00)
			{
				dwLoc48_1111.u0 = 0x00;
				ebp_212.u0 = 0x00;
			}
		}
		else
			dwLoc48_1111.u0 = 0x00;
	}
	Eq_74104 eax_1116;
	if (dwArg0C == 0x01 || dwArg0C > 0x24)
	{
		gs->tFFFFFFE0.u0 = 22;
		eax_1116.u0 = 0x00;
		return eax_1116;
	}
	int32 edx_66 = (int32) *dwArg04;
	Eq_2 esi_63 = dwArg04;
	Eq_2 ecx_64 = dwArg14->t0034;
	byte al_80 = (byte) edx_66;
	if ((*((word32) ecx_64 + (edx_66 * 0x02 + 1)) & 0x20) != 0x00)
	{
		do
		{
			esi_63 = (word32) esi_63 + 1;
			int32 edx_74 = (int32) *esi_63;
			al_80 = (byte) edx_74;
		} while ((*((word32) ecx_64 + (edx_74 * 0x02 + 1)) & 0x20) != 0x00);
	}
	if (al_80 == 0x00)
	{
		if (dwArg08 == null)
		{
			eax_1116.u0 = 0x00;
			return eax_1116;
		}
		goto l08071C54;
	}
	up32 dwLoc24_704;
	Eq_2 esi_107;
	if (al_80 != 0x2D)
	{
		dwLoc24_704 = 0x00;
		esi_107 = (word32) esi_63 + (word32) ((int8) (al_80 == 0x2B));
	}
	else
	{
		esi_107 = (word32) esi_63 + 1;
		dwLoc24_704 = 0x01;
	}
	cu8 bLoc30_1108;
	Eq_74104 dwLoc44_1100;
	Eq_3851 (* dwLoc38_1094)[];
	ui32 ecx_143;
	Eq_2 edi_129;
	ui32 ecx_111 = (word32) *esi_107;
	byte cl_112 = (byte) ecx_111;
	if (cl_112 != 0x30)
	{
		if (dwArg0C != 0x00 && dwArg0C != 0x0A)
		{
			dwLoc48_1111.u0 = 0x00;
			bLoc30_1108 = (cu8) *((word32) dwArg0C.u0 + 0x080B1BFE);
			edi_129.u0 = 0x00;
			dwLoc44_1100 = *((char *) g_a80B1C38 + dwArg0C * 0x04);
			goto l0807192C;
		}
		if (dwLoc48_1111 == 0x00)
		{
			dwLoc44_1100.u0 = 0x19999999;
			edi_129.u0 = 0x00;
			bLoc30_1108 = 0x05;
			dwArg0C.u0 = 0x0A;
			goto l0807192C;
		}
l08071BD8:
		word32 ecx_1197;
		word32 edx_1198;
		Eq_2 eax_216 = strlen(ebp_212, out ecx_1197, out edx_1198);
		if (eax_216 == 0x00)
			goto l08071C25;
		byte al_232 = *ebp_212.u0;
		if (cl_112 == al_232)
		{
			Eq_2 eax_237 = 0x00;
			do
			{
				eax_237 = (word32) eax_237 + 1;
				if (eax_216 == eax_237)
					goto l08071C25;
			} while (Mem233[ebp_212 + eax_237:byte] == Mem233[esi_107 + eax_237:byte]);
		}
		ui32 ebx_254 = (word32) cl_112;
		Eq_2 edx_259 = esi_107;
		if ((byte) ebx_254 != 0x00)
		{
			edx_259 = esi_107;
			word32 edi_273 = (word32) al_232;
			Eq_2 ecx_274 = g_t80CE08C;
			Eq_3851 eax_275[] = g_ptr80CE084;
			do
			{
				if ((byte) (ebx_254 - 0x30) > 0x09)
				{
					byte cl_292 = (byte) edi_273;
					Eq_2 eax_286 = 0x00;
					while (Mem278[edx_259 + eax_286:byte] == cl_292)
					{
						eax_286 = (word32) eax_286 + 1;
						if (eax_216 == eax_286)
							goto l08071D80;
						cl_292 = Mem278[ebp_212 + eax_286:byte];
					}
					if (eax_216 > eax_286 && ((*((word32) ecx_274 + (ebx_254 * 0x02 + 1)) & 0x04) == 0x00 || eax_275[ebx_254] > 0x40))
						break;
				}
l08071D80:
				edx_259 = (word32) edx_259 + 1;
				ebx_254 = (word32) *edx_259;
			} while ((byte) ebx_254 != 0x00);
		}
		Eq_2 eax_347 = __correctly_grouped_prefixmb(esi_107, edx_259, ebp_212, dwLoc48_1111);
		edi_129 = eax_216;
		ecx_111 = (word32) *esi_107;
		dwLoc48_1111 = eax_347;
		dwLoc44_1100.u0 = 0x19999999;
		bLoc30_1108 = 0x05;
		dwArg0C.u0 = 0x0A;
l0807192C:
		byte cl_372 = (byte) ecx_111;
		if (dwLoc48_1111 == esi_107)
			goto l08071C25;
		ecx_143 = ecx_111;
		if (cl_372 == 0x00)
			goto l08071C25;
l0807193E:
		dwLoc38_1094 = g_ptr80CE084;
		goto l0807194C;
	}
	if ((dwArg0C & ~0x10) == 0x00)
	{
		Eq_3851 eax_120[] = g_ptr80CE084;
		dwLoc38_1094 = eax_120;
		if (eax_120[(int32) *((word32) esi_107 + 1)] == 88)
		{
			ecx_111 = (word32) *((word32) esi_107 + 2);
			bLoc30_1108 = 0x0F;
			esi_107 = (word32) esi_107 + 2;
			edi_129.u0 = 0x00;
			dwLoc44_1100.u0 = 0x0FFFFFFF;
			dwArg0C.u0 = 0x10;
			dwLoc48_1111.u0 = 0x00;
			goto l0807192C;
		}
		if (dwArg0C == 0x00)
		{
			dwArg0C.u0 = 0x08;
			edi_129.u0 = 0x00;
			ecx_143 = 0x30;
			dwLoc48_1111.u0 = 0x00;
			dwLoc44_1100.u0 = 0x1FFFFFFF;
			bLoc30_1108 = 0x07;
			goto l0807194C;
		}
	}
	if (dwArg0C == 0x0A)
	{
		if (dwLoc48_1111 == 0x00)
		{
			dwLoc44_1100.u0 = 0x19999999;
			edi_129.u0 = 0x00;
			ecx_143 = 0x30;
			bLoc30_1108 = 0x05;
			goto l0807193E;
		}
		goto l08071BD8;
	}
	ecx_143 = 0x30;
	dwLoc48_1111.u0 = 0x00;
	dwLoc44_1100 = *((char *) g_a80B1C38 + dwArg0C * 0x04);
	bLoc30_1108 = (cu8) *((word32) dwArg0C.u0 + 0x080B1BFE);
	edi_129.u0 = 0x00;
	dwLoc38_1094 = g_ptr80CE084;
l0807194C:
	int32 edx_390 = edi_129 - 0x01;
	Eq_2 ebx_393 = esi_107;
	word32 dwLoc40_796 = 0x00;
	Eq_2 eax_397 = g_t80CE08C;
	eax_1116.u0 = 0x00;
	do
	{
		Eq_2 edx_438;
		word32 edx_1195 = ecx_143 - 0x30;
		byte cl_412 = (byte) ecx_143;
		if ((byte) edx_1195 > 0x09)
		{
			if (edi_129 == 0x00)
			{
l080719B0:
				if ((*((word32) eax_397 + (ecx_143 * 0x02 + 1)) & 0x04) == 0x00)
					break;
				edx_1195 = dwLoc38_1094[ecx_143] - 55;
				goto l080719C5;
			}
			Eq_2 edx_415 = 0x00;
			do
			{
				if (Mem414[ebp_212 + edx_415:byte] != Mem414[ebx_393 + edx_415:byte])
				{
					ecx_143 = (word32) cl_412;
					if (edi_129 == edx_415)
						break;
					goto l080719B0;
				}
				edx_415 = (word32) edx_415 + 1;
			} while (edx_415 != edi_129);
			edx_438 = (word32) ebx_393 + edx_390;
			goto l0807198F;
		}
l080719C5:
		cu8 dl_451 = (byte) edx_1195;
		Eq_44571 ecx_453 = (word32) dl_451;
		if (ecx_453 >= dwArg0C)
			break;
		if (eax_1116 > dwLoc44_1100 || eax_1116 == dwLoc44_1100 && dl_451 > bLoc30_1108)
		{
			ecx_143 = (word32) *((word32) ebx_393 + 1);
			dwLoc40_796 = 0x01;
			ebx_393 = (word32) ebx_393 + 1;
			if ((byte) ecx_143 == 0x00)
				break;
		}
		else
		{
			edx_438 = ebx_393;
			eax_1116 = (word32) ecx_453.u0 + eax_1116 *s dwArg0C;
l0807198F:
			ecx_143 = (word32) *((word32) edx_438 + 1);
			ebx_393 = (word32) edx_438 + 1;
			if ((byte) ecx_143 == 0x00)
				break;
		}
	} while (ebx_393 != dwLoc48_1111);
	if (ebx_393 != esi_107)
	{
		if (dwArg08 != null)
			*dwArg08 = (union Eq_2 *) ebx_393;
		if (dwLoc40_796 == 0x00)
		{
			if (dwLoc24_704 == 0x00)
			{
				if (eax_1116 < 0x00)
				{
					gs->tFFFFFFE0.u0 = 0x22;
					eax_1116.u0 = 0x7FFFFFFF;
				}
				return eax_1116;
			}
			else
			{
				if (eax_1116 <= 0x80000000)
					return -eax_1116;
				gs->tFFFFFFE0.u0 = 0x22;
				eax_1116.u0 = 0x80000000;
				return eax_1116;
			}
		}
		else
		{
			gs->tFFFFFFE0.u0 = 0x22;
			eax_1116 = 0x00 - (dwLoc24_704 < 0x01) + 0x80000000;
			return eax_1116;
		}
	}
l08071C25:
	if (dwArg08 == null)
	{
l08071D02:
		eax_1116.u0 = 0x00;
		return eax_1116;
	}
	if (esi_107 - dwArg04 > 0x01 && (g_ptr80CE084[(int32) (*((word32) esi_107 - 1))] == 88 && *((word32) esi_107 - 2) == 0x30))
	{
		*dwArg08 = (union Eq_2 *) (esi_107 - 0x01);
		goto l08071D02;
	}
l08071C54:
	*dwArg08 = (union Eq_2 *) dwArg04;
	eax_1116.u0 = 0x00;
	return eax_1116;
}

// 08071E20: void __strtol_l(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack Eq_44571 dwArg0C, Stack (ptr32 Eq_11467) dwArg10)
void __strtol_l(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, Eq_44571 dwArg0C, struct Eq_11467 * dwArg10)
{
	____strtol_l_internal(gs, dwArg04, dwArg08, dwArg0C, 0x00, dwArg10);
}

// 08071E50: void read_int(Register (ptr32 (ptr32 byte)) eax)
void read_int(byte ** eax)
{
	byte * ebx_19 = *eax;
	byte * ebx_21 = ebx_19 + 1;
	Eq_74545 ecx_22 = (word32) *ebx_19 - 0x30;
	while (true)
	{
		*eax = (byte **) ebx_21;
		Eq_74555 edx_27 = (word32) *ebx_21;
		if (edx_27 > 0x39)
			break;
		if (ecx_22 >= 0x00)
		{
			if (ecx_22 > 0x0CCCCCCC)
				ecx_22.u0 = ~0x00;
			else
			{
				ui32 ebp_47 = ecx_22 * 0x05;
				ecx_22 = edx_27 - 0x30 + ebp_47 * 0x02;
				if (0x7FFFFFFF - (edx_27 - 0x30) < ebp_47 * 0x02)
					ecx_22.u0 = ~0x00;
			}
		}
		++ebx_21;
	}
}

// 08071EB0: void group_number(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack (ptr32 byte) dwArg04, Stack Eq_2 dwArg08)
void group_number(Eq_2 eax, Eq_2 ecx, Eq_2 edx, byte * dwArg04, Eq_2 dwArg08)
{
	word32 esi_23 = (word32) *dwArg04;
	if ((byte) (esi_23 - 0x01) > 0x7D)
		return;
	Eq_2 esi_51 = ecx - edx;
	word32 ecx_254;
	word32 edx_255;
	Eq_2 eax_35 = strlen(dwArg08, out ecx_254, out edx_255);
	word32 edx_256;
	memmove(eax, edx, esi_51, out edx_256);
	Eq_2 edi_166 = ecx;
	word32 esi_55 = esi_51 + eax;
	int32 ecx_119 = (int32) (byte) esi_23;
	if (eax >= esi_55)
		return;
	struct Eq_74618 * eax_104 = dwArg04 + 1;
	Eq_2 esi_106 = esi_55;
	while (true)
	{
		while (true)
		{
			esi_106 -= (byte *) 0x01;
			*((word32) edi_166 - 1) = *esi_106;
			Eq_2 ebx_109 = edi_166 - 0x01;
			--ecx_119;
			if (ecx_119 == 0x00)
				break;
			if (eax >= esi_106)
				return;
			edi_166 = ebx_109;
		}
		if (eax >= esi_106)
			return;
		if (ebx_109 - esi_106 <= eax_35)
			break;
		Eq_2 ecx_103 = eax_35;
		do
		{
			--ecx_103;
			--ebx_109;
			Mem115[ebx_109 + 0x00:byte] = Mem112[dwArg08 + ecx_103:byte];
		} while (ecx_103 > 0x00);
		ecx_119 = (int32) eax_104->b0000;
		ci8 cl_123 = (byte) ecx_119;
		if (cl_123 == 0x7F || cl_123 < 0x00)
			break;
		if (cl_123 != 0x00)
		{
			++eax_104;
			edi_166 = ebx_109;
		}
		else
		{
			ecx_119 = (int32) eax_104->bFFFFFFFF;
			edi_166 = ebx_109;
		}
	}
	word32 edx_257;
	memmove(ebx_109, esi_106, eax - esi_106, out edx_257);
}

// 08071FE0: void _i18n_number_rewrite(Register Eq_2 eax, Register Eq_2 ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void _i18n_number_rewrite(Eq_2 eax, Eq_2 ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	__align(fp - 4);
	struct Eq_74687 * eax_42 = wctrans(gs, 0x080B1CCC);
	Eq_2 eax_58 = __towctrans(0x2E, eax_42);
	__towctrans(44, eax_42);
	struct Eq_74704 * ebp_14 = fp - 0x0C;
	word32 edi_143 = edx;
	Eq_2 esi_145 = eax;
	Eq_2 edx_152 = fp - 0x0464;
	if (eax_42 != null)
	{
		struct Eq_74714 * ebp_102;
		word32 esi_526;
		word32 edi_527;
		int32 eax_101 = wcrtomb(gs, fp - 0x4A, eax_58, fp - 0x0464, dwLoc0488, ecx, out ebp_102, out esi_526, out edi_527);
		Eq_2 edx_114 = ebp_102->tFFFFFB98;
		Eq_2 ecx_115 = ebp_102->tFFFFFB94;
		if (eax_101 != ~0x00)
			ebp_102 - 0x3E + eax_101 = (byte *) 0x00;
		else
			ebp_102->wFFFFFFC2 = 0x2E;
		ebp_102->tFFFFFB98 = edx_114;
		ebp_102->dwFFFFFBA8 = 0x00;
		ebp_102->dwFFFFFBAC = 0x00;
		int32 eax_139 = wcrtomb(gs, ebp_102 - 0x2D, ecx_115, edx_114, dwLoc0488, ecx, out ebp_14, out esi_145, out edi_143);
		edx_152 = ebp_14->tFFFFFB98;
		if (eax_139 != ~0x00)
			ebp_14 - 0x2D + eax_139 = (byte *) 0x00;
		else
			ebp_14->wFFFFFFD3 = 44;
	}
	ebp_14->dwFFFFFBAC = 0x0400;
	Eq_2 eax_166 = ebp_14 - 0x0448;
	ebp_14->tFFFFFB94 = eax_166;
	ebp_14->tFFFFFBA8 = eax_166;
	Eq_2 edi_163 = edi_143 - esi_145;
	word32 edx_529;
	word32 ecx_528;
	if ((byte) (uint32) __libc_scratch_buffer_set_array_size(gs, edx_152, edi_163, 0x01, out ecx_528, out edx_529) != 0x00)
	{
		Eq_2 ecx_191 = ebp_14->tFFFFFBA8;
		ebp_14->tFFFFFB90 = ecx_191;
		word32 edx_530;
		Eq_2 eax_202 = __mempcpy(ecx_191, esi_145, edi_163, out edx_530);
		Eq_2 esi_211 = ebp_14->tFFFFFBA0;
		ebp_14->tFFFFFB8C = ebp_14 - 0x2D;
		Eq_2 ecx_217 = ebp_14->tFFFFFB90;
		ebp_14->tFFFFFB98.u0 = ~0x2F;
		Eq_2 edi_214 = eax_202;
l080720F9:
		for (--edi_214; ecx_217 <= edi_214; --edi_214)
		{
			int32 eax_227 = (int32) *edi_214;
			byte al_280 = (byte) eax_227;
			if ((byte) (eax_227 - 0x30) <= 0x09)
			{
				ebp_14->tFFFFFBA0 = ecx_217;
				Eq_2 ebx_242 = (gs->*ebp_14->tFFFFFB98)->ptr0000->a0008[eax_227].t0000;
				word32 edx_534;
				word32 ecx_533;
				Eq_2 eax_245 = strlen(ebx_242, out ecx_533, out edx_534);
				ecx_217 = ebp_14->tFFFFFBA0;
				esi_211 -= eax_245;
				int32 edx_258 = eax_245 - 0x01;
				if (eax_245 != 0x00)
				{
					do
					{
						*((word32) esi_211 + edx_258) = *((word32) ebx_242 + edx_258);
						--edx_258;
					} while (edx_258 != ~0x00);
				}
				goto l080720F9;
			}
			if (ebp_14->dwFFFFFBA4 != 0x00 && (byte) (eax_227 & ~0x02) == 44)
			{
				Eq_2 ebx_282 = ebp_14 - 0x3E;
				if (al_280 != 0x2E)
					ebx_282 = ebp_14->tFFFFFB8C;
				ebp_14->tFFFFFBA0 = ecx_217;
				word32 ecx_537;
				word32 edx_538;
				Eq_2 eax_294 = strlen(ebx_282, out ecx_537, out edx_538);
				ecx_217 = ebp_14->tFFFFFBA0;
				esi_211 -= eax_294;
				int32 edx_307 = eax_294 - 0x01;
				if (eax_294 != 0x00)
				{
					do
					{
						*((word32) esi_211 + edx_307) = *((word32) ebx_282 + edx_307);
						--edx_307;
					} while (edx_307 != ~0x00);
				}
				goto l080720F9;
			}
			*((word32) esi_211 - 1) = al_280;
			--esi_211;
		}
		Eq_2 eax_335 = ebp_14->tFFFFFBA8;
		if (eax_335 != ebp_14->tFFFFFB94)
		{
			word32 ecx_535;
			word32 edx_536;
			free(gs, dwLoc0498, eax_335, out ecx_535, out edx_536);
		}
	}
	if ((ebp_14->dwFFFFFFE4 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_532;
	word32 ecx_531;
	__stack_chk_fail(out ecx_531, out edx_532);
	_IO_helper_overflow(dwArg04, dwArg08);
}

// 080722A0: void _IO_helper_overflow(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      _i18n_number_rewrite
void _IO_helper_overflow(Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 ecx_103 = *((word32) dwArg04 + 20);
	Eq_2 eax_22 = *((word32) dwArg04 + 16);
	Eq_2 esp_18 = fp - 44;
	Eq_2 esi_24 = ecx_103 - eax_22;
	if (esi_24 != 0x00)
	{
		if (*((word32) *((word32) dwArg04 + 0x0098) + 0x0094) >= 135066356)
		{
			word32 edx_197;
			word32 ecx_196;
			_IO_vtable_check(out ecx_196, out edx_197);
			esp_18.u0 = <invalid>;
			eax_22 = *((word32) dwArg04 + 16);
		}
		struct Eq_75036 * esp_47 = esp_18 - 0x04;
		esp_47->tFFFFFFFC = esi_24;
		esp_47->tFFFFFFF8 = eax_22;
		esp_47->tFFFFFFF4 = esp_47->t0010;
		struct Eq_75051 * eax_58 = esp_47->ptr000C;
		up32 eax_65;
		eax_58->ptr001C();
		if (eax_65 > ~0x01)
			return;
		Eq_2 eax_73 = *((word32) dwArg04 + 16);
		esp_47->tFFFFFFFC = esi_24 - eax_65;
		esp_47->tFFFFFFF8 = (word32) eax_73 + eax_65;
		esp_47->tFFFFFFF4 = eax_73;
		word32 edx_198;
		memmove(esp_47->tFFFFFFF4, esp_47->tFFFFFFF8, esp_47->tFFFFFFFC, out edx_198);
		ecx_103 = *((word32) dwArg04 + 20) - eax_65;
		*((word32) dwArg04 + 20) = ecx_103;
	}
	Eq_2 eax_100 = (word32) (byte) dwArg08;
	if (*((word32) dwArg04 + 24) <= ecx_103)
	{
		word32 edx_200;
		word32 ecx_199;
		__overflow(dwArg04, eax_100, out ecx_199, out edx_200);
	}
	else
	{
		*((word32) dwArg04 + 20) = (word32) ecx_103 + 1;
		*ecx_103 = (byte) dwArg08;
	}
}

// 08072380: Register Eq_2 printf_positional(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      vfprintf
Eq_2 printf_positional(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	__align(fp - 4);
	struct Eq_75130 * ebp_1027 = fp - 0x0C;
	struct Eq_75126 * esp_1016 = fp - 0x0944;
	if (dwArg20 == ~0x00)
	{
		byte al_72 = **((char *) *gs->ptrFFFFFFDC + 44);
		if (al_72 == 0x00 || al_72 == 0x7F)
			;
	}
	Eq_2 ecx_1009;
	Eq_2 edx_1014;
	struct Eq_75126 * esp_1575;
	Eq_2 edi_1040;
	struct Eq_75126 * esp_1063;
	Eq_2 edi_1058;
	Eq_2 esi_1140;
	Eq_2 edi_104;
	if (*dwArg14 != 0x00)
	{
		edi_104.u0 = 0x00;
		ebx.u0 = 0x00;
		Eq_2 esi_121 = dwArg14;
		while (true)
		{
			Eq_2 edx_108 = (word32) ebp_1027->tFFFFF780 + edi_104 *s 0x34;
			struct Eq_75184 * esp_111 = esp_1016 - 4;
			esp_111->t0000 = ebp_1027->tFFFFF778;
			esp_111->tFFFFFFFC = edx_108;
			esp_111->tFFFFFFF8 = ebx;
			esp_111->tFFFFFFF4 = esi_121;
			ebp_1027->tFFFFF784 = edx_108;
			Eq_2 esp_131 = <invalid>;
			word32 ebx_126;
			ebx = ebx_126 + __parse_one_specmb(esp_111->tFFFFFFF4, esp_111->tFFFFFFF8, esp_111->tFFFFFFFC, esp_111->t0000, out ebx_126, out ebp_1027, out edi_104);
			esp_1016 = (word32) esp_131 + 16;
			esi_121 = *((word32) ebp_1027->tFFFFF784 + 24);
			if (*esi_121 == 0x00)
				break;
			if (ebp_1027->tFFFFF77C != edi_104)
				continue;
			*esp_131 = ebp_1027->ptrFFFFF768;
			esp_1016 = (word32) esp_131 + 16;
			if ((byte) __libc_scratch_buffer_grow_preserve(gs, dwArg00, out ecx_1009, out edx_1014) == 0x00)
				goto l08072AC0;
			ebp_1027->tFFFFF780 = ebp_1027->tFFFFF7A8;
			ebp_1027->tFFFFF77C = SLICE(ebp_1027->dwFFFFF7AC *64 0x4EC4EC4F, word32, 32) >> 0x04;
		}
		if (ebp_1027->tFFFFF794 >= ebx)
			ebx = ebp_1027->tFFFFF794;
		ebp_1027->tFFFFF784 = ebx;
	}
	else
		edi_104.u0 = 0x00;
	Eq_2 esi_150 = ebp_1027->tFFFFF784;
	struct Eq_75341 * esp_155 = esp_1016 - 0x04;
	esp_155->tFFFFFFFC.u0 = 0x14;
	esp_155->tFFFFFFF8 = esi_150;
	esp_155->tFFFFFFF4 = ebp_1027 - 0x0448;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	esp_1016 = (struct Eq_75126 *) ((char *) &esp_155->tFFFFFFFC + 8);
	if ((byte) (uint32) __libc_scratch_buffer_set_array_size(gs, dwArg00, stackArg8, dwArg08, out ecx_1009, out edx_1014) == 0x00)
	{
l08072AC0:
		esi_1140.u0 = ~0x00;
l08072AC5:
		struct Eq_75248 * eax_622 = ebp_1027->ptrFFFFFBB8;
		if (eax_622 != ebp_1027->ptrFFFFF734)
		{
			ebx = ebp_1027->tFFFFF774;
			esp_1016->dwFFFFFFF0 = eax_622;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			free(gs, stackArg0, dwArg00, out ecx_1009, out edx_1014);
		}
		Eq_2 eax_645 = ebp_1027->tFFFFF7A8;
		if (eax_645 != ebp_1027->tFFFFF760)
		{
			ebx = ebp_1027->tFFFFF774;
			esp_1016->dwFFFFFFF0 = (word32) eax_645;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			free(gs, stackArg0, dwArg00, out ecx_1009, out edx_1014);
		}
		edi_1040 = ebp_1027->dwFFFFFFE4 ^ gs->dw0014;
		if (edi_1040 == 0x00)
		{
			ecxOut = ecx_1009;
			edxOut = edx_1014;
			return esi_1140;
		}
		Eq_2 ecx_684;
		word32 edx_3775;
		__stack_chk_fail(out ecx_684, out edx_3775);
		if (ecx_684 <= 0x00)
		{
l080733B7:
			ecx_1009.u0 = 0x00;
			if (ebp_1027->tFFFFF750 != 0x00)
			{
				Eq_2 edx_768 = ebp_1027->tFFFFF770;
				Eq_2 eax_769 = *((word32) edx_768 + 20);
				if (eax_769 < *((word32) edx_768 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_769 + 1;
					*eax_769 = 0x2D;
					edx_1014 = (word32) eax_769 + 1;
					goto l080733E6;
				}
				ebp_1027->tFFFFF77C.u0 = 0x00;
				struct Eq_78038 * esp_772 = esp_1016 - (struct Eq_78039 *) 0x08;
				esp_772->tFFFFFFFC.u0 = 0x2D;
				esp_772->tFFFFFFF8 = edx_768;
			}
			else if (ebp_1027->tFFFFF74C != 0x00)
			{
				Eq_2 esi_753 = ebp_1027->tFFFFF770;
				Eq_2 eax_754 = *((word32) esi_753 + 20);
				if (eax_754 < *((word32) esi_753 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_754 + 1;
					*eax_754 = 0x2B;
					edx_1014 = (word32) eax_754 + 1;
					goto l080733E6;
				}
				ebp_1027->tFFFFF77C.u0 = 0x00;
				struct Eq_78093 * esp_757 = esp_1016 - (struct Eq_78094 *) 0x08;
				esp_757->tFFFFFFFC.u0 = 0x2B;
				esp_757->tFFFFFFF8 = esi_753;
			}
			else
			{
				if (ebp_1027->tFFFFF710 == 0x00)
				{
l08073400:
					if (ebp_1027->tFFFFF744 == 0x00 || (ebp_1027->tFFFFF740 != 0x10 || (ebp_1027->dwFFFFF708 & 0x01) == 0x00))
					{
l08073492:
						word32 edx_906 = Mem902[ebp_1027 + ~0x087B:word32] + ecx_1009;
						if (edx_906 <= 0x00)
						{
l080734A2:
							if (ebp_1027->tFFFFF76C < 0x00)
							{
								edi_1058 = ebp_1027->tFFFFF774;
								struct Eq_77751 * esp_970 = esp_1016 - (struct Eq_77752 *) 4;
								esp_970->a0000[0].t0000 = (word32) edi_1058 - 0x0001C23C;
								esp_970->tFFFFFFFC.u0 = 0x07E1;
								esp_1063 = esp_970 - (struct Eq_77763 *) 4;
								goto l08074C01;
							}
							Eq_2 edx_1005 = *((word32) ebp_1027->tFFFFF770 + 0x0094);
							Eq_2 eax_1008 = edx_1005 - ebp_1027->dwFFFFF6F4;
							if (ebp_1027->tFFFFF6F0 <= eax_1008)
							{
								ebp_1027->tFFFFF784 = edx_1005;
								word32 edx_3774;
								eax_1008 = _IO_vtable_check(out ecx_1009, out edx_3774);
								edx_1005 = ebp_1027->tFFFFF784;
							}
							struct Eq_77792 * esp_993 = esp_1016 - (struct Eq_77793 *) 0x04;
							esp_993->tFFFFFFFC = ebx;
							esp_993->tFFFFFFF8 = ebp_1027->tFFFFF754;
							esp_993->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
							Eq_2 eax_1012;
							(*((word32) edx_1005 + 28))();
							esp_1016 = esp_993 + 0x04;
							if (ebx == eax_1012)
							{
								ecx_1009 = ebp_1027->tFFFFF76C;
								if (0x7FFFFFFF - ecx_1009 >= ebx)
								{
									ecx_1009 += ebx;
									ebp_1027->tFFFFF76C = ecx_1009;
l08072FA7:
									if (ebp_1027->tFFFFF75C != 0x00)
									{
										esp_1016->dwFFFFFFF0 = (word32) ebp_1027->tFFFFF75C;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg0 = <invalid>;
										word32 edx_3758;
										free(gs, stackArg0, dwArg00, out ecx_1009, out edx_3758);
									}
									if (ebp_1027->tFFFFF76C >= 0x00)
									{
										ebx = *((word32) ebp_1027->tFFFFF770 + 0x0094);
										if (ebp_1027->ptrFFFFF714 <= ebx - ebp_1027->dwFFFFF718)
										{
											word32 edx_3759;
											_IO_vtable_check(out ecx_1009, out edx_3759);
										}
										Eq_2 edx_1107 = *((word32) edi_1040 + 20);
										struct Eq_77180 * esp_1110 = esp_1016 - (struct Eq_77181 *) 0x04;
										Eq_2 eax_1111 = *((word32) edi_1040 + 24) - edx_1107;
										esp_1110->tFFFFFFFC = eax_1111;
										esp_1110->tFFFFFFF8 = edx_1107;
										esp_1110->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
										Eq_2 eax_1126;
										(*((word32) ebx + 28))();
										edx_1014 = *((word32) edi_1040 + 24) - *((word32) edi_1040 + 20);
										esp_1016 = esp_1110 + 0x04;
										if (edx_1014 == eax_1126)
										{
											if (edx_1014 <= 0x7FFFFFFF - ebp_1027->tFFFFF76C)
											{
												ebp_1027->tFFFFF764 = (word32) ebp_1027->tFFFFF764 + 1;
												Eq_2 eax_1146 = ebp_1027->tFFFFF764;
												Mem1148[ebp_1027 + ~0x0893:word32] = Mem1144[ebp_1027 + ~0x0893:word32] + edx_1014;
												edi_1040 = (word32) edi_1040 + 52;
												if (eax_1146 >= ebp_1027->tFFFFF70C)
													goto l0807303F;
												goto l080727BD;
											}
											gs->tFFFFFFE0.u0 = 0x4B;
											esi_1140.u0 = ~0x00;
											goto l08072AC5;
										}
										goto l08072AC0;
									}
									edi_1058 = ebp_1027->tFFFFF774;
									struct Eq_77143 * esp_1061 = esp_1016 - (struct Eq_77144 *) 4;
									esp_1061->a0000[0].t0000 = (word32) edi_1058 - 0x0001C23C;
									esp_1061->tFFFFFFFC.u0 = 0x0809;
									esp_1063 = esp_1061 - (struct Eq_77155 *) 4;
l08074C01:
									while (true)
									{
										struct Eq_77384 * esp_1068 = esp_1063 - (struct Eq_77385 *) 4;
										esp_1068->a0000[0].t0000 = (word32) edi_1058 - 0x0001C322;
										esp_1068->tFFFFFFFC = (word32) edi_1058 - 0x0001C28C;
										word32 edx_3761;
										word32 ecx_3760;
										__assert_fail(out ecx_3760, out edx_3761);
										edi_1058 = ebp_1027->tFFFFF774;
										esp_1068->tFFFFFFF8 = (word32) edi_1058 - 0x0001C23C;
										esp_1068->dwFFFFFFF4 = 0x07E2;
										esp_1063 = esp_1068 - (struct Eq_77415 *) 0x0C;
									}
								}
								goto l08072A82;
							}
							goto l08072A95;
						}
						ebp_1027->tFFFFF784 = edx_906;
						struct Eq_77695 * esp_911 = esp_1016 - (struct Eq_77696 *) 0x04;
						esp_911->tFFFFFFFC = edx_906;
						esp_911->tFFFFFFF8.u0 = 0x30;
						esp_911->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						word32 esi_3772;
						word32 edi_3773;
						word32 edx_3769;
						word32 ebp_3771;
						word32 ebx_3770;
						Eq_2 eax_934 = _IO_padn(gs, dwArg00, stackArg8, dwArg08, out ecx_1009, out edx_3769, out ebx_3770, out ebp_3771, out esi_3772, out edi_3773);
						edx_1014 = ebp_1027->tFFFFF784;
						esp_1016 = esp_911 + 0x04;
						if (edx_1014 == eax_934)
						{
							ecx_1009 = ebp_1027->tFFFFF76C;
							if (ecx_1009 <= 0x7FFFFFFE)
							{
								if (0x7FFFFFFF - ecx_1009 >= edx_1014)
								{
									ecx_1009 += edx_1014;
									ebp_1027->tFFFFF76C = ecx_1009;
									goto l080734A2;
								}
								goto l08072A82;
							}
							goto l08074B50;
						}
						goto l08072A95;
					}
					Eq_2 esi_827 = ebp_1027->tFFFFF770;
					Eq_2 eax_828 = *((word32) esi_827 + 20);
					if (eax_828 < *((word32) esi_827 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_828 + 1;
						*eax_828 = 0x30;
						edx_1014 = (word32) eax_828 + 1;
l08073441:
						if (ebp_1027->tFFFFF76C != 0x7FFFFFFF)
						{
							Eq_2 esi_860 = ebp_1027->tFFFFF770;
							Eq_2 eax_861 = *((word32) esi_860 + 20);
							if (eax_861 < *((word32) esi_860 + 24))
							{
								*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_861 + 1;
								edx_1014 = (word32) ebp_1027->bFFFFF749;
								*eax_861 = (byte) edx_1014;
l08073478:
								Eq_2 eax_895 = ebp_1027->tFFFFF76C;
								if (eax_895 != 0x7FFFFFFE)
								{
									ebp_1027->tFFFFF76C = (word32) eax_895 + 2;
									goto l08073492;
								}
								goto l08072A95;
							}
							Eq_2 eax_864 = (word32) ebp_1027->bFFFFF749;
							ebp_1027->tFFFFF77C = ecx_1009;
							struct Eq_77568 * esp_866 = esp_1016 - (struct Eq_77569 *) 0x08;
							esp_866->tFFFFFFFC = eax_864;
							esp_866->tFFFFFFF8 = esi_860;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							word32 ecx_3767;
							word32 eax_879 = __overflow(dwArg00, stackArg8, out ecx_3767, out edx_1014);
							esp_1016 = esp_866 + 0x08;
							ecx_1009 = ebp_1027->tFFFFF77C;
							if (eax_879 != ~0x00)
								goto l08073478;
						}
						goto l08072A95;
					}
					ebp_1027->tFFFFF77C = ecx_1009;
					struct Eq_77511 * esp_832 = esp_1016 - (struct Eq_77512 *) 0x08;
					esp_832->tFFFFFFFC.u0 = 0x30;
					esp_832->tFFFFFFF8 = esi_827;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					word32 ecx_3765;
					word32 eax_844 = __overflow(dwArg00, stackArg8, out ecx_3765, out edx_1014);
					esp_1016 = esp_832 + 0x08;
					ecx_1009 = ebp_1027->tFFFFF77C;
					if (eax_844 != ~0x00)
						goto l08073441;
					goto l08072A95;
				}
				Eq_2 esi_736 = ebp_1027->tFFFFF770;
				Eq_2 eax_737 = *((word32) esi_736 + 20);
				if (eax_737 < *((word32) esi_736 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_737 + 1;
					*eax_737 = 0x20;
					edx_1014 = (word32) eax_737 + 1;
					goto l080733E6;
				}
				ebp_1027->tFFFFF77C.u0 = 0x00;
				struct Eq_78132 * esp_741 = esp_1016 - (struct Eq_78133 *) 0x08;
				esp_741->tFFFFFFFC.u0 = 0x20;
				esp_741->tFFFFFFF8 = esi_736;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg8 = <invalid>;
			word32 ecx_3783;
			word32 eax_795 = __overflow(dwArg00, stackArg8, out ecx_3783, out edx_1014);
			ecx_1009 = ebp_1027->tFFFFF77C;
			if (eax_795 != ~0x00)
			{
l080733E6:
				Eq_2 eax_810 = ebp_1027->tFFFFF76C;
				if (eax_810 != 0x7FFFFFFF)
				{
					ebp_1027->tFFFFF76C = (word32) eax_810 + 1;
					goto l08073400;
				}
				goto l08072A95;
			}
			goto l08072A95;
		}
		ebp_1027->tFFFFF77C = ecx_684;
		struct Eq_77958 * esp_689 = esp_1016 - (struct Eq_77959 *) 0x04;
		esp_689->tFFFFFFFC = ecx_684;
		esp_689->tFFFFFFF8.u0 = 0x20;
		esp_689->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		word32 ecx_3777;
		word32 ebx_3778;
		word32 esi_3780;
		word32 ebp_3779;
		word32 edi_3781;
		Eq_2 eax_699 = _IO_padn(gs, dwArg00, stackArg8, dwArg08, out ecx_3777, out edx_1014, out ebx_3778, out ebp_3779, out esi_3780, out edi_3781);
		ecx_1009 = ebp_1027->tFFFFF77C;
		esp_1016 = esp_689 + 0x04;
		if (eax_699 == ecx_1009)
		{
			if (ebp_1027->tFFFFF76C > 0x7FFFFFFE)
			{
l08074B50:
				edi_1040 = ebp_1027->tFFFFF774;
				struct Eq_77926 * esp_950 = esp_1016 - (struct Eq_77927 *) 4;
				esp_950->a0000[0].t0000 = (word32) edi_1040 - 0x0001C23C;
				esp_950->tFFFFFFFC.u0 = 0x07E1;
				esp_1575 = esp_950 - (struct Eq_77938 *) 4;
l08074B62:
				struct Eq_77417 * esp_2319 = esp_1575 - (struct Eq_77418 *) 4;
				esp_2319->a0000[0].t0000 = (word32) edi_1040 - 0x0001C322;
				esp_2319->tFFFFFFFC = (word32) edi_1040 - 115388;
				word32 edx_3763;
				word32 ecx_3762;
				__assert_fail(out ecx_3762, out edx_3763);
				esp_1016 = esp_2319 - (struct Eq_77436 *) 4;
				ecx_1009.u0 = 0x00;
				goto l08073400;
			}
			Eq_2 esi_709 = ebp_1027->tFFFFF76C;
			if (0x7FFFFFFF - esi_709 >= ecx_1009)
			{
				Mem718[ebp_1027 + ~0x0893:word32] = esi_709 + ecx_1009;
				goto l080733B7;
			}
			goto l08072A82;
		}
		goto l08072A95;
	}
	struct Eq_75248 * ecx_194 = ebp_1027->ptrFFFFFBB8;
	ebp_1027->ptrFFFFF768 = ecx_194;
	esp_155->tFFFFFFFC = esi_150 * 0x04;
	Eq_2 ecx_198 = ecx_194 + esi_150;
	ebp_1027->tFFFFF77C = ecx_198;
	Eq_2 ecx_203 = (word32) ecx_198 + esi_150 * 0x04;
	Eq_2 eax_204 = ebp_1027->tFFFFF770;
	ebp_1027->tFFFFF778 = ecx_203;
	esp_155->tFFFFFFF8 = *((word32) eax_204 + 60) << 0x1D >> 0x1F;
	esp_155->tFFFFFFF4 = ecx_203;
	word32 ecx_3737;
	memset(esp_155->tFFFFFFF4, esp_155->tFFFFFFF8, esp_155->tFFFFFFFC, out ecx_3737, out edx_1014);
	esp_1016 = (struct Eq_75126 *) ((char *) &esp_155->tFFFFFFFC + 8);
	ecx_1009 = ebp_1027->tFFFFF778;
	if (edi_104 != 0x00)
	{
		Eq_2 eax_232 = ebp_1027->tFFFFF780;
		ebp_1027->tFFFFF754 = edi_104;
		ebx = eax_232;
		Eq_2 esi_235 = (word32) eax_232 + edi_104 *s 0x34;
		do
		{
			ui32 eax_241 = *((word64) ebx.u0 + 32);
			if (eax_241 != ~0x00)
				((word32) ecx_1009 + eax_241 * 0x04)->u0 = 0x00;
			ui32 eax_248 = *((word64) ebx.u0 + 28);
			if (eax_248 != ~0x00)
				((word32) ecx_1009 + eax_248 * 0x04)->u0 = 0x00;
			Eq_2 eax_255 = *((word64) ebx.u0 + 44);
			if (eax_255 != 0x00)
			{
				if (eax_255 != 0x01)
				{
					ui32 ecx_280 = *((word32) ebx + 36);
					ebp_1027->tFFFFF778 = *((word32) ebx + 8);
					struct Eq_77864 * esp_290 = esp_1016 - (struct Eq_77865 *) 4;
					esp_290->a0000[0].t0000 = (word32) ebp_1027->tFFFFF77C + ecx_280 * 0x04;
					Eq_2 edx_286 = (word64) ecx_1009.u0 + ecx_280 * 0x04;
					Eq_2 ecx_292 = ebp_1027->tFFFFF778;
					esp_290->tFFFFFFFC = edx_286;
					esp_290->tFFFFFFF8 = eax_255;
					Eq_2 eax_297 = ebp_1027->tFFFFF774;
					esp_290->dwFFFFFFF4 = (word32) ebx;
					<anonymous> * eax_302[] = *((word32) eax_297 + 8168);
					eax_302[ecx_292]();
					ebx = (word32) ebx + 52;
					if (esi_235 == ebx)
						break;
					continue;
				}
				Eq_2 ecx_266 = ebp_1027->tFFFFF77C;
				*((word64) ecx_1009.u0 + *((word32) ebx + 36) * 0x04) = *((word32) ebx + 40);
				edx_1014 = *((word32) ebx + 48);
				*((word32) ecx_266 + *((word32) ebx + 36) * 0x04) = edx_1014;
			}
			ebx = (word32) ebx + 52;
		} while (esi_235 != ebx);
		edi_104 = ebp_1027->tFFFFF754;
		if (ebp_1027->tFFFFF784 == 0x00)
		{
l08072728:
			if (edi_104 <= ebp_1027->tFFFFF764)
			{
l0807303F:
				esi_1140 = ebp_1027->tFFFFF76C;
				goto l08072AC5;
			}
			word32 eax_576 = ebp_1027->dwFFFFF72C;
			Eq_2 ecx_577 = ebp_1027->tFFFFF780;
			ebp_1027->tFFFFF70C = edi_104;
			ebp_1027->tFFFFF704 = eax_576 + 1000;
			edi_1040 = (word32) ecx_577 + ebp_1027->tFFFFF764 *s 0x34;
			ebp_1027->dwFFFFF6E4 = 0x080CEFA0;
			ebp_1027->dwFFFFF6E0 = 0x0354;
			ebp_1027->dwFFFFF6D4 = 0x080CEFA0;
			ebp_1027->dwFFFFF6D0 = 0x0354;
			ebp_1027->dwFFFFF6DC = 0x080CEFA0;
			ebp_1027->dwFFFFF6D8 = 0x0354;
			ebp_1027->dwFFFFF6FC = 0x080CEFA0;
			ebp_1027->dwFFFFF6F8 = 0x0354;
			ebp_1027->dwFFFFF6F4 = 0x080CEFA0;
			ebp_1027->tFFFFF6F0.u0 = 0x0354;
			ebp_1027->dwFFFFF718 = 0x080CEFA0;
			ebp_1027->ptrFFFFF714 = 0x0354;
l080727BD:
			ui32 eax_1153 = (word32) *((word32) edi_1040 + 0x0C);
			word32 edx_1166 = (word32) *((word32) edi_1040 + 0x0D);
			ebp_1027->tFFFFF754 = (byte) (SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x03) & 0x01);
			ebp_1027->tFFFFF778 = SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x05) & 0x01;
			Eq_76171 esi_1175 = *((word32) edi_1040 + 16);
			ebp_1027->tFFFFF750 = (byte) (SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x04) & 0x01);
			ebp_1027->tFFFFF738 = esi_1175;
			ebp_1027->tFFFFF74C = (byte) (SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x06) & 0x01);
			ebp_1027->bFFFFF74A = (byte) eax_1153 >> 0x07;
			ebp_1027->tFFFFF74B = (byte) (eax_1153 & 0x01);
			ebp_1027->tFFFFF744 = (byte) (SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x01) & 0x01);
			ebp_1027->bFFFFF748 = (byte) (SEQ(SLICE(edx_1166, word24, 8), (byte) edx_1166 >> 0x03) & 0x01);
			ui32 edx_1219 = *((word32) edi_1040 + 32);
			ebp_1027->tFFFFF740 = (byte) (SEQ(SLICE(edx_1166, word24, 8), (byte) edx_1166 >> 0x01) & 0x01);
			ebp_1027->bFFFFF73C = (byte) (SEQ(SLICE(eax_1153, word24, 8), (byte) eax_1153 >> 0x02) & 0x01);
			ebp_1027->tFFFFF784 = *edi_1040;
			ecx_1009 = *((word32) edi_1040 + 8);
			ebp_1027->bFFFFF749 = (byte) ecx_1009;
			if (edx_1219 != ~0x00)
			{
				Eq_2 esi_1241 = ebp_1027->ptrFFFFF768[edx_1219];
				ebp_1027->tFFFFF77C = esi_1241;
				if (esi_1241 >= 0x00)
					*((word32) edi_1040 + 4) = esi_1241;
				else
				{
					ebp_1027->tFFFFF77C = -ebp_1027->tFFFFF77C;
					Eq_2 ebx_1248 = ebp_1027->tFFFFF77C;
					*((word32) edi_1040 + 0x0C) = (byte) (eax_1153 | 0x20);
					*((word32) edi_1040 + 4) = ebx_1248;
					ebp_1027->tFFFFF778.u0 = 0x01;
				}
			}
			else
				ebp_1027->tFFFFF77C = *((word32) edi_1040 + 4);
			ui32 eax_1259 = *((word32) edi_1040 + 28);
			if (eax_1259 != ~0x00)
			{
				Eq_2 eax_1265 = ebp_1027->ptrFFFFF768[eax_1259];
				ebp_1027->tFFFFF784 = eax_1265;
				if (eax_1265 >= 0x00)
					*edi_1040 = eax_1265;
				else
				{
					*edi_1040 = ~0x00;
					ebp_1027->tFFFFF784.u0 = ~0x00;
				}
			}
			Eq_2 esi_1275 = ebp_1027->tFFFFF77C;
			Eq_2 eax_1276 = ebp_1027->tFFFFF784;
			if (esi_1275 >= eax_1276)
				eax_1276 = esi_1275;
			if (eax_1276 <= 0x03C8)
			{
				ebp_1027->tFFFFF75C.u0 = 0x00;
				ebp_1027->tFFFFF71C = ebp_1027->tFFFFF704;
				goto l08072B86;
			}
			ebp_1027->tFFFFF75C = ecx_1009;
			struct Eq_75964 * esp_1297 = esp_1016 - 0x0C;
			Eq_2 ebx_1299 = (word32) eax_1276 + 32;
			esp_1297->tFFFFFFFC = ebx_1299;
			up32 eax_1316 = __libc_alloca_cutoff(gs, esp_1297->tFFFFFFFC);
			esp_1016 = (struct Eq_75126 *) ((char *) &esp_1297->tFFFFFFFC + 16);
			ecx_1009 = ebp_1027->tFFFFF75C;
			if (ebx_1299 <= 0x1000 || eax_1316 != 0x00)
			{
				struct Eq_75126 * esi_1376 = (char *) &esp_1297->tFFFFFFFC + 16 - ((word32) ebx_1299 + 27 & ~0x0FFF);
				ui32 edx_1377 = (word32) ebx_1299 + 27 & ~0x0F;
				if ((char *) &esp_1297->tFFFFFFFC + 16 != esi_1376)
				{
					do
					{
						esp_1016 -= 0x1000;
						esp_1016->dw0FFC = esp_1016->dw0FFC;
					} while (esp_1016 != esi_1376);
				}
				if ((edx_1377 & 0x0FFF) != 0x00)
				{
					esp_1016 -= edx_1377 & 0x0FFF;
					Mem1401[esp_1016 - 0x04 + (edx_1377 & 0x0FFF):word32] = Mem1398[esp_1016 - 0x04 + (edx_1377 & 0x0FFF):word32];
				}
				Eq_2 eax_1409 = ebp_1027->tFFFFF77C;
				Eq_2 esi_1412 = ebp_1027->tFFFFF784;
				Mem1414[ebp_1027 + ~0x08A3:word32] = esp_1016 + 0x0F & ~0x0F;
				int32 eax_1418 = (word32) eax_1409 + 32;
				if (eax_1409 < esi_1412)
					eax_1418 = (word32) esi_1412 + 32;
				Eq_2 eax_1424 = (word32) ebp_1027->tFFFFF75C + eax_1418;
				ebp_1027->tFFFFF75C.u0 = 0x00;
				ebp_1027->tFFFFF71C = eax_1424;
l08072B86:
				byte cl_1435 = (byte) ecx_1009;
				<anonymous> * eax_1431[] = *((word32) ebp_1027->tFFFFF774 + 8148);
				if (eax_1431 != null)
				{
					Eq_2 ebx_1444 = (int32) cl_1435;
					<anonymous> * edx_1445 = eax_1431[ebx_1444];
					ebp_1027->tFFFFF710 = ebx_1444;
					if (edx_1445 != null)
					{
						ui32 eax_1457 = *((word32) edi_1040 + 44);
						ebp_1027->dwFFFFF708 = eax_1457;
						ui32 ebx_1460 = (eax_1457 << 0x02) + 0x1B;
						ebp_1027->dwFFFFF700 = ebx_1460 & ~0x0F;
						<anonymous> * eax_1459[] = eax_1457 << 0x02;
						struct Eq_75126 * esi_1469 = esp_1016 - (ebx_1460 & ~0x0FFF);
						ui32 esi_1472 = ebp_1027->dwFFFFF708;
						while (esp_1016 != esi_1469)
						{
							esp_1016 -= (struct Eq_76292 *) 0x1000;
							esp_1016->dw0FFC = esp_1016->dw0FFC;
						}
						ebp_1027->dwFFFFF708 = esi_1472;
						ui32 ebx_1480 = ebp_1027->dwFFFFF700;
						if ((ebx_1480 & 0x0FFF) != 0x00)
						{
							esp_1016 -= ebx_1480 & 0x0FFF;
							Mem1487[esp_1016 - 0x04 + (ebx_1480 & 0x0FFF):word32] = Mem1479[esp_1016 - 0x04 + (ebx_1480 & 0x0FFF):word32];
						}
						word32 ebx_1494 = esp_1016 + 0x0F;
						ebx = ebx_1494 & ~0x0F;
						if (ebp_1027->dwFFFFF708 != 0x00)
						{
							word32 * eax_1505 = (eax_1457 << 0x02) + (ebx_1494 & ~0x0F);
							word32 * edx_1509 = ebx_1494 & ~0x0F;
							word32 esi_1510 = ebp_1027->ptrFFFFF768 + *((word32) edi_1040 + 36);
							do
							{
								*edx_1509 = esi_1510;
								++edx_1509;
								esi_1510 += 0x0C;
							} while (eax_1505 != edx_1509);
							eax_1459 = (<anonymous> * (*)[]) *((word32) ebp_1027->tFFFFF774 + 8148);
							edx_1445 = eax_1459[ebp_1027->tFFFFF710];
						}
						ebp_1027->tFFFFF710 = ecx_1009;
						struct Eq_77026 * esp_1526 = esp_1016 - (struct Eq_77027 *) 0x04;
						esp_1526->tFFFFFFFC = ebx_1494 & ~0x0F;
						esp_1526->tFFFFFFF8 = edi_1040;
						esp_1526->dwFFFFFFF4 = (word32) ebp_1027->tFFFFF770;
						Eq_2 eax_1558;
						edx_1445();
						ecx_1009 = ebp_1027->tFFFFF710;
						esp_1016 = esp_1526 + 0x04;
						if (eax_1558 != ~0x01)
						{
							if (eax_1558 < 0x00)
								goto l08072A95;
							if (ebp_1027->tFFFFF76C > 0x7FFFFFFE)
							{
								edi_1040 = ebp_1027->tFFFFF774;
								esp_1526->a0000[0].t0000 = (word32) edi_1040 - 0x0001C23C;
								esp_1526->tFFFFFFFC.u0 = 2010;
								esp_1575 = esp_1526 - (struct Eq_77105 *) 4;
								goto l08074B62;
							}
							edx_1014 = 0x7FFFFFFF - ebp_1027->tFFFFF76C;
							if (edx_1014 >= eax_1558)
							{
								Mem1582[ebp_1027 + ~0x0893:word32] = Mem1544[ebp_1027 + ~0x0893:word32] + eax_1558;
								goto l08072FA7;
							}
l08072A82:
							gs->tFFFFFFE0.u0 = 0x4B;
							goto l08072A95;
						}
					}
				}
				struct Eq_75126 * esp_1637 = fp;
				byte cl_1621 = (byte) ecx_1009;
				if ((byte) (ecx_1009 - 0x20) <= 0x5A)
				{
					Eq_76171 dl_1619 = ebp_1027->tFFFFF738;
					Eq_2 esi_1611 = ebp_1027->tFFFFF774;
					ebp_1027->dwFFFFF708 = (word32) ebp_1027->tFFFFF754;
					ebp_1027->tFFFFF710 = (word32) ebp_1027->tFFFFF750;
					ebp_1027->tFFFFF74C.u1 = (word32) ebp_1027->tFFFFF74C;
					Eq_2 eax_1618 = (word32) ebp_1027->tFFFFF74B;
					ebp_1027->tFFFFF74B = dl_1619;
					ebp_1027->tFFFFF750 = eax_1618;
					ui32 edx_1624 = (word32) ((word32) esi_1611 - 115232 + (int32) cl_1621);
					ebp_1027->tFFFFF744.u1 = (word32) ebp_1027->tFFFFF744;
					Eq_2 eax_1646;
					Eq_2 ecx_1647;
					Eq_2 edx_1648;
					(*((word32) esi_1611 + (edx_1624 * 0x04 - 5952)))();
					ecxOut = ecx_1647;
					edxOut = edx_1648;
					return eax_1646;
				}
				ui32 edx_1650 = *((word32) edi_1040 + 44);
				ui32 eax_1653 = edx_1650 * 0x04 + 0x1B;
				ecx_1009 = edx_1650 * 0x04;
				struct Eq_75126 * esi_1656 = fp - (eax_1653 & ~0x0FFF);
				if (fp != esi_1656)
				{
					do
					{
						esp_1637 -= 0x1000;
						esp_1637->dw0FFC = esp_1637->dw0FFC;
					} while (esp_1637 != esi_1656);
				}
				int32 ebx_1672 = eax_1653 & ~0x0F & 0x0FFF;
				if (ebx_1672 != 0x00)
				{
					esp_1637 -= ebx_1672;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1637 - 0x04)[ebx_1672 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1637 - 0x04)[ebx_1672 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_76264 eax_1684 = (char *) &(esp_1637->a0000 + 3)->t0000 + 3;
				Eq_2 eax_1685 = eax_1684 & ~0x0F;
				if (edx_1650 != 0x00)
				{
					ecx_1009 = edx_1650 * 0x04 + (eax_1684 & ~0x0F);
					word32 edx_1707 = ebp_1027->ptrFFFFF768 + *((word32) edi_1040 + 36);
					do
					{
						*eax_1685 = edx_1707;
						eax_1685 = (word32) eax_1685 + 4;
						edx_1707 += 0x0C;
					} while (ecx_1009 != eax_1685);
				}
				Eq_2 esi_1723 = ebp_1027->tFFFFF770;
				Eq_2 eax_1724 = *((word32) esi_1723 + 20);
				if (eax_1724 < *((word32) esi_1723 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1724 + 1;
					*eax_1724 = 0x25;
					edx_1014 = (word32) eax_1724 + 1;
				}
				else
				{
					struct Eq_76334 * esp_1729 = esp_1637 - 0x08;
					esp_1729->dwFFFFFFFC = 0x25;
					esp_1729->tFFFFFFF8 = ebp_1027->tFFFFF770;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					esp_1016 = (struct Eq_75126 *) (&esp_1729->dwFFFFFFFC + 3);
					if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
						goto l08072A95;
				}
				ci8 al_1767 = *((word32) edi_1040 + 0x0C);
				if ((al_1767 & 0x08) != 0x00)
				{
					Eq_2 ebx_1773 = ebp_1027->tFFFFF770;
					Eq_2 eax_1774 = *((word32) ebx_1773 + 20);
					if (eax_1774 < *((word32) ebx_1773 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1774 + 1;
						*eax_1774 = 0x23;
						edx_1014 = (word32) eax_1774 + 1;
					}
					else
					{
						struct Eq_76382 * esp_1778 = esp_1637 - 0x08;
						esp_1778->dwFFFFFFFC = 0x23;
						esp_1778->tFFFFFFF8 = ebx_1773;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_75126 *) (&esp_1778->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					al_1767 = (ci8) *((word32) edi_1040 + 0x0C);
					ebx.u0 = 0x02;
				}
				else
					ebx.u0 = 0x01;
				if (al_1767 < 0x00)
				{
					Eq_2 esi_1812 = ebp_1027->tFFFFF770;
					Eq_2 eax_1813 = *((word32) esi_1812 + 20);
					if (eax_1813 < *((word32) esi_1812 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1813 + 1;
						*eax_1813 = 0x27;
						edx_1014 = (word32) eax_1813 + 1;
					}
					else
					{
						esp_1637->dwFFFFFFF4 = 0x27;
						esp_1637->dwFFFFFFF0 = (word32) esi_1812;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = esp_1637;
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word64) ebx.u0 + 1;
					al_1767 = (ci8) *((word32) edi_1040 + 0x0C);
				}
				Eq_2 esi_1862;
				if ((al_1767 & 0x40) != 0x00)
				{
					esi_1862 = ebp_1027->tFFFFF770;
					Eq_2 eax_1877 = *((word32) esi_1862 + 20);
					if (eax_1877 < *((word32) esi_1862 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1877 + 1;
						*eax_1877 = 0x2B;
						edx_1014 = (word32) eax_1877 + 1;
						goto l08072CB4;
					}
					esp_1637->dwFFFFFFF4 = 0x2B;
				}
				else
				{
					if ((al_1767 & 0x10) == 0x00)
						goto l08072CBB;
					esi_1862 = ebp_1027->tFFFFF770;
					Eq_2 eax_1863 = *((word32) esi_1862 + 20);
					if (eax_1863 < *((word32) esi_1862 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1863 + 1;
						*eax_1863 = 0x20;
						edx_1014 = (word32) eax_1863 + 1;
						goto l08072CB4;
					}
					esp_1637->dwFFFFFFF4 = 0x20;
				}
				struct Eq_76972 * esp_1884 = esp_1637 - 0x0C;
				esp_1884->tFFFFFFFC = esi_1862;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				esp_1016 = (struct Eq_75126 *) ((char *) &esp_1884->tFFFFFFFC + 16);
				if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
					goto l08072A95;
l08072CB4:
				al_1767 = (ci8) *((word32) edi_1040 + 0x0C);
				ebx = (word64) ebx.u0 + 1;
l08072CBB:
				if ((al_1767 & 0x20) != 0x00)
				{
					Eq_2 esi_1931 = ebp_1027->tFFFFF770;
					Eq_2 eax_1932 = *((word32) esi_1931 + 20);
					if (eax_1932 < *((word32) esi_1931 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1932 + 1;
						*eax_1932 = 0x2D;
						edx_1014 = (word32) eax_1932 + 1;
					}
					else
					{
						struct Eq_76481 * esp_1937 = esp_1637 - 0x08;
						esp_1937->dwFFFFFFFC = 0x2D;
						esp_1937->tFFFFFFF8 = esi_1931;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_75126 *) (&esp_1937->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word32) ebx + 1;
				}
				if (*((word32) edi_1040 + 16) == 0x30)
				{
					Eq_2 esi_1975 = ebp_1027->tFFFFF770;
					Eq_2 eax_1976 = *((word32) esi_1975 + 20);
					if (eax_1976 < *((word32) esi_1975 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_1976 + 1;
						*eax_1976 = 0x30;
						edx_1014 = (word32) eax_1976 + 1;
					}
					else
					{
						struct Eq_76589 * esp_1981 = esp_1637 - 0x08;
						esp_1981->dwFFFFFFFC = 0x30;
						esp_1981->tFFFFFFF8 = esi_1975;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_75126 *) (&esp_1981->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word32) ebx + 1;
				}
				if ((*((word32) edi_1040 + 0x0D) & 0x08) != 0x00)
				{
					Eq_2 esi_2019 = ebp_1027->tFFFFF770;
					Eq_2 eax_2020 = *((word32) esi_2019 + 20);
					if (eax_2020 < *((word32) esi_2019 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_2020 + 1;
						*eax_2020 = 0x49;
						edx_1014 = (word32) eax_2020 + 1;
					}
					else
					{
						struct Eq_76557 * esp_2025 = esp_1637 - 0x08;
						esp_2025->dwFFFFFFFC = 0x49;
						esp_2025->tFFFFFFF8 = esi_2019;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_75126 *) (&esp_2025->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					ebx = (word32) ebx + 1;
				}
				Eq_2 eax_2058 = *((word32) edi_1040 + 4);
				if (eax_2058 != 0x00)
				{
					struct Eq_76623 * esp_2067 = esp_1637 - 4;
					esp_2067->t0000.u0 = 0x00;
					esp_2067->tFFFFFFFC.u0 = 0x0A;
					Eq_2 esi_2064 = ebp_1027 - 0x20;
					esp_2067->tFFFFFFF8 = esi_2064;
					esp_2067->tFFFFFFF4 = eax_2058;
					ebp_1027->tFFFFF784 = esi_2064;
					Eq_2 eax_2076 = _itoa_word(esp_2067->tFFFFFFF4, esp_2067->tFFFFFFF8, esp_2067->tFFFFFFFC, esp_2067->t0000, out ecx_1009, out edx_1014);
					Eq_2 esi_2084 = eax_2076;
					if (eax_2076 < ebp_1027->tFFFFF784)
					{
						ebp_1027->tFFFFF77C = edi_1040;
						Eq_2 edi_2088 = ebp_1027->tFFFFF770;
						do
						{
							esi_2084 = (word32) esi_2084 + 1;
							edx_1014 = (word32) *((word32) esi_2084 - 1);
							byte dl_2099 = (byte) edx_1014;
							Eq_2 eax_2094 = *((word32) edi_2088 + 20);
							if (eax_2094 >= *((word32) edi_2088 + 24))
							{
								struct Eq_76869 * esp_2102 = esp_1637 - 0x08;
								esp_2102->tFFFFFFFC = edx_1014;
								esp_2102->tFFFFFFF8 = edi_2088;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg8 = <invalid>;
								esp_1016 = (struct Eq_75126 *) ((char *) &esp_2102->tFFFFFFFC + 0x0C);
								if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
									goto l08072A95;
							}
							else
							{
								*((word32) edi_2088 + 20) = (word32) eax_2094 + 1;
								*eax_2094 = dl_2099;
								ecx_1009 = (word32) eax_2094 + 1;
							}
							esp_1016 = esp_1637;
							if (ebx == 0x7FFFFFFF)
								goto l08072A95;
							ebx = (word32) ebx + 1;
						} while (esi_2084 != ebp_1027->tFFFFF784);
						edi_1040 = ebp_1027->tFFFFF77C;
					}
				}
				esp_1016 = esp_1637;
				if (*edi_1040 != ~0x00)
				{
					Eq_2 esi_2135 = ebp_1027->tFFFFF770;
					Eq_2 eax_2136 = *((word32) esi_2135 + 20);
					if (eax_2136 < *((word32) esi_2135 + 24))
					{
						*((word32) ebp_1027->tFFFFF770 + 20) = (word32) eax_2136 + 1;
						*eax_2136 = 0x2E;
						edx_1014 = (word32) eax_2136 + 1;
					}
					else
					{
						struct Eq_76699 * esp_2141 = esp_1637 - 0x08;
						esp_2141->dwFFFFFFFC = 0x2E;
						esp_2141->tFFFFFFF8 = esi_2135;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1016 = (struct Eq_75126 *) (&esp_2141->dwFFFFFFFC + 3);
						if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
							goto l08072A95;
					}
					esp_1016 = esp_1637;
					if (ebx == 0x7FFFFFFF)
						goto l08072A95;
					struct Eq_76731 * esp_2182 = esp_1637 - 4;
					esp_2182->t0000.u0 = 0x00;
					esp_2182->tFFFFFFFC.u0 = 0x0A;
					Eq_2 eax_2180 = ebp_1027 - 0x20;
					esp_2182->tFFFFFFF8 = eax_2180;
					esp_2182->tFFFFFFF4 = *edi_1040;
					ebp_1027->tFFFFF784 = eax_2180;
					Eq_2 eax_2195 = _itoa_word(esp_2182->tFFFFFFF4, esp_2182->tFFFFFFF8, esp_2182->tFFFFFFFC, esp_2182->t0000, out ecx_1009, out edx_1014);
					ebx = (word32) ebx + 1;
					esp_1016 = (struct Eq_75126 *) ((char *) &esp_2182->t0000 + 4);
					Eq_2 esi_2203 = eax_2195;
					if (eax_2195 < ebp_1027->tFFFFF784)
					{
						ebp_1027->tFFFFF77C = edi_1040;
						Eq_2 edi_2207 = ebp_1027->tFFFFF770;
						do
						{
							esi_2203 = (word32) esi_2203 + 1;
							edx_1014 = (word32) *((word32) esi_2203 - 1);
							byte dl_2218 = (byte) edx_1014;
							Eq_2 eax_2213 = *((word32) edi_2207 + 20);
							if (eax_2213 >= *((word32) edi_2207 + 24))
							{
								struct Eq_76840 * esp_2221 = esp_1637 - 0x08;
								esp_2221->tFFFFFFFC = edx_1014;
								esp_2221->tFFFFFFF8 = edi_2207;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg8 = <invalid>;
								esp_1016 = (struct Eq_75126 *) ((char *) &esp_2221->tFFFFFFFC + 0x0C);
								if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
									goto l08072A95;
							}
							else
							{
								*((word32) edi_2207 + 20) = (word32) eax_2213 + 1;
								*eax_2213 = dl_2218;
								ecx_1009 = (word32) eax_2213 + 1;
							}
							esp_1016 = esp_1637;
							if (ebx == 0x7FFFFFFF)
								goto l08072A95;
							ebx = (word32) ebx + 1;
						} while (esi_2203 != ebp_1027->tFFFFF784);
l08072A25:
						edi_1040 = ebp_1027->tFFFFF77C;
					}
				}
				word32 eax_2253 = *((word32) edi_1040 + 8);
				byte al_2267 = (byte) eax_2253;
				if (eax_2253 == 0x00)
				{
l08072A5D:
					if (ebp_1027->tFFFFF76C > 0x7FFFFFFE)
					{
						edi_1040 = ebp_1027->tFFFFF774;
						struct Eq_77442 * esp_2312 = esp_1016 - (struct Eq_77443 *) 4;
						esp_2312->a0000[0].t0000 = (word32) edi_1040 - 0x0001C23C;
						esp_2312->tFFFFFFFC.u0 = 0x07FD;
						esp_1575 = esp_2312 - (struct Eq_77454 *) 4;
						goto l08074B62;
					}
					Eq_2 esi_2373 = ebp_1027->tFFFFF76C;
					if (0x7FFFFFFF - esi_2373 >= ebx)
					{
						Mem2380[ebp_1027 + ~0x0893:word32] = esi_2373 + ebx;
						goto l08072FA7;
					}
					goto l08072A82;
				}
				Eq_2 esi_2258 = ebp_1027->tFFFFF770;
				edx_1014 = *((word32) esi_2258 + 20);
				if (edx_1014 < *((word32) esi_2258 + 24))
				{
					*((word32) ebp_1027->tFFFFF770 + 20) = (word32) edx_1014 + 1;
					*edx_1014 = al_2267;
					ecx_1009 = (word32) edx_1014 + 1;
				}
				else
				{
					struct Eq_75607 * esp_2265 = esp_1016 - 0x08;
					esp_2265->dwFFFFFFFC = (word32) al_2267;
					esp_2265->tFFFFFFF8 = esi_2258;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					esp_1016 = (struct Eq_75126 *) (&esp_2265->dwFFFFFFFC + 3);
					if (__overflow(dwArg00, stackArg8, out ecx_1009, out edx_1014) == ~0x00)
						goto l08072A95;
				}
				if (ebx != 0x7FFFFFFF)
				{
					ebx = (word32) ebx + 1;
					goto l08072A5D;
				}
l08072A95:
				ebx = ebp_1027->tFFFFF75C;
				if (ebx != 0x00)
				{
					struct Eq_75815 * esp_2397 = esp_1016 - 0x0C;
					esp_2397->tFFFFFFFC = ebp_1027->tFFFFF75C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					ebx = ebp_1027->tFFFFF774;
					Eq_2 stackArg0 = <invalid>;
					free(gs, stackArg0, dwArg00, out ecx_1009, out edx_1014);
					esp_1016 = (struct Eq_75126 *) ((char *) &esp_2397->tFFFFFFFC + 16);
				}
				goto l08072AC0;
			}
			ebp_1027->tFFFFF71C = ecx_1009;
			esp_1297->tFFFFFFFC = ebx_1299;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			ebx = ebp_1027->tFFFFF774;
			Eq_2 stackArg0 = <invalid>;
			word32 edi_3746;
			word32 esi_3745;
			word32 ecx_3742;
			word32 ebx_3743;
			word32 ebp_3744;
			Eq_2 eax_1347 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_3742, out edx_1014, out ebx_3743, out ebp_3744, out esi_3745, out edi_3746);
			ecx_1009 = ebp_1027->tFFFFF71C;
			ebp_1027->tFFFFF75C = eax_1347;
			esp_1016 = (struct Eq_75126 *) ((char *) &esp_1297->tFFFFFFFC + 16);
			if (eax_1347 != 0x00)
			{
				Eq_2 esi_1358 = ebp_1027->tFFFFF77C;
				Eq_2 ebx_1357 = ebp_1027->tFFFFF784;
				int32 edx_1361 = (word32) esi_1358 + 32;
				if (esi_1358 < ebx_1357)
					edx_1361 = (word32) ebx_1357 + 32;
				ebp_1027->tFFFFF71C = (word32) ebp_1027->tFFFFF75C + edx_1361;
				goto l08072B86;
			}
			goto l08072AC0;
		}
	}
	else if (ebp_1027->tFFFFF784 == 0x00)
		goto l0807303F;
	ebp_1027->tFFFFF754 = edi_104;
	struct Eq_75248 * esi_332 = ebp_1027->ptrFFFFF768;
	Eq_2 edi_336 = ebp_1027->tFFFFF75C;
	ebp_1027->tFFFFF778.u0 = 0.0F;
	ebx.u0 = 0x00;
	struct Eq_75248 * esi_338 = esi_332;
	do
	{
		Eq_2 eax_342 = *((word32) ecx_1009 + ebx * 0x04);
		if (eax_342 <= 0x05)
		{
			if (eax_342 >= 0x03 || (eax_342 > 0x01 || eax_342 >= 0x00))
				goto l08072998;
			if (eax_342 != ~0x00)
				goto l08072990;
			if ((*((word32) ebp_1027->tFFFFF770 + 60) & 0x04) == 0x00)
			{
				Eq_2 edi_359 = ebp_1027->tFFFFF774;
				struct Eq_75532 * esp_362 = esp_1016 - 4;
				esp_362->dw0000 = (word32) edi_359 - 0x0001C23C;
				esp_362->dwFFFFFFFC = 1887;
				esp_362->dwFFFFFFF8 = (word32) edi_359 - 0x0001C322;
				esp_362->dwFFFFFFF4 = (word32) edi_359 - 115456;
				__assert_fail(out ecx_1009, out edx_1014);
				esp_1016 = esp_362 - 0x0C;
				goto l08072A25;
			}
			struct Eq_75560 * esp_381 = esp_1016 - 0x0C;
			esp_381->dwFFFFFFFC = (word32) ebp_1027->tFFFFF774 - 115424;
			esp_1016 = esp_381 - 4;
			eax_342 = __libc_fatal(out ecx_1009);
		}
		if (eax_342 != 0x0100)
		{
			if (eax_342 > 0x0100)
			{
				if (eax_342 == 0x0200 || eax_342 == 0x0400)
					goto l08072998;
				if (eax_342 != 0x0107)
					goto l08072990;
				struct Eq_75491 * eax_551 = *edi_336;
				real64 rLoc1_2679 = (real64) eax_551->t0000;
				*edi_336 = (char *) &eax_551->t0004 + 8;
				esi_338->t0000 = (real80) rLoc1_2679;
				edx_1014 = (char *) &eax_551->t0004 + 8;
			}
			else if (eax_342 <= 0x07)
			{
				struct Eq_75491 * eax_407 = *edi_336;
				uint128 xmm1_408 = (uint128) eax_407->t0000;
				*edi_336 = (char *) &eax_407->t0004 + 4;
				esi_338->t0000 = (real64) xmm1_408;
				edx_1014 = (char *) &eax_407->t0004 + 4;
			}
			else
			{
l08072990:
				if ((SLICE(eax_342, byte, 8) & 0x08) != 0x00)
				{
l08072998:
					struct Eq_75491 * eax_545 = *edi_336;
					*edi_336 = &eax_545->t0004;
					esi_338->t0000 = eax_545->t0000;
					edx_1014 = &eax_545->t0004;
				}
				else
				{
					edx_1014 = *((word32) ebp_1027->tFFFFF774 + 8172);
					ebp_1027->tFFFFF75C = edx_1014;
					if (edx_1014 == 0x00 || (edx_1014 - 0x20)[eax_342] == 0x00)
						esi_338->t0000 = (real80) (real64) ebp_1027->tFFFFF778;
					else
					{
						word32 eax_447 = *((word32) ebp_1027->tFFFFF77C + ebx * 0x04);
						ebp_1027->tFFFFF750 = eax_447 + 0x1B & ~0x0F;
						struct Eq_75126 * edx_456 = esp_1016 - (eax_447 + 0x1B & ~0x0FFF);
						Eq_2 edx_458 = ebp_1027->tFFFFF75C;
						while (esp_1016 != edx_456)
						{
							esp_1016 -= 0x1000;
							esp_1016->dw0FFC = esp_1016->dw0FFC;
						}
						ebp_1027->tFFFFF75C = edx_458;
						Eq_2 eax_475 = ebp_1027->tFFFFF750;
						if ((eax_475 & 0x0FFF) != 0x00)
						{
							esp_1016 -= eax_475 & 0x0FFF;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1016 - 0x04)[(eax_475 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1016 - 0x04)[(eax_475 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						ebp_1027->tFFFFF750 = ecx_1009;
						Eq_75898 eax_487 = (char *) &(esp_1016->a0000 + 3)->t0000 + 3;
						esi_338->t0000 = eax_487 & ~0x0F;
						struct Eq_75906 * esp_488 = esp_1016 - 0x08;
						Eq_2 edx_507 = *((word32) ecx_1009 + ebx * 0x04);
						esp_488->tFFFFFFFC = edi_336;
						esp_488->dwFFFFFFF8 = eax_487 & ~0x0F;
						Eq_2 eax_516 = ebp_1027->tFFFFF75C;
						(eax_516 - 0x20)[edx_507]();
						ecx_1009 = ebp_1027->tFFFFF750;
						esp_1016 = (struct Eq_75126 *) ((char *) &esp_488->tFFFFFFFC + 0x0C);
					}
				}
			}
		}
		else
		{
			struct Eq_75491 * eax_396 = *edi_336;
			*edi_336 = (char *) &eax_396->t0004 + 4;
			edx_1014 = eax_396->t0004;
			Eq_75502 eax_400 = eax_396->t0000;
			esi_338->dw0004 = (word32) edx_1014;
			esi_338->t0000 = eax_400;
		}
		ebx = (word64) ebx.u0 + 1;
		++esi_338;
	} while (ebx < ebp_1027->tFFFFF784);
	edi_104 = ebp_1027->tFFFFF754;
	goto l08072728;
}

// 08074CB0: Register Eq_2 vfprintf(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_12125 ecxOut, Register out Eq_2 edxOut, Register out Eq_2 ebxOut, Register out ptr32 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      _IO_printf
//      locked_vfxprintf
//      vasprintf
//      buffered_vfprintf
//      __fprintf
Eq_2 vfprintf(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_12125 & ecxOut, union Eq_2 & edxOut, union Eq_2 & ebxOut, ptr32 & ebpOut, union Eq_2 & ediOut)
{
	ptr32 fp;
	word32 ebp;
	word32 edi;
	Eq_2 ebx;
	struct Eq_9 * gs;
	Eq_2 dwArg08;
	Eq_2 dwArg04;
	Eq_2 dwArg0C;
	word32 dwLoc04AC;
	word32 dwLoc0498;
	word32 dwLoc04A8;
	word32 dwLoc04B0;
	word32 dwLoc0490;
	word32 dwLoc048C;
	word32 dwLoc0494;
	word32 dwLoc04B8;
	word32 dwLoc0460;
	word32 dwLoc04B4;
	word32 dwLoc0500;
	word32 dwLoc04F0;
	word32 dwLoc04E0;
	word32 dwLoc04D4;
	word32 dwLoc0488;
	word32 dwLoc0478;
	word32 ecx;
	word32 edx;
	edi_12.u0 = 0x080CE000;
	esp_19 = fp - 0x050C;
	esi_21 = dwArg04;
	eax_26 = gs->dw0014;
	eax_31 = gs->tFFFFFFE0;
	eax_33 = *((word32) dwArg04 + 0x0068);
	if (eax_33 == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	else if (eax_33 != ~0x00)
	{
		dwLoc0470_1015.u0 = ~0x00;
		goto l08075033;
	}
	Mem42 = (Mem40, Mem32);
	edx_43 = *dwArg04;
	dl_44 = (byte) edx_43;
	if ((dl_44 & 0x08) != 0x00)
	{
		edx_50 = edx_43 | 0x20;
		*dwArg04 = edx_43 | 0x20;
		gs->tFFFFFFE0.u0 = 0x09;
		dwLoc0470_1017.u0 = ~0x00;
		goto l08075033;
	}
	if (dwArg08 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 22;
		dwLoc0470_1019.u0 = ~0x00;
		goto l08075033;
	}
	dwLoc0498_1020 = edx_43 & 0x02;
	if ((edx_43 & 0x02) != 0x00)
	{
		eax_77 = buffered_vfprintf(dwArg04, gs, out ecx_79, out edx_78);
		dwLoc0470_1025 = eax_77;
		goto l08075033;
	}
	eax_93 = strchrnul(dwArg08, 0x25);
	dwLoc0488_1030 = eax_93;
	dwLoc0460_1031 = eax_93;
	dwLoc0478_1032 = edx_43 & 0x8000;
	if ((edx_43 & 0x8000) != 0x00)
		dwLoc0478_1039.u0 = 0x00;
	else
	{
		dwLoc0478_1809 = (dwLoc0478_1038, dwLoc0478_1032);
		Mem136 = (Mem133, Mem115);
		edx_137 = *((word32) dwArg04 + 72);
		ebx_139 = gs->t0008;
		if (*((word32) edx_137 + 8) != ebx_139)
		{
			if (gs->t000C != 0x00)
				__lock();
			Z_151 = __cmpxchg(*edx_137, 0x01, 0x00, out eax_150);
			if (!Z_151)
				__lll_lock_wait_private(eax_150, edx_137, gs);
			edx_163 = *((word32) dwArg04 + 72);
			*((word32) edx_163 + 8) = ebx_139;
		}
		Mem168 = (Mem136, Mem166);
		edx_167 = (edx_137, edx_163);
		v41_169 = (word32) *((word32) edx_167 + 4) + 1;
		*((word32) edx_167 + 4) = v41_169;
	}
	dwLoc0478_1807 = (dwLoc0478_1039, dwLoc0478_1038, dwLoc0478_1809);
	Mem177 = (Mem172, Mem133, Mem170);
	ebx_178 = *((word32) dwArg04 + 0x0094);
	dwLoc0490_1040 = 0x080CEFA0;
	dwLoc048C_1041 = 0x0354;
	if (ebx_178 >= 135066356)
		_IO_vtable_check(out ecx_1989, out edx_1990);
	eax_220 = eax_93 - dwArg08;
	dwLoc0470_1072 = eax_220;
	(*((word32) ebx_178 + 28))();
	esp_238 = fp - 0x050C;
	if (eax_220 != eax_234)
	{
l080750B8:
		edx_1957 = (edx_235, edx_305, edx_1958, edx_934, edx_787);
		dwLoc0488_1933 = (dwLoc0488_1030, dwLoc0488_1934, dwLoc0488_1934, dwLoc0488_1517, dwLoc0488_1517);
		dwLoc04D4_1926 = (dwLoc04D4, dwLoc04D4_1927, dwLoc04D4_1927, dwLoc04D4_1472, dwLoc04D4_1472);
		dwLoc04E0_1913 = (dwLoc04E0, dwLoc04E0_1914, dwLoc04E0_1914, dwLoc04E0_1427, dwLoc04E0_1427);
		dwLoc04F0_1904 = (dwLoc04F0, dwLoc04F0_1905, dwLoc04F0_1905, dwLoc04F0_1382, dwLoc04F0_1382);
		dwLoc04B4_1898 = (dwLoc04B4, dwLoc04B4_1899, dwLoc04B4_1899, dwLoc04B4_1345, dwLoc04B4_1343);
		dwLoc0460_1895 = (dwLoc0460_1031, dwLoc0460_1896, dwLoc0460_1896, dwLoc0460_1304, dwLoc0460_1340);
		dwLoc04B8_1892 = (dwLoc04B8, dwLoc04B8_1893, dwLoc04B8_1893, dwLoc04B8_1276, dwLoc04B8_1336);
		dwLoc0494_1885 = (dwLoc0494, dwLoc0494_1095, dwLoc0494_1095, dwLoc0494_1639, dwLoc0494_1374);
		dwLoc048C_1874 = (dwLoc048C_1041, dwLoc048C_1875, dwLoc048C_1875, dwLoc048C_1177, dwLoc048C_1177);
		dwLoc0490_1871 = (dwLoc0490_1040, dwLoc0490_1872, dwLoc0490_1872, dwLoc0490_1169, dwLoc0490_1169);
		dwLoc04A8_1865 = (dwLoc04A8, dwLoc04A8_1866, dwLoc04A8_1866, dwLoc04A8_1153, dwLoc04A8_1153);
		dwLoc0498_1861 = (dwLoc0498_1020, dwLoc0498_1862, dwLoc0498_1862, dwLoc0498_1281, dwLoc0498_1318);
		dwLoc04AC_1858 = (dwLoc04AC, dwLoc04AC_1859, dwLoc04AC_1859, dwLoc04AC_1280, dwLoc04AC_1314);
		dwLoc0478_1829 = (dwLoc0478_1807, dwLoc0478_1830, dwLoc0478_1830, dwLoc0478_1820, dwLoc0478_1820);
		ebx_1002 = (ebx_178, ebx_300, ebx_289, ebx_938, ebx_779);
		edi_1000 = (edi_12, edi_299, edi_299, edi_383, edi_383);
		esp_999 = (esp_238, esp_308, esp_293, esp_937, esp_786);
		ecx_995 = (ecx_236, ecx_306, ecx_996, ecx_939, ecx_788);
		esi_993 = (esi_21, esi_310, esi_301, esi_388, esi_388);
		dwLoc0470_1099.u0 = ~0x00;
		goto l08075010;
	}
	else
	{
		edx_241 = eax_93;
		if (*eax_93 == 0x00)
		{
l08075010:
			edx_1956 = (edx_241, edx_876, edx_1957, edx_934, edx_934);
			dwLoc0488_1520 = (dwLoc0488_1030, dwLoc0488_1509, dwLoc0488_1933, dwLoc0488_1517, dwLoc0488_1517);
			dwLoc04D4_1475 = (dwLoc04D4, dwLoc04D4_1465, dwLoc04D4_1926, dwLoc04D4_1472, dwLoc04D4_1472);
			dwLoc04E0_1430 = (dwLoc04E0, dwLoc04E0_1419, dwLoc04E0_1913, dwLoc04E0_1427, dwLoc04E0_1427);
			dwLoc04F0_1385 = (dwLoc04F0, dwLoc04F0_1623, dwLoc04F0_1904, dwLoc04F0_1382, dwLoc04F0_1382);
			dwLoc04B4_1350 = (dwLoc04B4, dwLoc04B4_1607, dwLoc04B4_1898, dwLoc04B4_1345, dwLoc04B4_1345);
			dwLoc0460_1292 = (dwLoc0460_1031, dwLoc0460_1605, dwLoc0460_1895, dwLoc0460_1304, dwLoc0460_1304);
			dwLoc04B8_1269 = (dwLoc04B8, dwLoc04B8_1529, dwLoc04B8_1892, dwLoc04B8_1276, dwLoc04B8_1276);
			dwLoc0494_1257 = (dwLoc0494, dwLoc0494_1597, dwLoc0494_1885, dwLoc0494_1639, dwLoc0494_1639);
			dwLoc048C_1180 = (dwLoc048C_1041, dwLoc048C_1594, dwLoc048C_1874, dwLoc048C_1177, dwLoc048C_1177);
			dwLoc0490_1172 = (dwLoc0490_1040, dwLoc0490_1591, dwLoc0490_1871, dwLoc0490_1169, dwLoc0490_1169);
			dwLoc04A8_1149 = (dwLoc04A8, dwLoc04A8_1575, dwLoc04A8_1865, dwLoc04A8_1153, dwLoc04A8_1153);
			dwLoc0498_1141 = (dwLoc0498_1020, dwLoc0498_1439, dwLoc0498_1861, dwLoc0498_1281, dwLoc0498_1281);
			dwLoc04AC_1134 = (dwLoc04AC, dwLoc04AC_1567, dwLoc04AC_1858, dwLoc04AC_1280, dwLoc04AC_1280);
			dwLoc0470_1124 = (dwLoc0470_1072, dwLoc0470_1631, dwLoc0470_1099, dwLoc0470_1663, dwLoc0470_1662);
			dwLoc0478_1101 = (dwLoc0478_1807, dwLoc0478_1812, dwLoc0478_1829, dwLoc0478_1820, dwLoc0478_1820);
			ebx_391 = (ebx_178, ebx_868, ebx_1002, ebx_950, ebx_942);
			edi_356 = (edi_12, edi_866, edi_1000, edi_383, edi_383);
			esp_349 = (esp_238, esp_879, esp_999, esp_937, esp_937);
			ecx_335 = (ecx_236, ecx_877, ecx_995, ecx_939, ecx_939);
			Mem314 = (Mem229, Mem881, Mem312, Mem952, Mem949);
			esi_313 = (esi_21, esi_882, esi_993, esi_388, esi_388);
			if ((*esi_313 & 0x8000) == 0x00)
			{
				edx_318 = *((word32) esi_313 + 72);
				v33_319 = *((word32) edx_318 + 4) - 0x01;
				*((word32) edx_318 + 4) = v33_319;
				if (v33_319 == 0x00)
				{
					*((word32) edx_318 + 8) = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					v35_329 = *edx_318 - 0x01;
					*edx_318 = v35_329;
					if (v35_329 != 0x00)
						__lll_unlock_wake_private(edx_318, ecx_335, edx_318, gs);
				}
			}
			edx_1955 = (edx_1956, edx_318, edx_318);
			Mem342 = (Mem314, Mem320, Mem330);
			ecx_344 = dwLoc0478_1101;
			if (dwLoc0478_1101 != 0x00)
			{
				esp_352 = esp_349 - 0x08;
				ebx_359 = edi_356;
				esp_352->dwFFFFFFFC = 0x00;
				esp_352->ptrFFFFFFF8 = fp - 0x0444;
				fn00000000();
				esp_377 = &esp_352->dwFFFFFFFC + 3;
			}
l08075033:
			edx_1953 = (edx, edx_1955, edx_374, edx_78, edx_43, edx_50);
			ecx_1948 = (ecx, ecx_344, ecx_375, ecx_79, ecx, ecx);
			dwLoc0478_1820 = (dwLoc0478, dwLoc0478_1101, dwLoc0478_1101, dwLoc0478, dwLoc0478, dwLoc0478);
			dwLoc0488_1517 = (dwLoc0488, dwLoc0488_1520, dwLoc0488_1520, dwLoc0488, dwLoc0488, dwLoc0488);
			dwLoc04D4_1472 = (dwLoc04D4, dwLoc04D4_1475, dwLoc04D4_1475, dwLoc04D4, dwLoc04D4, dwLoc04D4);
			dwLoc04E0_1427 = (dwLoc04E0, dwLoc04E0_1430, dwLoc04E0_1430, dwLoc04E0, dwLoc04E0, dwLoc04E0);
			dwLoc04F0_1382 = (dwLoc04F0, dwLoc04F0_1385, dwLoc04F0_1385, dwLoc04F0, dwLoc04F0, dwLoc04F0);
			dwLoc04B4_1347 = (dwLoc04B4, dwLoc04B4_1350, dwLoc04B4_1350, dwLoc04B4, dwLoc04B4, dwLoc04B4);
			dwLoc0460_1289 = (dwLoc0460, dwLoc0460_1292, dwLoc0460_1292, dwLoc0460, dwLoc0460, dwLoc0460);
			dwLoc04B8_1266 = (dwLoc04B8, dwLoc04B8_1269, dwLoc04B8_1269, dwLoc04B8, dwLoc04B8, dwLoc04B8);
			dwLoc0494_1254 = (dwLoc0494, dwLoc0494_1257, dwLoc0494_1257, dwLoc0494, dwLoc0494, dwLoc0494);
			dwLoc048C_1177 = (dwLoc048C, dwLoc048C_1180, dwLoc048C_1180, dwLoc048C, dwLoc048C, dwLoc048C);
			dwLoc0490_1169 = (dwLoc0490, dwLoc0490_1172, dwLoc0490_1172, dwLoc0490, dwLoc0490, dwLoc0490);
			dwLoc04A8_1146 = (dwLoc04A8, dwLoc04A8_1149, dwLoc04A8_1149, dwLoc04A8, dwLoc04A8, dwLoc04A8);
			dwLoc0498_1138 = (dwLoc0498, dwLoc0498_1141, dwLoc0498_1141, dwLoc0498_1020, dwLoc0498, dwLoc0498);
			dwLoc04AC_1131 = (dwLoc04AC, dwLoc04AC_1134, dwLoc04AC_1134, dwLoc04AC, dwLoc04AC, dwLoc04AC);
			dwLoc0470_1122 = (dwLoc0470_1015, dwLoc0470_1124, dwLoc0470_1124, dwLoc0470_1025, dwLoc0470_1019, dwLoc0470_1017);
			esp_394 = (esp_19, esp_349, esp_377, esp_19, esp_19, esp_19);
			ebx_389 = (ebx, ebx_391, ebx_359, ebx, ebx, ebx);
			esi_388 = (esi_21, esi_313, esi_313, esi_21, esi_21, esi_21);
			Mem380 = (Mem39, Mem342, Mem363, Mem81, Mem63, Mem56);
			ebp_379 = fp - 4;
			edi_383 = eax_26 ^ gs->dw0014;
			eax_386 = dwLoc0470_1122;
			if (edi_383 == 0x00)
			{
				ebx_955 = ebx;
				edi_959 = edi;
				ebp_961 = ebp;
				ecxOut = ecx_1948;
				edxOut = edx_1953;
				ebxOut = ebx_955;
				ebpOut = ebp_961;
				ediOut = edi_959;
				return eax_386;
			}
			__stack_chk_fail(out ecx_1991, out edx_1992);
			esp_400 = esp_394 - 0x0C;
			esp_400->tFFFFFFFC = ebx_389;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			stackArg0.u0 = <invalid>;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			stackArg4.u0 = <invalid>;
			eax_405 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_407, out edx_1995, out ebx_1996, out ebp_1997, out esi_1998, out edi_1999);
			esp_409 = (char *) &esp_400->t0008 + 4;
			edx_410 = eax_405;
			if (eax_405 != 0x00)
			{
				dwLoc04A4_1130.u0 = 0x01;
				esp_400->t0008 = dwLoc04AC_1131;
				esp_400->t0004 = dwLoc0498_1138;
				esp_400->t0000 = fp - 0x0434;
				esp_400->tFFFFFFFC = eax_405;
				dwLoc0498_1145 = eax_405;
				nLoc0497_1164 = SLICE(eax_405, word24, 8);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				stackArg4.u0 = <invalid>;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				stackArg44.u0 = <invalid>;
				eax_427 = __wcsrtombs(gs, stackArg4, dwArg04, dwArg08, dwArg0C, stackArg44, out ebp_2004, out esi_2005, out edi_2006);
				esp_431 = (char *) &esp_400->t0008 + 4;
				edx_432 = eax_405;
				ecx_434 = eax_427;
				if (eax_427 != ~0x00)
				{
					v30_436 = dwLoc04A8_1146 - eax_427;
					dwLoc04A8_1153 = v30_436;
					if (v30_436 < 0x00)
					{
						if (dwLoc0470_1122 >= 0x00)
						{
							ebx_641 = *((word32) esi_388 + 0x0094);
							eax_643 = ebx_641 - dwLoc0490_1169;
							if (dwLoc048C_1177 <= eax_643)
							{
								dwLoc04A4_1230 = eax_405;
								_IO_vtable_check(out ecx_2016, out edx_2017);
							}
							dwLoc04A4_1635 = (dwLoc04A4_1130, dwLoc04A4_1230);
							dwLoc0498_1232 = eax_427;
							esp_400->t0004 = eax_427;
							esp_400->t0000 = eax_405;
							esp_400->tFFFFFFFC = esi_388;
							(*((word32) ebx_641 + 28))();
							ecx_676 = eax_427;
							esp_677 = (char *) &esp_400->t0008 + 4;
							if (eax_427 == eax_672)
							{
								eax_681 = 0x7FFFFFFF - dwLoc0470_1122;
								if (eax_427 <= eax_681)
								{
									v32_689 = dwLoc0470_1122 + eax_427;
									dwLoc0470_1251 = v32_689;
								}
								goto l08076520;
							}
							goto l08075098;
						}
						goto l0807768D;
					}
					bLoc0498_1161 = (int8) (v30_436 != 0x00);
					eax_445 = (word32) bLoc0498_1161;
					al_449 = (byte) eax_445;
					dwLoc0498_1165 = SEQ(nLoc0497_1164, bLoc0498_1161);
					if (dwLoc04B0 != 0x00 || al_449 == 0x00)
					{
l080766A2:
						dwLoc04B4_1356 = (dwLoc04B4_1347, dwLoc04B4_1347, dwLoc04B4_1162);
						dwLoc04AC_1317 = (dwLoc04AC_1131, dwLoc04AC_1131, dwLoc04AC_1163);
						dwLoc0470_1167 = (dwLoc0470_1122, dwLoc0470_1122, dwLoc0470_1166);
						Mem485 = (Mem444, Mem444, Mem482);
						if (dwLoc0470_1167 < 0x00)
						{
l0807768D:
							dwLoc0470_1535 = (dwLoc0470_1122, dwLoc0470_1167);
							dwLoc04B4_1355 = (dwLoc04B4_1347, dwLoc04B4_1356);
							dwLoc04AC_1316 = (dwLoc04AC_1131, dwLoc04AC_1317);
							esp_637 = esp_394 - 4;
							esp_637->dw0000 = (word32) edi_383 - 0x0001C228;
							esp_637->dwFFFFFFFC = 0x0666;
							goto l080775FF;
						}
						ebx_491 = *((word32) esi_388 + 0x0094);
						eax_493 = ebx_491 - dwLoc0490_1169;
						if (dwLoc048C_1177 <= eax_493)
							_IO_vtable_check(out ecx_2037, out edx_2038);
						esp_511 = esp_394 - 0x04;
						dwLoc04B4_1192 = eax_427;
						esp_511->tFFFFFFFC = eax_427;
						esp_511->tFFFFFFF8 = eax_405;
						esp_511->tFFFFFFF4 = esi_388;
						dwLoc04AC_1193 = eax_405;
						(*((word32) ebx_491 + 28))();
						ecx_533 = eax_427;
						esp_534 = (char *) &esp_511->tFFFFFFFC + 8;
						if (eax_427 == eax_529)
						{
							edx_538 = eax_405;
							eax_540 = 0x7FFFFFFF - dwLoc0470_1167;
							if (eax_427 > eax_540)
								goto l08076520;
							v37_544 = dwLoc0470_1167 + eax_427;
							dwLoc0470_1203 = v37_544;
							dwLoc0498_1225 = SEQ(nLoc0497_1164, bLoc0498_1161);
							if (dwLoc04B0 == 0x00 || bLoc0498_1161 == 0x00)
							{
l08076728:
								dwLoc0470_1303 = (dwLoc0470_1203, dwLoc0470_1203, dwLoc0470_1215);
								dwLoc0498_1223 = (dwLoc0498_1225, dwLoc0498_1225, dwLoc0498_1205);
								esp_614 = esp_394 - 0x0C;
								esp_614->tFFFFFFFC = eax_405;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								stackArg0.u0 = <invalid>;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								stackArg4.u0 = <invalid>;
								free(gs, stackArg0, stackArg4, out ecx_2047, out edx_2048);
							}
							esp_511->tFFFFFFFC = v30_436;
							esp_511->tFFFFFFF8.u0 = 0x20;
							esp_511->tFFFFFFF4 = esi_388;
							dwLoc0498_1205 = eax_405;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							stackArg4.u0 = <invalid>;
							eax_561 = _IO_padn(gs, stackArg4, dwArg04, dwArg08, out ecx_2040, out edx_562, out ebx_2041, out ebp_2042, out esi_2043, out edi_2044);
							ecx_565 = v30_436;
							esp_566 = (char *) &esp_511->tFFFFFFFC + 8;
							if (v30_436 == eax_561)
							{
								if (v37_544 <= 0x7FFFFFFE)
								{
									ebx_599 = 0x7FFFFFFF - v37_544;
									edx_600 = eax_405;
									if (ebx_599 >= v30_436)
									{
										v40_604 = v37_544 + v30_436;
										dwLoc0470_1215 = v40_604;
										goto l08076728;
									}
									goto l08076520;
								}
								goto l0807767F;
							}
						}
						goto l08075098;
					}
					dwLoc04B4_1162 = eax_405;
					dwLoc04AC_1163 = eax_427;
					esp_400->t0004 = v30_436;
					esp_400->t0000.u0 = 0x20;
					esp_400->tFFFFFFFC = esi_388;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg4.u0 = <invalid>;
					eax_464 = _IO_padn(gs, stackArg4, dwArg04, dwArg08, out ecx_466, out edx_465, out ebx_2033, out ebp_2034, out esi_2035, out edi_2036);
					esp_468 = (char *) &esp_400->t0008 + 4;
					if (v30_436 == eax_464)
					{
						if (dwLoc0470_1122 > 0x7FFFFFFE)
						{
l0807767F:
							dwLoc0470_1536 = (dwLoc0470_1203, dwLoc0470_1122);
							dwLoc04B4_1357 = (dwLoc04B4_1192, dwLoc04B4_1162);
							dwLoc0498_1210 = (dwLoc0498_1205, dwLoc0498_1165);
							dwLoc04AC_1209 = (dwLoc04AC_1193, dwLoc04AC_1163);
							esp_575 = esp_394 - 4;
							esp_575->ptr0000 = (word32) edi_383 - 0x0001C228;
							esp_575->dwFFFFFFFC = 0x0666;
							esp_575->ptrFFFFFFF8 = (word32) edi_383 - 0x0001C322;
							esp_575->ptrFFFFFFF4 = (word32) edi_383 - 115388;
							__assert_fail(out ecx_2049, out edx_2050);
							esp_575->ptrFFFFFFF0 = (word32) edi_383 - 0x0001C228;
							esp_575->dwFFFFFFEC = 0x0665;
l080775FF:
							dwLoc04A4_1632 = (dwLoc04A4_1634, dwLoc04A4_1130, dwLoc04A4_1130);
							dwLoc0470_1534 = (dwLoc0470_1302, dwLoc0470_1535, dwLoc0470_1536);
							dwLoc04B4_1343 = (dwLoc04B4_1345, dwLoc04B4_1355, dwLoc04B4_1357);
							dwLoc0460_1340 = (dwLoc0460_1304, dwLoc0460_1289, dwLoc0460_1289);
							dwLoc04B8_1336 = (dwLoc04B8_1276, dwLoc04B8_1266, dwLoc04B8_1266);
							dwLoc0498_1318 = (dwLoc0498_1281, dwLoc0498_1165, dwLoc0498_1210);
							dwLoc04AC_1314 = (dwLoc04AC_1280, dwLoc04AC_1316, dwLoc04AC_1209);
							__assert_fail(out ecx_2024, out edx_774);
							ebx_779 = edi_383;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							stackArg0.u0 = <invalid>;
							eax_782 = __libc_malloc(gs, stackArg0, edx_774, out ecx_2026, out edx_2027, out ebx_2028, out ebp_2029, out esi_2030, out edi_2031);
							esp_786 = fp;
							edx_787 = dwLoc04B4_1343;
							ecx_788 = dwLoc0500;
							dwLoc0494_1374 = eax_782;
							if (eax_782 != 0x00)
							{
								edx_793 = dwLoc04B4_1343 + eax_782;
								dwLoc04B4_1375 = edx_793;
								ebx_797 = (word32) *dwLoc0460_1340;
								bl_798 = (byte) ebx_797;
								if (bl_798 != 0x24)
								{
									dl_885 = (byte) (ebx_797 - 0x20);
									if (dl_885 <= 0x5A)
									{
										eax_889.u0 = (int32) bl_798;
										eax_890 = CONVERT(Mem795[eax_889 - 0x20 + dwLoc04A4_1632:byte], byte, word32);
										(*((word32) edi_383 + (eax_890 * 0x04 - 5312)))();
										ecxOut = ecx_893;
										edxOut = edx_892;
										ebxOut = ebx_797;
										ebpOut = ebp_379;
										ediOut = edi_383;
										return eax_891;
									}
									else
									{
										(*((word32) edi_383 - 364422))();
										ecxOut = ecx_897;
										edxOut = edx_896;
										ebxOut = ebx_797;
										ebpOut = ebp_379;
										ediOut = edi_383;
										return eax_895;
									}
								}
								goto l08075260;
							}
							goto l080750B8;
						}
						edx_475 = eax_405;
						eax_476 = 0x7FFFFFFF - dwLoc0470_1122;
						ecx_477 = eax_427;
						if (eax_476 < v30_436)
						{
l08076520:
							edx_1959 = (edx_673, edx_538, edx_600, edx_475);
							dwLoc04B4_1900 = (dwLoc04B4_1347, dwLoc04B4_1192, dwLoc04B4_1192, dwLoc04B4_1162);
							dwLoc0498_1864 = (dwLoc0498_1232, dwLoc0498_1225, dwLoc0498_1205, dwLoc0498_1165);
							dwLoc04AC_1860 = (dwLoc04AC_1131, dwLoc04AC_1193, dwLoc04AC_1193, dwLoc04AC_1163);
							ecx_998 = (ecx_676, ecx_533, ecx_565, ecx_477);
							esp_989 = esp_394;
							gs->tFFFFFFE0.u0 = 0x4B;
							goto l08075098;
						}
						v42_481 = dwLoc0470_1122 + v30_436;
						dwLoc0470_1166 = v42_481;
						goto l080766A2;
					}
				}
			}
			goto l08075098;
		}
		eax_244 = __printf_function_table;
		dwLoc04E0_1082 = eax_244;
		if (eax_244 != null)
		{
			dwLoc04B8_1083 = 0x00;
			dwLoc04E0_1084 = null;
			dwLoc04D4_1085 = ~0x00;
			goto l08074FB4;
		}
		ecx_252 = __printf_modifier_table;
		if (ecx_252 == 0x00)
		{
			eax_256 = __printf_va_arg_table;
			if (eax_256 == 0x00)
			{
				dwLoc04F0_1088.u0 = 0x00;
				dwLoc04B8_1089 = 0x00;
				dwLoc04D4_1090 = ~0x00;
				dwLoc0498_1863 = (dwLoc0498_1020, dwLoc0498_1281);
				dwLoc0478_1815 = (dwLoc0478_1807, dwLoc0478_1820);
				dwLoc0470_1533 = (dwLoc0470_1072, dwLoc0470_1663);
				dwLoc0488_1512 = (dwLoc0488_1030, dwLoc0488_1517);
				dwLoc04D4_1467 = (dwLoc04D4_1090, dwLoc04D4_1472);
				dwLoc04E0_1422 = (dwLoc04E0_1082, dwLoc04E0_1427);
				dwLoc04B4_1416 = (dwLoc04B4, dwLoc04B4_1345);
				dwLoc04B8_1413 = (dwLoc04B8_1089, dwLoc04B8_1276);
				dwLoc048C_1411 = (dwLoc048C_1041, dwLoc048C_1177);
				dwLoc0490_1409 = (dwLoc0490_1040, dwLoc0490_1169);
				dwLoc04A8_1405 = (dwLoc04A8, dwLoc04A8_1153);
				dwLoc04AC_1403 = (dwLoc04AC, dwLoc04AC_1280);
				dwLoc04F0_1377 = (dwLoc04F0_1088, dwLoc04F0_1382);
				ecx_997 = (ecx_252, ecx_939);
				edi_814 = (edi_12, edi_383);
				esp_810 = fp;
				esi_285 = (esi_21, esi_388);
				ebp_270 = fp - 4;
				edx_268 = (edx_241, edx_934);
				eax_269 = (word32) edx_268 + 1;
				dwLoc0460_1092 = eax_269;
				ebx_272 = (word32) *((word32) edx_268 + 1);
				bl_278 = (byte) ebx_272;
				al_274 = (byte) (ebx_272 - 0x20);
				if (al_274 <= 0x5A)
				{
					eax_963 = (int32) bl_278;
					ecx_964 = (word32) edi_814 - 115200;
					eax_967 = (word32) ((word32) edi_814 - 115232 + eax_963);
					ecx_969 = (word32) edi_814 - 0x00001440;
					eax_971 = ecx_969[eax_967];
					eax_971();
					ecxOut = ecx_987;
					edxOut = edx_986;
					ebxOut = ebx_272;
					ebpOut = ebp_270;
					ediOut = edi_814;
					return eax_985;
				}
				dwLoc0494_1093.u0 = 0x00;
				if (bl_278 != 0x00)
				{
l08075260:
					dwLoc0478_1814 = (dwLoc0478_1815, dwLoc0478_1820);
					dwLoc0470_1532 = (dwLoc0470_1533, dwLoc0470_1534);
					dwLoc0488_1511 = (dwLoc0488_1512, dwLoc0488_1517);
					dwLoc04D4_1466 = (dwLoc04D4_1467, dwLoc04D4_1472);
					dwLoc04E0_1421 = (dwLoc04E0_1422, dwLoc04E0_1427);
					dwLoc04B4_1415 = (dwLoc04B4_1416, dwLoc04B4_1375);
					dwLoc0460_1414 = (dwLoc0460_1092, dwLoc0460_1340);
					dwLoc04B8_1412 = (dwLoc04B8_1413, dwLoc04B8_1336);
					dwLoc048C_1410 = (dwLoc048C_1411, dwLoc048C_1177);
					dwLoc0490_1408 = (dwLoc0490_1409, dwLoc0490_1169);
					dwLoc04A8_1404 = (dwLoc04A8_1405, dwLoc04A8_1153);
					dwLoc04AC_1402 = (dwLoc04AC_1403, dwLoc04AC_1314);
					dwLoc0494_1395 = (dwLoc0494_1093, dwLoc0494_1374);
					dwLoc04F0_1376 = (dwLoc04F0_1377, dwLoc04F0_1382);
					ebx_870 = (ebx_272, ebx_797);
					esi_818 = (esi_285, esi_388);
					edi_813 = (edi_814, edi_383);
					esp_809 = fp;
					dwLoc0498_1394 = dwLoc04F0_1376;
					if (dwLoc0494_1395 != 0x00)
					{
						ebx_815 = edi_813;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						free(gs, stackArg0, dwLoc0494_1395, out ecx_2014, out edx_2015);
						esp_826 = fp;
					}
l08074FB4:
					dwLoc0478_1812 = (dwLoc0478_1807, dwLoc0478_1814, dwLoc0478_1814, dwLoc0478_1807);
					dwLoc04F0_1623 = (dwLoc04F0, dwLoc04F0_1376, dwLoc04F0_1376, dwLoc04F0);
					dwLoc04B4_1607 = (dwLoc04B4, dwLoc04B4_1415, dwLoc04B4_1415, dwLoc04B4);
					dwLoc0460_1605 = (dwLoc0460_1031, dwLoc0460_1414, dwLoc0460_1414, dwLoc0460_1031);
					dwLoc0494_1597 = (dwLoc0494, dwLoc0494_1395, dwLoc0494_1395, dwLoc0494);
					dwLoc048C_1594 = (dwLoc048C_1041, dwLoc048C_1410, dwLoc048C_1410, dwLoc048C_1041);
					dwLoc0490_1591 = (dwLoc0490_1040, dwLoc0490_1408, dwLoc0490_1408, dwLoc0490_1040);
					dwLoc04A8_1575 = (dwLoc04A8, dwLoc04A8_1404, dwLoc04A8_1404, dwLoc04A8);
					dwLoc04AC_1567 = (dwLoc04AC, dwLoc04AC_1402, dwLoc04AC_1402, dwLoc04AC);
					dwLoc0470_1530 = (dwLoc0470_1072, dwLoc0470_1532, dwLoc0470_1532, dwLoc0470_1072);
					dwLoc04B8_1529 = (dwLoc04B8_1086, dwLoc04B8_1412, dwLoc04B8_1412, dwLoc04B8_1083);
					dwLoc0488_1509 = (dwLoc0488_1030, dwLoc0488_1511, dwLoc0488_1511, dwLoc0488_1030);
					dwLoc04D4_1465 = (dwLoc04D4_1087, dwLoc04D4_1466, dwLoc04D4_1466, dwLoc04D4_1085);
					dwLoc0498_1439 = (dwLoc0498_1020, dwLoc0498_1394, dwLoc0498_1394, dwLoc0498_1020);
					dwLoc04E0_1419 = (dwLoc04E0_1082, dwLoc04E0_1421, dwLoc04E0_1421, dwLoc04E0_1084);
					ebx_868 = (ebx_178, ebx_870, ebx_815, ebx_178);
					edi_866 = (edi_12, edi_813, edi_813, edi_12);
					esi_860 = (esi_21, esi_818, esi_818, esi_21);
					esp_828 = (esp_238, esp_809, esp_826, esp_238);
					esp_830 = esp_828 - 0x0C;
					esp_830->ptrFFFFFFFC = dwLoc04E0_1419;
					esp_830->dwFFFFFFF8 = dwLoc04D4_1465;
					esp_830->tFFFFFFF4 = eax_31;
					esp_830->ptrFFFFFFF0 = fp - 0x0408;
					esp_830->tFFFFFFEC = dwLoc0488_1509;
					esp_830->dwFFFFFFE8 = dwLoc04B8_1529;
					esp_830->tFFFFFFE4 = dwLoc0470_1530;
					esp_830->ptrFFFFFFE0 = fp - 1116;
					esp_830->tFFFFFFDC = dwArg0C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg0.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg20.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg24.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg28.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg32.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg36.u0 = <invalid>;
					eax_875 = printf_positional(ebx_868, gs, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, out ecx_877, out edx_876);
					esp_879 = (char *) &esp_830->ptrFFFFFFFC + 16;
					dwLoc0470_1631 = eax_875;
					esi_882 = esi_860;
					goto l08075010;
				}
				gs->tFFFFFFE0.u0 = 22;
				esi_286 = esi_285;
l08075098:
				edx_1958 = (edx_268, edx_410, edx_432, edx_673, edx_1959, edx_530, edx_562, edx_465);
				dwLoc0488_1934 = (dwLoc0488_1512, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517, dwLoc0488_1517);
				dwLoc04D4_1927 = (dwLoc04D4_1467, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472, dwLoc04D4_1472);
				dwLoc04E0_1914 = (dwLoc04E0_1422, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427, dwLoc04E0_1427);
				dwLoc04F0_1905 = (dwLoc04F0_1377, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382, dwLoc04F0_1382);
				dwLoc04B4_1899 = (dwLoc04B4_1416, dwLoc04B4_1347, dwLoc04B4_1347, dwLoc04B4_1347, dwLoc04B4_1900, dwLoc04B4_1192, dwLoc04B4_1192, dwLoc04B4_1162);
				dwLoc0460_1896 = (dwLoc0460_1092, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289, dwLoc0460_1289);
				dwLoc04B8_1893 = (dwLoc04B8_1413, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266, dwLoc04B8_1266);
				dwLoc048C_1875 = (dwLoc048C_1411, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177, dwLoc048C_1177);
				dwLoc0490_1872 = (dwLoc0490_1409, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169, dwLoc0490_1169);
				dwLoc04A8_1866 = (dwLoc04A8_1405, dwLoc04A8_1146, dwLoc04A8_1146, dwLoc04A8_1153, dwLoc04A8_1153, dwLoc04A8_1153, dwLoc04A8_1153, dwLoc04A8_1153);
				dwLoc0498_1862 = (dwLoc0498_1863, dwLoc0498_1138, dwLoc0498_1145, dwLoc0498_1232, dwLoc0498_1864, dwLoc0498_1165, dwLoc0498_1205, dwLoc0498_1165);
				dwLoc04AC_1859 = (dwLoc04AC_1403, dwLoc04AC_1131, dwLoc04AC_1131, dwLoc04AC_1131, dwLoc04AC_1860, dwLoc04AC_1193, dwLoc04AC_1193, dwLoc04AC_1163);
				dwLoc0478_1830 = (dwLoc0478_1815, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820, dwLoc0478_1820);
				dwLoc0494_1095 = (dwLoc0494_1093, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254, dwLoc0494_1254);
				ecx_996 = (ecx_997, ecx_407, ecx_434, ecx_676, ecx_998, ecx_533, ecx_565, ecx_466);
				esi_301 = (esi_286, esi_388, esi_388, esi_388, esi_388, esi_388, esi_388, esi_388);
				edi_299 = (edi_814, edi_383, edi_383, edi_383, edi_383, edi_383, edi_383, edi_383);
				esp_293 = (esp_810, esp_409, esp_431, esp_677, esp_989, esp_534, esp_566, esp_468);
				ebx_289 = dwLoc0494_1095;
				if (dwLoc0494_1095 != 0x00)
				{
					esp_294 = esp_293 - 0x0C;
					esp_294->tFFFFFFFC = dwLoc0494_1095;
					ebx_300 = edi_299;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg0.u0 = <invalid>;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg4.u0 = <invalid>;
					free(gs, stackArg0, stackArg4, out ecx_306, out edx_305);
					esp_308 = (char *) &esp_294->tFFFFFFFC + 16;
					esi_310 = esi_301;
				}
				goto l080750B8;
			}
		}
		dwLoc04B8_1086 = 0x00;
		dwLoc04D4_1087 = ~0x00;
		goto l08074FB4;
	}
}

// 08077700: Register Eq_2 buffered_vfprintf(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      vfprintf
Eq_2 buffered_vfprintf(Eq_2 eax, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 dwLoc20E4_337;
	ui32 eax_30 = gs->dw0014;
	Eq_2 eax_33 = *((word32) eax + 0x0068);
	if (eax_33 == 0x00)
		((word32) eax + 0x0068)->u0 = ~0x00;
	else if (eax_33 != ~0x00)
	{
		dwLoc20E4_337.u0 = ~0x00;
l0807787A:
		if ((eax_30 ^ gs->dw0014) != 0x00)
		{
			word32 ecx_478;
			word32 edx_479;
			__stack_chk_fail(out ecx_478, out edx_479);
		}
		else
		{
			ecxOut = ecx;
			edxOut = edx;
			return dwLoc20E4_337;
		}
	}
	Eq_2 ecx_75;
	Eq_2 edx_76;
	word32 ebx_475;
	word32 ebp_476;
	word32 edi_477;
	Eq_2 eax_74 = vfprintf(0x080CE000, gs, fp - 0x20C8, edx, ecx, out ecx_75, out edx_76, out ebx_475, out ebp_476, out edi_477);
	dwLoc20E4_337 = eax_74;
	Eq_79506 ebp_145;
	Mem104 = Mem86;
	edx = edx_76;
	ecx = ecx_75;
	ui32 eax_105 = *eax;
	if ((eax_105 & 0x8000) != 0x00)
	{
		ebp_145 = fp - 0x2020 - (fp - 0x2020);
		if (ebp_145 <= 0x00)
			goto l08077864;
	}
	else
	{
		edx = *((word32) eax + 72);
		Eq_2 ebp_112 = gs->t0008;
		if (*((word32) edx + 8) != ebp_112)
		{
			ecx.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_122;
			if (!__cmpxchg(*edx, 0x01, eax_105 & 0x8000, out eax_122))
				ecx = __lll_lock_wait_private(eax_122, edx, gs);
			edx = *((word32) eax + 72);
			*((word32) edx + 8) = ebp_112;
		}
		*((word32) edx + 4) = (word32) *((word32) edx + 4) + 1;
		ebp_145 = fp - 0x2020 - (fp - 0x2020);
		if (ebp_145 <= 0x00)
		{
l08077835:
			if ((*eax & 0x8000) == 0x00)
			{
				edx = *((word32) eax + 72);
				word32 v20_231 = *((word32) edx + 4) - 0x01;
				*((word32) edx + 4) = v20_231;
				if (v20_231 == 0x00)
				{
					((word32) edx + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					Eq_2 v21_242 = *edx - 0x01;
					*edx = v21_242;
					if (v21_242 != 0x00)
						__lll_unlock_wake_private(edx, ecx, edx, gs);
				}
			}
l08077864:
			goto l0807787A;
		}
	}
	Eq_2 ecx_160 = *((word32) eax + 0x0094);
	Eq_2 eax_155 = 0x080CEFA0;
	word32 edx_165 = ecx_160 - 0x080CEFA0;
	if (ecx_160 >= 135066356)
	{
		word32 ecx_474;
		eax_155 = _IO_vtable_check(out ecx_474, out edx_165);
	}
	Eq_79506 eax_212;
	(*((word32) ecx_160 + 28))();
	Eq_2 eax_218 = ~0x00;
	if (eax_212 == ebp_145)
		eax_218 = eax_74;
	dwLoc20E4_337 = eax_218;
	goto l08077835;
}

// 08077940: Register Eq_79653 hack_digit(Register Eq_79653 eax, Register out Eq_2 ecxOut)
// Called from:
//      buffered_vfprintf
//      __printf_fp_l
Eq_79653 hack_digit(Eq_79653 eax, union Eq_2 & ecxOut)
{
	if (*eax != 0x00 && *((word32) eax + 4) == 0x66)
	{
		int32 edx_20 = *((word32) eax + 8);
		*((word32) eax + 8) = edx_20 - 0x01;
		if (edx_20 > 0x00)
		{
			ecxOut = edx_20 - 0x01;
			return 0x30;
		}
	}
	Eq_2 eax_36 = *((word32) eax + 24);
	Eq_2 ecx_105 = *((word32) eax + 16);
	Eq_2 esi_112 = *((word32) eax + 0x0C);
	if (eax_36 == 0x00)
	{
		union Eq_2 * ebx_42 = esi_112 - 0x04 + ecx_105 * 0x04;
		Eq_2 edi_44 = *ebx_42;
		Eq_2 ecx_57;
		*ebx_42 = (union Eq_2 *) __mpn_mul_1(esi_112, esi_112, ecx_105 - 0x01, 0x0A, out ecx_57);
		ecxOut = ecx_57;
		return (word32) edi_44 + 48;
	}
	else
	{
		Eq_79653 edi_113;
		if (eax_36 <= ecx_105)
		{
			uint32 eax_92 = __mpn_divrem(*((word32) eax + 28), 0x00, esi_112, ecx_105, *((word32) eax + 20), eax_36);
			Eq_79752 ecx_99[] = *((word32) eax + 28);
			ecx_99[*((word32) eax + 16) - *((word32) eax + 24)].u0 = eax_92;
			Eq_79752 edi_104 = ecx_99[0];
			ecx_105 = *((word32) eax + 24);
			*((word32) eax + 16) = ecx_105;
			if (ecx_105 == 0x00)
			{
l080779C3:
				*((word32) eax + 16) = 0x01;
				ecxOut = ecx_105;
				return edi_104 + 0x30;
			}
			esi_112 = *((word32) eax + 0x0C);
			edi_113 = edi_104 + 0x30;
			if ((esi_112 - 0x04)[ecx_105] == 0x00)
			{
				Eq_2 edx_118 = ecx_105 - 0x01;
				do
				{
					*((word32) eax + 16) = edx_118;
					ecx_105 = edx_118;
					if (edx_118 == 0x00)
						goto l080779C3;
					--edx_118;
				} while (*((word32) esi_112 + edx_118 * 0x04) == 0x00);
			}
		}
		else
			edi_113.u0->a0000 = 0x30;
		Eq_2 ecx_145;
		Eq_2 eax_144 = __mpn_mul_1(esi_112, esi_112, ecx_105, 0x0A, out ecx_145);
		if (eax_144 != 0x00)
		{
			Eq_2 edx_156 = *((word32) eax + 16);
			ecx_145 = *((word32) eax + 0x0C);
			*((word32) eax + 16) = (word32) edx_156 + 1;
			*((word32) ecx_145 + edx_156 * 0x04) = eax_144;
		}
		ecxOut = ecx_145;
		return edi_113;
	}
}

// 08077A50: Register Eq_2 _i18n_number_rewrite(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_79826) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      __printf_fp_l
Eq_2 _i18n_number_rewrite(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, struct Eq_79826 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	__align(fp - 4);
	struct Eq_74687 * eax_42 = wctrans(gs, 0x080B1CCC);
	Eq_2 eax_58 = __towctrans(0x2E, eax_42);
	__towctrans(44, eax_42);
	struct Eq_79826 * ebp_14 = fp - 0x0C;
	Eq_2 edi_143 = edx;
	Eq_2 esi_145 = eax;
	Eq_2 edx_152 = fp - 0x0464;
	if (eax_42 != null)
	{
		struct Eq_79855 * ebp_102;
		word32 esi_505;
		word32 edi_506;
		int32 eax_101 = wcrtomb(gs, fp - 0x4A, eax_58, fp - 0x0464, dwLoc0488, ecx, out ebp_102, out esi_505, out edi_506);
		Eq_2 edx_114 = ebp_102->tFFFFFB98;
		Eq_2 ecx_115 = ebp_102->tFFFFFB94;
		if (eax_101 != ~0x00)
			ebp_102 - 0x3E + eax_101 = (byte *) 0x00;
		else
			ebp_102->wFFFFFFC2 = 0x2E;
		ebp_102->tFFFFFB98 = edx_114;
		ebp_102->dwFFFFFBA8 = 0x00;
		ebp_102->dwFFFFFBAC = 0x00;
		int32 eax_139 = wcrtomb(gs, ebp_102 - 0x2D, ecx_115, edx_114, dwLoc0488, ecx, out ebp_14, out esi_145, out edi_143);
		edx_152 = ebp_14->tFFFFFB98;
		if (eax_139 != ~0x00)
			ebp_14 - 0x2D + eax_139 = (byte *) 0x00;
		else
			ebp_14->wFFFFFFD3 = 44;
	}
	ebp_14->dwFFFFFBAC = 0x0400;
	Eq_2 eax_166 = ebp_14 - 0x0448;
	ebp_14->tFFFFFB94 = eax_166;
	ebp_14->tFFFFFBA8 = eax_166;
	Eq_2 edi_163 = edi_143 - esi_145;
	word32 ecx_507;
	byte * edx_180;
	if ((byte) (uint32) __libc_scratch_buffer_set_array_size(gs, edx_152, edi_163, 0x01, out ecx_507, out edx_180) != 0x00)
	{
		Eq_2 ecx_191 = ebp_14->tFFFFFBA8;
		ebp_14->tFFFFFB90 = ecx_191;
		Eq_2 eax_202 = __mempcpy(ecx_191, esi_145, edi_163, out edx_180);
		esi_145 = ebp_14->tFFFFFBA0;
		ebp_14->tFFFFFB8C = ebp_14 - 0x2D;
		Eq_2 ecx_217 = ebp_14->tFFFFFB90;
		ebp_14->tFFFFFB98.u0 = ~0x2F;
		edi_163 = eax_202;
l08077B69:
		for (--edi_163; ecx_217 <= edi_163; --edi_163)
		{
			int32 eax_227 = (int32) *edi_163;
			byte al_280 = (byte) eax_227;
			if ((byte) (eax_227 - 0x30) <= 0x09)
			{
				ebp_14->tFFFFFBA0 = ecx_217;
				Eq_2 ebx_242 = (gs->*ebp_14->tFFFFFB98)->ptr0000->a0008[eax_227].t0000;
				word32 edx_511;
				word32 ecx_510;
				Eq_2 eax_245 = strlen(ebx_242, out ecx_510, out edx_511);
				ecx_217 = ebp_14->tFFFFFBA0;
				esi_145 -= eax_245;
				edx_180 = eax_245 - 0x01;
				if (eax_245 != 0x00)
				{
					do
					{
						Mem267[esi_145 + edx_180:byte] = Mem263[ebx_242 + edx_180:byte];
						--edx_180;
					} while (edx_180 != (byte *) ~0x00);
				}
				goto l08077B69;
			}
			edx_180 = ebp_14->ptrFFFFFBA4;
			if (edx_180 != null)
			{
				edx_180 = eax_227 & ~0x02;
				if ((byte) (eax_227 & ~0x02) == 44)
				{
					Eq_2 ebx_282 = ebp_14 - 0x3E;
					if (al_280 != 0x2E)
						ebx_282 = ebp_14->tFFFFFB8C;
					ebp_14->tFFFFFBA0 = ecx_217;
					word32 edx_514;
					word32 ecx_513;
					Eq_2 eax_294 = strlen(ebx_282, out ecx_513, out edx_514);
					ecx_217 = ebp_14->tFFFFFBA0;
					esi_145 -= eax_294;
					edx_180 = eax_294 - 0x01;
					if (eax_294 != 0x00)
					{
						do
						{
							Mem315[esi_145 + edx_180:byte] = Mem311[ebx_282 + edx_180:byte];
							--edx_180;
						} while (edx_180 != (byte *) ~0x00);
					}
					goto l08077B69;
				}
			}
			*((word32) esi_145 - 1) = al_280;
			--esi_145;
		}
		Eq_2 eax_335 = ebp_14->tFFFFFBA8;
		if (eax_335 != ebp_14->tFFFFFB94)
		{
			word32 ecx_512;
			free(gs, dwLoc0498, eax_335, out ecx_512, out edx_180);
		}
	}
	if ((ebp_14->dwFFFFFFE4 ^ gs->dw0014) != 0x00)
	{
		word32 edx_509;
		word32 ecx_508;
		Eq_2 eax_376 = __stack_chk_fail(out ecx_508, out edx_509);
		Eq_2 eax_387 = __guess_grouping.part.0(eax_376, edx_180);
		ebpOut = ebp_14;
		esiOut = esi_145;
		ediOut = edi_163;
		return eax_387;
	}
	else
	{
		struct Eq_79946 * esp_394 = ebp_14 - 0x0C;
		Eq_2 esi_397 = esp_394->t0004;
		Eq_2 edi_403 = esp_394->ptr0008->tFFFFFFF8;
		ebpOut = esp_394->ptr000C;
		esiOut = esi_397;
		ediOut = edi_403;
		return esi_145;
	}
}

// 08077D10: Register Eq_2 __guess_grouping.part.0(Register Eq_2 eax, Register (ptr32 byte) edx)
// Called from:
//      _i18n_number_rewrite
//      __printf_fp_l
//      __guess_grouping
Eq_2 __guess_grouping.part.0(Eq_2 eax, byte * edx)
{
	Eq_2 ebx_10 = 0x00;
	word32 ecx_14 = (word32) *edx;
	do
	{
		Eq_2 esi_16 = (int32) (byte) ecx_14;
		if (eax <= esi_16)
			return ebx_10;
		ebx_10 = (word32) ebx_10 + 1;
		ecx_14 = CONVERT(Mem9[edx + ebx_10:byte], byte, word32);
		eax -= esi_16;
		ci8 cl_26 = (byte) ecx_14;
		if (cl_26 == 0x7F || cl_26 < 0x00)
			return ebx_10;
	} while (cl_26 != 0x00);
	return (word32) ebx_10 + (uint32) ((uint64) (eax - 0x01) /u esi_16);
}

// 08077D50: void __printf_fp_l(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack Eq_2 dwArg04, Stack (ptr32 Eq_11467) dwArg08, Stack (ptr32 Eq_80169) dwArg0C, Stack (ptr32 (ptr32 Eq_2)) dwArg10)
// Called from:
//      __printf_fp
void __printf_fp_l(struct Eq_9 * gs, word32 dwArg00, Eq_2 dwArg04, struct Eq_11467 * dwArg08, struct Eq_80169 * dwArg0C, union Eq_2 ** dwArg10)
{
	Eq_2 ebx_2058;
	Eq_80172 edi_2346;
	Eq_2 esp_2959;
	Eq_2 dwLoc80_5426;
	Eq_2 dwLoc50_5427;
	struct Eq_11467 * dwLoc90_5368;
	ptr32 edi_250;
	Eq_2 edi_296;
	union Eq_2 * edx_162;
	struct Eq_11467 * ebx_101;
	__align(fp);
	ui32 eax_35 = (word32) dwArg0C->b000D;
	struct Eq_80189 * ebp_1126 = fp - 8;
	byte al_177 = (byte) eax_35;
	word16 eax_16_16_340 = SLICE(eax_35, word16, 16);
	struct Eq_11467 * esi_45 = (word32) dwArg0C->b000C;
	ui32 ecx_47 = SEQ(SLICE(eax_35, word24, 8), (byte) eax_35 >> 0x02);
	byte bl_54 = (byte) (eax_35 & 0x01);
	if ((eax_35 & 0x01) == 0x00)
	{
		ebx_101 = esi_45;
		Eq_2 ecx_92 = dwArg08->t0004;
		if ((byte) esi_45 >= 0x00)
			goto l08077DF5;
		ebx_101 = (struct Eq_11467 *) *((word32) ecx_92 + 44);
		dwLoc90_5368 = ebx_101;
	}
	else
	{
		struct Eq_80214 * ecx_58 = dwArg08->ptr0010;
		*ecx_58->ptr002C != 0x00;
		ecx_58->dw00D0 != 0x00;
		ebx_101 = esi_45;
		if ((byte) esi_45 >= 0x00)
			goto l08077DF5;
		dwLoc90_5368 = ecx_58->ptr0034;
	}
	if ((byte) ((word32) dwLoc90_5368->t0000 - 0x01) <= 0x7D)
	{
		if ((ecx_47 & 0x01) != 0x00)
		{
			Eq_2 dwLocC0_5388;
			if (bl_54 == 0x00)
				dwLocC0_5388 = *((word32) dwArg08->t0004 + 52);
			else
			{
				ebx_101 = dwArg08;
				dwLocC0_5388 = dwArg08->ptr0010->t00D4;
			}
			edx_162 = (union Eq_2 *) *dwArg10;
			if ((al_177 & 0x10) != 0x00)
			{
l08077E1D:
				Eq_2 xmm2_399 = *edx_162;
				if (__unordtf2((word32) xmm2_399, SLICE(xmm2_399, word32, 32), SLICE(xmm2_399, word32, 64), SLICE(xmm2_399, word32, 96), (word32) xmm2_399, SLICE(xmm2_399, word32, 32), SLICE(xmm2_399, word32, 64), SLICE(xmm2_399, word32, 96)) == 0x00)
				{
					word128 xmm0_452 = __pand(xmm2_399, g_ow80B1ED0);
					word128 xmm3_453 = g_ow80B1EE0;
					if (__unordtf2((word32) xmm0_452, SLICE(xmm0_452, word32, 32), SLICE(xmm0_452, word32, 64), SLICE(xmm0_452, word32, 96), (word32) xmm3_453, SLICE(xmm3_453, word32, 32), SLICE(xmm3_453, word32, 64), SLICE(xmm3_453, word32, 96)) == 0x00 && __lttf2((word32) xmm0_452, SLICE(xmm0_452, word32, 32), SLICE(xmm0_452, word32, 64), SLICE(xmm0_452, word32, 96), (word32) xmm3_453, SLICE(xmm3_453, word32, 32), SLICE(xmm3_453, word32, 64), SLICE(xmm3_453, word32, 96)) > 0x00)
					{
						ui32 edx_3223 = dwArg0C->dw0008;
						ebx_2058 = SEQ(SLICE(0x080CE000, word24, 8), __movmskps(xmm2_399)) & 0x08;
						if ((gs->ptrFFFFFFF8[edx_3223].b0001 & 0x01) != 0x00)
							goto l08077EDB;
						goto l0807807E;
					}
					Eq_2 eax_504 = __mpn_extract_float128(fp - 0x34, fp - 88, fp - 100, xmm2_399);
					dwLoc80_5426 = eax_504;
					dwLoc50_5427 = eax_504;
					edi_296 = (eax_504 << 0x05) - 0x70;
l080783DA:
					ui32 eax_530 = ((dwLoc58 >> 0x1F ^ dwLoc58) - (dwLoc58 >> 0x1F) + 0x1F >> 0x05) * 0x04 + 0x3B;
					struct Eq_82639 * esp_536 = fp - 0x0100;
					struct Eq_82639 * edx_538 = fp - 0x0100 - (eax_530 & ~0x0FFF);
					if (fp - 0x0100 != edx_538)
					{
						do
						{
							esp_536 -= 0x1000;
							esp_536->dw0FFC = esp_536->dw0FFC;
						} while (esp_536 != edx_538);
					}
					if ((eax_530 & ~0x0F & 0x0FFF) != 0x00)
					{
						esp_536 -= eax_530 & ~0x0F & 0x0FFF;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					Eq_82681 edx_566 = (char *) esp_536 + 0x0F;
					struct Eq_82639 * edx_582 = esp_536 - (eax_530 & ~0x0FFF);
					while (esp_536 != edx_582)
					{
						esp_536 -= 0x1000;
						esp_536->dw0FFC = esp_536->dw0FFC;
					}
					if ((eax_530 & ~0x0F & 0x0FFF) != 0x00)
					{
						esp_536 -= eax_530 & ~0x0F & 0x0FFF;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[(eax_530 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					struct Eq_82639 * ecx_622 = esp_536 - (eax_530 & ~0x0FFF);
					while (esp_536 != ecx_622)
					{
						esp_536 -= 0x1000;
						esp_536->dw0FFC = esp_536->dw0FFC;
					}
					int32 eax_639 = eax_530 & ~0x0F & 0x0FFF;
					if (eax_639 != 0x00)
					{
						esp_536 -= eax_639;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[eax_639 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_536 - 0x04)[eax_639 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					Eq_82809 eax_651 = (char *) esp_536 + 0x0F;
					if (dwLoc58 <= 0x02)
					{
						if (dwLoc58 >= 0x00)
						{
							struct Eq_82973 * esp_1243 = esp_536 - 4;
							esp_1243->t0000 = (word32) edi_296 + dwLoc58;
							esp_1243->tFFFFFFFC = dwLoc80_5426;
							esp_1243->tFFFFFFF8 = fp - 0x34;
							esp_1243->tFFFFFFF4 = edx_566 & ~0x0F;
							__mpn_lshift(esp_1243->tFFFFFFF4, esp_1243->tFFFFFFF8, esp_1243->tFFFFFFFC, esp_1243->t0000);
							(edx_566 & ~0x0F)[dwLoc50_5427] = eax_651 & ~0x0F;
							dwLoc58 = 0x00;
							goto l080787D0;
						}
						struct Eq_82933 * esp_672 = esp_536 - 4;
						esp_672->t0000 = edi_296;
						esp_672->tFFFFFFFC = dwLoc80_5426;
						esp_672->tFFFFFFF8 = fp - 0x34;
						esp_672->tFFFFFFF4 = edx_566 & ~0x0F;
						__mpn_lshift(esp_672->tFFFFFFF4, esp_672->tFFFFFFF8, esp_672->tFFFFFFFC, esp_672->t0000);
						(edx_566 & ~0x0F)[dwLoc50_5427] = eax_651 & ~0x0F;
						dwLoc58 = -dwLoc58;
						struct Eq_82971 * edi_1020 = &g_t80B4E70;
						do
						{
							edi_1020 -= 0x10;
							if (edi_1020->dw000C <= ebp_1126->ptrFFFFFF88)
							{
								ui32 ecx_770;
								word32 edx_773;
								int32 eax_735 = edi_1020->dw0004;
								Eq_2 edx_736 = ebp_1126->dwFFFFFFB8;
								Eq_2 ebx_737 = ebp_1126->ptrFFFFFFB4;
								Eq_2 ecx_738 = ebp_1126->dwFFFFFFC4;
								if (edx_736 >= eax_735 - 0x02)
								{
									struct Eq_83328 * esp_777 = esp_536 - 0x0C;
									word32 esi_779 = ebp_1126->dwFFFFFF80;
									esp_777->tFFFFFFFC = eax_735 - 0x02;
									esp_777->tFFFFFFF8 = esi_779 + ~0x00019157 + edi_1020->dw0000 * 0x04;
									esp_777->tFFFFFFF4 = edx_736;
									esp_777->tFFFFFFF0 = ebx_737;
									esp_777->tFFFFFFEC = ecx_738;
									word32 esi_9259;
									word32 eax_792 = __mpn_mul(gs, esp_777->tFFFFFFEC, esp_777->tFFFFFFF0, esp_777->tFFFFFFF4, esp_777->tFFFFFFF8, esp_777->tFFFFFFFC, out ebp_1126, out esi_9259, out edi_1020);
									ecx_770 = ebp_1126->dwFFFFFFB8;
									edx_773 = edi_1020->dw0004 + ecx_770;
									if (eax_792 == 0x00)
										goto l0807997B;
									goto l080798BC;
								}
								struct Eq_83256 * esp_743 = esp_536 - 0x0C;
								word32 esi_745 = ebp_1126->dwFFFFFF80;
								esp_743->tFFFFFFFC = edx_736;
								esp_743->tFFFFFFF8 = ebx_737;
								esp_743->tFFFFFFF4 = eax_735 - 0x02;
								esp_743->tFFFFFFF0 = esi_745 + ~0x00019157 + edi_1020->dw0000 * 0x04;
								esp_743->tFFFFFFEC = ecx_738;
								word32 esi_9258;
								word32 eax_759 = __mpn_mul(gs, esp_743->tFFFFFFEC, esp_743->tFFFFFFF0, esp_743->tFFFFFFF4, esp_743->tFFFFFFF8, esp_743->tFFFFFFFC, out ebp_1126, out esi_9258, out edi_1020);
								ecx_770 = ebp_1126->dwFFFFFFB8;
								edx_773 = edi_1020->dw0004 + ecx_770;
								if (eax_759 != 0x00)
								{
l080798BC:
									word32 eax_811 = edx_773 - 0x02;
									ebp_1126->dwFFFFFF4C = eax_811;
									ebp_1126->dwFFFFFFC8 = eax_811;
								}
								else
								{
l0807997B:
									word32 eax_816 = edx_773 - 0x03;
									ebp_1126->dwFFFFFF4C = eax_816;
									ebp_1126->dwFFFFFFC8 = eax_816;
								}
								word32 eax_822 = ebp_1126->dwFFFFFFC4;
								ebp_1126->tFFFFFF3C = eax_822;
								ui32 eax_825 = ebp_1126->dwFFFFFF4C;
								union Eq_963 * edx_826 = eax_822 - 0x04 + eax_825 * 0x04;
								word32 ebx_832 = __bsr(*edx_826);
								int32 eax_835 = ebp_1126->dwFFFFFFB0;
								ebp_1126->ptrFFFFFF88 = eax_835;
								ebp_1126->ptrFFFFFF68 = ebx_832 ^ 0x1F;
								int32 esi_839 = (eax_825 - ecx_770 << 0x05) + 0x1F - (ebx_832 ^ 0x1F);
								if (eax_835 + 0x03 != esi_839)
								{
									if (esi_839 > eax_835 + 0x02)
										goto l0807990F;
									goto l080799A0;
								}
								Eq_963 ecx_885;
								if ((ebx_832 ^ 0x1F) <= 0x1C)
								{
									ebp_1126->dwFFFFFFCC = 0x00;
									Eq_963 ebx_892 = 0x0A << (byte) (0x1C - (ebx_832 ^ 0x1F));
									ebp_1126->dwFFFFFFD0 = (word32) ebx_892;
									ecx_885 = ebx_892;
									if (esi_839 > eax_835 + 0x02)
										goto l08079A9E;
									goto l080799A0;
								}
								Eq_2 eax_846 = 0x20 - ebp_1126->ptrFFFFFF68;
								ebp_1126->dwFFFFFFCC = 0xA0000000;
								struct Eq_83681 * esp_852 = esp_536 - 4;
								esp_852->t0000 = eax_846;
								esp_852->tFFFFFFFC.u0 = 0x02;
								Eq_2 eax_854 = ebp_1126 - 0x34;
								esp_852->tFFFFFFF8 = eax_854;
								esp_852->tFFFFFFF4 = eax_854;
								ebp_1126->dwFFFFFFD0 = 0x00;
								__mpn_lshift(esp_852->tFFFFFFF4, esp_852->tFFFFFFF8, esp_852->tFFFFFFFC, esp_852->t0000);
								eax_835 = ebp_1126->dwFFFFFFB0;
								ebp_1126->ptrFFFFFF88 = eax_835;
								if (eax_835 + 0x02 < esi_839)
								{
									if (eax_835 + 0x03 != esi_839)
										goto l0807990F;
									int32 ecx_881 = ebp_1126->dwFFFFFFC8;
									Eq_85475 ebx_882 = ebp_1126->dwFFFFFFC4;
									ebp_1126->dwFFFFFF4C = ecx_881;
									ecx_885 = ebp_1126->dwFFFFFFD0;
									ebp_1126->tFFFFFF3C.u7 = ebx_882;
									edx_826 = ebx_882 - 0x04 + ecx_881 * 0x04;
l08079A9E:
									if (*edx_826 < ecx_885 || *edx_826 == ecx_885 && (ebp_1126->tFFFFFF3C - 0x08)[ebp_1126->dwFFFFFF4C] < ebp_1126->dwFFFFFFCC)
										goto l080799A0;
									ebp_1126->ptrFFFFFF88 = eax_835;
									goto l0807990F;
								}
								ebp_1126->tFFFFFF3C = ebp_1126->dwFFFFFFC4;
								ebp_1126->dwFFFFFF4C = ebp_1126->dwFFFFFFC8;
l080799A0:
								int32 eax_920 = eax_835 - esi_839;
								byte cl_928 = ebp_1126->tFFFFFF58;
								ebp_1126->ptrFFFFFF88 = eax_920;
								ebp_1126->dwFFFFFFB0 = eax_920;
								Eq_2 (* ecx_930)[] = ebp_1126->ptrFFFFFF68;
								ebp_1126->dwFFFFFF38 |= 0x01 << cl_928;
								Eq_2 (* eax_935)[] = ecx_930 - eax_920;
								union Eq_2 * esi_938 = ebp_1126->tFFFFFF3C;
								if (eax_920 >= 0x00)
									eax_935 = ecx_930;
								ui32 ebx_1011;
								Eq_2 edx_1059;
								Eq_2 ecx_1063;
								ui32 ecx_1012;
								ebp_1126->ptrFFFFFF68 = eax_935;
								Eq_2 eax_945 = *esi_938;
								if (eax_945 == 0x00)
								{
									ebp_1126->dwFFFFFF30 = edi_1020;
									struct Eq_83984 * eax_1005 = (char *) esi_938 + 4;
									ui32 esi_1002 = 0x00;
									while (true)
									{
										++eax_1005;
										ebx_1011 = esi_1002 + 0x01;
										Eq_2 edx_1009 = eax_1005->dwFFFFFFFC;
										ecx_1012 = ebx_1011;
										if (edx_1009 != 0x00)
											break;
										esi_1002 = ebx_1011;
									}
									ebp_1126->dwFFFFFF28 = eax_1005;
									edi_1020 = ebp_1126->dwFFFFFF30;
									if (ebp_1126->ptrFFFFFF68 != (Eq_2 (*)[]) 0x1F)
									{
										Eq_2 eax_1058 = __tzcnt(edx_1009);
										edx_1059 = ebp_1126->ptrFFFFFFB4;
										ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) eax_1058;
										Eq_2 eax_1062 = 0x1F - ebp_1126->ptrFFFFFF68;
										ecx_1063 = eax_1062;
										if (eax_1062 > ebp_1126->ptrFFFFFF88)
										{
											struct Eq_84232 * esp_1100 = esp_536 - 4;
											esp_1100->t0000 = eax_1062;
											esp_1100->tFFFFFFFC = ebp_1126->dwFFFFFF4C - esi_1002;
											esp_1100->tFFFFFFF8 = (word32) ebp_1126->tFFFFFF3C + esi_1002 * 0x04;
											esp_1100->tFFFFFFF4 = edx_1059;
											__mpn_rshift(esp_1100->tFFFFFFF4, esp_1100->tFFFFFFF8, esp_1100->tFFFFFFFC, esp_1100->t0000);
											ebp_1126->dwFFFFFFB8 = ebp_1126->dwFFFFFFC8 - esi_1002;
											ebp_1126->ptrFFFFFF88 = ebp_1126->dwFFFFFFB0;
											goto l0807990F;
										}
										ptr32 eax_1066 = ebp_1126->dwFFFFFF28;
										ebp_1126->dwFFFFFF4C -= ebx_1011;
										ebp_1126->tFFFFFF3C.u1 = eax_1066;
										goto l0807A2C0;
									}
									ebp_1126->dwFFFFFF4C -= ebx_1011;
									goto l0807A269;
								}
								Eq_2 (* ebx_949)[] = ebp_1126->ptrFFFFFF68;
								if (ebx_949 != (Eq_2 (*)[]) 0x1F)
								{
									Eq_2 eax_957 = __tzcnt(eax_945);
									edx_1059 = ebp_1126->ptrFFFFFFB4;
									ecx_1063 = 0x1F - ebx_949;
									ebx_1011 = 0x00;
									if (eax_957 < ecx_1063)
									{
										Eq_2 eax_963[] = ebp_1126->ptrFFFFFF68;
										struct Eq_84348 * esp_969 = esp_536 - 4;
										esp_969->t0000 = (char *) eax_963 + 1;
										esp_969->tFFFFFFFC = ebp_1126->dwFFFFFF4C;
										esp_969->tFFFFFFF8 = ebp_1126->tFFFFFF3C;
										esp_969->tFFFFFFF4 = edx_1059;
										__mpn_lshift(esp_969->tFFFFFFF4, esp_969->tFFFFFFF8, esp_969->tFFFFFFFC, esp_969->t0000);
										ui32 edx_985 = ebp_1126->dwFFFFFFC8;
										ebp_1126->dwFFFFFFB8 = edx_985 + 0x01;
										ebp_1126->ptrFFFFFFB4[edx_985] = (char *) eax_963 + 1;
										ebp_1126->ptrFFFFFF88 = ebp_1126->dwFFFFFFB0;
									}
									else
									{
l0807A2C0:
										struct Eq_84296 * esp_1073 = esp_536 - 4;
										esp_1073->t0000 = ecx_1063;
										esp_1073->tFFFFFFFC = ebp_1126->dwFFFFFF4C;
										esp_1073->tFFFFFFF8 = ebp_1126->tFFFFFF3C;
										esp_1073->tFFFFFFF4 = edx_1059;
										__mpn_rshift(esp_1073->tFFFFFFF4, esp_1073->tFFFFFFF8, esp_1073->tFFFFFFFC, esp_1073->t0000);
										ebp_1126->dwFFFFFFB8 = ebp_1126->dwFFFFFFC8 - ebx_1011;
										ebp_1126->ptrFFFFFF88 = ebp_1126->dwFFFFFFB0;
									}
								}
								else
								{
									ecx_1012 = 0x00;
									ebx_1011 = 0x00;
l0807A269:
									if (ebp_1126->dwFFFFFF4C > 0x00)
									{
										Eq_2 edx_1031[] = ebp_1126->ptrFFFFFFB4;
										Eq_2 ecx_1033[] = (word32) ebp_1126->tFFFFFF3C + ecx_1012 * 0x04;
										int32 eax_1034 = 0x00;
										do
										{
											edx_1031[eax_1034] = ecx_1033[eax_1034];
											++eax_1034;
											int32 esi_1049 = ebp_1126->dwFFFFFFC8 - ebx_1011;
										} while (esi_1049 > eax_1034);
										ebp_1126->dwFFFFFF4C = esi_1049;
									}
									ebp_1126->dwFFFFFFB8 = ebp_1126->dwFFFFFF4C;
								}
							}
l0807990F:
							ebp_1126->tFFFFFF58.u0 = ebp_1126->tFFFFFF58 - 0x01;
							if (edi_1020 == ebp_1126->tFFFFFF40)
							{
								if (ebp_1126->ptrFFFFFF88 > 0x00)
								{
									struct Eq_83587 * esp_1146 = esp_536 - 4;
									esp_1146->t0000.u0 = 0x0A;
									esp_1146->tFFFFFFFC = ebp_1126->dwFFFFFFB8;
									esp_1146->tFFFFFFF8 = ebp_1126->ptrFFFFFFB4;
									esp_1146->tFFFFFFF4 = ebp_1126->dwFFFFFFC4;
									word32 ecx_9260;
									__mpn_mul_1(esp_1146->tFFFFFFF4, esp_1146->tFFFFFFF8, esp_1146->tFFFFFFFC, esp_1146->t0000, out ecx_9260);
									Eq_2 edx_1164 = ebp_1126->dwFFFFFFB8;
									Eq_2 ebx_1165 = ebp_1126->dwFFFFFFC4;
									ebp_1126->dwFFFFFFC8 = (word32) edx_1164;
									Eq_2 eax_1168 = 0x04;
									Eq_2 ecx_1170 = __tzcnt(*ebx_1165);
									if (ebp_1126->dwFFFFFFB0 <= 0x04)
										eax_1168 = ebp_1126->dwFFFFFFB0;
									if (eax_1168 > ecx_1170)
									{
										esp_1146->t0000 = 0x20 - eax_1168;
										esp_1146->tFFFFFFFC = edx_1164;
										esp_1146->tFFFFFFF8 = ebx_1165;
										esp_1146->tFFFFFFF4 = ebp_1126->ptrFFFFFFB4;
										__mpn_lshift(esp_1146->tFFFFFFF4, esp_1146->tFFFFFFF8, esp_1146->tFFFFFFFC, esp_1146->t0000);
										if (eax_1168 != 0x00)
										{
											ui32 edx_1221 = ebp_1126->dwFFFFFFC8;
											ebp_1126->dwFFFFFFC8 = edx_1221 + 0x01;
											ebp_1126->ptrFFFFFFB4[edx_1221] = eax_1168;
										}
									}
									else
									{
										esp_1146->t0000 = eax_1168;
										esp_1146->tFFFFFFFC = edx_1164;
										esp_1146->tFFFFFFF8 = ebx_1165;
										esp_1146->tFFFFFFF4 = ebp_1126->ptrFFFFFFB4;
										__mpn_rshift(esp_1146->tFFFFFFF4, esp_1146->tFFFFFFF8, esp_1146->tFFFFFFFC, esp_1146->t0000);
									}
									word32 eax_1228 = ebp_1126->dwFFFFFFC8;
									ebp_1126->dwFFFFFF38 |= 0x01;
									ebp_1126->dwFFFFFFB8 = eax_1228;
								}
								break;
							}
						} while (ebp_1126->ptrFFFFFF88 > 0x00);
						ebp_1126->dwFFFFFFB0 = ebp_1126->dwFFFFFF38;
						goto l080787D0;
					}
					int32 ecx_1267 = (word32) edi_296 + dwLoc58;
					byte cl_1279 = (byte) ecx_1267;
					int32 eax_1270 = ecx_1267 + 0x1F;
					if (ecx_1267 >= 0x00)
						eax_1270 = ecx_1267;
					int32 edx_1323;
					int32 eax_1274 = eax_1270 >> 0x05;
					int32 ecx_1285 = ecx_1267;
					if ((cl_1279 & 0x1F) == 0x00)
					{
						word32 edi_1337[] = (edx_566 & ~0x0F) + eax_1274 * 0x04;
						ui32 eax_1339 = dwLoc80_5426 - 0x01;
						if (dwLoc80_5426 >= 0x01)
						{
							do
							{
								edi_1337[eax_1339] = (fp - 0x34)[eax_1339];
								--eax_1339;
							} while (eax_1339 != ~0x00);
						}
						edx_1323 = eax_1274;
					}
					else
					{
						uint32 eax_1288 = ecx_1267 >> 0x1F >> 0x1B;
						struct Eq_82862 * esp_1295 = esp_536 - 4;
						esp_1295->t0000 = (ecx_1267 + eax_1288 & 0x1F) - eax_1288;
						esp_1295->tFFFFFFFC = dwLoc80_5426;
						esp_1295->tFFFFFFF8 = fp - 0x34;
						Eq_2 eax_1297 = (edx_566 & ~0x0F) + eax_1274 * 0x04;
						esp_1295->tFFFFFFF4 = eax_1297;
						__mpn_lshift(esp_1295->tFFFFFFF4, esp_1295->tFFFFFFF8, esp_1295->tFFFFFFFC, esp_1295->t0000);
						ecx_1285 = (word32) edi_296 + dwLoc58;
						int32 edx_1319 = ecx_1285 + 0x1F;
						if (ecx_1285 >= 0x00)
							edx_1319 = ecx_1285;
						edx_1323 = edx_1319 >> 0x05;
						ui32 esi_1325 = (word32) dwLoc50_5427 + edx_1323;
						if (eax_1297 != 0x00)
							(edx_566 & ~0x0F)[esi_1325] = eax_1297;
					}
					int32 ebx_1399 = dwLoc58;
					int32 eax_1364 = 0x00;
					if (ecx_1285 > 0x1F)
					{
						do
						{
							(edx_566 & ~0x0F)[eax_1364] = 0x00;
							++eax_1364;
						} while (edx_1323 > eax_1364);
					}
					Eq_2 eax_1383 = 0x00;
					word32 edi_1385 = 0x0C;
					struct Eq_85587 * esi_1388 = &g_t80B4E70;
l080785F5:
					esi_1388 -= 0x10;
					if (ebp_1126->ptrFFFFFF88 + esi_1388->dw0008 / 4 - 0x01 > ebx_1399)
					{
l080785E3:
						--edi_1385;
						if (esi_1388 == ebp_1126->ptrFFFFFF68)
							goto l080786A3;
						goto l080785F2;
					}
					bool v162_5340;
					Eq_2 edx_1441;
					Eq_2 edx_1402 = ebp_1126->dwFFFFFFC4;
					if (eax_1383 != 0x00)
					{
						struct Eq_85645 * esp_1471 = esp_536 - 0x0C;
						Eq_85648 ecx_1474 = ebp_1126->tFFFFFF58;
						esp_1471->tFFFFFFFC = esi_1388->dw0004 - 0x02;
						esp_1471->tFFFFFFF8 = (word32) (esi_1388->t0000 * 0x04) + ((word32) ecx_1474 + 8);
						esp_1471->tFFFFFFF4 = eax_1383;
						esp_1471->tFFFFFFF0 = ebp_1126->ptrFFFFFFBC;
						esp_1471->tFFFFFFEC = edx_1402;
						word32 eax_1489 = __mpn_mul(gs, esp_1471->tFFFFFFEC, esp_1471->tFFFFFFF0, esp_1471->tFFFFFFF4, esp_1471->tFFFFFFF8, esp_1471->tFFFFFFFC, out ebp_1126, out esi_1388, out edi_1385);
						int32 edx_1502 = esi_1388->dw0004 + ebp_1126->dwFFFFFFC0;
						if (eax_1489 != 0x00)
						{
							ebp_1126->dwFFFFFFC8 = edx_1502 - 0x02;
							edx_1441 = edx_1502 - 0x02;
							v162_5340 = ebp_1126->dwFFFFFFB8 == edx_1502 - 0x02;
							if (ebp_1126->dwFFFFFFB8 > edx_1502 - 0x02)
								goto l08078650;
							goto l080785DA;
						}
						ebp_1126->dwFFFFFFC8 = edx_1502 - 0x03;
						edx_1441 = edx_1502 - 0x03;
					}
					else
					{
						ui32 eax_1410 = esi_1388->dw0004;
						if ((ebp_1126->ptrFFFFFF84->b000D & 0x10) == 0x00)
						{
							ui32 ebx_1445 = esi_1388->t0000;
							Eq_86525 ecx_1446 = ebp_1126->tFFFFFF58;
							ebp_1126->dwFFFFFFC8 = eax_1410;
							struct Eq_86532 * esp_1447 = esp_536 - 0x04;
							esp_1447->tFFFFFFFC = eax_1410 << 0x02;
							Mem1455[esp_1447 + -8:word32] = ecx_1446 + ebx_1445 * 0x04;
							esp_1447->tFFFFFFF4 = edx_1402;
							word32 ecx_9273;
							word32 edx_9274;
							memcpy(esp_1447->tFFFFFFF4, esp_1447->tFFFFFFF8, esp_1447->tFFFFFFFC, out ecx_9273, out edx_9274);
							edx_1441 = ebp_1126->dwFFFFFFC8;
						}
						else
						{
							ui32 ebx_1412 = esi_1388->t0000;
							Eq_86454 ecx_1413 = ebp_1126->tFFFFFF58;
							ebp_1126->dwFFFFFFC8 = eax_1410 + 0x02;
							struct Eq_86463 * esp_1416 = esp_536 - 0x04;
							esp_1416->tFFFFFFFC = eax_1410 + 0x02 << 0x02;
							Mem1425[esp_1416 + -8:word32] = ecx_1413 + ebx_1412 * 0x04;
							esp_1416->tFFFFFFF4 = (word32) edx_1402 + 8;
							word32 ecx_9271;
							word32 edx_9272;
							memcpy(esp_1416->tFFFFFFF4, esp_1416->tFFFFFFF8, esp_1416->tFFFFFFFC, out ecx_9271, out edx_9272);
							struct Eq_86498 * eax_1437 = ebp_1126->dwFFFFFFC4;
							eax_1437->dw0000 = 0x00;
							eax_1437->dw0004 = 0x00;
							edx_1441 = ebp_1126->dwFFFFFFC8;
							ebp_1126->dwFFFFFFB0 += 0x40;
						}
					}
					v162_5340 = ebp_1126->dwFFFFFFB8 == edx_1441;
					if (ebp_1126->dwFFFFFFB8 > edx_1441)
						goto l08078650;
l080785DA:
					if (!v162_5340)
					{
l080785E0:
						eax_1383 = ebp_1126->dwFFFFFFC0;
						goto l080785E3;
					}
					struct Eq_85830 * esp_1523 = esp_536 - 0x04;
					esp_1523->tFFFFFFFC = edx_1441;
					esp_1523->tFFFFFFF8 = ebp_1126->dwFFFFFFC4;
					esp_1523->tFFFFFFF4 = ebp_1126->ptrFFFFFFB4;
					int32 eax_1535 = __mpn_cmp(esp_1523->tFFFFFFF4, esp_1523->tFFFFFFF8, esp_1523->tFFFFFFFC);
					edx_1441 = ebp_1126->dwFFFFFFC8;
					if (eax_1535 < 0x00)
						goto l080785E0;
l08078650:
					ebp_1126->dwFFFFFFC0 = (word32) edx_1441;
					struct Eq_86292 * esp_1567 = esp_536 - 0x04;
					esp_1567->tFFFFFFFC = edx_1441 << 0x02;
					esp_1567->tFFFFFFF8 = ebp_1126->dwFFFFFFC4;
					esp_1567->tFFFFFFF4 = ebp_1126->ptrFFFFFFBC;
					word32 ecx_9269;
					word32 edx_9270;
					memcpy(esp_1567->tFFFFFFF4, esp_1567->tFFFFFFF8, esp_1567->tFFFFFFFC, out ecx_9269, out edx_9270);
					eax_1383 = ebp_1126->dwFFFFFFC0;
					ebp_1126->ptrFFFFFF88 = (__bsr((ebp_1126->ptrFFFFFFBC - 0x04)[eax_1383]) ^ ~0x1F) + (eax_1383 - 0x02 << 0x05);
					ebp_1126->dwFFFFFF4C |= 0x01 << (byte) edi_1385;
					--edi_1385;
					if (esi_1388 == ebp_1126->ptrFFFFFF68)
					{
l080786A3:
						ebp_1126->dwFFFFFFB0 = ebp_1126->dwFFFFFF4C;
						if (eax_1383 <= 0x00)
						{
l080787D0:
							word32 esi_2085;
							struct Eq_83012 * esi_1991 = ebp_1126->ptrFFFFFF84;
							ebp_1126->dwFFFFFF1C = esi_1991->dw0004;
							ui32 eax_1996 = esi_1991->dw0008;
							Eq_2 esi_2044 = esi_1991->t0000;
							int32 edi_2045 = gs->ptrFFFFFFF0[eax_1996];
							ebp_1126->tFFFFFF58.u2 = esi_2044;
							ebp_1126->dwFFFFFF18 = edi_2045;
							if ((byte) edi_2045 != 101)
							{
								if (ebp_1126->dwFFFFFF18 != 0x66)
								{
									Eq_2 edx_2103;
									Eq_2 esi_2098 = ebp_1126->tFFFFFF58;
									if (esi_2098 >= 0x00)
									{
										if (esi_2098 != 0x00)
										{
											ebp_1126->dwFFFFFF10 = (int32) esi_2098;
											edx_2103 = esi_2098;
										}
										else
										{
											ebp_1126->dwFFFFFF10 = 0x01;
											edx_2103.u0 = 0x01;
										}
									}
									else
									{
										ebp_1126->dwFFFFFF10 = 0x06;
										edx_2103.u0 = 0x06;
									}
									int32 ecx_2112 = ebp_1126->dwFFFFFFB0;
									if (ebp_1126->dwFFFFFFA8 != 0x00)
									{
										if (ecx_2112 <= 0x04)
										{
											Eq_83203 eax_2143 = ebp_1126->dwFFFFFF10;
											ebp_1126->dwFFFFFFAC = 0x66;
											ebp_1126->dwFFFFFF4C = 0x00;
											ebp_1126->tFFFFFF58 = eax_2143;
											ebx_2058 = edx_2103;
											goto l08078866;
										}
									}
									else if (ebp_1126->dwFFFFFF10 > ecx_2112)
									{
										ebp_1126->dwFFFFFFAC = 0x66;
										ebp_1126->dwFFFFFF4C = ecx_2112 + 0x01;
										Eq_2 eax_2123 = ebp_1126->dwFFFFFF10 - (ecx_2112 + 0x01);
										ebp_1126->tFFFFFF58.u2 = eax_2123;
										ebx_2058 = eax_2123;
l08078866:
										ebp_1126->dwFFFFFF30 = (int32) ((word64) edx_2103.u0 + 5);
l0807886F:
										esi_2085 = 0x00;
										Eq_83218 eax_2158 = ebp_1126->tFFFFFF58;
										if ((ebp_1126->ptrFFFFFF84->b000C & 0x08) == 0x00)
											eax_2158.u1 = 0x00;
										ebp_1126->dwFFFFFF38 = (int32) eax_2158;
l08078887:
										ebp_1126->dwFFFFFF28 = 0x00;
										byte * ecx_2166 = ebp_1126->ptrFFFFFF78;
										if (ecx_2166 != null)
										{
											word32 eax_2170 = (word32) *ecx_2166;
											ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) (byte) eax_2170;
											Eq_2 eax_2174 = 0x00;
											if ((byte) (eax_2170 - 0x01) <= 0x7D)
											{
												eax_2174 = __guess_grouping.part.0(ebp_1126->dwFFFFFF4C, ecx_2166);
												ebp_1126->dwFFFFFF28 = (ui32) eax_2174;
											}
											ebp_1126->dwFFFFFF30 = (word32) eax_2174 + (ebp_1126->dwFFFFFF30 + 0x01);
										}
										Eq_2 eax_2196 = ebp_1126->dwFFFFFF30;
										if (eax_2196 > 0x3FFFFFFC || eax_2196 < ebx_2058)
										{
											gs->tFFFFFFE0.u0 = 0x22;
											goto l080782CA;
										}
										struct Eq_83774 * esp_2245 = esp_536 - 0x0C;
										Eq_2 ebx_2247 = ebp_1126->dwFFFFFF30 * 0x04 + 0x08;
										esp_2245->tFFFFFFFC = ebx_2247;
										up32 eax_2250 = __libc_alloca_cutoff(gs, esp_2245->tFFFFFFFC);
										Eq_2 esp_2256 = (char *) &esp_2245->tFFFFFFFC + 16;
										if (ebx_2247 > 0x1000 && eax_2250 == 0x00)
										{
											esp_2245->tFFFFFFFC = ebx_2247;
											word32 ecx_9261;
											word32 edx_9262;
											word32 edi_9263;
											Eq_2 eax_2267 = __libc_malloc(gs, esp_2245->tFFFFFFF8, esp_2245->tFFFFFFFC, out ecx_9261, out edx_9262, out ebx_2058, out ebp_1126, out esi_2085, out edi_9263);
											ebp_1126->ptrFFFFFF20 = (struct Eq_155353 *) eax_2267;
											esp_2256 = (char *) &esp_2245->tFFFFFFFC + 16;
											if (eax_2267 == 0x00)
												goto l08078BC0;
											ebp_1126->dwFFFFFF14 = 0x00;
										}
										else
										{
											Eq_2 edx_2290 = (char *) &esp_2245->tFFFFFFFC + 16 - ((word32) ebx_2247 + 27 & ~0x0FFF);
											ui32 eax_2291 = (word32) ebx_2247 + 27 & ~0x0F;
											if ((char *) &esp_2245->tFFFFFFFC + 16 != edx_2290)
											{
												do
												{
													esp_2256 -= 0x1000;
													*((word32) esp_2256 + 0x0FFC) = *((word32) esp_2256 + 0x0FFC);
												} while (esp_2256 != edx_2290);
											}
											if ((eax_2291 & 0x0FFF) != 0x00)
											{
												esp_2256 -= eax_2291 & 0x0FFF;
												Mem2314[esp_2256 - 0x04 + (eax_2291 & 0x0FFF):word32] = Mem2311[esp_2256 - 0x04 + (eax_2291 & 0x0FFF):word32];
											}
											ebp_1126->dwFFFFFF14 = 0x01;
											Mem2327[ebp_1126 + -224:word32] = esp_2256 + 0x0F & ~0x0F;
										}
										Eq_84127 ebx_2401;
										up32 edi_2331 = ebp_1126->dwFFFFFFA8;
										ebp_1126->tFFFFFF40 = ebp_1126->ptrFFFFFF20->a0008;
										if (edi_2331 != 0x00 && ebp_1126->dwFFFFFFAC == 0x66)
										{
											struct Eq_84020 * eax_2339 = ebp_1126->ptrFFFFFF20;
											word32 ebx_2340 = ebp_1126->dwFFFFFF50;
											ebp_1126->dwFFFFFF24 = 0x00;
											--ebp_1126->dwFFFFFFB0;
											eax_2339->dw0008 = 0x30;
											eax_2339->dw000C = ebx_2340;
											ebp_1126->ptrFFFFFF68 = ebp_1126 - 88;
											edi_2346 = &eax_2339->dw000C + 1;
											goto l08078A02;
										}
										Eq_80172 eax_2358;
										int32 esi_2352 = ebp_1126->dwFFFFFF4C;
										ebp_1126->dwFFFFFF24 = 0x00;
										ebp_1126->ptrFFFFFF68 = ebp_1126 - 88;
										if (esi_2352 > 0x00)
										{
											struct Eq_84057 * ebx_2359 = ebp_1126->ptrFFFFFF20;
											Eq_79653 edi_2360 = ebp_1126->ptrFFFFFF68;
											ui32 esi_2364 = 0x00;
											do
											{
												++esi_2364;
												word32 ecx_9264;
												ebx_2359->a0004[esi_2364] = hack_digit(edi_2360, out ecx_9264);
											} while (ebp_1126->dwFFFFFF4C != esi_2364);
											ebp_1126->dwFFFFFF24 = esi_2364;
											eax_2358 = (word32) ebp_1126->tFFFFFF40 + ebp_1126->dwFFFFFF4C * 0x04;
										}
										else
											eax_2358 = ebp_1126->tFFFFFF40;
										if ((ebp_1126->ptrFFFFFF84->b000C & 0x08) == 0x00 && ebp_1126->dwFFFFFF38 <= 0x00)
										{
											if (ebp_1126->tFFFFFF58 <= 0x00)
											{
												ebp_1126->tFFFFFF3C.u1 = 0x00;
												edi_2346 = eax_2358;
												ebx_2401.u0 = 0x00;
												goto l08078DC5;
											}
											if (ebp_1126->dwFFFFFFB8 <= 0x01 && (ebp_1126->ptrFFFFFFB4)[0] == 0x00)
											{
												edi_2346 = eax_2358;
												esi_2085 = 0x01;
l08078A02:
												int32 eax_2422 = ebp_1126->dwFFFFFF38;
												ebp_1126->tFFFFFF3C.u1 = 0x00;
												ebp_1126->ptrFFFFFF88 = eax_2422;
												ebx_2401.u0 = 0x00;
l08078A17:
												if (ebp_1126->ptrFFFFFF88 > ebx_2401)
												{
l08078A32:
													do
													{
														edi_2346 += 0x04;
														word32 ecx_9265;
														int32 eax_3190 = hack_digit(ebp_1126->ptrFFFFFF68, out ecx_9265);
														*((word32) edi_2346 - 4) = eax_3190;
														ebx_2401 = (word32) ebx_2401.u0 + 1;
														if (esi_2085 == 0x00 && eax_3190 == 0x30)
														{
															int32 eax_3204 = ebp_1126->dwFFFFFF38;
															ebp_1126->tFFFFFF58 = (word32) ebp_1126->tFFFFFF58 + 1;
															if (eax_3204 > 0x00)
															{
																ebp_1126->tFFFFFF3C = (word32) ebp_1126->tFFFFFF3C + 1;
																ebp_1126->ptrFFFFFF88 = (word32) ebp_1126->tFFFFFF3C + eax_3204;
															}
															goto l08078A17;
														}
														esi_2085 = 0x01;
													} while (ebp_1126->ptrFFFFFF88 > ebx_2401);
													goto l08078A1C;
												}
l08078A1C:
												if (ebp_1126->tFFFFFF58 > ebx_2401 && (ebp_1126->dwFFFFFFB8 > 0x01 || (ebp_1126->ptrFFFFFFB4)[0] != 0x00))
													goto l08078A32;
l08078DC5:
												int32 eax_2448 = *((word32) edi_2346 - 4);
												ebp_1126->ptrFFFFFF88 = eax_2448;
												esp_2959 = esp_2256;
												if (eax_2448 == ebp_1126->dwFFFFFF50)
													ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) *((word32) edi_2346 - 8);
												word32 ecx_2459;
												int32 eax_2458 = hack_digit(ebp_1126->ptrFFFFFF68, out ecx_2459);
												int8 cl_2468 = (int8) (eax_2458 != 0x30);
												byte dl_2472 = (int8) (eax_2458 != 0x35) & cl_2468;
												Eq_2 ecx_2486 = SEQ(SLICE(ecx_2459, word24, 8), cl_2468);
												if (dl_2472 == 0x00)
												{
													Eq_2 (* eax_2476)[] = ebp_1126->dwFFFFFFB8;
													if (eax_2476 != (Eq_2 (*)[]) 0x01)
													{
														ecx_2486 = ebp_1126->dwFFFFFFC0;
														if (ecx_2486 == 0x00)
														{
															ebp_1126->ptrFFFFFF68 = eax_2476;
															if (eax_2476 != null)
															{
																ecx_2486 = ebp_1126->ptrFFFFFFB4;
																do
																{
																	if ((ecx_2486 - 0x04)[eax_2476] != 0x00)
																		goto l08079618;
																	--eax_2476;
																} while (eax_2476 != null);
															}
														}
														else
														{
l08079618:
															dl_2472 = 0x01;
														}
													}
													else if (ebp_1126->ptrFFFFFFB4[0] != 0x00)
														dl_2472 = 0x01;
												}
												Eq_84127 edx_2586;
												Eq_80172 eax_2563;
												ebp_1126->wFFFFFFA2 = __fstcw();
												cui16 ax_2511 = ebp_1126->wFFFFFFA2;
												if ((ax_2511 & 0x0C00) == 0x0400)
												{
													if (ebp_1126->dwFFFFFFA4 == 0x00)
														goto l08078E70;
													goto l08078E5C;
												}
												else
												{
													if ((ax_2511 & 0x0C00) > 0x0400)
													{
														if ((ax_2511 & 0x0C00) == 0x0800)
														{
															if (ebp_1126->dwFFFFFFA4 != 0x00)
																goto l08078E70;
l08078E5C:
															if (eax_2458 > 0x34)
																goto l08079368;
															goto l08078E65;
														}
														if ((ax_2511 & 0x0C00) == 0x0C00)
															goto l08078E70;
													}
													else if ((ax_2511 & 0x0C00) == 0x00)
													{
														if (eax_2458 <= 0x34)
														{
l08078E70:
															edx_2586 = (word32) ebp_1126->tFFFFFF3C + ebp_1126->dwFFFFFF38;
															goto l08078E7C;
														}
														if ((ebp_1126->ptrFFFFFF88 & 0x01) != 0x00)
														{
l08079368:
															Eq_80172 eax_2585;
															eax_2563 = edi_2346 - (struct Eq_84611 *) 0x04;
															word32 esi_2567 = *((word32) edi_2346 - 4);
															Eq_80172 ecx_2568 = eax_2563;
															if (ebx_2401 == 0x00)
															{
																eax_2585 = edi_2346;
																edx_2586 = (word32) ebp_1126->tFFFFFF3C + ebp_1126->dwFFFFFF38;
																goto l08079B76;
															}
															word32 esi_2622;
															int32 edx_2588 = 0x00;
															if (esi_2567 != ebp_1126->dwFFFFFF50)
															{
																if (esi_2567 == 0x39)
																{
																	ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) edi_2346;
																	word32 edi_2594 = ebp_1126->dwFFFFFF50;
																	do
																	{
																		*ecx_2568 = 0x30;
																		ecx_2568 -= (struct Eq_84657 *) 0x04;
																		esi_2567 = (word32) *ecx_2568;
																		++edx_2588;
																		if (esi_2567 == edi_2594)
																		{
																			edi_2346 = ebp_1126->ptrFFFFFF88;
																			goto l080793BE;
																		}
																	} while (esi_2567 == 0x39);
																	edi_2346 = ebp_1126->ptrFFFFFF88;
																}
																if (edx_2588 != ebp_1126->dwFFFFFF38 || ebp_1126->tFFFFFF3C <= 0x00)
																{
l08079D57:
																	esi_2622 = esi_2567 + 0x01;
																	*ecx_2568 = esi_2622;
l080793EC:
																	edx_2586 = (word32) ebp_1126->tFFFFFF3C + ebp_1126->dwFFFFFF38;
																	if (esi_2622 != ebp_1126->dwFFFFFF50)
																	{
																		if (edx_2586 >= ebx_2401 || *((word32) edi_2346 - 4) != 0x30)
																		{
l08078EC0:
																			byte * edx_2915 = ebp_1126->ptrFFFFFF78;
																			if (edx_2915 != null)
																			{
																				Eq_2 esi_2919 = ebp_1126->dwFFFFFF24;
																				ebp_1126->ptrFFFFFF68 = (Eq_2 (*)[]) esi_2919;
																				if (ebp_1126->dwFFFFFF4C == esi_2919)
																				{
l08078F0C:
																					word32 esi_2943 = ebp_1126->dwFFFFFF28;
																					if (esi_2943 != 0x00)
																					{
																						int32 ecx_2947 = ebp_1126->tFFFFFF40;
																						ui32 ebx_2948 = ebp_1126->dwFFFFFF24;
																						Eq_2 eax_2987 = ecx_2947 + ebx_2948 * 0x04;
																						Eq_2 esp_2986 = esp_2256 - (struct Eq_84845 *) 0x04;
																						*((word32) esp_2986 - 4) = edi_2346 - eax_2987 >> 0x02;
																						*((word32) esp_2986 - 8) = eax_2987;
																						ui32 ebx_2988 = ebx_2948 + esi_2943;
																						*((word32) esp_2986 - 0x0C) = ecx_2947 + (ebx_2988 << 0x02);
																						wmemmove(*((word32) esp_2986 - 0x0C), *((word32) esp_2986 - 8), *((word32) esp_2986 - 4));
																						byte * eax_3011 = ebp_1126->ptrFFFFFF78;
																						ebp_1126->ptrFFFFFF88 = ecx_2947 - 0x04 + (ebx_2988 << 0x02);
																						ebp_1126->tFFFFFF58.u3 = edi_2346;
																						esp_2959 = esp_2986;
																						Eq_2 (* edx_3017)[] = (int32) *eax_3011;
																						Eq_2 esi_3018[] = ebp_1126->ptrFFFFFF68;
																						do
																						{
																							ebp_1126->ptrFFFFFF68 = edx_3017;
																							Eq_84947 esi_3029 = esi_3018 + ((edx_3017 << 0x1E) - edx_3017) / 4;
																							int32 edi_3025 = -edx_3017;
																							Eq_84902 ebx_3032 = (word32) ebp_1126->tFFFFFF40 + esi_3029 * 0x04;
																							Eq_84935 (* ecx_3034)[] = ebp_1126->ptrFFFFFF88 + (edi_3025 << 0x02) / 4;
																							Eq_2 (* eax_3035)[] = edx_3017;
																							do
																							{
																								ecx_3034[eax_3035].u0 = (ebx_3032 - 0x04)[eax_3035];
																								--eax_3035;
																							} while (eax_3035 != null);
																							Eq_2 (* edx_3047)[] = ebp_1126->ptrFFFFFF68;
																							ebp_1126->ptrFFFFFF88 = ebp_1126->ptrFFFFFF88 - 0x04 + (edi_3025 << 0x02);
																							ecx_3034[0].u0 = ebp_1126->dwFFFFFF48;
																							struct Eq_84939 * eax_3056 = ebp_1126->ptrFFFFFF78;
																							edx_3017 = (int32) eax_3056->b0001;
																							esi_3018 = esi_3029 - (edx_3047 << 0x1E);
																							ci8 dl_3058 = (byte) edx_3017;
																							if (dl_3058 == 0x7F || dl_3058 < 0x00)
																								break;
																							if (dl_3058 != 0x00)
																								ebp_1126->ptrFFFFFF78 = &eax_3056->b0001;
																							else
																								edx_3017 = (int32) *ebp_1126->ptrFFFFFF78;
																						} while (edx_3017 < esi_3018);
																						struct Eq_84955 * ecx_3078 = ebp_1126->tFFFFFF40;
																						Eq_84959 edi_3081 = ebp_1126->tFFFFFF58;
																						word32 * eax_3083 = ecx_3078 - 0x04 + esi_3018 *32 0x04;
																						struct Eq_84955 * esi_3084 = ebp_1126->ptrFFFFFF88;
																						do
																						{
																							esi_3084 -= 0x04;
																							esi_3084[1] = (struct Eq_84955) *eax_3083;
																							eax_3083 -= 0x04;
																						} while (esi_3084 > ecx_3078);
																						edi_2346 = edi_3081 + Mem3091[ebp_1126 + -0x00D8:word32] * 0x04;
																					}
																					goto l08079010;
																				}
																				ebp_1126->dwFFFFFF28 = 0x00;
																				word32 ecx_2924 = (word32) *edx_2915;
																				ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) (byte) ecx_2924;
																				if ((byte) (ecx_2924 - 0x01) <= 0x7D)
																				{
																					ebp_1126->dwFFFFFF28 = (ui32) __guess_grouping.part.0(esi_2919, edx_2915);
																					goto l08078F0C;
																				}
																			}
l08079010:
																			word32 eax_3101 = ebp_1126->dwFFFFFFAC;
																			if (eax_3101 == 0x66)
																				goto l08079098;
																			word32 eax_3117;
																			ebx_2058 = ebp_1126->dwFFFFFFB0;
																			if (ebp_1126->dwFFFFFFA8 == 0x00)
																			{
																				*edi_2346 = eax_3101;
																				eax_3117 = 0x2B;
																			}
																			else
																			{
																				if (ebp_1126->dwFFFFFF18 == 0x67 && ebx_2058 == 0x04)
																					goto l0807A5B4;
																				*edi_2346 = eax_3101;
																				eax_3117 = 0x2D;
																			}
																			Eq_85048 esi_3130;
																			*((word32) edi_2346 + 4) = eax_3117;
																			Eq_85048 esi_3121 = (word32) edi_2346 + 8;
																			if (ebx_2058 > 0x09)
																			{
																				int32 ecx_3131 = 0x0A;
																				do
																				{
																					ui32 ecx_3134 = ecx_3131 * 0x05;
																					ecx_3131 = ecx_3134 * 0x02;
																				} while (ecx_3134 * 0x02 <= ebx_2058);
																				ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) ebx_2058;
																				Eq_85048 ebx_3145 = esi_3121;
																				while (true)
																				{
																					int32 esi_3157 = (SLICE(ecx_3131 *s64 0x66666667, word32, 32) >> 0x02) - (ecx_3131 >> 0x1F);
																					int64 edx_eax_3161 = (int64) ebp_1126->ptrFFFFFF88;
																					Eq_2 edx_3165 = (int32) (edx_eax_3161 % esi_3157);
																					ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) edx_3165;
																					ebx_3145 = (word32) ebx_3145 + 4;
																					*((word32) ebx_3145 - 4) = (int32) (edx_eax_3161 /32 esi_3157) + 0x30;
																					if (ecx_3131 <= 0x6D)
																						break;
																					ecx_3131 = esi_3157;
																				}
																				ebp_1126->dwFFFFFFB0 = (int32) edx_3165;
																				esi_3130 = ebx_3145;
																				ebx_2058 = edx_3165;
																			}
																			else
																			{
																				*((word32) edi_2346 + 8) = 0x30;
																				esi_3130 = (word32) edi_2346 + 0x0C;
																			}
																			*esi_3130 = (word32) ebx_2058 + 48;
																			edi_2346 = (word32) esi_3130 + 4;
l08079098:
																			Eq_2 eax_3913;
																			ebx_2058 = ebp_1126->dwFFFFFFA4;
																			ui32 esi_3890 = (word32) ebp_1126->ptrFFFFFF84->b000C;
																			Eq_80694 eax_3893 = edi_2346 - ebp_1126->tFFFFFF40;
																			ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) ebx_2058;
																			ebp_1126->tFFFFFF58 = eax_3893;
																			ui32 edx_3898 = esi_3890;
																			int32 eax_3899 = -(eax_3893 >> 0x02);
																			byte cl_3907 = (byte) (esi_3890 & 0x20);
																			if (ebx_2058 != 0x00)
																			{
																				ebp_1126->ptrFFFFFF68 = ebp_1126->dwFFFFFF1C - 0x01 + eax_3899;
																				if (cl_3907 == 0x00)
																				{
																					eax_3913 = ebp_1126->ptrFFFFFF84->t0010;
																					if (ebp_1126->ptrFFFFFF68 > null && eax_3913 != 0x30)
																						goto l080790FC;
																				}
																				ebx_2058.u0 = 0x00;
																				goto l080794B2;
																			}
																			else
																			{
																				if ((esi_3890 & 0x50) != 0x00)
																				{
																					ebx_2058 = ebp_1126->dwFFFFFF1C;
																					ebp_1126->ptrFFFFFF68 = ebx_2058 - 0x01 + eax_3899;
																					if (cl_3907 != 0x00)
																						goto l08079148;
																					eax_3913 = ebp_1126->ptrFFFFFF84->t0010;
																					if (ebp_1126->ptrFFFFFF68 > null && eax_3913 != 0x30)
																					{
l080790FC:
																						Eq_2 eax_3996;
																						if (ebp_1126->dwFFFFFF54 != 0x00)
																						{
																							struct Eq_80823 * esp_4011 = esp_2959 - 0x04;
																							esp_4011->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_4011->tFFFFFFF8 = eax_3913;
																							esp_4011->tFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4029 = <invalid>;
																							word32 esi_9196;
																							word32 edx_9195;
																							word32 ecx_9194;
																							eax_3996 = _IO_wpadn(gs, esp_4011->tFFFFFFF4, esp_4011->tFFFFFFF8, esp_4011->tFFFFFFFC, out ecx_9194, out edx_9195, out ebx_2058, out ebp_1126, out esi_9196, out edi_2346);
																							esp_2959 = (word32) esp_4029 + 16;
																						}
																						else
																						{
																							struct Eq_80782 * esp_3963 = esp_2959 - 0x04;
																							esp_3963->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_3963->tFFFFFFF8 = eax_3913;
																							esp_3963->tFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4003 = <invalid>;
																							word32 ecx_9191;
																							word32 edx_9192;
																							word32 esi_9193;
																							eax_3996 = _IO_padn(gs, esp_3963->tFFFFFFF4, esp_3963->tFFFFFFF8, esp_3963->tFFFFFFFC, out ecx_9191, out edx_9192, out ebx_2058, out ebp_1126, out esi_9193, out edi_2346);
																							esp_2959 = (word32) esp_4003 + 16;
																						}
																						Eq_2 esi_4039 = ebp_1126->ptrFFFFFF68;
																						if (eax_3996 != esi_4039)
																							goto l08078BA2;
																						if (ebp_1126->dwFFFFFFA4 == 0x00)
																						{
																							struct Eq_80877 * eax_4131 = ebp_1126->ptrFFFFFF84;
																							ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) esi_4039;
																							esi_3890 = (word32) eax_4131->b000C;
																							goto l08079148;
																						}
																						ebx_2058 = ebp_1126->ptrFFFFFF68;
l080794B2:
																						int8 al_4080;
																						if (ebp_1126->dwFFFFFF54 != 0x00)
																						{
																							Eq_2 eax_4086 = ebp_1126->ptrFFFFFF7C->t0058;
																							if (eax_4086 != 0x00)
																							{
																								struct Eq_80410 * edx_4090 = *((word32) eax_4086 + 16);
																								if (edx_4090 < *((word32) eax_4086 + 20))
																								{
																									*((word32) eax_4086 + 16) = (char *) &edx_4090->t0000 + 4;
																									edx_4090->t0000.u0 = 0x2D;
																									goto l080794E9;
																								}
																							}
																							struct Eq_80980 * esp_4094 = esp_2959 - 0x08;
																							esp_4094->tFFFFFFFC.u0 = 0x2D;
																							esp_4094->tFFFFFFF8 = ebp_1126->ptrFFFFFF7C;
																							word32 ecx_9199;
																							al_4080 = (int8) (__woverflow(esp_4094->tFFFFFFF8, esp_4094->tFFFFFFFC, out ecx_9199) == ~0x00);
																						}
																						else
																						{
																							Eq_2 esi_4056 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 eax_4057 = *((word32) esi_4056 + 20);
																							if (eax_4057 < *((word32) esi_4056 + 24))
																							{
																								ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_4057 + 1;
																								*eax_4057 = 0x2D;
																								goto l080794E9;
																							}
																							struct Eq_82064 * esp_4063 = esp_2959 - (struct Eq_82065 *) 0x08;
																							esp_4063->tFFFFFFFC.u0 = 0x2D;
																							esp_4063->tFFFFFFF8 = esi_4056;
																							word32 ecx_9236;
																							word32 edx_9237;
																							al_4080 = (int8) (__overflow(esp_4063->tFFFFFFF8, esp_4063->tFFFFFFFC, out ecx_9236, out edx_9237) == ~0x00);
																						}
																						if (al_4080 != 0x00)
																							goto l08078BA2;
l080794E9:
																						ebp_1126->ptrFFFFFF88 = (word32) ebx_2058 + 1;
																						edx_3898 = (word32) ebp_1126->ptrFFFFFF84->b000C;
l08079198:
																						if ((edx_3898 & 0x20) != 0x00 || ((ebp_1126->ptrFFFFFF84)->t0010 != 0x30 || ebp_1126->ptrFFFFFF68 <= null))
																						{
l080791B4:
																							<anonymous> * eax_4442;
																							Eq_2 esi_4410;
																							Eq_2 edi_4431;
																							ebx_2058 = ebp_1126->dwFFFFFF54;
																							struct Eq_81088 * eax_4375 = ebp_1126->ptrFFFFFF84;
																							if (ebx_2058 != 0x00)
																							{
																								if ((eax_4375->b000D & 0x08) == 0x00)
																									ebx_2058.u0 = 0x00;
																								else
																								{
																									esp_2959.u0 = <invalid>;
																									word32 esi_9207;
																									ebx_2058 = _i18n_number_rewrite(0x00, 0x00, 0x00, gs, out ebp_1126, out esi_9207, out edi_2346);
																								}
																								Eq_81311 eax_4408 = ebp_1126->tFFFFFF58;
																								esi_4410 = eax_4408 >> 0x02;
																								if (edi_2346 != ebp_1126->tFFFFFF40)
																								{
																									edi_4431 = ebp_1126->ptrFFFFFF7C->t0094;
																									if (edi_4431 < 135066356)
																									{
																										ebp_1126->ptrFFFFFF78 = 0x00;
																										eax_4442 = (<anonymous> *) *((word32) edi_4431 + 28);
																										goto l08078B2A;
																									}
																									ebp_1126->ptrFFFFFF78 = 0x00;
l0807A185:
																									word32 edx_9230;
																									word32 ecx_9229;
																									_IO_vtable_check(out ecx_9229, out edx_9230);
																									esp_2959.u0 = <invalid>;
																									eax_4442 = (<anonymous> *) *((word32) edi_4431 + 28);
																									if (ebp_1126->dwFFFFFF54 != 0x00)
																										ebx_2058 = ebp_1126->tFFFFFF40;
																									ebp_1126->tFFFFFF40.u2 = ebx_2058;
l08078B2A:
																									struct Eq_81860 * esp_4855 = esp_2959 - (struct Eq_81861 *) 0x04;
																									esp_4855->tFFFFFFFC = esi_4410;
																									esp_4855->tFFFFFFF8 = ebp_1126->tFFFFFF40;
																									esp_4855->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																									Eq_2 eax_5028;
																									eax_4442();
																									esp_2959 = esp_4855 + 0x04;
																									if (eax_5028 != esi_4410)
																										goto l08078BA2;
																									goto l08078B46;
																								}
																								if (eax_4408 >> 0x02 != 0x00)
																								{
																									Eq_2 ecx_4448 = ebp_1126->ptrFFFFFF88;
																									ebp_1126->ptrFFFFFF88 = (word32) ecx_4448 + (eax_4408 >> 0x02);
																									ebx_2058 = ecx_4448;
																									Eq_2 esi_4456[] = (word32) edi_2346 + -ecx_4448 * 0x04;
																									do
																									{
																										int8 al_4474;
																										Eq_2 ecx_4462 = esi_4456[ebx_2058];
																										Eq_2 eax_4463 = ebp_1126->ptrFFFFFF7C->t0058;
																										if (eax_4463 == 0x00)
																										{
l0807957A:
																											struct Eq_81476 * esp_4478 = esp_2959 - (struct Eq_81477 *) 0x08;
																											esp_4478->tFFFFFFFC = ecx_4462;
																											esp_4478->tFFFFFFF8 = ebp_1126->ptrFFFFFF7C;
																											word32 ecx_9214;
																											al_4474 = (int8) (__woverflow(esp_4478->tFFFFFFF8, esp_4478->tFFFFFFFC, out ecx_9214) == ~0x00);
																											goto l08079556;
																										}
																										struct Eq_80410 * edx_4467 = *((word32) eax_4463 + 16);
																										if (edx_4467 >= *((word32) eax_4463 + 20))
																											goto l0807957A;
																										*((word32) eax_4463 + 16) = (char *) &edx_4467->t0000 + 4;
																										edx_4467->t0000 = ecx_4462;
																										al_4474 = (int8) (ecx_4462 == ~0x00);
l08079556:
																										if (al_4474 != 0x00)
																											goto l08078BA2;
																										ebx_2058 = (word64) ebx_2058.u0 + 1;
																									} while (ebx_2058 != ebp_1126->ptrFFFFFF88);
																									ebp_1126->ptrFFFFFF78 = 0x00;
																								}
																								else
																									ebp_1126->ptrFFFFFF78 = 0x00;
l08078B46:
																								if (ebp_1126->dwFFFFFF14 == 0x00)
																								{
																									struct Eq_81560 * esp_5048 = esp_2959 - (struct Eq_81561 *) 0x0C;
																									Eq_2 edi_5050 = ebp_1126->dwFFFFFF80;
																									esp_5048->tFFFFFFFC = ebp_1126->ptrFFFFFF78;
																									word32 ecx_9216;
																									word32 edx_9217;
																									free(gs, esp_5048->tFFFFFFF8, esp_5048->tFFFFFFFC, out ecx_9216, out edx_9217);
																									esp_5048->a0000[0] = ebp_1126->ptrFFFFFF20;
																									word32 edx_9219;
																									word32 ecx_9218;
																									free(gs, esp_5048->tFFFFFFFC, esp_5048->a0000[0], out ecx_9218, out edx_9219);
																									ebx_2058 = edi_5050;
																									esp_2959 = esp_5048 + 0x14;
																								}
																								struct Eq_81605 * eax_5087 = ebp_1126->ptrFFFFFF84;
																								if ((eax_5087->b000C & 0x20) != 0x00)
																								{
																									Eq_2 edi_5091 = ebp_1126->ptrFFFFFF68;
																									if (edi_5091 > 0x00)
																									{
																										Eq_2 eax_5111;
																										Eq_2 eax_5095 = eax_5087->t0010;
																										if (ebp_1126->dwFFFFFF54 != 0x00)
																										{
																											struct Eq_81674 * esp_5126 = esp_2959 - (struct Eq_81675 *) 0x04;
																											esp_5126->tFFFFFFFC = edi_5091;
																											esp_5126->tFFFFFFF8 = eax_5095;
																											esp_5126->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																											Eq_2 esp_5143 = <invalid>;
																											word32 esi_9226;
																											word32 edi_9227;
																											word32 edx_9225;
																											word32 ecx_9224;
																											eax_5111 = _IO_wpadn(gs, esp_5126->dwFFFFFFF4, esp_5126->tFFFFFFF8, esp_5126->tFFFFFFFC, out ecx_9224, out edx_9225, out ebx_2058, out ebp_1126, out esi_9226, out edi_9227);
																											esp_2959 = (word32) esp_5143 + 16;
																										}
																										else
																										{
																											struct Eq_81632 * esp_5100 = esp_2959 - (struct Eq_81633 *) 0x04;
																											esp_5100->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																											esp_5100->tFFFFFFF8 = eax_5095;
																											esp_5100->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																											Eq_2 esp_5118 = <invalid>;
																											word32 edx_9221;
																											word32 esi_9222;
																											word32 edi_9223;
																											word32 ecx_9220;
																											eax_5111 = _IO_padn(gs, esp_5100->dwFFFFFFF4, esp_5100->tFFFFFFF8, esp_5100->tFFFFFFFC, out ecx_9220, out edx_9221, out ebx_2058, out ebp_1126, out esi_9222, out edi_9223);
																											esp_2959 = (word32) esp_5118 + 16;
																										}
																										if (eax_5111 != ebp_1126->ptrFFFFFF68)
																											goto l08078BA2;
																										goto l080782C8;
																									}
																								}
																								goto l080782CA;
																							}
																							if ((eax_4375->b000D & 0x08) != 0x00)
																								ebp_1126->dwFFFFFF30 *= *((char *) *ebp_1126->ptrFFFFFF44 + 88);
																							int32 edx_4545;
																							struct Eq_81128 * esp_4524 = esp_2959 - 0x0C;
																							esp_4524->tFFFFFFFC = ebp_1126->dwFFFFFF34;
																							word32 edx_9201;
																							word32 ecx_9200;
																							ebp_1126->tFFFFFF58.u2 = strlen(esp_4524->tFFFFFFFC, out ecx_9200, out edx_9201);
																							Eq_2 eax_4540 = ebp_1126->dwFFFFFF2C;
																							if (eax_4540 != 0x00)
																							{
																								esp_4524->tFFFFFFFC = eax_4540;
																								word32 ecx_9202;
																								word32 edx_9203;
																								Eq_2 eax_4552 = strlen(esp_4524->tFFFFFFFC, out ecx_9202, out edx_9203);
																								int32 edx_4559 = ebp_1126->dwFFFFFF28;
																								ebp_1126->dwFFFFFF4C = (int32) eax_4552;
																								edx_4545 = edx_4559 *s eax_4552;
																							}
																							else
																							{
																								ebp_1126->dwFFFFFF4C = 0x00;
																								edx_4545 = 0x00;
																							}
																							word32 ecx_4568 = ebp_1126->dwFFFFFF14;
																							Eq_2 eax_4571 = (word32) ebp_1126->tFFFFFF58 + (ebp_1126->dwFFFFFF30 + 0x02) + edx_4545;
																							ebp_1126->ptrFFFFFF44 = (struct Eq_81163 **) eax_4571;
																							if (ecx_4568 != 0x00)
																							{
																								Eq_81245 eax_4600 = ebp_1126->ptrFFFFFF44;
																								word32 esi_4605 = esp_2959 - (eax_4600 + 0x1B & ~0x0FFF);
																								word32 edx_4606 = eax_4600 + 0x1B & ~0x0F;
																								while (esp_2959 != esi_4605)
																								{
																									esp_2959 -= 0x1000;
																									*((word32) esp_2959 + 0x0FFC) = *((word32) esp_2959 + 0x0FFC);
																								}
																								if ((edx_4606 & 0x0FFF) != 0x00)
																								{
																									esp_2959 -= edx_4606 & 0x0FFF;
																									Mem4629[esp_2959 - 0x04 + (edx_4606 & 0x0FFF):word32] = Mem4627[esp_2959 - 0x04 + (edx_4606 & 0x0FFF):word32];
																								}
																								Mem4640[ebp_1126 + -0x0088:word32] = esp_2959 + 0x0F & ~0x0F;
																							}
																							else
																							{
																								struct Eq_81213 * esp_4577 = esp_2959 - 0x0C;
																								esp_4577->tFFFFFFFC = eax_4571;
																								word32 ecx_9204;
																								word32 edx_9205;
																								word32 esi_9206;
																								Eq_2 eax_4584 = __libc_malloc(gs, esp_4577->tFFFFFFF8, esp_4577->tFFFFFFFC, out ecx_9204, out edx_9205, out ebx_2058, out ebp_1126, out esi_9206, out edi_2346);
																								ebp_1126->ptrFFFFFF78 = (byte *) eax_4584;
																								esp_2959 = (char *) &esp_4577->tFFFFFFFC + 16;
																								if (eax_4584 == 0x00)
																								{
l08078BAC:
																									struct Eq_80935 * esp_5166 = esp_2959 - 0x0C;
																									esp_5166->tFFFFFFFC = ebp_1126->ptrFFFFFF20;
																									ebx_2058 = ebp_1126->dwFFFFFF80;
																									word32 ecx_9197;
																									word32 edx_9198;
																									free(gs, esp_5166->tFFFFFFF8, esp_5166->tFFFFFFFC, out ecx_9197, out edx_9198);
																									goto l08078BC0;
																								}
																							}
																							Eq_2 eax_4656;
																							Eq_80172 eax_4643 = ebp_1126->tFFFFFF40;
																							if (edi_2346 > eax_4643)
																							{
																								Eq_80172 esi_4657 = eax_4643;
																								eax_4656 = ebp_1126->ptrFFFFFF78;
																								do
																								{
																									word32 ebx_4661 = *esi_4657;
																									byte bl_4690 = (byte) ebx_4661;
																									if (ebx_4661 == ebp_1126->dwFFFFFF50)
																									{
																										struct Eq_81516 * esp_4694 = esp_2959 - (struct Eq_81517 *) 0x04;
																										esp_4694->tFFFFFFFC = ebp_1126->tFFFFFF58;
																										esp_4694->tFFFFFFF8 = ebp_1126->dwFFFFFF34;
																										esp_4694->dwFFFFFFF4 = (word32) eax_4656;
																										word32 edx_9215;
																										eax_4656 = __mempcpy(esp_4694->dwFFFFFFF4, esp_4694->tFFFFFFF8, esp_4694->tFFFFFFFC, out edx_9215);
																									}
																									else if (ebp_1126->dwFFFFFF48 != ebx_4661)
																									{
																										*eax_4656 = bl_4690;
																										eax_4656 = (word32) eax_4656 + 1;
																									}
																									else
																									{
																										struct Eq_81794 * esp_4668 = esp_2959 - (struct Eq_81795 *) 0x04;
																										esp_4668->tFFFFFFFC = ebp_1126->dwFFFFFF4C;
																										esp_4668->tFFFFFFF8 = ebp_1126->dwFFFFFF2C;
																										esp_4668->dwFFFFFFF4 = (word32) eax_4656;
																										word32 edx_9231;
																										eax_4656 = __mempcpy(esp_4668->dwFFFFFFF4, esp_4668->tFFFFFFF8, esp_4668->tFFFFFFFC, out edx_9231);
																									}
																									esi_4657 = (word32) esi_4657 + 4;
																								} while (edi_2346 > esi_4657);
																								if ((ebp_1126->ptrFFFFFF84->b000D & 0x08) == 0x00)
																								{
																									ebx_2058 = ebp_1126->ptrFFFFFF78;
l08078AEB:
																									Eq_2 eax_4763 = eax_4656 - ebx_2058;
																									esi_4410 = eax_4763;
																									if (eax_4763 > 0x14)
																									{
																										edi_4431 = ebp_1126->ptrFFFFFF7C->t0094;
																										if (edi_4431 < 135066356)
																										{
																											ebp_1126->tFFFFFF40.u2 = ebx_2058;
																											eax_4442 = (<anonymous> *) *((word32) edi_4431 + 28);
																											goto l08078B2A;
																										}
																										goto l0807A185;
																									}
																									int32 esi_4769 = ebp_1126->ptrFFFFFF88;
																									ebx_2058 -= esi_4769;
																									word32 edi_4771 = (word32) eax_4763 + esi_4769;
																									if (eax_4763 != 0x00)
																									{
																										ebp_1126->ptrFFFFFF88 = edi_4771;
																										Eq_2 edi_4779 = ebp_1126->ptrFFFFFF7C;
																										do
																										{
																											Eq_2 edx_4783 = (word32) *((word32) ebx_2058 + esi_4769);
																											byte dl_4790 = (byte) edx_4783;
																											Eq_2 eax_4785 = *((word32) edi_4779 + 20);
																											if (eax_4785 >= *((word32) edi_4779 + 24))
																											{
																												struct Eq_81893 * esp_4793 = esp_2959 - (struct Eq_81894 *) 0x08;
																												esp_4793->tFFFFFFFC = edx_4783;
																												esp_4793->tFFFFFFF8 = edi_4779;
																												esp_2959 = esp_4793 + 0x08;
																												word32 ecx_9232;
																												word32 edx_9233;
																												if (__overflow(esp_4793->tFFFFFFF8, esp_4793->tFFFFFFFC, out ecx_9232, out edx_9233) == ~0x00)
																													goto l08078BA2;
																											}
																											else
																											{
																												*((word32) edi_4779 + 20) = (word32) eax_4785 + 1;
																												*eax_4785 = dl_4790;
																											}
																											++esi_4769;
																										} while (esi_4769 != ebp_1126->ptrFFFFFF88);
																										goto l08078B46;
																									}
l0807A155:
																									goto l08078B46;
																								}
																							}
																							else
																							{
																								if ((ebp_1126->ptrFFFFFF84->b000D & 0x08) == 0x00)
																									goto l0807A155;
																								eax_4656 = ebp_1126->ptrFFFFFF78;
																							}
																							Eq_2 edi_4729 = ebp_1126->ptrFFFFFF78;
																							esp_2959.u0 = <invalid>;
																							Eq_2 esi_4752;
																							word32 edi_9228;
																							ebx_2058 = _i18n_number_rewrite(edi_4729, Mem4728[ebp_1126 + -188:word32] + edi_4729, eax_4656, gs, out ebp_1126, out esi_4752, out edi_9228);
																							eax_4656 = esi_4752;
																							goto l08078AEB;
																						}
																						Eq_2 eax_4322;
																						if (ebp_1126->dwFFFFFF54 != 0x00)
																						{
																							struct Eq_81390 * esp_4337 = esp_2959 - (struct Eq_81391 *) 0x04;
																							esp_4337->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_4337->tFFFFFFF8.u0 = 0x30;
																							esp_4337->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4355 = <invalid>;
																							word32 edx_9212;
																							word32 esi_9213;
																							word32 ecx_9211;
																							eax_4322 = _IO_wpadn(gs, esp_4337->dwFFFFFFF4, esp_4337->tFFFFFFF8, esp_4337->tFFFFFFFC, out ecx_9211, out edx_9212, out ebx_2058, out ebp_1126, out esi_9213, out edi_2346);
																							esp_2959 = (word32) esp_4355 + 16;
																						}
																						else
																						{
																							struct Eq_81348 * esp_4298 = esp_2959 - (struct Eq_81349 *) 0x04;
																							esp_4298->tFFFFFFFC = ebp_1126->ptrFFFFFF68;
																							esp_4298->tFFFFFFF8.u0 = 0x30;
																							esp_4298->dwFFFFFFF4 = ebp_1126->ptrFFFFFF7C;
																							Eq_2 esp_4329 = <invalid>;
																							word32 edx_9209;
																							word32 esi_9210;
																							word32 ecx_9208;
																							eax_4322 = _IO_padn(gs, esp_4298->dwFFFFFFF4, esp_4298->tFFFFFFF8, esp_4298->tFFFFFFFC, out ecx_9208, out edx_9209, out ebx_2058, out ebp_1126, out esi_9210, out edi_2346);
																							esp_2959 = (word32) esp_4329 + 16;
																						}
																						if (eax_4322 == ebp_1126->ptrFFFFFF68)
																						{
																							Mem4370[ebp_1126 + -0x0078:word32] = Mem4365[ebp_1126 + -0x0078:word32] + Mem4365[ebp_1126 + -0x0098:word32];
																							goto l080791B4;
																						}
l08078BA2:
																						if (ebp_1126->dwFFFFFF14 != 0x00)
																							goto l08078BC0;
																						goto l08078BAC;
																					}
																				}
																				else
																				{
																					ebp_1126->ptrFFFFFF68 = eax_3899 + ebp_1126->dwFFFFFF1C;
																					if (cl_3907 != 0x00)
																						goto l0807914A;
																					eax_3913 = ebp_1126->ptrFFFFFF84->t0010;
																					if (eax_3913 != 0x30)
																					{
																						ebx_2058 = ebp_1126->ptrFFFFFF68;
																						if (ebx_2058 > 0x00)
																							goto l080790FC;
																					}
																				}
l08079148:
																				edx_3898 = esi_3890;
l0807914A:
																				int8 al_4175;
																				if ((esi_3890 & 0x40) != 0x00)
																				{
																					if (ebp_1126->dwFFFFFF54 != 0x00)
																					{
																						Eq_2 eax_4227 = ebp_1126->ptrFFFFFF7C->t0058;
																						if (eax_4227 != 0x00)
																						{
																							struct Eq_80410 * edx_4231 = *((word32) eax_4227 + 16);
																							if (edx_4231 < *((word32) eax_4227 + 20))
																							{
																								*((word32) eax_4227 + 16) = (char *) &edx_4231->t0000 + 4;
																								edx_4231->t0000.u0 = 0x2B;
																								goto l0807918D;
																							}
																						}
																						*((word32) esp_2959 - 0x0C) = 0x2B;
																						goto l0807A3B9;
																					}
																					Eq_2 ecx_4200 = ebp_1126->ptrFFFFFF7C;
																					Eq_2 eax_4201 = *((word32) ecx_4200 + 20);
																					if (eax_4201 < *((word32) ecx_4200 + 24))
																					{
																						ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_4201 + 1;
																						*eax_4201 = 0x2B;
																						goto l0807918D;
																					}
																					struct Eq_81966 * esp_4204 = esp_2959 - (struct Eq_81967 *) 0x08;
																					esp_4204->tFFFFFFFC.u0 = 0x2B;
																					esp_4204->tFFFFFFF8 = ecx_4200;
																					word32 edx_9235;
																					word32 ecx_9234;
																					al_4175 = (int8) (__overflow(esp_4204->tFFFFFFF8, esp_4204->tFFFFFFFC, out ecx_9234, out edx_9235) == ~0x00);
																				}
																				else
																				{
																					if ((esi_3890 & 0x10) == 0x00)
																						goto l08079198;
																					if (ebp_1126->dwFFFFFF54 != 0x00)
																					{
																						Eq_2 eax_4181 = ebp_1126->ptrFFFFFF7C->t0058;
																						if (eax_4181 != 0x00)
																						{
																							struct Eq_80410 * edx_4185 = *((word32) eax_4181 + 16);
																							if (edx_4185 < *((word32) eax_4181 + 20))
																							{
																								*((word32) eax_4181 + 16) = (char *) &edx_4185->t0000 + 4;
																								edx_4185->t0000.u0 = 0x20;
																								goto l0807918D;
																							}
																						}
																						*((word64) esp_2959.u0 - 0x0C) = 0x20;
l0807A3B9:
																						struct Eq_82101 * esp_4244 = esp_2959 - (struct Eq_82102 *) 0x0C;
																						esp_4244->tFFFFFFFC = ebp_1126->ptrFFFFFF7C;
																						word32 ecx_9238;
																						al_4175 = (int8) (__woverflow(esp_4244->tFFFFFFFC, esp_4244->a0000[0], out ecx_9238) == ~0x00);
																						goto l0807A3CD;
																					}
																					Eq_2 esi_4152 = ebp_1126->ptrFFFFFF7C;
																					Eq_2 eax_4153 = *((word32) esi_4152 + 20);
																					if (eax_4153 < *((word32) esi_4152 + 24))
																					{
																						ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_4153 + 1;
																						*eax_4153 = 0x20;
l0807918D:
																						struct Eq_81171 * eax_4270 = ebp_1126->ptrFFFFFF84;
																						ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) ((char *) ebp_1126->ptrFFFFFF88 + 1);
																						edx_3898 = (word32) eax_4270->b000C;
																						goto l08079198;
																					}
																					struct Eq_82125 * esp_4158 = esp_2959 - (struct Eq_82126 *) 0x08;
																					esp_4158->tFFFFFFFC.u0 = 0x20;
																					esp_4158->tFFFFFFF8 = esi_4152;
																					word32 ecx_9239;
																					word32 edx_9240;
																					al_4175 = (int8) (__overflow(esp_4158->tFFFFFFF8, esp_4158->tFFFFFFFC, out ecx_9239, out edx_9240) == ~0x00);
																				}
l0807A3CD:
																				if (al_4175 != 0x00)
																					goto l08078BA2;
																				goto l0807918D;
																			}
																		}
																		goto l08078E99;
																	}
																	esi_2567 = (word32) *((word32) ecx_2568 - 4);
																	eax_2585 = ecx_2568;
																	ecx_2568 -= (struct Eq_84772 *) 0x04;
l08079B76:
																	if (esi_2567 == ebp_1126->dwFFFFFF50)
																	{
																		eax_2585 = ecx_2568;
																		ecx_2568 -= (struct Eq_85099 *) 0x04;
																	}
																	if (ebp_1126->tFFFFFF40 <= ecx_2568)
																	{
																		word32 eax_2693 = *((word32) eax_2585 - 4);
																		Eq_80172 esi_2694 = ebp_1126->tFFFFFF40;
																		while (eax_2693 == 0x39)
																		{
																			*ecx_2568 = 0x30;
																			ecx_2568 -= (struct Eq_85177 *) 0x04;
																			if (esi_2694 > ecx_2568)
																				goto l08079BB8;
																			eax_2693 = (word32) *ecx_2568;
																		}
																		*ecx_2568 = eax_2693 + 0x01;
																	}
																	else
																	{
l08079BB8:
																		if (ebp_1126->dwFFFFFFAC != 0x66)
																		{
																			ebp_1126->ptrFFFFFF20->a0008[0] = 0x31;
																			int32 v111_2808 = ebp_1126->dwFFFFFFB0 + ((0x00 - (ebp_1126->dwFFFFFFA8 < 0x01) & 0x02) - 0x01);
																			ebp_1126->dwFFFFFFB0 = v111_2808;
																			if (v111_2808 == 0x00)
																				ebp_1126->dwFFFFFFA8 = 0x00;
																		}
																		else
																		{
																			struct Eq_85263 * eax_2712 = ebp_1126->ptrFFFFFF20;
																			if (ebp_1126->dwFFFFFF10 != ebp_1126->dwFFFFFF24)
																			{
																				eax_2712->dw0004 = 0x31;
																				ebp_1126->tFFFFFF40 = &eax_2712->dw0004;
																				++ebp_1126->dwFFFFFF24;
																			}
																			else
																			{
																				word32 esi_2715 = ebp_1126->dwFFFFFF50;
																				eax_2712->dw0000 = 0x31;
																				eax_2712->dw0004 = esi_2715;
																				if ((ebp_1126->ptrFFFFFF84->b000C & 0x08) == 0x00 && ebx_2401 == 0x00)
																					ebx_2401.u0 = ebp_1126->dwFFFFFF10;
																				else
																				{
																					ui32 eax_2738 = ebp_1126->dwFFFFFF24;
																					ebp_1126->ptrFFFFFF20->a0008[eax_2738] = 0x30;
																					ebx_2401 = (word32) ebx_2401.u0 + 1 + eax_2738;
																				}
																				struct Eq_85382 * eax_2745 = ebp_1126->ptrFFFFFF84;
																				++ebp_1126->dwFFFFFFB0;
																				ui32 ecx_2748 = eax_2745->dw0008;
																				Eq_153925 eax_2781[] = gs->ptrFFFFFFF8;
																				ebp_1126->dwFFFFFF24 = 0x01;
																				ebp_1126->dwFFFFFFAC = (0x00 - (((eax_2781)[ecx_2748].w0000 & 0x0100) < 0x01) & 0x20) + 0x45;
																				ebp_1126->tFFFFFF40 = ebp_1126->ptrFFFFFF20;
																			}
																		}
																		int32 esi_2816 = ebp_1126->dwFFFFFF10;
																		int32 eax_2819 = (word32) ebx_2401.u0 + ebp_1126->dwFFFFFF24;
																		if (eax_2819 > esi_2816)
																		{
																			int32 eax_2822 = eax_2819 - esi_2816;
																			ebx_2401 -= eax_2822;
																			edi_2346 -= eax_2822 * 0x04;
																		}
																	}
l08078E7C:
																	if (ebx_2401 <= edx_2586)
																	{
l08078EA2:
																		if (ebx_2401 == 0x00 && (((ebp_1126->ptrFFFFFF84)->b000C & 0x08) == 0x00 && *((word32) edi_2346 - 4) == ebp_1126->dwFFFFFF50))
																			edi_2346 -= (struct Eq_84748 *) 0x04;
																		goto l08078EC0;
																	}
																	eax_2563 = edi_2346 - (struct Eq_84667 *) 0x04;
																	if (*((word32) edi_2346 - 4) != 0x30)
																		goto l08078EA2;
l08078E99:
																	while (true)
																	{
																		--ebx_2401;
																		edi_2346 = eax_2563;
																		if (ebx_2401 <= edx_2586 || *((word32) eax_2563 - 4) != 0x30)
																			break;
																		eax_2563 -= (struct Eq_84826 *) 0x04;
																	}
																	goto l08078EA2;
																}
																ebp_1126->tFFFFFF3C.u5 = ebp_1126->tFFFFFF3C - 0x01;
																if (esi_2567 != ebp_1126->dwFFFFFF50)
																	goto l08079D57;
															}
															else
															{
l080793BE:
																if (edx_2588 == ebp_1126->dwFFFFFF38)
																{
																	Eq_84700 esi_2633 = ebp_1126->tFFFFFF3C;
																	ebp_1126->tFFFFFF3C = (bool) ((int8) (esi_2633 > 0x00) < 0x01) + ((word32) esi_2633 - 1);
																}
															}
															esi_2622 = (word32) *ecx_2568;
															if (ebp_1126->dwFFFFFF18 == 0x67 && (ebp_1126->dwFFFFFFAC == 0x66 && (((ebp_1126->ptrFFFFFF84)->b000C & 0x08) != 0x00 && (ecx_2568 == (ebp_1126->ptrFFFFFF20)->a0008 + 1 && ((ebp_1126->ptrFFFFFF20)->a0008)[0] == 0x30))))
																ebp_1126->tFFFFFF3C.u1 = ebp_1126->tFFFFFF3C - 0x01;
															goto l080793EC;
														}
l08078E65:
														if (dl_2472 == 0x00)
															goto l08078E70;
														goto l08079368;
													}
													word32 edx_9267;
													word32 ecx_9266;
													abort(ecx_2486, gs, out ecx_9266, out edx_9267);
												}
											}
										}
										*eax_2358 = ebp_1126->dwFFFFFF50;
										edi_2346 = (word32) eax_2358 + 4;
										esi_2085 = 0x01;
										goto l08078A02;
									}
									ebp_1126->dwFFFFFF4C = 0x01;
									ebp_1126->dwFFFFFFAC = eax_1996 - 0x02;
									int32 eax_2136 = ebp_1126->dwFFFFFF10;
									ebp_1126->tFFFFFF58 = eax_2136 - 0x01;
									ebp_1126->dwFFFFFF30 = (int32) ((word64) edx_2103.u0 + 7);
									ebx_2058 = eax_2136 - 0x01;
									goto l0807886F;
								}
								ebx_2058 = ebp_1126->tFFFFFF58;
								ebp_1126->dwFFFFFFAC = 0x66;
								if (ebx_2058 < 0x00)
								{
									ebp_1126->tFFFFFF58 = 0x06;
									ebx_2058.u0 = 0x06;
								}
								if (ebp_1126->dwFFFFFFA8 == 0x00)
								{
									int32 eax_2089 = ebp_1126->dwFFFFFFB0;
									ebp_1126->dwFFFFFF10 = 0x7FFFFFFF;
									ebp_1126->dwFFFFFF30 = (int32) ((word64) ebx_2058.u0 + (eax_2089 + 0x02));
									Eq_85554 eax_2095 = ebp_1126->tFFFFFF58;
									ebp_1126->dwFFFFFF4C = eax_2089 + 0x01;
									ebp_1126->dwFFFFFF38 = (int32) eax_2095;
									esi_2085 = 0x01;
									goto l08078887;
								}
								ebp_1126->dwFFFFFF30 = (int32) ((word64) ebx_2058.u0 + 2);
							}
							else
							{
								ebp_1126->dwFFFFFFAC = eax_1996;
								if (esi_2044 >= 0x00)
								{
									ebp_1126->dwFFFFFF30 = (word32) esi_2044 + 8;
									ebx_2058 = esi_2044;
								}
								else
								{
									ebp_1126->dwFFFFFF30 = 0x0E;
									ebp_1126->tFFFFFF58 = 0x06;
									ebx_2058.u0 = 0x06;
								}
							}
							Eq_85567 eax_2084 = ebp_1126->tFFFFFF58;
							ebp_1126->dwFFFFFF10 = 0x7FFFFFFF;
							ebp_1126->dwFFFFFF4C = 0x01;
							ebp_1126->dwFFFFFF38 = (int32) eax_2084;
							esi_2085 = 0x01;
							goto l08078887;
						}
						else
						{
							int32 eax_1866;
							Eq_2 edx_1648;
							Eq_2 esi_1649;
							Eq_85750 ebx_1652;
							Eq_2 edi_1640;
							Eq_2 ecx_1641;
							Eq_85753 esi_1623 = ebp_1126->ptrFFFFFFBC;
							word32 edi_1625 = __bsr((esi_1623 - 0x04)[eax_1383]);
							Eq_85765 ebx_1626 = *esi_1623;
							ebp_1126->tFFFFFF40.u8 = esi_1623;
							ebp_1126->tFFFFFF58.u14 = ebx_1626;
							ebp_1126->dwFFFFFF4C = edi_1625 ^ 0x1F;
							if (ebx_1626 == 0x00)
							{
								Eq_2 ebx_1657[] = ebp_1126->ptrFFFFFFB4;
								Eq_2 edx_1658 = ebx_1657[0];
								ebp_1126->ptrFFFFFF88 = ebx_1657;
								if (edx_1658 == 0x00)
								{
									ebp_1126->tFFFFFF3C.u2 = eax_1383;
									Eq_2 esi_1674 = (word32) esi_1623 + 4;
									ebx_1652.u0 = 0x00;
									do
									{
										Eq_2 ecx_1681 = *esi_1674;
										ebx_1652 = (char *) ebx_1652.u0 + 1;
										ebp_1126->ptrFFFFFF68 = (Eq_2 (*)[]) ebx_1652;
										edx_1648 = esi_1674;
										if (ecx_1681 != 0x00)
										{
											int32 esi_1708 = ebp_1126->dwFFFFFF4C;
											ebp_1126->tFFFFFF58.u15 = ebx_1652 * 0x04;
											eax_1383 = ebp_1126->tFFFFFF3C;
											if (esi_1708 == 0x00)
												goto l08079FAB;
											Eq_2 (* esi_1771)[] = ebp_1126->ptrFFFFFF88;
											edi_1640 = __tzcnt(ecx_1681);
											ecx_1641 = Mem1709[esi_1771 + Mem1709[ebp_1126 + -0x00A8:word32]:word32];
											if (ecx_1641 != 0x00)
												goto l0807875D;
											esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
											goto l08079D8C;
										}
										Eq_2 edi_1692 = ebp_1126->ptrFFFFFF88[ebx_1652];
										esi_1674 = (word32) esi_1674 + 4;
									} while (edi_1692 == 0x00);
									int32 esi_1697 = ebp_1126->dwFFFFFF4C;
									ebp_1126->tFFFFFF58.u19 = ebx_1652 * 0x04;
									eax_1383 = ebp_1126->tFFFFFF3C;
									if (esi_1697 != 0x00)
									{
										Eq_2 ecx_1704 = 0x20 - ebp_1126->dwFFFFFF4C;
										edi_1640 = __tzcnt(edi_1692);
										esi_1649 = ecx_1704;
										goto l08079D8C;
									}
l08079FAB:
									Eq_85897 eax_1716 = eax_1383 - ebx_1652;
									if (eax_1716 > 0x00)
									{
										Eq_86255 edi_1721 = ebp_1126->tFFFFFF40;
										Eq_85897 edx_1723 = 0x00;
										word32 esi_1724 = Mem1720[ebp_1126 + -0x00A8:word32] + edi_1721;
										while (true)
										{
											((word32) edi_1721 + edx_1723 * 0x04)->u3 = ecx_1681;
											edx_1723 = (word32) edx_1723.u0 + 1;
											eax_1716 = ebp_1126->dwFFFFFFC0 - ebx_1652;
											if (eax_1716 <= edx_1723)
												break;
											ecx_1681 = *((word32) esi_1724 + edx_1723 * 0x04);
										}
									}
									int32 edx_1741 = ebp_1126->dwFFFFFFB8;
									ebp_1126->dwFFFFFFC0 = (word32) eax_1716;
									int32 edx_1745 = edx_1741 - ebx_1652;
									if (edx_1745 > 0x00)
									{
										Eq_86372 esi_1749 = ebp_1126->ptrFFFFFF88;
										int32 eax_1750 = 0x00;
										word32 ecx_1751 = Mem1743[ebp_1126 + -0x00A8:word32] + esi_1749;
										do
										{
											*((word32) esi_1749 + eax_1750 * 0x04) = *((word32) ecx_1751 + eax_1750 * 0x04);
											++eax_1750;
											edx_1745 = ebp_1126->dwFFFFFFB8 - ebx_1652;
										} while (edx_1745 > eax_1750);
									}
									ebp_1126->dwFFFFFFB8 = edx_1745;
									goto l080787D0;
								}
								if (ebp_1126->dwFFFFFF4C == 0x00)
									goto l080787D0;
								edi_1640 = __tzcnt(edx_1658);
								edx_1648 = ebp_1126->tFFFFFF40;
								esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
							}
							else
							{
								if (ebp_1126->dwFFFFFF4C == 0x00)
									goto l080787D0;
								Eq_2 edx_1638[] = ebp_1126->ptrFFFFFFB4;
								edi_1640 = __tzcnt(ebp_1126->tFFFFFF58);
								ecx_1641 = edx_1638[0];
								if (ecx_1641 != 0x00)
								{
									edx_1648 = ebp_1126->tFFFFFF40;
									ebp_1126->ptrFFFFFF68 = null;
									ebp_1126->tFFFFFF58.u0 = 0x00;
									ebx_1652.u0 = 0x00;
l0807875D:
									Eq_2 ecx_1783 = __tzcnt(ecx_1641);
									if (edi_1640 > ecx_1783)
										edi_1640 = ecx_1783;
									esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
									if (ebx_1652 != 0x00)
									{
l08079D8C:
										if (esi_1649 > edi_1640)
										{
											Eq_2 (* ecx_1807)[] = ebp_1126->ptrFFFFFF68;
											struct Eq_86135 * esp_1817 = esp_536 - 4;
											esp_1817->t0000 = esi_1649;
											Eq_86141 edi_1809 = ebx_1652 - 0x01;
											Eq_2 ecx_1825 = ebp_1126->tFFFFFF40;
											esp_1817->tFFFFFFFC = eax_1383 - edi_1809;
											Eq_86152 edx_1824 = ecx_1807 * 0x04 + ~0x03;
											ebp_1126->ptrFFFFFF88 = (Eq_2 (*)[]) edx_1824;
											Mem1831[esp_1817 + -8:word32] = ecx_1825 + edx_1824;
											esp_1817->tFFFFFFF4 = ecx_1825;
											__mpn_rshift(esp_1817->tFFFFFFF4, esp_1817->tFFFFFFF8, esp_1817->tFFFFFFFC, esp_1817->t0000);
											Eq_2 ecx_1840 = ebp_1126->ptrFFFFFFB4;
											int32 eax_1841 = ebp_1126->dwFFFFFFB8;
											esp_1817->tFFFFFFF0 = esi_1649;
											Eq_2 (* edx_1844)[] = ebp_1126->ptrFFFFFF88;
											ebp_1126->dwFFFFFFC0 -= ebx_1652;
											esp_1817->tFFFFFFEC = eax_1841 - edi_1809;
											Mem1853[esp_1817 + -24:word32] = edx_1844 + ecx_1840;
											esp_1817->tFFFFFFE4 = ecx_1840;
											__mpn_rshift(esp_1817->tFFFFFFE4, esp_1817->tFFFFFFE8, esp_1817->tFFFFFFEC, esp_1817->tFFFFFFF0);
											int32 ecx_1862 = ebp_1126->dwFFFFFFB8;
											eax_1866 = ecx_1862 - edi_1809;
											if ((ebp_1126->ptrFFFFFFB4 - 0x04)[eax_1866] == 0x00)
												eax_1866 = ecx_1862 - ebx_1652;
l080787CD:
											ebp_1126->dwFFFFFFB8 = eax_1866;
											goto l080787D0;
										}
l08078785:
										struct Eq_86015 * esp_1929 = esp_536 - 4;
										esp_1929->t0000 = esi_1649;
										esp_1929->tFFFFFFFC = eax_1383 - ebx_1652;
										esp_1929->tFFFFFFF8 = edx_1648;
										esp_1929->tFFFFFFF4 = ebp_1126->tFFFFFF40;
										__mpn_rshift(esp_1929->tFFFFFFF4, esp_1929->tFFFFFFF8, esp_1929->tFFFFFFFC, esp_1929->t0000);
										int32 eax_1952 = ebp_1126->dwFFFFFFB8;
										Eq_2 edx_1953 = ebp_1126->ptrFFFFFFB4;
										esp_1929->tFFFFFFF0 = esi_1649;
										Eq_86059 edi_1932 = (char *) ebx_1652.u0 + 1;
										ebp_1126->dwFFFFFFC0 -= edi_1932;
										esp_1929->tFFFFFFEC = eax_1952 - ebx_1652;
										Mem1965[esp_1929 + -24:word32] = Mem1960[ebp_1126 + -0x00A8:word32] + edx_1953;
										esp_1929->tFFFFFFE4 = edx_1953;
										__mpn_rshift(esp_1929->tFFFFFFE4, esp_1929->tFFFFFFE8, esp_1929->tFFFFFFEC, esp_1929->tFFFFFFF0);
										int32 edx_1974 = ebp_1126->dwFFFFFFB8;
										eax_1866 = edx_1974 - ebx_1652;
										if ((ebp_1126->ptrFFFFFFB4 - 0x04)[eax_1866] == 0x00)
											eax_1866 = edx_1974 - edi_1932;
										goto l080787CD;
									}
								}
								else
								{
									ebp_1126->tFFFFFF58.u0 = 0x00;
									edx_1648 = ebp_1126->tFFFFFF40;
									esi_1649 = 0x20 - ebp_1126->dwFFFFFF4C;
								}
							}
							ebx_1652.u0 = 0x00;
							if (edi_1640 < esi_1649)
							{
								Eq_2 edi_1881 = ebp_1126->dwFFFFFF4C;
								struct Eq_85947 * esp_1883 = esp_536 - 4;
								esp_1883->t0000 = edi_1881;
								esp_1883->tFFFFFFFC = eax_1383;
								Eq_2 eax_1888 = ebp_1126->tFFFFFF40;
								esp_1883->tFFFFFFF8 = eax_1888;
								esp_1883->tFFFFFFF4 = eax_1888;
								__mpn_lshift(esp_1883->tFFFFFFF4, esp_1883->tFFFFFFF8, esp_1883->tFFFFFFFC, esp_1883->t0000);
								Eq_2 eax_1899 = ebp_1126->ptrFFFFFFB4;
								esp_1883->tFFFFFFF0 = edi_1881;
								esp_1883->tFFFFFFEC = ebp_1126->dwFFFFFFB8;
								esp_1883->tFFFFFFE8 = eax_1899;
								esp_1883->tFFFFFFE4 = eax_1899;
								__mpn_lshift(esp_1883->tFFFFFFE4, esp_1883->tFFFFFFE8, esp_1883->tFFFFFFEC, esp_1883->tFFFFFFF0);
								if (eax_1899 != 0x00)
								{
									int32 edx_1919 = ebp_1126->dwFFFFFFB8;
									ebp_1126->dwFFFFFFB8 = edx_1919 + 0x01;
									ebp_1126->ptrFFFFFFB4[edx_1919] = eax_1899;
								}
								goto l080787D0;
							}
							goto l08078785;
						}
					}
l080785F2:
					ebx_1399 = ebp_1126->dwFFFFFFB0;
					goto l080785F5;
				}
				ebx_2058 = SEQ(SLICE(0x080CE000, word24, 8), __movmskps(xmm2_399)) & 0x08;
l08078A9B:
				if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) == 0x00)
				{
					edi_250 = 134946403;
					goto l08077EF0;
				}
				goto l08078ABB;
			}
l08078030:
			if ((esi_45 & 0x01) == 0x00)
			{
				Eq_82724 xmm0_213 = (uint128) *edx_162;
				if (!PARITY_EVEN((real64) xmm0_213 - (real64) xmm0_213))
				{
					if ((real64) __andpd(xmm0_213, g_t80B1EF0) <= g_t80B1F00)
					{
						real64 rLoc0110_5419 = (real64) xmm0_213;
						Eq_2 eax_284 = __mpn_extract_double(fp - 0x34, fp - 88, fp - 100, (word32) rLoc0110_5419, SLICE(rLoc0110_5419, word32, 32));
						dwLoc80_5426 = eax_284;
						dwLoc50_5427 = eax_284;
						edi_296 = (eax_284 << 0x05) - 0x34;
						goto l080783DA;
					}
					ebx_2058 = SEQ(SLICE(ebx_101, word24, 8), __movmskpd(xmm0_213)) & 0x01;
					if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) != 0x00)
						goto l08077EDB;
					edi_250 = 134946407;
				}
				else
				{
					ebx_2058 = SEQ(SLICE(ebx_101, word24, 8), __movmskpd(xmm0_213)) & 0x01;
					if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) != 0x00)
					{
l08078ABB:
						edi_250 = 0x080B1E5B;
						goto l08077EF0;
					}
					edi_250 = 134946403;
				}
l08077EF0:
				Eq_2 dwLoc80_5617;
				int8 al_3461;
				ptr32 esp_3421;
				Eq_2 esi_3395;
				ptr32 esp_3404;
				struct Eq_80400 * esp_3308 = fp - 0x0100;
				struct Eq_11467 * esi_3248 = esi_45;
				int32 edx_3247 = dwArg0C->dw0004;
				byte al_3282 = (byte) ((SEQ(SLICE(esi_45, word24, 8), (byte) esi_45 >> 0x05) ^ 0x01) & 0x01);
				if (ebx_2058 != 0x00)
				{
					dwLoc80_5617 = edx_3247 - 0x04;
					if (edx_3247 <= 0x04 || al_3282 == 0x00)
					{
						ebx_2058.u0 = 0x00;
						goto l08077F24;
					}
					goto l08078120;
				}
				if ((esi_45 & 0x50) == 0x00)
				{
					dwLoc80_5617 = edx_3247 - 0x03;
					if (edx_3247 <= 0x03)
						goto l080781E5;
				}
				else
				{
					dwLoc80_5617 = edx_3247 - 0x04;
					if (edx_3247 <= 0x04)
						goto l080781E5;
				}
				if (al_3282 != 0x00)
				{
l08078120:
					Eq_2 eax_3330;
					if ((ecx_47 & 0x01) != 0x00)
					{
						Eq_2 esp_3363 = <invalid>;
						word32 ecx_9250;
						word32 esi_9252;
						word32 edx_9251;
						eax_3330 = _IO_wpadn(gs, dwArg04, 0x20, dwLoc80_5617, out ecx_9250, out edx_9251, out ebx_2058, out ebp_1126, out esi_9252, out edi_250);
						esp_3308 = (word32) esp_3363 + 16;
					}
					else
					{
						Eq_2 esp_3337 = <invalid>;
						word32 esi_9249;
						word32 ecx_9247;
						word32 edx_9248;
						eax_3330 = _IO_padn(gs, dwArg04, 0x20, dwLoc80_5617, out ecx_9247, out edx_9248, out ebx_2058, out ebp_1126, out esi_9249, out edi_250);
						esp_3308 = (word32) esp_3337 + 16;
					}
					if (eax_3330 == ebp_1126->ptrFFFFFF88)
					{
						word32 eax_3376 = ebp_1126->dwFFFFFFA4;
						ebx_2058 = ebp_1126->ptrFFFFFF88;
						ebp_1126->tFFFFFF58.u0 = 0x01;
						if (eax_3376 == 0x00)
						{
							esi_3248 = (word32) ebp_1126->ptrFFFFFF84->b000C;
							if ((esi_3248 & 0x40) == 0x00)
								goto l08078174;
							goto l080781ED;
						}
l08077F24:
						if (ebp_1126->dwFFFFFF54 != 0x00)
						{
							Eq_2 eax_3524 = ebp_1126->ptrFFFFFF7C->t0058;
							if (eax_3524 != 0x00)
							{
								struct Eq_80410 * edx_3528 = *((word32) eax_3524 + 16);
								if (edx_3528 < *((word32) eax_3524 + 20))
								{
									*((word32) eax_3524 + 16) = (char *) &edx_3528->t0000 + 4;
									edx_3528->t0000.u0 = 0x2D;
									goto l08078228;
								}
							}
							struct Eq_80399 * esp_3532 = esp_3308 - 0x08;
							esp_3532->dwFFFFFFFC = 0x2D;
							esp_3421 = esp_3532 - 4;
							goto l08079E43;
						}
						esi_3395 = ebp_1126->ptrFFFFFF7C;
						Eq_2 eax_3494 = *((word32) esi_3395 + 20);
						if (eax_3494 < *((word32) esi_3395 + 24))
						{
							ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_3494 + 1;
							*eax_3494 = 0x2D;
							goto l08078228;
						}
						struct Eq_82282 * esp_3499 = esp_3308 - 0x08;
						esp_3499->dwFFFFFFFC = 0x2D;
						esp_3404 = esp_3499 - 4;
						goto l0807A0D4;
					}
l08078BC0:
					goto l080782CA;
				}
l080781E5:
				if ((esi_45 & 0x40) == 0x00)
				{
l08078174:
					if ((esi_3248 & 0x10) == 0x00)
					{
l0807822B:
						Eq_2 eax_3683;
						Eq_2 esi_3587 = (word32) ebx_2058 + 3;
						if (ebp_1126->dwFFFFFF54 != 0x00)
						{
							ebp_1126->ptrFFFFFF68 -= ebx_2058 * 0x04;
							do
							{
								int8 al_3738;
								Eq_2 ecx_3707 = ebp_1126->ptrFFFFFF68[ebx_2058];
								Eq_2 eax_3709 = ebp_1126->ptrFFFFFF7C->t0058;
								if (eax_3709 != 0x00)
								{
									struct Eq_80482 * edx_3713 = *((word32) eax_3709 + 16);
									if (edx_3713 >= *((word32) eax_3709 + 20))
										goto l08078C40;
									*((word32) eax_3709 + 16) = (char *) &edx_3713->t0000 + 4;
									edx_3713->t0000 = ecx_3707;
									al_3738 = (int8) (ecx_3707 == ~0x00);
								}
								else
								{
l08078C40:
									struct Eq_80451 * esp_3718 = esp_3308 - 0x08;
									esp_3718->tFFFFFFFC = ecx_3707;
									esp_3718->tFFFFFFF8 = ebp_1126->ptrFFFFFF7C;
									word32 ecx_9184;
									al_3738 = (int8) (__woverflow(esp_3718->tFFFFFFF8, esp_3718->tFFFFFFFC, out ecx_9184) == ~0x00);
								}
								if (al_3738 != 0x00)
									goto l08078BC0;
								ebx_2058 = (word32) ebx_2058 + 1;
							} while (ebx_2058 != esi_3587);
							if ((ebp_1126->ptrFFFFFF84->b000C & 0x20) != 0x00 && ebp_1126->tFFFFFF58 != 0x00)
							{
								esp_3308->tFFFFFFF8 = ebp_1126->ptrFFFFFF88;
								esp_3308->tFFFFFFF4.u0 = 0x20;
								esp_3308->tFFFFFFF0 = ebp_1126->ptrFFFFFF7C;
								word32 esi_9187;
								word32 edi_9188;
								word32 edx_9186;
								word32 ecx_9185;
								eax_3683 = _IO_wpadn(gs, esp_3308->tFFFFFFF0, esp_3308->tFFFFFFF4, esp_3308->tFFFFFFF8, out ecx_9185, out edx_9186, out ebx_2058, out ebp_1126, out esi_9187, out edi_9188);
								goto l080782BF;
							}
						}
						else
						{
							ebp_1126->ptrFFFFFF68 = edi_250 - ebx_2058;
							Eq_2 edi_3610 = ebp_1126->ptrFFFFFF7C;
							do
							{
								word32 edx_3615 = CONVERT(Mem3612[Mem3612[ebp_1126 + -0x0098:word32] + ebx_2058:byte], byte, word32);
								byte dl_3640 = (byte) edx_3615;
								Eq_2 eax_3617 = *((word32) edi_3610 + 20);
								if (eax_3617 < *((word32) edi_3610 + 24))
								{
									*((word32) edi_3610 + 20) = (word32) eax_3617 + 1;
									*eax_3617 = dl_3640;
								}
								else
								{
									struct Eq_82178 * esp_3621 = esp_3308 - 0x08;
									esp_3621->tFFFFFFFC = edx_3615;
									esp_3621->tFFFFFFF8 = edi_3610;
									word32 edx_9242;
									word32 ecx_9241;
									if (__overflow(esp_3621->tFFFFFFF8, esp_3621->tFFFFFFFC, out ecx_9241, out edx_9242) == ~0x00)
										goto l08078BC0;
								}
								ebx_2058 = (word32) ebx_2058 + 1;
							} while (ebx_2058 != esi_3587);
							if ((ebp_1126->ptrFFFFFF84->b000C & 0x20) != 0x00 && ebp_1126->tFFFFFF58 != 0x00)
							{
								esp_3308->tFFFFFFF8 = ebp_1126->ptrFFFFFF88;
								esp_3308->tFFFFFFF4.u0 = 0x20;
								esp_3308->tFFFFFFF0 = ebp_1126->ptrFFFFFF7C;
								word32 ecx_9243;
								word32 esi_9245;
								word32 edi_9246;
								word32 edx_9244;
								eax_3683 = _IO_padn(gs, esp_3308->tFFFFFFF0, esp_3308->tFFFFFFF4, esp_3308->tFFFFFFF8, out ecx_9243, out edx_9244, out ebx_2058, out ebp_1126, out esi_9245, out edi_9246);
l080782BF:
								if (eax_3683 == ebp_1126->ptrFFFFFF88)
								{
l080782C8:
									goto l080782CA;
								}
								goto l08078BC0;
							}
						}
l080782CA:
						edi_2346 = ebp_1126->dwFFFFFFE4 ^ gs->dw0014;
						if (edi_2346 == 0x00)
							return;
						word32 edx_9190;
						word32 ecx_9189;
						__stack_chk_fail(out ecx_9189, out edx_9190);
						esp_2959.u0 = <invalid>;
l0807A5B4:
						word32 eax_3822 = ebp_1126->dwFFFFFF80;
						Eq_80635 esp_3830 = esp_2959 - 4;
						*esp_3830 = ebx_2058;
						Eq_80639 ebx_3834 = ebp_1126->tFFFFFF40;
						*((word32) esp_3830 - 4) = 0x06;
						*((word32) esp_3830 - 8) = eax_3822 + ~0x0001C153;
						*((word32) esp_3830 - 0x0C) = ebx_3834;
						word32 edx_9268;
						Eq_2 ecx_3843 = __wmemcpy(*((word32) esp_3830 - 0x0C), *((word32) esp_3830 - 8), *((word32) esp_3830 - 4), out edx_9268);
						*((word32) ebx_3834 + 4) = ebp_1126->dwFFFFFF50;
						esp_2959 = esp_3830 + 0x04;
						if (ebx_3834 + 0x08 >u edi_2346)
							edi_2346 = (word32) edi_2346 + 20;
						else
						{
							*esp_3830 = ecx_3843;
							Mem3866[esp_3830 + -4:word32] = edi_2346 - (ebx_3834 + 0x08) >> 0x02;
							word32 eax_3867 = ebp_1126->tFFFFFF40;
							*((word32) esp_3830 - 8) = 0x30;
							*((word32) esp_3830 - 0x0C) = eax_3867 + 0x18;
							__wmemset(*((word32) esp_3830 - 0x0C), *((word32) esp_3830 - 8), *((word32) esp_3830 - 4));
							edi_2346 = (word32) edi_2346 + 16;
							esp_2959 = (word32) esp_3830 + 4;
						}
						goto l08079098;
					}
					if (ebp_1126->dwFFFFFF54 != 0x00)
					{
						Eq_2 eax_3467 = ebp_1126->ptrFFFFFF7C->t0058;
						if (eax_3467 != 0x00)
						{
							struct Eq_80410 * edx_3471 = *((word32) eax_3467 + 16);
							if (edx_3471 < *((word32) eax_3467 + 20))
							{
								*((word32) eax_3467 + 16) = (char *) &edx_3471->t0000 + 4;
								edx_3471->t0000.u0 = 0x20;
								goto l08078228;
							}
						}
						struct Eq_82406 * esp_3475 = esp_3308 - 0x08;
						esp_3475->dwFFFFFFFC = 0x20;
						esp_3421 = esp_3475 - 4;
l08079E43:
						struct Eq_82472 * esp_3543 = esp_3421 - 4;
						esp_3543->t0000 = ebp_1126->ptrFFFFFF7C;
						esp_3308 = (struct Eq_80400 *) ((char *) &esp_3543->t0004 + 0x0C);
						word32 ecx_9255;
						al_3461 = (int8) (__woverflow(esp_3543->t0000, esp_3543->t0004, out ecx_9255) == ~0x00);
						goto l08079E57;
					}
					Eq_2 ecx_3439 = ebp_1126->ptrFFFFFF7C;
					Eq_2 eax_3440 = *((word32) ecx_3439 + 20);
					if (eax_3440 < *((word32) ecx_3439 + 24))
					{
						ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_3440 + 1;
						*eax_3440 = 0x20;
						goto l08078228;
					}
					struct Eq_82432 * esp_3444 = esp_3308 - 0x08;
					esp_3444->tFFFFFFFC.u0 = 0x20;
					esp_3444->tFFFFFFF8 = ecx_3439;
					esp_3308 = (struct Eq_80400 *) ((char *) &esp_3444->tFFFFFFFC + 0x0C);
					word32 ecx_9253;
					word32 edx_9254;
					al_3461 = (int8) (__overflow(esp_3444->tFFFFFFF8, esp_3444->tFFFFFFFC, out ecx_9253, out edx_9254) == ~0x00);
l08079E57:
					if (al_3461 != 0x00)
						goto l08078BC0;
					goto l08078228;
				}
l080781ED:
				if (ebp_1126->dwFFFFFF54 != 0x00)
				{
					Eq_2 eax_3411 = ebp_1126->ptrFFFFFF7C->t0058;
					if (eax_3411 != 0x00)
					{
						struct Eq_80410 * edx_3415 = *((word32) eax_3411 + 16);
						if (edx_3415 < *((word32) eax_3411 + 20))
						{
							*((word32) eax_3411 + 16) = (char *) &edx_3415->t0000 + 4;
							edx_3415->t0000.u0 = 0x2B;
							goto l08078228;
						}
					}
					struct Eq_82518 * esp_3419 = esp_3308 - 0x08;
					esp_3419->dwFFFFFFFC = 0x2B;
					esp_3421 = esp_3419 - 4;
					goto l08079E43;
				}
				esi_3395 = ebp_1126->ptrFFFFFF7C;
				Eq_2 eax_3396 = *((word32) esi_3395 + 20);
				if (eax_3396 < *((word32) esi_3395 + 24))
				{
					ebp_1126->ptrFFFFFF7C->t0014 = (word32) eax_3396 + 1;
					*eax_3396 = 0x2B;
l08078228:
					ebx_2058 = (word64) ebx_2058.u0 + 1;
					goto l0807822B;
				}
				struct Eq_82544 * esp_3402 = esp_3308 - 0x08;
				esp_3402->dwFFFFFFFC = 0x2B;
				esp_3404 = esp_3402 - 4;
l0807A0D4:
				struct Eq_82569 * esp_3504 = esp_3404 - 4;
				esp_3504->t0000 = esi_3395;
				esp_3308 = (struct Eq_80400 *) ((char *) &esp_3504->t0004 + 0x0C);
				word32 ecx_9256;
				word32 edx_9257;
				al_3461 = (int8) (__overflow(esp_3504->t0000, esp_3504->t0004, out ecx_9256, out edx_9257) == ~0x00);
				goto l08079E57;
			}
			else
			{
				real64 rLoc1_5430 = (real64) *edx_162;
				Eq_82741 FPUF_329 = cond(rLoc1_5430);
				ui32 eax_345 = SEQ(eax_16_16_340, FPUF_329 << 8);
				if (PARITY_EVEN(rLoc1_5430 - rLoc1_5430))
				{
					ebx_2058 = eax_345 & 0x0200;
					goto l08078A9B;
				}
				if ((FPUF_329 & 0x45) != 0x05)
				{
					Eq_2 eax_370 = __mpn_extract_long_double(fp - 0x34, fp - 88, fp - 100, (real80) rLoc1_5430);
					dwLoc80_5426 = eax_370;
					dwLoc50_5427 = eax_370;
					edi_296 = (eax_370 << 0x05) - 0x3F;
					goto l080783DA;
				}
				ebx_2058 = eax_345 & 0x0200;
				if ((gs->ptrFFFFFFF8[dwArg0C->dw0008].b0001 & 0x01) == 0x00)
				{
l0807807E:
					edi_250 = 134946407;
					goto l08077EF0;
				}
l08077EDB:
				edi_250 = 134946399;
				goto l08077EF0;
			}
		}
		cu8 * dwLocDC_5382;
		if (bl_54 == 0x00)
			dwLocDC_5382 = (cu8 *) *((word32) dwArg08->t0004 + 40);
		else
			dwLocDC_5382 = dwArg08->ptr0010->ptr0030;
		ebx_101 = ~(0x00 - (*dwLocDC_5382 < 0x01)) & ~0x01;
		*dwLocDC_5382 == 0x00;
l08077E13:
		edx_162 = (union Eq_2 *) *dwArg10;
		if ((al_177 & 0x10) != 0x00)
			goto l08077E1D;
		goto l08078030;
	}
l08077DF5:
	goto l08077E13;
}

// subject_text_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0807A640: void __printf_fp(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_80169) dwArg08, Stack (ptr32 (ptr32 Eq_2)) dwArg0C)
void __printf_fp(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_80169 * dwArg08, union Eq_2 ** dwArg0C)
{
	__printf_fp_l(gs, dwLoc20, dwArg04, gs->ptrFFFFFFD4, dwArg08, dwArg0C);
}

// 0807A670: void __guess_grouping(Stack Eq_2 dwArg04, Stack (ptr32 byte) dwArg08)
void __guess_grouping(Eq_2 dwArg04, byte * dwArg08)
{
	if ((byte) ((word32) *dwArg08 - 0x01) > 0x7D)
		return;
	__guess_grouping.part.0(dwArg04, dwArg08);
}

// 0807A6A0: void register_printf_specifier(Register (ptr32 Eq_9) gs, Stack uint32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
// Called from:
//      register_printf_function
void register_printf_specifier(struct Eq_9 * gs, uint32 dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	struct Eq_86603 * ebx_102 = &g_t80CE000;
	uint32 esi_21 = dwArg04;
	if (dwArg04 > 0xFF)
	{
		gs->tFFFFFFE0.u0 = 22;
		return;
	}
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_36;
	if (!__cmpxchg(lock, 0x01, 0x00, out eax_36))
		__lll_lock_wait_private(eax_36, 0x080CFA20, gs);
	Eq_2 edx_113;
	Eq_2 ecx_111;
	Eq_2 eax_61;
	Eq_2 edx_48[] = __printf_function_table;
	if (edx_48 != null)
		eax_61 = __printf_arginfo_table;
	else
	{
		word32 edx_187;
		word32 ebp_188;
		word32 edi_189;
		eax_61 = __libc_calloc(gs, 0x0100, 0x08, out ecx_111, out edx_187, out ebx_102, out ebp_188, out esi_21, out edi_189);
		ebx_102->t1FE8 = eax_61;
		if (eax_61 == 0x00)
		{
			edx_113.u0 = ~0x00;
			goto l0807A70A;
		}
		ebx_102->dw1FD4 = (word32) eax_61 + 0x0400;
		edx_48 = (word32) eax_61 + 0x0400;
	}
	edx_48[esi_21] = dwArg08;
	*((word32) eax_61 + esi_21 * 0x04) = dwArg0C;
	ecx_111 = dwArg08;
	edx_113.u0 = 0x00;
l0807A70A:
	if (gs->t000C != 0x00)
		__lock();
	word32 v14_105 = ebx_102->dw1A20 - 0x01;
	ebx_102->dw1A20 = v14_105;
	if (v14_105 != 0x00)
		__lll_unlock_wake_private(&ebx_102->dw1A20, ecx_111, edx_113, gs);
}

// 0807A790: void register_printf_function(Register (ptr32 Eq_9) gs, Stack uint32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C)
void register_printf_function(struct Eq_9 * gs, uint32 dwArg04, Eq_2 dwArg08, word32 dwArg0C)
{
	register_printf_specifier(gs, dwArg04, dwArg08, dwArg0C);
}

// 0807A7A0: void __printf_fphex(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_86700) dwArg08, Stack (ptr32 (ptr32 Eq_2)) dwArg0C)
void __printf_fphex(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_86700 * dwArg08, union Eq_2 ** dwArg0C)
{
	word32 dwLoc0148_3453;
	byte * dwLoc014C_3452;
	__align(fp);
	ui32 edx_32 = (word32) dwArg08->b000D;
	struct Eq_86712 * ebp_1005 = fp - 8;
	Eq_2 edi_1298 = dwArg04;
	int32 esi_42 = dwArg08->dw0004;
	ui32 ecx_45 = SEQ(SLICE(edx_32, word24, 8), (byte) edx_32 >> 0x02);
	if (((byte) edx_32 & 0x01) == 0x00)
	{
		struct Eq_75143 * ecx_63 = *gs->ptrFFFFFFDC;
		dwLoc014C_3452 = ecx_63->ptr0024;
		dwLoc0148_3453 = ecx_63->dw0030;
	}
	else
	{
		struct Eq_86731 * ecx_56 = *gs->ptrFFFFFFD8;
		dwLoc014C_3452 = ecx_56->ptr002C;
		dwLoc0148_3453 = ecx_56->dw00D0;
	}
	if (*dwLoc014C_3452 == 0x00 || dwLoc0148_3453 == 0x00)
	{
		word32 ecx_5053;
		word32 edx_5054;
		__assert_fail(out ecx_5053, out edx_5054);
		goto l0807C4D2;
	}
	ui32 edx_111;
	ui32 dwLoc0128_3466;
	Eq_2 ebx_1078;
	Eq_2 edi_1008;
	struct Eq_86767 * esp_1017;
	union Eq_2 * eax_107 = *dwArg0C;
	ui16 eax_16_16_326 = SLICE(eax_107, word16, 16);
	ui32 esi_108 = dwArg08->dw0008;
	if ((edx_32 & 0x10) != 0x00)
	{
		Eq_2 xmm1_535 = *eax_107;
		dwLoc0128_3466 = SEQ(SLICE(eax_107, word24, 8), __movmskps(xmm1_535)) & 0x08;
		word32 dwLoc0140_3584 = (word32) xmm1_535;
		word32 dwLoc013C_3589 = (word32) SLICE(xmm1_535, word96, 32);
		if (__unordtf2((word32) xmm1_535, SLICE(xmm1_535, word32, 32), SLICE(xmm1_535, word32, 64), SLICE(xmm1_535, word32, 96), (word32) xmm1_535, SLICE(xmm1_535, word32, 32), SLICE(xmm1_535, word32, 64), SLICE(xmm1_535, word32, 96)) != 0x00)
		{
			(gs->ptrFFFFFFF8[esi_108].b0001 & 0x01) != 0x00;
			goto l0807AF02;
		}
		word128 xmm0_577 = __pand(xmm1_535, g_ow80B1ED0);
		word128 xmm5_578 = g_ow80B1EE0;
		if (__unordtf2((word32) xmm0_577, SLICE(xmm0_577, word32, 32), SLICE(xmm0_577, word32, 64), SLICE(xmm0_577, word32, 96), (word32) xmm5_578, SLICE(xmm5_578, word32, 32), SLICE(xmm5_578, word32, 64), SLICE(xmm5_578, word32, 96)) == 0x00 && __lttf2((word32) xmm0_577, SLICE(xmm0_577, word32, 32), SLICE(xmm0_577, word32, 64), SLICE(xmm0_577, word32, 96), (word32) xmm5_578, SLICE(xmm5_578, word32, 32), SLICE(xmm5_578, word32, 64), SLICE(xmm5_578, word32, 96)) > 0x00)
		{
			(gs->ptrFFFFFFF8[esi_108].b0001 & 0x01) != 0x00;
l0807AF02:
			edx_111 = (word32) dwArg08->b000C;
			goto l0807AF0C;
		}
		struct Eq_86849 * ebp_871;
		word32 edi_5056;
		word32 ebx_5055;
		_itoa(gs, SEQ(dwLoc013C_3589, dwLoc0140_3584), fp - 0x24, 0x10, (uint32) (int8) (esi_108 == 0x41), out ebx_5055, out ebp_871, out edi_5056);
		Eq_2 esp_877 = <invalid>;
		*((word32) esp_877 + 16) = (word32) (int8) (ebp_871->ptrFFFFFEDC->dw0008 == 0x41);
		((word32) esp_877 + 0x0C)->u0 = 0x10;
		*((word32) esp_877 + 8) = ebp_871 - 0x44;
		*((word32) esp_877 + 4) = ebp_871->dwFFFFFE9C;
		*esp_877 = ebp_871->tFFFFFE98;
		ebp_871->ptrFFFFFE80 = ebp_871 - 0x44;
		Eq_2 esp_911 = <invalid>;
		struct Eq_86914 * ebp_905;
		word32 edi_5057;
		Eq_2 esi_910;
		Eq_2 edx_919 = _itowa(gs, *esp_877, *((word32) esp_877 + 8), *((word32) esp_877 + 0x0C), *((word32) esp_877 + 16), out ebp_905, out esi_910, out edi_5057);
		Eq_2 eax_920 = esi_910;
		if (esi_910 > ebp_905 - 44)
		{
			do
			{
				--eax_920;
				*eax_920 = 0x30;
				edx_919 -= 0x04;
				*edx_919 = 0x30;
			} while (eax_920 != ebp_905 - 44);
			esi_910 = eax_920;
		}
		ebp_905->tFFFFFE88 = ebp_905->tFFFFFED0;
		ebp_905->dwFFFFFE8C = (word32) ebp_905->w012C;
		*((word32) esp_911 + 16) = (word32) (int8) (ebp_905->ptrFFFFFEDC->dw0008 == 0x41);
		((word32) esp_911 + 0x0C)->u0 = 0x10;
		*((word32) esp_911 + 8) = esi_910;
		*((word32) esp_911 + 4) = ebp_905->dwFFFFFE8C;
		*esp_911 = ebp_905->tFFFFFE88;
		struct Eq_87016 * ebp_972;
		Eq_2 ebx_973;
		word32 edi_5058;
		ebp_972->tFFFFFE94 = _itoa(gs, *esp_911, *((word32) esp_911 + 8), *((word32) esp_911 + 0x0C), *((word32) esp_911 + 16), out ebx_973, out ebp_972, out edi_5058);
		Eq_2 esp_978 = <invalid>;
		*((word32) esp_978 + 16) = (word32) (int8) (ebp_972->ptrFFFFFEDC->dw0008 == 0x41);
		((word32) esp_978 + 0x0C)->u0 = 0x10;
		*((word32) esp_978 + 8) = ebx_973;
		*((word32) esp_978 + 4) = ebp_972->dwFFFFFE8C;
		*esp_978 = ebp_972->tFFFFFE88;
		Eq_2 esi_1010;
		Eq_2 eax_1004 = _itowa(gs, *esp_978, *((word32) esp_978 + 8), *((word32) esp_978 + 0x0C), *((word32) esp_978 + 16), out ebp_1005, out esi_1010, out edi_1008);
		ebp_1005->tFFFFFEA8 = eax_1004;
		Eq_2 esp_1011 = <invalid>;
		word24 ecx_24_8_1053 = SLICE(ebp_1005 - 0x38, word24, 8);
		esp_1017 = (word32) esp_1011 + 32;
		if (esi_1010 > ebp_1005 - 0x38)
		{
			Eq_2 edx_1021 = eax_1004;
			eax_1004 = esi_1010;
			do
			{
				--eax_1004;
				*eax_1004 = 0x30;
				edx_1021 -= 0x04;
				*edx_1021 = 0x30;
				ecx_24_8_1053 = SLICE(ebp_1005 - 0x38, word24, 8);
			} while (eax_1004 != ebp_1005 - 0x38);
			Eq_2 esi_1034 = ebp_1005->tFFFFFEA8;
			Eq_87202 edx_1036 = eax_1004 - ebp_1005->tFFFFFE94;
			ebp_1005->tFFFFFE94 = eax_1004;
			ebp_1005->tFFFFFEA8 = (word32) esi_1034 + edx_1036 * 0x04;
		}
		Eq_2 ebx_1044 = ebp_1005->tFFFFFE88;
		ui32 esi_1045 = ebp_1005->dwFFFFFE8C;
		ui32 edx_1046 = ebp_1005->dwFFFFFE9C;
		ebp_1005->tFFFFFE93 = (byte) (SEQ(ecx_24_8_1053, (int8) (((word16) __pextrw(eax_1004, ebp_1005->tFFFFFEC8, 0x07) & 0x7FFF) != 0x00)) + 0x30);
		ui32 ecx_1065 = ebx_1044 | ebp_1005->tFFFFFE98;
		ui32 eax_1066 = (word32) ebp_1005->wFFFFFF26;
		ebp_1005->tFFFFFE98 = eax_1066 & 0x7FFF;
		ui32 ebx_1063 = esi_1045 | edx_1046;
		if ((eax_1066 & 0x7FFF) != 0x00)
		{
			Eq_87164 eax_1085 = ebp_1005->tFFFFFE98;
			if (eax_1085 > 0x3FFE)
			{
				ebp_1005->tFFFFFE98.u0 = 0x00;
				ebx_1078 = eax_1085 - 0x3FFF;
			}
			else
			{
				ebx_1078 = 0x3FFF - ebp_1005->tFFFFFE98;
				ebp_1005->tFFFFFE98.u0 = 0x01;
			}
		}
		else
		{
			uint32 eax_1073 = ebx_1063 | ecx_1065;
			ebp_1005->tFFFFFE98 = (word32) (int8) (eax_1073 != 0x00);
			ebx_1078 = ~(0x00 - (eax_1073 < 0x01)) & 0x3FFE;
		}
		ebp_1005->tFFFFFE88 = (uint32) (int8) ((ecx_1065 | ebx_1063) == 0x00);
		goto l0807B220;
	}
	edx_111 = (word32) dwArg08->b000C;
	if (((byte) edx_111 & 0x01) != 0x00)
	{
		real64 rLoc1_3485 = (real64) *eax_107;
		Eq_90416 FPUF_324 = cond(rLoc1_3485);
		dwLoc0128_3466 = SEQ(eax_16_16_326, FPUF_324 << 8) & 0x0200;
		if (!PARITY_EVEN(rLoc1_3485 - rLoc1_3485))
		{
			if ((FPUF_324 & 0x45) != 0x05)
			{
				struct Eq_90443 * ebp_406;
				word32 ebx_5151;
				word32 edi_5152;
				_itoa(gs, (word64) (real80) rLoc1_3485, fp - 0x24, 0x10, (uint32) (int8) (esi_108 == 0x41), out ebx_5151, out ebp_406, out edi_5152);
				Eq_2 esp_412 = <invalid>;
				*((word32) esp_412 + 16) = (word32) (int8) (ebp_406->ptrFFFFFEDC->dw0008 == 0x41);
				((word32) esp_412 + 0x0C)->u0 = 0x10;
				*((word32) esp_412 + 8) = ebp_406 - 0x44;
				*((word32) esp_412 + 4) = ebp_406->dwFFFFFECC;
				*esp_412 = ebp_406->tFFFFFEC8;
				ebp_406->ptrFFFFFE80 = ebp_406 - 0x44;
				Eq_2 esp_446 = <invalid>;
				byte * esi_445;
				Eq_2 eax_439 = _itowa(gs, *esp_412, *((word32) esp_412 + 8), *((word32) esp_412 + 0x0C), *((word32) esp_412 + 16), out ebp_1005, out esi_445, out edi_1008);
				esp_1017 = (word32) esp_446 + 32;
				Eq_2 edx_454 = eax_439;
				byte * eax_455 = esi_445;
				if (esi_445 > ebp_1005 - 44)
				{
					do
					{
						--eax_455;
						*eax_455 = 0x30;
						edx_454 -= 0x04;
						*edx_454 = 0x30;
					} while (eax_455 != ebp_1005 - 44);
					ebp_1005->tFFFFFE94 = ebp_1005 - 0x2B;
					ebp_1005->tFFFFFEA8 = (word32) eax_439 + 4 + (eax_455 - esi_445) * 0x04;
					esi_445 = eax_455;
				}
				else
				{
					ebp_1005->tFFFFFE94 = esi_445 + 1;
					ebp_1005->tFFFFFEA8 = (word32) eax_439 + 4;
				}
				ui32 ebx_488 = (word32) ebp_1005->wFFFFFF10;
				ebp_1005->tFFFFFE93 = *esi_445;
				ebx_1078 = ebx_488 & 0x7FFF;
				if ((ebx_488 & 0x7FFF) == 0x00)
				{
					uint32 eax_507 = ebp_1005->dwFFFFFECC | ebp_1005->tFFFFFEC8;
					ebp_1005->tFFFFFE98 = 0x00 - (eax_507 < 0x01) + 0x01;
					if (eax_507 != 0x00)
						ebx_1078.u0 = 0x4001;
				}
				else if ((ebx_488 & 0x7FFF) > 0x4001)
					ebx_1078 = (ebx_488 & 0x7FFF) - 0x4002;
				else
				{
					ebp_1005->tFFFFFE98.u0 = 0x01;
					ebx_1078 = 0x4002 - (ebx_488 & 0x7FFF);
				}
				goto l0807B220;
			}
			(gs->ptrFFFFFFF8[esi_108].b0001 & 0x01) != 0x00;
			goto l0807AF0C;
		}
		if ((gs->ptrFFFFFFF8[esi_108].b0001 & 0x01) == 0x00)
			goto l0807AF0C;
	}
	else
	{
		Eq_82724 xmm0_116 = (uint128) *eax_107;
		real64 rLocF0_3465 = (real64) xmm0_116;
		uint32 dwLocF0_3473 = (word32) rLocF0_3465;
		ui32 dwLocEC_3475 = SLICE(rLocF0_3465, word32, 32);
		dwLoc0128_3466 = SEQ(SLICE(eax_107, word24, 8), __movmskpd(xmm0_116)) & 0x01;
		if (!PARITY_EVEN((real64) xmm0_116 - (real64) xmm0_116))
		{
			if ((real64) __andpd(xmm0_116, g_t80B1EF0) <= g_t80B1F00)
			{
				struct Eq_90638 * ebp_196;
				Eq_2 esi_201;
				word32 edi_5153;
				Eq_2 eax_195 = _itowa(gs, SEQ(dwLocEC_3475 & 0x000FFFFF, dwLocF0_3473), fp - 0x4C, 0x10, (uint32) (int8) (esi_108 == 0x41), out ebp_196, out esi_201, out edi_5153);
				ebp_196->tFFFFFE84 = esi_201;
				ebp_196->tFFFFFEA8 = eax_195;
				Eq_2 esp_202 = <invalid>;
				*((word32) esp_202 + 16) = (word32) (int8) (ebp_196->ptrFFFFFEDC->dw0008 == 0x41);
				((word32) esp_202 + 0x0C)->u0 = 0x10;
				*((word32) esp_202 + 8) = esi_201;
				*((word32) esp_202 + 4) = ebp_196->dwFFFFFECC;
				*esp_202 = ebp_196->tFFFFFEC8;
				ptr32 ebx_230;
				ebp_1005->tFFFFFE94 = _itoa(gs, *esp_202, *((word32) esp_202 + 8), *((word32) esp_202 + 0x0C), *((word32) esp_202 + 16), out ebx_230, out ebp_1005, out edi_1008);
				Eq_2 esp_235 = <invalid>;
				word24 ecx_24_8_283 = SLICE(ebp_1005 - 0x78, word24, 8);
				esp_1017 = (word32) esp_235 + 32;
				if (ebx_230 > ebp_1005 - 0x78)
				{
					Eq_2 esi_245 = ebp_1005->tFFFFFEA8;
					ptr32 ecx_246 = ~(ebp_1005 - 0x78);
					Eq_2 ebx_247 = ebp_1005->tFFFFFE94;
					Eq_90766 eax_248 = 0x00;
					Eq_90766 edx_252 = ~((word32) esi_245 + ecx_246 >> 0x02);
					do
					{
						(esi_245 - 0x04)[eax_248] = 0x30;
						Mem257[ebx_247 - 0x01 + eax_248:byte] = 0x30;
						--eax_248;
					} while (eax_248 != edx_252);
					Eq_2 edx_263 = ebp_1005->tFFFFFEA8;
					Eq_90791 ecx_265 = (word32) edx_263 + ecx_246;
					ebp_1005->tFFFFFE94 = (word32) ebp_1005->tFFFFFE94 + ~(ecx_265 >> 0x02);
					ebp_1005->tFFFFFEA8 = edx_263 - ((word32) ((ecx_265 >> 0x02) * 0x04) + 4);
					ecx_24_8_283 = SLICE(ecx_265 >> 0x02, word24, 8);
				}
				word32 ebx_277 = (word32) ebp_1005->wFFFFFF1E;
				cu16 bx_278 = (word16) ebx_277;
				ebp_1005->tFFFFFE93 = (byte) (SEQ(ecx_24_8_283, (int8) ((bx_278 & 0x7FF0) != 0x00)) + 0x30);
				ui32 ebx_291 = SEQ(SLICE(ebx_277, word16, 16), bx_278 >> 0x04);
				ebx_1078 = ebx_291 & 0x07FF;
				if ((ebx_291 & 0x07FF) == 0x00)
				{
					if ((ebp_1005->dwFFFFFECC | ebp_1005->tFFFFFEC8) != 0x00)
					{
						ebp_1005->tFFFFFE98.u0 = 0x01;
						ebx_1078.u0 = 1022;
l0807B22E:
						if (ebp_1005->dwFFFFFFB8 == 0x30)
						{
							Eq_2 eax_1125 = ebp_1005->tFFFFFE80;
							Eq_2 edx_1126 = ebp_1005->tFFFFFE84;
							do
							{
								eax_1125 -= 0x04;
								--edx_1126;
							} while (*((word32) eax_1125 - 4) == 0x30);
							ebp_1005->tFFFFFE84 = edx_1126;
						}
						Eq_2 edx_1139 = ebp_1005->tFFFFFE94;
						Eq_2 ecx_1140 = ebp_1005->tFFFFFEC4;
						Eq_2 esi_1141 = ebp_1005->tFFFFFE84 - edx_1139;
						if (ecx_1140 == ~0x00)
						{
							ebp_1005->tFFFFFEC4 = esi_1141;
							goto l0807AD70;
						}
						if (ecx_1140 >= esi_1141)
						{
l0807AD70:
							struct Eq_87975 * esp_1822 = esp_1017 - 4;
							esp_1822->t0000.u0 = 0x00;
							esp_1822->tFFFFFFFC.u0 = 0x0A;
							Eq_2 esi_1797 = ebp_1005 - 0x3C;
							esp_1822->tFFFFFFF8 = esi_1797;
							esp_1822->tFFFFFFF4 = ebx_1078;
							word32 ecx_5084;
							word32 edx_5085;
							Eq_2 eax_1834 = _itoa_word(esp_1822->tFFFFFFF4, esp_1822->tFFFFFFF8, esp_1822->tFFFFFFFC, esp_1822->t0000, out ecx_5084, out edx_5085);
							ebp_1005->tFFFFFEC8 = edi_1008;
							ebp_1005->tFFFFFE88 = eax_1834;
							ebp_1005->tFFFFFE80 = esi_1797;
							Eq_2 edi_1852 = ebp_1005 - 0xC4;
							while (true)
							{
								uint32 edx_1861 = SLICE(ebx_1078 *64 ~0x33333332, word32, 32);
								edi_1852 -= 0x04;
								*edi_1852 = *((word32) ebp_1005->tFFFFFEE4 + ((ebx_1078 - ((edx_1861 >> 0x03) + (edx_1861 >> 0x03) * 0x04) * 0x02) * 0x04 - 88256));
								if (ebx_1078 <= 0x09)
									break;
								ebx_1078 = edx_1861 >> 0x03;
							}
							struct Eq_87292 * eax_1875 = ebp_1005->ptrFFFFFEDC;
							Eq_2 edx_1876 = ebp_1005->tFFFFFEE0;
							ebp_1005->tFFFFFE7C = edi_1852;
							ui32 ebx_1880 = (word32) eax_1875->b000C;
							Eq_2 esi_1878 = ebp_1005->tFFFFFE80;
							Eq_2 edi_1879 = ebp_1005->tFFFFFEC8;
							byte bl_1886 = (byte) ebx_1880;
							uint32 eax_1881 = 0x04;
							if (edx_1876 == 0x00)
								eax_1881 = (uint32) (int8) ((bl_1886 & 0x50) != 0x00) + 0x03;
							Eq_2 ecx_1896 = ebp_1005->tFFFFFEC4;
							Eq_2 esi_1898 = esi_1878 - ebp_1005->tFFFFFE88;
							ebp_1005->tFFFFFE80 = esi_1898;
							ebp_1005->tFFFFFEB8 -= (word32) esi_1898 + (((word32) ecx_1896 + 2) + eax_1881);
							if (ecx_1896 > 0x00 || (bl_1886 & 0x08) != 0x00)
							{
								Eq_2 eax_1915 = 0x01;
								if (ebp_1005->tFFFFFED8 == 0x00)
								{
									esp_1822->tFFFFFFF4 = ebp_1005->tFFFFFEBC;
									word32 ecx_5088;
									word32 edx_5089;
									eax_1915 = strlen(esp_1822->tFFFFFFF4, out ecx_5088, out edx_5089);
								}
								ebp_1005->tFFFFFEB8 -= eax_1915;
							}
							Eq_2 esi_1960;
							struct Eq_86767 * esp_1967 = esp_1017;
							if ((ebx_1880 & 0x20) == 0x00 && (ebp_1005->ptrFFFFFEDC)->t0010 != 0x30)
							{
								Eq_2 eax_1957 = ebp_1005->tFFFFFEB8;
								if (eax_1957 > 0x00)
								{
									Eq_2 eax_1991;
									if (ebp_1005->tFFFFFED8 == 0x00)
									{
										struct Eq_88478 * esp_2006 = esp_1017 - 0x04;
										esp_2006->tFFFFFFFC = ebp_1005->tFFFFFEB8;
										esp_2006->tFFFFFFF8.u0 = 0x20;
										esp_2006->tFFFFFFF4 = edi_1879;
										Eq_2 esp_2022 = <invalid>;
										word32 ecx_5094;
										word32 edx_5095;
										word32 ebx_5096;
										word32 esi_5097;
										eax_1991 = _IO_padn(gs, esp_2006->tFFFFFFF4, esp_2006->tFFFFFFF8, esp_2006->tFFFFFFFC, out ecx_5094, out edx_5095, out ebx_5096, out ebp_1005, out esi_5097, out edi_1879);
										esp_1967 = (word32) esp_2022 + 16;
									}
									else
									{
										struct Eq_88440 * esp_1969 = esp_1017 - 0x04;
										esp_1969->tFFFFFFFC = eax_1957;
										esp_1969->tFFFFFFF8.u0 = 0x20;
										esp_1969->tFFFFFFF4 = edi_1879;
										Eq_2 esp_1998 = <invalid>;
										word32 edx_5091;
										word32 ecx_5090;
										word32 esi_5093;
										word32 ebx_5092;
										eax_1991 = _IO_wpadn(gs, esp_1969->tFFFFFFF4, esp_1969->tFFFFFFF8, esp_1969->tFFFFFFFC, out ecx_5090, out edx_5091, out ebx_5092, out ebp_1005, out esi_5093, out edi_1879);
										esp_1967 = (word32) esp_1998 + 16;
									}
									esi_1960 = ebp_1005->tFFFFFEB8;
									if (eax_1991 != esi_1960)
										goto l0807AEB8;
l0807B542:
									int8 al_2143;
									if (ebp_1005->tFFFFFEE0 != 0x00)
									{
										if (ebp_1005->tFFFFFED8 != 0x00)
										{
											Eq_2 eax_2147 = *((word32) edi_1879 + 88);
											if (eax_2147 != 0x00)
											{
												struct Eq_88594 * edx_2151 = *((word32) eax_2147 + 16);
												if (edx_2151 < *((word32) eax_2147 + 20))
												{
													*((word32) eax_2147 + 16) = (char *) &edx_2151->t0000 + 4;
													edx_2151->t0000.u0 = 0x2D;
													goto l0807B581;
												}
											}
											esp_1967->dwFFFFFFF4 = 0x2D;
											goto l0807C303;
										}
										Eq_2 eax_2121 = *((word32) edi_1879 + 20);
										if (eax_2121 < *((word32) edi_1879 + 24))
										{
											*((word32) edi_1879 + 20) = (word32) eax_2121 + 1;
											*eax_2121 = 0x2D;
											goto l0807B581;
										}
										esp_1967->dwFFFFFFF4 = 0x2D;
l0807C3E3:
										struct Eq_90314 * esp_2128 = esp_1967 - 0x0C;
										esp_2128->tFFFFFFFC = edi_1879;
										word32 edx_5150;
										word32 ecx_5149;
										al_2143 = (int8) (__overflow(esp_2128->tFFFFFFFC, esp_2128->t0000, out ecx_5149, out edx_5150) == ~0x00);
l0807C312:
										if (al_2143 != 0x00)
											goto l0807AEB8;
										goto l0807B581;
									}
									byte al_2046 = ebp_1005->ptrFFFFFEDC->b000C;
									if ((al_2046 & 0x40) != 0x00)
									{
										if (ebp_1005->tFFFFFED8 != 0x00)
										{
											Eq_2 eax_2102 = *((word32) edi_1879 + 88);
											if (eax_2102 != 0x00)
											{
												struct Eq_88594 * edx_2106 = *((word32) eax_2102 + 16);
												if (edx_2106 < *((word32) eax_2102 + 20))
												{
													*((word32) eax_2102 + 16) = (char *) &edx_2106->t0000 + 4;
													edx_2106->t0000.u0 = 0x2B;
													goto l0807B581;
												}
											}
											esp_1967->dwFFFFFFF4 = 0x2B;
l0807C303:
											struct Eq_90237 * esp_2159 = esp_1967 - 0x0C;
											esp_2159->tFFFFFFFC = edi_1879;
											word32 ecx_5148;
											al_2143 = (int8) (__woverflow(esp_2159->tFFFFFFFC, esp_2159->t0000, out ecx_5148) == ~0x00);
											goto l0807C312;
										}
										Eq_2 eax_2092 = *((word32) edi_1879 + 20);
										if (eax_2092 >= *((word32) edi_1879 + 24))
										{
											esp_1967->dwFFFFFFF4 = 0x2B;
											goto l0807C3E3;
										}
										*((word32) edi_1879 + 20) = (word32) eax_2092 + 1;
										*eax_2092 = 0x2B;
									}
									else
									{
										if ((al_2046 & 0x10) == 0x00)
										{
l0807B584:
											struct Eq_86767 * esp_2254;
											int8 al_2519;
											Eq_2 eax_2434;
											int8 al_2276;
											if (ebp_1005->tFFFFFED8 == 0x00)
											{
												byte al_2257;
												Eq_2 eax_2213 = *((word32) edi_1879 + 20);
												if (eax_2213 < *((word32) edi_1879 + 24))
												{
													*((word32) edi_1879 + 20) = (word32) eax_2213 + 1;
													*eax_2213 = 0x30;
													Eq_2 eax_2245 = ebp_1005->ptrFFFFFEDC->t0008;
													ebp_1005->tFFFFFEE0 = eax_2245;
													al_2257 = (byte) ((word32) eax_2245 + 23);
												}
												else
												{
													struct Eq_90046 * esp_2219 = esp_1967 - 0x08;
													esp_2219->tFFFFFFFC.u0 = 0x30;
													esp_2219->tFFFFFFF8 = edi_1879;
													word32 edx_5145;
													word32 ecx_5144;
													if (__overflow(esp_2219->tFFFFFFF8, esp_2219->tFFFFFFFC, out ecx_5144, out edx_5145) == ~0x00)
														goto l0807AEB8;
													Eq_2 eax_2237 = ebp_1005->ptrFFFFFEDC->t0008;
													ebp_1005->tFFFFFEE0 = eax_2237;
													al_2257 = (byte) ((word32) eax_2237 + 23);
												}
												esp_2254 = esp_1967;
												Eq_2 edx_2251 = *((word32) edi_1879 + 20);
												if (edx_2251 < *((word32) edi_1879 + 24))
												{
													*((word32) edi_1879 + 20) = (word32) edx_2251 + 1;
													*edx_2251 = al_2257;
													ebp_1005->tFFFFFEC8 = (word32) esi_1960 + 2;
													if ((ebp_1005->ptrFFFFFEDC->b000C & 0x20) != 0x00 || ((ebp_1005->ptrFFFFFEDC)->t0010 != 0x30 || ebp_1005->tFFFFFEB8 <= 0x00))
													{
l0807BA30:
														Eq_2 eax_2494 = *((word32) edi_1879 + 20);
														if (eax_2494 < *((word32) edi_1879 + 24))
														{
															Eq_2 bl_2523 = ebp_1005->tFFFFFE93;
															*((word32) edi_1879 + 20) = (word32) eax_2494 + 1;
															*eax_2494 = bl_2523;
l0807B692:
															struct Eq_86767 * esp_3288;
															Eq_2 ebx_3086;
															Eq_2 eax_3062;
															int8 al_3001;
															byte al_3027;
															Eq_2 eax_2728;
															Eq_2 eax_2570 = ebp_1005->tFFFFFEC8;
															Eq_2 esi_2573 = (word32) eax_2570 + 1;
															if (ebp_1005->tFFFFFEC4 <= 0x00 && ((ebp_1005->ptrFFFFFEDC)->b000C & 0x08) == 0x00)
															{
l0807BA70:
																Eq_2 ecx_2955 = ebp_1005->tFFFFFED8;
																Eq_2 eax_2956 = ebp_1005->ptrFFFFFEDC->t0008;
																ebp_1005->tFFFFFEE0 = eax_2956;
																eax_2728 = (word32) eax_2956 + 0x0F;
																al_3027 = (byte) ((word32) eax_2956 + 0x0F);
																if (ecx_2955 == 0x00)
																{
																	ebp_1005->tFFFFFEE0 = esi_2573;
l0807BCD6:
																	Eq_2 edx_3020 = *((word32) edi_1879 + 20);
																	if (edx_3020 < *((word32) edi_1879 + 24))
																	{
																		*((word32) edi_1879 + 20) = (word32) edx_3020 + 1;
																		*edx_3020 = al_3027;
																		eax_3062 = (0x00 - (ebp_1005->tFFFFFE98 < 0x01) & ~0x01) + 0x2D;
																		goto l0807BCF9;
																	}
																	struct Eq_89313 * esp_3025 = esp_2254 - 0x08;
																	esp_3025->tFFFFFFFC = (word32) al_3027;
																	esp_3025->tFFFFFFF8 = edi_1879;
																	word32 edx_5115;
																	word32 ecx_5114;
																	word32 eax_3035 = __overflow(esp_3025->tFFFFFFF8, esp_3025->tFFFFFFFC, out ecx_5114, out edx_5115);
																	esp_2254 = (struct Eq_86767 *) ((char *) &esp_3025->tFFFFFFFC + 0x0C);
																	esi_2573 = ebp_1005->tFFFFFEE0;
																	al_3001 = (int8) (eax_3035 == ~0x00);
l0807BAB5:
																	if (al_3001 != 0x00)
																		goto l0807AEB8;
																	eax_3062 = (0x00 - (ebp_1005->tFFFFFE98 < 0x01) & ~0x01) + 0x2D;
																	if (ebp_1005->tFFFFFED8 == 0x00)
																	{
																		ebp_1005->tFFFFFEE0 = esi_2573;
l0807BCF9:
																		byte al_3214 = (byte) eax_3062;
																		Eq_2 edx_3186 = *((word32) edi_1879 + 20);
																		if (edx_3186 < *((word32) edi_1879 + 24))
																		{
																			Eq_2 ebx_3212 = ebp_1005->tFFFFFEE0;
																			*((word32) edi_1879 + 20) = (word32) edx_3186 + 1;
																			*edx_3186 = al_3214;
																			ebx_3086 = (word32) ebx_3212 + 2;
																		}
																		else
																		{
																			struct Eq_89364 * esp_3190 = esp_2254 - 0x08;
																			esp_3190->tFFFFFFFC = eax_3062;
																			esp_3190->tFFFFFFF8 = edi_1879;
																			word32 ecx_5116;
																			word32 edx_5117;
																			word32 eax_3197 = __overflow(esp_3190->tFFFFFFF8, esp_3190->tFFFFFFFC, out ecx_5116, out edx_5117);
																			ebx_3086 = (word32) ebp_1005->tFFFFFEE0 + 2;
																			if (eax_3197 == ~0x00)
																				goto l0807AEB8;
																		}
																		Eq_2 eax_3220 = ebp_1005->tFFFFFE80;
																		Mem3223[ebp_1005 + -288:word32] = ebx_3086 + eax_3220;
																		esp_3288 = esp_2254;
																		Eq_89410 esi_3225 = ebp_1005->tFFFFFE88 - ebx_3086;
																		if (eax_3220 == 0x00)
																		{
l0807BB7E:
																			ebp_1005->tFFFFFEE0 = ebx_3086;
																			goto l0807BB88;
																		}
																		do
																		{
																			word32 edx_3232 = CONVERT(Mem3231[esi_3225 + ebx_3086:byte], byte, word32);
																			byte dl_3239 = (byte) edx_3232;
																			Eq_2 eax_3234 = *((word32) edi_1879 + 20);
																			if (eax_3234 >= *((word32) edi_1879 + 24))
																			{
																				struct Eq_89871 * esp_3242 = esp_2254 - 0x08;
																				esp_3242->tFFFFFFFC = edx_3232;
																				esp_3242->tFFFFFFF8 = edi_1879;
																				word32 edx_5138;
																				word32 ecx_5137;
																				if (__overflow(esp_3242->tFFFFFFF8, esp_3242->tFFFFFFFC, out ecx_5137, out edx_5138) == ~0x00)
																					goto l0807AEB8;
																			}
																			else
																			{
																				*((word32) edi_1879 + 20) = (word32) eax_3234 + 1;
																				*eax_3234 = dl_3239;
																			}
																			esp_3288 = esp_2254;
																			ebx_3086 = (word32) ebx_3086 + 1;
																		} while (ebp_1005->tFFFFFEE0 != ebx_3086);
l0807BB88:
																		struct Eq_87292 * eax_3274 = ebp_1005->ptrFFFFFEDC;
																		if ((eax_3274->b000C & 0x20) == 0x00)
																			goto l0807B06E;
																		Eq_2 eax_3278 = eax_3274->t0010;
																		if (eax_3278 == 0x30)
																			goto l0807B06E;
																		Eq_2 ebx_3281 = ebp_1005->tFFFFFEB8;
																		if (ebx_3281 <= 0x00)
																		{
l0807B06E:
																			if ((ebp_1005->dwFFFFFFE4 ^ gs->dw0014) == 0x00)
																				return;
l0807C4D2:
																			word32 edx_5072;
																			word32 ecx_5071;
																			__stack_chk_fail(out ecx_5071, out edx_5072);
																			register_printf_modifier(gs, dwArg04);
																			return;
																		}
																		Eq_2 eax_3328;
																		if (ebp_1005->tFFFFFED8 != 0x00)
																		{
																			struct Eq_89574 * esp_3343 = esp_3288 - 0x04;
																			esp_3343->tFFFFFFFC = ebx_3281;
																			esp_3343->tFFFFFFF8 = eax_3278;
																			esp_3343->tFFFFFFF4 = edi_1879;
																			word32 edi_5133;
																			word32 ecx_5129;
																			word32 esi_5132;
																			word32 edx_5130;
																			word32 ebx_5131;
																			eax_3328 = _IO_wpadn(gs, esp_3343->tFFFFFFF4, esp_3343->tFFFFFFF8, esp_3343->tFFFFFFFC, out ecx_5129, out edx_5130, out ebx_5131, out ebp_1005, out esi_5132, out edi_5133);
																		}
																		else
																		{
																			struct Eq_89537 * esp_3294 = esp_3288 - 0x04;
																			esp_3294->tFFFFFFFC = ebp_1005->tFFFFFEB8;
																			esp_3294->tFFFFFFF8 = eax_3278;
																			esp_3294->tFFFFFFF4 = edi_1879;
																			word32 ebx_5126;
																			word32 edx_5125;
																			word32 ecx_5124;
																			word32 esi_5127;
																			word32 edi_5128;
																			eax_3328 = _IO_padn(gs, esp_3294->tFFFFFFF4, esp_3294->tFFFFFFF8, esp_3294->tFFFFFFFC, out ecx_5124, out edx_5125, out ebx_5126, out ebp_1005, out esi_5127, out edi_5128);
																		}
																		Eq_2 edi_3369 = ebp_1005->tFFFFFEB8;
																		if (edi_3369 == eax_3328)
																		{
																			Mem3374[ebp_1005 + -288:word32] = Mem3368[ebp_1005 + -288:word32] + edi_3369;
																			goto l0807B06E;
																		}
																		goto l0807AEB8;
																	}
																	Eq_2 edx_3074 = *((word32) edi_1879 + 88);
																	if (edx_3074 != 0x00)
																	{
																		struct Eq_88594 * ecx_3078 = *((word32) edx_3074 + 16);
																		if (ecx_3078 < *((word32) edx_3074 + 20))
																		{
																			*((word32) edx_3074 + 16) = (char *) &ecx_3078->t0000 + 4;
																			ecx_3078->t0000 = eax_3062;
																			ebx_3086 = (word32) esi_2573 + 2;
l0807BAFC:
																			Eq_2 ecx_3111 = ebp_1005->tFFFFFE80;
																			Eq_2 edx_3112 = ebp_1005->tFFFFFE7C;
																			Mem3115[ebp_1005 + -288:word32] = ebx_3086 + ecx_3111;
																			ebp_1005->tFFFFFEC8 = edx_3112 - ebx_3086 * 0x04;
																			esp_3288 = esp_2254;
																			if (ecx_3111 == 0x00)
																				goto l0807BB7E;
																			do
																			{
																				int8 al_3139;
																				Eq_2 ecx_3126 = *((word32) ebp_1005->tFFFFFEC8 + ebx_3086 * 0x04);
																				Eq_2 eax_3128 = *((word32) edi_1879 + 88);
																				if (eax_3128 == 0x00)
																				{
l0807BB69:
																					struct Eq_89768 * esp_3143 = esp_2254 - 0x08;
																					esp_3143->tFFFFFFFC = ecx_3126;
																					esp_3143->tFFFFFFF8 = edi_1879;
																					word32 ecx_5136;
																					al_3139 = (int8) (__woverflow(esp_3143->tFFFFFFF8, esp_3143->tFFFFFFFC, out ecx_5136) == ~0x00);
																					goto l0807BB46;
																				}
																				struct Eq_88594 * edx_3132 = *((word32) eax_3128 + 16);
																				if (edx_3132 >= *((word32) eax_3128 + 20))
																					goto l0807BB69;
																				*((word32) eax_3128 + 16) = (char *) &edx_3132->t0000 + 4;
																				edx_3132->t0000 = ecx_3126;
																				al_3139 = (int8) (ecx_3126 == ~0x00);
l0807BB46:
																				esp_3288 = esp_2254;
																				if (al_3139 != 0x00)
																					goto l0807AEB8;
																				ebx_3086 = (word32) ebx_3086 + 1;
																			} while (ebp_1005->tFFFFFEE0 != ebx_3086);
																			goto l0807BB88;
																		}
																	}
																	struct Eq_89684 * esp_3083 = esp_2254 - 0x08;
																	esp_3083->tFFFFFFFC = eax_3062;
																	esp_3083->tFFFFFFF8 = edi_1879;
																	ebx_3086 = (word32) esi_2573 + 2;
																	word32 ecx_5135;
																	if (__woverflow(esp_3083->tFFFFFFF8, esp_3083->tFFFFFFFC, out ecx_5135) == ~0x00)
																		goto l0807AEB8;
																	goto l0807BAFC;
																}
l0807BA90:
																Eq_2 edx_2969 = *((word32) edi_1879 + 88);
																if (edx_2969 != 0x00)
																{
																	struct Eq_88594 * ecx_2973 = *((word32) edx_2969 + 16);
																	if (ecx_2973 < *((word32) edx_2969 + 20))
																	{
																		*((word32) edx_2969 + 16) = (char *) &ecx_2973->t0000 + 4;
																		ecx_2973->t0000 = eax_2728;
																		al_3001 = (int8) (eax_2728 == ~0x00);
																		goto l0807BAB5;
																	}
																}
																struct Eq_89616 * esp_2981 = esp_2254 - 0x08;
																esp_2981->tFFFFFFFC = eax_2728;
																esp_2981->tFFFFFFF8 = edi_1879;
																esp_2254 = (struct Eq_86767 *) ((char *) &esp_2981->tFFFFFFFC + 0x0C);
																word32 ecx_5134;
																al_3001 = (int8) (__woverflow(esp_2981->tFFFFFFF8, esp_2981->tFFFFFFFC, out ecx_5134) == ~0x00);
																goto l0807BAB5;
															}
															word32 esi_2768;
															Eq_2 eax_2762;
															Eq_2 eax_2582 = ebp_1005->tFFFFFED8;
															ebp_1005->tFFFFFEE0 = (word32) eax_2570 + 1;
															if (eax_2582 == 0x00)
															{
																Eq_2 ebx_2777 = ebp_1005->tFFFFFEBC;
																struct Eq_88990 * esp_2778 = esp_2254 - 0x0C;
																esp_2778->tFFFFFFFC = ebx_2777;
																word32 edx_5110;
																word32 ecx_5109;
																Eq_2 eax_2782 = strlen(esp_2778->tFFFFFFFC, out ecx_5109, out edx_5110);
																Eq_2 edx_2789 = ebp_1005->tFFFFFEE0;
																ptr32 ebx_2791 = ebx_2777 - ebp_1005->tFFFFFEC8;
																Mem2793[ebp_1005 + -288:word32] = edx_2789 + eax_2782;
																if (eax_2782 == 0x00)
																	ebp_1005->tFFFFFEE0 = edx_2789;
																else
																{
																	do
																	{
																		Eq_2 edx_2800 = (word32) *((word32) esi_2573 + (ebx_2791 - 0x01));
																		byte dl_2808 = (byte) edx_2800;
																		Eq_2 eax_2802 = *((word32) edi_1879 + 20);
																		if (eax_2802 >= *((word32) edi_1879 + 24))
																		{
																			struct Eq_89085 * esp_2814 = esp_2254 - 0x08;
																			esp_2814->tFFFFFFFC = edx_2800;
																			esp_2814->tFFFFFFF8 = edi_1879;
																			word32 ecx_5111;
																			word32 edx_5112;
																			if (__overflow(esp_2814->tFFFFFFF8, esp_2814->tFFFFFFFC, out ecx_5111, out edx_5112) == ~0x00)
																				goto l0807AEB8;
																			esi_2573 = (word32) esi_2573 + 1;
																			if (ebp_1005->tFFFFFEE0 == esi_2573)
																				break;
																			continue;
																		}
																		*((word32) edi_1879 + 20) = (word32) eax_2802 + 1;
																		*eax_2802 = dl_2808;
																		esi_2573 = (word32) esi_2573 + 1;
																	} while (ebp_1005->tFFFFFEE0 != esi_2573);
																}
																if (ebp_1005->tFFFFFEC4 <= 0x00)
																{
l0807BCC4:
																	Eq_2 eax_3013 = ebp_1005->ptrFFFFFEDC->t0008;
																	ebp_1005->tFFFFFEC8 = eax_3013;
																	al_3027 = (byte) ((word32) eax_3013 + 0x0F);
																	goto l0807BCD6;
																}
																Eq_2 ecx_2842 = ebp_1005->tFFFFFE94;
																Eq_2 esi_2841 = ebp_1005->tFFFFFEC4;
																Eq_2 eax_2845 = ebp_1005->tFFFFFE84 - ecx_2842;
																Eq_2 ebx_2846 = esi_2841 - eax_2845;
																if (esi_2841 <= eax_2845)
																	eax_2845 = esi_2841;
																Eq_2 esi_2852 = ebp_1005->tFFFFFEE0;
																ebp_1005->tFFFFFEC8 = ebx_2846;
																Mem2860[ebp_1005 + -288:word32] = esi_2852 + eax_2845;
																ptr32 ebx_2859 = ecx_2842 - esi_2852;
																if (eax_2845 != 0x00)
																{
																	do
																	{
																		Eq_2 edx_2867 = (word32) *((word32) esi_2852 + ebx_2859);
																		byte dl_2874 = (byte) edx_2867;
																		Eq_2 eax_2869 = *((word32) edi_1879 + 20);
																		if (eax_2869 >= *((word32) edi_1879 + 24))
																		{
																			struct Eq_89922 * esp_2877 = esp_2254 - 0x08;
																			esp_2877->tFFFFFFFC = edx_2867;
																			esp_2877->tFFFFFFF8 = edi_1879;
																			word32 edx_5140;
																			word32 ecx_5139;
																			if (__overflow(esp_2877->tFFFFFFF8, esp_2877->tFFFFFFFC, out ecx_5139, out edx_5140) == ~0x00)
																				goto l0807AEB8;
																		}
																		else
																		{
																			*((word32) edi_1879 + 20) = (word32) eax_2869 + 1;
																			*eax_2869 = dl_2874;
																		}
																		esi_2852 = (word32) esi_2852 + 1;
																	} while (esi_2852 != ebp_1005->tFFFFFEE0);
																}
																if (ebp_1005->tFFFFFEC8 <= 0x00)
																{
																	ebp_1005->tFFFFFEE0 = esi_2852;
																	goto l0807BCC4;
																}
																struct Eq_89476 * esp_2910 = esp_2254 - 0x04;
																esp_2910->tFFFFFFFC = ebp_1005->tFFFFFEC8;
																esp_2910->tFFFFFFF8.u0 = 0x30;
																esp_2910->tFFFFFFF4 = edi_1879;
																Eq_2 esp_2936 = <invalid>;
																word32 ecx_5121;
																word32 edx_5122;
																word32 ebx_5123;
																eax_2762 = _IO_padn(gs, esp_2910->tFFFFFFF4, esp_2910->tFFFFFFF8, esp_2910->tFFFFFFFC, out ecx_5121, out edx_5122, out ebx_5123, out ebp_1005, out esi_2768, out edi_1879);
																esp_2254 = (word32) esp_2936 + 16;
l0807BEC4:
																if (eax_2762 != ebp_1005->tFFFFFEC8)
																	goto l0807AEB8;
																esi_2573 = (word32) eax_2762 + esi_2768;
																goto l0807BA70;
															}
															int8 al_2623;
															Eq_2 eax_2591 = *((word32) edi_1879 + 88);
															if (eax_2591 != 0x00)
															{
																struct Eq_88594 * edx_2595 = *((word32) eax_2591 + 16);
																if (edx_2595 < *((word32) eax_2591 + 20))
																{
																	*((word32) eax_2591 + 16) = (char *) &edx_2595->t0000 + 4;
																	Eq_2 eax_2626 = ebp_1005->tFFFFFEC0;
																	edx_2595->t0000 = eax_2626;
																	al_2623 = (int8) (eax_2626 == ~0x00);
l0807B7F3:
																	if (al_2623 != 0x00)
																		goto l0807AEB8;
																	esi_2573 = (word32) ebp_1005->tFFFFFEC8 + 2;
																	if (ebp_1005->tFFFFFEC4 > 0x00)
																	{
																		Eq_2 ebx_2642 = ebp_1005->tFFFFFEC4;
																		Eq_2 eax_2644 = ebp_1005->tFFFFFE84 - ebp_1005->tFFFFFE94;
																		Eq_2 ecx_2645 = ebp_1005->tFFFFFEC8;
																		ebp_1005->tFFFFFEC0 = eax_2644;
																		if (ebx_2642 <= eax_2644)
																			eax_2644 = ebx_2642;
																		ebp_1005->tFFFFFEE0 = ebp_1005->tFFFFFEA8 - ecx_2645 * 0x04;
																		ebp_1005->tFFFFFEC8 = (word32) eax_2644 + ((word32) ecx_2645 + 2);
																		if (eax_2644 != 0x00)
																		{
																			do
																			{
																				int8 al_2680;
																				Eq_2 ecx_2667 = (ebp_1005->tFFFFFEE0 - 0x08)[esi_2573];
																				Eq_2 eax_2669 = *((word32) edi_1879 + 88);
																				if (eax_2669 == 0x00)
																				{
l0807B89E:
																					struct Eq_89959 * esp_2684 = esp_2254 - 0x08;
																					esp_2684->tFFFFFFFC = ecx_2667;
																					esp_2684->tFFFFFFF8 = edi_1879;
																					word32 ecx_5141;
																					al_2680 = (int8) (__woverflow(esp_2684->tFFFFFFF8, esp_2684->tFFFFFFFC, out ecx_5141) == ~0x00);
																					goto l0807B876;
																				}
																				struct Eq_88594 * edx_2673 = *((word32) eax_2669 + 16);
																				if (edx_2673 >= *((word32) eax_2669 + 20))
																					goto l0807B89E;
																				*((word32) eax_2669 + 16) = (char *) &edx_2673->t0000 + 4;
																				edx_2673->t0000 = ecx_2667;
																				al_2680 = (int8) (ecx_2667 == ~0x00);
l0807B876:
																				if (al_2680 != 0x00)
																					goto l0807AEB8;
																				esi_2573 = (word32) esi_2573 + 1;
																			} while (esi_2573 != ebp_1005->tFFFFFEC8);
																		}
																		Eq_2 eax_2719 = ebp_1005->tFFFFFEC4 - ebp_1005->tFFFFFEC0;
																		ebp_1005->tFFFFFEC8 = eax_2719;
																		if (eax_2719 > 0x00)
																		{
																			struct Eq_89433 * esp_2734 = esp_2254 - 0x04;
																			esp_2734->tFFFFFFFC = ebp_1005->tFFFFFEC8;
																			esp_2734->tFFFFFFF8.u0 = 0x30;
																			esp_2734->tFFFFFFF4 = edi_1879;
																			Eq_2 esp_2769 = <invalid>;
																			word32 ecx_5118;
																			word32 ebx_5120;
																			word32 edx_5119;
																			eax_2762 = _IO_wpadn(gs, esp_2734->tFFFFFFF4, esp_2734->tFFFFFFF8, esp_2734->tFFFFFFFC, out ecx_5118, out edx_5119, out ebx_5120, out ebp_1005, out esi_2768, out edi_1879);
																			esp_2254 = (word32) esp_2769 + 16;
																			goto l0807BEC4;
																		}
																	}
																	Eq_2 eax_2726 = ebp_1005->ptrFFFFFEDC->t0008;
																	ebp_1005->tFFFFFEE0 = eax_2726;
																	eax_2728 = (word32) eax_2726 + 0x0F;
																	goto l0807BA90;
																}
															}
															struct Eq_89114 * esp_2602 = esp_2254 - 0x08;
															esp_2602->tFFFFFFFC = ebp_1005->tFFFFFEC0;
															esp_2602->tFFFFFFF8 = edi_1879;
															word32 ecx_5113;
															al_2623 = (int8) (__woverflow(esp_2602->tFFFFFFF8, esp_2602->tFFFFFFFC, out ecx_5113) == ~0x00);
															goto l0807B7F3;
														}
														struct Eq_90004 * esp_2502 = esp_2254 - 0x08;
														esp_2502->tFFFFFFFC = (word32) ebp_1005->tFFFFFE93;
														esp_2502->tFFFFFFF8 = edi_1879;
														esp_2254 = (struct Eq_86767 *) ((char *) &esp_2502->tFFFFFFFC + 0x0C);
														word32 ecx_5142;
														word32 edx_5143;
														al_2519 = (int8) (__overflow(esp_2502->tFFFFFFF8, esp_2502->tFFFFFFFC, out ecx_5142, out edx_5143) == ~0x00);
l0807B68A:
														if (al_2519 != 0x00)
															goto l0807AEB8;
														goto l0807B692;
													}
													goto l0807BA16;
												}
												struct Eq_90092 * esp_2255 = esp_1967 - 0x08;
												esp_2255->tFFFFFFFC = (word32) al_2257;
												esp_2255->tFFFFFFF8 = edi_1879;
												word32 ecx_5146;
												word32 edx_5147;
												al_2276 = (int8) (__overflow(esp_2255->tFFFFFFF8, esp_2255->tFFFFFFFC, out ecx_5146, out edx_5147) == ~0x00);
l0807B5DF:
												esp_2254 = esp_1967;
												if (al_2276 != 0x00)
													goto l0807AEB8;
												ebp_1005->tFFFFFEC8 = (word64) esi_1960.u0 + 2;
												struct Eq_87292 * eax_2389 = ebp_1005->ptrFFFFFEDC;
												if ((eax_2389->b000C & 0x20) != 0x00 || (eax_2389->t0010 != 0x30 || ebp_1005->tFFFFFEB8 <= 0x00))
												{
l0807B650:
													if (ebp_1005->tFFFFFED8 != 0x00)
													{
														Eq_2 eax_2525 = *((word32) edi_1879 + 88);
														if (eax_2525 != 0x00)
														{
															struct Eq_88594 * edx_2529 = *((word32) eax_2525 + 16);
															if (edx_2529 < *((word32) eax_2525 + 20))
															{
																Eq_2 ecx_2555 = (int32) ebp_1005->tFFFFFE93;
																*((word32) eax_2525 + 16) = (char *) &edx_2529->t0000 + 4;
																edx_2529->t0000 = ecx_2555;
																al_2519 = (int8) (ecx_2555 == ~0x00);
																goto l0807B68A;
															}
														}
														struct Eq_88886 * esp_2536 = esp_2254 - 0x08;
														esp_2536->tFFFFFFFC = (int32) ebp_1005->tFFFFFE93;
														esp_2536->tFFFFFFF8 = edi_1879;
														esp_2254 = (struct Eq_86767 *) ((char *) &esp_2536->tFFFFFFFC + 0x0C);
														word32 ecx_5108;
														al_2519 = (int8) (__woverflow(esp_2536->tFFFFFFF8, esp_2536->tFFFFFFFC, out ecx_5108) == ~0x00);
														goto l0807B68A;
													}
													goto l0807BA30;
												}
												if (ebp_1005->tFFFFFED8 != 0x00)
												{
													struct Eq_88793 * esp_2449 = esp_1967 - 0x04;
													esp_2449->tFFFFFFFC = ebp_1005->tFFFFFEB8;
													esp_2449->tFFFFFFF8.u0 = 0x30;
													esp_2449->tFFFFFFF4 = edi_1879;
													Eq_2 esp_2466 = <invalid>;
													word32 edx_5105;
													word32 ecx_5104;
													word32 esi_5107;
													word32 ebx_5106;
													eax_2434 = _IO_wpadn(gs, esp_2449->tFFFFFFF4, esp_2449->tFFFFFFF8, esp_2449->tFFFFFFFC, out ecx_5104, out edx_5105, out ebx_5106, out ebp_1005, out esi_5107, out edi_1879);
													esp_2254 = (word32) esp_2466 + 16;
l0807B634:
													Eq_2 esi_2476 = ebp_1005->tFFFFFEB8;
													if (esi_2476 != eax_2434)
														goto l0807AEB8;
													Mem2481[ebp_1005 + -312:word32] = Mem2475[ebp_1005 + -312:word32] + esi_2476;
													goto l0807B650;
												}
l0807BA16:
												struct Eq_88751 * esp_2404 = esp_1967 - 0x04;
												esp_2404->tFFFFFFFC = ebp_1005->tFFFFFEB8;
												esp_2404->tFFFFFFF8.u0 = 0x30;
												esp_2404->tFFFFFFF4 = edi_1879;
												Eq_2 esp_2441 = <invalid>;
												word32 ecx_5100;
												word32 ebx_5102;
												word32 edx_5101;
												word32 esi_5103;
												eax_2434 = _IO_padn(gs, esp_2404->tFFFFFFF4, esp_2404->tFFFFFFF8, esp_2404->tFFFFFFFC, out ecx_5100, out edx_5101, out ebx_5102, out ebp_1005, out esi_5103, out edi_1879);
												esp_2254 = (word32) esp_2441 + 16;
												goto l0807B634;
											}
											Eq_2 edx_2326;
											struct Eq_88594 * ebx_2300;
											struct Eq_88594 * ecx_2331;
											Eq_2 eax_2295 = *((word32) edi_1879 + 88);
											if (eax_2295 != 0x00)
											{
												struct Eq_88594 * edx_2299 = *((word32) eax_2295 + 16);
												ebx_2300 = (struct Eq_88594 *) *((word32) eax_2295 + 20);
												if (edx_2299 < ebx_2300)
												{
													*((word32) eax_2295 + 16) = (char *) &edx_2299->t0000 + 4;
													edx_2299->t0000.u0 = 0x30;
													Eq_2 edx_2337 = ebp_1005->ptrFFFFFEDC->t0008;
													ebp_1005->tFFFFFEE0 = edx_2337;
													ecx_2331 = (struct Eq_88594 *) ((char *) &edx_2299->t0000 + 4);
													edx_2326 = (word32) edx_2337 + 23;
													goto l0807B5C9;
												}
											}
											struct Eq_88629 * esp_2304 = esp_1967 - 0x08;
											esp_2304->tFFFFFFFC.u0 = 0x30;
											esp_2304->tFFFFFFF8 = edi_1879;
											word32 ecx_5098;
											if (__woverflow(esp_2304->tFFFFFFF8, esp_2304->tFFFFFFFC, out ecx_5098) == ~0x00)
												goto l0807AEB8;
											Eq_2 eax_2324 = ebp_1005->ptrFFFFFEDC->t0008;
											ebp_1005->tFFFFFEE0 = eax_2324;
											edx_2326 = (word32) eax_2324 + 23;
											eax_2295 = *((word32) edi_1879 + 88);
											if (eax_2295 == 0x00)
											{
l0807C008:
												struct Eq_88681 * esp_2347 = esp_1967 - 0x08;
												esp_2347->tFFFFFFFC = edx_2326;
												esp_2347->tFFFFFFF8 = edi_1879;
												word32 ecx_5099;
												al_2276 = (int8) (__woverflow(esp_2347->tFFFFFFF8, esp_2347->tFFFFFFFC, out ecx_5099) == ~0x00);
												goto l0807B5DF;
											}
											ecx_2331 = (struct Eq_88594 *) *((word32) eax_2295 + 16);
											ebx_2300 = (struct Eq_88594 *) *((word32) eax_2295 + 20);
l0807B5C9:
											if (ecx_2331 < ebx_2300)
											{
												*((word32) eax_2295 + 16) = (char *) &ecx_2331->t0000 + 4;
												ecx_2331->t0000 = edx_2326;
												al_2276 = (int8) (edx_2326 == ~0x00);
												goto l0807B5DF;
											}
											goto l0807C008;
										}
										if (ebp_1005->tFFFFFED8 != 0x00)
										{
											Eq_2 eax_2073 = *((word32) edi_1879 + 88);
											if (eax_2073 != 0x00)
											{
												struct Eq_88594 * edx_2077 = *((word32) eax_2073 + 16);
												if (edx_2077 < *((word32) eax_2073 + 20))
												{
													*((word32) eax_2073 + 16) = (char *) &edx_2077->t0000 + 4;
													edx_2077->t0000.u0 = 0x20;
													goto l0807B581;
												}
											}
											esp_1967->dwFFFFFFF4 = 0x20;
											goto l0807C303;
										}
										Eq_2 eax_2060 = *((word32) edi_1879 + 20);
										if (eax_2060 >= *((word32) edi_1879 + 24))
										{
											esp_1967->dwFFFFFFF4 = 0x20;
											goto l0807C3E3;
										}
										*((word32) edi_1879 + 20) = (word32) eax_2060 + 1;
										*eax_2060 = 0x20;
									}
l0807B581:
									esi_1960 = (word64) esi_1960.u0 + 1;
									goto l0807B584;
								}
							}
							esi_1960.u0 = 0x00;
							goto l0807B542;
						}
						word32 eax_1147 = (word32) ebp_1005->tFFFFFE93;
						if (ecx_1140 > 0x00)
							eax_1147 = CONVERT(Mem1137[edx_1139 - 0x01 + ecx_1140:byte], byte, word32);
						Mem1161[ebp_1005 + -312:byte] = Mem1137[Mem1137[ebp_1005 + -364:word32] + Mem1137[ebp_1005 + -316:word32]:byte];
						int32 edx_1159 = (int32) (byte) eax_1147;
						if ((byte) (eax_1147 - 0x41) <= 0x05)
							ebp_1005->tFFFFFE88 = edx_1159 - 55;
						else
						{
							Eq_2 eax_1171 = edx_1159 - 0x57;
							if ((byte) (eax_1147 - 0x61) > 0x05)
								eax_1171 = edx_1159 - 0x30;
							ebp_1005->tFFFFFE88 = eax_1171;
						}
						Eq_2 ecx_1210;
						int32 edx_1194;
						int32 eax_1184 = (int32) ebp_1005->tFFFFFEC8;
						if ((byte) (eax_1184 - 0x41) <= 0x05)
							edx_1194 = eax_1184 - 55;
						else if ((byte) ((word32) ebp_1005->tFFFFFEC8 - 0x61) <= 0x05)
							edx_1194 = eax_1184 - 0x57;
						else
						{
							edx_1194 = eax_1184 - 0x30;
							if (((byte) (eax_1184 - 0x30) & 0x07) == 0x00)
							{
								ecx_1210 = (uint32) (int8) ((word32) ebp_1005->tFFFFFEC4 + 1 < esi_1141);
l0807B2D0:
								ebp_1005->wFFFFFF08 = __fstcw();
								uint16 ax_1215 = ebp_1005->wFFFFFF08;
								if ((ax_1215 & 0x0C00) == 0x0400)
								{
									if (ebp_1005->tFFFFFEE0 == 0x00)
										goto l0807AD70;
									goto l0807B309;
								}
								else
								{
									if ((ax_1215 & 0x0C00) > 0x0400)
									{
										if ((ax_1215 & 0x0C00) == 0x0800)
										{
											if (ebp_1005->tFFFFFEE0 != 0x00)
												goto l0807AD70;
l0807B309:
											if (edx_1194 <= 0x07 && ecx_1210 == 0x00)
												goto l0807AD70;
											goto l0807B316;
										}
										if ((ax_1215 & 0x0C00) == 0x0C00)
											goto l0807AD70;
									}
									else if ((ax_1215 & 0x0C00) == 0x00)
									{
										if (edx_1194 <= 0x07 || ((ebp_1005->tFFFFFE88 | ecx_1210) & 0x01) == 0x00)
											goto l0807AD70;
l0807B316:
										Eq_2 eax_1649 = ebp_1005->tFFFFFEC4;
										Eq_88117 eax_1650 = eax_1649 - 0x01;
										if (eax_1649 >= 0x01)
										{
											word32 esi_1654 = Mem1213[ebp_1005 + -364:word32] + (eax_1649 - 0x01);
											Eq_2 cl_1657 = *esi_1654;
											ebp_1005->tFFFFFEC8 = esi_1654;
											ebp_1005->tFFFFFE88 = cl_1657;
											if (cl_1657 != 0x39)
											{
												if (gs->ptrFFFFFFF0[(int32) cl_1657] > 101)
												{
													Eq_2 edx_1669 = ebp_1005->tFFFFFE94;
													ebp_1005->tFFFFFE80 = ebx_1078;
													ebp_1005->tFFFFFE7C = edi_1008;
													ebp_1005->tFFFFFE88 = edx_1669 - 0x01;
													do
													{
														Eq_2 edx_1708 = ebp_1005->tFFFFFEA8;
														*((word32) eax_1650 + ((word32) ebp_1005->tFFFFFE88 + 1)) = 0x30;
														*((word32) edx_1708 + eax_1650 * 0x04) = 0x30;
														--eax_1650;
														if (eax_1650 == ~0x00)
														{
															ebx_1078 = ebp_1005->tFFFFFE80;
															edi_1008 = ebp_1005->tFFFFFE7C;
															goto l0807B3DA;
														}
														Mem1717[ebp_1005 + -312:word32] = edx_1669 + eax_1650;
														byte cl_1719 = Mem1717[edx_1669 + eax_1650:byte];
														if (cl_1719 == 0x39)
														{
															ebx_1078 = ebp_1005->tFFFFFE80;
															edi_1008 = ebp_1005->tFFFFFE7C;
															goto l0807C244;
														}
													} while (gs->ptrFFFFFFF0[(int32) cl_1719] > 101);
													ebp_1005->tFFFFFE88 = cl_1719;
													ebx_1078 = ebp_1005->tFFFFFE80;
													edi_1008 = ebp_1005->tFFFFFE7C;
												}
												*ebp_1005->tFFFFFEC8 = (byte) ((word32) ebp_1005->tFFFFFE88 + 0x01);
												Eq_2 edx_1750 = ebp_1005->tFFFFFEA8;
												*((word32) edx_1750 + eax_1650 * 0x04) = (word32) *((word32) edx_1750 + eax_1650 * 0x04) + 1;
											}
											else
											{
l0807C244:
												Eq_2 edx_1728 = ebp_1005->ptrFFFFFEDC->t0008;
												*((word32) ebp_1005->tFFFFFEA8 + eax_1650 * 0x04) = edx_1728;
												*ebp_1005->tFFFFFEC8 = (byte) edx_1728;
											}
										}
										else
										{
l0807B3DA:
											if (ebp_1005->tFFFFFE93 != 0x39)
											{
												int32 eax_1766 = (int32) ebp_1005->tFFFFFE93;
												if (gs->ptrFFFFFFF0[eax_1766] <= 101)
													ebp_1005->tFFFFFE93 = (byte) (eax_1766 + 0x01);
												else if (ebp_1005->tFFFFFE98 != 0x00)
												{
													Eq_2 eax_1781 = ebx_1078 - 0x04;
													if (eax_1781 > 0x00)
													{
														ebp_1005->tFFFFFE93.u0 = 0x31;
														ebx_1078 = eax_1781;
													}
													else
													{
														ebp_1005->tFFFFFE93.u0 = 0x31;
														ebp_1005->tFFFFFE98.u0 = 0x00;
														ebx_1078 = 0x04 - ebx_1078;
													}
												}
												else
												{
													ebp_1005->tFFFFFE93.u0 = 0x31;
													ebx_1078 = (word32) ebx_1078 + 4;
												}
											}
											else
												ebp_1005->tFFFFFE93 = ebp_1005->ptrFFFFFEDC->t0008;
										}
										goto l0807AD70;
									}
									word32 ecx_5086;
									word32 edx_5087;
									abort(ecx_1210, gs, out ecx_5086, out edx_5087);
								}
							}
						}
						ecx_1210.u0 = 0x01;
						goto l0807B2D0;
					}
					ebp_1005->tFFFFFE98.u0 = 0x00;
l0807AD50:
					ebp_1005->tFFFFFE84 = ebp_1005->tFFFFFE94;
					if (ebp_1005->tFFFFFEC4 == ~0x00)
						ebp_1005->tFFFFFEC4.u0 = 0x00;
					goto l0807AD70;
				}
				if ((ebx_291 & 0x07FF) > 1022)
				{
					ebp_1005->tFFFFFE98.u0 = 0x00;
					ebx_1078 = (ebx_291 & 0x07FF) - 0x03FF;
				}
				else
				{
					ebp_1005->tFFFFFE98.u0 = 0x01;
					ebx_1078 = 0x03FF - (ebx_291 & 0x07FF);
				}
l0807B220:
				if (ebp_1005->tFFFFFE88 == 0x00)
					goto l0807B22E;
				goto l0807AD50;
			}
			(gs->ptrFFFFFFF8[esi_108].b0001 & 0x01) != 0x00;
l0807AF0C:
			Eq_2 esi_1532;
			Eq_2 eax_1526;
			Eq_2 esi_1263;
			Eq_2 eax_1262;
			Eq_2 ebx_651;
			int8 al_785;
			struct Eq_87264 * esp_1303 = fp - 400;
			byte dl_655 = (byte) edx_111;
			byte al_642 = (byte) (edx_111 & 0x20);
			if (dwLoc0128_3466 == 0x00)
			{
				if ((dl_655 & 0x50) != 0x00)
				{
					esi_1263 = esi_42 - 0x04;
					if (al_642 != 0x00)
						goto l0807B474;
					if (esi_42 <= 0x04)
					{
						eax_1262 = esi_42 - 0x04;
						esi_1263.u0 = 0x00;
						goto l0807B46C;
					}
				}
				else
				{
					esi_1263 = esi_42 - 0x03;
					if (al_642 != 0x00 || esi_42 <= 0x03)
						goto l0807B474;
				}
			}
			else
			{
				esi_1263 = esi_42 - 0x04;
				if (al_642 != 0x00 || esi_42 <= 0x04)
				{
					ebx_651.u0 = 0x00;
					if ((ecx_45 & 0x01) != 0x00)
					{
l0807AF8A:
						Eq_2 eax_791 = *((word32) edi_1298 + 88);
						if (eax_791 != 0x00)
						{
							word32 * edx_795 = *((word32) eax_791 + 16);
							if (edx_795 < *((word32) eax_791 + 20))
							{
								*((word32) eax_791 + 16) = edx_795 + 1;
								*edx_795 = 0x2D;
								goto l0807AFAD;
							}
						}
						struct Eq_87317 * esp_800 = esp_1303 - 0x08;
						esp_800->tFFFFFFFC.u0 = 0x2D;
						esp_800->tFFFFFFF8 = edi_1298;
						esp_1303 = (struct Eq_87264 *) ((char *) &esp_800->tFFFFFFFC + 0x0C);
						word32 ecx_5065;
						al_785 = (int8) (__woverflow(esp_800->tFFFFFFF8, esp_800->tFFFFFFFC, out ecx_5065) == ~0x00);
						goto l0807BFF4;
					}
l0807B445:
					Eq_2 eax_762 = *((word32) edi_1298 + 20);
					if (eax_762 < *((word32) edi_1298 + 24))
					{
						*((word32) edi_1298 + 20) = (word32) eax_762 + 1;
						*eax_762 = 0x2D;
						goto l0807AFAD;
					}
					struct Eq_87645 * esp_768 = esp_1303 - 0x08;
					esp_768->tFFFFFFFC.u0 = 0x2D;
					esp_768->tFFFFFFF8 = edi_1298;
					esp_1303 = (struct Eq_87264 *) ((char *) &esp_768->tFFFFFFFC + 0x0C);
					word32 ecx_5079;
					word32 edx_5080;
					al_785 = (int8) (__overflow(esp_768->tFFFFFFF8, esp_768->tFFFFFFFC, out ecx_5079, out edx_5080) == ~0x00);
l0807BFF4:
					if (al_785 != 0x00)
						goto l0807AEB8;
l0807AFAD:
					ebp_1005->tFFFFFEE0 = (word32) ebx_651 + 1;
					goto l0807AFB6;
				}
			}
			Eq_2 eax_701;
			if ((ecx_45 & 0x01) != 0x00)
			{
				Eq_2 esp_732 = <invalid>;
				word32 edx_5063;
				word32 ebx_5064;
				word32 ecx_5062;
				eax_701 = _IO_wpadn(gs, dwArg04, 0x20, esi_1263, out ecx_5062, out edx_5063, out ebx_5064, out ebp_1005, out esi_1263, out edi_1298);
				esp_1303 = (word32) esp_732 + 16;
			}
			else
			{
				Eq_2 esp_708 = <invalid>;
				word32 ecx_5059;
				word32 ebx_5061;
				word32 edx_5060;
				eax_701 = _IO_padn(gs, dwArg04, 0x20, esi_1263, out ecx_5059, out edx_5060, out ebx_5061, out ebp_1005, out esi_1263, out edi_1298);
				esp_1303 = (word32) esp_708 + 16;
			}
			if (eax_701 == esi_1263)
			{
				if (ebp_1005->tFFFFFEE0 != 0x00)
				{
					ebx_651 = esi_1263;
					if (ebp_1005->tFFFFFED8 != 0x00)
						goto l0807AF8A;
					goto l0807B445;
				}
				eax_1262 = esi_1263;
				edx_111 = (word32) ebp_1005->ptrFFFFFEDC->b000C;
l0807B46C:
				ebp_1005->tFFFFFEE0 = esi_1263;
				esi_1263 = eax_1262;
l0807B474:
				int8 al_1353;
				if (((byte) edx_111 & 0x40) != 0x00)
				{
					if (ebp_1005->tFFFFFED8 != 0x00)
					{
						Eq_2 eax_1357 = *((word32) edi_1298 + 88);
						if (eax_1357 != 0x00)
						{
							word32 * edx_1361 = *((word32) eax_1357 + 16);
							if (edx_1361 < *((word32) eax_1357 + 20))
							{
								*((word32) eax_1357 + 16) = edx_1361 + 1;
								*edx_1361 = 0x2B;
								goto l0807B4AE;
							}
						}
						esp_1303->tFFFFFFF4.u0 = 0x2B;
						goto l0807C216;
					}
					Eq_2 eax_1331 = *((word32) edi_1298 + 20);
					if (eax_1331 < *((word32) edi_1298 + 24))
					{
						*((word32) edi_1298 + 20) = (word32) eax_1331 + 1;
						*eax_1331 = 0x2B;
						goto l0807B4AE;
					}
					esp_1303->tFFFFFFF4.u0 = 0x2B;
				}
				else
				{
					if ((edx_111 & 0x10) == 0x00)
					{
l0807AFB6:
						if (ebp_1005->tFFFFFED8 != 0x00)
							goto l0807AFC4;
						goto l0807B4C3;
					}
					if (ebp_1005->tFFFFFED8 != 0x00)
					{
						Eq_2 eax_1312 = *((word32) edi_1298 + 88);
						if (eax_1312 != 0x00)
						{
							word32 * edx_1316 = *((word32) eax_1312 + 16);
							if (edx_1316 < *((word32) eax_1312 + 20))
							{
								*((word32) eax_1312 + 16) = edx_1316 + 1;
								*edx_1316 = 0x20;
								goto l0807B4AE;
							}
						}
						esp_1303->tFFFFFFF4.u0 = 0x20;
l0807C216:
						struct Eq_87797 * esp_1369 = esp_1303 - 0x0C;
						esp_1369->tFFFFFFFC = edi_1298;
						word32 ecx_5081;
						al_1353 = (int8) (__woverflow(esp_1369->tFFFFFFFC, esp_1369->t0000, out ecx_5081) == ~0x00);
						goto l0807C225;
					}
					Eq_2 eax_1300 = *((word32) edi_1298 + 20);
					if (eax_1300 < *((word32) edi_1298 + 24))
					{
						*((word32) edi_1298 + 20) = (word32) eax_1300 + 1;
						*eax_1300 = 0x20;
						goto l0807B4AE;
					}
					esp_1303->tFFFFFFF4.u0 = 0x20;
				}
				struct Eq_87842 * esp_1338 = esp_1303 - 0x0C;
				esp_1338->tFFFFFFFC = edi_1298;
				word32 edx_5083;
				word32 ecx_5082;
				al_1353 = (int8) (__overflow(esp_1338->tFFFFFFFC, esp_1338->t0000, out ecx_5082, out edx_5083) == ~0x00);
l0807C225:
				if (al_1353 != 0x00)
					goto l0807AEB8;
l0807B4AE:
				Eq_2 eax_1402 = ebp_1005->tFFFFFED8;
				ebp_1005->tFFFFFEE0 = (word32) ebp_1005->tFFFFFEE0 + 1;
				if (eax_1402 != 0x00)
				{
l0807AFC4:
					Eq_2 ebx_1410 = ebp_1005->tFFFFFEE0;
					Eq_2 ecx_1411 = ebp_1005->tFFFFFEC4;
					ebp_1005->tFFFFFEC8 = esi_1263;
					ebp_1005->tFFFFFED8 = (word32) ebx_1410 + 3;
					ebp_1005->tFFFFFEE0 = ecx_1411 - ebx_1410 * 0x04;
					do
					{
						int8 al_1468;
						Eq_2 ecx_1438 = *((word32) ebp_1005->tFFFFFEE0 + ebx_1410 * 0x04);
						Eq_2 eax_1440 = *((word32) edi_1298 + 88);
						if (eax_1440 != 0x00)
						{
							struct Eq_87425 * edx_1444 = *((word32) eax_1440 + 16);
							if (edx_1444 >= *((word32) eax_1440 + 20))
								goto l0807B940;
							*((word32) eax_1440 + 16) = (char *) &edx_1444->t0000 + 4;
							edx_1444->t0000 = ecx_1438;
							al_1468 = (int8) (ecx_1438 == ~0x00);
						}
						else
						{
l0807B940:
							struct Eq_87401 * esp_1449 = esp_1303 - 0x08;
							esp_1449->tFFFFFFFC = ecx_1438;
							esp_1449->tFFFFFFF8 = edi_1298;
							word32 ecx_5066;
							al_1468 = (int8) (__woverflow(esp_1449->tFFFFFFF8, esp_1449->tFFFFFFFC, out ecx_5066) == ~0x00);
						}
						if (al_1468 != 0x00)
							goto l0807AEB8;
						ebx_1410 = (word32) ebx_1410 + 1;
					} while (ebp_1005->tFFFFFED8 != ebx_1410);
					struct Eq_87292 * eax_1487 = ebp_1005->ptrFFFFFEDC;
					Eq_2 esi_1488 = ebp_1005->tFFFFFEC8;
					ebp_1005->tFFFFFEE0 = ebx_1410;
					if ((eax_1487->b000C & 0x20) != 0x00 && esi_1488 > 0x00)
					{
						esp_1303->tFFFFFFF8 = esi_1488;
						esp_1303->tFFFFFFF4.u0 = 0x20;
						esp_1303->tFFFFFFF0 = edi_1298;
						word32 edi_5070;
						word32 ecx_5067;
						word32 edx_5068;
						word32 ebx_5069;
						eax_1526 = _IO_wpadn(gs, esp_1303->tFFFFFFF0, esp_1303->tFFFFFFF4, esp_1303->tFFFFFFF8, out ecx_5067, out edx_5068, out ebx_5069, out ebp_1005, out esi_1532, out edi_5070);
						goto l0807B060;
					}
					goto l0807B06E;
				}
l0807B4C3:
				Eq_2 eax_1543 = ebp_1005->tFFFFFEE0;
				Eq_2 ebx_1544 = ebp_1005->tFFFFFEC8;
				ebp_1005->tFFFFFED8 = esi_1263;
				ebp_1005->tFFFFFEE4 = (word32) eax_1543 + 3;
				Eq_87376 ebx_1548 = ebx_1544 - eax_1543;
				Eq_2 esi_1550 = eax_1543;
				do
				{
					word32 edx_1555 = CONVERT(Mem1554[ebx_1548 + esi_1550:byte], byte, word32);
					byte dl_1580 = (byte) edx_1555;
					Eq_2 eax_1557 = *((word32) edi_1298 + 20);
					if (eax_1557 < *((word32) edi_1298 + 24))
					{
						*((word32) edi_1298 + 20) = (word32) eax_1557 + 1;
						*eax_1557 = dl_1580;
					}
					else
					{
						struct Eq_87543 * esp_1561 = esp_1303 - 0x08;
						esp_1561->tFFFFFFFC = edx_1555;
						esp_1561->tFFFFFFF8 = edi_1298;
						word32 edx_5074;
						word32 ecx_5073;
						if (__overflow(esp_1561->tFFFFFFF8, esp_1561->tFFFFFFFC, out ecx_5073, out edx_5074) == ~0x00)
							goto l0807AEB8;
					}
					esi_1550 = (word32) esi_1550 + 1;
				} while (ebp_1005->tFFFFFEE4 != esi_1550);
				struct Eq_87292 * eax_1589 = ebp_1005->ptrFFFFFEDC;
				ebp_1005->tFFFFFEE0 = esi_1550;
				Eq_2 esi_1591 = ebp_1005->tFFFFFED8;
				if ((eax_1589->b000C & 0x20) != 0x00 && esi_1591 > 0x00)
				{
					esp_1303->tFFFFFFF8 = esi_1591;
					esp_1303->tFFFFFFF4.u0 = 0x20;
					esp_1303->tFFFFFFF0 = edi_1298;
					word32 edi_5078;
					word32 ebx_5077;
					word32 ecx_5075;
					word32 edx_5076;
					eax_1526 = _IO_padn(gs, esp_1303->tFFFFFFF0, esp_1303->tFFFFFFF4, esp_1303->tFFFFFFF8, out ecx_5075, out edx_5076, out ebx_5077, out ebp_1005, out esi_1532, out edi_5078);
l0807B060:
					if (eax_1526 == esi_1532)
					{
						Mem1632[ebp_1005 + -288:word32] = Mem1630[ebp_1005 + -288:word32] + eax_1526;
						goto l0807B06E;
					}
					goto l0807AEB8;
				}
				goto l0807B06E;
			}
l0807AEB8:
			ebp_1005->tFFFFFEE0.u0 = ~0x00;
			goto l0807B06E;
		}
		if ((gs->ptrFFFFFFF8[esi_108].b0001 & 0x01) == 0x00)
			goto l0807AF0C;
	}
	goto l0807AF0C;
}

// 0807C4E0: void register_printf_modifier(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __printf_fphex
void register_printf_modifier(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_113 = dwArg04;
	if (*dwArg04 <= 0xFF)
	{
		Eq_2 esi_110 = dwArg04;
		do
		{
			esi_110 = (word32) esi_110 + 4;
			Eq_2 eax_28 = *esi_110;
			if (eax_28 == 0x00)
			{
				if (next_bit <= 0x17)
				{
					gs->tFFFFFFE0.u0 = 0x1C;
					return;
				}
				if (gs->t000C != 0x00)
					__lock();
				word32 eax_68;
				if (!__cmpxchg(lock, 0x01, eax_28, out eax_68))
					__lll_lock_wait_private(eax_68, 0x080CFA28, gs);
				Eq_2 edx_141;
				Eq_2 ecx_128;
				struct Eq_90915 * ebx_127;
				if (__printf_modifier_table == 0x00)
				{
					word32 ebp_315;
					word32 edx_314;
					Eq_2 eax_93 = __libc_calloc(gs, 0xFF, 0x04, out ecx_128, out edx_314, out ebx_127, out ebp_315, out esi_110, out edi_113);
					ebx_127->t1FD8 = eax_93;
					if (eax_93 == 0x00)
					{
l0807C640:
						edx_141.u0 = ~0x00;
l0807C5D1:
						if (gs->t000C != 0x00)
							__lock();
						word32 v17_188 = ebx_127->dw1A28 - 0x01;
						ebx_127->dw1A28 = v17_188;
						if (v17_188 != 0x00)
							__lll_unlock_wake_private(&ebx_127->dw1A28, ecx_128, edx_141, gs);
						return;
					}
				}
				byte * edi_129;
				int32 esi_131;
				word32 edx_316;
				word32 ebp_317;
				Eq_2 eax_125 = __libc_malloc(gs, dwLoc30, esi_110 - edi_113 + 0x08, out ecx_128, out edx_316, out ebx_127, out ebp_317, out esi_131, out edi_129);
				if (eax_125 == 0x00)
					goto l0807C640;
				word32 ecx_146 = ebx_127->dw1A24;
				*eax_125 = *((word32) ebx_127->t1FD8 + (word32) (*edi_129) * 0x04);
				ebx_127->dw1A24 = ecx_146 + 0x01;
				*((word32) eax_125 + 4) = 0x01 << (byte) ecx_146;
				word32 edx_318;
				ecx_128 = __wmemcpy((word32) eax_125 + 8, edi_129 + 4, esi_131 >> 0x02, out edx_318);
				*((word32) ebx_127->t1FD8 + (word32) (*edi_129) * 0x04) = eax_125;
				edx_141 = *((word32) eax_125 + 4);
				goto l0807C5D1;
			}
		} while (eax_28 <= 0xFF);
	}
	gs->tFFFFFFE0.u0 = 22;
}

// 0807C660: Register word32 __handle_registered_modifier_mb(Stack (ptr32 (ptr32 Eq_91036)) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __parse_one_specmb
word32 __handle_registered_modifier_mb(struct Eq_91036 ** dwArg04, Eq_2 dwArg08)
{
	struct Eq_91036 * ebx_21 = *dwArg04;
	struct Eq_91040 * esi_24 = *((word32) __printf_modifier_table + (word32) ebx_21->b0000 * 0x04);
	if (esi_24 == null)
		return 0x01;
	word32 edi_39 = (word32) ebx_21[1];
	struct Eq_91036 * dwLoc14_162 = null;
	int32 dwLoc20_163 = 0x00;
	byte al_45 = (byte) edi_39;
	word32 dwLoc18_164 = 0x00;
	struct Eq_91040 * esi_112 = esi_24;
	do
	{
		struct Eq_91036 * ecx_106;
		int32 eax_61;
		word32 * ebx_52 = &esi_112->dw0008;
		word32 edx_53 = esi_112->dw0008;
		if (al_45 != 0x00)
		{
			if (edx_53 != 0x00)
			{
				if (edx_53 == edi_39)
				{
					ecx_106 = ebx_21 + 1;
					do
					{
						++ecx_106;
						++ebx_52;
						word32 eax_69 = (word32) ecx_106->b0000;
						edx_53 = *ebx_52;
						if ((byte) eax_69 == 0x00)
							goto l0807C6F7;
						if (edx_53 == 0x00)
							goto l0807C6FB;
					} while (eax_69 == edx_53);
				}
				goto l0807C716;
			}
			ecx_106 = ebx_21 + 1;
			eax_61 = 0x01;
			goto l0807C701;
		}
		ecx_106 = ebx_21 + 1;
l0807C6F7:
		if (edx_53 == 0x00)
		{
l0807C6FB:
			eax_61 = ecx_106 - ebx_21;
l0807C701:
			if (eax_61 > dwLoc20_163)
			{
				dwLoc14_162 = ecx_106;
				dwLoc20_163 = eax_61;
				dwLoc18_164 = esi_112->dw0004;
			}
		}
l0807C716:
		cui16 wLoc18_192 = (word16) dwLoc18_164;
		esi_112 = esi_112->ptr0000;
	} while (esi_112 != null);
	word32 eax_118 = 0x01;
	if (dwLoc18_164 != 0x00)
	{
		*((word32) dwArg08 + 0x0E) |= wLoc18_192;
		*dwArg04 = (struct Eq_91036 **) dwLoc14_162;
		eax_118 = 0x00;
	}
	return eax_118;
}

// 0807C770: Register word32 __handle_registered_modifier_wc(Stack (ptr32 (ptr32 Eq_91136)) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __parse_one_specwc
word32 __handle_registered_modifier_wc(struct Eq_91136 ** dwArg04, Eq_2 dwArg08)
{
	struct Eq_91136 * ebp_21 = *dwArg04;
	struct Eq_91140 * esi_23 = *((word32) __printf_modifier_table + ebp_21->dw0000 * 0x04);
	if (esi_23 == null)
		return 0x01;
	struct Eq_91136 * dwLoc14_160 = null;
	word32 edi_40 = ebp_21[1];
	int32 dwLoc20_161 = 0x00;
	word32 dwLoc18_162 = 0x00;
	struct Eq_91140 * esi_111 = esi_23;
	do
	{
		struct Eq_91136 * edx_105;
		int32 eax_60;
		word32 * ecx_47 = &esi_111->dw0008;
		word32 eax_49 = esi_111->dw0008;
		if (edi_40 != 0x00)
		{
			if (eax_49 != 0x00)
			{
				if (edi_40 == eax_49)
				{
					edx_105 = ebp_21 + 1;
					do
					{
						++edx_105;
						++ecx_47;
						word32 ebx_67 = edx_105->dw0000;
						eax_49 = *ecx_47;
						if (ebx_67 == 0x00)
							goto l0807C7F6;
						if (eax_49 == 0x00)
							goto l0807C7FA;
					} while (eax_49 == ebx_67);
				}
				goto l0807C816;
			}
			edx_105 = ebp_21 + 1;
			eax_60 = 0x01;
			goto l0807C803;
		}
		edx_105 = ebp_21 + 1;
l0807C7F6:
		if (eax_49 == 0x00)
		{
l0807C7FA:
			eax_60 = edx_105 - ebp_21 >> 0x02;
l0807C803:
			if (dwLoc20_161 < eax_60)
			{
				dwLoc14_160 = edx_105;
				dwLoc20_161 = eax_60;
				dwLoc18_162 = esi_111->dw0004;
			}
		}
l0807C816:
		cui16 wLoc18_189 = (word16) dwLoc18_162;
		esi_111 = esi_111->ptr0000;
	} while (esi_111 != null);
	word32 eax_117 = 0x01;
	if (dwLoc18_162 != 0x00)
	{
		*((word32) dwArg08 + 0x0E) |= wLoc18_189;
		*dwArg04 = (struct Eq_91136 **) dwLoc14_160;
		eax_117 = 0x00;
	}
	return eax_117;
}

// 0807C870: void register_printf_type(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void register_printf_type(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ecx_24 = 0x01;
	struct Eq_91233 * ebx_10 = &g_t80CE000;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_19;
	if (!__cmpxchg(lock, 0x01, 0x00, out eax_19))
		ecx_24 = __lll_lock_wait_private(eax_19, 0x080CFA2C, gs);
	Eq_2 edx_61;
	if (__printf_va_arg_table == 0x00)
	{
		word32 edx_161;
		word32 ebp_162;
		word32 esi_163;
		word32 edi_164;
		Eq_2 eax_44 = __libc_calloc(gs, 0xF8, 0x04, out ecx_24, out edx_161, out ebx_10, out ebp_162, out esi_163, out edi_164);
		ebx_10->t1FEC = eax_44;
		if (eax_44 == 0x00)
		{
			edx_61.u0 = ~0x00;
			goto l0807C8D8;
		}
	}
	edx_61 = ebx_10->t0ED8;
	if (edx_61 != 0x0100)
	{
		ebx_10->t0ED8 = (word64) edx_61.u0 + 1;
		(ebx_10->t1FEC - 0x20)[edx_61] = dwArg04;
		ecx_24 = dwArg04;
	}
	else
	{
		gs->tFFFFFFE0.u0 = 0x1C;
		edx_61.u0 = ~0x00;
	}
l0807C8D8:
	if (gs->t000C != 0x00)
		__lock();
	word32 v12_86 = ebx_10->dw1A2C - 0x01;
	ebx_10->dw1A2C = v12_86;
	if (v12_86 != 0x00)
		__lll_unlock_wake_private(&ebx_10->dw1A2C, ecx_24, edx_61, gs);
}

// 0807C940: Register word32 __fprintf(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 ebxOut, Register out ptr32 ediOut)
// Called from:
//      __malloc_stats
//      malloc_info
word32 __fprintf(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & ebxOut, ptr32 & ediOut)
{
	word32 ecx_20;
	ptr32 edi_21;
	ptr32 ebx_23;
	word32 edx_41;
	word32 ebp_42;
	vfprintf(ebx, gs, dwArg04, dwArg08, fp + 0x0C, out ecx_20, out edx_41, out ebx_23, out ebp_42, out edi_21);
	ebxOut = ebx_23;
	ediOut = edi_21;
	return ecx_20;
}

// 0807C960: void read_int(Register (ptr32 (ptr32 Eq_91338)) eax)
void read_int(struct Eq_91338 ** eax)
{
	struct Eq_91338 * ecx_17 = *eax;
	up32 esi_20 = ecx_17->dw0004;
	struct Eq_91338 * ecx_19 = &ecx_17->dw0004;
	struct Eq_91338 * ebx_21 = &ecx_17->dw0004;
	int32 esi_22 = esi_20 - 0x30;
	int32 edx_23 = ecx_17->dw0000 - 0x30;
	if (esi_20 <= 0x39)
	{
		do
		{
			if (edx_23 >= 0x00)
			{
				if (edx_23 <= 0x0CCCCCCC)
				{
					ui32 edx_33 = edx_23 * 0x05;
					if (0x7FFFFFFF - esi_22 < edx_33 * 0x02)
						goto l0807C9B8;
					edx_23 = edx_33 * 0x02 + esi_22;
				}
				else
				{
l0807C9B8:
					struct Eq_91338 * ebx_43 = &ebx_21->dw0004;
					if (ebx_43->dw0000 > 0x39)
					{
						*eax = (struct Eq_91338 **) ebx_43;
						return;
					}
					++ecx_19;
					edx_23 = ~0x00;
					if (ecx_19->dw0000 > 0x39)
					{
						*eax = (struct Eq_91338 **) ecx_19;
						return;
					}
				}
			}
			ecx_19 = (struct Eq_91338 *) &ecx_19->dw0004;
			up32 esi_89 = ecx_19->dw0000;
			ebx_21 = ecx_19;
			esi_22 = esi_89 - 0x30;
		} while (esi_89 <= 0x39);
	}
	*eax = (struct Eq_91338 **) ebx_21;
}

// 0807CA00: void group_number(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack (ptr32 byte) dwArg04, Stack word32 dwArg08)
void group_number(Eq_2 eax, Eq_2 ecx, Eq_2 edx, byte * dwArg04, word32 dwArg08)
{
	int32 ebx_22 = (int32) *dwArg04;
	Eq_2 edi_120 = ecx;
	if ((byte) (ebx_22 - 0x01) > 0x7D)
		return;
	Eq_2 esi_32 = ecx - edx;
	word32 edx_233;
	memmove(eax, edx, esi_32, out edx_233);
	word32 esi_35 = esi_32 + eax;
	struct Eq_91434 * ecx_121 = dwArg04 + 1;
	if (eax >= esi_35)
		return;
	*((word32) ecx - 4) = *((word32) esi_35 - 4);
	Eq_2 esi_124 = esi_35 - 0x04;
	Eq_2 edx_130 = ecx - 0x04;
	int32 ebx_119 = ebx_22 - 0x01;
	if (ebx_22 == 0x01)
	{
		esi_124 = esi_35 - 0x04;
		do
		{
			if (eax >= esi_124)
				return;
			if (esi_124 == edx_130)
			{
l0807CAB0:
				word32 edx_234;
				memmove(edx_130, esi_124, eax - esi_124, out edx_234);
				return;
			}
			*((word32) edi_120 - 8) = dwArg08;
			ebx_119 = (int32) ecx_121->b0000;
			edx_130 = edi_120 - 0x08;
			ci8 bl_77 = (byte) ebx_119;
			if (bl_77 == 0x7F || bl_77 < 0x00)
				goto l0807CAB0;
			if (bl_77 != 0x00)
			{
				++ecx_121;
				edi_120 = edx_130;
			}
			else
			{
				ebx_119 = (int32) ecx_121->bFFFFFFFF;
				edi_120 = edx_130;
			}
l0807CA88:
			esi_124 -= (word32 *) 0x04;
			*((word32) edi_120 - 4) = *esi_124;
			edx_130 = edi_120 - 0x04;
			--ebx_119;
		} while (ebx_119 == 0x00);
	}
	if (eax >= esi_124)
		return;
	edi_120 = edx_130;
	goto l0807CA88;
}

// 0807CAE0: void _i18n_number_rewrite(Register Eq_2 eax, Register (ptr32 word32) ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
void _i18n_number_rewrite(Eq_2 eax, word32 * ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	__align(fp - 4);
	ui32 eax_35 = gs->dw0014;
	struct Eq_74687 * eax_43 = wctrans(gs, 0x080B1CCC);
	Eq_2 eax_59 = __towctrans(0x2E, eax_43);
	Eq_2 eax_76 = __towctrans(44, eax_43);
	Eq_2 edx_88 = edx - eax;
	word32 ecx_441;
	word32 edx_442;
	if ((byte) (uint32) __libc_scratch_buffer_set_array_size(gs, fp - 0x0444, edx_88 >> 0x02, 0x04, out ecx_441, out edx_442) != 0x00)
	{
		word32 edx_443;
		Eq_2 eax_125 = __mempcpy(fp - 0x0434, eax, edx_88, out edx_443);
		word32 * esi_137 = ecx;
		struct Eq_3487 * ebx_138 = gs->ptrFFFFFFD0;
l0807CBF5:
		for (eax_125 -= 0x04; fp - 0x0434 <= eax_125; eax_125 -= 0x04)
		{
			uint32 edx_147 = *eax_125;
			esi_137 -= 0x04;
			if (edx_147 <= 0x39)
			{
				*esi_137 = (word32) *((word32) ebx_138->t0000 + (edx_147 * 0x04 + 48));
				goto l0807CBF5;
			}
			if (eax_43 == null || (edx_147 & ~0x02) != 44)
				*esi_137 = edx_147;
			else
			{
				Eq_2 edx_167 = eax_59;
				if (edx_147 != 0x2E)
					edx_167 = eax_76;
				*esi_137 = (word32) edx_167;
			}
		}
		if (fp - 0x0434 != fp - 0x0434)
		{
			word32 ecx_446;
			word32 edx_447;
			free(gs, dwLoc0478, fp - 0x0434, out ecx_446, out edx_447);
		}
	}
	if ((eax_35 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_444;
	word32 edx_445;
	__stack_chk_fail(out ecx_444, out edx_445);
	_IO_helper_overflow(dwArg04, dwArg08);
}

// 0807CC80: void _IO_helper_overflow(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _i18n_number_rewrite
void _IO_helper_overflow(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 edx_100 = *((word32) dwArg04 + 88);
	Eq_2 esp_18 = fp - 44;
	Eq_2 esi_22 = *((word32) edx_100 + 16);
	Eq_2 ebx_106 = *((word32) edx_100 + 0x0C);
	if (esi_22 != ebx_106)
	{
		Eq_2 edx_26 = *((word32) dwArg04 + 332);
		Eq_2 eax_36 = ebx_106;
		if (*((word32) edx_26 + 0x0094) >= 135066356)
		{
			word32 edx_207;
			word32 ecx_206;
			_IO_vtable_check(out ecx_206, out edx_207);
			esp_18.u0 = <invalid>;
			edx_26 = *((word64) esp_18.u0 + 0x0C);
			eax_36 = *((word32) *((word32) dwArg04 + 88) + 0x0C);
		}
		int32 esi_52 = esi_22 - ebx_106;
		struct Eq_91671 * esp_54 = esp_18 - 0x04;
		esp_54->dwFFFFFFFC = esi_52 >> 0x02;
		esp_54->tFFFFFFF8 = eax_36;
		esp_54->tFFFFFFF4 = edx_26;
		struct Eq_91685 * eax_65 = esp_54->ptr000C;
		Eq_91689 eax_69;
		word32 ecx_71;
		eax_65->ptr001C();
		if (eax_69 > ~0x01)
			return;
		Eq_2 edx_83 = *((word32) *((word32) dwArg04 + 88) + 0x0C);
		esp_54->dwFFFFFFFC = (esi_52 >> 0x02) - eax_69;
		esp_54->tFFFFFFF8 = (word32) edx_83 + eax_69 * 0x04;
		esp_54->tFFFFFFF4 = edx_83;
		wmemmove(esp_54->tFFFFFFF4, esp_54->tFFFFFFF8, esp_54->dwFFFFFFFC);
		edx_100 = *((word32) dwArg04 + 88);
		Eq_2 eax_103 = *((word32) edx_100 + 16) - eax_69 * 0x04;
		*((word32) edx_100 + 16) = eax_103;
		ebx_106 = eax_103;
	}
	if (*((word32) edx_100 + 20) <= ebx_106)
	{
		word32 ecx_208;
		__woverflow(dwArg04, dwArg08, out ecx_208);
	}
	else
	{
		*((word32) edx_100 + 16) = (word32) ebx_106 + 4;
		*ebx_106 = dwArg08;
	}
}

// 0807CD80: Register Eq_2 printf_positional(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __vfwprintf
Eq_2 printf_positional(struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	__align(fp - 4);
	struct Eq_91770 * ebp_106 = fp - 0x0C;
	Eq_2 esp_1019 = fp - 2388;
	if (dwArg20 == ~0x00)
	{
		byte al_72 = **((char *) *gs->ptrFFFFFFDC + 44);
		if (al_72 == 0x00 || al_72 == 0x7F)
			;
	}
	Eq_2 edx_1187;
	Eq_2 ecx_1016;
	ptr32 esp_1052;
	Eq_2 esi_1047;
	ptr32 esp_1032;
	Eq_2 esi_1027;
	Eq_2 esi_1119;
	Eq_2 ecx_1422;
	Eq_2 esi_1196;
	Eq_2 edi_104 = *dwArg14;
	if (edi_104 != 0x00)
	{
		edi_104.u0 = 0x00;
		Eq_2 ebx_118 = 0x00;
		Eq_2 esi_103 = dwArg14;
		do
		{
l0807CE98:
			Eq_2 edx_108 = (word32) ebp_106->tFFFFF770 + edi_104 *s 0x34;
			struct Eq_91826 * esp_111 = esp_1019 - 4;
			esp_111->t0000 = ebp_106->tFFFFF768;
			esp_111->tFFFFFFFC = edx_108;
			esp_111->tFFFFFFF8 = ebx_118;
			esp_111->tFFFFFFF4 = esi_103;
			ebp_106->tFFFFF774 = edx_108;
			word32 ebx_126;
			word32 eax_124 = __parse_one_specwc(esp_111->tFFFFFFF4, esp_111->tFFFFFFF8, esp_111->tFFFFFFFC, esp_111->t0000, out ebx_126, out ebp_106, out edi_104);
			Eq_2 esp_131 = <invalid>;
			esi_103 = *((word32) ebp_106->tFFFFF774 + 24);
			esp_1019 = (word32) esp_131 + 16;
			ebx_118 = ebx_126 + eax_124;
			if (*esi_103 == 0x00)
			{
				if (ebp_106->tFFFFF77C >= ebx_118)
					ebx_118 = ebp_106->tFFFFF77C;
				ebp_106->tFFFFF774 = ebx_118;
				goto l0807CF23;
			}
		} while (ebp_106->tFFFFF76C != edi_104);
		*esp_131 = ebp_106->tFFFFF758;
		esp_1019 = (word32) esp_131 + 16;
		if ((byte) __libc_scratch_buffer_grow_preserve(gs, dwArg00, out ecx_1016, out edx_1187) != 0x00)
		{
			ebp_106->tFFFFF770 = ebp_106->tFFFFF7B8;
			ebp_106->tFFFFF76C = SLICE(ebp_106->dwFFFFF7BC *64 0x4EC4EC4F, word32, 32) >> 0x04;
			goto l0807CE98;
		}
l0807D5D8:
		do
		{
l0807D5D8:
			esi_1196.u0 = ~0x00;
l0807D5DD:
			Eq_2 eax_623 = ebp_106->tFFFFFBC8;
			if (eax_623 != ebp_106->tFFFFF744)
			{
				*((word32) esp_1019 - 16) = eax_623;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				free(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187);
			}
			Eq_2 eax_646 = ebp_106->tFFFFF7B8;
			if (eax_646 != ebp_106->tFFFFF750)
			{
				*((word32) esp_1019 - 16) = eax_646;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				free(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187);
			}
			esi_1119 = ebp_106->dwFFFFFFE4 ^ gs->dw0014;
			if (esi_1119 == 0x00)
			{
				ecxOut = ecx_1016;
				edxOut = edx_1187;
				return esi_1196;
			}
			Eq_2 ecx_686;
			word32 edx_4288;
			__stack_chk_fail(out ecx_686, out edx_4288);
			if (ecx_686 > 0x00)
			{
				ebp_106->tFFFFF774 = ecx_686;
				struct Eq_94297 * esp_691 = esp_1019 - 0x04;
				esp_691->tFFFFFFFC = ecx_686;
				esp_691->dwFFFFFFF8 = 0x20;
				esp_691->tFFFFFFF4 = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				word32 ecx_4290;
				word32 ebp_4293;
				word32 ebx_4292;
				word32 edx_4291;
				word32 edi_4295;
				word32 esi_4294;
				Eq_2 eax_702 = _IO_wpadn(gs, dwArg00, stackArg8, dwArg08, out ecx_4290, out edx_4291, out ebx_4292, out ebp_4293, out esi_4294, out edi_4295);
				ecx_1016 = ebp_106->tFFFFF774;
				esp_1019 = (char *) &esp_691->tFFFFFFFC + 8;
				if (ecx_1016 != eax_702)
					goto l0807D5B3;
				if (ebp_106->tFFFFF75C > 0x7FFFFFFE)
				{
l0807F6CF:
					esi_1027 = ebp_106->tFFFFF764;
					struct Eq_94525 * esp_1030 = esp_1019 - 4;
					esp_1030->ptr0000 = (word32) esi_1027 - 0x0001C23C;
					esp_1030->dwFFFFFFFC = 0x07E1;
					esp_1032 = esp_1030 - 4;
					goto l0807F6E1;
				}
				Eq_2 ebx_712 = ebp_106->tFFFFF75C;
				if (0x7FFFFFFF - ebx_712 < ecx_1016)
					goto l0807D5A0;
				Mem721[ebp_106 + ~0x08A3:word32] = ebx_712 + ecx_1016;
			}
			ecx_1016.u0 = 0x00;
			if (ebp_106->tFFFFF768 != 0x00)
			{
				struct Eq_93235 * eax_780 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_780 != null)
				{
					Eq_2 edx_784 = eax_780->t0010;
					if (edx_784 >= eax_780->t0014)
						goto l0807F218;
					eax_780->t0010 = (word32) edx_784 + 4;
					edx_784->u0 = 0x2D;
					goto l0807DF7A;
				}
l0807F218:
				ebp_106->tFFFFF774.u0 = 0x00;
				*((word32) esp_1019 - 0x0C) = 0x2D;
				goto l0807F223;
			}
			if (ebp_106->tFFFFF734 != 0x00)
			{
				struct Eq_93235 * eax_761 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_761 != null)
				{
					Eq_2 edx_765 = eax_761->t0010;
					if (edx_765 >= eax_761->t0014)
						goto l0807F483;
					eax_761->t0010 = (word32) edx_765 + 4;
					*edx_765 = 0x2B;
					goto l0807DF7A;
				}
l0807F483:
				ebp_106->tFFFFF774.u0 = 0x00;
				*((word32) esp_1019 - 0x0C) = 0x2B;
				goto l0807F223;
			}
			if (ebp_106->dwFFFFF72C != 0x00)
			{
				struct Eq_93235 * eax_740 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_740 != null)
				{
					Eq_2 edx_744 = eax_740->t0010;
					if (edx_744 >= eax_740->t0014)
						goto l0807F698;
					eax_740->t0010 = (word32) edx_744 + 4;
					*edx_744 = 0x20;
					goto l0807DF7A;
				}
l0807F698:
				ebp_106->tFFFFF774.u0 = 0x00;
				*((word32) esp_1019 - 0x0C) = 0x20;
l0807F223:
				struct Eq_94594 * esp_798 = esp_1019 - 0x0C;
				esp_798->tFFFFFFFC = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				word32 ecx_4301;
				word32 eax_836 = __woverflow(dwArg00, stackArg8, out ecx_4301);
				esp_1019 = (char *) &esp_798->tFFFFFFFC + 16;
				ecx_1016 = ebp_106->tFFFFF774;
				if (eax_836 == ~0x00)
					goto l0807D5B3;
l0807DF7A:
				Eq_2 eax_849 = ebp_106->tFFFFF75C;
				if (eax_849 == 0x7FFFFFFF)
					goto l0807D5B3;
				ebp_106->tFFFFF75C = (word32) eax_849 + 1;
			}
			if (ebp_106->dwFFFFF704 != 0x00 && (ebp_106->dwFFFFF718 == 0x10 && ebp_106->dwFFFFF724 != 0x00))
			{
				Eq_2 edx_925;
				struct Eq_93235 * eax_868 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_868 == null)
				{
l0807F520:
					ebp_106->tFFFFF774 = ecx_1016;
					struct Eq_94412 * esp_880 = esp_1019 - 0x08;
					esp_880->dwFFFFFFFC = 0x30;
					esp_880->tFFFFFFF8 = ebp_106->tFFFFF760;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					word32 ecx_4297;
					word32 eax_909 = __woverflow(dwArg00, stackArg8, out ecx_4297);
					esp_1019 = &esp_880->dwFFFFFFFC + 3;
					ecx_1016 = ebp_106->tFFFFF774;
					if (eax_909 == ~0x00 || ebp_106->tFFFFF75C == 0x7FFFFFFF)
						goto l0807D5B3;
					eax_868 = (struct Eq_93235 *) *((word32) ebp_106->tFFFFF760 + 88);
					if (eax_868 != null)
					{
						edx_925 = eax_868->t0010;
						ebp_106->tFFFFF774 = eax_868->t0014;
l0807DFF6:
						if (ebp_106->tFFFFF774 <= edx_925)
							goto l0807F4E8;
						eax_868->t0010 = (word32) edx_925 + 4;
						*edx_925 = ebp_106->tFFFFF770;
						goto l0807E010;
					}
l0807F4E8:
					struct Eq_94469 * esp_939 = esp_1019 - 0x08;
					esp_939->tFFFFFFFC = ebp_106->tFFFFF770;
					esp_939->tFFFFFFF8 = ebp_106->tFFFFF760;
					ebp_106->tFFFFF774 = ecx_1016;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					word32 ecx_4299;
					word32 eax_965 = __woverflow(dwArg00, stackArg8, out ecx_4299);
					esp_1019 = (char *) &esp_939->tFFFFFFFC + 0x0C;
					ecx_1016 = ebp_106->tFFFFF774;
					if (eax_965 == ~0x00)
						goto l0807D5B3;
l0807E010:
					Eq_2 eax_979 = ebp_106->tFFFFF75C;
					if (eax_979 == 0x7FFFFFFE)
						goto l0807D5B3;
					ebp_106->tFFFFF75C = (word32) eax_979 + 2;
					goto l0807E02A;
				}
				Eq_2 edx_872 = eax_868->t0014;
				Eq_2 ebx_873 = eax_868->t0010;
				ebp_106->tFFFFF774 = edx_872;
				if (ebx_873 >= edx_872)
					goto l0807F520;
				eax_868->t0010 = (word32) ebx_873 + 4;
				*ebx_873 = 0x30;
				edx_925 = (word32) ebx_873 + 4;
				if (ebp_106->tFFFFF75C != 0x7FFFFFFF)
					goto l0807DFF6;
l0807D5B3:
				edx_1187 = ebp_106->tFFFFF76C;
				if (edx_1187 != 0x00)
				{
					struct Eq_93459 * esp_2669 = esp_1019 - 0x0C;
					esp_2669->tFFFFFFFC = ebp_106->tFFFFF76C;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					free(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187);
					esp_1019 = (char *) &esp_2669->tFFFFFFFC + 16;
				}
				goto l0807D5D8;
			}
l0807E02A:
			edi_104 += ecx_1016;
			if (edi_104 > 0x00)
			{
				*((word32) esp_1019 - 8) = edi_104;
				*((word32) esp_1019 - 0x0C) = 0x30;
				*((word32) esp_1019 - 16) = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				word32 ebp_4305;
				word32 esi_4306;
				word32 edi_4307;
				word32 edx_4303;
				word32 ebx_4304;
				if (edi_104 != _IO_wpadn(gs, dwArg00, stackArg8, dwArg08, out ecx_1016, out edx_4303, out ebx_4304, out ebp_4305, out esi_4306, out edi_4307))
					goto l0807D5B3;
				Eq_2 ebx_1022 = ebp_106->tFFFFF75C;
				if (ebx_1022 > 0x7FFFFFFE)
					goto l0807F6CF;
				if (0x7FFFFFFF - ebx_1022 < edi_104)
					goto l0807D5A0;
				Mem1040[ebp_106 + ~0x08A3:word32] = ebx_1022 + edi_104;
			}
			Eq_2 edx_1043 = ebp_106->tFFFFF75C;
			if (edx_1043 < 0x00)
			{
				esi_1047 = ebp_106->tFFFFF764;
				*((word32) esp_1019 - 4) = (word32) esi_1047 - 0x0001C23C;
				*((word32) esp_1019 - 8) = 0x07E1;
				esp_1052 = esp_1019 - 8;
l0807F706:
				struct Eq_93094 * esp_2618 = esp_1052 - 4;
				esp_2618->ptr0000 = (word32) esi_1047 - 0x0001C322;
				esp_2618->ptrFFFFFFFC = (word32) esi_1047 - 0x0001C28C;
				word32 edx_4275;
				word32 ecx_4274;
				__assert_fail(out ecx_4274, out edx_4275);
				esp_1019 = esp_2618 - 4;
				goto l0807F719;
			}
			Eq_2 ebx_1055 = *((word32) ebp_106->tFFFFF760 + 0x0094);
			Eq_2 eax_1057 = ebx_1055 - ebp_106->dwFFFFF6E0;
			if (ebp_106->tFFFFF6DC <= eax_1057)
				eax_1057 = _IO_vtable_check(out ecx_1016, out edx_1043);
			edi_104 = ebp_106->tFFFFF74C;
			*((word32) esp_1019 - 8) = edi_104;
			*((word32) esp_1019 - 0x0C) = ebp_106->dwFFFFF710;
			*((word32) esp_1019 - 16) = ebp_106->tFFFFF760;
			Eq_2 eax_1090;
			(*((word32) ebx_1055 + 28))();
			if (edi_104 != eax_1090)
				goto l0807D5B3;
			ecx_1016 = ebp_106->tFFFFF75C;
			if (edi_104 > 0x7FFFFFFF - ecx_1016)
				goto l0807D5A0;
			Mem1104[ebp_106 + ~0x08A3:word32] = ecx_1016 + edi_104;
l0807DBD9:
			if (ebp_106->tFFFFF76C != 0x00)
			{
				*((word32) esp_1019 - 16) = ebp_106->tFFFFF76C;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 ecx_4269;
				word32 edx_4270;
				free(gs, stackArg0, dwArg00, out ecx_4269, out edx_4270);
			}
			Eq_2 ecx_1133 = ebp_106->tFFFFF75C;
			if (ecx_1133 < 0x00)
			{
				esi_1047 = ebp_106->tFFFFF764;
				struct Eq_92818 * esp_1140 = esp_1019 - 4;
				esp_1140->ptr0000 = (word32) esi_1047 - 0x0001C23C;
				esp_1140->dwFFFFFFFC = 0x0809;
				esp_1052 = esp_1140 - 4;
				goto l0807F706;
			}
			Eq_2 ebx_1145 = *((word32) ebp_106->tFFFFF760 + 0x0094);
			if (ebp_106->dwFFFFF708 <= ebx_1145 - ebp_106->dwFFFFF70C)
			{
				word32 edx_4271;
				_IO_vtable_check(out ecx_1133, out edx_4271);
			}
			word32 edx_1161 = *((word32) esi_1119 + 20);
			struct Eq_92856 * esp_1164 = esp_1019 - 0x04;
			int32 eax_1165 = *((word32) esi_1119 + 24) - edx_1161;
			esp_1164->dwFFFFFFFC = eax_1165 >> 0x02;
			esp_1164->dwFFFFFFF8 = edx_1161;
			esp_1164->tFFFFFFF4 = ebp_106->tFFFFF760;
			int32 eax_1181;
			(*((word32) ebx_1145 + 28))();
			int32 edx_1186 = *((word32) esi_1119 + 24) - *((word32) esi_1119 + 20);
			edx_1187 = edx_1186 >> 0x02;
			esp_1019 = &esp_1164->dwFFFFFFFC + 2;
		} while (edx_1186 >> 0x02 != eax_1181);
		if (edx_1186 >> 0x02 <= 0x7FFFFFFF - ebp_106->tFFFFF75C)
		{
			ebp_106->tFFFFF754 = (word32) ebp_106->tFFFFF754 + 1;
			Eq_2 eax_1202 = ebp_106->tFFFFF754;
			ebp_106->tFFFFF75C = (word32) ebp_106->tFFFFF75C + (edx_1186 >> 0x02);
			esi_1119 = (word32) esi_1119 + 52;
			if (eax_1202 >= ebp_106->tFFFFF6FC)
				goto l0807DC77;
			goto l0807D1AE;
		}
		gs->tFFFFFFE0.u0 = 0x4B;
		esi_1196.u0 = ~0x00;
		goto l0807D5DD;
	}
l0807CF23:
	Eq_2 esi_152 = ebp_106->tFFFFF774;
	struct Eq_91973 * esp_157 = esp_1019 - 0x04;
	esp_157->tFFFFFFFC.u0 = 0x14;
	esp_157->tFFFFFFF8 = esi_152;
	esp_157->tFFFFFFF4 = ebp_106 - 1080;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	esp_1019 = (char *) &esp_157->tFFFFFFFC + 8;
	if ((byte) (uint32) __libc_scratch_buffer_set_array_size(gs, dwArg00, stackArg8, dwArg08, out ecx_1016, out edx_1187) == 0x00)
		goto l0807D5D8;
	Eq_2 ebx_196 = ebp_106->tFFFFFBC8;
	ebp_106->tFFFFF758 = ebx_196;
	esp_157->tFFFFFFFC = esi_152 * 0x04;
	Eq_2 esi_200 = (word32) ebx_196 + esi_152 * 0x0C;
	Eq_2 ecx_205 = (word32) esi_200 + esi_152 * 0x04;
	Eq_2 eax_206 = ebp_106->tFFFFF760;
	ebp_106->tFFFFF768 = ecx_205;
	ui32 eax_208 = *((word32) eax_206 + 60);
	ebp_106->tFFFFF76C = esi_200;
	esp_157->tFFFFFFF8 = eax_208 << 0x1D >> 0x1F;
	esp_157->tFFFFFFF4 = ecx_205;
	word32 ecx_4260;
	memset(esp_157->tFFFFFFF4, esp_157->tFFFFFFF8, esp_157->tFFFFFFFC, out ecx_4260, out edx_1187);
	esp_1019 = (char *) &esp_157->tFFFFFFFC + 8;
	ecx_1016 = ebp_106->tFFFFF768;
	if (edi_104 != 0x00)
	{
		Eq_2 eax_235 = ebp_106->tFFFFF770;
		ebp_106->tFFFFF740 = edi_104;
		Eq_2 ebx_237 = eax_235;
		Eq_2 esi_238 = (word32) eax_235 + edi_104 *s 0x34;
		do
		{
			ui32 eax_244 = ebx_237.u20->dw0020;
			if (eax_244 != ~0x00)
				((word32) ecx_1016 + eax_244 * 0x04)->u0 = 0x00;
			ui32 eax_251 = ebx_237.u20->dw001C;
			if (eax_251 != ~0x00)
				((word32) ecx_1016 + eax_251 * 0x04)->u0 = 0x00;
			word32 eax_258 = ebx_237.u20->dw002C;
			if (eax_258 != 0x00)
			{
				if (eax_258 != 0x01)
				{
					ui32 ecx_283 = ebx_237.u20->dw0024;
					ebp_106->tFFFFF768 = ebx_237.u20->dw0008;
					struct Eq_94232 * esp_293 = esp_1019 - 4;
					esp_293->dw0000 = (word32) ebp_106->tFFFFF76C + ecx_283 * 0x04;
					ui32 edx_289 = (word32) ecx_1016 + ecx_283 * 0x04;
					Eq_2 ecx_295 = ebp_106->tFFFFF768;
					esp_293->dwFFFFFFFC = edx_289;
					esp_293->dwFFFFFFF8 = eax_258;
					Eq_2 eax_300 = ebp_106->tFFFFF764;
					esp_293->tFFFFFFF4 = ebx_237;
					<anonymous> * eax_305[] = *((word32) eax_300 + 8168);
					eax_305[ecx_295]();
					++ebx_237.u20;
					if (esi_238 == ebx_237)
						break;
					continue;
				}
				Eq_2 ecx_269 = ebp_106->tFFFFF76C;
				*((word32) ecx_1016 + (ebx_237.u20)->dw0024 * 0x04) = ebx_237.u20->dw0028;
				edx_1187 = ebx_237.u20->dw0030;
				*((word32) ecx_269 + (ebx_237.u20)->dw0024 * 0x04) = edx_1187;
			}
			++ebx_237.u20;
		} while (esi_238 != ebx_237);
		edi_104 = ebp_106->tFFFFF740;
		if (ebp_106->tFFFFF774 == 0x00)
		{
l0807D128:
			if (edi_104 <= ebp_106->tFFFFF754)
			{
l0807DC77:
				esi_1196 = ebp_106->tFFFFF75C;
				goto l0807D5DD;
			}
			word32 eax_580 = ebp_106->dwFFFFF738;
			Eq_2 esi_581 = ebp_106->tFFFFF770;
			ebp_106->tFFFFF6FC = edi_104;
			ebp_106->tFFFFF6F8 = eax_580 + 1000;
			esi_1119 = (word32) esi_581 + ebp_106->tFFFFF754 *s 0x34;
			ebp_106->dwFFFFF6D8 = 0x080CEFA0;
			ebp_106->dwFFFFF6D4 = 0x0354;
			ebp_106->dwFFFFF6D0 = 0x080CEFA0;
			ebp_106->dwFFFFF6CC = 0x0354;
			ebp_106->dwFFFFF6F0 = 0x080CEFA0;
			ebp_106->dwFFFFF6E4 = 0x0354;
			ebp_106->dwFFFFF6E0 = 0x080CEFA0;
			ebp_106->tFFFFF6DC.u0 = 0x0354;
			ebp_106->dwFFFFF70C = 0x080CEFA0;
			ebp_106->dwFFFFF708 = 0x0354;
l0807D1AE:
			ui32 eax_1209 = (word32) *((word32) esi_1119 + 0x0C);
			byte cl_1219 = (byte) (SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x03) & 0x01);
			ebp_106->bFFFFF700 = cl_1219;
			ebp_106->dwFFFFF724 = (word32) cl_1219;
			ebp_106->dwFFFFF72C = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x04) & 0x01;
			ebp_106->tFFFFF74C = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x05) & 0x01;
			ebp_106->tFFFFF734 = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x06) & 0x01;
			ebp_106->bFFFFF730 = (byte) eax_1209 >> 0x07;
			ebp_106->tFFFFF768 = eax_1209 & 0x01;
			word32 edx_1258 = (word32) *((word32) esi_1119 + 0x0D);
			ebp_106->dwFFFFF704 = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x01) & 0x01;
			ebp_106->bFFFFF72A = (byte) (SEQ(SLICE(edx_1258, word24, 8), (byte) edx_1258 >> 0x03) & 0x01);
			edx_1187 = *((word32) esi_1119 + 32);
			ebp_106->dwFFFFF710 = SEQ(SLICE(edx_1258, word24, 8), (byte) edx_1258 >> 0x01) & 0x01;
			ebp_106->bFFFFF72B = (byte) *((word32) esi_1119 + 16);
			Eq_2 ecx_1286 = *((word32) esi_1119 + 8);
			ebp_106->dwFFFFF718 = SEQ(SLICE(eax_1209, word24, 8), (byte) eax_1209 >> 0x02) & 0x01;
			edi_104 = *esi_1119;
			ebp_106->tFFFFF770 = ecx_1286;
			if (edx_1187 != ~0x00)
			{
				Eq_2 ecx_1296 = *((word32) ebp_106->tFFFFF758 + edx_1187 * 0x0C);
				ebp_106->tFFFFF774 = ecx_1296;
				edx_1187 *= 0x03;
				if (ecx_1296 >= 0x00)
					*((word32) esi_1119 + 4) = ecx_1296;
				else
				{
					ebp_106->tFFFFF774 = -ebp_106->tFFFFF774;
					Eq_2 ecx_1303 = ebp_106->tFFFFF774;
					*((word32) esi_1119 + 0x0C) = (byte) (eax_1209 | 0x20);
					*((word32) esi_1119 + 4) = ecx_1303;
					ebp_106->tFFFFF74C.u0 = 0x01;
				}
			}
			else
				ebp_106->tFFFFF774 = *((word32) esi_1119 + 4);
			ui32 eax_1314 = *((word32) esi_1119 + 28);
			if (eax_1314 != ~0x00)
			{
				edi_104 = *((word32) ebp_106->tFFFFF758 + eax_1314 * 0x0C);
				if (edi_104 >= 0x00)
					*esi_1119 = edi_104;
				else
				{
					*esi_1119 = ~0x00;
					edi_104.u0 = ~0x00;
				}
			}
			Eq_2 eax_1329 = ebp_106->tFFFFF774;
			if (eax_1329 < edi_104)
				eax_1329 = edi_104;
			if (eax_1329 <= 0xDA)
			{
l0807D458:
				ebp_106->tFFFFF76C.u0 = 0x00;
				ebp_106->tFFFFF740 = ebp_106->tFFFFF6F8;
				goto l0807D46E;
			}
			struct Eq_92702 * esp_1353 = esp_1019 - 0x0C;
			Eq_2 ebx_1355 = eax_1329 * 0x04 + 0x80;
			esp_1353->tFFFFFFFC = ebx_1355;
			esp_1019 = (char *) &esp_1353->tFFFFFFFC + 16;
			if (__libc_alloca_cutoff(gs, esp_1353->tFFFFFFFC) != 0x00 || ebx_1355 <= 0x1000)
			{
				Eq_2 edx_1431 = (char *) &esp_1353->tFFFFFFFC + 16 - ((word32) ebx_1355 + 27 & ~0x0FFF);
				ui32 eax_1432 = (word32) ebx_1355 + 27 & ~0x0F;
				if ((char *) &esp_1353->tFFFFFFFC + 16 != edx_1431)
				{
					do
					{
						esp_1019 -= 0x1000;
						*((word32) esp_1019 + 0x0FFC) = *((word32) esp_1019 + 0x0FFC);
					} while (esp_1019 != edx_1431);
				}
				if ((eax_1432 & 0x0FFF) != 0x00)
				{
					esp_1019 -= eax_1432 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_1432 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_1432 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				ui32 eax_1473;
				Eq_92775 edx_1459 = (word32) esp_1019 + 0x0F;
				edx_1187 = edx_1459 & ~0x0F;
				if (ebp_106->tFFFFF774 < edi_104)
					eax_1473 = edi_104 * 0x04 + 0x80;
				else
					eax_1473 = ebp_106->tFFFFF774 * 0x04 + 0x80;
				ecx_1422 = ebp_106->tFFFFF770;
				ebp_106->tFFFFF76C.u0 = 0x00;
				ebp_106->tFFFFF740 = eax_1473 + (edx_1459 & ~0x0F);
				if (ecx_1422 <= 0xFF)
				{
l0807D480:
					struct Eq_92233 * eax_1488 = *((word32) ebp_106->tFFFFF764 + 8148);
					if (eax_1488 != null)
					{
						edx_1187 = eax_1488[ecx_1422 * 0x04];
						if (edx_1187 != 0x00)
						{
							ui32 eax_1507 = *((word32) esi_1119 + 44);
							ebp_106->dwFFFFF6C8 = eax_1507;
							ebp_106->dwFFFFF6F4 = eax_1507 << 0x02;
							ui32 ecx_1510 = (eax_1507 << 0x02) + 0x1B;
							ebp_106->dwFFFFF6C4 = ecx_1510 & ~0x0F;
							Eq_2 eax_1522 = esp_1019 - (ecx_1510 & ~0x0FFF);
							ui32 eax_1524 = ebp_106->dwFFFFF6F4;
							while (esp_1019 != eax_1522)
							{
								esp_1019 -= 0x1000;
								*((word32) esp_1019 + 0x0FFC) = *((word32) esp_1019 + 0x0FFC);
							}
							ebp_106->dwFFFFF6F4 = eax_1524;
							ui32 ecx_1541 = ebp_106->dwFFFFF6C4;
							if ((ecx_1541 & 0x0FFF) != 0x00)
							{
								esp_1019 -= ecx_1541 & 0x0FFF;
								(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(ecx_1541 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(ecx_1541 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
							}
							Eq_92297 ecx_1553 = (word32) esp_1019 + 0x0F;
							ui32 ecx_1557 = ebp_106->dwFFFFF6C8;
							ebp_106->dwFFFFF6C4 = ecx_1553 & ~0x0F;
							struct Eq_92309 * eax_1558 = ecx_1553 & ~0x0F;
							if (ecx_1557 != 0x00)
							{
								ecx_1557 = (word32) ebp_106->tFFFFF758 + *((word32) esi_1119 + 36) * 0x0C;
								word32 * edx_1570 = ecx_1553 & ~0x0F;
								word32 * eax_1571 = (ecx_1553 & ~0x0F) + ebp_106->dwFFFFF6F4;
								do
								{
									*edx_1570 = ecx_1557;
									++edx_1570;
									ecx_1557 += 0x0C;
								} while (eax_1571 != edx_1570);
								eax_1558 = (struct Eq_92309 *) *((word32) ebp_106->tFFFFF764 + 8148);
								edx_1187 = eax_1558[ecx_1422 * 0x04];
							}
							struct Eq_92476 * esp_1592 = esp_1019 - 0x04;
							esp_1592->dwFFFFFFFC = ebp_106->dwFFFFF6C4;
							esp_1592->tFFFFFFF8 = esi_1119;
							esp_1592->tFFFFFFF4 = ebp_106->tFFFFF760;
							Eq_92494 eax_1651;
							edx_1187();
							esp_1019 = &esp_1592->ptr0000 + 1;
							if (eax_1651 != ~0x01)
							{
								if (eax_1651 < 0x00)
									goto l0807D5B3;
								if (ebp_106->tFFFFF75C <= 0x7FFFFFFE)
								{
									if (0x7FFFFFFF - ebp_106->tFFFFF75C < eax_1651)
										goto l0807D5A0;
									Mem1674[ebp_106 + ~0x08A3:word32] = Mem1605[ebp_106 + ~0x08A3:word32] + eax_1651;
									goto l0807DBD9;
								}
								esi_1027 = ebp_106->tFFFFF764;
								esp_1592->ptr0000 = (word32) esi_1027 - 0x0001C23C;
								esp_1592->dwFFFFFFFC = 2010;
								esp_1032 = esp_1592 - 4;
l0807F6E1:
								struct Eq_93061 * esp_2581 = esp_1032 - 4;
								esp_2581->ptr0000 = (word32) esi_1027 - 0x0001C322;
								esp_2581->ptrFFFFFFFC = (word32) esi_1027 - 115388;
								word32 ecx_4272;
								word32 edx_4273;
								__assert_fail(out ecx_4272, out edx_4273);
								esi_1047 = ebp_106->tFFFFF764;
								esp_2581->ptrFFFFFFF8 = (word32) esi_1047 - 0x0001C23C;
								esp_2581->dwFFFFFFF4 = 0x07E2;
								esp_1052 = esp_2581 - 0x0C;
								goto l0807F706;
							}
						}
					}
					goto l0807D354;
				}
l0807D354:
				Eq_2 esp_1695 = fp;
				Eq_2 ecx_1678 = ebp_106->tFFFFF770;
				if (ecx_1678 <= 122)
				{
					Eq_2 ebx_1682 = ebp_106->tFFFFF764;
					ui32 eax_1683 = (word32) *((word32) ecx_1678 + ((word32) ebx_1682 - 114784));
					Eq_2 eax_1697;
					Eq_2 ecx_1698;
					Eq_2 edx_1699;
					(*((word32) ebx_1682 + (eax_1683 * 0x04 - 5056)))();
					ecxOut = ecx_1698;
					edxOut = edx_1699;
					return eax_1697;
				}
				ui32 edx_1701 = *((word32) esi_1119 + 44);
				ui32 eax_1704 = edx_1701 * 0x04 + 0x1B;
				edi_104 = fp - (eax_1704 & ~0x0FFF);
				while (esp_1695 != edi_104)
				{
					esp_1695 -= 0x1000;
					*((word32) esp_1695 + 0x0FFC) = *((word32) esp_1695 + 0x0FFC);
				}
				int32 ebx_1717 = eax_1704 & ~0x0F & 0x0FFF;
				if (ebx_1717 != 0x00)
				{
					esp_1695 -= ebx_1717;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1695 - 0x04)[ebx_1717 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1695 - 0x04)[ebx_1717 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_93200 eax_1728 = (word32) esp_1695 + 0x0F;
				word32 * eax_1729 = eax_1728 & ~0x0F;
				if (edx_1701 != 0x00)
				{
					edi_104 = ebp_106->tFFFFF758;
					word32 * ecx_1744 = edx_1701 * 0x04 + (eax_1728 & ~0x0F);
					ptr32 edx_1747 = (word64) edi_104.u0 + *((word32) esi_1119 + 36) * 0x0C;
					do
					{
						*eax_1729 = edx_1747;
						++eax_1729;
						edx_1747 += 0x0C;
					} while (ecx_1744 != eax_1729);
				}
				ui32 edx_1830;
				ui32 edx_1815;
				Eq_2 ecx_1825;
				Eq_2 ebx_1766;
				struct Eq_93235 * eax_1761 = *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_1761 != null)
				{
					Eq_2 edx_1765 = eax_1761->t0010;
					ebx_1766 = eax_1761->t0014;
					if (edx_1765 < ebx_1766)
					{
						eax_1761->t0010 = (word32) edx_1765 + 4;
						edx_1765->u0 = 0x25;
						edx_1830 = (word32) *((word32) esi_1119 + 0x0C);
						ecx_1825 = (word32) edx_1765 + 4;
						ci8 dl_1831 = (byte) edx_1830;
						if ((dl_1831 & 0x08) == 0x00)
						{
							ebp_106->tFFFFF770.u0 = 0x01;
							if (dl_1831 >= 0x00)
								goto l0807E7CE;
							goto l0807EFD0;
						}
						goto l0807E7A4;
					}
				}
				struct Eq_93266 * esp_1772 = esp_1695 - 0x08;
				esp_1772->dwFFFFFFFC = 0x25;
				esp_1772->tFFFFFFF8 = ebp_106->tFFFFF760;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg8 = <invalid>;
				esp_1019 = &esp_1772->dwFFFFFFFC + 3;
				if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
					goto l0807D5B3;
				ebp_106->tFFFFF770.u0 = 0x01;
				edx_1815 = (word32) *((word32) esi_1119 + 0x0C);
				if (((byte) edx_1815 & 0x08) == 0x00)
					goto l0807F2FA;
				eax_1761 = (struct Eq_93235 *) *((word32) ebp_106->tFFFFF760 + 88);
				if (eax_1761 == null)
				{
l0807F2D0:
					struct Eq_93322 * esp_1845 = esp_1695 - 0x08;
					esp_1845->dwFFFFFFFC = 0x23;
					esp_1845->tFFFFFFF8 = ebp_106->tFFFFF760;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg8 = <invalid>;
					esp_1019 = &esp_1845->dwFFFFFFFC + 3;
					if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
						goto l0807D5B3;
					ebp_106->tFFFFF770.u0 = 0x02;
					edx_1815 = (word32) *((word32) esi_1119 + 0x0C);
l0807F2FA:
					edx_1830 = edx_1815;
					if ((byte) edx_1815 >= 0x00)
					{
l0807E7CE:
						ui32 edx_2035;
						byte dl_1956 = (byte) edx_1830;
						if ((dl_1956 & 0x40) != 0x00)
						{
							struct Eq_93235 * eax_1985 = *((word32) ebp_106->tFFFFF760 + 88);
							if (eax_1985 != null)
							{
								Eq_2 edx_1989 = eax_1985->t0010;
								if (edx_1989 < eax_1985->t0014)
								{
									eax_1985->t0010 = (word32) edx_1989 + 4;
									edx_1989->u0 = 0x2B;
									goto l0807E800;
								}
							}
							*((word32) esp_1695 - 0x0C) = 0x2B;
						}
						else
						{
							edx_2035 = edx_1830;
							if ((dl_1956 & 0x10) == 0x00)
								goto l0807E80B;
							struct Eq_93235 * eax_1967 = *((word32) ebp_106->tFFFFF760 + 88);
							if (eax_1967 != null)
							{
								Eq_2 edx_1971 = eax_1967->t0010;
								if (edx_1971 < eax_1967->t0014)
								{
									eax_1967->t0010 = (word32) edx_1971 + 4;
									edx_1971->u0 = 0x20;
									goto l0807E800;
								}
							}
							*((word32) esp_1695 - 0x0C) = 0x20;
						}
						struct Eq_94089 * esp_2002 = esp_1695 - 0x0C;
						esp_2002->tFFFFFFFC = ebp_106->tFFFFF760;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1019 = (char *) &esp_2002->tFFFFFFFC + 16;
						if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
							goto l0807D5B3;
l0807E800:
						ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
						edx_2035 = (word32) *((word32) esi_1119 + 0x0C);
l0807E80B:
						if ((edx_2035 & 0x20) == 0x00)
						{
l0807E840:
							if (*((word32) esi_1119 + 16) != 0x30)
							{
l0807E84A:
								if ((*((word32) esi_1119 + 0x0D) & 0x08) == 0x00)
								{
l0807E880:
									uint32 ecx_2247 = *((word32) esi_1119 + 4);
									if (ecx_2247 == 0x00)
									{
l0807EC6C:
										uint32 ecx_2339 = *esi_1119;
										if (ecx_2339 == ~0x00)
										{
l0807EF37:
											esp_1019 = esp_1695;
											Eq_2 eax_2500 = *((word32) esi_1119 + 8);
											if (eax_2500 == 0x00)
											{
l0807EF86:
												esp_1019 = esp_1695;
												if (ebp_106->tFFFFF75C > 0x7FFFFFFE)
												{
l0807F719:
													esi_1027 = ebp_106->tFFFFF764;
													struct Eq_94011 * esp_2574 = esp_1019 - 4;
													esp_2574->ptr0000 = (word32) esi_1027 - 0x0001C23C;
													esp_2574->dwFFFFFFFC = 0x07FD;
													esp_1032 = esp_2574 - 4;
													goto l0807F6E1;
												}
												edi_104 = ebp_106->tFFFFF75C;
												ecx_1016 = ebp_106->tFFFFF770;
												if (0x7FFFFFFF - edi_104 >= ecx_1016)
												{
													edi_104 += ecx_1016;
													ebp_106->tFFFFF75C = edi_104;
													goto l0807DBD9;
												}
l0807D5A0:
												gs->tFFFFFFE0.u0 = 0x4B;
												goto l0807D5B3;
											}
											edi_104 = ebp_106->tFFFFF760;
											struct Eq_93954 * edx_2506 = *((word64) edi_104.u0 + 88);
											if (edx_2506 != null)
											{
												ecx_1016 = edx_2506->t0010;
												if (ecx_1016 < edx_2506->t0014)
												{
													edx_2506->t0010 = (word32) ecx_1016 + 4;
													*ecx_1016 = eax_2500;
													if (eax_2500 == ~0x00)
														goto l0807D5B3;
l0807EF6C:
													esp_1019 = esp_1695;
													Eq_2 eax_2559 = ebp_106->tFFFFF770;
													if (eax_2559 != 0x7FFFFFFF)
													{
														ebp_106->tFFFFF770 = (word32) eax_2559 + 1;
														goto l0807EF86;
													}
													goto l0807D5B3;
												}
											}
											struct Eq_93960 * esp_2518 = esp_1695 - 0x08;
											esp_2518->tFFFFFFFC = eax_2500;
											esp_2518->tFFFFFFF8 = ebp_106->tFFFFF760;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											Eq_2 stackArg8 = <invalid>;
											esp_1019 = (char *) &esp_2518->tFFFFFFFC + 0x0C;
											if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
												goto l0807D5B3;
											goto l0807EF6C;
										}
										struct Eq_93235 * eax_2344 = *((word32) ebp_106->tFFFFF760 + 88);
										if (eax_2344 != null)
										{
											Eq_2 edx_2348 = eax_2344->t0010;
											if (edx_2348 < eax_2344->t0014)
											{
												eax_2344->t0010 = (word32) edx_2348 + 4;
												edx_2348->u0 = 0x2E;
												goto l0807ECA0;
											}
										}
										struct Eq_93729 * esp_2357 = esp_1695 - 0x08;
										esp_2357->dwFFFFFFFC = 0x2E;
										esp_2357->tFFFFFFF8 = ebp_106->tFFFFF760;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg8 = <invalid>;
										esp_1019 = &esp_2357->dwFFFFFFFC + 3;
										if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
											goto l0807D5B3;
										ecx_2339 = (uint32) *esi_1119;
l0807ECA0:
										ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
										Eq_2 eax_2406 = &ebp_106->tFFFFF7B8;
										ebp_106->tFFFFF774 = eax_2406;
										Eq_2 ebx_2412 = eax_2406;
										while (true)
										{
											uint32 edx_2419 = SLICE(ecx_2339 *64 ~0x33333332, word32, 32);
											ebx_2412 -= 0x04;
											edi_104 = *((word32) ebp_106->tFFFFF764 + ((ecx_2339 - ((edx_2419 >> 0x03) + (edx_2419 >> 0x03) * 0x04) * 0x02) * 0x04 - 88256));
											*ebx_2412 = edi_104;
											if (ecx_2339 <= 0x09)
												break;
											ecx_2339 = edx_2419 >> 0x03;
										}
										if (ebx_2412 >= ebp_106->tFFFFF774)
											goto l0807EF37;
										ebp_106->tFFFFF768 = esi_1119;
										Eq_2 esi_2438 = ebp_106->tFFFFF770;
l0807ED46:
										esp_1019 = esp_1695;
										ebx_2412 = (word32) ebx_2412 + 4;
										struct Eq_93235 * eax_2444 = *((word32) ebp_106->tFFFFF760 + 88);
										if (eax_2444 != null)
										{
											Eq_2 edx_2448 = eax_2444->t0010;
											if (edx_2448 < eax_2444->t0014)
											{
												eax_2444->t0010 = (word32) edx_2448 + 4;
												*edx_2448 = edi_104;
												ecx_1016 = (word32) edx_2448 + 4;
												if (edi_104 == ~0x00)
													goto l0807D5B3;
l0807ED29:
												esp_1019 = esp_1695;
												if (esi_2438 == 0x7FFFFFFF)
													goto l0807D5B3;
												esi_2438 = (word32) esi_2438 + 1;
												if (ebx_2412 < ebp_106->tFFFFF774)
												{
													edi_104 = *ebx_2412;
													goto l0807ED46;
												}
												ebp_106->tFFFFF770 = esi_2438;
												esi_1119 = ebp_106->tFFFFF768;
												goto l0807EF37;
											}
										}
										struct Eq_93881 * esp_2459 = esp_1695 - 0x08;
										esp_2459->tFFFFFFFC = edi_104;
										esp_2459->tFFFFFFF8 = ebp_106->tFFFFF760;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_2 stackArg8 = <invalid>;
										esp_1019 = (char *) &esp_2459->tFFFFFFFC + 0x0C;
										if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
											goto l0807D5B3;
										goto l0807ED29;
									}
									Eq_2 eax_2252 = &ebp_106->tFFFFF7B8;
									ebp_106->tFFFFF774 = eax_2252;
									Eq_2 ebx_2254 = eax_2252;
									while (true)
									{
										uint32 edx_2261 = SLICE(ecx_2247 *64 ~0x33333332, word32, 32);
										ebx_2254 -= 0x04;
										edi_104 = *((word32) ebp_106->tFFFFF764 + ((ecx_2247 - ((edx_2261 >> 0x03) + (edx_2261 >> 0x03) * 0x04) * 0x02) * 0x04 - 88256));
										*ebx_2254 = edi_104;
										if (ecx_2247 <= 0x09)
											break;
										ecx_2247 = edx_2261 >> 0x03;
									}
									if (ebx_2254 >= ebp_106->tFFFFF774)
										goto l0807EC6C;
									ebp_106->tFFFFF768 = esi_1119;
									Eq_2 esi_2279 = ebp_106->tFFFFF770;
l0807E91A:
									esp_1019 = esp_1695;
									ebx_2254 = (word32) ebx_2254 + 4;
									struct Eq_93235 * eax_2285 = *((word32) ebp_106->tFFFFF760 + 88);
									if (eax_2285 != null)
									{
										Eq_2 edx_2289 = eax_2285->t0010;
										if (edx_2289 < eax_2285->t0014)
										{
											eax_2285->t0010 = (word32) edx_2289 + 4;
											*edx_2289 = edi_104;
											ecx_1016 = (word32) edx_2289 + 4;
											if (edi_104 == ~0x00)
												goto l0807D5B3;
l0807E909:
											esi_2279 = (word32) esi_2279 + 1;
											if (ebx_2254 < ebp_106->tFFFFF774)
											{
												edi_104 = *ebx_2254;
												goto l0807E91A;
											}
											ebp_106->tFFFFF770 = esi_2279;
											esi_1119 = ebp_106->tFFFFF768;
											goto l0807EC6C;
										}
									}
									struct Eq_93804 * esp_2300 = esp_1695 - 0x08;
									esp_2300->tFFFFFFFC = edi_104;
									esp_2300->tFFFFFFF8 = ebp_106->tFFFFF760;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg8 = <invalid>;
									esp_1019 = (char *) &esp_2300->tFFFFFFFC + 0x0C;
									if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
										goto l0807D5B3;
									goto l0807E909;
								}
								struct Eq_93235 * eax_2191 = *((word32) ebp_106->tFFFFF760 + 88);
								if (eax_2191 != null)
								{
									Eq_2 edx_2195 = eax_2191->t0010;
									if (edx_2195 < eax_2191->t0014)
									{
										eax_2191->t0010 = (word32) edx_2195 + 4;
										edx_2195->u0 = 0x49;
l0807E879:
										ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
										goto l0807E880;
									}
								}
								struct Eq_93563 * esp_2201 = esp_1695 - 0x08;
								esp_2201->dwFFFFFFFC = 0x49;
								esp_2201->tFFFFFFF8 = ebp_106->tFFFFF760;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								Eq_2 stackArg8 = <invalid>;
								esp_1019 = &esp_2201->dwFFFFFFFC + 3;
								if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
									goto l0807D5B3;
								goto l0807E879;
							}
							struct Eq_93235 * eax_2130 = *((word32) ebp_106->tFFFFF760 + 88);
							if (eax_2130 != null)
							{
								Eq_2 edx_2134 = eax_2130->t0010;
								if (edx_2134 < eax_2130->t0014)
								{
									eax_2130->t0010 = (word32) edx_2134 + 4;
									edx_2134->u0 = 0x30;
l0807F098:
									ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
									goto l0807E84A;
								}
							}
							*((word32) esp_1695 - 0x0C) = 0x30;
							*((word32) esp_1695 - 16) = ebp_106->tFFFFF760;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg8 = <invalid>;
							esp_1019 = esp_1695;
							if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
								goto l0807D5B3;
							goto l0807F098;
						}
						struct Eq_93235 * eax_2071 = *((word32) ebp_106->tFFFFF760 + 88);
						if (eax_2071 != null)
						{
							Eq_2 edx_2075 = eax_2071->t0010;
							if (edx_2075 < eax_2071->t0014)
							{
								eax_2071->t0010 = (word32) edx_2075 + 4;
								edx_2075->u0 = 0x2D;
l0807E839:
								ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
								goto l0807E840;
							}
						}
						*((word32) esp_1695 - 0x0C) = 0x2D;
						*((word32) esp_1695 - 16) = ebp_106->tFFFFF760;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1019 = esp_1695;
						if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
							goto l0807D5B3;
						goto l0807E839;
					}
					eax_1761 = (struct Eq_93235 *) *((word32) ebp_106->tFFFFF760 + 88);
					if (eax_1761 == null)
					{
l0807F313:
						struct Eq_93491 * esp_1906 = esp_1695 - 0x08;
						esp_1906->dwFFFFFFFC = 0x27;
						esp_1906->tFFFFFFF8 = ebp_106->tFFFFF760;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg8 = <invalid>;
						esp_1019 = &esp_1906->dwFFFFFFFC + 3;
						if (__woverflow(dwArg00, stackArg8, out ecx_1016) == ~0x00)
							goto l0807D5B3;
						goto l0807EFE8;
					}
l0807EFD0:
					Eq_2 edx_1900 = eax_1761->t0010;
					if (edx_1900 < eax_1761->t0014)
					{
						eax_1761->t0010 = (word32) edx_1900 + 4;
						edx_1900->u0 = 0x27;
l0807EFE8:
						ebp_106->tFFFFF770 = (word32) ebp_106->tFFFFF770 + 1;
						edx_1830 = (word32) *((word32) esi_1119 + 0x0C);
						goto l0807E7CE;
					}
					goto l0807F313;
				}
				ecx_1825 = eax_1761->t0010;
				ebx_1766 = eax_1761->t0014;
l0807E7A4:
				if (ebx_1766 > ecx_1825)
				{
					ebp_106->tFFFFF770.u0 = 0x02;
					eax_1761->t0010 = (word32) ecx_1825 + 4;
					ecx_1825->u0 = 0x23;
					edx_1830 = (word32) *((word32) esi_1119 + 0x0C);
					if ((byte) edx_1830 >= 0x00)
						goto l0807E7CE;
					goto l0807EFD0;
				}
				goto l0807F2D0;
			}
			esp_1353->tFFFFFFFC = ebx_1355;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edi_4267;
			word32 ebp_4265;
			word32 esi_4266;
			word32 ebx_4264;
			Eq_2 eax_1400 = __libc_malloc(gs, stackArg0, dwArg00, out ecx_1016, out edx_1187, out ebx_4264, out ebp_4265, out esi_4266, out edi_4267);
			ebp_106->tFFFFF76C = eax_1400;
			esp_1019 = (char *) &esp_1353->tFFFFFFFC + 16;
			if (eax_1400 != 0x00)
			{
				ui32 eax_1412;
				if (ebp_106->tFFFFF774 < edi_104)
					eax_1412 = edi_104 * 0x04 + 0x80;
				else
					eax_1412 = ebp_106->tFFFFF774 * 0x04 + 0x80;
				ebp_106->tFFFFF740 = (word32) ebp_106->tFFFFF76C + eax_1412;
l0807D46E:
				ecx_1422 = ebp_106->tFFFFF770;
				if (ecx_1422 <= 0xFF)
					goto l0807D480;
				goto l0807D354;
			}
			goto l0807D5D8;
		}
	}
	else if (ebp_106->tFFFFF774 == 0x00)
		goto l0807DC77;
	ebp_106->tFFFFF740 = edi_104;
	Eq_2 esi_335 = ebp_106->tFFFFF758;
	edi_104 = ebp_106->tFFFFF74C;
	ebp_106->tFFFFF768.u0 = 0.0F;
	Eq_2 ebx_336 = 0x00;
	Eq_2 esi_341 = esi_335;
	do
	{
		Eq_2 eax_345 = *((word32) ecx_1016 + ebx_336 * 0x04);
		if (eax_345 <= 0x05)
		{
			if (eax_345 >= 0x03 || (eax_345 > 0x01 || eax_345 >= 0x00))
				goto l0807D3C8;
			if (eax_345 != ~0x00)
				goto l0807D3C0;
			if ((*((word32) ebp_106->tFFFFF760 + 60) & 0x04) == 0x00)
			{
				Eq_2 esi_362 = ebp_106->tFFFFF764;
				struct Eq_92166 * esp_365 = esp_1019 - 4;
				esp_365->dw0000 = (word32) esi_362 - 0x0001C23C;
				esp_365->dwFFFFFFFC = 1887;
				esp_365->dwFFFFFFF8 = (word32) esi_362 - 0x0001C322;
				esp_365->dwFFFFFFF4 = (word32) esi_362 - 115456;
				word32 ecx_4262;
				__assert_fail(out ecx_4262, out edx_1187);
				esp_1019 = esp_365 - 0x0C;
				esi_1119 = esi_362;
				goto l0807D458;
			}
			struct Eq_92195 * esp_385 = esp_1019 - 0x0C;
			esp_385->dwFFFFFFFC = (word32) ebp_106->tFFFFF764 - 115424;
			esp_1019 = esp_385 - 4;
			eax_345 = __libc_fatal(out ecx_1016);
		}
		if (eax_345 != 0x0100)
		{
			if (eax_345 > 0x0100)
			{
				if (eax_345 == 0x0200 || eax_345 == 0x0400)
					goto l0807D3C8;
				if (eax_345 != 0x0107)
					goto l0807D3C0;
				real80 * eax_555 = *edi_104.u0;
				real64 rLoc1_2950 = (real64) *eax_555;
				*edi_104.u0 = (char *) eax_555 + 0x0C;
				esi_341->u3 = (real80) rLoc1_2950;
				edx_1187 = (char *) eax_555 + 0x0C;
			}
			else if (eax_345 <= 0x07)
			{
				real64 * eax_411 = *edi_104.u0;
				uint128 xmm1_412 = (uint128) *eax_411;
				*edi_104.u0 = eax_411 + 1;
				*esi_341 = (real64) xmm1_412;
				edx_1187 = eax_411 + 1;
			}
			else
			{
l0807D3C0:
				if ((SLICE(eax_345, byte, 8) & 0x08) != 0x00)
				{
l0807D3C8:
					word32 * eax_549 = *edi_104.u0;
					*edi_104.u0 = eax_549 + 1;
					*esi_341 = *eax_549;
					edx_1187 = eax_549 + 1;
				}
				else
				{
					edx_1187 = *((word32) ebp_106->tFFFFF764 + 8172);
					ebp_106->tFFFFF74C = edx_1187;
					if (edx_1187 == 0x00 || *((word32) (edx_1187 - 0x20) + eax_345 * 0x04) == 0x00)
						esi_341->u3 = (real80) (real64) ebp_106->tFFFFF768;
					else
					{
						word32 eax_451 = *((word32) ebp_106->tFFFFF76C + ebx_336 * 0x04);
						ebp_106->tFFFFF734 = eax_451 + 0x1B & ~0x0F;
						Eq_2 edx_460 = esp_1019 - (eax_451 + 0x1B & ~0x0FFF);
						Eq_2 edx_462 = ebp_106->tFFFFF74C;
						while (esp_1019 != edx_460)
						{
							esp_1019 -= 0x1000;
							*((word32) esp_1019 + 0x0FFC) = *((word32) esp_1019 + 0x0FFC);
						}
						ebp_106->tFFFFF74C = edx_462;
						Eq_2 eax_479 = ebp_106->tFFFFF734;
						if ((eax_479 & 0x0FFF) != 0x00)
						{
							esp_1019 -= eax_479 & 0x0FFF;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_479 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1019 - 0x04)[(eax_479 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						ebp_106->tFFFFF734 = ecx_1016;
						Eq_92595 eax_491 = (word32) esp_1019 + 0x0F;
						*esi_341 = eax_491 & ~0x0F;
						struct Eq_92603 * esp_492 = esp_1019 - 0x08;
						Eq_2 edx_511 = *((word32) ecx_1016 + ebx_336 * 0x04);
						esp_492->tFFFFFFFC = edi_104;
						esp_492->dwFFFFFFF8 = eax_491 & ~0x0F;
						Eq_2 eax_520 = ebp_106->tFFFFF74C;
						(eax_520 - 0x20)[edx_511]();
						ecx_1016 = ebp_106->tFFFFF734;
						esp_1019 = (char *) &esp_492->tFFFFFFFC + 0x0C;
					}
				}
			}
		}
		else
		{
			struct Eq_94145 * eax_400 = *edi_104.u0;
			*edi_104.u0 = (char *) &eax_400->t0004 + 4;
			edx_1187 = eax_400->t0004;
			word32 eax_404 = eax_400->dw0000;
			*((word32) esi_341 + 4) = edx_1187;
			*esi_341 = eax_404;
		}
		ebx_336 = (word32) ebx_336 + 1;
		esi_341 = (word32) esi_341 + 0x0C;
	} while (ebx_336 < ebp_106->tFFFFF774);
	edi_104 = ebp_106->tFFFFF740;
	goto l0807D128;
}

// 0807F7D0: Register Eq_94815 __vfwprintf(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_12322 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      locked_vfxprintf
//      buffered_vfprintf
Eq_94815 __vfwprintf(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_12322 & ecxOut, union Eq_2 & edxOut)
{
	ptr32 fp;
	struct Eq_9 * gs;
	Eq_2 dwArg08;
	Eq_2 dwArg04;
	Eq_2 dwArg0C;
	word32 dwLoc0494;
	word32 dwLoc04A0;
	word32 dwLoc0480;
	word32 dwLoc047C;
	word32 dwLoc0484;
	word32 dwLoc04B8;
	word32 dwLoc0450;
	word32 dwLoc04A4;
	word32 dwLoc04D0;
	word32 dwLoc04D8;
	word32 dwLoc04C0;
	word32 dwLoc0478;
	word32 dwLoc0470;
	esi_21 = dwArg04;
	eax_26 = gs->dw0014;
	eax_33 = gs->tFFFFFFE0;
	eax_39 = _IO_fwide(gs, dwArg04, 0x01, out ecx_41, out edx_40, out ebp_1926, out esi_1927);
	esp_43 = fp - 0x04FC;
	if (eax_39 == 0x01)
	{
		eax_46 = (ui32) *dwArg04;
		al_47 = (byte) eax_46;
		if ((al_47 & 0x08) == 0x00)
		{
			if (dwArg08 == 0x00)
			{
				edi_62.u0 = ~0x00;
				gs->tFFFFFFE0.u0 = 22;
				goto l0807FB6B;
			}
			eax_70 = _IO_fwide(gs, dwArg04, 0x01, out ecx_72, out edx_71, out ebp_1928, out esi_1929);
			esp_74 = fp - 0x04FC;
			if (eax_70 == 0x01)
			{
				edi_78 = (ui32) *dwArg04;
				dwLoc0474_1029 = edi_78 & 0x02;
				if ((edi_78 & 0x02) != 0x00)
				{
					eax_88 = buffered_vfprintf(dwArg04, dwArg0C, dwArg08, gs, out ecx_90, out edx_89);
					edi_92 = eax_88;
					goto l0807FB6B;
				}
				eax_102 = wcschrnul(dwArg08, 0x25);
				dwLoc0478_1033 = eax_102;
				dwLoc0450_1034 = eax_102;
				dwLoc0470_1035 = edi_78 & 0x8000;
				if ((edi_78 & 0x8000) != 0x00)
					dwLoc0470_1042.u0 = 0x00;
				else
				{
					dwLoc0470_1757 = (dwLoc0470_1041, dwLoc0470_1035);
					Mem144 = (Mem141, Mem123);
					edx_145 = *((word32) dwArg04 + 72);
					edi_147 = gs->t0008;
					if (*((word32) edx_145 + 8) != edi_147)
					{
						if (gs->t000C != 0x00)
							__lock();
						Z_159 = __cmpxchg(*edx_145, 0x01, 0x00, out eax_158);
						if (!Z_159)
							__lll_lock_wait_private(eax_158, edx_145, gs);
						edx_171 = *((word32) dwArg04 + 72);
						*((word32) edx_171 + 8) = edi_147;
					}
					Mem176 = (Mem144, Mem174);
					edx_175 = (edx_145, edx_171);
					v39_177 = (word32) *((word32) edx_175 + 4) + 1;
					*((word32) edx_175 + 4) = v39_177;
				}
				dwLoc0470_1755 = (dwLoc0470_1042, dwLoc0470_1041, dwLoc0470_1757);
				Mem185 = (Mem180, Mem141, Mem178);
				edx_186 = *((word32) dwArg04 + 0x0094);
				dwLoc0480_1043 = 0x080CEFA0;
				dwLoc047C_1044 = 0x0354;
				if (edx_186 >= 135066356)
				{
					dwLoc0484_1045 = edx_186;
					_IO_vtable_check(out ecx_1930, out edx_1931);
				}
				dwLoc0484_1554 = (dwLoc0484_1045, dwLoc0484);
				eax_230 = eax_102 - dwArg08;
				edi_235 = eax_230 >> 0x02;
				(*((word32) edx_186 + 28))();
				esp_249 = fp - 0x04FC;
				if (eax_230 >> 0x02 != eax_245)
				{
l0807FBD8:
					edx_1897 = (edx_246, edx_316, edx_1898, edx_944, edx_792);
					dwLoc0478_1874 = (dwLoc0478_1033, dwLoc0478_1875, dwLoc0478_1875, dwLoc0478_1477, dwLoc0478_1477);
					dwLoc04C0_1867 = (dwLoc04C0, dwLoc04C0_1868, dwLoc04C0_1868, dwLoc04C0_1431, dwLoc04C0_1431);
					dwLoc04D8_1854 = (dwLoc04D8, dwLoc04D8_1855, dwLoc04D8_1855, dwLoc04D8_1391, dwLoc04D8_1391);
					dwLoc04D0_1845 = (dwLoc04D0, dwLoc04D0_1846, dwLoc04D0_1846, dwLoc04D0_1371, dwLoc04D0_1371);
					dwLoc04A4_1836 = (dwLoc04A4, dwLoc04A4_1837, dwLoc04A4_1837, dwLoc04A4_1326, dwLoc04A4_1323);
					dwLoc0450_1833 = (dwLoc0450_1034, dwLoc0450_1834, dwLoc0450_1834, dwLoc0450_1266, dwLoc0450_1314);
					dwLoc04B8_1830 = (dwLoc04B8, dwLoc04B8_1831, dwLoc04B8_1831, dwLoc04B8_1243, dwLoc04B8_1312);
					dwLoc0484_1829 = (dwLoc0484_1554, dwLoc0484_1097, dwLoc0484_1097, dwLoc0484_1603, dwLoc0484_1340);
					dwLoc047C_1817 = (dwLoc047C_1044, dwLoc047C_1818, dwLoc047C_1818, dwLoc047C_1160, dwLoc047C_1160);
					dwLoc0480_1814 = (dwLoc0480_1043, dwLoc0480_1815, dwLoc0480_1815, dwLoc0480_1152, dwLoc0480_1152);
					dwLoc0494_1808 = (dwLoc0494, dwLoc0494_1809, dwLoc0494_1809, dwLoc0494_1141, dwLoc0494_1141);
					dwLoc0470_1778 = (dwLoc0470_1755, dwLoc0470_1779, dwLoc0470_1779, dwLoc0470_1764, dwLoc0470_1764);
					esp_1010 = (esp_249, esp_319, esp_305, esp_948, esp_795);
					ecx_1006 = (ecx_247, ecx_317, ecx_1007, ecx_950, ecx_796);
					Mem1004 = (Mem240, Mem310, Mem300, Mem945, Mem799);
					esi_1003 = (esi_21, esi_321, esi_311, esi_399, esi_399);
					edi_322.u0 = ~0x00;
					goto l0807FB48;
				}
				else
				{
					edx_252 = eax_102;
					ecx_253 = *eax_102;
					if (ecx_253 == 0x00)
					{
l0807FB48:
						edx_1896 = (edx_252, edx_944, edx_944, edx_883, edx_1897);
						dwLoc0478_1481 = (dwLoc0478_1033, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1469, dwLoc0478_1874);
						dwLoc04C0_1435 = (dwLoc04C0, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1423, dwLoc04C0_1867);
						dwLoc04D8_1395 = (dwLoc04D8, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1383, dwLoc04D8_1854);
						dwLoc04D0_1375 = (dwLoc04D0, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1363, dwLoc04D0_1845);
						dwLoc04A4_1332 = (dwLoc04A4, dwLoc04A4_1326, dwLoc04A4_1326, dwLoc04A4_1570, dwLoc04A4_1836);
						dwLoc0450_1258 = (dwLoc0450_1034, dwLoc0450_1266, dwLoc0450_1266, dwLoc0450_1568, dwLoc0450_1833);
						dwLoc04B8_1237 = (dwLoc04B8, dwLoc04B8_1243, dwLoc04B8_1243, dwLoc04B8_1560, dwLoc04B8_1830);
						dwLoc0484_1225 = (dwLoc0484_1554, dwLoc0484_1603, dwLoc0484_1603, dwLoc0484_1552, dwLoc0484_1829);
						dwLoc047C_1164 = (dwLoc047C_1044, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1549, dwLoc047C_1817);
						dwLoc0480_1156 = (dwLoc0480_1043, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1546, dwLoc0480_1814);
						dwLoc0494_1138 = (dwLoc0494, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1530, dwLoc0494_1808);
						dwLoc0470_1102 = (dwLoc0470_1755, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1770, dwLoc0470_1778);
						edi_370 = (edi_235, edi_961, edi_958, edi_888, edi_322);
						esp_359 = (esp_249, esp_948, esp_948, esp_886, esp_1010);
						ecx_345 = (ecx_253, ecx_950, ecx_950, ecx_884, ecx_1006);
						Mem324 = (Mem240, Mem945, Mem959, Mem875, Mem1004);
						esi_323 = (esi_21, esi_399, esi_399, esi_889, esi_1003);
						if ((*esi_323 & 0x8000) == 0x00)
						{
							edx_328 = *((word32) esi_323 + 72);
							v18_329 = *((word32) edx_328 + 4) - 0x01;
							*((word32) edx_328 + 4) = v18_329;
							if (v18_329 == 0x00)
							{
								((word32) edx_328 + 8)->u0 = 0x00;
								if (gs->t000C != 0x00)
									__lock();
								v29_339 = *edx_328 - 0x01;
								*edx_328 = v29_339;
								if (v29_339 != 0x00)
									__lll_unlock_wake_private(edx_328, ecx_345, edx_328, gs);
							}
						}
						edx_1895 = (edx_1896, edx_328, edx_328);
						Mem352 = (Mem324, Mem330, Mem340);
						ecx_354 = dwLoc0470_1102;
						if (dwLoc0470_1102 != 0x00)
						{
							esp_362 = esp_359 - 0x08;
							esp_362->dwFFFFFFFC = 0x00;
							esp_362->ptrFFFFFFF8 = fp - 0x0434;
							fn00000000();
							esp_390 = &esp_362->dwFFFFFFFC + 3;
						}
l0807FB6B:
						edx_1893 = (edx_1894, edx_89, edx_1895, edx_387, edx_40);
						ecx_1889 = (ecx_1890, ecx_90, ecx_354, ecx_388, ecx_41);
						dwLoc0470_1764 = (dwLoc0470, dwLoc0470, dwLoc0470_1102, dwLoc0470_1102, dwLoc0470);
						dwLoc0478_1477 = (dwLoc0478, dwLoc0478, dwLoc0478_1481, dwLoc0478_1481, dwLoc0478);
						dwLoc04C0_1431 = (dwLoc04C0, dwLoc04C0, dwLoc04C0_1435, dwLoc04C0_1435, dwLoc04C0);
						dwLoc04D8_1391 = (dwLoc04D8, dwLoc04D8, dwLoc04D8_1395, dwLoc04D8_1395, dwLoc04D8);
						dwLoc04D0_1371 = (dwLoc04D0, dwLoc04D0, dwLoc04D0_1375, dwLoc04D0_1375, dwLoc04D0);
						dwLoc04A4_1328 = (dwLoc04A4, dwLoc04A4, dwLoc04A4_1332, dwLoc04A4_1332, dwLoc04A4);
						dwLoc0450_1254 = (dwLoc0450, dwLoc0450, dwLoc0450_1258, dwLoc0450_1258, dwLoc0450);
						dwLoc04B8_1233 = (dwLoc04B8, dwLoc04B8, dwLoc04B8_1237, dwLoc04B8_1237, dwLoc04B8);
						dwLoc0484_1221 = (dwLoc0484, dwLoc0484, dwLoc0484_1225, dwLoc0484_1225, dwLoc0484);
						dwLoc047C_1160 = (dwLoc047C, dwLoc047C, dwLoc047C_1164, dwLoc047C_1164, dwLoc047C);
						dwLoc0480_1152 = (dwLoc0480, dwLoc0480, dwLoc0480_1156, dwLoc0480_1156, dwLoc0480);
						dwLoc0494_1134 = (dwLoc0494, dwLoc0494, dwLoc0494_1138, dwLoc0494_1138, dwLoc0494);
						esp_407 = (esp_408, esp_74, esp_359, esp_390, esp_43);
						edi_402 = (edi_77, edi_92, edi_370, edi_370, edi_62);
						Mem394 = (Mem395, Mem83, Mem352, Mem368, Mem63);
						esi_399 = eax_26 ^ gs->dw0014;
						eax_403 = edi_402;
						if (esi_399 == 0x00)
						{
							ecxOut = ecx_1889;
							edxOut = edx_1893;
							return eax_403;
						}
						__stack_chk_fail(out ecx_413, out edx_412);
						esp_415 = esp_407 - 0x0C;
						dwLoc0474_1129 = edx_412;
						nLoc0473_1320 = SLICE(edx_412, word24, 8);
						esp_415->tFFFFFFFC = ecx_413;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg4.u0 = <invalid>;
						eax_420 = __libc_malloc(gs, stackArg0, stackArg4, out ecx_422, out edx_421, out ebx_1934, out ebp_1935, out esi_1936, out edi_1937);
						esp_424 = &esp_415->ptr0008 + 1;
						if (eax_420 != 0x00)
						{
							esp_415->ptr0008 = fp - 0x0410;
							esp_415->t0004 = edx_412;
							esp_415->t0000 = fp - 0x0424;
							esp_415->tFFFFFFFC = eax_420;
							eax_444 = __mbsrtowcs(gs, dwArg0C, out ecx_446);
							esp_448 = &esp_415->ptr0008 + 1;
							edx_449 = eax_444;
							if (eax_444 != ~0x00)
							{
								v21_452 = dwLoc0494_1134 - eax_444;
								dwLoc0494_1141 = v21_452;
								if (v21_452 < 0x00)
								{
									if (edi_402 >= 0x00)
									{
										eax_626 = *((word32) esi_399 + 0x0094);
										ecx_628 = eax_626 - dwLoc0480_1152;
										if (dwLoc047C_1160 <= ecx_628)
											_IO_vtable_check(out ecx_1949, out edx_1950);
										esp_415->t0004 = eax_444;
										esp_415->t0000 = eax_420;
										esp_415->tFFFFFFFC = esi_399;
										(*((word32) eax_626 + 28))();
										edx_662 = eax_444;
										esp_663 = &esp_415->ptr0008 + 1;
										if (eax_444 == eax_658)
										{
											eax_667 = 0x7FFFFFFF - edi_402;
											if (eax_444 <= eax_667)
												edi_675 = edi_402 + eax_444;
											goto l080811B8;
										}
										goto l0807FBB8;
									}
									goto l080822AB;
								}
								bLoc0474_1149 = (int8) (v21_452 != 0x00);
								eax_461 = (word32) bLoc0474_1149;
								al_465 = (byte) eax_461;
								if (dwLoc04A0 != 0x00 || al_465 == 0x00)
								{
l08081248:
									Mem501 = (Mem460, Mem460, Mem478);
									edi_496 = (edi_402, edi_402, edi_494);
									dwLoc0474_1321 = SEQ(nLoc0473_1320, bLoc0474_1149);
									if (edi_496 < 0x00)
									{
l080822AB:
										dwLoc0474_1318 = (dwLoc0474_1129, dwLoc0474_1321);
										edi_745 = (edi_402, edi_496);
										esp_622 = esp_407 - 4;
										esp_622->ptr0000 = 0x080B1F94;
										esp_624 = esp_622 - 4;
										esp_622->dwFFFFFFFC = 0x0666;
										dwLoc04A4_1324 = (dwLoc04A4_1326, dwLoc04A4_1328);
										dwLoc0474_1317 = (dwLoc0474_1264, dwLoc0474_1318);
										dwLoc0450_1294 = (dwLoc0450_1266, dwLoc0450_1254);
										dwLoc04B8_1291 = (dwLoc04B8_1243, dwLoc04B8_1233);
										edi_744 = (edi_691, edi_745);
										esp_736 = (esp_732, esp_624);
										esp_737 = esp_736 - 4;
										esp_737->ptr0000 = 134946014;
										esp_737->ptrFFFFFFFC = 134946164;
										__assert_fail(out ecx_1957, out edx_1958);
										esp_737->ptrFFFFFFF8 = 0x080B1F94;
										esp_737->dwFFFFFFF4 = 0x0665;
l080821E5:
										dwLoc04A4_1323 = (dwLoc04A4_1324, dwLoc04A4_1339);
										dwLoc0474_1316 = (dwLoc0474_1317, dwLoc0474_1322);
										dwLoc0450_1314 = (dwLoc0450_1294, dwLoc0450_1254);
										dwLoc04B8_1312 = (dwLoc04B8_1291, dwLoc04B8_1233);
										edi_774 = (edi_744, edi_775);
										__assert_fail(out ecx_1976, out edx_1977);
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										stackArg0.u0 = <invalid>;
										eax_791 = __libc_malloc(gs, stackArg0, dwLoc0474_1316, out ecx_1979, out edx_792, out ebx_1980, out ebp_1981, out esi_1982, out edi_1983);
										esp_795 = fp;
										ecx_796 = dwLoc04A4_1323;
										dwLoc0484_1340 = eax_791;
										if (eax_791 != 0x00)
										{
											eax_802 = dwLoc0474_1316 + eax_791;
											dwLoc04A4_1341 = eax_802;
											edx_806 = *dwLoc0450_1314;
											if (edx_806 != 0x24)
											{
												if (edx_806 > 122 || edx_806 < 0x20)
												{
													g_t807FB92();
													ecxOut = ecx_899;
													edxOut = edx_898;
													return eax_897;
												}
												else
												{
													eax_902 = (word32) *((word32) edx_806 + (eax_420 - 0x20));
													((<anonymous> *[]) 0x080CCEC0)[eax_902]();
													ecxOut = ecx_905;
													edxOut = edx_904;
													return eax_903;
												}
											}
											goto l0807FD80;
										}
										goto l0807FBD8;
									}
									eax_502 = *((word32) esi_399 + 0x0094);
									ecx_505 = eax_502 - dwLoc0480_1152;
									if (dwLoc047C_1160 <= ecx_505)
									{
										dwLoc04A4_1167 = eax_502;
										_IO_vtable_check(out ecx_1965, out edx_1966);
									}
									dwLoc04A4_1336 = (dwLoc04A4_1328, dwLoc04A4_1167);
									esp_522 = esp_407 - 0x04;
									esp_522->tFFFFFFFC = eax_444;
									esp_522->tFFFFFFF8 = eax_420;
									esp_522->tFFFFFFF4 = esi_399;
									(*((word32) eax_502 + 28))();
									edx_544 = eax_444;
									esp_545 = (char *) &esp_522->tFFFFFFFC + 8;
									if (eax_444 == eax_540)
									{
										ecx_548.u0 = 0x7FFFFFFF;
										eax_550 = 0x7FFFFFFF - edi_496;
										if (eax_444 > eax_550)
											goto l080811B8;
										edi_554 = edi_496 + eax_444;
										if (dwLoc04A0 == 0x00 || bLoc0474_1149 == 0x00)
										{
l080812B9:
											edi_605 = (edi_554, edi_554, edi_591);
											esp_600 = esp_407 - 0x0C;
											esp_600->tFFFFFFFC = eax_420;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											stackArg0.u0 = <invalid>;
											// Failed to bind call argument.
											// Please report this issue at https://github.com/uxmal/reko
											stackArg4.u0 = <invalid>;
											free(gs, stackArg0, stackArg4, out ecx_1974, out edx_1975);
										}
										esp_522->tFFFFFFFC = v21_452;
										esp_522->tFFFFFFF8.u0 = 0x20;
										esp_522->tFFFFFFF4 = esi_399;
										dwLoc0474_1186.u0 = 0x7FFFFFFF;
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										stackArg4.u0 = <invalid>;
										eax_570 = _IO_wpadn(gs, stackArg4, dwArg04, dwArg08, out ecx_572, out edx_571, out ebx_1968, out ebp_1969, out esi_1970, out edi_1971);
										esp_574 = (char *) &esp_522->tFFFFFFFC + 8;
										if (v21_452 == eax_570)
										{
											if (edi_554 <= 0x7FFFFFFE)
											{
												ecx_586.u0 = 0x7FFFFFFF;
												edx_588 = 0x7FFFFFFF - edi_554;
												if (edx_588 >= v21_452)
												{
													edi_591 = edi_554 + v21_452;
													goto l080812B9;
												}
												goto l080811B8;
											}
											goto l0808229A;
										}
									}
									goto l0807FBB8;
								}
								esp_415->t0004 = v21_452;
								esp_415->t0000.u0 = 0x20;
								esp_415->tFFFFFFFC = esi_399;
								// Failed to bind call argument.
								// Please report this issue at https://github.com/uxmal/reko
								stackArg4.u0 = <invalid>;
								eax_479 = _IO_wpadn(gs, stackArg4, dwArg04, dwArg08, out ecx_1960, out edx_480, out ebx_1961, out ebp_1962, out esi_1963, out edi_1964);
								ecx_483 = v21_452;
								esp_484 = &esp_415->ptr0008 + 1;
								if (v21_452 == eax_479)
								{
									if (edi_402 > 0x7FFFFFFE)
									{
l0808229A:
										dwLoc04A4_1339 = (dwLoc04A4_1336, dwLoc04A4_1328);
										dwLoc0474_1322 = (dwLoc0474_1186, dwLoc0474_1321);
										edi_775 = (edi_554, edi_402);
										esp_582 = esp_407 - 4;
										esp_582->ptr0000 = 0x080B1F94;
										esp_582->dwFFFFFFFC = 0x0666;
										goto l080821E5;
									}
									edx_490 = eax_444;
									eax_491 = 0x7FFFFFFF - edi_402;
									if (eax_491 < v21_452)
									{
l080811B8:
										edx_1899 = (edx_662, edx_544, edx_588, edx_490);
										dwLoc04A4_1838 = (dwLoc04A4_1328, dwLoc04A4_1336, dwLoc04A4_1336, dwLoc04A4_1328);
										ecx_1008 = (ecx_660, ecx_548, ecx_586, ecx_483);
										esp_999 = esp_407;
										gs->tFFFFFFE0.u0 = 0x4B;
										goto l0807FBB8;
									}
									edi_494 = edi_402 + v21_452;
									goto l08081248;
								}
							}
						}
						goto l0807FBB8;
					}
					eax_257 = __printf_function_table;
					if (eax_257 == null)
					{
						eax_261 = __printf_modifier_table;
						if (eax_261 == 0x00)
						{
							eax_265 = __printf_va_arg_table;
							if (eax_265 == 0x00)
							{
								dwLoc04D8_1088 = 0x00;
								dwLoc04B8_1089 = 0x00;
								dwLoc04D0_1090 = 0x00;
								dwLoc04C0_1091 = ~0x00;
								dwLoc0470_1772 = (dwLoc0470_1755, dwLoc0470_1764);
								dwLoc0478_1471 = (dwLoc0478_1033, dwLoc0478_1477);
								dwLoc04C0_1425 = (dwLoc04C0_1091, dwLoc04C0_1431);
								dwLoc04D8_1385 = (dwLoc04D8_1088, dwLoc04D8_1391);
								dwLoc04D0_1365 = (dwLoc04D0_1090, dwLoc04D0_1371);
								dwLoc04A4_1362 = (dwLoc04A4, dwLoc04A4_1326);
								dwLoc047C_1359 = (dwLoc047C_1044, dwLoc047C_1160);
								dwLoc0480_1357 = (dwLoc0480_1043, dwLoc0480_1152);
								dwLoc0494_1353 = (dwLoc0494, dwLoc0494_1141);
								dwLoc04B8_1343 = (dwLoc04B8_1089, dwLoc04B8_1243);
								edi_824 = (edi_235, edi_961);
								esp_818 = fp;
								esi_297 = (esi_21, esi_399);
								Mem280 = (Mem278, Mem945);
								edx_279 = (edx_252, edx_944);
								ecx_281 = *((word32) edx_279 + 4);
								eax_282 = (word32) edx_279 + 4;
								dwLoc0450_1093 = eax_282;
								if (ecx_281 <= 122)
								{
									eax_978 = (word32) *((word32) ecx_281 + 0x080B1FA0);
									eax_981 = ((<anonymous> *[]) 0x080CCF40)[eax_978];
									eax_981();
									ecxOut = ecx_997;
									edxOut = edx_996;
									return eax_995;
								}
								dwLoc0484_1095.u0 = 0x00;
								if (ecx_281 != 0x00)
								{
l0807FD80:
									dwLoc0470_1771 = (dwLoc0470_1772, dwLoc0470_1764);
									dwLoc0478_1470 = (dwLoc0478_1471, dwLoc0478_1477);
									dwLoc04C0_1424 = (dwLoc04C0_1425, dwLoc04C0_1431);
									dwLoc04D8_1384 = (dwLoc04D8_1385, dwLoc04D8_1391);
									dwLoc04D0_1364 = (dwLoc04D0_1365, dwLoc04D0_1371);
									dwLoc04A4_1361 = (dwLoc04A4_1362, dwLoc04A4_1341);
									dwLoc0450_1360 = (dwLoc0450_1093, dwLoc0450_1314);
									dwLoc047C_1358 = (dwLoc047C_1359, dwLoc047C_1160);
									dwLoc0480_1356 = (dwLoc0480_1357, dwLoc0480_1152);
									dwLoc0494_1352 = (dwLoc0494_1353, dwLoc0494_1141);
									dwLoc0484_1345 = (dwLoc0484_1095, dwLoc0484_1340);
									dwLoc04B8_1342 = (dwLoc04B8_1343, dwLoc04B8_1312);
									esi_825 = (esi_297, esi_399);
									edi_823 = (edi_824, edi_774);
									esp_817 = fp;
									dwLoc0474_1344 = dwLoc04B8_1342;
									if (dwLoc0484_1345 != 0x00)
									{
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										stackArg0.u0 = <invalid>;
										free(gs, stackArg0, dwLoc0484_1345, out ecx_1947, out edx_1948);
										esp_835 = fp;
									}
l0807FAF6:
									dwLoc0470_1770 = (dwLoc0470_1771, dwLoc0470_1771, dwLoc0470_1755);
									dwLoc04A4_1570 = (dwLoc04A4_1361, dwLoc04A4_1361, dwLoc04A4);
									dwLoc0450_1568 = (dwLoc0450_1360, dwLoc0450_1360, dwLoc0450_1034);
									dwLoc04B8_1560 = (dwLoc04B8_1342, dwLoc04B8_1342, dwLoc04B8);
									dwLoc0484_1552 = (dwLoc0484_1345, dwLoc0484_1345, dwLoc0484_1554);
									dwLoc047C_1549 = (dwLoc047C_1358, dwLoc047C_1358, dwLoc047C_1044);
									dwLoc0480_1546 = (dwLoc0480_1356, dwLoc0480_1356, dwLoc0480_1043);
									dwLoc0494_1530 = (dwLoc0494_1352, dwLoc0494_1352, dwLoc0494);
									dwLoc0474_1490 = (dwLoc0474_1344, dwLoc0474_1344, dwLoc0474_1029);
									dwLoc0478_1469 = (dwLoc0478_1470, dwLoc0478_1470, dwLoc0478_1033);
									dwLoc04C0_1423 = (dwLoc04C0_1424, dwLoc04C0_1424, dwLoc04C0_1087);
									dwLoc04D8_1383 = (dwLoc04D8_1384, dwLoc04D8_1384, dwLoc04D8_1086);
									dwLoc04D0_1363 = (dwLoc04D0_1364, dwLoc04D0_1364, dwLoc04D0_1085);
									esi_870 = (esi_825, esi_825, esi_21);
									edi_865 = (edi_823, edi_823, edi_235);
									esp_837 = (esp_817, esp_835, esp_249);
									esp_839 = esp_837 - 0x0C;
									esp_839->dwFFFFFFFC = dwLoc04D0_1363;
									esp_839->dwFFFFFFF8 = dwLoc04C0_1423;
									esp_839->tFFFFFFF4 = eax_33;
									esp_839->ptrFFFFFFF0 = fp - 0x0408;
									esp_839->tFFFFFFEC = dwLoc0478_1469;
									esp_839->dwFFFFFFE8 = dwLoc0474_1490;
									esp_839->tFFFFFFE4 = edi_865;
									esp_839->ptrFFFFFFE0 = fp - 1100;
									esp_839->tFFFFFFDC = dwArg0C;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg0.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg20.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg24.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg28.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg32.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg36.u0 = <invalid>;
									eax_882 = printf_positional(gs, stackArg0, dwArg04, dwArg08, dwArg0C, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, out ecx_884, out edx_883);
									esp_886 = &esp_839->dwFFFFFFFC + 4;
									edi_888 = eax_882;
									esi_889 = esi_870;
									goto l0807FB48;
								}
								gs->tFFFFFFE0.u0 = 22;
								esi_298 = esi_297;
l0807FBB8:
								edx_1898 = (edx_279, edx_421, edx_449, edx_662, edx_1899, edx_544, edx_571, edx_480);
								dwLoc0478_1875 = (dwLoc0478_1471, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477, dwLoc0478_1477);
								dwLoc04C0_1868 = (dwLoc04C0_1425, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431, dwLoc04C0_1431);
								dwLoc04D8_1855 = (dwLoc04D8_1385, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391, dwLoc04D8_1391);
								dwLoc04D0_1846 = (dwLoc04D0_1365, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371, dwLoc04D0_1371);
								dwLoc04A4_1837 = (dwLoc04A4_1362, dwLoc04A4_1328, dwLoc04A4_1328, dwLoc04A4_1328, dwLoc04A4_1838, dwLoc04A4_1336, dwLoc04A4_1336, dwLoc04A4_1328);
								dwLoc0450_1834 = (dwLoc0450_1093, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254, dwLoc0450_1254);
								dwLoc04B8_1831 = (dwLoc04B8_1343, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233, dwLoc04B8_1233);
								dwLoc047C_1818 = (dwLoc047C_1359, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160, dwLoc047C_1160);
								dwLoc0480_1815 = (dwLoc0480_1357, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152, dwLoc0480_1152);
								dwLoc0494_1809 = (dwLoc0494_1353, dwLoc0494_1134, dwLoc0494_1134, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1141, dwLoc0494_1141);
								dwLoc0470_1779 = (dwLoc0470_1772, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764, dwLoc0470_1764);
								dwLoc0484_1097 = (dwLoc0484_1095, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221, dwLoc0484_1221);
								ecx_1007 = (ecx_281, ecx_422, ecx_446, ecx_660, ecx_1008, ecx_542, ecx_572, ecx_483);
								esi_311 = (esi_298, esi_399, esi_399, esi_399, esi_399, esi_399, esi_399, esi_399);
								esp_305 = (esp_818, esp_424, esp_448, esp_663, esp_999, esp_545, esp_574, esp_484);
								Mem300 = (Mem296, Mem425, Mem443, Mem652, Mem674, Mem534, Mem569, Mem478);
								if (dwLoc0484_1097 != 0x00)
								{
									esp_306 = esp_305 - 0x0C;
									esp_306->tFFFFFFFC = dwLoc0484_1097;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg0.u0 = <invalid>;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									stackArg4.u0 = <invalid>;
									free(gs, stackArg0, stackArg4, out ecx_317, out edx_316);
									esp_319 = (char *) &esp_306->tFFFFFFFC + 16;
									esi_321 = esi_311;
								}
								goto l0807FBD8;
							}
						}
					}
					dwLoc04D0_1085 = 0x00;
					dwLoc04D8_1086 = 0x00;
					dwLoc04C0_1087 = ~0x00;
					goto l0807FAF6;
				}
			}
		}
		else
		{
			*dwArg04 = eax_46 | 0x20;
			gs->tFFFFFFE0.u0 = 0x09;
		}
	}
	edx_1894 = (edx_40, edx_71, edx_40);
	ecx_1890 = (ecx_41, ecx_72, ecx_41);
	esp_408 = fp - 0x04FC;
	Mem395 = (Mem38, Mem69, Mem56);
	edi_77.u0 = ~0x00;
	goto l0807FB6B;
}

<anonymous> g_t807FB92 = <code>; // 0807FB92
// 080822D0: Register Eq_2 buffered_vfprintf(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __vfwprintf
Eq_2 buffered_vfprintf(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	struct Eq_96057 * esp_13 = fp - 16;
	do
	{
		esp_13 = esp_454 - 0x1000;
		esp_13->dw0000 = esp_13->dw0000;
		esp_454 = esp_13;
	} while (esp_13 != fp + ~0x800F);
	esp_13->dw7FF0 = gs->dw0014;
	esp_13->dwFFFFFE68 = 0x01;
	esp_13->dwFFFFFE64 = (word32) eax;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	word32 ecx_447;
	word32 ebp_448;
	word32 esi_449;
	Eq_2 edx_158;
	if (_IO_fwide(gs, stackArg4, stackArg8, out ecx_447, out edx_158, out ebp_448, out esi_449) != 0x01)
	{
		esp_13->dwFFFFFE78 = ~0x00;
		goto l08082473;
	}
	esp_13->dwFFFFFFE0 = (word32) eax;
	esp_13->dwFFFFFEEC = esp_13 - 212;
	esp_13->dwFFFFFF3C = esp_13 - 0x10;
	esp_13->dwFFFFFF38 = esp_13 - 0x10;
	esp_13->dwFFFFFF40 = &esp_13->dw7FF0;
	ui32 eax_69 = *((word32) eax + 60);
	esp_13->dwFFFFFEFC = 0x01;
	esp_13->dwFFFFFED0 = eax_69;
	esp_13->dwFFFFFE94 = 4222451716;
	esp_13->dwFFFFFEDC = 0x00;
	esp_13->dwFFFFFF28 = 0x080CF2A0;
	esp_13->dwFFFFFE6C = (word32) ecx;
	esp_13->dwFFFFFE68 = (word32) edx;
	esp_13->dwFFFFFE64 = esp_13 - 0x016C;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	word32 edx_83;
	Eq_2 ecx_84;
	esp_13->dwFFFFFE78 = (word32) __vfwprintf(gs, stackArg4, stackArg8, stackArg12, out ecx_84, out edx_83);
	esp_13->dwFFFFFE7C = 0x00;
	esp_13->dwFFFFFE88 = (word32) eax;
	esp_13->dwFFFFFE84 = 0x08082540;
	struct Eq_96196 * eax_153;
	Mem113 = Mem95;
	Eq_2 ecx_124 = ecx_84;
	struct Eq_96193 * esp_149 = esp_454 - 0x118C;
	ui32 eax_114 = *eax;
	if ((eax_114 & 0x8000) != 0x00)
	{
		eax_153 = esp_149->ptr0078;
		edx_158 = eax_153->dw0010 - eax_153->dw000C;
		if (edx_158 <= 0x00)
			goto l08082459;
	}
	else
	{
		Eq_2 edx_119 = *((word32) eax + 72);
		Eq_2 ebp_121 = gs->t0008;
		if (*((word32) edx_119 + 8) != ebp_121)
		{
			ecx_124.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_131;
			if (!__cmpxchg(*edx_119, 0x01, eax_114 & 0x8000, out eax_131))
				ecx_124 = __lll_lock_wait_private(eax_131, edx_119, gs);
			edx_119 = *((word32) eax + 72);
			*((word32) edx_119 + 8) = ebp_121;
		}
		eax_153 = esp_149->ptr0078;
		*((word32) edx_119 + 4) = (word32) *((word32) edx_119 + 4) + 1;
		edx_158 = eax_153->dw0010 - eax_153->dw000C;
		if (edx_158 <= 0x00)
		{
l0808242A:
			if ((*eax & 0x8000) == 0x00)
			{
				edx_158 = *((word32) eax + 72);
				Eq_2 v19_239 = *((word32) edx_158 + 4) - 0x01;
				*((word32) edx_158 + 4) = v19_239;
				if (v19_239 == 0x00)
				{
					((word32) edx_158 + 8)->u0 = 0x00;
					if (gs->t000C != 0x00)
						__lock();
					word32 v20_250 = *edx_158 - 0x01;
					*edx_158 = v20_250;
					if (v20_250 != 0x00)
						__lll_unlock_wake_private(edx_158, ecx_124, edx_158, gs);
				}
			}
l08082459:
			if (esp_149->dw0008 != 0x00)
			{
				esp_149->dwFFFFFFF4 = 0x00;
				esp_149->tFFFFFFF0 = &esp_149->dw000C + 1;
				fn00000000();
			}
l08082473:
			Eq_2 ecx_317 = dwLoc20 ^ gs->dw0014;
			if (ecx_317 != 0x00)
			{
				Eq_2 ecx_330;
				word32 edx_453;
				__stack_chk_fail(out ecx_330, out edx_453);
				Eq_2 edx_333;
				Eq_2 eax_332 = __funlockfile(ecx_330, gs, dwLoc8198, out edx_333);
				ecxOut = ecx_330;
				edxOut = edx_333;
				return eax_332;
			}
			else
			{
				ecxOut = ecx_317;
				edxOut = edx_158;
				return dwLoc8198;
			}
		}
	}
	Eq_2 ebp_171 = *((word32) eax + 0x0094);
	esp_149->dw000C = edx_158 >> 0x02;
	word32 ecx_172 = 0x080CEFA0;
	word32 edx_177 = 0x0354;
	if (ebp_171 >= 135066356)
	{
		_IO_vtable_check(out ecx_172, out edx_177);
		eax_153 = esp_149->ptr0078;
	}
	int32 edi_204 = esp_149->dw000C;
	esp_149->dwFFFFFFF8 = edi_204;
	esp_149->dwFFFFFFF4 = eax_153->dw000C;
	esp_149->tFFFFFFF0 = eax;
	int32 eax_220;
	(*((word32) ebp_171 + 28))();
	word32 eax_226 = ~0x00;
	if (eax_220 == edi_204)
		eax_226 = esp_149->dw0004;
	esp_149->dw0004 = eax_226;
	goto l0808242A;
}

// 08082540: Register Eq_2 __funlockfile(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 edxOut)
// Called from:
//      buffered_vfprintf
Eq_2 __funlockfile(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & edxOut)
{
	Eq_2 edx_6 = *((word32) dwArg04 + 72);
	Eq_2 v5_7 = *((word32) edx_6 + 4) - 0x01;
	*((word32) edx_6 + 4) = v5_7;
	Eq_2 eax_25 = dwArg04;
	if (v5_7 == 0x00)
	{
		((word32) edx_6 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		word32 v9_17 = *edx_6 - 0x01;
		*edx_6 = v9_17;
		if (v9_17 != 0x00)
			eax_25 = __lll_unlock_wake_private(edx_6, ecx, edx_6, gs);
	}
	edxOut = edx_6;
	return eax_25;
}

// 08082570: Register (ptr32 (ptr32 byte)) read_int(Register (ptr32 (ptr32 byte)) eax)
// Called from:
//      __parse_one_specmb
byte ** read_int(byte ** eax)
{
	byte * ebx_19 = *eax;
	byte * ebx_21 = ebx_19 + 1;
	byte ** ecx_22 = (word32) *ebx_19 - 0x30;
	while (true)
	{
		*eax = (byte **) ebx_21;
		Eq_96457 edx_27 = (word32) *ebx_21;
		if (edx_27 > 0x39)
			break;
		if (ecx_22 >= null)
		{
			if (ecx_22 > (byte **) 0x0CCCCCCC)
				ecx_22 = (byte **) ~0x00;
			else
			{
				ui32 ebp_47 = ecx_22 * 0x05;
				ecx_22 = edx_27 - 0x30 + ebp_47 * 0x02;
				if (0x7FFFFFFF - (edx_27 - 0x30) < ebp_47 * 0x02)
					ecx_22 = (byte **) ~0x00;
			}
		}
		++ebx_21;
	}
	return ecx_22;
}

// 080825D0: Register Eq_2 __parse_one_specmb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out (ptr32 Eq_75214) ebpOut, Register out Eq_2 ediOut)
// Called from:
//      printf_positional
Eq_2 __parse_one_specmb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, struct Eq_75214 & ebpOut, union Eq_2 & ediOut)
{
	((word32) dwArg0C + 36)->u0 = ~0x00;
	*((word32) dwArg0C + 16) = 0x20;
	*((word32) dwArg0C + 0x0C) &= 0xE207;
	up32 edx_28 = (word32) *((word32) dwArg04 + 1);
	Eq_2 edi_19 = dwArg04;
	struct Eq_75214 * ebp_146 = (word32) dwArg04 + 1;
	struct Eq_75214 * dwArg04_518 = (word32) dwArg04 + 1;
	up32 eax_29 = edx_28;
	if (edx_28 <= 0x39)
	{
		up32 eax_34 = read_int(fp + 0x04);
		if (eax_34 != 0x00 && *((word32) dwArg04 + 1) == 0x24)
		{
			ebp_146 = (word32) dwArg04 + 2;
			dwArg04_518 = (word32) dwArg04 + 2;
			if (eax_34 != ~0x00)
			{
				*((word32) dwArg0C + 36) = eax_34 - 0x01;
				edi_19 = dwArg10;
				if (*dwArg10 >= eax_34)
					eax_34 = (up32) *dwArg10;
				*dwArg10 = eax_34;
			}
			eax_29 = (word32) *((word32) dwArg04 + 2);
		}
		else
		{
			dwArg04_518 = (word32) dwArg04 + 1;
			eax_29 = (word32) *((word32) dwArg04 + 1);
		}
	}
	cu8 al_72 = (byte) (eax_29 - 0x20);
	if (al_72 <= 0x29)
	{
		ui32 eax_502 = (word32) al_72;
		<anonymous> * ecx_504 = g_a80B201C[eax_502 * 0x04] + 0x080CE000;
		Eq_2 eax_509;
		ecx_504();
		ebxOut = 0x080CE000;
		ebpOut = ebp_146;
		ediOut = edi_19;
		return eax_509;
	}
	if ((*((word32) dwArg0C + 0x0C) & 0x20) != 0x00)
		*((word32) dwArg0C + 16) = 0x20;
	Eq_2 edi_147;
	((word32) dwArg0C + 32)->u0 = ~0x00;
	*((word32) dwArg0C + 4) = 0x00;
	up32 eax_91 = (word32) ebp_146->t0000;
	if ((byte) eax_91 != 0x2A)
	{
		edi_147.u0 = 0x00;
		if (eax_91 <= 0x39)
		{
			up32 eax_170 = read_int(fp + 0x04);
			if (eax_170 != ~0x00)
				*((word32) dwArg0C + 4) = eax_170;
			ebp_146 = dwArg04_518;
		}
		goto l0808268C;
	}
	struct Eq_75214 * edi_95 = &ebp_146->b0001;
	dwArg04_518 = edi_95;
	if ((word32) ebp_146->b0001 <= 0x39)
	{
		up32 eax_106 = read_int(fp + 0x04);
		if (eax_106 != 0x00 && edi_95->t0000 == 0x24)
		{
			if (eax_106 != ~0x00)
			{
				*((word32) dwArg0C + 32) = eax_106 - 0x01;
				if (*dwArg10 >= eax_106)
					eax_106 = (up32) *dwArg10;
				*dwArg10 = eax_106;
			}
			dwArg04_518 = (struct Eq_75214 *) &edi_95->b0001;
		}
		if (*((word32) dwArg0C + 32) >= 0x00)
		{
			ebp_146 = dwArg04_518;
			edi_147.u0 = 0x00;
l0808268C:
			((word32) dwArg0C + 28)->u0 = ~0x00;
			*dwArg0C = ~0x00;
			if (ebp_146->t0000 != 0x2E)
			{
l080826A3:
				struct Eq_75214 * edx_338;
				Eq_2 eax_339;
				Eq_2 eax_304 = __printf_modifier_table;
				*((word32) dwArg0C + 0x0C) &= 0xFDF8;
				if (eax_304 != 0x00 && *((word32) eax_304 + (word32) ebp_146->t0000 * 0x04) != 0x00)
				{
					if (__handle_registered_modifier_mb(fp + 0x04, dwArg0C) == 0x00)
					{
						edx_338 = dwArg04_518;
						eax_339 = &dwArg04_518->b0001;
						goto l08082747;
					}
					ebp_146 = dwArg04_518;
				}
				Eq_2 edx_342 = &ebp_146->b0001;
				cu8 al_347 = (byte) ((word32) ebp_146->t0000 - 0x4C);
				if (al_347 <= 0x2E)
				{
					ui32 eax_494 = (word32) al_347;
					<anonymous> * ecx_496 = g_a80B20C4[eax_494 * 0x04] + 0x080CE000;
					Eq_2 eax_499;
					ecx_496();
					ebxOut = 0x080CE000;
					ebpOut = ebp_146;
					ediOut = edi_147;
					return eax_499;
				}
				eax_339 = edx_342;
				edx_338 = ebp_146;
l08082747:
				Eq_2 (* eax_357)[] = __printf_function_table;
				ui32 edx_359 = (word32) edx_338->t0000;
				*((word32) dwArg0C + 48) = ~0x00;
				*((word32) dwArg0C + 8) = edx_359;
				if (eax_357 != null)
				{
					<anonymous> * eax_368 = *((word32) __printf_arginfo_table + edx_359 * 0x04);
					if (eax_368 != null)
					{
						int32 eax_407;
						eax_368();
						edx_359 = (ui32) *((word32) dwArg0C + 8);
						*((word32) dwArg0C + 44) = eax_407;
						if (eax_407 >= 0x00)
						{
							if (*((word32) dwArg0C + 36) == ~0x00 && eax_407 != 0x00)
							{
								*((word32) dwArg0C + 36) = dwArg08;
								edi_147 = (word64) edi_147.u0 + eax_407;
							}
							goto l08082938;
						}
					}
				}
				*((word32) dwArg0C + 44) = 0x01;
				uint32 eax_426 = edx_359 - 0x41;
				if (eax_426 <= 55)
				{
					struct Eq_75214 * ebp_487 = g_a80B2180[eax_426 * 0x04] + 0x080CE000;
					Eq_2 eax_491;
					ebp_487();
					ebxOut = 0x080CE000;
					ebpOut = ebp_487;
					ediOut = edi_147;
					return eax_491;
				}
				*((word32) dwArg0C + 44) = 0x00;
l08082938:
				if (edx_359 != 0x00)
				{
					*((word32) dwArg0C + 20) = eax_339;
					*((word32) dwArg0C + 24) = strchrnul(eax_339, 0x25);
					ebxOut = ebx;
					ebpOut = ebp;
					ediOut = edi;
					return edi_147;
				}
				else
				{
					*((word32) dwArg0C + 24) = eax_339 - 0x01;
					*((word32) dwArg0C + 20) = eax_339 - 0x01;
					ebxOut = ebx;
					ebpOut = ebp;
					ediOut = edi;
					return edi_147;
				}
			}
			struct Eq_75214 * edx_190 = &ebp_146->b0001;
			up32 eax_193 = (word32) ebp_146->b0001;
			dwArg04_518 = edx_190;
			if ((byte) eax_193 == 0x2A)
			{
				struct Eq_75214 * edx_197 = &ebp_146->b0002;
				dwArg04_518 = edx_197;
				if ((word32) ebp_146->b0002 <= 0x39)
				{
					up32 eax_205 = read_int(fp + 0x04);
					if (eax_205 != 0x00 && edx_197->t0000 == 0x24)
					{
						if (eax_205 != ~0x00)
						{
							*((word32) dwArg0C + 28) = eax_205 - 0x01;
							if (*dwArg10 >= eax_205)
								eax_205 = (up32) *dwArg10;
							*dwArg10 = eax_205;
						}
						dwArg04_518 = (struct Eq_75214 *) &edx_197->b0001;
					}
					if (*((word32) dwArg0C + 28) >= 0x00)
						goto l080829B8;
				}
				*((word32) dwArg0C + 28) = dwArg08;
				edi_147 = (word32) edi_147 + 1;
				dwArg04_518 = edx_197;
				ebp_146 = edx_197;
				dwArg08 = (word32) dwArg08 + 1;
				goto l080826A3;
			}
			else
			{
				if (eax_193 > 0x39)
				{
					*dwArg0C = 0x00;
					ebp_146 = edx_190;
					goto l080826A3;
				}
				up32 eax_271 = read_int(fp + 0x04);
				if (eax_271 != ~0x00)
					*dwArg0C = eax_271;
l080829B8:
				ebp_146 = dwArg04_518;
				goto l080826A3;
			}
		}
	}
	*((word32) dwArg0C + 32) = dwArg08;
	dwArg04_518 = edi_95;
	ebp_146 = edi_95;
	edi_147.u0 = 0x01;
	dwArg08 = (word32) dwArg08 + 1;
	goto l0808268C;
}

// 08082BA0: Register (ptr32 (ptr32 Eq_96909)) read_int(Register (ptr32 (ptr32 Eq_96909)) eax)
// Called from:
//      __parse_one_specwc
struct Eq_96909 ** read_int(struct Eq_96909 ** eax)
{
	struct Eq_96909 * ecx_17 = *eax;
	up32 esi_20 = ecx_17->dw0004;
	struct Eq_96909 * ecx_19 = &ecx_17->dw0004;
	struct Eq_96909 * ebx_21 = &ecx_17->dw0004;
	int32 esi_22 = esi_20 - 0x30;
	struct Eq_96909 ** edx_23 = ecx_17->dw0000 - 0x30;
	if (esi_20 <= 0x39)
	{
		do
		{
			if (edx_23 >= null)
			{
				if (edx_23 <= (struct Eq_96909 **) 0x0CCCCCCC)
				{
					ui32 edx_33 = edx_23 * 0x05;
					if (0x7FFFFFFF - esi_22 < edx_33 * 0x02)
						goto l08082BF8;
					edx_23 = edx_33 * 0x02 + esi_22;
				}
				else
				{
l08082BF8:
					struct Eq_96909 * ebx_43 = &ebx_21->dw0004;
					if (ebx_43->dw0000 > 0x39)
					{
						*eax = (struct Eq_96909 **) ebx_43;
						return (struct Eq_96909 **) ~0x00;
					}
					++ecx_19;
					edx_23 = (struct Eq_96909 **) ~0x00;
					if (ecx_19->dw0000 > 0x39)
					{
						*eax = (struct Eq_96909 **) ecx_19;
						return (struct Eq_96909 **) ~0x00;
					}
				}
			}
			ecx_19 = (struct Eq_96909 *) &ecx_19->dw0004;
			up32 esi_89 = ecx_19->dw0000;
			ebx_21 = ecx_19;
			esi_22 = esi_89 - 0x30;
		} while (esi_89 <= 0x39);
	}
	*eax = (struct Eq_96909 **) ebx_21;
	return edx_23;
}

// 08082C40: Register word32 __parse_one_specwc(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 ediOut)
// Called from:
//      printf_positional
word32 __parse_one_specwc(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & ediOut)
{
	cui16 ax_25 = *((word32) dwArg0C + 0x0C);
	((word32) dwArg0C + 36)->u0 = ~0x00;
	*((word32) dwArg0C + 16) = 0x20;
	*((word32) dwArg0C + 0x0C) = SEQ(SLICE(ax_25 & 0xE207, byte, 8) | 0x04, (byte) (ax_25 & 0xE207));
	Eq_2 ebp_111 = dwArg04;
	Eq_2 edi_23 = (word32) dwArg04 + 4;
	Eq_2 dwArg04_533 = (word32) dwArg04 + 4;
	up32 eax_33 = *((word32) dwArg04 + 4);
	if (eax_33 <= 0x39)
	{
		up32 eax_38 = read_int(fp + 0x04);
		if (eax_38 != 0x00 && *((word32) dwArg04 + 4) == 0x24)
		{
			edi_23 = (word32) dwArg04 + 8;
			dwArg04_533 = (word32) dwArg04 + 8;
			if (eax_38 != ~0x00)
			{
				*((word32) dwArg0C + 36) = eax_38 - 0x01;
				if (*dwArg10 >= eax_38)
					eax_38 = (up32) *dwArg10;
				*dwArg10 = eax_38;
			}
			eax_33 = (up32) *((word32) dwArg04 + 8);
		}
		else
		{
			dwArg04_533 = (word32) dwArg04 + 4;
			eax_33 = (up32) *((word32) dwArg04 + 4);
		}
	}
	uint32 eax_80 = eax_33 - 0x20;
	if (eax_80 <= 0x29)
	{
		<anonymous> * ecx_521 = g_a80B2260[eax_80 * 0x04] + 0x080CE000;
		word32 eax_523;
		ecx_521();
		ebxOut = 0x080CE000;
		ebpOut = dwArg04;
		ediOut = edi_23;
		return eax_523;
	}
	Eq_2 dwArg04_541 = dwArg04_533;
	Eq_2 edi_106 = dwArg04_533;
	if ((*((word32) dwArg0C + 0x0C) & 0x20) != 0x00)
		*((word32) dwArg0C + 16) = 0x20;
	word32 dwLoc24_550;
	((word32) dwArg0C + 32)->u0 = ~0x00;
	*((word32) dwArg0C + 4) = 0x00;
	up32 eax_107 = *dwArg04_533;
	if (eax_107 != 0x2A)
	{
		dwLoc24_550 = 0x00;
		if (eax_107 <= 0x39)
		{
			up32 eax_181 = read_int(fp + 0x04);
			if (eax_181 != ~0x00)
				*((word32) dwArg0C + 4) = eax_181;
			edi_106 = dwArg04_533;
		}
		goto l08082D04;
	}
	ebp_111 = (word32) dwArg04_533 + 4;
	dwArg04_541 = ebp_111;
	if (*((word32) dwArg04_533 + 4) <= 0x39)
	{
		up32 eax_119 = read_int(fp + 0x04);
		if (eax_119 != 0x00 && *ebp_111 == 0x24)
		{
			if (eax_119 != ~0x00)
			{
				*((word32) dwArg0C + 32) = eax_119 - 0x01;
				if (*dwArg10 >= eax_119)
					eax_119 = (up32) *dwArg10;
				*dwArg10 = eax_119;
			}
			dwArg04_541 = (word32) ebp_111 + 4;
		}
		if (*((word32) dwArg0C + 32) >= 0x00)
		{
			edi_106 = dwArg04_541;
			dwLoc24_550 = 0x00;
l08082D04:
			((word32) dwArg0C + 28)->u0 = ~0x00;
			*dwArg0C = ~0x00;
			if (*edi_106 != 0x2E)
			{
l08082D1A:
				Eq_2 edx_345;
				Eq_2 edx_310 = __printf_modifier_table;
				*((word32) dwArg0C + 0x0C) &= 0xFDF8;
				int32 eax_317 = *edi_106;
				if (edx_310 != 0x00 && *((word32) edx_310 + eax_317 * 0x04) != 0x00)
				{
					if (__handle_registered_modifier_wc(fp + 0x04, dwArg0C) == 0x00)
					{
						edx_345 = (word32) dwArg04_541 + 4;
						eax_317 = (int32) *dwArg04_541;
l08082DE0:
						Eq_2 (* edx_362)[] = __printf_function_table;
						*((word32) dwArg0C + 8) = eax_317;
						*((word32) dwArg0C + 48) = ~0x00;
						if (edx_362 != null && eax_317 <= 0xFF)
						{
							<anonymous> * edx_374 = *((word32) __printf_arginfo_table + eax_317 * 0x04);
							if (edx_374 != null)
							{
								int32 eax_424;
								edx_374();
								*((word32) dwArg0C + 44) = eax_424;
								eax_317 = (int32) *((word32) dwArg0C + 8);
								if (eax_424 >= 0x00)
								{
									if (*((word32) dwArg0C + 36) == ~0x00 && eax_424 != 0x00)
									{
										*((word32) dwArg0C + 36) = dwArg08;
										dwLoc24_550 += eax_424;
									}
									goto l08082F79;
								}
							}
						}
						*((word32) dwArg0C + 44) = 0x01;
						uint32 edx_446 = eax_317 - 0x41;
						if (edx_446 <= 55)
						{
							Eq_2 edi_505 = g_a80B23C4[edx_446 * 0x04] + 0x080CE000;
							word32 eax_509;
							edi_505();
							ebxOut = 0x080CE000;
							ebpOut = ebp_111;
							ediOut = edi_505;
							return eax_509;
						}
						*((word32) dwArg0C + 44) = 0x00;
l08082F79:
						if (eax_317 != 0x00)
						{
							*((word32) dwArg0C + 20) = edx_345;
							*((word32) dwArg0C + 24) = wcschrnul(edx_345, 0x25);
							ebxOut = ebx;
							ebpOut = ebp;
							ediOut = edi;
							return dwLoc24_550;
						}
						else
						{
							*((word32) dwArg0C + 24) = edx_345 - 0x04;
							*((word32) dwArg0C + 20) = edx_345 - 0x04;
							ebxOut = ebx;
							ebpOut = ebp;
							ediOut = edi;
							return dwLoc24_550;
						}
					}
					edi_106 = dwArg04_541;
					eax_317 = (int32) *dwArg04_541;
				}
				edx_345 = (word32) edi_106 + 4;
				uint32 ecx_352 = eax_317 - 0x4C;
				if (ecx_352 <= 0x2E)
				{
					Eq_2 ebp_514 = g_a80B2308[ecx_352 * 0x04] + 0x080CE000;
					word32 eax_516;
					ebp_514();
					ebxOut = 0x080CE000;
					ebpOut = ebp_514;
					ediOut = edi_106;
					return eax_516;
				}
				goto l08082DE0;
			}
			Eq_2 edx_202 = (word32) edi_106 + 4;
			up32 eax_201 = *((word32) edi_106 + 4);
			dwArg04_541 = edx_202;
			if (eax_201 == 0x2A)
			{
				Eq_2 edx_208 = (word32) edi_106 + 8;
				dwArg04_541 = edx_208;
				if (*((word32) edi_106 + 8) <= 0x39)
				{
					up32 eax_215 = read_int(fp + 0x04);
					if (eax_215 != 0x00 && *edx_208 == 0x24)
					{
						if (eax_215 != ~0x00)
						{
							*((word32) dwArg0C + 28) = eax_215 - 0x01;
							if (*dwArg10 >= eax_215)
								eax_215 = (up32) *dwArg10;
							*dwArg10 = eax_215;
						}
						dwArg04_541 = (word32) edx_208 + 4;
					}
					if (*((word32) dwArg0C + 28) >= 0x00)
						goto l08083070;
				}
				*((word32) dwArg0C + 28) = dwArg08;
				++dwLoc24_550;
				edi_106 = edx_208;
				dwArg04_541 = edx_208;
				dwArg08 = (word32) dwArg08 + 1;
				goto l08082D1A;
			}
			else
			{
				if (eax_201 > 0x39)
				{
					*dwArg0C = 0x00;
					edi_106 = edx_202;
					goto l08082D1A;
				}
				up32 eax_276 = read_int(fp + 0x04);
				if (eax_276 != ~0x00)
					*dwArg0C = eax_276;
l08083070:
				edi_106 = dwArg04_541;
				goto l08082D1A;
			}
		}
	}
	*((word32) dwArg0C + 32) = dwArg08;
	dwArg04_541 = ebp_111;
	edi_106 = ebp_111;
	dwLoc24_550 = 0x01;
	dwArg08 = (word32) dwArg08 + 1;
	goto l08082D04;
}

// 08083260: Register word32 _IO_file_doallocate(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _IO_wfile_doallocate
word32 _IO_file_doallocate(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 ebp_102;
	Eq_2 esp_18 = fp - 0x8C;
	ui32 eax_20 = gs->dw0014;
	if (*((word32) dwArg04 + 56) >= 0x00)
	{
		Eq_2 ebx_28 = *((word32) dwArg04 + 0x0094);
		if (ebx_28 >= 135066356)
		{
			word32 ecx_291;
			word32 edx_292;
			_IO_vtable_check(out ecx_291, out edx_292);
			esp_18.u0 = <invalid>;
		}
		struct Eq_97425 * esp_44 = esp_18 - 0x08;
		esp_44->ptrFFFFFFFC = &esp_44->ptrFFFFFFFC + 6;
		esp_44->tFFFFFFF8 = dwArg04;
		int32 eax_57;
		(*((word32) ebx_28 + 72))();
		struct Eq_97440 * esp_100 = &esp_44->ptrFFFFFFFC + 3;
		if (eax_57 >= 0x00)
		{
			if ((esp_44->dw0024 & 0xF000) != 0x2000)
			{
l080832D7:
				ebp_102 = esp_100->t0040;
				if (ebp_102 <= 0x1FFF)
					goto l080832E8;
				goto l08083330;
			}
			uint32 ebx_70 = esp_44->dw0038;
			if ((__shrd(esp_44->dw0034, ebx_70, 0x08) & 0x0FFF | ebx_70 & ~0x0FFF) > 0x8F)
			{
				Eq_2 ebp_83 = gs->tFFFFFFE0;
				esp_44->tFFFFFFF8 = *((word32) dwArg04 + 56);
				word32 ecx_298;
				struct Eq_226 * eax_87 = __isatty(gs, out ecx_298);
				gs->tFFFFFFE0 = ebp_83;
				Eq_2 esp_90 = <invalid>;
				esp_100 = (word32) esp_90 + 16;
				if (eax_87 == null)
					goto l080832D7;
			}
			ebp_102 = esp_100->t0040;
			*dwArg04 |= 0x0200;
			if (ebp_102 <= 0x1FFF)
			{
l080832E8:
				word32 ebp_136;
				word32 edi_139;
				Eq_2 esi_141;
				word32 ebx_297;
				word32 ecx_295;
				word32 edx_296;
				Eq_2 eax_135 = __libc_malloc(gs, dwLocA0, ebp_102, out ecx_295, out edx_296, out ebx_297, out ebp_136, out esi_141, out edi_139);
				if (eax_135 != 0x00)
					_IO_setb(esi_141, eax_135, (word32) eax_135 + ebp_136, 0x01);
				if ((eax_20 ^ gs->dw0014) == 0x00)
					return edi;
				word32 ecx_293;
				word32 edx_294;
				__stack_chk_fail(out ecx_293, out edx_294);
				fputs(gs, dwArg04, dwArg08);
				return edi_139;
			}
		}
	}
l08083330:
	ebp_102.u0 = 0x2000;
	goto l080832E8;
}

// 080833D0: void fputs(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      malloc_info
//      _IO_file_doallocate
void fputs(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	word32 edx_325;
	word32 ecx_324;
	Eq_2 eax_25 = strlen(dwArg04, out ecx_324, out edx_325);
	Eq_2 esp_100 = fp - 44;
	ui32 eax_34 = *dwArg08;
	if ((eax_34 & 0x8000) == 0x00)
	{
		Eq_2 edx_39 = *((word32) dwArg08 + 72);
		Eq_2 ecx_41 = gs->t0008;
		if (*((word32) edx_39 + 8) != ecx_41)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_52;
			if (!__cmpxchg(*edx_39, 0x01, eax_34 & 0x8000, out eax_52))
				__lll_lock_wait_private(eax_52, edx_39, gs);
			edx_39 = *((word32) dwArg08 + 72);
			*((word32) edx_39 + 8) = ecx_41;
		}
		*((word32) edx_39 + 4) = (word32) *((word32) edx_39 + 4) + 1;
	}
	Eq_2 ecx_152;
	Eq_2 eax_78 = *((word32) dwArg08 + 0x0068);
	if (eax_78 == 0x00)
		((word32) dwArg08 + 0x0068)->u0 = ~0x00;
	else if (eax_78 != ~0x00)
		goto l0808349D;
	Eq_2 ecx_87 = *((word32) dwArg08 + 0x0094);
	if (ecx_87 >= 135066356)
	{
		word32 edx_327;
		word32 ecx_326;
		_IO_vtable_check(out ecx_326, out edx_327);
		esp_100.u0 = <invalid>;
	}
	struct Eq_97622 * esp_114 = esp_100 - 0x04;
	esp_114->tFFFFFFFC = eax_25;
	esp_114->tFFFFFFF8 = dwArg04;
	esp_114->tFFFFFFF4 = dwArg08;
	Eq_2 eax_147;
	(*((word32) ecx_87 + 28))();
	ecx_152.u0 = 0x01;
	if (eax_25 == eax_147)
	{
		if ((*dwArg08 & 0x8000) != 0x00)
			return;
l080834AA:
		Eq_2 edx_166 = *((word32) dwArg08 + 72);
		word32 v18_167 = *((word32) edx_166 + 4) - 0x01;
		*((word32) edx_166 + 4) = v18_167;
		if (v18_167 != 0x00)
			return;
		*((word32) edx_166 + 8) = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		word32 v19_178 = *edx_166 - 0x01;
		*edx_166 = v19_178;
		if (v19_178 != 0x00)
			__lll_unlock_wake_private(edx_166, ecx_152, edx_166, gs);
		return;
	}
l0808349D:
	ecx_152.u0 = ~0x00;
	if ((*dwArg08 & 0x8000) != 0x00)
		return;
	goto l080834AA;
}

// 08083500: void _IO_wfile_doallocate(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wfile_doallocate(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_13 = dwArg04;
	word32 eax_16 = *((word32) dwArg04 + 28);
	if (eax_16 == 0x00)
	{
		edi_13 = _IO_file_doallocate(gs, dwArg04, dwLoc18);
		eax_16 = (word32) *((word32) edi_13 + 28);
	}
	uint32 ecx_43 = *((word32) edi_13 + 32) - eax_16;
	uint32 eax_45 = ecx_43;
	uint32 edx_46 = ecx_43 + 0x03 >> 0x02;
	if ((*edi_13 & 0x01) != 0x00)
		eax_45 = edx_46;
	Eq_2 edi_65;
	word32 esi_67;
	word32 ebx_153;
	word32 ecx_151;
	word32 edx_152;
	word32 ebp_154;
	Eq_2 eax_61 = __libc_malloc(gs, dwLoc20, eax_45 * 0x04, out ecx_151, out edx_152, out ebx_153, out ebp_154, out esi_67, out edi_65);
	if (eax_61 == 0x00)
		return;
	word32 edx_155;
	_IO_wsetb(edi_65, eax_61, (word32) eax_61 + esi_67, 0x01, out edx_155);
}

// 08083590: void fwrite(Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04, Stack int32 dwArg08, Stack int32 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __malloc_stats
void fwrite(struct Eq_9 * gs, ptr32 dwArg04, int32 dwArg08, int32 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 esp_119 = fp - 44;
	Eq_2 ebx_21 = dwArg08 *s dwArg0C;
	if (ebx_21 == 0x00)
		return;
	ui32 eax_26 = *dwArg10;
	if ((eax_26 & 0x8000) == 0x00)
	{
		Eq_2 edx_31 = *((word32) dwArg10 + 72);
		Eq_2 ecx_33 = gs->t0008;
		if (*((word32) edx_31 + 8) != ecx_33)
		{
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_44;
			if (!__cmpxchg(*edx_31, 0x01, eax_26 & 0x8000, out eax_44))
				__lll_lock_wait_private(eax_44, edx_31, gs);
			edx_31 = *((word32) dwArg10 + 72);
			*((word32) edx_31 + 8) = ecx_33;
		}
		*((word32) edx_31 + 4) = (word32) *((word32) edx_31 + 4) + 1;
	}
	word32 edi_101;
	Eq_2 edx_102;
	Eq_2 ecx_181;
	Eq_2 eax_70 = *((word32) dwArg10 + 0x0068);
	if (eax_70 == 0x00)
		((word32) dwArg10 + 0x0068)->u0 = ~0x00;
	else if (eax_70 != ~0x00)
	{
		if ((*dwArg10 & 0x8000) != 0x00)
			return;
		ecx_181 = *((word32) dwArg10 + 72);
		word32 v20_80 = *((word32) ecx_181 + 4) - 0x01;
		*((word32) ecx_181 + 4) = v20_80;
		if (v20_80 != 0x00)
			return;
		edi_101 = 0x00;
		edx_102.u0 = 0x00;
		goto l0808365D;
	}
	Eq_2 ecx_108 = *((word32) dwArg10 + 0x0094);
	if (ecx_108 >= 135066356)
	{
		word32 ecx_389;
		word32 edx_390;
		_IO_vtable_check(out ecx_389, out edx_390);
		esp_119.u0 = <invalid>;
	}
	struct Eq_97846 * esp_133 = esp_119 - 0x04;
	esp_133->tFFFFFFFC = ebx_21;
	esp_133->ptrFFFFFFF8 = dwArg04;
	esp_133->tFFFFFFF4 = dwArg10;
	Eq_2 eax_166;
	word32 ecx_168;
	(*((word32) ecx_108 + 28))();
	edx_102 = eax_166;
	edi_101 = SEQ(SLICE(eax_166, word24, 8), (int8) (eax_166 == ~0x00));
	if ((*dwArg10 & 0x8000) != 0x00)
	{
l0808367B:
		if (ebx_21 == edx_102 || (byte) edi_101 != 0x00)
			;
		return;
	}
	ecx_181 = *((word32) dwArg10 + 72);
	word32 v19_182 = *((word32) ecx_181 + 4) - 0x01;
	*((word32) ecx_181 + 4) = v19_182;
	if (v19_182 != 0x00)
		goto l0808367B;
l0808365D:
	*((word32) ecx_181 + 8) = 0x00;
	if (gs->t000C != 0x00)
		__lock();
	word32 v21_193 = *ecx_181 - 0x01;
	*ecx_181 = v21_193;
	if (v21_193 != 0x00)
		__lll_unlock_wake_private(ecx_181, ecx_181, edx_102, gs);
	goto l0808367B;
}

// 08083700: Register Eq_2 _IO_getdelim(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __gconv_read_conf
//      __readonly_area
Eq_2 _IO_getdelim(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 dwLoc28_414;
	if (dwArg04 == 0x00 || dwArg08 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 22;
		dwLoc28_414.u0 = ~0x00;
		return dwLoc28_414;
	}
	Eq_2 ecx_146;
	Eq_2 edx_353;
	byte ah_344;
	ui32 ecx_38 = *dwArg10;
	if ((ecx_38 & 0x8000) != 0x00)
	{
		if ((ecx_38 & 0x20) != 0x00)
			return ~0x00;
	}
	else
	{
		edx_353 = *((word32) dwArg10 + 72);
		Eq_2 ebx_45 = gs->t0008;
		if (*((word32) edx_353 + 8) != ebx_45)
		{
			ecx_146.u0 = 0x01;
			if (gs->t000C != 0x00)
				__lock();
			word32 eax_62;
			if (!__cmpxchg(*edx_353, 0x01, ecx_38 & 0x8000, out eax_62))
				ecx_146 = __lll_lock_wait_private(eax_62, edx_353, gs);
			ui32 eax_76 = *dwArg10;
			Eq_2 edx_75 = *((word32) dwArg10 + 72);
			*((word32) edx_75 + 8) = ebx_45;
			*((word32) edx_75 + 4) = (word32) *((word32) edx_75 + 4) + 1;
			ah_344 = SLICE(eax_76, byte, 8);
			if (((byte) eax_76 & 0x20) != 0x00)
			{
				dwLoc28_414.u0 = ~0x00;
				goto l08083885;
			}
		}
		else
		{
			*((word32) edx_353 + 4) = (word32) *((word32) edx_353 + 4) + 1;
			ecx_146 = ecx_38 & 0x20;
			if ((ecx_38 & 0x20) != 0x00)
			{
				dwLoc28_414.u0 = ~0x00;
				goto l0808388D;
			}
		}
	}
	if (*dwArg04 == 0x00 || *dwArg08 == 0x00)
	{
		dwArg08->u0 = 0x78;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ebp_657;
		word32 esi_658;
		word32 edx_655;
		word32 edi_659;
		word32 ebx_656;
		word32 ecx_654;
		Eq_2 eax_142 = __libc_malloc(gs, stackArg0, 0x78, out ecx_654, out edx_655, out ebx_656, out ebp_657, out esi_658, out edi_659);
		*dwArg04 = eax_142;
		ecx_146 = dwArg04;
		if (eax_142 == 0x00)
			goto l0808387C;
	}
	Eq_2 ebx_154 = *((word32) dwArg10 + 4);
	Eq_2 esi_156 = *((word32) dwArg10 + 8) - ebx_154;
	if (esi_156 > 0x00)
	{
l08083793:
		Eq_2 dwLoc20_442 = 0x00;
		while (true)
		{
			Eq_2 eax_194 = __memchr(ebx_154, dwArg0C, esi_156);
			ecx_146 = eax_194;
			word32 eax_203 = eax_194 - ebx_154;
			if (eax_194 != 0x00)
				esi_156 = eax_203 + 0x01;
			if (esi_156 >= 0x7FFFFFFF - dwLoc20_442)
				break;
			word32 eax_218 = dwLoc20_442 + esi_156;
			Eq_2 edx_219 = *dwArg08;
			dwLoc28_414 = eax_218;
			Eq_2 eax_224 = *dwArg04;
			if (edx_219 <u eax_218 + 0x01)
			{
				Eq_2 edx_228 = edx_219 * 0x02;
				if (edx_219 * 0x02 <u eax_218 + 0x01)
					edx_228 = eax_218 + 0x01;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 esi_665;
				word32 edx_663;
				word32 ebp_664;
				word32 edi_666;
				eax_224 = __realloc(gs, stackArg0, eax_224, edx_228, out edx_663, out ebp_664, out esi_665, out edi_666);
				ecx_146 = eax_194;
				if (eax_224 == 0x00)
					goto l0808387C;
				*dwArg04 = eax_224;
				*dwArg08 = edx_228;
				ebx_154 = *((word32) dwArg10 + 4);
			}
			word32 ecx_660;
			word32 edx_661;
			memcpy(eax_224 + dwLoc20_442, ebx_154, esi_156, out ecx_660, out edx_661);
			Mem303[dwArg10 + 0x04:word32] = Mem291[dwArg10 + 0x04:word32] + esi_156;
			if (eax_194 != 0x00)
			{
l08083928:
				Mem326[Mem322[dwArg04 + 0x00:word32] + eax_218:byte] = 0x00;
				ecx_146 = eax_218;
				goto l08083934;
			}
			word32 ecx_667;
			if (__underflow(dwArg10, out ecx_667) == ~0x00)
				goto l08083928;
			ebx_154 = *((word32) dwArg10 + 4);
			dwLoc20_442 = eax_218;
			esi_156 = *((word32) dwArg10 + 8) - ebx_154;
		}
		gs->tFFFFFFE0.u0 = 0x4B;
l0808387C:
		dwLoc28_414.u0 = ~0x00;
		ah_344 = (byte) *((word32) dwArg10 + 1);
		goto l08083885;
	}
	Eq_2 eax_167 = __underflow(dwArg10, out ecx_146);
	dwLoc28_414 = eax_167;
	if (eax_167 != ~0x00)
	{
		ebx_154 = *((word32) dwArg10 + 4);
		esi_156 = *((word32) dwArg10 + 8) - ebx_154;
		goto l08083793;
	}
l08083934:
	ah_344 = (byte) *((word32) dwArg10 + 1);
l08083885:
	if ((ah_344 & 0x80) != 0x00)
		return dwLoc28_414;
	edx_353 = *((word32) dwArg10 + 72);
l0808388D:
	word32 v18_356 = *((word32) edx_353 + 4) - 0x01;
	*((word32) edx_353 + 4) = v18_356;
	if (v18_356 == 0x00)
	{
		((word32) edx_353 + 8)->u0 = 0x00;
		if (gs->t000C != 0x00)
			__lock();
		Eq_2 v19_370 = *edx_353 - 0x01;
		*edx_353 = v19_370;
		if (v19_370 != 0x00)
			__lll_unlock_wake_private(edx_353, ecx_146, edx_353, gs);
	}
	return dwLoc28_414;
}

// 080839B0: void _IO_getline_info(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_98245 dwArg14, Stack (ptr32 word32) dwArg18)
// Called from:
//      _IO_getline
void _IO_getline_info(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_98245 dwArg14, word32 * dwArg18)
{
	Eq_2 ebp_139 = dwArg0C;
	if (dwArg18 != null)
		*dwArg18 = 0x00;
	if (*((word32) dwArg04 + 0x0068) == 0x00)
		((word32) dwArg04 + 0x0068)->u0 = ~0x00;
	if (dwArg0C != 0x00)
	{
		Eq_2 dwLoc28_252 = dwArg08;
		do
		{
			Eq_2 ebx_50 = *((word32) dwArg04 + 4);
			byte bArg10_294 = (byte) dwArg10;
			Eq_2 esi_52 = *((word32) dwArg04 + 8) - ebx_50;
			if (esi_52 > 0x00)
			{
				if (esi_52 > ebp_139)
					esi_52 = ebp_139;
				Eq_2 eax_72 = __memchr(ebx_50, dwArg10, esi_52);
				if (eax_72 != 0x00)
				{
					Eq_2 edx_84 = eax_72;
					Eq_2 esi_103 = eax_72 - ebx_50;
					if (dwArg14 >= 0x00)
					{
						edx_84 = (word32) eax_72 + 1;
						esi_103 = esi_103 - ~0x00 - (dwArg14 < 0x01);
					}
					word32 ecx_377;
					word32 edx_378;
					memcpy(dwLoc28_252, ebx_50, esi_103, out ecx_377, out edx_378);
					*((word32) dwArg04 + 4) = edx_84;
					return;
				}
				else
				{
					word32 edx_376;
					word32 ecx_375;
					memcpy(dwLoc28_252, ebx_50, esi_52, out ecx_375, out edx_376);
					Mem161[dwArg04 + 0x04:word32] = Mem158[dwArg04 + 0x04:word32] + esi_52;
					ebp_139 -= esi_52;
					dwLoc28_252 += esi_52;
					if (ebp_139 != 0x00)
						continue;
					break;
				}
			}
			Eq_2 eax_170 = __uflow(dwArg04);
			byte al_212 = (byte) eax_170;
			if (eax_170 == ~0x00)
			{
				if (dwArg18 != null)
					*dwArg18 = ~0x00;
				return;
			}
			if (eax_170 == dwArg10)
			{
				if (dwArg14 > 0x00)
					*dwLoc28_252 = bArg10_294;
				else if (dwArg14 != 0x00)
					_IO_sputbackc(dwArg04, dwArg10);
				break;
			}
			*dwLoc28_252 = al_212;
			--ebp_139;
			dwLoc28_252 = (word32) dwLoc28_252 + 1;
		} while (ebp_139 != 0x00);
	}
}

// 08083B50: Register Eq_2 _IO_getline()
// Called from:
//      fgets_unlocked
Eq_2 _IO_getline()
{
	_IO_getline_info(dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, null);
	return <invalid>;
}

// 08083B80: Register Eq_2 _IO_padn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out (ptr32 Eq_77725) edxOut, Register out Eq_979 ebxOut, Register out Eq_979 ebpOut, Register out Eq_2 esiOut, Register out (ptr32 Eq_77729) ediOut)
// Called from:
//      printf_positional
//      vfprintf
//      __printf_fp_l
//      __printf_fphex
Eq_2 _IO_padn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, struct Eq_77725 & edxOut, union Eq_979 & ebxOut, union Eq_979 & ebpOut, union Eq_2 & esiOut, struct Eq_77729 & ediOut)
{
	byte * ebx_131 = &g_b80B24B4;
	byte cl_197 = (byte) dwArg08;
	Eq_2 ebp_107 = dwArg0C;
	ui32 esi_25 = gs->dw0014;
	if (dwArg08 != 0x20)
	{
		ebx_131 = &g_b80B24A4;
		if (dwArg08 != 0x30)
		{
			ebx_131 = fp - 33;
			while (true)
			{
				*ebx_131 = cl_197;
				byte * eax_38 = ebx_131 - 0x01;
				if (ebx_131 == fp - 0x30)
					break;
				ebx_131 = eax_38;
			}
		}
	}
	Eq_2 esi_103;
	Eq_2 ecx_100 = dwArg08;
	if (dwArg0C > 0x0F)
	{
		esi_103.u0 = 0x00;
		do
		{
			Eq_2 eax_66 = *((word32) dwArg04 + 0x0094);
			if (eax_66 >= 135066356)
			{
				word32 ecx_323;
				word32 edx_324;
				_IO_vtable_check(out ecx_323, out edx_324);
			}
			word32 eax_99;
			(*((word32) eax_66 + 28))();
			esi_103 = (word32) esi_103 + eax_99;
			if (eax_99 != 0x10)
				goto l08083C86;
			ebp_107 -= 0x10;
		} while (ebp_107 > 0x0F);
	}
	else
		esi_103.u0 = 0x00;
	if (ebp_107 > 0x00)
	{
		Eq_2 edx_119 = *((word32) dwArg04 + 0x0094);
		if (edx_119 >= 135066356)
		{
			word32 ecx_321;
			word32 edx_322;
			_IO_vtable_check(out ecx_321, out edx_322);
		}
		word32 eax_159;
		(*((word32) edx_119 + 28))();
		esi_103 = (word64) esi_103.u0 + eax_159;
	}
l08083C86:
	struct Eq_77729 * edi_170 = esi_25 ^ gs->dw0014;
	if (edi_170 != null)
	{
		word32 edx_326;
		word32 ecx_325;
		__stack_chk_fail(out ecx_325, out edx_326);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 ecx_184;
		struct Eq_77725 * edx_185;
		word32 ebx_330;
		word32 edi_333;
		word32 ebp_331;
		word32 esi_332;
		Eq_2 eax_183 = _IO_wpadn(gs, stackArg4, stackArg8, stackArg12, out ecx_184, out edx_185, out ebx_330, out ebp_331, out esi_332, out edi_333);
		ecxOut = ecx_184;
		edxOut = edx_185;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi_103;
		ediOut = edi_170;
		return eax_183;
	}
	else
	{
		ecxOut = ecx_100;
		edxOut = edx;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return esi_103;
	}
}

// 08083CB0: Register (ptr32 word32) _IO_wpadn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out (ptr32 (ptr32 (ptr32 (ptr32 Eq_98583)))) edxOut, Register out Eq_979 ebxOut, Register out Eq_979 ebpOut, Register out (ptr32 word32) esiOut, Register out (ptr32 Eq_80574) ediOut)
// Called from:
//      __printf_fp_l
//      __printf_fphex
//      printf_positional
//      __vfwprintf
//      _IO_padn
word32 * _IO_wpadn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, struct Eq_98583 & edxOut, union Eq_979 & ebxOut, union Eq_979 & ebpOut, word32 & esiOut, struct Eq_80574 & ediOut)
{
	word32 * ebx_129 = &g_dw80B2520;
	Eq_2 ecx_158 = dwArg08;
	Eq_2 ebp_105 = dwArg0C;
	ui32 esi_25 = gs->dw0014;
	if (dwArg08 != 0x20)
	{
		ebx_129 = &g_dw80B24E0;
		if (dwArg08 != 0x30)
		{
			ebx_129 = fp - 0x24;
			while (true)
			{
				*ebx_129 = (word32) dwArg08;
				word32 * eax_38 = ebx_129 - 0x04;
				if (ebx_129 == fp - 0x60)
					break;
				ebx_129 = eax_38;
			}
		}
	}
	word32 * esi_101;
	if (dwArg0C > 0x0F)
	{
		esi_101 = null;
		do
		{
			Eq_2 eax_64 = *((word32) dwArg04 + 0x0094);
			if (eax_64 >= 135066356)
			{
				word32 edx_318;
				word32 ecx_317;
				_IO_vtable_check(out ecx_317, out edx_318);
			}
			word32 eax_97;
			(*((word32) eax_64 + 28))();
			esi_101 += eax_97;
			if (eax_97 != 0x10)
				goto l08083DB6;
			ebp_105 -= 0x10;
		} while (ebp_105 > 0x0F);
	}
	else
		esi_101 = null;
	if (ebp_105 > 0x00)
	{
		Eq_2 edx_117 = *((word32) dwArg04 + 0x0094);
		if (edx_117 >= 135066356)
		{
			word32 edx_316;
			word32 ecx_315;
			_IO_vtable_check(out ecx_315, out edx_316);
		}
		word32 eax_157;
		(*((word32) edx_117 + 28))();
		esi_101 += eax_157;
	}
l08083DB6:
	struct Eq_80574 * edi_168 = esi_25 ^ gs->dw0014;
	if (edi_168 != null)
	{
		word32 ecx_319;
		word32 edx_320;
		__stack_chk_fail(out ecx_319, out edx_320);
		Eq_2 ecx_182;
		struct Eq_98583 **** edx_183;
		word32 ebp_323;
		word32 esi_324;
		word32 * eax_181 = save_for_wbackup.isra.0(eax, ecx, edx_183, out ecx_182, out edx_183, out ebp_323, out esi_324);
		ecxOut = ecx_182;
		edxOut = edx_183;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi_101;
		ediOut = edi_168;
		return eax_181;
	}
	else
	{
		ecxOut = ecx_158;
		edxOut = edx;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		esiOut = esi;
		ediOut = edi;
		return esi_101;
	}
}

// 08083DE0: Register (ptr32 word32) save_for_wbackup.isra.0(Register (ptr32 word32) eax, Register Eq_2 ecx, Register (ptr32 (ptr32 (ptr32 (ptr32 Eq_98583)))) edx, Register out Eq_98571 ecxOut, Register out Eq_2 edxOut, Register out (ptr32 Eq_98573) ebpOut, Register out (ptr32 Eq_98574) esiOut)
// Called from:
//      _IO_wpadn
//      _IO_wdefault_pbackfail
//      __wuflow
//      __wunderflow
word32 * save_for_wbackup.isra.0(word32 * eax, Eq_2 ecx, struct Eq_98583 **** edx, union Eq_98571 & ecxOut, union Eq_2 & edxOut, struct Eq_98573 & ebpOut, struct Eq_98574 & esiOut)
{
	word32 * eax_312;
	Eq_2 edi_253;
	struct Eq_98583 * ebx_184;
	struct Eq_98583 **** ecx_251;
	struct Eq_98585 * esp_183;
	int32 edi_193;
	struct Eq_98583 * ebx_27 = *edx;
	Eq_2 edi_28 = ebx_27->t0008;
	Eq_2 edx_187 = ebx_27->t0020;
	Eq_2 edi_32 = ebx_27->t0028;
	Eq_98571 ecx_291 = ecx - edi_28;
	struct Eq_98583 * eax_25 = *eax;
	int32 edi_36 = edi_32 - edx_187;
	Eq_2 esi_198 = ecx_291 >> 0x02;
	if (eax_25 != null)
	{
		ecx_291 >>= 0x02;
		struct Eq_98583 * edx_54 = eax_25;
		do
		{
			Eq_2 ebp_57 = edx_54->t0008;
			edx_54 = edx_54->ptr0000;
			if (esi_198 > ebp_57)
				esi_198 = ebp_57;
		} while (edx_54 != null);
		Eq_2 ebp_72 = (ecx_291 >> 0x02) - esi_198;
		if (ebp_72 > edi_36 >> 0x02)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 eax_77 = ebp_72 * 0x04 + 400;
			Eq_2 stackArg0 = <invalid>;
			word32 esi_466;
			word32 edi_467;
			word32 ebx_464;
			word32 ebp_465;
			word32 edx_463;
			Eq_2 eax_90 = __libc_malloc(gs, stackArg0, eax_77, out ecx_291, out edx_463, out ebx_464, out ebp_465, out esi_466, out edi_467);
			edx_187 = eax_90;
			if (eax_90 == 0x00)
			{
				eax_312 = (word32 *) ~0x00;
l08083E8B:
				ecxOut = ecx_291;
				edxOut = edx_187;
				ebpOut = ebp;
				esiOut = esi;
				return eax_312;
			}
			ui32 eax_98 = esi_198 * 0x04;
			edi_253 = (word32) eax_90 + 400;
			if (esi_198 >= 0x00)
			{
				word32 edx_468;
				__wmemcpy((word32) eax_90 + 400, (word32) edi_28 + eax_98, ebp_72, out edx_468);
			}
			else
				__wmempcpy(__wmempcpy((word32) eax_90 + 400, (word32) edi_32 + eax_98, -esi_198), edi_28, ecx_291 >> 0x02);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_470;
			word32 edx_471;
			free(gs, stackArg0, *((char *) *edx + 32), out ecx_470, out edx_471);
			ebx_184 = (struct Eq_98583 *) *edx;
			ebx_184->t0020 = eax_77;
			edx_187 = (word32) eax_77 + 0x080CE000;
			ebx_184->t0028 = edx_187;
			esp_183 = fp - 88;
			goto l08083F15;
		}
		int32 edi_190 = (edi_36 >> 0x02) - ebp_72;
		edi_193 = edi_190 << 0x02;
		edx_187 = (word32) edx_187 + (edi_190 << 0x02);
		if (esi_198 >= 0x00)
		{
			if (ebp_72 == 0x00)
			{
				ebx_27->t0024 = edx_187;
				goto l08083E80;
			}
			__wmemcpy(edx_187, (word32) edi_28 + esi_198 * 0x04, ebp_72, out edx_187);
			ebx_184 = (struct Eq_98583 *) *edx;
			esp_183 = fp - 0x5C;
			edi_253 = (word32) ebx_184->t0020 + (edi_190 << 0x02);
l08083F15:
			ecx_251 = esp_183->ptr002C;
l08083F19:
			ecx_291 = ecx_251 - ebx_184->t0008 >> 0x02;
			eax_25 = (struct Eq_98583 *) *esp_183->ptr0024;
			ebx_184->t0024 = edi_253;
			if (eax_25 == null)
			{
l08083E89:
				eax_312 = null;
				goto l08083E8B;
			}
l08083E80:
			do
			{
				eax_25->t0008 -= ecx_291;
				eax_25 = eax_25->ptr0000;
			} while (eax_25 != null);
			goto l08083E89;
		}
	}
	else
	{
		edi_193 = edi_36;
		if (ecx_291 >= 0x00)
		{
			ebx_27->t0024 = edi_32;
			goto l08083E89;
		}
		edx_187 = edi_32;
		esi_198 = ecx_291 >> 0x02;
	}
	wmemmove(edx_187, (word32) edi_32 + esi_198 * 0x04, -esi_198);
	struct Eq_98583 * ecx_226 = *eax;
	Eq_2 edx_228 = ecx_226->t0008;
	__wmemcpy((word32) ecx_226->t0020 + ((ecx_291 >> 0x02) - esi_198) * 0x04, edx_228, edx - edx_228 >> 0x02, out edx_187);
	ebx_184 = *eax;
	esp_183 = fp - 0x60;
	ecx_251 = edx;
	edi_253 = (word32) ebx_184->t0020 + edi_193;
	goto l08083F19;
}

// 08084020: void _IO_least_wmarker(Stack (ptr32 Eq_98814) dwArg04, Stack int32 dwArg08)
void _IO_least_wmarker(struct Eq_98814 * dwArg04, int32 dwArg08)
{
	struct Eq_98816 * edx_16 = dwArg04->ptr0030;
	int32 eax_10 = dwArg08 - (dwArg04->ptr0058)->dw0008 >> 0x02;
	while (edx_16 != null)
	{
		int32 ecx_18 = edx_16->dw0008;
		edx_16 = edx_16->ptr0000;
		if (eax_10 > ecx_18)
			eax_10 = ecx_18;
	}
}

// 08084050: void _IO_switch_to_main_wget_area(Stack (ptr32 Eq_98842) dwArg04)
void _IO_switch_to_main_wget_area(struct Eq_98842 * dwArg04)
{
	dwArg04->dw0000 &= ~0x0100;
	struct Eq_98851 * eax_10 = dwArg04->ptr0058;
	word32 ecx_12 = eax_10->dw0028;
	eax_10->dw0028 = eax_10->dw0004;
	word32 edx_14 = eax_10->dw0020;
	eax_10->dw0004 = ecx_12;
	word32 ecx_16 = eax_10->dw0008;
	eax_10->dw0000 = edx_14;
	eax_10->dw0008 = edx_14;
	eax_10->dw0020 = ecx_16;
}

// 08084080: void _IO_switch_to_wbackup_area(Stack (ptr32 Eq_98885) dwArg04)
void _IO_switch_to_wbackup_area(struct Eq_98885 * dwArg04)
{
	dwArg04->dw0000 |= 0x0100;
	struct Eq_98894 * eax_12 = dwArg04->ptr0058;
	word32 edx_14 = eax_12->dw0028;
	word32 ebx_15 = eax_12->dw0020;
	eax_12->dw0028 = eax_12->dw0004;
	word32 ecx_17 = eax_12->dw0008;
	eax_12->dw0004 = edx_14;
	eax_12->dw0008 = ebx_15;
	eax_12->dw0020 = ecx_17;
	eax_12->dw0000 = edx_14;
}

// 080840B0: Register Eq_2 _IO_wsetb(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 edxOut)
// Called from:
//      _IO_file_close_it
//      _IO_cleanup
//      _IO_wfile_doallocate
//      _IO_wdoallocbuf
//      _IO_wdefault_doallocate
Eq_2 _IO_wsetb(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & edxOut)
{
	Eq_2 eax_15 = *((word32) dwArg04 + 60);
	Eq_2 edx_14 = *((word32) dwArg04 + 88);
	byte al_20 = (byte) eax_15;
	Eq_2 ecx_16 = *((word32) edx_14 + 24);
	if (ecx_16 != 0x00 && (al_20 & 0x08) == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_88;
		word32 edx_89;
		free(gs, stackArg0, ecx_16, out ecx_88, out edx_89);
		edx_14 = *((word32) dwArg04 + 88);
		eax_15 = *((word32) dwArg04 + 60);
	}
	*((word32) edx_14 + 24) = dwArg08;
	*((word32) edx_14 + 28) = dwArg0C;
	Eq_2 eax_46 = eax_15 | 0x08;
	Eq_2 edx_47 = eax_15 & ~0x08;
	if (dwArg10 != 0x00)
		eax_46 = edx_47;
	*((word32) dwArg04 + 60) = eax_46;
	edxOut = edx_47;
	return dwArg10;
}

// 08084120: void _IO_wdefault_pbackfail(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_98981) dwArg04, Stack int32 dwArg08)
void _IO_wdefault_pbackfail(struct Eq_9 * gs, struct Eq_98981 * dwArg04, int32 dwArg08)
{
	Eq_2 ecx_144;
	Eq_2 eax_128;
	ui32 edx_21 = dwArg04->dw0000;
	struct Eq_98989 * esi_134 = dwArg04->ptr0058;
	struct Eq_98993 * esp_101 = fp - 44;
	struct Eq_98981 * ebp_129 = dwArg04;
	byte dh_175 = SLICE(edx_21, byte, 8);
	byte dl_182 = (byte) edx_21;
	word16 edx_16_16_186 = SLICE(edx_21, word16, 16);
	Eq_2 edi_148 = esi_134->t0000;
	Eq_2 ecx_23 = esi_134->t0008;
	if (edi_148 > ecx_23)
	{
		if ((edx_21 & 0x0100) != 0x00)
			goto l08084158;
		struct Eq_99020 * ecx_109 = dwArg04->ptr0004;
		if ((int32) ecx_109->bFFFFFFFF == dwArg08)
		{
			dwArg04->ptr0004 = ecx_109 - 0x01;
			return;
		}
		if (esi_134->t0020 != 0x00)
		{
			word32 edx_296;
			word32 esi_297;
			word32 ecx_295;
			if (save_for_wbackup.isra.0((char *) &dwArg04->ptr0004 + 44, edi_148, &dwArg04->ptr0058, out ecx_295, out edx_296, out ebp_129, out esi_297) != null)
				return;
			ui32 edx_171 = ebp_129->dw0000;
			esi_134 = ebp_129->ptr0058;
			dh_175 = SLICE(edx_171, byte, 8);
			dl_182 = (byte) edx_171;
			edx_16_16_186 = SLICE(edx_171, word16, 16);
			ecx_144 = esi_134->t0000;
			edi_148 = esi_134->t0028;
			eax_128 = esi_134->t0020;
			goto l08084234;
		}
	}
	else
	{
		if ((edx_21 & 0x0100) != 0x00)
		{
			struct Eq_99045 * ebp_50;
			word32 edi_53;
			Eq_2 esi_55;
			word32 ecx_286;
			word32 ebx_288;
			word32 edx_287;
			Eq_2 eax_49 = __libc_malloc(gs, dwLoc40, (esi_134->t0004 - ecx_23 >> 0x02) * 0x08, out ecx_286, out edx_287, out ebx_288, out ebp_50, out esi_55, out edi_53);
			if (eax_49 == 0x00)
				return;
			edi_148 = (word32) eax_49 + edi_53;
			word32 edx_289;
			__wmemcpy(edi_148, ecx_23, esi_55, out edx_289);
			word32 edx_291;
			word32 ecx_290;
			free(gs, dwLoc40, ebp_50->ptr0058->t0008, out ecx_290, out edx_291);
			esi_134 = ebp_50->ptr0058;
			esi_134->t0008 = dwLoc1C;
			esi_134->t0000 = edi_148;
			Mem104[esi_134 + 0x04:word32] = dwLoc1C + ecx_23;
			esi_134->t0024 = edi_148;
			esp_101 = fp - 0x28;
l08084158:
			esi_134->t0000 = edi_148 - 0x04;
			*((word32) edi_148 - 4) = esp_101->t0034;
			return;
		}
		eax_128 = esi_134->t0020;
		if (eax_128 != 0x00)
		{
			ecx_144 = edi_148;
			edi_148 = esi_134->t0028;
			goto l08084234;
		}
	}
	Eq_2 edi_132;
	word32 edx_293;
	word32 ebx_294;
	word32 ecx_292;
	eax_128 = __libc_malloc(gs, dwLoc40, 0x0200, out ecx_292, out edx_293, out ebx_294, out ebp_129, out esi_134, out edi_132);
	if (eax_128 == 0x00)
		return;
	esi_134->t0020 = eax_128;
	esi_134->t0028 = (word32) eax_128 + 0x0200;
	esi_134->t0024 = (word32) eax_128 + 0x0200;
	ecx_144 = edi_132;
	dh_175 = SLICE(edx_21, byte, 8);
	dl_182 = (byte) edx_21;
	edx_16_16_186 = SLICE(edx_21, word16, 16);
	edi_148 = (word32) eax_128 + 0x0200;
l08084234:
	ebp_129->dw0000 = SEQ(edx_16_16_186, dh_175 | 0x01, dl_182);
	Eq_2 edx_194 = esi_134->t0004;
	esi_134->t0008 = eax_128;
	esi_134->t0004 = edi_148;
	esi_134->t0028 = edx_194;
	esi_134->t0020 = ecx_144;
	esi_134->t0000 = edi_148;
	esp_101 = fp - 44;
	goto l08084158;
}

// 080842B0: void _IO_wdefault_finish(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wdefault_finish(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_14 = *((word32) dwArg04 + 88);
	ptr32 esp_12 = fp - 0x0C;
	Eq_2 eax_15 = *((word32) edx_14 + 24);
	if (eax_15 != 0x00 && (*((word32) dwArg04 + 60) & 0x08) == 0x00)
	{
		word32 ecx_122;
		word32 edx_123;
		free(gs, dwLoc20, eax_15, out ecx_122, out edx_123);
		edx_14 = *((word32) dwArg04 + 88);
		*((word32) edx_14 + 28) = 0x00;
		((word32) edx_14 + 24)->u0 = 0x00;
		esp_12 = fp - 0x08;
	}
	struct Eq_99227 * eax_42;
	for (eax_42 = *((word32) dwArg04 + 48); eax_42 != null; eax_42 = eax_42->ptr0000)
		eax_42->dw0004 = 0x00;
	if (*((word32) dwArg04 + 36) != 0x00)
	{
		struct Eq_99274 * esp_62 = esp_12 - 0x0C;
		esp_62->tFFFFFFFC = *((word32) edx_14 + 32);
		word32 edx_125;
		word32 ecx_124;
		free(gs, esp_62->tFFFFFFF8, esp_62->tFFFFFFFC, out ecx_124, out edx_125);
		*((word32) dwArg04 + 36) = 0x00;
	}
	_IO_un_link(dwArg04);
}

// 08084340: void _IO_wdefault_uflow(Stack (ptr32 Eq_99301) dwArg04)
void _IO_wdefault_uflow(struct Eq_99301 * dwArg04)
{
	struct Eq_99302 * esi_16 = dwArg04->ptr0094;
	if (esi_16 >= &__elf_set___libc_atexit_element__IO_cleanup__)
	{
		word32 edx_89;
		word32 ecx_88;
		_IO_vtable_check(out ecx_88, out edx_89);
	}
	word32 eax_38;
	esi_16->ptr0010();
	if (eax_38 == ~0x00)
		return;
	word32 * edx_51 = dwArg04->ptr0058;
	*edx_51 += 0x04;
}

// 080843B0: Register word32 __woverflow(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 (arr Eq_2)) ecxOut)
// Called from:
//      __printf_fp_l
//      __printf_fphex
//      _IO_helper_overflow
//      printf_positional
//      _IO_wdefault_xsputn
word32 __woverflow(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 (& ecxOut)
{
	if (*((word32) dwArg04 + 0x0068) == 0x00)
	{
		word32 esi_106;
		word32 ebp_105;
		word32 ecx_103;
		word32 edx_104;
		_IO_fwide(gs, dwArg04, 0x01, out ecx_103, out edx_104, out ebp_105, out esi_106);
	}
	Eq_2 ebp_39 = *((word32) dwArg04 + 0x0094);
	if (ebp_39 >= 135066356)
	{
		word32 ecx_107;
		word32 edx_108;
		_IO_vtable_check(out ecx_107, out edx_108);
	}
	word32 eax_73;
	Eq_2 (* ecx_75)[];
	(*((word32) ebp_39 + 0x0C))();
	ecxOut = ecx_75;
	return eax_73;
}

// 08084430: Register Eq_17418 _IO_wdefault_xsputn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_17418 dwArg0C)
// Called from:
//      _IO_wfile_xsputn
Eq_17418 _IO_wdefault_xsputn(Eq_2 dwArg04, Eq_2 dwArg08, Eq_17418 dwArg0C)
{
	if (dwArg0C == 0x00)
		return 0x00;
	Eq_17418 ebp_139 = dwArg0C;
l08084484:
	Eq_2 edx_38 = *((word32) dwArg04 + 88);
	Eq_2 edi_39 = *((word32) edx_38 + 16);
	Eq_2 esi_114 = dwArg08;
	int32 ebx_41 = *((word32) edx_38 + 20) - edi_39;
	if (ebx_41 > 0x00)
	{
		Eq_17418 ebx_44 = ebx_41 >> 0x02;
		if (ebx_41 >> 0x02 > ebp_139)
			ebx_44 = ebp_139;
		if (ebx_44 > 0x14)
		{
			*((word32) edx_38 + 16) = __wmempcpy(edi_39, dwArg08, ebx_44);
			ebp_139 -= ebx_44;
			esi_114 = (word32) dwArg08 + ebx_44 * 0x04;
			if (ebp_139 == 0x00)
				return dwArg0C;
l08084460:
			dwArg08 = (word32) esi_114 + 4;
			word32 ecx_253;
			if (__woverflow(dwArg04, *esi_114, out ecx_253) == ~0x00)
			{
				dwArg0C -= ebp_139;
				return dwArg0C;
			}
			--ebp_139;
			goto l08084484;
		}
		esi_114 = dwArg08;
		if (ebx_44 != 0x00)
		{
			ui32 ecx_58 = ebx_44 * 0x04;
			Eq_2 eax_60 = (word32) edi_39 + ecx_58;
			Eq_2 esi_61 = dwArg08;
			do
			{
				*edi_39 = *esi_61;
				esi_61 = (word32) esi_61 + 4;
				edi_39 = (word32) edi_39 + 4;
			} while (eax_60 != edi_39);
			*((word32) edx_38 + 16) = eax_60;
			ebp_139 -= ebx_44;
			esi_114 = (word32) dwArg08 + ecx_58;
		}
	}
	if (ebp_139 == 0x00)
		return dwArg0C;
	goto l08084460;
}

// 08084520: void _IO_wdoallocbuf(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_underflow
//      _IO_wfile_underflow_mmap
//      _IO_wfile_overflow
void _IO_wdoallocbuf(Eq_2 dwArg04)
{
	Eq_2 eax_28 = *((word32) dwArg04 + 88);
	if (*((word32) eax_28 + 24) != 0x00)
		return;
	if ((*dwArg04 & 0x02) == 0x00)
	{
		Eq_2 eax_19 = *((word32) eax_28 + 0x00B0);
		word32 eax_22;
		(*((word32) eax_19 + 52))();
		if (eax_22 != ~0x00)
			return;
		eax_28 = *((word32) dwArg04 + 88);
	}
	word32 edx_88;
	_IO_wsetb(dwArg04, (word32) eax_28 + 0x00AC, (word32) eax_28 + 0x00B0, 0x00, out edx_88);
}

// 08084580: void _IO_wdefault_doallocate(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _IO_wdefault_doallocate(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 ebx_89;
	word32 edx_88;
	word32 ecx_87;
	word32 ebp_90;
	word32 esi_91;
	word32 edi_92;
	Eq_2 eax_14 = __libc_malloc(gs, dwLoc20, 0x2000, out ecx_87, out edx_88, out ebx_89, out ebp_90, out esi_91, out edi_92);
	if (eax_14 == 0x00)
		return;
	word32 edx_93;
	_IO_wsetb(dwArg04, eax_14, (word32) eax_14 + 0x00008000, 0x01, out edx_93);
}

// 080845E0: Register word32 _IO_switch_to_wget_mode(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
//      __wuflow
//      __wunderflow
//      _IO_init_wmarker
word32 _IO_switch_to_wget_mode(Eq_2 dwArg04)
{
	word32 eax_23;
	Eq_2 eax_12 = *((word32) dwArg04 + 88);
	up32 edx_13 = *((word32) eax_12 + 16);
	if (edx_13 > *((word32) eax_12 + 0x0C))
	{
		Eq_2 eax_18 = *((word32) eax_12 + 0x00B0);
		(*((word32) eax_18 + 0x0C))();
		if (eax_23 == ~0x00)
			return eax_23;
		eax_12 = *((word32) dwArg04 + 88);
		edx_13 = (up32) *((word32) eax_12 + 16);
	}
	word32 ecx_34 = *dwArg04;
	byte ch_35 = SLICE(ecx_34, byte, 8);
	byte cl_59 = (byte) ecx_34;
	word16 ecx_16_16_61 = SLICE(ecx_34, word16, 16);
	if ((ch_35 & 0x01) == 0x00)
	{
		*((word32) eax_12 + 8) = *((word32) eax_12 + 24);
		if (*((word32) eax_12 + 4) < edx_13)
			*((word32) eax_12 + 4) = edx_13;
	}
	else
		*((word32) eax_12 + 8) = *((word32) eax_12 + 36);
	*eax_12 = edx_13;
	*((word32) eax_12 + 20) = edx_13;
	*((word32) eax_12 + 0x0C) = edx_13;
	*dwArg04 = SEQ(ecx_16_16_61, ch_35 & ~0x08, cl_59);
	eax_23 = 0x00;
	return eax_23;
}

// 08084650: void _IO_free_wbackup_area(Stack Eq_2 dwArg04)
// Called from:
//      _IO_wfile_seekoff
//      _IO_wfile_overflow
//      _IO_file_close_it
//      __wuflow
//      __wunderflow
//      _IO_unsave_wmarkers
void _IO_free_wbackup_area(Eq_2 dwArg04)
{
	word32 ecx_17 = *dwArg04;
	Eq_2 eax_16 = *((word32) dwArg04 + 88);
	byte ch_19 = SLICE(ecx_17, byte, 8);
	byte cl_27 = (byte) ecx_17;
	word16 ecx_16_16_28 = SLICE(ecx_17, word16, 16);
	Eq_2 edx_18 = *((word32) eax_16 + 32);
	if ((ch_19 & 0x01) != 0x00)
	{
		word32 edi_26 = *((word32) eax_16 + 40);
		*dwArg04 = SEQ(ecx_16_16_28, ch_19 & ~0x01, cl_27);
		word32 ecx_31 = *((word32) eax_16 + 4);
		*((word32) eax_16 + 4) = edi_26;
		*((word32) eax_16 + 40) = ecx_31;
		Eq_2 ecx_34 = *((word32) eax_16 + 8);
		*eax_16 = edx_18;
		*((word32) eax_16 + 32) = ecx_34;
		*((word32) eax_16 + 8) = edx_18;
		edx_18 = ecx_34;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_80;
	word32 edx_81;
	free(gs, stackArg0, edx_18, out ecx_80, out edx_81);
	Eq_2 eax_53 = *((word32) dwArg04 + 88);
	*((word32) eax_53 + 32) = 0x00;
	*((word32) eax_53 + 40) = 0x00;
	*((word32) eax_53 + 36) = 0x00;
}

// 080846C0: void __wuflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void __wuflow(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esi_13 = dwArg04;
	Eq_2 edi_16 = *((word32) dwArg04 + 0x0068);
	if (edi_16 < 0x00)
		return;
	if (edi_16 == 0x00)
	{
		word32 ecx_320;
		word32 edx_321;
		word32 ebp_322;
		if (_IO_fwide(gs, dwArg04, 0x01, out ecx_320, out edx_321, out ebp_322, out esi_13) != 0x01)
			return;
		if (*((word32) esi_13 + 0x0068) == 0x00)
		{
			word32 ecx_328;
			word32 edx_329;
			word32 ebp_330;
			_IO_fwide(gs, esi_13, 0x01, out ecx_328, out edx_329, out ebp_330, out esi_13);
		}
	}
	if ((*esi_13 & 0x0800) != 0x00 && _IO_switch_to_wget_mode(esi_13) == ~0x00)
		return;
	Eq_2 eax_87 = *((word32) esi_13 + 88);
	Eq_2 edx_103 = *eax_87;
	Eq_2 ecx_89 = *((word32) eax_87 + 4);
	if (edx_103 >= ecx_89)
	{
		ui32 edx_92 = *esi_13;
		byte dh_93 = SLICE(edx_92, byte, 8);
		byte dl_99 = (byte) edx_92;
		word16 edx_16_16_100 = SLICE(edx_92, word16, 16);
		if ((dh_93 & 0x01) == 0x00)
		{
l0808472A:
			if (*((word32) esi_13 + 48) != 0x00)
			{
				word32 ebp_325;
				word32 ecx_323;
				word32 edx_324;
				if (save_for_wbackup.isra.0((word32) esi_13 + 48, *((word32) eax_87 + 4), (word32) esi_13 + 88, out ecx_323, out edx_324, out ebp_325, out esi_13) != null)
					return;
			}
			else if (*((word32) eax_87 + 32) != 0x00)
				_IO_free_wbackup_area(esi_13);
			Eq_2 edi_180 = *((word32) esi_13 + 0x0094);
			if (edi_180 >= 135066356)
			{
				word32 ecx_326;
				word32 edx_327;
				_IO_vtable_check(out ecx_326, out edx_327);
			}
			word32 edx_218;
			word32 ecx_219;
			(*((word32) edi_180 + 20))();
			return;
		}
		Eq_2 edi_98 = *((word32) eax_87 + 40);
		*esi_13 = SEQ(edx_16_16_100, dh_93 & ~0x01, dl_99);
		edx_103 = *((word32) eax_87 + 32);
		*((word32) eax_87 + 40) = ecx_89;
		Eq_2 ecx_105 = *((word32) eax_87 + 8);
		*((word32) eax_87 + 4) = edi_98;
		*((word32) eax_87 + 8) = edx_103;
		*((word32) eax_87 + 32) = ecx_105;
		if (edi_98 <= edx_103)
		{
			*eax_87 = edx_103;
			goto l0808472A;
		}
	}
	*eax_87 = (word32) edx_103 + 4;
}

// 08084820: Register word32 __wunderflow(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      _IO_wdefault_xsgetn
word32 __wunderflow(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & ebpOut)
{
	Eq_2 esi_13 = dwArg04;
	Eq_2 edi_16 = *((word32) dwArg04 + 0x0068);
	if (edi_16 >= 0x00)
	{
		if (edi_16 == 0x00)
		{
			word32 edx_321;
			word32 ecx_320;
			if (_IO_fwide(gs, dwArg04, 0x01, out ecx_320, out edx_321, out ebp, out esi_13) != 0x01)
				goto l080848ED;
			if (*((word32) esi_13 + 0x0068) == 0x00)
			{
				word32 ecx_326;
				word32 edx_327;
				_IO_fwide(gs, esi_13, 0x01, out ecx_326, out edx_327, out ebp, out esi_13);
			}
		}
		if ((*esi_13 & 0x0800) == 0x00 || _IO_switch_to_wget_mode(esi_13) != ~0x00)
		{
			Eq_2 eax_87 = *((word32) esi_13 + 88);
			Eq_2 edx_103 = *eax_87;
			Eq_2 ecx_89 = *((word32) eax_87 + 4);
			if (edx_103 >= ecx_89)
			{
				ui32 edx_92 = *esi_13;
				byte dh_93 = SLICE(edx_92, byte, 8);
				byte dl_99 = (byte) edx_92;
				word16 edx_16_16_100 = SLICE(edx_92, word16, 16);
				if ((dh_93 & 0x01) == 0x00)
				{
l0808488A:
					if (*((word32) esi_13 + 48) == 0x00)
					{
						if (*((word32) esi_13 + 36) != 0x00)
							_IO_free_wbackup_area(esi_13);
						goto l080848A7;
					}
					word32 ecx_322;
					word32 edx_323;
					if (save_for_wbackup.isra.0((word32) esi_13 + 48, *((word32) eax_87 + 4), (word32) esi_13 + 88, out ecx_322, out edx_323, out ebp, out esi_13) == null)
					{
l080848A7:
						Eq_2 edi_178 = *((word32) esi_13 + 0x0094);
						if (edi_178 >= 135066356)
						{
							word32 edx_325;
							word32 ecx_324;
							_IO_vtable_check(out ecx_324, out edx_325);
						}
						word32 eax_215;
						word32 edx_216;
						word32 ecx_217;
						(*((word32) edi_178 + 16))();
						ebpOut = ebp;
						return eax_215;
					}
					goto l080848ED;
				}
				Eq_2 edi_98 = *((word32) eax_87 + 40);
				*esi_13 = SEQ(edx_16_16_100, dh_93 & ~0x01, dl_99);
				edx_103 = *((word32) eax_87 + 32);
				*((word32) eax_87 + 40) = ecx_89;
				Eq_2 ecx_105 = *((word32) eax_87 + 8);
				*((word32) eax_87 + 4) = edi_98;
				*((word32) eax_87 + 8) = edx_103;
				*((word32) eax_87 + 32) = ecx_105;
				*eax_87 = edx_103;
				if (edi_98 <= edx_103)
					goto l0808488A;
			}
			word32 eax_118 = *edx_103;
			ebpOut = ebp;
			return eax_118;
		}
	}
l080848ED:
	ebpOut = ebp;
	return ~0x00;
}

// 08084980: void _IO_wdefault_xsgetn(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_17418 dwArg0C)
void _IO_wdefault_xsgetn(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_17418 dwArg0C)
{
	Eq_17418 ebp_115 = dwArg0C;
	do
	{
		Eq_2 eax_22 = *((word32) dwArg04 + 88);
		Eq_2 esi_23 = *eax_22;
		int32 ebx_25 = *((word32) eax_22 + 4) - esi_23;
		if (ebx_25 > 0x00)
		{
			Eq_17418 ebx_28 = ebx_25 >> 0x02;
			if (ebx_25 >> 0x02 > ebp_115)
				ebx_28 = ebp_115;
			if (ebx_28 > 0x14)
			{
				dwArg08 = __wmempcpy(dwArg08, esi_23, ebx_28);
				Eq_2 eax_93 = *((word32) dwArg04 + 88);
				*eax_93 = (word32) *eax_93 + ebx_28 * 0x04;
				if (ebp_115 - ebx_28 == 0x00)
					return;
				goto l080849A0;
			}
			if (ebx_28 != 0x00)
			{
				ui32 edx_39 = ebx_28 * 0x04;
				Eq_2 edi_42 = dwArg08;
				Eq_2 ecx_44 = (word32) esi_23 + edx_39;
				do
				{
					*edi_42 = *esi_23;
					esi_23 = (word32) esi_23 + 4;
					edi_42 = (word32) edi_42 + 4;
				} while (ecx_44 != esi_23);
				*eax_22 = ecx_44;
				dwArg08 = (word32) dwArg08 + edx_39;
				ebp_115 -= ebx_28;
			}
		}
		if (ebp_115 == 0x00)
			return;
l080849A0:
	} while (__wunderflow(gs, dwArg04, out ebp_115) != ~0x00);
}

// 08084A50: void _IO_sputbackwc(Stack (ptr32 Eq_100069) dwArg04, Stack word32 dwArg08)
void _IO_sputbackwc(struct Eq_100069 * dwArg04, word32 dwArg08)
{
	word32 eax_26;
	struct Eq_100072 * eax_17 = dwArg04->ptr0058;
	Eq_2 esp_12 = fp - 0x0C;
	struct Eq_100080 * edx_18 = eax_17->ptr0000;
	if (edx_18 > eax_17->ptr0008 && edx_18->dwFFFFFFFC == dwArg08)
	{
		eax_17->ptr0000 = edx_18 - 0x04;
		eax_26 = dwArg08;
	}
	else
	{
		struct Eq_100088 * edi_29 = dwArg04->ptr0094;
		if (edi_29 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 ecx_120;
			word32 edx_121;
			_IO_vtable_check(out ecx_120, out edx_121);
			esp_12.u0 = <invalid>;
		}
		struct Eq_100109 * esp_46 = esp_12 - 0x08;
		esp_46->dwFFFFFFFC = dwArg08;
		esp_46->ptrFFFFFFF8 = dwArg04;
		edi_29->ptr0018();
	}
	if (eax_26 != ~0x00)
		dwArg04->dw0000 &= ~0x10;
}

// 08084AD0: void _IO_sungetwc(Stack (ptr32 Eq_100131) dwArg04)
void _IO_sungetwc(struct Eq_100131 * dwArg04)
{
	word32 eax_44;
	struct Eq_100133 * eax_14 = dwArg04->ptr0058;
	Eq_2 esp_12 = fp - 0x0C;
	struct Eq_100141 * edx_15 = eax_14->ptr0000;
	if (edx_15 > eax_14->ptr0008)
	{
		eax_14->ptr0000 = edx_15 - 0x04;
		eax_44 = edx_15->dwFFFFFFFC;
	}
	else
	{
		struct Eq_100149 * esi_18 = dwArg04->ptr0094;
		if (esi_18 >= &__elf_set___libc_atexit_element__IO_cleanup__)
		{
			word32 edx_92;
			word32 ecx_91;
			_IO_vtable_check(out ecx_91, out edx_92);
			esp_12.u0 = <invalid>;
		}
		struct Eq_100177 * esp_34 = esp_12 - 0x08;
		esp_34->dwFFFFFFFC = ~0x00;
		esp_34->ptrFFFFFFF8 = dwArg04;
		esi_18->ptr0018();
	}
	if (eax_44 != ~0x00)
		dwArg04->dw0000 &= ~0x10;
}

// 08084B50: void _IO_adjust_wcolumn(Stack (ptr32 Eq_100192) dwArg08, Stack ui32 dwArg0C)
void _IO_adjust_wcolumn(struct Eq_100192 * dwArg08, ui32 dwArg0C)
{
	struct Eq_100192 * eax_9 = dwArg08 + dwArg0C;
	if (dwArg08 >= eax_9)
		return;
	struct Eq_100192 * edx_13 = eax_9 - 0x04;
	if (eax_9->dwFFFFFFFC == 0x0A)
		return;
	do
	{
		if (dwArg08 >= edx_13)
			return;
		edx_13 -= 0x04;
	} while (edx_13->dw0000 != 0x0A);
}

// 08084BA0: void _IO_init_wmarker(Stack (ptr32 Eq_100215) dwArg04, Stack Eq_2 dwArg08)
void _IO_init_wmarker(struct Eq_100215 * dwArg04, Eq_2 dwArg08)
{
	byte dh_15 = *((word32) dwArg08 + 1);
	dwArg04->t0004 = dwArg08;
	if ((dh_15 & 0x08) != 0x00)
	{
		_IO_switch_to_wget_mode(dwArg08);
		dh_15 = (byte) *((word32) dwArg08 + 1);
	}
	int32 eax_44;
	Eq_2 ecx_35 = *((word32) dwArg08 + 88);
	int32 eax_36 = *ecx_35;
	if ((dh_15 & 0x01) != 0x00)
		eax_44 = eax_36 - *((word32) ecx_35 + 4) >> 0x02;
	else
		eax_44 = eax_36 - *((word32) ecx_35 + 8) >> 0x02;
	dwArg04->dw0008 = eax_44;
	dwArg04->ptr0000 = (struct Eq_100215 *) *((word32) dwArg08 + 48);
	*((word32) dwArg08 + 48) = dwArg04;
}

// 08084C00: void _IO_wmarker_delta(Stack (ptr32 Eq_100270) dwArg04)
void _IO_wmarker_delta(struct Eq_100270 * dwArg04)
{
	struct Eq_100271 * eax_8 = dwArg04->ptr0004;
	if (eax_8 == null)
		return;
	(eax_8->b0001 & 0x01) != 0x00;
}

// 08084C40: void _IO_seekwmark(Stack (ptr32 Eq_100284) dwArg04, Stack (ptr32 Eq_100285) dwArg08)
void _IO_seekwmark(struct Eq_100284 * dwArg04, struct Eq_100285 * dwArg08)
{
	if (dwArg08->ptr0004 == dwArg04)
	{
		word32 edi_26;
		ui32 ecx_18 = dwArg04->dw0000;
		byte ch_30 = SLICE(ecx_18, byte, 8);
		byte cl_35 = (byte) ecx_18;
		word16 ecx_16_16_36 = SLICE(ecx_18, word16, 16);
		int32 ebx_19 = dwArg08->dw0008;
		struct Eq_100305 * eax_20 = dwArg04->ptr0058;
		if (ebx_19 >= 0x00)
		{
			edi_26 = eax_20->dw0008;
			if ((ecx_18 & 0x0100) != 0x00)
			{
				dwArg04->dw0000 = SEQ(ecx_16_16_36, ch_30 & ~0x01, cl_35);
				word32 ecx_56 = eax_20->dw0028;
				eax_20->dw0028 = eax_20->dw0004;
				word32 edx_58 = eax_20->dw0020;
				eax_20->dw0004 = ecx_56;
				eax_20->dw0020 = edi_26;
				eax_20->dw0008 = edx_58;
				edi_26 = edx_58;
			}
		}
		else
		{
			edi_26 = eax_20->dw0004;
			if ((ecx_18 & 0x0100) == 0x00)
			{
				word32 esi_34 = eax_20->dw0020;
				dwArg04->dw0000 = SEQ(ecx_16_16_36, ch_30 | 0x01, cl_35);
				word32 edx_39 = eax_20->dw0028;
				word32 ecx_40 = eax_20->dw0008;
				eax_20->dw0028 = edi_26;
				eax_20->dw0004 = edx_39;
				eax_20->dw0008 = esi_34;
				eax_20->dw0020 = ecx_40;
				edi_26 = edx_39;
			}
		}
		eax_20->dw0000 = edi_26 + ebx_19 * 0x04;
	}
}

// 08084CD0: void _IO_unsave_wmarkers(Stack Eq_2 dwArg04)
void _IO_unsave_wmarkers(Eq_2 dwArg04)
{
	if (*((word32) dwArg04 + 48) != 0x00)
		*((word32) dwArg04 + 48) = 0x00;
	if (*((word32) dwArg04 + 36) == 0x00)
		return;
	_IO_free_wbackup_area(dwArg04);
}

// 08084D10: void do_encoding(Stack (ptr32 Eq_100406) dwArg04)
void do_encoding(struct Eq_100406 * dwArg04)
{
	struct Eq_100407 * edx_6 = dwArg04->ptr0024;
	if (edx_6->dw0034 != 0x00)
		return;
	edx_6->dw0024 == edx_6->dw0028;
}

// 08084D40: void do_always_noconv()
void do_always_noconv()
{
}

// 08084D50: void do_max_length()
void do_max_length()
{
}

// 08084D60: void do_in(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack (ptr32 Eq_2) dwArg20)
void do_in(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, union Eq_2 * dwArg20)
{
	struct Eq_100432 * eax_25 = *((word32) dwArg04 + 36);
	ui32 eax_18 = gs->dw0014;
	Eq_2 ebx_29 = eax_25->t0014;
	*((word32) dwArg04 + 40) = dwArg18;
	*((word32) dwArg04 + 44) = dwArg1C;
	*((word32) dwArg04 + 60) = dwArg08;
	if (eax_25->dw0000 != 0x00)
		ebx_29 = __ror(ebx_29, 0x09) ^ gs->t0018;
	word32 edx_234;
	word32 ecx_233;
	_dl_mcount_wrapper_check(gs, dwLoc50, ebx_29, out ecx_233, out edx_234);
	int32 eax_87;
	ebx_29();
	*dwArg14 = (union Eq_2 *) dwArg0C;
	*dwArg20 = (union Eq_2 *) *((word32) dwArg04 + 40);
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_236;
	word32 ecx_235;
	__stack_chk_fail(out ecx_235, out edx_236);
	do_unshift(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
}

// 08084E50: void do_unshift(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack (ptr32 Eq_2) dwArg20)
// Called from:
//      do_in
void do_unshift(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, union Eq_2 * dwArg20)
{
	ui32 eax_18 = gs->dw0014;
	*((word32) dwArg04 + 80) = dwArg0C;
	Eq_2 edi_26 = *((word32) dwArg04 + 76);
	*((word32) dwArg04 + 84) = dwArg10;
	Eq_2 ebx_29 = *((word32) edi_26 + 20);
	*((word32) dwArg04 + 100) = dwArg08;
	if (*edi_26 != 0x00)
		ebx_29 = __ror(ebx_29, 0x09) ^ gs->t0018;
	word32 edx_217;
	word32 ecx_216;
	_dl_mcount_wrapper_check(gs, dwLoc40, ebx_29, out ecx_216, out edx_217);
	int32 eax_76;
	ebx_29();
	*dwArg14 = (union Eq_2 *) *((word32) dwArg04 + 80);
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_219;
	word32 ecx_218;
	__stack_chk_fail(out ecx_218, out edx_219);
	do_out(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18, dwArg1C, dwArg20);
}

// 08084F20: void do_out(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack (ptr32 Eq_2) dwArg20)
// Called from:
//      do_unshift
void do_out(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, union Eq_2 * dwArg20)
{
	Eq_2 eax_25 = *((word32) dwArg04 + 76);
	ui32 eax_18 = gs->dw0014;
	Eq_2 ebx_29 = *((word32) eax_25 + 20);
	*((word32) dwArg04 + 80) = dwArg18;
	*((word32) dwArg04 + 84) = dwArg1C;
	*((word32) dwArg04 + 100) = dwArg08;
	if (*eax_25 != 0x00)
		ebx_29 = __ror(ebx_29, 0x09) ^ gs->t0018;
	word32 edx_231;
	word32 ecx_230;
	_dl_mcount_wrapper_check(gs, dwLoc50, ebx_29, out ecx_230, out edx_231);
	int32 eax_87;
	ebx_29();
	*dwArg14 = (union Eq_2 *) dwArg0C;
	*dwArg20 = (union Eq_2 *) *((word32) dwArg04 + 80);
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_233;
	word32 ecx_232;
	__stack_chk_fail(out ecx_232, out edx_233);
	do_length(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
}

// 08085010: void do_length(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack (ptr32 Eq_2) dwArg14)
// Called from:
//      do_out
void do_length(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 * dwArg14)
{
	ui32 esi_30 = (dwArg14 << 0x02) + 0x0F;
	struct Eq_100659 * esp_17 = fp - 0x3C;
	ui32 eax_24 = gs->dw0014;
	struct Eq_100659 * edx_36 = fp - 0x3C - (esi_30 & ~0x0FFF);
	if (fp - 0x3C != edx_36)
	{
		do
		{
			esp_17 -= 0x1000;
			esp_17->dw0FFC = esp_17->dw0FFC;
		} while (esp_17 != edx_36);
	}
	if ((esi_30 & ~0x0F & 0x0FFF) != 0x00)
	{
		esp_17 -= esi_30 & ~0x0F & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[(esi_30 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[(esi_30 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_100703 * esi_67 = *((word32) dwArg04 + 36);
	*((word32) dwArg04 + 60) = dwArg08;
	*((word32) dwArg04 + 40) = esp_17;
	word32 edx_79 = esi_67->dw0000;
	*((word32) dwArg04 + 44) = esp_17 + (dwArg14 << 0x02) / 0x00001000;
	Eq_2 eax_81 = esi_67->t0014;
	if (edx_79 != 0x00)
		eax_81 = __ror(eax_81, 0x09) ^ gs->t0018;
	struct Eq_100728 * esp_94 = esp_17 - 0x0C;
	esp_94->tFFFFFFFC = eax_81;
	word32 ecx_257;
	word32 edx_258;
	_dl_mcount_wrapper_check(gs, esp_94->tFFFFFFF8, esp_94->tFFFFFFFC, out ecx_257, out edx_258);
	esp_94->tFFFFFFF8.u0 = 0x00;
	esp_94->dwFFFFFFF4 = 0x00;
	esp_94->ptrFFFFFFF0 = fp - 0x24;
	esp_94->dwFFFFFFEC = 0x00;
	esp_94->tFFFFFFE8 = dwArg10;
	esp_94->ptrFFFFFFE4 = fp - 0x28;
	esp_94->ptrFFFFFFE0 = (word32) dwArg04 + 40;
	esp_94->ptrFFFFFFDC = esi_67;
	eax_81();
	if ((eax_24 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_259;
	word32 edx_260;
	__stack_chk_fail(out ecx_259, out edx_260);
	word32 ebp_263;
	word32 esi_264;
	word32 ecx_261;
	word32 edx_262;
	_IO_fwide(gs, dwArg04, dwArg08, out ecx_261, out edx_262, out ebp_263, out esi_264);
}

// 080850F0: Register word32 _IO_fwide(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 ecxOut, Register out Eq_2 edxOut, Register out ptr32 ebpOut, Register out Eq_2 esiOut)
// Called from:
//      __vfwprintf
//      buffered_vfprintf
//      __woverflow
//      __wuflow
//      __wunderflow
//      do_length
word32 _IO_fwide(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & ecxOut, union Eq_2 & edxOut, ptr32 & ebpOut, union Eq_2 & esiOut)
{
	ui32 eax_20 = gs->dw0014;
	Eq_2 edx_24 = dwArg08;
	word32 eax_107 = *((word32) dwArg04 + 0x0068);
	if (dwArg08 >= 0x00)
	{
		if (eax_107 != 0x00 || dwArg08 == 0x00)
			goto l08085129;
		struct Eq_93235 * ebx_39 = *((word32) dwArg04 + 88);
		word32 ecx_43 = ebx_39->dw0004;
		*((word32) dwArg04 + 84) = &ebx_39->dw0038 + 1;
		ebx_39->dw0000 = ecx_43;
		Eq_2 ecx_47 = ebx_39->t000C;
		ebx_39->dw002C = 0x00;
		ebx_39->t0010 = ecx_47;
		ebx_39->dw0030 = 0x00;
		struct Eq_93235 * ecx_51 = *((word32) dwArg04 + 88);
		ecx_51->dw0034 = 0x00;
		ecx_51->dw0038 = 0x00;
		__wcsmbs_clone_conv(gs, fp - 0x30);
		if (dwLoc2C != 0x01)
			goto l0808529B;
		if (dwLoc24 != 0x01)
		{
l0808527F:
			word32 ecx_299;
			word32 edx_300;
			__assert_fail(out ecx_299, out edx_300);
l0808529B:
			word32 edx_298;
			word32 ecx_297;
			__assert_fail(out ecx_297, out edx_298);
			Eq_2 edx_184;
			ptr32 ecx_185;
			word32 eax_183 = __libc_enable_asynccancel(gs, out ecx_185, out edx_184);
			ecxOut = ecx_185;
			edxOut = edx_184;
			ebpOut = 0x080CE000;
			esiOut = dwArg04;
			return eax_183;
		}
		word32 * edi_112 = &ebx_39->dw0038 + 1;
		word32 ecx_115;
		for (ecx_115 = 0x1C; ecx_115 != 0x00; --ecx_115)
		{
			*edi_112 = eax_107;
			++edi_112;
		}
		ebx_39->dw005C = 0x01;
		ebx_39->ptr0040 = 0x08084F20;
		ebx_39->ptr0044 = 0x08084E50;
		ebx_39->ptr0048 = 0x08084D60;
		ebx_39->ptr004C = 0x08084D10;
		ebx_39->ptr0050 = 0x08084D40;
		ebx_39->ptr0054 = 0x08085010;
		ebx_39->ptr0058 = 0x08084D50;
		ebx_39->dw0074 = 0x01;
		ebx_39->dw0060 = dwLoc30;
		struct Eq_93235 * eax_96 = *((word32) dwArg04 + 88);
		ebx_39->dw006C = 0x01;
		Eq_2 eax_99 = eax_96->t00B0;
		ebx_39->dw0084 = 0x01;
		ebx_39->ptr0078 = &eax_96->dw002C;
		ebx_39->ptr0088 = dwLoc28;
		ebx_39->dw009C = 0x01;
		ebx_39->dw0094 = 0x09;
		ebx_39->ptr00A0 = &eax_96->dw002C;
		*((word32) dwArg04 + 0x0094) = eax_99;
		ecx = dwLoc28;
		edx_24 = &eax_96->dw002C;
		eax_107 = 0x01;
	}
	else
	{
		if (eax_107 != 0x00)
			goto l08085129;
		eax_107 = ~0x00;
	}
	*((word32) dwArg04 + 0x0068) = eax_107;
l08085129:
	if ((eax_20 ^ gs->dw0014) == 0x00)
	{
		ecxOut = ecx;
		edxOut = edx_24;
		ebpOut = ebp;
		esiOut = esi;
		return eax_107;
	}
	word32 ecx_295;
	word32 edx_296;
	__stack_chk_fail(out ecx_295, out edx_296);
	goto l0808527F;
}

// 080852C0: Register Eq_2 __libc_enable_asynccancel(Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      open
//      read
//      __libc_write
//      _IO_fwide
Eq_2 __libc_enable_asynccancel(struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_15 = gs->t0084;
	while (true)
	{
		Eq_2 eax_21;
		Eq_2 ecx_18 = edx_15 | 0x02;
		if (edx_15 == ecx_18)
			break;
		__lock();
		__cmpxchg(gs->t0084, edx_15 | 0x02, edx_15, out eax_21);
		if (edx_15 == eax_21)
		{
			ecx_18 = (edx_15 | 0x02) & ~0x44;
			if (ecx_18 != 0x0A)
				goto l080852FD;
			gs->dw0228 = ~0x00;
			__lock();
			gs->t0084 |= 0x10;
			fn00000000();
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			Eq_2 edx_49;
			Eq_2 ecx_50;
			Eq_2 eax_51 = __libc_disable_asynccancel(gs, stackArg4, out ecx_50, out edx_49);
			ecxOut = ecx_50;
			edxOut = edx_49;
			return eax_51;
		}
		edx_15 = eax_21;
	}
	eax_21 = edx_15;
l080852FD:
	ecxOut = ecx_18;
	edxOut = edx_15;
	return eax_21;
}

// 08085340: Register Eq_2 __libc_disable_asynccancel(Register (ptr32 Eq_9) gs, Stack Eq_2 bArg04, Register out Eq_44730 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      open
//      read
//      __libc_write
//      __libc_enable_asynccancel
Eq_2 __libc_disable_asynccancel(struct Eq_9 * gs, Eq_2 bArg04, union Eq_44730 & ecxOut, union Eq_2 & edxOut)
{
	if ((bArg04 & 0x02) == 0x00)
	{
		Eq_2 ecx_24 = gs->t0084;
		while (true)
		{
			__lock();
			edx = ecx_24 & ~0x02;
			__cmpxchg(gs->t0084, edx, ecx_24, out eax);
			if (ecx_24 == eax)
				break;
			ecx_24 = eax;
		}
		ecx = ecx_24 & 0x0C;
		if (ecx == 0x04)
		{
			do
			{
				word32 edx_56;
				up32 eax_57;
				gs->ptr0010();
				if (eax_57 > ~0x0FFF)
				{
					ecx = eax_57 + 11;
					byte cl_65 = (byte) (eax_57 + 11);
					if (eax_57 > 0x00 || (0x01 << cl_65 & 0x0881) == 0x00)
					{
						word32 ecx_174;
						__libc_fatal(out ecx_174);
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						Eq_44730 ecx_86;
						Eq_2 edx_87;
						Eq_2 eax_88 = __libc_scratch_buffer_grow_preserve(gs, stackArg4, out ecx_86, out edx_87);
						ecxOut = ecx_86;
						edxOut = edx_87;
						return eax_88;
					}
				}
				edx = gs->t0084;
				eax = edx & 0x0C;
			} while ((edx & 0x0C) == 0x04);
		}
	}
	ecxOut = ecx;
	edxOut = edx;
	return eax;
}

// 08085400: Register word32 __libc_scratch_buffer_grow_preserve(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out ptr32 edxOut)
// Called from:
//      printf_positional
//      printf_positional
//      __libc_disable_asynccancel
word32 __libc_scratch_buffer_grow_preserve(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut, ptr32 & edxOut)
{
	Eq_2 ecx_106;
	ptr32 edx_163;
	word32 eax_103;
	Eq_2 edx_20 = *((word32) dwArg04 + 4);
	Eq_2 ebp_21 = *dwArg04;
	if (ebp_21 == (word32) dwArg04 + 16)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_173;
		word32 ebx_174;
		word32 ebp_175;
		word32 esi_176;
		word32 edi_177;
		Eq_2 eax_33 = __libc_malloc(gs, stackArg0, edx_20 * 0x02, out ecx_173, out edx_163, out ebx_174, out ebp_175, out esi_176, out edi_177);
		ecx_106 = eax_33;
		eax_103 = 0x00;
		if (eax_33 == 0x00)
			goto l08085452;
		word32 ecx_182;
		memcpy(eax_33, ebp_21, edx_20, out ecx_182, out edx_163);
		ecx_106 = eax_33;
l08085448:
		*dwArg04 = ecx_106;
		*((word32) dwArg04 + 4) = edx_20 * 0x02;
		eax_103 = 0x01;
		goto l08085452;
	}
	else
	{
		if (edx_20 <= edx_20 * 0x02)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ebp_179;
			word32 esi_180;
			word32 edi_181;
			Eq_2 eax_75 = __realloc(gs, stackArg0, ebp_21, edx_20 * 0x02, out edx_163, out ebp_179, out esi_180, out edi_181);
			ecx_106 = eax_75;
			if (eax_75 != 0x00)
				goto l08085448;
			ebp_21 = *dwArg04;
		}
		else
			gs->tFFFFFFE0.u0 = 0x0C;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		free(gs, stackArg0, ebp_21, out ecx_106, out edx_163);
		((word32) dwArg04 + 4)->u0 = 0x0400;
		*dwArg04 = (word32) dwArg04 + 16;
		eax_103 = 0x00;
l08085452:
		ecxOut = ecx_106;
		edxOut = edx_163;
		return eax_103;
	}
}

// 080854D0: Register byte __libc_scratch_buffer_set_array_size(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut, Register out Eq_74771 edxOut)
// Called from:
//      _i18n_number_rewrite
//      printf_positional
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      printf_positional
//      _dl_map_object_deps
byte __libc_scratch_buffer_set_array_size(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut, union Eq_74771 & edxOut)
{
	Eq_2 ecx_110 = dwArg08;
	Eq_2 edi_25 = dwArg08 *s dwArg0C;
	if ((dwArg08 | dwArg0C) >> 0x10 != 0x00 && dwArg08 != 0x00)
	{
		uint64 edx_eax_34 = (uint64) edi_25;
		edx.u0 = (uint32) (edx_eax_34 % dwArg08);
		if ((uint32) (edx_eax_34 /u dwArg08) != dwArg0C)
		{
			Eq_2 eax_40 = *dwArg04;
			if (eax_40 != (word32) dwArg04 + 16)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				free(gs, stackArg0, eax_40, out ecx_110, out edx);
			}
			*dwArg04 = (word32) dwArg04 + 16;
			((word32) dwArg04 + 4)->u0 = 0x0400;
			gs->tFFFFFFE0.u0 = 0x0C;
			ecxOut = ecx_110;
			edxOut = edx;
			return 0x00;
		}
	}
	if (*((word32) dwArg04 + 4) < edi_25)
	{
		Eq_2 eax_81 = *dwArg04;
		if (eax_81 != (word32) dwArg04 + 16)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 ecx_219;
			word32 edx_220;
			free(gs, stackArg0, eax_81, out ecx_219, out edx_220);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ebx_214;
		word32 ebp_215;
		word32 esi_216;
		word32 edi_217;
		Eq_2 eax_111 = __libc_malloc(gs, stackArg0, edi_25, out ecx_110, out edx, out ebx_214, out ebp_215, out esi_216, out edi_217);
		if (eax_111 == 0x00)
		{
			*dwArg04 = (word32) dwArg04 + 16;
			((word32) dwArg04 + 4)->u0 = 0x0400;
			ecxOut = ecx_110;
			edxOut = edx;
			return (byte) eax_111;
		}
		*((word32) dwArg04 + 4) = edi_25;
		*dwArg04 = eax_111;
	}
	ecxOut = ecx_110;
	edxOut = edx;
	return 0x01;
}

// 080855B0: Register Eq_2 __strndup(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_69653) ebpOut)
// Called from:
//      _nl_find_locale
Eq_2 __strndup(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_69653 & ebpOut)
{
	struct Eq_69653 * ebp_36;
	Eq_2 edi_39;
	Eq_2 esi_41;
	word32 ecx_110;
	word32 edx_111;
	word32 ecx_112;
	word32 edx_113;
	word32 ebx_114;
	Eq_2 eax_35 = __libc_malloc(gs, dwLoc20, (word32) strnlen(dwArg04, dwArg08, out ecx_110, out edx_111) + 1, out ecx_112, out edx_113, out ebx_114, out ebp_36, out esi_41, out edi_39);
	if (eax_35 != 0x00)
	{
		Mem52[eax_35 + esi_41:byte] = 0x00;
		word32 ecx_115;
		word32 edx_116;
		eax_35 = memcpy(eax_35, edi_39, esi_41, out ecx_115, out edx_116);
	}
	ebpOut = ebp_36;
	return eax_35;
}

// 08085600: Register Eq_2 strerror_r(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 esiOut)
// Called from:
//      _dl_start_profile
//      fatal_error
//      strerror
Eq_2 strerror_r(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2 eax_241;
	Eq_2 ebp_103;
	Eq_2 edx_101;
	ui32 eax_20 = gs->dw0014;
	Eq_2 esi_164 = dwArg04;
	if (dwArg04 >= 0x00)
	{
		if (_sys_nerr_internal > dwArg04 && ((word32[]) 0x080CD6A0)[dwArg04] != 0x00)
		{
			word32 edx_480;
			eax_241 = dcgettext(out edx_480);
			ebp_103 = ebp;
			goto l0808565E;
		}
		word32 edx_475;
		Eq_2 eax_129 = dcgettext(out edx_475);
		word32 edx_477;
		word32 ecx_476;
		Eq_2 eax_135 = strlen(eax_129, out ecx_476, out edx_477);
		ebp_103 = eax_135;
		word32 ecx_478;
		word32 edx_479;
		esi_164 = _itoa_word(dwArg04, fp - 33, 0x0A, 0x00, out ecx_478, out edx_479);
		Eq_2 eax_165 = eax_135;
		if (dwArg0C <= eax_135)
			eax_165 = dwArg0C;
		word32 edx_488;
		edx_101 = __mempcpy(dwArg08, eax_129, eax_165, out edx_488);
		if (dwArg0C <= eax_135)
		{
l08085798:
			if (dwArg0C == 0x00)
			{
				eax_241 = dwArg08;
l0808565E:
				if ((eax_20 ^ gs->dw0014) != 0x00)
				{
					word32 ecx_481;
					word32 edx_482;
					__stack_chk_fail(out ecx_481, out edx_482);
					word32 ecx_486;
					word32 edx_487;
					Eq_2 eax_298 = strnlen(dwLoc48, dwLoc44, out ecx_486, out edx_487);
					ebxOut = 0x080CE000;
					ebpOut = ebp_103;
					esiOut = esi_164;
					return eax_298;
				}
				else
				{
					ebxOut = ebx;
					ebpOut = ebp;
					esiOut = esi;
					return eax_241;
				}
			}
			goto l08085716;
		}
	}
	else
	{
		word32 edx_470;
		Eq_2 eax_40 = dcgettext(out edx_470);
		word32 edx_472;
		word32 ecx_471;
		Eq_2 eax_46 = strlen(eax_40, out ecx_471, out edx_472);
		ebp_103 = eax_46;
		word32 ecx_473;
		word32 edx_474;
		esi_164 = _itoa_word(-dwArg04, fp - 33, 0x0A, 0x00, out ecx_473, out edx_474);
		Eq_2 eax_76 = eax_46;
		if (eax_46 > dwArg0C)
			eax_76 = dwArg0C;
		word32 edx_483;
		Eq_2 eax_89 = __mempcpy(dwArg08, eax_40, eax_76, out edx_483);
		if (eax_46 >= dwArg0C)
			goto l08085798;
		*eax_89 = 0x2D;
		edx_101 = (word32) eax_89 + 1;
		ebp_103 = (word32) eax_46 + 1;
		if (dwArg0C <= (word32) eax_46 + 1)
		{
l08085716:
			*((word32) dwArg0C + (dwArg08 - 0x01)) = 0x00;
			eax_241 = dwArg08;
			goto l0808565E;
		}
	}
	Eq_2 ecx_198 = fp - 0x20 - esi_164;
	Eq_2 eax_200 = dwArg0C - ebp_103;
	if (eax_200 > ecx_198)
		eax_200 = ecx_198;
	word32 edx_485;
	word32 ecx_484;
	memcpy(edx_101, esi_164, eax_200, out ecx_484, out edx_485);
	goto l08085716;
}

// 080857B0: Register int32 strnlen(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      two_way_long_needle
//      strstr
//      __mbsrtowcs_l
//      add_module.isra.0
//      __strndup
//      strerror_r
int32 strnlen(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	int32 eax_110 = 0x00;
	Eq_2 edx_101 = dwArg08;
	byte bl_24 = (byte) dwArg04;
	if (dwArg08 != 0x00)
	{
		word32 eax_139 = dwArg08 + dwArg04;
		if (eax_139 < 0x00)
			eax_139.u0 = ~0x00;
		edx_101 = dwArg04;
		if ((bl_24 & 0x03) != 0x00)
		{
			if (*dwArg04 != 0x00)
			{
				do
				{
					edx_101 = (word32) edx_101 + 1;
					if (((byte) edx_101 & 0x03) == 0x00)
						goto l080857ED;
				} while (*edx_101 != 0x00);
			}
			if (eax_139 > edx_101)
				eax_139 = edx_101;
			ecxOut = ecx;
			edxOut = edx_101;
			return eax_139 - dwArg04;
		}
l080857ED:
		if (eax_139 > edx_101)
		{
			do
			{
				ecx = (word32) edx_101 + 4;
				if ((*((word32) ecx - 4) - 0x01010101 & 0x80808080) != 0x00)
				{
					if (*((word32) ecx - 4) == 0x00)
					{
						if (eax_139 > edx_101)
							eax_139 = edx_101;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
					if (*((word32) ecx - 3) == 0x00)
					{
						ecx = (word32) edx_101 + 1;
						if (eax_139 > ecx)
							eax_139 = ecx;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
					if (*((word32) ecx - 2) == 0x00)
					{
						ecx = (word32) edx_101 + 2;
						if (eax_139 > ecx)
							eax_139 = ecx;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
					if (*((word32) ecx - 1) == 0x00)
					{
						ecx = (word32) edx_101 + 3;
						if (eax_139 > ecx)
							eax_139 = ecx;
						eax_110 = eax_139 - dwArg04;
						goto l0808582C;
					}
				}
				edx_101 = ecx;
			} while (eax_139 > ecx);
		}
		eax_110 = eax_139 - dwArg04;
	}
l0808582C:
	ecxOut = ecx;
	edxOut = edx_101;
	return eax_110;
}

// 08085870: Register Eq_2 rindex(Stack Eq_2 dwArg04, Stack Eq_2 bArg08)
// Called from:
//      __init_misc
//      _nl_find_locale
Eq_2 rindex(Eq_2 dwArg04, Eq_2 bArg08)
{
	byte cl_13 = (byte) dwArg08;
	Eq_101562 ecx_16 = SEQ(SLICE(dwArg08, word16, 16), cl_13, cl_13);
	Eq_2 eax_10 = 0x00;
	Eq_2 esi_11 = dwArg04;
	word32 ecx_312 = SEQ(ecx_16, ecx_16);
	word24 ecx_24_8_322 = SEQ(ecx_16, cl_13);
	if ((dwArg04 & 0x03) != 0x00)
	{
		byte dl_24 = *dwArg04;
		if (cl_13 == dl_24)
			eax_10 = dwArg04;
		ecx_312 = SEQ(ecx_24_8_322, cl_13);
		if (dl_24 == 0x00)
			return eax_10;
		esi_11 = dwArg04 + 0x01;
		if ((dwArg04 + 0x01 & 0x03) != 0x00)
		{
			byte dl_40 = Mem9[dwArg04 + 0x01:byte];
			if (cl_13 == dl_40)
				eax_10 = dwArg04 + 0x01;
			ecx_312 = SEQ(ecx_24_8_322, cl_13);
			if (dl_40 == 0x00)
				return eax_10;
			esi_11 = dwArg04 + 0x02;
			if ((dwArg04 + 0x02 & 0x03) != 0x00)
			{
				byte dl_56 = Mem9[dwArg04 + 0x02:byte];
				if (cl_13 == dl_56)
					eax_10 = dwArg04 + 0x02;
				if (dl_56 == 0x00)
					return eax_10;
				esi_11 = dwArg04 + 0x03;
			}
		}
	}
	while (true)
	{
		byte cl_183 = (byte) ecx_312;
		uint32 edx_451 = *esi_11;
		if (edx_451 >= ~0x01010100 || (edx_451 + ~0x01010100 ^ edx_451 | ~0x01010100) != 0x01)
			break;
		uint32 edx_109 = edx_451 ^ ecx_312;
		if (edx_109 < ~0x01010100)
		{
			if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) == 0x01)
			{
				uint32 edx_453 = *((word32) esi_11 + 4);
				if (edx_453 < ~0x01010100 && (edx_453 + ~0x01010100 ^ edx_453 | ~0x01010100) == 0x01)
				{
					edx_109 = edx_453 ^ ecx_312;
					if (edx_109 >= ~0x01010100)
						goto l080858E1;
					if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) != 0x01)
						goto l080858F7;
					uint32 edx_126 = *((word32) esi_11 + 8);
					if (edx_126 < ~0x01010100 && (edx_126 + ~0x01010100 ^ edx_126 | ~0x01010100) == 0x01)
					{
						edx_109 = edx_126 ^ ecx_312;
						if (edx_109 >= ~0x01010100)
							goto l080858E4;
						if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) != 0x01)
							goto l080858FA;
						edx_126 = (uint32) *((word32) esi_11 + 0x0C);
						if (edx_126 < ~0x01010100 && (edx_126 + ~0x01010100 ^ edx_126 | ~0x01010100) == 0x01)
						{
							edx_109 = edx_126 ^ ecx_312;
							if (edx_109 >= ~0x01010100)
								goto l080858E7;
							if ((edx_109 + ~0x01010100 ^ edx_109 | ~0x01010100) != 0x01)
								goto l080858FD;
							goto l08085914;
						}
						esi_11 = (word32) esi_11 + 4;
					}
					esi_11 = (word32) esi_11 + 4;
					edx_453 = edx_126;
				}
				esi_11 = (word32) esi_11 + 4;
				edx_451 = edx_453;
				break;
			}
			esi_11 -= 0x04;
l080858F7:
			esi_11 -= 0x04;
l080858FA:
			esi_11 -= 0x04;
			goto l080858FD;
		}
		esi_11 -= 0x04;
l080858E1:
		esi_11 -= 0x04;
l080858E4:
		esi_11 -= 0x04;
l080858E7:
		if ((edx_109 & 0xFF000000) == 0x00)
			eax_10 = (word32) esi_11 + 0x0F;
		else
		{
l080858FD:
			byte dh_295 = SLICE(edx_109, byte, 8);
			if ((edx_109 & 0x00FF0000) == 0x00)
				eax_10 = (word32) esi_11 + 0x0E;
			else
			{
				eax_10 = (word32) esi_11 + 0x0C;
				if (dh_295 == 0x00)
					eax_10 = (word32) esi_11 + 0x0D;
			}
		}
l08085914:
		esi_11 = (word32) esi_11 + 16;
	}
	byte dh_196 = SLICE(edx_451, byte, 8);
	byte dl_174 = (byte) edx_451;
	if (dl_174 == cl_183)
		eax_10 = esi_11;
	if (dl_174 != 0x00)
	{
		if (dh_196 == cl_183)
			eax_10 = (word32) esi_11 + 1;
		if (dh_196 != 0x00)
		{
			byte dl_226 = (byte) (edx_451 >> 0x10);
			byte dh_237 = SLICE(edx_451 >> 0x10, byte, 8);
			if (dl_226 == cl_183)
				eax_10 = (word32) esi_11 + 2;
			if (dl_226 != 0x00 && dh_237 == cl_183)
				eax_10 = (word32) esi_11 + 3;
		}
	}
	return eax_10;
}

// 08085A30: Register Eq_2 __strtok_r(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __gconv_open
//      __gconv_get_path
Eq_2 __strtok_r(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 ebx_13 = dwArg04;
	if (dwArg04 == 0x00)
		ebx_13 = *dwArg0C;
	if (*ebx_13 != 0x00)
	{
		ebx_13 = (word32) ebx_13 + strspn(ebx_13, dwArg08);
		if (*ebx_13 != 0x00)
		{
			word32 eax_72 = strcspn(ebx_13, dwArg08) + ebx_13;
			if (*eax_72 != 0x00)
			{
				*eax_72 = 0x00;
				eax_72 = (word32) eax_72 + 1;
			}
			*dwArg0C = eax_72;
			return ebx_13;
		}
	}
	*dwArg0C = ebx_13;
	return 0x00;
}

// 08085AA0: Register Eq_2 __memchr(Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Stack Eq_2 dwArg0C)
// Called from:
//      next_line
//      _nl_find_locale
//      _IO_getdelim
//      _IO_getline_info
//      __memmem
Eq_2 __memchr(Eq_2 dwArg04, Eq_2 bArg08, Eq_2 dwArg0C)
{
	Eq_2 eax_10 = dwArg04;
	byte al_23 = (byte) dwArg04;
	byte dl_15 = (byte) dwArg08;
	word16 edx_16_16_17 = SLICE(dwArg08, word16, 16);
	Eq_2 esi_12 = dwArg0C;
	if (dwArg0C < 0x04)
	{
l08085BFF:
		ui32 esi_214 = esi_12 & 0x03;
		if (esi_214 != 0x00)
		{
			if (*eax_10 == dl_15)
				return eax_10;
			eax_10 = (word32) eax_10 + 1;
			if (esi_214 != 0x01)
			{
				if (*eax_10 == dl_15)
					return eax_10;
				eax_10 = (word32) eax_10 + 1;
				if (esi_214 != 0x02 && *((word32) eax_10 + 1) == dl_15)
					return eax_10;
			}
		}
		goto l08085C18;
	}
	Eq_101838 edx_18 = SEQ(edx_16_16_17, dl_15, dl_15);
	word32 edx_258 = SEQ(edx_18, edx_18);
	if ((al_23 & 0x03) == 0x00)
	{
l08085B96:
		while (true)
		{
			Eq_101846 ecx_123;
			esi_12 -= 0x10;
			if (esi_12 < 0x00)
				break;
			ecx_123 = *eax_10 ^ edx_258;
			if (ecx_123 >= ~0x01010100 || ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) != 0x01)
				goto l08085C25;
			Eq_101846 ecx_346 = *((word32) eax_10 + 4) ^ edx_258;
			if (ecx_346 >= ~0x01010100 || ((word32) ecx_346.u0 - 0x01010101 ^ ecx_346 | ~0x01010100) != 0x01)
			{
l08085C22:
				eax_10 = (word32) eax_10 + 4;
				ecx_123 = ecx_346;
				goto l08085C25;
			}
			Eq_101846 ecx_348 = *((word32) eax_10 + 8) ^ edx_258;
			if (ecx_348 >= ~0x01010100 || ((word32) ecx_348.u0 - 0x01010101 ^ ecx_348 | ~0x01010100) != 0x01)
			{
l08085C1F:
				eax_10 = (word32) eax_10 + 4;
				ecx_346 = ecx_348;
				goto l08085C22;
			}
			ecx_348 = *((word32) eax_10 + 0x0C) ^ edx_258;
			if (ecx_348 >= ~0x01010100 || ((word32) ecx_348.u0 - 0x01010101 ^ ecx_348 | ~0x01010100) != 0x01)
			{
				eax_10 = (word32) eax_10 + 4;
				goto l08085C1F;
			}
			eax_10 = (word32) eax_10 + 16;
		}
		if (esi_12 >= ~0x0B)
		{
			ecx_123 = *eax_10 ^ edx_258;
			if (ecx_123 < ~0x01010100 && ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) == 0x01)
			{
				eax_10 = (word32) eax_10 + 4;
				if (esi_12 < ~0x07)
					goto l08085BFF;
				ecx_123 = *eax_10 ^ edx_258;
				if (ecx_123 < ~0x01010100 && ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) == 0x01)
				{
					eax_10 = (word32) eax_10 + 4;
					if (esi_12 < ~0x03)
						goto l08085BFF;
					ecx_123 = *((word32) eax_10 + 4) ^ edx_258;
					if (ecx_123 < ~0x01010100 && ((word32) ecx_123 - 0x01010101 ^ ecx_123 | ~0x01010100) == 0x01)
					{
						eax_10 = (word32) eax_10 + 8;
						goto l08085BFF;
					}
				}
			}
l08085C25:
			byte ch_179 = SLICE(ecx_123, byte, 8);
			if ((byte) ecx_123 != 0x00)
			{
				eax_10 = (word32) eax_10 + 1;
				if (ch_179 != 0x00)
				{
					eax_10 = (word32) eax_10 + 1;
					if ((ecx_123 & 0x00FF0000) != 0x00)
						eax_10 = (word32) eax_10 + 2;
				}
			}
			return eax_10;
		}
		goto l08085BFF;
	}
	else
	{
		if (*dwArg04 == dl_15)
			return eax_10;
		eax_10 = (word32) dwArg04 + 1;
		byte al_34 = (byte) ((word32) dwArg04 + 1);
		esi_12 = dwArg0C - 0x01;
		if (dwArg0C != 0x01)
		{
			if ((al_34 & 0x03) == 0x00)
				goto l08085B96;
			if (*((word32) dwArg04 + 1) == dl_15)
				return eax_10;
			eax_10 = (word32) dwArg04 + 2;
			byte al_44 = (byte) ((word32) dwArg04 + 2);
			esi_12 = dwArg0C - 0x02;
			if (dwArg0C != 0x02)
			{
				if ((al_44 & 0x03) != 0x00)
				{
					if (*((word32) dwArg04 + 2) == dl_15)
						return eax_10;
					eax_10 = (word32) dwArg04 + 3;
					esi_12 = dwArg0C - 0x03;
				}
				goto l08085B96;
			}
		}
l08085C18:
		eax_10.u0 = 0x00;
		return eax_10;
	}
}

// 08085C40: Register Eq_2 critical_factorization(Register Eq_2 eax, Register (ptr32 int32) ecx, Register Eq_2 edx)
// Called from:
//      two_way_long_needle
//      __memmem
Eq_2 critical_factorization(Eq_2 eax, int32 * ecx, Eq_2 edx)
{
	int32 ebp_46 = 0x01;
	int32 ebx_18 = 0x01;
	Eq_2 dwLoc20_152 = ~0x00;
	Eq_2 esi_26 = 0x00;
l08085C68:
	Eq_2 ecx_29 = (word32) esi_26 + ebx_18;
	while (ecx_29 < edx)
	{
		byte dl_42 = Mem31[eax + dwLoc20_152 + ebx_18:byte];
		if (Mem31[eax + ecx_29:byte] >=u dl_42)
		{
			if (Mem31[eax + ecx_29:byte] != dl_42)
			{
				dwLoc20_152 = esi_26;
				ebp_46 = 0x01;
				esi_26 = (word32) esi_26 + 1;
				ebx_18 = 0x01;
			}
			else if (ebx_18 != ebp_46)
				++ebx_18;
			else
			{
				esi_26 = ecx_29;
				ebx_18 = 0x01;
			}
			goto l08085C68;
		}
		esi_26 = ecx_29;
		ebx_18 = 0x01;
		ebp_46 = ecx_29 - dwLoc20_152;
		ecx_29 = (word32) ecx_29 + 1;
	}
	*ecx = ebp_46;
	int32 dwLoc18_161 = 0x01;
	int32 ebx_101 = 0x01;
	Eq_2 edi_105 = ~0x00;
	Eq_2 esi_100 = 0x00;
l08085CB8:
	Eq_2 ecx_115 = (word32) esi_100 + ebx_101;
	while (ecx_115 < edx)
	{
		byte dl_93 = Mem90[eax + edi_105 + ebx_101:byte];
		if (Mem90[eax + ecx_115:byte] <=u dl_93)
		{
			if (Mem90[eax + ecx_115:byte] != dl_93)
			{
				edi_105 = esi_100;
				dwLoc18_161 = 0x01;
				esi_100 = (word32) esi_100 + 1;
				ebx_101 = 0x01;
			}
			else if (ebx_101 != dwLoc18_161)
				++ebx_101;
			else
			{
				esi_100 = ecx_115;
				ebx_101 = 0x01;
			}
			goto l08085CB8;
		}
		ebx_101 = 0x01;
		dwLoc18_161 = ecx_115 - edi_105;
		esi_100 = ecx_115;
		ecx_115 = (word32) ecx_115 + 1;
	}
	Eq_2 edi_123 = (word32) edi_105 + 1;
	Eq_2 eax_124 = (word32) dwLoc20_152 + 1;
	if (edi_123 >= (word32) dwLoc20_152 + 1)
	{
		*ecx = dwLoc18_161;
		eax_124 = edi_123;
	}
	return eax_124;
}

// 08085D90: Register Eq_2 two_way_long_needle(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __memmem
Eq_2 two_way_long_needle(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 eax_30 = gs->dw0014;
	Eq_2 eax_36 = critical_factorization(ecx, fp - 0x0424, dwArg04);
	word32 * eax_45 = fp - 0x0420;
	do
	{
		*eax_45 = (word32) dwArg04;
		++eax_45;
	} while (eax_45 != fp - 0x20);
	word32 eax_55 = ecx + dwArg04;
	word32 ebx_58 = (word32) ecx + (dwArg04 - 0x01);
	Eq_2 eax_59 = ecx;
	if (dwArg04 != 0x00)
	{
		do
		{
			(fp - 0x0420)[(word32) *eax_59] = ebx_58 - eax_59;
			eax_59 = (word32) eax_59 + 1;
		} while (eax_59 != eax_55);
	}
	Eq_2 eax_134;
	word32 ecx_897;
	word32 edx_898;
	if (memcmp(ecx, dwLoc0424 + ecx, eax_36, out ecx_897, out edx_898) == 0x00)
	{
		byte * ebx_232 = null;
		Eq_2 esi_233 = 0x00;
		byte * eax_236 = (word32) ecx + (eax_36 - (byte *) 0x01);
		do
		{
			word32 eax_243 = eax + ebx_232;
			byte * eax_247 = (fp - 0x0420)[(word32) *((word32) eax_243 + (dwArg04 - 0x01))];
			if (eax_247 == null)
			{
				Eq_2 eax_271 = eax_36;
				if (esi_233 >= eax_36)
					eax_271 = esi_233;
				word32 ecx_283 = eax_271 + ebx_232 + eax;
				if (eax_271 < dwArg04 - 0x01)
				{
					if (Mem280[ecx_283 + 0x00:byte] == Mem280[ecx + eax_271:byte])
					{
						do
						{
							++eax_271;
							if (eax_271 >= dwArg04 - 0x01)
								goto l08085F08;
						} while (Mem280[ecx + eax_271:byte] == Mem280[eax_243 + eax_271:byte]);
					}
					ebx_232 = eax_271 + 0x01 + (ebx_232 - eax_36);
					goto l08085E8F;
				}
l08085F08:
				Eq_2 dwLoc0440_645;
				word32 eax_333 = eax_36 - 0x01 + ebx_232 + eax;
				if (esi_233 < eax_36)
				{
					byte * ecx_340 = eax_333 - eax_36;
					if (*eax_333 != *eax_236)
						goto l080860D1;
					Eq_2 ecx_352 = eax_36 - (byte *) 0x01;
					while (true)
					{
						Eq_2 eax_355 = ecx_352 - (byte *) 0x01;
						if (esi_233 == ecx_352 || Mem351[ecx + eax_355:byte] != Mem351[(eax_355 + 0x01) + ecx_340:byte])
							break;
						ecx_352 = eax_355;
					}
					dwLoc0440_645 = ecx_352;
				}
				else
				{
l080860D1:
					dwLoc0440_645 = eax_36;
				}
				if (esi_233 + 0x01 >u dwLoc0440_645)
				{
					eax_134 = eax_243;
					goto l08085F9C;
				}
				else
				{
					ebx_232 += dwLoc0424;
					esi_233 = dwArg04 - dwLoc0424;
					if (edx - dwArg04 < ebx_232)
						break;
					continue;
				}
			}
			if (esi_233 != 0x00)
			{
				byte * edx_260 = dwArg04 - dwLoc0424;
				if ((int8) (dwLoc0424 > eax_247) != 0x00)
					eax_247 = edx_260;
			}
			ebx_232 += eax_247;
l08085E8F:
			esi_233.u0 = 0x00;
		} while (edx - dwArg04 >= ebx_232);
	}
	else
	{
		Eq_2 eax_113 = dwArg04 - eax_36;
		if (eax_113 < eax_36)
			eax_113 = eax_36;
		byte * ecx_118 = null;
		byte * eax_120 = (word32) eax_113 + 1;
		byte * eax_125 = 0x01 - eax_36;
		do
		{
			eax_134 = eax + ecx_118;
			word32 edx_137 = (fp - 0x0420)[CONVERT(Mem131[eax_134 + (dwArg04 - 0x01):byte], byte, word32) * 0x04];
			if (edx_137 != 0x00)
			{
l08086012:
				ecx_118 += edx_137;
				goto l08086014;
			}
			word32 ebx_144 = ecx + eax_36;
			word32 edx_145 = ecx_118 + eax_36 + eax;
			if (eax_36 < dwArg04 - 0x01)
			{
				edx_137 = eax_36;
				if (*ebx_144 == *edx_145)
				{
					do
					{
						++edx_137;
						if (edx_137 >= dwArg04 - 0x01)
							goto l08086060;
					} while (Mem131[ecx + edx_137:byte] == Mem131[eax_134 + edx_137:byte]);
				}
				ecx_118 += eax_125;
				goto l08086012;
			}
l08086060:
			word32 ebx_169 = ecx + (eax_36 - 0x01);
			word32 ebx_178 = eax_36 - 0x01 + ecx_118 + eax;
			if (eax_36 == 0x00)
				goto l08085F9C;
			byte * ebx_182 = ebx_178 - eax_36;
			if (*ebx_178 == *ebx_169)
			{
				byte * edx_189 = eax_36 - (byte *) 0x01;
				do
				{
					edx_189 -= (byte *) 0x01;
					if (edx_189 == (byte *) ~0x00)
						goto l08085F9C;
				} while (Mem191[ecx + edx_189:byte] == Mem191[(edx_189 + 0x01) + ebx_182:byte]);
			}
			ecx_118 += eax_120;
l08086014:
		} while (ecx_118 <= edx - dwArg04);
	}
	eax_134.u0 = 0x00;
l08085F9C:
	if ((eax_30 ^ gs->dw0014) == 0x00)
		return eax_134;
	word32 edx_900;
	word32 ecx_899;
	__stack_chk_fail(out ecx_899, out edx_900);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg8 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	word32 ebp_904;
	word32 esi_905;
	word32 edi_906;
	return __memmem(gs, dwArg04, stackArg8, stackArg12, stackArg16, out ebp_904, out esi_905, out edi_906);
}

// 080860F0: Register Eq_2 __memmem(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 ebpOut, Register out (ptr32 Eq_2) esiOut, Register out Eq_2 ediOut)
// Called from:
//      _nl_find_locale
//      two_way_long_needle
Eq_2 __memmem(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	ui32 eax_20 = gs->dw0014;
	Eq_2 ebp_125 = dwArg04;
	Eq_2 edi_25 = dwArg08;
	Eq_2 eax_257 = dwArg04;
	if (dwArg10 != 0x00)
	{
		if (dwArg10 > dwArg08)
		{
l08086276:
			eax_257.u0 = 0x00;
			goto l08086280;
		}
		if (dwArg10 <= 0x1F)
		{
			eax_257 = __memchr(dwArg04, (word32) *dwArg0C, dwArg08);
			if (eax_257 != 0x00 && dwArg10 != 0x01)
			{
				edi_25 = dwArg08 - (eax_257 - dwArg04);
				eax_257.u0 = 0x00;
				if (dwArg10 <= edi_25)
				{
					Eq_2 eax_80 = critical_factorization(dwArg0C, fp - 0x24, dwArg10);
					edi_25 = eax_80;
					word32 ecx_858;
					word32 edx_859;
					word32 eax_281 = memcmp(dwArg0C, dwLoc24 + dwArg0C, eax_80, out ecx_858, out edx_859);
					if (eax_281 == 0x00)
					{
						Eq_2 ecx_267 = 0x00;
						word32 ebx_269 = eax_80 - 0x01 + dwArg0C;
						do
						{
							Eq_2 edx_276 = ecx_267;
							if (eax_80 >= ecx_267)
								edx_276 = eax_80;
							ebp_125 = dwArg0C + edx_276;
							word32 ebx_290 = edx_276 + eax_281 + eax_257;
							if (dwArg10 > edx_276)
							{
								if (*ebp_125 == *ebx_290)
								{
									ebp_125 = ecx_267;
									word32 ebx_300 = eax_257 + eax_281;
									do
									{
										++edx_276;
										if (dwArg10 == edx_276)
											goto l08086208;
									} while (Mem289[dwArg0C + edx_276:byte] == Mem289[ebx_300 + edx_276:byte]);
								}
								ecx_267.u0 = 0x00;
								eax_281 = edx_276 + 0x01 + (eax_281 - eax_80);
							}
							else
							{
l08086208:
								Eq_2 ebx_332 = eax_80 - (byte *) 0x01;
								ebp_125 = eax_80 - 0x01 + eax_281 + eax_257;
								if (eax_80 > ecx_267 && *ebp_125 == *ebx_269)
								{
									ebp_125 -= eax_80;
									while (true)
									{
										Eq_2 edx_349 = ebx_332 - (byte *) 0x01;
										if (ebx_332 == ecx_267 || Mem347[dwArg0C + edx_349:byte] != Mem347[(edx_349 + 0x01) + ebp_125:byte])
											break;
										ebx_332 = edx_349;
									}
								}
								else
									ebx_332 = eax_80;
								if (ebx_332 < (word64) ecx_267.u0 + 1)
								{
									eax_257 = eax_281 + eax_257;
									goto l08086280;
								}
								eax_281 += dwLoc24;
								ecx_267 = dwArg10 - dwLoc24;
							}
						} while (edi_25 - dwArg10 >= eax_281);
						goto l08086276;
					}
					byte al_112 = Mem98[dwArg0C + eax_80:byte];
					Eq_2 eax_115 = dwArg10 - eax_80;
					if (eax_115 < eax_80)
						eax_115 = eax_80;
					byte * ebp_122 = edi_25 - dwArg10;
					byte * edx_123 = null;
					ebp_125 = eax_257;
					byte * eax_127 = (word32) eax_115 + 1;
					byte * eax_131 = 0x01 - eax_80;
					do
					{
						word32 ecx_141 = eax_80 + edx_123 + eax_257;
						word32 eax_142 = ecx_141 + 0x01;
						if (al_112 != *ecx_141)
						{
							word32 eax_157 = __memchr(ecx_141 + 0x01, CONVERT(al_112, byte, word32), ebp_122 - edx_123);
							if (eax_157 == 0x00)
								goto l08086276;
							eax_142 = (word32) eax_157 + 1;
							edx_123 = eax_157 - (eax_257 + eax_80);
						}
						word32 ebx_178 = dwArg0C + (eax_80 + 0x01);
						word32 dwLoc44_508 = eax_80 + 0x01;
						if (dwArg10 >u eax_80 + 0x01)
						{
							if (*ebx_178 == *eax_142)
							{
								byte * eax_188 = eax_142 - eax_80;
								word32 ecx_190 = eax_80 + 0x01;
								do
								{
									++ecx_190;
									if (dwArg10 == ecx_190)
										goto l08086373;
								} while (Mem180[dwArg0C + ecx_190:byte] == Mem180[(ecx_190 - 0x01) + eax_188:byte]);
								dwLoc44_508 = ecx_190;
							}
							edx_123 = edx_123 + eax_131 + dwLoc44_508;
						}
						else
						{
l08086373:
							word32 ebx_220 = dwArg0C + (eax_80 - 0x01);
							word32 ecx_224 = eax_80 - 0x01 + edx_123 + eax_257;
							if (eax_80 == 0x00)
							{
l080863B2:
								eax_257 += edx_123;
								goto l08086280;
							}
							if (*ebx_220 == *ecx_224)
							{
								byte * ecx_231 = ecx_224 - eax_80;
								byte * eax_233 = eax_80 - (byte *) 0x01;
								do
								{
									eax_233 -= (byte *) 0x01;
									if (eax_233 == (byte *) ~0x00)
										goto l080863B2;
								} while (Mem218[dwArg0C + eax_233:byte] == Mem218[(eax_233 + 0x01) + ecx_231:byte]);
							}
							edx_123 += eax_127;
						}
					} while (ebp_122 >= edx_123);
					eax_257.u0 = 0x00;
				}
			}
		}
		else
			eax_257 = two_way_long_needle(eax, dwArg0C, dwArg08, gs, dwArg10);
	}
l08086280:
	union Eq_2 * esi_433 = eax_20 ^ gs->dw0014;
	if (esi_433 != null)
	{
		word32 ecx_860;
		word32 edx_861;
		__stack_chk_fail(out ecx_860, out edx_861);
		Eq_2 eax_443 = argz_create_sep(gs, dwArg04, dwArg0C, dwArg10);
		ebpOut = ebp_125;
		esiOut = esi_433;
		ediOut = edi_25;
		return eax_443;
	}
	else
	{
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return eax_257;
	}
}

// 08086410: Register word32 argz_create_sep(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      setlocale
//      __memmem
word32 argz_create_sep(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	word32 eax_154;
	word32 ecx_260;
	word32 edx_261;
	Eq_2 eax_25 = strlen(dwArg04, out ecx_260, out edx_261);
	if (eax_25 != 0x00)
	{
		int32 edi_45;
		word32 ecx_262;
		word32 edx_263;
		word32 ebx_264;
		byte * esi_47;
		word32 ebp_42;
		Eq_2 eax_41 = __libc_malloc(gs, dwLoc40, (word32) eax_25 + 1, out ecx_262, out edx_263, out ebx_264, out ebp_42, out esi_47, out edi_45);
		*dwArg0C = eax_41;
		if (eax_41 == 0x00)
		{
			eax_154 = 0x0C;
			return eax_154;
		}
		else
		{
			Eq_2 ecx_171 = eax_41;
			do
			{
				int32 ebx_62 = (int32) *esi_47;
				byte bl_67 = (byte) ebx_62;
				byte dl_86 = (byte) ebx_62;
				if (ebx_62 != edi_45)
				{
					*ecx_171 = bl_67;
					ecx_171 = (word32) ecx_171 + 1;
					goto l0808648D;
				}
				if (eax_41 >= ecx_171 || *((word32) ecx_171 - 1) == 0x00)
				{
					--ebp_42;
l0808648D:
					++esi_47;
					if (dl_86 != 0x00)
						continue;
					break;
				}
				*ecx_171 = 0x00;
				++esi_47;
				ecx_171 = (word32) ecx_171 + 1;
			} while (dl_86 != 0x00);
			if (ebp_42 == 0x00)
			{
				word32 ecx_265;
				word32 edx_266;
				free(gs, dwLoc40, eax_41, out ecx_265, out edx_266);
				*dwArg10 = 0x00;
			}
			*dwArg10 = ebp_42;
			return 0x00;
		}
	}
	else
	{
		dwArg0C->u0 = 0x00;
		*dwArg10 = 0x00;
		eax_154 = 0x00;
		return eax_154;
	}
}

// 08086510: Register word32 __argz_add_sep(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_2) dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      setlocale
word32 __argz_add_sep(struct Eq_9 * gs, union Eq_2 * dwArg04, word32 * dwArg08, Eq_2 dwArg0C)
{
	word32 edx_234;
	word32 ecx_233;
	Eq_2 eax_25 = strlen(dwArg0C, out ecx_233, out edx_234);
	word32 eax_177 = 0x00;
	if (eax_25 == 0x00)
		return eax_177;
	union Eq_2 * edi_50;
	int32 esi_52;
	word32 edx_235;
	byte * ebp_107;
	Eq_2 eax_54 = __realloc(gs, dwLoc40, *dwArg04, (word32) eax_25 + 1 + *dwArg08, out edx_235, out ebp_107, out esi_52, out edi_50);
	*edi_50 = (union Eq_2 *) eax_54;
	if (eax_54 == 0x00)
	{
		eax_177 = 0x0C;
		return eax_177;
	}
	else
	{
		Eq_2 eax_106 = (word32) eax_54 + *dwArg08;
		word32 ecx_120 = (word32) eax_25 + 1;
		do
		{
			int32 ebx_74 = (int32) *ebp_236;
			byte bl_79 = (byte) ebx_74;
			if (ebx_74 != esi_52)
			{
				*eax_106 = bl_79;
				ebx_74 = (word32) *ebp_236;
				eax_106 = (word32) eax_106 + 1;
				goto l08086589;
			}
			if (*edi_50 >= eax_106 || *((word32) eax_106 - 1) == 0x00)
			{
				--ecx_120;
l08086589:
				ebp_107 = ebp_236 + 1;
				if ((byte) ebx_74 != 0x00)
					continue;
				break;
			}
			*eax_106 = 0x00;
			eax_106 = (word32) eax_106 + 1;
			ebp_107 = ebp_236 + 1;
			ebp_236 = ebp_107;
		} while (*ebp_236 != 0x00);
		*dwArg08 += ecx_120;
		return 0x00;
	}
}

// 080865E0: Register Eq_2 handle_amd(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register Eq_2 ebx, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_1038 esiOut, Register out ptr32 ediOut)
// Called from:
//      init_cacheinfo
//      __cache_sysconf
Eq_2 handle_amd(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 ebx, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_1038 & esiOut, ptr32 & ediOut)
{
	__cpuid(0x80000000, ecx, &0x80000000, &ebx, &ecx, &edx);
	Eq_2 esi_13 = eax;
	Eq_2 ecx_45;
	if (eax <= 0xBE)
	{
		__cpuid(0x80000005, ecx, &0x80000005, &ebx, &ecx, &edx);
		ecx_45 = ecx;
		if (eax <= 0xBB)
		{
			esi_13 = (word32) eax + 3;
			ecx_45 = edx;
		}
	}
	else
	{
		__cpuid(0x80000006, ecx, &0x80000006, &ebx, &ecx, &edx);
		ecx_45 = ecx;
	}
	Eq_1038 esi_47 = esi_13 - 188;
	if (esi_47 > 0x08)
	{
		word32 ecx_117;
		word32 edx_118;
		__assert_fail(out ecx_117, out edx_118);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		word32 ecx_122;
		word32 edx_123;
		intel_check_word.isra.0(eax, ecx, edx, stackArg4, stackArg8, stackArg12, out ecx_122, out edx_123);
		ecxOut = ecx_45;
		edxOut = edx;
		esiOut = esi_47;
		ediOut = 0x080CE000;
		return 134948313;
	}
	else
	{
		<anonymous> * eax_67 = g_a80B2600[esi_47 * 0x04] + 0x080CE000;
		Eq_2 eax_73;
		Eq_2 ecx_74;
		Eq_2 edx_75;
		eax_67();
		ecxOut = ecx_74;
		edxOut = edx_75;
		esiOut = esi_47;
		ediOut = 0x080CE000;
		return eax_73;
	}
}

// 08086810: Register Eq_2 intel_check_word.isra.0(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_102882 ecxOut, Register out Eq_102882 edxOut)
// Called from:
//      __cache_sysconf
Eq_2 intel_check_word.isra.0(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_102882 & ecxOut, union Eq_102882 & edxOut)
{
intel_check_word.isra.0_entry:
	def fp
	def eax
	def ecx
	def edx
	def dwArg04
	def dwArg08
	def dwArg0C
	esp_18 = fp - 44
	dwLoc24_364 = eax
	branch edx < 0x00 l08086920
	ebx_29 = edx
	ecx_32 = eax - 0xB9 >> 0x1F
	edx_eax_33 = (eax - 0xB9) *s64 0x55555556
	edx_34 = SLICE(edx_eax_33, word32, 32)
	edx_35 = edx_34 - ecx_32
	dwLoc2C_367 = edx_35 * 0x03
	branch edx == 0x00 l08086920
	ebp_41 = edx
	goto l0808687A
l08086810:
l08086836:
l0808685A:
l08086860:
	*dwArg04 = 0x01
	branch dwLoc2C_369 == 0x09 l08086920
l08086871:
	ecx_504 = PHI((ecx_503, l08086860), (ecx_290, l080868DA), (ecx_221, l08086905))
	dwLoc24_475 = PHI((dwLoc24_380, l08086860), (dwLoc24_492, l080868DA), (dwLoc24_492, l08086905))
	dwLoc2C_472 = PHI((dwLoc2C_369, l08086860), (dwLoc2C_491, l080868DA), (dwLoc2C_491, l08086905))
	edx_326 = PHI((edx_59, l08086860), (edx_291, l080868DA), (edx_230, l08086905))
	ebx_320 = PHI((ebx_58, l08086860), (ebx_325, l080868DA), (ebx_325, l08086905))
	Mem310 = PHI((Mem52, l08086860), (Mem210, l080868DA), (Mem210, l08086905))
	ebp_296 = ebp_42 >> 0x08
	branch ebp_296 == 0x00 l08086920
l0808687A:
	ecx_503 = PHI((ecx_32, l0808685A), (ecx_504, l08086871), (ecx_221, l0808690E))
	dwLoc24_380 = PHI((dwLoc24_364, l0808685A), (dwLoc24_475, l08086871), (dwLoc24_492, l0808690E))
	dwLoc2C_369 = PHI((dwLoc2C_367, l0808685A), (dwLoc2C_472, l08086871), (dwLoc2C_491, l0808690E))
	edx_59 = PHI((edx_35, l0808685A), (edx_326, l08086871), (edx_230, l0808690E))
	ebx_58 = PHI((ebx_29, l0808685A), (ebx_320, l08086871), (ebx_325, l0808690E))
	Mem49 = PHI((Mem37, l0808685A), (Mem310, l08086871), (Mem285, l0808690E))
	ebp_42 = PHI((ebp_41, l0808685A), (ebp_296, l08086871), (ebp_283, l0808690E))
	al_44 = (byte) ebp_42
	eax_45 = (word32) al_44
	branch eax_45 == 0x40 l08086860
l08086884:
	branch eax_45 == 0xFF l0808693C
l0808688F:
	branch eax_45 != 0x49 l080868C0
l08086894:
	branch dwLoc2C_369 != 0x09 l080868C0
l0808689A:
	branch *dwArg08 != 0x0F l08086930
l080868A7:
	branch *dwArg0C != 0x06 l08086930
l080868B4:
	v17_205 = dwLoc24_380 - 0x03
	dwLoc24_395 = v17_205
	dwLoc2C_396.u0 = 0x06
l080868C0:
	dwLoc24_492 = PHI((dwLoc24_380, l0808688F), (dwLoc24_380, l08086894), (dwLoc24_395, l080868B4), (dwLoc24_380, l08086930))
	dwLoc2C_491 = PHI((dwLoc2C_369, l0808688F), (dwLoc2C_369, l08086894), (dwLoc2C_396, l080868B4), (dwLoc2C_394, l08086930))
	Mem210 = PHI((Mem49, l0808688F), (Mem49, l08086894), (Mem208, l080868B4), (Mem204, l08086930))
	bl_330 = (byte) ebp_42
	ecx_215.u0 = 0x44
	edx_216.u0 = 0x00
	goto l080868DE
l080868D8:
	ecx_288 = eax_222 >> 0x01
l080868DA:
	edx_291 = PHI((edx_289, l080868EC), (edx_220, l080868D8))
	ecx_290 = PHI((ecx_221, l080868EC), (ecx_288, l080868D8))
	branch ecx_290 <= edx_291 l08086871
l080868DE:
	ecx_221 = PHI((ecx_215, l080868C0), (ecx_290, l080868DA))
	edx_220 = PHI((edx_216, l080868C0), (edx_291, l080868DA))
	eax_222 = edx_220 + ecx_221
	esi_225 = 0x080B2740 + (eax_222 >> 0x01) * 0x08
	ebx_325 = ebp_42
	branch bl_330 == esi_225->b0000 l080868F8
l080868EA:
	branch bl_330 < esi_225->b0000 l080868D8
l080868EC:
	edx_289 = (eax_222 >> 0x01) + 0x01
	goto l080868DA
l080868F8:
	edx_230 = (word32) esi_225->b0003
	dl_278 = (byte) edx_230
	branch edx_230 == dwLoc2C_491 l080869DD
l08086905:
	branch dl_278 != 0x06 l08086871
l0808690E:
	ebp_283 = ebp_42 >> 0x08
	*ecx = 0x01
	branch ebp_283 != 0x00 l0808687A
l0808691E:
l08086922:
	edx_505 = PHI((edx_79, l080869CF), (edx_230, l080869F9), (edx_230, l08086A3C), (edx_230, l08086A02))
	ecx_501 = PHI((ecx_338, l080869CF), (ecx_338, l08086A80), (ecx_221, l080869F9), (ecx_221, l08086A3C), (ecx_221, l08086A02))
	eax_500 = PHI((eax_192, l080869CF), (eax_186, l08086A80), (eax_277, l080869F9), (eax_239, l08086A3C), (eax_242, l08086A02))
	ecxOut = ecx_501
	edxOut = edx_505
	return eax_500
l08086930:
	dwLoc2C_394.u0 = 0x09
	goto l080868C0
l0808693C:
	ecx_57 = 0x00
	ecx_24_8_327 = 0x00
	__cpuid(0x04, 0x00, &0x04, &ebx_58, &0x00, &edx_59)
	edx_61 = 0x04
	esi_65.u0 = 0x00
	dwLoc20_370.u0 = 0x00
	goto l0808697E
l0808694C:
l08086964:
	branch dwLoc2C_369 == 0x03 l080869AB
l0808696A:
	esi_132 = (word32) esi_128 + 1
	ecx_140 = esi_132
	ecx_24_8_328 = SLICE(esi_132, word24, 8)
	__cpuid(0x04, esi_132, &0x04, &ebx_58, &esi_132, &0x04)
	dwLoc20_376 = esi_132
	edx_154 = 0x04
l0808697E:
	dwLoc20_387 = PHI((dwLoc20_370, l0808694C), (dwLoc20_376, l0808696A))
	esi_128 = PHI((esi_65, l0808694C), (esi_132, l0808696A))
	Mem86 = PHI((Mem69, l0808694C), (Mem153, l0808696A))
	edx_79.u0 = 0x04
	ecx_24_8_76 = PHI((ecx_24_8_327, l0808694C), (ecx_24_8_328, l0808696A))
	cl_75 = (int8) false
	ecx_77 = SEQ(ecx_24_8_76, cl_75)
	ecx_340 = ecx_77
	ecx_339 = ecx_340
	goto l08086A53
l08086991:
l080869C6:
	branch eax_163 != 0x02 l08086AAE
l080869CF:
	ebx_189 = ebx_58 & 0x0FFF
	eax_192 = ebx_189 + 0x01
	goto l08086922
l080869DD:
	eax_236 = dwLoc24_492 - 0xB9 - dwLoc2C_491
	branch eax_236 == 0x00 l08086A3C
l080869EB:
	branch eax_236 == 0x01 l08086A02
l080869F0:
	branch eax_236 != 0x02 l08086A8B
l080869F9:
	eax_277 = (word32) esi_225->b0002
	goto l08086922
l08086A02:
	eax_242 = (word32) esi_225->b0001
	goto l08086922
l08086A3C:
	eax_239 = esi_225->t0004
	goto l08086922
l08086A44:
l08086A49:
	branch dwLoc2C_369 == 0x06 l080869AB
l08086A53:
	goto l08086A62
l08086A58:
	branch dwLoc2C_369 == 0x09 l080869AB
l08086A62:
	goto l0808696A
l08086A6B:
	branch dwLoc2C_369 == 0x0C l080869AB
	goto l0808696A
l08086A75:
l08086A80:
	ebx_184 = ebx_58 >> 22
	eax_186 = ebx_184 + 0x01
	goto l08086922
l08086A8B:
	ebx_245 = 0x080CE000
	esp_249 = fp - 0x34
l08086A9B:
	esp_253 = PHI((esp_275, l08086AAE), (esp_249, l08086A8B))
	ebx_251 = PHI((ebx_271, l08086AAE), (ebx_245, l08086A8B))
	eax_252 = ebx_251 + ~0x0001BA41
	esp_254 = esp_253 - 4
	esp_254->dw0000 = eax_252
	eax_256 = ebx_251 + ~0x0001BA14
	esp_257 = esp_254 - 4
	esp_254->dwFFFFFFFC = eax_256
	__assert_fail(out ecx_541, out edx_542)
l08086AAE:
	Mem270 = PHI((Mem86, l080869C6), (Mem258, l08086A9B))
	esp_269 = PHI((esp_18, l080869C6), (esp_257, l08086A9B))
	ebx_271 = esp_269->ptr0004
	esp_273 = esp_269 - 4
	esp_273->dw0000 = ebx_271 + 4294855020
	esp_275 = esp_273 - 4
	esp_273->dwFFFFFFFC = 0xC0
	goto l08086A9B
intel_check_word.isra.0_exit:
}

// 08086AC0: Register Eq_2 handle_intel.constprop.1(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 ebx, Register (ptr32 Eq_943) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut, Register out Eq_979 ebxOut, Register out Eq_979 ebpOut, Register out Eq_981 ediOut)
// Called from:
//      init_cacheinfo
//      __cache_sysconf
Eq_2 handle_intel.constprop.1(Eq_2 eax, Eq_2 ecx, Eq_2 ebx, struct Eq_943 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut, union Eq_979 & ebxOut, union Eq_979 & ebpOut, union Eq_981 & ediOut)
{
	Eq_2 eax_117;
	Eq_2 edx_116 = 0x080CE000;
	word32 eax_22 = gs->dw0014;
	if (g_t80CF8E4 > 0x01)
	{
		up32 dwLoc34_201 = 0x01;
		up32 dwLoc44_202 = 0x01;
		while (true)
		{
			__cpuid(0x02, ecx, &0x02, &ebx, &ecx, &edx_116);
			if (dwLoc44_202 == 0x01)
				dwLoc34_201 = 0x02;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, edx, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			ebx = eax;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, ebx, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, ecx, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			eax_117 = intel_check_word.isra.0(eax, fp - 33, edx_116, fp - 0x22, 0x080CF918, 0x080CF91C, out ecx, out edx_116);
			if (eax_117 != 0x00)
				break;
			edx_116 = dwLoc44_202 + 0x01;
			if (dwLoc34_201 <= dwLoc44_202)
			{
				edx_116 = eax - 191;
				if (eax <= 0xC4)
					eax_117 = -0x00;
				break;
			}
			++dwLoc44_202;
		}
	}
	else
		eax_117.u0 = ~0x00;
	Eq_981 edi_161 = eax_22 ^ gs->dw0014;
	if (edi_161 != 0x00)
	{
		word32 ecx_277;
		word32 edx_278;
		__stack_chk_fail(out ecx_277, out edx_278);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 edx_176;
		Eq_2 ecx_178;
		Eq_2 eax_177 = __cache_sysconf(ecx_178, ebx, stackArg4, out ecx_178, out edx_176);
		ecxOut = ecx_178;
		edxOut = edx_176;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		ediOut = edi_161;
		return eax_177;
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx_116;
		ebxOut.u0 = <invalid>;
		ebpOut.u0 = <invalid>;
		ediOut = edi;
		return eax_117;
	}
}

// 08086C20: Register Eq_2 __cache_sysconf(Register Eq_2 ecx, Register Eq_2 ebx, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      __sysconf
//      handle_intel.constprop.1
Eq_2 __cache_sysconf(Eq_2 ecx, Eq_2 ebx, Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_2 edx_9 = g_t80CF8E0;
	if (edx_9 == 0x01)
	{
		Eq_2 edx_12;
		Eq_2 ecx_14;
		word32 ebx_58;
		word32 ebp_59;
		word32 edi_60;
		Eq_2 eax_13 = handle_intel.constprop.1(eax, ecx_14, ebx, gs, out ecx_14, out edx_12, out ebx_58, out ebp_59, out edi_60);
		ecxOut = ecx_14;
		edxOut = edx_12;
		return eax_13;
	}
	else if (edx_9 == 0x02)
	{
		Eq_2 ecx_23;
		Eq_2 edx_24;
		word32 esi_61;
		word32 edi_62;
		Eq_2 eax_20 = handle_amd(dwArg04, ecx, edx_9, ebx, out ecx_23, out edx_24, out esi_61, out edi_62);
		ecxOut = ecx_23;
		edxOut = edx_24;
		return eax_20;
	}
	else
	{
		ecxOut = ecx;
		edxOut = edx_9;
		return 0x00;
	}
}

// 08086C60: Register ui32 __wcslen(Stack (ptr32 Eq_103364) dwArg04)
// Called from:
//      __wcsrtombs
ui32 __wcslen(struct Eq_103364 * dwArg04)
{
	if (dwArg04->a0000[0] == 0x00)
		return 0x00;
	if (dwArg04->a0004[0] == 0x00)
		return 0x01;
	if (dwArg04->a0008[0] == 0x00)
		return 0x02;
	ui32 edx_31 = 0x00;
	while (true)
	{
		ui32 eax_38 = edx_31 + 0x03;
		if (dwArg04->a000C[edx_31] == 0x00)
			break;
		eax_38 = edx_31 + 0x04;
		if (dwArg04[eax_38 * 0x04 / 0x0C] == 0x00)
			return eax_38;
		ui32 ebx_48 = edx_31 + 0x05;
		if (dwArg04->a0004[eax_38] == 0x00)
			return ebx_48;
		ui32 edx_55 = edx_31 + 0x06;
		if (dwArg04->a0008[eax_38] == 0x00)
			return edx_55;
		edx_31 = eax_38;
	}
	return eax_38;
}

// 08086CE0: Register word32 __wmemcpy(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 edxOut)
// Called from:
//      __printf_fp_l
//      register_printf_modifier
//      save_for_wbackup.isra.0
//      _IO_wdefault_pbackfail
word32 __wmemcpy(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & edxOut)
{
	word32 ecx_22;
	ptr32 edx_23;
	memcpy(dwArg04, dwArg08, dwArg0C << 0x02, out ecx_22, out edx_23);
	edxOut = edx_23;
	return ecx_22;
}

// 08086D10: void wmemmove(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack int32 dwArg0C)
// Called from:
//      __printf_fp_l
//      _IO_helper_overflow
//      save_for_wbackup.isra.0
void wmemmove(Eq_2 dwArg04, Eq_2 dwArg08, int32 dwArg0C)
{
	word32 edx_20;
	memmove(dwArg04, dwArg08, dwArg0C << 0x02, out edx_20);
}

// 08086D20: void __wmemset(Stack (ptr32 Eq_80657) dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __printf_fp_l
void __wmemset(struct Eq_80657 * dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 esi_11 = dwArg0C;
	struct Eq_80657 * edx_13 = dwArg04;
	if (dwArg0C > 0x03)
	{
		Eq_2 ebx_16 = dwArg0C;
		do
		{
			edx_13->dw0000 = (word32) dwArg08;
			++edx_13;
			edx_13->dwFFFFFFF4 = (word32) dwArg08;
			edx_13->dwFFFFFFF8 = (word32) dwArg08;
			edx_13->dwFFFFFFFC = (word32) dwArg08;
			ebx_16 -= 0x04;
		} while (ebx_16 > 0x03);
		esi_11 = dwArg0C & 0x03;
		edx_13 = dwArg04 + ((dwArg0C - 0x04 >> 0x02) + 0x01 << 0x04) / 16;
	}
	if (esi_11 != 0x00)
	{
		edx_13->dw0000 = (word32) dwArg08;
		if (esi_11 != 0x01)
		{
			edx_13->dw0004 = (word32) dwArg08;
			if (esi_11 == 0x03)
				edx_13->dw0008 = (word32) dwArg08;
		}
	}
}

// 08086D80: void btowc(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg2C)
void btowc(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg2C)
{
	struct Eq_103492 * esp_15 = fp - 0x4C;
	ui32 eax_17 = gs->dw0014;
	byte bl_97 = (byte) dwArg04;
	if (dwArg04 <= 0xFF && dwArg04 != ~0x00)
	{
		if ((dwArg04 & ~0x7F) != 0x00)
		{
			Eq_2 esi_33 = gs->ptrFFFFFFD0->t0000;
			struct Eq_103520 * edi_34 = *((word32) esi_33 + 20);
			if (edi_34 == null)
			{
				if (esi_33 != 0x080CC740)
				{
					word32 ebx_48;
					struct Eq_103732 * esi_52;
					word32 edi_357;
					__wcsmbs_load_conv(gs, esi_33, out ebx_48, out esi_52, out edi_357);
					Eq_2 esp_53 = <invalid>;
					bl_97 = (byte) ebx_48;
					edi_34 = esi_52->ptr0014;
					esp_15 = (word32) esp_53 + 16;
				}
				else
					edi_34 = (struct Eq_103520 *) 135055060;
			}
			Eq_2 eax_64 = edi_34->t0000;
			Eq_2 esi_65 = *((word32) eax_64 + 24);
			if (*eax_64 != 0x00)
				esi_65 = __ror(esi_65, 0x09) ^ gs->t0018;
			if (edi_34->dw0004 == 0x01 && esi_65 != 0x00)
			{
				struct Eq_103618 * esp_178 = esp_15 - 0x0C;
				esp_178->tFFFFFFFC = esi_65;
				word32 ecx_350;
				word32 edx_351;
				_dl_mcount_wrapper_check(gs, esp_178->tFFFFFFF8, esp_178->tFFFFFFFC, out ecx_350, out edx_351);
				Eq_2 edx_190 = esp_178->tFFFFFFFC;
				word32 ecx_192 = esp_178->dw0000;
				esp_178->dw0000 = (word32) bl_97;
				esp_178->tFFFFFFFC = edi_34->t0000;
				esi_65();
			}
			else
			{
				esp_15->dw0030 = 0x00;
				esp_15->ptr0010 = &esp_15->b003B;
				esp_15->ptr0018 = (char *) esp_15 + 0x0C;
				esp_15->dw0034 = 0x00;
				esp_15->b003B = bl_97;
				esp_15->ptr002C = &esp_15->dw0030;
				word32 * esi_89 = &esp_15->ptr0010;
				Eq_2 eax_103 = edi_34->t0000;
				esp_15->ptr001C = esi_89;
				Eq_2 ebx_105 = *((word32) eax_103 + 20);
				word32 eax_106 = *eax_103;
				esp_15->dw0024 = 0x00;
				esp_15->dw0028 = 0x01;
				esp_15->dw0020 = 0x01;
				if (eax_106 != 0x00)
					ebx_105 = __ror(ebx_105, 0x09) ^ gs->t0018;
				struct Eq_103654 * esp_121 = esp_15 - 0x0C;
				esp_121->tFFFFFFFC = ebx_105;
				word32 ecx_352;
				word32 edx_353;
				_dl_mcount_wrapper_check(gs, esp_121->tFFFFFFF8, esp_121->tFFFFFFFC, out ecx_352, out edx_353);
				esp_121->tFFFFFFF8.u0 = 0x01;
				esp_121->dwFFFFFFF4 = 0x00;
				esp_121->ptrFFFFFFF0 = &esp_121->dw001C + 1;
				esp_121->dwFFFFFFEC = 0x00;
				esp_121->dwFFFFFFE8 = esp_121->dw001C + 0x01;
				esp_121->ptrFFFFFFE4 = esi_89;
				esp_121->ptrFFFFFFE0 = &esp_121->dw001C + 2;
				esp_121->tFFFFFFDC = edi_34->t0000;
				up32 eax_163;
				ebx_105();
				if (eax_163 <= 0x05 || eax_163 == 0x00)
					;
			}
		}
	}
	if ((eax_17 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_348;
	word32 edx_349;
	__stack_chk_fail(out ecx_348, out edx_349);
	word32 esi_355;
	word32 edi_356;
	word32 ebp_354;
	wcrtomb(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg2C, out ebp_354, out esi_355, out edi_356);
}

// 08086F10: Register Eq_2 wcrtomb(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg2C, Register out (ptr32 Eq_74726) ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      btowc
Eq_2 wcrtomb(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg2C, struct Eq_74726 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	ptr32 edi_11 = 0x080CE000;
	ui32 ecx_20 = gs->dw0014;
	Eq_2 esi_24 = dwArg04;
	if (dwArg04 == 0x00)
	{
		dwArg08.u0 = 0x00;
		esi_24 = fp - 0x30;
	}
	Eq_2 esi_140;
	Eq_2 ebx_49 = gs->ptrFFFFFFD0->t0000;
	Eq_2 dwLoc50_294 = esi_24;
	struct Eq_103769 * ebp_51 = *((word32) ebx_49 + 20);
	esi_140 = esi_24;
	if (ebp_51 == null)
	{
		if (ebx_49 != 0x080CC740)
		{
			struct Eq_103874 * ebx_69;
			__wcsmbs_load_conv(gs, ebx_49, out ebx_69, out esi_140, out edi_11);
			ebp_51 = ebx_69->ptr0014;
		}
		else
		{
			ebp_51 = (struct Eq_103769 *) 135055060;
			esi_140 = esi_24;
		}
	}
	struct Eq_103777 * eax_85 = ebp_51->ptr0008;
	Eq_2 ebx_107 = eax_85->t0014;
	if (eax_85->dw0000 != 0x00)
		ebx_107 = __ror(ebx_107, 0x09) ^ gs->t0018;
	Eq_2 esp_208;
	uint32 eax_146;
	Eq_2 eax_214;
	if (dwArg08 != 0x00)
	{
		word32 ecx_432;
		word32 edx_433;
		_dl_mcount_wrapper_check(gs, dwLoc70, ebx_107, out ecx_432, out edx_433);
		ebx_107();
		if ((eax_146 & ~0x04) == 0x00)
			goto l08087062;
	}
	else
	{
		word32 ecx_430;
		word32 edx_431;
		_dl_mcount_wrapper_check(gs, dwLoc70, ebx_107, out ecx_430, out edx_431);
		ebx_107();
		if ((eax_146 & ~0x04) == 0x00)
		{
			*esi_24 = 0x00;
			dwLoc50_294 = (word32) esi_24 + 1;
			goto l08087062;
		}
	}
	esp_208 = fp - 92;
	if (eax_146 > 0x07 || eax_146 < 0x05)
		goto l080870B6;
	if (eax_146 != 0x05)
	{
		gs->tFFFFFFE0.u0 = 0x54;
		eax_214.u0 = ~0x00;
l0808700B:
		if ((ecx_20 ^ gs->dw0014) == 0x00)
		{
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return eax_214;
		}
		word32 ecx_436;
		word32 edx_437;
		__stack_chk_fail(out ecx_436, out edx_437);
		esp_208.u0 = <invalid>;
l080870B6:
		struct Eq_103830 * esp_241 = esp_208 - 4;
		esp_241->ptr0000 = edi_11 + ~0x0001B677;
		esp_241->dwFFFFFFFC = 101;
		esp_241->ptrFFFFFFF8 = edi_11 + ~0x0001B682;
		esp_241->ptrFFFFFFF4 = edi_11 + 4294793992;
		word32 ecx_434;
		word32 edx_435;
		__assert_fail(out ecx_434, out edx_435);
		struct Eq_74726 * ebp_261;
		ptr32 edi_264;
		ptr32 esi_266;
		Eq_2 eax_260 = __wcsrtombs(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg2C, out ebp_261, out esi_266, out edi_264);
		ebpOut = ebp_261;
		esiOut = esi_266;
		ediOut = edi_264;
		return eax_260;
	}
l08087062:
	eax_214 = dwLoc50_294 - esi_140;
	goto l0808700B;
}

// 080870E0: Register ui32 __wcsrtombs(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg2C, Register out (ptr32 Eq_78795) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      vfprintf
//      wcrtomb
ui32 __wcsrtombs(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg2C, struct Eq_78795 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	Eq_2 eax_19 = dwArg10;
	Eq_2 edi_113 = dwArg04;
	ui32 esi_25 = gs->dw0014;
	if (dwArg10 == 0x00)
		eax_19.u0 = 0x080CFA38;
	Eq_2 ebx_41 = gs->ptrFFFFFFD0->t0000;
	struct Eq_103917 * eax_42 = *((word32) ebx_41 + 20);
	if (eax_42 == null)
	{
		if (ebx_41 != 0x080CC740)
		{
			word32 edi_659;
			word32 esi_658;
			word32 ebx_657;
			__wcsmbs_load_conv(gs, ebx_41, out ebx_657, out esi_658, out edi_659);
			eax_42 = (struct Eq_103917 *) *((word32) ebx_41 + 20);
		}
		else
			eax_42 = (struct Eq_103917 *) 135055060;
	}
	struct Eq_78795 * ebp_72 = eax_42->ptr0008;
	Eq_2 esi_132 = ebp_72->t0014;
	if (ebp_72->dw0000 != 0x00)
		esi_132 = __ror(esi_132, 0x09) ^ gs->t0018;
	struct Eq_103939 * esp_252;
	ui32 ebx_110;
	Eq_2 eax_174;
	struct Eq_103364 * edx_87 = *dwArg08;
	if (dwArg04 != 0x00)
	{
		word32 ebx_210 = edx_87->a0004 + __wcsnlen(edx_87, dwArg0C);
		word32 ecx_660;
		word32 edx_661;
		_dl_mcount_wrapper_check(gs, dwLoc0190, esi_132, out ecx_660, out edx_661);
		esi_132();
		esp_252 = fp - 0x017C;
		ebx_110 = 0x00;
		if ((eax_174 & ~0x04) != 0x00 || *((word32) dwArg04 - 1) != 0x00)
			goto l080871EC;
		if (dwArg04 == dwArg04)
			goto l080873E6;
		if (*eax_19.u0 != 0x00)
		{
l080873C6:
			word32 esi_371 = esp_252->dw001C;
			struct Eq_104098 * esp_373 = esp_252 - (struct Eq_104099 *) 4;
			esp_373->dw0000 = esi_371 + ~0x0001B61F;
			esp_373->dwFFFFFFFC = 0x7B;
			esp_373->dwFFFFFFF8 = esi_371 + ~0x0001B66D;
			esp_373->dwFFFFFFF4 = esi_371 + 4294793922;
			word32 ecx_671;
			word32 edx_672;
			__assert_fail(out ecx_671, out edx_672);
l080873E6:
			word32 edx_670;
			word32 ecx_669;
			__assert_fail(out ecx_669, out edx_670);
			ui32 eax_415 = __wcsnlen((word32) dwArg2C - 112238, 122);
			ebpOut = ebp_72;
			esiOut = dwArg2C;
			ediOut = edi_113;
			return eax_415;
		}
		*dwArg08 = null;
	}
	else
	{
		ebx_110 = 0x00;
		edi_113 = fp - 288;
		word32 eax_114 = edx_87->a0004 + __wcslen(edx_87);
		do
		{
			word32 ecx_663;
			word32 edx_664;
			_dl_mcount_wrapper_check(gs, dwLoc0190, esi_132, out ecx_663, out edx_664);
			esi_132();
			dwLoc0190.u0 = 0x01;
			ebx_110 += fp - (struct Eq_104031 *) 288 - (fp - (struct Eq_104033 *) 288);
		} while (eax_174 == 0x05);
		if ((eax_174 & ~0x04) != 0x00)
		{
l080871EC:
			uint32 edx_273 = eax_174 - 0x04;
			if (eax_174 != 0x00 && edx_273 > 0x03)
			{
				edi_113.u0 = 0x080CE000;
				word32 ecx_662;
				eax_174 = __assert_fail(out ecx_662, out edx_273);
			}
			if (eax_174 != 0x00 && edx_273 > 0x01)
			{
				gs->tFFFFFFE0.u0 = 0x54;
				ebx_110 = ~0x00;
			}
			if ((esi_25 ^ gs->dw0014) == 0x00)
			{
				ebpOut = ebp;
				esiOut = esi;
				ediOut = edi;
				return ebx_110;
			}
			word32 ecx_667;
			word32 edx_668;
			__stack_chk_fail(out ecx_667, out edx_668);
l080873A6:
			word32 edx_666;
			word32 ecx_665;
			__assert_fail(out ecx_665, out edx_666);
			esp_252 = fp - (struct Eq_104052 *) 0x018C;
			goto l080873C6;
		}
		if (bLoc0121 != 0x00)
			goto l080873A6;
	}
	--ebx_110;
	goto l080871EC;
}

// 08087410: Register ui32 __wcsnlen(Stack (ptr32 Eq_103364) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __wcsrtombs
ui32 __wcsnlen(struct Eq_103364 * dwArg04, Eq_2 dwArg08)
{
	Eq_2 ecx_48 = dwArg08;
	if (dwArg08 == 0x00 || (dwArg04->a0000)[0] == 0x00)
		return 0x00;
	if (dwArg08 == 0x01 || (dwArg04->a0004)[0] == 0x00)
		return 0x01;
	if (dwArg08 == 0x02)
		return 0x02;
	ui32 edx_39 = 0x02;
	do
	{
		ui32 eax_47;
		if (dwArg04[edx_39 * 0x04 / 0x0C] == 0x00)
			break;
		eax_47 = edx_39 + 0x01;
		if (ecx_48 == 0x03 || (dwArg04->a0004)[edx_39] == 0x00)
			return eax_47;
		eax_47 = edx_39 + 0x02;
		ecx_48 -= 0x04;
		if (ecx_48 == 0x00 || (dwArg04->a0008)[edx_39] == 0x00)
			return eax_47;
		eax_47 = edx_39 + 0x03;
		if (ecx_48 == 0x01 || (dwArg04->a000C)[edx_39] == 0x00)
			return eax_47;
		edx_39 += 0x04;
	} while (ecx_48 != 0x02);
	eax_47 = edx_39;
	return eax_47;
}

// 080874A0: Register Eq_2 wcschrnul(Stack Eq_2 dwArg04, Stack word32 dwArg08)
// Called from:
//      __vfwprintf
//      __parse_one_specwc
Eq_2 wcschrnul(Eq_2 dwArg04, word32 dwArg08)
{
	Eq_2 eax_14 = dwArg04;
	word32 edx_10 = *dwArg04;
	if (dwArg08 != edx_10)
	{
		while (edx_10 != 0x00)
		{
			eax_14 = (word32) eax_14 + 4;
			edx_10 = (word32) *eax_14;
			if (edx_10 == dwArg08)
				return eax_14;
		}
	}
	return eax_14;
}

// 080874D0: Register word32 time(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
// Called from:
//      get_nprocs
word32 time(struct Eq_9 * gs, word32 dwArg04)
{
	word32 eax_10;
	gs->ptr0010();
	return eax_10;
}

// 080874F0: Register Eq_2 __alloc_dir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Stack Eq_2 dwArg10)
// Called from:
//      opendir
//      __fdopendir
Eq_2 __alloc_dir(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 bArg08, Eq_2 dwArg10)
{
	Eq_2 esi_103;
	if ((byte) dwArg08 != 0x00 || __fcntl64_nocancel() >= 0x00)
	{
		Eq_2 eax_42 = 0x801C;
		Eq_2 edi_141 = 0x8000;
		if (dwArg10 != 0x00)
		{
			Eq_2 edx_50 = 0x8000;
			if (*((word32) dwArg10 + 52) >= 0x8000)
				edx_50 = *((word32) dwArg10 + 52);
			edi_141 = edx_50;
			if (edx_50 > 0x00100000)
				edi_141.u0 = 0x00100000;
			eax_42 = (word32) edi_141 + 28;
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_230;
		word32 ebx_231;
		word32 edi_234;
		word32 ebp_232;
		word32 esi_233;
		word32 ecx_229;
		Eq_2 eax_86 = __libc_malloc(gs, stackArg0, eax_42, out ecx_229, out edx_230, out ebx_231, out ebp_232, out esi_233, out edi_234);
		esi_103 = eax_86;
		if (eax_86 != 0x00)
		{
l08087557:
			*((word64) esi_103.u0 + 4) = 0x00;
			*((word64) esi_103.u0 + 8) = edi_141;
			*esi_103.u0 = dwArg04;
			*((word64) esi_103.u0 + 0x0C) = 0x00;
			*((word64) esi_103.u0 + 16) = 0x00;
			*((word64) esi_103.u0 + 20) = 0x00;
			((word64) esi_103.u0 + 24)->u0 = 0x00;
			return esi_103;
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_237;
		word32 ebx_238;
		word32 edi_241;
		word32 ebp_239;
		word32 esi_240;
		word32 ecx_236;
		Eq_2 eax_99 = __libc_malloc(gs, stackArg0, 8220, out ecx_236, out edx_237, out ebx_238, out ebp_239, out esi_240, out edi_241);
		edi_141.u0 = 0x2000;
		esi_103 = eax_99;
		if (eax_99 != 0x00)
			goto l08087557;
		if ((byte) dwArg08 != 0x00)
		{
			Eq_2 ebp_123 = gs->tFFFFFFE0;
			word32 edx_242;
			__close_nocancel(gs, dwArg04, out edx_242);
			gs->tFFFFFFE0 = ebp_123;
			return esi_103;
		}
	}
	esi_103.u0 = 0x00;
	return esi_103;
}

// 08087600: Register Eq_2 opendir_tail(Register Eq_2 eax, Register (ptr32 Eq_9) gs)
// Called from:
//      __opendirat
//      opendir
Eq_2 opendir_tail(Eq_2 eax, struct Eq_9 * gs)
{
	ui32 eax_19 = gs->dw0014;
	if (eax >= 0x00)
	{
		word32 ecx_148;
		word32 edx_149;
		if (__fxstat64(gs, eax, fp - 0x70, out ecx_148, out edx_149) >= 0x00)
		{
			if ((dwLoc60 & 0xF000) == 0x4000)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				__alloc_dir(gs, stackArg4, stackArg8, stackArg16);
				goto l08087658;
			}
			gs->tFFFFFFE0.u0 = 0x14;
		}
		word32 edx_157;
		__close_nocancel(gs, eax, out edx_157);
	}
l08087658:
	if ((eax_19 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_154;
	word32 ecx_153;
	__stack_chk_fail(out ecx_153, out edx_154);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg8 = <invalid>;
	__opendirat(gs, stackArg4, stackArg8);
	return;
}

// 080876A0: void __opendirat(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      opendir
void __opendirat(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08)
{
	if (*dwArg08 == 0x00)
		gs->tFFFFFFE0.u0 = 0x02;
	else
	{
		Eq_2 eax_26 = __openat_nocancel(gs, dwArg04, dwArg08, 0x00098800, dwLoc10);
		opendir_tail(eax_26, gs);
	}
}

// 08087700: Register word32 opendir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      get_nprocs_conf
word32 opendir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (*dwArg04 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 0x02;
		return 0x00;
	}
	else
	{
		word32 ecx_63;
		word32 edx_64;
		Eq_2 eax_23 = __open_nocancel(gs, dwArg04, 0x00098800, dwLoc14, out ecx_63, out edx_64);
		return opendir_tail(eax_23, gs);
	}
}

// 08087750: Register word32 closedir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
//      get_nprocs_conf
word32 closedir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00)
	{
		gs->tFFFFFFE0.u0 = 22;
		return ~0x00;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 esi_29 = *dwArg04;
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_71;
		word32 edx_72;
		free(gs, stackArg0, dwArg04, out ecx_71, out edx_72);
		word32 edx_73;
		return __close_nocancel(gs, esi_29, out edx_73);
	}
}

// 080877A0: Register Eq_2 __readdir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
Eq_2 __readdir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edi_24 = gs->tFFFFFFE0;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_31;
	if (!__cmpxchg(*((word32) dwArg04 + 4), 0x01, 0x00, out eax_31))
		__lll_lock_wait_private(eax_31, (word32) dwArg04 + 4, gs);
	Eq_104468 eax_43 = *((word32) dwArg04 + 16);
	do
	{
		Eq_2 edx_122;
		Eq_2 ecx_100;
		word32 edx_46 = (word32) eax_43.u1 + 28;
		if (*((word32) dwArg04 + 0x0C) <= eax_43)
		{
			Eq_104468 eax_67 = __getdents(gs, *dwArg04, (word32) dwArg04 + 28, *((word32) dwArg04 + 8), out ecx_100);
			if (eax_67 <= 0x00)
			{
				if (eax_67 != 0x00)
				{
					edx_122.u0 = 0x00;
					if (gs->tFFFFFFE0 != 0x02)
						break;
				}
				gs->tFFFFFFE0 = edi_24;
				edx_122.u0 = 0x00;
				break;
			}
			*((word32) dwArg04 + 0x0C) = eax_67;
			edx_46 = 0x1C;
			eax_43.u0 = 0x00;
		}
		edx_122 = (word32) dwArg04 + edx_46;
		eax_43 = (word32) eax_43.u1 + (word32) (*((word32) edx_122 + 8));
		word32 ecx_97 = *((word32) edx_122 + 4);
		*((word32) dwArg04 + 16) = eax_43;
		*((word32) dwArg04 + 20) = ecx_97;
		ecx_100 = *edx_122;
	} while (ecx_100 == 0x00);
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v18_113 = *((word32) dwArg04 + 4) - 0x01;
	*((word32) dwArg04 + 4) = v18_113;
	if (v18_113 != 0x00)
		__lll_unlock_wake_private((word32) dwArg04 + 4, ecx_100, edx_122, gs);
	return edx_122;
}

// 08087870: Register Eq_2 __rewinddir(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
Eq_2 __rewinddir(Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_18;
	if (!__cmpxchg(*((word32) dwArg04 + 4), 0x01, 0x00, out eax_18))
		__lll_lock_wait_private(eax_18, (word32) dwArg04 + 4, gs);
	word32 ebp_94;
	word32 ebx_93;
	word32 edi_96;
	Eq_2 ecx_42;
	word32 esi_95;
	__libc_lseek(gs, *dwArg04, 0x00, 0x00, out ecx_42, out ebx_93, out ebp_94, out esi_95, out edi_96);
	*((word32) dwArg04 + 20) = 0x00;
	*((word32) dwArg04 + 16) = 0x00;
	*((word32) dwArg04 + 0x0C) = 0x00;
	((word32) dwArg04 + 24)->u0 = 0x00;
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v12_52 = *((word32) dwArg04 + 4) - 0x01;
	*((word32) dwArg04 + 4) = v12_52;
	if (v12_52 != 0x00)
		__lll_unlock_wake_private((word32) dwArg04 + 4, ecx_42, edx, gs);
	return edx;
}

// 080878F0: Register (ptr32 Eq_226) __getdents(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_2 ecxOut)
// Called from:
//      __readdir
struct Eq_226 * __getdents(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_2 & ecxOut)
{
	struct Eq_104646 * esp_16 = fp - 0x016C;
	Eq_2 ecx_19 = fp - 0x0134;
	ui32 esi_23 = gs->dw0014;
	if (dwArg0C >= 0x010D)
		ecx_19 = dwArg08;
	struct Eq_226 * eax_135;
	Eq_2 ecx_108;
	gs->ptr0010();
	Eq_2 ebp_120 = ecx_19;
	if (eax_135 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_320;
		eax_135 = __syscall_error(eax_135, gs, out edx_320);
		esp_16 = fp - 0x0168;
	}
	if (eax_135 != (struct Eq_226 *) ~0x00)
	{
		word32 eax_56 = eax_135 + ecx_19;
		ecx_108 = esp_16->t002C;
		esp_16->t0028 = eax_56;
		if (ecx_19 < eax_56)
		{
			esp_16->dw0008 = ~0x00;
			esp_16->dw000C = ~0x00;
			Eq_2 ebx_127 = ecx_108;
			do
			{
				int32 esi_68 = (word32) *((word32) ebp_120 + 16);
				struct Eq_104705 * esp_71 = esp_16 - 0x04;
				Eq_2 ecx_72 = *((word32) ebp_120 + 0x0C);
				Eq_2 edi_73 = *((word32) ebp_120 + 8);
				esp_71->dw0020 = (word32) *((word32) ebp_120 + 4);
				esp_71->t001C = ecx_72;
				esp_71->dw0024 = esi_68 - 0x05 & ~0x03;
				esp_71->t0018 = *ebp_120;
				esp_71->t002B = *((word32) ebp_120 + 18);
				esp_71->tFFFFFFFC = esi_68 - 0x13;
				esp_71->tFFFFFFF8 = (word32) ebp_120 + 19;
				esp_71->tFFFFFFF4 = (word32) ebx_127 + 11;
				word32 edx_321;
				memmove(esp_71->tFFFFFFF4, esp_71->tFFFFFFF8, esp_71->tFFFFFFFC, out edx_321);
				Eq_2 eax_104 = esp_71->t0018;
				word32 edx_106 = esp_71->dw0020;
				*((word32) ebx_127 + 4) = edi_73;
				ecx_108 = esp_71->t001C;
				*ebx_127 = eax_104;
				if (edx_106 != 0x00 || ecx_108 != SLICE((int64) edi_73, word32, 32))
				{
					if ((esp_71->t000C & esp_71->t0010) != ~0x00)
					{
						esp_71->t0018 = ebx_127;
						esp_71->dw0000 = 0x00;
						esp_71->tFFFFFFFC = esp_71->t0010;
						esp_71->tFFFFFFF8 = esp_71->t000C;
						esp_71->tFFFFFFF4 = esp_71->t0174;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						word32 ebx_325;
						word32 edi_327;
						word32 esi_326;
						word32 edx_324;
						lseek64(gs, stackArg4, dwArg04, dwArg08, dwArg0C, out edx_324, out ebx_325, out esi_326, out edi_327);
						ecx_108 = esp_71->t0018;
						eax_135 = ecx_108 - esp_71->dw0030;
					}
					else
					{
						word32 edx_322;
						eax_135 = __syscall_error((struct Eq_226 *) ~0x4A, gs, out edx_322);
					}
					goto l08087A47;
				}
				int32 edx_118 = esp_71->dw0024;
				Eq_66520 al_125 = esp_71->t002B;
				esp_71->t000C = edi_73;
				esp_71->t0010 = ecx_108;
				((word32) ebx_127 + 8)->u4 = (word16) edx_118;
				*((word32) ebx_127 + 0x0A) = al_125;
				ebp_120 = (word32) ebp_120 + esi_68;
				ebx_127 = (word32) ebx_127 + edx_118;
			} while (esp_71->t002C > ebp_120);
			ecx_108 = ebx_127;
		}
		eax_135 = ecx_108 - esp_16->t002C;
	}
l08087A47:
	if ((esi_23 ^ gs->dw0014) != 0x00)
	{
		word32 edx_329;
		word32 ecx_328;
		__stack_chk_fail(out ecx_328, out edx_329);
		Eq_2 ecx_206;
		struct Eq_226 * eax_205 = readdir64(gs, dwLoc0168, out ecx_206);
		ecxOut = ecx_206;
		return eax_205;
	}
	else
	{
		ecxOut = ecx_108;
		return eax_135;
	}
}

// 08087AA0: Register Eq_2 readdir64(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      get_nprocs_conf
//      __getdents
Eq_2 readdir64(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut)
{
	Eq_2 edi_24 = gs->tFFFFFFE0;
	if (gs->t000C != 0x00)
		__lock();
	word32 eax_31;
	if (!__cmpxchg(*((word32) dwArg04 + 4), 0x01, 0x00, out eax_31))
		__lll_lock_wait_private(eax_31, (word32) dwArg04 + 4, gs);
	Eq_104909 eax_43 = *((word32) dwArg04 + 16);
	do
	{
		Eq_2 edx_125;
		Eq_2 ecx_103;
		word32 edx_46 = (word32) eax_43.u1 + 28;
		if (*((word32) dwArg04 + 0x0C) <= eax_43)
		{
			Eq_104909 eax_64 = __getdents64(gs, *dwArg04, (word32) dwArg04 + 28, *((word32) dwArg04 + 8), out ecx_103);
			if (eax_64 <= 0x00)
			{
				if (eax_64 != 0x00)
				{
					edx_125.u0 = 0x00;
					if (gs->tFFFFFFE0 != 0x02)
						break;
				}
				gs->tFFFFFFE0 = edi_24;
				edx_125.u0 = 0x00;
				break;
			}
			*((word32) dwArg04 + 0x0C) = eax_64;
			edx_46 = 0x1C;
			eax_43.u0 = 0x00;
		}
		edx_125 = (word32) dwArg04 + edx_46;
		eax_43 = (word32) eax_43.u1 + (word32) (*((word32) edx_125 + 16));
		word32 ecx_99 = *((word32) edx_125 + 8);
		*((word32) dwArg04 + 16) = eax_43;
		*((word32) dwArg04 + 20) = ecx_99;
		ecx_103 = *((word32) edx_125 + 4) | *edx_125;
	} while (ecx_103 == 0x00);
	if (gs->t000C != 0x00)
		__lock();
	Eq_2 v18_116 = *((word32) dwArg04 + 4) - 0x01;
	*((word32) dwArg04 + 4) = v18_116;
	if (v18_116 != 0x00)
		__lll_unlock_wake_private((word32) dwArg04 + 4, ecx_103, edx_125, gs);
	ecxOut = ecx_103;
	return edx_125;
}

// 08087B70: Register word32 __fdopendir(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      getcwd
word32 __fdopendir(struct Eq_9 * gs, Eq_2 dwArg04)
{
	word32 eax_157;
	ui32 eax_17 = gs->dw0014;
	word32 ecx_173;
	word32 edx_174;
	if (__fxstat64(gs, dwArg04, fp - 0x70, out ecx_173, out edx_174) >= 0x00)
	{
		if ((dwLoc60 & 0xF000) == 0x4000)
		{
			int32 eax_53 = __fcntl64_nocancel();
			if (eax_53 != ~0x00)
			{
				if ((eax_53 & 0x03) != 0x01)
					eax_157 = __alloc_dir(gs, dwArg04, 0x00, fp - 0x70);
				else
				{
					gs->tFFFFFFE0.u0 = 22;
					eax_157 = 0x00;
				}
l08087BE6:
				if ((eax_17 ^ gs->dw0014) == 0x00)
					return eax_157;
				word32 ecx_175;
				word32 edx_176;
				__stack_chk_fail(out ecx_175, out edx_176);
				return __uname(dwArg04, gs, dwLoc78);
			}
		}
		else
			gs->tFFFFFFE0.u0 = 0x14;
	}
	eax_157 = 0x00;
	goto l08087BE6;
}

// 08087C30: Register (ptr32 Eq_226) __uname(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack ptr32 dwArg04)
// Called from:
//      _dl_discover_osversion
//      __fdopendir
struct Eq_226 * __uname(Eq_2 ebx, struct Eq_9 * gs, ptr32 dwArg04)
{
	struct Eq_226 * eax_11;
	gs->ptr0010();
	if (eax_11 < (struct Eq_226 *) ~0x0FFE)
		return eax_11;
	word32 edx_35;
	return __syscall_error(eax_11, gs, out edx_35);
}

// 08087C60: Register word32 __getuid(Register (ptr32 Eq_50367) gs)
// Called from:
//      __libc_init_secure
word32 __getuid(struct Eq_50367 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087C80: Register word32 __geteuid(Register (ptr32 Eq_50367) gs)
// Called from:
//      __libc_init_secure
word32 __geteuid(struct Eq_50367 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087CA0: Register word32 __getgid(Register (ptr32 Eq_50367) gs)
// Called from:
//      __libc_init_secure
word32 __getgid(struct Eq_50367 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087CC0: Register word32 __getegid(Register (ptr32 Eq_50367) gs)
// Called from:
//      __libc_init_secure
word32 __getegid(struct Eq_50367 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08087CE0: Register (ptr32 Eq_226) __lxstat64(Register (ptr32 Eq_9) gs, Stack ptr32 dwArg08, Stack (ptr32 word32) dwArg0C)
// Called from:
//      getcwd
struct Eq_226 * __lxstat64(struct Eq_9 * gs, ptr32 dwArg08, word32 * dwArg0C)
{
	struct Eq_226 * eax_11;
	gs->ptr0010();
	if (eax_11 <= (struct Eq_226 *) ~0x0FFF)
		return eax_11;
	word32 edx_44;
	return __syscall_error(eax_11, gs, out edx_44);
}

// 08087D10: Register (ptr32 Eq_226) __fxstatat64(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack word32 dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack Eq_2 dwArg14)
// Called from:
//      getcwd
struct Eq_226 * __fxstatat64(struct Eq_9 * gs, word32 dwArg04, word32 dwArg08, byte * dwArg0C, word32 dwArg10, Eq_2 dwArg14)
{
	if (dwArg04 != 0x03)
	{
		word32 edx_74;
		return __syscall_error((struct Eq_226 *) ~0x15, gs, out edx_74);
	}
	else
	{
		struct Eq_226 * eax_31;
		gs->ptr0010();
		if (eax_31 <= (struct Eq_226 *) ~0x0FFF)
			return null;
		word32 edx_73;
		return __syscall_error(eax_31, gs, out edx_73);
	}
}

// 08087D70: Register (ptr32 Eq_226) __libc_lseek(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out (ptr32 Eq_104589) ebxOut, Register out (ptr32 Eq_104590) ebpOut, Register out (ptr32 Eq_104591) esiOut, Register out Eq_2 ediOut)
// Called from:
//      __rewinddir
//      _dl_process_pt_note
//      open_verify.constprop.7
//      _dl_map_object_from_fd.constprop.8
//      _dl_start_profile
struct Eq_226 * __libc_lseek(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, struct Eq_104589 & ebxOut, struct Eq_104590 & ebpOut, struct Eq_104591 & esiOut, union Eq_2 & ediOut)
{
	ui32 eax_20 = gs->dw0014;
	ptr32 ecx_36;
	struct Eq_226 * eax_116;
	gs->ptr0010();
	if (eax_116 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_159;
		eax_116 = __syscall_error(eax_116, gs, out edx_159);
	}
	if (eax_116 == null)
	{
		eax_116 = dwLoc2C;
		if (dwLoc28 != dwLoc2C >> 0x1F)
		{
			gs->tFFFFFFE0.u0 = 0x4B;
			eax_116 = (struct Eq_226 *) ~0x00;
		}
	}
	struct Eq_104589 * ebx_66 = eax_20 ^ gs->dw0014;
	if (ebx_66 != null)
	{
		word32 ecx_160;
		word32 edx_161;
		__stack_chk_fail(out ecx_160, out edx_161);
		ptr32 ecx_84;
		struct Eq_226 * eax_82 = __isatty(gs, out ecx_84);
		ecxOut = ecx_84;
		ebxOut = ebx_66;
		ebpOut = (struct Eq_104590 *) &g_t80CE000;
		esiOut = fp - 44;
		ediOut = dwArg0C;
		return eax_82;
	}
	else
	{
		ecxOut = ecx_36;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return eax_116;
	}
}

// 08087E20: Register Eq_2 __isatty(Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut)
// Called from:
//      _IO_file_doallocate
//      __libc_lseek
Eq_2 __isatty(struct Eq_9 * gs, ptr32 & ecxOut)
{
	ui32 eax_7 = gs->dw0014;
	ptr32 ecx_47;
	int8 al_24 = (int8) (tcgetattr(gs, dwArg04, fp - 0x4C, out ecx_47) == 0x00);
	if ((eax_7 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_66;
		word32 edx_67;
		__stack_chk_fail(out ecx_66, out edx_67);
		ptr32 ecx_34;
		word32 edx_68;
		Eq_2 eax_33 = __open64_nocancel(gs, dwLoc48, dwLoc44, dwLoc40, out ecx_34, out edx_68);
		ecxOut = ecx_34;
		return eax_33;
	}
	else
	{
		ecxOut = ecx_47;
		return (word32) al_24;
	}
}

// 08087E70: Register (ptr32 Eq_226) __open64_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _dl_discover_osversion
//      __isatty
//      open_verify.constprop.7
//      _dl_sysdep_read_whole_file
//      _dl_start_profile
struct Eq_226 * __open64_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	byte dh_25 = SLICE(dwArg08, byte, 8);
	if (((byte) dwArg08 & 0x40) != 0x00 || (dwArg08 & 0x00410000) == 0x00410000)
		;
	ptr32 ecx_43;
	struct Eq_226 * eax_42;
	ptr32 edx_41;
	gs->ptr0010();
	if (eax_42 > (struct Eq_226 *) ~0x0FFF)
		eax_42 = __syscall_error(eax_42, gs, out edx_41);
	ecxOut = ecx_43;
	edxOut = edx_41;
	return eax_42;
}

// 08087EE0: Register (ptr32 Eq_226) __openat_nocancel(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack ui32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      __opendirat
struct Eq_226 * __openat_nocancel(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ui32 dwArg0C, word32 dwArg10)
{
	if (((byte) dwArg0C & 0x40) != 0x00 || (dwArg0C & 0x00410000) == 0x00410000)
		;
	struct Eq_226 * eax_36;
	gs->ptr0010();
	if (eax_36 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_84;
		eax_36 = __syscall_error(eax_36, gs, out edx_84);
	}
	return eax_36;
}

// 08087F40: Register (ptr32 Eq_226) tcgetattr(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 Eq_105177) dwArg08, Register out ptr32 ecxOut)
// Called from:
//      __isatty
struct Eq_226 * tcgetattr(struct Eq_9 * gs, word32 dwArg04, struct Eq_105177 * dwArg08, ptr32 & ecxOut)
{
	ui32 eax_13 = gs->dw0014;
	struct Eq_226 * eax_23;
	ptr32 ecx_119;
	gs->ptr0010();
	if (eax_23 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_175;
		eax_23 = __syscall_error(eax_23, gs, out edx_175);
	}
	if (eax_23 == null)
	{
		dwArg08->dw0024 = 0x00;
		dwArg08->dw0028 = 0x00;
		dwArg08->dw000C = dwLoc28;
		dwArg08->dw0000 = dwLoc34;
		dwArg08->b0010 = bLoc24;
		dwArg08->dw0004 = dwLoc30;
		dwArg08->dw0011 = dwLoc23;
		dwArg08->dw0008 = dwLoc2C;
		dwArg08->dw0015 = dwLoc1F;
		dwArg08->dw0034 = dwLoc2C & 4111;
		dwArg08->dw0019 = dwLoc1B;
		dwArg08->dw0038 = dwLoc2C & 4111;
		dwArg08->dw001D = dwLoc17;
		dwArg08->dw002C = 0x00;
		dwArg08->w0021 = wLoc13;
		dwArg08->b0030 = 0x00;
		ecx_119 = (word32) bLoc11;
		dwArg08->b0023 = (byte) ecx_119;
	}
	if ((eax_13 ^ gs->dw0014) != 0x00)
	{
		ptr32 ecx_88;
		word32 edx_176;
		__stack_chk_fail(out ecx_88, out edx_176);
		word32 edx_177;
		struct Eq_226 * eax_92 = brk(gs, dwLoc38, out edx_177);
		ecxOut = ecx_88;
		return eax_92;
	}
	else
	{
		ecxOut = ecx_119;
		return eax_23;
	}
}

// 08088020: Register (ptr32 Eq_226) brk(Register (ptr32 Eq_9) gs, Stack Eq_46344 dwArg04, Register out ptr32 edxOut)
// Called from:
//      __sbrk
//      tcgetattr
struct Eq_226 * brk(struct Eq_9 * gs, Eq_46344 dwArg04, ptr32 & edxOut)
{
	__syscall(0x80);
	__curbrk.u0 = 0x2D;
	if (dwArg04 > 0x2D)
	{
		ptr32 edx_19;
		struct Eq_226 * eax_18 = __syscall_error((struct Eq_226 *) ~0x0B, gs, out edx_19);
		edxOut = edx_19;
		return eax_18;
	}
	else
	{
		edxOut = 0x080CE000;
		return null;
	}
}

// 08088060: Register word32 wctrans(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      _i18n_number_rewrite
word32 wctrans(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 eax_23 = gs->ptrFFFFFFD0->t0000;
	Eq_2 ebp_24 = *((word32) eax_23 + 80);
	if (*ebp_24 != 0x00)
	{
		word32 esi_28 = 0x00;
		do
		{
			word32 ecx_139;
			word32 edx_140;
			if (strcmp(dwArg04, ebp_24, out ecx_139, out edx_140) == 0x00)
				return *((word32) eax_23 + (((word32) (*((word32) eax_23 + 0x006C)) + esi_28) * 0x04 + 36));
			++esi_28;
			word32 ecx_141;
			word32 edx_142;
			ebp_24 = (word32) strlen(ebp_24, out ecx_141, out edx_142) + ((word32) ebp_24 + 1);
		} while (*ebp_24 != 0x00);
	}
	return 0x00;
}

// 080880F0: Register uint32 __towctrans(Stack uint32 dwArg04, Stack (ptr32 Eq_74687) dwArg08)
// Called from:
//      _i18n_number_rewrite
//      _i18n_number_rewrite
//      _i18n_number_rewrite
uint32 __towctrans(uint32 dwArg04, struct Eq_74687 * dwArg08)
{
	uint32 eax_11 = dwArg04;
	if (dwArg08 != null)
	{
		uint32 ebx_18 = dwArg04 >> dwArg08->b0000;
		if (ebx_18 < dwArg08->dw0004)
		{
			int32 ebx_21 = dwArg08->a0014[ebx_18];
			if (ebx_21 != 0x00)
			{
				int32 ecx_32 = (dwArg08 + ((dwArg08->dw000C & dwArg04 >> dwArg08->b0008) * 0x04) / 20)[ebx_21 / 20];
				if (ecx_32 != 0x00)
					eax_11 = (uint32) ((byte) (dwArg08 + ((dwArg08->dw0010 & dwArg04) * 0x04) / 20)[ecx_32 / 20].b0000 + dwArg04);
			}
		}
	}
	return eax_11;
}

// 08088140: void __readonly_area(Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_10008 dwArg04, Stack up32 dwArg08)
void __readonly_area(Eq_2 edx, struct Eq_9 * gs, Eq_10008 dwArg04, up32 dwArg08)
{
	ui32 eax_20 = gs->dw0014;
	__new_fopen();
	if (134949356 != 0x00)
	{
		Eq_105488 eax_50 = g_t80B29EC;
		g_t80B29EC = SEQ(SLICE(eax_50, word16, 16), SLICE(eax_50, byte, 8) | 0x80, (byte) eax_50);
		up32 dwLoc50_310 = dwArg08;
		if (((byte) eax_50 & 0x10) == 0x00)
		{
			dwLoc4C = fp - 0x30;
			do
			{
				if (_IO_getdelim(gs, fp - 0x30, fp - 44, 0x0A, 134949356) <= null)
				{
l080882E0:
					break;
				}
				word32 ecx_486;
				word32 edx_487;
				Eq_10008 eax_112 = __strtoul(gs, 0x00, fp - 0x28, 0x10, out ecx_486, out edx_487);
				if (dwLoc28 == null)
					goto l080882E0;
				dwLoc28 = (union Eq_105544 *) ((char *) dwLoc28 + 1);
				if (*dwLoc28 != 0x2D)
					goto l080882E0;
				word32 edx_489;
				word32 ecx_488;
				Eq_10008 eax_137 = __strtoul(gs, (char *) dwLoc28 + 1, fp - 0x24, 0x10, out ecx_488, out edx_489);
				if (dwLoc24 == dwLoc28)
					goto l080882E0;
				dwLoc24 = (union Eq_105544 *) ((char *) dwLoc24 + 1);
				if (*dwLoc24 != 0x20)
					goto l080882E0;
				Eq_10008 ecx_154 = (word32) dwArg04.u1 + dwArg08;
				if (ecx_154 > eax_112 && dwArg04 < eax_137)
				{
					if (*((char *) dwLoc24 + 1) != 114)
						goto l080882E0;
					dwLoc24 = (union Eq_105544 *) ((char *) dwLoc24 + 3);
					if (*((char *) dwLoc24 + 2) != 0x2D)
						goto l080882E0;
					if (dwArg04 >= eax_112 && ecx_154 <= eax_137)
						break;
					if (dwArg04 < eax_112)
					{
						if (ecx_154 <= eax_137)
							dwLoc50_310 = (word32) eax_112.u1 + (dwLoc50_310 - ecx_154);
						else
							dwLoc50_310 = (word32) eax_112.u1 + dwLoc50_310 - eax_137;
					}
					else
						dwLoc50_310 = (word32) dwArg04.u1 + dwLoc50_310 - eax_137;
					if (dwLoc50_310 != 0x00)
						goto l080881F8;
					goto l080882E0;
				}
l080881F8:
			} while ((g_t80B29EC & 0x10) == 0x00);
		}
		__new_fclose(gs, 134949356);
		word32 ecx_484;
		word32 edx_485;
		free(gs, dwLoc70, 0x00, out ecx_484, out edx_485);
		edx = dwLoc4C;
		if (dwLoc4C != 0x00)
		{
l08088309:
			if ((eax_20 ^ gs->dw0014) == 0x00)
				return;
			word32 ecx_490;
			word32 edx_491;
			Eq_2 eax_272 = __stack_chk_fail(out ecx_490, out edx_491);
			word32 ecx_492;
			is_dst(eax_272, edx, out ecx_492);
			return;
		}
	}
	else
	{
		Eq_2 eax_43 = gs->tFFFFFFE0;
		if (eax_43 != 0x02 && eax_43 != 0x0D)
			goto l08088304;
	}
	goto l08088309;
}

// 08088370: Register Eq_2 is_dst(Register Eq_2 eax, Register Eq_2 edx, Register out ptr32 ecxOut)
// Called from:
//      __readonly_area
//      _dl_dst_count
//      _dl_dst_substitute
Eq_2 is_dst(Eq_2 eax, Eq_2 edx, ptr32 & ecxOut)
{
	ptr32 ecx_150;
	word32 ecx_171;
	word32 edx_172;
	Eq_2 eax_24 = strlen(edx, out ecx_171, out edx_172);
	Eq_2 ebx_105 = eax_24;
	if (*eax == 0x7B)
	{
		ebx_105.u0 = 0x00;
		if (strncmp((word32) eax + 1, edx, eax_24, out ecx_150) == 0x00 && *((word32) eax_24 + ((word32) eax + 1)) == 0x7D)
		{
			ecxOut = ecx_150;
			return (word32) eax_24 + 2;
		}
		goto l0808839F;
	}
	if (strncmp(eax, edx, eax_24, out ecx_150) == 0x00)
	{
		word32 edx_91 = CONVERT(Mem79[eax + eax_24:byte], byte, word32);
		byte dl_102 = (byte) edx_91;
		if ((byte) ((edx_91 & ~0x20) - 0x41) > 0x19 && ((byte) (edx_91 - 0x30) > 0x09 && dl_102 != 0x5F))
			goto l0808839F;
	}
	ebx_105.u0 = 0x00;
l0808839F:
	ecxOut = ecx_150;
	return ebx_105;
}

// 08088400: Register byte is_trusted_path_normalize(Register Eq_2 eax, Register int32 edx, Register out (ptr32 Eq_105687) ecxOut)
// Called from:
//      _dl_dst_substitute
byte is_trusted_path_normalize(Eq_2 eax, int32 edx, struct Eq_105687 & ecxOut)
{
	if (edx == 0x00)
	{
		ecxOut = ecx;
		return 0x00;
	}
	ui32 ecx_17 = edx + 0x1D & ~0x0F;
	struct Eq_105697 * esp_28 = fp - 44;
	struct Eq_105697 * edi_30 = fp - 44 - (edx + 0x1D & ~0x0FFF);
	if (fp - 44 != edi_30)
	{
		do
		{
			esp_28 -= 0x1000;
			esp_28->dw0FFC = esp_28->dw0FFC;
		} while (esp_28 != edi_30);
	}
	if ((ecx_17 & 0x0FFF) != 0x00)
	{
		esp_28 -= ecx_17 & 0x0FFF;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_28 - 0x04)[(ecx_17 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_28 - 0x04)[(ecx_17 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	word32 esi_57 = esp_28 + 0x0F;
	word32 edi_85 = (word32) *eax;
	struct Eq_105687 * ecx_116 = esi_57 & ~0x0F;
l0808846C:
	byte dl_159 = (byte) edi_85;
	if (dl_159 != 0x00)
	{
		do
		{
			byte bl_75 = *((word32) eax + 1);
			if (dl_159 != 0x2F)
			{
				eax = (word32) eax + 1;
l08088463:
				ecx_116->b0000 = dl_159;
				edi_85 = (word32) bl_75;
				++ecx_116;
				goto l0808846C;
			}
			if (bl_75 == 0x2E)
			{
				edi_85 = (word32) *((word32) eax + 2);
				byte bl_87 = (byte) edi_85;
				if (bl_87 != 0x2E)
				{
					if (bl_87 == 0x2F || bl_87 == 0x00)
					{
						eax = (word32) eax + 2;
						goto l0808846C;
					}
				}
				else
				{
					edi_85 = (word32) *((word32) eax + 3);
					byte bl_92 = (byte) edi_85;
					if (bl_92 == 0x2F || bl_92 == 0x00)
					{
						if (ecx_116 > (esi_57 & ~0x0F))
						{
							struct Eq_105687 * edx_106 = ecx_116 - 0x01;
							if (ecx_116->bFFFFFFFF != 0x2F)
							{
								do
								{
									if ((esi_57 & ~0x0F) == edx_106)
									{
										ecx_116 = esi_57 & ~0x0F;
										goto l0808855E;
									}
									--edx_106;
								} while (edx_106->b0000 != 0x2F);
							}
							ecx_116 = edx_106;
						}
l0808855E:
						eax = (word32) eax + 3;
						goto l0808846C;
					}
				}
			}
			eax = (word32) eax + 1;
			if (ecx_116 <= (esi_57 & ~0x0F) || ecx_116->bFFFFFFFF != 0x2F)
				goto l08088463;
			dl_159 = bl_75;
		} while (bl_75 != 0x00);
	}
	struct Eq_105687 * eax_183;
	word32 esi_169 = esp_28 + 0x0F & ~0x0F;
	if (ecx_116 != esi_169)
	{
		eax_183 = ecx_116;
		if (ecx_116->bFFFFFFFF == 0x2F)
		{
l080884B2:
			word32 eax_210;
			ptr32 eax_191 = eax_183 - esi_169;
			if (eax_191 > 0x04 && (esi_169->b0000 == 0x62696C2F && esi_169[4] == 0x2F || eax_191 > 0x08 && (esi_169->b0000 == 0x7273752F && (esi_169[4] == 0x62696C2F && esi_169[8] == 0x2F))))
				eax_210 = 0x01;
			else
				eax_210 = 0x00;
			ecxOut = ecx_116;
			return (byte) eax_210;
		}
	}
	ecx_116->b0000 = 0x2F;
	eax_183 = ecx_116 + 1;
	goto l080884B2;
}

// 08088590: Register Eq_2 _dl_process_pt_note(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 up32) dwArg04, Register out (ptr32 Eq_105878) ebxOut, Register out (ptr32 Eq_105879) ebpOut, Register out (ptr32 Eq_105880) esiOut, Register out (ptr32 Eq_105881) ediOut)
// Called from:
//      _dl_map_object_from_fd.constprop.8
Eq_2 _dl_process_pt_note(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, up32 * dwArg04, struct Eq_105878 & ebxOut, struct Eq_105879 & ebpOut, struct Eq_105880 & esiOut, struct Eq_105881 & ediOut)
{
	Eq_2 ebx_125;
	Eq_2 eax_216;
	Eq_2 eax_126;
	Eq_2 edi_27 = *((word32) edx + 16);
	Eq_2 edi_30 = *((word32) edx + 4);
	struct Eq_105893 * ebp_185 = fp - 4;
	struct Eq_105897 * esp_136 = fp - 0x4C;
	if (edi_27 + edi_30 >u Mem29[dwArg04 + 0x00:word32])
	{
		if (edi_27 <= 0xFFFF)
		{
			struct Eq_105897 * ebx_131 = fp - 0x4C - ((word32) edi_27 + 27 & ~0x0FFF);
			ui32 edx_132 = (word32) edi_27 + 27 & ~0x0F;
			if (fp - 0x4C != ebx_131)
			{
				do
				{
					esp_136 -= 0x1000;
					esp_136->dw0FFC = esp_136->dw0FFC;
				} while (esp_136 != ebx_131);
			}
			if ((edx_132 & 0x0FFF) != 0x00)
			{
				esp_136 -= edx_132 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_136 - 0x04)[(edx_132 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_136 - 0x04)[(edx_132 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			struct Eq_106041 * esp_160 = esp_136 - 0x04;
			esp_160->tFFFFFFFC.u0 = 0x00;
			esp_160->tFFFFFFF8 = edi_30;
			esp_160->tFFFFFFF4 = ecx;
			struct Eq_106054 * esi_190;
			word32 ecx_487;
			word32 edi_488;
			__libc_lseek(gs, esp_160->tFFFFFFF4, esp_160->tFFFFFFF8, esp_160->tFFFFFFFC, out ecx_487, out ebx_125, out ebp_185, out esi_190, out edi_488);
			Eq_2 esp_191 = <invalid>;
			Eq_2 edi_196 = ebp_185->tFFFFFFE4;
			Eq_2 ecx_197 = ebp_185->tFFFFFFE0;
			*((word32) esp_191 + 8) = edi_196;
			*((word32) esp_191 + 4) = ebx_125;
			*esp_191 = ecx_197;
			esp_136 = (word32) esp_191 + 16;
			word32 ecx_489;
			if (edi_196 == __read_nocancel(gs, *esp_191, *((word32) esp_191 + 4), *((word32) esp_191 + 8), out ecx_489))
			{
				if ((ebp_185->ptrFFFFFFDC->b019A & 0x0E) == 0x00 && esi_190->dw001C == 0x04)
				{
					eax_126 = ebx_125;
					if (ebp_185->tFFFFFFE4 > 0x0C)
					{
						ebp_185->tFFFFFFD0.u0 = 0x00;
						goto l080885F4;
					}
				}
				goto l080886DE;
			}
		}
		else
		{
			struct Eq_105946 * ebp_47;
			Eq_2 edi_50;
			word32 ecx_480;
			word32 edx_481;
			word32 esi_483;
			word32 ebx_482;
			Eq_2 eax_46 = __libc_malloc(gs, dwLoc60, edi_27, out ecx_480, out edx_481, out ebx_482, out ebp_47, out esi_483, out edi_50);
			Eq_2 ecx_57 = ebp_47->tFFFFFFE0;
			ebp_47->tFFFFFFD0 = eax_46;
			Eq_2 ebx_70;
			struct Eq_105970 * esi_74;
			word32 edi_485;
			word32 ecx_484;
			__libc_lseek(gs, ecx_57, edi_50, 0x00, out ecx_484, out ebx_70, out ebp_185, out esi_74, out edi_485);
			Eq_2 esp_75 = <invalid>;
			Eq_2 edi_80 = ebp_185->tFFFFFFE4;
			Eq_2 ecx_81 = ebp_185->tFFFFFFE0;
			*((word32) esp_75 + 8) = edi_80;
			*((word32) esp_75 + 4) = ebx_70;
			*esp_75 = ecx_81;
			esp_136 = (word32) esp_75 + 16;
			word32 ecx_486;
			if (__read_nocancel(gs, *esp_75, *((word32) esp_75 + 4), *((word32) esp_75 + 8), out ecx_486) == edi_80)
			{
				if ((ebp_185->ptrFFFFFFDC->b019A & 0x0E) != 0x00 || esi_74->dw001C != 0x04)
					goto l080886C8;
				ebx_125 = ebp_185->tFFFFFFD0;
				eax_126 = ebx_125;
l080885F4:
				ebp_185->dwFFFFFFCC = 0x00;
				ebp_185->dwFFFFFFD4 = 0x0C - eax_126;
				up32 edi_240 = 0x00;
				do
				{
					Eq_105936 esi_258;
					Eq_2 eax_247 = *ebx_125;
					ebp_185->tFFFFFFE0 = eax_247;
					if (eax_247 == 0x04 && (*((word32) ebx_125 + 8) == 0x05 && *((word32) ebx_125 + 0x0C) == 5590599))
					{
						struct Eq_106132 * esi_259 = ebp_185->ptrFFFFFFDC;
						ui32 eax_260 = (word32) esi_259->b019A;
						if (((byte) eax_260 & 0x0E) != 0x00)
							goto l080886C8;
						esi_259->b019A = (byte) (eax_260 & ~0x0E | 0x02);
						Eq_105936 esi_269 = *((word32) ebx_125 + 4);
						if (esi_269 <= 0x07 || (esi_269 & 0x03) != 0x00)
							goto l080886C8;
						ebp_185->tFFFFFFC4 = esi_269;
						struct Eq_106173 * eax_275 = (word32) ebx_125 + 16;
						ebp_185->tFFFFFFC8 = ebx_125;
						word32 ecx_277 = eax_275 + esi_269;
						do
						{
							up32 edx_282 = eax_275->dw0000;
							int32 ecx_283 = eax_275->dw0004;
							if (edx_282 < edi_240)
								goto l080886C8;
							ptr32 ebx_287 = eax_275 + 1;
							if (ecx_277 < ebx_287 + ecx_283)
								goto l080886C8;
							if (edx_282 == 0xC0000002)
							{
								ebx_125 = ebp_185->tFFFFFFC8;
								esi_258 = ebp_185->tFFFFFFC4;
								if (ecx_283 != 0x04)
									goto l080886C8;
								ebp_185->dwFFFFFFCC = (ui32) eax_275[1];
								edi_240 = 0xC0000002;
								goto l08088613;
							}
							if (edx_282 > 0xC0000002)
								goto l080886C8;
							eax_275 = ebx_287 + (ecx_283 + 0x03 & ~0x03);
							edi_240 = edx_282;
						} while (ecx_277 - eax_275 > 0x07);
						ebx_125 = ebp_185->tFFFFFFC8;
						esi_258 = ebp_185->tFFFFFFC4;
					}
					else
						esi_258 = *((word32) ebx_125 + 4);
l08088613:
					ebx_125 = (word32) ebx_125 + ((word32) esi_258 + ((word32) ebp_185->tFFFFFFE0 + 0x0F | 0x03) & ~0x03);
				} while (ebp_185->tFFFFFFE4 > (word32) ebx_125 + ebp_185->dwFFFFFFD4);
				ui32 ecx_328 = ebp_185->dwFFFFFFCC;
				if ((ecx_328 & 0x01) != 0x00)
				{
					struct Eq_106132 * esi_335 = ebp_185->ptrFFFFFFDC;
					esi_335->b019A |= 0x04;
				}
				if ((ecx_328 & 0x02) != 0x00)
				{
					struct Eq_106132 * eax_346 = ebp_185->ptrFFFFFFDC;
					eax_346->b019A |= 0x08;
				}
l080886C8:
				Eq_2 eax_354 = ebp_185->tFFFFFFD0;
				if (eax_354 != 0x00)
				{
					struct Eq_106263 * esp_365 = esp_136 - 0x0C;
					esp_365->tFFFFFFFC = eax_354;
					word32 ecx_490;
					word32 edx_491;
					free(gs, esp_365->tFFFFFFF8, esp_365->tFFFFFFFC, out ecx_490, out edx_491);
				}
				goto l080886DE;
			}
			Eq_2 eax_100 = ebp_185->tFFFFFFD0;
			if (eax_100 != 0x00)
			{
				*esp_75 = eax_100;
				word32 ecx_492;
				word32 edx_493;
				free(gs, *((word32) esp_75 - 4), *esp_75, out ecx_492, out edx_493);
			}
		}
		eax_216.u0 = ~0x00;
l080886E0:
		struct Eq_106220 * esp_393 = ebp_185 - 0x0C;
		struct Eq_105880 * esi_399 = esp_393->ptr0004;
		struct Eq_105881 * edi_401 = esp_393->ptr0008;
		struct Eq_105879 * ebp_403 = esp_393->ptr000C;
		ebxOut = esp_393->ptr0000;
		ebpOut = ebp_403;
		esiOut = esi_399;
		ediOut = edi_401;
		return eax_216;
	}
	else
	{
		if ((*((word32) eax + 410) & 0x0E) != 0x00 || *((word32) edx + 28) != 0x04)
			goto l080886DE;
		ebx_125 = dwArg04 + 0x04 + edi_30;
		eax_126 = ebx_125;
		if (edi_27 > 0x0C)
			goto l080885F4;
l080886DE:
		eax_216.u0 = 0x00;
		goto l080886E0;
	}
}

// 08088890: Register word32 lose(Register Eq_2 eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08)
// Called from:
//      open_verify.constprop.7
//      _dl_map_object_from_fd.constprop.8
word32 lose(Eq_2 eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg08)
{
	if (edx != ~0x00)
	{
		word32 edx_154;
		__close_nocancel(gs, edx, out edx_154);
	}
	ptr32 esp_48 = fp - 0x1C;
	if (dwArg08 != 0x00)
	{
		Eq_2 eax_45 = *((word32) dwArg08 + 428);
		if (eax_45 != ~0x00)
		{
			word32 ecx_159;
			word32 edx_160;
			free(gs, dwLoc30, eax_45, out ecx_159, out edx_160);
			esp_48 = fp - 0x18;
		}
	}
	struct Eq_106400 * esp_65 = esp_48 - 0x0C;
	esp_65->tFFFFFFFC = dwArg08;
	word32 ecx_155;
	word32 edx_156;
	free(gs, esp_65->tFFFFFFF8, esp_65->tFFFFFFFC, out ecx_155, out edx_156);
	esp_65->t0000 = esp_65->t0030;
	word32 ecx_157;
	word32 edx_158;
	free(gs, esp_65->tFFFFFFFC, esp_65->t0000, out ecx_157, out edx_158);
	if (esp_65->ptr0040 != null)
	{
		esp_65->ptr0040->dw000C = 0x00;
		_dl_debug_state();
	}
	esp_65->t0010 = esp_65->t003C;
	esp_65->dw000C = 0x00;
	esp_65->dw0008 = ecx;
	esp_65->t0004 = eax;
	word32 ebp_118;
	Eq_2 edx_122;
	word32 ecx_161;
	word32 ebx_162;
	word32 edi_163;
	Eq_2 eax_117 = _dl_signal_error(gs, esp_65->t0004, esp_65->t0010, out ecx_161, out edx_122, out ebx_162, out ebp_118, out edi_163);
	word32 ebp_164;
	word32 edi_165;
	add_name_to_object.isra.4(eax_117, edx_122, gs, out ebp_164, out edi_165);
	return ebp_118;
}

// 08088920: Register word32 add_name_to_object.isra.4(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_106516) ebpOut, Register out (ptr32 Eq_106517) ediOut)
// Called from:
//      lose
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
word32 add_name_to_object.isra.4(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, struct Eq_106516 & ebpOut, struct Eq_106517 & ediOut)
{
	struct Eq_106517 * edi_147;
	struct Eq_106516 * ebp_144;
	ptr32 esp_154;
	word32 ebx_145;
	if (eax == 0x00)
	{
		esp_154 = fp - 44;
		word32 ecx_275;
		word32 edx_276;
		word32 ecx_277;
		word32 edx_278;
		word32 esi_279;
		if (__libc_malloc(gs, dwLoc40, (word32) strlen(edx, out ecx_275, out edx_276) + 0x0D, out ecx_277, out edx_278, out ebx_145, out ebp_144, out esi_279, out edi_147) != 0x00)
			goto l080889E9;
	}
	else
	{
		do
		{
			word32 ecx_273;
			word32 edx_274;
			if (strcmp(edx, *eax, out ecx_273, out edx_274) == 0x00)
			{
				ebpOut = ebp;
				ediOut = edi;
				return ebx;
			}
			eax = *((word32) eax + 4);
		} while (eax != 0x00);
		word32 ecx_283;
		word32 edx_284;
		Eq_2 eax_56 = strlen(edx, out ecx_283, out edx_284);
		Eq_2 edi_74;
		struct Eq_106622 * esi_76;
		word32 ecx_285;
		word32 edx_286;
		word32 ebp_287;
		Eq_2 eax_70 = __libc_malloc(gs, dwLoc40, (word32) eax_56 + 0x0D, out ecx_285, out edx_286, out ebx_145, out ebp_287, out esi_76, out edi_74);
		if (eax_70 != 0x00)
		{
			word32 ecx_294;
			word32 edx_295;
			Eq_2 eax_96 = memcpy((word32) eax_70 + 0x0C, edi_74, (word32) eax_56 + 1, out ecx_294, out edx_295);
			*((word32) eax_70 + 4) = 0x00;
			*eax_70 = eax_96;
			*((word32) eax_70 + 8) = 0x00;
			esi_76->t0004 = eax_70;
			ebpOut = ebp;
			ediOut = edi;
			return ebx;
		}
	}
	word32 ecx_281;
	word32 edx_282;
	_dl_signal_error(gs, 0x0C, ebx_145 + ~0x0001B603, out ecx_281, out edx_282, out ebx_145, out ebp_144, out edi_147);
	esp_154 = fp - 0x40;
l080889E9:
	struct Eq_106571 * esp_186 = esp_154 - 4;
	esp_186->dw0000 = ebx_145 + ~0x0001AED7;
	esp_186->dwFFFFFFFC = 0x01AF;
	esp_186->dwFFFFFFF8 = ebx_145 + 4294855192;
	esp_186->dwFFFFFFF4 = ebx_145 + ~0x0001B5DD;
	struct Eq_106593 * edx_197;
	word32 ecx_280;
	Eq_2 eax_196 = __assert_fail(out ecx_280, out edx_197);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	word32 ebx_290;
	word32 ebp_291;
	word32 esi_292;
	word32 edi_293;
	open_verify.constprop.7(eax_196, ecx, edx_197, gs, stackArg4, out ebx_290, out ebp_291, out esi_292, out edi_293);
	ebpOut = ebp_144;
	ediOut = edi_147;
	return ebx_145;
}

// 08088A10: Register Eq_2 open_verify.constprop.7(Register Eq_2 eax, Register ui32 ecx, Register (ptr32 Eq_106593) edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_106651) ebxOut, Register out (ptr32 Eq_106652) ebpOut, Register out ptr32 esiOut, Register out (ptr32 Eq_106654) ediOut)
// Called from:
//      add_name_to_object.isra.4
//      open_path
//      _dl_map_object
Eq_2 open_verify.constprop.7(Eq_2 eax, ui32 ecx, struct Eq_106593 * edx, struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_106651 & ebxOut, union Eq_106652 & ebpOut, ptr32 & esiOut, struct Eq_106654 & ediOut)
{
	struct Eq_106686 * ebp_277 = fp - 4;
	word32 ecx_1142;
	word32 edx_1143;
	Eq_2 eax_36 = __open64_nocancel(gs, eax, 0x00080000, dwLoc64, out ecx_1142, out edx_1143);
	if (eax_36 == ~0x00)
	{
l08088B56:
		struct Eq_106701 * esp_883 = ebp_277 - 0x0C;
		Eq_2 eax_882 = ebp_277->dwFFFFFFD4;
		ptr32 esi_886 = esp_883->ptr0004;
		struct Eq_106654 * edi_888 = esp_883->ptr0008;
		union Eq_106652 * ebp_890 = esp_883->ptr000C;
		ebxOut = esp_883->ptr0000;
		ebpOut = ebp_890;
		esiOut = esi_886;
		ediOut = edi_888;
		return eax_882;
	}
	gs->tFFFFFFE0.u0 = 0x00;
	edx->t0000.u0 = 0x00;
	Eq_106726 eax_55 = 0x00;
	do
	{
		word32 ecx_1144;
		word32 eax_76 = __read_nocancel(gs, eax_36, eax_55 + (edx + 0x04), 0x0200 - eax_55, out ecx_1144);
		struct Eq_106754 * esp_225 = fp - 0x5C;
		if (eax_76 <= 0x00)
		{
			eax_55 = edx->t0000;
			break;
		}
		eax_55 = eax_76 + Mem74[edx + 0x00:word32];
		edx->t0000 = eax_55;
	} while (eax_55 <= 0x33);
	Eq_106759 esi_104;
	Eq_2 edi_100;
	if (eax_55 <= 0x33)
	{
		edi_100 = gs->tFFFFFFE0;
		esi_104.u1 = 134949424;
		if (edi_100 != 0x00)
			esi_104.u1 = 134949439;
		goto l08088DDA;
	}
	word32 edx_110 = edx->dw0004;
	if (edx_110 != g_dw80B3184)
	{
		if (edx_110 != g_dw80B3178)
			goto l08088AFF;
	}
	else
	{
		if (edx->t0008 == g_t80B3188)
			goto l08088AD8;
		if (edx_110 != g_dw80B3178)
		{
l08088AFF:
			if (edx->dw0004 != 0x464C457F)
			{
				edi_100.u0 = 0x00;
				esi_104.u1 = 0x080B2AB4;
				goto l08088DDA;
			}
			if (edx->t0008 == 0x01)
			{
				if (edx->b0009 != 0x01)
				{
					edi_100.u0 = 0x00;
					esi_104.u1 = 0x080B2C90;
				}
				else if (edx->b000A != 0x01)
				{
					edi_100.u0 = 0x00;
					esi_104.u1 = 0x080B2C5C;
				}
				else
				{
					byte dl_610 = edx->b000B;
					int8 al_613 = (int8) (dl_610 != 0x03);
					if (dl_610 != 0x00 && al_613 != 0x00)
					{
						edi_100.u0 = 0x00;
						esi_104.u1 = 134949461;
					}
					else
					{
						cu8 dl_624 = edx->b000C;
						if (dl_624 != 0x00 && (dl_624 > 0x03 || al_613 != 0x00))
						{
							edi_100.u0 = 0x00;
							esi_104.u1 = 134949485;
						}
						else
						{
							word32 edx_1163;
							word32 ecx_1162;
							Eq_2 eax_655 = memcmp(&edx->dw000D, 0x080B318D, 0x07, out ecx_1162, out edx_1163);
							esi_104.u1 = 134949541;
							esp_225 = fp - 0x5C;
							edi_100 = eax_655;
							if (eax_655 != 0x00)
							{
								edi_100.u0 = 0x00;
								esi_104.u1 = 0x080B2A8A;
							}
						}
					}
				}
				goto l08088DDA;
			}
			*dwArg04 = 0x01;
l08088B26:
			struct Eq_107375 * esp_831 = esp_225 - 0x0C;
			esp_831->tFFFFFFFC = ebp_277->dwFFFFFFD4;
			word32 edx_1155;
			__close_nocancel(gs, esp_831->tFFFFFFFC, out edx_1155);
			(gs->*ebp_277->ptrFFFFFFB8).u0 = 0x02;
			ebp_277->dwFFFFFFD4 = ~0x00;
			esp_225 = (struct Eq_106754 *) ((char *) &esp_831->tFFFFFFFC + 16);
l08088B45:
			struct Eq_106905 * esp_858 = esp_225 - 0x0C;
			esp_858->tFFFFFFFC = ebp_277->dwFFFFFFBC;
			word32 edx_1146;
			word32 ecx_1145;
			free(gs, esp_858->tFFFFFFF8, esp_858->tFFFFFFFC, out ecx_1145, out edx_1146);
			goto l08088B56;
		}
	}
	if (edx->t0008 != g_t80B317C)
		goto l08088AFF;
l08088AD8:
	cu8 dl_138 = edx->b000C;
	if ((dl_138 == 0x00 || edx->b000B == 0x03 && dl_138 <= 0x03) && (edx->dw000D == g_dw80B318D && (edx->w0011 == g_w80B3191 && edx->b0013 == g_b80B3193)))
	{
		edi_100.u0 = 0x00;
		if (edx->dw0018 != 0x01)
		{
			esi_104.u1 = 0x080B2CBC;
			goto l08088DDA;
		}
		if (edx->w0016 == 0x03)
		{
			word32 edx_175 = (word32) edx->w0014;
			word16 dx_182 = (word16) edx_175;
			if ((word16) (edx_175 - 0x02) <= 0x01)
			{
				if (dx_182 != 0x02 || (ecx & 0x20000000) != 0x00)
				{
					if (edx->w002E == 0x20)
					{
						ui32 edx_200 = (word32) edx->w0030;
						Eq_2 ecx_201 = edx->t0020;
						ui32 esi_203 = edx_200 << 0x05;
						if ((word32) ecx_201 + (edx_200 << 0x05) <= eax_55)
						{
l08088C1A:
							struct Eq_106899 * edi_316 = ebp_277->dwFFFFFFE0;
							ebp_277->dwFFFFFFBC = 0x00;
							if (edi_316 < edi_316 + esi_203 / 32)
							{
								do
								{
									if (edi_316->dw0000 == 0x04)
									{
										Eq_2 ecx_326 = edi_316->dw0010;
										if (ecx_326 > 0x1F)
										{
											uint32 eax_329 = edi_316->dw001C;
											ebp_277->dwFFFFFFD8 = eax_329;
											if (eax_329 > 0x03 && (eax_329 - 0x04 & ~0x04) == 0x00)
											{
												Eq_2 ebx_345;
												Eq_2 esi_339 = edi_316->dw0004;
												if (ecx_326 + esi_339 >u Mem331[Mem331[ebp_277 + -36:word32] + 0x00:word32])
												{
													if (ecx_326 <= 0xFFFF)
													{
														struct Eq_106754 * ebx_383 = esp_225 - ((word32) ecx_326 + 27 & ~0x0FFF);
														ui32 edx_384 = (word32) ecx_326 + 27 & ~0x0F;
														while (esp_225 != ebx_383)
														{
															esp_225 -= 0x1000;
															esp_225->dw0FFC = esp_225->dw0FFC;
														}
														if ((edx_384 & 0x0FFF) != 0x00)
														{
															esp_225 -= edx_384 & 0x0FFF;
															(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[(edx_384 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[(edx_384 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
														}
													}
													else
													{
														ebp_277->ptrFFFFFFD0 = (ptr32) ecx_326;
														struct Eq_107070 * esp_349 = esp_225 - 0x08;
														esp_349->tFFFFFFFC = ecx_326;
														esp_349->tFFFFFFF8 = ebp_277->dwFFFFFFBC;
														Eq_2 esp_363 = <invalid>;
														word32 edi_1150;
														word32 edx_1149;
														Eq_2 eax_364 = __realloc(gs, esp_349->tFFFFFFF4, esp_349->tFFFFFFF8, esp_349->tFFFFFFFC, out edx_1149, out ebp_277, out esi_339, out edi_1150);
														esp_225 = (word32) esp_363 + 16;
														if (eax_364 == 0x00)
															goto l08088FE5;
														ebp_277->dwFFFFFFBC = (word32) eax_364;
														ecx_326 = ebp_277->ptrFFFFFFD0;
													}
													ebp_277->ptrFFFFFFD0 = (ptr32) ecx_326;
													struct Eq_107442 * esp_416 = esp_225 - 0x04;
													esp_416->tFFFFFFFC.u0 = 0x00;
													esp_416->tFFFFFFF8 = esi_339;
													esp_416->tFFFFFFF4 = ebp_277->dwFFFFFFD4;
													word32 ecx_1156;
													Eq_2 esi_448;
													__libc_lseek(gs, esp_416->tFFFFFFF4, esp_416->tFFFFFFF8, esp_416->tFFFFFFFC, out ecx_1156, out ebx_345, out ebp_277, out esi_448, out edi_316);
													Eq_2 esp_449 = <invalid>;
													*((word32) esp_449 + 8) = ebp_277->ptrFFFFFFD0;
													*((word32) esp_449 + 4) = ebx_345;
													*esp_449 = esi_448;
													word32 ecx_1157;
													Eq_2 eax_463 = __read_nocancel(gs, *esp_449, *((word32) esp_449 + 4), *((word32) esp_449 + 8), out ecx_1157);
													ecx_326 = ebp_277->ptrFFFFFFD0;
													esp_225 = (word32) esp_449 + 16;
													if (ecx_326 != eax_463)
													{
														*esp_449 = ebp_277->dwFFFFFFBC;
														word32 ecx_1153;
														word32 edx_1154;
														free(gs, *((word32) esp_449 - 4), *esp_449, out ecx_1153, out edx_1154);
														esp_225 = (word32) esp_449 + 20;
														goto l08088FE5;
													}
												}
												else
													ebx_345 = (word32) esi_339 + ebp_277->dwFFFFFFC8;
												word32 eax_499 = ebp_277->dwFFFFFFD8;
												ebp_277->dwFFFFFFB4 = edi_316;
												ebp_277->ptrFFFFFFD0 = ~0x0001AE97;
												ebp_277->dwFFFFFFCC = eax_499 + 11;
												ui32 edx_506 = -eax_499;
												while (*ebx_345 != (ebp_277->ptrFFFFFFE4)[ebp_277->ptrFFFFFFD0] || (*((word32) ebx_345 + 4) != (ebp_277->ptrFFFFFFE4)->dwFFFE516C || (*((word32) ebx_345 + 8) != (ebp_277->ptrFFFFFFE4)->dwFFFE5170 || *((word32) ebx_345 + 0x0C) != (ebp_277->ptrFFFFFFE4)->dwFFFE5174)))
												{
													Eq_107305 eax_545 = ((word32) *ebx_345 + ebp_277->dwFFFFFFCC & edx_506) + ((word32) (*((word32) ebx_345 + 4)) + (ebp_277->dwFFFFFFD8 - 0x01)) & edx_506;
													if (eax_545 > ecx_326 - 0x20)
													{
														edi_316 = ebp_277->dwFFFFFFB4;
														goto l08088EA3;
													}
													ecx_326 -= eax_545;
													ebx_345 += eax_545;
												}
												edi_316 = ebp_277->dwFFFFFFB4;
												if (ecx_326 != 0x00)
												{
													if (*((word32) ebx_345 + 16) != 0x00)
														goto l08088B26;
													uint32 edx_580 = _dl_osversion;
													if ((((word32) *((word32) ebx_345 + 20) << 0x08) + (word32) (*((word32) ebx_345 + 24)) << 0x08) + (word32) (*((word32) ebx_345 + 28)) > edx_580 && edx_580 != 0x00)
														goto l08088B26;
													break;
												}
l08088EA3:
												edx_200 = (word32) ebp_277->ptrFFFFFFDC->w0030;
											}
										}
									}
									++edi_316;
								} while (edi_316 < (edx_200 << 0x05) + ebp_277->dwFFFFFFE0);
							}
							goto l08088B45;
						}
						ui32 eax_211 = (edx_200 << 0x05) + 0x1B;
						struct Eq_106754 * ebx_220 = fp - 0x5C - (eax_211 & 0x003FF000);
						if (fp - 0x5C != ebx_220)
						{
							do
							{
								esp_225 -= 0x1000;
								esp_225->dw0FFC = esp_225->dw0FFC;
							} while (esp_225 != ebx_220);
						}
						int32 edx_236 = eax_211 & 0x003FFFF0 & 0x0FFF;
						if (edx_236 != 0x00)
						{
							esp_225 -= edx_236;
							(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[edx_236 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_225 - 0x04)[edx_236 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						}
						struct Eq_107157 * esp_254 = esp_225 - 0x04;
						esp_254->tFFFFFFFC.u0 = 0x00;
						esp_254->tFFFFFFF8 = ecx_201;
						esp_254->tFFFFFFF4 = eax_36;
						word32 ecx_1151;
						Eq_2 ebx_278;
						Eq_2 edi_280;
						Eq_2 esi_282;
						__libc_lseek(gs, esp_254->tFFFFFFF4, esp_254->tFFFFFFF8, esp_254->tFFFFFFFC, out ecx_1151, out ebx_278, out ebp_277, out esi_282, out edi_280);
						Eq_2 esp_283 = <invalid>;
						*((word32) esp_283 + 8) = esi_282;
						*((word32) esp_283 + 4) = ebx_278;
						*esp_283 = edi_280;
						esp_225 = (word32) esp_283 + 16;
						word32 ecx_1152;
						if (__read_nocancel(gs, *esp_283, *((word32) esp_283 + 4), *((word32) esp_283 + 8), out ecx_1152) == esi_282)
						{
							edx_200 = (word32) ebp_277->ptrFFFFFFDC->w0030;
							esi_203 = edx_200 << 0x05;
							goto l08088C1A;
						}
l08088FE5:
						edi_100 = gs->*ebp_277->ptrFFFFFFB8;
						esi_104 = (char *) ebp_277->ptrFFFFFFE4 - 0x0001B5C1;
					}
					else
						esi_104.u1 = 0x080B2CE8;
				}
				else
					esi_104.u1 = 134949904;
			}
			else
				esi_104.u1 = 134949940;
l08088DDA:
			if (ebp_277->bFFFFFFC0 == 0x00)
			{
l08088DE0:
				struct Eq_106971 * esp_699 = esp_225 - 0x0C;
				word32 ecx_703 = ebp_277->dwFFFFFFC4;
				Eq_2 edx_704 = ebp_277->dwFFFFFFD4;
				esp_699->dwFFFFFFFC = 0x00;
				esp_699->dwFFFFFFF8 = 0x00;
				esp_699->tFFFFFFF4 = esi_104;
				esp_699->dwFFFFFFF0 = 0x00;
				esp_699->dwFFFFFFEC = 0x00;
				lose(edi_100, ecx_703, edx_704, gs, dwArg04);
				esp_225 = esp_699 - 20;
			}
			struct Eq_106938 * esp_730 = esp_225 - 0x0C;
			esp_730->tFFFFFFFC = ebp_277->dwFFFFFFC4;
			word32 ecx_1147;
			word32 edx_1148;
			Eq_2 eax_737 = strlen(esp_730->tFFFFFFFC, out ecx_1147, out edx_1148);
			struct Eq_106957 * esp_744 = (char *) &esp_730->tFFFFFFFC + 16;
			struct Eq_106957 * ebx_750 = (char *) &esp_730->tFFFFFFFC + 16 - ((word32) eax_737 + 28 & ~0x0FFF);
			ui32 ecx_751 = (word32) eax_737 + 28 & ~0x0F;
			while (esp_744 != ebx_750)
			{
				esp_744 -= 0x1000;
				esp_744->dw0FFC = esp_744->dw0FFC;
			}
			if ((ecx_751 & 0x0FFF) != 0x00)
			{
				esp_744 -= ecx_751 & 0x0FFF;
				Mem768[esp_744 - 0x04 + (ecx_751 & 0x0FFF):word32] = Mem766[esp_744 - 0x04 + (ecx_751 & 0x0FFF):word32];
			}
			struct Eq_107532 * esp_773 = esp_744 - 0x04;
			esp_773->tFFFFFFFC = (word32) eax_737 + 1;
			esp_773->tFFFFFFF8 = ebp_277->dwFFFFFFC4;
			Mem789[esp_773 + -0x0C:word32] = esp_744 + 0x0F & ~0x0F;
			word32 edx_1159;
			word32 ecx_1158;
			Eq_2 eax_790 = memcpy(esp_773->tFFFFFFF4, esp_773->tFFFFFFF8, esp_773->tFFFFFFFC, out ecx_1158, out edx_1159);
			esp_773->tFFFFFFF4 = ebp_277->dwFFFFFFC4;
			ebp_277->dwFFFFFFE0 = (word32) eax_790;
			word32 ecx_1160;
			word32 edx_1161;
			free(gs, esp_773->tFFFFFFF0, esp_773->tFFFFFFF4, out ecx_1160, out edx_1161);
			ebp_277->dwFFFFFFC4 = ebp_277->dwFFFFFFE0;
			esp_225 = (struct Eq_106754 *) ((char *) &esp_773->tFFFFFFFC + 0x0C);
			goto l08088DE0;
		}
		goto l08088B26;
	}
	goto l08088AFF;
}

// subject_text_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080890B0: Register word32 open_path(Register word32 edx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out (ptr32 Eq_107650) ebxOut, Register out (ptr32 Eq_107651) ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      _dl_map_object
word32 open_path(word32 edx, struct Eq_9 * gs, word32 * dwArg04, struct Eq_107650 & ebxOut, struct Eq_107651 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	struct Eq_107654 * ebp_444 = fp - 4;
	struct Eq_107658 * ebx_115 = &g_t80CE000;
	struct Eq_107660 * esp_111 = fp - 0xCC;
	struct Eq_107715 ** eax_23 = *dwArg04;
	if (eax_23 != null)
	{
		ui32 eax_33 = edx + 0x1B + (g_dw80CE044 + max_dirnamelen);
		struct Eq_107660 * ecx_39 = fp - 0xCC - (eax_33 & ~0x0FFF);
		if (fp - 0xCC != ecx_39)
		{
			do
			{
				esp_111 -= 0x1000;
				esp_111->dw0FFC = esp_111->dw0FFC;
			} while (esp_111 != ecx_39);
		}
		if ((eax_33 & ~0x0F & 0x0FFF) != 0x00)
		{
			esp_111 -= eax_33 & ~0x0F & 0x0FFF;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(eax_33 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(eax_33 & ~0x0F & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_107715 * edi_105 = *eax_23;
		do
		{
			Eq_107872 eax_99 = *ebp_444->ptrFFFFFF74;
			ebp_444->dwFFFFFF7C = eax_99 & 0x01;
			if ((eax_99 & 0x01) != 0x00)
			{
				word32 eax_106 = edi_105->dw0004;
				ebp_444->dwFFFFFF54 = eax_106;
				if (eax_106 != ebp_444->ptrFFFFFF4C)
				{
					word32 eax_110 = edi_105[1];
					ebp_444->dwFFFFFF48 = esp_111;
					ebp_444->ptrFFFFFF4C = eax_110;
					word32 eax_117 = ebx_115->dwFFFFFFBC + ebx_115->dw1A44;
					struct Eq_107660 * ecx_121 = esp_111 - (eax_117 + 0x0F & ~0x0FFF);
					ui32 edx_122 = eax_117 + 0x0F & ~0x0F;
					while (esp_111 != ecx_121)
					{
						esp_111 -= 0x1000;
						esp_111->dw0FFC = esp_111->dw0FFC;
					}
					if ((edx_122 & 0x0FFF) != 0x00)
					{
						esp_111 -= edx_122 & 0x0FFF;
						(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(edx_122 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_111 - 0x04)[(edx_122 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
					}
					ebp_444->ptrFFFFFF78 = esp_111;
					esp_111->dwFFFFFFF0 = (char *) ebx_115 - 111910;
					word32 edx_1055;
					word32 ecx_1054;
					_dl_debug_printf(out ecx_1054, out edx_1055);
					struct Eq_108427 * eax_171 = *ebp_444->ptrFFFFFF60;
					if (eax_171 != null && ebp_444->dwFFFFFF54 == eax_171->dw0004)
					{
						ebp_444->dwFFFFFF44 = edi_105;
						struct Eq_108463 ** esi_183 = ebp_444->ptrFFFFFF60;
						ebp_444->dwFFFFFF5C = (char *) ebx_115 - 111929;
						struct Eq_108463 ** esi_185 = esi_183;
						do
						{
							struct Eq_108507 * esp_187 = esp_111 - 0x04;
							esp_187->tFFFFFFFC = eax_171->t0010;
							esp_187->tFFFFFFF8 = eax_171->t000C;
							esp_187->tFFFFFFF4 = ebp_444->ptrFFFFFF78;
							word32 edx_1056;
							ebp_444->dwFFFFFF70 = (word32) __mempcpy(esp_187->tFFFFFFF4, esp_187->tFFFFFFF8, esp_187->tFFFFFFFC, out edx_1056);
							if (ebx_115->dwFFFFFFC0 != 0x00)
							{
								ebp_444->ptrFFFFFF68 = (word32 Eq_9::*) ((char *) ebx_115 - 84938);
								uint32 edi_217 = 0x00;
								do
								{
									if (*((char *) *esi_185 + (edi_217 * 0x04 + 20)) != 0x01)
									{
										struct Eq_108555 * eax_232 = ebx_115->dwFFFFFFC4 + edi_217 * 0x08;
										struct Eq_108562 * esp_230 = esp_111 - 0x04;
										esp_230->tFFFFFFFC = eax_232->t0004;
										esp_230->tFFFFFFF8 = eax_232->t0000;
										esp_230->tFFFFFFF4 = ebp_444->dwFFFFFF70;
										word32 edx_1057;
										Eq_2 eax_243 = __mempcpy(esp_230->tFFFFFFF4, esp_230->tFFFFFFF8, esp_230->tFFFFFFFC, out edx_1057);
										Eq_2 edx_251 = ebp_444->ptrFFFFFF78;
										if (edx_251 == eax_243)
											*eax_243 = 0x00;
										else if (eax_243 != (word32) edx_251 + 1 || *edx_251 != 0x2F)
											*((word32) eax_243 - 1) = 0x00;
										else
											*eax_243 = 0x00;
										Eq_2 eax_270 = ebp_444->dwFFFFFF5C;
										if (ebp_444->dwFFFFFF7C != 0x00)
											eax_270 = ebp_444->ptrFFFFFF68;
										esp_230->tFFFFFFF8 = ebp_444->ptrFFFFFF78;
										esp_230->tFFFFFFF4 = eax_270;
										word32 edx_1058;
										_dl_debug_printf_c(out edx_1058);
										ebp_444->dwFFFFFF7C = 0x00;
									}
									++edi_217;
								} while (edi_217 < ebx_115->dwFFFFFFC0);
							}
							esi_185 = (struct Eq_108463 **) ((char *) esi_185 + 4);
							eax_171 = (struct Eq_108427 *) *esi_185;
						} while (eax_171 != null && ebp_444->dwFFFFFF54 == eax_171->dw0004);
						edi_105 = ebp_444->dwFFFFFF44;
					}
					if (ebp_444->ptrFFFFFF4C != 0x00)
					{
						if (*ebp_444->ptrFFFFFF4C == 0x00)
						{
							Eq_2 edx_365 = **(union Eq_2 **) 135060900;
							Eq_2 eax_366 = (char *) ebx_115 - 111925;
							if (edx_365 != 0x00)
								eax_366 = edx_365;
							ebp_444->ptrFFFFFF4C = (byte *) eax_366;
						}
						struct Eq_108679 * esp_376 = esp_111 - 0x04;
						esp_376->ptrFFFFFFFC = ebp_444->ptrFFFFFF4C;
						esp_376->dwFFFFFFF8 = ebp_444->dwFFFFFF54;
						esp_376->ptrFFFFFFF4 = (char *) ebx_115 - 111896;
						word32 edx_1060;
						_dl_debug_printf_c(out edx_1060);
					}
					else
					{
						struct Eq_108653 * esp_339 = esp_111 - 0x08;
						esp_339->dwFFFFFFFC = ebp_444->dwFFFFFF54;
						esp_339->ptrFFFFFFF8 = (char *) ebx_115 - 111875;
						word32 edx_1059;
						_dl_debug_printf_c(out edx_1059);
					}
					esp_111 = ebp_444->dwFFFFFF48;
					ebp_444->ptrFFFFFF4C = ebp_444->dwFFFFFF54;
				}
			}
			struct Eq_107730 * esp_407 = esp_111 - 0x04;
			esp_407->tFFFFFFFC = edi_105[2];
			esp_407->tFFFFFFF8 = edi_105->dw000C;
			esp_407->tFFFFFFF4 = ebp_444->dwFFFFFF84;
			word32 edx_1036;
			Eq_2 eax_427 = __mempcpy(esp_407->tFFFFFFF4, esp_407->tFFFFFFF8, esp_407->tFFFFFFFC, out edx_1036);
			ebp_444->dwFFFFFF7C = 0x00;
			ebp_444->dwFFFFFF70 = (word32) eax_427;
			uint32 esi_439 = 0x00;
l080891B8:
			uint32 eax_443 = ebx_115->dwFFFFFFC0;
			ebp_444->ptrFFFFFF68 = ~0x1F;
			for (; eax_443 > esi_439; ++esi_439)
			{
				if (edi_105->a0014[esi_439] != 0x01)
				{
					struct Eq_107790 * eax_459 = ebx_115->dwFFFFFFC4 + esi_439 * 0x08;
					struct Eq_107797 * esp_457 = esp_111 - 0x04;
					esp_457->tFFFFFFFC = eax_459->t0004;
					esp_457->tFFFFFFF8 = eax_459->t0000;
					esp_457->tFFFFFFF4 = ebp_444->dwFFFFFF70;
					word32 edx_1037;
					Eq_2 eax_470 = __mempcpy(esp_457->tFFFFFFF4, esp_457->tFFFFFFF8, esp_457->tFFFFFFFC, out edx_1037);
					esp_457->tFFFFFFFC = ebp_444->dwFFFFFF6C;
					esp_457->tFFFFFFF8 = ebp_444->dwFFFFFF64;
					esp_457->tFFFFFFF4 = eax_470;
					word32 edx_1038;
					ebp_444->ptrFFFFFF78 = __mempcpy(esp_457->tFFFFFFF4, esp_457->tFFFFFFF8, esp_457->tFFFFFFFC, out edx_1038) - ebp_444->dwFFFFFF84;
					if ((*ebp_444->ptrFFFFFF74 & 0x01) != 0x00)
					{
						esp_457->tFFFFFFF8 = ebp_444->dwFFFFFF84;
						esp_457->tFFFFFFF4 = (char *) ebx_115 - 111867;
						word32 ecx_1039;
						word32 edx_1040;
						_dl_debug_printf(out ecx_1039, out edx_1040);
					}
					struct Eq_107894 * esp_522 = esp_111 - 0x08;
					struct Eq_106593 * edx_526 = ebp_444[2];
					ui32 ecx_527 = ebp_444->dwFFFFFF80;
					esp_522->tFFFFFFFC.u0 = 0x00;
					Eq_2 eax_530 = ebp_444->dwFFFFFF84;
					esp_522->tFFFFFFF8 = ebp_444->dw001C;
					uint32 esi_541;
					Eq_2 eax_542 = open_verify.constprop.7(eax_530, ecx_527, edx_526, gs, esp_522->tFFFFFFF8, out ebx_115, out ebp_444, out esi_541, out edi_105);
					Eq_2 edx_548 = eax_542;
					uint32 eax_549 = edi_105->a0014[esi_541];
					if (eax_549 == 0x00)
					{
						if (eax_542 != ~0x00)
						{
							edi_105->a0014[esi_541] = 0x02;
							ebp_444->dwFFFFFF7C = 0x01;
							goto l0808926B;
						}
						if (ebp_444->ptr0014 != 0x00 && (*((char *) (*((char *) (&g_t80CEA00) + (ebp_444->ptr0014)->dw0018 * 0x4C)) + 0x0199) & 0x08) != 0x00)
							ebp_444->dwFFFFFF7C = 0x01;
						else
						{
							int32 ecx_578 = ebp_444->dwFFFFFF84;
							ebp_444->ptrFFFFFF78 + ecx_578 + ~ebp_444->dwFFFFFF6C = (byte *) 0x00;
							esp_111->dwFFFFFFF8 = ebp_444 - 0x78;
							esp_111->dwFFFFFFF4 = ecx_578;
							esp_111->dwFFFFFFF0 = 0x03;
							uint32 edx_602 = 0x01;
							if (__xstat64(gs, esp_111->dwFFFFFFF4, esp_111->dwFFFFFFF8) == 0x00)
							{
								ui32 eax_606 = ebp_444->dwFFFFFF98;
								edx_602 = (uint32) (int8) ((eax_606 & 0xF000) == 0x4000) + 0x01;
								ui32 eax_616 = 0x01;
								if ((eax_606 & 0xF000) != 0x4000)
									eax_616 = ebp_444->dwFFFFFF7C;
								ebp_444->dwFFFFFF7C = eax_616;
							}
							edi_105->a0014[esi_541] = edx_602;
						}
l080893F8:
						esi_439 = esi_541 + 0x01;
						goto l080891B8;
					}
					ebp_444->dwFFFFFF7C |= (word32) (int8) (eax_549 != 0x01);
					if (eax_542 == ~0x00)
						goto l080893F8;
l0808926B:
					if ((ebp_444->dwFFFFFF80 & 0x04000000) != 0x00)
					{
						if (*ebp_444->ptrFFFFFF50 != 0x00)
						{
							esp_522->t0000 = ebp_444 - 0x78;
							esp_522->tFFFFFFFC = eax_542;
							ebp_444->dwFFFFFF5C = (word32) eax_542;
							esp_522->tFFFFFFF8.u0 = 0x03;
							word32 ecx_1046;
							word32 edx_1047;
							Eq_2 eax_660 = __fxstat64(gs, esp_522->tFFFFFFFC, esp_522->t0000, out ecx_1046, out edx_1047);
							edx_548 = ebp_444->dwFFFFFF5C;
							if (eax_660 == 0x00 && (ebp_444->bFFFFFF99 & 0x08) != 0x00)
								goto l08089280;
							esp_111->dwFFFFFFF0 = (word32) edx_548;
							word32 edx_1048;
							__close_nocancel(gs, esp_111->dwFFFFFFF0, out edx_1048);
							gs->*ebp_444->ptrFFFFFF68 = 0x02;
							eax_443 = ebx_115->dwFFFFFFC0;
							esi_439 = esi_541;
							goto l08089340;
						}
l08089280:
						esi_439 = esi_541 + 0x01;
						if (edx_548 == ~0x00)
							goto l080891B8;
					}
					ebp_444->dwFFFFFF80 = (ui32) edx_548;
					struct Eq_107972 * esp_787 = esp_111 - 0x0C;
					esp_787->tFFFFFFFC = ebp_444->ptrFFFFFF78;
					word32 edi_1045;
					word32 ecx_1041;
					word32 edx_1042;
					word32 esi_1044;
					word32 ebx_1043;
					Eq_2 eax_798 = __libc_malloc(gs, esp_787->tFFFFFFF8, esp_787->tFFFFFFFC, out ecx_1041, out edx_1042, out ebx_1043, out ebp_444, out esi_1044, out edi_1045);
					word32 edx_811 = ebp_444->dwFFFFFF80;
					*ebp_444->ptr000C = (union Eq_2 *) eax_798;
					if (eax_798 == 0x00)
					{
						esp_111->dwFFFFFFF0 = edx_811;
						word32 edx_1049;
						__close_nocancel(gs, esp_111->dwFFFFFFF0, out edx_1049);
						goto l080892E1;
					}
					else
					{
						ebp_444->dwFFFFFF80 = edx_811;
						esp_111->dwFFFFFFF8 = ebp_444->ptrFFFFFF78;
						esp_111->dwFFFFFFF4 = ebp_444->dwFFFFFF84;
						esp_111->dwFFFFFFF0 = (word32) eax_798;
						word32 ecx_1050;
						word32 edx_1051;
						memcpy(esp_111->dwFFFFFFF0, esp_111->dwFFFFFFF4, esp_111->dwFFFFFFF8, out ecx_1050, out edx_1051);
						ptr32 esi_869 = ebp_444->dwFFFFFFF8;
						word32 eax_871 = ebp_444->dwFFFFFF80;
						ptr32 edi_872 = ebp_444->dwFFFFFFFC;
						struct Eq_107651 * ebp_874 = ebp_444->dw0000;
						ebxOut = ebp_444->dwFFFFFFF4;
						ebpOut = ebp_874;
						esiOut = esi_869;
						ediOut = edi_872;
						return eax_871;
					}
				}
l08089340:
			}
			if (ebp_444->dwFFFFFF7C != 0x00)
			{
				Eq_2 eax_717 = gs->tFFFFFFE0;
				if (eax_717 != 0x0D && eax_717 != 0x02)
					goto l080892E1;
			}
			ebp_444->ptrFFFFFF60 = (struct Eq_108427 **) ((char *) ebp_444->ptrFFFFFF60 + 4);
			struct Eq_107715 ** eax_726 = ebp_444->ptrFFFFFF60;
			ebp_444->dwFFFFFF58 |= ebp_444->dwFFFFFF7C;
			edi_105 = (struct Eq_107715 *) *eax_726;
		} while (edi_105 != null);
		if (ebp_444->dwFFFFFF58 == 0x00)
		{
			struct Eq_108306 * eax_739 = ebp_444[1];
			if (eax_739->dw0004 != 0x00)
			{
				esp_111->dwFFFFFFF0 = eax_739->dw0000;
				word32 edx_1053;
				word32 ecx_1052;
				free(gs, esp_111->dwFFFFFFEC, esp_111->dwFFFFFFF0, out ecx_1052, out edx_1053);
			}
			if (ebp_444[1] != ebx_115 - 0x38 && ebp_444[1] != ebx_115 - 0x4C)
			{
				*ebp_444[1].dw0000 = (struct Eq_107654) ~0x00;
l080892E6:
				struct Eq_108352 * esp_831 = ebp_444 - 0x0C;
				ptr32 esi_838 = esp_831->ptr0004;
				ptr32 edi_840 = esp_831->ptr0008;
				struct Eq_107651 * ebp_842 = esp_831->ptr000C;
				ebxOut = esp_831->ptr0000;
				ebpOut = ebp_842;
				esiOut = esi_838;
				ediOut = edi_840;
				return ~0x00;
			}
		}
	}
l080892E1:
	goto l080892E6;
}

// 08089720: Register Eq_2 _dl_map_object_from_fd.constprop.8(Register Eq_2 eax, Register (ptr32 Eq_108727) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack ui32 dwArg10, Stack Eq_2 dwArg18)
// Called from:
//      _dl_map_object
Eq_2 _dl_map_object_from_fd.constprop.8(Eq_2 eax, struct Eq_108727 * ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ui32 dwArg10, Eq_2 dwArg18)
{
	Eq_2 edi_1062;
	word32 esi_1047;
	Eq_2 eax_34 = _dl_debug_initialize(0x00, dwArg18);
	struct Eq_107003 * ebp_1051 = fp - 4;
	Eq_2 esp_1067 = fp - 0xEC;
	word32 ecx_2932;
	word32 edx_2933;
	if (__fxstat64(gs, edx, fp - 0x7C, out ecx_2932, out edx_2933) < 0x00)
	{
l08089F62:
		esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B4CB;
		ebp_1051->dwFFFFFF38 = (word32) gs->tFFFFFFE0;
		edi_1062.u0 = 0x00;
		goto l08089F7C;
	}
	Eq_2 edi_128;
	edi_1062 = *((char *) &g_t80CEA00 + dwArg18 * 0x4C);
	while (edi_1062 != 0x00)
	{
		if ((*((word32) edi_1062 + 0x0199) & 0x20) == 0x00 && ((*((word32) edi_1062 + 480) ^ dwLoc78 | *((word32) edi_1062 + 476) ^ dwLoc7C) == 0x00 && (*((word32) edi_1062 + 488) ^ dwLoc20 | dwLoc24 ^ *((word32) edi_1062 + 484)) == 0x00))
		{
			word32 edx_2934;
			__close_nocancel(gs, edx, out edx_2934);
			word32 edx_2936;
			word32 ecx_2935;
			free(gs, dwLoc0100, dwArg04, out ecx_2935, out edx_2936);
			word32 ebp_2937;
			add_name_to_object.isra.4(*((word32) edi_1062 + 28), eax, gs, out ebp_2937, out edi_128);
			return edi_128;
		}
		edi_1062 = *((word32) edi_1062 + 0x0C);
	}
	if ((dwArg10 & 0x04) != 0x00)
	{
		word32 ecx_2938;
		word32 edx_2939;
		free(gs, dwLoc0100, dwArg04, out ecx_2938, out edx_2939);
		word32 edx_2940;
		__close_nocancel(gs, edx, out edx_2940);
		edi_128.u0 = 0x00;
		return edi_128;
	}
	if ((_dl_debug_mask & 0x40) != 0x00)
	{
		word32 edx_2942;
		word32 ecx_2941;
		_dl_debug_printf(out ecx_2941, out edx_2942);
	}
	Eq_2 eax_186 = *((word32) eax_34 + 0x0C);
	if (eax_186 != 0x00)
	{
		if (eax_186 != 0x01)
		{
			word32 edx_2944;
			word32 ecx_2943;
			__assert_fail(out ecx_2943, out edx_2944);
			Eq_2 esp_211 = <invalid>;
			esp_1067 = (word32) esp_211 - 4;
			goto l0808A7AF;
		}
	}
	else
	{
		((word32) eax_34 + 0x0C)->u0 = 0x01;
		_dl_debug_state();
	}
	Eq_2 eax_245 = _dl_new_object(gs, dwArg04, eax, (byte) dwArg0C, (byte) dwArg10, dwArg18);
	esp_1067 = fp - 0xEC;
	edi_1062 = eax_245;
	if (eax_245 == 0x00)
	{
l0808A327:
		esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B2BF;
		goto l0808A330;
	}
	Eq_2 esi_331;
	Eq_2 edx_258 = ecx->t0020;
	*((word32) eax_245 + 344) = ecx->dw001C;
	ui32 eax_263 = (word32) ecx->w0030;
	((word32) eax_245 + 348)->u4 = (word16) eax_263;
	ui32 ebx_267 = eax_263 << 0x05;
	if ((word32) edx_258 + (eax_263 << 0x05) <= ecx->dw0000)
	{
		esi_331 = ecx + 0x04 + edx_258;
		goto l080898F1;
	}
	ui32 eax_271 = (eax_263 << 0x05) + 0x1B;
	Eq_2 esi_275 = fp - 0xEC - (eax_271 & 0x003FF000);
	if (fp - 0xEC != esi_275)
	{
		do
		{
			esp_1067 -= 0x1000;
			*((word32) esp_1067 + 0x0FFC) = *((word32) esp_1067 + 0x0FFC);
		} while (esp_1067 != esi_275);
	}
	int32 ecx_291 = eax_271 & 0x003FFFF0 & 0x0FFF;
	if (ecx_291 != 0x00)
	{
		esp_1067 -= ecx_291;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1067 - 0x04)[ecx_291 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1067 - 0x04)[ecx_291 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	struct Eq_109077 * esp_304 = esp_1067 - 0x04;
	esp_304->tFFFFFFFC.u0 = 0x00;
	esp_304->tFFFFFFF8 = edx_258;
	esp_304->tFFFFFFF4 = edx;
	Eq_2 ebx_327;
	word32 ecx_2945;
	__libc_lseek(gs, esp_304->tFFFFFFF4, esp_304->tFFFFFFF8, esp_304->tFFFFFFFC, out ecx_2945, out ebx_327, out ebp_1051, out esi_331, out edi_1062);
	Eq_2 esp_332 = <invalid>;
	*((word32) esp_332 + 8) = ebx_327;
	*((word32) esp_332 + 4) = esi_331;
	*esp_332 = ebp_1051->dwFFFFFF78;
	esp_1067 = (word32) esp_332 + 16;
	word32 ecx_2946;
	if (__read_nocancel(gs, *esp_332, *((word32) esp_332 + 4), *((word32) esp_332 + 8), out ecx_2946) == ebx_327)
	{
		eax_263 = (word32) *((word32) edi_1062 + 348);
		ebx_267 = eax_263 << 0x05;
l080898F1:
		ebp_1051->dwFFFFFF30 = (word32) esp_1067;
		ui32 eax_371 = eax_263 * 0x18 + 0x0F;
		Eq_2 ecx_374 = esp_1067 - (eax_371 & 0x003FF000);
		while (esp_1067 != ecx_374)
		{
			esp_1067 -= 0x1000;
			*((word32) esp_1067 + 0x0FFC) = *((word32) esp_1067 + 0x0FFC);
		}
		int32 edx_390 = eax_371 & 0x003FFFF0 & 0x0FFF;
		if (edx_390 != 0x00)
		{
			esp_1067 -= edx_390;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1067 - 0x04)[edx_390 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1067 - 0x04)[edx_390 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		Eq_108997 eax_402 = (word32) esp_1067 + 3;
		ebp_1051->dwFFFFFF20 = eax_402 >> 0x02;
		ebp_1051->ptrFFFFFF58 = __align(eax_402, 4);
		if (esi_331 >= (word32) esi_331 + ebx_267)
		{
l0808A480:
			esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B213;
			goto l08089F2B;
		}
		ebp_1051->dwFFFFFF84 = (ui32) esi_331;
		ebp_1051->dwFFFFFF44 = 0x07;
		ebp_1051->bFFFFFF3C = 0x00;
		ebp_1051->dwFFFFFF7C = 0x00;
		ebp_1051->ptrFFFFFF24 = 0x080CFEC0;
		ebp_1051->ptrFFFFFF40 = 0x080CE9B0;
		Eq_2 ebx_422 = esi_331;
		Eq_2 esi_428 = edi_1062;
		do
		{
			up32 eax_438 = *ebx_422;
			if (eax_438 != 0x06)
			{
				if (eax_438 > 0x06)
				{
					if (eax_438 != 1685382481)
					{
						if (eax_438 != 1685382482)
						{
							if (eax_438 == 0x07)
							{
								word32 eax_599 = *((word32) ebx_422 + 20);
								if (eax_599 != 0x00)
								{
									*((word32) esi_428 + 568) = eax_599;
									ui32 eax_604 = *((word32) ebx_422 + 28);
									*((word32) esi_428 + 572) = eax_604;
									ui32 ecx_606 = *((word32) ebx_422 + 8);
									ui32 edx_608 = eax_604 - 0x01 & ecx_606;
									if (eax_604 != 0x00)
										eax_604 = edx_608;
									*((word32) esi_428 + 576) = eax_604;
									word32 eax_617 = *((word32) ebx_422 + 16);
									*((word32) esi_428 + 560) = ecx_606;
									*((word32) esi_428 + 564) = eax_617;
									if ((byte) ((word32) *((word32) esi_428 + 408) & 0x03) != 0x01 && *ebp_1051->ptrFFFFFF24 == 0x00)
									{
										word32 esi_632 = ebp_1051->dwFFFFFF80;
										struct Eq_109293 * esp_635 = esp_1067 - 4;
										esp_635->dw0000 = esi_632 + ~0x0001AEEF;
										esp_635->dwFFFFFFFC = 0x0484;
										esp_635->dwFFFFFFF8 = esi_632 + 4294855192;
										esp_635->dwFFFFFFF4 = esi_632 + ~0x0001B0EB;
										word32 ecx_2947;
										word32 edx_2948;
										__assert_fail(out ecx_2947, out edx_2948);
										Eq_2 esp_647 = <invalid>;
										esp_1067 = (word32) esp_647 - 4;
										goto l0808A327;
									}
									*((word32) esi_428 + 584) = _dl_next_tls_modid();
								}
							}
						}
						else
						{
							*((word32) esi_428 + 592) = *((word32) ebx_422 + 8);
							*((word32) esi_428 + 596) = *((word32) ebx_422 + 20);
						}
					}
					else
						ebp_1051->dwFFFFFF44 = (ui32) *((word32) ebx_422 + 24);
				}
				else if (eax_438 != 0x02)
				{
					if (eax_438 != 0x04)
					{
						if (eax_438 == 0x01)
						{
							ui32 edi_492 = *((word32) ebx_422 + 28);
							ui32 edx_493 = *ebp_1051->ptrFFFFFF40;
							ebp_1051->dwFFFFFF64 = edx_493;
							ebp_1051->dwFFFFFF54 = edx_493 - 0x01;
							if ((edx_493 - 0x01 & edi_492) != 0x00)
							{
								edi_1062 = esi_428;
								esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B1C7;
								goto l08089F2B;
							}
							uint32 ecx_503 = *((word32) ebx_422 + 8);
							ui32 eax_504 = *((word32) ebx_422 + 4);
							ebp_1051->dwFFFFFF74 = eax_504;
							if ((ecx_503 - eax_504 & edi_492 - 0x01) != 0x00)
							{
								edi_1062 = esi_428;
								esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B19B;
								goto l08089F2B;
							}
							up32 edx_516 = *((word32) ebx_422 + 16);
							if (ebp_1051->dwFFFFFFB8 - (ebp_1051->dwFFFFFFB4 < ebp_1051->dwFFFFFF74 + edx_516) < 0x00)
							{
								edi_1062 = esi_428;
								esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B1EB;
								goto l08089F2B;
							}
							ui32 edi_530 = ebp_1051->dwFFFFFF7C;
							ebp_1051->dwFFFFFF68 = edi_530 + 0x01;
							ebp_1051->dwFFFFFF64 = -ebp_1051->dwFFFFFF64;
							struct Eq_109749 * edx_540 = ebp_1051->ptrFFFFFF58 + (edi_530 * 0x18) / 20;
							uint32 edi_541 = ebp_1051->dwFFFFFF64;
							edx_540->dw0008 = edx_516 + ecx_503;
							ui32 eax_545 = ebp_1051->dwFFFFFF54 + edx_540->dw0008;
							uint32 ecx_546 = (word32) *((word32) ebx_422 + 20) + ecx_503;
							edx_540->dw0000 = edi_541 & ecx_503;
							edi_1062 = ebp_1051->dwFFFFFF64;
							edx_540->dw000C = ecx_546;
							edx_540->dw0004 = eax_545 & edi_1062;
							edx_540->dw0010 = ebp_1051->dwFFFFFF74 & edi_1062;
							if (ebp_1051->dwFFFFFF68 > 0x01)
							{
								byte cl_563 = ebp_1051->bFFFFFF3C;
								if (edx_540->dwFFFFFFEC != edx_540->dw0000)
									cl_563 = 0x01;
								ebp_1051->bFFFFFF3C = cl_563;
							}
							ebp_1051->ptrFFFFFF58->a0014[ebp_1051->dwFFFFFF7C].dw0000 = 1934713408 >> (byte) ((*((word32) ebx_422 + 24) & 0x07) << 0x02) & 0x0F;
							ebp_1051->dwFFFFFF7C = ebp_1051->dwFFFFFF68;
						}
					}
					else
					{
						struct Eq_109568 * esp_461 = esp_1067 - 0x0C;
						esp_461->ptrFFFFFFFC = (up32 *) ebp_1051->ptrFFFFFF6C;
						if (_dl_process_pt_note(esi_428, ebp_1051->dwFFFFFF78, ebx_422, gs, esp_461->ptrFFFFFFFC, out ebx_422, out ebp_1051, out esi_428, out edi_1062) != 0x00)
						{
							edi_1062 = esi_428;
							esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B4B1;
							goto l08089F2B;
						}
					}
				}
				else if (*((word32) ebx_422 + 16) != 0x00)
				{
					*((word32) esi_428 + 8) = *((word32) ebx_422 + 8);
					((word32) esi_428 + 350)->u4 = (word16) (*((word32) ebx_422 + 20) >> 0x03);
				}
			}
			else
				*((word32) esi_428 + 340) = *((word32) ebx_422 + 8);
			Eq_2 esp_1006 = esp_1067;
			ebx_422 = (word32) ebx_422 + 32;
		} while (ebx_422 < ((word32) (*((word32) esi_428 + 348)) << 0x05) + ebp_1051->dwFFFFFF84);
		edi_1062 = esi_428;
		if (ebp_1051->dwFFFFFF7C == 0x00)
			goto l0808A480;
		Eq_2 edx_1037;
		Eq_109335 ecx_1005;
		word32 eax_686 = (word32) ebp_1051->ptrFFFFFF2C;
		ebp_1051->dwFFFFFF68 = eax_686;
		if (eax_686 != 0x03)
		{
			if ((ebp_1051->dw0014 & 0x20000000) != 0x00)
			{
				ui32 eax_695 = ebp_1051->dwFFFFFF7C;
				Eq_109335 ebx_696 = ebp_1051->ptrFFFFFF58;
				Eq_2 ecx_698 = *((word32) ebx_696 + (((eax_695 - 0x03) + eax_695 * 0x02) * 0x08 + 0x0C));
				word32 edx_700 = null[ebp_1051->dwFFFFFF20];
				ebp_1051->dwFFFFFF74 = ecx_698 - edx_700;
				up32 eax_704 = *esi_428;
				*((word32) esi_428 + 436) = (word32) ecx_698 + eax_704;
				word32 eax_709 = (word32) ebp_1051->bFFFFFF3C;
				*((word32) esi_428 + 432) = edx_700 + eax_704;
				ui32 eax_712 = (eax_709 ^ 0x01) & 0x01;
				*((word32) esi_428 + 0x0199) = (byte) ((word32) *((word32) esi_428 + 0x0199) & ~0x40 | eax_712 << 0x06);
				ecx_1005 = ebx_696;
				edx_1037 = eax_712 << 0x06;
l08089E20:
				Eq_2 ebx_1056 = ebp_1051->ptrFFFFFF58;
				edi_1062 = esi_428;
				if (ecx_1005 < (word32) ebx_1056 + ebp_1051->dwFFFFFF7C * 0x18)
				{
					up32 edx_2008 = *((word32) ecx_1005 + 4);
					up32 eax_2009 = *ecx_1005;
					ebp_1051->dwFFFFFF84 = (ui32) *((word32) ecx_1005 + 20);
					if (edx_2008 > eax_2009)
					{
						struct Eq_109996 * esp_2015 = esp_1006 - 0x08;
						esp_2015->tFFFFFFFC = *((word32) ecx_1005 + 16);
						ebp_1051->dwFFFFFF64 = (up32) ecx_1005;
						esp_2015->tFFFFFFF8 = ebp_1051->dwFFFFFF78;
						esp_2015->tFFFFFFF4.u0 = 2066;
						esp_2015->dwFFFFFFF0 = ebp_1051->dwFFFFFF84;
						esp_2015->tFFFFFFEC = edx_2008 - eax_2009;
						esp_2015->tFFFFFFE8 = (word32) *esi_428 + eax_2009;
						word32 ecx_2956;
						word32 edx_2957;
						Eq_2 eax_2035 = mmap(gs, esp_2015->tFFFFFFE8, esp_2015->tFFFFFFEC, esp_2015->dwFFFFFFF0, esp_2015->tFFFFFFF4, esp_2015->tFFFFFFF8, esp_2015->tFFFFFFFC, out ecx_2956, out edx_2957);
						esp_1006 = (char *) &esp_2015->tFFFFFFFC + 0x0C;
						ecx_1005 = ebp_1051->dwFFFFFF64;
						if (eax_2035 == ~0x00)
						{
l08089E84:
							edi_1062 = esi_428;
							esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B13F;
							goto l08089F2B;
						}
					}
					goto l08089D5C;
				}
				byte al_1353;
				word32 eax_1066 = *((word32) esi_428 + 8);
				esp_1067 = ebp_1051->dwFFFFFF30;
				if (eax_1066 != 0x00)
				{
					ecx_1005 = *esi_428;
					ebp_1051->dwFFFFFF84 = (ui32) ecx_1005;
					edx_1037 = (word32) ecx_1005 + eax_1066;
					*((word32) esi_428 + 8) = edx_1037;
					if (edx_1037 != 0x00)
					{
						Eq_2 eax_1085 = *edx_1037;
						while (eax_1085 == 0x00)
						{
							if (ebp_1051->dwFFFFFF84 != 0x00)
							{
								struct Eq_110186 * eax_1097 = *((word32) esi_428 + 48);
								if (eax_1097 != null)
									eax_1097->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110192 * eax_1107 = *((word32) esi_428 + 44);
								if (eax_1107 != null)
									eax_1107->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110278 * eax_1118 = *((word32) esi_428 + 52);
								if (eax_1118 != null)
									eax_1118->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110383 * eax_1129 = *((word32) esi_428 + 56);
								if (eax_1129 != null)
									eax_1129->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110415 * eax_1140 = *((word32) esi_428 + 60);
								if (eax_1140 != null)
									eax_1140->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110431 * eax_1151 = *((word32) esi_428 + 100);
								if (eax_1151 != null)
									eax_1151->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110504 * eax_1162 = *((word32) esi_428 + 0x007C);
								if (eax_1162 != null)
									eax_1162->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_110742 * eax_1173 = *((word32) esi_428 + 232);
								if (eax_1173 != null)
									eax_1173->dw0004 += ebp_1051->dwFFFFFF84;
								struct Eq_111118 * eax_1184 = *((word32) esi_428 + 336);
								if (eax_1184 != null)
									eax_1184->dw0004 += ebp_1051->dwFFFFFF84;
							}
							struct Eq_110180 * eax_1195 = *((word32) esi_428 + 112);
							if (eax_1195 == null)
							{
l0808A0D3:
								ebx_1056 = *((word32) esi_428 + 60);
								if (ebx_1056 != 0x00 && *((word32) (*((word32) esi_428 + 0x0044)) + 4) != 0x0C)
								{
									word32 esi_1215 = ebp_1051->dwFFFFFF80;
									struct Eq_110464 * esp_1228 = esp_1067 - 4;
									esp_1228->dw0000 = esi_1215 + ~0x0002962B;
									esp_1228->dwFFFFFFFC = 131;
									esp_1228->dwFFFFFFF8 = esi_1215 + ~0x000297B6;
									esp_1228->dwFFFFFFF4 = esi_1215 + ~0x000296CF;
									word32 edx_2964;
									word32 ecx_2963;
									__assert_fail(out ecx_2963, out edx_2964);
									Eq_2 esp_1240 = <invalid>;
									esp_1067 = (word32) esp_1240 - 4;
								}
								ecx_1005 = *((word32) esi_428 + 100);
								if (ecx_1005 != 0x00 && *((word32) (*((word32) esi_428 + 0x006C)) + 4) != 0x08)
								{
									word32 esi_1257 = ebp_1051->dwFFFFFF80;
									struct Eq_110711 * esp_1260 = esp_1067 - 4;
									esp_1260->dw0000 = esi_1257 + ~0x0002962B;
									esp_1260->dwFFFFFFFC = 0x87;
									esp_1260->dwFFFFFFF8 = esi_1257 + ~0x000297B6;
									esp_1260->dwFFFFFFF4 = esi_1257 + ~0x0002969B;
									word32 ecx_2972;
									word32 edx_2973;
									__assert_fail(out ecx_2972, out edx_2973);
									Eq_2 esp_1272 = <invalid>;
									esp_1067 = (word32) esp_1272 - 4;
								}
								struct Eq_110693 * edx_1281 = *((word32) esi_428 + 0x0098);
								if (edx_1281 != null)
								{
									word32 eax_1285 = edx_1281->dw0004;
									*((word32) esi_428 + 524) = eax_1285;
									byte al_1287 = (byte) eax_1285;
									if ((al_1287 & 0x02) != 0x00)
										*((word32) esi_428 + 96) = edx_1281;
									if ((al_1287 & 0x04) != 0x00)
										*((word32) esi_428 + 0x0078) = edx_1281;
									if ((al_1287 & 0x08) != 0x00)
										*((word32) esi_428 + 0x0080) = edx_1281;
								}
								struct Eq_111134 * eax_1310 = *((word32) esi_428 + 188);
								if (eax_1310 != null)
								{
									Eq_111229 eax_1315 = eax_1310->t0004;
									ecx_1005 = ebp_1051->dwFFFFFF28;
									*((word32) esi_428 + 520) = eax_1315;
									al_1353 = (byte) eax_1315;
									if ((*ecx_1005 & 0x40) != 0x00 && (eax_1315 & ~0x08E9) != 0x00)
									{
										word32 eax_1330 = ebp_1051->dwFFFFFF80;
										struct Eq_111287 * esp_1335 = esp_1067 - 0x08;
										esp_1335->dwFFFFFFFC = eax_1315 & ~0x08E9;
										esp_1335->dwFFFFFFF8 = eax_1330 + 4294797720;
										word32 edx_2984;
										_dl_debug_printf(out ecx_1005, out edx_2984);
										al_1353 = (byte) *((word32) esi_428 + 520);
									}
									if ((al_1353 & 0x01) != 0x00)
										*((word32) esi_428 + 0x0080) = *((word32) esi_428 + 188);
								}
								else
									al_1353 = (byte) *((word32) esi_428 + 520);
								edx_1037 = *((word32) esi_428 + 0x0094);
								if (edx_1037 != 0x00)
									*((word32) esi_428 + 92) = 0x00;
								goto l0808A1B2;
							}
							word32 eax_1199 = eax_1195->dw0004;
							if (eax_1199 == 0x11 || eax_1199 == 0x07)
								goto l0808A0D3;
							word32 esi_1938 = ebp_1051->dwFFFFFF80;
							struct Eq_110317 * esp_1940 = esp_1067 - 4;
							esp_1940->dw0000 = esi_1938 + ~0x0002962B;
							esp_1940->dwFFFFFFFC = 0x7E;
							esp_1940->dwFFFFFFF8 = esi_1938 + ~0x000297B6;
							esp_1940->dwFFFFFFF4 = esi_1938 + ~0x0002971F;
							Eq_2 esp_1952 = <invalid>;
							word32 ecx_2962;
							eax_1085 = __assert_fail(out ecx_2962, out edx_1037);
							esp_1067 = (word32) esp_1952 - 4;
l0808A090:
							eax_1085 = 0x70000022 - eax_1085;
l0808A099:
							*((word32) esi_428 + (eax_1085 * 0x04 + 32)) = edx_1037;
l0808A09C:
							edx_1037 = (word32) edx_1037 + 8;
							eax_1085 = *edx_1037;
						}
						if (eax_1085 > 0x22)
						{
							if (0x6FFFFFFF - eax_1085 > 0x0F)
							{
								int32 ecx_1982 = eax_1085 * 0x02;
								if (ecx_1982 >> 0x01 > ~0x03)
									*((word32) esi_428 + (~(ecx_1982 >> 0x01) * 0x04 + 0x00EC)) = edx_1037;
								else if (0x6FFFFDFF - eax_1085 > 11)
								{
									if (0x6FFFFEFF - eax_1085 <= 0x0A)
										*((word32) esi_428 + (-eax_1085 * 0x04 - 0x400002DC)) = edx_1037;
								}
								else
									*((word32) esi_428 + (-eax_1085 * 0x04 - 0x4000070C)) = edx_1037;
								goto l0808A09C;
							}
							goto l0808A090;
						}
						goto l0808A099;
					}
				}
				else if (ebp_1051->dwFFFFFF68 == 0x03)
				{
					esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B297;
					goto l08089F31;
				}
				al_1353 = (byte) *((word32) esi_428 + 520);
l0808A1B2:
				edi_1062 = esi_428;
				if ((al_1353 & 0x40) != 0x00 && ebp_1051->dw0014 < 0x00)
				{
					Eq_2 edx_1387 = *((word32) esi_428 + 432);
					struct Eq_110535 * esp_1392 = esp_1067 - 4;
					esp_1392->t0000 = ebx_1056;
					esp_1392->tFFFFFFFC = ebx_1056;
					esp_1392->tFFFFFFF8 = *((word32) esi_428 + 436) - edx_1387;
					esp_1392->tFFFFFFF4 = edx_1387;
					word32 ecx_2965;
					word32 edx_2966;
					word32 ebx_2967;
					__munmap(ebx_1056, gs, esp_1392->tFFFFFFF4, esp_1392->tFFFFFFF8, out ecx_2965, out edx_2966, out ebx_2967);
					Eq_2 eax_1443 = *((word32) esi_428 + 28);
					esp_1067 = (char *) &esp_1392->t0000 + 8;
					if (*((word32) eax_1443 + 8) == 0x00)
					{
						esp_1392->tFFFFFFF8 = eax_1443;
						word32 ecx_2974;
						word32 edx_2975;
						free(gs, esp_1392->tFFFFFFF4, esp_1392->tFFFFFFF8, out ecx_2974, out edx_2975);
						esp_1067 = (char *) &esp_1392->t0000 + 0x0C;
					}
					esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B273;
					if (*((word32) esi_428 + 408) < 0x00)
					{
						struct Eq_110785 * esp_1470 = esp_1067 - 0x0C;
						esp_1470->tFFFFFFFC = *((word32) esi_428 + 340);
						word32 ecx_2976;
						word32 edx_2977;
						free(gs, esp_1470->tFFFFFFF8, esp_1470->tFFFFFFFC, out ecx_2976, out edx_2977);
						esp_1067 = (char *) &esp_1470->tFFFFFFFC + 20;
					}
l08089F31:
					if (ebp_1051->bFFFFFF37 == 0x00)
					{
l08089F7C:
						ebp_1051->dwFFFFFF60 = 0x00;
						goto l08089F3A;
					}
l08089F3A:
					struct Eq_108788 * esp_2058 = esp_1067 - 0x0C;
					esp_2058->dwFFFFFFFC = ebp_1051->dw001C;
					word32 ecx_2065 = ebp_1051->dwFFFFFF5C;
					Eq_2 edx_2066 = ebp_1051->dwFFFFFF78;
					esp_2058->dwFFFFFFF8 = ebp_1051->dwFFFFFF60;
					Eq_2 eax_2070 = ebp_1051->dwFFFFFF38;
					esp_2058->dwFFFFFFF4 = esi_1047;
					esp_2058->tFFFFFFF0 = edi_1062;
					esp_2058->dwFFFFFFEC = ebp_1051->dw0008;
					ebp_1051 = lose(eax_2070, ecx_2065, edx_2066, gs, esp_2058->tFFFFFFF0);
					esp_1067.u0 = <invalid>;
					goto l08089F62;
				}
				word32 eax_1489 = *((word32) esi_428 + 340);
				if (eax_1489 != 0x00)
					*((word32) esi_428 + 340) = (word32) *esi_428 + eax_1489;
				else
				{
					struct Eq_110579 * esp_1496 = esp_1067 - 0x0C;
					ui32 eax_1498 = (word32) ebp_1051->ptrFFFFFF6C->w0030;
					esp_1496->tFFFFFFFC = eax_1498 << 0x05;
					ebp_1051->dwFFFFFF84 = eax_1498 << 0x05;
					Eq_2 esi_1511;
					word32 ebx_2970;
					word32 ecx_2968;
					word32 edx_2969;
					Eq_2 eax_1505 = __libc_malloc(gs, esp_1496->tFFFFFFF8, esp_1496->tFFFFFFFC, out ecx_2968, out edx_2969, out ebx_2970, out ebp_1051, out esi_1511, out edi_1062);
					esp_1067 = (char *) &esp_1496->t0004 + 8;
					if (eax_1505 == 0x00)
					{
						esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B2EB;
						goto l0808A330;
					}
					esp_1496->t0004 = ebp_1051->dwFFFFFF84;
					esp_1496->t0000 = esi_1511;
					esp_1496->tFFFFFFFC = eax_1505;
					Eq_2 eax_1532 = memcpy(esp_1496->tFFFFFFFC, esp_1496->t0000, esp_1496->t0004, out ecx_1005, out edx_1037);
					*((word32) edi_1062 + 408) |= 0x80;
					*((word32) edi_1062 + 340) = eax_1532;
				}
				if (((byte) (~_dl_stack_flags & ebp_1051->dwFFFFFF44) & 0x01) != 0x00)
				{
					struct Eq_110629 * eax_1560 = ebp_1051->dwFFFFFF80;
					eax_1560->dwFFFFFFD0 |= 0x07;
					struct Eq_110641 * esp_1562 = esp_1067 - 0x0C;
					esp_1562->dwFFFFFFFC = ebp_1051->dw0018;
					word32 eax_1670;
					_dl_make_stack_executable_hook();
					ebp_1051->dwFFFFFF38 = eax_1670;
					esp_1067 = &esp_1562->dwFFFFFFFC + 4;
					if (eax_1670 != 0x00)
					{
						esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B24F;
						goto l08089F31;
					}
				}
				word32 eax_1681 = *((word32) edi_1062 + 560);
				if (eax_1681 != 0x00)
					*((word32) edi_1062 + 560) = (word32) *edi_1062 + eax_1681;
				struct Eq_110666 * esp_1690 = esp_1067 - 0x0C;
				esp_1690->tFFFFFFFC = ebp_1051->dwFFFFFF78;
				esp_1067 = &esp_1690->dw0008 + 1;
				word32 edx_2971;
				if (__close_nocancel(gs, esp_1690->tFFFFFFFC, out edx_2971) == 0x00)
				{
					if (ebp_1051->dwFFFFFF68 != 0x02 || (*((word32) edi_1062 + 408) & 0x03) == 0x00)
					{
						up32 eax_1755 = *edi_1062;
						byte * esi_1757 = ebp_1051->dwFFFFFF28;
						word32 edx_1758 = (word32) *((word32) edi_1062 + 344) + eax_1755;
						*((word32) edi_1062 + 344) = edx_1758;
						if ((*esi_1757 & 0x40) != 0x00)
						{
							esp_1690->tFFFFFFFC = (word32) *((word32) edi_1062 + 348);
							esp_1690->dwFFFFFFF8 = 0x08;
							esp_1690->dwFFFFFFF4 = (word32) *((word32) edi_1062 + 340);
							esp_1690->dwFFFFFFF0 = 0x08;
							esp_1690->dwFFFFFFEC = edx_1758;
							esp_1690->dwFFFFFFE8 = 0x08;
							esp_1690->dwFFFFFFE4 = ebp_1051->dwFFFFFF74;
							esp_1690->dwFFFFFFE0 = 0x08;
							esp_1690->dwFFFFFFDC = eax_1755;
							word32 eax_1787 = ebp_1051->dwFFFFFF80;
							esp_1690->dwFFFFFFD8 = 0x08;
							esp_1690->dwFFFFFFD4 = (word32) *((word32) edi_1062 + 8);
							esp_1690->dwFFFFFFD0 = 0x08;
							esp_1690->dwFFFFFFCC = eax_1787 + ~0x0001B083;
							word32 ecx_2978;
							word32 edx_2979;
							_dl_debug_printf(out ecx_2978, out edx_2979);
						}
						struct Eq_110918 * esp_1809 = esp_1067 - 0x0C;
						esp_1809->tFFFFFFFC = edi_1062;
						word32 esi_2980;
						struct Eq_110925 * ebp_1818;
						_dl_setup_hash(esp_1809->tFFFFFFFC, esp_1809->t0000, out ebp_1818, out esi_2980, out edi_128);
						if ((ebp_1818->b0014 & 0x08) == 0x00 && *((word64) edi_128.u0 + 96) != 0x00)
						{
							Eq_2 eax_1833 = *((word64) edi_128.u0 + 464);
							if (*eax_1833 != (word64) edi_128.u0 + 352)
							{
								**((word64) edi_128.u0 + 360) = edi_128;
								Eq_2 edx_1840 = *((word64) edi_128.u0 + 0x01CC);
								*((word64) edi_128.u0 + 364) = 0x01;
								esp_1809->t0004 = edx_1840 * 0x04 + ~0x03;
								esp_1809->t0000 = eax_1833;
								esp_1809->tFFFFFFFC = (word32) eax_1833 + 4;
								word32 edx_2981;
								memmove(esp_1809->tFFFFFFFC, esp_1809->t0000, esp_1809->t0004, out edx_2981);
								**((word64) edi_128.u0 + 464) = (word64) edi_128.u0 + 360;
							}
						}
						if ((*((word64) edi_128.u0 + 520) & 0x20) != 0x00)
							_dl_initfirst = edi_128;
						*((word64) edi_128.u0 + 476) = ebp_1818->dwFFFFFF50;
						*((word64) edi_128.u0 + 480) = ebp_1818->dwFFFFFF4C;
						*((word64) edi_128.u0 + 484) = ebp_1818->dwFFFFFF70;
						*((word64) edi_128.u0 + 488) = ebp_1818->dwFFFFFF48;
						if (_dl_profile != 0x00)
						{
							Eq_2 eax_1890 = *((word64) edi_128.u0 + 88);
							if (eax_1890 != 0x00)
								add_name_to_object.isra.4(*((word64) edi_128.u0 + 28), Mem1883[eax_1890 + 0x04:word32] + Mem1883[Mem1883[edi_128 + 0x34:word32] + 0x04:word32], gs, out ebp_1818, out edi_128);
						}
						struct Eq_111002 * esp_1919 = esp_1067 - 0x08;
						esp_1919->tFFFFFFFC = ebp_1818->t001C;
						esp_1919->tFFFFFFF8 = edi_128;
						_dl_add_to_namespace_list(esp_1919->tFFFFFFF8, esp_1919->tFFFFFFFC);
						return edi_128;
					}
					word32 esi_1727 = ebp_1051->dwFFFFFF80;
					esp_1690->dw0008 = esi_1727 + ~0x0001AEEF;
					esp_1690->dw0004 = 1322;
					esp_1690->dw0000 = esi_1727 + 4294855192;
					esp_1690->tFFFFFFFC = esi_1727 + ~0x0001B0B3;
					word32 ecx_2982;
					word32 edx_2983;
					__assert_fail(out ecx_2982, out edx_2983);
					goto l0808A480;
				}
				esi_1047 = ebp_1051->dwFFFFFF80 + 4294855447;
l0808A330:
				ebp_1051->dwFFFFFF38 = (word32) gs->tFFFFFFE0;
				goto l08089F31;
			}
			esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B3EF;
l08089F2B:
			esp_1067 = ebp_1051->dwFFFFFF30;
			goto l08089F31;
		}
		ui32 ecx_723 = ebp_1051->dwFFFFFF20;
		ui32 eax_722 = ebp_1051->dwFFFFFF7C;
		ui32 ebx_731 = null[ecx_723];
		ui32 edx_733 = ((ui32[]) 0x14)[ecx_723];
		Eq_2 eax_734 = ebp_1051->ptrFFFFFF58->a000C[(eax_722 - 0x03 + eax_722 * 0x02) * 2] - ebx_731;
		ebp_1051->dwFFFFFF84 = edx_733;
		ebp_1051->dwFFFFFF74 = (uint32) eax_734;
		struct Eq_109392 * esp_728 = esp_1067 - 0x08;
		esp_728->tFFFFFFFC = ((Eq_2[]) 0x10)[ecx_723];
		esp_728->tFFFFFFF8 = ebp_1051->dwFFFFFF78;
		esp_728->tFFFFFFF4.u0 = 0x0802;
		esp_728->dwFFFFFFF0 = edx_733;
		esp_728->tFFFFFFEC = eax_734;
		esp_728->tFFFFFFE8 = _dl_use_load_bias & ebx_731;
		word32 ecx_2949;
		word32 edx_2950;
		Eq_2 eax_762 = mmap(gs, esp_728->tFFFFFFE8, esp_728->tFFFFFFEC, esp_728->dwFFFFFFF0, esp_728->tFFFFFFF4, esp_728->tFFFFFFF8, esp_728->tFFFFFFFC, out ecx_2949, out edx_2950);
		*((word32) esi_428 + 432) = eax_762;
		esp_1006 = (char *) &esp_728->t0000 + 8;
		if (eax_762 == ~0x00)
			goto l08089E84;
		*((word32) esi_428 + 436) = (word32) eax_762 + ebp_1051->dwFFFFFF74;
		word32 eax_775 = eax_762 - ebx_731;
		*esi_428 = eax_775;
		if (ebp_1051->bFFFFFF3C != 0x00)
		{
			ui32 ebx_780 = ebp_1051->dwFFFFFF7C;
			struct Eq_109493 * ebx_784 = ebp_1051->ptrFFFFFF58;
			word32 ecx_785 = ((word32[]) 0x04)[ebp_1051->dwFFFFFF20];
			esp_728->t0000.u0 = 0x00;
			esp_728->tFFFFFFFC = (ebx_784 - 0x18)[ebx_780].dw0000 - ecx_785;
			esp_728->tFFFFFFF8 = eax_775 + ecx_785;
			esp_1006 = (char *) &esp_728->t0000 + 0x0C;
			word32 ecx_2951;
			word32 edx_2952;
			if (mprotect(gs, esp_728->tFFFFFFF8, esp_728->tFFFFFFFC, esp_728->t0000, out ecx_2951, out edx_2952) < 0x00)
				goto l0808A550;
		}
		*((word32) esi_428 + 0x0199) |= 0x40;
		ecx_1005 = ebp_1051->ptrFFFFFF58;
l08089D5C:
		edi_1062 = esi_428;
		if ((ebp_1051->dwFFFFFF84 & 0x04) != 0x00)
			Mem826[esi_428 + 440:word32] = Mem817[ecx_1005 + 0x04:word32] + Mem817[esi_428 + 0x00:word32];
		if (*((word32) esi_428 + 340) == 0x00)
		{
			up32 eax_836 = *((word32) ecx_1005 + 16);
			up32 ebx_837 = ebp_1051->ptrFFFFFF6C->dw0020;
			if (eax_836 <= ebx_837)
			{
				up32 edx_840 = *ecx_1005;
				ebp_1051->dwFFFFFF54 = eax_836;
				ebp_1051->dwFFFFFF64 = edx_840;
				if ((word32) *((word32) ecx_1005 + 4) + eax_836 - ebp_1051->dwFFFFFF64 >= ((word32) (ebp_1051->ptrFFFFFF6C)->w0030 << 0x05) + ebx_837)
					*((word32) esi_428 + 340) = ebp_1051->dwFFFFFF64 + ebx_837 - ebp_1051->dwFFFFFF54;
			}
		}
		Eq_2 eax_861 = *((word32) ecx_1005 + 0x0C);
		edx_1037 = *((word32) ecx_1005 + 8);
		if (eax_861 <= edx_1037)
		{
l08089E1D:
			ecx_1005 = (word32) ecx_1005 + 24;
			goto l08089E20;
		}
		Eq_109639 ebx_866 = *esi_428;
		Mem871[ebp_1051 + -0x009C:word32] = eax_861 + ebx_866;
		Eq_2 eax_873 = _dl_pagesize;
		ebp_1051->ptrFFFFFF2C = (union Eq_2 *) 0x080CE9B0;
		ebp_1051->ptrFFFFFF40 = (ui32 *) eax_873;
		Eq_109657 eax_876 = -eax_873;
		ebp_1051->bFFFFFF3C = (byte) eax_876;
		edx_1037 += ebx_866;
		Eq_2 eax_881 = ebp_1051->ptrFFFFFF40 + (edx_1037 - 0x01) & eax_876;
		Eq_2 ebx_883 = eax_881;
		if (ebp_1051->dwFFFFFF64 <= eax_881)
			ebx_883 = ebp_1051->dwFFFFFF64;
		ebp_1051->dwFFFFFF54 = (up32) ebx_883;
		if (edx_1037 >= ebx_883)
		{
l08089E0B:
			if (ebp_1051->dwFFFFFF64 <= ebp_1051->dwFFFFFF54)
				goto l08089E1D;
			ebp_1051->ptrFFFFFF40 = (ui32 *) ecx_1005;
			up32 eax_1015 = ebp_1051->dwFFFFFF64;
			struct Eq_110215 * esp_1017 = esp_1006 - 0x08;
			Eq_2 ecx_1018 = ebp_1051->dwFFFFFF54;
			esp_1017->tFFFFFFFC.u0 = 0x00;
			esp_1017->tFFFFFFF8.u0 = ~0x00;
			esp_1017->tFFFFFFF4.u0 = 0x32;
			esp_1017->dwFFFFFFF0 = ebp_1051->dwFFFFFF84;
			esp_1017->tFFFFFFEC = eax_1015 - ecx_1018;
			esp_1017->tFFFFFFE8 = ecx_1018;
			word32 ecx_2961;
			Eq_2 eax_1035 = mmap(gs, esp_1017->tFFFFFFE8, esp_1017->tFFFFFFEC, esp_1017->dwFFFFFFF0, esp_1017->tFFFFFFF4, esp_1017->tFFFFFFF8, esp_1017->tFFFFFFFC, out ecx_2961, out edx_1037);
			esp_1006 = (char *) &esp_1017->tFFFFFFFC + 0x0C;
			ecx_1005 = ebp_1051->ptrFFFFFF40;
			if (eax_1035 == ~0x00)
			{
				esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B495;
				goto l08089F2B;
			}
			goto l08089E1D;
		}
		if ((ebp_1051->dwFFFFFF84 & 0x02) != 0x00)
		{
			up32 eax_985 = ebp_1051->dwFFFFFF54;
			ebp_1051->ptrFFFFFF40 = (ui32 *) ecx_1005;
			struct Eq_109931 * esp_986 = esp_1006 - 0x04;
			esp_986->tFFFFFFFC = eax_985 - edx_1037;
			esp_986->tFFFFFFF8.u0 = 0x00;
			esp_986->tFFFFFFF4 = edx_1037;
			word32 ecx_2955;
			memset(esp_986->tFFFFFFF4, esp_986->tFFFFFFF8, esp_986->tFFFFFFFC, out ecx_2955, out edx_1037);
			ecx_1005 = ebp_1051->ptrFFFFFF40;
			esp_1006 = (char *) &esp_986->tFFFFFFFC + 8;
			goto l08089E0B;
		}
		ui32 eax_895 = ebp_1051->dwFFFFFF84;
		ebp_1051->ptrFFFFFF24 = (word32 *) ecx_1005;
		struct Eq_109873 * esp_900 = esp_1006 - 0x04;
		esp_900->tFFFFFFFC = eax_895 | 0x02;
		Eq_109881 eax_906 = ebp_1051->bFFFFFF3C;
		esp_900->tFFFFFFF8 = ebp_1051->ptrFFFFFF40;
		ebp_1051->ptrFFFFFF40 = (ui32 *) edx_1037;
		esp_900->tFFFFFFF4 = eax_906 & edx_1037;
		word32 ecx_2953;
		word32 edx_2954;
		Eq_2 eax_920 = mprotect(gs, esp_900->tFFFFFFF4, esp_900->tFFFFFFF8, esp_900->tFFFFFFFC, out ecx_2953, out edx_2954);
		Eq_2 edx_929 = ebp_1051->ptrFFFFFF40;
		Eq_109918 ecx_930 = ebp_1051->ptrFFFFFF24;
		if (eax_920 >= 0x00)
		{
			uint32 eax_938 = ebp_1051->dwFFFFFF54;
			ebp_1051->bFFFFFF3C = (byte) ecx_930;
			esp_900->t0000 = eax_938 - edx_929;
			esp_900->tFFFFFFFC.u0 = 0x00;
			esp_900->tFFFFFFF8 = edx_929;
			ebp_1051->ptrFFFFFF40 = (ui32 *) edx_929;
			word32 ecx_2958;
			word32 edx_2959;
			memset(esp_900->tFFFFFFF8, esp_900->tFFFFFFFC, esp_900->t0000, out ecx_2958, out edx_2959);
			ui32 * edx_961 = ebp_1051->ptrFFFFFF40;
			Eq_2 eax_962 = *ebp_1051->ptrFFFFFF2C;
			esp_900->t0000 = ebp_1051->dwFFFFFF84;
			esp_900->tFFFFFFFC = eax_962;
			esp_900->tFFFFFFF8 = -eax_962 & edx_961;
			word32 ecx_2960;
			mprotect(gs, esp_900->tFFFFFFF8, esp_900->tFFFFFFFC, esp_900->t0000, out ecx_2960, out edx_1037);
			esp_1006 = (char *) &esp_900->t0000 + 0x0C;
			ecx_1005.u0 = ebp_1051->bFFFFFF3C;
			goto l08089E0B;
		}
l0808A550:
		edi_1062 = esi_428;
		esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B163;
		goto l08089F2B;
	}
l0808A7AF:
	esi_1047 = ebp_1051->dwFFFFFF80 + ~0x0001B5C0;
	goto l0808A330;
}

// 0808A7E0: Register Eq_2 add_path.isra.3.constprop.9(Register Eq_2 eax, Register (ptr32 word32) edx)
// Called from:
//      _dl_rtld_di_serinfo
Eq_2 add_path.isra.3.constprop.9(Eq_2 eax, word32 * edx)
{
	if (edx != (word32 *) ~0x00)
	{
		word32 * edi_23 = edx;
		struct Eq_111457 * edx_100 = *edx;
		do
		{
			eax = edx_100->t0010;
			++edi_23;
			struct Eq_111466 * ecx_32 = *((word32) eax + 8);
			word24 eax_24_8_87 = SLICE(eax, word24, 8);
			if (*eax != 0x00)
			{
				edx_100 = *edi_23;
				++ecx_32->dw0004;
				if (eax < 0x02)
					eax.u0 = 0x02;
				ecx_32->dw0000 = (word32) eax + ecx_32->dw0000;
				if (edx_100 != null)
					continue;
				return eax;
			}
			ui32 ebp_52 = *((word32) eax + 4);
			*((word32) eax + 4) = ebp_52 + 0x01;
			struct Eq_111499 * ebp_54 = ecx_32 + ebp_52;
			Eq_2 ebx_56 = *((word32) eax + 0x0C);
			ebp_54->t0008 = ebx_56;
			if (eax <= 0x01)
			{
				*((word32) eax + 0x0C) = (word32) ebx_56 + 1;
				*ebx_56 = (byte) (SEQ(eax_24_8_87, (int8) (eax != 0x00)) + 0x2E);
				eax = *((word32) eax + 0x0C);
			}
			else
			{
				word32 edx_166;
				eax = __mempcpy(ebx_56, edx_100->t000C, eax - 0x01, out edx_166);
			}
			*((word64) eax.u0 + 0x0C) = (word64) eax.u0 + 1;
			*eax.u0 = 0x00;
			edx_100 = *edi_23;
			ebp_54->dw000C = 0x00;
		} while (edx_100 != null);
	}
	return eax;
}

// 0808A8A0: Register word32 _dl_dst_count(Stack Eq_2 dwArg04)
// Called from:
//      expand_dynamic_string_token
//      _dl_map_object_deps
word32 _dl_dst_count(Eq_2 dwArg04)
{
	word32 ebx_113 = 0x00;
	word32 ecx_168;
	word32 edx_169;
	Eq_2 eax_26 = strchr(dwArg04, 0x24, out ecx_168, out edx_169);
	while (eax_26 != 0x00)
	{
		Eq_2 ebp_42 = (word32) eax_26 + 1;
		word32 ecx_174;
		int32 eax_46 = is_dst(ebp_42, 0x080B2B9A, out ecx_174);
		if (eax_46 == 0x00)
		{
			word32 ecx_170;
			eax_46 = is_dst(ebp_42, 134949793, out ecx_170);
			if (eax_46 != 0x00)
				goto l0808A920;
			word32 ecx_171;
			eax_46 = is_dst(ebp_42, 0x080B2BAA, out ecx_171);
			if (eax_46 != 0x00)
				goto l0808A920;
		}
		else
		{
l0808A920:
			++ebx_113;
			ebp_42 = (word32) ebp_42 + eax_46;
		}
		word32 edx_173;
		word32 ecx_172;
		eax_26 = strchr(ebp_42, 0x24, out ecx_172, out edx_173);
	}
	return ebx_113;
}

// 0808A940: Register Eq_2 _dl_dst_substitute(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_111622) ecxOut)
// Called from:
//      expand_dynamic_string_token
//      _dl_map_object_deps
Eq_2 _dl_dst_substitute(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_111622 & ecxOut)
{
	struct Eq_111622 * ebp_126 = null;
	Eq_2 edi_159 = dwArg0C;
	Eq_2 esi_162 = dwArg08;
	byte al_164 = *dwArg08;
	struct Eq_111622 * ecx_125 = (struct Eq_111622 *) 0x080CDDAC;
	do
	{
		esi_162 = (word32) esi_162 + 1;
		if (al_164 != 0x24)
		{
			*edi_159 = al_164;
			edi_159 = (word32) edi_159 + 1;
			goto l0808A985;
		}
		ptr32 dwLoc28_231;
		Eq_2 eax_116;
		int32 eax_41 = is_dst(esi_162, 0x080B2B9A, out ecx_125);
		int32 edx_138 = eax_41;
		if (eax_41 != 0x00)
		{
			if (*(union Eq_4933 *) 0x080CDDAC == 0x00)
			{
				eax_116 = *((word32) dwArg04 + 428);
				ebp_126 = null;
				ecx_125 = eax_116 - 0x01;
				dwLoc28_231 = eax_116 - 0x01;
			}
			else
			{
				if (esi_162 != (word32) dwArg08 + 1)
					goto l0808AA7E;
				byte al_107 = *((word32) esi_162 + eax_41);
				if (al_107 != 0x00 && al_107 != 0x2F)
					goto l0808AA7E;
				eax_116 = *((word32) dwArg04 + 428);
				ecx_125 = SEQ(SLICE(dwArg04, word24, 8), (int8) ((*((word32) dwArg04 + 408) & 0x03) == 0x00));
				dwLoc28_231 = eax_116 - 0x01;
				ebp_126 = ecx_125;
			}
			goto l0808A9C7;
		}
		word32 ecx_322;
		int32 eax_54 = is_dst(esi_162, 134949793, out ecx_322);
		edx_138 = eax_54;
		if (eax_54 == 0x00)
		{
			int32 eax_73 = is_dst(esi_162, 0x080B2BAA, out ecx_125);
			edx_138 = eax_73;
			if (eax_73 != 0x00)
			{
				eax_116.u0 = 0x080B2BAE;
				ecx_125 = (struct Eq_111622 *) &g_t80B2BAF;
				dwLoc28_231 = 0x080B2BAF;
				goto l0808A9C7;
			}
			*edi_159 = 0x24;
			edi_159 = (word32) edi_159 + 1;
l0808A985:
			al_164 = (byte) *esi_162;
			if (al_164 != 0x00)
				continue;
			break;
		}
		eax_116 = _dl_platform;
		ecx_125 = eax_116 - 0x01;
		dwLoc28_231 = eax_116 - 0x01;
l0808A9C7:
		if (dwLoc28_231 > ~0x02)
			goto l0808AA7E;
		edi_159 = __stpcpy(edi_159, eax_116, out ecx_125);
		esi_162 = (word32) esi_162 + edx_138;
		al_164 = (byte) *esi_162;
	} while (al_164 != 0x00);
	if ((byte) ebp_126 == 0x00 || (byte) ((uint32) is_trusted_path_normalize(dwArg0C, edi_159 - dwArg0C, out ecx_125)) != 0x00)
		*edi_159 = 0x00;
	else
	{
l0808AA7E:
		*dwArg0C = 0x00;
	}
	ecxOut = ecx_125;
	return dwArg0C;
}

// 0808AAD0: Register Eq_2 expand_dynamic_string_token(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ebpOut, Register out Eq_2 esiOut)
// Called from:
//      fillin_rpath
//      _dl_map_object
Eq_2 expand_dynamic_string_token(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ebpOut, union Eq_2 & esiOut)
{
	Eq_2 eax_166;
	Eq_2 eax_26 = _dl_dst_count(edx);
	if (eax_26 == 0x00)
	{
		eax_166 = strdup(edx);
		goto l0808AAFF;
	}
	Eq_2 eax_106;
	word32 ecx_306;
	word32 edx_307;
	Eq_2 edx_109 = strlen(edx, out ecx_306, out edx_307);
	Eq_2 edi_139 = eax_26;
	struct Eq_111774 * esp_110 = fp - 44;
	Eq_2 eax_115 = *((word32) eax + 428);
	if (eax_115 != 0x00)
	{
		if (eax_115 != ~0x00)
			goto l0808AB37;
	}
	else
	{
		if (**((word32) eax + 4) != 0x00)
		{
			Eq_2 edx_71;
			word32 ecx_310;
			__assert_fail(out ecx_310, out edx_71);
			Eq_2 eax_80 = fillin_rpath(ecx, edx_71, gs);
			ebpOut = eax;
			esiOut = edx;
			return eax_80;
		}
		word32 ebx_311;
		word32 esi_312;
		eax_115 = _dl_get_origin(gs, dwLoc2C, out ebx_311, out esi_312, out edi_139);
		*((word32) eax + 428) = eax_115;
		esp_110 = fp - 0x28;
		edx_109 = dwLoc1C;
		if (eax_115 <= ~0x01)
		{
l0808AB37:
			esp_110->t000C = edx_109;
			struct Eq_111800 * esp_112 = esp_110 - 0x0C;
			esp_112->tFFFFFFFC = eax_115;
			word32 edx_309;
			word32 ecx_308;
			eax_106 = strlen(esp_112->tFFFFFFFC, out ecx_308, out edx_309);
			esp_110 = (struct Eq_111774 *) ((char *) &esp_112->tFFFFFFFC + 16);
			edx_109 = esp_112->t0018;
l0808AB4B:
			if (_dl_platformlen >= eax_106)
				eax_106 = _dl_platformlen;
			if (eax_106 > 0x04)
				esp_110->dw0008 = (word32) edx_109 + edi_139 *s (eax_106 - 0x04);
			struct Eq_111849 * esp_153 = esp_110 - 0x0C;
			esp_153->tFFFFFFFC = esp_153->dw0014 + 0x01;
			Eq_2 ebp_167;
			Eq_2 esi_172;
			word32 edi_316;
			word32 ecx_313;
			word32 ebx_315;
			word32 edx_314;
			eax_166 = __libc_malloc(gs, esp_153->tFFFFFFF8, esp_153->tFFFFFFFC, out ecx_313, out edx_314, out ebx_315, out ebp_167, out esi_172, out edi_316);
			if (eax_166 != 0x00)
			{
				esp_153->t0004 = eax_166;
				esp_153->t0000 = esi_172;
				esp_153->tFFFFFFFC = ebp_167;
				word32 ecx_317;
				eax_166 = _dl_dst_substitute(esp_153->tFFFFFFFC, esp_153->t0000, esp_153->t0004, out ecx_317);
			}
l0808AAFF:
			ebpOut = ebp;
			esiOut = esi;
			return eax_166;
		}
	}
	eax_106.u0 = 0x00;
	goto l0808AB4B;
}

// 0808ABF0: Register Eq_2 fillin_rpath(Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      expand_dynamic_string_token
//      cache_rpath.part.6
//      _dl_init_paths
Eq_2 fillin_rpath(Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	struct Eq_111923 * ebx_17 = &g_t80CE000;
	while (true)
	{
		Eq_2 eax_42 = __strsep_g(fp - 0x20, ecx);
		struct Eq_111965 * esp_103 = fp - 0x4C;
		Eq_2 edi_150 = eax_42;
		if (eax_42 == 0x00)
			break;
		Eq_2 esi_145;
		struct Eq_111930 * esp_187;
		Eq_2 ebp_163;
		Eq_2 eax_157;
		Eq_2 edx_125;
		if (*eax_42 == 0x00)
		{
			esi_145.u0 = 0x00;
			eax_157 = _dl_all_dirs;
			if (eax_157 != 0x00)
				goto l0808ACCA;
			esi_145.u0 = 0x00;
			goto l0808AD68;
		}
		word32 ebp_725;
		word32 esi_726;
		Eq_2 eax_84 = expand_dynamic_string_token(dwArg0C, eax_42, gs, out ebp_725, out esi_726);
		edi_150 = eax_84;
		if (eax_84 == 0x00)
			continue;
		word32 edx_728;
		word32 ecx_727;
		Eq_2 eax_96 = strlen(eax_84, out ecx_727, out edx_728);
		esp_103 = fp - 0x4C;
		if (eax_96 != 0x00)
		{
			if (eax_96 != 0x01)
			{
				edx_125 = eax_96 - 0x01;
				if (*((word32) eax_96 + (eax_84 - 0x01)) != 0x2F)
				{
					edx_125 = eax_96;
					while (true)
					{
l0808AE78:
						Mem151[edi_150 + edx_125:byte] = 0x2F;
						esp_103->dw0000 = (word32) edi_150;
						esi_145 = (word64) edx_125.u0 + 1;
l0808ACB8:
						eax_157 = *esp_103[2].dw0000;
						esp_103->dw0014 = (word32) eax_157;
						if (eax_157 != 0x00)
						{
l0808ACCA:
							ebp_163 = eax_157;
							do
							{
								if (*((word32) ebp_163 + 16) == esi_145)
								{
									struct Eq_112178 * esp_170 = esp_103 - 0x04;
									esp_170->tFFFFFFFC = esi_145;
									esp_170->tFFFFFFF8 = *((word32) ebp_163 + 0x0C);
									esp_170->tFFFFFFF4 = edi_150;
									word32 edx_738;
									word32 ecx_737;
									Eq_2 eax_180 = memcmp(esp_170->tFFFFFFF4, esp_170->tFFFFFFF8, esp_170->tFFFFFFFC, out ecx_737, out edx_738);
									esp_187 = (struct Eq_111930 *) ((char *) &esp_170->tFFFFFFFC + 8);
									if (eax_180 == 0x00)
									{
										Eq_2 edx_392 = esp_170->t0010;
										if (edx_392 == 0x00)
											goto l0808AD1C;
										Eq_2 ecx_396[] = esp_170->ptr001C;
										if (ebp_163 != ecx_396[0])
										{
											do
											{
												eax_180 = (word32) eax_180 + 1;
												if (edx_392 == eax_180)
													goto l0808AD1C;
											} while (ecx_396[eax_180] != ebp_163);
										}
										goto l0808AD2E;
									}
								}
								ebp_163 = *ebp_163;
							} while (ebp_163 != 0x00);
						}
l0808AD68:
						if (esp_103->dw0054 != 0x00)
						{
							struct Eq_112048 * esp_205 = esp_103 - 0x0C;
							esp_205->tFFFFFFFC = esp_205->t0060;
							word32 ecx_731;
							word32 edx_732;
							esp_205->dw0028 = (word32) strlen(esp_205->tFFFFFFFC, out ecx_731, out edx_732) + 1;
						}
						else
							esp_103->dw001C = 0x00;
						ui32 edx_231 = ebx_17->dwFFFFFFC0;
						struct Eq_112073 * esp_233 = esp_103 - 0x0C;
						esp_233->dw0030 = edx_231;
						ui32 ecx_234 = edx_231 * 0x04 + 0x14;
						esp_233->dw002C = ecx_234;
						esp_233->dw0034 = ecx_234 + 0x01;
						esp_233->tFFFFFFFC = (word32) esp_233->t0028 + ((word32) esi_145 + (ecx_234 + 0x01));
						Eq_2 edi_261;
						Eq_2 esi_263;
						word32 ebp_745;
						word32 ecx_743;
						word32 edx_744;
						Eq_2 eax_257 = __libc_malloc(gs, esp_233->tFFFFFFF8, esp_233->tFFFFFFFC, out ecx_743, out edx_744, out ebx_17, out ebp_745, out esi_263, out edi_261);
						ui32 ecx_269 = esp_233->dw002C;
						ui32 edx_270 = esp_233->dw0030;
						ebp_163 = eax_257;
						if (eax_257 != 0x00)
						{
							esp_233->dw002C = edx_270;
							Eq_2 ecx_298 = (word32) eax_257 + ecx_269;
							*((word32) eax_257 + 0x0C) = ecx_298;
							esp_233->t0004 = esi_263;
							esp_233->t0000 = edi_261;
							esp_233->tFFFFFFFC = ecx_298;
							word32 edx_736;
							Eq_2 eax_308 = __mempcpy(esp_233->tFFFFFFFC, esp_233->t0000, esp_233->t0004, out edx_736);
							ui32 edx_318 = esp_233->dw002C;
							*eax_308 = 0x00;
							*((word32) eax_257 + 16) = esi_263;
							if (ebx_17->t1A44 < esi_263)
								ebx_17->t1A44 = esi_263;
							ui32 eax_329 = 0x00;
							uint32 ecx_331 = (uint32) (int8) (*edi_261 != 0x2F);
							if (edx_318 != 0x00)
							{
								do
								{
									*((word32) eax_257 + (eax_329 * 0x04 + 20)) = ecx_331 * 0x02;
									++eax_329;
								} while (edx_318 != eax_329);
							}
							Eq_2 edx_352 = esp_233->t0060;
							*((word32) eax_257 + 4) = esp_233->dw005C;
							if (edx_352 != 0x00)
							{
								Eq_2 esi_364 = (word32) eax_257 + ((word32) esi_263 + esp_233->dw0034);
								esp_233->t0004 = esp_233->t0028;
								esp_233->t0000 = esp_233->t0060;
								esp_233->tFFFFFFFC = esi_364;
								word32 ecx_741;
								word32 edx_742;
								*((word32) eax_257 + 8) = memcpy(esp_233->tFFFFFFFC, esp_233->t0000, esp_233->t0004, out ecx_741, out edx_742);
							}
							else
								((word32) eax_257 + 8)->u0 = 0x00;
							*eax_257 = esp_233->dw0020;
							*esp_233->ptr001C = (union Eq_2 *) eax_257;
							esp_187 = (struct Eq_111930 *) ((char *) &esp_233->t0008 + 4);
l0808AD1C:
							ui32 eax_412 = esp_187->dw000C;
							esp_187->ptr0018[eax_412] = ebp_163;
							esp_187->dw000C = eax_412 + 0x01;
l0808AD2E:
							struct Eq_112245 * esp_420 = esp_187 - 0x0C;
							esp_420->tFFFFFFFC = esp_420->t000C;
							word32 edx_740;
							word32 ecx_739;
							free(gs, esp_420->tFFFFFFF8, esp_420->tFFFFFFFC, out ecx_739, out edx_740);
							continue;
						}
						esp_233->t0008 = (char *) ebx_17 - 0x0001AFF8;
						esp_233->t0004.u0 = 0x00;
						esp_233->t0000.u0 = 0x00;
						esp_233->tFFFFFFFC.u0 = 0x0C;
						word32 ebp_735;
						word32 ecx_733;
						word32 edx_734;
						_dl_signal_error(gs, esp_233->tFFFFFFFC, esp_233->t0008, out ecx_733, out edx_734, out ebx_17, out ebp_735, out edi_150);
						esp_103 = (struct Eq_111965 *) &esp_233->tFFFFFFF8;
l0808AEC6:
						edx_125.u0 = 0x01;
					}
				}
				while (edx_125 != 0x01)
				{
					Eq_2 eax_133 = edx_125 - 0x01;
					if (Mem95[eax_84 - 0x01 + edx_125:byte] != 0x2F)
						goto l0808AE78;
					edx_125 = eax_133;
				}
			}
			if (*eax_84 != 0x2F)
				goto l0808AEC6;
			esi_145.u0 = 0x01;
			goto l0808ACB8;
		}
		word32 edx_730;
		word32 ecx_729;
		free(gs, dwLoc60, eax_84, out ecx_729, out edx_730);
	}
	*edx = 0x00;
	return edx;
}

// 0808AED0: Register Eq_2 cache_rpath.part.6(Register Eq_2 eax, Register ui32 ecx, Register (ptr32 word32) edx, Register (ptr32 Eq_9) gs, Register out Eq_112410 ebxOut, Register out Eq_112410 ebpOut, Register out Eq_112410 esiOut, Register out Eq_112410 ediOut)
// Called from:
//      _dl_map_object
//      _dl_rtld_di_serinfo
Eq_2 cache_rpath.part.6(Eq_2 eax, ui32 ecx, word32 * edx, struct Eq_9 * gs, union Eq_112410 & ebxOut, union Eq_112410 & ebpOut, union Eq_112410 & esiOut, union Eq_112410 & ediOut)
{
	ptr32 ebx_19 = 0x080CE000;
	Eq_2 eax_22 = *((word32) eax + (ecx * 0x04 + 32));
	if (eax_22 == 0x00)
	{
		*edx = (struct Eq_107715 **) ~0x00;
		ebxOut = ebx;
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return eax_22;
	}
	word32 eax_40 = Mem17[eax_22 + 0x04:word32] + Mem17[Mem17[eax + 0x34:word32] + 0x04:word32];
	byte * eax_42 = *((word32) eax + 4);
	byte * ecx_100 = _dl_inhibit_rpath;
	if (ecx_100 != null && *((union Eq_4933 *) 0x080CDDAC) == 0x00)
	{
		byte al_111 = *ecx_100;
		word32 edi_61 = (word32) *eax_42;
		do
		{
			byte dl_65 = (byte) edi_61;
			if (dl_65 == al_111)
			{
				if (dl_65 == 0x00)
					goto l0808B090;
				byte * esi_74 = eax_42;
				do
				{
					++ecx_100;
					++esi_74;
					al_111 = *ecx_100;
					dl_65 = *esi_74;
					if (al_111 != dl_65)
						goto l0808B044;
				} while (al_111 != 0x00);
				goto l0808B080;
			}
l0808B044:
			if (dl_65 == 0x00)
			{
l0808B080:
				if (al_111 == 0x00 || al_111 == 0x3A)
				{
l0808B090:
					goto l0808AF1C;
				}
			}
			do
			{
				byte al_103 = *ecx_100;
				if (al_103 == 0x00)
					goto l0808B05E;
				++ecx_100;
			} while (al_103 != 0x3A);
			al_111 = *ecx_100;
		} while (al_111 != 0x00);
l0808B05E:
	}
	if (*eax_40 == 0x00)
	{
l0808AF1C:
		*edx = (struct Eq_107715 **) ~0x00;
		goto l0808AF24;
	}
	Eq_2 eax_237;
	Eq_2 eax_149 = strdup(eax_40);
	ptr32 esp_158 = fp - 44;
	if (eax_149 != 0x00)
	{
		Eq_2 eax_168;
		byte al_164 = *eax_149;
		if (al_164 != 0x00)
		{
			Eq_2 edx_169 = eax_149;
			ui32 ecx_170 = 0x00;
			do
			{
				edx_169 = (word32) edx_169 + 1;
				ecx_170 += (word32) (int8) (al_164 == 0x3A);
				al_164 = (byte) *edx_169;
			} while (al_164 != 0x00);
			eax_168 = ecx_170 * 0x04 + 0x08;
		}
		else
			eax_168.u0 = 0x08;
		word32 ebp_559;
		word32 edx_558;
		word32 ebx_209;
		Eq_2 edi_211;
		struct Eq_112540 * esi_213;
		word32 ecx_557;
		Eq_2 eax_207 = __libc_malloc(gs, dwLoc40, eax_168, out ecx_557, out edx_558, out ebx_209, out ebp_559, out esi_213, out edi_211);
		if (eax_207 != 0x00)
		{
			fillin_rpath(ebx_209 + ~0x00014A8A, eax_207, gs);
			word32 ecx_549;
			word32 edx_550;
			free(gs, dwLoc40, edi_211, out ecx_549, out edx_550);
			if (*eax_207 != 0x00)
			{
				esi_213->t0000 = eax_207;
				esi_213->dw0004 = 0x01;
				ebxOut = esi;
				ebpOut = dwArg00;
				esiOut = edi;
				ediOut = ebp;
				return 0x01;
			}
			word32 edx_552;
			word32 ecx_551;
			free(gs, edi_211, eax_207, out ecx_551, out edx_552);
			esi_213->t0000.u0 = ~0x00;
l0808AF24:
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return 0x00;
		}
		word32 ecx_547;
		word32 edx_548;
		free(gs, dwLoc40, edi_211, out ecx_547, out edx_548);
		esp_158 = fp - 0x28;
		eax_237 = ebx_209 + ~0x0001AFF7;
l0808B0DB:
		struct Eq_112579 * esp_239 = esp_158 - 4;
		esp_239->t0000 = eax_237;
		esp_239->dwFFFFFFFC = 0x00;
		esp_239->dwFFFFFFF8 = 0x00;
		esp_239->tFFFFFFF4.u0 = 0x0C;
		word32 ebp_555;
		word32 edi_556;
		word32 ecx_553;
		word32 edx_554;
		_dl_signal_error(gs, esp_239->tFFFFFFF4, esp_239->t0000, out ecx_553, out edx_554, out ebx_19, out ebp_555, out edi_556);
		esp_158 = esp_239 - 0x10;
	}
	eax_237 = ebx_19 + ~0x0001AFD3;
	goto l0808B0DB;
}

// 0808B0F0: Register word32 _dl_init_paths(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_non_dynamic_init
word32 _dl_init_paths(struct Eq_9 * gs)
{
	Eq_2 eax_305;
	struct Eq_112655 * ebx_38;
	word32 eax_36 = _dl_important_hwcaps(gs, _dl_platform, _dl_platformlen, &_IO_list_all, out ebx_38);
	Eq_2 esp_44 = <invalid>;
	esp_44->u0 = 0x0C;
	ebx_38->dwFFFFFFC4 = eax_36;
	struct Eq_112679 * ebp_52;
	word32 ecx_474;
	word32 edx_475;
	word32 esi_476;
	word32 edi_477;
	struct Eq_112684 * ebx_319;
	Eq_2 eax_51 = __libc_malloc(gs, *((word32) esp_44 - 4), *esp_44, out ecx_474, out edx_475, out ebx_319, out ebp_52, out esi_476, out edi_477);
	ebx_319->tFFFFFFB4 = eax_51;
	ptr32 esp_299 = (word32) esp_44 + 16;
	if (eax_51 != 0x00)
	{
		uint32 edx_73 = SLICE((ebx_319->tFFFFFFC0 * 0x04 + 0x27) *64 ~0x33333332, word32, 32);
		uint32 edx_76 = (edx_73 >> 0x04) + (edx_73 >> 0x04) * 0x04;
		ebp_52->dwFFFFFFE4 = edx_76;
		*esp_44 = edx_76 * 0x08;
		struct Eq_112736 * ebp_82;
		struct Eq_112737 * edi_85;
		ui32 esi_87;
		word32 edx_479;
		word32 ecx_478;
		struct Eq_112741 * ebx_290;
		Eq_2 eax_81 = __libc_malloc(gs, *((word32) esp_44 - 4), *esp_44, out ecx_478, out edx_479, out ebx_290, out ebp_82, out esi_87, out edi_85);
		Eq_112757 edx_93 = ebp_82->tFFFFFFE4;
		edi_85->t0000 = eax_81;
		esp_299 = (word32) esp_44 + 16;
		if (eax_81 != 0x00)
		{
			struct Eq_112770 * edx_112;
			*((word32) eax_81 + 8) = 0x00;
			ebx_290->dwFFFFFFB8 = 0x00;
			_dl_all_dirs = eax_81;
			ebp_82->tFFFFFFE4 = (char *) ebx_290 - 111694;
			*((word32) eax_81 + 4) = (char *) ebx_290 - 111694;
			*((word32) eax_81 + 0x0C) = (char *) ebx_290 - 110188;
			*((word32) eax_81 + 16) = 0x05;
			if (esi_87 != 0x00)
			{
				ui32 edx_122 = 0x00;
				do
				{
					*((word32) eax_81 + (edx_122 * 0x04 + 20)) = 0x00;
					++edx_122;
				} while (esi_87 != edx_122);
				edx_112 = (word32) eax_81 + edx_93 * 0x04;
				*eax_81 = edx_112;
				edi_85->ptr0004 = edx_112;
				Eq_112757 edi_142 = ebp_82->tFFFFFFE4;
				edx_112->dw0008 = 0x00;
				edx_112->t0004 = edi_142;
				edx_112->dw0010 = 0x09;
				edx_112->ptr000C = (char *) ebx_290 - 110182;
				ui32 ecx_147 = 0x00;
				do
				{
					edx_112->a0014[ecx_147] = 0x00;
					++ecx_147;
				} while (esi_87 != ecx_147);
			}
			else
			{
				edx_112 = (word32) eax_81 + edx_93 * 0x04;
				*eax_81 = edx_112;
				edi_85->ptr0004 = edx_112;
				Eq_112757 edi_117 = ebp_82->tFFFFFFE4;
				edx_112->dw0008 = 0x00;
				edx_112->t0004 = edi_117;
				edx_112->ptr000C = (char *) ebx_290 - 110182;
				edx_112->dw0010 = 0x09;
			}
			Eq_2 ecx_161 = ebp_82->t0008;
			edx_112->dw0000 = 0x00;
			ebx_290->t1A44.u0 = 0x09;
			edi_85->dw0008 = 0x00;
			if (ecx_161 == 0x00)
			{
l0808B24C:
				ebx_290->tFFFFFFC8.u0 = ~0x00;
				return ebp_82->dwFFFFFFF4;
			}
			Eq_2 eax_173 = ebp_82->t0008;
			if (*eax_173 == 0x00)
				goto l0808B24C;
			*esp_44 = eax_173;
			word32 edx_481;
			word32 ecx_480;
			Eq_2 eax_183 = strlen(*esp_44, out ecx_480, out edx_481);
			struct Eq_112927 * esp_190 = (word32) esp_44 + 16;
			struct Eq_112927 * edi_196 = (word32) esp_44 + 16 - ((word32) eax_183 + 28 & ~0x0FFF);
			ui32 ecx_197 = (word32) eax_183 + 28 & ~0x0F;
			while (esp_190 != edi_196)
			{
				esp_190 -= 0x1000;
				esp_190->dw0FFC = esp_190->dw0FFC;
			}
			if ((ecx_197 & 0x0FFF) != 0x00)
			{
				esp_190 -= ecx_197 & 0x0FFF;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[(ecx_197 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[(ecx_197 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_2 ecx_248;
			struct Eq_113004 * esp_218 = esp_190 - 0x04;
			esp_218->tFFFFFFFC = (word32) eax_183 + 1;
			esp_218->tFFFFFFF8 = ebp_82->t0008;
			Mem232[esp_218 + -0x0C:word32] = esp_190 + 0x0F & ~0x0F;
			word32 ecx_486;
			word32 edx_487;
			Eq_2 eax_233 = memcpy(esp_218->tFFFFFFF4, esp_218->tFFFFFFF8, esp_218->tFFFFFFFC, out ecx_486, out edx_487);
			word32 eax_243 = (word32) *eax_233;
			if ((byte) eax_243 != 0x00)
			{
				Eq_2 edx_249 = eax_233;
				ui32 edi_250 = 0x01;
				do
				{
					ui32 ecx_255 = edi_250 + 0x01;
					if ((byte) (eax_243 - 0x3A) <= 0x01)
					{
						edi_250 = ecx_255;
						ecx_255 = edi_250 + 0x02;
					}
					edx_249 = (word32) edx_249 + 1;
					eax_243 = (word32) *edx_249;
				} while ((byte) eax_243 != 0x00);
				ecx_248 = ecx_255 << 0x02;
			}
			else
				ecx_248.u0 = 0x08;
			esp_218->tFFFFFFF4 = ecx_248;
			word32 esi_490;
			word32 edx_489;
			word32 ecx_488;
			struct Eq_113071 * ebp_289;
			word32 edi_491;
			Eq_2 eax_288 = __libc_malloc(gs, esp_218->tFFFFFFF0, esp_218->tFFFFFFF4, out ecx_488, out edx_489, out ebx_290, out ebp_289, out esi_490, out edi_491);
			ebx_290->tFFFFFFC8 = eax_288;
			esp_299 = (char *) &esp_218->tFFFFFFFC + 8;
			if (eax_288 != 0x00)
			{
				esp_218->tFFFFFFFC.u0 = 0x00;
				esp_218->tFFFFFFF8.u0 = 0x00;
				esp_218->tFFFFFFF4 = (char *) ebx_290 - 0x0002977B;
				fillin_rpath((char *) ebx_290 - 111675, eax_288, gs);
				Eq_2 eax_350 = ebx_290->tFFFFFFC8;
				if (*eax_350 == 0x00)
				{
					esp_218->tFFFFFFF4 = eax_350;
					word32 edx_493;
					word32 ecx_492;
					free(gs, esp_218->tFFFFFFF0, esp_218->tFFFFFFF4, out ecx_492, out edx_493);
					ebx_290->tFFFFFFC8.u0 = ~0x00;
				}
				ebx_290->dwFFFFFFCC = 0x00;
				return ebp_289->dwFFFFFFF4;
			}
		}
		eax_305 = (char *) ebx_290 - 0x0001AFF8;
l0808B3A7:
		struct Eq_112941 * esp_307 = esp_299 - 4;
		esp_307->t0000 = eax_305;
		esp_307->dwFFFFFFFC = 0x00;
		esp_307->dwFFFFFFF8 = 0x00;
		esp_307->tFFFFFFF4.u0 = 0x0C;
		word32 edi_485;
		word32 ecx_482;
		word32 edx_483;
		word32 ebp_484;
		_dl_signal_error(gs, esp_307->tFFFFFFF4, esp_307->t0000, out ecx_482, out edx_483, out ebx_319, out ebp_484, out edi_485);
		esp_299 = esp_307 - 0x10;
	}
	eax_305 = (char *) ebx_319 - 110512;
	goto l0808B3A7;
}

// 0808B3C0: Register Eq_2 _dl_map_object(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack ui32 dwArg14, Stack Eq_2 dwArg18, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
// Called from:
//      dl_open_worker
//      openaux
Eq_2 _dl_map_object(Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ui32 dwArg14, Eq_2 dwArg18, ptr32 & ebxOut, ptr32 & ebpOut)
{
	struct Eq_113166 * ebp_1072 = &g_t80CE000;
	ptr32 esp_18 = fp - 588;
	Eq_2 esi_1000 = dwArg08;
	if (dwArg18 >= 0x00)
	{
		if (dwArg18 < _dl_nns)
		{
			Eq_2 ebx_1271 = *((char *) &g_t80CEA00 + dwArg18 * 0x4C);
			while (ebx_1271 != 0x00)
			{
				word32 eax_78 = (word32) *((word32) ebx_1271 + 0x0199);
				if (((byte) (SEQ(SLICE(eax_78, word24, 8), (byte) eax_78 >> 0x05) | SEQ(SLICE(eax_78, word24, 8), (byte) eax_78 >> 0x01)) & 0x01) == 0x00)
				{
					word32 ecx_1987;
					if (_dl_name_match_p(dwArg08, ebx_1271, out ecx_1987) != 0x00)
						goto l0808B48F;
					if ((*((word32) ebx_1271 + 0x0199) & 0x01) == 0x00)
					{
						Eq_2 eax_115 = *((word32) ebx_1271 + 88);
						if (eax_115 != 0x00)
						{
							word32 edi_122 = Mem100[eax_115 + 0x04:word32] + Mem100[Mem100[ebx_1271 + 0x34:word32] + 0x04:word32];
							word32 edx_1989;
							word32 ecx_1988;
							if (strcmp(dwArg08, edi_122, out ecx_1988, out edx_1989) == 0x00)
							{
								word32 ebp_1990;
								word32 edi_1991;
								ebx_1271 = add_name_to_object.isra.4(*((word32) ebx_1271 + 28), edi_122, gs, out ebp_1990, out edi_1991);
								*((word32) ebx_1271 + 0x0199) |= 0x01;
								goto l0808B48F;
							}
						}
					}
				}
				ebx_1271 = *((word32) ebx_1271 + 0x0C);
			}
			Eq_2 dwArg04_1551;
			Eq_2 eax_1078;
			struct Eq_108727 * ebx_1225;
			struct Eq_113243 * esp_1022;
			Eq_2 ebx_1003;
			struct Eq_113245 * esp_859;
			word32 * edi_530;
			struct Eq_113243 * esp_1210;
			Eq_2 eax_549;
			byte al_515;
			Eq_2 ebx_171 = _dl_debug_mask;
			if (((byte) ebx_171 & 0x40) == 0x00)
			{
				word32 ecx_1980;
				word32 edx_1981;
				if (strchr(dwArg08, 0x2F, out ecx_1980, out edx_1981) != 0x00)
				{
					if (dwArg04 != 0x00)
						goto l0808B4EF;
					goto l0808B59C;
				}
				word32 ecx_1982;
				word32 edx_1983;
				strlen(dwArg08, out ecx_1982, out edx_1983);
				ebx_1003 = ebx_171 & 0x01;
				if ((ebx_171 & 0x01) == 0x00)
				{
l0808B688:
					if (dwArg04 != 0x00)
						goto l0808B697;
					goto l0808BC17;
				}
			}
			else if (dwArg04 != 0x00)
			{
				Eq_2 edx_222 = *((word32) dwArg04 + 4);
				ebx_1003 = *((word32) dwArg04 + 24);
				if (*edx_222 == 0x00)
				{
					edx_222 = **(union Eq_2 **) 135060900;
					if (edx_222 == 0x00)
						edx_222.u0 = 0x080B2ACB;
				}
				word32 ecx_1999;
				word32 edx_2000;
				_dl_debug_printf(out ecx_1999, out edx_2000);
				dwLoc0260 = edx_222;
				word32 edx_2002;
				word32 ecx_2001;
				if (strchr(dwArg08, 0x2F, out ecx_2001, out edx_2002) != 0x00)
				{
l0808B4EF:
					eax_549 = expand_dynamic_string_token(dwArg04, dwArg08, gs, out ebp_1072, out esi_1000);
					esp_1210 = fp - 588;
					dwLoc0228 = eax_549;
					if (eax_549 == 0x00)
						goto l0808B5B4;
l0808B509:
					word32 edi_1984;
					eax_1078 = open_verify.constprop.7(eax_549, dwArg14, fp - 0x0220, gs, fp - 0x0229, out ebx_1225, out ebp_1072, out esi_1000, out edi_1984);
					if (eax_1078 != ~0x00)
					{
						Eq_2 edx_1366 = 0x00;
						if ((dwArg14 & 0x10000000) == 0x00)
							edx_1366 = dwArg04;
						dwArg04_1551 = edx_1366;
l0808B54B:
						Eq_2 eax_1431 = _dl_map_object_from_fd.constprop.8(esi_1000, ebx_1225, eax_1078, gs, dwLoc0228, dwArg04_1551, dwArg0C, dwArg14, dwArg18);
						ebxOut = ebx;
						ebpOut = ebp;
						return eax_1431;
					}
					word32 ecx_1985;
					word32 edx_1986;
					free(gs, dwLoc0260, dwLoc0228, out ecx_1985, out edx_1986);
					esp_1210 = fp - 0x0248;
l0808B5B4:
					word32 eax_636 = 0x00;
					if (esp_1210->dw0008 == 0x00)
						eax_636 = esp_1210->dw0250;
					esp_1210->dw0250 = eax_636;
l0808B5CE:
					if (esp_1210->dw025C != 0x00 && ((esp_1210->ptr0010)->b0001 & 0x08) == 0x00)
					{
						struct Eq_113462 * esp_1226 = esp_1210 - 0x0C;
						esp_1226->tFFFFFFFC = esi_1000;
						Eq_2 eax_1230 = strdup(esp_1226->tFFFFFFFC);
						edi = eax_1230;
						if (eax_1230 != 0x00)
						{
							esp_1226->t0000 = esp_1226->t0270;
							esp_1226->tFFFFFFFC = esp_1226->t026C;
							esp_1226->dwFFFFFFF8 = esp_1226->dw025C;
							esp_1226->tFFFFFFF4 = esp_1226->t0264;
							esp_1226->tFFFFFFF0 = esi_1000;
							esp_1226->tFFFFFFEC = eax_1230;
							Eq_2 eax_1264 = _dl_new_object(gs, esp_1226->tFFFFFFEC, esp_1226->tFFFFFFF0, esp_1226->tFFFFFFF4, esp_1226->tFFFFFFFC, esp_1226->t0000);
							ebx_1271 = eax_1264;
							if (eax_1264 != 0x00)
							{
								*((word32) eax_1264 + 408) |= 0x0204;
								*((word32) eax_1264 + 400) = (char *) ebp_1072 - 110172;
								*((word32) eax_1264 + 380) = 0x01;
								esp_1226->t0000 = esp_1226->t0270;
								esp_1226->tFFFFFFFC = eax_1264;
								_dl_add_to_namespace_list(esp_1226->tFFFFFFFC, esp_1226->t0000);
l0808B48F:
								ebxOut = ebx;
								ebpOut = ebp;
								return ebx_1271;
							}
						}
l0808BCD9:
						word32 ecx_1994;
						word32 edx_1995;
						free(gs, dwArg0C, edi, out ecx_1994, out edx_1995);
						ptr32 ebp_1306;
						ptr32 ebx_1307;
						word32 edx_1997;
						word32 edi_1998;
						word32 ecx_1996;
						_dl_signal_error(gs, 0x0C, (char *) ebp_1072 - 111296, out ecx_1996, out edx_1997, out ebx_1307, out ebp_1306, out edi_1998);
						Eq_2 eax_1319 = _dl_rtld_di_serinfo(gs, 0x0C, esi_1000, 0x00);
						ebxOut = ebx_1307;
						ebpOut = ebp_1306;
						return eax_1319;
					}
					if (esp_1210->b0023 != 0x00)
					{
						struct Eq_114382 * esp_862 = esp_1210 - 4;
						esp_862->t0000 = (char *) ebp_1072 - 111630;
						esp_862->dwFFFFFFFC = 0x00;
						esp_862->tFFFFFFF8 = esi_1000;
						esp_862->tFFFFFFF4.u0 = 0x00;
						word32 edi_2025;
						word32 ecx_2023;
						word32 edx_2024;
						_dl_signal_error(gs, esp_862->tFFFFFFF4, esp_862->t0000, out ecx_2023, out edx_2024, out ebx_1003, out ebp_1072, out edi_2025);
						esp_1022 = esp_862 - 0x10;
l0808B7AB:
						if (esp_1022->dw0250 == 0x00)
						{
l0808B7BA:
							esp_1022[3] = (struct Eq_113243) 0x00;
							if ((esp_1022->dw0260 & 0x04000000) != 0x00 && *((union Eq_4933 *) 0x080CDDAC) != 0x00 || _dl_inhibit_cache != 0x00)
							{
l0808B957:
								Eq_2 edx_1112 = esp_1022->dw0250;
								if (edx_1112 == 0x00)
								{
									edx_1112 = *((char *) &g_t80CEA00 + esp_1022[0x0033] *32 0x4C);
									if (edx_1112 == 0x00)
										goto l0808B973;
								}
								if ((*((word32) edx_1112 + 521) & 0x08) != 0x00)
								{
									eax_1078.u0 = ~0x00;
									goto l0808B756;
								}
l0808B973:
								eax_1078.u0 = ~0x00;
								if (ebp_1072->dwFFFFFFB4 != ~0x00)
								{
									struct Eq_114144 * esp_1137 = esp_1022 - 0x08;
									esp_1137->ptrFFFFFFFC = (char *) &esp_1137->dw0014 + 23;
									esp_1137->dwFFFFFFF8 = 0x40;
									esp_1137->tFFFFFFF4 = edx_1112;
									esp_1137->ptrFFFFFFF0 = &esp_1137->dw0014 + 8;
									esp_1137->ptrFFFFFFEC = &esp_1137->dw0014 + 6;
									esp_1137->ptrFFFFFFE8 = ebp_1072 - 0x4C;
									Eq_2 esp_1176 = <invalid>;
									word32 ebx_2015;
									word32 edi_2016;
									eax_1078 = open_path(esp_1137->dw0014, gs, esp_1137->ptrFFFFFFE8, out ebx_2015, out ebp_1072, out esi_1000, out edi_2016);
									esp_1022 = (word32) esp_1176 + 32;
								}
								goto l0808B756;
							}
							struct Eq_113997 * esp_995 = esp_1022 - 0x0C;
							esp_995->tFFFFFFFC = esi_1000;
							Eq_2 eax_1014 = _dl_load_cache_lookup(ebx_1003, gs, esp_995->tFFFFFFFC);
							esp_1022 = (struct Eq_113243 *) (&esp_995->dw0000 + 3);
							Eq_2 edi_1023 = eax_1014;
							if (eax_1014 == 0x00)
								goto l0808B957;
							if (esp_995->ptr025C != null)
							{
								if ((esp_995->ptr025C->b0209 & 0x08) == 0x00)
									goto l0808B81C;
							}
							else if ((*((char *) *esp_995->ptr0010 + 521) & 0x08) == 0x00)
								goto l0808B81C;
							if (*eax_1014 == 0x62696C2F && *((word32) eax_1014 + 4) == 0x2F || *eax_1014 == 0x7273752F && (*((word32) eax_1014 + 4) == 0x62696C2F && *((word32) eax_1014 + 8) == 0x2F))
								goto l0808B949;
l0808B81C:
							esp_995->dw0000 = 0x00;
							esp_995->tFFFFFFFC = (char *) &esp_995->ptr0010 + 31;
							word32 ebx_2012;
							eax_1078 = open_verify.constprop.7(eax_1014, esp_995->dw026C, (char *) &esp_995->t0030 + 8, gs, esp_995->tFFFFFFFC, out ebx_2012, out ebp_1072, out esi_1000, out edi_1023);
							esp_1022 = (struct Eq_113243 *) (&esp_995->dw0000 + 3);
							if (eax_1078 != ~0x00)
							{
								esp_995->t0030 = edi_1023;
								goto l0808B756;
							}
l0808B949:
							struct Eq_114079 * esp_1087 = esp_1022 - 0x0C;
							esp_1087->tFFFFFFFC = edi_1023;
							word32 ecx_2013;
							word32 edx_2014;
							free(gs, esp_1087->tFFFFFFF8, esp_1087->tFFFFFFFC, out ecx_2013, out edx_2014);
							esp_1022 = (struct Eq_113243 *) ((char *) &esp_1087->tFFFFFFFC + 20);
							goto l0808B957;
						}
l0808B6FC:
						struct Eq_113767 * eax_890 = esp_1022->dw0250;
						word32 edi_891 = &eax_890->dw01EC;
						word32 eax_892 = eax_890->dw01EC;
						if (eax_892 == ~0x00)
							goto l0808B7BA;
						if (eax_892 == 0x00)
						{
							struct Eq_113851 * esp_898 = esp_1022 - 0x0C;
							esp_898->ptrFFFFFFFC = (char *) ebp_1072 - 111638;
							Eq_2 esp_918 = <invalid>;
							esp_1022 = (word32) esp_918 + 16;
							if ((byte) cache_rpath.part.6(esp_898->t025C, 0x1D, &eax_890->dw01EC, gs, out ebx_1003, out ebp_1072, out esi_1000, out edi_891) == 0x00)
								goto l0808B7BA;
						}
						struct Eq_113876 * esp_929 = esp_1022 - 0x08;
						esp_929->ptrFFFFFFFC = (char *) &esp_929->ptrFFFFFFFC + 47;
						esp_929->dwFFFFFFF8 = 0x04;
						esp_929->dwFFFFFFF4 = esp_929->dw0258;
						esp_929->ptrFFFFFFF0 = &esp_929->ptrFFFFFFFC + 0x0E;
						esp_929->ptrFFFFFFEC = &esp_929->ptrFFFFFFFC + 0x0C;
						esp_929->dwFFFFFFE8 = edi_891;
						esp_859 = esp_929 - 24;
l0808B73C:
						Eq_2 esp_967 = <invalid>;
						word32 edi_2011;
						eax_1078 = open_path(esp_859->dw002C, gs, esp_859->ptr0000, out ebx_1003, out ebp_1072, out esi_1000, out edi_2011);
						esp_1022 = (word32) esp_967 + 32;
l0808B751:
						if (eax_1078 != ~0x00)
							goto l0808B756;
						goto l0808B7BA;
					}
					struct Eq_114344 * esp_663 = esp_1210 - 4;
					esp_663->t0000 = (char *) ebp_1072 - 0x0001AF10;
					esp_663->dwFFFFFFFC = 0x00;
					esp_663->tFFFFFFF8 = esi_1000;
					esp_663->tFFFFFFF4 = gs->tFFFFFFE0;
					word32 edx_2021;
					word32 ebx_2022;
					word32 ecx_2020;
					_dl_signal_error(gs, esp_663->tFFFFFFF4, esp_663->t0000, out ecx_2020, out edx_2021, out ebx_2022, out ebp_1072, out edi_530);
					esp_1022 = esp_663 - 0x10;
					goto l0808BC43;
				}
				word32 ecx_2007;
				word32 edx_2008;
				strlen(dwArg08, out ecx_2007, out edx_2008);
				if ((_dl_debug_mask & 0x01) == 0x00)
				{
l0808B697:
					esp_1022 = fp - 588;
					if (*((word32) dwArg04 + 0x0094) != 0x00)
					{
						if (g_dw80CE038 == ~0x00)
							goto l0808B6FC;
						goto l0808B6B5;
					}
					Eq_2 ebx_393 = dwArg04;
					ui32 edi_394 = 0x00;
					do
					{
						word32 eax_410 = ebx_393.u22[1];
						word32 * esi_411 = ebx_393.u22 + 1;
						if (eax_410 != ~0x00)
						{
							if (eax_410 == 0x00)
							{
								struct Eq_114306 * esp_418 = esp_1022 - 0x0C;
								esp_418->dwFFFFFFFC = esp_418->dw0028;
								Eq_2 esp_435 = <invalid>;
								esp_1022 = (word32) esp_435 + 16;
								if ((byte) cache_rpath.part.6(ebx_393, 0x0F, esi_411, gs, out ebx_393, out ebp_1072, out esi_411, out edi_394) == 0x00)
									goto l0808BA37;
							}
							struct Eq_114253 * esp_446 = esp_1022 - 0x08;
							esp_446->dwFFFFFFFC = esp_446->dw0020;
							esp_446->dwFFFFFFF8 = 0x04;
							esp_446->dwFFFFFFF4 = esp_446->dw0258;
							esp_446->ptrFFFFFFF0 = &esp_446->dw0020 + 5;
							esp_446->ptrFFFFFFEC = &esp_446->dw0020 + 3;
							esp_446->ptrFFFFFFE8 = esi_411;
							ui32 edi_473;
							word32 esi_2019;
							eax_1078 = open_path(esp_446->dw0014, gs, esp_446->ptrFFFFFFE8, out ebx_393, out ebp_1072, out esi_2019, out edi_473);
							Eq_2 esp_478 = <invalid>;
							ui24 eax_24_8_490 = SLICE(eax_1078, word24, 8);
							esp_1022 = (word32) esp_478 + 32;
							if (eax_1078 != ~0x00)
							{
								esi_1000 = *((word32) esp_478 + 628);
								goto l0808B756;
							}
							edi_394 = edi_473 | SEQ(eax_24_8_490, (int8) (ebx_393 == *((word32) esp_478 + 52)));
						}
l0808BA37:
						ebx_393 = ebx_393.u22->dw0170;
					} while (ebx_393 != 0x00);
					esi_1000 = esp_1022->dw0254;
					al_515 = (byte) (edi_394 ^ 0x01);
l0808BA84:
					ebx_1003 = esp_1022->ptr0014;
					if (ebx_1003 == 0x00 || al_515 == 0x00)
						goto l0808BB12;
					ui32 eax_522 = (word32) esp_1022->ptr0014->b0198;
					esp_1022[2] = (struct Eq_113243) (byte) eax_522;
					if ((byte) (eax_522 & 0x03) == 0x02)
					{
l0808BB12:
						if (ebp_1072->dwFFFFFFC8 == ~0x00)
							goto l0808B7AB;
						if (esp_1022->dw0250 == 0x00)
						{
							struct Eq_113929 * esp_841 = esp_1022 - 0x08;
							esp_841->ptrFFFFFFFC = (char *) &esp_841->ptr000C + 31;
							esp_841->dwFFFFFFF8 = 0x02;
							esp_841->dwFFFFFFF4 = *esp_841->ptr000C;
							esp_841->ptrFFFFFFF0 = (char *) &esp_841->ptr000C + 40;
							esp_841->ptrFFFFFFEC = (char *) &esp_841->ptr000C + 32;
							esp_841->ptrFFFFFFE8 = ebp_1072 - 0x38;
							esp_859 = esp_841 - 24;
							goto l0808B73C;
						}
l0808B6B5:
						struct Eq_113780 * esp_793 = esp_1022 - 0x08;
						esp_793->ptrFFFFFFFC = (char *) &esp_793->dw0014 + 23;
						esp_793->dwFFFFFFF8 = 0x02;
						esp_793->dwFFFFFFF4 = esp_793->dw0258;
						esp_793->ptrFFFFFFF0 = &esp_793->dw0014 + 8;
						esp_793->ptrFFFFFFEC = &esp_793->dw0014 + 6;
						esp_793->ptrFFFFFFE8 = ebp_1072 - 0x38;
						Eq_2 esp_829 = <invalid>;
						word32 edi_2010;
						eax_1078 = open_path(esp_793->dw0014, gs, esp_793->ptrFFFFFFE8, out ebx_1003, out ebp_1072, out esi_1000, out edi_2010);
						esp_1022 = (word32) esp_829 + 32;
						if (eax_1078 != ~0x00 || *((word32) esp_829 + 624) == 0x00)
							goto l0808B751;
						goto l0808B6FC;
					}
					struct Eq_113662 * eax_529 = esp_1022->ptr0014;
					edi_530 = &eax_529->dw019C;
					word32 eax_531 = eax_529->dw019C;
					if (eax_531 == ~0x00)
						goto l0808BB12;
					if (eax_531 != 0x00)
					{
l0808BAC7:
						struct Eq_113701 * eax_731 = esp_1022->ptr0014;
						if (esp_1022->dw0250 != 0x00)
							eax_731 = esp_1022->dw0250;
						struct Eq_113710 * esp_737 = esp_1022 - 0x08;
						esp_737->ptrFFFFFFFC = (char *) &esp_737->dw0014 + 23;
						esp_737->dwFFFFFFF8 = 0x04;
						esp_737->ptrFFFFFFF4 = eax_731;
						esp_737->ptrFFFFFFF0 = &esp_737->dw0014 + 8;
						esp_737->ptrFFFFFFEC = &esp_737->dw0014 + 6;
						esp_737->ptrFFFFFFE8 = edi_530;
						Eq_2 esp_775 = <invalid>;
						word32 edi_2009;
						eax_1078 = open_path(esp_737->dw0014, gs, esp_737->ptrFFFFFFE8, out ebx_1003, out ebp_1072, out esi_1000, out edi_2009);
						esp_1022 = (word32) esp_775 + 32;
						if (eax_1078 != ~0x00)
						{
l0808B756:
							dwArg04_1551 = dwArg04;
							if ((esp_1022->ptr0010->b0000 & 0x01) != 0x00)
							{
								esp_1022->dw0004 = (word32) eax_1078;
								struct Eq_114194 * esp_1195 = esp_1022 - 0x0C;
								esp_1195->ptrFFFFFFFC = (char *) ebp_1072 - 0x0002BD5A;
								word32 ecx_2017;
								word32 edx_2018;
								_dl_debug_printf(out ecx_2017, out edx_2018);
								eax_1078 = esp_1195->t0010;
							}
							esp_1210 = esp_1022;
							word32 edx_1215 = 0x00;
							if (esp_1022->dw0008 == 0x00)
								edx_1215 = esp_1022->dw0250;
							esp_1022->dw0250 = edx_1215;
							if (eax_1078 != ~0x00)
							{
								ebx_1225 = (struct Eq_108727 *) (&esp_1022->dw0024 + 2);
								goto l0808B54B;
							}
							goto l0808B5CE;
						}
						goto l0808BB12;
					}
l0808BC43:
					struct Eq_113676 * esp_690 = esp_1022 - 0x0C;
					esp_690->ptrFFFFFFFC = (char *) ebp_1072 - 111644;
					Eq_2 esp_718 = <invalid>;
					esp_1022 = (word32) esp_718 + 16;
					if ((byte) cache_rpath.part.6(esp_690->t0020, 0x0F, edi_530, gs, out ebx_1003, out ebp_1072, out esi_1000, out edi_530) == 0x00)
						goto l0808BB12;
					goto l0808BAC7;
				}
			}
			else
			{
				word32 ecx_1992;
				word32 edx_1993;
				if (strchr(dwArg08, 0x2F, out ecx_1992, out edx_1993) != 0x00)
				{
l0808B59C:
					eax_549 = strdup(dwArg08);
					dwLoc0228 = eax_549;
					esp_1210 = fp - 588;
					if (eax_549 == 0x00)
						goto l0808B5B4;
					goto l0808B509;
				}
				word32 ecx_2003;
				word32 edx_2004;
				strlen(dwArg08, out ecx_2003, out edx_2004);
				ebx_1003 = ebx_171 & 0x01;
				if ((ebx_171 & 0x01) == 0x00)
				{
l0808BC17:
					esp_1022 = fp - 588;
					al_515 = 0x01;
					goto l0808BA84;
				}
			}
			word32 edx_2006;
			word32 ecx_2005;
			_dl_debug_printf(out ecx_2005, out edx_2006);
			goto l0808B688;
		}
		word32 ecx_1978;
		word32 edx_1979;
		__assert_fail(out ecx_1978, out edx_1979);
		Eq_2 esp_41 = <invalid>;
		esp_18 = (word32) esp_41 - 4;
	}
	struct Eq_113175 * esp_50 = esp_18 - 4;
	esp_50->ptr0000 = 0x080B313C;
	esp_50->dwFFFFFFFC = 0x0797;
	esp_50->ptrFFFFFFF8 = 134949400;
	esp_50->ptrFFFFFFF4 = 0x080B2BC8;
	word32 edx_1977;
	word32 ecx_1976;
	__assert_fail(out ecx_1976, out edx_1977);
	goto l0808BCD9;
}

// 0808BD00: Register ui32 _dl_rtld_di_serinfo(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_113264 bArg0C)
// Called from:
//      _dl_map_object
ui32 _dl_rtld_di_serinfo(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_113264 bArg0C)
{
	struct Eq_114420 * esp_116 = fp - 0x3C;
	Eq_2 ebp_112 = dwArg04;
	Eq_2 esi_118 = dwArg08;
	byte bLoc34_303 = (byte) dwArg0C;
	if ((byte) dwArg0C != 0x00)
	{
		*((word32) dwArg08 + 4) = 0x00;
		*dwArg08 = 0x00;
	}
	Eq_2 edi_157 = fp - 44;
	if (*((word32) dwArg04 + 0x0094) == 0x00)
	{
		Eq_2 ebx_104 = dwArg04;
		edi_157 = fp - 44;
		ptr32 esi_291 = 0x080B2BE4;
		do
		{
			word32 * edx_58 = *((word32) ebx_104 + 412);
			if (edx_58 != (word32 *) ~0x00)
			{
				if (edx_58 == null)
				{
					esp_116->ptrFFFFFFF0 = esi_291;
					Eq_2 esp_82 = <invalid>;
					esp_116 = (word32) esp_82 + 16;
					if ((byte) cache_rpath.part.6(ebx_104, 0x0F, (word32) ebx_104 + 412, gs, out ebx_104, out ebp_112, out esi_291, out edi_157) == 0x00)
						goto l0808BE47;
					edx_58 = (word32 *) *((word32) ebx_104 + 412);
				}
				add_path.isra.3.constprop.9(edi_157, edx_58);
			}
l0808BE47:
			ebx_104 = *((word32) ebx_104 + 368);
		} while (ebx_104 != 0x00);
		esi_118 = esp_116->t0044;
		if (*((word32) ebp_112 + 24) == 0x00)
		{
			struct Eq_114446 * ecx_122 = esp_116->ptr000C;
			Eq_2 ebx_124 = g_t80CEA00;
			if (ebx_124 == 0x00 || ((byte) ((word32) (*((word32) ebx_124 + 408)) & 0x03) == 0x02 || ebp_112 == ebx_124))
				goto l0808BD68;
			word32 * edx_135 = *((word32) ebx_124 + 412);
			if (edx_135 != (word32 *) ~0x00)
			{
				if (edx_135 == null)
				{
					esp_116->ptrFFFFFFF0 = (char *) ecx_122 - 111644;
					Eq_2 esp_159 = <invalid>;
					esp_116 = (word32) esp_159 + 16;
					struct Eq_114601 * ebx_156;
					if ((byte) cache_rpath.part.6(ebx_124, 0x0F, (word32) ebx_124 + 412, gs, out ebx_156, out ebp_112, out esi_118, out edi_157) == 0x00)
						goto l0808BD68;
					edx_135 = ebx_156->ptr019C;
				}
				add_path.isra.3.constprop.9(edi_157, edx_135);
			}
		}
	}
l0808BD68:
	struct Eq_114446 * ebx_185 = esp_116->ptr000C;
	ui32 eax_190 = add_path.isra.3.constprop.9(edi_157, ebx_185->ptrFFFFFFC8);
	word32 * edx_198 = *((word32) ebp_112 + 492);
	if (edx_198 != (word32 *) ~0x00)
	{
		if (edx_198 == null)
		{
			esp_116->ptrFFFFFFF0 = (char *) ebx_185 - 111638;
			word32 ebx_388;
			eax_190 = cache_rpath.part.6(ebp_112, 0x1D, (word32) ebp_112 + 492, gs, out ebx_388, out ebp_112, out esi_118, out edi_157);
			if ((byte) eax_190 == 0x00)
				goto l0808BD8F;
			edx_198 = (word32 *) *((word32) ebp_112 + 492);
		}
		eax_190 = add_path.isra.3.constprop.9(edi_157, edx_198);
	}
l0808BD8F:
	if ((*((word32) ebp_112 + 521) & 0x08) == 0x00)
		eax_190 = add_path.isra.3.constprop.9(edi_157, g_ptr80CE04C);
	if (bLoc34_303 != 0x00)
	{
		eax_190 = *((word32) esi_118 + 4) * 0x08 + 0x08;
		*esi_118 = (word32) *esi_118 + eax_190;
	}
	return eax_190;
}

// 0808BF20: Register Eq_2 check_match(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Stack Eq_2 bArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack int32 dwArg10, Stack word32 dwArg14, Stack Eq_2 dwArg18, Stack (ptr32 Eq_2) dwArg1C, Stack (ptr32 word32) dwArg20, Register out Eq_2 ecxOut)
// Called from:
//      do_lookup_x
Eq_2 check_match(Eq_2 eax, Eq_2 ecx, Eq_2 edx, Eq_2 bArg04, Eq_2 dwArg08, Eq_2 dwArg0C, int32 dwArg10, word32 dwArg14, Eq_2 dwArg18, union Eq_2 * dwArg1C, word32 * dwArg20, union Eq_2 & ecxOut)
{
	ui32 esi_22 = (word32) *((word32) dwArg0C + 0x0C);
	Eq_2 bp_33 = *((word32) dwArg0C + 0x0E);
	if (*((word32) dwArg0C + 4) == 0x00 && ((byte) (esi_22 & 0x0F) != 0x06 && bp_33 != ~0x0E))
	{
l0808C032:
		ecxOut = ecx;
		return 0x00;
	}
	if ((dwArg08 & (uint32) ((int8) (bp_33 == 0x00))) == 0x00 && !__bt(1127, esi_22 & 0x0F))
	{
		if (dwArg0C != edx)
		{
			word32 edx_352;
			if (strcmp((word32) *dwArg0C + dwArg14, eax, out ecx, out edx_352) != 0x00)
				goto l0808C030;
		}
		word16 eax_86[] = *((word32) dwArg18 + 424);
		if (ecx != 0x00)
		{
			if (eax_86 == null)
			{
				Eq_2 eax_126 = *((word32) ecx + 0x0C);
				if (eax_126 != 0x00 && _dl_name_match_p(eax_126, dwArg18, out ecx) != 0x00)
				{
					Eq_2 ecx_165;
					Eq_114778 edx_166;
					Eq_2 eax_164 = __assert_fail(out ecx_165, out edx_166);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					Eq_2 stackArg8 = <invalid>;
					Eq_2 stackArg12 = <invalid>;
					Eq_2 stackArg16 = <invalid>;
					Eq_2 stackArg20 = <invalid>;
					Eq_2 stackArg24 = <invalid>;
					Eq_2 stackArg28 = <invalid>;
					Eq_2 stackArg32 = <invalid>;
					Eq_2 stackArg36 = <invalid>;
					Eq_2 ecx_170;
					Eq_2 eax_169 = do_lookup_x(eax_164, ecx_165, edx_166, gs, stackArg4, stackArg8, stackArg12, stackArg16, stackArg20, stackArg24, stackArg28, stackArg32, stackArg36, out ecx_170);
					ecxOut = ecx_170;
					return eax_169;
				}
				goto l0808BFDB;
			}
			ui32 edi_175 = (word32) eax_86[dwArg10];
			struct Eq_114694 * eax_179 = (word32) *((word32) dwArg18 + 372) + ((edi_175 & 0x7FFF) << 0x04);
			ecx = dwArg18;
			ci16 di_210 = (word16) edi_175;
			ui32 ebp_180 = eax_179->dw0004;
			if (ebp_180 == *((word32) ecx + 4))
			{
				word32 edx_353;
				if (strcmp(eax_179->t0000, *ecx, out ecx, out edx_353) == 0x00)
					goto l0808BFDB;
			}
			if ((ebp_180 | *((word32) ecx + 8)) == 0x00 && di_210 >= 0x00)
			{
l0808BFDB:
				ecxOut = ecx;
				return dwArg0C;
			}
		}
		else
		{
			if (eax_86 == null)
				goto l0808BFDB;
			ui32 edx_95 = (word32) eax_86[dwArg10];
			ci16 dx_107 = (word16) edx_95;
			ecx = edx_95 & 0x7FFF;
			if ((edx_95 & 0x7FFF) < (uint32) ((int8) ((bArg04 & 0x02) == 0x00)) + 0x02)
				goto l0808BFDB;
			if (dx_107 >= 0x00)
			{
				word32 eax_113 = *dwArg20;
				*dwArg20 = eax_113 + 0x01;
				if (eax_113 == 0x00)
					*dwArg1C = (union Eq_2 *) dwArg0C;
			}
		}
	}
l0808C030:
	goto l0808C032;
}

// 0808C0C0: Register Eq_2 do_lookup_x(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_114778 rdx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Stack Eq_2 dwArg24, Register out Eq_2 ecxOut)
// Called from:
//      check_match
//      _dl_lookup_symbol_x
Eq_2 do_lookup_x(Eq_2 eax, Eq_2 ecx, Eq_114778 rdx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, Eq_2 dwArg24, union Eq_2 & ecxOut)
{
do_lookup_x_entry:
	def fp
	def eax
	def edx
	def ecx
	def gs
	def dwArg0C
	def dwArg10
	def dwArg1C
	def dwArg20
	def dwArg18
	def dwArg14
	def dwArg04
	def dwArg24
	def dwArg08
	def dwLoc78
	esi_24 = dwArg10
	edi_27 = *((word32) dwArg0C + 4)
	edi_30 = (struct Eq_114821 *) *dwArg0C
	goto l0808C18C
l0808C0C0:
l0808C110:
	dwLoc78_2192 = PHI((dwLoc78_2194, l0808C1BD), (dwLoc78_1302, l0808C1D5))
	ecx_1236 = PHI((ecx_109, l0808C1BD), (ecx_117, l0808C1D5))
	Mem122 = PHI((Mem50, l0808C1BD), (Mem94, l0808C1D5))
	eax_123 = *((word32) ebp_42 + 380)
	branch eax_123 == 0x00 l0808C17F
l0808C11E:
	eax_129 = *((word32) ebp_42 + 56)
	ecx_130 = *((word32) ebp_42 + 0x0188)
	eax_133 = (Eq_154640 (*)[]) *((word32) eax_129 + 4)
	eax_135 = *((word32) ebp_42 + 52)
	eax_136 = (word32) *((word32) eax_135 + 4)
	branch ecx_130 == 0x00 l0808C218
l0808C150:
	eax_276 = edx >> 0x05 & *((word32) ebp_42 + 384)
	eax_277 = (uint32) *((word32) ecx_130 + eax_276 * 0x04)
	ecx_278 = (word32) *((word32) ebp_42 + 388)
	cl_280 = (byte) ecx_278
	edx_281 = edx >> cl_280
	cl_284 = (byte) edx_281
	edx_285 = eax_277 >> cl_284
	ecx_286 = edx
	cl_287 = (byte) edx
	eax_288 = eax_277 >> cl_287
	eax_289 = eax_288 & edx_285
	al_290 = (byte) eax_289
	branch (al_290 & 0x01) != 0x00 l0808C320
l0808C17F:
	dwLoc78_2196 = PHI((dwLoc78_2194, l0808C18C), (dwLoc78_2194, l0808C1AB), (dwLoc78_2194, l0808C1B4), (dwLoc78_2192, l0808C110), (dwLoc78_2192, l0808C150), (dwLoc78_2192, l0808C227), (dwLoc78_2192, l0808C320), (dwLoc78_2187, l0808C2F1), (dwLoc78_2187, l0808C53E), (dwLoc78_2187, l0808C54C), (dwLoc78_2189, l0808C698), (dwLoc78_2189, l0808C6AF), (dwLoc78_2200, l0808CA35))
	ecx_1235 = PHI((ecx_109, l0808C18C), (ecx_109, l0808C1AB), (ecx_109, l0808C1B4), (ecx_1236, l0808C110), (ecx_286, l0808C150), (ecx_1237, l0808C227), (ecx_286, l0808C320), (ecx_560, l0808C2F1), (ecx_560, l0808C53E), (ecx_560, l0808C54C), (ecx_1238, l0808C698), (ecx_384, l0808C6AF), (ecx_1241, l0808CA35))
	Mem1207 = PHI((Mem40, l0808C18C), (Mem50, l0808C1AB), (Mem50, l0808C1B4), (Mem125, l0808C110), (Mem137, l0808C150), (Mem198, l0808C227), (Mem137, l0808C320), (Mem561, l0808C2F1), (Mem561, l0808C53E), (Mem587, l0808C54C), (Mem381, l0808C698), (Mem381, l0808C6AF), (Mem548, l0808CA35))
	esi_1205 = (word32) esi_39 + 1
	branch edi_27 <= esi_1205 l0808C3D0
l0808C18C:
	dwLoc78_2194 = PHI((dwLoc78, l0808C0C0), (dwLoc78_2196, l0808C17F))
	ecx_109 = PHI((ecx, l0808C0C0), (ecx_1235, l0808C17F))
	Mem40 = PHI((Mem37, l0808C0C0), (Mem1207, l0808C17F))
	esi_39 = PHI((esi_24, l0808C0C0), (esi_1205, l0808C17F))
	eax_41 = (struct Eq_114839 *) edi_30[esi_39 * 0x04]
	ebp_42 = eax_41->t0014
	branch ebp_42 == dwArg1C l0808C17F
l0808C19B:
	branch (dwArg20 & 0x02) == 0x00 l0808C1B4
l0808C1AB:
	branch (*((word32) ebp_42 + 408) & 0x03) == 0x00 l0808C17F
l0808C1B4:
	branch (*((word32) ebp_42 + 0x0199) & 0x20) != 0x00 l0808C17F
l0808C1BD:
	branch (_dl_debug_mask & 0x08) == 0x00 l0808C110
l0808C1CA:
	eax_65 = (byte *) *((word32) ebp_42 + 4)
	branch *eax_65 == 0x00 l0808C1F8
l0808C1D5:
	dwLoc78_1302 = eax
	_dl_debug_printf(out ecx_117, out edx_2371)
	goto l0808C110
l0808C1F8:
	eax_72 = *(union Eq_2 **) 135060900
	eax_73 = *eax_72
	goto l0808C1D5
l0808C218:
	eax_142 = *ecx
	branch eax_142 == ~0x00 l0808C7DD
l0808C227:
	ecx_1237 = PHI((ecx_130, l0808C218), (ecx_189, l0808C83F))
	Mem198 = PHI((Mem137, l0808C218), (Mem192, l0808C83F))
	eax_194 = PHI((eax_142, l0808C218), (eax_191, l0808C83F))
	edx_eax_195 = (uint64) eax_194
	edx_199 = (uint32) (edx_eax_195 % eax_123)
	eax_204 = (int32 (*)[]) *((word32) ebp_42 + 400)
	ebx_205 = eax_204[edx_199]
	branch ebx_205 == 0x00 l0808C17F
	goto l0808C269
l0808C258:
	eax_263 = (union Eq_115004 *) *((word32) ebp_42 + 396)
	ebx_264 = *((char *) eax_263 + ebx_223 * 0x04)
	branch ebx_264 == 0x00 l0808C690
l0808C269:
	ebx_223 = PHI((ebx_205, l0808C23E), (ebx_264, l0808C258))
	eax_229 = ebx_223 << 0x04
	dwLoc78_1334 = ebp_42
	eax_241 = &(eax_133 + eax_229 / 16)->dw0000
	eax_255 = check_match(eax, dwArg14, dwArg04, dwArg18, dwArg20, eax_241, ebx_223, eax_136, ebp_42, fp - 0x20, fp - 0x24, out ecx_257)
	branch eax_255 == 0x00 l0808C258
l0808C2A7:
	ecx_272 = eax_255
l0808C2B8:
	dwLoc78_2188 = PHI((dwLoc78_1334, l0808C2A7), (dwLoc78_1366, l0808CA22), (dwLoc78_2189, l0808C6A3))
	ecx_424 = PHI((ecx_272, l0808C2A7), (ecx_364, l0808CA22), (ecx_384, l0808C6A3))
	Mem389 = PHI((Mem250, l0808C2A7), (Mem351, l0808CA22), (Mem381, l0808C6A3))
	branch dwArg24 == 0x00 l0808C3E0
l0808C2F1:
	branch al_568 >> 0x04 != 0x01 l0808C17F
l0808C2FD:
	ecx_2239 = PHI((ecx_560, l0808C2F9), (ecx_1100, l0808C754), (ecx_1269, l0808C734))
	*((word32) dwArg08 + 4) = ebp_42
	*dwArg08 = ecx_424
l0808C30A:
	ecx_2238 = PHI((ecx_1174, l0808C66E), (ecx_2239, l0808C2FD), (ecx_1123, l0808C65C))
	eax_1194.u0 = 0x01
	ecxOut = ecx_2238
	return eax_1194
l0808C320:
	edx_eax_296 = (uint64) edx
	edx_298 = (uint32) (edx_eax_296 % eax_123)
	eax_300 = (union Eq_115004 *) *((word32) ebp_42 + 396)
	eax_301 = *((char *) eax_300 + edx_298 * 0x04)
	branch eax_301 == 0x00 l0808C17F
l0808C339:
	edx_305 = (int32 (*)[]) *((word32) ebp_42 + 400)
	ecx_306 = fp - 0x20
	ebx_310 = (word32 *) (edx_305 + eax_301)
	goto l0808C36B
l0808C360:
	dwLoc78_2190 = PHI((dwLoc78_2191, l0808C36B), (dwLoc78_1366, l0808C3C3))
	ecx_1239 = PHI((ecx_1240, l0808C36B), (ecx_358, l0808C3C3))
	Mem377 = PHI((Mem315, l0808C36B), (Mem351, l0808C3C3))
	al_370 = PHI((al_371, l0808C36B), (al_372, l0808C3C3))
	ebx_369 = ebx_314 + 1
	branch (al_370 & 0x01) != 0x00 l0808C84C
l0808C36B:
	dwLoc78_2191 = PHI((dwLoc78_2192, l0808C339), (dwLoc78_2190, l0808C360))
	ecx_1240 = PHI((ecx_306, l0808C339), (ecx_1239, l0808C360))
	Mem315 = PHI((Mem312, l0808C339), (Mem377, l0808C360))
	ebx_314 = PHI((ebx_310, l0808C339), (ebx_369, l0808C360))
	eax_316 = *ebx_314
	al_371 = (byte) eax_316
	edx_319 = eax_316 ^ edx
	branch edx_319 >> 0x01 != 0x00 l0808C360
l0808C375:
	eax_325 = ebx_314 - *((word32) ebp_42 + 400)
	dwLoc78_1366 = ebp_42
	eax_341 = eax_325 >> 0x02 << 0x04
	eax_342 = &(eax_133 + eax_341 / 16)->dw0000
	eax_356 = check_match(eax, dwArg14, dwArg04, dwArg18, dwArg20, eax_342, eax_325 >> 0x02, eax_136, ebp_42, fp - 0x20, fp - 0x24, out ecx_358)
	branch eax_356 != 0x00 l0808CA22
l0808C3C3:
	eax_367 = *ebx_314
	al_372 = (byte) eax_367
	goto l0808C360
l0808C3D0:
	eax_1211.u0 = 0x00
	ecxOut = ecx_1235
	return eax_1211
l0808C3ED:
	branch dwArg20 != 0x04 l0808C2C7
	eax_402 = *((word32) ebp_42 + 60)
	branch eax_402 == 0x00 l0808C49C
	goto l0808C406
l0808C3FB:
l0808C406:
	edx_406 = *((word32) ebp_42 + 64)
	branch edx_406 == 0x00 l0808C49C
l0808C411:
	ebx_410 = (uint32) *((word32) edx_406 + 4)
	branch ebx_410 == 0x00 l0808C49C
l0808C41C:
	eax_414 = (struct Eq_115727 *) *((word32) eax_402 + 4)
	edx_419 = SLICE(ebx_410 *64 ~0x55555554, word32, 32)
	branch ebx_410 <= 11 l0808C49C
l0808C436:
	ebx_426 = 0x00
	edi_432 = eax_414
l0808C44A:
	dwLoc78_2203 = PHI((dwLoc78_2188, l0808C436), (dwLoc78_2202, l0808C486))
	ebx_473 = PHI((ebx_426, l0808C436), (ebx_474, l0808C486))
	Mem438 = PHI((Mem435, l0808C436), (Mem482, l0808C486))
	edi_437 = PHI((edi_432, l0808C436), (edi_476, l0808C486))
	eax_439 = edi_437->dw0004
	al_440 = (byte) eax_439
	edx_441 = (word32) al_440
	branch edx_441 <= 0x25 l0808C486
l0808C458:
	branch edx_441 != 0x05 l0808C486
l0808C45D:
	dwLoc78_1419 = eax
	ecx_456 = eax_136 + (eax_133)[eax_439 >> 0x08].dw0000
	eax_460 = strcmp(ecx_456, eax, out ecx_461, out edx_2382)
	branch eax_460 == 0x00 l0808CA31
l0808C486:
	dwLoc78_2202 = PHI((dwLoc78_2203, l0808C458), (dwLoc78_1419, l0808C45D), (dwLoc78_2203, l0808C44A))
	Mem482 = PHI((Mem438, l0808C458), (Mem459, l0808C45D), (Mem438, l0808C44A))
	ebx_474 = ebx_473 + 0x01
	edi_476 = &edi_437->dw0004 + 2
	branch edx_419 >> 0x03 > ebx_474 l0808C44A
l0808C49C:
	dwLoc78_2201 = PHI((dwLoc78_2188, l0808C3FB), (dwLoc78_2188, l0808C406), (dwLoc78_2188, l0808C411), (dwLoc78_2188, l0808C41C), (dwLoc78_2202, l0808C490))
	Mem489 = PHI((Mem389, l0808C3FB), (Mem389, l0808C406), (Mem389, l0808C411), (Mem416, l0808C41C), (Mem482, l0808C490))
	edx_490 = *((word32) ebp_42 + 100)
	branch edx_490 == 0x00 l0808C2C7
	eax_494 = *((word32) ebp_42 + 0x0068)
	branch eax_494 == 0x00 l0808C2C7
	eax_498 = (uint32) *((word32) eax_494 + 4)
	branch eax_498 == 0x00 l0808C2C7
	ebx_504 = (struct Eq_115941 *) *((word32) edx_490 + 4)
	branch eax_498 >> 0x03 == 0x00 l0808C2C7
	eax_509 = ebx_504 + (eax_498 >> 0x03)
	goto l0808C4D6
l0808C4A7:
l0808C4B2:
l0808C4BD:
l0808C4C9:
l0808C4D6:
	dwLoc78_2205 = PHI((dwLoc78_2201, l0808C4C9), (dwLoc78_2204, l0808C512))
	Mem514 = PHI((Mem511, l0808C4C9), (Mem557, l0808C512))
	ebx_513 = PHI((ebx_504, l0808C4C9), (ebx_551, l0808C512))
	eax_515 = ebx_513->dw0004
	al_516 = (byte) eax_515
	edx_517 = (word32) al_516
	branch edx_517 <= 0x25 l0808C512
l0808C4E4:
	branch edx_517 != 0x05 l0808C512
l0808C4E9:
	dwLoc78_1432 = eax
	ecx_532 = eax_136 + (eax_133)[eax_515 >> 0x08].dw0000
	eax_536 = strcmp(ecx_532, eax, out ecx_537, out edx_2383)
	branch eax_536 == 0x00 l0808CA35
l0808C512:
	dwLoc78_2204 = PHI((dwLoc78_2205, l0808C4E4), (dwLoc78_1432, l0808C4E9), (dwLoc78_2205, l0808C4D6))
	Mem557 = PHI((Mem514, l0808C4E4), (Mem535, l0808C4E9), (Mem514, l0808C4D6))
	ebx_551 = &ebx_513->dw0004 + 1
	branch ebx_551 != eax_509 l0808C4D6
l0808C519:
l0808C53E:
	ebx_579 = *dwArg08
	branch ebx_579 != 0x00 l0808C17F
l0808C54C:
	*dwArg08 = ecx_424
	*((word32) dwArg08 + 4) = ebp_42
	goto l0808C17F
l0808C57D:
	dwLoc7C_1498 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
l0808C5A0:
	Mem626 = PHI((Mem608, l0808C57D), (Mem599, l0808C7C7))
	esi_628 = eax_590 *s 0x4C + 0x080CEA00
	eax_629 = esi_628->t0028
	ecx_630 = esi_628->t002C
	dwLoc50_1514 = eax_629
	branch eax_629 == 0x00 l0808C98F
l0808C5BB:
	edx_eax_692 = (uint64) edx
	edx_694 = (uint32) (edx_eax_692 % ecx_630)
	edx_eax_699 = (uint64) edx
	edx_701 = (uint32) (edx_eax_699 % (ecx_630 - 0x02))
	esi_704 = edx_694
	dwLoc3C_1539 = edx_701 + 0x01
	edx_710 = edx_701 + 0x01 << 0x04
l0808C5EE:
	dwLoc78_2185 = PHI((dwLoc78_2187, l0808C5BB), (dwLoc78_2184, l0808C7C0))
	Mem716 = PHI((Mem707, l0808C5BB), (Mem1251, l0808C7C0))
	esi_712 = PHI((esi_704, l0808C5BB), (esi_1138, l0808C7C0))
	ebx_714 = esi_712 << 0x04
	ebx_717 = (word32) eax_629 + ebx_714
	goto l0808C614
l0808C600:
	branch eax_721 == 0x00 l0808C6B8
l0808C608:
	dwLoc78_2184 = PHI((dwLoc78_1778, l0808C61B), (dwLoc78_1547, l0808C600))
	Mem1251 = PHI((Mem1114, l0808C61B), (Mem720, l0808C600))
	esi_1131 = (word32) esi_1129 + (edx_701 + 0x01)
	ebx_1134 = ebx_719 + edx_710 / 16
	branch ecx_630 <= esi_1131 l0808C7C0
l0808C614:
	dwLoc78_1547 = PHI((dwLoc78_2184, l0808C608), (dwLoc78_2185, l0808C5EE))
	esi_1129 = PHI((esi_1131, l0808C608), (esi_712, l0808C5EE))
	Mem720 = PHI((Mem1251, l0808C608), (Mem716, l0808C5EE))
	ebx_719 = PHI((ebx_1134, l0808C608), (ebx_717, l0808C5EE))
	eax_721 = ebx_719->t0004
	branch edx != ebx_719->t0000 l0808C600
l0808C61B:
	dwLoc78_1778 = eax
	eax_1115 = strcmp(eax_721, eax, out ecx_2376, out edx_2377)
	ecx_1123 = edx_701 + 0x01
	branch eax_1115 != 0x00 l0808C608
l0808C63F:
	branch (dwArg20 & 0x02) == 0x00 l0808CA0E
l0808C64F:
	*((word32) dwArg08 + 4) = ebp_42
	*dwArg08 = ecx_424
l0808C65C:
	goto l0808C30A
l0808C66E:
	eax_1165 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
	goto l0808C30A
l0808C698:
	dwLoc78_2189 = PHI((dwLoc78_2190, l0808C84C), (dwLoc78_1334, l0808C690))
	ecx_1238 = PHI((ecx_1239, l0808C84C), (ecx_257, l0808C690))
	Mem381 = PHI((Mem377, l0808C84C), (Mem250, l0808C690))
	goto l0808C17F
l0808C6A3:
	ecx_384.u0 = 0x00
	goto l0808C17F
l0808C6AF:
l0808C6B8:
	ecx_732 = ecx_630
	edi_735 = edx_694
	eax_736 = (ui32) g_a80CEA30[eax_590]
	branch ecx_630 * 0x03 <= eax_736 << 0x02 l0808C859
l0808C6DD:
	dwLoc78_2351 = PHI((dwLoc78_1515, l0808C9B0), (dwLoc78_1547, l0808C6B8), (dwLoc78_1548, l0808C938))
	dwLoc50_2222 = PHI((dwLoc50_1520, l0808C9B0), (dwLoc50_1514, l0808C6B8), (dwLoc50_1642, l0808C938))
	dwLoc3C_1651 = PHI((dwLoc3C_1536, l0808C9B0), (dwLoc3C_1539, l0808C6B8), (dwLoc3C_1641, l0808C938))
	ecx_1269 = PHI((ecx_658, l0808C9B0), (ecx_732, l0808C6B8), (ecx_964, l0808C938))
	edi_1265 = PHI((edi_676, l0808C9B0), (edi_735, l0808C6B8), (edi_974, l0808C938))
	Mem987 = PHI((Mem686, l0808C9B0), (Mem720, l0808C6B8), (Mem985, l0808C938))
	ebx_991 = (word32) *ecx_424 + eax_136
	branch (dwArg20 & 0x02) == 0x00 l0808C76B
l0808C6F8:
	edi_1040 = PHI((edi_1265, l0808C6DD), (edi_1059, l0808C7D6))
	eax_1042 = edi_1040 << 0x04
	eax_1045 = (word32) dwLoc50_2222 + eax_1042
	goto l0808C714
l0808C708:
	edi_1053 = (word32) edi_1051 + dwLoc3C_1651
	eax_1055 = eax_1047 + (dwLoc3C_1651 << 0x04) / 16
	branch ecx_1269 <= edi_1053 l0808C7D6
l0808C714:
	edi_1051 = PHI((edi_1040, l0808C6F8), (edi_1053, l0808C708))
	eax_1047 = PHI((eax_1045, l0808C6F8), (eax_1055, l0808C708))
	branch eax_1047->dw0004 != 0x00 l0808C708
l0808C71A:
	eax_1047->dw0004 = ebx_991
	eax_1047->t0000 = edx
	eax_1047->t0008 = dwArg04
	eax_1047->t000C = dwArg24
l0808C734:
	Mem1072 = PHI((Mem1070, l0808C71A), (Mem1030, l0808C78E), (Mem1037, l0808C7AF))
	v31_1077 = (word32) ((word608) g_a80CEA30[eax_590] + 1)
	g_a80CEA30[eax_590] = (struct Eq_154637) v31_1077
	goto l0808C2FD
l0808C754:
	eax_1084 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
	goto l0808C2FD
l0808C769:
	edi_1017 = edi_1011 - ecx_1269
l0808C76B:
	edi_998 = PHI((edi_1265, l0808C6DD), (edi_1017, l0808C769))
	eax_1000 = edi_998 << 0x04
	eax_1003 = (word32) dwLoc50_2222 + eax_1000
	goto l0808C788
l0808C780:
	edi_1011 = (word32) edi_1009 + dwLoc3C_1651
	eax_1013 = eax_1005 + (dwLoc3C_1651 << 0x04) / 16
	branch ecx_1269 <= edi_1011 l0808C769
l0808C788:
	edi_1009 = PHI((edi_998, l0808C76B), (edi_1011, l0808C780))
	eax_1005 = PHI((eax_1003, l0808C76B), (eax_1013, l0808C780))
	branch eax_1005->dw0004 != 0x00 l0808C780
l0808C78E:
	eax_1005->dw0004 = ebx_991
	eax_1005->t000C = ebp_42
	eax_1005->t0000 = edx
	eax_1005->t0008 = ecx_424
	eax_1031 = (word32) *((word32) ebp_42 + 408)
	al_1033 = (byte) (eax_1031 & 0x03)
	branch al_1033 != 0x02 l0808C734
l0808C7AF:
	v32_1036 = *((word32) ebp_42 + 520) | 0x08
	*((word32) ebp_42 + 520) = v32_1036
	goto l0808C734
l0808C7C0:
	esi_1138 = esi_1131 - ecx_630
	goto l0808C5EE
l0808C7C7:
	goto l0808C5A0
l0808C7D6:
	edi_1059 = edi_1053 - ecx_1269
	goto l0808C6F8
l0808C7DD:
	edx_145 = ecx_130
	ecx_147 = (word32) *eax
	branch ecx_147 == 0x00 l0808C83F
l0808C7EA:
	edx_151 = ecx_147
	ecx_152 = (word32) *((word32) eax + 1)
	branch ecx_152 == 0x00 l0808C83F
l0808C7F2:
	edx_154 = (ecx_147 << 0x04) + ecx_152
	ecx_156 = (word32) *((word32) eax + 2)
	branch ecx_156 == 0x00 l0808C83F
l0808C7FD:
	edx_158 = (edx_154 << 0x04) + ecx_156
	ecx_160 = (word32) *((word32) eax + 3)
	branch ecx_160 == 0x00 l0808C83F
l0808C808:
	edx_162 = (edx_158 << 0x04) + ecx_160
	ecx_164 = (word32) *((word32) eax + 4)
	branch ecx_164 == 0x00 l0808C83F
l0808C813:
	eax_166 = (word32) eax + 5
	edx_167 = (edx_162 << 0x04) + ecx_164
	ecx_169 = (word32) *((word32) eax + 5)
	branch ecx_169 == 0x00 l0808C83F
l0808C820:
	ecx_175 = PHI((ecx_169, l0808C813), (ecx_181, l0808C820))
	eax_173 = PHI((eax_166, l0808C813), (eax_174, l0808C820))
	edx_170 = PHI((edx_167, l0808C813), (edx_182, l0808C820))
	edx_171 = edx_170 << 0x04
	eax_174 = eax_173 + 1
	edx_176 = edx_171 + ecx_175
	ebx_179 = (edx_176 & 0xF0000000) >> 0x18
	ecx_181 = (word32) *eax_174
	edx_182 = edx_176 & 0x0FFFFFFF ^ ebx_179
	branch ecx_181 != 0x00 l0808C820
l0808C83F:
	edx_190 = PHI((edx_145, l0808C7DD), (edx_151, l0808C7EA), (edx_154, l0808C7F2), (edx_158, l0808C7FD), (edx_162, l0808C808), (edx_167, l0808C813), (edx_182, l0808C820))
	ecx_189 = ecx
	eax_191 = edx_190
	*ecx = edx_190
	goto l0808C227
l0808C859:
	eax_746 = _dl_higher_prime_number((word32) ecx_630 + 1)
	dwLoc78_1548 = eax_746
	eax_764 = __libc_calloc(gs, 0x10, eax_746, out ecx_766, out edx_765, out ebx_2378, out ebp_2379, out esi_2380, out edi_2381)
	branch eax_764 == 0x00 l0808CA3E
l0808C888:
	ecx_845 = ecx_630
	edi_850 = eax_629
	eax_852 = (word32) eax_629 + (ecx_630 << 0x04)
	branch ecx_630 == 0x00 l0808C938
	goto l0808C8C1
l0808C8B8:
	ecx_949 = PHI((ecx_950, l0808C8C1), (ecx_918, l0808C90E))
	edx_946 = PHI((edx_947, l0808C8C1), (edx_885, l0808C90E))
	eax_943 = PHI((eax_944, l0808C8C1), (eax_896, l0808C90E))
	Mem925 = PHI((Mem859, l0808C8C1), (Mem919, l0808C90E))
	edi_923 = (word32) edi_858 + 16
	branch eax_852 == edi_923 l0808C934
l0808C8C1:
	ecx_950 = PHI((ecx_845, l0808C8AC), (ecx_949, l0808C8B8))
	edx_947 = PHI((edx_765, l0808C8AC), (edx_946, l0808C8B8))
	eax_944 = PHI((eax_852, l0808C8AC), (eax_943, l0808C8B8))
	Mem859 = PHI((Mem857, l0808C8AC), (Mem925, l0808C8B8))
	edi_858 = PHI((edi_850, l0808C8AC), (edi_923, l0808C8B8))
	ebx_860 = (word32) *((word32) edi_858 + 4)
	branch ebx_860 == 0x00 l0808C8B8
l0808C8C8:
	eax_864 = *((word32) edi_858 + 0x0C)
	eax_868 = (word32) *((word32) edi_858 + 8)
	eax_870 = (word32) *edi_858
	edx_eax_873 = (uint64) eax_870
	edx_876 = (uint32) (edx_eax_873 % eax_746)
	ecx_879 = edx_876
	edx_eax_881 = (uint64) eax_870
	edx_883 = (uint32) (edx_eax_881 % (eax_746 - 0x02))
	edx_885 = edx_883 + 0x01
	ebp_887 = edx_883 + 0x01 << 0x04
l0808C8F4:
	ecx_889 = PHI((ecx_879, l0808C8C8), (ecx_908, l0808C930))
	eax_891 = ecx_889 << 0x04
	eax_894 = (word32) eax_764 + eax_891
	goto l0808C908
l0808C900:
	ecx_902 = (word32) ecx_900 + (edx_883 + 0x01)
	eax_904 = (word32) eax_896 + ebp_887
	branch eax_746 <= ecx_902 l0808C930
l0808C908:
	ecx_900 = PHI((ecx_902, l0808C900), (ecx_889, l0808C8F4))
	eax_896 = PHI((eax_904, l0808C900), (eax_894, l0808C8F4))
	branch *((word32) eax_896 + 4) != 0x00 l0808C900
l0808C90E:
	*((word32) eax_896 + 4) = ebx_860
	*eax_896 = eax_870
	*((word32) eax_896 + 8) = eax_868
	ecx_918 = eax_864
	*((word32) eax_896 + 0x0C) = eax_864
	goto l0808C8B8
l0808C930:
	ecx_908 = ecx_902 - eax_746
	goto l0808C8F4
l0808C938:
	ecx_948 = PHI((ecx_845, l0808C888), (ecx_949, l0808C934))
	edx_945 = PHI((edx_765, l0808C888), (edx_946, l0808C934))
	eax_942 = PHI((eax_852, l0808C888), (eax_943, l0808C934))
	ebx_933 = eax_590 *s 0x4C + 0x080CEA00
	ebx_933->ptr0034()
	ebx_933->t002C = eax_746
	ecx_964 = eax_746
	ebx_933->t0028 = eax_764
	ebx_933->ptr0034 = &g_t805D820
	edx_eax_969 = (uint64) edx
	edx_971 = (uint32) (edx_eax_969 % eax_746)
	edi_974 = edx_971
	edx_eax_976 = (uint64) edx
	edx_978 = (uint32) (edx_eax_976 % (eax_746 - 0x02))
	dwLoc3C_1641 = edx_978 + 0x01
	dwLoc50_1642 = eax_764
	goto l0808C6DD
l0808C98F:
	dwLoc78_1515.u0 = 0x1F
	eax_646 = __libc_calloc(gs, 0x10, 0x1F, out ecx_648, out edx_647, out ebx_2372, out ebp_2373, out esi_2374, out edi_2375)
	dwLoc50_1520 = eax_646
	branch eax_646 == 0x00 l0808CA3E
l0808C9B0:
	esi_628->t0028 = eax_646
	ecx_658.u0 = 0x1F
	esi_628->t002C.u0 = 0x1F
	esi_628->dw0034 = 0x0805D820
	edx_665 = SLICE(edx *64 138547333, word32, 32)
	eax_666 = edx - edx_665
	edi_669 = (eax_666 >> 0x01) + edx_665
	eax_673 = edi_669 >> 0x04 << 0x05
	eax_674 = eax_673 - (edi_669 >> 0x04)
	edi_676 = edx - eax_674
	edx_679 = SLICE(edx *64 2369637129, word32, 32)
	eax_681 = (edx_679 >> 0x04) *s 0x1D
	esi_682 = edx - eax_681
	dwLoc3C_1536 = esi_682 + 0x01
	goto l0808C6DD
l0808CA0E:
	eax_1145 = ebx_719->t0008
	*dwArg08 = eax_1145
	eax_1148 = ebx_719->t000C
	*((word32) dwArg08 + 4) = eax_1148
	goto l0808C65C
l0808CA22:
	ecx_364 = eax_356
	goto l0808C2B8
l0808CA35:
	dwLoc78_2200 = eax
	ecx_1241 = PHI((ecx_461, l0808CA31), (ecx_537, l0808C4E9))
	Mem548 = PHI((Mem459, l0808CA31), (Mem535, l0808C4E9))
	goto l0808C17F
l0808CA3E:
	dwLoc78_2285 = PHI((dwLoc78_1515, l0808C98F), (dwLoc78_1548, l0808C859))
	ecx_788 = PHI((ecx_648, l0808C98F), (ecx_766, l0808C859))
	edx_787 = PHI((edx_647, l0808C98F), (edx_765, l0808C859))
	Mem774 = PHI((Mem650, l0808C98F), (Mem768, l0808C859))
	branch _dl_tls_static_size == 0x00 l0808CA64
l0808CA4B:
	eax_782 = eax_590 *s 0x4C + 0x080CEA10
	fn00000000()
l0808CA64:
	_dl_dprintf()
	_exit(gs, 0x7F)
do_lookup_x_exit:
}

// 0808CA90: Register word32 _dl_lookup_symbol_x(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 word32) dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C, Stack Eq_2 dwArg20, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      do_lookup_x
//      _dl_lookup_symbol_x
//      _dl_relocate_object
//      do_dlsym_private
//      do_dlsym
//      do_dlvsym
//      _dl_fixup
//      _dl_profile_fixup
//      _dl_tlsdesc_resolve_rel_fixup
//      _dl_tlsdesc_resolve_rela_fixup
//      call_dl_lookup
//      _dl_sym
word32 _dl_lookup_symbol_x(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, word32 * dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18, Eq_2 dwArg1C, Eq_2 dwArg20, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	Eq_114778 ebx_26;
	word32 eax_21 = (word32) *dwArg04;
	word32 * esp_18 = fp - 0x5C;
	if ((byte) eax_21 != 0x00)
	{
		Eq_2 edx_27 = dwArg04;
		ebx_26.u0 = 0x1505;
		do
		{
			edx_27 = (word32) edx_27 + 1;
			eax_21 = (word32) *edx_27;
			ebx_26 = ebx_26 * 33 + eax_21;
		} while ((byte) eax_21 != 0x00);
	}
	else
		ebx_26.u0 = 0x1505;
	ptr32 edx_1458;
	ptr32 eax_1456;
	struct Eq_116046 * esp_169;
	Eq_2 ecx_182;
	Eq_2 esi_131 = dwArg14;
	if (dwArg14 != 0x00 && (dwArg1C & ~0x05) != 0x00)
	{
l0808D367:
		word32 edi_249 = *esp_18;
		struct Eq_116071 * esp_251 = esp_18 - 4;
		esp_251->dw0000 = edi_249 + ~0x0001AC6F;
		esp_251->dwFFFFFFFC = 799;
		esp_251->dwFFFFFFF8 = edi_249 + ~0x0001AE57;
		esp_251->dwFFFFFFF4 = edi_249 + ~0x0001AD87;
		word32 edx_2721;
		word32 ecx_2720;
		__assert_fail(out ecx_2720, out edx_2721);
		esp_169 = esp_251 - 0x10;
		goto l0808D389;
	}
	Eq_2 dwLoc58_1499;
	Eq_2 ecx_115 = dwArg20;
	Eq_2 eax_120 = *dwArg10;
	Eq_2 edx_126 = *dwArg0C;
	if (dwArg20 == 0x00)
	{
		if (eax_120 == 0x00)
			goto l0808CCD0;
	}
	else
	{
		struct Eq_116101 * ecx_66 = *eax_120;
		if (dwArg20 != (ecx_66->a0000)[0])
		{
			Eq_2 esi_74 = 0x00;
			do
				esi_74 = (word32) esi_74 + 1;
			while (ecx_66[esi_74 * 0x04] != dwArg20);
			dwLoc58_1499 = esi_74;
l0808CB29:
			ecx_115 = dwLoc58_1499;
			esi_131 = dwArg10;
			do
			{
				if (do_lookup_x(dwArg04, fp - 0x34, ebx_26, gs, edx_126, fp - 0x30, eax_120, ecx_115, dwArg14, dwArg1C, dwArg20, dwArg18, dwArg08, out ecx_115) != 0x00)
				{
					edx_126 = *dwArg0C;
					break;
				}
				esi_131 = (word32) esi_131 + 4;
				eax_120 = *esi_131;
				ecx_115.u0 = 0x00;
				edx_126 = *dwArg0C;
			} while (eax_120 != 0x00);
l0808CCD0:
			esp_169 = fp - 0x5C;
			if (edx_126 != 0x00 && *((word32) edx_126 + 0x0C) >> 0x04 == 0x02 || (g_b80CFF05 & 0x01) != 0x00)
			{
				*dwArg0C = (word32) 0x00;
				ecxOut = ecx_115;
				edxOut = edx_126;
				return 0x00;
			}
			if (dwArg08 != 0x00)
			{
				ecx_182 = *((word32) dwArg08 + 4);
				if (dwArg14 != 0x00)
				{
					eax_1456 = (ptr32) *dwArg14;
					if (eax_1456 != 0x00)
						edx_1458 = 0x080B31B4;
					else
					{
						edx_1458 = 0x080B31B4;
						eax_1456 = 134955513;
					}
				}
				else
				{
					edx_1458 = 134955513;
					eax_1456 = 134955513;
				}
				if (*ecx_182 != 0x00)
				{
l0808D335:
					struct Eq_116197 * esp_202 = esp_169 - 4;
					esp_202->t0000 = esi_131;
					esp_202->tFFFFFFFC = esi_131;
					esp_202->ptrFFFFFFF8 = eax_1456;
					esp_202->ptrFFFFFFF4 = edx_1458;
					esp_202->dwFFFFFFF0 = esp_202->dw0064;
					word32 edi_216 = esp_202->dw0004;
					esp_202->dwFFFFFFEC = edi_216 + ~0x0001AE2F;
					esp_202->tFFFFFFE8 = ecx_182;
					esp_202->ptrFFFFFFE4 = &esp_202->dw0004 + 0x0D;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					_dl_exception_create_format(gs, stackArg4, dwArg04, dwArg08);
					esp_202->tFFFFFFFC = edi_216 + ~0x0001AE16;
					esp_202->ptrFFFFFFF8 = &esp_202->dw0004 + 0x0D;
					esp_202->ptrFFFFFFF4 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg4 = <invalid>;
					word32 ebx_2724;
					_dl_signal_exception(gs, stackArg4, dwArg04, out ebx_2724);
					esi_131 = &esp_202->dw0004 + 0x0D;
					esp_18 = esp_202 - 0x10;
					goto l0808D367;
				}
l0808D3AD:
				word32 edi_293 = esp_169->dw0000;
				ecx_182 = **(union Eq_2 **) 135060900;
				if (ecx_182 == 0x00)
					ecx_182 = edi_293 + ~0x0001B534;
				goto l0808D335;
			}
l0808D389:
			if (esp_169[28] != 0x00)
			{
				word32 edi_283 = esp_169->dw0000;
				eax_1456 = (ptr32) *esp_169[28].dw0000;
				edx_1458 = edi_283 + ~0x0001AE4B;
				if (eax_1456 == 0x00)
					eax_1456 = edi_283 + ~0x00019E06;
			}
			else
			{
				word32 eax_279 = esp_169->dw0000;
				edx_1458 = eax_279 + ~0x00019E06;
				eax_1456 = eax_279 + ~0x00019E06;
			}
			goto l0808D3AD;
		}
	}
	dwLoc58_1499.u0 = 0x00;
	goto l0808CB29;
}

// 0808D5C0: Register ui32 _dl_setup_hash(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_49382 ebpOut, Register out Eq_49383 esiOut, Register out ptr32 ediOut)
// Called from:
//      _dl_non_dynamic_init
//      _dl_map_object_from_fd.constprop.8
ui32 _dl_setup_hash(Eq_2 dwArg04, Eq_2 dwArg08, union Eq_49382 & ebpOut, union Eq_49383 & esiOut, ptr32 & ediOut)
{
	Eq_2 edx_20 = *((word32) dwArg04 + 336);
	if (edx_20 != 0x00)
	{
		Eq_2 edx_36 = *((word32) edx_20 + 4);
		Eq_113558 ecx_37 = *edx_36;
		*((word32) dwArg04 + 380) = ecx_37;
		ui32 ebx_39 = *((word32) edx_36 + 8);
		Eq_49382 ebp_40 = *((word32) edx_36 + 4);
		if ((ebx_39 - 0x01 & ebx_39) != 0x00)
		{
			word32 ecx_133;
			word32 edx_134;
			__assert_fail(out ecx_133, out edx_134);
			_dl_add_to_namespace_list(dwArg04, dwArg08);
			ebpOut = ebp_40;
			esiOut = ebx_39 - 0x01;
			ediOut = 0x080CE000;
			return ebx_39;
		}
		*((word32) dwArg04 + 384) = ebx_39 - 0x01;
		word32 edx_73 = *((word32) edx_36 + 0x0C);
		*((word32) dwArg04 + 0x0188) = (word32) edx_36 + 16;
		*((word32) dwArg04 + 388) = edx_73;
		union Eq_115004 * edx_78 = (word32) edx_36 + 16 + ebx_39 * 0x04;
		*((word32) dwArg04 + 396) = edx_78;
		*((word32) dwArg04 + 400) = (char *) edx_78 + (ecx_37 - ebp_40) * 0x04;
	}
	else
	{
		Eq_2 edx_24 = *((word32) dwArg04 + 48);
		if (edx_24 != 0x00)
		{
			union Eq_113558 * edx_28 = *((word32) edx_24 + 4);
			Eq_113558 ecx_29 = *edx_28;
			*((word32) dwArg04 + 400) = (char *) edx_28 + 8;
			*((word32) dwArg04 + 380) = ecx_29;
			*((word32) dwArg04 + 396) = (char *) edx_28 + 8 + ecx_29 * 0x04;
		}
	}
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return ebx;
}

// 0808D680: void _dl_add_to_namespace_list(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _dl_non_dynamic_init
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
//      _dl_setup_hash
void _dl_add_to_namespace_list(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Mem36 = Mem12;
	union Eq_2 * eax_35 = dwArg08 *s 0x4C + 0x080CEA00;
	Eq_2 edx_37 = *eax_35;
	if (edx_37 == 0x00)
		*eax_35 = (union Eq_2 *) dwArg04;
	else
	{
		while (true)
		{
			Eq_2 eax_43 = *((word32) edx_37 + 0x0C);
			if (eax_43 == 0x00)
				break;
			edx_37 = eax_43;
		}
		*((word32) dwArg04 + 16) = edx_37;
		*((word32) edx_37 + 0x0C) = dwArg04;
	}
	g_a80CEA04[dwArg08] = (struct Eq_154643) ((word32) g_a80CEA04[dwArg08].dw0000 + 1);
	up32 eax_62 = g_dw80CE9B8;
	word32 edx_63 = g_dw80CE9BC;
	*((word32) dwArg04 + 600) = eax_62;
	g_dw80CE9B8 = eax_62 + 0x01;
	*((word32) dwArg04 + 604) = edx_63;
	g_dw80CE9BC = (word32) ((bool) (eax_62 < 0x01) + edx_63);
}

// 0808D740: Register Eq_2 _dl_new_object(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_49275 bArg0C, Stack Eq_2 bArg14, Stack Eq_2 dwArg18)
// Called from:
//      _dl_non_dynamic_init
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
Eq_2 _dl_new_object(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_49275 bArg0C, Eq_2 bArg14, Eq_2 dwArg18)
{
	word32 ecx_610;
	word32 edx_611;
	Eq_2 eax_24 = strlen(dwArg08, out ecx_610, out edx_611);
	word32 ebp_46;
	word32 ecx_612;
	word32 edx_613;
	word32 ebx_614;
	word32 edi_615;
	Eq_2 esi_137;
	Eq_2 eax_45 = __libc_calloc(gs, (word32) eax_24 + 625, 0x01, out ecx_612, out edx_613, out ebx_614, out ebp_46, out esi_137, out edi_615);
	Eq_2 edi_240 = eax_45;
	if (eax_45 == 0x00)
		return edi_240;
	*((word32) eax_45 + 20) = eax_45;
	*((word32) eax_45 + 360) = (word32) eax_45 + 608;
	*((word32) eax_45 + 28) = (word32) eax_45 + 612;
	word32 ecx_616;
	word32 edx_617;
	Eq_2 eax_78 = memcpy((word32) eax_45 + 624, dwArg08, (word32) eax_24 + 1, out ecx_616, out edx_617);
	*((word32) eax_45 + 620) = 0x01;
	*((word32) eax_45 + 612) = eax_78;
	Eq_2 eax_100 = (word32) eax_78 + ebp_46;
	byte dl_93 = *dwArg04;
	ui32 ecx_92 = (word32) bArg0C;
	if (dl_93 != 0x00)
		eax_100 = dwArg04;
	*((word32) eax_45 + 4) = eax_100;
	*((word32) eax_45 + 408) = (byte) ((word32) *((word32) eax_45 + 408) & ~0x03 | ecx_92 & 0x03);
	if ((g_b80CFF05 & 0x01) == 0x00)
		*((word32) eax_45 + 0x0200) = 0x01;
	ptr32 esi_158;
	ptr32 eax_138;
	word32 ebp_133;
	*((word32) eax_45 + 368) = esi_137;
	*((word32) eax_45 + 464) = (word32) eax_45 + 444;
	*((word32) eax_45 + 24) = dwArg18;
	((word32) eax_45 + 0x01CC)->u0 = 0x04;
	ptr32 * ecx_120 = (word32) eax_45 + 444;
	word32 eax_129 = *((char *) &g_t80CEA00 + dwArg18 * 0x4C);
	if (eax_129 != 0x00)
	{
		*((word32) eax_45 + 444) = eax_129 + 0x0160;
		eax_138 = eax_129 + 0x0160;
		ebp_133 = 0x01;
		if (esi_137 == 0x00)
		{
			esi_137 = eax_45;
			goto l0808D966;
		}
	}
	else
	{
		ebp_133 = 0x00;
		if (esi_137 == 0x00)
		{
			esi_137 = eax_45;
			goto l0808D874;
		}
	}
	while (true)
	{
		Eq_2 eax_146 = *((word32) esi_137 + 368);
		if (eax_146 == 0x00)
			break;
		esi_137 = eax_146;
	}
	if (ebp_133 != 0x00)
	{
		eax_138 = (ptr32) *((word32) eax_45 + 444);
l0808D966:
		esi_158 = (word32) esi_137 + 352;
		if (esi_158 == eax_138)
			goto l0808D87C;
		if ((bArg14 & 0x08) != 0x00)
			*((word32) eax_45 + 448) = eax_138;
		else
			ecx_120 = (word32) eax_45 + 448;
l0808D87A:
		*ecx_120 = esi_158;
l0808D87C:
		*((word32) eax_45 + 468) = (word32) eax_45 + 352;
		if (dl_93 != 0x00)
		{
			Eq_2 edx_252;
			Eq_2 ecx_253;
			Eq_2 edx_248;
			word32 ecx_618;
			word32 edx_619;
			Eq_2 eax_205 = strlen(dwArg04, out ecx_618, out edx_619);
			struct Eq_116641 * esp_212 = fp - 0x3C;
			word32 esi_218 = (word32) eax_205 + 1;
			if (dl_93 != 0x2F)
			{
				Eq_2 ebp_254 = 0x00;
				do
				{
					struct Eq_116672 * esp_257 = esp_212 - 0x08;
					esp_257->tFFFFFFFC = esi_218 + 0x80;
					esp_257->tFFFFFFF8 = ebp_254;
					word32 esi_270;
					word32 edx_625;
					word32 edi_626;
					Eq_2 eax_272 = __realloc(gs, esp_257->tFFFFFFF4, esp_257->tFFFFFFF8, esp_257->tFFFFFFFC, out edx_625, out ebp_254, out esi_270, out edi_626);
					Eq_2 esp_271 = <invalid>;
					if (eax_272 == 0x00)
						break;
					*((word32) esp_271 + 4) = esi_270 + 0x7F - *((word32) esp_271 + 32);
					*esp_271 = eax_272;
					*((word32) esp_271 + 28) = eax_272;
					word32 edi_297;
					word32 edx_627;
					Eq_2 eax_293 = getcwd(gs, *esp_271, *((word32) esp_271 + 4), out edx_627, out edi_297);
					esp_212 = (word32) esp_271 + 16;
					edx_248 = *((word32) esp_271 + 28);
					if (eax_293 != 0x00)
					{
						edi_240 = *((word32) esp_271 + 44);
						Eq_2 ecx_311 = edx_248;
						do
						{
							word32 esi_314 = *ecx_311;
							ui32 eax_318 = esi_314 + ~0x01010100 & ~esi_314;
							ecx_311 = (word32) ecx_311 + 4;
							uint32 eax_319 = eax_318 & 0x80808080;
						} while ((eax_318 & 0x80808080) == 0x00);
						Eq_2 ebp_324 = ecx_311;
						uint32 esi_325 = (eax_318 & 0x80808080) >> 0x10;
						if ((eax_318 & 0x80808080 & 0x8080) == 0x00)
							eax_319 = esi_325;
						uint8 al_338 = (byte) eax_319;
						if ((eax_318 & 0x80808080 & 0x8080) == 0x00)
							ebp_324 = (word32) ecx_311 + 2;
						ecx_253 = SLICE(SEQ(ebp_324, (byte) eax_319) + SEQ(0x03, al_338), word32, 8);
						if (*((word32) ecx_253 - 1) != 0x2F)
						{
							*ecx_253 = 0x2F;
							ecx_253 = (word32) ecx_253 + 1;
						}
						goto l0808D9D6;
					}
					ebp_254 = edx_248;
					esi_218 = edi_297;
				} while (gs->**((word32) esp_271 + 36) == 0x22);
				edi_240 = *((word32) esp_271 + 44);
				*esp_271 = ebp_254;
				word32 ecx_628;
				word32 edx_629;
				free(gs, *((word32) esp_271 - 4), *esp_271, out ecx_628, out edx_629);
				edx_252.u0 = ~0x00;
			}
			else
			{
				word32 ecx_620;
				word32 ebp_623;
				word32 esi_624;
				word32 edx_621;
				word32 ebx_622;
				Eq_2 eax_236 = __libc_malloc(gs, dwLoc50, (word32) eax_205 + 1, out ecx_620, out edx_621, out ebx_622, out ebp_623, out esi_624, out edi_240);
				esp_212 = fp - 0x3C;
				edx_248 = eax_236;
				if (eax_236 != 0x00)
				{
					ecx_253 = eax_236;
l0808D9D6:
					esp_212->t000C = edx_248;
					struct Eq_116763 * esp_362 = esp_212 - 0x04;
					esp_362->tFFFFFFFC = esp_362->t001C;
					esp_362->tFFFFFFF8 = esp_362->t0044;
					esp_362->tFFFFFFF4 = ecx_253;
					word32 edx_630;
					Eq_2 eax_373 = __mempcpy(esp_362->tFFFFFFF4, esp_362->tFFFFFFF8, esp_362->tFFFFFFFC, out edx_630);
					edx_252 = esp_362->t0010;
					while (true)
					{
						Eq_2 ecx_387 = eax_373 - 0x01;
						if (*((word32) eax_373 - 1) == 0x2F)
							break;
						eax_373 = ecx_387;
					}
					if (edx_252 == ecx_387)
						ecx_387 = eax_373;
					*ecx_387 = 0x00;
				}
				else
					edx_252.u0 = ~0x00;
			}
			*((word32) edi_240 + 428) = edx_252;
		}
		return edi_240;
	}
l0808D874:
	esi_158 = (word32) esi_137 + 352;
	goto l0808D87A;
}

// 0808DA60: Register Eq_2 _dl_try_allocate_static_tls(Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out Eq_116881 edxOut)
// Called from:
//      _dl_allocate_static_tls
Eq_2 _dl_try_allocate_static_tls(Eq_2 dwArg04, union Eq_2 & ecxOut, union Eq_116881 & edxOut)
{
	Eq_2 eax_118 = *((word32) dwArg04 + 0x0244);
	if (eax_118 == ~0x00)
	{
l0808DB09:
		ecxOut = ecx;
		edxOut = edx;
		return eax_118;
	}
	else
	{
		Eq_116890 esi_24 = *((word32) dwArg04 + 572);
		if (esi_24 <= _dl_tls_static_align)
		{
			ecx = _dl_tls_static_used;
			up32 eax_32 = _dl_tls_static_size - ecx;
			if (eax_32 > 1215)
			{
				edx = *((word32) dwArg04 + 576);
				word32 ebp_38 = Mem29[dwArg04 + 0x0238:word32] + edx;
				if (eax_32 - 0x04C0 >= ebp_38)
				{
					uint64 edx_eax_46 = (uint64) (eax_32 - 0x04C0 - ebp_38);
					Eq_2 ecx_51 = (word32) ecx + (eax_32 - 0x04C0) - edx - (uint32) (edx_eax_46 /u esi_24) *s esi_24;
					*((word32) dwArg04 + 0x0244) = ecx_51;
					_dl_tls_static_used = ecx_51;
					Eq_116881 edx_48 = (uint32) (edx_eax_46 % esi_24);
					if ((*((word32) *((word32) dwArg04 + 20) + 408) & 0x04) == 0x00)
					{
						*((word32) dwArg04 + 0x0199) |= 0x04;
						ecxOut = ecx_51;
						edxOut = edx_48;
						return 0x00;
					}
					_dl_init_static_tls();
					eax_118.u0 = 0x00;
					goto l0808DB09;
				}
			}
		}
		eax_118.u0 = ~0x00;
		goto l0808DB09;
	}
}

// 0808DB40: Register word32 _dl_allocate_static_tls(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 edxOut, Register out (ptr32 Eq_116963) ebxOut, Register out (ptr32 Eq_116964) ebpOut, Register out (ptr32 Eq_116965) esiOut, Register out (ptr32 Eq_116966) ediOut)
// Called from:
//      _dl_relocate_object
//      _dl_tlsdesc_resolve_abs_plus_addend_fixup
//      _dl_tlsdesc_resolve_rel_fixup
//      _dl_tlsdesc_resolve_rela_fixup
word32 _dl_allocate_static_tls(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & edxOut, struct Eq_116963 & ebxOut, struct Eq_116964 & ebpOut, struct Eq_116965 & esiOut, struct Eq_116966 & ediOut)
{
	if (*((word32) dwArg04 + 0x0244) != ~0x00)
	{
		word32 ecx_21;
		ptr32 edx_22;
		if (_dl_try_allocate_static_tls(dwArg04, out ecx_21, out edx_22) == 0x00)
		{
			edxOut = edx_22;
			ebxOut = ebx;
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return ecx_21;
		}
	}
	struct Eq_116964 * ebp_47;
	struct Eq_116963 * ebx_48;
	struct Eq_116966 * edi_50;
	word32 ecx_107;
	word32 edx_108;
	_dl_signal_error(gs, 0x00, 134951844, out ecx_107, out edx_108, out ebx_48, out ebp_47, out edi_50);
	ptr32 edx_61;
	word32 ecx_60 = _dl_nothread_init_static_tls(gs, null, out edx_61);
	edxOut = edx_61;
	ebxOut = ebx_48;
	ebpOut = ebp_47;
	esiOut = (struct Eq_116965 *) &g_t80CE000;
	ediOut = edi_50;
	return ecx_60;
}

// 0808DB90: Register word32 _dl_nothread_init_static_tls(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_117004) dwArg04, Register out ptr32 edxOut)
// Called from:
//      _dl_allocate_static_tls
word32 _dl_nothread_init_static_tls(struct Eq_9 * gs, struct Eq_117004 * dwArg04, ptr32 & edxOut)
{
	Eq_2 ecx_16 = dwArg04->t0234;
	word32 ecx_45;
	ptr32 edx_46;
	word32 edx_73;
	memset(__mempcpy(gs->t0008 - dwArg04->dw0244, dwArg04->t0230, ecx_16, out edx_73), 0x00, dwArg04->dw0238 - ecx_16, out ecx_45, out edx_46);
	edxOut = edx_46;
	return ecx_45;
}

// 0808DBF0: Register Eq_2 _dl_protect_relro(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_117042 ecxOut, Register out Eq_979 dlOut)
// Called from:
//      _dl_relocate_object
Eq_2 _dl_protect_relro(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_117042 & ecxOut, union Eq_979 & dlOut)
{
	word32 eax_16 = Mem11[dwArg04 + 0x0250:word32] + Mem11[dwArg04 + 0x00:word32];
	Eq_117042 ecx_103 = -_dl_pagesize;
	Eq_2 edx_21 = eax_16 & ecx_103;
	Eq_2 eax_22 = (word32) *((word32) dwArg04 + 596) + eax_16 & ecx_103;
	if (edx_21 != eax_22)
	{
		word32 edx_37;
		eax_22 = mprotect(gs, edx_21, eax_22 - edx_21, 0x01, out ecx_103, out edx_37);
		if (eax_22 < 0x00)
		{
			word32 ecx_126;
			word32 edx_127;
			word32 ebx_128;
			word32 ebp_129;
			word32 edi_130;
			_dl_signal_error(gs, gs->tFFFFFFE0, 0x080B3B20, out ecx_126, out edx_127, out ebx_128, out ebp_129, out edi_130);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg8 = <invalid>;
			Eq_2 stackArg12 = <invalid>;
			Eq_117042 ecx_73;
			byte dl_133;
			Eq_2 eax_72 = _dl_reloc_bad_type(gs, stackArg8, stackArg12, out ecx_73, out dl_133);
			ecxOut = ecx_73;
			dlOut.u0 = <invalid>;
			return eax_72;
		}
	}
	ecxOut = ecx_103;
	dlOut.u0 = <invalid>;
	return eax_22;
}

// 0808DC60: Register word32 _dl_reloc_bad_type(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 ecxOut, Register out Eq_979 dlOut)
// Called from:
//      _dl_protect_relro
//      _dl_relocate_object
word32 _dl_reloc_bad_type(struct Eq_9 * gs, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & ecxOut, union Eq_979 & dlOut)
{
	word32 ecx_92;
	Eq_2 eax_27 = __stpcpy(fp - 44, 0x080B3AE0 + (dwArg0C << 0x05), out ecx_92);
	*((word32) eax_27 + 2) = 0x00;
	*eax_27 = (&g_t80B8620)[dwArg08 >> 0x04 & 0x0F];
	*((word32) eax_27 + 1) = (&g_t80B8620)[dwArg08 & 0x0F];
	word32 ecx_93;
	word32 edx_94;
	word32 ebx_95;
	word32 ebp_96;
	word32 edi_97;
	_dl_signal_error(gs, 0x00, fp - 44, out ecx_93, out edx_94, out ebx_95, out ebp_96, out edi_97);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg4 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	ptr32 ecx_72;
	byte dl_101;
	word32 ebx_102;
	word32 ebp_103;
	word32 esi_104;
	word32 edi_105;
	word32 eax_70 = _dl_relocate_object(gs, stackArg4, stackArg12, stackArg16, out ecx_72, out dl_101, out ebx_102, out ebp_103, out esi_104, out edi_105);
	ecxOut = ecx_72;
	dlOut.u0 = <invalid>;
	return eax_70;
}

// 0808DCD0: Register ptr32 _dl_relocate_object(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 ecxOut, Register out Eq_979 dlOut, Register out Eq_2 ebxOut, Register out (ptr32 Eq_117172) ebpOut, Register out Eq_2 esiOut, Register out Eq_2 ediOut)
// Called from:
//      _dl_reloc_bad_type
//      dl_open_worker
ptr32 _dl_relocate_object(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & ecxOut, union Eq_979 & dlOut, union Eq_2 & ebxOut, struct Eq_117172 & ebpOut, union Eq_2 & esiOut, union Eq_2 & ediOut)
{
	ptr32 eax_2913 = 0x080CE000;
	struct Eq_117172 * ebp_1032 = fp - 4;
	struct Eq_117186 * esp_1040 = fp - 0x9C;
	Eq_2 edi_20 = dwArg04;
	if ((*((word32) dwArg04 + 408) & 0x04) != 0x00)
	{
l0808E109:
		struct Eq_117200 * esp_2955 = ebp_1032 - 0x0C;
		Eq_2 ebx_2957 = esp_2955->t0000;
		Eq_2 esi_2959 = esp_2955->t0004;
		Eq_2 edi_2961 = esp_2955->t0008;
		struct Eq_117172 * ebp_2963 = esp_2955->ptr000C;
		ecxOut = ecx;
		dlOut.u0 = <invalid>;
		ebxOut = ebx_2957;
		ebpOut = ebp_2963;
		esiOut = esi_2959;
		ediOut = edi_2961;
		return eax_2913;
	}
	Eq_2 dwLoc78_3471;
	struct Eq_49300 * edx_140;
	ui32 ecx_139;
	struct Eq_49300 * ebx_142;
	Eq_2 eax_229;
	Eq_2 eax_27 = _dl_debug_mask;
	if (dwArg10 != 0x00 || *((word32) dwArg04 + 0x0080) == 0x00)
	{
		dwLoc78_3471 = dwArg0C & 0x01;
		if ((eax_27 & 0x20) == 0x00)
			goto l0808DD24;
	}
	else
	{
		if ((eax_27 & 0x20) == 0x00)
		{
			if (*((word32) dwArg04 + 0x0078) == 0x00)
				dwLoc78_3471.u0 = 0x00;
			else
			{
				edx_140 = (struct Eq_49300 *) *((word32) dwArg04 + 340);
				ecx_139 = (word32) *((word32) dwArg04 + 348);
				dwLoc78_3471.u0 = 0x00;
				ebx_142 = edx_140;
				if (edx_140 < edx_140 + (ecx_139 << 0x05) / 32)
					goto l0808F747;
				dwLoc78_3471 = dwArg10;
			}
l0808DD97:
			Eq_117266 eax_351 = 0x00;
			do
			{
				*((word32) eax_351 + (fp - 0x3C)) = 0x00;
				eax_351 = (word32) eax_351 + 4;
			} while (eax_351 < 0x20);
			Eq_2 ebx_1005;
			ui32 eax_2829;
			word32 esi_370;
			Eq_2 edx_369;
			Eq_2 eax_364 = *((word32) dwArg04 + 100);
			if (eax_364 != 0x00)
			{
				ebx_1005 = *((word32) eax_364 + 4);
				esi_370 = (word32) *((word32) *((word32) dwArg04 + 0x0068) + 4);
				struct Eq_117386 * ecx_376 = *((word32) dwArg04 + 0x00C0);
				eax_2829 = 0x00;
				edx_369 = (word64) ebx_1005.u0 + esi_370;
				if (ecx_376 != null)
					eax_2829 = ecx_376->dw0004;
			}
			else
			{
				eax_2829 = 0x00;
				edx_369.u0 = 0x00;
				esi_370 = 0x00;
				ebx_1005.u0 = 0x00;
			}
			Eq_22842 ecx_389 = *((word32) dwArg04 + 112);
			if (ecx_389 != 0x00 && *((word32) ecx_389 + 4) == 0x11)
			{
				Eq_2 ecx_396 = *((word32) *((word32) dwArg04 + 0x007C) + 4);
				word32 ecx_400 = *((word32) *((word32) dwArg04 + 40) + 4);
				if ((word32) ecx_396 + ecx_400 == edx_369)
				{
					esi_370 -= ecx_400;
					edx_369 = (word64) ebx_1005.u0 + esi_370;
				}
				if (dwLoc78_3471 == 0x00 && ecx_396 == edx_369)
					esi_370 += ecx_400;
			}
			word32 edx_2828 = 0x00;
			word32 edi_2830 = esi_370;
			Eq_2 esi_1650 = dwArg04;
l0808DE20:
			struct Eq_117186 * esp_2150;
			Eq_2 edi_1004;
			Eq_2 edx_3282;
			Eq_2 esi_1012;
			Eq_2 edx_2985;
			Eq_2 edx_3023;
			Eq_2 eax_1058;
			Eq_2 ecx_1059;
			Eq_118555 dl_2998;
			Eq_2 edi_461 = (word32) ebx_1005 + edi_2830;
			ebp_1032->tFFFFFFA8 = edi_461;
			struct Eq_9 * gs_2587 = gs;
			Eq_2 ecx_462 = ebx_1005;
			if (edx_2828 != 0x00)
			{
				ebp_1032->tFFFFFFA4.u0 = 135060900;
				ebp_1032->tFFFFFFA0.u0 = 135060900;
				if (ebx_1005 < edi_461)
				{
					Eq_2 ecx_1003 = esi_1650;
					edi_1004 = ebp_1032->tFFFFFFB4;
					do
					{
						uint32 eax_1007 = *((word64) ebx_1005.u0 + 4);
						Eq_2 edx_1010 = (word32) (byte) eax_1007;
						esi_1012 = Mem1006[ebx_1005 + 0x00:word32] + edi_1004;
						if (edx_1010 == 0x07)
						{
							word32 eax_1016 = *((word32) ecx_1003 + 532);
							if (eax_1016 == 0x00)
								Mem1026[esi_1012 + 0x00:word32] = Mem1006[esi_1012 + 0x00:word32] + edi_1004;
							else
								*esi_1012 = eax_1016 + (esi_1012 - *((word32) ecx_1003 + 536)) * 0x04;
							goto l0808DE60;
						}
						if (edx_1010 != 0x29)
						{
							if (edx_1010 == 0x2A)
							{
								Eq_2 ecx_1046;
								word32 eax_1035 = Mem1006[esi_1012 + 0x00:word32] + Mem1006[ecx_1003 + 0x00:word32];
								if (ebp_1032->dwFFFFFF88 == 0x00)
								{
									ebp_1032->t0008 = ecx_1003;
									word32 edx_1044;
									eax_1035();
									ecx_1046 = ebp_1032->t0008;
									ecx_1003 = ecx_1046;
								}
								*esi_1012 = eax_1035;
								goto l0808DE60;
							}
							struct Eq_119792 * esp_1050 = esp_1040 - (struct Eq_119793 *) 0x04;
							esp_1050->tFFFFFFFC.u0 = 0x01;
							esp_1050->tFFFFFFF8 = edx_1010;
							esp_1050->tFFFFFFF4 = ecx_1003;
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_2 stackArg12 = <invalid>;
							Eq_2 edx_1060 = <invalid>;
							byte dl_4170;
							eax_1058 = _dl_reloc_bad_type(gs, dwArg04, stackArg12, out ecx_1059, out dl_4170);
							dl_2998 = (byte) edx_1060;
							esp_1040 = esp_1050 - (struct Eq_119813 *) 0x10;
l0808F714:
							if (0x00 - (dl_2998 < 0x01) + 0x03 == ecx_1059)
							{
l0808ECE3:
								Eq_2 eax_3038 = ebp_1032->t0008;
								edx_2985 = *((word32) eax_3038 + 556);
								Eq_2 eax_3040 = *((word32) eax_3038 + 552);
								ebp_1032->tFFFFFFC4 = edx_2985;
								ebp_1032->tFFFFFF94 = eax_3040;
							}
							else
							{
l0808E029:
								ptr32 ecx_3052 = esi_1012 - 0x0E;
								byte cl_3073 = (byte) ecx_3052;
								if (ecx_3052 <= 0x1B)
									edx_3023 = 0x08C00001 >> cl_3073 & 0x01;
								else
								{
									edx_3023.u0 = 0x00;
l0808E375:
									if (esi_1012 != 0x05)
									{
										if (esi_1012 == 0x06)
										{
l0808E383:
											edx_3023 |= 0x04;
										}
									}
									else
										edx_3023 |= 0x02;
								}
								Eq_2 ecx_3090 = ebp_1032->t0008;
								*((word32) ecx_3090 + 0x0224) = edx_3023;
								*((word32) ecx_3090 + 544) = ebx_1005;
								Eq_2 eax_3114 = (word32) ebp_1032->tFFFFFFA0 + ((eax_1058 & 0x7FFF) << 0x04);
								if (eax_3114 != 0x00 && *((word32) eax_3114 + 4) == 0x00)
									eax_3114.u0 = 0x00;
								struct Eq_117953 * esp_3133 = esp_1040 - (struct Eq_117954 *) 4;
								esp_3133->t0000.u0 = 0x00;
								esp_3133->tFFFFFFFC.u0 = 0x01;
								esp_3133->tFFFFFFF8 = edx_3023;
								esp_3133->tFFFFFFF4 = eax_3114;
								esp_3133->dwFFFFFFF0 = (word32) ebp_1032->t000C;
								esp_3133->ptrFFFFFFEC = ebp_1032 - 0x3C;
								Eq_2 eax_3152 = (word32) *ebx_1005 + ebp_1032->dwFFFFFF90;
								esp_3133->tFFFFFFE8 = ebp_1032->t0008;
								esp_3133->tFFFFFFE4 = eax_3152;
								word32 ecx_4153;
								word32 edx_4154;
								Eq_2 eax_3169 = _dl_lookup_symbol_x(gs, esp_3133->tFFFFFFE4, esp_3133->tFFFFFFE8, esp_3133->ptrFFFFFFEC, esp_3133->dwFFFFFFF0, esp_3133->tFFFFFFF4, esp_3133->tFFFFFFF8, esp_3133->tFFFFFFFC, esp_3133->t0000, out ecx_4153, out edx_4154);
								edx_2985 = ebp_1032->tFFFFFFC4;
								ebp_1032->tFFFFFF94 = eax_3169;
								Eq_2 eax_3182 = ebp_1032->t0008;
								*((word32) eax_3182 + 556) = edx_2985;
								*((word32) eax_3182 + 552) = eax_3169;
							}
							ebp_1032->tFFFFFFA0.u0 = 0x00;
							if (edx_2985 != 0x00)
							{
l0808E318:
								Eq_2 ax_3195 = *((word32) edx_2985 + 0x0E);
								Eq_2 ecx_3194 = *((word32) edx_2985 + 4);
								ebp_1032->tFFFFFF98 = ax_3195;
								ebp_1032->tFFFFFFA0 = ecx_3194;
								if (ax_3195 != ~0x0E)
								{
									Eq_2 ax_3206 = ebp_1032->tFFFFFF98;
									Mem3205[ebp_1032 + -96:word32] = ecx_3194 + Mem3198[Mem3198[ebp_1032 + -0x006C:word32] + 0x00:word32];
									if (ax_3206 != 0x00)
										goto l0808E343;
								}
								else
								{
l0808E343:
									if ((byte) ((word32) *((word32) edx_2985 + 0x0C) & 0x0F) == 0x0A && ebp_1032->dwFFFFFF88 == 0x00)
									{
										Eq_2 eax_3270;
										word32 ecx_3271;
										word32 edx_3272;
										ebp_1032->tFFFFFFA0();
										ebp_1032->tFFFFFFA0 = eax_3270;
									}
								}
							}
							esp_2150 = fp;
							uint32 edx_3277 = (word32) *((word32) edi_1004 + 4);
							if (edx_3277 <= 0x2A)
							{
								Eq_2 eax_3307 = ebp_1032->tFFFFFFAC;
								word32 ecx_3309 = (eax_3307 + ~0x0001AA7F)[edx_3277 * 0x04] + eax_3307;
								ptr32 eax_3314;
								ptr32 ecx_3315;
								word32 edx_3316;
								ecx_3309();
								ecxOut = ecx_3315;
								dlOut.u0 = <invalid>;
								ebxOut = ebx_1005;
								ebpOut = ebp_1032;
								esiOut = esi_1012;
								ediOut = edi_1004;
								return eax_3314;
							}
l0808FA70:
							gs_2587 = gs;
							edx_3282 = esi_1012;
							goto l0808FA72;
						}
						ebp_1032->tFFFFFFB4 = eax_1007 >> 0x08;
						if (eax_1007 >> 0x08 != 0x00)
						{
							if (*((word32) esi_1012 + 4) == 0x00)
							{
								Eq_2 eax_1071 = ebp_1032->tFFFFFFAC;
								*((word32) esi_1012 + 4) = ebx_1005;
								*esi_1012 = (word32) eax_1071 - 240672;
								goto l0808DE60;
							}
							Eq_2 ecx_1557;
							Eq_2 ecx_1310;
							Eq_2 eax_1076 = *((word32) ecx_1003 + 56);
							ebp_1032->tFFFFFF9C = *((word32) ecx_1003 + 232);
							Eq_2 edx_1080 = (word32) *((word32) eax_1076 + 4) + (ebp_1032->tFFFFFFB4 << 0x04);
							ebp_1032->tFFFFFFB0 = edx_1080;
							Eq_2 dl_1083 = *((word32) edx_1080 + 0x0C);
							ebp_1032->tFFFFFF74 = dl_1083;
							ebp_1032->tFFFFFF98 = dl_1083 >> 0x04;
							Eq_2 edx_1087 = ebp_1032->tFFFFFF9C;
							if (edx_1087 != 0x00)
							{
								Eq_2 edx_1329;
								ui32 edx_1315 = (word32) *((word32) *((word32) edx_1087 + 4) + ebp_1032->tFFFFFFB4 * 0x02);
								ebp_1032->tFFFFFFB4 = *((word32) ecx_1003 + 372);
								Eq_2 eax_1318 = ebp_1032->tFFFFFFB0;
								ebp_1032->tFFFFFFC4 = eax_1318;
								if (ebp_1032->tFFFFFF98 != 0x00 && ((word32) (*((word32) eax_1318 + 0x0D)) & 0x03) > 0x02)
								{
									if (*((word32) ecx_1003 + 544) != ebp_1032->tFFFFFFB0 || *((word32) ecx_1003 + 0x0224) != 0x01)
									{
										Eq_2 eax_1341 = ebp_1032->tFFFFFFB0;
										((word32) ecx_1003 + 0x0224)->u0 = 0x01;
										*((word32) ecx_1003 + 544) = eax_1341;
										Eq_2 eax_1349 = (word32) ebp_1032->tFFFFFFB4 + ((edx_1315 & 0x7FFF) << 0x04);
										if (eax_1349 != 0x00 && *((word32) eax_1349 + 4) == 0x00)
											eax_1349.u0 = 0x00;
										Eq_2 edx_1360 = ebp_1032->tFFFFFFB0;
										struct Eq_119680 * esp_1363 = esp_1040 - (struct Eq_119681 *) 4;
										esp_1363->t0000.u0 = 0x00;
										esp_1363->tFFFFFFFC.u0 = 0x01;
										esp_1363->tFFFFFFF8.u0 = 0x01;
										esp_1363->tFFFFFFF4 = eax_1349;
										esp_1363->dwFFFFFFF0 = (word32) ebp_1032->t000C;
										esp_1363->ptrFFFFFFEC = ebp_1032 - 0x3C;
										Eq_2 eax_1379 = (word32) *edx_1360 + ebp_1032->dwFFFFFF90;
										esp_1363->tFFFFFFE8 = ecx_1003;
										esp_1363->tFFFFFFE4 = eax_1379;
										ebp_1032->t0008 = ecx_1003;
										word32 ecx_4167;
										word32 edx_4168;
										Eq_2 eax_1389 = _dl_lookup_symbol_x(gs, esp_1363->tFFFFFFE4, esp_1363->tFFFFFFE8, esp_1363->ptrFFFFFFEC, esp_1363->dwFFFFFFF0, esp_1363->tFFFFFFF4, esp_1363->tFFFFFFF8, esp_1363->tFFFFFFFC, esp_1363->t0000, out ecx_4167, out edx_4168);
										ecx_1003 = ebp_1032->t0008;
										edx_1329 = ebp_1032->tFFFFFFC4;
										ebp_1032->tFFFFFFB4 = eax_1389;
										*((word32) ecx_1003 + 556) = edx_1329;
										*((word32) ecx_1003 + 552) = eax_1389;
									}
									else
									{
										edx_1329 = *((word32) ecx_1003 + 556);
										Eq_2 eax_1336 = *((word32) ecx_1003 + 552);
										ebp_1032->tFFFFFFC4 = edx_1329;
										ebp_1032->tFFFFFFB4 = eax_1336;
									}
									if (edx_1329 == 0x00)
										goto l0808EB73;
									ebp_1032->tFFFFFF74 = *((word32) edx_1329 + 0x0C);
								}
								else
								{
									ebp_1032->tFFFFFFB4 = ecx_1003;
									edx_1329 = ebp_1032->tFFFFFFB0;
								}
								Eq_2 ax_1416 = *((word32) edx_1329 + 0x0E);
								ebp_1032->tFFFFFF9C = ax_1416;
								if (ax_1416 != ~0x0E)
									ebp_1032->tFFFFFF98 = *ebp_1032->tFFFFFFB4;
								else
									ebp_1032->tFFFFFF98.u0 = 0x00;
								if ((byte) ((word32) ebp_1032->tFFFFFF74 & 0x0F) != 0x0A || (ebp_1032->tFFFFFF9C == 0x00 || ebp_1032->dwFFFFFF88 != 0x00))
									goto l0808F63F;
								ebp_1032->tFFFFFF9C = *((word32) edx_1329 + 4);
								Eq_2 eax_1441 = ebp_1032->tFFFFFFB4;
								if (ecx_1003 != eax_1441)
								{
									Eq_49395 al_1448 = *((word32) eax_1441 + 408);
									if ((al_1448 & 0x03) != 0x00 && (al_1448 & 0x04) == 0x00)
									{
										Eq_2 edx_1455 = *((word32) ecx_1003 + 52);
										Eq_2 eax_1456 = ebp_1032->tFFFFFFB0;
										ebp_1032->t0008 = ecx_1003;
										Mem1460[ebp_1032 + -80:word32] = Mem1457[eax_1456 + 0x00:word32] + Mem1457[edx_1455 + 0x04:word32];
										Eq_2 edx_1462 = ebp_1032->tFFFFFFA0;
										ebp_1032->tFFFFFF74 = *((word32) ebp_1032->tFFFFFFB4 + 4);
										Eq_2 edx_1466 = ebp_1032->tFFFFFFAC;
										word32 eax_1467 = **edx_1462;
										if (eax_1467 == 0x00)
											eax_1467 = (word32) edx_1466 - 0x0001AAD3;
										Eq_2 edx_1475 = ebp_1032->tFFFFFFAC;
										struct Eq_120085 * esp_1481 = esp_1040 - (struct Eq_120086 *) 0x08;
										esp_1481->tFFFFFFFC = ebp_1032->tFFFFFFB0;
										esp_1481->tFFFFFFF8 = ebp_1032->tFFFFFF74;
										esp_1481->tFFFFFFF4 = *((word32) ecx_1003 + 4);
										esp_1481->dwFFFFFFF0 = eax_1467;
										esp_1481->ptrFFFFFFEC = (word32) edx_1475 - 0x0001ABDC;
										esp_1481->tFFFFFFE8.u0 = 0x02;
										_dl_dprintf();
										ecx_1003 = ebp_1032->t0008;
									}
								}
								ebp_1032->t0008 = ecx_1003;
								word32 eax_1515 = Mem1513[ebp_1032 + -100:word32] + Mem1513[ebp_1032 + -0x0068:word32];
								word32 edx_1552;
								eax_1515();
								ecx_1557 = ebp_1032->t0008;
								ecx_1003 = ecx_1557;
								if (ebp_1032->tFFFFFFC4 != 0x00)
									goto l0808F63F;
								ecx_1003 = ecx_1557;
								goto l0808EB73;
							}
							Eq_2 eax_1104;
							Eq_2 edx_1091 = ebp_1032->tFFFFFFB0;
							ebp_1032->tFFFFFFC4 = edx_1091;
							if (ebp_1032->tFFFFFF98 == 0x00 || ((word32) (*((word32) edx_1091 + 0x0D)) & 0x03) <= 0x02)
							{
								ebp_1032->tFFFFFFB4 = ecx_1003;
								eax_1104 = ebp_1032->tFFFFFFB0;
								goto l0808EF2E;
							}
							if (*((word32) ecx_1003 + 544) != edx_1091 || *((word32) ecx_1003 + 0x0224) != 0x01)
							{
								Eq_2 edx_1110 = ebp_1032->tFFFFFFB0;
								ebp_1032->t0008 = ecx_1003;
								((word32) ecx_1003 + 0x0224)->u0 = 0x01;
								*((word32) ecx_1003 + 544) = edx_1110;
								struct Eq_120339 * esp_1117 = esp_1040 - (struct Eq_120340 *) 4;
								esp_1117->t0000.u0 = 0x00;
								esp_1117->tFFFFFFFC.u0 = 0x01;
								esp_1117->tFFFFFFF8.u0 = 0x01;
								esp_1117->tFFFFFFF4.u0 = 0x00;
								esp_1117->dwFFFFFFF0 = (word32) ebp_1032->t000C;
								esp_1117->ptrFFFFFFEC = ebp_1032 - 0x3C;
								Eq_2 eax_1131 = (word32) *edx_1110 + ebp_1032->dwFFFFFF90;
								esp_1117->tFFFFFFE8 = ecx_1003;
								esp_1117->tFFFFFFE4 = eax_1131;
								word32 ecx_4172;
								word32 edx_4173;
								Eq_2 eax_1139 = _dl_lookup_symbol_x(gs, esp_1117->tFFFFFFE4, esp_1117->tFFFFFFE8, esp_1117->ptrFFFFFFEC, esp_1117->dwFFFFFFF0, esp_1117->tFFFFFFF4, esp_1117->tFFFFFFF8, esp_1117->tFFFFFFFC, esp_1117->t0000, out ecx_4172, out edx_4173);
								ecx_1003 = ebp_1032->t0008;
								ebp_1032->tFFFFFFB4 = eax_1139;
								eax_1104 = ebp_1032->tFFFFFFC4;
								*((word32) ecx_1003 + 552) = eax_1139;
								*((word32) ecx_1003 + 556) = eax_1104;
							}
							else
							{
								eax_1104 = *((word32) ecx_1003 + 556);
								Eq_2 edx_1105 = *((word32) ecx_1003 + 552);
								ebp_1032->tFFFFFFC4 = eax_1104;
								ebp_1032->tFFFFFFB4 = edx_1105;
							}
							if (eax_1104 != 0x00)
							{
								ebp_1032->tFFFFFF74 = *((word32) eax_1104 + 0x0C);
l0808EF2E:
								Eq_2 dx_1171 = *((word32) eax_1104 + 0x0E);
								ebp_1032->tFFFFFF98 = dx_1171;
								if (dx_1171 != ~0x0E)
									ebp_1032->tFFFFFF9C = *ebp_1032->tFFFFFFB4;
								else
									ebp_1032->tFFFFFF9C.u0 = 0x00;
								if ((byte) ((word32) ebp_1032->tFFFFFF74 & 0x0F) != 0x0A || (ebp_1032->tFFFFFF98 == 0x00 || ebp_1032->dwFFFFFF88 != 0x00))
								{
l0808F63F:
									Eq_2 eax_1562 = *((word32) ebp_1032->tFFFFFFB4 + 0x0244);
									ebp_1032->tFFFFFFB0 = eax_1562;
									if (eax_1562 <= 0x00)
									{
										struct Eq_119922 * esp_1568 = esp_1040 - (struct Eq_119923 *) 0x0C;
										esp_1568->tFFFFFFFC = ebp_1032->tFFFFFFB4;
										ebp_1032->t0008 = ecx_1003;
										word32 edx_4171;
										_dl_allocate_static_tls(gs, esp_1568->tFFFFFFFC, out edx_4171, out ebx_1005, out ebp_1032, out esi_1012, out edi_1004);
										ecx_1003 = ebp_1032->t0008;
										ebp_1032->tFFFFFFB0 = *((word32) ebp_1032->tFFFFFFB4 + 0x0244);
										Eq_2 esp_1595 = <invalid>;
										esp_1040 = (word32) esp_1595 + 16;
									}
									Mem1616[esi_1012 + 0x04:word32] = Mem1608[esi_1012 + 0x04:word32] + Mem1608[Mem1608[ebp_1032 + -60:word32] + 0x04:word32] - Mem1608[ebp_1032 + -80:word32];
									*esi_1012 = (word32) ebp_1032->tFFFFFFAC - 0x0003AC60;
l0808DE60:
									ebx_1005 = (word32) ebx_1005 + 8;
									if (ebp_1032->tFFFFFFA8 > ebx_1005)
										continue;
									break;
								}
								ebp_1032->tFFFFFF98 = *((word32) eax_1104 + 4);
								Eq_2 eax_1196 = ebp_1032->tFFFFFFB4;
								if (ecx_1003 != eax_1196)
								{
									Eq_49395 al_1203 = *((word32) eax_1196 + 408);
									if ((al_1203 & 0x03) != 0x00 && (al_1203 & 0x04) == 0x00)
									{
										word32 eax_1213 = Mem1195[Mem1195[ebp_1032 + -80:word32] + 0x00:word32] + Mem1195[Mem1195[ecx_1003 + 0x34:word32] + 0x04:word32];
										ebp_1032->tFFFFFFB0 = *((word32) ebp_1032->tFFFFFFB4 + 4);
										ebp_1032->tFFFFFF74 = *((word32) ecx_1003 + 4);
										word32 * eax_1222 = **ebp_1032->tFFFFFFA4;
										if (eax_1222 == null)
											eax_1222 = (word32) ebp_1032->tFFFFFFAC - 0x0001AAD3;
										ebp_1032->t0008 = ecx_1003;
										struct Eq_120263 * esp_1236 = esp_1040 - (struct Eq_120264 *) 4;
										esp_1236->t0000 = ecx_1003;
										esp_1236->tFFFFFFFC = ecx_1003;
										esp_1236->tFFFFFFF8 = eax_1213;
										esp_1236->tFFFFFFF4 = ebp_1032->tFFFFFFB0;
										esp_1236->dwFFFFFFF0 = (word32) ebp_1032->tFFFFFF74;
										esp_1236->ptrFFFFFFEC = eax_1222;
										esp_1236->tFFFFFFE8 = (word32) ebp_1032->tFFFFFFAC - 0x0001ABDC;
										esp_1236->tFFFFFFE4.u0 = 0x02;
										_dl_dprintf();
										ecx_1003 = ebp_1032->t0008;
									}
								}
								ebp_1032->t0008 = ecx_1003;
								word32 eax_1272 = Mem1270[ebp_1032 + -0x0068:word32] + Mem1270[ebp_1032 + -100:word32];
								word32 edx_1305;
								eax_1272();
								ecx_1310 = ebp_1032->t0008;
								ecx_1003 = ecx_1310;
								if (ebp_1032->tFFFFFFC4 != 0x00)
									goto l0808F63F;
								ecx_1003 = ecx_1310;
							}
l0808EB73:
							*esi_1012 = (word32) ebp_1032->tFFFFFFAC - 240720;
							goto l0808DE60;
						}
						*esi_1012 = (word32) ebp_1032->tFFFFFFAC - 240704;
						ebx_1005 = (word64) ebx_1005.u0 + 8;
					} while (ebp_1032->tFFFFFFA8 > ebx_1005);
					ebp_1032->tFFFFFFB4 = *ecx_1003;
					esi_1650 = ecx_1003;
				}
				ebp_1032->tFFFFFF94 = (word32) ebp_1032->tFFFFFF94 + 16;
				if (ebp_1032->tFFFFFF94 == ebp_1032->tFFFFFF84)
				{
l0808DEB7:
					Eq_117715 eax_1663 = 0x00;
					do
					{
						*((word32) eax_1663 + (ebp_1032 - 0x38)) = 0x00;
						eax_1663 = (word32) eax_1663 + 4;
					} while (eax_1663 < 0x20);
					Eq_2 ebx_1679;
					Eq_2 eax_1680;
					Eq_2 eax_1674 = *((word32) esi_1650 + 60);
					if (eax_1674 != 0x00)
					{
						eax_1680 = *((word32) eax_1674 + 4);
						struct Eq_117743 * ecx_1685 = *((word32) esi_1650 + 0x00C4);
						ebx_1679 = *((word32) *((word32) esi_1650 + 64) + 4);
						ebp_1032->tFFFFFFC8 = eax_1680;
						ebp_1032->tFFFFFFCC = ebx_1679;
						Mem1690[ebp_1032 + -80:word32] = eax_1680 + ebx_1679;
						if (ecx_1685 != null)
							ebp_1032->tFFFFFFD0 = ecx_1685->t0004;
					}
					else
					{
						ebp_1032->tFFFFFFB0.u0 = 0x00;
						ebx_1679.u0 = 0x00;
						eax_1680.u0 = 0x00;
					}
					Eq_22842 ecx_1698 = *((word32) esi_1650 + 112);
					if (ecx_1698 != 0x00 && *((word32) ecx_1698 + 4) == 0x07)
					{
						Eq_2 ecx_1706 = *((word32) *((word32) esi_1650 + 0x007C) + 4);
						union Eq_2 * esi_1707 = *((word32) *((word32) esi_1650 + 40) + 4);
						if (ecx_1706 + esi_1707 == Mem1697[ebp_1032 + -80:word32])
						{
							ebx_1679 -= esi_1707;
							ebp_1032->tFFFFFFCC = ebx_1679;
							Mem1718[ebp_1032 + -80:word32] = ebx_1679 + eax_1680;
						}
						if (ebp_1032->tFFFFFF8C == 0x00 && ecx_1706 == ebp_1032->tFFFFFFB0)
						{
							ebx_1679 += esi_1707;
							ebp_1032->tFFFFFFCC = ebx_1679;
						}
						else
						{
							ebp_1032->tFFFFFFD8 = ecx_1706;
							ebp_1032->ptrFFFFFFDC = esi_1707;
						}
					}
					Eq_2 esi_1740 = ebp_1032->tFFFFFF80;
					ebp_1032->t0008 = esi_1650;
					ebp_1032->tFFFFFF8C = esi_1740;
					ebp_1032->tFFFFFF84 = ebp_1032 - 0x18;
					ebp_1032->tFFFFFF80.u0 = 0x00;
					ebp_1032->tFFFFFF74.u0 = 135060900;
l0808DF31:
					Eq_2 eax_1802;
					Eq_2 esi_1759 = ebp_1032->tFFFFFF80;
					Mem1760[ebp_1032 + -88:word32] = ebx_1679 + eax_1680;
					ebp_1032->tFFFFFFA4 = *((word32) *((word32) ebp_1032->t0008 + 56) + 4);
					Eq_2 edx_1756 = eax_1680;
					edi_1004 = (word64) eax_1680.u0 + *((word32) ebp_1032->tFFFFFF8C + 8) * 0x0C;
					if (ebp_1032->t0008 != esi_1759 && (ebp_1032->tFFFFFFB4 != 0x00 || *((word32) ebp_1032->t0008 + 288) == 0x00) && eax_1680 < edi_1004)
					{
						Eq_2 eax_1786 = ebp_1032->tFFFFFFB4;
						do
						{
							Mem1796[Mem1790[edx_1756 + 0x00:word32] + eax_1786:word32] = Mem1790[edx_1756 + 0x08:word32] + eax_1786;
							edx_1756 = (word32) edx_1756 + 0x0C;
						} while (edi_1004 > edx_1756);
						eax_1802 = *((word32) ebp_1032->t0008 + 232);
						if (eax_1802 == 0x00)
						{
l0808E952:
							if (ebp_1032->tFFFFFFA8 > edi_1004)
							{
								ebp_1032->tFFFFFF94.u0 = 135060900;
								ebp_1032->dwFFFFFF78 = 0x080CFF4C;
								do
								{
									Mem1830[ebp_1032 + -80:word32] = Mem1826[ebp_1032 + -76:word32] + Mem1826[edi_1004 + 0x00:word32];
									Eq_118534 eax_1831 = *((word32) edi_1004 + 4);
									ebx_1005 = (word32) ebp_1032->tFFFFFFA4 + ((eax_1831 >> 0x08) << 0x04);
									ebp_1032->tFFFFFFC4 = ebx_1005;
									Eq_2 esi_1834 = (word32) (byte) eax_1831;
									if (esi_1834 != 0x08)
									{
										if (esi_1834 == 0x00)
											goto l0808EBA0;
										Eq_2 edx_1862;
										if (*((word32) ebx_1005 + 0x0C) >> 0x04 == 0x00)
										{
											ebp_1032->tFFFFFF98 = ebp_1032->t0008;
											edx_1862 = ebx_1005;
											goto l0808EBD0;
										}
										Eq_2 eax_1868 = ebp_1032->t0008;
										if (((word32) *((word32) ebx_1005 + 0x0D) & 0x03) <= 0x02)
										{
											ebp_1032->tFFFFFF98 = eax_1868;
											edx_1862 = ebx_1005;
											goto l0808EBD0;
										}
										Eq_2 eax_1905;
										if (ebx_1005 != *((word32) eax_1868 + 544))
										{
l0808E9D4:
											if (esi_1834 != 0x07 && esi_1834 != 0x23)
												goto l0808E9E6;
											eax_1905.u0 = 0x01;
											goto l0808EC3D;
										}
										Eq_2 edx_1887;
										Eq_2 ecx_1888;
										if (esi_1834 <= 0x25 && !__bt(0x70000081, esi_1834 - 0x07))
										{
											edx_1887.u0 = 0x01;
											ecx_1888 = *((word32) ebp_1032->t0008 + 0x0224);
											goto l0808F696;
										}
										Eq_118352 al_1886 = (int8) (esi_1834 == 0x29);
										edx_1887 = (word32) al_1886;
										ecx_1888 = *((word32) ebp_1032->t0008 + 0x0224);
										if (esi_1834 != 0x05)
										{
											if (esi_1834 == 0x06)
											{
												if (0x00 - (al_1886 < 0x01) + 0x05 == ecx_1888)
													goto l0808F69E;
												eax_1905.u0 = 0x00;
												goto l0808EC4B;
											}
l0808F696:
											if (ecx_1888 != edx_1887)
												goto l0808E9D4;
l0808F69E:
											Eq_2 eax_1919 = ebp_1032->t0008;
											edx_1862 = *((word32) eax_1919 + 556);
											Eq_2 eax_1921 = *((word32) eax_1919 + 552);
											ebp_1032->tFFFFFFC4 = edx_1862;
											ebp_1032->tFFFFFF98 = eax_1921;
										}
										else
										{
											if (0x00 - (al_1886 < 0x01) + 0x03 == ecx_1888)
												goto l0808F69E;
l0808E9E6:
											byte cl_1953 = (byte) (esi_1834 - 0x0E);
											if (esi_1834 <= 0x29)
												eax_1905 = 0x08C00001 >> cl_1953 & 0x01;
											else
											{
												eax_1905.u0 = 0x00;
l0808EC3D:
												if (esi_1834 != 0x05)
												{
													if (esi_1834 == 0x06)
													{
l0808EC4B:
														eax_1905 |= 0x04;
													}
												}
												else
													eax_1905 |= 0x02;
											}
											Eq_2 ecx_1971 = ebp_1032->t0008;
											*((word32) ecx_1971 + 0x0224) = eax_1905;
											*((word32) ecx_1971 + 544) = ebx_1005;
											struct Eq_118414 * esp_1998 = esp_1040 - (struct Eq_118415 *) 4;
											esp_1998->t0000.u0 = 0x00;
											esp_1998->tFFFFFFFC.u0 = 0x01;
											esp_1998->tFFFFFFF8 = eax_1905;
											esp_1998->tFFFFFFF4.u0 = 0x00;
											esp_1998->dwFFFFFFF0 = (word32) ebp_1032->t000C;
											esp_1998->ptrFFFFFFEC = ebp_1032 - 0x3C;
											Eq_2 eax_2013 = (word32) *ebx_1005 + ebp_1032->dwFFFFFF90;
											esp_1998->tFFFFFFE8 = ecx_1971;
											esp_1998->tFFFFFFE4 = eax_2013;
											word32 ecx_4158;
											word32 edx_4159;
											Eq_2 eax_2034 = _dl_lookup_symbol_x(gs, esp_1998->tFFFFFFE4, esp_1998->tFFFFFFE8, esp_1998->ptrFFFFFFEC, esp_1998->dwFFFFFFF0, esp_1998->tFFFFFFF4, esp_1998->tFFFFFFF8, esp_1998->tFFFFFFFC, esp_1998->t0000, out ecx_4158, out edx_4159);
											edx_1862 = ebp_1032->tFFFFFFC4;
											ebp_1032->tFFFFFF98 = eax_2034;
											Eq_2 eax_2047 = ebp_1032->t0008;
											*((word32) eax_2047 + 556) = edx_1862;
											*((word32) eax_2047 + 552) = eax_2034;
										}
										ebp_1032->tFFFFFFA0.u0 = 0x00;
										if (edx_1862 != 0x00)
										{
l0808EBD0:
											Eq_2 ax_2060 = *((word32) edx_1862 + 0x0E);
											Eq_2 ecx_2059 = *((word32) edx_1862 + 4);
											ebp_1032->tFFFFFF9C = ax_2060;
											ebp_1032->tFFFFFFA0 = ecx_2059;
											if (ax_2060 != ~0x0E)
											{
												Eq_2 ax_2071 = ebp_1032->tFFFFFF9C;
												Mem2070[ebp_1032 + -96:word32] = ecx_2059 + Mem2063[Mem2063[ebp_1032 + -0x0068:word32] + 0x00:word32];
												if (ax_2071 != 0x00)
													goto l0808EBFB;
											}
											else
											{
l0808EBFB:
												if ((byte) ((word32) *((word32) edx_1862 + 0x0C) & 0x0F) == 0x0A && ebp_1032->dwFFFFFF88 == 0x00)
												{
													Eq_2 eax_2133;
													word32 ecx_2134;
													word32 edx_2135;
													ebp_1032->tFFFFFFA0();
													ebp_1032->tFFFFFFA0 = eax_2133;
												}
											}
										}
										esp_2150 = esp_1040;
										esi_1012 = esi_1834;
										uint32 edx_2140 = (word32) *((word32) edi_1004 + 4);
										if (edx_2140 > 0x2A)
											goto l0808FA70;
										Eq_2 eax_2144 = ebp_1032->tFFFFFFAC;
										word32 ecx_2146 = (eax_2144 + ~0x0001A7CF)[edx_2140 * 0x04] + eax_2144;
										ptr32 eax_2152;
										ptr32 ecx_2153;
										word32 edx_2154;
										ecx_2146();
										ecxOut = ecx_2153;
										dlOut.u0 = <invalid>;
										ebxOut = ebx_1005;
										ebpOut = ebp_1032;
										esiOut = esi_1834;
										ediOut = edi_1004;
										return eax_2152;
									}
									Mem1846[Mem1838[ebp_1032 + -80:word32] + 0x00:word32] = Mem1838[edi_1004 + 0x08:word32] + Mem1838[Mem1838[ebp_1032 + 0x08:word32] + 0x00:word32];
l0808EBA0:
									edi_1004 = (word32) edi_1004 + 0x0C;
								} while (ebp_1032->tFFFFFFA8 > edi_1004);
							}
							goto l0808E17C;
						}
					}
					else
					{
						eax_1802 = *((word32) ebp_1032->t0008 + 232);
						if (eax_1802 == 0x00)
							goto l0808E952;
					}
					ebp_1032->tFFFFFF9C = *((word32) eax_1802 + 4);
					if (ebp_1032->tFFFFFFA8 > edi_1004)
					{
						ebp_1032->dwFFFFFF78 = 0x080CFF4C;
						do
						{
							Eq_118609 edx_2173 = *((word32) edi_1004 + 4);
							Eq_2 esi_2175 = ebp_1032->t0008;
							Eq_2 eax_2176 = ebp_1032->tFFFFFF9C;
							Mem2181[ebp_1032 + -80:word32] = Mem2172[ebp_1032 + -76:word32] + Mem2172[edi_1004 + 0x00:word32];
							eax_1058 = (word32) *((word32) eax_2176 + (edx_2173 >> 0x08) * 0x02);
							ebx_1005 = (word32) ebp_1032->tFFFFFFA4 + ((edx_2173 >> 0x08) << 0x04);
							ebp_1032->tFFFFFFA0 = *((word32) esi_2175 + 372);
							ebp_1032->tFFFFFFC4 = ebx_1005;
							esi_1012 = (word32) (byte) edx_2173;
							if (esi_1012 != 0x08)
							{
								if (esi_1012 != 0x00)
								{
									if (*((word32) ebx_1005 + 0x0C) >> 0x04 == 0x00 || ((word32) (*((word32) ebx_1005 + 0x0D)) & 0x03) <= 0x02)
									{
										ebp_1032->tFFFFFF94 = ebp_1032->t0008;
										edx_2985 = ebx_1005;
										goto l0808E318;
									}
									if (ebx_1005 == *((word32) ebp_1032->t0008 + 544))
									{
										if (esi_1012 <= 0x25 && !__bt(0x70000081, esi_1012 - 0x07))
										{
											Eq_2 edx_3026 = ebp_1032->t0008;
											ebp_1032->tFFFFFF98.u0 = 0x01;
											ecx_1059 = *((word32) edx_3026 + 0x0224);
										}
										else
										{
											dl_2998.u0 = (int8) (esi_1012 == 0x29);
											ebp_1032->tFFFFFF98 = (word32) dl_2998;
											ecx_1059 = *((word32) ebp_1032->t0008 + 0x0224);
											if (esi_1012 == 0x05)
												goto l0808F714;
											if (esi_1012 == 0x06)
											{
												if (0x00 - (dl_2998 < 0x01) + 0x05 == ecx_1059)
													goto l0808ECE3;
												edx_3023.u0 = 0x00;
												goto l0808E383;
											}
										}
										if (ecx_1059 == ebp_1032->tFFFFFF98)
											goto l0808ECE3;
									}
									if (esi_1012 != 0x07 && esi_1012 != 0x23)
										goto l0808E029;
									edx_3023.u0 = 0x01;
									goto l0808E375;
								}
							}
							else
								Mem2197[Mem2189[ebp_1032 + -80:word32] + 0x00:word32] = Mem2189[edi_1004 + 0x08:word32] + Mem2189[Mem2189[ebp_1032 + 0x08:word32] + 0x00:word32];
							edi_1004 = (word32) edi_1004 + 0x0C;
						} while (ebp_1032->tFFFFFFA8 > edi_1004);
					}
l0808E17C:
					ebp_1032->tFFFFFF8C = (word32) ebp_1032->tFFFFFF8C + 16;
					if (ebp_1032->tFFFFFF8C != ebp_1032->tFFFFFF84)
					{
						Eq_2 eax_2966 = ebp_1032->tFFFFFF8C;
						ebx_1679 = *((word32) eax_2966 + 4);
						eax_1680 = *eax_2966;
						ebp_1032->tFFFFFFB4 = *ebp_1032->t0008;
						goto l0808DF31;
					}
					ecx = ebp_1032->ptr0014;
					edi_20 = ebp_1032->t0008;
					if (ecx != 0x00)
					{
						struct Eq_118739 * eax_2219 = *((word32) edi_20 + 40);
						if (eax_2219 != null)
						{
							struct Eq_118827 * esp_2235 = esp_1040 - (struct Eq_118828 *) 0x08;
							esp_2235->tFFFFFFFC = (uint32) ((uint64) eax_2219->dw0004 /u ((uint32) ((int8) (*((word32) (*((word32) edi_20 + 112)) + 4) == 0x07)) * 0x04 + 0x08));
							esp_2235->tFFFFFFF8.u0 = 0x18;
							word32 edx_4162;
							word32 esi_4164;
							word32 ebx_4163;
							Eq_2 eax_2252 = __libc_calloc(gs, esp_2235->tFFFFFFF8, esp_2235->tFFFFFFFC, out ecx, out edx_4162, out ebx_4163, out ebp_1032, out esi_4164, out edi_20);
							*((word32) edi_20 + 420) = eax_2252;
							if (eax_2252 == 0x00)
							{
								Eq_2 edx_2270 = *((word32) edi_20 + 4);
								Eq_2 eax_2273 = **(union Eq_2 **) 135060900;
								if (eax_2273 == 0x00)
									eax_2273 = (word32) ebp_1032->tFFFFFFAC - 0x0001AAD3;
								esp_2235[1] = (struct Eq_118827) edx_2270;
								esp_2235->t0000 = eax_2273;
								esp_2235->tFFFFFFFC = (word32) ebp_1032->tFFFFFFAC - 0x0001AB2C;
								esp_2235->tFFFFFFF8.u0 = 0x02;
								_dl_dprintf();
								esp_2235->tFFFFFFF8.u0 = 0x7F;
								_exit(gs, esp_2235->tFFFFFFF8);
							}
						}
					}
					struct Eq_118745 * edx_2834 = ebp_1032->ptrFFFFFF7C;
					*((word32) edi_20 + 408) |= 0x04;
					if (edx_2834 != null)
					{
						struct Eq_118745 * ebx_2842 = ebp_1032->ptrFFFFFF7C;
						do
						{
							struct Eq_118788 * esp_2844 = esp_1040 - (struct Eq_118789 *) 0x04;
							esp_2844->tFFFFFFFC = ebx_2842->t0008;
							esp_2844->tFFFFFFF8 = ebx_2842->t0004;
							esp_2844->tFFFFFFF4 = ebx_2842->t0000;
							esp_1040 = esp_2844 + 0x08;
							word32 edx_2860;
							if (mprotect(gs, esp_2844->tFFFFFFF4, esp_2844->tFFFFFFF8, esp_2844->tFFFFFFFC, out ecx, out edx_2860) < 0x00)
								goto l0808FF3E;
							ebx_2842 = ebx_2842->ptr000C;
						} while (ebx_2842 != null);
					}
					eax_2913 = (ptr32) *((word32) edi_20 + 596);
					if (eax_2913 != 0x00)
					{
						esp_1040->dwFFFFFFF0 = (word32) edi_20;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_2 stackArg4 = <invalid>;
						byte dl_4161;
						eax_2913 = _dl_protect_relro(gs, stackArg4, out ecx, out dl_4161);
					}
					goto l0808E109;
				}
l0808E5B8:
				Eq_2 ecx_2827 = ebp_1032->tFFFFFF94;
				edx_2828 = (word32) *((word32) ecx_2827 + 0x0C);
				eax_2829 = (ui32) *((word32) ecx_2827 + 8);
				edi_2830 = (word32) *((word32) ecx_2827 + 4);
				ebx_1005 = *ecx_2827;
				goto l0808DE20;
			}
			Eq_2 edi_508;
			Eq_2 edx_470 = *((word32) esi_1650 + 56);
			ebp_1032->tFFFFFFB0 = (word64) ebx_1005.u0 + eax_2829 * 0x08;
			Eq_2 eax_474 = ebp_1032->tFFFFFFB4;
			ebp_1032->tFFFFFFA0 = *((word32) edx_470 + 4);
			if (eax_474 != 0x00 && (esi_1650 != 0x00 && ebx_1005 < ebp_1032->tFFFFFFB0))
			{
				word32 eax_486 = Mem476[ebp_1032 + -76:word32] + Mem476[ebx_1005 + 0x00:word32];
				if (*((word32) ebx_1005 + 4) == 0x08)
				{
					ebx_1005 = ebp_1032->tFFFFFFB0;
					Eq_2 edx_490 = ebp_1032->tFFFFFFB4;
					do
					{
						*eax_486 = (word32) edx_490 + *eax_486;
						ecx_462 = (word32) ecx_462 + 8;
						if (ebx_1005 <= ecx_462)
							goto l0808E407;
						eax_486 = Mem497[ecx_462 + 0x00:word32] + edx_490;
					} while (*((word32) ecx_462 + 4) == 0x08);
				}
				edi_508 = ebp_1032->tFFFFFFAC;
				struct Eq_120489 * esp_513 = esp_1040 - (struct Eq_120490 *) 4;
				esp_513->t0000 = (word32) edi_508 - 109300;
				esp_513->tFFFFFFFC.u0 = 0x0288;
				esp_513->tFFFFFFF8 = (word32) edi_508 - 0x0001AA9E;
				esp_513->tFFFFFFF4 = (word32) edi_508 - 0x0001ABA8;
				word32 edx_4175;
				word32 ecx_4174;
				__assert_fail(out ecx_4174, out edx_4175);
				Eq_2 esp_525 = <invalid>;
				esp_2150 = (word32) esp_525 - 4;
l0808FF17:
				edx_3282 = edi_508;
				while (true)
				{
l0808FA72:
					Eq_2 edi_3285 = ebp_1032->t0008;
					struct Eq_118223 * esp_3287 = esp_2150 - (struct Eq_118224 *) 0x04;
					esp_3287->tFFFFFFFC.u0 = 0x00;
					esp_3287->tFFFFFFF8 = edx_3282;
					esp_3287->tFFFFFFF4 = edi_3285;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg12 = <invalid>;
					byte dl_4157;
					word32 ecx_4156;
					_dl_reloc_bad_type(gs_2587, dwArg04, stackArg12, out ecx_4156, out dl_4157);
					esp_2150 = esp_3287 - (struct Eq_118243 *) 0x10;
l0808FA81:
					edx_3282 = ebx_1005;
				}
			}
l0808E407:
			Eq_2 eax_534 = *((word32) esi_1650 + 232);
			if (eax_534 != 0x00)
			{
				Eq_2 edi_988 = ebp_1032->tFFFFFFB0;
				ebp_1032->tFFFFFF98 = *((word32) eax_534 + 4);
				if (ebp_1032->tFFFFFFA8 > edi_988)
				{
					ebp_1032->t0008 = esi_1650;
					ebp_1032->tFFFFFF74.u0 = 0x080CFF4C;
					do
					{
						Eq_2 eax_2365 = ebp_1032->tFFFFFFB0;
						uint32 ebx_2368 = *((word32) eax_2365 + 4);
						Eq_2 edi_2366 = ebp_1032->tFFFFFF98;
						word32 ecx_2369 = Mem2364[ebp_1032 + -76:word32] + Mem2364[eax_2365 + 0x00:word32];
						Eq_2 eax_2370 = ebp_1032->t0008;
						ebp_1032->tFFFFFFA4 = ecx_2369;
						Eq_2 edx_2376 = *((word32) eax_2370 + 372);
						Eq_2 di_2381 = *((word32) edi_2366 + (ebx_2368 >> 0x08) * 0x02);
						Eq_2 esi_2379 = (word32) ebp_1032->tFFFFFFA0 + ((ebx_2368 >> 0x08) << 0x04);
						ebp_1032->tFFFFFFC4 = esi_2379;
						ebp_1032->tFFFFFF9C = di_2381;
						gs_2587 = gs;
						ebx_1005 = (word32) (byte) ebx_2368;
						if (ebx_1005 != 0x08)
						{
							if (ebx_1005 == 0x00)
							{
								ebp_1032->tFFFFFFB0 = (word32) ebp_1032->tFFFFFFB0 + 8;
								if (ebp_1032->tFFFFFFA8 <= ebp_1032->tFFFFFFB0)
									break;
								continue;
							}
							<anonymous> * edx_2632;
							Eq_2 edi_2411;
							Eq_2 edx_2408;
							ui32 ecx_2396 = (word32) *((word32) esi_2379 + 0x0C);
							if ((byte) ecx_2396 >> 0x04 == 0x00 || ((word32) (*((word32) esi_2379 + 0x0D)) & 0x03) <= 0x02)
							{
								edi_2411 = ebp_1032->t0008;
								Eq_2 ax_2413 = *((word32) esi_2379 + 0x0E);
								ebp_1032->tFFFFFF9C = ax_2413;
								edx_2408 = esi_2379;
								if (ax_2413 != ~0x0E)
									goto l0808E657;
								goto l0808E816;
							}
							Eq_2 edi_2464;
							if (esi_2379 != *((word32) ebp_1032->t0008 + 544))
							{
l0808E4B5:
								if (ebx_1005 != 0x07 && ebx_1005 != 0x23)
									goto l0808E4C7;
								edi_2464.u0 = 0x01;
								goto l0808E7E5;
							}
							Eq_2 edi_2427;
							if (ebx_1005 <= 0x25 && !__bt(0x70000081, ebx_1005 - 0x07))
							{
								ebp_1032->tFFFFFF70.u0 = 0x01;
								edi_2427 = *((word32) ebp_1032->t0008 + 0x0224);
								goto l0808EEA1;
							}
							Eq_119468 cl_2431 = (int8) (ebx_1005 == 0x29);
							ebp_1032->tFFFFFF70 = (word32) cl_2431;
							edi_2427 = *((word32) ebp_1032->t0008 + 0x0224);
							if (ebx_1005 != 0x05)
							{
								if (ebx_1005 == 0x06)
								{
									if (0x00 - (cl_2431 < 0x01) + 0x05 == edi_2427)
										goto l0808EEAD;
									edi_2464.u0 = 0x00;
									goto l0808E7F7;
								}
l0808EEA1:
								if (edi_2427 != ebp_1032->tFFFFFF70)
									goto l0808E4B5;
l0808EEAD:
								Eq_2 eax_2460 = ebp_1032->t0008;
								edx_2408 = *((word32) eax_2460 + 556);
								edi_2411 = *((word32) eax_2460 + 552);
								ebp_1032->tFFFFFFC4 = edx_2408;
							}
							else
							{
								if (0x00 - (cl_2431 < 0x01) + 0x03 == edi_2427)
									goto l0808EEAD;
l0808E4C7:
								byte cl_2496 = (byte) (ebx_1005 - 0x0E);
								if (ebx_1005 <= 0x29)
									edi_2464 = 0x08C00001 >> cl_2496 & 0x01;
								else
								{
									edi_2464.u0 = 0x00;
l0808E7E5:
									if (ebx_1005 != 0x05)
									{
										if (ebx_1005 == 0x06)
										{
l0808E7F7:
											edi_2464 |= 0x04;
										}
									}
									else
										edi_2464 |= 0x02;
								}
								Eq_2 eax_2518 = ebp_1032->tFFFFFF9C;
								Eq_2 ecx_2519 = ebp_1032->t0008;
								*((word32) ecx_2519 + 0x0224) = edi_2464;
								*((word32) ecx_2519 + 544) = esi_2379;
								Eq_2 edx_2537 = (word32) edx_2376 + ((eax_2518 & 0x7FFF) << 0x04);
								if (edx_2537 != 0x00 && *((word32) edx_2537 + 4) == 0x00)
									edx_2537.u0 = 0x00;
								struct Eq_119118 * esp_2559 = esp_1040 - (struct Eq_119119 *) 4;
								esp_2559->t0000.u0 = 0x00;
								esp_2559->tFFFFFFFC.u0 = 0x01;
								esp_2559->tFFFFFFF8 = edi_2464;
								esp_2559->tFFFFFFF4 = edx_2537;
								esp_2559->dwFFFFFFF0 = (word32) ebp_1032->t000C;
								esp_2559->ptrFFFFFFEC = ebp_1032 - 0x3C;
								Eq_2 eax_2576 = (word32) *esi_2379 + ebp_1032->dwFFFFFF90;
								esp_2559->tFFFFFFE8 = ebp_1032->t0008;
								esp_2559->tFFFFFFE4 = eax_2576;
								word32 ecx_4165;
								word32 edx_4166;
								Eq_2 eax_2596 = _dl_lookup_symbol_x(gs, esp_2559->tFFFFFFE4, esp_2559->tFFFFFFE8, esp_2559->ptrFFFFFFEC, esp_2559->dwFFFFFFF0, esp_2559->tFFFFFFF4, esp_2559->tFFFFFFF8, esp_2559->tFFFFFFFC, esp_2559->t0000, out ecx_4165, out edx_4166);
								edx_2408 = ebp_1032->tFFFFFFC4;
								Eq_2 eax_2608 = ebp_1032->t0008;
								*((word32) eax_2608 + 556) = edx_2408;
								*((word32) eax_2608 + 552) = eax_2596;
								edi_2411 = eax_2596;
							}
							esp_2150 = esp_1040;
							if (edx_2408 == 0x00)
							{
								if (ebx_1005 <= 0x2A)
								{
									Eq_2 eax_2805 = ebp_1032->tFFFFFFAC;
									word32 eax_2806 = eax_2805 + (eax_2805 + 4294858284)[ebx_1005 * 0x04];
									ptr32 eax_2808;
									ptr32 ecx_2809;
									word32 edx_2810;
									eax_2806();
									ecxOut = ecx_2809;
									dlOut.u0 = <invalid>;
									ebxOut = ebx_1005;
									ebpOut = ebp_1032;
									esiOut = esi_2379;
									ediOut = edi_2411;
									return eax_2808;
								}
								goto l0808FA81;
							}
							Eq_2 ax_2618 = *((word32) edx_2408 + 0x0E);
							ecx_2396 = (word32) *((word32) edx_2408 + 0x0C);
							ebp_1032->tFFFFFF9C = ax_2618;
							if (ax_2618 == ~0x0E)
							{
l0808E816:
								edx_2632 = (<anonymous> *) *((word32) edx_2408 + 4);
								if ((byte) (ecx_2396 & 0x0F) == 0x0A)
									goto l0808E830;
							}
							else
							{
l0808E657:
								edx_2632 = Mem2625[edi_2411 + 0x00:word32] + Mem2625[edx_2408 + 0x04:word32];
								if ((byte) (ecx_2396 & 0x0F) == 0x0A)
								{
l0808E830:
									if (ebp_1032->tFFFFFF9C != 0x00 && ebp_1032->dwFFFFFF88 == 0x00)
									{
										if (ebp_1032->t0008 != edi_2411)
										{
											Eq_49395 al_2717 = *((word32) edi_2411 + 408);
											if ((al_2717 & 0x03) != 0x00 && (al_2717 & 0x04) == 0x00)
											{
												Eq_2 eax_2724 = ebp_1032->t0008;
												word32 ecx_2725 = *esi_2379;
												ebp_1032->ptrFFFFFF6C = edx_2632;
												Eq_2 edx_2728 = ebp_1032->tFFFFFFAC;
												Eq_2 eax_2731 = *((word32) edi_2411 + 4);
												ebp_1032->tFFFFFF9C = (word32) *((word32) *((word32) eax_2724 + 52) + 4) + ecx_2725;
												ebp_1032->tFFFFFF70 = eax_2731;
												Eq_2 eax_2737 = **(union Eq_2 **) 135060900;
												if (eax_2737 == 0x00)
													eax_2737 = (word32) edx_2728 - 0x0001AAD3;
												Eq_2 ecx_2744 = ebp_1032->t0008;
												struct Eq_119390 * esp_2746 = esp_1040 - (struct Eq_119391 *) 0x08;
												esp_2746->tFFFFFFFC = ebp_1032->tFFFFFF9C;
												esp_2746->tFFFFFFF8 = ebp_1032->tFFFFFF70;
												esp_2746->tFFFFFFF4 = *((word32) ecx_2744 + 4);
												esp_2746->dwFFFFFFF0 = (word32) eax_2737;
												esp_2746->ptrFFFFFFEC = (word32) edx_2728 - 0x0001ABDC;
												esp_2746->tFFFFFFE8.u0 = 0x02;
												_dl_dprintf();
												edx_2632 = ebp_1032->ptrFFFFFF6C;
											}
										}
										word32 eax_2788;
										word32 ecx_2789;
										edx_2632();
										esp_2150 = esp_1040;
										if (ebx_1005 <= 0x2A)
										{
											Eq_2 eax_2796 = ebp_1032->tFFFFFFAC;
											word32 eax_2797 = eax_2796 + (eax_2796 + 4294858628)[ebx_1005 * 0x04];
											ptr32 eax_2799;
											ptr32 ecx_2800;
											word32 edx_2801;
											eax_2797();
											ecxOut = ecx_2800;
											dlOut.u0 = <invalid>;
											ebxOut = ebx_1005;
											ebpOut = ebp_1032;
											esiOut = esi_2379;
											ediOut = edi_2411;
											return eax_2799;
										}
										goto l0808FA81;
									}
								}
							}
							esp_2150 = esp_1040;
							if (ebx_1005 <= 0x2A)
							{
								Eq_2 eax_2674 = ebp_1032->tFFFFFFAC;
								word32 eax_2675 = eax_2674 + (eax_2674 + 4294858456)[ebx_1005 * 0x04];
								ptr32 eax_2710;
								ptr32 ecx_2711;
								word32 edx_2712;
								eax_2675();
								ecxOut = ecx_2711;
								dlOut.u0 = <invalid>;
								ebxOut = ebx_1005;
								ebpOut = ebp_1032;
								esiOut = esi_2379;
								ediOut = edi_2411;
								return eax_2710;
							}
							goto l0808FA81;
						}
						word32 eax_2385 = *eax_2370;
						ebp_1032->tFFFFFFB0 = (word32) ebp_1032->tFFFFFFB0 + 8;
						*ecx_2369 = (word32) *ecx_2369 + eax_2385;
					} while (ebp_1032->tFFFFFFA8 > ebp_1032->tFFFFFFB0);
					goto l0808E5A0;
				}
			}
			else
			{
				Eq_2 eax_539 = ebp_1032->tFFFFFFB0;
				if (ebp_1032->tFFFFFFA8 > eax_539)
				{
					ebp_1032->t0008 = esi_1650;
					ebp_1032->tFFFFFF98.u0 = 135060900;
					ebp_1032->tFFFFFF74.u0 = 0x080CFF4C;
					Eq_2 esi_549 = eax_539;
					do
					{
						Mem555[ebp_1032 + -80:word32] = Mem551[ebp_1032 + -76:word32] + Mem551[esi_549 + 0x00:word32];
						uint32 eax_556 = *((word32) esi_549 + 4);
						ebx_1005 = (word32) ebp_1032->tFFFFFFA0 + ((eax_556 >> 0x08) << 0x04);
						ebp_1032->tFFFFFFC4 = ebx_1005;
						edi_508 = (word32) (byte) eax_556;
						if (edi_508 != 0x08)
						{
							if (edi_508 == 0x00)
							{
								esi_549 = (word32) esi_549 + 8;
								if (ebp_1032->tFFFFFFA8 <= esi_549)
									break;
								continue;
							}
							Eq_2 ecx_799;
							Eq_2 ecx_597;
							ui32 edx_580 = (word32) *((word32) ebx_1005 + 0x0C);
							if ((byte) edx_580 >> 0x04 == 0x00)
							{
								ebp_1032->tFFFFFFA4 = ebp_1032->t0008;
								goto l0808F270;
							}
							Eq_2 eax_593 = ebp_1032->t0008;
							if (((word32) *((word32) ebx_1005 + 0x0D) & 0x03) <= 0x02)
							{
								ebp_1032->tFFFFFFA4 = eax_593;
l0808F270:
								Eq_2 ax_600 = *((word32) ebx_1005 + 0x0E);
								ebp_1032->tFFFFFF9C = ax_600;
								ecx_597 = ebx_1005;
								if (ax_600 != ~0x0E)
									goto l0808F282;
								goto l0808F3E6;
							}
							Eq_2 eax_637;
							if (ebx_1005 != *((word32) eax_593 + 544))
							{
l0808F0BE:
								if (edi_508 != 0x07 && edi_508 != 0x23)
									goto l0808F0D0;
								eax_637.u0 = 0x01;
								goto l0808F3AD;
							}
							Eq_2 edx_619;
							Eq_2 ecx_620;
							if (edi_508 <= 0x25 && !__bt(0x70000081, edi_508 - 0x07))
							{
								edx_619.u0 = 0x01;
								ecx_620 = *((word32) ebp_1032->t0008 + 0x0224);
								goto l0808F5B9;
							}
							Eq_121005 al_618 = (int8) (edi_508 == 0x29);
							edx_619 = (word32) al_618;
							ecx_620 = *((word32) ebp_1032->t0008 + 0x0224);
							if (edi_508 != 0x05)
							{
								if (edi_508 == 0x06)
								{
									if (0x00 - (al_618 < 0x01) + 0x05 == ecx_620)
										goto l0808F5C1;
									eax_637.u0 = 0x00;
									goto l0808F3BF;
								}
l0808F5B9:
								if (ecx_620 != edx_619)
									goto l0808F0BE;
l0808F5C1:
								Eq_2 eax_651 = ebp_1032->t0008;
								ecx_597 = *((word32) eax_651 + 556);
								Eq_2 eax_653 = *((word32) eax_651 + 552);
								ebp_1032->tFFFFFFC4 = ecx_597;
								ebp_1032->tFFFFFFA4 = eax_653;
							}
							else
							{
								if (0x00 - (al_618 < 0x01) + 0x03 == ecx_620)
									goto l0808F5C1;
l0808F0D0:
								byte cl_685 = (byte) (edi_508 - 0x0E);
								if (edi_508 <= 0x29)
									eax_637 = 0x08C00001 >> cl_685 & 0x01;
								else
								{
									eax_637.u0 = 0x00;
l0808F3AD:
									if (edi_508 != 0x05)
									{
										if (edi_508 == 0x06)
										{
l0808F3BF:
											eax_637 |= 0x04;
										}
									}
									else
										eax_637 |= 0x02;
								}
								Eq_2 ecx_708 = ebp_1032->t0008;
								*((word32) ecx_708 + 0x0224) = eax_637;
								*((word32) ecx_708 + 544) = ebx_1005;
								struct Eq_120880 * esp_730 = esp_1040 - (struct Eq_120881 *) 4;
								esp_730->t0000.u0 = 0x00;
								esp_730->tFFFFFFFC.u0 = 0x01;
								esp_730->tFFFFFFF8 = eax_637;
								esp_730->tFFFFFFF4.u0 = 0x00;
								esp_730->dwFFFFFFF0 = (word32) ebp_1032->t000C;
								esp_730->ptrFFFFFFEC = ebp_1032 - 0x3C;
								Eq_2 eax_745 = (word32) *ebx_1005 + ebp_1032->dwFFFFFF90;
								esp_730->tFFFFFFE8 = ecx_708;
								esp_730->tFFFFFFE4 = eax_745;
								word32 edx_4177;
								word32 ecx_4176;
								Eq_2 eax_763 = _dl_lookup_symbol_x(gs, esp_730->tFFFFFFE4, esp_730->tFFFFFFE8, esp_730->ptrFFFFFFEC, esp_730->dwFFFFFFF0, esp_730->tFFFFFFF4, esp_730->tFFFFFFF8, esp_730->tFFFFFFFC, esp_730->t0000, out ecx_4176, out edx_4177);
								Eq_2 edx_771 = ebp_1032->t0008;
								ecx_597 = ebp_1032->tFFFFFFC4;
								ebp_1032->tFFFFFFA4 = eax_763;
								*((word32) edx_771 + 556) = ecx_597;
								*((word32) edx_771 + 552) = eax_763;
							}
							esp_2150 = esp_1040;
							if (ecx_597 == 0x00)
							{
								if (edi_508 <= 0x2A)
								{
									Eq_2 eax_980 = ebp_1032->tFFFFFFAC;
									word32 eax_981 = eax_980 + (eax_980 + 4294858972)[edi_508 * 0x04];
									ptr32 eax_983;
									ptr32 ecx_984;
									word32 edx_985;
									eax_981();
									ecxOut = ecx_984;
									dlOut.u0 = <invalid>;
									ebxOut = ebx_1005;
									ebpOut = ebp_1032;
									esiOut = esi_549;
									ediOut = edi_508;
									return eax_983;
								}
								goto l0808FF17;
							}
							Eq_2 ax_785 = *((word32) ecx_597 + 0x0E);
							edx_580 = (word32) *((word32) ecx_597 + 0x0C);
							ebp_1032->tFFFFFF9C = ax_785;
							if (ax_785 == ~0x0E)
							{
l0808F3E6:
								ecx_799 = *((word32) ecx_597 + 4);
								if ((byte) (edx_580 & 0x0F) == 0x0A)
									goto l0808F400;
							}
							else
							{
l0808F282:
								ecx_799 = Mem791[Mem791[ebp_1032 + -92:word32] + 0x00:word32] + Mem791[ecx_597 + 0x04:word32];
								if ((byte) (edx_580 & 0x0F) == 0x0A)
								{
l0808F400:
									if (ebp_1032->dwFFFFFF88 == 0x00 && ebp_1032->tFFFFFF9C != 0x00)
									{
										Eq_2 eax_887 = ebp_1032->tFFFFFFA4;
										if (ebp_1032->t0008 != eax_887)
										{
											Eq_49395 al_891 = *((word32) eax_887 + 408);
											if ((al_891 & 0x03) != 0x00 && (al_891 & 0x04) == 0x00)
											{
												ebp_1032->tFFFFFF70 = ecx_799;
												Eq_2 ecx_903 = ebp_1032->tFFFFFFAC;
												Eq_2 eax_905 = ebp_1032->tFFFFFFA4;
												Mem906[ebp_1032 + -100:word32] = Mem899[ebx_1005 + 0x00:word32] + Mem899[Mem899[Mem899[ebp_1032 + 0x08:word32] + 0x34:word32] + 0x04:word32];
												Eq_2 edx_907 = *((word32) eax_905 + 4);
												Eq_2 eax_911 = **(union Eq_2 **) 135060900;
												if (eax_911 == 0x00)
													eax_911 = (word32) ecx_903 - 0x0001AAD3;
												struct Eq_120820 * esp_917 = esp_1040 - (struct Eq_120821 *) 0x08;
												Eq_2 ecx_921 = ebp_1032->tFFFFFFAC;
												esp_917->tFFFFFFFC = ebp_1032->tFFFFFF9C;
												esp_917->tFFFFFFF8 = edx_907;
												esp_917->tFFFFFFF4 = *((word32) ebp_1032->t0008 + 4);
												esp_917->dwFFFFFFF0 = (word32) eax_911;
												esp_917->ptrFFFFFFEC = (word32) ecx_921 - 0x0001ABDC;
												esp_917->tFFFFFFE8.u0 = 0x02;
												_dl_dprintf();
												ecx_799 = ebp_1032->tFFFFFF70;
											}
										}
										word32 eax_961;
										word32 edx_963;
										ecx_799();
										esp_2150 = esp_1040;
										if (edi_508 <= 0x2A)
										{
											Eq_2 eax_969 = ebp_1032->tFFFFFFAC;
											word32 eax_970 = eax_969 + (eax_969 + ~0x0001A5CB)[edi_508 * 0x04];
											ptr32 eax_972;
											ptr32 ecx_973;
											word32 edx_974;
											eax_970();
											ecxOut = ecx_973;
											dlOut.u0 = <invalid>;
											ebxOut = ebx_1005;
											ebpOut = ebp_1032;
											esiOut = esi_549;
											ediOut = edi_508;
											return eax_972;
										}
										goto l0808FF17;
									}
								}
							}
							esp_2150 = esp_1040;
							if (edi_508 <= 0x2A)
							{
								Eq_2 eax_844 = ebp_1032->tFFFFFFAC;
								word32 eax_845 = eax_844 + (eax_844 + 4294859144)[edi_508 * 0x04];
								ptr32 eax_883;
								ptr32 ecx_884;
								word32 edx_885;
								eax_845();
								ecxOut = ecx_884;
								dlOut.u0 = <invalid>;
								ebxOut = ebx_1005;
								ebpOut = ebp_1032;
								esiOut = esi_549;
								ediOut = edi_508;
								return eax_883;
							}
							goto l0808FF17;
						}
						Eq_2 edi_567 = ebp_1032->tFFFFFFB0;
						Mem571[edi_567 + 0x00:word32] = Mem563[edi_567 + 0x00:word32] + Mem563[Mem563[ebp_1032 + 0x08:word32] + 0x00:word32];
						esi_549 = (word32) esi_549 + 8;
					} while (ebp_1032->tFFFFFFA8 > esi_549);
l0808E5A0:
					esi_1650 = ebp_1032->t0008;
					goto l0808E5A3;
				}
			}
l0808E5A3:
			Eq_2 eax_2817 = *esi_1650;
			ebp_1032->tFFFFFF94 = (word32) ebp_1032->tFFFFFF94 + 16;
			ebp_1032->tFFFFFFB4 = eax_2817;
			if (ebp_1032->tFFFFFF94 == ebp_1032->tFFFFFF84)
				goto l0808DEB7;
			goto l0808E5B8;
		}
		dwLoc78_3471.u0 = 0x00;
	}
	if (**((word32) dwArg04 + 4) == 0x00)
		**(union Eq_2 **) 135060900 != 0x00;
	word32 ecx_4178;
	word32 edx_4179;
	_dl_debug_printf(out ecx_4178, out edx_4179);
l0808DD24:
	esp_1040 = fp - 0x9C;
	if (*((word32) dwArg04 + 0x0078) == 0x00)
		goto l0808DD35;
	edx_140 = (struct Eq_49300 *) *((word32) dwArg04 + 340);
	ecx_139 = (word32) *((word32) dwArg04 + 348);
	ebx_142 = edx_140;
	if (edx_140 >= edx_140 + (ecx_139 << 0x05) / 32)
	{
l0808DD35:
		if (*((word32) dwArg04 + 0x007C) != null && dwLoc78_3471 != 0x00)
		{
			struct Eq_117270 * edx_275 = *((word32) *((word32) dwArg04 + 44) + 4);
			Eq_2 ecx_277 = edx_275->t0004;
			uint32 eax_278 = g_dw80CFF1C;
			if (ecx_277 != 0x00)
			{
				Mem284[dwArg04 + 0x0214:word32] = ecx_277 + Mem264[dwArg04 + 0x00:word32];
				*((word32) dwArg04 + 536) = &edx_275->ptr0008 + 1;
			}
			edx_275->t0004 = dwArg04;
			if (dwArg10 == 0x00)
			{
				dwLoc78_3471.u0 = 0x01;
				ptr32 eax_343 = 0x08092630;
				if ((eax_278 & 0x02) != 0x00)
					eax_343 = 0x08092660;
				edx_275->ptr0008 = eax_343;
			}
			else
			{
				dwLoc78_3471.u0 = 0x01;
				ptr32 eax_302 = 0x080926E0;
				if ((eax_278 & 0x02) != 0x00)
					eax_302 = 0x08092690;
				edx_275->ptr0008 = eax_302;
				Eq_2 eax_310 = _dl_profile;
				if (eax_310 != 0x00)
				{
					struct Eq_117329 * esp_319 = esp_1040 - 0x08;
					esp_319->tFFFFFFFC = dwArg04;
					esp_319->tFFFFFFF8 = eax_310;
					esp_1040 = (struct Eq_117186 *) ((char *) &esp_319->tFFFFFFFC + 0x0C);
					word32 ecx_4147;
					if (_dl_name_match_p(esp_319->tFFFFFFF8, esp_319->tFFFFFFFC, out ecx_4147) != 0x00)
						_dl_profile_map = dwArg04;
				}
			}
		}
		goto l0808DD97;
	}
l0808F747:
	esp_1040 = fp - 0x9C;
	struct Eq_117404 * dwLoc88_3491 = null;
	do
	{
		if (ebx_142->dw0000 == 0x01 && (ebx_142->t0018 & 0x02) == 0x00)
		{
			struct Eq_117424 * esp_174 = esp_1040 - 0x20;
			esp_174[7] = esp_174[7];
			Eq_2 ecx_183 = _dl_pagesize;
			ui32 edx_190 = -ecx_183;
			ui32 eax_192 = ebx_142->dw0008 & edx_190;
			word32 esi_191 = esp_174 + 0x0F & ~0x0F;
			Eq_2 edx_199 = (edx_190 & ((word32) ecx_183 + (ebx_142->dw0008 - 0x01)) + ebx_142->dw0014) - eax_192;
			Eq_2 eax_203 = (word32) *dwArg04 + eax_192;
			esi_191->t0004 = edx_199;
			esi_191->t0000 = eax_203;
			esp_174->tFFFFFFF8.u0 = 0x03;
			esp_174->tFFFFFFF4 = edx_199;
			esp_174->dwFFFFFFF0 = (word32) eax_203;
			esp_1040 = esp_174 + 0x04;
			word32 edx_4149;
			word32 ecx_4148;
			if (mprotect(gs, esp_174->dwFFFFFFF0, esp_174->tFFFFFFF4, esp_174->tFFFFFFF8, out ecx_4148, out edx_4149) < 0x00)
			{
				eax_229.u0 = 0x080B33D0;
				while (true)
				{
					struct Eq_117619 * esp_2876 = esp_1040 - (struct Eq_117620 *) 4;
					esp_2876->t0000 = eax_229;
					esp_2876->tFFFFFFFC.u0 = 0x00;
					esp_2876->tFFFFFFF8 = *((word32) edi_20 + 4);
					esp_2876->tFFFFFFF4 = gs->tFFFFFFE0;
					word32 edx_4151;
					word32 ebx_4152;
					word32 ecx_4150;
					_dl_signal_error(gs, esp_2876->tFFFFFFF4, esp_2876->t0000, out ecx_4150, out edx_4151, out ebx_4152, out ebp_1032, out edi_20);
					esp_1040 = esp_2876 - (struct Eq_117656 *) 0x10;
l0808FF3E:
					eax_229 = (word32) ebp_1032->tFFFFFFAC - 0x0001AC04;
				}
			}
			edx_140 = (struct Eq_49300 *) *((word32) dwArg04 + 340);
			ecx_139 = (word32) *((word32) dwArg04 + 348);
			esi_191->dw0008 = 1934713408 >> (byte) ((ebx_142->t0018 & 0x07) << 0x02) & 0x0F;
			esi_191->ptr000C = dwLoc88_3491;
			dwLoc88_3491 = esi_191;
		}
		++ebx_142;
	} while (ebx_142 < edx_140 + (ecx_139 << 0x05) / 32);
	goto l0808DD35;
}

// 0808FF70: Register Eq_2 _dl_important_hwcaps(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack (ptr32 ui32) dwArg0C, Register out ptr32 ebxOut)
// Called from:
//      _dl_init_paths
Eq_2 _dl_important_hwcaps(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ui32 * dwArg0C, ptr32 & ebxOut)
{
	uint32 dwLoc44_1295;
	__tunable_get_val(0x10, fp - 0x24, null);
	ui32 edi_43 = g_dw80CF8C8;
	ui32 eax_45 = g_dw80CF8CC;
	uint32 edi_48 = edi_43 & dwLoc24;
	uint32 eax_51 = eax_45 & dwLoc20;
	struct Eq_121169 * ebp_1084 = fp - 4;
	struct Eq_121172 * esp_1259 = fp - 0x7C;
	uint32 dwLoc4C_1292 = edi_48;
	uint32 dwLoc48_1293 = eax_51;
	uint32 ebx_1253 = (uint32) (int8) (dwArg04 != 0x00);
	if ((eax_51 | edi_48) != 0x00)
	{
		uip32 ecx_1788 = 0x00;
		do
		{
			uint32 eax_75 = ebx_1253 + 0x01;
			byte cl_82 = (byte) ecx_1788;
			dwLoc44_1295 = eax_75;
			uint32 eax_83 = __shrd(edi_48, eax_51, cl_82);
			uint32 edx_84 = eax_51 >> cl_82;
			if ((cl_82 & 0x20) != 0x00)
				eax_83 = edx_84;
			if ((eax_83 & 0x01) != 0x00)
			{
				ebx_1253 = eax_75;
				dwLoc44_1295 = ebx_1253 + 0x02;
			}
			byte cl_107 = (byte) (ecx_1788 + 0x01);
			ui32 edx_108 = __shld(~0x00, ~0x00, cl_107);
			ui32 eax_109 = ~0x00 << cl_107;
			if ((cl_107 & 0x20) != 0x00)
			{
				edx_108 = eax_109;
				eax_109 = 0x00;
			}
			++ecx_1788;
		} while ((edx_108 & eax_51 | eax_109 & edi_48) != 0x00);
	}
	else
		dwLoc44_1295 = ebx_1253 + 0x01;
	uint32 dwLoc40_1520;
	uint32 dwLoc3C_1376;
	uint32 eax_609;
	uint32 ecx_329;
	struct Eq_121172 * edi_328;
	Eq_2 eax_142 = _dl_sysinfo_map;
	if (eax_142 != 0x00)
	{
		struct Eq_49300 * eax_185 = *((word32) eax_142 + 340);
		word32 edi_186 = (word32) *((word32) eax_142 + 348);
		if (edi_186 != 0x00)
		{
			struct Eq_49300 * ecx_191 = eax_185;
			word32 dwLoc40_1311 = 0x00;
			do
			{
				if (ecx_191->dw0000 == 0x04)
				{
					uint32 eax_197 = ecx_191->dw001C;
					uint32 dwLoc54_1312 = eax_197;
					if (eax_197 > 0x03)
					{
						if ((eax_197 - 0x04 & ~0x04) == 0x00)
							goto l080900AF;
					}
					else
					{
						dwLoc54_1312 = 0x04;
l080900AF:
						struct Eq_121346 * esi_215 = (word32) *eax_142 + ecx_191->dw0008;
						ptr32 eax_214 = ecx_191->dw0014;
						int32 ebx_216 = 0x0C - esi_215;
						if (eax_214 > 0x0C)
						{
							ui32 edi_234 = -dwLoc54_1312;
							word32 dwLoc34_1326 = dwLoc54_1312 + 11;
							do
							{
								word32 eax_242 = esi_215->dw0000;
								Eq_121372 edx_243 = esi_215->t0004;
								if (esi_215->dw0008 == 0x02 && (eax_242 == 0x04 && (esi_215->dw000C == 5590599 && edx_243 > 0x0A)))
								{
									struct Eq_121400 * ecx_339 = esi_215 + (dwLoc54_1312 + 0x0F & edi_234) / 16;
									uint32 v21_341 = dwLoc44_1295 + ecx_339->dw0000;
									ui32 eax_346 = v21_341 * 0x08 + 0x0F;
									dwLoc44_1295 = v21_341;
									struct Eq_121172 * edi_349 = fp - 0x7C - (eax_346 & ~0x0FFF);
									if (fp - 0x7C != edi_349)
									{
										do
										{
											esp_1259 -= 0x1000;
											esp_1259->dw0FFC = esp_1259->dw0FFC;
										} while (esp_1259 != edi_349);
									}
									int32 eax_366 = eax_346 & ~0x0F & 0x0FFF;
									if (eax_366 != 0x00)
									{
										esp_1259 -= eax_366;
										(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1259 - 0x04)[eax_366 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1259 - 0x04)[eax_366 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
									}
									ui32 eax_381 = ecx_339->dw0004;
									g_dw80CF8C8 = edi_43;
									g_dw80CF8CC = eax_45 | eax_381 << 0x12;
									struct Eq_121449 * esp_388 = esp_1259 - 0x08;
									esp_388->tFFFFFFFC = fp - 0x24;
									esp_388->dwFFFFFFF8 = 0x10;
									__tunable_set_val(esp_388->dwFFFFFFF8, esp_388->tFFFFFFFC);
									esp_1259 = (struct Eq_121172 *) ((char *) &esp_388->tFFFFFFFC + 8);
									ecx_329 = 0x01;
									dwLoc3C_1376 = 0x00;
									word32 eax_430 = ecx_339 + edx_243;
									if (&ecx_339->dw0004 + 1 < eax_430)
									{
										uint32 edi_435 = 0x00;
										byte * esi_438 = &ecx_339->dw0004 + 1;
										do
										{
											struct Eq_121172 * esp_439 = esp_1259 - 0x04;
											Eq_2 ebx_443 = esi_438 + 1;
											esp_439->tFFFFFFF0 = ebx_443;
											word32 edx_1793;
											word32 ecx_1792;
											Eq_2 eax_446 = strlen(esp_439->tFFFFFFF0, out ecx_1792, out edx_1793);
											esp_1259 = esp_439;
											uint32 edx_457 = edi_435 + 0x01;
											if ((eax_381 & 0x01 << *esi_438) != 0x00)
											{
												struct Eq_121497 * ecx_469 = esp_1259 + (edi_435 * 0x08) / 0x00001000;
												ecx_469->t0000 = ebx_443;
												ecx_469->t0004 = eax_446;
												ecx_329 = edi_435 + 0x02;
												edi_435 = edx_457;
											}
											else
											{
												--dwLoc44_1295;
												ecx_329 = edx_457;
											}
											esi_438 = (word32) eax_446 + ((word32) ebx_443 + 1);
										} while (esi_438 < eax_430);
										dwLoc3C_1376 = edi_435;
									}
									edi_328 = esp_1259;
									if ((eax_51 | edi_48) != 0x00)
										goto l08090224;
									goto l08090353;
								}
								esi_215 += ((eax_242 + dwLoc34_1326 & edi_234) + ((word32) edx_243 + (dwLoc54_1312 - 0x01)) & edi_234) / 16;
							} while (esi_215 + ebx_216 / 16 < eax_214);
							word32 v27_273 = dwLoc40_1311 + 0x01;
							dwLoc40_1311 = v27_273;
							++ecx_191;
							if (edi_186 == v27_273)
								break;
							continue;
						}
					}
				}
				word32 v26_222 = dwLoc40_1311 + 0x01;
				dwLoc40_1311 = v26_222;
				++ecx_191;
			} while (edi_186 != v26_222);
		}
		ui32 edx_289 = dwLoc44_1295 * 0x08 + 0x0F;
		struct Eq_121172 * edi_292 = fp - 0x7C - (edx_289 & ~0x0FFF);
		if (fp - 0x7C != edi_292)
		{
			do
			{
				esp_1259 -= 0x1000;
				esp_1259->dw0FFC = esp_1259->dw0FFC;
			} while (esp_1259 != edi_292);
		}
		int32 eax_308 = edx_289 & ~0x0F & 0x0FFF;
		if (eax_308 != 0x00)
		{
			esp_1259 -= eax_308;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1259 - 0x04)[eax_308 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1259 - 0x04)[eax_308 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
	}
	else
	{
		ui32 eax_154 = dwLoc44_1295 * 0x08 + 0x0F;
		struct Eq_121172 * edi_157 = fp - 0x7C - (eax_154 & ~0x0FFF);
		if (fp - 0x7C != edi_157)
		{
			do
			{
				esp_1259 -= 0x1000;
				esp_1259->dw0FFC = esp_1259->dw0FFC;
			} while (esp_1259 != edi_157);
		}
		int32 edx_173 = eax_154 & ~0x0F & 0x0FFF;
		if (edx_173 != 0x00)
		{
			esp_1259 -= edx_173;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1259 - 0x04)[edx_173 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_1259 - 0x04)[edx_173 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
	}
	edi_328 = esp_1259;
	ecx_329 = 0x01;
	dwLoc3C_1376 = 0x00;
	if ((eax_51 | edi_48) == 0x00)
	{
l08090353:
		dwLoc40_1520 = dwLoc3C_1376;
		if (dwArg04 == 0x00)
			goto l08090360;
	}
	else
	{
l08090224:
		ui32 ebx_507 = 0x00;
		uint32 esi_1248 = dwLoc3C_1376 + 0x01;
		while (true)
		{
			while (true)
			{
				byte cl_523 = (byte) ebx_507;
				dwLoc40_1520 = esi_1248;
				uint32 eax_524 = __shrd(dwLoc4C_1292, dwLoc48_1293, cl_523);
				uint32 edx_525 = dwLoc48_1293 >> cl_523;
				if (((byte) ebx_507 & 0x20) != 0x00)
					eax_524 = edx_525;
				if ((eax_524 & 0x01) != 0x00)
					break;
				++ebx_507;
			}
			ui32 eax_546 = ebx_507 * 0x09;
			struct Eq_121566 * edx_549 = edi_328 + (dwLoc3C_1376 * 0x08) / 0x00001000;
			edx_549->dw0000 = eax_546 + 0x080A4804;
			struct Eq_121575 * esp_545 = esp_1259 - 0x0C;
			esp_545->tFFFFFFFC = eax_546 + 0x080A4804;
			word32 ecx_1794;
			word32 edx_1795;
			edx_549->t0004 = strlen(esp_545->tFFFFFFFC, out ecx_1794, out edx_1795);
			byte cl_567 = (byte) ebx_507;
			esp_1259 = (struct Eq_121172 *) ((char *) &esp_545->tFFFFFFFC + 16);
			ui32 edx_568 = __shld(0x00, 0x01, cl_567);
			ui32 eax_569 = 0x01 << cl_567;
			if ((cl_567 & 0x20) != 0x00)
			{
				edx_568 = eax_569;
				eax_569 = 0x00;
			}
			uint32 eax_587 = eax_569 ^ dwLoc4C_1292;
			uint32 eax_590 = edx_568 ^ dwLoc48_1293;
			++ebx_507;
			ecx_329 = dwLoc3C_1376 + 0x02;
			if ((eax_590 | eax_587) == 0x00)
				break;
			dwLoc3C_1376 = esi_1248;
			++esi_1248;
			dwLoc48_1293 = eax_590;
			dwLoc4C_1292 = eax_587;
		}
		if (dwArg04 == 0x00)
		{
l08090360:
			eax_609 = ecx_329;
			ecx_329 = dwLoc40_1520;
l080903EE:
			struct Eq_121634 * edx_631 = edi_328 + (ecx_329 * 0x08) / 0x00001000;
			edx_631->dw0004 = 0x03;
			edx_631->ptr0000 = 0x080B3B60;
			if (dwLoc44_1295 != eax_609)
			{
				struct Eq_121661 * esp_646 = esp_1259 - 4;
				esp_646->ptr0000 = 0x080B3B98;
				esp_646->dwFFFFFFFC = 0xB8;
				esp_646->ptrFFFFFFF8 = 0x080B3B64;
				esp_646->ptrFFFFFFF4 = 0x080B3B70;
				word32 edx_657;
				word32 ecx_1796;
				__assert_fail(out ecx_1796, out edx_657);
				ptr32 ebx_698;
				word32 ecx_1809;
				word32 edx_1810;
				Eq_2 eax_694 = _dl_debug_vdprintf(&g_t80B3B60, edx_657, gs, dwArg04, out ecx_1809, out edx_1810, out ebx_698);
				ebxOut = ebx_698;
				return eax_694;
			}
			Eq_2 ecx_1242;
			struct Eq_121687 * edi_1061;
			Eq_2 eax_1075;
			ptr32 esp_866;
			word32 eax_705 = edi_328->dw0004;
			if (dwLoc44_1295 == 0x01)
			{
				*dwArg0C = 0x02;
				struct Eq_121700 * esp_710 = esp_1259 - 0x0C;
				esp_710->tFFFFFFFC = eax_705 + 0x11;
				union Eq_2 * edi_722;
				word32 edx_1798;
				word32 ebx_1799;
				word32 ecx_1797;
				Eq_2 eax_718 = __libc_malloc(gs, esp_710->tFFFFFFF8, esp_710->tFFFFFFFC, out ecx_1797, out edx_1798, out ebx_1799, out ebp_1084, out ecx_1242, out edi_722);
				ebp_1084->tFFFFFFD0 = eax_718;
				if (eax_718 != 0x00)
				{
					Eq_2 esi_734 = ebp_1084->tFFFFFFD0;
					Eq_2 ebx_735 = ebp_1084->tFFFFFFB8;
					*((word32) esi_734 + 0x0C) = 0x00;
					*esi_734 = (word32) esi_734 + 16;
					*((word32) esi_734 + 4) = (word32) ebx_735 + 1;
					*((word32) esi_734 + 8) = (word32) esi_734 + 16;
					esp_710->t0004 = ebx_735;
					esp_710->t0000 = *edi_722;
					esp_710->tFFFFFFFC = (word32) esi_734 + 16;
					word32 edx_1808;
					Eq_2 eax_752 = __mempcpy(esp_710->tFFFFFFFC, esp_710->t0000, esp_710->t0004, out edx_1808);
					word32 * edi_760 = ebp_1084->ptr0014;
					*eax_752 = 0x2F;
					*ebp_1084->ptr0010 = 0x02;
					*edi_760 = (word32) *((word32) esi_734 + 4);
					Eq_2 eax_768 = ebp_1084->tFFFFFFD0;
					ebxOut = ebp_1084->ptrFFFFFFF4;
					return eax_768;
				}
				goto l080906C6;
			}
			ui32 edx_786 = (char *) &(*((char *) &(edi_328 + (dwLoc44_1295 * 0x08) / 0x00001000)->tFFFFFFF0 + 0x0C))->tFFFFFFF0 + 18 + eax_705;
			if (dwLoc44_1295 > 0x02)
			{
				ui32 edx_790 = edx_786 * 0x02;
				uint32 eax_791 = 0x00;
				ecx_1242 = dwLoc44_1295 - 0x01;
				do
				{
					++eax_791;
					edx_790 = edx_790 + 0x01 + ((edi_328->a000C))[eax_791].dw0000;
				} while (dwLoc44_1295 - 0x02 != eax_791);
				if (dwLoc44_1295 != 0x03 && (dwLoc44_1295 > 0x1F || edx_790 + 0x40 >> (byte) (0x23 - dwLoc44_1295) != 0x00))
				{
l080906C6:
					struct Eq_121817 * esp_877 = esp_1259 - 4;
					esp_877->t0000 = (word32) ebp_1084->tFFFFFFD4 - 107655;
					esp_877->dwFFFFFFFC = 0x00;
					esp_877->dwFFFFFFF8 = 0x00;
					esp_877->tFFFFFFF4.u0 = 0x0C;
					word32 edx_1804;
					word32 ecx_1803;
					word32 ebx_1805;
					eax_1075 = _dl_signal_error(gs, esp_877->tFFFFFFF4, esp_877->t0000, out ecx_1803, out edx_1804, out ebx_1805, out ebp_1084, out edi_1061);
					esp_866 = esp_877 - 0x10;
					goto l080906DB;
				}
				edx_786 = edx_790 << (byte) (dwLoc44_1295 - 0x03);
			}
			*dwArg0C = 0x01 << (byte) dwLoc44_1295;
			struct Eq_121750 * esp_834 = esp_1259 - 0x0C;
			esp_834->tFFFFFFFC = edx_786 + (0x08 << (byte) dwLoc44_1295);
			word32 ebx_1802;
			word32 ecx_1800;
			word32 edx_1801;
			Eq_2 eax_855 = __libc_malloc(gs, esp_834->tFFFFFFF8, esp_834->tFFFFFFFC, out ecx_1800, out edx_1801, out ebx_1802, out ebp_1084, out ecx_1242, out edi_1061);
			Eq_2 ecx_867 = ebp_1084->tFFFFFFB0;
			ebp_1084->tFFFFFFD0 = eax_855;
			esp_866 = (char *) &esp_834->tFFFFFFFC + 16;
			if (eax_855 != 0x00)
			{
				Eq_2 ebx_898 = ebp_1084->tFFFFFFD0;
				eax_1075 = ebx_898 + ecx_867;
				*ebx_898 = eax_1075;
				*((word32) ebx_898 + 8) = eax_1075;
				ebp_1084->tFFFFFFB0 = edi_1061->a0000[0];
				ui32 edx_904 = 0x01 << (byte) ecx_1242;
				if (ebp_1084->dwFFFFFFC0 != 0x02)
				{
					struct Eq_121687 * ebx_958 = ebp_1084->ptrFFFFFFC8;
					ebp_1084->tFFFFFFA4 = ecx_1242;
					ebp_1084->tFFFFFFAC = ebx_958->tFFFFFFF8;
					ebp_1084->dwFFFFFFC0 -= 0x02;
					ui32 esi_1056 = edx_904;
					do
					{
						struct Eq_122251 * esp_969 = esp_1259 - 0x04;
						esp_969->tFFFFFFFC = ebp_1084->tFFFFFFB4;
						esp_969->tFFFFFFF8 = ebp_1084->tFFFFFFAC;
						esp_969->tFFFFFFF4 = eax_1075;
						word32 edx_1813;
						Eq_2 eax_985 = __mempcpy(esp_969->tFFFFFFF4, esp_969->tFFFFFFF8, esp_969->tFFFFFFFC, out edx_1813);
						ui32 ecx_993 = ebp_1084->dwFFFFFFC0;
						*eax_985 = 0x2F;
						ui32 esi_977 = esi_1056 - 0x02;
						struct Eq_121687 * edx_1017 = edi_1061;
						Eq_2 eax_1028 = (word32) eax_985 + 1;
						ui32 esi_1001 = ecx_993;
						do
						{
							if ((0x01 << (byte) esi_1001 & esi_977) != 0x00)
							{
								struct Eq_122159 * esp_1015 = esp_1259 - 0x04;
								esp_1015->tFFFFFFFC = edx_1017->a0004[esi_1001].t0000;
								esp_1015->tFFFFFFF8 = edx_1017[esi_1001 * 0x08 / 16];
								esp_1015->tFFFFFFF4 = eax_1028;
								ebp_1084->ptrFFFFFFC8 = edx_1017;
								word32 edx_1811;
								Eq_2 eax_1031 = __mempcpy(esp_1015->tFFFFFFF4, esp_1015->tFFFFFFF8, esp_1015->tFFFFFFFC, out edx_1811);
								edx_1017 = ebp_1084->ptrFFFFFFC8;
								*eax_1031 = 0x2F;
								eax_1028 = (word32) eax_1031 + 1;
								--esi_1001;
								if (esi_1001 == 0x00)
									break;
								continue;
							}
							--esi_1001;
						} while (esi_1001 != 0x00);
						struct Eq_122211 * esp_1047 = esp_1259 - 0x04;
						esp_1047->tFFFFFFFC = ebp_1084->tFFFFFFB8;
						esp_1047->tFFFFFFF8 = ebp_1084->tFFFFFFB0;
						esp_1047->tFFFFFFF4 = eax_1028;
						word32 edx_1812;
						Eq_2 eax_1065 = __mempcpy(esp_1047->tFFFFFFF4, esp_1047->tFFFFFFF8, esp_1047->tFFFFFFFC, out edx_1812);
						*eax_1065 = 0x2F;
						esi_1056 = esi_977;
						edi_1061 = edx_1017;
						eax_1075 = (word32) eax_1065 + 1;
					} while (esi_977 != 0x00);
					ecx_1242 = ebp_1084->tFFFFFFA4;
					if (ebp_1084->dwFFFFFFC4 == 0x00)
					{
l080905B7:
						while (true)
						{
							uint32 edi_1113 = ebp_1084->dwFFFFFFC4;
							Eq_2 edx_1115 = ebp_1084->tFFFFFFD0;
							ui32 ebx_1117 = 0x01 << (byte) ecx_1242;
							uint32 eax_1118 = edi_1113;
							Eq_2 ecx_1123 = ecx_1242;
							if (edi_1113 != 0x00)
							{
								ebp_1084->tFFFFFFD4 = ecx_1242;
								do
								{
									--eax_1118;
									edx_1115 = (word32) edx_1115 + 8;
									while ((ebx_1117 & eax_1118) != 0x00)
									{
										edx_1115 = (word32) edx_1115 + 8;
										*((word32) edx_1115 - 0x0C) = (word32) edi_1061->a0004[ebp_1084->tFFFFFFD4].t0000 + ((word32) (*((word32) edx_1115 - 4)) + 1);
										--eax_1118;
									}
								} while (eax_1118 != 0x00);
								ecx_1123 = ebp_1084->tFFFFFFD4;
							}
							if (ecx_1123 == 0x00)
								break;
							ecx_1242 = ecx_1123 - 0x01;
						}
						uint32 eax_1165 = ebp_1084->dwFFFFFFC4;
						Eq_2 eax_1168 = ebp_1084->tFFFFFFD0;
						uint32 ebx_1167 = eax_1165 - 0x02;
						struct Eq_122314 * edx_1169 = (word32) eax_1168 + 16;
						uint32 eax_1172 = 0x01 << ebp_1084->bFFFFFFA8;
						if (eax_1165 - 0x02 != eax_1172)
						{
							struct Eq_122347 * ecx_1175 = (word32) eax_1168 + 16;
							do
							{
								--ebx_1167;
								if (((byte) ebx_1167 & 0x01) == 0x00)
								{
									++ecx_1175;
									ecx_1175->dwFFFFFFF8 = ecx_1175->dwFFFFFFF8;
									if (ebx_1167 == eax_1172)
										break;
									continue;
								}
								++ecx_1175;
								ecx_1175->dwFFFFFFF8 = ecx_1175->dwFFFFFFF4 + ecx_1175->dwFFFFFFF0;
							} while (ebx_1167 != eax_1172);
							edx_1169 = (word32) eax_1168 + (ebp_1084->dwFFFFFFC4 - eax_1172) * 0x08;
						}
						byte cl_1211 = ebp_1084->bFFFFFFA8;
						Eq_2 esi_1209 = ebp_1084->tFFFFFFB4;
						do
						{
							++edx_1169;
							edx_1169->dwFFFFFFF8 = edx_1169[(~0x07 << cl_1211) / 8].a0000 + ((word32) esi_1209 + 1) / 4;
							--eax_1172;
						} while (eax_1172 != 0x00);
						*ebp_1084->ptr0014 = (word32) *((word32) ebp_1084->tFFFFFFD0 + 4);
						Eq_2 eax_1232 = ebp_1084->tFFFFFFD0;
						ebxOut = ebp_1084->ptrFFFFFFF4;
						return eax_1232;
					}
l0809059A:
					uint32 edx_1086 = ebp_1084->dwFFFFFFC4;
					Eq_2 ecx_1087 = ebp_1084->tFFFFFFD0;
					uint32 eax_1088 = 0x00;
					do
					{
						*((word32) ecx_1087 + (eax_1088 * 0x08 + 4)) = 0x00;
						++eax_1088;
					} while (eax_1088 < edx_1086);
					goto l080905B7;
				}
l080906DB:
				struct Eq_121956 * esp_911 = esp_866 - 0x04;
				esp_911->tFFFFFFFC = edi_1061->t000C;
				esp_911->tFFFFFFF8 = edi_1061->t0008;
				esp_911->tFFFFFFF4 = eax_1075;
				word32 edx_1806;
				Eq_2 eax_926 = __mempcpy(esp_911->tFFFFFFF4, esp_911->tFFFFFFF8, esp_911->tFFFFFFFC, out edx_1806);
				*eax_926 = 0x2F;
				esp_911->tFFFFFFFC = ebp_1084->tFFFFFFB8;
				esp_911->tFFFFFFF8 = ebp_1084->tFFFFFFB0;
				esp_911->tFFFFFFF4 = (word32) eax_926 + 1;
				word32 edx_1807;
				*__mempcpy(esp_911->tFFFFFFF4, esp_911->tFFFFFFF8, esp_911->tFFFFFFFC, out edx_1807) = 0x2F;
				goto l0809059A;
			}
			goto l080906C6;
		}
	}
	struct Eq_121622 * eax_620 = edi_328 + (dwLoc40_1520 * 0x08) / 0x00001000;
	eax_620->t0000 = dwArg04;
	eax_620->t0004 = dwArg08;
	eax_609 = ecx_329 + 0x01;
	goto l080903EE;
}

// 08090790: Register Eq_2 _dl_debug_vdprintf(Register (ptr32 Eq_122143) ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out (ptr32 Eq_122143) ebxOut)
// Called from:
//      _dl_important_hwcaps
//      _dl_debug_printf
//      _dl_debug_printf_c
//      _dl_dprintf
Eq_2 _dl_debug_vdprintf(struct Eq_122143 * ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & ecxOut, ptr32 & edxOut, struct Eq_122143 & ebxOut)
{
	int32 esi_101 = 0x00;
	struct Eq_122143 * ebx_110 = ecx;
	struct Eq_122442 * esp_154 = fp - 0x025C;
	byte al_107 = ecx->b0000;
	int32 dwLoc0234_1026 = 0x00;
	word32 dwLoc0230_1002 = edx;
	if (al_107 == 0x00)
	{
l0809086F:
		ptr32 ecx_680;
		Eq_2 eax_681;
		ptr32 edx_682;
		gs->ptr0010();
		ecxOut = ecx_680;
		edxOut = edx_682;
		ebxOut = ebx;
		return eax_681;
	}
l080907E0:
	struct Eq_122143 * edx_111;
	struct Eq_122462 * ebp_133;
	ptr32 esp_254;
	ptr32 edi_247;
	if (dwLoc0230_1002 != 0x01)
	{
		if (al_107 != 0x25)
			goto l080907F5;
		goto l080908F8;
	}
	while (true)
	{
		ebp_133 = fp - 4;
		if (dwLoc0234_1026 == 0x00)
		{
			int32 eax_146 = getpid(gs);
			dwLoc0234_1026 = eax_146;
			if (eax_146 < 0x00)
			{
				word32 ecx_1153;
				word32 edx_1154;
				__assert_fail(out ecx_1153, out edx_1154);
				ptr32 ecx_197;
				ptr32 edx_198;
				Eq_2 eax_196 = _dl_sysdep_read_whole_file(gs, 0x080B3BE4, &g_u80B3BAD, 0x62, out ecx_197, out edx_198);
				ecxOut = ecx_197;
				edxOut = edx_198;
				ebxOut = ebx_110;
				return eax_196;
			}
			word32 ebp_1156;
			word32 edi_1157;
			word32 ebx_1155;
			Eq_2 eax_221 = _itoa(gs, (word32) (int64) eax_146, fp - 0x021E, 0x0A, 0x00, out ebx_1155, out ebp_1156, out edi_1157);
			if (eax_221 > fp - 0x0228)
			{
				do
				{
					--eax_221;
					*eax_221 = 0x20;
				} while (eax_221 != fp - 0x0228);
			}
		}
		esp_154 = fp + 20;
		if (esi_101 > 0x3F)
		{
			edi_247 = 0x080CE000;
			esp_254 = fp + 0x0C;
			while (true)
			{
				struct Eq_122537 * esp_283 = esp_254 - 4;
				esp_283->dw0000 = edi_247 + ~0x0001A452;
				esp_283->dwFFFFFFFC = edi_247 + ~0x0001A448;
				word32 edx_1152;
				word32 ecx_1151;
				__assert_fail(out ecx_1151, out edx_1152);
				esp_154 = (struct Eq_122442 *) ((char *) esp_283 - 8);
l08090BFF:
				edi_247 = ebp_133->ptrFFFFFDB8;
				struct Eq_122504 * esp_276 = esp_154 - 4;
				esp_276->dw0000 = edi_247 + ~0x0001A3FB;
				esp_276->dwFFFFFFFC = 0x78;
				esp_254 = esp_276 - 4;
			}
		}
		(fp - 0x0218)[esi_101].dw0000 = 0x0C;
		(fp - 0x021C)[esi_101].ptr0000 = fp - 0x0228;
		dwLoc0230_1002 = ~0x00;
		al_107 = ebx_110->b0000;
		++esi_101;
		if (al_107 == 0x25)
		{
l080908F8:
			ebp_133 = fp - 4;
			if (esi_101 > 0x3F)
				goto l08090BFF;
			(fp - 0x0218)[esi_101].dw0000 = 0x00;
			edx_111 = ebx_110;
			if (al_107 == 0x25)
				goto l08090920;
			goto l0809085E;
		}
l080907F5:
		ebp_133 = fp - 4;
		if (al_107 == 0x00)
			goto l080908F8;
		int8 cl_52 = (int8) (dwLoc0230_1002 == 0x00);
		if (al_107 == 0x0A && cl_52 == 0x00)
		{
			if (esi_101 > 0x3F)
				goto l08090BFF;
			(fp - 0x0218)[esi_101].dw0000 = 0x00;
			edx_111 = ebx_110;
			goto l080909C1;
		}
		edx_111 = ebx_110;
		do
		{
			++edx_111;
			al_107 = edx_111->b0000;
		} while (al_107 != 0x00 && (al_107 != 0x25 && (al_107 != 0x0A || cl_52 != 0x00)));
		if (esi_101 > 0x3F)
			goto l08090BFF;
		ptr32 edi_93 = edx_111 - ebx_110;
		(fp - 0x0218)[esi_101].ptr0000 = edi_93;
		if (edi_93 != 0x00)
		{
			(fp - 0x021C)[esi_101].ptr0000.b0000 = (byte) ebx_110;
			++esi_101;
		}
		if (al_107 == 0x25)
			break;
l0809085E:
		if (al_107 != 0x0A)
		{
			ebx_110 = edx_111;
			goto l08090864;
		}
		if (ebx_110 != edx_111)
			(fp - 0x0220)[esi_101].dw0000 = (fp - 0x0220)[esi_101].dw0000 + 0x01;
		else
		{
l080909C1:
			(fp - 0x021C)[esi_101].ptr0000.b0000 = (byte) ebx_110;
			(fp - 0x0218)[esi_101].dw0000 = 0x01;
			++esi_101;
		}
		ebx_110 = edx_111 + 1;
		if (edx_111[1] == 0x00)
			break;
	}
l08090920:
	byte bLoc023D_789;
	struct Eq_122559 * ebx_330;
	ci8 al_324 = edx_111[1];
	if (al_324 != 0x30)
	{
		bLoc023D_789 = 0x20;
		ebx_330 = (struct Eq_122559 *) (edx_111 + 1);
		goto l08090936;
	}
l08090AC0:
	ebx_330 = (struct Eq_122559 *) (edx_111 + 2);
	bLoc023D_789 = 0x30;
	al_324 = (ci8) edx_111[2];
l08090936:
	int32 dwLoc023C_790 = ~0x00;
	if (al_324 == 0x2A)
	{
		++ebx_330;
		dwArg04 = (word32) dwArg04 + 4;
		dwLoc023C_790 = (int32) *dwArg04;
		al_324 = ebx_330->b0000;
	}
	Eq_2 edi_346 = ~0x00;
	if (al_324 == 0x2E)
	{
		if (ebx_330[1] != 0x2A)
			goto l08090A9A;
		ebx_330 += 2;
		edi_346 = *dwArg04;
		al_324 = ebx_330->b0000;
		dwArg04 = (word32) dwArg04 + 4;
	}
	if (al_324 == 0x6C || al_324 == 0x5A)
	{
		al_324 = (ci8) ebx_330[1];
		++ebx_330;
	}
	if (al_324 != 115)
	{
		if (al_324 <= 115)
		{
			if (al_324 == 0x25)
			{
				(fp - 0x021C)[esi_101].ptr0000.b0000 = (byte) ebx_330;
				(fp - 0x0218)[esi_101].dw0000 = 0x01;
				++esi_101;
				goto l080909A1;
			}
l08090A9A:
			struct Eq_122767 * esp_563 = esp_154 - 4;
			esp_563->ptr0000 = 0x080B3C04;
			esp_563->dwFFFFFFFC = 0xD8;
			esp_563->ptrFFFFFFF8 = 0x080B3BAD;
			esp_563->ptrFFFFFFF4 = 0x080B3BC6;
			word32 ecx_1160;
			__assert_fail(out ecx_1160, out edx_111);
			esp_154 = esp_563 - 0x10;
			goto l08090AC0;
		}
		if (al_324 != 117 && al_324 != 0x78)
			goto l08090A9A;
		Eq_2 dwLoc0244_804 = (word32) dwArg04 + 4;
		word32 ecx_446 = *dwArg04;
		struct Eq_122442 * esp_459 = esp_154 - 0x20;
		esp_459->dw001C = esp_459->dw001C;
		word32 edi_466 = esp_459 + 0x0F & ~0x0F;
		word32 eax_472 = 0x10;
		if (al_324 != 0x78)
			eax_472 = 0x0A;
		esp_459->dwFFFFFFF0 = 0x00;
		esp_459->dwFFFFFFEC = eax_472;
		esp_459->dwFFFFFFE8 = edi_466 + 0x0C;
		esp_459->dwFFFFFFE4 = 0x00;
		esp_459->dwFFFFFFE0 = ecx_446;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_86855 stackArg4 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg16 = <invalid>;
		Eq_2 stackArg20 = <invalid>;
		word32 ebx_1165;
		word32 ebp_1166;
		word32 edi_1167;
		Eq_2 eax_517 = _itoa(gs, stackArg4, stackArg12, stackArg16, stackArg20, out ebx_1165, out ebp_1166, out edi_1167);
		esp_154 = esp_459;
		int32 edx_523 = edi_466 + 0x0C - eax_517;
		if (dwLoc023C_790 != ~0x00 && dwLoc023C_790 > edx_523)
		{
			do
			{
				--eax_517;
				*eax_517 = bLoc023D_789;
				edx_523 = edi_466 + 0x0C - eax_517;
			} while (edx_523 < dwLoc023C_790);
		}
		(fp - 0x021C)[esi_101].t0000 = eax_517;
		(fp - 0x0218)[esi_101].dw0000 = edx_523;
		++esi_101;
		dwArg04 = dwLoc0244_804;
	}
	else
	{
		struct Eq_122730 * esp_391 = esp_154 - 0x0C;
		Eq_2 eax_396 = *dwArg04;
		esp_391->tFFFFFFFC = eax_396;
		(fp - 0x021C)[esi_101].t0000 = eax_396;
		Eq_2 dwLoc023C_799 = (word32) dwArg04 + 4;
		word32 ecx_1158;
		word32 edx_1159;
		Eq_2 eax_405 = strlen(esp_391->tFFFFFFFC, out ecx_1158, out edx_1159);
		esp_154 = (struct Eq_122442 *) ((char *) &esp_391->tFFFFFFFC + 16);
		if (edi_346 != ~0x00)
		{
			if (edi_346 > eax_405)
				edi_346 = eax_405;
			(fp - 0x0218)[esi_101].t0000 = edi_346;
		}
		else
			(fp - 0x0218)[esi_101].t0000 = eax_405;
		++esi_101;
		dwArg04 = dwLoc023C_799;
	}
l080909A1:
	ebx_110 = (struct Eq_122143 *) (ebx_330 + 1);
l08090864:
	al_107 = ebx_110->b0000;
	if (al_107 == 0x00)
		goto l0809086F;
	goto l080907E0;
}

// 08090C40: Register Eq_2 _dl_sysdep_read_whole_file(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_2) dwArg08, Stack ui32 dwArg0C, Register out ptr32 ecxOut, Register out ptr32 edxOut)
// Called from:
//      _dl_debug_vdprintf
//      _dl_load_cache_lookup
Eq_2 _dl_sysdep_read_whole_file(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 * dwArg08, ui32 dwArg0C, ptr32 & ecxOut, ptr32 & edxOut)
{
	ptr32 ecx_20;
	ptr32 edx_21;
	Eq_2 eax_19 = __open64_nocancel(gs, dwArg04, 0x00080000, dwLoc74, out ecx_20, out edx_21);
	if (eax_19 < 0x00)
	{
		ecxOut = ecx_20;
		edxOut = edx_21;
		return ~0x00;
	}
	Eq_2 esi_100;
	word32 edx_163;
	ptr32 ecx_144;
	if (__fxstat64(gs, eax_19, fp - 0x6C, out ecx_144, out edx_163) >= 0x00)
	{
		*dwArg08 = (union Eq_2 *) dwLoc40;
		if (dwLoc40 != 0x00)
		{
			word32 edx_164;
			esi_100 = mmap(gs, 0x00, dwLoc40, dwArg0C, 0x02, eax_19, 0x00, out ecx_144, out edx_164);
l08090C9C:
			ptr32 edx_94;
			__close_nocancel(gs, eax_19, out edx_94);
			ecxOut = ecx_144;
			edxOut = edx_94;
			return esi_100;
		}
	}
	esi_100.u0 = ~0x00;
	goto l08090C9C;
}

// 08090CD0: Register byte _dl_debug_printf(Register out Eq_49975 ecxOut, Register out (ptr32 byte) edxOut)
// Called from:
//      _dl_non_dynamic_init
//      open_path
//      _dl_map_object_from_fd.constprop.8
//      _dl_map_object
//      do_lookup_x
//      _dl_lookup_symbol_x
//      _dl_relocate_object
//      _dl_load_cache_lookup
//      add_to_global
//      _dl_show_scope
//      dl_open_worker
//      _dl_close_worker
//      _dl_map_object_deps
//      call_init.part.0
//      _dl_init
//      _dl_check_map_versions
byte _dl_debug_printf(union Eq_49975 & ecxOut, byte & edxOut)
{
	byte * edx_17;
	Eq_49975 ecx_18;
	word32 ebx_31;
	Eq_2 eax_16 = _dl_debug_vdprintf(dwArg04, 0x01, gs, fp + 0x08, out ecx_18, out edx_17, out ebx_31);
	ecxOut = ecx_18;
	edxOut = edx_17;
	return (byte) eax_16;
}

// 08090D10: Register word32 _dl_debug_printf_c(Register out ptr32 edxOut)
// Called from:
//      open_path
//      _dl_lookup_symbol_x
//      _dl_show_scope
word32 _dl_debug_printf_c(ptr32 & edxOut)
{
	ptr32 edx_17;
	word32 ecx_18;
	word32 ebx_30;
	_dl_debug_vdprintf(dwArg04, ~0x00, gs, fp + 0x08, out ecx_18, out edx_17, out ebx_30);
	edxOut = edx_17;
	return ecx_18;
}

// 08090D50: void _dl_dprintf()
// Called from:
//      _dl_non_dynamic_init
//      do_lookup_x
//      _dl_relocate_object
//      _dl_start_profile
//      oom
//      length_mismatch
//      _dl_exception_create_format
//      fatal_error
//      dl_open_worker
//      _dl_close_worker
void _dl_dprintf()
{
	word32 ecx_27;
	word32 edx_28;
	word32 ebx_29;
	_dl_debug_vdprintf(dwArg08, 0x00, gs, fp + 0x0C, out ecx_27, out edx_28, out ebx_29);
}

// 08090D80: Register word32 _dl_name_match_p(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_113353) ecxOut)
// Called from:
//      _dl_map_object
//      check_match
//      _dl_relocate_object
//      _dl_check_map_versions
word32 _dl_name_match_p(Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_113353 & ecxOut)
{
	word32 edx_121;
	struct Eq_113353 * ecx_102;
	if (strcmp(dwArg04, *((word32) dwArg08 + 4), out ecx_102, out edx_121) == 0x00)
	{
l08090DCE:
		ecxOut = ecx_102;
		return 0x01;
	}
	else
	{
		struct Eq_123039 * ebx_31;
		for (ebx_31 = *((word32) dwArg08 + 28); ebx_31 != null; ebx_31 = ebx_31->ptr0004)
		{
			word32 edx_122;
			if (strcmp(dwArg04, ebx_31->t0000, out ecx_102, out edx_122) == 0x00)
				goto l08090DCE;
		}
		ecxOut = ecx_102;
		return 0x00;
	}
}

// 08090DF0: Register word32 _dl_higher_prime_number(Stack uint32 dwArg04)
// Called from:
//      do_lookup_x
word32 _dl_higher_prime_number(uint32 dwArg04)
{
	up32 * ecx_14 = &g_dw80B3C20;
	up32 * edx_15 = &g_dw80B3C98;
	do
	{
		up32 * eax_41;
		int32 eax_19 = edx_15 - ecx_14;
		word32 ebx_25 = ecx_14 + (((eax_19 >> 0x02) >>u 0x1F) + (eax_19 >> 0x02) >> 0x01) * 0x04;
		if (dwArg04 <= *ebx_25)
		{
			while (ecx_14 != ebx_25)
			{
				int32 eax_35 = ebx_25 - ecx_14;
				eax_41 = ecx_14 + (((eax_35 >> 0x02) >>u 0x1F) + (eax_35 >> 0x02) >> 0x01) * 0x04;
				if (*eax_41 < dwArg04)
				{
					edx_15 = ebx_25;
					goto l08090E5A;
				}
				ebx_25 = eax_41;
			}
			return *ebx_25;
		}
		eax_41 = ebx_25;
l08090E5A:
		ecx_14 = eax_41 + 0x04;
	} while (ecx_14 != edx_15);
	return *edx_15;
}

// 08090E70: Register Eq_123112 _dl_strtoul(Stack Eq_2 dwArg04, Stack (ptr32 (ptr32 Eq_123130)) dwArg08)
// Called from:
//      tunable_initialize
//      _dl_non_dynamic_init
Eq_123112 _dl_strtoul(Eq_2 dwArg04, struct Eq_123130 ** dwArg08)
{
	Eq_2 ebp_19 = dwArg04;
	Eq_2 al_22 = *dwArg04;
	if (al_22 == 0x20)
	{
l08090E98:
		do
		{
			ebp_19 = (word32) ebp_19 + 1;
			al_22 = *ebp_19;
		} while (al_22 == 0x20);
	}
	if (al_22 != 0x09)
	{
		byte bLoc1D_275;
		struct Eq_123130 * ebp_129;
		if (al_22 != 0x2D)
		{
			bLoc1D_275 = 0x01;
			ebp_129 = (word32) ebp_19 + (word32) ((int8) (al_22 == 0x2B));
		}
		else
		{
			ebp_129 = (word32) ebp_19 + 1;
			bLoc1D_275 = 0x00;
		}
		Eq_123112 esi_138;
		int32 eax_406 = (int32) ebp_129->b0000;
		byte al_67 = (byte) eax_406;
		if ((byte) (eax_406 - 0x30) > 0x09)
		{
			esi_138.u0 = 0x00;
			if (dwArg08 == null)
				return esi_138;
			goto l0809100C;
		}
		Eq_963 ecx_65 = 0x0A;
		word32 edx_66 = 0x09;
		if (al_67 == 0x30)
		{
			if ((byte) ((word32) ebp_129[1] & ~0x20) == 88)
			{
				eax_406 = (int32) ebp_129[2];
				ecx_65.u0 = 0x10;
				ebp_129 += 2;
			}
			else
			{
				ecx_65.u0 = 0x08;
				edx_66 = 0x07;
			}
		}
		Eq_123162 ebx_82 = edx_66 + 0x30;
		esi_138.u0 = 0x00;
		Eq_123166 edi_144 = 0x00;
		Eq_963 ebx_90 = ecx_65 >> 0x1F;
		int32 eax_257 = eax_406;
l08090F7E:
		Eq_123173 eax_101;
		ci8 al_93 = (byte) eax_257;
		if (al_93 > 0x2F)
		{
			Eq_123162 edx_96 = (int32) al_93;
			if (edx_96 <= ebx_82)
			{
				eax_101 = edx_96 - 0x30;
l08090F0C:
				int32 ebx_158 = eax_101 >> 0x1F;
				int64 qwLoc34_353 = SEQ(ebx_158, eax_101);
				up32 edx_181;
				if (edi_144 - edx_181 - (esi_138 < __udivdi3(SEQ(~ebx_158, ~eax_101), ecx_65, ebx_90, out edx_181)) < 0x00)
				{
					uint64 edx_eax_245 = ecx_65 *64 esi_138;
					ui64 edi_esi_268 = SEQ(SLICE(edx_eax_245, word32, 32) + (ebx_90 *s esi_138 + edi_144 *s ecx_65), (word32) edx_eax_245) + qwLoc34_353;
					++ebp_129;
					esi_138 = (word32) edi_esi_268;
					edi_144 = SLICE(edi_esi_268, word32, 32);
					eax_257 = (int32) ebp_129->b0000;
					goto l08090F7E;
				}
				esi_138.u0 = ~0x00;
				if (dwArg08 == null)
					return esi_138;
l0809100C:
				*dwArg08 = (struct Eq_123130 **) ebp_129;
				return esi_138;
			}
		}
		if (ecx_65 == 0x10)
		{
			if ((byte) (eax_257 - 0x61) <= 0x05)
			{
				eax_101 = eax_257 - 0x57;
				goto l08090F0C;
			}
			if ((byte) (eax_257 - 0x41) <= 0x05)
			{
				eax_101 = eax_257 - 55;
				goto l08090F0C;
			}
		}
		if (dwArg08 != null)
			*dwArg08 = (struct Eq_123130 **) ebp_129;
		if (bLoc1D_275 == 0x00)
			esi_138 = -esi_138;
		return esi_138;
	}
	goto l08090E98;
}

// 08091060: void _dl_start_profile(Register (ptr32 Eq_9) gs)
void _dl_start_profile(struct Eq_9 * gs)
{
	uint32 edi_109;
	uint32 ebx_107;
	Eq_2 edi_21 = _dl_profile_map;
	struct Eq_49300 * eax_23 = *((word32) edi_21 + 340);
	struct Eq_123283 * ebp_424 = fp - 4;
	Eq_2 esi_15 = 0x080CE000;
	struct Eq_49300 * edx_26 = eax_23 + ((word32) (*((word32) edi_21 + 348)) << 0x05) / 32;
	if (eax_23 < edx_26)
	{
		Eq_2 ecx_36 = _dl_pagesize;
		ui32 edi_39 = -ecx_36;
		ebx_107 = ~0x00;
		edi_109 = 0x00;
		do
		{
			if (eax_23->dw0000 == 0x01 && (eax_23->t0018 & 0x01) != 0x00)
			{
				uint32 ecx_61 = edi_39 & eax_23->dw0008;
				if (ebx_107 > ecx_61)
					ebx_107 = ecx_61;
				uint32 ecx_72 = eax_23->dw0008 + eax_23->dw0014 + (ecx_36 - 0x01) & edi_39;
				if (edi_109 < ecx_72)
					edi_109 = ecx_72;
				++eax_23;
				if (eax_23 >= edx_26)
					break;
				continue;
			}
			++eax_23;
		} while (eax_23 < edx_26);
	}
	else
	{
		ebx_107 = ~0x00;
		edi_109 = 0x00;
	}
	int32 dwLoc0258_1042;
	running = null;
	log_hashfraction.u1 = 0x04;
	word32 eax_106 = *edi_21;
	ui32 ebx_108 = ebx_107 + eax_106;
	lowpc = ebx_108 & ~0x03;
	Eq_50407 eax_114 = (eax_106 + 0x03 + edi_109 & ~0x03) - (ebx_108 & ~0x03);
	textsize = eax_114;
	if (eax_114 * 0x03 <= 4999)
	{
		fromlimit.u0 = 0x32;
		dwLoc0258_1042 = 0x1300;
	}
	else
	{
		uint32 edx_124 = SLICE(eax_114 * 0x03 *64 1374389535, word32, 32);
		if (eax_114 * 0x03 > 0x06400063)
		{
			fromlimit.u0 = 0x00100000;
			dwLoc0258_1042 = 0x06000040;
		}
		else
		{
			fromlimit = edx_124 >> 0x05;
			dwLoc0258_1042 = (edx_124 >> 0x05) *s 0x60 + 0x40;
		}
	}
	__profile_frequency();
	Eq_2 ebx_163 = _dl_profile_output;
	word32 ecx_1219;
	word32 edx_1220;
	Eq_2 eax_170 = strlen(ebx_163, out ecx_1219, out edx_1220);
	Eq_2 edi_179 = _dl_profile;
	word32 ecx_1221;
	word32 edx_1222;
	ui32 eax_192 = (word32) strlen(edi_179, out ecx_1221, out edx_1222) + ((word32) eax_170 + 37);
	struct Eq_123392 * esp_190 = fp - 636;
	struct Eq_123392 * ecx_195 = fp - 636 - (eax_192 & ~0x0FFF);
	if (fp - 636 != ecx_195)
	{
		do
		{
			esp_190 -= 0x1000;
			esp_190->dw0FFC = esp_190->dw0FFC;
		} while (esp_190 != ecx_195);
	}
	int32 edx_211 = eax_192 & ~0x0F & 0x0FFF;
	if (edx_211 != 0x00)
	{
		esp_190 -= edx_211;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[edx_211 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_190 - 0x04)[edx_211 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
	}
	Eq_2 edi_301;
	struct Eq_123413 * esp_224 = esp_190 - 0x08;
	esp_224->tFFFFFFFC = ebx_163;
	Eq_123420 eax_223 = (char *) esp_190 + 0x0F;
	esp_224->tFFFFFFF8 = eax_223 & ~0x0F;
	word32 ecx_1198;
	Eq_2 eax_245 = __stpcpy(esp_224->tFFFFFFF8, esp_224->tFFFFFFFC, out ecx_1198);
	*eax_245 = 0x2F;
	esp_224->tFFFFFFFC = edi_179;
	esp_224->tFFFFFFF8 = (word32) eax_245 + 1;
	word32 ecx_1199;
	Eq_2 eax_266 = __stpcpy(esp_224->tFFFFFFF8, esp_224->tFFFFFFFC, out ecx_1199);
	*eax_266 = 0x6F72702E;
	*((word32) eax_266 + 4) = 0x656C6966;
	*((word32) eax_266 + 8) = 0x00;
	esp_224->t0000.u0 = 0x01B6;
	esp_224->tFFFFFFFC.u0 = 0x00020042;
	esp_224->tFFFFFFF8 = eax_223 & ~0x0F;
	word32 ecx_1200;
	word32 edx_1201;
	Eq_2 eax_288 = __open64_nocancel(gs, esp_224->tFFFFFFF8, esp_224->tFFFFFFFC, esp_224->t0000, out ecx_1200, out edx_1201);
	ptr32 esp_295 = (char *) &esp_224->t0000 + 8;
	if (eax_288 != ~0x00)
	{
		esp_224->t0000 = fp - 0x020C;
		esp_224->tFFFFFFFC = eax_288;
		esp_224->tFFFFFFF8.u0 = 0x03;
		Eq_2 esp_319 = (char *) &esp_224->t0000 + 8;
		word32 edx_1203;
		word32 ecx_1202;
		if (__fxstat64(gs, esp_224->tFFFFFFFC, esp_224->t0000, out ecx_1202, out edx_1203) >= 0x00 && (dwLoc01FC & 0xF000) == 0x8000)
		{
			ptr32 esp_505;
			ui32 ebx_334 = dwLoc0258_1042 + (eax_114 >> 0x01);
			if ((dwLoc01DC | dwLoc01E0) != 0x00)
			{
				if ((dwLoc01DC ^ SLICE((int64) ebx_334, word32, 32) | dwLoc01E0 ^ ebx_334) != 0x00)
				{
					esp_224->tFFFFFFF8 = eax_288;
					word32 edx_1204;
					__close_nocancel(gs, esp_224->tFFFFFFF8, out edx_1204);
					esp_505 = (char *) &esp_224->t0000 + 8;
					goto l080916C3;
				}
l08091368:
				Eq_2 ebx_509 = ebp_424->tFFFFFDB4;
				struct Eq_123593 * esp_511 = esp_319 - 0x08;
				esp_511->tFFFFFFFC.u0 = 0x00;
				esp_511->tFFFFFFF8 = ebx_509;
				esp_511->tFFFFFFF4.u0 = 0x01;
				esp_511->dwFFFFFFF0 = 0x03;
				esp_511->tFFFFFFEC = ebp_424->tFFFFFDAC;
				esp_511->tFFFFFFE8.u0 = 0x00;
				word32 edx_1206;
				word32 ecx_1205;
				Eq_2 eax_527 = mmap(gs, esp_511->tFFFFFFE8, esp_511->tFFFFFFEC, esp_511->dwFFFFFFF0, esp_511->tFFFFFFF4, esp_511->tFFFFFFF8, esp_511->tFFFFFFFC, out ecx_1205, out edx_1206);
				esp_319 = (char *) &esp_511->t0000 + 8;
				if (eax_527 != ~0x00)
				{
					esp_511->tFFFFFFF8 = ebx_509;
					word32 edx_1207;
					__close_nocancel(gs, esp_511->tFFFFFFF8, out edx_1207);
					word32 edx_629 = ebp_424->dwFFFFFDA4;
					ebp_424->ptrFFFFFD94 = (word32) eax_527 + 56;
					Eq_2 ecx_633 = (word32) eax_527 + 60 + edx_629;
					*((word32) esi_15 + 6756) = ecx_633;
					*((word32) esi_15 + 6768) = (word32) ecx_633 + 4;
					if ((ebp_424->dwFFFFFE28 | ebp_424->dwFFFFFE24) == 0x00)
					{
						word32 eax_752 = ebp_424->dwFFFFFDC4;
						*((word32) eax_527 + 20) = 0x00;
						*eax_527 = eax_752;
						*((word32) eax_527 + 4) = ebp_424->dwFFFFFDC8;
						*((word32) eax_527 + 8) = ebp_424->dwFFFFFDCC;
						*((word32) eax_527 + 0x0C) = ebp_424->dwFFFFFDD0;
						*((word32) eax_527 + 16) = ebp_424->dwFFFFFDD4;
						*((word32) eax_527 + 24) = ebp_424->tFFFFFDD8;
						*((word32) eax_527 + 28) = ebp_424->dwFFFFFDDC;
						*((word32) eax_527 + 32) = ebp_424->dwFFFFFDE0;
						*((word32) eax_527 + 36) = ebp_424->dwFFFFFDE4;
						*((word32) eax_527 + 40) = ebp_424->dwFFFFFDE8;
						*((word32) eax_527 + 44) = ebp_424->dwFFFFFDEC;
						*((word32) eax_527 + 48) = ebp_424->dwFFFFFDF0;
						*((word32) eax_527 + 52) = ebp_424->tFFFFFDF4;
						((word32) ecx_633 - 4)->u0 = 0x01;
						goto l08091455;
					}
					ebp_424->tFFFFFDB4 = ecx_633;
					esp_511->t0000.u0 = 0x14;
					esp_511->tFFFFFFFC = ebp_424 - 0x023C;
					esp_511->tFFFFFFF8 = eax_527;
					word32 edx_1209;
					word32 ecx_1208;
					if (memcmp(esp_511->tFFFFFFF8, esp_511->tFFFFFFFC, esp_511->t0000, out ecx_1208, out edx_1209) == 0x00 && *((word32) eax_527 + 20) == 0x00)
					{
						esp_511->t0000.u0 = 0x20;
						esp_511->tFFFFFFFC = ebp_424 - 0x0228;
						esp_511->tFFFFFFF8 = (word32) eax_527 + 24;
						word32 edx_1227;
						word32 ecx_1226;
						if (memcmp(esp_511->tFFFFFFF8, esp_511->tFFFFFFFC, esp_511->t0000, out ecx_1226, out edx_1227) == 0x00)
						{
							ecx_633 = ebp_424->tFFFFFDB4;
							if (*((word32) ecx_633 - 4) == 0x01)
							{
l08091455:
								Eq_2 eax_785 = ebp_424->dwFFFFFDA0 + ebp_424->dwFFFFFDA4;
								ebp_424->tFFFFFDA8 = ecx_633;
								struct Eq_123810 * esp_781 = esp_319 - 0x08;
								esp_781->tFFFFFFFC.u0 = 0x01;
								esp_781->tFFFFFFF8 = eax_785;
								word32 ecx_1228;
								word32 edx_1229;
								struct Eq_123817 * ebp_797;
								Eq_2 ebx_798;
								Eq_2 edi_800;
								struct Eq_123843 * esi_802;
								Eq_2 eax_796 = __libc_calloc(gs, esp_781->tFFFFFFF8, esp_781->tFFFFFFFC, out ecx_1228, out edx_1229, out ebx_798, out ebp_797, out esi_802, out edi_800);
								struct Eq_123877 * ecx_809 = ebp_797->ptrFFFFFDA8;
								ebp_797->tFFFFFDB4 = eax_796;
								esi_802->t1A60 = eax_796;
								if (eax_796 == 0x00)
								{
									esp_781->t0004 = eax_796;
									esp_781->t0000 = eax_796;
									esp_781->tFFFFFFFC = ebp_797->tFFFFFDAC;
									esp_781->tFFFFFFF8 = edi_800;
									word32 edx_1211;
									word32 ebx_1212;
									word32 ecx_1210;
									__munmap(ebx_798, gs, esp_781->tFFFFFFF8, esp_781->tFFFFFFFC, out ecx_1210, out edx_1211, out ebx_1212);
									esp_781->t0000 = (char *) esi_802 - 107208;
									esp_781->tFFFFFFFC.u0 = 0x02;
									_dl_dprintf();
									esp_781->tFFFFFFFC.u0 = 0x7F;
									_exit(gs, esp_781->tFFFFFFFC);
								}
								else
								{
									esi_802->dw1A54 = 0x00;
									word32 eax_859 = Mem857[ebp_797 + -588:word32] + Mem857[ebp_797 + -604:word32];
									uint32 edx_860 = ecx_809->dw0000;
									ebp_797->tFFFFFDAC = eax_859;
									esi_802->t1A5C = eax_859;
									uint32 eax_863 = esi_802->dw1A58;
									if (edx_860 < eax_863)
										eax_863 = ecx_809->dw0000;
									esi_802->dw1A68 = eax_863;
									if (eax_863 != 0x00)
									{
										ebp_797->ptrFFFFFDA8 = ecx_809 - 0x08;
										struct Eq_123877 * eax_878 = ecx_809 - 0x08 + eax_863 * 0x0C;
										do
										{
											ui32 edx_884 = esi_802->dw1A54;
											uint32 ecx_882 = eax_878->dw0004;
											Eq_2 edi_886 = ebp_797->tFFFFFDB4;
											esi_802->dw1A54 = edx_884 + 0x01;
											word16 * ecx_890 = (word32) edi_886 + (ecx_882 >> 0x02) * 0x02;
											word16 di_896 = *ecx_890;
											struct Eq_124043 * ebx_893 = (word32) ebp_797->tFFFFFDAC + edx_884 * 0x08;
											ebx_893->ptr0000 = eax_878;
											ebx_893->w0004 = di_896;
											*ecx_890 = (word16) edx_884;
											eax_878 -= 0x0C;
										} while (eax_878 != ebp_797->ptrFFFFFDA8);
									}
									Eq_2 ebx_904 = esi_802->t1A50;
									Eq_2 eax_907 = 0x00010000;
									Eq_2 ecx_908 = ebp_797->dwFFFFFD9C - ebx_904;
									if (ecx_908 > ebp_797->tFFFFFDA4)
									{
										uint32 eax_916 = (uint32) ((uint64) ecx_908 /u ebp_797->tFFFFFDA4);
										eax_907.u0 = 0x01;
										if (eax_916 <= 0xFFFF)
										{
											if (eax_916 > 0xFF)
												eax_907 = (uint32) (0x00010000 /u eax_916);
											else if (ecx_908 > 0x00FFFFFF)
												eax_907 = (uint32) (0x01000000 /u (uint32) ((uint64) ecx_908 /u (ebp_797->dwFFFFFDB0 >> 0x09)));
											else
												eax_907 = (uint32) (0x01000000 /u (uint32) ((uint64) (ecx_908 << 0x08) /u ebp_797->tFFFFFDA4));
										}
									}
									esp_781->t0004 = eax_907;
									esp_781->t0000 = ebx_904;
									esp_781->tFFFFFFFC = ebp_797->tFFFFFDA4;
									esp_781->tFFFFFFF8 = ebp_797->tFFFFFD94;
									profil(gs, esp_781->tFFFFFFF8)->dw1A6C = 0x01;
									return;
								}
							}
						}
					}
					struct Eq_124288 * esp_694 = esp_319 - 0x08;
					esp_694->tFFFFFFFC = ebp_424->tFFFFFDAC;
					esp_694->tFFFFFFF8 = eax_527;
					word32 ebx_1225;
					word32 ecx_1223;
					word32 edx_1224;
					__munmap(esi_15, gs, esp_694->tFFFFFFF8, esp_694->tFFFFFFFC, out ecx_1223, out edx_1224, out ebx_1225);
					esp_505 = (char *) &esp_694->tFFFFFFFC + 16;
l080916C3:
					struct Eq_124407 * esp_722 = esp_505 - 4;
					esp_722->dw0000 = *ebp_424->ptrFFFFFD98;
					esp_722->tFFFFFFFC = ebp_424->tFFFFFDA8;
					esp_722->ptrFFFFFFF8 = (word32) esi_15 - 107260;
					esp_722->dwFFFFFFF4 = 0x02;
					_dl_dprintf();
					return;
				}
			}
			else
			{
				Eq_2 ecx_346 = _dl_pagesize;
				Eq_2 edx_350 = (char *) &esp_224->t0000 + 8 - ((word32) ecx_346 + 0x0F & ~0x0FFF);
				ui32 ebx_351 = (word32) ecx_346 + 0x0F & ~0x0F;
				if ((char *) &esp_224->t0000 + 8 != edx_350)
				{
					do
					{
						esp_319 -= 0x1000;
						*((word32) esp_319 + 0x0FFC) = *((word32) esp_319 + 0x0FFC);
					} while (esp_319 != edx_350);
				}
				if ((ebx_351 & 0x0FFF) != 0x00)
				{
					esp_319 -= ebx_351 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_319 - 0x04)[(ebx_351 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_319 - 0x04)[(ebx_351 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				struct Eq_123916 * esp_379 = esp_319 - 0x04;
				esp_379->tFFFFFFFC = ecx_346;
				esp_379->tFFFFFFF8.u0 = 0x00;
				esp_379->tFFFFFFF4 = esp_319;
				word32 edx_1214;
				word32 ecx_1213;
				memset(esp_379->tFFFFFFF4, esp_379->tFFFFFFF8, esp_379->tFFFFFFFC, out ecx_1213, out edx_1214);
				esp_379->tFFFFFFFC.u0 = 0x00;
				esp_379->tFFFFFFF8 = -ecx_346 & ebx_334;
				esp_379->tFFFFFFF4 = eax_288;
				Eq_2 esp_430 = <invalid>;
				ui32 * edi_427;
				word32 ebx_1216;
				word32 ecx_1215;
				if (__libc_lseek(gs, esp_379->tFFFFFFF4, esp_379->tFFFFFFF8, esp_379->tFFFFFFFC, out ecx_1215, out ebx_1216, out ebp_424, out esi_15, out edi_427) != ~0x00)
				{
					do
					{
						*((word32) esp_430 + 8) = *edi_427 - 0x01 & ebp_424->tFFFFFDAC;
						*((word32) esp_430 + 4) = ebp_424->ptrFFFFFD94;
						*esp_430 = ebp_424->tFFFFFDB4;
						int32 eax_458 = __write_nocancel(gs, *esp_430, *((word32) esp_430 + 4), *((word32) esp_430 + 8));
						if (eax_458 != ~0x00)
						{
							if (eax_458 < 0x00)
								break;
							esp_319 = ebp_424->tFFFFFD90;
							goto l08091368;
						}
					} while (gs->tFFFFFFE0 == 0x04);
				}
				esp_319 = ebp_424->tFFFFFD90;
			}
		}
		struct Eq_124173 * esp_543 = esp_319 - 0x0C;
		edi_301 = gs->tFFFFFFE0;
		esp_543->tFFFFFFFC = ebp_424->tFFFFFDB4;
		word32 edx_1217;
		__close_nocancel(gs, esp_543->tFFFFFFFC, out edx_1217);
		esp_295 = (char *) &esp_543->tFFFFFFFC + 16;
	}
	else
		edi_301 = gs->tFFFFFFE0;
	struct Eq_124202 * esp_567 = esp_295 - 0x04;
	esp_567->tFFFFFFFC.u0 = 400;
	esp_567->tFFFFFFF8 = ebp_424 - 424;
	esp_567->tFFFFFFF4 = edi_301;
	Eq_2 esp_586 = <invalid>;
	struct Eq_124218 * ebp_580;
	Eq_2 ebx_581;
	word32 esi_1218;
	*((word32) esp_586 - 4) = strerror_r(gs, esp_567->tFFFFFFF4, esp_567->tFFFFFFF8, esp_567->tFFFFFFFC, out ebx_581, out ebp_580, out esi_1218);
	*((word32) esp_586 - 8) = ebp_580->tFFFFFDA8;
	*((word32) esp_586 - 0x0C) = ebx_581;
	((word32) esp_586 - 16)->u0 = 0x02;
	_dl_dprintf();
}

// 080918B0: Register Eq_2 _dl_mcount(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out (ptr32 Eq_50406) ecxOut, Register out Eq_50407 edxOut)
// Called from:
//      _dl_mcount_wrapper
//      _dl_mcount_wrapper_check
//      _dl_profile_fixup
Eq_2 _dl_mcount(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, struct Eq_50406 & ecxOut, union Eq_50407 & edxOut)
{
	struct Eq_50406 * ecx_7 = running;
	if (ecx_7 == null)
	{
		ecxOut = ecx_7;
		edxOut = edx;
		return <invalid>;
	}
	struct Eq_50406 * ecx_197 = lowpc;
	Eq_50407 edx_176 = textsize;
	Eq_50407 ebx_109 = dwArg04 - ecx_197;
	if (edx_176 <= ebx_109)
		ebx_109.u0 = 0x00;
	Eq_50407 edi_35 = dwArg08 - ecx_197;
	if (edx_176 <= edi_35)
	{
l08091AAE:
		ecxOut = ecx_197;
		edxOut = edx_176;
		return <invalid>;
	}
	struct Eq_124469 * esi_248;
	word32 esi_43 = tos;
	struct Eq_124473 * edi_47 = esi_43 + (edi_35 >> log_hashfraction) * 0x02;
	ui32 edx_175 = (word32) edi_47->w0000;
	struct Eq_124473 * dwLoc2C_286 = edi_47;
	if (edx_175 != 0x00)
	{
l08091920:
		struct Eq_124498 * edi_55 = froms;
		ecx_197 = (struct Eq_50406 *) (edi_55 + (edx_175 * 0x08) / 22);
		esi_248 = ecx_197->dw0000;
		edx_176 = esi_248->t0000;
		if (edx_176 == ebx_109)
			goto l08091AA0;
		ui32 edx_63 = (word32) ecx_197[1];
		if ((word16) edx_63 != 0x00)
		{
			do
			{
				ecx_197 = (struct Eq_50406 *) (edi_55 + (edx_63 * 0x08) / 22);
				edx_63 = (word32) ecx_197[1];
				esi_248 = ecx_197->dw0000;
			} while ((word16) edx_63 != 0x00 && esi_248->t0000 != ebx_109);
		}
		edx_176 = esi_248->t0000;
		if (edx_176 == ebx_109)
		{
l08091AA0:
			if (gs->t000C != 0x00)
				__lock();
			++esi_248->dw0008;
			goto l08091AAE;
		}
		dwLoc2C_286 = (struct Eq_124473 *) (ecx_197 + 1);
	}
	union Eq_28506 * esi_98 = narcsp;
	Eq_28506 edx_113 = narcs;
	if (edx_113 != *esi_98 && fromlimit > edx_113)
	{
		struct Eq_124564 * esi_107 = data;
		struct Eq_124498 * edi_108 = froms;
		do
		{
			struct Eq_124577 * ebp_116 = esi_107 + (edx_113 * 0x0C) / 24;
			uint32 ecx_119 = ebp_116->dw0004;
			if (gs->t000C != 0x00)
				__lock();
			fromidx = __xadd(fromidx, 0x01);
			edi_108->ptr0010 = ebp_116;
			word16 * ecx_142 = esi_43 + (ecx_119 >> 0x02) * 0x02;
			edi_108->w0014 = *ecx_142;
			*ecx_142 = 0x02;
			if (gs->t000C != 0x00)
				__lock();
			narcs = (word32) narcs + 1;
			edx_113 = narcs;
		} while (*esi_98 != edx_113 && edx_113 < fromlimit);
	}
	if (dwLoc2C_286->w0000 == 0x00)
	{
		edx_176.u0 = 0x01;
		if (gs->t000C != 0x00)
			__lock();
		*esi_98 = (union Eq_28506 *) __xadd(*esi_98, 0x01);
		ecx_197 = (struct Eq_50406 *) 0x01;
		if (fromlimit > 0x01)
		{
			if (gs->t000C != 0x00)
				__lock();
			fromidx = __xadd(fromidx, 0x01);
			struct Eq_124498 * esi_217 = froms;
			dwLoc2C_286->w0000 = 0x02;
			struct Eq_124661 * esi_224 = esi_217 + ((word32) dwLoc2C_286->w0000 * 0x08) / 22;
			struct Eq_124564 * edx_225 = data;
			esi_224->ptr0000 = (struct Eq_124469 *) &edx_225->t000C;
			edx_225->t000C = ebx_109;
			edx_225->dw0014 = 0x00;
			edx_225->t0010 = edi_35;
			esi_224->w0004 = 0x00;
			ecx_197 = (struct Eq_50406 *) 0x03;
			edx_176.u0 = 0x00;
			if (gs->t000C != 0x00)
				__lock();
			narcs = (word32) narcs + 1;
			esi_248 = esi_224->ptr0000;
			goto l08091AA0;
		}
		goto l08091AAE;
	}
	edx_175 = (word32) dwLoc2C_286->w0000;
	goto l08091920;
}

// 08091B00: Register Eq_2 allocate_dtv(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_allocate_tls_storage
//      _dl_allocate_tls
Eq_2 allocate_dtv(struct Eq_9 * gs)
{
	Eq_2 edi_32;
	word32 esi_34;
	word32 ebp_84;
	word32 ebx_83;
	word32 edx_82;
	word32 ecx_81;
	Eq_2 eax_28 = __libc_calloc(gs, (word32) _dl_tls_max_dtv_idx + 16, 0x08, out ecx_81, out edx_82, out ebx_83, out ebp_84, out esi_34, out edi_32);
	if (eax_28 != 0x00)
	{
		*eax_28 = esi_34;
		*((word32) edi_32 + 4) = (word32) eax_28 + 8;
		eax_28 = edi_32;
	}
	return eax_28;
}

// 08091B40: void oom(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_allocate_tls
void oom(struct Eq_9 * gs)
{
	_dl_dprintf();
	_exit(gs, 0x7F);
}

// 08091B70: Register Eq_2 _dl_next_tls_modid()
// Called from:
//      _dl_map_object_from_fd.constprop.8
//      oom
Eq_2 _dl_next_tls_modid()
{
	Eq_2 eax_103;
	struct Eq_124762 * esp_18 = fp - 44;
	Eq_2 eax_21 = _dl_tls_max_dtv_idx;
	if (g_b80CFEC4 == 0x00)
	{
		eax_103 = (word32) eax_21 + 1;
		goto l08091BA4;
	}
	Eq_2 eax_28 = _dl_tls_static_nelem;
	eax_103 = (word32) eax_28 + 1;
	if ((word32) eax_28 + 1 <= eax_21)
	{
		Eq_2 edx_38 = _dl_tls_dtv_slotinfo_list;
		up32 edi_34 = 0x00;
		uint32 ebp_132 = *edx_38;
		do
		{
l08091BE0:
			uint32 esi_45 = eax_103 - edi_34;
			if (esi_45 >= ebp_132)
				goto l08091C18;
			if (*((word32) edx_38 + (esi_45 * 0x08 + 0x0C)) == null)
				goto l08091C28;
			eax_103 = (word32) eax_103 + 1;
		} while (esp_18->t000C >= eax_103);
		struct Eq_124823 * esp_61 = esp_18 - 4;
		esp_61->ptr0000 = 134954744;
		esp_61->dwFFFFFFFC = 0x49;
		esp_61->ptrFFFFFFF8 = 0x080B3F0B;
		esp_61->ptrFFFFFFF4 = 134954396;
		Eq_2 esp_73 = <invalid>;
		word32 ecx_203;
		eax_103 = __assert_fail(out ecx_203, out edx_38);
		esp_18 = (word32) esp_73 - 4;
l08091C18:
		edx_38 = *((word32) edx_38 + 4);
		edi_34 += ebp_132;
		if (edx_38 != 0x00)
		{
			ebp_132 = (uint32) *edx_38;
			goto l08091BE0;
		}
l08091C28:
		if (eax_103 <= esp_18->t0004)
			return eax_103;
	}
	if ((word32) esp_18->t0004 + 1 != eax_103)
	{
		struct Eq_124850 * esp_110 = esp_18 - 4;
		esp_110->ptr0000 = 134954744;
		esp_110->dwFFFFFFFC = 0x57;
		esp_110->ptrFFFFFFF8 = 0x080B3F0B;
		esp_110->ptrFFFFFFF4 = 134954436;
		word32 ecx_204;
		word32 edx_205;
		__assert_fail(out ecx_204, out edx_205);
	}
	*esp_18->ptr0008 = 0x00;
l08091BA4:
	_dl_tls_max_dtv_idx = eax_103;
	return eax_103;
}

// 08091C70: void _dl_count_modids()
// Called from:
//      _dl_next_tls_modid
void _dl_count_modids()
{
	if (g_b80CFEC4 == 0x00)
		return;
	Eq_2 ecx_11 = _dl_tls_dtv_slotinfo_list;
	if (ecx_11 == 0x00)
		return;
	do
	{
		uint32 ebx_23 = *ecx_11;
		uint32 edx_24 = 0x00;
		if (ebx_23 != 0x00)
		{
			do
				++edx_24;
			while (edx_24 != ebx_23);
		}
		ecx_11 = *((word32) ecx_11 + 4);
	} while (ecx_11 != 0x00);
}

// 08091CE0: void _dl_get_tls_static_info(Stack (ptr32 word32) dwArg04, Stack (ptr32 Eq_116890) dwArg08)
void _dl_get_tls_static_info(word32 * dwArg04, union Eq_116890 * dwArg08)
{
	*dwArg04 = _dl_tls_static_size;
	*dwArg08 = (union Eq_116890 *) _dl_tls_static_align;
}

// 08091D10: void _dl_allocate_tls_storage(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_allocate_tls
void _dl_allocate_tls_storage(struct Eq_9 * gs)
{
	word32 ebp_29;
	Eq_124926 edi_32;
	word32 ecx_176;
	word32 edx_177;
	word32 ebx_178;
	word32 esi_179;
	Eq_2 eax_28 = __libc_malloc(gs, dwLoc40, (word32) _dl_tls_static_align + (_dl_tls_static_size + 0x04), out ecx_176, out edx_177, out ebx_178, out ebp_29, out esi_179, out edi_32);
	if (eax_28 == 0x00)
		return;
	struct Eq_124950 * edx_62 = ebp_29 - 0x04C0 + (uint32) ((uint64) ((word32) edi_32 + (eax_28 - 0x01)) /u edi_32) *s edi_32;
	edx_62->dw0000 = 0x00;
	edx_62[303] = (struct Eq_124950) 0x00;
	word32 edi_128 = edx_62 + 0x04 & ~0x03;
	word32 ecx_131;
	for (ecx_131 = edx_62 - edi_128 + 0x04C0 >>u 0x02; ecx_131 != 0x00; --ecx_131)
	{
		edi_128->dw0000 = 0x00;
		edi_128 += 4;
	}
	edx_62[304] = (struct Eq_124950) eax_28;
	if (allocate_dtv(gs) != null)
		return;
	word32 ecx_180;
	word32 edx_181;
	free(gs, dwLoc40, eax_28, out ecx_180, out edx_181);
}

// 08091DD0: void _dl_allocate_tls_init(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_124985) dwArg04)
// Called from:
//      _dl_allocate_tls
void _dl_allocate_tls_init(struct Eq_9 * gs, struct Eq_124985 * dwArg04)
{
	struct Eq_125006 * esp_25 = fp - 0x3C;
	if (dwArg04 == null)
		return;
	ui32 ebp_328;
	Eq_2 esi_342;
	Eq_2 edi_346;
	struct Eq_125015 * esp_362;
	Eq_125016 edx_303;
	Eq_2 eax_242 = _dl_tls_max_dtv_idx;
	if (dwArg04->ptr0004->tFFFFFFF8 >= eax_242)
	{
l08091E15:
		esp_25->t0008.dw0000 = (up32) 0x00;
		esp_25->t0010.u0 = 0x00;
		Eq_2 ebx_46 = _dl_tls_dtv_slotinfo_list;
		esp_25->ptr001C = &_dl_tls_generation;
		esp_25->t0004 = ebx_46;
		do
		{
			Eq_2 edi_51 = esp_25->t0010;
			uint32 ebx_57 = (uint32) (int8) (edi_51 == 0x00);
			uint32 esi_238 = ebx_57;
			Eq_2 ebx_240 = (word32) edi_51 + ebx_57;
			if (ebx_57 < *esp_25->t0004)
			{
				do
				{
					struct Eq_125006 * esp_144 = esp_25;
					if (ebx_240 > eax_242)
						goto l08091F32;
					Eq_2 ecx_69 = esp_25->t0004;
					struct Eq_124808 * eax_71 = *((word32) ecx_69 + (esi_238 * 0x08 + 0x0C));
					if (eax_71 != null)
					{
						Eq_125016 edx_104 = *((word32) ecx_69 + (esi_238 * 0x08 + 8));
						if (edx_104 > (esp_25->ptr001C)->dw0000)
						{
							word32 esi_79 = esp_25->dw000C;
							struct Eq_125572 * esp_81 = esp_25 - 4;
							esp_81->dw0000 = esi_79 + ~0x0001A11F;
							esp_81->dwFFFFFFFC = 0x01E1;
							esp_81->dwFFFFFFF8 = esi_79 + ~0x0001A0F4;
							esp_81->dwFFFFFFF4 = esi_79 + ~0x0001A213;
							Eq_2 esp_93 = <invalid>;
							word32 ecx_558;
							eax_242 = __assert_fail(out ecx_558, out edx_303);
							esp_25 = (word32) esp_93 - 4;
							goto l0809203F;
						}
						Eq_125016 edi_99 = esp_25->t0008.dw0000;
						Eq_2 ecx_100 = eax_71->t0244;
						if (edi_99 >= edx_104)
							edx_104 = edi_99;
						Eq_2 edi_107 = eax_71->t0248;
						esp_25->t0008.dw0000 = (up32) edx_104;
						struct Eq_125356 * edx_112 = esp_25->ptr0018 + edi_107;
						edx_112->t0000.u0 = ~0x00;
						edx_112->dw0004 = 0x00;
						if (ecx_100 <= 0x00)
							goto l08091F12;
						if (edi_107 == ebx_240)
						{
							Eq_2 edi_121 = eax_71->t0238;
							Eq_2 ebp_122 = eax_71->t0234;
							if (edi_121 >= ebp_122)
							{
								if (ecx_100 < edi_121)
									goto l080920A9;
								Eq_2 ebx_195 = esp_25->dw0040 - ecx_100;
								edx_112->t0000 = ebx_195;
								struct Eq_125392 * esp_193 = esp_25 - 0x04;
								esp_193->tFFFFFFFC = ebp_122;
								esp_193->tFFFFFFF8 = eax_71->t0230;
								esp_193->tFFFFFFF4 = ebx_195;
								word32 edx_549;
								Eq_2 eax_206 = __mempcpy(esp_193->tFFFFFFF4, esp_193->tFFFFFFF8, esp_193->tFFFFFFFC, out edx_549);
								esp_193->tFFFFFFFC = edi_121 - ebp_122;
								esp_193->tFFFFFFF8.u0 = 0x00;
								esp_193->tFFFFFFF4 = eax_206;
								word32 ecx_550;
								word32 edx_551;
								memset(esp_193->tFFFFFFF4, esp_193->tFFFFFFF8, esp_193->tFFFFFFFC, out ecx_550, out edx_551);
								goto l08091F12;
							}
							word32 esi_125 = esp_25->dw000C;
							struct Eq_125537 * esp_127 = esp_25 - 4;
							esp_127->dw0000 = esi_125 + ~0x0001A11F;
							esp_127->dwFFFFFFFC = 0x01EC;
							esp_127->dwFFFFFFF8 = esi_125 + ~0x0001A0F4;
							esp_127->dwFFFFFFF4 = esi_125 + ~0x0001A1BF;
							word32 ecx_556;
							word32 edx_557;
							__assert_fail(out ecx_556, out edx_557);
							Eq_2 esp_139 = <invalid>;
							esp_144 = (word32) esp_139 - 4;
l080920A9:
							word32 esi_150 = esp_144->dw000C;
							struct Eq_125470 * esp_152 = esp_144 - 4;
							esp_152->dw0000 = esi_150 + ~0x0001A11F;
							esp_152->dwFFFFFFFC = 0x01EE;
							esp_152->dwFFFFFFF8 = esi_150 + ~0x0001A0F4;
							esp_152->dwFFFFFFF4 = esi_150 + 4294860404;
							word32 ecx_552;
							word32 edx_553;
							__assert_fail(out ecx_552, out edx_553);
							Eq_2 esp_164 = <invalid>;
							esp_144 = (word32) esp_164 - 4;
						}
						word32 esi_172 = esp_144->dw000C;
						struct Eq_125505 * esp_174 = esp_144 - 4;
						esp_174->dw0000 = esi_172 + ~0x0001A11F;
						esp_174->dwFFFFFFFC = 0x01EB;
						esp_174->dwFFFFFFF8 = esi_172 + ~0x0001A0F4;
						esp_174->dwFFFFFFF4 = esi_172 + ~0x0001A1DF;
						word32 edx_555;
						word32 ecx_554;
						__assert_fail(out ecx_554, out edx_555);
						goto l080920EF;
					}
l08091F12:
					++esi_238;
					ebx_240 = (word32) esp_25->t0010 + esi_238;
					eax_242 = *esp_25->ptr0014;
				} while (*esp_25->t0004 > esi_238);
			}
			esp_25->t0010 = ebx_240;
			if (eax_242 <= ebx_240)
			{
l08091F32:
				esp_25->ptr0018->dw0000 = esp_25->t0008.dw0000;
				return;
			}
			Eq_2 esi_271 = *((word32) esp_25->t0004 + 4);
			esp_25->t0004 = esi_271;
		} while (esi_271 != 0x00);
		word32 esi_276 = esp_25->dw000C;
		struct Eq_125084 * esp_278 = esp_25 - 4;
		esp_278->dw0000 = esi_276 + ~0x0001A11F;
		esp_278->dwFFFFFFFC = 0x0205;
		esp_278->dwFFFFFFF8 = esi_276 + ~0x0001A0F4;
		esp_278->dwFFFFFFF4 = esi_276 + ~0x0001A0EB;
		Eq_2 esp_290 = <invalid>;
		word32 edx_536;
		word32 ecx_535;
		eax_242 = __assert_fail(out ecx_535, out edx_536);
		esp_25 = (word32) esp_290 - 4;
	}
	esp_25->t0004 = (word32) eax_242 + 0x0E;
	edx_303 = (Eq_125016) 0x080CFCC0;
	if (esp_25->ptr0018 != &g_t80CFCC8)
	{
		struct Eq_125126 * esp_364 = esp_25 - 0x08;
		esp_364->tFFFFFFFC = eax_242 * 0x08 + 0x80;
		esp_364->tFFFFFFF8 = esp_364->dw0020 - 0x08;
		Eq_2 esp_378 = <invalid>;
		word32 edi_539;
		word32 esi_538;
		word32 edx_537;
		Eq_2 eax_379 = __realloc(gs, esp_364->tFFFFFFF4, esp_364->tFFFFFFF8, esp_364->tFFFFFFFC, out edx_537, out ebp_328, out esi_538, out edi_539);
		esp_362 = (word32) esp_378 + 16;
		esi_342 = eax_379;
		if (eax_379 != 0x00)
		{
			edi_346 = ebp_328 * 0x08 + 0x10;
			goto l08091FE3;
		}
	}
	else
	{
l0809203F:
		esp_25->t0008.dw0000 = (up32) edx_303;
		struct Eq_125238 * esp_313 = esp_25 - 0x0C;
		esp_313->tFFFFFFFC = eax_242 * 0x08 + 0x80;
		word32 esi_545;
		word32 edi_546;
		word32 ecx_542;
		word32 edx_543;
		word32 ebx_544;
		Eq_2 eax_327 = __libc_malloc(gs, esp_313->tFFFFFFF8, esp_313->tFFFFFFFC, out ecx_542, out edx_543, out ebx_544, out ebp_328, out esi_545, out edi_546);
		Eq_2 edx_339 = esp_313->t0014;
		esi_342 = eax_327;
		if (eax_327 != 0x00)
		{
			edi_346 = ebp_328 * 0x08 + 0x10;
			esp_313->t0004 = edi_346;
			esp_313->t0000 = edx_339;
			esp_313->tFFFFFFFC = eax_327;
			word32 ecx_547;
			word32 edx_548;
			memcpy(esp_313->tFFFFFFFC, esp_313->t0000, esp_313->t0004, out ecx_547, out edx_548);
			esp_362 = (struct Eq_125015 *) ((char *) &esp_313->t0004 + 8);
l08091FE3:
			ui32 eax_398 = esp_362->dw0004;
			*esi_342 = eax_398;
			struct Eq_125179 * esp_402 = esp_362 - 0x04;
			esp_402->tFFFFFFFC = eax_398 - ebp_328 << 0x03;
			esp_402->tFFFFFFF8.u0 = 0x00;
			Mem413[esp_402 + -0x0C:word32] = edi_346 + esi_342;
			word32 ecx_540;
			word32 edx_541;
			memset(esp_402->tFFFFFFF4, esp_402->tFFFFFFF8, esp_402->tFFFFFFFC, out ecx_540, out edx_541);
			ptr32 eax_423 = (word32) esi_342 + 8;
			struct Eq_125214 * esi_424 = esp_402->ptr0044;
			esp_402->ptr001C = eax_423;
			esi_424->ptr0004 = eax_423;
			esp_25 = (struct Eq_125006 *) ((char *) &esp_402->tFFFFFFFC + 8);
			eax_242 = *esp_402->ptr0018;
			goto l08091E15;
		}
	}
l080920EF:
	oom(gs);
}

// 08092100: void _dl_allocate_tls(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_124985) dwArg04)
// Called from:
//      _dl_allocate_tls_init
void _dl_allocate_tls(struct Eq_9 * gs, struct Eq_124985 * dwArg04)
{
	if (dwArg04 == null)
	{
		_dl_allocate_tls_storage(gs);
		_dl_allocate_tls_init(gs, dwArg04);
	}
	else
	{
		struct Eq_124985 * eax_30 = allocate_dtv(gs);
		_dl_allocate_tls_init(gs, eax_30);
	}
}

// 08092140: void _dl_deallocate_tls(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_125618) dwArg00, Stack (ptr32 Eq_125619) dwArg04, Stack byte bArg08)
void _dl_deallocate_tls(struct Eq_9 * gs, struct Eq_125618 * dwArg00, struct Eq_125619 * dwArg04, byte bArg08)
{
	struct Eq_125621 * edi_21 = dwArg04->ptr0004;
	ptr32 esp_18 = fp - 0x1C;
	if (edi_21->dwFFFFFFF8 != 0x00)
	{
		uint32 esi_29 = 0x00;
		do
		{
			++esi_29;
			struct Eq_125640 * esp_33 = esp_18 - 0x0C;
			esp_33->tFFFFFFFC = edi_21->a0004[esi_29].t0000;
			word32 ecx_177;
			word32 edx_178;
			free(gs, esp_33->tFFFFFFF8, esp_33->tFFFFFFFC, out ecx_177, out edx_178);
			esp_18 = (char *) &esp_33->tFFFFFFFC + 20;
		} while (esi_29 < edi_21->dwFFFFFFF8);
	}
	if (edi_21 != &g_t80CFCC8)
	{
		struct Eq_125673 * esp_58 = esp_18 - 0x0C;
		esp_58->tFFFFFFFC = edi_21 - 0x08;
		word32 edx_180;
		word32 ecx_179;
		free(gs, esp_58->tFFFFFFF8, esp_58->tFFFFFFFC, out ecx_179, out edx_180);
	}
	if ((byte) dwArg08 == 0x00)
		return;
	word32 ecx_181;
	word32 edx_182;
	free(gs, dwLoc34, dwArg00->t04C0, out ecx_181, out edx_182);
}

// 080921E0: Register word32 _dl_tls_get_addr_soft(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_125705) dwArg04)
// Called from:
//      dlinfo_doit
//      __dl_iterate_phdr
word32 _dl_tls_get_addr_soft(struct Eq_9 * gs, struct Eq_125705 * dwArg04)
{
	uint32 eax_16 = dwArg04->dw0248;
	if (eax_16 == 0x00)
		return 0x00;
	struct Eq_125713 * edx_21 = gs->ptr0004;
	Eq_125016 edi_23 = edx_21->a0000[0].dw0000;
	if (edi_23 != _dl_tls_generation.dw0000)
	{
		if (eax_16 >= edx_21->dwFFFFFFF8)
			return 0x00;
		Eq_2 ecx_30 = _dl_tls_dtv_slotinfo_list;
		uint32 ebx_29 = eax_16;
		uint32 esi_31 = *ecx_30;
		if (eax_16 >= esi_31)
		{
			uint32 esi_34 = esi_31;
			do
			{
				ecx_30 = *((word32) ecx_30 + 4);
				ebx_29 -= esi_34;
				esi_34 = (uint32) *ecx_30;
			} while (esi_34 <= ebx_29);
		}
		if (edi_23 < *((word32) ecx_30 + (ebx_29 * 0x08 + 8)))
			return 0x00;
	}
	word32 eax_103 = edx_21[eax_16 * 0x08];
	if (eax_103 == ~0x00)
		eax_103 = 0x00;
	return eax_103;
}

// 08092260: Register word32 _dl_add_to_slotinfo(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_125761) ebpOut, Register out Eq_125762 esiOut, Register out (ptr32 Eq_125763) ediOut)
// Called from:
//      dl_open_worker
word32 _dl_add_to_slotinfo(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_125761 & ebpOut, union Eq_125762 & esiOut, struct Eq_125763 & ediOut)
{
	ptr32 ebx_17 = 0x080CE000;
	uint32 esi_149 = *((word32) dwArg04 + 584);
	Eq_2 edi_132 = _dl_tls_dtv_slotinfo_list;
	while (true)
	{
		word32 edx_141;
		uint32 eax_26 = *edi_132;
		if (eax_26 > esi_149)
			break;
		esi_149 -= eax_26;
		Eq_2 eax_31 = *((word32) edi_132 + 4);
		if (eax_31 == 0x00)
		{
			Eq_2 eax_51;
			if (esi_149 == 0x00)
			{
				struct Eq_125798 * edi_68;
				word32 ecx_227;
				word32 edx_228;
				word32 ebp_229;
				Eq_2 eax_64 = __libc_malloc(gs, dwLoc30, 0x01F8, out ecx_227, out edx_228, out ebx_17, out ebp_229, out esi_149, out edi_68);
				edi_68->t0004 = eax_64;
				eax_51.u0 = 0x080CFEC8;
				edx_141 = _dl_tls_generation.dw0000 + 0x01;
				if (eax_64 != 0x00)
				{
					*eax_64 = 0x3E;
					((word32) eax_64 + 4)->u0 = 0x00;
					word32 ecx_125;
					word32 * edi_128 = (word32) eax_64 + 8;
					for (ecx_125 = 0x7C; ecx_125 != 0x00; --ecx_125)
					{
						*edi_128 = esi_149;
						++edi_128;
					}
					edi_132 = eax_64;
					goto l080922AC;
				}
			}
			else
			{
				word32 ecx_226;
				eax_51 = __assert_fail(out ecx_226, out edx_141);
			}
			*eax_51.u0 = edx_141;
			struct Eq_125761 * ebp_101;
			word32 ecx_230;
			word32 edx_231;
			word32 ebx_232;
			word32 edi_233;
			_dl_signal_error(gs, 0x0C, ebx_17 + ~0x0001A157, out ecx_230, out edx_231, out ebx_232, out ebp_101, out edi_233);
			word32 ebx_116;
			struct Eq_125763 * edi_117;
			Eq_125762 esi_118;
			_dl_get_origin(gs, 0x0C, out ebx_116, out esi_118, out edi_117);
			ebpOut = ebp_101;
			esiOut = esi_118;
			ediOut = edi_117;
			return ebx_116;
		}
		edi_132 = eax_31;
	}
	edx_141 = _dl_tls_generation.dw0000 + 0x01;
l080922AC:
	struct Eq_125872 * eax_151 = (word32) edi_132 + esi_149 * 0x08;
	eax_151->dw0008 = edx_141;
	eax_151->t000C = dwArg04;
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return ebx;
}

// 08092350: Register Eq_2 _dl_get_origin(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out (ptr32 Eq_49202) ebxOut, Register out (ptr32 Eq_49203) esiOut, Register out (ptr32 Eq_49204) ediOut)
// Called from:
//      _dl_non_dynamic_init
//      expand_dynamic_string_token
//      _dl_add_to_slotinfo
//      _dl_map_object_deps
Eq_2 _dl_get_origin(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_49202 & ebxOut, struct Eq_49203 & esiOut, struct Eq_49204 & ediOut)
{
	Eq_2 ebp_195;
	int32 eax_29;
	Eq_2 ecx_31;
	gs->ptr0010();
	if (eax_29 <= 0x00 || bLoc101C == 0x5B)
	{
		Eq_2 edi_41 = _dl_origin_path;
		if (edi_41 != 0x00)
		{
			word32 edx_407;
			word32 ecx_406;
			Eq_2 eax_52 = strlen(edi_41, out ecx_406, out edx_407);
			Eq_2 edi_68;
			word32 ebp_411;
			word32 ecx_408;
			word32 edx_409;
			word32 ebx_410;
			word32 esi_412;
			Eq_2 eax_64 = __libc_malloc(gs, dwLoc1040, (word32) eax_52 + 1, out ecx_408, out edx_409, out ebx_410, out ebp_411, out esi_412, out edi_68);
			if (eax_64 != 0x00)
			{
				word32 edx_413;
				Eq_2 eax_101 = __mempcpy(eax_64, edi_68, eax_52, out edx_413);
				if ((word32) eax_64 + 1 < eax_101)
				{
					while (*((word32) eax_101 - 1) == 0x2F)
					{
						--eax_101;
						if ((word32) eax_64 + 1 == eax_101)
							break;
					}
				}
				*eax_101 = 0x00;
				ebxOut = ebx;
				esiOut = esi;
				ediOut = edi;
				return eax_64;
			}
		}
		goto l08092468;
	}
	if (bLoc101C != 0x2F)
	{
		word32 edx_399;
		word32 ecx_398;
		__assert_fail(out ecx_398, out edx_399);
		struct Eq_49202 * ebx_148;
		struct Eq_49204 * edi_150;
		struct Eq_49203 * esi_152;
		word32 ecx_414;
		Eq_2 eax_147 = _dl_scope_free(gs, dwArg04, out ecx_414, out ebx_148, out esi_152, out edi_150);
		ebxOut = ebx_148;
		esiOut = esi_152;
		ediOut = edi_150;
		return eax_147;
	}
	if (eax_29 != 0x01)
	{
		int32 edi_160 = eax_29 - 0x01;
		if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x101C)[eax_29 - 0x01].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == 0x2F)
		{
			edi_160 = eax_29;
l08092480:
			word32 edi_220;
			word32 ecx_416;
			word32 edx_417;
			word32 ebx_418;
			word32 ebp_419;
			word32 esi_420;
			Eq_2 eax_216 = __libc_malloc(gs, dwLoc1040, edi_160 + 0x01, out ecx_416, out edx_417, out ebx_418, out ebp_419, out esi_420, out edi_220);
			if (eax_216 != 0x00)
			{
				word32 edx_415;
				*__mempcpy(eax_216, ecx_31, edi_220 - 0x01, out edx_415) = 0x00;
				ebxOut = ebx;
				esiOut = esi;
				ediOut = edi;
				return eax_216;
			}
l08092468:
			ebp_195.u0 = ~0x00;
			goto l0809246D;
		}
		while (edi_160 != 0x01)
		{
			int32 eax_169 = edi_160 - 0x01;
			if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(ecx_31 - 0x01)[edi_160].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == 0x2F)
				goto l08092480;
			edi_160 = eax_169;
		}
	}
	word32 ebx_402;
	word32 ebp_403;
	word32 esi_404;
	word32 edi_405;
	word32 ecx_400;
	word32 edx_401;
	Eq_2 eax_183 = __libc_malloc(gs, dwLoc1040, 0x02, out ecx_400, out edx_401, out ebx_402, out ebp_403, out esi_404, out edi_405);
	ebp_195 = eax_183;
	if (eax_183 != 0x00)
	{
		eax_183->u4 = 0x2F;
l0809246D:
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return ebp_195;
	}
	goto l08092468;
}

// 080924E0: Register Eq_2 _dl_scope_free(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 ecxOut, Register out ptr32 ebxOut, Register out Eq_126001 esiOut, Register out (ptr32 Eq_126002) ediOut)
// Called from:
//      _dl_lookup_symbol_x
//      _dl_get_origin
//      dl_open_worker
//      _dl_close_worker
//      _dl_map_object_deps
Eq_2 _dl_scope_free(struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & ecxOut, ptr32 & ebxOut, union Eq_126001 & esiOut, struct Eq_106487 & ediOut)
{
	Eq_2 ecx_112;
	ptr32 esp_10 = fp - 0x0C;
	Eq_2 esi_103 = gs->t000C;
	if (esi_103 == 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 edx_184;
		free(gs, stackArg0, dwArg04, out ecx_112, out edx_184);
	}
	else
	{
		Eq_2 esi_21 = _dl_scope_free_list;
		if (esi_21 != 0x00)
		{
			uint32 eax_62 = *esi_21;
			if (eax_62 <= 0x31)
			{
				*esi_21 = eax_62 + 0x01;
				*((word32) esi_21 + (eax_62 * 0x04 + 4)) = dwArg04;
				ecx_112 = dwArg04;
				esi_103.u0 = 0x00;
			}
			else
			{
				_dl_wait_lookup_done();
				uint32 eax_70 = *esi_21;
				while (eax_70 != 0x00)
				{
					uint32 eax_75 = eax_70 - 0x01;
					*esi_21 = eax_75;
					struct Eq_126148 * esp_77 = esp_10 - 0x0C;
					esp_77->tFFFFFFFC = *((word32) esi_21 + (eax_75 * 0x04 + 4));
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_2 stackArg0 = <invalid>;
					Eq_2 stackArg4 = <invalid>;
					word32 edx_195;
					free(gs, stackArg0, stackArg4, out ecx_112, out edx_195);
					eax_70 = (uint32) *esi_21;
					esp_10 = (char *) &esp_77->tFFFFFFFC + 20;
				}
				esi_103.u0 = 0x01;
			}
		}
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			word32 edx_186;
			word32 ebx_187;
			word32 ebp_188;
			word32 esi_189;
			word32 edi_190;
			Eq_2 eax_29 = __libc_malloc(gs, stackArg0, 0xCC, out ecx_112, out edx_186, out ebx_187, out ebp_188, out esi_189, out edi_190);
			_dl_scope_free_list = eax_29;
			if (eax_29 != 0x00)
			{
				*eax_29 = 0x01;
				*((word32) eax_29 + 4) = dwArg04;
				esi_103.u0 = 0x00;
			}
			else
			{
				_dl_wait_lookup_done();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg0 = <invalid>;
				word32 edx_192;
				free(gs, stackArg0, dwArg04, out ecx_112, out edx_192);
				esi_103.u0 = 0x01;
			}
		}
	}
	ecxOut = ecx_112;
	ebxOut = ebx;
	esiOut = esi;
	ediOut = edi;
	return esi_103;
}

// 080925D0: void _dl_make_stack_executable(Register (ptr32 Eq_9) gs, Stack (ptr32 ui32) dwArg04)
void _dl_make_stack_executable(struct Eq_9 * gs, ui32 * dwArg04)
{
	Eq_2 eax_15 = _dl_pagesize;
	word32 edx_74;
	word32 ecx_73;
	if (mprotect(gs, -eax_15 & *dwArg04, eax_15, DW.ref.__gcc_personality_v0, out ecx_73, out edx_74) == 0x00)
	{
		*dwArg04 = 0x00;
		_dl_stack_flags |= 0x01;
	}
}

// 08092630: void _dl_runtime_resolve(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack word32 dwArg04)
void _dl_runtime_resolve(struct Eq_9 * gs, Eq_2 dwArg00, word32 dwArg04)
{
	_dl_fixup(dwArg00, dwArg04, gs);
}

// 08092660: void _dl_runtime_resolve_shstk(Register word32 eax, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack word32 dwArg04)
void _dl_runtime_resolve_shstk(word32 eax, struct Eq_9 * gs, Eq_2 dwArg00, word32 dwArg04)
{
	_dl_fixup(dwArg00, dwArg04, gs)();
}

// 08092690: void _dl_runtime_profile_shstk(Register word32 eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_126223 dwArg04, Stack Eq_2 dwArg08)
void _dl_runtime_profile_shstk(word32 eax, word32 ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_126223 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_39 = _dl_profile_fixup(dwArg00, dwArg08, dwArg04, gs, fp - 0x18);
	eax_39();
}

// 080926E0: void _dl_runtime_profile(Register word32 eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_126223 dwArg04, Stack Eq_2 dwArg08)
void _dl_runtime_profile(word32 eax, word32 ecx, word32 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_126223 dwArg04, Eq_2 dwArg08)
{
	_dl_profile_fixup(dwArg00, dwArg08, dwArg04, gs, fp - 0x18);
}

// 08092729: void fn08092729(Register (ptr32 code) eax, Register uint32 edx, Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg18, Stack word32 dwArg1C)
// Called from:
//      _dl_runtime_profile_shstk
//      _dl_runtime_profile
void fn08092729(<anonymous> * eax, uint32 edx, word32 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg18, word32 dwArg1C)
{
	word32 * esi_14 = fp + 0x24;
	word32 * edi_19 = fp - 8 - ((edx | 0x04) & ~0x03);
	uint32 ecx_22;
	for (ecx_22 = edx >> 0x02; ecx_22 != 0x00; --ecx_22)
	{
		*edi_19 = *esi_14;
		++esi_14;
		++edi_19;
	}
	eax();
	_dl_call_pltexit();
}

// 080927C0: void length_mismatch(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_exception_create_format
void length_mismatch(struct Eq_9 * gs)
{
	_dl_dprintf();
	_exit(gs, 0x7F);
}

// 080927F0: void _dl_exception_create(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      length_mismatch
//      _dl_signal_error
//      _dl_check_map_versions
void _dl_exception_create(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 edi_25;
	if (dwArg08 != 0x00)
	{
		word32 ecx_185;
		word32 edx_186;
		edi_25 = (word32) strlen(dwArg08, out ecx_185, out edx_186) + 1;
	}
	else
	{
		edi_25.u0 = 0x01;
		dwArg08.u0 = 134955513;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	word32 ecx_190;
	word32 edx_191;
	Eq_2 eax_49 = strlen(dwArg0C, out ecx_190, out edx_191);
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_194;
	word32 edx_195;
	word32 ebx_196;
	word32 ebp_197;
	word32 esi_198;
	word32 edi_199;
	Eq_2 eax_63 = __libc_malloc(gs, stackArg0, (word32) edi_25 + ((word32) eax_49 + 1), out ecx_194, out edx_195, out ebx_196, out ebp_197, out esi_198, out edi_199);
	if (eax_63 == 0x00)
	{
		((word32) dwArg04 + 8)->u0 = 0x00;
		dwArg04->u0 = 134955513;
		((word32) dwArg04 + 4)->u0 = 0x080B4000;
	}
	else
	{
		word32 edx_187;
		word32 ecx_188;
		word32 edx_189;
		*dwArg04 = memcpy(__mempcpy(eax_63, dwArg0C, (word32) eax_49 + 1, out edx_187), dwArg08, edi_25, out ecx_188, out edx_189);
		*((word32) dwArg04 + 4) = eax_63;
		*((word32) dwArg04 + 8) = eax_63;
	}
}

// 080928D0: void _dl_exception_create_format(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      _dl_lookup_symbol_x
//      _dl_check_map_versions
void _dl_exception_create_format(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 dwLoc20_360;
	Eq_2 ebp_104;
	Eq_2 edi_183 = dwArg0C;
	if (dwArg08 != 0x00)
	{
		word32 ecx_503;
		word32 edx_504;
		Eq_2 eax_35 = strlen(dwArg08, out ecx_503, out edx_504);
		ebp_104 = (word32) eax_35 + 2;
		dwLoc20_360 = (word32) eax_35 + 1;
	}
	else
	{
		ebp_104.u0 = 0x02;
		dwLoc20_360.u0 = 0x01;
		dwArg08.u0 = 134955513;
	}
	byte dl_54 = *dwArg0C;
	word32 * esi_129 = fp + 0x10;
	if (dl_54 != 0x00)
	{
		Eq_2 ebx_351 = dwArg0C;
		do
		{
			word32 eax_61 = (word32) *((word32) ebx_351 + 1);
			byte al_73 = (byte) eax_61;
			Eq_2 ecx_62 = (word32) ebx_351 + 1;
			if (dl_54 != 0x25)
			{
				ebp_104 = (word32) ebp_104 + 1;
				ebx_351 = ecx_62;
				goto l08092937;
			}
			dl_54 = (byte) *((word32) ebx_351 + 2);
			ebx_351 = (word32) ebx_351 + 2;
			if (al_73 == 115)
			{
				++esi_129;
				eax_61 = (word32) dl_54;
				word32 edx_513;
				word32 ecx_512;
				ebp_104 += strlen(*esi_129, out ecx_512, out edx_513);
l08092937:
				dl_54 = (byte) eax_61;
				if (dl_54 != 0x00)
					continue;
				break;
			}
			ebp_104 = (word32) ebp_104 + 1;
		} while (dl_54 != 0x00);
		if (ebp_104 < 0x00)
		{
l08092A50:
			((word32) dwArg04 + 8)->u0 = 0x00;
			dwArg04->u0 = 134955513;
			((word32) dwArg04 + 4)->u0 = 0x080B4000;
			return;
		}
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ebp_509;
	word32 esi_510;
	word32 edi_511;
	word32 ebx_508;
	word32 ecx_506;
	word32 edx_507;
	Eq_2 eax_135 = __libc_malloc(gs, stackArg0, ebp_104, out ecx_506, out edx_507, out ebx_508, out ebp_509, out esi_510, out edi_511);
	Eq_2 ebx_140 = eax_135;
	if (eax_135 != 0x00)
	{
		ptr32 esp_198;
		*((word32) dwArg04 + 4) = eax_135;
		*((word32) dwArg04 + 8) = eax_135;
		word32 ebp_166 = ebp_104 + eax_135;
		byte dl_171 = *dwArg0C;
		word32 * eax_170 = fp + 0x10;
		while (dl_171 != 0x00)
		{
			Eq_2 esi_184;
			esp_198 = fp - 44;
			if (dl_171 != 0x25)
			{
				if (ebp_166 == ebx_140)
					goto l08092AE0;
				*ebx_140 = dl_171;
				esi_184 = edi_183;
				++ebx_140;
				goto l080929AF;
			}
			byte dl_190 = *((word32) edi_183 + 1);
			esi_184 = (word32) edi_183 + 1 + 0x01;
			if (dl_190 != 0x25)
			{
				if (dl_190 != 115)
					goto l08092AE5;
				Eq_2 edi_197 = *eax_170;
				word32 * ecx_196 = eax_170 + 1;
				word32 ecx_516;
				word32 edx_517;
				Eq_2 eax_204 = strlen(edi_197, out ecx_516, out edx_517);
				if (ebp_166 - ebx_140 < eax_204)
					goto l08092AE0;
				word32 edx_518;
				ebx_140 = __mempcpy(ebx_140, edi_197, eax_204, out edx_518);
				eax_170 = ecx_196;
l080929AF:
				dl_171 = (byte) *esi_184;
				edi_183 = (word32) esi_184 + 1;
				if (dl_171 != 0x00)
					continue;
				break;
			}
			if (ebp_166 == ebx_140)
				goto l08092AE0;
			dl_171 = (byte) *((word32) esi_184 + 1);
			*ebx_140 = 0x25;
			edi_183 = (word32) esi_184 + 1;
			ebx_140 = (word32) ebx_140 + 1;
		}
		if (ebp_166 != ebx_140)
		{
			*ebx_140 = 0x00;
			Eq_2 ebx_266 = (word32) ebx_140 + 1;
			if (ebp_166 - ebx_266 == dwLoc20_360)
			{
				word32 edx_515;
				word32 ecx_514;
				*dwArg04 = memcpy(ebx_266, dwArg08, dwLoc20_360, out ecx_514, out edx_515);
				return;
			}
		}
l08092AE0:
		length_mismatch(gs);
		esp_198 = fp - 0x30;
l08092AE5:
		struct Eq_126545 * esp_288 = esp_198 - 0x08;
		esp_288->dwFFFFFFFC = esp_288->dw000C + ~0x0001A033;
		esp_288->tFFFFFFF8.u0 = 0x02;
		_dl_dprintf();
		esp_288->tFFFFFFF8.u0 = 0x7F;
		_exit(gs, esp_288->tFFFFFFF8);
	}
	goto l08092A50;
}

// 08092B10: void _dl_exception_free(Stack (ptr32 Eq_126606) dwArg04)
// Called from:
//      _dl_exception_create_format
//      _dl_map_object_deps
void _dl_exception_free(struct Eq_126606 * dwArg04)
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	word32 ecx_40;
	word32 edx_41;
	free(gs, stackArg0, dwArg04->t0008, out ecx_40, out edx_41);
	dwArg04->dw0000 = 0x00;
	dwArg04->dw0004 = 0x00;
	dwArg04->t0008.u0 = 0x00;
}

// 08092B50: Register int32 _dl_cache_libcmp(Stack Eq_2 dwArg04, Stack (ptr32 Eq_126632) dwArg08)
// Called from:
//      _dl_load_cache_lookup
int32 _dl_cache_libcmp(Eq_2 dwArg04, struct Eq_126632 * dwArg08)
{
	Eq_2 ebx_138 = dwArg04;
	struct Eq_126632 * dwLoc14_180 = dwArg08;
l08092B66:
	int32 eax_108;
	int32 eax_141 = (int32) *ebx_138;
	int32 edx_143 = (int32) dwLoc14_180->b0000;
	while ((byte) eax_141 != 0x00)
	{
		byte dl_124 = (byte) edx_143;
		byte al_123 = (byte) eax_141;
		cu8 cl_40 = (byte) (edx_143 - 0x30);
		if ((byte) (eax_141 - 0x30) <= 0x09)
		{
			if (cl_40 > 0x09)
			{
				eax_108 = 0x01;
				return eax_108;
			}
			else
			{
				int32 edx_47 = (int32) *((word32) ebx_138 + 1);
				int32 ebp_100 = edx_143 - 0x30;
				int32 eax_104 = eax_141 - 0x30;
				ebx_138 = (word32) ebx_138 + 1;
				while ((byte) (edx_47 - 0x30) <= 0x09)
				{
					ebx_138 = (word32) ebx_138 + 1;
					edx_47 = (int32) *ebx_138;
					eax_104 = edx_47 - 0x30 + eax_104 * 0x0A;
				}
				int32 edx_78 = (int32) dwLoc14_180[1];
				++dwLoc14_180;
				while ((byte) (edx_78 - 0x30) <= 0x09)
				{
					struct Eq_126632 * v20_87 = dwLoc14_180 + 1;
					edx_78 = (int32) v20_87->b0000;
					dwLoc14_180 = v20_87;
					ebp_100 = edx_78 - 0x30 + ebp_100 * 0x0A;
				}
				if (ebp_100 == eax_104)
					goto l08092B66;
				eax_108 = eax_104 - ebp_100;
				return eax_108;
			}
		}
		if (cl_40 <= 0x09)
			return ~0x00;
		if (al_123 != dl_124)
			return eax_141 - edx_143;
		ebx_138 = (word32) ebx_138 + 1;
		struct Eq_126632 * v18_139 = dwLoc14_180 + 1;
		eax_141 = (int32) *ebx_138;
		dwLoc14_180 = v18_139;
		edx_143 = (int32) v18_139->b0000;
	}
	eax_108 = -(int32) (byte) edx_143;
	return eax_108;
}

// 08092C60: Register Eq_2 _dl_load_cache_lookup(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_map_object
Eq_2 _dl_load_cache_lookup(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if ((_dl_debug_mask & 0x01) != 0x00)
	{
		word32 edx_1506;
		word32 ecx_1505;
		_dl_debug_printf(out ecx_1505, out edx_1506);
	}
	Eq_2 esi_186;
	Eq_2 edi_190 = cache;
	if (edi_190 == 0x00)
	{
		word32 ecx_1507;
		word32 edx_1508;
		Eq_2 eax_66 = _dl_sysdep_read_whole_file(gs, 0x080B400E, &cachesize, 0x01, out ecx_1507, out edx_1508);
		edi_190 = eax_66;
		if (eax_66 != ~0x00)
		{
			esi_186 = cachesize;
			if (esi_186 > 0x10)
			{
				if (*eax_66 == 1932420204 && (*((word32) eax_66 + 4) == 774974831 && (*((word32) eax_66 + 8) == 11831 && *((word32) eax_66 + 0x0A) == 0x30)))
				{
					cache = eax_66;
					Eq_127335 eax_92 = *((word32) eax_66 + 0x0C) * 0x0C + 0x10;
					word32 ecx_93 = eax_66 + eax_92;
					cache_new = ecx_93;
					if (esi_186 >= (word32) eax_92 + 48)
					{
						word32 ecx_1524;
						word32 edx_1525;
						if (memcmp(ecx_93, 0x080B403D, 0x14, out ecx_1524, out edx_1525) == 0x00)
							goto l08092CAF;
					}
					cache_new.u0 = ~0x00;
					goto l08092CAF;
				}
				if (esi_186 > 0x30)
				{
					ebx.u0 = 0x080CE000;
					word32 edx_1523;
					word32 ecx_1522;
					if (memcmp(eax_66, 0x080B403D, 0x14, out ecx_1522, out edx_1523) == 0x00)
					{
						cache_new = eax_66;
						cache = eax_66;
						goto l08092CAF;
					}
				}
			}
			word32 ecx_1519;
			word32 edx_1520;
			word32 ebx_1521;
			__munmap(ebx, gs, eax_66, esi_186, out ecx_1519, out edx_1520, out ebx_1521);
		}
		cache.u0 = ~0x00;
		return 0x00;
	}
	else
	{
		if (edi_190 == ~0x00)
			return 0x00;
		esi_186 = cachesize;
l08092CAF:
		Eq_2 dwLoc40_1047;
		word32 eax_194 = edi_190 + esi_186;
		Eq_2 ebx_195 = cache_new;
		if (ebx_195 != ~0x00)
		{
			ui32 dwLoc64_1381;
			ui32 dwLoc68_1372;
			Eq_2 eax_405 = eax_194 - ebx_195;
			Eq_2 ebx_408 = _dl_platform;
			if (ebx_408 != 0x00)
			{
				word32 edx_1510;
				word32 ecx_1509;
				if (strcmp(ebx_408, 134891488, out ecx_1509, out edx_1510) != 0x00)
				{
					word32 edx_1512;
					word32 ecx_1511;
					Eq_2 eax_443 = strcmp(ebx_408, 134891497, out ecx_1511, out edx_1512);
					dwLoc64_1381 = ~(0x00 - (eax_443 < 0x01));
					dwLoc68_1372 = (0x00 - (eax_443 < 0x01) & 0x00020001) - 0x01;
				}
				else
				{
					dwLoc64_1381 = 0x00;
					dwLoc68_1372 = 0x00010000;
				}
			}
			else
			{
				dwLoc64_1381 = ~0x00;
				dwLoc68_1372 = ~0x00;
			}
			__tunable_get_val(0x10, fp - 0x24, null);
			Eq_2 ebx_485 = cache_new;
			int32 eax_495 = *((word32) ebx_485 + 20);
			ui32 esi_492 = g_dw80CF8C8;
			ui32 eax_493 = g_dw80CF8CC;
			int32 edi_499 = eax_495 - 0x01;
			if (eax_495 >= 0x01)
			{
				int32 esi_503 = eax_495 - 0x01 >> 0x01;
				Eq_2 eax_505 = *((word32) ebx_485 + (esi_503 * 0x18 + 52));
				if (eax_405 > eax_505)
				{
					int32 ebx_508 = 0x00;
					do
					{
						word32 eax_523 = _dl_cache_libcmp(dwArg04, eax_505 + ebx_195);
						if (eax_523 == 0x00)
						{
							int32 edi_540;
							if (esi_503 != 0x00)
							{
								int32 edi_543 = esi_503 - 0x01;
								Eq_2 eax_546 = *((word32) ebx_485 + (edi_543 * 0x18 + 52));
								if (eax_405 > eax_546)
								{
									int32 esi_552 = edi_543;
									struct Eq_126932 * ebx_553 = (word32) ebx_485 + 4 + esi_503 * 0x18;
									while (true)
									{
										edi_540 = esi_552 + 0x01;
										if (_dl_cache_libcmp(dwArg04, eax_546 + ebx_195) != 0x00)
											break;
										if (esi_552 == 0x00)
										{
l08093060:
											edi_540 = esi_552;
											break;
										}
										ebx_553 -= 0x18;
										int32 edi_584 = esi_552 - 0x01;
										eax_546 = ebx_553[1];
										if (eax_405 <= eax_546)
											goto l08093060;
										esi_552 = edi_584;
									}
								}
								else
									edi_540 = esi_503;
							}
							else
								edi_540 = 0x00;
							ui32 eax_600 = _dl_correct_cache_id;
							dwLoc40_1047.u0 = 0x00;
							uint32 eax_605 = _dl_osversion;
							struct Eq_126977 * ebx_610 = (word32) ebx_485 + 48 + edi_540 * 0x18;
							ui32 eax_612 = eax_493 & dwLoc20;
							do
							{
								if (edi_540 > esi_503)
								{
									Eq_2 eax_623 = ebx_610->dw0004;
									if (eax_623 >= eax_405 || _dl_cache_libcmp(dwArg04, eax_623 + ebx_195) != 0x00)
										break;
								}
								ui32 eax_649 = ebx_610->dw0000;
								if ((eax_649 & ~0x02) == 0x01)
								{
									Eq_2 ecx_654 = ebx_610->dw0008;
									if (ecx_654 < eax_405 && (dwLoc40_1047 == 0x00 || eax_600 == eax_649))
									{
										ui32 ecx_670 = ebx_610->dw0014;
										if ((~(eax_612 | 0x80030000) & ecx_670 | ~(esi_492 & dwLoc24) & ebx_610->dw0010) == 0x00 && (eax_605 == 0x00 || eax_605 >= ebx_610->dw000C) && ((dwLoc68_1372 ^ ecx_670 & 0x00030000 | dwLoc64_1381) == 0x00 || (ecx_670 & 0x00030000) == 0x00))
										{
											dwLoc40_1047 = ecx_654 + ebx_195;
											if (eax_600 == eax_649)
												break;
										}
									}
								}
								++edi_540;
								++ebx_610;
							} while (edi_540 <= edi_499);
							goto l08092F40;
						}
						if (eax_523 < 0x00)
						{
							ebx_508 = esi_503 + 0x01;
							if (edi_499 < ebx_508)
								return 0x00;
						}
						else
						{
							edi_499 = esi_503 - 0x01;
							if (edi_499 < ebx_508)
								return 0x00;
						}
						int32 edx_881 = edi_499 + ebx_508;
						esi_503 = edx_881 >> 0x01;
						eax_505 = *((word32) ebx_485 + (((edx_881 >> 0x01) + (edx_881 >> 0x01) * 0x02) * 0x08 + 52));
					} while (eax_405 > eax_505);
				}
			}
		}
		else
		{
			int32 eax_199 = *((word32) edi_190 + 0x0C);
			int32 ecx_201 = eax_199 * 0x0C + 0x10;
			up32 esi_202 = esi_186 - ecx_201;
			ptr32 ebx_203 = (word32) edi_190 + ecx_201;
			if (eax_199 >= 0x01)
			{
				int32 esi_212 = eax_199 - 0x01 >> 0x01;
				up32 eax_214 = *((word32) edi_190 + (esi_212 * 0x0C + 20));
				if (esi_202 > eax_214)
				{
					int32 edi_221 = 0x00;
					int32 ebx_222 = eax_199 - 0x01;
					do
					{
						int32 eax_235 = _dl_cache_libcmp(dwArg04, eax_214 + ebx_203);
						if (eax_235 == 0x00)
						{
							int32 ebx_253;
							if (esi_212 != 0x00)
							{
								int32 ebx_256 = esi_212 - 0x01;
								up32 eax_258 = *((word32) edi_190 + (ebx_256 * 0x0C + 20));
								if (esi_202 > eax_258)
								{
									int32 esi_266 = ebx_256;
									struct Eq_127198 * edi_267 = edi_190 - 0x04 + esi_212 * 0x0C;
									while (true)
									{
										ebx_253 = esi_266 + 0x01;
										if (_dl_cache_libcmp(dwArg04, eax_258 + ebx_203) != 0x00)
											break;
										if (esi_266 == 0x00)
										{
l08093198:
											ebx_253 = esi_266;
											break;
										}
										edi_267 -= 0x0C;
										int32 ebx_298 = esi_266 - 0x01;
										eax_258 = (up32) edi_267[1];
										if (esi_202 <= eax_258)
											goto l08093198;
										esi_266 = ebx_298;
									}
								}
								else
									ebx_253 = esi_212;
							}
							else
								ebx_253 = 0x00;
							dwLoc40_1047.u0 = 0x00;
							ui32 eax_316 = _dl_correct_cache_id;
							struct Eq_127226 * edi_321 = (word32) edi_190 + 16 + ebx_253 * 0x0C;
							do
							{
								if (ebx_253 > esi_212)
								{
									up32 eax_328 = edi_321->dw0004;
									if (eax_328 >= esi_202 || _dl_cache_libcmp(dwArg04, eax_328 + ebx_203) != 0x00)
										break;
								}
								ui32 eax_354 = edi_321->dw0000;
								if ((eax_354 & ~0x02) == 0x01)
								{
									up32 edx_359 = edi_321->dw0008;
									if (edx_359 < esi_202)
									{
										if (dwLoc40_1047 == 0x00)
										{
											dwLoc40_1047 = edx_359 + ebx_203;
											if (eax_316 == eax_354)
												break;
										}
										else if (eax_316 == eax_354)
										{
											dwLoc40_1047 = edx_359 + ebx_203;
											break;
										}
									}
								}
								++ebx_253;
								++edi_321;
							} while (ebx_253 <= ebx_222);
l08092F40:
							if ((_dl_debug_mask & 0x01) == 0x00)
							{
								if (dwLoc40_1047 == 0x00)
									return 0x00;
							}
							else
							{
								if (dwLoc40_1047 == 0x00)
									return 0x00;
								word32 ecx_1517;
								word32 edx_1518;
								_dl_debug_printf(out ecx_1517, out edx_1518);
							}
							word32 ecx_1513;
							word32 edx_1514;
							Eq_2 eax_781 = strlen(dwLoc40_1047, out ecx_1513, out edx_1514);
							struct Eq_127094 * esp_788 = fp - 0x6C;
							struct Eq_127094 * esi_793 = fp - 0x6C - ((word32) eax_781 + 28 & ~0x0FFF);
							ui32 ecx_794 = (word32) eax_781 + 28 & ~0x0F;
							if (fp - 0x6C != esi_793)
							{
								do
								{
									esp_788 -= 0x1000;
									esp_788->dw0FFC = esp_788->dw0FFC;
								} while (esp_788 != esi_793);
							}
							if ((ecx_794 & 0x0FFF) != 0x00)
							{
								esp_788 -= ecx_794 & 0x0FFF;
								(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_788 - 0x04)[(ecx_794 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_788 - 0x04)[(ecx_794 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
							}
							struct Eq_127137 * esp_826 = esp_788 - 0x04;
							esp_826->tFFFFFFFC = (word32) eax_781 + 1;
							esp_826->tFFFFFFF8 = dwLoc40_1047;
							Eq_127148 esi_821 = (char *) esp_788 + 0x0F;
							esp_826->tFFFFFFF4 = esi_821 & ~0x0F;
							word32 edx_1516;
							word32 ecx_1515;
							memcpy(esp_826->tFFFFFFF4, esp_826->tFFFFFFF8, esp_826->tFFFFFFFC, out ecx_1515, out edx_1516);
							esp_826->tFFFFFFF4 = esi_821 & ~0x0F;
							return strdup(esp_826->tFFFFFFF4);
						}
						if (eax_235 < 0x00)
							edi_221 = esi_212 + 0x01;
						else
							ebx_222 = esi_212 - 0x01;
						if (edi_221 > ebx_222)
							return 0x00;
						int32 edx_395 = edi_221 + ebx_222;
						esi_212 = edx_395 >> 0x01;
						eax_214 = (up32) *((word32) edi_190 + (((edx_395 >> 0x01) + (edx_395 >> 0x01) * 0x02) * 0x04 + 20));
					} while (esi_202 > eax_214);
				}
			}
		}
		return 0x00;
	}
}

// 08093340: Register word32 _dl_unload_cache(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_open
word32 _dl_unload_cache(struct Eq_9 * gs)
{
	Eq_2 eax_10 = cache;
	if (eax_10 > ~0x01)
		return ebx;
	struct Eq_127370 * ebx_23;
	word32 ecx_64;
	word32 edx_65;
	__munmap(0x080CE000, gs, eax_10, cachesize, out ecx_64, out edx_65, out ebx_23);
	ebx_23->dw1A7C = 0x00;
	return dwArg00;
}

// 080933A0: void _dl_tlsdesc_return()
void _dl_tlsdesc_return()
{
}

// 080933B0: void _dl_tlsdesc_undefweak()
void _dl_tlsdesc_undefweak()
{
}

// 080933C0: void _dl_tlsdesc_resolve_abs_plus_addend(Register (ptr32 Eq_127386) eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_127389) ebx, Register (ptr32 Eq_9) gs)
void _dl_tlsdesc_resolve_abs_plus_addend(struct Eq_127386 * eax, word32 ecx, word32 edx, struct Eq_127389 * ebx, struct Eq_9 * gs)
{
	_dl_tlsdesc_resolve_abs_plus_addend_fixup(eax, 0x14, ebx->t0004, gs, dwLoc10);
	eax->ptr0000();
}

// 080933E0: void _dl_tlsdesc_resolve_rel(Register (ptr32 Eq_127386) eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_127410) ebx, Register (ptr32 Eq_9) gs)
void _dl_tlsdesc_resolve_rel(struct Eq_127386 * eax, word32 ecx, word32 edx, struct Eq_127410 * ebx, struct Eq_9 * gs)
{
	_dl_tlsdesc_resolve_rel_fixup(eax, 0x14, ebx->t0004, gs, dwLoc10);
	eax->ptr0000();
}

// 08093400: void _dl_tlsdesc_resolve_rela(Register (ptr32 Eq_127386) eax, Register word32 ecx, Register word32 edx, Register (ptr32 Eq_127431) ebx, Register (ptr32 Eq_9) gs)
void _dl_tlsdesc_resolve_rela(struct Eq_127386 * eax, word32 ecx, word32 edx, struct Eq_127431 * ebx, struct Eq_9 * gs)
{
	_dl_tlsdesc_resolve_rela_fixup(eax, 0x14, ebx->t0004, gs, dwLoc10);
	eax->ptr0000();
}

// 08093420: void _dl_tlsdesc_resolve_hold(Register (ptr32 (ptr32 code)) eax, Register word32 ecx, Register word32 edx)
void _dl_tlsdesc_resolve_hold(<anonymous> ** eax, word32 ecx, word32 edx)
{
	_dl_tlsdesc_resolve_hold_fixup(eax, 0x14, dwLoc10);
	(*eax)();
}

// 08093440: void do_dlopen(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_127464) dwArg04)
void do_dlopen(struct Eq_9 * gs, struct Eq_127464 * dwArg04)
{
	dwArg04->dw000C = _dl_open(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->dw0008, ~0x01, __libc_argc, __libc_argv, environ);
}

// 08093490: Register Eq_2 dlerror_run(Register (ptr32 Eq_9) gs, Register out Eq_127497 ecxOut)
// Called from:
//      __libc_dlclose
//      __libc_dlsym
//      __libc_dlvsym
//      __libc_dlsym_private
//      __libc_dlopen_mode
Eq_2 dlerror_run(struct Eq_9 * gs, union Eq_127497 & ecxOut)
{
	ui32 ecx_11 = gs->dw0014;
	word32 ecx_134;
	word32 edx_135;
	word32 esi_136;
	Eq_2 eax_34 = _dl_catch_error(gs, fp - 0x18, fp - 0x14, fp - 0x19, out ecx_134, out edx_135, out esi_136);
	if (eax_34 != 0x00 && bLoc19 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg0 = <invalid>;
		word32 ecx_140;
		word32 edx_141;
		free(gs, stackArg0, 0x00, out ecx_140, out edx_141);
	}
	Eq_127497 ecx_71 = ecx_11 ^ gs->dw0014;
	if (ecx_71 != 0x00)
	{
		word32 ecx_137;
		word32 edx_138;
		__stack_chk_fail(out ecx_137, out edx_138);
		Eq_127497 ecx_88;
		Eq_2 eax_90 = __libc_dlclose(out ecx_88);
		ecxOut = ecx_88;
		return eax_90;
	}
	else
	{
		ecxOut = ecx_71;
		return eax_34;
	}
}

// 08093520: Register word32 __libc_dlclose(Register out Eq_979 ecxOut)
// Called from:
//      do_release_shlib
//      dlerror_run
//      do_release_all
word32 __libc_dlclose(union Eq_979 & ecxOut)
{
	word32 ecx_20;
	word32 eax_10 = dlerror_run(gs, out ecx_20);
	ecxOut.u0 = <invalid>;
	return eax_10;
}

// 08093540: Register (ptr32 Eq_127563) __libc_dlsym(Register (ptr32 Eq_9) gs, Register out Eq_67344 ecxOut)
// Called from:
//      __gconv_find_shlib
struct Eq_127563 * __libc_dlsym(struct Eq_9 * gs, union Eq_67344 & ecxOut)
{
	ui32 ecx_9 = gs->dw0014;
	word32 ecx_113;
	word32 eax_20 = dlerror_run(gs, out ecx_113);
	struct Eq_127563 * edx_24 = null;
	if (eax_20 == 0x00)
	{
		edx_24 = dwLoc14;
		if (dwLoc14 != null)
		{
			if (dwLoc14->w000E != ~0x0E)
			{
				if (dwLoc18 != null)
					eax_20 = *dwLoc18;
			}
			else
				eax_20 = 0x00;
			edx_24 = eax_20 + dwLoc14->dw0004;
		}
	}
	Eq_67344 ecx_54 = ecx_9 ^ gs->dw0014;
	if (ecx_54 != 0x00)
	{
		word32 ecx_114;
		word32 edx_115;
		__stack_chk_fail(out ecx_114, out edx_115);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg12 = <invalid>;
		Eq_67344 ecx_72;
		struct Eq_127563 * eax_71 = __libc_dlvsym(gs, stackArg12, out ecx_72);
		ecxOut = ecx_72;
		return eax_71;
	}
	else
	{
		ecxOut = ecx_54;
		return edx_24;
	}
}

// 080935D0: Register (ptr32 Eq_127617) __libc_dlvsym(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg0C, Register out (ptr32 word32) ecxOut)
// Called from:
//      __libc_dlsym
struct Eq_127617 * __libc_dlvsym(struct Eq_9 * gs, Eq_2 dwArg0C, word32 & ecxOut)
{
	ui32 esi_14 = gs->dw0014;
	if ((word32) *dwArg0C != 0x00 && ((word32) (*((word32) dwArg0C + 1)) != 0x00 && ((word32) (*((word32) dwArg0C + 2)) != 0x00 && ((word32) (*((word32) dwArg0C + 3)) != 0x00 && (word32) (*((word32) dwArg0C + 4)) != 0x00))))
	{
		byte * eax_44 = (word32) dwArg0C + 5;
		if ((word32) *((word32) dwArg0C + 5) != 0x00)
		{
			do
				++eax_44;
			while ((word32) *eax_44 != 0x00);
		}
	}
	word32 * ecx_190;
	word32 eax_100 = dlerror_run(gs, out ecx_190);
	struct Eq_127617 * edx_105 = null;
	if (eax_100 == 0x00)
	{
		edx_105 = dwLoc24;
		if (dwLoc24 != null)
		{
			if (dwLoc24->w000E != ~0x0E)
			{
				ecx_190 = dwLoc28;
				if (dwLoc28 != null)
					eax_100 = *dwLoc28;
			}
			else
				eax_100 = 0x00;
			edx_105 = eax_100 + dwLoc24->dw0004;
		}
	}
	if ((esi_14 ^ gs->dw0014) != 0x00)
	{
		word32 edx_207;
		word32 ecx_206;
		__stack_chk_fail(out ecx_206, out edx_207);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		word32 * ecx_130;
		struct Eq_127617 * eax_129 = do_dlsym_private(gs, stackArg4, out ecx_130);
		ecxOut = ecx_130;
		return eax_129;
	}
	else
	{
		ecxOut = ecx_190;
		return edx_105;
	}
}

// 080936E0: Register ui32 do_dlsym_private(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      __libc_dlvsym
ui32 do_dlsym_private(struct Eq_9 * gs, Eq_2 dwArg04, ptr32 & ecxOut)
{
	ui32 ecx_11 = gs->dw0014;
	Eq_2 eax_22 = *dwArg04;
	*((word32) dwArg04 + 0x0C) = 0x00;
	ptr32 ecx_45;
	word32 edx_104;
	*((word32) dwArg04 + 8) = _dl_lookup_symbol_x(gs, *((word32) dwArg04 + 4), eax_22, (word32) dwArg04 + 0x0C, *((word32) eax_22 + 464), fp - 0x20, 0x00, 0x00, 0x00, out ecx_45, out edx_104);
	ui32 eax_51 = ecx_11 ^ gs->dw0014;
	if (eax_51 != 0x00)
	{
		word32 ecx_105;
		word32 edx_106;
		__stack_chk_fail(out ecx_105, out edx_106);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		ptr32 ecx_62;
		ui32 eax_61 = do_dlsym(stackArg4, out ecx_62);
		ecxOut = ecx_62;
		return eax_61;
	}
	else
	{
		ecxOut = ecx_45;
		return eax_51;
	}
}

// 08093770: Register Eq_2 do_dlsym(Stack Eq_2 dwArg04, Register out Eq_979 ecxOut)
// Called from:
//      do_dlsym_private
Eq_2 do_dlsym(Eq_2 dwArg04, union Eq_979 & ecxOut)
{
	Eq_2 eax_10 = *dwArg04;
	*((word32) dwArg04 + 0x0C) = 0x00;
	word32 ecx_55;
	word32 edx_56;
	Eq_2 eax_31 = _dl_lookup_symbol_x(gs, *((word32) dwArg04 + 4), eax_10, (word32) dwArg04 + 0x0C, (word32) eax_10 + 468, 0x00, 0x00, 0x02, 0x00, out ecx_55, out edx_56);
	*((word32) dwArg04 + 8) = eax_31;
	ecxOut.u0 = <invalid>;
	return eax_31;
}

// 080937B0: void do_dlvsym(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_127804) dwArg04)
void do_dlvsym(struct Eq_9 * gs, struct Eq_127804 * dwArg04)
{
	Eq_2 eax_10 = dwArg04->t0000;
	dwArg04->dw000C = 0x00;
	word32 ecx_60;
	word32 edx_61;
	dwArg04->t0008 = _dl_lookup_symbol_x(gs, dwArg04->t0004, eax_10, &dwArg04->dw000C, (word32) eax_10 + 468, &dwArg04->dw000C + 1, 0x00, 0x00, 0x00, out ecx_60, out edx_61);
}

// 080937F0: void do_dlclose(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void do_dlclose(struct Eq_9 * gs, Eq_2 dwArg04)
{
	_dl_close(gs, dwArg04);
}

// 08093800: Register (ptr32 Eq_127841) __libc_dlsym_private(Register (ptr32 Eq_9) gs)
// Called from:
//      __libc_register_dl_open_hook
//      __libc_register_dlfcn_hook
struct Eq_127841 * __libc_dlsym_private(struct Eq_9 * gs)
{
	ui32 ecx_9 = gs->dw0014;
	word32 ecx_112;
	word32 eax_20 = dlerror_run(gs, out ecx_112);
	struct Eq_127841 * edx_24 = null;
	if (eax_20 == 0x00)
	{
		edx_24 = dwLoc14;
		if (dwLoc14 != null)
		{
			if (dwLoc14->w000E != ~0x0E)
			{
				if (dwLoc18 != null)
					eax_20 = *dwLoc18;
			}
			else
				eax_20 = 0x00;
			edx_24 = eax_20 + dwLoc14->dw0004;
		}
	}
	if ((ecx_9 ^ gs->dw0014) == 0x00)
		return edx_24;
	word32 ecx_113;
	word32 edx_114;
	__stack_chk_fail(out ecx_113, out edx_114);
	return __libc_register_dl_open_hook();
}

// 08093890: Register (ptr32 ptr32) __libc_register_dl_open_hook()
// Called from:
//      __libc_dlsym_private
//      __libc_dlopen_mode
//      __dlmopen
//      __dlopen
ptr32 * __libc_register_dl_open_hook()
{
	ptr32 * eax_20 = __libc_dlsym_private(gs);
	if (eax_20 != null)
		*eax_20 = 0x080CEEFC;
	ptr32 * eax_40 = __libc_dlsym_private(gs);
	if (eax_40 != null)
		*eax_40 = 0x080CEEFC;
	return eax_40;
}

// 080938F0: Register Eq_2 __libc_dlopen_mode(Register (ptr32 Eq_9) gs, Register out Eq_67331 ecxOut)
// Called from:
//      __gconv_find_shlib
Eq_2 __libc_dlopen_mode(struct Eq_9 * gs, union Eq_67331 & ecxOut)
{
	ui32 ecx_9 = gs->dw0014;
	Eq_2 edx_26 = 0x00;
	word32 ecx_105;
	if (dlerror_run(gs, out ecx_105) == 0x00)
	{
		__libc_register_dl_open_hook();
		__libc_register_dlfcn_hook();
		edx_26 = dwLoc14;
	}
	Eq_67331 ecx_55 = ecx_9 ^ gs->dw0014;
	if (ecx_55 != 0x00)
	{
		word32 ecx_106;
		word32 edx_107;
		__stack_chk_fail(out ecx_106, out edx_107);
		Eq_67331 ecx_67;
		Eq_2 eax_66 = fatal_error(eax, ecx, edx, gs, out ecx_67);
		ecxOut = ecx_67;
		return eax_66;
	}
	else
	{
		ecxOut = ecx_55;
		return edx_26;
	}
}

// 08093970: Register Eq_2 fatal_error(Register Eq_2 eax, Register word32 ecx, Register (ptr32 byte) edx, Register (ptr32 Eq_9) gs, Register out ptr32 ecxOut)
// Called from:
//      __libc_dlopen_mode
//      _dl_signal_exception
//      _dl_signal_error
Eq_2 fatal_error(Eq_2 eax, word32 ecx, byte * edx, struct Eq_9 * gs, ptr32 & ecxOut)
{
	if (eax != 0x00)
	{
		word32 ebx_171;
		word32 ebp_172;
		word32 esi_173;
		strerror_r(gs, eax, fp - 0x0420, 0x0400, out ebx_171, out ebp_172, out esi_173);
	}
	*edx == 0x00;
	**(union Eq_2 **) 135060900 != 0x00;
	_dl_dprintf();
	_exit(gs, 0x7F);
}

// 08093A30: Register Eq_2 _dl_signal_exception(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 ebxOut)
// Called from:
//      _dl_lookup_symbol_x
//      _dl_open
//      _dl_map_object_deps
//      _dl_check_map_versions
//      _dl_sym
Eq_2 _dl_signal_exception(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & ebxOut)
{
	Eq_2 ebx_14 = dwArg08;
	struct Eq_127987 * edx_17 = gs->ptrFFFFFFFC;
	if (edx_17 != null)
	{
		Eq_2 ecx_21 = edx_17->t0000;
		*ecx_21 = *dwArg08;
		*((word32) ecx_21 + 4) = *((word32) dwArg08 + 4);
		*((word32) ecx_21 + 8) = *((word32) dwArg08 + 8);
		edx_17->ptr0004->t0000 = dwArg04;
		word32 ebp_92;
		word32 edi_93;
		ebx_14 = __longjmp(gs, (char *) &edx_17->ptr0004 + 4, 0x01, out ebp_92, out edi_93);
	}
	word32 ecx_91;
	fatal_error(eax, dwArg28, *ebx_14, gs, out ecx_91);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg16 = <invalid>;
	word32 ecx_95;
	word32 edx_96;
	word32 ebx_97;
	word32 ebp_98;
	word32 edi_99;
	Eq_2 eax_67 = _dl_signal_error(gs, dwArg04, stackArg16, out ecx_95, out edx_96, out ebx_97, out ebp_98, out edi_99);
	ebxOut = ebx_14;
	return eax_67;
}

// 08093A90: Register Eq_2 _dl_signal_error(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg10, Register out ptr32 ecxOut, Register out ptr32 edxOut, Register out Eq_2 ebxOut, Register out (ptr32 Eq_106486) ebpOut, Register out (ptr32 Eq_106487) ediOut)
// Called from:
//      lose
//      add_name_to_object.isra.4
//      fillin_rpath
//      cache_rpath.part.6
//      _dl_init_paths
//      _dl_map_object
//      _dl_allocate_static_tls
//      _dl_protect_relro
//      _dl_reloc_bad_type
//      _dl_relocate_object
//      _dl_important_hwcaps
//      _dl_add_to_slotinfo
//      _dl_signal_exception
//      dlinfo_doit
//      dlmopen_doit
//      add_to_global
//      _dl_open
//      dl_open_worker
//      _dl_close_worker
//      _dl_close
//      _dl_cet_open_check
//      dlopen_doit
//      _dl_map_object_deps
//      _dl_sym
Eq_2 _dl_signal_error(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg10, ptr32 & ecxOut, ptr32 & edxOut, union Eq_2 & ebxOut, union Eq_106486 & ebpOut, struct Eq_106487 & ediOut)
{
	Eq_2 ebx_11 = 0x080CE000;
	Eq_2 eax_13 = dwArg10;
	struct Eq_127987 * esi_19 = gs->ptrFFFFFFFC;
	if (dwArg10 == 0x00)
		eax_13.u0 = 134955153;
	if (esi_19 != null)
	{
		_dl_exception_create(esi_19->t0000, dwArg08, eax_13);
		esi_19->ptr0004->t0000 = dwArg04;
		ebx_11 = __longjmp(gs, (char *) &esi_19->ptr0004 + 4, 0x01, out ebp, out edi);
	}
	word32 ecx_130;
	fatal_error(dwArg20, dwArg28, edx, gs, out ecx_130);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg12 = <invalid>;
	ptr32 edx_88;
	ptr32 ecx_89;
	word32 ebx_132;
	Eq_2 eax_87 = _dl_catch_exception(gs, dwArg04, dwArg08, stackArg12, out ecx_89, out edx_88, out ebx_132);
	ecxOut = ecx_89;
	edxOut = edx_88;
	ebxOut = ebx_11;
	ebpOut = ebp;
	ediOut = edi;
	return eax_87;
}

// 08093B00: Register Eq_2 _dl_catch_exception(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out (ptr32 Eq_128109) ecxOut, Register out (ptr32 Eq_127987) edxOut, Register out Eq_128111 ebxOut)
// Called from:
//      _dl_signal_error
//      _dl_catch_error
//      _dl_open
//      _dl_map_object_deps
//      _dl_sym
Eq_2 _dl_catch_exception(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, struct Eq_128109 & ecxOut, struct Eq_127987 & edxOut, union Eq_128111 & ebxOut)
{
	Eq_2 ebx_48;
	ui32 ebx_17 = gs->dw0014;
	struct Eq_127987 * edx_25 = gs->ptrFFFFFFFC;
	gs->ptrFFFFFFFC = fp - 0xB4;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg0 = <invalid>;
	struct Eq_128109 * ecx_124;
	struct Eq_127987 * edx_126;
	Eq_2 eax_38 = __sigsetjmp(0x00, ebp, esi, edi, gs, stackArg0, fp - 0xAC, null, out ecx_124, out edx_126);
	if (eax_38 == 0x00)
	{
		dwArg08();
		gs->ptrFFFFFFFC = edx_25;
		*dwArg04 = 0x00;
		*((word32) dwArg04 + 4) = 0x00;
		*((word32) dwArg04 + 8) = 0x00;
		ebx_48 = eax_38;
		ecx_124 = (struct Eq_128109 *) &g_t80CE000;
		edx_126 = edx_25;
	}
	else
	{
		gs->ptrFFFFFFFC = edx_25;
		ebx_48 = dwLocB8;
	}
	Eq_128111 ebx_76 = ebx_17 ^ gs->dw0014;
	if (ebx_76 != 0x00)
	{
		word32 ecx_145;
		word32 edx_146;
		__stack_chk_fail(out ecx_145, out edx_146);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		struct Eq_128109 * ecx_88;
		struct Eq_127987 * edx_89;
		word32 esi_150;
		Eq_2 eax_90 = _dl_catch_error(gs, stackArg4, stackArg8, stackArg12, out ecx_88, out edx_89, out esi_150);
		ecxOut = ecx_88;
		edxOut = edx_89;
		ebxOut = ebx_76;
		return eax_90;
	}
	else
	{
		ecxOut = ecx_124;
		edxOut = edx_126;
		ebxOut = ebx;
		return ebx_48;
	}
}

// 08093C00: Register Eq_2 _dl_catch_error(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out Eq_127511 ecxOut, Register out (ptr32 Eq_127512) edxOut, Register out Eq_2 esiOut)
// Called from:
//      dlerror_run
//      _dl_catch_exception
//      _dlerror_run
Eq_2 _dl_catch_error(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, union Eq_127511 & ecxOut, struct Eq_127512 & edxOut, union Eq_2 & esiOut)
{
	ui32 eax_15 = gs->dw0014;
	word32 ecx_103;
	word32 edx_104;
	word32 ebx_105;
	Eq_2 eax_32 = _dl_catch_exception(gs, fp - 0x1C, dwArg10, dwArg14, out ecx_103, out edx_104, out ebx_105);
	*dwArg04 = dwLoc1C;
	*dwArg08 = dwLoc18;
	*dwArg0C = (int8) (dwLoc14 == dwLoc18);
	Eq_127511 ecx_45 = eax_15 ^ gs->dw0014;
	if (ecx_45 != 0x00)
	{
		word32 ecx_106;
		word32 edx_107;
		__stack_chk_fail(out ecx_106, out edx_107);
		struct Eq_127512 * edx_54;
		Eq_127511 ecx_55;
		Eq_2 eax_53 = __sigsetjmp(dwArg0C, ebp, dwArg08, dwArg04, gs, dwLoc1C, dwLoc18, dwLoc14, out ecx_55, out edx_54);
		ecxOut = ecx_55;
		edxOut = edx_54;
		esiOut = dwArg08;
		return eax_53;
	}
	else
	{
		ecxOut = ecx_45;
		edxOut = dwLoc18;
		esiOut = esi;
		return eax_32;
	}
}

// 08093C70: Register word32 __sigsetjmp(Register Eq_2 ebx, Register word32 ebp, Register Eq_2 esi, Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack (ptr32 Eq_127512) dwArg04, Stack (ptr32 Eq_127512) dwArg08, Register out ptr32 ecxOut, Register out Eq_979 edxOut)
// Called from:
//      _dl_catch_exception
//      _dl_catch_error
word32 __sigsetjmp(Eq_2 ebx, word32 ebp, Eq_2 esi, Eq_2 edi, struct Eq_9 * gs, Eq_2 dwArg00, struct Eq_127512 * dwArg04, struct Eq_127512 * dwArg08, ptr32 & ecxOut, union Eq_979 & edxOut)
{
	dwArg04->t0000 = ebx;
	dwArg04->t0004 = esi;
	dwArg04->t0008 = edi;
	dwArg04->t0010 = __rol(fp + 0x04 ^ gs->t0018, 0x09);
	dwArg04->t0014 = __rol(dwArg00 ^ gs->t0018, 0x09);
	dwArg04->dw000C = ebp;
	dwArg04->dw0028 = 0x00;
	word32 eax_29 = __sigjmp_save(dwArg04, dwArg08);
	ecxOut = 0x00;
	edxOut.u0 = <invalid>;
	return eax_29;
}

// 08093CC0: Register word32 __sigjmp_save(Stack (ptr32 Eq_127512) dwArg04, Stack (ptr32 Eq_127512) dwArg08)
// Called from:
//      __sigsetjmp
word32 __sigjmp_save(struct Eq_127512 * dwArg04, struct Eq_127512 * dwArg08)
{
	if (dwArg08 != null)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		word32 edx_65;
		sigprocmask(gs, stackArg4, stackArg8, stackArg12, out edx_65);
		dwArg04->ptr0018 = (word32) (int8) (dwArg04 == (struct Eq_127512 *) 0x1C);
		return;
	}
	else
	{
		dwArg04->ptr0018 = dwArg08;
		return;
	}
}

// 08093D10: Register word32 __longjmp(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_128033) dwArg04, Stack word32 dwArg08, Register out ptr32 ebpOut, Register out ptr32 ediOut)
// Called from:
//      _dl_signal_exception
//      _dl_signal_error
word32 __longjmp(struct Eq_9 * gs, struct Eq_128033 * dwArg04, word32 dwArg08, ptr32 & ebpOut, ptr32 & ediOut)
{
	word32 edx_7 = 0x00 - dwArg04->dw0028;
	if (edx_7 != 0x00)
	{
		uint32 edx_12 = (-edx_7 >> 0x02) + 0x01;
		uint32 ebx_14 = 0xFF;
		do
		{
			if (edx_12 < ebx_14)
				ebx_14 = edx_12;
			__lfence();
			edx_12 -= ebx_14;
		} while (edx_12 > 0x00);
	}
	word32 ecx_32 = dwArg04->dw0010;
	<anonymous> * edx_39 = __ror(dwArg04->t0014, 0x09) ^ gs->t0018;
	edx_39();
	word32 ebx_45 = dwArg04->dw0000;
	ptr32 edi_47 = dwArg04->ptr0008;
	ebpOut = dwArg04->ptr000C;
	ediOut = edi_47;
	return ebx_45;
}

// 08093D70: Register ui32 __mpn_cmp(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __printf_fp_l
//      __mpn_divrem
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n
ui32 __mpn_cmp(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	ui32 eax_13 = dwArg0C - 0x01;
	if (dwArg0C >= 0x01)
	{
		do
		{
			up32 edx_19 = *((word32) dwArg04 + eax_13 * 0x04);
			up32 ecx_21 = *((word32) dwArg08 + eax_13 * 0x04);
			if (edx_19 != ecx_21)
				return (0x00 - (ecx_21 < edx_19) & 0x02) - 0x01;
			--eax_13;
		} while (eax_13 != ~0x00);
	}
	return 0x00;
}

// 08093DC0: Register word32 __mpn_divrem(Stack (arr Eq_79752) dwArg04, Stack int32 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Stack Eq_2 dwArg18)
// Called from:
//      hack_digit
word32 __mpn_divrem(Eq_79752 dwArg04[], int32 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, Eq_2 dwArg18)
{
	word32 dwLoc24_587;
	struct Eq_128396 * esp_16 = fp - 0x3C;
	if (dwArg18 == 0x01)
	{
		dwLoc24_587 = 0x00;
		Eq_128403 ebx_22 = *dwArg14;
		Eq_128403 edx_24 = (dwArg0C - 0x04)[dwArg10];
		if (ebx_22 <= edx_24)
		{
			dwLoc24_587 = 0x01;
			edx_24 -= ebx_22;
		}
		uint32 edi_36[] = dwArg04 + dwArg08;
		if (dwArg10 >= 0x02)
		{
			int32 ecx_40 = dwArg10 - 0x02 << 0x02;
			do
			{
				uint64 edx_eax_49 = SEQ(edx_24, *((word32) dwArg0C + ecx_40));
				edi_36[ecx_40 / 4] = (uint32) (edx_eax_49 /u ebx_22);
				edx_24.u0 = (uint32) (edx_eax_49 % ebx_22);
				ecx_40 -= 0x04;
			} while (ecx_40 != ~0x03);
		}
		if (dwArg08 > 0x00)
		{
			struct Eq_128656 * ecx_66 = edi_36 - 0x04;
			ptr32 edi_69 = edi_36 - dwArg08 * 0x04;
			do
			{
				uint64 edx_eax_81 = SEQ(edx_24, 0x00);
				ecx_66 -= 0x04;
				ecx_66[1] = (struct Eq_128656) (uint32) (edx_eax_81 /u ebx_22);
				edx_24.u0 = (uint32) (edx_eax_81 % ebx_22);
			} while (edi_69 - 0x04 != ecx_66);
		}
		*dwArg0C = edx_24;
		return dwLoc24_587;
	}
	if (dwArg18 != 0x02)
	{
		if (dwArg18 == 0x00)
			;
		Eq_2 edi_287 = (word32) dwArg0C + (dwArg10 - dwArg18) * 0x04;
		dwLoc24_587 = 0x00;
		uint32 ebp_292 = *((word32) dwArg14 + ((word32) dwArg18 + 0x3FFFFFFF) * 0x04);
		uint32 ecx_298 = (dwArg14 - 0x04)[(word32) dwArg18 + 0x3FFFFFFF];
		uint32 ebx_299 = *((word32) edi_287 + ((word32) dwArg18 + 0x3FFFFFFF) * 0x04);
		if (ebp_292 <= ebx_299)
		{
			if (ebp_292 >= ebx_299)
			{
				esp_16 = fp - 0x3C;
				if (__mpn_cmp(edi_287, dwArg14, dwArg18 - 0x01) < 0x00)
					goto l08093E39;
			}
			uint32 * esi_346;
			__mpn_sub_n(edi_287, edi_287, dwArg14, dwArg18, out esi_346, out edi_287);
			esp_16 = fp - 0x38;
			ebx_299 = *esi_346;
			ecx_298 = dwLoc38;
			goto l08093E39;
		}
		else
		{
l08093E39:
			word32 eax_361 = Mem358[esp_16 + 0x4C:word32] + Mem358[esp_16 + 0x44:word32] - Mem358[esp_16 + 0x54:word32];
			esp_16[1] = (struct Eq_128396) (eax_361 - 0x01);
			if (eax_361 >= 0x01)
			{
				esp_16[7] = (struct Eq_128396) esp_16[5].dw0004;
				Eq_2 ecx_373 = edi_287;
				uint32 edi_374 = ecx_298;
				do
				{
					if (esp_16[0x0011] <= esp_16[1])
					{
						int32 esi_401 = esp_16[5];
						Eq_2 eax_402 = ecx_373 - 0x04;
						word32 ecx_403 = *((word32) ecx_373 + esi_401);
						esp_16[3] = (struct Eq_128396) ((word32) eax_402 + esi_401);
						esp_16[4] = (struct Eq_128396) ecx_403;
						ecx_373 = eax_402;
					}
					else
					{
						int32 edx_381 = esp_16[21];
						word32 eax_383 = Mem376[esp_16 + 0x14:word32] + ecx_373;
						esp_16[3] = (struct Eq_128396) eax_383;
						esp_16[4] = (struct Eq_128396) *eax_383;
						word32 eax_388 = Mem386[esp_16 + 0x1C:word32] + ecx_373;
						if (edx_381 > 0x00)
						{
							do
							{
								eax_388 -= 0x04;
								*((word32) eax_388 + 4) = *((word32) eax_388 - 4);
							} while (ecx_373 != eax_388);
						}
						*ecx_373 = 0x00;
					}
					Eq_2 esi_409 = ~0x00;
					if (ebp_292 != ebx_299)
					{
						uint64 edx_eax_427 = SEQ(ebx_299, *esp_16[3].dw0000);
						uint32 eax_430 = (uint32) (edx_eax_427 /u ebp_292);
						esp_16->dw0000 = eax_430;
						uint64 edx_eax_439 = eax_430 *64 edi_374;
						uint32 ebx_432 = (uint32) (edx_eax_427 % ebp_292);
						uint32 edx_440 = SLICE(edx_eax_439, word32, 32);
						uint32 eax_441 = (word32) edx_eax_439;
						while (edx_440 > ebx_432 || edx_440 == ebx_432 && Mem449[ecx_373 + Mem449[esp_16 + 0x08:word32]:word32] <u eax_441)
						{
							--esp_16->dw0000;
							ebx_432 += ebp_292;
							if (ebx_432 < 0x00)
								break;
							edx_440 -= eax_441 < edi_374;
							eax_441 -= edi_374;
						}
						esi_409 = esp_16->dw0000;
					}
					struct Eq_128556 * esp_478 = esp_16 - 4;
					esp_478->t0000 = esi_409;
					esp_478->tFFFFFFFC = esp_478->t0058;
					esp_478->tFFFFFFF8 = esp_478->t0054;
					esp_478->tFFFFFFF4 = ecx_373;
					esp_478->t0004 = ecx_373;
					word32 eax_494 = __mpn_submul_1(esp_478->tFFFFFFF4, esp_478->tFFFFFFF8, esp_478->tFFFFFFFC, esp_478->t0000);
					esp_16 = (struct Eq_128396 *) &esp_478->t0004;
					ecx_373 = esp_478->t0004;
					if (esp_478->dw0014 != eax_494)
					{
						esp_478->t0000 = esp_478->t0058;
						esp_478->tFFFFFFFC = esp_478->t0054;
						esp_478->tFFFFFFF8 = ecx_373;
						esp_478->tFFFFFFF4 = ecx_373;
						esp_478->t0004 = ecx_373;
						word32 ebx_861;
						__mpn_add_n(esp_478->tFFFFFFF4, esp_478->tFFFFFFF8, esp_478->tFFFFFFFC, esp_478->t0000, out ebx_861, out esi_409, out edi_374);
						Eq_2 esp_521 = <invalid>;
						esp_16 = (word32) esp_521 + 16;
						ecx_373 = *((word32) esp_521 + 16);
					}
					int32 eax_534 = esp_16[1];
					*((word32) esp_16[16].dw0000 + eax_534 * 0x04) = (struct Eq_128396) esi_409;
					uint32 * esi_538 = esp_16[3];
					esp_16[1] = (struct Eq_128396) (eax_534 - 0x01);
					ebx_299 = *esi_538;
				} while (eax_534 != 0x00);
			}
			return dwLoc24_587;
		}
	}
	struct Eq_128416 * eax_101 = dwArg0C - 0x08 + dwArg10 * 0x04;
	uint32 ecx_104 = eax_101[1];
	Eq_128403 ebx_105 = eax_101->dw0000;
	word32 dwLoc24_597 = 0x00;
	uint32 edi_102 = *((word32) dwArg14 + 4);
	struct Eq_128416 * dwLoc34_598 = eax_101;
	Eq_128403 ebp_107 = *dwArg14;
	uint64 ecx_ebx_577 = SEQ(ecx_104, ebx_105);
	if (edi_102 <= ecx_104)
	{
		if (edi_102 >= ecx_104)
		{
			ecx_ebx_577 = SEQ(ecx_104, ebx_105);
			if (ebp_107 > ebx_105)
				goto l08094046;
		}
		ecx_ebx_577 = SEQ(ecx_104, ebx_105) - SEQ(edi_102, ebp_107);
		dwLoc24_597 = 0x01;
		goto l08094046;
	}
	else
	{
l08094046:
		int32 eax_128 = (word32) dwArg10 + (dwArg08 - 0x03);
		uint32 ebx_185 = (word32) ecx_ebx_577;
		uint32 ecx_188 = SLICE(ecx_ebx_577, word32, 32);
		int32 dwLoc3C_604 = eax_128;
		if (eax_128 >= 0x00)
		{
			uint64 ecx_ebx_579 = ecx_ebx_577;
			do
			{
				uint64 edx_ebp_857;
				uint32 dwLoc38_609;
				uint32 ecx_158;
				uint32 ebx_168;
				uint32 eax_176;
				word32 ebx_154 = (word32) ecx_ebx_579;
				uint32 ecx_146 = SLICE(ecx_ebx_579, word32, 32);
				if (dwArg08 > dwLoc3C_604)
				{
					dwLoc34_598->dw0000 = 0x00;
					dwLoc38_609 = 0x00;
					if (edi_102 != ecx_146)
						goto l080940C8;
					goto l0809407A;
				}
				dwLoc34_598 -= 0x04;
				dwLoc38_609 = dwLoc34_598->dwFFFFFFFC;
				if (edi_102 != ecx_146)
				{
l080940C8:
					uint32 eax_199 = (uint32) (ecx_ebx_579 /u edi_102);
					ebx_168 = eax_199;
					ecx_158 = (uint32) (ecx_ebx_579 % edi_102);
					eax_176 = dwLoc38_609;
					edx_ebp_857 = eax_199 *64 ebp_107;
					goto l080940E0;
				}
l0809407A:
				uint32 ebx_156 = ebx_154 + edi_102;
				ecx_158 = ebx_156;
				if (ebx_156 >= 0x00)
				{
					ebx_168 = ~0x00;
					eax_176 = dwLoc38_609;
					edx_ebp_857 = SEQ(ebp_107 - (uint32) ((int8) (ebp_107 != 0x00)), -ebp_107);
l080940E0:
					do
					{
						uint64 edx_ebp_850;
						uint32 ebp_218 = (word32) edx_ebp_857;
						uint32 edx_213 = SLICE(edx_ebp_857, word32, 32);
						if (edx_213 <= ecx_158)
						{
							edx_ebp_850 = edx_ebp_857;
							if (edx_213 != ecx_158)
								break;
							edx_ebp_850 = edx_ebp_857;
							if (ebp_218 <= eax_176)
								break;
						}
						up32 ebp_228 = ebp_218 - ebp_107;
						word32 edx_232 = edx_213 - (ebp_228 < 0x00);
						--ebx_168;
						ecx_158 += edi_102;
						edx_ebp_850 = SEQ(edx_232, ebp_228);
						edx_ebp_857 = SEQ(edx_232, ebp_228);
					} while (ecx_158 >= 0x00);
					dwArg04[dwLoc3C_604].u0 = ebx_168;
					int32 v29_246 = dwLoc3C_604 - 0x01;
					ecx_ebx_579 = SEQ(ecx_158, dwLoc38_609) - edx_ebp_850;
					dwLoc3C_604 = v29_246;
					ebx_185 = (word32) ecx_ebx_579;
					ecx_188 = SLICE(ecx_ebx_579, word32, 32);
					if (v29_246 == ~0x00)
						break;
					continue;
				}
				dwArg04[dwLoc3C_604].u0 = ~0x00;
				ebx_185 = (word32) ebp_107.u0 + dwLoc38_609;
				int32 v30_180 = dwLoc3C_604 - 0x01;
				ecx_188 = (uint32) ((bool) (ebx_185 < 0x00) + (ebx_156 - ebp_107));
				dwLoc3C_604 = v30_180;
				ecx_ebx_579 = SEQ(ecx_188, ebx_185);
			} while (v30_180 != ~0x00);
		}
		dwLoc34_598[1] = (struct Eq_128416) ecx_188;
		dwLoc34_598->dw0000 = ebx_185;
		return dwLoc24_597;
	}
}

// 080941C0: void __mpn_lshift(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 bArg10)
// Called from:
//      __printf_fp_l
void __mpn_lshift(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 bArg10)
{
	byte cl_21 = (byte) dwArg10;
	ui32 esi_17[] = dwArg08 - 0x04;
	ui32 ebx_18 = (dwArg08 - 0x04)[dwArg0C];
	ui32 edx_23 = dwArg0C - 0x01;
	byte dl_37 = (byte) (dwArg0C - 0x01);
	if (dwArg0C == 0x01)
	{
		*dwArg04 = ebx_18 << cl_21;
		return;
	}
	ui32 eax_41;
	if ((dl_37 & 0x01) == 0x00)
	{
		eax_41 = ebx_18;
		esi_17 = dwArg08 - 0x04;
l080941F0:
		ebx_18 = esi_17[edx_23];
		*((word32) dwArg04 + edx_23 * 0x04) = __shld(eax_41, ebx_18, cl_21);
		--edx_23;
	}
	eax_41 = esi_17[edx_23];
	*((word32) dwArg04 + edx_23 * 0x04) = __shld(ebx_18, eax_41, cl_21);
	--edx_23;
	if (edx_23 == 0x00)
	{
		*dwArg04 = eax_41 << cl_21;
		return;
	}
	goto l080941F0;
}

// 08094220: void __mpn_rshift(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 bArg10)
// Called from:
//      __printf_fp_l
void __mpn_rshift(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 bArg10)
{
	uint32 esi_18[] = (word32) dwArg08 + dwArg0C * 0x04;
	ui32 edx_19 = -dwArg0C;
	byte cl_23 = (byte) dwArg10;
	Eq_129012 edi_17[] = dwArg04 - 0x04 + dwArg0C * 0x04;
	uint32 ebx_20 = esi_18[edx_19];
	ui32 edx_25 = edx_19 + 0x01;
	byte dl_39 = (byte) (edx_19 + 0x01);
	if (edx_19 == 0x01)
	{
		edi_17[0] = ebx_20 >> cl_23;
		return;
	}
	uint32 eax_43;
	if ((dl_39 & 0x01) == 0x00)
	{
		eax_43 = ebx_20;
l08094258:
		ebx_20 = esi_18[edx_25];
		edi_17[edx_25].u0 = __shrd(eax_43, ebx_20, cl_23);
		++edx_25;
	}
	eax_43 = esi_18[edx_25];
	edi_17[edx_25].u0 = __shrd(ebx_20, eax_43, cl_23);
	++edx_25;
	if (edx_25 == 0x00)
	{
		edi_17[0] = eax_43 >> cl_23;
		return;
	}
	goto l08094258;
}

// 08094280: Register Eq_2 __mpn_mul(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out (ptr32 Eq_83297) ebpOut, Register out (ptr32 Eq_83298) esiOut, Register out Eq_2 ediOut)
// Called from:
//      __printf_fp_l
//      __mpn_mul
Eq_2 __mpn_mul(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, struct Eq_83297 & ebpOut, struct Eq_83298 & esiOut, union Eq_2 & ediOut)
{
	struct Eq_129048 * esp_17 = fp - 0x5C;
	Eq_2 edi_103 = dwArg04;
	Eq_2 esi_170 = dwArg14;
	ui32 eax_26 = gs->dw0014;
	Eq_2 eax_28 = 0x00;
	if (dwArg14 > 0x1F)
	{
		ui32 eax_31 = dwArg14 * 0x08 + 0x1B;
		struct Eq_129048 * ebx_37 = fp - 0x5C - (eax_31 & ~0x0FFF);
		if (fp - 0x5C != ebx_37)
		{
			do
			{
				esp_17 -= 0x1000;
				esp_17->dw0FFC = esp_17->dw0FFC;
			} while (esp_17 != ebx_37);
		}
		int32 edx_52 = eax_31 & ~0x0F & 0x0FFF;
		if (edx_52 != 0x00)
		{
			esp_17 -= edx_52;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[edx_52 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_17 - 0x04)[edx_52 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		Eq_129121 ecx_70 = (char *) esp_17 + 0x0F;
		struct Eq_129124 * esp_71 = esp_17 - 0x0C;
		esp_71->dwFFFFFFFC = ecx_70 & ~0x0F;
		esp_71->tFFFFFFF8 = dwArg14;
		esp_71->tFFFFFFF4 = dwArg10;
		esp_71->tFFFFFFF0 = dwArg08;
		esp_71->tFFFFFFEC = dwArg04;
		__mpn_impn_mul_n(esp_71->tFFFFFFEC, esp_71->tFFFFFFF0, esp_71->tFFFFFFF4, esp_71->tFFFFFFF8, esp_71->t0000, esp_71->t0004);
		edi_103 = (word32) dwArg08 + dwArg14 * 0x04;
		Eq_2 eax_108 = dwArg0C - dwArg14;
		struct Eq_129176 * esp_102 = (char *) &esp_71->t0004 + 8;
		Eq_2 ebx_105 = (word32) dwArg04 + dwArg14 * 0x04;
		Eq_2 dwLoc38_674 = edi_103;
		Eq_2 dwLoc30_675 = eax_108;
		if (dwArg14 <= eax_108)
		{
			struct Eq_129176 * ecx_116 = (char *) &esp_71->t0004 + 8 - (eax_31 & ~0x0FFF);
			if ((char *) &esp_71->t0004 + 8 != ecx_116)
			{
				do
				{
					esp_102 -= 0x1000;
					esp_102->dw0FFC = esp_102->dw0FFC;
				} while (esp_102 != ecx_116);
			}
			int32 edx_132 = eax_31 & ~0x0F & 0x0FFF;
			if (edx_132 != 0x00)
			{
				esp_102 -= edx_132;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_102 - 0x04)[edx_132 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_102 - 0x04)[edx_132 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_129210 eax_144 = (char *) esp_102 + 0x0F;
			word32 * eax_150 = (eax_144 & ~0x0F) + dwArg14 * 0x04;
			do
			{
				int32 edi_225;
				struct Eq_129231 * ecx_226;
				struct Eq_129269 * esp_164 = esp_102 - 0x0C;
				esp_164->tFFFFFFFC = ecx_70 & ~0x0F;
				esp_164->tFFFFFFF8 = esi_170;
				esp_164->tFFFFFFF4 = dwArg10;
				esp_164->tFFFFFFF0 = dwLoc38_674;
				esp_164->tFFFFFFEC = eax_144 & ~0x0F;
				__mpn_impn_mul_n(esp_164->tFFFFFFEC, esp_164->tFFFFFFF0, esp_164->tFFFFFFF4, esp_164->tFFFFFFF8, esp_164->t0000, esp_164->t0004);
				esp_164->t0008 = esi_170;
				esp_164->t0004 = eax_144 & ~0x0F;
				esp_164->t0000 = ebx_105;
				esp_164->tFFFFFFFC = ebx_105;
				ebx_105 = ebx_202 + dwArg14 * 0x04;
				word32 ebx_202;
				Eq_2 esi_204;
				word32 edi_1061;
				up32 eax_214 = (word32) __mpn_add_n(esp_164->tFFFFFFFC, esp_164->t0000, esp_164->t0004, esp_164->t0008, out ebx_202, out esi_204, out edi_1061) + *eax_150;
				*ebx_105 = eax_214;
				Eq_2 esp_201 = <invalid>;
				esp_102 = (word32) esp_201 + 16;
				struct Eq_129231 * edx_213 = (word32) ebx_105 + 4;
				if ((uint32) (int8) (eax_214 < 0x00) != 0x00)
				{
					ecx_226 = (struct Eq_129231 *) (eax_150 + 1);
					word32 edi_230 = esi_204 - 0x01;
					do
					{
						++ecx_226;
						word32 eax_235 = ecx_226->dwFFFFFFFC;
						++edx_213;
						edx_213->dwFFFFFFFC = eax_235 + 0x01;
						if (eax_235 != 0x01)
						{
							if (ecx_226 == edx_213)
								break;
							edi_225 = edi_230 - 0x01;
							if (edi_225 <= 0x00)
								break;
							goto l08094608;
						}
						--edi_230;
					} while (edi_230 != 0x00);
				}
				else
				{
					edi_225 = dwArg14 - 0x01;
					ecx_226 = (struct Eq_129231 *) (eax_150 + 1);
					if (eax_150 + 1 != (word32) ebx_105 + 4)
					{
l08094608:
						int32 eax_254 = 0x00;
						esi_170 = esi_204;
						do
						{
							edx_213[eax_254] = ecx_226[eax_254];
							++eax_254;
						} while (eax_254 < edi_225);
						Eq_2 v30_272 = dwLoc30_675 - esi_204;
						dwLoc30_675 = v30_272;
						edi_103 = dwArg14 * 0x04;
						dwLoc38_674 = (word32) dwLoc38_674 + dwArg14 * 0x04;
						if (esi_204 > v30_272)
							break;
						continue;
					}
				}
				Eq_2 v24_287 = dwLoc30_675 - esi_204;
				esi_170 = esi_204;
				dwLoc30_675 = v24_287;
				edi_103 = dwArg14 * 0x04;
				dwLoc38_674 = (word32) dwLoc38_674 + dwArg14 * 0x04;
			} while (esi_204 <= v24_287);
		}
		if (dwLoc30_675 != 0x00)
		{
			struct Eq_129361 * esp_307 = esp_102 - 0x0C;
			esp_307->tFFFFFFFC = dwLoc30_675;
			esp_307->tFFFFFFF8 = dwLoc38_674;
			esp_307->tFFFFFFF4 = esi_170;
			esp_307->tFFFFFFF0 = dwArg10;
			esp_307->dwFFFFFFEC = ecx_70 & ~0x0F;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg4 = <invalid>;
			word32 esi_1064;
			word32 edi_1065;
			word32 ebp_1063;
			__mpn_mul(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, out ebp_1063, out esi_1064, out edi_1065);
			esp_307->t0008 = esi_170;
			esp_307->t0004 = ecx_70 & ~0x0F;
			esp_307->t0000 = ebx_105;
			esp_307->tFFFFFFFC = ebx_105;
			word32 * ecx_377 = edi_368 + dwArg14 * 0x04;
			word32 ebx_367;
			word32 edi_368;
			Eq_2 esi_369;
			up32 eax_379 = (word32) __mpn_add_n(esp_307->tFFFFFFFC, esp_307->t0000, esp_307->t0004, esp_307->t0008, out ebx_367, out esi_369, out edi_368) + *ecx_377;
			up32 * ebx_378 = ebx_367 + dwArg14 * 0x04;
			*ebx_378 = eax_379;
			Eq_2 ecx_385 = (word32) (int8) (eax_379 < 0x00);
			struct Eq_129441 * edx_381 = ecx_377 + 1;
			edi_103 = ecx_385;
			struct Eq_129441 * ecx_387 = ebx_378 + 1;
			if (ecx_385 != 0x00)
			{
				Eq_2 ebx_391 = dwLoc30_675;
				esi_170 = esi_369;
				do
				{
					--ebx_391;
					if (ebx_391 == 0x00)
						goto l0809445F;
					++edx_381;
					word32 eax_400 = edx_381->dwFFFFFFFC;
					++ecx_387;
					ecx_387->dwFFFFFFFC = eax_400 + 0x01;
				} while (eax_400 == 0x01);
				dwLoc30_675 = ebx_391;
			}
			esi_170 = esi_369;
			if (ecx_387 != edx_381 && dwLoc30_675 > 0x01)
			{
				struct Eq_129441 * eax_419 = edx_381 - 0x04 + dwLoc30_675 * 0x04;
				esi_170 = esi_369;
				do
				{
					++ecx_387;
					ecx_387->dwFFFFFFFC = edx_381->dw0000;
					++edx_381;
				} while (edx_381 != eax_419);
			}
		}
l0809445F:
		eax_28 = *((word32) dwArg04 + ((word32) esi_170 + ((word32) dwArg0C + 0x3FFFFFFF)) * 0x04);
l080942B6:
		struct Eq_83298 * esi_609 = eax_26 ^ gs->dw0014;
		if (esi_609 != null)
		{
			word32 edx_1060;
			word32 ecx_1059;
			__stack_chk_fail(out ecx_1059, out edx_1060);
			word32 ecx_1066;
			Eq_2 eax_619 = __mpn_mul_1(dwArg04, dwArg08, dwArg0C, dwArg10, out ecx_1066);
			ebpOut = fp - 4;
			esiOut = esi_609;
			ediOut = edi_103;
			return eax_619;
		}
		else
		{
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return eax_28;
		}
	}
	if (dwArg14 == 0x00)
		goto l080942B6;
	Eq_2 eax_445 = *dwArg10;
	if (eax_445 > 0x01)
	{
		word32 ecx_1067;
		eax_28 = __mpn_mul_1(dwArg04, dwArg08, dwArg0C, eax_445, out ecx_1067);
		goto l0809448A;
	}
	if (eax_445 != 0x01)
	{
		Eq_2 eax_492 = dwArg04;
		Eq_2 edx_493 = (word32) dwArg04 + dwArg0C * 0x04;
		if (dwArg0C > 0x00)
		{
			do
			{
				*eax_492 = 0x00;
				eax_492 = (word32) eax_492 + 4;
			} while (edx_493 != eax_492);
		}
	}
	else if (dwArg0C > 0x00)
	{
		Eq_2 edx_474 = dwArg04;
		Eq_2 eax_475 = dwArg08;
		Eq_2 ecx_476 = (word32) dwArg08 + dwArg0C * 0x04;
		do
		{
			edx_474 = (word32) edx_474 + 4;
			*((word32) edx_474 - 4) = *eax_475;
			eax_475 = (word32) eax_475 + 4;
		} while (eax_475 != ecx_476);
		eax_28.u0 = 0x00;
l0809448A:
		*((word32) dwArg04 + dwArg0C * 0x04) = eax_28;
		ptr32 esp_541 = fp - 0x5C;
		Eq_2 ebx_517 = (word32) dwArg04 + 4;
		if (dwArg14 > 0x01)
		{
			Eq_2 esi_526 = (word32) dwArg04 + dwArg14 * 0x04;
			word32 * esi_530 = (word32) dwArg10 + 4;
			edi_103 = dwArg0C << 0x02;
			do
			{
				uint32 eax_534 = *esi_530;
				if (eax_534 > 0x01)
				{
					struct Eq_129572 * esp_565 = esp_541 - 4;
					esp_565->dw0000 = eax_534;
					esp_565->tFFFFFFFC = dwArg0C;
					esp_565->tFFFFFFF8 = dwArg08;
					esp_565->tFFFFFFF4 = ebx_517;
					eax_28 = __mpn_addmul_1(esp_565->tFFFFFFF4, esp_565->tFFFFFFF8, esp_565->tFFFFFFFC, esp_565->dw0000);
					esp_541 = &esp_565->dw0000 + 1;
				}
				else
				{
					eax_28.u0 = 0x00;
					if (eax_534 == 0x01)
					{
						struct Eq_129633 * esp_542 = esp_541 - 4;
						esp_542->t0000 = dwArg0C;
						esp_542->tFFFFFFFC = dwArg08;
						esp_542->tFFFFFFF8 = ebx_517;
						esp_542->tFFFFFFF4 = ebx_517;
						Eq_2 esp_555 = <invalid>;
						eax_28 = __mpn_add_n(esp_542->tFFFFFFF4, esp_542->tFFFFFFF8, esp_542->tFFFFFFFC, esp_542->t0000, out ebx_517, out esi_530, out edi_103);
						esp_541 = (word32) esp_555 + 16;
					}
				}
				Mem588[ebx_517 + edi_103:word32] = eax_28;
				++esi_530;
				ebx_517 = (word32) ebx_517 + 4;
			} while (esi_526 != ebx_517);
		}
		goto l080942B6;
	}
	eax_28.u0 = 0x00;
	goto l0809448A;
}

// 08094660: Register word32 __mpn_mul_1(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_79707 ecxOut)
// Called from:
//      hack_digit
//      __printf_fp_l
//      __mpn_mul
//      __mpn_impn_mul_n_basecase
//      __mpn_impn_sqr_n_basecase
word32 __mpn_mul_1(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_79707 & ecxOut)
{
	up32 edi_20[] = (word32) dwArg04 + dwArg0C * 0x04;
	uint32 esi_21[] = (word32) dwArg08 + dwArg0C * 0x04;
	Eq_79707 ecx_22 = -dwArg0C;
	word32 ebp_23 = 0x00;
	do
	{
		uint64 edx_eax_32 = dwArg10 *64 esi_21[ecx_22];
		up32 eax_35 = (word32) edx_eax_32 + ebp_23;
		edi_20[ecx_22] = eax_35;
		word32 edx_41 = (bool) (eax_35 < 0x00) + SLICE(edx_eax_32, word32, 32);
		ebp_23 = edx_41;
		ecx_22 = (word32) ecx_22.u0 + 1;
	} while (ecx_22 != 0x00);
	ecxOut = ecx_22;
	return edx_41;
}

// 080946B0: void __mpn_impn_mul_n_basecase(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __mpn_impn_mul_n
//      __mpn_mul_n
void __mpn_impn_mul_n_basecase(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 eax_32;
	Eq_2 eax_19 = *dwArg0C;
	if (eax_19 <= 0x01)
	{
		if (eax_19 != 0x01)
		{
			Eq_2 eax_61 = dwArg04;
			Eq_2 edx_62 = (word32) dwArg04 + dwArg10 * 0x04;
			if (dwArg10 > 0x00)
			{
				do
				{
					*eax_61 = 0x00;
					eax_61 = (word32) eax_61 + 4;
				} while (eax_61 != edx_62);
			}
		}
		else if (dwArg10 > 0x00)
		{
			Eq_2 eax_45 = dwArg08;
			Eq_2 edx_47 = dwArg04;
			Eq_2 ecx_48 = (word32) dwArg08 + dwArg10 * 0x04;
			do
			{
				edx_47 = (word32) edx_47 + 4;
				*((word32) edx_47 - 4) = *eax_45;
				eax_45 = (word32) eax_45 + 4;
			} while (eax_45 != ecx_48);
		}
		eax_32.u0 = 0x00;
	}
	else
	{
		word32 ecx_248;
		eax_32 = __mpn_mul_1(dwArg04, dwArg08, dwArg10, eax_19, out ecx_248);
	}
	Eq_2 edi_126 = (word32) dwArg04 + dwArg10 * 0x04;
	*edi_126 = eax_32;
	struct Eq_129752 * esp_109 = fp - 0x1C;
	Eq_2 ebx_117 = (word32) dwArg04 + 4;
	if (dwArg10 > 0x01)
	{
		int32 esi_100 = dwArg10 * 0x04;
		word32 * ebp_101 = (word32) dwArg0C + 4;
		do
		{
			uint32 eax_104 = *ebp_101;
			if (eax_104 <= 0x01)
			{
				Eq_2 eax_107 = 0x00;
				if (eax_104 == 0x01)
				{
					struct Eq_129810 * esp_111 = esp_109 - 4;
					esp_111->t0000 = esp_109[11];
					esp_111->tFFFFFFFC = esp_111->t0028;
					esp_111->tFFFFFFF8 = ebx_117;
					esp_111->tFFFFFFF4 = ebx_117;
					Eq_2 esp_124 = <invalid>;
					eax_107 = __mpn_add_n(esp_111->tFFFFFFF4, esp_111->tFFFFFFF8, esp_111->tFFFFFFFC, esp_111->t0000, out ebx_117, out esi_100, out edi_126);
					esp_109 = (word32) esp_124 + 16;
				}
				*((word32) ebx_117 + esi_100) = eax_107;
				ebx_117 = (word32) ebx_117 + 4;
				++ebp_101;
				if (edi_126 != ebx_117)
					continue;
				return;
			}
			struct Eq_129764 * esp_146 = esp_109 - 4;
			esp_146->dw0000 = eax_104;
			esp_146->tFFFFFFFC = esp_146->t0030;
			esp_146->tFFFFFFF8 = esp_146->t0028;
			esp_146->tFFFFFFF4 = ebx_117;
			ebx_117 = (word32) ebx_117 + 4;
			(ebx_117 - 0x04)[esi_100 / 4] = __mpn_addmul_1(esp_146->tFFFFFFF4, esp_146->tFFFFFFF8, esp_146->tFFFFFFFC, esp_146->dw0000);
			++ebp_101;
			esp_109 = (struct Eq_129752 *) (&esp_146->dw0000 + 1);
		} while (edi_126 != ebx_117);
	}
}

// 080947E0: void __mpn_impn_mul_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      __mpn_mul
//      __mpn_impn_mul_n
//      __mpn_mul_n
void __mpn_impn_mul_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg18, Eq_2 dwArg1C)
{
	if ((dwArg10 & 0x01) != 0x00)
	{
		if (dwArg10 > 0x20)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg24 = <invalid>;
			Eq_2 stackArg28 = <invalid>;
			__mpn_impn_mul_n(dwArg04, dwArg08, dwArg0C, dwArg10 - 0x01, stackArg24, stackArg28);
		}
		else
			__mpn_impn_mul_n_basecase(dwArg04, dwArg08, dwArg0C, dwArg10 - 0x01);
		Eq_2 esi_650 = (word32) dwArg04 + (dwArg10 - 0x01) * 0x04;
		*((word32) dwArg04 + (dwArg10 - 0x01) * 0x08) = __mpn_addmul_1(esi_650, dwArg08, dwArg10 - 0x01, *((word32) dwArg0C + (dwArg10 - 0x01) * 0x04));
		*((word32) dwArg04 + ((word32) dwArg10 + (dwArg10 - 0x01)) * 0x04) = __mpn_addmul_1(esi_650, dwArg0C, dwArg10, *((word32) dwArg08 + (dwArg10 - 0x01) * 0x04));
		return;
	}
	Eq_2 ecx_25 = (dwArg10 >> 0x01) * 0x04;
	word32 eax_26 = dwArg0C + ecx_25;
	word32 ecx_28 = ecx_25 + dwArg08;
	Eq_2 edi_34 = (word32) dwArg04 + dwArg10 * 0x04;
	if (dwArg10 >> 0x01 > 0x1F)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg24 = <invalid>;
		Eq_2 stackArg28 = <invalid>;
		__mpn_impn_mul_n(edi_34, ecx_28, eax_26, dwArg10 >> 0x01, stackArg24, stackArg28);
	}
	else
		__mpn_impn_mul_n_basecase(edi_34, ecx_28, eax_26, dwArg10 >> 0x01);
	Eq_2 esi_112;
	if (__mpn_cmp(ecx_28, dwArg08, dwArg10 >> 0x01) >= 0x00)
	{
		word32 edi_966;
		__mpn_sub_n(dwArg04, ecx_28, dwArg08, dwArg10 >> 0x01, out esi_112, out edi_966);
	}
	else
	{
		word32 edi_965;
		__mpn_sub_n(dwArg04, dwArg08, ecx_28, dwArg10 >> 0x01, out esi_112, out edi_965);
	}
	Eq_2 edi_184;
	Eq_2 esi_185;
	Eq_2 ebp_165 = (word32) dwArg08 + dwLoc28;
	if (__mpn_cmp(ecx_25, dwArg10, esi_112) >= 0x00)
		__mpn_sub_n(ebp_165, ecx_25, dwArg10, esi_112, out esi_185, out edi_184);
	else
		__mpn_sub_n(ebp_165, dwArg10, ecx_25, esi_112, out esi_185, out edi_184);
	if (esi_185 <= 0x1F)
	{
		__mpn_impn_mul_n_basecase(dwArg1C, dwArg0C, ebp_165, esi_185);
		if (esi_185 <= 0x00)
			goto l08094966;
	}
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg24 = <invalid>;
		Eq_2 stackArg28 = <invalid>;
		__mpn_impn_mul_n(dwArg1C, dwArg0C, ebp_165, esi_185, stackArg24, stackArg28);
	}
	Eq_2 eax_272 = 0x00;
	do
	{
		*((word32) ebp_165 + eax_272 * 0x04) = *((word32) edi_184 + eax_272 * 0x04);
		eax_272 = (word32) eax_272 + 1;
	} while (esi_185 > eax_272);
l08094966:
	Eq_2 esi_343;
	struct Eq_129948 * esp_350;
	word32 ecx_352;
	Eq_2 esp_310 = <invalid>;
	word32 esi_970;
	word32 ebx_969;
	word32 edi_971;
	Mem318[esp_310 + 0x1C:word32] = __mpn_add_n(edi_184, edi_184, dwArg0C + (dwArg18 + esi_185) * 0x04, esi_185, out ebx_969, out esi_970, out edi_971);
	word32 ecx_321 = *((word32) esp_310 + 44);
	if (*((word32) esp_310 + 36) != 0x00)
	{
		*((word32) esp_310 + 36) = ecx_321;
		*((word32) esp_310 + 0x0C) = *((word32) esp_310 + 92);
		*((word32) esp_310 + 8) = *((word32) esp_310 + 96);
		*((word32) esp_310 + 4) = ebp_165;
		*esp_310 = ebp_165;
		word32 edi_974;
		*((word32) esp_310 + 32) -= __mpn_sub_n(*esp_310, *((word32) esp_310 + 4), *((word32) esp_310 + 8), *((word32) esp_310 + 0x0C), out esi_343, out edi_974);
		esp_350 = (word32) esp_310 + 20;
		ecx_352 = (word32) *((word32) esp_310 + 40);
	}
	else
	{
		*((word32) esp_310 + 36) = ecx_321;
		*((word32) esp_310 + 0x0C) = *((word32) esp_310 + 92);
		*((word32) esp_310 + 8) = *((word32) esp_310 + 96);
		*((word32) esp_310 + 4) = ebp_165;
		*esp_310 = ebp_165;
		Eq_2 esp_340 = <invalid>;
		word32 edi_973;
		word32 ebx_972;
		Mem349[esp_340 + 0x1C:word32] = __mpn_add_n(*esp_310, *((word32) esp_310 + 4), *((word32) esp_310 + 8), *((word32) esp_310 + 0x0C), out ebx_972, out esi_343, out edi_973) + Mem336[esp_340 + 0x1C:word32];
		esp_350 = (word32) esp_340 + 16;
		ecx_352 = (word32) *((word32) esp_340 + 36);
	}
	Eq_2 ebx_431;
	Eq_2 ecx_439;
	Eq_2 esi_433;
	struct Eq_130168 * esp_438;
	esp_350->dw0014 = ecx_352;
	if (esi_343 <= 0x1F)
	{
		struct Eq_130181 * esp_447 = esp_350 - 4;
		esp_447->t0000 = esi_343;
		esp_447->tFFFFFFFC = esp_447->t004C;
		esp_447->tFFFFFFF8 = esp_447->t0048;
		esp_447->tFFFFFFF4 = esp_447->t0054;
		__mpn_impn_mul_n_basecase(esp_447->tFFFFFFF4, esp_447->tFFFFFFF8, esp_447->tFFFFFFFC, esp_447->t0000);
		esp_447->tFFFFFFF0 = esp_447->t0050;
		esp_447->tFFFFFFEC = esp_447->t0054;
		esp_447->tFFFFFFE8 = ebp_165;
		esp_447->tFFFFFFE4 = ebp_165;
		Eq_2 esp_478 = <invalid>;
		esp_438 = (word32) esp_478 + 32;
		word32 edi_977;
		word32 eax_487 = __mpn_add_n(esp_447->tFFFFFFE4, esp_447->tFFFFFFE8, esp_447->tFFFFFFEC, esp_447->tFFFFFFF0, out ebx_431, out esi_433, out edi_977) + Mem474[esp_478 + 44:word32];
		if (eax_487 == 0x00)
			goto l080949F6;
		ecx_439 = *((word32) esp_478 + 52);
		up32 eax_491 = (word32) *ecx_439 + eax_487;
		*ecx_439 = eax_491;
		if (eax_491 >= 0x00)
		{
l080949F6:
			if (esi_433 <= 0x00)
				goto l08094A15;
			goto l080949FA;
		}
	}
	else
	{
		struct Eq_130089 * esp_387 = esp_350 - 0x0C;
		esp_387->tFFFFFFFC = (word32) esp_387->t005C + esp_387->dw0024;
		esp_387->tFFFFFFF8 = esi_343;
		esp_387->dwFFFFFFF4 = esp_387->dw0054;
		esp_387->dwFFFFFFF0 = esp_387->dw0050;
		esp_387->tFFFFFFEC = esp_387->t005C;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		__mpn_impn_mul_n(stackArg4, dwArg04, dwArg08, dwArg0C, dwArg14, dwArg18);
		esp_387->t0008 = esp_387->t0058;
		esp_387->t0004 = esp_387->t005C;
		esp_387->t0000 = ebp_165;
		esp_387->tFFFFFFFC = ebp_165;
		Eq_2 esp_430 = <invalid>;
		word32 edi_976;
		Eq_2 eax_427 = __mpn_add_n(esp_387->tFFFFFFFC, esp_387->t0000, esp_387->t0004, esp_387->t0008, out ebx_431, out esi_433, out edi_976);
		esp_438 = (word32) esp_430 + 16;
		ecx_439 = *((word32) esp_430 + 36);
		word32 eax_440 = eax_427 + Mem426[esp_430 + 0x1C:word32];
		if (eax_440 == 0x00)
			goto l080949FA;
		up32 eax_443 = (word32) *ecx_439 + eax_440;
		*ecx_439 = eax_443;
		if (eax_443 >= 0x00)
		{
l080949FA:
			word32 edx_527[] = esp_438->ptr0040;
			word32 ecx_528[] = esp_438->ptr0050;
			do
			{
				edx_527[ebx_431] = ecx_528[ebx_431];
				ebx_431 = (word32) ebx_431 + 1;
			} while (esi_433 > ebx_431);
l08094A15:
			struct Eq_130280 * esp_543 = esp_438 - 4;
			esp_543->t0000 = esi_433;
			esp_543->tFFFFFFFC = esp_543->dw0014 + esp_543->dw0054;
			esp_543->tFFFFFFF8 = ebp_165;
			esp_543->tFFFFFFF4 = ebp_165;
			Eq_2 esp_565 = <invalid>;
			struct Eq_130303 * edi_567;
			word32 esi_979;
			word32 ebx_978;
			if (__mpn_add_n(esp_543->tFFFFFFF4, esp_543->tFFFFFFF8, esp_543->tFFFFFFFC, esp_543->t0000, out ebx_978, out esi_979, out edi_567) != 0x00)
			{
				up32 eax_577 = edi_567->dw0000;
				edi_567->dw0000 = eax_577 + 0x01;
				if (eax_577 < 0x01)
				{
					Eq_2 eax_582 = *((word32) esp_565 + 92);
					ui32 eax_584 = 0x00;
					while (eax_584 != eax_582 - 0x01)
					{
						word32 edx_593 = edi_567->a0004[eax_584];
						edi_567->a0004[eax_584] = edx_593 + 0x01;
						++eax_584;
						if (edx_593 != 0x01)
							return;
					}
				}
			}
			return;
		}
	}
	esp_438->t000C = esi_433;
	int32 edx_496 = esi_433 - 0x01;
	int32 eax_499 = 0x00;
	while (edx_496 != eax_499)
	{
		word32 edx_509 = *((word32) ecx_439 + (eax_499 * 0x04 + 4));
		*((word32) ecx_439 + (eax_499 * 0x04 + 4)) = edx_509 + 0x01;
		++eax_499;
		if (edx_509 != 0x01)
			break;
	}
	esi_433 = esp_438->t000C;
	goto l080949F6;
}

// 08094BD0: void __mpn_impn_sqr_n_basecase(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C)
// Called from:
//      __mpn_impn_sqr_n
//      __mpn_mul_n
void __mpn_impn_sqr_n_basecase(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C)
{
	Eq_2 eax_32;
	Eq_2 edx_20 = *dwArg08;
	if (edx_20 <= 0x01)
	{
		if (edx_20 != 0x01)
		{
			Eq_2 eax_58 = dwArg04;
			Eq_2 edx_59 = (word32) dwArg04 + dwArg0C * 0x04;
			if (dwArg0C > 0x00)
			{
				do
				{
					*eax_58 = 0x00;
					eax_58 = (word32) eax_58 + 4;
				} while (edx_59 != eax_58);
			}
		}
		else if (dwArg0C > 0x00)
		{
			Eq_2 eax_44 = 0x00;
			while (true)
			{
				*((word32) dwArg04 + eax_44 * 0x04) = edx_20;
				eax_44 = (word32) eax_44 + 1;
				if (dwArg0C == eax_44)
					break;
				edx_20 = *((word32) dwArg08 + eax_44 * 0x04);
			}
		}
		eax_32.u0 = 0x00;
	}
	else
	{
		word32 ecx_240;
		eax_32 = __mpn_mul_1(dwArg04, dwArg08, dwArg0C, edx_20, out ecx_240);
	}
	*((word32) dwArg04 + dwArg0C * 0x04) = eax_32;
	struct Eq_130505 * esp_122 = fp - 44;
	Eq_2 esi_101 = dwArg0C;
	Eq_2 ebx_107 = (word32) dwArg04 + 4;
	word32 * edi_116 = (word32) dwArg08 + 4;
	if (dwArg0C > 0x01)
	{
		do
		{
			uint32 eax_94 = *edi_116;
			if (eax_94 <= 0x01)
			{
				Eq_2 eax_111 = 0x00;
				if (eax_94 == 0x01)
				{
					struct Eq_130567 * esp_100 = esp_122 - 4;
					esp_100->t0000 = esi_101;
					esp_100->tFFFFFFFC = esp_100->t0038;
					esp_100->tFFFFFFF8 = ebx_107;
					esp_100->tFFFFFFF4 = ebx_107;
					Eq_2 esp_114 = <invalid>;
					eax_111 = __mpn_add_n(esp_100->tFFFFFFF4, esp_100->tFFFFFFF8, esp_100->tFFFFFFFC, esp_100->t0000, out ebx_107, out esi_101, out edi_116);
					esp_122 = (word32) esp_114 + 16;
				}
				*((word32) ebx_107 + dwArg0C * 0x04) = eax_111;
				++edi_116;
				ebx_107 = (word32) ebx_107 + 4;
				if (esp_122[3] != edi_116)
					continue;
				return;
			}
			struct Eq_130520 * esp_135 = esp_122 - 4;
			esp_135->dw0000 = eax_94;
			esp_135->tFFFFFFFC = esi_101;
			esp_135->tFFFFFFF8 = esp_135->t0038;
			esp_135->tFFFFFFF4 = ebx_107;
			ebx_107 = (word32) ebx_107 + 4;
			(ebx_107 - 0x04)[dwArg0C] = __mpn_addmul_1(esp_135->tFFFFFFF4, esp_135->tFFFFFFF8, esp_135->tFFFFFFFC, esp_135->dw0000);
			++edi_116;
			esp_122 = (struct Eq_130505 *) (&esp_135->dw0000 + 1);
		} while (esp_135->ptr0010 != edi_116);
	}
}

// 08094CE0: void __mpn_impn_sqr_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __mpn_impn_sqr_n
//      __mpn_mul_n
void __mpn_impn_sqr_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if ((dwArg0C & 0x01) != 0x00)
	{
		if (dwArg0C > 0x20)
			__mpn_impn_sqr_n(dwArg04, dwArg08, dwArg0C - 0x01, dwArg10);
		else
			__mpn_impn_sqr_n_basecase(dwArg04, dwArg08, dwArg0C - 0x01);
		ui32 esi_603 = (dwArg0C - 0x01) * 0x04;
		uint32 * edi_604 = (word32) dwArg08 + esi_603;
		Eq_2 esi_606 = (word32) dwArg04 + esi_603;
		*((word32) dwArg04 + (dwArg0C - 0x01) * 0x08) = __mpn_addmul_1(esi_606, dwArg08, dwArg0C - 0x01, *edi_604);
		*((word32) dwArg04 + ((word32) dwArg0C + (dwArg0C - 0x01)) * 0x04) = __mpn_addmul_1(esi_606, dwArg08, dwArg0C, *edi_604);
		return;
	}
	Eq_2 edx_30 = (word32) dwArg04 + dwArg0C * 0x04;
	Eq_2 eax_32 = (word32) dwArg08 + (dwArg0C >> 0x01) * 0x04;
	if (dwArg0C >> 0x01 > 0x1F)
		__mpn_impn_sqr_n(edx_30, eax_32, dwArg0C >> 0x01, dwArg10);
	else
		__mpn_impn_sqr_n_basecase(edx_30, eax_32, dwArg0C >> 0x01);
	Eq_2 edi_114;
	Eq_2 esi_115;
	if (__mpn_cmp(eax_32, dwArg08, dwArg0C >> 0x01) >= 0x00)
		__mpn_sub_n(dwArg04, eax_32, dwArg08, dwArg0C >> 0x01, out esi_115, out edi_114);
	else
		__mpn_sub_n(dwArg04, dwArg08, eax_32, dwArg0C >> 0x01, out esi_115, out edi_114);
	Eq_2 (* edi_367)[];
	Eq_2 esi_368;
	struct Eq_130908 * esp_373;
	Eq_2 edx_374;
	Eq_2 ebx_366;
	Eq_2 edi_238;
	Eq_2 esi_239;
	struct Eq_130751 * esp_248;
	word32 edx_250;
	if (esi_115 <= 0x1F)
	{
		__mpn_impn_sqr_n_basecase(edi_114, dwArg04, esi_115);
		if (esi_115 <= 0x00)
		{
			Eq_2 edi_215;
			word32 ebx_840;
			word32 esi_841;
			word32 eax_210 = __mpn_add_n(dwLoc24, dwLoc24, dwArg04 + (dwArg10 + esi_115) * 0x04, esi_115, out ebx_840, out esi_841, out edi_215);
			Eq_2 esp_213 = <invalid>;
			word32 ecx_221 = *((word32) esp_213 + 28);
			*((word32) esp_213 + 32) = eax_210;
			Eq_2 edx_223 = (word32) dwArg04 + ecx_221;
			*((word32) esp_213 + 24) = edx_223;
			*((word32) esp_213 - 4) = *((word32) esp_213 + 88);
			*((word32) esp_213 - 8) = edi_215;
			*((word32) esp_213 - 0x0C) = edx_223;
			*((word32) esp_213 - 16) = edx_223;
			*((word32) esp_213 + 40) = *((word32) esp_213 + 36) - __mpn_sub_n(*((word32) esp_213 - 16), *((word32) esp_213 - 0x0C), *((word32) esp_213 - 8), *((word32) esp_213 - 4), out esi_239, out edi_238);
			esp_248 = (word32) esp_213 + 20;
			edx_250 = (word32) *((word32) esp_213 + 44);
			goto l08094FB8;
		}
	}
	else
		__mpn_impn_sqr_n(edi_114, dwArg04, esi_115, edx_30 + edi_114);
	word32 ecx_257[] = (word32) dwArg04 + dwArg0C * 0x04;
	Eq_2 eax_258 = 0x00;
	do
	{
		ecx_257[eax_258] = (word32) *((word32) dwLoc24 + eax_258 * 0x04);
		eax_258 = (word32) eax_258 + 1;
	} while (esi_115 > eax_258);
	Eq_2 edi_296;
	word32 esi_843;
	word32 ebx_842;
	word32 eax_291 = __mpn_add_n(dwLoc24, dwLoc24, dwArg04 + (dwArg10 + esi_115) * 0x04, esi_115, out ebx_842, out esi_843, out edi_296);
	Eq_2 esp_294 = <invalid>;
	Eq_2 ecx_302 = *((word32) esp_294 + 24);
	*((word32) esp_294 + 36) = eax_291;
	*((word32) esp_294 - 4) = *((word32) esp_294 + 88);
	*((word32) esp_294 - 8) = edi_296;
	*((word32) esp_294 - 0x0C) = ecx_302;
	*((word32) esp_294 - 16) = ecx_302;
	*((word32) esp_294 + 40) -= __mpn_sub_n(*((word32) esp_294 - 16), *((word32) esp_294 - 0x0C), *((word32) esp_294 - 8), *((word32) esp_294 - 4), out esi_239, out edi_238);
	esp_248 = (word32) esp_294 + 20;
	edx_250 = (word32) *((word32) esp_294 + 44);
	if (esi_239 > 0x1F)
	{
		Eq_2 eax_386 = *((word32) esp_294 + 36);
		*((word32) esp_294 + 44) = edx_250;
		Mem391[esp_294 + 0x10:word32] = eax_386 + edi_238;
		*((word32) esp_294 + 0x0C) = esi_239;
		*((word32) esp_294 + 8) = *((word32) esp_294 + 88);
		*((word32) esp_294 + 4) = edi_238;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		__mpn_impn_sqr_n(stackArg4, dwArg04, dwArg08, dwArg0C);
		*esp_294 = *((word32) esp_294 + 92);
		*((word32) esp_294 - 4) = edi_238;
		Eq_2 eax_410 = *((word32) esp_294 + 28);
		*((word32) esp_294 - 8) = eax_410;
		*((word32) esp_294 - 0x0C) = eax_410;
		Eq_2 esp_418 = <invalid>;
		Eq_2 eax_415 = __mpn_add_n(*((word32) esp_294 - 0x0C), *((word32) esp_294 - 8), *((word32) esp_294 - 4), *esp_294, out ebx_366, out esi_368, out edi_367);
		esp_373 = (word32) esp_418 + 32;
		edx_374 = *((word32) esp_418 + 56);
		word32 eax_428 = eax_415 + Mem414[esp_418 + 0x34:word32];
		if (eax_428 == 0x00)
			goto l08094EC0;
		Eq_2 ecx_431 = *((word32) esp_418 + 60);
		up32 eax_432 = (word32) *ecx_431 + eax_428;
		*ecx_431 = eax_432;
		if (eax_432 >= 0x00)
		{
l08094EC0:
			do
			{
				*((word32) dwArg04 + ebx_366 * 0x04) = edi_367[ebx_366];
				ebx_366 = (word32) ebx_366 + 1;
			} while (esi_368 > ebx_366);
			goto l08094ECE;
		}
l0809505A:
		esp_373->t0010 = esi_368;
		esp_373->t0014 = ebx_366;
		int32 ecx_437 = esi_368 - 0x01;
		int32 eax_440 = 0x00;
		struct Eq_131031 * ebx_446 = esp_373->ptr001C;
		while (ecx_437 != eax_440)
		{
			word32 ecx_453 = ebx_446->a0004[eax_440];
			ebx_446->a0004[eax_440] = ecx_453 + 0x01;
			++eax_440;
			if (ecx_453 != 0x01)
				break;
		}
		esi_368 = esp_373->t0010;
		ebx_366 = esp_373->t0014;
		if (esi_368 <= 0x00)
		{
l08094ECE:
			esp_373->t0010 = edx_374;
			struct Eq_131043 * esp_510 = esp_373 - 4;
			esp_510->t0000 = esi_368;
			esp_510->tFFFFFFFC = edi_367 + esp_510->dw0010 / 4;
			Eq_2 eax_518 = esp_510->t000C;
			esp_510->tFFFFFFF8 = eax_518;
			esp_510->tFFFFFFF4 = eax_518;
			word32 ebx_845;
			word32 edi_847;
			word32 esi_846;
			Eq_2 eax_523 = __mpn_add_n(esp_510->tFFFFFFF4, esp_510->tFFFFFFF8, esp_510->tFFFFFFFC, esp_510->t0000, out ebx_845, out esi_846, out edi_847);
			Eq_2 esp_526 = <invalid>;
			struct Eq_131088 * edx_535 = *((word32) esp_526 + 32);
			if (eax_523 != 0x00)
			{
				up32 eax_539 = edx_535->dw0000;
				edx_535->dw0000 = eax_539 + 0x01;
				if (eax_539 < 0x01)
				{
					Eq_2 eax_544 = *((word32) esp_526 + 88);
					ui32 eax_546 = 0x00;
					while (eax_546 != eax_544 - 0x01)
					{
						word32 edi_555 = edx_535->a0004[eax_546];
						edx_535->a0004[eax_546] = edi_555 + 0x01;
						++eax_546;
						if (edi_555 != 0x01)
							return;
					}
				}
			}
			return;
		}
l08094FEF:
		*((word32) dwArg04 + ebx_366 * 0x04) = edi_367[ebx_366];
		ebx_366 = (word32) ebx_366 + 1;
		if (esi_368 > ebx_366)
			goto l08094EC0;
		goto l08094ECE;
	}
l08094FB8:
	esp_248->dw0010 = edx_250;
	struct Eq_130840 * esp_334 = esp_248 - 0x04;
	esp_334->tFFFFFFFC = esi_239;
	esp_334->tFFFFFFF8 = esp_334->t0048;
	esp_334->tFFFFFFF4 = edi_238;
	__mpn_impn_sqr_n_basecase(esp_334->tFFFFFFF4, esp_334->tFFFFFFF8, esp_334->tFFFFFFFC);
	esp_334->tFFFFFFF0 = esp_334->t004C;
	esp_334->tFFFFFFEC = edi_238;
	Eq_2 eax_357 = esp_334->t000C;
	esp_334->tFFFFFFE8 = eax_357;
	esp_334->tFFFFFFE4 = eax_357;
	Eq_2 esp_365 = <invalid>;
	Eq_2 eax_362 = __mpn_add_n(esp_334->tFFFFFFE4, esp_334->tFFFFFFE8, esp_334->tFFFFFFEC, esp_334->tFFFFFFF0, out ebx_366, out esi_368, out edi_367);
	esp_373 = (word32) esp_365 + 32;
	edx_374 = *((word32) esp_365 + 48);
	word32 eax_375 = eax_362 + Mem361[esp_365 + 0x34:word32];
	if (eax_375 != 0x00)
	{
		Eq_2 ecx_378 = *((word32) esp_365 + 60);
		up32 eax_379 = (word32) *ecx_378 + eax_375;
		*ecx_378 = eax_379;
		if (eax_379 < 0x00)
			goto l0809505A;
	}
	if (esi_368 <= 0x00)
		goto l08094ECE;
	goto l08094FEF;
}

// 080950A0: void __mpn_mul_n(Register (ptr32 Eq_131212) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
void __mpn_mul_n(struct Eq_131212 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	struct Eq_131217 * esp_138 = fp - 0x3C;
	word32 edi_21 = gs->dw0014;
	if (dwArg08 != dwArg0C)
	{
		if (dwArg10 > 0x1F)
		{
			ui32 ebx_128 = dwArg10 * 0x08 + 0x1B;
			struct Eq_131217 * edi_134 = fp - 0x3C - (ebx_128 & ~0x0FFF);
			if (fp - 0x3C != edi_134)
			{
				do
				{
					esp_138 -= 0x1000;
					esp_138->dw0FFC = esp_138->dw0FFC;
				} while (esp_138 != edi_134);
			}
			if ((ebx_128 & ~0x0F & 0x0FFF) != 0x00)
			{
				esp_138 -= ebx_128 & ~0x0F & 0x0FFF;
				Mem158[esp_138 - 0x04 + ((ebx_128 & ~0x0F) & 0x0FFF):word32] = Mem149[esp_138 - 0x04 + ((ebx_128 & ~0x0F) & 0x0FFF):word32];
			}
			struct Eq_131258 * esp_163 = esp_138 - 0x0C;
			Mem168[esp_163 + -4:word32] = esp_138 + 0x0F & ~0x0F;
			esp_163->tFFFFFFF8 = dwArg10;
			esp_163->tFFFFFFF4 = dwArg0C;
			esp_163->tFFFFFFF0 = dwArg08;
			esp_163->tFFFFFFEC = dwArg04;
			__mpn_impn_mul_n(esp_163->tFFFFFFEC, esp_163->tFFFFFFF0, esp_163->tFFFFFFF4, esp_163->tFFFFFFF8, esp_163->t0000, esp_163->t0004);
		}
		else
			__mpn_impn_mul_n_basecase(dwArg04, dwArg08, dwArg0C, dwArg10);
	}
	else if (dwArg10 > 0x1F)
	{
		ui32 ecx_47 = dwArg10 * 0x08 + 0x1B;
		struct Eq_131217 * edi_51 = fp - 0x3C - (ecx_47 & ~0x0FFF);
		if (fp - 0x3C != edi_51)
		{
			do
			{
				esp_138 -= (struct Eq_131336 *) 0x1000;
				esp_138->dw0FFC = esp_138->dw0FFC;
			} while (esp_138 != edi_51);
		}
		struct Eq_131329 * ebx_67 = ecx_47 & ~0x0F & 0x0FFF;
		if (ebx_67 != null)
		{
			esp_138 -= ebx_67;
			Mem75[esp_138 - 0x04 + ebx_67:word32] = Mem73[esp_138 - 0x04 + ebx_67:word32];
		}
		struct Eq_131345 * esp_83 = esp_138 - (struct Eq_131346 *) 4;
		Mem84[esp_83 + 0x00:word32] = esp_138 + 0x0F & ~0x0F;
		esp_83->tFFFFFFFC = dwArg10;
		esp_83->tFFFFFFF8 = dwArg08;
		esp_83->tFFFFFFF4 = dwArg04;
		__mpn_impn_sqr_n(esp_83->tFFFFFFF4, esp_83->tFFFFFFF8, esp_83->tFFFFFFFC, esp_83->a0000[0]);
	}
	else
		__mpn_impn_sqr_n_basecase(dwArg04, dwArg08, dwArg10);
	if ((edi_21 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_347;
	word32 edx_348;
	__stack_chk_fail(out ecx_347, out edx_348);
	word32 esi_349;
	word32 edi_350;
	__mpn_sub_n(dwArg04, dwArg08, dwArg0C, dwArg10, out esi_349, out edi_350);
}

// 080951D0: Register Eq_131404 __mpn_sub_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out ptr32 esiOut, Register out (ptr32 (arr Eq_128777)) ediOut)
// Called from:
//      __mpn_divrem
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n
//      __mpn_mul_n
Eq_131404 __mpn_sub_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, ptr32 & esiOut, Eq_128777 (& ediOut)
{
	Eq_2 edi_10 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	Eq_2 edx_12 = dwArg0C;
	uint32 ecx_18 = dwArg10 >> 0x03;
	uint32 eax_19 = -dwArg10;
	if ((eax_19 & 0x07) == 0x00)
	{
		do
		{
			up32 eax_29 = *esi_11 - *edx_12;
			*edi_10 = eax_29;
			up32 eax_35 = *((word32) esi_11 + 4) - *((word32) edx_12 + 4) - (eax_29 < 0x00);
			*((word32) edi_10 + 4) = eax_35;
			up32 eax_40 = *((word32) esi_11 + 8) - *((word32) edx_12 + 8) - (eax_35 < 0x00);
			*((word32) edi_10 + 8) = eax_40;
			up32 eax_45 = *((word32) esi_11 + 0x0C) - *((word32) edx_12 + 0x0C) - (eax_40 < 0x00);
			*((word32) edi_10 + 0x0C) = eax_45;
			up32 eax_50 = *((word32) esi_11 + 16) - *((word32) edx_12 + 16) - (eax_45 < 0x00);
			*((word32) edi_10 + 16) = eax_50;
			up32 eax_55 = *((word32) esi_11 + 20) - *((word32) edx_12 + 20) - (eax_50 < 0x00);
			*((word32) edi_10 + 20) = eax_55;
			up32 eax_60 = *((word32) esi_11 + 24) - *((word32) edx_12 + 24) - (eax_55 < 0x00);
			*((word32) edi_10 + 24) = eax_60;
			up32 eax_65 = *((word32) esi_11 + 28) - *((word32) edx_12 + 28) - (eax_60 < 0x00);
			*((word32) edi_10 + 28) = eax_65;
			edi_10 = (word32) edi_10 + 32;
			esi_11 = (word32) esi_11 + 32;
			edx_12 = (word32) edx_12 + 32;
			--ecx_18;
		} while (ecx_18 != 0x00);
		esiOut = esi;
		ediOut = edi;
		return eax_65 < 0x00;
	}
	else
	{
		uint32 eax_88 = (eax_19 & 0x07) << 0x02;
		ui32 ebx_94 = (eax_88 >> 0x02) * 0x04 + ~0x03;
		Eq_128777 (* edi_89)[] = dwArg04 - eax_88;
		ptr32 esi_90 = dwArg08 - eax_88;
		Eq_131404 eax_95 = fn0809520C(eax_88 >> 0x02, ebx_94, dwLoc10);
		Eq_2 esp_96 = <invalid>;
		Eq_131404 eax_101 = fn0809520C(eax_95, ebx_94, *esp_96);
		esiOut = esi_90;
		ediOut = edi_89;
		return eax_101;
	}
}

// 0809520C: Register Eq_131404 fn0809520C(Register Eq_131404 eax, Register ui32 ebx, Stack word32 dwArg00)
// Called from:
//      __mpn_sub_n
Eq_131404 fn0809520C(Eq_131404 eax, ui32 ebx, word32 dwArg00)
{
	<anonymous> * eax_11 = eax * 0x09 + dwArg00 + 0x11 + ebx;
	Eq_131404 eax_13;
	eax_11();
	return eax_13;
}

// 080952A0: Register word32 __mpn_submul_1(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      __mpn_divrem
word32 __mpn_submul_1(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	up32 edi_20[] = (word32) dwArg04 + dwArg0C * 0x04;
	uint32 esi_21[] = (word32) dwArg08 + dwArg0C * 0x04;
	ui32 ecx_22 = -dwArg0C;
	word32 ebp_23 = 0x00;
	do
	{
		uint64 edx_eax_32 = dwArg10 *64 esi_21[ecx_22];
		up32 eax_35 = (word32) edx_eax_32 + ebp_23;
		up32 v14_41 = edi_20[ecx_22] - eax_35;
		edi_20[ecx_22] = v14_41;
		word32 edx_45 = (bool) (v14_41 < 0x00) + ((bool) (eax_35 < 0x00) + SLICE(edx_eax_32, word32, 32));
		ebp_23 = edx_45;
		++ecx_22;
	} while (ecx_22 != 0x00);
	return edx_45;
}

// 080952F0: Register word32 __mpn_extract_double(Stack (ptr32 Eq_83083) dwArg04, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 uint32) dwArg10, Stack Eq_963 dwArg14, Stack uint32 dwArg18)
// Called from:
//      __printf_fp_l
word32 __mpn_extract_double(struct Eq_83083 * dwArg04, ui32 * dwArg0C, uint32 * dwArg10, Eq_963 dwArg14, uint32 dwArg18)
{
	*dwArg10 = dwArg18 >> 0x1F;
	*dwArg0C = (dwArg18 >> 0x14 & 0x07FF) - 0x03FF;
	dwArg04->dw0004 = dwArg18 & 0x000FFFFF;
	dwArg04->t0000 = dwArg14;
	if ((dwArg18 >> 0x10 & 0x7FF0) != 0x00)
	{
		dwArg04->dw0004 = dwArg18 & 0x000FFFFF | 0x00100000;
		return;
	}
	else
	{
		if (dwArg14 == 0x00)
		{
			if ((dwArg18 & 0x000FFFFF) == 0x00)
			{
				*dwArg0C = 0x00;
				return;
			}
		}
		else if ((dwArg18 & 0x000FFFFF) == 0x00)
		{
			word32 edx_57 = __bsr(dwArg14);
			if ((edx_57 ^ 0x1F) > 0x0A)
			{
				dwArg04->t0000.u0 = 0x00;
				dwArg04->dw0004 = dwArg14 << (byte) ((edx_57 ^ 0x1F) - 11);
			}
			else
			{
				dwArg04->dw0004 = dwArg14 >> (byte) (11 - (edx_57 ^ 0x1F));
				dwArg04->t0000 = dwArg14 << (byte) ((edx_57 ^ 0x1F) + 0x15);
			}
			*dwArg0C = ~0x0412 - (edx_57 ^ 0x1F);
			return;
		}
		ui32 edx_103 = (__bsr(dwArg18 & 0x000FFFFF) ^ 0x1F) - 11;
		byte cl_108 = (byte) edx_103;
		dwArg04->t0000 = dwArg14 << cl_108;
		dwArg04->dw0004 = dwArg14 >> (byte) (0x20 - edx_103) | (dwArg18 & 0x000FFFFF) << cl_108;
		*dwArg0C = ~0x03FD - edx_103;
		return;
	}
}

// 08095400: Register word32 __mpn_extract_long_double(Stack (ptr32 Eq_82761) dwArg04, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 word32) dwArg10, Stack real80 rArg14)
// Called from:
//      __printf_fp_l
word32 __mpn_extract_long_double(struct Eq_82761 * dwArg04, ui32 * dwArg0C, word32 * dwArg10, real80 rArg14)
{
	__align(fp - 16);
	real64 rLoc1_161 = (real64) rArg14;
	real80 rLoc20_164 = (real80) rLoc1_161;
	*dwArg10 = (word32) (SLICE(rLoc20_164, byte, 72) >> 0x07);
	*dwArg0C = ((word32) SLICE(rLoc20_164, word16, 64) & 0x7FFF) - 0x3FFF;
	Eq_963 dwLoc30_169 = (word32) (real80) rLoc1_161;
	dwArg04->t0000 = dwLoc30_169;
	ui32 dwLoc3C_172 = SLICE((real80) rLoc1_161, word32, 32);
	dwArg04->dw0004 = dwLoc3C_172;
	cui16 cx_54 = SLICE((real80) rLoc1_161, word16, 64);
	if ((cx_54 & 0x7FFF) != 0x00)
	{
		if ((dwLoc30_169 | dwLoc3C_172) != 0x00)
			return;
		if ((cx_54 & 0x7FFF) == 0x7FFF)
			return;
l08095471:
		*dwArg0C = 0x00;
		return;
	}
	else
	{
		if (dwLoc30_169 == 0x00)
		{
			if (dwLoc3C_172 == 0x00)
				goto l08095471;
			if ((dwLoc3C_172 & 0x7FFFFFFF) == 0x00)
			{
				dwArg04->dw0004 = 0x80000000;
				*dwArg0C = ~0x3FFD;
				return;
			}
		}
		else if ((dwLoc3C_172 & 0x7FFFFFFF) == 0x00)
		{
			word32 ecx_82 = __bsr(dwLoc30_169);
			dwArg04->t0000.u0 = 0x00;
			dwArg04->dw0004 = dwLoc30_169 << (byte) (ecx_82 ^ 0x1F);
			*dwArg0C = ~0x401D - (ecx_82 ^ 0x1F);
			return;
		}
		word32 edi_100 = __bsr(dwLoc3C_172 & 0x7FFFFFFF);
		dwArg04->dw0004 = (dwLoc3C_172 & 0x7FFFFFFF) << (byte) (edi_100 ^ 0x1F) | dwLoc30_169 >> (byte) (0x20 - (edi_100 ^ 0x1F));
		dwArg04->t0000 = dwLoc30_169 << (byte) (edi_100 ^ 0x1F);
		*dwArg0C = ~0x3FFD - (edi_100 ^ 0x1F);
		return;
	}
}

// 08095530: Register word32 __mpn_extract_float128(Stack (ptr32 Eq_80300) dwArg04, Stack (ptr32 Eq_2) dwArg0C, Stack (ptr32 word32) dwArg10, Stack Eq_2 owArg14)
// Called from:
//      __printf_fp_l
word32 __mpn_extract_float128(struct Eq_80300 * dwArg04, union Eq_2 * dwArg0C, word32 * dwArg10, Eq_2 owArg14)
{
	word32 dwArg20_243 = SLICE(owArg14, word32, 96);
	Eq_131865 dwArg14_247 = (word32) owArg14;
	ui32 dwArg1C_248 = SLICE(owArg14, word32, 64);
	ui32 dwArg18_250 = SLICE(owArg14, word32, 32);
	*dwArg10 = (word32) (SLICE(owArg14, byte, 120) >> 0x07);
	Eq_2 edx_35 = ((word32) SLICE(owArg14, word16, 112) & 0x7FFF) - 0x3FFF;
	*dwArg0C = (union Eq_2 *) edx_35;
	cui16 dx_43 = (word16) __pextrw(edx_35, owArg14, 0x07);
	dwArg04->a0000[0] = dwArg14_247;
	dwArg04->dw0004 = dwArg18_250;
	dwArg04->dw0008 = dwArg1C_248;
	word16 bp_32 = (word16) dwArg20_243;
	Eq_963 ecx_33 = (word32) bp_32;
	dwArg04->t000C = ecx_33;
	if ((dx_43 & 0x7FFF) != 0x00)
	{
		dwArg04->t000C = ecx_33 | 0x00010000;
		return;
	}
	int32 esi_111;
	uint32 edi_110;
	int32 edx_77;
	if ((dwArg18_250 | dwArg14_247 | dwArg1C_248) != 0x00)
	{
		if (bp_32 == 0x00)
		{
			if (dwArg1C_248 == 0x00)
			{
				uint32 ecx_91 = (uint32) (int8) (dwArg18_250 != 0x00);
				edi_110 = ecx_91;
				edx_77 = ecx_91 * 0x04;
				esi_111 = 0x03 - ecx_91;
			}
			else
			{
				esi_111 = 0x01;
				edx_77 = 0x08;
				edi_110 = 0x02;
			}
l080955DA:
			int32 edx_154;
			Eq_963 ecx_101 = dwArg04[edx_77 / 16];
			word32 edx_102 = __bsr(ecx_101);
			int32 ebp_105 = (edx_102 ^ 0x1F) - 0x0F;
			if (ebp_105 >= 0x00)
			{
				if (ebp_105 == 0x00)
				{
					dwArg04->t000C = ecx_101;
					int32 ebx_167 = esi_111 * 0x04;
					int32 * edx_168 = &dwArg04->t000C;
					int32 * edi_170 = dwArg04 + ebx_167 / 16;
					int32 ebx_171 = -ebx_167;
					if (edi_170 != &dwArg04->t000C)
					{
						do
						{
							edx_168 -= 0x04;
							*edx_168 = (int32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(edx_168 - 0x04)[ebx_171 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
						} while (edi_170 != edx_168);
					}
					edx_154 = esi_111 - 0x01;
					goto l08095619;
				}
				if (esi_111 == 0x03)
				{
					dwArg04->t000C = dwArg14_247 << (byte) ((edx_102 ^ 0x1F) - 0x0F);
					edx_154 = 0x02;
					goto l08095620;
				}
			}
			else
			{
				ebp_105 = (edx_102 ^ 0x1F) + 0x11;
				esi_111 = 0x02 - edi_110;
			}
			byte bLoc30_304 = (byte) (0x20 - ebp_105);
			ui32 edi_129[] = dwArg04 - esi_111 * 0x04;
			int32 edx_131 = 0x03;
			do
			{
				dwArg04[edx_131 * 0x04 / 16] = (struct Eq_80300) (edi_129[edx_131] << (byte) ebp_105 | (edi_129 - 0x04)[edx_131] >> bLoc30_304);
				--edx_131;
			} while (esi_111 < edx_131);
			dwArg04[esi_111 * 0x04 / 16] = (struct Eq_80300) (dwArg04->a0000[0] << (byte) ebp_105);
			edx_154 = esi_111 - 0x01;
l08095619:
			if (edx_154 < 0x00)
			{
l0809562F:
				*dwArg0C = (union Eq_2 *) (~0x3FFD - (esi_111 << 0x05) - ebp_105);
				return;
			}
l08095620:
			do
			{
				dwArg04[edx_154 * 0x04 / 16] = (struct Eq_80300) 0x00;
				--edx_154;
			} while (edx_154 != ~0x00);
			goto l0809562F;
		}
	}
	else if (bp_32 == 0x00)
	{
		*dwArg0C = (union Eq_2 *) 0x00;
		return;
	}
	esi_111 = 0x00;
	edx_77 = 0x0C;
	edi_110 = 0x03;
	goto l080955DA;
}

// 08095740: Register Eq_2 _itoa_word(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out Eq_2 ecxOut, Register out (ptr32 Eq_76654) edxOut)
// Called from:
//      printf_positional
//      __printf_fphex
//      strerror_r
//      _fitoa_word
Eq_2 _itoa_word(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, union Eq_2 & ecxOut, struct Eq_76654 & edxOut)
{
	Eq_2 ecx_109 = dwArg04;
	Eq_2 ebx_122 = dwArg08;
	byte esi_147[] = g_a80B8660;
	if (dwArg10 == 0x00)
		esi_147 = (byte (*)[]) &g_t80B8620;
	if (dwArg0C == 0x0A)
	{
		while (true)
		{
			uint32 edx_39 = SLICE(ecx_109 *64 ~0x33333332, word32, 32);
			--ebx_122;
			Mem48[ebx_122 + 0x00:byte] = Mem45[esi_147 + (ecx_109 - ((edx_39 >>u 0x03) + (edx_39 >>u 0x03) * 0x04) * 0x02):byte];
			if (ecx_109 <= 0x09)
				break;
			ecx_109 = edx_39 >> 0x03;
		}
		ecxOut = ecx_109;
		edxOut = edx_39 >> 0x03;
		return ebx_122;
	}
	else if (dwArg0C == 0x10)
	{
		while (true)
		{
			--ebx_122;
			*ebx_122 = esi_147[ecx_109 & 0x0F];
			Eq_2 eax_76 = ecx_109 >> 0x04;
			if (ecx_109 <= 0x0F)
				break;
			ecx_109 = eax_76;
		}
		ecxOut = ecx_109;
		edxOut = (struct Eq_76654 *) &g_t80B8620;
		return ebx_122;
	}
	else if (dwArg0C != 0x08)
	{
		while (true)
		{
			uint64 edx_eax_97 = (uint64) ecx_109;
			struct Eq_76654 * edx_104 = (word32) esi_147[(uint32) (edx_eax_97 % dwArg0C)];
			--ebx_122;
			*ebx_122 = (byte) edx_104;
			Eq_2 eax_101 = (uint32) (edx_eax_97 /u dwArg0C);
			if (ecx_109 < dwArg0C)
				break;
			ecx_109 = eax_101;
		}
		ecxOut = ecx_109;
		edxOut = edx_104;
		return ebx_122;
	}
	else
	{
		while (true)
		{
			--ebx_122;
			*ebx_122 = esi_147[ecx_109 & 0x07];
			Eq_2 eax_131 = ecx_109 >> 0x03;
			if (ecx_109 <= 0x07)
				break;
			ecx_109 = eax_131;
		}
		ecxOut = ecx_109;
		edxOut = (struct Eq_76654 *) &g_t80B8620;
		return ebx_122;
	}
}

// 08095840: Register Eq_2 _itoa(Register (ptr32 Eq_9) gs, Stack Eq_86855 qwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out Eq_2 ebxOut, Register out (ptr32 Eq_86860) ebpOut, Register out Eq_86861 ediOut)
// Called from:
//      __printf_fphex
//      _dl_debug_vdprintf
//      _fitoa
//      _dl_check_map_versions
Eq_2 _itoa(struct Eq_9 * gs, Eq_86855 qwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, union Eq_2 & ebxOut, struct Eq_86860 & ebpOut, union Eq_86861 & ediOut)
{
	Eq_2 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_2 dwArg04 = (word32) qwArg04;
	struct Eq_86860 * ebp_19 = g_a80B8660;
	Eq_2 esi_211 = dwArg10;
	ui32 eax_26 = gs->dw0014;
	Eq_2 ebx_102 = dwArg04;
	if (dwArg14 == 0x00)
		ebp_19 = (struct Eq_86860 *) &g_t80B8620;
	Eq_2 ecx_117;
	if (dwArg10 != 0x08)
	{
		if (dwArg10 != 0x10)
		{
			word32 dwLoc3C_350;
			if (dwArg08 != 0x00)
			{
				Eq_2 edi_139 = (0x080B8460 + ((dwArg10 - 0x02) + (dwArg10 - 0x02) * 0x02) * 0x04)->t0008;
				if (edi_139 <= dwArg08)
				{
					ebx_102 = (uint32) (SEQ((uint32) ((uint64) dwArg08 % edi_139), dwArg04) % edi_139);
					dwLoc3C_350 = 0x03;
				}
				else
				{
					dwLoc3C_350 = 0x02;
					ebx_102 = (uint32) (qwArg04 % edi_139);
				}
			}
			else
				dwLoc3C_350 = 0x01;
			int32 edx_192;
			Eq_2 edi_180 = dwArg0C;
			ui32 dwLoc3C_363 = dwLoc3C_350 - 0x01;
			struct Eq_132272 * eax_185 = 0x080B8460 + (dwArg10 - 0x02) * 0x0C;
			ecx_117 = dwArg0C;
			while (ebx_102 == 0x00)
			{
				edx_192 = 0x00;
l0809593A:
				if (dwLoc3C_363 == 0x00)
				{
					if (dwArg0C == ecx_117)
					{
						*((word32) ecx_117 - 1) = 0x30;
						--ecx_117;
					}
					goto l08095958;
				}
				int32 eax_202 = (int32) eax_185->b0005;
				if (eax_202 > edx_192)
				{
					edi_180 = (word32) ecx_117 + (edx_192 - eax_202);
					do
					{
						--ecx_117;
						*ecx_117 = 0x30;
					} while (edi_180 != ecx_117);
				}
				else
					edi_180 = ecx_117;
				ecx_117 = edi_180;
				--dwLoc3C_363;
				ebx_102 = (fp - 0x30)[dwLoc3C_363];
			}
			while (true)
			{
				uint64 edx_eax_236 = (uint64) ebx_102;
				--ecx_117;
				*ecx_117 = ebp_19[(uint32) (edx_eax_236 % esi_211) / 360];
				Eq_2 eax_240 = (uint32) (edx_eax_236 /u esi_211);
				edx_192 = edi_180 - ecx_117;
				if (ebx_102 < esi_211)
					break;
				ebx_102 = eax_240;
			}
			goto l0809593A;
		}
		Eq_2 eax_100 = dwArg0C;
		ecx_117 = dwArg0C;
		if (dwArg08 != 0x00)
		{
			ecx_117 = dwArg0C - 0x08;
			do
			{
				--eax_100;
				*eax_100 = ebp_19[(ebx_102 & 0x0F) / 360];
				ebx_102 >>= 0x04;
			} while (dwArg0C - 0x08 != eax_100);
			ebx_102 = dwArg08;
		}
		do
		{
			--ecx_117;
			*ecx_117 = ebp_19[(ebx_102 & 0x0F) / 360];
			ebx_102 >>= 0x04;
		} while (ebx_102 != 0x00);
	}
	else
	{
		ecx_117 = dwArg0C;
		if (dwArg08 != 0x00)
		{
			ecx_117 = dwArg0C - 0x0A;
			Eq_2 esi_47 = dwArg0C;
			do
			{
				--esi_47;
				*esi_47 = ebp_19[(ebx_102 & 0x07) / 360];
				ebx_102 >>= 0x03;
			} while (dwArg0C - 0x0A != esi_47);
			ebx_102 |= dwArg08 * 0x04 & 0x04;
			if (dwArg08 >> 0x01 != 0x00)
			{
				Mem74[dwArg0C + -11:byte] = Mem58[ebp_19 + ebx_102:byte];
				ebx_102 = dwArg08 >> 0x01;
				ecx_117 = dwArg0C - 11;
			}
		}
		do
		{
			--ecx_117;
			*ecx_117 = ebp_19[(ebx_102 & 0x07) / 360];
			ebx_102 >>= 0x03;
		} while (ebx_102 != 0x00);
	}
l08095958:
	Eq_86861 edi_276 = eax_26 ^ gs->dw0014;
	if (edi_276 != 0x00)
	{
		word32 edx_531;
		word32 ecx_530;
		__stack_chk_fail(out ecx_530, out edx_531);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg4 = <invalid>;
		Eq_2 stackArg8 = <invalid>;
		Eq_2 stackArg12 = <invalid>;
		Eq_2 stackArg16 = <invalid>;
		Eq_2 eax_314 = _fitoa_word(gs, stackArg4, stackArg8, stackArg12, stackArg16);
		ebxOut = ebx_102;
		ebpOut = ebp_19;
		ediOut = edi_276;
		return eax_314;
	}
	else
	{
		ebxOut = ebx;
		ebpOut = ebp;
		ediOut = edi;
		return ecx_117;
	}
}

// 08095AB0: Register Eq_2 _fitoa_word(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      _itoa
Eq_2 _fitoa_word(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	Eq_2 eax_135;
	ui32 eax_18 = gs->dw0014;
	word32 edx_156;
	word32 ecx_155;
	Eq_2 eax_36 = _itoa_word(dwArg04, fp - 0x20, dwArg0C, dwArg10, out ecx_155, out edx_156);
	if (eax_36 < fp - 0x20)
	{
		Eq_2 edi_48 = dwArg08;
		Eq_2 esi_49 = eax_36;
		do
		{
			*edi_48 = *esi_49;
			esi_49 = (word32) esi_49 + 1;
			edi_48 = (word32) edi_48 + 1;
		} while (esi_49 != fp - 0x20);
		eax_135 = (word32) dwArg08 + (esi_49 - eax_36);
	}
	else
		eax_135 = dwArg08;
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return eax_135;
	word32 ecx_157;
	word32 edx_158;
	__stack_chk_fail(out ecx_157, out edx_158);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_2 stackArg12 = <invalid>;
	return _fitoa(gs, stackArg12);
}

// 08095B20: Register Eq_2 _fitoa(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg0C)
// Called from:
//      _fitoa_word
Eq_2 _fitoa(struct Eq_9 * gs, Eq_2 dwArg0C)
{
	Eq_2 eax_134;
	ui32 eax_18 = gs->dw0014;
	word32 ebx_151;
	word32 ebp_152;
	word32 edi_153;
	Eq_2 eax_39 = _itoa(gs, dwArg04, fp - 0x20, dwArg10, dwArg14, out ebx_151, out ebp_152, out edi_153);
	if (eax_39 < fp - 0x20)
	{
		Eq_2 esi_46 = eax_39;
		Eq_2 edi_47 = dwArg0C;
		do
		{
			*edi_47 = *esi_46;
			esi_46 = (word32) esi_46 + 1;
			edi_47 = (word32) edi_47 + 1;
		} while (esi_46 != fp - 0x20);
		eax_134 = (word32) dwArg0C + (esi_46 - eax_39);
	}
	else
		eax_134 = dwArg0C;
	if ((eax_18 ^ gs->dw0014) == 0x00)
		return eax_134;
	word32 ecx_154;
	word32 edx_155;
	__stack_chk_fail(out ecx_154, out edx_155);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_86855 stackArg4 = <invalid>;
	Eq_2 stackArg12 = <invalid>;
	Eq_2 stackArg16 = <invalid>;
	Eq_2 stackArg20 = <invalid>;
	word32 ebp_160;
	word32 esi_161;
	word32 edi_162;
	return _itowa(gs, stackArg4, stackArg12, stackArg16, stackArg20, out ebp_160, out esi_161, out edi_162);
}

// 08095B90: Register Eq_2 _itowa(Register (ptr32 Eq_9) gs, Stack Eq_86855 qwArg04, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Stack Eq_2 dwArg14, Register out Eq_2 ebpOut, Register out Eq_2 esiOut, Register out Eq_86927 ediOut)
// Called from:
//      __printf_fphex
//      _fitoa
Eq_2 _itowa(struct Eq_9 * gs, Eq_86855 qwArg04, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 dwArg14, union Eq_2 & ebpOut, union Eq_2 & esiOut, union Eq_86927 & ediOut)
{
	Eq_2 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_2 dwArg04 = (word32) qwArg04;
	Eq_2 esi_20 = dwArg10;
	Eq_2 ebp_184 = dwArg0C;
	ui32 edi_25 = gs->dw0014;
	Eq_2 edi_30[] = g_a80B86A0;
	if (dwArg14 == 0x00)
		edi_30 = g_a80B8740;
	Eq_2 ebx_113;
	Eq_2 ecx_108 = dwArg04;
	if (dwArg10 != 0x08)
	{
		if (dwArg10 != 0x10)
		{
			ui32 dwLoc3C_334;
			if (dwArg08 != 0x00)
			{
				Eq_2 ebx_133 = (0x080B8460 + ((dwArg10 - 0x02) + (dwArg10 - 0x02) * 0x02) * 0x04)->t0008;
				if (ebx_133 <= dwArg08)
				{
					ecx_108 = (uint32) (SEQ((uint32) ((uint64) dwArg08 % ebx_133), dwArg04) % ebx_133);
					dwLoc3C_334 = 0x03;
				}
				else
				{
					dwLoc3C_334 = 0x02;
					ecx_108 = (uint32) (qwArg04 % ebx_133);
				}
			}
			else
				dwLoc3C_334 = 0x01;
			ebx_113 = dwArg0C;
			struct Eq_132611 * eax_178 = 0x080B8460 + (dwArg10 - 0x02) * 0x0C;
			while (true)
			{
				ui32 v20_182 = dwLoc3C_334 - 0x01;
				esi_20 = dwArg10;
				dwLoc3C_334 = v20_182;
				ebp_184.u0 = 0x00;
				if (ecx_108 != 0x00)
				{
					while (true)
					{
						uint64 edx_eax_196 = (uint64) ecx_108;
						ebx_113 -= 0x04;
						*ebx_113 = edi_30[(uint32) (edx_eax_196 % dwArg10)];
						ebp_184 = (word32) ebp_184 + 1;
						Eq_2 eax_200 = (uint32) (edx_eax_196 /u dwArg10);
						if (ecx_108 < dwArg10)
							break;
						ecx_108 = eax_200;
					}
				}
				if (v20_182 == 0x00)
					break;
				Eq_2 ecx_277 = (int32) eax_178->b0005;
				if (ecx_277 > ebp_184)
				{
					Eq_2 edx_283 = (word32) ebx_113 + (ebp_184 - ecx_277) * 0x04;
					Eq_2 eax_284 = ebx_113;
					do
					{
						eax_284 -= 0x04;
						*eax_284 = 0x30;
					} while (eax_284 != edx_283);
					ebx_113 = (word32) ebx_113 + (ebp_184 - ecx_277) * 0x04;
				}
				ecx_108 = (fp - 0x30)[v20_182];
			}
		}
		else
		{
			ebx_113 = dwArg0C;
			if (dwArg08 != 0x00)
			{
				ebx_113 = dwArg0C - 0x20;
				do
				{
					ebp_184 -= 0x04;
					*ebp_184.u0 = edi_30[ecx_108 & 0x0F];
					ecx_108 >>= 0x04;
				} while (dwArg0C - 0x20 != ebp_184);
				ecx_108 = dwArg08;
			}
			do
			{
				ebx_113 -= 0x04;
				*ebx_113 = edi_30[ecx_108 & 0x0F];
				esi_20 = dwArg10;
				ecx_108 >>= 0x04;
			} while (ecx_108 != 0x00);
		}
	}
	else
	{
		ebx_113 = dwArg0C;
		if (dwArg08 != 0x00)
		{
			ebx_113 = dwArg0C - 0x28;
			Eq_2 eax_47 = dwArg0C;
			do
			{
				eax_47 -= 0x04;
				esi_20 = edi_30[ecx_108 & 0x07];
				*eax_47 = esi_20;
				ecx_108 >>= 0x03;
			} while (eax_47 != dwArg0C - 0x28);
			ecx_108 |= dwArg08 * 0x04 & 0x04;
			if (dwArg08 >> 0x01 != 0x00)
			{
				*((word32) dwArg0C - 44) = edi_30[ecx_108];
				ebx_113 = dwArg0C - 44;
				ecx_108 = dwArg08 >> 0x01;
			}
		}
		do
		{
			ebx_113 -= 0x04;
			*ebx_113 = edi_30[ecx_108 & 0x07];
			ecx_108 >>= 0x03;
		} while (ecx_108 != 0x00);
	}
	Eq_86927 edi_231 = edi_25 ^ gs->dw0014;
	if (edi_231 != 0x00)
	{
		word32 edx_509;
		word32 ecx_508;
		__stack_chk_fail(out ecx_508, out edx_509);
		Eq_2 eax_261 = init();
		ebpOut = ebp_184;
		esiOut = esi_20;
		ediOut = edi_231;
		return eax_261;
	}
	else
	{
		ebpOut = ebp;
		esiOut = esi;
		ediOut = edi;
		return ebx_113;
	}
}

// 08095DC0: Register ptr32 init()
// Called from:
//      _itowa
ptr32 init()
{
	static_buf.u0 = 0x080CFA8C;
	return 0x080CFA8C;
}

// 08095E10: void __dlerror(Register (ptr32 Eq_9) gs)
void __dlerror(struct Eq_9 * gs)
{
	ui32 eax_20 = gs->dw0014;
	Eq_2 ebp_133;
	ui32 eax_28 = once;
	if (eax_28 != 0x00)
	{
		ebp_133 = static_buf;
		if (ebp_133 == 0x00)
		{
l08095F78:
			Mem136 = Mem101;
			ebp_133.u0 = 0x080CFA8C;
			goto l08095E6F;
		}
	}
	else
	{
		static_buf.u0 = 0x080CFA8C;
		once = eax_28 | 0x02;
		Mem102 = Mem64;
		ebp_133.u0 = 0x080CFA8C;
		if (0x080CFA8C == 0x00)
			goto l08095F78;
	}
l08095E6F:
	Eq_2 eax_138 = *((word32) ebp_133 + 16);
	if (*((word32) ebp_133 + 4) != 0x00)
	{
		bool v27_416 = eax_138 > 0x00;
		if (eax_138 != 0x00)
		{
			word32 ecx_319 = 0x0E;
			cu8 * edi_320 = &g_b80B9420;
			Eq_2 esi_321 = eax_138;
			while (ecx_319 != 0x00)
			{
				v27_416 = *esi_658 > *edi_659;
				esi_321 = (word32) esi_658 + 1;
				edi_320 = edi_659 + 1;
				--ecx_319;
				esi_658 = esi_321;
				edi_659 = edi_320;
				if (*esi_658 == *edi_659)
					break;
			}
			if ((int8) v27_416 - (*esi_658 < *edi_659) != 0x00)
			{
				word32 ecx_647;
				word32 edx_648;
				free(gs, dwLoc40, eax_138, out ecx_647, out edx_648);
			}
			((word32) ebp_133 + 16)->u0 = 0x00;
		}
	}
	else if (eax_138 != 0x00)
	{
		Eq_2 dwLoc40_439;
		Eq_2 edx_145 = *ebp_133.u0;
		if (edx_145 != 0x00)
		{
			strerror(gs, edx_145);
			word32 edx_652;
			dcgettext(out edx_652);
			Eq_2 edx_216 = 134955513;
			if (**((word64) ebp_133.u0 + 0x0C) != 0x00)
				edx_216.u0 = 0x080A221C;
			dwLoc40_439 = edx_216;
		}
		else
		{
			word32 edx_651;
			dcgettext(out edx_651);
			Eq_2 edx_169 = 134955513;
			if (**((word64) ebp_133.u0 + 0x0C) != 0x00)
				edx_169.u0 = 0x080A221C;
			dwLoc40_439 = edx_169;
		}
		Eq_2164 eax_245 = ___asprintf();
		struct Eq_132896 * esp_251 = fp - 44;
		bool v23_412 = eax_245 > ~0x00;
		if (eax_245 != ~0x00)
		{
			Eq_2 eax_258 = *((word64) ebp_133.u0 + 16);
			word32 ecx_259 = 0x0E;
			cu8 * edi_262 = &g_b80B9420;
			Eq_2 esi_263 = eax_258;
			while (ecx_259 != 0x00)
			{
				v23_412 = *esi_656 > *edi_657;
				esi_263 = (word32) esi_656 + 1;
				edi_262 = edi_657 + 1;
				--ecx_259;
				esi_656 = esi_263;
				edi_657 = edi_262;
				if (*esi_656 == *edi_657)
					break;
			}
			if ((int8) v23_412 - (eax_245 < ~0x00) != 0x00)
			{
				word32 ecx_654;
				word32 edx_655;
				free(gs, dwLoc40_439, eax_258, out ecx_654, out edx_655);
				esp_251 = fp - 0x28;
			}
			*((word64) ebp_133.u0 + 16) = esp_251->t0008;
		}
		*((word64) ebp_133.u0 + 4) = 0x01;
l08095EA5:
		if ((eax_20 ^ gs->dw0014) == 0x00)
			return;
		word32 ecx_649;
		word32 edx_650;
		Eq_2 eax_383 = __stack_chk_fail(out ecx_649, out edx_650);
		word32 esi_653;
		check_free.isra.0(eax_383, gs, out esi_653);
		return;
	}
	goto l08095EA5;
}

// 08096090: Register ptr32 check_free.isra.0(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out ptr32 esiOut)
// Called from:
//      fini
//      __dlerror
//      free_key_mem
ptr32 check_free.isra.0(Eq_2 eax, struct Eq_9 * gs, ptr32 & esiOut)
{
	Eq_2 edx_6 = *eax;
	bool v19_84 = edx_6 > 0x00;
	if (edx_6 != 0x00)
	{
		word32 ecx_21 = 0x0E;
		cu8 * edi_22 = &g_b80B9420;
		Eq_2 esi_23 = edx_6;
		while (ecx_21 != 0x00)
		{
			v19_84 = *esi_145 > *edi_146;
			esi_23 = (word32) esi_145 + 1;
			edi_22 = edi_146 + 1;
			--ecx_21;
			esi_145 = esi_23;
			edi_146 = edi_22;
			if (*esi_145 == *edi_146)
				break;
		}
		if ((int8) v19_84 - (*esi_145 < *edi_146) != 0x00)
		{
			word32 ecx_143;
			word32 edx_144;
			free(gs, dwLoc20, edx_6, out ecx_143, out edx_144);
			eax->u0 = 0x00;
			esiOut = edi;
			return esi;
		}
	}
	esiOut = esi;
	return ebx;
}

// 080960E0: void free_key_mem(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
void free_key_mem(struct Eq_9 * gs, word32 dwArg04)
{
	Eq_2 esi_22;
	check_free.isra.0(dwArg04 + 0x10, gs, out esi_22);
	word32 edx_85;
	word32 ecx_84;
	free(gs, dwLoc24, esi_22, out ecx_84, out edx_85);
}

// 08096130: Register word32 _dlerror_run(Register (ptr32 Eq_9) gs)
// Called from:
//      __dlinfo
//      __dlmopen
//      __dlopen
//      __dlclose
//      __dlsym
//      __dlvsym
word32 _dlerror_run(struct Eq_9 * gs)
{
	Eq_2 esi_135;
	ui32 eax_17 = once;
	if (eax_17 != 0x00)
	{
		esi_135 = static_buf;
		if (esi_135 == 0x00)
		{
l080961E4:
			word32 ebx_124;
			word32 ecx_303;
			word32 edi_307;
			word32 edx_304;
			word32 ebp_305;
			word32 esi_306;
			Eq_2 eax_122 = __libc_calloc(gs, 0x01, 0x14, out ecx_303, out edx_304, out ebx_124, out ebp_305, out esi_306, out edi_307);
			esi_135 = eax_122;
			if (eax_122 == 0x00)
				esi_135 = ebx_124 + 6796;
			goto l08096175;
		}
	}
	else
	{
		static_buf.u0 = 0x080CFA8C;
		once = eax_17 | 0x02;
		Mem91 = Mem53;
		esi_135.u0 = 0x080CFA8C;
		if (0x080CFA8C == 0x00)
			goto l080961E4;
	}
l08096175:
	ptr32 esp_166 = fp - 0x0C;
	Eq_2 eax_160 = *((word32) esi_135 + 16);
	if (eax_160 != 0x00)
	{
		if (*((word32) esi_135 + 8) != 0x00)
		{
			word32 ecx_301;
			word32 edx_302;
			free(gs, dwLoc20, eax_160, out ecx_301, out edx_302);
			esp_166 = fp - 0x08;
		}
		((word32) esi_135 + 16)->u0 = 0x00;
	}
	struct Eq_133016 * esp_186 = esp_166 - 0x0C;
	esp_186->dwFFFFFFFC = esp_186->dw0020;
	esp_186->dwFFFFFFF8 = esp_186->dw001C;
	esp_186->tFFFFFFF4 = (word32) esi_135 + 8;
	esp_186->tFFFFFFF0 = (word32) esi_135 + 16;
	esp_186->tFFFFFFEC = (word32) esi_135 + 0x0C;
	struct Eq_133046 * esi_212;
	word32 ecx_299;
	word32 edx_300;
	esi_212->t0000 = _dl_catch_error(gs, esp_186->tFFFFFFEC, esp_186->tFFFFFFF0, esp_186->tFFFFFFF4, out ecx_299, out edx_300, out esi_212);
	word32 eax_220 = esi_212->dw0010;
	esi_212->dw0004 = (uint32) (int8) (eax_220 == 0x00);
	return (word32) (int8) (eax_220 != 0x00);
}

// 080962C0: void __libc_register_dlfcn_hook()
// Called from:
//      __libc_dlopen_mode
//      __dlmopen
//      __dlopen
void __libc_register_dlfcn_hook()
{
	ptr32 * eax_17 = __libc_dlsym_private(gs);
	if (eax_17 != null)
		*eax_17 = 0x080CEF20;
}

// 08096300: void __dladdr(Stack Eq_2 dwArg04, Stack (ptr32 Eq_133148) dwArg08)
void __dladdr(Eq_2 dwArg04, struct Eq_133148 * dwArg08)
{
	_dl_addr(dwArg04, dwArg08, null, null);
}

// 08096320: void __dladdr1(Stack Eq_2 dwArg04, Stack (ptr32 Eq_133148) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack word32 dwArg10)
void __dladdr1(Eq_2 dwArg04, struct Eq_133148 * dwArg08, union Eq_2 * dwArg0C, word32 dwArg10)
{
	union Eq_2 * dwArg10_26;
	if (dwArg10 != 0x01)
	{
		dwArg10_26 = null;
		if (dwArg10 == 0x02)
			goto l08096346;
	}
	else
		dwArg10_26 = dwArg0C;
	dwArg0C = null;
l08096346:
	_dl_addr(dwArg04, dwArg08, dwArg0C, dwArg10_26);
}

// 08096360: void dlinfo_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_133172) dwArg04)
void dlinfo_doit(struct Eq_9 * gs, struct Eq_133172 * dwArg04)
{
	if (dwArg04->dw0008 > 0x0A)
	{
		struct Eq_125705 * edx_32;
		word32 ecx_100;
		word32 ebx_101;
		word32 ebp_102;
		word32 edi_103;
		_dl_signal_error(gs, 0x00, 0x080B9445, out ecx_100, out edx_32, out ebx_101, out ebp_102, out edi_103);
		word32 eax_44 = _dl_tls_get_addr_soft(gs, edx_32);
		*dwArg04->ptr000C = eax_44;
	}
	else
	{
		uint32 eax_61 = dwArg04->dw0008;
		<anonymous> * ecx_63 = g_a80B9460[eax_61 * 0x04] + 0x080CE000;
		ecx_63();
	}
}

// 08096490: void __dlinfo(Register (ptr32 Eq_9) gs)
void __dlinfo(struct Eq_9 * gs)
{
	ui32 ecx_9 = gs->dw0014;
	_dlerror_run(gs);
	if ((ecx_9 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_99;
	word32 edx_100;
	__stack_chk_fail(out ecx_99, out edx_100);
	Eq_2 esp_50 = <invalid>;
	dlmopen_doit(gs, *((word32) esp_50 + 4));
}

// 08096510: void dlmopen_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_133235) dwArg04)
// Called from:
//      __dlinfo
void dlmopen_doit(struct Eq_9 * gs, struct Eq_133235 * dwArg04)
{
	if (dwArg04->dw0000 != 0x00)
	{
		word32 ebx_145;
		word32 edx_144;
		word32 ecx_143;
		word32 ebp_146;
		word32 edi_147;
		_dl_signal_error(gs, 22, 0x080B948C, out ecx_143, out edx_144, out ebx_145, out ebp_146, out edi_147);
		__dlmopen(gs, 22);
	}
	else
	{
		Eq_2 edx_53 = dwArg04->t0004;
		ui32 ecx_54 = dwArg04->dw0008;
		if (edx_53 == 0x00)
			edx_53.u0 = 134955513;
		dwArg04->dw000C = _dl_open(gs, edx_53, ecx_54 | 0x80000000, dwArg04->dw0010, 0x00, __libc_argc, __libc_argv, environ);
	}
}

// 08096590: void __dlmopen(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dlmopen_doit
void __dlmopen(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 ecx_9 = gs->dw0014;
	if (_dlerror_run(gs) == 0x00)
	{
		__libc_register_dl_open_hook();
		__libc_register_dlfcn_hook();
	}
	if ((ecx_9 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_133;
	word32 edx_134;
	__stack_chk_fail(out ecx_133, out edx_134);
	strerror(gs, dwArg04);
}

// 08096620: void strerror(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __dlerror
//      __dlmopen
void strerror(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 esp_35 = <invalid>;
	struct Eq_133318 * ebx_30;
	word32 ebp_154;
	Eq_2 esi_34;
	if (strerror_r(gs, dwArg04, 0x00, 0x00, out ebx_30, out ebp_154, out esi_34) != 0x00)
		return;
	Eq_2 eax_46 = ebx_30->t1FF0;
	if (eax_46 == 0x00)
	{
		esp_35->u0 = 0x0400;
		word32 ebp_56;
		struct Eq_133341 * ebx_57;
		word32 Eq_9::* edi_59;
		word32 edx_156;
		word32 ecx_155;
		eax_46 = __libc_malloc(gs, *((word32) esp_35 - 4), *esp_35, out ecx_155, out edx_156, out ebx_57, out ebp_56, out esi_34, out edi_59);
		ebx_57->t1FF0 = eax_46;
		gs->*edi_59 = ebp_56;
		if (eax_46 == 0x00)
		{
			((word32) esp_35 + 8)->u0 = 0x05;
			*((word32) esp_35 + 4) = (char *) ebx_57 - 84834;
			*esp_35 = (char *) ebx_57 - 0x0001C4A4;
			word32 edx_160;
			dcgettext(out edx_160);
			return;
		}
	}
	((word32) esp_35 + 8)->u0 = 0x0400;
	*((word32) esp_35 + 4) = eax_46;
	*esp_35 = esi_34;
	word32 ebp_158;
	word32 esi_159;
	word32 ebx_157;
	strerror_r(gs, *esp_35, *((word32) esp_35 + 4), *((word32) esp_35 + 8), out ebx_157, out ebp_158, out esi_159);
}

// 080966C0: Register word32 strspn(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      __strtok_r
word32 strspn(Eq_2 dwArg04, Eq_2 dwArg08)
{
	Eq_2 eax_138 = dwArg08;
	do
	{
		Eq_133417 cl_140 = *eax_138;
		if (cl_140 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_140].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_140;
		Eq_133424 cl_148 = *((word32) eax_138 + 1);
		if (cl_148 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_148].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_148;
		Eq_133434 cl_154 = *((word32) eax_138 + 2);
		if (cl_154 == 0x00)
			break;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_154].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_154;
		Eq_133444 cl_160 = *((word32) eax_138 + 3);
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_160].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = cl_160;
		eax_138 = (word32) eax_138 + 4;
	} while (cl_160 != 0x00);
	struct Eq_133414 * eax_169 = dwArg04 - 0x04;
	do
	{
		++eax_169;
		byte cl_173 = eax_169->b0000;
		if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_173].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_173) == 0x00)
			return eax_169 - dwArg04;
		byte cl_180 = eax_169->b0001;
		if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_180].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_180) == 0x00)
			goto l08096768;
		byte cl_185 = eax_169->b0002;
		if (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_185].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_185) == 0x00)
			goto l08096767;
		byte cl_190 = eax_169->b0003;
	} while (((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x0100)[(uint32) cl_190].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] & cl_190) != 0x00);
	eax_169 = (struct Eq_133414 *) &eax_169->b0001;
l08096767:
	eax_169 = (struct Eq_133414 *) &eax_169->b0001;
l08096768:
	eax_169 = (struct Eq_133414 *) &eax_169->b0001;
	return eax_169 - dwArg04;
}

// 08096780: Register word32 __strsep_g(Stack (ptr32 Eq_2) dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      fillin_rpath
word32 __strsep_g(union Eq_2 * dwArg04, Eq_2 dwArg08)
{
	Eq_2 esi_12 = *dwArg04;
	if (esi_12 == 0x00)
		return;
	word32 eax_31 = strcspn(esi_12, dwArg08) + esi_12;
	if (*eax_31 == 0x00)
	{
		*dwArg04 = (union Eq_2 *) 0x00;
		return;
	}
	else
	{
		*eax_31 = 0x00;
		*dwArg04 = (union Eq_2 *) (eax_31 + 1);
		return;
	}
}

// 080967D0: Register (ptr32 Eq_226) __getdents64(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack ptr32 dwArg08, Stack word32 dwArg0C, Register out Eq_979 ecxOut)
// Called from:
//      readdir64
struct Eq_226 * __getdents64(struct Eq_9 * gs, word32 dwArg04, ptr32 dwArg08, word32 dwArg0C, union Eq_979 & ecxOut)
{
	struct Eq_226 * eax_12;
	gs->ptr0010();
	if (eax_12 > (struct Eq_226 *) ~0x0FFF)
	{
		word32 edx_47;
		struct Eq_226 * eax_20 = __syscall_error(eax_12, gs, out edx_47);
		ecxOut.u0 = <invalid>;
		return eax_20;
	}
	else
	{
		ecxOut.u0 = <invalid>;
		return eax_12;
	}
}

// 08096810: Register word32 getpid(Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_debug_vdprintf
word32 getpid(struct Eq_9 * gs)
{
	word32 eax_7;
	gs->ptr0010();
	return eax_7;
}

// 08096830: void __profil_counter(Stack word32 dwArg40)
void __profil_counter(word32 dwArg40)
{
	Eq_133559 eax_13 = dwArg40 - pc_offset;
	word64 edx_eax_18 = Mem11[0x080CFB3C<p32>:word32] *u64 ((eax_13 >>u 0x1F) + eax_13 >> 0x01);
	uint32 eax_21 = __shrd((word32) edx_eax_18, SLICE(edx_eax_18, word32, 32), 0x10);
	if (eax_21 < nsamples)
	{
		Eq_2 edx_24 = samples;
		*((word32) edx_24 + eax_21 * 0x02) = (word32) *((word32) edx_24 + eax_21 * 0x02) + 1;
	}
}

// 08096880: Register Eq_2 profil(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_start_profile
Eq_2 profil(struct Eq_9 * gs, Eq_2 dwArg04)
{
	struct Eq_133593 * esp_113 = fp - 0xAC;
	ui32 eax_17 = gs->dw0014;
	Eq_2 edx_21 = samples;
	if (dwArg04 != 0x00)
	{
		if (edx_21 == 0x00)
		{
l08096900:
			uint32 eax_119 = esp_113->dw00B4;
			samples = dwArg04;
			esp_113->dw0094 = 0x10000000;
			nsamples = eax_119 >> 0x01;
			pc_offset = esp_113->dw00B8;
			pc_scale = esp_113->dw00BC;
			esp_113->ptr0010 = 0x08096830;
			word32 * edx_123 = &esp_113->ptr0010;
			word32 * eax_134 = &esp_113->ptr0010 + 32;
			do
			{
				*eax_134 = ~0x00;
				eax_134 -= 0x04;
			} while (eax_134 != edx_123);
			struct Eq_133670 * esp_142 = esp_113 - 0x04;
			esp_142->ptrFFFFFFFC = 0x080CFAA0;
			esp_142->ptrFFFFFFF8 = eax_134;
			esp_142->dwFFFFFFF4 = 0x1B;
			Eq_2 esp_157 = <invalid>;
			if (__sigaction(gs, esp_142->dwFFFFFFF4) >= null)
			{
				*((word32) esp_157 + 28) = 0x00;
				*((word32) esp_157 + 32) = (int32) (1000000 /32 __profile_frequency());
				Eq_2 edx_185 = *((word32) esp_157 + 32);
				*((word32) esp_157 + 20) = *((word32) esp_157 + 28);
				*((word32) esp_157 + 24) = edx_185;
				*((word32) esp_157 + 0x0C) = 0x080CFB2C;
				*((word32) esp_157 + 8) = (word32) esp_157 + 20;
				*((word32) esp_157 + 4) = 0x02;
				__setitimer(gs, *((word32) esp_157 + 4), *((word32) esp_157 + 8), *((word32) esp_157 + 0x0C));
				goto l080969B8;
			}
			goto l08096A28;
		}
		if (__setitimer(gs, 0x02, &g_dw80CFB2C, 0x00) < 0x00)
			goto l08096A28;
		Eq_2 esp_107 = <invalid>;
		esp_113 = (word32) esp_107 + 20;
		if (__sigaction(gs, 0x1B) >= null)
			goto l08096900;
	}
	else
	{
		if (edx_21 == 0x00)
			goto l080969B8;
		if (__setitimer(gs, 0x02, &g_dw80CFB2C, 0x00) >= 0x00)
		{
			samples.u0 = 0x00;
			__sigaction(gs, 0x1B);
l080969B8:
			if ((eax_17 ^ gs->dw0014) == 0x00)
				return esi;
			word32 ecx_300;
			word32 edx_301;
			__stack_chk_fail(out ecx_300, out edx_301);
			__profile_frequency();
			return dwArg04;
		}
	}
l08096A28:
	goto l080969B8;
}

// 08096A40: Register word32 __profile_frequency()
// Called from:
//      _dl_start_profile
//      profil
word32 __profile_frequency()
{
	return _dl_clktck;
}

// 08096A60: Register Eq_2 _dl_fixup(Register Eq_2 eax, Register word32 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _dl_runtime_resolve
//      _dl_runtime_resolve_shstk
//      _dl_profile_fixup
Eq_2 _dl_fixup(Eq_2 eax, word32 edx, struct Eq_9 * gs)
{
	struct Eq_133769 * edx_26 = (word32) *((word32) *((word32) eax + 0x007C) + 4) + edx;
	uint32 edx_29 = edx_26->dw0004;
	word32 ebx_36 = *eax;
	word32 esi_22 = *((word32) *((word32) eax + 52) + 4);
	struct Eq_133792 * ecx_35 = (word32) *((word32) *((word32) eax + 56) + 4) + ((edx_29 >> 0x08) << 0x04);
	union Eq_2 * edi_38 = edx_26->dw0000 + ebx_36;
	if ((byte) edx_29 != 0x07)
	{
		Eq_126223 edx_55;
		word32 ecx_354;
		Eq_2 eax_54 = __assert_fail(out ecx_354, out edx_55);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		return _dl_profile_fixup(eax_54, ecx, edx_55, gs, stackArg8);
	}
	Eq_2 eax_172;
	word32 eax_182;
	if ((ecx_35->b000D & 0x03) == 0x00)
	{
		Eq_2 edx_114 = *((word32) eax + 232);
		if (edx_114 != 0x00)
		{
			edx_114 = (word32) *((word32) eax + 372) + (((word32) (*((word32) (*((word32) edx_114 + 4)) + (edx_29 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) edx_114 + 4) == null)
				edx_114.u0 = 0x00;
		}
		Eq_2 ebx_102 = 0x01;
		if (gs->t000C != 0x00)
		{
			gs->t001C.u0 = 0x01;
			ebx_102.u0 = 0x05;
		}
		word32 ecx_357;
		word32 edx_358;
		Eq_2 eax_134 = _dl_lookup_symbol_x(gs, esi_22 + ecx_35->dw0000, eax, fp - 0x20, *((word32) eax + 464), edx_114, 0x01, ebx_102, 0x00, out ecx_357, out edx_358);
		if (gs->t000C != 0x00)
		{
			Eq_2 v17_150 = gs->t001C;
			gs->t001C.u0 = 0x00;
			if (v17_150 == 0x02)
				gs->ptr0010();
		}
		eax_172.u0 = 0x00;
		if (ecx_35 == null)
		{
l08096B53:
			if (_dl_bind_not == 0x00)
				*edi_38 = (union Eq_2 *) eax_172;
			return eax_172;
		}
		if (ecx_35->w000E != ~0x0E && eax_134 != 0x00)
			eax_182 = (word32) *eax_134;
		else
			eax_182 = 0x00;
	}
	else
	{
		if (ecx_35->w000E == ~0x0E)
			ebx_36 = 0x00;
		eax_182 = ebx_36;
	}
	ui32 edx_192 = (word32) ecx_35->b000C;
	eax_172 = eax_182 + ecx_35->dw0004;
	if ((byte) (edx_192 & 0x0F) == 0x0A)
		eax_172();
	goto l08096B53;
}

// 08096C10: Register Eq_2 _dl_profile_fixup(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_126223 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08)
// Called from:
//      _dl_runtime_profile_shstk
//      _dl_runtime_profile
//      _dl_fixup
Eq_2 _dl_profile_fixup(Eq_2 eax, Eq_2 ecx, Eq_126223 edx, struct Eq_9 * gs, Eq_2 dwArg08)
{
	Eq_2 ebp_202;
	Eq_2 ecx_22 = *((word32) eax + 420);
	if (ecx_22 == 0x00)
	{
		*dwArg08 = ~0x00;
		ebp_202 = _dl_fixup(eax, edx_31, gs);
		return ebp_202;
	}
	struct Eq_133957 * edi_39 = (word32) ecx_22 + ((edx >> 0x03) + (edx >> 0x03) * 0x02) * 0x08;
	ebp_202 = edi_39->t0014;
	if (ebp_202 != 0x00)
	{
		ebp_202 = edi_39->t0000;
		goto l08096D42;
	}
	uint32 edx_155 = *((word32) edx + ((word32) (*((word32) (*((word32) eax + 0x007C)) + 4)) + 4));
	word32 esi_46 = *((word32) *((word32) eax + 52) + 4);
	struct Eq_133993 * ecx_154 = (word32) *((word32) *((word32) eax + 56) + 4) + ((edx_155 >> 0x08) << 0x04);
	if ((byte) edx_155 != 0x07)
	{
		word32 ecx_425;
		word32 edx_426;
		Eq_2 eax_73 = __assert_fail(out ecx_425, out edx_426);
		_dl_call_pltexit();
		return eax_73;
	}
	ui32 eax_209;
	if ((ecx_154->t000D & 0x03) == 0x00)
	{
		Eq_2 edx_106 = *((word32) eax + 232);
		if (edx_106 != 0x00)
		{
			edx_106 = (word32) *((word32) eax + 372) + (((word32) (*((word32) (*((word32) edx_106 + 4)) + (edx_155 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) edx_106 + 4) == null)
				edx_106 = ebp_202;
		}
		Eq_2 ebx_116 = 0x01;
		if (gs->t000C != 0x00)
		{
			gs->t001C.u0 = 0x01;
			ebx_116.u0 = 0x05;
		}
		Eq_2 eax_153 = _dl_lookup_symbol_x(gs, esi_46 + ecx_154->dw0000, eax, fp - 0x20, *((word32) eax + 464), edx_106, 0x01, ebx_116, 0x00, out ecx_154, out edx_155);
		if (gs->t000C != 0x00)
		{
			Eq_2 v19_169 = gs->t001C;
			gs->t001C.u0 = 0x00;
			if (v19_169 == 0x02)
				gs->ptr0010();
		}
		if (ecx_154 != null)
		{
			if (ecx_154->t000E != ~0x0E && eax_153 != 0x00)
				ebp_202 = *eax_153;
			ui32 eax_208 = (word32) ecx_154->b000C;
			ebp_202 = (word32) ebp_202 + ecx_154->dw0004;
			eax_209 = eax_208 & 0x0F;
			if ((byte) (eax_208 & 0x0F) != 0x0A)
				goto l08096D23;
			goto l08096DA0;
		}
	}
	else
	{
		if (ecx_154->t000E != ~0x0E)
			ebp_202 = *eax;
		ui32 eax_91 = (word32) ecx_154->b000C;
		ebp_202 = (word32) ebp_202 + ecx_154->dw0004;
		eax_209 = eax_91 & 0x0F;
		if ((byte) (eax_91 & 0x0F) == 0x0A)
		{
l08096DA0:
			Eq_2 eax_246;
			ebp_202();
			ebp_202 = eax_246;
			goto l08096D23;
		}
	}
l08096D23:
	if (_dl_bind_not == 0x00)
	{
		edi_39->t0000 = ebp_202;
		edi_39->t0014.u0 = 0x01;
	}
l08096D42:
	*dwArg08 = ~0x00;
	word32 ecx_427;
	word32 edx_428;
	_dl_mcount(gs, ecx, ebp_202, out ecx_427, out edx_428);
	return ebp_202;
}

// 08096E30: void _dl_call_pltexit()
// Called from:
//      _dl_runtime_profile
//      _dl_profile_fixup
void _dl_call_pltexit()
{
}

// 08096E40: Register Eq_2 add_to_global(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_134166) ebpOut, Register out (ptr32 Eq_134167) ediOut)
// Called from:
//      dl_open_worker
Eq_2 add_to_global(Eq_2 eax, struct Eq_9 * gs, struct Eq_134166 & ebpOut, struct Eq_134167 & ediOut)
{
	up32 eax_25;
	uint32 ebp_21 = *((word32) eax + 356);
	if (ebp_21 != 0x00)
	{
		union Eq_134176 * edx_28 = *((word32) eax + 352);
		eax_25 = 0x00;
		union Eq_134176 * edi_32 = (char *) edx_28 + ebp_21 * 0x04;
		do
		{
			eax_25 = (up32) ((bool) ((byte) ((word32) *((char *) *edx_28 + 408) & 0x10) < 0x01) + eax_25);
			edx_28 = (union Eq_134176 *) ((char *) edx_28 + 4);
		} while (edi_32 != edx_28);
	}
	else
		eax_25 = 0x00;
	word32 ebx_136;
	Eq_2 edi_51 = *((word32) eax + 24);
	struct Eq_134206 * ecx_58 = edi_51 *s 0x4C + 0x080CEA00;
	struct Eq_134211 * edi_59 = ecx_58->ptr0008;
	Eq_2 esi_140 = eax;
	struct Eq_134216 * edx_60 = ecx_58->ptr000C;
	uint32 edi_119 = edi_59->dw0004;
	if (edx_60 != null)
	{
		if (edx_60 >= eax_25 + edi_119)
			goto l08096EC1;
		uint32 eax_123 = edx_60 + eax_25 / 1674934284;
		Eq_2 ebp_135;
		word32 edx_452;
		word32 edi_453;
		word32 ecx_451;
		Eq_2 eax_134 = __libc_malloc(gs, dwLoc50, eax_123 << 0x03, out ecx_451, out edx_452, out ebx_136, out ebp_135, out esi_140, out edi_453);
		if (eax_134 != 0x00)
		{
			word32 ecx_459;
			word32 edx_460;
			memcpy(eax_134, ebp_135, edx_60 << 0x02, out ecx_459, out edx_460);
			ecx_58->ptr000C = eax_123 * 0x02;
			edi_59->t0000 = eax_134;
			if (gs->t000C != 0x00)
				_dl_wait_lookup_done();
			word32 ecx_461;
			word32 edx_462;
			free(gs, dwLoc50, ebp_135, out ecx_461, out edx_462);
			ebp_21 = (uint32) *((word32) esi_140 + 356);
			edi_119 = edx_60->ptr63D57808->dw0004;
l08096EC1:
			if (ebp_21 != 0x00)
			{
				uint32 ebp_251 = 0x00;
				struct Eq_134285 * ecx_252 = edi_51 *s 0x4C + 0x080CEA00;
				do
				{
					struct Eq_134300 * edx_258 = *((word32) *((word32) esi_140 + 352) + ebp_251 * 0x04);
					ui32 eax_259 = (word32) edx_258->b0198;
					if (((byte) eax_259 & 0x10) == 0x00)
					{
						edx_258->b0198 = (byte) (eax_259 | 0x10);
						*((char *) *ecx_252->ptr0008 + edi_119 * 0x04) = (struct Eq_134300 * (**)[]) edx_258;
						++edi_119;
						if ((g_b80CFF05 & 0x02) != 0x00)
						{
							word32 ecx_454;
							word32 edx_455;
							_dl_debug_printf(out ecx_454, out edx_455);
						}
					}
					++ebp_251;
				} while (*((word32) esi_140 + 356) > ebp_251);
			}
			*((char *) *((char *) &g_ptr80CEA08 + edi_51 * 0x4C) + 4) = edi_119;
			ebpOut = ebp;
			ediOut = edi;
			return 0x00;
		}
	}
	else
	{
		struct Eq_134216 * eax_68 = eax_25 + 0x08 + edi_119;
		ecx_58->ptr000C = eax_68;
		ui32 edi_83;
		word32 edx_450;
		word32 ecx_449;
		Eq_2 eax_79 = __libc_malloc(gs, dwLoc50, eax_68 << 0x02, out ecx_449, out edx_450, out ebx_136, out ebp_21, out esi_140, out edi_83);
		if (eax_79 != 0x00)
		{
			word32 edx_464;
			word32 ecx_463;
			edi_59->t0000 = memcpy(eax_79, edi_59->t0000, edi_83 << 0x02, out ecx_463, out edx_464);
			edi_119 = edi_59->dw0004;
			goto l08096EC1;
		}
		ecx_58->ptr000C = null;
	}
	struct Eq_134166 * ebp_166;
	struct Eq_134167 * edi_169;
	word32 edx_457;
	word32 ebx_458;
	word32 ecx_456;
	_dl_signal_error(gs, 0x0C, ebx_136 + ~0x00014AF1, out ecx_456, out edx_457, out ebx_458, out ebp_166, out edi_169);
	Eq_2 eax_177 = _dl_find_dso_for_object(0x0C);
	ebpOut = ebp_166;
	ediOut = edi_169;
	return eax_177;
}

// 08097060: Register Eq_2 _dl_find_dso_for_object(Stack Eq_2 dwArg04)
// Called from:
//      add_to_global
//      dl_open_worker
//      _dl_addr
//      _dl_sym
Eq_2 _dl_find_dso_for_object(Eq_2 dwArg04)
{
	if (_dl_nns != 0x00)
	{
		Eq_2 ebx_22 = g_t80CEA00;
		while (ebx_22 != 0x00)
		{
			if (*((word32) ebx_22 + 432) <= dwArg04 && (*((word32) ebx_22 + 436) > dwArg04 && ((*((word32) ebx_22 + 0x0199) & 0x40) != 0x00 || _dl_addr_inside_object(ebx_22, dwArg04) != 0x00)))
			{
				if (*((word32) ebx_22 + 24) != 0x00)
				{
					word32 ecx_164;
					word32 edx_165;
					__assert_fail(out ecx_164, out edx_165);
				}
				else
					return ebx_22;
			}
			ebx_22 = *((word32) ebx_22 + 0x0C);
		}
	}
	return 0x00;
}

// 08097100: Register word32 _dl_open(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack Eq_2 dwArg10, Stack word32 dwArg14, Stack (ptr32 word32) dwArg18, Stack Eq_2 dwArg1C)
// Called from:
//      do_dlopen
//      dlmopen_doit
//      _dl_find_dso_for_object
//      dlopen_doit
word32 _dl_open(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, word32 dwArg0C, Eq_2 dwArg10, word32 dwArg14, word32 * dwArg18, Eq_2 dwArg1C)
{
	struct Eq_134471 * esp_116;
	Eq_2 ebp_106;
	Eq_2 eax_162;
	struct Eq_134474 * esp_143;
	ptr32 ebx_108 = 0x080CE000;
	ptr32 esp_160 = fp - 0x4C;
	Eq_2 esi_19 = dwArg08;
	Eq_2 edi_172 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
l080972CF:
		eax_162 = ebx_108 + 4294882625;
		goto l08097231;
	}
	else
	{
		esp_160 = fp - 0x4C;
		if (dwArg10 != ~0x00)
		{
			eax_162.u0 = 0x080B9618;
			if (((word32) dwArg10 + 2 & ~0x02) == 0x00)
			{
				word32 edx_480;
				word32 ebx_481;
				word32 ecx_479;
				ebp_106 = _dl_catch_exception(gs, fp - 0x48, 0x08097480, fp - 0x3C, out ecx_479, out edx_480, out ebx_481);
				edi_172 = fp - 0x48;
				ebx_108 = _dl_unload_cache(gs);
				esp_116 = fp - 0x4C;
				if (dwLoc44 != 0x00)
				{
l08097240:
					Eq_2 esi_207;
					Eq_2 eax_202 = esp_116[7];
					if (eax_202 != 0x00)
					{
						esi_207 = esi_19 & 0x08000000;
						if (esi_207 == 0x00)
							goto l080972A0;
l08097250:
						struct Eq_134560 * esp_212 = esp_116 - 0x08;
						esp_212->tFFFFFFFC.u0 = 0x01;
						esp_212->tFFFFFFF8 = eax_202;
						_dl_close_worker(esi_207, gs, esp_212->tFFFFFFF8, esp_212->tFFFFFFFC, out ebx_108, out ebp_106, out edi_172);
						esp_116 = (struct Eq_134471 *) ((char *) &esp_212->tFFFFFFFC + 0x0C);
					}
					struct Eq_134474 * esp_237 = esp_116 - 0x08;
					esp_237->tFFFFFFFC = esp_237->t0028;
					esp_237->tFFFFFFF8.u0 = 0x00;
					esi_19 = *((word32) _dl_debug_initialize(esp_237->tFFFFFFF8, esp_237->tFFFFFFFC) + 0x0C);
					if (esi_19 == 0x00)
					{
						struct Eq_134647 * esp_288 = esp_116 - 0x04;
						esp_288->dwFFFFFFFC = 0x00;
						esp_288->tFFFFFFF8 = edi_172;
						esp_288->tFFFFFFF4 = ebp_106;
						word32 ebx_482;
						eax_202 = _dl_signal_exception(gs, esp_288->tFFFFFFF4, esp_288->tFFFFFFF8, out ebx_482);
						esp_116 = esp_288 - 0x10;
						esi_207 = esi_19;
l080972A0:
						g_b80CFEC4 = 0x01;
						goto l08097250;
					}
					esp_237->ptr0004 = ebx_108 + 4294883128;
					esp_237->dw0000 = 0x0267;
					esp_143 = esp_237;
					goto l080972BC;
				}
				if (*((word32) _dl_debug_initialize(0x00, dwArg10) + 0x0C) == 0x00)
					return 0x00;
				esp_143 = fp - 0x54;
l080972BC:
				struct Eq_134672 * esp_148 = esp_143 - 4;
				esp_148->ptr0000 = ebx_108 + ~0x00014AD6;
				esp_148->ptrFFFFFFFC = ebx_108 + 4294882880;
				word32 edx_484;
				word32 ecx_483;
				__assert_fail(out ecx_483, out edx_484);
				Eq_2 esp_155 = <invalid>;
				esp_160 = (word32) esp_155 - 4;
				goto l080972CF;
			}
		}
		else
		{
			esp_160 = fp - 0x4C;
			eax_162.u0 = 134977004;
		}
l08097231:
		struct Eq_134492 * esp_166 = esp_160 - 4;
		esp_166->t0000 = eax_162;
		esp_166->dwFFFFFFFC = 0x00;
		esp_166->tFFFFFFF8 = edi_172;
		esp_166->tFFFFFFF4.u0 = 22;
		word32 edx_478;
		word32 ecx_477;
		_dl_signal_error(gs, esp_166->tFFFFFFF4, esp_166->t0000, out ecx_477, out edx_478, out ebx_108, out ebp_106, out edi_172);
		esp_116 = esp_166 - 0x10;
		goto l08097240;
	}
}

// 080972F0: void _dl_show_scope(Stack Eq_2 dwArg04, Stack ui32 dwArg08)
// Called from:
//      dl_open_worker
void _dl_show_scope(Eq_2 dwArg04, ui32 dwArg08)
{
	if (**((word32) dwArg04 + 4) == 0x00)
		**(union Eq_2 **) 135060900 != 0x00;
	word32 edx_299;
	word32 ecx_298;
	_dl_debug_printf(out ecx_298, out edx_299);
	Eq_2 eax_57 = *((word32) dwArg04 + 464);
	if (eax_57 != 0x00)
	{
		int32 ebx_113 = dwArg08 * 0x04;
		if (*((word32) eax_57 + dwArg08 * 0x04) != 0x00)
		{
			do
			{
				word32 ecx_306;
				word32 edx_307;
				_dl_debug_printf(out ecx_306, out edx_307);
				Eq_134736 edx_114 = *((word32) *((word32) dwArg04 + 464) + ebx_113);
				if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&edx_114.a0000[1].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] != 0x00)
				{
					uint32 edi_128 = 0x00;
					do
					{
						if ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&edx_114.a0000[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000[edi_128].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000[1].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] == 0x00)
							**(union Eq_2 **) 135060900 != 0x00;
						word32 edx_303;
						_dl_debug_printf_c(out edx_303);
						++edi_128;
						edx_114 = (Eq_134736) *((word32) *((word32) dwArg04 + 464) + ebx_113);
					} while ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&edx_114.a0000[1].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] > edi_128);
				}
				word32 edx_302;
				_dl_debug_printf_c(out edx_302);
				ebx_113 += 0x04;
			} while (*((word32) *((word32) dwArg04 + 464) + ebx_113) != 0x00);
		}
	}
	else
	{
		word32 ecx_300;
		word32 edx_301;
		_dl_debug_printf(out ecx_300, out edx_301);
	}
	word32 ecx_304;
	word32 edx_305;
	_dl_debug_printf(out ecx_304, out edx_305);
}

// 08097480: void dl_open_worker(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_134814) dwArg04)
void dl_open_worker(struct Eq_9 * gs, struct Eq_134814 * dwArg04)
{
	Eq_2 edi_139;
	Eq_2 esi_102;
	Eq_2 ebx_23 = dwArg04->t0000;
	ui32 eax_24 = dwArg04->dw0004;
	word32 ecx_1416;
	word32 edx_1417;
	Eq_2 eax_30 = strchr(ebx_23, 0x24, out ecx_1416, out edx_1417);
	if (eax_30 == 0x00)
	{
		edi_139 = eax_30;
		esi_102 = dwArg04->t0010;
		if (esi_102 != ~0x01)
		{
			word32 ecx_1418;
			word32 edx_1419;
			if (strchr(ebx_23, 0x2F, out ecx_1418, out edx_1419) != 0x00)
				goto l080974EC;
		}
	}
	Eq_2 esi_70 = g_t80CEA00;
	Eq_2 eax_75 = _dl_find_dso_for_object(dwArg04->t0008);
	edi_139 = eax_75;
	if (eax_75 == 0x00)
		edi_139 = esi_70;
	esi_102 = dwArg04->t0010;
	if (esi_102 == ~0x01)
	{
		esi_102 = *((word32) edi_139 + 24);
		dwArg04->t0010 = esi_102;
	}
l080974EC:
	ui32 esi_1176;
	Eq_2 ecx_1138;
	ptr32 esp_1023;
	Eq_2 ebx_1207;
	Eq_2 eax_1150;
	Eq_2 esp_1051;
	_dl_debug_initialize(0x00, esi_102);
	word32 ebx_1420;
	struct Eq_134875 * ebp_1016;
	Eq_2 eax_145 = _dl_map_object(edi_139, gs, edi_139, ebx_23, 0x02, eax_24 | 0x10000000, dwArg04->t0010, out ebx_1420, out ebp_1016);
	*((word32) ebp_1016->t0008 + 0x0C) = eax_145;
	Eq_2 edi_1008 = eax_145;
	if (eax_145 == 0x00)
	{
		if ((ebp_1016->tFFFFFFD8 & 0x04) != 0x00)
			return;
		word32 ecx_1421;
		word32 edx_1422;
		__assert_fail(out ecx_1421, out edx_1422);
		Eq_2 esp_182 = <invalid>;
		esp_1023 = (word32) esp_182 - 4;
l08097900:
		ebx_1207 = ebp_1016->tFFFFFFC4;
		edi_1008 = (word64) edi_1008.u0 + 1;
		ecx_1138 = ebp_1016->tFFFFFFCC;
		if (ebx_1207 <= edi_1008)
		{
l08097918:
			edi_1008 = ecx_1138;
			if (ebp_1016->bFFFFFFC3 != 0x00)
			{
				Eq_125016 v17_813 = _dl_tls_generation.dw0000 + 0x01;
				_dl_tls_generation.dw0000 = (up32) v17_813;
				if (v17_813 == 0x00)
				{
					struct Eq_135091 * esp_822 = esp_1023 - 0x08;
					esp_822->dwFFFFFFFC = (word32) ebp_1016->tFFFFFFD4 - 84240;
					esp_822->tFFFFFFF8.u0 = 0x02;
					_dl_dprintf();
					esp_822->tFFFFFFF8.u0 = 0x7F;
					_exit(gs, esp_822->tFFFFFFF8);
				}
			}
			Eq_2 esi_1003 = ebp_1016->tFFFFFFBC;
			if (ebx_1207 > esi_1003)
			{
				Eq_2 edx_1004 = ecx_1138;
				do
				{
					Eq_2 edi_970 = *((word32) *((word32) edx_1004 + 352) + esi_1003 * 0x04);
					if ((*((word32) edi_970 + 408) & 0x0408) == 0x0400 && *((word32) edi_970 + 568) != 0x00)
					{
						ebp_1016->tFFFFFFE4 = edx_1004;
						*((word32) edi_970 + 0x0199) &= ~0x04;
						struct Eq_135230 * esp_981 = esp_1023 - 0x0C;
						esp_981->tFFFFFFFC = edi_970;
						_dl_init_static_tls();
						edx_1004 = ebp_1016->tFFFFFFE4;
						if ((*((word32) edi_970 + 0x0199) & 0x04) != 0x00)
						{
							ecx_1138 = ebp_1016->tFFFFFFD4;
							esp_981->ptr0008 = (word32) ecx_1138 - 84184;
							esp_981->dw0004 = 0x01ED;
							esp_981->ptr0000 = (word32) ecx_1138 - 84695;
							esp_981->tFFFFFFFC = (word32) ecx_1138 - 84562;
							Eq_2 esp_1152 = <invalid>;
							word32 edx_1424;
							word32 ecx_1423;
							eax_1150 = __assert_fail(out ecx_1423, out edx_1424);
							esp_1023 = (word32) esp_1152 - 4;
							goto l080979C8;
						}
					}
					esi_1003 = (word32) esi_1003 + 1;
				} while (*((word32) edx_1004 + 356) > esi_1003);
				edi_1008 = edx_1004;
			}
			if (ebp_1016->tFFFFFFB4 == 0x00)
			{
l08097855:
				struct Eq_135610 * esp_1028 = esp_1023 - 4;
				esp_1028->dw0000 = (word32) *((word32) ebp_1016->t0008 + 28);
				esp_1028->dwFFFFFFFC = (word32) *((word32) ebp_1016->t0008 + 24);
				esp_1028->dwFFFFFFF8 = (word32) *((word32) ebp_1016->t0008 + 20);
				esp_1028->tFFFFFFF4 = edi_1008;
				_dl_init(esp_1028->tFFFFFFF4, esp_1028->dwFFFFFFF8, esp_1028->dwFFFFFFFC, esp_1028->dw0000);
				esp_1051 = &esp_1028->dw0000 + 1;
				if ((ebp_1016->tFFFFFFD8 & 0x0100) != 0x00)
				{
					esp_1051.u0 = <invalid>;
					if (add_to_global(edi_1008, gs, out ebp_1016, out edi_1008) != 0x00)
						return;
				}
				*((word32) ebp_1016->tFFFFFFD4 + 0x0CD4) = 0x01;
				if ((*ebp_1016->ptrFFFFFFDC & 0x40) != 0x00)
				{
l08097BD0:
					Eq_2 eax_1097 = ebp_1016->tFFFFFFD4;
					struct Eq_135714 * esp_1103 = esp_1051 - 4;
					esp_1103->dw0000 = (word32) *((word64) edi_1008.u0 + 404);
					esp_1103->dwFFFFFFFC = (word32) *((word64) edi_1008.u0 + 24);
					esp_1103->dwFFFFFFF8 = (word32) *((word64) edi_1008.u0 + 4);
					esp_1103->dwFFFFFFF4 = (word32) eax_1097 - 84352;
					word32 ecx_1427;
					word32 edx_1428;
					_dl_debug_printf(out ecx_1427, out edx_1428);
				}
				return;
			}
l08097A08:
			goto l08097855;
		}
		goto l08097771;
	}
	if ((ebp_1016->tFFFFFFD8 & 0x1000) != 0x00)
		*((word32) eax_145 + 520) |= 0x08;
	if ((ebp_1016->tFFFFFFD8 & 0x40000000) != 0x00)
		return;
	Eq_2 esp_320;
	word32 edx_202 = *((word32) eax_145 + 352);
	*((word32) eax_145 + 404) = (word32) *((word32) eax_145 + 404) + 1;
	if (edx_202 == 0x00)
	{
		uint32 ebx_233;
		Eq_2 esp_238 = <invalid>;
		for (ebx_233 = _dl_map_object_deps(gs, 0x00, 0x00, out ebp_1016, out edi_1008); ebx_233 < *((word32) edi_1008 + 356); ++ebx_233)
		{
			Eq_2 eax_254 = *((word32) *((word32) *((word32) edi_1008 + 352) + ebx_233 * 0x04) + 20);
			if (*((word32) eax_254 + 372) == 0x00)
			{
				*((word32) esp_238 + 24) = 0x00;
				((word32) esp_238 + 20)->u0 = 0x00;
				*((word32) esp_238 + 16) = eax_254;
				_dl_check_map_versions(gs, *((word32) esp_238 + 16));
				++ebx_233;
				if (*((word32) edi_1008 + 356) <= ebx_233)
					break;
				continue;
			}
		}
		*((word32) esp_238 + 20) = *((word32) ebp_1016->t0008 + 16);
		((word32) esp_238 + 16)->u0 = 0x00;
		Eq_2 eax_296 = _dl_debug_initialize(*((word32) esp_238 + 16), *((word32) esp_238 + 20));
		((word32) eax_296 + 0x0C)->u0 = 0x00;
		ebp_1016->tFFFFFFD0 = eax_296;
		_dl_debug_state();
		*((word32) esp_238 + 16) = edi_1008;
		_dl_cet_open_check(gs, *((word32) esp_238 + 16));
		ebp_1016->ptrFFFFFFDC = &_dl_debug_mask;
		Eq_2 eax_323 = _dl_debug_mask;
		ebp_1016->tFFFFFFE4 = eax_323;
		esp_320 = (word32) esp_238 + 32;
		if ((SLICE(eax_323, byte, 8) & 0x02) == 0x00)
		{
l0809761D:
			Eq_2 eax_332 = ebp_1016->tFFFFFFD8;
			Eq_2 ecx_336 = eax_332 & 0x08000000;
			if (_dl_lazy != 0x00)
				ecx_336 = eax_332 & 0x08000001;
			ebp_1016->tFFFFFFE4 = ecx_336;
			Eq_2 eax_344 = edi_1008;
			ui32 ecx_348 = 0x00;
			do
			{
				eax_344 = *((word32) eax_344 + 0x0C);
				ecx_348 = (ui32) ((bool) ((byte) ((word32) *((word32) *((word32) eax_344 + 20) + 408) & 0x04) < 0x01) + ecx_348);
			} while (eax_344 != 0x00);
			ebp_1016->tFFFFFFB8 = esp_320;
			ui32 eax_368 = ecx_348 * 0x04 + 0x0F;
			Eq_2 ecx_377 = esp_320 - (eax_368 & ~0x0FFF);
			while (esp_320 != ecx_377)
			{
				esp_320 -= 0x1000;
				*((word32) esp_320 + 0x0FFC) = *((word32) esp_320 + 0x0FFC);
			}
			int32 edx_393 = eax_368 & ~0x0F & 0x0FFF;
			if (edx_393 != 0x00)
			{
				esp_320 -= edx_393;
				(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_320 - 0x04)[edx_393 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_320 - 0x04)[edx_393 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
			}
			Eq_2 eax_410 = edi_1008;
			struct Eq_135353 * esi_414 = null;
			do
			{
				if ((*((word32) *((word32) eax_410 + 20) + 408) & 0x04) == 0x00)
				{
					*((word32) esp_320 + esi_414 * 0x04) = eax_410;
					++esi_414;
				}
				eax_410 = *((word32) eax_410 + 0x0C);
			} while (eax_410 != 0x00);
			struct Eq_135475 * esp_434 = esp_320 - 4;
			esp_434->t0000.u1 = 0x00;
			esp_434->ptrFFFFFFFC = null;
			esp_434->ptrFFFFFFF8 = esi_414;
			esp_434->tFFFFFFF4 = esp_320;
			_dl_sort_maps(esp_434->tFFFFFFF4, esp_434->ptrFFFFFFF8, esp_434->ptrFFFFFFFC, esp_434->t0000);
			ui32 eax_451 = esi_414 - 0x01;
			esp_1023 = (char *) &esp_434->t0000 + 4;
			if (esi_414 != null)
			{
				Eq_2 edx_469 = *((word32) esp_320 + eax_451 * 0x04);
				while (true)
				{
					struct Eq_135534 * esp_473 = esp_1023 - 4;
					esp_473->t0000.u0 = 0x00;
					esp_473->tFFFFFFFC = ebp_1016->tFFFFFFE4;
					esp_473->tFFFFFFF8 = *((word32) edx_469 + 464);
					esp_473->tFFFFFFF4 = edx_469;
					Eq_2 ebx_491[];
					ui32 esi_495;
					byte dl_1426;
					word32 ecx_1425;
					_dl_relocate_object(gs, esp_473->tFFFFFFF4, esp_473->tFFFFFFFC, esp_473->t0000, out ecx_1425, out dl_1426, out ebx_491, out ebp_1016, out esi_495, out edi_1008);
					Eq_2 esp_497 = <invalid>;
					esp_1023 = (word32) esp_497 + 16;
					if (esi_495 == ~0x00)
						break;
					edx_469 = ebx_491[esi_495];
				}
				ebx_1207 = *((word64) edi_1008.u0 + 356);
				ebp_1016->tFFFFFFB4.u0 = 0x01;
				ebp_1016->tFFFFFFBC = ebx_1207;
				if (ebx_1207 == 0x00)
					goto l08097A08;
			}
			else
			{
				ebx_1207 = *((word32) edi_1008 + 356);
				ebp_1016->tFFFFFFB4.u0 = 0x00;
				ebp_1016->tFFFFFFBC = ebx_1207;
				if (ebx_1207 == 0x00)
					goto l08097855;
			}
			ebp_1016->bFFFFFFC3 = 0x00;
			ecx_1138 = edi_1008;
			edi_1008.u0 = 0x00;
l08097771:
			do
			{
				Eq_2 eax_525 = *((word32) *((word32) ecx_1138 + 352) + edi_1008 * 0x04);
				ebp_1016->tFFFFFFE4 = eax_525;
				ui32 eax_528 = (word32) *((word32) eax_525 + 408);
				byte al_535 = (byte) eax_528;
				if ((byte) (eax_528 & 11) == 0x0A)
				{
					ui32 esi_552;
					Eq_2 edx_551;
					Eq_2 esi_545 = *((word32) ebp_1016->tFFFFFFE4 + 464);
					Eq_2 eax_546 = *esi_545;
					ebp_1016->tFFFFFFC8 = esi_545;
					if (eax_546 != 0x00)
					{
						Eq_2 edx_555 = (word32) ecx_1138 + 352;
						ebp_1016->tFFFFFFE0 = edx_555;
						if (eax_546 != edx_555)
						{
							ebp_1016->tFFFFFFCC = ecx_1138;
							ebp_1016->tFFFFFFC4 = ebx_1207;
							ui32 edx_560 = 0x02;
							Eq_2 ebx_566 = ebp_1016->tFFFFFFE0;
							do
							{
								esi_552 = edx_560 + 0x01;
								Eq_2 eax_571 = *((word32) esi_545 + esi_552 * 0x04);
								if (eax_571 == 0x00)
								{
									ecx_1138 = ebp_1016->tFFFFFFCC;
									edx_551 = edx_560 + 0x00;
									goto l080977DA;
								}
								edx_560 = esi_552;
							} while (eax_571 != ebx_566);
							goto l08097900;
						}
						goto l08097766;
					}
					edx_551.u0 = 0x01;
					esi_552 = 0x00;
l080977DA:
					Eq_2 eax_597 = *((word32) ebp_1016->tFFFFFFE4 + 0x01CC);
					if (eax_597 > edx_551)
					{
						ebp_1016->tFFFFFFE0 = esi_552 * 0x04;
						goto l080977F5;
					}
					Eq_2 ebx_601 = ebp_1016->tFFFFFFE4;
					ebp_1016->tFFFFFFC4 = (word32) ebx_601 + 444;
					if (eax_597 <= 0x03)
					{
						ebp_1016->tFFFFFFCC = (word32) ebx_601 + 444;
						ebp_1016->tFFFFFFB0.u0 = 0x04;
						if ((word32) ebx_601 + 444 != ebp_1016->tFFFFFFC8)
							goto l08097A60;
					}
					ebp_1016->tFFFFFFAC = ecx_1138;
					ebp_1016->tFFFFFFE0 = edx_551;
					ebp_1016->tFFFFFFB0 = eax_597 * 0x02;
					struct Eq_135757 * esp_614 = esp_1023 - 0x0C;
					esp_614->tFFFFFFFC = eax_597 << 0x03;
					word32 ebx_1431;
					word32 edx_1430;
					word32 ecx_1429;
					Eq_2 eax_633 = __libc_malloc(gs, esp_614->tFFFFFFF8, esp_614->tFFFFFFFC, out ecx_1429, out edx_1430, out ebx_1431, out ebp_1016, out esi_552, out edi_1008);
					edx_551 = ebp_1016->tFFFFFFE0;
					ecx_1138 = ebp_1016->tFFFFFFAC;
					ebp_1016->tFFFFFFCC = eax_633;
					if (eax_633 == 0x00)
					{
						Eq_2 ecx_651 = ebp_1016->tFFFFFFD4;
						esp_614->t0008 = (word32) ecx_651 - 84587;
						esp_614->dw0004 = 0x00;
						esp_614->dw0000 = (word32) ecx_651 - 106709;
						esp_614->tFFFFFFFC.u0 = 0x0C;
						word32 ebx_1437;
						word32 ecx_1435;
						word32 edx_1436;
						_dl_signal_error(gs, esp_614->tFFFFFFFC, esp_614->t0008, out ecx_1435, out edx_1436, out ebx_1437, out ebp_1016, out edi_1008);
						esp_1051 = &esp_614->tFFFFFFF8;
						goto l08097BD0;
					}
l08097A60:
					ebp_1016->tFFFFFFA8 = ecx_1138;
					ebp_1016->tFFFFFFAC = edx_551;
					Eq_2 eax_680 = esi_552 * 0x04;
					ebp_1016->tFFFFFFE0 = eax_680;
					struct Eq_135819 * esp_676 = esp_1023 - 0x04;
					esp_676->tFFFFFFFC = eax_680;
					esp_676->tFFFFFFF8 = ebp_1016->tFFFFFFC8;
					esp_676->tFFFFFFF4 = ebp_1016->tFFFFFFCC;
					word32 edx_1433;
					word32 ecx_1432;
					memcpy(esp_676->tFFFFFFF4, esp_676->tFFFFFFF8, esp_676->tFFFFFFFC, out ecx_1432, out edx_1433);
					Eq_2 ebx_704 = ebp_1016->tFFFFFFE4;
					Eq_2 ecx_705 = ebp_1016->tFFFFFFCC;
					edx_551 = ebp_1016->tFFFFFFAC;
					Eq_2 eax_708 = *((word32) ebx_704 + 464);
					ebp_1016->tFFFFFFC8 = ecx_705;
					*((word32) ebx_704 + 464) = ecx_705;
					ecx_1138 = ebp_1016->tFFFFFFA8;
					if (ebp_1016->tFFFFFFC4 != eax_708)
					{
						ebp_1016->tFFFFFFC4 = ecx_1138;
						ebp_1016->tFFFFFFCC = edx_551;
						esp_676->tFFFFFFF4 = eax_708;
						word32 ecx_1434;
						struct Eq_135899 * ebx_722;
						_dl_scope_free(gs, esp_676->tFFFFFFF4, out ecx_1434, out ebx_722, out esi_552, out edi_1008);
						ecx_1138 = ebp_1016->tFFFFFFC4;
						edx_551 = ebp_1016->tFFFFFFCC;
						ebp_1016->tFFFFFFC8 = ebx_722->t01D0;
					}
					*((word32) ebp_1016->tFFFFFFE4 + 0x01CC) = ebp_1016->tFFFFFFB0;
l080977F5:
					*((word32) ebp_1016->tFFFFFFC8 + edx_551 * 0x04) = 0x00;
					Mem757[Mem750[Mem750[ebp_1016 + -28:word32] + 464:word32] + Mem750[ebp_1016 + -32:word32]:word32] = ecx_1138 + 0x0160;
					Eq_2 eax_759 = *ebp_1016->ptrFFFFFFDC;
					ebp_1016->tFFFFFFE0 = eax_759;
					if ((SLICE(eax_759, byte, 8) & 0x02) == 0x00)
						goto l08097760;
					esi_1176 = esi_552;
					goto l08097828;
				}
				esi_1176 = 0x00;
				if ((al_535 & 0x08) == 0x00)
				{
					eax_1150 = ebp_1016->tFFFFFFE4;
					if (*((word32) eax_1150 + 568) != 0x00)
					{
l080979C8:
						ebp_1016->tFFFFFFE0 = ecx_1138;
						struct Eq_136023 * esp_1160 = esp_1023 - 0x0C;
						esp_1160->tFFFFFFFC = eax_1150;
						struct Eq_136029 * ebx_1172 = _dl_add_to_slotinfo(gs, esp_1160->tFFFFFFFC, out ebp_1016, out esi_1176, out edi_1008);
						ebp_1016->bFFFFFFC3 = 0x01;
						esp_1023 = (char *) &esp_1160->tFFFFFFFC + 16;
						ecx_1138 = ebp_1016->tFFFFFFE0;
						if ((ebx_1172->b0199 & 0x04) != 0x00)
						{
							Eq_2 eax_1188 = ebp_1016->tFFFFFFBC;
							if (*((word32) ecx_1138 + 356) == eax_1188)
								eax_1188 = edi_1008;
							ebp_1016->tFFFFFFBC = eax_1188;
						}
					}
				}
				Eq_2 eax_1198 = *ebp_1016->ptrFFFFFFDC;
				ebp_1016->tFFFFFFE0 = eax_1198;
				if ((SLICE(eax_1198, byte, 8) & 0x02) != 0x00)
				{
l08097828:
					ebp_1016->tFFFFFFE0 = ecx_1138;
					struct Eq_135377 * esp_769 = esp_1023 - 0x08;
					esp_769->dwFFFFFFFC = esi_1176;
					esp_769->tFFFFFFF8 = ebp_1016->tFFFFFFE4;
					_dl_show_scope(esp_769->tFFFFFFF8, esp_769->dwFFFFFFFC);
					esp_1023 = &esp_769->dwFFFFFFFC + 2;
					ecx_1138 = ebp_1016->tFFFFFFE0;
				}
l08097760:
				ebx_1207 = *((word32) ecx_1138 + 356);
l08097766:
				edi_1008 = (word32) edi_1008 + 1;
			} while (ebx_1207 > edi_1008);
			goto l08097918;
		}
	}
	else
	{
		if ((_dl_debug_mask & 0x40) != 0x00)
		{
			word32 ecx_1438;
			word32 edx_1439;
			_dl_debug_printf(out ecx_1438, out edx_1439);
		}
		Eq_2 esp_881 = fp - 88;
		if ((ebp_1016->tFFFFFFD8 & 0x0100) != 0x00 && (*((word32) eax_145 + 408) & 0x10) == 0x00)
		{
			add_to_global(eax_145, gs, out ebp_1016, out edi_1008);
			esp_881.u0 = <invalid>;
		}
		struct Eq_136066 * esp_892 = esp_881 - 0x08;
		esp_892->tFFFFFFFC = *((word32) ebp_1016->t0008 + 16);
		esp_892->tFFFFFFF8.u0 = 0x00;
		if (*((word32) _dl_debug_initialize(esp_892->tFFFFFFF8, esp_892->tFFFFFFFC) + 0x0C) == 0x00)
			return;
		Eq_2 ecx_911 = ebp_1016->tFFFFFFD4;
		esp_892->dw0004 = (word32) ecx_911 - 84184;
		esp_892->dw0000 = 0xFE;
		esp_892->tFFFFFFFC = (word32) ecx_911 - 84695;
		esp_892->tFFFFFFF8 = (word32) ecx_911 - 84304;
		word32 edx_1441;
		word32 ecx_1440;
		__assert_fail(out ecx_1440, out edx_1441);
		Eq_2 esp_925 = <invalid>;
		esp_320 = (word32) esp_925 - 4;
	}
	struct Eq_135137 * esp_936 = esp_320 - 0x08;
	esp_936->dwFFFFFFFC = 0x00;
	esp_936->tFFFFFFF8 = edi_1008;
	_dl_show_scope(esp_936->tFFFFFFF8, esp_936->dwFFFFFFFC);
	esp_320 = &esp_936->dwFFFFFFFC + 2;
	goto l0809761D;
}

// 08097C40: Register byte remove_slotinfo(Register Eq_2 eax, Register up32 ecx, Register Eq_2 edx, Stack Eq_2 bArg04)
// Called from:
//      remove_slotinfo
//      _dl_close_worker
byte remove_slotinfo(Eq_2 eax, up32 ecx, Eq_2 edx, Eq_2 bArg04)
{
	uint32 edx_23 = eax - ecx;
	ptr32 esp_25 = fp - 44;
	uint32 ecx_26 = *edx;
	if (edx_23 < ecx_26)
	{
		struct Eq_136160 * edx_30 = (word32) edx + edx_23 * 0x08;
		struct Eq_136164 * ecx_31 = edx_30->ptr000C;
		if (ecx_31 != null)
		{
			if (ecx_31->t0248 != eax)
			{
				word32 ecx_262;
				word32 edx_263;
				__assert_fail(out ecx_262, out edx_263);
				Eq_2 esp_50 = <invalid>;
				esp_25 = (word32) esp_50 - 4;
				goto l08097D46;
			}
			edx_30->ptr000C = null;
			edx_30->dw0008 = _dl_tls_generation.dw0000 + 0x01;
		}
		if (_dl_tls_max_dtv_idx != eax)
			return 0x01;
		goto l08097CDE;
	}
	else
	{
		Eq_2 edx_67 = *((word32) edx + 4);
		if (edx_67 != 0x00)
		{
			if ((byte) (uint32) remove_slotinfo(eax, ecx_26 + ecx, edx_67, (word32) (byte) dwArg04) != 0x00)
				return 0x01;
			eax = (word32) *edx + ecx;
l08097CDE:
			uint32 edx_134 = (word32) _dl_tls_static_nelem + 1;
			if (ecx != 0x00)
				edx_134 = 0x00;
			uint32 eax_144 = eax - ecx;
			do
			{
				if (eax_144 <= edx_134)
					return 0x00;
				--eax_144;
				Eq_2 ecx_152 = ecx - 0x01 + eax_144;
			} while (*((word32) edx + (eax_144 * 0x08 + 0x0C)) == 0x00);
			_dl_tls_max_dtv_idx = ecx_152;
			return 0x01;
		}
		if ((byte) dwArg04 == 0x00)
			goto l08097CDE;
l08097D46:
		struct Eq_136259 * esp_79 = esp_25 - 4;
		esp_79->ptr0000 = 0x080B99A4;
		esp_79->dwFFFFFFFC = 0x3B;
		esp_79->ptrFFFFFFF8 = 134977372;
		esp_79->ptrFFFFFFF4 = 0x080B9767;
		word32 ecx_269;
		word32 edx_270;
		__assert_fail(out ecx_269, out edx_270);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_2 stackArg8 = <invalid>;
		word32 edi_268;
		word32 ebp_267;
		word32 ebx_266;
		return (byte) (uint32) _dl_close_worker(edx, gs, dwArg04, stackArg8, out ebx_266, out ebp_267, out edi_268);
	}
}

// 08097D70: Register byte _dl_close_worker(Register Eq_2 esi, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 bArg08, Register out ptr32 ebxOut, Register out ptr32 ebpOut, Register out ptr32 ediOut)
// Called from:
//      _dl_open
//      remove_slotinfo
//      _dl_close
byte _dl_close_worker(Eq_2 esi, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 bArg08, ptr32 & ebxOut, ptr32 & ebpOut, ptr32 & ediOut)
{
	word32 eax_26 = *((word32) dwArg04 + 404);
	*((word32) dwArg04 + 404) = eax_26 - 0x01;
	struct Eq_136296 * ebp_1022 = fp - 4;
	Eq_2 esp_113 = fp - 0x8C;
	struct Eq_136303 * eax_2202 = eax_26 - 0x01;
	if (eax_26 == 0x01 && (byte) ((word32) (*((word32) dwArg04 + 408)) & 0x03) == 0x02)
	{
		if (dl_close_state.11755 == 0x00)
		{
			while (true)
			{
				struct Eq_138666 * eax_96 = ebp_1022->ptrFFFFFFCC;
				ebp_1022->dwFFFFFF8C = (word32) esp_113;
				eax_96->dw1B4C = 0x01;
				up32 eax_102 = ebp_1022->ptrFFFFFFA4->dw0004;
				ebp_1022->dwFFFFFFE4 = eax_102;
				Eq_2 edi_109 = esp_113 - (eax_102 + 0x0F & ~0x0FFF);
				Eq_2 ecx_110 = edi_109;
				while (esp_113 != edi_109)
				{
					esp_113 -= 0x1000;
					*((word32) esp_113 + 0x0FFC) = *((word32) esp_113 + 0x0FFC);
				}
				int32 edx_124 = eax_102 + 0x0F & ~0x0F & 0x0FFF;
				if (edx_124 != 0x00)
				{
					esp_113 -= edx_124;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_113 - 0x04)[edx_124 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_113 - 0x04)[edx_124 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_2 esp_148;
				Eq_2 edi_142 = esp_113;
				Eq_2 ebx_143 = esp_113 - (eax_102 + 0x0F & ~0x0FFF);
				ui32 edx_144 = eax_102 + 0x0F & ~0x0F;
				esp_148 = esp_113;
				esp_148 = esp_113;
				if (esp_113 != ebx_143)
				{
					do
					{
						esp_148 -= 0x1000;
						*((word32) esp_148 + 0x0FFC) = *((word32) esp_148 + 0x0FFC);
					} while (esp_148 != ebx_143);
				}
				if ((edx_144 & 0x0FFF) != 0x00)
				{
					esp_148 -= edx_144 & 0x0FFF;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[(edx_144 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[(edx_144 & 0x0FFF) / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				ui32 eax_178 = ebp_1022->dwFFFFFFE4;
				ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) esp_148;
				ui32 edx_182 = eax_178 * 0x04 + 0x0F;
				Eq_2 ebx_1501 = esp_148 - (edx_182 & ~0x0FFF);
				while (esp_148 != ebx_1501)
				{
					esp_148 -= 0x1000;
					*((word32) esp_148 + 0x0FFC) = *((word32) esp_148 + 0x0FFC);
				}
				int32 eax_195 = edx_182 & ~0x0F & 0x0FFF;
				if (eax_195 != 0x00)
				{
					esp_148 -= eax_195;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[eax_195 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_148 - 0x04)[eax_195 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
				}
				Eq_136448 eax_206 = (word32) esp_148 + 3;
				ebp_1022->dwFFFFFFC8 = eax_206 >> 0x02;
				ebp_1022->ptrFFFFFFDC = __align(eax_206, 4);
				if (ebp_1022->bFFFFFFA3 != 0x00)
				{
					struct Eq_136490 * eax_215 = ebp_1022[1];
					eax_215->dw0208 &= ~0x08;
				}
				ui32 edx_223 = 0x00;
				struct Eq_136481 * eax_224 = ebp_1022->ptrFFFFFFA4->ptr0000;
				if (eax_224 != null)
				{
					ecx_110 = ebp_1022->ptrFFFFFFDC;
					do
					{
						eax_224->dw0210 = edx_223;
						*((word32) ecx_110 + edx_223 * 0x04) = eax_224;
						eax_224 = eax_224->ptr000C;
						++edx_223;
					} while (eax_224 != null);
				}
				struct Eq_136502 * edi_1433;
				struct Eq_136503 * esp_1455;
				Eq_2 eax_1538;
				Eq_136505 edx_1548;
				word32 esp_1716;
				if (ebp_1022->dwFFFFFFE4 == edx_223)
				{
					struct Eq_136563 * esp_272 = esp_148 - 0x04;
					esp_272->tFFFFFFFC = ebp_1022->dwFFFFFFE4;
					esp_272->tFFFFFFF8.u0 = 0x00;
					esp_272->tFFFFFFF4 = esp_113;
					word32 edx_2787;
					word32 ecx_2786;
					memset(esp_272->tFFFFFFF4, esp_272->tFFFFFFF8, esp_272->tFFFFFFFC, out ecx_2786, out edx_2787);
					esp_272->tFFFFFFFC = ebp_1022->dwFFFFFFE4;
					esp_272->tFFFFFFF8.u0 = 0x00;
					esp_272->tFFFFFFF4 = ebp_1022->ptrFFFFFFD8;
					word32 edx_2789;
					word32 ecx_2788;
					memset(esp_272->tFFFFFFF4, esp_272->tFFFFFFF8, esp_272->tFFFFFFFC, out ecx_2788, out edx_2789);
					Eq_136625 esi_2241 = ~0x00;
					ptr32 esp_315 = (char *) &esp_272->tFFFFFFFC + 8;
l08097F90:
					esi_2241 = (word32) esi_2241 + 1;
					while (ebp_1022->dwFFFFFFE4 > esi_2241)
					{
						if (Mem324[Mem324[ebp_1022 + -40:word32] + esi_2241:byte] != 0x00)
							goto l08097F90;
						Eq_2 eax_330 = ebp_1022->ptrFFFFFFDC[esi_2241];
						ebp_1022->ptrFFFFFFE0 = (struct Eq_155439 *) eax_330;
						ui32 eax_332 = (word32) *((word32) eax_330 + 408);
						ebp_1022->bFFFFFFD4 = (byte) eax_332;
						if ((byte) (eax_332 & 0x03) != 0x02)
						{
l08097FC3:
							Eq_136733 eax_341 = ebp_1022->ptrFFFFFFD8;
							Mem344[edi_142 + esi_2241:byte] = 0x01;
							Mem345[eax_341 + esi_2241:byte] = 0x01;
							struct Eq_136743 * eax_346 = ebp_1022->ptrFFFFFFE0;
							eax_346->dw0210 = ~0x00;
							struct Eq_136751 * edx_348 = eax_346->ptr01F4;
							if (edx_348 != null)
							{
l08098068:
								struct Eq_136757 ** eax_429 = &edx_348->t0004;
								Eq_2 edx_431 = edx_348->t0004;
								if (edx_431 != 0x00)
								{
									Eq_138748 ecx_436 = ebp_1022->dwFFFFFFE4;
									do
									{
										Eq_138748 edx_439 = *((word32) edx_431 + 528);
										if (edx_439 != ~0x00)
										{
											if (edx_439 < 0x00 || ecx_436 <= edx_439)
											{
												edi_142 = ebp_1022->ptrFFFFFFCC;
												struct Eq_138797 * esp_478 = esp_315 - 4;
												esp_478->ptr0000 = (word32) edi_142 - 83532;
												esp_478->dwFFFFFFFC = 0xCF;
												esp_478->ptrFFFFFFF8 = (word32) edi_142 - 0x000148A4;
												esp_478->ptrFFFFFFF4 = (word32) edi_142 - 83856;
												word32 edx_2841;
												word32 ecx_2840;
												__assert_fail(out ecx_2840, out edx_2841);
												Eq_2 esp_490 = <invalid>;
												esp_315 = (word32) esp_490 - 4;
												goto l080980E0;
											}
											if (Mem438[edi_142 + edx_439:byte] == 0x00)
											{
												Mem451[edi_142 + edx_439:byte] = 0x01;
												Eq_136625 edx_454 = *((char *) *eax_429 + 528);
												if (edx_454 <= esi_2241)
													esi_2241 = edx_454 - 0x01;
											}
										}
										eax_429 = (struct Eq_136757 **) ((char *) eax_429 + 4);
										edx_431 = *eax_429;
									} while (edx_431 != 0x00);
								}
							}
							struct Eq_136766 * ecx_355 = ebp_1022->ptrFFFFFFE0->ptr01F8;
							if (ecx_355 != null && ecx_355->dw0000 != 0x00)
							{
								uint32 edx_363 = 0x00;
								do
								{
									struct Eq_136782 * ebx_369 = ecx_355->a0004[edx_363];
									Eq_136625 eax_370 = ebx_369->t0210;
									if (eax_370 != ~0x00)
									{
										if (eax_370 < 0x00 || ebp_1022->dwFFFFFFE4 <= eax_370)
										{
											edi_142 = ebp_1022->ptrFFFFFFCC;
											struct Eq_136906 * esp_408 = esp_315 - 4;
											esp_408->ptr0000 = (word32) edi_142 - 83532;
											esp_408->dwFFFFFFFC = 232;
											esp_408->ptrFFFFFFF8 = (word32) edi_142 - 0x000148A4;
											esp_408->ptrFFFFFFF4 = (word32) edi_142 - 83812;
											word32 ecx_2792;
											__assert_fail(out ecx_2792, out edx_348);
											Eq_2 esp_420 = <invalid>;
											esp_315 = (word32) esp_420 - 4;
											goto l08098068;
										}
										if (Mem368[edi_142 + eax_370:byte] == 0x00)
										{
											Mem382[edi_142 + eax_370:byte] = 0x01;
											Eq_136625 eax_383 = ebx_369->t0210;
											if (eax_383 <= esi_2241)
												esi_2241 = eax_383 - 0x01;
											ecx_355 = ebp_1022->ptrFFFFFFE0->ptr01F8;
										}
									}
									++edx_363;
								} while (edx_363 < ecx_355->dw0000);
							}
							goto l08097F90;
						}
l080980E0:
						struct Eq_136724 * eax_500 = ebp_1022->ptrFFFFFFE0;
						if (eax_500->dw0194 != 0x00 || (eax_500->b0208 & 0x08) != 0x00)
							goto l08097FC3;
						Eq_138765 eax_508 = eax_500->t024C;
						ebp_1022->bFFFFFFD4 = (byte) eax_508;
						if (eax_508 != 0x00 || Mem509[edi_142 + esi_2241:byte] != 0x00)
							goto l08097FC3;
						esi_2241 = (word32) esi_2241 + 1;
					}
					word32 edx_523 = ebp_1022->dwFFFFFFD0;
					word32 ebx_524 = ebp_1022->dwFFFFFFE4;
					struct Eq_136638 * esp_530 = esp_315 - 4;
					esp_530->t0000.u1 = 0x01;
					Eq_136645 eax_537 = (uint32) (int8) (edx_523 == 0x00);
					Mem548[esp_530 + -4:word32] = edi_142 + eax_537;
					esp_530->ptrFFFFFFF8 = ebx_524 - eax_537;
					esi = ebp_1022->ptrFFFFFFDC + ebp_1022->dwFFFFFF84 / 4;
					esp_530->tFFFFFFF4 = esi;
					_dl_sort_maps(esp_530->tFFFFFFF4, esp_530->ptrFFFFFFF8, esp_530->ptrFFFFFFFC, esp_530->t0000);
					word32 * esp_1030 = (char *) &esp_530->t0000 + 4;
					if (ebx_524 != 0x00)
					{
						esi = null[ebp_1022->dwFFFFFFC8];
						if (ebp_1022->dwFFFFFFD0 == *((word32) esi + 24))
						{
							ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) edi_142;
							ebp_1022->dwFFFFFFC8 = 0x00;
							ebp_1022->bFFFFFFD4 = 0x00;
							ebp_1022->bFFFFFFA2 = 0x00;
							ebp_1022->ptrFFFFFFE0 = (struct Eq_155439 *) (struct Eq_136863 *) ~0x00;
							ebp_1022->ptrFFFFFFBC = 0x080CFF04;
							struct Eq_106487 * edi_1013 = null;
							do
							{
								ui32 eax_586 = (word32) *((word32) esi + 408);
								byte al_624 = (byte) eax_586;
								byte dl_594 = (byte) (eax_586 & 0x03);
								if (Mem585[Mem585[ebp_1022 + -40:word32] + edi_1013:byte] != 0x00)
								{
									if (dl_594 != 0x02)
										goto l08098208;
									struct Eq_136946 * edx_787;
									if (*((word32) esi + 352) != 0x00)
									{
										struct Eq_136946 ** eax_800 = *((word32) esi + 464);
										ebp_1022->dwFFFFFFC0 = 0x00;
										edx_787 = (struct Eq_136946 *) *eax_800;
										ebp_1022->dwFFFFFFB8 = eax_800;
										ebx_1501.u0 = 0x01;
										if (edx_787 != null)
											goto l08098271;
										goto l080983B3;
									}
									word32 eax_752 = *((word32) esi + 500);
									ebp_1022->dwFFFFFFC0 = eax_752;
									if (eax_752 == 0x00)
									{
										struct Eq_136946 ** eax_793 = *((word32) esi + 464);
										edx_787 = (struct Eq_136946 *) *eax_793;
										ebp_1022->dwFFFFFFB8 = eax_793;
										ebx_1501.u0 = 0x01;
										if (edx_787 == null)
											goto l080983B3;
										goto l08098271;
									}
									ui32 edx_762;
									ui32 eax_763;
									struct Eq_138462 * ecx_757 = ebp_1022->dwFFFFFFC0;
									if (ecx_757->dw0004 != 0x00)
									{
										ui32 edx_764 = 0x01;
										while (true)
										{
											eax_763 = edx_764 + 0x01;
											if (ecx_757[eax_763 * 0x04 / 8] == 0x00)
												break;
											edx_764 = eax_763;
										}
										edx_762 = edx_764 * 0x04 + 0x08;
									}
									else
									{
										edx_762 = 0x08;
										eax_763 = 0x01;
									}
									*((word32) esi + 356) = eax_763;
									ui32 edx_783 = edx_762 + ebp_1022->dwFFFFFFC0;
									ebp_1022->dwFFFFFFC0 = (word32) esi + 352;
									struct Eq_136946 ** eax_785 = *((word32) esi + 464);
									*((word32) esi + 352) = edx_783;
									edx_787 = (struct Eq_136946 *) *eax_785;
									ebp_1022->dwFFFFFFB8 = eax_785;
									if (edx_787 != null)
									{
										ebx_1501.u0 = 0x02;
l08098271:
										word32 ecx_810 = ebp_1022->dwFFFFFFB8;
										ebp_1022->dwFFFFFFB4 = (word32) esi;
										ebp_1022->dwFFFFFFC4 = (word32) esi + 360;
										esi = ebp_1022->dwFFFFFFD0;
										ebp_1022->dwFFFFFFB0 = edx_787;
										struct Eq_136946 * edx_820 = ebp_1022->dwFFFFFFC4;
										ebp_1022->dwFFFFFFAC = edi_1013;
										ebp_1022->dwFFFFFFA8 = ecx_810 + 0x04;
										struct Eq_136946 * eax_817 = edx_787;
										struct Eq_137015 * ecx_818 = ecx_810 + 0x04;
										word32 edi_825 = 0x00;
										do
										{
											if (eax_817 != edx_820)
											{
												if (esi != eax_817->tFFFFFEB8)
												{
													edi_1433 = (struct Eq_136502 *) ebp_1022->ptrFFFFFFCC;
													struct Eq_138416 * esp_2144 = esp_1030 - 4;
													esp_2144->ptr0000 = (char *) edi_1433 - 83532;
													esp_2144->dwFFFFFFFC = 0x016D;
													esp_2144->ptrFFFFFFF8 = (char *) edi_1433 - 0x000148A4;
													esp_2144->ptrFFFFFFF4 = (char *) edi_1433 - 84015;
													Eq_2 esp_2156 = <invalid>;
													word32 ecx_2834;
													word32 edx_2835;
													eax_1538 = __assert_fail(out ecx_2834, out edx_2835);
													esp_1455 = (word32) esp_2156 - 4;
l08098BC9:
													ebp_1022->dwFFFFFFC8 = (uint32) eax_1538;
													ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) ebp_1022->bFFFFFFD4;
													goto l080984D4;
												}
												if (eax_817->dw00B0 != ~0x00)
												{
													++ecx_818;
													eax_817 = ecx_818->dwFFFFFFFC;
													edi_825 = 0x01;
													if (eax_817 != null)
														continue;
													break;
												}
											}
											++ecx_818;
											eax_817 = ecx_818->dwFFFFFFFC;
											ebx_1501 = (word64) ebx_1501.u0 + 1;
										} while (eax_817 != null);
										Eq_137053 al_866 = (byte) edi_825;
										struct Eq_137055 * edx_1004 = ebp_1022->dwFFFFFFB0;
										esi = ebp_1022->dwFFFFFFB4;
										ebp_1022->dwFFFFFFB0 = (word32) al_866;
										edi_1013 = ebp_1022->dwFFFFFFAC;
										if (al_866 != 0x00)
										{
											ebp_1022->dwFFFFFFAC = (word32) esi + 444;
											if (ebx_1501 <= 0x03)
											{
												ebp_1022->dwFFFFFFB4 = (word32) esi + 444;
												ebp_1022->dwFFFFFF9C = 0x04;
												if ((word32) esi + 444 != ebp_1022->dwFFFFFFB8)
													goto l08098310;
											}
											ui32 eax_890 = *((word32) esi + 0x01CC);
											ebp_1022->dwFFFFFF98 = edx_1004;
											ebp_1022->dwFFFFFF9C = eax_890;
											struct Eq_137092 * esp_898 = esp_1030 - 0x0C;
											esp_898->tFFFFFFFC = eax_890 << 0x02;
											word32 ecx_2793;
											word32 edx_2794;
											word32 ebx_2795;
											Eq_2 eax_916 = __libc_malloc(gs, esp_898->tFFFFFFF8, esp_898->tFFFFFFFC, out ecx_2793, out edx_2794, out ebx_2795, out ebp_1022, out esi, out edi_1013);
											edx_1004 = ebp_1022->dwFFFFFF98;
											ebp_1022->dwFFFFFFB4 = (word32) eax_916;
											if (eax_916 == 0x00)
											{
												struct Eq_137273 * edi_933 = ebp_1022->ptrFFFFFFCC;
												esp_898->t0008 = (char *) edi_933 - 84587;
												esp_898->dw0004 = 0x00;
												esp_898->ptr0000 = (char *) edi_933 - 83996;
												esp_898->tFFFFFFFC.u0 = 0x0C;
												word32 edx_2799;
												word32 ebx_2800;
												word32 ecx_2798;
												_dl_signal_error(gs, esp_898->tFFFFFFFC, esp_898->t0008, out ecx_2798, out edx_2799, out ebx_2800, out ebp_1022, out edi_1013);
												esp_1030 = (word32 *) &esp_898->tFFFFFFF8;
												goto l08098810;
											}
l08098310:
											ebp_1022->dwFFFFFF94 = edi_1013;
											word32 edi_962 = ebp_1022->dwFFFFFFB4;
											ebp_1022->dwFFFFFF98 = (word32) esi;
											ui32 ecx_1000 = 0x00;
											struct Eq_137151 * ebx_965 = ebp_1022->dwFFFFFFA8;
											do
											{
												ui32 esi_967 = ecx_1000 * 0x04;
												struct Eq_137055 ** eax_1003 = edi_962 + esi_967;
												if (edx_1004 != ebp_1022->dwFFFFFFC4 && edx_1004->dw00B0 != ~0x00)
												{
													struct Eq_137055 * edx_977 = ebp_1022->dwFFFFFFC0;
													if (edx_977 != null)
													{
														ebp_1022->dwFFFFFFC0 = 0x00;
														*eax_1003 = (struct Eq_137055 **) edx_977;
														++ecx_1000;
														eax_1003 = edi_962 + 0x04 + esi_967;
													}
													++ebx_965;
													edx_1004 = ebx_965->dwFFFFFFFC;
													if (edx_1004 != null)
														continue;
													break;
												}
												*eax_1003 = (struct Eq_137055 **) edx_1004;
												++ebx_965;
												++ecx_1000;
												eax_1003 = edi_962 + 0x04 + esi_967;
												edx_1004 = ebx_965->dwFFFFFFFC;
											} while (edx_1004 != null);
											esi = ebp_1022->dwFFFFFF98;
											edi_1013 = ebp_1022->dwFFFFFF94;
											*eax_1003 = (struct Eq_137055 **) null;
											*((word32) esi + 464) = ebp_1022->dwFFFFFFB4;
											Eq_2 eax_1019 = ebp_1022->dwFFFFFFB8;
											if (ebp_1022->dwFFFFFFAC != eax_1019)
											{
												struct Eq_137234 * esp_1032 = esp_1030 - 0x0C;
												esp_1032->tFFFFFFFC = eax_1019;
												word32 ebx_2797;
												word32 ecx_2796;
												Eq_2 eax_1041 = _dl_scope_free(gs, esp_1032->tFFFFFFFC, out ecx_2796, out ebx_2797, out esi, out edi_1013);
												byte bl_1059 = ebp_1022->bFFFFFFA2;
												esp_1030 = (word32 *) ((char *) &esp_1032->tFFFFFFFC + 16);
												if (eax_1041 != 0x00)
													bl_1059 = 0x00;
												ebp_1022->bFFFFFFA2 = bl_1059;
											}
											else
											{
l08098810:
												ebp_1022->bFFFFFFA2 = (byte) ebp_1022->dwFFFFFFB0;
											}
											*((word32) esi + 0x01CC) = ebp_1022->dwFFFFFF9C;
											goto l080983B3;
										}
										if (ebp_1022->dwFFFFFFC0 != 0x00)
											goto l0809875E;
									}
									else
									{
l0809875E:
										*((word32) esi + 352) = 0x00;
										*((word32) esi + 356) = 0x00;
									}
l080983B3:
									struct Eq_136978 * eax_1073 = *((word32) esi + 368);
									if (eax_1073 != null && eax_1073->dw0210 != ~0x00)
										*((word32) esi + 368) = 0x00;
									struct Eq_106487 * eax_1084 = ebp_1022->ptrFFFFFFE0;
									if (eax_1084 > edi_1013)
										eax_1084 = edi_1013;
									ebp_1022->ptrFFFFFFE0 = (struct Eq_155439 *) eax_1084;
									++edi_1013;
									if (ebp_1022->dwFFFFFFE4 == edi_1013)
										goto l080983E7;
									goto l08098214;
								}
								if (dl_594 != 0x02 || (*((word32) esi + 520) & 0x08) != 0x00)
								{
									struct Eq_138495 * edi_602 = ebp_1022->ptrFFFFFFCC;
									struct Eq_138499 * esp_606 = esp_1030 - 4;
									esp_606->ptr0000 = (char *) edi_602 - 83532;
									esp_606->dwFFFFFFFC = 0x010B;
									esp_606->ptrFFFFFFF8 = (char *) edi_602 - 0x000148A4;
									esp_606->ptrFFFFFFF4 = (char *) edi_602 - 83768;
									word32 edx_2837;
									word32 ecx_2836;
									__assert_fail(out ecx_2836, out edx_2837);
									Eq_2 esp_618 = <invalid>;
									esp_1030 = (word32) esp_618 - 4;
									break;
								}
								if ((al_624 & 0x08) != 0x00)
								{
									if ((ebp_1022->ptrFFFFFFBC->b0000 & 0x02) != 0x00)
									{
										struct Eq_138582 * eax_632 = ebp_1022->ptrFFFFFFCC;
										struct Eq_138586 * esp_633 = esp_1030 - 0x04;
										esp_633->dwFFFFFFFC = ebp_1022->dwFFFFFFD0;
										esp_633->tFFFFFFF8 = *((word32) esi + 4);
										esp_633->ptrFFFFFFF4 = (char *) eax_632 - 84041;
										word32 edx_2839;
										word32 ecx_2838;
										_dl_debug_printf(out ecx_2838, out edx_2839);
									}
									struct Eq_138612 * eax_656 = *((word32) esi + 0x0088);
									if (eax_656 != null)
									{
										uint32 eax_663 = *((word32) *((word32) esi + 144) + 4);
										word32 ecx_664 = Mem655[esi + 0x00:word32] + Mem655[eax_656 + 0x04:word32];
										if (eax_663 >> 0x02 != 0x00)
										{
											ebp_1022->bFFFFFFD4 = (byte) esi;
											word32 esi_671 = ecx_664 - 0x04 + (eax_663 >>u 0x02) * 0x04;
											while (true)
											{
												word32 ecx_682;
												(*esi_671)();
												Eq_138625 edx_684 = esi_671 - 0x04;
												if (ecx_664 == esi_671)
													break;
												esi_671 = edx_684;
											}
											esi = ebp_1022->bFFFFFFD4;
										}
									}
									struct Eq_138637 * edx_691 = *((word32) esi + 84);
									if (edx_691 != null)
									{
										word32 eax_696 = Mem690[esi + 0x00:word32] + Mem690[edx_691 + 0x04:word32];
										word32 ecx_710;
										eax_696();
									}
									eax_586 = (word32) *((word32) esi + 408);
								}
								*((word32) esi + 0x0199) |= 0x20;
								struct Eq_106487 * eax_726 = ebp_1022->ptrFFFFFFE0;
								ebp_1022->dwFFFFFFC8 = ebp_1022->dwFFFFFFC8 - ~0x00 - ((byte) (eax_586 & 0x10) < 0x01);
								ebp_1022->bFFFFFFD4 = 0x01;
								if (eax_726 > edi_1013)
									eax_726 = edi_1013;
								ebp_1022->ptrFFFFFFE0 = (struct Eq_155439 *) eax_726;
l08098208:
								++edi_1013;
								if (ebp_1022->dwFFFFFFE4 == edi_1013)
								{
l080983E7:
									Eq_137345 edi_1147 = ebp_1022->ptrFFFFFFD8;
									if (ebp_1022->bFFFFFFD4 == 0x00)
										goto l080986F0;
									struct Eq_137354 * esp_1150 = esp_1030 - 0x08;
									esp_1150->tFFFFFFFC = ebp_1022->dwFFFFFFD0;
									esp_1150->tFFFFFFF8.u0 = 0x00;
									Eq_2 eax_1157 = _dl_debug_initialize(esp_1150->tFFFFFFF8, esp_1150->tFFFFFFFC);
									*((word32) eax_1157 + 0x0C) = 0x02;
									ebp_1022->ptrFFFFFFBC = (struct Eq_155436 *) eax_1157;
									_dl_debug_state();
									esi = eax_1157;
									struct Eq_136503 * esp_1169 = (char *) &esp_1150->tFFFFFFFC + 0x0C;
									if (ebp_1022->dwFFFFFFC8 != 0x00)
									{
										Eq_2 eax_1180;
										struct Eq_137394 * eax_1174 = ebp_1022->ptrFFFFFFA4->ptr0008;
										Eq_2 ecx_1175 = eax_1174->t0004;
										ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) eax_1174;
										if (ecx_1175 != 0x00)
										{
											struct Eq_137891 * ebx_1183[] = eax_1174->ptr0000;
											if (((ebx_1183 - 0x04)[ecx_1175]->b0199 & 0x20) != 0x00)
											{
												eax_1180 = ecx_1175;
												do
												{
													--eax_1180;
													if (eax_1180 == 0x00)
														goto l080989FE;
												} while (((ebx_1183 - 0x04)[eax_1180]->b0199 & 0x20) != 0x00);
												esi = eax_1180;
											}
											else
												esi = ecx_1175;
											eax_1180 = esi;
											if (ecx_1175 != (word32) esi + ebp_1022->dwFFFFFFC8)
											{
												eax_1180.u0 = 0x00;
												Eq_2 ecx_1213 = 0x00;
												do
												{
													struct Eq_137891 * edx_1219 = ebx_1183[ecx_1213];
													if ((edx_1219->b0199 & 0x20) == 0x00)
													{
														if (eax_1180 != ecx_1213)
															ebx_1183[eax_1180] = edx_1219;
														eax_1180 = (word64) eax_1180.u0 + 1;
													}
													ecx_1213 = (word32) ecx_1213 + 1;
												} while (ecx_1213 != esi);
											}
										}
										else
											eax_1180.u0 = 0x00;
l080989FE:
										ebp_1022->ptrFFFFFFD8->t0004 = eax_1180;
									}
									if (gs->t000C != 0x00)
									{
										if (ebp_1022->dwFFFFFFC8 == 0x00 && ebp_1022->bFFFFFFA2 == 0x00)
										{
											Eq_2 eax_1285 = _dl_scope_free_list;
											if (eax_1285 == 0x00)
												goto l08098432;
											esi = *eax_1285;
											if (esi != 0x00)
												goto l08098A73;
										}
										else
										{
l08098A73:
											word32 ecx_1352;
											_dl_wait_lookup_done();
											esi = _dl_scope_free_list;
											if (esi != 0x00)
											{
												Eq_137498 eax_1358 = *esi;
												while (eax_1358 != 0x00)
												{
													Eq_137498 eax_1363 = eax_1358 - 0x01;
													*esi = eax_1363;
													struct Eq_137510 * esp_1365 = esp_1169 - 0x0C;
													esp_1365->tFFFFFFFC = *((word32) esi + (eax_1363 * 0x04 + 4));
													word32 edx_2802;
													word32 ecx_2801;
													free(gs, esp_1365->tFFFFFFF8, esp_1365->tFFFFFFFC, out ecx_2801, out edx_2802);
													eax_1358.u2 = *esi;
													esp_1169 = (struct Eq_136503 *) ((char *) &esp_1365->tFFFFFFFC + 20);
												}
											}
										}
									}
l08098432:
									ebp_1022->dwFFFFFFC0 = 0x00;
									Mem1417 = Mem1393;
									esp_1455 = esp_1169;
									if (ebp_1022->dwFFFFFFE4 <= ebp_1022->ptrFFFFFFE0)
									{
l08098B5E:
										goto l080986D0;
									}
									else
									{
										struct Eq_137438 * eax_1421 = ebp_1022->ptrFFFFFFE0;
										esi = ebp_1022->ptrFFFFFFDC;
										ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) 0x00;
										ebp_1022->dwFFFFFFC8 = 0x00;
										ebp_1022->dwFFFFFFC4 = 0x00;
										ebp_1022->ptrFFFFFFE0 = (word32) esi + eax_1421 * 0x04;
										ebp_1022->dwFFFFFFE4 = (word32) edi_1147 + ebp_1022->dwFFFFFFE4;
										edi_1433 = edi_1147 + eax_1421;
										goto l080984A8;
									}
								}
l08098214:
								esi = ebp_1022->ptrFFFFFFDC[edi_1013];
							} while (ebp_1022->dwFFFFFFD0 == *((word32) esi + 24));
						}
						struct Eq_136816 * edi_1111 = ebp_1022->ptrFFFFFFCC;
						struct Eq_136820 * esp_1126 = esp_1030 - 4;
						esp_1126->ptr0000 = (char *) edi_1111 - 83532;
						esp_1126->dwFFFFFFFC = 262;
						esp_1126->ptrFFFFFFF8 = (char *) edi_1111 - 0x000148A4;
						esp_1126->ptrFFFFFFF4 = (char *) edi_1111 - 84060;
						word32 ecx_2790;
						word32 edx_2791;
						__assert_fail(out ecx_2790, out edx_2791);
l08098B19:
						eax_2202 = (struct Eq_136303 *) ebp_1022->ptrFFFFFFCC;
						eax_2202->dw1B4C = 0x00;
l08097ED6:
						struct Eq_136376 * esp_2206 = ebp_1022 - 0x0C;
						ptr32 edi_2212 = esp_2206->ptr0008;
						ptr32 ebp_2214 = esp_2206->ptr000C;
						ebxOut = esp_2206->ptr0000;
						ebpOut = ebp_2214;
						ediOut = edi_2212;
						return (byte) eax_2202;
					}
				}
				else
				{
					word32 edi_249 = ebp_1022->ptrFFFFFFCC;
					struct Eq_136532 * esp_254 = esp_148 - 4;
					esp_254->dw0000 = edi_249 + ~0x0001464B;
					esp_254->dwFFFFFFFC = 0xA5;
					esp_254->dwFFFFFFF8 = edi_249 + ~0x000148A3;
					esp_254->dwFFFFFFF4 = edi_249 + 4294883221;
					word32 ecx_2784;
					word32 edx_2785;
					__assert_fail(out ecx_2784, out edx_2785);
					Eq_2 esp_266 = <invalid>;
					esp_1716 = (word32) esp_266 - 4;
					do
					{
						struct Eq_137782 * edi_1726 = ebp_1022->ptrFFFFFFCC;
						struct Eq_137786 * esp_1729 = esp_1716 - 4;
						esp_1729->ptr0000 = (char *) edi_1726 - 83532;
						esp_1729->dwFFFFFFFC = 0x02B2;
						esp_1729->ptrFFFFFFF8 = (char *) edi_1726 - 0x000148A4;
						esp_1729->ptrFFFFFFF4 = (char *) edi_1726 - 83943;
						word32 ecx_2806;
						word32 edx_2807;
						__assert_fail(out ecx_2806, out edx_2807);
						Eq_2 esp_1741 = <invalid>;
						esp_1716 = (word32) esp_1741 - 4;
						do
						{
							edi_1433 = (struct Eq_136502 *) ebp_1022->ptrFFFFFFCC;
							struct Eq_137746 * esp_1752 = esp_1716 - 4;
							esp_1752->ptr0000 = (char *) edi_1433 - 83532;
							esp_1752->dwFFFFFFFC = 0x02B1;
							esp_1752->ptrFFFFFFF8 = (char *) edi_1433 - 0x000148A4;
							esp_1752->ptrFFFFFFF4 = (char *) edi_1433 - 83962;
							word32 ecx_2805;
							__assert_fail(out ecx_2805, out edx_1548);
							Eq_2 esp_1764 = <invalid>;
							esp_1455 = (word32) esp_1764 - 4;
l08098C3E:
							Eq_138313 al_1782 = ebp_1022->bFFFFFFD4;
							*ecx_110.u0 = edx_1548;
							ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) al_1782;
l080984D4:
							if (ebp_1022->bFFFFFFA3 != 0x00)
							{
								if (ebp_1022->dwFFFFFFC0 != 0x00)
								{
									esp_1455->dwFFFFFFF0 = ebp_1022->dwFFFFFF88;
									word32 ecx_1611;
									fn00000000();
									ebx_1501 = ebp_1022->ptrFFFFFFCC;
								}
								struct Eq_137669 * eax_1618 = ebp_1022->ptrFFFFFFA4->ptr0028;
								if (eax_1618 != null)
								{
									struct Eq_137716 * ecx_1622 = ebp_1022->ptrFFFFFFA4;
									ui32 edx_1623 = ecx_1622->dw002C;
									if (edx_1623 != 0x00)
									{
										struct Eq_137669 * edx_1628 = eax_1618 + (edx_1623 << 0x04) / 16;
										do
										{
											ebx_1501 = eax_1618->dw0004;
											if (ebx_1501 != 0x00 && esi == eax_1618->dw000C)
											{
												eax_1618->dw0004 = 0x00;
												eax_1618->dw0000 = 0x00;
												--ecx_1622->dw0030;
											}
											++eax_1618;
										} while (eax_1618 != edx_1628);
									}
								}
							}
							struct Eq_137641 * esp_1689 = esp_1455 - 0x0C;
							esp_1689->tFFFFFFFC = esi;
							ebx_1501 = _dl_unmap(ebx_1501, gs, esp_1689->tFFFFFFFC);
							Eq_2 esp_1709 = <invalid>;
							ecx_110 = ebp_1022->dwFFFFFFD0;
							esp_1716 = (word32) esp_1709 + 16;
						} while (ecx_110 != 0x00);
						struct Eq_137776 * edx_1720 = *((word32) esi + 16);
					} while (edx_1720 == null);
					struct Eq_137817 * eax_1784 = *((word32) esi + 0x0C);
					struct Eq_137821 * ebx_1785 = ebp_1022->dwFFFFFF90;
					edx_1720->ptr000C = eax_1784;
					--ebx_1785->dw0004;
					if (eax_1784 != null)
						eax_1784->ptr0010 = edx_1720;
					*esp_1709 = *((word32) esi + 372);
					word32 edx_2809;
					word32 ecx_2808;
					free(gs, *((word32) esp_1709 - 4), *esp_1709, out ecx_2808, out edx_2809);
					Eq_2 eax_1812 = *((word32) esi + 428);
					ptr32 esp_1813 = (word32) esp_1709 + 20;
					if (eax_1812 != ~0x00)
					{
						*((word32) esp_1709 + 4) = eax_1812;
						word32 edx_2813;
						word32 ecx_2812;
						free(gs, *esp_1709, *((word32) esp_1709 + 4), out ecx_2812, out edx_2813);
						esp_1813 = (word32) esp_1709 + 24;
					}
					struct Eq_137895 * esp_1832 = esp_1813 - 0x0C;
					esp_1832->tFFFFFFFC = *((word32) esi + 504);
					word32 ecx_2810;
					word32 edx_2811;
					free(gs, esp_1832->tFFFFFFF8, esp_1832->tFFFFFFFC, out ecx_2810, out edx_2811);
					if ((_dl_debug_mask & 0x40) != 0x00)
					{
						struct Eq_137961 * eax_1856 = ebp_1022->ptrFFFFFFCC;
						esp_1832->dw0008 = (word32) *((word32) esi + 24);
						esp_1832->t0004 = *((word32) esi + 4);
						esp_1832->ptr0000 = (char *) eax_1856 - 83700;
						word32 edx_2815;
						word32 ecx_2814;
						_dl_debug_printf(out ecx_2814, out edx_2815);
					}
					struct Eq_137988 * esp_1878 = esp_1813 + 0x04;
					esp_1878->tFFFFFFF0 = *((word32) esi + 4);
					word32 ecx_2816;
					word32 edx_2817;
					free(gs, esp_1878->tFFFFFFEC, esp_1878->tFFFFFFF0, out ecx_2816, out edx_2817);
					Eq_2 eax_1897 = *((word32) esi + 28);
					ebp_1022->ptrFFFFFFDC = (Eq_137498 (*)[]) esi;
					ptr32 esp_1898 = (char *) &esp_1878->tFFFFFFF0 + 20;
					do
					{
						Eq_2 esi_1904 = *((word32) eax_1897 + 4);
						if (*((word32) eax_1897 + 8) == 0x00)
						{
							struct Eq_138040 * esp_1913 = esp_1898 - 0x0C;
							esp_1913->tFFFFFFFC = eax_1897;
							word32 edx_2819;
							word32 ecx_2818;
							free(gs, esp_1913->tFFFFFFF8, esp_1913->tFFFFFFFC, out ecx_2818, out edx_2819);
							esp_1898 = (char *) &esp_1913->tFFFFFFFC + 20;
							eax_1897 = esi_1904;
							if (esi_1904 == 0x00)
								break;
							continue;
						}
						eax_1897 = esi_1904;
					} while (esi_1904 != 0x00);
					esi = ebp_1022->ptrFFFFFFDC;
					struct Eq_138065 * esp_1937 = esp_1898 - 0x0C;
					esp_1937->tFFFFFFFC = *((word32) esi + 500);
					word32 edx_2821;
					word32 ecx_2820;
					free(gs, esp_1937->tFFFFFFF8, esp_1937->tFFFFFFFC, out ecx_2820, out edx_2821);
					Eq_2 eax_1952 = *((word32) esi + 464);
					ptr32 esp_1954 = (char *) &esp_1937->t0000 + 16;
					if (eax_1952 != (word32) esi + 444)
					{
						esp_1937->t0000 = eax_1952;
						word32 ecx_2822;
						word32 edx_2823;
						free(gs, esp_1937->tFFFFFFFC, esp_1937->t0000, out ecx_2822, out edx_2823);
						esp_1954 = (char *) &esp_1937->t0000 + 20;
					}
					if (*((word32) esi + 408) < 0x00)
					{
						struct Eq_138118 * esp_1977 = esp_1954 - 0x0C;
						esp_1977->tFFFFFFFC = *((word32) esi + 340);
						word32 edx_2825;
						word32 ecx_2824;
						free(gs, esp_1977->tFFFFFFF8, esp_1977->tFFFFFFFC, out ecx_2824, out edx_2825);
						esp_1954 = (char *) &esp_1977->tFFFFFFFC + 20;
					}
					Eq_2 eax_1997 = *((word32) esi + 412);
					if (eax_1997 != ~0x00)
					{
						struct Eq_138153 * esp_2001 = esp_1954 - 0x0C;
						esp_2001->tFFFFFFFC = eax_1997;
						word32 edx_2827;
						word32 ecx_2826;
						free(gs, esp_2001->tFFFFFFF8, esp_2001->tFFFFFFFC, out ecx_2826, out edx_2827);
						esp_1954 = (char *) &esp_2001->tFFFFFFFC + 20;
					}
					Eq_2 eax_2020 = *((word32) esi + 492);
					if (eax_2020 != ~0x00)
					{
						struct Eq_138245 * esp_2024 = esp_1954 - 0x0C;
						esp_2024->tFFFFFFFC = eax_2020;
						word32 edx_2833;
						word32 ecx_2832;
						free(gs, esp_2024->tFFFFFFF8, esp_2024->tFFFFFFFC, out ecx_2832, out edx_2833);
						esp_1954 = (char *) &esp_2024->tFFFFFFFC + 20;
					}
					struct Eq_138211 * esp_2042 = esp_1954 - 0x0C;
					esp_2042->tFFFFFFFC = esi;
					word32 ecx_2830;
					word32 edx_2831;
					free(gs, esp_2042->tFFFFFFF8, esp_2042->tFFFFFFFC, out ecx_2830, out edx_2831);
					ebp_1022->ptrFFFFFFE0 = (struct Eq_155439 *) ((char *) &ebp_1022->ptrFFFFFFE0->t0000 + 4);
					++edi_1433;
					esp_1455 = (struct Eq_136503 *) ((char *) &esp_2042->tFFFFFFFC + 20);
					if (ebp_1022->dwFFFFFFE4 != edi_1433)
					{
l080984A8:
						do
						{
							if (edi_1433->b0000 == 0x00)
							{
								esi = ebp_1022->ptrFFFFFFE0->t0000;
								ui32 ecx_1447 = (word32) *((word32) esi + 408);
								bcu8 cl_1511 = (byte) ecx_1447;
								ui24 ecx_24_8_1515 = SLICE(ecx_1447, word24, 8);
								if ((byte) (ecx_1447 & 0x03) != 0x02)
								{
									struct Eq_137595 * edi_1453 = ebp_1022->ptrFFFFFFCC;
									struct Eq_137599 * esp_1456 = esp_1455 - 4;
									esp_1456->ptr0000 = (char *) edi_1453 - 83532;
									esp_1456->dwFFFFFFFC = 0x0225;
									esp_1456->ptrFFFFFFF8 = (char *) edi_1453 - 0x000148A4;
									esp_1456->ptrFFFFFFF4 = (char *) edi_1453 - 83988;
									word32 edx_2804;
									word32 ecx_2803;
									__assert_fail(out ecx_2803, out edx_2804);
									goto l08098B5E;
								}
								ebx_1501 = *((word32) esi + 568);
								if (ebx_1501 == 0x00)
									goto l080984D4;
								if (_dl_tls_dtv_slotinfo_list != 0x00)
								{
									Eq_2 eax_1514 = *((word32) esi + 584);
									esp_1455->dwFFFFFFF0 = SEQ(ecx_24_8_1515, cl_1511 >> 0x03) & 0x01;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_2 stackArg4 = <invalid>;
									if ((byte) (uint32) remove_slotinfo(eax_1514, 0x00, edx, stackArg4) == 0x00)
										_dl_tls_max_dtv_idx = _dl_tls_static_nelem;
								}
								ebx_1501 = (word32) ebp_1022->bFFFFFFD4;
								eax_1538 = *((word32) esi + 0x0244);
								ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) (byte) ebx_1501;
								if (eax_1538 <= 0x00)
									goto l080984D4;
								ebx_1501 = ebp_1022->dwFFFFFFC4;
								edx_1548 = eax_1538 - *((word32) esi + 568);
								if (ebx_1501 == 0x00 || eax_1538 == ebx_1501)
								{
									if (ebp_1022->dwFFFFFFC8 == 0x00)
									{
l080989AF:
										ebp_1022->dwFFFFFFC8 = (uint32) eax_1538;
									}
									Eq_138349 al_1580 = ebp_1022->bFFFFFFD4;
									ebp_1022->dwFFFFFFC4 = (word32) edx_1548;
									ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) al_1580;
									goto l080984D4;
								}
								else
								{
									if (ebp_1022->dwFFFFFFC8 == edx_1548)
										goto l08098BC9;
									ecx_110.u0 = 0x080CFCA0;
									ebx_1501 = _dl_tls_static_used;
									if (ebx_1501 != ebp_1022->dwFFFFFFC8)
									{
										if (eax_1538 == ebx_1501)
											goto l08098C3E;
										ebx_1501 = (word32) ebp_1022->bFFFFFFD4;
										ebp_1022->ptrFFFFFFD8 = (struct Eq_155438 *) (byte) ebx_1501;
										if (eax_1538 > ebp_1022->dwFFFFFFC8)
										{
											ebp_1022->dwFFFFFFC8 = (uint32) eax_1538;
											ebp_1022->dwFFFFFFC4 = (word32) edx_1548;
										}
										goto l080984D4;
									}
									ebx_1501 = ebp_1022->dwFFFFFFC4;
									_dl_tls_static_used = ebx_1501;
									goto l080989AF;
								}
							}
							ebp_1022->ptrFFFFFFE0 = (struct Eq_155439 *) ((char *) &ebp_1022->ptrFFFFFFE0->t0000 + 4);
							++edi_1433;
						} while (ebp_1022->dwFFFFFFE4 != edi_1433);
					}
					Mem2110 = Mem2076;
					if (ebp_1022->ptrFFFFFFD8 != 0x00)
					{
						Eq_125016 v50_2115 = _dl_tls_generation.dw0000 + 0x01;
						_dl_tls_generation.dw0000 = (up32) v50_2115;
						if (v50_2115 == 0x00)
						{
							struct Eq_138368 * esp_2121 = esp_1455 - 0x08;
							esp_2121->ptrFFFFFFFC = (char *) ebp_1022->ptrFFFFFFCC - 83660;
							esp_2121->tFFFFFFF8.u0 = 0x02;
							_dl_dprintf();
							esp_2121->tFFFFFFF8.u0 = 0x7F;
							_exit(gs, esp_2121->tFFFFFFF8);
						}
						if (_dl_tls_static_used == ebp_1022->dwFFFFFFC8)
							_dl_tls_static_used = ebp_1022->dwFFFFFFC4;
					}
l080986D0:
					if (ebp_1022->ptrFFFFFFA4->ptr0000 == null && _dl_nns - 0x01 == ebp_1022->dwFFFFFFD0)
						_dl_nns = ebp_1022->dwFFFFFFD0;
					ebp_1022->ptrFFFFFFBC->dw000C = 0x00;
					_dl_debug_state();
				}
l080986F0:
				if (ebp_1022->ptrFFFFFFCC->dw1B4C != 0x02)
					goto l08098B19;
				esp_113 = ebp_1022->dwFFFFFF8C;
			}
		}
		dl_close_state.11755 = 0x02;
	}
	if ((_dl_debug_mask & 0x40) != 0x00)
	{
		word32 ecx_2782;
		word32 edx_2783;
		eax_2202 = (uint32) _dl_debug_printf(out ecx_2782, out edx_2783);
	}
	goto l08097ED6;
}

// 08098C60: void _dl_close(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      do_dlclose
//      dlclose_doit
void _dl_close(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Mem41 = Mem20;
	if ((*((word32) dwArg04 + 520) & 0x08) != 0x00)
		return;
	if (*((word32) dwArg04 + 404) == 0x00)
	{
		struct Eq_135353 * v15_75 = *((word32) dwArg04 + 4);
		word32 edx_223;
		word32 ebx_224;
		word32 ecx_222;
		word32 ebp_225;
		word32 edi_226;
		_dl_signal_error(gs, 0x00, 0x080B982E, out ecx_222, out edx_223, out ebx_224, out ebp_225, out edi_226);
		Eq_135478 bLoc10_164 = (byte) 0x080B982E;
		_dl_sort_maps(0x00, v15_75, null, bLoc10_164);
	}
	else
	{
		word32 ebx_110;
		word32 edi_221;
		word32 ebp_220;
		_dl_close_worker(dwArg04, gs, dwArg04, 0x00, out ebx_110, out ebp_220, out edi_221);
	}
}

// 08098D10: Register (ptr32 Eq_13623) _dl_sort_maps(Stack Eq_2 dwArg04, Stack (ptr32 Eq_135353) dwArg08, Stack (ptr32 (arr byte)) dwArg0C, Stack Eq_135478 bArg10)
// Called from:
//      dl_open_worker
//      _dl_close_worker
//      _dl_close
//      _dl_map_object_deps
struct Eq_13623 * _dl_sort_maps(Eq_2 dwArg04, struct Eq_135353 * dwArg08, byte (* dwArg0C)[], Eq_135478 bArg10)
{
	Eq_2 esp_19 = fp - 0x4C;
	if (dwArg08 > (struct Eq_135353 *) 0x01)
	{
		ui32 eax_30 = dwArg08 * 0x02 + 0x0F;
		Eq_2 esi_33 = fp - 0x4C - (eax_30 & ~0x0FFF);
		if (fp - 0x4C != esi_33)
		{
			do
			{
				esp_19 -= 0x1000;
				*((word32) esp_19 + 0x0FFC) = *((word32) esp_19 + 0x0FFC);
			} while (esp_19 != esi_33);
		}
		int32 ebx_49 = eax_30 & ~0x0F & 0x0FFF;
		if (ebx_49 != 0x00)
		{
			esp_19 -= ebx_49;
			(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_19 - 0x04)[ebx_49 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(esp_19 - 0x04)[ebx_49 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0];
		}
		struct Eq_138928 * esp_62 = esp_19 - 0x04;
		esp_62->tFFFFFFFC = dwArg08 * 0x02;
		esp_62->tFFFFFFF8.u0 = 0x00;
		esp_62->tFFFFFFF4 = esp_19;
		word32 edx_669;
		memset(esp_62->tFFFFFFF4, esp_62->tFFFFFFF8, esp_62->tFFFFFFFC, out ecx, out edx_669);
		struct Eq_135353 * dwLoc20_385 = null;
		word32 * eax_95 = dwArg04 - 0x04 + dwArg08 * 0x04;
		struct Eq_135353 * dwLoc28_386 = (struct Eq_135353 *) 0x01;
		while (true)
		{
l08098DB0:
			Eq_2 edx_267;
			struct Eq_139120 * eax_102 = (word32) esp_19 + dwLoc20_385 * 0x02;
			word16 si_106 = (word16) ((word32) eax_102->w0000 + 0x01);
			eax_102->w0000 = si_106;
			Eq_2 eax_110 = (word32) dwArg04 + dwLoc20_385 * 0x04;
			struct Eq_13623 * ebx_112 = *eax_110;
			if (bArg10 == 0x00 || ebx_112->ptr0014 == ebx_112 && ebx_112->dw0210 != ~0x00)
			{
				struct Eq_135353 * esi_123 = dwArg08 - 0x01;
				if (dwLoc20_385 < dwArg08 - 0x01)
				{
					word32 * edx_126 = eax_95;
					do
					{
						struct Eq_13623 * edi_129 = *edx_126;
						word32 * eax_130 = edi_129->ptr01F4;
						if (eax_130 != null)
						{
							do
							{
								ecx = *eax_130;
								if (ecx == null)
									goto l08098DFF;
								++eax_130;
							} while (ecx != ebx_112);
l08098E45:
							struct Eq_139080 * esp_204 = esp_19 - 0x04;
							uint32 edi_205 = esi_123 - dwLoc20_385;
							esp_204->tFFFFFFFC = edi_205 * 0x04;
							esp_204->tFFFFFFF8 = (word32) dwArg04 + 4 + dwLoc20_385 * 0x04;
							esp_204->tFFFFFFF4 = eax_110;
							word32 edx_671;
							memmove(esp_204->tFFFFFFF4, esp_204->tFFFFFFF8, esp_204->tFFFFFFFC, out edx_671);
							*edx_126 = ebx_112;
							if (dwArg0C != null)
							{
								word32 eax_236 = dwLoc20_385 + dwArg0C;
								byte bl_258 = *eax_236;
								*((word32) esp_19 - 8) = edi_205;
								Mem244[esp_19 + -0x0C:word32] = dwLoc28_386 + dwArg0C;
								*((word32) esp_19 - 16) = eax_236;
								word32 edx_672;
								memmove(*((word32) esp_19 - 16), *((word32) esp_19 - 0x0C), *((word32) esp_19 - 8), out edx_672);
								Mem259[dwArg0C + esi_123:byte] = bl_258;
							}
							edx_267 = (word32) esp_19 + dwLoc28_386 * 0x02;
							if ((word32) eax_102->w0002 > dwArg08 - dwLoc20_385)
								goto l08098EB9;
							struct Eq_139185 * esp_274 = esp_19 - 0x04;
							esp_274->tFFFFFFFC = edi_205 * 0x02;
							esp_274->tFFFFFFF8 = edx_267;
							esp_274->tFFFFFFF4 = esp_19 - 0x02 + dwLoc28_386 * 0x02;
							word32 edx_673;
							ecx = memmove(esp_274->tFFFFFFF4, esp_274->tFFFFFFF8, esp_274->tFFFFFFFC, out edx_673);
							((word32) esp_19 + esi_123 * 0x02)->u4 = si_106;
							goto l08098DB0;
						}
l08098DFF:
						if (bArg10 != 0x00)
						{
							struct Eq_138995 * eax_152 = edi_129->ptr01F8;
							if (eax_152 == null)
								goto l08098E09;
							ecx = eax_152->ptr0000;
							do
							{
								if (ecx == null)
									goto l08098E09;
								--ecx;
							} while (eax_152->a0004[ecx].ptr0000 != ebx_112);
							word32 * eax_167 = ebx_112->ptr01F4;
							if (eax_167 == null)
								goto l08098E45;
							do
							{
								ecx = *eax_167;
								if (ecx == null)
									goto l08098E45;
								++eax_167;
							} while (edi_129 != ecx);
						}
l08098E09:
						--esi_123;
						edx_126 -= 0x04;
					} while (dwLoc20_385 != esi_123);
				}
			}
			if (dwArg08 == dwLoc28_386)
				break;
			edx_267 = (word32) esp_19 + dwLoc28_386 * 0x02;
l08098EB9:
			struct Eq_139019 * esp_335 = esp_19 - 0x04;
			esp_335->tFFFFFFFC = (dwArg08 - dwLoc28_386) * 0x02;
			esp_335->tFFFFFFF8.u0 = 0x00;
			esp_335->tFFFFFFF4 = edx_267;
			word32 edx_670;
			memset(esp_335->tFFFFFFF4, esp_335->tFFFFFFF8, esp_335->tFFFFFFFC, out ecx, out edx_670);
			dwLoc20_385 = dwLoc28_386;
			++dwLoc28_386;
		}
	}
	return ecx;
}

// 08098F80: Register (ptr32 Eq_127386) _dl_tlsdesc_resolve_early_return_p(Register (ptr32 Eq_127386) eax, Register (ptr32 code) edx, Register out (ptr32 code) ecxOut)
// Called from:
//      _dl_tlsdesc_resolve_abs_plus_addend_fixup
//      _dl_tlsdesc_resolve_rel_fixup
//      _dl_tlsdesc_resolve_rela_fixup
struct Eq_127386 * _dl_tlsdesc_resolve_early_return_p(struct Eq_127386 * eax, <anonymous> * edx, <anonymous> & ecxOut)
{
	<anonymous> * ecx_100 = eax->ptr0000;
	if (ecx_100 == edx)
	{
		ecx_100 = eax->ptr0000;
		if (edx == ecx_100)
		{
			eax->ptr0000 = &g_t8093420;
			ecxOut = ecx_100;
			return null;
		}
	}
	ecxOut = ecx_100;
	return (struct Eq_127386 *) 0x01;
}

// 08099000: void _dl_tlsdesc_resolve_abs_plus_addend_fixup(Register (ptr32 Eq_127386) eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_abs_plus_addend
void _dl_tlsdesc_resolve_abs_plus_addend_fixup(struct Eq_127386 * eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 edi_23 = eax->t0004;
	struct Eq_127386 * esi_16 = eax;
	ptr32 ebx_21 = 0x080CE000;
	word32 ecx_29;
	if (_dl_tlsdesc_resolve_early_return_p(eax, dwArg00 - ecx, out ecx_29) == 0x00)
	{
		Eq_2 eax_38 = *((word32) edx + 0x0244);
		if (eax_38 <= 0x00)
		{
			struct Eq_139261 * ebp_48;
			word32 edx_52;
			_dl_allocate_static_tls(gs, edx, out edx_52, out ebx_21, out ebp_48, out esi_16, out edi_23);
			eax_38 = ebp_48->t0244;
		}
		esi_16->t0004 = edi_23 - eax_38;
		esi_16->ptr0000 = ebx_21 + ~0x0003AC5F;
	}
}

// subject_text_0005.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08099090: void _dl_tlsdesc_resolve_rel_fixup(Register (ptr32 Eq_127386) eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_rel
void _dl_tlsdesc_resolve_rel_fixup(struct Eq_127386 * eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 ebp_23 = eax->t0004;
	Eq_2 edi_107 = edx;
	struct Eq_127386 * esi_129 = eax;
	ptr32 ebx_125 = 0x080CE000;
	word32 ecx_294;
	Eq_2 eax_28 = _dl_tlsdesc_resolve_early_return_p(eax, dwArg00 - ecx, out ecx_294);
	if (eax_28 != 0x00)
		return;
	uint32 ebp_39 = *((word32) ebp_23 + 4);
	struct Eq_139302 * edx_46 = (word32) *((word32) *((word32) edx + 56) + 4) + ((ebp_39 >> 0x08) << 0x04);
	word32 ecx_40 = *((word32) *((word32) edx + 52) + 4);
	if (edx_46->b000C >> 0x04 != 0x00 && (edx_46->b000D & 0x03) == 0x00)
	{
		Eq_2 ecx_56 = *((word32) edx + 232);
		if (ecx_56 != 0x00)
		{
			ecx_56 = (word32) *((word32) edx + 372) + (((word32) (*((word32) (*((word32) ecx_56 + 4)) + (ebp_39 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) ecx_56 + 4) == null)
				ecx_56 = eax_28;
		}
		word32 ecx_98;
		word32 edx_295;
		edi_107 = _dl_lookup_symbol_x(gs, ecx_40 + edx_46->dw0000, edx, fp - 0x20, *((word32) edx + 464), ecx_56, 0x01, 0x01, 0x00, out ecx_98, out edx_295);
		if (edx_46 == null)
		{
			eax->t0004.u0 = 0x00;
			eax->ptr0000 = &g_t80933B0;
			return;
		}
	}
	struct Eq_139328 * esp_117 = fp - 0x3C;
	Eq_2 edx_113 = *((word32) edi_107 + 0x0244);
	if (edx_113 <= 0x00)
	{
		struct Eq_139400 * edi_127;
		word32 ebp_297;
		word32 edx_296;
		_dl_allocate_static_tls(gs, edi_107, out edx_296, out ebx_125, out ebp_297, out esi_129, out edi_127);
		Eq_2 esp_130 = <invalid>;
		edx_113 = edi_127->t0244;
		esp_117 = (word32) esp_130 + 16;
	}
	esi_129->t0004 = esp_117->ptr001C->dw0004 - edx_113;
	esi_129->ptr0000 = ebx_125 + ~0x0003AC5F;
}

// 080991D0: void _dl_tlsdesc_resolve_rela_fixup(Register (ptr32 Eq_127386) eax, Register word32 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_rela
void _dl_tlsdesc_resolve_rela_fixup(struct Eq_127386 * eax, word32 ecx, Eq_2 edx, struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 ebp_126 = eax->t0004;
	Eq_2 edi_109 = edx;
	struct Eq_127386 * esi_131 = eax;
	ptr32 ebx_127 = 0x080CE000;
	word32 ecx_295;
	Eq_2 eax_28 = _dl_tlsdesc_resolve_early_return_p(eax, dwArg00 - ecx, out ecx_295);
	if (eax_28 != 0x00)
		return;
	uint32 ecx_40 = *((word32) ebp_126 + 4);
	struct Eq_139451 * edx_48 = (word32) *((word32) *((word32) edx + 56) + 4) + ((ecx_40 >> 0x08) << 0x04);
	word32 eax_41 = *((word32) *((word32) edx + 52) + 4);
	if (edx_48->b000C >> 0x04 != 0x00 && (edx_48->b000D & 0x03) == 0x00)
	{
		Eq_2 ecx_58 = *((word32) edx + 232);
		if (ecx_58 != 0x00)
		{
			ecx_58 = (word32) *((word32) edx + 372) + (((word32) (*((word32) (*((word32) ecx_58 + 4)) + (ecx_40 >> 0x08) * 0x02)) & 0x7FFF) << 0x04);
			if (*((word32) ecx_58 + 4) == null)
				ecx_58 = eax_28;
		}
		word32 ecx_100;
		word32 edx_296;
		edi_109 = _dl_lookup_symbol_x(gs, eax_41 + edx_48->dw0000, edx, fp - 0x20, *((word32) edx + 464), ecx_58, 0x01, 0x01, 0x00, out ecx_100, out edx_296);
		if (edx_48 == null)
		{
			eax->t0004 = *((word32) ebp_126 + 8);
			eax->ptr0000 = &g_t80933B0;
			return;
		}
	}
	struct Eq_139477 * esp_119 = fp - 0x3C;
	Eq_2 edx_115 = *((word32) edi_109 + 0x0244);
	if (edx_115 <= 0x00)
	{
		struct Eq_139551 * edi_129;
		word32 edx_297;
		_dl_allocate_static_tls(gs, edi_109, out edx_297, out ebx_127, out ebp_126, out esi_131, out edi_129);
		Eq_2 esp_132 = <invalid>;
		edx_115 = edi_129->t0244;
		esp_119 = (word32) esp_132 + 16;
	}
	esi_131->t0004 = (word32) *((word32) ebp_126 + 8) + (esp_119->ptr001C)->dw0004 - edx_115;
	esi_131->ptr0000 = ebx_127 + ~0x0003AC5F;
}

// 08099320: void _dl_tlsdesc_resolve_hold_fixup(Register (ptr32 (ptr32 code)) eax, Register word32 ecx, Stack word32 dwArg00)
// Called from:
//      _dl_tlsdesc_resolve_hold
void _dl_tlsdesc_resolve_hold_fixup(<anonymous> ** eax, word32 ecx, word32 dwArg00)
{
	*eax == dwArg00 - ecx;
}

// 08099390: Register Eq_2 _dl_unmap(Register Eq_2 ebx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      _dl_close_worker
Eq_2 _dl_unmap(Eq_2 ebx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 edx_7 = *((word32) dwArg04 + 432);
	Eq_2 ebx_18;
	word32 ecx_35;
	word32 edx_36;
	__munmap(ebx, gs, edx_7, *((word32) dwArg04 + 436) - edx_7, out ecx_35, out edx_36, out ebx_18);
	return ebx_18;
}

// 080993C0: void _dl_cet_open_check(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dl_open_worker
void _dl_cet_open_check(struct Eq_9 * gs, Eq_2 dwArg04)
{
	uint32 eax_22 = g_dw80CFF20;
	ui32 eax_26 = eax_22 >> 0x03 & 0x07;
	struct Eq_139614 * esp_175 = fp - 0x6C;
	ui32 * edi_19 = &g_dw80CFF1C;
	byte cl_111 = (int8) ((eax_22 & 0x07) == 0x02) & (int8) (eax_26 == 0x02);
	if (cl_111 != 0x00)
		return;
	uint32 eax_39 = g_dw80CFF1C;
	if (((byte) eax_39 & 0x03) == 0x00)
		return;
	word32 edx_385;
	ui32 ecx_386;
	Eq_2 ebp_187;
	word32 edi_279;
	Eq_2 eax_281;
	Eq_2 eax_219;
	ui32 edx_48 = eax_39 >> 0x01 & 0x01;
	ui32 eax_58 = SEQ(SLICE(eax_39 >> 0x01, word24, 8), (int8) ((eax_22 & 0x07) != 0x01)) & (eax_39 & 0x01);
	byte dl_54 = (byte) edx_48;
	byte al_61 = (byte) eax_58;
	word24 ebx_24_8_74 = SLICE(eax_58, word24, 8);
	byte bl_70 = (byte) eax_58 | (byte) (SEQ(SLICE(eax_58, word24, 8), (int8) (eax_26 != 0x01)) & edx_48);
	if (bl_70 != 0x00)
	{
		ui32 eax_126 = *((word32) dwArg04 + 356);
		ebp_187.u0 = 0x00;
l08099460:
		for (--eax_126; eax_126 != ~0x00; --eax_126)
		{
			ebp_187 = *((word32) *((word32) dwArg04 + 500) + eax_126 * 0x04);
			if ((*((word64) ebp_187.u0 + 408) & 0x08) != 0x00)
				goto l08099460;
			byte dl_103 = (int8) ((eax_22 & 0x07) != 0x02) & al_61;
			if (dl_103 != 0x00 && ((*((word64) ebp_187.u0 + 410) & 0x04) == 0x00 && cl_111 == 0x00))
				cl_111 = dl_103;
			if (eax_26 == 0x02)
				goto l08099460;
		}
		if (cl_111 != 0x00)
		{
			Eq_2 eax_148 = g_t80CFF68;
			if (eax_148 == 0x00)
			{
				word32 eax_200;
				word32 edx_202;
				gs->ptr0010();
				if (eax_200 != 0x00)
					goto l08099700;
				g_t80CFF68 = dwLoc2C;
				g_t80CFF6C = dwLoc24;
			}
			else
			{
				esp_175 = fp - 0x68;
				word32 edx_809;
				word32 ecx_808;
				if (mprotect(gs, eax_148, g_t80CFF6C, 0x03, out ecx_808, out edx_809) < 0x00)
					goto l08099762;
			}
			if (esp_175[2] <= esp_175[9])
			{
				esp_175[0x0A] = (struct Eq_139614) *((word32) dwArg04 + 500);
				esp_175[0x0E] = (struct Eq_139614) _dl_pagesize;
				do
				{
					Eq_2 esi_232 = *((word32) esp_175[0x0A] + esp_175[2] * 0x04);
					eax_219 = esp_175[7];
					esp_175[8] = (struct Eq_139614) esi_232;
					if ((*((word32) esi_232 + 408) & 0x08) == 0x00 && (*((word32) esi_232 + 410) & 0x04) == 0x00)
					{
						word32 ecx_241 = (word32) *((word32) esi_232 + 348);
						struct Eq_49300 * edx_242 = *((word32) esi_232 + 340);
						esp_175[6] = (struct Eq_139614) ecx_241;
						if (ecx_241 != 0x00)
						{
							esp_175[1] = (struct Eq_139614) 0x00;
							struct Eq_49300 * ebp_247 = edx_242;
							do
							{
								if (ebp_247->dw0000 == 0x01 && (ebp_247->t0018 & 0x01) != 0x00)
								{
									uint32 esi_258 = esp_175[0x0E];
									uint32 eax_266 = (uint32) ((uint64) ((word32) *esp_175[8] + ebp_247->dw0008) /u esi_258);
									uint32 eax_273 = (uint32) ((uint64) (esi_258 - 0x01 + ebp_247->dw0014) /u esi_258);
									uint32 edx_274 = eax_266 + eax_273;
									esp_175[0x0D] = (struct Eq_139614) edx_274;
									if (esp_175[0x0C] < edx_274 >> 0x03)
									{
										edi_279 = (word32) esp_175[5];
										ebp_187 = esp_175[8];
										eax_281 = edi_279 + 4294883888;
										goto l0809970A;
									}
									uint32 esi_287 = 0x20 - (eax_266 & 0x1F);
									ui32 * ebx_288 = (word32) esp_175[7] + (eax_266 >> 0x05) * 0x04;
									ui32 edx_291 = ~0x00 << (byte) (eax_266 & 0x1F);
									if (eax_273 >= esi_287)
									{
										do
										{
											*ebx_288 |= edx_291;
											eax_273 -= esi_287;
											esi_287 = 0x20;
											++ebx_288;
											edx_291 = ~0x00;
										} while (eax_273 > 0x1F);
									}
									if (eax_273 != 0x00)
										*ebx_288 |= edx_291 & ~0x00 >> (byte) (-esp_175[0x0D]);
								}
								esp_175[1] = (struct Eq_139614) ((word32) esp_175[1] + 1);
								++ebp_247;
							} while (esp_175[6] != esp_175[1]);
l08099720:
							struct Eq_140168 * eax_340 = esp_175[0x0F];
							eax_219 = eax_340->t0000;
							esp_175[0x0C] = (struct Eq_139614) eax_340->dw0004;
							esp_175[7] = (struct Eq_139614) eax_219;
						}
					}
					esp_175[2] = (struct Eq_139614) ((word32) esp_175[2] + 1);
				} while (esp_175[2] <= esp_175[9]);
				ebp_187 = esp_175[8];
			}
			else
				eax_219 = esp_175[7];
			struct Eq_140133 * esp_354 = esp_175 - 0x04;
			esp_354->tFFFFFFFC.u0 = 0x01;
			esp_354->tFFFFFFF8 = esp_354->t0034;
			esp_354->tFFFFFFF4 = eax_219;
			esp_175 = (struct Eq_139614 *) ((char *) &esp_354->tFFFFFFFC + 0x0C);
			word32 ecx_810;
			word32 edx_811;
			if (mprotect(gs, esp_354->tFFFFFFF4, esp_354->tFFFFFFF8, esp_354->tFFFFFFFC, out ecx_810, out edx_811) < 0x00)
			{
l08099762:
				edi_279 = (word32) esp_175[5];
				eax_281 = edi_279 + ~0x0001463A;
				goto l0809970A;
			}
		}
		edx_385 = (word32) esp_175->b002D;
		ecx_386 = (word32) esp_175->b002E ^ edx_385;
	}
	else
	{
		ecx_386 = (word32) dl_54;
		ebp_187.u0 = 0x00;
		edx_385 = SEQ(ebx_24_8_74, bl_70);
	}
	byte dl_409 = (byte) edx_385;
	byte cl_397 = (byte) ecx_386;
	if ((esp_175->b002F & (int8) (esp_175[4] == 0x01)) == 0x00 && cl_397 == 0x00)
		return;
	if (esp_175[3] != 0x03)
	{
		if (esp_175->b002E == dl_409)
			return;
		edi_279 = (word32) esp_175[5];
		eax_281 = edi_279 + ~0x0001461C;
l0809970A:
		struct Eq_139753 * esp_527 = esp_175 - 4;
		esp_527->t0000 = eax_281;
		esp_527->dwFFFFFFFC = edi_279 + ~0x0001A0D4;
		esp_527->dwFFFFFFF8 = (word32) *((word64) ebp_187.u0 + 4);
		esp_527->tFFFFFFF4.u0 = 22;
		word32 edx_801;
		word32 ebx_802;
		word32 ebp_803;
		word32 ecx_800;
		_dl_signal_error(gs, esp_527->tFFFFFFF4, esp_527->t0000, out ecx_800, out edx_801, out ebx_802, out ebp_803, out edi_19);
		esp_175 = esp_527 - 0x10;
		goto l08099720;
	}
	word32 eax_451;
	word32 ecx_452;
	word32 edx_453;
	gs->ptr0010();
	byte dl_497 = (byte) edx_453;
	if (eax_451 == 0x00)
	{
		ui32 eax_490 = (word32) esp_175[11];
		*edi_19 &= ~ecx_452;
		if (dl_497 != 0x00)
			eax_490 |= 0x02;
		gs->dw0020 = eax_490;
		return;
	}
	word32 edi_458 = esp_175[5];
	struct Eq_139837 * esp_463 = esp_175 - 4;
	esp_463->t0000 = edi_458 + ~0x00014601;
	esp_463->dwFFFFFFFC = edi_458 + ~0x0001A0D4;
	esp_463->dwFFFFFFF8 = (word32) *((word32) ebp_187 + 4);
	esp_463->tFFFFFFF4 = -eax_451;
	word32 edx_805;
	word32 ebx_806;
	word32 edi_807;
	word32 ecx_804;
	_dl_signal_error(gs, esp_463->tFFFFFFF4, esp_463->t0000, out ecx_804, out edx_805, out ebx_806, out ebp_187, out edi_807);
	esp_175 = esp_463 - 0x10;
l08099700:
	edi_279 = (word32) esp_175[5];
	eax_281 = edi_279 + ~0x000145EF;
	goto l0809970A;
}

// 080997C0: void _dl_addr(Stack Eq_2 dwArg04, Stack (ptr32 Eq_133148) dwArg08, Stack (ptr32 Eq_2) dwArg0C, Stack (ptr32 Eq_2) dwArg10)
// Called from:
//      __dladdr
//      __dladdr1
void _dl_addr(Eq_2 dwArg04, struct Eq_133148 * dwArg08, union Eq_2 * dwArg0C, union Eq_2 * dwArg10)
{
	Eq_2 eax_46 = _dl_find_dso_for_object(dwArg04);
	if (eax_46 != 0x00)
	{
		Eq_2 edx_57 = *((word32) eax_46 + 4);
		Eq_2 ecx_59 = *((word32) eax_46 + 432);
		dwArg08->t0000 = edx_57;
		dwArg08->t0004 = ecx_59;
		if (*edx_57 == 0x00 && (*((word32) eax_46 + 408) & 0x03) == 0x00)
			dwArg08->t0000 = **(union Eq_2 **) 135060900;
		Eq_2 esi_78 = *((word32) *((word32) eax_46 + 56) + 4);
		Eq_2 ebp_164 = *((word32) eax_46 + 336);
		Eq_2 edx_105 = esi_78;
		Eq_2 esi_82 = *((word32) *((word32) eax_46 + 52) + 4);
		up32 esi_85 = *((word32) *((word32) eax_46 + 72) + 4);
		if (ebp_164 != 0x00)
		{
			Eq_113558 edx_197 = *((word32) eax_46 + 380);
			if (edx_197 != 0x00)
			{
				union Eq_115004 * esi_204 = *((word32) eax_46 + 396);
				Eq_2 dwLoc30_502 = 0x00;
				union Eq_115004 * ebx_209 = (char *) esi_204 + edx_197 * 0x04;
				do
				{
					ui32 edx_213 = *esi_204;
					if (edx_213 != 0x00)
					{
						struct Eq_140293 * ecx_224 = (word32) *((word32) eax_46 + 400) + edx_213 * 0x04;
						Eq_2 edx_226 = (word32) esi_78 + (edx_213 << 0x04);
						do
						{
							word16 bx_231 = *((word32) edx_226 + 0x0E);
							if (bx_231 == 0x00)
							{
								if (*((word32) edx_226 + 4) != 0x00)
								{
l080998B7:
									if ((byte) ((word32) *((word32) edx_226 + 0x0C) & 0x0F) == 0x06)
										goto l080998F8;
									up32 ebp_249 = *((word32) edx_226 + 4);
									Eq_2 edi_254 = (word32) *eax_46 + ebp_249;
									if (dwArg04 < edi_254)
										goto l080998F8;
									up32 ebx_263;
									if (bx_231 != 0x00)
									{
										ebx_263 = (up32) *((word32) edx_226 + 8);
										if (ebx_263 != 0x00)
											goto l08099A59;
										if (dwArg04 != edi_254)
											goto l080998F8;
										goto l08099A65;
									}
									if (dwArg04 != edi_254)
									{
										ebx_263 = (up32) *((word32) edx_226 + 8);
l08099A59:
										if (dwArg04 < (word32) edi_254 + ebx_263)
											goto l08099A65;
									}
									else
									{
l08099A65:
										if (dwLoc30_502 == 0x00 || ebp_249 > *((word32) dwLoc30_502 + 4))
										{
											Eq_2 eax_294 = dwLoc30_502;
											if (esi_85 > *edx_226)
												eax_294 = edx_226;
											dwLoc30_502 = eax_294;
										}
									}
								}
l080998F8:
								++ecx_224;
								edx_226 = (word32) edx_226 + 16;
								if ((ecx_224->bFFFFFFFC & 0x01) == 0x00)
									continue;
								break;
							}
							if (bx_231 != ~0x0E)
								goto l080998B7;
							++ecx_224;
							edx_226 = (word32) edx_226 + 16;
						} while ((ecx_224->bFFFFFFFC & 0x01) == 0x00);
						esi_204 = (union Eq_115004 *) ((char *) esi_204 + 4);
						if (ebx_209 == esi_204)
							break;
						continue;
					}
					esi_204 = (union Eq_115004 *) ((char *) esi_204 + 4);
				} while (ebx_209 != esi_204);
				ebp_164 = dwLoc30_502;
			}
			else
				ebp_164.u0 = 0x00;
		}
		else
		{
			struct Eq_140250 * ecx_90 = *((word32) eax_46 + 48);
			Eq_2 edi_102 = esi_82;
			if (ecx_90 != null)
				edi_102 = (word32) esi_78 + ((ecx_90->ptr0004)->dw0004 << 0x04);
			if (esi_78 < edi_102)
			{
				do
				{
					ui32 ebx_107 = (word32) *((word32) edx_105 + 0x0C);
					if ((byte) (SEQ(SLICE(ebx_107, word24, 8), (byte) ebx_107 >> 0x04) - 0x01) <= 0x01 && (((word32) (*((word32) edx_105 + 0x0D)) & 0x03) > 0x02 && (byte) (ebx_107 & 0x0F) != 0x06))
					{
						up32 ecx_133;
						up32 esi_140;
						Eq_2 ebx_136;
						word16 cx_127 = *((word32) edx_105 + 0x0E);
						if (cx_127 == 0x00)
						{
							ecx_133 = (up32) *((word32) edx_105 + 4);
							if (ecx_133 == 0x00)
								goto l08099A30;
							ebx_136 = (word32) *eax_46 + ecx_133;
							if (dwArg04 < ebx_136)
								goto l08099A30;
							if (dwArg04 == ebx_136)
								goto l08099A1A;
							esi_140 = (up32) *((word32) edx_105 + 8);
							goto l08099A12;
						}
						if (cx_127 == ~0x0E)
							goto l08099A30;
						ecx_133 = (up32) *((word32) edx_105 + 4);
						ebx_136 = (word32) *eax_46 + ecx_133;
						if (dwArg04 < ebx_136)
							goto l08099A30;
						esi_140 = (up32) *((word32) edx_105 + 8);
						if (esi_140 == 0x00)
						{
							if (dwArg04 == ebx_136)
								goto l08099A1A;
						}
						else
						{
l08099A12:
							if (dwArg04 < (word32) ebx_136 + esi_140)
							{
l08099A1A:
								if (ebp_164 == 0x00 || *((word64) ebp_164.u0 + 4) < ecx_133)
								{
									if (esi_85 > *edx_105)
										ebp_164 = edx_105;
								}
							}
						}
					}
l08099A30:
					edx_105 = (word32) edx_105 + 16;
				} while (edx_105 < edi_102);
			}
		}
		if (dwArg0C != null)
			*dwArg0C = (union Eq_2 *) eax_46;
		if (dwArg10 != null)
			*dwArg10 = (union Eq_2 *) ebp_164;
		if (ebp_164 != 0x00)
		{
			Eq_2 eax_389;
			Mem387[dwArg08 + 0x08:word32] = esi_82 + Mem378[ebp_164 + 0x00:word32];
			if (*((word64) ebp_164.u0 + 0x0E) != ~0x0E)
				eax_389 = *eax_46;
			else
				eax_389.u0 = 0x00;
			Mem402[dwArg08 + 0x0C:word32] = eax_389 + Mem387[ebp_164 + 0x04:word32];
		}
		else
		{
			dwArg08->dw0008 = 0x00;
			dwArg08->dw000C = 0x00;
		}
	}
}

// 08099B20: Register word32 _dl_addr_inside_object(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08)
// Called from:
//      _dl_find_dso_for_object
word32 _dl_addr_inside_object(Eq_2 dwArg04, Eq_2 dwArg08)
{
	ui32 edx_12 = (word32) *((word32) dwArg04 + 348);
	up32 esi_13 = dwArg08 - *dwArg04;
	do
	{
		--edx_12;
		if (edx_12 == ~0x00)
			return 0x00;
		struct Eq_140533 * eax_32 = (word32) *((word32) dwArg04 + 340) + (edx_12 << 0x05);
	} while (eax_32->dw0000 != 0x01 || esi_13 - eax_32->dw0008 >= eax_32->dw0014);
	return 0x01;
}

// 08099B80: Register uint32 fn08099B80(Register uint32 eax, Stack word32 dwArg00)
// Called from:
//      __mpn_add_n
uint32 fn08099B80(uint32 eax, word32 dwArg00)
{
	return eax + dwArg00;
}

// 08099B90: Register Eq_140561 __mpn_add_n(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10, Register out (ptr32 (arr Eq_2)) ebxOut, Register out (ptr32 word32) esiOut, Register out (ptr32 word32) ediOut)
// Called from:
//      __mpn_divrem
//      __mpn_mul
//      __mpn_impn_mul_n_basecase
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n_basecase
//      __mpn_impn_sqr_n
Eq_140561 __mpn_add_n(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10, Eq_2 (& ebxOut, word32 & esiOut, word32 & ediOut)
{
	Eq_2 edi_10 = dwArg04;
	Eq_2 esi_11 = dwArg08;
	Eq_2 edx_12 = dwArg0C;
	uint32 ecx_18 = dwArg10 >> 0x03;
	uint32 eax_19 = -dwArg10;
	if ((eax_19 & 0x07) == 0x00)
	{
		do
		{
			word32 eax_29 = Mem25[esi_11 + 0x00:word32] + Mem25[edx_12 + 0x00:word32];
			*edi_10 = eax_29;
			word32 eax_35 = Mem32[esi_11 + 0x04:word32] + Mem32[edx_12 + 0x04:word32] + (eax_29 <u 0x00);
			*((word32) edi_10 + 4) = eax_35;
			word32 eax_40 = Mem37[esi_11 + 0x08:word32] + Mem37[edx_12 + 0x08:word32] + (eax_35 <u 0x00);
			*((word32) edi_10 + 8) = eax_40;
			word32 eax_45 = Mem42[esi_11 + 0x0C:word32] + Mem42[edx_12 + 0x0C:word32] + (eax_40 <u 0x00);
			*((word32) edi_10 + 0x0C) = eax_45;
			word32 eax_50 = Mem47[esi_11 + 0x10:word32] + Mem47[edx_12 + 0x10:word32] + (eax_45 <u 0x00);
			*((word32) edi_10 + 16) = eax_50;
			word32 eax_55 = Mem52[esi_11 + 0x14:word32] + Mem52[edx_12 + 0x14:word32] + (eax_50 <u 0x00);
			*((word32) edi_10 + 20) = eax_55;
			word32 eax_60 = Mem57[esi_11 + 0x18:word32] + Mem57[edx_12 + 0x18:word32] + (eax_55 <u 0x00);
			*((word32) edi_10 + 24) = eax_60;
			word32 eax_65 = Mem62[esi_11 + 0x1C:word32] + Mem62[edx_12 + 0x1C:word32] + (eax_60 <u 0x00);
			*((word32) edi_10 + 28) = eax_65;
			edi_10 = (word32) edi_10 + 32;
			esi_11 = (word32) esi_11 + 32;
			edx_12 = (word32) edx_12 + 32;
			--ecx_18;
		} while (ecx_18 != 0x00);
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return eax_65 < 0x00;
	}
	else
	{
		uint32 eax_88 = (eax_19 & 0x07) << 0x02;
		Eq_2 ebx_94[] = (eax_88 >> 0x02) * 0x04 + ~0x03;
		Eq_140561 eax_105;
		ebx_94[fn08099B80((eax_88 >> 0x02) + 0x02 + (eax_88 >> 0x02) * 0x08, dwLoc10) / 4]();
		ebxOut = ebx_94;
		esiOut = dwArg08 - eax_88;
		ediOut = dwArg04 - eax_88;
		return eax_105;
	}
}

// 08099C50: Register word32 __mpn_addmul_1(Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack uint32 dwArg10)
// Called from:
//      __mpn_mul
//      __mpn_impn_mul_n_basecase
//      __mpn_impn_mul_n
//      __mpn_impn_sqr_n_basecase
//      __mpn_impn_sqr_n
word32 __mpn_addmul_1(Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, uint32 dwArg10)
{
	up32 edi_20[] = (word32) dwArg04 + dwArg0C * 0x04;
	uint32 esi_21[] = (word32) dwArg08 + dwArg0C * 0x04;
	ui32 ecx_22 = -dwArg0C;
	word32 ebp_23 = 0x00;
	do
	{
		uint64 edx_eax_32 = dwArg10 *64 esi_21[ecx_22];
		up32 eax_35 = (word32) edx_eax_32 + ebp_23;
		up32 v14_41 = edi_20[ecx_22] + eax_35;
		edi_20[ecx_22] = v14_41;
		word32 edx_45 = (bool) (v14_41 < 0x00) + ((bool) (eax_35 < 0x00) + SLICE(edx_eax_32, word32, 32));
		ebp_23 = edx_45;
		++ecx_22;
	} while (ecx_22 != 0x00);
	return edx_45;
}

// 08099CA0: void dlopen_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_140766) dwArg04)
void dlopen_doit(struct Eq_9 * gs, struct Eq_140766 * dwArg04)
{
	ui32 edx_14 = dwArg04->dw0004;
	if ((edx_14 & ~0x4000110F) != 0x00)
	{
		word32 edx_162;
		dcgettext(out edx_162);
		word32 edx_164;
		word32 ecx_163;
		word32 ebx_165;
		word32 ebp_166;
		word32 edi_167;
		_dl_signal_error(gs, 0x00, 0x080B1B5C, out ecx_163, out edx_164, out ebx_165, out ebp_166, out edi_167);
		__dlopen(gs, 0x00);
	}
	else
	{
		Eq_2 ecx_101 = dwArg04->t0000;
		if (ecx_101 == 0x00)
			ecx_101.u0 = 134955513;
		dwArg04->dw0008 = _dl_open(gs, ecx_101, edx_14 | 0x80000000, dwArg04->dw000C, 0x00, __libc_argc, __libc_argv, environ);
	}
}

// 08099D30: void __dlopen(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dlopen_doit
void __dlopen(struct Eq_9 * gs, Eq_2 dwArg04)
{
	ui32 ecx_9 = gs->dw0014;
	if (_dlerror_run(gs) == 0x00)
	{
		__libc_register_dl_open_hook();
		__libc_register_dlfcn_hook();
	}
	if ((ecx_9 ^ gs->dw0014) == 0x00)
		return;
	word32 edx_140;
	word32 ecx_139;
	__stack_chk_fail(out ecx_139, out edx_140);
	dlclose_doit(gs, dwArg04);
}

// 08099DC0: void dlclose_doit(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __dlopen
void dlclose_doit(struct Eq_9 * gs, Eq_2 dwArg04)
{
	_dl_close(gs, dwArg04);
}

// 08099DD0: void __dlclose(Register (ptr32 Eq_9) gs)
void __dlclose(struct Eq_9 * gs)
{
	_dlerror_run(gs);
}

// 08099E00: void dlsym_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_140856) dwArg04)
void dlsym_doit(struct Eq_9 * gs, struct Eq_140856 * dwArg04)
{
	struct Eq_140857 * esi_31;
	esi_31->dw000C = _dl_sym(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->t0008, out esi_31);
}

// 08099E30: void __dlsym(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_140880) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __dlsym(struct Eq_9 * gs, struct Eq_140880 * dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ui32 eax_14 = gs->dw0014;
	_dlerror_run(gs) != 0x00;
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_181;
	word32 edx_182;
	__stack_chk_fail(out ecx_181, out edx_182);
	dlvsym_doit(gs, dwArg04);
}

// 08099EE0: void dlvsym_doit(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_140880) dwArg04)
// Called from:
//      __dlsym
void dlvsym_doit(struct Eq_9 * gs, struct Eq_140880 * dwArg04)
{
	dwArg04->dw0010 = _dl_vsym(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->t0008, dwArg04->t000C);
}

// 08099F20: void __dlvsym(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 word32) dwArg08, Stack ptr32 dwArg0C, Stack word32 dwArg10)
void __dlvsym(struct Eq_9 * gs, word32 dwArg04, word32 * dwArg08, ptr32 dwArg0C, word32 dwArg10)
{
	ui32 eax_14 = gs->dw0014;
	_dlerror_run(gs) != 0x00;
	if ((eax_14 ^ gs->dw0014) == 0x00)
		return;
	word32 ecx_187;
	word32 edx_188;
	__stack_chk_fail(out ecx_187, out edx_188);
	__setitimer(gs, dwArg04, dwArg08, dwArg0C);
}

// 08099FE0: Register (ptr32 Eq_226) __setitimer(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack (ptr32 word32) dwArg08, Stack ptr32 dwArg0C)
// Called from:
//      profil
//      __dlvsym
struct Eq_226 * __setitimer(struct Eq_9 * gs, word32 dwArg04, word32 * dwArg08, ptr32 dwArg0C)
{
	struct Eq_226 * eax_14;
	gs->ptr0010();
	if (eax_14 < (struct Eq_226 *) ~0x0FFE)
		return eax_14;
	word32 edx_43;
	return __syscall_error(eax_14, gs, out edx_43);
}

// 0809A010: Register (ptr32 Eq_2) _dl_build_local_scope(Register (ptr32 Eq_2) eax, Register Eq_2 edx)
// Called from:
//      _dl_build_local_scope
//      _dl_map_object_deps
union Eq_2 * _dl_build_local_scope(union Eq_2 * eax, Eq_2 edx)
{
	*eax = (union Eq_2 *) edx;
	*((word32) edx + 408) = (byte) ((word32) *((word32) edx + 408) & ~0x60 | 0x20);
	struct Eq_140981 * edx_12 = *((word32) edx + 500);
	if (edx_12 == null)
		return (union Eq_2 *) 0x01;
	union Eq_2 * esi_24 = (char *) eax + 4;
	union Eq_2 * eax_25 = (union Eq_2 *) 0x01;
	word32 * ebx_29 = &edx_12->t0004;
	Eq_2 edx_30 = edx_12->t0004;
	if (edx_30 != 0x00)
	{
		do
		{
			if ((*((word32) edx_30 + 408) & 0x60) == 0x00)
				esi_24 = (union Eq_2 *) ((char *) esi_24 + _dl_build_local_scope(esi_24, edx_30) * 0x04);
			++ebx_29;
			edx_30 = *ebx_29;
		} while (edx_30 != 0x00);
		eax_25 = esi_24 - eax >> 0x02;
	}
	return eax_25;
}

// 0809A080: void openaux(Register Eq_2 edi, Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_141027) dwArg04)
void openaux(Eq_2 edi, struct Eq_9 * gs, struct Eq_141027 * dwArg04)
{
	Eq_2 edx_9 = dwArg04->t0000;
	byte al_21 = (byte) ((word32) *((word32) edx_9 + 408) & 0x03);
	Eq_2 v7_11 = *((word32) edx_9 + 24);
	ui32 v8_14 = dwArg04->dw0008;
	Eq_2 ecx_24 = (word32) al_21;
	Eq_2 eax_25 = 0x01;
	if (al_21 != 0x00)
		eax_25 = ecx_24;
	struct Eq_141054 * ebx_45;
	word32 ebp_77;
	ebx_45->t0014 = _dl_map_object(edi, gs, edx_9, dwArg04->t0010, eax_25, v8_14, v7_11, out ebx_45, out ebp_77);
}

// 0809A0C0: Register word32 _dl_map_object_deps(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg08, Stack ui32 dwArg0C, Register out (ptr32 Eq_134959) ebpOut, Register out ptr32 ediOut)
// Called from:
//      dl_open_worker
word32 _dl_map_object_deps(struct Eq_9 * gs, Eq_2 dwArg08, ui32 dwArg0C, struct Eq_134959 & ebpOut, ptr32 & ediOut)
{
	__align(fp);
	ui32 edx_36 = dwArg0C * 0x0C + 0x33;
	struct Eq_141075 * ebp_1062 = fp - 8;
	Eq_141078 esp_1077 = fp - 0x04B0;
	Eq_2 eax_1256 = dwArg08;
	Eq_141078 edi_42 = fp - 0x04B0 - (edx_36 & ~0x0FFF);
	if (fp - 0x04B0 != edi_42)
	{
		do
		{
			esp_1077 -= 0x1000;
			*((word32) esp_1077 + 0x0FFC) = *((word32) esp_1077 + 0x0FFC);
		} while (esp_1077 != edi_42);
	}
	Eq_2 ecx_102 = edx_36 & ~0x0F & 0x0FFF;
	if (ecx_102 != 0x00)
	{
l0809AD78:
		esp_1077 -= ecx_102;
		Mem1285[esp_1077 - 0x04 + ecx_102:word32] = Mem1282[esp_1077 - 0x04 + ecx_102:word32];
		goto l0809A14E;
	}
l0809A14E:
	ecx_102 = ebp_1062->ptrFFFFFB8C;
	ui32 ebx_68 = (word32) *((word32) ecx_102 + 408);
	Eq_141122 edx_66 = (word32) esp_1077 + 0x0F;
	(edx_66 & ~0x0F)->t0004 = ecx_102;
	*(edx_66 & ~0x0F) = 0x00;
	ebp_1062->ptrFFFFFB9C = edx_66 & ~0x0F;
	(edx_66 & ~0x0F)->dw0008 = (edx_66 & ~0x0F) + 0x0C;
	ebp_1062->tFFFFFB98.u0 = (byte) ebx_68;
	ui32 ebx_80 = ebp_1062->ptrFFFFFBA0;
	*((word32) ecx_102 + 408) = (byte) (ebx_68 & ~0x60 | 0x20);
	if (ebx_80 != 0x00)
	{
		ecx_102 = eax_1256;
		struct Eq_141180 * eax_100 = (edx_66 & ~0x0F) + 0x18;
		Eq_2 esi_95 = (word32) eax_1256 + ebx_80 * 0x04;
		do
		{
			struct Eq_141188 * ebx_99 = *ecx_102;
			eax_100->dwFFFFFFF4 = 0x00;
			eax_100->dwFFFFFFFC = eax_100;
			++eax_100;
			eax_100->dwFFFFFFEC = ebx_99;
			ebx_99->b0198 = (byte) ((word32) ebx_99->b0198 & ~0x60 | 0x20);
			ecx_102 = (word32) ecx_102 + 4;
		} while (esi_95 != ecx_102);
		word32 eax_115 = ebp_1062->ptrFFFFFBA0;
		struct Eq_141223 * ebx_116 = ebp_1062->ptrFFFFFB9C;
		ebp_1062->dwFFFFFB7C = eax_115 + 0x01;
		ebp_1062->dwFFFFFB84 = ebx_116 - 0x0C + ((eax_115 + 0x01) + (eax_115 + 0x01) * 0x02) * 0x04;
		ebp_1062->ptrFFFFFBA0 = ebx_116->dw0004;
	}
	else
	{
		ebp_1062->dwFFFFFB7C = 0x01;
		ebp_1062->ptrFFFFFBA0 = (struct Eq_155456 *) ebp_1062->ptrFFFFFB8C;
		ebp_1062->dwFFFFFB84 = ebp_1062->ptrFFFFFB9C;
	}
	struct Eq_143898 * eax_127 = ebp_1062->dwFFFFFB84;
	ebp_1062->dwFFFFFBDC = 0x0400;
	eax_127->dw0008 = 0x00;
	ptr32 eax_131 = ebp_1062 - 0x0418;
	ebp_1062->dwFFFFFB68 = eax_131;
	ebp_1062->dwFFFFFBD8 = eax_131;
	ebp_1062->dwFFFFFB64 = ~0x1F;
	ebp_1062->dwFFFFFB60 = (word32) gs->tFFFFFFE0;
	gs->tFFFFFFE0.u0 = 0x00;
	struct Eq_143931 * eax_142 = ebp_1062->ptrFFFFFB9C;
	ebp_1062->dwFFFFFB6C = edx_66 & ~0x0F;
	ebp_1062->ptrFFFFFB80 = (struct Eq_155452 *) eax_142;
	ebp_1062->dwFFFFFB5C = 0x080CFF04;
l0809A268:
	Eq_141377 esp_1107;
	Eq_2 eax_1526;
	ebp_1062->ptrFFFFFB80->dw0000 = 0x01;
	word32 eax_154 = ebp_1062->ptrFFFFFBA0->dw0160;
	ebp_1062->ptrFFFFFB90 = eax_154;
	struct Eq_9 * gs_1095 = gs;
	if (eax_154 != 0x00)
		ebp_1062->ptrFFFFFB90 = 0x00;
	else
	{
		struct Eq_141251 * eax_159 = ebp_1062->ptrFFFFFBA0;
		if (eax_159->dw01F4 == 0x00 && ebp_1062->ptrFFFFFB8C != eax_159)
		{
			Eq_2 eax_166 = (word32) eax_159->w015E;
			if ((word16) eax_166 != 0x00)
			{
				struct Eq_141764 * esp_172 = esp_1077 - 0x04;
				esp_172->tFFFFFFFC.u0 = 0x04;
				esp_172->tFFFFFFF8 = eax_166;
				esp_172->tFFFFFFF4 = ebp_1062 - 0x0428;
				esp_1107 = (char *) &esp_172->tFFFFFFFC + 8;
				word32 edx_2327;
				if ((byte) (uint32) __libc_scratch_buffer_set_array_size(gs, esp_172->tFFFFFFF4, esp_172->tFFFFFFF8, esp_172->tFFFFFFFC, out ecx_102, out edx_2327) == 0x00)
				{
					eax_1526 = ebp_1062->dwFFFFFBA4 + ~0x0001457F;
					goto l0809B176;
				}
				ebp_1062->ptrFFFFFB90 = ebp_1062->dwFFFFFBD8;
			}
		}
	}
	Eq_2 esi_1328;
	Eq_2 ecx_1888;
	Eq_141736 esp_2086;
	word32 edi_2081;
	Eq_141738 esp_2078;
	Eq_141078 esp_1430;
	Eq_2 ebx_1319;
	Eq_2 eax_1647;
	Eq_141078 esp_1979;
	Eq_2 eax_1052;
	struct Eq_141307 * eax_202 = ebp_1062->ptrFFFFFBA0;
	if (eax_202->dw0024 == 0x00 && eax_202->dw00F4 == 0x00)
	{
		ebp_1062->tFFFFFB98 = 0x00;
		if (eax_202->dw00EC == 0x00)
			goto l0809A2CF;
	}
	struct Eq_141264 * edi_218 = ebp_1062->ptrFFFFFBA0;
	struct Eq_141268 * eax_219 = edi_218->ptr0034;
	ebp_1062->dwFFFFFBC0 = edi_218;
	struct Eq_141275 * edi_2135 = edi_218->ptr0008;
	word32 eax_222 = eax_219->dw0004;
	ebp_1062->dwFFFFFB94 = eax_222;
	ebp_1062->dwFFFFFBCC = eax_222;
	ebp_1062->dwFFFFFBC4 = ebp_1062->dwFFFFFB78;
	ebp_1062->dwFFFFFBC8 = ebp_1062->dwFFFFFB74;
	ui32 eax_229 = edi_2135->dw0000;
	if (eax_229 == 0x00)
	{
		ebp_1062->tFFFFFB98 = 0x00;
l0809A2CF:
		gs_1095 = gs;
		word32 eax_1081[] = ebp_1062->ptrFFFFFB90;
		if (eax_1081 == null)
		{
l0809A36F:
			struct Eq_141329 * eax_1163 = ebp_1062->ptrFFFFFB80;
			if (eax_1163->dw0000 != 0x00)
			{
				do
				{
					eax_1163 = eax_1163->dw0008;
					if (eax_1163 == null)
					{
						ebp_1062->dwFFFFFB84 = 0x00;
						goto l0809A7EA;
					}
					ecx_102 = eax_1163->dw0000;
				} while (ecx_102 != 0x00);
				ebp_1062->ptrFFFFFB80 = (struct Eq_155452 *) eax_1163;
			}
			ebp_1062->ptrFFFFFBA0 = ebp_1062->ptrFFFFFB80->dw0004;
			goto l0809A268;
		}
		Eq_141338 edi_1085 = ebp_1062->tFFFFFB98;
		eax_1081[edi_1085] = 0x00;
		struct Eq_141346 * esp_1087 = esp_1077 - 0x0C;
		esp_1087->tFFFFFFFC = edi_1085 * 0x08 + 0x0C;
		int32 esi_1102;
		word32 ecx_2308;
		word32 edi_2311;
		word32 ebx_2310;
		word32 edx_2309;
		Eq_2 eax_1096 = __libc_malloc(gs, esp_1087->tFFFFFFF8, esp_1087->tFFFFFFFC, out ecx_2308, out edx_2309, out ebx_2310, out ebp_1062, out esi_1102, out edi_2311);
		esp_1107 = (char *) &esp_1087->t0004 + 8;
		if (eax_1096 != 0x00)
		{
			word32 eax_1112 = ebp_1062->ptrFFFFFBA0;
			ebp_1062->ptrFFFFFB9C = esi_1102 + 0x04;
			*eax_1096 = eax_1112;
			esp_1087->t0004 = esi_1102 + 0x04;
			esp_1087->t0000 = ebp_1062->ptrFFFFFB90;
			esp_1087->tFFFFFFFC = (word32) eax_1096 + 4;
			word32 ecx_2312;
			word32 edx_2313;
			memcpy(esp_1087->tFFFFFFFC, esp_1087->t0000, esp_1087->t0004, out ecx_2312, out edx_2313);
			esp_1087->t0004 = ebp_1062->ptrFFFFFB9C;
			esp_1087->t0000 = eax_1096;
			esp_1087->tFFFFFFFC = (word32) eax_1096 + 8 + esi_1102;
			word32 edx_2314;
			memcpy(esp_1087->tFFFFFFFC, esp_1087->t0000, esp_1087->t0004, out ecx_102, out edx_2314);
			struct Eq_141460 * eax_1154 = ebp_1062->ptrFFFFFBA0;
			eax_1154->b019A |= 0x01;
			eax_1154->t01F4 = eax_1096;
			goto l0809A36F;
		}
l0809B189:
		Eq_2 eax_1555 = ebp_1062->dwFFFFFBD8;
		if (eax_1555 != ebp_1062->dwFFFFFB68)
		{
			struct Eq_141481 * esp_1559 = esp_1107 - 0x0C;
			esp_1559->tFFFFFFFC = eax_1555;
			word32 edx_2316;
			word32 ecx_2315;
			free(gs_1095, esp_1559->tFFFFFFF8, esp_1559->tFFFFFFFC, out ecx_2315, out edx_2316);
			esp_1107 = (char *) &esp_1559->tFFFFFFFC + 20;
		}
		eax_1526 = ebp_1062->dwFFFFFBA4 + 4294884212;
l0809B176:
		struct Eq_141551 * esp_1528 = esp_1107 - 4;
		esp_1528->t0000 = eax_1526;
		struct Eq_141557 * eax_1532 = ebp_1062->ptrFFFFFB8C;
		esp_1528->dwFFFFFFFC = 0x00;
		esp_1528->dwFFFFFFF8 = eax_1532->dw0004;
		esp_1528->tFFFFFFF4.u0 = 0x0C;
		word32 ecx_2317;
		word32 edi_2320;
		word32 edx_2318;
		word32 ebx_2319;
		_dl_signal_error(gs_1095, esp_1528->tFFFFFFF4, esp_1528->t0000, out ecx_2317, out edx_2318, out ebx_2319, out ebp_1062, out edi_2320);
		esp_1107 = esp_1528 - 0x10;
		goto l0809B189;
	}
	else
	{
		Eq_141598 esp_1060;
		Eq_2 eax_503;
		struct Eq_141600 * ebx_234 = ebp_1062->ptrFFFFFB80;
		ebp_1062->tFFFFFB98 = 0x00;
		ebp_1062->ptrFFFFFB70 = (struct Eq_155451 *) ebx_234;
		ebp_1062->ptrFFFFFB58 = 135060900;
		while (eax_229 == 0x01)
		{
			Eq_2 eax_265;
			Eq_141633 esp_244 = esp_1077 - 0x0C;
			esi_1328 = (word32) edi_2135[1].dw0000 + ebp_1062->dwFFFFFB94;
			*((word32) esp_244 - 4) = esi_1328;
			Eq_2 eax_253 = _dl_dst_count(*((word32) esp_244 - 4));
			gs_1095 = gs;
			esp_1077 = esp_244 + 0x0C;
			Eq_2 ebx_261 = eax_253;
			if (eax_253 != 0x00)
			{
				Eq_141623 esp_294;
				if (*(union Eq_4933 *) 0x080CDDAC != 0x00)
				{
					*((word32) esp_244 + 8) = ebp_1062->dwFFFFFBA4 + 4294884004;
					*((word32) esp_244 + 4) = 0x00;
					*esp_244 = esi_1328;
					*((word32) esp_244 - 4) = 0x00;
					word32 edx_2321;
					word32 ebx_2322;
					word32 edi_2323;
					_dl_signal_error(gs, *((word32) esp_244 - 4), *((word32) esp_244 + 8), out ecx_1888, out edx_2321, out ebx_2322, out ebp_1062, out edi_2323);
					esp_294 = (word32) esp_244 - 8;
l0809B0B4:
					edi_2081 = ebp_1062->dwFFFFFBA4;
					struct Eq_143815 * esp_323 = esp_294 - (struct Eq_143816 *) 4;
					esp_323->a0000[0].t0000.u2.t0000 = edi_2081 + 4294884400;
					esp_323->dwFFFFFFFC = 244;
					esp_2086 = esp_323 - (struct Eq_143827 *) 4;
l0809B0C6:
					struct Eq_143087 * esp_2091 = esp_2086 - 4;
					esp_2091->dw0000 = edi_2081 + 4294883945;
					esp_2091->dwFFFFFFFC = edi_2081 + ~0x0001B01F;
					word32 edx_2360;
					word32 ecx_2359;
					__assert_fail(out ecx_2359, out edx_2360);
					Eq_2 esp_2098 = <invalid>;
					esp_1979 = (word32) esp_2098 - 4;
					goto l0809B0D9;
				}
				Eq_2 eax_349;
				*((word32) esp_244 - 4) = esi_1328;
				word32 edx_2324;
				Eq_2 eax_299 = strlen(*((word32) esp_244 - 4), out ecx_1888, out edx_2324);
				ebp_1062->ptrFFFFFB9C = (uint32 *) eax_299;
				esp_294 = (word32) esp_244 + 0x0C;
				Eq_2 edx_307 = eax_299;
				Eq_2 eax_310 = ebp_1062->ptrFFFFFBA0->t01AC;
				if (eax_310 != 0x00)
				{
					if (eax_310 != ~0x00)
						goto l0809A49E;
					goto l0809A78B;
				}
				if (*ebp_1062->ptrFFFFFBA0->t0004 != 0x00)
					goto l0809B0B4;
				ebp_1062->dwFFFFFB88 = (word32) eax_299;
				eax_310 = _dl_get_origin(gs, *((word32) esp_244 + 0x0C), out ebx_261, out esi_1328, out edi_2135);
				edx_307 = ebp_1062->dwFFFFFB88;
				ebp_1062->ptrFFFFFBA0->t01AC = eax_310;
				esp_294 = esp_244 + 0x10;
				if (eax_310 > ~0x01)
				{
l0809A78B:
					eax_349.u0 = 0x00;
				}
				else
				{
l0809A49E:
					ebp_1062->dwFFFFFB88 = (word32) edx_307;
					struct Eq_141712 * esp_353 = esp_294 - 0x0C;
					esp_353->tFFFFFFFC = eax_310;
					word32 edx_2326;
					word32 ecx_2325;
					eax_349 = strlen(esp_353->tFFFFFFFC, out ecx_2325, out edx_2326);
					edx_307 = ebp_1062->dwFFFFFB88;
					esp_294 = (char *) &esp_353->tFFFFFFFC + 16;
				}
				if (_dl_platformlen >= eax_349)
					eax_349 = _dl_platformlen;
				if (eax_349 > 0x04)
					ebp_1062->ptrFFFFFB9C = (word32) edx_307 + (eax_349 - 0x04) *s ebx_261;
				word32 ebx_400 = ebp_1062->ptrFFFFFB9C;
				Eq_141623 edx_409 = esp_294 - (ebx_400 + 0x1B & ~0x0FFF);
				ui32 eax_410 = ebx_400 + 0x1B & ~0x0F;
				while (esp_294 != edx_409)
				{
					esp_294 -= 0x1000;
					*((word32) esp_294 + 0x0FFC) = *((word32) esp_294 + 0x0FFC);
				}
				if ((eax_410 & 0x0FFF) != 0x00)
				{
					esp_294 -= eax_410 & 0x0FFF;
					Mem432[esp_294 - 0x04 + (eax_410 & 0x0FFF):word32] = Mem430[esp_294 - 0x04 + (eax_410 & 0x0FFF):word32];
				}
				struct Eq_141896 * esp_437 = esp_294 - 0x04;
				Mem442[esp_437 + -4:word32] = esp_294 + 0x0F & ~0x0F;
				esp_437->tFFFFFFF8 = esi_1328;
				esp_437->tFFFFFFF4 = ebp_1062->ptrFFFFFBA0;
				eax_265 = _dl_dst_substitute(esp_437->tFFFFFFF4, esp_437->tFFFFFFF8, esp_437->tFFFFFFFC, out ecx_102);
				esp_1077 = (char *) &esp_437->tFFFFFFFC + 8;
				if (*eax_265 != 0x00)
					goto l0809A539;
				if ((_dl_debug_mask & 0x01) != 0x00)
				{
					esp_437->tFFFFFFF8 = esi_1328;
					esp_1060 = esp_437 - 0x08;
					goto l0809A7B1;
				}
			}
			else
			{
				eax_265 = esi_1328;
l0809A539:
				ebp_1062->dwFFFFFBD0 = (word32) eax_265;
				struct Eq_142018 * esp_479 = esp_1077 - 0x04;
				esp_479->tFFFFFFFC = ebp_1062 - 0x0440;
				esp_479->tFFFFFFF8 = ebp_1062->dwFFFFFBA4 + ~0x00033F7F;
				esp_479->tFFFFFFF4 = ebp_1062 - 1100;
				Eq_2 esp_507 = <invalid>;
				word32 edx_2333;
				word32 ebx_2334;
				eax_503 = _dl_catch_exception(gs, esp_479->tFFFFFFF4, esp_479->tFFFFFFF8, esp_479->tFFFFFFFC, out ecx_102, out edx_2333, out ebx_2334);
				esp_1077 = (word32) esp_507 + 16;
				if (ebp_1062->dwFFFFFBB8 != 0x00)
					goto l0809A7D0;
				struct Eq_142068 * eax_517 = ebp_1062->dwFFFFFBD4;
				if ((eax_517->b0198 & 0x60) == 0x00)
				{
					if ((word32) esp_507 + 16 != (word32) esp_507 + 16)
					{
						do
						{
							esp_1077 -= 0x1000;
							*((word32) esp_1077 + 0x0FFC) = *((word32) esp_1077 + 0x0FFC);
						} while (esp_1077 != (word32) esp_507 + 16);
					}
					esp_1077 -= 0x20;
					*((word32) esp_1077 + 28) = *((word32) esp_1077 + 28);
					struct Eq_142095 * esi_541 = ebp_1062->dwFFFFFB84;
					++ebp_1062->dwFFFFFB7C;
					word32 edx_545 = esp_1077 + 0x0F & ~0x0F;
					edx_545->ptr0004 = eax_517;
					edx_545->dw0000 = 0x00;
					edx_545->dw0008 = 0x00;
					esi_541->ptr0008 = edx_545;
					ui32 ecx_552 = (word32) eax_517->b0198;
					ebp_1062->dwFFFFFB84 = edx_545;
					eax_517->b0198 = (byte) (ecx_552 & ~0x60 | 0x20);
				}
				ecx_102 = ebp_1062->ptrFFFFFB90;
				if (ecx_102 != 0x00)
				{
					Eq_142194 ebx_566 = ebp_1062->tFFFFFB98;
					*((word32) ecx_102 + ebx_566 * 0x04) = eax_517;
					ebp_1062->tFFFFFB98 = (word32) ebx_566 + 1;
				}
			}
l0809A5FE:
			edi_2135 += 2;
			eax_229 = edi_2135->dw0000;
			if (eax_229 == 0x00)
				goto l0809A2CF;
		}
		gs_1095 = gs;
		if ((eax_229 & ~0x02) == 0x7FFFFFFD)
		{
			Eq_142239 esp_588 = esp_1077 - 0x0C;
			ebx_1319 = (word32) edi_2135[1].dw0000 + ebp_1062->dwFFFFFB94;
			*((word32) esp_588 - 4) = ebx_1319;
			Eq_2 eax_598 = _dl_dst_count(*((word32) esp_588 - 4));
			esp_1077 = esp_588 + 0x0C;
			esi_1328 = eax_598;
			if (eax_598 == 0x00)
			{
l0809AC00:
				byte * eax_788 = ebp_1062->dwFFFFFB5C;
				ebp_1062->dwFFFFFBD0 = (word32) ebx_1319;
				if ((*eax_788 & 0x01) != 0x00)
				{
					Eq_2 eax_795 = ebp_1062->ptrFFFFFBA0->t0004;
					if (*eax_795 == 0x00)
					{
						word32 esi_799 = ebp_1062->dwFFFFFBA4;
						eax_795 = **ebp_1062->ptrFFFFFB58;
						if (eax_795 == 0x00)
							eax_795 = esi_799 + ~0x0001B534;
					}
					Eq_143732 esp_809 = esp_1077 - 0x04;
					*((word32) esp_809 - 4) = eax_795;
					word32 eax_815 = ebp_1062->dwFFFFFBA4;
					*((word32) esp_809 - 8) = ebx_1319;
					*((word32) esp_809 - 0x0C) = eax_815 + ~0x000144BB;
					word32 edx_2373;
					word32 ecx_2372;
					_dl_debug_printf(out ecx_2372, out edx_2373);
				}
				Eq_143508 esp_833 = esp_1077 - 0x04;
				*((word32) esp_833 - 4) = ebp_1062 - 0x0440;
				*((word32) esp_833 - 8) = ebp_1062->dwFFFFFBA4 + ~0x00033F7F;
				*((word32) esp_833 - 0x0C) = ebp_1062 - 1100;
				Eq_2 esp_861 = <invalid>;
				struct Eq_126606 * ebx_858;
				word32 edx_2371;
				eax_503 = _dl_catch_exception(gs, *((word32) esp_833 - 0x0C), *((word32) esp_833 - 8), *((word32) esp_833 - 4), out ecx_102, out edx_2371, out ebx_858);
				esp_1077 = (word32) esp_861 + 16;
				if (ebp_1062->dwFFFFFBB8 == 0x00)
				{
					if ((word32) esp_861 + 16 != (word32) esp_861 + 16)
					{
						do
						{
							esp_1077 -= 0x1000;
							*((word32) esp_1077 + 0x0FFC) = *((word32) esp_1077 + 0x0FFC);
						} while (esp_1077 != (word32) esp_861 + 16);
					}
					esp_1077 -= 0x20;
					*((word32) esp_1077 + 28) = *((word32) esp_1077 + 28);
					struct Eq_143569 * esi_927 = ebp_1062->ptrFFFFFB70;
					word32 ecx_928[] = ebp_1062->ptrFFFFFB90;
					word32 ebx_931 = esp_1077 + 0x0F & ~0x0F;
					*ebx_931 = esi_927->dw0000;
					*((word32) ebx_931 + 4) = esi_927->ptr0004;
					*((word32) ebx_931 + 8) = esi_927->dw0008;
					struct Eq_143590 * eax_937 = ebp_1062->dwFFFFFBD4;
					esi_927->dw0000 = 0x00;
					esi_927->ptr0004 = eax_937;
					if (ecx_928 != null)
					{
						Eq_143632 esi_943 = ebp_1062->tFFFFFB98;
						ecx_928[esi_943] = eax_937;
						eax_937 = ebp_1062->dwFFFFFBD4;
						ebp_1062->tFFFFFB98 = (word32) esi_943 + 1;
					}
					struct Eq_143623 * ecx_1010;
					struct Eq_143624 * edx_1005;
					if ((eax_937[0x0022] & 0x60) == 0x00)
					{
						struct Eq_143650 * esi_995 = ebp_1062->ptrFFFFFB70;
						ecx_1010 = eax_937->dw0010;
						++ebp_1062->dwFFFFFB7C;
						esi_995->t0008 = ebx_931;
						eax_937[0x0022] = (struct Eq_143590) (byte) ((word32) eax_937[0x0022] & ~0x60 | 0x20);
						edx_1005 = (struct Eq_143624 *) eax_937[1];
						if (ecx_1010 != null)
						{
l0809ACF1:
							ecx_1010->ptr000C = edx_1005;
							edx_1005 = (struct Eq_143624 *) eax_937[1];
						}
l0809ACF7:
						if (edx_1005 != null)
							edx_1005->ptr0010 = ecx_1010;
						struct Eq_143590 * edx_1026 = *((word32) ebx_931 + 4);
						eax_937->dw0010 = edx_1026->dw0010;
						edx_1026->dw0010 = eax_937;
						ecx_102 = eax_937->dw0010;
						if (ecx_102 != 0x00)
							*((word32) ecx_102 + 0x0C) = eax_937;
						eax_937[1] = (struct Eq_143590) edx_1026;
						if (ebp_1062->dwFFFFFB84 != ebp_1062->ptrFFFFFB70)
							ebp_1062->ptrFFFFFB70 = (struct Eq_155451 *) ebx_931;
						else
						{
							ebp_1062->ptrFFFFFB70 = (struct Eq_155451 *) ebx_931;
							ebp_1062->dwFFFFFB84 = (word32) ebx_931;
						}
					}
					else
					{
						ecx_102 = ebx_931;
						while (true)
						{
							Eq_2 edx_957 = *((word32) ecx_102 + 8);
							if (edx_957 == 0x00)
								break;
							if (eax_937 == *((word32) edx_957 + 4))
							{
								ebp_1062->ptrFFFFFB70->t0008 = ebx_931;
								Eq_2 edx_969 = *((word32) ecx_102 + 8);
								Eq_2 esi_968 = ebp_1062->dwFFFFFB84;
								word32 edx_971 = *((word32) edx_969 + 8);
								if (edx_969 == esi_968)
									esi_968 = ecx_102;
								*((word32) ecx_102 + 8) = edx_971;
								ecx_1010 = eax_937->dw0010;
								ebp_1062->dwFFFFFB84 = (word32) esi_968;
								edx_1005 = (struct Eq_143624 *) eax_937[1];
								if (ecx_1010 == null)
									goto l0809ACF7;
								goto l0809ACF1;
							}
							ecx_102 = edx_957;
						}
						struct Eq_143790 * esi_988 = ebp_1062->ptrFFFFFB70;
						esi_988->dw0000 = (word32) *ebx_931;
						esi_988->ptr0004 = (struct Eq_143590 *) *((word32) ebx_931 + 4);
						esi_988->dw0008 = (word32) *((word32) ebx_931 + 8);
					}
					goto l0809A5FE;
				}
				if (edi_2135->dw0000 == 0x7FFFFFFD)
				{
					*esp_861 = ebx_858;
					_dl_exception_free(*esp_861);
					Eq_2 esp_900 = <invalid>;
					esp_1077 = (word32) esp_900 + 16;
					goto l0809A5FE;
				}
l0809A7D0:
				ebp_1062->dwFFFFFB84 = (word32) eax_503;
				if (eax_503 == 0x00)
					ebp_1062->dwFFFFFB84 = ~0x00;
l0809A7EA:
				gs_1095 = gs;
				Eq_2 eax_1184 = ebp_1062->dwFFFFFBD8;
				if (eax_1184 != ebp_1062->dwFFFFFB68)
				{
					struct Eq_141819 * esp_1191 = esp_1077 - 0x0C;
					esp_1191->tFFFFFFFC = eax_1184;
					word32 edx_2328;
					free(gs, esp_1191->tFFFFFFF8, esp_1191->tFFFFFFFC, out ecx_102, out edx_2328);
					esp_1077 = (char *) &esp_1191->tFFFFFFFC + 20;
				}
				word32 Eq_9::* eax_1212 = ebp_1062->dwFFFFFB64;
				if (gs->*eax_1212 == 0x00)
				{
					word32 esi_1218 = ebp_1062->dwFFFFFB60;
					if (esi_1218 != 0x00)
						gs->*eax_1212 = esi_1218;
				}
				struct Eq_141861 * esi_1225 = ebp_1062->ptrFFFFFB8C;
				struct Eq_141865 * eax_1226 = esi_1225->ptr01F4;
				ebp_1062->ptrFFFFFB80 = (struct Eq_155452 *) eax_1226;
				if (eax_1226 == null)
				{
l0809A85C:
					struct Eq_141946 * esp_1293 = esp_1077 - 0x0C;
					esp_1293->tFFFFFFFC = ebp_1062->dwFFFFFB7C * 0x08 + 0x04;
					word32 esi_2332;
					word32 edx_2330;
					word32 ecx_2329;
					word32 ebx_2331;
					Eq_141963 edi_1305;
					Eq_2 eax_1301 = __libc_malloc(gs, esp_1293->tFFFFFFF8, esp_1293->tFFFFFFFC, out ecx_2329, out edx_2330, out ebx_2331, out ebp_1062, out esi_2332, out edi_1305);
					ebp_1062->dwFFFFFB94 = (word32) eax_1301;
					esp_1107 = (char *) &esp_1293->tFFFFFFFC + 16;
					if (eax_1301 == 0x00)
					{
l0809B16A:
						eax_1526 = ebp_1062->dwFFFFFBA4 + ~0x00014447;
						goto l0809B176;
					}
					ui32 eax_1318 = ebp_1062->dwFFFFFB7C;
					ebx_1319 = ebp_1062->ptrFFFFFB8C;
					word32 edx_1320 = ebp_1062->dwFFFFFB78;
					Eq_2 ecx_1321[] = ebp_1062->dwFFFFFB94 + 0x04 + eax_1318 * 0x04;
					ebp_1062->ptrFFFFFB90 = (word32 *) ecx_1321;
					*((word32) ebx_1319 + 352) = ecx_1321;
					*((word32) ebx_1319 + 356) = eax_1318;
					esi_1328.u0 = 0x00;
					do
					{
						Eq_2 eax_1331 = *((word32) edi_1305 + 4);
						if (edx_1320 == 0x00 || (*((word32) eax_1331 + 0x0199) & 0x02) == 0x00)
						{
							ecx_1321[esi_1328] = eax_1331;
							eax_1331 = *((word32) edi_1305 + 4);
							esi_1328 = (word64) esi_1328.u0 + 1;
						}
						else
						{
							ebx_1319 = ebp_1062->ptrFFFFFB8C;
							--*((word32) ebx_1319 + 356);
						}
						*((word32) eax_1331 + 408) &= ~0x60;
						edi_1305 = *((word32) edi_1305 + 8);
					} while (edi_1305 != 0x00);
					if ((g_b80CFF05 & 0x08) != 0x00 && (g_t80CEA00 == ebp_1062->ptrFFFFFB8C && esi_1328 != 0x00))
					{
						ebp_1062->dwFFFFFB88 = (word32) edi_1305;
						word32 edx_1386[] = ebp_1062->ptrFFFFFB90;
						ebp_1062->ptrFFFFFBA0 = (struct Eq_155456 *) esi_1328;
						struct Eq_143145 * edi_1387 = null;
						do
						{
							esp_1430 = esp_1077;
							esi_1328 = edx_1386[edi_1387];
							if (ebp_1062->ptrFFFFFB8C != esi_1328)
							{
								struct Eq_143184 * eax_1396 = *((word32) esi_1328 + 468);
								if (eax_1396 == null || eax_1396->dw0004 == 0x00)
								{
									if (*((word32) esi_1328 + 244) != 0x00 || *((word32) esi_1328 + 0x00EC) != 0x00)
										goto l0809B118;
									Eq_141011 eax_1417 = _dl_build_local_scope(ebp_1062->dwFFFFFB94, esi_1328);
									if (eax_1417 > ebp_1062->ptrFFFFFBA0)
									{
										word32 edi_1427 = ebp_1062->dwFFFFFBA4;
										Eq_143262 esp_1431 = esp_1077 - 4;
										*esp_1431 = edi_1427 + 4294884400;
										*((word32) esp_1431 - 4) = 0x0210;
										*((word32) esp_1431 - 8) = edi_1427 + 4294883945;
										*((word32) esp_1431 - 0x0C) = edi_1427 + 4294883955;
										word32 edx_2365;
										word32 ecx_2364;
										__assert_fail(out ecx_2364, out edx_2365);
										Eq_2 esp_1443 = <invalid>;
										esp_1107 = (word32) esp_1443 - 4;
										goto l0809B16A;
									}
									if (eax_1417 != 0x00)
									{
										struct Eq_143350 ** ebx_1452 = ebp_1062->dwFFFFFB94;
										struct Eq_143350 * eax_1453 = *ebx_1452;
										eax_1453->b0198 &= ~0x60;
										struct Eq_143362 ** eax_1458 = (char *) ebx_1452 + 4;
										struct Eq_143362 ** ebx_1459 = (char *) ebx_1452 + eax_1417 * 0x04;
										while (ebx_1459 != eax_1458)
										{
											struct Eq_143410 * ecx_1465 = *eax_1458;
											ecx_1465->b0198 &= ~0x60;
											if (*((char *) *eax_1458 + 96) != 0x00)
												*((word32) esi_1328 + 0x0199) |= 0x80;
											eax_1458 = (struct Eq_143362 **) ((char *) eax_1458 + 4);
										}
									}
									ebp_1062->tFFFFFB98.u3 = eax_1417;
									Eq_2 ecx_1485 = eax_1417 * 0x04 + 0x08;
									Eq_143303 esp_1489 = esp_1077 - 0x0C;
									*((word32) esp_1489 - 4) = ecx_1485;
									ebp_1062->ptrFFFFFB9C = (uint32 *) ecx_1485;
									struct Eq_143312 * esi_1511;
									word32 edx_2367;
									word32 ebx_2368;
									word32 ecx_2366;
									Eq_2 eax_1505 = __libc_malloc(gs, *((word32) esp_1489 - 8), *((word32) esp_1489 - 4), out ecx_2366, out edx_2367, out ebx_2368, out ebp_1062, out esi_1511, out edi_1387);
									uint32 * ecx_1517 = ebp_1062->ptrFFFFFB9C;
									Eq_143335 edx_1518 = ebp_1062->tFFFFFB98;
									esi_1511->t01D4 = eax_1505;
									esp_1107 = esp_1489 + 0x0C;
									if (eax_1505 == 0x00)
										goto l0809B16A;
									*((word32) eax_1505 + 4) = edx_1518;
									*eax_1505 = (word32) eax_1505 + 8;
									ebx_1319 = ebp_1062->dwFFFFFBA4;
									*((word32) esp_1489 + 4) = ecx_1517 - 0x08;
									*esp_1489 = ebp_1062->dwFFFFFB94;
									*((word32) esp_1489 - 4) = (word32) eax_1505 + 8;
									word32 edx_2370;
									word32 ecx_2369;
									memcpy(*((word32) esp_1489 - 4), *esp_1489, *((word32) esp_1489 + 4), out ecx_2369, out edx_2370);
									edx_1386 = ebp_1062->ptrFFFFFB8C->ptr0160;
								}
							}
							edi_1387 = (struct Eq_143145 *) ((char *) edi_1387->a0000 + 1);
						} while (edi_1387 != ebp_1062->ptrFFFFFBA0);
						ebp_1062->ptrFFFFFB90 = edx_1386;
						edi_1305 = ebp_1062->dwFFFFFB88;
						esi_1328 = ebp_1062->ptrFFFFFBA0;
					}
					if (*ebp_1062->ptrFFFFFB90 != ebp_1062->ptrFFFFFB8C)
					{
						word32 edi_1621 = ebp_1062->dwFFFFFBA4;
						Eq_142436 esp_1628 = esp_1077 - 4;
						*esp_1628 = edi_1621 + 4294884400;
						*((word32) esp_1628 - 4) = 0x0229;
						*((word32) esp_1628 - 8) = edi_1621 + 4294883945;
						*((word32) esp_1628 - 0x0C) = edi_1621 + ~0x000143F3;
						Eq_2 esp_1640 = <invalid>;
						word32 ecx_2341;
						word32 edx_2342;
						eax_1052 = __assert_fail(out ecx_2341, out edx_2342);
						esp_1077 = (word32) esp_1640 - 4;
						goto l0809B1DC;
					}
					union Eq_142480 * eax_1649 = ebp_1062->ptrFFFFFB8C->ptr01F8;
					ebp_1062->ptrFFFFFB9C = (uint32 *) eax_1649;
					if (eax_1649 == null)
					{
						edi_1305.u0 = 0x00;
						goto l0809AAD1;
					}
					Eq_142480 ecx_1657 = *eax_1649;
					ebp_1062->ptrFFFFFBA0 = (struct Eq_155456 *) ((char *) eax_1649 + 4);
					ebp_1062->tFFFFFB98 = ecx_1657;
					if (esi_1328 > 0x01)
					{
						word32 * eax_1668 = ebp_1062->ptrFFFFFB90;
						word32 * edx_1669 = eax_1668 + 1;
						word32 * ebx_1670 = eax_1668 + esi_1328 * 0x04;
						do
						{
							struct Eq_142510 * ecx_1674 = *edx_1669;
							ecx_1674->b0198 = (byte) ((word32) ecx_1674->b0198 & ~0x60 | 0x20);
							++edx_1669;
						} while (ebx_1670 != edx_1669);
						if (ebp_1062->tFFFFFB98 == 0x00)
							goto l0809AAB1;
					}
					else if (ebp_1062->tFFFFFB98 == 0x00)
						goto l0809AAD1;
					ebp_1062->dwFFFFFB7C = (ui32) esi_1328;
					ebp_1062->tFFFFFB98.u4 = edi_1305;
					uint32 esi_1700 = 0x00;
					do
					{
						ui32 edx_1705 = esi_1700 * 0x04;
						uint32 edi_1706 = esi_1700 + 0x01;
						if ((*((word32) ebp_1062->ptrFFFFFBA0[esi_1700 * 0x04 / 432].dw0160 + 56) & 0x60) != 0x00)
						{
							struct Eq_142592 * eax_1711 = ebp_1062->ptrFFFFFB8C;
							ebp_1062->dwFFFFFB88 = edx_1705;
							Eq_142599 esp_1713 = esp_1077 - 0x0C;
							*((word32) esp_1713 - 4) = eax_1711->dw01FC * 0x04 + 0x04;
							ui32 esi_1728;
							word32 edx_2344;
							word32 ecx_2343;
							word32 ebx_2345;
							Eq_2 eax_1722 = __libc_malloc(gs, *((word32) esp_1713 - 8), *((word32) esp_1713 - 4), out ecx_2343, out edx_2344, out ebx_2345, out ebp_1062, out esi_1728, out edi_1706);
							Eq_2 edx_1734 = ebp_1062->dwFFFFFB88;
							ebp_1062->tFFFFFB98 = eax_1722;
							if (eax_1722 != 0x00)
							{
								ui32 ecx_1772;
								ebp_1062->dwFFFFFB78 = (word32) edx_1734;
								*((word32) esp_1713 + 4) = edx_1734;
								*esp_1713 = ebp_1062->ptrFFFFFBA0;
								*((word32) esp_1713 - 4) = (word32) eax_1722 + 4;
								word32 ecx_2346;
								word32 edx_2347;
								memcpy(*((word32) esp_1713 - 4), *esp_1713, *((word32) esp_1713 + 4), out ecx_2346, out edx_2347);
								uint32 * eax_1766 = ebp_1062->ptrFFFFFB9C;
								uint32 ebx_1768 = *eax_1766;
								ebp_1062->dwFFFFFB88 = ebx_1768;
								if (ebx_1768 > edi_1706)
								{
									int32 edx_1773 = ebp_1062->dwFFFFFB78;
									struct Eq_142689 * ecx_1774 = ebp_1062->ptrFFFFFBA0;
									ebp_1062->dwFFFFFB78 = esi_1728;
									word32 * ebx_1776 = ecx_1774 + (ebx_1768 * 0x04) / 432;
									word32 * eax_1777 = eax_1766 + 2 + edx_1773;
									ecx_1772 = esi_1728;
									do
									{
										Eq_2 edx_1782 = *eax_1777;
										if ((*((word32) edx_1782 + 408) & 0x60) == 0x00)
										{
											*((word32) ebp_1062->tFFFFFB98 + (ecx_1772 * 0x04 + 4)) = edx_1782;
											++ecx_1772;
										}
										++eax_1777;
									} while (eax_1777 != ebx_1776);
									edi_1706 = ebp_1062->dwFFFFFB88 - 0x01 + edi_1706 - ebp_1062->dwFFFFFB78;
								}
								else
									ecx_1772 = esi_1728;
								*ebp_1062->tFFFFFB98 = ecx_1772;
								uint32 edi_1811 = edi_1706 + 0x01;
								esi_1700 = edi_1811;
								if (*ebp_1062->ptrFFFFFB9C <= edi_1811)
									break;
								continue;
							}
						}
						esi_1700 = edi_1706;
					} while (*ebp_1062->ptrFFFFFB9C > edi_1706);
					esi_1328 = ebp_1062->dwFFFFFB7C;
					edi_1305 = ebp_1062->tFFFFFB98;
					if (esi_1328 <= 0x01)
					{
l0809AAD1:
						Eq_142733 esp_1852 = esp_1077 - 0x04;
						*((word32) esp_1852 - 4) = esi_1328 * 0x04;
						*((word32) esp_1852 - 8) = ebp_1062->ptrFFFFFB90;
						*((word32) esp_1852 - 0x0C) = ebp_1062->dwFFFFFB94;
						word32 ecx_2348;
						word32 edx_2349;
						memcpy(*((word32) esp_1852 - 0x0C), *((word32) esp_1852 - 8), *((word32) esp_1852 - 4), out ecx_2348, out edx_2349);
						word32 ebx_1876[] = ebp_1062->dwFFFFFB94;
						*((word32) esp_1852 - 16) = 0x00;
						*((word32) esp_1852 - 20) = null;
						*((word32) esp_1852 - 24) = esi_1328 - (struct Eq_142780 *) 0x01;
						*((word32) esp_1852 - 28) = ebx_1876 + 1;
						ecx_1888 = _dl_sort_maps(*((word32) esp_1852 - 28), *((word32) esp_1852 - 24), *((word32) esp_1852 - 20), *((word32) esp_1852 - 16));
						ebx_1876[esi_1328] = 0x00;
						esi_1328 = ebp_1062->ptrFFFFFB8C;
						*((word32) esi_1328 + 500) = ebx_1876;
						*((word32) esi_1328 + 410) |= 0x01;
						if (edi_1305 != 0x00)
						{
							Eq_2 eax_1907 = *((word32) esi_1328 + 504);
							*((word32) esi_1328 + 504) = edi_1305;
							*((word32) esp_1852 - 0x0C) = eax_1907;
							word32 ebx_2350;
							word32 edi_2351;
							_dl_scope_free(gs, *((word32) esp_1852 - 0x0C), out ecx_1888, out ebx_2350, out esi_1328, out edi_2351);
						}
						Eq_2 eax_1942 = ebp_1062->ptrFFFFFB80;
						if (eax_1942 != 0x00)
						{
							Eq_142979 esp_1947 = esp_1077 - 0x0C;
							*((word32) esp_1947 - 4) = eax_1942;
							word32 ebx_2353;
							word32 edi_2354;
							_dl_scope_free(gs, *((word32) esp_1947 - 4), out ecx_1888, out ebx_2353, out esi_1328, out edi_2354);
						}
						esp_1979 = esp_1077;
						if (ebp_1062->dwFFFFFB84 == 0x00)
						{
							struct Eq_143001 * esp_2104 = ebp_1062 - 0x10;
							word32 ebx_2107 = esp_2104->dw0004;
							ptr32 edi_2111 = esp_2104->ptr000C;
							ebpOut = esp_2104->ptr0010;
							ediOut = edi_2111;
							return ebx_2107;
						}
l0809B0D9:
						if (ebp_1062->dwFFFFFB84 == ~0x00)
							ebp_1062->dwFFFFFB84 = 0x00;
						Eq_143051 esp_1980 = esp_1979 - 4;
						*esp_1980 = ecx_1888;
						*((word32) esp_1980 - 4) = 0x00;
						*((word32) esp_1980 - 8) = ebp_1062 - 1100;
						*((word32) esp_1980 - 0x0C) = ebp_1062->dwFFFFFB84;
						_dl_signal_exception(gs_1095, *((word32) esp_1980 - 0x0C), *((word32) esp_1980 - 8), out ebx_1319);
						esp_1077 = esp_1980 - 0x10;
l0809B101:
						eax_1647 = ebp_1062->dwFFFFFBA4 + 4294884004;
						goto l0809B10D;
					}
l0809AAB1:
					word32 ecx_1828[] = ebp_1062->ptrFFFFFB90;
					Eq_2 eax_1829 = 0x01;
					do
					{
						struct Eq_142718 * edx_1835 = ecx_1828[eax_1829];
						edx_1835->b0198 &= ~0x60;
						eax_1829 = (word32) eax_1829 + 1;
					} while (eax_1829 < esi_1328);
					goto l0809AAD1;
				}
				ui32 eax_1231 = (word32) esi_1225->b0198;
				ebp_1062->ptrFFFFFBA0 = (struct Eq_155456 *) (byte) eax_1231;
				if ((byte) (eax_1231 & 0x03) != 0x02)
				{
					ebp_1062->ptrFFFFFB80 = (struct Eq_155452 *) null;
					goto l0809A85C;
				}
				if (esi_1225->dw0160 == 0x00)
					goto l0809A85C;
				word32 edi_1242 = ebp_1062->dwFFFFFBA4;
				Eq_142156 esp_1246 = esp_1077 - 4;
				*esp_1246 = edi_1242 + 4294884400;
				*((word32) esp_1246 - 4) = 0x01D8;
				*((word32) esp_1246 - 8) = edi_1242 + 4294883945;
				*((word32) esp_1246 - 0x0C) = edi_1242 + 4294884244;
				Eq_2 esp_1258 = <invalid>;
				word32 edx_2336;
				word32 ecx_2335;
				eax_1256 = __assert_fail(out ecx_2335, out edx_2336);
				esp_1077 = (word32) esp_1258 - 4;
				goto l0809AD78;
			}
			if (*(union Eq_4933 *) 0x080CDDAC != 0x00)
				goto l0809B101;
			Eq_2 eax_665;
			*((word32) esp_588 - 4) = ebx_1319;
			word32 ecx_2337;
			word32 edx_2338;
			Eq_2 eax_620 = strlen(*((word32) esp_588 - 4), out ecx_2337, out edx_2338);
			ebp_1062->ptrFFFFFB9C = (uint32 *) eax_620;
			esp_2078 = esp_588 + 0x0C;
			ecx_1888 = eax_620;
			Eq_2 eax_631 = ebp_1062->ptrFFFFFBA0->t01AC;
			if (eax_631 != 0x00)
			{
				if (eax_631 != ~0x00)
					goto l0809A684;
			}
			else
			{
				if (*ebp_1062->ptrFFFFFBA0->t0004 != 0x00)
					goto l0809B131;
				ebp_1062->dwFFFFFB88 = (word32) eax_620;
				eax_631 = _dl_get_origin(gs, Mem639[esp_588 + 0x0C:word32], out ebx_1319, out esi_1328, out edi_2135);
				ebp_1062->ptrFFFFFBA0->t01AC = eax_631;
				esp_2078 = esp_588 + 0x10;
				ecx_1888 = ebp_1062->dwFFFFFB88;
				if (eax_631 <= ~0x01)
				{
l0809A684:
					ebp_1062->dwFFFFFB88 = (word32) ecx_1888;
					Eq_142330 esp_669 = esp_2078 - 0x0C;
					*((word32) esp_669 - 4) = eax_631;
					word32 ecx_2339;
					word32 edx_2340;
					eax_665 = strlen(*((word32) esp_669 - 4), out ecx_2339, out edx_2340);
					ecx_1888 = ebp_1062->dwFFFFFB88;
					esp_2078 = esp_669 + 0x0C;
l0809A69C:
					if (_dl_platformlen >= eax_665)
						eax_665 = _dl_platformlen;
					if (eax_665 > 0x04)
					{
						esi_1328 *= eax_665 - 0x04;
						ecx_1888 = Mem689[ebp_1062 + -0x0464:word32] + esi_1328;
					}
					ui32 ecx_715 = (word32) ecx_1888 + 27;
					Eq_141738 edx_723 = esp_2078 - (ecx_715 & ~0x0FFF);
					while (esp_2078 != edx_723)
					{
						esp_2078 -= 0x1000;
						*((word32) esp_2078 + 0x0FFC) = *((word32) esp_2078 + 0x0FFC);
					}
					Eq_142851 eax_738 = ecx_715 & ~0x0F & 0x0FFF;
					if (eax_738 != 0x00)
					{
						esp_2078 -= eax_738;
						Mem747[esp_2078 - 0x04 + eax_738:word32] = Mem744[esp_2078 - 0x04 + eax_738:word32];
					}
					Eq_142876 esp_752 = esp_2078 - 0x04;
					Mem757[esp_752 + -4:word32] = esp_2078 + 0x0F & ~0x0F;
					*((word32) esp_752 - 8) = ebx_1319;
					*((word32) esp_752 - 0x0C) = ebp_1062->ptrFFFFFBA0;
					Eq_2 eax_775 = _dl_dst_substitute(*((word32) esp_752 - 0x0C), *((word32) esp_752 - 8), *((word32) esp_752 - 4), out ecx_102);
					esp_1077 = esp_752 + 0x04;
					if (*eax_775 == 0x00)
					{
						eax_1052 = ebp_1062->dwFFFFFBA4;
						if (edi_2135->dw0000 != 0x7FFFFFFD)
						{
							if ((_dl_debug_mask & 0x01) != 0x00)
							{
								*((word32) esp_752 - 8) = ebx_1319;
								esp_1060 = esp_752 - 0x08;
l0809A7B1:
								Eq_142936 esp_1067 = esp_1060 - 4;
								*esp_1067 = ebp_1062->dwFFFFFBA4 + 4294884044;
								word32 edx_2352;
								_dl_debug_printf(out ecx_102, out edx_2352);
								esp_1077 = esp_1067 + 0x10;
								goto l0809A5FE;
							}
							goto l0809A5FE;
						}
l0809B1DC:
						gs_1095 = gs;
						eax_1647 = (word32) eax_1052 - 0x000144E4;
l0809B10D:
						Eq_143015 esp_2009 = esp_1077 - 4;
						*esp_2009 = eax_1647;
						*((word32) esp_2009 - 4) = 0x00;
						*((word32) esp_2009 - 8) = ebx_1319;
						*((word32) esp_2009 - 0x0C) = 0x00;
						word32 ecx_2355;
						word32 edi_2358;
						word32 edx_2356;
						word32 ebx_2357;
						_dl_signal_error(gs_1095, *((word32) esp_2009 - 0x0C), *esp_2009, out ecx_2355, out edx_2356, out ebx_2357, out ebp_1062, out edi_2358);
						esp_1430 = esp_2009 - 0x10;
l0809B118:
						Eq_143200 esp_2047 = esp_1430 - 4;
						*esp_2047 = ebp_1062->dwFFFFFBA4 + ~0x00014423;
						*((word32) esp_2047 - 4) = 0x00;
						*((word32) esp_2047 - 8) = *((word32) esi_1328 + 4);
						*((word32) esp_2047 - 0x0C) = 22;
						word32 edx_2361;
						word32 edi_2363;
						word32 ebx_2362;
						_dl_signal_error(gs_1095, *((word32) esp_2047 - 0x0C), *esp_2047, out ecx_1888, out edx_2361, out ebx_2362, out ebp_1062, out edi_2363);
						esp_2078 = esp_2047 - 0x10;
l0809B131:
						edi_2081 = ebp_1062->dwFFFFFBA4;
						Eq_143373 esp_2084 = esp_2078 - 4;
						*esp_2084 = edi_2081 + 4294884400;
						*((word32) esp_2084 - 4) = 288;
						esp_2086 = esp_2084 - 4;
						goto l0809B0C6;
					}
					ebx_1319 = eax_775;
					goto l0809AC00;
				}
			}
			eax_665.u0 = 0x00;
			goto l0809A69C;
		}
		goto l0809A5FE;
	}
}

// 0809B200: void call_init.part.0(Register Eq_2 eax, Register word32 ecx, Register word32 edx, Stack word32 dwArg04)
// Called from:
//      _dl_init
void call_init.part.0(Eq_2 eax, word32 ecx, word32 edx, word32 dwArg04)
{
	ui32 ebp_24 = (word32) *((word32) eax + 408);
	*((word32) eax + 408) = (byte) (ebp_24 | 0x08);
	byte * edx_134 = *((word32) eax + 4);
	byte cl_31 = *edx_134;
	if (cl_31 == 0x00 && ((ebp_24 | 0x08) & 0x03) == 0x00)
		return;
	struct Eq_22859 * eax_107;
	word32 ecx_133;
	Eq_2 eax_102 = *((word32) eax + 80);
	if (eax_102 != 0x00)
	{
		ecx_133 = 0x080CFF04;
		if ((_dl_debug_mask & 0x02) == 0x00)
			goto l0809B24E;
	}
	else
	{
		eax_107 = (struct Eq_22859 *) *((word32) eax + 0x0084);
		if (eax_107 == null)
			return;
		if ((_dl_debug_mask & 0x02) == 0x00)
		{
l0809B26C:
			word32 ecx_153 = *eax;
			uint32 edx_156 = *((word32) *((word32) eax + 0x008C) + 4);
			<anonymous> ** edi_157 = eax_107->dw0004 + ecx_153;
			uint32 edx_158 = edx_156 >> 0x02;
			if (edx_156 >> 0x02 != 0x00)
			{
				word32 eax_163 = ecx;
				<anonymous> ** ebp_164 = (char *) edi_157 + (edx_156 >> 0x02) * 0x04;
				<anonymous> ** ebx_168 = edi_157;
				do
				{
					(*ebx_168)();
					ebx_168 = (<anonymous> **) ((char *) ebx_168 + 4);
				} while (ebp_164 != ebx_168);
			}
			return;
		}
	}
	if (cl_31 == 0x00)
		**(union Eq_2 **) 135060900 != 0x00;
	_dl_debug_printf(out ecx_133, out edx_134);
	eax_102 = *((word32) eax + 80);
	if (eax_102 == 0x00)
	{
		eax_107 = (struct Eq_22859 *) *((word32) eax + 0x0084);
l0809B268:
		if (eax_107 == null)
			return;
		goto l0809B26C;
	}
l0809B24E:
	word32 eax_114 = Mem111[eax_102 + 0x04:word32] + Mem111[eax + 0x00:word32];
	eax_114();
	eax_107 = (struct Eq_22859 *) *((word32) eax + 0x0084);
	goto l0809B268;
}

// 0809B330: void _dl_init(Stack Eq_2 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      dl_open_worker
void _dl_init(Eq_2 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	Eq_2 eax_23 = _dl_initfirst;
	struct Eq_22879 * edx_25 = *((word32) dwArg04 + 0x00A0);
	Eq_2 ecx_26 = *((word32) dwArg04 + 0x00A4);
	if (eax_23 != 0x00)
	{
		if ((*((word32) eax_23 + 408) & 0x08) == 0x00)
			call_init.part.0(eax_23, dwArg0C, dwArg08, dwArg10);
		_dl_initfirst.u0 = 0x00;
	}
	if (edx_25 != null && ecx_26 != 0x00)
	{
		uint32 ecx_65 = *((word32) ecx_26 + 4);
		if (ecx_65 > 0x03)
		{
			if ((_dl_debug_mask & 0x02) != 0x00)
			{
				if (**((word32) dwArg04 + 4) == 0x00)
					**(union Eq_2 **) 135060900 != 0x00;
				word32 edx_333;
				word32 ecx_332;
				_dl_debug_printf(out ecx_332, out edx_333);
			}
			<anonymous> ** eax_117 = (word32) *dwArg04 + edx_25->dw0004;
			<anonymous> ** ebx_122 = eax_117;
			<anonymous> ** eax_123 = (char *) eax_117 + (ecx_65 & ~0x03);
			do
			{
				(*ebx_122)();
				ebx_122 = (<anonymous> **) ((char *) ebx_122 + 4);
			} while (eax_123 != ebx_122);
		}
	}
	ui32 edi_158 = *((word32) dwArg04 + 356);
l0809B38F:
	for (--edi_158; edi_158 != ~0x00; --edi_158)
	{
		Eq_2 eax_167 = *((word32) *((word32) dwArg04 + 500) + edi_158 * 0x04);
		if ((*((word32) eax_167 + 408) & 0x08) != 0x00)
			goto l0809B38F;
		call_init.part.0(eax_167, dwArg0C, dwArg08, dwArg10);
	}
	_dl_starting_up = 0x00;
}

// 0809B4B0: Register word32 _dl_check_map_versions(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      dl_open_worker
//      _dl_check_all_versions
word32 _dl_check_map_versions(struct Eq_9 * gs, Eq_2 dwArg04)
{
	struct Eq_144185 * esp_163 = fp - 0x7C;
	Eq_2 ebp_19 = dwArg04;
	if (*((word32) dwArg04 + 52) == 0x00)
		return 0x00;
	Eq_2 edx_489;
	Eq_2 eax_474;
	word32 * esp_482;
	Eq_2 eax_461;
	Eq_2 esi_447;
	word32 * esp_459;
	Eq_144202 edi_26 = *((word32) dwArg04 + 0x00B8);
	Eq_2 eax_28 = *((word32) dwArg04 + 0x00B0);
	if (eax_28 != 0x00)
	{
		word32 eax_42 = Mem30[eax_28 + 0x04:word32] + Mem41[dwArg04 + 0x00:word32];
		if (*eax_42 == 0x01)
		{
l0809B52E:
			struct Eq_144255 * edi_1005;
			Eq_2 esi_182;
			struct Eq_144255 * edx_221;
			struct Eq_144258 * ecx_785;
			struct Eq_144258 * ebx_271;
			word32 * esp_254;
			Eq_2 eax_219;
			Eq_2 esi_89 = esp_163->dw000C + (esp_163->ptr001C)->dw0004;
			Eq_2 ebx_100 = esp_163->ptr0030[*((word32) ebp_19 + 24)].t0000;
			while (ebx_100 != 0x00)
			{
				struct Eq_144285 * esp_97 = esp_163 - 0x08;
				esp_97->tFFFFFFFC = ebx_100;
				esp_97->tFFFFFFF8 = esi_89;
				word32 ecx_1297;
				if (_dl_name_match_p(esp_97->tFFFFFFF8, esp_97->tFFFFFFFC, out ecx_1297) != 0x00)
				{
l0809B56C:
					if (esp_163->dw0088 != 0x00 && (*((word32) ebx_100 + 0x0199) & 0x02) != 0x00)
						goto l0809B97B;
					struct Eq_144390 * eax_175 = esp_163->ptr001C;
					esp_163[1] = (struct Eq_144185) ebx_100;
					esp_163->ptr0080 = (struct Eq_155481 *) ebp_19;
					esi_182 = eax_175 + eax_175->dw0008 / 0x0C;
					esp_163->ptr0010 = 0x080CFF04;
					esp_163[2] = (struct Eq_144185) 135060900;
					goto l0809B5A6;
				}
				ebx_100 = *((word32) ebx_100 + 0x0C);
			}
			edi_1005 = (struct Eq_144255 *) *((word32) ebp_19 + 356);
			if (edi_1005 != null)
			{
				edi_1005 = null;
				do
				{
					struct Eq_144346 * esp_134 = esp_163 - 0x08;
					esp_134->tFFFFFFFC = *((word32) *((word32) ebp_19 + 352) + edi_1005 * 0x04);
					esp_134->tFFFFFFF8 = esi_89;
					word32 ecx_1300;
					if (_dl_name_match_p(esp_134->tFFFFFFF8, esp_134->tFFFFFFFC, out ecx_1300) != 0x00)
					{
						ebx_100 = *((word32) *((word32) ebp_19 + 352) + edi_1005 * 0x04);
						if (ebx_100 == 0x00)
							break;
						goto l0809B56C;
					}
					++edi_1005;
				} while (edi_1005 < *((word32) ebp_19 + 356));
			}
			esi_182 = esp_163->dw0000;
			struct Eq_144314 * esp_194 = esp_163 - 4;
			esp_194->dw0000 = (word32) esi_182 - 0x000141F0;
			esp_194->dwFFFFFFFC = 0xCD;
			esp_194->dwFFFFFFF8 = (word32) esi_182 - 82833;
			esp_194->dwFFFFFFF4 = (word32) esi_182 - 82820;
			word32 edx_1299;
			word32 ecx_1298;
			__assert_fail(out ecx_1298, out edx_1299);
			Eq_2 esp_206 = <invalid>;
			esp_163 = (word32) esp_206 - 4;
			do
			{
				if (esp_163->dw0084 != 0x00)
				{
					eax_219 = *((word32) ebp_19 + 4);
					edx_221 = edi_1005;
					if (*eax_219 == 0x00)
					{
						eax_219 = **(union Eq_2 **) 135060900;
						if (eax_219 == 0x00)
							goto l0809BB84;
					}
l0809B7C4:
					struct Eq_144530 * esp_232 = esp_163 - 4;
					esp_232->ptr0000 = edx_221;
					esp_232->tFFFFFFFC = esp_232->dw0004 + 4294884644;
					esp_232->tFFFFFFF8 = eax_219;
					esp_232->tFFFFFFF4 = &esp_232->dw0004 + 16;
					_dl_exception_create_format(gs, esp_232->tFFFFFFF4, esp_232->tFFFFFFF8, esp_232->tFFFFFFFC);
					esi_182 = &esp_232->dw0004 + 16;
					esp_254 = &esp_232->dw0004;
l0809B6A9:
					struct Eq_144578 * esp_257 = esp_254 - 0x04;
					esp_257->dwFFFFFFFC = esp_257->dw0004 + ~0x00014364;
					esp_257->tFFFFFFF8 = esi_182;
					esp_257->tFFFFFFF4.u0 = 0x00;
					_dl_signal_exception(gs, esp_257->tFFFFFFF4, esp_257->tFFFFFFF8, out ebx_271);
					esp_163 = esp_257 - 0x10;
l0809B6C0:
					struct Eq_144689 * esp_283 = esp_163 - 0x08;
					Mem289[esp_283 + -4:word32] = Mem280[ebx_271 + Mem280[ebx_271 + 0x0C:word32]:word32] + ebp_19;
					esp_283->tFFFFFFF8 = esp_283->t0010;
					esp_163 = (struct Eq_144185 *) ((char *) &esp_283->tFFFFFFFC + 0x0C);
					word32 ecx_1302;
					word32 edx_1303;
					if (strcmp(esp_283->tFFFFFFF8, esp_283->tFFFFFFFC, out ecx_1302, out edx_1303) != 0x00)
						goto l0809B636;
				}
l0809B6E0:
				ui32 eax_306 = (word32) *((word32) esi_182 + 6);
				uint32 edi_308 = esp_163->dw0004;
				uint32 eax_309 = eax_306 & 0x7FFF;
				if (edi_308 >= (eax_306 & 0x7FFF))
					eax_309 = edi_308;
				esp_163->dw0004 = eax_309;
				int32 eax_317 = *((word32) esi_182 + 0x0C);
				if (eax_317 == 0x00)
				{
					ebp_19 = esp_163->ptr0080;
l0809B97B:
					struct Eq_144993 * edi_324 = esp_163->ptr001C;
					word32 eax_325 = edi_324->dw000C;
					if (eax_325 == 0x00)
					{
						if (esp_163->ptr002C != 0x00)
							goto l0809B842;
						goto l0809B88B;
					}
					else
					{
						esp_163->ptr001C = (struct Eq_155479 *) (edi_324 + eax_325 / 16);
						goto l0809B52E;
					}
				}
				esi_182 = (word32) esi_182 + eax_317;
l0809B5A6:
				struct Eq_144255 * edx_654 = *esi_182;
				esp_163->b001A = (byte) *((word32) esi_182 + 4);
				ebp_19 = *esp_163[1].ptr0014;
				esp_163->dw0008 = (word32) *((word32) esi_182 + 8) + esp_163->dw000C;
				edi_1005 = esp_163->ptr0080->ptr0004;
				if (edi_1005->b0000 == 0x00)
				{
					edi_1005 = (struct Eq_144255 *) *esp_163[2].dw0000->dw0000;
					word32 eax_670 = esp_163->dw0000;
					if (edi_1005 == null)
						edi_1005 = eax_670 + ~0x0001B534;
				}
				Eq_2 ecx_679 = *((word32) *((word32) ebp_19 + 52) + 4);
				if ((*esp_163->ptr0010 & 0x10) != 0x00)
				{
					esp_163->dw0020 = (word32) *((word32) ebp_19 + 24);
					Eq_2 eax_687 = *((word32) ebp_19 + 4);
					if (*eax_687 == 0x00)
					{
						word32 ebx_691 = esp_163->dw0000;
						eax_687 = **esp_163->ptr0038;
						if (eax_687 == 0x00)
							eax_687 = ebx_691 + ~0x0001B534;
					}
					esp_163[3] = (struct Eq_144185) ecx_679;
					struct Eq_145087 * esp_704 = esp_163 - 0x08;
					esp_704->ptr002C = edx_654;
					esp_704->dwFFFFFFFC = esp_704->ptr0088->dw0018;
					esp_704->ptrFFFFFFF8 = edi_1005;
					esp_704->dwFFFFFFF4 = esp_704->dw0028;
					esp_704->tFFFFFFF0 = eax_687;
					esp_704->dwFFFFFFEC = esp_704->dw0010;
					esp_704->dwFFFFFFE8 = esp_704->dw0008 + ~0x00014323;
					word32 edx_1306;
					word32 ecx_1305;
					_dl_debug_printf(out ecx_1305, out edx_1306);
					ecx_679 = esp_704->t0044;
					edx_654 = esp_704->ptr002C;
				}
				Eq_144202 eax_749 = *((word32) ebp_19 + 0x00B8);
			} while (eax_749 == 0x00);
			word32 ebx_753 = *((word32) eax_749 + 4);
			if (ebx_753 != 0x00)
			{
				ebx_271 = (word32) *ebp_19 + ebx_753;
				if (ebx_271->w0000 != 0x01)
				{
					ecx_785 = ebx_271;
					goto l0809B64F;
				}
				esp_163->dw0020 = (word32) ebp_19;
				esp_163->dw0024 = edi_1005;
				ebp_19 = ecx_679;
				edi_1005 = edx_654;
l0809B62D:
				if (edi_1005 != ebx_271->ptr0008)
				{
l0809B636:
					int32 eax_801 = ebx_271->dw0010;
					if (eax_801 != 0x00)
					{
						ebx_271 += eax_801 / 20;
						if (ebx_271->w0000 != 0x01)
						{
							ecx_785 = ebx_271;
l0809B64F:
							esp_163->b005F = 0x00;
							struct Eq_144894 * esp_899 = esp_163 - 0x0C;
							esp_899->tFFFFFFFC.u0 = 0x00;
							esp_899->tFFFFFFF8.u0 = 0x0A;
							esp_899->tFFFFFFF4 = (char *) &esp_899->tFFFFFFFC + 111;
							Eq_86855 eax_911 = (word32) ecx_785->w0000;
							esp_899->dwFFFFFFF0 = 0x00;
							esp_899->tFFFFFFEC = eax_911;
							word32 ebx_1304;
							Eq_2 eax_923 = _itoa(gs, esp_899->tFFFFFFEC, esp_899->tFFFFFFF4, esp_899->tFFFFFFF8, esp_899->tFFFFFFFC, out ebx_1304, out ebp_19, out edi_1005);
							Eq_2 esp_930 = <invalid>;
							Eq_2 edx_935 = edi_1005[4];
							if (*edx_935 == 0x00)
							{
								word32 esi_939 = *((word32) esp_930 + 32);
								edx_935 = **(union Eq_2 **) 135060900;
								if (edx_935 == 0x00)
									edx_935 = esi_939 + ~0x0001B534;
							}
							*((word32) esp_930 + 28) = eax_923;
							*((word32) esp_930 + 24) = (word32) *((word32) esp_930 + 32) - 82600;
							*((word32) esp_930 + 20) = edx_935;
							*((word32) esp_930 + 16) = (word32) esp_930 + 96;
							_dl_exception_create_format(gs, *((word32) esp_930 + 16), *((word32) esp_930 + 20), *((word32) esp_930 + 24));
							esi_182 = (word32) esp_930 + 96;
							esp_254 = (word32) esp_930 + 32;
							goto l0809B6A9;
						}
						goto l0809B62D;
					}
					Eq_2 eax_812;
					Eq_2 edx_835;
					ebp_19 = esp_163->dw0020;
					edi_1005 = esp_163->dw0024;
					if ((esp_163->b001A & 0x02) == 0x00)
					{
						eax_812 = *((word32) ebp_19 + 4);
						if (*eax_812 == 0x00)
						{
							edi_1005 = esp_163->dw0000;
							eax_812 = **(union Eq_2 **) 135060900;
							if (eax_812 == 0x00)
								eax_812 = (char *) edi_1005 - 111925;
						}
						struct Eq_144999 * esp_826 = esp_163 - 0x0C;
						esp_826->ptrFFFFFFFC = edi_1005;
						esp_826->dwFFFFFFF8 = esp_826->dw0014;
						edx_835 = esp_826->dw000C + 4294884784;
l0809BAFD:
						struct Eq_144852 * esp_864 = esp_163 - 0x14;
						esp_864->tFFFFFFFC = edx_835;
						esp_864->tFFFFFFF8 = eax_812;
						esp_864->tFFFFFFF4 = (char *) &esp_864->tFFFFFFFC + 88;
						_dl_exception_create_format(gs, esp_864->tFFFFFFF4, esp_864->tFFFFFFF8, esp_864->tFFFFFFFC);
						esi_182 = (char *) &esp_864->tFFFFFFFC + 88;
						esp_254 = (word32 *) ((char *) &esp_864->tFFFFFFFC + 24);
						goto l0809B6A9;
					}
					if (esp_163->dw0084 != 0x00)
					{
						eax_812 = *((word32) ebp_19 + 4);
						if (*eax_812 == 0x00)
						{
							eax_812 = **(union Eq_2 **) 135060900;
							if (eax_812 == 0x00)
								eax_812 = esp_163->dw0000 + ~0x0001B534;
						}
						struct Eq_144823 * esp_854 = esp_163 - 0x0C;
						esp_854->ptrFFFFFFFC = edi_1005;
						esp_854->dwFFFFFFF8 = esp_854->dw0014;
						edx_835 = esp_854->dw000C + ~0x0001427F;
						goto l0809BAFD;
					}
					goto l0809B6E0;
				}
				goto l0809B6C0;
			}
			word32 esi_758 = esp_163->dw0000;
			struct Eq_144643 * esp_760 = esp_163 - 4;
			esp_760->dw0000 = esi_758 + ~0x000141FF;
			esp_760->dwFFFFFFFC = 88;
			esp_760->dwFFFFFFF8 = esi_758 + ~0x00014390;
			esp_760->dwFFFFFFF4 = esi_758 + 4294884491;
			word32 ecx_1301;
			__assert_fail(out ecx_1301, out edx_221);
			Eq_2 esp_772 = <invalid>;
			esp_163 = (word32) esp_772 - 4;
l0809BB84:
			eax_219 = esp_163->dw0000 + ~0x0001B534;
			goto l0809B7C4;
		}
		struct Eq_144227 * ebp_69;
		word32 edi_1296;
		word32 ebx_1295;
		eax_474 = _itoa(gs, (uint64) (word32) *eax_42, fp - 0x1D, 0x0A, 0x00, out ebx_1295, out ebp_69, out edi_1296);
		Eq_2 esp_75 = <invalid>;
		edx_489 = ebp_69->t0004;
		esp_482 = (word32) esp_75 + 32;
		if (*edx_489 == 0x00)
		{
l0809BAAF:
			word32 esi_485 = *esp_482;
			edx_489 = **(union Eq_2 **) 135060900;
			if (edx_489 == 0x00)
				edx_489 = esi_485 + ~0x0001B534;
			goto l0809BA87;
		}
l0809BA87:
		struct Eq_144457 * esp_496 = esp_482 - 4;
		esp_496->t0000 = eax_474;
		esp_496->tFFFFFFFC = esp_496->dw0004 + ~0x0001434F;
		esp_496->tFFFFFFF8 = edx_489;
		esp_496->tFFFFFFF4 = &esp_496->dw0004 + 16;
		_dl_exception_create_format(gs, esp_496->tFFFFFFF4, esp_496->tFFFFFFF8, esp_496->tFFFFFFFC);
		esi_447 = &esp_496->dw0004 + 16;
		esp_459 = &esp_496->dw0004;
		eax_461.u0 = 0x00;
	}
	else
	{
		if (edi_26 == 0x00)
			return 0x00;
l0809B842:
		struct Eq_145034 * edx_340 = (word32) *ebp_19 + (esp_163->ptr002C)->dw0004;
		ui32 eax_341 = (word32) edx_340->w0004;
		uint32 edi_336 = esp_163->dw0004;
		uint32 eax_342 = eax_341 & 0x7FFF;
		if (edi_336 >= (eax_341 & 0x7FFF))
			eax_342 = edi_336;
		esp_163->dw0004 = eax_342;
		uint32 ecx_347 = eax_342;
		int32 eax_351 = edx_340->dw0010;
		if (eax_351 != 0x00)
		{
			do
			{
				edx_340 += eax_351 / 20;
				ui32 eax_363 = (word32) edx_340->w0004;
				if (ecx_347 < (eax_363 & 0x7FFF))
					ecx_347 = eax_363 & 0x7FFF;
				eax_351 = edx_340->dw0010;
			} while (eax_351 != 0x00);
			esp_163->dw0004 = ecx_347;
		}
l0809B88B:
		word32 eax_381 = esp_163->dw0004;
		if (eax_381 == 0x00)
			return 0x00;
		struct Eq_145150 * esp_385 = esp_163 - 0x08;
		esp_385->tFFFFFFFC.u0 = 0x10;
		esp_385->tFFFFFFF8 = eax_381 + 0x01;
		uint32 esi_413;
		word32 edx_1308;
		word32 ecx_1307;
		word32 ebx_1309;
		word32 edi_1310;
		struct Eq_145167 * ebp_408;
		Eq_2 eax_1002 = __libc_calloc(gs, esp_385->tFFFFFFF8, esp_385->tFFFFFFFC, out ecx_1307, out edx_1308, out ebx_1309, out ebp_408, out esi_413, out edi_1310);
		ebp_408->t0174 = eax_1002;
		if (eax_1002 != 0x00)
		{
			struct Eq_145197 * edx_527 = ebp_408->ptr00E8;
			struct Eq_145201 * edi_528 = esp_385->ptr003C;
			ebp_408->dw0178 = esi_413;
			ebp_408->dw01A8 = edx_527->dw0004;
			if (edi_528 != null)
			{
				struct Eq_145222 * edi_536 = edi_528->dw0004 + ebp_408->dw0000;
				esp_385->ptr0088 = ebp_408;
				word32 ebp_539 = esp_385->dw0014;
				while (true)
				{
					word32 ebx_542 = edi_536->dw0008;
					esp_385->t0008 = eax_1002;
					struct Eq_145238 * ebx_546 = edi_536 + ebx_542 / 16;
					while (true)
					{
						ui32 ecx_550 = (word32) ebx_546->w0006;
						cui16 cx_556 = (word16) ecx_550;
						if (esi_413 > (ecx_550 & 0x7FFF))
						{
							struct Eq_145264 * edx_560 = (word32) esp_385->t0008 + ((ecx_550 & 0x7FFF) << 0x04);
							word32 eax_561 = ebx_546->dw0000;
							edx_560->dw0008 = (word32) (cx_556 & 0x8000);
							word32 ecx_564 = ebx_546->dw0008;
							edx_560->dw0004 = eax_561;
							edx_560->dw0000 = ecx_564 + ebp_539;
							edx_560->dw000C = edi_536->dw0004 + ebp_539;
						}
						int32 edx_576 = ebx_546->dw000C;
						if (edx_576 == 0x00)
							break;
						ebx_546 += edx_576 / 16;
					}
					int32 edx_583 = edi_536->dw000C;
					eax_1002 = esp_385->t0008;
					if (edx_583 == 0x00)
						break;
					edi_536 += edx_583 / 16;
				}
				ebp_408 = esp_385->ptr0088;
			}
			struct Eq_145216 * esi_592 = esp_385->ptr0034;
			if (esi_592 != null)
			{
				word32 esi_597 = esp_385->dw0014;
				struct Eq_145304 * edx_599 = esi_592->dw0004 + ebp_408->dw0000;
				while (true)
				{
					if ((edx_599->b0002 & 0x01) == 0x00)
					{
						int32 ebx_607 = edx_599->dw000C;
						struct Eq_145392 * ecx_612 = (word32) eax_1002 + (((word32) edx_599->w0004 & 0x7FFF) << 0x04);
						ecx_612->dw0004 = edx_599->dw0008;
						word32 edi_614 = edx_599[ebx_607 / 20];
						ecx_612->dw000C = 0x00;
						ecx_612->dw0000 = edi_614 + esi_597;
					}
					int32 ecx_622 = edx_599->dw0010;
					if (ecx_622 == 0x00)
						break;
					edx_599 += ecx_622 / 20;
				}
			}
			return 0x00;
		}
		Eq_2 eax_424 = ebp_408->t0004;
		if (*eax_424 == 0x00)
		{
			Eq_2 esi_427 = esp_385->t0008;
			eax_424 = **(union Eq_2 **) 135060900;
			if (eax_424 == 0x00)
				eax_424 = (word32) esi_427 - 111925;
		}
		esp_385->t0000 = (word32) esp_385->t0008 - 82472;
		esp_385->tFFFFFFFC = eax_424;
		esp_385->tFFFFFFF8 = (char *) &esp_385->ptr003C + 0x0C;
		_dl_exception_create(esp_385->tFFFFFFF8, esp_385->tFFFFFFFC, esp_385->t0000);
		esi_447 = (char *) &esp_385->ptr003C + 0x0C;
		esp_459 = (word32 *) &esp_385->t0008;
		eax_461.u0 = 0x0C;
	}
	struct Eq_145419 * esp_463 = esp_459 - 0x04;
	esp_463->dwFFFFFFFC = 0x00;
	esp_463->tFFFFFFF8 = esi_447;
	esp_463->tFFFFFFF4 = eax_461;
	word32 ebx_1311;
	eax_474 = _dl_signal_exception(gs, esp_463->tFFFFFFF4, esp_463->tFFFFFFF8, out ebx_1311);
	esp_482 = esp_463 - 0x10;
	goto l0809BAAF;
}

// 0809BBA0: void _dl_check_all_versions(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void _dl_check_all_versions(struct Eq_9 * gs, Eq_2 dwArg04)
{
	Eq_2 ebx_18 = dwArg04;
	if (dwArg04 != 0x00)
	{
		do
		{
			if ((*((word32) ebx_18 + 0x0199) & 0x02) == 0x00)
			{
				_dl_check_map_versions(gs, ebx_18);
				ebx_18 = *((word32) ebx_18 + 0x0C);
				if (ebx_18 == 0x00)
					return;
				continue;
			}
			ebx_18 = *((word32) ebx_18 + 0x0C);
		} while (ebx_18 != 0x00);
	}
}

// 0809BC00: void call_dl_lookup(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_145480) dwArg04)
void call_dl_lookup(struct Eq_9 * gs, struct Eq_145480 * dwArg04)
{
	Eq_2 eax_10 = dwArg04->t0000;
	word32 ecx_60;
	word32 edx_61;
	dwArg04->t0000 = _dl_lookup_symbol_x(gs, dwArg04->t0004, eax_10, dwArg04->ptr0014, *((word32) eax_10 + 464), dwArg04->t0008, 0x00, dwArg04->t000C, 0x00, out ecx_60, out edx_61);
}

// 0809BC40: Register Eq_2 do_sym(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_2 esiOut)
// Called from:
//      _dl_vsym
//      _dl_sym
Eq_2 do_sym(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_2 & esiOut)
{
	ui32 eax_24 = gs->dw0014;
	Eq_2 edi_11 = edx;
	Eq_2 esi_16 = eax;
	ptr32 ebx_152 = 0x080CE000;
	Eq_2 ebp_151 = dwArg04;
	Eq_2 eax_150 = _dl_find_dso_for_object(ecx);
	struct Eq_145529 * esp_161 = fp - 0x5C;
	if (eax_150 == 0x00)
		eax_150 = g_t80CEA00;
	Eq_2 dwLoc70_383;
	Eq_2 dwLoc60_377;
	Eq_2 dwLoc64_380;
	if (eax != 0x00)
	{
		if (eax != ~0x00)
		{
			word32 ecx_524;
			word32 edx_525;
			_dl_lookup_symbol_x(gs, edx, eax, fp - 0x48, (word32) eax + 468, dwArg04, 0x00, dwArg08, 0x00, out ecx_524, out edx_525);
			goto l0809BCB3;
		}
		esi_16.u0 = 0x080CEA00;
		Eq_2 edx_80 = eax_150;
		if (g_t80CEA00 == eax_150 && (eax_150 == 0x00 || (*((word32) eax_150 + 432) > ecx || *((word32) eax_150 + 436) <= ecx)))
		{
			word32 edx_533;
			word32 ecx_532;
			eax_150 = _dl_signal_error(gs, 0x00, 0x080B9E28, out ecx_532, out edx_533, out ebx_152, out ebp_151, out edi_11);
			esp_161 = fp - 0x70;
			esi_16.u0 = 0x080CEA00;
			goto l0809BDD0;
		}
		while (true)
		{
			Eq_2 ecx_93 = *((word32) edx_80 + 368);
			if (ecx_93 == 0x00)
				break;
			edx_80 = ecx_93;
		}
		dwLoc60_377 = eax_150;
		dwLoc64_380.u0 = 0x00;
		dwLoc70_383 = (word32) edx_80 + 468;
	}
	else
	{
		if (gs->t000C != 0x00)
		{
l0809BDD0:
			esp_161->t0024 = eax_150;
			ui32 eax_167 = esp_161->dw0064;
			esp_161->t0028 = edi_11;
			esp_161->t002C = ebp_151;
			esp_161->dw0030 = eax_167 | 0x05;
			esp_161->ptr0038 = (char *) esp_161 + 20;
			gs->t001C.u0 = 0x01;
			struct Eq_145629 * esp_178 = esp_161 - 0x04;
			esp_178->tFFFFFFFC = (char *) &esp_178->tFFFFFFFC + 44;
			esp_178->tFFFFFFF8 = ebx_152 + ~0x000323FF;
			esp_178->tFFFFFFF4 = (char *) &esp_178->tFFFFFFFC + 32;
			word32 ecx_534;
			word32 ebx_536;
			word32 edx_535;
			Eq_2 eax_190 = _dl_catch_exception(gs, esp_178->tFFFFFFF4, esp_178->tFFFFFFF8, esp_178->tFFFFFFFC, out ecx_534, out edx_535, out ebx_536);
			Eq_2 v18_202 = gs->t001C;
			gs->t001C = esi_16;
			Eq_2 esp_194 = <invalid>;
			if (v18_202 == 0x02)
				gs->ptr0010();
			if (*((word32) esp_194 + 44) != 0x00)
			{
				*((word32) esp_194 + 8) = 0x00;
				*((word32) esp_194 + 4) = (char *) &esp_178->tFFFFFFFC + 32;
				*esp_194 = eax_190;
				word32 ebx_537;
				_dl_signal_exception(gs, *esp_194, *((word32) esp_194 + 4), out ebx_537);
l0809BE62:
				word32 ecx_526;
				word32 edx_527;
				Eq_2 eax_349 = __stack_chk_fail(out ecx_526, out edx_527);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_2 stackArg4 = <invalid>;
				Eq_2 stackArg8 = <invalid>;
				Eq_2 stackArg12 = <invalid>;
				Eq_2 stackArg16 = <invalid>;
				_dl_vsym(gs, stackArg4, stackArg8, stackArg12, stackArg16);
				esiOut = esi_16;
				return eax_349;
			}
l0809BCB3:
			if ((eax_24 ^ gs->dw0014) == 0x00)
			{
				esiOut = esi;
				return 0x00;
			}
			goto l0809BE62;
		}
		dwLoc60_377.u0 = 0x00;
		dwLoc64_380 = dwArg08 | 0x01;
		dwLoc70_383 = *((word32) eax_150 + 464);
	}
	word32 ecx_538;
	word32 edx_539;
	_dl_lookup_symbol_x(gs, edx, eax_150, fp - 0x48, dwLoc70_383, dwArg04, 0x00, dwLoc64_380, dwLoc60_377, out ecx_538, out edx_539);
	goto l0809BCB3;
}

// 0809BE70: Register word32 _dl_vsym(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Stack Eq_2 dwArg10)
// Called from:
//      dlvsym_doit
//      _dl_sym
word32 _dl_vsym(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, Eq_2 dwArg10)
{
	if ((word32) *dwArg0C != 0x00 && ((word32) (*((word32) dwArg0C + 1)) != 0x00 && ((word32) (*((word32) dwArg0C + 2)) != 0x00 && ((word32) (*((word32) dwArg0C + 3)) != 0x00 && (word32) (*((word32) dwArg0C + 4)) != 0x00))))
	{
		byte * eax_35 = (word32) dwArg0C + 5;
		if ((word32) *((word32) dwArg0C + 5) != 0x00)
		{
			do
				++eax_35;
			while ((word32) *eax_35 != 0x00);
		}
	}
	word32 esi_153;
	word32 eax_70 = do_sym(dwArg04, dwArg10, dwArg08, gs, fp - 0x20, 0x00, out esi_153);
	if ((dwLoc0C ^ gs->dw0014) == 0x00)
		return eax_70;
	word32 ecx_154;
	word32 edx_155;
	__stack_chk_fail(out ecx_154, out edx_155);
	word32 esi_156;
	return _dl_sym(gs, dwArg04, dwArg08, dwArg0C, out esi_156);
}

// 0809BF40: Register word32 _dl_sym(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Stack Eq_2 dwArg0C, Register out ptr32 esiOut)
// Called from:
//      dlsym_doit
//      _dl_vsym
word32 _dl_sym(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, Eq_2 dwArg0C, ptr32 & esiOut)
{
	ptr32 esi_17;
	word32 eax_11 = do_sym(dwArg04, dwArg0C, dwArg08, gs, 0x00, 0x02, out esi_17);
	esiOut = esi_17;
	return eax_11;
}

// 0809BF70: Register uint32 __udivdi3(Stack Eq_123206 qwArg04, Stack Eq_963 dwArg0C, Stack Eq_963 dwArg10, Register out Eq_123209 edxOut)
// Called from:
//      _dl_strtoul
uint32 __udivdi3(Eq_123206 qwArg04, Eq_963 dwArg0C, Eq_963 dwArg10, union Eq_123209 & edxOut)
{
	Eq_963 dwArg04 = (word32) qwArg04;
	Eq_963 dwArg08 = SLICE(qwArg04, word32, 32);
	uint32 eax_104;
	Eq_123209 edi_150;
	if (dwArg10 == 0x00)
	{
		if (dwArg0C <= dwArg08)
		{
			Eq_963 ecx_110 = dwArg0C;
			if (dwArg0C == 0x00)
				ecx_110.u1 = (uint32) (0x01 /u dwArg0C);
			uint64 edx_eax_125 = (uint64) dwArg08;
			edxOut.u0 = (uint32) (edx_eax_125 /u ecx_110);
			return (uint32) (SEQ((uint32) (edx_eax_125 % ecx_110), dwArg04) /u ecx_110);
		}
		edi_150.u0 = 0x00;
		eax_104 = (uint32) (qwArg04 /u dwArg0C);
	}
	else
	{
		if (dwArg10 > dwArg08)
		{
			edxOut.u0 = 0x00;
			return 0x00;
		}
		word32 edi_39 = __bsr(dwArg10);
		edi_150 = edi_39 ^ 0x1F;
		if ((edi_39 ^ 0x1F) == 0x00)
		{
			if (dwArg10 >= dwArg08)
			{
				eax_104 = 0x00;
				if (dwArg0C > dwArg04)
					goto l0809BF9B;
			}
			eax_104 = 0x01;
			goto l0809BF9B;
		}
		word32 eax_46 = 0x20 - (edi_39 ^ 0x1F);
		uint32 ecx_55 = dwArg10 << (byte) (edi_39 ^ 0x1F) | dwArg0C >> (byte) eax_46;
		uint64 edx_eax_74 = SEQ(dwArg08 >> (byte) eax_46, dwArg08 << (byte) (edi_39 ^ 0x1F) | dwArg04 >> (byte) eax_46);
		uint32 eax_77 = (uint32) (edx_eax_74 /u ecx_55);
		uint64 edx_eax_80 = (dwArg0C << (byte) (edi_39 ^ 0x1F)) *64 eax_77;
		uint32 edx_76 = (uint32) (edx_eax_74 % ecx_55);
		uint32 edx_81 = SLICE(edx_eax_80, word32, 32);
		uint32 eax_87 = (word32) edx_eax_80;
		if (edx_76 >= edx_81 && (dwArg04 << (byte) (edi_39 ^ 0x1F) >= eax_87 || edx_76 != edx_81))
		{
			eax_104 = eax_77;
			edi_150.u0 = 0x00;
		}
		else
		{
			eax_104 = eax_77 - 0x01;
			edi_150.u0 = 0x00;
		}
	}
l0809BF9B:
	edxOut = edi_150;
	return eax_104;
}

// 0809C080: Register uint32 __lttf2(Stack uint32 dwArg04, Stack uint32 dwArg08, Stack uint32 dwArg0C, Stack uint32 dwArg10, Stack uint32 dwArg14, Stack uint32 dwArg18, Stack uint32 dwArg1C, Stack uint32 dwArg20)
// Called from:
//      __printf_fp_l
//      __printf_fphex
uint32 __lttf2(uint32 dwArg04, uint32 dwArg08, uint32 dwArg0C, uint32 dwArg10, uint32 dwArg14, uint32 dwArg18, uint32 dwArg1C, uint32 dwArg20)
{
	Eq_145901 ecx_112;
	uint32 dwLoc40_410;
	__fstcw();
	uint32 ebx_34 = (word32) (word16) dwArg10;
	uint32 esi_36 = (word32) (word16) dwArg20;
	uint32 eax_148 = dwArg20 >> 0x1F;
	int32 edx_49 = dwArg20 >> 0x10 & 0x7FFF;
	int32 esi_50 = dwArg10 >> 0x10 & 0x7FFF;
	if (esi_50 == 0x00)
	{
		if ((dwArg04 | dwArg08 | dwArg0C | ebx_34) != 0x00)
			ecx_112.u0 = 0x02;
		else
		{
			ecx_112.u0 = 0x00;
			if (edx_49 == 0x00)
			{
				ecx_112 = (word32) (int8) ((dwArg18 | dwArg14 | dwArg1C | esi_36) != 0x00) * 0x02;
l0809C136:
				ui32 esi_177 = dwArg04 | dwArg08 | dwArg0C | ebx_34;
				dwLoc40_410 = (uint32) (int8) (esi_177 == 0x00);
				if (edx_49 == 0x00 && (((dwArg18 | dwArg14) | dwArg1C) | esi_36) == 0x00)
				{
					eax_148 = 0x00;
					if (esi_177 != 0x00)
						goto l0809C173;
					goto l0809C287;
				}
				goto l0809C277;
			}
		}
		if (edx_49 != 0x7FFF)
			goto l0809C136;
		goto l0809C248;
	}
	if (edx_49 == 0x00)
	{
		ecx_112 = (word32) (int8) ((dwArg18 | dwArg14 | dwArg1C | esi_36) != 0x00) * 0x02;
		if (esi_50 != 0x7FFF)
		{
			if (esi_50 == 0x00)
				goto l0809C136;
			goto l0809C1F8;
		}
	}
	else
	{
		ecx_112.u0 = 0x00;
		if (esi_50 != 0x7FFF)
		{
			if (edx_49 != 0x7FFF)
				goto l0809C20E;
			goto l0809C248;
		}
	}
	if ((dwArg04 | dwArg08 | dwArg0C | ebx_34) != 0x00)
	{
l0809C298:
		ecx_112 |= 0x01;
		eax_148 = 0x02;
l0809C2A0:
		__sfp_handle_exceptions(ecx_112);
		return eax_148;
	}
	if (edx_49 == 0x7FFF)
	{
l0809C248:
		if ((dwArg18 | dwArg14 | dwArg1C | esi_36) == 0x00)
		{
			if (esi_50 == 0x00)
			{
				dwLoc40_410 = (uint32) (int8) ((dwArg04 | dwArg08 | dwArg0C | ebx_34) == 0x00);
l0809C277:
				if (dwLoc40_410 != 0x00)
					goto l0809C27F;
				goto l0809C20E;
			}
l0809C20E:
			if (dwArg10 >> 0x1F != dwArg20 >> 0x1F)
			{
				eax_148 = (0x00 - (dwArg10 >> 0x1F < 0x01) & 0x02) - 0x01;
				goto l0809C287;
			}
			if (esi_50 > edx_49)
			{
				if (dwArg20 >> 0x1F == 0x00)
				{
					eax_148 = 0x01;
					goto l0809C287;
				}
				goto l0809C317;
			}
			if (esi_50 < edx_49)
			{
l0809C27F:
				if (dwArg20 >> 0x1F != 0x00)
					goto l0809C287;
l0809C317:
				eax_148 = ~0x00;
				goto l0809C287;
			}
			if (ebx_34 <= esi_36)
			{
				if (ebx_34 != esi_36)
				{
					if (ebx_34 < esi_36)
						goto l0809C304;
					goto l0809C333;
				}
				byte SCZO_225 = cond(dwArg1C - dwArg0C);
				bool Z_227 = SLICE(SCZO_225, bool, 2);
				bool C_253 = SLICE(SCZO_225, bool, 1);
				if (dwArg1C >= dwArg0C)
				{
					if (dwArg1C != dwArg0C)
					{
						if (!(Z_227 | C_253))
							goto l0809C333;
						goto l0809C304;
					}
					if (dwArg18 >= dwArg08 && (dwArg18 != dwArg08 || dwArg14 >= dwArg04))
					{
						if (dwArg18 <= dwArg08)
						{
							if (dwArg14 <= dwArg04)
							{
l0809C333:
								eax_148 = 0x00;
								goto l0809C287;
							}
							if (dwArg18 != dwArg08)
							{
								eax_148 = 0x00;
								goto l0809C287;
							}
						}
l0809C304:
						eax_148 = ~0x00;
						if (dwArg10 >> 0x1F != 0x00)
							eax_148 = dwArg10 >> 0x1F;
l0809C287:
						if (ecx_112 == 0x00)
							return eax_148;
						goto l0809C2A0;
					}
				}
			}
l0809C173:
			eax_148 = (0x00 - (dwArg10 >> 0x1F < 0x01) & 0x02) - 0x01;
			if (ecx_112 == 0x00)
				return eax_148;
			goto l0809C2A0;
		}
		goto l0809C298;
	}
	if (edx_49 != 0x00)
		goto l0809C20E;
l0809C1F8:
	if ((dwArg18 | dwArg14 | dwArg1C | esi_36) == 0x00)
		goto l0809C173;
	goto l0809C20E;
}

// 0809C370: Register ui32 __unordtf2(Stack ui32 dwArg04, Stack ui32 dwArg08, Stack ui32 dwArg0C, Stack uint32 dwArg10, Stack ui32 dwArg14, Stack ui32 dwArg18, Stack ui32 dwArg1C, Stack uint32 dwArg20)
// Called from:
//      __printf_fp_l
//      __printf_fphex
ui32 __unordtf2(ui32 dwArg04, ui32 dwArg08, ui32 dwArg0C, uint32 dwArg10, ui32 dwArg14, ui32 dwArg18, ui32 dwArg1C, uint32 dwArg20)
{
	ui32 eax_192;
	Eq_145901 esi_100;
	__fstcw();
	ci16 bx_34 = (word16) dwArg20;
	ci16 cx_37 = (word16) dwArg10;
	ui32 edx_35 = (word32) bx_34;
	ui32 edi_38 = (word32) cx_37;
	ui32 edx_43 = dwArg20 >> 0x10 & 0x7FFF;
	ui32 eax_121 = dwArg10 >> 0x10 & 0x7FFF;
	if (eax_121 == 0x00)
	{
		if ((dwArg04 | dwArg08 | dwArg0C | edi_38) != 0x00)
		{
			if (edx_43 == 0x7FFF && ((word32) bx_34 | ((dwArg14 | dwArg18) | dwArg1C)) != 0x00)
			{
				esi_100.u0 = 0x02;
				goto l0809C418;
			}
			goto l0809C560;
		}
		if (edx_43 != 0x00)
		{
l0809C44C:
			if (edx_43 != 0x7FFF || (((dwArg14 | dwArg18) | dwArg1C) | edx_35) == 0x00)
				goto l0809C458;
			esi_100.u0 = 0x00;
			if (eax_121 != 0x7FFF)
			{
l0809C418:
				if (bx_34 >= 0x00)
					goto l0809C421;
				goto l0809C4A9;
			}
l0809C523:
			if ((dwArg04 | dwArg08 | dwArg0C | edi_38) == 0x00)
				goto l0809C418;
			if (cx_37 >= 0x00)
			{
l0809C421:
				esi_100 |= 0x01;
				eax_121 = 0x01;
				goto l0809C429;
			}
l0809C53E:
			if (((word32) bx_34 | ((dwArg14 | dwArg18) | dwArg1C)) == 0x00)
				goto l0809C4A9;
			goto l0809C418;
		}
	}
	else if (edx_43 != 0x00)
	{
		if (eax_121 != 0x7FFF)
			goto l0809C44C;
		goto l0809C4CD;
	}
	if ((dwArg14 | dwArg18 | dwArg1C | edx_35) != 0x00)
	{
		if (eax_121 != 0x7FFF)
		{
			eax_121 = 0x00;
l0809C560:
			esi_100.u0 = 0x02;
			goto l0809C429;
		}
		esi_100.u0 = 0x02;
		if ((dwArg04 | dwArg08 | dwArg0C | edi_38) != 0x00)
		{
l0809C498:
			if (cx_37 >= 0x00)
				goto l0809C421;
			if (edx_43 != 0x7FFF)
			{
l0809C4A9:
				eax_121 = 0x01;
				goto l0809C4AE;
			}
			goto l0809C53E;
		}
l0809C4DB:
		if (edx_43 != 0x7FFF)
			eax_121 = 0x00;
		else
		{
			if ((dwArg14 | dwArg18 | dwArg1C | edx_35) != 0x00)
				goto l0809C523;
			eax_121 = 0x00;
		}
l0809C4AE:
		if (esi_100 == 0x00)
			return eax_121;
l0809C429:
		__sfp_handle_exceptions(esi_100);
		eax_192 = eax_121;
		return eax_192;
	}
	if (eax_121 != 0x7FFF)
	{
l0809C458:
		eax_192 = 0x00;
		return eax_192;
	}
l0809C4CD:
	esi_100.u0 = 0x00;
	if ((dwArg04 | dwArg08 | dwArg0C | edi_38) != 0x00)
		goto l0809C498;
	goto l0809C4DB;
}

// 0809C590: void __sfp_handle_exceptions(Stack Eq_145901 bArg04)
// Called from:
//      __lttf2
//      __unordtf2
void __sfp_handle_exceptions(Eq_145901 bArg04)
{
	byte al_7 = (byte) dwArg04;
	if ((al_7 & 0x02) != 0x00)
	{
		__fstenv(wLoc1C);
		__fldenv(wLoc1C);
		__wait();
	}
	if ((al_7 & 0x04) != 0x00)
		wLoc1C = 0x00;
	if ((al_7 & 0x08) != 0x00)
	{
		__fstenv(wLoc1C);
		__fldenv(wLoc1C);
		__wait();
	}
	if ((al_7 & 0x10) != 0x00)
	{
		__fstenv(wLoc1C);
		__fldenv(wLoc1C);
		__wait();
	}
}

// 0809C610: Register Eq_146250 read_encoded_value_with_base(Register Eq_146250 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out Eq_2 ecxOut, Register out Eq_146255 edxOut, Register out Eq_2 esiOut)
// Called from:
//      uw_frame_state_for
Eq_146250 read_encoded_value_with_base(Eq_146250 eax, Eq_2 ecx, struct Eq_9 * gs, word32 * dwArg04, union Eq_2 & ecxOut, union Eq_146255 & edxOut, union Eq_2 & esiOut)
{
	byte al = (byte) eax;
	word24 eax_24_8 = SLICE(eax, word24, 8);
	if (al == 0x50)
	{
		word32 * esi_28 = (word32) ecx + 3 & ~0x03;
		*dwArg04 = *esi_28;
		ecxOut = ecx;
		edxOut = esi_28 + 1;
		esiOut = esi;
		return esi_28 + 1;
	}
	else
	{
		cu8 dl_47 = (byte) (eax & 0x0F);
		if (dl_47 > 0x0C)
			read_encoded_value_with_base.cold.6(ecx, gs);
		else
		{
			ui32 edx_51 = (word32) dl_47;
			<anonymous> * ecx_53 = g_a80B9E58[edx_51 * 0x04] + 0x080CE000;
			Eq_2 ecx_55;
			Eq_146255 edx_56;
			Eq_146250 eax_57;
			ecx_53();
			ecxOut = ecx_55;
			edxOut = edx_56;
			esiOut = ecx;
			return eax_57;
		}
	}
}

// 0809C760: void base_of_encoded_value(Register Eq_146250 al, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      uw_frame_state_for
void base_of_encoded_value(Eq_146250 al, Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_146250 al = (byte) eax;
	if (al == ~0x00)
		return;
	cu8 al_16 = (byte) (eax & 0x70);
	if (al_16 == 0x20)
		return;
	if (al_16 > 0x20)
	{
		if (al_16 == 0x40)
			return;
		if (al_16 == 0x50)
			return;
		if (al_16 == 0x30)
			return;
	}
	else if (al_16 == 0x00 || al_16 == 0x10)
		return;
	word32 edx_76;
	word32 ecx_75;
	abort(ecx, gs, out ecx_75, out edx_76);
}

// 0809C7C0: Register (ptr32 Eq_146328) execute_cfa_program(Register Eq_2 eax, Register (ptr32 Eq_146328) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Register out Eq_2 edxOut, Register out ptr32 ediOut)
// Called from:
//      base_of_encoded_value
//      uw_frame_state_for
struct Eq_146328 * execute_cfa_program(Eq_2 eax, struct Eq_146328 * ecx, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg04, union Eq_2 & edxOut, ptr32 & ediOut)
{
	*((word32) dwArg04 + 144) = null;
	if (eax < edx)
	{
		edx = *((word32) dwArg04 + 0x00A4);
		if (edx < (ecx->dw0060 >> 0x1F) + ecx->dw004C)
		{
			Eq_2 esi_107 = eax;
			do
			{
				ui32 eax_44 = (word32) *esi_107;
				cu8 al_136 = (byte) eax_44;
				Eq_2 ebx_45 = (word32) esi_107 + 1;
				ecx = eax_44 & ~0x3F;
				byte cl_48 = (byte) (eax_44 & ~0x3F);
				if (cl_48 != 0x40)
				{
					if (cl_48 != 0x80)
					{
						if (cl_48 != 0xC0)
						{
							if (al_136 > 0x2F)
								execute_cfa_program.cold.7(eax_44 & ~0x3F, gs);
							else
							{
								<anonymous> * ecx_145 = g_a80B9E8C[eax_44 * 0x04] + 0x080CE000;
								Eq_2 edx_153;
								struct Eq_146328 * ecx_154;
								ecx_145();
								edxOut = edx_153;
								ediOut = 0x080CE000;
								return ecx_154;
							}
						}
						cu8 al_102 = (byte) (eax_44 & 0x3F);
						edx = (word32) al_102;
						if (al_102 <= 0x11)
						{
							*((word32) dwArg04 + (edx * 0x08 + 4)) = 0x00;
							esi_107 = ebx_45;
						}
						else
							esi_107 = ebx_45;
					}
					else
					{
						cu8 al_67 = (byte) (eax_44 & 0x3F);
						int32 edi_63 = 0x00;
						ui32 esi_68 = (word32) al_67;
						esi_107 = ebx_45;
						uip32 ecx_247 = 0x00;
						do
						{
							esi_107 = (word32) esi_107 + 1;
							ui32 ebx_74 = (word32) *((word32) esi_107 - 1);
							edx = (ebx_74 & 0x7F) << (byte) ecx_247;
							ecx = ecx_247 + 0x07;
							edi_63 |= edx;
							ecx_247 += 0x07;
						} while ((byte) ebx_74 < 0x00);
						int32 edi_90 = edi_63 *s *((word32) dwArg04 + 0x00AC);
						if (al_67 <= 0x11)
						{
							struct Eq_146464 * eax_96 = (word32) dwArg04 + esi_68 * 0x08;
							eax_96->dw0004 = 0x01;
							eax_96->dw0000 = edi_90;
						}
					}
				}
				else
				{
					*((word32) dwArg04 + 0x00A4) = (word32) edx + (eax_44 & 0x3F) *s *((word32) dwArg04 + 0x00B0);
					esi_107 = ebx_45;
				}
				if (edx <= esi_107)
					break;
				edx = *((word32) dwArg04 + 0x00A4);
			} while (edx < (ecx->dw0060 >> 0x1F) + ecx->dw004C);
		}
	}
	edxOut = edx;
	ediOut = edi;
	return ecx;
}

// 0809D050: void init_dwarf_reg_size_table()
void init_dwarf_reg_size_table()
{
	g_t80CFB54.t0000 = 0x04;
	g_b80CFB56 = 0x04;
	g_b80CFB55 = 0x04;
	g_b80CFB57 = 0x04;
	g_b80CFB5A = 0x04;
	g_b80CFB5B = 0x04;
	g_b80CFB59 = 0x04;
	g_b80CFB58 = 0x04;
	g_b80CFB5F = 0x0C;
	g_b80CFB60 = 0x0C;
	g_b80CFB61 = 0x0C;
	g_b80CFB62 = 0x0C;
	g_b80CFB63 = 0x0C;
	g_b80CFB64 = 0x0C;
	g_b80CFB5D = 0x04;
	g_b80CFB5C = 0x04;
}

// 0809D0D0: Register Eq_2 uw_frame_state_for(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut, Register out Eq_2 edxOut)
// Called from:
//      uw_init_context_1
//      _Unwind_RaiseException_Phase2
//      _Unwind_ForcedUnwind_Phase2
//      __frame_state_for
//      _Unwind_RaiseException
//      _Unwind_Backtrace
Eq_2 uw_frame_state_for(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut, union Eq_2 & edxOut)
{
	word32 ecx_27;
	Eq_2 edi_26 = edx;
	for (ecx_27 = 0x30; ecx_27 != 0x00; --ecx_27)
	{
		*edi_26 = 0x00;
		edi_26 = (word32) edi_26 + 4;
	}
	((word32) eax + 0x0068)->u0 = 0x00;
	((word32) eax + 80)->u0 = 0x00;
	Eq_2 ecx_31 = *((word32) eax + 76);
	if (ecx_31 != 0x00)
	{
		Eq_2 ecx_123;
		Eq_2 edx_606;
		struct Eq_146558 * eax_54 = _Unwind_Find_FDE(gs, ecx_31 - 0x01 + (*((word32) eax + 96) >> 0x1F), (word32) eax + 84, out edx);
		if (eax_54 != null)
		{
			*((word32) edx + 0x00A4) = *((word32) eax + 92);
			struct Eq_146598 * eax_151 = &eax_54->dw0004 - eax_54->dw0004;
			struct Eq_146605 * dwLoc38_728 = &eax_151->b0009;
			struct Eq_146608 * esp_168 = fp - 0x4C;
			word32 ecx_924;
			Eq_2 edx_163;
			word32 eax_170 = eax_151 + 0x0A + strlen(&eax_151->b0009, out ecx_924, out edx_163);
			if (eax_151->b0009 == 101 && eax_151->b000A == 0x68)
			{
				edx_163 = *eax_170;
				*((word32) edx + 188) = edx_163;
				eax_170 = (word32) eax_170 + 4;
				dwLoc38_728 = (struct Eq_146605 *) (&eax_151->b000A + 1);
			}
			Eq_2 ecx_184 = (word32) eax_151->b0008;
			ui32 ebx_186 = (word32) *eax_170;
			cu8 cl_187 = (byte) ecx_184;
			byte bl_191 = (byte) ebx_186;
			if (cl_187 > 0x03)
			{
				if (bl_191 != 0x04 || *((word32) eax_170 + 1) != 0x00)
					goto l0809D4EC;
				ebx_186 = (word32) *((word32) eax_170 + 2);
				eax_170 = (word32) eax_170 + 2;
			}
			Eq_2 esi_199 = 0x00;
			uip32 ecx_907 = 0x00;
			while (true)
			{
				eax_170 = (word32) eax_170 + 1 + 0x02;
				esi_199 |= (ebx_186 & 0x7F) << (byte) ecx_907;
				if ((byte) ebx_186 >= 0x00)
					break;
				ebx_186 = (word32) *eax_170;
				ecx_907 += 0x07;
			}
			*((word32) edx + 0x00B0) = esi_199;
			int32 ebp_225 = 0x00;
			up32 ecx_910 = 0x00;
			while (true)
			{
				Eq_2 esi_230 = (word32) eax_170 + 1;
				ui32 ebx_232 = (word32) *((word32) esi_230 - 1);
				byte cl_257 = (byte) (ecx_910 + 0x07);
				ebp_225 |= (ebx_232 & 0x7F) << (byte) ecx_910;
				if ((byte) ebx_232 >= 0x00)
					break;
				eax_170 = esi_230;
				ecx_910 += 0x07;
			}
			Eq_2 ebx_249 = esi_230;
			if (ecx_910 <= 0x18 && (ebx_232 & 0x40) != 0x00)
				ebp_225 |= ~0x00 << cl_257;
			*((word32) edx + 0x00AC) = ebp_225;
			if (cl_187 != 0x01)
			{
				Eq_2 esi_281 = 0x00;
				uip32 ecx_913 = 0x00;
				do
				{
					ebx_249 = (word32) ebx_249 + 1;
					edx_163 = (word32) *((word32) ebx_249 - 1);
					esi_281 |= (edx_163 & 0x7F) << (byte) ecx_913;
					ecx_913 += 0x07;
				} while ((byte) edx_163 < 0x00);
				*((word32) edx + 0x00B4) = esi_281;
			}
			else
			{
				edx_163 = (word32) *esi_230;
				*((word32) edx + 0x00B4) = edx_163;
				ebx_249 = eax_170;
			}
			*((word32) edx + 0x00B9) = ~0x00;
			byte al_309 = dwLoc38_728->b0000;
			if (al_309 == 122)
			{
				do
				{
					ebx_249 = (word32) ebx_249 + 1;
					edx_163 = (word32) *((word32) ebx_249 - 1);
				} while ((byte) edx_163 < 0x00);
				*((word32) edx + 0x00BA) = 0x01;
				al_309 = dwLoc38_728->b0001;
				dwLoc38_728 = (struct Eq_146605 *) &dwLoc38_728->b0001;
			}
			ecx_184 = fp - 0x20;
			Eq_2 ebp_351 = ebx_249;
			byte * esi_353 = &dwLoc38_728->b0001;
			while (true)
			{
				Eq_2 ebp_363;
				if (al_309 == 0x00)
					break;
				if (al_309 == 0x4C)
				{
					*((word32) edx + 0x00B9) = *ebp_351;
					ebp_351 = (word32) ebp_351 + 1;
				}
				else if (al_309 != 0x52)
				{
					if (al_309 != 0x50)
					{
						if (al_309 != 0x53)
						{
							ebp_363 = esp_168->t001C;
							goto l0809D4E4;
						}
						*((word32) edx + 0x00BB) = 0x01;
					}
					else
					{
						Eq_146250 ebx_380 = (word32) *ebp_351;
						base_of_encoded_value(ebx_380, ecx_184, gs);
						struct Eq_146960 * esp_390 = esp_168 - 0x0C;
						esp_390->ptrFFFFFFFC = esp_390->ptr0020;
						Eq_2 esp_402 = <invalid>;
						ebp_351 = read_encoded_value_with_base(ebx_380, (word32) ebp_351 + 1, gs, esp_390->ptrFFFFFFFC, out ecx_184, out edx_163, out esi_353);
						*((word32) edx + 0x00A8) = *((word32) esp_402 + 64);
						esp_168 = (word32) esp_402 + 20;
					}
				}
				else
				{
					*((word32) edx + 0x00B8) = *ebp_351;
					ebp_351 = (word32) ebp_351 + 1;
				}
				al_309 = *esi_353;
				++esi_353;
			}
			ebp_363 = esp_168->t001C;
			if (ebp_363 != 0x00)
			{
l0809D34E:
				word32 ebx_457;
				int32 * ecx_425 = esp_168->ptr0018;
				struct Eq_147003 * esp_426 = esp_168 - 0x0C;
				int32 eax_428 = *ecx_425;
				esp_426->tFFFFFFFC = edx;
				Eq_2 edi_446;
				word32 edx_925;
				Eq_2 ecx_444 = execute_cfa_program(ebp_363, esp_426->ptr0014, ecx_425 + 1 + eax_428, gs, esp_426->tFFFFFFFC, out edx_925, out edi_446);
				Eq_2 esp_440 = <invalid>;
				ui32 eax_452 = (word32) *((word32) edi_446 + 0x00B8);
				struct Eq_147036 * esp_453 = (word32) esp_440 + 20;
				if ((byte) eax_452 == ~0x00)
				{
					ebx_457 = 0x08;
					goto l0809D39F;
				}
				cu8 al_459 = (byte) (eax_452 & 0x07);
				if (al_459 == 0x02)
				{
					ebx_457 = 0x0C;
					goto l0809D39F;
				}
				if (al_459 > 0x02)
				{
					if (al_459 != 0x03)
					{
						if (al_459 == 0x04)
						{
							ebx_457 = 0x18;
l0809D39F:
							Eq_2 eax_521;
							Eq_2 esi_520;
							Eq_2 ebx_483 = (word32) *((word32) esp_440 + 32) + ebx_457;
							Eq_2 ebp_487 = (word32) *((word32) edi_446 + 0x00B9);
							if (*((word32) edi_446 + 0x00BA) != 0x00)
							{
								ui32 esi_500 = 0x00;
								uip32 ecx_919 = 0x00;
								do
								{
									ebx_483 = (word32) ebx_483 + 1;
									ui32 edx_504 = (word32) *((word32) ebx_483 - 1);
									esi_500 |= (edx_504 & 0x7F) << (byte) ecx_919;
									ecx_919 += 0x07;
								} while ((byte) edx_504 < 0x00);
								ecx_444 = ebp_487;
								esi_520 = (word32) ebx_483 + esi_500;
								eax_521 = ebx_483;
								if ((byte) ebp_487 == ~0x00)
								{
l0809D3E2:
									if (esi_520 != 0x00)
										eax_521 = esi_520;
									ebx_483 = eax_521;
l0809D3E9:
									int32 * ecx_585 = esp_453->ptr000C;
									struct Eq_147145 * esp_586 = esp_453 - 0x0C;
									int32 eax_588 = *ecx_585;
									esp_586->tFFFFFFFC = edi_446;
									word32 edi_930;
									ecx_123 = execute_cfa_program(ebx_483, esp_586->ptr0014, ecx_585 + 1 + eax_588, gs, esp_586->tFFFFFFFC, out edx_606, out edi_930);
l0809D407:
									ecxOut = ecx_123;
									edxOut = edx_606;
									return 0x00;
								}
							}
							else if ((byte) ebp_487 == ~0x00)
								goto l0809D3E9;
							Eq_146250 ebp_532 = (word32) (byte) ebp_487;
							base_of_encoded_value(ebp_532, ecx_444, gs);
							*((word32) esp_440 + 4) = (word32) esp_440 + 64;
							word32 ecx_928;
							word32 edx_929;
							eax_521 = read_encoded_value_with_base(ebp_532, ebx_483, gs, *((word32) esp_440 + 4), out ecx_928, out edx_929, out esi_520);
							Eq_2 esp_559 = <invalid>;
							*((word32) *((word32) esp_559 + 28) + 80) = *((word32) esp_559 + 64);
							esp_453 = (word32) esp_559 + 20;
							goto l0809D3E2;
						}
l0809D61E:
						word32 ecx_926;
						word32 edx_927;
						abort(ecx_444, gs, out ecx_926, out edx_927);
					}
				}
				else if (al_459 != 0x00)
					goto l0809D61E;
				ebx_457 = 0x10;
				goto l0809D39F;
			}
			ebp_363 = ebp_351;
l0809D4E4:
			if (ebp_363 != 0x00)
				goto l0809D34E;
l0809D4EC:
			ecxOut = ecx_184;
			edxOut = edx_163;
			return 0x03;
		}
		struct Eq_146579 * eax_73;
		ecx_31 = *((word32) eax + 72);
		Eq_2 eax_66 = *((word32) eax + 76);
		if (*eax_66 == 0xB858 && (*((word32) eax_66 + 2) == 0x77 && *((word32) eax_66 + 6) == 0x80CD))
		{
			eax_73 = (word32) ecx_31 + 4;
l0809D546:
			edx_606 = eax_73->t001C;
			*((word32) edx + 4) = 0x01;
			*((word32) edx + 0x00A0) = (struct Eq_22879 *) 0x01;
			*((word32) edx + 28) = 0x01;
			((word32) edx + 0x0098)->u0 = 0x04;
			*((word32) edx + 0x0094) = edx_606 - ecx_31;
			*edx = (char *) &eax_73->t001C + 16 - edx_606;
			*((word32) edx + 0x0C) = 0x01;
			*((word32) edx + 24) = (char *) &eax_73->t001C + 4 - edx_606;
			*((word32) edx + 20) = 0x01;
			*((word32) edx + 8) = (char *) &eax_73->t001C + 0x0C - edx_606;
			((word32) edx + 52)->u0 = 0x01;
			*((word32) edx + 16) = (char *) &eax_73->t001C + 8 - edx_606;
			((word32) edx + 60)->u0 = 0x01;
			*((word32) edx + 48) = (char *) eax_73 + 20 - edx_606;
			*((word32) edx + 44) = 0x01;
			*((word32) edx + 56) = (char *) eax_73 + 16 - edx_606;
			((word32) edx + 0x0044)->u0 = 0x01;
			*((word32) edx + 64) = (char *) &eax_73->t001C + 28 - edx_606;
			ecx_123 = (char *) eax_73 + 24 - edx_606;
			*((word32) edx + 40) = ecx_123;
			((word32) edx + 0x00B4)->u0 = 0x08;
			*((word32) edx + 0x00BB) = 0x01;
			goto l0809D407;
		}
		if (*eax_66 == 0xB8 && (*((word32) eax_66 + 1) == 0xAD && *((word32) eax_66 + 5) == 0x80CD))
		{
			eax_73 = (word32) ecx_31 + 0x00A0;
			goto l0809D546;
		}
	}
	ecxOut = ecx_31;
	edxOut = edx;
	return 0x05;
}

// 0809D630: Register (ptr32 Eq_22871) execute_stack_op(Register (ptr32 Eq_22871) eax, Register (ptr32 Eq_22871) edx, Stack (ptr32 Eq_22871) dwArg04, Register out (ptr32 Eq_22871) edxOut, Register out (ptr32 Eq_147196) ebpOut)
// Called from:
//      uw_frame_state_for
//      uw_update_context_1
struct Eq_22871 * execute_stack_op(struct Eq_22871 * eax, struct Eq_22871 * edx, struct Eq_22871 * dwArg04, struct Eq_22871 & edxOut, struct Eq_147196 & ebpOut)
{
	if (eax >= edx)
	{
		edxOut = edx;
		ebpOut = ebp;
		return dwArg04;
	}
	else
	{
		Mem35 = Mem32;
		word32 eax_36 = (word32) eax->b0000;
		cu8 cl_40 = (byte) (eax_36 - 0x03);
		if (cl_40 > ~0x11)
		{
			word32 ecx_142;
			word32 edx_143;
			abort(eax_36 - 0x03, gs, out ecx_142, out edx_143);
		}
		else
		{
			ui32 ecx_88 = (word32) cl_40;
			struct Eq_147196 * ebp_90 = g_a80B9F4C[ecx_88 * 0x04] + 0x080CE000;
			struct Eq_22871 * eax_94;
			struct Eq_22871 * edx_95;
			ebp_90();
			edxOut = edx_95;
			ebpOut = ebp_90;
			return eax_94;
		}
	}
}

// 0809DD30: Register Eq_2 uw_update_context_1(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out Eq_147238 ebxOut, Register out Eq_2 ebpOut, Register out Eq_2 esiOut, Register out (ptr32 code) ediOut)
// Called from:
//      uw_init_context_1
//      uw_update_context
Eq_2 uw_update_context_1(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs, Eq_2 dwArg00, Eq_2 dwArg04, Eq_2 dwArg08, union Eq_147238 & ebxOut, union Eq_2 & ebpOut, union Eq_2 & esiOut, <anonymous> & ediOut)
{
	Eq_2 ecx_262;
	Eq_2 ebp_120 = edx;
	word32 * edi_23 = fp - 0x9C;
	Eq_2 esi_256 = eax;
	for (ecx_262 = 0x20; ecx_262 != 0x00; --ecx_262)
	{
		*edi_23 = (word32) *esi_256;
		esi_256 = (word32) esi_256 + 4;
		++edi_23;
	}
	if (((dwLoc3C & 0x40000000) == 0x00 || bLoc2C == 0x00) && dwLoc8C == 0x00)
	{
		if (g_b80CFB58 != 0x04)
			uw_update_context_1.cold.9(ecx_262, gs);
		if ((dwLoc3C & 0x40000000) != 0x00)
			bLoc2C = 0x00;
		dwLoc8C = fp - 0xA0;
	}
	if ((*((word32) eax + 99) & 0x40) != 0x00)
		*((word32) eax + 112) = 0x00;
	ui32 edx_124;
	*((word32) eax + 16) = 0x00;
	struct Eq_22879 * eax_77 = *((word32) edx + 0x00A0);
	if (eax_77 == (struct Eq_22879 *) 0x01)
	{
		Eq_2 eax_134 = *((word32) edx + 0x0098);
		if (eax_134 > 0x11)
			uw_update_context_1.cold.9(ecx_262, gs);
		edx_124 = dwLoc3C & 0x40000000;
		Eq_2 ecx_144 = (fp - 0x9C)[eax_134];
		byte bl_150 = Mem71[0x080CFB54<p32> + eax_134:byte];
		if (((dwLoc3C & 0x40000000) == 0x00 || Mem71[(fp - 0x30) + eax_134:byte] == 0x00) && bl_150 != 0x04)
			uw_update_context_1.cold.9(ecx_144, gs);
	}
	else
	{
		if (eax_77 != (struct Eq_22879 *) 0x02)
		{
			word32 ecx_455;
			word32 edx_456;
			abort(ecx_262, gs, out ecx_455, out edx_456);
		}
		struct Eq_22871 * eax_89 = *((word32) edx + 0x009C);
		int32 esi_106 = 0x00;
		uip32 ecx_448 = 0x00;
		do
		{
			++eax_89;
			ui32 ebx_98 = (word32) eax_89->bFFFFFFFF;
			esi_106 |= (ebx_98 & 0x7F) << (byte) ecx_448;
			ecx_448 += 0x07;
		} while ((byte) ebx_98 < 0x00);
		Eq_2 esp_126 = <invalid>;
		*((word32) esp_126 + 24) = execute_stack_op(eax_89, eax_89 + esi_106, null, out edx_124, out ebp_120);
	}
	*((word32) dwArg00 + 72) = dwArg08;
	Eq_147238 ebx_170 = 0x00;
	do
	{
		if (*((word32) ebp_120 + (ebx_170 * 0x08 + 4)) <= 0x05)
		{
			uint32 eax_234 = *((word32) ebp_120 + (ebx_170 * 0x08 + 4));
			word32 edi_236 = (dwArg04 + ~0x00013CA3)[eax_234 * 0x04] + dwArg04;
			Eq_2 ecx_252;
			edi_236();
			ebxOut = ebx_170;
			ebpOut = ebp_120;
			esiOut = dwArg04;
			ediOut = edi_236;
			return ecx_252;
		}
		ebx_170 = (word32) ebx_170.u0 + 1;
	} while (ebx_170 != 0x12);
	Eq_2 edx_188 = *((word32) dwArg00 + 96);
	Eq_2 eax_190 = edx_188 & 0x7FFFFFFF;
	if (*((word32) ebp_120 + 0x00BB) != 0x00)
		eax_190 = edx_188 | 0x80000000;
	Eq_2 edx_200 = *((word32) dwArg00 + 76);
	*((word32) dwArg00 + 96) = eax_190;
	if (*edx_200 == 0xB8 && *((word32) edx_200 + 1) == 0xAD)
	{
		Eq_55176 dx_208 = *((word32) edx_200 + 5);
		if (dx_208 == 0x80CD || dx_208 == 0x050F)
			*((word32) dwArg00 + 96) = eax_190 | 0x80000000;
	}
	ebxOut = ebx;
	ebpOut = ebp;
	esiOut = esi;
	ediOut = edi;
	return dwArg00;
}

// 0809E0B0: Register word32 uw_init_context_1(Register Eq_2 eax, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg00, Register out Eq_2 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      uw_update_context_1
//      _Unwind_RaiseException
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
//      _Unwind_Backtrace
word32 uw_init_context_1(Eq_2 eax, struct Eq_9 * gs, Eq_2 dwArg00, union Eq_2 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_2 edi_147 = eax;
	word32 ecx_150;
	for (ecx_150 = 0x20; ecx_150 != 0x00; --ecx_150)
	{
		*edi_147 = 0x00;
		edi_147 = (word32) edi_147 + 4;
	}
	((word32) eax + 96)->u0 = 0x40000000;
	*((word32) eax + 76) = dwArg00;
	Eq_2 ecx_40;
	word32 edx_41;
	if (uw_frame_state_for(eax, fp - 220, gs, out ecx_40, out edx_41) != 0x00)
		uw_init_context_1.cold.10(ecx_40, gs);
	else
	{
		Mem73 = Mem36;
		if (g_t80CFB54.t0000 == 0x00)
		{
			g_t80CFB54.t0000 = 0x04;
			g_b80CFB56 = 0x04;
			g_b80CFB55 = 0x04;
			g_b80CFB57 = 0x04;
			g_b80CFB5A = 0x04;
			g_b80CFB5B = 0x04;
			g_b80CFB59 = 0x04;
			g_b80CFB58 = 0x04;
			g_b80CFB5F = 0x0C;
			g_b80CFB60 = 0x0C;
			g_b80CFB61 = 0x0C;
			g_b80CFB62 = 0x0C;
			g_b80CFB63 = 0x0C;
			g_b80CFB64 = 0x0C;
			g_b80CFB5D = 0x04;
			g_b80CFB5C = 0x04;
		}
		if (g_b80CFB58 != 0x04)
			uw_init_context_1.cold.10(ecx_40, gs);
		else
		{
			if ((*((word32) eax + 99) & 0x40) != 0x00)
				*((word32) eax + 112) = 0x00;
			*((word32) eax + 16) = fp - 0xE0;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_2 stackArg0 = <invalid>;
			Eq_2 stackArg4 = <invalid>;
			Eq_2 stackArg8 = <invalid>;
			word32 edi_199;
			word32 esi_198;
			word32 ebp_197;
			word32 ebx_196;
			uw_update_context_1(eax, fp - 220, gs, stackArg0, stackArg4, stackArg8, out ebx_196, out ebp_197, out esi_198, out edi_199);
			*((word32) eax + 76) = dwLocEC;
			ebpOut = dwArg00;
			esiOut = edi;
			ediOut = ebp;
			return esi;
		}
	}
}

// 0809E210: Register Eq_2 uw_update_context(Register Eq_2 eax, Register Eq_2 edx, Register Eq_2 ebx, Register Eq_2 esi, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_147611) ebpOut, Register out (ptr32 Eq_147612) esiOut, Register out ptr32 ediOut)
// Called from:
//      _Unwind_RaiseException_Phase2
//      _Unwind_ForcedUnwind_Phase2
//      _Unwind_RaiseException
//      _Unwind_Backtrace
Eq_2 uw_update_context(Eq_2 eax, Eq_2 edx, Eq_2 ebx, Eq_2 esi, struct Eq_9 * gs, struct Eq_147611 & ebpOut, struct Eq_147612 & esiOut, ptr32 & ediOut)
{
	word32 ebp_22;
	struct Eq_147615 * ebx_23;
	struct Eq_147616 * edi_26;
	struct Eq_147617 * esi_27;
	Eq_2 ecx_24 = uw_update_context_1(eax, edx, gs, dwLoc10, ebx, esi, out ebx_23, out ebp_22, out esi_27, out edi_26);
	int32 eax_33 = edi_26->dw00B4;
	if (edi_26->a0004[eax_33].dw0000 != 0x06)
	{
		if (eax_33 > 0x11)
			uw_update_context.cold.11(ecx_24, gs);
		else
		{
			Eq_2 ecx_38 = (word32) ebx_23->a1B54[eax_33];
			byte cl_46 = (byte) ecx_38;
			struct Eq_147639 * edx_39 = esi_27[eax_33 * 0x04 / 0x006C];
			if ((esi_27->b0063 & 0x40) == 0x00 || (esi_27->a006C)[eax_33] == 0x00)
			{
				if (cl_46 != 0x04)
					uw_update_context.cold.11(ecx_38, gs);
				edx_39 = edx_39->ptr0000;
			}
			esi_27->ptr004C = edx_39;
			return;
		}
	}
	else
	{
		esi_27->ptr004C = null;
		return;
	}
}

// 0809E280: Register Eq_2 _Unwind_RaiseException_Phase2(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut)
// Called from:
//      _Unwind_RaiseException
//      _Unwind_Resume
Eq_2 _Unwind_RaiseException_Phase2(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut)
{
	word32 ebp_119 = 0x01;
	Eq_2 esi_124 = eax;
	Eq_2 ebx_120 = edx;
	Eq_2 edi_122 = fp - 220;
	while (true)
	{
		word32 edx_202;
		word32 ecx_201;
		Eq_2 eax_34 = uw_frame_state_for(ebx_120, edi_122, gs, out ecx_201, out edx_202);
		Eq_2 ecx_109 = *((word32) ebx_120 + 72) - (*((word32) ebx_120 + 96) >> 0x1F);
		ui32 edx_50 = (word32) (int8) (*((word32) esi_124 + 16) == ecx_109);
		if (eax_34 != 0x00)
			break;
		if (dwLoc34 != null)
		{
			ui32 ecx_64 = edx_50 << 0x02 | 0x02;
			Eq_2 eax_82;
			dwLoc34();
			if (eax_82 == 0x07)
			{
				*ecx = ebp_119;
				ecxOut = ecx_109;
				return eax_82;
			}
			if (eax_82 != 0x08)
				break;
		}
		if (edx_50 << 0x02 != 0x00)
			_Unwind_RaiseException_Phase2.cold.12(ecx_109, gs);
		ebx_120 = uw_update_context(ebx_120, edi_122, ebx_120, esi_124, gs, out ebp_119, out esi_124, out edi_122);
	}
	ecxOut = ecx_109;
	return 0x02;
}

// 0809E350: Register Eq_2 _Unwind_ForcedUnwind_Phase2(Register Eq_2 eax, Register (ptr32 word32) ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs, Register out Eq_2 ecxOut)
// Called from:
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
Eq_2 _Unwind_ForcedUnwind_Phase2(Eq_2 eax, word32 * ecx, Eq_2 edx, struct Eq_9 * gs, union Eq_2 & ecxOut)
{
	word32 ebp_133 = 0x01;
	Eq_2 esi_138 = edx;
	Eq_2 ebx_134 = eax;
	<anonymous> * eax_23 = *((word32) eax + 0x0C);
	Eq_2 edi_136 = fp - 220;
	word32 eax_28 = *((word32) eax + 16);
	while (true)
	{
		word32 edx_296;
		word32 ecx_295;
		Eq_2 eax_35 = uw_frame_state_for(esi_138, edi_136, gs, out ecx_295, out edx_296);
		Eq_2 ecx_113 = eax_35;
		if (eax_35 != 0x00 && eax_35 != 0x05)
			break;
		Eq_2 ebp_119;
		word32 eax_52 = *ebx_134;
		word32 edx_53 = *((word32) ebx_134 + 4);
		if (eax_35 == 0x05)
		{
			word32 eax_165;
			eax_23();
			ebp_119 = eax_35;
			if (eax_165 != 0x00)
				break;
			goto l0809E424;
		}
		word32 edx_83;
		word32 eax_84;
		eax_23();
		if (eax_84 != 0x00)
			break;
		if (dwLoc34 != null)
		{
			Eq_2 eax_112;
			dwLoc34();
			if (eax_112 != 0x07)
			{
				if (eax_112 != 0x08)
					break;
				goto l0809E3C4;
			}
			ebp_119 = eax_112;
l0809E424:
			*ecx = ebp_133;
			ecxOut = ecx_113;
			return ebp_119;
		}
l0809E3C4:
		ebx_134 = uw_update_context(esi_138, edi_136, ebx_134, esi_138, gs, out ebp_133, out esi_138, out edi_136);
	}
	ecxOut = ecx_113;
	return 0x02;
}

// 0809E440: Register Eq_2 uw_install_context_1(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_RaiseException
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
Eq_2 uw_install_context_1(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 eax_22 = *((word32) edx + 96);
	if (((eax_22 & 0x40000000) == 0x00 || *((word32) edx + 112) == 0x00) && *((word32) edx + 16) == null)
	{
		Eq_2 ecx_37 = *((word32) edx + 72);
		if (g_b80CFB58 != 0x04)
			uw_install_context_1.cold.13(ecx_37, gs);
		if ((eax_22 & 0x40000000) != 0x00)
			*((word32) edx + 112) = 0x00;
		*((word32) edx + 16) = fp - 0x20;
	}
	struct Eq_147838 * eax_106 = null;
	do
	{
		Eq_2 ecx_68 = *((word32) eax + eax_106 * 0x04);
		Eq_2 esi_69 = *((word32) edx + eax_106 * 0x04);
		if (eax_106[((word32) eax + 0x006C) / 0x080CE001] != 0x00)
			uw_install_context_1.cold.13(ecx_68, gs);
		if (eax_106[((word32) edx + 0x006C) / 0x080CE001] == 0x00)
		{
			if (((int8) (esi_69 != 0x00) & (int8) (ecx_68 != 0x00)) != 0x00 && ecx_68 != esi_69)
			{
				union Eq_2 * ebp_102 = (word32) ((char *) eax_106 + 6996)[0x080CE000];
				if (ebp_102 >= (union Eq_2 *) 0x04)
				{
					*ecx_68 = *esi_69;
					Mem109[ecx_68 - 0x04 + ebp_102:word32] = Mem107[esi_69 - 0x04 + ebp_102:word32];
					word32 edi_111 = ecx_68 + 0x04 & ~0x03;
					word32 * ecx_112 = ecx_68 - edi_111;
					++eax_106;
					word32 * esi_113 = esi_69 - ecx_112;
					word32 ecx_115;
					for (ecx_115 = ecx_112 + ebp_102 >>u 0x02; ecx_115 != 0x00; --ecx_115)
					{
						*edi_111 = *esi_113;
						++esi_113;
						edi_111 += 4;
					}
					if (eax_106 == (struct Eq_147838 *) 0x11)
						break;
					continue;
				}
				if (ebp_102 != null)
				{
					*ecx_68 = *esi_69;
					if ((ebp_102 & 0x02) != 0x00)
						Mem141[ecx_68 - 0x02 + ebp_102:word16] = Mem135[esi_69 - 0x02 + ebp_102:word16];
				}
			}
		}
		else if (ecx_68 != 0x00)
		{
			if (Mem63[eax_106 + 6996 + 0x080CE000<p32>:byte] != 0x04)
				uw_install_context_1.cold.13(ecx_68, gs);
			*ecx_68 = esi_69;
		}
		eax_106 = (struct Eq_147838 *) ((char *) eax_106 + 1);
	} while (eax_106 != (struct Eq_147838 *) 0x11);
	Eq_2 eax_153 = 0x00;
	if ((*((word32) eax + 99) & 0x40) != 0x00 && *((word32) eax + 112) != 0x00)
		return 0x00;
	if (*((word32) eax + 16) != 0x00)
		return eax_153;
	Eq_2 ecx_177 = (word32) g_b80CFB58;
	byte cl_186 = (byte) ecx_177;
	struct Eq_147830 * eax_179 = *((word32) edx + 16);
	if ((*((word32) edx + 99) & 0x40) == 0x00 || *((word32) edx + 112) == 0x00)
	{
		if (cl_186 != 0x04)
			uw_install_context_1.cold.13(ecx_177, gs);
		eax_179 = eax_179->ptr0000;
	}
	eax_153 = (word32) *((word32) edx + 0x0068) + (eax_179 - *((word32) eax + 72));
	return eax_153;
}

// 0809E5D0: void _Unwind_GetGR(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack int32 dwArg08)
void _Unwind_GetGR(struct Eq_9 * gs, Eq_2 dwArg04, int32 dwArg08)
{
	if (dwArg08 > 0x11)
		_Unwind_GetGR.cold.14(dwArg04, gs);
	else
	{
		Eq_2 esi_18 = (word32) (&g_t80CFB54)[dwArg08];
		if ((*((word32) dwArg04 + 99) & 0x40) != 0x00 && ((word32) dwArg04 + 0x006C) + dwArg08 != 0x00)
			return;
		if ((byte) esi_18 == 0x04)
			return;
		_Unwind_GetGR.cold.14(esi_18, gs);
	}
}

// 0809E630: void _Unwind_GetCFA()
void _Unwind_GetCFA()
{
}

// 0809E640: void _Unwind_SetGR(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_22859) dwArg04, Stack (ptr32 Eq_22859) dwArg08, Stack (ptr32 Eq_22859) dwArg0C)
// Called from:
//      __gcc_personality_v0
void _Unwind_SetGR(struct Eq_9 * gs, struct Eq_22859 * dwArg04, struct Eq_22859 * dwArg08, struct Eq_22859 * dwArg0C)
{
	if (dwArg08 > (struct Eq_22859 *) 0x11)
		_Unwind_SetGR.cold.15(0x080CE000, gs);
	else
	{
		byte bl_32 = Mem8[0x080CFB54<p32> + dwArg08:byte];
		if ((dwArg04->b0063 & 0x40) != 0x00 && Mem8[(dwArg04 + 0x6C) + dwArg08:byte] != 0x00)
			dwArg04[dwArg08 * 0x04 / 0x006C] = (struct Eq_22859) dwArg0C;
		else
		{
			struct Eq_22859 * eax_30 = dwArg04[dwArg08 * 0x04 / 0x006C];
			if (bl_32 != 0x04)
				_Unwind_SetGR.cold.15(0x080CE000, gs);
			else
				(&(&(&(&(&(&(&(&(&eax_30->a0000[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = dwArg0C;
		}
	}
}

// 0809E6B0: void _Unwind_GetIP()
void _Unwind_GetIP()
{
}

// 0809E6C0: Register word32 _Unwind_GetIPInfo(Stack (ptr32 Eq_148120) dwArg04, Stack (ptr32 uint32) dwArg08, Register out (ptr32 uint32) ecxOut)
// Called from:
//      __gcc_personality_v0
word32 _Unwind_GetIPInfo(struct Eq_148120 * dwArg04, uint32 * dwArg08, uint32 & ecxOut)
{
	*dwArg08 = dwArg04->dw0060 >> 0x1F;
	word32 eax_11 = dwArg04->dw004C;
	ecxOut = dwArg08;
	return eax_11;
}

// 0809E6E0: void _Unwind_SetIP(Stack (ptr32 Eq_22859) dwArg04, Stack (ptr32 Eq_22859) dwArg08)
// Called from:
//      __gcc_personality_v0
void _Unwind_SetIP(struct Eq_22859 * dwArg04, struct Eq_22859 * dwArg08)
{
	dwArg04->ptr004C = dwArg08;
}

// 0809E6F0: Register Eq_2 _Unwind_GetLanguageSpecificData(Stack Eq_2 dwArg04)
// Called from:
//      __gcc_personality_v0
Eq_2 _Unwind_GetLanguageSpecificData(Eq_2 dwArg04)
{
	return *((word32) dwArg04 + 80);
}

// 0809E700: void _Unwind_GetRegionStart()
// Called from:
//      base_of_encoded_value
//      __gcc_personality_v0
void _Unwind_GetRegionStart()
{
}

// 0809E710: void _Unwind_FindEnclosingFunction(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
void _Unwind_FindEnclosingFunction(struct Eq_9 * gs, word32 dwArg04)
{
	word32 edx_50;
	_Unwind_Find_FDE(gs, dwArg04 - 0x01, fp - 0x18, out edx_50) == null;
}

// 0809E750: void _Unwind_GetDataRelBase()
// Called from:
//      base_of_encoded_value
void _Unwind_GetDataRelBase()
{
}

// 0809E760: void _Unwind_GetTextRelBase()
// Called from:
//      base_of_encoded_value
void _Unwind_GetTextRelBase()
{
}

// 0809E770: void __frame_state_for(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_148159) dwArg08)
void __frame_state_for(struct Eq_9 * gs, struct Eq_148159 * dwArg08)
{
	word32 ecx_122;
	word32 * edi_119 = fp - 0x015C;
	for (ecx_122 = 0x20; ecx_122 != 0x00; --ecx_122)
	{
		*edi_119 = 0x00;
		++edi_119;
	}
	word32 edx_213;
	word32 ecx_212;
	if (uw_frame_state_for(fp - 0x015C, fp - 220, gs, out ecx_212, out edx_213) != 0x00 || dwLoc3C == 0x02)
		return;
	int32 edx_63;
	for (edx_63 = 0x00; edx_63 != 0x12; ++edx_63)
	{
		byte cl_70 = (fp - 0xD8)[edx_63].b0000;
		dwArg08->a005C[edx_63] = cl_70;
		if (cl_70 != 0x01 && cl_70 != 0x02)
		{
			dwArg08->a0010[edx_63] = 0x00;
			++edx_63;
			if (edx_63 != 0x12)
				continue;
			break;
		}
		dwArg08->a0010[edx_63] = (fp - 220)[edx_63].dw0000;
	}
	dwArg08->dw0008 = dwLoc48;
	dwArg08->w0058 = (word16) dwLoc44;
	dwArg08->w005A = (word16) dwLoc28;
	dwArg08->dw000C = dwLocF4;
	dwArg08->dw0004 = dwLoc20;
}

// 0809E850: void _Unwind_DebugHook()
// Called from:
//      _Unwind_RaiseException
//      _Unwind_ForcedUnwind
//      _Unwind_Resume
//      _Unwind_Resume_or_Rethrow
void _Unwind_DebugHook()
{
}

// 0809E860: Register word32 _Unwind_RaiseException(Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
// Called from:
//      _Unwind_Resume_or_Rethrow
word32 _Unwind_RaiseException(struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 esp_40 = <invalid>;
	struct Eq_148255 * ebp_221;
	Eq_2 esi_217;
	word32 * edi_243;
	Eq_2 ebx_222 = uw_init_context_1(fp - 0x01DC, gs, dwLoc01F0, out ebp_221, out esi_217, out edi_243);
	Eq_2 esp_227 = (word32) esp_40 + 4;
	word32 ecx_247;
	for (ecx_247 = 0x20; ecx_247 != 0x00; --ecx_247)
	{
		*edi_243 = (word32) *esi_217;
		esi_217 = (word32) esi_217 + 4;
		++edi_243;
	}
	ebp_221->tFFFFFE24 = ebp_221 - 0xD8;
	while (true)
	{
		word32 edx_60;
		word32 ecx_317;
		Eq_2 eax_58 = uw_frame_state_for(ebx_222, ebp_221->tFFFFFE24, gs, out ecx_317, out edx_60);
		if (eax_58 == 0x05)
			break;
		if (eax_58 != 0x00)
			return ebp_221->dw0000;
		<anonymous> * eax_70 = ebp_221->ptrFFFFFFD0;
		if (eax_70 != null)
		{
			esi_217 = ebp_221->t0008;
			struct Eq_148331 * esp_76 = esp_227 - 0x08;
			esp_76->tFFFFFFFC = ebx_222;
			esp_76->tFFFFFFF8 = ebp_221->t0008;
			esp_76->dwFFFFFFF4 = (word32) *((word32) esi_217 + 4);
			esp_76->dwFFFFFFF0 = (word32) *esi_217;
			esp_76->dwFFFFFFEC = 0x01;
			esp_76->dwFFFFFFE8 = 0x01;
			word32 eax_96;
			eax_70();
			if (eax_96 == 0x06)
			{
				Eq_2 edi_103 = ebp_221->tFFFFFEF0;
				Eq_2 esi_106 = ebp_221->tFFFFFE20;
				*((word32) ebp_221->t0008 + 0x0C) = 0x00;
				*((word32) ebp_221->t0008 + 16) = edi_103 - (ebp_221->dwFFFFFF08 >> 0x1F);
				word32 ecx_104;
				Eq_2 edi_115 = ebx_222;
				Eq_2 eax_116 = ebp_221->t0008;
				for (ecx_104 = 0x20; ecx_104 != 0x00; --ecx_104)
				{
					*edi_115 = *esi_106;
					esi_106 = (word32) esi_106 + 4;
					edi_115 = (word32) edi_115 + 4;
				}
				word32 ecx_319;
				if (_Unwind_RaiseException_Phase2(eax_116, ebp_221->tFFFFFE24, ebx_222, gs, out ecx_319) != 0x07)
					return ebp_221->dw0000;
				int32 eax_136 = uw_install_context_1(ebp_221->tFFFFFE20, ebx_222, gs);
				word32 ebx_144 = ebp_221->dwFFFFFEF4;
				esp_76->dw0008 = eax_136;
				esp_76->dw0004 = eax_136;
				esp_76->dw0000 = ebx_144;
				esp_76->tFFFFFFFC = ebp_221->tFFFFFEF0;
				_Unwind_DebugHook();
				ebp_221->a0004[eax_136 / 4] = ebx_144;
				<anonymous> * ecx_183 = ebp_221->a0004[eax_136 / 4];
				ecx_183();
				return ebp_221->dw0000;
			}
			if (eax_96 == 0x08)
				goto l0809E8DD;
			return ebp_221->dw0000;
		}
l0809E8DD:
		word32 edi_318;
		ebx_222 = uw_update_context(ebx_222, ebp_221->tFFFFFE24, ebx_222, esi_217, gs, out ebp_221, out esi_217, out edi_318);
		esp_227.u0 = <invalid>;
	}
	return ebp_221->dw0000;
}

// 0809E9E0: void _Unwind_ForcedUnwind(Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
void _Unwind_ForcedUnwind(struct Eq_9 * gs, word32 dwArg00)
{
	struct Eq_148469 * ebp_33;
	word32 * esi_142;
	word32 * edi_144;
	Eq_2 ebx_34 = uw_init_context_1(fp - 0x011C, gs, dwLoc0130, out ebp_33, out esi_142, out edi_144);
	Eq_2 esp_39 = <invalid>;
	word32 eax_45 = ebp_33->dw000C;
	word32 ecx_148;
	for (ecx_148 = 0x20; ecx_148 != 0x00; --ecx_148)
	{
		*edi_144 = *esi_142;
		++esi_142;
		++edi_144;
	}
	Eq_2 esi_50 = ebp_33->t0008;
	*((word32) esi_50 + 0x0C) = eax_45;
	*((word32) esi_50 + 16) = ebp_33->dw0010;
	word32 ecx_185;
	if (_Unwind_ForcedUnwind_Phase2(esi_50, ebp_33 - 0x011C, ebp_33 - 0x98, gs, out ecx_185) != 0x07)
		return;
	int32 eax_72 = uw_install_context_1(ebx_34, ebp_33 - 0x98, gs);
	Eq_2 ebx_80 = ebp_33->tFFFFFFB4;
	*((word32) esp_39 + 4) = eax_72;
	*esp_39 = eax_72;
	*((word32) esp_39 - 4) = ebx_80;
	*((word32) esp_39 - 8) = ebp_33->tFFFFFFB0;
	_Unwind_DebugHook();
	ebp_33->a0004[eax_72 / 4] = (<anonymous> *) ebx_80;
	<anonymous> * ecx_123 = ebp_33->a0004[eax_72 / 4];
	ecx_123();
}

// 0809EAC0: Register word32 _Unwind_Resume(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      _IO_new_fclose.cold.0
//      _IO_fflush.cold.0
//      _IO_puts.cold.0
//      _IO_wfile_underflow.cold.2
//      _IO_new_file_underflow.cold.6
//      _IO_fputs.cold.0
//      _IO_fwrite.cold.0
//      _IO_getdelim.cold.0
word32 _Unwind_Resume(struct Eq_9 * gs, word32 dwArg00, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	struct Eq_148562 * ebp_37;
	word32 * esi_154;
	word32 * edi_156;
	Eq_2 ebx_38 = uw_init_context_1(fp - 0x011C, gs, dwLoc0140, out ebp_37, out esi_154, out edi_156);
	Eq_2 esp_43 = <invalid>;
	Eq_2 eax_49 = ebp_37->t0008;
	word32 ecx_160;
	for (ecx_160 = 0x20; ecx_160 != 0x00; --ecx_160)
	{
		*edi_156 = *esi_154;
		++esi_154;
		++edi_156;
	}
	Eq_2 ecx_65;
	word32 eax_64;
	if (*((word32) eax_49 + 0x0C) == 0x00)
		eax_64 = _Unwind_RaiseException_Phase2(eax_49, ebp_37 - 0x011C, ebx_38, gs, out ecx_65);
	else
		eax_64 = _Unwind_ForcedUnwind_Phase2(ebp_37->t0008, ebp_37 - 0x011C, ebx_38, gs, out ecx_65);
	if (eax_64 != 0x07)
		_Unwind_Resume.cold.16(ecx_65, gs);
	else
	{
		int32 eax_89 = uw_install_context_1(ebp_37->tFFFFFED4, ebx_38, gs);
		Eq_2 ebx_98 = ebp_37->tFFFFFFB4;
		*((word32) esp_43 - 4) = ebx_98;
		*((word32) esp_43 - 8) = ebp_37->tFFFFFFB0;
		_Unwind_DebugHook();
		ebp_37->a0004[eax_89 / 4] = (<anonymous> *) ebx_98;
		<anonymous> * ecx_140 = ebp_37->a0004[eax_89 / 4];
		word32 ecx_152;
		ecx_140();
		ptr32 esi_136 = ebp_37->ptrFFFFFFF8;
		ptr32 edi_137 = ebp_37->ptrFFFFFFFC;
		ebpOut = ebp_37->ptr0000;
		esiOut = esi_136;
		ediOut = edi_137;
		return ecx_152;
	}
}

// 0809EBC0: void _Unwind_Resume_or_Rethrow(Register (ptr32 Eq_9) gs, Stack word32 dwArg00, Stack (ptr32 Eq_148664) dwArg04)
void _Unwind_Resume_or_Rethrow(struct Eq_9 * gs, word32 dwArg00, struct Eq_148664 * dwArg04)
{
	if (dwArg04->dw000C == 0x00)
		_Unwind_RaiseException(gs, dwLoc0150);
	else
	{
		struct Eq_148674 * ebp_65;
		word32 * esi_125;
		word32 * edi_164;
		Eq_2 ebx_66 = uw_init_context_1(fp - 0x011C, gs, dwLoc0140, out ebp_65, out esi_125, out edi_164);
		Eq_2 esp_71 = <invalid>;
		word32 ecx_168;
		Eq_2 eax_78 = ebp_65->t0008;
		for (ecx_168 = 0x20; ecx_168 != 0x00; --ecx_168)
		{
			*edi_164 = *esi_125;
			++esi_125;
			++edi_164;
		}
		Eq_2 ecx_87;
		if (_Unwind_ForcedUnwind_Phase2(eax_78, ebp_65 - 0x011C, ebp_65 - 0x98, gs, out ecx_87) != 0x07)
			_Unwind_Resume_or_Rethrow.cold.17(ecx_87, gs);
		else
		{
			int32 eax_98 = uw_install_context_1(ebx_66, ebp_65 - 0x98, gs);
			Eq_2 edi_107 = ebp_65->tFFFFFFB4;
			*((word32) esp_71 - 4) = edi_107;
			*((word32) esp_71 - 8) = ebp_65->tFFFFFFB0;
			_Unwind_DebugHook();
			ebp_65->a0004[eax_98 / 4] = (<anonymous> *) edi_107;
			<anonymous> * ecx_150 = ebp_65->a0004[eax_98 / 4];
			ecx_150();
		}
	}
}

// 0809ECD0: void _Unwind_DeleteException(Stack (ptr32 Eq_148749) dwArg04)
void _Unwind_DeleteException(struct Eq_148749 * dwArg04)
{
	<anonymous> * eax_7 = dwArg04->ptr0008;
	if (eax_7 != null)
		eax_7();
}

// 0809ED00: void _Unwind_Backtrace(Register (ptr32 Eq_9) gs, Stack word32 dwArg00)
void _Unwind_Backtrace(struct Eq_9 * gs, word32 dwArg00)
{
	Eq_2 esp_32 = <invalid>;
	word32 edi_147;
	Eq_2 esi_31;
	struct Eq_148761 * ebp_26;
	Eq_2 ebx_27 = uw_init_context_1(fp - 0x015C, gs, dwLoc0160, out ebp_26, out esi_31, out edi_147);
	Eq_2 esp_37 = (word32) esp_32 + 4;
	while (true)
	{
		word32 ecx_148;
		word32 edx_149;
		Eq_2 eax_43 = uw_frame_state_for(ebx_27, esi_31, gs, out ecx_148, out edx_149);
		if (eax_43 != 0x00 && eax_43 != 0x05)
			break;
		struct Eq_148784 * esp_58 = esp_37 - 0x08;
		esp_58->dwFFFFFFFC = ebp_26->dw000C;
		esp_58->tFFFFFFF8 = ebx_27;
		word32 eax_76;
		ebp_26->ptr0008();
		if (eax_76 != 0x00)
			break;
		if (eax_43 == 0x05)
			return;
		word32 edi_150;
		ebx_27 = uw_update_context(ebx_27, esi_31, ebx_27, esi_31, gs, out ebp_26, out esi_31, out edi_150);
		esp_37.u0 = <invalid>;
	}
}

// 0809ED80: void fde_unencoded_compare(Stack (ptr32 Eq_148812) dwArg08, Stack (ptr32 Eq_148813) dwArg0C)
void fde_unencoded_compare(struct Eq_148812 * dwArg08, struct Eq_148813 * dwArg0C)
{
	dwArg08->dw0008 > dwArg0C->dw0008;
}

// 0809EDA0: void frame_downheap(Register Eq_2 eax, Register (arr Eq_148910) ecx, Register (ptr32 code) edx, Stack Eq_148824 dwArg04, Stack Eq_148824 dwArg08)
// Called from:
//      frame_heapsort
void frame_downheap(Eq_2 eax, Eq_148910 ecx[], <anonymous> * edx, Eq_148824 dwArg04, Eq_148824 dwArg08)
{
	Eq_148824 edx_100 = dwArg04;
	Eq_148824 ebx_22 = (word32) dwArg04 + ((word32) dwArg04 + 1);
	if (ebx_22 < dwArg08)
	{
		do
		{
			word32 * ecx_28 = ebx_22 * 0x04;
			word32 edi_31 = ecx + ecx_28;
			Eq_148824 esi_29 = (word32) ebx_22.u0 + 1;
			word32 eax_33 = *edi_31;
			if (esi_29 >= dwArg08)
				esi_29 = ebx_22;
			else
			{
				word32 ecx_37 = ecx + 0x04 + ecx_28;
				int32 eax_54;
				edx();
				dwArg04 = edx_100;
				ecx_28 = ecx_37;
				if (eax_54 >= 0x00)
				{
					eax_33 = *edi_31;
					esi_29 = ebx_22;
				}
				else
				{
					eax_33 = *ecx_37;
					edi_31 = ecx_37;
				}
			}
			word32 * ebx_73 = ecx + edx_100;
			int32 eax_89;
			edx();
			if (eax_89 >= 0x00)
				return;
			word32 eax_96 = *ebx_73;
			*ebx_73 = *edi_31;
			*edi_31 = eax_96;
			ebx_22 = (word32) esi_29.u0 + ((word32) esi_29.u0 + 1);
			edx_100 = esi_29;
		} while (dwArg08 > ebx_22);
	}
}

// 0809EE60: void frame_heapsort(Register Eq_2 eax, Register Eq_2 ecx, Register (ptr32 code) edx)
// Called from:
//      search_object
void frame_heapsort(Eq_2 eax, Eq_2 ecx, <anonymous> * edx)
{
	Eq_148824 ebx_21 = *((word32) ecx + 4);
	Eq_148824 esi_28 = (ebx_21 >> 0x01) - 0x01;
	if (esi_28 != ~0x00)
	{
		Eq_148824 esi_33 = esi_28;
		do
		{
			frame_downheap(eax, (word32) ecx + 8, edx, esi_33, ebx_21);
			--esi_33;
		} while (esi_33 != ~0x00);
	}
	Eq_148824 ebx_61 = ebx_21 - 0x01;
	if (ebx_21 > 0x01)
	{
		do
		{
			Eq_148910 eax_70 = *((word32) ecx + 8);
			*((word32) ecx + 8) = *((word32) ecx + (ebx_61 * 0x04 + 8));
			*((word32) ecx + (ebx_61 * 0x04 + 8)) = eax_70;
			frame_downheap(eax, (word32) ecx + 8, edx, 0x00, ebx_61);
			--ebx_61;
		} while (ebx_61 != 0x00);
	}
}

// 0809EF00: Register ui32 size_of_encoded_value(Register Eq_148936 al, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      linear_search_fdes
//      _Unwind_IteratePhdrCallback
//      classify_object_over_fdes
//      add_fdes
ui32 size_of_encoded_value(Eq_148936 al, Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_148936 al = (byte) eax;
	ui32 eax_13;
	if (al == ~0x00)
	{
		eax_13 = 0x00;
		return eax_13;
	}
	else
	{
		cu8 al_19 = (byte) (eax & 0x07);
		if (al_19 == 0x02)
		{
			eax_13 = 0x02;
			return eax_13;
		}
		else
		{
			if (al_19 > 0x02)
			{
				if (al_19 == 0x03)
					return 0x04;
				if (al_19 == 0x04)
				{
					eax_13 = 0x08;
					return eax_13;
				}
			}
			else if (al_19 == 0x00)
				return 0x04;
			word32 edx_73;
			word32 ecx_72;
			abort(ecx, gs, out ecx_72, out edx_73);
		}
	}
}

// 0809EF60: Register ui32 base_from_object(Register Eq_148936 al, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      size_of_encoded_value
//      fde_single_encoding_compare
//      linear_search_fdes
//      fde_mixed_encoding_compare
//      classify_object_over_fdes
//      add_fdes
//      search_object
//      _Unwind_Find_FDE
ui32 base_from_object(Eq_148936 al, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_148936 al = (byte) eax;
	if (al == ~0x00)
		return 0x00;
	ui32 eax_34;
	cu8 al_16 = (byte) (eax & 0x70);
	if (al_16 == 0x20)
	{
		eax_34 = (ui32) *((word32) edx + 4);
		return eax_34;
	}
	else
	{
		if (al_16 > 0x20)
		{
			if (al_16 == 0x30)
			{
				eax_34 = (ui32) *((word32) edx + 8);
				return eax_34;
			}
			if (al_16 == 0x50)
				return 0x00;
		}
		else if (al_16 == 0x00 || al_16 == 0x10)
			return 0x00;
		word32 edx_73;
		word32 ecx_72;
		abort(ecx, gs, out ecx_72, out edx_73);
	}
}

// 0809EFC0: void base_from_cb_data(Register Eq_148936 al, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_IteratePhdrCallback
void base_from_cb_data(Eq_148936 al, Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_148936 al = (byte) eax;
	if (al == ~0x00)
		return;
	cu8 al_16 = (byte) (eax & 0x70);
	if (al_16 == 0x20)
		return;
	if (al_16 > 0x20)
	{
		if (al_16 == 0x30)
			return;
		if (al_16 == 0x50)
			return;
	}
	else if (al_16 == 0x00 || al_16 == 0x10)
		return;
	word32 edx_73;
	word32 ecx_72;
	abort(ecx, gs, out ecx_72, out edx_73);
}

// 0809F020: Register Eq_148936 read_encoded_value_with_base(Register Eq_148936 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out Eq_2 ecxOut, Register out ptr32 edxOut, Register out (ptr32 Eq_149037) ebxOut, Register out Eq_2 esiOut)
// Called from:
//      fde_single_encoding_compare
//      get_cie_encoding
//      linear_search_fdes
//      _Unwind_IteratePhdrCallback
//      fde_mixed_encoding_compare
//      classify_object_over_fdes
//      add_fdes
//      search_object
//      _Unwind_Find_FDE
Eq_148936 read_encoded_value_with_base(Eq_148936 eax, Eq_2 ecx, struct Eq_9 * gs, word32 * dwArg04, union Eq_2 & ecxOut, ptr32 & edxOut, struct Eq_149037 & ebxOut, union Eq_2 & esiOut)
{
	byte al = (byte) eax;
	word24 eax_24_8 = SLICE(eax, word24, 8);
	if (al == 0x50)
	{
		word32 * esi_28 = (word32) ecx + 3 & ~0x03;
		*dwArg04 = *esi_28;
		ecxOut = ecx;
		edxOut = esi_28 + 1;
		ebxOut = ebx;
		esiOut = esi;
		return esi_28 + 1;
	}
	else
	{
		cu8 dl_47 = (byte) (eax & 0x0F);
		if (dl_47 > 0x0C)
			read_encoded_value_with_base.cold.8(ecx, gs);
		else
		{
			ui32 edx_51 = (word32) dl_47;
			<anonymous> * ecx_53 = g_a80BA374[edx_51 * 0x04] + 0x080CE000;
			Eq_2 ecx_55;
			ptr32 edx_56;
			Eq_148936 eax_57;
			ecx_53();
			ecxOut = ecx_55;
			edxOut = edx_56;
			ebxOut = (struct Eq_149037 *) &g_t80CE000;
			esiOut = ecx;
			return eax_57;
		}
	}
}

// 0809F170: void fde_single_encoding_compare(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack word32 dwArg08)
void fde_single_encoding_compare(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04, word32 dwArg08)
{
	Eq_148936 ebx_21 = (word32) (byte) (*((word32) dwArg04 + 16) >> 0x03);
	base_from_object(ebx_21, ecx, dwArg04, gs);
	word32 ebx_115;
	word32 edx_114;
	word32 ecx_113;
	word32 esi_116;
	read_encoded_value_with_base(ebx_21, dwArg08 + 0x08, gs, fp - 0x14, out ecx_113, out edx_114, out ebx_115, out esi_116);
	Eq_2 esp_44 = <invalid>;
	Eq_2 eax_51 = *((word32) esp_44 + 60);
	cu16 ax_60 = *((word32) dwArg04 + 16);
	*((word32) esp_44 + 4) = (word32) esp_44 + 32;
	word32 ecx_117;
	word32 edx_118;
	word32 ebx_119;
	word32 esi_120;
	read_encoded_value_with_base((word32) (byte) (ax_60 >> 0x03), (word32) eax_51 + 8, gs, *((word32) esp_44 + 4), out ecx_117, out edx_118, out ebx_119, out esi_120);
}

// 0809F1F0: Register (ptr32 Eq_149149) get_cie_encoding(Register (ptr32 Eq_149149) eax, Register (ptr32 Eq_9) gs, Register out (ptr32 Eq_149151) ecxOut)
// Called from:
//      linear_search_fdes
//      _Unwind_IteratePhdrCallback
//      fde_mixed_encoding_compare
//      classify_object_over_fdes
//      add_fdes
//      search_object
//      _Unwind_Find_FDE
struct Eq_149149 * get_cie_encoding(struct Eq_149149 * eax, struct Eq_9 * gs, struct Eq_149151 & ecxOut)
{
	struct Eq_149149 * eax_150;
	word32 ecx_264;
	word32 edx_265;
	Eq_2 eax_22 = strlen(&eax->b0009, out ecx_264, out edx_265);
	struct Eq_149151 * ecx_127 = (word32) eax->b0008;
	cu8 cl_32 = (byte) ecx_127;
	ptr32 esp_109 = fp - 0x1C;
	word32 edx_165 = eax + 0x0A + eax_22;
	if (cl_32 > 0x03)
	{
		eax_150 = (struct Eq_149149 *) 0xFF;
		if (*edx_165 != 0x04 || *((word32) edx_165 + 1) != 0x00)
			goto l0809F228;
		edx_165 = (word32) edx_165 + 2;
	}
	if (eax->b0009 == 122)
	{
		do
		{
			edx_165 = (word32) edx_165 + 1;
			if (*((word32) edx_165 - 1) >= 0x00)
				break;
			edx_165 = (word32) edx_165 + 1;
		} while (*edx_165 < 0x00);
		while (true)
		{
			Eq_2 eax_104 = (word32) edx_165 + 1;
			if (*((word32) eax_104 - 1) >= 0x00)
				break;
			edx_165 = eax_104;
		}
		if (cl_32 != 0x01)
		{
			do
				eax_104 = (word32) eax_104 + 1;
			while (*((word32) eax_104 - 1) < 0x00);
		}
		else
			eax_104 = (word32) edx_165 + 2;
		byte * ebx_100 = &eax->b000A;
		do
			eax_104 = (word32) eax_104 + 1;
		while (*((word32) eax_104 - 1) < 0x00);
		word32 edx_103 = (word32) eax->b000A;
		word32 * esi_115 = fp - 0x10;
		while ((byte) edx_103 != 0x52)
		{
			byte dl_95 = (byte) edx_103;
			if (dl_95 != 0x50)
			{
				if (dl_95 != 0x4C)
					goto l0809F226;
				++ebx_100;
				edx_103 = (word32) *ebx_100;
				eax_104 = (word32) eax_104 + 1;
				if ((byte) edx_103 != 0x52)
					continue;
				break;
			}
			struct Eq_149263 * esp_110 = esp_109 - 0x0C;
			ui32 eax_112 = (word32) *eax_104;
			esp_110->ptrFFFFFFFC = esi_115;
			word32 edx_266;
			eax_104 = read_encoded_value_with_base(eax_112 & 0x7F, (word32) eax_104 + 1, gs, esp_110->ptrFFFFFFFC, out ecx_127, out edx_266, out ebx_100, out esi_115);
			Eq_2 esp_126 = <invalid>;
			edx_103 = (word32) *ebx_100;
			esp_109 = (word32) esp_126 + 20;
		}
		struct Eq_149149 * eax_140 = (word32) *eax_104;
		ecxOut = ecx_127;
		return eax_140;
	}
l0809F226:
	eax_150 = null;
l0809F228:
	ecxOut = ecx_127;
	return eax_150;
}

// 0809F300: Register Eq_2 linear_search_fdes(Register Eq_2 eax, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_IteratePhdrCallback
//      search_object
Eq_2 linear_search_fdes(Eq_2 eax, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_148936 esi_138 = (word32) (byte) (*((word32) eax + 16) >> 0x03);
	base_from_object(esi_138, ecx, eax, gs);
	Eq_2 ebx_136 = edx;
	struct Eq_149324 * esp_152 = fp - 0x4C;
	if (*edx != 0x00)
	{
		do
		{
			ui32 edx_49 = *((word32) ebx_136 + 4);
			if (edx_49 != 0x00)
			{
				if ((*((word32) eax + 16) & 0x04) != 0x00)
				{
					struct Eq_149149 * edi_58 = (word32) ebx_136 + 4 - edx_49;
					if (edi_58 != esp_152->ptr000C)
					{
						Eq_2 ecx_65;
						Eq_148936 eax_64 = get_cie_encoding(edi_58, gs, out ecx_65);
						word32 eax_75 = base_from_object((word32) (byte) eax_64, ecx_65, eax, gs);
						esp_152->ptr000C = edi_58;
						esp_152->dw0014 = eax_75;
						esi_138 = eax_64;
					}
				}
				if (esi_138 != 0x00)
				{
					struct Eq_149401 * esp_101 = esp_152 - 0x0C;
					esp_101->ptrFFFFFFFC = esp_101->ptr0024;
					Eq_148936 edi_109 = (word32) (byte) esi_138;
					ui32 esi_116;
					word32 ebx_289;
					word32 edx_288;
					word32 ecx_287;
					Eq_2 eax_113 = read_encoded_value_with_base(edi_109, (word32) ebx_136 + 8, gs, esp_101->ptrFFFFFFFC, out ecx_287, out edx_288, out ebx_289, out esi_116);
					Eq_2 esp_117 = <invalid>;
					*((word32) esp_117 + 4) = *((word32) esp_117 + 48);
					Eq_2 ecx_140;
					word32 edx_290;
					read_encoded_value_with_base(esi_116 & 0x0F, eax_113, gs, *((word32) esp_117 + 4), out ecx_140, out edx_290, out ebx_136, out esi_138);
					Eq_2 esp_139 = <invalid>;
					Eq_149449 eax_147 = size_of_encoded_value(edi_109, ecx_140, gs);
					esp_152 = (word32) esp_139 + 20;
					ui32 edx_153 = ~0x00;
					if (eax_147 <= 0x03)
						edx_153 = (0x01 << (byte) (eax_147 * 0x08)) - 0x01;
					Eq_2 eax_164 = *((word32) esp_139 + 60);
					if ((eax_164 & edx_153) != 0x00 && *((word32) esp_139 + 36) - eax_164 < *((word32) esp_139 + 64))
						return ebx_136;
				}
				else
				{
					up32 eax_89 = *((word32) ebx_136 + 8);
					up32 edx_90 = *((word32) ebx_136 + 0x0C);
					esp_152->dw0028 = eax_89;
					esp_152->dw002C = edx_90;
					if (eax_89 != 0x00 && esp_152->dw0010 - eax_89 < edx_90)
						return ebx_136;
				}
			}
			ebx_136 = (word32) *ebx_136 + ((word32) ebx_136 + 4);
		} while (*ebx_136 != 0x00);
	}
	return 0x00;
}

// 0809F450: void _Unwind_IteratePhdrCallback(Register (ptr32 Eq_9) gs, Stack (ptr32 Eq_149487) dwArg04, Stack up32 dwArg08, Stack (ptr32 Eq_149489) dwArg0C)
void _Unwind_IteratePhdrCallback(struct Eq_9 * gs, struct Eq_149487 * dwArg04, up32 dwArg08, struct Eq_149489 * dwArg0C)
{
	word32 dwLoc58_705;
	Eq_2 dwLoc44_703;
	Eq_2 ecx_104;
	struct Eq_149493 * ebx_261;
	Eq_2 dwLoc40_708;
	struct Eq_149493 * dwLoc48_706;
	word32 edi_21 = dwArg04->dw0000;
	struct Eq_149493 * eax_23 = dwArg04->ptr0008;
	if (dwArg0C->dw0014 != 0x00 && dwArg08 > 0x1F)
	{
		word32 ecx_32 = dwArg04->dw0014;
		word32 ebx_31 = dwArg04->dw0010;
		word32 edi_30 = dwArg04->dw0018;
		word32 edi_35 = dwArg04->dw001C;
		if ((g_dw80CEF5C ^ ecx_32 | g_dw80CEF58 ^ ebx_31) != 0x00 || (edi_35 ^ g_dw80CFB8C | edi_30 ^ g_dw80CFB88) != 0x00)
		{
			g_dw80CEF58 = ebx_31;
			g_dw80CEF5C = ecx_32;
			g_dw80CFB8C = edi_35;
			g_dw80CFB88 = edi_30;
			struct Eq_150058 * ecx_119 = &g_t80CFBB8;
			do
			{
				ecx_119->dwFFFFFFE8 = 0x00;
				ecx_119->dwFFFFFFEC = 0x00;
				ecx_119->dwFFFFFFFC = ecx_119;
				++ecx_119;
			} while (&any_objects_registered != ecx_119);
			frame_hdr_cache_head.u0 = 0x080CFBA0;
			g_dw80CFC5C = 0x00;
			dwArg0C->dw0014 = 0x00;
			dwLoc40_708.u0 = 0x00;
			dwLoc44_703.u0 = 0x00;
l0809F4A4:
			ui32 edx_169 = (word32) dwArg04->w000C;
			dwLoc58_705 = edi_21;
			struct Eq_149493 * eax_178 = eax_23;
			if ((word16) edx_169 == 0x00)
				return;
			Eq_2 dwLoc4C_723 = 0x00;
			struct Eq_149493 * edx_186 = eax_23 + (edx_169 << 0x05) / 32;
			Eq_2 dwLoc50_724 = 0x00;
			word32 dwLoc54_725 = 0x00;
			dwLoc48_706 = null;
			struct Eq_149493 * dwLoc5C_727 = null;
			do
			{
				ecx_104 = eax_178->dw0000;
				if (ecx_104 == 0x01)
				{
					Eq_2 esi_210 = edi_21 + eax_178->dw0008;
					ecx_104 = dwArg0C->t0000;
					if (ecx_104 >= esi_210)
					{
						Eq_2 ebx_223 = dwLoc4C_723;
						Eq_2 edi_224 = (word32) esi_210 + eax_178->dw0014;
						if (ecx_104 >= edi_224)
							esi_210 = dwLoc50_724;
						if (ecx_104 < edi_224)
							ebx_223 = edi_224;
						dwLoc50_724 = esi_210;
						dwLoc4C_723 = ebx_223;
						word32 ebx_239 = 0x01;
						if (ecx_104 >= edi_224)
							ebx_239 = dwLoc54_725;
						++eax_178;
						dwLoc54_725 = ebx_239;
						if (eax_178 == edx_186)
							break;
						continue;
					}
				}
				else if (ecx_104 != 0x6474E550)
				{
					struct Eq_149493 * ebx_201 = dwLoc5C_727;
					if (ecx_104 == 0x02)
						ebx_201 = eax_178;
					dwLoc5C_727 = ebx_201;
				}
				else
					dwLoc48_706 = eax_178;
				++eax_178;
			} while (eax_178 != edx_186);
			ebx_261 = dwLoc5C_727;
			if (dwLoc54_725 == 0x00)
				return;
			if (dwArg08 > 0x1F)
			{
				Eq_2 eax_280 = frame_hdr_cache_head;
				if (dwLoc40_708 != 0x00 && dwLoc44_703 != 0x00)
				{
					Eq_2 edx_288 = *((word64) dwLoc40_708.u0 + 20);
					frame_hdr_cache_head = dwLoc40_708;
					*((word64) dwLoc44_703.u0 + 20) = edx_288;
					*((word64) dwLoc40_708.u0 + 20) = eax_280;
					eax_280 = dwLoc40_708;
				}
				*((word32) eax_280 + 16) = dwLoc5C_727;
				*((word32) eax_280 + 8) = edi_21;
				*((word32) eax_280 + 4) = dwLoc4C_723;
				*((word32) eax_280 + 0x0C) = dwLoc48_706;
				*eax_280 = dwLoc50_724;
			}
l0809F5AB:
			if (dwLoc48_706 == null)
				return;
			struct Eq_149631 * esi_327 = dwLoc58_705 + dwLoc48_706->dw0008;
			if (esi_327->b0000 != 0x01)
				return;
			dwArg0C->dw0008 = 0x00;
			if (ebx_261 != null)
			{
				struct Eq_149684 * eax_337 = dwLoc58_705 + ebx_261->dw0008 + 0x04;
				word32 edx_338 = eax_337->dw0000;
				while (edx_338 != 0x00)
				{
					if (edx_338 == 0x03)
					{
						dwArg0C->dw0008 = eax_337->dw0000;
						break;
					}
					++eax_337;
					edx_338 = eax_337->dw0000;
				}
			}
			Eq_2 ecx_459;
			Eq_148936 ebx_359 = (word32) esi_327->b0001;
			base_from_cb_data(ebx_359, ecx_104, gs);
			word32 edx_1010;
			word32 ebx_1011;
			struct Eq_149658 * esi_409;
			Eq_2 ecx_411;
			Eq_2 eax_406 = read_encoded_value_with_base(ebx_359, &esi_327->b0001 + 3, gs, fp - 0x3C, out ecx_411, out edx_1010, out ebx_1011, out esi_409);
			Eq_2 esp_410 = <invalid>;
			Eq_148936 ebx_417 = (word32) esi_409->b0002;
			struct Eq_149678 * esp_418 = (word32) esp_410 + 20;
			if ((byte) ebx_417 != ~0x00 && esi_409->b0003 == 0x3B)
			{
				base_from_cb_data(ebx_417, ecx_411, gs);
				*((word32) esp_410 + 4) = (word32) esp_410 + 56;
				word32 ecx_1012;
				word32 ebx_1014;
				word32 edx_1013;
				up32 esi_443;
				Eq_2 eax_440 = read_encoded_value_with_base(ebx_417, eax_406, gs, *((word32) esp_410 + 4), out ecx_1012, out edx_1013, out ebx_1014, out esi_443);
				Eq_2 esp_444 = <invalid>;
				Eq_2 ebx_451 = *((word32) esp_444 + 56);
				*((word32) esp_444 + 20) = eax_440;
				esp_418 = (word32) esp_444 + 20;
				if (ebx_451 == 0x00)
					return;
				ecx_459 = **((word32) esp_444 + 0x007C);
				Eq_2 edi_461 = eax_440 & 0x03;
				if ((eax_440 & 0x03) == 0x00)
				{
					if ((word32) *eax_440 + esi_443 <= ecx_459)
					{
						Eq_2 eax_470 = (word32) eax_440 + (ebx_451 - 0x01) * 0x08;
						up32 edx_471 = *eax_470;
						*((word32) esp_444 + 24) = eax_470;
						if (edx_471 + esi_443 > ecx_459)
						{
							*((word32) esp_444 + 24) = ebx_451 - 0x01;
							do
							{
								Eq_2 eax_479 = *((word32) esp_444 + 24);
								if (edi_461 >= eax_479)
								{
l0809F8D8:
									word32 ecx_1021;
									word32 edx_1022;
									abort(ecx_459, gs, out ecx_1021, out edx_1022);
								}
								word32 eax_483 = eax_479 + edi_461;
								Eq_2 eax_485 = eax_483 >> 0x01;
								if ((word32) *((word32) *((word32) esp_444 + 20) + (eax_483 >> 0x01) * 0x08) + esi_443 > ecx_459)
								{
									*((word32) esp_444 + 24) = ecx_459;
									if (edi_461 < eax_483 >> 0x01)
									{
										do
										{
											word32 edx_497 = edi_461 + eax_485;
											ecx_459 = *((word32) esp_444 + 20);
											if ((word32) *((word32) ecx_459 + (edx_497 >> 0x01) * 0x08) + esi_443 <= *((word32) esp_444 + 24))
											{
												ecx_459 = *((word32) esp_444 + 24);
												*((word32) esp_444 + 24) = eax_485;
												eax_485 = edx_497 >> 0x01;
												goto l0809F8EA;
											}
											eax_485 = edx_497 >> 0x01;
										} while (edi_461 < edx_497 >> 0x01);
									}
									goto l0809F8D8;
								}
l0809F8EA:
								Eq_2 ebx_523 = *((word32) esp_444 + 20);
								edi_461 = (word32) eax_485 + 1;
							} while ((word32) *((word32) ebx_523 + edi_461 * 0x08) + esi_443 <= ecx_459);
							*((word32) esp_444 + 24) = (word32) ebx_523 + eax_485 * 0x08;
						}
						Eq_2 ebp_536 = *((word32) esp_444 + 24);
						struct Eq_149898 * ebx_539 = (word32) *((word32) ebp_536 + 4) + esi_443;
						Eq_2 ecx_546;
						Eq_148936 eax_545 = get_cie_encoding(&ebx_539->dw0004 - ebx_539->dw0004, gs, out ecx_546);
						word32 ecx_562 = ebx_539 + 0x08 + size_of_encoded_value((word32) ((byte) eax_545), ecx_546, gs);
						*((word32) esp_444 + 4) = (word32) esp_444 + 60;
						word32 ecx_1019;
						word32 ebx_571;
						word32 esi_573;
						word32 edx_1020;
						read_encoded_value_with_base(eax_545 & 0x0F, ecx_562, gs, *((word32) esp_444 + 4), out ecx_1019, out edx_1020, out ebx_571, out esi_573);
						Eq_2 esp_574 = <invalid>;
						Eq_2 esi_584 = (word32) *ebp_536 + esi_573;
						struct Eq_50034 * edi_583 = *((word32) esp_574 + 0x007C);
						if (Mem565[edi_583 + 0x00:word32] <u Mem565[esp_574 + 0x3C:word32] + esi_584)
							edi_583->dw0010 = ebx_571;
						*((word32) *((word32) esp_574 + 0x007C) + 0x0C) = esi_584;
					}
					return;
				}
			}
			else
				ecx_459 = **((word32) esp_410 + 0x007C);
			struct Eq_149777 * eax_600 = esp_418->ptr0068;
			Eq_2 edx_601 = esp_418->t0020;
			esp_418->dw0028 = 0x00;
			esp_418->dw0038 = 0x04;
			word32 eax_604 = eax_600->dw0004;
			esp_418->t0034 = edx_601;
			esp_418->dw002C = eax_604;
			esp_418->dw0030 = esp_418->ptr0068->dw0008;
			Eq_2 eax_614 = linear_search_fdes(&esp_418->dw0028, ecx_459, edx_601, gs);
			esp_418->ptr0068->t0010 = eax_614;
			if (eax_614 != 0x00)
			{
				Eq_2 ecx_631;
				Eq_148936 ebx_639 = (word32) (byte) get_cie_encoding((word32) eax_614 + 4 - *((word32) eax_614 + 4), gs, out ecx_631);
				base_from_cb_data(ebx_639, ecx_631, gs);
				struct Eq_149771 * esp_647 = esp_418 - 0x0C;
				Eq_2 edi_649 = esp_418->ptr0068->t0010;
				esp_647->t000C = edi_649;
				esp_647->ptrFFFFFFFC = (word32 *) ((char *) &esp_647->t000C + 36);
				word32 edx_1016;
				word32 esi_1018;
				word32 ebx_1017;
				word32 ecx_1015;
				read_encoded_value_with_base(ebx_639, (word32) edi_649 + 8, gs, esp_647->ptrFFFFFFFC, out ecx_1015, out edx_1016, out ebx_1017, out esi_1018);
				Eq_2 esp_661 = <invalid>;
				*((word32) *((word32) esp_661 + 0x007C) + 0x0C) = *((word32) esp_661 + 56);
			}
			return;
		}
		Eq_2 edi_52 = frame_hdr_cache_head;
		if (edi_52 != 0x00)
		{
			ecx_104 = edi_52;
			dwLoc44_703.u0 = 0x00;
			Eq_2 edi_106 = *((word32) edi_52 + 4);
			Eq_2 esi_107 = dwArg0C->t0000;
			Eq_2 ebx_105 = *edi_52;
			if (esi_107 >= ebx_105)
			{
l0809F808:
				if (esi_107 < edi_106)
				{
					ebx_261 = (struct Eq_149493 *) *((word32) ecx_104 + 16);
					dwLoc58_705 = (word32) *((word32) ecx_104 + 8);
					dwLoc48_706 = (struct Eq_149493 *) *((word32) ecx_104 + 0x0C);
					if (edi_52 != ecx_104)
					{
						Eq_2 eax_81 = *((word32) ecx_104 + 20);
						frame_hdr_cache_head = ecx_104;
						*((word64) dwLoc44_703.u0 + 20) = eax_81;
						*((word32) ecx_104 + 20) = edi_52;
					}
					goto l0809F5AB;
				}
			}
			do
			{
				if ((ebx_105 | edi_106) == 0x00)
				{
l0809F830:
					dwLoc40_708 = ecx_104;
					goto l0809F4A4;
				}
				Eq_2 ebx_95 = *((word32) ecx_104 + 20);
				if (ebx_95 == 0x00)
					goto l0809F830;
				dwLoc44_703 = ecx_104;
				ecx_104 = ebx_95;
				ebx_105 = *ebx_95;
				edi_106 = *((word32) ebx_95 + 4);
			} while (esi_107 < ebx_105);
			goto l0809F808;
		}
	}
	else if (dwArg08 <= 0x0D)
		return;
	dwLoc40_708.u0 = 0x00;
	dwLoc44_703.u0 = 0x00;
	goto l0809F4A4;
}

// 0809F990: void fde_mixed_encoding_compare(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack (ptr32 Eq_150154) dwArg08)
void fde_mixed_encoding_compare(struct Eq_9 * gs, Eq_2 dwArg04, struct Eq_150154 * dwArg08)
{
	Eq_2 ecx_25;
	Eq_148936 edi_33 = (word32) (byte) get_cie_encoding(&dwArg08->dw0004 - dwArg08->dw0004, gs, out ecx_25);
	base_from_object(edi_33, ecx_25, dwArg04, gs);
	struct Eq_150170 * ebx_49;
	word32 esi_141;
	word32 edx_140;
	word32 ecx_139;
	read_encoded_value_with_base(edi_33, &dwArg08->dw0004 + 1, gs, fp - 0x24, out ecx_139, out edx_140, out ebx_49, out esi_141);
	Eq_2 ecx_63;
	Eq_148936 esi_71 = (word32) (byte) get_cie_encoding(&ebx_49->dw0004 - ebx_49->dw0004, gs, out ecx_63);
	base_from_object(esi_71, ecx_63, dwArg04, gs);
	Eq_2 esp_52 = <invalid>;
	*((word32) esp_52 + 4) = (word32) esp_52 + 32;
	word32 ecx_142;
	word32 edx_143;
	word32 ebx_144;
	word32 esi_145;
	read_encoded_value_with_base(esi_71, &ebx_49->dw0004 + 1, gs, *((word32) esp_52 + 4), out ecx_142, out edx_143, out ebx_144, out esi_145);
}

// 0809FA20: Register Eq_2 classify_object_over_fdes(Register Eq_2 eax, Register (ptr32 Eq_150224) edx, Register (ptr32 Eq_9) gs)
// Called from:
//      search_object
Eq_2 classify_object_over_fdes(Eq_2 eax, struct Eq_150224 * edx, struct Eq_9 * gs)
{
	Eq_2 eax_20 = edx->dw0000;
	Eq_2 dwLoc30_203 = eax_20;
	if (eax_20 != 0x00)
	{
		struct Eq_150224 * ebx_122 = edx;
		struct Eq_149149 * ecx_152 = null;
		byte bLoc3C_241 = 0x00;
		dwLoc30_203.u0 = 0x00;
		do
		{
			ui32 eax_37 = ebx_122[1];
			if (eax_37 != 0x00)
			{
				Eq_148936 edi_113 = (word32) bLoc3C_241;
				struct Eq_149149 * esi_44 = ebx_122 + 1 - eax_37;
				if (esi_44 != ecx_152)
				{
					Eq_2 ecx_51;
					Eq_148936 eax_50 = get_cie_encoding(esi_44, gs, out ecx_51);
					bLoc3C_241 = (byte) eax_50;
					if (eax_50 == 0xFF)
						return ~0x00;
					edi_113 = (word32) bLoc3C_241;
					base_from_object(edi_113, ecx_51, eax, gs);
					word32 eax_82 = (word32) *((word32) eax + 16);
					cu16 ax_89 = (word16) eax_82;
					ui16 eax_16_16_92 = SLICE(eax_82, word16, 16);
					bLoc3C_241 = (byte) eax_50;
					if (((word16) eax_82 & 2040) != 2040)
					{
						if ((word32) (byte) (ax_89 >> 0x03) != eax_50)
							*((word32) eax + 16) |= 0x04;
					}
					else
						*((word32) eax + 16) = (word16) (SEQ(eax_16_16_92, ax_89 & 0xF807) | (word32) bLoc3C_241 << 0x03);
				}
				struct Eq_149149 * esi_124;
				Eq_2 ecx_126;
				word32 edx_295;
				read_encoded_value_with_base(edi_113, ebx_122 + 2, gs, fp - 0x20, out ecx_126, out edx_295, out ebx_122, out esi_124);
				Eq_2 esp_125 = <invalid>;
				Eq_149449 eax_133 = size_of_encoded_value(edi_113, ecx_126, gs);
				ui32 edx_139 = ~0x00;
				if (eax_133 <= 0x03)
					edx_139 = (0x01 << (byte) (eax_133 * 0x08)) - 0x01;
				uint32 eax_150 = *((word32) esp_125 + 48);
				ecx_152 = esi_124;
				if ((eax_150 & edx_139) != 0x00)
				{
					*((word32) esp_125 + 32) = (word32) *((word32) esp_125 + 32) + 1;
					if (*eax > eax_150)
						*eax = eax_150;
					ecx_152 = esi_124;
				}
			}
			ebx_122 = ebx_122 + 1 + ebx_122->dw0000 / 4;
		} while (ebx_122->dw0000 != 0x00);
	}
	return dwLoc30_203;
}

// 0809FB70: Register Eq_2 add_fdes(Register Eq_2 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs)
// Called from:
//      search_object
Eq_2 add_fdes(Eq_2 eax, Eq_2 ecx, struct Eq_9 * gs)
{
	Eq_148936 esi_107 = (word32) (byte) (*((word32) eax + 16) >> 0x03);
	base_from_object(esi_107, ecx, eax, gs);
	Eq_2 ebx_105 = ecx;
	struct Eq_150379 * esp_121 = fp - 0x3C;
	Eq_2 ecx_109 = *ecx;
	if (ecx_109 != 0x00)
	{
		do
		{
			ui32 edx_47 = *((word32) ebx_105 + 4);
			if (edx_47 != 0x00)
			{
				if ((*((word32) eax + 16) & 0x04) != 0x00)
				{
					struct Eq_149149 * ebp_56 = (word32) ebx_105 + 4 - edx_47;
					if (ebp_56 != esp_121->ptr0000)
					{
						Eq_148936 eax_62 = get_cie_encoding(ebp_56, gs, out ecx_109);
						word32 eax_73 = base_from_object((word32) (byte) eax_62, ecx_109, eax, gs);
						esp_121->ptr0000 = ebp_56;
						esp_121->dw0008 = eax_73;
						esi_107 = eax_62;
					}
				}
				if (esi_107 != 0x00)
				{
					struct Eq_150443 * esp_92 = esp_121 - 0x0C;
					esp_92->ptrFFFFFFFC = esp_92->ptr0018;
					Eq_148936 ebp_100 = (word32) (byte) esi_107;
					word32 edx_239;
					read_encoded_value_with_base(ebp_100, (word32) ebx_105 + 8, gs, esp_92->ptrFFFFFFFC, out ecx_109, out edx_239, out ebx_105, out esi_107);
					Eq_2 esp_108 = <invalid>;
					Eq_149449 eax_116 = size_of_encoded_value(ebp_100, ecx_109, gs);
					esp_121 = (word32) esp_108 + 20;
					ui32 edx_122 = ~0x00;
					if (eax_116 <= 0x03)
					{
						ecx_109 = eax_116 * 0x08;
						edx_122 = (0x01 << (byte) (eax_116 * 0x08)) - 0x01;
					}
					if ((*((word32) esp_108 + 48) & edx_122) == 0x00)
					{
						ebx_105 = (word32) *ebx_105 + ((word32) ebx_105 + 4);
						if (*ebx_105 == 0x00)
							return ecx_109;
						continue;
					}
					goto l0809FBBF;
				}
				if (*((word32) ebx_105 + 8) != 0x00)
				{
l0809FBBF:
					struct Eq_150491 * eax_140 = *esp_121->ptr0004;
					if (eax_140 != null)
					{
						ui32 edx_144 = eax_140->dw0004;
						eax_140->dw0004 = edx_144 + 0x01;
						eax_140->a0008[edx_144] = ebx_105;
						ecx_109 = edx_144 + 0x01;
					}
				}
			}
			ebx_105 = (word32) *ebx_105 + ((word32) ebx_105 + 4);
		} while (*ebx_105 != 0x00);
	}
	return ecx_109;
}

// 0809FC80: Register Eq_2 search_object(Register Eq_2 eax, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      _Unwind_Find_FDE
Eq_2 search_object(Eq_2 eax, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_2 ebx_573;
	Eq_2 ebp_117 = eax;
	Eq_150531 al_25 = *((word32) eax + 16);
	if ((al_25 & 0x01) != 0x00)
	{
l0809FCA4:
		Eq_2 edi_617 = *((word32) ebp_117 + 0x0C);
		uint32 edi_620 = *((word32) edi_617 + 4);
		struct Eq_150559 * esp_618 = fp - 0x5C;
		uint32 dwLoc54_1256 = edi_620;
		if ((al_25 & 0x04) == 0x00)
		{
			Eq_150531 ax_725 = *((word32) ebp_117 + 16);
			uint32 ecx_724 = 0x00;
			if ((ax_725 & 2040) == 0x00)
			{
				while (ecx_724 < dwLoc54_1256)
				{
					uint32 eax_844;
					Eq_2 esi_848;
					uint32 edx_831 = ecx_724 + dwLoc54_1256;
					ebx_573 = *((word32) edi_617 + ((edx_831 >> 0x01) * 0x04 + 8));
					uint32 edx_832 = edx_831 >> 0x01;
					Eq_2 esi_835 = *((word64) ebx_573.u0 + 8);
					up32 edi_836 = *((word64) ebx_573.u0 + 0x0C);
					if (edx < esi_835)
					{
						while (edx_832 > ecx_724)
						{
							uint32 eax_843 = edx_832 + ecx_724;
							ebx_573 = *((word32) edi_617 + ((eax_843 >> 0x01) * 0x04 + 8));
							eax_844 = eax_843 >> 0x01;
							esi_848 = *((word64) ebx_573.u0 + 8);
							edi_836 = (up32) *((word64) ebx_573.u0 + 0x0C);
							if (edx >= esi_848)
								goto l0809FD90;
							edx_832 = eax_843 >> 0x01;
						}
						break;
					}
					eax_844 = edx_831 >> 0x01;
					edx_832 = dwLoc54_1256;
					esi_848 = esi_835;
l0809FD90:
					if (edx < (word32) esi_848 + edi_836)
						return ebx_573;
					ecx_724 = eax_844 + 0x01;
					dwLoc54_1256 = edx_832;
				}
			}
			else
			{
				base_from_object((word32) (byte) (ax_725 >> 0x03), 0x00, ebp_117, gs);
				if (edi_620 != 0x00)
				{
					uint32 ebp_755 = edi_620;
					uint32 edi_757 = 0x00;
					do
					{
						struct Eq_151071 * esp_767 = esp_618 - 0x0C;
						Eq_2 ebx_770 = esp_618->ptr0010->a0008[ebp_755 + edi_757 >> 0x01];
						esp_767->ptrFFFFFFFC = esp_767->ptr0024;
						word32 edx_1326;
						word32 ecx_1325;
						word32 esi_1328;
						word32 ebx_1327;
						Eq_2 eax_778 = read_encoded_value_with_base(esp_767->t0020, (word32) ebx_770 + 8, gs, esp_767->ptrFFFFFFFC, out ecx_1325, out edx_1326, out ebx_1327, out esi_1328);
						Eq_2 esp_782 = <invalid>;
						*((word32) esp_782 + 4) = *((word32) esp_782 + 48);
						uint32 esi_802;
						word32 ecx_1329;
						word32 edx_1330;
						read_encoded_value_with_base(*((word32) esp_782 + 28), eax_778, gs, *((word32) esp_782 + 4), out ecx_1329, out edx_1330, out ebx_573, out esi_802);
						Eq_2 esp_803 = <invalid>;
						Eq_2 eax_810 = *((word32) esp_803 + 72);
						esp_618 = (word32) esp_803 + 20;
						Eq_2 edx_812 = *((word32) esp_803 + 32);
						if (eax_810 > edx_812)
							ebp_755 = esi_802;
						else
						{
							if (eax_810 + Mem793[esp_803 + 0x4C:word32] >u edx_812)
								return ebx_573;
							edi_757 = esi_802 + 0x01;
						}
					} while (edi_757 < ebp_755);
				}
			}
		}
		else if (edi_620 != 0x00)
		{
			do
			{
				Eq_2 edi_641 = esp_618->ptr0010->a0008[esp_618->dw0008 + esp_618->dw0014 >> 0x01];
				Eq_2 ecx_647;
				Eq_148936 ebp_655 = (word32) (byte) get_cie_encoding((word32) edi_641 + 4 - *((word32) edi_641 + 4), gs, out ecx_647);
				base_from_object(ebp_655, ecx_647, esp_618->t0020, gs);
				struct Eq_151180 * esp_666 = esp_618 - 0x0C;
				esp_666->ptrFFFFFFFC = esp_666->ptr0024;
				Eq_148936 ebx_675;
				word32 esi_1333;
				word32 ecx_1331;
				word32 edx_1332;
				Eq_2 eax_674 = read_encoded_value_with_base(ebp_655, (word32) edi_641 + 8, gs, esp_666->ptrFFFFFFFC, out ecx_1331, out edx_1332, out ebx_675, out esi_1333);
				Eq_2 esp_678 = <invalid>;
				*((word32) esp_678 + 4) = *((word32) esp_678 + 48);
				up32 esi_698;
				word32 ebx_1336;
				word32 edx_1335;
				word32 ecx_1334;
				read_encoded_value_with_base(ebx_675, eax_674, gs, *((word32) esp_678 + 4), out ecx_1334, out edx_1335, out ebx_1336, out esi_698);
				Eq_2 esp_699 = <invalid>;
				Eq_2 eax_706 = *((word32) esp_699 + 72);
				esp_618 = (word32) esp_699 + 20;
				Eq_2 ecx_708 = *((word32) esp_699 + 32);
				if (eax_706 > ecx_708)
					*((word32) esp_699 + 28) = esi_698;
				else
				{
					if (eax_706 + Mem689[esp_699 + 0x4C:word32] >u ecx_708)
					{
						ebx_573 = edi_641;
						return ebx_573;
					}
					*((word32) esp_699 + 40) = esi_698 + 0x01;
				}
			} while (*((word32) esp_699 + 40) < *((word32) esp_699 + 28));
		}
		goto l0809FD0F;
	}
	Eq_150531 esi_29 = *((word32) eax + 16);
	uint32 esi_30 = esi_29 >> 11;
	uint32 dwLoc3C_920 = esi_29 >> 11;
	if (esi_29 >> 11 == 0x00)
	{
		struct Eq_150224 * ebx_34 = *((word32) eax + 0x0C);
		if ((al_25 & 0x02) != 0x00)
		{
			struct Eq_150224 * edx_51 = ebx_34->dw0000;
			if (edx_51 == null)
				goto l0809FEA7;
			do
			{
				uint32 eax_59 = classify_object_over_fdes(eax, edx_51, gs);
				if (eax_59 == ~0x00)
				{
l0809FD6B:
					*((word32) eax + 16) = 2040;
					*((word32) eax + 0x0C) = &g_t80BA3A8;
					goto l0809FEA7;
				}
				++ebx_34;
				edx_51 = ebx_34->dw0000;
				esi_30 += eax_59;
			} while (edx_51 != null);
			dwLoc3C_920 = esi_30;
		}
		else
		{
			uint32 eax_41 = classify_object_over_fdes(eax, ebx_34, gs);
			dwLoc3C_920 = eax_41;
			if (eax_41 == ~0x00)
				goto l0809FD6B;
		}
		if ((dwLoc3C_920 & 0xFFE00000) != 0x00)
			*((word32) eax + 16) &= 0x07FF;
		else
			*((word32) eax + 16) = *((word32) eax + 16) & 0x07FF | dwLoc3C_920 << 11;
		if (dwLoc3C_920 == 0x00)
		{
l0809FEA7:
			if (*ebp_117 > edx)
				goto l0809FD0F;
			al_25 = *((word32) ebp_117 + 16);
			Eq_2 esi_552 = *((word32) ebp_117 + 0x0C);
			if ((al_25 & 0x01) == 0x00)
			{
				if ((al_25 & 0x02) == 0x00)
				{
					ebx_573 = linear_search_fdes(ebp_117, edx, esi_552, gs);
					return ebx_573;
				}
				Eq_2 edx_574 = *esi_552;
				while (edx_574 != 0x00)
				{
					Eq_2 eax_585 = linear_search_fdes(ebp_117, edx, edx_574, gs);
					if (eax_585 != 0x00)
						return eax_585;
					esi_552 = (word32) esi_552 + 4;
					edx_574 = *esi_552;
				}
l0809FD0F:
				ebx_573.u0 = 0x00;
				return ebx_573;
			}
			goto l0809FCA4;
		}
	}
	Eq_2 esi_122;
	word32 edi_1315;
	word32 ebx_1314;
	word32 edx_1313;
	word32 ecx_1312;
	Eq_2 eax_116 = __libc_malloc(gs, dwLoc70, dwLoc3C_920 * 0x04 + 0x08, out ecx_1312, out edx_1313, out ebx_1314, out ebp_117, out esi_122, out edi_1315);
	if (eax_116 == 0x00)
		goto l0809FEA7;
	*((word32) eax_116 + 4) = 0x00;
	Eq_2 ebp_138;
	word32 edi_1320;
	word32 esi_1319;
	word32 ebx_1318;
	word32 edx_1317;
	word32 ecx_1316;
	Eq_2 eax_137 = __libc_malloc(gs, dwLoc70, esi_122, out ecx_1316, out edx_1317, out ebx_1318, out ebp_138, out esi_1319, out edi_1320);
	struct Eq_150760 * esp_149 = fp - 0x5C;
	if (eax_137 != 0x00)
		*((word32) eax_137 + 4) = 0x00;
	Eq_2 ecx_167;
	Eq_2 ebx_156 = *((word32) ebp_138 + 0x0C);
	if ((*((word32) ebp_138 + 16) & 0x02) != 0x00)
	{
		ecx_167 = *ebx_156;
		if (ecx_167 == 0x00)
			goto l080A0341;
		do
		{
			add_fdes(ebp_138, ecx_167, gs);
			ebx_156 = (word32) ebx_156 + 4;
			ecx_167 = *ebx_156;
		} while (ecx_167 != 0x00);
	}
	else
		ecx_167 = add_fdes(ebp_138, ebx_156, gs);
	if (eax_116 != 0x00 && *((word32) eax_116 + 4) != dwLoc3C_920)
	{
l080A0341:
		word32 edx_1322;
		word32 ecx_1321;
		abort(ecx_167, gs, out ecx_1321, out edx_1322);
	}
	<anonymous> * dwLoc54_950 = &g_t809F990;
	if ((*((word32) ebp_138 + 16) & 0x04) == 0x00)
	{
		<anonymous> * edx_226 = &g_t809F170;
		if ((*((word32) ebp_138 + 16) & 2040) == 0x00)
			edx_226 = &g_t809ED80;
		dwLoc54_950 = edx_226;
	}
	if (eax_137 == 0x00)
	{
		frame_heapsort(ebp_138, eax_116, dwLoc54_950);
		goto l080A028B;
	}
	ui32 ebx_260;
	uint32 edx_261;
	uint32 eax_254 = *((word32) eax_116 + 4);
	if (eax_254 != 0x00)
	{
		Eq_150866 eax_264 = eax_254 * 0x04 + 0x04;
		word32 edx_265 = eax_116 + 0x08;
		Eq_150866 ebx_267 = 0x08;
		Eq_150876 ebp_273 = 0x080CFB80;
		while (true)
		{
l080A00D8:
			Mem280[eax_137 + ebx_267:word32] = ebp_273;
			ebp_273 = eax_116 + ebx_267;
			if (eax_264 == ebx_267)
				break;
			while (ebp_273 != 0x080CFB80)
			{
				int32 eax_311;
				word32 ecx_313;
				dwLoc54_950();
				if (eax_311 >= 0x00)
				{
					ebx_267 = (word32) ebx_267 + 4;
					goto l080A00D8;
				}
				word32 eax_321 = ebp_273 - (eax_116 + 0x08) + eax_137;
				ebp_273 = eax_321->t0008;
				eax_321->t0008.u0 = 0x00;
			}
			ebp_273.u0 = 0x080CFB80;
			ebx_267 = (word32) ebx_267 + 4;
		}
		ebx_260 = 0x00;
		edx_261 = 0x00;
		uint32 eax_329 = 0x00;
		do
		{
			word32 ecx_339 = *((word32) eax_116 + (eax_329 * 0x04 + 8));
			if (*((word32) eax_137 + (eax_329 * 0x04 + 8)) == 0x00)
			{
				*((word32) eax_137 + (ebx_260 * 0x04 + 8)) = ecx_339;
				++ebx_260;
			}
			else
			{
				*((word32) eax_116 + (edx_261 * 0x04 + 8)) = ecx_339;
				++edx_261;
			}
			++eax_329;
		} while (eax_254 != eax_329);
	}
	else
	{
		ebx_260 = 0x00;
		edx_261 = 0x00;
	}
	*((word32) eax_116 + 4) = edx_261;
	*((word32) eax_137 + 4) = ebx_260;
	ecx_167 = eax_137;
	if (Mem370[eax_137 + 0x04:word32] + Mem370[eax_116 + 0x04:word32] != dwLoc3C_920)
		goto l080A0341;
	frame_heapsort(ebp_138, eax_137, dwLoc54_950);
	ui32 eax_403 = *((word32) eax_137 + 4);
	if (eax_403 == 0x00)
	{
l080A0278:
		word32 edx_1324;
		word32 ecx_1323;
		free(gs, dwLoc70, eax_137, out ecx_1323, out edx_1324);
		esp_149 = fp - 88;
l080A028B:
		Eq_2 eax_526 = esp_149->t0038;
		*eax_526 = *((word32) ebp_138 + 0x0C);
		*((word32) ebp_138 + 0x0C) = eax_526;
		*((word32) ebp_138 + 16) |= 0x01;
		ebp_117 = ebp_138;
		goto l0809FEA7;
	}
	uint32 edi_411 = *((word32) eax_116 + 4);
l080A01D0:
	ui32 esi_432;
	ui32 edx_416 = eax_403 - 0x01;
	struct Eq_151046 * ebx_418 = (word32) eax_137 + eax_403 * 0x04;
	word32 edx_419 = ebx_418->dw0004;
	ui32 dwLoc44_1026 = edx_416;
	word32 dwLoc4C_1027 = edx_419;
	if (edi_411 != 0x00)
	{
		uint32 esi_438 = edi_411;
		ui32 edi_439 = eax_403 - 0x01 + edi_411;
		edx_458 = edx_419;
		do
		{
			word32 edx_458;
			uint32 ebx_444 = esi_438 - 0x01;
			int32 eax_461;
			word32 ecx_463;
			dwLoc54_950();
			if (eax_461 <= 0x00)
			{
				edi_411 = esi_438;
				esi_432 = edi_439;
				goto l080A0236;
			}
			*((word32) eax_116 + (edi_439 * 0x04 + 8)) = *((word32) eax_116 + (ebx_444 * 0x04 + 8));
			esi_438 = ebx_444;
			--edi_439;
		} while (ebx_444 != 0x00);
		edi_411 = ebx_444;
		esi_432 = edx_416;
	}
	else
	{
		ui32 ecx_426 = eax_403 - 0x01;
		*((word32) eax_116 + (ecx_426 * 0x04 + 8)) = edx_419;
		if (ecx_426 == 0x00)
			goto l080A0260;
		esi_432 = eax_403 - 0x02;
		dwLoc44_1026 = esi_432;
		dwLoc4C_1027 = ebx_418->dw0000;
	}
l080A0236:
	*((word32) eax_116 + (esi_432 * 0x04 + 8)) = dwLoc4C_1027;
	if (dwLoc44_1026 != 0x00)
	{
		eax_403 = dwLoc44_1026;
		goto l080A01D0;
	}
l080A0260:
	Mem498[eax_116 + 0x04:word32] = Mem491[eax_116 + 0x04:word32] + Mem491[eax_137 + 0x04:word32];
	goto l080A0278;
}

// 080A0350: void __register_frame_info_bases.part.5(Register (ptr32 word32) eax, Register word32 ecx, Register Eq_2 edx, Stack ptr32 dwArg04)
// Called from:
//      search_object
//      __register_frame_info_bases
//      __register_frame_info
//      __register_frame
void __register_frame_info_bases.part.5(word32 * eax, word32 ecx, Eq_2 edx, ptr32 dwArg04)
{
	*edx = ~0x00;
	*((word32) edx + 4) = ecx;
	*((word32) edx + 0x0C) = eax;
	*((word32) edx + 8) = dwArg04;
	*((word32) edx + 16) = 2040;
	Eq_2 eax_48 = unseen_objects;
	unseen_objects = edx;
	*((word32) edx + 20) = eax_48;
	if (any_objects_registered == 0x00)
		any_objects_registered = 0x01;
}

// 080A03E0: void __register_frame_info_bases(Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack ptr32 dwArg10)
// Called from:
//      frame_dummy
void __register_frame_info_bases(word32 * dwArg04, Eq_2 dwArg08, word32 dwArg0C, ptr32 dwArg10)
{
	if (dwArg04 == null || *dwArg04 == 0x00)
		return;
	__register_frame_info_bases.part.5(dwArg04, dwArg0C, dwArg08, dwArg10);
}

// 080A0420: void __register_frame_info(Stack (ptr32 word32) dwArg04, Stack Eq_2 dwArg08)
void __register_frame_info(word32 * dwArg04, Eq_2 dwArg08)
{
	if (dwArg04 == null || *dwArg04 == 0x00)
		return;
	__register_frame_info_bases.part.5(dwArg04, 0x00, dwArg08, 0x00);
}

// 080A0450: void __register_frame(Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04)
void __register_frame(struct Eq_9 * gs, word32 * dwArg04)
{
	if (*dwArg04 == 0x00)
		return;
	word32 * esi_29;
	word32 ecx_84;
	word32 edx_85;
	word32 ebx_86;
	word32 ebp_87;
	word32 edi_88;
	Eq_2 eax_23 = __libc_malloc(gs, dwLoc20, 0x18, out ecx_84, out edx_85, out ebx_86, out ebp_87, out esi_29, out edi_88);
	__register_frame_info_bases.part.5(esi_29, 0x00, eax_23, 0x00);
}

// 080A04A0: void __register_frame_info_table_bases(Stack word32 dwArg04, Stack Eq_2 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      __register_frame_info_table
//      __register_frame_table
void __register_frame_info_table_bases(word32 dwArg04, Eq_2 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	*dwArg08 = ~0x00;
	*((word32) dwArg08 + 4) = dwArg0C;
	*((word32) dwArg08 + 16) = 2042;
	*((word32) dwArg08 + 8) = dwArg10;
	*((word32) dwArg08 + 0x0C) = dwArg04;
	Eq_2 eax_39 = unseen_objects;
	unseen_objects = dwArg08;
	*((word32) dwArg08 + 20) = eax_39;
	if (any_objects_registered == 0x00)
		any_objects_registered = 0x01;
}

// 080A0540: void __register_frame_info_table(Stack word32 dwArg04, Stack Eq_2 dwArg08)
void __register_frame_info_table(word32 dwArg04, Eq_2 dwArg08)
{
	__register_frame_info_table_bases(dwArg04, dwArg08, 0x00, 0x00);
}

// 080A0560: void __register_frame_table(Register (ptr32 Eq_9) gs, Stack word32 dwArg04)
void __register_frame_table(struct Eq_9 * gs, word32 dwArg04)
{
	word32 ecx_57;
	word32 edx_58;
	word32 ebx_59;
	word32 ebp_60;
	word32 esi_61;
	word32 edi_62;
	__register_frame_info_table_bases(dwArg04, __libc_malloc(gs, dwLoc20, 0x18, out ecx_57, out edx_58, out ebx_59, out ebp_60, out esi_61, out edi_62), 0x00, 0x00);
}

// 080A0590: Register Eq_2 __deregister_frame_info_bases(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
// Called from:
//      __do_global_dtors_aux
//      __deregister_frame_info
//      __deregister_frame
Eq_2 __deregister_frame_info_bases(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (dwArg04 == 0x00 || *dwArg04 == 0x00)
		return 0x00;
	Eq_2 esi_100;
	Mem58 = Mem15;
	Eq_2 eax_59 = unseen_objects;
	if (eax_59 != 0x00)
	{
		word32 * eax_179;
		if (dwArg04 == *((word32) eax_59 + 0x0C))
		{
			esi_100 = eax_59;
			eax_179 = (word32 *) &unseen_objects;
l080A063B:
			*eax_179 = (word32) *((word32) esi_100 + 20);
			return esi_100;
		}
		while (true)
		{
			esi_100 = *((word32) eax_59 + 20);
			if (esi_100 == 0x00)
				break;
			if (dwArg04 == *((word32) esi_100 + 0x0C))
			{
				eax_179 = (word32) eax_59 + 20;
				goto l080A063B;
			}
			eax_59 = esi_100;
		}
	}
	esi_100 = seen_objects;
	if (esi_100 != 0x00)
	{
		word32 * edx_162 = &seen_objects;
		do
		{
			Eq_2 eax_88 = *((word32) esi_100 + 0x0C);
			if ((*((word32) esi_100 + 16) & 0x01) == 0x00)
			{
				if (dwArg04 == eax_88)
				{
					*edx_162 = (word32) *((word32) esi_100 + 20);
					return esi_100;
				}
			}
			else if (dwArg04 == *eax_88)
			{
				*edx_162 = (word32) *((word32) esi_100 + 20);
				word32 ecx_167;
				word32 edx_321;
				free(gs, dwLoc30, eax_88, out ecx_167, out edx_321);
				return esi_100;
			}
			edx_162 = (word32) esi_100 + 20;
			esi_100 = *((word32) esi_100 + 20);
		} while (esi_100 != 0x00);
	}
	word32 edx_320;
	word32 ecx_319;
	abort(ecx, gs, out ecx_319, out edx_320);
}

// 080A06B0: void __deregister_frame_info(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void __deregister_frame_info(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	__deregister_frame_info_bases(ecx, gs, dwArg04);
}

// 080A06C0: void __deregister_frame(Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04)
void __deregister_frame(Eq_2 ecx, struct Eq_9 * gs, Eq_2 dwArg04)
{
	if (*dwArg04 == 0x00)
		return;
	word32 ecx_70;
	word32 edx_71;
	free(gs, dwLoc20, __deregister_frame_info_bases(ecx, gs, dwArg04), out ecx_70, out edx_71);
}

// 080A0710: Register (ptr32 Eq_151532) _Unwind_Find_FDE(Register (ptr32 Eq_9) gs, Stack Eq_2 dwArg04, Stack Eq_2 dwArg08, Register out ptr32 edxOut)
// Called from:
//      uw_frame_state_for
//      _Unwind_FindEnclosingFunction
struct Eq_151532 * _Unwind_Find_FDE(struct Eq_9 * gs, Eq_2 dwArg04, Eq_2 dwArg08, ptr32 & edxOut)
{
	struct Eq_151532 * edi_151;
	ptr32 edx_245;
	if (any_objects_registered == 0x00)
	{
l080A0734:
		if (__dl_iterate_phdr(gs, &g_t809F450, fp - 0x34, out edx_245) >= 0x00)
			edi_151 = null;
		else
			edi_151 = null;
	}
	else
	{
		Mem41 = Mem25;
		Eq_2 esi_174 = seen_objects;
		while (esi_174 != 0x00)
		{
			if (dwArg04 >= *esi_174)
			{
				struct Eq_151532 * eax_60 = search_object(esi_174, dwArg04, gs);
				edi_151 = eax_60;
				if (eax_60 != null)
					goto l080A07FE;
				break;
			}
			esi_174 = *((word32) esi_174 + 20);
		}
		do
		{
			esi_174 = unseen_objects;
			if (esi_174 == 0x00)
				goto l080A0734;
			union Eq_2 * edi_125;
			unseen_objects = *((word32) esi_174 + 20);
			struct Eq_151532 * eax_110 = search_object(esi_174, dwArg04, gs);
			Eq_2 edx_117 = seen_objects;
			if (edx_117 != 0x00)
			{
				Eq_2 ecx_121 = *esi_174;
				if (*edx_117 < ecx_121)
					goto l080A08D0;
				do
				{
					edi_125 = (word32) edx_117 + 20;
					edx_117 = *((word32) edx_117 + 20);
				} while (edx_117 != 0x00 && *edx_117 >= ecx_121);
			}
			else
			{
l080A08D0:
				edi_125 = &seen_objects;
			}
			*((word32) esi_174 + 20) = edx_117;
			*edi_125 = (union Eq_2 *) esi_174;
		} while (eax_110 == null);
		edi_151 = eax_110;
l080A07FE:
		Eq_148936 ebx_215;
		*dwArg08 = *((word32) esi_174 + 4);
		*((word32) dwArg08 + 4) = *((word32) esi_174 + 8);
		Eq_2 ecx_195 = dwArg08;
		if ((*((word32) esi_174 + 16) & 0x04) == 0x00)
			ebx_215 = (word32) (byte) (*((word32) esi_174 + 16) >> 0x03);
		else
			ebx_215 = (word32) (byte) get_cie_encoding(&edi_151->dw0004 - edi_151->dw0004, gs, out ecx_195);
		base_from_object(ebx_215, ecx_195, esi_174, gs);
		word32 ecx_436;
		word32 ebx_437;
		word32 esi_438;
		read_encoded_value_with_base(ebx_215, &edi_151->dw0004 + 1, gs, fp - 0x34, out ecx_436, out edx_245, out ebx_437, out esi_438);
		Eq_2 esp_247 = <invalid>;
		*((word32) *((word32) esp_247 + 0x0068) + 8) = *((word32) esp_247 + 44);
	}
	edxOut = edx_245;
	return edi_151;
}

// 080A0930: void base_of_encoded_value(Register Eq_151687 al, Register Eq_2 ecx, Register Eq_2 edx, Register (ptr32 Eq_9) gs)
// Called from:
//      __gcc_personality_v0
void base_of_encoded_value(Eq_151687 al, Eq_2 ecx, Eq_2 edx, struct Eq_9 * gs)
{
	Eq_151687 al = (byte) eax;
	if (al == ~0x00)
		return;
	cu8 al_16 = (byte) (eax & 0x70);
	if (al_16 == 0x20)
		_Unwind_GetTextRelBase();
	else
	{
		if (al_16 > 0x20)
		{
			if (al_16 == 0x40)
			{
				_Unwind_GetRegionStart();
				return;
			}
			if (al_16 == 0x50)
				return;
			if (al_16 == 0x30)
			{
				_Unwind_GetDataRelBase();
				return;
			}
		}
		else if (al_16 == 0x00 || al_16 == 0x10)
			return;
		word32 edx_97;
		word32 ecx_96;
		abort(ecx, gs, out ecx_96, out edx_97);
	}
}

// 080A09B0: Register Eq_151687 read_encoded_value_with_base(Register Eq_151687 eax, Register Eq_2 ecx, Register (ptr32 Eq_9) gs, Stack (ptr32 word32) dwArg04, Register out Eq_2 ecxOut)
// Called from:
//      base_of_encoded_value
//      __gcc_personality_v0
Eq_151687 read_encoded_value_with_base(Eq_151687 eax, Eq_2 ecx, struct Eq_9 * gs, word32 * dwArg04, union Eq_2 & ecxOut)
{
	byte al = (byte) eax;
	word24 eax_24_8 = SLICE(eax, word24, 8);
	if (al == 0x50)
	{
		word32 * esi_28 = (word32) ecx + 3 & ~0x03;
		*dwArg04 = *esi_28;
		ecxOut = ecx;
		return esi_28 + 1;
	}
	else
	{
		cu8 dl_47 = (byte) (eax & 0x0F);
		if (dl_47 > 0x0C)
			read_encoded_value_with_base.cold.0(ecx, gs);
		else
		{
			ui32 edx_51 = (word32) dl_47;
			<anonymous> * ecx_53 = g_a80BA3B0[edx_51 * 0x04] + 0x080CE000;
			Eq_2 ecx_55;
			Eq_151687 eax_57;
			ecx_53();
			ecxOut = ecx_55;
			return eax_57;
		}
	}
}

// 080A0B00: void __gcc_personality_v0(Register (ptr32 Eq_9) gs, Stack word32 dwArg04, Stack byte bArg08, Stack Eq_2 dwArg18)
void __gcc_personality_v0(struct Eq_9 * gs, word32 dwArg04, byte bArg08, Eq_2 dwArg18)
{
	if (dwArg04 == 0x01)
	{
		if ((bArg08 & 0x02) != 0x00)
		{
			byte * eax_34 = _Unwind_GetLanguageSpecificData(dwArg18);
			if (eax_34 != null)
			{
				if (dwArg18 != 0x00)
					_Unwind_GetRegionStart();
				struct Eq_151789 * esp_101 = fp - 0x5C;
				byte dl_59 = *eax_34;
				Eq_2 ebx_58 = eax_34 + 1;
				if (dl_59 != ~0x00)
				{
					Eq_151687 esi_63 = (word32) dl_59;
					base_of_encoded_value(esi_63, dwArg18, dwArg18, gs);
					Eq_2 esp_86 = <invalid>;
					esp_101 = (word32) esp_86 + 20;
					word32 ecx_476;
					ebx_58 = read_encoded_value_with_base(esi_63, eax_34 + 1, gs, fp - 0x30, out ecx_476);
				}
				byte al_100 = *ebx_58;
				esp_101->b003C = al_100;
				struct Eq_151828 * edx_111 = (word32) ebx_58 + 1;
				if (al_100 != ~0x00)
				{
					ui32 esi_110 = 0x00;
					uip32 ecx_470 = 0x00;
					do
					{
						++edx_111;
						ui32 ebx_114 = (word32) edx_111->bFFFFFFFF;
						esi_110 |= (ebx_114 & 0x7F) << (byte) ecx_470;
						ecx_470 += 0x07;
					} while ((byte) ebx_114 < 0x00);
					esp_101->dw0034 = edx_111 + esi_110;
				}
				else
					esp_101->dw0034 = 0x00;
				esp_101->b003D = edx_111->b0000;
				ui32 ebx_136 = 0x00;
				Eq_2 esi_143 = edx_111 + 1;
				uip32 ecx_473 = 0x00;
				do
				{
					esi_143 = (word32) esi_143 + 1;
					ui32 edx_147 = (word32) *((word32) esi_143 - 1);
					ebx_136 |= (edx_147 & 0x7F) << (byte) ecx_473;
					ecx_473 += 0x07;
				} while ((byte) edx_147 < 0x00);
				struct Eq_151870 * esp_163 = esp_101 - 0x08;
				esp_163->t0040 = (word32) esi_143 + ebx_136;
				esp_163->ptrFFFFFFFC = &esp_163->dw0020;
				esp_163->ptrFFFFFFF8 = esp_163->ptr007C;
				struct Eq_151888 * esp_180 = (char *) &esp_163->ptrFFFFFFFC + 0x0C;
				Eq_2 ecx_174;
				up32 edi_184 = _Unwind_GetIPInfo(esp_163->ptrFFFFFFF8, esp_163->ptrFFFFFFFC, out ecx_174) - (esp_163->dw0020 < 0x01);
				if (esp_163->t0040 > esi_143)
				{
					esp_163->ptr000C = &esp_163->dw0020 + 2;
					esp_163->ptr0010 = &esp_163->dw0020 + 3;
					Eq_2 esi_192 = esi_143;
					do
					{
						Eq_151687 ebx_195 = (word32) esp_180->b003D;
						base_of_encoded_value(ebx_195, ecx_174, 0x00, gs);
						struct Eq_151964 * esp_207 = esp_180 - 0x0C;
						esp_207->ptrFFFFFFFC = (word32 *) (&esp_163->dw0020 + 1);
						Eq_2 ecx_221;
						Eq_2 eax_216 = read_encoded_value_with_base(ebx_195, esi_192, gs, esp_207->ptrFFFFFFFC, out ecx_221);
						Eq_2 esp_220 = <invalid>;
						Eq_151687 ebx_227 = (word32) *((word32) esp_220 + 81);
						base_of_encoded_value(ebx_227, ecx_221, 0x00, gs);
						*((word32) esp_220 + 4) = *((word32) esp_220 + 24);
						Eq_2 ecx_251;
						Eq_2 eax_246 = read_encoded_value_with_base(ebx_227, eax_216, gs, *((word32) esp_220 + 4), out ecx_251);
						Eq_2 esp_250 = <invalid>;
						Eq_151687 ebx_257 = (word32) *((word32) esp_250 + 81);
						base_of_encoded_value(ebx_257, ecx_251, 0x00, gs);
						*((word32) esp_250 + 4) = *((word32) esp_250 + 28);
						Eq_2 esp_280 = <invalid>;
						esp_180 = (word32) esp_280 + 20;
						esi_192 = read_encoded_value_with_base(ebx_257, eax_246, gs, *((word32) esp_250 + 4), out ecx_174);
						do
							esi_192 = (word32) esi_192 + 1;
						while (*((word32) esi_192 - 1) < 0x00);
						word32 eax_298 = Mem273[esp_280 + 0x30:word32] + Mem273[esp_280 + 0x3C:word32];
						if (eax_298 > edi_184)
							break;
						if ((word32) *((word32) esp_280 + 52) + eax_298 > edi_184)
						{
							Eq_2 eax_306 = *((word32) esp_280 + 56);
							if (eax_306 == 0x00)
								break;
							word32 eax_310 = eax_306 + Mem273[esp_280 + 0x40:word32];
							if (eax_310 == null)
								break;
							*((word32) esp_280 + 0x0C) = *((word32) esp_280 + 0x0084);
							*((word32) esp_280 + 8) = null;
							*((word32) esp_280 + 4) = *((word32) esp_280 + 0x0088);
							_Unwind_SetGR(gs, *((word32) esp_280 + 4), *((word32) esp_280 + 8), *((word32) esp_280 + 0x0C));
							*((word32) esp_280 + 16) = null;
							*((word32) esp_280 + 0x0C) = (struct Eq_22859 *) 0x02;
							*((word32) esp_280 + 8) = *((word32) esp_280 + 0x008C);
							_Unwind_SetGR(gs, *((word32) esp_280 + 8), *((word32) esp_280 + 0x0C), *((word32) esp_280 + 16));
							*((word32) esp_280 + 16) = eax_310;
							*((word32) esp_280 + 0x0C) = *((word32) esp_280 + 144);
							_Unwind_SetIP(*((word32) esp_280 + 0x0C), *((word32) esp_280 + 16));
							return;
						}
					} while (*((word32) esp_280 + 76) > esi_192);
				}
			}
		}
	}
}

// 080A0D90: Register ptr32 __dl_iterate_phdr(Register (ptr32 Eq_9) gs, Stack (ptr32 code) dwArg04, Stack ptr32 dwArg08, Register out ptr32 edxOut)
// Called from:
//      _Unwind_Find_FDE
ptr32 __dl_iterate_phdr(struct Eq_9 * gs, <anonymous> * dwArg04, ptr32 dwArg08, ptr32 & edxOut)
{
	ui32 ebx_23 = gs->dw0014;
	ptr32 edx_134;
	Mem43 = Mem24;
	Eq_2 ebx_46 = g_t80CEA00;
	if (ebx_46 != 0x00)
	{
		Eq_2 edi_135 = ebx_46;
		do
		{
			struct Eq_125705 * eax_64 = *((word32) edi_135 + 20);
			if (eax_64->dw0248 != 0x00)
				_dl_tls_get_addr_soft(gs, eax_64);
			ptr32 eax_126;
			dwArg04();
			if (eax_126 != 0x00)
			{
				edx_134 = eax_126;
				goto l080A0EB2;
			}
			edi_135 = *((word32) edi_135 + 0x0C);
		} while (edi_135 != 0x00);
	}
	edx_134 = 0x00;
l080A0EB2:
	Mem180 = Mem144;
	if ((ebx_23 ^ gs->dw0014) != 0x00)
	{
		word32 ecx_374;
		word32 edx_375;
		Eq_2 eax_189 = __stack_chk_fail(out ecx_374, out edx_375);
		byte al_195 = (byte) eax_189;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		*eax_189 = (word32) *eax_189 + al_195;
		Eq_2 esi_230 = _nl_domain_bindings;
		if (esi_230 == 0x00)
		{
			ptr32 edx_239;
			ptr32 eax_234 = fn080A0F73(&g_t80CE000, gs, out edx_239);
			edxOut = edx_239;
			return eax_234;
		}
		else
		{
			ptr32 edx_250;
			ptr32 eax_245 = fn080A0F32(&g_t80CE000, esi_230, &_nl_domain_bindings, gs, out edx_250);
			edxOut = edx_250;
			return eax_245;
		}
	}
	else
	{
		edxOut = edx_134;
		return edx_134;
	}
}

