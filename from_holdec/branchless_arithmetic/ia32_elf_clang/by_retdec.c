//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;

// ------------------- Function Prototypes --------------------

int32_t __divdi3(void);
int32_t __udivdi3(void);
int32_t abs32(int32_t a1);
int32_t abs64(int32_t a1, int32_t a2);
int32_t sat_adds32b_var1(int32_t a1, int32_t a2);
int32_t sat_adds32b_var2(int32_t a1, int32_t a2);
int32_t sat_adds32b_var3(int32_t a1, int32_t a2);
int32_t sat_adds64b(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t sat_addu32b(uint32_t a1, int32_t a2);
int32_t sat_addu64b(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4);
int32_t sat_divs32b(int32_t a1, uint32_t a2);
int32_t sat_divs64b(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t sat_divu32b(uint32_t a1, uint32_t a2);
int32_t sat_divu64b(int32_t a1);
int32_t sat_muls32b(int32_t a1, int32_t a2);
int32_t sat_mulu32b(uint32_t a1, uint32_t a2);
int32_t sat_subs32b(int32_t a1, int32_t a2);
int32_t sat_subs64b(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t sat_subu32b(uint32_t a1, uint32_t a2);
int32_t sat_subu64b(uint32_t a1, uint32_t a2, uint32_t a3, int32_t a4);
int32_t sgn32(int32_t a1);
int32_t sgn64(int32_t a1, int32_t a2);

// --------------------- Global Variables ---------------------

int128_t g1; // 0x804a010
int32_t g2;

// ------------------------ Functions -------------------------

// Address range: 0x8049190 - 0x80491a1
int32_t sat_addu32b(uint32_t a1, int32_t a2) {
    uint32_t v1 = a2 + a1; // 0x8049194
    return v1 >= a1 ? v1 : -1;
}

// Address range: 0x80491b0 - 0x80491be
int32_t sat_subu32b(uint32_t a1, uint32_t a2) {
    // 0x80491b0
    return (int32_t)(a1 < a2 ? a2 : a1) - a2;
}

// Address range: 0x80491c0 - 0x80491cb
int32_t sat_divu32b(uint32_t a1, uint32_t a2) {
    // 0x80491c0
    return a1 / a2;
}

// Address range: 0x80491d0 - 0x80491e1
int32_t sat_mulu32b(uint32_t a1, uint32_t a2) {
    uint64_t v1 = (int64_t)a2 * (int64_t)a1; // 0x80491d4
    return (int32_t)(v1 < 0xffffffff ? v1 : 0xffffffff);
}

// Address range: 0x80491f0 - 0x804920c
int32_t sat_addu64b(uint32_t a1, uint32_t a2, int32_t a3, int32_t a4) {
    uint32_t v1 = a3 + a1; // 0x80491f8
    uint32_t v2 = a4 + a2; // 0x80491fc
    return v1 < a1 ? v2 + (int32_t)(v1 < a1) <= a2 : v2 < a2 ? -1 : v1;
}

// Address range: 0x8049210 - 0x8049229
int32_t sat_subu64b(uint32_t a1, uint32_t a2, uint32_t a3, int32_t a4) {
    uint32_t v1 = (int32_t)(bool)(a1 < a3) + a4; // 0x804921e
    bool v2 = a1 < a3 ? v1 != -1 | (int32_t)(a1 < a3) + a2 - v1 > a2 : v1 > a2; // 0x804921e
    return v2 ? 0 : a1 - a3;
}

// Address range: 0x8049230 - 0x8049245
int32_t sat_divu64b(int32_t a1) {
    // 0x8049230
    __asm_movups(0, __asm_movaps((int128_t)a1));
    return __udivdi3();
}

// Address range: 0x8049250 - 0x804926f
int32_t sat_adds32b_var1(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + a1; // 0x804925d
    return ((v1 ^ a1) & (v1 ^ a2)) < 0 ? v1 >= 0 ? -0x80000000 : 0x7fffffff : v1;
}

// Address range: 0x8049270 - 0x8049296
int32_t sat_adds32b_var2(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + a1; // 0x804927a
    return (a2 ^ a1) < 0 | (v1 ^ a1) >= 0 ? v1 : a1 < 0 ? -0x80000000 : 0x7fffffff;
}

// Address range: 0x80492a0 - 0x80492c3
int32_t sat_adds32b_var3(int32_t a1, int32_t a2) {
    int32_t v1 = a2 + a1; // 0x80492a9
    int32_t v2 = a1 < 0 ? -0x80000000 : 0x7fffffff; // 0x80492af
    return (v2 ^ a2 | a2 ^ -0x80000000 ^ v1) < 0 ? v1 : v2;
}

// Address range: 0x80492d0 - 0x80492f2
int32_t sat_subs32b(int32_t a1, int32_t a2) {
    int32_t v1 = a1 - a2; // 0x80492db
    int32_t v2 = a1 < 0 ? -0x80000000 : 0x7fffffff; // 0x80492e0
    return ((v2 ^ a2) & (v2 ^ v1)) >= 0 ? v1 : v2;
}

// Address range: 0x8049300 - 0x8049324
int32_t sat_divs32b(int32_t a1, uint32_t a2) {
    int32_t v1 = (int32_t)(bool)((a2 + 1 | a1 ^ -0x80000000) == 0) + a1; // 0x804931c
    return (0x100000000 * (int64_t)(v1 >> 31) | (int64_t)v1) / (int64_t)a2;
}

// Address range: 0x8049330 - 0x8049356
int32_t sat_muls32b(int32_t a1, int32_t a2) {
    uint64_t v1 = (int64_t)a2 * (int64_t)a1; // 0x804933c
    int32_t v2 = v1; // 0x804933c
    int32_t v3 = (a2 ^ a1) < 0 ? -0x80000000 : 0x7fffffff; // 0x8049348
    return v2 >> 31 != (int32_t)(v1 / 0x100000000) ? v3 : v2;
}

// Address range: 0x8049360 - 0x8049391
int32_t sat_adds64b(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    uint32_t v1 = a3 + a1; // 0x804936b
    int32_t v2 = a2 < 0 ? -0x80000000 : 0x7fffffff; // 0x804937e
    return (a4 + a2 + (int32_t)(v1 < a3) ^ -0x80000000 | a4) < 0 ? v1 : v2;
}

// Address range: 0x80493a0 - 0x80493cb
int32_t sat_subs64b(uint32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    int32_t v1 = a2 < 0 ? -0x80000000 : 0x7fffffff; // 0x80493b9
    return (a2 - a4 + (int32_t)(a1 < a3) & a4) >= 0 ? a1 - a3 : v1;
}

// Address range: 0x80493d0 - 0x8049420
int32_t sat_divs64b(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x80493d0
    return __divdi3();
}

// Address range: 0x8049420 - 0x804942c
int32_t abs32(int32_t a1) {
    // 0x8049420
    return a1 < 0 ? -a1 : a1;
}

// Address range: 0x8049430 - 0x8049446
int32_t abs64(int32_t a1, int32_t a2) {
    int32_t v1 = a2 >> 31; // 0x8049436
    return v1 + a1 ^ v1;
}

// Address range: 0x8049450 - 0x8049461
int32_t sgn32(int32_t a1) {
    // 0x8049450
    return (a1 >> 31) + (int32_t)(bool)(a1 >= 0 == (a1 != 0));
}

// Address range: 0x8049470 - 0x804948d
int32_t sgn64(int32_t a1, int32_t a2) {
    int32_t v1 = (bool)(a1 != 0); // 0x804947a
    int32_t v2 = v1 + a2; // 0x804947a
    int32_t v3 = -v2; // 0x804947a
    return (a2 >> 31) + (int32_t)(v3 < 0 != (v3 - v1 & v2) < 0);
}

// Address range: 0x8049490 - 0x80496e5
int main(int argc, char ** argv) {
    // 0x8049490
    int32_t v1; // 0x8049490
    int32_t v2 = v1;
    int128_t v3; // 0x8049490
    int128_t v4 = v3;
    printf("sat_addu32b(0x%08x,0x%08x) = 0x%08x\n", -1, 3, sat_addu32b(-1, 3));
    printf("sat_subu32b(0x%08x,0x%08x) = 0x%08x\n", 1, 3, sat_subu32b(1, 3));
    printf("sat_mulu32b(0x%08x,0x%08x) = 0x%08x\n", -1, 3, sat_mulu32b(-1, 3));
    printf("sat_divu32b(0x%08x,0x%08x) = 0x%08x\n", -1, 3, sat_divu32b(-1, 3));
    int32_t v5 = sat_adds32b_var1(0x7fffffff, 2); // 0x8049519
    int32_t v6 = sat_adds32b_var2(0x7fffffff, 2); // 0x804952d
    printf("sat_adds32b(0x%08x,0x%08x) = 0x%08x 0x%08x 0x%08x\n", 0x7fffffff, 2, v5, v6, sat_adds32b_var3(0x7fffffff, 2));
    printf("sat_subs32b(0x%08x,0x%08x) = 0x%08x\n", -0x80000000, 2, sat_subs32b(-0x80000000, 2));
    printf("sat_muls32b(0x%08x,0x%08x) = 0x%08x\n", 0x7fffffff, 2, sat_muls32b(0x7fffffff, 2));
    printf("sat_divs32b(0x%08x,0x%08x) = 0x%08x\n", -0x80000000, -1, sat_divs32b(-0x80000000, -1));
    printf("abs32(0x%08x) = 0x%08x\n", -16, abs32(-16));
    printf("sgn32(0x%08x) = 0x%08x\n", 3, sgn32(3));
    int128_t v7 = __asm_xorps(v4, v4); // 0x80495fd
    __asm_movups((int128_t)(int32_t)"sgn32(0x%08x) = 0x%08x\n", v7);
    int32_t v8 = sat_addu64b((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x8049604
    __asm_movups((int128_t)(int32_t)"sgn32(0x%08x) = 0x%08x\n", __asm_xorps(v7, v7));
    uint32_t v9 = sat_subu64b((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x804961a
    uint32_t v10 = v9 + v8; // 0x8049626
    int128_t v11 = __asm_movaps(g1); // 0x804962d
    __asm_movups((int128_t)(int32_t)"sgn32(0x%08x) = 0x%08x\n", v11);
    uint32_t v12 = sat_divu64b((int32_t)&g2); // 0x8049638
    uint32_t v13 = v12 + v10; // 0x8049644
    int128_t v14 = __asm_xorps(v11, v11); // 0x804964b
    __asm_movups((int128_t)(int32_t)"sgn32(0x%08x) = 0x%08x\n", v14);
    uint32_t v15 = sat_adds64b((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x8049652
    uint32_t v16 = v15 + v13; // 0x804965e
    __asm_movups((int128_t)(int32_t)"sgn32(0x%08x) = 0x%08x\n", __asm_xorps(v14, v14));
    uint32_t v17 = sat_subs64b((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x804966c
    uint32_t v18 = v17 + v16; // 0x8049678
    __asm_movups((int128_t)(int32_t)"sgn32(0x%08x) = 0x%08x\n", __asm_movaps(g1));
    uint32_t v19 = sat_divs64b((int32_t)&g2, (int32_t)&g2, (int32_t)&g2, (int32_t)&g2); // 0x804968a
    uint32_t v20 = v19 + v18; // 0x8049696
    uint32_t v21 = abs64(0, 0); // 0x80496a1
    uint32_t v22 = v21 + v20; // 0x80496ad
    uint32_t v23 = sgn64(0, 0); // 0x80496b8
    uint32_t v24 = v23 + v22; // 0x80496c0
    if (((2 * v2 || (int32_t)(v10 < v9)) + 6 * v2 + (int32_t)(v13 < v12) + (int32_t)(v16 < v15) + (int32_t)(v18 < v17) + (int32_t)(v20 < v19) + (int32_t)(v22 < v21) + (int32_t)(v24 < v23) || v24 ^ 42) == 0) {
        // 0x80496cb
        puts("not reached");
    }
    // 0x80496db
    return 0;
}

// Address range: 0x80496f0 - 0x80496f1
int32_t __divdi3(void) {
    // 0x80496f0
    int32_t result; // 0x80496f0
    return result;
}

// Address range: 0x8049830 - 0x8049831
int32_t __udivdi3(void) {
    // 0x8049830
    int32_t result; // 0x8049830
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int printf(const char * restrict format, ...);
// int puts(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (11.1.1)
// Detected functions: 23

