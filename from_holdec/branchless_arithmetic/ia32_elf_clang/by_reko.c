// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b804C01C = 0x00; // 0804C01C
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080499CC: void _fini()
void _fini()
{
}

// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804C004 = null; // 0804C004
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049000: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	<anonymous> * eax_10 = g_ptr804C004;
	if (eax_10 != null)
		eax_10();
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049040: void printf()
void printf()
{
}

// 08049050: void puts()
void puts()
{
}

// 08049060: void __libc_start_main()
void __libc_start_main()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _fp_hw = 0x03; // 0804A000
word32 _IO_stdin_used = 0x00020001; // 0804A004
word128 g_ow804A010 = // 0804A010
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	};
char g_str804A030[] = "sat_addu32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A030
char g_str804A055[] = "sat_subu32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A055
char g_str804A07A[] = "sat_mulu32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A07A
char g_str804A09F[] = "sat_divu32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A09F
char g_str804A0C4[] = "sat_adds32b(0x%08x,0x%08x) = 0x%08x 0x%08x 0x%08x\n"; // 0804A0C4
char g_str804A0F7[] = "sat_subs32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A0F7
char g_str804A11C[] = "sat_muls32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A11C
char g_str804A141[] = "sat_divs32b(0x%08x,0x%08x) = 0x%08x\n"; // 0804A141
char g_str804A166[] = "abs32(0x%08x) = 0x%08x\n"; // 0804A166
char g_str804A17E[] = "sgn32(0x%08x) = 0x%08x\n"; // 0804A17E
char g_str804A196[] = "not reached"; // 0804A196
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049070: void _start(Register (ptr32 Eq_7) edx, Stack int32 dwArg00)
void _start(void (* edx)(), int32 dwArg00)
{
	__align((char *) fp + 4);
	__libc_start_main(&g_t8049490, dwArg00, (char *) fp + 4, &g_t8049950, &g_t80499C0, edx, fp);
	__hlt();
}

// 080490B0: void _dl_relocate_static_pie()
void _dl_relocate_static_pie()
{
}

// 080490C0: void __x86.get_pc_thunk.bx()
void __x86.get_pc_thunk.bx()
{
}

// 080490D0: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
}

// 08049110: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
}

// 08049150: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if (g_b804C01C != 0x00)
		return;
	deregister_tm_clones();
	g_b804C01C = 0x01;
}

// 08049180: void frame_dummy()
void frame_dummy()
{
	register_tm_clones();
}

// 08049190: Register up32 sat_addu32b(Stack word32 dwArg04, Stack word32 dwArg08)
// Called from:
//      main
up32 sat_addu32b(word32 dwArg04, word32 dwArg08)
{
	up32 ecx_6 = dwArg04 + dwArg08;
	up32 eax_10 = ~0x00;
	if (ecx_6 >= 0x00)
		eax_10 = ecx_6;
	return eax_10;
}

// 080491B0: Register up32 sat_subu32b(Stack word32 dwArg04, Stack word32 dwArg08)
// Called from:
//      main
up32 sat_subu32b(word32 dwArg04, word32 dwArg08)
{
	up32 eax_10 = dwArg04 - dwArg08;
	if (eax_10 < 0x00)
		eax_10 = 0x00;
	return eax_10;
}

// 080491C0: Register uint32 sat_divu32b(Stack word32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      main
uint32 sat_divu32b(word32 dwArg04, uint32 dwArg08)
{
	return (uint32) ((uint64) dwArg04 /u dwArg08);
}

// 080491D0: Register word32 sat_mulu32b(Stack uint32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      main
word32 sat_mulu32b(uint32 dwArg04, uint32 dwArg08)
{
	uint64 edx_eax_6 = dwArg08 *64 dwArg04;
	word32 eax_12 = (word32) edx_eax_6;
	if (OVERFLOW(edx_eax_6))
		eax_12 = ~0x00;
	return eax_12;
}

// 080491F0: void sat_addu64b(Stack word64 qwArg04, Stack ui64 qwArg0C)
// Called from:
//      main
void sat_addu64b(word64 qwArg04, ui64 qwArg0C)
{
}

// 08049210: void sat_subu64b(Stack word64 qwArg04, Stack ui64 qwArg0C)
// Called from:
//      main
void sat_subu64b(word64 qwArg04, ui64 qwArg0C)
{
}

// 08049230: Register word128 sat_divu64b(Stack word128 owArg04)
// Called from:
//      main
word128 sat_divu64b(word128 owArg04)
{
	word32 edx_11;
	__udivdi3((word64) owArg04, SLICE(owArg04, word32, 64), SLICE(owArg04, word32, 96), out edx_11);
	return owArg04;
}

// 08049250: Register uint32 sat_adds32b_var1(Stack word32 dwArg04, Stack word32 dwArg08)
// Called from:
//      main
uint32 sat_adds32b_var1(word32 dwArg04, word32 dwArg08)
{
	uint32 ecx_16 = (uint32) (int8) (dwArg04 + dwArg08 >= 0x00);
	uint32 eax_18 = dwArg04 + dwArg08;
	if (OVERFLOW(eax_18))
		eax_18 = ecx_16 + 0x7FFFFFFF;
	return eax_18;
}

// 08049270: Register uint32 sat_adds32b_var2(Stack uint32 dwArg04, Stack word32 dwArg08)
// Called from:
//      main
uint32 sat_adds32b_var2(uint32 dwArg04, word32 dwArg08)
{
	uint32 esi_12 = dwArg08 + dwArg04;
	uint32 eax_15 = (dwArg04 >> 0x1F) + 0x7FFFFFFF;
	if ((esi_12 ^ dwArg04) >= 0x00)
		eax_15 = esi_12;
	if ((dwArg08 ^ dwArg04) < 0x00)
		eax_15 = esi_12;
	return eax_15;
}

// 080492A0: Register uint32 sat_adds32b_var3(Stack uint32 dwArg04, Stack word32 dwArg08)
// Called from:
//      main
uint32 sat_adds32b_var3(uint32 dwArg04, word32 dwArg08)
{
	uint32 eax_11 = (dwArg04 >> 0x1F) + 0x7FFFFFFF;
	uint32 edx_9 = dwArg08 + dwArg04;
	if ((~(dwArg08 ^ edx_9) | eax_11 ^ dwArg08) < 0x00)
		eax_11 = edx_9;
	return eax_11;
}

// 080492D0: Register uint32 sat_subs32b(Stack uint32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      main
uint32 sat_subs32b(uint32 dwArg04, uint32 dwArg08)
{
	uint32 eax_12 = (dwArg04 >> 0x1F) + 0x7FFFFFFF;
	uint32 edx_10 = dwArg04 - dwArg08;
	if (((dwArg08 ^ eax_12) & (eax_12 ^ edx_10)) >= 0x00)
		eax_12 = edx_10;
	return eax_12;
}

// 08049300: Register int32 sat_divs32b(Stack word32 dwArg04, Stack int32 dwArg08)
// Called from:
//      main
int32 sat_divs32b(word32 dwArg04, int32 dwArg08)
{
	return (int32) ((int64) ((uint32) (int8) ((dwArg04 ^ 0x80000000 | dwArg08 + 0x01) == 0x00) + dwArg04) /32 dwArg08);
}

// 08049330: Register Eq_189 sat_muls32b(Stack int32 dwArg04, Stack int32 dwArg08)
// Called from:
//      main
Eq_189 sat_muls32b(int32 dwArg04, int32 dwArg08)
{
	int64 edx_eax_13 = dwArg04 *s64 dwArg08;
	Eq_189 eax_14 = (word32) edx_eax_13;
	Eq_189 ecx_19 = ((dwArg08 ^ dwArg04) >> 0x1F) + 0x7FFFFFFF;
	if (eax_14 >> 0x1F != SLICE(edx_eax_13, word32, 32))
		eax_14 = ecx_19;
	return eax_14;
}

// 08049360: void sat_adds64b(Stack word64 qwArg04, Stack ui64 qwArg0C)
// Called from:
//      main
void sat_adds64b(word64 qwArg04, ui64 qwArg0C)
{
	ui32 dwArg10 = SLICE(qwArg0C, word32, 32);
}

// 080493A0: void sat_subs64b(Stack word64 qwArg04, Stack ui64 qwArg0C)
// Called from:
//      main
void sat_subs64b(word64 qwArg04, ui64 qwArg0C)
{
	ui32 dwArg10 = SLICE(qwArg0C, word32, 32);
}

// 080493D0: void sat_divs64b(Stack up32 dwArg04, Stack ui32 dwArg08, Stack Eq_100 dwArg0C, Stack Eq_100 dwArg10)
// Called from:
//      main
void sat_divs64b(up32 dwArg04, ui32 dwArg08, Eq_100 dwArg0C, Eq_100 dwArg10)
{
	uint64 ecx_eax_73 = SEQ(dwArg08, (uint32) (int8) ((dwArg04 + 0x80000000 | (word32) dwArg0C + 1 | ((dwArg08 + ~0x00) + (word32) (dwArg04 < 0x80000000) | (word32) dwArg10 + (word32) (dwArg0C < 0x01))) == 0x00)) + (uint64) dwArg04;
	word32 edx_57;
	__divdi3((word32) ecx_eax_73, SLICE(ecx_eax_73, word32, 32), dwArg0C, dwArg10, out edx_57);
}

// 08049420: Register int32 abs32(Stack int32 dwArg04)
// Called from:
//      main
int32 abs32(int32 dwArg04)
{
	int32 eax_11 = -dwArg04;
	if (eax_11 < 0x00)
		eax_11 = dwArg04;
	return eax_11;
}

// 08049430: void abs64(Stack word64 qwArg04)
// Called from:
//      main
void abs64(word64 qwArg04)
{
}

// 08049450: Register uint32 sgn32(Stack int32 dwArg04)
// Called from:
//      main
uint32 sgn32(int32 dwArg04)
{
	return (dwArg04 >> 0x1F) + (uint32) ((int8) (dwArg04 > 0x00));
}

// 08049470: void sgn64(Stack word32 dwArg04, Stack word32 dwArg08)
// Called from:
//      main
void sgn64(word32 dwArg04, word32 dwArg08)
{
}

// 08049490: void main(Register Eq_284 xmm0)
void main(Eq_284 xmm0)
{
	printf("sat_addu32b(0x%08x,0x%08x) = 0x%08x\n", ~0x00, 0x03, sat_addu32b(~0x00, 0x03));
	printf("sat_subu32b(0x%08x,0x%08x) = 0x%08x\n", 0x01, 0x03, sat_subu32b(0x01, 0x03));
	printf("sat_mulu32b(0x%08x,0x%08x) = 0x%08x\n", ~0x00, 0x03, sat_mulu32b(~0x00, 0x03));
	printf("sat_divu32b(0x%08x,0x%08x) = 0x%08x\n", ~0x00, 0x03, sat_divu32b(~0x00, 0x03));
	printf("sat_adds32b(0x%08x,0x%08x) = 0x%08x 0x%08x 0x%08x\n", 0x7FFFFFFF, 0x02, sat_adds32b_var1(0x7FFFFFFF, 0x02), sat_adds32b_var2(0x7FFFFFFF, 0x02), sat_adds32b_var3(0x7FFFFFFF, 0x02));
	printf("sat_subs32b(0x%08x,0x%08x) = 0x%08x\n", 0x80000000, 0x02, sat_subs32b(0x80000000, 0x02));
	printf("sat_muls32b(0x%08x,0x%08x) = 0x%08x\n", 0x7FFFFFFF, 0x02, sat_muls32b(0x7FFFFFFF, 0x02));
	printf("sat_divs32b(0x%08x,0x%08x) = 0x%08x\n", 0x80000000, ~0x00, sat_divs32b(0x80000000, ~0x00));
	printf("abs32(0x%08x) = 0x%08x\n", ~0x0F, abs32(~0x0F));
	printf("sgn32(0x%08x) = 0x%08x\n", 0x03, sgn32(0x03));
	Eq_284 xmm0_272 = __xorps(xmm0, xmm0);
	sat_addu64b((word64) xmm0_272, SLICE(xmm0_272, ui64, 64));
	Eq_284 xmm0_288 = __xorps(xmm0_272, xmm0_272);
	sat_subu64b((word64) xmm0_288, SLICE(xmm0_288, ui64, 64));
	Eq_284 xmm0_311 = sat_divu64b(g_ow804A010);
	Eq_284 xmm0_327 = __xorps(xmm0_311, xmm0_311);
	sat_adds64b((word64) xmm0_327, SLICE(xmm0_327, ui64, 64));
	Eq_284 xmm0_347 = __xorps(xmm0_327, xmm0_327);
	sat_subs64b((word64) xmm0_347, SLICE(xmm0_347, ui64, 64));
	word128 xmm0_365 = g_ow804A010;
	sat_divs64b((word32) xmm0_365, SLICE(xmm0_365, word32, 32), SLICE(xmm0_365, word32, 64), SLICE(xmm0_365, word32, 96));
	abs64(0x00);
	sgn64(0x00, 0x00);
	ui64 edx_eax_567 = <invalid>;
	ui64 edx_eax_566 = <invalid>;
	ui64 edx_eax_568 = <invalid>;
	ui64 edx_eax_569 = <invalid>;
	ui64 edx_eax_570 = <invalid>;
	ui64 edx_eax_571 = <invalid>;
	ui64 edx_eax_572 = <invalid>;
	ui64 edx_eax_573 = <invalid>;
	ui64 edx_eax_463 = edx_eax_573 + (edx_eax_572 + (edx_eax_571 + (edx_eax_570 + (edx_eax_569 + (edx_eax_568 + (edx_eax_566 + edx_eax_567))))));
	if (((word32) edx_eax_463 ^ 0x2A | SLICE(edx_eax_463, word32, 32)) == 0x00)
		puts("not reached");
}

// 080496F0: Register uint32 __divdi3(Stack Eq_100 dwArg04, Stack Eq_100 dwArg08, Stack Eq_100 dwArg0C, Stack Eq_100 dwArg10, Register out Eq_261 edxOut)
// Called from:
//      sat_divs64b
uint32 __divdi3(Eq_100 dwArg04, Eq_100 dwArg08, Eq_100 dwArg0C, Eq_100 dwArg10, union Eq_261 & edxOut)
{
	word32 dwLoc24_217 = 0x00;
	Eq_100 eax_20 = dwArg0C;
	Eq_100 dwLoc2C_220 = dwArg04;
	Eq_100 ebp_23 = dwArg08;
	if (dwArg08 < 0x00)
	{
		dwLoc24_217 = ~0x00;
		dwLoc2C_220 = -dwArg04;
		ebp_23 = -((word32) dwArg08.u0 + (dwArg04 != 0x00));
	}
	Eq_100 ebx_39 = dwArg10;
	if (dwArg10 < 0x00)
	{
		eax_20 = -dwArg0C;
		dwLoc24_217 = ~dwLoc24_217;
		ebx_39 = -((word32) dwArg10.u0 + (dwArg0C != 0x00));
	}
	Eq_261 esi_123;
	uint32 ebp_106;
	Eq_100 edi_148 = eax_20;
	if (ebx_39 == 0x00)
	{
		if (eax_20 > ebp_23)
		{
			esi_123.u0 = 0x00;
			ebp_106 = (uint32) (SEQ(ebp_23, dwLoc2C_220) /u eax_20);
		}
		else
		{
			if (eax_20 == 0x00)
				edi_148.u1 = (uint32) (0x01 /u ebx_39);
			uint64 edx_eax_152 = (uint64) ebp_23;
			esi_123.u0 = (uint32) (edx_eax_152 /u edi_148);
			ebp_106 = (uint32) (SEQ((uint32) (edx_eax_152 % edi_148), dwLoc2C_220) /u edi_148);
		}
	}
	else
	{
		if (ebx_39 > ebp_23)
		{
			esi_123.u0 = 0x00;
			ebp_106 = 0x00;
			goto l08049770;
		}
		word32 esi_68 = __bsr(ebx_39);
		esi_123 = esi_68 ^ 0x1F;
		if ((esi_68 ^ 0x1F) == 0x00)
		{
			if (ebx_39 >= ebp_23)
			{
				ebp_106 = 0x00;
				if (eax_20 > dwLoc2C_220)
					goto l08049770;
			}
			ebp_106 = 0x01;
			goto l08049770;
		}
		word32 eax_76 = 0x20 - (esi_68 ^ 0x1F);
		uint32 edx_83 = eax_20 >> (byte) eax_76 | ebx_39 << ((byte) esi_68 ^ 0x1F);
		uint64 edx_eax_101 = SEQ(ebp_23 >> (byte) eax_76, ebp_23 << ((byte) esi_68 ^ 0x1F) | dwLoc2C_220 >> (byte) eax_76);
		uint32 eax_104 = (uint32) (edx_eax_101 /u edx_83);
		uint64 edx_eax_107 = (eax_20 << ((byte) esi_68 ^ 0x1F)) *64 eax_104;
		uint32 edx_103 = (uint32) (edx_eax_101 % edx_83);
		ebp_106 = eax_104;
		uint32 edx_108 = SLICE(edx_eax_107, word32, 32);
		uint32 eax_115 = (word32) edx_eax_107;
		if (edx_103 < edx_108 || dwLoc2C_220 << ((byte) esi_68 ^ 0x1F) < eax_115 && edx_103 == edx_108)
			ebp_106 = eax_104 - 0x01;
		esi_123.u0 = 0x00;
	}
l08049770:
	uint32 eax_186 = ebp_106;
	Eq_261 edx_189 = esi_123;
	if (dwLoc24_217 != 0x00)
	{
		eax_186 = -ebp_106;
		edx_189 = -((word32) esi_123.u0 + (word32) (ebp_106 != 0x00));
	}
	edxOut = edx_189;
	return eax_186;
}

// 08049830: Register uint32 __udivdi3(Stack uint64 qwArg04, Stack Eq_100 dwArg0C, Stack Eq_100 dwArg10, Register out Eq_102 edxOut)
// Called from:
//      sat_divu64b
uint32 __udivdi3(uint64 qwArg04, Eq_100 dwArg0C, Eq_100 dwArg10, union Eq_102 & edxOut)
{
	Eq_100 dwArg04 = (word32) qwArg04;
	Eq_100 dwArg08 = SLICE(qwArg04, word32, 32);
	if (dwArg10 == 0x00)
	{
		if (dwArg0C <= dwArg08)
		{
			Eq_100 ecx_124 = dwArg0C;
			if (dwArg0C == 0x00)
				ecx_124.u1 = (uint32) (0x01 /u dwArg0C);
			uint64 edx_eax_139 = (uint64) dwArg08;
			edxOut.u0 = (uint32) (edx_eax_139 /u ecx_124);
			return (uint32) (SEQ((uint32) (edx_eax_139 % ecx_124), dwArg04) /u ecx_124);
		}
		else
		{
			edxOut.u0 = 0x00;
			return (uint32) (qwArg04 /u dwArg0C);
		}
	}
	uint32 eax_217;
	Eq_102 edi_101;
	if (dwArg10 > dwArg08)
	{
		edi_101.u0 = 0x00;
		eax_217 = 0x00;
		goto l08049870;
	}
	word32 edi_26 = __bsr(dwArg10);
	edi_101 = edi_26 ^ 0x1F;
	if ((edi_26 ^ 0x1F) == 0x00)
	{
		if (dwArg10 < dwArg08)
		{
l08049892:
			eax_217 = 0x01;
			goto l08049870;
		}
		eax_217 = 0x00;
		if (dwArg0C <= dwArg04)
			goto l08049892;
	}
	else
	{
		word32 edx_33 = 0x20 - (edi_26 ^ 0x1F);
		uint32 ecx_42 = dwArg10 << ((byte) edi_26 ^ 0x1F) | dwArg0C >> (byte) edx_33;
		uint64 edx_eax_63 = SEQ(dwArg08 >> (byte) edx_33, dwArg04 >> (byte) edx_33 | dwArg08 << ((byte) edi_26 ^ 0x1F));
		uint32 eax_66 = (uint32) (edx_eax_63 /u ecx_42);
		uint64 edx_eax_69 = (dwArg0C << ((byte) edi_26 ^ 0x1F)) *64 eax_66;
		uint32 edx_65 = (uint32) (edx_eax_63 % ecx_42);
		uint32 edx_70 = SLICE(edx_eax_69, word32, 32);
		uint32 eax_76 = (word32) edx_eax_69;
		if (edx_65 >= edx_70 && (dwArg04 << ((byte) edi_26 ^ 0x1F) >= eax_76 || edx_65 != edx_70))
		{
			eax_217 = eax_66;
			edi_101.u0 = 0x00;
		}
		else
		{
			eax_217 = eax_66 - 0x01;
			edi_101.u0 = 0x00;
		}
	}
l08049870:
	edxOut = edi_101;
	return eax_217;
}

// 08049950: void __libc_csu_init(Stack word32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
void __libc_csu_init(word32 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	_init();
	int32 ebx_29 = 0x0804C0F0 - 0x0804C0F4;
	if (ebx_29 >> 0x02 != 0x00)
	{
		int32 esi_37 = 0x00;
		do
		{
			((<anonymous> *[]) 0x0804C0F4)[esi_37]();
			++esi_37;
		} while (ebx_29 >> 0x02 != esi_37);
	}
}

// 080499C0: void __libc_csu_fini()
void __libc_csu_fini()
{
}

// 080499C5: void __x86.get_pc_thunk.bp()
void __x86.get_pc_thunk.bp()
{
}

