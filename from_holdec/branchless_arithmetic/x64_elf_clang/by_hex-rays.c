/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_401020(); // weak
// int puts(const char *s);
// int printf(const char *format, ...);
__int64 __fastcall sat_addu32b(int, int);
__int64 __fastcall sat_subu32b(unsigned int, unsigned int);
__int64 __fastcall sat_divu32b(unsigned int, unsigned int);
__int64 __fastcall sat_mulu32b(unsigned int, unsigned int);
__int64 __fastcall sat_addu64b(__int64, __int64);
unsigned __int64 __fastcall sat_subu64b(unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall sat_divu64b(unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall sat_mulu64b(unsigned __int64 a1, unsigned __int64 a2);
__int64 __fastcall sat_adds32b_var1(int, int);
__int64 __fastcall sat_adds32b_var2(unsigned int, int);
__int64 __fastcall sat_adds32b_var3(unsigned int, int);
__int64 __fastcall sat_subs32b(unsigned int, int);
__int64 __fastcall sat_divs32b(int, int);
__int64 __fastcall sat_muls32b(int, unsigned int);
unsigned __int64 __fastcall sat_adds64b(unsigned __int64 a1, __int64 a2);
unsigned __int64 __fastcall sat_subs64b(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sat_divs64b(__int64, __int64);
__int64 __fastcall sat_muls64b(__int64, unsigned __int64);
__int64 __fastcall abs32(unsigned int);
__int64 __fastcall abs64(__int64);
__int64 __fastcall sgn32(int);
__int64 __fastcall sgn64(__int64);
int __cdecl main(int argc, const char **argv, const char **envp);

//-------------------------------------------------------------------------
// Data declarations

__int64 (*qword_404010)(void) = NULL; // weak


//----- (0000000000401020) ----------------------------------------------------
__int64 sub_401020()
{
  return qword_404010();
}
// 401020: using guessed type __int64 __fastcall sub_401020();
// 404010: using guessed type __int64 (*qword_404010)(void);

//----- (0000000000401140) ----------------------------------------------------
__int64 __fastcall sat_addu32b(int a1, int a2)
{
  bool v2; // cf
  unsigned int v3; // edi
  __int64 result; // rax

  v2 = __CFADD__(a2, a1);
  v3 = a2 + a1;
  result = 0xFFFFFFFFLL;
  if ( !v2 )
    return v3;
  return result;
}

//----- (0000000000401150) ----------------------------------------------------
__int64 __fastcall sat_subu32b(unsigned int a1, unsigned int a2)
{
  __int64 result; // rax
  bool v3; // cf
  unsigned int v4; // edi

  result = 0LL;
  v3 = a1 < a2;
  v4 = a1 - a2;
  if ( !v3 )
    return v4;
  return result;
}

//----- (0000000000401160) ----------------------------------------------------
__int64 __fastcall sat_divu32b(unsigned int a1, unsigned int a2)
{
  return a1 / a2;
}

//----- (0000000000401170) ----------------------------------------------------
__int64 __fastcall sat_mulu32b(unsigned int a1, unsigned int a2)
{
  __int64 result; // rax

  result = a2 * a1;
  if ( !is_mul_ok(a2, a1) )
    return 0xFFFFFFFFLL;
  return result;
}

//----- (0000000000401180) ----------------------------------------------------
__int64 __fastcall sat_addu64b(__int64 a1, __int64 a2)
{
  bool v2; // cf
  __int64 v3; // rdi
  __int64 result; // rax

  v2 = __CFADD__(a2, a1);
  v3 = a2 + a1;
  result = -1LL;
  if ( !v2 )
    return v3;
  return result;
}

//----- (0000000000401190) ----------------------------------------------------
unsigned __int64 __fastcall sat_subu64b(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax
  bool v3; // cf
  unsigned __int64 v4; // rdi

  result = 0LL;
  v3 = a1 < a2;
  v4 = a1 - a2;
  if ( !v3 )
    return v4;
  return result;
}

//----- (00000000004011A0) ----------------------------------------------------
unsigned __int64 __fastcall sat_divu64b(unsigned __int64 a1, unsigned __int64 a2)
{
  if ( (a2 | a1) >> 32 )
    return a1 / a2;
  else
    return (unsigned int)a1 / (unsigned int)a2;
}

//----- (00000000004011C0) ----------------------------------------------------
unsigned __int64 __fastcall sat_mulu64b(unsigned __int64 a1, unsigned __int64 a2)
{
  unsigned __int64 result; // rax

  result = a2 * a1;
  if ( !is_mul_ok(a2, a1) )
    return -1LL;
  return result;
}

//----- (00000000004011E0) ----------------------------------------------------
__int64 __fastcall sat_adds32b_var1(int a1, int a2)
{
  __int64 result; // rax
  bool v3; // of
  unsigned int v4; // edi

  result = (unsigned int)(a2 + a1 >= 0) + 0x7FFFFFFF;
  v3 = __OFADD__(a2, a1);
  v4 = a2 + a1;
  if ( !v3 )
    return v4;
  return result;
}

//----- (0000000000401200) ----------------------------------------------------
__int64 __fastcall sat_adds32b_var2(unsigned int a1, int a2)
{
  unsigned int v2; // ecx
  __int64 result; // rax

  v2 = a2 + a1;
  result = (a1 >> 31) + 0x7FFFFFFF;
  if ( ((a1 ^ (a2 + a1)) & 0x80000000) == 0 )
    result = v2;
  if ( ((a1 ^ a2) & 0x80000000) != 0 )
    return v2;
  return result;
}

//----- (0000000000401220) ----------------------------------------------------
__int64 __fastcall sat_adds32b_var3(unsigned int a1, int a2)
{
  __int64 result; // rax
  unsigned int v3; // edi

  result = a2 + a1;
  v3 = (a1 >> 31) + 0x7FFFFFFF;
  if ( (int)(a2 ^ v3 | ~(result ^ a2)) >= 0 )
    return v3;
  return result;
}

//----- (0000000000401240) ----------------------------------------------------
__int64 __fastcall sat_subs32b(unsigned int a1, int a2)
{
  __int64 result; // rax

  result = (a1 >> 31) + 0x7FFFFFFF;
  if ( (int)(((a1 - a2) ^ ((a1 >> 31) + 0x7FFFFFFF)) & (result ^ a2)) >= 0 )
    return a1 - a2;
  return result;
}

//----- (0000000000401260) ----------------------------------------------------
__int64 __fastcall sat_divs32b(int a1, int a2)
{
  return (unsigned int)((a1 + (((a2 + 1) | a1 ^ 0x80000000) == 0)) / a2);
}

//----- (0000000000401280) ----------------------------------------------------
__int64 __fastcall sat_muls32b(int a1, unsigned int a2)
{
  __int64 result; // rax

  result = ((a1 ^ a2) >> 31) + 0x7FFFFFFF;
  if ( (int)(a1 * a2) >> 31 == (unsigned __int64)(a1 * (__int64)(int)a2) >> 32 )
    return a1 * a2;
  return result;
}

//----- (00000000004012B0) ----------------------------------------------------
unsigned __int64 __fastcall sat_adds64b(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax

  result = (a1 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
  if ( ((a2 ^ result | ~((a2 + a1) ^ a2)) & 0x8000000000000000LL) != 0LL )
    return a2 + a1;
  return result;
}

//----- (00000000004012E0) ----------------------------------------------------
unsigned __int64 __fastcall sat_subs64b(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 result; // rax

  result = (a1 >> 63) + 0x7FFFFFFFFFFFFFFFLL;
  if ( (((a1 - a2) ^ result) & (result ^ a2) & 0x8000000000000000LL) == 0LL )
    return a1 - a2;
  return result;
}

//----- (0000000000401310) ----------------------------------------------------
__int64 __fastcall sat_divs64b(__int64 a1, __int64 a2)
{
  signed __int64 v2; // rax

  v2 = a1 + (((a2 + 1) | a1 ^ 0x8000000000000000LL) == 0);
  if ( (a2 | (unsigned __int64)v2) >> 32 )
    return v2 / a2;
  else
    return (unsigned int)v2 / (unsigned int)a2;
}

//----- (0000000000401350) ----------------------------------------------------
__int64 __fastcall sat_muls64b(__int64 a1, unsigned __int64 a2)
{
  __int128 v2; // rax
  __int64 v3; // rcx
  unsigned __int64 v4; // rsi

  v2 = a1 * (__int128)(__int64)a2;
  v3 = (__int64)(a1 * a2) >> 63;
  v4 = (a1 ^ a2) >> 63;
  if ( v3 != *((_QWORD *)&v2 + 1) )
    *(_QWORD *)&v2 = v4 + 0x7FFFFFFFFFFFFFFFLL;
  return v2;
}

//----- (0000000000401380) ----------------------------------------------------
__int64 __fastcall abs32(unsigned int a1)
{
  __int64 result; // rax

  result = -a1;
  if ( (signed int)-a1 < 1 )
    return a1;
  return result;
}

//----- (0000000000401390) ----------------------------------------------------
__int64 __fastcall abs64(__int64 a1)
{
  __int64 result; // rax

  result = -a1;
  if ( -a1 < 1 )
    return a1;
  return result;
}

//----- (00000000004013A0) ----------------------------------------------------
__int64 __fastcall sgn32(int a1)
{
  return (a1 >> 31) + (unsigned int)(a1 > 0);
}

//----- (00000000004013B0) ----------------------------------------------------
__int64 __fastcall sgn64(__int64 a1)
{
  return (a1 >> 63) + (a1 > 0);
}

//----- (00000000004013C0) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ebp
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  __int64 v15; // rbx
  unsigned __int64 v16; // rbp
  unsigned __int64 v17; // rbx
  unsigned __int64 v18; // rbp
  unsigned __int64 v19; // rbx
  unsigned __int64 v20; // rbp
  unsigned __int64 v21; // rbx
  unsigned __int64 v22; // rbp
  unsigned __int64 v23; // rbx

  v3 = sat_addu32b(-1, 3);
  printf("sat_addu32b(0x%08x,0x%08x) = 0x%08x\n", 0xFFFFFFFFLL, 3LL, v3);
  v4 = sat_subu32b(1u, 3u);
  printf("sat_subu32b(0x%08x,0x%08x) = 0x%08x\n", 1LL, 3LL, v4);
  v5 = sat_mulu32b(0xFFFFFFFF, 3u);
  printf("sat_mulu32b(0x%08x,0x%08x) = 0x%08x\n", 0xFFFFFFFFLL, 3LL, v5);
  v6 = sat_divu32b(0xFFFFFFFF, 3u);
  printf("sat_divu32b(0x%08x,0x%08x) = 0x%08x\n", 0xFFFFFFFFLL, 3LL, v6);
  v7 = sat_adds32b_var1(0x7FFFFFFF, 2);
  v8 = sat_adds32b_var2(0x7FFFFFFFu, 2);
  v9 = sat_adds32b_var3(0x7FFFFFFFu, 2);
  printf("sat_adds32b(0x%08x,0x%08x) = 0x%08x 0x%08x 0x%08x\n", 0x7FFFFFFFLL, 2LL, v7, v8, v9);
  v10 = sat_subs32b(0x80000000, 2);
  printf("sat_subs32b(0x%08x,0x%08x) = 0x%08x\n", 0x80000000LL, 2LL, v10);
  v11 = sat_muls32b(0x7FFFFFFF, 2u);
  printf("sat_muls32b(0x%08x,0x%08x) = 0x%08x\n", 0x7FFFFFFFLL, 2LL, v11);
  v12 = sat_divs32b(0x80000000, -1);
  printf("sat_divs32b(0x%08x,0x%08x) = 0x%08x\n", 0x80000000LL, 0xFFFFFFFFLL, v12);
  v13 = abs32(0xFFFFFFF0);
  printf("abs32(0x%08x) = 0x%08x\n", 4294967280LL, v13);
  v14 = sgn32(3);
  printf("sgn32(0x%08x) = 0x%08x\n", 3LL, v14);
  v15 = sat_addu64b(0LL, 0LL);
  v16 = v15 + sat_subu64b(0LL, 0LL);
  v17 = v16 + sat_divu64b(0LL, 1uLL);
  v18 = v17 + sat_mulu64b(0LL, 0LL);
  v19 = v18 + sat_muls64b(0LL, 0LL);
  v20 = v19 + sat_adds64b(0LL, 0LL);
  v21 = v20 + sat_subs64b(0LL, 0LL);
  v22 = v21 + sat_divs64b(0LL, 1LL);
  v23 = v22 + abs64(0LL);
  if ( v23 + sgn64(0LL) == 42 )
    puts("not reached");
  return 0;
}

// nfuncs=40 queued=24 decompiled=24 lumina nreq=0 worse=0 better=0
// ALL OK, 24 function(s) have been successfully decompiled
