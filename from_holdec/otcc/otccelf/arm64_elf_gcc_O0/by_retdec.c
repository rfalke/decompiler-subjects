//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t _24_x(void);
int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int32_t aa(int32_t s, int32_t a);
int32_t ab(int32_t s);
int32_t ac(void);
int32_t ad(int32_t d, int32_t a);
int32_t ae(int32_t s);
int32_t am(void);
int32_t an(void);
int32_t ao(int32_t a);
int32_t ap(int32_t a, uint32_t z);
int32_t aq(int32_t a);
int32_t ar(int32_t s);
int32_t au(int32_t F);
int32_t av(void);
int32_t aw(int32_t d);
int32_t ax(int32_t d);
int32_t B(void);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(int64_t a1);
int32_t E(int32_t a, uint32_t d);
int64_t e843419_40_0008_00000059_8c(void);
int64_t frame_dummy(void);
int64_t function_4184(void);
int64_t * function_d40(int64_t * dest, int64_t * src, int32_t n);
int64_t function_d50(int64_t a1);
int32_t function_d60(struct _IO_FILE * stream);
struct _IO_FILE * function_d70(char * filename, char * modes);
int32_t function_d80(int32_t c);
int32_t function_d90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_da0(struct _IO_FILE * stream);
int64_t * function_db0(int32_t nmemb, int32_t size);
int64_t function_dc0(int64_t a1);
void function_dd0(void);
int32_t function_de0(char * s);
int32_t function_df0(char * nptr, char ** endptr, int32_t base);
int32_t function_e00(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * function_e10(char * haystack, char * needle);
int32_t function_e20(int32_t c);
int64_t function_f70(int64_t a1, int64_t a2);
int32_t H(int32_t a);
int32_t I(int32_t a);
int32_t L(int32_t a);
int32_t M(int32_t a);
int64_t register_tm_clones(int64_t * a1, int64_t a2);
int32_t S(int32_t s);
int32_t w(void);
int32_t W(int32_t s, int32_t a);
int32_t x(int32_t d, int32_t a);
int32_t X(int32_t s);

// --------------------- Global Variables ---------------------

int32_t Q = 0; // 0x150c0
int32_t R = 0; // 0x150a0
int32_t ak = 0; // 0x150ac
int32_t al = 0; // 0x150d4
int64_t g1 = 3904; // 0x14d00
int64_t g2 = 3832; // 0x14d08
int64_t g3 = 0; // 0x14d10
void (*g4)() = (void (*)())0x4200; // 0x14f10
int64_t g5 = 0; // 0x14f18
int32_t g6 = 0x1508c; // 0x14f20
int32_t g7 = 0x15090; // 0x14f28
int32_t * g8 = (int32_t *)0x15094; // 0x14f30
int32_t g9 = 0x15098; // 0x14f38
int32_t g10 = 0; // 0x14f3c
int32_t * g11 = (int32_t *)0x1509c; // 0x14f40
int32_t g12 = 336; // 0x14f41
int64_t g14 = 0; // 0x14f50
char * g15 = "\xa4P\x01"; // 0x14f58
int32_t g16 = 0x150a8; // 0x14f60
int32_t g17 = 336; // 0x14f61
int32_t g18 = 0; // 0x14f64
int64_t g19 = 0; // 0x14f68
int32_t g21 = 336; // 0x14f71
void (*g22)() = (void (*)())0x4188; // 0x14f78
int32_t g23 = 0x150b0; // 0x14f80
int64_t g24; // 0x14f88
int64_t g25; // 0x14f90
int32_t g26 = 0x150bc; // 0x14f98
int32_t g28 = 0x150c4; // 0x14fa8
int32_t g29 = 0; // 0x14fac
int32_t g30 = 0x150c8; // 0x14fb0
int32_t g31 = 336; // 0x14fb1
int32_t g32 = 0; // 0x14fb3
int32_t g33 = 0; // 0x14fb4
int64_t g34 = 0x150cc00; // 0x14fb7
int32_t g35 = 0x150cc; // 0x14fb8
int32_t g36 = 1; // 0x14fba
int32_t g37 = 0; // 0x14fbb
int32_t * g38 = (int32_t *)0x150d000; // 0x14fbf
int32_t g40 = 0; // 0x14fc4
int32_t g41 = 0x2f7c; // 0x14fc8
int32_t g42 = 0; // 0x14fd0
int64_t g44 = 3360; // 0x15000
int64_t g45 = 0; // 0x15088
int64_t g46 = 0; // 0x1508f
int32_t * g47 = (int32_t *)-0x19d9dde42f384870; // 0x250
int32_t g48;
int32_t y = 0; // 0x150d0
int32_t * g13 = &R; // 0x14f48
int32_t * g20 = &ak; // 0x14f70
int32_t * g27 = &Q; // 0x14fa0
int32_t * g39 = &y; // 0x14fc0
int32_t * g43 = &al; // 0x14fe0

// ------------------------ Functions -------------------------

// Address range: 0xd08 - 0xd1c
int64_t _init(int64_t a1) {
    // 0xd08
    return call_weak_fn();
}

// Address range: 0xd40 - 0xd50
int64_t * function_d40(int64_t * dest, int64_t * src, int32_t n) {
    // 0xd40
    return memcpy(dest, src, n);
}

// Address range: 0xd50 - 0xd60
int64_t function_d50(int64_t a1) {
    // 0xd50
    return __cxa_finalize();
}

// Address range: 0xd60 - 0xd70
int32_t function_d60(struct _IO_FILE * stream) {
    // 0xd60
    return fclose(stream);
}

// Address range: 0xd70 - 0xd80
struct _IO_FILE * function_d70(char * filename, char * modes) {
    // 0xd70
    return fopen(filename, modes);
}

// Address range: 0xd80 - 0xd90
int32_t function_d80(int32_t c) {
    // 0xd80
    return isspace(c);
}

// Address range: 0xd90 - 0xda0
int32_t function_d90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xd90
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xda0 - 0xdb0
int32_t function_da0(struct _IO_FILE * stream) {
    // 0xda0
    return fgetc(stream);
}

// Address range: 0xdb0 - 0xdc0
int64_t * function_db0(int32_t nmemb, int32_t size) {
    // 0xdb0
    return calloc(nmemb, size);
}

// Address range: 0xdc0 - 0xdd0
int64_t function_dc0(int64_t a1) {
    // 0xdc0
    return __gmon_start__();
}

// Address range: 0xdd0 - 0xde0
void function_dd0(void) {
    // 0xdd0
    abort();
}

// Address range: 0xde0 - 0xdf0
int32_t function_de0(char * s) {
    // 0xde0
    return puts(s);
}

// Address range: 0xdf0 - 0xe00
int32_t function_df0(char * nptr, char ** endptr, int32_t base) {
    // 0xdf0
    return strtol(nptr, endptr, base);
}

// Address range: 0xe00 - 0xe10
int32_t function_e00(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0xe00
    return fwrite(ptr, size, n, s);
}

// Address range: 0xe10 - 0xe20
char * function_e10(char * haystack, char * needle) {
    // 0xe10
    return strstr(haystack, needle);
}

// Address range: 0xe20 - 0xe30
int32_t function_e20(int32_t c) {
    // 0xe20
    return isalnum(c);
}

// Address range: 0xe30 - 0xe68
int64_t _start(int64_t a1) {
    // 0xe30
    int64_t v1; // 0xe30
    int64_t v2; // 0xe30
    __libc_start_main((int64_t)g41, (int32_t)a1, (char **)&v1, g22, g4, (void (*)())v2);
    abort();
    return &g48;
}

// Address range: 0xe68 - 0xe7c
int64_t call_weak_fn(void) {
    // 0xe68
    if (g19 == 0) {
        // 0xe78
        return 0;
    }
    // 0xe74
    return function_dc0(g19);
}

// Address range: 0xe80 - 0xeb4
int64_t deregister_tm_clones(int64_t a1) {
    if ((int64_t)&g46 - (int64_t)&g45 == 14 || (uint64_t)((int64_t)&g46 - (int64_t)&g45) < 14 || g5 == 0) {
        // 0xeb0
        return &g45;
    }
    // 0xeac
    return _ITM_deregisterTMCloneTable(&g45, g5);
}

// Address range: 0xeb8 - 0xef4
int64_t register_tm_clones(int64_t * a1, int64_t a2) {
    // 0xeb8
    return &g45;
}

// Address range: 0xef8 - 0xf40
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g45; // 0xf08
    if (result != 0) {
        // 0xf34
        return result;
    }
    int64_t v1 = 0; // 0xf18
    if (g14 != 0) {
        // 0xf1c
        v1 = function_d50(*(int64_t *)((int64_t)&g44 + 128));
    }
    // 0xf28
    deregister_tm_clones(v1);
    *(char *)&g45 = 1;
    // 0xf34
    return 1;
}

// Address range: 0xf40 - 0xf70
int64_t frame_dummy(void) {
    // 0xf40
    if (g3 == 0 || g42 == 0) {
        // 0xf50
        return register_tm_clones(&g3, 0);
    }
    // 0xf64
    return _Jv_RegisterClasses(&g3, (int64_t)g42);
}

// Address range: 0xf70 - 0xf78
int64_t function_f70(int64_t a1, int64_t a2) {
    // 0xf70
    int64_t v1; // 0xf70
    return register_tm_clones((int64_t *)v1, v1);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0xf78 - 0xfb8
// Line range:    20 - 22
int32_t L(int32_t a) {
    int32_t result = *(int32_t *)*(int64_t *)0x14f20; // 0xf88
    *(int32_t *)(int64_t)g6 = result + 1;
    *(char *)(int64_t)result = (char)a;
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0xfb8 - 0x1074
// Line range:    23 - 32
// Demangled:     wchar_t
int32_t w(void) {
    // 0xfb8
    if (*(int32_t *)*(int64_t *)0x14f40 == 0) {
        int32_t c = fgetc((struct _IO_FILE *)(int64_t)*(int32_t *)&g20); // 0x1054
        *(int32_t *)(int64_t)g35 = c;
        // 0x1068
        return g35;
    }
    // 0xfd4
    *g11 = (int32_t)&g12;
    *(int32_t *)*(int64_t *)0x14fb8 = (int32_t)*(char *)&g11;
    if (g35 == 2) {
        // 0x101c
        *g11 = 0;
        *(int32_t *)(int64_t)g35 = *(int32_t *)&g43;
    }
    // 0x1068
    return g35;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1074 - 0x10b4
// Line range:    33 - 35
int32_t am(void) {
    // 0x1074
    return isalnum(g35) | (int32_t)(g35 == 95);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x10b4 - 0x1104
// Line range:    36 - 41
int32_t an(void) {
    // 0x10b4
    if (g35 != 92) {
        // 0x10f8
        return g35;
    }
    // 0x10d0
    w();
    int32_t result = g35; // 0x10e4
    if (g35 == 110) {
        // 0x10e8
        *(int32_t *)110 = 10;
        result = 110;
    }
    // 0x10f8
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1104 - 0x1684
// Line range:    42 - 127
int32_t av(void) {
    // 0x1104
    if ((isspace(g35) || (int32_t)(g35 == 35)) != 0) {
        if (g35 == 35) {
            // 0x1124
            w();
            av();
            if (*(int32_t *)*(int64_t *)0x14fa8 == (int32_t)".1") {
                // 0x1140
                av();
                L(32);
                *(int32_t *)(int64_t)g28 = 1;
                *(int32_t *)(int64_t)(int32_t)&g29 = g6;
            }
            // 0x11a8
            L(g35);
            if (g35 != 10) {
                w();
                L(g35);
                while (g35 != 10) {
                    // 0x1194
                    w();
                    L(g35);
                }
            }
            // 0x11bc
            L(2);
        }
        // 0x11d4
        w();
        bool v1 = g35 == 35; // 0x120c
        while ((isspace(g35) || (int32_t)(g35 == 35)) != 0) {
            // 0x1110
            if (v1) {
                // 0x1124
                w();
                av();
                if (*(int32_t *)*(int64_t *)0x14fa8 == (int32_t)".1") {
                    // 0x1140
                    av();
                    L(32);
                    *(int32_t *)(int64_t)g28 = 1;
                    *(int32_t *)(int64_t)(int32_t)&g29 = g6;
                }
                // 0x11a8
                L(g35);
                if (g35 != 10) {
                    w();
                    L(g35);
                    while (g35 != 10) {
                        // 0x1194
                        w();
                        L(g35);
                    }
                }
                // 0x11bc
                L(2);
            }
            // 0x11d4
            w();
            v1 = g35 == 35;
        }
    }
    // 0x1210
    *(int32_t *)*(int64_t *)0x14f28 = 0;
    *(int32_t *)(int64_t)g28 = g35;
    int32_t result2; // 0x1104
    if (am() != 0) {
        // 0x1240
        L(32);
        *(int32_t *)*(int64_t *)0x14f58 = g6;
        if (am() != 0) {
            L(g35);
            w();
            while (am() != 0) {
                // 0x1264
                L(g35);
                w();
            }
        }
        int32_t v2 = g28; // 0x128c
        if (v2 >= 57 != v2 != 57) {
            int32_t str_as_l = strtol((char *)(int64_t)*(int32_t *)&g15, NULL, 0); // 0x12b0
            *(int32_t *)*(int64_t *)0x14f80 = str_as_l;
            *(int32_t *)(int64_t)g28 = 2;
            // 0x1678
            return g28;
        }
        // 0x12d8
        *(char *)(int64_t)g6 = 32;
        int32_t str = *(int32_t *)&g27; // 0x12fc
        int32_t v3 = *(int32_t *)&g15; // 0x1310
        char * substr_pos = strstr((char *)(int64_t)str, (char *)(int64_t)(v3 - 1)); // 0x1324
        int32_t v4 = *(int32_t *)&g27; // 0x1334
        *(int32_t *)(int64_t)g28 = (int32_t)(int64_t)substr_pos - v4;
        *(char *)(int64_t)g6 = 0;
        *(int32_t *)(int64_t)g28 = 8 * (int32_t)&g41;
        int32_t result = g28; // 0x1390
        if (result <= (int32_t)".1") {
            // 0x1678
            return result;
        }
        int32_t v5 = *(int32_t *)*(int64_t *)0x14f30; // 0x13a4
        *(int32_t *)(int64_t)result = v5 + result;
        result2 = g28;
        if (g28 == 1) {
            // 0x13e0
            *g11 = g29;
            *g43 = g35;
            w();
            result2 = av();
        }
        // 0x1678
        return result2;
    }
    // 0x1428
    w();
    if (g28 == 39) {
        // 0x1440
        *(int32_t *)39 = 2;
        an();
        *(int32_t *)(int64_t)g23 = g35;
        w();
        // 0x1678
        return w();
    }
    char * v6 = (char *)(int32_t)"++#m--%am*@R<^1c/@%[_[H3c%@%[_[H3c+@.B#d-@%:_^BKd<<Z/03e>>`/03e<=0f>=/f<@.f>@1f==&g!='g&&k||#l&@.BCh^@.BSi|@.B+j~@/%Yd!@&d*@b"; // 0x14b4
    if (g28 == 47 == g35 == 42) {
        // 0x14b8
        w();
        while (true) {
            // 0x14fc
            if (g35 == 0) {
                // break (via goto) -> 0x1510
                goto lab_0x1510;
            }
            int32_t v7 = g35; // 0x14cc
            w();
            while (v7 != 42) {
                // 0x14c4
                v7 = g35;
                w();
            }
            int32_t v8 = g35; // 0x14ec
            while (g35 != 47) {
                // 0x14fc
                if (v8 == 0) {
                    // break (via goto) -> 0x1510
                    goto lab_0x1510;
                }
                v7 = v8;
                w();
                while (v7 != 42) {
                    // 0x14c4
                    v7 = g35;
                    w();
                }
                // 0x14d8
                v8 = g35;
            }
            // 0x14f0
            *(int32_t *)47 = 0;
        }
      lab_0x1510:
        // 0x1510
        w();
        // 0x1678
        return av();
    }
    unsigned char v9 = *v6; // 0x165c
    result2 = 0;
    while (v9 != 0) {
        int64_t v10 = (int64_t)v6;
        unsigned char v11 = *(char *)(v10 + 1 & 0xffffffff); // 0x153c
        *(int32_t *)(int64_t)g23 = 0;
        char * v12 = (char *)(v10 + 3 & 0xffffffff); // 0x158c
        unsigned char v13 = *(char *)(v10 + 2 & 0xffffffff); // 0x1594
        *(int32_t *)(int64_t)g7 = (int32_t)v13 - 98;
        char * v14 = v12; // 0x15b8
        v6 = v12;
        if (g7 < 0) {
            int32_t v15 = g23;
            *(int32_t *)(int64_t)v15 = g7 + 64 + 64 * v15;
            char * v16 = (char *)((int64_t)v14 + 1 & 0xffffffff);
            *(int32_t *)(int64_t)g7 = (int32_t)*v14 - 98;
            v14 = v16;
            v6 = v16;
            while (g7 < 0) {
                // 0x1554
                v15 = g23;
                *(int32_t *)(int64_t)v15 = g7 + 64 + 64 * v15;
                v16 = (char *)((int64_t)v14 + 1 & 0xffffffff);
                *(int32_t *)(int64_t)g7 = (int32_t)*v14 - 98;
                v14 = v16;
                v6 = v16;
            }
        }
        // 0x15bc
        if (g28 == (int32_t)v9 == (v11 == 64 || g35 == (int32_t)v11)) {
            // 0x161c
            result2 = g35;
            if (g35 == (int32_t)v11) {
                // 0x1634
                w();
                *(int32_t *)(int64_t)g28 = 1;
                result2 = g28;
                return result2;
            } else {
                return result2;
            }
        }
        v9 = *v6;
        result2 = 0;
    }
  lab_0x1678:
    // 0x1678
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1684 - 0x16ec
// Line range:    128 - 133
int32_t aw(int32_t d) {
    int32_t v1 = d; // 0x168c
    int32_t result; // 0x1684
    while (true) {
        // 0x16c8
        result = v1;
        switch (result) {
            case 0: {
            }
            case -1: {
                // 0x16e0
                return result;
            }
        }
        // 0x1690
        *(int32_t *)(int64_t)g16 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)result;
        v1 = result / 256;
    }
    // 0x16e0
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x16ec - 0x178c
// Line range:    134 - 139
int32_t E(int32_t a, uint32_t d) {
    // 0x16ec
    *(char *)(int64_t)a = (char)d;
    *(char *)(int64_t)(a + 1) = (char)(d / 256);
    *(char *)(int64_t)(a + 2) = (char)(d / 0x10000);
    uint32_t result = d / 0x1000000;
    *(char *)(int64_t)(a + 3) = (char)result;
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x178c - 0x17f0
// Line range:    140 - 143
int32_t ao(int32_t a) {
    unsigned char v1 = *(char *)(int64_t)(a + 1); // 0x17ac
    unsigned char v2 = *(char *)(int64_t)(a + 2); // 0x17c4
    unsigned char v3 = *(char *)(int64_t)(a + 3); // 0x17dc
    int64_t v4; // 0x178c
    return 256 * (int32_t)v1 | (int32_t)v4 % 256 | 0x10000 * (int32_t)v2 | 0x1000000 * (int32_t)v3;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x17f0 - 0x18fc
// Line range:    144 - 157
int32_t ap(int32_t a, uint32_t z) {
    if (a == 0) {
        // 0x18f0
        return 0;
    }
    int32_t v1 = a;
    int32_t v2 = ao(v1); // 0x1808
    int32_t v3; // 0x18a8
    int32_t v4; // 0x1884
    if (*(char *)(int64_t)(v1 - 1) == 5) {
        // 0x1828
        if (*(int32_t *)*(int64_t *)0x14f88 <= z == g30 > z) {
            // 0x1858
            E(v1, *(int32_t *)&g39 + z);
        } else {
            // 0x187c
            v4 = *(int32_t *)*(int64_t *)0x14f90;
            v3 = *(int32_t *)&g39;
            E(v1, z - v4 + *(int32_t *)&g13 + v3);
        }
    } else {
        // 0x18c0
        E(v1, (int32_t)(z - 4) - v1);
    }
    while (v2 != 0) {
        // 0x1804
        v1 = v2;
        v2 = ao(v1);
        if (*(char *)(int64_t)(v1 - 1) == 5) {
            // 0x1828
            if (*(int32_t *)*(int64_t *)0x14f88 <= z == g30 > z) {
                // 0x1858
                E(v1, *(int32_t *)&g39 + z);
            } else {
                // 0x187c
                v4 = *(int32_t *)*(int64_t *)0x14f90;
                v3 = *(int32_t *)&g39;
                E(v1, z - v4 + *(int32_t *)&g13 + v3);
            }
        } else {
            // 0x18c0
            E(v1, (int32_t)(z - 4) - v1);
        }
    }
    // 0x18f0
    return 0;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x18fc - 0x192c
// Line range:    158 - 160
int32_t H(int32_t a) {
    // 0x18fc
    return ap(a, g16);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x192c - 0x1990
// Line range:    161 - 167
// Demangled:     long long
int32_t x(int32_t d, int32_t a) {
    // 0x192c
    aw(d);
    E(g16, a);
    *(int32_t *)(int64_t)g16 = (int32_t)&g18;
    return g16;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1990 - 0x19b4
// Line range:    168 - 170
int32_t M(int32_t a) {
    // 0x1990
    return x(184, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x19b4 - 0x19d4
// Line range:    171 - 173
int32_t I(int32_t a) {
    // 0x19b4
    return x(233, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x19d4 - 0x1a08
// Line range:    174 - 177
int32_t aa(int32_t s, int32_t a) {
    // 0x19d4
    aw(0xfc085);
    return x(s + 132, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1a08 - 0x1a4c
// Line range:    178 - 184
int32_t aq(int32_t a) {
    // 0x1a08
    aw(0xc139);
    M(0);
    aw(15);
    aw(a + 144);
    return aw(192);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1a4c - 0x1adc
// Line range:    185 - 194
int32_t W(int32_t s, int32_t a) {
    // 0x1a4c
    aw(s + 131);
    int64_t v1; // 0x1a4c
    int32_t v2 = v1;
    int32_t result; // 0x1a4c
    if (v2 == 0 || v2 > 511) {
        int32_t * v3 = (int32_t *)(int64_t)(a + 4); // 0x1ab8
        int32_t v4 = x(5, *v3); // 0x1ac4
        *v3 = v4;
        result = v4;
    } else {
        // 0x1a90
        result = x(133, v2);
    }
    // 0x1acc
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1adc - 0x1f44
// Line range:    195 - 299
int32_t ab(int32_t s) {
    // 0x1adc
    int32_t v1; // 0x1adc
    int32_t v2; // 0x1adc
    int32_t v3; // 0x1adc
    int32_t v4; // 0x1adc
    int32_t v5; // 0x1adc
    if (g28 == 34) {
        // 0x1b08
        M(*(int32_t *)&g39 + g30);
        if (g35 != 34) {
            an();
            *(int32_t *)(int64_t)g30 = (int32_t)&g31;
            *(char *)(int64_t)g30 = (char)g35;
            w();
            while (g35 != 34) {
                // 0x1b2c
                an();
                *(int32_t *)(int64_t)g30 = (int32_t)&g31;
                *(char *)(int64_t)g30 = (char)g35;
                w();
            }
        }
        // 0x1b80
        *(char *)(int64_t)g30 = 0;
        *(int32_t *)(int64_t)g30 = (int32_t)&g33;
        w();
        av();
        v4 = 1;
        goto lab_0x1e24;
    } else {
        // 0x1bc0
        av();
        if (g28 == 2) {
            // 0x1c00
            M(g23);
            v4 = 1;
            v2 = 2;
            goto lab_0x1e24;
        } else {
            if (g7 == 2) {
                // 0x1c18
                ab(0);
                x(185, 0);
                if (g28 == 33) {
                    // 0x1c38
                    aq(g23);
                    v4 = 1;
                    v2 = 33;
                } else {
                    // 0x1c44
                    aw(g23);
                    v4 = 1;
                    v2 = g28;
                }
                goto lab_0x1e24;
            } else {
                switch (g28) {
                    case 40: {
                        // 0x1c5c
                        B();
                        av();
                        v4 = 1;
                        v2 = 40;
                        goto lab_0x1e24;
                    }
                    case 42: {
                        // 0x1c74
                        av();
                        av();
                        av();
                        v1 = g28;
                        if (g28 == 42) {
                            // 0x1ca4
                            av();
                            av();
                            av();
                            av();
                            v1 = 0;
                        }
                        // 0x1cb8
                        av();
                        ab(0);
                        if (g28 == 61) {
                            // 0x1cd8
                            av();
                            aw(80);
                            B();
                            aw(89);
                            aw(v1 == 256 ? 393 : 392);
                            v4 = 1;
                            v2 = v1;
                            goto lab_0x1e24;
                        } else {
                            // 0x1d10
                            v5 = 1;
                            v3 = 0;
                            switch (v1) {
                                case 0: {
                                    goto lab_0x1e24_2;
                                }
                                case 256: {
                                    // 0x1d28
                                    aw(139);
                                    goto lab_0x1d3c;
                                }
                                default: {
                                    // 0x1d34
                                    aw(0xbe0f);
                                    goto lab_0x1d3c;
                                }
                            }
                        }
                    }
                    case 38: {
                        // 0x1d68
                        W(10, g28);
                        av();
                        v4 = 1;
                        v2 = 38;
                        goto lab_0x1e24;
                    }
                    default: {
                        // 0x1d88
                        if (((int32_t)(g28 == 61) & s) == 0) {
                            // 0x1dd0
                            v4 = 0;
                            v2 = g28;
                            if (g28 != 40) {
                                // 0x1de4
                                W(8, g28);
                                v4 = 0;
                                v2 = g28;
                                if (g7 == 11) {
                                    // 0x1e04
                                    W(0, g28);
                                    aw(g23);
                                    av();
                                    v4 = 0;
                                    v2 = g28;
                                }
                            }
                        } else {
                            // 0x1db8
                            av();
                            B();
                            W(6, g28);
                            v4 = 0;
                            v2 = g28;
                        }
                        goto lab_0x1e24;
                    }
                }
            }
        }
    }
  lab_0x1e24:
    // 0x1e24
    v5 = v4;
    v3 = v2;
    goto lab_0x1e24_2;
  lab_0x1e24_2:
    // 0x1e24
    if (g28 != 40) {
        // 0x1f34
        return g28;
    }
    // 0x1e38
    if (v5 != 0) {
        // 0x1e44
        aw(80);
    }
    int32_t v6 = x(0xec81, 0); // 0x1e54
    av();
    int32_t v7 = 0; // 0x1eb0
    int32_t v8 = 0; // 0x1eb0
    if (g28 != 41) {
        B();
        x(0x248489, v7);
        if (g28 == 44) {
            // 0x1e90
            av();
        }
        int32_t v9 = v7 + 4; // 0x1e98
        v7 = v9;
        v8 = v9;
        while (g28 != 41) {
            // 0x1e68
            B();
            x(0x248489, v7);
            if (g28 == 44) {
                // 0x1e90
                av();
            }
            // 0x1e94
            v9 = v7 + 4;
            v7 = v9;
            v8 = v9;
        }
    }
    // 0x1eb4
    E(v6, v8);
    av();
    int32_t v10; // 0x1adc
    if (v5 == 0) {
        int32_t * v11 = (int32_t *)(int64_t)(v3 + 4); // 0x1f08
        *v11 = x(232, *v11);
        v10 = v8;
    } else {
        // 0x1ed0
        x(0x2494ff, v8);
        v10 = v8 + 4;
    }
    // 0x1f1c
    if (v10 == 0) {
        // 0x1f34
        return 0;
    }
    // 0x1f34
    return x(0xc481, v10);
  lab_0x1d3c:
    // 0x1d3c
    *(int32_t *)(int64_t)g16 = (int32_t)&g17;
    v4 = 1;
    v2 = v1;
    goto lab_0x1e24;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1f44 - 0x20ac
// Line range:    300 - 335
int32_t X(int32_t s) {
    if (s == 1) {
        // 0x20a0
        return ab(1);
    }
    uint32_t v1 = s - 1; // 0x1f54
    X(v1);
    if (v1 != g7) {
        // 0x20a0
        return 0;
    }
    int32_t v2 = 0;
    av();
    int32_t result; // 0x1f44
    while (v1 < 9) {
        // 0x1fcc
        aw(80);
        X(v1);
        aw(89);
        if ((v1 || 1) != 5) {
            // 0x2020
            aw(g23);
            if (g28 == 37) {
                // 0x2034
                aw(146);
            }
        } else {
            // 0x2014
            aq(g23);
        }
        // 0x203c
        if (v1 != g7) {
            // 0x2054
            result = v2 == 0 ? 0 : v1;
            return result;
        }
        av();
    }
    int32_t v3 = aa(g23, v2); // 0x1fb8
    X(v1);
    while (v1 == g7) {
        // 0x1f80
        v2 = v3;
        av();
        while (v1 < 9) {
            // 0x1fcc
            aw(80);
            X(v1);
            aw(89);
            if ((v1 || 1) != 5) {
                // 0x2020
                aw(g23);
                if (g28 == 37) {
                    // 0x2034
                    aw(146);
                }
            } else {
                // 0x2014
                aq(g23);
            }
            // 0x203c
            if (v1 != g7) {
                // 0x2054
                result = v2 == 0 ? 0 : v1;
                return result;
            }
            av();
        }
        // 0x1fb0
        v3 = aa(g23, v2);
        X(v1);
    }
    // 0x2054
    result = 0;
    if (v3 != 0) {
        int32_t v4 = aa(g23, v3); // 0x2074
        M(g23 ^ 1);
        I(5);
        H(v4);
        result = M(g23);
    }
  lab_0x20a0:
    // 0x20a0
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x20ac - 0x20c8
// Line range:    336 - 338
int32_t B(void) {
    // 0x20ac
    return X(11);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x20c8 - 0x20e8
// Line range:    339 - 342
int32_t ac(void) {
    // 0x20c8
    B();
    return aa(0, 0);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x20e8 - 0x23c8
// Line range:    343 - 409
int32_t S(int32_t s) {
    int32_t v1 = g28; // 0x2100
    int32_t d; // bp-4, 0x20e8
    if (v1 == 288) {
        // 0x210c
        av();
        av();
        d = ac();
        av();
        S(s);
        int32_t result; // 0x20e8
        if (g28 == 312) {
            // 0x213c
            av();
            int32_t v2 = I(0); // 0x2144
            H(d);
            S(s);
            result = H(v2);
        } else {
            // 0x2168
            result = H(d);
        }
        // 0x23b8
        return result;
    }
    if (v1 != 352 && v1 != 504) {
        switch (v1) {
            case 123: {
                // 0x22e0
                av();
                ar(1);
                if (g28 != 125) {
                    S(s);
                    while (g28 != 125) {
                        // 0x22f0
                        S(s);
                    }
                }
                // break -> 0x230c
                break;
            }
            case 448: {
                // 0x2328
                av();
                if (g28 != 59) {
                    // 0x2340
                    B();
                }
                int32_t v3 = I(g26); // 0x2350
                *(int32_t *)(int64_t)g26 = v3;
                // 0x23b8
                return av();
            }
            case 400: {
                // 0x237c
                av();
                int64_t v4; // 0x20e8
                *(int32_t *)(int64_t)s = I((int32_t)v4);
                // 0x23b8
                return av();
            }
            case 59: {
                // 0x23b8
                return av();
            }
            default: {
                // 0x23b0
                B();
                // 0x23b8
                return av();
            }
        }
        // 0x23b8
        return av();
    }
    // 0x21b4
    av();
    av();
    int32_t v5; // 0x20e8
    if (v1 == 352) {
        // 0x21d8
        d = ac();
        v5 = g16;
    } else {
        // 0x21f4
        if (g28 != 59) {
            // 0x2208
            B();
        }
        // 0x220c
        av();
        d = 0;
        if (g28 != 59) {
            // 0x2238
            d = ac();
        }
        // 0x2240
        av();
        v5 = g16;
        if (g28 != 41) {
            int32_t v6 = I(0); // 0x225c
            B();
            I(g16 - 5 - g16);
            H(v6);
            v5 = v6 + 4;
        }
    }
    // 0x2298
    av();
    S((int32_t)(int64_t)&d);
    I(v5 - 5 - g16);
    // 0x23b8
    return H(d);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x23c8 - 0x2630
// Line range:    410 - 450
int32_t ar(int32_t s) {
    int32_t v1 = g28;
    if (v1 != 256 && s == 0 != v1 != -1) {
        // 0x2624
        return 0;
    }
    int32_t v2; // 0x23c8
    int32_t v3; // 0x23c8
    int32_t v4; // 0x258c
    int32_t v5; // 0x2518
    if (v1 == 256) {
        // 0x23ec
        av();
        while (true) {
            if (g28 == 59) {
                // break (via goto) -> 0x24b8
                goto lab_0x24b8;
            }
            if (s == 0) {
                // 0x2448
                *(int32_t *)(int64_t)g28 = g30;
                *(int32_t *)(int64_t)g30 = (int32_t)&g33;
            } else {
                // 0x2400
                *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                *(int32_t *)(int64_t)g28 = -g9;
            }
            // 0x2488
            av();
            // 0x24a4
            while (g28 != 44) {
                // 0x24a4
                if (g28 == 59) {
                    // break (via goto) -> 0x24b8
                    goto lab_0x24b8;
                }
                if (s == 0) {
                    // 0x2448
                    *(int32_t *)(int64_t)g28 = g30;
                    *(int32_t *)(int64_t)g30 = (int32_t)&g33;
                } else {
                    // 0x2400
                    *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                    *(int32_t *)(int64_t)g28 = -g9;
                }
                // 0x2488
                av();
            }
            // 0x24a0
            av();
        }
        // 0x24b8
        av();
    } else {
        // 0x24c0
        *(int32_t *)(int64_t)v1 = g16;
        av();
        av();
        v2 = 8;
        while (true) {
            // 0x253c
            if (g28 == 41) {
                // break (via goto) -> 0x2550
                goto lab_0x2550;
            }
            // 0x24f8
            *(int32_t *)(int64_t)g28 = v2;
            v5 = v2 + 4;
            av();
            v3 = v5;
            while (g28 != 44) {
                // 0x253c
                if (g28 == 41) {
                    // break (via goto) -> 0x2550
                    goto lab_0x2550;
                }
                // 0x24f8
                *(int32_t *)(int64_t)g28 = v3;
                v5 = v3 + 4;
                av();
                v3 = v5;
            }
            // 0x2538
            av();
            v2 = v5;
        }
        // 0x2550
        av();
        *(int32_t *)(int64_t)g9 = 0;
        *(int32_t *)(int64_t)g26 = g9;
        aw(0xe58955);
        v4 = x(0xec81, 0);
        S(0);
        H(g26);
        aw(0xc3c9);
        E(v4, g9);
    }
    int32_t v6 = g28;
    bool v7 = v6 == 256; // 0x2620
    int32_t v8 = v6; // 0x2620
    while (v6 == 256 || s == 0 == (v6 != -1)) {
        // 0x23d8
        if (v7) {
            // 0x23ec
            av();
            while (true) {
                if (g28 == 59) {
                    // break (via goto) -> 0x24b8
                    goto lab_0x24b8;
                }
                if (s == 0) {
                    // 0x2448
                    *(int32_t *)(int64_t)g28 = g30;
                    *(int32_t *)(int64_t)g30 = (int32_t)&g33;
                } else {
                    // 0x2400
                    *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                    *(int32_t *)(int64_t)g28 = -g9;
                }
                // 0x2488
                av();
                // 0x24a4
                while (g28 != 44) {
                    // 0x24a4
                    if (g28 == 59) {
                        // break (via goto) -> 0x24b8
                        goto lab_0x24b8;
                    }
                    if (s == 0) {
                        // 0x2448
                        *(int32_t *)(int64_t)g28 = g30;
                        *(int32_t *)(int64_t)g30 = (int32_t)&g33;
                    } else {
                        // 0x2400
                        *(int32_t *)(int64_t)g9 = (int32_t)&g10;
                        *(int32_t *)(int64_t)g28 = -g9;
                    }
                    // 0x2488
                    av();
                }
                // 0x24a0
                av();
            }
            // 0x24b8
            av();
        } else {
            // 0x24c0
            *(int32_t *)(int64_t)v8 = g16;
            av();
            av();
            v2 = 8;
            while (true) {
                // 0x253c
                v3 = v2;
                if (g28 == 41) {
                    // break (via goto) -> 0x2550
                    goto lab_0x2550;
                }
                // 0x24f8
                *(int32_t *)(int64_t)g28 = v3;
                v5 = v3 + 4;
                av();
                v3 = v5;
                while (g28 != 44) {
                    // 0x253c
                    if (g28 == 41) {
                        // break (via goto) -> 0x2550
                        goto lab_0x2550;
                    }
                    // 0x24f8
                    *(int32_t *)(int64_t)g28 = v3;
                    v5 = v3 + 4;
                    av();
                    v3 = v5;
                }
                // 0x2538
                av();
                v2 = v5;
            }
            // 0x2550
            av();
            *(int32_t *)(int64_t)g9 = 0;
            *(int32_t *)(int64_t)g26 = g9;
            aw(0xe58955);
            v4 = x(0xec81, 0);
            S(0);
            H(g26);
            aw(0xc3c9);
            E(v4, g9);
        }
        // 0x25cc
        v6 = g28;
        v7 = v6 == 256;
        v8 = v6;
    }
    // 0x2624
    return 0;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2630 - 0x2678
// Line range:    451 - 454
int32_t ax(int32_t d) {
    // 0x2630
    E(g30, d);
    *(int32_t *)(int64_t)g30 = (int32_t)&g33;
    return g30;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2678 - 0x26d0
// Line range:    455 - 462
int32_t ad(int32_t d, int32_t a) {
    // 0x2678
    ax(d);
    int32_t v1 = d + 0x8048000; // 0x269c
    ax(v1);
    ax(v1);
    ax(a);
    return ax(a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x26d0 - 0x2998
// Line range:    463 - 505
int32_t ae(int32_t s) {
    char * v1 = (char *)(int64_t)*(int32_t *)&g27; // 0x26ec
    while (true) {
        int32_t v2 = (int64_t)v1; // 0x26f0
        uint32_t v3 = v2 + 1; // 0x26f4
        int64_t v4 = v3;
        char * v5 = (char *)v4;
        int64_t v6 = v4; // 0x2720
        v1 = v5;
        char * v7; // 0x26d0
        int64_t v8; // 0x26d0
        int64_t v9; // 0x26d0
        if (*v5 != 32) {
            // 0x2724
            v8 = v4;
            v6 = v4;
            v1 = v5;
            if (v3 < g6) {
                v9 = v8 + 1 & 0xffffffff;
                v7 = (char *)v9;
                v8 = v9;
                v6 = v9;
                v1 = v7;
                while (*v7 != 32 == v9 < (int64_t)g6) {
                    // 0x2708
                    v9 = v8 + 1 & 0xffffffff;
                    v7 = (char *)v9;
                    v8 = v9;
                    v6 = v9;
                    v1 = v7;
                }
            }
        }
        int32_t v10 = v6;
        while (g6 != v10) {
            int32_t v11 = *(int32_t *)&g27; // 0x275c
            int32_t v12 = *(int32_t *)&g8; // 0x2774
            *(int32_t *)(int64_t)g28 = v12 + 248 + 8 * (v3 - v11);
            if (g28 != 1 && g29 != 0) {
                if (g28 == 0) {
                    if (s != 0) {
                        // break -> 0x285c
                        break;
                    }
                    // 0x27f0
                    memcpy((int64_t *)(int64_t)g30, (int64_t *)(int64_t)v3, v10 - v3);
                    uint32_t v13 = g30; // 0x2834
                    *(int32_t *)(int64_t)v13 = v10 - v2 + v13;
                } else {
                    if (s == 0) {
                        // 0x2978
                        ap(g29, g28);
                    }
                }
            }
            v2 = (int64_t)v1;
            v3 = v2 + 1;
            v4 = v3;
            v5 = (char *)v4;
            v6 = v4;
            v1 = v5;
            if (*v5 != 32) {
                // 0x2724
                v8 = v4;
                v6 = v4;
                v1 = v5;
                if (v3 < g6) {
                    v9 = v8 + 1 & 0xffffffff;
                    v7 = (char *)v9;
                    v8 = v9;
                    v6 = v9;
                    v1 = v7;
                    while (*v7 != 32 == v9 < (int64_t)g6) {
                        // 0x2708
                        v9 = v8 + 1 & 0xffffffff;
                        v7 = (char *)v9;
                        v8 = v9;
                        v6 = v9;
                        v1 = v7;
                    }
                }
            }
            // 0x273c
            v10 = v6;
        }
        return g6;
    }
    // 0x2988
    uint32_t result; // 0x26d0
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2998 - 0x2f7c
// Line range:    506 - 595
int32_t au(int32_t F) {
    // 0x2998
    *g13 = g30;
    int32_t v1 = *(int32_t *)&g25;
    int32_t v2 = g16 - v1; // 0x29d4
    *(int32_t *)(int64_t)g16 = v1;
    aw(0x505458);
    int32_t v3 = *(int32_t *)&g8; // 0x2a08
    int32_t v4 = *(int32_t *)(int64_t)(v3 + (int32_t)&g47); // 0x2a14
    x(232, v4 - 5 - g16);
    aw(0xc389);
    M(1);
    aw(0x80cd);
    uint32_t v5 = g30;
    *(int32_t *)(int64_t)v5 = v5 + v2;
    *(int32_t *)(int64_t)g30 = (int32_t)&g31;
    *(int64_t *)(int64_t)g30 = 0x2e6f732e6362696c;
    *(int16_t *)&g35 = 54;
    *(int32_t *)(int64_t)g30 = (int32_t)&g36;
    *(int64_t *)(int64_t)g30 = 0x6f732e6c6462696c;
    *(int32_t *)&g34 = 0x322e6f;
    *(int32_t *)(int64_t)g30 = (int32_t)&g37;
    ae(0);
    *(int32_t *)(int64_t)g30 = (int32_t)&g32;
    ax(0);
    ax(0);
    ax(0);
    ax(0);
    ae(1);
    int32_t v6 = 0; // 0x2bdc
    ax(1);
    ax(v6);
    ax(1);
    ax(0);
    if (v6 > 2) {
        int32_t v7 = 2;
        int32_t v8 = v7 + 1; // 0x2c14
        ax(v7);
        while (v8 != v6) {
            // 0x2c10
            v7 = v8;
            v8 = v7 + 1;
            ax(v7);
        }
    }
    // 0x2c30
    ax(0);
    ae(2);
    int32_t v9 = *(int32_t *)&g13; // 0x2c58
    int32_t v10 = *(int32_t *)&g25; // 0x2c6c
    memcpy((int64_t *)(int64_t)v9, (int64_t *)(int64_t)v10, v2);
    *(int32_t *)(int64_t)g30 = *(int32_t *)&g24;
    ax(0x464c457f);
    ax(0x10101);
    ax(0);
    ax(0);
    ax(0x30002);
    ax(1);
    ax(*(int32_t *)&g39 + *(int32_t *)&g13);
    ax(48);
    ax(0);
    ax(0);
    ax(0x200034);
    ax(3);
    ax(3);
    ad(144, 19);
    ax(4);
    ax(1);
    ax(1);
    ad(0, g30 - *(int32_t *)&g24);
    ax(7);
    ax(0x1000);
    ax(2);
    ad(164, 88);
    ax(6);
    ax(4);
    *(int64_t *)(int64_t)g30 = 0x2d646c2f62696c2f;
    g35 = 0x756e696c;
    *(int32_t *)&g38 = 0x322e6f;
    *(int32_t *)(int64_t)g30 = (int32_t)&g40;
    ax(1);
    ax(1);
    ax(1);
    ax(11);
    ax(4);
    ax(*(int32_t *)&g39 + g30);
    ax(6);
    ax(*(int32_t *)&g39 + g30);
    ax(5);
    ax(*(int32_t *)&g39 + g30);
    ax(10);
    ax(0);
    ax(11);
    ax(16);
    ax(17);
    ax(*(int32_t *)&g39 + g30);
    ax(18);
    ax(0);
    ax(19);
    ax(8);
    ax(0);
    ax(0);
    struct _IO_FILE * file = fopen((char *)(int64_t)F, "w"); // 0x2f1c
    int32_t data = *(int32_t *)&g24;
    fwrite((int64_t *)(int64_t)data, 1, g30 - data, file);
    return fclose(file);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2f7c - 0x3184
// Line range:    596 - 616
int main(int d, char ** a) {
    if (d > 2) {
        // 0x2fac
        *g27 = (int32_t)(int64_t)calloc(1, 0x1869f);
        *(int64_t *)(int64_t)*(int32_t *)&g27 = 0x20666920746e6920;
        g28 = 0x65736c65;
        *(int64_t *)&g30 = 0x6b6165726220656c;
        g35 = 0x74657220;
        *(int64_t *)&g39 = 0x6966656420726f66;
        g41 = 0x6d20656e;
        *(char *)&g42 = 0;
        *(int32_t *)(int64_t)g6 = (int32_t)&g42;
        *(int32_t *)g24 = (int32_t)(int64_t)calloc(1, 0x1869f);
        *(int32_t *)(int64_t)g30 = *(int32_t *)&g24;
        *(int32_t *)g25 = (int32_t)(int64_t)calloc(1, 0x1869f);
        *(int32_t *)(int64_t)g16 = *(int32_t *)&g25;
        *g8 = (int32_t)(int64_t)calloc(1, 0x1869f);
        struct _IO_FILE * file = fopen((char *)(int64_t)*(int32_t *)(int64_t)(a + 4), "r"); // 0x30e0
        *g20 = (int32_t)(int64_t)file;
        *g39 = 0x8048000 - *(int32_t *)&g24;
        *(int32_t *)(int64_t)g30 = (int32_t)&ak;
        *(int32_t *)(int64_t)g16 = (int32_t)&g21;
        w();
        av();
        ar(0);
        au(*(int32_t *)(int64_t)(a + 8));
    } else {
        // 0x2f98
        puts("usage: otccelf file.c outfile");
    }
    // 0x317c
    return 0;
}

// Address range: 0x3184 - 0x3188
int64_t _24_x(void) {
    // 0x3184
    return function_4184();
}

// Address range: 0x3188 - 0x3190
int64_t e843419_40_0008_00000059_8c(void) {
    // 0x3188
    int64_t result; // 0x3188
    *(int32_t *)result = (int32_t)result;
    return result;
}

// Address range: 0x4184 - 0x4185
int64_t function_4184(void) {
    // 0x4184
    int64_t result; // 0x4184
    return result;
}

// Address range: 0x4188 - 0x4200
int64_t __libc_csu_init(void) {
    // 0x4188
    int64_t v1; // 0x4188
    int64_t result = _init(v1); // 0x41bc
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x41ec
        return result;
    }
    // 0x41cc
    return v1 & 0xffffffff;
}

// Address range: 0x4200 - 0x4204
int64_t __libc_csu_fini(void) {
    // 0x4200
    int64_t result; // 0x4200
    return result;
}

// Address range: 0x4204 - 0x4214
int64_t _fini(int64_t a1) {
    // 0x4204
    int64_t result; // 0x4204
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// int fclose(FILE * stream);
// int fgetc(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// int isalnum(int c);
// int isspace(int c);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int puts(const char * s);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 56

