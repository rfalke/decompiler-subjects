// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b15088 = 0x00; // 0000000000015088
int32 g_dw1508C = 0; // 000000000001508C
byte g_b1508F = 0x00; // 000000000001508F
int32 g_dw15090 = 0; // 0000000000015090
word32 g_dw15094 = 0x00; // 0000000000015094
Eq_106 g_t15098 = // 0000000000015098
	{
		0
	};
word32 g_dw1509C = 0x00; // 000000000001509C
Eq_106 g_t150A0 = // 00000000000150A0
	{
		0
	};
int32 g_dw150A4 = 0; // 00000000000150A4
Eq_106 g_t150A8 = // 00000000000150A8
	{
		0
	};
word32 g_dw150AC = 0x00; // 00000000000150AC
Eq_106 g_t150B0 = // 00000000000150B0
	{
		0
	};
Eq_106 g_t150B4 = // 00000000000150B4
	{
		0
	};
Eq_106 g_t150B8 = // 00000000000150B8
	{
		0
	};
Eq_106 g_t150BC = // 00000000000150BC
	{
		0
	};
int32 g_dw150C0 = 0; // 00000000000150C0
Eq_106 g_t150C4 = // 00000000000150C4
	{
		0
	};
Eq_106 g_t150C8 = // 00000000000150C8
	{
		0
	};
Eq_106 g_t150CC = // 00000000000150CC
	{
		0
	};
uipr32 g_dw150D0 = 0x00; // 00000000000150D0
Eq_106 g_t150D4 = // 00000000000150D4
	{
		0
	};
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw15080 = 0x00015080; // 0000000000015080
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000004204: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_csu_fini_GOT = __libc_csu_fini; // 0000000000014F10
<anonymous> * g_ptr14F18 = null; // 0000000000014F18
int32 * g_ptr14F20 = &g_dw1508C; // 0000000000014F20
int32 * g_ptr14F28 = &g_dw15090; // 0000000000014F28
word32 * g_ptr14F30 = &g_dw15094; // 0000000000014F30
union Eq_106 * g_ptr14F38 = &g_t15098; // 0000000000014F38
word32 * g_ptr14F40 = &g_dw1509C; // 0000000000014F40
union Eq_106 * g_ptr14F48 = &g_t150A0; // 0000000000014F48
word64 g_qw14F50 = 0x00; // 0000000000014F50
int32 * g_ptr14F58 = &g_dw150A4; // 0000000000014F58
union Eq_106 * g_ptr14F60 = &g_t150A8; // 0000000000014F60
word64 g_qw14F68 = 0x00; // 0000000000014F68
word32 * g_ptr14F70 = &g_dw150AC; // 0000000000014F70
<anonymous> * __libc_csu_init_GOT = __libc_csu_init; // 0000000000014F78
union Eq_106 * g_ptr14F80 = &g_t150B0; // 0000000000014F80
union Eq_106 * g_ptr14F88 = &g_t150B4; // 0000000000014F88
union Eq_106 * g_ptr14F90 = &g_t150B8; // 0000000000014F90
union Eq_106 * g_ptr14F98 = &g_t150BC; // 0000000000014F98
int32 * g_ptr14FA0 = &g_dw150C0; // 0000000000014FA0
union Eq_106 * g_ptr14FA8 = &g_t150C4; // 0000000000014FA8
union Eq_106 * g_ptr14FB0 = &g_t150C8; // 0000000000014FB0
union Eq_106 * g_ptr14FB8 = &g_t150CC; // 0000000000014FB8
uipr32 * g_ptr14FC0 = &g_dw150D0; // 0000000000014FC0
<anonymous> * main_GOT = main; // 0000000000014FC8
<anonymous> * g_ptr14FD0 = null; // 0000000000014FD0
<anonymous> * g_ptr14FD8 = null; // 0000000000014FD8
union Eq_106 * g_ptr14FE0 = &g_t150D4; // 0000000000014FE0
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_66 g_t15000 = // 0000000000015000
	{
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000D08: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_weak_fn();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a14D00[] = // 0000000000014D00
	{
	};
// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw14D10 = 0x00; // 0000000000014D10
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw42A0 = 0x2E6F732E6362696C; // 00000000000042A0
word16 g_w42A8 = 0x36; // 00000000000042A8
word64 g_qw42B0 = 8030813603607243116; // 00000000000042B0
word32 g_dw42B7 = 3288687; // 00000000000042B7
word64 g_qw42C0 = 0x2D646C2F62696C2F; // 00000000000042C0
word64 g_qw42C8 = 8030813655432849772; // 00000000000042C8
word32 g_dw42CF = 3288687; // 00000000000042CF
word64 g_qw4300 = 0x20666920746E6920; // 0000000000004300
word64 g_qw4308 = 7595451752585063525; // 0000000000004308
word64 g_qw4310 = 0x6B6165726220656C; // 0000000000004310
word64 g_qw4318 = 0x206E727574657220; // 0000000000004318
word64 g_qw4320 = 0x6966656420726F66; // 0000000000004320
word64 g_qw4328 = 0x206E69616D20656E; // 0000000000004328
byte g_b4330 = 0x00; // 0000000000004330
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000E30: void _start(Register (ptr64 Eq_5) x0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* x0)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__libc_start_main(main_GOT, (int32) qwArg00, &ptrArg08, __libc_csu_init_GOT, __libc_csu_fini_GOT, x0, fp);
	abort();
}

// 0000000000000E68: void call_weak_fn()
// Called from:
//      _init
void call_weak_fn()
{
	if (g_qw14F68 == 0x00)
		return;
	__gmon_start__();
}

// 0000000000000E80: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (&g_b1508F - &g_b15088 <= 0x0E)
		return;
	<anonymous> * x1_13 = g_ptr14F18;
	if (x1_13 == null)
		return;
	x1_13();
}

// 0000000000000EB8: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	byte * x1_7 = &g_b15088 - &g_b15088;
	if ((x1_7 >> 3) + ((x1_7 >> 3) >>u 63) >> 1 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr14FD8;
	if (x2_13 == null)
		return;
	word64 x2_17;
	x2_13();
}

// 0000000000000EF8: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_66 * x19_11 = &g_t15000;
	if ((word32) g_b15088 == 0x00)
	{
		if (g_qw14F50 != 0x00)
			__cxa_finalize(&g_t15000, g_qw15080);
		deregister_tm_clones();
		x19_11->b0088 = 0x01;
	}
}

// 0000000000000F40: void frame_dummy(Register word64 x29, Register word64 x30)
void frame_dummy(word64 x29, word64 x30)
{
	ptr64 fp;
	if (g_qw14D10 != 0x00)
	{
		<anonymous> * x1_8 = g_ptr14FD0;
		if (x1_8 != null)
		{
			x1_8();
			register_tm_clones();
			return;
		}
	}
	register_tm_clones();
}

// 0000000000000F78: Register word64 L(Register Eq_106 w0)
// Called from:
//      av
word64 L(Eq_106 w0)
{
	int32 * x1_11 = g_ptr14F20;
	int32 w0_8 = *g_ptr14F20;
	*x1_11 = w0_8 + 0x01;
	uint32 w1_15 = (uint32) (uint8) w0;
	null[(int64) w0_8] = (byte) w1_15;
	return SEQ(SLICE(x1_11, word32, 32), w1_15);
}

// 0000000000000FB8: Register word64 w(Register out ptr64 x29Out)
// Called from:
//      an
//      av
//      ab
//      main
word64 w(ptr64 & x29Out)
{
	ptr64 x29;
	word32 x1_32_32;
	if (*g_ptr14F40 == 0x00)
	{
		Eq_106 w0_19 = fgetc((int64) *g_ptr14F70);
		g_ptr14FB8->u0 = (int32) w0_19;
		word64 x1_67 = SEQ(x1_32_32, w0_19);
		x29Out = x29;
		return x1_67;
	}
	else
	{
		word32 * x1_33 = g_ptr14F40;
		word32 w0_30 = *g_ptr14F40;
		*x1_33 = w0_30 + 0x01;
		g_ptr14FB8->u0 = (word32) null[(int64) w0_30];
		word32 x1_32_32_64 = SLICE(x1_33, word32, 32);
		x29Out = fn0000000000001008();
		return SEQ(x1_32_32_64, w1_46);
	}
}

// 0000000000001008: Register word64 fn0000000000001008()
// Called from:
//      w
//      e843419@0008_00000059_8c
word64 fn0000000000001008()
{
	word64 qwArg00;
	if (g_ptr14FB8->u0 == 0x02)
	{
		*g_ptr14F40 = 0x00;
		g_ptr14FB8->u0 = g_ptr14FE0->u0;
	}
	return qwArg00;
}

// 0000000000001074: Register ui32 am()
// Called from:
//      av
ui32 am()
{
	union Eq_106 * x0_10 = g_ptr14FB8;
	ui32 w0_20 = (word32) isalnum(0x00014000, SEQ(SLICE(x0_10, word32, 32), x0_10->u0));
	union Eq_106 * x0_23 = g_ptr14FB8;
	return w0_20 | (uint32) ((uint8) (x0_23->u0 == 0x5F));
}

// 00000000000010B4: void an()
// Called from:
//      av
//      ab
void an()
{
	if (g_ptr14FB8->u0 == 0x5C)
	{
		word64 x29_63;
		w(out x29_63);
		if (g_ptr14FB8->u0 == 110)
			g_ptr14FB8->u0 = 0x0A;
	}
}

// 0000000000001104: Register word64 av()
// Called from:
//      av
//      ab
//      X
//      S
//      ar
//      main
word64 av()
{
	while (true)
	{
		union Eq_106 * x0_11 = g_ptr14FB8;
		if (((word32) isspace(0x00014000, SEQ(SLICE(x0_11, word32, 32), x0_11->u0)) | (uint32) ((uint8) (g_ptr14FB8->u0 == 0x23))) == 0x00)
			break;
		if (g_ptr14FB8->u0 == 0x23)
		{
			word64 x29_649;
			w(out x29_649);
			av();
			if (g_ptr14FA8->u0 == 0x0218)
			{
				av();
				L(0x20);
				null[(int64) g_ptr14FA8->u0 /64 4] = 0x01;
				null[(int64) (g_ptr14FA8->u0 + 0x04) /64 4] = *g_ptr14F20;
			}
			while (g_ptr14FB8->u0 != 0x0A)
			{
				L(g_ptr14FB8->u0);
				word64 x29_651;
				w(out x29_651);
			}
			L(g_ptr14FB8->u0);
			L(0x02);
		}
		word64 x29_648;
		w(out x29_648);
	}
	word64 x1_344;
	*g_ptr14F28 = 0x00;
	g_ptr14FA8->u0 = g_ptr14FB8->u0;
	if (am() != 0x00)
	{
		word32 x1_32_32_591 = SLICE(L(0x20), word32, 32);
		*g_ptr14F58 = *g_ptr14F20;
		while (am() != 0x00)
		{
			L(g_ptr14FB8->u0);
			word64 x29_650;
			x1_32_32_591 = SLICE(w(out x29_650), word32, 32);
		}
		Eq_106 w0_419 = g_ptr14FA8->u0;
		if (w0_419 <= 0x39 && w0_419 >= 0x30)
		{
			int32 * x0_523 = g_ptr14F58;
			g_ptr14F80->u0 = (int32) strtol(SEQ(SLICE(x0_523, word32, 32), *x0_523));
			g_ptr14FA8->u0 = 0x02;
			x1_344 = SEQ(x1_32_32_591, 0x02);
		}
		else
		{
			null[(int64) *g_ptr14F20] = 0x20;
			char * x0_442 = strstr((int64) *g_ptr14FA0, (int64) (*g_ptr14F58 - 0x01));
			g_ptr14FA8->u0 = (int32) ((word32) x0_442 + (0x00 - *g_ptr14FA0));
			null[(int64) *g_ptr14F20] = 0x00;
			Eq_106 w1_464 = g_ptr14FA8->u0 + 0x20 << 3;
			g_ptr14FA8->u0 = (int32) w1_464;
			word32 x1_32_32_595 = SLICE(x0_442, word32, 32);
			x1_344 = SEQ(x1_32_32_595, w1_464);
			if (g_ptr14FA8->u0 > 0x0218)
			{
				Eq_106 w1_479 = *g_ptr14F30 + g_ptr14FA8->u0;
				g_ptr14FA8->u0 = (int32) w1_479;
				x1_344 = SEQ(x1_32_32_595, w1_479);
				if (null[(int64) g_ptr14FA8->u0 /64 4] == 0x01)
				{
					*g_ptr14F40 = null[(int64) (g_ptr14FA8->u0 + 0x04) /64 4];
					g_ptr14FE0->u0 = g_ptr14FB8->u0;
					word64 x29_652;
					w(out x29_652);
					x1_344 = av();
				}
			}
		}
	}
	else
	{
		struct Eq_305 * x29_152;
		word32 x1_32_32_599 = SLICE(w(out x29_152), word32, 32);
		if (g_ptr14FA8->u0 == 0x27)
		{
			g_ptr14FA8->u0 = 0x02;
			an();
			g_ptr14F80->u0 = g_ptr14FB8->u0;
			word64 x29_653;
			w(out x29_653);
			word64 x29_654;
			x1_344 = w(out x29_654);
		}
		else if ((uint32) ((uint8) (g_ptr14FA8->u0 == 0x2F) & (uint8) (g_ptr14FB8->u0 == 0x2A)) != 0x00)
		{
			word64 x29_655;
			w(out x29_655);
			while (g_ptr14FB8->u0 != 0x00)
			{
				while (g_ptr14FB8->u0 != 0x2A)
				{
					word64 x29_657;
					w(out x29_657);
				}
				word64 x29_658;
				w(out x29_658);
				if (g_ptr14FB8->u0 == 0x2F)
					g_ptr14FB8->u0 = 0x00;
			}
			word64 x29_656;
			w(out x29_656);
			x1_344 = av();
		}
		else
		{
			x29_152->dw001C = (word32) 0x4220;
			do
			{
				word32 w0_187 = x29_152->dw001C;
				x29_152->dw001C = w0_187 + 0x01;
				x29_152->t0018.u0 = (word32) null[(int64) w0_187];
				x1_344 = SEQ(x1_32_32_599, w0_187 + 0x01);
				if (x29_152->t0018.u0 == 0x00)
					return x1_344;
				word32 w0_197 = x29_152->dw001C;
				x29_152->dw001C = w0_197 + 0x01;
				x29_152->t0014.u0 = (word32) null[(int64) w0_197];
				g_ptr14F80->u0 = 0x00;
				while (true)
				{
					word32 w0_209 = x29_152->dw001C;
					x29_152->dw001C = w0_209 + 0x01;
					*g_ptr14F28 = (word32) null[(int64) w0_209] - 0x62;
					if (*g_ptr14F28 >= 0x00)
						break;
					g_ptr14F80->u0 = (int32) ((g_ptr14F80->u0 << 6) + *g_ptr14F28 + 0x40);
				}
			} while (((uint32) (uint8) (x29_152->t0018.u0 == g_ptr14FA8->u0) & (uint32) ((uint8) ((x29_152->t0014).u0 == g_ptr14FB8->u0) | (uint8) ((x29_152->t0014).u0 == 0x40))) == 0x00);
			Eq_106 w1_266 = x29_152->t0014.u0;
			x1_344 = SEQ(x1_32_32_599, w1_266);
			if (w1_266 == g_ptr14FB8->u0)
			{
				word64 x29_659;
				word32 x1_32_32_604 = SLICE(w(out x29_659), word32, 32);
				g_ptr14FA8->u0 = 0x01;
				x1_344 = SEQ(x1_32_32_604, 0x01);
			}
		}
	}
	return x1_344;
}

// 0000000000001684: void aw()
// Called from:
//      x
//      aa
//      aq
//      W
//      ab
//      X
//      ar
//      au
void aw()
{
	ptr64 fp;
	struct Eq_806 * sp_24 = fp - 0x10;
	while (true)
	{
		word32 sp_32_32_23 = SLICE(sp_24, word32, 32);
		if (sp_24->t000C.u0 == 0x00)
			break;
		Eq_813 w0_11 = sp_24->t000C.u0;
		sp_24 = SEQ(sp_32_32_23, (word32) w0_11 + 1);
		if (w0_11 == ~0x00)
			return;
		Eq_106 w0_17 = g_ptr14F60->u0;
		g_ptr14F60->u0 = (word32) w0_17 + 1;
		null[(int64) w0_17].t0000.u1 = sp_24->t000C.u1;
		sp_24->t000C.u0 = (int32) (sp_24->t000C.u0 >> 8);
	}
}

// 00000000000016EC: Register (ptr64 uint8) E(Register Eq_106 w0, Register Eq_106 w1)
// Called from:
//      ap
//      x
//      ab
//      ar
//      ax
//      ae
uint8 * E(Eq_106 w0, Eq_106 w1)
{
	null[(int64) w0] = (uint8) w1;
	null[(int64) ((word32) w0 + 1)] = (uint8) (w1 >> 8);
	null[(int64) ((word32) w0 + 2)] = (uint8) (w1 >> 16);
	uint8 * x0_36 = (int64) ((word32) w0 + 3);
	*x0_36 = (uint8) (w1 >> 24);
	return x0_36;
}

// 000000000000178C: Register Eq_106 ao(Register Eq_106 w0)
// Called from:
//      ap
//      ae
Eq_106 ao(Eq_106 w0)
{
	int32 dwLoc0A;
	byte * x0_27 = (int64) ((word32) w0 + 3);
	return (word32) null[(int64) dwLoc0A] | (word32) null[(int64) ((word32) w0 + 1)] << 8 | (word32) null[(int64) ((word32) w0 + 2)] << 16 | (word32) (*x0_27) << 24;
}

// 00000000000017F0: Register word64 ap(Register Eq_106 w0, Register Eq_106 w1)
// Called from:
//      H
//      ae
word64 ap(Eq_106 w0, Eq_106 w1)
{
	word64 x1;
	Eq_106 w1 = (word32) x1;
	Eq_106 dwLoc14_100 = w0;
	word64 x1_118 = x1;
	while (dwLoc14_100 != 0x00)
	{
		Eq_106 w0_21 = ao(dwLoc14_100);
		if ((word32) null[(int64) (dwLoc14_100 - 0x01)] == 0x05)
		{
			if (w1 >= g_ptr14F88->u0 && w1 < g_ptr14FB0->u0)
				x1_118 = E(dwLoc14_100, (word32) w1.u0 + *g_ptr14FC0);
			else
				x1_118 = E(dwLoc14_100, w1 - g_ptr14F90->u0 + g_ptr14F48->u0 + *g_ptr14FC0);
		}
		else
			x1_118 = E(dwLoc14_100, w1 - dwLoc14_100 - 0x04);
		dwLoc14_100 = w0_21;
	}
	return x1_118;
}

// 00000000000018FC: Register word64 H(Register Eq_106 w0, Register word32 x1_32_32)
// Called from:
//      X
//      S
//      ar
word64 H(Eq_106 w0, word32 x1_32_32)
{
	return ap(w0, g_ptr14F60->u0);
}

// 000000000000192C: Register Eq_106 x(Register Eq_106 w1, Register out ptr64 x1Out)
// Called from:
//      M
//      I
//      aa
//      W
//      ab
//      ar
//      au
Eq_106 x(Eq_106 w1, ptr64 & x1Out)
{
	aw();
	word32 x1_32_32_50 = SLICE(E(g_ptr14F60->u0, w1), word32, 32);
	union Eq_106 * x0_36 = g_ptr14F60;
	Eq_106 w0_29 = g_ptr14F60->u0;
	Eq_106 w0_33 = g_ptr14F60->u0;
	x0_36->u0 = (word32) w0_33 + 4;
	x1Out = SEQ(x1_32_32_50, (word32) w0_33 + 4);
	return w0_29;
}

// 0000000000001990: void M(Register Eq_106 w0)
// Called from:
//      aq
//      ab
//      X
//      au
void M(Eq_106 w0)
{
	word64 x1_27;
	x(w0, out x1_27);
}

// 00000000000019B4: Register Eq_106 I(Register Eq_106 w0, Register out ptr64 x1Out)
// Called from:
//      X
//      S
Eq_106 I(Eq_106 w0, ptr64 & x1Out)
{
	ptr64 x1_15;
	uint64 x0_14 = (uint64) x(w0, out x1_15);
	x1Out = x1_15;
	return (word32) x0_14;
}

// 00000000000019D4: Register Eq_106 aa(Register Eq_106 w1)
// Called from:
//      X
//      ac
Eq_106 aa(Eq_106 w1)
{
	aw();
	word64 x1_40;
	return x(w1, out x1_40);
}

// 0000000000001A08: void aq()
// Called from:
//      ab
//      X
void aq()
{
	aw();
	M(0x00);
	aw();
	aw();
	aw();
}

// 0000000000001A4C: void W(Register word64 x19)
// Called from:
//      ab
void W(word64 x19)
{
	aw();
	int32 dwLoc2C_78 = SLICE(x19, int32, 32);
	Eq_106 w0_26 = null[(int64) dwLoc2C_78 /64 4].u0;
	if (w0_26 != 0x00 && w0_26 <= 0x01FF)
	{
		word64 x1_98;
		x(w0_26, out x1_98);
	}
	else
	{
		word64 x1_97;
		null[(int64) dwLoc2C_78 /64 4].u0 = (int32) x(null[(int64) dwLoc2C_78 /64 4].u0, out x1_97);
	}
}

// 0000000000001ADC: Register ptr64 ab(Register ui32 w0, Register word64 x19)
// Called from:
//      ab
//      X
ptr64 ab(ui32 w0, word64 x19)
{
	ptr64 fp;
	struct Eq_1104 * x29_121 = fp + -64;
	if (g_ptr14FA8->u0 == 0x22)
	{
		M(g_ptr14FB0->u0 + *g_ptr14FC0);
		while (g_ptr14FB8->u0 != 0x22)
		{
			an();
			Eq_106 w0_404 = g_ptr14FB0->u0;
			g_ptr14FB0->u0 = (word32) w0_404.u0 + 1;
			null[(int64) w0_404].t0000.u2 = g_ptr14FB8->u2;
			word64 x29_722;
			w(out x29_722);
		}
		null[(int64) g_ptr14FB0->u0] = 0x00;
		g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + 0x04 & ~0x03);
		w(out x29_121);
		av();
	}
	else
	{
		int32 w0_22 = *g_ptr14F28;
		Eq_106 w0_26 = g_ptr14F80->u0;
		Eq_106 w0_30 = g_ptr14FA8->u0;
		av();
		if (w0_30 == 0x02)
			M(w0_26);
		else if (w0_22 == 0x02)
		{
			x29_121 = ab(0x00, x19);
			word64 x1_724;
			x(0x00, out x1_724);
			if (x29_121->dw0038 == 33)
				aq();
			else
				aw();
		}
		else if (w0_30 == 0x28)
		{
			B(out x29_121);
			av();
		}
		else if (w0_30 == 0x2A)
		{
			av();
			av();
			av();
			if (g_ptr14FA8->u0 == 0x2A)
			{
				av();
				av();
				av();
				av();
			}
			av();
			x29_121 = ab(0x00, x19);
			if (g_ptr14FA8->u0 == 0x3D)
			{
				av();
				aw();
				B(out x29_121);
				aw();
				x29_121->dw0038 != 0x0100;
				aw();
			}
			else if (x29_121->dw0038 != 0x00)
			{
				if (x29_121->dw0038 == 0x0100)
					aw();
				else
					aw();
				g_ptr14F60->u0 = (int32) (g_ptr14F60->u0 + 0x01);
			}
		}
		else if (w0_30 == 0x26)
		{
			W(x19);
			av();
		}
		else if (((uint32) (uint8) (g_ptr14FA8->u0 == 0x3D) & w0) != 0x00)
		{
			av();
			W(B(out x29_121));
		}
		else if (g_ptr14FA8->u0 != 0x28)
		{
			W(x19);
			if (*g_ptr14F28 == 11)
			{
				W(x19);
				aw();
				av();
			}
		}
	}
	if (g_ptr14FA8->u0 == 0x28)
	{
		if (x29_121->dw003C != 0x00)
			aw();
		word64 x1_723;
		x29_121->t0030.u0 = (int32) x(0x00, out x1_723);
		av();
		x29_121->t002C.u0 = 0x00;
		while (g_ptr14FA8->u0 != 0x29)
		{
			B(out x29_121);
			word64 x1_725;
			x(x29_121->t002C.u0, out x1_725);
			if (g_ptr14FA8->u0 == 44)
				av();
			x29_121->t002C.u0 = (int32) (x29_121->t002C.u0 + 0x04);
		}
		E(x29_121->t0030.u0, x29_121->t002C.u0);
		av();
		if (x29_121->dw003C != 0x00)
		{
			word64 x1_727;
			x(x29_121->t002C.u0, out x1_727);
			x29_121->t002C.u0 = (int32) (x29_121->t002C.u0 + 0x04);
		}
		else
		{
			x29_121->dw0038 += 0x04;
			word64 x1_726;
			null[(int64) x29_121->dw001C /64 4].u0 = (int32) x(null[(int64) x29_121->dw001C /64 4].u0, out x1_726);
		}
		if (x29_121->t002C.u0 != 0x00)
		{
			word64 x1_728;
			x(x29_121->t002C.u0, out x1_728);
		}
	}
	return <invalid>;
}

// 0000000000001F44: Register ptr64 X(Register int32 w0)
// Called from:
//      X
//      B
ptr64 X(int32 w0)
{
	word64 x19;
	if (w0 == 0x01)
		ab(0x01, x19);
	else
	{
		struct Eq_1483 * x29_130 = X(w0 - 0x01);
		x29_130->t0028.u0 = 0x00;
		while (x29_130->dw001C == *g_ptr14F28)
		{
			x29_130->t0024.u0 = g_ptr14FA8->u0;
			x29_130->t002C.u0 = g_ptr14F80->u0;
			av();
			if (x29_130->dw001C > 0x08)
			{
				x29_130->t0028.u0 = (int32) aa(x29_130->t0028.u0);
				x29_130 = X(x29_130->dw001C);
			}
			else
			{
				aw();
				x29_130 = X(x29_130->dw001C);
				aw();
				if ((uint32) ((uint8) (x29_130->dw001C == 0x04) | (uint8) (x29_130->dw001C == 0x05)) != 0x00)
					aq();
				else
				{
					aw();
					if (x29_130->t0024.u0 == 0x25)
						aw();
				}
			}
		}
		if (x29_130->t0028.u0 != 0x00 && x29_130->dw001C > 0x08)
		{
			x29_130->t0028.u0 = (int32) aa(x29_130->t0028.u0);
			M(x29_130->t002C.u0 ^ 0x01);
			word64 x1_165;
			I(0x05, out x1_165);
			H(x29_130->t0028.u0, SLICE(x1_165, word32, 32));
			M(x29_130->t002C.u0);
		}
	}
	return <invalid>;
}

// 00000000000020AC: Register ptr64 B(Register out (ptr64 Eq_1261) x29Out)
// Called from:
//      ab
//      ac
//      S
ptr64 B(struct Eq_1261 & x29Out)
{
	X(11);
	x29Out = (struct Eq_1261 *) <invalid>;
	return <invalid>;
}

// 00000000000020C8: void ac()
// Called from:
//      S
void ac()
{
	word64 x29_25;
	B(out x29_25);
	aa(0x00);
}

// 00000000000020E8: Register word64 S(Register ptr64 x19, Register out ptr64 x19Out, Register out (ptr64 Eq_1261) x29Out)
// Called from:
//      S
//      ar
word64 S(ptr64 x19, ptr64 & x19Out, struct Eq_1261 & x29Out)
{
	word16 wLoc28;
	word64 x1_109;
	int32 dwLoc2A_432 = SEQ(wLoc28, SLICE(x19, word16, 48));
	if (g_ptr14FA8->u0 == 288)
	{
		av();
		av();
		ac();
		av();
		struct Eq_1672 * x29_354;
		ptr64 x19_356;
		word32 x1_32_32_367 = SLICE(S(x19, out x19_356, out x29_354), word32, 32);
		if (g_ptr14FA8->u0 == 0x0138)
		{
			av();
			word64 x1_384;
			x29_354->t003C.u0 = (int32) I(0x00, out x1_384);
			H(x29_354->t0034.u0, SLICE(x1_384, word32, 32));
			struct Eq_1708 * x29_401;
			word64 x19_491;
			x1_109 = H(x29_401->t003C.u0, SLICE(S(x19_356, out x19_491, out x29_401), word32, 32));
		}
		else
			x1_109 = H(x29_354->t0034.u0, x1_32_32_367);
	}
	else if ((uint32) ((uint8) (g_ptr14FA8->u0 == 0x0160) | (uint8) (g_ptr14FA8->u0 == 0x01F8)) != 0x00)
	{
		Eq_106 w0_159 = g_ptr14FA8->u0;
		av();
		av();
		if (w0_159 == 0x0160)
			ac();
		else
		{
			if (g_ptr14FA8->u0 != 0x3B)
			{
				word64 x29_493;
				B(out x29_493);
			}
			av();
			Eq_106 w0_194 = g_ptr14F60->u0;
			if (g_ptr14FA8->u0 != 0x3B)
				ac();
			av();
			if (g_ptr14FA8->u0 != 0x29)
			{
				word64 x1_499;
				Eq_106 w0_233 = I(0x00, out x1_499);
				word64 x29_500;
				B(out x29_500);
				word64 x1_245;
				I(w0_194 - g_ptr14F60->u0 - 0x05, out x1_245);
				H(w0_233, SLICE(x1_245, word32, 32));
			}
		}
		av();
		struct Eq_1747 * x29_293;
		word64 x19_492;
		S(x19, out x19_492, out x29_293);
		word64 x1_309;
		I(x29_293->dw003C - g_ptr14F60->u0 - 0x05, out x1_309);
		x1_109 = H(x29_293->t0034.u0, SLICE(x1_309, word32, 32));
	}
	else if (g_ptr14FA8->u0 == 0x7B)
	{
		av();
		word64 x30_495;
		word64 x29_494;
		ptr64 x19_126 = ar(out x29_494, out x30_495);
		while (g_ptr14FA8->u0 != 0x7D)
		{
			word64 x29_498;
			S(x19_126, out x19_126, out x29_498);
		}
		x1_109 = av();
	}
	else
	{
		if (g_ptr14FA8->u0 == 448)
		{
			av();
			if (g_ptr14FA8->u0 != 0x3B)
			{
				word64 x29_497;
				B(out x29_497);
			}
			word64 x1_496;
			g_ptr14F98->u0 = (int32) I(g_ptr14F98->u0, out x1_496);
		}
		else if (g_ptr14FA8->u0 == 400)
		{
			av();
			word64 x1_501;
			null[(int64) dwLoc2A_432 /64 4].u0 = (int32) I(null[(int64) dwLoc2A_432 /64 4].u0, out x1_501);
		}
		else if (g_ptr14FA8->u0 != 0x3B)
		{
			word64 x29_502;
			B(out x29_502);
		}
		x1_109 = av();
	}
	x19Out = x19;
	x29Out = (struct Eq_1261 *) <invalid>;
	return x1_109;
}

// 00000000000023C8: Register ptr64 ar(Register out ptr64 x29Out, Register out ptr64 x30Out)
// Called from:
//      S
//      main
ptr64 ar(ptr64 & x29Out, ptr64 & x30Out)
{
	ptr64 fp;
	ptr64 x19;
	word32 sp_32_32_262 = SLICE(fp + -48, word32, 32);
	struct Eq_1918 * x29_148 = fp + -48;
	while (true)
	{
		Eq_106 w0_22 = g_ptr14FA8->u0;
		struct Eq_1925 * sp_146 = SEQ(sp_32_32_262, (word32) w0_22 + 1);
		if (((uint32) (uint8) (g_ptr14FA8->u0 == 0x0100) | (uint32) ((uint8) (w0_22 != ~0x00) & (uint8) (x29_148->dw001C == 0x00))) == 0x00)
			break;
		if (g_ptr14FA8->u0 == 0x0100)
		{
			av();
			while (g_ptr14FA8->u0 != 0x3B)
			{
				if (x29_148->dw001C != 0x00)
				{
					g_ptr14F38->u0 = (int32) (g_ptr14F38->u0 + 0x04);
					null[(int64) g_ptr14FA8->u0 /64 4] = 0x00 - g_ptr14F38->u0;
				}
				else
				{
					null[(int64) g_ptr14FA8->u0 /64 4].u0 = g_ptr14FB0->u0;
					g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + 0x04);
				}
				av();
				if (g_ptr14FA8->u0 == 44)
					av();
			}
			av();
		}
		else
		{
			null[(int64) g_ptr14FA8->u0 /64 4].u0 = g_ptr14F60->u0;
			av();
			av();
			x29_148->t002C.u0 = 0x08;
			while (g_ptr14FA8->u0 != 0x29)
			{
				null[(int64) g_ptr14FA8->u0 /64 4].u0 = x29_148->t002C.u0;
				x29_148->t002C.u0 = (int32) (x29_148->t002C.u0 + 0x04);
				av();
				if (g_ptr14FA8->u0 == 44)
					av();
			}
			av();
			g_ptr14F38->u0 = 0x00;
			g_ptr14F98->u0 = g_ptr14F38->u0;
			aw();
			word64 x1_288;
			x29_148->t002C.u0 = (int32) x(0x00, out x1_288);
			word64 x19_290;
			H(g_ptr14F98->u0, SLICE(S(x19, out x19_290, out x29_148), word32, 32));
			aw();
			E(x29_148->t002C.u0, g_ptr14F38->u0);
		}
	}
	ptr64 x30_258 = sp_146->ptr0008;
	x29Out = sp_146->ptr0000;
	x30Out = x30_258;
	return <invalid>;
}

// 0000000000002630: Register word64 ax(Register Eq_106 w0)
// Called from:
//      ad
//      ae
//      au
word64 ax(Eq_106 w0)
{
	word32 x1_32_32_31 = SLICE(E(g_ptr14FB0->u0, w0), word32, 32);
	Eq_106 w0_19 = g_ptr14FB0->u0;
	g_ptr14FB0->u0 = (word32) w0_19.u0 + 4;
	return SEQ(x1_32_32_31, (word32) w0_19.u0 + 4);
}

// 0000000000002678: void ad(Register Eq_106 w0, Register Eq_106 w1)
// Called from:
//      au
void ad(Eq_106 w0, Eq_106 w1)
{
	ax(w0);
	ax((word32) w0 + 0x08048000);
	ax((word32) w0 + 0x08048000);
	ax(w1);
	ax(w1);
}

// 00000000000026D0: void ae(Register word32 w0, Register word32 x1_32_32)
// Called from:
//      au
void ae(word32 w0, word32 x1_32_32)
{
	word16 wLoc20;
	int32 dwLoc28;
	ui32 dwLoc0C_224 = 0x00;
	int32 dwLoc04_225 = *g_ptr14FA0;
	int32 dwLoc22_265 = SEQ(wLoc20, SLICE(w0, word16, 16));
	while (true)
	{
		int32 dwLoc04_227 = dwLoc04_225 + 0x01;
		dwLoc04_225 = dwLoc04_227;
		while ((word32) null[(int64) dwLoc22_265] != 0x20 && dwLoc04_225 < *g_ptr14F20)
			++dwLoc04_225;
		if (dwLoc04_225 == *g_ptr14F20)
			break;
		g_ptr14FA8->u0 = (int32) ((dwLoc04_227 - *g_ptr14FA0 << 3) + *g_ptr14F30 + 0xF8);
		Eq_106 w0_80 = null[(int64) (g_ptr14FA8->u0 + 0x04) /64 4].u0;
		Eq_106 w0_73 = null[(int64) g_ptr14FA8->u0 /64 4].u0;
		Eq_106 dwLoc08_242 = w0_80;
		if (w0_80 != 0x00 && w0_73 != 0x01)
		{
			if (w0_73 == 0x00)
			{
				if (w0 == 0x00)
				{
					void * x0_193 = (int64) dwLoc28;
					memcpy((int64) g_ptr14FB0->u0, x0_193, (int64) (dwLoc04_225 - dwLoc04_227));
					g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + dwLoc04_225 - dwLoc04_227 + 0x01);
				}
				else if (w0 == 0x01)
				{
					ax(dwLoc0C_224 + 22);
					ax(0x00);
					ax(0x00);
					ax(0x10);
					dwLoc0C_224 = dwLoc0C_224 + dwLoc04_225 - dwLoc04_227 + 0x01;
				}
				else
				{
					++dwLoc0C_224;
					while (dwLoc08_242 != 0x00)
					{
						Eq_106 w0_123 = ao(dwLoc08_242);
						uint32 w0_133 = (uint32) (uint8) ((word32) null[(int64) (dwLoc08_242 - 0x01)] != 0x05);
						E(dwLoc08_242, 0x00 - w0_133 << 2);
						ax(dwLoc08_242 - g_ptr14F90->u0 + g_ptr14F48->u0 + *g_ptr14FC0);
						ax((dwLoc0C_224 << 8) + w0_133 + 0x01);
						dwLoc08_242 = w0_123;
					}
				}
			}
			else if (w0 == 0x00)
				ap(w0_80, w0_73);
		}
	}
}

// 0000000000002998: void au(Register word64 x30)
// Called from:
//      main
void au(word64 x30)
{
	int32 dwLoc2C;
	word16 wLoc40;
	word16 wLoc28;
	word16 wLoc2A_535 = SLICE(dwLoc2C, word16, 16);
	g_ptr14F48->u0 = g_ptr14FB0->u0;
	word32 w0_23 = g_ptr14F60->u0 - g_ptr14F90->u0;
	g_ptr14F60->u0 = g_ptr14F90->u0;
	aw();
	word64 x1_542;
	x(null[(int64) (*g_ptr14F30 + 0x0250) /64 4] - g_ptr14F60->u0 - 0x05, out x1_542);
	aw();
	M(0x01);
	aw();
	g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + w0_23);
	Eq_106 w0_96 = g_ptr14FB0->u0;
	g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + 0x01);
	struct Eq_2446 * x0_108 = (int64) g_ptr14FB0->u0;
	x0_108->qw0000 = g_qw42A0;
	x0_108->w0008 = g_w42A8;
	g_ptr14FB0->u0 = (int32) ((word32) x0_108 + 0x0A);
	struct Eq_2469 * x0_128 = (int64) g_ptr14FB0->u0;
	x0_128->qw0000 = g_qw42B0;
	x0_128->dw0007 = g_dw42B7;
	g_ptr14FB0->u0 = (int32) ((word32) x0_128 + 11);
	ae(0x00, SLICE(&g_qw42B0, word32, 32));
	Eq_106 w0_156 = g_ptr14FB0->u0 - w0_96;
	g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + 0x03 & ~0x03);
	Eq_106 w0_168 = g_ptr14FB0->u0;
	ax(0x00);
	ax(0x00);
	ax(0x00);
	ae(0x01, SLICE(ax(0x00), word32, 32));
	int32 w0_198 = g_ptr14FB0->u0 - w0_168;
	Eq_106 w0_192 = g_ptr14FB0->u0;
	ax(0x01);
	int32 w0_202 = w0_198 < 0x00 ? w0_198 + 0x0F : w0_198;
	ax(w0_202 >> 4);
	ax(0x01);
	ax(0x00);
	Eq_106 dwLoc04_516 = 0x02;
	int32 dwLoc42_531 = SEQ(wLoc40, SLICE(x30, word16, 48));
	while (dwLoc04_516 < w0_202 >> 4)
	{
		ax(dwLoc04_516);
		dwLoc04_516 = (word32) dwLoc04_516.u0 + 1;
	}
	word32 x1_32_32_238 = SLICE(ax(0x00), word32, 32);
	Eq_106 w0_235 = g_ptr14FB0->u0;
	ae(0x02, x1_32_32_238);
	memcpy((int64) g_ptr14F48->u0, (int64) g_ptr14F90->u0, (int64) dwLoc2C);
	Eq_106 w0_262 = g_ptr14FB0->u0;
	g_ptr14FB0->u0 = g_ptr14F88->u0;
	ax(0x464C457F);
	ax(0x00010101);
	ax(0x00);
	ax(0x00);
	ax(0x00030002);
	ax(0x01);
	ax(g_ptr14F48->u0 + *g_ptr14FC0);
	ax(0x30);
	ax(0x00);
	ax(0x00);
	ax(0x00200034);
	ax(0x03);
	ax(0x03);
	ad(0x90, 0x13);
	ax(0x04);
	ax(0x01);
	ax(0x01);
	ad(0x00, w0_262 - g_ptr14F88->u0);
	ax(0x07);
	ax(0x1000);
	ax(0x02);
	ad(0xA4, 88);
	ax(0x06);
	ax(0x04);
	struct Eq_2708 * x0_363 = (int64) g_ptr14FB0->u0;
	word64 x1_371 = g_qw42C8;
	x0_363->qw0000 = g_qw42C0;
	x0_363->qw0008 = x1_371;
	x0_363->dw000F = g_dw42CF;
	g_ptr14FB0->u0 = (int32) ((word32) x0_363 + 0x14);
	ax(0x01);
	ax(0x01);
	ax(0x01);
	ax(11);
	ax(0x04);
	ax((word32) w0_192.u0 + *g_ptr14FC0);
	ax(0x06);
	ax((word32) w0_168.u0 + *g_ptr14FC0);
	ax(0x05);
	ax((word32) w0_96.u0 + *g_ptr14FC0);
	ax(0x0A);
	ax(w0_156);
	ax(11);
	ax(0x10);
	ax(0x11);
	ax((word32) w0_235.u0 + *g_ptr14FC0);
	ax(0x12);
	ax(w0_262 - w0_235);
	ax(0x13);
	ax(0x08);
	ax(0x00);
	ax(0x00);
	fopen((int64) dwLoc42_531, "w");
	int32 dwLoc2A_536 = SEQ(wLoc28, wLoc2A_535);
	fwrite((int64) g_ptr14F88->u0, 0x01, (int64) (w0_262 - g_ptr14F88->u0), (int64) dwLoc2A_536);
	fclose((int64) dwLoc2A_536);
}

// 0000000000002F7C: void main(Register int32 w0, Register word64 x30)
void main(int32 w0, word64 x30)
{
	int32 dwLoc14_198 = SLICE(x30, int32, 32);
	if (w0 <= 0x02)
		puts("usage: otccelf file.c outfile");
	else
	{
		*g_ptr14FA0 = (word32) calloc(0x01, ~0xFFFE7960);
		struct Eq_2870 * x0_28 = (int64) *g_ptr14FA0;
		word64 x3_35 = g_qw4308;
		x0_28->qw0000 = g_qw4300;
		x0_28->qw0008 = x3_35;
		word64 x3_41 = g_qw4318;
		x0_28->qw0010 = g_qw4310;
		x0_28->qw0018 = x3_41;
		word64 x3_47 = g_qw4328;
		x0_28->qw0020 = g_qw4320;
		x0_28->qw0028 = x3_47;
		x0_28->b0030 = g_b4330;
		*g_ptr14F20 = (word32) x0_28 + 0x30;
		g_ptr14F88->u0 = (int32) (word32) calloc(0x01, ~0xFFFE7960);
		g_ptr14FB0->u0 = g_ptr14F88->u0;
		g_ptr14F90->u0 = (int32) (word32) calloc(0x01, ~0xFFFE7960);
		g_ptr14F60->u0 = g_ptr14F90->u0;
		*g_ptr14F30 = (word32) calloc(0x01, ~0xFFFE7960);
		*g_ptr14F70 = (word32) fopen((int64) null[(int64) dwLoc14_198 /64 4], "r");
		*g_ptr14FC0 = 0x08048000 - g_ptr14F88->u0;
		g_ptr14FB0->u0 = (int32) (g_ptr14FB0->u0 + 252);
		g_ptr14F60->u0 = (int32) (g_ptr14F60->u0 + 0x11);
		word64 x29_226;
		w(out x29_226);
		av();
		struct Eq_3025 * x29_161;
		word64 x30_162;
		ar(out x29_161, out x30_162);
		x29_161->dw0018 += 0x04;
		au(x30_162);
	}
}

// 0000000000003188: void e843419@0008_00000059_8c(Register (ptr64 word32) x0, Register word32 w1)
void e843419@0008_00000059_8c(word32 * x0, word32 w1)
{
	*x0 = w1;
	fn0000000000001008();
}

// 0000000000004188: void __libc_csu_init(Register word32 w0, Register word64 x1, Register word64 x2, Register word64 x24, Register word64 x30)
void __libc_csu_init(word32 w0, word64 x1, word64 x2, word64 x24, word64 x30)
{
	ptr64 fp;
	word32 x24_32_32_89 = SLICE(x24, word32, 32);
	_init();
	int64 x20_23 = 85256 - g_a14D00;
	ptr64 x29_49 = fp + -64;
	<anonymous> * x21_21[] = g_a14D00;
	word64 x22_30 = x2;
	word64 x23_34 = x1;
	int64 x20_36 = x20_23 >> 3;
	if (x20_23 >> 3 != 0x00)
	{
		int64 x19_37 = 0x00;
		word64 x24_133 = SEQ(x24_32_32_89, w0);
		do
		{
			word64 x3_67;
			x21_21[x19_37]();
			int64 x31_70 = x20_36 - x19_37;
		} while (x31_70 != 0x00);
	}
}

// 0000000000004200: void __libc_csu_fini()
void __libc_csu_fini()
{
}

