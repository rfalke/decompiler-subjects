// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b15088 = 0x00; // 0000000000015088
Eq_117 g_t1508C = // 000000000001508C
	{
		0
	};
int32 g_dw15090 = 0; // 0000000000015090
word32 g_dw15094 = 0x00; // 0000000000015094
Eq_117 g_t15098 = // 0000000000015098
	{
		0
	};
word32 g_dw1509C = 0x00; // 000000000001509C
Eq_117 g_t150A0 = // 00000000000150A0
	{
		0
	};
Eq_117 g_t150A4 = // 00000000000150A4
	{
		0
	};
Eq_117 g_t150A8 = // 00000000000150A8
	{
		0
	};
word32 g_dw150AC = 0x00; // 00000000000150AC
Eq_117 g_t150B0 = // 00000000000150B0
	{
		0
	};
Eq_117 g_t150B4 = // 00000000000150B4
	{
		0
	};
Eq_117 g_t150B8 = // 00000000000150B8
	{
		0
	};
Eq_117 g_t150BC = // 00000000000150BC
	{
		0
	};
ui32 g_dw150C0 = 0x00; // 00000000000150C0
Eq_117 g_t150C4 = // 00000000000150C4
	{
		0
	};
Eq_117 g_t150C8 = // 00000000000150C8
	{
		0
	};
Eq_117 g_t150CC = // 00000000000150CC
	{
		0
	};
uipr32 g_dw150D0 = 0x00; // 00000000000150D0
Eq_117 g_t150D4 = // 00000000000150D4
	{
		0
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000004204: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_csu_fini_GOT = __libc_csu_fini; // 0000000000014F10
<anonymous> * g_ptr14F18 = null; // 0000000000014F18
union Eq_117 * g_ptr14F20 = &g_t1508C; // 0000000000014F20
int32 * g_ptr14F28 = &g_dw15090; // 0000000000014F28
word32 * g_ptr14F30 = &g_dw15094; // 0000000000014F30
union Eq_117 * g_ptr14F38 = &g_t15098; // 0000000000014F38
word32 * g_ptr14F40 = &g_dw1509C; // 0000000000014F40
union Eq_117 * g_ptr14F48 = &g_t150A0; // 0000000000014F48
word64 g_qw14F50 = 0x00; // 0000000000014F50
union Eq_117 * g_ptr14F58 = &g_t150A4; // 0000000000014F58
union Eq_117 * g_ptr14F60 = &g_t150A8; // 0000000000014F60
word64 g_qw14F68 = 0x00; // 0000000000014F68
word32 * g_ptr14F70 = &g_dw150AC; // 0000000000014F70
<anonymous> * __libc_csu_init_GOT = __libc_csu_init; // 0000000000014F78
union Eq_117 * g_ptr14F80 = &g_t150B0; // 0000000000014F80
union Eq_117 * g_ptr14F88 = &g_t150B4; // 0000000000014F88
union Eq_117 * g_ptr14F90 = &g_t150B8; // 0000000000014F90
union Eq_117 * g_ptr14F98 = &g_t150BC; // 0000000000014F98
ui32 * g_ptr14FA0 = &g_dw150C0; // 0000000000014FA0
union Eq_117 * g_ptr14FA8 = &g_t150C4; // 0000000000014FA8
union Eq_117 * g_ptr14FB0 = &g_t150C8; // 0000000000014FB0
union Eq_117 * g_ptr14FB8 = &g_t150CC; // 0000000000014FB8
uipr32 * g_ptr14FC0 = &g_dw150D0; // 0000000000014FC0
<anonymous> * main_GOT = main; // 0000000000014FC8
<anonymous> * g_ptr14FD0 = null; // 0000000000014FD0
<anonymous> * g_ptr14FD8 = null; // 0000000000014FD8
union Eq_117 * g_ptr14FE0 = &g_t150D4; // 0000000000014FE0
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr15000 = &g_t0D20; // 0000000000015000
<anonymous> * g_ptr15008 = &g_t0D20; // 0000000000015008
<anonymous> * g_ptr15010 = &g_t0D20; // 0000000000015010
<anonymous> * g_ptr15018 = &g_t0D20; // 0000000000015018
<anonymous> * g_ptr15020 = &g_t0D20; // 0000000000015020
<anonymous> * g_ptr15028 = &g_t0D20; // 0000000000015028
<anonymous> * g_ptr15030 = &g_t0D20; // 0000000000015030
<anonymous> * g_ptr15038 = &g_t0D20; // 0000000000015038
<anonymous> * g_ptr15040 = &g_t0D20; // 0000000000015040
<anonymous> * g_ptr15048 = &g_t0D20; // 0000000000015048
<anonymous> * g_ptr15050 = &g_t0D20; // 0000000000015050
<anonymous> * g_ptr15058 = &g_t0D20; // 0000000000015058
<anonymous> * g_ptr15060 = &g_t0D20; // 0000000000015060
<anonymous> * g_ptr15068 = &g_t0D20; // 0000000000015068
<anonymous> * g_ptr15070 = &g_t0D20; // 0000000000015070
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000D08: Register word64 _init(Register out ptr64 x30Out)
// Called from:
//      __libc_csu_init
word64 _init(ptr64 & x30Out)
{
	call_weak_fn();
	x30Out = qwArg00;
	return x30;
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a14D00[] = // 0000000000014D00
	{
	};
// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw14D10 = 0x00; // 0000000000014D10
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t0D20 = <code>; // 0000000000000D20
// 0000000000000D40: void fn0000000000000D40()
// Called from:
//      ae
//      au
void fn0000000000000D40()
{
	g_ptr15000();
}

// 0000000000000D50: void fn0000000000000D50()
// Called from:
//      __do_global_dtors_aux
void fn0000000000000D50()
{
	g_ptr15008();
}

// 0000000000000D60: void fn0000000000000D60()
// Called from:
//      au
void fn0000000000000D60()
{
	g_ptr15010();
}

// 0000000000000D70: void fn0000000000000D70()
// Called from:
//      au
//      main
void fn0000000000000D70()
{
	g_ptr15018();
}

// 0000000000000D80: void fn0000000000000D80()
// Called from:
//      av
void fn0000000000000D80()
{
	g_ptr15020();
}

// 0000000000000D90: void fn0000000000000D90()
// Called from:
//      _start
void fn0000000000000D90()
{
	g_ptr15028();
}

// 0000000000000DA0: void fn0000000000000DA0()
// Called from:
//      w
void fn0000000000000DA0()
{
	g_ptr15030();
}

// 0000000000000DB0: void fn0000000000000DB0()
// Called from:
//      main
void fn0000000000000DB0()
{
	g_ptr15038();
}

// 0000000000000DD0: void fn0000000000000DD0()
// Called from:
//      _start
void fn0000000000000DD0()
{
	g_ptr15048();
}

// 0000000000000DE0: void fn0000000000000DE0()
// Called from:
//      main
void fn0000000000000DE0()
{
	g_ptr15050();
}

// 0000000000000DF0: void fn0000000000000DF0()
// Called from:
//      av
void fn0000000000000DF0()
{
	g_ptr15058();
}

// 0000000000000E00: void fn0000000000000E00()
// Called from:
//      au
void fn0000000000000E00()
{
	g_ptr15060();
}

// 0000000000000E10: void fn0000000000000E10()
// Called from:
//      av
void fn0000000000000E10()
{
	g_ptr15068();
}

// 0000000000000E20: void fn0000000000000E20()
// Called from:
//      am
void fn0000000000000E20()
{
	g_ptr15070();
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw42A0 = 0x2E6F732E6362696C; // 00000000000042A0
word16 g_w42A8 = 0x36; // 00000000000042A8
word64 g_qw42B0 = 8030813603607243116; // 00000000000042B0
word32 g_dw42B7 = 3288687; // 00000000000042B7
word64 g_qw42C0 = 0x2D646C2F62696C2F; // 00000000000042C0
word64 g_qw42C8 = 8030813655432849772; // 00000000000042C8
word32 g_dw42CF = 3288687; // 00000000000042CF
word64 g_qw4300 = 0x20666920746E6920; // 0000000000004300
word64 g_qw4308 = 7595451752585063525; // 0000000000004308
word64 g_qw4310 = 0x6B6165726220656C; // 0000000000004310
word64 g_qw4318 = 0x206E727574657220; // 0000000000004318
word64 g_qw4320 = 0x6966656420726F66; // 0000000000004320
word64 g_qw4328 = 0x206E69616D20656E; // 0000000000004328
byte g_b4330 = 0x00; // 0000000000004330
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000E30: void _start()
void _start()
{
	fn0000000000000D90();
	fn0000000000000DD0();
	call_weak_fn();
}

// 0000000000000E68: void call_weak_fn()
// Called from:
//      _init
//      _start
void call_weak_fn()
{
	if (g_qw14F68 == 0x00)
		return;
	word64 x17_12;
	g_ptr15040();
}

// 0000000000000E80: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (0x0001508F - 0x00015088 <= 0x0E)
		return;
	<anonymous> * x1_13 = g_ptr14F18;
	if (x1_13 == null)
		return;
	x1_13();
}

// 0000000000000EB8: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	int64 x1_7 = 0x00015088 - 0x00015088;
	if ((x1_7 >> 3) + ((x1_7 >> 3) >>u 63) >> 1 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr14FD8;
	if (x2_13 == null)
		return;
	word64 x2_17;
	x2_13();
}

// 0000000000000EF8: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if ((word32) g_b15088 == 0x00)
	{
		if (g_qw14F50 != 0x00)
			fn0000000000000D50();
		deregister_tm_clones();
		g_b15088 = 0x01;
	}
}

// 0000000000000F40: void frame_dummy(Register word64 x29, Register word64 x30)
void frame_dummy(word64 x29, word64 x30)
{
	if (g_qw14D10 != 0x00)
	{
		<anonymous> * x1_8 = g_ptr14FD0;
		if (x1_8 != null)
		{
			x1_8();
			register_tm_clones();
			return;
		}
	}
	register_tm_clones();
}

// 0000000000000F78: Register word64 L(Register Eq_117 w0)
// Called from:
//      av
word64 L(Eq_117 w0)
{
	union Eq_117 * x1_11 = g_ptr14F20;
	Eq_117 w0_8 = *g_ptr14F20;
	*x1_11 = (word64) w0_8 + 1;
	uint32 w1_15 = (uint32) (uint8) w0;
	null[(int64) w0_8] = (byte) w1_15;
	return SEQ(SLICE(x1_11, word32, 32), w1_15);
}

// 0000000000000FB8: Register word64 w(Register out ptr64 x29Out)
// Called from:
//      an
//      av
//      ab
//      main
word64 w(ptr64 & x29Out)
{
	if (*g_ptr14F40 == 0x00)
	{
		Eq_117 w0_21 = (word32) (int64) *g_ptr14F70;
		fn0000000000000DA0();
		*g_ptr14FB8 = (union Eq_117 *) w0_21;
		word64 x1_71 = SEQ(x1_32_32, w0_21);
		x29Out = x30;
		return x1_71;
	}
	else
	{
		word32 * x1_36 = g_ptr14F40;
		word32 w0_33 = *g_ptr14F40;
		*x1_36 = w0_33 + 0x01;
		*g_ptr14FB8 = (union Eq_117 *) (word32) null[(int64) w0_33];
		word32 x1_32_32_68 = SLICE(x1_36, word32, 32);
		x29Out = fn0000000000001008();
		return SEQ(x1_32_32_68, w1_49);
	}
}

// 0000000000001008: Register word64 fn0000000000001008()
// Called from:
//      w
//      e843419@0008_00000059_8c
word64 fn0000000000001008()
{
	if (*g_ptr14FB8 == 0x02)
	{
		*g_ptr14F40 = 0x00;
		*g_ptr14FB8 = *g_ptr14FE0;
	}
	return qwArg00;
}

// 0000000000001074: Register ui32 am()
// Called from:
//      av
ui32 am()
{
	Eq_117 w0_12 = *g_ptr14FB8;
	fn0000000000000E20();
	union Eq_117 * x0_17 = g_ptr14FB8;
	return w0_12 | (uint32) ((uint8) ((word32) (*x0_17 == 0x5F)));
}

// 00000000000010B4: void an()
// Called from:
//      av
//      ab
void an()
{
	if (*g_ptr14FB8 == 0x5C)
	{
		word64 x29_72;
		w(out x29_72);
		if (*g_ptr14FB8 == 110)
			*g_ptr14FB8 = (union Eq_117 *) 0x0A;
	}
}

// 0000000000001104: Register word64 av()
// Called from:
//      av
//      ab
//      X
//      S
//      ar
//      main
word64 av()
{
	while (true)
	{
		Eq_117 w0_13 = *g_ptr14FB8;
		fn0000000000000D80();
		if ((w0_13 | (uint32) ((uint8) ((word32) (*g_ptr14FB8 == 0x23)))) == 0x00)
			break;
		if (*g_ptr14FB8 == 0x23)
		{
			word64 x29_709;
			w(out x29_709);
			av();
			if (*g_ptr14FA8 == 0x0218)
			{
				av();
				L(0x20);
				null[(int64) *g_ptr14FA8 /64 4] = 0x01;
				null[(int64) ((char *) *g_ptr14FA8 + 4) /64 4].t0000 = *g_ptr14F20;
			}
			while (*g_ptr14FB8 != 0x0A)
			{
				L(*g_ptr14FB8);
				word64 x29_711;
				w(out x29_711);
			}
			L(*g_ptr14FB8);
			L(0x02);
		}
		word64 x29_708;
		w(out x29_708);
	}
	word64 x1_368;
	*g_ptr14F28 = 0x00;
	*g_ptr14FA8 = *g_ptr14FB8;
	if ((word32) (uint64) am() != 0x00)
	{
		word32 x1_32_32_636 = SLICE(L(0x20), word32, 32);
		*g_ptr14F58 = *g_ptr14F20;
		while ((word32) (uint64) am() != 0x00)
		{
			L(*g_ptr14FB8);
			word64 x29_710;
			x1_32_32_636 = SLICE(w(out x29_710), word32, 32);
		}
		if (*g_ptr14FA8 <= 0x39)
		{
			Eq_117 w0_571 = *g_ptr14F58;
			fn0000000000000DF0();
			*g_ptr14F80 = (union Eq_117 *) w0_571;
			*g_ptr14FA8 = (union Eq_117 *) 0x02;
			x1_368 = SEQ(x1_32_32_636, 0x02);
		}
		else
		{
			null[(int64) *g_ptr14F20] = 0x20;
			int64 x0_475 = (int64) *g_ptr14FA0;
			fn0000000000000E10();
			*g_ptr14FA8 = (union Eq_117 *) (word32) (x0_475 + (0x00 - (int64) (*g_ptr14FA0)));
			null[(int64) *g_ptr14F20] = 0x00;
			Eq_117 w1_507 = (char *) *g_ptr14FA8 + 32 << 3;
			*g_ptr14FA8 = (union Eq_117 *) w1_507;
			word32 x1_32_32_640 = SLICE(x0_475, word32, 32);
			x1_368 = SEQ(x1_32_32_640, w1_507);
			if (*g_ptr14FA8 > 0x0218)
			{
				Eq_117 w1_522 = (char *) *g_ptr14FA8 + *g_ptr14F30;
				*g_ptr14FA8 = (union Eq_117 *) w1_522;
				x1_368 = SEQ(x1_32_32_640, w1_522);
				if (null[(int64) *g_ptr14FA8 /64 4] == 0x01)
				{
					*g_ptr14F40 = null[(int64) ((char *) *g_ptr14FA8 + 4) /64 4];
					*g_ptr14FE0 = *g_ptr14FB8;
					word64 x29_712;
					w(out x29_712);
					x1_368 = av();
				}
			}
		}
	}
	else
	{
		struct Eq_328 * x29_162;
		word32 x1_32_32_644 = SLICE(w(out x29_162), word32, 32);
		if (*g_ptr14FA8 == 0x27)
		{
			*g_ptr14FA8 = (union Eq_117 *) 0x02;
			an();
			*g_ptr14F80 = *g_ptr14FB8;
			word64 x29_713;
			w(out x29_713);
			word64 x29_714;
			x1_368 = w(out x29_714);
		}
		else if ((uint32) (uint8) ((uint32) (uint8) (word32) (*g_ptr14FA8 == 0x2F) & (uint32) ((uint8) ((word32) (*g_ptr14FB8 == 0x2A)))) != 0x00)
		{
			word64 x29_715;
			w(out x29_715);
			while (*g_ptr14FB8 != 0x00)
			{
				while (*g_ptr14FB8 != 0x2A)
				{
					word64 x29_717;
					w(out x29_717);
				}
				word64 x29_718;
				w(out x29_718);
				if (*g_ptr14FB8 == 0x2F)
					*g_ptr14FB8 = (union Eq_117 *) 0x00;
			}
			word64 x29_716;
			w(out x29_716);
			x1_368 = av();
		}
		else
		{
			x29_162->dw001C = (word32) 0x4220;
			do
			{
				word32 w0_198 = x29_162->dw001C;
				x29_162->dw001C = w0_198 + 0x01;
				x29_162->t0018 = (word32) null[(int64) w0_198];
				x1_368 = SEQ(x1_32_32_644, w0_198 + 0x01);
				if (x29_162->t0018 == 0x00)
					return x1_368;
				word32 w0_208 = x29_162->dw001C;
				x29_162->dw001C = w0_208 + 0x01;
				x29_162->t0014 = (word32) null[(int64) w0_208];
				*g_ptr14F80 = (union Eq_117 *) 0x00;
				while (true)
				{
					word32 w0_220 = x29_162->dw001C;
					x29_162->dw001C = w0_220 + 0x01;
					*g_ptr14F28 = (word32) null[(int64) w0_220] - 0x62;
					if (*g_ptr14F28 >= 0x00)
						break;
					*g_ptr14F80 = (union Eq_117 *) ((*g_ptr14F80 << 6) + *g_ptr14F28 + 0x40);
				}
			} while (((uint32) (uint8) (word32) (x29_162->t0018 == *g_ptr14FA8) & (uint32) ((uint8) ((uint32) ((uint8) ((word32) (x29_162->t0014 == *g_ptr14FB8))) | (uint32) ((uint8) ((word32) (x29_162->t0014 == 0x40)))))) == 0x00);
			Eq_117 w1_277 = x29_162->t0014;
			x1_368 = SEQ(x1_32_32_644, w1_277);
			if (w1_277 == *g_ptr14FB8)
			{
				word64 x29_719;
				word32 x1_32_32_649 = SLICE(w(out x29_719), word32, 32);
				*g_ptr14FA8 = (union Eq_117 *) 0x01;
				x1_368 = SEQ(x1_32_32_649, 0x01);
			}
		}
	}
	return x1_368;
}

// 0000000000001684: void aw()
// Called from:
//      x
//      aa
//      aq
//      W
//      ab
//      X
//      ar
//      au
void aw()
{
	struct Eq_872 * sp_24 = fp - 0x10;
	while (true)
	{
		word32 sp_32_32_23 = SLICE(sp_24, word32, 32);
		if (sp_24->t000C == 0x00)
			break;
		Eq_880 w0_11 = sp_24->t000C;
		sp_24 = SEQ(sp_32_32_23, (word32) w0_11 + 1);
		if (w0_11 == 0x01)
			return;
		Eq_117 w0_17 = *g_ptr14F60;
		*g_ptr14F60 = (word64) w0_17 + 1;
		null[(int64) w0_17] = (byte) (uint32) sp_24->t000C;
		sp_24->t000C >>= 8;
	}
}

// 00000000000016EC: Register (ptr64 byte) E(Register Eq_117 w0, Register Eq_117 w1)
// Called from:
//      ap
//      x
//      ab
//      ar
//      ax
//      ae
byte * E(Eq_117 w0, Eq_117 w1)
{
	null[(int64) w0] = (byte) (uint32) (uint8) w1;
	null[(int64) ((word64) w0 + 1)] = (byte) (uint32) (uint8) (w1 >> 8);
	null[(int64) ((word64) w0 + 2)] = (byte) (uint32) (uint8) (w1 >> 16);
	byte * x0_36 = (int64) ((word64) w0 + 3);
	*x0_36 = (byte) (uint32) (uint8) (w1 >> 24);
	return x0_36;
}

// 000000000000178C: Register Eq_117 ao(Register Eq_117 w0)
// Called from:
//      ap
//      ae
Eq_117 ao(Eq_117 w0)
{
	byte * x0_27 = (int64) ((word64) w0 + 3);
	return (word32) null[(int64) dwLoc0A] | (word32) null[(int64) ((word64) w0 + 1)] << 8 | (word32) null[(int64) ((word64) w0 + 2)] << 16 | (word32) (*x0_27) << 24;
}

// 00000000000017F0: Register word64 ap(Register Eq_117 w0, Register Eq_117 w1, Register out (ptr64 Eq_1007) x29Out)
// Called from:
//      H
//      ae
word64 ap(Eq_117 w0, Eq_117 w1, struct Eq_1007 & x29Out)
{
	Eq_117 w1 = (word32) x1;
	Eq_117 dwLoc0C_102 = w0;
	word64 x1_121 = x1;
	while (dwLoc0C_102 != 0x00)
	{
		Eq_117 w0_22 = (word32) (uint64) ao(dwLoc0C_102);
		if ((word32) null[(int64) (dwLoc0C_102 - 0x01)] == 0x05)
		{
			if (w1 >= *g_ptr14F88 && w1 < *g_ptr14FB0)
				x1_121 = E(dwLoc0C_102, (word32) w1.u0 + *g_ptr14FC0);
			else
				x1_121 = E(dwLoc0C_102, (char *) *g_ptr14F48 + (w1 - *g_ptr14F90) + *g_ptr14FC0);
		}
		else
			x1_121 = E(dwLoc0C_102, w1 - dwLoc0C_102 - 0x04);
		dwLoc0C_102 = w0_22;
	}
	x29Out = x30;
	return x1_121;
}

// 00000000000018FC: Register word64 H(Register Eq_117 w0, Register word32 x1_32_32)
// Called from:
//      X
//      S
//      ar
word64 H(Eq_117 w0, word32 x1_32_32)
{
	word64 x29_36;
	return ap(w0, SEQ(x1_32_32, *g_ptr14F60), out x29_36);
}

// 000000000000192C: Register Eq_117 x(Register Eq_117 w1, Register out ptr64 x1Out, Register out (ptr64 Eq_1092) x29Out)
// Called from:
//      M
//      I
//      aa
//      W
//      ab
//      ar
//      au
Eq_117 x(Eq_117 w1, ptr64 & x1Out, struct Eq_1092 & x29Out)
{
	aw();
	word32 x1_32_32_53 = SLICE(E(*g_ptr14F60, w1), word32, 32);
	union Eq_117 * x0_37 = g_ptr14F60;
	Eq_117 w0_30 = *g_ptr14F60;
	Eq_117 w0_34 = *g_ptr14F60;
	*x0_37 = (word64) w0_34 + 4;
	x1Out = SEQ(x1_32_32_53, (word64) w0_34 + 4);
	x29Out = x30;
	return w0_30;
}

// 0000000000001990: void M(Register Eq_117 w0)
// Called from:
//      aq
//      ab
//      X
//      au
void M(Eq_117 w0)
{
	word64 x1_32;
	word64 x29_33;
	x(w0, out x1_32, out x29_33);
}

// 00000000000019B4: Register Eq_117 I(Register Eq_117 w0, Register out ptr64 x1Out)
// Called from:
//      X
//      S
Eq_117 I(Eq_117 w0, ptr64 & x1Out)
{
	ptr64 x1_17;
	word64 x29_33;
	uint64 x0_16 = (uint64) x(w0, out x1_17, out x29_33);
	x1Out = x1_17;
	return (word32) x0_16;
}

// 00000000000019D4: Register word32 aa(Register Eq_117 w1)
// Called from:
//      X
//      ac
word32 aa(Eq_117 w1)
{
	aw();
	word64 x1_45;
	word64 x29_46;
	return (word32) (uint64) x(w1, out x1_45, out x29_46);
}

// 0000000000001A08: Register word64 aq()
// Called from:
//      ab
//      X
word64 aq()
{
	aw();
	M(0x00);
	aw();
	aw();
	aw();
	return x30;
}

// 0000000000001A4C: Register word64 W(Register word64 x19)
// Called from:
//      ab
word64 W(word64 x19)
{
	aw();
	int32 dwLoc24_85 = SLICE(x19, int32, 32);
	Eq_117 w0_27 = null[(int64) dwLoc24_85 /64 4].t0000;
	if (w0_27 != 0x00 && w0_27 <= 0x01FF)
	{
		word64 x1_106;
		word64 x29_107;
		x(w0_27, out x1_106, out x29_107);
	}
	else
	{
		word64 x1_104;
		word64 x29_105;
		null[(int64) dwLoc24_85 /64 4] = (word32) (uint64) x(null[(int64) dwLoc24_85 /64 4].t0000, out x1_104, out x29_105);
	}
	return qwLoc30;
}

// 0000000000001ADC: Register word64 ab(Register ui32 w0, Register word64 x19)
// Called from:
//      ab
//      X
word64 ab(ui32 w0, word64 x19)
{
	struct Eq_1213 * x29_130 = fp + -56;
	if (*g_ptr14FA8 == 0x22)
	{
		M((char *) *g_ptr14FB0 + *g_ptr14FC0);
		while (*g_ptr14FB8 != 0x22)
		{
			an();
			Eq_117 w0_455 = *g_ptr14FB0;
			*g_ptr14FB0 = (word64) w0_455 + 1;
			null[(int64) w0_455] = (byte) (uint32) *g_ptr14FB8;
			word64 x29_809;
			w(out x29_809);
		}
		null[(int64) *g_ptr14FB0] = 0x00;
		*g_ptr14FB0 = (union Eq_117 *) ((char *) *g_ptr14FB0 + 4 & ~0x03);
		w(out x29_130);
		av();
	}
	else
	{
		int32 w0_23 = *g_ptr14F28;
		Eq_117 w0_27 = *g_ptr14F80;
		Eq_117 w0_31 = *g_ptr14FA8;
		av();
		if (w0_31 == 0x02)
			M(w0_27);
		else if (w0_23 == 0x02)
		{
			ab(0x00, x19);
			word64 x1_811;
			x(0x00, out x1_811, out x29_130);
			if (x29_130->dw0038 == 33)
				x29_130 = aq();
			else
				aw();
		}
		else if (w0_31 == 0x28)
		{
			B(out x29_130);
			av();
		}
		else if (w0_31 == 0x2A)
		{
			av();
			av();
			av();
			if (*g_ptr14FA8 == 0x2A)
			{
				av();
				av();
				av();
				av();
			}
			av();
			x29_130 = ab(0x00, x19);
			if (*g_ptr14FA8 == 0x3D)
			{
				av();
				aw();
				B(out x29_130);
				aw();
				x29_130->dw0038 != 0x0100;
				aw();
			}
			else if (x29_130->dw0038 != 0x00)
			{
				if (x29_130->dw0038 == 0x0100)
					aw();
				else
					aw();
				*g_ptr14F60 = (union Eq_117 *) ((char *) *g_ptr14F60 + 1);
			}
		}
		else if (w0_31 == 0x26)
		{
			W(x19);
			av();
		}
		else if (((uint32) (uint8) (word32) (*g_ptr14FA8 == 0x3D) & w0) != 0x00)
		{
			av();
			W(B(out x29_130));
		}
		else if (*g_ptr14FA8 != 0x28)
		{
			word64 x19_80 = W(x19);
			if (*g_ptr14F28 == 11)
			{
				W(x19_80);
				aw();
				av();
			}
		}
	}
	if (*g_ptr14FA8 == 0x28)
	{
		if (x29_130->dw003C != 0x00)
			aw();
		word64 x1_810;
		struct Eq_1343 * x29_540;
		x29_540->t0030 = (word32) (uint64) x(0x00, out x1_810, out x29_540);
		av();
		x29_540->t002C.u0 = 0x00;
		while (*g_ptr14FA8 != 0x29)
		{
			struct Eq_1391 * x29_569;
			B(out x29_569);
			word64 x1_812;
			x(x29_569->t002C, out x1_812, out x29_540);
			if (*g_ptr14FA8 == 44)
				av();
			x29_540->t002C.u3 = (word64) x29_540->t002C + 4;
		}
		struct Eq_1412 * x29_641;
		E(x29_540->t0030, x29_540->t002C);
		av();
		if (x29_540->dw003C != 0x00)
		{
			word64 x1_814;
			x(x29_540->t002C, out x1_814, out x29_641);
			x29_641->t002C.u3 = (word64) x29_641->t002C + 4;
		}
		else
		{
			x29_540->dw0038 += 0x04;
			word64 x1_813;
			null[(int64) x29_540->dw001C /64 4] = (word32) (uint64) x(null[(int64) x29_540->dw001C /64 4].t0000, out x1_813, out x29_641);
		}
		if (x29_641->t002C != 0x00)
		{
			word64 x29_816;
			word64 x1_815;
			x(x29_641->t002C, out x1_815, out x29_816);
		}
	}
	return <invalid>;
}

// 0000000000001F44: Register word64 X(Register int32 w0)
// Called from:
//      X
//      B
word64 X(int32 w0)
{
	if (w0 == 0x01)
		ab(0x01, x19);
	else
	{
		struct Eq_1213 * x29_119 = X(w0 - 0x01);
		x29_119->t0028.u0 = 0x00;
		while (x29_119->dw001C == *g_ptr14F28)
		{
			x29_119->t0024 = *g_ptr14FA8;
			x29_119->t002C = *g_ptr14F80;
			av();
			if (x29_119->dw001C > 0x08)
			{
				x29_119->t0028 = (word32) (uint64) aa(x29_119->t0028);
				x29_119 = X(x29_119->dw001C);
			}
			else
			{
				aw();
				x29_119 = X(x29_119->dw001C);
				aw();
				if ((uint32) (uint8) ((uint32) (uint8) (word32) (x29_119->dw001C == 0x04) | (uint32) ((uint8) ((word32) (x29_119->dw001C == 0x05)))) != 0x00)
					x29_119 = aq();
				else
				{
					aw();
					if (x29_119->t0024 == 0x25)
						aw();
				}
			}
		}
		if (x29_119->t0028 != 0x00 && x29_119->dw001C > 0x08)
		{
			x29_119->t0028 = (word32) (uint64) aa(x29_119->t0028);
			M(x29_119->t002C ^ 0x01);
			word64 x1_175;
			I(0x05, out x1_175);
			H(x29_119->t0028, SLICE(x1_175, word32, 32));
			M(x29_119->t002C);
		}
	}
	return <invalid>;
}

// 00000000000020AC: Register word64 B(Register out (ptr64 Eq_1394) x29Out)
// Called from:
//      ab
//      ac
//      S
word64 B(struct Eq_1394 & x29Out)
{
	X(11);
	x29Out = (struct Eq_1394 *) <invalid>;
	return <invalid>;
}

// 00000000000020C8: Register word32 ac(Register out ptr64 x29Out)
// Called from:
//      S
word32 ac(ptr64 & x29Out)
{
	word64 x29_29;
	B(out x29_29);
	uint64 x0_14 = (uint64) aa(0x00);
	x29Out = x30;
	return (word32) x0_14;
}

// 00000000000020E8: Register word64 S(Register word64 x19, Register out ptr64 x19Out, Register out (ptr64 Eq_1394) x29Out)
// Called from:
//      S
//      ar
word64 S(word64 x19, ptr64 & x19Out, struct Eq_1394 & x29Out)
{
	word64 x1_114;
	struct Eq_1804 * x29_228 = fp + -56;
	int32 dwLoc22_481 = SEQ(wLoc20, SLICE(x19, word16, 48));
	if (*g_ptr14FA8 == 288)
	{
		av();
		av();
		struct Eq_1848 * x29_377;
		x29_377->dw0034 = (word32) (uint64) ac(out x29_377);
		av();
		struct Eq_1860 * x29_396;
		word64 x19_398;
		word32 x1_32_32_411 = SLICE(S(x19, out x19_398, out x29_396), word32, 32);
		if (*g_ptr14FA8 == 0x0138)
		{
			av();
			word64 x1_430;
			x29_396->dw003C = (word32) (uint64) I(0x00, out x1_430);
			H(x29_396->t0034, SLICE(x1_430, word32, 32));
			struct Eq_1899 * x29_447;
			word64 x19_531;
			x1_114 = H(x29_447->t003C, SLICE(S(x19_398, out x19_531, out x29_447), word32, 32));
		}
		else
			x1_114 = H(x29_396->t0034, x1_32_32_411);
	}
	else if ((uint32) (uint8) ((uint32) (uint8) (word32) (*g_ptr14FA8 == 0x0160) | (uint32) ((uint8) ((word32) (*g_ptr14FA8 == 0x01F8)))) != 0x00)
	{
		Eq_117 w0_174 = *g_ptr14FA8;
		av();
		av();
		if (w0_174 == 0x0160)
		{
			struct Eq_1938 * x29_295;
			x29_295->dw0034 = (word32) (uint64) ac(out x29_295);
		}
		else
		{
			if (*g_ptr14FA8 != 0x3B)
			{
				word64 x29_533;
				B(out x29_533);
			}
			av();
			if (*g_ptr14FA8 != 0x3B)
				x29_228->dw0034 = (word32) (uint64) ac(out x29_228);
			av();
			if (*g_ptr14FA8 != 0x29)
			{
				word64 x1_538;
				x29_228->t0038 = (word32) (uint64) I(0x00, out x1_538);
				word64 x29_539;
				B(out x29_539);
				word64 x1_271;
				I(x29_228->dw003C - *g_ptr14F60 - 0x05, out x1_271);
				H(x29_228->t0038, SLICE(x1_271, word32, 32));
				x29_228->dw003C = (word32) ((word64) x29_228->t0038 + 4);
			}
		}
		av();
		struct Eq_1949 * x29_324;
		word64 x19_532;
		S(x19, out x19_532, out x29_324);
		word64 x1_342;
		I(x29_324->dw003C - *g_ptr14F60 - 0x05, out x1_342);
		x1_114 = H(x29_324->t0034, SLICE(x1_342, word32, 32));
	}
	else if (*g_ptr14FA8 == 0x7B)
	{
		av();
		word64 x29_534;
		word64 x19_135 = ar(out x29_534);
		while (*g_ptr14FA8 != 0x7D)
		{
			word64 x29_537;
			S(x19_135, out x19_135, out x29_537);
		}
		x1_114 = av();
	}
	else
	{
		if (*g_ptr14FA8 == 448)
		{
			av();
			if (*g_ptr14FA8 != 0x3B)
			{
				word64 x29_536;
				B(out x29_536);
			}
			word64 x1_535;
			*g_ptr14F98 = (union Eq_117 *) (word32) (uint64) I(*g_ptr14F98, out x1_535);
		}
		else if (*g_ptr14FA8 == 400)
		{
			av();
			word64 x1_540;
			null[(int64) dwLoc22_481 /64 4] = (word32) (uint64) I(null[(int64) dwLoc22_481 /64 4].t0000, out x1_540);
		}
		else if (*g_ptr14FA8 != 0x3B)
		{
			word64 x29_541;
			B(out x29_541);
		}
		x1_114 = av();
	}
	x19Out = qwLoc30;
	x29Out = (struct Eq_1394 *) <invalid>;
	return x1_114;
}

// 00000000000023C8: Register word64 ar(Register out ptr64 x29Out)
// Called from:
//      S
//      main
word64 ar(ptr64 & x29Out)
{
	word32 sp_32_32_275 = SLICE(fp + -40, word32, 32);
	struct Eq_2150 * x29_157 = fp + -40;
	while (true)
	{
		Eq_117 w0_23 = *g_ptr14FA8;
		ptr64 * sp_280 = SEQ(sp_32_32_275, (word64) w0_23 + 1);
		if (((uint32) (uint8) (word32) (*g_ptr14FA8 == 0x0100) | (uint32) ((uint8) ((uint32) ((uint8) ((word32) (w0_23 != 0x01))) & (uint32) ((uint8) ((word32) (x29_157->dw001C == 0x00)))))) == 0x00)
			break;
		if (*g_ptr14FA8 == 0x0100)
		{
			av();
			while (*g_ptr14FA8 != 0x3B)
			{
				if (x29_157->dw001C != 0x00)
				{
					*g_ptr14F38 = (union Eq_117 *) ((char *) *g_ptr14F38 + 4);
					null[(int64) *g_ptr14FA8 /64 4] = 0x00 - *g_ptr14F38;
				}
				else
				{
					null[(int64) *g_ptr14FA8 /64 4].t0000 = *g_ptr14FB0;
					*g_ptr14FB0 = (union Eq_117 *) ((char *) *g_ptr14FB0 + 4);
				}
				av();
				if (*g_ptr14FA8 == 44)
					av();
			}
			av();
		}
		else
		{
			null[(int64) *g_ptr14FA8 /64 4].t0000 = *g_ptr14F60;
			av();
			av();
			x29_157->t002C.u0 = 0x08;
			while (*g_ptr14FA8 != 0x29)
			{
				null[(int64) *g_ptr14FA8 /64 4].t0000 = x29_157->t002C;
				x29_157->t002C.u3 = (word64) x29_157->t002C + 4;
				av();
				if (*g_ptr14FA8 == 44)
					av();
			}
			av();
			*g_ptr14F38 = (union Eq_117 *) 0x00;
			*g_ptr14F98 = *g_ptr14F38;
			aw();
			struct Eq_2295 * x29_147;
			word64 x1_311;
			x29_147->dw002C = (word32) (uint64) x(0x00, out x1_311, out x29_147);
			word64 x19_313;
			H(*g_ptr14F98, SLICE(S(x19, out x19_313, out x29_157), word32, 32));
			aw();
			E(x29_157->t002C, *g_ptr14F38);
			word64 sp_143 = <invalid>;
			sp_32_32_275 = SLICE(sp_143, word32, 32);
		}
	}
	x29Out = *sp_280;
	return <invalid>;
}

// 0000000000002630: Register word64 ax(Register Eq_117 w0, Register out (ptr64 Eq_2403) x29Out)
// Called from:
//      ad
//      ae
//      au
word64 ax(Eq_117 w0, struct Eq_2403 & x29Out)
{
	word32 x1_32_32_34 = SLICE(E(*g_ptr14FB0, w0), word32, 32);
	Eq_117 w0_20 = *g_ptr14FB0;
	*g_ptr14FB0 = (word64) w0_20 + 4;
	x29Out = x30;
	return SEQ(x1_32_32_34, (word64) w0_20 + 4);
}

// 0000000000002678: void ad(Register Eq_117 w0)
// Called from:
//      au
void ad(Eq_117 w0)
{
	struct Eq_2430 * x29_18;
	ax(w0, out x29_18);
	x29_18->t001C.u3 = (word64) x29_18->t001C + 0x08048000;
	struct Eq_2443 * x29_29;
	ax(x29_18->t001C, out x29_29);
	struct Eq_2450 * x29_35;
	ax(x29_29->t001C, out x29_35);
	struct Eq_2457 * x29_41;
	ax(x29_35->t0018, out x29_41);
	word64 x29_58;
	ax(x29_41->t0018, out x29_58);
}

// 00000000000026D0: void ae(Register word32 x1_32_32)
// Called from:
//      au
void ae(word32 x1_32_32)
{
	struct Eq_2472 * x29_105 = fp + -56;
	while (true)
	{
		x29_105->t003C.u3 = (word64) x29_105->t003C + 1;
		x29_105->t0030 = x29_105->t003C;
		while ((word32) null[(int64) x29_105->dw001E] != 0x20 && x29_105->t003C < *g_ptr14F20)
			x29_105->t003C.u3 = (word64) x29_105->t003C + 1;
		if (x29_105->t003C == *g_ptr14F20)
			break;
		*g_ptr14FA8 = (union Eq_117 *) ((x29_105->t0030 - *g_ptr14FA0 << 3) + *g_ptr14F30 + 0xF8);
		x29_105->dw002C = null[(int64) *g_ptr14FA8 /64 4];
		x29_105->t0038 = null[(int64) ((char *) *g_ptr14FA8 + 4) /64 4].t0000;
		if (x29_105->t0038 != 0x00 && x29_105->dw002C != 0x01)
		{
			if (x29_105->dw002C == 0x00)
			{
				if (x29_105->dw001C == 0x00)
				{
					x1_32_32 = SLICE((int64) x29_105->dw0018, word32, 32);
					fn0000000000000D40();
					Mem237[Mem83[0x0000000000014FB0<p64>:word64] + 0x00:word32] = Mem83[Mem83[0x0000000000014FB0<p64>:word64] + 0x00:word32] + Mem83[x29_105 + 60:word32] - Mem83[x29_105 + 48:word32] + 0x01;
				}
				else if (x29_105->dw001C == 0x01)
				{
					word64 x29_289;
					ax((word64) x29_105->t0034 + 22, out x29_289);
					word64 x29_290;
					ax(0x00, out x29_290);
					word64 x29_291;
					ax(0x00, out x29_291);
					x1_32_32 = SLICE(ax(0x10, out x29_105), word32, 32);
					Mem209[x29_105 + 52:word32] = Mem83[x29_105 + 52:word32] + Mem83[x29_105 + 60:word32] - Mem83[x29_105 + 48:word32] + 0x01;
				}
				else
				{
					x29_105->t0034.u3 = (word64) x29_105->t0034 + 1;
					while (x29_105->t0038 != 0x00)
					{
						x29_105->t0030 = (word32) (uint64) ao(x29_105->t0038);
						x29_105->dw0028 = (uint32) (uint8) (word32) ((word32) null[(int64) (x29_105->t0038 - 0x01)] != 0x05);
						E(x29_105->t0038, 0x00 - x29_105->dw0028 << 2);
						struct Eq_2738 * x29_164;
						ax((char *) *g_ptr14F48 + (x29_105->t0038 - *g_ptr14F90) + *g_ptr14FC0, out x29_164);
						x1_32_32 = SLICE(ax((x29_164->dw0034 << 8) + x29_164->dw0028 + 0x01, out x29_105), word32, 32);
						x29_105->t0038 = x29_105->t0030;
					}
				}
			}
			else if (x29_105->dw001C == 0x00)
				x1_32_32 = SLICE(ap(x29_105->t0038, SEQ(x1_32_32, x29_105->dw002C), out x29_105), word32, 32);
		}
	}
}

// 0000000000002998: void au()
// Called from:
//      main
void au()
{
	*g_ptr14F48 = *g_ptr14FB0;
	*g_ptr14F60 = *g_ptr14F90;
	aw();
	struct Eq_2806 * x29_60;
	word64 x1_682;
	x(null[(int64) (*g_ptr14F30 + 0x0250) /64 4] - *g_ptr14F60 - 0x05, out x1_682, out x29_60);
	aw();
	M(0x01);
	aw();
	*g_ptr14FB0 = (union Eq_117 *) ((char *) *g_ptr14FB0 + x29_60->dw0048);
	x29_60->t0044 = *g_ptr14FB0;
	*g_ptr14FB0 = (union Eq_117 *) ((char *) *g_ptr14FB0 + 1);
	struct Eq_2872 * x0_112 = (int64) *g_ptr14FB0;
	x0_112->qw0000 = g_qw42A0;
	x0_112->w0008 = g_w42A8;
	*g_ptr14FB0 = (union Eq_117 *) (word32) (&x0_112->w0008 + 1);
	struct Eq_2897 * x0_132 = (int64) *g_ptr14FB0;
	x0_132->qw0000 = g_qw42B0;
	x0_132->dw0007 = g_dw42B7;
	*g_ptr14FB0 = (union Eq_117 *) (word32) (&x0_132->dw0007 + 1);
	ae(SLICE(0x42B0, word32, 32));
	x29_60->dw0040 = *g_ptr14FB0 - x29_60->t0044;
	*g_ptr14FB0 = (union Eq_117 *) ((char *) *g_ptr14FB0 + 3 & ~0x03);
	x29_60->t003C = *g_ptr14FB0;
	word64 x29_683;
	ax(0x00, out x29_683);
	word64 x29_684;
	ax(0x00, out x29_684);
	word64 x29_685;
	ax(0x00, out x29_685);
	struct Eq_2976 * x29_196;
	ae(SLICE(ax(0x00, out x29_196), word32, 32));
	x29_196->t0038 = *g_ptr14FB0;
	int32 w0_214 = *g_ptr14FB0 - x29_196->dw003C;
	x29_196->dw0034 = (w0_214 < 0x00 ? w0_214 + 0x0F : w0_214) >> 4;
	struct Eq_3012 * x29_225;
	ax(0x01, out x29_225);
	word64 x29_686;
	ax(x29_225->t0034, out x29_686);
	word64 x29_687;
	ax(0x01, out x29_687);
	struct Eq_3029 * x29_243;
	ax(0x00, out x29_243);
	x29_243->t004C.u0 = 0x02;
	while (x29_243->t004C < x29_243->t0034)
	{
		Eq_117 w0_253 = x29_243->t004C;
		x29_243->t004C.u3 = (word64) w0_253 + 1;
		ax(w0_253, out x29_243);
	}
	struct Eq_3057 * x29_265;
	word32 x1_32_32_272 = SLICE(ax(0x00, out x29_265), word32, 32);
	x29_265->t0030 = *g_ptr14FB0;
	ae(x1_32_32_272);
	fn0000000000000D40();
	x29_265->t002C = *g_ptr14FB0;
	*g_ptr14FB0 = *g_ptr14F88;
	word64 x29_688;
	ax(0x464C457F, out x29_688);
	word64 x29_689;
	ax(0x00010101, out x29_689);
	word64 x29_690;
	ax(0x00, out x29_690);
	word64 x29_691;
	ax(0x00, out x29_691);
	word64 x29_692;
	ax(0x00030002, out x29_692);
	word64 x29_693;
	ax(0x01, out x29_693);
	word64 x29_694;
	ax((char *) *g_ptr14F48 + *g_ptr14FC0, out x29_694);
	word64 x29_695;
	ax(0x30, out x29_695);
	word64 x29_696;
	ax(0x00, out x29_696);
	word64 x29_697;
	ax(0x00, out x29_697);
	word64 x29_698;
	ax(0x00200034, out x29_698);
	word64 x29_699;
	ax(0x03, out x29_699);
	word64 x29_700;
	ax(0x03, out x29_700);
	ad(0x90);
	word64 x29_701;
	ax(0x04, out x29_701);
	word64 x29_702;
	ax(0x01, out x29_702);
	word64 x29_703;
	ax(0x01, out x29_703);
	ad(0x00);
	word64 x29_704;
	ax(0x07, out x29_704);
	word64 x29_705;
	ax(0x1000, out x29_705);
	word64 x29_706;
	ax(0x02, out x29_706);
	ad(0xA4);
	word64 x29_707;
	ax(0x06, out x29_707);
	word64 x29_708;
	ax(0x04, out x29_708);
	struct Eq_3219 * x0_461 = (int64) *g_ptr14FB0;
	word64 x1_470 = g_qw42C8;
	x0_461->qw0000 = g_qw42C0;
	x0_461->qw0008 = x1_470;
	x0_461->dw000F = g_dw42CF;
	*g_ptr14FB0 = (union Eq_117 *) (word32) ((char *) &x0_461->dw000F + 5);
	word64 x29_709;
	ax(0x01, out x29_709);
	word64 x29_710;
	ax(0x01, out x29_710);
	word64 x29_711;
	ax(0x01, out x29_711);
	word64 x29_712;
	ax(11, out x29_712);
	struct Eq_3270 * x29_514;
	ax(0x04, out x29_514);
	word64 x29_713;
	ax(*g_ptr14FC0 + x29_514->dw0038, out x29_713);
	struct Eq_3288 * x29_530;
	ax(0x06, out x29_530);
	word64 x29_714;
	ax(*g_ptr14FC0 + x29_530->dw003C, out x29_714);
	struct Eq_3306 * x29_546;
	ax(0x05, out x29_546);
	word64 x29_715;
	ax(*g_ptr14FC0 + x29_546->dw0044, out x29_715);
	struct Eq_3324 * x29_562;
	ax(0x0A, out x29_562);
	word64 x29_716;
	ax(x29_562->t0040, out x29_716);
	word64 x29_717;
	ax(11, out x29_717);
	word64 x29_718;
	ax(0x10, out x29_718);
	struct Eq_3346 * x29_586;
	ax(0x11, out x29_586);
	word64 x29_719;
	ax(*g_ptr14FC0 + x29_586->dw0030, out x29_719);
	struct Eq_3364 * x29_602;
	ax(0x12, out x29_602);
	word64 x29_720;
	ax(x29_602->dw002C - x29_602->dw0030, out x29_720);
	word64 x29_721;
	ax(0x13, out x29_721);
	word64 x29_722;
	ax(0x08, out x29_722);
	word64 x29_723;
	ax(0x00, out x29_723);
	struct Eq_3395 * x29_634;
	ax(0x00, out x29_634);
	word32 w0_645 = (word32) (int64) x29_634->dw000E;
	fn0000000000000D70();
	x29_634->dw004C = w0_645;
	fn0000000000000E00();
	fn0000000000000D60();
}

// 0000000000002F7C: void main(Register int32 w0)
void main(int32 w0)
{
	if (w0 <= 0x02)
		fn0000000000000DE0();
	else
	{
		fn0000000000000DB0();
		*g_ptr14FA0 = 0x01;
		struct Eq_3430 * x0_30 = (int64) *g_ptr14FA0;
		word64 x3_38 = g_qw4308;
		x0_30->qw0000 = g_qw4300;
		x0_30->qw0008 = x3_38;
		word64 x3_46 = g_qw4318;
		x0_30->qw0010 = g_qw4310;
		x0_30->qw0018 = x3_46;
		word64 x3_54 = g_qw4328;
		x0_30->qw0020 = g_qw4320;
		x0_30->qw0028 = x3_54;
		x0_30->b0030 = g_b4330;
		*g_ptr14F20 = (union Eq_117 *) (word32) &x0_30->b0030;
		fn0000000000000DB0();
		*g_ptr14F88 = (union Eq_117 *) 0x01;
		*g_ptr14FB0 = *g_ptr14F88;
		fn0000000000000DB0();
		*g_ptr14F90 = (union Eq_117 *) 0x01;
		*g_ptr14F60 = *g_ptr14F90;
		fn0000000000000DB0();
		*g_ptr14F30 = 0x01;
		word32 w0_125 = (word32) (int64) null[(int64) dwLoc0C /64 4];
		fn0000000000000D70();
		*g_ptr14F70 = w0_125;
		*g_ptr14FC0 = 0x08048000 - *g_ptr14F88;
		*g_ptr14FB0 = (union Eq_117 *) ((char *) *g_ptr14FB0 + 252);
		*g_ptr14F60 = (union Eq_117 *) ((char *) *g_ptr14F60 + 0x0011);
		word64 x29_249;
		w(out x29_249);
		av();
		struct Eq_3584 * x29_180;
		ar(out x29_180);
		x29_180->dw0018 += 0x04;
		au();
	}
}

// 0000000000003188: void e843419@0008_00000059_8c(Register (ptr64 word32) x0, Register word32 w1)
void e843419@0008_00000059_8c(word32 * x0, word32 w1)
{
	*x0 = w1;
	fn0000000000001008();
}

// 0000000000004188: void __libc_csu_init(Register word32 w0, Register word64 x1, Register word64 x2, Register word64 x24)
void __libc_csu_init(word32 w0, word64 x1, word64 x2, word64 x24)
{
	word32 x24_32_32_104 = SLICE(x24, word32, 32);
	int64 x20_26 = 85256 - 0x00014D00;
	<anonymous> * x21_24[] = g_a14D00;
	word64 x22_34 = x2;
	word64 x23_38 = x1;
	word64 x30_44;
	word64 x29_43 = _init(out x30_44);
	int64 x20_45 = x20_26 >> 3;
	if (x20_26 >> 3 != 0x00)
	{
		int64 x19_46 = 0x00;
		word64 x24_151 = SEQ(x24_32_32_104, w0);
		do
		{
			word64 x3_76;
			x21_24[x19_46]();
			int64 x31_81 = x20_45 - x19_46;
		} while (x31_81 != 0x00);
	}
}

// 0000000000004200: void __libc_csu_fini()
void __libc_csu_fini()
{
}

