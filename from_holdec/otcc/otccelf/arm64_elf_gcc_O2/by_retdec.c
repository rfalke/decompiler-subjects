//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int32_t aa(int32_t s, int32_t a);
int32_t ab(int32_t s);
int64_t ac(int64_t a1);
int32_t ad(uint32_t d, uint32_t a);
int32_t ae(int32_t s);
int64_t am(void);
int64_t an(void);
int64_t an_part_1(int64_t a1);
int64_t ao(void);
int32_t ap(int32_t a, int32_t z);
int32_t aq(int32_t a);
int32_t ar(int32_t s);
int32_t au(int32_t F);
int32_t av(void);
int64_t aw(void);
int64_t ax(void);
int64_t B(void);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(void);
int64_t E(void);
int64_t frame_dummy(void);
int64_t function_10f0(int64_t a1, int64_t a2);
int64_t function_400001534(void);
int64_t function_40000161c(void);
int64_t * function_d40(int64_t * dest, int64_t * src, int32_t n);
int64_t function_d50(int64_t a1);
int32_t function_d60(struct _IO_FILE * stream);
struct _IO_FILE * function_d70(char * filename, char * modes);
int32_t function_d80(int32_t c);
int32_t function_d90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_da0(struct _IO_FILE * stream);
int64_t * function_db0(int32_t nmemb, int32_t size);
int64_t function_dc0(int64_t a1);
void function_dd0(void);
int32_t function_de0(char * s);
int32_t function_df0(char * nptr, char ** endptr, int32_t base);
int32_t function_e00(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * function_e10(char * haystack, char * needle);
int32_t function_e20(int32_t c);
int64_t H(void);
int64_t I(void);
int64_t L(void);
int64_t M(void);
int64_t register_tm_clones(void);
int32_t S(int32_t s);
int64_t W(int64_t a1);
int64_t w(int64_t a1);
int32_t x(int32_t d, uint32_t a);
int32_t X(int32_t s);

// --------------------- Global Variables ---------------------

int32_t P = 0; // 0x15098
int32_t R = 0; // 0x150a0
int32_t Z = 0; // 0x150a4
int32_t ak = 0; // 0x150ac
int32_t al = 0; // 0x150d4
int64_t g1 = 0x10c0; // 0x14d00
int64_t g2 = 0x1078; // 0x14d08
int64_t g3 = 0; // 0x14d10
void (*g4)() = (void (*)())0x3d18; // 0x14f10
int64_t g5 = 0; // 0x14f18
int32_t * g6 = (int32_t *)0x1508c; // 0x14f20
int32_t g7 = 336; // 0x14f21
int32_t g8 = 0x15090; // 0x14f28
int32_t g9 = 0x15094; // 0x14f30
int32_t g11 = 0; // 0x14f3c
int32_t * g12 = (int32_t *)0x1509c; // 0x14f40
int64_t g14 = 0; // 0x14f50
int32_t g16 = 0x150a8; // 0x14f60
char * g17 = "P\x01"; // 0x14f61
char * g18 = "\x01"; // 0x14f62
char * g19; // 0x14f63
int32_t g20 = 0; // 0x14f64
int64_t g21 = 0; // 0x14f68
int32_t g23 = 336; // 0x14f71
void (*g24)() = (void (*)())0x3ca0; // 0x14f78
int32_t g25 = 0x150b0; // 0x14f80
int32_t g26 = 336; // 0x14f81
int64_t g27; // 0x14f88
char * g28 = "P\x01"; // 0x14f89
char * g29 = "\x01"; // 0x14f8a
char * g30; // 0x14f8b
int64_t g31; // 0x14f90
int32_t g32 = 336; // 0x14f91
int32_t g33 = 0x150bc; // 0x14f98
char * g34 = "\xc0P\x01"; // 0x14fa0
int32_t g35 = 0x150c4; // 0x14fa8
int32_t * g36 = (int32_t *)0x150c800000000; // 0x14fac
int64_t g37; // 0x14fb0
char * g38 = "P\x01"; // 0x14fb1
char * g39 = "\x01"; // 0x14fb2
char * g40; // 0x14fb3
char * g41; // 0x14fb4
char * g42; // 0x14fb5
char * g43; // 0x14fb6
char * g44; // 0x14fb7
int32_t g45 = 0x150cc; // 0x14fb8
char * g46; // 0x14fbc
int64_t g48 = 0xe300000000000; // 0x14fc3
char * g49 = "0\x0e"; // 0x14fc8
char * g50 = "\x0e"; // 0x14fc9
char * g51; // 0x14fca
char * g52; // 0x14fcb
int64_t g53 = 0; // 0x14fd0
int64_t g55 = 3360; // 0x15000
int64_t g56 = 0; // 0x15088
int64_t g57 = 0; // 0x1508f
int32_t * g58 = (int32_t *)-0x41769ff24aeed22; // 0x250
int32_t g59 = 0x6d232b2b; // 0x3d38
int32_t g60;
int32_t y = 0; // 0x150d0
int32_t * g10 = &P; // 0x14f38
int32_t * g13 = &R; // 0x14f48
int32_t * g15 = &Z; // 0x14f58
int32_t * g22 = &ak; // 0x14f70
int32_t * g47 = &y; // 0x14fc0
int32_t * g54 = &al; // 0x14fe0

// ------------------------ Functions -------------------------

// Address range: 0xd08 - 0xd1c
int64_t _init(int64_t a1) {
    // 0xd08
    return call_weak_fn();
}

// Address range: 0xd40 - 0xd50
int64_t * function_d40(int64_t * dest, int64_t * src, int32_t n) {
    // 0xd40
    return memcpy(dest, src, n);
}

// Address range: 0xd50 - 0xd60
int64_t function_d50(int64_t a1) {
    // 0xd50
    return __cxa_finalize();
}

// Address range: 0xd60 - 0xd70
int32_t function_d60(struct _IO_FILE * stream) {
    // 0xd60
    return fclose(stream);
}

// Address range: 0xd70 - 0xd80
struct _IO_FILE * function_d70(char * filename, char * modes) {
    // 0xd70
    return fopen(filename, modes);
}

// Address range: 0xd80 - 0xd90
int32_t function_d80(int32_t c) {
    // 0xd80
    return isspace(c);
}

// Address range: 0xd90 - 0xda0
int32_t function_d90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xd90
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xda0 - 0xdb0
int32_t function_da0(struct _IO_FILE * stream) {
    // 0xda0
    return fgetc(stream);
}

// Address range: 0xdb0 - 0xdc0
int64_t * function_db0(int32_t nmemb, int32_t size) {
    // 0xdb0
    return calloc(nmemb, size);
}

// Address range: 0xdc0 - 0xdd0
int64_t function_dc0(int64_t a1) {
    // 0xdc0
    return __gmon_start__();
}

// Address range: 0xdd0 - 0xde0
void function_dd0(void) {
    // 0xdd0
    abort();
}

// Address range: 0xde0 - 0xdf0
int32_t function_de0(char * s) {
    // 0xde0
    return puts(s);
}

// Address range: 0xdf0 - 0xe00
int32_t function_df0(char * nptr, char ** endptr, int32_t base) {
    // 0xdf0
    return strtol(nptr, endptr, base);
}

// Address range: 0xe00 - 0xe10
int32_t function_e00(int64_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0xe00
    return fwrite(ptr, size, n, s);
}

// Address range: 0xe10 - 0xe20
char * function_e10(char * haystack, char * needle) {
    // 0xe10
    return strstr(haystack, needle);
}

// Address range: 0xe20 - 0xe30
int32_t function_e20(int32_t c) {
    // 0xe20
    return isalnum(c);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0xe30 - 0xfb4
// Line range:    596 - 599
int main(int d, char ** a) {
    if (d < 3) {
        // 0xfa4
        puts("usage: otccelf file.c outfile");
    } else {
        int64_t * mem = calloc(1, 0x1869f); // 0xe60
        int64_t v1 = (int64_t)mem; // 0xe60
        int64_t v2 = 0x100000000 * v1 >> 32; // 0xe64
        *mem = 0x20666920746e6920;
        *(int64_t *)(v2 + 8) = 0x6968772065736c65;
        *(int32_t *)*(int64_t *)0x14fa0 = (int32_t)v1;
        *(int64_t *)(v2 + 32) = 0x6966656420726f66;
        *(int64_t *)(v2 + 40) = 0x206e69616d20656e;
        *(int64_t *)(v2 + 16) = 0x6b6165726220656c;
        *(int64_t *)(v2 + 24) = 0x206e727574657220;
        int64_t v3 = v2 + 48; // 0xeb4
        *(char *)v3 = 0;
        *(int32_t *)*(int64_t *)0x14f20 = (int32_t)v3;
        int32_t mem2 = (int64_t)calloc(1, 0x1869f); // 0xed8
        int32_t * v4 = (int32_t *)*(int64_t *)0x14fb0; // 0xed8
        *v4 = mem2;
        int32_t * v5 = (int32_t *)*(int64_t *)0x14f88; // 0xedc
        *v5 = mem2;
        int32_t * v6 = (int32_t *)(int64_t)g16; // 0xee8
        int32_t mem3 = (int64_t)calloc(1, 0x1869f); // 0xf00
        *v6 = mem3;
        *(int32_t *)*(int64_t *)0x14f90 = mem3;
        int64_t * mem4 = calloc(1, 0x1869f); // 0xf08
        int64_t v7 = 0x100000000 * (int64_t)a; // 0xf10
        *(int32_t *)*(int64_t *)0x14f30 = (int32_t)(int64_t)mem4;
        struct _IO_FILE * file = fopen((char *)(int64_t)*(int32_t *)(v7 + 0x400000000 >> 32), "r"); // 0xf34
        *v6 = (int32_t)&g23;
        *v4 = *v4 + 252;
        *g22 = (int32_t)(int64_t)file;
        *g47 = 0x8048000 - *v5;
        w((int64_t)&g60);
        av();
        ar(0);
        au(*(int32_t *)(v7 + 0x800000000 >> 32));
    }
    // 0xf90
    return 0;
}

// Address range: 0xfb4 - 0xfec
int64_t _start(int64_t a1) {
    // 0xfb4
    int64_t v1; // 0xfb4
    int64_t v2; // 0xfb4
    __libc_start_main((int64_t)g49, (int32_t)a1, (char **)&v1, g24, g4, (void (*)())v2);
    abort();
    return &g60;
}

// Address range: 0xfec - 0x1000
int64_t call_weak_fn(void) {
    // 0xfec
    if (g21 == 0) {
        // 0xffc
        return 0;
    }
    // 0xff8
    return function_dc0(g21);
}

// Address range: 0x1000 - 0x1034
int64_t deregister_tm_clones(void) {
    if ((int64_t)&g57 - (int64_t)&g56 == 14 || (uint64_t)((int64_t)&g57 - (int64_t)&g56) < 14 || g5 == 0) {
        // 0x1030
        return &g56;
    }
    // 0x102c
    return _ITM_deregisterTMCloneTable(&g56, g5);
}

// Address range: 0x1038 - 0x1074
int64_t register_tm_clones(void) {
    // 0x1038
    return &g56;
}

// Address range: 0x1078 - 0x10c0
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g56; // 0x1088
    if (result != 0) {
        // 0x10b4
        return result;
    }
    // 0x1090
    if (g14 != 0) {
        // 0x109c
        function_d50(*(int64_t *)((int64_t)&g55 + 128));
    }
    // 0x10a8
    deregister_tm_clones();
    *(char *)&g56 = 1;
    // 0x10b4
    return 1;
}

// Address range: 0x10c0 - 0x10f0
int64_t frame_dummy(void) {
    // 0x10c0
    if (g3 == 0 || g53 == 0) {
        // 0x10d0
        return register_tm_clones();
    }
    // 0x10e4
    return _Jv_RegisterClasses(&g3, g53);
}

// Address range: 0x10f0 - 0x10f8
int64_t function_10f0(int64_t a1, int64_t a2) {
    // 0x10f0
    return register_tm_clones();
}

// Address range: 0x10f8 - 0x111c
int64_t L(void) {
    // 0x10f8
    *g6 = (int32_t)&g7;
    int64_t v1; // 0x10f8
    *(char *)(0x100000000 * (int64_t)g6 >> 32) = (char)v1;
    return v1 & 0xffffffff;
}

// Address range: 0x1120 - 0x11a0
// Demangled:     wchar_t
int64_t w(int64_t a1) {
    int64_t result = *(int64_t *)0x14f40; // 0x1124
    int32_t * v1 = (int32_t *)result; // 0x1128
    int32_t v2 = *v1; // 0x1128
    if (v2 == 0) {
        int32_t c = fgetc((struct _IO_FILE *)(int64_t)*(int32_t *)&g22); // 0x116c
        *(int32_t *)(int64_t)g45 = c;
        return c;
    }
    // 0x1130
    *v1 = v2 + 1;
    int32_t * v3 = (int32_t *)(int64_t)g45; // 0x1140
    unsigned char v4 = *(char *)(int64_t)v2; // 0x1144
    *v3 = (int32_t)v4;
    if (v4 != 2) {
        // 0x1154
        return result;
    }
    // 0x1188
    *v1 = 0;
    uint32_t result2 = *(int32_t *)&g54; // 0x1194
    *v3 = result2;
    return result2;
}

// Address range: 0x11a0 - 0x11d0
int64_t an_part_1(int64_t a1) {
    // 0x11a0
    int64_t v1; // 0x11a0
    w(v1);
    int64_t result = g45;
    if (g45 == 110) {
        // 0x11c0
        *(int32_t *)result = 10;
    }
    // 0x11c8
    return result;
}

// Address range: 0x11d0 - 0x1208
int64_t am(void) {
    int32_t c = g45; // 0x11e4
    return isalnum(c) | (int32_t)(c == 95);
}

// Address range: 0x1208 - 0x1224
int64_t an(void) {
    uint32_t result = g45; // 0x1210
    if (result == 92) {
        // 0x1220
        return an_part_1((int64_t)&g60);
    }
    // 0x121c
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1228 - 0x16a4
// Line range:    42 - 99
int32_t av(void) {
    // 0x1228
    int32_t * v1; // 0x1228
    int32_t * v2; // 0x1228
    int32_t * v3; // 0x1228
    int64_t result; // 0x1228
    int64_t v4; // 0x1228
    while (true) {
      lab_0x125c_2:
        // 0x125c
        if ((isspace(g45) || (int32_t)(g45 == 35)) != 0) {
            w((int64_t)&g60);
            int32_t * v5; // 0x1228
            int64_t v6; // 0x1228
            int32_t v7; // 0x1520
            int64_t v8; // 0x1228
            if (g45 == 35) {
                // 0x1400
                av();
                if (g35 == (int32_t)".1") {
                    // 0x14f4
                    av();
                    *g6 = (int32_t)&g7;
                    *(char *)(int64_t)*(int32_t *)&g6 = 32;
                    *(int32_t *)(int64_t)g35 = 1;
                    v7 = *(int32_t *)&g6;
                    *(int32_t *)(int64_t)(int32_t)&g36 = v7;
                }
                // 0x1414
                v8 = (int64_t)g6;
                v6 = v8;
                v5 = g6;
                if (g45 != 10) {
                    // 0x1428
                    *g6 = (int32_t)&g7;
                    *(char *)(0x100000000 * v8 >> 32) = (char)g45;
                    w((int64_t)&g60);
                    if (g45 != 10) {
                        *g6 = (int32_t)&g7;
                        *(char *)(int64_t)*(int32_t *)&g6 = (char)g45;
                        w((int64_t)&g60);
                        while (g45 != 10) {
                            // 0x1428
                            *g6 = (int32_t)&g7;
                            *(char *)(int64_t)*(int32_t *)&g6 = (char)g45;
                            w((int64_t)&g60);
                        }
                    }
                    // 0x144c
                    v5 = g6;
                    v6 = (int64_t)v5;
                }
                // 0x144c
                *v5 = (int32_t)&g7;
                *(char *)(0x100000000 * v6 >> 32) = 10;
                *v5 = (int32_t)&g7;
                *(char *)(int64_t)*(int32_t *)&g6 = 2;
                w((int64_t)&g60);
            }
            int32_t v9 = isspace(g45); // 0x1290
            bool v10 = g45 == 35; // 0x12a0
            while ((v9 || (int32_t)(g45 == 35)) != 0) {
                // 0x1280
                w((int64_t)&g60);
                if (v10) {
                    // 0x1400
                    av();
                    if (g35 == (int32_t)".1") {
                        // 0x14f4
                        av();
                        *g6 = (int32_t)&g7;
                        *(char *)(int64_t)*(int32_t *)&g6 = 32;
                        *(int32_t *)(int64_t)g35 = 1;
                        v7 = *(int32_t *)&g6;
                        *(int32_t *)(int64_t)(int32_t)&g36 = v7;
                    }
                    // 0x1414
                    v8 = (int64_t)g6;
                    v6 = v8;
                    v5 = g6;
                    if (g45 != 10) {
                        // 0x1428
                        *g6 = (int32_t)&g7;
                        *(char *)(0x100000000 * v8 >> 32) = (char)g45;
                        w((int64_t)&g60);
                        if (g45 != 10) {
                            *g6 = (int32_t)&g7;
                            *(char *)(int64_t)*(int32_t *)&g6 = (char)g45;
                            w((int64_t)&g60);
                            while (g45 != 10) {
                                // 0x1428
                                *g6 = (int32_t)&g7;
                                *(char *)(int64_t)*(int32_t *)&g6 = (char)g45;
                                w((int64_t)&g60);
                            }
                        }
                        // 0x144c
                        v5 = g6;
                        v6 = (int64_t)v5;
                    }
                    // 0x144c
                    *v5 = (int32_t)&g7;
                    *(char *)(0x100000000 * v6 >> 32) = 10;
                    *v5 = (int32_t)&g7;
                    *(char *)(int64_t)*(int32_t *)&g6 = 2;
                    w((int64_t)&g60);
                }
                // 0x1288
                v9 = isspace(g45);
                v10 = g45 == 35;
            }
        }
        int32_t c = g45;
        v2 = (int32_t *)(int64_t)g8;
        v3 = (int32_t *)(int64_t)g35;
        *v2 = 0;
        *v3 = c;
        if ((isalnum(c) || (int32_t)(c == 95)) == 0) {
            // 0x1488
            w((int64_t)&g60);
            if (g35 == 39) {
                // break -> 0x1658
                break;
            }
            if (g35 == 47 != (g45 == 42)) {
                // 0x15c0
                v1 = (int32_t *)(int64_t)g25;
                v4 = &g59;
                goto lab_0x15d8;
            }
            // 0x14ac
            w((int64_t)&g60);
            int64_t v11 = g45;
            int64_t v12 = v11; // 0x14b8
            while (v12 != 0) {
                int64_t v13 = v12;
                w((int64_t)&g60);
                int64_t v14 = g45;
                while (v13 != 42) {
                    // 0x14d0
                    v13 = v14;
                    w((int64_t)&g60);
                    v14 = g45;
                }
                // 0x14d8
                v12 = v14;
                if (g45 == 47) {
                    // 0x14e8
                    *(int32_t *)v11 = 0;
                    // 0x14ec
                    w((int64_t)&g60);
                    goto lab_0x125c_2;
                }
            }
            // 0x14ec
            w((int64_t)&g60);
            goto lab_0x125c_2;
        } else {
            // 0x12cc
            *g6 = (int32_t)&g7;
            *(char *)(0x100000000 * (int64_t)g6 >> 32) = 32;
            *g15 = *(int32_t *)&g6;
            if ((isalnum(g45) || (int32_t)(g45 == 95)) != 0) {
                int32_t v15 = *(int32_t *)&g6; // 0x1308
                *g6 = (int32_t)&g7;
                *(char *)(int64_t)v15 = (char)g45;
                w((int64_t)&g60);
                while ((isalnum(g45) || (int32_t)(g45 == 95)) != 0) {
                    // 0x1308
                    v15 = *(int32_t *)&g6;
                    *g6 = (int32_t)&g7;
                    *(char *)(int64_t)v15 = (char)g45;
                    w((int64_t)&g60);
                }
            }
            uint32_t v16 = g35;
            int64_t v17 = v16;
            if (v16 == 57 || v16 < 57) {
                int32_t str_as_l = strtol((char *)(int64_t)*(int32_t *)&g15, NULL, 0); // 0x158c
                *(int32_t *)v17 = 2;
                *(int32_t *)(int64_t)g25 = str_as_l;
                return str_as_l;
            }
            // 0x1350
            *(char *)(int64_t)*(int32_t *)&g6 = 32;
            int32_t v18 = *(int32_t *)&g15; // 0x136c
            int32_t str = *(int32_t *)&g34; // 0x1370
            strstr((char *)(int64_t)str, (char *)(int64_t)(v18 - 1));
            int32_t * v19 = (int32_t *)v17; // 0x138c
            *(char *)(int64_t)*(int32_t *)&g6 = 0;
            *v19 = 8 * (int32_t)&g49;
            result = (int64_t)(8 * (int32_t)&g49);
            if (8 * (int32_t)&g49 <= (int32_t)".1") {
                // 0x1560
                return result;
            }
            int32_t v20 = g9 + 8 * (int32_t)&g49; // 0x13b8
            int64_t v21 = v20; // 0x13b8
            *v19 = v20;
            result = v21;
            if (*(int32_t *)(int64_t)v20 != 1) {
                // 0x1560
                return result;
            }
            // 0x13d0
            *g12 = *(int32_t *)(0x100000000 * v21 + 0x400000000 >> 32);
            *g54 = g45;
            w((int64_t)&g60);
            goto lab_0x125c_2;
        }
    }
    // 0x1658
    *v3 = 2;
    if (g45 == 92) {
        // 0x1698
        an_part_1((int64_t)&g60);
    }
    // 0x166c
    *(int32_t *)(int64_t)g25 = g45;
    w((int64_t)&g60);
    return w((int64_t)&g60);
  lab_0x15d8:;
    int64_t v22 = 0x100000000 * v4;
    int64_t v23 = v22 >> 32; // 0x15d8
    unsigned char v24 = *(char *)v23; // 0x15e0
    result = v23;
    unsigned char v25; // 0x15f8
    int64_t v26; // 0x1228
    if (v24 == 0) {
        return result;
    } else {
        // 0x15e8
        v25 = *(char *)(v22 + 0x100000000 >> 32);
        *v1 = 0;
        int64_t v27 = (int64_t)*(char *)(v22 + 0x200000000 >> 32) + 0xffffff9e; // 0x1604
        int32_t v28 = v27; // 0x1608
        *v2 = v28;
        v26 = v27 & 0xffffffff;
        if (v28 > -1) {
            v26 = function_400001534();
            goto lab_0x1610;
        } else {
            goto lab_0x1610;
        }
    }
  lab_0x1610:;
    int64_t v29 = v22 + 0x400000000 >> 32; // 0x1618
    *v1 = (int32_t)v26 + 64;
    int64_t v30 = (int64_t)*(char *)(v29 - 1) + 0xffffff9e; // 0x1634
    int32_t v31 = v30; // 0x1638
    *v2 = v31;
    int64_t v32 = v30 & 0xffffffff; // 0x163c
    if (v31 < 0) {
        v32 = function_40000161c();
        goto lab_0x1640;
    } else {
        goto lab_0x1640;
    }
  lab_0x1640:
    // 0x1640
    v4 = v29 & 0xffffffff;
    if (g35 == (int32_t)v24 == (v25 == 64 || g45 == (int32_t)v25)) {
        // 0x1650
        result = v32;
        if ((int64_t)g45 == (int64_t)v25) {
            // 0x1550
            w((int64_t)&g60);
            *(int32_t *)(int64_t)g35 = 1;
            result = 1;
            return result;
        } else {
            return result;
        }
    } else {
        goto lab_0x15d8;
    }
}

// Address range: 0x16a8 - 0x16e8
int64_t aw(void) {
    // 0x16a8
    int64_t v1; // 0x16a8
    int32_t v2 = v1;
    if (v2 == 0 || v2 == -1) {
        // 0x16e0
        return 0;
    }
    int32_t * v3 = (int32_t *)(int64_t)g16; // 0x16c8
    *v3 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)v1;
    int32_t v4 = v2 >> 8; // 0x16d0
    if (v4 != -1 != v4 != 0) {
        // 0x16e0
        return 0;
    }
    int32_t v5 = v4; // 0x16dc
    *v3 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)v5;
    v5 >>= 8;
    while (v5 != -1 == (v5 != 0)) {
        // 0x16bc
        *v3 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)v5;
        v5 >>= 8;
    }
    // 0x16e0
    return 0;
}

// Address range: 0x16e8 - 0x1724
int64_t E(void) {
    // 0x16e8
    int64_t v1; // 0x16e8
    int64_t v2 = 0x100000000 * v1;
    int64_t v3 = v1 + 3; // 0x16f4
    uint32_t v4 = (int32_t)v1; // 0x16fc
    *(char *)(v2 >> 32) = (char)v1;
    *(char *)(v2 + 0x100000000 >> 32) = (char)(v4 / 256);
    *(char *)(v2 + 0x200000000 >> 32) = (char)(v4 / 0x10000);
    *(char *)(0x100000000 * v3 >> 32) = (char)(v4 / 0x1000000);
    return v3 & 0xffffffff;
}

// Address range: 0x1728 - 0x1768
int64_t ao(void) {
    // 0x1728
    int64_t v1; // 0x1728
    uint64_t v2 = v1;
    int64_t v3 = 0x100000000 * v2; // 0x1728
    unsigned char v4 = *(char *)(v3 + 0x200000000 >> 32); // 0x1748
    unsigned char v5 = *(char *)(v3 + 0x100000000 >> 32); // 0x174c
    unsigned char v6 = *(char *)(v3 + 0x300000000 >> 32); // 0x1750
    return 0x10000 * (int64_t)v4 | v2 % 256 | 256 * (int64_t)v5 | 0x1000000 * (int64_t)v6;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1768 - 0x18b4
// Line range:    144 - 157
int32_t ap(int32_t a, int32_t z) {
    if (a == 0) {
        // 0x1818
        return 0;
    }
    int64_t v1 = z;
    int64_t v2 = a; // 0x1768
    char * v3; // 0x17e0
    int64_t v4; // 0x17fc
    char * v5; // 0x17c8
    char * v6; // 0x17d4
    char * v7; // 0x17d8
    while (true) {
      lab_0x17a0_2:;
        int64_t v8 = v2;
        int64_t v9 = 0x100000000 * v8; // 0x17a0
        v5 = (char *)(v9 + 0x200000000 >> 32);
        unsigned char v10 = *v5; // 0x17c8
        v6 = (char *)(v9 + 0x100000000 >> 32);
        unsigned char v11 = *v6; // 0x17d4
        v7 = (char *)(v9 + 0x300000000 >> 32);
        unsigned char v12 = *v7; // 0x17d8
        v3 = (char *)(v9 >> 32);
        unsigned char v13 = *v3; // 0x17e0
        v4 = 256 * (int64_t)v11 | 0x10000 * (int64_t)v10 | (int64_t)v13 | 0x1000000 * (int64_t)v12;
        if (*(char *)(v9 - 0x100000000 >> 32) == 5) {
            // 0x1828
            if (v1 < (int64_t)*(int32_t *)&g27) {
                goto lab_0x1870;
            } else {
                // 0x1834
                if (v1 < (int64_t)*(int32_t *)&g37) {
                    uint32_t v14 = *(int32_t *)&g47 + z; // 0x1844
                    *v3 = (char)v14;
                    *v6 = (char)(v14 / 256);
                    *v5 = (char)(v14 / 0x10000);
                    *v7 = (char)(v14 / 0x1000000);
                    if (v4 == 0) {
                        // break -> 0x1818
                        break;
                    }
                    // 0x17a0
                    v2 = v4;
                    goto lab_0x17a0_2;
                } else {
                    goto lab_0x1870;
                }
            }
        } else {
            int64_t v15 = v1 - v8 + 0xfffffffc; // 0x17cc
            uint32_t v16 = (int32_t)v15; // 0x17e8
            *v3 = (char)v15;
            *v6 = (char)(v16 / 256);
            *v5 = (char)(v16 / 0x10000);
            *v7 = (char)(v16 / 0x1000000);
            if (v4 == 0) {
                // break -> 0x1818
                break;
            }
            // 0x17a0
            v2 = v4;
            goto lab_0x17a0_2;
        }
    }
    // 0x1818
    return 0;
  lab_0x1870:;
    int32_t v17 = *(int32_t *)&g47; // 0x1878
    uint32_t v18 = z - *(int32_t *)&g31 + *(int32_t *)&g13 + v17; // 0x1884
    *v3 = (char)v18;
    *v6 = (char)(v18 / 256);
    *v5 = (char)(v18 / 0x10000);
    *v7 = (char)(v18 / 0x1000000);
    if (v4 == 0) {
        return 0;
    }
    // 0x17a0
    v2 = v4;
    goto lab_0x17a0_2;
}

// Address range: 0x18b8 - 0x18c8
int64_t H(void) {
    // 0x18b8
    int64_t v1; // 0x18b8
    return ap((int32_t)v1, g16);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x18c8 - 0x1950
// Line range:    161 - 167
// Demangled:     long long
int32_t x(int32_t d, uint32_t a) {
    if (d != 0 && d != -1) {
        int32_t * v1 = (int32_t *)(int64_t)g16; // 0x18e8
        *v1 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)d;
        int32_t v2 = d >> 8; // 0x18f0
        if (v2 != -1 == (v2 != 0)) {
            *v1 = (int32_t)&g17;
            *(char *)(int64_t)g16 = (char)v2;
            int32_t v3 = v2 >> 8; // 0x18f0
            int32_t v4 = v3; // 0x18fc
            while (v3 != -1 == (v3 != 0)) {
                // 0x18dc
                *v1 = (int32_t)&g17;
                *(char *)(int64_t)g16 = (char)v4;
                v3 = v4 >> 8;
                v4 = v3;
            }
        }
    }
    // 0x1900
    *(char *)(int64_t)g16 = (char)a;
    *(char *)(int64_t)(int32_t)&g17 = (char)(a / 256);
    *(char *)(int64_t)(int32_t)&g18 = (char)(a / 0x10000);
    *(char *)(int64_t)(int32_t)&g19 = (char)(a / 0x1000000);
    *(int32_t *)(int64_t)g16 = (int32_t)&g20;
    return g16;
}

// Address range: 0x1950 - 0x195c
int64_t M(void) {
    // 0x1950
    int64_t v1; // 0x1950
    return x(184, (int32_t)v1);
}

// Address range: 0x1960 - 0x196c
int64_t I(void) {
    // 0x1960
    int64_t v1; // 0x1960
    return x(233, (int32_t)v1);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1970 - 0x19ac
// Line range:    174 - 176
int32_t aa(int32_t s, int32_t a) {
    int32_t * v1 = (int32_t *)(int64_t)g16; // 0x1994
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -123;
    int64_t v2 = 3; // 0x1988
    int32_t v3 = 0xfc085; // 0x199c
    v3 >>= 8;
    v2 = v2 + 0xffffffff & 0xffffffff;
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)v3;
    while (v2 != 1) {
        // 0x1984
        v3 >>= 8;
        v2 = v2 + 0xffffffff & 0xffffffff;
        *v1 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)v3;
    }
    // 0x19a4
    return x(s + 132, a);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x19b0 - 0x1a78
// Line range:    178 - 184
int32_t aq(int32_t a) {
    int32_t * v1 = (int32_t *)(int64_t)g16; // 0x19c4
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = 57;
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -63;
    x(184, 0);
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = 15;
    if (a == -144 || a == -145) {
        // 0x1a50
        *(int32_t *)(int64_t)g16 = (int32_t)&g17;
        *(char *)(int64_t)g16 = -64;
        return 0;
    }
    int32_t v2 = a + 144; // 0x1a28
    *v1 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)v2;
    v2 >>= 8;
    while (v2 != -1 == (v2 != 0)) {
        // 0x1a2c
        *v1 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)v2;
        v2 >>= 8;
    }
    // 0x1a50
    *(int32_t *)(int64_t)g16 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -64;
    return 0;
}

// Address range: 0x1a78 - 0x1b04
int64_t W(int64_t a1) {
    // 0x1a78
    int64_t v1; // 0x1a78
    int32_t v2 = v1; // 0x1a78
    int32_t v3; // 0x1a78
    int64_t v4; // 0x1a78
    if (v2 == -131 || v2 == -132) {
        // 0x1a78
        v3 = v1;
    } else {
        int64_t v5 = v1 + 131; // 0x1a84
        int32_t * v6 = (int32_t *)(int64_t)g16; // 0x1a9c
        *v6 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)v5;
        int32_t v7 = (int32_t)v5 >> 8; // 0x1aa4
        if (v7 != -1 == (v7 != 0)) {
            *v6 = (int32_t)&g17;
            *(char *)(int64_t)g16 = (char)v7;
            int32_t v8 = v7 >> 8; // 0x1aa4
            int32_t v9 = v8; // 0x1ab0
            while (v8 != -1 == (v8 != 0)) {
                // 0x1a90
                *v6 = (int32_t)&g17;
                *(char *)(int64_t)g16 = (char)v9;
                v8 = v9 >> 8;
                v9 = v8;
            }
        }
        // 0x1ab4
        v3 = *(int32_t *)&v4;
    }
    int32_t v10 = v3; // 0x1ab8
    if (v10 == 0 || v10 > 511) {
        int32_t * v11 = (int32_t *)(0x100000000 * v4 + 0x400000000 >> 32); // 0x1adc
        uint32_t result = *v11; // 0x1adc
        *v11 = x(5, result);
        return result;
    }
    // 0x1af8
    return x(133, v10);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1b08 - 0x1ce8
// Line range:    300 - 302
int32_t X(int32_t s) {
    if (s == 1) {
        // 0x1ce4
        return ab(1);
    }
    int32_t v1 = s - 1; // 0x1b1c
    X(v1);
    if (g8 != v1) {
        // 0x1c3c
        return g8;
    }
    int32_t v2 = s - 5; // 0x1b3c
    int64_t v3 = 0; // 0x1c64
    int64_t v4; // 0x1b08
    while (true) {
        int64_t v5 = v3;
        while (true) {
            av();
            if (v1 > 8) {
                // break (via goto) -> 0x1c58
                goto lab_0x1c58;
            }
            int32_t * v6 = (int32_t *)(int64_t)g16; // 0x1b88
            *v6 = (int32_t)&g17;
            *(char *)(int64_t)g16 = 80;
            X(v1);
            *v6 = (int32_t)&g17;
            *(char *)(int64_t)g16 = 89;
            while (v2 != 1 && v2 != 0) {
                // 0x1bc4
                if ((int32_t)&g26 != 1 && (int32_t)&g26 >= 1) {
                    *v6 = (int32_t)&g17;
                    *(char *)(int64_t)g16 = (char)g25;
                    int32_t v7 = g25 >> 8; // 0x1bec
                    int32_t v8 = v7; // 0x1bf8
                    while (v7 != -1 == (v7 != 0)) {
                        // 0x1bd8
                        *v6 = (int32_t)&g17;
                        *(char *)(int64_t)g16 = (char)v8;
                        v7 = v8 >> 8;
                        v8 = v7;
                    }
                }
                if (g35 != 37) {
                    goto lab_0x1b58;
                }
                // 0x1c04
                *(int32_t *)(int64_t)g16 = (int32_t)&g17;
                *(char *)(int64_t)g16 = -110;
                v4 = v5;
                if (g8 != v1) {
                    // break (via goto) -> 0x1c30
                    goto lab_0x1c30_2;
                }
                av();
                if (v1 > 8) {
                    // break (via goto) -> 0x1c58
                    goto lab_0x1c58;
                }
                // 0x1b7c
                v6 = (int32_t *)(int64_t)g16;
                *v6 = (int32_t)&g17;
                *(char *)(int64_t)g16 = 80;
                X(v1);
                *v6 = (int32_t)&g17;
                *(char *)(int64_t)g16 = 89;
            }
            // 0x1c78
            aq(g25);
          lab_0x1b58:
            // 0x1b58
            v4 = v5;
            if (g8 != v1) {
                // break (via goto) -> 0x1c30
                goto lab_0x1c30_2;
            }
        }
      lab_0x1c58:
        // 0x1c58
        v3 = aa(g25, (int32_t)v5);
        X(v1);
        v4 = v3;
        if (g8 != v1) {
            // break -> 0x1c30
            break;
        }
    }
  lab_0x1c30_2:
    // 0x1c30
    if (v4 == 0) {
        // 0x1c3c
        return g8;
    }
    int32_t v9 = s - 9; // 0x1c34
    if (v9 == 0 || v9 < 0 != (8 - s & v1) < 0) {
        // 0x1c3c
        return g8;
    }
    int32_t v10 = aa(g25, (int32_t)v4); // 0x1c8c
    x(184, g25 ^ 1);
    x(233, 5);
    ap(v10, g16);
    return x(184, g25);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x1ce8 - 0x2250
// Line range:    195 - 130
int32_t ab(int32_t s) {
    uint32_t v1 = g35; // 0x1d08
    int64_t v2 = v1; // 0x1d08
    int32_t * v3; // 0x1ce8
    int32_t * v4; // 0x1ce8
    int64_t v5; // 0x2074
    int64_t v6; // 0x1ce8
    int64_t v7; // 0x1ce8
    int64_t v8; // 0x1ce8
    int64_t v9; // 0x1ce8
    int32_t v10; // 0x1ce8
    int64_t v11; // 0x1ce8
    char v12; // 0x1ce8
    if (v1 == 34) {
        // 0x1e90
        x(184, *(int32_t *)&g47 + (int32_t)g37);
        if (g45 != 34) {
            // 0x1f00
            if (g45 == 92) {
                // 0x1f08
                an_part_1((int64_t)&g60);
            }
            // 0x1ed8
            *(int32_t *)g37 = (int32_t)&g38;
            *(char *)(int64_t)*(int32_t *)&g37 = (char)g45;
            w((int64_t)&g60);
            int32_t v13 = g45; // 0x1ef4
            while (v13 != 34) {
                int32_t v14 = v13; // 0x1f04
                if (v13 == 92) {
                    // 0x1f08
                    an_part_1((int64_t)&g60);
                    v14 = g45;
                }
                // 0x1ed8
                *(int32_t *)g37 = (int32_t)&g38;
                *(char *)(int64_t)*(int32_t *)&g37 = (char)v14;
                w((int64_t)&g60);
                v13 = g45;
            }
        }
        // 0x1f10
        *(char *)(0x100000000 * g37 >> 32) = 0;
        *(int32_t *)g37 = (int32_t)&g41;
        w((int64_t)&g60);
        av();
        v7 = v2;
        goto lab_0x1f3c;
    } else {
        // 0x1d14
        av();
        if (v1 == 2) {
            // 0x1ff8
            x(184, g25);
            v7 = 2;
            goto lab_0x1f3c;
        } else {
            if (g8 == 2) {
                // 0x2010
                ab(0);
                x(185, 0);
                if (v1 == 33) {
                    // 0x222c
                    aq(g25);
                    v7 = 33;
                    goto lab_0x1f3c;
                } else {
                    if ((int32_t)&g26 == 1 || (int32_t)&g26 < 1) {
                        // 0x2248
                        v7 = v2;
                        goto lab_0x1f3c;
                    } else {
                        int32_t * v15 = (int32_t *)(int64_t)g16; // 0x204c
                        *v15 = (int32_t)&g17;
                        *(char *)(int64_t)g16 = (char)g25;
                        int32_t v16 = g25 >> 8; // 0x2054
                        v8 = v2;
                        if (v16 != -1 == (v16 != 0)) {
                            *v15 = (int32_t)&g17;
                            *(char *)(int64_t)g16 = (char)v16;
                            int32_t v17 = v16 >> 8; // 0x2054
                            int32_t v18 = v17; // 0x2060
                            v8 = v2;
                            while (v17 != -1 == (v17 != 0)) {
                                // 0x2040
                                *v15 = (int32_t)&g17;
                                *(char *)(int64_t)g16 = (char)v18;
                                v17 = v18 >> 8;
                                v18 = v17;
                                v8 = v2;
                            }
                        }
                        goto lab_0x2064;
                    }
                }
            } else {
                switch (v1) {
                    case 40: {
                        // 0x1f98
                        X(11);
                        av();
                        v7 = 40;
                        goto lab_0x1f3c;
                    }
                    case 42: {
                        // 0x2070
                        av();
                        av();
                        av();
                        av();
                        if (g35 == 42) {
                            // 0x2120
                            av();
                            av();
                            av();
                            av();
                            ab(0);
                            v7 = 0;
                            v9 = 0;
                            if (g35 == 61) {
                                goto lab_0x214c;
                            } else {
                                goto lab_0x1f3c;
                            }
                        } else {
                            // 0x208c
                            v5 = g35;
                            ab(0);
                            v9 = v5;
                            if (g35 == 61) {
                                goto lab_0x214c;
                            } else {
                                // 0x20a4
                                v7 = 0;
                                switch (g35) {
                                    case 0: {
                                        goto lab_0x1f3c;
                                    }
                                    case 256: {
                                        int32_t * v19 = (int32_t *)(int64_t)g16;
                                        v3 = v19;
                                        v4 = v19;
                                        v12 = -117;
                                        goto lab_0x20d4;
                                    }
                                    default: {
                                        int32_t * v20 = (int32_t *)(int64_t)g16;
                                        *v20 = (int32_t)&g17;
                                        *(char *)(int64_t)g16 = 15;
                                        v3 = (int32_t *)(int64_t)g16;
                                        v4 = v20;
                                        v12 = -66;
                                        goto lab_0x20d4;
                                    }
                                }
                            }
                        }
                    }
                    case 38: {
                        // 0x2108
                        W((int64_t)&g60);
                        av();
                        v7 = 38;
                        goto lab_0x1f3c;
                    }
                    default: {
                        // 0x1d5c
                        if (((int32_t)(g35 == 61) & s) == 0) {
                            // 0x1d70
                            v6 = v2;
                            v10 = 0;
                            if (g35 == 40) {
                                goto lab_0x1da4;
                            } else {
                                // 0x1d78
                                W((int64_t)&g60);
                                if (g8 == 11) {
                                    // 0x21dc
                                    W((int64_t)&g60);
                                    int64_t v21; // 0x1ce8
                                    if ((int32_t)&g26 != 1 && (int32_t)&g26 >= 1) {
                                        int32_t * v22 = (int32_t *)(int64_t)g16; // 0x220c
                                        *v22 = (int32_t)&g17;
                                        *(char *)(int64_t)g16 = (char)g25;
                                        int32_t v23 = g25 >> 8; // 0x2214
                                        v21 = (int64_t)&g17;
                                        if (v23 != -1 == (v23 != 0)) {
                                            *v22 = (int32_t)&g17;
                                            *(char *)(int64_t)g16 = (char)v23;
                                            int32_t v24 = v23 >> 8; // 0x2214
                                            int32_t v25 = v24; // 0x2220
                                            v21 = (int64_t)&g17;
                                            while (v24 != -1 == (v24 != 0)) {
                                                // 0x2200
                                                *v22 = (int32_t)&g17;
                                                *(char *)(int64_t)g16 = (char)v25;
                                                v24 = v25 >> 8;
                                                v25 = v24;
                                                v21 = (int64_t)&g17;
                                            }
                                        }
                                    }
                                    // 0x2224
                                    av();
                                    v11 = v21;
                                }
                                goto lab_0x1d90;
                            }
                        } else {
                            // 0x1fd8
                            av();
                            X(11);
                            W((int64_t)&g60);
                            goto lab_0x1d90;
                        }
                    }
                }
            }
        }
    }
  lab_0x1f3c:
    // 0x1f3c
    if (g35 != 40) {
        // 0x1f44
        return 0;
    }
    // 0x1fb0
    *(int32_t *)(int64_t)g16 = (int32_t)&g17;
    *(char *)(int64_t)g16 = 80;
    int64_t v26 = (int64_t)&g17; // 0x1fd4
    int64_t v27; // 0x1ce8
    int64_t v28 = v27; // 0x1fd4
    v6 = v7;
    v10 = 1;
    goto lab_0x1da4;
  lab_0x1da4:;
    int32_t v29 = x(0xec81, 0); // 0x1dac
    av();
    int64_t v30 = 0; // 0x1dc4
    char v31 = 0; // 0x1dc4
    char v32 = 0; // 0x1dc4
    char v33 = 0; // 0x1dc4
    char v34 = 0; // 0x1dc4
    int64_t v35 = 0; // 0x1dc4
    if (g35 != 41) {
        uint64_t v36; // 0x1df0
        int64_t v37; // 0x1df0
        while (true) {
          lab_0x1de0_2:
            // 0x1de0
            X(11);
            v36 = v30 + 4;
            v37 = v36 & 0xffffffff;
            x(0x248489, (int32_t)v30);
            switch (g35) {
                case 44: {
                    // 0x1e04
                    av();
                    if (g35 == 41) {
                        // break -> 0x1e14
                        break;
                    }
                    // 0x1de0
                    v30 = v37;
                    goto lab_0x1de0_2;
                }
                case 41: {
                    goto lab_0x1e14;
                }
                default: {
                    // 0x1de0
                    v30 = v37;
                    goto lab_0x1de0_2;
                }
            }
        }
      lab_0x1e14:;
        int64_t v38 = __asm_ubfx(v28, v37, 8, 8); // 0x1e18
        v31 = v36 / 0x1000000;
        v32 = __asm_ubfx(v26, v37, 16, 8);
        v33 = v38;
        v34 = v36;
        v35 = v37;
    }
    int64_t v39 = 0x100000000 * (int64_t)v29;
    *(char *)(int64_t)v29 = v34;
    *(char *)(v39 + 0x100000000 >> 32) = v33;
    *(char *)(v39 + 0x200000000 >> 32) = v32;
    *(char *)(v39 + 0x300000000 >> 32) = v31;
    av();
    if (v10 != 0) {
        // 0x1e58
        x(0x2494ff, (int32_t)v35);
        // 0x1e6c
        return x(0xc481, (int32_t)(v35 + 4 & 0xffffffff));
    }
    int32_t * v40 = (int32_t *)(0x100000000 * v6 + 0x400000000 >> 32); // 0x1f6c
    *v40 = x(232, *v40);
    if (v35 == 0) {
        // 0x1f44
        return 0;
    }
    // 0x1e6c
    return x(0xc481, (int32_t)v35);
  lab_0x2064:;
    // 0x2064
    int64_t v41; // 0x1ce8
    v27 = v41;
    v7 = v8;
    goto lab_0x1f3c;
  lab_0x1d90:
    // 0x1d90
    v26 = v11;
    v6 = v2;
    v10 = 0;
    if (g35 != 40) {
        // 0x1f44
        return 0;
    }
    goto lab_0x1da4;
  lab_0x214c:
    // 0x214c
    av();
    int32_t * v42 = (int32_t *)(int64_t)g16; // 0x215c
    *v42 = (int32_t)&g17;
    *(char *)(int64_t)g16 = 80;
    X(11);
    *v42 = (int32_t)&g17;
    *(char *)(int64_t)g16 = 89;
    int64_t v43 = v9 == 256 ? 393 : 392;
    *v42 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)v43;
    v41 = (int64_t)&g17;
    v8 = v9;
    while ((v43 & 256) != 0) {
        // 0x21a0
        v43 = 1;
        *v42 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)v43;
        v41 = (int64_t)&g17;
        v8 = v9;
    }
    goto lab_0x2064;
  lab_0x20d4:;
    int32_t v44 = *v4; // 0x20d4
    uint32_t v45 = v44 + 1; // 0x20dc
    *v4 = v45;
    *(char *)(int64_t)v44 = v12;
    *v3 = (int32_t)&g17;
    v27 = v45;
    v7 = v5;
    goto lab_0x1f3c;
}

// Address range: 0x2250 - 0x2258
int64_t B(void) {
    // 0x2250
    return X(11);
}

// Address range: 0x2258 - 0x2278
int64_t ac(int64_t a1) {
    // 0x2258
    X(11);
    return aa(0, 0);
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2278 - 0x24f0
// Line range:    410 - 427
int32_t ar(int32_t s) {
    int32_t v1 = g35; // 0x22b0
    int32_t result = v1; // 0x22cc
    if (v1 != 256 && s == 0 != v1 != -1) {
      lab_0x2438:
        // 0x2438
        return result;
    }
    bool v2 = v1 == 256; // 0x2278
    int32_t v3 = v1; // 0x22b0
    while (true) {
        int32_t v4 = v3; // 0x2418
        bool v5 = v2; // 0x2278
        while (true) {
            // 0x22d0
            if (v5) {
                // break -> 0x2458
                break;
            }
            // 0x22d4
            *(int32_t *)(int64_t)v4 = g16;
            av();
            av();
            int64_t v6 = 8; // 0x2304
            if (g35 != 41) {
                while (true) {
                  lab_0x2308:;
                    int64_t v7 = v6; // 0x2278
                    while (true) {
                      lab_0x2308_2:
                        // 0x2308
                        *(int32_t *)(int64_t)g35 = (int32_t)v7;
                        int64_t v8 = v7 + 4 & 0xffffffff; // 0x230c
                        av();
                        v6 = v8;
                        switch (g35) {
                            case 44: {
                                // 0x2320
                                av();
                                v7 = v8;
                                if (g35 == 41) {
                                    // break (via goto) -> 0x2334
                                    goto lab_0x2334;
                                }
                                goto lab_0x2308_2;
                            }
                            case 41: {
                                goto lab_0x2334;
                            }
                            default: {
                                goto lab_0x2308;
                            }
                        }
                    }
                }
            }
          lab_0x2334:
            // 0x2334
            av();
            *g10 = 0;
            *(int32_t *)(int64_t)g33 = 0;
            int32_t * v9 = (int32_t *)(int64_t)g16;
            int64_t v10 = 0xe58955; // 0x235c
            int64_t v11 = 3;
            *v9 = (int32_t)&g17;
            *(char *)(int64_t)g16 = (char)v10;
            v10 = (int32_t)v10 >> 8;
            int64_t v12 = v11 + 0xffffffff & 0xffffffff; // 0x237c
            while (v11 != 1) {
                // 0x2360
                v11 = v12;
                *v9 = (int32_t)&g17;
                *(char *)(int64_t)g16 = (char)v10;
                v10 = (int32_t)v10 >> 8;
                v12 = v11 + 0xffffffff & 0xffffffff;
            }
            int32_t v13 = x(0xec81, 0); // 0x2388
            S(0);
            ap(g33, g16);
            *v9 = (int32_t)&g17;
            *(char *)(int64_t)g16 = -55;
            *v9 = (int32_t)&g17;
            *(char *)(int64_t)g16 = -61;
            uint32_t v14 = *(int32_t *)&g10; // 0x23f8
            *(char *)(int64_t)v13 = (char)v14;
            *(char *)(int64_t)(v13 + 1) = (char)(v14 / 256);
            *(char *)(int64_t)(v13 + 2) = (char)(v14 / 0x10000);
            *(char *)(int64_t)(v13 + 3) = (char)(v14 / 0x1000000);
            v4 = g35;
            v5 = v4 == 256;
            result = v4;
            if (v4 != 256 && s == 0 != v4 != -1) {
                return result;
            }
        }
        // 0x2458
        av();
        if (g35 != 59) {
            int64_t v15; // 0x2278
            while (true) {
                // 0x24b0
                v15 = g35;
                if (s == 0) {
                    // 0x24b4
                    *(int32_t *)v15 = *(int32_t *)&g37;
                    *(int32_t *)g37 = (int32_t)&g41;
                    av();
                    if (g35 == 44) {
                        // break -> 0x24dc
                        break;
                    }
                } else {
                    // 0x2478
                    *g10 = (int32_t)&g11;
                    *(int32_t *)v15 = -4 - *(int32_t *)&g10;
                    av();
                    if (g35 == 44) {
                        // break -> 0x24dc
                        break;
                    }
                }
                // 0x24a0
                if (g35 == 59) {
                    // break (via goto) -> 0x24e8
                    goto lab_0x24e8;
                }
            }
            // 0x24dc
            av();
            while (g35 != 59) {
                // 0x24b0
                while (true) {
                    // 0x24b0
                    v15 = g35;
                    if (s == 0) {
                        // 0x24b4
                        *(int32_t *)v15 = *(int32_t *)&g37;
                        *(int32_t *)g37 = (int32_t)&g41;
                        av();
                        if (g35 == 44) {
                            // break -> 0x24dc
                            break;
                        }
                    } else {
                        // 0x2478
                        *g10 = (int32_t)&g11;
                        *(int32_t *)v15 = -4 - *(int32_t *)&g10;
                        av();
                        if (g35 == 44) {
                            // break -> 0x24dc
                            break;
                        }
                    }
                    // 0x24a0
                    if (g35 == 59) {
                        // break (via goto) -> 0x24e8
                        goto lab_0x24e8;
                    }
                }
                // 0x24dc
                av();
            }
        }
      lab_0x24e8:
        // 0x24e8
        av();
        v3 = g35;
        v2 = v3 == 256;
        result = v3;
        if (v3 != 256 && s == 0 != v3 != -1) {
            // break -> 0x2438
            break;
        }
    }
    // 0x2438
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x24f0 - 0x27a0
// Line range:    343 - 368
int32_t S(int32_t s) {
    // 0x24f0
    int32_t v1; // 0x24f0
    int32_t v2; // 0x24f0
    switch (g35) {
        case 288: {
            // 0x2698
            av();
            av();
            X(11);
            v1 = aa(0, 0);
            av();
            S(s);
            int32_t result; // 0x24f0
            if (g35 == 312) {
                // 0x2738
                av();
                int32_t v3 = x(233, 0); // 0x2748
                ap(v1, g16);
                S(s);
                result = ap(v3, g16);
            } else {
                // 0x26d0
                result = ap(v1, g16);
            }
            // 0x2554
            return result;
        }
        case 504: {
        }
        case 352: {
            // 0x2568
            av();
            av();
            if (g35 == 352) {
                // 0x2778
                X(11);
                v1 = aa(0, 0);
                v2 = g16;
            } else {
                // 0x2578
                if (g35 != 59) {
                    // 0x2584
                    X(11);
                }
                // 0x258c
                av();
                v1 = 0;
                if (g35 != 59) {
                    // 0x25b0
                    X(11);
                    v1 = aa(0, 0);
                }
                // 0x25c8
                av();
                v2 = g16;
                if (g35 != 41) {
                    int32_t v4 = x(233, 0); // 0x25e4
                    X(11);
                    x(233, g16 - 5 - g16);
                    ap(v4, g16);
                    v2 = v4 + 4;
                }
            }
            // break -> 0x261c
            break;
        }
        case 123: {
            // 0x26e8
            av();
            ar(1);
            if (g35 != 125) {
                S(s);
                while (g35 != 125) {
                    // 0x2704
                    S(s);
                }
            }
            // 0x2554
            return av();
        }
        case 448: {
            // 0x2660
            av();
            if (g35 != 59) {
                // 0x2670
                X(11);
            }
            uint32_t v5 = g33;
            *(int32_t *)(int64_t)v5 = x(233, v5);
            // 0x2554
            return av();
        }
        case 400: {
            // 0x2720
            av();
            int64_t v6; // 0x24f0
            *(int32_t *)(int64_t)s = x(233, (int32_t)v6);
            // 0x2554
            return av();
        }
        case 59: {
            // 0x2554
            return av();
        }
        default: {
            // 0x2548
            X(11);
            // 0x2554
            return av();
        }
    }
    // 0x261c
    av();
    S((int32_t)(int64_t)&v1);
    x(233, v2 - 5 - g16);
    return ap(v1, g16);
}

// Address range: 0x27a0 - 0x27fc
int64_t ax(void) {
    // 0x27a0
    int64_t v1; // 0x27a0
    uint32_t v2 = (int32_t)v1; // 0x27b0
    *(char *)(0x100000000 * g37 >> 32) = (char)v1;
    *(char *)(int64_t)(int32_t)&g38 = (char)(v2 / 256);
    *(char *)(int64_t)(int32_t)&g39 = (char)(v2 / 0x10000);
    *(char *)(int64_t)(int32_t)&g40 = (char)(v2 / 0x1000000);
    *(int32_t *)g37 = (int32_t)&g41;
    return v1 & 0xffffffff;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2800 - 0x2964
// Line range:    455 - 462
int32_t ad(uint32_t d, uint32_t a) {
    int64_t v1 = a;
    uint32_t v2 = d + 0x8048000; // 0x2820
    int64_t v3 = v2; // 0x2820
    int64_t v4; // 0x2800
    int64_t v5 = __asm_ubfx(v4, v3, 8, 8); // 0x2824
    int64_t v6 = __asm_ubfx(v4, v3, 16, 8); // 0x2828
    *(char *)(int64_t)*(int32_t *)&g37 = (char)d;
    *(char *)(int64_t)(int32_t)&g38 = (char)(d / 256);
    *(char *)(int64_t)(int32_t)&g39 = (char)(d / 0x10000);
    *(char *)(int64_t)(int32_t)&g40 = (char)(d / 0x1000000);
    int32_t * v7 = (int32_t *)g37; // 0x2870
    char v8 = v6; // 0x2894
    *(char *)(int64_t)(int32_t)&g43 = v8;
    *(char *)(int64_t)(int32_t)&g44 = (char)(v2 / 0x1000000);
    *v7 = (int32_t)&g41;
    *(char *)(int64_t)(int32_t)&g41 = (char)v2;
    *(char *)(int64_t)(int32_t)&g42 = (char)v5;
    int64_t v9 = __asm_ubfx((int64_t)(int32_t)&g42, v1, 16, 8); // 0x28d0
    *(char *)(int64_t)(int32_t)&g43 = v8;
    int64_t v10 = __asm_ubfx(v6, v1, 8, 8); // 0x28d8
    *(char *)(int64_t)(int32_t)&g41 = (char)a;
    *(char *)(int64_t)(int32_t)&g42 = (char)v10;
    *(char *)(int64_t)(int32_t)&g43 = (char)v9;
    *(char *)(int64_t)(int32_t)&g44 = (char)(a / 0x1000000);
    *v7 = (int32_t)&g41;
    return d;
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2968 - 0x2d3c
// Line range:    463 - 453
int32_t ae(int32_t s) {
    int64_t v1 = (int64_t)*(int32_t *)&g6; // 0x29b4
    int64_t v2 = (int64_t)*(int32_t *)&g34; // 0x29b4
    int64_t v3 = 0; // 0x29b4
    char v4; // 0x2968
    int64_t v5; // 0x2968
    int64_t v6; // 0x2968
    int64_t v7; // 0x2968
    int64_t v8; // 0x2968
    int64_t v9; // 0x2968
    int64_t v10; // 0x2968
    int64_t v11; // 0x2968
    int64_t v12; // 0x2968
    int64_t v13; // 0x2968
    while (true) {
      lab_0x29b8_2:;
        int64_t v14 = v2 + 1; // 0x29b8
        int64_t v15 = v14 & 0xffffffff; // 0x29b8
        int64_t v16 = 0x100000000 * v14 >> 32; // 0x29bc
        char v17 = *(char *)v16; // 0x29c0
        v4 = v17;
        v6 = v16;
        v12 = v1;
        v8 = v3;
        v10 = v15;
        v5 = 32;
        v7 = v16;
        v13 = v1;
        v9 = v3;
        v11 = v15;
        if (v17 == 32) {
            goto lab_0x2bb4;
        } else {
            goto lab_0x29cc;
        }
    }
  lab_0x2bd8_2:;
    // 0x2bd8
    int64_t result; // 0x2968
    return result;
  lab_0x2bb4:;
    int64_t v18 = v5; // 0x2bb8
    int64_t v19 = v7; // 0x2bb8
    int64_t v20 = v13; // 0x2bb8
    int64_t v21 = v11 & 0xffffffff; // 0x2bb8
    int64_t v22 = v9; // 0x2bb8
    int64_t v23 = v11; // 0x2bb8
  lab_0x29fc:
    // 0x29fc
    v2 = v21;
    int64_t v24 = v20;
    int32_t v25 = v2; // 0x29fc
    result = v18;
    if (v25 == (int32_t)v24) {
        // break -> 0x2bd8
        goto lab_0x2bd8_2;
    }
    int64_t v26 = v23;
    int64_t v27 = v22;
    int64_t v28 = v19;
    int32_t v29 = v26; // 0x2a0c
    int32_t v30 = 8 * (v29 - *(int32_t *)&g34) + g9; // 0x2a10
    int32_t v31 = v30 + 248; // 0x2a18
    *(int32_t *)(int64_t)(uint32_t)g35 = v31;
    uint32_t v32 = *(int32_t *)(int64_t)(v30 + 252); // 0x2a28
    int32_t v33 = *(int32_t *)(int64_t)v31; // 0x2a2c
    v1 = v24;
    v3 = v27;
    int64_t v34; // 0x2968
    if (v32 == 0 || v33 == 1) {
        goto lab_0x29b8_2;
    } else {
        if (v33 == 0) {
            if (s == 0) {
                // 0x2bf4
                memcpy((int64_t *)(0x100000000 * g37 >> 32), (int64_t *)v28, v25 - v29);
                *(int32_t *)g37 = v25 + 1 - v29 + *(int32_t *)&g37;
                v1 = (int64_t)*(int32_t *)&g6;
                v3 = v27;
                goto lab_0x29b8_2;
            } else {
                if (s == 1) {
                    int64_t v35 = v27 + 22; // 0x2c2c
                    uint32_t v36 = (int32_t)v35; // 0x2c3c
                    *(char *)(0x100000000 * g37 >> 32) = (char)v35;
                    *(char *)(int64_t)(int32_t)&g38 = (char)(v36 / 256);
                    *(char *)(int64_t)(int32_t)&g39 = (char)(v36 / 0x10000);
                    *(char *)(int64_t)(int32_t)&g40 = (char)(v36 / 0x1000000);
                    int32_t * v37 = (int32_t *)g37; // 0x2c88
                    *v37 = (int32_t)&g41;
                    *(char *)(int64_t)(int32_t)&g41 = 16;
                    *(char *)(int64_t)(int32_t)&g42 = 0;
                    *(char *)(int64_t)(int32_t)&g43 = 0;
                    *(char *)(int64_t)(int32_t)&g44 = 0;
                    *v37 = (int32_t)&g41;
                    v1 = (int64_t)*(int32_t *)&g6;
                    v3 = v2 + 1 + v27 - v26 & 0xffffffff;
                    goto lab_0x29b8_2;
                } else {
                    int64_t v38 = v27 + 1; // 0x2a5c
                    int64_t v39 = v32;
                    int64_t v40 = 0x100000000 * v39; // 0x2a74
                    char v41 = *(char *)(v40 - 0x100000000 >> 32); // 0x2a98
                    char * v42 = (char *)(v40 + 0x200000000 >> 32); // 0x2a9c
                    unsigned char v43 = *v42; // 0x2a9c
                    char * v44 = (char *)(v40 + 0x300000000 >> 32); // 0x2aa4
                    unsigned char v45 = *v44; // 0x2aa4
                    char * v46 = (char *)(v40 >> 32); // 0x2aac
                    unsigned char v47 = *v46; // 0x2aac
                    uint64_t v48 = (int64_t)(v41 != 5); // 0x2ab0
                    char * v49 = (char *)(v40 + 0x100000000 >> 32); // 0x2ab4
                    unsigned char v50 = *v49; // 0x2ab4
                    int64_t v51 = (256 * v38 & 0xffffff00 | (int64_t)(v41 != 5)) + 1; // 0x2ac4
                    *v46 = 4 * (char)(v41 != 5);
                    *v49 = (char)(v48 / 64);
                    uint32_t v52 = (int32_t)v51; // 0x2ae4
                    *v42 = (char)(v48 / 0x4000);
                    *v44 = (char)(v48 / 0x400000);
                    int32_t v53 = *(int32_t *)&g13; // 0x2afc
                    int32_t v54 = *(int32_t *)&g47; // 0x2b08
                    int64_t v55 = 0x10000 * (int64_t)v43 | (int64_t)v47 | 0x1000000 * (int64_t)v45 | 256 * (int64_t)v50; // 0x2b10
                    uint32_t v56 = (int32_t)v39 - *(int32_t *)&g31 + v53 + v54; // 0x2b18
                    *(char *)(int64_t)*(int32_t *)&g37 = (char)v56;
                    *(char *)(int64_t)(int32_t)&g38 = (char)(v56 / 256);
                    *(char *)(int64_t)(int32_t)&g39 = (char)(v56 / 0x10000);
                    *(char *)(int64_t)(int32_t)&g40 = (char)(v56 / 0x1000000);
                    *(char *)(int64_t)(int32_t)&g41 = (char)v51;
                    *(char *)(int64_t)(int32_t)&g42 = (char)(v52 / 256);
                    *(char *)(int64_t)(int32_t)&g43 = (char)(v52 / 0x10000);
                    *(char *)(int64_t)(int32_t)&g44 = (char)(v52 / 0x1000000);
                    *(int32_t *)g37 = (int32_t)&g41;
                    while (v55 != 0) {
                        // 0x2a74
                        v39 = v55;
                        v40 = 0x100000000 * v39;
                        v41 = *(char *)(v40 - 0x100000000 >> 32);
                        v42 = (char *)(v40 + 0x200000000 >> 32);
                        v43 = *v42;
                        v44 = (char *)(v40 + 0x300000000 >> 32);
                        v45 = *v44;
                        v46 = (char *)(v40 >> 32);
                        v47 = *v46;
                        v48 = (int64_t)(v41 != 5);
                        v49 = (char *)(v40 + 0x100000000 >> 32);
                        v50 = *v49;
                        v51 = (256 * v38 & 0xffffff00 | (int64_t)(v41 != 5)) + 1;
                        *v46 = 4 * (char)(v41 != 5);
                        *v49 = (char)(v48 / 64);
                        v52 = (int32_t)v51;
                        *v42 = (char)(v48 / 0x4000);
                        *v44 = (char)(v48 / 0x400000);
                        v53 = *(int32_t *)&g13;
                        v54 = *(int32_t *)&g47;
                        v55 = 0x10000 * (int64_t)v43 | (int64_t)v47 | 0x1000000 * (int64_t)v45 | 256 * (int64_t)v50;
                        v56 = (int32_t)v39 - *(int32_t *)&g31 + v53 + v54;
                        *(char *)(int64_t)*(int32_t *)&g37 = (char)v56;
                        *(char *)(int64_t)(int32_t)&g38 = (char)(v56 / 256);
                        *(char *)(int64_t)(int32_t)&g39 = (char)(v56 / 0x10000);
                        *(char *)(int64_t)(int32_t)&g40 = (char)(v56 / 0x1000000);
                        *(char *)(int64_t)(int32_t)&g41 = (char)v51;
                        *(char *)(int64_t)(int32_t)&g42 = (char)(v52 / 256);
                        *(char *)(int64_t)(int32_t)&g43 = (char)(v52 / 0x10000);
                        *(char *)(int64_t)(int32_t)&g44 = (char)(v52 / 0x1000000);
                        *(int32_t *)g37 = (int32_t)&g41;
                    }
                    // 0x2ba0
                    v34 = v38 & 0xffffffff;
                    goto lab_0x2ba0;
                }
            }
        } else {
            // 0x2bc0
            v1 = v24;
            v3 = v27;
            if (s == 0) {
                // 0x2bc4
                ap(v32, v33);
                v34 = v27;
                goto lab_0x2ba0;
            } else {
                goto lab_0x29b8_2;
            }
        }
    }
  lab_0x29cc:;
    int64_t v57 = v10;
    int64_t v58 = v8;
    int64_t v59 = v12;
    int64_t v60 = v6;
    v5 = v4;
    v7 = v60;
    v13 = v59;
    v9 = v58;
    v11 = v57;
    if (v57 < v59) {
        int32_t v61 = v59;
        int64_t v62 = v60 + 1; // 0x29dc
        int64_t v63 = v57; // 0x29dc
        while (true) {
            int64_t v64 = v62;
            int64_t v65 = v63 + 1; // 0x29ec
            v63 = v65 & 0xffffffff;
            v62 = v64 + 1;
            v18 = v62;
            v19 = v60;
            v20 = v59;
            v21 = v63;
            v22 = v58;
            v23 = v57;
            if (*(char *)v64 == 32) {
                goto lab_0x29fc;
            }
            // 0x29e0
            result = v62;
            if ((int32_t)v65 == v61) {
                // break (via goto) -> 0x2bd8
                goto lab_0x2bd8_2;
            }
        }
    }
    goto lab_0x2bb4;
    // 0x29b8
    goto lab_0x29b8_2;
  lab_0x2ba0:;
    int64_t v66 = (int64_t)*(int32_t *)&g6;
    int64_t v67 = v2 + 1; // 0x2ba0
    int64_t v68 = v67 & 0xffffffff; // 0x2ba0
    int64_t v69 = 0x100000000 * v67 >> 32; // 0x2ba4
    char v70 = *(char *)v69; // 0x2ba8
    v4 = v70;
    v6 = v69;
    v12 = v66;
    v8 = v34;
    v10 = v68;
    v5 = 32;
    v7 = v69;
    v13 = v66;
    v9 = v34;
    v11 = v68;
    if (v70 == 32) {
        goto lab_0x2bb4;
    } else {
        goto lab_0x29cc;
    }
}

// From module:   /mnt/from_holdec/./otcc/otccelf/source.c
// Address range: 0x2d40 - 0x3ca0
// Line range:    506 - 594
int32_t au(int32_t F) {
    uint32_t v1 = g16;
    int32_t * v2 = (int32_t *)(int64_t)v1; // 0x2d7c
    int32_t v3 = *(int32_t *)&g31; // 0x2d90
    *g13 = *(int32_t *)&g37;
    *v2 = (int32_t)&g32;
    *(char *)(int64_t)v3 = 88;
    int64_t v4 = 0x5054; // 0x2d40
    int64_t v5 = 2;
    *v2 = (int32_t)&g17;
    *(char *)(int64_t)g16 = (char)v4;
    v4 = (int32_t)v4 >> 8;
    while (v5 != 1) {
        // 0x2dc0
        v5 = v5 + 0xffffffff & 0xffffffff;
        *v2 = (int32_t)&g17;
        *(char *)(int64_t)g16 = (char)v4;
        v4 = (int32_t)v4 >> 8;
    }
    int32_t v6 = v1 - v3; // 0x2da0
    int32_t v7 = *(int32_t *)(int64_t)(g9 + (int32_t)&g58); // 0x2dfc
    x(232, -5 - g16 + v7);
    *v2 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -119;
    *v2 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -61;
    x(184, 1);
    *v2 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -51;
    *v2 = (int32_t)&g17;
    *(char *)(int64_t)g16 = -128;
    int32_t v8 = *(int32_t *)&g37 + v6; // 0x2e94
    int64_t v9 = v8 + 1; // 0x2ea0
    int64_t v10 = v8 + 11; // 0x2ea8
    *(int64_t *)v9 = 0x2e6f732e6362696c;
    *(int16_t *)(v9 + 8) = 54;
    *(int64_t *)v10 = 0x6f732e6c6462696c;
    *(int32_t *)(v10 + 7) = 0x322e6f;
    int32_t * v11 = (int32_t *)g37; // 0x2ecc
    *v11 = v8 + 22;
    ae(0);
    *(char *)(int64_t)(int32_t)&g40 = 0;
    *(char *)(int64_t)((int32_t)&g40 + 1) = 0;
    *(char *)(int64_t)((int32_t)&g40 + 2) = 0;
    *(char *)(int64_t)((int32_t)&g40 + 3) = 0;
    *(char *)(int64_t)(int32_t)&g41 = 0;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    *v11 = (int32_t)&g41;
    ae(1);
    int32_t v12 = *(int32_t *)&g37; // 0x2fd0
    *(char *)(int64_t)v12 = 1;
    *(char *)(int64_t)(int32_t)&g38 = 0;
    *(char *)(int64_t)(int32_t)&g39 = 0;
    *(char *)(int64_t)(int32_t)&g40 = 0;
    *(char *)(int64_t)(int32_t)&g41 = 0;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    *v11 = (int32_t)&g41;
    int64_t v13 = 2; // 0x30dc
    uint32_t v14 = (int32_t)v13; // 0x30f8
    *(char *)(0x100000000 * (int64_t)&g41 / 0x100000000) = (char)v13;
    *(char *)((0x100000000 * (int64_t)&g41 + 0x100000000) / 0x100000000) = (char)(v14 / 256);
    *(char *)((0x100000000 * (int64_t)&g41 + 0x200000000) / 0x100000000) = (char)(v14 / 0x10000);
    int64_t v15 = v13 + 1; // 0x3118
    *(char *)((0x100000000 * (int64_t)&g41 + 0x300000000) / 0x100000000) = (char)(v14 / 0x1000000);
    *v11 = (int32_t)&g41;
    v13 = v15 & 0xffffffff;
    while ((v12 - (int32_t)&g40) / 0x8000 != (int32_t)v15) {
        // 0x30e4
        v14 = (int32_t)v13;
        *(char *)(0x100000000 * (int64_t)&g41 / 0x100000000) = (char)v13;
        *(char *)((0x100000000 * (int64_t)&g41 + 0x100000000) / 0x100000000) = (char)(v14 / 256);
        *(char *)((0x100000000 * (int64_t)&g41 + 0x200000000) / 0x100000000) = (char)(v14 / 0x10000);
        v15 = v13 + 1;
        *(char *)((0x100000000 * (int64_t)&g41 + 0x300000000) / 0x100000000) = (char)(v14 / 0x1000000);
        *v11 = (int32_t)&g41;
        v13 = v15 & 0xffffffff;
    }
    // 0x3134
    *(char *)(0x100000000 * (int64_t)&g41 / 0x100000000) = 0;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    int32_t * v16 = (int32_t *)g37; // 0x3170
    *v16 = (int32_t)&g41;
    ae(2);
    int32_t v17 = *(int32_t *)&g13; // 0x318c
    int32_t v18 = *(int32_t *)&g31; // 0x3190
    memcpy((int64_t *)(int64_t)v17, (int64_t *)(int64_t)v18, v6);
    int32_t v19 = *(int32_t *)&g37; // 0x31a4
    *(char *)(int64_t)*(int32_t *)&g27 = 127;
    *(char *)(int64_t)(int32_t)&g28 = 69;
    *(char *)(int64_t)(int32_t)&g29 = 76;
    *(char *)(int64_t)(int32_t)&g30 = 70;
    *(char *)(int64_t)(int32_t)&g41 = 3;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    *v16 = (int32_t)&g41;
    ad(144, 19);
    *(char *)(int64_t)*(int32_t *)&g37 = 4;
    *(char *)(int64_t)(int32_t)&g38 = 0;
    *(char *)(int64_t)(int32_t)&g39 = 0;
    *(char *)(int64_t)(int32_t)&g40 = 0;
    *v16 = (int32_t)&g41;
    *(char *)(int64_t)(int32_t)&g41 = 1;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    *v16 = (int32_t)&g41;
    ad(0, v19 - *(int32_t *)&g27);
    *(char *)(int64_t)*(int32_t *)&g37 = 7;
    *(char *)(int64_t)(int32_t)&g38 = 0;
    *(char *)(int64_t)(int32_t)&g39 = 0;
    *(char *)(int64_t)(int32_t)&g40 = 0;
    *(char *)(int64_t)(int32_t)&g41 = 2;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    *v16 = (int32_t)&g41;
    ad(164, 88);
    *(char *)(int64_t)*(int32_t *)&g37 = 6;
    *(char *)(int64_t)(int32_t)&g38 = 0;
    *(char *)(int64_t)(int32_t)&g39 = 0;
    *(char *)(int64_t)(int32_t)&g40 = 0;
    *(int64_t *)(int64_t)(int32_t)&g41 = 0x2d646c2f62696c2f;
    g46 = (char *)0x6f732e78756e696c;
    *(int32_t *)&g48 = 0x322e6f;
    *(char *)(int64_t)(int32_t)&g49 = 1;
    *(char *)(int64_t)(int32_t)&g50 = 0;
    *(char *)(int64_t)(int32_t)&g51 = 0;
    *(char *)(int64_t)(int32_t)&g52 = 0;
    *(char *)(int64_t)(int32_t)&g41 = 0;
    *(char *)(int64_t)(int32_t)&g42 = 0;
    *(char *)(int64_t)(int32_t)&g43 = 0;
    *(char *)(int64_t)(int32_t)&g44 = 0;
    *v16 = (int32_t)&g41;
    struct _IO_FILE * file = fopen((char *)(int64_t)F, "w"); // 0x3c5c
    int32_t data = *(int32_t *)&g27; // 0x3c64
    fwrite((int64_t *)(int64_t)data, 1, v19 - data, file);
    return fclose(file);
}

// Address range: 0x3ca0 - 0x3d18
int64_t __libc_csu_init(void) {
    // 0x3ca0
    int64_t v1; // 0x3ca0
    int64_t result = _init(v1); // 0x3cd4
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x3d04
        return result;
    }
    // 0x3ce4
    return v1 & 0xffffffff;
}

// Address range: 0x3d18 - 0x3d1c
int64_t __libc_csu_fini(void) {
    // 0x3d18
    int64_t result; // 0x3d18
    return result;
}

// Address range: 0x3d1c - 0x3d2c
int64_t _fini(int64_t a1) {
    // 0x3d1c
    int64_t result; // 0x3d1c
    return result;
}

// Address range: 0x400001534 - 0x400001535
int64_t function_400001534(void) {
    // 0x400001534
    int64_t result; // 0x400001534
    return result;
}

// Address range: 0x40000161c - 0x40000161d
int64_t function_40000161c(void) {
    // 0x40000161c
    int64_t result; // 0x40000161c
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// int fclose(FILE * stream);
// int fgetc(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// int isalnum(int c);
// int isspace(int c);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int puts(const char * s);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 56

