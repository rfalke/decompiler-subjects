//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <dlfcn.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int32_t A(int32_t e);
int32_t ab(int32_t j);
int32_t ad(void);
int32_t ae(int32_t g);
int32_t B(int32_t e);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(void);
int32_t E(int32_t e);
int64_t frame_dummy(void);
int64_t function_c80(int64_t a1);
struct _IO_FILE * function_c90(char * filename, char * modes);
int32_t function_ca0(int32_t c);
int64_t * function_cb0(int64_t * handle, char * name);
int32_t function_cc0(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_cd0(struct _IO_FILE * stream);
int64_t * function_ce0(int32_t nmemb, int32_t size);
int64_t function_cf0(int64_t a1);
void function_d00(void);
int32_t function_d10(char * nptr, char ** endptr, int32_t base);
char * function_d20(char * dest, char * src);
char * function_d30(char * haystack, char * needle);
int32_t function_d40(int32_t c);
int64_t function_fb8(int64_t a1, int64_t a2);
int32_t H(int32_t e);
int32_t I(int32_t j);
int32_t N(int32_t j, int32_t e);
int32_t O(int32_t j);
int64_t o(void);
int64_t register_tm_clones(void);
int32_t S(int32_t j, int32_t e);
int32_t s(int32_t g, int32_t e);
int32_t T(int32_t j);
int32_t U(void);
int32_t w(void);
int32_t X(void);
int64_t Y(void);
int32_t Z(int32_t e);

// --------------------- Global Variables ---------------------

int32_t G = 0; // 0x130a4
int32_t P = 0; // 0x13080
int32_t R = 0; // 0x13084
int32_t W = 0; // 0x130b0
int32_t ac = 0; // 0x1309c
int64_t g1 = 3976; // 0x12d10
int64_t g2 = 3904; // 0x12d18
int64_t g3 = 0; // 0x12d20
void (*g4)() = (void (*)())0x1e60; // 0x12f20
int64_t g5 = 0; // 0x12f28
int32_t * g6 = (int32_t *)0x1307c; // 0x12f30
int32_t g7 = 304; // 0x12f31
int64_t g10 = 0; // 0x12f48
int32_t g11 = 0x13088; // 0x12f50
int32_t g12 = 0; // 0x12f54
int32_t g13 = 0x1308c; // 0x12f58
int32_t g14 = 0x13090; // 0x12f60
int32_t g15 = 304; // 0x12f61
int32_t g16 = 0; // 0x12f64
int32_t * g17 = (int32_t *)0x13094; // 0x12f68
int32_t g18 = 0x13098; // 0x12f70
int64_t g19 = 0; // 0x12f78
int64_t g21 = 0; // 0x12f88
void (*g22)() = (void (*)())0x1de8; // 0x12f90
int32_t g23 = 0x130a0; // 0x12f98
int32_t g25 = 0; // 0x12fa4
char * g26 = "\xa8\x30\x01"; // 0x12fa8
int32_t g27 = 0x130ac; // 0x12fb0
struct _IO_FILE * g29 = (struct _IO_FILE *)0x130b4; // 0x12fc0
int32_t g30 = 0x130b8; // 0x12fc8
int32_t g31 = 304; // 0x12fc9
int32_t g32 = 0; // 0x12fcc
int64_t g33 = 3408; // 0x12fd0
int64_t g34 = 0; // 0x12fd8
int64_t g35 = 3168; // 0x13000
int64_t g36 = 0; // 0x13078
int64_t g37 = 0; // 0x1307f
int32_t g38 = 0x6d232b2b; // 0x1e78
int32_t g39;
int32_t * g8 = &P; // 0x12f38
int32_t * g9 = &R; // 0x12f40
int32_t * g20 = &ac; // 0x12f80
int32_t * g24 = &G; // 0x12fa0
int32_t * g28 = &W; // 0x12fb8

// ------------------------ Functions -------------------------

// Address range: 0xc48 - 0xc5c
int64_t _init(int64_t a1) {
    // 0xc48
    return call_weak_fn();
}

// Address range: 0xc80 - 0xc90
int64_t function_c80(int64_t a1) {
    // 0xc80
    return __cxa_finalize();
}

// Address range: 0xc90 - 0xca0
struct _IO_FILE * function_c90(char * filename, char * modes) {
    // 0xc90
    return fopen(filename, modes);
}

// Address range: 0xca0 - 0xcb0
int32_t function_ca0(int32_t c) {
    // 0xca0
    return isspace(c);
}

// Address range: 0xcb0 - 0xcc0
int64_t * function_cb0(int64_t * handle, char * name) {
    // 0xcb0
    return dlsym(handle, name);
}

// Address range: 0xcc0 - 0xcd0
int32_t function_cc0(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xcc0
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xcd0 - 0xce0
int32_t function_cd0(struct _IO_FILE * stream) {
    // 0xcd0
    return fgetc(stream);
}

// Address range: 0xce0 - 0xcf0
int64_t * function_ce0(int32_t nmemb, int32_t size) {
    // 0xce0
    return calloc(nmemb, size);
}

// Address range: 0xcf0 - 0xd00
int64_t function_cf0(int64_t a1) {
    // 0xcf0
    return __gmon_start__();
}

// Address range: 0xd00 - 0xd10
void function_d00(void) {
    // 0xd00
    abort();
}

// Address range: 0xd10 - 0xd20
int32_t function_d10(char * nptr, char ** endptr, int32_t base) {
    // 0xd10
    return strtol(nptr, endptr, base);
}

// Address range: 0xd20 - 0xd30
char * function_d20(char * dest, char * src) {
    // 0xd20
    return strcpy(dest, src);
}

// Address range: 0xd30 - 0xd40
char * function_d30(char * haystack, char * needle) {
    // 0xd30
    return strstr(haystack, needle);
}

// Address range: 0xd40 - 0xd50
int32_t function_d40(int32_t c) {
    // 0xd40
    return isalnum(c);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xd50 - 0xe78
// Line range:    431 - 444
int main(int g, char ** e) {
    int32_t * v1 = (int32_t *)*(int64_t *)0x12fc0; // 0xd80
    *v1 = (int32_t)*(int64_t *)g19;
    if (g >= 2) {
        int32_t file_path = *(int32_t *)(0x100000000 * (int64_t)e + 0x400000000 >> 32); // 0xd98
        *v1 = (int32_t)(int64_t)fopen((char *)(int64_t)file_path, "r");
    }
    int64_t * mem = calloc(1, 0x1869f); // 0xdb4
    *g9 = (int32_t)(int64_t)mem;
    char * dest_str = strcpy((char *)mem, " int if else while break return for define main "); // 0xdd0
    *(int32_t *)*(int64_t *)0x12f30 = (int32_t)(int64_t)dest_str + 48;
    int64_t * mem2 = calloc(1, 0x1869f); // 0xdf0
    *(int32_t *)*(int64_t *)0x12f60 = (int32_t)(int64_t)mem2;
    int32_t mem3 = (int64_t)calloc(1, 0x1869f); // 0xe18
    *g20 = mem3;
    *(int32_t *)(int64_t)g30 = mem3;
    *g8 = (int32_t)(int64_t)calloc(1, 0x1869f);
    o();
    ad();
    ab(0);
    return g - 1;
}

// Address range: 0xe78 - 0xeb0
int64_t _start(int64_t a1) {
    // 0xe78
    int64_t v1; // 0xe78
    int64_t v2; // 0xe78
    __libc_start_main(g33, (int32_t)a1, (char **)&v1, g22, g4, (void (*)())v2);
    abort();
    return &g39;
}

// Address range: 0xeb0 - 0xec4
int64_t call_weak_fn(void) {
    // 0xeb0
    if (g21 == 0) {
        // 0xec0
        return 0;
    }
    // 0xebc
    return function_cf0(g21);
}

// Address range: 0xec8 - 0xefc
int64_t deregister_tm_clones(void) {
    if ((int64_t)&g37 - (int64_t)&g36 == 14 || (uint64_t)((int64_t)&g37 - (int64_t)&g36) < 14 || g5 == 0) {
        // 0xef8
        return &g36;
    }
    // 0xef4
    return _ITM_deregisterTMCloneTable(&g36, g5);
}

// Address range: 0xf00 - 0xf3c
int64_t register_tm_clones(void) {
    // 0xf00
    return &g36;
}

// Address range: 0xf40 - 0xf88
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g36; // 0xf50
    if (result != 0) {
        // 0xf7c
        return result;
    }
    // 0xf58
    if (g10 != 0) {
        // 0xf64
        function_c80(*(int64_t *)((int64_t)&g35 + 112));
    }
    // 0xf70
    deregister_tm_clones();
    *(char *)&g36 = 1;
    // 0xf7c
    return 1;
}

// Address range: 0xf88 - 0xfb8
int64_t frame_dummy(void) {
    // 0xf88
    if (g3 == 0 || g34 == 0) {
        // 0xf98
        return register_tm_clones();
    }
    // 0xfac
    return _Jv_RegisterClasses(&g3, g34);
}

// Address range: 0xfb8 - 0xfc0
int64_t function_fb8(int64_t a1, int64_t a2) {
    // 0xfb8
    return register_tm_clones();
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xfc0 - 0xfe0
// Line range:    20 - 22
int32_t E(int32_t e) {
    // 0xfc0
    *g6 = (int32_t)&g7;
    *(char *)(0x100000000 * (int64_t)g6 >> 32) = (char)e;
    return e;
}

// Address range: 0xfe0 - 0x1058
// Demangled:     unsigned __int128
int64_t o(void) {
    int64_t result = *(int64_t *)0x12f68; // 0xfec
    int32_t * v1 = (int32_t *)result; // 0xff0
    int32_t v2 = *v1; // 0xff0
    int32_t * v3; // 0xfe0
    int64_t c; // 0xfe0
    if (v2 == 0) {
        int32_t stream = *(int32_t *)&g29; // 0x1048
        v3 = (int32_t *)(int64_t)g13;
        c = fgetc((struct _IO_FILE *)(int64_t)stream);
    } else {
        // 0x1000
        *v1 = v2 + 1;
        int32_t * v4 = (int32_t *)(int64_t)g13;
        unsigned char v5 = *(char *)(int64_t)v2; // 0x1010
        *v4 = (int32_t)v5;
        if (v5 != 2) {
            // 0x1034
            return result;
        }
        // 0x1020
        *v1 = 0;
        v3 = v4;
        c = (int64_t)*(int32_t *)&g28;
    }
    // 0x1030
    *v3 = (int32_t)c;
    // 0x1034
    return c;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1058 - 0x1090
// Line range:    33 - 35
int32_t X(void) {
    int32_t c = g13; // 0x106c
    return isalnum(c) | (int32_t)(c == 95);
}

// Address range: 0x1090 - 0x10d4
int64_t Y(void) {
    uint32_t v1 = g13;
    int64_t result = v1;
    if (v1 != 92) {
        // 0x10c8
        return result;
    }
    // 0x10b0
    o();
    int64_t result2 = g13; // 0x10bc
    if (g13 == 110) {
        // 0x10c0
        *(int32_t *)result = 10;
        result2 = 10;
    }
    // 0x10c8
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x10d4 - 0x1424
// Line range:    42 - 116
int32_t ad(void) {
    int32_t * v1; // 0x10d4
    int32_t * v2; // 0x10d4
    int32_t * v3; // 0x10d4
    int64_t result; // 0x10d4
    int64_t v4; // 0x10d4
    while (true) {
        // 0x10fc
        if ((isspace(g13) || (int32_t)(g13 == 35)) != 0) {
            int32_t v5; // 0x11f0
            if (g13 == 35) {
                // 0x11bc
                o();
                ad();
                if (g11 == (int32_t)".1") {
                    // 0x11d0
                    ad();
                    E(32);
                    *(int32_t *)(int64_t)g11 = 1;
                    v5 = *(int32_t *)&g6;
                    *(int32_t *)(int64_t)(int32_t)&g12 = v5;
                }
                // 0x1204
                E(g13);
                if (g13 != 10) {
                    o();
                    E(g13);
                    while (g13 != 10) {
                        // 0x1224
                        o();
                        E(g13);
                    }
                }
                // 0x1210
                E(2);
            }
            // 0x121c
            o();
            while ((isspace(g13) || (int32_t)(g13 == 35)) != 0) {
                // 0x11b8
                if (g13 == 35) {
                    // 0x11bc
                    o();
                    ad();
                    if (g11 == (int32_t)".1") {
                        // 0x11d0
                        ad();
                        E(32);
                        *(int32_t *)(int64_t)g11 = 1;
                        v5 = *(int32_t *)&g6;
                        *(int32_t *)(int64_t)(int32_t)&g12 = v5;
                    }
                    // 0x1204
                    E(g13);
                    if (g13 != 10) {
                        o();
                        E(g13);
                        while (g13 != 10) {
                            // 0x1224
                            o();
                            E(g13);
                        }
                    }
                    // 0x1210
                    E(2);
                }
                // 0x121c
                o();
            }
        }
        // 0x111c
        v2 = (int32_t *)(int64_t)g11;
        *v2 = g13;
        v3 = (int32_t *)*(int64_t *)0x12f98;
        *v3 = 0;
        if (X() == 0) {
            // 0x12f4
            o();
            if (g11 == 39) {
                // break -> 0x1304
                break;
            }
            // 0x133c
            if (g11 == 47 != (g13 == 42)) {
                // 0x1390
                v1 = (int32_t *)(int64_t)g18;
                v4 = &g38;
                goto lab_0x13a8;
            }
            // 0x1350
            o();
            if (g13 != 0) {
                o();
                // 0x136c
                while (g13 != 42) {
                    // 0x136c
                    o();
                }
                // 0x1378
                if (g13 == 47) {
                    // 0x1388
                    *(int32_t *)(int64_t)g13 = 0;
                }
                // 0x136c
                while (g13 != 0) {
                    o();
                    // 0x136c
                    while (g13 != 42) {
                        // 0x136c
                        o();
                    }
                    // 0x1378
                    if (g13 == 47) {
                        // 0x1388
                        *(int32_t *)(int64_t)g13 = 0;
                    }
                }
            }
        } else {
            // 0x1138
            E(32);
            *(int32_t *)*(int64_t *)0x12fa8 = *(int32_t *)&g6;
            if (X() != 0) {
                E(g13);
                o();
                while (X() != 0) {
                    // 0x1230
                    E(g13);
                    o();
                }
            }
            uint32_t v6 = g11;
            int64_t v7 = v6;
            if (v6 >= 57 != v6 != 57) {
                int32_t str_as_l = strtol((char *)(int64_t)*(int32_t *)&g26, NULL, 0); // 0x1188
                *(int32_t *)(int64_t)g18 = str_as_l;
                *(int32_t *)v7 = 2;
                result = 2;
                return result;
            }
            // 0x1240
            *(char *)(int64_t)*(int32_t *)&g6 = 32;
            int32_t v8 = *(int32_t *)&g26; // 0x1258
            int32_t str = *(int32_t *)&g9; // 0x1268
            char * substr_pos = strstr((char *)(int64_t)str, (char *)(int64_t)(v8 - 1)); // 0x1270
            int32_t * v9 = (int32_t *)v7; // 0x1278
            *v9 = (int32_t)(int64_t)substr_pos - str;
            *(char *)(int64_t)*(int32_t *)&g6 = 0;
            *v9 = 8 * (int32_t)&g18;
            result = (int64_t)(8 * (int32_t)&g18);
            if (8 * (int32_t)&g18 <= (int32_t)".1") {
              lab_0x11a0:
                // 0x11a0
                return result;
            }
            int32_t v10 = *(int32_t *)&g8 + 8 * (int32_t)&g18; // 0x12a8
            int64_t v11 = v10; // 0x12a8
            *v9 = v10;
            result = v11;
            if (*(int32_t *)(int64_t)v10 != 1) {
                // 0x11a0
                return result;
            }
            // 0x12c0
            *g17 = *(int32_t *)(0x100000000 * v11 + 0x400000000 >> 32);
            *g28 = g13;
        }
        // 0x12ec
        o();
    }
    // 0x1304
    *v2 = 2;
    Y();
    *(int32_t *)(int64_t)g18 = g13;
    o();
    return o();
  lab_0x13a8:;
    int64_t v12 = 0x100000000 * v4;
    unsigned char v13 = *(char *)(v12 >> 32); // 0x13b0
    result = v4;
    int64_t v14; // 0x10d4
    int32_t v15; // 0x10d4
    unsigned char v16; // 0x13c4
    int64_t v17; // 0x10d4
    if (v13 == 0) {
        return result;
    } else {
        int64_t v18 = v12 + 0x300000000 >> 32; // 0x13c0
        v16 = *(char *)(v12 + 0x100000000 >> 32);
        *v1 = 0;
        int32_t v19 = (int32_t)*(char *)(v18 - 1) - 98; // 0x13d8
        *v3 = v19;
        v14 = v18;
        v15 = v19;
        v17 = v18;
        if (v19 < 0) {
            goto lab_0x1410;
        } else {
            goto lab_0x13e4;
        }
    }
  lab_0x1410:;
    int64_t v20 = v17 + 1; // 0x13d4
    *v1 = v15 + 64 + 64 * g18;
    int32_t v21 = (int32_t)*(char *)v17 - 98; // 0x13d8
    *v3 = v21;
    v14 = v20;
    v15 = v21;
    v17 = v20;
    if (v21 < 0) {
        goto lab_0x1410;
    } else {
        goto lab_0x13e4;
    }
  lab_0x13e4:;
    int64_t v22 = v14 & 0xffffffff;
    v4 = v22;
    if (g11 == (int32_t)v13 == (v16 == 64 || g13 == (int32_t)v16)) {
        // 0x13f4
        result = v22;
        if ((int64_t)g13 == (int64_t)v16) {
            // 0x13fc
            o();
            *(int32_t *)(int64_t)g11 = 1;
            result = 1;
            return result;
        } else {
            return result;
        }
    } else {
        goto lab_0x13a8;
    }
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1424 - 0x1458
// Line range:    128 - 131
int32_t ae(int32_t g) {
    // 0x1424
    if (g != -1 != g != 0) {
        // 0x1438
        return g;
    }
    int32_t * v1 = (int32_t *)(int64_t)g30; // 0x1448
    *v1 = (int32_t)&g31;
    *(char *)(int64_t)g30 = (char)g;
    int32_t result = g >> 8; // 0x1450
    if (result != -1 != result != 0) {
        // 0x1438
        return result;
    }
    int32_t result2 = result; // 0x1434
    *v1 = (int32_t)&g31;
    *(char *)(int64_t)g30 = (char)result2;
    result2 >>= 8;
    while (result2 != -1 == (result2 != 0)) {
        // 0x143c
        *v1 = (int32_t)&g31;
        *(char *)(int64_t)g30 = (char)result2;
        result2 >>= 8;
    }
    // 0x1438
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1458 - 0x1488
// Line range:    134 - 139
int32_t A(int32_t e) {
    if (e == 0) {
        // 0x1464
        return 0;
    }
    int32_t * v1 = (int32_t *)(0x100000000 * (int64_t)e >> 32); // 0x1474
    uint32_t v2 = *v1; // 0x1474
    *v1 = -4 - e + g30;
    while (v2 != 0) {
        int32_t v3 = v2;
        v1 = (int32_t *)(0x100000000 * (int64_t)v2 >> 32);
        v2 = *v1;
        *v1 = -4 - v3 + g30;
    }
    // 0x1464
    return 0;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1488 - 0x14bc
// Line range:    142 - 148
// Demangled:     short
int32_t s(int32_t g, int32_t e) {
    // 0x1488
    ae(g);
    *(int32_t *)(int64_t)g30 = e;
    *(int32_t *)(int64_t)g30 = (int32_t)&g32;
    return g30;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x14bc - 0x14c8
// Line range:    149 - 150
int32_t H(int32_t e) {
    // 0x14bc
    return s(184, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x14c8 - 0x14d4
// Line range:    152 - 153
int32_t B(int32_t e) {
    // 0x14c8
    return s(233, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x14d4 - 0x1500
// Line range:    155 - 157
int32_t S(int32_t j, int32_t e) {
    // 0x14d4
    ae(0xfc085);
    return s(j + 132, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1500 - 0x1538
// Line range:    159 - 164
int32_t Z(int32_t e) {
    // 0x1500
    ae(0xc139);
    H(0);
    ae(15);
    ae(e + 144);
    return ae(192);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1538 - 0x1568
// Line range:    166 - 168
int32_t N(int32_t j, int32_t e) {
    // 0x1538
    ae(j + 131);
    int32_t v1 = e - (int32_t)"/lib/ld-linux-aarch64.so.1"; // 0x154c
    int32_t v2 = v1 < 0 == ((v1 ^ e) & (e ^ (int32_t)"/lib/ld-linux-aarch64.so.1")) < 0 ? 5 : 133; // 0x1560
    return s(v2, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1568 - 0x1570
// Line range:    315 - 316
// Demangled:     wchar_t
int32_t w(void) {
    // 0x1568
    return O(11);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1570 - 0x18fc
// Line range:    170 - 274
int32_t T(int32_t j) {
    uint32_t v1 = g11; // 0x1590
    int64_t v2 = v1; // 0x1590
    int32_t v3; // 0x1570
    int64_t v4; // 0x1570
    int64_t v5; // 0x1570
    int64_t v6; // 0x1570
    int64_t v7; // 0x1570
    int64_t v8; // 0x1570
    if (v1 == 34) {
        // 0x159c
        H(g14);
        if (g13 != 34) {
            Y();
            *(int32_t *)(int64_t)g14 = (int32_t)&g15;
            *(char *)(int64_t)g14 = (char)g13;
            o();
            // 0x15e8
            while (g13 != 34) {
                // 0x15e8
                Y();
                *(int32_t *)(int64_t)g14 = (int32_t)&g15;
                *(char *)(int64_t)g14 = (char)g13;
                o();
            }
        }
        int64_t v9 = g14; // 0x15c0
        *(char *)v9 = 0;
        *(int32_t *)v9 = (int32_t)&g16;
        o();
        goto lab_0x15e0;
    } else {
        // 0x160c
        ad();
        if (v1 == 2) {
            // 0x1634
            H(g18);
            v4 = 1;
            v6 = 2;
            goto lab_0x1640;
        } else {
            if (g23 == 2) {
                // 0x16d8
                T(0);
                s(185, 0);
                v3 = g18;
                v8 = v2;
                if (v1 == 33) {
                    // 0x16f8
                    Z(g18);
                    v4 = 1;
                    v6 = 33;
                    goto lab_0x1640;
                } else {
                    goto lab_0x1788;
                }
            } else {
                switch (v1) {
                    case 40: {
                        // 0x1708
                        w();
                        goto lab_0x15e0;
                    }
                    case 42: {
                        // 0x1718
                        ad();
                        ad();
                        ad();
                        int64_t v10 = g11; // 0x1730
                        if (g11 == 42) {
                            // 0x1734
                            ad();
                            ad();
                            ad();
                            ad();
                            v10 = 0;
                        }
                        // 0x1748
                        ad();
                        T(0);
                        if (g11 == 61) {
                            // 0x1764
                            ad();
                            ae(80);
                            w();
                            ae(89);
                            v3 = v10 == 256 ? 393 : 392;
                            v8 = v10;
                            goto lab_0x1788;
                        } else {
                            int32_t v11 = v10; // 0x1794
                            v5 = 1;
                            v7 = v10;
                            if (v11 == 0) {
                                goto lab_0x1640_2;
                            } else {
                                // 0x1798
                                ae(v11 == 256 ? 139 : 0xbe0f);
                                *(int32_t *)(int64_t)g30 = (int32_t)&g31;
                                v4 = 1;
                                v6 = v10;
                                goto lab_0x1640;
                            }
                        }
                    }
                    default: {
                        // 0x17c4
                        if (v1 == 38) {
                            // 0x17cc
                            N(10, g11);
                            goto lab_0x15e0;
                        } else {
                            int32_t v12 = g11; // 0x17e8
                            int64_t v13 = g11; // 0x17e8
                            if (g11 == 0) {
                                uint32_t v14 = *(int32_t *)&g26; // 0x17f4
                                v12 = g11;
                                v13 = (int64_t)dlsym(NULL, (char *)(int64_t)v14) & 0xffffffff;
                            }
                            // 0x1804
                            if (((int32_t)(v12 == 61) & j) == 0) {
                                // 0x1834
                                v4 = v13;
                                v6 = v2;
                                if (v12 != 40) {
                                    int32_t v15 = v13; // 0x183c
                                    N(8, v15);
                                    v4 = v13;
                                    v6 = v2;
                                    if (g23 == 11) {
                                        // 0x1858
                                        N(0, v15);
                                        ae(g18);
                                        ad();
                                        v4 = v13;
                                        v6 = v2;
                                    }
                                }
                            } else {
                                // 0x181c
                                ad();
                                w();
                                N(6, (int32_t)v13);
                                v4 = v13;
                                v6 = v2;
                            }
                            goto lab_0x1640;
                        }
                    }
                }
            }
        }
    }
  lab_0x15e0:
    // 0x15e0
    ad();
    v4 = 1;
    v6 = v2;
    goto lab_0x1640;
  lab_0x1640:
    // 0x1640
    v5 = v4;
    v7 = v6;
    goto lab_0x1640_2;
  lab_0x1640_2:
    // 0x1640
    if (g11 != 40) {
        // 0x16b8
        return g11;
    }
    int32_t v16 = v5; // 0x1654
    if (v16 == 1) {
        // 0x1658
        ae(80);
    }
    int32_t v17 = s(0xec81, 0); // 0x1670
    ad();
    int64_t v18 = 0; // 0x168c
    int64_t v19 = 0; // 0x168c
    if (g11 != 41) {
        w();
        s(0x248489, (int32_t)v19);
        if (g11 == 44) {
            // 0x1894
            ad();
        }
        int64_t v20 = v19 + 4 & 0xffffffff; // 0x1898
        v18 = v20;
        v19 = v20;
        while (g11 != 41) {
            // 0x1878
            w();
            s(0x248489, (int32_t)v19);
            if (g11 == 44) {
                // 0x1894
                ad();
            }
            // 0x1898
            v20 = v19 + 4 & 0xffffffff;
            v18 = v20;
            v19 = v20;
        }
    }
    int32_t v21 = v18;
    *(int32_t *)(int64_t)v17 = v21;
    ad();
    int32_t result; // 0x1570
    switch (v16) {
        case 0: {
            int32_t * v22 = (int32_t *)(0x100000000 * v7 + 0x400000000 >> 32); // 0x16a8
            int32_t v23 = s(232, *v22); // 0x16ac
            *v22 = v23;
            result = v23;
            // break -> 0x16b4
            break;
        }
        case 1: {
            // 0x18a8
            s(0x2494ff, v21);
            // 0x18bc
            return s(0xc481, v21 + 4);
        }
        default: {
            // 0x18dc
            result = s(232, v16 - 5 - g30);
            // break -> 0x16b4
            break;
        }
    }
    // 0x16b4
    if (v18 == 0) {
        // 0x16b8
        return result;
    }
    // 0x18bc
    return s(0xc481, v21);
  lab_0x1788:
    // 0x1788
    ae(v3);
    v4 = 1;
    v6 = v8;
    goto lab_0x1640;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x18fc - 0x1a34
// Line range:    279 - 314
int32_t O(int32_t j) {
    if (j == 1) {
        // 0x1904
        return T(1);
    }
    uint32_t v1 = j - 1; // 0x1914
    O(v1);
    if (g23 != v1) {
        // 0x1a1c
        return g23;
    }
    int64_t v2 = 0;
    ad();
    int64_t v3; // 0x18fc
    while (v1 < 9) {
        // 0x19d4
        ae(80);
        O(v1);
        ae(89);
        if (v1 != 4 == (v1 != 5)) {
            // 0x1a04
            ae(g18);
            if (g11 == 37) {
                // 0x1a10
                ae(146);
            }
        } else {
            // 0x19fc
            Z(g18);
        }
        // 0x1948
        v3 = v2;
        if (g23 != v1) {
            // break (via goto) -> 0x1954
            goto lab_0x1954;
        }
        ad();
    }
    int64_t v4 = S(g18, (int32_t)v2); // 0x19c4
    O(v1);
    v3 = v4;
    while (g23 == v1) {
        // 0x19a4
        v2 = v4;
        ad();
        while (v1 < 9) {
            // 0x19d4
            ae(80);
            O(v1);
            ae(89);
            if (v1 != 4 == (v1 != 5)) {
                // 0x1a04
                ae(g18);
                if (g11 == 37) {
                    // 0x1a10
                    ae(146);
                }
            } else {
                // 0x19fc
                Z(g18);
            }
            // 0x1948
            v3 = v2;
            if (g23 != v1) {
                // break (via goto) -> 0x1954
                goto lab_0x1954;
            }
            ad();
        }
        // 0x19b8
        v4 = S(g18, (int32_t)v2);
        O(v1);
        v3 = v4;
    }
  lab_0x1954:
    // 0x1954
    if (v3 == 0) {
        // 0x1a1c
        return g23;
    }
    int32_t v5 = j - 9; // 0x1958
    if (v5 == 0 || v5 < 0 != (8 - j & v1) < 0) {
        // 0x1a1c
        return g23;
    }
    int32_t v6 = S(g18, (int32_t)v3); // 0x1968
    H(g18 ^ 1);
    B(5);
    A(v6);
    return H(g18);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1a34 - 0x1a50
// Line range:    318 - 320
int32_t U(void) {
    // 0x1a34
    w();
    return S(0, 0);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1a50 - 0x1be4
// Line range:    389 - 418
int32_t ab(int32_t j) {
    int32_t result = g11; // 0x1a88
    if (result != 256 && j == 0 != result != -1) {
        // 0x1a98
        return result;
    }
    // 0x1aac
    int32_t v1; // 0x1b94
    int64_t v2; // 0x1bc8
    int64_t v3; // 0x1ad8
    int64_t v4; // 0x1a50
    int64_t v5; // 0x1a50
    if (result == 256) {
        // 0x1ab4
        ad();
        while (true) {
            if (g11 == 59) {
                // break (via goto) -> 0x1ad0
                goto lab_0x1ad0;
            }
            // 0x1ad8
            v3 = g11;
            if (j == 0) {
                // 0x1b14
                *(int32_t *)v3 = g14;
                *(int32_t *)(int64_t)g14 = (int32_t)&g16;
            } else {
                // 0x1ae0
                *g24 = (int32_t)&g25;
                *(int32_t *)v3 = -4 - *(int32_t *)&g24;
            }
            // 0x1af8
            ad();
            // 0x1ac0
            while (g11 != 44) {
                // 0x1ac4
                if (g11 == 59) {
                    // break (via goto) -> 0x1ad0
                    goto lab_0x1ad0;
                }
                // 0x1ad8
                v3 = g11;
                if (j == 0) {
                    // 0x1b14
                    *(int32_t *)v3 = g14;
                    *(int32_t *)(int64_t)g14 = (int32_t)&g16;
                } else {
                    // 0x1ae0
                    *g24 = (int32_t)&g25;
                    *(int32_t *)v3 = -4 - *(int32_t *)&g24;
                }
                // 0x1af8
                ad();
            }
            // 0x1b0c
            ad();
        }
        // 0x1ad0
        ad();
    } else {
        // 0x1b2c
        A(g12);
        *(int32_t *)(int64_t)g11 = g30;
        ad();
        ad();
        v4 = 8;
        while (true) {
            // 0x1b5c
            if (g11 == 41) {
                // break (via goto) -> 0x1b68
                goto lab_0x1b68;
            }
            // 0x1bc0
            *(int32_t *)(int64_t)g11 = (int32_t)v4;
            v2 = v4 + 4 & 0xffffffff;
            ad();
            v5 = v2;
            while (g11 != 44) {
                // 0x1b5c
                if (g11 == 41) {
                    // break (via goto) -> 0x1b68
                    goto lab_0x1b68;
                }
                // 0x1bc0
                *(int32_t *)(int64_t)g11 = (int32_t)v5;
                v2 = v5 + 4 & 0xffffffff;
                ad();
                v5 = v2;
            }
            // 0x1bdc
            ad();
            v4 = v2;
        }
        // 0x1b68
        ad();
        *g24 = 0;
        *(int32_t *)(int64_t)g27 = 0;
        ae(0xe58955);
        v1 = s(0xec81, 0);
        I(0);
        A(g27);
        ae(0xc3c9);
        *(int32_t *)(int64_t)v1 = *(int32_t *)&g24;
    }
    int32_t v6 = g11; // 0x1a88
    int32_t result2 = v6; // 0x1a94
    bool v7 = v6 == 256; // 0x1a94
    while (v6 == 256 || j == 0 == (v6 != -1)) {
        // 0x1aac
        if (v7) {
            // 0x1ab4
            ad();
            while (true) {
                if (g11 == 59) {
                    // break (via goto) -> 0x1ad0
                    goto lab_0x1ad0;
                }
                // 0x1ad8
                v3 = g11;
                if (j == 0) {
                    // 0x1b14
                    *(int32_t *)v3 = g14;
                    *(int32_t *)(int64_t)g14 = (int32_t)&g16;
                } else {
                    // 0x1ae0
                    *g24 = (int32_t)&g25;
                    *(int32_t *)v3 = -4 - *(int32_t *)&g24;
                }
                // 0x1af8
                ad();
                // 0x1ac0
                while (g11 != 44) {
                    // 0x1ac4
                    if (g11 == 59) {
                        // break (via goto) -> 0x1ad0
                        goto lab_0x1ad0;
                    }
                    // 0x1ad8
                    v3 = g11;
                    if (j == 0) {
                        // 0x1b14
                        *(int32_t *)v3 = g14;
                        *(int32_t *)(int64_t)g14 = (int32_t)&g16;
                    } else {
                        // 0x1ae0
                        *g24 = (int32_t)&g25;
                        *(int32_t *)v3 = -4 - *(int32_t *)&g24;
                    }
                    // 0x1af8
                    ad();
                }
                // 0x1b0c
                ad();
            }
            // 0x1ad0
            ad();
        } else {
            // 0x1b2c
            A(g12);
            *(int32_t *)(int64_t)g11 = g30;
            ad();
            ad();
            v4 = 8;
            while (true) {
                // 0x1b5c
                v5 = v4;
                if (g11 == 41) {
                    // break (via goto) -> 0x1b68
                    goto lab_0x1b68;
                }
                // 0x1bc0
                *(int32_t *)(int64_t)g11 = (int32_t)v5;
                v2 = v5 + 4 & 0xffffffff;
                ad();
                v5 = v2;
                while (g11 != 44) {
                    // 0x1b5c
                    if (g11 == 41) {
                        // break (via goto) -> 0x1b68
                        goto lab_0x1b68;
                    }
                    // 0x1bc0
                    *(int32_t *)(int64_t)g11 = (int32_t)v5;
                    v2 = v5 + 4 & 0xffffffff;
                    ad();
                    v5 = v2;
                }
                // 0x1bdc
                ad();
                v4 = v2;
            }
            // 0x1b68
            ad();
            *g24 = 0;
            *(int32_t *)(int64_t)g27 = 0;
            ae(0xe58955);
            v1 = s(0xec81, 0);
            I(0);
            A(g27);
            ae(0xc3c9);
            *(int32_t *)(int64_t)v1 = *(int32_t *)&g24;
        }
        // 0x1a78
        v6 = g11;
        result2 = v6;
        v7 = v6 == 256;
    }
    // 0x1a98
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1be4 - 0x1de4
// Line range:    322 - 385
int32_t I(int32_t j) {
    // 0x1be4
    int32_t v1; // 0x1be4
    switch (g11) {
        case 288: {
            // 0x1c10
            ad();
            ad();
            v1 = U();
            ad();
            I(j);
            if (g11 == 312) {
                // 0x1c38
                ad();
                int32_t v2 = B(0); // 0x1c40
                A(v1);
                I(j);
                // 0x1c60
                return A(v2);
            }
            // break -> 0x1cc8
            break;
        }
        case 504: {
        }
        case 352: {
            // 0x1c84
            ad();
            ad();
            int32_t v3; // 0x1be4
            if (g11 == 352) {
                // 0x1c98
                v1 = U();
                v3 = g30;
            } else {
                // 0x1cd0
                if (g11 != 59) {
                    // 0x1cdc
                    w();
                }
                // 0x1ce0
                ad();
                v1 = 0;
                if (g11 != 59) {
                    // 0x1d00
                    v1 = U();
                }
                // 0x1d08
                ad();
                v3 = g30;
                if (g11 != 41) {
                    int32_t v4 = B(0); // 0x1d20
                    w();
                    B(g30 - 5 - g30);
                    A(v4);
                    v3 = v4 + 4;
                }
            }
            // 0x1ca8
            ad();
            I((int32_t)(int64_t)&v1);
            B(v3 - 5 - g30);
            // break -> 0x1cc8
            break;
        }
        case 123: {
            // 0x1d58
            ad();
            ab(1);
            if (g11 != 125) {
                I(j);
                while (g11 != 125) {
                    // 0x1d78
                    I(j);
                }
            }
            // 0x1c60
            return ad();
        }
        case 448: {
            // 0x1d8c
            ad();
            if (g11 != 59) {
                // 0x1d9c
                w();
            }
            uint32_t v5 = g27;
            *(int32_t *)(int64_t)v5 = B(v5);
            // 0x1c60
            return ad();
        }
        case 400: {
            // 0x1dc0
            ad();
            int64_t v6; // 0x1be4
            *(int32_t *)(int64_t)j = B((int32_t)v6);
            // 0x1c60
            return ad();
        }
        case 59: {
            // 0x1c60
            return ad();
        }
        default: {
            // 0x1ddc
            w();
            // 0x1c60
            return ad();
        }
    }
    // 0x1c60
    return A(v1);
}

// Address range: 0x1de8 - 0x1e60
int64_t __libc_csu_init(void) {
    // 0x1de8
    int64_t v1; // 0x1de8
    int64_t result = _init(v1); // 0x1e1c
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x1e4c
        return result;
    }
    // 0x1e2c
    return v1 & 0xffffffff;
}

// Address range: 0x1e60 - 0x1e64
int64_t __libc_csu_fini(void) {
    // 0x1e60
    int64_t result; // 0x1e60
    return result;
}

// Address range: 0x1e64 - 0x1e74
int64_t _fini(int64_t a1) {
    // 0x1e64
    int64_t result; // 0x1e64
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// void * dlsym(void * restrict handle, const char * restrict name);
// int fgetc(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int isalnum(int c);
// int isspace(int c);
// char * strcpy(char * restrict dest, const char * restrict src);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 44

