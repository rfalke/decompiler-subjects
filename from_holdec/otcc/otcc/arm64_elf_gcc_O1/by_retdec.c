//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <dlfcn.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int64_t __do_global_dtors_aux(void);
int64_t __libc_csu_fini(void);
int64_t __libc_csu_init(void);
int64_t _fini(int64_t a1);
int64_t _init(int64_t a1);
int64_t _start(int64_t a1);
int32_t A(int32_t e);
int32_t ab(int32_t j);
int32_t ad(void);
int32_t ae(int32_t g);
int32_t B(int32_t e);
int64_t call_weak_fn(void);
int64_t deregister_tm_clones(void);
int32_t E(int32_t e);
int64_t frame_dummy(void);
int64_t function_207c(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5);
int64_t function_4000012f8(void);
int64_t function_400001344(void);
int64_t function_c50(int64_t a1);
struct _IO_FILE * function_c60(char * filename, char * modes);
int32_t function_c70(int32_t c);
int64_t * function_c80(int64_t * handle, char * name);
int32_t function_c90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t function_ca0(struct _IO_FILE * stream);
int64_t * function_cb0(int32_t nmemb, int32_t size);
int64_t function_cc0(int64_t a1);
void function_cd0(void);
int32_t function_ce0(char * nptr, char ** endptr, int32_t base);
char * function_cf0(char * haystack, char * needle);
int32_t function_d00(int32_t c);
int64_t function_e50(int64_t a1, int64_t a2);
int32_t H(int32_t e);
int32_t I(int32_t j);
int32_t N(int32_t j, int32_t e);
int32_t O(int32_t j);
int32_t o(void);
int64_t register_tm_clones(void);
int32_t s(int32_t g, int32_t e);
int32_t S(int32_t j, int32_t e);
int32_t T(int32_t j);
int32_t U(void);
int32_t w(void);
int32_t X(void);
int32_t Y(void);
int32_t Z(int32_t e);

// --------------------- Global Variables ---------------------

int32_t G = 0; // 0x1309c
int32_t P = 0; // 0x13078
int32_t R = 0; // 0x1307c
int32_t ac = 0; // 0x13094
int64_t g1 = 3616; // 0x12d10
int64_t g2 = 3544; // 0x12d18
int64_t g3 = 0; // 0x12d20
void (*g4)() = (void (*)())0x2108; // 0x12f20
int64_t g5 = 0; // 0x12f28
int32_t * g6 = (int32_t *)0x13074; // 0x12f30
int64_t g9 = 0; // 0x12f48
int32_t g10 = 0x13080; // 0x12f50
int32_t g11 = 0; // 0x12f54
int32_t g12 = 0x13084; // 0x12f58
int32_t g13 = 0x13088; // 0x12f60
int32_t g14 = 304; // 0x12f61
int32_t g15 = 0; // 0x12f64
int32_t * g16 = (int32_t *)0x1308c; // 0x12f68
int32_t g17 = 0x13090; // 0x12f70
int64_t g18 = 0; // 0x12f78
int64_t g20 = 0; // 0x12f88
void (*g21)() = (void (*)())0x2090; // 0x12f90
int32_t g22 = 0x13098; // 0x12f98
int32_t g24 = 0; // 0x12fa4
char * g25 = "\xa0\x30\x01"; // 0x12fa8
int32_t g26 = 0x130a4; // 0x12fb0
int32_t * g27 = (int32_t *)0x130a8; // 0x12fb8
int32_t * g28 = (int32_t *)0x130ac; // 0x12fc0
int32_t g29 = 0x130b0; // 0x12fc8
int32_t g30 = 304; // 0x12fc9
int32_t g31 = 0; // 0x12fcc
int64_t g32 = 0x1f48; // 0x12fd0
int64_t g33 = 0; // 0x12fd8
int64_t g34 = 3120; // 0x13000
int64_t g35 = 0; // 0x13070
int64_t g36 = 0; // 0x13077
int32_t g37;
int32_t * g7 = &P; // 0x12f38
int32_t * g8 = &R; // 0x12f40
int32_t * g19 = &ac; // 0x12f80
int32_t * g23 = &G; // 0x12fa0

// ------------------------ Functions -------------------------

// Address range: 0xc10 - 0xc24
int64_t _init(int64_t a1) {
    // 0xc10
    return call_weak_fn();
}

// Address range: 0xc50 - 0xc60
int64_t function_c50(int64_t a1) {
    // 0xc50
    return __cxa_finalize();
}

// Address range: 0xc60 - 0xc70
struct _IO_FILE * function_c60(char * filename, char * modes) {
    // 0xc60
    return fopen(filename, modes);
}

// Address range: 0xc70 - 0xc80
int32_t function_c70(int32_t c) {
    // 0xc70
    return isspace(c);
}

// Address range: 0xc80 - 0xc90
int64_t * function_c80(int64_t * handle, char * name) {
    // 0xc80
    return dlsym(handle, name);
}

// Address range: 0xc90 - 0xca0
int32_t function_c90(int64_t main2, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0xc90
    return __libc_start_main(main2, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0xca0 - 0xcb0
int32_t function_ca0(struct _IO_FILE * stream) {
    // 0xca0
    return fgetc(stream);
}

// Address range: 0xcb0 - 0xcc0
int64_t * function_cb0(int32_t nmemb, int32_t size) {
    // 0xcb0
    return calloc(nmemb, size);
}

// Address range: 0xcc0 - 0xcd0
int64_t function_cc0(int64_t a1) {
    // 0xcc0
    return __gmon_start__();
}

// Address range: 0xcd0 - 0xce0
void function_cd0(void) {
    // 0xcd0
    abort();
}

// Address range: 0xce0 - 0xcf0
int32_t function_ce0(char * nptr, char ** endptr, int32_t base) {
    // 0xce0
    return strtol(nptr, endptr, base);
}

// Address range: 0xcf0 - 0xd00
char * function_cf0(char * haystack, char * needle) {
    // 0xcf0
    return strstr(haystack, needle);
}

// Address range: 0xd00 - 0xd10
int32_t function_d00(int32_t c) {
    // 0xd00
    return isalnum(c);
}

// Address range: 0xd10 - 0xd48
int64_t _start(int64_t a1) {
    // 0xd10
    int64_t v1; // 0xd10
    int64_t v2; // 0xd10
    __libc_start_main(g32, (int32_t)a1, (char **)&v1, g21, g4, (void (*)())v2);
    abort();
    return &g37;
}

// Address range: 0xd48 - 0xd5c
int64_t call_weak_fn(void) {
    // 0xd48
    if (g20 == 0) {
        // 0xd58
        return 0;
    }
    // 0xd54
    return function_cc0(g20);
}

// Address range: 0xd60 - 0xd94
int64_t deregister_tm_clones(void) {
    if ((int64_t)&g36 - (int64_t)&g35 == 14 || (uint64_t)((int64_t)&g36 - (int64_t)&g35) < 14 || g5 == 0) {
        // 0xd90
        return &g35;
    }
    // 0xd8c
    return _ITM_deregisterTMCloneTable(&g35, g5);
}

// Address range: 0xd98 - 0xdd4
int64_t register_tm_clones(void) {
    // 0xd98
    return &g35;
}

// Address range: 0xdd8 - 0xe20
int64_t __do_global_dtors_aux(void) {
    unsigned char result = *(char *)&g35; // 0xde8
    if (result != 0) {
        // 0xe14
        return result;
    }
    // 0xdf0
    if (g9 != 0) {
        // 0xdfc
        function_c50(*(int64_t *)((int64_t)&g34 + 104));
    }
    // 0xe08
    deregister_tm_clones();
    *(char *)&g35 = 1;
    // 0xe14
    return 1;
}

// Address range: 0xe20 - 0xe50
int64_t frame_dummy(void) {
    // 0xe20
    if (g3 == 0 || g33 == 0) {
        // 0xe30
        return register_tm_clones();
    }
    // 0xe44
    return _Jv_RegisterClasses(&g3, g33);
}

// Address range: 0xe50 - 0xe58
int64_t function_e50(int64_t a1, int64_t a2) {
    // 0xe50
    return register_tm_clones();
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xe58 - 0xe78
// Line range:    20 - 22
int32_t E(int32_t e) {
    int32_t * v1 = (int32_t *)*(int64_t *)0x12f30; // 0xe60
    int32_t v2 = *v1; // 0xe60
    *v1 = v2 + 1;
    *(char *)(int64_t)v2 = (char)e;
    return e;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xe78 - 0xf0c
// Line range:    23 - 32
// Demangled:     unsigned __int128
int32_t o(void) {
    int32_t v1 = *(int32_t *)*(int64_t *)0x12f68; // 0xe80
    if (v1 == 0) {
        int32_t c = fgetc((struct _IO_FILE *)(int64_t)*(int32_t *)*(int64_t *)0x12fc0); // 0xef4
        *(int32_t *)(int64_t)g12 = c;
        return c;
    }
    // 0xe88
    *g16 = v1 + 1;
    unsigned char v2 = *(char *)(int64_t)v1; // 0xe9c
    int64_t result = *(int64_t *)0x12f58; // 0xea4
    *(int32_t *)result = (int32_t)v2;
    if (v2 != 2) {
        // 0xeb4
        return result;
    }
    // 0xeb8
    *g16 = 0;
    int32_t v3 = *(int32_t *)*(int64_t *)0x12fb8; // 0xecc
    *(int32_t *)(int64_t)g12 = v3;
    return g12;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xf0c - 0xf44
// Line range:    33 - 35
int32_t X(void) {
    int32_t c = g12; // 0xf20
    return isalnum(c) | (int32_t)(c == 95);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xf44 - 0xf98
// Line range:    36 - 39
int32_t Y(void) {
    // 0xf44
    if (g12 != 92) {
        // 0xf58
        return g12;
    }
    // 0xf5c
    o();
    int32_t result = g12; // 0xf78
    if (g12 == 110) {
        // 0xf84
        *(int32_t *)110 = 10;
        result = 110;
    }
    // 0xf58
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0xf98 - 0x1394
// Line range:    42 - 120
int32_t ad(void) {
    // 0xf98
    if ((isspace(g12) || (int32_t)(g12 == 35)) != 0) {
        int32_t v1; // 0x1054
        int32_t v2; // 0xf98
        if (g12 == 35) {
            // 0x1024
            o();
            ad();
            if (g10 == (int32_t)".1") {
                // 0x1038
                ad();
                E(32);
                *(int32_t *)(int64_t)g10 = 1;
                v1 = *(int32_t *)&g6;
                *(int32_t *)(int64_t)(int32_t)&g11 = v1;
            }
            // 0xfc8
            if (g12 != 10) {
                E(g12);
                o();
                v2 = g12;
                while (g12 != 10) {
                    // 0xfdc
                    E(v2);
                    o();
                    v2 = g12;
                }
            }
            // 0xff0
            E(10);
            E(2);
        }
        // 0x1000
        o();
        while ((isspace(g12) || (int32_t)(g12 == 35)) != 0) {
            // 0x1020
            if (g12 == 35) {
                // 0x1024
                o();
                ad();
                if (g10 == (int32_t)".1") {
                    // 0x1038
                    ad();
                    E(32);
                    *(int32_t *)(int64_t)g10 = 1;
                    v1 = *(int32_t *)&g6;
                    *(int32_t *)(int64_t)(int32_t)&g11 = v1;
                }
                // 0xfc8
                if (g12 != 10) {
                    E(g12);
                    o();
                    v2 = g12;
                    while (g12 != 10) {
                        // 0xfdc
                        E(v2);
                        o();
                        v2 = g12;
                    }
                }
                // 0xff0
                E(10);
                E(2);
            }
            // 0x1000
            o();
        }
    }
    // 0x106c
    *(int32_t *)*(int64_t *)0x12f98 = 0;
    *(int32_t *)(int64_t)g10 = g12;
    int64_t result2; // 0xf98
    if (X() != 0) {
        // 0x108c
        E(32);
        *(int32_t *)*(int64_t *)0x12fa8 = *(int32_t *)&g6;
        if (X() != 0) {
            E(g12);
            o();
            while (X() != 0) {
                // 0x10b8
                E(g12);
                o();
            }
        }
        int32_t v3 = g10; // 0x10d4
        if (v3 == 57 || v3 < 57) {
            int32_t str_as_l = strtol((char *)(int64_t)*(int32_t *)&g25, NULL, 0); // 0x11a4
            *(int32_t *)(int64_t)g17 = str_as_l;
            int64_t result = g10;
            *(int32_t *)result = 2;
            // 0x117c
            return result;
        }
        // 0x10e4
        *(char *)(int64_t)*(int32_t *)&g6 = 32;
        int32_t v4 = *(int32_t *)&g25; // 0x1100
        int32_t str = *(int32_t *)&g8; // 0x1110
        char * substr_pos = strstr((char *)(int64_t)str, (char *)(int64_t)(v4 - 1)); // 0x111c
        int32_t * v5 = (int32_t *)(int64_t)g10; // 0x1124
        *v5 = (int32_t)(int64_t)substr_pos - str;
        *(char *)(int64_t)*(int32_t *)&g6 = 0;
        *v5 = 8 * (int32_t)&g17;
        if (8 * (int32_t)&g17 <= (int32_t)".1") {
            // 0x117c
            return (int64_t)(8 * (int32_t)&g17);
        }
        int32_t v6 = *(int32_t *)&g7 + 8 * (int32_t)&g17; // 0x115c
        int64_t v7 = v6; // 0x115c
        *(int32_t *)(int64_t)g10 = v6;
        result2 = v7;
        if (*(int32_t *)(int64_t)v6 == 1) {
            // 0x11c8
            *g16 = *(int32_t *)(0x100000000 * v7 + 0x400000000 >> 32);
            *g27 = g12;
            o();
            result2 = ad();
        }
        // 0x117c
        return result2;
    }
    // 0x1204
    o();
    if (g10 == 39) {
        // 0x125c
        *(int32_t *)39 = 2;
        Y();
        *(int32_t *)(int64_t)g17 = g12;
        o();
        // 0x117c
        return o();
    }
    // 0x121c
    if (g10 == 47 == g12 == 42) {
        // 0x1294
        o();
        while (true) {
            // 0x12a4
            while (true) {
              lab_0x12cc:
                // 0x12cc
                switch (g12) {
                    case 0: {
                        goto lab_0x12ec;
                    }
                    case 42: {
                        goto lab_0x12bc;
                    }
                    default: {
                        o();
                        while (g12 != 42) {
                            // 0x12ac
                            o();
                        }
                        goto lab_0x12bc;
                    }
                }
            }
          lab_0x12e0:
            // 0x12e0
            *(int32_t *)47 = 0;
        }
      lab_0x12ec:
        // 0x12ec
        o();
        // 0x117c
        return ad();
    }
    int32_t * v8 = (int32_t *)(int64_t)g17;
    int32_t * v9 = (int32_t *)(int64_t)g22;
    int64_t v10 = (int64_t)"++#m--%am*@R<^1c/@%[_[H3c%@%[_[H3c+@.B#d-@%:_^BKd<<Z/03e>>`/03e<=0f>=/f<@.f>@1f==&g!='g&&k||#l&@.BCh^@.BSi|@.B+j~@/%Yd!@&d*@b"; // 0x1258
    int64_t v11 = v10 + 1; // 0x130c
    int64_t v12 = 0x100000000 * v10;
    unsigned char v13 = *(char *)(v12 >> 32); // 0x1314
    while (v13 != 0) {
        unsigned char v14 = *(char *)(0x100000000 * v11 >> 32); // 0x1320
        *v8 = 0;
        int64_t v15 = (int64_t)*(char *)(v12 + 0x200000000 >> 32) + 0xffffff9e; // 0x1338
        int32_t v16 = v15; // 0x133c
        *v9 = v16;
        int64_t v17 = v15 & 0xffffffff; // 0x1340
        if (v16 > -1) {
            v17 = function_4000012f8();
        }
        // 0x1344
        *v8 = (int32_t)v17 + 64 + 64 * g17;
        int64_t v18 = (int64_t)*(char *)(v12 + 0x300000000 >> 32) + 0xffffff9e; // 0x1360
        int32_t v19 = v18; // 0x1364
        *v9 = v19;
        int64_t v20 = v18 & 0xffffffff; // 0x136c
        if (v19 < 0) {
            v20 = function_400001344();
        }
        // 0x1370
        v10 = v10 + 4 & 0xffffffff;
        if (g10 == (int32_t)v13 == (v14 == 64 || g12 == (int32_t)v14)) {
            // 0x1374
            result2 = v20;
            if ((int64_t)g12 == (int64_t)v14) {
                // 0x137c
                o();
                int64_t v21 = g10;
                *(int32_t *)v21 = 1;
                result2 = v21;
                return result2;
            } else {
                return result2;
            }
        }
        v11 = v10 + 1;
        v12 = 0x100000000 * v10;
        v13 = *(char *)(v12 >> 32);
    }
    // 0x117c
    result2 = v11 & 0xffffffff;
  lab_0x117c:
    // 0x117c
    return result2;
  lab_0x12bc:
    // 0x12bc
    o();
    if (g12 == 47) {
        // break -> 0x12e0
        goto lab_0x12e0;
    }
    goto lab_0x12cc;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1394 - 0x13d0
// Line range:    128 - 133
int32_t ae(int32_t g) {
    // 0x1394
    if (g == 0 || g == -1) {
        // 0x13cc
        return g;
    }
    int32_t * v1 = (int32_t *)(int64_t)g29; // 0x13b0
    *v1 = (int32_t)&g30;
    *(char *)(int64_t)g29 = (char)g;
    int32_t result = g >> 8; // 0x13bc
    if (result != -1 != result != 0) {
        // 0x13cc
        return result;
    }
    int32_t result2 = result; // 0x13c8
    *v1 = (int32_t)&g30;
    *(char *)(int64_t)g29 = (char)result2;
    result2 >>= 8;
    while (result2 != -1 == (result2 != 0)) {
        // 0x13a8
        *v1 = (int32_t)&g30;
        *(char *)(int64_t)g29 = (char)result2;
        result2 >>= 8;
    }
    // 0x13cc
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x13d0 - 0x1400
// Line range:    134 - 141
int32_t A(int32_t e) {
    if (e == 0) {
        // 0x13fc
        return 0;
    }
    int64_t v1 = e; // 0x13d0
    int32_t * v2 = (int32_t *)(0x100000000 * v1 >> 32); // 0x13e0
    uint32_t v3 = *v2; // 0x13e0
    *v2 = -4 - (int32_t)v1 + g29;
    v1 = v3;
    while (v3 != 0) {
        // 0x13dc
        v2 = (int32_t *)(0x100000000 * v1 >> 32);
        v3 = *v2;
        *v2 = -4 - (int32_t)v1 + g29;
        v1 = v3;
    }
    // 0x13fc
    return 0;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1400 - 0x143c
// Line range:    142 - 148
// Demangled:     short
int32_t s(int32_t g, int32_t e) {
    // 0x1400
    ae(g);
    *(int32_t *)(int64_t)g29 = e;
    *(int32_t *)(int64_t)g29 = (int32_t)&g31;
    return g29;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x143c - 0x1458
// Line range:    149 - 151
int32_t H(int32_t e) {
    // 0x143c
    return s(184, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1458 - 0x1474
// Line range:    152 - 154
int32_t B(int32_t e) {
    // 0x1458
    return s(233, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1474 - 0x14ac
// Line range:    155 - 158
int32_t S(int32_t j, int32_t e) {
    // 0x1474
    ae(0xfc085);
    return s(j + 132, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x14ac - 0x14f0
// Line range:    159 - 165
int32_t Z(int32_t e) {
    // 0x14ac
    ae(0xc139);
    H(0);
    ae(15);
    ae(e + 144);
    return ae(192);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x14f0 - 0x152c
// Line range:    166 - 169
int32_t N(int32_t j, int32_t e) {
    // 0x14f0
    ae(j + 131);
    int32_t v1 = e - (int32_t)"/lib/ld-linux-aarch64.so.1"; // 0x1508
    int32_t v2 = v1 < 0 == ((v1 ^ e) & (e ^ (int32_t)"/lib/ld-linux-aarch64.so.1")) < 0 ? 5 : 133; // 0x1518
    return s(v2, e);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x152c - 0x1544
// Line range:    315 - 317
// Demangled:     wchar_t
int32_t w(void) {
    // 0x152c
    return O(11);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1544 - 0x19f8
// Line range:    170 - 256
int32_t T(int32_t j) {
    uint32_t v1 = g10; // 0x1568
    int64_t v2 = v1; // 0x1568
    int32_t v3; // 0x1544
    int64_t v4; // 0x1778
    int64_t v5; // 0x1544
    int64_t v6; // 0x1544
    int64_t v7; // 0x1544
    int64_t v8; // 0x1544
    if (v1 == 34) {
        // 0x1668
        H(g13);
        if (g12 != 34) {
            Y();
            *(int32_t *)(int64_t)g13 = (int32_t)&g14;
            *(char *)(int64_t)g13 = (char)g12;
            o();
            // 0x168c
            while (g12 != 34) {
                // 0x169c
                Y();
                *(int32_t *)(int64_t)g13 = (int32_t)&g14;
                *(char *)(int64_t)g13 = (char)g12;
                o();
            }
        }
        // 0x16c8
        *(char *)(int64_t)g13 = 0;
        *(int32_t *)(int64_t)g13 = (int32_t)&g15;
        o();
        ad();
        v5 = v2;
        goto lab_0x16f0;
    } else {
        // 0x1574
        ad();
        if (v1 == 2) {
            // 0x1720
            H(g17);
            v5 = 2;
            goto lab_0x16f0;
        } else {
            if (g22 == 2) {
                // 0x172c
                T(0);
                s(185, 0);
                if (v1 == 33) {
                    // 0x1754
                    Z(g17);
                    v5 = 33;
                } else {
                    // 0x1748
                    ae(g17);
                    v5 = v2;
                }
                goto lab_0x16f0;
            } else {
                switch (v1) {
                    case 40: {
                        // 0x1760
                        w();
                        ad();
                        v5 = 40;
                        goto lab_0x16f0;
                    }
                    case 42: {
                        // 0x176c
                        ad();
                        ad();
                        ad();
                        ad();
                        if (g10 == 42) {
                            // 0x17dc
                            ad();
                            ad();
                            ad();
                            ad();
                            T(0);
                            v6 = 0;
                            if (g10 == 61) {
                                // 0x19bc
                                ad();
                                ae(80);
                                w();
                                ae(89);
                                v7 = 0;
                                v3 = 392;
                                goto lab_0x1838;
                            } else {
                                goto lab_0x16f0_2;
                            }
                        } else {
                            // 0x1790
                            v4 = g10;
                            T(0);
                            if (g10 == 61) {
                                // 0x1814
                                ad();
                                ae(80);
                                w();
                                ae(89);
                                v7 = v4;
                                v3 = g10 == 256 ? 393 : 392;
                                goto lab_0x1838;
                            } else {
                                // 0x17b0
                                v6 = 0;
                                switch (g10) {
                                    case 0: {
                                        goto lab_0x16f0_2;
                                    }
                                    case 256: {
                                        // 0x1840
                                        ae(139);
                                        goto lab_0x17c4;
                                    }
                                    default: {
                                        // 0x17bc
                                        ae(0xbe0f);
                                        goto lab_0x17c4;
                                    }
                                }
                            }
                        }
                    }
                    default: {
                        // 0x15b0
                        if (v1 == 38) {
                            // 0x184c
                            N(10, g10);
                            ad();
                            v5 = 38;
                            goto lab_0x16f0;
                        } else {
                            int32_t v9 = g10; // 0x15c0
                            v8 = g10;
                            if (g10 == 0) {
                                uint32_t v10 = *(int32_t *)&g25; // 0x1874
                                v9 = g10;
                                v8 = (int64_t)dlsym(NULL, (char *)(int64_t)v10) & 0xffffffff;
                            }
                            // 0x15c4
                            if (((int32_t)(v9 == 61) & j) == 0) {
                                if (v9 == 40) {
                                    goto lab_0x161c;
                                } else {
                                    int32_t v11 = v8; // 0x15e8
                                    N(8, v11);
                                    if (g22 == 11) {
                                        // 0x18a0
                                        N(0, v11);
                                        ae(g17);
                                        ad();
                                    }
                                    goto lab_0x1608;
                                }
                            } else {
                                // 0x1888
                                ad();
                                w();
                                N(6, (int32_t)v8);
                                goto lab_0x1608;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x16f0:
    // 0x16f0
    v6 = v5;
    goto lab_0x16f0_2;
  lab_0x16f0_2:;
    int64_t v12 = v6; // 0x1700
    if (g10 != 40) {
        // 0x1704
        return 0;
    }
    goto lab_0x18c4;
  lab_0x18c4:
    // 0x18c4
    ae(80);
    int32_t v13 = s(0xec81, 0); // 0x18d4
    ad();
    int64_t v14 = v12; // 0x18f4
    int64_t v15 = 1; // 0x18f4
    int32_t v16 = v13; // 0x18f4
    int64_t v17; // 0x1544
    if (g10 == 41) {
        // 0x18f8
        *(int32_t *)(int64_t)v13 = 0;
        ad();
        v17 = 0;
        goto lab_0x1908;
    } else {
        goto lab_0x164c;
    }
  lab_0x164c:;
    int64_t v18 = 0; // 0x1664
    w();
    s(0x248489, (int32_t)v18);
    if (g10 == 44) {
        // 0x194c
        ad();
    }
    int64_t v19 = v18 + 4; // 0x1920
    int64_t v20 = v19 & 0xffffffff; // 0x1920
    v18 = v20;
    while (g10 != 41) {
        // 0x1930
        w();
        s(0x248489, (int32_t)v18);
        if (g10 == 44) {
            // 0x194c
            ad();
        }
        // 0x1920
        v19 = v18 + 4;
        v20 = v19 & 0xffffffff;
        v18 = v20;
    }
    // 0x1954
    *(int32_t *)(int64_t)v16 = (int32_t)v19;
    ad();
    int32_t v21 = v15;
    v17 = v20;
    int32_t v22 = v21; // 0x1544
    int64_t v23 = v20; // 0x1544
    int64_t v24 = v20; // 0x1544
    int64_t v25 = v14; // 0x1544
    switch (v21) {
        case 0: {
            goto lab_0x19a0;
        }
        case 1: {
            goto lab_0x1908;
        }
        default: {
            goto lab_0x196c;
        }
    }
  lab_0x1908:
    // 0x1908
    s(0x2494ff, (int32_t)v17);
    int64_t v26 = v17 + 4 & 0xffffffff; // 0x191c
    goto lab_0x1988;
  lab_0x19a0:;
    int32_t * v29 = (int32_t *)(0x100000000 * v25 + 0x400000000 >> 32); // 0x19a8
    *v29 = s(232, *v29);
    v26 = v24;
    goto lab_0x1988;
  lab_0x196c:
    // 0x196c
    s(232, v22 - 5 - g29);
    v26 = v23;
    goto lab_0x1988;
  lab_0x1988:
    // 0x1988
    if ((int32_t)v26 != 0) {
        // 0x198c
        int32_t v27; // 0x1988
        s(0xc481, v27);
    }
    // 0x1704
    return 0;
  lab_0x161c:
    // 0x161c
    v12 = v2;
    if (v8 == 1) {
        goto lab_0x18c4;
    } else {
        int32_t v28 = s(0xec81, 0); // 0x162c
        ad();
        v14 = v2;
        v15 = v8;
        v16 = v28;
        if (g10 == 41) {
            // 0x19e0
            *(int32_t *)(int64_t)v28 = 0;
            ad();
            v24 = 0;
            v25 = v2;
            if (v8 == 0) {
                goto lab_0x19a0;
            } else {
                // 0x19e0
                v22 = v8;
                v23 = 0;
                goto lab_0x196c;
            }
        } else {
            goto lab_0x164c;
        }
    }
  lab_0x1608:
    // 0x1608
    if (g10 != 40) {
        // 0x1704
        return 0;
    }
    goto lab_0x161c;
  lab_0x1838:
    // 0x1838
    ae(v3);
    v5 = v7;
    goto lab_0x16f0;
  lab_0x17c4:
    // 0x17c4
    *(int32_t *)(int64_t)g29 = (int32_t)&g30;
    v5 = v4;
    goto lab_0x16f0;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x19f8 - 0x1b2c
// Line range:    279 - 311
int32_t O(int32_t j) {
    if (j == 1) {
        // 0x1ae0
        return T(1);
    }
    uint32_t v1 = j - 1; // 0x1a18
    O(v1);
    if (g22 != v1) {
        // 0x1ae0
        return g22;
    }
    int64_t v2 = 0;
    ad();
    int64_t v3; // 0x19f8
    while (v1 < 9) {
        // 0x1a4c
        ae(80);
        O(v1);
        ae(89);
        if (v1 == 5 || v1 == 4) {
            // 0x1abc
            Z(g17);
        } else {
            // 0x1a70
            ae(g17);
            if (g10 == 37) {
                // 0x1ac8
                ae(146);
            }
        }
        // 0x1a80
        v3 = v2;
        if (g22 != v1) {
            // break (via goto) -> 0x1ad4
            goto lab_0x1ad4;
        }
        ad();
    }
    int64_t v4 = S(g17, (int32_t)v2); // 0x1aac
    O(v1);
    v3 = v4;
    while (g22 == v1) {
        // 0x1a8c
        v2 = v4;
        ad();
        while (v1 < 9) {
            // 0x1a4c
            ae(80);
            O(v1);
            ae(89);
            if (v1 == 5 || v1 == 4) {
                // 0x1abc
                Z(g17);
            } else {
                // 0x1a70
                ae(g17);
                if (g10 == 37) {
                    // 0x1ac8
                    ae(146);
                }
            }
            // 0x1a80
            v3 = v2;
            if (g22 != v1) {
                // break (via goto) -> 0x1ad4
                goto lab_0x1ad4;
            }
            ad();
        }
        // 0x1aa0
        v4 = S(g17, (int32_t)v2);
        O(v1);
        v3 = v4;
    }
  lab_0x1ad4:
    // 0x1ad4
    if (v3 == 0) {
        // 0x1ae0
        return g22;
    }
    int32_t v5 = j - 9; // 0x1ad8
    int32_t result = g22; // 0x1adc
    if (v5 != 0 && v5 < 0 == (8 - j & v1) < 0) {
        int32_t v6 = S(g17, (int32_t)v3); // 0x1b00
        H(g17 ^ 1);
        B(5);
        A(v6);
        result = H(g17);
    }
    // 0x1ae0
    return result;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1b2c - 0x1b4c
// Line range:    318 - 321
int32_t U(void) {
    // 0x1b2c
    w();
    return S(0, 0);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1b4c - 0x1cfc
// Line range:    389 - 430
int32_t ab(int32_t j) {
    int32_t result = g10; // 0x1c58
    if (result != 256 && j == 0 != result != -1) {
        // 0x1ce4
        return result;
    }
    // 0x1c70
    int32_t v1; // 0x1c2c
    int64_t v2; // 0x1cc8
    int64_t v3; // 0x1b4c
    int64_t v4; // 0x1b4c
    if (result == 256) {
        // 0x1b7c
        ad();
        while (true) {
            if (g10 == 59) {
                // break (via goto) -> 0x1bf4
                goto lab_0x1bf4;
            }
            if (j == 0) {
                // 0x1b90
                *(int32_t *)(int64_t)g10 = g13;
                *(int32_t *)(int64_t)g13 = (int32_t)&g15;
            } else {
                // 0x1bcc
                *g23 = (int32_t)&g24;
                *(int32_t *)(int64_t)g10 = -4 - *(int32_t *)&g23;
            }
            // 0x1ba8
            ad();
            // 0x1b84
            while (g10 != 44) {
                // 0x1bbc
                if (g10 == 59) {
                    // break (via goto) -> 0x1bf4
                    goto lab_0x1bf4;
                }
                if (j == 0) {
                    // 0x1b90
                    *(int32_t *)(int64_t)g10 = g13;
                    *(int32_t *)(int64_t)g13 = (int32_t)&g15;
                } else {
                    // 0x1bcc
                    *g23 = (int32_t)&g24;
                    *(int32_t *)(int64_t)g10 = -4 - *(int32_t *)&g23;
                }
                // 0x1ba8
                ad();
            }
            // 0x1bec
            ad();
        }
        // 0x1bf4
        ad();
    } else {
        // 0x1c78
        A(g11);
        *(int32_t *)(int64_t)g10 = g29;
        ad();
        ad();
        v3 = 8;
        while (true) {
            // 0x1cb4
            if (g10 == 41) {
                // break (via goto) -> 0x1bfc
                goto lab_0x1bfc;
            }
            // 0x1cc0
            *(int32_t *)(int64_t)g10 = (int32_t)v3;
            v2 = v3 + 4 & 0xffffffff;
            ad();
            v4 = v2;
            while (g10 != 44) {
                // 0x1cb4
                if (g10 == 41) {
                    // break (via goto) -> 0x1bfc
                    goto lab_0x1bfc;
                }
                // 0x1cc0
                *(int32_t *)(int64_t)g10 = (int32_t)v4;
                v2 = v4 + 4 & 0xffffffff;
                ad();
                v4 = v2;
            }
            // 0x1cdc
            ad();
            v3 = v2;
        }
        // 0x1bfc
        ad();
        *g23 = 0;
        *(int32_t *)(int64_t)g26 = 0;
        ae(0xe58955);
        v1 = s(0xec81, 0);
        I(0);
        A(g26);
        ae(0xc3c9);
        *(int32_t *)(int64_t)v1 = *(int32_t *)&g23;
    }
    int32_t v5 = g10; // 0x1c58
    bool v6 = v5 == 256; // 0x1c6c
    int32_t result2 = v5; // 0x1c6c
    while (v5 == 256 || j == 0 == (v5 != -1)) {
        // 0x1c70
        if (v6) {
            // 0x1b7c
            ad();
            while (true) {
                if (g10 == 59) {
                    // break (via goto) -> 0x1bf4
                    goto lab_0x1bf4;
                }
                if (j == 0) {
                    // 0x1b90
                    *(int32_t *)(int64_t)g10 = g13;
                    *(int32_t *)(int64_t)g13 = (int32_t)&g15;
                } else {
                    // 0x1bcc
                    *g23 = (int32_t)&g24;
                    *(int32_t *)(int64_t)g10 = -4 - *(int32_t *)&g23;
                }
                // 0x1ba8
                ad();
                // 0x1b84
                while (g10 != 44) {
                    // 0x1bbc
                    if (g10 == 59) {
                        // break (via goto) -> 0x1bf4
                        goto lab_0x1bf4;
                    }
                    if (j == 0) {
                        // 0x1b90
                        *(int32_t *)(int64_t)g10 = g13;
                        *(int32_t *)(int64_t)g13 = (int32_t)&g15;
                    } else {
                        // 0x1bcc
                        *g23 = (int32_t)&g24;
                        *(int32_t *)(int64_t)g10 = -4 - *(int32_t *)&g23;
                    }
                    // 0x1ba8
                    ad();
                }
                // 0x1bec
                ad();
            }
            // 0x1bf4
            ad();
        } else {
            // 0x1c78
            A(g11);
            *(int32_t *)(int64_t)g10 = g29;
            ad();
            ad();
            v3 = 8;
            while (true) {
                // 0x1cb4
                v4 = v3;
                if (g10 == 41) {
                    // break (via goto) -> 0x1bfc
                    goto lab_0x1bfc;
                }
                // 0x1cc0
                *(int32_t *)(int64_t)g10 = (int32_t)v4;
                v2 = v4 + 4 & 0xffffffff;
                ad();
                v4 = v2;
                while (g10 != 44) {
                    // 0x1cb4
                    if (g10 == 41) {
                        // break (via goto) -> 0x1bfc
                        goto lab_0x1bfc;
                    }
                    // 0x1cc0
                    *(int32_t *)(int64_t)g10 = (int32_t)v4;
                    v2 = v4 + 4 & 0xffffffff;
                    ad();
                    v4 = v2;
                }
                // 0x1cdc
                ad();
                v3 = v2;
            }
            // 0x1bfc
            ad();
            *g23 = 0;
            *(int32_t *)(int64_t)g26 = 0;
            ae(0xe58955);
            v1 = s(0xec81, 0);
            I(0);
            A(g26);
            ae(0xc3c9);
            *(int32_t *)(int64_t)v1 = *(int32_t *)&g23;
        }
        // 0x1c58
        v5 = g10;
        v6 = v5 == 256;
        result2 = v5;
    }
    // 0x1ce4
    return result2;
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1cfc - 0x1f48
// Line range:    322 - 383
int32_t I(int32_t j) {
    // 0x1cfc
    int32_t v1; // 0x1cfc
    int32_t v2; // 0x1cfc
    switch (g10) {
        case 288: {
            // 0x1d64
            ad();
            ad();
            v1 = U();
            ad();
            I(j);
            int32_t result; // 0x1cfc
            if (g10 == 312) {
                // 0x1da0
                ad();
                int32_t v3 = B(0); // 0x1da8
                A(v1);
                I(j);
                result = A(v3);
            } else {
                // 0x1d94
                result = A(v1);
            }
            // 0x1d58
            return result;
        }
        case 504: {
        }
        case 352: {
            // 0x1dcc
            ad();
            ad();
            if (g10 == 352) {
                // 0x1ea0
                v1 = U();
                v2 = g29;
            } else {
                // 0x1ddc
                if (g10 != 59) {
                    // 0x1df0
                    w();
                }
                // 0x1df4
                ad();
                v1 = 0;
                if (g10 != 59) {
                    // 0x1e1c
                    v1 = U();
                }
                // 0x1e24
                ad();
                v2 = g29;
                if (g10 != 41) {
                    int32_t v4 = B(0); // 0x1e40
                    w();
                    B(g29 - 5 - g29);
                    A(v4);
                    v2 = v4 + 4;
                }
            }
            // break -> 0x1e70
            break;
        }
        case 123: {
            // 0x1eb8
            ad();
            ab(1);
            if (g10 != 125) {
                I(j);
                while (g10 != 125) {
                    // 0x1ee0
                    I(j);
                }
            }
            // 0x1d58
            return ad();
        }
        case 448: {
            // 0x1efc
            ad();
            if (g10 != 59) {
                // 0x1f14
                w();
            }
            uint32_t v5 = g26;
            *(int32_t *)(int64_t)v5 = B(v5);
            // 0x1d58
            return ad();
        }
        case 400: {
            // 0x1f30
            ad();
            int64_t v6; // 0x1cfc
            *(int32_t *)(int64_t)j = B((int32_t)v6);
            // 0x1d58
            return ad();
        }
        case 59: {
            // 0x1d58
            return ad();
        }
        default: {
            // 0x1d50
            w();
            // 0x1d58
            return ad();
        }
    }
    // 0x1e70
    ad();
    I((int32_t)(int64_t)&v1);
    B(v2 - 5 - g29);
    // 0x1d58
    return A(v1);
}

// From module:   /mnt/from_holdec/./otcc/otcc/source.c
// Address range: 0x1f48 - 0x207c
// Line range:    431 - 445
int main(int g, char ** e) {
    // 0x1f48
    *g28 = (int32_t)*(int64_t *)g18;
    if (g >= 2) {
        int32_t file_path = *(int32_t *)(0x100000000 * (int64_t)e + 0x400000000 >> 32); // 0x1f90
        struct _IO_FILE * file = fopen((char *)(int64_t)file_path, "r"); // 0x1f94
        *g28 = (int32_t)(int64_t)file;
    }
    int64_t * mem = calloc(1, 0x1869f); // 0x1fb4
    int64_t v1 = (int64_t)mem; // 0x1fb4
    *g8 = (int32_t)v1;
    int64_t v2 = 0x100000000 * v1 >> 32; // 0x1fc4
    *mem = 0x20666920746e6920;
    *(int64_t *)(v2 + 8) = 0x6968772065736c65;
    *(int64_t *)(v2 + 16) = 0x6b6165726220656c;
    *(int64_t *)(v2 + 24) = 0x206e727574657220;
    *(int64_t *)(v2 + 32) = 0x6966656420726f66;
    *(int64_t *)(v2 + 40) = 0x206e69616d20656e;
    int64_t v3 = v2 + 48; // 0x1fec
    *(char *)v3 = 0;
    *g6 = (int32_t)v3;
    int64_t * mem2 = calloc(1, 0x1869f); // 0x2004
    *(int32_t *)(int64_t)g13 = (int32_t)(int64_t)mem2;
    int32_t mem3 = (int64_t)calloc(1, 0x1869f); // 0x2028
    *g19 = mem3;
    *(int32_t *)(int64_t)g29 = mem3;
    *g7 = (int32_t)(int64_t)calloc(1, 0x1869f);
    o();
    ad();
    ab(0);
    return g - 1;
}

// Address range: 0x207c - 0x208c
int64_t function_207c(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5) {
    // 0x207c
    int64_t result; // 0x207c
    return result;
}

// Address range: 0x2090 - 0x2108
int64_t __libc_csu_init(void) {
    // 0x2090
    int64_t v1; // 0x2090
    int64_t result = _init(v1); // 0x20c4
    if ((int64_t)&g2 - (int64_t)&g1 >> 3 == 0) {
        // 0x20f4
        return result;
    }
    // 0x20d4
    return v1 & 0xffffffff;
}

// Address range: 0x2108 - 0x210c
int64_t __libc_csu_fini(void) {
    // 0x2108
    int64_t result; // 0x2108
    return result;
}

// Address range: 0x210c - 0x211c
int64_t _fini(int64_t a1) {
    // 0x210c
    int64_t result; // 0x210c
    return result;
}

// Address range: 0x4000012f8 - 0x4000012f9
int64_t function_4000012f8(void) {
    // 0x4000012f8
    int64_t result; // 0x4000012f8
    return result;
}

// Address range: 0x400001344 - 0x400001345
int64_t function_400001344(void) {
    // 0x400001344
    int64_t result; // 0x400001344
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int64_t __cxa_finalize(void);
// int64_t __gmon_start__(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int64_t _ITM_deregisterTMCloneTable(int64_t * a1, int64_t a2);
// int64_t _Jv_RegisterClasses(int64_t * a1, int64_t a2);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// void * dlsym(void * restrict handle, const char * restrict name);
// int fgetc(FILE * stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int isalnum(int c);
// int isspace(int c);
// char * strstr(char * haystack, const char * needle);
// long int strtol(const char * restrict nptr, char ** restrict endptr, int base);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (6.3.0)
// Detected functions: 46

