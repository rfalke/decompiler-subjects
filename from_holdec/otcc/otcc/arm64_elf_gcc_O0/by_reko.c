// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b13070 = 0x00; // 0000000000013070
word32 g_dw13074 = 0x00; // 0000000000013074
byte g_b13077 = 0x00; // 0000000000013077
word32 g_dw13078 = 0x00; // 0000000000013078
word32 g_dw1307C = 0x00; // 000000000001307C
Eq_106 g_t13080 = // 0000000000013080
	{
		0
	};
Eq_106 g_t13084 = // 0000000000013084
	{
		0
	};
Eq_106 g_t13088 = // 0000000000013088
	{
		0
	};
word32 g_dw1308C = 0x00; // 000000000001308C
Eq_106 g_t13090 = // 0000000000013090
	{
		0
	};
word32 g_dw13094 = 0x00; // 0000000000013094
int32 g_dw13098 = 0; // 0000000000013098
Eq_106 g_t1309C = // 000000000001309C
	{
		0
	};
word32 g_dw130A0 = 0x00; // 00000000000130A0
Eq_106 g_t130A4 = // 00000000000130A4
	{
		0
	};
Eq_106 g_t130A8 = // 00000000000130A8
	{
		0
	};
word32 g_dw130AC = 0x00; // 00000000000130AC
word32 g_dw130B0 = 0x00; // 00000000000130B0
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw13068 = 77928; // 0000000000013068
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 000000000000259C: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_csu_fini_GOT = __libc_csu_fini; // 0000000000012F20
<anonymous> * g_ptr12F28 = null; // 0000000000012F28
word32 * g_ptr12F30 = &g_dw13074; // 0000000000012F30
word32 * g_ptr12F38 = &g_dw13078; // 0000000000012F38
word32 * g_ptr12F40 = &g_dw1307C; // 0000000000012F40
word64 g_qw12F48 = 0x00; // 0000000000012F48
union Eq_106 * g_ptr12F50 = &g_t13080; // 0000000000012F50
union Eq_106 * g_ptr12F58 = &g_t13084; // 0000000000012F58
union Eq_106 * g_ptr12F60 = &g_t13088; // 0000000000012F60
word32 * g_ptr12F68 = &g_dw1308C; // 0000000000012F68
union Eq_106 * g_ptr12F70 = &g_t13090; // 0000000000012F70
word32 * g_ptr12F78 = null; // 0000000000012F78
word32 * g_ptr12F80 = &g_dw13094; // 0000000000012F80
word64 g_qw12F88 = 0x00; // 0000000000012F88
<anonymous> * __libc_csu_init_GOT = __libc_csu_init; // 0000000000012F90
int32 * g_ptr12F98 = &g_dw13098; // 0000000000012F98
union Eq_106 * g_ptr12FA0 = &g_t1309C; // 0000000000012FA0
word32 * g_ptr12FA8 = &g_dw130A0; // 0000000000012FA8
union Eq_106 * g_ptr12FB0 = &g_t130A4; // 0000000000012FB0
union Eq_106 * g_ptr12FB8 = &g_t130A8; // 0000000000012FB8
word32 * g_ptr12FC0 = &g_dw130AC; // 0000000000012FC0
word32 * g_ptr12FC8 = &g_dw130B0; // 0000000000012FC8
<anonymous> * main_GOT = main; // 0000000000012FD0
<anonymous> * g_ptr12FD8 = null; // 0000000000012FD8
<anonymous> * g_ptr12FE0 = null; // 0000000000012FE0
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_66 g_t13000 = // 0000000000013000
	{
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000C10: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_weak_fn();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a12D10[] = // 0000000000012D10
	{
	};
// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw12D20 = 0x00; // 0000000000012D20
// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw2640 = 0x20666920746E6920; // 0000000000002640
word64 g_qw2648 = 7595451752585063525; // 0000000000002648
word64 g_qw2650 = 0x6B6165726220656C; // 0000000000002650
word64 g_qw2658 = 0x206E727574657220; // 0000000000002658
word64 g_qw2660 = 0x6966656420726F66; // 0000000000002660
word64 g_qw2668 = 0x206E69616D20656E; // 0000000000002668
byte g_b2670 = 0x00; // 0000000000002670
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000D10: void _start(Register (ptr64 Eq_5) x0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* x0)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__libc_start_main(main_GOT, (int32) qwArg00, &ptrArg08, __libc_csu_init_GOT, __libc_csu_fini_GOT, x0, fp);
	abort();
}

// 0000000000000D48: void call_weak_fn()
// Called from:
//      _init
void call_weak_fn()
{
	if (g_qw12F88 == 0x00)
		return;
	__gmon_start__();
}

// 0000000000000D60: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (&g_b13077 - &g_b13070 <= 0x0E)
		return;
	<anonymous> * x1_13 = g_ptr12F28;
	if (x1_13 == null)
		return;
	x1_13();
}

// 0000000000000D98: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	byte * x1_7 = &g_b13070 - &g_b13070;
	if ((x1_7 >> 3) + ((x1_7 >> 3) >>u 63) >> 1 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr12FE0;
	if (x2_13 == null)
		return;
	word64 x2_17;
	x2_13();
}

// 0000000000000DD8: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_66 * x19_11 = &g_t13000;
	if ((word32) g_b13070 == 0x00)
	{
		if (g_qw12F48 != 0x00)
			__cxa_finalize(&g_t13000, g_qw13068);
		deregister_tm_clones();
		x19_11->b0070 = 0x01;
	}
}

// 0000000000000E20: void frame_dummy(Register word64 x29, Register word64 x30)
void frame_dummy(word64 x29, word64 x30)
{
	ptr64 fp;
	if (g_qw12D20 != 0x00)
	{
		<anonymous> * x1_8 = g_ptr12FD8;
		if (x1_8 != null)
		{
			x1_8();
			register_tm_clones();
			return;
		}
	}
	register_tm_clones();
}

// 0000000000000E58: Register word64 E(Register Eq_106 w0)
// Called from:
//      ad
word64 E(Eq_106 w0)
{
	word32 * x1_11 = g_ptr12F30;
	word32 w0_8 = *g_ptr12F30;
	*x1_11 = w0_8 + 0x01;
	uint32 w1_15 = (uint32) (uint8) w0;
	null[(int64) w0_8] = (byte) w1_15;
	return SEQ(SLICE(x1_11, word32, 32), w1_15);
}

// 0000000000000E98: Register word64 o()
// Called from:
//      Y
//      ad
//      T
//      main
word64 o()
{
	word32 x1_32_32;
	word64 x1_76;
	if (*g_ptr12F68 != 0x00)
	{
		word32 * x1_29 = g_ptr12F68;
		word32 w0_26 = *g_ptr12F68;
		*x1_29 = w0_26 + 0x01;
		Eq_106 w0_33 = (word32) null[(int64) w0_26];
		g_ptr12F58->u0 = (int32) w0_33;
		word32 x1_32_32_77 = SLICE(x1_29, word32, 32);
		x1_76 = SEQ(x1_32_32_77, w0_33);
		if (g_ptr12F58->u0 == 0x02)
		{
			*g_ptr12F68 = 0x00;
			Eq_106 w1_48 = g_ptr12FB8->u0;
			g_ptr12F58->u0 = (int32) w1_48;
			x1_76 = SEQ(x1_32_32_77, w1_48);
		}
	}
	else
	{
		Eq_106 w0_19 = fgetc((int64) *g_ptr12FC0);
		g_ptr12F58->u0 = (int32) w0_19;
		x1_76 = SEQ(x1_32_32, w0_19);
	}
	return x1_76;
}

// 0000000000000F54: Register ui32 X()
// Called from:
//      ad
ui32 X()
{
	union Eq_106 * x0_10 = g_ptr12F58;
	ui32 w0_20 = (word32) isalnum(0x00012000, SEQ(SLICE(x0_10, word32, 32), x0_10->u0));
	union Eq_106 * x0_23 = g_ptr12F58;
	return w0_20 | (uint32) ((uint8) (x0_23->u0 == 0x5F));
}

// 0000000000000F94: void Y()
// Called from:
//      ad
//      T
void Y()
{
	if (g_ptr12F58->u0 == 0x5C)
	{
		o();
		if (g_ptr12F58->u0 == 110)
			g_ptr12F58->u0 = 0x0A;
	}
}

// 0000000000000FE4: Register word64 ad()
// Called from:
//      ad
//      T
//      O
//      I
//      ab
//      main
word64 ad()
{
	while (true)
	{
		union Eq_106 * x0_11 = g_ptr12F58;
		if (((word32) isspace(0x00012000, SEQ(SLICE(x0_11, word32, 32), x0_11->u0)) | (uint32) ((uint8) (g_ptr12F58->u0 == 0x23))) == 0x00)
			break;
		if (g_ptr12F58->u0 == 0x23)
		{
			o();
			ad();
			if (g_ptr12F50->u0 == 0x0218)
			{
				ad();
				E(0x20);
				null[(int64) g_ptr12F50->u0 /64 4] = 0x01;
				null[(int64) (g_ptr12F50->u0 + 0x04) /64 4] = *g_ptr12F30;
			}
			while (g_ptr12F58->u0 != 0x0A)
			{
				E(g_ptr12F58->u0);
				o();
			}
			E(g_ptr12F58->u0);
			E(0x02);
		}
		o();
	}
	word64 x1_330;
	*g_ptr12F98 = 0x00;
	g_ptr12F50->u0 = g_ptr12F58->u0;
	if (X() != 0x00)
	{
		word32 x1_32_32_575 = SLICE(E(0x20), word32, 32);
		*g_ptr12FA8 = *g_ptr12F30;
		while (X() != 0x00)
		{
			E(g_ptr12F58->u0);
			x1_32_32_575 = SLICE(o(), word32, 32);
		}
		Eq_106 w0_399 = g_ptr12F50->u0;
		if (w0_399 <= 0x39 && w0_399 >= 0x30)
		{
			word32 * x0_503 = g_ptr12FA8;
			g_ptr12F70->u0 = (int32) strtol(SEQ(SLICE(x0_503, word32, 32), *x0_503));
			g_ptr12F50->u0 = 0x02;
			x1_330 = SEQ(x1_32_32_575, 0x02);
		}
		else
		{
			null[(int64) *g_ptr12F30] = 0x20;
			char * x0_422 = strstr((int64) *g_ptr12F40, (int64) (*g_ptr12FA8 - 0x01));
			g_ptr12F50->u0 = (int32) ((word32) x0_422 + (0x00 - *g_ptr12F40));
			null[(int64) *g_ptr12F30] = 0x00;
			Eq_106 w1_444 = g_ptr12F50->u0 + 0x20 << 3;
			g_ptr12F50->u0 = (int32) w1_444;
			word32 x1_32_32_579 = SLICE(x0_422, word32, 32);
			x1_330 = SEQ(x1_32_32_579, w1_444);
			if (g_ptr12F50->u0 > 0x0218)
			{
				Eq_106 w1_459 = *g_ptr12F38 + g_ptr12F50->u0;
				g_ptr12F50->u0 = (int32) w1_459;
				x1_330 = SEQ(x1_32_32_579, w1_459);
				if (null[(int64) g_ptr12F50->u0 /64 4] == 0x01)
				{
					*g_ptr12F68 = null[(int64) (g_ptr12F50->u0 + 0x04) /64 4];
					g_ptr12FB8->u0 = g_ptr12F58->u0;
					o();
					x1_330 = ad();
				}
			}
		}
	}
	else
	{
		word32 x1_32_32_583 = SLICE(o(), word32, 32);
		if (g_ptr12F50->u0 == 0x27)
		{
			g_ptr12F50->u0 = 0x02;
			Y();
			g_ptr12F70->u0 = g_ptr12F58->u0;
			o();
			x1_330 = o();
		}
		else if ((uint32) ((uint8) (g_ptr12F50->u0 == 0x2F) & (uint8) (g_ptr12F58->u0 == 0x2A)) != 0x00)
		{
			o();
			while (g_ptr12F58->u0 != 0x00)
			{
				while (g_ptr12F58->u0 != 0x2A)
					o();
				o();
				if (g_ptr12F58->u0 == 0x2F)
					g_ptr12F58->u0 = 0x00;
			}
			o();
			x1_330 = ad();
		}
		else
		{
			x29_19->dw001C = (word32) 9656;
			do
			{
				word32 w0_179 = x29_19->dw001C;
				x29_19->dw001C = w0_179 + 0x01;
				x29_19->t0018.u0 = (word32) null[(int64) w0_179];
				x1_330 = SEQ(x1_32_32_583, w0_179 + 0x01);
				if (x29_19->t0018.u0 == 0x00)
					return x1_330;
				word32 w0_189 = x29_19->dw001C;
				x29_19->dw001C = w0_189 + 0x01;
				x29_19->t0014.u0 = (word32) null[(int64) w0_189];
				g_ptr12F70->u0 = 0x00;
				while (true)
				{
					word32 w0_201 = x29_19->dw001C;
					x29_19->dw001C = w0_201 + 0x01;
					*g_ptr12F98 = (word32) null[(int64) w0_201] - 0x62;
					if (*g_ptr12F98 >= 0x00)
						break;
					g_ptr12F70->u0 = (int32) ((g_ptr12F70->u0 << 6) + *g_ptr12F98 + 0x40);
				}
			} while (((uint32) (uint8) (x29_19->t0018.u0 == g_ptr12F50->u0) & (uint32) ((uint8) ((x29_19->t0014).u0 == g_ptr12F58->u0) | (uint8) ((x29_19->t0014).u0 == 0x40))) == 0x00);
			Eq_106 w1_258 = x29_19->t0014.u0;
			x1_330 = SEQ(x1_32_32_583, w1_258);
			if (w1_258 == g_ptr12F58->u0)
			{
				word32 x1_32_32_588 = SLICE(o(), word32, 32);
				g_ptr12F50->u0 = 0x01;
				x1_330 = SEQ(x1_32_32_588, 0x01);
			}
		}
	}
	return x1_330;
}

// 0000000000001564: void ae()
// Called from:
//      s
//      S
//      Z
//      N
//      T
//      O
//      ab
void ae()
{
	ptr64 fp;
	struct Eq_774 * sp_24 = fp - 0x10;
	while (true)
	{
		word32 sp_32_32_23 = SLICE(sp_24, word32, 32);
		if (sp_24->t000C.u0 == 0x00)
			break;
		Eq_781 w0_11 = sp_24->t000C.u0;
		sp_24 = SEQ(sp_32_32_23, (word32) w0_11 + 1);
		if (w0_11 == ~0x00)
			return;
		word32 w0_17 = *g_ptr12FC8;
		*g_ptr12FC8 = w0_17 + 0x01;
		null[(int64) w0_17].t0000.u1 = sp_24->t000C.u1;
		sp_24->t000C.u0 = (int32) (sp_24->t000C.u0 >> 8);
	}
}

// 00000000000015CC: void A(Register Eq_106 w0)
// Called from:
//      O
//      I
//      ab
void A(Eq_106 w0)
{
	int32 dwLoc1A;
	Eq_106 dwLoc14_28 = w0;
	while (dwLoc14_28 != 0x00)
	{
		Eq_106 w0_13 = null[(int64) dwLoc1A /64 4].u0;
		null[(int64) dwLoc1A /64 4] = *g_ptr12FC8 - dwLoc14_28 - 0x04;
		dwLoc14_28 = w0_13;
	}
}

// 0000000000001628: Register word32 s(Register Eq_106 w1)
// Called from:
//      H
//      B
//      S
//      N
//      T
//      ab
word32 s(Eq_106 w1)
{
	ae();
	null[(int64) *g_ptr12FC8 /64 4].u0 = (int32) w1;
	word32 * x0_37 = g_ptr12FC8;
	word32 w0_30 = *g_ptr12FC8;
	*x0_37 = *g_ptr12FC8 + 0x04;
	return w0_30;
}

// 0000000000001694: void H(Register Eq_106 w0)
// Called from:
//      Z
//      T
//      O
void H(Eq_106 w0)
{
	s(w0);
}

// 00000000000016B8: Register Eq_106 B(Register Eq_106 w0)
// Called from:
//      O
//      I
Eq_106 B(Eq_106 w0)
{
	return s(w0);
}

// 00000000000016D8: Register Eq_106 S(Register Eq_106 w1)
// Called from:
//      O
//      U
Eq_106 S(Eq_106 w1)
{
	ae();
	return s(w1);
}

// 000000000000170C: void Z()
// Called from:
//      T
//      O
void Z()
{
	ae();
	H(0x00);
	ae();
	ae();
	ae();
}

// 0000000000001750: void N(Register Eq_106 w1)
// Called from:
//      T
void N(Eq_106 w1)
{
	ae();
	s(w1);
}

// 0000000000001798: Register word64 T(Register ui32 w0)
// Called from:
//      T
//      O
word64 T(ui32 w0)
{
	ptr64 fp;
	int32 dwLoc24;
	struct Eq_906 * x29_144 = fp + -64;
	if (g_ptr12F50->u0 == 0x22)
	{
		H(g_ptr12F60->u0);
		while (g_ptr12F58->u0 != 0x22)
		{
			Y();
			Eq_106 w0_425 = g_ptr12F60->u0;
			g_ptr12F60->u0 = (word32) w0_425 + 1;
			null[(int64) w0_425].t0000.u1 = g_ptr12F58->u1;
			o();
		}
		null[(int64) g_ptr12F60->u0] = 0x00;
		g_ptr12F60->u0 = (int32) (g_ptr12F60->u0 + 0x04 & ~0x03);
		o();
		ad();
	}
	else
	{
		int32 w0_22 = *g_ptr12F98;
		Eq_106 w0_26 = g_ptr12F70->u0;
		Eq_106 w0_30 = g_ptr12F50->u0;
		word32 x1_32_32_68 = SLICE(ad(), word32, 32);
		if (w0_30 == 0x02)
			H(w0_26);
		else if (w0_22 == 0x02)
		{
			x29_144 = T(0x00);
			s(0x00);
			if (x29_144->dw0038 == 33)
				Z();
			else
				ae();
		}
		else if (w0_30 == 0x28)
		{
			x29_144 = w();
			ad();
		}
		else if (w0_30 == 0x2A)
		{
			ad();
			ad();
			ad();
			if (g_ptr12F50->u0 == 0x2A)
			{
				ad();
				ad();
				ad();
				ad();
			}
			ad();
			x29_144 = T(0x00);
			if (g_ptr12F50->u0 == 0x3D)
			{
				ad();
				ae();
				x29_144 = w();
				ae();
				x29_144->dw0038 != 0x0100;
				ae();
			}
			else if (x29_144->dw0038 != 0x00)
			{
				if (x29_144->dw0038 == 0x0100)
					ae();
				else
					ae();
				++*g_ptr12FC8;
			}
		}
		else if (w0_30 == 0x26)
		{
			N(null[(int64) g_ptr12F50->u0 /64 4].u0);
			ad();
		}
		else
		{
			Eq_106 w0_56 = null[(int64) dwLoc24 /64 4].u0;
			Eq_106 dwLoc04_673 = w0_56;
			if (w0_56 == 0x00)
			{
				word32 * x0_62 = g_ptr12FA8;
				dwLoc04_673 = (word32) dlsym(SEQ(SLICE(x0_62, word32, 32), 0x00), SEQ(x1_32_32_68, *x0_62));
			}
			if (((uint32) (uint8) (g_ptr12F50->u0 == 0x3D) & w0) != 0x00)
			{
				ad();
				x29_144 = w();
				N(x29_144->t003C.u0);
			}
			else if (g_ptr12F50->u0 != 0x28)
			{
				N(dwLoc04_673);
				if (*g_ptr12F98 == 11)
				{
					N(dwLoc04_673);
					ae();
					ad();
				}
			}
		}
	}
	if (g_ptr12F50->u0 == 0x28)
	{
		if (x29_144->t003C.u0 == 0x01)
			ae();
		x29_144->t0030.u0 = (int32) s(0x00);
		ad();
		x29_144->t002C.u0 = 0x00;
		while (g_ptr12F50->u0 != 0x29)
		{
			x29_144 = w();
			s(x29_144->t002C.u0);
			if (g_ptr12F50->u0 == 44)
				ad();
			x29_144->t002C.u0 = (int32) (x29_144->t002C.u0 + 0x04);
		}
		null[(int64) x29_144->dw0018 /64 4].u0 = x29_144->t002C.u0;
		ad();
		if (x29_144->t003C.u0 == 0x00)
		{
			x29_144->dw0038 += 0x04;
			null[(int64) x29_144->dw001C /64 4].u0 = (int32) s(null[(int64) x29_144->dw001C /64 4].u0);
		}
		else if (x29_144->t003C.u0 == 0x01)
		{
			s(x29_144->t002C.u0);
			x29_144->t002C.u0 = (int32) (x29_144->t002C.u0 + 0x04);
		}
		else
			s(x29_144->t003C.u0 - *g_ptr12FC8 - 0x05);
		if (x29_144->t002C.u0 != 0x00)
			s(x29_144->t002C.u0);
	}
	return <invalid>;
}

// 0000000000001C60: Register word64 O(Register int32 w0)
// Called from:
//      O
//      w
word64 O(int32 w0)
{
	if (w0 == 0x01)
		T(0x01);
	else
	{
		struct Eq_1315 * x29_130 = O(w0 - 0x01);
		x29_130->t0028.u0 = 0x00;
		while (x29_130->dw001C == *g_ptr12F98)
		{
			x29_130->t0024.u0 = g_ptr12F50->u0;
			x29_130->t002C.u0 = g_ptr12F70->u0;
			ad();
			if (x29_130->dw001C > 0x08)
			{
				x29_130->t0028.u0 = (int32) S(x29_130->t0028.u0);
				x29_130 = O(x29_130->dw001C);
			}
			else
			{
				ae();
				x29_130 = O(x29_130->dw001C);
				ae();
				if ((uint32) ((uint8) (x29_130->dw001C == 0x04) | (uint8) (x29_130->dw001C == 0x05)) != 0x00)
					Z();
				else
				{
					ae();
					if (x29_130->t0024.u0 == 0x25)
						ae();
				}
			}
		}
		if (x29_130->t0028.u0 != 0x00 && x29_130->dw001C > 0x08)
		{
			x29_130->t0028.u0 = (int32) S(x29_130->t0028.u0);
			H(x29_130->t002C.u0 ^ 0x01);
			B(0x05);
			A(x29_130->t0028.u0);
			H(x29_130->t002C.u0);
		}
	}
	return <invalid>;
}

// 0000000000001DC8: Register word64 w()
// Called from:
//      T
//      U
//      I
word64 w()
{
	O(11);
	return <invalid>;
}

// 0000000000001DE4: void U()
// Called from:
//      I
void U()
{
	w();
	S(0x00);
}

// 0000000000001E04: Register word64 I(Register word64 x19, Register out (ptr64 Eq_1457) x29Out)
// Called from:
//      I
//      ab
word64 I(word64 x19, struct Eq_1457 & x29Out)
{
	word16 wLoc28;
	int32 dwLoc2A_432 = SEQ(wLoc28, SLICE(x19, word16, 48));
	if (g_ptr12F50->u0 == 288)
	{
		ad();
		ad();
		U();
		ad();
		struct Eq_1495 * x29_354;
		word64 x19_356 = I(x19, out x29_354);
		if (g_ptr12F50->u0 == 0x0138)
		{
			ad();
			x29_354->t003C.u0 = (int32) B(0x00);
			A(x29_354->t0034.u0);
			struct Eq_1525 * x29_401;
			I(x19_356, out x29_401);
			A(x29_401->t003C.u0);
		}
		else
			A(x29_354->t0034.u0);
	}
	else if ((uint32) ((uint8) (g_ptr12F50->u0 == 0x0160) | (uint8) (g_ptr12F50->u0 == 0x01F8)) != 0x00)
	{
		Eq_106 w0_159 = g_ptr12F50->u0;
		ad();
		ad();
		if (w0_159 == 0x0160)
			U();
		else
		{
			if (g_ptr12F50->u0 != 0x3B)
				w();
			ad();
			word32 w0_194 = *g_ptr12FC8;
			if (g_ptr12F50->u0 != 0x3B)
				U();
			ad();
			if (g_ptr12F50->u0 != 0x29)
			{
				Eq_106 w0_233 = B(0x00);
				w();
				B(w0_194 - *g_ptr12FC8 - 0x05);
				A(w0_233);
			}
		}
		ad();
		struct Eq_1562 * x29_293;
		I(x19, out x29_293);
		B(x29_293->dw003C - *g_ptr12FC8 - 0x05);
		A(x29_293->t0034.u0);
	}
	else if (g_ptr12F50->u0 == 0x7B)
	{
		ad();
		word64 x30_495;
		word64 x29_494;
		word64 x19_126 = ab(out x29_494, out x30_495);
		while (g_ptr12F50->u0 != 0x7D)
		{
			word64 x29_496;
			x19_126 = I(x19_126, out x29_496);
		}
		ad();
	}
	else
	{
		if (g_ptr12F50->u0 == 448)
		{
			ad();
			if (g_ptr12F50->u0 != 0x3B)
				w();
			g_ptr12FB0->u0 = (int32) B(g_ptr12FB0->u0);
		}
		else if (g_ptr12F50->u0 == 400)
		{
			ad();
			null[(int64) dwLoc2A_432 /64 4].u0 = (int32) B(null[(int64) dwLoc2A_432 /64 4].u0);
		}
		else if (g_ptr12F50->u0 != 0x3B)
			w();
		ad();
	}
	x29Out = (struct Eq_1457 *) <invalid>;
	return x19;
}

// 00000000000020E4: Register word64 ab(Register out ptr64 x29Out, Register out ptr64 x30Out)
// Called from:
//      I
//      main
word64 ab(ptr64 & x29Out, ptr64 & x30Out)
{
	ptr64 fp;
	word64 x19;
	word32 sp_32_32_275 = SLICE(fp + -48, word32, 32);
	struct Eq_1710 * x29_161 = fp + -48;
	while (true)
	{
		Eq_106 w0_22 = g_ptr12F50->u0;
		struct Eq_1717 * sp_159 = SEQ(sp_32_32_275, (word32) w0_22 + 1);
		if (((uint32) (uint8) (g_ptr12F50->u0 == 0x0100) | (uint32) ((uint8) (w0_22 != ~0x00) & (uint8) (x29_161->dw001C == 0x00))) == 0x00)
			break;
		if (g_ptr12F50->u0 == 0x0100)
		{
			ad();
			while (g_ptr12F50->u0 != 0x3B)
			{
				if (x29_161->dw001C != 0x00)
				{
					g_ptr12FA0->u0 = (int32) (g_ptr12FA0->u0 + 0x04);
					null[(int64) g_ptr12F50->u0 /64 4] = 0x00 - g_ptr12FA0->u0;
				}
				else
				{
					null[(int64) g_ptr12F50->u0 /64 4].u0 = g_ptr12F60->u0;
					g_ptr12F60->u0 = (int32) (g_ptr12F60->u0 + 0x04);
				}
				ad();
				if (g_ptr12F50->u0 == 44)
					ad();
			}
			ad();
		}
		else
		{
			A(null[(int64) (g_ptr12F50->u0 + 0x04) /64 4].u0);
			null[(int64) g_ptr12F50->u0 /64 4] = *g_ptr12FC8;
			ad();
			ad();
			x29_161->t002C.u0 = 0x08;
			while (g_ptr12F50->u0 != 0x29)
			{
				null[(int64) g_ptr12F50->u0 /64 4].u0 = x29_161->t002C.u0;
				x29_161->t002C.u0 = (int32) (x29_161->t002C.u0 + 0x04);
				ad();
				if (g_ptr12F50->u0 == 44)
					ad();
			}
			ad();
			g_ptr12FA0->u0 = 0x00;
			g_ptr12FB0->u0 = g_ptr12FA0->u0;
			ae();
			x29_161->t002C.u0 = (int32) s(0x00);
			I(x19, out x29_161);
			A(g_ptr12FB0->u0);
			ae();
			null[(int64) x29_161->dw0016 /64 4].u0 = g_ptr12FA0->u0;
		}
	}
	ptr64 x30_271 = sp_159->ptr0008;
	x29Out = sp_159->ptr0000;
	x30Out = x30_271;
	return <invalid>;
}

// 0000000000002368: void main(Register int32 w0, Register word64 x30)
void main(int32 w0, word64 x30)
{
	*g_ptr12FC0 = *g_ptr12F78;
	int32 dwLoc14_179 = SLICE(x30, int32, 32);
	if (w0 > 0x01)
		*g_ptr12FC0 = (word32) fopen((int64) null[(int64) dwLoc14_179 /64 4], "r");
	*g_ptr12F40 = (word32) calloc(0x01, ~0xFFFE7960);
	struct Eq_1967 * x0_57 = (int64) *g_ptr12F40;
	word64 x3_64 = g_qw2648;
	x0_57->qw0000 = g_qw2640;
	x0_57->qw0008 = x3_64;
	word64 x3_70 = g_qw2658;
	x0_57->qw0010 = g_qw2650;
	x0_57->qw0018 = x3_70;
	word64 x3_76 = g_qw2668;
	x0_57->qw0020 = g_qw2660;
	x0_57->qw0028 = x3_76;
	x0_57->b0030 = g_b2670;
	*g_ptr12F30 = (word32) x0_57 + 0x30;
	g_ptr12F60->u0 = (int32) (word32) calloc(0x01, ~0xFFFE7960);
	*g_ptr12F80 = (word32) calloc(0x01, ~0xFFFE7960);
	*g_ptr12FC8 = *g_ptr12F80;
	*g_ptr12F38 = (word32) calloc(0x01, ~0xFFFE7960);
	o();
	ad();
	word64 x29_141;
	word64 x30_142;
	ab(out x29_141, out x30_142);
	<anonymous> * x0_153 = (int64) null[(int64) (*g_ptr12F38 + 0x0250) /64 4];
	word64 x2_165;
	x0_153();
}

// 0000000000002520: void __libc_csu_init(Register word32 w0, Register word64 x1, Register word64 x2, Register word64 x24, Register word64 x30)
void __libc_csu_init(word32 w0, word64 x1, word64 x2, word64 x24, word64 x30)
{
	ptr64 fp;
	word32 x24_32_32_89 = SLICE(x24, word32, 32);
	_init();
	int64 x20_23 = 77080 - g_a12D10;
	ptr64 x29_49 = fp + -64;
	<anonymous> * x21_21[] = g_a12D10;
	word64 x22_30 = x2;
	word64 x23_34 = x1;
	int64 x20_36 = x20_23 >> 3;
	if (x20_23 >> 3 != 0x00)
	{
		int64 x19_37 = 0x00;
		word64 x24_133 = SEQ(x24_32_32_89, w0);
		do
		{
			word64 x3_67;
			x21_21[x19_37]();
			int64 x31_70 = x20_36 - x19_37;
		} while (x31_70 != 0x00);
	}
}

// 0000000000002598: void __libc_csu_fini()
void __libc_csu_fini()
{
}

