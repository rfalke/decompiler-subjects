//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <ctype.h>
#include <errno.h>
#include <error.h>
#include <libintl.h>
#include <libio.h>
#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <wctype.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___mbstate_t {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1);
int32_t function_8048778(void);
int32_t function_80487a0(struct _IO_FILE * fp);
int32_t function_80487b0(struct _IO_FILE * a1, int32_t a2);
int32_t function_80487c0(char * s, struct _IO_FILE * stream);
int32_t function_80487d0(struct _IO_FILE * stream, char * format, ...);
char * function_80487e0(char * name);
char * function_80487f0(char * domainname, char * msgid, int32_t category);
char * function_8048800(int32_t category, char * locale);
int32_t function_8048810(void (*func)(int32_t *), int32_t * arg, int32_t * dso_handle);
int32_t * function_8048820(void);
int32_t * function_8048830(int32_t size);
void function_8048840(void);
int32_t function_8048850(struct _IO_FILE * s, char * format, int32_t arg);
char * function_8048860(char * domainname, char * dirname);
int32_t function_8048870(char * s);
int32_t function_8048880(int32_t * pwc, char * s, int32_t n, struct _TYPEDEF___mbstate_t * p);
int32_t function_8048890(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t * function_80488a0(int32_t * ptr, int32_t size);
char * function_80488b0(char * domainname);
int32_t function_80488c0(char * format, ...);
int32_t * function_80488d0(int32_t * dest, int32_t * src, int32_t n);
int32_t function_80488e0(struct _IO_FILE * stream);
int32_t function_80488f0(void);
void function_8048900(int32_t status);
int32_t * function_8048910(int32_t nmemb, int32_t size);
int32_t function_8048920(int32_t wc);
void function_8048930(int32_t * ptr);
int32_t * function_8048940(int32_t * s, int32_t c, int32_t n);
int32_t function_8048950(struct _TYPEDEF___mbstate_t * ps);
void function_8048960(int32_t status, int32_t errnum, char * format, ...);
int16_t ** function_8048970(void);
int32_t function_80489a4(void);
int32_t function_80489c8(void);
int32_t function_8048a04(void);
int32_t function_8048a30(int32_t status);
int32_t function_8048b10(int32_t a1, int32_t a2);
int32_t function_8048c10(int32_t result);
int32_t function_8048c20(void);
int32_t function_8048cf0(int32_t a1);
int32_t function_8048d70(int32_t a1);
int32_t function_8048d90(int32_t a1, int32_t result);
int32_t function_8048db0(int32_t * a1, uint32_t a2, uint32_t a3);
int32_t function_8048e10(int32_t * a1, int32_t a2);
int32_t function_8048e50(int32_t a1, uint32_t a2, int32_t str2, int32_t a4, int32_t a5, int32_t a6);
int32_t function_8049490(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_80494f0(uint32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_8049660(int32_t a1, int32_t a2);
int32_t function_8049690(int32_t result);
int32_t function_80496b0(int32_t * a1, int32_t a2);
int32_t function_8049720(int32_t a1, int32_t a2, int32_t a3);
int32_t function_8049770(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_80497c0(int32_t a1, int32_t a2);
int32_t function_80497f0(int32_t a1, int32_t a2);
int32_t function_8049890(int32_t a1);
int32_t function_80498b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
int32_t function_8049ac0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_8049b00(void);
int32_t function_8049b60(uint32_t a1, uint32_t a2);
int32_t function_8049ba0(int32_t size);
int32_t function_8049bd0(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_8049c20(int32_t a1, int32_t a2);
int32_t function_8049c50(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_8049cc0(int32_t a1, int32_t a2);
int32_t function_8049d31(int32_t a1);
int32_t function_8049d80(uint32_t nmemb, uint32_t size);
int32_t function_8049dc0(int32_t a1, int32_t a2);
int32_t function_8049df0(int32_t a1);
int32_t function_8049e04(void);
int32_t function_8049e4c(void);
int32_t function_8049e90(int32_t a1);
int32_t function_8049ec0(void);
int32_t function_8049ee4(void);

// --------------------- Global Variables ---------------------

char * g1; // 0x804a01c
char * g2 = "\""; // 0x804a0cb
struct _TYPEDEF___mbstate_t * g3 = (struct _TYPEDEF___mbstate_t *)0x600027; // 0x804a0cd
int32_t g4 = 96; // 0x804a0cf
int32_t g5 = -1; // 0x804b648
int32_t g6 = 0; // 0x804b654
char * g8 = "\x01"; // 0x804b7bc
int32_t g9 = 1; // 0x804b7c0
int32_t g10 = 256; // 0x804b7c4
int32_t g12; // 0x804b7cc
char (*g13)[50] = "Copyright (C) 2004 Free Software Foundation, Inc."; // 0x804b7d0
struct _IO_FILE * g14 = NULL; // 0x804b7e0
char g15 = 0; // 0x804b7e4
int32_t g16 = 0; // 0x804b7e8
int32_t g17 = 0; // 0x804b800
int32_t g18 = 0; // 0x804b900
int32_t g19 = 0; // 0x804b904
int32_t g20 = 0; // 0x804b928
int32_t g21;
int32_t g22;
int32_t g23;
int32_t g24;
int32_t g25;
int32_t * g7 = &g6; // 0x804b7b8
int32_t * g11 = &g17; // 0x804b7c8

// ------------------------ Functions -------------------------

// Address range: 0x8048778 - 0x804878f
int32_t function_8048778(void) {
    // 0x8048778
    function_80489a4();
    function_8048a04();
    return function_8049ec0();
}

// Address range: 0x80487a0 - 0x80487a6
int32_t function_80487a0(struct _IO_FILE * fp) {
    // 0x80487a0
    return __fpending(fp);
}

// Address range: 0x80487b0 - 0x80487b6
int32_t function_80487b0(struct _IO_FILE * a1, int32_t a2) {
    // 0x80487b0
    return __overflow(a1, a2);
}

// Address range: 0x80487c0 - 0x80487c6
int32_t function_80487c0(char * s, struct _IO_FILE * stream) {
    // 0x80487c0
    return fputs_unlocked(s, stream);
}

// Address range: 0x80487d0 - 0x80487d6
int32_t function_80487d0(struct _IO_FILE * stream, char * format, ...) {
    // 0x80487d0
    return fprintf(stream, format);
}

// Address range: 0x80487e0 - 0x80487e6
char * function_80487e0(char * name) {
    // 0x80487e0
    return getenv(name);
}

// Address range: 0x80487f0 - 0x80487f6
char * function_80487f0(char * domainname, char * msgid, int32_t category) {
    // 0x80487f0
    return dcgettext(domainname, msgid, category);
}

// Address range: 0x8048800 - 0x8048806
char * function_8048800(int32_t category, char * locale) {
    // 0x8048800
    return setlocale(category, locale);
}

// Address range: 0x8048810 - 0x8048816
int32_t function_8048810(void (*func)(int32_t *), int32_t * arg, int32_t * dso_handle) {
    // 0x8048810
    return __cxa_atexit(func, arg, dso_handle);
}

// Address range: 0x8048820 - 0x8048826
int32_t * function_8048820(void) {
    // 0x8048820
    return __errno_location();
}

// Address range: 0x8048830 - 0x8048836
int32_t * function_8048830(int32_t size) {
    // 0x8048830
    return malloc(size);
}

// Address range: 0x8048840 - 0x8048846
void function_8048840(void) {
    // 0x8048840
    abort();
}

// Address range: 0x8048850 - 0x8048856
int32_t function_8048850(struct _IO_FILE * s, char * format, int32_t arg) {
    // 0x8048850
    return vfprintf(s, format, arg);
}

// Address range: 0x8048860 - 0x8048866
char * function_8048860(char * domainname, char * dirname) {
    // 0x8048860
    return bindtextdomain(domainname, dirname);
}

// Address range: 0x8048870 - 0x8048876
int32_t function_8048870(char * s) {
    // 0x8048870
    return strlen(s);
}

// Address range: 0x8048880 - 0x8048886
int32_t function_8048880(int32_t * pwc, char * s, int32_t n, struct _TYPEDEF___mbstate_t * p) {
    // 0x8048880
    return mbrtowc(pwc, s, n, p);
}

// Address range: 0x8048890 - 0x8048896
int32_t function_8048890(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x8048890
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x80488a0 - 0x80488a6
int32_t * function_80488a0(int32_t * ptr, int32_t size) {
    // 0x80488a0
    return realloc(ptr, size);
}

// Address range: 0x80488b0 - 0x80488b6
char * function_80488b0(char * domainname) {
    // 0x80488b0
    return textdomain(domainname);
}

// Address range: 0x80488c0 - 0x80488c6
int32_t function_80488c0(char * format, ...) {
    // 0x80488c0
    return printf(format);
}

// Address range: 0x80488d0 - 0x80488d6
int32_t * function_80488d0(int32_t * dest, int32_t * src, int32_t n) {
    // 0x80488d0
    return memcpy(dest, src, n);
}

// Address range: 0x80488e0 - 0x80488e6
int32_t function_80488e0(struct _IO_FILE * stream) {
    // 0x80488e0
    return fclose(stream);
}

// Address range: 0x80488f0 - 0x80488f6
int32_t function_80488f0(void) {
    // 0x80488f0
    return __ctype_get_mb_cur_max();
}

// Address range: 0x8048900 - 0x8048906
void function_8048900(int32_t status) {
    // 0x8048900
    exit(status);
}

// Address range: 0x8048910 - 0x8048916
int32_t * function_8048910(int32_t nmemb, int32_t size) {
    // 0x8048910
    return calloc(nmemb, size);
}

// Address range: 0x8048920 - 0x8048926
int32_t function_8048920(int32_t wc) {
    // 0x8048920
    return iswprint(wc);
}

// Address range: 0x8048930 - 0x8048936
void function_8048930(int32_t * ptr) {
    // 0x8048930
    free(ptr);
}

// Address range: 0x8048940 - 0x8048946
int32_t * function_8048940(int32_t * s, int32_t c, int32_t n) {
    // 0x8048940
    return memset(s, c, n);
}

// Address range: 0x8048950 - 0x8048956
int32_t function_8048950(struct _TYPEDEF___mbstate_t * ps) {
    // 0x8048950
    return mbsinit(ps);
}

// Address range: 0x8048960 - 0x8048966
void function_8048960(int32_t status, int32_t errnum, char * format, ...) {
    // 0x8048960
    error(status, errnum, format);
}

// Address range: 0x8048970 - 0x8048976
int16_t ** function_8048970(void) {
    // 0x8048970
    return __ctype_b_loc();
}

// Address range: 0x8048980 - 0x80489a2
int32_t entry_point(int32_t a1) {
    // 0x8048980
    int32_t v1; // 0x8048980
    int32_t v2; // 0x8048980
    __libc_start_main(0x8048b10, a1, (char **)&v1, (void (*)())0x8049e04, (void (*)())0x8049e4c, (void (*)())v2);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x80489a4 - 0x80489c6
int32_t function_80489a4(void) {
    // 0x80489a4
    int32_t v1; // 0x80489a4
    return *(int32_t *)(v1 + 0x2d7b);
}

// Address range: 0x80489c8 - 0x8048a02
int32_t function_80489c8(void) {
    // 0x80489c8
    if (g15 != 0) {
        // 0x8048a00
        int32_t result; // 0x80489c8
        return result;
    }
    int32_t result2 = (int32_t)g7; // 0x80489d7
    int32_t result3 = result2; // 0x80489e0
    if (g7 == NULL) {
        // 0x80489f9
        g15 = 1;
        // 0x8048a00
        return result2;
    }
    result3 += 4;
    while (result3 != 0) {
        // 0x80489e4
        result3 += 4;
    }
    // 0x80489f9
    *(int32_t *)&g7 = result3;
    // 0x80489f9
    g15 = 1;
    // 0x8048a00
    return result3;
}

// Address range: 0x8048a04 - 0x8048a2e
int32_t function_8048a04(void) {
    // 0x8048a04
    return 0;
}

// Address range: 0x8048a30 - 0x8048b04
int32_t function_8048a30(int32_t status) {
    // 0x8048a30
    printf(dcgettext(NULL, "Usage: %s [ignored command line arguments]\n  or:  %s OPTION\nExit with a status code indicating success.\n\nThese option names may not be abbreviated.\n\n", 5));
    fputs_unlocked(dcgettext(NULL, "      --help     display this help and exit\n", 5), g14);
    fputs_unlocked(dcgettext(NULL, "      --version  output version information and exit\n", 5), g14);
    printf(dcgettext(NULL, "\nReport bugs to <%s>.\n", 5));
    exit(status);
    // UNREACHABLE
}

// Address range: 0x8048b10 - 0x8048c0e
int32_t function_8048b10(int32_t a1, int32_t a2) {
    // 0x8048b10
    g20 = *(int32_t *)a2;
    setlocale(LC_ALL, (char *)&g1);
    bindtextdomain("coreutils", "/usr/share/locale");
    textdomain("coreutils");
    function_8049e90(0x8048c20);
    if (a1 != 2 || getenv("POSIXLY_CORRECT") != NULL) {
        // 0x8048b74
        exit(0);
        // UNREACHABLE
    }
    int32_t v1 = *(int32_t *)(a2 + 4); // 0x8048b91
    int32_t v2 = 7; // 0x8048ba6
    int32_t v3 = v1; // 0x8048ba6
    int32_t v4 = (int32_t)"--help"; // 0x8048ba6
    int32_t v5; // 0x8048b10
    int32_t v6; // 0x8048b10
    int32_t v7; // 0x8048b10
    while (v2 != 0) {
        int32_t v8 = v3;
        char v9 = *(char *)v4; // 0x8048ba6
        v2--;
        v3 = v8 + 1;
        v4++;
        v6 = (int32_t)"--version";
        v7 = v1;
        v5 = 10;
        if (*(char *)v8 != v9) {
            goto lab_0x8048baa;
        }
    }
    // 0x8048bfa
    function_8048a30(0);
    // UNREACHABLE
  lab_0x8048baa:
    // 0x8048baa
    if (*(char *)v7 == *(char *)v6) {
        int32_t v10 = v5 - 1; // 0x8048bba
        v6++;
        v7++;
        v5 = v10;
        if (v10 == 0) {
            // 0x8048bbe
            function_8049ac0((int32_t)g14, (int32_t)"true", (int32_t)"GNU coreutils", (int32_t)"5.2.1", (int32_t)"Jim Meyering", 0);
        } else {
            goto lab_0x8048baa;
        }
    } else {
        goto lab_0x8048b74;
    }
}

// Address range: 0x8048c10 - 0x8048c1d
int32_t function_8048c10(int32_t result) {
    // 0x8048c10
    g16 = result;
    return result;
}

// Address range: 0x8048c20 - 0x8048cf0
int32_t function_8048c20(void) {
    char v1 = *(char *)g14; // 0x8048c34
    struct _IO_FILE * file = g14; // 0x8048c3d
    if ((v1 & 32) == 0) {
        // 0x8048c3f
        if (__fpending(g14) == 0) {
            // 0x8048cc0
            return 0;
        }
        // 0x8048c4b
        file = g14;
    }
    int32_t result = 0; // 0x8048c5b
    int32_t err_num = (v1 & 32) == 0; // 0x8048c5b
    if (fclose(file) != 0) {
        int32_t * v2 = __errno_location(); // 0x8048c5d
        err_num = *v2;
        result = (int32_t)v2;
    }
    // 0x8048c64
    if (err_num < 0) {
        // 0x8048cc0
        return result;
    }
    char * v3 = dcgettext(NULL, "write error", 5); // 0x8048c81
    if (g16 == 0) {
        // 0x8048cd0
        error((int32_t)g8, err_num, "%s", v3);
    } else {
        int32_t v4 = function_8049890(g16); // 0x8048c94
        error((int32_t)g8, err_num, "%s: %s", (char *)v4, v3);
    }
    // 0x8048cc0
    return &g25;
}

// Address range: 0x8048cf0 - 0x8048d67
int32_t function_8048cf0(int32_t a1) {
    int32_t * v1 = __errno_location(); // 0x8048cfc
    int32_t result = function_8049ba0(36); // 0x8048d0c
    int32_t v2 = a1 == 0 ? (int32_t)&g18 : a1;
    *(int32_t *)result = *(int32_t *)v2;
    *(int32_t *)(result + 4) = *(int32_t *)(v2 + 4);
    *(int32_t *)(result + 8) = *(int32_t *)(v2 + 8);
    *(int32_t *)(result + 12) = *(int32_t *)(v2 + 12);
    *(int32_t *)(result + 16) = *(int32_t *)(v2 + 16);
    *(int32_t *)(result + 20) = *(int32_t *)(v2 + 20);
    *(int32_t *)(result + 24) = *(int32_t *)(v2 + 24);
    *(int32_t *)(result + 28) = *(int32_t *)(v2 + 28);
    *(int32_t *)(result + 32) = *(int32_t *)(v2 + 32);
    return result;
}

// Address range: 0x8048d70 - 0x8048d87
int32_t function_8048d70(int32_t a1) {
    // 0x8048d70
    return *(int32_t *)(a1 == 0 ? (int32_t)&g18 : a1);
}

// Address range: 0x8048d90 - 0x8048da8
int32_t function_8048d90(int32_t a1, int32_t result) {
    // 0x8048d90
    *(int32_t *)(a1 == 0 ? (int32_t)&g18 : a1) = result;
    return result;
}

// Address range: 0x8048db0 - 0x8048e08
int32_t function_8048db0(int32_t * a1, uint32_t a2, uint32_t a3) {
    int32_t v1 = a1 == NULL ? (int32_t)&g19 : (int32_t)a1 + 4;
    int32_t * v2 = (int32_t *)((a2 / 8 & 28) + v1); // 0x8048dda
    uint32_t v3 = *v2; // 0x8048dda
    uint32_t v4 = a2 % 32; // 0x8048ddc
    uint32_t result = (v3 >> v4) % 2; // 0x8048de6
    *v2 = (result ^ a3 % 2) << v4 ^ v3;
    return result;
}

// Address range: 0x8048e10 - 0x8048e4d
int32_t function_8048e10(int32_t * a1, int32_t a2) {
    char * v1 = dcgettext(NULL, (char *)a1, 5); // 0x8048e30
    int32_t result = a2 != 6 | v1 != (char *)a1 ? (int32_t)v1 : (int32_t)&g2;
    return result;
}

// Address range: 0x8048e50 - 0x804948a
int32_t function_8048e50(int32_t a1, uint32_t a2, int32_t str2, int32_t a4, int32_t a5, int32_t a6) {
    int32_t v1 = __ctype_get_mb_cur_max(); // 0x8048e75
    g22 = a5;
    bool v2 = true; // 0x8048e8d
    int32_t len = 0; // 0x8048e8d
    char * v3 = NULL; // 0x8048e8d
    int32_t v4 = 0; // 0x8048e8d
    switch (a5) {
        case 2: {
            // 0x80493ef
            v2 = true;
            len = 1;
            v3 = (char *)&g3;
            v4 = 1;
            if (a2 != 0) {
                // 0x80493f7
                *(char *)a1 = 39;
                v2 = true;
                len = 1;
                v3 = (char *)&g3;
                v4 = 1;
            }
            // break -> 0x8048ebe
            break;
        }
        case 3: {
            // 0x8048e94
            v2 = false;
            len = 1;
            v3 = (char *)&g2;
            v4 = 1;
            if (a2 != 0) {
                // 0x8048e9c
                *(char *)a1 = 34;
                v2 = false;
                len = 1;
                v3 = (char *)&g2;
                v4 = 1;
            }
            // break -> 0x8048ebe
            break;
        }
        case 4: {
            // 0x8049410
            v2 = false;
            len = 0;
            v3 = NULL;
            v4 = 0;
            // break -> 0x8048ebe
            break;
        }
        case 5: {
        }
        case 6: {
            int32_t v5 = function_8048e10(&g4, a5); // 0x804942a
            int32_t v6 = function_8048e10((int32_t *)&g3, a5); // 0x804943c
            char * v7 = (char *)v5; // 0x8049441
            char v8 = *v7; // 0x8049446
            int32_t v9 = 0; // 0x8049449
            if (v8 != 0) {
                uint32_t v10 = 0;
                if (v10 < a2) {
                    // 0x8049453
                    *(char *)(v10 + a1) = v8;
                }
                char * v11 = (char *)((int32_t)v7 + 1); // 0x8049462
                int32_t v12 = v10 + 1; // 0x8049465
                char v13 = *v11; // 0x804946b
                char * v14 = v11; // 0x804946e
                v9 = v12;
                while (v13 != 0) {
                    // 0x804944b
                    v10 = v12;
                    if (v10 < a2) {
                        // 0x8049453
                        *(char *)(v10 + a1) = v13;
                    }
                    // 0x8049462
                    v11 = (char *)((int32_t)v14 + 1);
                    v12 = v10 + 1;
                    v13 = *v11;
                    v14 = v11;
                    v9 = v12;
                }
            }
            char * str = (char *)v6; // 0x8049477
            v2 = false;
            len = strlen(str);
            v3 = str;
            v4 = v9;
            // break -> 0x8048ebe
            break;
        }
    }
    bool v15 = v2 | len == 0;
    int32_t v16 = a4; // 0x8048ec9
    int32_t v17 = v4; // 0x8048ec9
    int32_t v18 = 0; // 0x8048ec9
    int32_t v19; // 0x8048e50
    char v20; // 0x8048e50
    char v21; // 0x8048e50
    int32_t v22; // 0x8048e50
    int32_t v23; // 0x8048e50
    int32_t v24; // 0x8048e50
    int32_t v25; // 0x8048e50
    int32_t v26; // 0x8048e50
    int32_t v27; // 0x8048e50
    int32_t v28; // 0x8048e50
    int32_t v29; // 0x8048e50
    int32_t v30; // 0x8048e50
    int32_t v31; // 0x8048e50
    int32_t v32; // 0x8048e50
    int32_t v33; // 0x8048e50
    int32_t v34; // 0x8048e50
    int32_t v35; // 0x8048e50
    int32_t v36; // 0x8048e50
    char v37; // 0x8048e50
    char v38; // 0x8048e50
    char v39; // 0x8048e50
    char v40; // 0x8048e50
    int32_t v41; // 0x8048e50
    int32_t v42; // 0x8048e50
    int32_t v43; // 0x8048e50
    int32_t result; // 0x8048e50
    char v44; // 0x8048f36
    int32_t v45; // 0x8049101
    char v46; // 0x804911e
    while (true) {
      lab_0x8048ed0:
        // 0x8048ed0
        v43 = v18;
        v31 = v17;
        v22 = v16;
        int32_t v47; // 0x8048e50
        if (v22 == -1) {
            int32_t v48 = v43 + str2;
            v47 = v48;
            if (*(char *)v48 == 0) {
                // break -> 0x8049391
                break;
            }
        } else {
            if (v43 == v22) {
                // break -> 0x8049391
                break;
            }
            // 0x8048ee0
            v47 = v43 + str2;
        }
        int32_t v49 = v47; // 0x8048eeb
        int32_t v50 = (int32_t)v3; // 0x8048eeb
        int32_t v51 = v31; // 0x8048eeb
        if (!v15 && v43 + len <= v22) {
            int32_t v52 = len; // 0x8048e50
            while (v52 != 0) {
                int32_t v53 = v49;
                char v54 = *(char *)v50; // 0x8048f14
                v52--;
                v49 = v53 + 1;
                v50++;
                v51 = v31;
                if (*(char *)v53 != v54) {
                    goto lab_0x8048f30;
                }
            }
            if (v31 < a2) {
                // 0x8048f20
                *(char *)(v31 + a1) = 92;
            }
            // 0x8048f2a
            v51 = v31 + 1;
        }
      lab_0x8048f30:
        // 0x8048f30
        v32 = v51;
        v44 = *(char *)v47;
        int32_t v55 = v44; // 0x8048f36
        g23 = v55;
        v29 = v43;
        v38 = v44;
        v34 = v32;
        v20 = 97;
        v21 = 116;
        switch (v44) {
            case 0: {
                int32_t v56 = v43 + 1;
                v16 = v22;
                v39 = 0;
                v35 = v32;
                v18 = v56;
                if (v2) {
                    goto lab_0x8049000;
                } else {
                    if (v32 < a2) {
                        // 0x8048f69
                        *(char *)(v32 + a1) = 92;
                    }
                    uint32_t v57 = v32 + 1; // 0x8048f73
                    if (v57 < a2) {
                        // 0x8048f7e
                        *(char *)(v57 + a1) = 48;
                    }
                    uint32_t v58 = v32 + 2; // 0x8048f88
                    if (v58 < a2) {
                        // 0x8048f93
                        *(char *)(v58 + a1) = 48;
                    }
                    // 0x8048f9d
                    v19 = v56;
                    v33 = v32 + 3;
                    v37 = 48;
                    v23 = v22;
                    v28 = v43;
                    goto lab_0x8048fbd;
                }
            }
            case 7: {
                goto lab_0x8049030;
            }
            case 8: {
                // 0x8049042
                v20 = 98;
                goto lab_0x8049030;
            }
            case 9: {
                goto lab_0x8049048;
            }
            case 10: {
                // 0x8049086
                v21 = 110;
                goto lab_0x8049048;
            }
            case 11: {
                // 0x804908a
                v20 = 118;
                goto lab_0x8049030;
            }
            case 12: {
                // 0x804908e
                v20 = 102;
                goto lab_0x8049030;
            }
            case 13: {
                // 0x8049092
                v21 = 114;
                goto lab_0x8049048;
            }
            case 32: {
                goto lab_0x8049375;
            }
            case 33: {
                goto lab_0x8049375;
            }
            case 34: {
                goto lab_0x8049375;
            }
            case 35: {
                goto lab_0x8049384;
            }
            case 36: {
                goto lab_0x8049375;
            }
            case 37: {
                goto lab_0x8048fb0;
            }
            case 38: {
                goto lab_0x8049375;
            }
            case 39: {
                if (a5 == 1) {
                    // 0x804904e
                    result = function_8048e50(a1, a2, str2, v22, 2, a6);
                    return result;
                }
                // 0x804909c
                v29 = v43;
                v38 = 39;
                v34 = v32;
                if (a5 != 2) {
                    goto lab_0x8048fb0;
                } else {
                    if (v32 < a2) {
                        // 0x80490ae
                        *(char *)(v32 + a1) = 39;
                    }
                    uint32_t v59 = v32 + 1; // 0x80490b8
                    if (v59 < a2) {
                        // 0x80490c3
                        *(char *)(v59 + a1) = 92;
                    }
                    int32_t v60 = v32 + 2; // 0x80490cd
                    v30 = v43;
                    v40 = 39;
                    v36 = v60;
                    if (v60 < a2) {
                        // 0x80490d8
                        *(char *)(v60 + a1) = 39;
                        v30 = v43;
                        v40 = 39;
                        v36 = v60;
                    }
                    goto lab_0x80490e2;
                }
            }
            case 40: {
                goto lab_0x8049375;
            }
            case 41: {
                goto lab_0x8049375;
            }
            case 42: {
                goto lab_0x8049375;
            }
            case 43: {
                goto lab_0x8048fb0;
            }
            case 44: {
                goto lab_0x8048fb0;
            }
            case 45: {
                goto lab_0x8048fb0;
            }
            case 46: {
                goto lab_0x8048fb0;
            }
            case 47: {
                goto lab_0x8048fb0;
            }
            case 48: {
                goto lab_0x8048fb0;
            }
            case 49: {
                goto lab_0x8048fb0;
            }
            case 50: {
                goto lab_0x8048fb0;
            }
            case 51: {
                goto lab_0x8048fb0;
            }
            case 52: {
                goto lab_0x8048fb0;
            }
            case 53: {
                goto lab_0x8048fb0;
            }
            case 54: {
                goto lab_0x8048fb0;
            }
            case 55: {
                goto lab_0x8048fb0;
            }
            case 56: {
                goto lab_0x8048fb0;
            }
            case 57: {
                goto lab_0x8048fb0;
            }
            case 58: {
                goto lab_0x8048fb0;
            }
            case 59: {
                goto lab_0x8049375;
            }
            case 60: {
                goto lab_0x8049375;
            }
            case 61: {
                goto lab_0x8048fb0;
            }
            case 62: {
                goto lab_0x8049375;
            }
            case 63: {
                if (a5 == 1) {
                    // 0x804904e
                    result = function_8048e50(a1, a2, str2, v22, 2, a6);
                    return result;
                }
                // 0x80490f4
                v29 = v43;
                v38 = 63;
                v34 = v32;
                if (a5 != 3) {
                    goto lab_0x8048fb0;
                } else {
                    // 0x80490fe
                    v45 = v43 + 2;
                    v29 = v43;
                    v38 = 63;
                    v34 = v32;
                    if (v45 >= v22) {
                        goto lab_0x8048fb0;
                    } else {
                        // 0x804910d
                        if (*(char *)(v43 + 1 + str2) != 63) {
                            goto lab_0x8048fb0;
                        } else {
                            // 0x804911e
                            v46 = *(char *)(v45 + str2);
                            int32_t v61 = v46; // 0x8049123
                            g24 = v61 - 33;
                            v29 = v43;
                            v38 = 63;
                            v34 = v32;
                            switch (v61) {
                                case 33: {
                                    goto lab_0x8049139;
                                }
                                case 39: {
                                    goto lab_0x8049139;
                                }
                                case 40: {
                                    goto lab_0x8049139;
                                }
                                case 41: {
                                    goto lab_0x8049139;
                                }
                                case 45: {
                                    goto lab_0x8049139;
                                }
                                case 47: {
                                    goto lab_0x8049139;
                                }
                                case 60: {
                                    goto lab_0x8049139;
                                }
                                case 61: {
                                    goto lab_0x8049139;
                                }
                                case 62: {
                                    goto lab_0x8049139;
                                }
                                default: {
                                    goto lab_0x8048fb0;
                                }
                            }
                        }
                    }
                }
            }
            case 65: {
                goto lab_0x8048fb0;
            }
            case 66: {
                goto lab_0x8048fb0;
            }
            case 67: {
                goto lab_0x8048fb0;
            }
            case 68: {
                goto lab_0x8048fb0;
            }
            case 69: {
                goto lab_0x8048fb0;
            }
            case 70: {
                goto lab_0x8048fb0;
            }
            case 71: {
                goto lab_0x8048fb0;
            }
            case 72: {
                goto lab_0x8048fb0;
            }
            case 73: {
                goto lab_0x8048fb0;
            }
            case 74: {
                goto lab_0x8048fb0;
            }
            case 75: {
                goto lab_0x8048fb0;
            }
            case 76: {
                goto lab_0x8048fb0;
            }
            case 77: {
                goto lab_0x8048fb0;
            }
            case 78: {
                goto lab_0x8048fb0;
            }
            case 79: {
                goto lab_0x8048fb0;
            }
            case 80: {
                goto lab_0x8048fb0;
            }
            case 81: {
                goto lab_0x8048fb0;
            }
            case 82: {
                goto lab_0x8048fb0;
            }
            case 83: {
                goto lab_0x8048fb0;
            }
            case 84: {
                goto lab_0x8048fb0;
            }
            case 85: {
                goto lab_0x8048fb0;
            }
            case 86: {
                goto lab_0x8048fb0;
            }
            case 87: {
                goto lab_0x8048fb0;
            }
            case 88: {
                goto lab_0x8048fb0;
            }
            case 89: {
                goto lab_0x8048fb0;
            }
            case 90: {
                goto lab_0x8048fb0;
            }
            case 91: {
                goto lab_0x8049375;
            }
            case 92: {
                // 0x804936c
                v21 = 92;
                goto lab_0x8049048;
            }
            case 93: {
                goto lab_0x8048fb0;
            }
            case 94: {
                goto lab_0x8049375;
            }
            case 95: {
                goto lab_0x8048fb0;
            }
            case 96: {
                goto lab_0x8049375;
            }
            case 97: {
                goto lab_0x8048fb0;
            }
            case 98: {
                goto lab_0x8048fb0;
            }
            case 99: {
                goto lab_0x8048fb0;
            }
            case 100: {
                goto lab_0x8048fb0;
            }
            case 101: {
                goto lab_0x8048fb0;
            }
            case 102: {
                goto lab_0x8048fb0;
            }
            case 103: {
                goto lab_0x8048fb0;
            }
            case 104: {
                goto lab_0x8048fb0;
            }
            case 105: {
                goto lab_0x8048fb0;
            }
            case 106: {
                goto lab_0x8048fb0;
            }
            case 107: {
                goto lab_0x8048fb0;
            }
            case 108: {
                goto lab_0x8048fb0;
            }
            case 109: {
                goto lab_0x8048fb0;
            }
            case 110: {
                goto lab_0x8048fb0;
            }
            case 111: {
                goto lab_0x8048fb0;
            }
            case 112: {
                goto lab_0x8048fb0;
            }
            case 113: {
                goto lab_0x8048fb0;
            }
            case 114: {
                goto lab_0x8048fb0;
            }
            case 115: {
                goto lab_0x8048fb0;
            }
            case 116: {
                goto lab_0x8048fb0;
            }
            case 117: {
                goto lab_0x8048fb0;
            }
            case 118: {
                goto lab_0x8048fb0;
            }
            case 119: {
                goto lab_0x8048fb0;
            }
            case 120: {
                goto lab_0x8048fb0;
            }
            case 121: {
                goto lab_0x8048fb0;
            }
            case 122: {
                goto lab_0x8048fb0;
            }
            case 123: {
                goto lab_0x8048fb0;
            }
            case 124: {
                goto lab_0x8049375;
            }
            case 125: {
                goto lab_0x8048fb0;
            }
            case 126: {
                goto lab_0x8049384;
            }
            default: {
                if (v1 != 1) {
                    int32_t ps = 0; // bp-36, 0x804928a
                    int32_t len2 = v22; // 0x80492a6
                    if (v22 == -1) {
                        // 0x8049359
                        len2 = strlen((char *)str2);
                    }
                    // 0x80492b0
                    v25 = len2;
                    int32_t v62 = 0; // 0x8048e50
                    int32_t v63 = 1; // 0x8048e50
                    while (true) {
                      lab_0x80492b0:;
                        int32_t v64 = v63;
                        int32_t v65 = v62;
                        uint32_t v66 = v65 + v43; // 0x80492c3
                        char * wstr = (char *)(v66 + str2);
                        int32_t pwc; // bp-40, 0x8048e50
                        int32_t v67 = mbrtowc(&pwc, wstr, v25 - v66, (struct _TYPEDEF___mbstate_t *)&ps); // 0x80492d7
                        v42 = v65;
                        v27 = v64;
                        switch (v67) {
                            case 0: {
                                goto lab_0x8049315;
                            }
                            case -1: {
                                // 0x8049350
                                v42 = v65;
                                v27 = 0;
                                goto lab_0x8049315;
                            }
                            case -2: {
                                // 0x8049324
                                v42 = v65;
                                v27 = 0;
                                if (v25 > v66) {
                                    // 0x8049330
                                    v42 = v65;
                                    v27 = 0;
                                    int32_t v68 = v65; // 0x8049333
                                    if (*wstr != 0) {
                                        int32_t v69 = v68 + 1; // 0x8049335
                                        uint32_t v70 = v69 + v43; // 0x804933e
                                        v42 = v69;
                                        v27 = 0;
                                        while (v70 < v25) {
                                            // 0x8049345
                                            v42 = v69;
                                            v27 = 0;
                                            v68 = v69;
                                            if (*(char *)(v70 + str2) == 0) {
                                                // break -> 0x8049315
                                                break;
                                            }
                                            v69 = v68 + 1;
                                            v70 = v69 + v43;
                                            v42 = v69;
                                            v27 = 0;
                                        }
                                    }
                                }
                                goto lab_0x8049315;
                            }
                            default: {
                                int32_t v71 = iswprint(pwc) == 0 ? 0 : v64; // 0x8049309
                                int32_t v72 = mbsinit((struct _TYPEDEF___mbstate_t *)&ps); // 0x804930c
                                v62 = v67 + v65;
                                v63 = v71;
                                if (v72 != 0) {
                                    // break -> 0x8049315
                                    break;
                                }
                                goto lab_0x80492b0;
                            }
                        }
                    }
                    goto lab_0x8049315;
                } else {
                    int16_t v73 = *(int16_t *)(2 * v55 + (int32_t)*__ctype_b_loc()); // 0x80491a1
                    v24 = v22;
                    v41 = 1;
                    v26 = v73 & 0x4000;
                    goto lab_0x80491ae;
                }
            }
        }
    }
    int32_t v74 = v31; // 0x8049396
    if (v3 != NULL) {
        char v75 = *v3; // 0x804939b
        v74 = v31;
        if (v75 != 0) {
            if (v31 < a2) {
                // 0x80493aa
                *(char *)(v31 + a1) = v75;
            }
            char * v76 = (char *)((int32_t)v3 + 1); // 0x80493b3
            int32_t v77 = v31 + 1; // 0x80493b6
            char v78 = *v76; // 0x80493bc
            char * v79 = v76; // 0x80493c1
            v74 = v77;
            while (v78 != 0) {
                uint32_t v80 = v77;
                if (v80 < a2) {
                    // 0x80493aa
                    *(char *)(v80 + a1) = v78;
                }
                // 0x80493b3
                v76 = (char *)((int32_t)v79 + 1);
                v77 = v80 + 1;
                v78 = *v76;
                v79 = v76;
                v74 = v77;
            }
        }
    }
    // 0x80493c3
    result = v74;
    if (v74 < a2) {
        // 0x80493cb
        *(char *)(v74 + a1) = 0;
        result = v74;
    }
  lab_0x804907e:
    // 0x804907e
    return result;
  lab_0x8049315:
    // 0x8049315
    v24 = v25;
    v41 = v42;
    v26 = v27;
    int32_t v81 = v25; // 0x8049319
    int32_t v82 = v42; // 0x8049319
    int32_t v83 = v27; // 0x8049319
    if (v42 < 2) {
        goto lab_0x80491ae;
    } else {
        goto lab_0x80491ca;
    }
  lab_0x8049030:;
    int32_t v84 = v43; // 0x804903b
    int32_t v85 = v22; // 0x804903b
    char v86 = v20; // 0x804903b
    int32_t v87 = v32; // 0x804903b
    v16 = v22;
    v39 = v44;
    v35 = v32;
    v18 = v43 + 1;
    if (v2) {
        goto lab_0x8049000;
    } else {
        goto lab_0x8048fdb;
    }
  lab_0x8049048:
    // 0x8049048
    v20 = v21;
    if (a5 == 1) {
        // 0x804904e
        result = function_8048e50(a1, a2, str2, v22, 2, a6);
        return result;
    }
    goto lab_0x8049030;
  lab_0x8049375:
    // 0x8049375
    v29 = v43;
    v38 = v44;
    v34 = v32;
    if (a5 == 1) {
        // 0x804904e
        result = function_8048e50(a1, a2, str2, v22, 2, a6);
        goto lab_0x804907e;
    }
    goto lab_0x8048fb0;
  lab_0x8049384:
    // 0x8049384
    v29 = v43;
    v38 = v44;
    v34 = v32;
    if (a5 == 1 == v43 == 0) {
        // 0x804904e
        result = function_8048e50(a1, a2, str2, v22, 2, a6);
        goto lab_0x804907e;
    }
    goto lab_0x8048fb0;
  lab_0x8048fb0:;
    int32_t v88 = v29 + 1; // 0x8048fb8
    v19 = v88;
    v33 = v34;
    v37 = v38;
    v23 = v22;
    v28 = v29;
    v16 = v22;
    v39 = v38;
    v35 = v34;
    v18 = v88;
    if (v2) {
        goto lab_0x8049000;
    } else {
        goto lab_0x8048fbd;
    }
  lab_0x8049000:;
    uint32_t v89 = v35;
    if (v89 < a2) {
        // 0x8049008
        *(char *)(v89 + a1) = v39;
    }
    // 0x8049015
    v17 = v89 + 1;
    goto lab_0x8048ed0;
  lab_0x8048fdb:;
    uint32_t v90 = v87;
    if (v90 < a2) {
        // 0x8048fe3
        *(char *)(v90 + a1) = 92;
    }
    // 0x8048fed
    v16 = v85;
    v39 = v86;
    v35 = v90 + 1;
    v18 = v84 + 1;
    goto lab_0x8049000;
  lab_0x8048fbd:;
    int32_t v91 = *(int32_t *)(a6 + 4 + (int32_t)(4 * v37 / 32)); // 0x8048fce
    v84 = v28;
    v85 = v23;
    v86 = v37;
    v87 = v33;
    v16 = v23;
    v39 = v37;
    v35 = v33;
    v18 = v19;
    if ((v91 & 1 << (int32_t)(v37 % 32)) == 0) {
        goto lab_0x8049000;
    } else {
        goto lab_0x8048fdb;
    }
  lab_0x80491ae:;
    int32_t v92 = v24;
    int32_t v93 = v43 + 1;
    v16 = v92;
    v39 = v44;
    v35 = v32;
    v18 = v93;
    if (v2) {
        goto lab_0x8049000;
    } else {
        // 0x80491bf
        v19 = v93;
        v33 = v32;
        v37 = v44;
        v23 = v92;
        v28 = v43;
        v81 = v92;
        v82 = v41;
        v83 = v26;
        if (v26 != 0) {
            goto lab_0x8048fbd;
        } else {
            goto lab_0x80491ca;
        }
    }
  lab_0x80490e2:
    // 0x80490e2
    v29 = v30;
    v38 = v40;
    v34 = v36 + 1;
    goto lab_0x8048fb0;
  lab_0x80491ca:;
    int32_t v94 = v32;
    unsigned char v95 = v44;
    char v96 = v95; // 0x80491e5
    int32_t v97 = v94; // 0x80491e5
    uint32_t v98; // 0x8049200
    uint32_t v99; // 0x804921d
    if (!v2 && v83 == 0) {
        if (v94 < a2) {
            // 0x80491f6
            *(char *)(v94 + a1) = 92;
        }
        // 0x8049200
        v98 = v94 + 1;
        if (v98 < a2) {
            // 0x804920b
            *(char *)(v98 + a1) = v95 / 64 | 48;
        }
        // 0x804921d
        v99 = v94 + 2;
        if (v99 < a2) {
            // 0x8049228
            *(char *)(v99 + a1) = v95 / 8 % 8 | 48;
        }
        // 0x804923c
        v96 = v95 % 8 | 48;
        v97 = v94 + 3;
    }
    int32_t v100 = v97;
    char v101 = v96;
    int32_t v102 = v43 + 1; // 0x8049253
    v16 = v81;
    v39 = v101;
    v35 = v100;
    v18 = v102;
    while (v82 + v43 > v102) {
        if (v100 < a2) {
            // 0x8049264
            *(char *)(v100 + a1) = v101;
        }
        // 0x8049271
        v94 = v100 + 1;
        v95 = *(char *)(v102 + str2);
        v96 = v95;
        v97 = v94;
        if (!v2 && v83 == 0) {
            if (v94 < a2) {
                // 0x80491f6
                *(char *)(v94 + a1) = 92;
            }
            // 0x8049200
            v98 = v94 + 1;
            if (v98 < a2) {
                // 0x804920b
                *(char *)(v98 + a1) = v95 / 64 | 48;
            }
            // 0x804921d
            v99 = v94 + 2;
            if (v99 < a2) {
                // 0x8049228
                *(char *)(v99 + a1) = v95 / 8 % 8 | 48;
            }
            // 0x804923c
            v96 = v95 % 8 | 48;
            v97 = v94 + 3;
        }
        // 0x8049250
        v100 = v97;
        v101 = v96;
        v102++;
        v16 = v81;
        v39 = v101;
        v35 = v100;
        v18 = v102;
    }
    goto lab_0x8049000;
  lab_0x8049139:
    if (v32 < a2) {
        // 0x8049147
        *(char *)(v32 + a1) = 63;
    }
    uint32_t v103 = v32 + 1; // 0x8049151
    if (v103 < a2) {
        // 0x804915c
        *(char *)(v103 + a1) = 92;
    }
    int32_t v104 = v32 + 2; // 0x8049166
    v30 = v45;
    v40 = v46;
    v36 = v104;
    if (v104 < a2) {
        // 0x8049175
        *(char *)(v104 + a1) = 63;
        v30 = v45;
        v40 = v46;
        v36 = v104;
    }
    goto lab_0x80490e2;
}

// Address range: 0x8049490 - 0x80494ef
int32_t function_8049490(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    int32_t v1 = a5 == 0 ? (int32_t)&g18 : a5;
    int32_t * v2 = __errno_location(); // 0x80494a6
    int32_t result = function_8048e50(a1, a2, a3, a4, *(int32_t *)v1, v1); // 0x80494d4
    return result;
}

// Address range: 0x80494f0 - 0x8049652
int32_t function_80494f0(uint32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t * v1 = __errno_location(); // 0x80494f9
    if (a1 < 0) {
        // 0x8049648
        abort();
        // UNREACHABLE
    }
    int32_t v2 = *v1; // 0x80494fe
    if (g9 <= a1) {
        int32_t v3 = a1 + 1; // 0x804951b
        if (v3 >= 0x20000000) {
            // 0x804964d
            function_8049b00();
            // UNREACHABLE
        }
        int32_t v4 = *(int32_t *)0x804b7cc; // 0x8049528
        int32_t v5 = v4; // 0x8049534
        if (v4 == 0x804b7c4) {
            // 0x8049620
            v5 = function_8049ba0(8);
            g12 = v5;
            *(int32_t *)(v5 + 4) = (int32_t)g11;
            *(int32_t *)v5 = g10;
        }
        int32_t v6 = function_8049c20(v5, 8 * v3); // 0x804954a
        g12 = v6;
        int32_t v7 = g9; // 0x804955c
        memset((int32_t *)(8 * v7 + v6), 0, 8 * (v3 - v7));
        g9 = v3;
    }
    int32_t v8 = 8 * a1; // 0x8049588
    uint32_t v9 = *(int32_t *)(g12 + v8); // 0x8049588
    int32_t v10 = v8 | 4;
    int32_t result = *(int32_t *)(g12 + v10); // 0x804958b
    uint32_t v11 = function_8049490(result, v9, a2, a3, a4); // 0x80495a8
    if (v9 > v11) {
        // 0x8049608
        *__errno_location() = v2;
        return result;
    }
    int32_t v12 = v11 + 1; // 0x80495b7
    *(int32_t *)(g12 + v8) = v12;
    int32_t v13 = g12; // 0x80495c6
    if (result != (int32_t)&g17) {
        // 0x80495c8
        function_8049df0(result);
        v13 = g12;
    }
    int32_t result2 = function_8049ba0(v12); // 0x80495d9
    *(int32_t *)(v13 + v10) = result2;
    function_8049490(result2, v12, a2, a3, a4);
    // 0x8049608
    *__errno_location() = v2;
    return result2;
}

// Address range: 0x8049660 - 0x804968e
int32_t function_8049660(int32_t a1, int32_t a2) {
    // 0x8049660
    return function_80494f0(a1, a2, -1, (int32_t)&g18);
}

// Address range: 0x8049690 - 0x80496ad
int32_t function_8049690(int32_t result) {
    // 0x8049690
    return result;
}

// Address range: 0x80496b0 - 0x8049717
int32_t function_80496b0(int32_t * a1, int32_t a2) {
    int32_t result = (int32_t)a1;
    int32_t v1; // bp-56, 0x80496b0
    __asm_rep_stosd_memset((char *)&v1, 0, 8);
    *a1 = a2;
    *(int32_t *)(result + 4) = v1;
    return result;
}

// Address range: 0x8049720 - 0x8049764
int32_t function_8049720(int32_t a1, int32_t a2, int32_t a3) {
    // 0x8049720
    int32_t v1; // bp-60, 0x8049720
    function_80496b0(&v1, a2);
    return function_80494f0(a1, a3, -1, (int32_t)&v1);
}

// Address range: 0x8049770 - 0x80497b2
int32_t function_8049770(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x8049770
    int32_t v1; // bp-60, 0x8049770
    function_80496b0(&v1, a2);
    return function_80494f0(a1, a3, a4, (int32_t)&v1);
}

// Address range: 0x80497c0 - 0x80497e4
int32_t function_80497c0(int32_t a1, int32_t a2) {
    // 0x80497c0
    return function_8049720(0, a1, a2);
}

// Address range: 0x80497f0 - 0x8049884
int32_t function_80497f0(int32_t a1, int32_t a2) {
    int32_t v1 = g18; // bp-60, 0x8049808
    function_8048db0(&v1, 0x1000000 * a2 >> 24, 1);
    return function_80494f0(0, a1, -1, (int32_t)&v1);
}

// Address range: 0x8049890 - 0x80498ae
int32_t function_8049890(int32_t a1) {
    // 0x8049890
    return function_80497f0(a1, 58);
}

// Address range: 0x80498b0 - 0x8049abe
int32_t function_80498b0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    int32_t v1 = (int32_t)a5;
    int32_t v2 = v1; // 0x80498d7
    int32_t v3 = 0; // 0x80498d7
    int32_t v4 = 0; // 0x80498d7
    if (*a5 != 0) {
        v2 += 4;
        v3++;
        v4 = v3;
        while (*(int32_t *)v2 != 0) {
            // 0x80498e0
            v2 += 4;
            v3++;
            v4 = v3;
        }
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)a1;
    if (a2 == 0) {
        // 0x8049a9a
        fprintf(stream, "%s %s\n", (char *)a3, (char *)a4);
    } else {
        // 0x80498f4
        fprintf(stream, "%s (%s) %s\n", (char *)a2, (char *)a3, (char *)a4);
    }
    // 0x8049920
    g21 = v4;
    int32_t v5 = (int32_t)"Written by %s.\n"; // 0x8049920
    char * v6 = "Written by %s and %s.\n"; // 0x8049920
    int32_t * v7; // 0x8049960
    int32_t * v8; // 0x8049963
    switch (v4) {
        case 0: {
            // 0x8049927
            abort();
            // UNREACHABLE
        }
        case 3: {
            // 0x80499fa
            v5 = (int32_t)"Written by %s, %s, and %s.\n";
        }
        case 1: {
          lab_0x8049940:
            // 0x8049940
            v6 = (char *)v5;
        }
        case 2: {
          lab_0x8049944:
            // 0x8049944
            vfprintf(stream, dcgettext(NULL, v6, 5), v1);
            v7 = (int32_t *)(a1 + 20);
            uint32_t v9 = *v7; // 0x8049960
            v8 = (int32_t *)(a1 + 24);
            if (v9 >= *v8) {
                // 0x80499d0
                __overflow(stream, 10);
            } else {
                // 0x8049968
                *(char *)v9 = 10;
                *v7 = *v7 + 1;
            }
            // break -> 0x804996e
            break;
        }
        case 4: {
            // 0x8049a0d
            v5 = (int32_t)"Written by %s, %s, %s,\nand %s.\n";
            // branch (via goto) -> 0x8049940
            goto lab_0x8049940;
        }
        case 5: {
            // 0x8049a20
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, and %s.\n";
            // branch (via goto) -> 0x8049940
            goto lab_0x8049940;
        }
        case 6: {
            // 0x8049a33
            v6 = "Written by %s, %s, %s,\n%s, %s, and %s.\n";
            // branch (via goto) -> 0x8049944
            goto lab_0x8049944;
        }
        case 7: {
            // 0x8049a4a
            v6 = "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n";
            // branch (via goto) -> 0x8049944
            goto lab_0x8049944;
        }
        case 8: {
            // 0x8049a61
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n";
            // branch (via goto) -> 0x8049940
            goto lab_0x8049940;
        }
        case 9: {
            // 0x8049a74
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
            // branch (via goto) -> 0x8049940
            goto lab_0x8049940;
        }
        default: {
            // 0x8049a87
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
            // branch (via goto) -> 0x8049940
            goto lab_0x8049940;
        }
    }
    // 0x804996e
    fputs_unlocked(g13, stream);
    uint32_t v10 = *v7; // 0x804997f
    if (v10 >= *v8) {
        // 0x80499bd
        __overflow(stream, 10);
    } else {
        // 0x8049987
        *(char *)v10 = 10;
        *v7 = *v7 + 1;
    }
    char * v11 = dcgettext(NULL, "This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 5); // 0x80499a9
    return fputs_unlocked(v11, (struct _IO_FILE *)&g25);
}

// Address range: 0x8049ac0 - 0x8049af1
int32_t function_8049ac0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8049ac0
    int32_t v1; // bp+20, 0x8049ac0
    return function_80498b0(a1, a2, a3, a4, &v1);
}

// Address range: 0x8049b00 - 0x8049b56
int32_t function_8049b00(void) {
    // 0x8049b00
    error((int32_t)g8, 0, "%s", dcgettext(NULL, "memory exhausted", 5));
    abort();
    // UNREACHABLE
}

// Address range: 0x8049b60 - 0x8049b97
int32_t function_8049b60(uint32_t a1, uint32_t a2) {
    if (0xffffffff / a2 < a1) {
        // 0x8049b92
        function_8049b00();
        // UNREACHABLE
    }
    int32_t * mem = malloc(a2 * a1); // 0x8049b82
    if (mem != NULL) {
        // 0x8049b8b
        return (int32_t)mem;
    }
    // 0x8049b92
    function_8049b00();
    // UNREACHABLE
}

// Address range: 0x8049ba0 - 0x8049bc5
int32_t function_8049ba0(int32_t size) {
    int32_t * mem = malloc(size); // 0x8049bac
    if (mem != NULL) {
        // 0x8049bb5
        return (int32_t)mem;
    }
    // 0x8049bc0
    function_8049b00();
    // UNREACHABLE
}

// Address range: 0x8049bd0 - 0x8049c15
int32_t function_8049bd0(int32_t a1, uint32_t a2, uint32_t a3) {
    if (0xffffffff / a3 < a2) {
        // 0x8049c10
        function_8049b00();
        // UNREACHABLE
    }
    int32_t * mem = realloc((int32_t *)a1, a3 * a2); // 0x8049bfc
    if (mem != NULL) {
        // 0x8049c05
        return (int32_t)mem;
    }
    // 0x8049c10
    function_8049b00();
    // UNREACHABLE
}

// Address range: 0x8049c20 - 0x8049c45
int32_t function_8049c20(int32_t a1, int32_t a2) {
    int32_t * mem = realloc((int32_t *)a1, a2); // 0x8049c33
    if (mem != NULL) {
        // 0x8049c3c
        return (int32_t)mem;
    }
    // 0x8049c40
    function_8049b00();
    // UNREACHABLE
}

// Address range: 0x8049c50 - 0x8049cbf
int32_t function_8049c50(int32_t a1, int32_t a2, uint32_t a3) {
    int32_t * v1 = (int32_t *)a2; // 0x8049c67
    uint32_t v2 = *v1; // 0x8049c67
    int32_t v3; // 0x8049c50
    if (a1 == 0) {
        int32_t v4 = v2; // 0x8049ca2
        if (v2 == 0) {
            // 0x8049ca4
            v4 = a3 <= 64 ? 64 / a3 : 1;
        }
        // 0x8049c7d
        *v1 = v4;
        return function_8049c20(v3, v3);
    }
    if (0x7fffffff / a3 < v2) {
        // 0x8049cba
        function_8049b00();
        // UNREACHABLE
    }
    // 0x8049c7d
    *v1 = 2 * v2;
    return function_8049c20(v3, v3);
}

// Address range: 0x8049cc0 - 0x8049d31
int32_t function_8049cc0(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a2; // 0x8049cdc
    int32_t v2 = *v1; // 0x8049cdc
    int32_t v3; // 0x8049cc0
    if (a1 == 0) {
        // 0x8049cf1
        *v1 = v2 != 0 ? v2 : 64;
        return function_8049c20(v3, v3);
    }
    if (v2 < 0) {
        // 0x8049d2c
        function_8049b00();
        // UNREACHABLE
    }
    // 0x8049cf1
    *v1 = 2 * v2;
    return function_8049c20(v3, v3);
}

// Address range: 0x8049d31 - 0x8049d77
int32_t function_8049d31(int32_t a1) {
    int32_t result = function_8049ba0(a1); // 0x8049d52
    memset((int32_t *)result, 0, a1);
    return result;
}

// Address range: 0x8049d80 - 0x8049db8
int32_t function_8049d80(uint32_t nmemb, uint32_t size) {
    if (0xffffffff / size < nmemb) {
        // 0x8049db3
        function_8049b00();
        // UNREACHABLE
    }
    int32_t * mem = calloc(nmemb, size); // 0x8049da3
    if (mem != NULL) {
        // 0x8049dac
        return (int32_t)mem;
    }
    // 0x8049db3
    function_8049b00();
    // UNREACHABLE
}

// Address range: 0x8049dc0 - 0x8049dee
int32_t function_8049dc0(int32_t a1, int32_t a2) {
    // 0x8049dc0
    return (int32_t)memcpy((int32_t *)function_8049ba0(a2), (int32_t *)a1, a2);
}

// Address range: 0x8049df0 - 0x8049e02
int32_t function_8049df0(int32_t a1) {
    // 0x8049df0
    if (a1 == 0) {
        // 0x8049e00
        return 0;
    }
    // 0x8049dfa
    int32_t v1; // 0x8049df0
    free((int32_t *)v1);
    return &g25;
}

// Address range: 0x8049e04 - 0x8049e4c
int32_t function_8049e04(void) {
    // 0x8049e04
    return function_8048778();
}

// Address range: 0x8049e4c - 0x8049e90
int32_t function_8049e4c(void) {
    // 0x8049e4c
    return function_8049ee4();
}

// Address range: 0x8049e90 - 0x8049ebe
int32_t function_8049e90(int32_t a1) {
    // 0x8049e90
    int32_t v1; // 0x8049e90
    int32_t v2 = *(int32_t *)(v1 + 0x188b); // 0x8049ea0
    int32_t * v3 = NULL; // 0x8049eaa
    if (v2 != 0) {
        // 0x8049eac
        v3 = (int32_t *)*(int32_t *)v2;
    }
    // 0x8049eae
    return __cxa_atexit((void (*)(int32_t *))a1, NULL, v3);
}

// Address range: 0x8049ec0 - 0x8049ee4
int32_t function_8049ec0(void) {
    // 0x8049ec0
    int32_t result; // 0x8049ec0
    if (g5 == -1) {
        // 0x8049ee0
        return result;
    }
    int32_t v1 = &g5; // 0x8049ed2
    while (*(int32_t *)(v1 - 4) != -1) {
        // 0x8049ed4
        v1 -= 4;
    }
    // 0x8049ee0
    return result;
}

// Address range: 0x8049ee4 - 0x8049eff
int32_t function_8049ee4(void) {
    // 0x8049ee4
    return function_80489c8();
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// size_t __ctype_get_mb_cur_max(void);
// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// size_t __fpending(FILE * fp);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int __overflow(_IO_FILE *, int);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// void * calloc(size_t nmemb, size_t size);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// void error(int status, int errnum, const char * format, ...);
// void exit(int status);
// int fclose(FILE * stream);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs_unlocked(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// char * getenv(const char * name);
// int iswprint(wint_t wc);
// void * malloc(size_t size);
// size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict p);
// int mbsinit(const mbstate_t * ps);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// void * realloc(void * ptr, size_t size);
// char * setlocale(int category, const char * locale);
// size_t strlen(const char * s);
// char * textdomain(const char * domainname);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected functions: 73

