/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall init_proc(int a1, int a2);
int sub_80487C8();
// size_t __fpending(FILE *fp);
// int __overflow(_IO_FILE *, int);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int fprintf(FILE *stream, const char *format, ...);
// char *getenv(const char *name);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// char *setlocale(int category, const char *locale);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// int *__errno_location(void);
// void *malloc(size_t size);
// void abort(void);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// char *bindtextdomain(const char *domainname, const char *dirname);
// size_t strlen(const char *s);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// void *realloc(void *ptr, size_t size);
// char *textdomain(const char *domainname);
// int printf(const char *format, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// int fclose(FILE *stream);
// size_t __ctype_get_mb_cur_max(void);
// void exit(int status);
// void *calloc(size_t nmemb, size_t size);
// int iswprint(wint_t wc);
// void free(void *ptr);
// void *memset(void *s, int c, size_t n);
// int mbsinit(const mbstate_t *ps);
// void error(int status, int errnum, const char *format, ...);
// const unsigned __int16 **__ctype_b_loc(void);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
int __fastcall call_gmon_start(int a1, int a2);
// int *__usercall _do_global_dtors_aux@<eax>(int *result@<eax>);
int frame_dummy();
void __cdecl __noreturn usage(int status); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
int __cdecl close_stdout_set_file_name(int a1);
void __cdecl close_stdout();
int __cdecl get_quoting_style(int *a1);
int __cdecl set_quoting_style(int *a1, int a2);
int __cdecl set_char_quoting(int a1, unsigned __int8 a2, char a3);
_DWORD *__cdecl clone_quoting_options(int *a1);
// _DWORD *__usercall quoting_options_from_style@<eax>(_DWORD *result@<eax>, int a2@<edx>);
// char *__usercall gettext_quote@<eax>(const char *a1@<eax>, int a2@<edx>);
// unsigned int __usercall quotearg_buffer_restyled@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, const char *a3@<ecx>, size_t a4, int a5, int a6);
unsigned int __cdecl quotearg_buffer(_BYTE *a1, unsigned int a2, const char *a3, size_t a4, int *a5);
// _BYTE *__usercall quotearg_n_options@<eax>(int a1@<eax>, const char *a2@<edx>, size_t a3@<ecx>, int *a4);
_BYTE *__cdecl quotearg_char(const char *a1, unsigned __int8 a2);
_BYTE *__cdecl quotearg_colon(const char *a1);
_BYTE *__cdecl quotearg_n_style_mem(int a1, int a2, const char *a3, size_t a4);
_BYTE *__cdecl quotearg_n_style(int a1, int a2, const char *a3);
_BYTE *__cdecl quotearg_style(int a1, const char *a2);
_BYTE *__cdecl quotearg_n(int a1, const char *a2);
_BYTE *__cdecl quotearg(const char *a1);
int __cdecl version_etc_va(FILE *stream, int, int, int, __gnuc_va_list __varargs); // idb
int version_etc(FILE *stream, int, int, int, ...); // idb
void __noreturn xalloc_die();
void *__cdecl xcalloc(size_t nmemb, size_t size);
void *__cdecl xrealloc(void *ptr, size_t size);
void *__cdecl x2realloc(void *a1, signed int *a2);
void *__cdecl x2nrealloc(void *a1, unsigned int *a2, unsigned int a3);
void *__cdecl xnrealloc(void *ptr, int a2, int a3);
void *__cdecl xmalloc(size_t size);
void *__cdecl xclone(void *src, size_t n);
void *__cdecl xzalloc(size_t n);
void *__cdecl xnmalloc(unsigned int a1, unsigned int a2);
void _libc_csu_fini(void); // idb
void __fastcall _libc_csu_init(int a1, int a2);
int __cdecl atexit(void (__cdecl *lpfunc)(void *)); // idb
int __fastcall _do_global_ctors_aux(int a1, int a2);
// int *__usercall term_proc@<eax>(int *a1@<eax>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_804A099; // weak
int _CTOR_LIST__ = -1; // weak
int _JCR_LIST__ = 0; // weak
int (*dword_804B74C)(void) = NULL; // weak
_DWORD _dso_handle = 0; // idb
int *p_0 = &_DTOR_END__; // weak
int exit_failure = 1; // idb
int nslots_1 = 1; // weak
int slotvec0_2 = 256; // weak
void *off_804B7E0 = &slot0_0; // weak
void *slotvec_3 = &slotvec0_2; // idb
char *version_etc_copyright = "Copyright (C) 2004 Free Software Foundation, Inc."; // weak
FILE *stdout; // idb
char completed_1; // weak
int file_name; // weak
_UNKNOWN slot0_0; // weak
int default_quoting_options; // weak
int dword_804B924[]; // weak
int dword_804B928; // weak
int dword_804B92C; // weak
int dword_804B930; // weak
int dword_804B934; // weak
int dword_804B938; // weak
int dword_804B93C; // weak
int dword_804B940; // weak
int (*xalloc_fail_func)(void); // weak
int program_name; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (080487B0) --------------------------------------------------------
int __fastcall init_proc(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx

  call_gmon_start(a1, a2);
  frame_dummy();
  return _do_global_ctors_aux(v3, v2);
}
// 80487C0: variable 'v3' is possibly undefined
// 80487C0: variable 'v2' is possibly undefined

//----- (080487C8) --------------------------------------------------------
int sub_80487C8()
{
  return dword_804B74C();
}
// 804B74C: using guessed type int (*dword_804B74C)(void);

//----- (080489C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main(
    (int (__cdecl *)(int, char **, char **))main,
    v2,
    &retaddr,
    (void (*)(void))_libc_csu_init,
    _libc_csu_fini,
    a2,
    &v3);
  __halt();
}
// 80489C3: positive sp value 4 has been found

//----- (080489E4) --------------------------------------------------------
int __fastcall call_gmon_start(int a1, int a2)
{
  if ( &_gmon_start__ )
    ((void (__cdecl *)(int))_gmon_start__)(a2);
  return a2;
}
// 8048A01: variable 'a2' is possibly undefined

//----- (08048A10) --------------------------------------------------------
int *__usercall _do_global_dtors_aux@<eax>(int *result@<eax>)
{
  void (__cdecl *i)(int *, int *); // edx
  int *v2; // [esp-8h] [ebp-8h]
  int *v3; // [esp-4h] [ebp-4h]

  v3 = result;
  v2 = result;
  if ( !completed_1 )
  {
    result = p_0;
    for ( i = (void (__cdecl *)(int *, int *))*p_0; *p_0; i = (void (__cdecl *)(int *, int *))*p_0 )
    {
      p_0 = result + 1;
      i(v2, v3);
      result = p_0;
    }
    completed_1 = 1;
  }
  return result;
}
// 8048A38: variable 'v2' is possibly undefined
// 8048A38: variable 'v3' is possibly undefined
// 804B7D0: using guessed type int *p_0;
// 804B804: using guessed type char completed_1;

//----- (08048A50) --------------------------------------------------------
int frame_dummy()
{
  int result; // eax

  if ( _JCR_LIST__ )
    result = 0;
  return result;
}
// 804B670: using guessed type int _JCR_LIST__;

//----- (08048A80) --------------------------------------------------------
void __cdecl __noreturn usage(int status)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  v1 = dcgettext(
         0,
         "Usage: %s [ignored command line arguments]\n"
         "  or:  %s OPTION\n"
         "Exit with a status code indicating success.\n"
         "\n"
         "These option names may not be abbreviated.\n"
         "\n",
         5);
  printf(v1, program_name, program_name);
  v2 = dcgettext(0, "      --help     display this help and exit\n", 5);
  fputs_unlocked(v2, stdout);
  v3 = dcgettext(0, "      --version  output version information and exit\n", 5);
  fputs_unlocked(v3, stdout);
  v4 = dcgettext(0, "\nReport bugs to <%s>.\n", 5);
  printf(v4, "bug-coreutils@gnu.org");
  exit(status);
}
// 80487F8: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804B948: using guessed type int program_name;

//----- (08048B60) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  program_name = (int)*argv;
  setlocale(6, "");
  bindtextdomain("coreutils", "/usr/share/locale");
  textdomain("coreutils");
  atexit((void (__cdecl *)(void *))close_stdout);
  if ( argc == 2 && !getenv("POSIXLY_CORRECT") )
  {
    if ( !strcmp(argv[1], "--help") )
      usage(0);
    if ( !strcmp(argv[1], "--version") )
      version_etc(stdout, (int)"true", (int)&unk_804A099, (int)"5.2.1", "Jim Meyering", 0);
  }
  exit(0);
}
// 804B948: using guessed type int program_name;

//----- (08048C70) --------------------------------------------------------
int __cdecl close_stdout_set_file_name(int a1)
{
  int result; // eax

  result = a1;
  file_name = a1;
  return result;
}
// 804B808: using guessed type int file_name;

//----- (08048C80) --------------------------------------------------------
void __cdecl close_stdout()
{
  FILE *v0; // edx
  unsigned int v1; // eax
  int v2; // ebx
  char *v3; // esi
  const char *v4; // eax

  v0 = stdout;
  v1 = ((unsigned int)stdout->_flags >> 5) & 1;
  v2 = -(v1 == 0);
  if ( !v1 )
  {
    if ( !__fpending(stdout) )
      return;
    v0 = stdout;
  }
  if ( fclose(v0) )
    v2 = *__errno_location();
  if ( v2 >= 0 )
  {
    v3 = dcgettext(0, "write error", 5);
    if ( file_name )
    {
      v4 = quotearg_colon((const char *)file_name);
      error(exit_failure, v2, "%s: %s", v4, v3);
    }
    else
    {
      error(exit_failure, v2, "%s", v3);
    }
  }
}
// 804B808: using guessed type int file_name;

//----- (08048D50) --------------------------------------------------------
int __cdecl get_quoting_style(int *a1)
{
  int result; // eax

  if ( a1 )
    result = *a1;
  else
    result = default_quoting_options;
  return result;
}
// 804B920: using guessed type int default_quoting_options;

//----- (08048D70) --------------------------------------------------------
int __cdecl set_quoting_style(int *a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a1 )
    *a1 = a2;
  else
    default_quoting_options = a2;
  return result;
}
// 804B920: using guessed type int default_quoting_options;

//----- (08048D90) --------------------------------------------------------
int __cdecl set_char_quoting(int a1, unsigned __int8 a2, char a3)
{
  int v3; // edx
  int *v4; // esi
  int result; // eax
  int v6; // edx
  int v7; // edx

  v3 = a2 >> 5;
  v4 = (int *)(v3 * 4 + a1 + 4);
  if ( a1 )
  {
    result = (*v4 >> (a2 & 0x1F)) & 1;
    v6 = ((result ^ a3 & 1) << (a2 & 0x1F)) ^ *v4;
  }
  else
  {
    v4 = &dword_804B924[v3];
    v7 = dword_804B924[a2 >> 5];
    result = (v7 >> (a2 & 0x1F)) & 1;
    v6 = ((result ^ a3 & 1) << (a2 & 0x1F)) ^ v7;
  }
  *v4 = v6;
  return result;
}
// 804B924: using guessed type int dword_804B924[];

//----- (08048E00) --------------------------------------------------------
_DWORD *__cdecl clone_quoting_options(int *a1)
{
  int *v1; // eax
  int v2; // esi
  int *v3; // ebx
  _DWORD *result; // eax
  int *v5; // edx

  v1 = __errno_location();
  v2 = *v1;
  v3 = v1;
  result = xmalloc(0x24u);
  v5 = a1;
  if ( !a1 )
    v5 = &default_quoting_options;
  *result = *v5;
  result[1] = v5[1];
  result[2] = v5[2];
  result[3] = v5[3];
  result[4] = v5[4];
  result[5] = v5[5];
  result[6] = v5[6];
  result[7] = v5[7];
  result[8] = v5[8];
  *v3 = v2;
  return result;
}
// 804B920: using guessed type int default_quoting_options;

//----- (08048E70) --------------------------------------------------------
_DWORD *__usercall quoting_options_from_style@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  int v2[8]; // [esp+4h] [ebp-34h] BYREF

  memset(v2, 0, sizeof(v2));
  *result = a2;
  result[1] = v2[0];
  result[2] = v2[1];
  result[3] = v2[2];
  result[4] = v2[3];
  result[5] = v2[4];
  result[6] = v2[5];
  result[7] = v2[6];
  result[8] = v2[7];
  return result;
}

//----- (08048ED0) --------------------------------------------------------
char *__usercall gettext_quote@<eax>(const char *a1@<eax>, int a2@<edx>)
{
  char *v4; // ecx

  v4 = dcgettext(0, a1, 5);
  if ( v4 == a1 && a2 == 6 )
    v4 = (char *)L"\"`'";
  return v4;
}
// 804A3BC: using guessed type __int16 asc_804A3BC[4];

//----- (08048F20) --------------------------------------------------------
unsigned int __usercall quotearg_buffer_restyled@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, const char *a3@<ecx>, size_t a4, int a5, int a6)
{
  unsigned int v6; // ecx
  int v7; // edx
  char k; // al
  size_t v10; // eax
  char v11; // al
  char *i; // edx
  unsigned int v13; // [esp+1Ch] [ebp-6Ch]
  unsigned int v14; // [esp+1Ch] [ebp-6Ch]
  unsigned int v15; // [esp+1Ch] [ebp-6Ch]
  unsigned int v16; // [esp+1Ch] [ebp-6Ch]
  unsigned int v17; // [esp+1Ch] [ebp-6Ch]
  unsigned int v18; // [esp+1Ch] [ebp-6Ch]
  unsigned int v19; // [esp+1Ch] [ebp-6Ch]
  unsigned int v20; // [esp+1Ch] [ebp-6Ch]
  int j; // [esp+28h] [ebp-60h]
  unsigned int v22; // [esp+2Ch] [ebp-5Ch]
  unsigned __int8 v23; // [esp+30h] [ebp-58h]
  _BOOL4 v24; // [esp+44h] [ebp-44h]
  int v25; // [esp+48h] [ebp-40h]
  unsigned int v26; // [esp+4Ch] [ebp-3Ch]
  const __int16 *v27; // [esp+50h] [ebp-38h]
  char *v28; // [esp+50h] [ebp-38h]
  int v29; // [esp+54h] [ebp-34h]
  wchar_t pwc; // [esp+64h] [ebp-24h] BYREF
  mbstate_t p; // [esp+68h] [ebp-20h] BYREF

  v13 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = __ctype_get_mb_cur_max() == 1;
  switch ( a5 )
  {
    case 2:
      if ( a2 )
        *a1 = 39;
      v13 = 1;
      v27 = L"\"`'" + 4;
      goto LABEL_5;
    case 3:
      if ( a2 )
        *a1 = 34;
      v13 = 1;
      v25 = 1;
      v27 = L"\"`'";
LABEL_5:
      v26 = 1;
      break;
    case 4:
      v25 = 1;
      break;
    case 5:
    case 6:
      v28 = gettext_quote((const char *)L"`'", a5);
      for ( i = gettext_quote((const char *)L"'", a5); *v28; ++v13 )
      {
        if ( v13 < a2 )
          a1[v13] = *v28;
        ++v28;
      }
      v25 = 1;
      v27 = (const __int16 *)i;
      v26 = strlen(i);
      break;
    default:
      break;
  }
  v29 = 0;
  while ( 1 )
  {
    if ( a4 != -1 )
    {
      if ( v29 == a4 )
        break;
      goto LABEL_9;
    }
    if ( !a3[v29] )
      break;
LABEL_9:
    if ( v25 && v26 && v26 + v29 <= a4 && !memcmp(&a3[v29], v27, v26) )
    {
      if ( v13 < a2 )
        a1[v13] = 92;
      ++v13;
    }
    v23 = a3[v29];
    switch ( v23 )
    {
      case 0u:
        v7 = v29 + 1;
        if ( !v25 )
          goto LABEL_57;
        if ( v13 < a2 )
          a1[v13] = 92;
        v18 = v13 + 1;
        if ( v18 < a2 )
          a1[v18] = 48;
        v19 = v18 + 1;
        if ( v19 < a2 )
          a1[v19] = 48;
        v13 = v19 + 1;
        v23 = 48;
        goto LABEL_52;
      case 7u:
        v11 = 97;
        goto LABEL_62;
      case 8u:
        v11 = 98;
        goto LABEL_62;
      case 9u:
        v11 = 116;
        goto LABEL_61;
      case 0xAu:
        v11 = 110;
        goto LABEL_61;
      case 0xBu:
        v11 = 118;
        goto LABEL_62;
      case 0xCu:
        v11 = 102;
        goto LABEL_62;
      case 0xDu:
        v11 = 114;
        if ( a5 == 1 )
          return quotearg_buffer_restyled(a4, 2, a6);
        goto LABEL_62;
      case 0x20u:
      case 0x21u:
      case 0x22u:
      case 0x24u:
      case 0x26u:
      case 0x28u:
      case 0x29u:
      case 0x2Au:
      case 0x3Bu:
      case 0x3Cu:
      case 0x3Eu:
      case 0x5Bu:
      case 0x5Eu:
      case 0x60u:
      case 0x7Cu:
        goto LABEL_51;
      case 0x23u:
      case 0x7Eu:
        if ( v29 )
          goto LABEL_52;
LABEL_51:
        if ( a5 != 1 )
          goto LABEL_52;
        return quotearg_buffer_restyled(a4, 2, a6);
      case 0x25u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x2Du:
      case 0x2Eu:
      case 0x2Fu:
      case 0x30u:
      case 0x31u:
      case 0x32u:
      case 0x33u:
      case 0x34u:
      case 0x35u:
      case 0x36u:
      case 0x37u:
      case 0x38u:
      case 0x39u:
      case 0x3Au:
      case 0x3Du:
      case 0x41u:
      case 0x42u:
      case 0x43u:
      case 0x44u:
      case 0x45u:
      case 0x46u:
      case 0x47u:
      case 0x48u:
      case 0x49u:
      case 0x4Au:
      case 0x4Bu:
      case 0x4Cu:
      case 0x4Du:
      case 0x4Eu:
      case 0x4Fu:
      case 0x50u:
      case 0x51u:
      case 0x52u:
      case 0x53u:
      case 0x54u:
      case 0x55u:
      case 0x56u:
      case 0x57u:
      case 0x58u:
      case 0x59u:
      case 0x5Au:
      case 0x5Du:
      case 0x5Fu:
      case 0x61u:
      case 0x62u:
      case 0x63u:
      case 0x64u:
      case 0x65u:
      case 0x66u:
      case 0x67u:
      case 0x68u:
      case 0x69u:
      case 0x6Au:
      case 0x6Bu:
      case 0x6Cu:
      case 0x6Du:
      case 0x6Eu:
      case 0x6Fu:
      case 0x70u:
      case 0x71u:
      case 0x72u:
      case 0x73u:
      case 0x74u:
      case 0x75u:
      case 0x76u:
      case 0x77u:
      case 0x78u:
      case 0x79u:
      case 0x7Au:
      case 0x7Bu:
      case 0x7Du:
        goto LABEL_52;
      case 0x27u:
        if ( a5 == 1 )
          return quotearg_buffer_restyled(a4, 2, a6);
        if ( a5 == 2 )
        {
          if ( v13 < a2 )
            a1[v13] = 39;
          v16 = v13 + 1;
          if ( v16 < a2 )
            a1[v16] = 92;
          v17 = v16 + 1;
          if ( v17 < a2 )
            a1[v17] = 39;
LABEL_77:
          v13 = v17 + 1;
        }
        goto LABEL_52;
      case 0x3Fu:
        if ( a5 == 1 )
          return quotearg_buffer_restyled(a4, 2, a6);
        if ( a5 == 3 && v29 + 2 < a4 && a3[v29 + 1] == 63 )
        {
          switch ( a3[v29 + 2] )
          {
            case '!':
            case '\'':
            case '(':
            case ')':
            case '-':
            case '/':
            case '<':
            case '=':
            case '>':
              v23 = a3[v29 + 2];
              v29 += 2;
              if ( v13 < a2 )
                a1[v13] = 63;
              v20 = v13 + 1;
              if ( v20 < a2 )
                a1[v20] = 92;
              v17 = v20 + 1;
              if ( v17 < a2 )
                a1[v17] = 63;
              goto LABEL_77;
            default:
              goto LABEL_52;
          }
        }
        goto LABEL_52;
      case 0x5Cu:
        v11 = a3[v29];
LABEL_61:
        if ( a5 == 1 )
          return quotearg_buffer_restyled(a4, 2, a6);
LABEL_62:
        v7 = v29 + 1;
        if ( !v25 )
          goto LABEL_57;
        v23 = v11;
        goto LABEL_54;
      default:
        if ( v24 )
        {
          v22 = 1;
          j = (*__ctype_b_loc())[v23] & 0x4000;
        }
        else
        {
          p.__count = 0;
          p.__wch = 0;
          v22 = 0;
          j = 1;
          if ( a4 == -1 )
            a4 = strlen(a3);
          do
          {
            v10 = mbrtowc(&pwc, &a3[v22 + v29], a4 - (v22 + v29), &p);
            if ( !v10 )
              break;
            if ( v10 == -1 )
            {
              j = 0;
              break;
            }
            if ( v10 == -2 )
            {
              for ( j = 0; v22 + v29 < a4 && a3[v22 + v29]; ++v22 )
                ;
              break;
            }
            v22 += v10;
            j = iswprint(pwc) != 0 ? j : 0;
          }
          while ( !mbsinit(&p) );
          if ( v22 > 1 )
          {
LABEL_20:
            v6 = v22 + v29;
            while ( 1 )
            {
              if ( j == 0 && v25 != 0 )
              {
                if ( v13 < a2 )
                  a1[v13] = 92;
                v14 = v13 + 1;
                if ( v14 < a2 )
                  a1[v14] = (v23 >> 6) + 48;
                v15 = v14 + 1;
                if ( v15 < a2 )
                  a1[v15] = ((v23 >> 3) & 7) + 48;
                v13 = v15 + 1;
                v23 = (v23 & 7) + 48;
              }
              v7 = v29 + 1;
              if ( v6 <= v29 + 1 )
                break;
              if ( v13 < a2 )
                a1[v13] = v23;
              ++v13;
              ++v29;
              v23 = a3[v7];
            }
            goto LABEL_57;
          }
        }
        if ( j == 0 && v25 != 0 )
          goto LABEL_20;
LABEL_52:
        v7 = v29 + 1;
        if ( v25 && ((*(int *)(a6 + 4 * (v23 >> 5) + 4) >> (v23 & 0x1F)) & 1) != 0 )
        {
LABEL_54:
          if ( v13 < a2 )
            a1[v13] = 92;
          ++v13;
          v7 = v29 + 1;
        }
LABEL_57:
        if ( v13 < a2 )
          a1[v13] = v23;
        ++v13;
        v29 = v7;
        break;
    }
  }
  if ( v27 )
  {
    for ( k = *(_BYTE *)v27; *(_BYTE *)v27; k = *(_BYTE *)v27 )
    {
      if ( v13 < a2 )
        a1[v13] = k;
      v27 = (const __int16 *)((char *)v27 + 1);
      ++v13;
    }
  }
  if ( v13 < a2 )
    a1[v13] = 0;
  return v13;
}
// 804A3BC: using guessed type __int16 asc_804A3BC[4];

//----- (08049560) --------------------------------------------------------
unsigned int __cdecl quotearg_buffer(_BYTE *a1, unsigned int a2, const char *a3, size_t a4, int *a5)
{
  int *v5; // edi
  int *v6; // eax
  int v7; // esi
  int *v8; // ebx
  unsigned int result; // eax

  v5 = a5;
  if ( !a5 )
    v5 = &default_quoting_options;
  v6 = __errno_location();
  v7 = *v6;
  v8 = v6;
  result = quotearg_buffer_restyled(a1, a2, a3, a4, *v5, (int)v5);
  *v8 = v7;
  return result;
}
// 804B920: using guessed type int default_quoting_options;

//----- (080495C0) --------------------------------------------------------
_BYTE *__usercall quotearg_n_options@<eax>(int a1@<eax>, const char *a2@<edx>, size_t a3@<ecx>, int *a4)
{
  int v4; // esi
  int *v5; // ebx
  _DWORD *v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // esi
  _BYTE *v9; // edi
  unsigned int v10; // eax
  _DWORD *v11; // ebx
  size_t v12; // esi
  int v14; // eax
  int v15; // [esp+1Ch] [ebp-1Ch]

  v15 = *__errno_location();
  if ( a1 < 0 )
    abort();
  if ( nslots_1 <= (unsigned int)a1 )
  {
    v4 = a1 + 1;
    if ( (unsigned int)(a1 + 1) > 0x1FFFFFFF )
      xalloc_die();
    v5 = (int *)slotvec_3;
    if ( slotvec_3 == &slotvec0_2 )
    {
      slotvec_3 = xmalloc(8u);
      v5 = (int *)slotvec_3;
      v14 = slotvec0_2;
      *((_DWORD *)slotvec_3 + 1) = off_804B7E0;
      *v5 = v14;
    }
    slotvec_3 = xrealloc(v5, 8 * v4);
    v6 = (char *)slotvec_3 + 8 * nslots_1;
    v7 = 8 * (v4 - nslots_1);
    if ( v7 > 7 && ((unsigned __int8)v6 & 4) != 0 )
    {
      *v6 = 0;
      v7 -= 4;
      ++v6;
    }
    memset(v6, 0, 4 * (v7 >> 2));
    nslots_1 = a1 + 1;
  }
  v8 = *((_DWORD *)slotvec_3 + 2 * a1);
  v9 = (_BYTE *)*((_DWORD *)slotvec_3 + 2 * a1 + 1);
  v10 = quotearg_buffer(v9, v8, a2, a3, a4);
  if ( v8 <= v10 )
  {
    v11 = slotvec_3;
    v12 = v10 + 1;
    *((_DWORD *)slotvec_3 + 2 * a1) = v10 + 1;
    if ( v9 != (_BYTE *)&slot0_0 )
    {
      free(v9);
      v11 = slotvec_3;
    }
    v9 = xmalloc(v12);
    v11[2 * a1 + 1] = v9;
    quotearg_buffer(v9, v12, a2, a3, a4);
  }
  *__errno_location() = v15;
  return v9;
}
// 804B7D8: using guessed type int nslots_1;
// 804B7DC: using guessed type int slotvec0_2;
// 804B7E0: using guessed type void *off_804B7E0;

//----- (08049750) --------------------------------------------------------
_BYTE *__cdecl quotearg_char(const char *a1, unsigned __int8 a2)
{
  int v3[14]; // [esp+10h] [ebp-38h] BYREF

  v3[0] = default_quoting_options;
  v3[1] = dword_804B924[0];
  v3[2] = dword_804B928;
  v3[3] = dword_804B92C;
  v3[4] = dword_804B930;
  v3[5] = dword_804B934;
  v3[6] = dword_804B938;
  v3[7] = dword_804B93C;
  v3[8] = dword_804B940;
  set_char_quoting((int)v3, a2, 1);
  return quotearg_n_options(0, a1, 0xFFFFFFFF, v3);
}
// 804B920: using guessed type int default_quoting_options;
// 804B924: using guessed type int dword_804B924[];
// 804B928: using guessed type int dword_804B928;
// 804B92C: using guessed type int dword_804B92C;
// 804B930: using guessed type int dword_804B930;
// 804B934: using guessed type int dword_804B934;
// 804B938: using guessed type int dword_804B938;
// 804B93C: using guessed type int dword_804B93C;
// 804B940: using guessed type int dword_804B940;

//----- (080497E0) --------------------------------------------------------
_BYTE *__cdecl quotearg_colon(const char *a1)
{
  return quotearg_char(a1, 0x3Au);
}

//----- (08049800) --------------------------------------------------------
_BYTE *__cdecl quotearg_n_style_mem(int a1, int a2, const char *a3, size_t a4)
{
  int v5[14]; // [esp+10h] [ebp-38h] BYREF

  quoting_options_from_style(v5, a2);
  return quotearg_n_options(a1, a3, a4, v5);
}

//----- (08049830) --------------------------------------------------------
_BYTE *__cdecl quotearg_n_style(int a1, int a2, const char *a3)
{
  int v4[14]; // [esp+10h] [ebp-38h] BYREF

  quoting_options_from_style(v4, a2);
  return quotearg_n_options(a1, a3, 0xFFFFFFFF, v4);
}

//----- (08049860) --------------------------------------------------------
_BYTE *__cdecl quotearg_style(int a1, const char *a2)
{
  return quotearg_n_style(0, a1, a2);
}

//----- (08049890) --------------------------------------------------------
_BYTE *__cdecl quotearg_n(int a1, const char *a2)
{
  return quotearg_n_options(a1, a2, 0xFFFFFFFF, &default_quoting_options);
}
// 804B920: using guessed type int default_quoting_options;

//----- (080498B0) --------------------------------------------------------
_BYTE *__cdecl quotearg(const char *a1)
{
  return quotearg_n(0, a1);
}

//----- (080498D0) --------------------------------------------------------
int __cdecl version_etc_va(FILE *stream, int a2, int a3, int a4, __gnuc_va_list __varargs)
{
  int v5; // ebx
  _DWORD *v6; // edx
  const char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int result; // eax

  v5 = 0;
  v6 = (char *)__varargs + 4;
  if ( *(_DWORD *)__varargs )
  {
    do
      ++v5;
    while ( *v6++ );
  }
  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", (const char *)a2, (const char *)a3, (const char *)a4);
  else
    fprintf(stream, "%s %s\n", (const char *)a3, (const char *)a4);
  switch ( v5 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = "Written by %s.\n";
      goto LABEL_7;
    case 2:
      v9 = dcgettext(0, "Written by %s and %s.\n", 5);
      goto LABEL_8;
    case 3:
      v8 = "Written by %s, %s, and %s.\n";
      goto LABEL_7;
    case 4:
      v8 = "Written by %s, %s, %s,\nand %s.\n";
      goto LABEL_7;
    case 5:
      v8 = "Written by %s, %s, %s,\n%s, and %s.\n";
      goto LABEL_7;
    case 6:
      v9 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, and %s.\n", 5);
      goto LABEL_8;
    case 7:
      v9 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", 5);
      goto LABEL_8;
    case 8:
      v8 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n";
      goto LABEL_7;
    case 9:
      v8 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
      goto LABEL_7;
    default:
      v8 = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
LABEL_7:
      v9 = dcgettext(0, v8, 5);
LABEL_8:
      vfprintf(stream, v9, __varargs);
      v10 = stream->_IO_write_ptr;
      if ( v10 >= stream->_IO_write_end )
      {
        __overflow(stream, 10);
      }
      else
      {
        *v10 = 10;
        ++stream->_IO_write_ptr;
      }
      fputs_unlocked(version_etc_copyright, stream);
      v11 = stream->_IO_write_ptr;
      if ( v11 >= stream->_IO_write_end )
      {
        __overflow(stream, 10);
      }
      else
      {
        *v11 = 10;
        ++stream->_IO_write_ptr;
      }
      v12 = dcgettext(
              0,
              "This is free software; see the source for copying conditions.  There is NO\n"
              "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
              5);
      return fputs_unlocked(v12, stream);
  }
}
// 80487F8: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804B7E8: using guessed type char *version_etc_copyright;

//----- (08049AF0) --------------------------------------------------------
int version_etc(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list __varargs; // [esp+30h] [ebp+18h] BYREF

  va_start(__varargs, a4);
  return version_etc_va(stream, a2, a3, a4, __varargs);
}

//----- (08049B20) --------------------------------------------------------
void __noreturn xalloc_die()
{
  char *v0; // eax

  if ( xalloc_fail_func )
    xalloc_fail_func();
  v0 = dcgettext(0, "memory exhausted", 5);
  error(exit_failure, 0, "%s", v0);
  abort();
}
// 804B944: using guessed type int (*xalloc_fail_func)(void);

//----- (08049B80) --------------------------------------------------------
void *__cdecl xcalloc(size_t nmemb, size_t size)
{
  void *result; // eax

  if ( 0xFFFFFFFF / size < nmemb || (result = calloc(nmemb, size)) == 0 )
    xalloc_die();
  return result;
}

//----- (08049BC0) --------------------------------------------------------
void *__cdecl xrealloc(void *ptr, size_t size)
{
  void *result; // eax

  result = realloc(ptr, size);
  if ( !result )
    xalloc_die();
  return result;
}

//----- (08049BF0) --------------------------------------------------------
void *__cdecl x2realloc(void *a1, signed int *a2)
{
  signed int v2; // eax

  v2 = *a2;
  if ( a1 )
  {
    if ( v2 < 0 )
      xalloc_die();
    v2 *= 2;
  }
  else if ( !v2 )
  {
    v2 = 64;
  }
  *a2 = v2;
  return xrealloc(a1, v2);
}

//----- (08049C30) --------------------------------------------------------
void *__cdecl x2nrealloc(void *a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v3; // ecx

  v3 = *a2;
  if ( a1 )
  {
    if ( 0x7FFFFFFF / a3 < v3 )
      xalloc_die();
    v3 *= 2;
  }
  else if ( !v3 )
  {
    v3 = (0x40 / a3 == 0) + 0x40 / a3;
  }
  *a2 = v3;
  return xrealloc(a1, a3 * v3);
}

//----- (08049CA0) --------------------------------------------------------
void *__cdecl xnrealloc(void *ptr, int a2, int a3)
{
  void *result; // eax

  if ( 0xFFFFFFFF / a3 < a2 || (result = realloc(ptr, a3 * a2)) == 0 )
    xalloc_die();
  return result;
}

//----- (08049CF0) --------------------------------------------------------
void *__cdecl xmalloc(size_t size)
{
  void *result; // eax

  result = malloc(size);
  if ( !result )
    xalloc_die();
  return result;
}

//----- (08049D20) --------------------------------------------------------
void *__cdecl xclone(void *src, size_t n)
{
  void *v2; // eax

  v2 = xmalloc(n);
  return memcpy(v2, src, n);
}

//----- (08049D50) --------------------------------------------------------
void *__cdecl xzalloc(size_t n)
{
  void *v1; // eax

  v1 = xmalloc(n);
  return memset(v1, 0, n);
}

//----- (08049D80) --------------------------------------------------------
void *__cdecl xnmalloc(unsigned int a1, unsigned int a2)
{
  void *result; // eax

  if ( 0xFFFFFFFF / a2 < a1 || (result = malloc(a2 * a1)) == 0 )
    xalloc_die();
  return result;
}

//----- (08049DC0) --------------------------------------------------------
void _libc_csu_fini(void)
{
  term_proc(0);
}

//----- (08049E30) --------------------------------------------------------
void __fastcall _libc_csu_init(int a1, int a2)
{
  init_proc(a1, a2);
}

//----- (08049E90) --------------------------------------------------------
int __cdecl atexit(void (__cdecl *lpfunc)(void *))
{
  void *v1; // eax

  v1 = 0;
  if ( &_dso_handle )
    v1 = (void *)_dso_handle;
  return __cxa_atexit(lpfunc, 0, v1);
}

//----- (08049ED0) --------------------------------------------------------
int __fastcall _do_global_ctors_aux(int a1, int a2)
{
  void (**v2)(void); // ebx
  void (*v3)(void); // eax

  v2 = (void (**)(void))&_CTOR_LIST__;
  v3 = (void (*)(void))_CTOR_LIST__;
  if ( _CTOR_LIST__ != -1 )
  {
    do
    {
      --v2;
      v3();
      v3 = *v2;
    }
    while ( *v2 != (void (*)(void))-1 );
  }
  return a2;
}
// 804B660: using guessed type int _CTOR_LIST__;

//----- (08049EF4) --------------------------------------------------------
int *__usercall term_proc@<eax>(int *a1@<eax>)
{
  return _do_global_dtors_aux(a1);
}

// nfuncs=104 queued=43 decompiled=43 lumina nreq=0 worse=0 better=0
// ALL OK, 43 function(s) have been successfully decompiled
