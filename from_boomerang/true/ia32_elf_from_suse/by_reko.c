// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

FILE * stdout = &g_t10097000; // 0804B800
byte g_b804B804 = 0x00; // 0804B804
Eq_269 file_name = 0x00; // 0804B808
void g_v804B820 = ??void??; // 0804B820
<anonymous> * g_a804B828[] = // 0804B828
	{
	};
word32 g_dw804B920 = 0x00; // 0804B920
<anonymous> * xalloc_fail_func = null; // 0804B944
word32 program_name = 0x00; // 0804B948
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804B660 = &g_tFFFFFFFF; // 0804B660
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> ** g_ptr804B7D0 = &g_ptr804B66C; // 0804B7D0
int32 exit_failure = 1; // 0804B7D4
Eq_1230 (* nslots.1)[] = &g_a0001; // 0804B7D8
Eq_1230 g_t804B7DC = // 0804B7DC
	{
		0x0100,
		0x0804B7DC,
	};
Eq_1234 g_t804B7E0 = // 0804B7E0
	{
		0x0804A3C4,
	};
Eq_1230 (* slotvec.3)[] = &g_a804B7DC; // 0804B7E4
char * version_etc_copyright = &g_str804A3C4; // 0804B7E8
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804B66C = null; // 0804B66C
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049EF4: void _fini()
// Called from:
//      __libc_csu_fini
void _fini()
{
	__do_global_dtors_aux();
}

// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804B748 = null; // 0804B748
void ** g_ptr804B74C = null; // 0804B74C
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080487B0: void _init(Register word32 ecx, Register word32 edx)
// Called from:
//      __libc_csu_init
void _init(word32 ecx, word32 edx)
{
	call_gmon_start(edx);
	__do_global_ctors_aux(frame_dummy(ecx));
}

// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw804B670 = 0x00; // 0804B670
// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080487D8: void __fpending()
void __fpending()
{
}

// 080487E8: void __overflow()
void __overflow()
{
}

// 080487F8: void fputs_unlocked()
void fputs_unlocked()
{
}

// 08048808: void fprintf()
void fprintf()
{
}

// 08048818: void getenv()
void getenv()
{
}

// 08048828: void dcgettext()
void dcgettext()
{
}

// 08048838: void setlocale()
void setlocale()
{
}

// 08048848: void __cxa_atexit()
void __cxa_atexit()
{
}

// 08048858: void __errno_location()
void __errno_location()
{
}

// 08048868: void malloc()
void malloc()
{
}

// 08048878: void abort()
void abort()
{
}

// 08048888: void vfprintf()
void vfprintf()
{
}

// 08048898: void bindtextdomain()
void bindtextdomain()
{
}

// 080488A8: void strlen()
void strlen()
{
}

// 080488B8: void mbrtowc()
void mbrtowc()
{
}

// 080488C8: void __libc_start_main()
void __libc_start_main()
{
}

// 080488D8: void realloc()
void realloc()
{
}

// 080488E8: void textdomain()
void textdomain()
{
}

// 080488F8: void printf()
void printf()
{
}

// 08048908: void memcpy()
void memcpy()
{
}

// 08048918: void fclose()
void fclose()
{
}

// 08048928: void __ctype_get_mb_cur_max()
void __ctype_get_mb_cur_max()
{
}

// 08048938: void exit()
void exit()
{
}

// 08048948: void calloc()
void calloc()
{
}

// 08048958: void iswprint()
void iswprint()
{
}

// 08048968: void free()
void free()
{
}

// 08048978: void memset()
void memset()
{
}

// 08048988: void mbsinit()
void mbsinit()
{
}

// 08048998: void error()
void error()
{
}

// 080489A8: void __ctype_b_loc()
void __ctype_b_loc()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _fp_hw = 0x03; // 08049F20
word32 _IO_stdin_used = 0x00020001; // 08049F24
char g_str8049F28[] = "Usage: %s [ignored command line arguments]\n  or:  %s OPTION\nExit with a status code indicating success.\n\nThese option names may not be abbreviated.\n\n"; // 08049F28
char g_str8049FC0[] = "      --help     display this help and exit\n"; // 08049FC0
char g_str8049FF0[] = "      --version  output version information and exit\n"; // 08049FF0
char g_str804A026[] = "\nReport bugs to <%s>.\n"; // 0804A026
char g_str804A03C[] = ""; // 0804A03C
char g_str804A053[] = "/usr/share/locale"; // 0804A053
char g_str804A065[] = "POSIXLY_CORRECT"; // 0804A065
byte g_b804A075 = 0x2D; // 0804A075
byte g_b804A07C = 0x2D; // 0804A07C
char g_str804A093[] = "5.2.1"; // 0804A093
char g_str804A099[] = "GNU coreutils"; // 0804A099
char g_str804A09D[] = "coreutils"; // 0804A09D
char g_str804A0A7[] = "true"; // 0804A0A7
char g_str804A0AC[] = "write error"; // 0804A0AC
char g_str804A0B8[] = "%s: %s"; // 0804A0B8
char g_str804A0BC[] = "%s"; // 0804A0BC
char g_str804A3BC[] = "\""; // 0804A3BC
char g_str804A3BE[] = "`"; // 0804A3BE
char g_str804A3C0[] = "'"; // 0804A3C0
char g_str804A3C4[] = "Copyright (C) 2004 Free Software Foundation, Inc."; // 0804A3C4
char g_str804A3F8[] = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"; // 0804A3F8
char g_str804A434[] = "This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"; // 0804A434
char g_str804A4CC[] = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"; // 0804A4CC
char g_str804A500[] = "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"; // 0804A500
char g_str804A530[] = "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"; // 0804A530
char g_str804A55C[] = "Written by %s, %s, %s,\n%s, %s, and %s.\n"; // 0804A55C
char g_str804A584[] = "Written by %s, %s, %s,\n%s, and %s.\n"; // 0804A584
char g_str804A5A8[] = "Written by %s, %s, %s,\nand %s.\n"; // 0804A5A8
char g_str804A5C8[] = "%s (%s) %s\n"; // 0804A5C8
char g_str804A5D4[] = "Written by %s, %s, and %s.\n"; // 0804A5D4
char g_str804A5F0[] = "Written by %s and %s.\n"; // 0804A5F0
char g_str804A607[] = "Written by %s.\n"; // 0804A607
char g_str804A617[] = "%s %s\n"; // 0804A617
char g_str804A648[] = "memory exhausted"; // 0804A648
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080489C0: void _start(Register (ptr32 Eq_16) edx, Stack int32 dwArg00)
void _start(void (* edx)(), int32 dwArg00)
{
	__align((char *) fp + 4);
	__libc_start_main(&g_t8048B60, dwArg00, (char *) fp + 4, &g_t8049E30, &g_t8049DC0, edx, fp);
	__hlt();
}

// 080489E4: void call_gmon_start(Register word32 edx)
// Called from:
//      _init
void call_gmon_start(word32 edx)
{
	<anonymous> * eax_16 = g_ptr804B748;
	if (eax_16 != null)
		eax_16();
}

// 08048A10: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	if (g_b804B804 == 0x00)
	{
		<anonymous> ** eax_15 = g_ptr804B7D0;
		<anonymous> * edx_16 = *eax_15;
		while (edx_16 != null)
		{
			<anonymous> ** eax_23 = (char *) eax_15 + 4;
			g_ptr804B7D0 = eax_23;
			edx_16();
			eax_15 = g_ptr804B7D0;
			edx_16 = (<anonymous> *) *eax_15;
		}
		g_b804B804 = 0x01;
	}
}

// 08048A50: Register word32 frame_dummy(Register word32 ecx)
// Called from:
//      _init
word32 frame_dummy(word32 ecx)
{
	word32 edx_13 = g_dw804B670;
	return edx_13;
}

// 08048A80: void usage(Stack int32 dwArg04)
// Called from:
//      main
void usage(int32 dwArg04)
{
	printf(dcgettext(null, "Usage: %s [ignored command line arguments]\n  or:  %s OPTION\nExit with a status code indicating success.\n\nThese option names may not be abbreviated.\n\n", 0x05), 0x00);
	fputs_unlocked(dcgettext(null, "      --help     display this help and exit\n", 0x05), stdout);
	fputs_unlocked(dcgettext(null, "      --version  output version information and exit\n", 0x05), stdout);
	printf(dcgettext(null, "\nReport bugs to <%s>.\n", 0x05), 0x00);
	exit(dwArg04);
}

// 08048B60: void main(Stack word32 dwArg04, Stack (ptr32 Eq_130) dwArg08)
void main(word32 dwArg04, struct Eq_130 * dwArg08)
{
	__align(fp - 44);
	program_name = dwArg08->dw0000;
	setlocale(0x06, "");
	bindtextdomain("coreutils", "/usr/share/locale");
	textdomain("coreutils");
	atexit(&g_t8048C80);
	if (dwArg04 == 0x02)
	{
		char * eax_40 = getenv("POSIXLY_CORRECT");
		bool v22_113 = eax_40 != null;
		bool v18_109 = eax_40 == null;
		if (eax_40 == null)
		{
			byte * eax_45 = dwArg08->ptr0004;
			byte * edi_46 = &g_b804A075;
			byte * esi_48 = eax_45;
			word32 ecx_50 = 0x07;
			while (ecx_50 != 0x00)
			{
				v22_113 = *esi_144 != *edi_145;
				v18_109 = *esi_144 == *edi_145;
				esi_48 = esi_144 + 1;
				edi_46 = edi_145 + 1;
				--ecx_50;
				esi_144 = esi_48;
				edi_145 = edi_46;
				if (*esi_144 == *edi_145)
					break;
			}
			if (v18_109)
				usage(0x00);
			byte * esi_69 = eax_45;
			byte * edi_71 = &g_b804A07C;
			word32 ecx_72 = 0x0A;
			while (ecx_72 != 0x00)
			{
				v22_113 = *esi_146 != *edi_147;
				esi_69 = esi_146 + 1;
				edi_71 = edi_147 + 1;
				--ecx_72;
				esi_146 = esi_69;
				edi_147 = edi_71;
				if (*esi_146 == *edi_147)
					break;
			}
			if (!v22_113)
				version_etc(stdout, "true", "GNU coreutils", "5.2.1");
		}
	}
	exit(0x00);
}

// 08048C70: void close_stdout_set_file_name(Stack Eq_269 dwArg04)
void close_stdout_set_file_name(Eq_269 dwArg04)
{
	file_name = dwArg04;
}

// 08048C80: void close_stdout()
void close_stdout()
{
	FILE * edx_15 = stdout;
	int32 ebx_21 = 0x00 - ((*edx_15 >> 0x05 & 0x01) < 0x01);
	if (ebx_21 != 0x00)
	{
		if (__fpending(edx_15) == 0x00)
			return;
		edx_15 = stdout;
	}
	if (fclose(edx_15) != 0x00)
		ebx_21 = *__errno_location();
	if (ebx_21 < 0x00)
		return;
	dcgettext(null, "write error", 0x05);
	Eq_269 eax_53 = file_name;
	if (eax_53 == 0x00)
		error(exit_failure, ebx_21, "%s", 0x00);
	else
	{
		quotearg_colon(eax_53);
		error(exit_failure, ebx_21, "%s: %s", 0x00);
	}
}

// 08048D50: void get_quoting_style(Stack word32 dwArg04)
void get_quoting_style(word32 dwArg04)
{
	if (dwArg04 == 0x00)
		;
}

// 08048D70: void set_quoting_style(Stack (ptr32 word32) dwArg04, Stack word32 dwArg08)
void set_quoting_style(word32 * dwArg04, word32 dwArg08)
{
	if (dwArg04 == null)
		g_dw804B920 = dwArg08;
	else
		*dwArg04 = dwArg08;
}

// 08048D90: void set_char_quoting(Stack ptr32 dwArg04, Stack byte bArg08, Stack ui32 dwArg0C)
// Called from:
//      quotearg_char
void set_char_quoting(ptr32 dwArg04, byte bArg08, ui32 dwArg0C)
{
	ui32 ecx_16 = (word32) bArg08;
	ui32 edx_20 = (word32) ((byte) ecx_16 >> 0x05);
	int32 * esi_24 = (edx_20 << 0x02) + 0x04 + dwArg04;
	if (dwArg04 == 0x00)
	{
		int32 * esi_26 = (edx_20 << 0x02) + 0x0804B924;
		int32 edx_27 = *esi_26;
		byte cl_31 = (byte) (ecx_16 & 0x1F);
		*esi_26 = edx_27 ^ (dwArg0C & 0x01 ^ edx_27 >> cl_31 & 0x01) << cl_31;
	}
	else
	{
		int32 edx_46 = *esi_24;
		byte cl_50 = (byte) (ecx_16 & 0x1F);
		*esi_24 = edx_46 ^ (dwArg0C & 0x01 ^ edx_46 >> cl_50 & 0x01) << cl_50;
	}
}

// 08048E00: void clone_quoting_options(Stack (ptr32 Eq_413) dwArg04)
void clone_quoting_options(struct Eq_413 * dwArg04)
{
	int32 * eax_16 = __errno_location();
	int32 esi_17 = *eax_16;
	struct Eq_421 * eax_20 = xmalloc(0x24);
	struct Eq_413 * edx_25 = dwArg04;
	if (dwArg04 == null)
		edx_25 = (struct Eq_413 *) &g_dw804B920;
	eax_20->dw0000 = edx_25->dw0000;
	eax_20->dw0004 = edx_25->dw0004;
	eax_20->dw0008 = edx_25->dw0008;
	eax_20->dw000C = edx_25->dw000C;
	eax_20->dw0010 = edx_25->dw0010;
	eax_20->dw0014 = edx_25->dw0014;
	eax_20->dw0018 = edx_25->dw0018;
	eax_20->dw001C = edx_25->dw001C;
	eax_20->dw0020 = edx_25->dw0020;
	*eax_16 = esi_17;
}

// 08048E70: void quoting_options_from_style(Register (ptr32 Eq_488) eax, Register word32 edx)
// Called from:
//      quotearg_n_style_mem
//      quotearg_n_style
void quoting_options_from_style(struct Eq_488 * eax, word32 edx)
{
	word32 ecx_12;
	word32 * edi_24 = fp - 0x38;
	for (ecx_12 = 0x08; ecx_12 != 0x00; --ecx_12)
	{
		*edi_24 = 0x00;
		++edi_24;
	}
	eax->dw0000 = edx;
	eax->dw0004 = dwLoc38;
	eax->dw0008 = dwLoc34;
	eax->dw000C = dwLoc30;
	eax->dw0010 = dwLoc2C;
	eax->dw0014 = dwLoc28;
	eax->dw0018 = dwLoc24;
	eax->dw001C = dwLoc20;
	eax->dw0020 = dwLoc1C;
}

// 08048ED0: Register (ptr32 char) gettext_quote(Register (ptr32 char) eax, Register up32 edx)
// Called from:
//      quotearg_buffer_restyled
char * gettext_quote(char * eax, up32 edx)
{
	ui24 edx_24_8_31 = SLICE(edx, word24, 8);
	char * eax_21 = dcgettext(null, eax, 0x05);
	char * ecx_23 = eax_21;
	if (((byte) (SEQ(SLICE(eax_21, word24, 8), (int8) (edx == 0x06)) & SEQ(edx_24_8_31, (int8) (eax_21 == eax))) & 0x01) != 0x00)
		ecx_23 = (char *) "\"";
	return ecx_23;
}

// 08048F20: void quotearg_buffer_restyled(Register size_t eax, Register size_t ecx, Register Eq_269 edx, Stack Eq_269 dwArg04, Stack up32 dwArg08, Stack size_t dwArg0C)
// Called from:
//      quotearg_buffer_restyled
//      quotearg_buffer
void quotearg_buffer_restyled(size_t eax, size_t ecx, Eq_269 edx, Eq_269 dwArg04, up32 dwArg08, size_t dwArg0C)
{
	size_t dwLoc70_1004 = 0x00;
	size_t dwLoc3C_1374 = 0x00;
	Eq_269 dwLoc40_1576 = 0x00;
	word32 dwLoc44_1565 = 0x00;
	word32 eax_33 = (word32) (int8) (__ctype_get_mb_cur_max() == 0x01);
	if (dwArg08 <= 0x06)
	{
		switch (dwArg08)
		{
		case 0x00:
		case 0x01:
			break;
		case 0x02:
			if (edx > 0x00)
				*eax = (Eq_269) 0x27;
			dwLoc3C_1374 = 0x0804A3C0;
			goto l08048F90;
		case 0x03:
			if (edx > 0x00)
				*eax = (Eq_269) 0x22;
			dwLoc44_1565 = 0x01;
			dwLoc3C_1374 = 0x0804A3BC;
l08048F90:
			dwLoc70_1004 = 0x01;
			dwLoc40_1576 = 0x01;
			break;
		case 0x04:
			dwLoc44_1565 = 0x01;
			break;
		case 0x05:
		case 0x06:
			size_t eax_44 = gettext_quote("`", dwArg08);
			Eq_269 eax_54 = gettext_quote("'", dwArg08);
			size_t dwLoc3C_891 = eax_44;
			if (*eax_44 != 0x00)
			{
				do
				{
					if (dwLoc70_1004 < edx)
						Mem73[dwLoc70_1004 + eax:byte] = Mem64[dwLoc3C_891 + 0x00:byte];
					size_t v20_76 = (word32) dwLoc3C_891 + 1;
					dwLoc3C_891 = v20_76;
					dwLoc70_1004 = (Eq_269) ((word32) dwLoc70_1004 + 1);
				} while (*v20_76 != 0x00);
			}
			dwLoc44_1565 = 0x01;
			dwLoc3C_1374 = eax_54;
			dwLoc40_1576 = strlen(eax_54);
			break;
		}
	}
	size_t dwLoc38_1005 = 0x00;
l08048FA0:
	if (dwArg04 != ~0x00)
	{
		if (dwLoc38_1005 != dwArg04)
		{
l08048FB6:
			if (dwLoc44_1565 != 0x00 && (dwLoc40_1576 != 0x00 && dwLoc38_1005 + dwLoc40_1576 <=u dwArg04))
			{
				Eq_269 ecx_214 = dwLoc40_1576;
				Eq_269 edi_215 = dwLoc3C_1374;
				word32 esi_217 = ecx + dwLoc38_1005;
				bool v55_873 = false;
				while (ecx_214 != 0x00)
				{
					v55_873 = *esi_1853 != *edi_1854;
					esi_217 = esi_1853 + 1;
					edi_215 = (Eq_269) ((word32) edi_1854 + 1);
					--ecx_214;
					esi_1853 = esi_217;
					edi_1854 = edi_215;
					if (*esi_1853 == *edi_1854)
						break;
				}
				if (!v55_873)
				{
					if (dwLoc70_1004 < edx)
						Mem239[dwLoc70_1004 + eax:byte] = 0x5C;
					dwLoc70_1004 = (Eq_269) ((word32) dwLoc70_1004 + 1);
				}
			}
			Eq_269 edx_436;
			byte bl_253 = Mem249[dwLoc38_1005 + ecx:byte];
			up32 eax_254 = (word32) bl_253;
			Eq_622 bLoc5C_1105 = bl_253;
			if (eax_254 <= 0x7E)
			{
				Eq_622 al_358;
				switch (eax_254)
				{
				case 0x00:
					edx_436 = (Eq_269) ((word32) dwLoc38_1005 + 1);
					if (dwLoc44_1565 == 0x00)
						goto l08049290;
					if (dwLoc70_1004 < edx)
						Mem674[dwLoc70_1004 + eax:byte] = 0x5C;
					word32 v30_677 = dwLoc70_1004 + 0x01;
					if (v30_677 < edx)
						Mem684[v30_677 + eax:byte] = 0x30;
					if (v30_677 + 0x01 <u edx)
						Mem694[v30_677 + 0x01 + eax:byte] = 0x30;
					dwLoc70_1004 = v30_677 + 0x02;
					bLoc5C_1105 = (Eq_622) 0x30;
					goto l08049240;
				case 0x01:
				case 0x02:
				case 0x03:
				case 0x04:
				case 0x05:
				case 0x06:
				case 0x0E:
				case 0x0F:
				case 0x10:
				case 0x11:
				case 0x12:
				case 0x13:
				case 0x14:
				case 0x15:
				case 22:
				case 0x17:
				case 0x18:
				case 0x19:
				case 0x1A:
				case 0x1B:
				case 0x1C:
				case 0x1D:
				case 0x1E:
				case 0x1F:
				case 0x40:
					goto l08049020;
				case 0x07:
					al_358 = (Eq_622) 0x61;
					break;
				case 0x08:
					al_358 = (Eq_622) 0x62;
					break;
				case 0x09:
					al_358 = (Eq_622) 116;
					goto l080492B4;
				case 0x0A:
					al_358 = (Eq_622) 110;
					goto l080492B4;
				case 11:
					al_358 = (Eq_622) 118;
					break;
				case 0x0C:
					al_358 = (Eq_622) 0x66;
					break;
				case 0x0D:
					al_358 = (Eq_622) 114;
					if (dwArg08 == 0x01)
						goto l08049386;
					break;
				case 0x20:
				case 33:
				case 0x22:
				case 0x24:
				case 0x26:
				case 0x28:
				case 0x29:
				case 0x2A:
				case 0x3B:
				case 0x3C:
				case 0x3E:
				case 0x5B:
				case 0x5E:
				case 0x60:
				case 0x7C:
					goto l08049234;
				case 0x23:
				case 0x7E:
					if (dwLoc38_1005 != 0x00)
						goto l08049240;
l08049234:
					if (dwArg08 != 0x01)
						goto l08049240;
					goto l08049386;
				case 0x25:
				case 0x2B:
				case 44:
				case 0x2D:
				case 0x2E:
				case 0x2F:
				case 0x30:
				case 0x31:
				case 0x32:
				case 0x33:
				case 0x34:
				case 0x35:
				case 0x36:
				case 55:
				case 0x38:
				case 0x39:
				case 0x3A:
				case 0x3D:
				case 0x41:
				case 66:
				case 0x43:
				case 0x44:
				case 0x45:
				case 0x46:
				case 0x47:
				case 0x48:
				case 0x49:
				case 0x4A:
				case 0x4B:
				case 0x4C:
				case 77:
				case 0x4E:
				case 0x4F:
				case 0x50:
				case 0x51:
				case 0x52:
				case 0x53:
				case 0x54:
				case 0x55:
				case 0x56:
				case 0x57:
				case 88:
				case 0x59:
				case 0x5A:
				case 0x5D:
				case 0x5F:
				case 0x61:
				case 0x62:
				case 99:
				case 100:
				case 101:
				case 0x66:
				case 0x67:
				case 0x68:
				case 0x69:
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
				case 110:
				case 111:
				case 0x70:
				case 113:
				case 114:
				case 115:
				case 116:
				case 117:
				case 118:
				case 0x77:
				case 0x78:
				case 121:
				case 122:
				case 0x7B:
				case 0x7D:
					goto l08049240;
				case 0x27:
					if (dwArg08 == 0x01)
						goto l08049386;
					if (dwArg08 == 0x02)
					{
						if (dwLoc70_1004 < edx)
							Mem319[dwLoc70_1004 + eax:byte] = 0x27;
						word32 v25_322 = dwLoc70_1004 + 0x01;
						if (v25_322 < edx)
							Mem329[v25_322 + eax:byte] = 0x5C;
						if (v25_322 + 0x01 <u edx)
							Mem339[v25_322 + 0x01 + eax:byte] = 0x27;
l08049372:
						dwLoc70_1004 += 0x03;
					}
					goto l08049240;
				case 0x3F:
					if (dwArg08 == 0x01)
						goto l08049386;
					if (dwArg08 == 0x03 && ((word32) dwLoc38_1005 + 2 < dwArg04 && *((word32) ecx + ((word32) dwLoc38_1005 + 1)) == 0x3F))
					{
						Eq_622 cl_273 = *((word32) ecx + ((word32) dwLoc38_1005 + 2));
						Eq_786 eax_274 = (int32) cl_273;
						if (eax_274 <= 0x3E)
						{
							switch (eax_274)
							{
							case 33:
							case 0x27:
							case 0x28:
							case 0x29:
							case 0x2D:
							case 0x2F:
							case 0x3C:
							case 0x3D:
							case 0x3E:
								bLoc5C_1105 = cl_273;
								dwLoc38_1005 = (Eq_269) ((word32) dwLoc38_1005 + 2);
								if (dwLoc70_1004 < edx)
									Mem288[dwLoc70_1004 + eax:byte] = 0x3F;
								word32 v26_291 = dwLoc70_1004 + 0x01;
								if (v26_291 < edx)
									Mem298[v26_291 + eax:byte] = 0x5C;
								if (v26_291 + 0x01 <u edx)
									Mem308[v26_291 + 0x01 + eax:byte] = 0x3F;
								goto l08049372;
							case 0x22:
							case 0x23:
							case 0x24:
							case 0x25:
							case 0x26:
							case 0x2A:
							case 0x2B:
							case 44:
							case 0x2E:
							case 0x30:
							case 0x31:
							case 0x32:
							case 0x33:
							case 0x34:
							case 0x35:
							case 0x36:
							case 55:
							case 0x38:
							case 0x39:
							case 0x3A:
							case 0x3B:
								break;
							}
						}
					}
					goto l08049240;
				case 0x5C:
					al_358 = bl_253;
l080492B4:
					if (dwArg08 == 0x01)
					{
l08049386:
						quotearg_buffer_restyled(eax, ecx, edx, dwArg04, 0x02, dwArg0C);
						return;
					}
					break;
				}
				edx_436 = (Eq_269) ((word32) dwLoc38_1005 + 1);
				if (dwLoc44_1565 != 0x00)
				{
					bLoc5C_1105 = al_358;
l0804926B:
					if (dwLoc70_1004 < edx)
						Mem730[dwLoc70_1004 + eax:byte] = 0x5C;
					++dwLoc70_1004;
					edx_436 = (Eq_269) ((word32) dwLoc38_1005 + 1);
					goto l08049290;
				}
l08049290:
				if (dwLoc70_1004 < edx)
					Mem779[dwLoc70_1004 + eax:byte] = bLoc5C_1105;
				++dwLoc70_1004;
				dwLoc38_1005 = edx_436;
				goto l08048FA0;
			}
l08049020:
			ui32 dwLoc64_1117;
			Eq_721 dwLoc60_1116;
			ui24 edx_24_8_554;
			ui24 eax_24_8_547;
			if (eax_33 != 0x00)
			{
				ui32 eax_532 = (word32) *((char *) *__ctype_b_loc() + (word32) bl_253 * 0x02);
				dwLoc60_1116.u0 = 0x01;
				eax_24_8_547 = SLICE(eax_532 & 0x4000, word24, 8);
				dwLoc64_1117 = eax_532 & 0x4000;
			}
			else
			{
				dwLoc60_1116.u0 = 0x00;
				dwLoc64_1117 = 0x01;
				if (dwArg04 == ~0x00)
					dwArg04 = strlen(ecx);
				do
				{
					word32 ebx_469 = dwLoc38_1005 + dwLoc60_1116;
					word32 eax_473 = ecx + ebx_469;
					Eq_269 eax_477 = mbrtowc(fp - 0x28, eax_473, dwArg04 - ebx_469, fp - 0x24);
					edx_24_8_554 = SLICE(fp - 0x28, word24, 8);
					eax_24_8_547 = SLICE(eax_477, word24, 8);
					if (eax_477 == 0x00)
						break;
					if (eax_477 == ~0x00)
					{
						dwLoc64_1117 = 0x00;
						break;
					}
					if (eax_477 == ~0x01)
					{
						dwLoc64_1117 = 0x00;
						if (ebx_469 < dwArg04 && *eax_473 != 0x00)
						{
							do
							{
								Eq_721 v43_495 = (word32) dwLoc60_1116.u0 + 1;
								word32 eax_499 = dwLoc38_1005 + v43_495;
								dwLoc60_1116 = v43_495;
								eax_24_8_547 = SLICE(eax_499, word24, 8);
							} while (eax_499 < dwArg04 && Mem496[eax_499 + ecx:byte] != 0x00);
						}
						break;
					}
					dwLoc64_1117 &= -(word32) (int8) (iswprint(dwLoc28) != 0x00);
					int32 eax_520 = mbsinit(fp - 0x24);
					dwLoc60_1116 += eax_477;
					eax_24_8_547 = SLICE(eax_520, word24, 8);
				} while (eax_520 == 0x00);
				if (dwLoc60_1116 > 0x01)
				{
l08049063:
					ui24 eax_24_8_577 = SLICE(dwLoc60_1116, word24, 8);
					word32 ecx_565 = dwLoc38_1005 + dwLoc60_1116;
					while (true)
					{
						if (((byte) (SEQ(eax_24_8_577, (int8) (dwLoc44_1565 != 0x00)) & SEQ(edx_24_8_554, (int8) (dwLoc64_1117 == 0x00))) & 0x01) != 0x00)
						{
							if (dwLoc70_1004 < edx)
								Mem591[dwLoc70_1004 + eax:byte] = 0x5C;
							word32 v35_594 = dwLoc70_1004 + 0x01;
							if (v35_594 < edx)
								Mem606[v35_594 + eax:byte] = (bLoc5C_1105 >>u 0x06) + 0x30;
							if (v35_594 + 0x01 <u edx)
								Mem622[v35_594 + 0x01 + eax:byte] = (bLoc5C_1105 >>u 0x03 & 0x07) + 0x30;
							dwLoc70_1004 = v35_594 + 0x02;
							bLoc5C_1105 = (bLoc5C_1105 & 0x07) + 0x30;
						}
						edx_436 = (Eq_269) ((word32) dwLoc38_1005 + 1);
						edx_24_8_554 = SLICE((word32) dwLoc38_1005 + 1, word24, 8);
						if (ecx_565 <= (word32) dwLoc38_1005 + 1)
							break;
						if (dwLoc70_1004 < edx)
							Mem651[dwLoc70_1004 + eax:byte] = bLoc5C_1105;
						word32 eax_660 = (word32) *((word32) ecx + ((word32) dwLoc38_1005 + 1));
						++dwLoc70_1004;
						dwLoc38_1005 = (Eq_269) ((word32) dwLoc38_1005 + 1);
						eax_24_8_577 = SLICE(eax_660, word24, 8);
						bLoc5C_1105 = (byte) eax_660;
					}
					goto l08049290;
				}
			}
			edx_24_8_554 = SLICE(dwLoc64_1117, word24, 8);
			if (((byte) (SEQ(eax_24_8_547, (int8) (dwLoc44_1565 != 0x00)) & SEQ(edx_24_8_554, (int8) (dwLoc64_1117 == 0x00))) & 0x01) == 0x00)
			{
l08049240:
				edx_436 = (Eq_269) ((word32) dwLoc38_1005 + 1);
				if (dwLoc44_1565 == 0x00 || ((byte) (*((word32) dwArg0C + ((word32) (bLoc5C_1105 >> 0x05) * 0x04 + 4)) >> (byte) ((word32) bLoc5C_1105 & 0x1F)) & 0x01) == 0x00)
					goto l08049290;
				goto l0804926B;
			}
			goto l08049063;
		}
	}
	else if (Mem126[dwLoc38_1005 + ecx:byte] != 0x00)
		goto l08048FB6;
	if (dwLoc3C_1374 != 0x00)
	{
		Eq_622 al_144 = *dwLoc3C_1374;
		while (al_144 != 0x00)
		{
			if (dwLoc70_1004 < edx)
				Mem156[dwLoc70_1004 + eax:byte] = al_144;
			size_t v18_159 = (word32) dwLoc3C_1374 + 1;
			dwLoc3C_1374 = v18_159;
			++dwLoc70_1004;
			al_144 = (Eq_622) *v18_159;
		}
	}
	if (dwLoc70_1004 < edx)
		Mem176[dwLoc70_1004 + eax:byte] = 0x00;
}

// 08049560: void quotearg_buffer(Stack Eq_269 dwArg04, Stack Eq_269 dwArg08, Stack Eq_269 dwArg0C, Stack Eq_269 dwArg10, Stack Eq_269 dwArg14)
// Called from:
//      quotearg_n
void quotearg_buffer(Eq_269 dwArg04, Eq_269 dwArg08, Eq_269 dwArg0C, Eq_269 dwArg10, Eq_269 dwArg14)
{
	size_t edi_11 = dwArg14;
	if (dwArg14 == 0x00)
		edi_11 = 0x0804B920;
	int32 * eax_20 = __errno_location();
	int32 esi_22 = *eax_20;
	quotearg_buffer_restyled(dwArg04, dwArg0C, dwArg08, dwArg10, *edi_11, edi_11);
	*eax_20 = esi_22;
}

// 080495C0: Register ptr32 quotearg_n_options(Register (arr Eq_1230) eax, Register size_t edx)
// Called from:
//      quotearg_char
//      quotearg_n_style_mem
//      quotearg_n_style
//      quotearg_n
ptr32 quotearg_n_options(Eq_1230 eax[], size_t edx)
{
	word32 eax_25 = *__errno_location();
	if (eax < null)
		abort();
	else
	{
		if (nslots.1 <= eax)
		{
			if (eax > (Eq_1230 (*)[]) 0x1FFFFFFE)
			{
				xalloc_die();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_269 stackArg4 = <invalid>;
				byte stackArg8 = <invalid>;
				quotearg_char(stackArg4, stackArg8);
				return fp - 4;
			}
			if (slotvec.3 == &g_t804B7DC)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_269 stackArg4 = <invalid>;
				xmalloc(stackArg4);
				slotvec.3 = eax;
				Eq_1230 eax_47 = g_t804B7DC.dw0000;
				*((word32) &eax[0].dw0000 + 4) = (Eq_1230 (*)[]) g_t804B7E0;
				eax[0].dw0000 = (word32) eax_47;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_269 stackArg4 = <invalid>;
			Eq_269 stackArg8 = <invalid>;
			xrealloc(stackArg4, stackArg8);
			Eq_1230 eax_54[] = (eax + 0x01) * 0x08;
			slotvec.3 = eax_54;
			Eq_1230 (* eax_59)[] = nslots.1;
			word32 edx_61 = eax + 0x01 - eax_59;
			word32 * edi_147 = &(eax_54 + eax_59)->dw0000;
			uint32 eax_63 = edx_61 * 0x08;
			if (edx_61 * 0x08 > 0x07 && (edi_147 & 0x04) != 0x00)
			{
				*edi_147 = 0x00;
				eax_63 = edx_61 * 0x08 - 0x04;
				++edi_147;
			}
			uint32 ecx_150;
			for (ecx_150 = eax_63 >> 0x02; ecx_150 != 0x00; --ecx_150)
			{
				*edi_147 = 0x00;
				++edi_147;
			}
			Mem83[0x0804B7D8<p32>:word32] = eax + 0x01;
		}
		Eq_1230 eax_88[] = slotvec.3;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_269 esi_89 = eax_88[eax].dw0000;
		void * edi_90 = *((word32) &eax_88[eax].dw0000 + 4);
		Eq_269 stackArg4 = <invalid>;
		Eq_269 stackArg8 = <invalid>;
		Eq_269 stackArg12 = <invalid>;
		Eq_269 stackArg16 = <invalid>;
		Eq_269 stackArg20 = <invalid>;
		quotearg_buffer(stackArg4, stackArg8, stackArg12, stackArg16, stackArg20);
		if (esi_89 <= edx)
		{
			Eq_1230 ebx_103[] = slotvec.3;
			ebx_103[eax].dw0000 = (word32) edx + 1;
			if (edi_90 != &g_v804B820)
			{
				free(edi_90);
				ebx_103 = slotvec.3;
			}
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_269 stackArg4 = <invalid>;
			xmalloc(stackArg4);
			*((word32) &ebx_103[eax].dw0000 + 4) = (Eq_1230 (*)[]) edx;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_269 stackArg4 = <invalid>;
			Eq_269 stackArg8 = <invalid>;
			Eq_269 stackArg12 = <invalid>;
			Eq_269 stackArg16 = <invalid>;
			Eq_269 stackArg20 = <invalid>;
			quotearg_buffer(stackArg4, stackArg8, stackArg12, stackArg16, stackArg20);
		}
		*__errno_location() = eax_25;
		return ebp;
	}
}

// 08049750: void quotearg_char(Stack Eq_269 dwArg04, Stack byte bArg08)
// Called from:
//      quotearg_colon
//      quotearg_n
void quotearg_char(Eq_269 dwArg04, byte bArg08)
{
	set_char_quoting(fp - 0x3C, (byte) (int32) bArg08, 0x01);
	quotearg_n_options(null, dwArg04);
}

// 080497E0: void quotearg_colon(Stack Eq_269 dwArg04)
// Called from:
//      close_stdout
void quotearg_colon(Eq_269 dwArg04)
{
	quotearg_char(dwArg04, 0x3A);
}

// 08049800: void quotearg_n_style_mem(Stack (ptr32 (arr Eq_1230)) dwArg04, Stack word32 dwArg08, Stack Eq_269 dwArg0C)
void quotearg_n_style_mem(Eq_1230 (* dwArg04)[], word32 dwArg08, Eq_269 dwArg0C)
{
	quoting_options_from_style(fp - 0x3C, dwArg08);
	quotearg_n_options(dwArg04, dwArg0C);
}

// 08049830: void quotearg_n_style(Stack (ptr32 (arr Eq_1230)) dwArg04, Stack word32 dwArg08, Stack Eq_269 dwArg0C)
// Called from:
//      quotearg_style
void quotearg_n_style(Eq_1230 (* dwArg04)[], word32 dwArg08, Eq_269 dwArg0C)
{
	quoting_options_from_style(fp - 0x3C, dwArg08);
	quotearg_n_options(dwArg04, dwArg0C);
}

// 08049860: void quotearg_style(Stack word32 dwArg04, Stack Eq_269 dwArg08)
void quotearg_style(word32 dwArg04, Eq_269 dwArg08)
{
	quotearg_n_style(null, dwArg04, dwArg08);
}

// 08049890: Register word32 quotearg_n(Stack (ptr32 (arr Eq_1230)) dwArg04, Stack Eq_269 dwArg08)
// Called from:
//      quotearg
word32 quotearg_n(Eq_1230 (* dwArg04)[], Eq_269 dwArg08)
{
	return quotearg_n_options(dwArg04, dwArg08);
}

// 080498B0: void quotearg(Stack Eq_269 dwArg04)
void quotearg(Eq_269 dwArg04)
{
	quotearg_n(null, dwArg04);
}

// 080498D0: void version_etc_va(Stack (ptr32 Eq_99) dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 char) dwArg0C, Stack (ptr32 char) dwArg10, Stack Eq_1315 dwArg14)
// Called from:
//      version_etc
void version_etc_va(FILE * dwArg04, char * dwArg08, char * dwArg0C, char * dwArg10, Eq_1315 dwArg14)
{
	up32 ebx_18 = 0x00;
	word32 * edx_25 = (word32) dwArg14 + 4;
	if (*dwArg14 != 0x00)
	{
		do
		{
			++ebx_18;
			edx_25 = edx_281 + 1;
			edx_281 = edx_25;
		} while (*edx_281 != 0x00);
	}
	if (dwArg08 != null)
		fprintf(dwArg04, "%s (%s) %s\n", dwArg08, dwArg0C, dwArg10);
	else
		fprintf(dwArg04, "%s %s\n", dwArg0C, dwArg10);
	char * dwLoc28_209;
	char * eax_100;
	if (ebx_18 <= 0x09)
	{
		switch (ebx_18)
		{
		case 0x00:
			abort();
		case 0x01:
			eax_100 = (char *) "Written by %s.\n";
			break;
		case 0x02:
			dwLoc28_209 = (char *) "Written by %s and %s.\n";
			goto l08049955;
		case 0x03:
			eax_100 = (char *) "Written by %s, %s, and %s.\n";
			break;
		case 0x04:
			eax_100 = (char *) "Written by %s, %s, %s,\nand %s.\n";
			break;
		case 0x05:
			eax_100 = (char *) "Written by %s, %s, %s,\n%s, and %s.\n";
			break;
		case 0x06:
			dwLoc28_209 = (char *) "Written by %s, %s, %s,\n%s, %s, and %s.\n";
			goto l08049955;
		case 0x07:
			dwLoc28_209 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n";
			goto l08049955;
		case 0x08:
			eax_100 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n";
			break;
		case 0x09:
			eax_100 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
			break;
		}
	}
	else
		eax_100 = (char *) "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
	dwLoc28_209 = eax_100;
l08049955:
	vfprintf(dwArg04, dcgettext(null, dwLoc28_209, 0x05), dwArg14);
	byte * eax_127 = dwArg04->ptr0014;
	if (eax_127 < dwArg04->ptr0018)
	{
		*eax_127 = 0x0A;
		++dwArg04->ptr0014;
	}
	else
		__overflow(dwArg04, 0x0A);
	fputs_unlocked(version_etc_copyright, dwArg04);
	byte * eax_144 = dwArg04->ptr0014;
	if (eax_144 < dwArg04->ptr0018)
	{
		*eax_144 = 0x0A;
		++dwArg04->ptr0014;
	}
	else
		__overflow(dwArg04, 0x0A);
	fputs_unlocked(dcgettext(null, "This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 0x05), dwArg04);
}

// 08049AF0: void version_etc(Stack (ptr32 Eq_99) dwArg04, Stack (ptr32 char) dwArg08, Stack (ptr32 char) dwArg0C, Stack (ptr32 char) dwArg10)
// Called from:
//      main
void version_etc(FILE * dwArg04, char * dwArg08, char * dwArg0C, char * dwArg10)
{
	version_etc_va(dwArg04, dwArg08, dwArg0C, dwArg10, fp + 0x14);
}

// 08049B20: void xalloc_die()
// Called from:
//      quotearg_n
//      xcalloc
//      x2realloc
//      x2nrealloc
//      xnrealloc
//      xmalloc
//      xnmalloc
void xalloc_die()
{
	<anonymous> * eax_9 = xalloc_fail_func;
	if (eax_9 != null)
		eax_9();
	dcgettext(null, "memory exhausted", 0x05);
	error(exit_failure, 0x00, "%s", 0x00);
	abort();
}

// 08049B80: void xcalloc(Stack Eq_269 dwArg04, Stack Eq_269 dwArg08)
void xcalloc(Eq_269 dwArg04, Eq_269 dwArg08)
{
	if ((uint32) (0xFFFFFFFF /u dwArg08) >= dwArg04 && calloc(dwArg04, dwArg08) != null)
		return;
	xalloc_die();
}

// 08049BC0: void xrealloc(Stack Eq_269 dwArg04, Stack Eq_269 dwArg08)
// Called from:
//      quotearg_n
//      xcalloc
//      x2realloc
//      x2nrealloc
void xrealloc(Eq_269 dwArg04, Eq_269 dwArg08)
{
	if (realloc(dwArg04, dwArg08) != null)
		return;
	xalloc_die();
}

// 08049BF0: void x2realloc(Stack Eq_269 dwArg04, Stack (ptr32 Eq_269) dwArg08)
// Called from:
//      x2nrealloc
void x2realloc(Eq_269 dwArg04, size_t * dwArg08)
{
	Eq_269 eax_13 = *dwArg08;
	if (dwArg04 != 0x00)
	{
		if (eax_13 < 0x00)
			xalloc_die();
		eax_13 *= 0x02;
	}
	else if (eax_13 == 0x00)
		eax_13 = 0x40;
	*dwArg08 = (uint32) eax_13;
	xrealloc(dwArg04, eax_13);
}

// 08049C30: void x2nrealloc(Stack Eq_269 dwArg04, Stack (ptr32 Eq_1513) dwArg08, Stack Eq_1512 dwArg0C)
// Called from:
//      x2realloc
void x2nrealloc(Eq_269 dwArg04, union Eq_1513 * dwArg08, Eq_1512 dwArg0C)
{
	Eq_1513 ecx_19 = *dwArg08;
	if (dwArg04 != 0x00)
	{
		if ((uint32) (0x7FFFFFFF /u dwArg0C) < ecx_19)
			xalloc_die();
		ecx_19 *= 0x02;
	}
	else if (ecx_19 == 0x00)
	{
		uint32 eax_30 = (uint32) (0x40 /u dwArg0C);
		ecx_19 = eax_30 + (uint32) ((int8) (eax_30 == 0x00));
	}
	*dwArg08 = (union Eq_1513 *) ecx_19;
	Eq_269 ecx_54 = ecx_19 *s dwArg0C;
	xrealloc(dwArg04, ecx_54);
}

// 08049CA0: void xnrealloc(Stack Eq_269 dwArg04, Stack Eq_1546 dwArg08, Stack Eq_1547 dwArg0C)
// Called from:
//      x2nrealloc
void xnrealloc(Eq_269 dwArg04, Eq_1546 dwArg08, Eq_1547 dwArg0C)
{
	if ((uint32) (0xFFFFFFFF /u dwArg0C) >= dwArg08 && realloc(dwArg04, dwArg08 *s dwArg0C) != null)
		return;
	xalloc_die();
}

// 08049CF0: Register (ptr32 void) xmalloc(Stack Eq_269 dwArg04)
// Called from:
//      clone_quoting_options
//      quotearg_n
//      xnrealloc
//      xclone
//      xzalloc
void * xmalloc(Eq_269 dwArg04)
{
	void * eax_11 = malloc(dwArg04);
	if (eax_11 != null)
		return eax_11;
	xalloc_die();
}

// 08049D20: void xclone(Stack (ptr32 void) dwArg04, Stack Eq_269 dwArg08)
// Called from:
//      xmalloc
void xclone(void * dwArg04, Eq_269 dwArg08)
{
	memcpy(xmalloc(dwArg08), dwArg04, dwArg08);
}

// 08049D50: void xzalloc(Stack Eq_269 dwArg04)
void xzalloc(Eq_269 dwArg04)
{
	memset(xmalloc(dwArg04), 0x00, dwArg04);
}

// 08049D80: void xnmalloc(Stack Eq_1589 dwArg04, Stack Eq_1590 dwArg08)
void xnmalloc(Eq_1589 dwArg04, Eq_1590 dwArg08)
{
	if ((uint32) (0xFFFFFFFF /u dwArg08) >= dwArg04 && malloc(dwArg04 *s dwArg08) != null)
		return;
	xalloc_die();
}

// 08049DC0: void __libc_csu_fini()
// Called from:
//      xnmalloc
void __libc_csu_fini()
{
	int32 eax_19 = 0x0804B828 - 0x0804B828;
	int32 esi_23 = (eax_19 >> 0x02) - 0x01;
	if (eax_19 >> 0x02 != 0x00)
	{
		do
		{
			(*((char *) g_a804B828 + esi_89 * 0x04))();
			esi_23 = esi_89 - 0x01;
			esi_89 = esi_23;
		} while (esi_89 != 0x00);
		_fini();
	}
	else
		_fini();
}

// 08049E30: void __libc_csu_init(Register word32 ecx, Register word32 edx)
void __libc_csu_init(word32 ecx, word32 edx)
{
	_init(ecx, edx);
	int32 edx_29 = 0x0804B828 - 0x0804B828;
	int32 edx_30 = edx_29 >> 0x02;
	if (edx_29 >> 0x02 > 0x00)
	{
		Eq_1643 esi_35 = 0x00;
		do
		{
			(*((char *) g_a804B828 + esi_35 * 0x04))();
			esi_35 = (word32) esi_35.u1 + 1;
		} while (esi_35 < edx_29 >> 0x02);
	}
}

// 08049E88: void __i686.get_pc_thunk.bx()
void __i686.get_pc_thunk.bx()
{
}

// 08049E90: void atexit(Stack (ptr32 Eq_162) dwArg04)
// Called from:
//      main
void atexit(void (* dwArg04)(void * ptrArg04))
{
	void * eax_19 = null;
	void ** edx_15 = g_ptr804B74C;
	if (edx_15 != null)
		eax_19 = (void *) *edx_15;
	__cxa_atexit(dwArg04, null, eax_19);
}

// 08049ED0: void __do_global_ctors_aux(Register word32 edx)
// Called from:
//      _init
void __do_global_ctors_aux(word32 edx)
{
	word32 * ebx_14 = &g_ptr804B660;
	<anonymous> * eax_15 = g_ptr804B660;
	while (eax_15 != (<anonymous> *) ~0x00)
	{
		eax_15();
		ebx_14 -= 0x04;
		eax_15 = *ebx_14;
	}
}

