//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
//

#include <libintl.h>
#include <libio.h>
#include <locale.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t __i686_get_pc_thunk_bx(int32_t a1);
int32_t usage(int32_t status);
int32_t version_etc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t version_etc_va(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);

// --------------------- Global Variables ---------------------

char * g1; // 0x804a03c
char (*g2)[50] = "Copyright (C) 2004 Free Software Foundation, Inc."; // 0x804b7e8
struct _IO_FILE * g3 = NULL; // 0x804b800
int32_t g4 = 0; // 0x804b948
int32_t g5;
int32_t g6;

// ------------------------ Functions -------------------------

// Address range: 0x8048a80 - 0x8048b54
int32_t usage(int32_t status) {
    // 0x8048a80
    printf(dcgettext(NULL, "Usage: %s [ignored command line arguments]\n  or:  %s OPTION\nExit with a status code indicating success.\n\nThese option names may not be abbreviated.\n\n", 5));
    fputs_unlocked(dcgettext(NULL, "      --help     display this help and exit\n", 5), g3);
    fputs_unlocked(dcgettext(NULL, "      --version  output version information and exit\n", 5), g3);
    printf(dcgettext(NULL, "\nReport bugs to <%s>.\n", 5));
    exit(status);
    return &g6;
}

// Address range: 0x8048b60 - 0x8048c62
int main(int argc, char ** argv) {
    // 0x8048b60
    g4 = (int32_t)*argv;
    setlocale(LC_ALL, (char *)&g1);
    bindtextdomain("coreutils", "/usr/share/locale");
    textdomain("coreutils");
    atexit(0x8048c80);
    if (argc != 2 || getenv("POSIXLY_CORRECT") != NULL) {
        // 0x8048bc7
        exit(0);
        // UNREACHABLE
    }
    int32_t v1 = *(int32_t *)((int32_t)argv + 4); // 0x8048be4
    int32_t v2 = 7; // 0x8048bf9
    int32_t v3 = v1; // 0x8048bf9
    int32_t v4 = (int32_t)"--help"; // 0x8048bf9
    int32_t v5; // 0x8048b60
    int32_t v6; // 0x8048b60
    int32_t v7; // 0x8048b60
    while (v2 != 0) {
        int32_t v8 = v3;
        char v9 = *(char *)v4; // 0x8048bf9
        v2--;
        v3 = v8 + 1;
        v4++;
        v6 = (int32_t)"--version";
        v7 = v1;
        v5 = 10;
        if (*(char *)v8 != v9) {
            goto lab_0x8048bfd;
        }
    }
    // 0x8048c4d
    usage(0);
    // UNREACHABLE
  lab_0x8048bfd:
    // 0x8048bfd
    if (*(char *)v7 == *(char *)v6) {
        int32_t v10 = v5 - 1; // 0x8048c0d
        v6++;
        v7++;
        v5 = v10;
        if (v10 == 0) {
            // 0x8048c11
            version_etc((int32_t)g3, (int32_t)"true", (int32_t)"GNU coreutils", (int32_t)"5.2.1", (int32_t)"Jim Meyering", 0);
        } else {
            goto lab_0x8048bfd;
        }
    } else {
        goto lab_0x8048bc7;
    }
}

// Address range: 0x80498d0 - 0x8049ae2
int32_t version_etc_va(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    int32_t v1 = (int32_t)a5;
    int32_t v2 = v1; // 0x80498f7
    int32_t v3 = 0; // 0x80498f7
    int32_t v4 = 0; // 0x80498f7
    if (*a5 != 0) {
        v2 += 4;
        v3++;
        v4 = v3;
        while (*(int32_t *)v2 != 0) {
            // 0x8049900
            v2 += 4;
            v3++;
            v4 = v3;
        }
    }
    struct _IO_FILE * stream = (struct _IO_FILE *)a1;
    if (a2 == 0) {
        // 0x8049a92
        fprintf(stream, "%s %s\n", (char *)a3, (char *)a4);
    } else {
        // 0x8049914
        fprintf(stream, "%s (%s) %s\n", (char *)a2, (char *)a3, (char *)a4);
    }
    // 0x804993c
    g5 = v4;
    int32_t v5 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"; // 0x804993c
    char * v6 = "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"; // 0x804993c
    int32_t * v7; // 0x8049971
    int32_t * v8; // 0x8049974
    switch (v4) {
        case 0: {
            // 0x8049a8d
            abort();
            // UNREACHABLE
        }
        case 1: {
            // 0x8049a7a
            v5 = (int32_t)"Written by %s.\n";
        }
        default: {
          lab_0x8049951:
            // 0x8049951
            v6 = (char *)v5;
        }
        case 7: {
          lab_0x8049955:
            // 0x8049955
            vfprintf(stream, dcgettext(NULL, v6, 5), v1);
            v7 = (int32_t *)(a1 + 20);
            uint32_t v9 = *v7; // 0x8049971
            v8 = (int32_t *)(a1 + 24);
            if (v9 >= *v8) {
                // 0x8049acc
                __overflow(stream, 10);
            } else {
                // 0x804997d
                *(char *)v9 = 10;
                *v7 = *v7 + 1;
            }
            // break -> 0x8049983
            break;
        }
        case 2: {
            // 0x8049a63
            v6 = "Written by %s and %s.\n";
            // branch (via goto) -> 0x8049955
            goto lab_0x8049955;
        }
        case 3: {
            // 0x8049a50
            v5 = (int32_t)"Written by %s, %s, and %s.\n";
            // branch (via goto) -> 0x8049951
            goto lab_0x8049951;
        }
        case 4: {
            // 0x8049a3d
            v5 = (int32_t)"Written by %s, %s, %s,\nand %s.\n";
            // branch (via goto) -> 0x8049951
            goto lab_0x8049951;
        }
        case 5: {
            // 0x8049a2a
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, and %s.\n";
            // branch (via goto) -> 0x8049951
            goto lab_0x8049951;
        }
        case 6: {
            // 0x8049a13
            v6 = "Written by %s, %s, %s,\n%s, %s, and %s.\n";
            // branch (via goto) -> 0x8049955
            goto lab_0x8049955;
        }
        case 8: {
            // 0x80499e9
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n";
            // branch (via goto) -> 0x8049951
            goto lab_0x8049951;
        }
        case 9: {
            // 0x80499d6
            v5 = (int32_t)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
            // branch (via goto) -> 0x8049951
            goto lab_0x8049951;
        }
    }
    // 0x8049983
    fputs_unlocked(g2, stream);
    uint32_t v10 = *v7; // 0x8049994
    if (v10 >= *v8) {
        // 0x8049ab6
        __overflow(stream, 10);
    } else {
        // 0x80499a0
        *(char *)v10 = 10;
        *v7 = *v7 + 1;
    }
    char * v11 = dcgettext(NULL, "This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n", 5); // 0x80499c2
    return fputs_unlocked(v11, (struct _IO_FILE *)&g6);
}

// Address range: 0x8049af0 - 0x8049b1f
int32_t version_etc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8049af0
    int32_t v1; // bp+20, 0x8049af0
    return version_etc_va(a1, a2, a3, a4, &v1);
}

// Address range: 0x8049e88 - 0x8049e8c
int32_t __i686_get_pc_thunk_bx(int32_t a1) {
    // 0x8049e88
    int32_t result; // 0x8049e88
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t atexit(int32_t a1);

// --------------- Dynamically Linked Functions ---------------

// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int __overflow(_IO_FILE *, int);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// void exit(int status);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs_unlocked(const char * restrict s, FILE * restrict stream);
// char * getenv(const char * name);
// int printf(const char * restrict format, ...);
// char * setlocale(int category, const char * locale);
// char * textdomain(const char * domainname);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected functions: 5

