//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <errno.h>
#include <error.h>
#include <libintl.h>
#include <libio.h>
#include <locale.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <wctype.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _TYPEDEF___mbstate_t {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t close_stdout(void);
int32_t entry_point(int32_t a1);
int32_t function_80488bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_80488e4(struct _IO_FILE * fp);
int32_t function_80488f4(struct _IO_FILE * a1, int32_t a2);
int32_t function_8048904(char * s, struct _IO_FILE * stream);
int32_t function_8048914(struct _IO_FILE * stream, char * format, ...);
char * function_8048924(char * name);
char * function_8048934(char * domainname, char * msgid, int32_t category);
char * function_8048944(int32_t category, char * locale);
int32_t function_8048954(void (*func)(int32_t *), int32_t * arg, int32_t * dso_handle);
int32_t * function_8048964(void);
int32_t * function_8048974(int32_t size);
void function_8048984(void);
int32_t function_8048994(struct _IO_FILE * s, char * format, int32_t arg);
char * function_80489a4(char * domainname, char * dirname);
int32_t function_80489b4(int32_t * pwc, char * s, int32_t n, struct _TYPEDEF___mbstate_t * p);
int32_t function_80489c4(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)());
int32_t * function_80489d4(int32_t * ptr, int32_t size);
char * function_80489e4(char * domainname);
int32_t function_80489f4(char * format, ...);
int32_t * function_8048a04(int32_t * dest, int32_t * src, int32_t n);
int32_t function_8048a14(struct _IO_FILE * stream);
int32_t function_8048a24(void);
void function_8048a34(int32_t status);
int32_t * function_8048a44(int32_t nmemb, int32_t size);
int32_t function_8048a54(int32_t wc);
void function_8048a64(int32_t * ptr);
int32_t * function_8048a74(int32_t * s, int32_t c, int32_t n);
int32_t function_8048a84(struct _TYPEDEF___mbstate_t * ps);
void function_8048a94(int32_t status, int32_t errnum, char * format, ...);
int16_t ** function_8048aa4(void);
int32_t function_8048ae4(int32_t a1);
int32_t function_8048b08(int32_t a1, int32_t a2);
int32_t function_8048b3c(void);
int32_t function_8048b68(int32_t status);
int32_t function_8048c4a(int32_t a1, int32_t a2);
int32_t function_8048d64(int32_t a1, int32_t a2);
int32_t function_8048d68(int32_t result);
int32_t function_8048e5f(int32_t a1);
int32_t function_8048e70(int32_t a1);
int32_t function_8048eea(int32_t a1);
int32_t function_8048f0d(int32_t a1, int32_t result);
int32_t function_8048f36(int32_t * a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12);
int32_t function_8048fa3(void);
int32_t function_8048ff6(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_80495c7(void);
int32_t function_80495f4(void);
int32_t function_8049600(void);
int32_t function_8049672(void);
int32_t function_80496c3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t function_8049721(int32_t a1, int32_t a2);
int32_t function_80498ae(int32_t a1, int32_t a2);
int32_t function_80498da(int32_t result);
int32_t function_8049905(int32_t a1, int32_t a2);
int32_t function_804995f(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804998f(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_80499be(int32_t a1, int32_t a2);
int32_t function_80499f0(int32_t a1, int32_t a2);
int32_t function_8049a8b(int32_t a1);
int32_t function_8049ac0(int32_t stream, int32_t a2, int32_t a3, int32_t a4, int32_t * a5);
int32_t function_8049ccd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_8049d10(void);
int32_t function_8049d82(uint32_t a1, uint32_t a2);
int32_t function_8049dc5(int32_t size);
int32_t function_8049df5(int32_t a1, uint32_t a2, uint32_t a3);
int32_t function_8049e3f(int32_t a1, int32_t a2);
int32_t function_8049e75(int32_t a1, int32_t a2, uint32_t a3);
int32_t function_8049ee2(int32_t a1, int32_t a2);
int32_t function_8049f27(int32_t a1);
int32_t function_8049f60(uint32_t nmemb, uint32_t size);
int32_t function_8049fa5(int32_t a1, int32_t a2);
int32_t function_8049fe0(int32_t a1);
int32_t function_804a008(void);
int32_t function_804a05c(void);
int32_t function_804a0a0(int32_t a1);
int32_t function_804a0d0(void);
int32_t function_804a0f4(void);

// --------------------- Global Variables ---------------------

int32_t g1 = -1; // 0x804b82c
int32_t g2 = 0; // 0x804b838
char g4 = 0; // 0x804ba00
int32_t g5;
int32_t * g3 = &g2; // 0x804b9d4

// ------------------------ Functions -------------------------

// Address range: 0x80488bc - 0x80488d3
int32_t function_80488bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x80488bc
    int32_t v1; // 0x80488bc
    function_8048ae4(v1);
    function_8048b3c();
    return function_804a0d0();
}

// Address range: 0x80488e4 - 0x80488ea
int32_t function_80488e4(struct _IO_FILE * fp) {
    // 0x80488e4
    return __fpending(fp);
}

// Address range: 0x80488f4 - 0x80488fa
int32_t function_80488f4(struct _IO_FILE * a1, int32_t a2) {
    // 0x80488f4
    return __overflow(a1, a2);
}

// Address range: 0x8048904 - 0x804890a
int32_t function_8048904(char * s, struct _IO_FILE * stream) {
    // 0x8048904
    return fputs_unlocked(s, stream);
}

// Address range: 0x8048914 - 0x804891a
int32_t function_8048914(struct _IO_FILE * stream, char * format, ...) {
    // 0x8048914
    return fprintf(stream, format);
}

// Address range: 0x8048924 - 0x804892a
char * function_8048924(char * name) {
    // 0x8048924
    return getenv(name);
}

// Address range: 0x8048934 - 0x804893a
char * function_8048934(char * domainname, char * msgid, int32_t category) {
    // 0x8048934
    return dcgettext(domainname, msgid, category);
}

// Address range: 0x8048944 - 0x804894a
char * function_8048944(int32_t category, char * locale) {
    // 0x8048944
    return setlocale(category, locale);
}

// Address range: 0x8048954 - 0x804895a
int32_t function_8048954(void (*func)(int32_t *), int32_t * arg, int32_t * dso_handle) {
    // 0x8048954
    return __cxa_atexit(func, arg, dso_handle);
}

// Address range: 0x8048964 - 0x804896a
int32_t * function_8048964(void) {
    // 0x8048964
    return __errno_location();
}

// Address range: 0x8048974 - 0x804897a
int32_t * function_8048974(int32_t size) {
    // 0x8048974
    return malloc(size);
}

// Address range: 0x8048984 - 0x804898a
void function_8048984(void) {
    // 0x8048984
    abort();
}

// Address range: 0x8048994 - 0x804899a
int32_t function_8048994(struct _IO_FILE * s, char * format, int32_t arg) {
    // 0x8048994
    return vfprintf(s, format, arg);
}

// Address range: 0x80489a4 - 0x80489aa
char * function_80489a4(char * domainname, char * dirname) {
    // 0x80489a4
    return bindtextdomain(domainname, dirname);
}

// Address range: 0x80489b4 - 0x80489ba
int32_t function_80489b4(int32_t * pwc, char * s, int32_t n, struct _TYPEDEF___mbstate_t * p) {
    // 0x80489b4
    return mbrtowc(pwc, s, n, p);
}

// Address range: 0x80489c4 - 0x80489ca
int32_t function_80489c4(int32_t main, int32_t argc, char ** ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)()) {
    // 0x80489c4
    return __libc_start_main(main, argc, ubp_av, init, fini, rtld_fini);
}

// Address range: 0x80489d4 - 0x80489da
int32_t * function_80489d4(int32_t * ptr, int32_t size) {
    // 0x80489d4
    return realloc(ptr, size);
}

// Address range: 0x80489e4 - 0x80489ea
char * function_80489e4(char * domainname) {
    // 0x80489e4
    return textdomain(domainname);
}

// Address range: 0x80489f4 - 0x80489fa
int32_t function_80489f4(char * format, ...) {
    // 0x80489f4
    return printf(format);
}

// Address range: 0x8048a04 - 0x8048a0a
int32_t * function_8048a04(int32_t * dest, int32_t * src, int32_t n) {
    // 0x8048a04
    return memcpy(dest, src, n);
}

// Address range: 0x8048a14 - 0x8048a1a
int32_t function_8048a14(struct _IO_FILE * stream) {
    // 0x8048a14
    return fclose(stream);
}

// Address range: 0x8048a24 - 0x8048a2a
int32_t function_8048a24(void) {
    // 0x8048a24
    return __ctype_get_mb_cur_max();
}

// Address range: 0x8048a34 - 0x8048a3a
void function_8048a34(int32_t status) {
    // 0x8048a34
    exit(status);
}

// Address range: 0x8048a44 - 0x8048a4a
int32_t * function_8048a44(int32_t nmemb, int32_t size) {
    // 0x8048a44
    return calloc(nmemb, size);
}

// Address range: 0x8048a54 - 0x8048a5a
int32_t function_8048a54(int32_t wc) {
    // 0x8048a54
    return iswprint(wc);
}

// Address range: 0x8048a64 - 0x8048a6a
void function_8048a64(int32_t * ptr) {
    // 0x8048a64
    free(ptr);
}

// Address range: 0x8048a74 - 0x8048a7a
int32_t * function_8048a74(int32_t * s, int32_t c, int32_t n) {
    // 0x8048a74
    return memset(s, c, n);
}

// Address range: 0x8048a84 - 0x8048a8a
int32_t function_8048a84(struct _TYPEDEF___mbstate_t * ps) {
    // 0x8048a84
    return mbsinit(ps);
}

// Address range: 0x8048a94 - 0x8048a9a
void function_8048a94(int32_t status, int32_t errnum, char * format, ...) {
    // 0x8048a94
    error(status, errnum, format);
}

// Address range: 0x8048aa4 - 0x8048aaa
int16_t ** function_8048aa4(void) {
    // 0x8048aa4
    return __ctype_b_loc();
}

// Address range: 0x8048ac0 - 0x8048ae2
int32_t entry_point(int32_t a1) {
    // 0x8048ac0
    int32_t v1; // 0x8048ac0
    int32_t v2; // 0x8048ac0
    __libc_start_main(0x8048c4a, a1, (char **)&v1, (void (*)())0x804a008, (void (*)())0x804a05c, (void (*)())v2);
    __asm_hlt();
    // UNREACHABLE
}

// Address range: 0x8048ae4 - 0x8048b05
int32_t function_8048ae4(int32_t a1) {
    // 0x8048ae4
    int32_t result; // 0x8048ae4
    return result;
}

// Address range: 0x8048b08 - 0x8048b3a
int32_t function_8048b08(int32_t a1, int32_t a2) {
    // 0x8048b08
    if (g4 != 0) {
        // 0x8048b38
        int32_t result; // 0x8048b08
        return result;
    }
    int32_t result2 = (int32_t)g3; // 0x8048b26
    int32_t result3 = result2; // 0x8048b2f
    if (g3 == NULL) {
        // 0x8048b31
        g4 = 1;
        // 0x8048b38
        return result2;
    }
    result3 += 4;
    while (result3 != 0) {
        // 0x8048b1c
        result3 += 4;
    }
    // 0x8048b31
    *(int32_t *)&g3 = result3;
    // 0x8048b31
    g4 = 1;
    // 0x8048b38
    return result3;
}

// Address range: 0x8048b3c - 0x8048b66
int32_t function_8048b3c(void) {
    // 0x8048b3c
    return 0;
}

// Address range: 0x8048b68 - 0x8048c4a
int32_t function_8048b68(int32_t status) {
    // 0x8048b68
    int32_t v1; // 0x8048b68
    function_8048d64(v1, v1);
    printf(dcgettext(NULL, (char *)(v1 + 0x15a6), 5));
    char * v2 = dcgettext(NULL, (char *)(v1 + 0x163e), 5); // 0x8048bca
    int32_t * v3 = (int32_t *)*(int32_t *)(v1 + 0x2dce); // 0x8048bd5
    fputs_unlocked(v2, (struct _IO_FILE *)*v3);
    fputs_unlocked(dcgettext(NULL, (char *)(v1 + 0x166e), 5), (struct _IO_FILE *)*v3);
    printf(dcgettext(NULL, (char *)(v1 + 0x16a4), 5));
    exit(status);
    // UNREACHABLE
}

// Address range: 0x8048c4a - 0x8048d64
int32_t function_8048c4a(int32_t a1, int32_t a2) {
    // 0x8048c4a
    int32_t v1; // 0x8048c4a
    int32_t v2 = v1;
    function_8048d64(v2, v1);
    *(int32_t *)*(int32_t *)(v2 + 0x2ce3) = *(int32_t *)a2;
    setlocale(LC_ALL, (char *)(v2 + 0x15d7));
    char * v3 = (char *)(v2 + 0x1638); // 0x8048c97
    bindtextdomain(v3, (char *)(v2 + 0x15ee));
    textdomain(v3);
    function_804a0a0(*(int32_t *)(v2 + 0x2cd7));
    if (a1 != 2) {
        // 0x8048cbb
        exit(0);
        // UNREACHABLE
    }
    char * env_val = getenv((char *)(v2 + 0x1600)); // 0x8048cd0
    if (env_val != NULL) {
      lab_0x8048cbb:
        // 0x8048cbb
        exit(0);
        // UNREACHABLE
    }
    int32_t v4 = *(int32_t *)(a2 + 4); // 0x8048cdf
    int32_t v5 = (int32_t)env_val & -256 | 7; // 0x8048cef
    int32_t v6 = v4; // 0x8048cef
    int32_t v7 = v2 + 0x1610; // 0x8048cef
    int32_t v8; // 0x8048c4a
    int32_t v9; // 0x8048c4a
    int32_t v10; // 0x8048c4a
    while (v5 != 0) {
        int32_t v11 = v6;
        char v12 = *(char *)v7; // 0x8048cef
        v5--;
        v6 = v11 + 1;
        v7++;
        if (*(char *)v11 != v12) {
            // 0x8048cf3
            v9 = v2 + 0x1617;
            v10 = v4;
            v8 = 10;
            goto lab_dec_label_pc_unknown;
        }
    }
    // 0x8048d4d
    function_8048b68(0);
    // UNREACHABLE
  lab_dec_label_pc_unknown:
    if (*(char *)v10 == *(char *)v9) {
        int32_t v13 = v8 - 1; // 0x8048d04
        v9++;
        v10++;
        v8 = v13;
        if (v13 == 0) {
            int32_t v14 = *(int32_t *)*(int32_t *)(v2 + 0x2ceb); // 0x8048d3e
            function_8049ccd(v14, v2 + 0x1642, v2 + 0x1634, v2 + 0x162e, v2 + 0x1621, 0);
            goto lab_0x8048cbb;
        } else {
            goto lab_dec_label_pc_unknown;
        }
    } else {
        goto lab_0x8048cbb;
    }
}

// Address range: 0x8048d64 - 0x8048d68
int32_t function_8048d64(int32_t a1, int32_t a2) {
    // 0x8048d64
    int32_t result; // 0x8048d64
    return result;
}

// Address range: 0x8048d68 - 0x8048d81
int32_t function_8048d68(int32_t result) {
    // 0x8048d68
    int32_t v1; // 0x8048d68
    function_8048e5f(v1);
    *(int32_t *)(v1 + 0x2c96) = result;
    return result;
}

// Address range: 0x8048d81 - 0x8048e5f
int32_t close_stdout(void) {
    // 0x8048d81
    int32_t v1; // 0x8048d81
    int32_t v2 = v1;
    function_8048d64(v2, v1);
    int32_t * v3 = (int32_t *)*(int32_t *)(v2 + 0x2bb4); // 0x8048d9b
    int32_t v4 = *v3; // 0x8048d9b
    int32_t v5 = *(int32_t *)v4; // 0x8048d9d
    int32_t file = v4; // 0x8048dac
    if ((v5 & 32) == 0) {
        // 0x8048dae
        if (__fpending((struct _IO_FILE *)v4) == 0) {
            // 0x8048e24
            return 0;
        }
        // 0x8048dae
        file = *v3;
    }
    int32_t v6 = fclose((struct _IO_FILE *)file); // 0x8048dbf
    int32_t result = v6; // 0x8048dc6
    int32_t err_num = (v5 & 32) == 0; // 0x8048dc6
    if (v6 != 0) {
        int32_t * v7 = __errno_location(); // 0x8048e2c
        err_num = *v7;
        result = (int32_t)v7;
    }
    // 0x8048dc8
    if (err_num < 0) {
        // 0x8048e24
        return result;
    }
    // 0x8048dcc
    dcgettext(NULL, (char *)(v2 + 0x1510), 5);
    int32_t v8 = *(int32_t *)(v2 + 0x2c78); // 0x8048dec
    if (v8 == 0) {
        // 0x8048e35
        error(*(int32_t *)*(int32_t *)(v2 + 0x2bb0), err_num, (char *)(v2 + 0x1520));
        return &g5;
    }
    // 0x8048df6
    function_8049a8b(v8);
    error(*(int32_t *)*(int32_t *)(v2 + 0x2bb0), err_num, (char *)(v2 + 0x151c));
    // 0x8048e24
    return &g5;
}

// Address range: 0x8048e5f - 0x8048e63
int32_t function_8048e5f(int32_t a1) {
    // 0x8048e5f
    int32_t result; // 0x8048e5f
    return result;
}

// Address range: 0x8048e70 - 0x8048eea
int32_t function_8048e70(int32_t a1) {
    // 0x8048e70
    int32_t v1; // 0x8048e70
    function_8048d64(v1, v1);
    int32_t * v2 = __errno_location(); // 0x8048e84
    int32_t result = function_8049dc5(36); // 0x8048e94
    int32_t v3 = a1 == 0 ? v1 + 0x2ca5 : a1;
    *(int32_t *)result = *(int32_t *)v3;
    *(int32_t *)(result + 4) = *(int32_t *)(v3 + 4);
    *(int32_t *)(result + 8) = *(int32_t *)(v3 + 8);
    *(int32_t *)(result + 12) = *(int32_t *)(v3 + 12);
    *(int32_t *)(result + 16) = *(int32_t *)(v3 + 16);
    *(int32_t *)(result + 20) = *(int32_t *)(v3 + 20);
    *(int32_t *)(result + 24) = *(int32_t *)(v3 + 24);
    *(int32_t *)(result + 28) = *(int32_t *)(v3 + 28);
    *(int32_t *)(result + 32) = *(int32_t *)(v3 + 32);
    return result;
}

// Address range: 0x8048eea - 0x8048f0d
int32_t function_8048eea(int32_t a1) {
    // 0x8048eea
    int32_t v1; // 0x8048eea
    function_8048e5f(v1);
    if (a1 == 0) {
        // 0x8048f03
        return *(int32_t *)(v1 + 0x2c30);
    }
    // 0x8048eff
    return *(int32_t *)a1;
}

// Address range: 0x8048f0d - 0x8048f36
int32_t function_8048f0d(int32_t a1, int32_t result) {
    // 0x8048f0d
    int32_t v1; // 0x8048f0d
    function_8048e5f(v1);
    if (a1 == 0) {
        // 0x8048f29
        *(int32_t *)(v1 + 0x2c0d) = result;
        return result;
    }
    // 0x8048f22
    *(int32_t *)a1 = result;
    return result;
}

// Address range: 0x8048f36 - 0x8048fa3
int32_t function_8048f36(int32_t * a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, int32_t a12) {
    // 0x8048f36
    int32_t v1; // 0x8048f36
    function_8048d64(v1, v1);
    int32_t v2 = a2 / 8 & 28; // 0x8048f59
    if (a1 == NULL) {
        uint32_t v3 = a2 % 32; // 0x8048f87
        int32_t * v4 = (int32_t *)(v1 + (v2 | 0x2be3)); // 0x8048f8d
        uint32_t v5 = *v4; // 0x8048f8d
        uint32_t result = (v5 >> v3) % 2; // 0x8048f93
        *v4 = (result ^ a3 % 2) << v3 ^ v5;
        return result;
    }
    int32_t * v6 = (int32_t *)((int32_t)a1 + 4 + v2); // 0x8048f64
    uint32_t v7 = *v6; // 0x8048f64
    uint32_t v8 = a2 % 32; // 0x8048f66
    uint32_t result2 = (v7 >> v8) % 2; // 0x8048f70
    *v6 = (result2 ^ a3 % 2) << v8 ^ v7;
    return result2;
}

// Address range: 0x8048fa3 - 0x8048ff6
int32_t function_8048fa3(void) {
    // 0x8048fa3
    int32_t v1; // 0x8048fa3
    int32_t v2 = (int32_t)dcgettext(NULL, (char *)function_8048d64(v1, v1), 5); // 0x8048fce
    return v1 == 6 != (v1 == v2) ? v2 : v1 + 0x15d6;
}

// Address range: 0x8048ff6 - 0x80495c7
int32_t function_8048ff6(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x8048ff6
    int32_t v1; // 0x8048ff6
    int32_t v2 = function_8048d64(v1, v1); // 0x8048ffc
    int32_t v3 = v1 + 0x294b; // 0x8049001
    int32_t v4 = __ctype_get_mb_cur_max(); // 0x804902c
    if (a3 < 7) {
        // 0x8049043
        return *(int32_t *)(4 * a3 + 0x12cb + v1) + v3;
    }
    int32_t v5 = 0; // 0x8049081
    int32_t v6 = 0; // 0x8049081
    int32_t v7 = a2; // 0x8049081
    int32_t v8 = 0; // 0x8049081
    int32_t v9 = 0; // 0x8049081
    int32_t v10 = -1; // 0x8049081
    if (a2 == -1) {
        goto lab_0x8049218;
    } else {
        goto lab_0x8049087;
    }
  lab_0x804931a:;
    // 0x804931a
    int32_t v11; // 0x8048ff6
    uint32_t v12 = v11;
    int32_t v13; // 0x8048ff6
    int32_t v14 = v13; // 0x804931e
    int32_t v15; // 0x8048ff6
    int32_t v16; // 0x8048ff6
    if (v12 < 2) {
        goto lab_0x804933e;
    } else {
        // 0x804931a
        v15 = v12 + v16;
        goto lab_0x8049142;
    }
  lab_0x8049218:;
    int32_t v17 = v8; // 0x8049222
    int32_t v18 = v9; // 0x8049222
    int32_t v19 = v10; // 0x8049222
    int32_t result = v8; // 0x8049222
    if (*(char *)(v9 + a1) != 0) {
        goto lab_0x8049093;
    } else {
        goto lab_0x8049255;
    }
  lab_0x8049087:
    // 0x8049087
    v17 = v5;
    v18 = v6;
    v19 = v7;
    result = v5;
    if (v6 == v7) {
        goto lab_0x8049255;
    } else {
        goto lab_0x8049093;
    }
  lab_0x8049093:
    // 0x8049093
    v16 = v18;
    int32_t v20 = v16 + a1; // 0x80490e5
    char v21 = *(char *)v20; // 0x80490e5
    if (v21 < 127) {
        // 0x80490f4
        return *(int32_t *)(v1 + 0x12e7 + 4 * (int32_t)v21) + v3;
    }
    int32_t v22 = v19;
    int32_t v23 = v17;
    if (v4 != 1) {
        int32_t ps = 0; // bp-36, 0x8049279
        int32_t v24 = v22; // 0x8049298
        int32_t v25 = a1; // 0x8049298
        if (v22 == -1) {
            int32_t v26 = -1; // 0x804954e
            int32_t v27 = 0; // 0x804954e
            while (v26 != 0) {
                int32_t v28 = v25;
                v26--;
                v25 = v28 + 1;
                v27 = v26;
                if (*(char *)v28 == 0) {
                    // break -> 
                    break;
                }
                v27 = 0;
            }
            v24 = -2 - v27;
        }
        // 0x804929e
        v13 = v24;
        int32_t v29 = 0; // 0x80492aa
        while (true) {
          lab_0x80492ad:;
            int32_t v30 = v29;
            int32_t v31 = v30 + v16;
            int32_t pwc; // bp-40, 0x8048ff6
            int32_t v32 = mbrtowc(&pwc, (char *)(v31 + a1), v13 - v31, (struct _TYPEDEF___mbstate_t *)&ps); // 0x80492d3
            v11 = v30;
            switch (v32) {
                case 0: {
                    goto lab_0x804931a;
                }
                case -1: {
                    // 0x804955d
                    v15 = v31;
                    v14 = v13;
                    if (v30 < 2) {
                        goto lab_0x804933e;
                    } else {
                        goto lab_0x8049142;
                    }
                }
                case -2: {
                    // 0x8049573
                    v11 = v30;
                    if (v13 > v31) {
                        // 0x8049587
                        v11 = v30;
                        int32_t v33 = v30; // 0x8049591
                        if (*(char *)(v30 + v20) != 0) {
                            int32_t v34 = v33 + 1; // 0x8049598
                            int32_t v35 = v34 + v16;
                            v11 = v34;
                            while (v35 < v13) {
                                // 0x80495ac
                                v33 = v34;
                                if (*(char *)(v34 + v20) == 0) {
                                    // 0x80495b8
                                    v15 = v35;
                                    v14 = v13;
                                    if (v34 < 2) {
                                        goto lab_0x804933e;
                                    } else {
                                        goto lab_0x8049142;
                                    }
                                }
                                v34 = v33 + 1;
                                v35 = v34 + v16;
                                v11 = v34;
                            }
                        }
                    }
                    goto lab_0x804931a;
                }
                default: {
                    // 0x80492f0
                    iswprint(pwc);
                    int32_t v36 = mbsinit((struct _TYPEDEF___mbstate_t *)&ps); // 0x8049311
                    v29 = v32 + v30;
                    if (v36 != 0) {
                        // break -> 0x804931a
                        break;
                    }
                    goto lab_0x80492ad;
                }
            }
        }
        goto lab_0x804931a;
    } else {
        // 0x804910a
        __ctype_b_loc();
        v14 = v22;
        goto lab_0x804933e;
    }
  lab_0x8049255:
    // 0x8049255
    if (result < v1) {
        // 0x804925d
        *(char *)(result + v2) = 0;
    }
    // 0x8049267
    return result;
  lab_0x804933e:;
    int32_t v37 = v23; // 0x8048ff6
    int32_t v38 = v14; // 0x8048ff6
    char v39 = v21; // 0x8048ff6
    int32_t v40 = v16 + 1; // 0x8048ff6
    goto lab_0x80491f2;
  lab_0x80491f2:;
    uint32_t v41 = v37;
    if (v41 < v1) {
        // 0x80491fa
        *(char *)(v41 + v2) = v39;
    }
    int32_t v42 = v41 + 1; // 0x8049207
    v5 = v42;
    v6 = v40;
    v7 = v38;
    v8 = v42;
    v9 = v40;
    v10 = v38;
    if (v38 != -1) {
        goto lab_0x8049087;
    } else {
        goto lab_0x8049218;
    }
  lab_0x8049142:;
    int32_t v43 = v15;
    int32_t v44 = v16 + 1; // 0x80491e7
    int32_t v45 = v44; // 0x80491ec
    char v46 = v21; // 0x80491ec
    int32_t v47 = v23; // 0x80491ec
    v37 = v23;
    v38 = v13;
    v39 = v21;
    v40 = v44;
    if (v44 < v43) {
        uint32_t v48 = v47;
        if (v48 < v1) {
            // 0x8049152
            *(char *)(v48 + v2) = v46;
        }
        int32_t v49 = v48 + 1; // 0x804915f
        char v50 = *(char *)(v45 + a1); // 0x8049169
        int32_t v51 = v45 + 1; // 0x80491e7
        v45 = v51;
        v37 = v49;
        v38 = v13;
        v39 = v50;
        v40 = v43;
        while (v51 != v43) {
            // 0x804914a
            v48 = v49;
            if (v48 < v1) {
                // 0x8049152
                *(char *)(v48 + v2) = v50;
            }
            // 0x804915f
            v49 = v48 + 1;
            v50 = *(char *)(v45 + a1);
            v51 = v45 + 1;
            v45 = v51;
            v37 = v49;
            v38 = v13;
            v39 = v50;
            v40 = v43;
        }
    }
    goto lab_0x80491f2;
}

// Address range: 0x80495c7 - 0x80495f4
int32_t function_80495c7(void) {
    // 0x80495c7
    int32_t result; // 0x80495c7
    int32_t * v1 = (int32_t *)(result - 52); // 0x80495ca
    if (*v1 < *(int32_t *)(result - 44)) {
        // 0x80495d2
        *(char *)*(int32_t *)(result - 40) = 34;
    }
    // 0x80495d8
    *v1 = 1;
    *(int32_t *)(result - 64) = 1;
    *(int32_t *)(result - 56) = result - 0x13c4;
    return result;
}

// Address range: 0x80495f4 - 0x8049600
int32_t function_80495f4(void) {
    // 0x80495f4
    int32_t result; // 0x80495f4
    *(int32_t *)(result - 64) = 1;
    return result;
}

// Address range: 0x8049600 - 0x8049672
int32_t function_8049600(void) {
    int32_t v1 = function_8048fa3(); // 0x8049609
    int32_t v2 = function_8048fa3(); // 0x8049619
    int32_t v3; // 0x8049600
    int32_t * v4 = (int32_t *)(v3 - 56); // 0x804961e
    *v4 = v1;
    char v5 = *(char *)v1;
    if (v5 != 0) {
        int32_t * v6 = (int32_t *)(v3 - 52); // 0x804962b
        uint32_t v7 = *v6; // 0x804962b
        int32_t v8 = v1; // 0x804962e
        if (v7 < *(int32_t *)(v3 - 44)) {
            // 0x8049630
            *(char *)(*(int32_t *)(v3 - 40) + v7) = v5;
            v8 = *v4;
        }
        // 0x804963f
        *v4 = v8 + 1;
        int32_t v9 = *v6 + 1; // 0x8049643
        *v6 = v9;
        int32_t v10 = *v4; // 0x8049647
        char v11 = *(char *)v10;
        while (v11 != 0) {
            // 0x8049628
            v7 = v9;
            v8 = v10;
            if (v7 < *(int32_t *)(v3 - 44)) {
                // 0x8049630
                *(char *)(*(int32_t *)(v3 - 40) + v7) = v11;
                v8 = *v4;
            }
            // 0x804963f
            *v4 = v8 + 1;
            v9 = *v6 + 1;
            *v6 = v9;
            v10 = *v4;
            v11 = *(char *)v10;
        }
    }
    // 0x804964f
    *(int32_t *)(v3 - 64) = 1;
    *v4 = v2;
    int32_t v12 = -1; // 0x8049663
    int32_t v13 = v2; // 0x8049663
    int32_t v14 = 0; // 0x8049663
    while (v12 != 0) {
        int32_t v15 = v13;
        v12--;
        v13 = v15 + 1;
        v14 = v12;
        if (*(char *)v15 == 0) {
            // break -> 
            break;
        }
        v14 = 0;
    }
    *(int32_t *)(v3 - 60) = -2 - v14;
    return 0;
}

// Address range: 0x8049672 - 0x80496c3
int32_t function_8049672(void) {
    // 0x8049672
    int32_t v1; // 0x8049672
    int32_t * v2 = (int32_t *)(v1 - 44); // 0x8049672
    uint32_t result = *v2; // 0x8049672
    *(char *)(v1 - 88) = (char)v1;
    int32_t * v3 = (int32_t *)(v1 - 52); // 0x804967b
    uint32_t v4 = *v3; // 0x804967b
    int32_t * v5 = (int32_t *)(v1 - 40);
    int32_t v6 = v4; // 0x804967e
    if (v4 < result) {
        // 0x8049680
        *(char *)(*v5 + v4) = 63;
        v6 = *v3;
    }
    int32_t v7 = v6 + 1; // 0x804968a
    *v3 = v7;
    int32_t v8 = v7; // 0x8049694
    if (result < *v2) {
        // 0x8049696
        *(char *)(*v5 + result) = 92;
        v8 = *v3;
    }
    int32_t v9 = v8 + 1; // 0x80496a0
    *v3 = v9;
    *(char *)(*v5 + v9) = 63;
    *v3 = *v3 + 1;
    return result;
}

// Address range: 0x80496c3 - 0x8049721
int32_t function_80496c3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5) {
    // 0x80496c3
    int32_t v1; // 0x80496c3
    function_8048d64(v1, v1);
    int32_t v2 = a5 == 0 ? v1 + 0x2452 : a5;
    int32_t * v3 = __errno_location(); // 0x80496de
    int32_t result = function_8048ff6(a3, a4, *(int32_t *)v2, v2); // 0x8049707
    return result;
}

// Address range: 0x8049721 - 0x80498ae
int32_t function_8049721(int32_t a1, int32_t a2) {
    // 0x8049721
    int32_t v1; // 0x8049721
    int32_t v2 = function_8048d64(v1, v1); // 0x8049727
    int32_t * v3 = __errno_location(); // 0x804973b
    if (v2 < 0) {
        // 0x80498a4
        abort();
        // UNREACHABLE
    }
    int32_t v4 = *v3; // 0x8049740
    int32_t * v5 = (int32_t *)(v1 + 0x22b0); // 0x8049753
    int32_t * v6; // 0x8049721
    if (*v5 > v2) {
        // 0x8049750
        v6 = (int32_t *)(v1 + 0x22bc);
    } else {
        uint32_t v7 = v2 + 1; // 0x804975d
        if (v7 >= 0x20000000) {
            // 0x80498a9
            function_8049d10();
            // UNREACHABLE
        }
        int32_t * v8 = (int32_t *)(v1 + 0x22bc);
        int32_t v9 = *v8; // 0x804976c
        int32_t v10 = v9; // 0x804977a
        if (v9 == v1 + 0x22b4) {
            // 0x804987a
            v10 = function_8049dc5(8);
            *v8 = v10;
            *(int32_t *)v10 = *(int32_t *)v9;
            *(int32_t *)(v10 + 4) = *(int32_t *)(v1 + 0x22b8);
        }
        int32_t v11 = function_8049e3f(v10, 8 * v7); // 0x804978e
        int32_t v12 = *v5; // 0x8049793
        *v8 = v11;
        memset((int32_t *)(8 * v12 + v11), 0, 8 * (v7 - v12));
        *v5 = v7;
        v6 = v8;
    }
    int32_t v13 = *v6; // 0x80497c5
    int32_t v14 = 8 * v2; // 0x80497ce
    uint32_t v15 = *(int32_t *)(v13 + v14); // 0x80497ce
    int32_t v16 = v14 | 4;
    int32_t result = *(int32_t *)(v13 + v16); // 0x80497d7
    uint32_t v17 = function_80496c3(result, v15, v1, a1, a2); // 0x80497fa
    if (v15 > v17) {
        // 0x8049866
        *__errno_location() = v4;
        return result;
    }
    int32_t v18 = v17 + 1; // 0x8049804
    int32_t v19 = *v6; // 0x8049807
    *(int32_t *)(v19 + v14) = v18;
    int32_t v20 = v19; // 0x804981e
    if (result != v1 + 0x22f4) {
        // 0x8049820
        function_8049fe0(result);
        v20 = *v6;
    }
    int32_t result2 = function_8049dc5(v18); // 0x8049834
    *(int32_t *)(v20 + v16) = result2;
    function_80496c3(result2, v18, v1, a1, a2);
    // 0x8049866
    *__errno_location() = v4;
    return result2;
}

// Address range: 0x80498ae - 0x80498da
int32_t function_80498ae(int32_t a1, int32_t a2) {
    // 0x80498ae
    int32_t v1; // 0x80498ae
    function_8048d64(v1, v1);
    return function_8049721(-1, v1 + 0x2269);
}

// Address range: 0x80498da - 0x8049905
int32_t function_80498da(int32_t result) {
    // 0x80498da
    int32_t v1; // 0x80498da
    function_8048d64(v1, v1);
    return result;
}

// Address range: 0x8049905 - 0x804995f
int32_t function_8049905(int32_t a1, int32_t a2) {
    // 0x8049905
    int32_t v1; // bp-56, 0x8049905
    __asm_rep_stosd_memset((char *)&v1, 0, 8);
    int32_t result; // 0x8049905
    *(int32_t *)(result + 4) = v1;
    return result;
}

// Address range: 0x804995f - 0x804998f
int32_t function_804995f(int32_t a1, int32_t a2, int32_t a3) {
    // 0x804995f
    int32_t v1; // 0x804995f
    function_8049905(v1, v1);
    int32_t v2; // bp-60, 0x804995f
    return function_8049721(-1, (int32_t)&v2);
}

// Address range: 0x804998f - 0x80499be
int32_t function_804998f(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x804998f
    int32_t v1; // 0x804998f
    function_8049905(v1, v1);
    int32_t v2; // bp-60, 0x804998f
    return function_8049721(a4, (int32_t)&v2);
}

// Address range: 0x80499be - 0x80499f0
int32_t function_80499be(int32_t a1, int32_t a2) {
    // 0x80499be
    int32_t v1; // 0x80499be
    function_8048d64(v1, v1);
    return function_804995f(0, a1, a2);
}

// Address range: 0x80499f0 - 0x8049a8b
int32_t function_80499f0(int32_t a1, int32_t a2) {
    // 0x80499f0
    int32_t v1; // 0x80499f0
    function_8048d64(v1, v1);
    int32_t v2 = *(int32_t *)(v1 + 0x2126); // 0x8049a06
    int32_t v3 = v2; // bp-60, 0x8049a10
    int32_t v4 = *(int32_t *)(v1 + 0x212a); // 0x8049a13
    int32_t v5 = *(int32_t *)(v1 + 0x212e); // 0x8049a1c
    int32_t v6 = *(int32_t *)(v1 + 0x2132); // 0x8049a25
    int32_t v7 = *(int32_t *)(v1 + 0x2136); // 0x8049a2e
    int32_t v8 = *(int32_t *)(v1 + 0x213a); // 0x8049a37
    int32_t v9 = *(int32_t *)(v1 + 0x213e); // 0x8049a40
    int32_t v10 = *(int32_t *)(v1 + 0x2142); // 0x8049a49
    int32_t v11 = *(int32_t *)(v1 + 0x2146); // 0x8049a52
    function_8048f36(&v3, 0x1000000 * a2 / 0x1000000, 1, v2, v4, v5, v6, v7, v8, v9, v10, v11);
    return function_8049721(-1, (int32_t)&v3);
}

// Address range: 0x8049a8b - 0x8049ab6
int32_t function_8049a8b(int32_t a1) {
    // 0x8049a8b
    int32_t v1; // 0x8049a8b
    function_8048d64(v1, v1);
    return function_80499f0(a1, 58);
}

// Address range: 0x8049ac0 - 0x8049ccd
int32_t function_8049ac0(int32_t stream, int32_t a2, int32_t a3, int32_t a4, int32_t * a5) {
    // 0x8049ac0
    int32_t v1; // 0x8049ac0
    int32_t v2 = v1;
    int32_t v3 = (int32_t)a5;
    function_8048d64(v2, v1);
    int32_t v4 = v3; // 0x8049af3
    int32_t v5 = 0; // 0x8049af3
    int32_t v6 = 0; // 0x8049af3
    if (*a5 != 0) {
        v4 += 4;
        v5++;
        v6 = v5;
        while (*(int32_t *)v4 != 0) {
            // 0x8049ae7
            v4 += 4;
            v5++;
            v6 = v5;
        }
    }
    // 0x8049af5
    if (a2 == 0) {
        // 0x8049c7e
        fprintf((struct _IO_FILE *)stream, (char *)(v2 + 3350));
    } else {
        // 0x8049afd
        fprintf((struct _IO_FILE *)stream, (char *)(v2 + 3271));
    }
    if (v6 < 10) {
        // 0x8049b26
        return v2 + 0x1e7f + *(int32_t *)(v2 + 3359 + 4 * v6);
    }
    char * format = dcgettext(NULL, (char *)(v2 + 2807), (int32_t)&g5); // 0x8049b4a
    struct _IO_FILE * stream2 = (struct _IO_FILE *)stream; // 0x8049b5d
    vfprintf(stream2, format, v3);
    int32_t * v7 = (int32_t *)(stream + 20); // 0x8049b62
    uint32_t v8 = *v7; // 0x8049b62
    int32_t * v9 = (int32_t *)(stream + 24); // 0x8049b65
    if (v8 >= *v9) {
        // 0x8049cb8
        __overflow(stream2, 10);
    } else {
        // 0x8049b6e
        *(char *)v8 = 10;
        *v7 = *v7 + 1;
    }
    // 0x8049b75
    fputs_unlocked((char *)*(int32_t *)*(int32_t *)(v2 + 0x1e63), stream2);
    uint32_t v10 = *v7; // 0x8049b89
    if (v10 >= *v9) {
        // 0x8049ca3
        __overflow(stream2, 10);
    } else {
        // 0x8049b95
        *(char *)v10 = 10;
        *v7 = *v7 + 1;
    }
    // 0x8049b9c
    return fputs_unlocked(dcgettext(NULL, (char *)(v2 + 2867), 5), stream2);
}

// Address range: 0x8049ccd - 0x8049d0c
int32_t function_8049ccd(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x8049ccd
    int32_t v1; // 0x8049ccd
    function_8048d64(v1, v1);
    int32_t v2; // bp+20, 0x8049ccd
    return function_8049ac0(a1, a2, a3, a4, &v2);
}

// Address range: 0x8049d10 - 0x8049d82
int32_t function_8049d10(void) {
    // 0x8049d10
    int32_t v1; // 0x8049d10
    int32_t v2 = v1;
    function_8048d64(v2, v1);
    dcgettext(NULL, (char *)*(int32_t *)(v2 + 0x1c2b), 5);
    error(*(int32_t *)*(int32_t *)(v2 + 0x1c23), 0, (char *)(v2 + 1427));
    abort();
    // UNREACHABLE
}

// Address range: 0x8049d82 - 0x8049dc5
int32_t function_8049d82(uint32_t a1, uint32_t a2) {
    // 0x8049d82
    int32_t v1; // 0x8049d82
    if (function_8048d64(v1, v1) / a2 < a1) {
        // 0x8049dbe
        return function_8049d10();
    }
    int32_t * mem = malloc(a2 * a1); // 0x8049dae
    if (mem == NULL) {
        // 0x8049dbe
        return function_8049d10();
    }
    // 0x8049db7
    return (int32_t)mem;
}

// Address range: 0x8049dc5 - 0x8049df5
int32_t function_8049dc5(int32_t size) {
    // 0x8049dc5
    int32_t v1; // 0x8049dc5
    function_8048d64(v1, v1);
    int32_t * mem = malloc(size); // 0x8049ddd
    if (mem != NULL) {
        // 0x8049de6
        return (int32_t)mem;
    }
    // 0x8049dec
    function_8049d10();
    // UNREACHABLE
}

// Address range: 0x8049df5 - 0x8049e3f
int32_t function_8049df5(int32_t a1, uint32_t a2, uint32_t a3) {
    // 0x8049df5
    int32_t v1; // 0x8049df5
    if (function_8048d64(v1, v1) / a3 < a2) {
        // 0x8049e3a
        return function_8049d10();
    }
    int32_t * mem = realloc((int32_t *)a1, a3 * a2); // 0x8049e29
    if (mem == NULL) {
        // 0x8049e3a
        return function_8049d10();
    }
    // 0x8049e32
    return (int32_t)mem;
}

// Address range: 0x8049e3f - 0x8049e75
int32_t function_8049e3f(int32_t a1, int32_t a2) {
    // 0x8049e3f
    int32_t v1; // 0x8049e3f
    function_8048d64(v1, v1);
    int32_t * mem = realloc((int32_t *)a1, a2); // 0x8049e5e
    if (mem != NULL) {
        // 0x8049e67
        return (int32_t)mem;
    }
    // 0x8049e6d
    function_8049d10();
    // UNREACHABLE
}

// Address range: 0x8049e75 - 0x8049ee2
int32_t function_8049e75(int32_t a1, int32_t a2, uint32_t a3) {
    // 0x8049e75
    int32_t v1; // 0x8049e75
    function_8048d64(v1, v1);
    int32_t * v2 = (int32_t *)a2; // 0x8049e94
    uint32_t v3 = *v2; // 0x8049e94
    if (a1 == 0) {
        int32_t v4 = v3; // 0x8049ec5
        if (v3 == 0) {
            // 0x8049ec7
            v4 = 64 / a3 + (int32_t)(a3 > 64);
        }
        // 0x8049ea7
        *v2 = v4;
        return function_8049e3f(a1, v4 * a3);
    }
    if (0x7fffffff / a3 < v3) {
        // 0x8049edd
        function_8049d10();
        // UNREACHABLE
    }
    int32_t v5 = 2 * v3;
    *v2 = v5;
    return function_8049e3f(a1, v5 * a3);
}

// Address range: 0x8049ee2 - 0x8049f27
int32_t function_8049ee2(int32_t a1, int32_t a2) {
    // 0x8049ee2
    int32_t v1; // 0x8049ee2
    function_8048d64(v1, v1);
    int32_t * v2 = (int32_t *)a2; // 0x8049efc
    int32_t v3 = *v2; // 0x8049efc
    if (a1 == 0) {
        int32_t v4 = v3; // 0x8049f1c
        if (v3 == 0) {
            // 0x8049f1e
            v4 = v3 & -256 | 64;
        }
        // 0x8049f06
        *v2 = v4;
        return function_8049e3f(a1, v4);
    }
    if (v3 < 0) {
        // 0x8049f22
        function_8049d10();
        // UNREACHABLE
    }
    int32_t v5 = 2 * v3;
    *v2 = v5;
    return function_8049e3f(a1, v5);
}

// Address range: 0x8049f27 - 0x8049f60
int32_t function_8049f27(int32_t a1) {
    // 0x8049f27
    int32_t v1; // 0x8049f27
    function_8048d64(v1, v1);
    return (int32_t)memset((int32_t *)function_8049dc5(a1), 0, a1);
}

// Address range: 0x8049f60 - 0x8049fa5
int32_t function_8049f60(uint32_t nmemb, uint32_t size) {
    // 0x8049f60
    int32_t v1; // 0x8049f60
    if (function_8048d64(v1, v1) / size < nmemb) {
        // 0x8049f9d
        function_8049d10();
        // UNREACHABLE
    }
    int32_t * mem = calloc(nmemb, size); // 0x8049f8d
    if (mem != NULL) {
        // 0x8049f96
        return (int32_t)mem;
    }
    // 0x8049f9d
    function_8049d10();
    // UNREACHABLE
}

// Address range: 0x8049fa5 - 0x8049fdd
int32_t function_8049fa5(int32_t a1, int32_t a2) {
    // 0x8049fa5
    int32_t v1; // 0x8049fa5
    function_8048d64(v1, v1);
    return (int32_t)memcpy((int32_t *)function_8049dc5(a2), (int32_t *)a1, a2);
}

// Address range: 0x8049fe0 - 0x804a007
int32_t function_8049fe0(int32_t a1) {
    // 0x8049fe0
    int32_t v1; // 0x8049fe0
    function_8048d64(v1, v1);
    int32_t result = 0; // 0x8049ff7
    if (a1 != 0) {
        // 0x8049ff9
        free((int32_t *)a1);
        result = &g5;
    }
    // 0x804a001
    return result;
}

// Address range: 0x804a008 - 0x804a05a
int32_t function_804a008(void) {
    // 0x804a008
    int32_t v1; // 0x804a008
    function_80488bc(v1, v1, v1, v1);
    return 0;
}

// Address range: 0x804a05c - 0x804a09e
int32_t function_804a05c(void) {
    // 0x804a05c
    return function_804a0f4();
}

// Address range: 0x804a0a0 - 0x804a0ce
int32_t function_804a0a0(int32_t a1) {
    // 0x804a0a0
    int32_t v1; // 0x804a0a0
    int32_t v2 = *(int32_t *)(v1 + 0x188b); // 0x804a0b0
    int32_t * v3 = NULL; // 0x804a0ba
    if (v2 != 0) {
        // 0x804a0bc
        v3 = (int32_t *)*(int32_t *)v2;
    }
    // 0x804a0be
    return __cxa_atexit((void (*)(int32_t *))a1, NULL, v3);
}

// Address range: 0x804a0d0 - 0x804a0f4
int32_t function_804a0d0(void) {
    // 0x804a0d0
    int32_t result; // 0x804a0d0
    if (g1 == -1) {
        // 0x804a0f0
        return result;
    }
    int32_t v1 = &g1; // 0x804a0ee
    while (*(int32_t *)(v1 - 4) != -1) {
        // 0x804a0e4
        v1 -= 4;
    }
    // 0x804a0f0
    return result;
}

// Address range: 0x804a0f4 - 0x804a10e
int32_t function_804a0f4(void) {
    // 0x804a0f4
    int32_t v1; // 0x804a0f4
    return function_8048b08(v1, v1);
}

// --------------- Dynamically Linked Functions ---------------

// const unsigned short int ** __ctype_b_loc(void);
// size_t __ctype_get_mb_cur_max(void);
// int __cxa_atexit(void(* func)(void *), void * arg, void * dso_handle);
// int * __errno_location(void);
// size_t __fpending(FILE * fp);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// int __overflow(_IO_FILE *, int);
// void abort(void);
// char * bindtextdomain(const char * domainname, const char * dirname);
// void * calloc(size_t nmemb, size_t size);
// char * dcgettext(const char * domainname, const char * msgid, int category);
// void error(int status, int errnum, const char * format, ...);
// void exit(int status);
// int fclose(FILE * stream);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// int fputs_unlocked(const char * restrict s, FILE * restrict stream);
// void free(void * ptr);
// char * getenv(const char * name);
// int iswprint(wint_t wc);
// void * malloc(size_t size);
// size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict p);
// int mbsinit(const mbstate_t * ps);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int printf(const char * restrict format, ...);
// void * realloc(void * ptr, size_t size);
// char * setlocale(int category, const char * locale);
// char * textdomain(const char * domainname);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.6.3)
// Detected functions: 78

