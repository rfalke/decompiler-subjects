/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// int __fastcall init_proc(int, int);
int sub_80488D4();
// size_t __fpending(FILE *fp);
// int __overflow(_IO_FILE *, int);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// int fprintf(FILE *stream, const char *format, ...);
// char *getenv(const char *name);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// char *setlocale(int category, const char *locale);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// int *__errno_location(void);
// void *malloc(size_t size);
// void abort(void);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// char *bindtextdomain(const char *domainname, const char *dirname);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// void *realloc(void *ptr, size_t size);
// char *textdomain(const char *domainname);
// int printf(const char *format, ...);
// int fclose(FILE *stream);
// size_t __ctype_get_mb_cur_max(void);
// void exit(int status);
// int iswprint(wint_t wc);
// void free(void *ptr);
// void *memset(void *s, int c, size_t n);
// int mbsinit(const mbstate_t *ps);
// void error(int status, int errnum, const char *format, ...);
// const unsigned __int16 **__ctype_b_loc(void);
// void __usercall __noreturn start(int@<eax>, void (*)(void)@<edx>);
int __fastcall sub_8048AE4(int, int);
void sub_8048B08();
int sub_8048B3C();
void __cdecl __noreturn sub_8048B68(int status); // idb
void __cdecl __noreturn main(int, char **);
void sub_8048D64();
void close_stdout();
void sub_8048E5F();
int __cdecl sub_8048F36(int, unsigned __int8, char);
// char *__usercall sub_8048FA3@<eax>(const char *a1@<eax>, int a2@<edx>);
// unsigned int __usercall sub_8048FF6@<eax>(_BYTE *@<eax>, unsigned int@<edx>, const char *, unsigned int, int, int);
unsigned int __cdecl sub_80496C3(_BYTE *, unsigned int, const char *, unsigned int, int *);
// _BYTE *__usercall sub_8049721@<eax>(unsigned int a1@<eax>, const char *a2@<edx>, unsigned int a3, int *a4);
_BYTE *__cdecl sub_80498AE(int, const char *);
// _DWORD *__usercall sub_8049905@<eax>(_DWORD *result@<eax>, int@<edx>);
_BYTE *__cdecl sub_804995F(int, int, const char *);
_BYTE *__cdecl sub_80499F0(const char *, unsigned __int8);
_BYTE *__cdecl sub_8049A8B(const char *);
int __cdecl sub_8049AC0(FILE *stream, int, int, int, __gnuc_va_list __varargs); // idb
int sub_8049CCD(FILE *stream, int, int, int, ...); // idb
void __noreturn sub_8049D10();
void *__cdecl sub_8049DC5(size_t size);
void *__cdecl sub_8049E3F(void *ptr, size_t size);
void __cdecl sub_8049FE0(void *ptr);
void __fastcall init(int a1, int a2);
void fini(void); // idb
int __cdecl sub_804A0A0(void (__cdecl *lpfunc)(void *)); // idb
int __fastcall sub_804A0D0(int, int);
// void term_proc();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_804A289; // weak
int dword_804B82C = -1; // weak
int dword_804B83C = 0; // weak
int (*dword_804B954)(void) = NULL; // weak
_DWORD dword_804B9D0 = 0; // weak
int *off_804B9D4 = &dword_804B838; // weak
_UNKNOWN exit_failure; // weak
int dword_804B9DC = 1; // weak
int dword_804B9E0 = 256; // weak
void *off_804B9E4 = &unk_804BA20; // weak
int off_804B9E8 = 134527456; // weak
char *version_etc_copyright = "Copyright (C) 2004 Free Software Foundation, Inc."; // weak
char byte_804BA00; // weak
int dword_804BA04; // weak
_UNKNOWN unk_804BA20; // weak
int dword_804BB20; // weak
int dword_804BB24[]; // weak
int dword_804BB28; // weak
int dword_804BB2C; // weak
int dword_804BB30; // weak
int dword_804BB34; // weak
int dword_804BB38; // weak
int dword_804BB3C; // weak
int dword_804BB40; // weak
void (*xalloc_fail_func)(void); // weak
_UNKNOWN program_name; // weak
// extern struct _IO_FILE *stdout;
// extern _UNKNOWN _gmon_start__; weak


//----- (080488D4) --------------------------------------------------------
int sub_80488D4()
{
  return dword_804B954();
}
// 804B954: using guessed type int (*dword_804B954)(void);

//----- (08048AC0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, (void (*)(void))init, fini, a2, &v3);
  __halt();
}
// 8048AC3: positive sp value 4 has been found

//----- (08048AE4) --------------------------------------------------------
int __fastcall sub_8048AE4(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-8h]

  v3 = a2;
  if ( &_gmon_start__ )
    ((void (__thiscall *)(int, int))_gmon_start__)(a1, a2);
  return v3;
}
// 8048B01: variable 'v3' is possibly undefined

//----- (08048B08) --------------------------------------------------------
void sub_8048B08()
{
  void (*v0)(void); // edx

  if ( !byte_804BA00 )
  {
    while ( 1 )
    {
      v0 = (void (*)(void))*off_804B9D4;
      if ( !*off_804B9D4 )
        break;
      ++off_804B9D4;
      v0();
    }
    byte_804BA00 = 1;
  }
}
// 804B9D4: using guessed type int *off_804B9D4;
// 804BA00: using guessed type char byte_804BA00;

//----- (08048B3C) --------------------------------------------------------
int sub_8048B3C()
{
  int result; // eax

  result = dword_804B83C;
  if ( dword_804B83C )
    return 0;
  return result;
}
// 804B83C: using guessed type int dword_804B83C;

//----- (08048B68) --------------------------------------------------------
void __cdecl __noreturn sub_8048B68(int status)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  v1 = dcgettext(
         0,
         "Usage: %s [ignored command line arguments]\n"
         "  or:  %s OPTION\n"
         "Exit with a status code indicating success.\n"
         "\n"
         "These option names may not be abbreviated.\n"
         "\n",
         5);
  printf(v1, program_name, program_name);
  v2 = dcgettext(0, "      --help     display this help and exit\n", 5);
  fputs_unlocked(v2, stdout);
  v3 = dcgettext(0, "      --version  output version information and exit\n", 5);
  fputs_unlocked(v3, stdout);
  v4 = dcgettext(0, "\nReport bugs to <%s>.\n", 5);
  printf(v4, "bug-coreutils@gnu.org");
  exit(status);
}
// 8048904: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);

//----- (08048C4A) --------------------------------------------------------
void __cdecl __noreturn main(int a1, char **a2)
{
  program_name = *a2;
  setlocale(6, "");
  bindtextdomain("coreutils", "/usr/share/locale");
  textdomain("coreutils");
  sub_804A0A0((void (__cdecl *)(void *))close_stdout);
  if ( a1 == 2 && !getenv("POSIXLY_CORRECT") )
  {
    if ( !strcmp(a2[1], "--help") )
      sub_8048B68(0);
    if ( !strcmp(a2[1], "--version") )
      sub_8049CCD(stdout, (int)"true", (int)&unk_804A289, (int)"5.2.1", "Jim Meyering", 0);
  }
  exit(0);
}

//----- (08048D64) --------------------------------------------------------
void sub_8048D64()
{
  ;
}

//----- (08048D81) --------------------------------------------------------
void close_stdout()
{
  unsigned int v0; // eax
  int v1; // esi
  char *v2; // edi
  _BYTE *v3; // eax

  v0 = ((unsigned int)stdout->_flags >> 5) & 1;
  v1 = -(v0 == 0);
  if ( v0 || __fpending(stdout) )
  {
    if ( fclose(stdout) )
      v1 = *__errno_location();
    if ( v1 >= 0 )
    {
      v2 = dcgettext(0, "write error", 5);
      if ( dword_804BA04 )
      {
        v3 = sub_8049A8B((const char *)dword_804BA04);
        error(exit_failure, v1, "%s: %s", v3, v2);
      }
      else
      {
        error(exit_failure, v1, "%s", v2);
      }
    }
  }
}
// 804BA04: using guessed type int dword_804BA04;

//----- (08048E5F) --------------------------------------------------------
void sub_8048E5F()
{
  ;
}

//----- (08048F36) --------------------------------------------------------
int __cdecl sub_8048F36(int a1, unsigned __int8 a2, char a3)
{
  int v3; // eax
  int *v4; // edi
  int result; // eax

  v3 = a2 >> 5;
  v4 = (int *)(v3 * 4 + a1 + 4);
  if ( !a1 )
    v4 = &dword_804BB24[v3];
  result = (*v4 >> (a2 & 0x1F)) & 1;
  *v4 ^= (result ^ a3 & 1) << (a2 & 0x1F);
  return result;
}
// 804BB24: using guessed type int dword_804BB24[];

//----- (08048FA3) --------------------------------------------------------
char *__usercall sub_8048FA3@<eax>(const char *a1@<eax>, int a2@<edx>)
{
  char *v4; // ecx

  v4 = dcgettext(0, a1, 5);
  if ( a2 == 6 && v4 == a1 )
    return (char *)L"\"'`";
  return v4;
}
// 804A588: using guessed type __int16 asc_804A588[4];

//----- (08048FF6) --------------------------------------------------------
unsigned int __usercall sub_8048FF6@<eax>(
        _BYTE *a1@<eax>,
        unsigned int a2@<edx>,
        const char *a3,
        unsigned int a4,
        int a5,
        int a6)
{
  unsigned int v6; // ecx
  int v7; // edx
  size_t v9; // eax
  char v10; // al
  char *v11; // edx
  bool i; // zf
  const char *v13; // [esp+0h] [ebp-6Ch]
  int v14; // [esp+Ch] [ebp-60h]
  unsigned int v15; // [esp+10h] [ebp-5Ch]
  unsigned __int8 v16; // [esp+14h] [ebp-58h]
  _BOOL4 v17; // [esp+28h] [ebp-44h]
  int v18; // [esp+2Ch] [ebp-40h]
  unsigned int v19; // [esp+30h] [ebp-3Ch]
  __int16 *v20; // [esp+34h] [ebp-38h]
  char *v21; // [esp+34h] [ebp-38h]
  unsigned int v22; // [esp+38h] [ebp-34h]
  unsigned int v23; // [esp+38h] [ebp-34h]
  unsigned int v24; // [esp+38h] [ebp-34h]
  unsigned int v25; // [esp+38h] [ebp-34h]
  unsigned int v26; // [esp+38h] [ebp-34h]
  unsigned int v27; // [esp+38h] [ebp-34h]
  unsigned int v28; // [esp+38h] [ebp-34h]
  unsigned int v29; // [esp+38h] [ebp-34h]
  int v30; // [esp+3Ch] [ebp-30h]
  wint_t wc; // [esp+48h] [ebp-24h] BYREF
  mbstate_t v34[4]; // [esp+4Ch] [ebp-20h] BYREF

  v22 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = __ctype_get_mb_cur_max() == 1;
  switch ( a5 )
  {
    case 2:
      if ( a2 )
        *a1 = 39;
      v22 = 1;
      v20 = L"'`";
      goto LABEL_5;
    case 3:
      if ( a2 )
        *a1 = 34;
      v22 = 1;
      v18 = 1;
      v20 = L"\"'`";
LABEL_5:
      v19 = 1;
      break;
    case 4:
      v18 = 1;
      break;
    case 5:
    case 6:
      v21 = sub_8048FA3((const char *)L"`", a5);
      v11 = sub_8048FA3((const char *)L"'`", a5);
      for ( i = *v21 == 0; !i; i = *v21 == 0 )
      {
        if ( v22 < a2 )
          a1[v22] = *v21;
        ++v21;
        ++v22;
      }
      v18 = 1;
      v20 = (__int16 *)v11;
      v19 = strlen(v11);
      break;
    default:
      break;
  }
  v30 = 0;
  if ( a4 == -1 )
    goto LABEL_33;
  while ( v30 != a4 )
  {
    while ( 1 )
    {
      if ( v19 != 0 && v18 != 0 && v19 + v30 <= a4 && !memcmp(&a3[v30], v20, v19) )
      {
        if ( v22 < a2 )
          a1[v22] = 92;
        ++v22;
      }
      v16 = a3[v30];
      switch ( v16 )
      {
        case 0u:
          v7 = v30 + 1;
          if ( !v18 )
            goto LABEL_30;
          if ( v22 < a2 )
            a1[v22] = 92;
          v27 = v22 + 1;
          if ( v27 < a2 )
            a1[v27] = 48;
          v28 = v27 + 1;
          if ( v28 < a2 )
            a1[v28] = 48;
          v22 = v28 + 1;
          v16 = 48;
          goto LABEL_52;
        case 7u:
          v10 = 97;
          goto LABEL_62;
        case 8u:
          v10 = 98;
          goto LABEL_62;
        case 9u:
          v10 = 116;
          goto LABEL_61;
        case 0xAu:
          v10 = 110;
          goto LABEL_61;
        case 0xBu:
          v10 = 118;
          goto LABEL_62;
        case 0xCu:
          v10 = 102;
          goto LABEL_62;
        case 0xDu:
          v10 = 114;
          goto LABEL_61;
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x24u:
        case 0x26u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Eu:
        case 0x5Bu:
        case 0x5Eu:
        case 0x60u:
        case 0x7Cu:
          goto LABEL_58;
        case 0x23u:
        case 0x7Eu:
          if ( v30 )
            goto LABEL_52;
LABEL_58:
          if ( a5 != 1 )
            goto LABEL_52;
          return sub_8048FF6(a1, a2, a3, a4, 2, a6);
        case 0x25u:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x3Du:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Du:
        case 0x5Fu:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
        case 0x7Bu:
        case 0x7Du:
          goto LABEL_52;
        case 0x27u:
          if ( a5 == 1 )
            return sub_8048FF6(a1, a2, a3, a4, 2, a6);
          if ( a5 == 2 )
          {
            if ( v22 < a2 )
              a1[v22] = 39;
            v25 = v22 + 1;
            if ( v25 < a2 )
              a1[v25] = 92;
            v26 = v25 + 1;
            if ( v26 < a2 )
              a1[v26] = 39;
LABEL_77:
            v22 = v26 + 1;
          }
          goto LABEL_52;
        case 0x3Fu:
          if ( a5 == 1 )
            return sub_8048FF6(a1, a2, a3, a4, 2, a6);
          if ( a5 == 3 && v30 + 2 < a4 && a3[v30 + 1] == 63 )
          {
            switch ( a3[v30 + 2] )
            {
              case '!':
              case '\'':
              case '(':
              case ')':
              case '-':
              case '/':
              case '<':
              case '=':
              case '>':
                v16 = a3[v30 + 2];
                v30 += 2;
                if ( v22 < a2 )
                  a1[v22] = 63;
                v29 = v22 + 1;
                if ( v29 < a2 )
                  a1[v29] = 92;
                v26 = v29 + 1;
                if ( v26 >= a2 )
                  goto LABEL_77;
                a1[v26] = 63;
                v22 = v26 + 1;
                break;
              default:
                goto LABEL_52;
            }
          }
          goto LABEL_52;
        case 0x5Cu:
          v10 = a3[v30];
LABEL_61:
          if ( a5 == 1 )
            return sub_8048FF6(a1, a2, a3, a4, 2, a6);
LABEL_62:
          v7 = v30 + 1;
          if ( !v18 )
            goto LABEL_30;
          v16 = v10;
          goto LABEL_54;
        default:
          if ( v17 )
          {
            v15 = 1;
            v14 = (*__ctype_b_loc())[v16] & 0x4000;
            if ( v14 == 0 && v18 != 0 )
              goto LABEL_17;
            goto LABEL_52;
          }
          v34[0].__count = 0;
          v34[0].__wch = 0;
          v15 = 0;
          v14 = 1;
          if ( a4 == -1 )
            a4 = strlen(a3);
          v13 = &a3[v30];
          break;
      }
      while ( 1 )
      {
        v9 = mbrtowc((wchar_t *)&wc, &a3[v15 + v30], a4 - (v15 + v30), v34);
        if ( !v9 )
          goto LABEL_50;
        if ( v9 == -1 )
        {
          v14 = 0;
          if ( v15 > 1 )
            goto LABEL_17;
          goto LABEL_51;
        }
        if ( v9 == -2 )
          break;
        v15 += v9;
        v14 = iswprint(wc) != 0 ? v14 : 0;
        if ( mbsinit(v34) )
          goto LABEL_50;
      }
      v14 = 0;
      if ( v15 + v30 < a4 && v13[v15] )
      {
        do
        {
          if ( ++v15 + v30 >= a4 )
            goto LABEL_50;
        }
        while ( v13[v15] );
        if ( v15 > 1 )
        {
LABEL_17:
          v6 = v15 + v30;
          while ( 1 )
          {
            if ( v14 == 0 && v18 != 0 )
            {
              if ( v22 < a2 )
                a1[v22] = 92;
              v23 = v22 + 1;
              if ( v23 < a2 )
                a1[v23] = (v16 >> 6) + 48;
              v24 = v23 + 1;
              if ( v24 < a2 )
                a1[v24] = ((v16 >> 3) & 7) + 48;
              v22 = v24 + 1;
              v16 = (v16 & 7) + 48;
            }
            v7 = v30 + 1;
            if ( v30 + 1 >= v6 )
              break;
            if ( v22 < a2 )
              a1[v22] = v16;
            ++v22;
            ++v30;
            v16 = a3[v7];
          }
          goto LABEL_30;
        }
      }
      else
      {
LABEL_50:
        if ( v15 > 1 )
          goto LABEL_17;
      }
LABEL_51:
      if ( v14 == 0 && v18 != 0 )
        goto LABEL_17;
LABEL_52:
      v7 = v30 + 1;
      if ( v18 && ((*(int *)(a6 + 4 * (v16 >> 5) + 4) >> (v16 & 0x1F)) & 1) != 0 )
      {
LABEL_54:
        if ( v22 < a2 )
          a1[v22] = 92;
        ++v22;
        v7 = v30 + 1;
      }
LABEL_30:
      if ( v22 < a2 )
        a1[v22] = v16;
      ++v22;
      v30 = v7;
      if ( a4 != -1 )
        break;
LABEL_33:
      if ( !a3[v30] )
        goto LABEL_34;
    }
  }
LABEL_34:
  if ( v20 )
  {
    while ( *(_BYTE *)v20 )
    {
      if ( v22 < a2 )
        a1[v22] = *(_BYTE *)v20;
      ++v22;
      v20 = (__int16 *)((char *)v20 + 1);
    }
  }
  if ( v22 < a2 )
    a1[v22] = 0;
  return v22;
}
// 804A588: using guessed type __int16 asc_804A588[4];

//----- (080496C3) --------------------------------------------------------
unsigned int __cdecl sub_80496C3(_BYTE *a1, unsigned int a2, const char *a3, unsigned int a4, int *a5)
{
  int *v5; // edi
  int *v6; // esi
  unsigned int result; // eax
  int v8; // [esp+0h] [ebp-10h]

  v5 = a5;
  if ( !a5 )
    v5 = &dword_804BB20;
  v6 = __errno_location();
  v8 = *v6;
  result = sub_8048FF6(a1, a2, a3, a4, *v5, (int)v5);
  *v6 = v8;
  return result;
}
// 804BB20: using guessed type int dword_804BB20;

//----- (08049721) --------------------------------------------------------
_BYTE *__usercall sub_8049721@<eax>(unsigned int a1@<eax>, const char *a2@<edx>, unsigned int a3, int *a4)
{
  unsigned int v4; // edi
  void *v5; // esi
  _BYTE *v6; // edi
  unsigned int v7; // eax
  int v8; // esi
  _BYTE *v9; // eax
  _DWORD *v11; // eax
  void *v12; // edx
  unsigned int sizea; // [esp+0h] [ebp-1Ch]
  size_t size; // [esp+0h] [ebp-1Ch]
  int v15; // [esp+4h] [ebp-18h]

  v15 = *__errno_location();
  if ( (a1 & 0x80000000) != 0 )
    abort();
  if ( dword_804B9DC <= a1 )
  {
    v4 = a1 + 1;
    if ( a1 + 1 > 0x1FFFFFFF )
      sub_8049D10();
    v5 = (void *)off_804B9E8;
    if ( (int *)off_804B9E8 == &dword_804B9E0 )
    {
      v11 = sub_8049DC5(8u);
      v12 = off_804B9E4;
      v5 = v11;
      off_804B9E8 = (int)v11;
      *v11 = dword_804B9E0;
      v11[1] = v12;
    }
    off_804B9E8 = (int)sub_8049E3F(v5, 8 * v4);
    memset((void *)(off_804B9E8 + 8 * dword_804B9DC), 0, 8 * (v4 - dword_804B9DC));
    dword_804B9DC = a1 + 1;
  }
  sizea = *(_DWORD *)(off_804B9E8 + 8 * a1);
  v6 = *(_BYTE **)(off_804B9E8 + 8 * a1 + 4);
  v7 = sub_80496C3(v6, sizea, a2, a3, a4);
  if ( sizea <= v7 )
  {
    v8 = off_804B9E8;
    size = v7 + 1;
    *(_DWORD *)(off_804B9E8 + 8 * a1) = v7 + 1;
    if ( v6 != (_BYTE *)&unk_804BA20 )
    {
      sub_8049FE0(v6);
      v8 = off_804B9E8;
    }
    v9 = sub_8049DC5(size);
    *(_DWORD *)(v8 + 8 * a1 + 4) = v9;
    v6 = v9;
    sub_80496C3(v9, size, a2, a3, a4);
  }
  *__errno_location() = v15;
  return v6;
}
// 804B9DC: using guessed type int dword_804B9DC;
// 804B9E0: using guessed type int dword_804B9E0;
// 804B9E4: using guessed type void *off_804B9E4;
// 804B9E8: using guessed type int off_804B9E8;

//----- (080498AE) --------------------------------------------------------
_BYTE *__cdecl sub_80498AE(int a1, const char *a2)
{
  return sub_8049721(a1, a2, 0xFFFFFFFF, &dword_804BB20);
}
// 804BB20: using guessed type int dword_804BB20;

//----- (08049905) --------------------------------------------------------
_DWORD *__usercall sub_8049905@<eax>(_DWORD *result@<eax>, int a2@<edx>)
{
  int v2[8]; // [esp+4h] [ebp-34h] BYREF

  memset(v2, 0, sizeof(v2));
  *result = a2;
  result[1] = v2[0];
  result[2] = v2[1];
  result[3] = v2[2];
  result[4] = v2[3];
  result[5] = v2[4];
  result[6] = v2[5];
  result[7] = v2[6];
  result[8] = v2[7];
  return result;
}

//----- (0804995F) --------------------------------------------------------
_BYTE *__cdecl sub_804995F(int a1, int a2, const char *a3)
{
  int v4[14]; // [esp+10h] [ebp-38h] BYREF

  sub_8049905(v4, a2);
  return sub_8049721(a1, a3, 0xFFFFFFFF, v4);
}
// 804995F: using guessed type int var_38[14];

//----- (080499F0) --------------------------------------------------------
_BYTE *__cdecl sub_80499F0(const char *a1, unsigned __int8 a2)
{
  int v3[14]; // [esp+0h] [ebp-38h] BYREF

  v3[0] = dword_804BB20;
  v3[1] = dword_804BB24[0];
  v3[2] = dword_804BB28;
  v3[3] = dword_804BB2C;
  v3[4] = dword_804BB30;
  v3[5] = dword_804BB34;
  v3[6] = dword_804BB38;
  v3[7] = dword_804BB3C;
  v3[8] = dword_804BB40;
  sub_8048F36((int)v3, a2, 1);
  return sub_8049721(0, a1, 0xFFFFFFFF, v3);
}
// 804BB20: using guessed type int dword_804BB20;
// 804BB24: using guessed type int dword_804BB24[];
// 804BB28: using guessed type int dword_804BB28;
// 804BB2C: using guessed type int dword_804BB2C;
// 804BB30: using guessed type int dword_804BB30;
// 804BB34: using guessed type int dword_804BB34;
// 804BB38: using guessed type int dword_804BB38;
// 804BB3C: using guessed type int dword_804BB3C;
// 804BB40: using guessed type int dword_804BB40;

//----- (08049A8B) --------------------------------------------------------
_BYTE *__cdecl sub_8049A8B(const char *a1)
{
  return sub_80499F0(a1, 0x3Au);
}

//----- (08049AC0) --------------------------------------------------------
int __cdecl sub_8049AC0(FILE *stream, int a2, int a3, int a4, __gnuc_va_list __varargs)
{
  int v5; // esi
  char *v6; // edx
  _DWORD *v7; // eax
  char *v8; // eax
  char *IO_write_ptr; // eax
  char *v10; // eax
  char *v11; // eax
  int result; // eax

  v5 = 0;
  v6 = (char *)__varargs + 4;
  v7 = __varargs;
  while ( *v7 )
  {
    v7 = v6;
    ++v5;
    v6 += 4;
  }
  if ( a2 )
    fprintf(stream, "%s (%s) %s\n", a2, a3, a4);
  else
    fprintf(stream, "%s %s\n", a3, a4);
  switch ( v5 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v8 = dcgettext(0, "Written by %s.\n", 5);
      break;
    case 2:
      v8 = dcgettext(0, "Written by %s and %s.\n", 5);
      break;
    case 3:
      v8 = dcgettext(0, "Written by %s, %s, and %s.\n", 5);
      break;
    case 4:
      v8 = dcgettext(0, "Written by %s, %s, %s,\nand %s.\n", 5);
      break;
    case 5:
      v8 = dcgettext(0, "Written by %s, %s, %s,\n%s, and %s.\n", 5);
      break;
    case 6:
      v8 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, and %s.\n", 5);
      break;
    case 7:
      v8 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", 5);
      break;
    case 8:
      v8 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n", 5);
      break;
    case 9:
      v8 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n", 5);
      break;
    default:
      v8 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n", 5);
      break;
  }
  vfprintf(stream, v8, __varargs);
  IO_write_ptr = stream->_IO_write_ptr;
  if ( IO_write_ptr >= stream->_IO_write_end )
  {
    __overflow(stream, 10);
  }
  else
  {
    *IO_write_ptr = 10;
    ++stream->_IO_write_ptr;
  }
  fputs_unlocked(version_etc_copyright, stream);
  v10 = stream->_IO_write_ptr;
  if ( v10 >= stream->_IO_write_end )
  {
    __overflow(stream, 10);
  }
  else
  {
    *v10 = 10;
    ++stream->_IO_write_ptr;
  }
  v11 = dcgettext(
          0,
          "This is free software; see the source for copying conditions.  There is NO\n"
          "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n",
          5);
  return fputs_unlocked(v11, stream);
}
// 8048904: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 804B9EC: using guessed type char *version_etc_copyright;

//----- (08049CCD) --------------------------------------------------------
int sub_8049CCD(FILE *stream, int a2, int a3, int a4, ...)
{
  va_list __varargs; // [esp+1Ch] [ebp+18h] BYREF

  va_start(__varargs, a4);
  return sub_8049AC0(stream, a2, a3, a4, __varargs);
}

//----- (08049D10) --------------------------------------------------------
void __noreturn sub_8049D10()
{
  char *v0; // eax

  if ( xalloc_fail_func )
    xalloc_fail_func();
  v0 = dcgettext(0, "memory exhausted", 5);
  error(exit_failure, 0, "%s", v0);
  abort();
}
// 804BB44: using guessed type void (*xalloc_fail_func)(void);

//----- (08049DC5) --------------------------------------------------------
void *__cdecl sub_8049DC5(size_t size)
{
  void *result; // eax

  result = malloc(size);
  if ( !result )
    sub_8049D10();
  return result;
}

//----- (08049E3F) --------------------------------------------------------
void *__cdecl sub_8049E3F(void *ptr, size_t size)
{
  void *result; // eax

  result = realloc(ptr, size);
  if ( !result )
    sub_8049D10();
  return result;
}

//----- (08049FE0) --------------------------------------------------------
void __cdecl sub_8049FE0(void *ptr)
{
  if ( ptr )
    free(ptr);
}

//----- (0804A008) --------------------------------------------------------
void __fastcall init(int a1, int a2)
{
  init_proc(a1, a2);
}

//----- (0804A05C) --------------------------------------------------------
void fini(void)
{
  term_proc();
}
// 804A08F: conditional instruction was optimized away because esi.4==FFFFFFFF

//----- (0804A0A0) --------------------------------------------------------
int __cdecl sub_804A0A0(void (__cdecl *lpfunc)(void *))
{
  void *v1; // eax

  v1 = 0;
  if ( &dword_804B9D0 )
    v1 = (void *)dword_804B9D0;
  return __cxa_atexit(lpfunc, 0, v1);
}
// 804B9D0: using guessed type _DWORD dword_804B9D0;

//----- (0804A0D0) --------------------------------------------------------
int __fastcall sub_804A0D0(int a1, int a2)
{
  void (**v2)(void); // ebx
  void (*i)(void); // eax

  v2 = (void (**)(void))&dword_804B82C;
  for ( i = (void (*)(void))dword_804B82C; i != (void (*)(void))-1; i = *v2 )
  {
    --v2;
    i();
  }
  return a2;
}
// 804B82C: using guessed type int dword_804B82C;

// nfuncs=90 queued=30 decompiled=30 lumina nreq=0 worse=0 better=0
// ALL OK, 30 function(s) have been successfully decompiled
