//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdint.h>
#include <stdio.h>

// ------------------- Function Prototypes --------------------

void c(void);
void f(void);

// --------------------- Global Variables ---------------------

int32_t b_c = 3; // 0x411030
int32_t c_d = 3; // 0x411034
int32_t c_f = 3; // 0x411040
int32_t c_h = 3; // 0x41104c
int32_t c_j = 3; // 0x411054
int32_t c_l = 3; // 0x411060
int32_t d_e = 3; // 0x411038
int32_t e_c = 3; // 0x41103c
int32_t f_g = 3; // 0x411044
int32_t g_f = 3; // 0x411048
int32_t h_i = 3; // 0x411050
int32_t j_k = 3; // 0x411058
int32_t k_e = 3; // 0x41105c
int32_t l_b = 3; // 0x411064
int32_t res = 0; // 0x41106c

// ------------------------ Functions -------------------------

// From module:   /mnt/from_boomerang/./recursion2/source.c
// Address range: 0x4005e0 - 0x400648
// Line range:    45 - 50
int main() {
    uint32_t v1 = b_c; // 0x4005f0
    b_c = v1 - 1;
    if (v1 >= 1) {
        // 0x400600
        c();
    }
    // 0x400604
    res += 2;
    printf("ecx is %d, edx is %d\n", 0, 0);
    printf("res is %d\n", (int64_t)res);
    return 0;
}

// From module:   /mnt/from_boomerang/./recursion2/source.c
// Address range: 0x400680 - 0x400878
// Line range:    59 - 67
// Demangled:     char
void c(void) {
    uint32_t v1 = c_d; // 0x40068c
    c_d = v1 - 1;
    if (v1 >= 1) {
        int32_t v2 = d_e; // 0x4006a0
        d_e = v2 - 1;
        int32_t v3; // 0x400680
        if (v2 < 1) {
            // 0x4006e0
            v3 = res;
        } else {
            uint32_t v4 = e_c; // 0x4006b8
            e_c = v4 - 1;
            if (v4 >= 1) {
                // 0x4006c8
                c();
            }
            int32_t v5 = res + 7; // 0x4006d4
            res = v5;
            v3 = v5;
        }
        // 0x4006e8
        res = v3 + 5;
    }
    uint32_t v6 = c_f; // 0x4006f8
    c_f = v6 - 1;
    if (v6 >= 1) {
        // 0x400708
        f();
    }
    uint32_t v7 = c_h; // 0x400710
    c_h = v7 - 1;
    if (v7 >= 1) {
        uint32_t v8 = h_i; // 0x400724
        int32_t v9 = res; // 0x40072c
        h_i = v8 - 1;
        int32_t v10 = v9; // 0x400738
        if (v8 >= 1) {
            // 0x40073c
            v10 = v9 + 19;
            res = v10;
        }
        // 0x400744
        res = v10 + 17;
    }
    uint32_t v11 = c_j; // 0x400750
    c_j = v11 - 1;
    if (v11 >= 1) {
        int32_t v12 = j_k; // 0x400764
        j_k = v12 - 1;
        int32_t v13; // 0x400680
        if (v12 < 1) {
            // 0x4007bc
            v13 = res;
        } else {
            int32_t v14 = k_e; // 0x40077c
            k_e = v14 - 1;
            int32_t v15; // 0x400680
            if (v14 < 1) {
                // 0x4007c8
                v15 = res;
            } else {
                uint32_t v16 = e_c; // 0x400794
                e_c = v16 - 1;
                if (v16 >= 1) {
                    // 0x4007a4
                    c();
                }
                int32_t v17 = res + 7; // 0x4007b0
                res = v17;
                v15 = v17;
            }
            int32_t v18 = v15 + 27; // 0x4007d0
            res = v18;
            v13 = v18;
        }
        // 0x4007dc
        res = v13 + 23;
    }
    int32_t v19 = c_l; // 0x4007ec
    c_l = v19 - 1;
    if (v19 < 1) {
        // 0x400864
        res += 3;
        return;
    }
    int32_t v20 = l_b; // 0x400804
    l_b = v20 - 1;
    int32_t v21; // 0x400680
    if (v20 < 1) {
        // 0x400850
        v21 = res;
    } else {
        uint32_t v22 = b_c; // 0x40081c
        b_c = v22 - 1;
        if (v22 >= 1) {
            // 0x40082c
            c();
        }
        int32_t v23 = res + 2; // 0x400838
        res = v23;
        v21 = v23;
    }
    int32_t v24 = v21 + 29; // 0x400858
    res = v24;
    // 0x400864
    res = v24 + 3;
}

// From module:   /mnt/from_boomerang/./recursion2/source.c
// Address range: 0x400918 - 0x400980
// Line range:    81 - 85
// Demangled:     float
void f(void) {
    int32_t v1 = f_g; // 0x40091c
    f_g = v1 - 1;
    if (v1 < 1) {
        // 0x400970
        res += 11;
        return;
    }
    uint32_t v2 = g_f; // 0x400934
    g_f = v2 - 1;
    if (v2 >= 1) {
        // 0x400944
        f();
    }
    int32_t v3 = res + 13; // 0x40095c
    res = v3;
    // 0x400970
    res = v3 + 11;
}

// --------------- Dynamically Linked Functions ---------------

// int printf(const char * restrict format, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: llvm (3.8.1)
// Detected functions: 3

