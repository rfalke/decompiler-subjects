// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

void g_v400000 = ??void??; // 00400000
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw406000 = 0x00; // 00406000
word32 g_dw406004 = 0x00; // 00406004
word32 g_dw406008 = 0x00; // 00406008
word32 g_dw406010 = 0x00; // 00406010
word32 g_dw406014 = 0x00; // 00406014
word32 g_dw40601C = 0x00; // 0040601C
word32 g_dw406020 = 0x00; // 00406020
word32 g_dw406024 = 0x00; // 00406024
ci8 g_b406030 = 0x4F; // 00406030
ci8 g_b406038 = 0x53; // 00406038
ci8 g_b406040 = 0x53; // 00406040
ci8 g_b406048 = 0x46; // 00406048
ci8 g_b406050 = 0x46; // 00406050
ci8 g_b406058 = 0x54; // 00406058
ci8 g_b406060 = 0x54; // 00406060
<anonymous> * g_ptr406068 = &g_t401F20; // 00406068
word32 g_dw40606C = 0x01; // 0040606C
Eq_559 g_t406070 = // 00406070
	{
		0x40506C0040507C
	};
Eq_559 g_t406074 = // 00406074
	{
		0x408D000040506C
	};
Eq_34 g_t406098 = // 00406098
	{
		0x00,
		0x00,
		0x00,
		0x02,
		
		{
			1
		},
		0x00,
	};
Eq_34 g_t4060B8 = // 004060B8
	{
		0x00,
		0x00,
		0x00,
		0x02,
		
		{
			2
		},
		0x00,
	};
byte g_a406380[5] = // 00406380
	{
		0x01,
		0x02,
		0x04,
		0x08,
		0x00,
	};
Eq_6385 g_a406388[6] = // 00406388
	{
		
		{
			
			{
				932
			},
		},
		
		{
			
			{
				936
			},
		},
		
		{
			
			{
				949
			},
		},
		
		{
			
			{
				950
			},
		},
		
		{
			
			{
				0x0551
			},
		},
		
		{
			
			{
				-1
			},
		},
	};
Eq_6393 g_a40638C[] = // 0040638C
	{
	};
Eq_6394 g_a406390[] = // 00406390
	{
	};
Eq_6395 g_a406394[] = // 00406394
	{
	};
Eq_3129 g_t406478 = // 00406478
	{
		~0x00,
	};
Eq_6404 g_a406498[19] = // 00406498
	{
		
		{
			0x02,
			
			{
				&g_t4052E8
			},
		},
		
		{
			0x08,
			
			{
				&g_t4052BC
			},
		},
		
		{
			0x09,
			
			{
				&g_t405290
			},
		},
		
		{
			0x0A,
			
			{
				&g_t40526C
			},
		},
		
		{
			0x10,
			
			{
				&g_t405240
			},
		},
		
		{
			0x11,
			
			{
				&g_t405210
			},
		},
		
		{
			0x12,
			
			{
				&g_t4051EC
			},
		},
		
		{
			0x13,
			
			{
				&g_t4051C0
			},
		},
		
		{
			0x18,
			
			{
				&g_t405188
			},
		},
		
		{
			0x19,
			
			{
				&g_t405160
			},
		},
		
		{
			0x1A,
			
			{
				&g_t405128
			},
		},
		
		{
			0x1B,
			
			{
				&g_t4050F0
			},
		},
		
		{
			0x1C,
			
			{
				&g_t4050C8
			},
		},
		
		{
			0x78,
			
			{
				&g_t4050B8
			},
		},
		
		{
			121,
			
			{
				&g_t4050A8
			},
		},
		
		{
			122,
			
			{
				&g_t405098
			},
		},
		
		{
			252,
			
			{
				&g_t405094
			},
		},
		
		{
			0xFF,
			
			{
				&g_t405084
			},
		},
		
		{
			0x00404130,
			
			{
				&g_t404130
			},
		},
	};
<anonymous> * g_ptr406528 = &g_t404130; // 00406528
<anonymous> * g_ptr40652C = &g_t404130; // 0040652C
<anonymous> * g_ptr406534 = &g_t404130; // 00406534
struct Eq_357 * g_ptr406540 = &g_t40654A; // 00406540
Eq_357 g_t40654A = // 0040654A
	{
		
		{
		},
	};
word32 g_dw406750 = 0x00406750; // 00406750
Eq_93 g_t406754 = // 00406754
	{
		&g_t406750
	};
word32 g_dw406760 = ~0x00; // 00406760
Eq_93 g_t408770 = // 00408770
	{
		&g_t406750
	};
Eq_93 g_t408774 = // 00408774
	{
		&g_t01E0
	};
Eq_93 g_t408780 = // 00408780
	{
		&g_t0001
	};
Eq_6425 g_a408790[46] = // 00408790
	{
		
		{
			
			{
				0x01
			},
			22,
		},
		
		{
			
			{
				0x02
			},
			0x02,
		},
		
		{
			
			{
				0x03
			},
			0x02,
		},
		
		{
			
			{
				0x04
			},
			0x18,
		},
		
		{
			
			{
				0x05
			},
			0x0D,
		},
		
		{
			
			{
				0x06
			},
			0x09,
		},
		
		{
			
			{
				0x07
			},
			0x0C,
		},
		
		{
			
			{
				0x08
			},
			0x0C,
		},
		
		{
			
			{
				0x09
			},
			0x0C,
		},
		
		{
			
			{
				0x0A
			},
			0x07,
		},
		
		{
			
			{
				11
			},
			0x08,
		},
		
		{
			
			{
				0x0C
			},
			22,
		},
		
		{
			
			{
				0x0D
			},
			22,
		},
		
		{
			
			{
				0x0F
			},
			0x02,
		},
		
		{
			
			{
				0x10
			},
			0x0D,
		},
		
		{
			
			{
				0x11
			},
			0x12,
		},
		
		{
			
			{
				0x12
			},
			0x02,
		},
		
		{
			
			{
				33
			},
			0x0D,
		},
		
		{
			
			{
				0x35
			},
			0x02,
		},
		
		{
			
			{
				0x41
			},
			0x0D,
		},
		
		{
			
			{
				0x43
			},
			0x02,
		},
		
		{
			
			{
				0x50
			},
			0x11,
		},
		
		{
			
			{
				0x52
			},
			0x0D,
		},
		
		{
			
			{
				0x53
			},
			0x0D,
		},
		
		{
			
			{
				0x57
			},
			22,
		},
		
		{
			
			{
				0x59
			},
			11,
		},
		
		{
			
			{
				0x6C
			},
			0x0D,
		},
		
		{
			
			{
				0x6D
			},
			0x20,
		},
		
		{
			
			{
				0x70
			},
			0x1C,
		},
		
		{
			
			{
				114
			},
			0x09,
		},
		
		{
			
			{
				0x06
			},
			22,
		},
		
		{
			
			{
				0x80
			},
			0x0A,
		},
		
		{
			
			{
				0x81
			},
			0x0A,
		},
		
		{
			
			{
				0x82
			},
			0x09,
		},
		
		{
			
			{
				131
			},
			22,
		},
		
		{
			
			{
				0x84
			},
			0x0D,
		},
		
		{
			
			{
				0x91
			},
			0x29,
		},
		
		{
			
			{
				0x9E
			},
			0x0D,
		},
		
		{
			
			{
				161
			},
			0x02,
		},
		
		{
			
			{
				0xA4
			},
			11,
		},
		
		{
			
			{
				0xA7
			},
			0x0D,
		},
		
		{
			
			{
				0xB7
			},
			0x11,
		},
		
		{
			
			{
				0xCE
			},
			0x02,
		},
		
		{
			
			{
				0xD7
			},
			11,
		},
		
		{
			
			{
				1816
			},
			0x0C,
		},
		
		{
			
			{
				0x00
			},
			0x00,
		},
	};
Eq_93 g_t4088F8 = // 004088F8
	{
		null
	};
word32 g_dw408900 = 0x00; // 00408900
word32 g_a408908[] = // 00408908
	{
	};
word32 g_dw408910 = 0x00; // 00408910
word32 g_dw408914 = 0x00; // 00408914
Eq_47 g_t408918 = // 00408918
	{
		0x00
	};
uint32 g_dw408920 = 0x00; // 00408920
uint32 g_dw408924 = 0x00; // 00408924
ui32 g_dw408928 = 0x00; // 00408928
uint32 g_dw40892C = 0x00; // 0040892C
uint32 g_dw408930 = 0x00; // 00408930
Eq_93 g_t408934 = // 00408934
	{
		null
	};
Eq_93 g_t40893C = // 0040893C
	{
		null
	};
Eq_93 g_t408940 = // 00408940
	{
		null
	};
word32 g_dw40894C = 0x00; // 0040894C
byte g_b408954 = 0x00; // 00408954
word32 g_dw408958 = 0x00; // 00408958
word32 g_dw40895C = 0x00; // 0040895C
word32 g_dw408A70 = 0x00; // 00408A70
Eq_3169 g_a408A78[] = // 00408A78
	{
	};
byte g_a408A7A[255] = // 00408A7A
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_111 g_t408B7C = // 00408B7C
	{
		0
	};
word32 g_dw408B80 = 0x00; // 00408B80
word32 g_dw408B88 = 0x00; // 00408B88
word32 g_dw408B8C = 0x00; // 00408B8C
word32 g_dw408B90 = 0x00; // 00408B90
word32 g_dw408B94 = 0x00; // 00408B94
<anonymous> * g_ptr408B98 = null; // 00408B98
word32 g_dw408BA8 = 0x00; // 00408BA8
Eq_111 g_t408BB8 = // 00408BB8
	{
		0
	};
word32 g_dw408BBC = 0x00; // 00408BBC
Eq_5671 g_t408BC0 = null; // 00408BC0
Eq_5671 g_t408BC4 = null; // 00408BC4
Eq_5671 g_t408BC8 = null; // 00408BC8
word32 g_dw408BCC = 0x00; // 00408BCC
<anonymous> * g_ptr408BD0 = null; // 00408BD0
Eq_2167 g_t408BD4 = null; // 00408BD4
Eq_93 g_t408BE0 = // 00408BE0
	{
		null
	};
Eq_93 g_a408BE4[] = // 00408BE4
	{
	};
Eq_111 g_t408CE0 = // 00408CE0
	{
		0
	};
up32 g_dw408CE4 = 0x00; // 00408CE4
word32 * g_ptr408CE8 = null; // 00408CE8
<anonymous> * g_ptr408CEC = null; // 00408CEC
Eq_93 g_t409D04 = // 00409D04
	{
		null
	};
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40A028 = 0xA288; // 0040A028
word32 g_dw40A02C = 0xA152; // 0040A02C
word32 g_dw40A030 = 0xA160; // 0040A030
word32 g_dw40A034 = 0xA16E; // 0040A034
word32 g_dw40A038 = 41346; // 0040A038
word32 g_dw40A03C = 41366; // 0040A03C
word32 g_dw40A040 = 41394; // 0040A040
word32 g_dw40A044 = 41416; // 0040A044
word32 g_dw40A048 = 41442; // 0040A048
word32 g_dw40A04C = 41468; // 0040A04C
word32 g_dw40A050 = 41492; // 0040A050
word32 g_dw40A054 = 0xA22E; // 0040A054
word32 g_dw40A058 = 0xA244; // 0040A058
word32 g_dw40A05C = 0xA250; // 0040A05C
word32 g_dw40A060 = 0xA25A; // 0040A060
word32 g_dw40A064 = 0xA266; // 0040A064
word32 g_dw40A068 = 0xA278; // 0040A068
word32 g_dw40A06C = 0xA140; // 0040A06C
word32 g_dw40A070 = 41622; // 0040A070
word32 g_dw40A074 = 0xA2A8; // 0040A074
word32 g_dw40A078 = 41654; // 0040A078
word32 g_dw40A07C = 41668; // 0040A07C
word32 g_dw40A080 = 0xA2D2; // 0040A080
word32 g_dw40A084 = 41694; // 0040A084
word32 g_dw40A088 = 0xA2EA; // 0040A088
word32 g_dw40A08C = 41718; // 0040A08C
word32 g_dw40A090 = 0xA302; // 0040A090
word32 g_dw40A094 = 41746; // 0040A094
word32 g_dw40A098 = 41764; // 0040A098
word32 g_dw40A09C = 0xA334; // 0040A09C
word32 g_dw40A0A0 = 0xA344; // 0040A0A0
word32 g_dw40A0A4 = 41816; // 0040A0A4
word32 g_dw40A0A8 = 0xA36A; // 0040A0A8
word32 g_dw40A0AC = 0xA37A; // 0040A0AC
<anonymous> * __imp__GetFileType = &g_tA288; // 0040A0B4
<anonymous> * __imp__GetVersion = &g_tA152; // 0040A0B8
<anonymous> * __imp__ExitProcess = &g_tA160; // 0040A0BC
<anonymous> * __imp__TerminateProcess = &g_tA16E; // 0040A0C0
<anonymous> * __imp__GetCurrentProcess = &g_tA182; // 0040A0C4
<anonymous> * __imp__UnhandledExceptionFilter = &g_tA196; // 0040A0C8
<anonymous> * __imp__GetModuleFileNameA = &g_tA1B2; // 0040A0CC
<anonymous> * __imp__FreeEnvironmentStringsA = &g_tA1C8; // 0040A0D0
<anonymous> * __imp__FreeEnvironmentStringsW = &g_tA1E2; // 0040A0D4
<anonymous> * __imp__GetEnvironmentStrings = &g_tA1FC; // 0040A0D8
<anonymous> * __imp__GetEnvironmentStringsW = &g_tA214; // 0040A0DC
<anonymous> * __imp__WideCharToMultiByte = &g_tA22E; // 0040A0E0
<anonymous> * __imp__GetCPInfo = &g_tA244; // 0040A0E4
<anonymous> * __imp__GetACP = &g_tA250; // 0040A0E8
<anonymous> * __imp__GetOEMCP = &g_tA25A; // 0040A0EC
<anonymous> * __imp__SetHandleCount = &g_tA266; // 0040A0F0
<anonymous> * __imp__GetStdHandle = &g_tA278; // 0040A0F4
<anonymous> * __imp__GetCommandLineA = &g_tA140; // 0040A0F8
<anonymous> * __imp__GetStartupInfoA = &g_tA296; // 0040A0FC
<anonymous> * __imp__HeapDestroy = &g_tA2A8; // 0040A100
<anonymous> * __imp__HeapCreate = &g_tA2B6; // 0040A104
<anonymous> * __imp__VirtualFree = &g_tA2C4; // 0040A108
<anonymous> * __imp__RtlUnwind = &g_tA2D2; // 0040A10C
<anonymous> * __imp__WriteFile = &g_tA2DE; // 0040A110
<anonymous> * __imp__HeapAlloc = &g_tA2EA; // 0040A114
<anonymous> * __imp__HeapFree = &g_tA2F6; // 0040A118
<anonymous> * __imp__VirtualAlloc = &g_tA302; // 0040A11C
<anonymous> * __imp__GetProcAddress = &g_tA312; // 0040A120
<anonymous> * __imp__LoadLibraryA = &g_tA324; // 0040A124
<anonymous> * __imp__GetLastError = &g_tA334; // 0040A128
<anonymous> * __imp__FlushFileBuffers = &g_tA344; // 0040A12C
<anonymous> * __imp__SetFilePointer = &g_tA358; // 0040A130
<anonymous> * __imp__SetStdHandle = &g_tA36A; // 0040A134
<anonymous> * __imp__CloseHandle = &g_tA37A; // 0040A138
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

CHAR g_t405084 = 'r'; // 00405084
CHAR g_t405094 = '\r'; // 00405094
CHAR g_t405098 = 'T'; // 00405098
CHAR g_t4050A8 = 'S'; // 004050A8
CHAR g_t4050B8 = 'D'; // 004050B8
CHAR g_t4050C8 = 'R'; // 004050C8
CHAR g_t4050F0 = 'R'; // 004050F0
CHAR g_t405128 = 'R'; // 00405128
CHAR g_t405160 = 'R'; // 00405160
CHAR g_t405188 = 'R'; // 00405188
CHAR g_t4051C0 = 'R'; // 004051C0
CHAR g_t4051EC = 'R'; // 004051EC
CHAR g_t405210 = 'R'; // 00405210
CHAR g_t405240 = 'R'; // 00405240
CHAR g_t40526C = '\r'; // 0040526C
CHAR g_t405290 = 'R'; // 00405290
CHAR g_t4052BC = 'R'; // 004052BC
CHAR g_t4052E8 = 'R'; // 004052E8
byte g_b405338 = 0x0A; // 00405338
Eq_6408 g_a40533C[] = // 0040533C
	{
	};
byte g_b405358 = 0x2E; // 00405358
Eq_6405 g_a40535C[] = // 0040535C
	{
	};
CHAR g_t405374 = 'G'; // 00405374
CHAR g_t405388 = 'G'; // 00405388
CHAR g_t405398 = 'M'; // 00405398
CHAR g_t4053A4 = 'u'; // 004053A4
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register word32 fn00401000(Stack uint32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401000(uint32 dwArg04)
{
	if (dwArg04 > 0x07)
	{
		fn004010A0(&g_b406030);
		return;
	}
	else
	{
		switch (dwArg04)
		{
		case 0x02:
			fn004010A0(&g_b406060);
			return;
		case 0x03:
			fn004010A0(&g_b406058);
			return;
		case 0x04:
			fn004010A0(&g_b406050);
			return;
		case 0x05:
			fn004010A0(&g_b406048);
			return;
		case 0x06:
			fn004010A0(&g_b406040);
			return;
		case 0x07:
			fn004010A0(&g_b406038);
			return;
		}
	}
}

// 004010A0: void fn004010A0(Stack (ptr32 ci8) dwArg04)
// Called from:
//      fn00401000
void fn004010A0(ci8 * dwArg04)
{
	word32 eax_12 = fn00401230(&g_t406098);
	fn00401330(dwArg04);
	fn004012D0(eax_12, &g_t406098);
}

// 004010E0: Register Eq_47 Win32CrtStartup()
Eq_47 Win32CrtStartup()
{
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	Eq_47 eax_30 = GetVersion();
	uint32 edx_35 = (uint32) SLICE(eax_30, byte, 8);
	g_dw40892C = edx_35;
	g_dw408928 = eax_30 & 0xFF;
	g_dw408924 = ((eax_30 & 0xFF) << 0x08) + edx_35;
	g_dw408920 = eax_30 >> 0x10;
	if (fn00402B80() == 0x00)
		fn00401200(0x1C);
	fn00402980();
	fn00402970();
	g_t409D04 = GetCommandLineA();
	Eq_93 eax_85 = fn00402540();
	g_t4088F8 = eax_85;
	if (eax_85 == 0x00 || g_t409D04 == 0x00)
		fn00401F00(~0x00);
	fn00402290();
	fn004021A0();
	fn00401ED0();
	g_t408940 = g_t40893C;
	Eq_47 eax_156 = fn00401F00(fn00401000(g_dw408930));
	fs->ptr0000 = eax_15;
	return eax_156;
}

// 00401200: Register word32 fn00401200(Stack word32 dwArg04)
// Called from:
//      Win32CrtStartup
//      fn004021A0
//      fn00402290
//      fn00402980
word32 fn00401200(word32 dwArg04)
{
	if (g_dw408900 != 0x02)
		fn00402D90();
	fn00402DD0(dwArg04);
	word32 ecx_34;
	g_ptr406068();
	return ecx_34;
}

// 00401230: Register word32 fn00401230(Stack (ptr32 Eq_34) dwArg04)
// Called from:
//      fn004010A0
word32 fn00401230(struct Eq_34 * dwArg04)
{
	if (fn00403060(dwArg04->t0010) == 0x00)
		return 0x00;
	ui32 edi_29;
	if (dwArg04 == &g_t406098)
		edi_29 = 0x00;
	else
	{
		if (dwArg04 != &g_t4060B8)
			return 0x00;
		edi_29 = 0x01;
	}
	++g_dw408910;
	if ((dwArg04->dw000C & 0x010C) != 0x00)
		return 0x00;
	if (g_a408908[edi_29 * 0x04] == 0x00)
	{
		word32 ecx_126;
		Eq_93 eax_50 = fn00402FB0(0x1000, out ecx_126);
		g_a408908[edi_29 * 0x04] = (word32) eax_50;
		if (eax_50 == 0x00)
			return 0x00;
	}
	word32 eax_73 = g_a408908[edi_29 * 0x04];
	dwArg04->dw0018 = 0x1000;
	dwArg04->dw0008 = eax_73;
	dwArg04->dw0000 = eax_73;
	ui32 eax_78 = dwArg04->dw000C;
	dwArg04->dw0004 = 0x1000;
	dwArg04->dw000C = eax_78 | 0x1102;
	return 0x01;
}

// 004012D0: void fn004012D0(Stack word32 dwArg04, Stack (ptr32 Eq_44) dwArg08)
// Called from:
//      fn004010A0
void fn004012D0(word32 dwArg04, struct Eq_44 * dwArg08)
{
	if (dwArg04 == 0x00)
	{
		if ((dwArg08->b000D & 0x10) != 0x00)
			fn004030E0(dwArg08);
	}
	else
	{
		if ((dwArg08->b000D & 0x10) == 0x00)
			return;
		fn004030E0(dwArg08);
		ui32 eax_48 = dwArg08->dw000C;
		dwArg08->dw0018 = 0x00;
		dwArg08->dw000C = SEQ(SLICE(eax_48, word16, 16), SLICE(eax_48, byte, 8) & ~0x11, (byte) eax_48);
		dwArg08->t0000.u0 = 0x00;
		dwArg08->t0008.u0 = 0x00;
	}
}

// 00401330: void fn00401330(Stack (ptr32 ci8) dwArg08)
// Called from:
//      fn004010A0
void fn00401330(ci8 * dwArg08)
{
	Eq_284 esp_100 = fp - 0x025C;
	struct Eq_288 * ecx_1257 = null;
	Eq_290 ebp_1318 = 0x00;
	ci8 bl_1219 = *dwArg08;
	struct Eq_296 * edi_1062 = dwArg08 + 1;
	if (bl_1219 != 0x00)
	{
		ui32 esi_1256 = dwLoc0234;
		while (*((word32) esp_100 + 28) >= 0x00)
		{
			ui32 eax_40;
			if (bl_1219 >= 0x20 && bl_1219 <= 0x78)
			{
				struct Eq_314 * eax_43 = (int32) bl_1219;
				eax_40 = SEQ(SLICE(eax_43, word24, 8), eax_43->b404FF0) & 0x0F;
			}
			else
				eax_40 = 0x00;
			int32 eax_56 = (int32) ecx_1257->a405010[eax_40].b0000;
			*((word32) esp_100 + 60) = eax_56 >> 0x04;
			if (eax_56 >> 0x04 <= 0x07)
			{
				switch (eax_56 >> 0x04)
				{
				case 0x00:
l00401530:
					struct Eq_357 * eax_1190 = g_ptr406540;
					*((word32) esp_100 + 44) = 0x00;
					if ((eax_1190->a0001[*((word32) esp_100 + 64) & 0xFF].b0000 & 0x80) != 0x00)
					{
						struct Eq_432 * edx_1199 = *((word32) esp_100 + 608);
						struct Eq_472 * esp_1204 = esp_100 - 4;
						esp_1204->t0000 = (word32) esp_100 + 28;
						esp_1204->ptrFFFFFFFC = edx_1199;
						esp_1204->tFFFFFFF8 = (int32) bl_1219;
						fn00401CC0(esp_1204->tFFFFFFF8, esp_1204->ptrFFFFFFFC, esp_1204->t0000);
						bl_1219 = edi_1062->b0000;
						esp_1204->ptr0268 = &edi_1062->b0001;
					}
					struct Eq_432 * edx_1227 = *((word32) esp_100 + 608);
					struct Eq_436 * esp_1231 = esp_100 - 4;
					esp_1231->t0000 = (word32) esp_100 + 28;
					esp_1231->ptrFFFFFFFC = edx_1227;
					esp_1231->tFFFFFFF8 = (int32) bl_1219;
					fn00401CC0(esp_1231->tFFFFFFF8, esp_1231->ptrFFFFFFFC, esp_1231->t0000);
					esp_100 = (char *) &esp_1231->t0000 + 4;
					break;
				case 0x01:
					*((word32) esp_100 + 0x0044) = 0x00;
					*((word32) esp_100 + 52) = 0x00;
					*((word32) esp_100 + 40) = 0x00;
					*((word32) esp_100 + 36) = 0x00;
					*((word32) esp_100 + 16) = 0x00;
					*((word32) esp_100 + 24) = ~0x00;
					*((word32) esp_100 + 44) = 0x00;
					break;
				case 0x02:
					Eq_406 eax_1134 = (int32) bl_1219;
					if (eax_1134 <= ~0x2F)
					{
						switch ((word32) eax_1134)
						{
						case 0x20:
							word32 eax_1174 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1174, word24, 8), (byte) eax_1174 | 0x02);
							break;
						case 33:
						case 0x22:
						case 0x24:
						case 0x25:
						case 0x26:
						case 0x27:
						case 0x28:
						case 0x29:
						case 0x2A:
						case 44:
						case 0x2E:
						case 0x2F:
							break;
						case 0x23:
							word32 eax_1166 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1166, word24, 8), (byte) eax_1166 | 0x80);
							break;
						case 0x2B:
							word32 eax_1158 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1158, word24, 8), (byte) eax_1158 | 0x01);
							break;
						case 0x2D:
							word32 eax_1150 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1150, word24, 8), (byte) eax_1150 | 0x04);
							break;
						case 0x30:
							word32 eax_1142 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1142, word24, 8), (byte) eax_1142 | 0x08);
							break;
						}
					}
					break;
				case 0x03:
					if (bl_1219 == 0x2A)
					{
						Eq_1736 esp_1114 = esp_100 - 4;
						*esp_1114 = (word32) esp_100 + 616;
						Eq_559 eax_1116 = fn00401D90(*esp_1114);
						*((word32) esp_1114 + 44) = eax_1116;
						esp_100 = (word32) esp_1114 + 4;
						if (eax_1116 < 0x00)
						{
							*((word32) esp_1114 + 20) |= 0x04;
							*((word32) esp_1114 + 44) = -eax_1116;
						}
					}
					else
						*((word32) esp_100 + 40) = (int32) bl_1219 - 0x30 + esi_1256 * 0x0A;
					break;
				case 0x04:
					*((word32) esp_100 + 24) = 0x00;
					break;
				case 0x05:
					if (bl_1219 == 0x2A)
					{
						Eq_1560 esp_1092 = esp_100 - 4;
						*esp_1092 = (word32) esp_100 + 616;
						Eq_559 eax_1094 = fn00401D90(*esp_1092);
						*((word32) esp_1092 + 28) = eax_1094;
						esp_100 = (word32) esp_1092 + 4;
						if (eax_1094 < 0x00)
							*((word32) esp_1092 + 28) = ~0x00;
					}
					else
						*((word32) esp_100 + 24) = (int32) bl_1219 - 0x30 + *((word32) esp_100 + 24) * 0x0A;
					break;
				case 0x06:
					Eq_418 eax_1028 = (int32) bl_1219;
					if (eax_1028 <= ~0x76)
					{
						switch ((word32) eax_1028)
						{
						case 0x49:
							if (edi_1062->b0000 != 0x36 || edi_1062->b0001 != 0x34)
							{
								*((word32) esp_100 + 60) = 0x00;
								goto l00401530;
							}
							ui32 eax_1073 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 612) = &edi_1062->b0001 + 1;
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1073, word16, 16), SLICE(eax_1073, byte, 8) | 0x80, (byte) eax_1073);
							break;
						case 0x4A:
						case 0x4B:
						case 0x4C:
						case 77:
						case 0x4E:
						case 0x4F:
						case 0x50:
						case 0x51:
						case 0x52:
						case 0x53:
						case 0x54:
						case 0x55:
						case 0x56:
						case 0x57:
						case 88:
						case 0x59:
						case 0x5A:
						case 0x5B:
						case 0x5C:
						case 0x5D:
						case 0x5E:
						case 0x5F:
						case 0x60:
						case 0x61:
						case 0x62:
						case 99:
						case 100:
						case 101:
						case 0x66:
						case 0x67:
						case 0x69:
						case 0x6A:
						case 0x6B:
						case 0x6D:
						case 110:
						case 111:
						case 0x70:
						case 113:
						case 114:
						case 115:
						case 116:
						case 117:
						case 118:
							break;
						case 0x68:
							ui32 eax_1053 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1053, word24, 8), (byte) eax_1053 | 0x20);
							break;
						case 0x6C:
							ui32 eax_1045 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1045, word24, 8), (byte) eax_1045 | 0x10);
							break;
						case 0x77:
							ui32 eax_1036 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_1036, word16, 16), SLICE(eax_1036, byte, 8) | 0x08, (byte) eax_1036);
							break;
						}
					}
					break;
				case 0x07:
					Eq_422 eax_65 = (int32) bl_1219;
					if (eax_65 <= ~0x77)
					{
						switch ((word32) eax_65)
						{
						case 0x43:
							ui32 eax_720 = *((word32) esp_100 + 16);
							byte ah_724 = SLICE(eax_720, byte, 8);
							byte al_728 = (byte) eax_720;
							word16 eax_16_16_729 = SLICE(eax_720, word16, 16);
							if ((eax_720 & 0x0830) == 0x00)
								*((word32) esp_100 + 16) = SEQ(eax_16_16_729, ah_724 | 0x08, al_728);
							goto l004015DA;
						case 0x44:
						case 0x46:
						case 0x48:
						case 0x49:
						case 0x4A:
						case 0x4B:
						case 0x4C:
						case 77:
						case 0x4E:
						case 0x4F:
						case 0x50:
						case 0x51:
						case 0x52:
						case 0x54:
						case 0x55:
						case 0x56:
						case 0x57:
						case 0x59:
						case 0x5B:
						case 0x5C:
						case 0x5D:
						case 0x5E:
						case 0x5F:
						case 0x60:
						case 0x61:
						case 0x62:
						case 0x68:
						case 0x6A:
						case 0x6B:
						case 0x6C:
						case 0x6D:
						case 113:
						case 114:
						case 116:
						case 118:
						case 0x77:
							goto l00401A50;
						case 0x45:
						case 0x47:
							*((word32) esp_100 + 0x0044) = 0x01;
							bl_1219 += 0x20;
							goto l004017A2;
						case 0x53:
							ui32 eax_458 = *((word32) esp_100 + 16);
							byte ah_462 = SLICE(eax_458, byte, 8);
							byte al_466 = (byte) eax_458;
							word16 eax_16_16_467 = SLICE(eax_458, word16, 16);
							if ((eax_458 & 0x0830) == 0x00)
								*((word32) esp_100 + 16) = SEQ(eax_16_16_467, ah_462 | 0x08, al_466);
							goto l004016BE;
						case 88:
							goto l004018A0;
						case 0x5A:
							struct Eq_551 * esp_122 = esp_100 - 4;
							esp_122->t0000 = (word32) esp_100 + 616;
							Eq_559 eax_124 = fn00401D90(esp_122->t0000);
							esp_100 = (char *) &esp_122->t0000 + 4;
							if (eax_124 != 0x00)
							{
								Eq_559 ecx_134 = *((word64) eax_124 + 4);
								if (ecx_134 != 0x00)
								{
									if ((esp_122->b0015 & 0x08) != 0x00)
									{
										Eq_745 ebp_168 = (int32) *eax_124;
										esp_122->t0018 = ecx_134;
										esp_122->dw0030 = 0x01;
										ebp_1318 = ebp_168 >> 0x01;
									}
									else
									{
										ebp_1318.u0 = (int32) *eax_124;
										esp_122->dw0030 = 0x00;
										esp_122->t0018 = ecx_134;
									}
									goto l00401A50;
								}
							}
							Eq_559 edi_139 = g_t406070;
							esp_122->t0018 = edi_139;
							word32 ecx_141 = ~0x00;
							while (ecx_141 != 0x00)
							{
								edi_139 = (word32) edi_1795 + 1;
								--ecx_141;
								edi_1795 = edi_139;
								if (*edi_1795 != 0x00)
									break;
							}
							ebp_1318 = ~ecx_141 - 0x01;
							goto l00401A50;
						case 99:
l004015DA:
							if ((*((word32) esp_100 + 16) & 0x0810) != 0x00)
							{
								struct Eq_1350 * esp_752 = esp_100 - (struct Eq_1351 *) 4;
								Mem753[esp_752 + 0x00:word32] = esp_100 + 616;
								esp_752->dw0000 = (int32) fn00401DD0(esp_752->dw0000);
								Mem766[esp_752 + -4:word32] = esp_752 + 0x60;
								Eq_290 eax_767 = fn004031E0(esp_752->dwFFFFFFFC, esp_752->dw0000);
								ebp_1318 = eax_767;
								esp_100 = esp_752 + 1;
								if (eax_767 < 0x00)
								{
									esp_752[0x0E] = (struct Eq_1350) 0x01;
									esp_752[6] = (struct Eq_1350) (esp_752 + 24);
									goto l00401A50;
								}
							}
							else
							{
								struct Eq_1332 * esp_738 = esp_100 - (struct Eq_1333 *) 4;
								Mem739[esp_738 + 0x00:word32] = esp_100 + 616;
								esp_738[24] = (struct Eq_1332) (byte) fn00401D90(esp_738->dw0000);
								ebp_1318.u0 = 0x01;
							}
							*((word32) esp_100 + 20) = (word32) esp_100 + 92;
							goto l00401A50;
						case 100:
						case 0x69:
							ui32 eax_112 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 48) = 0x0A;
							*((word32) esp_100 + 16) = SEQ(SLICE(eax_112, word24, 8), (byte) eax_112 | 0x40);
							break;
						case 101:
						case 0x66:
						case 0x67:
l004017A2:
							ui32 edx_565 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 20) = (word32) esp_100 + 92;
							int32 eax_568 = *((word32) esp_100 + 24);
							*((word32) esp_100 + 16) = edx_565 | 0x40;
							if (eax_568 < 0x00)
								*((word32) esp_100 + 24) = 0x06;
							else if (eax_568 == 0x00 && bl_1219 == 0x67)
								*((word32) esp_100 + 24) = 0x01;
							struct Eq_1266 * eax_582 = *((word32) esp_100 + 616);
							Eq_93 edi_583 = *((word32) esp_100 + 24);
							*((word32) esp_100 + 616) = &eax_582->dw0004 + 1;
							*((word32) esp_100 + 76) = eax_582->dw0000;
							Eq_440 eax_590 = *((word32) esp_100 + 0x0044);
							*((word32) esp_100 + 80) = eax_582->dw0004;
							struct Eq_1295 * esp_594 = esp_100 - (struct Eq_1296 *) 4;
							esp_594->dw0000 = (int32) eax_590;
							esp_594->dwFFFFFFFC = (word32) edi_583;
							Eq_290 ecx_593 = (int32) bl_1219;
							esp_594->tFFFFFFF8 = ecx_593;
							Mem603[esp_594 + -0x0C:word32] = esp_594 + 0x60;
							Mem605[esp_594 + -16:word32] = esp_594 + 0x50;
							struct Eq_1319 * esp_631;
							g_ptr406528();
							ui32 esi_637 = esp_631->dw0024;
							esp_100 = &esp_631->ptr0010 + 1;
							if ((esi_637 & 0x80) != 0x00 && edi_583 == 0x00)
							{
								esp_631->ptr0010 = &esp_631->dw0024 + 19;
								word32 esp_649;
								word32 edx_652;
								g_ptr406534();
								esp_100 = esp_649 + 0x04;
							}
							if (bl_1219 == 0x67 && (esi_637 & 0x80) == 0x00)
							{
								Eq_1444 edx_665 = (word32) esp_100 + 92;
								*((word32) esp_100 - 4) = edx_665;
								word32 esp_673;
								g_ptr40652C();
								esp_100 = esp_673 + 0x04;
							}
							if (*((word32) esp_100 + 92) == 0x2D)
							{
								word32 eax_686 = *((word32) esp_100 + 16);
								*((word32) esp_100 + 16) = SEQ(SLICE(eax_686, word16, 16), SLICE(eax_686, byte, 8) | 0x01, (byte) eax_686);
								*((word32) esp_100 + 20) = (word32) esp_100 + 93;
							}
							byte * edi_699 = *((word32) esp_100 + 20);
							word32 ecx_703 = ~0x00;
							while (ecx_703 != 0x00)
							{
								edi_699 = edi_1798 + 1;
								--ecx_703;
								edi_1798 = edi_699;
								if (*edi_1798 != 0x00)
									break;
							}
							ebp_1318 = ~ecx_703 - 0x01;
							goto l00401A50;
						case 110:
							struct Eq_614 * esp_91 = esp_100 - 4;
							esp_91->t0000 = (word32) esp_100 + 616;
							Eq_559 eax_93 = fn00401D90(esp_91->t0000);
							esp_100 = (char *) &esp_91->t0000 + 4;
							if ((esp_91->b0014 & 0x20) != 0x00)
							{
								Eq_736 cx_107 = esp_91->t0020;
								esp_91->dw0038 = 0x01;
								*eax_93 = cx_107;
							}
							else
							{
								Eq_736 edx_104 = esp_91->t0020;
								esp_91->dw0038 = 0x01;
								*eax_93 = edx_104;
							}
							goto l00401A50;
						case 111:
							Eq_637 al_76 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 48) = 0x08;
							if ((al_76 & 0x80) != 0x00)
							{
								word32 eax_81 = *((word32) esp_100 + 16);
								*((word32) esp_100 + 16) = SEQ(SLICE(eax_81, word16, 16), SLICE(eax_81, byte, 8) | 0x02, (byte) eax_81);
							}
							break;
						case 0x70:
							*((word32) esp_100 + 24) = 0x08;
l004018A0:
							*((word32) esp_100 + 56) = 0x07;
							goto l004018B2;
						case 115:
l004016BE:
							word32 eax_472 = *((word32) esp_100 + 24);
							word32 esi_473 = 0x7FFFFFFF;
							if (eax_472 != ~0x00)
								esi_473 = eax_472;
							struct Eq_1114 * esp_479 = esp_100 - (struct Eq_1115 *) 4;
							Mem480[esp_479 + 0x00:word32] = esp_100 + 616;
							Eq_559 eax_481 = fn00401D90(esp_479->t0000);
							ui32 eax_488 = esp_479[5];
							esp_479[6] = (struct Eq_1114) eax_481;
							Eq_559 ecx_487 = eax_481;
							esp_100 = esp_479 + 0x04;
							if ((eax_488 & 0x0810) != 0x00)
							{
								if (eax_481 == 0x00)
								{
									ecx_487 = g_t406074;
									esp_479[6] = (struct Eq_1114) ecx_487;
								}
								esp_479[0x0C] = (struct Eq_1114) 0x01;
								word32 esi_532 = esi_473 - 0x01;
								Eq_559 eax_538 = ecx_487;
								if (esi_473 != 0x00)
								{
									while (*eax_538 != 0x00)
									{
										eax_538 = (word64) eax_538 + 2;
										esi_532 = esi_1797 - 0x01;
										esi_1797 = esi_532;
										if (esi_1797 == 0x00)
											break;
									}
								}
								ebp_1318 = eax_538 - ecx_487 >> 0x01;
							}
							else
							{
								if (eax_481 == 0x00)
								{
									ecx_487 = g_t406070;
									esp_479[6] = (struct Eq_1114) ecx_487;
								}
								word32 esi_502 = esi_473 - 0x01;
								Eq_559 eax_506 = ecx_487;
								if (esi_473 != 0x00)
								{
									while (*eax_506.u1 != 0x00)
									{
										++eax_506.u1;
										esi_502 = esi_1796 - 0x01;
										esi_1796 = esi_502;
										if (esi_1796 == 0x00)
											break;
									}
								}
								ebp_1318 = eax_506 - ecx_487;
							}
							goto l00401A50;
						case 117:
							*((word32) esp_100 + 48) = 0x0A;
							break;
						case 0x78:
							*((word32) esp_100 + 56) = 0x27;
l004018B2:
							byte al_177 = *((word32) esp_100 + 16);
							*((word32) esp_100 + 48) = 0x10;
							if ((al_177 & 0x80) != 0x00)
							{
								Eq_775 cl_182 = *((word32) esp_100 + 56);
								*((word32) esp_100 + 0x0022) = 0x30;
								*((word32) esp_100 + 36) = 0x02;
								*((word32) esp_100 + 35) = (word32) cl_182 + 81;
							}
							break;
						}
						Eq_559 eax_205;
						Eq_760 edx_212;
						ui32 ebx_190 = *((word32) esp_100 + 16);
						byte bh_191 = SLICE(ebx_190, byte, 8);
						byte bl_195 = (byte) ebx_190;
						word16 ebx_16_16_307 = SLICE(ebx_190, word16, 16);
						if ((bh_191 & 0x80) != 0x00)
						{
							struct Eq_2091 *** esp_259 = esp_100 - 4;
							*esp_259 = (word32) esp_100 + 616;
							eax_205 = fn00401DB0(*esp_259, out edx_212);
						}
						else if ((bl_195 & 0x20) != 0x00)
						{
							if ((bl_195 & 0x40) != 0x00)
							{
								union Eq_440 * esp_245 = esp_100 - 4;
								*esp_245 = (word32) esp_100 + 616;
								int64 edx_eax_257 = (int64) (int32) (word16) fn00401D90(*esp_245);
								edx_212 = SLICE(edx_eax_257, word32, 32);
								eax_205 = (word32) edx_eax_257;
							}
							else
							{
								union Eq_440 * esp_231 = esp_100 - 4;
								*esp_231 = (word32) esp_100 + 616;
								int64 edx_eax_243 = (int64) (fn00401D90(*esp_231) & 0xFFFF);
								edx_212 = SLICE(edx_eax_243, word32, 32);
								eax_205 = (word32) edx_eax_243;
							}
						}
						else if ((bl_195 & 0x40) != 0x00)
						{
							union Eq_440 * esp_216 = esp_100 - 4;
							*esp_216 = (word32) esp_100 + 616;
							int64 edx_eax_226 = (int64) fn00401D90(*esp_216);
							edx_212 = SLICE(edx_eax_226, word32, 32);
							eax_205 = (word32) edx_eax_226;
						}
						else
						{
							union Eq_440 * esp_203 = esp_100 - 4;
							*esp_203 = (word32) esp_100 + 616;
							eax_205 = fn00401D90(*esp_203);
							edx_212.u0 = 0x00;
						}
						Eq_760 edi_290;
						Eq_559 esi_288;
						if ((bl_195 & 0x40) != 0x00 && (edx_212 <= 0x00 && (edx_212 < 0x00 || Test(ULT,false))))
						{
							*((word32) esp_100 + 16) = SEQ(ebx_16_16_307, bh_191 | 0x01, bl_195);
							Eq_559 eax_292 = -eax_205;
							esi_288 = eax_292;
							bh_191 |= 0x01;
							edi_290 = -((word32) edx_212.u0 + (eax_292 == 0x00));
						}
						else
						{
							esi_288 = eax_205;
							edi_290 = edx_212;
						}
						ui32 ebx_337 = SEQ(ebx_16_16_307, bh_191, bl_195);
						if ((bh_191 & 0x80) == 0x00)
							edi_290.u0 = 0x00;
						int32 ecx_1273 = *((word32) esp_100 + 24);
						if (ecx_1273 < 0x00)
							ecx_1273 = 0x01;
						else
							*((word32) esp_100 + 16) = ebx_337 & ~0x08;
						if ((esi_288 | edi_290) == 0x00)
							*((word32) esp_100 + 36) = 0x00;
						struct Eq_979 * eax_356 = (word32) esp_100 + 603;
						*((word32) esp_100 + 20) = eax_356;
						while (true)
						{
							*((word32) esp_100 + 24) = ecx_1273 - 0x01;
							if (ecx_1273 <= 0x00 && (esi_288 | edi_290) == 0x00)
								break;
							int64 edx_eax_398 = (int64) *((word32) esp_100 + 48);
							uint32 edx_402 = SLICE(edx_eax_398, word32, 32);
							struct Eq_996 * esp_401 = esp_100 - 4;
							esp_401->dw0000 = edx_402;
							Eq_559 eax_399 = (word32) edx_eax_398;
							esp_401->tFFFFFFFC = eax_399;
							esp_401->tFFFFFFF8 = edi_290;
							esp_401->tFFFFFFF4 = esi_288;
							esp_401->dw005C = edx_402;
							int32 eax_413 = fn004032D0(esp_401->tFFFFFFF4, esp_401->tFFFFFFFC);
							esp_401->dw0000 = esp_401->dw005C;
							esp_401->tFFFFFFFC = eax_399;
							esp_401->tFFFFFFF8 = edi_290;
							esp_401->tFFFFFFF4 = esi_288;
							byte bl_451 = (byte) eax_413 + 0x30;
							Eq_760 edx_435;
							esi_288 = fn00403260(esp_401->tFFFFFFF4, esp_401->tFFFFFFF8, esp_401->tFFFFFFFC, esp_401->dw0000, out edx_435);
							edi_290 = edx_435;
							if (eax_413 > 0x09)
								bl_451 = (byte) eax_413 + 0x30 + esp_401->b003C;
							byte * eax_449 = esp_401->ptr0018;
							ecx_1273 = esp_401->dw001C;
							*eax_449 = bl_451;
							esp_401->ptr0018 = eax_449 - 0x01;
							eax_356 = eax_449 - 0x01;
						}
						byte ch_377 = *((word32) esp_100 + 0x0011);
						struct Eq_1078 * eax_376 = (char *) &eax_356->t0000 + 1;
						*((word32) esp_100 + 20) = eax_376;
						ebp_1318 = esp_100 + 0x025B - eax_356;
						if ((ch_377 & 0x02) != 0x00 && (eax_376->b0000 != 0x30 || ebp_1318 == 0x00))
						{
							*((word32) esp_100 + 20) = eax_376 - 0x01;
							eax_376->bFFFFFFFF = 0x30;
							ebp_1318 = (word32) ebp_1318.u0 + 1;
						}
					}
l00401A50:
					if (*((word32) esp_100 + 52) == 0x00)
					{
						word32 ebx_805 = *((word32) esp_100 + 16);
						byte bl_806 = (byte) ebx_805;
						byte bh_810 = SLICE(ebx_805, byte, 8);
						if ((bl_806 & 0x40) != 0x00)
						{
							if ((bh_810 & 0x01) != 0x00)
							{
								*((word32) esp_100 + 0x0022) = 0x2D;
								goto l00401A87;
							}
							if ((bl_806 & 0x01) != 0x00)
							{
								*((word32) esp_100 + 0x0022) = 0x2B;
								goto l00401A87;
							}
							if ((bl_806 & 0x02) != 0x00)
							{
								*((word32) esp_100 + 0x0022) = 0x20;
l00401A87:
								*((word32) esp_100 + 36) = 0x01;
							}
						}
						word32 esi_840;
						Eq_290 edi_834 = *((word32) esp_100 + 40) - *((word32) esp_100 + 36) - ebp_1318;
						if ((bl_806 & 0x0C) == 0x00)
						{
							esi_840 = (word32) *((word32) esp_100 + 608);
							Eq_1599 esp_843 = esp_100 - 4;
							*esp_843 = (word32) esp_100 + 28;
							*((word32) esp_843 - 4) = esi_840;
							*((word32) esp_843 - 8) = edi_834;
							((word32) esp_843 - 0x0C)->u0 = 0x20;
							fn00401D10(*((word32) esp_843 - 0x0C), *((word32) esp_843 - 8), *((word32) esp_843 - 4), *esp_843);
						}
						else
							esi_840 = (word32) *((word32) esp_100 + 608);
						Eq_290 edx_862 = *((word32) esp_100 + 36);
						Eq_1640 esp_864 = esp_100 - 4;
						*esp_864 = (word32) esp_100 + 28;
						*((word32) esp_864 - 4) = esi_840;
						*((word32) esp_864 - 8) = edx_862;
						*((word32) esp_864 - 0x0C) = (word32) esp_864 + 38;
						fn00401D50(*((word32) esp_864 - 0x0C), *((word32) esp_864 - 8), *((word32) esp_864 - 4), *esp_864);
						if ((bl_806 & 0x08) != 0x00 && (bl_806 & 0x04) == 0x00)
						{
							*esp_864 = (word32) esp_864 + 32;
							*((word32) esp_864 - 4) = esi_840;
							*((word32) esp_864 - 8) = edi_834;
							((word32) esp_864 - 0x0C)->u0 = 0x30;
							fn00401D10(*((word32) esp_864 - 0x0C), *((word32) esp_864 - 8), *((word32) esp_864 - 4), *esp_864);
						}
						word32 eax_910 = *((word32) esp_100 + 44);
						word16 eax_16_16_1371 = SLICE(eax_910, word16, 16);
						if (eax_910 != 0x00 && ebp_1318 > 0x00)
						{
							word16 * esi_942 = *((word32) esp_100 + 20);
							Eq_1810 ebx_943 = ebp_1318 - 0x01;
							do
							{
								Eq_1817 esp_949 = esp_100 - 4;
								*esp_949 = SEQ(eax_16_16_1371, *esi_942);
								*((word32) esp_949 - 4) = (word32) esp_100 + 72;
								++esi_942;
								Eq_290 eax_957 = fn004031E0(*((word32) esp_949 - 4), *esp_949);
								if (eax_957 <= 0x00)
									break;
								struct Eq_432 * edx_967 = *((word32) esp_949 + 612);
								*esp_949 = (word32) esp_949 + 32;
								*((word32) esp_949 - 4) = edx_967;
								*((word32) esp_949 - 8) = eax_957;
								*((word32) esp_949 - 0x0C) = (word32) esp_949 + 76;
								eax_16_16_1371 = SLICE(fn00401D50(*((word32) esp_949 - 0x0C), *((word32) esp_949 - 8), *((word32) esp_949 - 4), *esp_949), word16, 16);
								ebx_943 = ebx_1799 - 0x01;
								ebx_1799 = ebx_943;
							} while (ebx_1799 != 0x00);
							bl_806 = (byte) *((word32) esp_100 + 16);
						}
						else
						{
							Eq_447 eax_920 = *((word32) esp_100 + 20);
							Eq_1773 esp_922 = esp_100 - 4;
							*esp_922 = (word32) esp_100 + 28;
							*((word32) esp_922 - 4) = esi_840;
							*((word32) esp_922 - 8) = ebp_1318;
							*((word32) esp_922 - 0x0C) = eax_920;
							fn00401D50(*((word32) esp_922 - 0x0C), *((word32) esp_922 - 8), *((word32) esp_922 - 4), *esp_922);
						}
						if ((bl_806 & 0x04) != 0x00)
						{
							word32 edx_1004 = *((word32) esp_100 + 608);
							Eq_1888 esp_1006 = esp_100 - 4;
							*esp_1006 = (word32) esp_100 + 28;
							*((word32) esp_1006 - 4) = edx_1004;
							*((word32) esp_1006 - 8) = edi_834;
							((word32) esp_1006 - 0x0C)->u0 = 0x20;
							fn00401D10(*((word32) esp_1006 - 0x0C), *((word32) esp_1006 - 8), *((word32) esp_1006 - 4), *esp_1006);
							esp_100 = (word32) esp_1006 + 4;
						}
					}
					break;
				}
			}
			ci8 * edi_1248 = *((word32) esp_100 + 612);
			bl_1219 = *edi_1248;
			*((word32) esp_100 + 64) = bl_1219;
			*((word32) esp_100 + 612) = edi_1248 + 1;
			edi_1062 = (struct Eq_296 *) (edi_1248 + 1);
			if (bl_1219 == 0x00)
				return;
			esi_1256 = (ui32) *((word32) esp_100 + 40);
			ecx_1257 = (struct Eq_288 *) *((word32) esp_100 + 60);
		}
	}
}

// 00401CC0: void fn00401CC0(Stack Eq_447 dwArg04, Stack (ptr32 Eq_432) dwArg08, Stack Eq_440 dwArg0C)
// Called from:
//      fn00401330
//      fn00401D10
//      fn00401D50
void fn00401CC0(Eq_447 dwArg04, struct Eq_432 * dwArg08, Eq_440 dwArg0C)
{
	ui32 eax_16;
	int32 eax_6 = dwArg08->dw0004;
	dwArg08->dw0004 = eax_6 - 0x01;
	if (eax_6 >= 0x01)
	{
		*dwArg08->t0000 = (byte) dwArg04;
		dwArg08->t0000 = (word32) dwArg08->t0000 + 1;
		eax_16 = dwArg04 & 0xFF;
	}
	else
		eax_16 = fn00403350(dwArg04, dwArg08);
	if (eax_16 != ~0x00)
		*dwArg0C = (word32) *dwArg0C + 1;
	else
		*dwArg0C = eax_16;
}

// 00401D10: void fn00401D10(Stack Eq_447 dwArg04, Stack Eq_290 dwArg08, Stack (ptr32 Eq_432) dwArg0C, Stack Eq_440 dwArg10)
// Called from:
//      fn00401330
void fn00401D10(Eq_447 dwArg04, Eq_290 dwArg08, struct Eq_432 * dwArg0C, Eq_440 dwArg10)
{
	int32 ebp_15 = dwArg08 - 0x01;
	if (dwArg08 > 0x00)
	{
		do
		{
			fn00401CC0(dwArg04, dwArg0C, dwArg10);
			if (*dwArg10 == ~0x00)
				return;
			ebp_15 = ebp_99 - 0x01;
			ebp_99 = ebp_15;
		} while (ebp_99 > 0x00);
	}
}

// 00401D50: Register Eq_290 fn00401D50(Stack Eq_447 dwArg04, Stack Eq_290 dwArg08, Stack (ptr32 Eq_432) dwArg0C, Stack Eq_440 dwArg10)
// Called from:
//      fn00401330
Eq_290 fn00401D50(Eq_447 dwArg04, Eq_290 dwArg08, struct Eq_432 * dwArg0C, Eq_440 dwArg10)
{
	Eq_290 eax_14 = dwArg08;
	int32 ebp_15 = dwArg08 - 0x01;
	if (dwArg08 > 0x00)
	{
		Eq_447 esi_23 = dwArg04;
		do
		{
			fn00401CC0((int32) *esi_23, dwArg0C, dwArg10);
			esi_23 = (word32) esi_23 + 1;
			eax_14 = *dwArg10;
			if (eax_14 == ~0x00)
				return eax_14;
			ebp_15 = ebp_103 - 0x01;
			ebp_103 = ebp_15;
		} while (ebp_103 > 0x00);
	}
	return eax_14;
}

// 00401D90: Register word32 fn00401D90(Stack Eq_440 dwArg04)
// Called from:
//      fn00401330
word32 fn00401D90(Eq_440 dwArg04)
{
	word32 * ecx_6 = *dwArg04;
	*dwArg04 = ecx_6 + 1;
	return *ecx_6;
}

// 00401DB0: Register word32 fn00401DB0(Stack (ptr32 (ptr32 Eq_2091)) dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00401330
word32 fn00401DB0(struct Eq_2091 ** dwArg04, ptr32 & edxOut)
{
	struct Eq_2091 * ecx_6 = *dwArg04;
	*dwArg04 = (struct Eq_2091 **) (&ecx_6->ptr0004 + 1);
	word32 eax_10 = ecx_6->dw0000;
	edxOut = ecx_6->ptr0004;
	return eax_10;
}

// 00401DD0: Register word32 fn00401DD0(Stack Eq_440 dwArg04)
// Called from:
//      fn00401330
word32 fn00401DD0(Eq_440 dwArg04)
{
	word16 * ecx_6 = *dwArg04;
	*dwArg04 = ecx_6 + 2;
	return SEQ(SLICE(ecx_6 + 2, word16, 16), *ecx_6);
}

// 00401ED0: void fn00401ED0()
// Called from:
//      Win32CrtStartup
void fn00401ED0()
{
	<anonymous> * eax_5 = g_ptr408CEC;
	if (eax_5 != null)
		eax_5();
	fn00401FF0(&g_dw406008, &g_dw406010);
	fn00401FF0(&g_dw406000, &g_dw406004);
}

// 00401F00: Register word32 fn00401F00(Stack Eq_111 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401F00(Eq_111 dwArg04)
{
	return fn00401F40(dwArg04, 0x00, 0x00);
}

<anonymous> g_t401F20 = <code>; // 00401F20
// 00401F40: Register word32 fn00401F40(Stack Eq_111 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00401F00
word32 fn00401F40(Eq_111 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (g_dw40895C == 0x01)
		TerminateProcess(GetCurrentProcess(), dwArg04);
	g_dw408958 = 0x01;
	g_b408954 = (byte) dwArg0C;
	ptr32 esp_25 = fp - 0x0C;
	if (dwArg08 == 0x00)
	{
		word32 * ecx_35 = g_ptr408CE8;
		if (ecx_35 != null)
		{
			up32 esi_39 = g_dw408CE4;
			word32 * esi_40 = esi_39 - 0x04;
			if (esi_39 - 0x04 >= ecx_35)
			{
				do
				{
					word32 * ecx_58;
					<anonymous> * eax_45 = *esi_40;
					if (eax_45 != null)
					{
						eax_45();
						ecx_58 = g_ptr408CE8;
						ecx_35 = ecx_58;
					}
					esi_40 -= 0x04;
				} while (esi_40 >= ecx_35);
			}
		}
		struct Eq_2185 * esp_67 = esp_25 - 4;
		esp_67->ptr0000 = &g_dw40601C;
		esp_67->ptrFFFFFFFC = &g_dw406014;
		fn00401FF0(esp_67->ptrFFFFFFFC, esp_67->ptr0000);
	}
	word32 eax_83 = fn00401FF0(&g_dw406020, &g_dw406024);
	if (dwArg0C != 0x00)
		return eax_83;
	g_dw40895C = 0x01;
	ExitProcess(dwArg04);
}

// 00401FF0: Register (ptr32 code) fn00401FF0(Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn00401ED0
//      fn00401F40
<anonymous> * fn00401FF0(word32 * dwArg04, word32 * dwArg08)
{
	word32 * esi_14 = dwArg04;
	if (dwArg04 < dwArg08)
	{
		do
		{
			<anonymous> * eax_24;
			eax = *esi_14;
			if (eax != null)
			{
				eax();
				eax = eax_24;
			}
			++esi_14;
		} while (esi_14 < dwArg08);
	}
	return eax;
}

// 004021A0: void fn004021A0()
// Called from:
//      Win32CrtStartup
void fn004021A0()
{
	Eq_93 edx_32 = g_t4088F8;
	byte al_17 = *edx_32;
	ui32 esi_18 = 0x00;
	while (al_17 != 0x00)
	{
		if (al_17 != 0x3D)
			++esi_18;
		Eq_93 edi_33 = edx_32;
		word32 ecx_36 = ~0x00;
		while (ecx_36 != 0x00)
		{
			edi_33 = (word32) edi_382 + 1;
			--ecx_36;
			edi_382 = edi_33;
			if (*edi_382 != 0x00)
				break;
		}
		int32 ecx_49 = ~ecx_36;
		al_17 = (byte) ((word32) edx_32 + 1 + (ecx_49 - 0x01));
		edx_32 = (word32) edx_32 + 1 + (ecx_49 - 0x01);
	}
	struct Eq_108 * ecx_119;
	Eq_93 eax_71 = fn00402FB0(esi_18 * 0x04 + 0x04, out ecx_119);
	g_t40893C = eax_71;
	Eq_93 esi_142 = eax_71;
	Eq_93 dwLoc04_282 = eax_71;
	if (eax_71 == 0x00)
		ecx_119 = fn00401200(0x09);
	Eq_93 ebp_102 = g_t4088F8;
	byte dl_124 = *ebp_102;
	while (dl_124 != 0x00)
	{
		Eq_93 edi_103 = ebp_102;
		word32 ecx_105 = ~0x00;
		while (ecx_105 != 0x00)
		{
			edi_103 = (word32) edi_383 + 1;
			--ecx_105;
			edi_383 = edi_103;
			if (*edi_383 != 0x00)
				break;
		}
		Eq_93 ecx_118 = ~ecx_105;
		ecx_119 = ecx_118 - 0x01;
		if (dl_124 != 0x3D)
		{
			word32 ecx_381;
			Eq_93 eax_132 = fn00402FB0(ecx_118, out ecx_381);
			*esi_142 = eax_132;
			if (eax_132 == 0x00)
				fn00401200(0x09);
			Eq_93 edi_161 = ebp_102;
			word32 ecx_163 = ~0x00;
			while (ecx_163 != 0x00)
			{
				edi_161 = (word32) edi_161 + 1;
				--ecx_163;
				if (*edi_161 != 0x00)
					break;
			}
			uint32 ecx_181 = ~ecx_163;
			struct Eq_2372 * esi_185 = edi_161 - ecx_181;
			struct Eq_2374 * edi_186 = *dwLoc04_282;
			uint32 ecx_187;
			for (ecx_187 = ecx_181 >> 0x02; ecx_187 != 0x00; --ecx_187)
			{
				edi_186->dw0000 = esi_185->dw0000;
				esi_185 += 4;
				edi_186 += 4;
			}
			for (ecx_119 = ecx_181 & 0x03; ecx_119 != null; --ecx_119)
			{
				edi_186->dw0000 = esi_185->dw0000;
				++esi_185;
				++edi_186;
			}
			dwLoc04_282 = (word32) dwLoc04_282 + 4;
			esi_142 = (word32) dwLoc04_282 + 4;
		}
		dl_124 = Mem205[ebp_102 + ecx_118:byte];
		ebp_102 += ecx_118;
	}
	fn00403590(ecx_119, g_t4088F8);
	g_t4088F8.u0 = 0x00;
	esi_142->u0 = 0x00;
}

// 00402290: void fn00402290()
// Called from:
//      Win32CrtStartup
void fn00402290()
{
	GetModuleFileNameA(null, 0x00408968, 0x0104);
	Eq_93 edi_19 = g_t409D04;
	g_dw40894C = 0x00408968;
	if (*edi_19 == 0x00)
		edi_19.u0 = 0x00408968;
	fn00402330(SLICE(fp - 0x08, word24, 8), edi_19, 0x00, null, fp - 0x08, fp - 0x04);
	word32 ecx_145;
	Eq_93 eax_53 = fn00402FB0(dwLoc04 + dwLoc08 * 0x04, out ecx_145);
	if (eax_53 == 0x00)
		fn00401200(0x08);
	fn00402330(SLICE(dwLoc08, word24, 8), edi_19, eax_53, (word32) eax_53 + dwLoc08 * 0x04, fp - 0x08, fp - 0x04);
	g_t408934 = eax_53;
	g_dw408930 = dwLoc08 - 0x01;
}

// 00402330: void fn00402330(Register word24 ecx_24_8, Stack Eq_93 dwArg04, Stack Eq_93 dwArg08, Stack (ptr32 Eq_2450) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      fn00402290
void fn00402330(word24 ecx_24_8, Eq_93 dwArg04, Eq_93 dwArg08, struct Eq_2450 * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	ui24 nArg15_621 = SLICE(dwArg14, word24, 8);
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	Eq_93 ebp_12 = dwArg08;
	struct Eq_2450 * esi_123 = dwArg0C;
	Eq_93 eax_100 = dwArg04;
	if (dwArg08 != 0x00)
	{
		*dwArg08 = dwArg0C;
		ebp_12 = (word32) dwArg08 + 4;
		dwArg08 = (word32) dwArg08 + 4;
	}
	if (*dwArg04 == 0x22)
	{
		byte cl_104 = *((word32) dwArg04 + 1);
		eax_100 = (word32) dwArg04 + 1;
		uint32 ecx_855 = SEQ(ecx_24_8, cl_104);
		if (cl_104 != 0x22)
		{
			while ((byte) ecx_855 != 0x00)
			{
				if (((ecx_855 & 0xFF)->b408A79 & 0x04) != 0x00)
				{
					++*dwArg14;
					if (esi_123 != null)
					{
						esi_123->b0000 = (byte) *eax_100;
						++esi_123;
						eax_100 = (word32) eax_100 + 1;
					}
				}
				++*dwArg14;
				if (esi_123 != null)
				{
					esi_123->b0000 = (byte) *eax_100;
					++esi_123;
				}
				byte cl_150 = *((word32) eax_100 + 1);
				eax_100 = (word32) eax_100 + 1;
				ecx_855 = (uint32) cl_150;
				if (cl_150 == 0x22)
					break;
			}
		}
		++*dwArg14;
		if (esi_123 != null)
		{
			esi_123->b0000 = 0x00;
			++esi_123;
		}
		if (*eax_100 == 0x22)
			eax_100 = (word32) eax_100 + 1;
	}
	else
	{
		do
		{
			++*dwArg14;
			if (esi_123 != null)
			{
				esi_123->b0000 = (byte) *eax_100;
				++esi_123;
			}
			uint8 cl_52 = *eax_100;
			eax_100 = (word32) eax_100 + 1;
			if (((SEQ(nArg15_621, cl_52) & 0xFF)->b408A79 & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_123 != null)
				{
					esi_123->b0000 = (byte) *eax_100;
					++esi_123;
				}
				eax_100 = (word32) eax_100 + 1;
			}
			if (cl_52 == 0x20)
				break;
			if (cl_52 == 0x00)
				goto l00402409;
		} while (cl_52 != 0x09);
		if (cl_52 == 0x00)
		{
l00402409:
			--eax_100;
		}
		else if (esi_123 != null)
			esi_123->bFFFFFFFF = 0x00;
	}
	uint32 edx_177 = 0x00;
	uint32 dwArg14_579 = 0x00;
	while (*eax_100 != 0x00)
	{
		while (true)
		{
			byte cl_198 = *eax_100;
			if (cl_198 != 0x20 && cl_198 != 0x09)
				break;
			eax_100 = (word32) eax_100 + 1;
		}
		if (*eax_100 == 0x00)
			break;
		if (ebp_12 != 0x00)
		{
			*ebp_12 = esi_123;
			dwArg08 = (word32) ebp_12 + 4;
		}
		++*dwArg10;
		while (true)
		{
			uint32 ecx_249 = 0x00;
			word32 ebp_251 = 0x01;
			ecx_249 = 0x00;
			if (*eax_100 == 0x5C)
			{
				do
				{
					eax_100 = (word32) eax_860 + 1;
					++ecx_249;
					eax_860 = eax_100;
				} while (*((word32) eax_860 + 1) == 0x5C);
			}
			byte cl_265 = (byte) ecx_249;
			uint32 ecx_307 = ecx_249;
			if (*eax_100 == 0x22)
			{
				if ((cl_265 & 0x01) == 0x00)
				{
					if (edx_177 != 0x00 && *((word32) eax_100 + 1) == 0x22)
						eax_100 = (word32) eax_100 + 1;
					else
						ebp_251 = 0x00;
					edx_177 = (uint32) (int8) (dwArg14_579 == 0x00);
					dwArg14_579 = edx_177;
				}
				ecx_307 = ecx_249 >> 0x01;
			}
			word32 ecx_312 = ecx_307 - 0x01;
			word24 ecx_24_8_421 = SLICE(ecx_312, word24, 8);
			if (ecx_307 != 0x00)
			{
				word32 ecx_316 = ecx_312 + 0x01;
				do
				{
					if (esi_123 != null)
					{
						esi_123->b0000 = 0x5C;
						++esi_123;
					}
					++*dwArg14;
					--ecx_316;
					ecx_24_8_421 = SLICE(ecx_316, word24, 8);
				} while (ecx_316 != 0x00);
			}
			byte cl_347 = *eax_100;
			if (cl_347 == 0x00)
				break;
			ui32 ecx_420 = SEQ(ecx_24_8_421, cl_347);
			if (edx_177 == 0x00)
			{
				if (cl_347 == 0x20)
					break;
				ecx_420 = SEQ(ecx_24_8_421, cl_347);
				if (cl_347 == 0x09)
					break;
			}
			byte cl_452 = (byte) ecx_420;
			if (ebp_251 != 0x00)
			{
				if (esi_123 != null)
				{
					if (((ecx_420 & 0xFF)->b408A79 & 0x04) != 0x00)
					{
						esi_123->b0000 = cl_452;
						++*dwArg14;
						++esi_123;
						eax_100 = (word32) eax_100 + 1;
					}
					esi_123->b0000 = (byte) *eax_100;
					++*dwArg14;
					++esi_123;
					eax_100 = (word32) eax_100 + 1;
					continue;
				}
				if (((ecx_420 & 0xFF)->b408A79 & 0x04) != 0x00)
				{
					++*dwArg14;
					eax_100 = (word32) eax_100 + 1;
				}
				++*dwArg14;
			}
			eax_100 = (word32) eax_100 + 1;
		}
		if (esi_123 != null)
		{
			esi_123->b0000 = 0x00;
			++esi_123;
		}
		++*dwArg14;
		ebp_12 = dwArg08;
	}
	if (ebp_12 != 0x00)
		*ebp_12 = 0x00;
	++*dwArg10;
}

// 00402540: Register Eq_93 fn00402540()
// Called from:
//      Win32CrtStartup
Eq_93 fn00402540()
{
	word32 eax_35 = g_dw408A70;
	Eq_2927 esi_16 = 0x00;
	Eq_2929 ebx_17 = 0x00;
	if (eax_35 == 0x00)
	{
		Eq_2927 eax_25 = GetEnvironmentStringsW();
		esi_16 = eax_25;
		if (eax_25 != 0x00)
			eax_35 = 0x01;
		else
		{
			Eq_2929 eax_30 = GetEnvironmentStrings();
			ebx_17 = eax_30;
			if (eax_30 == 0x00)
				return 0x00;
			eax_35 = 0x02;
		}
		g_dw408A70 = eax_35;
	}
	if (eax_35 != 0x01)
	{
		if (eax_35 != 0x02)
			return 0x00;
		if (ebx_17 == 0x00)
		{
			Eq_2929 eax_51 = GetEnvironmentStrings();
			ebx_17 = eax_51;
			if (eax_51 == 0x00)
				return 0x00;
		}
		Eq_2929 eax_60 = ebx_17;
		if (*ebx_17 != 0x00)
		{
			do
			{
				do
				{
					eax_60 = (word32) eax_465 + 1;
					eax_465 = eax_60;
				} while (*((word32) eax_465 + 1) != 0x00);
				++eax_60;
			} while (*((word32) eax_60 + 1) != 0x00);
		}
		Eq_3044 eax_79 = eax_60 - ebx_17;
		word32 ecx_464;
		word32 eax_91 = fn00402FB0(eax_79 + 0x01, out ecx_464);
		if (eax_91 != 0x00)
		{
			Eq_2929 esi_104 = ebx_17;
			Eq_93 edi_106 = eax_91;
			word32 ecx_107;
			for (ecx_107 = eax_79 + 0x01 >>u 0x02; ecx_107 != 0x00; --ecx_107)
			{
				*edi_106 = *esi_104;
				esi_104 += 4;
				edi_106 = (word32) edi_106 + 4;
			}
			word32 ecx_116;
			for (ecx_116 = eax_79 + 0x01 & 0x03; ecx_116 != 0x00; --ecx_116)
			{
				*edi_106 = *esi_104;
				++esi_104;
				edi_106 = (word32) edi_106 + 1;
			}
			FreeEnvironmentStringsA(ebx_17);
			return eax_91;
		}
		else
		{
			FreeEnvironmentStringsA(ebx_17);
			return 0x00;
		}
	}
	else
	{
		if (esi_16 == 0x00)
		{
			Eq_2927 eax_169 = GetEnvironmentStringsW();
			esi_16 = eax_169;
			if (eax_169 == 0x00)
				return 0x00;
		}
		Eq_2927 eax_190 = esi_16;
		if (*esi_16 != 0x00)
		{
			do
			{
				do
					eax_190 += 0x02;
				while (*eax_190 != 0x00);
				eax_190 += 0x02;
			} while (Mem58[eax_190 + 0x02:word16] != 0x00);
		}
		int32 eax_210 = (eax_190 - esi_16 >> 0x01) + 0x01;
		Eq_93 eax_226 = WideCharToMultiByte(0x00, 0x00, esi_16, eax_210, 0x00, 0x00, null, null);
		if (eax_226 != 0x00)
		{
			struct Eq_108 * ecx_235;
			Eq_93 eax_234 = fn00402FB0(eax_226, out ecx_235);
			Eq_93 ebx_241 = eax_234;
			if (eax_234 != 0x00)
			{
				if (WideCharToMultiByte(0x00, 0x00, esi_16, eax_210, eax_234, eax_226, null, null) == 0x00)
				{
					fn00403590(ecx_235, eax_234);
					ebx_241.u0 = 0x00;
				}
				FreeEnvironmentStringsW(esi_16);
				return ebx_241;
			}
		}
		FreeEnvironmentStringsW(esi_16);
		return 0x00;
	}
}

// 004026A0: void fn004026A0(Stack Eq_111 dwArg04)
// Called from:
//      fn00402970
void fn004026A0(Eq_111 dwArg04)
{
	Eq_111 eax_22 = fn00402890(dwArg04);
	if (eax_22 == g_t408B7C)
		return;
	if (eax_22 != 0x00)
	{
		ui32 edx_164 = 0x00;
		struct Eq_3129 * eax_163 = g_a406388;
		do
		{
			if (eax_163->dw0000 == eax_22)
			{
				word32 ecx_162 = 0x40;
				struct Eq_3136 * edi_161 = g_a408A78;
				ui32 ebx_51 = edx_164 * 0x03;
				while (true)
				{
					word24 ecx_24_8_343 = SLICE(ecx_162, word24, 8);
					if (ecx_162 == 0x00)
						break;
					edi_161->b0000 = (byte) 0x00;
					++edi_161;
					--ecx_162;
				}
				edi_161->b0000 = 0x00;
				byte * edi_107 = g_a406380;
				struct Eq_3194 * ebp_113 = (ebx_51 << 0x04) + 0x00406398;
				do
				{
					struct Eq_3194 * esi_100 = ebp_113;
					if (ebp_113->b0000 != 0x00)
					{
						do
						{
							byte cl_71 = esi_491->b0001;
							ui32 ecx_77 = SEQ(ecx_24_8_343, cl_71);
							if (cl_71 == 0x00)
								break;
							struct Eq_3306 * eax_81 = (uint32) esi_491->b0000;
							if (eax_81 <= (ecx_77 & 0xFF))
							{
								byte dl_85 = *edi_107;
								do
								{
									eax_81[4229753] = (struct Eq_3306) (eax_81[4229753] | dl_85);
									++eax_81;
								} while (eax_81 <= (ecx_77 & 0xFF));
							}
							ecx_24_8_343 = 0x00;
							esi_100 = (struct Eq_3194 *) &esi_491->b0002;
							esi_491 = esi_100;
						} while (esi_491->b0002 != 0x00);
					}
					++edi_107;
					++ebp_113;
				} while (edi_107 < (byte *) 4290747524);
				g_t408B7C = eax_22;
				word32 eax_127 = fn004028E0(eax_22);
				word32 ecx_138 = g_a40638C[ebx_51];
				word32 edx_139 = g_a406390[ebx_51];
				g_dw408B80 = eax_127;
				g_dw408B88 = ecx_138;
				word32 eax_144 = g_a406394[ebx_51];
				g_dw408B8C = edx_139;
				g_dw408B90 = eax_144;
				return;
			}
			++eax_163;
			++edx_164;
		} while (eax_163 < &g_t406478);
		if (GetCPInfo(eax_22, fp - 0x14) != 0x01)
		{
			if (g_dw408B94 == 0x00)
				return;
			fn00402940();
		}
		else
		{
			word32 ecx_208 = 0x40;
			struct Eq_3167 * edi_212 = g_a408A78;
			while (true)
			{
				word24 ecx_24_8_236 = SLICE(ecx_208, word24, 8);
				if (ecx_208 == 0x00)
					break;
				edi_212->b0000 = (byte) 0x00;
				++edi_212;
				--ecx_208;
			}
			edi_212->b0000 = 0x00;
			if (dwLoc14 > 0x01)
			{
				if (bLoc0E != 0x00)
				{
					struct Eq_3222 * edx_228 = fp - 0x0D;
					do
					{
						byte cl_231 = edx_492->b0000;
						ui32 ecx_237 = SEQ(ecx_24_8_236, cl_231);
						if (cl_231 == 0x00)
							break;
						struct Eq_3225 * eax_241;
						for (eax_241 = (uint32) edx_492->bFFFFFFFF; eax_241 <= (ecx_237 & 0xFF); ++eax_241)
							eax_241[4229753] = (struct Eq_3225) (eax_241[4229753] | 0x04);
						ecx_24_8_236 = 0x00;
						edx_228 = &edx_492->b0001 + 1;
						edx_492 = edx_228;
					} while (edx_492->b0001 != 0x00);
				}
				struct Eq_3220 * eax_261 = (struct Eq_3220 *) 0x01;
				do
				{
					eax_261[4229753] = (struct Eq_3220) (eax_261[4229753] | 0x08);
					++eax_261;
				} while (eax_261 < (struct Eq_3220 *) 0xFF);
				g_t408B7C = eax_22;
				g_dw408B80 = fn004028E0(eax_22);
			}
			else
			{
				g_t408B7C.u0 = 0x00;
				g_dw408B80 = 0x00;
			}
			g_dw408B88 = 0x00;
			g_dw408B8C = 0x00;
			g_dw408B90 = 0x00;
		}
	}
	else
		fn00402940();
}

// 00402890: Register Eq_111 fn00402890(Stack Eq_111 dwArg04)
// Called from:
//      fn004026A0
Eq_111 fn00402890(Eq_111 dwArg04)
{
	g_dw408B94 = 0x00;
	Eq_111 eax_13 = dwArg04;
	if (dwArg04 != ~0x01)
	{
		if (dwArg04 != ~0x02)
		{
			if (dwArg04 == ~0x03)
			{
				eax_13 = g_t408BB8;
				g_dw408B94 = 0x01;
			}
			return eax_13;
		}
		else
		{
			g_dw408B94 = 0x01;
			return GetACP();
		}
	}
	else
	{
		g_dw408B94 = 0x01;
		return GetOEMCP();
	}
}

// 004028E0: Register word32 fn004028E0(Stack Eq_111 dwArg04)
// Called from:
//      fn004026A0
word32 fn004028E0(Eq_111 dwArg04)
{
	if (dwArg04 <= ~0x03B5)
	{
		switch ((word32) dwArg04)
		{
		case 0x03A4:
			return 0x0411;
		case 933:
		case 0x03A6:
		case 0x03A7:
		case 0x03A9:
		case 0x03AA:
		case 939:
		case 0x03AC:
		case 0x03AD:
		case 0x03AE:
		case 0x03AF:
		case 944:
		case 0x03B1:
		case 0x03B2:
		case 0x03B3:
		case 0x03B4:
			break;
		case 0x03A8:
			return 0x0804;
		case 949:
			return 0x0412;
		case 0x03B6:
			return 0x0404;
		}
	}
	return 0x00;
}

// 00402940: void fn00402940()
// Called from:
//      fn004026A0
void fn00402940()
{
	word32 ecx_12;
	struct Eq_3413 * edi_11 = g_a408A78;
	for (ecx_12 = 0x40; ecx_12 != 0x00; --ecx_12)
	{
		edi_11->b0000 = (byte) 0x00;
		++edi_11;
	}
	edi_11->b0000 = 0x00;
	g_t408B7C.u0 = 0x00;
	g_dw408B80 = 0x00;
	g_dw408B88 = 0x00;
	g_dw408B8C = 0x00;
	g_dw408B90 = 0x00;
}

// 00402970: void fn00402970()
// Called from:
//      Win32CrtStartup
void fn00402970()
{
	fn004026A0(~0x02);
}

// 00402980: void fn00402980()
// Called from:
//      Win32CrtStartup
void fn00402980()
{
	word32 ecx_449;
	Eq_93 eax_20 = fn00402FB0(0x0100, out ecx_449);
	Eq_93 esi_27 = eax_20;
	if (eax_20 == 0x00)
		fn00401200(0x1B);
	g_t408BE0 = eax_20;
	g_t408CE0.u0 = 0x20;
	if (eax_20 < (word32) eax_20 + 0x0100)
	{
		do
		{
			*((word32) esi_27 + 4) = 0x00;
			*esi_27 = ~0x00;
			*((word32) esi_27 + 5) = 0x0A;
			esi_27 = (word32) esi_27 + 8;
		} while (esi_27 < (word32) g_t408BE0 + 0x0100);
	}
	GetStartupInfoA(fp - 0x44);
	if (wLoc12 != 0x00 && dwLoc10 != null)
	{
		Eq_111 ecx_73 = *dwLoc10;
		byte * edi_142 = (char *) dwLoc10 + 4;
		Eq_111 dwLoc48_347 = ecx_73;
		word32 ebp_137 = dwLoc10 + 0x04 + ecx_73;
		if (ecx_73 >= 0x0800)
			dwLoc48_347.u0 = 0x0800;
		if (g_t408CE0 < dwLoc48_347)
		{
			up32 * esi_104 = g_a408BE4;
			do
			{
				word32 ecx_450;
				Eq_93 eax_111 = fn00402FB0(0x0100, out ecx_450);
				if (eax_111 == 0x00)
				{
					dwLoc48_347 = g_t408CE0;
					break;
				}
				Eq_111 ecx_103 = g_t408CE0;
				*esi_104 = (up32) eax_111;
				g_t408CE0 = (word32) ecx_103 + 32;
				if (eax_111 < (word32) eax_111 + 0x0100)
				{
					do
					{
						*((word32) eax_111 + 4) = 0x00;
						*eax_111 = ~0x00;
						*((word32) eax_111 + 5) = 0x0A;
						eax_111 = (word32) eax_111 + 8;
					} while (eax_111 < *esi_104 + 0x0100);
				}
				++esi_104;
			} while (g_t408CE0 < dwLoc48_347);
		}
		Eq_111 esi_134 = 0x00;
		if (dwLoc48_347 > 0x00)
		{
			do
			{
				Eq_2167 ecx_139 = *ebp_137;
				if (ecx_139 != (void *) ~0x00)
				{
					byte al_143 = *edi_142;
					if ((al_143 & 0x01) != 0x00 && ((al_143 & 0x08) != 0x00 || GetFileType(ecx_139) != 0x00))
					{
						ui32 eax_163 = esi_134 & 0x1F;
						Eq_6402 ecx_167[] = *((char *) &g_t408BE0 + (esi_134 >> 0x05) * 0x04);
						ecx_167[eax_163].dw0000 = *ebp_137;
						(&(ecx_167 + eax_163)->dw0000)[1] = (word32) *edi_142;
					}
				}
				esi_134 = (word32) esi_134.u0 + 1;
				++edi_142;
				++ebp_137;
			} while (esi_134 < dwLoc48_347);
		}
	}
	int32 ebx_188;
	for (ebx_188 = 0x00; ebx_188 < 0x03; ++ebx_188)
	{
		byte al_199;
		Eq_93 edx_192 = g_t408BE0;
		struct Eq_3519 * esi_195 = (word32) edx_192 + ebx_188 * 0x08;
		if (*((word32) edx_192 + ebx_188 * 0x08) == ~0x00)
		{
			Eq_47 eax_211;
			esi_195->b0004 = 0x81;
			if (ebx_188 == 0x00)
				eax_211.u0 = ~0x09;
			else
				eax_211 = 0x00 - (ebx_188 == 0x01) + ~0x0A;
			Eq_2167 eax_228 = GetStdHandle(eax_211);
			if (eax_228 != (void *) ~0x00)
			{
				Eq_47 eax_238 = GetFileType(eax_228);
				if (eax_238 == 0x00)
					goto l00402B4F;
				esi_195->t0000 = eax_228;
				if ((eax_238 & 0xFF) == 0x02)
				{
					al_199 = esi_195->b0004 | 0x40;
					goto l00402B5B;
				}
				if ((eax_238 & 0xFF) != 0x03)
					goto l00402B5E;
				al_199 = esi_195->b0004 | 0x08;
			}
			else
			{
l00402B4F:
				al_199 = esi_195->b0004 | 0x40;
			}
		}
		else
			al_199 = esi_195->b0004 | 0x80;
l00402B5B:
		esi_195->b0004 = al_199;
l00402B5E:
	}
	SetHandleCount(g_t408CE0);
}

// 00402B80: Register Eq_2167 fn00402B80()
// Called from:
//      Win32CrtStartup
Eq_2167 fn00402B80()
{
	Eq_2167 eax_10 = HeapCreate(0x01, 0x1000, 0x00);
	g_t408BD4 = eax_10;
	if (eax_10 == null)
		return eax_10;
	if (fn004035E0() != 0x00)
		return (void *) 0x01;
	HeapDestroy(g_t408BD4);
	return null;
}

// 00402D90: void fn00402D90()
// Called from:
//      fn00401200
void fn00402D90()
{
	word32 eax_5 = g_dw408900;
	if (eax_5 == 0x01 || eax_5 == 0x00 && g_dw40606C == 0x01)
	{
		fn00402DD0(252);
		<anonymous> * eax_23 = g_ptr408B98;
		if (eax_23 != null)
		{
			word32 ecx_32;
			word32 edx_33;
			eax_23();
		}
		fn00402DD0(0xFF);
	}
}

// 00402DD0: void fn00402DD0(Stack word32 dwArg04)
// Called from:
//      fn00401200
//      fn00402D90
void fn00402DD0(word32 dwArg04)
{
	struct Eq_3763 * eax_24 = g_a406498;
	ui32 ebp_20 = 0x00;
	while (dwArg04 != eax_24->dw0000)
	{
		++eax_24;
		++ebp_20;
		if (eax_24 >= &g_ptr406528)
			break;
	}
	if (dwArg04 != g_a406498[ebp_20])
		return;
	word32 eax_38 = g_dw408900;
	if (eax_38 != 0x01 && (eax_38 != 0x00 || g_dw40606C != 0x01))
	{
		if (dwArg04 == 252)
			return;
		if (GetModuleFileNameA(null, fp - 0x0104, 0x0104) == 0x00)
		{
			word32 ecx_135;
			struct Eq_3820 * esi_136 = g_a40535C;
			struct Eq_3822 * edi_137 = fp - 0x0104;
			for (ecx_135 = 0x05; ecx_135 != 0x00; --ecx_135)
			{
				edi_137->w0000 = esi_136->w0000;
				++esi_136;
				++edi_137;
			}
			edi_137->w0000 = esi_136->w0000;
			edi_137->b0002 = esi_136->b0002;
		}
		byte * edi_152 = fp - 0x0104;
		word32 ecx_154 = ~0x00;
		byte * ebx_158 = fp - 0x0104;
		while (ecx_154 != 0x00)
		{
			edi_152 = edi_750 + 1;
			--ecx_154;
			edi_750 = edi_152;
			if (*edi_750 != 0x00)
				break;
		}
		if (~ecx_154 > 0x3C)
		{
			byte * edi_173 = fp - 0x0104;
			word32 ecx_174 = ~0x00;
			while (ecx_174 != 0x00)
			{
				edi_173 = edi_751 + 1;
				--ecx_174;
				edi_751 = edi_173;
				if (*edi_751 != 0x00)
					break;
			}
			ebx_158 = ~ecx_174 - 0x01 + (fp - 0x013F);
			fn00403D90(ebx_158, &g_b405358, 0x03);
		}
		word32 ecx_210;
		struct Eq_3868 * esi_211 = g_a40533C;
		struct Eq_3870 * edi_213 = fp - 0x01A4;
		for (ecx_210 = 0x06; ecx_210 != 0x00; --ecx_210)
		{
			edi_213->w0000 = esi_211->w0000;
			++esi_211;
			++edi_213;
		}
		edi_213->w0000 = esi_211->w0000;
		word32 ecx_224 = ~0x00;
		byte * edi_228 = ebx_158;
		while (ecx_224 != 0x00)
		{
			++edi_228;
			--ecx_224;
			if (*edi_228 != 0x00)
				break;
		}
		uint32 ecx_238 = ~ecx_224;
		struct Eq_3945 * esi_246 = edi_228 - ecx_238;
		word32 ecx_247 = ~0x00;
		byte * edi_250 = fp - 0x01A4;
		while (ecx_247 != 0x00)
		{
			++edi_250;
			--ecx_247;
			if (*edi_250 != 0x00)
				break;
		}
		struct Eq_3963 * edi_263 = edi_250 - 0x01;
		uint32 ecx_264;
		for (ecx_264 = ecx_238 >> 0x02; ecx_264 != 0x00; --ecx_264)
		{
			edi_263->dw0000 = esi_246->dw0000;
			esi_246 += 4;
			edi_263 += 4;
		}
		ui32 ecx_271;
		for (ecx_271 = ecx_238 & 0x03; ecx_271 != 0x00; --ecx_271)
		{
			edi_263->dw0000 = esi_246->dw0000;
			++esi_246;
			++edi_263;
		}
		byte * edi_277 = &g_b405338;
		word32 ecx_278 = ~0x00;
		while (ecx_278 != 0x00)
		{
			++edi_277;
			--ecx_278;
			if (*edi_277 != 0x00)
				break;
		}
		uint32 ecx_290 = ~ecx_278;
		struct Eq_4043 * esi_298 = edi_277 - ecx_290;
		byte * edi_303 = fp - 0x01A4;
		word32 ecx_304 = ~0x00;
		while (ecx_304 != 0x00)
		{
			++edi_303;
			--ecx_304;
			if (*edi_303 != 0x00)
				break;
		}
		struct Eq_4061 * edi_319 = edi_303 - 0x01;
		uint32 ecx_320;
		for (ecx_320 = ecx_290 >> 0x02; ecx_320 != 0x00; --ecx_320)
		{
			edi_319->dw0000 = esi_298->dw0000;
			esi_298 += 4;
			edi_319 += 4;
		}
		ui32 ecx_327;
		for (ecx_327 = ecx_290 & 0x03; ecx_327 != 0x00; --ecx_327)
		{
			edi_319->dw0000 = esi_298->dw0000;
			++esi_298;
			++edi_319;
		}
		byte * edi_333 = *((char *) &g_a406498->t0004 + ebp_20 * 0x08);
		word32 ecx_334 = ~0x00;
		while (ecx_334 != 0x00)
		{
			++edi_333;
			--ecx_334;
			if (*edi_333 != 0x00)
				break;
		}
		uint32 ecx_346 = ~ecx_334;
		struct Eq_4118 * esi_349 = edi_333 - ecx_346;
		byte * edi_354 = fp - 0x01A4;
		word32 ecx_355 = ~0x00;
		while (ecx_355 != 0x00)
		{
			++edi_354;
			--ecx_355;
			if (*edi_354 != 0x00)
				break;
		}
		struct Eq_4136 * edi_370 = edi_354 - 0x01;
		uint32 ecx_371;
		for (ecx_371 = ecx_346 >> 0x02; ecx_371 != 0x00; --ecx_371)
		{
			edi_370->dw0000 = esi_349->dw0000;
			esi_349 += 4;
			edi_370 += 4;
		}
		ui32 ecx_378;
		for (ecx_378 = ecx_346 & 0x03; ecx_378 != 0x00; --ecx_378)
		{
			edi_370->dw0000 = esi_349->dw0000;
			++esi_349;
			++edi_370;
		}
		fn00403D00();
		return;
	}
	Eq_2167 esi_102;
	Eq_93 eax_47 = g_t408BE0;
	if (eax_47 != 0x00)
	{
		esi_102 = (Eq_2167) *((word32) eax_47 + 16);
		if (esi_102 != (void *) ~0x00)
		{
l00402F78:
			Eq_93 edx_67 = *((char *) &g_a406498->t0004 + ebp_20 * 0x08);
			Eq_93 edi_74 = edx_67;
			word32 ecx_75 = ~0x00;
			while (ecx_75 != 0x00)
			{
				edi_74 = (word32) edi_749 + 1;
				--ecx_75;
				edi_749 = edi_74;
				if (*edi_749 != 0x00)
					break;
			}
			WriteFile(esi_102, edx_67, ~ecx_75 - 0x01, fp - 424, null);
			return;
		}
	}
	esi_102 = GetStdHandle(~0x0B);
	goto l00402F78;
}

// 00402FB0: Register word32 fn00402FB0(Stack Eq_93 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00401230
//      fn004021A0
//      fn00402290
//      fn00402540
//      fn00402980
//      fn00404200
word32 fn00402FB0(Eq_93 dwArg04, ptr32 & ecxOut)
{
	ptr32 ecx_12;
	word32 eax_11 = fn00402FD0(dwArg04, g_dw408BCC, out ecx_12);
	ecxOut = ecx_12;
	return eax_11;
}

// 00402FD0: Register word32 fn00402FD0(Stack Eq_93 dwArg04, Stack word32 dwArg08, Register out ptr32 ecxOut)
// Called from:
//      fn00402FB0
word32 fn00402FD0(Eq_93 dwArg04, word32 dwArg08, ptr32 & ecxOut)
{
	word32 eax_23;
	Eq_93 esi_16 = dwArg04;
	if (dwArg04 <= ~0x1F)
	{
		if (dwArg04 == 0x00)
			esi_16.u0 = 0x01;
		do
		{
			if (esi_16 <= ~0x1F)
				eax_23 = fn00403020(esi_16, out ecx);
			else
				eax_23 = 0x00;
			if (eax_23 != 0x00 || dwArg08 == 0x00)
				goto l00403011;
		} while (fn00403E90(esi_16, out ecx) != 0x00);
	}
	eax_23 = 0x00;
l00403011:
	ecxOut = ecx;
	return eax_23;
}

// 00403020: Register Eq_93 fn00403020(Stack Eq_93 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00402FD0
Eq_93 fn00403020(Eq_93 dwArg04, ptr32 & ecxOut)
{
	Eq_93 eax_19;
	Eq_93 esi_11 = (word32) dwArg04 + 0x0F & ~0x0F;
	if (esi_11 <= g_t408774)
	{
		eax_19 = fn00403940(esi_11 >> 0x04, out ecx);
		if (eax_19 != 0x00)
		{
l00403056:
			ecxOut = ecx;
			return eax_19;
		}
	}
	eax_19 = HeapAlloc(g_t408BD4, 0x00, esi_11);
	goto l00403056;
}

// 00403060: Register ui32 fn00403060(Stack Eq_111 dwArg04)
// Called from:
//      fn00401230
//      fn00403350
ui32 fn00403060(Eq_111 dwArg04)
{
	if (dwArg04 < g_t408CE0)
		return (uint32) *((char *) *((char *) &g_t408BE0 + (dwArg04 >> 0x05) * 0x04) + ((dwArg04 & 0x1F) * 0x08 + 4)) & 0x40;
	return 0x00;
}

// 004030E0: void fn004030E0(Stack (ptr32 Eq_44) dwArg04)
// Called from:
//      fn004012D0
void fn004030E0(struct Eq_44 * dwArg04)
{
	ui32 eax_15 = dwArg04->dw000C;
	if (((byte) eax_15 & 0x03) == 0x02 && (eax_15 & 0x0108) != 0x00)
	{
		Eq_93 eax_24 = dwArg04->t0008;
		Eq_47 edi_26 = dwArg04->t0000 - eax_24;
		if (edi_26 > 0x00)
		{
			Eq_47 eax_36 = fn00403F10(dwArg04->t0010, eax_24, edi_26);
			ui32 eax_45 = dwArg04->dw000C;
			byte al_47 = (byte) eax_45;
			word24 eax_24_8_52 = SLICE(eax_45, word24, 8);
			if (eax_36 == edi_26)
			{
				if ((al_47 & 0x80) != 0x00)
				{
					dwArg04->dw0004 = 0x00;
					dwArg04->dw000C = SEQ(eax_24_8_52, al_47 & ~0x02);
					dwArg04->t0000 = dwArg04->t0008;
					return;
				}
			}
			else
				dwArg04->dw000C = SEQ(eax_24_8_52, al_47 | 0x20);
		}
	}
	Eq_93 eax_60 = dwArg04->t0008;
	dwArg04->dw0004 = 0x00;
	dwArg04->t0000 = eax_60;
}

// 004031E0: Register Eq_93 fn004031E0(Stack Eq_93 dwArg04, Stack Eq_440 wArg08)
// Called from:
//      fn00401330
Eq_93 fn004031E0(Eq_93 dwArg04, Eq_440 wArg08)
{
	if (dwArg04 == 0x00)
		return dwArg04;
	if (g_dw408BA8 != 0x00)
	{
		Eq_93 eax_34 = WideCharToMultiByte(g_t408BB8, 0x0220, fp + 0x08, 0x01, dwArg04, g_t408780, null, fp + 0x04);
		return eax_34;
	}
	else
	{
		Eq_4385 cl_51 = (byte) wArg08;
		*dwArg04 = cl_51;
		return 0x01;
	}
}

// 00403260: Register uint32 fn00403260(Stack Eq_559 dwArg04, Stack Eq_760 dwArg08, Stack Eq_559 dwArg0C, Stack uint32 dwArg10, Register out Eq_1054 edxOut)
// Called from:
//      fn00401330
uint32 fn00403260(Eq_559 dwArg04, Eq_760 dwArg08, Eq_559 dwArg0C, uint32 dwArg10, union Eq_1054 & edxOut)
{
	uint32 eax_110;
	Eq_1054 edx_114;
	if (dwArg10 == 0x00)
	{
		uint64 edx_eax_69 = (uint64) dwArg08;
		eax_110 = (uint32) (SEQ((uint32) (edx_eax_69 % dwArg0C), dwArg04) /u dwArg0C);
		edx_114.u0 = (uint32) (edx_eax_69 /u dwArg0C);
	}
	else
	{
		uint32 ecx_15 = dwArg10;
		Eq_559 ebx_16 = dwArg0C;
		Eq_760 edx_17 = dwArg08;
		Eq_559 eax_18 = dwArg04;
		do
		{
			uint32 ecx_20 = ecx_15 >> 0x01;
			edx_17 >>= 0x01;
			ebx_16 = __rcr(ebx_16, 0x01, SLICE(cond(ecx_20), bool, 1));
			eax_18 = __rcr(eax_18, 0x01, SLICE(cond(edx_17), bool, 1));
			ecx_15 = ecx_20;
		} while (ecx_20 != 0x00);
		uint32 eax_39 = (uint32) (SEQ(edx_17, eax_18) /u ebx_16);
		uint64 edx_eax_47 = eax_39 *64 dwArg0C;
		uint32 esi_40 = eax_39;
		Eq_559 eax_55 = (word32) edx_eax_47;
		Eq_760 edx_49 = SLICE(edx_eax_47, word32, 32) + dwArg10 * eax_39;
		if (edx_49 < 0x00 || (edx_49 > dwArg08 || edx_49 >= dwArg08 && eax_55 > dwArg04))
			esi_40 = eax_39 - 0x01;
		edx_114.u0 = 0x00;
		eax_110 = esi_40;
	}
	edxOut = edx_114;
	return eax_110;
}

// 004032D0: Register uint32 fn004032D0(Stack Eq_559 qwArg04, Stack Eq_559 qwArg0C)
// Called from:
//      fn00401330
uint32 fn004032D0(Eq_559 qwArg04, Eq_559 qwArg0C)
{
	uint32 dwArg10 = SLICE(qwArg0C, word32, 32);
	Eq_559 dwArg0C = (word32) qwArg0C;
	uint32 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_559 dwArg04 = (word32) qwArg04;
	uint32 eax_122;
	if (dwArg10 == 0x00)
	{
		eax_122 = (uint32) (SEQ((uint32) ((uint64) dwArg08 % dwArg0C), dwArg04) % dwArg0C);
		return eax_122;
	}
	uint32 ecx_12 = dwArg10;
	Eq_559 ebx_13 = dwArg0C;
	uint32 edx_14 = dwArg08;
	Eq_559 eax_15 = dwArg04;
	do
	{
		uint32 ecx_17 = ecx_12 >> 0x01;
		edx_14 >>= 0x01;
		ebx_13 = __rcr(ebx_13, 0x01, SLICE(cond(ecx_17), bool, 1));
		eax_15 = __rcr(eax_15, 0x01, SLICE(cond(edx_14), bool, 1));
		ecx_12 = ecx_17;
	} while (ecx_17 != 0x00);
	word64 edx_eax_142;
	uint32 eax_36 = (uint32) (SEQ(edx_14, eax_15) /u ebx_13);
	uint64 edx_eax_45 = dwArg0C *64 eax_36;
	Eq_559 eax_53 = (word32) edx_eax_45;
	uint32 edx_47 = SLICE(edx_eax_45, word32, 32) + dwArg10 * eax_36;
	if (edx_47 < 0x00 || edx_47 > dwArg08)
	{
l0040332A:
		edx_eax_142 = SEQ(edx_47, eax_53) - qwArg0C;
		goto l00403332;
	}
	else
	{
		edx_eax_142 = SEQ(edx_47, eax_53);
		if (edx_47 >= dwArg08)
		{
			edx_eax_142 = SEQ(edx_47, eax_53);
			if (eax_53 > dwArg04)
				goto l0040332A;
		}
l00403332:
		eax_122 = -(word32) (edx_eax_142 - qwArg04);
		return eax_122;
	}
}

// 00403350: Register ui32 fn00403350(Stack Eq_447 dwArg04, Stack (ptr32 Eq_432) dwArg08)
// Called from:
//      fn00401CC0
ui32 fn00403350(Eq_447 dwArg04, struct Eq_432 * dwArg08)
{
	byte bArg04 = (byte) dwArg04;
	ui32 eax_17 = dwArg08->dw000C;
	byte al_19 = (byte) eax_17;
	word24 eax_24_8_41 = SLICE(eax_17, word24, 8);
	Eq_111 ebp_18 = dwArg08->t0010;
	if ((al_19 & 0x82) != 0x00 && (al_19 & 0x40) == 0x00)
	{
		Eq_47 ebx_135 = 0x00;
		if ((al_19 & 0x01) == 0x00)
		{
l00403389:
			ui32 eax_63 = dwArg08->dw000C;
			dwArg08->dw0004 = 0x00;
			ui32 eax_70 = SEQ(SLICE(eax_63, word24, 8), (byte) eax_63 & ~0x10 | 0x02);
			dwArg08->dw000C = eax_70;
			if ((eax_70 & 0x010C) == 0x00 && (dwArg08 != &g_t406098 && dwArg08 != &g_t4060B8 || fn00403060(ebp_18) == 0x00))
				fn00404200(dwArg08);
			Eq_47 edi_115;
			if ((dwArg08->dw000C & 0x0108) != 0x00)
			{
				Eq_93 eax_136 = dwArg08->t0008;
				word32 ecx_138 = dwArg08->dw0018;
				edi_115 = dwArg08->t0000 - eax_136;
				dwArg08->t0000 = (word32) eax_136 + 1;
				dwArg08->dw0004 = ecx_138 - 0x01;
				if (edi_115 > 0x00)
				{
					Eq_47 eax_196 = fn00403F10(ebp_18, eax_136, edi_115);
					*dwArg08->t0008 = bArg04;
					ebx_135 = eax_196;
				}
				else
				{
					struct Eq_4647 * eax_151;
					if (ebp_18 != ~0x00)
						eax_151 = (struct Eq_4647 *) ((char *) *((char *) &g_t408BE0 + (ebp_18 >> 0x05) * 0x04) + (ebp_18 & 0x1F) * 0x08);
					else
						eax_151 = (struct Eq_4647 *) &g_t406478;
					if ((eax_151->b0004 & 0x20) != 0x00)
						fn00404140(ebp_18, 0x00, 0x02);
					*dwArg08->t0008 = bArg04;
				}
			}
			else
			{
				edi_115.u0 = 0x01;
				ebx_135 = fn00403F10(ebp_18, fp + 0x04, 0x01);
			}
			if (ebx_135 == edi_115)
				return dwArg04 & 0xFF;
			ui32 eax_231 = dwArg08->dw000C;
			dwArg08->dw000C = SEQ(SLICE(eax_231, word24, 8), (byte) eax_231 | 0x20);
			return ~0x00;
		}
		dwArg08->dw0004 = 0x00;
		if ((al_19 & 0x10) != 0x00)
		{
			dwArg08->t0000 = dwArg08->t0008;
			dwArg08->dw000C = SEQ(eax_24_8_41, al_19 & ~0x01);
			goto l00403389;
		}
	}
	dwArg08->dw000C = SEQ(eax_24_8_41, al_19 | 0x20);
	return ~0x00;
}

// 00403590: void fn00403590(Register (ptr32 Eq_108) ecx, Stack Eq_93 dwArg04)
// Called from:
//      fn004021A0
//      fn00402540
void fn00403590(struct Eq_108 * ecx, Eq_93 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	byte * eax_22 = fn00403880(dwArg04, fp - 0x04, fp + 0x04);
	if (eax_22 == null)
		HeapFree(g_t408BD4, 0x00, dwArg04);
	else
		fn004038E0(ecx, dwArg04, eax_22);
}

// 004035E0: Register Eq_93 fn004035E0()
// Called from:
//      fn00402B80
//      fn00403940
Eq_93 fn004035E0()
{
	Eq_93 ebp_26;
	if (g_dw406760 == ~0x00)
		ebp_26.u0 = 0x00406750;
	else
	{
		Eq_93 eax_24 = HeapAlloc(g_t408BD4, 0x00, 0x2020);
		ebp_26 = eax_24;
		if (eax_24 == 0x00)
			return 0x00;
	}
	Eq_93 eax_41 = VirtualAlloc(0x00, 0x00400000, 0x2000, 0x04);
	Eq_93 esi_162 = eax_41;
	if (eax_41 != 0x00)
	{
		if (VirtualAlloc(eax_41, 0x00010000, 0x1000, 0x04) != 0x00)
		{
			if (ebp_26 == 0x00406750)
			{
				if (g_dw406750 == 0x00)
					g_dw406750 = 0x00406750;
				if (g_t406754 == 0x00)
					g_t406754.u0 = 0x00406750;
			}
			else
			{
				*ebp_26.u0 = (char) 0x00406750;
				ebp_26.u0[4] = (char) g_t406754;
				g_t406754 = ebp_26;
				ebp_26.u0[4] + 0x00 = (word32) ebp_26;
			}
			Mem120[ebp_26 + 0x14:word32] = eax_41 + 0x00400000;
			ebp_26.u0[16] = (char) eax_41;
			word32 ecx_118 = ebp_26 + 0x18;
			ebp_26.u0[8] = (char) ecx_118;
			Mem123[ebp_26 + 0x0C:word32] = ebp_26 + 0x98;
			int32 eax_124;
			for (eax_124 = 0x00; eax_124 < 0x0400; ++eax_124)
			{
				ecx_118 = (word32) ecx_118 + 8;
				*((word32) ecx_118 - 8) = ((uint32) (int8) (eax_124 >= 0x10) - 0x01 & 0xF1) - 0x01;
				*((word32) ecx_118 - 4) = 0xF1;
			}
			word32 ecx_146;
			Eq_93 edi_151 = eax_41;
			for (ecx_146 = 0x4000; ecx_146 != 0x00; --ecx_146)
			{
				*edi_151 = 0x00;
				edi_151 += 4;
			}
			if (eax_41 < (ebp_26.u0)[16] + 0x00010000)
			{
				do
				{
					((word32) esi_162 + 4)->u0 = 0xF0;
					Mem166[esi_162 + 0x00:word32] = esi_162 + 0x08;
					*((word32) esi_162 + 0x00F8) = ~0x00;
					esi_162 += 0x1000;
				} while (esi_162 < (ebp_26.u0)[16] + 0x00010000);
			}
			return ebp_26;
		}
		VirtualFree(eax_41, 0x00, 0x8000);
	}
	if (ebp_26 != 0x00406750)
		HeapFree(g_t408BD4, 0x00, ebp_26);
	return 0x00;
}

// 00403750: void fn00403750(Stack Eq_93 dwArg04)
// Called from:
//      fn004037B0
void fn00403750(Eq_93 dwArg04)
{
	VirtualFree(*((word32) dwArg04 + 16), 0x00, 0x8000);
	if (g_t408770 == dwArg04)
		g_t408770 = *((word32) dwArg04 + 4);
	if (dwArg04 == 0x00406750)
		g_dw406760 = ~0x00;
	else
	{
		**((word32) dwArg04 + 4) = *dwArg04;
		*((word32) *dwArg04 + 4) = *((word32) dwArg04 + 4);
		HeapFree(g_t408BD4, 0x00, dwArg04);
	}
}

// 004037B0: void fn004037B0(Stack int32 dwArg04)
// Called from:
//      fn004038E0
void fn004037B0(int32 dwArg04)
{
	Eq_93 edi_126 = g_t406754;
	do
	{
		if (*((word32) edi_126 + 16) != ~0x00)
		{
			word32 ebp_21 = 0x00;
			struct Eq_4963 * esi_24 = (word32) edi_126 + 8208;
			int32 ebx_25;
			for (ebx_25 = 0x003FF000; ebx_25 >= 0x00; ebx_25 -= 0x1000)
			{
				if (esi_24->dw0000 == 0xF0 && VirtualFree((word32) (*((word32) edi_126 + 16)) + ebx_25, 0x1000, 0x4000) != 0x00)
				{
					esi_24->dw0000 = ~0x00;
					--g_dw408BBC;
					struct Eq_4963 * eax_50 = *((word32) edi_126 + 0x0C);
					if (eax_50 == null || eax_50 > esi_24)
						*((word32) edi_126 + 0x0C) = esi_24;
					++ebp_21;
					--dwArg04;
					if (dwArg04 == 0x01)
						break;
				}
				esi_24 -= 0x08;
			}
			edi_126 = *((word32) edi_126 + 4);
			if (ebp_21 != 0x00 && *((word32) edi_126 + 24) == ~0x00)
			{
				int32 eax_101 = 0x01;
				struct Eq_5033 * ecx_103 = (word32) edi_126 + 32;
				while (ecx_103->dw0000 == ~0x00)
				{
					++eax_101;
					++ecx_103;
					if (eax_101 >= 0x0400)
						break;
				}
				if (eax_101 == 0x0400)
					fn00403750(edi_126);
			}
		}
	} while (edi_126 != g_t406754 && dwArg04 > 0x00);
}

// 00403880: Register int32 fn00403880(Stack Eq_93 dwArg04, Stack (ptr32 (ptr32 Eq_5053)) dwArg08, Stack (ptr32 ui32) dwArg0C)
// Called from:
//      fn00403590
int32 fn00403880(Eq_93 dwArg04, struct Eq_5053 ** dwArg08, ui32 * dwArg0C)
{
	struct Eq_5053 * eax_36 = &g_dw406750;
	do
	{
		byte cl_14 = (byte) dwArg04;
		if (dwArg04 > eax_36->t0010 && dwArg04 < eax_36->t0014)
		{
			if ((cl_14 & 0x0F) != 0x00 || (dwArg04 & 0x0FFF) < 0x0100)
				return 0x00;
			*dwArg08 = (struct Eq_5053 **) eax_36;
			*dwArg0C = dwArg04 & ~0x0FFF;
			return (dwArg04 - (dwArg04 & ~0x0FFF) - 0x0100 >> 0x04) + 0x08 + (dwArg04 & ~0x0FFF);
		}
		eax_36 = eax_36->ptr0000;
	} while (eax_36 != &g_dw406750);
	return 0x00;
}

// 004038E0: void fn004038E0(Stack (ptr32 Eq_108) dwArg04, Stack Eq_93 dwArg08, Stack (ptr32 byte) dwArg0C)
// Called from:
//      fn00403590
void fn004038E0(struct Eq_108 * dwArg04, Eq_93 dwArg08, byte * dwArg0C)
{
	int32 ecx_11 = dwArg08 - dwArg04->dw0010;
	struct Eq_5102 * eax_14 = &dwArg04->a0018->dw0000 + (ecx_11 >> 0x0C) * 0x08;
	eax_14->dw0000 = dwArg04->a0018[ecx_11 >> 0x0C].dw0000 + (uint32) (*dwArg0C);
	*dwArg0C = 0x00;
	word32 ecx_22 = eax_14->dw0000;
	eax_14->dw0004 = 0xF1;
	if (ecx_22 == 0xF0)
	{
		word32 eax_26 = g_dw408BBC;
		g_dw408BBC = eax_26 + 0x01;
		if (eax_26 == 0x1F)
			fn004037B0(0x10);
	}
}

// 00403940: Register Eq_5151 fn00403940(Stack Eq_93 dwArg04, Register out Eq_93 ecxOut)
// Called from:
//      fn00403020
Eq_5151 fn00403940(Eq_93 dwArg04, union Eq_93 & ecxOut)
{
	Eq_93 ecx_145 = g_t408770;
	Eq_5155 bl_397 = (byte) dwArg04;
	Eq_93 dwLoc04_405 = ecx_145;
	do
	{
		Eq_93 eax_24 = *((word32) ecx_145 + 16);
		if (eax_24 != ~0x00)
		{
			Eq_5155 edi_27 = *((word32) ecx_145 + 8);
			Eq_5155 ebp_28 = (word32) ecx_145 + 8216;
			Eq_93 esi_34 = (word32) eax_24 + (((edi_27 - ecx_145) - 0x18 >> 0x03) << 0x0C);
			for (; edi_27 < ebp_28; edi_27 += 0x08)
			{
				Eq_93 eax_39 = *edi_27;
				if (eax_39 >= dwArg04 && *((word32) edi_27 + 4) > dwArg04)
				{
					Eq_5151 eax_53 = fn00403B80(esi_34, eax_39, dwArg04);
					if (eax_53 != 0x00)
					{
						g_t408770 = dwLoc04_405;
						*edi_27 -= dwArg04;
						*((word32) dwLoc04_405 + 8) = edi_27;
						ecxOut = dwLoc04_405;
						return eax_53;
					}
					*((word32) edi_27 + 4) = dwArg04;
					ecx_145 = dwLoc04_405;
				}
				esi_34 = (word32) esi_34 + 0x00001000;
			}
			Eq_5155 ebp_96 = *((word32) ecx_145 + 8);
			Eq_93 edi_115 = *((word32) ecx_145 + 16);
			Eq_5155 esi_101 = (word32) ecx_145 + 24;
			while (esi_101 < ebp_96)
			{
				Eq_93 eax_103 = *esi_101;
				if (eax_103 >= dwArg04 && *((word32) esi_101 + 4) > dwArg04)
				{
					Eq_5151 eax_117 = fn00403B80(edi_115, eax_103, dwArg04);
					if (eax_117 != 0x00)
					{
						g_t408770 = dwLoc04_405;
						*esi_101 -= dwArg04;
						*((word32) dwLoc04_405 + 8) = esi_101;
						ecxOut = dwLoc04_405;
						return eax_117;
					}
					*((word32) esi_101 + 4) = dwArg04;
					ecx_145 = dwLoc04_405;
				}
				esi_101 = (word32) esi_101 + 8;
				edi_115 = (word32) edi_115 + 0x00001000;
			}
		}
		ecx_145 = *ecx_145;
		dwLoc04_405 = ecx_145;
	} while (ecx_145 != g_t408770);
	Eq_93 ebp_170 = 0x00406750;
	do
	{
		if (*((word32) ebp_170 + 16) != ~0x00 && *((word32) ebp_170 + 0x0C) != null)
		{
			Eq_5155 eax_183 = (word32) *((word32) ebp_170 + 0x0C) + 8;
			Eq_93 edi_193 = (word32) *((word32) ebp_170 + 16) + (((eax_183 - ebp_170) - 0x18 >> 0x03) << 0x0C);
			int32 esi_194 = 0x00;
			eax_200 = eax_183;
			if (*eax_183 == ~0x00)
			{
				do
				{
					Eq_5155 eax_200;
					if (esi_194 >= 0x10)
						break;
					eax_200 = (word32) eax_557 + 8;
					++esi_194;
					eax_557 = eax_200;
				} while (*eax_557 == ~0x00);
			}
			Eq_93 eax_214 = esi_194 << 0x0C;
			dwLoc04_405 = eax_214;
			if (VirtualAlloc(edi_193, eax_214, 0x1000, 0x04) != edi_193)
				goto l00403B6B;
			Eq_5155 ecx_233 = eax_183;
			if (esi_194 > 0x00)
			{
				word32 eax_234 = edi_193 + 0x04;
				do
				{
					*eax_234 = 0xF0;
					Mem238[eax_234 + -4:word32] = eax_234 + 0x04;
					*((word32) eax_234 + 244) = ~0x00;
					*ecx_233 = 0xF0;
					*((word32) ecx_233 + 4) = 0xF1;
					eax_234 += 0x1000;
					ecx_233 = (word32) ecx_233 + 8;
					--esi_194;
				} while (esi_194 != 0x00);
			}
			Eq_5155 ecx_261;
			g_t408770 = ebp_170;
			Eq_5155 eax_256 = (word32) ebp_170 + 8216;
			ecx_261 = ecx_233;
			ecx_261 = ecx_233;
			if (ecx_233 < eax_256)
			{
				while (*ecx_261 != ~0x00)
				{
					ecx_261 = (word32) ecx_261 + 8;
					if (ecx_261 >= eax_256)
						break;
				}
			}
			*((word32) ebp_170 + 0x0C) = 0x00 - (ecx_233 < eax_256) & ecx_261;
			*((word32) edi_193 + 8) = bl_397;
			*((word32) ebp_170 + 8) = eax_183;
			*eax_183 -= dwArg04;
			*((word32) edi_193 + 4) -= dwArg04;
			Mem317[edi_193 + 0x00:word32] = edi_193 + 0x08 + dwArg04;
			ecxOut = eax_214;
			return edi_193 + 0x0100;
		}
		ebp_170 = *ebp_170;
	} while (ebp_170 != 0x00406750);
	Eq_93 eax_338 = fn004035E0();
	if (eax_338 == 0x00)
	{
l00403B6B:
		ecxOut = dwLoc04_405;
		return 0x00;
	}
	else
	{
		Eq_93 ecx_364 = *((word32) eax_338 + 16);
		*((word32) ecx_364 + 8) = bl_397;
		g_t408770 = eax_338;
		*ecx_364 = (word32) dwArg04 + ((word32) ecx_364 + 8);
		*((word32) ecx_364 + 4) = 0xF0 - dwArg04;
		*((word32) eax_338 + 24) -= dwArg04 & 0xFF;
		ecxOut = ecx_145;
		return (word32) ecx_364 + 0x0100;
	}
}

// 00403B80: Register ui32 fn00403B80(Stack Eq_93 dwArg04, Stack Eq_93 dwArg08, Stack Eq_93 dwArg0C)
// Called from:
//      fn00403940
ui32 fn00403B80(Eq_93 dwArg04, Eq_93 dwArg08, Eq_93 dwArg0C)
{
	Eq_5457 ecx_20 = *dwArg04;
	byte dl_239 = (byte) dwArg0C;
	Eq_93 eax_19 = *((word32) dwArg04 + 4);
	Eq_5457 esi_101 = ecx_20;
	if (eax_19 < dwArg0C)
	{
		word32 eax_26 = eax_19 + ecx_20;
		if (*eax_26 != 0x00)
			esi_101 = eax_26;
		byte dl_171;
		Eq_5457 ecx_100;
		word32 eax_32 = esi_101 + dwArg0C;
		word24 eax_24_8_272 = SLICE(eax_32, word24, 8);
		Eq_93 ebx_197 = dwArg08;
		ecx_100 = ecx_20;
		ecx_100 = ecx_20;
		if (eax_32 < (word32) dwArg04 + 0x00F8)
		{
			do
			{
				byte al_41 = *esi_101;
				dl_171 = (byte) dwArg0C;
				ui32 eax_46 = SEQ(eax_24_8_272, al_41);
				if (al_41 == 0x00)
				{
					Eq_5457 eax_51 = (word32) esi_101 + 1;
					Eq_93 ecx_52 = 0x01;
					if (*((word32) esi_101 + 1) == 0x00)
					{
						do
						{
							eax_51 = (word32) eax_51 + 1;
							ecx_52 = (word32) ecx_52 + 1;
						} while (*eax_51 == 0x00);
					}
					if (ecx_52 >= dwArg0C)
					{
						word32 eax_69 = esi_101 + dwArg0C;
						if (eax_69 < (word32) dwArg04 + 0x00F8)
						{
							*dwArg04 = eax_69;
							*((word32) dwArg04 + 4) = ecx_52 - dwArg0C;
						}
						else
						{
							*dwArg04 = (word32) dwArg04 + 8;
l00403CCF:
							((word32) dwArg04 + 4)->u0 = 0x00;
						}
l00403CD6:
						*esi_101 = dl_171;
						return (esi_101 + 0x08 << 0x04) - (dwArg04 * 0x03 + dwArg04 * 0x0C);
					}
					if (esi_101 == ecx_20)
					{
						*((word32) dwArg04 + 4) = ecx_52;
						esi_101 = eax_51;
						ecx_100 = ecx_20;
					}
					else
					{
						ebx_197 -= ecx_52;
						if (ebx_197 < dwArg0C)
							return 0x00;
						ecx_100 = ecx_20;
						esi_101 = eax_51;
					}
				}
				else
					esi_101 = (word32) esi_101 + (eax_46 & 0xFF);
				eax_24_8_272 = SLICE((word32) dwArg04 + 0x00F8, word24, 8);
			} while (esi_101 + dwArg0C <u dwArg04 + 0xF8);
		}
		esi_101 = (word32) dwArg04 + 8;
		if ((word32) dwArg04 + 8 >= ecx_100)
			return 0x00;
		do
		{
			dl_171 = (byte) dwArg0C;
			word24 eax_24_8_130 = SLICE((word32) dwArg04 + 0x00F8, word24, 8);
			if (esi_101 + dwArg0C >=u dwArg04 + 0xF8)
				return 0x00;
			byte al_126 = *esi_101;
			ui32 eax_131 = SEQ(eax_24_8_130, al_126);
			if (al_126 == 0x00)
			{
				Eq_5457 eax_136 = (word32) esi_101 + 1;
				Eq_93 ecx_137 = 0x01;
				if (*((word32) esi_101 + 1) == 0x00)
				{
					do
					{
						eax_136 = (word32) eax_136 + 1;
						ecx_137 = (word32) ecx_137 + 1;
					} while (*eax_136 == 0x00);
				}
				if (ecx_137 >= dwArg0C)
				{
					word32 eax_153 = esi_101 + dwArg0C;
					if (eax_153 >= (word32) dwArg04 + 0x00F8)
					{
						*dwArg04 = (word32) dwArg04 + 8;
						goto l00403CCF;
					}
					else
					{
						*dwArg04 = eax_153;
						*((word32) dwArg04 + 4) = ecx_137 - dwArg0C;
						goto l00403CD6;
					}
				}
				ebx_197 -= ecx_137;
				if (ebx_197 < dwArg0C)
					return 0x00;
				esi_101 = eax_136;
			}
			else
				esi_101 = (word32) esi_101 + (eax_131 & 0xFF);
		} while (esi_101 < ecx_20);
		return 0x00;
	}
	else
	{
		*ecx_20 = dl_239;
		if (ecx_20 + dwArg0C <u dwArg04 + 0xF8)
		{
			Eq_93 eax_249 = *((word32) dwArg04 + 4) - dwArg0C;
			Mem251[dwArg04 + 0x00:word32] = Mem240[dwArg04 + 0x00:word32] + dwArg0C;
			*((word32) dwArg04 + 4) = eax_249;
		}
		else
		{
			((word32) dwArg04 + 4)->u0 = 0x00;
			*dwArg04 = (word32) dwArg04 + 8;
		}
		return (ecx_20 + 0x08 << 0x04) - (dwArg04 * 0x03 + dwArg04 * 0x0C);
	}
}

// 00403D00: void fn00403D00()
// Called from:
//      fn00402DD0
void fn00403D00()
{
	word32 ebx_101 = 0x00;
	if (g_t408BC0 == null)
	{
		Eq_2427 eax_21 = LoadLibraryA(&g_t4053A4);
		if (eax_21 == null)
			return;
		Eq_5671 eax_32 = GetProcAddress(eax_21, &g_t405398);
		g_t408BC0 = eax_32;
		if (eax_32 == null)
			return;
		g_t408BC4 = GetProcAddress(eax_21, &g_t405388);
		g_t408BC8 = GetProcAddress(eax_21, &g_t405374);
	}
	struct Eq_5674 * esp_102 = fp - 0x0C;
	Eq_5671 eax_64 = g_t408BC4;
	if (eax_64 != null)
	{
		word32 eax_74;
		word32 ecx_75;
		word32 edx_76;
		eax_64();
		ebx_101 = eax_74;
	}
	if (ebx_101 != 0x00)
	{
		Eq_5671 eax_85 = g_t408BC8;
		if (eax_85 != null)
		{
			esp_102->dwFFFFFFFC = ebx_101;
			word32 eax_96;
			word32 ecx_97;
			word32 edx_98;
			eax_85();
			ebx_101 = eax_96;
		}
	}
	word32 eax_104 = esp_102->dw0018;
	word32 ecx_105 = esp_102->dw0014;
	word32 edx_106 = esp_102->dw0010;
	struct Eq_5729 * esp_107 = esp_102 - 4;
	esp_107->dw0000 = eax_104;
	esp_107->dwFFFFFFFC = ecx_105;
	esp_107->dwFFFFFFF8 = edx_106;
	esp_107->dwFFFFFFF4 = ebx_101;
	g_t408BC0();
}

// 00403D90: void fn00403D90(Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fn00402DD0
void fn00403D90(byte * dwArg04, byte * dwArg08, uint32 dwArg0C)
{
	uint32 ecx_31 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	uint32 ecx_129;
	byte al_174;
	uint32 ecx_112;
	uint32 ebx_116 = dwArg0C;
	byte * esi_172 = dwArg08;
	byte * edi_109 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
		ecx_112 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 == 0x00)
			goto l00403DD5;
	}
	else
	{
		do
		{
			al_174 = *esi_172;
			*edi_109 = al_174;
			++esi_172;
			++edi_109;
			--ecx_31;
			if (ecx_31 == 0x00)
				return;
			if (al_174 == 0x00)
			{
				while ((edi_109 & 0x03) != 0x00)
				{
					*edi_109 = al_174;
					++edi_109;
					--ecx_31;
					if (ecx_31 == 0x00)
						return;
				}
				ebx_116 = ecx_31;
				ecx_129 = ecx_31 >> 0x02;
				if (ecx_129 != 0x00)
				{
l00403E77:
					do
					{
						*edi_109 = (byte) 0x00;
						edi_109 += 4;
						--ecx_129;
					} while (ecx_129 != 0x00);
l00403E81:
					al_174 = 0x00;
					ebx_116 &= 0x03;
					if (ebx_116 == 0x00)
						return;
				}
				do
				{
					*edi_109 = al_174;
					++edi_109;
l00403E0E:
					--ebx_116;
				} while (ebx_116 != 0x00);
				return;
			}
		} while ((esi_172 & 0x03) != 0x00);
		ebx_116 = ecx_31;
		ecx_112 = ecx_31 >> 0x02;
		if (ecx_31 >> 0x02 == 0x00)
		{
l00403DD0:
			ebx_116 &= 0x03;
			if (ebx_116 == 0x00)
				return;
l00403DD5:
			do
			{
				al_174 = *esi_172;
				*edi_109 = al_174;
				++esi_172;
				++edi_109;
				if (al_174 == 0x00)
					goto l00403E0E;
				--ebx_116;
			} while (ebx_116 != 0x00);
			return;
		}
	}
	do
	{
		Eq_5789 edx_74 = *esi_172;
		Eq_5793 eax_70 = *esi_172;
		byte dl_79 = (byte) edx_74;
		byte dh_88 = SLICE(edx_74, byte, 8);
		esi_172 += 4;
		if (((~eax_70 ^ (word32) eax_70 + 0x7EFEFEFF) & 0x81010100) != 0x00)
		{
			if (dl_79 != 0x00)
			{
				if (dh_88 != 0x00)
				{
					if ((edx_74 & 0x00FF0000) != 0x00)
					{
						if ((edx_74 & 0xFF000000) != 0x00)
							goto l00403E19;
						*edi_109 = (byte) edx_74;
					}
					else
						*edi_109 = (byte) (edx_74 & 0xFFFF);
				}
				else
					*edi_109 = (byte) (edx_74 & 0xFF);
			}
			else
				*edi_109 = (byte) 0x00;
			edi_109 += 4;
			ecx_129 = ecx_112 - 0x01;
			if (ecx_129 != 0x00)
				goto l00403E77;
			goto l00403E81;
		}
l00403E19:
		*edi_109 = (byte) edx_74;
		edi_109 += 4;
		--ecx_112;
	} while (ecx_112 != 0x00);
	goto l00403DD0;
}

// 00403E90: Register word32 fn00403E90(Stack Eq_93 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00402FD0
word32 fn00403E90(Eq_93 dwArg04, ptr32 & ecxOut)
{
	<anonymous> * eax_5 = g_ptr408BD0;
	if (eax_5 != null)
	{
		word32 eax_13;
		eax_5();
		if (eax_13 != 0x00)
		{
			ecxOut = ecx;
			return 0x01;
		}
	}
	ecxOut = ecx;
	return 0x00;
}

// 00403F10: Register word32 fn00403F10(Stack Eq_111 dwArg04, Stack Eq_93 dwArg08, Stack Eq_47 dwArg0C)
// Called from:
//      fn004030E0
//      fn00403350
word32 fn00403F10(Eq_111 dwArg04, Eq_93 dwArg08, Eq_47 dwArg0C)
{
	if (dwArg04 < g_t408CE0)
	{
		struct Eq_6092 * esi_28 = (dwArg04 & 0x1F) << 0x03;
		Eq_6092 (** edi_27)[] = (dwArg04 >> 0x05) * 0x04 + 0x00408BE0;
		byte cl_31 = Mem30[esi_28 + 0x04 + 0x00408BE0[(dwArg04 >> 0x05) * 0x04]:byte];
		if ((cl_31 & 0x01) != 0x00)
		{
			Eq_47 dwLoc041C_302 = 0x00;
			word32 dwLoc040C_303 = 0x00;
			if (dwArg0C == 0x00)
				return 0x00;
			if ((cl_31 & 0x20) != 0x00)
				fn00404140(dwArg04, 0x00, 0x02);
			Eq_47 dwLoc0414_314;
			word32 eax_64 = Mem61[edi_27 + 0x00:word32] + esi_28;
			if ((eax_64->b0004 & 0x80) != 0x00)
			{
				dwLoc0414_314.u0 = 0x00;
				Eq_93 edi_103 = dwArg08;
				if (dwArg0C > 0x00)
				{
					do
					{
						Eq_6021 eax_102 = fp - 0x0404;
						while (edi_103 - dwArg08 < dwArg0C)
						{
							byte cl_111 = *edi_103;
							++edi_103;
							if (cl_111 == 0x0A)
							{
								*eax_102 = 0x0D;
								++eax_102;
								++dwLoc040C_303;
							}
							*eax_102 = cl_111;
							++eax_102;
							if (eax_102 - (fp - 0x0404) >= 0x0400)
								break;
						}
						Eq_47 esi_138 = eax_102 - (fp - 0x0404);
						if (WriteFile(*((char *) *edi_27 + (dwArg04 & 0x1F) * 0x08), fp - 0x0404, esi_138, fp - 0x0410, null) == 0x00)
						{
							dwLoc0414_314 = GetLastError();
							break;
						}
						dwLoc041C_302 += dwLoc0410;
					} while (dwLoc0410 >= esi_138 && edi_103 - dwArg08 < dwArg0C);
				}
			}
			else if (WriteFile(eax_64->t0000, dwArg08, dwArg0C, fp - 0x0410, null) != 0x00)
			{
				dwLoc0414_314.u0 = 0x00;
				dwLoc041C_302 = dwLoc0410;
			}
			else
				dwLoc0414_314 = GetLastError();
			if (dwLoc041C_302 != 0x00)
				return dwLoc041C_302 - dwLoc040C_303;
			if (dwLoc0414_314 != 0x00)
			{
				if (dwLoc0414_314 != 0x05)
				{
					fn004043D0(dwLoc0414_314);
					return ~0x00;
				}
				else
				{
					g_t408918 = dwLoc0414_314;
					g_dw408914 = 0x09;
					return ~0x00;
				}
			}
			if ((Mem182[esi_28 + 0x04 + Mem182[edi_27 + 0x00:word32]:byte] & 0x40) != 0x00 && *dwArg08 == 0x1A)
				return 0x00;
			g_dw408914 = 0x1C;
l004040C7:
			g_t408918.u0 = 0x00;
			return ~0x00;
		}
	}
	g_dw408914 = 0x09;
	goto l004040C7;
}

CHAR g_t404130 = 'j'; // 00404130
// 00404140: void fn00404140(Stack Eq_111 dwArg04, Stack Eq_4703 dwArg08, Stack Eq_47 dwArg0C)
// Called from:
//      fn00403350
//      fn00403F10
void fn00404140(Eq_111 dwArg04, Eq_4703 dwArg08, Eq_47 dwArg0C)
{
	if (dwArg04 < g_t408CE0)
	{
		struct Eq_6181 ** ebx_23 = (dwArg04 >> 0x05) * 0x04 + 0x00408BE0;
		if ((*((char *) *((char *) &g_t408BE0 + (dwArg04 >> 0x05) * 0x04) + ((dwArg04 & 0x1F) * 0x08 + 4)) & 0x01) != 0x00)
		{
			Eq_2167 eax_44 = fn00404380(dwArg04);
			if (eax_44 != (void *) ~0x00)
			{
				Eq_47 eax_69;
				if (SetFilePointer(eax_44, dwArg08, null, dwArg0C) == ~0x00)
					eax_69 = GetLastError();
				else
					eax_69.u0 = 0x00;
				if (eax_69 == 0x00)
				{
					struct Eq_6181 * eax_79 = *ebx_23;
					eax_79->a0004[dwArg04 & 0x1F].b0000 &= ~0x02;
					return;
				}
				else
				{
					fn004043D0(eax_69);
					return;
				}
			}
			else
			{
				g_dw408914 = 0x09;
				return;
			}
		}
	}
	g_dw408914 = 0x09;
	g_t408918.u0 = 0x00;
}

// 00404200: void fn00404200(Stack (ptr32 Eq_432) dwArg04)
// Called from:
//      fn00403350
void fn00404200(struct Eq_432 * dwArg04)
{
	++g_dw408910;
	word32 ecx_64;
	Eq_93 eax_11 = fn00402FB0(0x1000, out ecx_64);
	dwArg04->t0008 = eax_11;
	ui32 eax_23 = dwArg04->dw000C;
	byte al_25 = (byte) eax_23;
	word24 eax_24_8_30 = SLICE(eax_23, word24, 8);
	if (eax_11 == 0x00)
	{
		dwArg04->dw0018 = 0x02;
		dwArg04->dw000C = SEQ(eax_24_8_30, al_25 | 0x04);
		dwArg04->t0008 = (char *) &dwArg04->t0010 + 4;
		dwArg04->t0000 = (char *) &dwArg04->t0010 + 4;
		dwArg04->dw0004 = 0x00;
	}
	else
	{
		Eq_93 edx_38 = dwArg04->t0008;
		dwArg04->dw000C = SEQ(eax_24_8_30, al_25 | 0x08);
		dwArg04->dw0018 = 0x1000;
		dwArg04->t0000 = edx_38;
		dwArg04->dw0004 = 0x00;
	}
}

// 00404380: Register word32 fn00404380(Stack Eq_111 dwArg04)
// Called from:
//      fn00404140
word32 fn00404380(Eq_111 dwArg04)
{
	if (dwArg04 < g_t408CE0)
	{
		struct Eq_6281 * edx_12 = *((char *) &g_t408BE0 + (dwArg04 >> 0x05) * 0x04);
		word32 * eax_16 = edx_12 + (dwArg04 & 0x1F) * 2;
		if ((edx_12->a0004[dwArg04 & 0x1F].b0000 & 0x01) != 0x00)
			return *eax_16;
	}
	g_dw408914 = 0x09;
	g_t408918.u0 = 0x00;
	return ~0x00;
}

// 004043D0: void fn004043D0(Stack Eq_47 dwArg04)
// Called from:
//      fn00403F10
//      fn00404140
void fn004043D0(Eq_47 dwArg04)
{
	g_t408918 = dwArg04;
	ui32 ecx_16 = 0x00;
	struct Eq_6311 * eax_10 = g_a408790;
	do
	{
		if (dwArg04 == eax_10->dw0000)
		{
			g_dw408914 = (&g_a408790->dw0004)[ecx_16 * 0x08];
			return;
		}
		++eax_10;
		++ecx_16;
	} while (eax_10 < &g_t4088F8);
	if (dwArg04 < 0x13 || dwArg04 > 0x24)
	{
		if (dwArg04 >= 188)
		{
			g_dw408914 = 0x08;
			if (dwArg04 <= 202)
				return;
		}
		g_dw408914 = 22;
	}
	else
		g_dw408914 = 0x0D;
}

