// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw406000 = 0x00; // 00406000
word32 g_dw406004 = 0x00; // 00406004
word32 g_dw406008 = 0x00; // 00406008
word32 g_dw406010 = 0x00; // 00406010
word32 g_dw406014 = 0x00; // 00406014
word32 g_dw40601C = 0x00; // 0040601C
word32 g_dw406020 = 0x00; // 00406020
word32 g_dw406024 = 0x00; // 00406024
ci8 g_b406030 = 0x4F; // 00406030
ci8 g_b406038 = 0x53; // 00406038
ci8 g_b406040 = 0x53; // 00406040
ci8 g_b406048 = 0x46; // 00406048
ci8 g_b406050 = 0x46; // 00406050
ci8 g_b406058 = 0x54; // 00406058
ci8 g_b406060 = 0x54; // 00406060
<anonymous> * g_ptr406068 = &g_t401F20; // 00406068
word32 g_dw40606C = 0x01; // 0040606C
Eq_560 g_t406070 = // 00406070
	{
		0x40506C0040507C
	};
Eq_560 g_t406074 = // 00406074
	{
		0x408D000040506C
	};
Eq_34 g_t406098 = // 00406098
	{
		0x00,
		0x00,
		0x00,
		0x02,
		
		{
			0x01
		},
		0x00,
	};
Eq_34 g_t4060B8 = // 004060B8
	{
		0x00,
		0x00,
		0x00,
		0x02,
		
		{
			0x02
		},
		0x00,
	};
byte g_a406380[5] = // 00406380
	{
		0x01,
		0x02,
		0x04,
		0x08,
		0x00,
	};
Eq_6079 g_a406388[6] = // 00406388
	{
		
		{
			
			{
				0xA4
			},
		},
		
		{
			
			{
				0xA8
			},
		},
		
		{
			
			{
				181
			},
		},
		
		{
			
			{
				~0x49
			},
		},
		
		{
			
			{
				0x51
			},
		},
		
		{
			
			{
				~0x00
			},
		},
	};
Eq_6095 g_a40638C[] = // 0040638C
	{
	};
Eq_6097 g_a406390[] = // 00406390
	{
	};
Eq_6099 g_a406394[] = // 00406394
	{
	};
Eq_3043 g_t406478 = // 00406478
	{
		~0x00,
	};
Eq_6117 g_a406498[19] = // 00406498
	{
		
		{
			0x02,
			&g_str4052E8,
		},
		
		{
			0x08,
			&g_str4052BC,
		},
		
		{
			0x09,
			&g_str405290,
		},
		
		{
			0x0A,
			&g_str40526C,
		},
		
		{
			0x10,
			&g_str405240,
		},
		
		{
			0x11,
			&g_str405210,
		},
		
		{
			0x12,
			&g_str4051EC,
		},
		
		{
			0x13,
			&g_str4051C0,
		},
		
		{
			0x18,
			&g_str405188,
		},
		
		{
			0x19,
			&g_str405160,
		},
		
		{
			0x1A,
			&g_str405128,
		},
		
		{
			0x1B,
			&g_str4050F0,
		},
		
		{
			0x1C,
			&g_str4050C8,
		},
		
		{
			0x78,
			&g_str4050B8,
		},
		
		{
			121,
			&g_str4050A8,
		},
		
		{
			122,
			&g_str405098,
		},
		
		{
			252,
			&g_str405094,
		},
		
		{
			0xFF,
			&g_str405084,
		},
		
		{
			0x00404130,
			&g_str404130,
		},
	};
<anonymous> * g_ptr406528 = &g_t404130; // 00406528
<anonymous> * g_ptr40652C = &g_t404130; // 0040652C
<anonymous> * g_ptr406534 = &g_t404130; // 00406534
struct Eq_358 * g_ptr406540 = &g_t40654A; // 00406540
Eq_358 g_t40654A = // 0040654A
	{
		
		{
		},
	};
word32 g_dw406750 = 0x00406750; // 00406750
Eq_3618 g_t406754 = // 00406754
	{
		&g_str406750
	};
word32 g_dw406760 = ~0x00; // 00406760
Eq_3618 g_t408770 = // 00408770
	{
		&g_str406750
	};
Eq_3618 g_t408774 = // 00408774
	{
		&g_str01E0
	};
int32 g_dw408780 = 1; // 00408780
Eq_6149 g_a408790[46] = // 00408790
	{
		
		{
			
			{
				0x01
			},
			22,
		},
		
		{
			
			{
				0x02
			},
			0x02,
		},
		
		{
			
			{
				0x03
			},
			0x02,
		},
		
		{
			
			{
				0x04
			},
			0x18,
		},
		
		{
			
			{
				0x05
			},
			0x0D,
		},
		
		{
			
			{
				0x06
			},
			0x09,
		},
		
		{
			
			{
				0x07
			},
			0x0C,
		},
		
		{
			
			{
				0x08
			},
			0x0C,
		},
		
		{
			
			{
				0x09
			},
			0x0C,
		},
		
		{
			
			{
				0x0A
			},
			0x07,
		},
		
		{
			
			{
				11
			},
			0x08,
		},
		
		{
			
			{
				0x0C
			},
			22,
		},
		
		{
			
			{
				0x0D
			},
			22,
		},
		
		{
			
			{
				0x0F
			},
			0x02,
		},
		
		{
			
			{
				0x10
			},
			0x0D,
		},
		
		{
			
			{
				0x11
			},
			0x12,
		},
		
		{
			
			{
				0x12
			},
			0x02,
		},
		
		{
			
			{
				33
			},
			0x0D,
		},
		
		{
			
			{
				0x35
			},
			0x02,
		},
		
		{
			
			{
				0x41
			},
			0x0D,
		},
		
		{
			
			{
				0x43
			},
			0x02,
		},
		
		{
			
			{
				0x50
			},
			0x11,
		},
		
		{
			
			{
				0x52
			},
			0x0D,
		},
		
		{
			
			{
				0x53
			},
			0x0D,
		},
		
		{
			
			{
				0x57
			},
			22,
		},
		
		{
			
			{
				0x59
			},
			11,
		},
		
		{
			
			{
				0x6C
			},
			0x0D,
		},
		
		{
			
			{
				0x6D
			},
			0x20,
		},
		
		{
			
			{
				0x70
			},
			0x1C,
		},
		
		{
			
			{
				114
			},
			0x09,
		},
		
		{
			
			{
				0x06
			},
			22,
		},
		
		{
			
			{
				0x80
			},
			0x0A,
		},
		
		{
			
			{
				0x81
			},
			0x0A,
		},
		
		{
			
			{
				0x82
			},
			0x09,
		},
		
		{
			
			{
				131
			},
			22,
		},
		
		{
			
			{
				0x84
			},
			0x0D,
		},
		
		{
			
			{
				0x91
			},
			0x29,
		},
		
		{
			
			{
				0x9E
			},
			0x0D,
		},
		
		{
			
			{
				161
			},
			0x02,
		},
		
		{
			
			{
				0xA4
			},
			11,
		},
		
		{
			
			{
				0xA7
			},
			0x0D,
		},
		
		{
			
			{
				0xB7
			},
			0x11,
		},
		
		{
			
			{
				0xCE
			},
			0x02,
		},
		
		{
			
			{
				0xD7
			},
			11,
		},
		
		{
			
			{
				1816
			},
			0x0C,
		},
		
		{
			
			{
				0x00
			},
			0x00,
		},
	};
Eq_95 g_t4088F8 = // 004088F8
	{
		null
	};
word32 g_dw408900 = 0x00; // 00408900
word32 g_a408908[] = // 00408908
	{
	};
word32 g_dw408910 = 0x00; // 00408910
word32 g_dw408914 = 0x00; // 00408914
Eq_47 g_t408918 = // 00408918
	{
		0x00
	};
uint32 g_dw408920 = 0x00; // 00408920
uint32 g_dw408924 = 0x00; // 00408924
ui32 g_dw408928 = 0x00; // 00408928
uint32 g_dw40892C = 0x00; // 0040892C
up32 g_dw408930 = 0x00; // 00408930
Eq_95 g_t408934 = // 00408934
	{
		null
	};
Eq_95 g_t40893C = // 0040893C
	{
		null
	};
Eq_95 g_t408940 = // 00408940
	{
		null
	};
word32 g_dw40894C = 0x00; // 0040894C
byte g_b408954 = 0x00; // 00408954
word32 g_dw408958 = 0x00; // 00408958
word32 g_dw40895C = 0x00; // 0040895C
word32 g_dw408A70 = 0x00; // 00408A70
Eq_3081 g_a408A78[] = // 00408A78
	{
	};
byte g_a408A7A[255] = // 00408A7A
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_113 g_t408B7C = // 00408B7C
	{
		0x00
	};
word32 g_dw408B80 = 0x00; // 00408B80
word32 g_dw408B88 = 0x00; // 00408B88
word32 g_dw408B8C = 0x00; // 00408B8C
word32 g_dw408B90 = 0x00; // 00408B90
word32 g_dw408B94 = 0x00; // 00408B94
<anonymous> * g_ptr408B98 = null; // 00408B98
word32 g_dw408BA8 = 0x00; // 00408BA8
Eq_113 g_t408BB8 = // 00408BB8
	{
		0x00
	};
word32 g_dw408BBC = 0x00; // 00408BBC
Eq_5357 g_t408BC0 = null; // 00408BC0
Eq_5357 g_t408BC4 = null; // 00408BC4
Eq_5357 g_t408BC8 = null; // 00408BC8
word32 g_dw408BCC = 0x00; // 00408BCC
<anonymous> * g_ptr408BD0 = null; // 00408BD0
Eq_2140 g_t408BD4 = null; // 00408BD4
Eq_95 g_t408BE0 = // 00408BE0
	{
		null
	};
Eq_95 g_a408BE4[] = // 00408BE4
	{
	};
Eq_113 g_t408CE0 = // 00408CE0
	{
		0x00
	};
up32 g_dw408CE4 = 0x00; // 00408CE4
word32 * g_ptr408CE8 = null; // 00408CE8
<anonymous> * g_ptr408CEC = null; // 00408CEC
Eq_95 g_t409D04 = // 00409D04
	{
		null
	};
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40A028 = 0xA288; // 0040A028
word32 g_dw40A02C = 0xA152; // 0040A02C
word32 g_dw40A030 = 0xA160; // 0040A030
word32 g_dw40A034 = 0xA16E; // 0040A034
word32 g_dw40A038 = 41346; // 0040A038
word32 g_dw40A03C = 41366; // 0040A03C
word32 g_dw40A040 = 41394; // 0040A040
word32 g_dw40A044 = 41416; // 0040A044
word32 g_dw40A048 = 41442; // 0040A048
word32 g_dw40A04C = 41468; // 0040A04C
word32 g_dw40A050 = 41492; // 0040A050
word32 g_dw40A054 = 0xA22E; // 0040A054
word32 g_dw40A058 = 0xA244; // 0040A058
word32 g_dw40A05C = 0xA250; // 0040A05C
word32 g_dw40A060 = 0xA25A; // 0040A060
word32 g_dw40A064 = 0xA266; // 0040A064
word32 g_dw40A068 = 0xA278; // 0040A068
word32 g_dw40A06C = 0xA140; // 0040A06C
word32 g_dw40A070 = 41622; // 0040A070
word32 g_dw40A074 = 0xA2A8; // 0040A074
word32 g_dw40A078 = 41654; // 0040A078
word32 g_dw40A07C = 41668; // 0040A07C
word32 g_dw40A080 = 0xA2D2; // 0040A080
word32 g_dw40A084 = 41694; // 0040A084
word32 g_dw40A088 = 0xA2EA; // 0040A088
word32 g_dw40A08C = 41718; // 0040A08C
word32 g_dw40A090 = 0xA302; // 0040A090
word32 g_dw40A094 = 41746; // 0040A094
word32 g_dw40A098 = 41764; // 0040A098
word32 g_dw40A09C = 0xA334; // 0040A09C
word32 g_dw40A0A0 = 0xA344; // 0040A0A0
word32 g_dw40A0A4 = 41816; // 0040A0A4
word32 g_dw40A0A8 = 0xA36A; // 0040A0A8
word32 g_dw40A0AC = 0xA37A; // 0040A0AC
<anonymous> * __imp__GetFileType = &g_tA288; // 0040A0B4
<anonymous> * __imp__GetVersion = &g_tA152; // 0040A0B8
<anonymous> * __imp__ExitProcess = &g_tA160; // 0040A0BC
<anonymous> * __imp__TerminateProcess = &g_tA16E; // 0040A0C0
<anonymous> * __imp__GetCurrentProcess = &g_tA182; // 0040A0C4
<anonymous> * __imp__UnhandledExceptionFilter = &g_tA196; // 0040A0C8
<anonymous> * __imp__GetModuleFileNameA = &g_tA1B2; // 0040A0CC
<anonymous> * __imp__FreeEnvironmentStringsA = &g_tA1C8; // 0040A0D0
<anonymous> * __imp__FreeEnvironmentStringsW = &g_tA1E2; // 0040A0D4
<anonymous> * __imp__GetEnvironmentStrings = &g_tA1FC; // 0040A0D8
<anonymous> * __imp__GetEnvironmentStringsW = &g_tA214; // 0040A0DC
<anonymous> * __imp__WideCharToMultiByte = &g_tA22E; // 0040A0E0
<anonymous> * __imp__GetCPInfo = &g_tA244; // 0040A0E4
<anonymous> * __imp__GetACP = &g_tA250; // 0040A0E8
<anonymous> * __imp__GetOEMCP = &g_tA25A; // 0040A0EC
<anonymous> * __imp__SetHandleCount = &g_tA266; // 0040A0F0
<anonymous> * __imp__GetStdHandle = &g_tA278; // 0040A0F4
<anonymous> * __imp__GetCommandLineA = &g_tA140; // 0040A0F8
<anonymous> * __imp__GetStartupInfoA = &g_tA296; // 0040A0FC
<anonymous> * __imp__HeapDestroy = &g_tA2A8; // 0040A100
<anonymous> * __imp__HeapCreate = &g_tA2B6; // 0040A104
<anonymous> * __imp__VirtualFree = &g_tA2C4; // 0040A108
<anonymous> * __imp__RtlUnwind = &g_tA2D2; // 0040A10C
<anonymous> * __imp__WriteFile = &g_tA2DE; // 0040A110
<anonymous> * __imp__HeapAlloc = &g_tA2EA; // 0040A114
<anonymous> * __imp__HeapFree = &g_tA2F6; // 0040A118
<anonymous> * __imp__VirtualAlloc = &g_tA302; // 0040A11C
<anonymous> * __imp__GetProcAddress = &g_tA312; // 0040A120
<anonymous> * __imp__LoadLibraryA = &g_tA324; // 0040A124
<anonymous> * __imp__GetLastError = &g_tA334; // 0040A128
<anonymous> * __imp__FlushFileBuffers = &g_tA344; // 0040A12C
<anonymous> * __imp__SetFilePointer = &g_tA358; // 0040A130
<anonymous> * __imp__SetStdHandle = &g_tA36A; // 0040A134
<anonymous> * __imp__CloseHandle = &g_tA37A; // 0040A138
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str405084[] = "runtime error "; // 00405084
char g_str405094[] = "\r\n"; // 00405094
char g_str405098[] = "TLOSS error\r\n"; // 00405098
char g_str4050A8[] = "SING error\r\n"; // 004050A8
char g_str4050B8[] = "DOMAIN error\r\n"; // 004050B8
char g_str4050C8[] = "R6028\r\n- unable to initialize heap\r\n"; // 004050C8
char g_str4050F0[] = "R6027\r\n- not enough space for lowio initialization\r\n"; // 004050F0
char g_str405128[] = "R6026\r\n- not enough space for stdio initialization\r\n"; // 00405128
char g_str405160[] = "R6025\r\n- pure virtual function call\r\n"; // 00405160
char g_str405188[] = "R6024\r\n- not enough space for _onexit/atexit table\r\n"; // 00405188
char g_str4051C0[] = "R6019\r\n- unable to open console device\r\n"; // 004051C0
char g_str4051EC[] = "R6018\r\n- unexpected heap error\r\n"; // 004051EC
char g_str405210[] = "R6017\r\n- unexpected multithread lock error\r\n"; // 00405210
char g_str405240[] = "R6016\r\n- not enough space for thread data\r\n"; // 00405240
char g_str40526C[] = "\r\nabnormal program termination\r\n"; // 0040526C
char g_str405290[] = "R6009\r\n- not enough space for environment\r\n"; // 00405290
char g_str4052BC[] = "R6008\r\n- not enough space for arguments\r\n"; // 004052BC
char g_str4052E8[] = "R6002\r\n- floating point not loaded\r\n"; // 004052E8
char g_str405338[] = "\n\n"; // 00405338
Eq_3734 g_t40533C = // 0040533C;
byte g_b405358 = 0x2E; // 00405358
Eq_3725 g_t40535C = // 0040535C;
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register word32 fn00401000(Stack up32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401000(up32 dwArg04)
{
	if (dwArg04 > 0x07)
	{
		fn004010A0(&g_b406030);
		return;
	}
	else
	{
		switch (dwArg04)
		{
		case 0x02:
			fn004010A0(&g_b406060);
			return;
		case 0x03:
			fn004010A0(&g_b406058);
			return;
		case 0x04:
			fn004010A0(&g_b406050);
			return;
		case 0x05:
			fn004010A0(&g_b406048);
			return;
		case 0x06:
			fn004010A0(&g_b406040);
			return;
		case 0x07:
			fn004010A0(&g_b406038);
			return;
		}
	}
}

// 004010A0: void fn004010A0(Stack (ptr32 ci8) dwArg04)
// Called from:
//      fn00401000
void fn004010A0(ci8 * dwArg04)
{
	word32 eax_12 = fn00401230(&g_t406098);
	fn00401330(dwArg04);
	fn004012D0(eax_12, &g_t406098);
}

// 004010E0: Register Eq_47 Win32CrtStartup()
Eq_47 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_49 * fs;
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	Eq_47 eax_30 = GetVersion();
	uint32 edx_35 = (uint32) SLICE(eax_30, byte, 8);
	g_dw40892C = edx_35;
	g_dw408928 = eax_30 & 0xFF;
	g_dw408924 = ((eax_30 & 0xFF) << 0x08) + edx_35;
	g_dw408920 = eax_30 >> 0x10;
	if (fn00402B80() == 0x00)
		fn00401200(0x1C);
	fn00402980();
	fn00402970();
	g_t409D04.u0 = (word32 *) GetCommandLineA();
	Eq_95 eax_90 = fn00402540();
	g_t4088F8.u0 = (word32 *) eax_90;
	if (eax_90 == 0x00 || g_t409D04.u0 == 0x00)
		fn00401F00(~0x00);
	fn00402290();
	fn004021A0();
	fn00401ED0();
	g_t408940.u0 = g_t40893C.u0;
	Eq_47 eax_169 = fn00401F00(fn00401000(g_dw408930));
	fs->ptr0000 = eax_15;
	return eax_169;
}

// 00401200: Register word32 fn00401200(Stack word32 dwArg04)
// Called from:
//      Win32CrtStartup
//      fn004021A0
//      fn00402290
//      fn00402980
word32 fn00401200(word32 dwArg04)
{
	if (g_dw408900 != 0x02)
		fn00402D90();
	fn00402DD0(dwArg04);
	word32 ecx_36;
	g_ptr406068();
	return ecx_36;
}

// 00401230: Register word32 fn00401230(Stack (ptr32 Eq_34) dwArg04)
// Called from:
//      fn004010A0
word32 fn00401230(struct Eq_34 * dwArg04)
{
	if (fn00403060(dwArg04->t0010.u1) == 0x00)
		return 0x00;
	ui32 edi_30;
	if (dwArg04 == &g_t406098)
		edi_30 = 0x00;
	else
	{
		if (dwArg04 != &g_t4060B8)
			return 0x00;
		edi_30 = 0x01;
	}
	++g_dw408910;
	if ((dwArg04->dw000C & 0x010C) != 0x00)
		return 0x00;
	if (g_a408908[edi_30 * 0x04] == 0x00)
	{
		word32 ecx_139;
		Eq_95 eax_54 = fn00402FB0(0x1000, out ecx_139);
		g_a408908[edi_30 * 0x04] = (word32) eax_54;
		if (eax_54 == 0x00)
			return 0x00;
	}
	word32 eax_80 = g_a408908[edi_30 * 0x04];
	dwArg04->dw0018 = 0x1000;
	dwArg04->dw0008 = eax_80;
	dwArg04->dw0000 = eax_80;
	ui32 eax_85 = dwArg04->dw000C;
	dwArg04->dw0004 = 0x1000;
	dwArg04->dw000C = eax_85 | 0x1102;
	return 0x01;
}

// 004012D0: void fn004012D0(Stack word32 dwArg04, Stack (ptr32 Eq_44) dwArg08)
// Called from:
//      fn004010A0
void fn004012D0(word32 dwArg04, struct Eq_44 * dwArg08)
{
	if (dwArg04 == 0x00)
	{
		if ((dwArg08->b000D & 0x10) != 0x00)
			fn004030E0(dwArg08);
	}
	else
	{
		if ((dwArg08->b000D & 0x10) == 0x00)
			return;
		fn004030E0(dwArg08);
		ui32 eax_53 = dwArg08->dw000C;
		dwArg08->dw0018 = 0x00;
		dwArg08->dw000C = SEQ(SLICE(eax_53, word16, 16), SLICE(eax_53, byte, 8) & ~0x11, (byte) eax_53);
		dwArg08->t0000.u0 = 0x00;
		dwArg08->t0008.u0 = 0x00;
	}
}

// 00401330: void fn00401330(Stack (ptr32 ci8) dwArg08)
// Called from:
//      fn004010A0
void fn00401330(ci8 * dwArg08)
{
	ptr32 fp;
	ui32 dwLoc0234;
	Eq_287 esp_1066 = fp - 0x025C;
	struct Eq_290 * ecx_1341 = null;
	Eq_292 ebp_1397 = 0x00;
	ci8 bl_1302 = *dwArg08;
	struct Eq_298 * edi_1132 = dwArg08 + 1;
	if (bl_1302 != 0x00)
	{
		ui32 esi_1340 = dwLoc0234;
		while (*((word32) esp_1066 + 28) >= 0x00)
		{
			ui32 eax_41;
			if (bl_1302 >= 0x20 && bl_1302 <= 0x78)
			{
				struct Eq_315 * eax_45 = (int32) bl_1302;
				eax_41 = SEQ(SLICE(eax_45, word24, 8), eax_45->b404FF0) & 0x0F;
			}
			else
				eax_41 = 0x00;
			int32 eax_59 = (int32) ecx_1341->a405010[eax_41].b0000;
			*((word32) esp_1066 + 60) = eax_59 >> 0x04;
			if (eax_59 >> 0x04 <= 0x07)
			{
				switch (eax_59 >> 0x04)
				{
				case 0x00:
l00401530:
					struct Eq_358 * eax_1272 = g_ptr406540;
					*((word32) esp_1066 + 44) = 0x00;
					if ((eax_1272->a0001[*((word32) esp_1066 + 64) & 0xFF].b0000 & 0x80) != 0x00)
					{
						struct Eq_433 * edx_1282 = *((word32) esp_1066 + 608);
						struct Eq_473 * esp_1287 = esp_1066 - 4;
						esp_1287->t0000.u0 = (word32) esp_1066 + 28;
						esp_1287->ptrFFFFFFFC = edx_1282;
						esp_1287->tFFFFFFF8.u0 = (int32) bl_1302;
						fn00401CC0(esp_1287->tFFFFFFF8.u0, esp_1287->ptrFFFFFFFC, esp_1287->t0000.u0);
						bl_1302 = edi_1132->b0000;
						esp_1287->ptr0268 = &edi_1132->b0001;
					}
					struct Eq_433 * edx_1310 = *((word32) esp_1066 + 608);
					struct Eq_437 * esp_1314 = esp_1066 - 4;
					esp_1314->t0000.u0 = (word32) esp_1066 + 28;
					esp_1314->ptrFFFFFFFC = edx_1310;
					esp_1314->tFFFFFFF8.u0 = (int32) bl_1302;
					fn00401CC0(esp_1314->tFFFFFFF8.u0, esp_1314->ptrFFFFFFFC, esp_1314->t0000.u0);
					esp_1066 = (char *) &esp_1314->t0000 + 4;
					break;
				case 0x01:
					*((word32) esp_1066 + 0x0044) = 0x00;
					*((word32) esp_1066 + 52) = 0x00;
					*((word32) esp_1066 + 40) = 0x00;
					*((word32) esp_1066 + 36) = 0x00;
					*((word32) esp_1066 + 16) = 0x00;
					*((word32) esp_1066 + 24) = ~0x00;
					*((word32) esp_1066 + 44) = 0x00;
					break;
				case 0x02:
					Eq_407 eax_1209 = (int32) bl_1302;
					if (eax_1209 <= 0x30)
					{
						switch ((word32) eax_1209)
						{
						case 0x20:
							word32 eax_1255 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1255, word24, 8), (byte) eax_1255 | 0x02);
							break;
						case 33:
						case 0x22:
						case 0x24:
						case 0x25:
						case 0x26:
						case 0x27:
						case 0x28:
						case 0x29:
						case 0x2A:
						case 44:
						case 0x2E:
						case 0x2F:
							break;
						case 0x23:
							word32 eax_1246 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1246, word24, 8), (byte) eax_1246 | 0x80);
							break;
						case 0x2B:
							word32 eax_1237 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1237, word24, 8), (byte) eax_1237 | 0x01);
							break;
						case 0x2D:
							word32 eax_1228 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1228, word24, 8), (byte) eax_1228 | 0x04);
							break;
						case 0x30:
							word32 eax_1219 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1219, word24, 8), (byte) eax_1219 | 0x08);
							break;
						}
					}
					break;
				case 0x03:
					if (bl_1302 == 0x2A)
					{
						Eq_1709 esp_1187 = esp_1066 - 4;
						*esp_1187 = (word32) esp_1066 + 616;
						Eq_560 eax_1189 = fn00401D90(*esp_1187);
						*((word32) esp_1187 + 44) = eax_1189;
						esp_1066 = (word32) esp_1187 + 4;
						if (eax_1189 < 0x00)
						{
							*((word32) esp_1187 + 20) |= 0x04;
							*((word32) esp_1187 + 44) = -eax_1189;
						}
					}
					else
						*((word32) esp_1066 + 40) = (int32) bl_1302 - 48 + esi_1340 * 0x0A;
					break;
				case 0x04:
					*((word32) esp_1066 + 24) = 0x00;
					break;
				case 0x05:
					if (bl_1302 == 0x2A)
					{
						Eq_1533 esp_1163 = esp_1066 - 4;
						*esp_1163 = (word32) esp_1066 + 616;
						Eq_560 eax_1165 = fn00401D90(*esp_1163);
						*((word32) esp_1163 + 28) = eax_1165;
						esp_1066 = (word32) esp_1163 + 4;
						if (eax_1165 < 0x00)
							*((word32) esp_1163 + 28) = ~0x00;
					}
					else
						*((word32) esp_1066 + 24) = (int32) bl_1302 - 48 + *((word32) esp_1066 + 24) * 0x0A;
					break;
				case 0x06:
					Eq_419 eax_1093 = (int32) bl_1302;
					if (eax_1093 <= 0x77)
					{
						switch ((word32) eax_1093)
						{
						case 0x49:
							if (edi_1132->b0000 != 0x36 || edi_1132->b0001 != 0x34)
							{
								*((word32) esp_1066 + 60) = 0x00;
								goto l00401530;
							}
							ui32 eax_1143 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 612) = &edi_1132->b0001 + 1;
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1143, word16, 16), SLICE(eax_1143, byte, 8) | 0x80, (byte) eax_1143);
							break;
						case 0x4A:
						case 0x4B:
						case 0x4C:
						case 77:
						case 0x4E:
						case 0x4F:
						case 0x50:
						case 0x51:
						case 0x52:
						case 0x53:
						case 0x54:
						case 0x55:
						case 0x56:
						case 0x57:
						case 88:
						case 0x59:
						case 0x5A:
						case 0x5B:
						case 0x5C:
						case 0x5D:
						case 0x5E:
						case 0x5F:
						case 0x60:
						case 0x61:
						case 0x62:
						case 99:
						case 100:
						case 101:
						case 0x66:
						case 0x67:
						case 0x69:
						case 0x6A:
						case 0x6B:
						case 0x6D:
						case 110:
						case 111:
						case 0x70:
						case 113:
						case 114:
						case 115:
						case 116:
						case 117:
						case 118:
							break;
						case 0x68:
							ui32 eax_1122 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1122, word24, 8), (byte) eax_1122 | 0x20);
							break;
						case 0x6C:
							ui32 eax_1113 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1113, word24, 8), (byte) eax_1113 | 0x10);
							break;
						case 0x77:
							ui32 eax_1103 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_1103, word16, 16), SLICE(eax_1103, byte, 8) | 0x08, (byte) eax_1103);
							break;
						}
					}
					break;
				case 0x07:
					Eq_423 eax_69 = (int32) bl_1302;
					if (eax_69 <= 0x78)
					{
						switch ((word32) eax_69)
						{
						case 0x43:
							ui32 eax_761 = *((word32) esp_1066 + 16);
							byte ah_766 = SLICE(eax_761, byte, 8);
							byte al_771 = (byte) eax_761;
							word16 eax_16_16_772 = SLICE(eax_761, word16, 16);
							if ((eax_761 & 0x0830) == 0x00)
								*((word32) esp_1066 + 16) = SEQ(eax_16_16_772, ah_766 | 0x08, al_771);
							goto l004015DA;
						case 0x44:
						case 0x46:
						case 0x48:
						case 0x49:
						case 0x4A:
						case 0x4B:
						case 0x4C:
						case 77:
						case 0x4E:
						case 0x4F:
						case 0x50:
						case 0x51:
						case 0x52:
						case 0x54:
						case 0x55:
						case 0x56:
						case 0x57:
						case 0x59:
						case 0x5B:
						case 0x5C:
						case 0x5D:
						case 0x5E:
						case 0x5F:
						case 0x60:
						case 0x61:
						case 0x62:
						case 0x68:
						case 0x6A:
						case 0x6B:
						case 0x6C:
						case 0x6D:
						case 113:
						case 114:
						case 116:
						case 118:
						case 0x77:
							goto l00401A50;
						case 0x45:
						case 0x47:
							*((word32) esp_1066 + 0x0044) = 0x01;
							bl_1302 += 0x20;
							goto l004017A2;
						case 0x53:
							ui32 eax_490 = *((word32) esp_1066 + 16);
							byte ah_495 = SLICE(eax_490, byte, 8);
							byte al_500 = (byte) eax_490;
							word16 eax_16_16_501 = SLICE(eax_490, word16, 16);
							if ((eax_490 & 0x0830) == 0x00)
								*((word32) esp_1066 + 16) = SEQ(eax_16_16_501, ah_495 | 0x08, al_500);
							goto l004016BE;
						case 88:
							goto l004018A0;
						case 0x5A:
							struct Eq_552 * esp_132 = esp_1066 - 4;
							esp_132->t0000.u0 = (word32) esp_1066 + 616;
							Eq_560 eax_134 = fn00401D90(esp_132->t0000.u0);
							esp_1066 = (char *) &esp_132->t0000 + 4;
							if (eax_134 != 0x00)
							{
								Eq_560 ecx_145 = eax_134.u2[2];
								if (ecx_145 != 0x00)
								{
									if ((esp_132->b0015 & 0x08) != 0x00)
									{
										Eq_748 ebp_174 = (int32) eax_134.u2->t0000.u1;
										esp_132->t0018.u1 = (byte *) ecx_145;
										esp_132->dw0030 = 0x01;
										ebp_1397 = ebp_174 >> 0x01;
									}
									else
									{
										ebp_1397.u0 = (int32) eax_134.u2->t0000.u1;
										esp_132->dw0030 = 0x00;
										esp_132->t0018.u1 = (byte *) ecx_145;
									}
									goto l00401A50;
								}
							}
							Eq_560 edi_151 = g_t406070.u1;
							esp_132->t0018.u1 = (byte *) edi_151;
							ebp_1397 = strlen(edi_151);
							goto l00401A50;
						case 99:
l004015DA:
							if ((*((word32) esp_1066 + 16) & 0x0810) != 0x00)
							{
								struct Eq_1337 * esp_796 = esp_1066 - (struct Eq_1338 *) 4;
								Mem797[esp_796 + 0x00:word32] = esp_1066 + 616;
								esp_796->dw0000 = (int32) fn00401DD0(esp_796->dw0000);
								Mem810[esp_796 + -4:word32] = esp_796 + 96;
								Eq_292 eax_811 = fn004031E0(esp_796->dwFFFFFFFC, esp_796->dw0000);
								ebp_1397 = eax_811;
								esp_1066 = esp_796 + 1;
								if (eax_811 < 0x00)
								{
									esp_796[0x0E] = (struct Eq_1337) 0x01;
									esp_796[6] = (struct Eq_1337) (esp_796 + 24);
									goto l00401A50;
								}
							}
							else
							{
								struct Eq_1319 * esp_782 = esp_1066 - (struct Eq_1320 *) 4;
								Mem783[esp_782 + 0x00:word32] = esp_1066 + 616;
								esp_782[24] = (struct Eq_1319) (byte) fn00401D90(esp_782->t0000.u0);
								ebp_1397.u0 = 0x01;
							}
							*((word32) esp_1066 + 20) = (word32) esp_1066 + 92;
							goto l00401A50;
						case 100:
						case 0x69:
							ui32 eax_121 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 48) = 0x0A;
							*((word32) esp_1066 + 16) = SEQ(SLICE(eax_121, word24, 8), (byte) eax_121 | 0x40);
							break;
						case 101:
						case 0x66:
						case 0x67:
l004017A2:
							ui32 edx_607 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 20) = (word32) esp_1066 + 92;
							int32 eax_610 = *((word32) esp_1066 + 24);
							*((word32) esp_1066 + 16) = edx_607 | 0x40;
							if (eax_610 < 0x00)
								*((word32) esp_1066 + 24) = 0x06;
							else if (eax_610 == 0x00 && bl_1302 == 0x67)
								*((word32) esp_1066 + 24) = 0x01;
							struct Eq_1253 * eax_626 = *((word32) esp_1066 + 616);
							Eq_1257 edi_627 = *((word32) esp_1066 + 24);
							*((word32) esp_1066 + 616) = &eax_626->dw0004 + 1;
							*((word32) esp_1066 + 76) = eax_626->dw0000;
							Eq_441 eax_634 = *((word32) esp_1066 + 0x0044);
							*((word32) esp_1066 + 80) = eax_626->dw0004;
							struct Eq_1282 * esp_638 = esp_1066 - (struct Eq_1283 *) 4;
							esp_638->t0000.u0 = (BOOL) eax_634;
							esp_638->dwFFFFFFFC = (word32) edi_627;
							Eq_292 ecx_637 = (int32) bl_1302;
							esp_638->tFFFFFFF8.u0 = (int32) ecx_637;
							Mem647[esp_638 + -0x0C:word32] = esp_638 + 96;
							Mem649[esp_638 + -16:word32] = esp_638 + 80;
							struct Eq_1306 * esp_675;
							g_ptr406528();
							ui32 esi_681 = esp_675->dw0024;
							esp_1066 = &esp_675->ptr0010 + 1;
							if ((esi_681 & 0x80) != 0x00 && edi_627 == 0x00)
							{
								esp_675->ptr0010 = &esp_675->dw0024 + 19;
								word32 esp_695;
								word32 edx_698;
								g_ptr406534();
								esp_1066 = esp_695 + 0x04;
							}
							if (bl_1302 == 0x67 && (esi_681 & 0x80) == 0x00)
							{
								Eq_1413 edx_712 = (word32) esp_1066 + 92;
								*((word32) esp_1066 - 4) = edx_712;
								word32 esp_720;
								g_ptr40652C();
								esp_1066 = esp_720 + 0x04;
							}
							if (*((word32) esp_1066 + 92) == 0x2D)
							{
								word32 eax_733 = *((word32) esp_1066 + 16);
								*((word32) esp_1066 + 16) = SEQ(SLICE(eax_733, word16, 16), SLICE(eax_733, byte, 8) | 0x01, (byte) eax_733);
								*((word32) esp_1066 + 20) = (word32) esp_1066 + 93;
							}
							ebp_1397 = strlen(*((word32) esp_1066 + 20));
							goto l00401A50;
						case 110:
							struct Eq_615 * esp_99 = esp_1066 - 4;
							esp_99->t0000.u0 = (word32) esp_1066 + 616;
							Eq_560 eax_101 = fn00401D90(esp_99->t0000.u0);
							esp_1066 = (char *) &esp_99->t0000 + 4;
							if ((esp_99->b0014 & 0x20) != 0x00)
							{
								Eq_739 cx_116 = esp_99->t0020.u0;
								esp_99->dw0038 = 0x01;
								eax_101.u2->t0000.u1 = (word16) cx_116;
							}
							else
							{
								Eq_739 edx_113 = esp_99->t0020.u1;
								esp_99->dw0038 = 0x01;
								eax_101->u1 = edx_113;
							}
							goto l00401A50;
						case 111:
							Eq_638 al_82 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 48) = 0x08;
							if ((al_82 & 0x80) != 0x00)
							{
								word32 eax_88 = *((word32) esp_1066 + 16);
								*((word32) esp_1066 + 16) = SEQ(SLICE(eax_88, word16, 16), SLICE(eax_88, byte, 8) | 0x02, (byte) eax_88);
							}
							break;
						case 0x70:
							*((word32) esp_1066 + 24) = 0x08;
l004018A0:
							*((word32) esp_1066 + 56) = 0x07;
							goto l004018B2;
						case 115:
l004016BE:
							word32 eax_506 = *((word32) esp_1066 + 24);
							word32 esi_507 = 0x7FFFFFFF;
							if (eax_506 != ~0x00)
								esi_507 = eax_506;
							struct Eq_977 * esp_513 = esp_1066 - 4;
							esp_513->t0000.u0 = (word32) esp_1066 + 616;
							Eq_560 eax_515 = fn00401D90(esp_513->t0000.u0);
							ui32 eax_522 = esp_513->dw0014;
							esp_513->t0018.u1 = (byte *) eax_515;
							Eq_560 ecx_521 = eax_515;
							esp_1066 = (char *) &esp_513->t0000 + 4;
							if ((eax_522 & 0x0810) != 0x00)
							{
								if (eax_515 == 0x00)
								{
									ecx_521.u1 = g_t406074.u1;
									esp_513->t0018.u1 = (byte *) ecx_521;
								}
								esp_513->dw0030 = 0x01;
								word32 esi_571 = esi_507 - 0x01;
								Eq_560 eax_578 = ecx_521;
								if (esi_507 != 0x00)
								{
									while (eax_578.u2->t0000.u1 != 0x00)
									{
										eax_578.u1 = (word64) eax_578 + 2;
										esi_571 = esi_1746 - 0x01;
										esi_1746 = esi_571;
										if (esi_1746 == 0x00)
											break;
									}
								}
								ebp_1397 = eax_578 - ecx_521 >> 0x01;
							}
							else
							{
								if (eax_515 == 0x00)
								{
									ecx_521.u1 = g_t406070.u1;
									esp_513->t0018.u1 = (byte *) ecx_521;
								}
								word32 esi_538 = esi_507 - 0x01;
								Eq_560 eax_543 = ecx_521;
								if (esi_507 != 0x00)
								{
									while (*eax_543.u1 != 0x00)
									{
										++eax_543.u1;
										esi_538 = esi_1745 - 0x01;
										esi_1745 = esi_538;
										if (esi_1745 == 0x00)
											break;
									}
								}
								ebp_1397 = eax_543 - ecx_521;
							}
							goto l00401A50;
						case 117:
							*((word32) esp_1066 + 48) = 0x0A;
							break;
						case 0x78:
							*((word32) esp_1066 + 56) = 0x27;
l004018B2:
							byte al_183 = *((word32) esp_1066 + 16);
							*((word32) esp_1066 + 48) = 0x10;
							if ((al_183 & 0x80) != 0x00)
							{
								Eq_778 cl_189 = *((word32) esp_1066 + 56);
								*((word32) esp_1066 + 0x0022) = 0x30;
								*((word32) esp_1066 + 36) = 0x02;
								*((word32) esp_1066 + 35) = (word32) cl_189 + 81;
							}
							break;
						}
						Eq_560 eax_215;
						Eq_763 edx_222;
						ui32 ebx_197 = *((word32) esp_1066 + 16);
						byte bh_198 = SLICE(ebx_197, byte, 8);
						byte bl_203 = (byte) ebx_197;
						word16 ebx_16_16_327 = SLICE(ebx_197, word16, 16);
						if ((bh_198 & 0x80) != 0x00)
						{
							struct Eq_2064 *** esp_272 = esp_1066 - 4;
							*esp_272 = (word32) esp_1066 + 616;
							eax_215 = fn00401DB0(*esp_272, out edx_222);
						}
						else if ((bl_203 & 0x20) != 0x00)
						{
							if ((bl_203 & 0x40) != 0x00)
							{
								union Eq_441 * esp_258 = esp_1066 - 4;
								esp_258->u0 = (word32) esp_1066 + 616;
								int64 edx_eax_270 = (int64) (int32) (word16) fn00401D90(esp_258->u0);
								edx_222 = SLICE(edx_eax_270, word32, 32);
								eax_215 = (word32) edx_eax_270;
							}
							else
							{
								union Eq_441 * esp_243 = esp_1066 - 4;
								esp_243->u0 = (word32) esp_1066 + 616;
								int64 edx_eax_256 = (int64) (fn00401D90(esp_243->u0) & 0xFFFF);
								edx_222 = SLICE(edx_eax_256, word32, 32);
								eax_215 = (word32) edx_eax_256;
							}
						}
						else if ((bl_203 & 0x40) != 0x00)
						{
							union Eq_441 * esp_227 = esp_1066 - 4;
							esp_227->u0 = (word32) esp_1066 + 616;
							int64 edx_eax_237 = (int64) fn00401D90(esp_227->u0);
							edx_222 = SLICE(edx_eax_237, word32, 32);
							eax_215 = (word32) edx_eax_237;
						}
						else
						{
							union Eq_441 * esp_213 = esp_1066 - 4;
							esp_213->u0 = (word32) esp_1066 + 616;
							eax_215 = fn00401D90(esp_213->u0);
							edx_222.u0 = 0x00;
						}
						Eq_763 edi_309;
						Eq_560 esi_307;
						if ((bl_203 & 0x40) != 0x00 && (edx_222 <= 0x00 && (edx_222 < 0x00 || Test(ULT,false))))
						{
							*((word32) esp_1066 + 16) = SEQ(ebx_16_16_327, bh_198 | 0x01, bl_203);
							esi_307 = -eax_215;
							bh_198 |= 0x01;
							edi_309 = -((word32) edx_222.u0 + (word32) (eax_215 != 0x00));
						}
						else
						{
							esi_307 = eax_215;
							edi_309 = edx_222;
						}
						ui32 ebx_361 = SEQ(ebx_16_16_327, bh_198, bl_203);
						if ((bh_198 & 0x80) == 0x00)
							edi_309.u0 = 0x00;
						int32 ecx_1356 = *((word32) esp_1066 + 24);
						if (ecx_1356 < 0x00)
							ecx_1356 = 0x01;
						else
							*((word32) esp_1066 + 16) = ebx_361 & ~0x08;
						if ((esi_307 | edi_309) == 0x00)
							*((word32) esp_1066 + 36) = 0x00;
						struct Eq_967 * eax_382 = (word32) esp_1066 + 603;
						*((word32) esp_1066 + 20) = eax_382;
						while (true)
						{
							*((word32) esp_1066 + 24) = ecx_1356 - 0x01;
							if (ecx_1356 <= 0x00 && (esi_307 | edi_309) == 0x00)
								break;
							int64 edx_eax_430 = (int64) *((word32) esp_1066 + 48);
							uint32 edx_434 = SLICE(edx_eax_430, word32, 32);
							struct Eq_1012 * esp_433 = esp_1066 - 4;
							esp_433->dw0000 = edx_434;
							Eq_1018 eax_431 = (word32) edx_eax_430;
							esp_433->tFFFFFFFC.u0 = (uint32) eax_431;
							esp_433->tFFFFFFF8.u0 = (int32) edi_309;
							esp_433->tFFFFFFF4.u1 = (byte *) esi_307;
							esp_433->dw005C = edx_434;
							int32 eax_445 = fn004032D0(esp_433->tFFFFFFF4.u0, esp_433->tFFFFFFFC.u1);
							esp_433->dw0000 = esp_433->dw005C;
							esp_433->tFFFFFFFC.u0 = (uint32) eax_431;
							esp_433->tFFFFFFF8.u0 = (int32) edi_309;
							esp_433->tFFFFFFF4.u1 = (byte *) esi_307;
							byte bl_483 = (byte) eax_445 + 0x30;
							Eq_763 edx_467;
							esi_307 = fn00403260(esp_433->tFFFFFFF4.u1, esp_433->tFFFFFFF8.u0, esp_433->tFFFFFFFC.u0, esp_433->dw0000, out edx_467);
							edi_309 = edx_467;
							if (eax_445 > 0x09)
								bl_483 = (byte) eax_445 + 0x30 + esp_433->b003C;
							byte * eax_481 = esp_433->ptr0018;
							ecx_1356 = esp_433->dw001C;
							*eax_481 = bl_483;
							esp_433->ptr0018 = eax_481 - 0x01;
							eax_382 = eax_481 - 0x01;
						}
						byte ch_407 = *((word32) esp_1066 + 0x0011);
						struct Eq_1094 * eax_406 = (char *) &eax_382->t0000 + 1;
						*((word32) esp_1066 + 20) = eax_406;
						ebp_1397 = esp_1066 + 0x025B - eax_382;
						if ((ch_407 & 0x02) != 0x00 && (eax_406->b0000 != 0x30 || ebp_1397 == 0x00))
						{
							*((word32) esp_1066 + 20) = eax_406 - 0x01;
							eax_406->bFFFFFFFF = 0x30;
							ebp_1397 = (word32) ebp_1397.u0 + 1;
						}
					}
l00401A50:
					if (*((word32) esp_1066 + 52) == 0x00)
					{
						word32 ebx_847 = *((word32) esp_1066 + 16);
						byte bl_1058 = (byte) ebx_847;
						byte bh_853 = SLICE(ebx_847, byte, 8);
						if ((bl_1058 & 0x40) != 0x00)
						{
							if ((bh_853 & 0x01) != 0x00)
							{
								*((word32) esp_1066 + 0x0022) = 0x2D;
								goto l00401A87;
							}
							if ((bl_1058 & 0x01) != 0x00)
							{
								*((word32) esp_1066 + 0x0022) = 0x2B;
								goto l00401A87;
							}
							if ((bl_1058 & 0x02) != 0x00)
							{
								*((word32) esp_1066 + 0x0022) = 0x20;
l00401A87:
								*((word32) esp_1066 + 36) = 0x01;
							}
						}
						word32 esi_887;
						Eq_292 edi_880 = *((word32) esp_1066 + 40) - *((word32) esp_1066 + 36) - ebp_1397;
						if ((bl_1058 & 0x0C) == 0x00)
						{
							esi_887 = (word32) *((word32) esp_1066 + 608);
							Eq_1572 esp_890 = esp_1066 - 4;
							*esp_890 = (word32) esp_1066 + 28;
							*((word32) esp_890 - 4) = esi_887;
							*((word32) esp_890 - 8) = edi_880;
							*((word32) esp_890 - 0x0C) = 0x20;
							fn00401D10(*((word32) esp_890 - 0x0C), *((word32) esp_890 - 8), *((word32) esp_890 - 4), *esp_890);
						}
						else
							esi_887 = (word32) *((word32) esp_1066 + 608);
						Eq_292 edx_910 = *((word32) esp_1066 + 36);
						Eq_1613 esp_912 = esp_1066 - 4;
						*esp_912 = (word32) esp_1066 + 28;
						*((word32) esp_912 - 4) = esi_887;
						*((word32) esp_912 - 8) = edx_910;
						*((word32) esp_912 - 0x0C) = (word32) esp_912 + 38;
						fn00401D50(*((word32) esp_912 - 0x0C), *((word32) esp_912 - 8), *((word32) esp_912 - 4), *esp_912);
						if ((bl_1058 & 0x08) != 0x00 && (bl_1058 & 0x04) == 0x00)
						{
							*esp_912 = (word32) esp_912 + 32;
							*((word32) esp_912 - 4) = esi_887;
							*((word32) esp_912 - 8) = edi_880;
							*((word32) esp_912 - 0x0C) = 0x30;
							fn00401D10(*((word32) esp_912 - 0x0C), *((word32) esp_912 - 8), *((word32) esp_912 - 4), *esp_912);
						}
						word32 eax_962 = *((word32) esp_1066 + 44);
						word16 eax_16_16_1007 = SLICE(eax_962, word16, 16);
						if (eax_962 != 0x00 && ebp_1397 > 0x00)
						{
							word16 * esi_1001 = *((word32) esp_1066 + 20);
							Eq_1783 ebx_1000 = ebp_1397 - 1;
							do
							{
								Eq_1790 esp_1006 = esp_1066 - 4;
								*esp_1006 = SEQ(eax_16_16_1007, *esi_1001);
								*((word32) esp_1006 - 4) = (word32) esp_1066 + 72;
								++esi_1001;
								Eq_292 eax_1014 = fn004031E0(*((word32) esp_1006 - 4), *esp_1006);
								if (eax_1014 <= 0x00)
									break;
								struct Eq_433 * edx_1028 = *((word32) esp_1006 + 612);
								*esp_1006 = (word32) esp_1006 + 32;
								*((word32) esp_1006 - 4) = edx_1028;
								*((word32) esp_1006 - 8) = eax_1014;
								*((word32) esp_1006 - 0x0C) = (word32) esp_1006 + 76;
								eax_16_16_1007 = SLICE(fn00401D50(*((word32) esp_1006 - 0x0C), *((word32) esp_1006 - 8), *((word32) esp_1006 - 4), *esp_1006), word16, 16);
								ebx_1000 = ebx_1747 - 0x01;
								ebx_1747 = ebx_1000;
							} while (ebx_1747 != 0x00);
							bl_1058 = (byte) *((word32) esp_1066 + 16);
						}
						else
						{
							Eq_448 eax_976 = *((word32) esp_1066 + 20);
							Eq_1746 esp_978 = esp_1066 - 4;
							*esp_978 = (word32) esp_1066 + 28;
							*((word32) esp_978 - 4) = esi_887;
							*((word32) esp_978 - 8) = ebp_1397;
							*((word32) esp_978 - 0x0C) = eax_976;
							fn00401D50(*((word32) esp_978 - 0x0C), *((word32) esp_978 - 8), *((word32) esp_978 - 4), *esp_978);
						}
						if ((bl_1058 & 0x04) != 0x00)
						{
							word32 edx_1068 = *((word32) esp_1066 + 608);
							Eq_1861 esp_1070 = esp_1066 - 4;
							*esp_1070 = (word32) esp_1066 + 28;
							*((word32) esp_1070 - 4) = edx_1068;
							*((word32) esp_1070 - 8) = edi_880;
							*((word32) esp_1070 - 0x0C) = 0x20;
							fn00401D10(*((word32) esp_1070 - 0x0C), *((word32) esp_1070 - 8), *((word32) esp_1070 - 4), *esp_1070);
							esp_1066 = (word32) esp_1070 + 4;
						}
					}
					break;
				}
			}
			ci8 * edi_1331 = *((word32) esp_1066 + 612);
			bl_1302 = *edi_1331;
			*((word32) esp_1066 + 64) = bl_1302;
			*((word32) esp_1066 + 612) = edi_1331 + 1;
			edi_1132 = (struct Eq_298 *) (edi_1331 + 1);
			if (bl_1302 == 0x00)
				return;
			esi_1340 = (ui32) *((word32) esp_1066 + 40);
			ecx_1341 = (struct Eq_290 *) *((word32) esp_1066 + 60);
		}
	}
}

// 00401CC0: void fn00401CC0(Stack Eq_448 dwArg04, Stack (ptr32 Eq_433) dwArg08, Stack Eq_441 dwArg0C)
// Called from:
//      fn00401330
//      fn00401D10
//      fn00401D50
void fn00401CC0(Eq_448 dwArg04, struct Eq_433 * dwArg08, Eq_441 dwArg0C)
{
	ui32 eax_16;
	int32 eax_6 = dwArg08->dw0004;
	dwArg08->dw0004 = eax_6 - 0x01;
	if (eax_6 >= 0x01)
	{
		*dwArg08->t0000.u0 = (word32) (byte) dwArg04;
		dwArg08->t0000.u0 = (word32 *) ((char *) dwArg08->t0000.u0 + 1);
		eax_16 = dwArg04 & 0xFF;
	}
	else
		eax_16 = fn00403350(dwArg04, dwArg08);
	if (eax_16 != ~0x00)
		*dwArg0C = (word32) *dwArg0C + 1;
	else
		*dwArg0C = eax_16;
}

// 00401D10: void fn00401D10(Stack Eq_448 dwArg04, Stack Eq_292 dwArg08, Stack (ptr32 Eq_433) dwArg0C, Stack Eq_441 dwArg10)
// Called from:
//      fn00401330
void fn00401D10(Eq_448 dwArg04, Eq_292 dwArg08, struct Eq_433 * dwArg0C, Eq_441 dwArg10)
{
	int32 ebp_15 = dwArg08 - 0x01;
	if (dwArg08 > 0x00)
	{
		do
		{
			fn00401CC0(dwArg04, dwArg0C, dwArg10);
			if (*dwArg10 == ~0x00)
				return;
			ebp_15 = ebp_107 - 0x01;
			ebp_107 = ebp_15;
		} while (ebp_107 > 0x00);
	}
}

// 00401D50: Register Eq_292 fn00401D50(Stack Eq_448 dwArg04, Stack Eq_292 dwArg08, Stack (ptr32 Eq_433) dwArg0C, Stack Eq_441 dwArg10)
// Called from:
//      fn00401330
Eq_292 fn00401D50(Eq_448 dwArg04, Eq_292 dwArg08, struct Eq_433 * dwArg0C, Eq_441 dwArg10)
{
	Eq_292 eax_14 = dwArg08;
	int32 ebp_15 = dwArg08 - 0x01;
	if (dwArg08 > 0x00)
	{
		Eq_448 esi_26 = dwArg04;
		do
		{
			fn00401CC0((int32) *esi_26, dwArg0C, dwArg10);
			esi_26 = (word32) esi_26 + 1;
			eax_14 = *dwArg10;
			if (eax_14 == ~0x00)
				return eax_14;
			ebp_15 = ebp_111 - 0x01;
			ebp_111 = ebp_15;
		} while (ebp_111 > 0x00);
	}
	return eax_14;
}

// 00401D90: Register word32 fn00401D90(Stack Eq_441 dwArg04)
// Called from:
//      fn00401330
word32 fn00401D90(Eq_441 dwArg04)
{
	word32 * ecx_6 = *dwArg04;
	*dwArg04 = ecx_6 + 1;
	return *ecx_6;
}

// 00401DB0: Register word32 fn00401DB0(Stack (ptr32 (ptr32 Eq_2064)) dwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00401330
word32 fn00401DB0(struct Eq_2064 ** dwArg04, ptr32 & edxOut)
{
	struct Eq_2064 * ecx_6 = *dwArg04;
	*dwArg04 = (struct Eq_2064 **) (&ecx_6->ptr0004 + 1);
	word32 eax_10 = ecx_6->dw0000;
	edxOut = ecx_6->ptr0004;
	return eax_10;
}

// 00401DD0: Register word32 fn00401DD0(Stack Eq_441 dwArg04)
// Called from:
//      fn00401330
word32 fn00401DD0(Eq_441 dwArg04)
{
	word16 * ecx_6 = *dwArg04;
	*dwArg04 = ecx_6 + 2;
	return SEQ(SLICE(ecx_6 + 2, word16, 16), *ecx_6);
}

// 00401ED0: void fn00401ED0()
// Called from:
//      Win32CrtStartup
void fn00401ED0()
{
	<anonymous> * eax_5 = g_ptr408CEC;
	if (eax_5 != null)
		eax_5();
	fn00401FF0(&g_dw406008, &g_dw406010);
	fn00401FF0(&g_dw406000, &g_dw406004);
}

// 00401F00: Register word32 fn00401F00(Stack Eq_113 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401F00(Eq_113 dwArg04)
{
	return fn00401F40(dwArg04, 0x00, 0x00);
}

<anonymous> g_t401F20 = <code>; // 00401F20
// 00401F40: Register word32 fn00401F40(Stack Eq_113 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn00401F00
word32 fn00401F40(Eq_113 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ptr32 fp;
	if (g_dw40895C == 0x01)
		TerminateProcess(GetCurrentProcess(), dwArg04);
	g_dw408958 = 0x01;
	g_b408954 = (byte) dwArg0C;
	ptr32 esp_25 = fp - 0x0C;
	if (dwArg08 == 0x00)
	{
		word32 * ecx_36 = g_ptr408CE8;
		if (ecx_36 != null)
		{
			up32 esi_41 = g_dw408CE4;
			word32 * esi_42 = esi_41 - 0x04;
			if (esi_41 - 0x04 >= ecx_36)
			{
				do
				{
					word32 * ecx_61;
					<anonymous> * eax_47 = *esi_42;
					if (eax_47 != null)
					{
						eax_47();
						ecx_61 = g_ptr408CE8;
						ecx_36 = ecx_61;
					}
					esi_42 -= 0x04;
				} while (esi_42 >= ecx_36);
			}
		}
		struct Eq_2158 * esp_70 = esp_25 - 4;
		esp_70->ptr0000 = &g_dw40601C;
		esp_70->ptrFFFFFFFC = &g_dw406014;
		fn00401FF0(esp_70->ptrFFFFFFFC, esp_70->ptr0000);
	}
	word32 eax_87 = fn00401FF0(&g_dw406020, &g_dw406024);
	if (dwArg0C != 0x00)
		return eax_87;
	g_dw40895C = 0x01;
	ExitProcess(dwArg04);
}

// 00401FF0: Register (ptr32 code) fn00401FF0(Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn00401ED0
//      fn00401F40
<anonymous> * fn00401FF0(word32 * dwArg04, word32 * dwArg08)
{
	<anonymous> * eax;
	word32 * esi_14 = dwArg04;
	if (dwArg04 < dwArg08)
	{
		do
		{
			<anonymous> * eax_25;
			eax = *esi_14;
			if (eax != null)
			{
				eax();
				eax = eax_25;
			}
			++esi_14;
		} while (esi_14 < dwArg08);
	}
	return eax;
}

// 004021A0: void fn004021A0()
// Called from:
//      Win32CrtStartup
void fn004021A0()
{
	Eq_95 edx_33 = g_t4088F8.u0;
	byte al_17 = *edx_33.u4;
	ui32 esi_18 = 0x00;
	while (al_17 != 0x00)
	{
		if (al_17 != 0x3D)
			++esi_18;
		Eq_2240 ecx_42 = strlen(edx_33) - ~0x00;
		al_17 = Mem24[edx_33 + 1 + (ecx_42 - 0x01):byte];
		edx_33 = edx_33 + 1 + (ecx_42 - 0x01);
	}
	uint32 ecx_104;
	Eq_95 eax_60 = fn00402FB0(esi_18 * 0x04 + 0x04, out ecx_104);
	g_t40893C.u0 = (word32 *) eax_60;
	Eq_95 esi_122 = eax_60;
	Eq_95 dwLoc04_221 = eax_60;
	if (eax_60 == 0x00)
		ecx_104 = fn00401200(0x09);
	Eq_95 ebp_175 = g_t4088F8.u0;
	byte dl_107 = *ebp_175.u4;
	while (dl_107 != 0x00)
	{
		Eq_226 ecx_103 = strlen(ebp_175) - ~0x00;
		ecx_104 = ecx_103 - 0x01;
		if (dl_107 != 0x3D)
		{
			word32 ecx_276;
			Eq_95 eax_113 = fn00402FB0(ecx_103, out ecx_276);
			*esi_122.u0 = (word32) eax_113;
			if (eax_113 == 0x00)
				fn00401200(0x09);
			char * edi_155 = *dwLoc04_221.u0;
			strcpy(edi_155, ebp_175);
			ecx_104 = 0x00;
			dwLoc04_221.u0 = &dwLoc04_221.u2->b0004;
			esi_122.u0 = &dwLoc04_221.u2->b0004;
		}
		dl_107 = Mem172[ebp_175 + ecx_103:byte];
		ebp_175 += ecx_103;
	}
	fn00403590(ecx_104, g_t4088F8.u0);
	g_t4088F8.u0 = 0x00;
	*esi_122.u0 = 0x00;
}

// 00402290: void fn00402290()
// Called from:
//      Win32CrtStartup
void fn00402290()
{
	Eq_2326 tLoc08;
	Eq_2327 tLoc04;
	GetModuleFileNameA(null, 0x00408968, 0x0104);
	Eq_95 edi_19 = g_t409D04.u0;
	g_dw40894C = 0x00408968;
	if (*edi_19.u4 == 0x00)
		edi_19.u0 = 0x00408968;
	fn00402330(SLICE(&tLoc08, word24, 8), edi_19, 0x00, null, &tLoc08, &tLoc04);
	word32 ecx_147;
	Eq_95 eax_54 = fn00402FB0((word32) tLoc04 + tLoc08 * 0x04, out ecx_147);
	if (eax_54 == 0x00)
		fn00401200(0x08);
	ui32 ecx_82 = tLoc08;
	fn00402330(SLICE(ecx_82, word24, 8), edi_19, eax_54, eax_54.u0 + ecx_82 * 0x04, &tLoc08, &tLoc04);
	word32 eax_107 = tLoc08;
	g_t408934.u0 = (word32 *) eax_54;
	g_dw408930 = eax_107 - 0x01;
}

// 00402330: void fn00402330(Register word24 ecx_24_8, Stack Eq_95 dwArg04, Stack Eq_95 dwArg08, Stack (ptr32 Eq_2352) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      fn00402290
void fn00402330(word24 ecx_24_8, Eq_95 dwArg04, Eq_95 dwArg08, struct Eq_2352 * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	ui24 nArg15_649 = SLICE(dwArg14, word24, 8);
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	Eq_95 ebp_12 = dwArg08;
	struct Eq_2352 * esi_100 = dwArg0C;
	Eq_95 eax_107 = dwArg04;
	if (dwArg08 != 0x00)
	{
		*dwArg08.u0 = dwArg0C;
		ebp_12.u0 = &dwArg08.u2->b0004;
		dwArg08.u0 = &dwArg08.u2->b0004;
	}
	if (*dwArg04.u4 == 0x22)
	{
		byte cl_111 = *((word32) dwArg04 + 1);
		&eax_107.u1->a0000->u0 = dwArg04.u1 + 1;
		uint32 ecx_885 = SEQ(ecx_24_8, cl_111);
		if (cl_111 != 0x22)
		{
			while ((byte) ecx_885 != 0x00)
			{
				if (((ecx_885 & 0xFF)->b408A79 & 0x04) != 0x00)
				{
					++*dwArg14;
					if (esi_100 != null)
					{
						esi_100->b0000 = eax_107.u1->a0000[0].u0;
						++esi_100;
						&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
					}
				}
				++*dwArg14;
				if (esi_100 != null)
				{
					esi_100->b0000 = eax_107.u1->a0000[0].u0;
					++esi_100;
				}
				byte cl_161 = eax_107.u1[1];
				&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
				ecx_885 = (uint32) cl_161;
				if (cl_161 == 0x22)
					break;
			}
		}
		++*dwArg14;
		if (esi_100 != null)
		{
			esi_100->b0000 = 0x00;
			++esi_100;
		}
		if (eax_107.u1->a0000[0].u0 == 0x22)
			&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
	}
	else
	{
		do
		{
			++*dwArg14;
			if (esi_100 != null)
			{
				esi_100->b0000 = eax_107.u1->a0000[0].u0;
				++esi_100;
			}
			uint8 cl_54 = eax_107.u1->a0000[0].u0;
			&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
			if (((SEQ(nArg15_649, cl_54) & 0xFF)->b408A79 & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_100 != null)
				{
					esi_100->b0000 = eax_107.u1->a0000[0].u0;
					++esi_100;
				}
				&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
			}
			if (cl_54 == 0x20)
				break;
			if (cl_54 == 0x00)
				goto l00402409;
		} while (cl_54 != 0x09);
		if (cl_54 == 0x00)
		{
l00402409:
			--eax_107;
		}
		else if (esi_100 != null)
			esi_100->bFFFFFFFF = 0x00;
	}
	uint32 edx_189 = 0x00;
	uint32 dwArg14_607 = 0x00;
	while (eax_107.u1->a0000[0].u0 != 0x00)
	{
		while (true)
		{
			byte cl_211 = eax_107.u1->a0000[0].u0;
			if (cl_211 != 0x20 && cl_211 != 0x09)
				break;
			&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
		}
		if (eax_107.u1->a0000[0].u0 == 0x00)
			break;
		if (ebp_12 != 0x00)
		{
			*ebp_12.u0 = esi_100;
			dwArg08.u0 = &ebp_12.u2->b0004;
		}
		++*dwArg10;
		while (true)
		{
			uint32 ecx_264 = 0x00;
			word32 ebp_266 = 0x01;
			ecx_264 = 0x00;
			if (eax_107.u1->a0000[0].u0 == 0x5C)
			{
				do
				{
					&eax_107.u1->a0000->u0 = eax_890.u1 + 1;
					++ecx_264;
					eax_890 = eax_107;
				} while (*((word32) eax_890 + 1) == 0x5C);
			}
			byte cl_280 = (byte) ecx_264;
			uint32 ecx_326 = ecx_264;
			if (eax_107.u1->a0000[0].u0 == 0x22)
			{
				if ((cl_280 & 0x01) == 0x00)
				{
					if (edx_189 != 0x00 && (eax_107.u1)[1] == 0x22)
						&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
					else
						ebp_266 = 0x00;
					edx_189 = (uint32) (int8) (dwArg14_607 == 0x00);
					dwArg14_607 = edx_189;
				}
				ecx_326 = ecx_264 >> 0x01;
			}
			word32 ecx_331 = ecx_326 - 0x01;
			word24 ecx_24_8_447 = SLICE(ecx_331, word24, 8);
			if (ecx_326 != 0x00)
			{
				word32 ecx_336 = ecx_331 + 0x01;
				do
				{
					if (esi_100 != null)
					{
						esi_100->b0000 = 0x5C;
						++esi_100;
					}
					++*dwArg14;
					--ecx_336;
					ecx_24_8_447 = SLICE(ecx_336, word24, 8);
				} while (ecx_336 != 0x00);
			}
			byte cl_368 = eax_107.u1->a0000[0].u0;
			if (cl_368 == 0x00)
				break;
			ui32 ecx_446 = SEQ(ecx_24_8_447, cl_368);
			if (edx_189 == 0x00)
			{
				if (cl_368 == 0x20)
					break;
				ecx_446 = SEQ(ecx_24_8_447, cl_368);
				if (cl_368 == 0x09)
					break;
			}
			byte cl_480 = (byte) ecx_446;
			if (ebp_266 != 0x00)
			{
				if (esi_100 != null)
				{
					if (((ecx_446 & 0xFF)->b408A79 & 0x04) != 0x00)
					{
						esi_100->b0000 = cl_480;
						++*dwArg14;
						++esi_100;
						&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
					}
					esi_100->b0000 = eax_107.u1->a0000[0].u0;
					++*dwArg14;
					++esi_100;
					&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
					continue;
				}
				if (((ecx_446 & 0xFF)->b408A79 & 0x04) != 0x00)
				{
					++*dwArg14;
					&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
				}
				++*dwArg14;
			}
			&eax_107.u1->a0000->u0 = eax_107.u1 + 1;
		}
		if (esi_100 != null)
		{
			esi_100->b0000 = 0x00;
			++esi_100;
		}
		++*dwArg14;
		ebp_12 = dwArg08;
	}
	if (ebp_12 != 0x00)
		*ebp_12.u0 = 0x00;
	++*dwArg10;
}

// 00402540: Register Eq_95 fn00402540()
// Called from:
//      Win32CrtStartup
Eq_95 fn00402540()
{
	word32 eax_38 = g_dw408A70;
	Eq_2839 esi_157 = 0x00;
	Eq_2841 ebx_17 = 0x00;
	if (eax_38 == 0x00)
	{
		Eq_2839 eax_26 = GetEnvironmentStringsW();
		esi_157 = eax_26;
		if (eax_26 != 0x00)
			eax_38 = 0x01;
		else
		{
			Eq_2841 eax_32 = GetEnvironmentStrings();
			ebx_17 = eax_32;
			if (eax_32 == 0x00)
				return 0x00;
			eax_38 = 0x02;
		}
		g_dw408A70 = eax_38;
	}
	if (eax_38 != 0x01)
	{
		if (eax_38 != 0x02)
			return 0x00;
		if (ebx_17 == 0x00)
		{
			Eq_2841 eax_55 = GetEnvironmentStrings();
			ebx_17 = eax_55;
			if (eax_55 == 0x00)
				return 0x00;
		}
		Eq_2841 eax_65 = ebx_17;
		if (ebx_17.u0->t0000 != 0x00)
		{
			do
			{
				do
				{
					&eax_65.u0->t0000 = eax_460.u0 + 1;
					eax_460 = eax_65;
				} while (eax_460.u0[1] != 0x00);
				&eax_65.u0->t0000 = eax_65.u0 + 1;
			} while (eax_65.u0[1] != 0x00);
		}
		word32 eax_87 = eax_65 - ebx_17;
		word32 ecx_459;
		Eq_95 eax_99 = fn00402FB0(eax_87 + 0x01, out ecx_459);
		if (eax_99 != 0x00)
		{
			uint32 ecx_117 = eax_87 + 0x01 >> 0x02;
			memcpy(eax_99, ebx_17, ecx_117 * 0x04);
			memcpy(eax_99 + ecx_117 *u 0x04, ebx_17 + ecx_117 *u 0x04, eax_87 + 0x01 & 0x03);
			FreeEnvironmentStringsA(ebx_17);
			return eax_99;
		}
		else
		{
			FreeEnvironmentStringsA(ebx_17);
			return 0x00;
		}
	}
	else
	{
		if (esi_157 == 0x00)
		{
			Eq_2839 eax_163 = GetEnvironmentStringsW();
			esi_157 = eax_163;
			if (eax_163 == 0x00)
				return 0x00;
		}
		Eq_2839 eax_186 = esi_157;
		if (esi_157.u0->w0000 != 0x00)
		{
			do
			{
				do
					&eax_186.u0->w0000 = eax_186.u0 + 1;
				while (eax_186.u0->w0000 != 0x00);
				eax_186 += 0x02;
			} while (Mem63[eax_186 + 0x02:word16] != 0x00);
		}
		int32 eax_206 = (eax_186 - esi_157 >> 0x01) + 0x01;
		Eq_226 eax_222 = WideCharToMultiByte(0x00, 0x00, esi_157, eax_206, 0x00, 0x00, null, null);
		if (eax_222 != 0x00)
		{
			uint32 ecx_232;
			Eq_95 eax_231 = fn00402FB0(eax_222, out ecx_232);
			Eq_95 ebx_239 = eax_231;
			if (eax_231 != 0x00)
			{
				if (WideCharToMultiByte(0x00, 0x00, esi_157, eax_206, eax_231, eax_222, null, null) == 0x00)
				{
					fn00403590(ecx_232, eax_231);
					ebx_239.u0 = 0x00;
				}
				FreeEnvironmentStringsW(esi_157);
				return ebx_239;
			}
		}
		FreeEnvironmentStringsW(esi_157);
		return 0x00;
	}
}

// 004026A0: void fn004026A0(Stack Eq_113 dwArg04)
// Called from:
//      fn00402970
void fn004026A0(Eq_113 dwArg04)
{
	Eq_3030 tLoc14;
	Eq_113 eax_22 = fn00402890(dwArg04);
	if (eax_22 == g_t408B7C.u1)
		return;
	if (eax_22 != 0x00)
	{
		ui32 edx_169 = 0x00;
		struct Eq_3043 * eax_168 = g_a406388;
		do
		{
			if (eax_168->dw0000 == eax_22)
			{
				word32 ecx_167 = 0x40;
				struct Eq_3050 * edi_166 = g_a408A78;
				ui32 ebx_53 = edx_169 * 0x03;
				while (true)
				{
					word24 ecx_24_8_352 = SLICE(ecx_167, word24, 8);
					if (ecx_167 == 0x00)
						break;
					edi_166->b0000 = (byte) 0x00;
					++edi_166;
					--ecx_167;
				}
				edi_166->b0000 = 0x00;
				byte * edi_112 = g_a406380;
				struct Eq_3109 * ebp_118 = (ebx_53 << 0x04) + 0x00406398;
				do
				{
					struct Eq_3109 * esi_104 = ebp_118;
					if (ebp_118->b0000 != 0x00)
					{
						do
						{
							byte cl_74 = esi_509->b0001;
							ui32 ecx_81 = SEQ(ecx_24_8_352, cl_74);
							if (cl_74 == 0x00)
								break;
							struct Eq_3222 * eax_85 = (uint32) esi_509->b0000;
							if (eax_85 <= (ecx_81 & 0xFF))
							{
								byte dl_89 = *edi_112;
								do
								{
									eax_85[4229753] = (struct Eq_3222) (eax_85[4229753] | dl_89);
									++eax_85;
								} while (eax_85 <= (ecx_81 & 0xFF));
							}
							ecx_24_8_352 = 0x00;
							esi_104 = (struct Eq_3109 *) &esi_509->b0002;
							esi_509 = esi_104;
						} while (esi_509->b0002 != 0x00);
					}
					++edi_112;
					++ebp_118;
				} while (edi_112 < (byte *) 4290747524);
				g_t408B7C.u1 = (LPBYTE) eax_22;
				word32 eax_132 = fn004028E0(eax_22);
				word32 ecx_143 = g_a40638C[ebx_53];
				word32 edx_144 = g_a406390[ebx_53];
				g_dw408B80 = eax_132;
				g_dw408B88 = ecx_143;
				word32 eax_149 = g_a406394[ebx_53];
				g_dw408B8C = edx_144;
				g_dw408B90 = eax_149;
				return;
			}
			++eax_168;
			++edx_169;
		} while (eax_168 < &g_t406478);
		if (GetCPInfo(eax_22, &tLoc14) != 0x01)
		{
			if (g_dw408B94 == 0x00)
				return;
			fn00402940();
		}
		else
		{
			word32 ecx_213 = 0x40;
			struct Eq_3079 * edi_218 = g_a408A78;
			while (true)
			{
				word24 ecx_24_8_244 = SLICE(ecx_213, word24, 8);
				if (ecx_213 == 0x00)
					break;
				edi_218->b0000 = (byte) 0x00;
				++edi_218;
				--ecx_213;
			}
			edi_218->b0000 = 0x00;
			if (tLoc14.MaxCharSize > 0x01)
			{
				if (Mem222[&tLoc14 + 6:byte] != 0x00)
				{
					struct Eq_3139 * edx_235 = tLoc14.LeadByte + 1;
					do
					{
						byte cl_238 = edx_510->b0000;
						ui32 ecx_245 = SEQ(ecx_24_8_244, cl_238);
						if (cl_238 == 0x00)
							break;
						struct Eq_3143 * eax_249;
						for (eax_249 = (uint32) edx_510->bFFFFFFFF; eax_249 <= (ecx_245 & 0xFF); ++eax_249)
							eax_249[4229753] = (struct Eq_3143) (eax_249[4229753] | 0x04);
						ecx_24_8_244 = 0x00;
						edx_235 = &edx_510->b0001 + 1;
						edx_510 = edx_235;
					} while (edx_510->b0001 != 0x00);
				}
				struct Eq_3137 * eax_270 = (struct Eq_3137 *) 0x01;
				do
				{
					eax_270[4229753] = (struct Eq_3137) (eax_270[4229753] | 0x08);
					++eax_270;
				} while (eax_270 < (struct Eq_3137 *) 0xFF);
				g_t408B7C.u1 = (LPBYTE) eax_22;
				g_dw408B80 = fn004028E0(eax_22);
			}
			else
			{
				g_t408B7C.u1 = (LPBYTE) 0x00;
				g_dw408B80 = 0x00;
			}
			g_dw408B88 = 0x00;
			g_dw408B8C = 0x00;
			g_dw408B90 = 0x00;
		}
	}
	else
		fn00402940();
}

// 00402890: Register Eq_113 fn00402890(Stack Eq_113 dwArg04)
// Called from:
//      fn004026A0
Eq_113 fn00402890(Eq_113 dwArg04)
{
	g_dw408B94 = 0x00;
	Eq_113 eax_13 = dwArg04;
	switch (dwArg04)
	{
	case ~0x01:
		g_dw408B94 = 0x01;
		return GetOEMCP();
	case ~0x02:
		g_dw408B94 = 0x01;
		return GetACP();
	default:
		if (dwArg04 == ~0x03)
		{
			eax_13.u1 = g_t408BB8.u1;
			g_dw408B94 = 0x01;
		}
		return eax_13;
	}
}

// 004028E0: Register word32 fn004028E0(Stack Eq_113 dwArg04)
// Called from:
//      fn004026A0
word32 fn004028E0(Eq_113 dwArg04)
{
	if (dwArg04 <= 0x03B6)
	{
		switch ((word32) dwArg04)
		{
		case 0x03A4:
			return 0x0411;
		case 933:
		case 0x03A6:
		case 0x03A7:
		case 0x03A9:
		case 0x03AA:
		case 939:
		case 0x03AC:
		case 0x03AD:
		case 0x03AE:
		case 0x03AF:
		case 944:
		case 0x03B1:
		case 0x03B2:
		case 0x03B3:
		case 0x03B4:
			break;
		case 0x03A8:
			return 0x0804;
		case 949:
			return 0x0412;
		case 0x03B6:
			return 0x0404;
		}
	}
	return 0x00;
}

// 00402940: void fn00402940()
// Called from:
//      fn004026A0
void fn00402940()
{
	word32 ecx_13;
	struct Eq_3320 * edi_12 = g_a408A78;
	for (ecx_13 = 0x40; ecx_13 != 0x00; --ecx_13)
	{
		edi_12->b0000 = (byte) 0x00;
		++edi_12;
	}
	edi_12->b0000 = 0x00;
	g_t408B7C.u1 = (LPBYTE) 0x00;
	g_dw408B80 = 0x00;
	g_dw408B88 = 0x00;
	g_dw408B8C = 0x00;
	g_dw408B90 = 0x00;
}

// 00402970: void fn00402970()
// Called from:
//      Win32CrtStartup
void fn00402970()
{
	fn004026A0(~0x02);
}

// 00402980: void fn00402980()
// Called from:
//      Win32CrtStartup
void fn00402980()
{
	Eq_3350 tLoc44;
	word32 ecx_481;
	Eq_95 eax_20 = fn00402FB0(0x0100, out ecx_481);
	Eq_95 esi_28 = eax_20;
	if (eax_20 == 0x00)
		fn00401200(0x1B);
	g_t408BE0.u0 = (word32 *) eax_20;
	g_t408CE0.u1 = (LPBYTE) 0x20;
	if (eax_20 < (word32) eax_20 + 0x0100)
	{
		do
		{
			esi_28.u2->b0004 = 0x00;
			*esi_28.u0 = ~0x00;
			esi_28.u2->b0005 = 0x0A;
			esi_28.u0 = (word32) esi_28 + 8;
		} while (esi_28 < g_t408BE0.u0 + 64);
	}
	GetStartupInfoA(&tLoc44);
	if (tLoc44.cbReserved2 != 0x00)
	{
		Eq_3402 eax_72 = tLoc44.lpReserved2;
		if (eax_72 != 0x00)
		{
			Eq_113 ecx_77 = eax_72.u0->u1;
			word32 edi_151 = eax_72 + 4;
			Eq_113 dwLoc48_360 = ecx_77;
			word32 ebp_146 = eax_72 + 4 + ecx_77;
			if (ecx_77 >= 0x0800)
				dwLoc48_360.u0 = 0x0800;
			if (g_t408CE0.u1 < dwLoc48_360)
			{
				up32 * esi_110 = g_a408BE4;
				do
				{
					word32 ecx_482;
					Eq_95 eax_117 = fn00402FB0(0x0100, out ecx_482);
					if (eax_117 == 0x00)
					{
						dwLoc48_360.u1 = g_t408CE0.u1;
						break;
					}
					Eq_113 ecx_109 = g_t408CE0.u1;
					*esi_110 = (up32) eax_117;
					g_t408CE0.u1 = (word32) ecx_109 + 32;
					if (eax_117 < (word32) eax_117 + 0x0100)
					{
						do
						{
							eax_117.u2->b0004 = 0x00;
							*eax_117.u0 = ~0x00;
							eax_117.u2->b0005 = 0x0A;
							eax_117.u0 = (word32) eax_117 + 8;
						} while (eax_117 < *esi_110 + 0x0100);
					}
					++esi_110;
				} while (g_t408CE0.u1 < dwLoc48_360);
			}
			Eq_113 esi_140 = 0x00;
			if (dwLoc48_360 > 0x00)
			{
				do
				{
					Eq_2140 ecx_148 = ebp_146.u0->t0000.u1;
					if (ecx_148 != (void *) ~0x00)
					{
						byte al_152 = edi_151.u0->t0000.u0;
						if ((al_152 & 0x01) != 0x00 && ((al_152 & 0x08) != 0x00 || GetFileType(ecx_148) != 0x00))
						{
							ui32 eax_175 = esi_140 & 0x1F;
							Eq_6113 ecx_180[] = *((char *) &g_t408BE0.u0 + (esi_140 >> 0x05) * 0x04);
							ecx_180[eax_175].dw0000 = ebp_146.u0->t0000.u1;
							(&(ecx_180 + eax_175)->dw0000)[1] = (word32) edi_151.u0->t0000.u0;
						}
					}
					esi_140.u1 = (word32) esi_140 + 1;
					++edi_151;
					ebp_146 += 0x04;
				} while (esi_140 < dwLoc48_360);
			}
		}
	}
	int32 ebx_201;
	for (ebx_201 = 0x00; ebx_201 < 0x03; ++ebx_201)
	{
		byte al_213;
		Eq_95 edx_206 = g_t408BE0.u0;
		struct Eq_3425 * esi_209 = edx_206.u0 + ebx_201 * 0x08;
		if (edx_206.u0[ebx_201 * 0x08] == ~0x00)
		{
			Eq_47 eax_227;
			esi_209->b0004 = 0x81;
			if (ebx_201 == 0x00)
				eax_227.u0 = ~0x09;
			else
				eax_227 = 0x00 - (ebx_201 != 0x01) + ~0x0A;
			Eq_2140 eax_244 = GetStdHandle(eax_227);
			if (eax_244 != (void *) ~0x00)
			{
				Eq_47 eax_254 = GetFileType(eax_244);
				if (eax_254 == 0x00)
					goto l00402B4F;
				esi_209->t0000 = eax_244;
				if ((eax_254 & 0xFF) == 0x02)
				{
					al_213 = esi_209->b0004 | 0x40;
					goto l00402B5B;
				}
				if ((eax_254 & 0xFF) != 0x03)
					goto l00402B5E;
				al_213 = esi_209->b0004 | 0x08;
			}
			else
			{
l00402B4F:
				al_213 = esi_209->b0004 | 0x40;
			}
		}
		else
			al_213 = esi_209->b0004 | 0x80;
l00402B5B:
		esi_209->b0004 = al_213;
l00402B5E:
	}
	SetHandleCount(g_t408CE0.u1);
}

// 00402B80: Register Eq_2140 fn00402B80()
// Called from:
//      Win32CrtStartup
Eq_2140 fn00402B80()
{
	Eq_2140 eax_10 = HeapCreate(0x01, 0x1000, 0x00);
	g_t408BD4 = eax_10;
	if (eax_10 == null)
		return eax_10;
	if (fn004035E0() != 0x00)
		return (void *) 0x01;
	HeapDestroy(g_t408BD4);
	return null;
}

// 00402D90: void fn00402D90()
// Called from:
//      fn00401200
void fn00402D90()
{
	word32 eax_5 = g_dw408900;
	if (eax_5 == 0x01 || eax_5 == 0x00 && g_dw40606C == 0x01)
	{
		fn00402DD0(252);
		<anonymous> * eax_25 = g_ptr408B98;
		if (eax_25 != null)
		{
			word32 ecx_35;
			word32 edx_36;
			eax_25();
		}
		fn00402DD0(0xFF);
	}
}

// 00402DD0: void fn00402DD0(Stack word32 dwArg04)
// Called from:
//      fn00401200
//      fn00402D90
void fn00402DD0(word32 dwArg04)
{
	ptr32 fp;
	Eq_47 tLoc01A8;
	word32 dwLoc01A4;
	word32 dwLoc0104;
	struct Eq_3667 * eax_25 = g_a406498;
	ui32 ebp_20 = 0x00;
	while (dwArg04 != eax_25->dw0000)
	{
		++eax_25;
		++ebp_20;
		if (eax_25 >= &g_ptr406528)
			break;
	}
	if (dwArg04 != g_a406498[ebp_20])
		return;
	word32 eax_39 = g_dw408900;
	if (eax_39 != 0x01 && (eax_39 != 0x00 || g_dw40606C != 0x01))
	{
		if (dwArg04 == 252)
			return;
		if (GetModuleFileNameA(null, &dwLoc0104, 0x0104) == 0x00)
			memcpy(&dwLoc0104, &g_t40535C, 0x14);
		union Eq_3713 * ebx_146 = &dwLoc0104;
		if (strlen(&dwLoc0104) > 0x3B)
		{
			ebx_146 = strlen(&dwLoc0104) + (fp - 0x013F);
			fn00403D90(ebx_146, &g_b405358, 0x03);
		}
		memcpy(&dwLoc01A4, &g_t40533C, 0x18);
		ptr32 edi_208 = &dwLoc01A4 + ((word32) strlen(&dwLoc01A4) + 1);
		strcpy(edi_208 - 0x01, ebx_146);
		ptr32 edi_236 = &dwLoc01A4 + ((word32) strlen(&dwLoc01A4) + 1);
		strcpy(edi_236 - 0x01, "\n\n");
		char * edi_251 = *((char *) &g_a406498->ptr0004 + ebp_20 * 0x08);
		ptr32 edi_263 = &dwLoc01A4 + ((word32) strlen(&dwLoc01A4) + 1);
		strcpy(edi_263 - 0x01, edi_251);
		fn00403D00();
		return;
	}
	Eq_2140 esi_54;
	Eq_95 eax_49 = g_t408BE0.u0;
	if (eax_49 != 0x00)
	{
		esi_54 = (Eq_2140) eax_49.u1[16];
		if (esi_54 != (void *) ~0x00)
		{
l00402F78:
			Eq_95 edx_70 = *((char *) &g_a406498->ptr0004 + ebp_20 * 0x08);
			WriteFile(esi_54, edx_70, strlen(edx_70), &tLoc01A8, null);
			return;
		}
	}
	esi_54 = GetStdHandle(~0x0B);
	goto l00402F78;
}

// 00402FB0: Register word32 fn00402FB0(Stack Eq_226 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00401230
//      fn004021A0
//      fn00402290
//      fn00402540
//      fn00402980
//      fn00404200
word32 fn00402FB0(Eq_226 dwArg04, ptr32 & ecxOut)
{
	ptr32 ecx_12;
	word32 eax_11 = fn00402FD0(dwArg04, g_dw408BCC, out ecx_12);
	ecxOut = ecx_12;
	return eax_11;
}

// 00402FD0: Register word32 fn00402FD0(Stack Eq_226 dwArg04, Stack word32 dwArg08, Register out ptr32 ecxOut)
// Called from:
//      fn00402FB0
word32 fn00402FD0(Eq_226 dwArg04, word32 dwArg08, ptr32 & ecxOut)
{
	ptr32 ecx;
	word32 eax_101;
	Eq_226 esi_17 = dwArg04;
	if (dwArg04 <= ~0x1F)
	{
		if (dwArg04 == 0x00)
			esi_17.u0 = 0x01;
		do
		{
			if (esi_17 <= ~0x1F)
				eax_101 = fn00403020(esi_17, out ecx);
			else
				eax_101 = 0x00;
			if (eax_101 != 0x00 || dwArg08 == 0x00)
				goto l00403011;
		} while (fn00403E90(esi_17, out ecx) != 0x00);
	}
	eax_101 = 0x00;
l00403011:
	ecxOut = ecx;
	return eax_101;
}

// 00403020: Register Eq_3618 fn00403020(Stack Eq_226 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00402FD0
Eq_3618 fn00403020(Eq_226 dwArg04, ptr32 & ecxOut)
{
	ptr32 ecx;
	Eq_3618 eax_19;
	Eq_3618 esi_11 = (word32) dwArg04 + 0x0F & ~0x0F;
	if (esi_11 <= g_t408774.u0)
	{
		eax_19 = fn00403940(esi_11 >> 0x04, out ecx);
		if (eax_19 != 0x00)
		{
l00403056:
			ecxOut = ecx;
			return eax_19;
		}
	}
	eax_19 = HeapAlloc(g_t408BD4, 0x00, esi_11);
	goto l00403056;
}

// 00403060: Register ui32 fn00403060(Stack Eq_113 dwArg04)
// Called from:
//      fn00401230
//      fn00403350
ui32 fn00403060(Eq_113 dwArg04)
{
	if (dwArg04 < g_t408CE0.u1)
		return (uint32) *((char *) *((char *) &g_t408BE0.u0 + (dwArg04 >> 0x05) * 0x04) + ((dwArg04 & 0x1F) * 0x08 + 4)) & 0x40;
	return 0x00;
}

// 004030E0: void fn004030E0(Stack (ptr32 Eq_44) dwArg04)
// Called from:
//      fn004012D0
void fn004030E0(struct Eq_44 * dwArg04)
{
	ui32 eax_15 = dwArg04->dw000C;
	if (((byte) eax_15 & 0x03) == 0x02 && (eax_15 & 0x0108) != 0x00)
	{
		Eq_95 eax_25 = dwArg04->t0008.u0;
		Eq_47 edi_27 = dwArg04->t0000.u0 - eax_25;
		if (edi_27 > 0x00)
		{
			Eq_47 eax_40 = fn00403F10(dwArg04->t0010.u1, eax_25, edi_27);
			ui32 eax_50 = dwArg04->dw000C;
			byte al_52 = (byte) eax_50;
			word24 eax_24_8_58 = SLICE(eax_50, word24, 8);
			if (eax_40 == edi_27)
			{
				if ((al_52 & 0x80) != 0x00)
				{
					dwArg04->dw0004 = 0x00;
					dwArg04->dw000C = SEQ(eax_24_8_58, al_52 & ~0x02);
					dwArg04->t0000.u0 = dwArg04->t0008.u0;
					return;
				}
			}
			else
				dwArg04->dw000C = SEQ(eax_24_8_58, al_52 | 0x20);
		}
	}
	Eq_95 eax_67 = dwArg04->t0008.u0;
	dwArg04->dw0004 = 0x00;
	dwArg04->t0000.u0 = (word32 *) eax_67;
}

// 004031E0: Register Eq_95 fn004031E0(Stack Eq_1257 tArg04, Stack Eq_441 tArg08)
// Called from:
//      fn00401330
Eq_95 fn004031E0(Eq_1257 tArg04, Eq_441 tArg08)
{
	Eq_95 eax_5 = tArg04;
	if (eax_5 == 0x00)
		return eax_5;
	Eq_95 eax_36;
	if (g_dw408BA8 == 0x00)
	{
		cup16 cx_47 = tArg08;
		Eq_4063 cl_56 = (byte) cx_47;
		if (cx_47 <= 0xFF)
		{
			*eax_5.u4 = (char) cl_56;
			return 0x01;
		}
	}
	else
	{
		int32 edx_15 = g_dw408780;
		Eq_113 ecx_19 = g_t408BB8.u1;
		tArg04 = 0x00;
		eax_36 = WideCharToMultiByte(ecx_19, 0x0220, &tArg08, 0x01, eax_5, edx_15, null, &tArg04);
		if (eax_36 != 0x00 && tArg04 == 0x00)
			return eax_36;
	}
	g_dw408914 = 0x2A;
	eax_36.u0 = ~0x00;
	return eax_36;
}

// 00403260: Register uint32 fn00403260(Stack Eq_560 dwArg04, Stack Eq_763 dwArg08, Stack Eq_1018 dwArg0C, Stack uint32 dwArg10, Register out Eq_1070 edxOut)
// Called from:
//      fn00401330
uint32 fn00403260(Eq_560 dwArg04, Eq_763 dwArg08, Eq_1018 dwArg0C, uint32 dwArg10, union Eq_1070 & edxOut)
{
	uint32 eax_115;
	Eq_1070 edx_119;
	if (dwArg10 == 0x00)
	{
		uint64 edx_eax_72 = (uint64) dwArg08;
		eax_115 = (uint32) (SEQ((uint32) (edx_eax_72 % dwArg0C), dwArg04) /u dwArg0C);
		edx_119.u0 = (uint32) (edx_eax_72 /u dwArg0C);
	}
	else
	{
		uint64 ecx_ebx_132 = SEQ(dwArg10, dwArg0C);
		uint64 edx_eax_135 = SEQ(dwArg08, dwArg04);
		do
		{
			uint64 v23_93 = ecx_ebx_132 >> 0x01;
			uint32 ebx_26 = (word32) v23_93;
			edx_eax_135 >>= 0x01;
			ecx_ebx_132 = v23_93;
		} while (SLICE(v23_93, word32, 32) != 0x00);
		uint32 eax_41 = (uint32) (edx_eax_135 /u ebx_26);
		uint64 edx_eax_49 = eax_41 *64 dwArg0C;
		uint32 esi_42 = eax_41;
		Eq_560 eax_57 = (word32) edx_eax_49;
		Eq_763 edx_51 = SLICE(edx_eax_49, word32, 32) + dwArg10 * eax_41;
		if (edx_51 < 0x00 || (edx_51 > dwArg08 || edx_51 >= dwArg08 && eax_57 > dwArg04))
			esi_42 = eax_41 - 0x01;
		edx_119.u0 = 0x00;
		eax_115 = esi_42;
	}
	edxOut = edx_119;
	return eax_115;
}

// 004032D0: Register uint32 fn004032D0(Stack Eq_560 qwArg04, Stack Eq_1018 qwArg0C)
// Called from:
//      fn00401330
uint32 fn004032D0(Eq_560 qwArg04, Eq_1018 qwArg0C)
{
	uint32 dwArg10 = SLICE(qwArg0C, word32, 32);
	uint32 dwArg0C = (word32) qwArg0C;
	up32 dwArg08 = SLICE(qwArg04, word32, 32);
	uint32 dwArg04 = (word32) qwArg04;
	uint32 eax_127;
	if (dwArg10 == 0x00)
	{
		eax_127 = (uint32) (SEQ((uint32) ((uint64) dwArg08 % dwArg0C), dwArg04) % dwArg0C);
		return eax_127;
	}
	Eq_1018 ecx_ebx_144 = qwArg0C;
	Eq_560 edx_eax_147 = qwArg04;
	do
	{
		Eq_1018 v23_105 = ecx_ebx_144 >> 0x01;
		uint32 ebx_23 = (word32) v23_105;
		edx_eax_147 >>= 0x01;
		ecx_ebx_144 = v23_105;
	} while (SLICE(v23_105, word32, 32) != 0x00);
	word64 edx_eax_102;
	uint32 eax_38 = (uint32) (edx_eax_147 /u ebx_23);
	uint64 edx_eax_47 = dwArg0C *64 eax_38;
	uint32 eax_55 = (word32) edx_eax_47;
	up32 edx_49 = SLICE(edx_eax_47, word32, 32) + dwArg10 * eax_38;
	if (edx_49 < 0x00 || edx_49 > dwArg08)
	{
l0040332A:
		edx_eax_102 = SEQ(edx_49, eax_55) - qwArg0C;
		goto l00403332;
	}
	else
	{
		edx_eax_102 = SEQ(edx_49, eax_55);
		if (edx_49 >= dwArg08)
		{
			edx_eax_102 = SEQ(edx_49, eax_55);
			if (eax_55 > dwArg04)
				goto l0040332A;
		}
l00403332:
		eax_127 = -(word32) (edx_eax_102 - qwArg04);
		return eax_127;
	}
}

// 00403350: Register ui32 fn00403350(Stack Eq_448 dwArg04, Stack (ptr32 Eq_433) dwArg08)
// Called from:
//      fn00401CC0
ui32 fn00403350(Eq_448 dwArg04, struct Eq_433 * dwArg08)
{
	ptr32 fp;
	byte bArg04 = (byte) dwArg04;
	ui32 eax_17 = dwArg08->dw000C;
	byte al_19 = (byte) eax_17;
	word24 eax_24_8_45 = SLICE(eax_17, word24, 8);
	Eq_113 ebp_18 = dwArg08->t0010.u1;
	if ((al_19 & 0x82) != 0x00 && (al_19 & 0x40) == 0x00)
	{
		Eq_47 ebx_146 = 0x00;
		if ((al_19 & 0x01) == 0x00)
		{
l00403389:
			ui32 eax_69 = dwArg08->dw000C;
			dwArg08->dw0004 = 0x00;
			ui32 eax_76 = SEQ(SLICE(eax_69, word24, 8), (byte) eax_69 & ~0x10 | 0x02);
			dwArg08->dw000C = eax_76;
			if ((eax_76 & 0x010C) == 0x00 && (dwArg08 != &g_t406098 && dwArg08 != &g_t4060B8 || fn00403060(ebp_18) == 0x00))
				fn00404200(dwArg08);
			Eq_47 edi_125;
			if ((dwArg08->dw000C & 0x0108) != 0x00)
			{
				Eq_95 eax_147 = dwArg08->t0008.u0;
				word32 ecx_149 = dwArg08->dw0018;
				edi_125 = dwArg08->t0000.u0 - eax_147;
				dwArg08->t0000.u0 = (word32 *) (eax_147.u1 + 1);
				dwArg08->dw0004 = ecx_149 - 0x01;
				if (edi_125 > 0x00)
				{
					Eq_47 eax_210 = fn00403F10(ebp_18, eax_147, edi_125);
					*dwArg08->t0008.u0 = (word32) bArg04;
					ebx_146 = eax_210;
				}
				else
				{
					struct Eq_4313 * eax_162;
					if (ebp_18 != ~0x00)
						eax_162 = (struct Eq_4313 *) ((char *) &(*((char *) &g_t408BE0.u0 + (ebp_18 >> 0x05) * 0x04))->u0 + (ebp_18 & 0x1F) * 0x08);
					else
						eax_162 = (struct Eq_4313 *) &g_t406478;
					if ((eax_162->b0004 & 0x20) != 0x00)
						fn00404140(ebp_18, 0x00, 0x02);
					*dwArg08->t0008.u0 = (word32) bArg04;
				}
			}
			else
			{
				edi_125.u0 = 0x01;
				ebx_146 = fn00403F10(ebp_18, fp + 4, 0x01);
			}
			if (ebx_146 == edi_125)
				return dwArg04 & 0xFF;
			ui32 eax_247 = dwArg08->dw000C;
			dwArg08->dw000C = SEQ(SLICE(eax_247, word24, 8), (byte) eax_247 | 0x20);
			return ~0x00;
		}
		dwArg08->dw0004 = 0x00;
		if ((al_19 & 0x10) != 0x00)
		{
			dwArg08->t0000.u0 = dwArg08->t0008.u0;
			dwArg08->dw000C = SEQ(eax_24_8_45, al_19 & ~0x01);
			goto l00403389;
		}
	}
	dwArg08->dw000C = SEQ(eax_24_8_45, al_19 | 0x20);
	return ~0x00;
}

// 00403590: void fn00403590(Register uint32 ecx, Stack Eq_95 tArg04)
// Called from:
//      fn004021A0
//      fn00402540
void fn00403590(uint32 ecx, Eq_95 tArg04)
{
	Eq_4374 tLoc04;
	tLoc04 = (Eq_4374) ecx;
	Eq_3618 esi_10 = tArg04;
	if (esi_10 == 0x00)
		return;
	byte * eax_23 = fn00403880(esi_10, &tLoc04, &tArg04);
	if (eax_23 == null)
		HeapFree(g_t408BD4, 0x00, esi_10);
	else
		fn004038E0(tLoc04, tArg04, eax_23);
}

// 004035E0: Register Eq_3618 fn004035E0()
// Called from:
//      fn00402B80
//      fn00403940
Eq_3618 fn004035E0()
{
	Eq_3618 ebp_26;
	if (g_dw406760 == ~0x00)
		ebp_26.u0 = 0x00406750;
	else
	{
		Eq_3618 eax_24 = HeapAlloc(g_t408BD4, 0x00, 0x2020);
		ebp_26 = eax_24;
		if (eax_24 == 0x00)
			return 0x00;
	}
	Eq_3618 eax_42 = VirtualAlloc(0x00, 0x00400000, 0x2000, 0x04);
	Eq_3618 esi_170 = eax_42;
	if (eax_42 != 0x00)
	{
		if (VirtualAlloc(eax_42, 0x00010000, 0x1000, 0x04) != 0x00)
		{
			if (ebp_26 == 0x00406750)
			{
				if (g_dw406750 == 0x00)
					g_dw406750 = 0x00406750;
				if (g_t406754.u0 == 0x00)
					g_t406754.u0 = 0x00406750;
			}
			else
			{
				*ebp_26.u0 = (char) 0x00406750;
				ebp_26.u0[4] = (char) g_t406754.u0;
				g_t406754.u0 = (LPSTR) ebp_26;
				*ebp_26.u0[4] = (char) ebp_26;
			}
			ebp_26.u0[20] = (char) ((word32) eax_42 + 0x00400000);
			ebp_26.u0[16] = (char) eax_42;
			word32 ecx_124 = ebp_26 + 24;
			ebp_26.u0[8] = (char) ecx_124;
			Mem129[ebp_26 + 0x0C:word32] = ebp_26 + 0x98;
			int32 eax_130;
			for (eax_130 = 0x00; eax_130 < 0x0400; ++eax_130)
			{
				&ecx_124.u0->dw0000 = ecx_124.u0 + 1;
				ecx_124.u0->dwFFFFFFF8 = ((uint32) (int8) (eax_130 >= 0x10) - 0x01 & 0xF1) - 0x01;
				ecx_124.u0->dwFFFFFFFC = 0xF1;
			}
			word32 ecx_153;
			Eq_3618 edi_159 = eax_42;
			for (ecx_153 = 0x4000; ecx_153 != 0x00; --ecx_153)
			{
				edi_159->u0 = 0x00;
				edi_159 += 4;
			}
			if (eax_42 < (ebp_26.u0)[16] + 0x00010000)
			{
				do
				{
					esi_170.u2->t0004.u0 = 0xF0;
					Mem174[esi_170 + 0x00:word32] = esi_170 + 8;
					((word32) esi_170 + 0x00F8)->u0 = ~0x00;
					esi_170 += 0x1000;
				} while (esi_170 < (ebp_26.u0)[16] + 0x00010000);
			}
			return ebp_26;
		}
		VirtualFree(eax_42, 0x00, 0x8000);
	}
	if (ebp_26 != 0x00406750)
		HeapFree(g_t408BD4, 0x00, ebp_26);
	return 0x00;
}

// 00403750: void fn00403750(Stack Eq_3618 dwArg04)
// Called from:
//      fn004037B0
void fn00403750(Eq_3618 dwArg04)
{
	VirtualFree(*((word32) dwArg04 + 16), 0x00, 0x8000);
	if (g_t408770.u0 == dwArg04)
		g_t408770.u0 = dwArg04.u2->t0004.u0;
	if (dwArg04 == 0x00406750)
		g_dw406760 = ~0x00;
	else
	{
		*dwArg04.u2->t0004.u0 = (char) *dwArg04;
		dwArg04->u2->t0004.u0 = dwArg04.u2->t0004.u0;
		HeapFree(g_t408BD4, 0x00, dwArg04);
	}
}

// 004037B0: void fn004037B0(Stack int32 dwArg04)
// Called from:
//      fn004038E0
void fn004037B0(int32 dwArg04)
{
	Eq_3618 edi_132 = g_t406754.u0;
	do
	{
		if (*((word32) edi_132 + 16) != ~0x00)
		{
			word32 ebp_21 = 0x00;
			struct Eq_4653 * esi_25 = (word32) edi_132 + 8208;
			int32 ebx_26;
			for (ebx_26 = 0x003FF000; ebx_26 >= 0x00; ebx_26 -= 0x1000)
			{
				if (esi_25->dw0000 == 0xF0 && VirtualFree(((word32) edi_132 + 16)->u0 + ebx_26, 0x1000, 0x4000) != 0x00)
				{
					esi_25->dw0000 = ~0x00;
					--g_dw408BBC;
					struct Eq_4653 * eax_52 = *((word32) edi_132 + 0x0C);
					if (eax_52 == null || eax_52 > esi_25)
						((word32) edi_132 + 0x0C)->u0 = esi_25;
					++ebp_21;
					--dwArg04;
					if (dwArg04 == 0x01)
						break;
				}
				esi_25 -= 0x08;
			}
			edi_132.u0 = edi_132.u2->t0004.u0;
			if (ebp_21 != 0x00 && (edi_132.u0)[24] == ~0x00)
			{
				int32 eax_101 = 0x01;
				struct Eq_4726 * ecx_102 = edi_132.u0 + 32;
				while (ecx_102->dw0000 == ~0x00)
				{
					++eax_101;
					++ecx_102;
					if (eax_101 >= 0x0400)
						break;
				}
				if (eax_101 == 0x0400)
					fn00403750(edi_132);
			}
		}
	} while (edi_132 != g_t406754.u0 && dwArg04 > 0x00);
}

// 00403880: Register int32 fn00403880(Stack Eq_3618 dwArg04, Stack (ptr32 (ptr32 Eq_4746)) dwArg08, Stack (ptr32 Eq_4391) dwArg0C)
// Called from:
//      fn00403590
int32 fn00403880(Eq_3618 dwArg04, struct Eq_4746 ** dwArg08, LPSTR * dwArg0C)
{
	struct Eq_4746 * eax_38 = &g_dw406750;
	do
	{
		byte cl_14 = (byte) dwArg04;
		if (dwArg04 > (eax_38->t0010).u0 && dwArg04 < (eax_38->t0014).u0)
		{
			if ((cl_14 & 0x0F) != 0x00 || (dwArg04 & 0x0FFF) < 0x0100)
				return 0x00;
			*dwArg08 = (struct Eq_4746 **) eax_38;
			*dwArg0C = dwArg04 & ~0x0FFF;
			return (dwArg04 - (dwArg04 & ~0x0FFF) - 0x0100 >> 0x04) + 8 + (dwArg04 & ~0x0FFF);
		}
		eax_38 = eax_38->ptr0000;
	} while (eax_38 != &g_dw406750);
	return 0x00;
}

// 004038E0: void fn004038E0(Stack (ptr32 Eq_4407) dwArg04, Stack Eq_4408 dwArg08, Stack (ptr32 byte) dwArg0C)
// Called from:
//      fn00403590
void fn004038E0(struct Eq_4407 * dwArg04, Eq_4408 dwArg08, byte * dwArg0C)
{
	int32 ecx_11 = dwArg08 - dwArg04->dw0010;
	struct Eq_4795 * eax_14 = &dwArg04->a0018->dw0000 + (ecx_11 >> 0x0C) * 0x08;
	eax_14->dw0000 = dwArg04->a0018[ecx_11 >> 0x0C].dw0000 + (uint32) (*dwArg0C);
	*dwArg0C = 0x00;
	word32 ecx_22 = eax_14->dw0000;
	eax_14->dw0004 = 0xF1;
	if (ecx_22 == 0xF0)
	{
		word32 eax_26 = g_dw408BBC;
		g_dw408BBC = eax_26 + 0x01;
		if (eax_26 == 0x1F)
			fn004037B0(0x10);
	}
}

// 00403940: Register Eq_4842 fn00403940(Stack Eq_3618 dwArg04, Register out Eq_3618 ecxOut)
// Called from:
//      fn00403020
Eq_4842 fn00403940(Eq_3618 dwArg04, union Eq_3618 & ecxOut)
{
	Eq_3618 ecx_149 = g_t408770.u0;
	Eq_4845 bl_409 = (byte) dwArg04;
	Eq_3618 dwLoc04_417 = ecx_149;
	do
	{
		Eq_3618 eax_24 = *((word32) ecx_149 + 16);
		if (eax_24 != ~0x00)
		{
			Eq_4845 edi_27 = ecx_149.u2->t0008.u1;
			Eq_4845 ebp_28 = (word32) ecx_149 + 8216;
			Eq_3618 esi_34 = eax_24.u0 + (((edi_27 - ecx_149) - 0x18 >> 0x03) << 0x0C);
			for (; edi_27 < ebp_28; edi_27 += 0x08)
			{
				Eq_3618 eax_39 = edi_27.u1->dw0000;
				if (eax_39 >= dwArg04 && (edi_27.u1)->dw0004 > dwArg04)
				{
					Eq_4842 eax_53 = fn00403B80(esi_34, eax_39, dwArg04);
					if (eax_53 != 0x00)
					{
						g_t408770.u0 = (LPSTR) dwLoc04_417;
						edi_27.u1->dw0000 -= dwArg04;
						dwLoc04_417.u2->t0008.u1 = (struct Eq_6205 *) edi_27;
						ecxOut = dwLoc04_417;
						return eax_53;
					}
					edi_27.u1->dw0004 = (up32) dwArg04;
					ecx_149 = dwLoc04_417;
				}
				esi_34.u0 = (word32) esi_34 + 0x00001000;
			}
			Eq_4845 ebp_98 = ecx_149.u2->t0008.u1;
			Eq_3618 edi_117 = *((word32) ecx_149 + 16);
			Eq_4845 esi_100 = (word32) ecx_149 + 24;
			while (esi_100 < ebp_98)
			{
				Eq_3618 eax_105 = esi_100.u1->dw0000;
				if (eax_105 >= dwArg04 && (esi_100.u1)->dw0004 > dwArg04)
				{
					Eq_4842 eax_119 = fn00403B80(edi_117, eax_105, dwArg04);
					if (eax_119 != 0x00)
					{
						g_t408770.u0 = (LPSTR) dwLoc04_417;
						esi_100.u1->dw0000 -= dwArg04;
						dwLoc04_417.u2->t0008.u1 = (struct Eq_6205 *) esi_100;
						ecxOut = dwLoc04_417;
						return eax_119;
					}
					esi_100.u1->dw0004 = (up32) dwArg04;
					ecx_149 = dwLoc04_417;
				}
				&esi_100.u1->dw0000 = (word32) esi_100 + 8;
				edi_117.u0 = (word32) edi_117 + 0x00001000;
			}
		}
		ecx_149 = *ecx_149;
		dwLoc04_417 = ecx_149;
	} while (ecx_149 != g_t408770.u0);
	Eq_3618 ebp_174 = 0x00406750;
	do
	{
		if (*((word32) ebp_174 + 16) != ~0x00 && *((word32) ebp_174 + 0x0C) != null)
		{
			Eq_4845 eax_189 = &((word32) ebp_174 + 0x0C)->u2->t0008.u0;
			Eq_3618 edi_199 = ((word32) ebp_174 + 16)->u0 + (((eax_189 - ebp_174) - 0x18 >> 0x03) << 0x0C);
			int32 esi_200 = 0x00;
			eax_206 = eax_189;
			if (eax_189.u1->dw0000 == ~0x00)
			{
				do
				{
					Eq_4845 eax_206;
					if (esi_200 >= 0x10)
						break;
					&eax_206.u1->dw0000 = (word32) eax_582 + 8;
					++esi_200;
					eax_582 = eax_206;
				} while (eax_582.u1->dw0000 == ~0x00);
			}
			Eq_3618 eax_220 = esi_200 << 0x0C;
			dwLoc04_417 = eax_220;
			if (VirtualAlloc(edi_199, eax_220, 0x1000, 0x04) != edi_199)
				goto l00403B6B;
			Eq_4845 ecx_240 = eax_189;
			if (esi_200 > 0x00)
			{
				Eq_5071 eax_243 = &edi_199.u2->t0004.u0;
				do
				{
					eax_243.u0->dw0000 = 0xF0;
					Mem247[eax_243 + -4:word32] = eax_243 + 4;
					eax_243.u0->b00F4 = ~0x00;
					ecx_240.u1->dw0000 = 0xF0;
					ecx_240.u1->dw0004 = 0xF1;
					eax_243 += 0x1000;
					&ecx_240.u1->dw0000 = (word32) ecx_240 + 8;
					--esi_200;
				} while (esi_200 != 0x00);
			}
			Eq_4845 ecx_270;
			g_t408770.u0 = (LPSTR) ebp_174;
			Eq_4845 eax_265 = (word32) ebp_174 + 8216;
			ecx_270 = ecx_240;
			ecx_270 = ecx_240;
			if (ecx_240 < eax_265)
			{
				while (ecx_270.u1->dw0000 != ~0x00)
				{
					&ecx_270.u1->dw0000 = (word32) ecx_270 + 8;
					if (ecx_270 >= eax_265)
						break;
				}
			}
			((word32) ebp_174 + 0x0C)->u0 = 0x00 - (word32) (ecx_240 < eax_265) & ecx_270;
			edi_199.u2->t0008.u0 = (byte) bl_409;
			ebp_174.u2->t0008.u1 = (struct Eq_6205 *) eax_189;
			eax_189.u1->dw0000 -= dwArg04;
			edi_199.u2->t0004.u0 = (LPSTR) (edi_199.u2->t0004.u0 - dwArg04);
			Mem326[edi_199 + 0x00:word32] = edi_199 + 8 + dwArg04;
			ecxOut = eax_220;
			return edi_199 + 0x0100;
		}
		ebp_174 = *ebp_174;
	} while (ebp_174 != 0x00406750);
	Eq_3618 eax_347 = fn004035E0();
	if (eax_347 == 0x00)
	{
l00403B6B:
		ecxOut = dwLoc04_417;
		return 0x00;
	}
	else
	{
		Eq_3618 ecx_376 = *((word32) eax_347 + 16);
		ecx_376.u2->t0008.u0 = (byte) bl_409;
		g_t408770.u0 = (LPSTR) eax_347;
		Mem383[ecx_376 + 0x00:word32] = ecx_376 + 8 + dwArg04;
		ecx_376.u2->t0004.u0 = (LPSTR) (0xF0 - dwArg04);
		((word32) eax_347 + 24)->u0 = *((word32) eax_347 + 24) - (dwArg04 & 0xFF);
		ecxOut = ecx_149;
		return (word32) ecx_376 + 0x0100;
	}
}

// 00403B80: Register ui32 fn00403B80(Stack Eq_3618 dwArg04, Stack Eq_3618 dwArg08, Stack Eq_3618 dwArg0C)
// Called from:
//      fn00403940
ui32 fn00403B80(Eq_3618 dwArg04, Eq_3618 dwArg08, Eq_3618 dwArg0C)
{
	Eq_5148 ecx_20 = *dwArg04;
	byte dl_243 = (byte) dwArg0C;
	Eq_3618 eax_19 = dwArg04.u2->t0004.u0;
	Eq_5148 esi_100 = ecx_20;
	if (eax_19 < dwArg0C)
	{
		word32 eax_26 = eax_19 + ecx_20;
		if (*eax_26.u0 != 0x00)
			esi_100 = eax_26;
		byte dl_173;
		Eq_5148 ecx_101;
		word32 eax_32 = esi_100 + dwArg0C;
		word24 eax_24_8_276 = SLICE(eax_32, word24, 8);
		Eq_3618 ebx_199 = dwArg08;
		ecx_101 = ecx_20;
		ecx_101 = ecx_20;
		if (eax_32 < (word32) dwArg04 + 0x00F8)
		{
			do
			{
				byte al_41 = *esi_100.u0;
				dl_173 = (byte) dwArg0C;
				ui32 eax_47 = SEQ(eax_24_8_276, al_41);
				if (al_41 == 0x00)
				{
					Eq_5148 eax_52 = esi_100.u0 + 1;
					Eq_3618 ecx_53 = 0x01;
					if (esi_100.u0[1] == 0x00)
					{
						do
						{
							&eax_52.u1->b0000 = eax_52.u1 + 1;
							ecx_53.u0 = (word32) ecx_53 + 1;
						} while (eax_52.u1->b0000 == 0x00);
					}
					if (ecx_53 >= dwArg0C)
					{
						word32 eax_70 = esi_100 + dwArg0C;
						if (eax_70 < (word32) dwArg04 + 0x00F8)
						{
							dwArg04->u0 = eax_70;
							dwArg04.u2->t0004.u0 = (LPSTR) (ecx_53 - dwArg0C);
						}
						else
						{
							dwArg04->u0 = &dwArg04.u2->t0008.u0;
l00403CCF:
							dwArg04.u2->t0004.u0 = 0x00;
						}
l00403CD6:
						*esi_100.u0 = dl_173;
						return (esi_100 + 8 << 0x04) - dwArg04 * 0x0F;
					}
					if (esi_100 == ecx_20)
					{
						dwArg04.u2->t0004.u0 = (LPSTR) ecx_53;
						esi_100 = eax_52;
						ecx_101 = ecx_20;
					}
					else
					{
						ebx_199 -= ecx_53;
						if (ebx_199 < dwArg0C)
							return 0x00;
						ecx_101 = ecx_20;
						esi_100 = eax_52;
					}
				}
				else
					esi_100.u0 += eax_47 & 0xFF;
				eax_24_8_276 = SLICE((word32) dwArg04 + 0x00F8, word24, 8);
			} while (esi_100 + dwArg0C <u dwArg04 + 0xF8);
		}
		esi_100.u0 = &dwArg04.u2->t0008.u0;
		if (&dwArg04.u2->t0008.u0 >= ecx_101)
			return 0x00;
		do
		{
			dl_173 = (byte) dwArg0C;
			word24 eax_24_8_132 = SLICE((word32) dwArg04 + 0x00F8, word24, 8);
			if (esi_100 + dwArg0C >=u dwArg04 + 0xF8)
				return 0x00;
			byte al_127 = *esi_100.u0;
			ui32 eax_133 = SEQ(eax_24_8_132, al_127);
			if (al_127 == 0x00)
			{
				Eq_5148 eax_138 = esi_100.u0 + 1;
				Eq_3618 ecx_139 = 0x01;
				if (esi_100.u0[1] == 0x00)
				{
					do
					{
						&eax_138.u1->b0000 = eax_138.u1 + 1;
						ecx_139.u0 = (word32) ecx_139 + 1;
					} while (eax_138.u1->b0000 == 0x00);
				}
				if (ecx_139 >= dwArg0C)
				{
					word32 eax_155 = esi_100 + dwArg0C;
					if (eax_155 >= (word32) dwArg04 + 0x00F8)
					{
						dwArg04->u0 = &dwArg04.u2->t0008.u0;
						goto l00403CCF;
					}
					else
					{
						dwArg04->u0 = eax_155;
						dwArg04.u2->t0004.u0 = (LPSTR) (ecx_139 - dwArg0C);
						goto l00403CD6;
					}
				}
				ebx_199 -= ecx_139;
				if (ebx_199 < dwArg0C)
					return 0x00;
				esi_100 = eax_138;
			}
			else
				esi_100.u0 += eax_133 & 0xFF;
		} while (esi_100 < ecx_20);
		return 0x00;
	}
	else
	{
		*ecx_20.u0 = dl_243;
		if (ecx_20 + dwArg0C <u dwArg04 + 0xF8)
		{
			Eq_3618 eax_253 = dwArg04.u2->t0004.u0 - dwArg0C;
			Mem255[dwArg04 + 0x00:word32] = Mem244[dwArg04 + 0x00:word32] + dwArg0C;
			dwArg04.u2->t0004.u0 = (LPSTR) eax_253;
		}
		else
		{
			dwArg04.u2->t0004.u0 = 0x00;
			dwArg04->u0 = &dwArg04.u2->t0008.u0;
		}
		return (ecx_20 + 8 << 0x04) - dwArg04 * 0x0F;
	}
}

// 00403D00: void fn00403D00()
// Called from:
//      fn00402DD0
void fn00403D00()
{
	ptr32 fp;
	word32 ebx_108 = 0x00;
	if (g_t408BC0 == null)
	{
		Eq_2330 eax_22 = LoadLibraryA("user32.dll");
		if (eax_22 == null)
			return;
		Eq_5357 eax_34 = GetProcAddress(eax_22, "MessageBoxA");
		g_t408BC0 = eax_34;
		if (eax_34 == null)
			return;
		g_t408BC4 = GetProcAddress(eax_22, "GetActiveWindow");
		g_t408BC8 = GetProcAddress(eax_22, "GetLastActivePopup");
	}
	struct Eq_5360 * esp_102 = fp - 0x0C;
	Eq_5357 eax_68 = g_t408BC4;
	if (eax_68 != null)
	{
		word32 eax_79;
		word32 ecx_80;
		word32 edx_81;
		eax_68();
		ebx_108 = eax_79;
	}
	if (ebx_108 != 0x00)
	{
		Eq_5357 eax_91 = g_t408BC8;
		if (eax_91 != null)
		{
			esp_102->dwFFFFFFFC = ebx_108;
			word32 eax_103;
			word32 ecx_104;
			word32 edx_105;
			eax_91();
			ebx_108 = eax_103;
		}
	}
	word32 eax_111 = esp_102->dw0018;
	word32 ecx_112 = esp_102->dw0014;
	word32 edx_113 = esp_102->dw0010;
	struct Eq_5418 * esp_114 = esp_102 - 4;
	esp_114->dw0000 = eax_111;
	esp_114->dwFFFFFFFC = ecx_112;
	esp_114->dwFFFFFFF8 = edx_113;
	esp_114->dwFFFFFFF4 = ebx_108;
	g_t408BC0();
}

// 00403D90: void fn00403D90(Stack (ptr32 Eq_3713) dwArg04, Stack (ptr32 byte) dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fn00402DD0
void fn00403D90(union Eq_3713 * dwArg04, byte * dwArg08, uint32 dwArg0C)
{
	uint32 ecx_33 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	uint32 ecx_144;
	byte al_191;
	uint32 ecx_126;
	uint32 ebx_130 = dwArg0C;
	byte * esi_189 = dwArg08;
	union Eq_3713 * edi_123 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
		ecx_126 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 == 0x00)
			goto l00403DD5;
	}
	else
	{
		do
		{
			al_191 = *esi_189;
			edi_123->u0 = al_191;
			++esi_189;
			edi_123 = (union Eq_3713 *) ((char *) edi_123 + 1);
			--ecx_33;
			if (ecx_33 == 0x00)
				return;
			if (al_191 == 0x00)
			{
				while ((edi_123 & 0x03) != 0x00)
				{
					edi_123->u0 = al_191;
					edi_123 = (union Eq_3713 *) ((char *) edi_123 + 1);
					--ecx_33;
					if (ecx_33 == 0x00)
						return;
				}
				ebx_130 = ecx_33;
				ecx_144 = ecx_33 >> 0x02;
				if (ecx_144 != 0x00)
				{
l00403E77:
					do
					{
						edi_123->u1 = 0x00;
						edi_123 = (union Eq_3713 *) ((char *) edi_123 + 4);
						--ecx_144;
					} while (ecx_144 != 0x00);
l00403E81:
					al_191 = 0x00;
					ebx_130 &= 0x03;
					if (ebx_130 == 0x00)
						return;
				}
				do
				{
					edi_123->u0 = al_191;
					edi_123 = (union Eq_3713 *) ((char *) edi_123 + 1);
l00403E0E:
					--ebx_130;
				} while (ebx_130 != 0x00);
				return;
			}
		} while ((esi_189 & 0x03) != 0x00);
		ebx_130 = ecx_33;
		ecx_126 = ecx_33 >> 0x02;
		if (ecx_33 >> 0x02 == 0x00)
		{
l00403DD0:
			ebx_130 &= 0x03;
			if (ebx_130 == 0x00)
				return;
l00403DD5:
			do
			{
				al_191 = *esi_189;
				edi_123->u0 = al_191;
				++esi_189;
				edi_123 = (union Eq_3713 *) ((char *) edi_123 + 1);
				if (al_191 == 0x00)
					goto l00403E0E;
				--ebx_130;
			} while (ebx_130 != 0x00);
			return;
		}
	}
	do
	{
		Eq_5476 edx_80 = *esi_189;
		Eq_5480 eax_76 = *esi_189;
		byte dl_86 = (byte) edx_80;
		byte dh_97 = SLICE(edx_80, byte, 8);
		esi_189 += 4;
		if (((~eax_76 ^ (word32) eax_76 + 0x7EFEFEFF) & 0x81010100) != 0x00)
		{
			if (dl_86 != 0x00)
			{
				if (dh_97 != 0x00)
				{
					if ((edx_80 & 0x00FF0000) != 0x00)
					{
						if ((edx_80 & 0xFF000000) != 0x00)
							goto l00403E19;
						edi_123->u1 = (word32) edx_80;
					}
					else
						edi_123->u1 = (word32) (edx_80 & 0xFFFF);
				}
				else
					edi_123->u1 = (word32) (edx_80 & 0xFF);
			}
			else
				edi_123->u1 = 0x00;
			edi_123 = (union Eq_3713 *) ((char *) edi_123 + 4);
			ecx_144 = ecx_126 - 0x01;
			if (ecx_144 != 0x00)
				goto l00403E77;
			goto l00403E81;
		}
l00403E19:
		edi_123->u1 = (word32) edx_80;
		edi_123 = (union Eq_3713 *) ((char *) edi_123 + 4);
		--ecx_126;
	} while (ecx_126 != 0x00);
	goto l00403DD0;
}

// 00403E90: Register word32 fn00403E90(Stack Eq_226 dwArg04, Register out ptr32 ecxOut)
// Called from:
//      fn00402FD0
word32 fn00403E90(Eq_226 dwArg04, ptr32 & ecxOut)
{
	ptr32 ecx;
	<anonymous> * eax_5 = g_ptr408BD0;
	if (eax_5 != null)
	{
		word32 eax_14;
		eax_5();
		if (eax_14 != 0x00)
		{
			ecxOut = ecx;
			return 0x01;
		}
	}
	ecxOut = ecx;
	return 0x00;
}

// 00403F10: Register word32 fn00403F10(Stack Eq_113 dwArg04, Stack Eq_95 dwArg08, Stack Eq_47 dwArg0C)
// Called from:
//      fn004030E0
//      fn00403350
word32 fn00403F10(Eq_113 dwArg04, Eq_95 dwArg08, Eq_47 dwArg0C)
{
	Eq_47 tLoc0410;
	word32 dwLoc0404;
	if (dwArg04 < g_t408CE0.u1)
	{
		struct Eq_5793 * esi_28 = (dwArg04 & 0x1F) << 0x03;
		Eq_5793 (** edi_27)[] = (dwArg04 >> 0x05) * 0x04 + 0x00408BE0;
		byte cl_31 = Mem30[esi_28 + 4 + 0x00408BE0[(dwArg04 >> 0x05) * 0x04]:byte];
		if ((cl_31 & 0x01) != 0x00)
		{
			word32 dwLoc041C_314 = 0x00;
			word32 dwLoc040C_315 = 0x00;
			if (dwArg0C == 0x00)
				return 0x00;
			if ((cl_31 & 0x20) != 0x00)
				fn00404140(dwArg04, 0x00, 0x02);
			Eq_47 dwLoc0414_326;
			word32 eax_67 = Mem64[edi_27 + 0x00:word32] + esi_28;
			if ((eax_67->b0004 & 0x80) != 0x00)
			{
				dwLoc0414_326.u0 = 0x00;
				Eq_95 edi_104 = dwArg08;
				if (dwArg0C > 0x00)
				{
					do
					{
						union Eq_5712 * eax_108 = &dwLoc0404;
						while (edi_104 - dwArg08 < dwArg0C)
						{
							byte cl_117 = *edi_104.u4;
							++edi_104;
							if (cl_117 == 0x0A)
							{
								eax_108->u0 = 0x0D;
								eax_108 = (union Eq_5712 *) ((char *) eax_108 + 1);
								++dwLoc040C_315;
							}
							eax_108->u0 = cl_117;
							eax_108 = (union Eq_5712 *) ((char *) eax_108 + 1);
							if (eax_108 - &dwLoc0404 >= 0x0400)
								break;
						}
						Eq_47 esi_144 = eax_108 - &dwLoc0404;
						if (WriteFile(*((char *) *edi_27 + (dwArg04 & 0x1F) * 0x08), &dwLoc0404, esi_144, &tLoc0410, null) == 0x00)
						{
							dwLoc0414_326 = GetLastError();
							break;
						}
						Eq_47 eax_169 = tLoc0410;
						dwLoc041C_314 = (char *) eax_169.u1 + dwLoc041C_314;
					} while (eax_169 >= esi_144 && edi_104 - dwArg08 < dwArg0C);
				}
			}
			else if (WriteFile(eax_67->t0000, dwArg08, dwArg0C, &tLoc0410, null) != 0x00)
			{
				dwLoc0414_326.u0 = 0x00;
				dwLoc041C_314 = (word32) tLoc0410;
			}
			else
				dwLoc0414_326 = GetLastError();
			if (dwLoc041C_314 != 0x00)
				return dwLoc041C_314 - dwLoc040C_315;
			if (dwLoc0414_326 != 0x00)
			{
				if (dwLoc0414_326 != 0x05)
				{
					fn004043D0(dwLoc0414_326);
					return ~0x00;
				}
				else
				{
					g_t408918.u0 = (DWORD) dwLoc0414_326;
					g_dw408914 = 0x09;
					return ~0x00;
				}
			}
			if ((Mem189[esi_28 + 4 + Mem189[edi_27 + 0x00:word32]:byte] & 0x40) != 0x00 && *dwArg08.u4 == 0x1A)
				return 0x00;
			g_dw408914 = 0x1C;
l004040C7:
			g_t408918.u0 = 0x00;
			return ~0x00;
		}
	}
	g_dw408914 = 0x09;
	goto l004040C7;
}

char g_str404130[] = "j\x02\xE8\xC9\xD0\xFF\xFF\x83\xC4\x04\xC3\x90\x90\x90\x90\x90\x8BD$\x04\x8B\r\xE0\x8C@"; // 00404130
// 00404140: void fn00404140(Stack Eq_113 dwArg04, Stack Eq_4369 dwArg08, Stack Eq_47 dwArg0C)
// Called from:
//      fn00403350
//      fn00403F10
void fn00404140(Eq_113 dwArg04, Eq_4369 dwArg08, Eq_47 dwArg0C)
{
	if (dwArg04 < g_t408CE0.u1)
	{
		struct Eq_5876 ** ebx_23 = (dwArg04 >> 0x05) * 0x04 + 0x00408BE0;
		if ((*((char *) *((char *) &g_t408BE0.u0 + (dwArg04 >> 0x05) * 0x04) + ((dwArg04 & 0x1F) * 0x08 + 4)) & 0x01) != 0x00)
		{
			Eq_2140 eax_46 = fn00404380(dwArg04);
			if (eax_46 != (void *) ~0x00)
			{
				Eq_47 eax_72;
				if (SetFilePointer(eax_46, dwArg08, null, dwArg0C) == ~0x00)
					eax_72 = GetLastError();
				else
					eax_72.u0 = 0x00;
				if (eax_72 == 0x00)
				{
					struct Eq_5876 * eax_84 = *ebx_23;
					eax_84->a0004[dwArg04 & 0x1F].b0000 &= ~0x02;
					return;
				}
				else
				{
					fn004043D0(eax_72);
					return;
				}
			}
			else
			{
				g_dw408914 = 0x09;
				return;
			}
		}
	}
	g_dw408914 = 0x09;
	g_t408918.u0 = 0x00;
}

// 00404200: void fn00404200(Stack (ptr32 Eq_433) dwArg04)
// Called from:
//      fn00403350
void fn00404200(struct Eq_433 * dwArg04)
{
	++g_dw408910;
	word32 ecx_68;
	Eq_95 eax_11 = fn00402FB0(0x1000, out ecx_68);
	dwArg04->t0008.u0 = (word32 *) eax_11;
	ui32 eax_25 = dwArg04->dw000C;
	byte al_27 = (byte) eax_25;
	word24 eax_24_8_33 = SLICE(eax_25, word24, 8);
	if (eax_11 == 0x00)
	{
		dwArg04->dw0018 = 0x02;
		dwArg04->dw000C = SEQ(eax_24_8_33, al_27 | 0x04);
		dwArg04->t0008.u0 = (word32 *) ((char *) &dwArg04->t0010 + 4);
		dwArg04->t0000.u0 = (word32 *) ((char *) &dwArg04->t0010 + 4);
		dwArg04->dw0004 = 0x00;
	}
	else
	{
		Eq_95 edx_41 = dwArg04->t0008.u0;
		dwArg04->dw000C = SEQ(eax_24_8_33, al_27 | 0x08);
		dwArg04->dw0018 = 0x1000;
		dwArg04->t0000.u0 = (word32 *) edx_41;
		dwArg04->dw0004 = 0x00;
	}
}

// 00404380: Register word32 fn00404380(Stack Eq_113 dwArg04)
// Called from:
//      fn00404140
word32 fn00404380(Eq_113 dwArg04)
{
	if (dwArg04 < g_t408CE0.u1)
	{
		struct Eq_5971 * edx_12 = *((char *) &g_t408BE0.u0 + (dwArg04 >> 0x05) * 0x04);
		word32 * eax_17 = edx_12 + (dwArg04 & 0x1F) * 2;
		if ((edx_12->a0004[dwArg04 & 0x1F].b0000 & 0x01) != 0x00)
			return *eax_17;
	}
	g_dw408914 = 0x09;
	g_t408918.u0 = 0x00;
	return ~0x00;
}

// 004043D0: void fn004043D0(Stack Eq_47 dwArg04)
// Called from:
//      fn00403F10
//      fn00404140
void fn004043D0(Eq_47 dwArg04)
{
	g_t408918.u0 = (DWORD) dwArg04;
	ui32 ecx_17 = 0x00;
	struct Eq_6000 * eax_11 = g_a408790;
	do
	{
		if (dwArg04 == eax_11->dw0000)
		{
			g_dw408914 = (&g_a408790->dw0004)[ecx_17 * 0x08];
			return;
		}
		++eax_11;
		++ecx_17;
	} while (eax_11 < &g_t4088F8);
	if (dwArg04 < 0x13 || dwArg04 > 0x24)
	{
		if (dwArg04 >= 188)
		{
			g_dw408914 = 0x08;
			if (dwArg04 <= 202)
				return;
		}
		g_dw408914 = 22;
	}
	else
		g_dw408914 = 0x0D;
}

