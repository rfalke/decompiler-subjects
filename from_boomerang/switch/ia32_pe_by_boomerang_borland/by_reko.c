// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw40A10F = 0x00; // 0040A10F
Eq_34 g_t40A128 = // 0040A128
	{
		0x54,
		0x77,
	};
Eq_34 g_t40A12E = // 0040A12E
	{
		0x54,
		0x68,
	};
Eq_34 g_t40A136 = // 0040A136
	{
		0x46,
		111,
	};
Eq_34 g_t40A13D = // 0040A13D
	{
		0x46,
		0x69,
	};
Eq_34 g_t40A144 = // 0040A144
	{
		0x53,
		0x69,
	};
Eq_34 g_t40A14A = // 0040A14A
	{
		0x53,
		101,
	};
Eq_34 g_t40A152 = // 0040A152
	{
		0x4F,
		116,
	};
word32 g_dw40A5CC = 0x00; // 0040A5CC
byte g_a40B1FA[] = // 0040B1FA
	{
	};
Eq_1026 g_t40B570 = // 0040B570
	{
		0x00,
		0x01,
	};
struct Eq_1026 * g_ptr40B59C = &g_t40B570; // 0040B59C
<anonymous> * g_ptr40B780 = &g_t404FE0; // 0040B780
<anonymous> * g_ptr40B784 = &g_t404FE0; // 0040B784
byte g_a40CA55[] = // 0040CA55
	{
	};
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40F03C = 61884; // 0040F03C
word32 g_dw40F040 = 61898; // 0040F040
word32 g_dw40F044 = 61912; // 0040F044
word32 g_dw40F048 = 61926; // 0040F048
word32 g_dw40F04C = 0xF1F0; // 0040F04C
word32 g_dw40F050 = 0xF1FC; // 0040F050
word32 g_dw40F054 = 61966; // 0040F054
word32 g_dw40F058 = 0xF224; // 0040F058
word32 g_dw40F05C = 62012; // 0040F05C
word32 g_dw40F060 = 62026; // 0040F060
word32 g_dw40F064 = 62042; // 0040F064
word32 g_dw40F068 = 0xF26A; // 0040F068
word32 g_dw40F06C = 0xF280; // 0040F06C
word32 g_dw40F070 = 62100; // 0040F070
word32 g_dw40F074 = 62112; // 0040F074
word32 g_dw40F078 = 0xF2B2; // 0040F078
word32 g_dw40F07C = 0xF2C4; // 0040F07C
word32 g_dw40F080 = 62166; // 0040F080
word32 g_dw40F084 = 62182; // 0040F084
word32 g_dw40F088 = 62200; // 0040F088
word32 g_dw40F08C = 0xF306; // 0040F08C
word32 g_dw40F090 = 62230; // 0040F090
word32 g_dw40F094 = 62252; // 0040F094
word32 g_dw40F098 = 62264; // 0040F098
word32 g_dw40F09C = 62276; // 0040F09C
word32 g_dw40F0A0 = 62292; // 0040F0A0
word32 g_dw40F0A4 = 0xF36A; // 0040F0A4
word32 g_dw40F0A8 = 62332; // 0040F0A8
word32 g_dw40F0AC = 0xF388; // 0040F0AC
word32 g_dw40F0B0 = 0xF3A0; // 0040F0B0
word32 g_dw40F0B4 = 62386; // 0040F0B4
word32 g_dw40F0B8 = 62404; // 0040F0B8
word32 g_dw40F0BC = 0xF3D0; // 0040F0BC
word32 g_dw40F0C0 = 62426; // 0040F0C0
word32 g_dw40F0C4 = 62440; // 0040F0C4
word32 g_dw40F0C8 = 0xF3F6; // 0040F0C8
word32 g_dw40F0CC = 62482; // 0040F0CC
word32 g_dw40F0D0 = 0xF422; // 0040F0D0
word32 g_dw40F0D4 = 0xF430; // 0040F0D4
word32 g_dw40F0D8 = 0xF446; // 0040F0D8
<anonymous> * __imp__CloseHandle = &g_tF1BC; // 0040F0E0
<anonymous> * __imp__CreateFileA = &g_tF1CA; // 0040F0E4
<anonymous> * __imp__ExitProcess = &g_tF1D8; // 0040F0E8
<anonymous> * __imp__GetACP = &g_tF1E6; // 0040F0EC
<anonymous> * __imp__GetCPInfo = &g_tF1F0; // 0040F0F0
<anonymous> * __imp__GetCommandLineA = &g_tF1FC; // 0040F0F4
<anonymous> * __imp__GetCurrentThreadId = &g_tF20E; // 0040F0F8
<anonymous> * __imp__GetEnvironmentStrings = &g_tF224; // 0040F0FC
<anonymous> * __imp__GetFileType = &g_tF23C; // 0040F100
<anonymous> * __imp__GetLastError = &g_tF24A; // 0040F104
<anonymous> * __imp__GetLocalTime = &g_tF25A; // 0040F108
<anonymous> * __imp__GetModuleFileNameA = &g_tF26A; // 0040F10C
<anonymous> * __imp__GetModuleHandleA = &g_tF280; // 0040F110
<anonymous> * __imp__GetOEMCP = &g_tF294; // 0040F114
<anonymous> * __imp__GetProcAddress = &g_tF2A0; // 0040F118
<anonymous> * __imp__GetProcessHeap = &g_tF2B2; // 0040F11C
<anonymous> * __imp__GetStartupInfoA = &g_tF2C4; // 0040F120
<anonymous> * __imp__GetStdHandle = &g_tF2D6; // 0040F124
<anonymous> * __imp__GetStringTypeW = &g_tF2E6; // 0040F128
<anonymous> * __imp__GetVersion = &g_tF2F8; // 0040F12C
<anonymous> * __imp__GetVersionExA = &g_tF306; // 0040F130
<anonymous> * __imp__GlobalMemoryStatus = &g_tF316; // 0040F134
<anonymous> * __imp__HeapAlloc = &g_tF32C; // 0040F138
<anonymous> * __imp__HeapFree = &g_tF338; // 0040F13C
<anonymous> * __imp__LoadLibraryA = &g_tF344; // 0040F140
<anonymous> * __imp__MultiByteToWideChar = &g_tF354; // 0040F144
<anonymous> * __imp__RaiseException = &g_tF36A; // 0040F148
<anonymous> * __imp__RtlUnwind = &g_tF37C; // 0040F14C
<anonymous> * __imp__SetConsoleCtrlHandler = &g_tF388; // 0040F150
<anonymous> * __imp__SetFilePointer = &g_tF3A0; // 0040F154
<anonymous> * __imp__SetHandleCount = &g_tF3B2; // 0040F158
<anonymous> * __imp__TlsAlloc = &g_tF3C4; // 0040F15C
<anonymous> * __imp__TlsFree = &g_tF3D0; // 0040F160
<anonymous> * __imp__TlsGetValue = &g_tF3DA; // 0040F164
<anonymous> * __imp__TlsSetValue = &g_tF3E8; // 0040F168
<anonymous> * __imp__UnhandledExceptionFilter = &g_tF3F6; // 0040F16C
<anonymous> * __imp__VirtualAlloc = &g_tF412; // 0040F170
<anonymous> * __imp__VirtualFree = &g_tF422; // 0040F174
<anonymous> * __imp__WideCharToMultiByte = &g_tF430; // 0040F178
<anonymous> * __imp__WriteFile = &g_tF446; // 0040F17C
word32 g_dw40F184 = 62546; // 0040F184
word32 g_dw40F188 = 62566; // 0040F188
word32 g_dw40F18C = 0xF474; // 0040F18C
<anonymous> * __imp__EnumThreadWindows = &g_tF452; // 0040F194
<anonymous> * __imp__MessageBoxA = &g_tF466; // 0040F198
<anonymous> * __imp__wsprintfA = &g_tF474; // 0040F19C
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401059: void _GetExceptDLLinfo(Stack (ptr32 Eq_2) dwArg04)
void _GetExceptDLLinfo(struct Eq_2 * dwArg04)
{
	g_dw40A5CC = fn00401140() + 0x1C;
	dwArg04->dw0000 = 0x82727349;
	dwArg04->ptr0004 = 0x0040A5B8;
}

// 00401140: Register word32 fn00401140()
// Called from:
//      _GetExceptDLLinfo
word32 fn00401140()
{
	return fs->ptr002C[g_dw40A10F];
}

// 00401150: Register int32 main(Stack Eq_28 argc, Stack (ptr32 (ptr32 char)) argv)
int32 main(Eq_28 argc, char ** argv)
{
	if (argc <= 0x07)
	{
		switch (argc)
		{
		case 0x00:
		case 0x01:
			goto l004011D0;
		case 0x02:
			fn004038E4(&g_t40A128);
			break;
		case 0x03:
			fn004038E4(&g_t40A12E);
			break;
		case 0x04:
			fn004038E4(&g_t40A136);
			break;
		case 0x05:
			fn004038E4(&g_t40A13D);
			break;
		case 0x06:
			fn004038E4(&g_t40A144);
			break;
		case 0x07:
			fn004038E4(&g_t40A14A);
			break;
		}
	}
	else
	{
l004011D0:
		fn004038E4(&g_t40A152);
	}
	return 0x00;
}

// 00402250: Register int32 fn00402250(Stack Eq_57 dwArg04)
// Called from:
//      fn00403AD0
int32 fn00402250(Eq_57 dwArg04)
{
	Eq_57 eax_10 = dwArg04;
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		eax_10 = (word32) dwArg04 + 4;
		if (*dwArg04 == 0x00)
			goto l0040229F;
		if (*((word32) dwArg04 + 1) == 0x00)
		{
l004022A0:
			--eax_10;
			goto l004022A1;
		}
		if (*((word32) dwArg04 + 2) == 0x00)
		{
l004022A1:
			--eax_10;
			return eax_10 - (struct Eq_107 *) 0x01 - dwArg04;
		}
		eax_10 = SEQ(SLICE(dwArg04 + 0x03, word24, 8), SLICE(dwArg04 + 0x03, byte, 0) & 252);
	}
	do
	{
		do
		{
			ui32 edx_27 = *eax_10;
			eax_10 = (word32) eax_10 + 4;
			ui32 edx_31 = edx_27 - 0x01010101 & 0x80808080;
		} while (edx_31 == 0x00);
		ui32 edx_36 = edx_31 & ~edx_27;
		byte dl_40 = (byte) edx_36;
		byte dh_47 = SLICE(edx_36, byte, 8);
	} while (edx_36 == 0x00);
	if (dl_40 == 0x00)
	{
		if (dh_47 == 0x00)
		{
			if ((edx_36 & 0x00FF0000) == 0x00)
				return eax_10 - (struct Eq_107 *) 0x01 - dwArg04;
			goto l004022A1;
		}
		goto l004022A0;
	}
l0040229F:
	--eax_10;
	goto l004022A0;
}

// 004038E4: void fn004038E4(Stack (ptr32 Eq_34) dwArg04)
// Called from:
//      main
void fn004038E4(struct Eq_34 * dwArg04)
{
	fn00403AD0(dwArg04, 0x00, fp + 0x08);
}

// 00403A20: void fn00403A20(Stack (ptr32 Eq_138) dwArg04)
// Called from:
//      fn00403A68
//      fn00403AD0
void fn00403A20(struct Eq_138 * dwArg04)
{
	word32 eax_12 = 0x01;
	if (dwArg04->dw0050 != 0x00)
	{
		up32 * edx_15 = dwArg04->ptr0064;
		if (edx_15 != null && *edx_15 <= dwArg04->dw005C)
			eax_12 = 0x00;
		word32 edx_30 = dwArg04->dw0058;
		int32 ecx_33 = dwArg04->dw0050;
		word32 eax_41;
		dwArg04->ptr0054();
		if (eax_41 == 0x00)
			dwArg04->dw0060 = 0x01;
		dwArg04->dw0050 = 0x00;
	}
}

// 00403A68: void fn00403A68(Stack byte bArg04, Stack (ptr32 Eq_138) dwArg08)
// Called from:
//      fn00403AD0
void fn00403A68(byte bArg04, struct Eq_138 * dwArg08)
{
	if (dwArg08->dw0050 >= 0x50)
		fn00403A20(dwArg08);
	up32 * eax_27 = dwArg08->ptr0064;
	if (eax_27 == null || *eax_27 > dwArg08->dw005C)
	{
		dwArg08[dwArg08->dw0050 / 0x0068] = (struct Eq_138) bArg04;
		++dwArg08->dw0050;
	}
	++dwArg08->dw005C;
}

// 00403A9C: void fn00403A9C(Stack Eq_57 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      fn00403AD0
void fn00403A9C(Eq_57 dwArg04, ptr32 dwArg08)
{
	int32 ecx_11;
	Eq_57 esi_13 = dwArg04;
	byte * eax_14 = dwArg08 + 0x07;
	for (ecx_11 = 0x07; ecx_11 >= 0x00; --ecx_11)
	{
		int32 edx_18 = esi_13 & 0x0F;
		byte dl_21 = (byte) edx_18;
		if (edx_18 < 0x0A)
			*eax_14 = dl_21 + 0x30;
		else
			*eax_14 = dl_21 + 55;
		esi_13 >>= 0x04;
		--eax_14;
	}
}

// 00403AD0: void fn00403AD0(Stack (ptr32 Eq_34) dwArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_132) dwArg18)
// Called from:
//      fn004038E4
void fn00403AD0(struct Eq_34 * dwArg0C, word32 dwArg10, struct Eq_132 * dwArg18)
{
	word24 ebx_24_8_1200 = SLICE(ebx, word24, 8);
	struct Eq_34 * esi_107 = dwArg0C;
	while (true)
	{
l00403B18:
		byte bl_1182 = esi_107->b0000;
		++esi_107;
		if (bl_1182 == 0x00)
			break;
		if (bl_1182 == 0x25)
		{
			bl_1182 = esi_107->b0000;
			if (bl_1182 != 0x25)
			{
				int32 eax_1024 = 0x00;
				byte * dwLoc18_1334 = esi_107 - 0x01;
				int32 dwLoc14_1335 = 0x00;
				ci8 bLoc0D_1336 = 0x00;
				Eq_57 dwLoc0C_1337 = ~0x00;
				Eq_57 dwLoc08_1338 = ~0x00;
				ui32 edi_1030 = 0x20;
				word32 dwLoc20_1339 = 0x00;
				while (true)
				{
					ci8 bl_65 = esi_107->b0000;
					++esi_107;
					if (bl_65 < 0x20)
						break;
					word32 ebx_73 = SEQ(ebx_24_8_1200, bl_65);
					if ((int32) bl_65 > 0x7F)
						break;
					uint32 ecx_84 = (uint32) g_a40B1FA[(uint32) (bl_65 + 0xE0)];
					if (ecx_84 <= 0x1A)
					{
						Eq_57 dwLoc1C_1347;
						Eq_57 dwLoc44_1360;
						int32 dwLoc3C_1399;
						byte cl_374;
						switch (ecx_84)
						{
						case 0x00:
							if (eax_1024 > 0x00)
								goto l004043D8;
							if (bLoc0D_1336 != 0x2B)
								bLoc0D_1336 = bl_65;
							break;
						case 0x01:
							if (eax_1024 > 0x00)
								goto l004043D8;
							edi_1030 |= 0x01;
							break;
						case 0x02:
							struct Eq_132 * v63_1087 = (char *) &dwArg18->tFFFFFFFC + 8;
							dwArg18 = v63_1087;
							Eq_57 ecx_1091 = v63_1087->tFFFFFFFC;
							if (eax_1024 < 0x02)
							{
								if (ecx_1091 < 0x00)
								{
									dwLoc08_1338 = -ecx_1091;
									edi_1030 |= 0x02;
								}
								else
									dwLoc08_1338 = ecx_1091;
								eax_1024 = 0x03;
							}
							else
							{
								if (eax_1024 != 0x04)
									goto l004043D8;
								++eax_1024;
								dwLoc0C_1337 = ecx_1091;
							}
							break;
						case 0x03:
							if (eax_1024 > 0x00)
								goto l004043D8;
							edi_1030 |= 0x02;
							break;
						case 0x04:
							if (eax_1024 >= 0x04)
								goto l004043D8;
							eax_1024 = 0x04;
							dwLoc0C_1337 = (word32) dwLoc0C_1337 + 1;
							break;
						case 0x05:
							goto l00403CFD;
						case 0x06:
							edi_1030 |= 0x10;
							eax_1024 = 0x05;
							break;
						case 0x07:
							eax_1024 = 0x05;
							edi_1030 = (edi_1030 | 0x0100) & ~0x10;
							break;
						case 0x08:
							eax_1024 = 0x05;
							edi_1030 = (edi_1030 | 0x0200) & ~0x10;
							break;
						case 0x09:
							if (eax_1024 <= 0x00)
							{
								if ((edi_1030 & 0x02) == 0x00)
								{
									edi_1030 |= 0x08;
									eax_1024 = 0x01;
								}
							}
							else
							{
l00403CFD:
								if (eax_1024 <= 0x02)
								{
									eax_1024 = 0x02;
									if (dwLoc08_1338 == ~0x00)
										dwLoc08_1338 = (int32) (bl_65 + 0xD0);
									else
										dwLoc08_1338 = dwLoc08_1338 * 0x02 + dwLoc08_1338 * 0x08 + (int32) (bl_65 + 0xD0);
								}
								else
								{
									if (eax_1024 != 0x04)
										goto l004043D8;
									dwLoc0C_1337 = dwLoc0C_1337 * 0x02 + dwLoc0C_1337 * 0x08 + (int32) (bl_65 + 0xD0);
								}
							}
							break;
						case 0x0A:
							dwLoc3C_1399 = 0x0A;
							cl_374 = 0x01;
							goto l00403E34;
						case 11:
							dwLoc3C_1399 = 0x08;
							goto l00403E23;
						case 0x0C:
							dwLoc3C_1399 = 0x0A;
							goto l00403E23;
						case 0x0D:
							dwLoc3C_1399 = 0x10;
							bLoc21 = (byte) (ebx_73 - 0x17);
l00403E23:
							bLoc0D_1336 = 0x00;
							cl_374 = 0x00;
l00403E34:
							Eq_875 qwLoc2C_2230;
							uint32 ecx_490 = (uint32) cl_374;
							if ((edi_1030 & 0x0100) != 0x00)
							{
								struct Eq_132 * v52_450 = &dwArg18->b0005 + 3;
								dwArg18 = v52_450;
								qwLoc2C_2230 = v52_450->tFFFFFFF8;
							}
							else if ((edi_1030 & 0x10) != 0x00)
							{
								struct Eq_132 * v53_430 = (char *) &dwArg18->tFFFFFFFC + 8;
								dwArg18 = v53_430;
								Eq_57 edx_435 = v53_430->tFFFFFFFC;
								ecx_490 = (uint32) cl_374;
								if (cl_374 != 0x00)
									qwLoc2C_2230.u0 = (int64) edx_435;
								else
									qwLoc2C_2230.u1 = (uint64) edx_435;
							}
							else if ((edi_1030 & 0x0200) != 0x00)
							{
								struct Eq_132 * v59_410 = (char *) &dwArg18->tFFFFFFFC + 8;
								dwArg18 = v59_410;
								Eq_57 dx_415 = v59_410->tFFFFFFFC;
								ecx_490 = (uint32) cl_374;
								if (cl_374 != 0x00)
									qwLoc2C_2230.u0 = (int64) (int32) dx_415;
								else
									qwLoc2C_2230.u1 = (uint64) (word32) dx_415;
							}
							else
							{
								struct Eq_132 * v62_388 = (char *) &dwArg18->tFFFFFFFC + 8;
								dwArg18 = v62_388;
								Eq_57 edx_395 = v62_388->tFFFFFFFC;
								ecx_490 = (uint32) cl_374;
								if (cl_374 != 0x00)
									qwLoc2C_2230.u0 = (int64) edx_395;
								else
									qwLoc2C_2230.u1 = (uint64) edx_395;
							}
							word32 dwLoc2C_1430 = (word32) qwLoc2C_2230;
							dwLoc1C_1347 = fp - 0xBB;
							if (SLICE(qwLoc2C_2230, word32, 32) == 0x00 && dwLoc2C_1430 == 0x00)
							{
								if (dwLoc0C_1337 != 0x00)
									goto l00403F0A;
								bLocBB = 0x00;
							}
							else
							{
								edi_1030 |= 0x04;
l00403F0A:
								fn00405090(qwLoc2C_2230, fp - 0xBB, dwLoc3C_1399, (byte) ecx_490, bLoc21);
							}
							if (dwLoc0C_1337 < 0x00)
								goto l00404148;
							Eq_57 eax_614 = fn00402250(fp - 0xBB);
							Eq_57 dwLoc40_1518 = eax_614;
							dwLoc44_1360 = eax_614;
							if (bLocBB == 0x2D)
								dwLoc40_1518 = eax_614 - 0x01;
							else if (bLoc0D_1336 != 0x00)
							{
								dwLoc44_1360 = (word32) eax_614 + 1;
								dwLoc1C_1347 = fp - 188;
							}
							if (dwLoc0C_1337 > dwLoc40_1518)
								dwLoc14_1335 = dwLoc0C_1337 - dwLoc40_1518;
							goto l004041B6;
						case 0x0E:
							struct Eq_132 * v25_336 = (char *) &dwArg18->tFFFFFFFC + 8;
							fn00403A9C(v25_336->tFFFFFFFC, fp - 188);
							dwArg18 = v25_336;
							edi_1030 &= ~0x04;
							dwLoc1C_1347 = fp - 188;
							goto l00404148;
						case 0x0F:
							dwLoc1C_1347 = fp - 0xBB;
							fn00404FC8();
							fn00404FCE();
l00404148:
							if ((edi_1030 & 0x08) != 0x00 && dwLoc08_1338 > 0x00)
							{
								Eq_57 eax_541 = fn00402250(dwLoc1C_1347);
								Eq_57 dwLoc44_1477 = eax_541;
								if (*dwLoc1C_1347.u0 == 0x2D)
									dwLoc44_1477 = eax_541 - 0x01;
								if (dwLoc08_1338 > dwLoc44_1477)
									dwLoc14_1335 = dwLoc08_1338 - dwLoc44_1477;
							}
							if (*dwLoc1C_1347.u0 == 0x2D || bLoc0D_1336 != 0x00)
							{
								if (*dwLoc1C_1347.u0 != 0x2D)
								{
									Eq_57 v30_578 = dwLoc1C_1347 - 0x01;
									*v30_578 = bLoc0D_1336;
									dwLoc1C_1347 = v30_578;
								}
								if (dwLoc14_1335 > 0x00)
									--dwLoc14_1335;
							}
							dwLoc44_1360 = fn00402250(dwLoc1C_1347);
							goto l004041B6;
						case 0x10:
							goto l00403FBD;
						case 0x11:
							goto l00404038;
						case 0x12:
							if ((edi_1030 & 0x0210) == 0x00)
								edi_1030 |= 0x10;
l00403FBD:
							if ((edi_1030 & 0x10) != 0x00)
							{
								struct Eq_132 * v24_273 = (char *) &dwArg18->tFFFFFFFC + 8;
								dwArg18 = v24_273;
								bLocBB = v24_273->b0005;
								dwLoc20_1339 = 0x01;
								dwLoc1C_1347 = fp - 188;
								dwLoc44_1360.u0 = 0x01;
							}
							else
							{
								dwArg18 = (struct Eq_132 *) ((char *) &dwArg18->tFFFFFFFC + 8);
								bLocBB = 0x00;
								dwLoc1C_1347 = fp - 188;
								dwLoc20_1339 = 0x00;
								dwLoc44_1360.u0 = 0x01;
							}
							goto l004041B6;
						case 0x13:
							if ((edi_1030 & 0x0210) == 0x00)
								edi_1030 |= 0x10;
l00404038:
							if ((edi_1030 & 0x10) != 0x00)
							{
								struct Eq_132 * v23_191 = (char *) &dwArg18->tFFFFFFFC + 8;
								Eq_57 edx_194 = v23_191->tFFFFFFFC;
								dwArg18 = v23_191;
								dwLoc1C_1347 = edx_194;
								dwLoc20_1339 = 0x01;
								if (edx_194 == 0x00)
									dwLoc1C_1347.u0 = 0x0040B1EC;
							}
							else
							{
								struct Eq_132 * v51_181 = (char *) &dwArg18->tFFFFFFFC + 8;
								Eq_57 eax_185 = v51_181->tFFFFFFFC;
								dwArg18 = v51_181;
								dwLoc1C_1347 = eax_185;
								dwLoc20_1339 = 0x00;
								if (eax_185 == 0x00)
									dwLoc1C_1347.u0 = 4239844;
							}
							if (dwLoc20_1339 != 0x00)
							{
								Eq_57 eax_1287;
								if (dwLoc0C_1337 >= 0x00)
									eax_1287 = dwLoc0C_1337;
								else
									eax_1287.u0 = 0x7FFFFFFF;
								Eq_57 edx_235 = dwLoc1C_1347;
								dwLoc44_1360.u0 = 0x00;
								while (eax_1287 != 0x00 && *edx_235 != 0x00)
								{
									--eax_1287;
									dwLoc44_1360.u0 = (word16) dwLoc44_1360.u0 + 1;
									edx_235 = (word32) edx_235 + 2;
								}
							}
							else
							{
								Eq_57 eax_1286;
								if (dwLoc0C_1337 >= 0x00)
									eax_1286 = dwLoc0C_1337;
								else
									eax_1286.u0 = 0x7FFFFFFF;
								Eq_57 edx_210 = dwLoc1C_1347;
								dwLoc44_1360.u0 = 0x00;
								while (eax_1286 != 0x00 && *edx_210 != 0x00)
								{
									--eax_1286;
									dwLoc44_1360.u0 = (word16) dwLoc44_1360.u0 + 1;
									edx_210 = (word32) edx_210 + 1;
								}
							}
l004041B6:
							word32 ebx_782 = SEQ(ebx_24_8_1200, bl_65);
							if ((edi_1030 & 0x01) != 0x00)
							{
								ebx_782 = SEQ(ebx_24_8_1200, bl_65);
								if (bl_65 == 111)
								{
									if (dwLoc14_1335 <= 0x00)
										dwLoc14_1335 = 0x01;
									goto l004041EE;
								}
								ebx_782 = SEQ(ebx_24_8_1200, bl_65);
								if (bl_65 != 0x78)
								{
									ebx_782 = SEQ(ebx_24_8_1200, bl_65);
									if (bl_65 == 88)
										goto l004041DC;
								}
								else
								{
l004041DC:
									int32 v28_702 = dwLoc14_1335 - 0x02;
									edi_1030 |= 0x40;
									dwLoc08_1338 -= 0x02;
									dwLoc14_1335 = v28_702;
									if (v28_702 < 0x00)
										dwLoc14_1335 = 0x00;
								}
							}
l004041EE:
							Eq_57 v33_716 = (word16) dwLoc44_1360.u0 + dwLoc14_1335;
							ebx_24_8_1200 = SLICE(ebx_782, word24, 8);
							Eq_57 dwLoc44_1560 = v33_716;
							if ((edi_1030 & 0x02) == 0x00 && dwLoc08_1338 > v33_716)
							{
								do
								{
									fn00403A68(0x20, fp - 1316);
									Eq_57 v34_740 = dwLoc08_1338 - 0x01;
									dwLoc08_1338 = v34_740;
								} while (v34_740 > v33_716);
							}
							if ((edi_1030 & 0x40) != 0x00)
							{
								fn00403A68(0x30, fp - 1316);
								fn00403A68((byte) ebx_782, fp - 1316);
							}
							if (dwLoc14_1335 > 0x00)
							{
								Eq_57 v35_828 = v33_716 - dwLoc14_1335;
								Eq_57 v36_831 = dwLoc08_1338 - dwLoc14_1335;
								dwLoc44_1560 = v35_828;
								dwLoc08_1338 = v36_831;
								if (*dwLoc1C_1347.u0 == 0x2D || (*dwLoc1C_1347.u0 == 0x20 || *dwLoc1C_1347.u0 == 0x2B))
								{
									fn00403A68(*dwLoc1C_1347.u0, fp - 1316);
									dwLoc1C_1347.u0 = (word16) dwLoc1C_1347.u0 + 1;
									dwLoc44_1560 = v35_828 - 0x01;
									dwLoc08_1338 = v36_831 - 0x01;
								}
								while (true)
								{
									dwLoc14_1335 += ~0x00;
									if (dwLoc14_1335 == 0x00)
										break;
									fn00403A68(0x30, fp - 1316);
								}
							}
							if (dwLoc20_1339 != 0x00)
							{
								Eq_57 dwLoc48_1637 = dwLoc1C_1347;
								Eq_57 dwLoc50_1638 = 0x00;
								Eq_57 dwLoc58_1641 = dwLoc44_1560;
								while (true)
								{
									dwLoc58_1641 = (word32) dwLoc58_1641 - 1;
									if (dwLoc58_1641 <= 0x00)
										break;
									dwLoc48_1637 = (word32) dwLoc48_1637 + 2;
									int32 eax_928 = fn0040487C(fp - 0x5A, *dwLoc48_1637);
									if (eax_928 <= 0x00)
										break;
									int32 ecx_939 = 0x00;
									byte * edx_941 = (word32) dwLoc50_1638 + (fp - 1212);
									byte * eax_942 = fp - 0x5A;
									if (eax_928 > 0x00)
									{
										do
										{
											*edx_941 = *eax_942;
											++eax_942;
											++edx_941;
											dwLoc50_1638 = (word32) dwLoc50_1638 + 1;
											++ecx_939;
										} while (ecx_939 < eax_928);
									}
								}
								dwLoc1C_1347 = fp - 1212;
								dwLoc44_1560 = dwLoc50_1638;
							}
							if (dwLoc44_1560 != 0x00)
							{
								dwLoc08_1338 -= dwLoc44_1560;
								while (true)
								{
									dwLoc44_1560 = (word32) dwLoc44_1560 - 1;
									if (dwLoc44_1560 == 0x00)
										break;
									fn00403A68(*dwLoc1C_1347.u0, fp - 1316);
									dwLoc1C_1347.u0 = (word16) dwLoc1C_1347.u0 + 1;
								}
							}
							while (true)
							{
								dwLoc08_1338 = (word32) dwLoc08_1338 - 1;
								if (dwLoc08_1338 <= 0x00)
									break;
								fn00403A68(0x20, fp - 1316);
							}
							goto l00403B18;
						case 0x14:
							struct Eq_132 * v21_143 = (char *) &dwArg18->tFFFFFFFC + 8;
							dwArg18 = v21_143;
							Eq_57 ecx_148 = v21_143->tFFFFFFFC;
							if ((edi_1030 & 0x10) != 0x00)
								*ecx_148 = 0x00;
							else if ((edi_1030 & 0x0200) != 0x00)
								ecx_148->u0 = 0x00;
							else
								*ecx_148 = 0x00;
							goto l00403B18;
						case 0x15:
						case 22:
						case 0x17:
							goto l004043D8;
						case 0x18:
							edi_1030 &= ~0x20;
							eax_1024 = 0x05;
							break;
						case 0x19:
							edi_1030 |= 0x20;
							eax_1024 = 0x05;
							break;
						case 0x1A:
							if (esi_107->b0000 == 0x36 && esi_107[1] == 0x34)
							{
								esi_107 += 2;
								edi_1030 = (edi_1030 | 0x0100) & ~0x0210;
								eax_1024 = 0x05;
							}
							else if (esi_107->b0000 == 0x33 && esi_107[1] == 0x32)
							{
								esi_107 += 2;
								edi_1030 = (edi_1030 | 0x10) & ~0x0300;
								eax_1024 = 0x05;
							}
							else if (esi_107->b0000 == 0x31 && esi_107[1] == 0x36)
							{
								esi_107 += 2;
								edi_1030 = (edi_1030 | 0x0200) & ~0x0110;
								eax_1024 = 0x05;
							}
							else if (esi_107->b0000 == 0x38)
							{
								++esi_107;
								edi_1030 &= ~0x0310;
								eax_1024 = 0x05;
							}
							break;
						}
					}
				}
l004043D8:
				while (true)
				{
					++dwLoc18_1334;
					byte al_1123 = *dwLoc18_1334;
					if (al_1123 == 0x00)
						break;
					fn00403A68(al_1123, fp - 1316);
				}
				break;
			}
			++esi_107;
		}
		word32 ebx_1201 = SEQ(ebx_24_8_1200, bl_1182);
		if ((g_a40CA55[(uint32) bl_1182] & 0x04) != 0x00 && esi_107->b0000 != 0x00)
		{
			fn00403A68(bl_1182, fp - 1316);
			++esi_107;
			ebx_1201 = SEQ(ebx_24_8_1200, esi_107->b0000);
		}
		fn00403A68((byte) ebx_1201, fp - 1316);
		ebx_24_8_1200 = SLICE(ebx_1201, word24, 8);
	}
	fn00403A20(fp - 1316);
}

// 0040487C: Register int32 fn0040487C(Stack Eq_813 dwArg04, Stack Eq_814 wArg08)
// Called from:
//      fn00403AD0
int32 fn0040487C(Eq_813 dwArg04, Eq_814 wArg08)
{
	Eq_1021 bArg08_99 = (byte) wArg08;
	if (dwArg04 == 0x00)
		return 0x00;
	if (g_ptr40B59C->dw0008 == 0x00)
	{
		int32 eax_40 = WideCharToMultiByte(g_ptr40B59C->t0000, 0x0220, fp + 0x08, 0x01, dwArg04, 0x02, null, fp - 0x08);
		return eax_40;
	}
	else
	{
		if (wArg08 > 0xFF)
			return ~0x00;
		*dwArg04 = bArg08_99;
		return 0x01;
	}
}

// 00404C97: Register uint32 fn00404C97(Sequence Eq_875 edx_eax, Stack int64 qwArg04, Register out ptr32 edxOut)
// Called from:
//      fn00405090
uint32 fn00404C97(Eq_875 edx_eax, int64 qwArg04, ptr32 & edxOut)
{
	word32 edx = SLICE(edx_eax, word32, 32);
	uint32 dwArg04 = (word32) qwArg04;
	uint32 dwArg08 = SLICE(qwArg04, word32, 32);
	uint32 eax_108;
	ptr32 edx_159;
	if (dwArg08 == 0x00 && (edx == 0x00 || dwArg04 == 0x00))
	{
		eax_108 = (uint32) (edx_eax /u dwArg04);
		edx_159 = 0x00;
	}
	else
	{
		word32 ecx_44;
		uint32 edi_113 = 0x00;
		uint32 esi_112 = 0x00;
		Eq_875 edx_eax_186 = edx_eax;
		for (ecx_44 = 0x40; ecx_44 != 0x00; --ecx_44)
		{
			ui64 v25_122 = edx_eax_186 << 0x01;
			esi_112 = __rcl(esi_112, 0x01, (SLICE(edx_eax_186, word32, 32) & 0x80000000) != 0x00);
			eax_108 = (word32) v25_122;
			edx_159 = SLICE(v25_122, word32, 32);
			edi_113 = __rcl(edi_113, 0x01, (esi_112 & 0x80000000) != 0x00);
			if (edi_113 >= dwArg08 && (edi_113 > dwArg08 || esi_112 >= dwArg04))
			{
				ui64 edi_esi_119 = SEQ(edi_113, esi_112) - qwArg04;
				esi_112 = (word32) edi_esi_119;
				edi_113 = SLICE(edi_esi_119, word32, 32);
				++eax_108;
			}
			edx_eax_186 = SEQ(edx_159, eax_108);
		}
	}
	edxOut = edx_159;
	return eax_108;
}

// 00404D5A: Register byte fn00404D5A(Sequence Eq_875 edx_eax, Stack int64 qwArg04)
// Called from:
//      fn00405090
byte fn00404D5A(Eq_875 edx_eax, int64 qwArg04)
{
	word32 edx = SLICE(edx_eax, word32, 32);
	uint32 dwArg04 = (word32) qwArg04;
	uint32 dwArg08 = SLICE(qwArg04, word32, 32);
	uint32 eax_161;
	if (dwArg08 == 0x00 && (edx == 0x00 || dwArg04 == 0x00))
		eax_161 = (uint32) (edx_eax % dwArg04);
	else
	{
		word32 ecx_47;
		uint32 edi_48 = 0x00;
		uint32 esi_49 = 0x00;
		Eq_875 edx_eax_191 = edx_eax;
		for (ecx_47 = 0x40; ecx_47 != 0x00; --ecx_47)
		{
			ui64 v26_127 = edx_eax_191 << 0x01;
			esi_49 = __rcl(esi_49, 0x01, (SLICE(edx_eax_191, word32, 32) & 0x80000000) != 0x00);
			word32 eax_115 = (word32) v26_127;
			word32 edx_58 = SLICE(v26_127, word32, 32);
			edi_48 = __rcl(edi_48, 0x01, (esi_49 & 0x80000000) != 0x00);
			if (edi_48 >= dwArg08 && (edi_48 > dwArg08 || esi_49 >= dwArg04))
			{
				ui64 edi_esi_124 = SEQ(edi_48, esi_49) - qwArg04;
				esi_49 = (word32) edi_esi_124;
				edi_48 = SLICE(edi_esi_124, word32, 32);
				++eax_115;
			}
			edx_eax_191 = SEQ(edx_58, eax_115);
		}
		eax_161 = esi_49;
	}
	return (byte) eax_161;
}

// 00404FC8: void fn00404FC8()
// Called from:
//      fn00403AD0
void fn00404FC8()
{
	g_ptr40B780();
}

// 00404FCE: void fn00404FCE()
// Called from:
//      fn00403AD0
void fn00404FCE()
{
	g_ptr40B784();
}

<anonymous> g_t404FE0 = <code>; // 00404FE0
// 00405090: void fn00405090(Stack Eq_875 qwArg04, Stack (ptr32 byte) dwArg0C, Stack int32 dwArg10, Stack byte bArg14, Stack ci8 bArg18)
// Called from:
//      fn00403AD0
void fn00405090(Eq_875 qwArg04, byte * dwArg0C, int32 dwArg10, byte bArg14, ci8 bArg18)
{
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	up32 dwArg04 = (word32) qwArg04;
	byte * esi_113 = dwArg0C;
	if (dwArg10 < 0x02 || dwArg10 > 0x24)
	{
l00405134:
		*esi_113 = 0x00;
		return;
	}
	Eq_875 qwArg04_232;
	if (dwArg08 == 0x00)
	{
		qwArg04_232 = qwArg04;
		if (dwArg04 >= 0x00)
			goto l004050DE;
	}
	else
	{
		qwArg04_232 = qwArg04;
		if (dwArg08 >= 0x00)
			goto l004050DE;
	}
	qwArg04_232 = qwArg04;
	if (bArg14 != 0x00)
	{
		*dwArg0C = 0x2D;
		uint32 eax_38 = -dwArg04;
		esi_113 = dwArg0C + 1;
		qwArg04_232 = SEQ(-(dwArg08 + (eax_38 == 0x00)), eax_38);
	}
l004050DE:
	byte * ebx_102 = fp - 0x48;
	Eq_875 qwArg04_228 = qwArg04_232;
	do
	{
		do
		{
			*ebx_102 = (byte) (uint32) fn00404D5A(qwArg04_228, (int64) dwArg10);
			word32 edx_88;
			word32 eax_86 = fn00404C97(qwArg04_228, (int64) dwArg10, out edx_88);
			++ebx_102;
			word24 eax_24_8_117 = SLICE(eax_86, word24, 8);
			qwArg04_228 = SEQ(edx_88, eax_86);
		} while (edx_88 != 0x00);
		qwArg04_228 = SEQ(edx_88, eax_86);
	} while (eax_86 != 0x00);
	while (ebx_102 != fp - 0x48)
	{
		--ebx_102;
		ci8 al_107 = *ebx_102;
		word32 eax_118 = SEQ(eax_24_8_117, al_107);
		if (al_107 < 0x0A)
		{
			*esi_113 = (byte) (eax_118 + 0x30);
			eax_24_8_117 = SLICE(eax_118 + 0x30, word24, 8);
			++esi_113;
		}
		else
		{
			*esi_113 = al_107 + bArg18 + ~0x09;
			++esi_113;
		}
	}
	goto l00405134;
}

