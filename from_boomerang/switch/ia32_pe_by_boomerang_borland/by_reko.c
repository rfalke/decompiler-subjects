// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject_text.h"

// 00401059: void _GetExceptDLLinfo(Stack (ptr32 Eq_2) dwArg04)
void _GetExceptDLLinfo(struct Eq_2 * dwArg04)
{
	g_dw40A5CC = fn00401140() + 0x1C;
	dwArg04->dw0000 = 0x82727349;
	dwArg04->ptr0004 = 0x0040A5B8;
}

// 00401140: Register word32 fn00401140()
// Called from:
//      _GetExceptDLLinfo
word32 fn00401140()
{
	return fs->ptr002C[g_dw40A10F];
}

// 00401150: Register int32 main(Stack Eq_28 argc, Stack (ptr32 (ptr32 char)) argv)
int32 main(Eq_28 argc, char ** argv)
{
	if (argc > 0x07)
		goto l004011D0;
	switch (argc)
	{
	case 0x00:
	case 0x01:
l004011D0:
		fn004038E4(&g_t40A152);
		break;
	case 0x02:
		fn004038E4(&g_t40A128);
		break;
	case 0x03:
		fn004038E4(&g_t40A12E);
		break;
	case 0x04:
		fn004038E4(&g_t40A136);
		break;
	case 0x05:
		fn004038E4(&g_t40A13D);
		break;
	case 0x06:
		fn004038E4(&g_t40A144);
		break;
	case 0x07:
		fn004038E4(&g_t40A14A);
		break;
	}
	return 0x00;
}

// 00402250: Register int32 fn00402250(Stack Eq_57 dwArg04)
// Called from:
//      fn00403AD0
int32 fn00402250(Eq_57 dwArg04)
{
	Eq_57 eax_10 = dwArg04;
	if (((byte) dwArg04 & 0x03) != 0x00)
	{
		eax_10 = (word32) dwArg04 + 4;
		if (*dwArg04 == 0x00)
			goto l0040229F;
		if (*((word32) dwArg04 + 1) == 0x00)
		{
l004022A0:
			--eax_10;
			goto l004022A1;
		}
		if (*((word32) dwArg04 + 2) == 0x00)
		{
l004022A1:
			--eax_10;
			return eax_10 - (struct Eq_107 *) 0x01 - dwArg04;
		}
		eax_10 = SEQ(SLICE(dwArg04 + 0x03, word24, 8), SLICE(dwArg04 + 0x03, byte, 0) & 252);
	}
	do
	{
		do
		{
			ui32 edx_27 = *eax_10;
			eax_10 = (word32) eax_10 + 4;
			ui32 edx_31 = edx_27 - 0x01010101 & 0x80808080;
		} while (edx_31 == 0x00);
		ui32 edx_36 = edx_31 & ~edx_27;
		byte dl_40 = (byte) edx_36;
		byte dh_47 = SLICE(edx_36, byte, 8);
	} while (edx_36 == 0x00);
	if (dl_40 == 0x00)
	{
		if (dh_47 == 0x00)
		{
			if ((edx_36 & 0x00FF0000) == 0x00)
				return eax_10 - (struct Eq_107 *) 0x01 - dwArg04;
			goto l004022A1;
		}
		goto l004022A0;
	}
l0040229F:
	--eax_10;
	goto l004022A0;
}

// 004038E4: void fn004038E4(Stack (ptr32 Eq_34) dwArg04)
// Called from:
//      main
void fn004038E4(struct Eq_34 * dwArg04)
{
	fn00403AD0(dwArg04, 0x00, fp + 0x08);
}

// 00403A20: void fn00403A20(Stack (ptr32 Eq_138) dwArg04)
// Called from:
//      fn00403A68
//      fn00403AD0
void fn00403A20(struct Eq_138 * dwArg04)
{
	word32 eax_12 = 0x01;
	if (dwArg04->dw0050 != 0x00)
	{
		up32 * edx_15 = dwArg04->ptr0064;
		if (edx_15 != null && *edx_15 <= dwArg04->dw005C)
			eax_12 = 0x00;
		word32 edx_30 = dwArg04->dw0058;
		int32 ecx_33 = dwArg04->dw0050;
		word32 eax_41;
		dwArg04->ptr0054();
		if (eax_41 == 0x00)
			dwArg04->dw0060 = 0x01;
		dwArg04->dw0050 = 0x00;
	}
}

// 00403A68: void fn00403A68(Stack byte bArg04, Stack (ptr32 Eq_138) dwArg08)
// Called from:
//      fn00403AD0
void fn00403A68(byte bArg04, struct Eq_138 * dwArg08)
{
	if (dwArg08->dw0050 >= 0x50)
		fn00403A20(dwArg08);
	up32 * eax_27 = dwArg08->ptr0064;
	if (eax_27 == null || *eax_27 > dwArg08->dw005C)
	{
		dwArg08[dwArg08->dw0050 / 0x0068] = (struct Eq_138) bArg04;
		++dwArg08->dw0050;
	}
	++dwArg08->dw005C;
}

// 00403A9C: void fn00403A9C(Stack Eq_57 dwArg04, Stack ptr32 dwArg08)
// Called from:
//      fn00403AD0
void fn00403A9C(Eq_57 dwArg04, ptr32 dwArg08)
{
	int32 ecx_11;
	Eq_57 esi_13 = dwArg04;
	byte * eax_14 = dwArg08 + 0x07;
	for (ecx_11 = 0x07; ecx_11 >= 0x00; --ecx_11)
	{
		int32 edx_18 = esi_13 & 0x0F;
		byte dl_21 = (byte) edx_18;
		if (edx_18 < 0x0A)
			*eax_14 = dl_21 + 0x30;
		else
			*eax_14 = dl_21 + 55;
		esi_13 >>= 0x04;
		--eax_14;
	}
}

// 00403AD0: void fn00403AD0(Stack (ptr32 Eq_34) dwArg0C, Stack word32 dwArg10, Stack (ptr32 Eq_132) dwArg18)
// Called from:
//      fn004038E4
void fn00403AD0(struct Eq_34 * dwArg0C, word32 dwArg10, struct Eq_132 * dwArg18)
{
	word24 ebx_24_8_1200 = SLICE(ebx, word24, 8);
	struct Eq_34 * esi_107 = dwArg0C;
	while (true)
	{
l00403B18:
		byte bl_1182 = esi_107->b0000;
		++esi_107;
		if (bl_1182 == 0x00)
			break;
		if (bl_1182 == 0x25)
		{
			bl_1182 = esi_107->b0000;
			if (bl_1182 != 0x25)
			{
				int32 eax_1024 = 0x00;
				byte * dwLoc18_1334 = esi_107 - 0x01;
				int32 dwLoc14_1335 = 0x00;
				ci8 bLoc0D_1336 = 0x00;
				Eq_57 dwLoc0C_1337 = ~0x00;
				Eq_57 dwLoc08_1338 = ~0x00;
				ui32 edi_1030 = 0x20;
				word32 dwLoc20_1339 = 0x00;
				while (true)
				{
					do
					{
						ci8 bl_65 = esi_107->b0000;
						++esi_107;
						if (bl_65 < 0x20)
							goto l004043D8;
						word32 ebx_73 = SEQ(ebx_24_8_1200, bl_65);
						if ((int32) bl_65 > 0x7F)
							goto l004043D8;
						uint32 ecx_84 = (uint32) g_a40B1FA[(uint32) (bl_65 + 0xE0)];
					} while (ecx_84 > 0x1A);
					Eq_57 dwLoc1C_1347;
					Eq_57 dwLoc44_1360;
					int32 dwLoc3C_1399;
					byte cl_374;
					switch (ecx_84)
					{
					case 0x00:
						if (eax_1024 > 0x00)
							goto l004043D8;
						if (bLoc0D_1336 != 0x2B)
							bLoc0D_1336 = bl_65;
						break;
					case 0x01:
						if (eax_1024 > 0x00)
							goto l004043D8;
						edi_1030 |= 0x01;
						break;
					case 0x02:
						struct Eq_132 * v63_1087 = (char *) &dwArg18->tFFFFFFFC + 8;
						dwArg18 = v63_1087;
						Eq_57 ecx_1091 = v63_1087->tFFFFFFFC;
						if (eax_1024 < 0x02)
						{
							if (ecx_1091 < 0x00)
							{
								dwLoc08_1338 = -ecx_1091;
								edi_1030 |= 0x02;
							}
							else
								dwLoc08_1338 = ecx_1091;
							eax_1024 = 0x03;
						}
						else
						{
							if (eax_1024 != 0x04)
								goto l004043D8;
							++eax_1024;
							dwLoc0C_1337 = ecx_1091;
						}
						break;
					case 0x03:
						if (eax_1024 > 0x00)
							goto l004043D8;
						edi_1030 |= 0x02;
						break;
					case 0x04:
						if (eax_1024 >= 0x04)
							goto l004043D8;
						eax_1024 = 0x04;
						dwLoc0C_1337 = (word32) dwLoc0C_1337 + 1;
						break;
					case 0x05:
l00403CFD:
						if (eax_1024 <= 0x02)
						{
							eax_1024 = 0x02;
							if (dwLoc08_1338 == ~0x00)
								dwLoc08_1338 = (int32) (bl_65 + 0xD0);
							else
								dwLoc08_1338 = dwLoc08_1338 * 0x02 + dwLoc08_1338 * 0x08 + (int32) (bl_65 + 0xD0);
						}
						else
						{
							if (eax_1024 != 0x04)
								goto l004043D8;
							dwLoc0C_1337 = dwLoc0C_1337 * 0x02 + dwLoc0C_1337 * 0x08 + (int32) (bl_65 + 0xD0);
						}
						break;
					case 0x06:
						edi_1030 |= 0x10;
						eax_1024 = 0x05;
						break;
					case 0x07:
						eax_1024 = 0x05;
						edi_1030 = (edi_1030 | 0x0100) & ~0x10;
						break;
					case 0x08:
						eax_1024 = 0x05;
						edi_1030 = (edi_1030 | 0x0200) & ~0x10;
						break;
					case 0x09:
						if (eax_1024 > 0x00)
							goto l00403CFD;
						if ((edi_1030 & 0x02) == 0x00)
						{
							edi_1030 |= 0x08;
							eax_1024 = 0x01;
						}
						break;
					case 0x0A:
						dwLoc3C_1399 = 0x0A;
						cl_374 = 0x01;
						goto l00403E34;
					case 11:
						dwLoc3C_1399 = 0x08;
						goto l00403E23;
					case 0x0C:
						dwLoc3C_1399 = 0x0A;
						goto l00403E23;
					case 0x0D:
						dwLoc3C_1399 = 0x10;
						bLoc21 = (byte) (ebx_73 - 0x17);
l00403E23:
						bLoc0D_1336 = 0x00;
						cl_374 = 0x00;
l00403E34:
						Eq_878 qwLoc2C_2230;
						uint32 ecx_490 = (uint32) cl_374;
						if ((edi_1030 & 0x0100) != 0x00)
						{
							struct Eq_132 * v52_450 = &dwArg18->b0005 + 3;
							dwArg18 = v52_450;
							qwLoc2C_2230 = SEQ(v52_450->tFFFFFFFC, v52_450->dwFFFFFFF8);
						}
						else if ((edi_1030 & 0x10) != 0x00)
						{
							struct Eq_132 * v53_430 = (char *) &dwArg18->tFFFFFFFC + 8;
							dwArg18 = v53_430;
							Eq_57 edx_435 = v53_430->tFFFFFFFC;
							ecx_490 = (uint32) cl_374;
							if (cl_374 != 0x00)
								qwLoc2C_2230.u0 = (int64) edx_435;
							else
								qwLoc2C_2230.u1 = (uint64) edx_435;
						}
						else if ((edi_1030 & 0x0200) != 0x00)
						{
							struct Eq_132 * v59_410 = (char *) &dwArg18->tFFFFFFFC + 8;
							dwArg18 = v59_410;
							Eq_57 dx_415 = v59_410->tFFFFFFFC;
							ecx_490 = (uint32) cl_374;
							if (cl_374 != 0x00)
								qwLoc2C_2230.u0 = (int64) (int32) dx_415;
							else
								qwLoc2C_2230.u1 = (uint64) (word32) dx_415;
						}
						else
						{
							struct Eq_132 * v62_388 = (char *) &dwArg18->tFFFFFFFC + 8;
							dwArg18 = v62_388;
							Eq_57 edx_395 = v62_388->tFFFFFFFC;
							ecx_490 = (uint32) cl_374;
							if (cl_374 != 0x00)
								qwLoc2C_2230.u0 = (int64) edx_395;
							else
								qwLoc2C_2230.u1 = (uint64) edx_395;
						}
						word32 dwLoc2C_1430 = (word32) qwLoc2C_2230;
						dwLoc1C_1347 = fp - 0xBB;
						if (SLICE(qwLoc2C_2230, word32, 32) == 0x00 && dwLoc2C_1430 == 0x00)
						{
							if (dwLoc0C_1337 != 0x00)
								goto l00403F0A;
							bLocBB = 0x00;
						}
						else
						{
							edi_1030 |= 0x04;
l00403F0A:
							fn00405090(qwLoc2C_2230, fp - 0xBB, dwLoc3C_1399, (byte) ecx_490, bLoc21);
						}
						if (dwLoc0C_1337 < 0x00)
							goto l00404148;
						Eq_57 eax_614 = fn00402250(fp - 0xBB);
						Eq_57 dwLoc40_1518 = eax_614;
						dwLoc44_1360 = eax_614;
						if (bLocBB == 0x2D)
							dwLoc40_1518 = eax_614 - 0x01;
						else if (bLoc0D_1336 != 0x00)
						{
							dwLoc44_1360 = (word32) eax_614 + 1;
							dwLoc1C_1347 = fp - 188;
						}
						if (dwLoc0C_1337 > dwLoc40_1518)
							dwLoc14_1335 = dwLoc0C_1337 - dwLoc40_1518;
						goto l004041B6;
					case 0x0E:
						struct Eq_132 * v25_336 = (char *) &dwArg18->tFFFFFFFC + 8;
						fn00403A9C(v25_336->tFFFFFFFC, fp - 188);
						dwArg18 = v25_336;
						edi_1030 &= ~0x04;
						dwLoc1C_1347 = fp - 188;
						goto l00404148;
					case 0x0F:
						dwLoc1C_1347 = fp - 0xBB;
						fn00404FC8();
						fn00404FCE();
l00404148:
						if ((edi_1030 & 0x08) != 0x00 && dwLoc08_1338 > 0x00)
						{
							Eq_57 eax_541 = fn00402250(dwLoc1C_1347);
							Eq_57 dwLoc44_1477 = eax_541;
							if (*dwLoc1C_1347.u0 == 0x2D)
								dwLoc44_1477 = eax_541 - 0x01;
							if (dwLoc08_1338 > dwLoc44_1477)
								dwLoc14_1335 = dwLoc08_1338 - dwLoc44_1477;
						}
						if (*dwLoc1C_1347.u0 == 0x2D || bLoc0D_1336 != 0x00)
						{
							if (*dwLoc1C_1347.u0 != 0x2D)
							{
								Eq_57 v30_578 = dwLoc1C_1347 - 0x01;
								*v30_578 = bLoc0D_1336;
								dwLoc1C_1347 = v30_578;
							}
							if (dwLoc14_1335 > 0x00)
								--dwLoc14_1335;
						}
						dwLoc44_1360 = fn00402250(dwLoc1C_1347);
						goto l004041B6;
					case 0x10:
l00403FBD:
						if ((edi_1030 & 0x10) != 0x00)
						{
							struct Eq_132 * v24_273 = (char *) &dwArg18->tFFFFFFFC + 8;
							dwArg18 = v24_273;
							bLocBB = v24_273->b0005;
							dwLoc20_1339 = 0x01;
							dwLoc1C_1347 = fp - 188;
							dwLoc44_1360.u0 = 0x01;
						}
						else
						{
							dwArg18 = (struct Eq_132 *) ((char *) &dwArg18->tFFFFFFFC + 8);
							bLocBB = 0x00;
							dwLoc1C_1347 = fp - 188;
							dwLoc20_1339 = 0x00;
							dwLoc44_1360.u0 = 0x01;
						}
						goto l004041B6;
					case 0x11:
l00404038:
						if ((edi_1030 & 0x10) != 0x00)
						{
							struct Eq_132 * v23_191 = (char *) &dwArg18->tFFFFFFFC + 8;
							Eq_57 edx_194 = v23_191->tFFFFFFFC;
							dwArg18 = v23_191;
							dwLoc1C_1347 = edx_194;
							dwLoc20_1339 = 0x01;
							if (edx_194 == 0x00)
								dwLoc1C_1347.u0 = 0x0040B1EC;
						}
						else
						{
							struct Eq_132 * v51_181 = (char *) &dwArg18->tFFFFFFFC + 8;
							Eq_57 eax_185 = v51_181->tFFFFFFFC;
							dwArg18 = v51_181;
							dwLoc1C_1347 = eax_185;
							dwLoc20_1339 = 0x00;
							if (eax_185 == 0x00)
								dwLoc1C_1347.u0 = 4239844;
						}
						if (dwLoc20_1339 != 0x00)
						{
							Eq_57 eax_1287;
							if (dwLoc0C_1337 >= 0x00)
								eax_1287 = dwLoc0C_1337;
							else
								eax_1287.u0 = 0x7FFFFFFF;
							Eq_57 edx_235 = dwLoc1C_1347;
							dwLoc44_1360.u0 = 0x00;
							while (eax_1287 != 0x00 && *edx_235 != 0x00)
							{
								--eax_1287;
								dwLoc44_1360.u0 = (word16) dwLoc44_1360.u0 + 1;
								edx_235 = (word32) edx_235 + 2;
							}
						}
						else
						{
							Eq_57 eax_1286;
							if (dwLoc0C_1337 >= 0x00)
								eax_1286 = dwLoc0C_1337;
							else
								eax_1286.u0 = 0x7FFFFFFF;
							Eq_57 edx_210 = dwLoc1C_1347;
							dwLoc44_1360.u0 = 0x00;
							while (eax_1286 != 0x00 && *edx_210 != 0x00)
							{
								--eax_1286;
								dwLoc44_1360.u0 = (word16) dwLoc44_1360.u0 + 1;
								edx_210 = (word32) edx_210 + 1;
							}
						}
l004041B6:
						word32 ebx_782 = SEQ(ebx_24_8_1200, bl_65);
						if ((edi_1030 & 0x01) != 0x00)
						{
							ebx_782 = SEQ(ebx_24_8_1200, bl_65);
							if (bl_65 == 111)
							{
								if (dwLoc14_1335 <= 0x00)
									dwLoc14_1335 = 0x01;
								goto l004041EE;
							}
							ebx_782 = SEQ(ebx_24_8_1200, bl_65);
							if (bl_65 != 0x78)
							{
								ebx_782 = SEQ(ebx_24_8_1200, bl_65);
								if (bl_65 == 88)
									goto l004041DC;
							}
							else
							{
l004041DC:
								int32 v28_702 = dwLoc14_1335 - 0x02;
								edi_1030 |= 0x40;
								dwLoc08_1338 -= 0x02;
								dwLoc14_1335 = v28_702;
								if (v28_702 < 0x00)
									dwLoc14_1335 = 0x00;
							}
						}
l004041EE:
						Eq_57 v33_716 = (word16) dwLoc44_1360.u0 + dwLoc14_1335;
						ebx_24_8_1200 = SLICE(ebx_782, word24, 8);
						Eq_57 dwLoc44_1560 = v33_716;
						if ((edi_1030 & 0x02) == 0x00 && dwLoc08_1338 > v33_716)
						{
							do
							{
								fn00403A68(0x20, fp - 1316);
								Eq_57 v34_740 = dwLoc08_1338 - 0x01;
								dwLoc08_1338 = v34_740;
							} while (v34_740 > v33_716);
						}
						if ((edi_1030 & 0x40) != 0x00)
						{
							fn00403A68(0x30, fp - 1316);
							fn00403A68((byte) ebx_782, fp - 1316);
						}
						if (dwLoc14_1335 > 0x00)
						{
							Eq_57 v35_828 = v33_716 - dwLoc14_1335;
							Eq_57 v36_831 = dwLoc08_1338 - dwLoc14_1335;
							dwLoc44_1560 = v35_828;
							dwLoc08_1338 = v36_831;
							if (*dwLoc1C_1347.u0 == 0x2D || (*dwLoc1C_1347.u0 == 0x20 || *dwLoc1C_1347.u0 == 0x2B))
							{
								fn00403A68(*dwLoc1C_1347.u0, fp - 1316);
								dwLoc1C_1347.u0 = (word16) dwLoc1C_1347.u0 + 1;
								dwLoc44_1560 = v35_828 - 0x01;
								dwLoc08_1338 = v36_831 - 0x01;
							}
							while (true)
							{
								dwLoc14_1335 += ~0x00;
								if (dwLoc14_1335 == 0x00)
									break;
								fn00403A68(0x30, fp - 1316);
							}
						}
						if (dwLoc20_1339 != 0x00)
						{
							Eq_57 dwLoc48_1637 = dwLoc1C_1347;
							Eq_57 dwLoc50_1638 = 0x00;
							Eq_57 dwLoc58_1641 = dwLoc44_1560;
							while (true)
							{
								dwLoc58_1641 = (word32) dwLoc58_1641 - 1;
								if (dwLoc58_1641 <= 0x00)
									break;
								dwLoc48_1637 = (word32) dwLoc48_1637 + 2;
								int32 eax_928 = fn0040487C(fp - 0x5A, *dwLoc48_1637);
								if (eax_928 <= 0x00)
									break;
								int32 ecx_939 = 0x00;
								byte * edx_941 = (word32) dwLoc50_1638 + (fp - 1212);
								byte * eax_942 = fp - 0x5A;
								if (eax_928 > 0x00)
								{
									do
									{
										*edx_941 = *eax_942;
										++eax_942;
										++edx_941;
										dwLoc50_1638 = (word32) dwLoc50_1638 + 1;
										++ecx_939;
									} while (ecx_939 < eax_928);
								}
							}
							dwLoc1C_1347 = fp - 1212;
							dwLoc44_1560 = dwLoc50_1638;
						}
						if (dwLoc44_1560 != 0x00)
						{
							dwLoc08_1338 -= dwLoc44_1560;
							while (true)
							{
								dwLoc44_1560 = (word32) dwLoc44_1560 - 1;
								if (dwLoc44_1560 == 0x00)
									break;
								fn00403A68(*dwLoc1C_1347.u0, fp - 1316);
								dwLoc1C_1347.u0 = (word16) dwLoc1C_1347.u0 + 1;
							}
						}
						while (true)
						{
							dwLoc08_1338 = (word32) dwLoc08_1338 - 1;
							if (dwLoc08_1338 <= 0x00)
								break;
							fn00403A68(0x20, fp - 1316);
						}
						goto l00403B18;
					case 0x12:
						if ((edi_1030 & 0x0210) == 0x00)
							edi_1030 |= 0x10;
						goto l00403FBD;
					case 0x13:
						if ((edi_1030 & 0x0210) == 0x00)
							edi_1030 |= 0x10;
						goto l00404038;
					case 0x14:
						struct Eq_132 * v21_143 = (char *) &dwArg18->tFFFFFFFC + 8;
						dwArg18 = v21_143;
						Eq_57 ecx_148 = v21_143->tFFFFFFFC;
						if ((edi_1030 & 0x10) != 0x00)
							*ecx_148 = 0x00;
						else if ((edi_1030 & 0x0200) != 0x00)
							ecx_148->u0 = 0x00;
						else
							*ecx_148 = 0x00;
						goto l00403B18;
					case 0x15:
					case 22:
					case 0x17:
l004043D8:
						while (true)
						{
							++dwLoc18_1334;
							byte al_1123 = *dwLoc18_1334;
							if (al_1123 == 0x00)
								break;
							fn00403A68(al_1123, fp - 1316);
						}
						goto l004043E4;
					case 0x18:
						edi_1030 &= ~0x20;
						eax_1024 = 0x05;
						break;
					case 0x19:
						edi_1030 |= 0x20;
						eax_1024 = 0x05;
						break;
					case 0x1A:
						if (esi_107->b0000 == 0x36 && esi_107[1] == 0x34)
						{
							esi_107 += 2;
							edi_1030 = (edi_1030 | 0x0100) & ~0x0210;
							eax_1024 = 0x05;
						}
						else if (esi_107->b0000 == 0x33 && esi_107[1] == 0x32)
						{
							esi_107 += 2;
							edi_1030 = (edi_1030 | 0x10) & ~0x0300;
							eax_1024 = 0x05;
						}
						else if (esi_107->b0000 == 0x31 && esi_107[1] == 0x36)
						{
							esi_107 += 2;
							edi_1030 = (edi_1030 | 0x0200) & ~0x0110;
							eax_1024 = 0x05;
						}
						else if (esi_107->b0000 == 0x38)
						{
							++esi_107;
							edi_1030 &= ~0x0310;
							eax_1024 = 0x05;
						}
						break;
					}
				}
			}
			++esi_107;
		}
		word32 ebx_1201 = SEQ(ebx_24_8_1200, bl_1182);
		if ((g_a40CA55[(uint32) bl_1182] & 0x04) != 0x00 && esi_107->b0000 != 0x00)
		{
			fn00403A68(bl_1182, fp - 1316);
			++esi_107;
			ebx_1201 = SEQ(ebx_24_8_1200, esi_107->b0000);
		}
		fn00403A68((byte) ebx_1201, fp - 1316);
		ebx_24_8_1200 = SLICE(ebx_1201, word24, 8);
	}
l004043E4:
	fn00403A20(fp - 1316);
}

// 0040487C: Register int32 fn0040487C(Stack Eq_816 dwArg04, Stack Eq_817 wArg08)
// Called from:
//      fn00403AD0
int32 fn0040487C(Eq_816 dwArg04, Eq_817 wArg08)
{
	Eq_1028 bArg08_99 = (byte) wArg08;
	if (dwArg04 == 0x00)
		return 0x00;
	if (g_ptr40B59C->dw0008 == 0x00)
	{
		int32 eax_40 = WideCharToMultiByte(g_ptr40B59C->t0000, 0x0220, fp + 0x08, 0x01, dwArg04, 0x02, null, fp - 0x08);
		if (eax_40 == 0x00 || 0x00 != 0x00)
			return ~0x00;
		return eax_40;
	}
	else
	{
		if (wArg08 > 0xFF)
			return ~0x00;
		*dwArg04 = bArg08_99;
		return 0x01;
	}
}

// 00404C97: Register uint32 fn00404C97(Sequence Eq_878 edx_eax, Stack int64 qwArg04, Register out Eq_1082 edxOut)
// Called from:
//      fn00405090
uint32 fn00404C97(Eq_878 edx_eax, int64 qwArg04, union Eq_1082 & edxOut)
{
	Eq_1082 edx = SLICE(edx_eax, word32, 32);
	uint32 eax = (word32) edx_eax;
	Eq_1082 dwArg04 = (word32) qwArg04;
	Eq_1082 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_1082 edx_109;
	if (dwArg08 == 0x00 && (edx == 0x00 || dwArg04 == 0x00))
	{
		eax = (uint32) (edx_eax /u dwArg04);
		edx_109.u0 = 0x00;
	}
	else
	{
		edx_109 = edx;
		word32 ecx_44;
		Eq_1082 edi_113 = 0x00;
		Eq_1082 esi_112 = 0x00;
		for (ecx_44 = 0x40; ecx_44 != 0x00; --ecx_44)
		{
			eax <<= 0x01;
			edx_109 = __rcl(edx_109, 0x01, SLICE(cond(eax), bool, 1));
			esi_112 = __rcl(esi_112, 0x01, (edx_109 & 0x80000000) != 0x00);
			edi_113 = __rcl(edi_113, 0x01, (esi_112 & 0x80000000) != 0x00);
			if (edi_113 >= dwArg08 && (edi_113 > dwArg08 || esi_112 >= dwArg04))
			{
				ui64 edi_esi_119 = SEQ(edi_113, esi_112) - qwArg04;
				esi_112 = (word32) edi_esi_119;
				edi_113 = SLICE(edi_esi_119, word32, 32);
				++eax;
			}
		}
	}
	edxOut = edx_109;
	return eax;
}

// 00404D5A: Register byte fn00404D5A(Sequence Eq_878 edx_eax, Stack int64 qwArg04)
// Called from:
//      fn00405090
byte fn00404D5A(Eq_878 edx_eax, int64 qwArg04)
{
	Eq_1082 edx = SLICE(edx_eax, word32, 32);
	ui32 eax = (word32) edx_eax;
	Eq_1082 dwArg04 = (word32) qwArg04;
	Eq_1082 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_1082 eax_158;
	if (dwArg08 == 0x00 && (edx == 0x00 || dwArg04 == 0x00))
		eax_158.u0 = (uint32) (edx_eax % dwArg04);
	else
	{
		Eq_1082 edx_116 = edx;
		word32 ecx_47;
		Eq_1082 edi_48 = 0x00;
		Eq_1082 esi_49 = 0x00;
		for (ecx_47 = 0x40; ecx_47 != 0x00; --ecx_47)
		{
			eax <<= 0x01;
			edx_116 = __rcl(edx_116, 0x01, SLICE(cond(eax), bool, 1));
			esi_49 = __rcl(esi_49, 0x01, (edx_116 & 0x80000000) != 0x00);
			edi_48 = __rcl(edi_48, 0x01, (esi_49 & 0x80000000) != 0x00);
			if (edi_48 >= dwArg08 && (edi_48 > dwArg08 || esi_49 >= dwArg04))
			{
				ui64 edi_esi_124 = SEQ(edi_48, esi_49) - qwArg04;
				esi_49 = (word32) edi_esi_124;
				edi_48 = SLICE(edi_esi_124, word32, 32);
				++eax;
			}
		}
		eax_158 = esi_49;
	}
	return (byte) eax_158;
}

// 00404FC8: void fn00404FC8()
// Called from:
//      fn00403AD0
void fn00404FC8()
{
	g_ptr40B780();
}

// 00404FCE: void fn00404FCE()
// Called from:
//      fn00403AD0
void fn00404FCE()
{
	g_ptr40B784();
}

// 00405090: void fn00405090(Stack Eq_878 qwArg04, Stack (ptr32 byte) dwArg0C, Stack int32 dwArg10, Stack byte bArg14, Stack ci8 bArg18)
// Called from:
//      fn00403AD0
void fn00405090(Eq_878 qwArg04, byte * dwArg0C, int32 dwArg10, byte bArg14, ci8 bArg18)
{
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	up32 dwArg04 = (word32) qwArg04;
	byte * esi_113 = dwArg0C;
	if (dwArg10 < 0x02 || dwArg10 > 0x24)
	{
l00405134:
		*esi_113 = 0x00;
		return;
	}
	Eq_878 qwArg04_232;
	if (dwArg08 == 0x00)
	{
		qwArg04_232 = qwArg04;
		if (dwArg04 >= 0x00)
			goto l004050DE;
	}
	else
	{
		qwArg04_232 = qwArg04;
		if (dwArg08 >= 0x00)
			goto l004050DE;
	}
	qwArg04_232 = qwArg04;
	if (bArg14 != 0x00)
	{
		*dwArg0C = 0x2D;
		uint32 eax_38 = -dwArg04;
		esi_113 = dwArg0C + 1;
		qwArg04_232 = SEQ(-(dwArg08 + (eax_38 == 0x00)), eax_38);
	}
l004050DE:
	byte * ebx_102 = fp - 0x48;
	Eq_878 qwArg04_228 = qwArg04_232;
	do
	{
		do
		{
			*ebx_102 = (byte) (uint32) fn00404D5A(qwArg04_228, (int64) dwArg10);
			word32 edx_88;
			word32 eax_86 = fn00404C97(qwArg04_228, (int64) dwArg10, out edx_88);
			++ebx_102;
			word24 eax_24_8_117 = SLICE(eax_86, word24, 8);
			qwArg04_228 = SEQ(edx_88, eax_86);
		} while (edx_88 != 0x00);
		qwArg04_228 = SEQ(edx_88, eax_86);
	} while (eax_86 != 0x00);
	while (ebx_102 != fp - 0x48)
	{
		--ebx_102;
		ci8 al_107 = *ebx_102;
		word32 eax_118 = SEQ(eax_24_8_117, al_107);
		if (al_107 < 0x0A)
		{
			*esi_113 = (byte) (eax_118 + 0x30);
			eax_24_8_117 = SLICE(eax_118 + 0x30, word24, 8);
			++esi_113;
		}
		else
		{
			*esi_113 = al_107 + bArg18 + ~0x09;
			++esi_113;
		}
	}
	goto l00405134;
}

