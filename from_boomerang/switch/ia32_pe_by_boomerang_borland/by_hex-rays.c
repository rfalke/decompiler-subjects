/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Borland C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn sub_40106C(); // weak
void *sub_4010F3();
int __cdecl main(int argc, const char **argv, const char **envp);
// void *__cdecl malloc(size_t Size);
// void __cdecl free(void *Block);
// void *__cdecl realloc(void *Block, size_t Size);
void sub_4014B4();
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// size_t __cdecl strlen(const char *Str);
// wchar_t *__cdecl wcscpy(wchar_t *Destination, const wchar_t *Source);
// _DWORD __cdecl __InitExceptBlockLDTC();
int sub_4025DB();
FARPROC sub_402C78();
int __cdecl sub_403564(signed int *a1);
// int printf(const char *const Format, ...);
// _DWORD __cdecl _getLocaleNumericInfo(_DWORD); weak
// int __cdecl iswspace(wint_t C);
// double __cdecl _pow10(_DWORD); weak
int sub_404FCE();
void __noreturn sub_404FF8(); // weak
void __noreturn sub_405004(); // weak
// double __cdecl _fuildq(_DWORD); weak
// int __cdecl __ldtrunc(int, long double, int, int); idb
// _DWORD __cdecl _qmul10(_DWORD, _DWORD); weak
// _DWORD __cdecl sub_4053B8(_DWORD, _DWORD, _DWORD); weak
char *__cdecl sub_4053FC(int a1, int a2, void *a3, char a4, char a5, int a6);
int __cdecl sub_405684(int a1, int a2);
// _DWORD __cdecl sub_4056B4(_DWORD, _DWORD, _DWORD); weak
wchar_t *__cdecl sub_405700(int a1, int a2, wchar_t *Destination, __int16 a4, __int16 a5, int a6);
int __cdecl sub_4059B8(int a1, int a2);
__int16 __cdecl sub_4059E8(int a1, int (__cdecl *a2)(int), void (__cdecl *a3)(int, int), int a4, int a5, _DWORD *a6, _DWORD *a7);
// void __usercall sub_405E34(long double fst6_0@<st1>, int a2, int a3, int a4);
void sub_405EB4();
__int16 __cdecl sub_405ECC(int a1, int (__cdecl *a2)(int), void (__cdecl *a3)(int, int), int a4, int a5, _DWORD *a6, _DWORD *a7);
// void __usercall sub_406314(long double fst6_0@<st1>, int a2, int a3, int a4);
// int __cdecl __xcvt(int, size_t Size, int, void *, int); idb
// int __cdecl __xcvtw(int, size_t n, int, void *s, int); idb
// int __cdecl _ismbcspace(unsigned int C);
// void __cdecl __noreturn _ErrorExit(LPCSTR lpText); idb
void *__cdecl sub_4070A0(char *Str, int a2);
void sub_407598();
void *sub_4075A8();
// int _expandblock(void); weak
void *sub_407728();
void __cdecl __noreturn sub_407A40(UINT uExitCode); // idb
int sub_407A50();
int sub_407A54();
int __cdecl sub_407A58(_DWORD *a1, int a2);
void sub_407B2C();
int sub_407D1C();
// int __stdcall __CRTL_TLS_GetValue(DWORD dwTlsIndex); idb
// _DWORD __stdcall __CRTL_TLS_ExitThread(_DWORD); weak
FARPROC sub_407D8C();
// void __stdcall ExitProcess(UINT uExitCode);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HANDLE __stdcall GetProcessHeap();
// void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);

//-------------------------------------------------------------------------
// Data declarations

DWORD TlsIndex = 0u; // idb
_UNKNOWN __CPPdebugHook; // weak
int dword_40A1F8 = 0; // weak
CHAR aCppdebughook[] = "___CPPdebugHook"; // idb
UINT uNumber = 50u; // idb
int dword_40AB6C = 24576; // weak
int (*off_40B784)(void) = &loc_404FE0; // weak
void (__noreturn *off_40B788[2])() = { &unknown_libname_4, &unknown_libname_4 }; // weak
void (__noreturn *off_40B78C)() = &unknown_libname_4; // weak
CHAR aPrintfFloating_0[] = "printf : floating point formats not linked"; // idb
CHAR aScanfFloatingP_0[] = "scanf : floating point formats not linked"; // idb
int dword_40B858 = 0; // idb
int dword_40B85C = 2146435072; // idb
char aInf[5] = "-INF"; // weak
char aInf_0[5] = "+INF"; // weak
char aNan[5] = "-NAN"; // weak
char aNan_0[5] = "+NAN"; // weak
wchar_t Source[] = L"-INF"; // idb
char asc_40B8FE[2] = "+"; // weak
wchar_t aNan_1[] = L"-NAN"; // idb
char asc_40B912[2] = "+"; // weak
long double tbyte_40B91C = +Inf; // weak
long double tbyte_40B926 = -Inf; // weak
long double tbyte_40B930 = NaN; // weak
long double tbyte_40B93A = NaN; // weak
long double tbyte_40B944 = +Inf; // weak
long double tbyte_40B94E = -Inf; // weak
long double tbyte_40B958 = NaN; // weak
long double tbyte_40B962 = NaN; // weak
CHAR aNoSpaceForComm[] = "No space for command line argument vector"; // idb
CHAR aNoSpaceForComm_0[] = "No space for command line argument"; // idb
LPSTR lpFilename = NULL; // idb
CHAR aCouldNotAlloca[] = "Could not allocate memory for environment block"; // idb
int dword_40BBF8 = 0; // weak
CHAR aCppdebughook_0[] = "___CPPdebugHook"; // idb
int dword_40C4A8[259] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  
}; // idb
int dword_40C8B4; // weak
HANDLE Src; // idb
void *dword_40CC7C; // idb
int dword_40CC80; // weak
void *dword_40CC90; // idb
char *dword_40CC94; // idb
int dword_40CCA8; // weak
int dword_40CCB4; // weak
_DWORD dword_40CCB8[2]; // idb
int dword_40CCD4; // weak
int dword_40CCE4; // weak


//----- (0040106C) --------------------------------------------------------
void __noreturn sub_40106C()
{
  JUMPOUT(0xBAD);
}
// 401078: control flows out of bounds to BAD
// 40106C: using guessed type void __noreturn sub_40106C();

//----- (004010F3) --------------------------------------------------------
void *sub_4010F3()
{
  void *result; // eax
  HANDLE v1; // eax
  void *v2; // [esp-4h] [ebp-4h]

  result = (void *)__CRTL_TLS_GetValue(TlsIndex);
  if ( result )
  {
    v2 = result;
    v1 = GetProcessHeap();
    HeapFree(v1, 8u, v2);
    result = (void *)__CRTL_TLS_ExitThread(TlsIndex);
  }
  return result;
}
// 407D80: using guessed type _DWORD __stdcall __CRTL_TLS_ExitThread(_DWORD);

//----- (00401150) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  switch ( argc )
  {
    case 2:
      printf("Two!\n");
      break;
    case 3:
      printf("Three!\n");
      break;
    case 4:
      printf("Four!\n");
      break;
    case 5:
      printf("Five!\n");
      break;
    case 6:
      printf("Six!\n");
      break;
    case 7:
      printf("Seven!\n");
      break;
    default:
      printf("Other!\n");
      break;
  }
  return 0;
}

//----- (004014B4) --------------------------------------------------------
void sub_4014B4()
{
  dword_40A1F8 = 1;
}
// 40A1F8: using guessed type int dword_40A1F8;

//----- (004025DB) --------------------------------------------------------
int sub_4025DB()
{
  int i; // esi
  int result; // eax
  int v2; // ebx

  __InitExceptBlockLDTC();
  for ( i = 0; i < 256; ++i )
  {
    result = dword_40C4A8[i];
    if ( result )
    {
      do
      {
        v2 = *(_DWORD *)(result + 12);
        if ( result )
          (**(void (__cdecl ***)(int, int))result)(result, 3);
        result = v2;
      }
      while ( v2 );
    }
  }
  return result;
}
// 4025FC: conditional instruction was optimized away because of 'eax.4!=0'

//----- (00402C78) --------------------------------------------------------
FARPROC sub_402C78()
{
  HMODULE v0; // eax
  FARPROC result; // eax

  v0 = GetModuleHandleA(0);
  result = GetProcAddress(v0, aCppdebughook);
  dword_40C8B4 = (int)result;
  if ( !result )
    dword_40C8B4 = (int)&__CPPdebugHook;
  return result;
}
// 40C8B4: using guessed type int dword_40C8B4;

//----- (00403564) --------------------------------------------------------
int __cdecl sub_403564(signed int *a1)
{
  signed int v1; // eax
  UINT *v2; // edx
  int result; // eax
  signed int *v4; // esi
  char v5; // cl
  int v6; // edx
  int *i; // [esp+4h] [ebp-8h]
  signed int v8; // [esp+8h] [ebp-4h]

  v1 = uNumber;
  v2 = &uNumber + uNumber;
  if ( uNumber )
  {
    do
    {
      if ( *v2 )
        break;
      --v1;
      --v2;
    }
    while ( v1 );
  }
  if ( a1 )
  {
    *a1 = v1;
    v8 = 0;
    v4 = a1 + 1;
    for ( i = &dword_40AB6C; v1 > v8; ++i )
    {
      v5 = 1;
      v6 = *i;
      if ( (*i & 0x800) != 0 )
        v5 = 33;
      if ( (v6 & 0x8000) == 0 )
        v5 |= 0x80u;
      if ( (v6 & 0x2000) != 0 )
        v5 |= 0x40u;
      *(_BYTE *)v4 = v5;
      v4 = (signed int *)((char *)v4 + 1);
      ++v8;
    }
    memcpy(v4, &Src, 4 * v1);
    result = 0;
  }
  else if ( v1 )
  {
    result = 5 * v1 + 4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 40AB6C: using guessed type int dword_40AB6C;

//----- (00404FCE) --------------------------------------------------------
int sub_404FCE()
{
  return off_40B784();
}
// 40B784: using guessed type int (*off_40B784)(void);

//----- (00404FF8) --------------------------------------------------------
void __noreturn sub_404FF8()
{
  _ErrorExit(aPrintfFloating_0);
}
// 404FF8: using guessed type void __noreturn sub_404FF8();

//----- (00405004) --------------------------------------------------------
void __noreturn sub_405004()
{
  _ErrorExit(aScanfFloatingP_0);
}
// 405004: using guessed type void __noreturn sub_405004();

//----- (004053FC) --------------------------------------------------------
char *__cdecl sub_4053FC(int a1, int a2, void *a3, char a4, char a5, int a6)
{
  size_t v6; // edi
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // esi
  char *i; // ebx
  const char *v12; // eax
  char *result; // eax
  int v14; // eax
  _BYTE *v15; // ebx
  int v16; // edi
  int v17; // edi
  size_t v18; // edi
  char *v19; // ebx
  char v20; // dl
  char *v21; // eax
  _BYTE *v22; // ebx
  int v23; // esi
  _BYTE *v24; // ebx
  int v25; // edi
  _BYTE *v26; // ebx
  char v27; // [esp+Ch] [ebp-38h] BYREF
  char v28; // [esp+Dh] [ebp-37h]
  __int16 v29; // [esp+Eh] [ebp-36h] BYREF
  char v30; // [esp+3Ah] [ebp-Ah]
  char v31; // [esp+3Bh] [ebp-9h]
  int v32; // [esp+3Ch] [ebp-8h]
  int v33; // [esp+40h] [ebp-4h] BYREF

  v30 = *(_BYTE *)_getLocaleNumericInfo(14);
  if ( a2 > 40 )
    a2 = 40;
  v32 = a2;
  v31 = a4 & 0xDF;
  if ( (a4 & 0xDF) == 70 )
  {
    v6 = -v32;
    if ( -v32 >= 0 && v32 != 0 )
    {
      v6 = 0;
      a2 = 0;
    }
  }
  else
  {
    v6 = v32;
    if ( v32 > 0 )
    {
      if ( v31 == 69 )
      {
        v6 = v32 + 1;
        ++a2;
      }
    }
    else
    {
      v6 = 1;
    }
  }
  v7 = __xcvt(a1, v6, (int)&v33, &v27, a6);
  v10 = v7;
  i = (char *)a3;
  if ( v7 == 0x7FFF )
  {
    if ( v33 )
      v12 = aInf;
    else
      v12 = aInf_0;
    return strcpy((char *)a3, v12);
  }
  if ( v7 == 32766 )
  {
    if ( v33 )
      v12 = aNan;
    else
      v12 = aNan_0;
    return strcpy((char *)a3, v12);
  }
  if ( v33 )
  {
    *(_BYTE *)a3 = 45;
    i = (char *)a3 + 1;
  }
  if ( (v31 == 70 || v31 == 71 && v7 >= -3 && (a2 ? (v14 = a2) : (v14 = 1), v10 <= v14)) && v10 <= 40 )
  {
    if ( v10 <= 0 )
    {
      *i = 48;
      v15 = i + 1;
      *v15 = v30;
      for ( i = v15 + 1; v10; ++v10 )
        *i++ = 48;
    }
    v16 = 0;
    for ( result = &v27; *result; ++result )
    {
      *i++ = *result;
      if ( !--v10 )
      {
        *i++ = v30;
        ++v16;
      }
    }
    v17 = v32 + v16;
    if ( v17 >= a2 )
    {
      if ( v10 != 1 && !a5 )
      {
        LOBYTE(v8) = a4;
        result = (char *)sub_4053B8(v8, a3, i);
        i = result;
      }
    }
    else
    {
      v18 = a2 - v17;
      result = (char *)memset(i, 48, v18);
      i += v18;
    }
    if ( i == a3 )
      *i++ = 48;
    *i = 0;
  }
  else
  {
    *i = v27;
    v19 = i + 1;
    v20 = v28;
    v21 = (char *)&v29;
    if ( v28 )
    {
      for ( *v19++ = v30; v20; ++v21 )
      {
        *v19++ = v20;
        v20 = *v21;
      }
      if ( !a5 )
      {
        LOBYTE(v9) = a4;
        v19 = (char *)sub_4053B8(v9, a3, v19);
      }
    }
    else if ( a5 )
    {
      *v19++ = v30;
    }
    *v19 = a4 & 0x20 | 0x45;
    v22 = v19 + 1;
    v23 = v10 - 1;
    if ( v23 >= 0 )
    {
      *v22 = 43;
    }
    else
    {
      v23 = -v23;
      *v22 = 45;
    }
    v24 = v22 + 1;
    if ( v23 < 1000 )
    {
      if ( v23 < 100 )
        v25 = 2;
      else
        v25 = 3;
    }
    else
    {
      v25 = 4;
    }
    v24[v25] = 0;
    v26 = &v24[v25];
    do
    {
      *--v26 = v23 % 10 + 48;
      --v25;
      result = (char *)(v23 / 10);
      v23 /= 10;
    }
    while ( v25 );
  }
  return result;
}
// 405657: conditional instruction was optimized away because of 'edi.4 in (2..4)'
// 4055AB: variable 'v8' is possibly undefined
// 4055F9: variable 'v9' is possibly undefined
// 404434: using guessed type _DWORD __cdecl _getLocaleNumericInfo(_DWORD);
// 4053B8: using guessed type _DWORD __cdecl sub_4053B8(_DWORD, _DWORD, _DWORD);

//----- (00405684) --------------------------------------------------------
int __cdecl sub_405684(int a1, int a2)
{
  int result; // eax

  if ( a2 )
    result = a1 + 12;
  else
    result = a1 + 8;
  return result;
}

//----- (00405700) --------------------------------------------------------
wchar_t *__cdecl sub_405700(int a1, int a2, wchar_t *Destination, __int16 a4, __int16 a5, int a6)
{
  size_t v6; // edi
  int v7; // eax
  int v8; // edx
  int v9; // ecx
  int v10; // esi
  wchar_t *i; // ebx
  const wchar_t *v12; // eax
  wchar_t *result; // eax
  const wchar_t *v14; // edx
  int v15; // eax
  wchar_t *v16; // ebx
  int v17; // edi
  int v18; // edi
  size_t v19; // edi
  __int16 *v20; // ebx
  __int16 v21; // dx
  __int16 *v22; // eax
  _WORD *v23; // ebx
  int v24; // esi
  _WORD *v25; // ebx
  int v26; // edi
  _WORD *v27; // ebx
  wchar_t s; // [esp+Ch] [ebp-64h] BYREF
  __int16 v29; // [esp+Eh] [ebp-62h]
  int v30; // [esp+10h] [ebp-60h] BYREF
  wchar_t v31; // [esp+64h] [ebp-Ch]
  __int16 v32; // [esp+66h] [ebp-Ah]
  int v33; // [esp+68h] [ebp-8h]
  int v34; // [esp+6Ch] [ebp-4h] BYREF

  v31 = *(_WORD *)_getLocaleNumericInfo(14);
  if ( a2 > 40 )
    a2 = 40;
  v33 = a2;
  v32 = a4 & 0xDF;
  if ( v32 == 70 )
  {
    v6 = -v33;
    if ( -v33 >= 0 && v33 != 0 )
    {
      v6 = 0;
      a2 = 0;
    }
  }
  else
  {
    v6 = v33;
    if ( v33 > 0 )
    {
      if ( v32 == 69 )
      {
        v6 = v33 + 1;
        ++a2;
      }
    }
    else
    {
      v6 = 1;
    }
  }
  v7 = __xcvtw(a1, v6, (int)&v34, &s, a6);
  v10 = v7;
  i = Destination;
  if ( v7 == 0x7FFF )
  {
    if ( v34 )
      v12 = Source;
    else
      v12 = (const wchar_t *)asc_40B8FE;
    result = wcscpy(Destination, v12);
  }
  else if ( v7 == 32766 )
  {
    if ( v34 )
      v14 = aNan_1;
    else
      v14 = (const wchar_t *)asc_40B912;
    result = wcscpy(Destination, v14);
  }
  else
  {
    if ( v34 )
    {
      *Destination = 45;
      i = Destination + 1;
    }
    if ( (v32 == 70 || v32 == 71 && v7 >= -3 && (a2 ? (v15 = a2) : (v15 = 1), v10 <= v15)) && v10 <= 40 )
    {
      if ( v10 <= 0 )
      {
        *i = 48;
        v16 = i + 1;
        *v16 = v31;
        for ( i = v16 + 1; v10; ++v10 )
          *i++ = 48;
      }
      v17 = 0;
      for ( result = &s; *result; ++result )
      {
        *i++ = *result;
        if ( !--v10 )
        {
          *i++ = v31;
          ++v17;
        }
      }
      v18 = v33 + v17;
      if ( v18 >= a2 )
      {
        if ( v10 != 1 && !a5 )
        {
          LOWORD(v8) = a4;
          result = (wchar_t *)sub_4056B4(v8, Destination, i);
          i = result;
        }
      }
      else
      {
        v19 = a2 - v18;
        result = (wchar_t *)memset(i, 48, v19);
        i += v19;
      }
      if ( i == Destination )
        *i++ = 48;
      *i = 0;
    }
    else
    {
      *i = s;
      v20 = (__int16 *)(i + 1);
      v21 = v29;
      v22 = (__int16 *)&v30;
      if ( v29 )
      {
        *v20 = v31;
        for ( ++v20; v21; ++v22 )
        {
          *v20++ = v21;
          v21 = *v22;
        }
        if ( !a5 )
        {
          LOWORD(v9) = a4;
          v20 = (__int16 *)sub_4056B4(v9, Destination, v20);
        }
      }
      else if ( a5 )
      {
        *v20++ = v31;
      }
      *v20 = a4 & 0x20 | 0x45;
      v23 = v20 + 1;
      v24 = v10 - 1;
      if ( v24 >= 0 )
      {
        *v23 = 43;
      }
      else
      {
        v24 = -v24;
        *v23 = 45;
      }
      v25 = v23 + 1;
      if ( v24 < 1000 )
      {
        if ( v24 < 100 )
          v26 = 2;
        else
          v26 = 3;
      }
      else
      {
        v26 = 4;
      }
      v25[v26] = 0;
      v27 = &v25[v26];
      do
      {
        *--v27 = v24 % 10 + 48;
        --v26;
        result = (wchar_t *)(v24 / 10);
        v24 /= 10;
      }
      while ( v26 );
    }
  }
  return result;
}
// 405989: conditional instruction was optimized away because of 'edi.4 in (2..4)'
// 4058AA: variable 'v8' is possibly undefined
// 405916: variable 'v9' is possibly undefined
// 404434: using guessed type _DWORD __cdecl _getLocaleNumericInfo(_DWORD);
// 4056B4: using guessed type _DWORD __cdecl sub_4056B4(_DWORD, _DWORD, _DWORD);

//----- (004059B8) --------------------------------------------------------
int __cdecl sub_4059B8(int a1, int a2)
{
  int result; // eax

  if ( a2 )
    result = a1 + 12;
  else
    result = a1 + 8;
  return result;
}

//----- (004059E8) --------------------------------------------------------
__int16 __cdecl sub_4059E8(int a1, int (__cdecl *a2)(int), void (__cdecl *a3)(int, int), int a4, int a5, _DWORD *a6, _DWORD *a7)
{
  int v7; // esi
  unsigned int v8; // eax
  int v9; // ebx
  int v10; // edx
  int v11; // ebx
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // edi
  int v16; // eax
  __int16 result; // ax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // [esp+Ch] [ebp-44h]
  char v23; // [esp+13h] [ebp-3Dh]
  __int64 v24; // [esp+14h] [ebp-3Ch] BYREF
  long double *v25; // [esp+1Ch] [ebp-34h]
  long double v26; // [esp+20h] [ebp-30h]
  long double v27; // [esp+2Ch] [ebp-24h] BYREF
  int v28; // [esp+38h] [ebp-18h]
  int v29; // [esp+3Ch] [ebp-14h]
  char v30; // [esp+43h] [ebp-Dh]
  char v31; // [esp+44h] [ebp-Ch]
  char v32; // [esp+45h] [ebp-Bh]
  char v33; // [esp+46h] [ebp-Ah]
  char v34; // [esp+47h] [ebp-9h]
  int v35; // [esp+48h] [ebp-8h]
  int v36; // [esp+4Ch] [ebp-4h]

  v36 = 0x8000;
  v35 = 19;
  v34 = 0;
  v33 = 1;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v7 = -2;
  v28 = 1;
  v27 = 0.0;
  v25 = &v27;
  v23 = *(_BYTE *)_getLocaleNumericInfo(14);
  do
  {
    ++v29;
    v8 = a2(a4);
    v9 = v8;
    if ( v8 == -1 )
    {
      v28 = -1;
      goto LABEL_76;
    }
  }
  while ( (v8 & 0x80u) == 0 && _ismbcspace(v8) );
  if ( --a5 < 0 )
  {
LABEL_36:
    v9 = 101;
LABEL_37:
    if ( v7 == -2 )
      goto LABEL_75;
    if ( v36 == 0x8000 )
      v36 = v7;
    v12 = 0;
    if ( v9 != 101 && v9 != 69 )
    {
LABEL_52:
      a3(v9, a4);
      --v29;
LABEL_53:
      if ( v31 )
      {
        v12 = -v12;
        v30 = -v30;
      }
      if ( v7 >= 0 )
      {
        if ( v30 )
        {
          if ( v30 == 1 )
          {
            *((_WORD *)v25 + 3) = -1;
            *((_WORD *)v25 + 2) = -1;
            *((_WORD *)v25 + 1) = -1;
            *(_WORD *)v25 = -1;
            *((_WORD *)v25 + 4) = 32766;
          }
          else
          {
            v27 = 0.0;
          }
          v28 = 2;
        }
        else
        {
          if ( v7 <= v35 )
            v14 = v7;
          else
            v14 = v35;
          v15 = v36 - v14 + v12;
          v27 = _fuildq(&v27);
          if ( v15 )
          {
            if ( v15 <= 0 )
              v16 = -v15;
            else
              v16 = v15;
            v26 = _pow10(v16);
            if ( v15 >= 0 )
              v27 = v27 * v26;
            else
              v27 = v27 / v26;
          }
        }
      }
      else
      {
        v27 = 0.0;
      }
      goto LABEL_72;
    }
    v22 = 1;
    while ( 1 )
    {
      if ( --a5 < 0 )
        goto LABEL_53;
      ++v29;
      v13 = a2(a4);
      v9 = v13;
      if ( v22 )
      {
        v22 = 0;
        if ( v13 == 45 )
        {
          v31 = 1;
        }
        else if ( v13 != 43 )
        {
          goto LABEL_48;
        }
      }
      else
      {
LABEL_48:
        if ( v13 < 48 || v13 > 57 )
          goto LABEL_52;
        v12 = 10 * v12 + v13 - 48;
        if ( v12 > 4932 )
          v30 = 1;
      }
    }
  }
  if ( v9 == 43 )
  {
    v32 = 1;
  }
  else
  {
    if ( v9 != 45 )
      goto LABEL_13;
    v32 = 1;
    v34 = 1;
  }
  while ( 1 )
  {
    if ( --a5 < 0 )
      goto LABEL_36;
    ++v29;
    v9 = a2(a4);
LABEL_13:
    if ( v33 != 1 || !v32 )
      goto LABEL_17;
    if ( v9 == 73 )
      break;
    if ( v9 == 78 )
    {
      ++v29;
      v20 = a2(a4);
      v9 = v20;
      if ( --a5 >= 0 && v20 == 65 )
      {
        ++v29;
        v21 = a2(a4);
        v9 = v21;
        if ( --a5 >= 0 && v21 == 78 )
        {
          if ( v34 )
            v27 = tbyte_40B93A;
          else
            v27 = tbyte_40B930;
          goto LABEL_74;
        }
      }
      goto LABEL_75;
    }
LABEL_17:
    v33 = 0;
    if ( v9 == v23 )
    {
      if ( v36 != 0x8000 )
        goto LABEL_37;
      if ( v7 <= 0 )
        v10 = 0;
      else
        v10 = v7;
      v36 = v10;
    }
    else
    {
      if ( v9 < 48 || v9 > 57 )
        goto LABEL_37;
      v11 = v9 - 48;
      if ( ++v7 > 0 )
      {
        if ( v7 > 9 )
        {
          if ( v7 <= v35 )
          {
            v24 = *(_QWORD *)&v27;
            if ( _qmul10(&v24, v11) )
              v35 = v7 - 1;
            else
              *(_QWORD *)&v27 = v24;
          }
        }
        else
        {
          LODWORD(v27) = v11 + 10 * LODWORD(v27);
        }
      }
      else
      {
        *(_WORD *)v25 = v11;
        if ( v11 )
        {
          v7 = 1;
        }
        else
        {
          v7 = -1;
          if ( v36 != 0x8000 )
            --v36;
        }
      }
    }
  }
  ++v29;
  v18 = a2(a4);
  v9 = v18;
  if ( --a5 >= 0 && v18 == 78 )
  {
    ++v29;
    v19 = a2(a4);
    v9 = v19;
    if ( --a5 >= 0 && v19 == 70 )
    {
      if ( v34 )
        v27 = tbyte_40B926;
      else
        v27 = tbyte_40B91C;
      goto LABEL_74;
    }
  }
LABEL_75:
  v28 = 0;
LABEL_76:
  if ( a5 >= 0 )
  {
    a3(v9, a4);
    --v29;
  }
  v27 = 0.0;
LABEL_72:
  if ( v34 )
    v27 = -v27;
LABEL_74:
  *a6 += v29;
  *a7 = v28;
  *(_QWORD *)a1 = *(_QWORD *)&v27;
  result = HIWORD(v27);
  *(_WORD *)(a1 + 8) = HIWORD(v27);
  return result;
}
// 404434: using guessed type _DWORD __cdecl _getLocaleNumericInfo(_DWORD);
// 404DFC: using guessed type double __cdecl _pow10(_DWORD);
// 405028: using guessed type double __cdecl _fuildq(_DWORD);
// 405388: using guessed type _DWORD __cdecl _qmul10(_DWORD, _DWORD);
// 40B91C: using guessed type long double tbyte_40B91C;
// 40B926: using guessed type long double tbyte_40B926;
// 40B930: using guessed type long double tbyte_40B930;
// 40B93A: using guessed type long double tbyte_40B93A;

//----- (00405E34) --------------------------------------------------------
void __usercall sub_405E34(long double fst6_0@<st1>, int a2, int a3, int a4)
{
  long double v5; // fst6
  long double v6; // [esp-14h] [ebp-24h]
  long double v7; // [esp-14h] [ebp-24h]

  if ( (a4 & 4) != 0 )
  {
    HIWORD(v6) = *(_WORD *)(a2 + 8);
    *(_QWORD *)&v6 = *(_QWORD *)a2;
    __ldtrunc(1, v6, dword_40B858, dword_40B85C);
    *(double *)a3 = fst6_0;
  }
  else if ( (a4 & 8) != 0 )
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 4);
    *(_WORD *)(a3 + 8) = *(_WORD *)(a2 + 8);
  }
  else
  {
    v5 = tbyte_40B91C;
    HIWORD(v7) = *(_WORD *)(a2 + 8);
    *(_QWORD *)&v7 = *(_QWORD *)a2;
    __ldtrunc(0, v7, COERCE_UNSIGNED_INT64(tbyte_40B91C), HIDWORD(COERCE_UNSIGNED_INT64(tbyte_40B91C)));
    *(float *)a3 = v5;
  }
}
// 40B91C: using guessed type long double tbyte_40B91C;

//----- (00405EB4) --------------------------------------------------------
void sub_405EB4()
{
  off_40B788[0] = (void (__noreturn *)())sub_4059E8;
  off_40B78C = (void (__noreturn *)())sub_405E34;
}
// 40B788: using guessed type void (__noreturn *off_40B788[2])();
// 40B78C: using guessed type void (__noreturn *off_40B78C)();

//----- (00405ECC) --------------------------------------------------------
__int16 __cdecl sub_405ECC(int a1, int (__cdecl *a2)(int), void (__cdecl *a3)(int, int), int a4, int a5, _DWORD *a6, _DWORD *a7)
{
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v10; // edx
  int v11; // ebx
  int v12; // edi
  int v13; // eax
  int v14; // edx
  int v15; // edi
  int v16; // eax
  __int16 result; // ax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // [esp+Ch] [ebp-44h]
  unsigned __int16 v23; // [esp+12h] [ebp-3Eh]
  __int64 v24; // [esp+14h] [ebp-3Ch] BYREF
  long double *v25; // [esp+1Ch] [ebp-34h]
  long double v26; // [esp+20h] [ebp-30h]
  long double v27; // [esp+2Ch] [ebp-24h] BYREF
  int v28; // [esp+38h] [ebp-18h]
  int v29; // [esp+3Ch] [ebp-14h]
  char v30; // [esp+43h] [ebp-Dh]
  char v31; // [esp+44h] [ebp-Ch]
  char v32; // [esp+45h] [ebp-Bh]
  char v33; // [esp+46h] [ebp-Ah]
  char v34; // [esp+47h] [ebp-9h]
  int v35; // [esp+48h] [ebp-8h]
  int v36; // [esp+4Ch] [ebp-4h]

  v36 = 0x8000;
  v35 = 19;
  v34 = 0;
  v33 = 1;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v7 = -2;
  v28 = 1;
  v27 = 0.0;
  v25 = &v27;
  v23 = *(_WORD *)_getLocaleNumericInfo(14);
  do
  {
    ++v29;
    v8 = a2(a4);
    v9 = v8;
    if ( v8 == -1 )
    {
      v28 = -1;
      goto LABEL_75;
    }
  }
  while ( iswspace(v8) );
  if ( --a5 < 0 )
  {
LABEL_35:
    v9 = 101;
LABEL_36:
    if ( v7 == -2 )
      goto LABEL_74;
    if ( v36 == 0x8000 )
      v36 = v7;
    v12 = 0;
    if ( v9 != 101 && v9 != 69 )
    {
LABEL_51:
      a3(v9, a4);
      --v29;
LABEL_52:
      if ( v31 )
      {
        v12 = -v12;
        v30 = -v30;
      }
      if ( v7 >= 0 )
      {
        if ( v30 )
        {
          if ( v30 == 1 )
          {
            *((_WORD *)v25 + 3) = -1;
            *((_WORD *)v25 + 2) = -1;
            *((_WORD *)v25 + 1) = -1;
            *(_WORD *)v25 = -1;
            *((_WORD *)v25 + 4) = 32766;
          }
          else
          {
            v27 = 0.0;
          }
          v28 = 2;
        }
        else
        {
          if ( v7 <= v35 )
            v14 = v7;
          else
            v14 = v35;
          v15 = v36 - v14 + v12;
          v27 = _fuildq(&v27);
          if ( v15 )
          {
            if ( v15 <= 0 )
              v16 = -v15;
            else
              v16 = v15;
            v26 = _pow10(v16);
            if ( v15 >= 0 )
              v27 = v27 * v26;
            else
              v27 = v27 / v26;
          }
        }
      }
      else
      {
        v27 = 0.0;
      }
      goto LABEL_71;
    }
    v22 = 1;
    while ( 1 )
    {
      if ( --a5 < 0 )
        goto LABEL_52;
      ++v29;
      v13 = a2(a4);
      v9 = v13;
      if ( v22 )
      {
        v22 = 0;
        if ( v13 == 45 )
        {
          v31 = 1;
        }
        else if ( v13 != 43 )
        {
          goto LABEL_47;
        }
      }
      else
      {
LABEL_47:
        if ( v13 < 48 || v13 > 57 )
          goto LABEL_51;
        v12 = 10 * v12 + v13 - 48;
        if ( v12 > 4932 )
          v30 = 1;
      }
    }
  }
  if ( v9 == 43 )
  {
    v32 = 1;
  }
  else
  {
    if ( v9 != 45 )
      goto LABEL_12;
    v32 = 1;
    v34 = 1;
  }
  while ( 1 )
  {
    if ( --a5 < 0 )
      goto LABEL_35;
    ++v29;
    v9 = a2(a4);
LABEL_12:
    if ( v33 != 1 || !v32 )
      goto LABEL_16;
    if ( v9 == 73 )
      break;
    if ( v9 == 78 )
    {
      ++v29;
      v20 = a2(a4);
      v9 = v20;
      if ( --a5 >= 0 && v20 == 65 )
      {
        ++v29;
        v21 = a2(a4);
        v9 = v21;
        if ( --a5 >= 0 && v21 == 78 )
        {
          if ( v34 )
            v27 = tbyte_40B962;
          else
            v27 = tbyte_40B958;
          goto LABEL_73;
        }
      }
      goto LABEL_74;
    }
LABEL_16:
    v33 = 0;
    if ( v9 == v23 )
    {
      if ( v36 != 0x8000 )
        goto LABEL_36;
      if ( v7 <= 0 )
        v10 = 0;
      else
        v10 = v7;
      v36 = v10;
    }
    else
    {
      if ( v9 < 48 || v9 > 57 )
        goto LABEL_36;
      v11 = v9 - 48;
      if ( ++v7 > 0 )
      {
        if ( v7 > 9 )
        {
          if ( v7 <= v35 )
          {
            v24 = *(_QWORD *)&v27;
            if ( _qmul10(&v24, v11) )
              v35 = v7 - 1;
            else
              *(_QWORD *)&v27 = v24;
          }
        }
        else
        {
          LODWORD(v27) = v11 + 10 * LODWORD(v27);
        }
      }
      else
      {
        *(_WORD *)v25 = v11;
        if ( v11 )
        {
          v7 = 1;
        }
        else
        {
          v7 = -1;
          if ( v36 != 0x8000 )
            --v36;
        }
      }
    }
  }
  ++v29;
  v18 = a2(a4);
  v9 = v18;
  if ( --a5 >= 0 && v18 == 78 )
  {
    ++v29;
    v19 = a2(a4);
    v9 = v19;
    if ( --a5 >= 0 && v19 == 70 )
    {
      if ( v34 )
        v27 = tbyte_40B94E;
      else
        v27 = tbyte_40B944;
      goto LABEL_73;
    }
  }
LABEL_74:
  v28 = 0;
LABEL_75:
  if ( a5 >= 0 )
  {
    a3(v9, a4);
    --v29;
  }
  v27 = 0.0;
LABEL_71:
  if ( v34 )
    v27 = -v27;
LABEL_73:
  *a6 += v29;
  *a7 = v28;
  *(_QWORD *)a1 = *(_QWORD *)&v27;
  result = HIWORD(v27);
  *(_WORD *)(a1 + 8) = HIWORD(v27);
  return result;
}
// 404434: using guessed type _DWORD __cdecl _getLocaleNumericInfo(_DWORD);
// 404DFC: using guessed type double __cdecl _pow10(_DWORD);
// 405028: using guessed type double __cdecl _fuildq(_DWORD);
// 405388: using guessed type _DWORD __cdecl _qmul10(_DWORD, _DWORD);
// 40B944: using guessed type long double tbyte_40B944;
// 40B94E: using guessed type long double tbyte_40B94E;
// 40B958: using guessed type long double tbyte_40B958;
// 40B962: using guessed type long double tbyte_40B962;

//----- (00406314) --------------------------------------------------------
void __usercall sub_406314(long double fst6_0@<st1>, int a2, int a3, int a4)
{
  long double v5; // fst6
  long double v6; // [esp-14h] [ebp-24h]
  long double v7; // [esp-14h] [ebp-24h]

  if ( (a4 & 4) != 0 )
  {
    HIWORD(v6) = *(_WORD *)(a2 + 8);
    *(_QWORD *)&v6 = *(_QWORD *)a2;
    __ldtrunc(1, v6, dword_40B858, dword_40B85C);
    *(double *)a3 = fst6_0;
  }
  else if ( (a4 & 8) != 0 )
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    *(_DWORD *)(a3 + 4) = *(_DWORD *)(a2 + 4);
    *(_WORD *)(a3 + 8) = *(_WORD *)(a2 + 8);
  }
  else
  {
    v5 = tbyte_40B944;
    HIWORD(v7) = *(_WORD *)(a2 + 8);
    *(_QWORD *)&v7 = *(_QWORD *)a2;
    __ldtrunc(0, v7, COERCE_UNSIGNED_INT64(tbyte_40B944), HIDWORD(COERCE_UNSIGNED_INT64(tbyte_40B944)));
    *(float *)a3 = v5;
  }
}
// 40B944: using guessed type long double tbyte_40B944;

//----- (004070A0) --------------------------------------------------------
void *__cdecl sub_4070A0(char *Str, int a2)
{
  size_t v2; // eax
  char *v3; // eax
  char *v4; // ebx
  void *result; // eax

  if ( dword_40CCB4 == dword_40CC80 )
  {
    dword_40CC80 += 16;
    dword_40CC7C = realloc(dword_40CC7C, 4 * dword_40CC80);
    if ( !dword_40CC7C )
      _ErrorExit(aNoSpaceForComm);
  }
  if ( a2 )
  {
    v2 = strlen(Str);
    v3 = (char *)malloc(v2 + 1);
    v4 = v3;
    if ( !v3 )
      _ErrorExit(aNoSpaceForComm_0);
    strcpy(v3, Str);
  }
  else
  {
    v4 = Str;
  }
  result = dword_40CC7C;
  *((_DWORD *)dword_40CC7C + dword_40CCB4++) = v4;
  return result;
}
// 40CC80: using guessed type int dword_40CC80;
// 40CCB4: using guessed type int dword_40CCB4;

//----- (00407598) --------------------------------------------------------
void sub_407598()
{
  free(lpFilename);
}

//----- (004075A8) --------------------------------------------------------
void *sub_4075A8()
{
  void *result; // eax

  if ( dword_40CC94 )
    free(dword_40CC94);
  result = dword_40CC90;
  if ( dword_40CC90 )
    free(dword_40CC90);
  dword_40CC94 = 0;
  dword_40CC90 = 0;
  return result;
}

//----- (00407728) --------------------------------------------------------
void *sub_407728()
{
  void *result; // eax

  if ( !_expandblock() )
    _ErrorExit(aCouldNotAlloca);
  result = dword_40CC90;
  dword_40CCA8 = (int)dword_40CC90;
  return result;
}
// 4075DC: using guessed type int _expandblock(void);
// 40CCA8: using guessed type int dword_40CCA8;

//----- (00407A40) --------------------------------------------------------
void __cdecl __noreturn sub_407A40(UINT uExitCode)
{
  ExitProcess(uExitCode);
}

//----- (00407A50) --------------------------------------------------------
int sub_407A50()
{
  return 0;
}

//----- (00407A54) --------------------------------------------------------
int sub_407A54()
{
  return 0;
}

//----- (00407A58) --------------------------------------------------------
int __cdecl sub_407A58(_DWORD *a1, int a2)
{
  int result; // eax
  int i; // esi
  unsigned int v4; // edi
  unsigned int v5; // edx
  unsigned int v6; // ebx
  unsigned int j; // ebx
  int *v8; // [esp+Ch] [ebp-14h]
  int v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  int v11; // [esp+18h] [ebp-8h]
  unsigned int v12; // [esp+1Ch] [ebp-4h]

  if ( a2 )
  {
    v10 = -1;
    v9 = -1;
    result = 255;
  }
  else
  {
    v10 = 256;
    v9 = 1;
    result = 0;
  }
  for ( i = result; i != v10; i += v9 )
  {
    result = 0;
    v11 = 0;
    v8 = a1 + 1;
    while ( *a1 > v11 )
    {
      result = *v8;
      if ( a2 )
        v4 = *(_DWORD *)(result + 8);
      else
        v4 = *(_DWORD *)result;
      if ( a2 )
        v5 = *(_DWORD *)(result + 12);
      else
        v5 = *(_DWORD *)(result + 4);
      v12 = v5;
      if ( a2 )
      {
        for ( j = v5 - 6; v4 <= j; j -= 6 )
        {
          result = i;
          if ( (_BYTE)i == *(_BYTE *)(j + 1) )
            result = (*(int (**)(void))(j + 2))();
        }
      }
      else
      {
        v6 = v4;
        if ( v4 < v5 )
        {
          do
          {
            result = i;
            if ( (_BYTE)i == *(_BYTE *)(v6 + 1) )
              result = (*(int (**)(void))(v6 + 2))();
            v6 += 6;
          }
          while ( v6 < v12 );
        }
      }
      ++v11;
      ++v8;
    }
  }
  return result;
}

//----- (00407B2C) --------------------------------------------------------
void sub_407B2C()
{
  _DWORD *v0; // eax
  _DWORD *v1; // edi
  int v2; // esi
  _DWORD *v3; // ebx

  if ( !dword_40BBF8 )
  {
    dword_40BBF8 = 1;
    sub_407A58(&dword_40CCD4, 1);
    sub_407A58(dword_40CCB8, 1);
    v0 = (_DWORD *)sub_407A54();
    v1 = v0;
    if ( v0 )
    {
      sub_407A58(v0, 1);
      v2 = 0;
      v3 = v1 + 1;
      while ( v2 < *v1 )
      {
        (*(void (__cdecl **)(int, _DWORD))(*v3 + 24))(1, *(_DWORD *)(*v3 + 20));
        ++v2;
        ++v3;
      }
    }
  }
}
// 40BBF8: using guessed type int dword_40BBF8;
// 40CCD4: using guessed type int dword_40CCD4;

//----- (00407D1C) --------------------------------------------------------
int sub_407D1C()
{
  int result; // eax
  struct _STARTUPINFOA v1; // [esp+0h] [ebp-44h] BYREF

  GetStartupInfoA(&v1);
  if ( (v1.dwFlags & 1) != 0 )
    result = v1.wShowWindow;
  else
    result = 10;
  return result;
}

//----- (00407D8C) --------------------------------------------------------
FARPROC sub_407D8C()
{
  HMODULE v0; // eax
  FARPROC result; // eax

  v0 = GetModuleHandleA(0);
  result = GetProcAddress(v0, aCppdebughook_0);
  dword_40CCE4 = (int)result;
  if ( !result )
    dword_40CCE4 = (int)&__CPPdebugHook;
  return result;
}
// 40CCE4: using guessed type int dword_40CCE4;

// nfuncs=322 queued=30 decompiled=30 lumina nreq=0 worse=0 better=0
// ALL OK, 30 function(s) have been successfully decompiled
