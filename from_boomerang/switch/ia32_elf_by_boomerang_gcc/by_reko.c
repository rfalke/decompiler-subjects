// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_31 g_t804AA6C = // 0804AA6C
	{
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
	};
struct Eq_31 * objects = null; // 0804AA84
word32 _environ = 0x10095510; // 0804AA88
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw804A55C = ~0x00; // 0804A55C
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> ** g_ptr804A558 = &g_ptr804A568; // 0804A558
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804A568 = null; // 0804A568
// subject_eh_frame.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_25 g_t804A56C = // 0804A56C
	{
		
		{
			0x10
		},
		0x00,
		0x7C010001,
		0x04040C08,
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049440: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049410: void _init()
// Called from:
//      _start
void _init()
{
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048780: void _cleanup()
void _cleanup()
{
}

// 08048790: void atexit()
void atexit()
{
}

// 080487A0: void __fpstart()
void __fpstart()
{
}

// 080487B0: void exit()
void exit()
{
}

// 080487C0: void printf()
void printf()
{
}

// 080487D0: void malloc()
void malloc()
{
}

// 080487E0: void free()
void free()
{
}

// 080487F0: void abort()
void abort()
{
}

// 08048800: void memset()
void memset()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _lib_version = 0x01; // 08049454
char g_str8049458[] = "Two!\n"; // 08049458
char g_str804945E[] = "Three!\n"; // 0804945E
char g_str8049466[] = "Four!\n"; // 08049466
char g_str804946D[] = "Five!\n"; // 0804946D
char g_str8049474[] = "Six!\n"; // 08049474
char g_str804947A[] = "Seven!\n"; // 0804947A
char g_str8049482[] = "Other!\n"; // 08049482
<unknown> g_t804948A = // 0804948A;
<unknown> g_t804948B = // 0804948B;
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048810: void _start(Register word32 edx, Stack word32 dwArg00)
void _start(word32 edx, word32 dwArg00)
{
	atexit(&g_t8048780);
}

// 0804887F: void _mcount()
void _mcount()
{
}

// 08048880: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	while (true)
	{
		<anonymous> ** eax_16 = g_ptr804A558;
		if (*eax_16 == null)
			break;
		g_ptr804A558 = (<anonymous> **) ((char *) eax_16 + 4);
		(*eax_16)();
	}
	__deregister_frame_info(&g_t804A56C);
}

// 080488C0: void fini_dummy()
void fini_dummy()
{
}

// 080488D8: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
	__register_frame_info(&g_t804A56C, &g_t804AA6C);
}

// 08048900: void init_dummy()
void init_dummy()
{
}

// 08048918: Register word32 main(Stack up32 dwArg04)
// Called from:
//      _start
word32 main(up32 dwArg04)
{
	char * dwLoc08_40;
	if (dwArg04 <= 0x07)
	{
		switch (dwArg04)
		{
		case 0x02:
			dwLoc08_40 = (char *) "Two!\n";
			break;
		case 0x03:
			dwLoc08_40 = (char *) "Three!\n";
			break;
		case 0x04:
			dwLoc08_40 = (char *) "Four!\n";
			break;
		case 0x05:
			dwLoc08_40 = (char *) "Five!\n";
			break;
		case 0x06:
			dwLoc08_40 = (char *) "Six!\n";
			break;
		case 0x07:
			dwLoc08_40 = (char *) "Seven!\n";
			break;
		}
	}
	else
		dwLoc08_40 = (char *) "Other!\n";
	printf(dwLoc08_40);
	return 0x00;
}

// 0804898C: Register word32 decode_uleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
//      execute_cfa_insn
//      __frame_state_for
word32 decode_uleb128(byte * dwArg04, ui32 * dwArg08)
{
	ui32 edi_14 = 0x00;
	word32 esi_18 = 0x00;
	while (true)
	{
		ui32 edx_22 = (word32) *dwArg04;
		++dwArg04;
		edi_14 |= (edx_22 & 0x7F) << (byte) esi_18;
		if ((byte) edx_22 >= 0x00)
			break;
		esi_18 += 0x07;
	}
	*dwArg08 = edi_14;
	return dwArg04 + 1;
}

// 080489C8: Register (ptr32 byte) decode_sleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
byte * decode_sleb128(byte * dwArg04, ui32 * dwArg08)
{
	byte * edi_16 = dwArg04;
	ui32 dwLoc08_76 = 0x00;
	up32 ecx_107 = 0x00;
	do
	{
		byte cl_25 = (byte) ecx_110;
		ui32 esi_21 = (word32) *edi_16;
		ui32 v15_28 = dwLoc08_76 | (esi_21 & 0x7F) << cl_25;
		++edi_16;
		dwLoc08_76 = v15_28;
		ecx_107 = SEQ(SLICE(ecx_110 + 0x07, word24, 8), cl_25 + 0x07);
		ecx_110 = ecx_107;
	} while ((byte) esi_21 < 0x00);
	if (ecx_110 <= 0x18 && (esi_21 & 0x40) != 0x00)
		dwLoc08_76 = v15_28 | ~0x00 << cl_25 + 0x07;
	*dwArg08 = dwLoc08_76;
	return edi_16;
}

// 08048A24: void fde_insert(Stack (ptr32 Eq_25) dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_25) dwArg0C)
// Called from:
//      add_fdes
void fde_insert(struct Eq_25 * dwArg04, ui32 dwArg08, struct Eq_25 * dwArg0C)
{
	dwArg04[dwArg08] = (struct Eq_25) dwArg0C;
	ui32 edx_15 = dwArg08;
	if (dwArg08 != 0x00)
	{
		word32 * ecx_23 = dwArg04 + dwArg08;
		do
		{
			struct Eq_139 * esi_31 = (dwArg04 - 4)[edx_15];
			struct Eq_143 * edi_26 = *ecx_23;
			if (edi_26->dw0008 >= esi_31->dw0008)
				return;
			*ecx_23 = esi_31;
			(dwArg04 - 4)[edx_15] = edi_26;
			ecx_23 += -1;
			--edx_15;
		} while (edx_15 != 0x00);
	}
}

// 08048A7C: Register word32 count_fdes(Stack (ptr32 Eq_25) dwArg04)
// Called from:
//      frame_init
word32 count_fdes(struct Eq_25 * dwArg04)
{
	struct Eq_25 * edx_12 = dwArg04;
	word32 ecx_18 = 0x00;
	if (dwArg04->t0000.u0 != 0x00)
	{
		do
		{
			if (edx_12[1] != 0x00 && edx_12[2] != 0x00)
				++ecx_18;
			struct Eq_180 * eax_24 = edx_12 + (edx_12->t0000).u0 / 4;
			edx_12 = (struct Eq_25 *) &eax_24->dw0004;
		} while (eax_24->dw0004 != 0x00);
	}
	return ecx_18;
}

// 08048AAC: void add_fdes(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_25) dwArg08, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 up32) dwArg10, Stack (ptr32 up32) dwArg14)
// Called from:
//      frame_init
void add_fdes(struct Eq_25 * dwArg04, struct Eq_25 * dwArg08, ui32 * dwArg0C, up32 * dwArg10, up32 * dwArg14)
{
	struct Eq_25 * esi_20 = dwArg04;
	ui32 edi_22 = *dwArg0C;
	up32 dwLoc08_109 = *dwArg10;
	up32 dwLoc0C_111 = *dwArg14;
	if (dwArg04->t0000.u0 != 0x00)
	{
		do
		{
			if (esi_20[1] != 0x00 && esi_20[2] != 0x00)
			{
				fde_insert(dwArg08, edi_22, esi_20);
				++edi_22;
				up32 eax_57 = esi_20[2];
				if (dwLoc08_109 > eax_57)
					dwLoc08_109 = eax_57;
				up32 eax_65 = (word32) esi_20[3].t0000 + eax_57;
				if (dwLoc0C_111 < eax_65)
					dwLoc0C_111 = eax_65;
			}
			struct Eq_236 * eax_73 = esi_20 + (esi_20->t0000).u0 / 4;
			esi_20 = (struct Eq_25 *) &eax_73->dw0004;
		} while (eax_73->dw0004 != 0x00);
	}
	*dwArg0C = edi_22;
	*dwArg10 = dwLoc08_109;
	*dwArg14 = dwLoc0C_111;
}

// 08048B3C: void frame_init(Stack (ptr32 Eq_31) dwArg04)
// Called from:
//      find_fde
void frame_init(struct Eq_31 * dwArg04)
{
	Eq_275 tLoc10;
	Eq_276 tLoc0C;
	Eq_277 tLoc08;
	struct Eq_25 * eax_21 = dwArg04->ptr000C;
	if (eax_21 != null)
	{
		tLoc10 = (Eq_275) 0x00;
		struct Eq_25 * esi_40 = eax_21;
		if (eax_21->t0000.u0 != 0x00)
		{
			do
			{
				tLoc10 = (Eq_275) ((word32) tLoc10 + count_fdes((esi_40->t0000).u0));
				++esi_40;
			} while (esi_40->t0000.u0 != 0x00);
		}
	}
	else
		tLoc10 = (Eq_275) count_fdes(dwArg04->ptr0008);
	uint32 eax_66 = tLoc10;
	dwArg04->dw0010 = eax_66;
	struct Eq_25 * eax_73 = malloc(eax_66 << 0x02);
	tLoc0C = (Eq_276) ~0x00;
	tLoc08 = (Eq_277) 0x00;
	tLoc10 = (Eq_275) 0x00;
	struct Eq_25 * eax_81 = dwArg04->ptr000C;
	if (eax_81 != null)
	{
		struct Eq_25 * esi_108 = eax_81;
		if (eax_81->t0000.u0 != 0x00)
		{
			up32 * dwLoc14_179 = &tLoc08;
			do
			{
				add_fdes(esi_108->t0000.u0, eax_73, &tLoc10, &tLoc0C, dwLoc14_179);
				++esi_108;
			} while (esi_108->t0000.u0 != 0x00);
		}
	}
	else
		add_fdes(dwArg04->ptr0008, eax_73, &tLoc10, &tLoc0C, &tLoc08);
	dwArg04->ptr000C = eax_73;
	dwArg04->dw0000 = (up32) tLoc0C;
	dwArg04->dw0004 = (up32) tLoc08;
}

// 08048C28: Register (ptr32 Eq_410) find_fde(Stack up32 dwArg04)
// Called from:
//      __frame_state_for
struct Eq_410 * find_fde(up32 dwArg04)
{
	struct Eq_410 * eax_168;
	struct Eq_31 * esi_20 = objects;
	if (esi_20 != null)
	{
		do
		{
			if (esi_20->dw0000 == 0x00)
				frame_init(esi_20);
			if (esi_20->dw0000 <= dwArg04 && esi_20->dw0004 > dwArg04)
				break;
			esi_20 = esi_20->ptr0014;
		} while (esi_20 != null);
		if (esi_20 != null)
		{
			uint32 ecx_65 = esi_20->dw0010;
			uint32 edi_63 = 0x00;
			uint32 dwLoc08_124 = ecx_65;
			if (ecx_65 > 0x00)
			{
				struct Eq_25 * esi_71 = esi_20->ptr000C;
				do
				{
					uint32 eax_76 = dwLoc08_124 + edi_63;
					struct Eq_410 * ecx_80 = esi_71[eax_76 >> 0x01];
					up32 eax_82 = ecx_80->dw0008;
					if (dwArg04 < eax_82)
						dwLoc08_124 = eax_76 >> 0x01;
					else
					{
						if (dwArg04 <= eax_82 + ecx_80->dw000C)
						{
							eax_168 = ecx_80;
							return eax_168;
						}
						edi_63 = (eax_76 >> 0x01) + 1;
					}
				} while (dwLoc08_124 > edi_63);
			}
		}
	}
	eax_168 = null;
	return eax_168;
}

// 08048CC8: Register ptr32 extract_cie_info(Stack (ptr32 Eq_479) dwArg04, Stack (ptr32 Eq_480) dwArg08)
// Called from:
//      __frame_state_for
ptr32 extract_cie_info(struct Eq_479 * dwArg04, struct Eq_480 * dwArg08)
{
	Eq_481 tLoc08;
	ptr32 eax_160;
	struct Eq_483 * edx_23 = dwArg04 - (dwArg04->dw0004 + ~0x03);
	dwArg08->ptr0000 = &edx_23->b0009;
	if (memcmp(&edx_23->b0009, &g_t804948A, 0x01) != 0x00 && (memcmp(&edx_23->b0009, &g_t804948B, 0x03) != 0x00 && edx_23->b0009 != 122))
		eax_160 = 0x00;
	else
	{
		char * eax_60 = dwArg08->ptr0000;
		struct Eq_510 * eax_70 = eax_60 - 1 + (strlen(eax_60) - ~0x00);
		byte * edx_108 = &eax_70->dw0001;
		if (memcmp(eax_60, &g_t804948B, 0x03) == 0x00)
		{
			dwArg08->dw0004 = eax_70->dw0001;
			edx_108 = (byte *) (&eax_70->dw0001 + 1);
		}
		else
			dwArg08->dw0004 = 0x00;
		byte * eax_126 = decode_sleb128(decode_uleb128(edx_108, &dwArg08->dw0004 + 1), &dwArg08->dw0004 + 2);
		dwArg08->dw0010 = (word32) *eax_126;
		ptr32 edx_138 = eax_126 + 1;
		if (*dwArg08->ptr0000 == 122)
			edx_138 = decode_uleb128(eax_126 + 1, &tLoc08) + Mem147[&tLoc08 + 0x00:word32];
		eax_160 = edx_138;
	}
	return eax_160;
}

// 08048DE0: Register (ptr32 byte) execute_cfa_insn(Stack (ptr32 byte) dwArg04, Stack Eq_601 dwArg08, Stack (ptr32 Eq_602) dwArg0C, Stack (ptr32 word32) dwArg10, Register out (ptr32 Eq_604) ebpOut, Register out (ptr32 Eq_602) ediOut)
// Called from:
//      __frame_state_for
byte * execute_cfa_insn(byte * dwArg04, Eq_601 dwArg08, struct Eq_602 * dwArg0C, word32 * dwArg10, struct Eq_604 & ebpOut, struct Eq_602 & ediOut)
{
	ptr32 fp;
	struct Eq_604 * ebp;
	struct Eq_602 * edi;
	Eq_609 tLoc08;
	uint32 eax_23 = (word32) *dwArg04;
	ci8 al_33 = (byte) eax_23;
	byte * dwArg04_116 = dwArg04 + 1;
	byte bLoc14_119 = (byte) eax_23 & 0x40;
	if ((eax_23 & 0x40) != 0x00)
		*dwArg10 += (eax_23 & 0x3F) *s dwArg0C->dw0008;
	else if (al_33 < 0x00)
	{
		dwArg04_116 = decode_uleb128(dwArg04 + 1, &tLoc08);
		tLoc08 = (Eq_609) (tLoc08 *s dwArg0C->dw000C);
		*((word32) dwArg08.u0 + ((word32) (eax_23 & 0x3F) + 92)) = 0x01;
		Mem90[(eax_23 & 0x3F) * 0x04 + 16 + dwArg08:word32] = Mem86[&tLoc08 + 0x00:word32];
	}
	else
	{
		if ((al_33 & 0xC0) == 0x00)
		{
			if (eax_23 > 0x2E)
				abort();
			else
			{
				<anonymous> * ecx_46 = 0x0804A490 - g_a8048EA0[eax_23 * 0x04];
				byte * eax_50;
				ecx_46();
				ebpOut = fp - 4;
				ediOut = dwArg0C;
				return eax_50;
			}
		}
		Mem59[(eax_23 & 0x3F) + 92 + dwArg08:byte] = bLoc14_119;
	}
	ebpOut = ebp;
	ediOut = edi;
	return dwArg04_116;
}

ui32 g_a8048EA0[] = // 08048EA0
	{
	};
// 08049170: void __register_frame_info(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_31) dwArg08)
// Called from:
//      frame_dummy
void __register_frame_info(struct Eq_25 * dwArg04, struct Eq_31 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->ptr000C = null;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 080491B8: void __register_frame_info_table(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_31) dwArg08)
void __register_frame_info_table(struct Eq_25 * dwArg04, struct Eq_31 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->ptr000C = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 080491FC: void __deregister_frame_info(Stack (ptr32 Eq_25) dwArg04)
// Called from:
//      __do_global_dtors_aux
void __deregister_frame_info(struct Eq_25 * dwArg04)
{
	struct Eq_414 * ecx_14 = &objects;
	if (objects != null)
	{
		do
		{
			struct Eq_758 * edx_19 = ecx_14->ptr0000;
			if (edx_19->ptr0008 == dwArg04)
			{
				ecx_14->ptr0000 = (struct Eq_1055 *) edx_19->ptr0014;
				if (edx_19->dw0000 != 0x00)
					free(edx_19->ptr000C);
				return;
			}
			ecx_14 = (struct Eq_414 *) &edx_19->ptr0014;
		} while (edx_19->ptr0014 != null);
	}
	abort();
}

// 08049254: void __frame_state_for(Stack up32 dwArg04)
void __frame_state_for(up32 dwArg04)
{
	ptr32 fp;
	word32 dwLoc8C;
	Eq_794 tLoc18;
	struct Eq_795 * ebp_102 = fp - 4;
	struct Eq_479 * eax_24 = find_fde(dwArg04);
	if (eax_24 != null)
	{
		byte * eax_45 = extract_cie_info(eax_24, &tLoc18);
		byte * esi_114 = eax_45;
		if (eax_45 != null)
		{
			memset(&dwLoc8C, 0x00, 116);
			up32 * ecx_78 = eax_24 - (eax_24->dw0004 + ~0x03);
			ptr32 esp_115 = fp - 0xB8;
			if (eax_45 < (ecx_78 + *ecx_78) + 1)
			{
				do
				{
					struct Eq_853 * esp_89 = esp_115 - 4;
					esp_89->ptr0000 = null;
					esp_89->ptrFFFFFFFC = ebp_102->ptrFFFFFF60;
					esp_89->tFFFFFFF8.u0 = ebp_102->tFFFFFF5C.u0;
					esp_89->ptrFFFFFFF4 = esi_114;
					byte * edi_105;
					byte * eax_101 = execute_cfa_insn(esp_89->ptrFFFFFFF4, esp_89->tFFFFFFF8.u0, esp_89->ptrFFFFFFFC, esp_89->ptr0000, out ebp_102, out edi_105);
					word32 esp_108 = <invalid>;
					esi_114 = eax_101;
					esp_115 = esp_108 + 0x10;
				} while (eax_101 < edi_105);
			}
			struct Eq_838 * esi_120 = ebp_102->ptrFFFFFF6C;
			byte * esi_121 = &esi_120->dw0008 + 2;
			if (*ebp_102->ptrFFFFFFEC == 122)
			{
				struct Eq_921 * esp_127 = esp_115 - 4;
				esp_127->ptr0000 = ebp_102 - 0x8C;
				esp_127->ptrFFFFFFFC = (byte *) (&esi_120->dw0008 + 2);
				esi_121 = decode_uleb128(esp_127->ptrFFFFFFFC, esp_127->ptr0000) + ebp_102->dwFFFFFF74;
			}
			struct Eq_838 * eax_145 = ebp_102->ptrFFFFFF6C;
			up32 eax_146 = eax_145 + eax_145->dw0000 / 0x0C;
			ebp_102->dwFFFFFF70 = ebp_102->ptrFFFFFF6C->dw0008;
			ptr32 esp_162 = esp_115;
			if (esi_121 < eax_146 + 4)
			{
				ebp_102->ptrFFFFFF58 = ebp_102 - 0x90;
				while (ebp_102->dwFFFFFF70 <= ebp_102->dw0008)
				{
					struct Eq_962 * esp_163 = esp_162 - 4;
					esp_163->ptr0000 = ebp_102->ptrFFFFFF58;
					esp_163->ptrFFFFFFFC = ebp_102 - 20;
					esp_163->tFFFFFFF8.u0 = (int32) (ebp_102 - 0x88);
					esp_163->ptrFFFFFFF4 = esi_121;
					byte * edi_178;
					byte * eax_174 = execute_cfa_insn(esp_163->ptrFFFFFFF4, esp_163->tFFFFFFF8.u0, esp_163->ptrFFFFFFFC, esp_163->ptr0000, out ebp_102, out edi_178);
					word32 esp_181 = <invalid>;
					esi_121 = eax_174;
					esp_162 = esp_181 + 0x10;
					if (eax_174 >= edi_178)
						break;
				}
			}
			memcpy(ebp_102->ptr000C, ebp_102 - 0x88, 0x70);
		}
	}
}

// 080493C0: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> ** esi_17 = &g_dw804A55C;
	if (g_dw804A55C != ~0x00)
	{
		do
		{
			(*esi_17)();
			esi_17 = (<anonymous> **) ((char *) esi_17 - 4);
		} while (*esi_17 != (<anonymous> *) ~0x00);
	}
}

// 080493F4: void init_dummy()
void init_dummy()
{
}

