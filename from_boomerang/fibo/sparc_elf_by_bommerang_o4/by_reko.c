// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 objects = 0x00; // 000219DC
ptr32 _environ = 0x00; // 000219E0
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str21864[] = ""; // 00021864
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_92 g_t2185C = // 0002185C
	{
		137324,
		~0x00,
		0x00,
		~0x00,
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00011668: void _fini(Register word32 o2, Register word32 o3, Register word32 o4, Register word32 o5)
void _fini(word32 o2, word32 o3, word32 o4, word32 o5)
{
	__do_global_dtors_aux(o2, o3, o4, o5);
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_39 g_t216CC = // 000216CC
	{
		137308,
	};
struct Eq_92 * g_ptr216D0 = &g_t2185C; // 000216D0
struct Eq_93 * g_ptr216D4 = &g_t116B8; // 000216D4
word32 ** g_ptr216D8 = &g_ptr116C0; // 000216D8
char * g_ptr216DC = &g_str219DC; // 000216DC
char * g_ptr216E0 = &g_str21864; // 000216E0
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0001164C: Register word32 _init()
// Called from:
//      _start
word32 _init()
{
	word32 o3_32;
	word32 o4_33;
	word32 o5_34;
	return __do_global_ctors_aux(frame_dummy(out o3_32, out o4_33, out o5_34), o3_32, o4_33, o5_34);
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_93 ** g_ptr216E4 = null; // 000216E4
struct Eq_1174 * g_ptr216E8 = null; // 000216E8
// 00021714: void atexit()
void atexit()
{
}

// 00021720: void exit()
void exit()
{
}

// 0002172C: void _exit()
void _exit()
{
}

// 00021738: void printf()
void printf()
{
}

// 00021744: void scanf()
void scanf()
{
}

// 00021750: void malloc()
void malloc()
{
}

// 0002175C: void strcmp()
void strcmp()
{
}

// 00021768: void strlen()
void strlen()
{
}

// 00021774: void .umul()
void .umul()
{
}

// 00021780: void memcpy()
void memcpy()
{
}

// 0002178C: void free()
void free()
{
}

// 00021798: void abort()
void abort()
{
}

// 000217A4: void memset()
void memset()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _lib_version = 0x01; // 00011680
char g_str11688[] = "Input number: "; // 00011688
char g_str11698[] = "%d"; // 00011698
char g_str116A0[] = "fibonacci(%d) = %d\n"; // 000116A0
Eq_93 g_t116B8 = // 000116B8
	{
		0x00,
		0x00,
		,
		?? /* Can't read address 000116C4 */ ,
		?? /* Can't read address 000116C8 */ ,
		,
	};
word32 * g_ptr116C0 = ; // 000116C0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0001095C: void _start(Register (ptr32 Eq_2) g1)
void _start(void (* g1)())
{
	if (g1 == null)
	{
		atexit(&g_t11668);
		_environ = fp + 0x44 + ((_init() << 0x02) + 0x04);
		exit(main());
	}
	else
		atexit(g1);
}

// 000109D0: void __do_global_dtors_aux(Register word32 o2, Register word32 o3, Register word32 o4, Register word32 o5)
// Called from:
//      _fini
void __do_global_dtors_aux(word32 o2, word32 o3, word32 o4, word32 o5)
{
	word32 ** o1_27 = g_ptr216D8;
	struct Eq_39 * l7_23 = &g_t216CC;
	if (**o1_27 != 0x00)
	{
		word32 ** l0_35 = o1_27;
		word32 * o0_36 = *o1_27;
		while (true)
		{
			struct Eq_61 * o0_38 = o0_36 + 1;
			*l0_35 = (word32 **) o0_38;
			<anonymous> * o0_41 = o0_38->ptrFFFFFFFC;
			o0_41();
			if (**l0_35 == 0x00)
				break;
			o0_36 = *l0_35;
		}
	}
	__deregister_frame_info(l7_23->dw0004);
}

// 00010A4C: void fini_dummy()
void fini_dummy()
{
}

// 00010A58: Register word32 frame_dummy(Register out ptr32 o3Out, Register out ptr32 o4Out, Register out ptr32 o5Out)
// Called from:
//      _init
word32 frame_dummy(ptr32 & o3Out, ptr32 & o4Out, ptr32 & o5Out)
{
	ptr32 i3_34;
	ptr32 i4_35;
	ptr32 i5_36;
	word32 o2_42 = __register_frame_info(g_ptr216D0, g_ptr216D4, out i3_34, out i4_35, out i5_36);
	o3Out = i3_34;
	o4Out = i4_35;
	o5Out = i5_36;
	return o2_42;
}

// 00010A90: void init_dummy()
void init_dummy()
{
}

// 00010A9C: Register Eq_105 fib(Register Eq_105 o0, Register out Eq_105 l0Out, Register out Eq_105 i0Out, Register out (ptr32 Eq_108) i6Out)
// Called from:
//      fib
//      main
Eq_105 fib(Eq_105 o0, union Eq_105 & l0Out, union Eq_105 & i0Out, struct Eq_108 & i6Out)
{
	Eq_105 i0_5 = o0;
	struct Eq_108 * i6_16 = fp;
	Eq_105 l0_20 = o0;
	if (o0 > 0x01)
	{
		word32 l0_41;
		word32 i0_101;
		word32 i6_102;
		fib((word32) o0.u0 - 1, out l0_41, out i0_101, out i6_102);
		word32 i0_47;
		i0_5 = i0_47 + fib(l0_41 + ~0x01, out l0_20, out i0_47, out i6_16);
	}
	l0Out = l0_20;
	i0Out = i0_5;
	i6Out = i6_16;
	return i0_5;
}

// 00010AD0: Register word32 main()
// Called from:
//      _start
word32 main()
{
	int32 o2_30;
	printf("Input number: ");
	scanf("%d", &fp->dwFFFFFFEC);
	struct Eq_147 * i6_14 = fp;
	if (dwLoc14 > 0x01)
	{
		word32 i0_34;
		word32 l0_115;
		word32 i6_116;
		fib(dwLoc14 + ~0x00, out l0_115, out i0_34, out i6_116);
		word32 l0_66;
		word32 i0_117;
		o2_30 = l0_66 + fib(i0_34 + ~0x01, out l0_66, out i0_117, out i6_14);
	}
	else
		o2_30 = dwLoc14;
	printf("fibonacci(%d) = %d\n", i6_14->dwFFFFFFEC, o2_30);
	return 0x00;
}

// 00010B30: Register (ptr32 byte) decode_uleb128(Register (ptr32 byte) o0, Register (ptr32 Eq_187) o1, Register out Eq_187 o3Out)
// Called from:
//      extract_cie_info
//      execute_cfa_insn
//      __frame_state_for
byte * decode_uleb128(byte * o0, union Eq_187 * o1, union Eq_187 & o3Out)
{
	word32 o2_10 = 0x00;
	ui32 o3_15 = 0x00;
	while (true)
	{
		ui32 g3_7 = (ui32) *o0;
		++o0;
		ui32 g2_11 = (g3_7 & 0x7F) << o2_10;
		if ((g3_7 & 0x80) == 0x00)
			break;
		o3_15 |= g2_11;
		o2_10 += 0x07;
	}
	Eq_187 o3_16 = o3_15 | g2_11;
	*o1 = (union Eq_187 *) o3_16;
	o3Out = o3_16;
	return o0;
}

// 00010B64: Register (ptr32 byte) decode_sleb128(Register (ptr32 byte) o0, Register (ptr32 ui32) o1)
// Called from:
//      extract_cie_info
byte * decode_sleb128(byte * o0, ui32 * o1)
{
	word32 g3_10 = 0x00;
	ui32 o2_12 = 0x00;
	while (true)
	{
		ui32 o3_7 = (ui32) *o0;
		++o0;
		o2_12 |= (o3_7 & 0x7F) << g3_10;
		if ((o3_7 & 0x80) == 0x00)
			break;
		g3_10 += 0x07;
	}
	up32 g3_18 = g3_10 + 0x07;
	if (g3_18 < 0x1F && (o3_7 & 0x40) != 0x00)
		o2_12 |= ~0x00 << g3_18;
	*o1 = o2_12;
	return o0;
}

// 00010BB0: void fde_insert(Register (arr (ptr32 Eq_92)) o0, Register ui32 o1, Register (ptr32 Eq_92) o2)
// Called from:
//      add_fdes
void fde_insert(struct Eq_92 * o0[], ui32 o1, struct Eq_92 * o2)
{
	if (o1 != 0x00)
	{
		o0[o1].dw0000 = o2;
		struct Eq_257 * o0_12 = o0 + (o1 << 0x02) / 4;
		while (true)
		{
			struct Eq_271 * o3_15 = o0_12->dw0000;
			struct Eq_267 * o2_16 = o0_12->dwFFFFFFFC;
			if (o3_15->dw0008 - o2_16->dw0008 >= 0x00)
				break;
			o1 += ~0x00;
			o0_12->dw0000 = o2_16;
			o0_12->dwFFFFFFFC = o3_15;
			if (o1 == 0x00)
				return;
			o0_12 = (struct Eq_257 *) &o0_12->dwFFFFFFFC;
		}
	}
	else
		o0[o1].dw0000 = o2;
}

// 00010BF8: Register (ptr32 Eq_92) count_fdes(Register (ptr32 Eq_92) o0)
// Called from:
//      frame_init
struct Eq_92 * count_fdes(struct Eq_92 * o0)
{
	struct Eq_92 * o1_21 = null;
	if (o0->dw0000 != 0x00)
	{
		while (true)
		{
			int32 g2_16;
			if (o0[1] != 0x00)
			{
				if (o0[2] != 0x00)
					o1_21 = (struct Eq_92 *) ((char *) &o1_21->dw0000 + 1);
				g2_16 = o0->dw0000;
			}
			else
				g2_16 = o0->dw0000;
			struct Eq_310 * g2_28 = o0 + g2_16 / 4;
			if (g2_28->dw0004 == 0x00)
				break;
			o0 = (struct Eq_92 *) &g2_28->dw0004;
		}
	}
	return o1_21;
}

// 00010C4C: Register ui32 add_fdes(Register (ptr32 Eq_92) o0, Register (ptr32 (arr (ptr32 Eq_92))) o1, Register (ptr32 ui32) o2, Register (ptr32 word32) o3, Register (ptr32 word32) o4, Register out (ptr32 void) l1Out, Register out (ptr32 Eq_92) i0Out, Register out (ptr32 Eq_340) i6Out)
// Called from:
//      frame_init
ui32 add_fdes(struct Eq_92 * o0, struct Eq_92 * (* o1)[], ui32 * o2, word32 * o3, word32 * o4, void & l1Out, struct Eq_92 & i0Out, struct Eq_340 & i6Out)
{
	void * l1_109;
	struct Eq_92 * i0_118 = o0;
	ui32 l0_21 = *o2;
	up32 l2_100 = *o3;
	if (o0->dw0000 != 0x00)
	{
		l1_109 = *o4;
		while (true)
		{
			int32 o0_35;
			if (i0_118[1] != 0x00)
			{
				if (i0_118[2] != 0x00)
				{
					fde_insert(o1, l0_21, i0_118);
					up32 o1_57 = i0_118[2];
					if (o1_57 - l2_100 < 0x00)
					{
						++l0_21;
						l2_100 = o1_57;
					}
					else
						++l0_21;
					void * o0_69 = (word32) i0_118[3].dw0000 + o1_57;
					if (o0_69 - l1_109 >= 0x00)
						l1_109 = o0_69;
				}
				o0_35 = i0_118->dw0000;
			}
			else
				o0_35 = i0_118->dw0000;
			struct Eq_378 * o0_81 = i0_118 + o0_35 / 4;
			if (o0_81->dw0004 == 0x00)
				break;
			i0_118 = (struct Eq_92 *) &o0_81->dw0004;
		}
		i0_118 = (struct Eq_92 *) &o0_81->dw0004;
	}
	else
		l1_109 = *o4;
	*o2 = l0_21;
	*o3 = l2_100;
	*o4 = l1_109;
	l1Out = l1_109;
	i0Out = i0_118;
	i6Out = fp;
	return l0_21;
}

// 00010CE8: Register (ptr32 Eq_420) frame_init(Register (ptr32 Eq_93) o0, Register out (ptr32 (arr (ptr32 Eq_92))) l1Out, Register out (ptr32 Eq_423) i6Out)
// Called from:
//      find_fde
struct Eq_420 * frame_init(struct Eq_93 * o0, struct Eq_92 * (& l1Out, struct Eq_423 & i6Out)
{
	uint32 o0_37;
	struct Eq_93 * i0_130 = o0;
	struct Eq_423 * i6_101 = fp;
	struct Eq_420 * o0_21 = o0[3];
	if (o0_21 != null)
	{
		struct Eq_420 * l0_38 = o0_21;
		uint32 dwLoc14_195 = 0x00;
		if (o0_21->dw0000 != 0x00)
		{
			do
			{
				uint32 o1_64 = dwLoc14_195 + count_fdes(l0_38->dw0000);
				++l0_38;
				dwLoc14_195 = o1_64;
			} while (l0_38->dw0000 != 0x00);
			o0_37 = o1_64;
			o0[4] = (struct Eq_93) o1_64;
l00010D54:
			word32 o1_111;
			struct Eq_92 * (* l1_104)[];
			struct Eq_420 * l0_103;
			struct Eq_92 * (* o0_76)[] = malloc((size_t) (o0_37 << 0x02));
			struct Eq_420 * o1_84 = o0[3];
			if (o1_84 != null)
			{
				l1_104 = o0_76;
				l0_103 = o1_84;
				if (o1_84->dw0000 != 0x00)
				{
					struct Eq_92 * (* o1_120)[] = o0_76;
					while (true)
					{
						struct Eq_420 * l0_138 = add_fdes(l0_103->dw0000, o1_120, &i6_101->dwFFFFFFE8 + 1, &i6_101->dwFFFFFFE8, &i6_101->dwFFFFFFE4, out l1_104, out i0_130, out i6_101);
						l0_103 = l0_138 + 1;
						if (l0_138[1] == 0x00)
							break;
						o1_120 = l1_104;
					}
					o1_111 = i6_101->dwFFFFFFE8;
				}
				else
					o1_111 = ~0x00;
			}
			else
			{
				l0_103 = add_fdes(o0[2], o0_76, &fp->dwFFFFFFE8 + 1, &fp->dwFFFFFFE8, &fp->dwFFFFFFE4, out l1_104, out i0_130, out i6_101);
				o1_111 = i6_101->dwFFFFFFE8;
			}
			i0_130[3] = (struct Eq_93) l1_104;
			word32 o0_158 = i6_101->dwFFFFFFE4;
			i0_130->dw0000 = o1_111;
			i0_130[1] = (struct Eq_93) o0_158;
			l1Out = l1_104;
			i6Out = i6_101;
			return l0_103;
		}
		o0_37 = 0x00;
	}
	else
		o0_37 = count_fdes(o0[2]);
	o0[4] = (struct Eq_93) o0_37;
	goto l00010D54;
}

// 00010DF8: Register (ptr32 Eq_548) find_fde(Register (ptr32 Eq_548) o0, Register out ptr32 i6Out)
// Called from:
//      __frame_state_for
struct Eq_548 * find_fde(struct Eq_548 * o0, ptr32 & i6Out)
{
	struct Eq_548 * l1_205;
	struct Eq_93 * l0_105 = *g_ptr216E4;
	ptr32 i6_16 = fp;
	bool v32_207 = l0_105 == null;
	if (l0_105 == null)
	{
		l1_205 = o0;
		goto l00010E74;
	}
	l1_205 = o0;
	up32 o0_34 = l0_105->dw0000;
	while (true)
	{
		bool v36_211;
		if (o0_34 == 0x00)
		{
			l0_105 = frame_init(l0_105, out l1_205, out i6_16);
			v36_211 = l1_205 - l0_105->dw0000 < 0x00;
		}
		else
			v36_211 = l1_205 - o0_34 < 0x00;
		if (!v36_211)
		{
			if (l1_205 - l0_105[1] < 0x00)
			{
				v32_207 = l0_105 == null;
				goto l00010E74;
			}
			l0_105 = (struct Eq_93 *) l0_105[5];
		}
		else
			l0_105 = (struct Eq_93 *) l0_105[5];
		if (l0_105 == null)
		{
			v32_207 = l0_105 == null;
l00010E74:
			struct Eq_548 * i0_103;
			if (v32_207)
			{
				i0_103 = null;
				goto l00010ED8;
			}
			i0_103 = null;
			uint32 o4_107 = l0_105[4];
			uint32 o3_108 = 0x00;
			if (o4_107 <= 0x00)
				goto l00010ED8;
			uint32 o0_113 = o4_107;
			struct Eq_548 * o5_114[] = l0_105[3];
			while (true)
			{
				uint32 o2_116 = o0_113 >> 0x01;
				i0_103 = o5_114[o2_116];
				up32 o1_121 = i0_103->dw0008;
				if (l1_205 - o1_121 < 0x00)
					o4_107 = o2_116;
				else
				{
					up32 o0_126 = i0_103->dw000C;
					if (l1_205 - (o1_121 + o0_126) <= 0x00)
						goto l00010ED8;
					o3_108 = o2_116 + 0x01;
				}
				if (o3_108 - o4_107 >= 0x00)
					break;
				o0_113 = o3_108 + o4_107;
			}
			i0_103 = null;
l00010ED8:
			i6Out = i6_16;
			return i0_103;
		}
		o0_34 = l0_105->dw0000;
	}
}

// 00010EE0: Register (ptr32 Eq_649) extract_cie_info(Register (ptr32 Eq_649) o0, Register (ptr32 Eq_650) o1, Register out (ptr32 Eq_649) i0Out, Register out (ptr32 Eq_650) i1Out, Register out ptr32 i6Out)
// Called from:
//      __frame_state_for
struct Eq_649 * extract_cie_info(struct Eq_649 * o0, struct Eq_650 * o1, struct Eq_649 & i0Out, struct Eq_650 & i1Out, ptr32 & i6Out)
{
	struct Eq_649 * i0_116;
	char * o1_27 = g_ptr216DC;
	word32 o0_30 = o0 - o0->dw0004;
	o1->ptr0000 = o0_30 + 0x0D;
	if (strcmp(o0_30 + 0x0D, o1_27) != 0x00 && (strcmp(o1->ptr0000, g_ptr216E0) != 0x00 && (int32) (*o1->ptr0000) != 122))
		i0_116 = null;
	else
	{
		uint32 o0_56 = (uint32) strlen(o1->ptr0000);
		char * o2_58 = o1->ptr0000;
		struct Eq_689 * l0_62 = o2_58 + o0_56;
		byte * i0_63 = &l0_62->b0001;
		if (strcmp(o2_58, g_ptr216E0) == 0x00)
		{
			o1->dw0004 = (ui32) l0_62->b0004 | ((ui32) l0_62->b0003 << 0x08 | ((ui32) l0_62->b0002 << 0x10 | (ui32) l0_62->b0001 << 0x18));
			i0_63 = (byte *) (&l0_62->b0004 + 1);
		}
		else
			o1->dw0004 = 0x00;
		word32 o3_186;
		byte * o0_100 = decode_sleb128(decode_uleb128(i0_63, &o1->dw0004 + 1, out o3_186), &o1->dw0004 + 2);
		char * o1_110 = o1->ptr0000;
		o1->dw0010 = (ui32) *o0_100;
		if ((int32) *o1_110 == 122)
		{
			word32 o3_187;
			i0_116 = (struct Eq_649 *) (decode_uleb128(o0_100 + 1, fp + ~0x13, out o3_187) + dwLoc14);
		}
		else
			i0_116 = (struct Eq_649 *) (o0_100 + 1);
	}
	i0Out = i0_116;
	i1Out = o1;
	i6Out = fp;
	return i0_116;
}

// 00011008: Register (ptr32 byte) execute_cfa_insn(Register (ptr32 byte) o0, Register (ptr32 void) o1, Register (ptr32 (ptr32 int8)) o2, Register (ptr32 word32) o3, Register word32 o4, Register word32 o5, Register ptr32 o7, Register out ptr32 o7Out, Register out (ptr32 byte) i0Out, Register out (ptr32 void) i1Out, Register out (ptr32 Eq_805) i6Out)
// Called from:
//      __frame_state_for
byte * execute_cfa_insn(byte * o0, void * o1, int8 ** o2, word32 * o3, word32 o4, word32 o5, ptr32 o7, ptr32 & o7Out, byte & i0Out, void & i1Out, struct Eq_805 & i6Out)
{
	byte * i0_119;
	void * i1_121 = o1;
	struct Eq_805 * i6_109 = fp;
	ptr32 i7_110 = o7;
	uint32 o2_21 = (ui32) *o0;
	if ((o2_21 & 0x40) != 0x00)
	{
		word32 o0_98;
		word32 * i3_103;
		word32 g2_113;
		word32 g3_114;
		.umul();
		*i3_103 += o0_98;
	}
	else
	{
		i0_119 = o0 + 1;
		if ((o2_21 & 0x80) != 0x00)
		{
			word32 o3_55;
			word32 o0_66;
			word32 g2_81;
			word32 g3_82;
			.umul();
			i6_109->dwFFFFFFEC = o0_66;
			struct Eq_852 * o1_87 = (char *) i1_121 + i6_109->dwFFFFFFE8;
			o1_87->b01AC = 0x01;
			((char *) i1_121 + (i6_109->dwFFFFFFE8 << 0x02))[16] = (char) o1_87;
		}
		else
		{
			if ((o2_21 & 0xC0) == 0x00)
			{
				if (o2_21 >= 0x2E)
					abort();
				else
				{
					byte * o0_40 = *((char *) g_a11090 + o2_21 * 0x04);
					o7Out = 0x0001107C;
					i0Out = o0 + 1;
					i1Out = o1;
					i6Out = fp;
					return o0_40;
				}
			}
			((char *) o1 + (o2_21 & 0x3F))[428] = 0x00;
		}
	}
	o7Out = i7_110;
	i0Out = i0_119;
	i1Out = i1_121;
	i6Out = i6_109;
	return i0_119;
}

byte * g_a11090[] = // 00011090
	{
	};
// 000113B4: Register word32 __register_frame_info(Register (ptr32 Eq_92) o0, Register (ptr32 Eq_93) o1, Register out ptr32 i3Out, Register out ptr32 i4Out, Register out ptr32 i5Out)
// Called from:
//      frame_dummy
word32 __register_frame_info(struct Eq_92 * o0, struct Eq_93 * o1, ptr32 & i3Out, ptr32 & i4Out, ptr32 & i5Out)
{
	o1[2] = (struct Eq_93) o0;
	o1[1] = (struct Eq_93) 0x00;
	o1->dw0000 = 0x00;
	struct Eq_93 ** o1_28 = g_ptr216E4;
	o1[3] = (struct Eq_93) 0x00;
	struct Eq_93 * o0_30 = *o1_28;
	o1[4] = (struct Eq_93) 0x00;
	o1[5] = (struct Eq_93) o0_30;
	*o1_28 = (struct Eq_93 **) o1;
	i3Out = o3;
	i4Out = o4;
	i5Out = o5;
	return o2;
}

// 000113FC: void __register_frame_info_table(Register (ptr32 Eq_92) o0, Register (ptr32 Eq_93) o1)
void __register_frame_info_table(struct Eq_92 * o0, struct Eq_93 * o1)
{
	o1[2] = (struct Eq_93) o0;
	o1[3] = (struct Eq_93) o0;
	o1[1] = (struct Eq_93) 0x00;
	struct Eq_93 ** o1_28 = g_ptr216E4;
	o1->dw0000 = 0x00;
	struct Eq_93 * o0_30 = *o1_28;
	o1[4] = (struct Eq_93) 0x00;
	o1[5] = (struct Eq_93) o0_30;
	*o1_28 = (struct Eq_93 **) o1;
}

// 00011444: void __deregister_frame_info(Register word32 o0)
// Called from:
//      __do_global_dtors_aux
void __deregister_frame_info(word32 o0)
{
	struct Eq_93 ** o2_27 = g_ptr216E4;
	if (*o2_27 == null)
		abort();
	else
	{
		struct Eq_93 * o1_32 = *o2_27;
		if (o1_32[2] - o0 == 0x00)
		{
			struct Eq_93 * o0_40 = o1_32[5];
			*o2_27 = (struct Eq_93 **) o0_40;
			if (o1_32->dw0000 != 0x00)
				free(o1_32[3]);
		}
	}
}

// 000114C4: void __frame_state_for(Register (ptr32 Eq_548) o0, Register word32 o4, Register word32 o5, Register ptr32 o7)
void __frame_state_for(struct Eq_548 * o0, word32 o4, word32 o5, ptr32 o7)
{
	word32 i6_28;
	struct Eq_649 * o0_33 = find_fde(o0, out i6_28);
	if (o0_33 == null)
		return;
	void * i1_177;
	struct Eq_1011 * i6_101;
	up32 i0_161;
	byte * o0_57 = extract_cie_info(o0_33, i6_28 + ~0x27, out i0_161, out i1_177, out i6_101);
	if (o0_57 == null)
		return;
	int8 * o0_120;
	memset(&i6_101->dwFFFFFDBC + 1, 0x00, (size_t) 0x0218);
	word32 o1_71 = i6_101->dwFFFFFFDC;
	i6_101->wFFFFFF6A = (word16) (uipr32) i6_101->wFFFFFFEA;
	i6_101->dwFFFFFDC4 = o1_71;
	word32 * o0_76 = o0_33 - (o0_33->dw0004 + ~0x03);
	up32 o0_78 = o0_76 + *o0_76;
	if (o0_57 - (o0_78 + 0x04) < 0x00)
	{
		byte * o0_117 = o0_57;
		while (true)
		{
			byte * o0_103 = execute_cfa_insn(o0_117, &i6_101->dwFFFFFDBC + 1, &i6_101->ptrFFFFFFD8, null, o4, o5, o7, out o7, out i0_161, out i1_177, out i6_101);
			if (o0_103 - (o0_78 + 0x04) >= 0x00)
				break;
			o0_117 = o0_103;
		}
		o0_120 = i6_101->ptrFFFFFFD8;
	}
	else
		o0_120 = i6_101->ptrFFFFFFD8;
	byte * l0_129;
	if ((int32) *o0_120 == 122)
	{
		word32 o3_328;
		l0_129 = decode_uleb128(&o0_33->dw0008 + 2, &i6_101->dwFFFFFDBC, out o3_328) + i6_101->dwFFFFFDBC;
	}
	else
		l0_129 = (byte *) (&o0_33->dw0008 + 2);
	Eq_1099 o0_150 = o0_33 + o0_33->dw0000 / 0x0C;
	up32 o1_149 = o0_33->dw0008;
	if (l0_129 - ((word32) o0_150 + 4) < 0x00)
	{
		i6_101->dwFFFFFDB8 = o1_149;
		up32 o0_159 = i6_101->dwFFFFFDB8;
		while (o0_159 - i0_161 < 0x00)
		{
			byte * o0_184 = execute_cfa_insn(l0_129, &i6_101->dwFFFFFDBC + 1, &i6_101->ptrFFFFFFD8, &i6_101->dwFFFFFDB8, o4, o5, o7, out o7, out i0_161, out i1_177, out i6_101);
			l0_129 = o0_184;
			if (o0_184 - ((word32) o0_150 + 4) >= 0x00)
				break;
			o0_159 = i6_101->dwFFFFFDB8;
		}
	}
	else
		i6_101->dwFFFFFDB8 = o1_149;
	memcpy(i1_177, &i6_101->dwFFFFFDBC + 1, (size_t) 0x0214);
}

// 000115EC: Register (ptr32 word32) __do_global_ctors_aux(Register word32 o2, Register word32 o3, Register word32 o4, Register word32 o5)
// Called from:
//      _init
word32 * __do_global_ctors_aux(word32 o2, word32 o3, word32 o4, word32 o5)
{
	word32 * l0_32;
	struct Eq_1174 * o0_27 = g_ptr216E8;
	word32 o1_28 = o0_27->dwFFFFFFFC;
	if (o1_28 != ~0x00)
	{
		l0_32 = &o0_27->dwFFFFFFFC;
		do
		{
			<anonymous> * o0_36 = *l0_32;
			o0_36();
		} while (*l0_32 != (<anonymous> *) ~0x00);
	}
	else
		l0_32 = &o0_27->dwFFFFFFFC;
	return l0_32;
}

// 00011640: void init_dummy()
void init_dummy()
{
}

