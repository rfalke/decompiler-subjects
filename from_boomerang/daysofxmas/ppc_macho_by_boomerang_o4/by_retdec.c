//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ---------------- Integer Types Definitions -----------------

typedef int8_t int4_t;

// ------------------------ Structures ------------------------

struct struct1 {
    bool e0;
    bool e1;
    bool e2;
    bool e3;
    int4_t e4;
    int4_t e5;
    int4_t e6;
    int4_t e7;
    int4_t e8;
    int4_t e9;
    int4_t e10;
};

// ------------------- Function Prototypes --------------------

int32_t function_1d54(int32_t a1, int32_t a2, char a3);

// ------------------------ Functions -------------------------

// Address range: 0x19b8 - 0x1bc8
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv;
    int32_t v2 = __asm_mfcr(); // 0x19b8
    int32_t v3; // 0x19b8
    __asm_stmw(v3, v3);
    int32_t result; // 0x19b8
    int32_t v4; // 0x19b8
    int32_t v5; // 0x19b8
    if (v2 < 2) {
        char v6 = v3 / 0x1000000;
        if (v2 > -1) {
            // 0x1b48
            v4 = 2;
            v5 = 2;
            if (v2 == 0) {
                if (v6 != 47) {
                    int32_t v7 = main(-61, (char **)(int32_t)v6); // 0x1b88
                    if (main(0, (char **)v7) == 0) {
                        // 0x1ba8
                        __asm_lmw(v1, v3);
                        __asm_mtcrf(8, v2);
                        return 0;
                    }
                }
                // 0x1ba8
                __asm_lmw(v1, v3);
                __asm_mtcrf(8, v2);
                return 1;
            }
        } else {
            // 0x1a8c
            v4 = v1;
            v5 = v2;
            if (v2 > -73) {
                if (v2 > -51) {
                    // 0x1b30
                    v4 = v2 + (int32_t)(v6 == 47);
                    v5 = v1;
                } else {
                    // 0x1ab0
                    v4 = -65;
                    v5 = v1;
                    if (v1 == (int32_t)v6) {
                        char v8 = *(char *)(v3 + 31); // 0x1ac0
                        int32_t v9 = *(int32_t *)0x2060; // 0x1ac8
                        uint32_t v10 = (int32_t)v8; // 0x1acc
                        int32_t v11 = v9 + 88; // 0x1ad0
                        int32_t * v12 = (int32_t *)(v9 + 96); // 0x1ad4
                        int32_t v13 = *v12 - 1; // 0x1ad8
                        *v12 = v13;
                        if (v13 <= 0xffffffff) {
                            // 0x1ae8
                            if (v8 == 10 | v13 < *(int32_t *)(v9 + 112)) {
                                // 0x1ba8
                                result = function_1d54(v10, v11, v6);
                                __asm_lmw(v1, v3);
                                __asm_mtcrf(8, v2);
                                return result;
                            }
                        }
                        int32_t * v14 = (int32_t *)v11; // 0x1afc
                        int32_t v15 = *v14; // 0x1afc
                        *(char *)v15 = v8;
                        int32_t v16 = v15 + 1; // 0x1b08
                        *v14 = v16;
                        // 0x1ba8
                        __asm_lmw(v16, v3);
                        __asm_mtcrf(8, v2);
                        return v10 % 256;
                    }
                }
            }
        }
    } else {
        if (v2 == 2) {
            // 0x19f4
            main(-86, NULL);
            main(-87, (char **)(1 - v1));
            main(-79, (char **)-13);
        }
        if (v2 < v1) {
            // 0x1a2c
            main(v2 + 1, argv);
        }
        // 0x1a3c
        if (main(-94, (char **)(v2 - 27)) == 0 || v2 != 2) {
            // 0x1ba8
            __asm_lmw(v1, v3);
            __asm_mtcrf(8, v2);
            return 16;
        }
        // 0x1a58
        if (argv > (char **)12) {
            // 0x1ba8
            __asm_lmw(v1, v3);
            __asm_mtcrf(8, v2);
            return 9;
        }
        // 0x1a60
        v4 = 2;
        v5 = v1 + 1;
    }
    // 0x1ba8
    result = main(v4, (char **)v5);
    __asm_lmw(v1, v3);
    __asm_mtcrf(8, v2);
    return result;
}

// Address range: 0x1d54 - 0x1d78
int32_t function_1d54(int32_t a1, int32_t a2, char a3) {
    // 0x1d54
    return ___swbuf();
}

// --------------- Dynamically Linked Functions ---------------

// int32_t ___swbuf(void);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: xcode
// Detected functions: 2

