// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_31 g_t804AAAC = // 0804AAAC
	{
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
	};
struct Eq_31 * objects = null; // 0804AAC4
word32 _environ = 0x10095590; // 0804AAC8
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw804A59C = ~0x00; // 0804A59C
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> ** g_ptr804A598 = &g_ptr804A5A8; // 0804A598
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804A5A8 = null; // 0804A5A8
// subject_eh_frame.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_25 g_t804A5AC = // 0804A5AC
	{
		
		{
			0x10
		},
		0x00,
		0x7C010001,
		0x04040C08,
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080494A0: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049470: void _init()
// Called from:
//      _start
void _init()
{
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080487E8: void _cleanup()
void _cleanup()
{
}

// 080487F8: void atexit()
void atexit()
{
}

// 08048808: void __fpstart()
void __fpstart()
{
}

// 08048818: void exit()
void exit()
{
}

// 08048828: void printf()
void printf()
{
}

// 08048838: void malloc()
void malloc()
{
}

// 08048848: void free()
void free()
{
}

// 08048858: void abort()
void abort()
{
}

// 08048868: void memset()
void memset()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _lib_version = 0x01; // 080494B4
char g_str80494B8[] = "Fifty five is %d\n"; // 080494B8
<unknown> g_t80494CA = // 080494CA;
<unknown> g_t80494CB = // 080494CB;
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048878: void _start(Register word32 edx, Stack word32 dwArg00)
void _start(word32 edx, word32 dwArg00)
{
	atexit(&g_t80487E8);
}

// 080488E7: void _mcount()
void _mcount()
{
}

// 080488E8: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	while (true)
	{
		<anonymous> ** eax_16 = g_ptr804A598;
		if (*eax_16 == null)
			break;
		g_ptr804A598 = (<anonymous> **) ((char *) eax_16 + 4);
		(*eax_16)();
	}
	__deregister_frame_info(&g_t804A5AC);
}

// 08048928: void fini_dummy()
void fini_dummy()
{
}

// 08048940: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
	__register_frame_info(&g_t804A5AC, &g_t804AAAC);
}

// 08048968: void init_dummy()
void init_dummy()
{
}

// 08048980: Register word32 add5(Stack word32 dwArg04)
// Called from:
//      main
word32 add5(word32 dwArg04)
{
	return dwArg04 + 0x05;
}

// 08048990: Register word32 add10(Stack word32 dwArg04)
// Called from:
//      main
word32 add10(word32 dwArg04)
{
	return dwArg04 + 0x0A;
}

// 080489A0: Register word32 add15(Stack word32 dwArg04)
// Called from:
//      main
word32 add15(word32 dwArg04)
{
	return dwArg04 + 0x0F;
}

// 080489B0: void printarg(Stack int32 dwArg04)
// Called from:
//      main
void printarg(int32 dwArg04)
{
	printf("Fifty five is %d\n", dwArg04);
}

// 080489C4: Register word32 main()
// Called from:
//      _start
word32 main()
{
	printarg(add5(add10(add15(0x19))));
	return 0x00;
}

// 080489E4: Register word32 decode_uleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
//      execute_cfa_insn
//      __frame_state_for
word32 decode_uleb128(byte * dwArg04, ui32 * dwArg08)
{
	ui32 edi_14 = 0x00;
	word32 esi_18 = 0x00;
	while (true)
	{
		ui32 edx_22 = (word32) *dwArg04;
		++dwArg04;
		edi_14 |= (edx_22 & 0x7F) << (byte) esi_18;
		if ((byte) edx_22 >= 0x00)
			break;
		esi_18 += 0x07;
	}
	*dwArg08 = edi_14;
	return dwArg04 + 1;
}

// 08048A20: Register (ptr32 byte) decode_sleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
byte * decode_sleb128(byte * dwArg04, ui32 * dwArg08)
{
	byte * edi_16 = dwArg04;
	ui32 dwLoc08_76 = 0x00;
	up32 ecx_107 = 0x00;
	do
	{
		byte cl_25 = (byte) ecx_110;
		ui32 esi_21 = (word32) *edi_16;
		ui32 v15_28 = dwLoc08_76 | (esi_21 & 0x7F) << cl_25;
		++edi_16;
		dwLoc08_76 = v15_28;
		ecx_107 = SEQ(SLICE(ecx_110 + 0x07, word24, 8), cl_25 + 0x07);
		ecx_110 = ecx_107;
	} while ((byte) esi_21 < 0x00);
	if (ecx_110 <= 0x18 && (esi_21 & 0x40) != 0x00)
		dwLoc08_76 = v15_28 | ~0x00 << cl_25 + 0x07;
	*dwArg08 = dwLoc08_76;
	return edi_16;
}

// 08048A7C: void fde_insert(Stack (ptr32 Eq_25) dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_25) dwArg0C)
// Called from:
//      add_fdes
void fde_insert(struct Eq_25 * dwArg04, ui32 dwArg08, struct Eq_25 * dwArg0C)
{
	dwArg04[dwArg08] = (struct Eq_25) dwArg0C;
	ui32 edx_15 = dwArg08;
	if (dwArg08 != 0x00)
	{
		word32 * ecx_23 = dwArg04 + dwArg08;
		do
		{
			struct Eq_154 * esi_31 = (dwArg04 - 4)[edx_15];
			struct Eq_158 * edi_26 = *ecx_23;
			if (edi_26->dw0008 >= esi_31->dw0008)
				return;
			*ecx_23 = esi_31;
			(dwArg04 - 4)[edx_15] = edi_26;
			ecx_23 += -1;
			--edx_15;
		} while (edx_15 != 0x00);
	}
}

// 08048AD4: Register word32 count_fdes(Stack (ptr32 Eq_25) dwArg04)
// Called from:
//      frame_init
word32 count_fdes(struct Eq_25 * dwArg04)
{
	struct Eq_25 * edx_12 = dwArg04;
	word32 ecx_18 = 0x00;
	if (dwArg04->t0000.u0 != 0x00)
	{
		do
		{
			if (edx_12[1] != 0x00 && edx_12[2] != 0x00)
				++ecx_18;
			struct Eq_195 * eax_24 = edx_12 + (edx_12->t0000).u0 / 4;
			edx_12 = (struct Eq_25 *) &eax_24->dw0004;
		} while (eax_24->dw0004 != 0x00);
	}
	return ecx_18;
}

// 08048B04: void add_fdes(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_25) dwArg08, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 up32) dwArg10, Stack (ptr32 up32) dwArg14)
// Called from:
//      frame_init
void add_fdes(struct Eq_25 * dwArg04, struct Eq_25 * dwArg08, ui32 * dwArg0C, up32 * dwArg10, up32 * dwArg14)
{
	struct Eq_25 * esi_20 = dwArg04;
	ui32 edi_22 = *dwArg0C;
	up32 dwLoc08_109 = *dwArg10;
	up32 dwLoc0C_111 = *dwArg14;
	if (dwArg04->t0000.u0 != 0x00)
	{
		do
		{
			if (esi_20[1] != 0x00 && esi_20[2] != 0x00)
			{
				fde_insert(dwArg08, edi_22, esi_20);
				++edi_22;
				up32 eax_57 = esi_20[2];
				if (dwLoc08_109 > eax_57)
					dwLoc08_109 = eax_57;
				up32 eax_65 = (word32) esi_20[3].t0000 + eax_57;
				if (dwLoc0C_111 < eax_65)
					dwLoc0C_111 = eax_65;
			}
			struct Eq_251 * eax_73 = esi_20 + (esi_20->t0000).u0 / 4;
			esi_20 = (struct Eq_25 *) &eax_73->dw0004;
		} while (eax_73->dw0004 != 0x00);
	}
	*dwArg0C = edi_22;
	*dwArg10 = dwLoc08_109;
	*dwArg14 = dwLoc0C_111;
}

// 08048B94: void frame_init(Stack (ptr32 Eq_31) dwArg04)
// Called from:
//      find_fde
void frame_init(struct Eq_31 * dwArg04)
{
	Eq_290 tLoc10;
	Eq_291 tLoc0C;
	Eq_292 tLoc08;
	struct Eq_25 * eax_21 = dwArg04->ptr000C;
	if (eax_21 != null)
	{
		tLoc10 = (Eq_290) 0x00;
		struct Eq_25 * esi_40 = eax_21;
		if (eax_21->t0000.u0 != 0x00)
		{
			do
			{
				tLoc10 = (Eq_290) ((word32) tLoc10 + count_fdes((esi_40->t0000).u0));
				++esi_40;
			} while (esi_40->t0000.u0 != 0x00);
		}
	}
	else
		tLoc10 = (Eq_290) count_fdes(dwArg04->ptr0008);
	uint32 eax_66 = tLoc10;
	dwArg04->dw0010 = eax_66;
	struct Eq_25 * eax_73 = malloc(eax_66 << 0x02);
	tLoc0C = (Eq_291) ~0x00;
	tLoc08 = (Eq_292) 0x00;
	tLoc10 = (Eq_290) 0x00;
	struct Eq_25 * eax_81 = dwArg04->ptr000C;
	if (eax_81 != null)
	{
		struct Eq_25 * esi_108 = eax_81;
		if (eax_81->t0000.u0 != 0x00)
		{
			up32 * dwLoc14_179 = &tLoc08;
			do
			{
				add_fdes(esi_108->t0000.u0, eax_73, &tLoc10, &tLoc0C, dwLoc14_179);
				++esi_108;
			} while (esi_108->t0000.u0 != 0x00);
		}
	}
	else
		add_fdes(dwArg04->ptr0008, eax_73, &tLoc10, &tLoc0C, &tLoc08);
	dwArg04->ptr000C = eax_73;
	dwArg04->dw0000 = (up32) tLoc0C;
	dwArg04->dw0004 = (up32) tLoc08;
}

// 08048C80: Register (ptr32 Eq_425) find_fde(Stack up32 dwArg04)
// Called from:
//      __frame_state_for
struct Eq_425 * find_fde(up32 dwArg04)
{
	struct Eq_425 * eax_168;
	struct Eq_31 * esi_20 = objects;
	if (esi_20 != null)
	{
		do
		{
			if (esi_20->dw0000 == 0x00)
				frame_init(esi_20);
			if (esi_20->dw0000 <= dwArg04 && esi_20->dw0004 > dwArg04)
				break;
			esi_20 = esi_20->ptr0014;
		} while (esi_20 != null);
		if (esi_20 != null)
		{
			uint32 ecx_65 = esi_20->dw0010;
			uint32 edi_63 = 0x00;
			uint32 dwLoc08_124 = ecx_65;
			if (ecx_65 > 0x00)
			{
				struct Eq_25 * esi_71 = esi_20->ptr000C;
				do
				{
					uint32 eax_76 = dwLoc08_124 + edi_63;
					struct Eq_425 * ecx_80 = esi_71[eax_76 >> 0x01];
					up32 eax_82 = ecx_80->dw0008;
					if (dwArg04 < eax_82)
						dwLoc08_124 = eax_76 >> 0x01;
					else
					{
						if (dwArg04 <= eax_82 + ecx_80->dw000C)
						{
							eax_168 = ecx_80;
							return eax_168;
						}
						edi_63 = (eax_76 >> 0x01) + 1;
					}
				} while (dwLoc08_124 > edi_63);
			}
		}
	}
	eax_168 = null;
	return eax_168;
}

// 08048D20: Register ptr32 extract_cie_info(Stack (ptr32 Eq_494) dwArg04, Stack (ptr32 Eq_495) dwArg08)
// Called from:
//      __frame_state_for
ptr32 extract_cie_info(struct Eq_494 * dwArg04, struct Eq_495 * dwArg08)
{
	Eq_496 tLoc08;
	ptr32 eax_160;
	struct Eq_498 * edx_23 = dwArg04 - (dwArg04->dw0004 + ~0x03);
	dwArg08->ptr0000 = &edx_23->b0009;
	if (memcmp(&edx_23->b0009, &g_t80494CA, 0x01) != 0x00 && (memcmp(&edx_23->b0009, &g_t80494CB, 0x03) != 0x00 && edx_23->b0009 != 122))
		eax_160 = 0x00;
	else
	{
		char * eax_60 = dwArg08->ptr0000;
		struct Eq_525 * eax_70 = eax_60 - 1 + (strlen(eax_60) - ~0x00);
		byte * edx_108 = &eax_70->dw0001;
		if (memcmp(eax_60, &g_t80494CB, 0x03) == 0x00)
		{
			dwArg08->dw0004 = eax_70->dw0001;
			edx_108 = (byte *) (&eax_70->dw0001 + 1);
		}
		else
			dwArg08->dw0004 = 0x00;
		byte * eax_126 = decode_sleb128(decode_uleb128(edx_108, &dwArg08->dw0004 + 1), &dwArg08->dw0004 + 2);
		dwArg08->dw0010 = (word32) *eax_126;
		ptr32 edx_138 = eax_126 + 1;
		if (*dwArg08->ptr0000 == 122)
			edx_138 = decode_uleb128(eax_126 + 1, &tLoc08) + Mem147[&tLoc08 + 0x00:word32];
		eax_160 = edx_138;
	}
	return eax_160;
}

// 08048E38: Register (ptr32 byte) execute_cfa_insn(Stack (ptr32 byte) dwArg04, Stack Eq_616 dwArg08, Stack (ptr32 Eq_617) dwArg0C, Stack (ptr32 word32) dwArg10, Register out (ptr32 Eq_619) ebpOut, Register out (ptr32 Eq_617) ediOut)
// Called from:
//      __frame_state_for
byte * execute_cfa_insn(byte * dwArg04, Eq_616 dwArg08, struct Eq_617 * dwArg0C, word32 * dwArg10, struct Eq_619 & ebpOut, struct Eq_617 & ediOut)
{
	ptr32 fp;
	struct Eq_619 * ebp;
	struct Eq_617 * edi;
	Eq_624 tLoc08;
	uint32 eax_23 = (word32) *dwArg04;
	ci8 al_33 = (byte) eax_23;
	byte * dwArg04_116 = dwArg04 + 1;
	byte bLoc14_119 = (byte) eax_23 & 0x40;
	if ((eax_23 & 0x40) != 0x00)
		*dwArg10 += (eax_23 & 0x3F) *s dwArg0C->dw0008;
	else if (al_33 < 0x00)
	{
		dwArg04_116 = decode_uleb128(dwArg04 + 1, &tLoc08);
		tLoc08 = (Eq_624) (tLoc08 *s dwArg0C->dw000C);
		*((word32) dwArg08.u0 + ((word32) (eax_23 & 0x3F) + 92)) = 0x01;
		Mem90[(eax_23 & 0x3F) * 0x04 + 16 + dwArg08:word32] = Mem86[&tLoc08 + 0x00:word32];
	}
	else
	{
		if ((al_33 & 0xC0) == 0x00)
		{
			if (eax_23 > 0x2E)
				abort();
			else
			{
				<anonymous> * ecx_46 = 0x0804A4D0 - g_a8048EF8[eax_23 * 0x04];
				byte * eax_50;
				ecx_46();
				ebpOut = fp - 4;
				ediOut = dwArg0C;
				return eax_50;
			}
		}
		Mem59[(eax_23 & 0x3F) + 92 + dwArg08:byte] = bLoc14_119;
	}
	ebpOut = ebp;
	ediOut = edi;
	return dwArg04_116;
}

ui32 g_a8048EF8[] = // 08048EF8
	{
	};
// 080491C8: void __register_frame_info(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_31) dwArg08)
// Called from:
//      frame_dummy
void __register_frame_info(struct Eq_25 * dwArg04, struct Eq_31 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->ptr000C = null;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 08049210: void __register_frame_info_table(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_31) dwArg08)
void __register_frame_info_table(struct Eq_25 * dwArg04, struct Eq_31 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->ptr000C = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 08049254: void __deregister_frame_info(Stack (ptr32 Eq_25) dwArg04)
// Called from:
//      __do_global_dtors_aux
void __deregister_frame_info(struct Eq_25 * dwArg04)
{
	struct Eq_429 * ecx_14 = &objects;
	if (objects != null)
	{
		do
		{
			struct Eq_773 * edx_19 = ecx_14->ptr0000;
			if (edx_19->ptr0008 == dwArg04)
			{
				ecx_14->ptr0000 = (struct Eq_1070 *) edx_19->ptr0014;
				if (edx_19->dw0000 != 0x00)
					free(edx_19->ptr000C);
				return;
			}
			ecx_14 = (struct Eq_429 *) &edx_19->ptr0014;
		} while (edx_19->ptr0014 != null);
	}
	abort();
}

// 080492AC: void __frame_state_for(Stack up32 dwArg04)
void __frame_state_for(up32 dwArg04)
{
	ptr32 fp;
	word32 dwLoc8C;
	Eq_809 tLoc18;
	struct Eq_810 * ebp_102 = fp - 4;
	struct Eq_494 * eax_24 = find_fde(dwArg04);
	if (eax_24 != null)
	{
		byte * eax_45 = extract_cie_info(eax_24, &tLoc18);
		byte * esi_114 = eax_45;
		if (eax_45 != null)
		{
			memset(&dwLoc8C, 0x00, 116);
			up32 * ecx_78 = eax_24 - (eax_24->dw0004 + ~0x03);
			ptr32 esp_115 = fp - 0xB8;
			if (eax_45 < (ecx_78 + *ecx_78) + 1)
			{
				do
				{
					struct Eq_868 * esp_89 = esp_115 - 4;
					esp_89->ptr0000 = null;
					esp_89->ptrFFFFFFFC = ebp_102->ptrFFFFFF60;
					esp_89->tFFFFFFF8.u0 = ebp_102->tFFFFFF5C.u0;
					esp_89->ptrFFFFFFF4 = esi_114;
					byte * edi_105;
					byte * eax_101 = execute_cfa_insn(esp_89->ptrFFFFFFF4, esp_89->tFFFFFFF8.u0, esp_89->ptrFFFFFFFC, esp_89->ptr0000, out ebp_102, out edi_105);
					word32 esp_108 = <invalid>;
					esi_114 = eax_101;
					esp_115 = esp_108 + 0x10;
				} while (eax_101 < edi_105);
			}
			struct Eq_853 * esi_120 = ebp_102->ptrFFFFFF6C;
			byte * esi_121 = &esi_120->dw0008 + 2;
			if (*ebp_102->ptrFFFFFFEC == 122)
			{
				struct Eq_936 * esp_127 = esp_115 - 4;
				esp_127->ptr0000 = ebp_102 - 0x8C;
				esp_127->ptrFFFFFFFC = (byte *) (&esi_120->dw0008 + 2);
				esi_121 = decode_uleb128(esp_127->ptrFFFFFFFC, esp_127->ptr0000) + ebp_102->dwFFFFFF74;
			}
			struct Eq_853 * eax_145 = ebp_102->ptrFFFFFF6C;
			up32 eax_146 = eax_145 + eax_145->dw0000 / 0x0C;
			ebp_102->dwFFFFFF70 = ebp_102->ptrFFFFFF6C->dw0008;
			ptr32 esp_162 = esp_115;
			if (esi_121 < eax_146 + 4)
			{
				ebp_102->ptrFFFFFF58 = ebp_102 - 0x90;
				while (ebp_102->dwFFFFFF70 <= ebp_102->dw0008)
				{
					struct Eq_977 * esp_163 = esp_162 - 4;
					esp_163->ptr0000 = ebp_102->ptrFFFFFF58;
					esp_163->ptrFFFFFFFC = ebp_102 - 20;
					esp_163->tFFFFFFF8.u0 = (int32) (ebp_102 - 0x88);
					esp_163->ptrFFFFFFF4 = esi_121;
					byte * edi_178;
					byte * eax_174 = execute_cfa_insn(esp_163->ptrFFFFFFF4, esp_163->tFFFFFFF8.u0, esp_163->ptrFFFFFFFC, esp_163->ptr0000, out ebp_102, out edi_178);
					word32 esp_181 = <invalid>;
					esi_121 = eax_174;
					esp_162 = esp_181 + 0x10;
					if (eax_174 >= edi_178)
						break;
				}
			}
			memcpy(ebp_102->ptr000C, ebp_102 - 0x88, 0x70);
		}
	}
}

// 08049418: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> ** esi_17 = &g_dw804A59C;
	if (g_dw804A59C != ~0x00)
	{
		do
		{
			(*esi_17)();
			esi_17 = (<anonymous> **) ((char *) esi_17 - 4);
		} while (*esi_17 != (<anonymous> *) ~0x00);
	}
}

// 0804944C: void init_dummy()
void init_dummy()
{
}

