// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_33 g_t804ACB0 = // 0804ACB0
	{
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
	};
struct Eq_33 * objects = null; // 0804ACC8
word32 _environ = 0x10095998; // 0804ACCC
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> ** g_ptr804A68C = &g_ptr804A69C; // 0804A68C
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw804A698 = ~0x00; // 0804A698
<anonymous> * g_ptr804A69C = null; // 0804A69C
// subject_eh_frame.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_32 g_t804A6A0 = // 0804A6A0
	{
		
		{
			0x10
		},
		0x00,
		0x7C010001,
		0x04040C08,
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049510: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080494E0: Register word32 _init()
// Called from:
//      _start
word32 _init()
{
	word32 edx_5 = frame_dummy();
	__do_global_ctors_aux();
	return edx_5;
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080487A0: void _cleanup()
void _cleanup()
{
}

// 080487B0: void atexit()
void atexit()
{
}

// 080487C0: void __fpstart()
void __fpstart()
{
}

// 080487D0: void exit()
void exit()
{
}

// 080487E0: void scanf()
void scanf()
{
}

// 080487F0: void printf()
void printf()
{
}

// 08048800: void malloc()
void malloc()
{
}

// 08048810: void free()
void free()
{
}

// 08048820: void abort()
void abort()
{
}

// 08048830: void memset()
void memset()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _lib_version = 0x01; // 08049524
char g_str8049528[] = "%d"; // 08049528
char g_str804952B[] = "Equal\n"; // 0804952B
char g_str8049532[] = "Not Equal\n"; // 08049532
char g_str804953D[] = "Greater\n"; // 0804953D
char g_str8049546[] = "Less or Equal\n"; // 08049546
char g_str8049555[] = "Greater or Equal\n"; // 08049555
char g_str8049567[] = "Less\n"; // 08049567
char g_str804956D[] = "Greater Unsigned\n"; // 0804956D
char g_str804957F[] = "Less or Equal Unsigned\n"; // 0804957F
char g_str8049597[] = "Carry Clear\n"; // 08049597
char g_str80495A4[] = "Carry Set\n"; // 080495A4
char g_str80495AF[] = "Minus\n"; // 080495AF
char g_str80495B6[] = "Plus\n"; // 080495B6
byte g_b80495BC = 0x00; // 080495BC
byte g_b80495BD = 101; // 080495BD
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048840: void _start(Register word32 edx, Stack word32 dwArg00)
void _start(word32 edx, word32 dwArg00)
{
	atexit(&g_t80487A0);
}

// 080488AF: void _mcount()
void _mcount()
{
}

// 080488B0: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	while (true)
	{
		<anonymous> ** eax_16 = g_ptr804A68C;
		if (*eax_16 == null)
			break;
		g_ptr804A68C = (<anonymous> **) ((char *) eax_16 + 4);
		(*eax_16)();
	}
	__deregister_frame_info(0x0804A6A0);
}

// 080488F0: void fini_dummy()
void fini_dummy()
{
}

// 08048908: Register word32 frame_dummy()
// Called from:
//      _init
word32 frame_dummy()
{
	return __register_frame_info(&g_t804A6A0, &g_t804ACB0);
}

// 08048930: void init_dummy()
void init_dummy()
{
}

// 08048948: Register word32 main()
// Called from:
//      _start
word32 main()
{
	scanf("%d", fp - 0x08);
	scanf("%d", fp - 0x0C);
	if (dwLoc08 == 0x05)
		printf("Equal\n");
	if (dwLoc08 != 0x05)
	{
		printf("Not Equal\n");
		if (dwLoc08 < 0x05)
		{
			printf("Greater\n");
			if (dwLoc08 < 0x05)
			{
l080489C3:
				printf("Greater or Equal\n");
				if (dwLoc08 <= 0x05)
					goto l080489E2;
l080489D5:
				printf("Less\n");
l080489E2:
				if (dwLoc0C < 0x05)
				{
					printf("Greater Unsigned\n");
					if (dwLoc0C < 0x05)
					{
l08048A0B:
						printf("Carry Clear\n");
						if (dwLoc0C <= 0x05)
							goto l08048A2A;
l08048A1D:
						printf("Carry Set\n");
l08048A2A:
						if (dwLoc08 <= 0x05)
						{
							printf("Minus\n");
							if (dwLoc08 <= 0x05)
								return 0x00;
						}
						printf("Plus\n");
						return 0x00;
					}
				}
				printf("Less or Equal Unsigned\n");
				if (dwLoc0C > 0x05)
					goto l08048A1D;
				goto l08048A0B;
			}
		}
	}
	printf("Less or Equal\n");
	if (dwLoc08 > 0x05)
		goto l080489D5;
	goto l080489C3;
}

// 08048A58: Register word32 decode_uleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
//      execute_cfa_insn
//      __frame_state_for
word32 decode_uleb128(byte * dwArg04, ui32 * dwArg08)
{
	ui32 edi_14 = 0x00;
	word32 esi_17 = 0x00;
	while (true)
	{
		ui32 edx_21 = (word32) *dwArg04;
		++dwArg04;
		edi_14 |= (edx_21 & 0x7F) << (byte) esi_17;
		if ((byte) edx_21 >= 0x00)
			break;
		esi_17 += 0x07;
	}
	*dwArg08 = edi_14;
	return dwArg04 + 1;
}

// 08048A94: Register (ptr32 byte) decode_sleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
byte * decode_sleb128(byte * dwArg04, ui32 * dwArg08)
{
	byte * edi_16 = dwArg04;
	ui32 dwLoc08_72 = 0x00;
	up32 ecx_102 = 0x00;
	do
	{
		byte cl_25 = (byte) ecx_105;
		ui32 esi_21 = (word32) *edi_16;
		ui32 v12_28 = dwLoc08_72 | (esi_21 & 0x7F) << cl_25;
		++edi_16;
		dwLoc08_72 = v12_28;
		ecx_102 = SEQ(SLICE(ecx_105 + 0x07, word24, 8), cl_25 + 0x07);
		ecx_105 = ecx_102;
	} while ((byte) esi_21 < 0x00);
	if (ecx_105 <= 0x18 && (esi_21 & 0x40) != 0x00)
		dwLoc08_72 = v12_28 | ~0x00 << cl_25 + 0x07;
	*dwArg08 = dwLoc08_72;
	return edi_16;
}

// 08048AF0: void fde_insert(Stack (ptr32 Eq_32) dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_32) dwArg0C)
// Called from:
//      add_fdes
void fde_insert(struct Eq_32 * dwArg04, ui32 dwArg08, struct Eq_32 * dwArg0C)
{
	dwArg04[dwArg08] = (struct Eq_32) dwArg0C;
	ui32 edx_15 = dwArg08;
	if (dwArg08 != 0x00)
	{
		word32 * ecx_22 = dwArg04 + dwArg08;
		do
		{
			struct Eq_216 * esi_30 = (dwArg04 - 0x04)[edx_15];
			struct Eq_220 * edi_25 = *ecx_22;
			if (edi_25->dw0008 - esi_30->dw0008 >= 0x00)
				return;
			*ecx_22 = esi_30;
			(dwArg04 - 0x04)[edx_15] = edi_25;
			ecx_22 += -1;
			--edx_15;
		} while (edx_15 != 0x00);
	}
}

// 08048B48: Register word32 count_fdes(Stack (ptr32 Eq_32) dwArg04)
// Called from:
//      frame_init
word32 count_fdes(struct Eq_32 * dwArg04)
{
	struct Eq_32 * edx_12 = dwArg04;
	word32 ecx_18 = 0x00;
	if (dwArg04->t0000 != 0x00)
	{
		do
		{
			if (edx_12[1] != 0x00 && edx_12[2] != 0x00)
				++ecx_18;
			word32 eax_24 = edx_12 + Mem6[edx_12 + 0x00:word32];
			edx_12 = (struct Eq_32 *) &eax_24->dw0004;
		} while (eax_24->dw0004 != 0x00);
	}
	return ecx_18;
}

// 08048B78: void add_fdes(Stack (ptr32 Eq_32) dwArg04, Stack (ptr32 Eq_32) dwArg08, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 up32) dwArg10, Stack (ptr32 up32) dwArg14)
// Called from:
//      frame_init
void add_fdes(struct Eq_32 * dwArg04, struct Eq_32 * dwArg08, ui32 * dwArg0C, up32 * dwArg10, up32 * dwArg14)
{
	struct Eq_32 * esi_20 = dwArg04;
	ui32 edi_22 = *dwArg0C;
	up32 dwLoc08_108 = *dwArg10;
	up32 dwLoc0C_110 = *dwArg14;
	if (dwArg04->t0000 != 0x00)
	{
		do
		{
			if (esi_20[1] != 0x00 && esi_20[2] != 0x00)
			{
				fde_insert(dwArg08, edi_22, esi_20);
				++edi_22;
				up32 eax_56 = esi_20[2];
				if (dwLoc08_108 > eax_56)
					dwLoc08_108 = eax_56;
				up32 eax_64 = (word32) esi_20[3].t0000 + eax_56;
				if (dwLoc0C_110 < eax_64)
					dwLoc0C_110 = eax_64;
			}
			word32 eax_72 = esi_20 + Mem71[esi_20 + 0x00:word32];
			esi_20 = (struct Eq_32 *) &eax_72->dw0004;
		} while (eax_72->dw0004 != 0x00);
	}
	*dwArg0C = edi_22;
	*dwArg10 = dwLoc08_108;
	*dwArg14 = dwLoc0C_110;
}

// 08048C08: void frame_init(Stack (ptr32 Eq_33) dwArg04)
// Called from:
//      find_fde
void frame_init(struct Eq_33 * dwArg04)
{
	uint32 dwLoc10_165;
	struct Eq_32 * eax_21 = dwArg04->ptr000C;
	if (eax_21 != null)
	{
		struct Eq_32 * esi_39 = eax_21;
		dwLoc10_165 = 0x00;
		if (eax_21->t0000 != 0x00)
		{
			do
			{
				dwLoc10_165 += count_fdes(esi_39->t0000);
				++esi_39;
			} while (esi_39->t0000 != 0x00);
		}
	}
	else
		dwLoc10_165 = count_fdes(dwArg04->ptr0008);
	dwArg04->dw0010 = dwLoc10_165;
	struct Eq_32 * eax_72 = malloc(dwLoc10_165 << 0x02);
	struct Eq_32 * eax_80 = dwArg04->ptr000C;
	if (eax_80 != null)
	{
		struct Eq_32 * esi_106 = eax_80;
		if (eax_80->t0000 != 0x00)
		{
			do
			{
				add_fdes(esi_106->t0000, eax_72, fp - 0x10, fp - 0x0C, fp - 0x08);
				++esi_106;
			} while (esi_106->t0000 != 0x00);
		}
	}
	else
		add_fdes(dwArg04->ptr0008, eax_72, fp - 0x10, fp - 0x0C, fp - 0x08);
	dwArg04->ptr000C = eax_72;
	dwArg04->dw0000 = ~0x00;
	dwArg04->dw0004 = 0x00;
}

// 08048CF4: Register (ptr32 Eq_451) find_fde(Stack up32 dwArg04)
// Called from:
//      __frame_state_for
struct Eq_451 * find_fde(up32 dwArg04)
{
	struct Eq_451 * eax_163;
	struct Eq_33 * esi_20 = objects;
	if (esi_20 != null)
	{
		do
		{
			if (esi_20->dw0000 == 0x00)
				frame_init(esi_20);
			if (esi_20->dw0000 <= dwArg04 && esi_20->dw0004 > dwArg04)
				break;
			esi_20 = esi_20->ptr0014;
		} while (esi_20 != null);
		if (esi_20 != null)
		{
			uint32 ecx_61 = esi_20->dw0010;
			uint32 edi_59 = 0x00;
			uint32 dwLoc08_119 = ecx_61;
			if (ecx_61 > 0x00)
			{
				struct Eq_32 * esi_67 = esi_20->ptr000C;
				do
				{
					uint32 eax_72 = dwLoc08_119 + edi_59;
					struct Eq_451 * ecx_76 = esi_67[eax_72 >> 0x01];
					up32 eax_78 = ecx_76->dw0008;
					if (dwArg04 < eax_78)
						dwLoc08_119 = eax_72 >> 0x01;
					else
					{
						if (dwArg04 <= eax_78 + ecx_76->dw000C)
						{
							eax_163 = ecx_76;
							return eax_163;
						}
						edi_59 = (eax_72 >> 0x01) + 0x01;
					}
				} while (dwLoc08_119 > edi_59);
			}
		}
	}
	eax_163 = null;
	return eax_163;
}

// 08048D94: Register ptr32 extract_cie_info(Stack (ptr32 Eq_520) dwArg04, Stack (ptr32 Eq_521) dwArg08)
// Called from:
//      __frame_state_for
ptr32 extract_cie_info(struct Eq_520 * dwArg04, struct Eq_521 * dwArg08)
{
	struct Eq_522 * edx_23 = dwArg04 - (dwArg04->dw0004 + ~0x03);
	dwArg08->ptr0000 = &edx_23->b0009;
	byte * esi_24 = &edx_23->b0009;
	word32 ecx_31 = 0x01;
	byte * edi_32 = &g_b80495BC;
	bool v19_240 = true;
	while (ecx_31 != 0x00)
	{
		v19_240 = *esi_389 == *edi_390;
		esi_24 = esi_389 + 1;
		edi_32 = edi_390 + 1;
		--ecx_31;
		esi_389 = esi_24;
		edi_390 = edi_32;
		if (*esi_389 == *edi_390)
			break;
	}
	ptr32 eax_222;
	if (!v19_240)
	{
		byte * esi_52 = &edx_23->b0009;
		byte * edi_55 = &g_b80495BD;
		word32 ecx_56 = 0x03;
		bool v23_244 = true;
		while (ecx_56 != 0x00)
		{
			v23_244 = *esi_391 == *edi_392;
			esi_52 = esi_391 + 1;
			edi_55 = edi_392 + 1;
			--ecx_56;
			esi_391 = esi_52;
			edi_392 = edi_55;
			if (*esi_391 == *edi_392)
				break;
		}
		if (!v23_244 && edx_23->b0009 != 122)
		{
			eax_222 = 0x00;
			return eax_222;
		}
	}
	byte * eax_86 = dwArg08->ptr0000;
	byte * edi_100 = eax_86;
	word32 ecx_101 = ~0x00;
	while (ecx_101 != 0x00)
	{
		edi_100 = edi_393 + 1;
		--ecx_101;
		edi_393 = edi_100;
		if (*edi_393 != 0x00)
			break;
	}
	struct Eq_612 * eax_110 = eax_86 - 0x01 + ~ecx_101;
	byte * edx_113 = &eax_110->dw0001;
	byte * esi_114 = eax_86;
	byte * edi_121 = &g_b80495BD;
	word32 ecx_123 = 0x03;
	bool v27_248 = false;
	while (ecx_123 != 0x00)
	{
		v27_248 = *esi_394 != *edi_395;
		esi_114 = esi_394 + 1;
		edi_121 = edi_395 + 1;
		--ecx_123;
		esi_394 = esi_114;
		edi_395 = edi_121;
		if (*esi_394 == *edi_395)
			break;
	}
	if (!v27_248)
	{
		dwArg08->dw0004 = eax_110->dw0001;
		edx_113 = (byte *) (&eax_110->dw0001 + 1);
	}
	else
		dwArg08->dw0004 = 0x00;
	byte * eax_190 = decode_sleb128(decode_uleb128(edx_113, &dwArg08->dw0004 + 1), &dwArg08->dw0004 + 2);
	dwArg08->dw0010 = (word32) *eax_190;
	ptr32 edx_201 = eax_190 + 1;
	if (*dwArg08->ptr0000 == 122)
		edx_201 = decode_uleb128(eax_190 + 1, fp - 0x08) + dwLoc08;
	eax_222 = edx_201;
	return eax_222;
}

// 08048EAC: Register (ptr32 byte) execute_cfa_insn(Stack (ptr32 byte) dwArg04, Stack Eq_714 dwArg08, Stack (ptr32 Eq_715) dwArg0C, Stack (ptr32 word32) dwArg10, Register out (ptr32 Eq_717) ebpOut, Register out (ptr32 Eq_715) ediOut)
// Called from:
//      __frame_state_for
byte * execute_cfa_insn(byte * dwArg04, Eq_714 dwArg08, struct Eq_715 * dwArg0C, word32 * dwArg10, struct Eq_717 & ebpOut, struct Eq_715 & ediOut)
{
	uint32 eax_23 = (word32) *dwArg04;
	ci8 al_32 = (byte) eax_23;
	byte * dwArg04_108 = dwArg04 + 1;
	byte bLoc14_111 = (byte) eax_23 & 0x40;
	if ((eax_23 & 0x40) != 0x00)
		*dwArg10 += (eax_23 & 0x3F) *s dwArg0C->dw0008;
	else if (al_32 < 0x00)
	{
		dwArg04_108 = decode_uleb128(dwArg04 + 1, fp - 0x08);
		int32 eax_74 = dwLoc08 *s dwArg0C->dw000C;
		*((word32) dwArg08.u0 + ((word32) (eax_23 & 0x3F) + 92)) = 0x01;
		Mem83[(eax_23 & 0x3F) * 0x04 + 0x10 + dwArg08:word32] = eax_74;
	}
	else
	{
		if ((al_32 & 0xC0) == 0x00)
		{
			if (eax_23 > 0x2E)
				abort();
			else
			{
				<anonymous> * ecx_42 = 0x0804A5C0 - g_a8048F6C[eax_23 * 0x04];
				byte * eax_46;
				ecx_42();
				ebpOut = fp - 4;
				ediOut = dwArg0C;
				return eax_46;
			}
		}
		Mem54[(eax_23 & 0x3F) + 0x5C + dwArg08:byte] = bLoc14_111;
	}
	ebpOut = ebp;
	ediOut = edi;
	return dwArg04_108;
}

ui32 g_a8048F6C[] = // 08048F6C
	{
	};
// 0804923C: Register (ptr32 Eq_33) __register_frame_info(Stack (ptr32 Eq_32) dwArg04, Stack (ptr32 Eq_33) dwArg08)
// Called from:
//      frame_dummy
struct Eq_33 * __register_frame_info(struct Eq_32 * dwArg04, struct Eq_33 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->ptr000C = null;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
	return dwArg08;
}

// 08049284: void __register_frame_info_table(Stack (ptr32 Eq_32) dwArg04, Stack (ptr32 Eq_33) dwArg08)
void __register_frame_info_table(struct Eq_32 * dwArg04, struct Eq_33 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->ptr000C = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 080492C8: void __deregister_frame_info(Stack ptr32 dwArg04)
// Called from:
//      __do_global_dtors_aux
void __deregister_frame_info(ptr32 dwArg04)
{
	struct Eq_859 * ecx_14 = &objects;
	if (objects != null)
	{
		do
		{
			struct Eq_867 * edx_19 = ecx_14->dw0000;
			if (edx_19->ptr0008 == dwArg04)
			{
				ecx_14->dw0000 = edx_19->dw0014;
				if (edx_19->dw0000 != 0x00)
					free(edx_19->ptr000C);
				return;
			}
			ecx_14 = (struct Eq_859 *) &edx_19->dw0014;
		} while (edx_19->dw0014 != 0x00);
	}
	abort();
}

// 08049320: void __frame_state_for(Stack up32 dwArg04)
void __frame_state_for(up32 dwArg04)
{
	struct Eq_901 * ebp_113 = fp - 4;
	struct Eq_520 * eax_24 = find_fde(dwArg04);
	if (eax_24 != null)
	{
		byte * eax_43 = extract_cie_info(eax_24, fp - 0x18);
		byte * esi_109 = eax_43;
		if (eax_43 != null)
		{
			memset(fp - 0x8C, 0x00, 116);
			up32 * ecx_74 = eax_24 - (eax_24->dw0004 + ~0x03);
			ptr32 esp_110 = fp - 0xB8;
			if (eax_43 < (ecx_74 + *ecx_74) + 1)
			{
				do
				{
					struct Eq_962 * esp_85 = esp_110 - 4;
					esp_85->ptr0000 = null;
					esp_85->ptrFFFFFFFC = ebp_113->ptrFFFFFF60;
					esp_85->tFFFFFFF8 = ebp_113->tFFFFFF5C;
					esp_85->ptrFFFFFFF4 = esi_109;
					byte * edi_101;
					byte * eax_97 = execute_cfa_insn(esp_85->ptrFFFFFFF4, esp_85->tFFFFFFF8, esp_85->ptrFFFFFFFC, esp_85->ptr0000, out ebp_113, out edi_101);
					word32 esp_104 = <invalid>;
					esi_109 = eax_97;
					esp_110 = esp_104 + 0x10;
				} while (eax_97 < edi_101);
			}
			struct Eq_947 * esi_115 = ebp_113->ptrFFFFFF6C;
			byte * esi_116 = &esi_115->dw0008 + 2;
			if (*ebp_113->ptrFFFFFFEC == 122)
			{
				struct Eq_1030 * esp_122 = esp_110 - 4;
				esp_122->ptr0000 = ebp_113 - 0x8C;
				esp_122->ptrFFFFFFFC = (byte *) (&esi_115->dw0008 + 2);
				esi_116 = decode_uleb128(esp_122->ptrFFFFFFFC, esp_122->ptr0000) + ebp_113->dwFFFFFF74;
			}
			struct Eq_947 * eax_139 = ebp_113->ptrFFFFFF6C;
			up32 eax_140 = eax_139 + eax_139->dw0000 / 0x0C;
			ebp_113->dwFFFFFF70 = ebp_113->ptrFFFFFF6C->dw0008;
			ptr32 esp_156 = esp_110;
			if (esi_116 < eax_140 + 0x04)
			{
				ebp_113->ptrFFFFFF58 = ebp_113 - 0x90;
				while (ebp_113->dwFFFFFF70 <= ebp_113->dw0008)
				{
					struct Eq_1068 * esp_157 = esp_156 - 4;
					esp_157->ptr0000 = ebp_113->ptrFFFFFF58;
					esp_157->ptrFFFFFFFC = ebp_113 - 0x14;
					esp_157->tFFFFFFF8 = ebp_113 - 0x88;
					esp_157->ptrFFFFFFF4 = esi_116;
					byte * edi_172;
					byte * eax_168 = execute_cfa_insn(esp_157->ptrFFFFFFF4, esp_157->tFFFFFFF8, esp_157->ptrFFFFFFFC, esp_157->ptr0000, out ebp_113, out edi_172);
					word32 esp_175 = <invalid>;
					esi_116 = eax_168;
					esp_156 = esp_175 + 0x10;
					if (eax_168 >= edi_172)
						break;
				}
			}
			word32 * edi_186 = ebp_113->ptr000C;
			word32 * esi_187 = ebp_113 - 0x88;
			word32 ecx_189;
			for (ecx_189 = 0x1C; ecx_189 != 0x00; --ecx_189)
			{
				*edi_186 = *esi_187;
				++esi_187;
				++edi_186;
			}
		}
	}
}

// 0804948C: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> ** esi_17 = &g_dw804A698;
	if (g_dw804A698 != ~0x00)
	{
		do
		{
			(*esi_17)();
			esi_17 = (<anonymous> **) ((char *) esi_17 - 4);
		} while (*esi_17 != (<anonymous> *) ~0x00);
	}
}

// 080494C0: void init_dummy()
void init_dummy()
{
}

