// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_31 g_t804ACB0 = // 0804ACB0
	{
		0x00,
		0x00,
		null,
		null,
		0x00,
		null,
	};
struct Eq_31 * objects = null; // 0804ACC8
word32 _environ = 0x10095998; // 0804ACCC
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw804A690 = ~0x00; // 0804A690
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> ** g_ptr804A68C = &g_ptr804A69C; // 0804A68C
// subject_dtors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr804A69C = null; // 0804A69C
// subject_eh_frame.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_25 g_t804A6A0 = // 0804A6A0
	{
		
		{
			0x10
		},
		0x00,
		0x7C010001,
		0x04040C08,
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049510: void _fini()
void _fini()
{
	__do_global_dtors_aux();
}

// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080494E0: void _init()
// Called from:
//      _start
void _init()
{
	frame_dummy();
	__do_global_ctors_aux();
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080487A0: void _cleanup()
void _cleanup()
{
}

// 080487B0: void atexit()
void atexit()
{
}

// 080487C0: void __fpstart()
void __fpstart()
{
}

// 080487D0: void exit()
void exit()
{
}

// 080487E0: void scanf()
void scanf()
{
}

// 080487F0: void printf()
void printf()
{
}

// 08048800: void malloc()
void malloc()
{
}

// 08048810: void free()
void free()
{
}

// 08048820: void abort()
void abort()
{
}

// 08048830: void memset()
void memset()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _lib_version = 0x01; // 08049524
char g_str8049528[] = "%d"; // 08049528
char g_str804952B[] = "Equal\n"; // 0804952B
char g_str8049532[] = "Not Equal\n"; // 08049532
char g_str804953D[] = "Greater\n"; // 0804953D
char g_str8049546[] = "Less or Equal\n"; // 08049546
char g_str8049555[] = "Greater or Equal\n"; // 08049555
char g_str8049567[] = "Less\n"; // 08049567
char g_str804956D[] = "Greater Unsigned\n"; // 0804956D
char g_str804957F[] = "Less or Equal Unsigned\n"; // 0804957F
char g_str8049597[] = "Carry Clear\n"; // 08049597
char g_str80495A4[] = "Carry Set\n"; // 080495A4
char g_str80495AF[] = "Minus\n"; // 080495AF
char g_str80495B6[] = "Plus\n"; // 080495B6
<unknown> g_t80495BC = // 080495BC;
<unknown> g_t80495BD = // 080495BD;
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08048840: void _start(Register word32 edx, Stack word32 dwArg00)
void _start(word32 edx, word32 dwArg00)
{
	atexit(&g_t80487A0);
}

// 080488AF: void _mcount()
void _mcount()
{
}

// 080488B0: void __do_global_dtors_aux()
// Called from:
//      _fini
void __do_global_dtors_aux()
{
	while (true)
	{
		<anonymous> ** eax_16 = g_ptr804A68C;
		if (*eax_16 == null)
			break;
		g_ptr804A68C = (<anonymous> **) ((char *) eax_16 + 4);
		(*eax_16)();
	}
	__deregister_frame_info(&g_t804A6A0);
}

// 080488F0: void fini_dummy()
void fini_dummy()
{
}

// 08048908: void frame_dummy()
// Called from:
//      _init
void frame_dummy()
{
	__register_frame_info(&g_t804A6A0, &g_t804ACB0);
}

// 08048930: void init_dummy()
void init_dummy()
{
}

// 08048948: Register word32 main()
// Called from:
//      _start
word32 main()
{
	int32 dwLoc0C;
	int32 dwLoc08;
	scanf("%d", &dwLoc08);
	scanf("%d", &dwLoc0C);
	if (dwLoc08 == 0x05)
		printf("Equal\n");
	if (dwLoc08 != 0x05)
	{
		printf("Not Equal\n");
		if (dwLoc08 < 0x05)
		{
			printf("Greater\n");
			if (dwLoc08 < 0x05)
			{
l080489C3:
				printf("Greater or Equal\n");
				if (dwLoc08 <= 0x05)
					goto l080489E2;
l080489D5:
				printf("Less\n");
l080489E2:
				if (dwLoc0C < 0x05)
				{
					printf("Greater Unsigned\n");
					if (dwLoc0C < 0x05)
					{
l08048A0B:
						printf("Carry Clear\n");
						if (dwLoc0C <= 0x05)
							goto l08048A2A;
l08048A1D:
						printf("Carry Set\n");
l08048A2A:
						if (dwLoc08 <= 0x05)
						{
							printf("Minus\n");
							if (dwLoc08 <= 0x05)
								return 0x00;
						}
						printf("Plus\n");
						return 0x00;
					}
				}
				printf("Less or Equal Unsigned\n");
				if (dwLoc0C > 0x05)
					goto l08048A1D;
				goto l08048A0B;
			}
		}
	}
	printf("Less or Equal\n");
	if (dwLoc08 > 0x05)
		goto l080489D5;
	goto l080489C3;
}

// 08048A58: Register word32 decode_uleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
//      execute_cfa_insn
//      __frame_state_for
word32 decode_uleb128(byte * dwArg04, ui32 * dwArg08)
{
	ui32 edi_14 = 0x00;
	word32 esi_18 = 0x00;
	while (true)
	{
		ui32 edx_22 = (word32) *dwArg04;
		++dwArg04;
		edi_14 |= (edx_22 & 0x7F) << (byte) esi_18;
		if ((byte) edx_22 >= 0x00)
			break;
		esi_18 += 0x07;
	}
	*dwArg08 = edi_14;
	return dwArg04 + 1;
}

// 08048A94: Register (ptr32 byte) decode_sleb128(Stack (ptr32 byte) dwArg04, Stack (ptr32 ui32) dwArg08)
// Called from:
//      extract_cie_info
byte * decode_sleb128(byte * dwArg04, ui32 * dwArg08)
{
	byte * edi_16 = dwArg04;
	ui32 dwLoc08_76 = 0x00;
	up32 ecx_107 = 0x00;
	do
	{
		byte cl_25 = (byte) ecx_110;
		ui32 esi_21 = (word32) *edi_16;
		ui32 v15_28 = dwLoc08_76 | (esi_21 & 0x7F) << cl_25;
		++edi_16;
		dwLoc08_76 = v15_28;
		ecx_107 = SEQ(SLICE(ecx_110 + 0x07, word24, 8), cl_25 + 0x07);
		ecx_110 = ecx_107;
	} while ((byte) esi_21 < 0x00);
	if (ecx_110 <= 0x18 && (esi_21 & 0x40) != 0x00)
		dwLoc08_76 = v15_28 | ~0x00 << cl_25 + 0x07;
	*dwArg08 = dwLoc08_76;
	return edi_16;
}

// 08048AF0: void fde_insert(Stack (ptr32 Eq_25) dwArg04, Stack ui32 dwArg08, Stack (ptr32 Eq_25) dwArg0C)
// Called from:
//      add_fdes
void fde_insert(struct Eq_25 * dwArg04, ui32 dwArg08, struct Eq_25 * dwArg0C)
{
	dwArg04[dwArg08] = (struct Eq_25) dwArg0C;
	ui32 edx_15 = dwArg08;
	if (dwArg08 != 0x00)
	{
		word32 * ecx_23 = dwArg04 + dwArg08;
		do
		{
			struct Eq_258 * esi_31 = (dwArg04 - 4)[edx_15];
			struct Eq_262 * edi_26 = *ecx_23;
			if (edi_26->dw0008 >= esi_31->dw0008)
				return;
			*ecx_23 = esi_31;
			(dwArg04 - 4)[edx_15] = edi_26;
			ecx_23 += -1;
			--edx_15;
		} while (edx_15 != 0x00);
	}
}

// 08048B48: Register word32 count_fdes(Stack (ptr32 Eq_25) dwArg04)
// Called from:
//      frame_init
word32 count_fdes(struct Eq_25 * dwArg04)
{
	struct Eq_25 * edx_12 = dwArg04;
	word32 ecx_18 = 0x00;
	if (dwArg04->t0000.u0 != 0x00)
	{
		do
		{
			if (edx_12[1] != 0x00 && edx_12[2] != 0x00)
				++ecx_18;
			struct Eq_299 * eax_24 = edx_12 + (edx_12->t0000).u0 / 4;
			edx_12 = (struct Eq_25 *) &eax_24->dw0004;
		} while (eax_24->dw0004 != 0x00);
	}
	return ecx_18;
}

// 08048B78: void add_fdes(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_25) dwArg08, Stack (ptr32 ui32) dwArg0C, Stack (ptr32 up32) dwArg10, Stack (ptr32 up32) dwArg14)
// Called from:
//      frame_init
void add_fdes(struct Eq_25 * dwArg04, struct Eq_25 * dwArg08, ui32 * dwArg0C, up32 * dwArg10, up32 * dwArg14)
{
	struct Eq_25 * esi_20 = dwArg04;
	ui32 edi_22 = *dwArg0C;
	up32 dwLoc08_109 = *dwArg10;
	up32 dwLoc0C_111 = *dwArg14;
	if (dwArg04->t0000.u0 != 0x00)
	{
		do
		{
			if (esi_20[1] != 0x00 && esi_20[2] != 0x00)
			{
				fde_insert(dwArg08, edi_22, esi_20);
				++edi_22;
				up32 eax_57 = esi_20[2];
				if (dwLoc08_109 > eax_57)
					dwLoc08_109 = eax_57;
				up32 eax_65 = (word32) esi_20[3].t0000 + eax_57;
				if (dwLoc0C_111 < eax_65)
					dwLoc0C_111 = eax_65;
			}
			struct Eq_355 * eax_73 = esi_20 + (esi_20->t0000).u0 / 4;
			esi_20 = (struct Eq_25 *) &eax_73->dw0004;
		} while (eax_73->dw0004 != 0x00);
	}
	*dwArg0C = edi_22;
	*dwArg10 = dwLoc08_109;
	*dwArg14 = dwLoc0C_111;
}

// 08048C08: void frame_init(Stack (ptr32 Eq_31) dwArg04)
// Called from:
//      find_fde
void frame_init(struct Eq_31 * dwArg04)
{
	Eq_394 tLoc10;
	Eq_395 tLoc0C;
	Eq_396 tLoc08;
	struct Eq_25 * eax_21 = dwArg04->ptr000C;
	if (eax_21 != null)
	{
		tLoc10 = (Eq_394) 0x00;
		struct Eq_25 * esi_40 = eax_21;
		if (eax_21->t0000.u0 != 0x00)
		{
			do
			{
				tLoc10 = (Eq_394) ((word32) tLoc10 + count_fdes((esi_40->t0000).u0));
				++esi_40;
			} while (esi_40->t0000.u0 != 0x00);
		}
	}
	else
		tLoc10 = (Eq_394) count_fdes(dwArg04->ptr0008);
	uint32 eax_66 = tLoc10;
	dwArg04->dw0010 = eax_66;
	struct Eq_25 * eax_73 = malloc(eax_66 << 0x02);
	tLoc0C = (Eq_395) ~0x00;
	tLoc08 = (Eq_396) 0x00;
	tLoc10 = (Eq_394) 0x00;
	struct Eq_25 * eax_81 = dwArg04->ptr000C;
	if (eax_81 != null)
	{
		struct Eq_25 * esi_108 = eax_81;
		if (eax_81->t0000.u0 != 0x00)
		{
			up32 * dwLoc14_179 = &tLoc08;
			do
			{
				add_fdes(esi_108->t0000.u0, eax_73, &tLoc10, &tLoc0C, dwLoc14_179);
				++esi_108;
			} while (esi_108->t0000.u0 != 0x00);
		}
	}
	else
		add_fdes(dwArg04->ptr0008, eax_73, &tLoc10, &tLoc0C, &tLoc08);
	dwArg04->ptr000C = eax_73;
	dwArg04->dw0000 = (up32) tLoc0C;
	dwArg04->dw0004 = (up32) tLoc08;
}

// 08048CF4: Register (ptr32 Eq_529) find_fde(Stack up32 dwArg04)
// Called from:
//      __frame_state_for
struct Eq_529 * find_fde(up32 dwArg04)
{
	struct Eq_529 * eax_168;
	struct Eq_31 * esi_20 = objects;
	if (esi_20 != null)
	{
		do
		{
			if (esi_20->dw0000 == 0x00)
				frame_init(esi_20);
			if (esi_20->dw0000 <= dwArg04 && esi_20->dw0004 > dwArg04)
				break;
			esi_20 = esi_20->ptr0014;
		} while (esi_20 != null);
		if (esi_20 != null)
		{
			uint32 ecx_65 = esi_20->dw0010;
			uint32 edi_63 = 0x00;
			uint32 dwLoc08_124 = ecx_65;
			if (ecx_65 > 0x00)
			{
				struct Eq_25 * esi_71 = esi_20->ptr000C;
				do
				{
					uint32 eax_76 = dwLoc08_124 + edi_63;
					struct Eq_529 * ecx_80 = esi_71[eax_76 >> 0x01];
					up32 eax_82 = ecx_80->dw0008;
					if (dwArg04 < eax_82)
						dwLoc08_124 = eax_76 >> 0x01;
					else
					{
						if (dwArg04 <= eax_82 + ecx_80->dw000C)
						{
							eax_168 = ecx_80;
							return eax_168;
						}
						edi_63 = (eax_76 >> 0x01) + 1;
					}
				} while (dwLoc08_124 > edi_63);
			}
		}
	}
	eax_168 = null;
	return eax_168;
}

// 08048D94: Register ptr32 extract_cie_info(Stack (ptr32 Eq_598) dwArg04, Stack (ptr32 Eq_599) dwArg08)
// Called from:
//      __frame_state_for
ptr32 extract_cie_info(struct Eq_598 * dwArg04, struct Eq_599 * dwArg08)
{
	Eq_600 tLoc08;
	ptr32 eax_160;
	struct Eq_602 * edx_23 = dwArg04 - (dwArg04->dw0004 + ~0x03);
	dwArg08->ptr0000 = &edx_23->b0009;
	if (memcmp(&edx_23->b0009, &g_t80495BC, 0x01) != 0x00 && (memcmp(&edx_23->b0009, &g_t80495BD, 0x03) != 0x00 && edx_23->b0009 != 122))
		eax_160 = 0x00;
	else
	{
		char * eax_60 = dwArg08->ptr0000;
		struct Eq_629 * eax_70 = eax_60 - 1 + (strlen(eax_60) - ~0x00);
		byte * edx_108 = &eax_70->dw0001;
		if (memcmp(eax_60, &g_t80495BD, 0x03) == 0x00)
		{
			dwArg08->dw0004 = eax_70->dw0001;
			edx_108 = (byte *) (&eax_70->dw0001 + 1);
		}
		else
			dwArg08->dw0004 = 0x00;
		byte * eax_126 = decode_sleb128(decode_uleb128(edx_108, &dwArg08->dw0004 + 1), &dwArg08->dw0004 + 2);
		dwArg08->dw0010 = (word32) *eax_126;
		ptr32 edx_138 = eax_126 + 1;
		if (*dwArg08->ptr0000 == 122)
			edx_138 = decode_uleb128(eax_126 + 1, &tLoc08) + Mem147[&tLoc08 + 0x00:word32];
		eax_160 = edx_138;
	}
	return eax_160;
}

// 08048EAC: Register (ptr32 byte) execute_cfa_insn(Stack (ptr32 byte) dwArg04, Stack Eq_720 dwArg08, Stack (ptr32 Eq_721) dwArg0C, Stack (ptr32 word32) dwArg10, Register out (ptr32 Eq_723) ebpOut, Register out (ptr32 Eq_721) ediOut)
// Called from:
//      __frame_state_for
byte * execute_cfa_insn(byte * dwArg04, Eq_720 dwArg08, struct Eq_721 * dwArg0C, word32 * dwArg10, struct Eq_723 & ebpOut, struct Eq_721 & ediOut)
{
	ptr32 fp;
	struct Eq_723 * ebp;
	struct Eq_721 * edi;
	Eq_728 tLoc08;
	uint32 eax_23 = (word32) *dwArg04;
	ci8 al_33 = (byte) eax_23;
	byte * dwArg04_116 = dwArg04 + 1;
	byte bLoc14_119 = (byte) eax_23 & 0x40;
	if ((eax_23 & 0x40) != 0x00)
		*dwArg10 += (eax_23 & 0x3F) *s dwArg0C->dw0008;
	else if (al_33 < 0x00)
	{
		dwArg04_116 = decode_uleb128(dwArg04 + 1, &tLoc08);
		tLoc08 = (Eq_728) (tLoc08 *s dwArg0C->dw000C);
		*((word32) dwArg08.u0 + ((word32) (eax_23 & 0x3F) + 92)) = 0x01;
		Mem90[(eax_23 & 0x3F) * 0x04 + 16 + dwArg08:word32] = Mem86[&tLoc08 + 0x00:word32];
	}
	else
	{
		if ((al_33 & 0xC0) == 0x00)
		{
			if (eax_23 > 0x2E)
				abort();
			else
			{
				<anonymous> * ecx_46 = 0x0804A5C0 - g_a8048F6C[eax_23 * 0x04];
				byte * eax_50;
				ecx_46();
				ebpOut = fp - 4;
				ediOut = dwArg0C;
				return eax_50;
			}
		}
		Mem59[(eax_23 & 0x3F) + 92 + dwArg08:byte] = bLoc14_119;
	}
	ebpOut = ebp;
	ediOut = edi;
	return dwArg04_116;
}

ui32 g_a8048F6C[] = // 08048F6C
	{
	};
// 0804923C: void __register_frame_info(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_31) dwArg08)
// Called from:
//      frame_dummy
void __register_frame_info(struct Eq_25 * dwArg04, struct Eq_31 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->ptr000C = null;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 08049284: void __register_frame_info_table(Stack (ptr32 Eq_25) dwArg04, Stack (ptr32 Eq_31) dwArg08)
void __register_frame_info_table(struct Eq_25 * dwArg04, struct Eq_31 * dwArg08)
{
	dwArg08->ptr0008 = dwArg04;
	dwArg08->ptr000C = dwArg04;
	dwArg08->dw0004 = 0x00;
	dwArg08->dw0000 = 0x00;
	dwArg08->dw0010 = 0x00;
	dwArg08->ptr0014 = objects;
	objects = dwArg08;
}

// 080492C8: void __deregister_frame_info(Stack (ptr32 Eq_25) dwArg04)
// Called from:
//      __do_global_dtors_aux
void __deregister_frame_info(struct Eq_25 * dwArg04)
{
	struct Eq_533 * ecx_14 = &objects;
	if (objects != null)
	{
		do
		{
			struct Eq_877 * edx_19 = ecx_14->ptr0000;
			if (edx_19->ptr0008 == dwArg04)
			{
				ecx_14->ptr0000 = (struct Eq_1174 *) edx_19->ptr0014;
				if (edx_19->dw0000 != 0x00)
					free(edx_19->ptr000C);
				return;
			}
			ecx_14 = (struct Eq_533 *) &edx_19->ptr0014;
		} while (edx_19->ptr0014 != null);
	}
	abort();
}

// 08049320: void __frame_state_for(Stack up32 dwArg04)
void __frame_state_for(up32 dwArg04)
{
	ptr32 fp;
	word32 dwLoc8C;
	Eq_913 tLoc18;
	struct Eq_914 * ebp_102 = fp - 4;
	struct Eq_598 * eax_24 = find_fde(dwArg04);
	if (eax_24 != null)
	{
		byte * eax_45 = extract_cie_info(eax_24, &tLoc18);
		byte * esi_114 = eax_45;
		if (eax_45 != null)
		{
			memset(&dwLoc8C, 0x00, 116);
			up32 * ecx_78 = eax_24 - (eax_24->dw0004 + ~0x03);
			ptr32 esp_115 = fp - 0xB8;
			if (eax_45 < (ecx_78 + *ecx_78) + 1)
			{
				do
				{
					struct Eq_972 * esp_89 = esp_115 - 4;
					esp_89->ptr0000 = null;
					esp_89->ptrFFFFFFFC = ebp_102->ptrFFFFFF60;
					esp_89->tFFFFFFF8.u0 = ebp_102->tFFFFFF5C.u0;
					esp_89->ptrFFFFFFF4 = esi_114;
					byte * edi_105;
					byte * eax_101 = execute_cfa_insn(esp_89->ptrFFFFFFF4, esp_89->tFFFFFFF8.u0, esp_89->ptrFFFFFFFC, esp_89->ptr0000, out ebp_102, out edi_105);
					word32 esp_108 = <invalid>;
					esi_114 = eax_101;
					esp_115 = esp_108 + 0x10;
				} while (eax_101 < edi_105);
			}
			struct Eq_957 * esi_120 = ebp_102->ptrFFFFFF6C;
			byte * esi_121 = &esi_120->dw0008 + 2;
			if (*ebp_102->ptrFFFFFFEC == 122)
			{
				struct Eq_1040 * esp_127 = esp_115 - 4;
				esp_127->ptr0000 = ebp_102 - 0x8C;
				esp_127->ptrFFFFFFFC = (byte *) (&esi_120->dw0008 + 2);
				esi_121 = decode_uleb128(esp_127->ptrFFFFFFFC, esp_127->ptr0000) + ebp_102->dwFFFFFF74;
			}
			struct Eq_957 * eax_145 = ebp_102->ptrFFFFFF6C;
			up32 eax_146 = eax_145 + eax_145->dw0000 / 0x0C;
			ebp_102->dwFFFFFF70 = ebp_102->ptrFFFFFF6C->dw0008;
			ptr32 esp_162 = esp_115;
			if (esi_121 < eax_146 + 4)
			{
				ebp_102->ptrFFFFFF58 = ebp_102 - 0x90;
				while (ebp_102->dwFFFFFF70 <= ebp_102->dw0008)
				{
					struct Eq_1081 * esp_163 = esp_162 - 4;
					esp_163->ptr0000 = ebp_102->ptrFFFFFF58;
					esp_163->ptrFFFFFFFC = ebp_102 - 20;
					esp_163->tFFFFFFF8.u0 = (int32) (ebp_102 - 0x88);
					esp_163->ptrFFFFFFF4 = esi_121;
					byte * edi_178;
					byte * eax_174 = execute_cfa_insn(esp_163->ptrFFFFFFF4, esp_163->tFFFFFFF8.u0, esp_163->ptrFFFFFFFC, esp_163->ptr0000, out ebp_102, out edi_178);
					word32 esp_181 = <invalid>;
					esi_121 = eax_174;
					esp_162 = esp_181 + 0x10;
					if (eax_174 >= edi_178)
						break;
				}
			}
			memcpy(ebp_102->ptr000C, ebp_102 - 0x88, 0x70);
		}
	}
}

// 0804948C: void __do_global_ctors_aux()
// Called from:
//      _init
void __do_global_ctors_aux()
{
	<anonymous> ** esi_17 = &g_dw804A690;
	if (g_dw804A690 != ~0x00)
	{
		do
		{
			(*esi_17)();
			esi_17 = (<anonymous> **) ((char *) esi_17 - 4);
		} while (*esi_17 != (<anonymous> *) ~0x00);
	}
}

// 080494C0: void init_dummy()
void init_dummy()
{
}

