// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw405000 = 0x00; // 00405000
word32 g_dw405004 = 0x00; // 00405004
word32 g_dw405008 = 0x00; // 00405008
word32 g_dw405010 = 0x00; // 00405010
word32 g_dw405014 = 0x00; // 00405014
word32 g_dw405018 = 0x00; // 00405018
word32 g_dw40501C = 0x00; // 0040501C
word32 g_dw405020 = 0x00; // 00405020
<anonymous> * g_ptr405030 = &g_t4014CD; // 00405030
word32 g_dw405034 = 0x02; // 00405034
word32 g_dw405038 = 0xC0000005; // 00405038
int32 g_dw4050B0 = 3; // 004050B0
word32 g_dw4050B4 = 0x07; // 004050B4
ui32 g_dw4050B8 = 0x0A; // 004050B8
word32 g_dw4050BC = 0x8C; // 004050BC
Eq_5666 g_a4050E0[19] = // 004050E0
	{
		
		{
			0x02,
			
			{
				0x60
			},
		},
		
		{
			0x08,
			
			{
				0x34
			},
		},
		
		{
			0x09,
			
			{
				0x08
			},
		},
		
		{
			0x0A,
			
			{
				228
			},
		},
		
		{
			0x10,
			
			{
				0xB8
			},
		},
		
		{
			0x11,
			
			{
				0x88
			},
		},
		
		{
			0x12,
			
			{
				100
			},
		},
		
		{
			0x13,
			
			{
				0x38
			},
		},
		
		{
			0x18,
			
			{
				0x00
			},
		},
		
		{
			0x19,
			
			{
				0xD8
			},
		},
		
		{
			0x1A,
			
			{
				0xA0
			},
		},
		
		{
			0x1B,
			
			{
				0x68
			},
		},
		
		{
			0x1C,
			
			{
				0x40
			},
		},
		
		{
			0x78,
			
			{
				0x30
			},
		},
		
		{
			121,
			
			{
				0x20
			},
		},
		
		{
			122,
			
			{
				0x10
			},
		},
		
		{
			252,
			
			{
				0x0C
			},
		},
		
		{
			0xFF,
			
			{
				252
			},
		},
		
		{
			0x08040201,
			
			{
				0x00
			},
		},
	};
byte g_a405170[5] = // 00405170
	{
		0x01,
		0x02,
		0x04,
		0x08,
		0x00,
	};
Eq_5671 g_a405178[6] = // 00405178
	{
		
		{
			
			{
				0xA4
			},
		},
		
		{
			
			{
				0xA8
			},
		},
		
		{
			
			{
				181
			},
		},
		
		{
			
			{
				~0x49
			},
		},
		
		{
			
			{
				0x51
			},
		},
		
		{
			
			{
				0x00
			},
		},
	};
Eq_8 g_t405268 = // 00405268
	{
		0x00
	};
Eq_8 g_t405270 = // 00405270
	{
		~0x07
	};
word16 g_a40528A[] = // 0040528A
	{
	};
Eq_3 g_t405558 = // 00405558
	{
		null
	};
Eq_8 g_t40555C = // 0040555C
	{
		0x00
	};
word32 g_dw405564 = 0x00; // 00405564
uint32 g_dw405574 = 0x00; // 00405574
uint32 g_dw405578 = 0x00; // 00405578
ui32 g_dw40557C = 0x00; // 0040557C
uint32 g_dw405580 = 0x00; // 00405580
ui32 g_dw405584 = 0x00; // 00405584
Eq_8 g_t405588 = // 00405588
	{
		0x00
	};
Eq_8 g_t405590 = // 00405590
	{
		0x00
	};
word32 g_dw4055A0 = 0x00; // 004055A0
byte g_b4055A8 = 0x00; // 004055A8
word32 g_dw4055AC = 0x00; // 004055AC
word32 g_dw4055B0 = 0x00; // 004055B0
struct _EXCEPTION_POINTERS * g_ptr4055B4 = null; // 004055B4
word32 g_dw4056BC = 0x00; // 004056BC
<anonymous> * g_ptr4056C0 = null; // 004056C0
word32 g_dw4056C4 = 0x00; // 004056C4
Eq_4401 g_t4056C8 = null; // 004056C8
Eq_4401 g_t4056CC = null; // 004056CC
Eq_4401 g_t4056D0 = null; // 004056D0
Eq_8 g_t4056DC = // 004056DC
	{
		0x00
	};
Eq_8 g_t4056EC = // 004056EC
	{
		0x00
	};
word32 g_dw4056F4 = 0x00; // 004056F4
word32 g_dw4056F8 = 0x00; // 004056F8
word32 g_dw4056FC = 0x00; // 004056FC
<anonymous> * g_ptr405700 = null; // 00405700
ui32 g_dw405704 = 0x00; // 00405704
Eq_3046 g_t405708 = // 00405708
	{
		0
	};
Eq_8 g_t40570C = // 0040570C
	{
		0x00
	};
Eq_8 g_t405710 = // 00405710
	{
		0x00
	};
ui32 g_dw405714 = 0x00; // 00405714
Eq_8 g_t405718 = // 00405718
	{
		0x00
	};
Eq_8 g_t40571C = // 0040571C
	{
		0x00
	};
word32 g_dw405720 = 0x00; // 00405720
word32 g_dw405724 = 0x00; // 00405724
word32 g_dw405728 = 0x00; // 00405728
word32 g_dw40572C = 0x00; // 0040572C
byte g_a405740[257] = // 00405740
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_1882 g_a405840[] = // 00405840
	{
	};
byte g_a405841[257] = // 00405841
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
byte g_a405842[255] = // 00405842
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_8 g_t405944 = // 00405944
	{
		0x00
	};
Eq_356 g_t405948 = null; // 00405948
Eq_8 g_t405960 = // 00405960
	{
		0x00
	};
Eq_8 g_a405964[] = // 00405964
	{
	};
Eq_8 g_t405A60 = // 00405A60
	{
		0x00
	};
word32 g_dw405A64 = 0x00; // 00405A64
word32 g_dw405A68 = 0x00; // 00405A68
up32 g_dw405A6C = 0x00; // 00405A6C
word32 * g_ptr405A70 = null; // 00405A70
<anonymous> * g_ptr405A74 = null; // 00405A74
Eq_8 g_t405A78 = // 00405A78
	{
		0x00
	};
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetModuleFileNameA = &g_t4776; // 00404000
<anonymous> * __imp__GetStringTypeW = &g_t493C; // 00404004
<anonymous> * __imp__GetStringTypeA = &g_t492A; // 00404008
<anonymous> * __imp__LCMapStringW = &g_t491A; // 0040400C
<anonymous> * __imp__LCMapStringA = &g_t490A; // 00404010
<anonymous> * __imp__MultiByteToWideChar = &g_t48F4; // 00404014
<anonymous> * __imp__LoadLibraryA = &g_t48E4; // 00404018
<anonymous> * __imp__GetProcAddress = &g_t48D2; // 0040401C
<anonymous> * __imp__HeapReAlloc = &g_t48C4; // 00404020
<anonymous> * __imp__VirtualAlloc = &g_t48B4; // 00404024
<anonymous> * __imp__HeapAlloc = &g_t48A8; // 00404028
<anonymous> * __imp__GetOEMCP = &g_t489C; // 0040402C
<anonymous> * __imp__GetACP = &g_t4892; // 00404030
<anonymous> * __imp__GetCPInfo = &g_t4886; // 00404034
<anonymous> * __imp__WriteFile = &g_t487A; // 00404038
<anonymous> * __imp__RtlUnwind = &g_t486E; // 0040403C
<anonymous> * __imp__HeapFree = &g_t4862; // 00404040
<anonymous> * __imp__VirtualFree = &g_t4854; // 00404044
<anonymous> * __imp__HeapCreate = &g_t4846; // 00404048
<anonymous> * __imp__HeapDestroy = &g_t4838; // 0040404C
<anonymous> * __imp__GetFileType = &g_t482A; // 00404050
<anonymous> * __imp__GetModuleHandleA = &g_t46DE; // 00404054
<anonymous> * __imp__GetStartupInfoA = &g_t46F2; // 00404058
<anonymous> * __imp__GetCommandLineA = &g_t4704; // 0040405C
<anonymous> * __imp__GetVersion = &g_t4716; // 00404060
<anonymous> * __imp__ExitProcess = &g_t4724; // 00404064
<anonymous> * __imp__TerminateProcess = &g_t4732; // 00404068
<anonymous> * __imp__GetCurrentProcess = &g_t4746; // 0040406C
<anonymous> * __imp__UnhandledExceptionFilter = &g_t475A; // 00404070
<anonymous> * __imp__FreeEnvironmentStringsA = &g_t478C; // 00404074
<anonymous> * __imp__FreeEnvironmentStringsW = &g_t47A6; // 00404078
<anonymous> * __imp__WideCharToMultiByte = &g_t47C0; // 0040407C
<anonymous> * __imp__GetEnvironmentStrings = &g_t47D6; // 00404080
<anonymous> * __imp__GetEnvironmentStringsW = &g_t47EE; // 00404084
<anonymous> * __imp__SetHandleCount = &g_t4808; // 00404088
<anonymous> * __imp__GetStdHandle = &g_t481A; // 0040408C
<anonymous> * __imp__EndDialog = &g_t46C6; // 00404094
<anonymous> * __imp__DefWindowProcA = &g_t46B4; // 00404098
<anonymous> * __imp__DestroyWindow = &g_t46A4; // 0040409C
<anonymous> * __imp__DialogBoxParamA = &g_t4692; // 004040A0
<anonymous> * __imp__BeginPaint = &g_t4684; // 004040A4
<anonymous> * __imp__GetClientRect = &g_t4674; // 004040A8
<anonymous> * __imp__DrawTextA = &g_t4668; // 004040AC
<anonymous> * __imp__EndPaint = &g_t465C; // 004040B0
<anonymous> * __imp__PostQuitMessage = &g_t464A; // 004040B4
<anonymous> * __imp__CreateWindowExA = &g_t4638; // 004040B8
<anonymous> * __imp__ShowWindow = &g_t462A; // 004040BC
<anonymous> * __imp__UpdateWindow = &g_t461A; // 004040C0
<anonymous> * __imp__LoadIconA = &g_t460E; // 004040C4
<anonymous> * __imp__LoadCursorA = &g_t4600; // 004040C8
<anonymous> * __imp__RegisterClassExA = &g_t45EC; // 004040CC
<anonymous> * __imp__LoadStringA = &g_t45DE; // 004040D0
<anonymous> * __imp__LoadAcceleratorsA = &g_t45CA; // 004040D4
<anonymous> * __imp__GetMessageA = &g_t45BC; // 004040D8
<anonymous> * __imp__TranslateAcceleratorA = &g_t45A4; // 004040DC
<anonymous> * __imp__TranslateMessage = &g_t4590; // 004040E0
<anonymous> * __imp__DispatchMessageA = &g_t457C; // 004040E4
byte g_b4043D0 = 0x2E; // 004043D0
word32 g_dw404490 = 0x4776; // 00404490
word32 g_dw404494 = 18748; // 00404494
word32 g_dw404498 = 0x492A; // 00404498
word32 g_dw40449C = 18714; // 0040449C
word32 g_dw4044A0 = 0x490A; // 004044A0
word32 g_dw4044A4 = 0x48F4; // 004044A4
word32 g_dw4044A8 = 0x48E4; // 004044A8
word32 g_dw4044AC = 0x48D2; // 004044AC
word32 g_dw4044B0 = 0x48C4; // 004044B0
word32 g_dw4044B4 = 0x48B4; // 004044B4
word32 g_dw4044B8 = 0x48A8; // 004044B8
word32 g_dw4044BC = 18588; // 004044BC
word32 g_dw4044C0 = 18578; // 004044C0
word32 g_dw4044C4 = 0x4886; // 004044C4
word32 g_dw4044C8 = 18554; // 004044C8
word32 g_dw4044CC = 0x486E; // 004044CC
word32 g_dw4044D0 = 0x4862; // 004044D0
word32 g_dw4044D4 = 0x4854; // 004044D4
word32 g_dw4044D8 = 0x4846; // 004044D8
word32 g_dw4044DC = 18488; // 004044DC
word32 g_dw4044E0 = 18474; // 004044E0
word32 g_dw4044E4 = 18142; // 004044E4
word32 g_dw4044E8 = 18162; // 004044E8
word32 g_dw4044EC = 0x4704; // 004044EC
word32 g_dw4044F0 = 18198; // 004044F0
word32 g_dw4044F4 = 18212; // 004044F4
word32 g_dw4044F8 = 18226; // 004044F8
word32 g_dw4044FC = 0x4746; // 004044FC
word32 g_dw404500 = 18266; // 00404500
word32 g_dw404504 = 18316; // 00404504
word32 g_dw404508 = 0x47A6; // 00404508
word32 g_dw40450C = 0x47C0; // 0040450C
word32 g_dw404510 = 0x47D6; // 00404510
word32 g_dw404514 = 18414; // 00404514
word32 g_dw404518 = 0x4808; // 00404518
word32 g_dw40451C = 18458; // 0040451C
word32 g_dw404524 = 18118; // 00404524
word32 g_dw404528 = 18100; // 00404528
word32 g_dw40452C = 0x46A4; // 0040452C
word32 g_dw404530 = 18066; // 00404530
word32 g_dw404534 = 0x4684; // 00404534
word32 g_dw404538 = 0x4674; // 00404538
word32 g_dw40453C = 0x4668; // 0040453C
word32 g_dw404540 = 18012; // 00404540
word32 g_dw404544 = 0x464A; // 00404544
word32 g_dw404548 = 17976; // 00404548
word32 g_dw40454C = 0x462A; // 0040454C
word32 g_dw404550 = 0x461A; // 00404550
word32 g_dw404554 = 0x460E; // 00404554
word32 g_dw404558 = 0x4600; // 00404558
word32 g_dw40455C = 17900; // 0040455C
word32 g_dw404560 = 17886; // 00404560
word32 g_dw404564 = 17866; // 00404564
word32 g_dw404568 = 0x45BC; // 00404568
word32 g_dw40456C = 0x45A4; // 0040456C
word32 g_dw404570 = 0x4590; // 00404570
word32 g_dw404574 = 17788; // 00404574
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register word32 fn00401000(Stack Eq_3 dwArg04, Stack int32 dwArg10)
// Called from:
//      Win32CrtStartup
word32 fn00401000(Eq_3 dwArg04, int32 dwArg10)
{
	LoadStringA(dwArg04, 0x67, 0x004054F4, 100);
	LoadStringA(dwArg04, 0x6D, 0x00405490, 100);
	fn004010C0(dwArg04);
	word32 eax_47 = fn00401150(dwArg04, dwArg10);
	if (eax_47 == 0x00)
		return eax_47;
	Eq_32 eax_60 = LoadAcceleratorsA(dwArg04, 0x6D);
	while (GetMessageA(fp - 0x1C, null, 0x00, 0x00) != 0x00)
	{
		if (TranslateAcceleratorA(dwLoc1C, eax_60, fp - 0x1C) == 0x00)
		{
			TranslateMessage(fp - 0x1C);
			DispatchMessageA(fp - 0x1C);
		}
	}
	return dwLoc14;
}

// 004010C0: void fn004010C0(Stack Eq_3 dwArg04)
// Called from:
//      fn00401000
void fn004010C0(Eq_3 dwArg04)
{
	LoadIconA(dwArg04, 0x6B);
	LoadCursorA(0x00, 0x7F00);
	LoadIconA(dwArg04, 0x6C);
	RegisterClassExA(fp - 0x30);
}

// 00401150: Register Eq_42 fn00401150(Stack Eq_3 dwArg04, Stack int32 dwArg08)
// Called from:
//      fn00401000
Eq_42 fn00401150(Eq_3 dwArg04, int32 dwArg08)
{
	g_t405558 = dwArg04;
	Eq_42 eax_34 = CreateWindowExA(0x00, 0x00405490, 0x004054F4, 0x00CF0000, 0x80000000, 0x00, 0x80000000, 0x00, null, null, dwArg04, 0x00);
	if (eax_34 == null)
		return eax_34;
	ShowWindow(eax_34, dwArg08);
	UpdateWindow(eax_34);
	return (struct HWND__ *) 0x01;
}

// 00401350: Register Eq_8 Win32CrtStartup()
Eq_8 Win32CrtStartup()
{
	fs->ptr0000 = fp - 20;
	Eq_8 eax_30 = GetVersion();
	uint32 edx_35 = (uint32) SLICE(eax_30, byte, 8);
	g_dw405580 = edx_35;
	g_dw40557C = eax_30 & 0xFF;
	g_dw405578 = ((eax_30 & 0xFF) << 0x08) + edx_35;
	g_dw405574 = eax_30 >> 0x10;
	if (fn00401D50(0x00) != 0x00)
	{
		int32 eax_116;
		fn00401BA5();
		g_t405A78 = GetCommandLineA();
		ui32 ecx_74;
		g_t40555C = fn00401A73(out ecx_74);
		fn00401826(ecx_74);
		struct Eq_210 * ebp_88 = fn0040176D();
		fn0040148F();
		ebp_88->dwFFFFFFD0 = 0x00;
		GetStartupInfoA(ebp_88 - 0x5C);
		ebp_88->dwFFFFFF9C = fn00401715();
		if ((ebp_88->dwFFFFFFD0 & 0x01) != 0x00)
			eax_116 = (word32) ebp_88->wFFFFFFD4;
		else
			eax_116 = 0x0A;
		Eq_8 eax_136 = fn00401000(GetModuleHandleA(0x00), eax_116);
		ebp_88->tFFFFFFA0 = eax_136;
		fn004014BC(eax_136);
		struct _EXCEPTION_POINTERS * eax_153 = ebp_88->ptrFFFFFFEC;
		word32 ecx_155 = eax_153->ExceptionRecord->ExceptionCode;
		ebp_88->dwFFFFFF98 = ecx_155;
		return fn00401591(ecx_155, eax_153);
	}
	else
		fn0040146B(0x1C);
}

// 00401446: Register word32 fn00401446(Stack word32 dwArg04)
// Called from:
//      fn0040176D
//      fn00401826
//      fn00401BA5
word32 fn00401446(word32 dwArg04)
{
	if (g_dw405564 == 0x01)
		fn00401F5C();
	word32 edi_23 = fn00401F95(dwArg04);
	g_ptr405030();
	return edi_23;
}

// 0040146B: void fn0040146B(Stack word32 dwArg04)
// Called from:
//      Win32CrtStartup
void fn0040146B(word32 dwArg04)
{
	if (g_dw405564 == 0x01)
		fn00401F5C();
	fn00401F95(dwArg04);
	ExitProcess(0xFF);
}

// 0040148F: void fn0040148F()
// Called from:
//      Win32CrtStartup
void fn0040148F()
{
	<anonymous> * eax_5 = g_ptr405A74;
	if (eax_5 != null)
		eax_5();
	fn00401577(&g_dw405008, &g_dw405010);
	fn00401577(&g_dw405000, &g_dw405004);
}

// 004014BC: void fn004014BC(Stack Eq_8 dwArg04)
// Called from:
//      Win32CrtStartup
void fn004014BC(Eq_8 dwArg04)
{
	fn004014DE(dwArg04, 0x00, 0x00);
}

<anonymous> g_t4014CD = <code>; // 004014CD
// 004014DE: void fn004014DE(Stack Eq_8 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn004014BC
void fn004014DE(Eq_8 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	if (g_dw4055B0 == 0x01)
		TerminateProcess(GetCurrentProcess(), dwArg04);
	g_dw4055AC = 0x01;
	g_b4055A8 = (byte) dwArg0C;
	ptr32 esp_24 = fp - 8;
	if (dwArg08 == 0x00)
	{
		word32 * eax_34 = g_ptr405A70;
		if (eax_34 != null)
		{
			up32 ecx_38 = g_dw405A6C;
			ptr32 esp_39 = fp - 0x0C;
			word32 * esi_43 = ecx_38 - 0x04;
			if (ecx_38 - 0x04 >= eax_34)
			{
				do
				{
					<anonymous> * eax_48 = *esi_43;
					if (eax_48 != null)
					{
						word32 eax_57;
						eax_48();
					}
					esi_43 -= 0x04;
				} while (esi_43 >= g_ptr405A70);
			}
			esp_24 = esp_39 + 4;
		}
		struct Eq_373 * esp_72 = esp_24 - 4;
		esp_72->ptr0000 = &g_dw405018;
		esp_72->ptrFFFFFFFC = &g_dw405014;
		fn00401577(esp_72->ptrFFFFFFFC, esp_72->ptr0000);
	}
	fn00401577(&g_dw40501C, &g_dw405020);
	if (dwArg0C != 0x00)
		return;
	g_dw4055B0 = 0x01;
	ExitProcess(dwArg04);
}

// 00401577: void fn00401577(Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn0040148F
//      fn004014DE
void fn00401577(word32 * dwArg04, word32 * dwArg08)
{
	word32 * esi_25;
	for (esi_25 = dwArg04; esi_25 < dwArg08; ++esi_25)
	{
		<anonymous> * eax_15 = *esi_25;
		if (eax_15 != null)
		{
			word32 eax_21;
			eax_15();
		}
	}
}

// 00401591: Register Eq_433 fn00401591(Stack word32 dwArg04, Stack (ptr32 Eq_266) dwArg08)
// Called from:
//      Win32CrtStartup
Eq_433 fn00401591(word32 dwArg04, struct _EXCEPTION_POINTERS * dwArg08)
{
	Eq_433 eax_149;
	struct Eq_435 * eax_14 = fn004016D2(dwArg04);
	if (eax_14 != null)
	{
		<anonymous> * ebx_26 = eax_14->ptr0008;
		if (ebx_26 != null)
		{
			if (ebx_26 == (<anonymous> *) 0x05)
			{
				eax_14->ptr0008 = null;
				eax_149 = 0x01;
			}
			else
			{
				if (ebx_26 != (<anonymous> *) 0x01)
				{
					struct _EXCEPTION_POINTERS * ecx_42 = g_ptr4055B4;
					g_ptr4055B4 = dwArg08;
					word32 ecx_46 = eax_14->dw0004;
					if (ecx_46 == 0x08)
					{
						int32 ecx_63 = g_dw4050B0;
						int32 edx_65 = g_dw4050B4 + ecx_63;
						if (ecx_63 < edx_65)
						{
							int32 edx_72 = edx_65 - ecx_63;
							struct Eq_496 * esi_74 = ecx_63 * 0x0C + 0x00405040;
							do
							{
								esi_74->dw0000 = 0x00;
								++esi_74;
								--edx_72;
							} while (edx_72 != 0x00);
						}
						word32 eax_89 = eax_14->dw0000;
						word32 esi_90 = g_dw4050BC;
						if (eax_89 == 0xC000008E)
							g_dw4050BC = 131;
						else if (eax_89 == 0xC0000090)
							g_dw4050BC = 0x81;
						else if (eax_89 == 0xC0000091)
							g_dw4050BC = 0x84;
						else if (eax_89 == 0xC0000093)
							g_dw4050BC = 133;
						else if (eax_89 == 0xC000008D)
							g_dw4050BC = 0x82;
						else if (eax_89 == 0xC000008F)
							g_dw4050BC = 0x86;
						else if (eax_89 == 0xC0000092)
							g_dw4050BC = 0x8A;
						ebx_26();
						g_dw4050BC = esi_90;
					}
					else
					{
						eax_14->ptr0008 = null;
						ebx_26();
					}
					g_ptr4055B4 = ecx_42;
				}
				eax_149 = ~0x00;
			}
			return eax_149;
		}
	}
	eax_149 = UnhandledExceptionFilter(dwArg08);
	return eax_149;
}

// 004016D2: Register (ptr32 Eq_548) fn004016D2(Stack word32 dwArg04)
// Called from:
//      fn00401591
struct Eq_548 * fn004016D2(word32 dwArg04)
{
	ui32 ecx_6 = g_dw4050B8;
	struct Eq_548 * eax_11 = &g_dw405038;
	if (g_dw405038 != dwArg04)
	{
		struct Eq_548 * esi_14 = ecx_6 * 0x0C + 0x00405038;
		do
			++eax_11;
		while (eax_11 < esi_14 && eax_11->dw0000 != dwArg04);
	}
	if (eax_11 >= ecx_6 * 0x0C + 0x00405038 || eax_11->dw0000 != dwArg04)
		eax_11 = null;
	return eax_11;
}

// 00401715: Register Eq_8 fn00401715()
// Called from:
//      Win32CrtStartup
Eq_8 fn00401715()
{
	if (g_dw405A68 == 0x00)
		fn004024EE();
	Eq_8 esi_20 = g_t405A78;
	cu8 al_21 = *esi_20;
	if (al_21 == 0x22)
	{
		while (true)
		{
			byte al_33 = *((word32) esi_20 + 1);
			esi_20 = (word32) esi_20 + 1;
			if (al_33 == 0x22 || al_33 == 0x00)
				break;
			if (fn004020E8((word32) al_33) != 0x00)
				esi_20 = (word32) esi_20 + 1;
		}
		if (*esi_20 == 0x22)
		{
l00401752:
			esi_20 = (word32) esi_20 + 1;
		}
	}
	else if (al_21 > 0x20)
	{
		do
			esi_20 = (word32) esi_20 + 1;
		while (*esi_20 > 0x20);
	}
	cu8 al_50 = *esi_20;
	if (al_50 == 0x00 || al_50 > 0x20)
		return esi_20;
	goto l00401752;
}

// 0040176D: Register word32 fn0040176D()
// Called from:
//      Win32CrtStartup
word32 fn0040176D()
{
	if (g_dw405A68 == 0x00)
		fn004024EE();
	Eq_8 esi_203 = g_t40555C;
	ui32 edi_188 = 0x00;
	while (true)
	{
		byte al_31 = *esi_203;
		if (al_31 == 0x00)
			break;
		if (al_31 != 0x3D)
			++edi_188;
		esi_203 = (word32) fn004026B0(esi_203) + ((word32) esi_203 + 1);
	}
	Eq_8 eax_40 = fn00402630(edi_188 * 0x04 + 0x04);
	g_t405590 = eax_40;
	Eq_8 esi_107 = eax_40;
	if (eax_40 == 0x00)
		fn00401446(0x09);
	Eq_8 edi_114 = g_t40555C;
	while (*edi_114 != 0x00)
	{
		Eq_8 eax_81 = fn004026B0(edi_114);
		if (*edi_114 != 0x3D)
		{
			Eq_8 eax_96 = fn00402630((word32) eax_81 + 1);
			*esi_107 = eax_96;
			if (eax_96 == 0x00)
				edi_114 = fn00401446(0x09);
			edi_114 = fn00402540(*esi_107, edi_114);
			esi_107 = (word32) esi_107 + 4;
		}
		edi_114 = (word32) edi_114 + ((word32) eax_81 + 1);
	}
	word32 ebp_165;
	Eq_8 ebx_166 = fn0040250A(g_t40555C, out ebp_165);
	g_t40555C = ebx_166;
	*esi_107 = ebx_166;
	g_dw405A64 = 0x01;
	return ebp_165;
}

// 00401826: void fn00401826(Register ui32 ecx)
// Called from:
//      Win32CrtStartup
void fn00401826(ui32 ecx)
{
	if (g_dw405A68 == 0x00)
		fn004024EE();
	GetModuleFileNameA(0x00, 0x004055B8, 0x0104);
	Eq_8 eax_44 = g_t405A78;
	g_dw4055A0 = 0x004055B8;
	Eq_8 edi_119 = 0x004055B8;
	if (*eax_44 != 0x00)
		edi_119 = eax_44;
	fn004018BF(edi_119, 0x00, null, fp - 0x08, fp - 0x0C);
	Eq_8 eax_80 = fn00402630(ecx * 0x05);
	if (eax_80 == 0x00)
		edi_119 = fn00401446(0x08);
	fn004018BF(edi_119, eax_80, (word32) eax_80 + ecx * 0x04, fp - 0x08, fp - 0x0C);
	g_t405588 = eax_80;
	g_dw405584 = ecx - 0x01;
}

// 004018BF: void fn004018BF(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08, Stack (ptr32 Eq_782) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      fn00401826
void fn004018BF(Eq_8 dwArg04, Eq_8 dwArg08, struct Eq_782 * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	struct Eq_782 * esi_118 = dwArg0C;
	Eq_8 edi_167 = dwArg08;
	Eq_8 eax_101 = dwArg04;
	if (dwArg08 != 0x00)
	{
		*dwArg08 = dwArg0C;
		edi_167 = (word32) dwArg08 + 4;
		dwArg08 = (word32) dwArg08 + 4;
	}
	if (*dwArg04 == 0x22)
	{
		while (true)
		{
			byte dl_105 = *((word32) eax_101 + 1);
			eax_101 = (word32) eax_101 + 1;
			if (dl_105 == 0x22 || dl_105 == 0x00)
				break;
			if ((g_a405841[(word32) dl_105] & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_118 != null)
				{
					esi_118->b0000 = (byte) *eax_101;
					++esi_118;
					eax_101 = (word32) eax_101 + 1;
				}
			}
			++*dwArg14;
			if (esi_118 != null)
			{
				esi_118->b0000 = (byte) *eax_101;
				++esi_118;
			}
		}
		++*dwArg14;
		if (esi_118 != null)
		{
			esi_118->b0000 = 0x00;
			++esi_118;
		}
		if (*eax_101 == 0x22)
			eax_101 = (word32) eax_101 + 1;
	}
	else
	{
		do
		{
			++*dwArg14;
			if (esi_118 != null)
			{
				esi_118->b0000 = (byte) *eax_101;
				++esi_118;
			}
			byte dl_52 = *eax_101;
			eax_101 = (word32) eax_101 + 1;
			if ((g_a405841[(word32) dl_52] & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_118 != null)
				{
					esi_118->b0000 = (byte) *eax_101;
					++esi_118;
				}
				eax_101 = (word32) eax_101 + 1;
			}
			if (dl_52 == 0x20)
				break;
			if (dl_52 == 0x00)
				goto l0040196A;
		} while (dl_52 != 0x09);
		if (dl_52 == 0x00)
		{
l0040196A:
			--eax_101;
		}
		else if (esi_118 != null)
			esi_118->bFFFFFFFF = 0x00;
	}
	uint32 dwArg14_523 = 0x00;
	while (*eax_101 != 0x00)
	{
		while (true)
		{
			byte dl_158 = *eax_101;
			if (dl_158 != 0x20 && dl_158 != 0x09)
				break;
			eax_101 = (word32) eax_101 + 1;
		}
		if (*eax_101 == 0x00)
			break;
		if (edi_167 != 0x00)
		{
			*edi_167 = esi_118;
			edi_167 = (word32) edi_167 + 4;
			dwArg08 = edi_167;
		}
		++*dwArg10;
l004019AB:
		word32 dwArg04_546 = 0x01;
		uint32 ebx_824 = 0x00;
		while (true)
		{
			byte bl_222 = (byte) ebx_824;
			if (*eax_101 != 0x5C)
				break;
			eax_101 = (word32) eax_101 + 1;
			ebx_824 = SEQ(SLICE(ebx_824 + 0x01, word24, 8), bl_222 + 0x01);
		}
		uint32 ebx_252 = ebx_824;
		if (*eax_101 == 0x22)
		{
			if ((bl_222 & 0x01) == 0x00)
			{
				if (dwArg14_523 != 0x00)
				{
					Eq_8 edx_231 = (word32) eax_101 + 1;
					if (*((word32) eax_101 + 1) != 0x22)
						goto l004019DB;
					eax_101 = edx_231;
				}
				else
				{
l004019DB:
					dwArg04_546 = 0x00;
				}
				edi_167 = dwArg08;
				dwArg14_523 = (uint32) (int8) (dwArg14_523 == 0x00);
			}
			ebx_252 = ebx_824 >> 0x01;
		}
		word32 ebx_257 = ebx_252 - 0x01;
		if (ebx_252 != 0x00)
		{
			word32 ebx_261 = ebx_257 + 0x01;
			do
			{
				if (esi_118 != null)
				{
					esi_118->b0000 = 0x5C;
					++esi_118;
				}
				++*dwArg14;
				--ebx_261;
			} while (ebx_261 != 0x00);
		}
		byte dl_291 = *eax_101;
		if (dl_291 != 0x00 && (dwArg14_523 != 0x00 || dl_291 != 0x20 && dl_291 != 0x09))
		{
			if (dwArg04_546 != 0x00)
			{
				if (esi_118 != null)
				{
					if ((g_a405841[(word32) dl_291] & 0x04) != 0x00)
					{
						esi_118->b0000 = dl_291;
						++*dwArg14;
						++esi_118;
						eax_101 = (word32) eax_101 + 1;
					}
					esi_118->b0000 = (byte) *eax_101;
					++esi_118;
				}
				else if ((g_a405841[(word32) dl_291] & 0x04) != 0x00)
				{
					++*dwArg14;
					eax_101 = (word32) eax_101 + 1;
				}
				++*dwArg14;
			}
			eax_101 = (word32) eax_101 + 1;
			goto l004019AB;
		}
		if (esi_118 != null)
		{
			esi_118->b0000 = 0x00;
			++esi_118;
		}
		++*dwArg14;
	}
	if (edi_167 != 0x00)
		*edi_167 = 0x00;
	++*dwArg10;
}

// 00401A73: Register Eq_8 fn00401A73(Register out Eq_8 ecxOut)
// Called from:
//      Win32CrtStartup
Eq_8 fn00401A73(union Eq_8 & ecxOut)
{
	Eq_8 eax_127;
	Eq_8 dwLoc04_279 = ecx;
	word32 eax_9 = g_dw4056BC;
	Eq_8 esi_129 = 0x00;
	Eq_8 edi_108 = 0x00;
	if (eax_9 == 0x00)
	{
		Eq_8 eax_32 = GetEnvironmentStringsW();
		esi_129 = eax_32;
		if (eax_32 != 0x00)
		{
			g_dw4056BC = 0x01;
l00401ACA:
			if (esi_129 != 0x00)
			{
l00401ADA:
				Eq_8 eax_147 = esi_129;
				if (*esi_129 != 0x00)
				{
					do
					{
						do
						{
							word32 eax_150 = eax_147 + 0x01;
							eax_147 = eax_150 + 0x01;
						} while (Mem143[eax_150 + 0x01:word16] != 0x00);
						eax_147 = eax_150 + 0x03;
					} while (Mem143[eax_150 + 0x03:word16] != 0x00);
				}
				Eq_8 eax_180 = (eax_147 - esi_129 >> 0x01) + 0x01;
				Eq_8 ebx_171 = 0x00;
				dwLoc04_279 = eax_180;
				Eq_8 eax_194 = WideCharToMultiByte(0x00, 0x00, esi_129, eax_180, 0x00, 0x00, 0x00, 0x00);
				if (eax_194 != 0x00)
				{
					Eq_8 eax_201 = fn00402630(eax_194);
					Eq_8 dwLoc08_300 = eax_201;
					if (eax_201 != 0x00)
					{
						if (WideCharToMultiByte(0x00, 0x00, esi_129, eax_180, eax_201, eax_194, 0x00, 0x00) == 0x00)
						{
							word32 ebp_461;
							dwLoc08_300 = fn0040250A(eax_201, out ebp_461);
						}
						ebx_171 = dwLoc08_300;
					}
				}
				FreeEnvironmentStringsW(esi_129);
				eax_127 = ebx_171;
				goto l00401B9E;
			}
			Eq_8 eax_134 = GetEnvironmentStringsW();
			esi_129 = eax_134;
			if (eax_134 != 0x00)
				goto l00401ADA;
l00401B9C:
			eax_127.u0 = 0x00;
			goto l00401B9E;
		}
		Eq_8 eax_36 = GetEnvironmentStrings();
		edi_108 = eax_36;
		if (eax_36 == 0x00)
			goto l00401B9C;
		g_dw4056BC = 0x02;
	}
	else
	{
		if (eax_9 == 0x01)
			goto l00401ACA;
		if (eax_9 != 0x02)
			goto l00401B9C;
	}
	if (edi_108 == 0x00)
	{
		Eq_8 eax_45 = GetEnvironmentStrings();
		edi_108 = eax_45;
		if (eax_45 == 0x00)
			goto l00401B9C;
	}
	Eq_8 eax_55 = edi_108;
	if (*edi_108 != 0x00)
	{
		do
		{
			do
				++eax_55;
			while (*eax_55 != 0x00);
			++eax_55;
		} while (Mem51[eax_55 + 0x01:byte] != 0x00);
	}
	Eq_8 esi_109;
	Eq_1330 eax_69 = eax_55 - edi_108;
	word32 eax_80 = fn00402630(eax_69 + 0x01);
	if (eax_80 == 0x00)
		esi_109.u0 = 0x00;
	else
		esi_109 = fn00402730(eax_80, edi_108, eax_69 + 0x01, out edi_108);
	FreeEnvironmentStringsA(edi_108);
	eax_127 = esi_109;
l00401B9E:
	ecxOut = dwLoc04_279;
	return eax_127;
}

// 00401BA5: void fn00401BA5()
// Called from:
//      Win32CrtStartup
void fn00401BA5()
{
	Eq_8 eax_20 = fn00402630(0x0100);
	Eq_8 esi_267 = eax_20;
	if (eax_20 == 0x00)
		fn00401446(0x1B);
	g_t405960 = eax_20;
	g_t405A60.u0 = 0x20;
	Eq_8 eax_268 = (word32) eax_20 + 0x0100;
	while (esi_267 < eax_268)
	{
		*((word32) esi_267 + 4) = 0x00;
		*esi_267 = ~0x00;
		*((word32) esi_267 + 5) = 0x0A;
		esi_267 = (word32) esi_267 + 8;
		eax_268 = (word32) g_t405960 + 0x0100;
	}
	GetStartupInfoA(fp - 0x44);
	if (wLoc12 != 0x00 && dwLoc10 != null)
	{
		Eq_8 esi_109 = *dwLoc10;
		byte * ebp_117 = (char *) dwLoc10 + 4;
		word32 ebx_112 = esi_109 + (dwLoc10 + 0x04);
		if (esi_109 >= 0x0800)
			esi_109.u0 = 0x0800;
		if (g_t405A60 < esi_109)
		{
			word32 * edi_103 = g_a405964;
			do
			{
				Eq_8 eax_255 = fn00402630(0x0100);
				if (eax_255 == 0x00)
				{
					esi_109 = g_t405A60;
					break;
				}
				g_t405A60 = (word32) g_t405A60 + 32;
				*edi_103 = (word32) eax_255;
				Eq_8 ecx_256 = (word32) eax_255 + 0x0100;
				while (eax_255 < ecx_256)
				{
					*((word32) eax_255 + 4) = 0x00;
					*eax_255 = ~0x00;
					*((word32) eax_255 + 5) = 0x0A;
					eax_255 = (word32) eax_255 + 8;
					ecx_256 = *edi_103 + 0x0100;
				}
				++edi_103;
			} while (g_t405A60 < esi_109);
		}
		Eq_8 edi_108 = 0x00;
		if (esi_109 > 0x00)
		{
			do
			{
				Eq_356 eax_114 = *ebx_112;
				if (eax_114 != (void *) ~0x00)
				{
					byte cl_118 = *ebp_117;
					if ((cl_118 & 0x01) != 0x00 && ((cl_118 & 0x08) != 0x00 || GetFileType(eax_114) != 0x00))
					{
						struct Eq_1595 * eax_143 = (char *) *((char *) &g_t405960 + (edi_108 >> 0x05) * 0x04) + (edi_108 & 0x1F) * 0x08;
						eax_143->dw0000 = *ebx_112;
						eax_143->b0004 = *ebp_117;
					}
				}
				edi_108 = (word32) edi_108 + 1;
				++ebp_117;
				++ebx_112;
			} while (edi_108 < esi_109);
		}
	}
	int32 ebx_161;
	for (ebx_161 = 0x00; ebx_161 < 0x03; ++ebx_161)
	{
		Eq_8 eax_165 = g_t405960;
		struct Eq_1481 * esi_168 = (word32) eax_165 + ebx_161 * 0x08;
		if (*((word32) eax_165 + ebx_161 * 0x08) == ~0x00)
		{
			Eq_8 eax_183;
			esi_168->b0004 = 0x81;
			if (ebx_161 == 0x00)
				eax_183.u0 = ~0x09;
			else
				eax_183 = 0x00 - (ebx_161 == 0x01) + ~0x0A;
			Eq_356 eax_194 = GetStdHandle(eax_183);
			if (eax_194 != (void *) ~0x00)
			{
				Eq_8 eax_201 = GetFileType(eax_194);
				if (eax_201 == 0x00)
					goto l00401D21;
				esi_168->t0000 = eax_194;
				if ((eax_201 & 0xFF) == 0x02)
					goto l00401D21;
				if ((eax_201 & 0xFF) == 0x03)
					esi_168->b0004 |= 0x08;
			}
			else
			{
l00401D21:
				esi_168->b0004 |= 0x40;
			}
		}
		else
			esi_168->b0004 |= 0x80;
	}
	SetHandleCount(g_t405A60);
}

// 00401D50: Register word32 fn00401D50(Stack word32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401D50(word32 dwArg04)
{
	Eq_356 eax_16 = HeapCreate((uint32) (int8) (dwArg04 == 0x00), 0x1000, 0x00);
	g_t405948 = eax_16;
	if (eax_16 == null)
		return 0x00;
	if (fn00402A65() != 0x00)
		return 0x01;
	HeapDestroy(g_t405948);
	return 0x00;
}

// 00401F5C: void fn00401F5C()
// Called from:
//      fn00401446
//      fn0040146B
void fn00401F5C()
{
	word32 eax_5 = g_dw405564;
	if (eax_5 == 0x01 || eax_5 == 0x00 && g_dw405034 == 0x01)
	{
		fn00401F95(252);
		<anonymous> * eax_24 = g_ptr4056C0;
		if (eax_24 != null)
		{
			word32 ecx_33;
			word32 edx_35;
			eax_24();
		}
		fn00401F95(0xFF);
	}
}

// 00401F95: Register Eq_8 fn00401F95(Stack word32 dwArg04)
// Called from:
//      fn00401446
//      fn0040146B
//      fn00401F5C
Eq_8 fn00401F95(word32 dwArg04)
{
	ui32 ecx_10 = 0x00;
	word32 * eax_13 = g_a4050E0;
	while (dwArg04 != *eax_13)
	{
		eax_13 += 2;
		++ecx_10;
		if (eax_13 >= g_a405170)
			break;
	}
	if (dwArg04 == g_a4050E0[ecx_10])
	{
		word32 eax_37 = g_dw405564;
		if (eax_37 != 0x01 && (eax_37 != 0x00 || g_dw405034 != 0x01))
		{
			if (dwArg04 != 252)
			{
				if (GetModuleFileNameA(0x00, fp - 424, 0x0104) == 0x00)
					edi = fn00402540(fp - 424, 0x004043D4);
				if (fn004026B0(fp - 424) > 0x3B)
					fn00403340((word32) fn004026B0(fp - 424) + (fp - 0x01E3), &g_b4043D0, 0x03);
				fn00402550(fp - 0xA4, fn00402540(fp - 0xA4, 0x004043B4));
				fn00402550(fp - 0xA4, 0x004043B0);
				fn00402550(fp - 0xA4, *((char *) &g_a4050E0->t0004 + ecx_10 * 0x08));
				fn004032AE();
			}
		}
		else
			WriteFile(GetStdHandle(~0x0B), *((char *) &g_a4050E0->t0004 + ecx_10 * 0x08), fn004026B0(*((char *) &g_a4050E0->t0004 + ecx_10 * 0x08)), fp + 0x04, null);
	}
	return edi;
}

// 004020E8: Register word32 fn004020E8(Stack Eq_615 bArg04)
// Called from:
//      fn00401715
word32 fn004020E8(Eq_615 bArg04)
{
	return fn004020F9((byte) dwArg04, 0x00, 0x04);
}

// 004020F9: Register ui32 fn004020F9(Stack byte bArg04, Stack ui32 dwArg08, Stack byte bArg0C)
// Called from:
//      fn004020E8
ui32 fn004020F9(byte bArg04, ui32 dwArg08, byte bArg0C)
{
	struct Eq_1809 * eax_5 = (word32) bArg04;
	if ((eax_5->b405841 & bArg0C) != 0x00)
		return 0x01;
	ui32 eax_12;
	if (dwArg08 != 0x00)
		eax_12 = (word32) g_a40528A[eax_5 * 0x02] & dwArg08;
	else
		eax_12 = 0x00;
	if (eax_12 != 0x00)
		return 0x01;
	return eax_12;
}

// 0040212A: void fn0040212A(Stack Eq_8 dwArg04)
// Called from:
//      fn004024EE
void fn0040212A(Eq_8 dwArg04)
{
	Eq_8 eax_22 = fn004022C3(dwArg04);
	if (eax_22 == g_t40571C)
		return;
	if (eax_22 != 0x00)
	{
		ui32 edx_160 = 0x00;
		union Eq_8 * eax_159 = g_a405178;
		do
		{
			if (*eax_159 == eax_22)
			{
				word32 ecx_158;
				struct Eq_1850 * edi_157 = g_a405840;
				for (ecx_158 = 0x40; ecx_158 != 0x00; --ecx_158)
				{
					edi_157->b0000 = (byte) 0x00;
					++edi_157;
				}
				edi_157->b0000 = 0x00;
				ui32 esi_56 = edx_160 * 0x03;
				byte * dwLoc08_343 = g_a405170;
				union Eq_1989 * ebx_113 = (esi_56 << 0x04) + 0x00405188;
				do
				{
					union Eq_1989 * ecx_70 = ebx_113;
					if (*ebx_113 != 0x00)
					{
						do
						{
							byte dl_74 = *((char *) ecx_70 + 1);
							if (dl_74 == 0x00)
								break;
							struct Eq_2018 * eax_78 = (word32) *ecx_70;
							struct Eq_2018 * edi_79 = (word32) dl_74;
							if (eax_78 <= edi_79)
							{
								byte dl_84 = *dwLoc08_343;
								do
								{
									eax_78[0x00405841] = (struct Eq_2018) (eax_78[0x00405841] | dl_84);
									++eax_78;
								} while (eax_78 <= edi_79);
							}
							struct Eq_2026 * ecx_97 = (char *) ecx_70 + 1;
							ecx_70 = (union Eq_1989 *) &ecx_97->b0001;
						} while (ecx_97->b0001 != 0x00);
					}
					byte * v22_107 = dwLoc08_343 + 1;
					dwLoc08_343 = v22_107;
					ebx_113 = (union Eq_1989 *) ((char *) ebx_113 + 8);
				} while (v22_107 < (byte *) ~0x0040516B);
				g_dw40572C = 0x01;
				g_t40571C = eax_22;
				Eq_8 eax_127 = fn0040230D(eax_22);
				struct Eq_2062 * esi_137 = (esi_56 << 0x04) + 4215164;
				g_dw405720 = esi_137->dw0000;
				g_dw405724 = esi_137->dw0004;
				g_t405944 = eax_127;
				g_dw405728 = esi_137->dw0008;
				goto l004022B2;
			}
			eax_159 = (union Eq_8 *) ((char *) eax_159 + 48);
			++edx_160;
		} while (eax_159 < &g_t405268);
		if (GetCPInfo(eax_22, fp - 0x1C) == 0x01)
		{
			g_t40571C = eax_22;
			word32 ecx_189;
			struct Eq_1880 * edi_191 = g_a405840;
			for (ecx_189 = 0x40; ecx_189 != 0x00; --ecx_189)
			{
				edi_191->b0000 = (byte) 0x00;
				++edi_191;
			}
			edi_191->b0000 = 0x00;
			g_t405944.u0 = 0x00;
			if (dwLoc1C > 0x01)
			{
				if (bLoc16 != 0x00)
				{
					struct Eq_1910 * ecx_206 = fp - 0x15;
					do
					{
						byte dl_209 = ecx_206->b0000;
						if (dl_209 == 0x00)
							break;
						struct Eq_1913 * eax_213;
						struct Eq_1913 * edx_214 = (word32) dl_209;
						for (eax_213 = (word32) ecx_206->bFFFFFFFF; eax_213 <= edx_214; ++eax_213)
							eax_213[0x00405841] = (struct Eq_1913) (eax_213[0x00405841] | 0x04);
						byte * ecx_220 = ecx_206 + 1;
						ecx_206 = (struct Eq_1910 *) (ecx_220 + 1);
					} while (*ecx_220 != 0x00);
				}
				struct Eq_1908 * eax_231 = (struct Eq_1908 *) 0x01;
				do
				{
					eax_231[0x00405841] = (struct Eq_1908) (eax_231[0x00405841] | 0x08);
					++eax_231;
				} while (eax_231 < (struct Eq_1908 *) 0xFF);
				g_t405944 = fn0040230D(eax_22);
				g_dw40572C = 0x01;
			}
			else
				g_dw40572C = 0x00;
			g_dw405720 = 0x00;
			g_dw405724 = 0x00;
			g_dw405728 = 0x00;
l004022B2:
			fn00402369();
			return;
		}
		if (g_dw4056C4 == 0x00)
			return;
	}
	fn00402340();
	goto l004022B2;
}

// 004022C3: Register Eq_8 fn004022C3(Stack Eq_8 dwArg04)
// Called from:
//      fn0040212A
Eq_8 fn004022C3(Eq_8 dwArg04)
{
	g_dw4056C4 = 0x00;
	Eq_8 eax_15 = dwArg04;
	if (dwArg04 != ~0x01)
	{
		if (dwArg04 != ~0x02)
		{
			if (dwArg04 == ~0x03)
			{
				eax_15 = g_t4056EC;
				g_dw4056C4 = 0x01;
			}
			return eax_15;
		}
		else
		{
			g_dw4056C4 = 0x01;
			return GetACP();
		}
	}
	else
	{
		g_dw4056C4 = 0x01;
		return GetOEMCP();
	}
}

// 0040230D: Register word32 fn0040230D(Stack Eq_8 dwArg04)
// Called from:
//      fn0040212A
word32 fn0040230D(Eq_8 dwArg04)
{
	if (dwArg04 == 0x03A4)
		return 0x0411;
	if (dwArg04 == 0x03A8)
		return 0x0804;
	if (dwArg04 == 949)
		return 0x0412;
	if (dwArg04 == 0x03B6)
		return 0x0404;
	return 0x00;
}

// 00402340: void fn00402340()
// Called from:
//      fn0040212A
void fn00402340()
{
	word32 ecx_15;
	struct Eq_2127 * edi_14 = g_a405840;
	for (ecx_15 = 0x40; ecx_15 != 0x00; --ecx_15)
	{
		edi_14->b0000 = (byte) 0x00;
		++edi_14;
	}
	edi_14->b0000 = 0x00;
	g_t40571C.u0 = 0x00;
	g_dw40572C = 0x00;
	g_t405944.u0 = 0x00;
	g_dw405720 = 0x00;
	g_dw405724 = 0x00;
	g_dw405728 = 0x00;
}

// 00402369: void fn00402369()
// Called from:
//      fn0040212A
void fn00402369()
{
	if (GetCPInfo(g_t40571C, fp - 0x18) == 0x01)
	{
		Eq_2172 eax_466 = 0x00;
		do
		{
			byte al_73 = (byte) eax_472;
			*((word32) eax_472 + (fp - 0x0118)) = al_73;
			eax_466 = SEQ(SLICE((word32) eax_472 + 1, word24, 8), al_73 + 0x01);
			eax_472 = eax_466;
		} while (eax_472 < 0xFF);
		byte al_100 = bLoc12;
		if (bLoc12 != 0x00)
		{
			byte * edx_122 = fp - 0x11;
			do
			{
				Eq_2270 ecx_99 = (word32) *edx_122;
				Eq_2270 eax_101 = (word32) al_100;
				if (eax_101 <= ecx_99)
				{
					word32 ecx_104 = ecx_99 - eax_101;
					struct Eq_2273 * edi_106 = (word32) eax_101 + (fp - 0x0118);
					uint32 ecx_110;
					for (ecx_110 = ecx_104 + 0x01 >> 0x02; ecx_110 != 0x00; --ecx_110)
					{
						edi_106->dw0000 = 0x20202020;
						edi_106 += 4;
					}
					ui32 ecx_115;
					for (ecx_115 = ecx_104 + 0x01 & 0x03; ecx_115 != 0x00; --ecx_115)
					{
						edi_106->dw0000 = (word32) 0x20;
						++edi_106;
					}
				}
				byte * edx_121 = edx_122 + 1;
				edx_122 = edx_121 + 1;
				al_100 = *edx_121;
			} while (al_100 != 0x00);
		}
		fn0040368D(0x01, fp - 0x0118, 0x0100, fp - 0x0518, g_t40571C, g_t405944, 0x00);
		fn0040343E(g_t405944, 0x0100, fp - 0x0118, 0x0100, fp - 0x0218, 0x0100, g_t40571C, 0x00);
		fn0040343E(g_t405944, 0x0200, fp - 0x0118, 0x0100, fp - 0x0318, 0x0100, g_t40571C, 0x00);
		struct Eq_2251 * eax_230 = null;
		struct Eq_2253 * ecx_233 = fp - 0x0518;
		do
		{
			byte dl_254;
			byte dl_237 = ecx_233->b0000;
			if ((dl_237 & 0x01) != 0x00)
			{
				eax_230[0x00405841] = (struct Eq_2251) (eax_230[0x00405841] | 0x10);
				dl_254 = Mem256[fp - 0x0218 + eax_230:byte];
				goto l00402475;
			}
			if ((dl_237 & 0x02) != 0x00)
			{
				eax_230[0x00405841] = (struct Eq_2251) (eax_230[0x00405841] | 0x20);
				dl_254 = Mem250[fp - 0x0318 + eax_230:byte];
l00402475:
				eax_230[0x00405740] = (struct Eq_2251) dl_254;
			}
			else
				eax_230[0x00405740] = (struct Eq_2251) 0x00;
			++eax_230;
			++ecx_233;
		} while (eax_230 < (struct Eq_2251 *) 0x0100);
	}
	else
	{
		struct Eq_2170 * eax_22 = null;
		do
		{
			byte cl_49;
			byte al_47 = (byte) eax_22;
			if (eax_22 >= (struct Eq_2170 *) 0x41 && eax_22 <= (struct Eq_2170 *) 0x5A)
			{
				eax_22[0x00405841] = (struct Eq_2170) (eax_22[0x00405841] | 0x10);
				cl_49 = al_47 + 0x20;
				goto l004024BF;
			}
			if (eax_22 >= (struct Eq_2170 *) 0x61 && eax_22 <= (struct Eq_2170 *) 122)
			{
				eax_22[0x00405841] = (struct Eq_2170) (eax_22[0x00405841] | 0x20);
				cl_49 = al_47 - 0x20;
l004024BF:
				eax_22[0x00405740] = (struct Eq_2170) cl_49;
			}
			else
				eax_22[0x00405740] = (struct Eq_2170) 0x00;
			++eax_22;
		} while (eax_22 < (struct Eq_2170 *) 0x0100);
	}
}

// 004024EE: void fn004024EE()
// Called from:
//      fn00401715
//      fn0040176D
//      fn00401826
void fn004024EE()
{
	if (g_dw405A68 == 0x00)
	{
		fn0040212A(~0x02);
		g_dw405A68 = 0x01;
	}
}

// 0040250A: Register word32 fn0040250A(Stack Eq_8 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      fn0040176D
//      fn00401A73
word32 fn0040250A(Eq_8 dwArg04, ptr32 & ebpOut)
{
	if (dwArg04 != 0x00)
	{
		Eq_8 eax_13 = fn00402AA3(dwArg04);
		if (eax_13 != 0x00)
		{
			ptr32 ebp_45;
			word32 ebx_41 = fn00402ACE(eax_13, dwArg04, out ebp_45);
			ebpOut = ebp_45;
			return ebx_41;
		}
		HeapFree(g_t405948, 0x00, dwArg04);
	}
	ebpOut = ebp;
	return ebx;
}

// 00402540: Register word32 fn00402540(Stack (ptr32 Eq_732) dwArg04, Stack Eq_8 dwArg08)
// Called from:
//      fn0040176D
//      fn00401F95
word32 fn00402540(struct Eq_732 * dwArg04, Eq_8 dwArg08)
{
	return fn004025B1(dwArg04, dwArg08);
}

// 00402550: void fn00402550(Stack (ptr32 Eq_1756) dwArg04, Stack Eq_8 dwArg08)
// Called from:
//      fn00401F95
void fn00402550(struct Eq_1756 * dwArg04, Eq_8 dwArg08)
{
	struct Eq_1756 * ecx_12 = dwArg04;
	if ((dwArg04 & 0x03) != 0x00)
	{
		do
		{
			++ecx_12;
			if (ecx_12->dw0000 == 0x00)
				goto l0040259F;
		} while ((ecx_12 & 0x03) != 0x00);
	}
	do
	{
		do
		{
			word32 eax_24 = ecx_12->dw0000;
			ecx_12 += 4;
		} while (((~eax_24 ^ eax_24 + 0x7EFEFEFF) & 0x81010100) == 0x00);
		ui32 eax_33 = ecx_12->dwFFFFFFFC;
		byte ah_49 = SLICE(eax_33, byte, 8);
		if ((byte) eax_33 == 0x00)
		{
			fn004025B1(ecx_12 - 0x04, dwArg08);
			return;
		}
		if (ah_49 == 0x00)
		{
			fn004025B1(ecx_12 - 0x03, dwArg08);
			return;
		}
		if ((eax_33 & 0x00FF0000) == 0x00)
		{
			fn004025B1(ecx_12 - 0x02, dwArg08);
			return;
		}
	} while ((eax_33 & 0xFF000000) != 0x00);
l0040259F:
	struct Eq_732 * edi_80 = ecx_12 - 0x01;
	fn004025B1(edi_80, dwArg08);
}

// 004025B1: Register (ptr32 Eq_732) fn004025B1(Register (ptr32 Eq_732) edi, Stack Eq_8 dwArg0C)
// Called from:
//      fn00402540
//      fn00402550
struct Eq_732 * fn004025B1(struct Eq_732 * edi, Eq_8 dwArg0C)
{
	Eq_2516 edx_125;
	Eq_8 ecx_12 = dwArg0C;
	if ((dwArg0C & 0x03) != 0x00)
	{
		do
		{
			byte dl_11 = *ecx_12;
			ecx_12 = (word32) ecx_12 + 1;
			edx_125 = SEQ(edx_24_8, dl_11);
			if (dl_11 == 0x00)
				goto l00402628;
			edi->b0000 = dl_11;
			++edi;
		} while ((ecx_12 & 0x03) != 0x00);
	}
l004025D6:
	edx_125 = *ecx_12;
	Eq_2544 eax_25 = *ecx_12;
	byte dl_34 = (byte) edx_125;
	byte dh_48 = SLICE(edx_125, byte, 8);
	Eq_2552 dx_52 = (word16) edx_125;
	ecx_12 = (word32) ecx_12 + 4;
	if (((~eax_25 ^ (word32) eax_25 + 0x7EFEFEFF) & 0x81010100) != 0x00)
	{
		if (dl_34 == 0x00)
		{
l00402628:
			edi->b0000 = (byte) edx_125;
			return;
		}
		if (dh_48 == 0x00)
		{
			edi->b0000 = (byte) dx_52;
			return;
		}
		if ((edx_125 & 0x00FF0000) == 0x00)
		{
			edi->b0000 = (byte) dx_52;
			edi[2] = (struct Eq_732) 0x00;
			return;
		}
		if ((edx_125 & 0xFF000000) == 0x00)
		{
			edi->b0000 = (byte) edx_125;
			return;
		}
	}
	edi->b0000 = (byte) edx_125;
	edi += 4;
	goto l004025D6;
}

// 00402630: Register word32 fn00402630(Stack Eq_8 dwArg04)
// Called from:
//      fn0040176D
//      fn00401826
//      fn00401A73
//      fn00401BA5
word32 fn00402630(Eq_8 dwArg04)
{
	return fn00402642(dwArg04, g_dw4056FC);
}

// 00402642: Register word32 fn00402642(Stack Eq_8 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn00402630
word32 fn00402642(Eq_8 dwArg04, word32 dwArg08)
{
	word32 eax_12;
	if (dwArg04 <= ~0x1F)
	{
		do
		{
			eax_12 = fn0040266E(dwArg04);
			if (eax_12 != 0x00 || dwArg08 == eax_12)
				return eax_12;
		} while (fn004037D6(dwArg04) != 0x00);
	}
	eax_12 = 0x00;
	return eax_12;
}

// 0040266E: Register Eq_8 fn0040266E(Stack Eq_8 dwArg04)
// Called from:
//      fn00402642
Eq_8 fn0040266E(Eq_8 dwArg04)
{
	Eq_8 eax_12;
	Eq_8 esi_31 = dwArg04;
	if (dwArg04 <= g_t405270)
	{
		eax_12 = fn00402DF9(dwArg04);
		if (eax_12 != 0x00)
			return eax_12;
	}
	if (dwArg04 == 0x00)
		esi_31.u0 = 0x01;
	eax_12 = HeapAlloc(g_t405948, 0x00, (word32) esi_31 + 0x0F & ~0x0F);
	return eax_12;
}

// 004026B0: Register ptr32 fn004026B0(Stack Eq_8 dwArg04)
// Called from:
//      fn0040176D
//      fn00401F95
ptr32 fn004026B0(Eq_8 dwArg04)
{
	Eq_8 ecx_12 = dwArg04;
	if ((dwArg04 & 0x03) != 0x00)
	{
		do
		{
			ecx_12 = (word32) ecx_12 + 1;
			if (*ecx_12 == 0x00)
				return ecx_12 - 0x01 - dwArg04;
		} while ((ecx_12 & 0x03) != 0x00);
	}
	do
	{
		do
		{
			word32 eax_26 = *ecx_12;
			ecx_12 = (word32) ecx_12 + 4;
		} while (((~eax_26 ^ eax_26 + 0x7EFEFEFF) & 0x81010100) == 0x00);
		ui32 eax_35 = *((word32) ecx_12 - 4);
		byte ah_45 = SLICE(eax_35, byte, 8);
		if ((byte) eax_35 == 0x00)
			return ecx_12 - 0x04 - dwArg04;
		if (ah_45 == 0x00)
			return ecx_12 - 0x03 - dwArg04;
		if ((eax_35 & 0x00FF0000) == 0x00)
			return ecx_12 - 0x02 - dwArg04;
	} while ((eax_35 & 0xFF000000) != 0x00);
	return ecx_12 - 0x01 - dwArg04;
}

// 00402730: Register Eq_8 fn00402730(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08, Stack Eq_1356 dwArg0C, Register out Eq_8 ediOut)
// Called from:
//      fn00401A73
Eq_8 fn00402730(Eq_8 dwArg04, Eq_8 dwArg08, Eq_1356 dwArg0C, union Eq_8 & ediOut)
{
	Eq_8 esi_14 = dwArg08;
	Eq_8 edi_16 = dwArg04;
	word32 eax_19 = dwArg0C + dwArg08;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_19)
	{
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (dwArg0C < (CHAR *) 0x04)
			{
				switch (dwArg0C - (CHAR *) 0x04)
				{
				case 0x00:
					ediOut = edi;
					return esi;
				case 0x01:
					*dwArg04 = *dwArg08;
					ediOut = edi;
					return esi;
				case 0x02:
					*dwArg04 = *dwArg08;
					*((word32) dwArg04 + 1) = *((word32) dwArg08 + 1);
					ediOut = edi;
					return esi;
				case 0x03:
					*dwArg04 = *dwArg08;
					*((word32) dwArg04 + 1) = *((word32) dwArg08 + 1);
					*((word32) dwArg04 + 2) = *((word32) dwArg08 + 2);
					ediOut = edi;
					return esi;
				}
			}
		}
		else
		{
			uint32 ecx_167 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (dwArg0C >> 0x02)
				{
				case 0x00:
					goto l0040286F;
				case 0x01:
					goto l0040285C;
				case 0x02:
					goto l00402854;
				case 0x03:
					goto l0040284C;
				case 0x04:
					goto l00402844;
				case 0x05:
					goto l0040283C;
				case 0x06:
					break;
				case 0x07:
					*((word32) (dwArg04 - 0x1C) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x1C)[dwArg0C >> 0x02];
					break;
				}
				*((word32) (dwArg04 - 0x18) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x18)[dwArg0C >> 0x02];
l0040283C:
				*((word32) (dwArg04 - 0x14) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x14)[dwArg0C >> 0x02];
l00402844:
				*((word32) (dwArg04 - 0x10) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x10)[dwArg0C >> 0x02];
l0040284C:
				*((word32) (dwArg04 - 0x0C) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x0C)[dwArg0C >> 0x02];
l00402854:
				*((word32) (dwArg04 - 0x08) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x08)[dwArg0C >> 0x02];
l0040285C:
				(dwArg04 - 0x04)[dwArg0C >> 0x02] = (dwArg08 - 0x04)[dwArg0C >> 0x02];
				Eq_2786 eax_210 = (dwArg0C >> 0x02) * 0x04;
				esi_14 = dwArg08 + eax_210;
				edi_16 = dwArg04 + eax_210;
l0040286F:
				(*((char *) g_a402878 + (dwArg0C & 0x03) * 0x04))();
				ediOut = edi_16;
				return esi_14;
			}
			else
			{
				for (; ecx_167 != 0x00; --ecx_167)
				{
					*edi_16 = *esi_14;
					esi_14 = (word32) esi_14 + 4;
					edi_16 = (word32) edi_16 + 4;
				}
				(*((char *) g_a402878 + (dwArg0C & 0x03) * 0x04))();
				ediOut = edi_16;
				return esi_14;
			}
		}
	}
	else
	{
		Eq_8 esi_107 = (word32) dwArg08 + (dwArg0C - 0x04);
		Eq_8 edi_108 = (word32) dwArg04 + (dwArg0C - 0x04);
		if ((edi_108 & 0x03) != 0x00)
		{
			if (dwArg0C < (CHAR *) 0x04)
			{
				switch (dwArg0C)
				{
				case 0x00:
					ediOut = edi;
					return esi;
				case 0x01:
					*((word32) edi_108 + 3) = *((word32) esi_107 + 3);
					ediOut = edi;
					return esi;
				case 0x02:
					*((word32) edi_108 + 3) = *((word32) esi_107 + 3);
					*((word32) edi_108 + 2) = *((word32) esi_107 + 2);
					ediOut = edi;
					return esi;
				case 0x03:
					*((word32) edi_108 + 3) = *((word32) esi_107 + 3);
					*((word32) edi_108 + 2) = *((word32) esi_107 + 2);
					*((word32) edi_108 + 1) = *((word32) esi_107 + 1);
					ediOut = edi;
					return esi;
				}
			}
		}
		else
		{
			uint32 ecx_109 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (-(dwArg0C >> 0x02))
				{
				case 0x00:
					(*((char *) g_a402A10 + (dwArg0C & 0x03) * 0x04))();
					ediOut = edi_108;
					return esi_107;
				}
			}
			else
			{
				for (; ecx_109 != 0x00; --ecx_109)
				{
					*edi_108 = *esi_107;
					esi_107 -= 4;
					edi_108 -= 4;
				}
				(*((char *) g_a402A10 + (dwArg0C & 0x03) * 0x04))();
				ediOut = edi_108;
				return esi_107;
			}
		}
	}
}

<anonymous> * g_a402878[] = // 00402878
	{
	};
<anonymous> * g_a402A10[] = // 00402A10
	{
	};
// 00402A65: Register Eq_8 fn00402A65()
// Called from:
//      fn00401D50
Eq_8 fn00402A65()
{
	Eq_8 eax_11 = HeapAlloc(g_t405948, 0x00, 0x0140);
	g_t405718 = eax_11;
	if (eax_11 == 0x00)
		return eax_11;
	g_t405710.u0 = 0x00;
	g_dw405714 = 0x00;
	g_t40570C = eax_11;
	g_dw405704 = 0x10;
	return 0x01;
}

// 00402AA3: Register Eq_8 fn00402AA3(Stack Eq_8 dwArg04)
// Called from:
//      fn0040250A
Eq_8 fn00402AA3(Eq_8 dwArg04)
{
	Eq_8 eax_13 = g_t405718;
	Eq_8 ecx_8 = (word32) eax_13 + g_dw405714 * 0x14;
	while (eax_13 < ecx_8)
	{
		if (dwArg04 - *((byte) eax_13.u0 + 0x0C) < 0x00100000)
			return eax_13;
		eax_13 = (byte) eax_13.u0 + 20;
	}
	eax_13.u0 = 0x00;
	return eax_13;
}

// 00402ACE: Register word32 fn00402ACE(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08, Register out ptr32 ebpOut)
// Called from:
//      fn0040250A
word32 fn00402ACE(Eq_8 dwArg04, Eq_8 dwArg08, ptr32 & ebpOut)
{
	Eq_8 dwArg08_515;
	int32 ebx_20 = *((word32) dwArg08 - 4);
	Eq_3024 esi_19 = dwArg08 - *((word32) dwArg04 + 0x0C);
	Eq_8 eax_17 = *((word32) dwArg04 + 16);
	int32 ecx_34 = ebx_20 - 0x01 + ((word32) dwArg08 - 4);
	struct Eq_3040 * ebp_457 = fp - 4;
	struct Eq_3044 * edx_21 = (word32) dwArg08 - 4;
	Eq_3046 esi_25 = esi_19 >> 0x0F;
	int32 edi_27 = *((word32) dwArg08 - 8);
	int32 ebx_109 = ebx_20 - 0x01;
	word32 * ecx_31 = (word32) eax_17 + ((esi_19 >> 0x0F) *s 0x0204 + 0x0144);
	int32 dwLoc10_511 = ebx_20 - 0x01;
	dwArg08_515 = dwArg08;
	if (((byte) ecx_34 & 0x01) == 0x00)
	{
		Eq_8 ecx_43 = (ecx_34 >> 0x04) - 0x01;
		dwArg08_515 = ecx_43;
		if (ecx_43 > 0x3F)
			dwArg08_515.u0 = 0x3F;
		if (ebx_20 + 0x03 + ((word32) dwArg08 - 4) == (ebx_20 + 0x07) + ((word32) dwArg08 - 4))
		{
			byte cl_83 = (byte) dwArg08_515;
			if (dwArg08_515 < 0x20)
			{
				uint32 edi_86 = ~(0x80000000 >> cl_83);
				*((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044)) &= edi_86;
				word32 ecx_85 = dwArg08_515 + 0x04 + eax_17;
				Eq_3214 v17_91 = *ecx_85 - 0x01;
				*ecx_85 = v17_91;
				if (v17_91 == 0x00)
					*dwArg04 &= edi_86;
			}
			else
			{
				uint32 edi_67 = ~(0x80000000 >> (byte) dwArg08_515 + 0xE0);
				*((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4)) &= edi_67;
				word32 ecx_66 = dwArg08_515 + 0x04 + eax_17;
				byte v20_73 = *ecx_66 - 0x01;
				*ecx_66 = v20_73;
				if (v20_73 == 0x00)
					*((word32) dwArg04 + 4) &= edi_67;
			}
		}
		*((char *) (ebx_20 + 0x07 + ((word32) dwArg08 - 4)) + 4) = ebx_20 + 0x03 + ((word32) dwArg08 - 4);
		*((char *) (ebx_20 + 0x03 + ((word32) dwArg08 - 4)) + 8) = ebx_20 + 0x07 + ((word32) dwArg08 - 4);
		ebx_109 = ebx_20 - 0x01 + ecx_34;
		dwLoc10_511 = ebx_109;
	}
	Eq_3069 edi_115 = ebx_109 >> 0x04;
	Eq_8 edi_116 = edi_115 - 0x01;
	if (edi_115 > 0x40)
		edi_116.u0 = 0x3F;
	if ((edi_27 & 0x01) == 0x00)
	{
		Eq_8 ecx_145 = (edi_27 >> 0x04) - 0x01;
		struct Eq_3044 * edx_138 = (word32) dwArg08 - 4 - edi_27;
		dwArg08_515 = ecx_145;
		if (ecx_145 > 0x3F)
		{
			dwArg08_515.u0 = 0x3F;
			ecx_145.u0 = 0x3F;
		}
		ebx_109 += edi_27;
		dwLoc10_511 = ebx_109;
		edi_116 = (ebx_109 >> 0x04) - 0x01;
		if (edi_116 > 0x3F)
			edi_116.u0 = 0x3F;
		if (ecx_145 != edi_116)
		{
			if (edx_138->ptr0004 == edx_138->ptr0008)
			{
				byte cl_211 = (byte) dwArg08_515;
				if (dwArg08_515 < 0x20)
				{
					uint32 edx_214 = ~(0x80000000 >> cl_211);
					*((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044)) &= edx_214;
					word32 ecx_213 = dwArg08_515 + 0x04 + eax_17;
					Eq_3214 v23_219 = *ecx_213 - 0x01;
					*ecx_213 = v23_219;
					if (v23_219 == 0x00)
						*dwArg04 &= edx_214;
				}
				else
				{
					uint32 edx_191 = ~(0x80000000 >> (byte) dwArg08_515 + 0xE0);
					*((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4)) &= edx_191;
					word32 ecx_190 = dwArg08_515 + 0x04 + eax_17;
					Eq_3214 v26_201 = *ecx_190 - 0x01;
					*ecx_190 = v26_201;
					if (v26_201 == 0x00)
						*((word32) dwArg04 + 4) &= edx_191;
				}
			}
			edx_138->ptr0008->ptr0004 = edx_138->ptr0004;
			edx_138->ptr0004->ptr0008 = edx_138->ptr0008;
		}
		edx_21 = edx_138;
	}
	struct Eq_3101 * esp_366 = fp - 0x24;
	if ((edi_27 & 0x01) != 0x00 || dwArg08_515 != edi_116)
	{
		edx_21->ptr0004 = (ecx_31 + edi_116 * 0x08)[1];
		word32 ecx_261 = ecx_31 + edi_116 * 0x08;
		edx_21->ptr0008 = ecx_261;
		ecx_261->ptr0004 = edx_21;
		edx_21->ptr0004->ptr0008 = edx_21;
		if (edx_21->ptr0004 == edx_21->ptr0008)
		{
			byte cl_273 = Mem265[edi_116 + 0x04 + eax_17:byte];
			Mem278[edi_116 + 0x04 + eax_17:byte] = cl_273 + 0x01;
			if (edi_116 < 0x20)
			{
				if (cl_273 == 0x00)
					*dwArg04 |= 0x80000000 >> (byte) edi_116;
				word32 eax_326 = eax_17 + 0x44 + (esi_19 >>u 0x0F) * 0x04;
				*eax_326 |= 0x80000000 >> (byte) edi_116;
			}
			else
			{
				if (cl_273 == 0x00)
					*((word32) dwArg04 + 4) |= 0x80000000 >> (byte) edi_116 - 0x20;
				word32 eax_302 = eax_17 + 0xC4 + (esi_19 >>u 0x0F) * 0x04;
				*eax_302 |= 0x80000000 >> (byte) edi_116 - 0x20;
			}
			ebx_109 = dwLoc10_511;
		}
	}
	edx_21->dw0000 = ebx_109;
	edx_21[(ebx_109 - 0x04) / 0x0C] = (struct Eq_3044) ebx_109;
	word32 v31_352 = *ecx_31 - 0x01;
	*ecx_31 = v31_352;
	if (v31_352 != 0x00)
	{
l00402DF4:
		word32 ebx_497 = esp_366->dw0008;
		ebpOut = ebp_457->ptr0000;
		return ebx_497;
	}
	Eq_8 eax_417;
	Eq_8 eax_356 = g_t405710;
	if (eax_356 != 0x00)
	{
		VirtualFree((word32) *((word32) eax_356 + 0x0C) + (g_t405708 << 0x0F), 0x8000, 0x4000);
		Eq_8 eax_384 = g_t405710;
		*((word32) eax_384 + 8) |= 0x80000000 >> g_t405708;
		*((word32) *((word32) g_t405710 + 16) + (g_t405708 * 0x04 + 0x00C4)) = 0x00;
		Eq_8 eax_398 = *((word32) g_t405710 + 16);
		--*((word32) eax_398 + 67);
		Eq_8 eax_401 = g_t405710;
		if (*((word32) *((word32) eax_401 + 16) + 67) == 0x00)
		{
			*((word32) eax_401 + 4) &= ~0x01;
			eax_401 = g_t405710;
		}
		if (*((word32) eax_401 + 8) == ~0x00)
		{
			VirtualFree(*((word32) eax_401 + 0x0C), 0x00, 0x8000);
			HeapFree(g_t405948, 0x00, *((word32) g_t405710 + 16));
			Eq_8 eax_445 = g_t405710;
			ebp_457 = fn00403800(eax_445, (word32) eax_445 + 20, (word32) g_t405718 + ((g_dw405714 * 0x14 - eax_445) - 0x14), out esi_25);
			eax_417 = ebp_457->t0008;
			--g_dw405714;
			esp_366 = fp - 0x30;
			if (eax_417 > g_t405710)
				eax_417 -= 0x14;
			g_t40570C = g_t405718;
l00402DE9:
			g_t405710 = eax_417;
			g_t405708 = esi_25;
			goto l00402DF4;
		}
	}
	esp_366 = fp - 0x24;
	eax_417 = dwArg04;
	goto l00402DE9;
}

// 00402DF9: Register ptr32 fn00402DF9(Stack Eq_8 dwArg04)
// Called from:
//      fn0040266E
ptr32 fn00402DF9(Eq_8 dwArg04)
{
	uint32 dwLoc10_549;
	uint32 esi_178;
	uint32 dwLoc0C_550;
	int32 ecx_25 = (word32) dwArg04 + 23 & ~0x0F;
	Eq_8 edx_10 = g_t405718;
	int32 ecx_28 = (ecx_25 >> 0x04) - 0x01;
	Eq_8 edi_21 = (word32) edx_10 + g_dw405714 * 0x14;
	byte cl_40 = (byte) ecx_28;
	if (ecx_28 < 0x20)
	{
		esi_178 = ~0x00 >> cl_40;
		dwLoc0C_550 = ~0x00;
		dwLoc10_549 = esi_178;
	}
	else
	{
		esi_178 = 0x00;
		dwLoc10_549 = 0x00;
		dwLoc0C_550 = ~0x00 >> (byte) ecx_28 + 0xE0;
	}
	Eq_8 eax_48 = g_t40570C;
	Eq_8 ebx_112 = eax_48;
	Eq_8 dwArg04_553 = eax_48;
	if (eax_48 < edi_21)
	{
		while ((*((word32) ebx_112 + 4) & dwLoc0C_550 | *ebx_112 & esi_178) == 0x00)
		{
			ebx_112 = (word32) ebx_112 + 20;
			dwArg04_553 = ebx_112;
			if (ebx_112 >= edi_21)
				break;
		}
	}
	ptr32 eax_483;
	if (ebx_112 == edi_21)
	{
		ebx_112 = edx_10;
		while (true)
		{
			bool v32_533 = ebx_112 != eax_48;
			dwArg04_553 = ebx_112;
			if (ebx_112 >= eax_48)
				break;
			if ((*((word32) ebx_112 + 4) & dwLoc0C_550 | *ebx_112 & esi_178) != 0x00)
			{
				v32_533 = ebx_112 != eax_48;
				break;
			}
			ebx_112 = (word32) ebx_112 + 20;
		}
		if (!v32_533)
		{
			while (true)
			{
				bool v35_536 = ebx_112 != edi_21;
				if (ebx_112 >= edi_21)
					break;
				if (*((word32) ebx_112 + 8) != 0x00)
				{
					v35_536 = ebx_112 != edi_21;
					break;
				}
				ebx_112 = (word32) ebx_112 + 20;
				dwArg04_553 = ebx_112;
			}
			if (!v35_536)
			{
				ebx_112 = edx_10;
				while (true)
				{
					bool v38_539 = ebx_112 != eax_48;
					dwArg04_553 = ebx_112;
					if (ebx_112 >= eax_48)
						break;
					if (*((word32) ebx_112 + 8) != 0x00)
					{
						v38_539 = ebx_112 != eax_48;
						break;
					}
					ebx_112 = (word32) ebx_112 + 20;
				}
				if (!v38_539)
				{
					Eq_8 eax_125 = fn00403102();
					ebx_112 = eax_125;
					dwArg04_553 = eax_125;
					if (eax_125 == 0x00)
					{
l00402EE7:
						eax_483 = 0x00;
						return eax_483;
					}
				}
			}
			**((word32) ebx_112 + 16) = fn004031B3(ebx_112);
			if (**((word32) ebx_112 + 16) == ~0x00)
				goto l00402EE7;
		}
	}
	g_t40570C = ebx_112;
	struct Eq_3699 * eax_164 = *((word32) ebx_112 + 16);
	Eq_3046 edx_165 = eax_164->t0000;
	Eq_3046 dwLoc08_565 = edx_165;
	if (edx_165 == ~0x00 || ((eax_164->a00C4)[edx_165] & dwLoc0C_550 | (eax_164->a0044)[edx_165] & esi_178) == 0x00)
	{
		dwLoc08_565.u0 = 0x00;
		ui32 * ecx_200 = eax_164->a0044 + 33;
		esi_178 = dwLoc10_549;
		if ((eax_164->a00C4[0] & dwLoc0C_550 | (eax_164->a0044)[0] & dwLoc10_549) == 0x00)
		{
			do
			{
				ecx_200 = ecx_834 + 1;
				dwLoc08_565 = (word32) dwLoc08_565.u0 + 1;
				ecx_834 = ecx_200;
			} while ((*ecx_834 & dwLoc0C_550 | dwLoc10_549 & *ecx_200) == 0x00);
		}
		edx_165 = dwLoc08_565;
	}
	int32 edi_226 = 0x00;
	struct Eq_3761 * ecx_231 = eax_164 + (edx_165 *s 0x0204 + 0x0144) / 0x00C4;
	int32 ecx_237 = eax_164->a0044[edx_165] & esi_178;
	if (ecx_237 == 0x00)
	{
		ecx_237 = eax_164->a00C4[edx_165] & dwLoc0C_550;
		edi_226 = 0x20;
	}
	for (; ecx_237 >= 0x00; ecx_237 <<= 0x01)
		++edi_226;
	struct Eq_3812 * edx_267 = ecx_231->a0004[edi_226].ptr0000;
	int32 ecx_269 = *edx_267 - ecx_25;
	int32 esi_273 = (ecx_269 >> 0x04) - 0x01;
	if (esi_273 > 0x3F)
		esi_273 = 0x3F;
	if (esi_273 == edi_226)
	{
l004030B0:
		if (ecx_269 != 0x00)
		{
			*edx_267 = ecx_269;
			edx_267[(ecx_269 - 0x04) / 0x0C] = (struct Eq_3812) ecx_269;
		}
		goto l004030BF;
	}
	if (edx_267->ptr0004 == edx_267->ptr0008)
	{
		if (edi_226 < 0x20)
		{
			uint32 ebx_324 = ~(0x80000000 >> (byte) edi_226);
			eax_164->a0044[dwLoc08_565] = ebx_324 & (eax_164->a0044)[dwLoc08_565];
			byte * edi_323 = (char *) &eax_164->t0000 + 4 + edi_226;
			byte v19_329 = *edi_323 - 0x01;
			*edi_323 = v19_329;
			if (v19_329 == 0x00)
			{
				*dwArg04_553 &= ebx_324;
				ebx_112 = dwArg04_553;
				goto l0040300C;
			}
l00403009:
			ebx_112 = dwArg04_553;
			goto l0040300C;
		}
		ui32 * ecx_301 = eax_164->a00C4 + dwLoc08_565;
		uint32 ebx_302 = ~(0x80000000 >> (byte) edi_226 - 0x20);
		*ecx_301 &= ebx_302;
		byte * edi_300 = (char *) &eax_164->t0000 + 4 + edi_226;
		byte v22_307 = *edi_300 - 0x01;
		*edi_300 = v22_307;
		if (v22_307 != 0x00)
			goto l00403009;
		*((word32) dwArg04_553 + 4) &= ebx_302;
		ebx_112 = dwArg04_553;
	}
l0040300C:
	edx_267->ptr0008->ptr0004 = edx_267->ptr0004;
	edx_267->ptr0004->ptr0008 = edx_267->ptr0008;
	if (ecx_269 == 0x00)
	{
l004030BF:
		int32 * edx_449 = edx_267 + ecx_269 / 0x0C;
		*edx_449 = ecx_25 + 0x01;
		(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(edx_449 - 0x04)[ecx_25 / 4].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0].a0000)[0] = ecx_25 + 0x01;
		word32 ecx_454 = ecx_231->dw0000;
		ecx_231->dw0000 = ecx_454 + 0x01;
		if (ecx_454 == 0x00 && (ebx_112 == g_t405710 && dwLoc08_565 == g_t405708))
			g_t405710.u0 = 0x00;
		eax_164->t0000 = dwLoc08_565;
		eax_483 = edx_449 + 1;
		return eax_483;
	}
	edx_267->ptr0004 = ecx_231->a0004[esi_273].ptr0000;
	struct Eq_3812 * ecx_359 = ecx_231 + esi_273 * 2;
	edx_267->ptr0008 = ecx_359;
	ecx_359->ptr0004 = edx_267;
	edx_267->ptr0004->ptr0008 = edx_267;
	if (edx_267->ptr0004 == edx_267->ptr0008)
	{
		byte cl_370 = eax_164[(esi_273 + 0x04) / 0x00C4];
		if (esi_273 < 0x20)
		{
			eax_164[(esi_273 + 0x04) / 0x00C4] = (struct Eq_3699) (cl_370 + 0x01);
			if (cl_370 == 0x00)
				*ebx_112 |= 0x80000000 >> (byte) esi_273;
			eax_164->a0044[dwLoc08_565] |= 0x80000000 >> (byte) esi_273;
		}
		else
		{
			eax_164[(esi_273 + 0x04) / 0x00C4] = (struct Eq_3699) (cl_370 + 0x01);
			if (cl_370 == 0x00)
				*((word32) ebx_112 + 4) |= 0x80000000 >> (byte) esi_273 - 0x20;
			ui32 * edi_393 = eax_164->a00C4 + dwLoc08_565;
			*edi_393 |= 0x80000000 >> (byte) esi_273 - 0x20;
		}
	}
	goto l004030B0;
}

// 00403102: Register (ptr32 Eq_4135) fn00403102()
// Called from:
//      fn00402DF9
struct Eq_4135 * fn00403102()
{
	struct Eq_4135 * eax_126;
	ui32 eax_36 = g_dw405714;
	ui32 ecx_6 = g_dw405704;
	if (eax_36 == ecx_6)
	{
		Eq_8 eax_28 = HeapReAlloc(g_t405948, 0x00, g_t405718, ecx_6 + 0x50 + ecx_6 * 0x04 << 0x02);
		if (eax_28 == 0x00)
		{
l00403195:
			eax_126 = null;
			return eax_126;
		}
		g_dw405704 += 0x10;
		g_t405718 = eax_28;
		eax_36 = g_dw405714;
	}
	struct Eq_4135 * esi_49 = (word32) g_t405718 + eax_36 * 0x14;
	Eq_8 eax_50 = HeapAlloc(g_t405948, 0x08, 0x41C4);
	esi_49->t0010 = eax_50;
	if (eax_50 != 0x00)
	{
		Eq_8 eax_64 = VirtualAlloc(0x00, 0x00100000, 0x2000, 0x04);
		esi_49->t000C = eax_64;
		if (eax_64 != 0x00)
		{
			esi_49->dw0008 = ~0x00;
			esi_49->dw0000 = 0x00;
			esi_49->dw0004 = 0x00;
			++g_dw405714;
			*esi_49->t0010 = ~0x00;
			eax_126 = esi_49;
			return eax_126;
		}
		HeapFree(g_t405948, 0x00, esi_49->t0010);
	}
	goto l00403195;
}

// 004031B3: Register int32 fn004031B3(Stack Eq_8 dwArg04)
// Called from:
//      fn00402DF9
int32 fn004031B3(Eq_8 dwArg04)
{
	struct Eq_4246 * esi_21 = *((word32) dwArg04 + 16);
	int32 eax_166;
	int32 ebx_168 = 0x00;
	for (eax_166 = *((word32) dwArg04 + 8); eax_166 >= 0x00; eax_166 <<= 0x01)
		++ebx_168;
	word32 edx_37;
	struct Eq_4258 * eax_40 = esi_21 + (ebx_168 *s 0x0204 + 0x0144) / 0x00C4;
	eax_43 = eax_40;
	for (edx_37 = 0x3F; edx_37 != 0x00; --edx_37)
	{
		struct Eq_4258 * eax_43;
		eax_43[1] = (struct Eq_4258) eax_43;
		eax_43->dw0004 = eax_43;
		++eax_43;
	}
	int32 eax_149;
	Eq_8 edi_60 = (word32) *((word32) dwArg04 + 0x0C) + (ebx_168 << 0x0F);
	if (VirtualAlloc(edi_60, 0x8000, 0x1000, 0x04) == 0x00)
		eax_149 = ~0x00;
	else
	{
		if (edi_60 <=u edi_60 + 0x7000)
		{
			word32 eax_75 = edi_60 + 0x10;
			do
			{
				*((word32) eax_75 - 8) = ~0x00;
				*((word32) eax_75 + 0x0FEC) = ~0x00;
				*((word32) eax_75 - 4) = 0x0FF0;
				Mem86[eax_75 + 0x00:word32] = eax_75 + 0x0FFC;
				Mem88[eax_75 + 0x04:word32] = eax_75 + ~0x1003;
				*((word32) eax_75 + 0x0FE8) = 0x0FF0;
				eax_75 += 0x1000;
			} while (eax_75 - 0x10 <=u edi_60 + 0x7000);
		}
		Mem110[eax_40 + 0x01FC:word32] = edi_60 + 0x0C;
		*((word32) edi_60 + 20) = eax_40 + 63;
		Mem114[eax_40 + 0x0200:word32] = edi_60 + 0x700C;
		*((word32) edi_60 + 28688) = eax_40 + 63;
		esi_21->a0044[ebx_168] = 0x00;
		esi_21->a00C4[ebx_168] = 0x01;
		byte al_125 = esi_21->b0043;
		esi_21->b0043 = al_125 + 0x01;
		if (al_125 == 0x00)
			*((word32) dwArg04 + 4) |= 0x01;
		*((word32) dwArg04 + 8) &= ~(0x80000000 >> (byte) ebx_168);
		eax_149 = ebx_168;
	}
	return eax_149;
}

// 004032AE: void fn004032AE()
// Called from:
//      fn00401F95
void fn004032AE()
{
	word32 ebx_65 = 0x00;
	if (g_t4056C8 == null)
	{
		Eq_3 eax_18 = LoadLibraryA(0x0040441C);
		if (eax_18 == 0x00)
			return;
		Eq_4401 eax_28 = GetProcAddress(eax_18, 0x00404410);
		g_t4056C8 = eax_28;
		if (eax_28 == null)
			return;
		g_t4056CC = GetProcAddress(eax_18, 0x00404400);
		g_t4056D0 = GetProcAddress(eax_18, 0x004043EC);
	}
	struct Eq_4404 * esp_59 = fp - 0x0C;
	Eq_4401 eax_52 = g_t4056CC;
	if (eax_52 != null)
	{
		word32 eax_62;
		eax_52();
		ebx_65 = eax_62;
		if (eax_62 != 0x00)
		{
			Eq_4401 eax_69 = g_t4056D0;
			if (eax_69 != null)
			{
				esp_59->dwFFFFFFFC = eax_62;
				word32 eax_76;
				eax_69();
				ebx_65 = eax_76;
			}
		}
	}
	struct Eq_4442 * esp_83 = esp_59 - 4;
	esp_83->dw0000 = esp_59->dw0018;
	esp_83->dwFFFFFFFC = esp_83->dw0018;
	esp_83->dwFFFFFFF8 = esp_83->dw0014;
	esp_83->dwFFFFFFF4 = ebx_65;
	g_t4056C8();
}

// 00403340: void fn00403340(Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fn00401F95
void fn00403340(byte * dwArg04, byte * dwArg08, uint32 dwArg0C)
{
	uint32 ecx_31 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	uint32 ecx_129;
	byte al_174;
	uint32 ecx_112;
	uint32 ebx_116 = dwArg0C;
	byte * esi_172 = dwArg08;
	byte * edi_109 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
		ecx_112 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 == 0x00)
			goto l00403385;
	}
	else
	{
		do
		{
			al_174 = *esi_172;
			*edi_109 = al_174;
			++esi_172;
			++edi_109;
			--ecx_31;
			if (ecx_31 == 0x00)
				return;
			if (al_174 == 0x00)
			{
				while ((edi_109 & 0x03) != 0x00)
				{
					*edi_109 = al_174;
					++edi_109;
					--ecx_31;
					if (ecx_31 == 0x00)
						return;
				}
				ebx_116 = ecx_31;
				ecx_129 = ecx_31 >> 0x02;
				if (ecx_129 != 0x00)
				{
l00403427:
					do
					{
						*edi_109 = (byte) 0x00;
						edi_109 += 4;
						--ecx_129;
					} while (ecx_129 != 0x00);
l00403431:
					al_174 = 0x00;
					ebx_116 &= 0x03;
					if (ebx_116 == 0x00)
						return;
				}
				do
				{
					*edi_109 = al_174;
					++edi_109;
l004033BE:
					--ebx_116;
				} while (ebx_116 != 0x00);
				return;
			}
		} while ((esi_172 & 0x03) != 0x00);
		ebx_116 = ecx_31;
		ecx_112 = ecx_31 >> 0x02;
		if (ecx_31 >> 0x02 == 0x00)
		{
l00403380:
			ebx_116 &= 0x03;
			if (ebx_116 == 0x00)
				return;
l00403385:
			do
			{
				al_174 = *esi_172;
				*edi_109 = al_174;
				++esi_172;
				++edi_109;
				if (al_174 == 0x00)
					goto l004033BE;
				--ebx_116;
			} while (ebx_116 != 0x00);
			return;
		}
	}
	do
	{
		Eq_4512 edx_74 = *esi_172;
		Eq_4516 eax_70 = *esi_172;
		byte dl_79 = (byte) edx_74;
		byte dh_88 = SLICE(edx_74, byte, 8);
		esi_172 += 4;
		if (((~eax_70 ^ (word32) eax_70 + 0x7EFEFEFF) & 0x81010100) != 0x00)
		{
			if (dl_79 != 0x00)
			{
				if (dh_88 != 0x00)
				{
					if ((edx_74 & 0x00FF0000) != 0x00)
					{
						if ((edx_74 & 0xFF000000) != 0x00)
							goto l004033C9;
						*edi_109 = (byte) edx_74;
					}
					else
						*edi_109 = (byte) (edx_74 & 0xFFFF);
				}
				else
					*edi_109 = (byte) (edx_74 & 0xFF);
			}
			else
				*edi_109 = (byte) 0x00;
			edi_109 += 4;
			ecx_129 = ecx_112 - 0x01;
			if (ecx_129 != 0x00)
				goto l00403427;
			goto l00403431;
		}
l004033C9:
		*edi_109 = (byte) edx_74;
		edi_109 += 4;
		--ecx_112;
	} while (ecx_112 != 0x00);
	goto l00403380;
}

// 0040343E: void fn0040343E(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08, Stack Eq_8 dwArg0C, Stack Eq_8 dwArg10, Stack Eq_8 dwArg14, Stack Eq_8 dwArg18, Stack Eq_8 dwArg1C, Stack word32 dwArg20)
// Called from:
//      fn00402369
void fn0040343E(Eq_8 dwArg04, Eq_8 dwArg08, Eq_8 dwArg0C, Eq_8 dwArg10, Eq_8 dwArg14, Eq_8 dwArg18, Eq_8 dwArg1C, word32 dwArg20)
{
	byte bArg09_427 = SLICE(dwArg08, byte, 8);
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	if (g_dw4056F4 == 0x00)
	{
		if (LCMapStringW(0x00, 0x0100, 0x0040442C, 0x01, 0x00, 0x00) != 0x00)
			g_dw4056F4 = 0x01;
		else
		{
			if (LCMapStringA(0x00, 0x0100, 0x00404428, 0x01, 0x00, 0x00) == 0x00)
				goto l004035CC;
			g_dw4056F4 = 0x02;
		}
	}
	if (dwArg10 > 0x00)
		dwArg10 = fn00403662(dwArg0C, dwArg10);
	word32 eax_99 = g_dw4056F4;
	if (eax_99 == 0x02)
	{
		LCMapStringA(dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18);
		goto l004035CE;
	}
	if (eax_99 == 0x01)
	{
		if (dwArg1C == 0x00)
			dwArg1C = g_t4056EC;
		Eq_8 eax_135 = MultiByteToWideChar(dwArg1C, (0x00 - (dwArg20 == 0x00) & 0x08) + 0x01, dwArg0C, dwArg10, 0x00, 0x00);
		if (eax_135 == 0x00)
			goto l004035CC;
		ui32 eax_143 = eax_135 * 0x02 + 0x03;
		fn00403B40(SEQ(SLICE(eax_143, word24, 8), (byte) eax_143 & 252), 0x00);
		Eq_8 esp_151 = <invalid>;
		if (esp_151 == 0x00)
			goto l004035CC;
		*((word32) esp_151 - 4) = eax_135;
		*((word32) esp_151 - 8) = esp_151;
		*((word32) esp_151 - 0x0C) = dwArg10;
		*((word32) esp_151 - 16) = dwArg0C;
		((word32) esp_151 - 20)->u0 = 0x01;
		*((word32) esp_151 - 24) = dwArg1C;
		if (MultiByteToWideChar(*((word32) esp_151 - 24), *((word32) esp_151 - 20), *((word32) esp_151 - 16), *((word32) esp_151 - 0x0C), *((word32) esp_151 - 8), *((word32) esp_151 - 4)) != 0x00)
		{
			((word32) esp_151 - 4)->u0 = 0x00;
			((word32) esp_151 - 8)->u0 = 0x00;
			*((word32) esp_151 - 0x0C) = eax_135;
			*((word32) esp_151 - 16) = esp_151;
			*((word32) esp_151 - 20) = dwArg08;
			*((word32) esp_151 - 24) = dwArg04;
			Eq_8 eax_201 = LCMapStringW(*((word32) esp_151 - 24), *((word32) esp_151 - 20), *((word32) esp_151 - 16), *((word32) esp_151 - 0x0C), *((word32) esp_151 - 8), *((word32) esp_151 - 4));
			if (eax_201 == 0x00)
				goto l004035CC;
			if ((bArg09_427 & 0x04) != 0x00)
			{
				if (dwArg18 != 0x00)
				{
					if (eax_201 > dwArg18)
						goto l004035CC;
					*((word32) esp_151 - 4) = dwArg18;
					*((word32) esp_151 - 8) = dwArg14;
					*((word32) esp_151 - 0x0C) = eax_135;
					*((word32) esp_151 - 16) = esp_151;
					*((word32) esp_151 - 20) = dwArg08;
					*((word32) esp_151 - 24) = dwArg04;
					if (LCMapStringW(*((word32) esp_151 - 24), *((word32) esp_151 - 20), *((word32) esp_151 - 16), *((word32) esp_151 - 0x0C), *((word32) esp_151 - 8), *((word32) esp_151 - 4)) == 0x00)
						goto l004035CC;
				}
			}
			else
			{
				ui32 eax_212 = eax_201 * 0x02 + 0x03;
				fn00403B40(SEQ(SLICE(eax_212, word24, 8), (byte) eax_212 & 252), *((word32) esp_151 - 4));
				Eq_8 esp_220 = <invalid>;
				if (esp_220 == 0x00)
					goto l004035CC;
				*((word32) esp_220 - 4) = eax_201;
				*((word32) esp_220 - 8) = esp_220;
				*((word32) esp_220 - 0x0C) = eax_135;
				*((word32) esp_220 - 16) = esp_151;
				*((word32) esp_220 - 20) = dwArg08;
				*((word32) esp_220 - 24) = dwArg04;
				if (LCMapStringW(*((word32) esp_220 - 24), *((word32) esp_220 - 20), *((word32) esp_220 - 16), *((word32) esp_220 - 0x0C), *((word32) esp_220 - 8), *((word32) esp_220 - 4)) == 0x00)
					goto l004035CC;
				((word32) esp_220 - 4)->u0 = 0x00;
				((word32) esp_220 - 8)->u0 = 0x00;
				if (dwArg18 == 0x00)
				{
					((word32) esp_220 - 0x0C)->u0 = 0x00;
					((word32) esp_220 - 16)->u0 = 0x00;
				}
				else
				{
					*((word32) esp_220 - 0x0C) = dwArg18;
					*((word32) esp_220 - 16) = dwArg14;
				}
				*((word32) esp_220 - 20) = eax_201;
				*((word32) esp_220 - 24) = esp_220;
				((word32) esp_220 - 28)->u0 = 0x0220;
				*((word32) esp_220 - 32) = dwArg1C;
				if (WideCharToMultiByte(*((word32) esp_220 - 32), *((word32) esp_220 - 28), *((word32) esp_220 - 24), *((word32) esp_220 - 20), *((word32) esp_220 - 16), *((word32) esp_220 - 0x0C), *((word32) esp_220 - 8), *((word32) esp_220 - 4)) == 0x00)
					goto l004035CC;
			}
l004035CE:
			fs->ptr0000 = eax_15;
			return;
		}
	}
l004035CC:
	goto l004035CE;
}

// 00403662: Register Eq_8 fn00403662(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08)
// Called from:
//      fn0040343E
Eq_8 fn00403662(Eq_8 dwArg04, Eq_8 dwArg08)
{
	Eq_8 eax_14 = dwArg04;
	word32 ecx_12 = dwArg08 - 0x01;
	if (dwArg08 != 0x00)
	{
		while (*eax_14 != 0x00)
		{
			eax_14 = (word32) eax_14 + 1;
			ecx_12 = ecx_65 - 0x01;
			ecx_65 = ecx_12;
			if (ecx_65 == 0x00)
				break;
		}
	}
	if (*eax_14 != 0x00)
		return dwArg08;
	return eax_14 - dwArg04;
}

// 0040368D: void fn0040368D(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08, Stack Eq_8 dwArg0C, Stack Eq_8 dwArg10, Stack Eq_8 dwArg14, Stack Eq_8 dwArg18, Stack word32 dwArg1C)
// Called from:
//      fn00402369
void fn0040368D(Eq_8 dwArg04, Eq_8 dwArg08, Eq_8 dwArg0C, Eq_8 dwArg10, Eq_8 dwArg14, Eq_8 dwArg18, word32 dwArg1C)
{
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	word32 eax_30 = g_dw4056F8;
	if (eax_30 == 0x00)
	{
		if (GetStringTypeW(0x01, 0x0040442C, 0x01, fp - 0x20) != 0x00)
			eax_30 = 0x01;
		else
		{
			if (GetStringTypeA(0x00, 0x01, 0x00404428, 0x01, fp - 0x20) == 0x00)
				goto l004037C2;
			eax_30 = 0x02;
		}
		g_dw4056F8 = eax_30;
	}
	if (eax_30 == 0x02)
	{
		Eq_8 eax_194 = dwArg18;
		if (dwArg18 == 0x00)
			eax_194 = g_t4056DC;
		GetStringTypeA(eax_194, dwArg04, dwArg08, dwArg0C, dwArg10);
l004037C4:
		fs->ptr0000 = eax_15;
		return;
	}
	if (eax_30 == 0x01)
	{
		if (dwArg14 == 0x00)
			dwArg14 = g_t4056EC;
		Eq_8 eax_115 = MultiByteToWideChar(dwArg14, (0x00 - (dwArg1C == 0x00) & 0x08) + 0x01, dwArg08, dwArg0C, 0x00, 0x00);
		if (eax_115 != 0x00)
		{
			ui32 eax_123 = eax_115 * 0x02 + 0x03;
			fn00403B40(SEQ(SLICE(eax_123, word24, 8), (byte) eax_123 & 252), 0x00);
			Eq_8 esp_131 = <invalid>;
			*((word32) esp_131 - 4) = eax_115 * 0x02;
			((word32) esp_131 - 8)->u0 = 0x00;
			*((word32) esp_131 - 0x0C) = esp_131;
			fn00403B70(*((word32) esp_131 - 0x0C), *((word32) esp_131 - 8), *((word32) esp_131 - 4));
			if (esp_131 != 0x00)
			{
				*((word32) esp_131 - 4) = eax_115;
				*((word32) esp_131 - 8) = esp_131;
				*((word32) esp_131 - 0x0C) = dwArg0C;
				*((word32) esp_131 - 16) = dwArg08;
				((word32) esp_131 - 20)->u0 = 0x01;
				*((word32) esp_131 - 24) = dwArg14;
				Eq_8 eax_175 = MultiByteToWideChar(*((word32) esp_131 - 24), *((word32) esp_131 - 20), *((word32) esp_131 - 16), *((word32) esp_131 - 0x0C), *((word32) esp_131 - 8), *((word32) esp_131 - 4));
				if (eax_175 != 0x00)
				{
					*((word32) esp_131 - 4) = dwArg10;
					*((word32) esp_131 - 8) = eax_175;
					*((word32) esp_131 - 0x0C) = esp_131;
					*((word32) esp_131 - 16) = dwArg04;
					GetStringTypeW(*((word32) esp_131 - 16), *((word32) esp_131 - 0x0C), *((word32) esp_131 - 8), *((word32) esp_131 - 4));
					goto l004037C4;
				}
			}
		}
	}
l004037C2:
	goto l004037C4;
}

// 004037D6: Register word32 fn004037D6(Stack Eq_8 dwArg04)
// Called from:
//      fn00402642
word32 fn004037D6(Eq_8 dwArg04)
{
	<anonymous> * eax_5 = g_ptr405700;
	if (eax_5 == null)
		return 0x00;
	word32 eax_13;
	eax_5();
	if (eax_13 == 0x00)
		return 0x00;
	return 0x01;
}

// 00403800: Register ptr32 fn00403800(Stack Eq_8 dwArg04, Stack Eq_8 dwArg08, Stack uint32 dwArg0C, Register out Eq_8 esiOut)
// Called from:
//      fn00402ACE
ptr32 fn00403800(Eq_8 dwArg04, Eq_8 dwArg08, uint32 dwArg0C, union Eq_8 & esiOut)
{
	Eq_8 esi_14 = dwArg08;
	Eq_8 edi_16 = dwArg04;
	Eq_8 eax_19 = (word32) dwArg08 + dwArg0C;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_19)
	{
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (dwArg0C < 0x04)
			{
				switch (dwArg0C)
				{
				case 0x04:
					esiOut = esi;
					return ebp;
				case 0x05:
					*dwArg04 = *dwArg08;
					esiOut = esi;
					return ebp;
				case 0x06:
					*dwArg04 = *dwArg08;
					*((word32) dwArg04 + 1) = *((word32) dwArg08 + 1);
					esiOut = esi;
					return ebp;
				case 0x07:
					*dwArg04 = *dwArg08;
					*((word32) dwArg04 + 1) = *((word32) dwArg08 + 1);
					*((word32) dwArg04 + 2) = *((word32) dwArg08 + 2);
					esiOut = esi;
					return ebp;
				}
			}
		}
		else
		{
			uint32 ecx_167 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (dwArg0C >> 0x02)
				{
				case 0x00:
					goto l0040393F;
				case 0x01:
					goto l0040392C;
				case 0x02:
					goto l00403924;
				case 0x03:
					goto l0040391C;
				case 0x04:
					goto l00403914;
				case 0x05:
					goto l0040390C;
				case 0x06:
					break;
				case 0x07:
					*((word32) (dwArg04 - 0x1C) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x1C)[dwArg0C >> 0x02];
					break;
				}
				*((word32) (dwArg04 - 0x18) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x18)[dwArg0C >> 0x02];
l0040390C:
				*((word32) (dwArg04 - 0x14) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x14)[dwArg0C >> 0x02];
l00403914:
				*((word32) (dwArg04 - 0x10) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x10)[dwArg0C >> 0x02];
l0040391C:
				*((word32) (dwArg04 - 0x0C) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x0C)[dwArg0C >> 0x02];
l00403924:
				*((word32) (dwArg04 - 0x08) + (dwArg0C >> 0x02) * 0x04) = (dwArg08 - 0x08)[dwArg0C >> 0x02];
l0040392C:
				(dwArg04 - 0x04)[dwArg0C >> 0x02] = (dwArg08 - 0x04)[dwArg0C >> 0x02];
				esi_14 = (word32) dwArg08 + (dwArg0C >> 0x02) * 0x04;
l0040393F:
				(*((char *) g_a403948 + (dwArg0C & 0x03) * 0x04))();
				esiOut = esi_14;
				return fp - 4;
			}
			else
			{
				for (; ecx_167 != 0x00; --ecx_167)
				{
					*edi_16 = *esi_14;
					esi_14 = (word32) esi_14 + 4;
					edi_16 = (word32) edi_16 + 4;
				}
				(*((char *) g_a403948 + (dwArg0C & 0x03) * 0x04))();
				esiOut = esi_14;
				return fp - 4;
			}
		}
	}
	else
	{
		Eq_8 esi_107 = (word32) dwArg08 + (dwArg0C - 0x04);
		struct Eq_5268 * edi_108 = (word32) dwArg04 + (dwArg0C - 0x04);
		if ((edi_108 & 0x03) != 0x00)
		{
			if (dwArg0C < 0x04)
			{
				switch (dwArg0C)
				{
				case 0x00:
					esiOut = esi;
					return ebp;
				case 0x01:
					edi_108->b0003 = (byte) *((word32) esi_107 + 3);
					esiOut = esi;
					return ebp;
				case 0x02:
					edi_108->b0003 = (byte) *((word32) esi_107 + 3);
					edi_108->b0002 = (byte) *((word32) esi_107 + 2);
					esiOut = esi;
					return ebp;
				case 0x03:
					edi_108->b0003 = (byte) *((word32) esi_107 + 3);
					edi_108->b0002 = (byte) *((word32) esi_107 + 2);
					edi_108->b0001 = (byte) *((word32) esi_107 + 1);
					esiOut = esi;
					return ebp;
				}
			}
		}
		else
		{
			uint32 ecx_109 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (-(dwArg0C >> 0x02))
				{
				case 0x00:
					(*((char *) g_a403AE0 + (dwArg0C & 0x03) * 0x04))();
					esiOut = esi_107;
					return fp - 4;
				}
			}
			else
			{
				for (; ecx_109 != 0x00; --ecx_109)
				{
					edi_108->dw0000 = (word32) *esi_107;
					esi_107 -= 4;
					edi_108 -= 4;
				}
				(*((char *) g_a403AE0 + (dwArg0C & 0x03) * 0x04))();
				esiOut = esi_107;
				return fp - 4;
			}
		}
	}
}

<anonymous> * g_a403948[] = // 00403948
	{
	};
<anonymous> * g_a403AE0[] = // 00403AE0
	{
	};
// 00403B40: void fn00403B40(Register uint32 eax, Stack Eq_8 dwArg00)
// Called from:
//      fn0040343E
//      fn0040368D
void fn00403B40(uint32 eax, Eq_8 dwArg00)
{
	ptr32 ecx_11 = fp + 0x04;
	for (; eax >= 0x1000; eax -= 0x1000)
		ecx_11 -= 0x1000;
	(ecx_11 - eax)->tFFFFFFFC = dwArg00;
}

// 00403B70: void fn00403B70(Stack Eq_8 dwArg04, Stack Eq_8 bArg08, Stack Eq_8 dwArg0C)
// Called from:
//      fn0040368D
void fn00403B70(Eq_8 dwArg04, Eq_8 bArg08, Eq_8 dwArg0C)
{
	Eq_8 edx_24 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	Eq_8 al_12 = bArg08;
	Eq_8 edi_16 = dwArg04;
	uint32 eax_34 = (uint32) bArg08;
	if (dwArg0C >= 0x04)
	{
		ui32 ecx_19 = -dwArg04;
		ui32 ecx_20 = ecx_19 & 0x03;
		if ((ecx_19 & 0x03) != 0x00)
		{
			edx_24 = dwArg0C - (ecx_19 & 0x03);
			do
			{
				*edi_16 = bArg08;
				edi_16 = (word32) edi_16 + 1;
				--ecx_20;
				eax_34 = (uint32) bArg08;
			} while (ecx_20 != 0x00);
		}
		ui32 eax_41 = eax_34 * 0x0101;
		al_12 = (byte) eax_41 * 0x01;
		edx_24 &= 0x03;
		uint32 ecx_49 = edx_24 >> 0x02;
		if (ecx_49 != 0x00)
		{
			while (true)
			{
				al_12 = (byte) eax_41 * 0x01;
				if (ecx_49 == 0x00)
					break;
				*edi_16 = eax_41 * 0x00010001;
				edi_16 = (word32) edi_16 + 4;
				--ecx_49;
			}
			if (edx_24 == 0x00)
				return;
		}
	}
	do
	{
		*edi_16 = al_12;
		edi_16 = (word32) edi_16 + 1;
		--edx_24;
	} while (edx_24 != 0x00);
}

