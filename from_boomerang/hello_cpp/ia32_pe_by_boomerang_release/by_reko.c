// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw405000 = 0x00; // 00405000
word32 g_dw405004 = 0x00; // 00405004
word32 g_dw405008 = 0x00; // 00405008
word32 g_dw405010 = 0x00; // 00405010
word32 g_dw405014 = 0x00; // 00405014
word32 g_dw405018 = 0x00; // 00405018
word32 g_dw40501C = 0x00; // 0040501C
word32 g_dw405020 = 0x00; // 00405020
<anonymous> * g_ptr405030 = &g_t4014CD; // 00405030
word32 g_dw405034 = 0x02; // 00405034
word32 g_dw405038 = 0xC0000005; // 00405038
int32 g_dw4050B0 = 3; // 004050B0
word32 g_dw4050B4 = 0x07; // 004050B4
ui32 g_dw4050B8 = 0x0A; // 004050B8
word32 g_dw4050BC = 0x8C; // 004050BC
Eq_5794 g_a4050E0[19] = // 004050E0
	{
		
		{
			0x02,
			
			{
				0x60
			},
		},
		
		{
			0x08,
			
			{
				0x34
			},
		},
		
		{
			0x09,
			
			{
				0x08
			},
		},
		
		{
			0x0A,
			
			{
				228
			},
		},
		
		{
			0x10,
			
			{
				0xB8
			},
		},
		
		{
			0x11,
			
			{
				0x88
			},
		},
		
		{
			0x12,
			
			{
				100
			},
		},
		
		{
			0x13,
			
			{
				0x38
			},
		},
		
		{
			0x18,
			
			{
				0x00
			},
		},
		
		{
			0x19,
			
			{
				0xD8
			},
		},
		
		{
			0x1A,
			
			{
				0xA0
			},
		},
		
		{
			0x1B,
			
			{
				0x68
			},
		},
		
		{
			0x1C,
			
			{
				0x40
			},
		},
		
		{
			0x78,
			
			{
				0x30
			},
		},
		
		{
			121,
			
			{
				0x20
			},
		},
		
		{
			122,
			
			{
				0x10
			},
		},
		
		{
			252,
			
			{
				0x0C
			},
		},
		
		{
			0xFF,
			
			{
				252
			},
		},
		
		{
			0x08040201,
			
			{
				0x00
			},
		},
	};
byte g_a405170[5] = // 00405170
	{
		0x01,
		0x02,
		0x04,
		0x08,
		0x00,
	};
Eq_5804 g_a405178[6] = // 00405178
	{
		
		{
			
			{
				0xA4
			},
		},
		
		{
			
			{
				0xA8
			},
		},
		
		{
			
			{
				181
			},
		},
		
		{
			
			{
				~0x49
			},
		},
		
		{
			
			{
				0x51
			},
		},
		
		{
			
			{
				0x00
			},
		},
	};
Eq_9 g_t405268 = // 00405268
	{
		0x00
	};
Eq_714 g_t405270 = // 00405270
	{
		1016
	};
word16 g_a40528A[] = // 0040528A
	{
	};
CHAR g_t405490 = '\0'; // 00405490
Eq_3 g_t405558 = // 00405558
	{
		null
	};
Eq_9 g_t40555C = // 0040555C
	{
		0x00
	};
word32 g_dw405564 = 0x00; // 00405564
uint32 g_dw405574 = 0x00; // 00405574
uint32 g_dw405578 = 0x00; // 00405578
ui32 g_dw40557C = 0x00; // 0040557C
uint32 g_dw405580 = 0x00; // 00405580
word32 g_dw405584 = 0x00; // 00405584
Eq_9 g_t405588 = // 00405588
	{
		0x00
	};
Eq_9 g_t405590 = // 00405590
	{
		0x00
	};
word32 g_dw4055A0 = 0x00; // 004055A0
byte g_b4055A8 = 0x00; // 004055A8
word32 g_dw4055AC = 0x00; // 004055AC
word32 g_dw4055B0 = 0x00; // 004055B0
struct _EXCEPTION_POINTERS * g_ptr4055B4 = null; // 004055B4
word32 g_dw4056BC = 0x00; // 004056BC
<anonymous> * g_ptr4056C0 = null; // 004056C0
word32 g_dw4056C4 = 0x00; // 004056C4
Eq_4459 g_t4056C8 = null; // 004056C8
Eq_4459 g_t4056CC = null; // 004056CC
Eq_4459 g_t4056D0 = null; // 004056D0
Eq_9 g_t4056DC = // 004056DC
	{
		0x00
	};
Eq_9 g_t4056EC = // 004056EC
	{
		0x00
	};
word32 g_dw4056F4 = 0x00; // 004056F4
word32 g_dw4056F8 = 0x00; // 004056F8
word32 g_dw4056FC = 0x00; // 004056FC
<anonymous> * g_ptr405700 = null; // 00405700
ui32 g_dw405704 = 0x00; // 00405704
Eq_3122 g_t405708 = // 00405708
	{
		0
	};
Eq_9 g_t40570C = // 0040570C
	{
		0x00
	};
Eq_9 g_t405710 = // 00405710
	{
		0x00
	};
ui32 g_dw405714 = 0x00; // 00405714
Eq_9 g_t405718 = // 00405718
	{
		0x00
	};
Eq_9 g_t40571C = // 0040571C
	{
		0x00
	};
word32 g_dw405720 = 0x00; // 00405720
word32 g_dw405724 = 0x00; // 00405724
word32 g_dw405728 = 0x00; // 00405728
word32 g_dw40572C = 0x00; // 0040572C
byte g_a405740[257] = // 00405740
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_1972 g_a405840[] = // 00405840
	{
	};
byte g_a405841[257] = // 00405841
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
byte g_a405842[255] = // 00405842
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
Eq_9 g_t405944 = // 00405944
	{
		0x00
	};
Eq_430 g_t405948 = null; // 00405948
Eq_9 g_t405960 = // 00405960
	{
		0x00
	};
Eq_9 g_a405964[] = // 00405964
	{
	};
Eq_9 g_t405A60 = // 00405A60
	{
		0x00
	};
word32 g_dw405A64 = 0x00; // 00405A64
word32 g_dw405A68 = 0x00; // 00405A68
up32 g_dw405A6C = 0x00; // 00405A6C
word32 * g_ptr405A70 = null; // 00405A70
<anonymous> * g_ptr405A74 = null; // 00405A74
Eq_9 g_t405A78 = // 00405A78
	{
		0x00
	};
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __imp__GetModuleFileNameA = &g_t4776; // 00404000
<anonymous> * __imp__GetStringTypeW = &g_t493C; // 00404004
<anonymous> * __imp__GetStringTypeA = &g_t492A; // 00404008
<anonymous> * __imp__LCMapStringW = &g_t491A; // 0040400C
<anonymous> * __imp__LCMapStringA = &g_t490A; // 00404010
<anonymous> * __imp__MultiByteToWideChar = &g_t48F4; // 00404014
<anonymous> * __imp__LoadLibraryA = &g_t48E4; // 00404018
<anonymous> * __imp__GetProcAddress = &g_t48D2; // 0040401C
<anonymous> * __imp__HeapReAlloc = &g_t48C4; // 00404020
<anonymous> * __imp__VirtualAlloc = &g_t48B4; // 00404024
<anonymous> * __imp__HeapAlloc = &g_t48A8; // 00404028
<anonymous> * __imp__GetOEMCP = &g_t489C; // 0040402C
<anonymous> * __imp__GetACP = &g_t4892; // 00404030
<anonymous> * __imp__GetCPInfo = &g_t4886; // 00404034
<anonymous> * __imp__WriteFile = &g_t487A; // 00404038
<anonymous> * __imp__RtlUnwind = &g_t486E; // 0040403C
<anonymous> * __imp__HeapFree = &g_t4862; // 00404040
<anonymous> * __imp__VirtualFree = &g_t4854; // 00404044
<anonymous> * __imp__HeapCreate = &g_t4846; // 00404048
<anonymous> * __imp__HeapDestroy = &g_t4838; // 0040404C
<anonymous> * __imp__GetFileType = &g_t482A; // 00404050
<anonymous> * __imp__GetModuleHandleA = &g_t46DE; // 00404054
<anonymous> * __imp__GetStartupInfoA = &g_t46F2; // 00404058
<anonymous> * __imp__GetCommandLineA = &g_t4704; // 0040405C
<anonymous> * __imp__GetVersion = &g_t4716; // 00404060
<anonymous> * __imp__ExitProcess = &g_t4724; // 00404064
<anonymous> * __imp__TerminateProcess = &g_t4732; // 00404068
<anonymous> * __imp__GetCurrentProcess = &g_t4746; // 0040406C
<anonymous> * __imp__UnhandledExceptionFilter = &g_t475A; // 00404070
<anonymous> * __imp__FreeEnvironmentStringsA = &g_t478C; // 00404074
<anonymous> * __imp__FreeEnvironmentStringsW = &g_t47A6; // 00404078
<anonymous> * __imp__WideCharToMultiByte = &g_t47C0; // 0040407C
<anonymous> * __imp__GetEnvironmentStrings = &g_t47D6; // 00404080
<anonymous> * __imp__GetEnvironmentStringsW = &g_t47EE; // 00404084
<anonymous> * __imp__SetHandleCount = &g_t4808; // 00404088
<anonymous> * __imp__GetStdHandle = &g_t481A; // 0040408C
<anonymous> * __imp__EndDialog = &g_t46C6; // 00404094
<anonymous> * __imp__DefWindowProcA = &g_t46B4; // 00404098
<anonymous> * __imp__DestroyWindow = &g_t46A4; // 0040409C
<anonymous> * __imp__DialogBoxParamA = &g_t4692; // 004040A0
<anonymous> * __imp__BeginPaint = &g_t4684; // 004040A4
<anonymous> * __imp__GetClientRect = &g_t4674; // 004040A8
<anonymous> * __imp__DrawTextA = &g_t4668; // 004040AC
<anonymous> * __imp__EndPaint = &g_t465C; // 004040B0
<anonymous> * __imp__PostQuitMessage = &g_t464A; // 004040B4
<anonymous> * __imp__CreateWindowExA = &g_t4638; // 004040B8
<anonymous> * __imp__ShowWindow = &g_t462A; // 004040BC
<anonymous> * __imp__UpdateWindow = &g_t461A; // 004040C0
<anonymous> * __imp__LoadIconA = &g_t460E; // 004040C4
<anonymous> * __imp__LoadCursorA = &g_t4600; // 004040C8
<anonymous> * __imp__RegisterClassExA = &g_t45EC; // 004040CC
<anonymous> * __imp__LoadStringA = &g_t45DE; // 004040D0
<anonymous> * __imp__LoadAcceleratorsA = &g_t45CA; // 004040D4
<anonymous> * __imp__GetMessageA = &g_t45BC; // 004040D8
<anonymous> * __imp__TranslateAcceleratorA = &g_t45A4; // 004040DC
<anonymous> * __imp__TranslateMessage = &g_t4590; // 004040E0
<anonymous> * __imp__DispatchMessageA = &g_t457C; // 004040E4
byte g_b4043D0 = 0x2E; // 004043D0
word32 g_dw404490 = 0x4776; // 00404490
word32 g_dw404494 = 18748; // 00404494
word32 g_dw404498 = 0x492A; // 00404498
word32 g_dw40449C = 18714; // 0040449C
word32 g_dw4044A0 = 0x490A; // 004044A0
word32 g_dw4044A4 = 0x48F4; // 004044A4
word32 g_dw4044A8 = 0x48E4; // 004044A8
word32 g_dw4044AC = 0x48D2; // 004044AC
word32 g_dw4044B0 = 0x48C4; // 004044B0
word32 g_dw4044B4 = 0x48B4; // 004044B4
word32 g_dw4044B8 = 0x48A8; // 004044B8
word32 g_dw4044BC = 18588; // 004044BC
word32 g_dw4044C0 = 18578; // 004044C0
word32 g_dw4044C4 = 0x4886; // 004044C4
word32 g_dw4044C8 = 18554; // 004044C8
word32 g_dw4044CC = 0x486E; // 004044CC
word32 g_dw4044D0 = 0x4862; // 004044D0
word32 g_dw4044D4 = 0x4854; // 004044D4
word32 g_dw4044D8 = 0x4846; // 004044D8
word32 g_dw4044DC = 18488; // 004044DC
word32 g_dw4044E0 = 18474; // 004044E0
word32 g_dw4044E4 = 18142; // 004044E4
word32 g_dw4044E8 = 18162; // 004044E8
word32 g_dw4044EC = 0x4704; // 004044EC
word32 g_dw4044F0 = 18198; // 004044F0
word32 g_dw4044F4 = 18212; // 004044F4
word32 g_dw4044F8 = 18226; // 004044F8
word32 g_dw4044FC = 0x4746; // 004044FC
word32 g_dw404500 = 18266; // 00404500
word32 g_dw404504 = 18316; // 00404504
word32 g_dw404508 = 0x47A6; // 00404508
word32 g_dw40450C = 0x47C0; // 0040450C
word32 g_dw404510 = 0x47D6; // 00404510
word32 g_dw404514 = 18414; // 00404514
word32 g_dw404518 = 0x4808; // 00404518
word32 g_dw40451C = 18458; // 0040451C
word32 g_dw404524 = 18118; // 00404524
word32 g_dw404528 = 18100; // 00404528
word32 g_dw40452C = 0x46A4; // 0040452C
word32 g_dw404530 = 18066; // 00404530
word32 g_dw404534 = 0x4684; // 00404534
word32 g_dw404538 = 0x4674; // 00404538
word32 g_dw40453C = 0x4668; // 0040453C
word32 g_dw404540 = 18012; // 00404540
word32 g_dw404544 = 0x464A; // 00404544
word32 g_dw404548 = 17976; // 00404548
word32 g_dw40454C = 0x462A; // 0040454C
word32 g_dw404550 = 0x461A; // 00404550
word32 g_dw404554 = 0x460E; // 00404554
word32 g_dw404558 = 0x4600; // 00404558
word32 g_dw40455C = 17900; // 0040455C
word32 g_dw404560 = 17886; // 00404560
word32 g_dw404564 = 17866; // 00404564
word32 g_dw404568 = 0x45BC; // 00404568
word32 g_dw40456C = 0x45A4; // 0040456C
word32 g_dw404570 = 0x4590; // 00404570
word32 g_dw404574 = 17788; // 00404574
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 fn00401000(Stack Eq_3 dwArg04, Stack int32 dwArg10)
// Called from:
//      Win32CrtStartup
Eq_2 fn00401000(Eq_3 dwArg04, int32 dwArg10)
{
	Eq_5 tLoc1C;
	LoadStringA(dwArg04, 0x67, 0x004054F4, 100);
	LoadStringA(dwArg04, 0x6D, 0x00405490, 100);
	fn004010C0(dwArg04);
	Eq_2 eax_47 = fn00401150(dwArg04, dwArg10);
	if (eax_47 == 0x00)
		return eax_47;
	Eq_38 eax_62 = LoadAcceleratorsA(dwArg04, 0x6D);
	while (GetMessageA(&tLoc1C, null, 0x00, 0x00) != 0x00)
	{
		if (TranslateAcceleratorA(tLoc1C.hwnd, eax_62, &tLoc1C) == 0x00)
		{
			TranslateMessage(&tLoc1C);
			DispatchMessageA(&tLoc1C);
		}
	}
	return tLoc1C.wParam;
}

// 004010C0: void fn004010C0(Stack Eq_3 dwArg04)
// Called from:
//      fn00401000
void fn004010C0(Eq_3 dwArg04)
{
	Eq_98 tLoc30;
	tLoc30.cbSize = (UINT) 0x30;
	tLoc30.style = (UINT) 0x03;
	tLoc30.lpfnWndProc = &g_t4011B0;
	tLoc30.cbClsExtra = 0x00;
	tLoc30.cbWndExtra = 0x00;
	tLoc30.hInstance = (HINSTANCE) dwArg04;
	tLoc30.hIcon = (HICON) LoadIconA(dwArg04, 0x6B);
	tLoc30.hCursor = (HCURSOR) LoadCursorA(0x00, 0x7F00);
	Eq_3 eax_31 = tLoc30.hInstance;
	tLoc30.hbrBackground = (HBRUSH) (struct HBRUSH__ *) 0x06;
	tLoc30.lpszMenuName = (LPCSTR) (CHAR *) 0x6D;
	tLoc30.lpszClassName = (LPCSTR) &g_t405490;
	tLoc30.hIconSm = (HICON) LoadIconA(eax_31, 0x6C);
	RegisterClassExA(&tLoc30);
}

// 00401150: Register Eq_48 fn00401150(Stack Eq_3 dwArg04, Stack int32 dwArg08)
// Called from:
//      fn00401000
Eq_48 fn00401150(Eq_3 dwArg04, int32 dwArg08)
{
	g_t405558.u0 = (HINSTANCE) dwArg04;
	Eq_48 eax_34 = CreateWindowExA(0x00, 0x00405490, 0x004054F4, 0x00CF0000, 0x80000000, 0x00, 0x80000000, 0x00, null, null, dwArg04, 0x00);
	if (eax_34 == null)
		return eax_34;
	ShowWindow(eax_34, dwArg08);
	UpdateWindow(eax_34);
	return (struct HWND__ *) 0x01;
}

LRESULT g_t4011B0(HWND tArg04, UINT tArg08, WPARAM tArg0C, LPARAM tArg10) = ??/* Unexpected function type (fn LRESULT (HWND, UINT, WPARAM, LPARAM)) */ ; // 004011B0
// 00401350: Register Eq_9 Win32CrtStartup()
Eq_9 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_228 * fs;
	fs->ptr0000 = fp - 20;
	Eq_9 eax_30 = GetVersion();
	uint32 edx_35 = (uint32) SLICE(eax_30, byte, 8);
	g_dw405580 = edx_35;
	g_dw40557C = eax_30 & 0xFF;
	g_dw405578 = ((eax_30 & 0xFF) << 0x08) + edx_35;
	g_dw405574 = eax_30 >> 0x10;
	if (fn00401D50(0x00) != 0x00)
	{
		int32 eax_126;
		fn00401BA5();
		g_t405A78.u1 = (DWORD) GetCommandLineA();
		word32 ecx_78;
		g_t40555C.u1 = (DWORD) fn00401A73(out ecx_78);
		fn00401826(ecx_78);
		struct Eq_285 * ebp_94 = fn0040176D();
		fn0040148F();
		ebp_94->dwFFFFFFD0 = 0x00;
		GetStartupInfoA(ebp_94 - 92);
		ebp_94->dwFFFFFF9C = fn00401715();
		if ((ebp_94->dwFFFFFFD0 & 0x01) != 0x00)
			eax_126 = (word32) ebp_94->wFFFFFFD4;
		else
			eax_126 = 0x0A;
		Eq_9 eax_146 = fn00401000(GetModuleHandleA(0x00), eax_126);
		ebp_94->tFFFFFFA0.u1 = (DWORD) eax_146;
		fn004014BC(eax_146);
		struct _EXCEPTION_POINTERS * eax_165 = ebp_94->ptrFFFFFFEC;
		word32 ecx_167 = eax_165->ExceptionRecord->ExceptionCode;
		ebp_94->dwFFFFFF98 = ecx_167;
		return fn00401591(ecx_167, eax_165);
	}
	else
		fn0040146B(0x1C);
}

// 00401446: Register word32 fn00401446(Stack Eq_9 dwArg04)
// Called from:
//      fn0040176D
//      fn00401826
//      fn00401BA5
word32 fn00401446(Eq_9 dwArg04)
{
	if (g_dw405564 == 0x01)
		fn00401F5C();
	word32 edi_24 = fn00401F95(dwArg04);
	g_ptr405030();
	return edi_24;
}

// 0040146B: void fn0040146B(Stack Eq_9 dwArg04)
// Called from:
//      Win32CrtStartup
void fn0040146B(Eq_9 dwArg04)
{
	if (g_dw405564 == 0x01)
		fn00401F5C();
	fn00401F95(dwArg04);
	ExitProcess(0xFF);
}

// 0040148F: void fn0040148F()
// Called from:
//      Win32CrtStartup
void fn0040148F()
{
	<anonymous> * eax_5 = g_ptr405A74;
	if (eax_5 != null)
		eax_5();
	fn00401577(&g_dw405008, &g_dw405010);
	fn00401577(&g_dw405000, &g_dw405004);
}

// 004014BC: void fn004014BC(Stack Eq_9 dwArg04)
// Called from:
//      Win32CrtStartup
void fn004014BC(Eq_9 dwArg04)
{
	fn004014DE(dwArg04, 0x00, 0x00);
}

<anonymous> g_t4014CD = <code>; // 004014CD
// 004014DE: void fn004014DE(Stack Eq_9 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      fn004014BC
void fn004014DE(Eq_9 dwArg04, word32 dwArg08, word32 dwArg0C)
{
	ptr32 fp;
	if (g_dw4055B0 == 0x01)
		TerminateProcess(GetCurrentProcess(), dwArg04);
	g_dw4055AC = 0x01;
	g_b4055A8 = (byte) dwArg0C;
	ptr32 esp_24 = fp - 8;
	if (dwArg08 == 0x00)
	{
		word32 * eax_34 = g_ptr405A70;
		if (eax_34 != null)
		{
			up32 ecx_39 = g_dw405A6C;
			ptr32 esp_40 = fp - 0x0C;
			word32 * esi_44 = ecx_39 - 4;
			if (ecx_39 - 4 >= eax_34)
			{
				do
				{
					<anonymous> * eax_49 = *esi_44;
					if (eax_49 != null)
					{
						word32 eax_59;
						eax_49();
					}
					esi_44 -= 0x04;
				} while (esi_44 >= g_ptr405A70);
			}
			esp_24 = esp_40 + 4;
		}
		struct Eq_447 * esp_74 = esp_24 - 4;
		esp_74->ptr0000 = &g_dw405018;
		esp_74->ptrFFFFFFFC = &g_dw405014;
		fn00401577(esp_74->ptrFFFFFFFC, esp_74->ptr0000);
	}
	fn00401577(&g_dw40501C, &g_dw405020);
	if (dwArg0C != 0x00)
		return;
	g_dw4055B0 = 0x01;
	ExitProcess(dwArg04);
}

// 00401577: void fn00401577(Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      fn0040148F
//      fn004014DE
void fn00401577(word32 * dwArg04, word32 * dwArg08)
{
	word32 * esi_26;
	for (esi_26 = dwArg04; esi_26 < dwArg08; ++esi_26)
	{
		<anonymous> * eax_15 = *esi_26;
		if (eax_15 != null)
		{
			word32 eax_22;
			eax_15();
		}
	}
}

// 00401591: Register Eq_507 fn00401591(Stack word32 dwArg04, Stack (ptr32 Eq_341) dwArg08)
// Called from:
//      Win32CrtStartup
Eq_507 fn00401591(word32 dwArg04, struct _EXCEPTION_POINTERS * dwArg08)
{
	Eq_507 eax_152;
	struct Eq_509 * eax_14 = fn004016D2(dwArg04);
	if (eax_14 != null)
	{
		<anonymous> * ebx_27 = eax_14->ptr0008;
		if (ebx_27 != null)
		{
			if (ebx_27 == (<anonymous> *) 0x05)
			{
				eax_14->ptr0008 = null;
				eax_152 = 0x01;
			}
			else
			{
				if (ebx_27 != (<anonymous> *) 0x01)
				{
					struct _EXCEPTION_POINTERS * ecx_44 = g_ptr4055B4;
					g_ptr4055B4 = dwArg08;
					word32 ecx_48 = eax_14->dw0004;
					if (ecx_48 == 0x08)
					{
						int32 ecx_66 = g_dw4050B0;
						int32 edx_68 = g_dw4050B4 + ecx_66;
						if (ecx_66 < edx_68)
						{
							int32 edx_75 = edx_68 - ecx_66;
							struct Eq_569 * esi_77 = ecx_66 * 0x0C + 0x00405040;
							do
							{
								esi_77->dw0000 = 0x00;
								++esi_77;
								--edx_75;
							} while (edx_75 != 0x00);
						}
						word32 eax_92 = eax_14->dw0000;
						word32 esi_93 = g_dw4050BC;
						if (eax_92 == 0xC000008E)
							g_dw4050BC = 131;
						else if (eax_92 == 0xC0000090)
							g_dw4050BC = 0x81;
						else if (eax_92 == 0xC0000091)
							g_dw4050BC = 0x84;
						else if (eax_92 == 0xC0000093)
							g_dw4050BC = 133;
						else if (eax_92 == 0xC000008D)
							g_dw4050BC = 0x82;
						else if (eax_92 == 0xC000008F)
							g_dw4050BC = 0x86;
						else if (eax_92 == 0xC0000092)
							g_dw4050BC = 0x8A;
						ebx_27();
						g_dw4050BC = esi_93;
					}
					else
					{
						eax_14->ptr0008 = null;
						ebx_27();
					}
					g_ptr4055B4 = ecx_44;
				}
				eax_152 = ~0x00;
			}
			return eax_152;
		}
	}
	eax_152 = UnhandledExceptionFilter(dwArg08);
	return eax_152;
}

// 004016D2: Register (ptr32 Eq_612) fn004016D2(Stack word32 dwArg04)
// Called from:
//      fn00401591
struct Eq_612 * fn004016D2(word32 dwArg04)
{
	ui32 ecx_6 = g_dw4050B8;
	struct Eq_612 * eax_11 = &g_dw405038;
	if (g_dw405038 != dwArg04)
	{
		struct Eq_612 * esi_14 = ecx_6 * 0x0C + 0x00405038;
		do
			++eax_11;
		while (eax_11 < esi_14 && eax_11->dw0000 != dwArg04);
	}
	if (eax_11 >= ecx_6 * 0x0C + 0x00405038 || eax_11->dw0000 != dwArg04)
		eax_11 = null;
	return eax_11;
}

// 00401715: Register Eq_9 fn00401715()
// Called from:
//      Win32CrtStartup
Eq_9 fn00401715()
{
	if (g_dw405A68 == 0x00)
		fn004024EE();
	Eq_9 esi_20 = g_t405A78.u1;
	cu8 al_21 = *esi_20.u2;
	if (al_21 == 0x22)
	{
		while (true)
		{
			byte al_33 = esi_20.u1->b0001;
			&esi_20.u1->dw0000 = &esi_20.u1->b0001;
			if (al_33 == 0x22 || al_33 == 0x00)
				break;
			if (fn004020E8(al_33) != 0x00)
				&esi_20.u1->dw0000 = &esi_20.u1->b0001;
		}
		if (*esi_20.u2 == 0x22)
		{
l00401752:
			&esi_20.u1->dw0000 = &esi_20.u1->b0001;
		}
	}
	else if (al_21 > 0x20)
	{
		do
			&esi_20.u1->dw0000 = &esi_20.u1->b0001;
		while (*esi_20.u2 > 0x20);
	}
	cu8 al_51 = *esi_20.u2;
	if (al_51 == 0x00 || al_51 > 0x20)
		return esi_20;
	goto l00401752;
}

// 0040176D: Register word32 fn0040176D()
// Called from:
//      Win32CrtStartup
word32 fn0040176D()
{
	if (g_dw405A68 == 0x00)
		fn004024EE();
	Eq_9 esi_212 = g_t40555C.u1;
	ui32 edi_196 = 0x00;
	while (true)
	{
		byte al_32 = *esi_212.u2;
		if (al_32 == 0x00)
			break;
		if (al_32 != 0x3D)
			++edi_196;
		esi_212 = esi_212 + 1 + fn004026B0(esi_212);
	}
	Eq_9 eax_41 = fn00402630(edi_196 * 0x04 + 0x04);
	g_t405590.u1 = (DWORD) eax_41;
	Eq_9 esi_112 = eax_41;
	if (eax_41 == 0x00)
		fn00401446(0x09);
	Eq_9 edi_119 = g_t40555C.u1;
	while (*edi_119.u2 != 0x00)
	{
		Eq_9 eax_84 = fn004026B0(edi_119);
		if (*edi_119.u2 != 0x3D)
		{
			Eq_9 eax_100 = fn00402630(&eax_84.u1->b0001);
			esi_112.u1->dw0000 = (word32) eax_100;
			if (eax_100 == 0x00)
				edi_119 = fn00401446(0x09);
			edi_119 = fn00402540(esi_112.u1->dw0000, edi_119);
			&esi_112.u1->dw0000 = (word32) esi_112 + 4;
		}
		edi_119 += eax_84 + 0x01;
	}
	word32 ebp_172;
	Eq_9 ebx_173 = fn0040250A(g_t40555C.u1, out ebp_172);
	g_t40555C.u1 = (DWORD) ebx_173;
	esi_112.u1->dw0000 = (word32) ebx_173;
	g_dw405A64 = 0x01;
	return ebp_172;
}

// 00401826: void fn00401826(Register word32 ecx)
// Called from:
//      Win32CrtStartup
void fn00401826(word32 ecx)
{
	Eq_807 tLoc0C;
	Eq_808 tLoc08;
	tLoc08 = (Eq_808) ecx;
	tLoc0C = (Eq_807) ecx;
	if (g_dw405A68 == 0x00)
		fn004024EE();
	GetModuleFileNameA(0x00, 0x004055B8, 0x0104);
	Eq_9 eax_44 = g_t405A78.u1;
	g_dw4055A0 = 0x004055B8;
	Eq_9 edi_122 = 0x004055B8;
	if (*eax_44.u2 != 0x00)
		edi_122 = eax_44;
	fn004018BF(edi_122, 0x00, null, &tLoc08, &tLoc0C);
	Eq_9 eax_81 = fn00402630((word32) tLoc0C + tLoc08 * 0x04);
	if (eax_81 == 0x00)
		edi_122 = fn00401446(0x08);
	fn004018BF(edi_122, eax_81, eax_81.u1 + tLoc08, &tLoc08, &tLoc0C);
	word32 eax_132 = tLoc08;
	g_t405588.u1 = (DWORD) eax_81;
	g_dw405584 = eax_132 - 0x01;
}

// 004018BF: void fn004018BF(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08, Stack (ptr32 Eq_847) dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14)
// Called from:
//      fn00401826
void fn004018BF(Eq_9 dwArg04, Eq_9 dwArg08, struct Eq_847 * dwArg0C, word32 * dwArg10, word32 * dwArg14)
{
	*dwArg14 = 0x00;
	*dwArg10 = 0x01;
	struct Eq_847 * esi_127 = dwArg0C;
	Eq_9 edi_178 = dwArg08;
	Eq_9 eax_107 = dwArg04;
	if (dwArg08 != 0x00)
	{
		dwArg08.u1->dw0000 = dwArg0C;
		&edi_178.u1->dw0000 = (word32) dwArg08 + 4;
		&dwArg08.u1->dw0000 = (word32) dwArg08 + 4;
	}
	if (*dwArg04.u2 == 0x22)
	{
		while (true)
		{
			byte dl_113 = eax_107.u1->b0001;
			&eax_107.u1->dw0000 = &eax_107.u1->b0001;
			if (dl_113 == 0x22 || dl_113 == 0x00)
				break;
			if ((g_a405841[(word32) dl_113] & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_127 != null)
				{
					esi_127->b0000 = *eax_107.u2;
					++esi_127;
					&eax_107.u1->dw0000 = &eax_107.u1->b0001;
				}
			}
			++*dwArg14;
			if (esi_127 != null)
			{
				esi_127->b0000 = *eax_107.u2;
				++esi_127;
			}
		}
		++*dwArg14;
		if (esi_127 != null)
		{
			esi_127->b0000 = 0x00;
			++esi_127;
		}
		if (*eax_107.u2 == 0x22)
			&eax_107.u1->dw0000 = &eax_107.u1->b0001;
	}
	else
	{
		do
		{
			++*dwArg14;
			if (esi_127 != null)
			{
				esi_127->b0000 = *eax_107.u2;
				++esi_127;
			}
			byte dl_54 = *eax_107.u2;
			&eax_107.u1->dw0000 = &eax_107.u1->b0001;
			if ((g_a405841[(word32) dl_54] & 0x04) != 0x00)
			{
				++*dwArg14;
				if (esi_127 != null)
				{
					esi_127->b0000 = *eax_107.u2;
					++esi_127;
				}
				&eax_107.u1->dw0000 = &eax_107.u1->b0001;
			}
			if (dl_54 == 0x20)
				break;
			if (dl_54 == 0x00)
				goto l0040196A;
		} while (dl_54 != 0x09);
		if (dl_54 == 0x00)
		{
l0040196A:
			--eax_107;
		}
		else if (esi_127 != null)
			esi_127->bFFFFFFFF = 0x00;
	}
	uint32 dwArg14_549 = 0x00;
	while (*eax_107.u2 != 0x00)
	{
		while (true)
		{
			byte dl_169 = *eax_107.u2;
			if (dl_169 != 0x20 && dl_169 != 0x09)
				break;
			&eax_107.u1->dw0000 = &eax_107.u1->b0001;
		}
		if (*eax_107.u2 == 0x00)
			break;
		if (edi_178 != 0x00)
		{
			edi_178.u1->dw0000 = esi_127;
			&edi_178.u1->dw0000 = (word32) edi_178 + 4;
			dwArg08 = edi_178;
		}
		++*dwArg10;
l004019AB:
		word32 dwArg04_572 = 0x01;
		uint32 ebx_852 = 0x00;
		while (true)
		{
			byte bl_237 = (byte) ebx_852;
			if (*eax_107.u2 != 0x5C)
				break;
			&eax_107.u1->dw0000 = &eax_107.u1->b0001;
			ebx_852 = SEQ(SLICE(ebx_852 + 0x01, word24, 8), bl_237 + 0x01);
		}
		uint32 ebx_268 = ebx_852;
		if (*eax_107.u2 == 0x22)
		{
			if ((bl_237 & 0x01) == 0x00)
			{
				if (dwArg14_549 != 0x00)
				{
					Eq_9 edx_247 = &eax_107.u1->b0001;
					if (eax_107.u1->b0001 != 0x22)
						goto l004019DB;
					eax_107 = edx_247;
				}
				else
				{
l004019DB:
					dwArg04_572 = 0x00;
				}
				edi_178 = dwArg08;
				dwArg14_549 = (uint32) (int8) (dwArg14_549 == 0x00);
			}
			ebx_268 = ebx_852 >> 0x01;
		}
		word32 ebx_273 = ebx_268 - 0x01;
		if (ebx_268 != 0x00)
		{
			word32 ebx_278 = ebx_273 + 0x01;
			do
			{
				if (esi_127 != null)
				{
					esi_127->b0000 = 0x5C;
					++esi_127;
				}
				++*dwArg14;
				--ebx_278;
			} while (ebx_278 != 0x00);
		}
		byte dl_309 = *eax_107.u2;
		if (dl_309 != 0x00 && (dwArg14_549 != 0x00 || dl_309 != 0x20 && dl_309 != 0x09))
		{
			if (dwArg04_572 != 0x00)
			{
				if (esi_127 != null)
				{
					if ((g_a405841[(word32) dl_309] & 0x04) != 0x00)
					{
						esi_127->b0000 = dl_309;
						++*dwArg14;
						++esi_127;
						&eax_107.u1->dw0000 = &eax_107.u1->b0001;
					}
					esi_127->b0000 = *eax_107.u2;
					++esi_127;
				}
				else if ((g_a405841[(word32) dl_309] & 0x04) != 0x00)
				{
					++*dwArg14;
					&eax_107.u1->dw0000 = &eax_107.u1->b0001;
				}
				++*dwArg14;
			}
			&eax_107.u1->dw0000 = &eax_107.u1->b0001;
			goto l004019AB;
		}
		if (esi_127 != null)
		{
			esi_127->b0000 = 0x00;
			++esi_127;
		}
		++*dwArg14;
	}
	if (edi_178 != 0x00)
		edi_178.u1->dw0000 = 0x00;
	++*dwArg10;
}

// 00401A73: Register Eq_9 fn00401A73(Register out Eq_276 ecxOut)
// Called from:
//      Win32CrtStartup
Eq_9 fn00401A73(union Eq_276 & ecxOut)
{
	Eq_276 ecx;
	Eq_9 eax_130;
	Eq_276 dwLoc04_286 = ecx;
	word32 eax_9 = g_dw4056BC;
	Eq_9 esi_132 = 0x00;
	Eq_9 edi_108 = 0x00;
	if (eax_9 == 0x00)
	{
		Eq_9 eax_32 = GetEnvironmentStringsW();
		esi_132 = eax_32;
		if (eax_32 != 0x00)
		{
			g_dw4056BC = 0x01;
l00401ACA:
			if (esi_132 != 0x00)
			{
l00401ADA:
				Eq_9 eax_151 = esi_132;
				if (*esi_132 != 0x00)
				{
					do
					{
						do
						{
							Eq_1357 eax_154 = &eax_151.u1->b0001;
							&eax_151.u1->dw0000 = &eax_154.u0->t0001.u0;
						} while (eax_154.u0->t0001.u0 != 0x00);
						eax_151 = eax_154 + 0x03;
					} while (Mem147[eax_154 + 0x03:word16] != 0x00);
				}
				Eq_276 eax_184 = (eax_151 - esi_132 >> 0x01) + 0x01;
				Eq_9 ebx_175 = 0x00;
				dwLoc04_286 = eax_184;
				Eq_714 eax_198 = WideCharToMultiByte(0x00, 0x00, esi_132, eax_184, 0x00, 0x00, 0x00, 0x00);
				if (eax_198 != 0x00)
				{
					Eq_9 eax_205 = fn00402630(eax_198);
					Eq_9 dwLoc08_307 = eax_205;
					if (eax_205 != 0x00)
					{
						if (WideCharToMultiByte(0x00, 0x00, esi_132, eax_184, eax_205, eax_198, 0x00, 0x00) == 0x00)
						{
							word32 ebp_477;
							dwLoc08_307 = fn0040250A(eax_205, out ebp_477);
						}
						ebx_175 = dwLoc08_307;
					}
				}
				FreeEnvironmentStringsW(esi_132);
				eax_130 = ebx_175;
				goto l00401B9E;
			}
			Eq_9 eax_137 = GetEnvironmentStringsW();
			esi_132 = eax_137;
			if (eax_137 != 0x00)
				goto l00401ADA;
l00401B9C:
			eax_130.u0 = 0x00;
			goto l00401B9E;
		}
		Eq_9 eax_36 = GetEnvironmentStrings();
		edi_108 = eax_36;
		if (eax_36 == 0x00)
			goto l00401B9C;
		g_dw4056BC = 0x02;
	}
	else
	{
		if (eax_9 == 0x01)
			goto l00401ACA;
		if (eax_9 != 0x02)
			goto l00401B9C;
	}
	if (edi_108 == 0x00)
	{
		Eq_9 eax_45 = GetEnvironmentStrings();
		edi_108 = eax_45;
		if (eax_45 == 0x00)
			goto l00401B9C;
	}
	Eq_9 eax_55 = edi_108;
	if (*edi_108.u2 != 0x00)
	{
		do
		{
			do
				&eax_55.u1->dw0000 = &eax_55.u1->b0001;
			while (*eax_55.u2 != 0x00);
			++eax_55;
		} while (Mem51[eax_55 + 0x01:byte] != 0x00);
	}
	Eq_9 esi_110;
	word32 eax_69 = eax_55 - edi_108;
	Eq_9 eax_80 = fn00402630(eax_69 + 0x01);
	if (eax_80 == 0x00)
		esi_110.u0 = 0x00;
	else
		esi_110 = fn00402730(eax_80, edi_108, eax_69 + 0x01, out edi_108);
	FreeEnvironmentStringsA(edi_108);
	eax_130 = esi_110;
l00401B9E:
	ecxOut = dwLoc04_286;
	return eax_130;
}

// 00401BA5: void fn00401BA5()
// Called from:
//      Win32CrtStartup
void fn00401BA5()
{
	Eq_1456 tLoc44;
	Eq_9 eax_20 = fn00402630(0x0100);
	Eq_9 esi_28 = eax_20;
	if (eax_20 == 0x00)
		fn00401446(0x1B);
	g_t405960.u1 = (DWORD) eax_20;
	g_t405A60.u1 = (DWORD) 0x20;
	Eq_9 eax_287 = (word32) eax_20 + 0x0100;
	while (esi_28 < eax_287)
	{
		&((word32) esi_28 + 4)->u1->dw0000 = 0x00;
		esi_28.u1->dw0000 = ~0x00;
		&((word32) esi_28 + 5)->u1->dw0000 = 0x0A;
		&esi_28.u1->dw0000 = (word32) esi_28 + 8;
		&eax_287.u1->dw0000 = g_t405960.u1 + 64;
	}
	GetStartupInfoA(&tLoc44);
	if (tLoc44.cbReserved2 != 0x00)
	{
		Eq_1506 eax_63 = tLoc44.lpReserved2;
		if (eax_63 != 0x00)
		{
			Eq_9 esi_115 = eax_63.u0->u1;
			word32 ebp_126 = eax_63 + 4;
			word32 ebx_121 = esi_115 + (eax_63 + 4);
			if (esi_115 >= 0x0800)
				esi_115.u0 = 0x0800;
			if (g_t405A60.u1 < esi_115)
			{
				word32 * edi_101 = g_a405964;
				do
				{
					Eq_9 eax_104 = fn00402630(0x0100);
					if (eax_104 == 0x00)
					{
						&esi_115.u1->dw0000 = g_t405A60.u1;
						break;
					}
					g_t405A60.u1 += 8;
					*edi_101 = (word32) eax_104;
					Eq_9 ecx_103 = (word32) eax_104 + 0x0100;
					while (eax_104 < ecx_103)
					{
						&((word32) eax_104 + 4)->u1->dw0000 = 0x00;
						eax_104.u1->dw0000 = ~0x00;
						&((word32) eax_104 + 5)->u1->dw0000 = 0x0A;
						&eax_104.u1->dw0000 = (word32) eax_104 + 8;
						ecx_103 = *edi_101 + 0x0100;
					}
					++edi_101;
				} while (g_t405A60.u1 < esi_115);
			}
			Eq_9 edi_114 = 0x00;
			if (esi_115 > 0x00)
			{
				do
				{
					Eq_430 eax_123 = *ebx_121.u0;
					if (eax_123 != (void *) ~0x00)
					{
						byte cl_127 = *ebp_126;
						if ((cl_127 & 0x01) != 0x00 && ((cl_127 & 0x08) != 0x00 || GetFileType(eax_123) != 0x00))
						{
							struct Eq_1682 * eax_156 = &(*((char *) &g_t405960.u1 + (edi_114 >> 0x05) * 0x04))->u0 + (edi_114 & 0x1F) * 0x08;
							eax_156->dw0000 = *ebx_121.u0;
							eax_156->b0004 = *ebp_126;
						}
					}
					&edi_114.u1->dw0000 = &edi_114.u1->b0001;
					++ebp_126;
					ebx_121 += 0x04;
				} while (edi_114 < esi_115);
			}
		}
	}
	int32 ebx_174;
	for (ebx_174 = 0x00; ebx_174 < 0x03; ++ebx_174)
	{
		Eq_9 eax_179 = g_t405960.u1;
		struct Eq_1570 * esi_182 = eax_179.u1 + ebx_174 * 2;
		if (eax_179.u1[ebx_174 * 2] == ~0x00)
		{
			Eq_9 eax_199;
			esi_182->b0004 = 0x81;
			if (ebx_174 == 0x00)
				eax_199.u0 = ~0x09;
			else
				eax_199 = 0x00 - (ebx_174 != 0x01) + ~0x0A;
			Eq_430 eax_210 = GetStdHandle(eax_199);
			if (eax_210 != (void *) ~0x00)
			{
				Eq_9 eax_217 = GetFileType(eax_210);
				if (eax_217 == 0x00)
					goto l00401D21;
				esi_182->t0000 = eax_210;
				if ((eax_217 & 0xFF) == 0x02)
					goto l00401D21;
				if ((eax_217 & 0xFF) == 0x03)
					esi_182->b0004 |= 0x08;
			}
			else
			{
l00401D21:
				esi_182->b0004 |= 0x40;
			}
		}
		else
			esi_182->b0004 |= 0x80;
	}
	SetHandleCount(g_t405A60.u1);
}

// 00401D50: Register word32 fn00401D50(Stack word32 dwArg04)
// Called from:
//      Win32CrtStartup
word32 fn00401D50(word32 dwArg04)
{
	Eq_430 eax_16 = HeapCreate((uint32) (int8) (dwArg04 == 0x00), 0x1000, 0x00);
	g_t405948 = eax_16;
	if (eax_16 == null)
		return 0x00;
	if (fn00402A65() != 0x00)
		return 0x01;
	HeapDestroy(g_t405948);
	return 0x00;
}

// 00401F5C: void fn00401F5C()
// Called from:
//      fn00401446
//      fn0040146B
void fn00401F5C()
{
	word32 eax_5 = g_dw405564;
	if (eax_5 == 0x01 || eax_5 == 0x00 && g_dw405034 == 0x01)
	{
		fn00401F95(252);
		<anonymous> * eax_26 = g_ptr4056C0;
		if (eax_26 != null)
		{
			word32 ecx_36;
			word32 edx_38;
			eax_26();
		}
		fn00401F95(0xFF);
	}
}

// 00401F95: Register Eq_9 fn00401F95(Stack Eq_9 tArg04)
// Called from:
//      fn00401446
//      fn0040146B
//      fn00401F5C
Eq_9 fn00401F95(Eq_9 tArg04)
{
	ptr32 fp;
	Eq_9 edi;
	Eq_1767 tLoc01A8;
	word32 edx_9 = tArg04;
	ui32 ecx_10 = 0x00;
	word32 * eax_14 = g_a4050E0;
	while (edx_9 != *eax_14)
	{
		eax_14 += 2;
		++ecx_10;
		if (eax_14 >= g_a405170)
			break;
	}
	if (edx_9 == g_a4050E0[ecx_10])
	{
		word32 eax_38 = g_dw405564;
		if (eax_38 != 0x01 && (eax_38 != 0x00 || g_dw405034 != 0x01))
		{
			if (edx_9 != 252)
			{
				if (GetModuleFileNameA(0x00, &tLoc01A8, 0x0104) == 0x00)
					edi = fn00402540(&tLoc01A8, 0x004043D4);
				if (fn004026B0(&tLoc01A8) > 0x3B)
					fn00403340(fn004026B0(&tLoc01A8).u1 + (fp - 0x01E3) / 4, &g_b4043D0, 0x03);
				fn00402550(fp - 0xA4, fn00402540(fp - 0xA4, 0x004043B4));
				fn00402550(fp - 0xA4, 0x004043B0);
				fn00402550(fp - 0xA4, (&g_a4050E0->t0004.u0)[ecx_10 * 0x08]);
				fn004032AE();
			}
		}
		else
			WriteFile(GetStdHandle(~0x0B), (&g_a4050E0->t0004.u0)[ecx_10 * 0x08], fn004026B0((&g_a4050E0->t0004.u0)[ecx_10 * 0x08]), &tArg04, null);
	}
	return edi;
}

// 004020E8: Register word32 fn004020E8(Stack byte bArg04)
// Called from:
//      fn00401715
word32 fn004020E8(byte bArg04)
{
	word32 dwArg04;
	return fn004020F9((byte) dwArg04, 0x00, 0x04);
}

// 004020F9: Register ui32 fn004020F9(Stack byte bArg04, Stack ui32 dwArg08, Stack byte bArg0C)
// Called from:
//      fn004020E8
ui32 fn004020F9(byte bArg04, ui32 dwArg08, byte bArg0C)
{
	struct Eq_1901 * eax_5 = (word32) bArg04;
	if ((eax_5->b405841 & bArg0C) != 0x00)
		return 0x01;
	ui32 eax_13;
	if (dwArg08 != 0x00)
		eax_13 = (word32) g_a40528A[eax_5 * 0x02] & dwArg08;
	else
		eax_13 = 0x00;
	if (eax_13 != 0x00)
		return 0x01;
	return eax_13;
}

// 0040212A: void fn0040212A(Stack Eq_9 dwArg04)
// Called from:
//      fn004024EE
void fn0040212A(Eq_9 dwArg04)
{
	Eq_1923 tLoc1C;
	Eq_9 eax_22 = fn004022C3(dwArg04);
	if (eax_22 == g_t40571C.u1)
		return;
	if (eax_22 != 0x00)
	{
		ui32 edx_163 = 0x00;
		union Eq_9 * eax_162 = g_a405178;
		do
		{
			if (eax_162->u1 == eax_22)
			{
				word32 ecx_161;
				struct Eq_1943 * edi_160 = g_a405840;
				for (ecx_161 = 0x40; ecx_161 != 0x00; --ecx_161)
				{
					edi_160->b0000 = (byte) 0x00;
					++edi_160;
				}
				edi_160->b0000 = 0x00;
				ui32 esi_58 = edx_163 * 0x03;
				byte * dwLoc08_351 = g_a405170;
				union Eq_2084 * ebx_116 = (esi_58 << 0x04) + 0x00405188;
				do
				{
					union Eq_2084 * ecx_101 = ebx_116;
					if (ebx_116->u0.b0000 != 0x00)
					{
						do
						{
							byte dl_76 = (&ecx_101->u0)[1];
							if (dl_76 == 0x00)
								break;
							struct Eq_2113 * eax_81 = (word32) ecx_101->u0.b0000;
							struct Eq_2113 * edi_82 = (word32) dl_76;
							if (eax_81 <= edi_82)
							{
								byte dl_87 = *dwLoc08_351;
								do
								{
									eax_81[0x00405841] = (struct Eq_2113) (eax_81[0x00405841] | dl_87);
									++eax_81;
								} while (eax_81 <= edi_82);
							}
							struct Eq_2121 * ecx_100 = &ecx_101->u0 + 1;
							ecx_101 = (union Eq_2084 *) &ecx_100->b0001;
						} while (ecx_100->b0001 != 0x00);
					}
					byte * v26_110 = dwLoc08_351 + 1;
					dwLoc08_351 = v26_110;
					ebx_116 = (union Eq_2084 *) ((char *) ebx_116 + 8);
				} while (v26_110 < (byte *) ~0x0040516B);
				g_dw40572C = 0x01;
				g_t40571C.u1 = (DWORD) eax_22;
				Eq_9 eax_130 = fn0040230D(eax_22);
				struct Eq_2155 * esi_140 = (esi_58 << 0x04) + 4215164;
				g_dw405720 = esi_140->dw0000;
				g_dw405724 = esi_140->dw0004;
				g_t405944.u1 = (DWORD) eax_130;
				g_dw405728 = esi_140->dw0008;
				goto l004022B2;
			}
			eax_162 = (union Eq_9 *) ((char *) eax_162 + 48);
			++edx_163;
		} while (eax_162 < &g_t405268);
		if (GetCPInfo(eax_22, &tLoc1C) == 0x01)
		{
			g_t40571C.u1 = (DWORD) eax_22;
			word32 ecx_193;
			struct Eq_1970 * edi_195 = g_a405840;
			for (ecx_193 = 0x40; ecx_193 != 0x00; --ecx_193)
			{
				edi_195->b0000 = (byte) 0x00;
				++edi_195;
			}
			edi_195->b0000 = 0x00;
			g_t405944.u1 = (DWORD) 0x00;
			if (tLoc1C.MaxCharSize > 0x01)
			{
				if (Mem204[&tLoc1C + 6:byte] != 0x00)
				{
					struct Eq_2006 * ecx_210 = tLoc1C.LeadByte + 1;
					do
					{
						byte dl_213 = ecx_210->b0000;
						if (dl_213 == 0x00)
							break;
						struct Eq_2010 * eax_218;
						struct Eq_2010 * edx_219 = (word32) dl_213;
						for (eax_218 = (word32) ecx_210->bFFFFFFFF; eax_218 <= edx_219; ++eax_218)
							eax_218[0x00405841] = (struct Eq_2010) (eax_218[0x00405841] | 0x04);
						byte * ecx_225 = ecx_210 + 1;
						ecx_210 = (struct Eq_2006 *) (ecx_225 + 1);
					} while (*ecx_225 != 0x00);
				}
				struct Eq_2004 * eax_236 = (struct Eq_2004 *) 0x01;
				do
				{
					eax_236[0x00405841] = (struct Eq_2004) (eax_236[0x00405841] | 0x08);
					++eax_236;
				} while (eax_236 < (struct Eq_2004 *) 0xFF);
				g_t405944.u1 = (DWORD) fn0040230D(eax_22);
				g_dw40572C = 0x01;
			}
			else
				g_dw40572C = 0x00;
			g_dw405720 = 0x00;
			g_dw405724 = 0x00;
			g_dw405728 = 0x00;
l004022B2:
			fn00402369();
			return;
		}
		if (g_dw4056C4 == 0x00)
			return;
	}
	fn00402340();
	goto l004022B2;
}

// 004022C3: Register Eq_9 fn004022C3(Stack Eq_9 dwArg04)
// Called from:
//      fn0040212A
Eq_9 fn004022C3(Eq_9 dwArg04)
{
	g_dw4056C4 = 0x00;
	Eq_9 eax_15 = dwArg04;
	switch (dwArg04)
	{
	case ~0x01:
		g_dw4056C4 = 0x01;
		return GetOEMCP();
	case ~0x02:
		g_dw4056C4 = 0x01;
		return GetACP();
	default:
		if (dwArg04 == ~0x03)
		{
			&eax_15.u1->dw0000 = g_t4056EC.u1;
			g_dw4056C4 = 0x01;
		}
		return eax_15;
	}
}

// 0040230D: Register word32 fn0040230D(Stack Eq_9 dwArg04)
// Called from:
//      fn0040212A
word32 fn0040230D(Eq_9 dwArg04)
{
	if (dwArg04 == 0x03A4)
		return 0x0411;
	if (dwArg04 == 0x03A8)
		return 0x0804;
	if (dwArg04 == 949)
		return 0x0412;
	if (dwArg04 == 0x03B6)
		return 0x0404;
	return 0x00;
}

// 00402340: void fn00402340()
// Called from:
//      fn0040212A
void fn00402340()
{
	word32 ecx_16;
	struct Eq_2215 * edi_15 = g_a405840;
	for (ecx_16 = 0x40; ecx_16 != 0x00; --ecx_16)
	{
		edi_15->b0000 = (byte) 0x00;
		++edi_15;
	}
	edi_15->b0000 = 0x00;
	g_t40571C.u1 = (DWORD) 0x00;
	g_dw40572C = 0x00;
	g_t405944.u1 = (DWORD) 0x00;
	g_dw405720 = 0x00;
	g_dw405724 = 0x00;
	g_dw405728 = 0x00;
}

// 00402369: void fn00402369()
// Called from:
//      fn0040212A
void fn00402369()
{
	ptr32 fp;
	Eq_2247 tLoc0518;
	Eq_1767 tLoc0318;
	Eq_1767 tLoc0218;
	Eq_2250 tLoc18;
	if (GetCPInfo(g_t40571C.u1, &tLoc18) == 0x01)
	{
		Eq_2262 eax_494 = 0x00;
		do
		{
			byte al_76 = (byte) eax_500;
			*((word32) eax_500 + (fp - 0x0118)) = al_76;
			eax_494 = SEQ(SLICE((word32) eax_500 + 1, word24, 8), al_76 + 0x01);
			eax_500 = eax_494;
		} while (eax_500 < 0xFF);
		BYTE al_104[12] = tLoc18.LeadByte[0];
		if (al_104 != 0x00)
		{
			byte * edx_100 = tLoc18.LeadByte + 1;
			do
			{
				Eq_2354 ecx_103 = (word32) *edx_100;
				Eq_2354 eax_105 = (word32) al_104;
				if (eax_105 <= ecx_103)
				{
					word32 ecx_108 = ecx_103 - eax_105;
					struct Eq_2357 * edi_110 = (word32) eax_105 + (fp - 0x0118);
					uint32 ecx_114;
					for (ecx_114 = ecx_108 + 0x01 >> 0x02; ecx_114 != 0x00; --ecx_114)
					{
						edi_110->dw0000 = 0x20202020;
						edi_110 += 4;
					}
					ui32 ecx_119;
					for (ecx_119 = ecx_108 + 0x01 & 0x03; ecx_119 != 0x00; --ecx_119)
					{
						edi_110->dw0000 = (word32) 0x20;
						++edi_110;
					}
				}
				BYTE edx_126[12] = edx_100 + 1;
				edx_100 = (byte *) (edx_126 + 1);
				al_104 = (BYTE[12]) edx_126[0];
			} while (al_104 != 0x00);
		}
		fn0040368D(0x01, fp - 0x0118, 0x0100, &tLoc0518, g_t40571C.u1, g_t405944.u1, 0x00);
		fn0040343E(g_t405944.u1, 0x0100, fp - 0x0118, 0x0100, &tLoc0218, 0x0100, g_t40571C.u1, 0x00);
		fn0040343E(g_t405944.u1, 0x0200, fp - 0x0118, 0x0100, &tLoc0318, 0x0100, g_t40571C.u1, 0x00);
		struct Eq_2335 * eax_239 = null;
		union Eq_2337 * ecx_243 = &tLoc0518;
		do
		{
			byte dl_268;
			byte dl_247 = ecx_243->u0;
			if ((dl_247 & 0x01) != 0x00)
			{
				eax_239[0x00405841] = (struct Eq_2335) (eax_239[0x00405841] | 0x10);
				dl_268 = Mem270[&tLoc0218 + eax_239:byte];
				goto l00402475;
			}
			if ((dl_247 & 0x02) != 0x00)
			{
				eax_239[0x00405841] = (struct Eq_2335) (eax_239[0x00405841] | 0x20);
				dl_268 = Mem263[&tLoc0318 + eax_239:byte];
l00402475:
				eax_239[0x00405740] = (struct Eq_2335) dl_268;
			}
			else
				eax_239[0x00405740] = (struct Eq_2335) 0x00;
			++eax_239;
			ecx_243 = (union Eq_2337 *) ((char *) ecx_243 + 2);
		} while (eax_239 < (struct Eq_2335 *) 0x0100);
	}
	else
	{
		struct Eq_2260 * eax_22 = null;
		do
		{
			byte cl_51;
			byte al_49 = (byte) eax_22;
			if (eax_22 >= (struct Eq_2260 *) 0x41 && eax_22 <= (struct Eq_2260 *) 0x5A)
			{
				eax_22[0x00405841] = (struct Eq_2260) (eax_22[0x00405841] | 0x10);
				cl_51 = al_49 + 0x20;
				goto l004024BF;
			}
			if (eax_22 >= (struct Eq_2260 *) 0x61 && eax_22 <= (struct Eq_2260 *) 122)
			{
				eax_22[0x00405841] = (struct Eq_2260) (eax_22[0x00405841] | 0x20);
				cl_51 = al_49 - 0x20;
l004024BF:
				eax_22[0x00405740] = (struct Eq_2260) cl_51;
			}
			else
				eax_22[0x00405740] = (struct Eq_2260) 0x00;
			++eax_22;
		} while (eax_22 < (struct Eq_2260 *) 0x0100);
	}
}

// 004024EE: void fn004024EE()
// Called from:
//      fn00401715
//      fn0040176D
//      fn00401826
void fn004024EE()
{
	if (g_dw405A68 == 0x00)
	{
		fn0040212A(~0x02);
		g_dw405A68 = 0x01;
	}
}

// 0040250A: Register word32 fn0040250A(Stack Eq_9 dwArg04, Register out ptr32 ebpOut)
// Called from:
//      fn0040176D
//      fn00401A73
word32 fn0040250A(Eq_9 dwArg04, ptr32 & ebpOut)
{
	ptr32 ebp;
	word32 ebx;
	if (dwArg04 != 0x00)
	{
		Eq_9 eax_14 = fn00402AA3(dwArg04);
		if (eax_14 != 0x00)
		{
			ptr32 ebp_47;
			word32 ebx_43 = fn00402ACE(eax_14, dwArg04, out ebp_47);
			ebpOut = ebp_47;
			return ebx_43;
		}
		HeapFree(g_t405948, 0x00, dwArg04);
	}
	ebpOut = ebp;
	return ebx;
}

// 00402540: Register word32 fn00402540(Stack (ptr32 Eq_789) dwArg04, Stack Eq_9 dwArg08)
// Called from:
//      fn0040176D
//      fn00401F95
word32 fn00402540(struct Eq_789 * dwArg04, Eq_9 dwArg08)
{
	return fn004025B1(dwArg04, dwArg08);
}

// 00402550: void fn00402550(Stack (ptr32 Eq_1849) dwArg04, Stack Eq_9 dwArg08)
// Called from:
//      fn00401F95
void fn00402550(struct Eq_1849 * dwArg04, Eq_9 dwArg08)
{
	struct Eq_1849 * ecx_13 = dwArg04;
	if ((dwArg04 & 0x03) != 0x00)
	{
		do
		{
			++ecx_13;
			if (ecx_13->dw0000 == 0x00)
				goto l0040259F;
		} while ((ecx_13 & 0x03) != 0x00);
	}
	do
	{
		do
		{
			word32 eax_27 = ecx_13->dw0000;
			ecx_13 += 4;
		} while (((~eax_27 ^ eax_27 + 0x7EFEFEFF) & 0x81010100) == 0x00);
		ui32 eax_37 = ecx_13->dwFFFFFFFC;
		byte ah_55 = SLICE(eax_37, byte, 8);
		if ((byte) eax_37 == 0x00)
		{
			fn004025B1(ecx_13 - 4, dwArg08);
			return;
		}
		if (ah_55 == 0x00)
		{
			fn004025B1(ecx_13 - 3, dwArg08);
			return;
		}
		if ((eax_37 & 0x00FF0000) == 0x00)
		{
			fn004025B1(ecx_13 - 2, dwArg08);
			return;
		}
	} while ((eax_37 & 0xFF000000) != 0x00);
l0040259F:
	struct Eq_789 * edi_91 = ecx_13 - 1;
	fn004025B1(edi_91, dwArg08);
}

// 004025B1: Register (ptr32 Eq_789) fn004025B1(Register (ptr32 Eq_789) edi, Stack Eq_9 dwArg0C)
// Called from:
//      fn00402540
//      fn00402550
struct Eq_789 * fn004025B1(struct Eq_789 * edi, Eq_9 dwArg0C)
{
	word24 edx_24_8;
	Eq_2596 edx_135;
	Eq_9 ecx_10 = dwArg0C;
	if ((dwArg0C & 0x03) != 0x00)
	{
		do
		{
			byte dl_12 = *ecx_10.u2;
			&ecx_10.u1->dw0000 = &ecx_10.u1->b0001;
			edx_135 = SEQ(edx_24_8, dl_12);
			if (dl_12 == 0x00)
				goto l00402628;
			edi->t0000 = dl_12;
			++edi;
		} while ((ecx_10 & 0x03) != 0x00);
	}
l004025D6:
	edx_135 = ecx_10.u1->dw0000;
	Eq_2623 eax_28 = ecx_10.u1->dw0000;
	byte dl_38 = (byte) edx_135;
	byte dh_53 = SLICE(edx_135, byte, 8);
	Eq_2631 dx_58 = (word16) edx_135;
	&ecx_10.u1->dw0000 = (word32) ecx_10 + 4;
	if (((~eax_28 ^ (word32) eax_28 + 0x7EFEFEFF) & 0x81010100) != 0x00)
	{
		if (dl_38 == 0x00)
		{
l00402628:
			edi->t0000 = (byte) edx_135;
			return;
		}
		if (dh_53 == 0x00)
		{
			edi->t0000 = (CHAR) dx_58;
			return;
		}
		if ((edx_135 & 0x00FF0000) == 0x00)
		{
			edi->t0000 = (CHAR) dx_58;
			edi[2] = (struct Eq_789) 0x00;
			return;
		}
		if ((edx_135 & 0xFF000000) == 0x00)
		{
			edi->t0000 = (CHAR) edx_135;
			return;
		}
	}
	edi->t0000 = (CHAR) edx_135;
	edi += 4;
	goto l004025D6;
}

// 00402630: Register word32 fn00402630(Stack Eq_714 dwArg04)
// Called from:
//      fn0040176D
//      fn00401826
//      fn00401A73
//      fn00401BA5
word32 fn00402630(Eq_714 dwArg04)
{
	return fn00402642(dwArg04, g_dw4056FC);
}

// 00402642: Register word32 fn00402642(Stack Eq_714 dwArg04, Stack word32 dwArg08)
// Called from:
//      fn00402630
word32 fn00402642(Eq_714 dwArg04, word32 dwArg08)
{
	word32 eax_12;
	if (dwArg04 <= ~0x1F)
	{
		do
		{
			eax_12 = fn0040266E(dwArg04);
			if (eax_12 != 0x00 || dwArg08 == eax_12)
				return eax_12;
		} while (fn004037D6(dwArg04) != 0x00);
	}
	eax_12 = 0x00;
	return eax_12;
}

// 0040266E: Register Eq_9 fn0040266E(Stack Eq_714 dwArg04)
// Called from:
//      fn00402642
Eq_9 fn0040266E(Eq_714 dwArg04)
{
	Eq_9 eax_12;
	Eq_714 esi_34 = dwArg04;
	if (dwArg04 <= g_t405270.u0)
	{
		eax_12 = fn00402DF9(dwArg04);
		if (eax_12 != 0x00)
			return eax_12;
	}
	if (dwArg04 == 0x00)
		esi_34.u0 = 0x01;
	eax_12 = HeapAlloc(g_t405948, 0x00, (word32) esi_34 + 0x0F & ~0x0F);
	return eax_12;
}

// 004026B0: Register ptr32 fn004026B0(Stack Eq_9 dwArg04)
// Called from:
//      fn0040176D
//      fn00401F95
ptr32 fn004026B0(Eq_9 dwArg04)
{
	Eq_9 ecx_10 = dwArg04;
	if ((dwArg04 & 0x03) != 0x00)
	{
		do
		{
			&ecx_10.u1->dw0000 = &ecx_10.u1->b0001;
			if (*ecx_10.u2 == 0x00)
				return ecx_10 - 1 - dwArg04;
		} while ((ecx_10 & 0x03) != 0x00);
	}
	do
	{
		do
		{
			word32 eax_29 = ecx_10.u1->dw0000;
			&ecx_10.u1->dw0000 = (word32) ecx_10 + 4;
		} while (((~eax_29 ^ eax_29 + 0x7EFEFEFF) & 0x81010100) == 0x00);
		ui32 eax_39 = *((word32) ecx_10 - 4);
		byte ah_50 = SLICE(eax_39, byte, 8);
		if ((byte) eax_39 == 0x00)
			return ecx_10 - 4 - dwArg04;
		if (ah_50 == 0x00)
			return ecx_10 - 3 - dwArg04;
		if ((eax_39 & 0x00FF0000) == 0x00)
			return ecx_10 - 2 - dwArg04;
	} while ((eax_39 & 0xFF000000) != 0x00);
	return ecx_10 - 1 - dwArg04;
}

// 00402730: Register Eq_9 fn00402730(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08, Stack uint32 dwArg0C, Register out Eq_9 ediOut)
// Called from:
//      fn00401A73
Eq_9 fn00402730(Eq_9 dwArg04, Eq_9 dwArg08, uint32 dwArg0C, union Eq_9 & ediOut)
{
	Eq_9 edi;
	Eq_9 esi;
	Eq_9 esi_14 = dwArg08;
	Eq_9 edi_16 = dwArg04;
	Eq_9 eax_19 = dwArg08.u1 + dwArg0C / 4;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_19)
	{
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (dwArg0C < 0x04)
			{
				switch (dwArg0C)
				{
				case 0x00:
					ediOut = edi;
					return esi;
				case 0x01:
					*dwArg04.u2 = *dwArg08.u2;
					ediOut = edi;
					return esi;
				case 0x02:
					*dwArg04.u2 = *dwArg08.u2;
					dwArg04.u1->b0001 = dwArg08.u1->b0001;
					ediOut = edi;
					return esi;
				case 0x03:
					*dwArg04.u2 = *dwArg08.u2;
					dwArg04.u1->b0001 = dwArg08.u1->b0001;
					dwArg04.u1->b0002 = dwArg08.u1->b0002;
					ediOut = edi;
					return esi;
				}
			}
			else
			{
				(*((char *) g_a402790 + (dwArg04 & 0x03) * 0x04))();
				ediOut = dwArg04;
				return dwArg08;
			}
		}
		else if (dwArg0C >> 0x02 < 0x08)
		{
			switch (dwArg0C >> 0x02)
			{
			case 0x00:
				goto l0040286F;
			case 0x01:
				goto l0040285C;
			case 0x02:
				goto l00402854;
			case 0x03:
				goto l0040284C;
			case 0x04:
				goto l00402844;
			case 0x05:
				goto l0040283C;
			case 0x06:
				break;
			case 0x07:
				(dwArg04 - 28)[dwArg0C >> 0x02] = (dwArg08 - 28)[dwArg0C >> 0x02];
				break;
			}
			(dwArg04 - 24)[dwArg0C >> 0x02] = (dwArg08 - 24)[dwArg0C >> 0x02];
l0040283C:
			(dwArg04 - 20)[dwArg0C >> 0x02] = (dwArg08 - 20)[dwArg0C >> 0x02];
l00402844:
			(dwArg04 - 16)[dwArg0C >> 0x02] = (dwArg08 - 16)[dwArg0C >> 0x02];
l0040284C:
			(dwArg04 - 0x0C)[dwArg0C >> 0x02] = (dwArg08 - 0x0C)[dwArg0C >> 0x02];
l00402854:
			(dwArg04 - 8)[dwArg0C >> 0x02] = (dwArg08 - 8)[dwArg0C >> 0x02];
l0040285C:
			(dwArg04 - 4)[dwArg0C >> 0x02] = (dwArg08 - 4)[dwArg0C >> 0x02];
			int32 eax_241 = (dwArg0C >> 0x02) * 0x04;
			&esi_14.u1->dw0000 = dwArg08.u1 + eax_241 / 4;
			&edi_16.u1->dw0000 = dwArg04.u1 + eax_241 / 4;
l0040286F:
			(*((char *) g_a402878 + (dwArg0C & 0x03) * 0x04))();
			ediOut = edi_16;
			return esi_14;
		}
		else
		{
			Eq_2823 size_282 = (dwArg0C >> 0x02) * 0x04;
			memcpy(dwArg04, dwArg08, size_282);
			(*((char *) g_a402878 + (dwArg0C & 0x03) * 0x04))();
			ediOut = dwArg04 + size_282;
			return dwArg08 + size_282;
		}
	}
	else
	{
		Eq_9 esi_102 = dwArg08.u1 + (dwArg0C - 4) / 4;
		Eq_9 edi_105 = dwArg04.u1 + (dwArg0C - 4) / 4;
		if ((edi_105 & 0x03) == 0x00)
		{
			uint32 ecx_130 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (dwArg0C >> 0x02)
				{
				case 0x00:
					(*((char *) g_a402A10 + (dwArg0C & 0x03) * 0x04))();
					ediOut = edi_105;
					return esi_102;
				}
			}
			for (; ecx_130 != 0x00; --ecx_130)
			{
				edi_105.u1->dw0000 = esi_102.u1->dw0000;
				esi_102 -= 4;
				edi_105 -= 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
				goto l00402A28;
			case 0x02:
				goto l00402A38;
			case 0x03:
				goto l00402A4C;
			}
		}
		else
		{
			if (dwArg0C >= 0x04)
			{
				(*((char *) g_a402918 + (edi_105 & 0x03) * 0x04))();
				ediOut = edi_105;
				return esi_102;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
l00402A28:
				edi_105.u1->b0003 = esi_102.u1->b0003;
				ediOut = edi;
				return esi;
			case 0x02:
l00402A38:
				edi_105.u1->b0003 = esi_102.u1->b0003;
				edi_105.u1->b0002 = esi_102.u1->b0002;
				ediOut = edi;
				return esi;
			case 0x03:
l00402A4C:
				edi_105.u1->b0003 = esi_102.u1->b0003;
				edi_105.u1->b0002 = esi_102.u1->b0002;
				edi_105.u1->b0001 = esi_102.u1->b0001;
				ediOut = edi;
				return esi;
			}
		}
		ediOut = edi;
		return esi;
	}
}

<anonymous> * g_a402790[] = // 00402790
	{
	};
<anonymous> * g_a402878[] = // 00402878
	{
	};
<anonymous> * g_a402918[] = // 00402918
	{
	};
<anonymous> * g_a402A10[] = // 00402A10
	{
	};
// 00402A65: Register Eq_9 fn00402A65()
// Called from:
//      fn00401D50
Eq_9 fn00402A65()
{
	Eq_9 eax_11 = HeapAlloc(g_t405948, 0x00, 0x0140);
	g_t405718.u1 = (DWORD) eax_11;
	if (eax_11 == 0x00)
		return eax_11;
	g_t405710.u1 = (DWORD) 0x00;
	g_dw405714 = 0x00;
	g_t40570C.u1 = (DWORD) eax_11;
	g_dw405704 = 0x10;
	return 0x01;
}

// 00402AA3: Register Eq_9 fn00402AA3(Stack Eq_9 dwArg04)
// Called from:
//      fn0040250A
Eq_9 fn00402AA3(Eq_9 dwArg04)
{
	Eq_9 eax_13 = g_t405718.u1;
	Eq_9 ecx_8 = eax_13.u1 + g_dw405714 * 5;
	while (eax_13 < ecx_8)
	{
		if (dwArg04 - *((byte) eax_13.u0 + 0x0C) < 0x00100000)
			return eax_13;
		&eax_13.u1->dw0000 = (byte) eax_13.u0 + 20;
	}
	eax_13.u0 = 0x00;
	return eax_13;
}

// 00402ACE: Register word32 fn00402ACE(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08, Register out ptr32 ebpOut)
// Called from:
//      fn0040250A
word32 fn00402ACE(Eq_9 dwArg04, Eq_9 dwArg08, ptr32 & ebpOut)
{
	ptr32 fp;
	Eq_9 dwArg08_528;
	int32 ebx_20 = *((word32) dwArg08 - 4);
	Eq_3101 esi_19 = dwArg08 - *((word32) dwArg04 + 0x0C);
	Eq_9 eax_17 = *((word32) dwArg04 + 16);
	int32 ecx_34 = *((word32) (ebx_20 - 0x01) + ((word32) dwArg08 - 4));
	struct Eq_3117 * ebp_469 = fp - 4;
	struct Eq_3120 * edx_21 = (word32) dwArg08 - 4;
	Eq_3122 esi_25 = esi_19 >> 0x0F;
	int32 edi_27 = *((word32) dwArg08 - 8);
	int32 ebx_112 = ebx_20 - 0x01;
	word32 * ecx_31 = eax_17.u1 + ((esi_19 >> 0x0F) *s 0x0204 + 0x0144) / 4;
	int32 dwLoc10_524 = ebx_20 - 0x01;
	dwArg08_528 = dwArg08;
	if (((byte) ecx_34 & 0x01) == 0x00)
	{
		Eq_9 ecx_44 = (ecx_34 >> 0x04) - 0x01;
		dwArg08_528 = ecx_44;
		if (ecx_44 > 0x3F)
			dwArg08_528.u0 = 0x3F;
		if (*((word32) (ebx_20 + 0x03) + ((word32) dwArg08 - 4)) == *((word32) (ebx_20 + 0x07) + ((word32) dwArg08 - 4)))
		{
			byte cl_85 = (byte) dwArg08_528;
			if (dwArg08_528 < 0x20)
			{
				uint32 edi_88 = ~(0x80000000 >> cl_85);
				&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044))->u1->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044)) & edi_88;
				word32 ecx_87 = dwArg08_528 + 4 + eax_17;
				Eq_3290 v22_93 = ecx_87.u1->t0000.u1 - 0x01;
				ecx_87.u1->t0000.u1 = (byte) v22_93;
				if (v22_93 == 0x00)
					dwArg04.u1->dw0000 = (word32) (dwArg04.u1->dw0000 & edi_88);
			}
			else
			{
				uint32 edi_68 = ~(0x80000000 >> (byte) dwArg08_528 + 0xE0);
				&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4))->u1->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4)) & edi_68;
				word32 ecx_67 = dwArg08_528 + 4 + eax_17;
				byte v25_74 = *ecx_67 - 0x01;
				*ecx_67 = v25_74;
				if (v25_74 == 0x00)
					&((word32) dwArg04 + 4)->u1->dw0000 = *((word32) dwArg04 + 4) & edi_68;
			}
		}
		*((word32) *((word32) (ebx_20 + 0x07) + ((word32) dwArg08 - 4)) + 4) = *((word32) (ebx_20 + 0x03) + ((word32) dwArg08 - 4));
		*((word32) *((word32) (ebx_20 + 0x03) + ((word32) dwArg08 - 4)) + 8) = *((word32) (ebx_20 + 0x07) + ((word32) dwArg08 - 4));
		ebx_112 = ebx_20 - 0x01 + ecx_34;
		dwLoc10_524 = ebx_112;
	}
	Eq_3145 edi_118 = ebx_112 >> 0x04;
	Eq_9 edi_119 = edi_118 - 0x01;
	if (edi_118 > 0x40)
		edi_119.u0 = 0x3F;
	if ((edi_27 & 0x01) == 0x00)
	{
		Eq_9 ecx_149 = (edi_27 >> 0x04) - 0x01;
		struct Eq_3120 * edx_142 = (word32) dwArg08 - 4 - edi_27;
		dwArg08_528 = ecx_149;
		if (ecx_149 > 0x3F)
		{
			dwArg08_528.u0 = 0x3F;
			ecx_149.u0 = 0x3F;
		}
		ebx_112 += edi_27;
		dwLoc10_524 = ebx_112;
		edi_119 = (ebx_112 >> 0x04) - 0x01;
		if (edi_119 > 0x3F)
			edi_119.u0 = 0x3F;
		if (ecx_149 != edi_119)
		{
			if (edx_142->ptr0004 == edx_142->ptr0008)
			{
				byte cl_216 = (byte) dwArg08_528;
				if (dwArg08_528 < 0x20)
				{
					uint32 edx_219 = ~(0x80000000 >> cl_216);
					&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044))->u1->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x0044)) & edx_219;
					word32 ecx_218 = dwArg08_528 + 4 + eax_17;
					Eq_3290 v28_224 = ecx_218.u1->t0000.u1 - 0x01;
					ecx_218.u1->t0000.u1 = (byte) v28_224;
					if (v28_224 == 0x00)
						dwArg04.u1->dw0000 = (word32) (dwArg04.u1->dw0000 & edx_219);
				}
				else
				{
					uint32 edx_195 = ~(0x80000000 >> (byte) dwArg08_528 + 0xE0);
					&((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4))->u1->dw0000 = *((word32) eax_17 + ((esi_19 >> 0x0F) * 0x04 + 0x00C4)) & edx_195;
					word32 ecx_194 = dwArg08_528 + 4 + eax_17;
					Eq_3290 v31_205 = ecx_194.u1->t0000.u1 - 0x01;
					ecx_194.u1->t0000.u1 = (byte) v31_205;
					if (v31_205 == 0x00)
						&((word32) dwArg04 + 4)->u1->dw0000 = *((word32) dwArg04 + 4) & edx_195;
				}
			}
			edx_142->ptr0008->ptr0004 = edx_142->ptr0004;
			edx_142->ptr0004->ptr0008 = edx_142->ptr0008;
		}
		edx_21 = edx_142;
	}
	struct Eq_3177 * esp_377 = fp - 0x24;
	if ((edi_27 & 0x01) != 0x00 || dwArg08_528 != edi_119)
	{
		edx_21->ptr0004 = (ecx_31 + edi_119 * 0x08)[1];
		word32 ecx_267 = ecx_31 + edi_119 * 0x08;
		edx_21->ptr0008 = ecx_267;
		ecx_267->ptr0004 = edx_21;
		edx_21->ptr0004->ptr0008 = edx_21;
		if (edx_21->ptr0004 == edx_21->ptr0008)
		{
			byte cl_279 = Mem271[edi_119 + 4 + eax_17:byte];
			Mem284[edi_119 + 4 + eax_17:byte] = cl_279 + 0x01;
			if (edi_119 < 0x20)
			{
				if (cl_279 == 0x00)
					dwArg04.u1->dw0000 = (word32) (dwArg04.u1->dw0000 | 0x80000000 >> (byte) edi_119);
				word32 eax_335 = eax_17 + 0x0044 + (esi_19 >>u 0x0F) * 0x04;
				eax_335.u1->t0000.u0 = (ui32) (eax_335.u1->t0000.u0 | 0x80000000 >> (byte) edi_119);
			}
			else
			{
				if (cl_279 == 0x00)
					&((word32) dwArg04 + 4)->u1->dw0000 = *((word32) dwArg04 + 4) | 0x80000000 >> (byte) edi_119 - 0x20;
				word32 eax_309 = eax_17 + 0xC4 + (esi_19 >>u 0x0F) * 0x04;
				eax_309.u1->t0000.u0 = (ui32) (eax_309.u1->t0000.u0 | 0x80000000 >> (byte) edi_119 - 0x20);
			}
			ebx_112 = dwLoc10_524;
		}
	}
	edx_21->dw0000 = ebx_112;
	edx_21[(ebx_112 - 4) / 0x0C] = (struct Eq_3120) ebx_112;
	word32 v36_362 = *ecx_31 - 0x01;
	*ecx_31 = v36_362;
	if (v36_362 != 0x00)
	{
l00402DF4:
		word32 ebx_510 = esp_377->dw0008;
		ebpOut = ebp_469->ptr0000;
		return ebx_510;
	}
	Eq_9 eax_429;
	Eq_9 eax_366 = g_t405710.u1;
	if (eax_366 != 0x00)
	{
		VirtualFree(((word32) eax_366 + 0x0C)->u1 + (g_t405708.u0 << 0x0F) / 4, 0x8000, 0x4000);
		Eq_9 eax_395 = g_t405710.u1;
		&((word32) eax_395 + 8)->u1->dw0000 = *((word32) eax_395 + 8) | 0x80000000 >> g_t405708;
		*((byte) g_t405710.u1[4].b0003 + (g_t405708.u0 * 0x04 + 0x00C1)) = (struct Eq_5969) 0x00;
		Eq_9 eax_409 = g_t405710.u1[4];
		&((word32) eax_409 + 67)->u1->dw0000 = *((word32) eax_409 + 67) - 0x01;
		Eq_9 eax_412 = g_t405710.u1;
		if (*((word32) *((word32) eax_412 + 16) + 67) == 0x00)
		{
			&((word32) eax_412 + 4)->u1->dw0000 = *((word32) eax_412 + 4) & ~0x01;
			&eax_412.u1->dw0000 = g_t405710.u1;
		}
		if (*((word32) eax_412 + 8) == ~0x00)
		{
			VirtualFree(eax_412.u1[3], 0x00, 0x8000);
			HeapFree(g_t405948, 0x00, g_t405710.u1[4]);
			Eq_9 eax_457 = g_t405710.u1;
			ebp_469 = fn00403800(eax_457, (word32) eax_457 + 20, g_t405718.u1 + ((g_dw405714 * 0x14 - eax_457) - 20) / 4, out esi_25);
			&eax_429.u1->dw0000 = ebp_469->t0008.u1;
			--g_dw405714;
			esp_377 = fp - 0x30;
			if (eax_429 > g_t405710.u1)
				eax_429 -= 0x14;
			g_t40570C.u1 = g_t405718.u1;
l00402DE9:
			g_t405710.u1 = (DWORD) eax_429;
			g_t405708.u0 = (int32) esi_25;
			goto l00402DF4;
		}
	}
	esp_377 = fp - 0x24;
	eax_429 = dwArg04;
	goto l00402DE9;
}

// 00402DF9: Register ptr32 fn00402DF9(Stack Eq_714 dwArg04)
// Called from:
//      fn0040266E
ptr32 fn00402DF9(Eq_714 dwArg04)
{
	uint32 dwLoc10_571;
	uint32 esi_183;
	uint32 dwLoc0C_572;
	int32 ecx_25 = (word32) dwArg04 + 23 & ~0x0F;
	Eq_9 edx_10 = g_t405718.u1;
	int32 ecx_28 = (ecx_25 >> 0x04) - 0x01;
	Eq_9 edi_21 = edx_10.u1 + g_dw405714 * 5;
	byte cl_40 = (byte) ecx_28;
	if (ecx_28 < 0x20)
	{
		esi_183 = ~0x00 >> cl_40;
		dwLoc0C_572 = ~0x00;
		dwLoc10_571 = esi_183;
	}
	else
	{
		esi_183 = 0x00;
		dwLoc10_571 = 0x00;
		dwLoc0C_572 = ~0x00 >> (byte) ecx_28 + 0xE0;
	}
	Eq_9 eax_49 = g_t40570C.u1;
	Eq_9 ebx_102 = eax_49;
	Eq_9 dwArg04_575 = eax_49;
	if (eax_49 < edi_21)
	{
		while ((*((word32) ebx_102 + 4) & dwLoc0C_572 | (ebx_102.u1)->dw0000 & esi_183) == 0x00)
		{
			ebx_102 += 0x14;
			dwArg04_575 = ebx_102;
			if (ebx_102 >= edi_21)
				break;
		}
	}
	ptr32 eax_504;
	if (ebx_102 == edi_21)
	{
		ebx_102 = edx_10;
		while (true)
		{
			bool v37_555 = ebx_102 != eax_49;
			dwArg04_575 = ebx_102;
			if (ebx_102 >= eax_49)
				break;
			if ((*((word32) ebx_102 + 4) & dwLoc0C_572 | (ebx_102.u1)->dw0000 & esi_183) != 0x00)
			{
				v37_555 = ebx_102 != eax_49;
				break;
			}
			ebx_102 += 0x14;
		}
		if (!v37_555)
		{
			while (true)
			{
				bool v40_558 = ebx_102 != edi_21;
				if (ebx_102 >= edi_21)
					break;
				if (*((word32) ebx_102 + 8) != 0x00)
				{
					v40_558 = ebx_102 != edi_21;
					break;
				}
				ebx_102 += 0x14;
				dwArg04_575 = ebx_102;
			}
			if (!v40_558)
			{
				ebx_102 = edx_10;
				while (true)
				{
					bool v43_561 = ebx_102 != eax_49;
					dwArg04_575 = ebx_102;
					if (ebx_102 >= eax_49)
						break;
					if (*((word32) ebx_102 + 8) != 0x00)
					{
						v43_561 = ebx_102 != eax_49;
						break;
					}
					ebx_102 += 0x14;
				}
				if (!v43_561)
				{
					Eq_9 eax_128 = fn00403102();
					ebx_102 = eax_128;
					dwArg04_575 = eax_128;
					if (eax_128 == 0x00)
					{
l00402EE7:
						eax_504 = 0x00;
						return eax_504;
					}
				}
			}
			((word32) ebx_102 + 16)->u1->dw0000 = fn004031B3(ebx_102);
			if (((word32) ebx_102 + 16)->u1->dw0000 == ~0x00)
				goto l00402EE7;
		}
	}
	g_t40570C.u1 = (DWORD) ebx_102;
	struct Eq_3759 * eax_169 = *((word32) ebx_102 + 16);
	Eq_3122 edx_170 = eax_169->t0000.u0;
	Eq_3122 dwLoc08_587 = edx_170;
	if (edx_170 == ~0x00 || ((eax_169->a00C4)[edx_170] & dwLoc0C_572 | (eax_169->a0044)[edx_170] & esi_183) == 0x00)
	{
		dwLoc08_587.u0 = 0x00;
		ui32 * ecx_206 = eax_169->a0044 + 33;
		esi_183 = dwLoc10_571;
		if ((eax_169->a00C4[0] & dwLoc0C_572 | (eax_169->a0044)[0] & dwLoc10_571) == 0x00)
		{
			do
			{
				ecx_206 = ecx_858 + 1;
				dwLoc08_587 = (word32) dwLoc08_587.u0 + 1;
				ecx_858 = ecx_206;
			} while ((*ecx_858 & dwLoc0C_572 | dwLoc10_571 & *ecx_206) == 0x00);
		}
		edx_170 = dwLoc08_587;
	}
	int32 edi_234 = 0x00;
	struct Eq_3821 * ecx_239 = eax_169 + (edx_170 *s 0x0204 + 0x0144) / 0x00C4;
	int32 ecx_245 = eax_169->a0044[edx_170] & esi_183;
	if (ecx_245 == 0x00)
	{
		ecx_245 = eax_169->a00C4[edx_170] & dwLoc0C_572;
		edi_234 = 0x20;
	}
	for (; ecx_245 >= 0x00; ecx_245 <<= 0x01)
		++edi_234;
	struct Eq_3872 * edx_279 = ecx_239->a0004[edi_234].ptr0000;
	int32 ecx_281 = *edx_279 - ecx_25;
	int32 esi_285 = (ecx_281 >> 0x04) - 0x01;
	if (esi_285 > 0x3F)
		esi_285 = 0x3F;
	if (esi_285 == edi_234)
	{
l004030B0:
		if (ecx_281 != 0x00)
		{
			*edx_279 = ecx_281;
			edx_279[(ecx_281 - 4) / 0x0C] = (struct Eq_3872) ecx_281;
		}
		goto l004030BF;
	}
	if (edx_279->ptr0004 == edx_279->ptr0008)
	{
		if (edi_234 < 0x20)
		{
			uint32 ebx_337 = ~(0x80000000 >> (byte) edi_234);
			eax_169->a0044[dwLoc08_587] = ebx_337 & (eax_169->a0044)[dwLoc08_587];
			byte * edi_336 = (char *) &eax_169->t0000 + 4 + edi_234;
			byte v24_342 = *edi_336 - 0x01;
			*edi_336 = v24_342;
			if (v24_342 == 0x00)
			{
				dwArg04_575.u1->dw0000 &= ebx_337;
				ebx_102 = dwArg04_575;
				goto l0040300C;
			}
l00403009:
			ebx_102 = dwArg04_575;
			goto l0040300C;
		}
		ui32 * ecx_313 = eax_169->a00C4 + dwLoc08_587;
		uint32 ebx_314 = ~(0x80000000 >> (byte) edi_234 - 0x20);
		*ecx_313 &= ebx_314;
		byte * edi_312 = (char *) &eax_169->t0000 + 4 + edi_234;
		byte v27_319 = *edi_312 - 0x01;
		*edi_312 = v27_319;
		if (v27_319 != 0x00)
			goto l00403009;
		&((word32) dwArg04_575 + 4)->u1->dw0000 = *((word32) dwArg04_575 + 4) & ebx_314;
		ebx_102 = dwArg04_575;
	}
l0040300C:
	edx_279->ptr0008->ptr0004 = edx_279->ptr0004;
	edx_279->ptr0004->ptr0008 = edx_279->ptr0008;
	if (ecx_281 == 0x00)
	{
l004030BF:
		int32 * edx_468 = edx_279 + ecx_281 / 0x0C;
		*edx_468 = ecx_25 + 1;
		(edx_468 - 4)[ecx_25 / 4] = ecx_25 + 1;
		word32 ecx_473 = ecx_239->dw0000;
		ecx_239->dw0000 = ecx_473 + 1;
		if (ecx_473 == 0x00 && (ebx_102 == g_t405710.u1 && dwLoc08_587 == g_t405708.u0))
			g_t405710.u1 = (DWORD) 0x00;
		eax_169->t0000.u0 = (int32) dwLoc08_587;
		eax_504 = edx_468 + 1;
		return eax_504;
	}
	edx_279->ptr0004 = ecx_239->a0004[esi_285].ptr0000;
	struct Eq_3872 * ecx_373 = ecx_239 + esi_285 * 2;
	edx_279->ptr0008 = ecx_373;
	ecx_373->ptr0004 = edx_279;
	edx_279->ptr0004->ptr0008 = edx_279;
	if (edx_279->ptr0004 == edx_279->ptr0008)
	{
		byte cl_384 = eax_169[(esi_285 + 4) / 0x00C4];
		if (esi_285 < 0x20)
		{
			eax_169[(esi_285 + 4) / 0x00C4] = (struct Eq_3759) (cl_384 + 0x01);
			if (cl_384 == 0x00)
				ebx_102.u1->dw0000 |= 0x80000000 >> (byte) esi_285;
			eax_169->a0044[dwLoc08_587] |= 0x80000000 >> (byte) esi_285;
		}
		else
		{
			eax_169[(esi_285 + 4) / 0x00C4] = (struct Eq_3759) (cl_384 + 0x01);
			if (cl_384 == 0x00)
				&((word32) ebx_102 + 4)->u1->dw0000 = *((word32) ebx_102 + 4) | 0x80000000 >> (byte) esi_285 - 0x20;
			ui32 * edi_408 = eax_169->a00C4 + dwLoc08_587;
			*edi_408 |= 0x80000000 >> (byte) esi_285 - 0x20;
		}
	}
	goto l004030B0;
}

// 00403102: Register (ptr0 Eq_4192) fn00403102()
// Called from:
//      fn00402DF9
struct Eq_4192 * fn00403102()
{
	struct Eq_4192 * eax_128;
	ui32 eax_36 = g_dw405714;
	ui32 ecx_6 = g_dw405704;
	if (eax_36 == ecx_6)
	{
		Eq_9 eax_28 = HeapReAlloc(g_t405948, 0x00, g_t405718.u1, ecx_6 + 80 + ecx_6 * 0x04 << 0x02);
		if (eax_28 == 0x00)
		{
l00403195:
			eax_128 = null;
			return eax_128;
		}
		g_dw405704 += 0x10;
		g_t405718.u1 = (DWORD) eax_28;
		eax_36 = g_dw405714;
	}
	word32 esi_49 = Mem37[0x00405718<p32>:word32] + eax_36 * 0x14;
	Eq_9 eax_50 = HeapAlloc(g_t405948, 0x08, 0x41C4);
	esi_49->t0010.u1 = (DWORD) eax_50;
	if (eax_50 != 0x00)
	{
		Eq_9 eax_64 = VirtualAlloc(0x00, 0x00100000, 0x2000, 0x04);
		esi_49->t000C.u1 = (DWORD) eax_64;
		if (eax_64 != 0x00)
		{
			esi_49->dw0008 = ~0x00;
			esi_49->dw0000 = 0x00;
			esi_49->dw0004 = 0x00;
			++g_dw405714;
			esi_49->t0010.u1->dw0000 = ~0x00;
			eax_128 = esi_49;
			return eax_128;
		}
		HeapFree(g_t405948, 0x00, esi_49->t0010.u1);
	}
	goto l00403195;
}

// 004031B3: Register int32 fn004031B3(Stack Eq_9 dwArg04)
// Called from:
//      fn00402DF9
int32 fn004031B3(Eq_9 dwArg04)
{
	Eq_9 esi_21 = *((word32) dwArg04 + 16);
	int32 eax_174;
	int32 ebx_176 = 0x00;
	for (eax_174 = *((word32) dwArg04 + 8); eax_174 >= 0x00; eax_174 <<= 0x01)
		++ebx_176;
	word32 edx_40;
	struct Eq_4310 * eax_43 = esi_21.u1 + (ebx_176 *s 0x0204 + 0x0144) / 4;
	eax_46 = eax_43;
	for (edx_40 = 0x3F; edx_40 != 0x00; --edx_40)
	{
		struct Eq_4310 * eax_46;
		eax_46[1] = (struct Eq_4310) eax_46;
		eax_46->dw0004 = eax_46;
		++eax_46;
	}
	int32 eax_156;
	Eq_9 edi_63 = ((word32) dwArg04 + 0x0C)->u1 + (ebx_176 << 0x0F) / 4;
	if (VirtualAlloc(edi_63, 0x8000, 0x1000, 0x04) == 0x00)
		eax_156 = ~0x00;
	else
	{
		if (edi_63 <=u edi_63 + 0x7000)
		{
			word32 eax_79 = edi_63 + 16;
			do
			{
				eax_79.u0->dwFFFFFFF8 = ~0x00;
				eax_79.u0->dw0FEC = ~0x00;
				eax_79.u0->dwFFFFFFFC = 0x0FF0;
				Mem90[eax_79 + 0x00:word32] = eax_79 + 0x0FFC;
				Mem92[eax_79 + 4:word32] = eax_79 + ~0x1003;
				eax_79.u0->dw0FE8 = 0x0FF0;
				eax_79 += 0x1000;
			} while (eax_79 - 16 <=u edi_63 + 0x7000);
		}
		eax_43->t01FC = (Eq_4360) ((word32) edi_63 + 0x0C);
		&((word32) edi_63 + 20)->u1->dw0000 = eax_43 + 63;
		Mem118[eax_43 + 0x0200:word32] = edi_63 + 0x700C;
		&((word32) edi_63 + 28688)->u1->dw0000 = eax_43 + 63;
		&((word32) esi_21 + (ebx_176 * 0x04 + 0x0044))->u1->dw0000 = 0x00;
		&((word32) esi_21 + (ebx_176 * 0x04 + 0x00C4))->u1->dw0000 = 0x01;
		byte al_129 = *((word32) esi_21 + 67);
		&((word32) esi_21 + 67)->u1->dw0000 = al_129 + 0x01;
		if (al_129 == 0x00)
			&((word32) dwArg04 + 4)->u1->dw0000 = *((word32) dwArg04 + 4) | 0x01;
		&((word32) dwArg04 + 8)->u1->dw0000 = *((word32) dwArg04 + 8) & ~(0x80000000 >> (byte) ebx_176);
		eax_156 = ebx_176;
	}
	return eax_156;
}

// 004032AE: void fn004032AE()
// Called from:
//      fn00401F95
void fn004032AE()
{
	ptr32 fp;
	word32 ebx_68 = 0x00;
	if (g_t4056C8 == null)
	{
		Eq_3 eax_18 = LoadLibraryA(0x0040441C);
		if (eax_18 == 0x00)
			return;
		Eq_4459 eax_28 = GetProcAddress(eax_18, 0x00404410);
		g_t4056C8 = eax_28;
		if (eax_28 == null)
			return;
		g_t4056CC = GetProcAddress(eax_18, 0x00404400);
		g_t4056D0 = GetProcAddress(eax_18, 0x004043EC);
	}
	struct Eq_4462 * esp_62 = fp - 0x0C;
	Eq_4459 eax_54 = g_t4056CC;
	if (eax_54 != null)
	{
		word32 eax_65;
		eax_54();
		ebx_68 = eax_65;
		if (eax_65 != 0x00)
		{
			Eq_4459 eax_73 = g_t4056D0;
			if (eax_73 != null)
			{
				esp_62->dwFFFFFFFC = eax_65;
				word32 eax_81;
				eax_73();
				ebx_68 = eax_81;
			}
		}
	}
	struct Eq_4503 * esp_88 = esp_62 - 4;
	esp_88->dw0000 = esp_62->dw0018;
	esp_88->dwFFFFFFFC = esp_88->dw0018;
	esp_88->dwFFFFFFF8 = esp_88->dw0014;
	esp_88->dwFFFFFFF4 = ebx_68;
	g_t4056C8();
}

// 00403340: void fn00403340(Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fn00401F95
void fn00403340(byte * dwArg04, byte * dwArg08, uint32 dwArg0C)
{
	uint32 ecx_33 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	uint32 ecx_144;
	byte al_191;
	uint32 ecx_126;
	uint32 ebx_130 = dwArg0C;
	byte * esi_189 = dwArg08;
	byte * edi_123 = dwArg04;
	if ((dwArg08 & 0x03) == 0x00)
	{
		ecx_126 = dwArg0C >> 0x02;
		if (dwArg0C >> 0x02 == 0x00)
			goto l00403385;
	}
	else
	{
		do
		{
			al_191 = *esi_189;
			*edi_123 = al_191;
			++esi_189;
			++edi_123;
			--ecx_33;
			if (ecx_33 == 0x00)
				return;
			if (al_191 == 0x00)
			{
				while ((edi_123 & 0x03) != 0x00)
				{
					*edi_123 = al_191;
					++edi_123;
					--ecx_33;
					if (ecx_33 == 0x00)
						return;
				}
				ebx_130 = ecx_33;
				ecx_144 = ecx_33 >> 0x02;
				if (ecx_144 != 0x00)
				{
l00403427:
					do
					{
						*edi_123 = (byte) 0x00;
						edi_123 += 4;
						--ecx_144;
					} while (ecx_144 != 0x00);
l00403431:
					al_191 = 0x00;
					ebx_130 &= 0x03;
					if (ebx_130 == 0x00)
						return;
				}
				do
				{
					*edi_123 = al_191;
					++edi_123;
l004033BE:
					--ebx_130;
				} while (ebx_130 != 0x00);
				return;
			}
		} while ((esi_189 & 0x03) != 0x00);
		ebx_130 = ecx_33;
		ecx_126 = ecx_33 >> 0x02;
		if (ecx_33 >> 0x02 == 0x00)
		{
l00403380:
			ebx_130 &= 0x03;
			if (ebx_130 == 0x00)
				return;
l00403385:
			do
			{
				al_191 = *esi_189;
				*edi_123 = al_191;
				++esi_189;
				++edi_123;
				if (al_191 == 0x00)
					goto l004033BE;
				--ebx_130;
			} while (ebx_130 != 0x00);
			return;
		}
	}
	do
	{
		Eq_4571 edx_80 = *esi_189;
		Eq_4575 eax_76 = *esi_189;
		byte dl_86 = (byte) edx_80;
		byte dh_97 = SLICE(edx_80, byte, 8);
		esi_189 += 4;
		if (((~eax_76 ^ (word32) eax_76 + 0x7EFEFEFF) & 0x81010100) != 0x00)
		{
			if (dl_86 != 0x00)
			{
				if (dh_97 != 0x00)
				{
					if ((edx_80 & 0x00FF0000) != 0x00)
					{
						if ((edx_80 & 0xFF000000) != 0x00)
							goto l004033C9;
						*edi_123 = (byte) edx_80;
					}
					else
						*edi_123 = (byte) (edx_80 & 0xFFFF);
				}
				else
					*edi_123 = (byte) (edx_80 & 0xFF);
			}
			else
				*edi_123 = (byte) 0x00;
			edi_123 += 4;
			ecx_144 = ecx_126 - 0x01;
			if (ecx_144 != 0x00)
				goto l00403427;
			goto l00403431;
		}
l004033C9:
		*edi_123 = (byte) edx_80;
		edi_123 += 4;
		--ecx_126;
	} while (ecx_126 != 0x00);
	goto l00403380;
}

// 0040343E: void fn0040343E(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08, Stack Eq_9 dwArg0C, Stack Eq_9 dwArg10, Stack Eq_9 dwArg14, Stack Eq_9 dwArg18, Stack Eq_9 dwArg1C, Stack word32 dwArg20)
// Called from:
//      fn00402369
void fn0040343E(Eq_9 dwArg04, Eq_9 dwArg08, Eq_9 dwArg0C, Eq_9 dwArg10, Eq_9 dwArg14, Eq_9 dwArg18, Eq_9 dwArg1C, word32 dwArg20)
{
	ptr32 fp;
	struct Eq_4714 * fs;
	byte bArg09_441 = SLICE(dwArg08, byte, 8);
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	if (g_dw4056F4 == 0x00)
	{
		if (LCMapStringW(0x00, 0x0100, 0x0040442C, 0x01, 0x00, 0x00) != 0x00)
			g_dw4056F4 = 0x01;
		else
		{
			if (LCMapStringA(0x00, 0x0100, 0x00404428, 0x01, 0x00, 0x00) == 0x00)
				goto l004035CC;
			g_dw4056F4 = 0x02;
		}
	}
	if (dwArg10 > 0x00)
		dwArg10 = fn00403662(dwArg0C, dwArg10);
	word32 eax_102 = g_dw4056F4;
	if (eax_102 == 0x02)
	{
		LCMapStringA(dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, dwArg18);
		goto l004035CE;
	}
	if (eax_102 == 0x01)
	{
		if (dwArg1C == 0x00)
			&dwArg1C.u1->dw0000 = g_t4056EC.u1;
		Eq_9 eax_138 = MultiByteToWideChar(dwArg1C, (0x00 - (dwArg20 != 0x00) & 0x08) + 0x01, dwArg0C, dwArg10, 0x00, 0x00);
		if (eax_138 == 0x00)
			goto l004035CC;
		ui32 eax_146 = eax_138 * 0x02 + 0x03;
		fn00403B40(SEQ(SLICE(eax_146, word24, 8), (byte) eax_146 & 252), 0x00);
		Eq_9 esp_155 = <invalid>;
		if (esp_155 == 0x00)
			goto l004035CC;
		*((word32) esp_155 - 4) = eax_138;
		*((word32) esp_155 - 8) = esp_155;
		*((word32) esp_155 - 0x0C) = dwArg10;
		*((word32) esp_155 - 16) = dwArg0C;
		((word32) esp_155 - 20)->u0 = 0x01;
		*((word32) esp_155 - 24) = dwArg1C;
		if (MultiByteToWideChar(*((word32) esp_155 - 24), *((word32) esp_155 - 20), *((word32) esp_155 - 16), *((word32) esp_155 - 0x0C), *((word32) esp_155 - 8), *((word32) esp_155 - 4)) != 0x00)
		{
			((word32) esp_155 - 4)->u0 = 0x00;
			((word32) esp_155 - 8)->u0 = 0x00;
			*((word32) esp_155 - 0x0C) = eax_138;
			*((word32) esp_155 - 16) = esp_155;
			*((word32) esp_155 - 20) = dwArg08;
			*((word32) esp_155 - 24) = dwArg04;
			Eq_9 eax_208 = LCMapStringW(*((word32) esp_155 - 24), *((word32) esp_155 - 20), *((word32) esp_155 - 16), *((word32) esp_155 - 0x0C), *((word32) esp_155 - 8), *((word32) esp_155 - 4));
			if (eax_208 == 0x00)
				goto l004035CC;
			if ((bArg09_441 & 0x04) != 0x00)
			{
				if (dwArg18 != 0x00)
				{
					if (eax_208 > dwArg18)
						goto l004035CC;
					*((word32) esp_155 - 4) = dwArg18;
					*((word32) esp_155 - 8) = dwArg14;
					*((word32) esp_155 - 0x0C) = eax_138;
					*((word32) esp_155 - 16) = esp_155;
					*((word32) esp_155 - 20) = dwArg08;
					*((word32) esp_155 - 24) = dwArg04;
					if (LCMapStringW(*((word32) esp_155 - 24), *((word32) esp_155 - 20), *((word32) esp_155 - 16), *((word32) esp_155 - 0x0C), *((word32) esp_155 - 8), *((word32) esp_155 - 4)) == 0x00)
						goto l004035CC;
				}
			}
			else
			{
				ui32 eax_220 = eax_208 * 0x02 + 0x03;
				fn00403B40(SEQ(SLICE(eax_220, word24, 8), (byte) eax_220 & 252), *((word32) esp_155 - 4));
				Eq_9 esp_229 = <invalid>;
				if (esp_229 == 0x00)
					goto l004035CC;
				*((word32) esp_229 - 4) = eax_208;
				*((word32) esp_229 - 8) = esp_229;
				*((word32) esp_229 - 0x0C) = eax_138;
				*((word32) esp_229 - 16) = esp_155;
				*((word32) esp_229 - 20) = dwArg08;
				*((word32) esp_229 - 24) = dwArg04;
				if (LCMapStringW(*((word32) esp_229 - 24), *((word32) esp_229 - 20), *((word32) esp_229 - 16), *((word32) esp_229 - 0x0C), *((word32) esp_229 - 8), *((word32) esp_229 - 4)) == 0x00)
					goto l004035CC;
				((word32) esp_229 - 4)->u0 = 0x00;
				((word32) esp_229 - 8)->u0 = 0x00;
				if (dwArg18 == 0x00)
				{
					((word32) esp_229 - 0x0C)->u0 = 0x00;
					((word32) esp_229 - 16)->u0 = 0x00;
				}
				else
				{
					*((word32) esp_229 - 0x0C) = dwArg18;
					*((word32) esp_229 - 16) = dwArg14;
				}
				*((word32) esp_229 - 20) = eax_208;
				*((word32) esp_229 - 24) = esp_229;
				((word32) esp_229 - 28)->u0 = 0x0220;
				*((word32) esp_229 - 32) = dwArg1C;
				if (WideCharToMultiByte(*((word32) esp_229 - 32), *((word32) esp_229 - 28), *((word32) esp_229 - 24), *((word32) esp_229 - 20), *((word32) esp_229 - 16), *((word32) esp_229 - 0x0C), *((word32) esp_229 - 8), *((word32) esp_229 - 4)) == 0x00)
					goto l004035CC;
			}
l004035CE:
			fs->ptr0000 = eax_15;
			return;
		}
	}
l004035CC:
	goto l004035CE;
}

// 00403662: Register Eq_9 fn00403662(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08)
// Called from:
//      fn0040343E
Eq_9 fn00403662(Eq_9 dwArg04, Eq_9 dwArg08)
{
	Eq_9 eax_15 = dwArg04;
	word32 ecx_13 = dwArg08 - 1;
	if (dwArg08 != 0x00)
	{
		while (*eax_15.u2 != 0x00)
		{
			&eax_15.u1->dw0000 = &eax_15.u1->b0001;
			ecx_13 = ecx_72 - 0x01;
			ecx_72 = ecx_13;
			if (ecx_72 == 0x00)
				break;
		}
	}
	if (*eax_15.u2 != 0x00)
		return dwArg08;
	return eax_15 - dwArg04;
}

// 0040368D: void fn0040368D(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08, Stack Eq_9 dwArg0C, Stack Eq_2291 dwArg10, Stack Eq_9 dwArg14, Stack Eq_9 dwArg18, Stack word32 dwArg1C)
// Called from:
//      fn00402369
void fn0040368D(Eq_9 dwArg04, Eq_9 dwArg08, Eq_9 dwArg0C, Eq_2291 dwArg10, Eq_9 dwArg14, Eq_9 dwArg18, word32 dwArg1C)
{
	ptr32 fp;
	struct Eq_5155 * fs;
	Eq_2247 tLoc20;
	ptr32 eax_15 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	word32 eax_30 = g_dw4056F8;
	if (eax_30 == 0x00)
	{
		if (GetStringTypeW(0x01, 0x0040442C, 0x01, &tLoc20) != 0x00)
			eax_30 = 0x01;
		else
		{
			if (GetStringTypeA(0x00, 0x01, 0x00404428, 0x01, &tLoc20) == 0x00)
				goto l004037C2;
			eax_30 = 0x02;
		}
		g_dw4056F8 = eax_30;
	}
	if (eax_30 == 0x02)
	{
		Eq_9 eax_200 = dwArg18;
		if (dwArg18 == 0x00)
			&eax_200.u1->dw0000 = g_t4056DC.u1;
		GetStringTypeA(eax_200, dwArg04, dwArg08, dwArg0C, dwArg10);
l004037C4:
		fs->ptr0000 = eax_15;
		return;
	}
	if (eax_30 == 0x01)
	{
		if (dwArg14 == 0x00)
			&dwArg14.u1->dw0000 = g_t4056EC.u1;
		Eq_2291 eax_117 = MultiByteToWideChar(dwArg14, (0x00 - (dwArg1C != 0x00) & 0x08) + 0x01, dwArg08, dwArg0C, 0x00, 0x00);
		if (eax_117 != 0x00)
		{
			ui32 eax_125 = eax_117 * 0x02 + 0x03;
			fn00403B40(SEQ(SLICE(eax_125, word24, 8), (byte) eax_125 & 252), 0x00);
			Eq_9 esp_134 = <invalid>;
			&((word32) esp_134 - 4)->u1->dw0000 = eax_117 * 0x02;
			((word32) esp_134 - 8)->u0 = 0x00;
			*((word32) esp_134 - 0x0C) = esp_134;
			fn00403B70(*((word32) esp_134 - 0x0C), *((word32) esp_134 - 8), *((word32) esp_134 - 4));
			if (esp_134 != 0x00)
			{
				&((word32) esp_134 - 4)->u1->dw0000 = eax_117;
				*((word32) esp_134 - 8) = esp_134;
				*((word32) esp_134 - 0x0C) = dwArg0C;
				*((word32) esp_134 - 16) = dwArg08;
				((word32) esp_134 - 20)->u0 = 0x01;
				*((word32) esp_134 - 24) = dwArg14;
				Eq_9 eax_180 = MultiByteToWideChar(*((word32) esp_134 - 24), *((word32) esp_134 - 20), *((word32) esp_134 - 16), *((word32) esp_134 - 0x0C), *((word32) esp_134 - 8), *((word32) esp_134 - 4));
				if (eax_180 != 0x00)
				{
					&((word32) esp_134 - 4)->u1->dw0000 = dwArg10;
					*((word32) esp_134 - 8) = eax_180;
					*((word32) esp_134 - 0x0C) = esp_134;
					*((word32) esp_134 - 16) = dwArg04;
					GetStringTypeW(*((word32) esp_134 - 16), *((word32) esp_134 - 0x0C), *((word32) esp_134 - 8), *((word32) esp_134 - 4));
					goto l004037C4;
				}
			}
		}
	}
l004037C2:
	goto l004037C4;
}

// 004037D6: Register word32 fn004037D6(Stack Eq_714 dwArg04)
// Called from:
//      fn00402642
word32 fn004037D6(Eq_714 dwArg04)
{
	<anonymous> * eax_5 = g_ptr405700;
	if (eax_5 == null)
		return 0x00;
	word32 eax_14;
	eax_5();
	if (eax_14 == 0x00)
		return 0x00;
	return 0x01;
}

// 00403800: Register ptr32 fn00403800(Stack Eq_9 dwArg04, Stack Eq_9 dwArg08, Stack uint32 dwArg0C, Register out Eq_9 esiOut)
// Called from:
//      fn00402ACE
ptr32 fn00403800(Eq_9 dwArg04, Eq_9 dwArg08, uint32 dwArg0C, union Eq_9 & esiOut)
{
	ptr32 fp;
	ptr32 ebp;
	Eq_9 esi;
	Eq_9 esi_14 = dwArg08;
	Eq_9 eax_19 = dwArg08.u1 + dwArg0C / 4;
	if (dwArg04 <= dwArg08 || dwArg04 >= eax_19)
	{
		if ((dwArg04 & 0x03) != 0x00)
		{
			if (dwArg0C < 0x04)
			{
				switch (dwArg0C)
				{
				case 0x00:
					esiOut = esi;
					return ebp;
				case 0x01:
					*dwArg04.u2 = *dwArg08.u2;
					esiOut = esi;
					return ebp;
				case 0x02:
					*dwArg04.u2 = *dwArg08.u2;
					dwArg04.u1->b0001 = dwArg08.u1->b0001;
					esiOut = esi;
					return ebp;
				case 0x03:
					*dwArg04.u2 = *dwArg08.u2;
					dwArg04.u1->b0001 = dwArg08.u1->b0001;
					dwArg04.u1->b0002 = dwArg08.u1->b0002;
					esiOut = esi;
					return ebp;
				}
			}
			else
			{
				(*((char *) g_a403860 + (dwArg04 & 0x03) * 0x04))();
				esiOut = dwArg08;
				return fp - 4;
			}
		}
		else if (dwArg0C >> 0x02 < 0x08)
		{
			switch (dwArg0C >> 0x02)
			{
			case 0x00:
				goto l0040393F;
			case 0x01:
				goto l0040392C;
			case 0x02:
				goto l00403924;
			case 0x03:
				goto l0040391C;
			case 0x04:
				goto l00403914;
			case 0x05:
				goto l0040390C;
			case 0x06:
				break;
			case 0x07:
				(dwArg04 - 28)[dwArg0C >> 0x02] = (dwArg08 - 28)[dwArg0C >> 0x02];
				break;
			}
			(dwArg04 - 24)[dwArg0C >> 0x02] = (dwArg08 - 24)[dwArg0C >> 0x02];
l0040390C:
			(dwArg04 - 20)[dwArg0C >> 0x02] = (dwArg08 - 20)[dwArg0C >> 0x02];
l00403914:
			(dwArg04 - 16)[dwArg0C >> 0x02] = (dwArg08 - 16)[dwArg0C >> 0x02];
l0040391C:
			(dwArg04 - 0x0C)[dwArg0C >> 0x02] = (dwArg08 - 0x0C)[dwArg0C >> 0x02];
l00403924:
			(dwArg04 - 8)[dwArg0C >> 0x02] = (dwArg08 - 8)[dwArg0C >> 0x02];
l0040392C:
			(dwArg04 - 4)[dwArg0C >> 0x02] = (dwArg08 - 4)[dwArg0C >> 0x02];
			&esi_14.u1->dw0000 = dwArg08.u1 + (dwArg0C >> 0x02);
l0040393F:
			(*((char *) g_a403948 + (dwArg0C & 0x03) * 0x04))();
			esiOut = esi_14;
			return fp - 4;
		}
		else
		{
			Eq_5411 size_282 = (dwArg0C >> 0x02) * 0x04;
			memcpy(dwArg04, dwArg08, size_282);
			(*((char *) g_a403948 + (dwArg0C & 0x03) * 0x04))();
			esiOut = dwArg08 + size_282;
			return fp - 4;
		}
	}
	else
	{
		Eq_9 esi_102 = dwArg08.u1 + (dwArg0C - 4) / 4;
		struct Eq_5396 * edi_105 = dwArg04.u1 + (dwArg0C - 4) / 4;
		if ((edi_105 & 0x03) == 0x00)
		{
			uint32 ecx_130 = dwArg0C >> 0x02;
			if (dwArg0C >> 0x02 < 0x08)
			{
				switch (dwArg0C >> 0x02)
				{
				case 0x00:
					(*((char *) g_a403AE0 + (dwArg0C & 0x03) * 0x04))();
					esiOut = esi_102;
					return fp - 4;
				}
			}
			for (; ecx_130 != 0x00; --ecx_130)
			{
				edi_105->dw0000 = esi_102.u1->dw0000;
				esi_102 -= 4;
				edi_105 -= 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
				goto l00403AF8;
			case 0x02:
				goto l00403B08;
			case 0x03:
				goto l00403B1C;
			}
		}
		else
		{
			if (dwArg0C >= 0x04)
			{
				(*((char *) g_a4039E8 + (edi_105 & 0x03) * 0x04))();
				esiOut = esi_102;
				return fp - 4;
			}
			switch (dwArg0C)
			{
			case 0x00:
				break;
			case 0x01:
l00403AF8:
				edi_105->b0003 = esi_102.u1->b0003;
				esiOut = esi;
				return ebp;
			case 0x02:
l00403B08:
				edi_105->b0003 = esi_102.u1->b0003;
				edi_105->b0002 = esi_102.u1->b0002;
				esiOut = esi;
				return ebp;
			case 0x03:
l00403B1C:
				edi_105->b0003 = esi_102.u1->b0003;
				edi_105->b0002 = esi_102.u1->b0002;
				edi_105->b0001 = esi_102.u1->b0001;
				esiOut = esi;
				return ebp;
			}
		}
		esiOut = esi;
		return ebp;
	}
}

<anonymous> * g_a403860[] = // 00403860
	{
	};
<anonymous> * g_a403948[] = // 00403948
	{
	};
<anonymous> * g_a4039E8[] = // 004039E8
	{
	};
<anonymous> * g_a403AE0[] = // 00403AE0
	{
	};
// 00403B40: void fn00403B40(Register uint32 eax, Stack Eq_9 dwArg00)
// Called from:
//      fn0040343E
//      fn0040368D
void fn00403B40(uint32 eax, Eq_9 dwArg00)
{
	ptr32 fp;
	ptr32 ecx_11 = fp + 4;
	for (; eax >= 0x1000; eax -= 0x1000)
		ecx_11 -= 0x1000;
	(ecx_11 - eax)->tFFFFFFFC.u1 = (DWORD) dwArg00;
}

// 00403B70: void fn00403B70(Stack Eq_9 dwArg04, Stack Eq_9 bArg08, Stack Eq_2291 dwArg0C)
// Called from:
//      fn0040368D
void fn00403B70(Eq_9 dwArg04, Eq_9 bArg08, Eq_2291 dwArg0C)
{
	Eq_2291 edx_26 = dwArg0C;
	if (dwArg0C == 0x00)
		return;
	Eq_9 al_13 = bArg08;
	Eq_9 edi_17 = dwArg04;
	uint32 eax_36 = (uint32) bArg08;
	if (dwArg0C >= 0x04)
	{
		ui32 ecx_20 = -dwArg04;
		ui32 ecx_21 = ecx_20 & 0x03;
		if ((ecx_20 & 0x03) != 0x00)
		{
			edx_26 = dwArg0C - (ecx_20 & 0x03);
			do
			{
				*edi_17.u2 = (byte) bArg08;
				&edi_17.u1->dw0000 = &edi_17.u1->b0001;
				--ecx_21;
				eax_36 = (uint32) bArg08;
			} while (ecx_21 != 0x00);
		}
		ui32 eax_43 = eax_36 * 0x0101;
		al_13 = (byte) eax_43;
		edx_26 &= 0x03;
		uint32 ecx_51 = edx_26 >> 0x02;
		if (ecx_51 != 0x00)
		{
			while (true)
			{
				al_13 = (byte) eax_43;
				if (ecx_51 == 0x00)
					break;
				edi_17.u1->dw0000 = (word32) (eax_43 * 0x00010001);
				&edi_17.u1->dw0000 = (word32) edi_17 + 4;
				--ecx_51;
			}
			if (edx_26 == 0x00)
				return;
		}
	}
	do
	{
		*edi_17.u2 = (byte) al_13;
		&edi_17.u1->dw0000 = &edi_17.u1->b0001;
		--edx_26;
	} while (edx_26 != 0x00);
}

