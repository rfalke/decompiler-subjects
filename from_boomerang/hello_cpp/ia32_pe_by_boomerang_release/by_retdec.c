//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _M128A {
    int32_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    int32_t e21;
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    int32_t e28;
    int32_t e29;
    int32_t e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    int32_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    int32_t e43;
    int32_t e44;
    int32_t e45;
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct _cpinfo {
    int32_t e0;
    char e1[1];
    char e2[1];
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagMSG {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct tagPOINT e5;
};

struct tagRECT {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct tagPAINTSTRUCT {
    int32_t * e0;
    bool e1;
    struct tagRECT e2;
    bool e3;
    bool e4;
    char e5[32];
};

struct tagWNDCLASSEXA {
    int32_t e0;
    int32_t e1;
    int32_t (*e2)(int32_t *, int32_t, int32_t, int32_t);
    int32_t e3;
    int32_t e4;
    int32_t * e5;
    int32_t * e6;
    int32_t * e7;
    int32_t * e8;
    char * e9;
    char * e10;
    int32_t * e11;
};

// ------------------- Function Prototypes --------------------

int32_t __callnewh(int32_t a1);
int32_t __FF_MSGBANNER(void);
int32_t __heap_alloc(uint32_t a1);
int32_t __NMSG_WRITE(int32_t a1);
void _RtlUnwind_40_16(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue);
int32_t entry_point(int32_t a1);
int32_t function_287afb7(void);
int32_t function_287c087(void);
int32_t function_401000(int32_t a1);
int32_t function_4010c0(int32_t hInstance);
int32_t function_401150(int32_t hInstance, int32_t a2);
int32_t function_4011b0(int32_t lParam);
int32_t function_401310(int32_t hDlg, int32_t a2, int32_t a3);
int32_t function_40146b(int32_t a1);
int32_t function_40148e(void);
int32_t function_40148f(void);
int32_t function_4014bc(int32_t a1);
int32_t function_4014cd(int32_t a1);
int32_t function_4014de(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401577(int32_t * a1, int32_t * a2);
int32_t function_401591(int32_t a1, int32_t ExceptionInfo);
int32_t function_4016d2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401715(void);
int32_t function_40176d(void);
int32_t function_401826(void);
int32_t function_4018bf(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5);
int32_t function_401a73(void);
int32_t function_401ba5(int32_t a1);
int32_t function_401d50(int32_t a1);
int32_t function_401e59(void);
int32_t function_401e7c(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4020e8(int32_t a1);
int32_t function_4020f9(int32_t a1, int32_t a2, int32_t a3);
int32_t function_40212a(int32_t a1);
int32_t function_4022c3(int32_t result, int32_t a2, int32_t a3, int32_t a4);
int32_t function_40230d(int32_t a1);
int32_t function_402340(void);
int32_t function_402369(void);
int32_t function_4024ee(void);
int32_t function_40250a(int32_t lpMem);
int32_t function_402540(int32_t a1);
int32_t function_402550(int32_t * a1, int32_t a2);
int32_t function_4025b1(int32_t a1, int32_t result, int32_t a3);
int32_t function_4026b0(int32_t a1);
int32_t function_402730(int32_t result5, uint32_t a2, uint32_t a3);
int32_t function_402a65(void);
int32_t function_402aa3(int32_t a1, int32_t a2);
int32_t function_402ace(int32_t a1, int32_t a2);
int32_t function_402df9(int32_t a1, int32_t a2);
int32_t function_403102(int32_t a1);
int32_t function_4031b3(int32_t a1);
int32_t function_4032ae(int32_t * a1, char * a2, int32_t a3);
int32_t function_403340(int32_t result, char * a2, int32_t a3);
int32_t function_40343e(int32_t a1, int32_t a2, char * a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t function_403662(int32_t a1, int32_t result);
int32_t function_40368d(int32_t a1, char * a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_403800(int32_t result5, uint32_t a2, uint32_t a3);
int32_t function_403b40(int32_t result);
int32_t function_403b70(int32_t result, int32_t a2, int32_t a3);

// --------------------- Global Variables ---------------------

char * g1; // 0x404428
int16_t * g2 = NULL; // 0x40442c
int32_t g3 = 0; // 0x405000
int32_t g4 = 0; // 0x405004
int32_t g5 = 0; // 0x405008
int32_t g6 = 0; // 0x405010
int32_t g7 = 0; // 0x405014
int32_t g8 = 0; // 0x405018
int32_t g9 = 0; // 0x40501c
int32_t g10 = 0; // 0x405020
int32_t g11 = 2; // 0x405034
int32_t g12 = -0x3ffffffb; // 0x405038
int32_t g13 = 0; // 0x405040
int32_t g14 = 3; // 0x4050b0
int32_t g15 = 7; // 0x4050b4
int32_t g16 = 10; // 0x4050b8
int32_t g17 = 140; // 0x4050bc
int32_t g18 = 2; // 0x4050e0
char (*g19)[37] = "R6002\r\n- floating point not loaded\r\n"; // 0x4050e4
char * g20 = "\x01\x02\x04\b"; // 0x405170
int32_t g21 = 932; // 0x405178
int32_t g22 = -0x7d867da0; // 0x40517c
char * g23 = "\xa6\xdf"; // 0x405188
bool g24 = false; // 0x405268
int32_t g25 = 1016; // 0x405270
int16_t * g26 = (int16_t *)0x200020; // 0x40528a
char * g27; // 0x405490
char * g28; // 0x4054f4
int32_t g29 = 0; // 0x405558
char * g30; // 0x40555c
int32_t g31 = 0; // 0x405564
uint32_t g32 = 0; // 0x405574
int32_t g33 = 0; // 0x405578
int32_t g34 = 0; // 0x40557c
int32_t g35 = 0; // 0x405580
int32_t g36 = 0; // 0x405584
int32_t g37 = 0; // 0x405588
int32_t g38 = 0; // 0x405590
char * g39; // 0x4055a0
int32_t g40 = 0; // 0x4055a8
int32_t g41 = 0; // 0x4055ac
int32_t g42 = 0; // 0x4055b0
int32_t g43 = 0; // 0x4055b4
char * g44; // 0x4055b8
int32_t g45 = 0; // 0x4056bc
int32_t g46 = 0; // 0x4056c4
int32_t g47 = 0; // 0x4056c8
int32_t g48 = 0; // 0x4056cc
int32_t g49 = 0; // 0x4056d0
int32_t g50 = 0; // 0x4056dc
int32_t g51 = 0; // 0x4056ec
int32_t g52 = 0; // 0x4056f4
int32_t g53 = 0; // 0x4056f8
int32_t g54 = 0; // 0x405700
int32_t g55 = 0; // 0x405704
int32_t g56 = 0; // 0x405708
int32_t g57 = 0; // 0x40570c
int32_t g58 = 0; // 0x405710
int32_t g59 = 0; // 0x405714
int32_t g60 = 0; // 0x405718
int32_t g61 = 0; // 0x40571c
int32_t g62 = 0; // 0x405720
int32_t g63 = 0; // 0x40572c
char * g64; // 0x405740
char * g65; // 0x405840
char * g66; // 0x405841
int32_t g67 = 0; // 0x405944
int32_t g68 = 0; // 0x405948
int32_t g69 = 0; // 0x405960
int32_t g70 = 0; // 0x405964
int32_t g71 = 0; // 0x405a60
int32_t g72 = 0; // 0x405a64
int32_t g73 = 0; // 0x405a68
int32_t g74 = 0; // 0x405a6c
int32_t g75 = 0; // 0x405a70
char * g76; // 0x405a78
int32_t g77;
int32_t g78;
int32_t g79;
int32_t g80;
int32_t g81;
int32_t g82;
int32_t g83;
int32_t g84;
int32_t g85;
int32_t g86;
int32_t g87;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x4010b9
int32_t function_401000(int32_t a1) {
    int32_t * hInstance = (int32_t *)a1; // 0x401019
    LoadStringA(hInstance, 103, (char *)&g28, 100);
    int32_t lpMsg = a1; // bp-68, 0x401024
    LoadStringA(hInstance, 109, (char *)&g27, 100);
    function_4010c0(a1);
    int32_t v1; // 0x401000
    int32_t result = function_401150(a1, v1); // 0x401033
    if (result == 0) {
        // 0x40103f
        return result;
    }
    int32_t * v2 = LoadAcceleratorsA(hInstance, (char *)109); // 0x40104a
    struct tagMSG * v3 = (struct tagMSG *)&lpMsg; // bp-92, 0x401060
    if (!GetMessageA((struct tagMSG *)&lpMsg, NULL, 0, 0)) {
        // 0x4010ad
        return *(int32_t *)((int32_t)&v3 + 16);
    }
    // 0x401069
    int32_t v4; // bp-100, 0x401000
    int32_t v5 = &v4;
    int32_t v6 = v5 + 16; // 0x401077
    *(int32_t *)(v5 - 4) = v6;
    *(int32_t *)(v5 - 8) = (int32_t)v2;
    int32_t v7 = v5 - 12; // 0x401081
    *(int32_t *)v7 = *(int32_t *)v6;
    int32_t v8 = TranslateAcceleratorA(&g80, &g80, (struct tagMSG *)&g80); // 0x401082
    int32_t v9 = v7; // 0x401086
    if (v8 == 0) {
        // 0x401088
        *(int32_t *)(v5 - 16) = v5 + 4;
        TranslateMessage((struct tagMSG *)&g80);
        v9 = v5 - 20;
        *(int32_t *)v9 = v5;
        DispatchMessageA((struct tagMSG *)&g80);
    }
    // 0x40109a
    *(int32_t *)(v9 - 4) = 0;
    int32_t v10 = v9 - 8; // 0x40109c
    *(int32_t *)v10 = 0;
    *(int32_t *)(v9 - 12) = 0;
    int32_t v11 = v9 - 16; // 0x4010a4
    *(int32_t *)v11 = v9 + 16;
    bool v12 = GetMessageA((struct tagMSG *)&g80, &g80, (int32_t)&g80, (int32_t)&g80); // 0x4010a5
    while (v12) {
        // 0x401077
        v5 = v11;
        v6 = v5 + 16;
        *(int32_t *)(v5 - 4) = v6;
        *(int32_t *)(v5 - 8) = (int32_t)v2;
        v7 = v5 - 12;
        *(int32_t *)v7 = *(int32_t *)v6;
        v8 = TranslateAcceleratorA(&g80, &g80, (struct tagMSG *)&g80);
        v9 = v7;
        if (v8 == 0) {
            // 0x401088
            *(int32_t *)(v5 - 16) = v5 + 4;
            TranslateMessage((struct tagMSG *)&g80);
            v9 = v5 - 20;
            *(int32_t *)v9 = v5;
            DispatchMessageA((struct tagMSG *)&g80);
        }
        // 0x40109a
        *(int32_t *)(v9 - 4) = 0;
        v10 = v9 - 8;
        *(int32_t *)v10 = 0;
        *(int32_t *)(v9 - 12) = 0;
        v11 = v9 - 16;
        *(int32_t *)v11 = v9 + 16;
        v12 = GetMessageA((struct tagMSG *)&g80, &g80, (int32_t)&g80, (int32_t)&g80);
    }
    // 0x4010ad
    return *(int32_t *)(v10 + 16);
}

// Address range: 0x4010c0 - 0x401149
int32_t function_4010c0(int32_t hInstance) {
    // 0x4010c0
    LoadIconA((int32_t *)hInstance, (char *)107);
    LoadCursorA(NULL, (char *)0x7f00);
    char * lpwcx = (char *)108; // bp-72, 0x401118
    LoadIconA((int32_t *)3, (char *)108);
    return RegisterClassExA((struct tagWNDCLASSEXA *)&lpwcx);
}

// Address range: 0x401150 - 0x4011a8
int32_t function_401150(int32_t hInstance, int32_t a2) {
    // 0x401150
    g29 = hInstance;
    int32_t * windowHandle = CreateWindowExA(0, (char *)&g27, (char *)&g28, 0xcf0000, -0x80000000, 0, -0x80000000, 0, NULL, NULL, (int32_t *)hInstance, NULL); // 0x401180
    if (windowHandle == NULL) {
        // 0x40118c
        return (int32_t)windowHandle;
    }
    // 0x40118e
    ShowWindow(windowHandle, 0xcf0000);
    UpdateWindow(windowHandle);
    return 1;
}

// Address range: 0x4011b0 - 0x401305
int32_t function_4011b0(int32_t lParam) {
    // 0x4011b0
    int32_t lpBuffer; // bp-100, 0x4011b0
    LoadStringA((int32_t *)g29, 106, (char *)&lpBuffer, 100);
    int32_t v1; // 0x4011b0
    int32_t lpchText; // bp-132, 0x4011b0
    int32_t (*lpRect)(int32_t *, int32_t, int32_t, int32_t); // bp-204, 0x4011b0
    int32_t lpPaint2; // bp-216, 0x4011b0
    int32_t * hWnd; // 0x4012a2
    int32_t * hdc; // 0x4012a2
    int32_t hWndParent; // 0x4011b0
    switch (hWndParent) {
        case 2: {
            // 0x4012f2
            PostQuitMessage(0);
            return 0;
        }
        case 15: {
            // 0x401292
            lpRect = (int32_t (*)(int32_t *, int32_t, int32_t, int32_t))hWndParent;
            hWnd = (int32_t *)hWndParent;
            int32_t lpPaint; // bp-180, 0x4011b0
            hdc = BeginPaint(hWnd, (struct tagPAINTSTRUCT *)&lpPaint);
            GetClientRect(hWnd, (struct tagRECT *)&lpRect);
            int32_t v2; // bp-1, 0x4011b0
            int32_t v3 = &v2; // 0x4012c6
            int32_t v4 = &lpchText; // 0x4012c6
            v1 = 0;
            while (v3 != 0) {
                int32_t v5 = v4;
                v3--;
                bool v6; // 0x4011b0
                v4 = v5 + (v6 ? -1 : 1);
                v1 = v3;
                if (*(char *)v5 == 0) {
                    // break -> 
                    break;
                }
                v1 = 0;
            }
            // break -> 
            break;
        }
        case 273: {
            int32_t v7; // 0x4011b0
            switch ((int16_t)v7) {
                case 104: {
                    // 0x40126a
                    lpRect = (int32_t (*)(int32_t *, int32_t, int32_t, int32_t))0x401310;
                    lpPaint2 = g29;
                    DialogBoxParamA((int32_t *)g29, (char *)103, (int32_t *)hWndParent, (int32_t (*)(int32_t *, int32_t, int32_t, int32_t))0x401310, 0);
                    return 0;
                }
                case 105: {
                    // 0x401251
                    DestroyWindow((int32_t *)hWndParent);
                    return 0;
                }
            }
            // 0x40122c
            lpRect = (int32_t (*)(int32_t *, int32_t, int32_t, int32_t))hWndParent;
            return DefWindowProcA((int32_t *)hWndParent, 273, hWndParent, lParam);
        }
        default: {
            // 0x4011ee
            lpRect = (int32_t (*)(int32_t *, int32_t, int32_t, int32_t))hWndParent;
            return DefWindowProcA((int32_t *)hWndParent, hWndParent, hWndParent, lParam);
        }
    }
    DrawTextA(hdc, (char *)&lpchText, -2 - v1, (struct tagRECT *)&g80, (int32_t)&g80);
    EndPaint(hWnd, (struct tagPAINTSTRUCT *)&lpPaint2);
    return 0;
}

// Address range: 0x401310 - 0x40134c
int32_t function_401310(int32_t hDlg, int32_t a2, int32_t a3) {
    int32_t v1 = a2 - 272; // 0x401314
    if (v1 == 0) {
        // 0x40132e
        return 1;
    }
    // 0x40131b
    if (v1 != 1) {
        // 0x40132e
        return 0;
    }
    int32_t result = 0; // 0x401310
    if ((int16_t)a3 < 3) {
        // 0x401333
        EndDialog((int32_t *)hDlg, a3 & 0xffff);
        result = 1;
    }
    // 0x40132e
    return result;
}

// Address range: 0x401350 - 0x40143b
int32_t entry_point(int32_t a1) {
    // 0x401350
    int32_t v1; // 0x401350
    int32_t v2 = v1;
    int32_t v3 = __readfsdword(0); // bp-20, 0x401365
    __writefsdword(0, (int32_t)&v3);
    uint32_t v4 = GetVersion(); // 0x401376
    int32_t v5 = v4 / 256 & 255; // 0x40137e
    g35 = v5;
    int32_t v6 = v4 & 255; // 0x401388
    g34 = v6;
    g33 = 256 * v6 | v5;
    g32 = v4 / 0x10000;
    if (function_401d50(0) == 0) {
        // 0x4013b4
        function_40146b(28);
        // UNREACHABLE
    }
    // 0x4013bc
    function_401ba5(0);
    g76 = GetCommandLineA();
    g30 = (char *)function_401a73();
    function_401826();
    function_40176d();
    function_40148f();
    int32_t lpStartupInfo; // bp-96, 0x401350
    GetStartupInfoA((struct _STARTUPINFOA *)&lpStartupInfo);
    function_401715();
    int32_t * moduleHandle = GetModuleHandleA(NULL); // 0x401412
    function_4014bc(function_401000((int32_t)moduleHandle));
    return function_401591(*(int32_t *)*(int32_t *)v2, v2);
}

// Address range: 0x40146b - 0x40148e
int32_t function_40146b(int32_t a1) {
    // 0x40146b
    if (g31 == 1) {
        // 0x401474
        __FF_MSGBANNER();
    }
    // 0x401479
    __NMSG_WRITE(a1);
    ExitProcess(255);
    // UNREACHABLE
}

// Address range: 0x40148e - 0x40148f
int32_t function_40148e(void) {
    // 0x40148e
    int32_t result; // 0x40148e
    return result;
}

// Address range: 0x40148f - 0x4014bc
int32_t function_40148f(void) {
    // 0x40148f
    function_401577(&g5, &g6);
    return function_401577(&g3, &g4);
}

// Address range: 0x4014bc - 0x4014cd
int32_t function_4014bc(int32_t a1) {
    // 0x4014bc
    return function_4014de(a1, 0, 0);
}

// Address range: 0x4014cd - 0x4014de
int32_t function_4014cd(int32_t a1) {
    // 0x4014cd
    return function_4014de(a1, 1, 0);
}

// Address range: 0x4014de - 0x401577
int32_t function_4014de(int32_t a1, int32_t a2, int32_t a3) {
    // 0x4014de
    int32_t v1; // bp-4, 0x4014de
    int32_t * v2 = &v1; // 0x4014e8
    if (g42 == 1) {
        int32_t * processHandle = GetCurrentProcess(); // 0x4014ee
        int32_t v3 = (int32_t)processHandle; // bp-12, 0x4014f4
        TerminateProcess(processHandle, (int32_t)&g80);
        v2 = &v3;
    }
    int32_t v4 = (int32_t)v2;
    int32_t v5 = *(int32_t *)(v4 + 16); // 0x401501
    g41 = 1;
    *(char *)&g40 = (char)v5;
    int32_t * v6; // 0x4014de
    int32_t * v7; // 0x4014de
    if (*(int32_t *)(v4 + 12) != 0) {
        // 0x4014fb
        v7 = (int32_t *)(v4 - 12);
        v6 = (int32_t *)(v4 - 8);
    } else {
        // 0x401513
        int32_t * v8; // 0x4014de
        if (g75 == 0) {
            // 0x401513
            v8 = (int32_t *)(v4 - 8);
        } else {
            int32_t * v9 = (int32_t *)(v4 - 8);
            int32_t v10 = g74 - 4; // 0x401523
            v8 = v9;
            if (v10 >= g75) {
                int32_t v11 = v10; // 0x401532
                v11 -= 4;
                v8 = v9;
                while (v11 >= g75) {
                    // 0x40152a
                    v11 -= 4;
                    v8 = v9;
                }
            }
        }
        // 0x40153e
        *v8 = (int32_t)&g8;
        int32_t * v12 = (int32_t *)(v4 - 12);
        *v12 = (int32_t)&g7;
        function_401577(&g80, &g80);
        v7 = v12;
        v6 = v8;
    }
    // 0x40154f
    *v6 = (int32_t)&g10;
    *v7 = (int32_t)&g9;
    int32_t result = function_401577(&g80, &g80); // 0x401559
    if (v5 != 0) {
        // 0x401575
        return result;
    }
    // 0x401565
    *(int32_t *)(v4 - 4) = *(int32_t *)(v4 + 8);
    g42 = 1;
    ExitProcess((int32_t)&g80);
    // UNREACHABLE
}

// Address range: 0x401577 - 0x401591
int32_t function_401577(int32_t * a1, int32_t * a2) {
    if (a1 >= a2) {
        // 0x40158f
        int32_t result; // 0x401577
        return result;
    }
    int32_t v1 = (int32_t)a1;
    int32_t v2 = v1 + 4; // 0x40158a
    while (v2 < (uint32_t)(int32_t)a2) {
        // 0x401582
        v1 = v2;
        v2 = v1 + 4;
    }
    // 0x40158f
    return *(int32_t *)v1;
}

// Address range: 0x401591 - 0x4016d2
int32_t function_401591(int32_t a1, int32_t ExceptionInfo) {
    // 0x401591
    int32_t v1; // 0x401591
    int32_t v2 = function_4016d2(a1, v1, v1); // 0x401598
    if (v2 == 0) {
        // 0x4016cf
        return UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo);
    }
    int32_t * v3 = (int32_t *)(v2 + 8); // 0x4015a6
    int32_t v4 = *v3; // 0x4015a6
    if (v4 == 0) {
        // 0x4016cf
        return UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)ExceptionInfo);
    }
    if (v4 == 5) {
        // 0x4015b6
        *v3 = 0;
        // 0x4016cf
        return 1;
    }
    // 0x4015c2
    if (v4 == 1) {
        // 0x4016cf
        return -1;
    }
    int32_t v5 = g43; // 0x4015cb
    g43 = ExceptionInfo;
    if (*(int32_t *)(v2 + 4) != 8) {
        // 0x4016b1
        *v3 = 0;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    int32_t v6 = g14; // 0x4015e9
    if (g15 + v6 > v6) {
        int32_t v7 = g15; // 0x401601
        int32_t v8 = 12 * v6 + (int32_t)&g13; // 0x401601
        *(int32_t *)v8 = 0;
        v7--;
        v8 += 12;
        while (v7 != 0) {
            // 0x401608
            *(int32_t *)v8 = 0;
            v7--;
            v8 += 12;
        }
    }
    int32_t v9 = *(int32_t *)v2; // 0x401611
    int32_t v10 = g17; // 0x401613
    if (v9 == -0x3fffff72) {
        // 0x401620
        g17 = 131;
        // 0x40169c
        g17 = v10;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    if (v9 == -0x3fffff70) {
        // 0x401633
        g17 = 129;
        // 0x40169c
        g17 = v10;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    if (v9 == -0x3fffff6f) {
        // 0x401646
        g17 = 132;
        // 0x40169c
        g17 = v10;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    if (v9 == -0x3fffff6d) {
        // 0x401659
        g17 = 133;
        // 0x40169c
        g17 = v10;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    if (v9 == -0x3fffff73) {
        // 0x40166c
        g17 = 130;
        // 0x40169c
        g17 = v10;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    if (v9 == -0x3fffff71) {
        // 0x40167f
        g17 = 134;
        // 0x40169c
        g17 = v10;
        // 0x4016b9
        g43 = v5;
        // 0x4016cf
        return -1;
    }
    if (v9 == -0x3fffff6e) {
        // 0x401692
        g17 = 138;
    }
    // 0x40169c
    g17 = v10;
    // 0x4016b9
    g43 = v5;
    // 0x4016cf
    return -1;
}

// Address range: 0x4016d2 - 0x401715
int32_t function_4016d2(int32_t a1, int32_t a2, int32_t a3) {
    uint32_t v1 = 12 * g16 + (int32_t)&g12;
    int32_t v2 = &g12; // 0x4016e8
    int32_t result = &g12; // 0x4016e8
    if (g12 != a1) {
        v2 += 12;
        result = v2;
        while (v2 < v1) {
            // 0x4016fb
            result = v2;
            if (*(int32_t *)v2 == a1) {
                // break -> 0x4016ff
                break;
            }
            v2 += 12;
            result = v2;
        }
    }
    // 0x4016ff
    if (result < v1) {
        // 0x40170e
        if (*(int32_t *)result == a1) {
            // 0x401714
            return result;
        }
    }
    // 0x401714
    return 0;
}

// Address range: 0x401715 - 0x40176d
int32_t function_401715(void) {
    // 0x401715
    if (g73 == 0) {
        // 0x40171e
        function_4024ee();
    }
    int32_t v1 = (int32_t)g76; // 0x401724
    unsigned char v2 = *g76; // 0x40172a
    int32_t v3; // 0x401715
    if (v2 != 34) {
        // 0x401755
        v3 = v1;
        if (v2 >= 33) {
            int32_t v4 = v1 + 1; // 0x401759
            int32_t v5 = v4; // 0x40175d
            v3 = v4;
            while (*(char *)v4 >= 33) {
                // 0x401759
                v4 = v5 + 1;
                v5 = v4;
                v3 = v4;
            }
        }
        goto lab_0x40175f;
    } else {
        int32_t v6 = v1; // 0x401715
        unsigned char v7; // 0x401730
        int32_t v8; // 0x401730
        while (true) {
          lab_0x401730:
            // 0x401730
            v8 = v6 + 1;
            v7 = *(char *)v8;
            switch (v7) {
                case 34: {
                    goto lab_0x40174d;
                }
                case 0: {
                    goto lab_0x40174d;
                }
                default: {
                    // 0x40173c
                    int32_t v9; // bp-4, 0x401715
                    *(int32_t *)((int32_t)&v9 - 4) = (int32_t)v7;
                    v6 += 2;
                    goto lab_0x401730;
                }
            }
        }
      lab_0x40174d:
        // 0x40174d
        v3 = v8;
        if (v7 != 34) {
            goto lab_0x40175f;
        } else {
            // 0x401752
            v3 = v8 + 1;
            goto lab_0x40175f;
        }
    }
  lab_0x40175f:;
    int32_t result = v3;
    if (*(char *)result >= 33) {
        // 0x401769
        return result;
    }
    // 0x401752
    v3 = result + 1;
    goto lab_0x40175f;
}

// Address range: 0x40176d - 0x401826
int32_t function_40176d(void) {
    // 0x40176d
    if (g73 == 0) {
        // 0x40177a
        function_4024ee();
    }
    // 0x40177f
    int32_t v1; // bp-12, 0x40176d
    int32_t v2 = &v1; // 0x401777
    int32_t * v3 = (int32_t *)(v2 - 4);
    int32_t v4 = (int32_t)g30; // 0x401785
    int32_t v5 = 0; // 0x401785
    int32_t v6; // 0x40176d
    while (true) {
      lab_0x401787:
        // 0x401787
        v6 = v5;
        v5 = v6;
        int32_t v7; // 0x40176d
        switch (*(char *)v7) {
            case 0: {
                goto lab_0x40179f;
            }
            case 61: {
                goto lab_0x401792;
            }
            default: {
                // 0x401791
                v5 = v6 + 1;
                goto lab_0x401792;
            }
        }
    }
  lab_0x40179f:
    // 0x40179f
    *v3 = 4 * v6 + 4;
    int32_t * v8 = _malloc((int32_t)&g80); // 0x4017a7
    int32_t v9 = (int32_t)v8; // 0x4017a7
    g38 = v9;
    if (v8 == NULL) {
        // 0x4017b9
        *v3 = 9;
        __amsg_exit();
    }
    char * v10 = g30; // 0x4017c1
    char * v11 = v10; // 0x4017c9
    int32_t * v12 = v8; // 0x4017c9
    if (*v10 != 0) {
        int32_t * v13 = (int32_t *)(v2 - 8); // 0x4017cc
        int32_t v14 = (int32_t)v10;
        *v13 = v14;
        int32_t v15 = function_4026b0((int32_t)&g80) + 1; // 0x4017d5
        int32_t v16 = v9; // 0x4017d9
        int32_t * v17; // 0x4017dc
        int32_t * v18; // 0x4017e4
        if (*(char *)v14 != 61) {
            // 0x4017db
            *v13 = v15;
            v17 = _malloc((int32_t)&g80);
            v18 = (int32_t *)v9;
            *v18 = (int32_t)v17;
            if (v17 == NULL) {
                // 0x4017e8
                *v13 = 9;
                __amsg_exit();
            }
            // 0x4017f0
            *v13 = v14;
            *(int32_t *)(v2 - 12) = *v18;
            function_402540((int32_t)&g80);
            v16 = v9 + 4;
        }
        int32_t v19 = v16;
        int32_t v20 = v15 + v14; // 0x4017fd
        while (*(char *)v20 != 0) {
            // 0x4017cc
            v14 = v20;
            int32_t v21 = v19;
            *v13 = v14;
            v15 = function_4026b0((int32_t)&g80) + 1;
            v16 = v21;
            if (*(char *)v14 != 61) {
                // 0x4017db
                *v13 = v15;
                v17 = _malloc((int32_t)&g80);
                v18 = (int32_t *)v21;
                *v18 = (int32_t)v17;
                if (v17 == NULL) {
                    // 0x4017e8
                    *v13 = 9;
                    __amsg_exit();
                }
                // 0x4017f0
                *v13 = v14;
                *(int32_t *)(v2 - 12) = *v18;
                function_402540((int32_t)&g80);
                v16 = v21 + 4;
            }
            // 0x4017fd
            v19 = v16;
            v20 = v15 + v14;
        }
        // 0x401803
        v11 = g30;
        v12 = (int32_t *)v19;
    }
    // 0x401804
    *v3 = (int32_t)v11;
    int32_t result = function_40250a((int32_t)&g80); // 0x40180a
    g30 = NULL;
    *v12 = 0;
    g72 = 1;
    return result;
  lab_0x401792:
    // 0x401792
    *v3 = v4;
    v4 = v4 + 1 + function_4026b0((int32_t)&g80);
    goto lab_0x401787;
}

// Address range: 0x401826 - 0x4018bf
int32_t function_401826(void) {
    // 0x401826
    if (g73 == 0) {
        // 0x401838
        function_4024ee();
    }
    // 0x40183d
    GetModuleFileNameA(NULL, (char *)&g44, 260);
    char * v1 = g76; // 0x40184f
    g39 = (char *)&g44;
    int32_t v2 = *v1 == 0 ? (int32_t)&g44 : (int32_t)v1;
    int32_t v3; // bp-12, 0x401826
    int32_t v4; // bp-8, 0x401826
    function_4018bf(v2, 0, 0, &v4, &v3);
    int32_t * v5 = _malloc(4 * v4 + v3); // 0x40187c
    if (v5 == NULL) {
        // 0x40188a
        __amsg_exit();
    }
    int32_t v6 = (int32_t)v5; // 0x40187c
    function_4018bf(v2, v6, 4 * v4 + v6, &v4, &v3);
    int32_t result = v4 - 1; // 0x4018ae
    g37 = v6;
    g36 = result;
    return result;
}

// Address range: 0x4018bf - 0x401a73
int32_t function_4018bf(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t * a5) {
    // 0x4018bf
    *a5 = 0;
    *a4 = 1;
    int32_t v1 = 0; // 0x4018df
    if (a2 != 0) {
        // 0x4018e1
        *(int32_t *)a2 = a3;
        v1 = a2 + 4;
    }
    int32_t v2 = a1; // 0x4018ec
    int32_t v3 = a3; // 0x4018ec
    int32_t v4 = a1; // 0x4018ec
    int32_t v5 = a3; // 0x4018ec
    int32_t v6; // 0x4018bf
    int32_t v7; // 0x4018bf
    int32_t v8; // 0x4018bf
    int32_t v9; // 0x4018bf
    int32_t v10; // 0x4018bf
    int32_t v11; // 0x4018bf
    if (*(char *)a1 != 34) {
        while (true) {
          lab_0x401932:;
            int32_t v12 = v5;
            int32_t v13 = v4;
            *a5 = *a5 + 1;
            char * v14 = (char *)v13;
            int32_t v15 = 0; // 0x401936
            if (v12 != 0) {
                // 0x401938
                *(char *)v12 = *v14;
                v15 = v12 + 1;
            }
            int32_t v16 = v15;
            unsigned char v17 = *v14; // 0x40193d
            int32_t v18 = v13 + 1; // 0x40193f
            int32_t v19 = v18; // 0x40194a
            int32_t v20 = v16; // 0x40194a
            if ((*(char *)((int32_t)v17 + (int32_t)&g66) & 4) != 0) {
                // 0x40194c
                *a5 = *a5 + 1;
                int32_t v21 = 0; // 0x401950
                if (v16 != 0) {
                    // 0x401952
                    *(char *)v16 = *(char *)v18;
                    v21 = v16 + 1;
                }
                // 0x401957
                v19 = v13 + 2;
                v20 = v21;
            }
            // 0x401958
            v5 = v20;
            v4 = v19;
            switch (v17) {
                case 32: {
                    goto lab_0x40196d;
                }
                case 0: {
                    // 0x40196a
                    v8 = v4 - 1;
                    v11 = v5;
                    goto lab_0x401975;
                }
                default: {
                    // 0x401961
                    if (v17 == 9) {
                        // break -> 0x40196d
                        break;
                    }
                    goto lab_0x401932;
                }
            }
        }
      lab_0x40196d:
        // 0x40196d
        v8 = v4;
        v11 = 0;
        if (v5 != 0) {
            // 0x401971
            *(char *)(v5 - 1) = 0;
            v8 = v4;
            v11 = v5;
        }
    } else {
        int32_t v22; // 0x4018bf
        int32_t v23; // 0x4018bf
        int32_t v24; // 0x4018ee
        char * v25; // 0x4018bf
        while (true) {
          lab_0x4018ee_2:
            // 0x4018ee
            v23 = v3;
            v22 = v2;
            v24 = v22 + 1;
            v25 = (char *)v24;
            unsigned char v26 = *v25; // 0x4018ee
            switch (v26) {
                case 34: {
                    goto lab_0x401920;
                }
                case 0: {
                    goto lab_0x401920;
                }
                default: {
                    char v27 = *(char *)((int32_t)v26 + (int32_t)&g66); // 0x4018fe
                    v7 = v24;
                    v10 = v23;
                    if ((v27 & 4) == 0) {
                        goto lab_0x401913;
                    } else {
                        int32_t v28 = *a5; // 0x401907
                        *a5 = v28 + 1;
                        if (v23 == 0) {
                            // 0x401913
                            *a5 = v28 + 2;
                            v6 = v24;
                            v9 = 0;
                            goto lab_0x4018ee;
                        } else {
                            // 0x40190d
                            *(char *)v23 = *v25;
                            v7 = v22 + 2;
                            v10 = v23 + 1;
                            goto lab_0x401913;
                        }
                    }
                }
            }
        }
      lab_0x401920:
        // 0x401920
        *a5 = *a5 + 1;
        int32_t v29 = 0; // 0x401924
        if (v23 != 0) {
            // 0x401926
            *(char *)v23 = 0;
            v29 = v23 + 1;
        }
        // 0x40192a
        v8 = *v25 != 34 ? v24 : v22 + 2;
        v11 = v29;
    }
    goto lab_0x401975;
  lab_0x4019ee:;
    // 0x4019ee
    int32_t v67; // 0x4018bf
    int32_t v79 = v67;
    int32_t v65; // 0x4018bf
    int32_t v80 = v65;
    int32_t v64; // 0x4018bf
    int32_t v82 = v64;
    int32_t v63; // 0x4018bf
    int32_t v81 = v63;
    int32_t v66; // 0x4018bf
    int32_t v83 = v66; // 0x4019f3
    int32_t v50; // 0x4018bf
    int32_t v84 = v50; // 0x4019f3
    int32_t v85 = v50; // 0x4019f3
    if (v66 != 0) {
        int32_t v86 = v84;
        int32_t v87 = 0; // 0x4019f8
        if (v86 != 0) {
            // 0x4019fa
            *(char *)v86 = 92;
            v87 = v86 + 1;
        }
        // 0x4019fe
        *a5 = *a5 + 1;
        int32_t v88 = v83 - 1; // 0x401a00
        v83 = v88;
        v85 = v87;
        while (v88 != 0) {
            // 0x4019f6
            v86 = v87;
            v87 = 0;
            if (v86 != 0) {
                // 0x4019fa
                *(char *)v86 = 92;
                v87 = v86 + 1;
            }
            // 0x4019fe
            *a5 = *a5 + 1;
            v88 = v83 - 1;
            v83 = v88;
            v85 = v87;
        }
    }
    int32_t v76 = v85;
    char * v78 = (char *)v80;
    unsigned char v89 = *v78; // 0x401a03
    if (v89 == 0) {
        // break -> 0x401a53
        goto lab_0x401a53_2;
    }
    if (v81 != 0) {
        goto lab_0x401a19;
    } else {
        switch (v89) {
            case 32: {
                goto lab_0x401a53_2;
            }
            case 9: {
                goto lab_0x401a53_2;
            }
            default: {
                goto lab_0x401a19;
            }
        }
    }
  lab_0x401a19:;
    int32_t v90 = v80; // 0x401a1d
    int32_t v91 = v76; // 0x401a1d
    if (v82 != 0) {
        char v92 = *(char *)((int32_t)v89 + (int32_t)&g66);
        int32_t v93; // 0x4018bf
        int32_t v94; // 0x4018bf
        if (v76 == 0) {
            // 0x401a3c
            v93 = v80;
            v94 = 0;
            if ((v92 & 4) != 0) {
                // 0x401a48
                *a5 = *a5 + 1;
                v93 = v80 + 1;
                v94 = 0;
            }
        } else {
            char v95 = v89; // 0x401a2d
            int32_t v96 = v80; // 0x401a2d
            int32_t v97 = v76; // 0x401a2d
            if ((v92 & 4) != 0) {
                // 0x401a2f
                *(char *)v76 = v89;
                v96 = v80 + 1;
                *a5 = *a5 + 1;
                v95 = *(char *)v96;
                v97 = v76 + 1;
            }
            // 0x401a35
            *(char *)v97 = v95;
            v93 = v96;
            v94 = v97 + 1;
        }
        // 0x401a4b
        *a5 = *a5 + 1;
        v90 = v93;
        v91 = v94;
    }
    int32_t v45 = v81; // 0x401a4e
    int32_t v46 = v90 + 1; // 0x401a4e
    int32_t v47 = v91; // 0x401a4e
    int32_t v48 = v79; // 0x401a4e
    goto lab_0x4019ab;
  lab_0x4019ec:;
    // 0x4019ec
    int32_t v68; // 0x4018bf
    v63 = v68;
    int32_t v69; // 0x4018bf
    v64 = v69;
    int32_t v70; // 0x4018bf
    v65 = v70;
    int32_t v61; // 0x4018bf
    v66 = v61 / 2;
    int32_t v71; // 0x4018bf
    v67 = v71;
    goto lab_0x4019ee;
  lab_0x4019de:;
    // 0x4019de
    int32_t v51; // 0x4018bf
    v68 = v51 == 0;
    int32_t v72; // 0x4018bf
    v69 = v72;
    int32_t v73; // 0x4018bf
    v70 = v73;
    int32_t v44; // 0x4018bf
    v71 = v44;
    goto lab_0x4019ec;
  lab_0x401913:;
    int32_t v98 = v10;
    int32_t v99 = v7;
    *a5 = *a5 + 1;
    v6 = v99;
    v9 = 0;
    if (v98 != 0) {
        // 0x401919
        *(char *)v98 = *(char *)v99;
        v6 = v99;
        v9 = v98 + 1;
    }
    goto lab_0x4018ee;
  lab_0x4018ee:
    // 0x4018ee
    v2 = v6;
    v3 = v9;
    goto lab_0x4018ee_2;
  lab_0x401975:;
    char v30 = *(char *)v8; // 0x401979
    char v31 = v30; // 0x40197c
    int32_t v32 = v1; // 0x40197c
    int32_t v33 = v11; // 0x40197c
    int32_t v34 = v8; // 0x40197c
    int32_t v35 = 0; // 0x40197c
    int32_t v36 = v1; // 0x40197c
    if (v30 != 0) {
        while (true) {
            int32_t v37 = v33;
            int32_t v38 = v32;
            char v39 = v31; // 0x401982
            int32_t v40 = v34; // 0x401987
            if (v39 != 32 != v39 != 9) {
                int32_t v41 = v40 + 1; // 0x40198e
                char v42 = *(char *)v41; // 0x401982
                v40 = v41;
                while (v42 != 32 != v42 != 9) {
                    // 0x40198e
                    v41 = v40 + 1;
                    v42 = *(char *)v41;
                    v40 = v41;
                }
                // 0x401991
                v36 = v38;
                if (v42 == 0) {
                    // break -> 0x401a62
                    break;
                }
            }
            int32_t v43 = 0; // 0x40199c
            if (v38 != 0) {
                // 0x40199e
                *(int32_t *)v38 = v37;
                v43 = v38 + 4;
            }
            // 0x4019a6
            v44 = v43;
            *a4 = *a4 + 1;
            v45 = v35;
            v46 = v34;
            v47 = v37;
            v48 = v43;
            while (true) {
              lab_0x4019ab:;
                int32_t v49 = v48;
                v50 = v47;
                v51 = v45;
                char v52 = *(char *)v46; // 0x4019b4
                int32_t v53 = v46; // 0x4019b7
                int32_t v54 = v46; // 0x4019b7
                int32_t v55 = 0; // 0x4019b7
                char v56 = v52; // 0x4019b7
                if (v52 == 92) {
                    v54 = v53 + 1;
                    v55 = 1;
                    v56 = *(char *)v54;
                    while (v56 == 92) {
                        // 0x4019b9
                        v54 = v53 + 1;
                        int32_t v57; // 0x4018bf
                        v55 = v57 + 1;
                        v56 = *(char *)v54;
                        v57 = v55;
                        v53 = v54;
                        int32_t v58 = v54; // 0x4019b7
                        int32_t v59 = v55; // 0x4019b7
                        char v60 = v56; // 0x4019b7
                    }
                }
                // 0x4019bd
                v61 = v55;
                int32_t v62 = v54;
                v63 = v51;
                v64 = 1;
                v65 = v62;
                v66 = v61;
                v67 = v49;
                if (v56 != 34) {
                    goto lab_0x4019ee;
                } else {
                    // 0x4019c2
                    v68 = v51;
                    v69 = 1;
                    v70 = v62;
                    v71 = v49;
                    if ((v61 & 1) != 0) {
                        goto lab_0x4019ec;
                    } else {
                        if (v51 == 0) {
                            // 0x4019db
                            v72 = 0;
                            v73 = v62;
                            goto lab_0x4019de;
                        } else {
                            int32_t v74 = v62 + 1; // 0x4019ce
                            v72 = 1;
                            v73 = v74;
                            if (*(char *)v74 != 34) {
                                // 0x4019db
                                v72 = 0;
                                v73 = v62;
                                goto lab_0x4019de;
                            } else {
                                goto lab_0x4019de;
                            }
                        }
                    }
                }
            }
          lab_0x401a53_2:;
            int32_t v75 = 0; // 0x401a55
            if (v76 != 0) {
                // 0x401a57
                *(char *)v76 = 0;
                v75 = v76 + 1;
            }
            // 0x401a5b
            *a5 = *a5 + 1;
            char v77 = *v78; // 0x401979
            v31 = v77;
            v32 = v79;
            v33 = v75;
            v34 = v80;
            v35 = v81;
            v36 = v79;
            if (v77 == 0) {
                // break -> 0x401a62
                break;
            }
        }
    }
    // 0x401a62
    if (v36 != 0) {
        // 0x401a66
        *(int32_t *)v36 = 0;
    }
    // 0x401a69
    *a4 = *a4 + 1;
    return (int32_t)a4;
}

// Address range: 0x401a73 - 0x401ba5
int32_t function_401a73(void) {
    int32_t v1 = g45; // 0x401a75
    char * lpszEnvironmentBlock; // 0x401a73
    int16_t * lpWideCharStr; // 0x401a73
    if (v1 != 0) {
        if (v1 != 1) {
            // 0x401b4b
            if (v1 != 2) {
                // 0x401b9e
                return 0;
            }
            char * v2 = GetEnvironmentStrings(); // 0x401b54
            lpszEnvironmentBlock = v2;
            if (v2 == NULL) {
                // 0x401b9e
                return 0;
            }
            goto lab_0x401b60;
        } else {
            int16_t * v3 = GetEnvironmentStringsW(); // 0x401ace
            lpWideCharStr = v3;
            if (v3 == NULL) {
                // 0x401b9e
                return 0;
            }
            goto lab_0x401ada;
        }
    } else {
        int16_t * v4 = GetEnvironmentStringsW(); // 0x401a8e
        if (v4 == NULL) {
            char * v5 = GetEnvironmentStrings(); // 0x401aa2
            if (v5 == NULL) {
                // 0x401b9e
                return 0;
            }
            // 0x401b50
            g45 = 2;
            lpszEnvironmentBlock = v5;
            goto lab_0x401b60;
        } else {
            // 0x401aca
            g45 = 1;
            lpWideCharStr = v4;
            goto lab_0x401ada;
        }
    }
  lab_0x401b60:;
    int32_t v6 = (int32_t)lpszEnvironmentBlock;
    int32_t v7 = v6; // 0x401b64
    int32_t v8 = v6; // 0x401b64
    if (*lpszEnvironmentBlock != 0) {
        while (true) {
            int32_t v9 = v7;
            int32_t v10 = v9 + 1; // 0x401b66
            int32_t v11 = v10; // 0x401b69
            if (*(char *)v10 == 0) {
                // 0x401b6b
                v11 = v9 + 2;
                v8 = v11;
                if (*(char *)v11 == 0) {
                    // break -> 0x401b70
                    break;
                }
            }
            // 0x401b66
            v7 = v11;
        }
    }
    int32_t v12 = v8 - v6 + 1; // 0x401b72
    int32_t * v13 = _malloc(v12); // 0x401b76
    int32_t result = 0; // 0x401b80
    if (v13 != NULL) {
        int32_t v14 = (int32_t)v13; // 0x401b76
        function_402730(v14, v6, v12);
        result = v14;
    }
    // 0x401b91
    FreeEnvironmentStringsA(lpszEnvironmentBlock);
    // 0x401b9e
    return result;
  lab_0x401ada:;
    int32_t v15 = (int32_t)lpWideCharStr;
    int32_t v16 = v15; // 0x401adf
    int32_t v17 = v15; // 0x401adf
    if (*lpWideCharStr != 0) {
        while (true) {
            int32_t v18 = v16;
            int32_t v19 = v18 + 2; // 0x401ae2
            int32_t v20 = v19; // 0x401ae6
            if (*(int16_t *)v19 == 0) {
                // 0x401ae8
                v20 = v18 + 4;
                v17 = v20;
                if (*(int16_t *)v20 == 0) {
                    // break -> 0x401aef
                    break;
                }
            }
            // 0x401ae1
            v16 = v20;
        }
    }
    int32_t v21 = 0; // bp-56, 0x401b01
    int32_t v22 = &v21; // 0x401b01
    int32_t cbMultiByte = WideCharToMultiByte(0, 0, lpWideCharStr, (v17 - v15) / 2 + 1, NULL, 0, NULL, NULL); // 0x401b06
    int32_t result2 = 0; // 0x401b0c
    int32_t v23 = v22; // 0x401b0c
    if (cbMultiByte != 0) {
        int32_t * lpMultiByteStr = _malloc(cbMultiByte); // 0x401b0f
        result2 = 0;
        v23 = v22;
        if (lpMultiByteStr != NULL) {
            int32_t v24 = 0; // bp-88, 0x401b27
            int32_t v25 = WideCharToMultiByte(0, 0, lpWideCharStr, 0, (char *)lpMultiByteStr, cbMultiByte, NULL, NULL); // 0x401b28
            char * v26 = (char *)lpMultiByteStr; // 0x401b2c
            if (v25 == 0) {
                // 0x401b2e
                function_40250a((int32_t)lpMultiByteStr);
                v26 = NULL;
            }
            // 0x401b3c
            result2 = (int32_t)v26;
            v23 = &v24;
        }
    }
    // 0x401b40
    *(int32_t *)(v23 - 4) = v15;
    FreeEnvironmentStringsW((int16_t *)&g80);
    // 0x401b9e
    return result2;
}

// Address range: 0x401ba5 - 0x401d50
int32_t function_401ba5(int32_t a1) {
    struct _STARTUPINFOA * v1 = (struct _STARTUPINFOA *)256; // bp-88, 0x401bac
    int32_t * v2 = _malloc(256); // 0x401bb1
    if (v2 == NULL) {
        // 0x401bbd
        v1 = (struct _STARTUPINFOA *)27;
        __amsg_exit();
    }
    int32_t v3 = (int32_t)v2; // 0x401bb1
    g69 = v3;
    g71 = 32;
    int32_t v4 = v3; // 0x401bdd
    if (v2 < (int32_t *)-256) {
        *(char *)(v4 + 4) = 0;
        *(int32_t *)v4 = -1;
        *(char *)(v4 + 5) = 10;
        v4 += 8;
        while (v4 < g69 + 256) {
            // 0x401bdf
            *(char *)(v4 + 4) = 0;
            *(int32_t *)v4 = -1;
            *(char *)(v4 + 5) = 10;
            v4 += 8;
        }
    }
    // 0x401bf9
    int32_t lpStartupInfo; // bp-68, 0x401ba5
    v1 = (struct _STARTUPINFOA *)&lpStartupInfo;
    int32_t v5 = (int32_t)&v1; // 0x401bfd
    GetStartupInfoA((struct _STARTUPINFOA *)&lpStartupInfo);
    int32_t v6 = v5; // 0x401c0a
    int32_t v7; // 0x401ba5
    int32_t v8; // 0x401ba5
    int32_t v9; // 0x401ba5
    int32_t v10; // 0x401ba5
    int32_t v11; // 0x401ba5
    uint32_t v12; // 0x401ba5
    int32_t v13; // 0x401ba5
    int32_t v14; // 0x401ba5
    int32_t v15; // 0x401ba5
    int32_t v16; // 0x401ba5
    int32_t v17; // 0x401ba5
    char * v18; // 0x401c96
    int16_t v19; // 0x401ba5
    if (v17 != 0 && v19 != 0) {
        int32_t v20 = *(int32_t *)v17; // 0x401c1c
        int32_t v21 = v20 < 2048 ? v20 : 2048;
        v13 = v21;
        if (g71 < v21) {
            int32_t v22 = &g70; // 0x401ba5
            *(int32_t *)(v5 - 4) = 256;
            int32_t * v23 = _malloc((int32_t)&g80); // 0x401c41
            v13 = g71;
            while (v23 != NULL) {
                int32_t v24 = (int32_t)v23; // 0x401c41
                g71 += 32;
                int32_t * v25 = (int32_t *)v22; // 0x401c52
                *v25 = v24;
                int32_t v26 = v24; // 0x401c5c
                if (v23 < (int32_t *)-256) {
                    *(char *)(v26 + 4) = 0;
                    *(int32_t *)v26 = -1;
                    *(char *)(v26 + 5) = 10;
                    int32_t v27 = v26 + 8; // 0x401c6b
                    v26 = v27;
                    while (v27 < *v25 + 256) {
                        // 0x401c5e
                        *(char *)(v26 + 4) = 0;
                        *(int32_t *)v26 = -1;
                        *(char *)(v26 + 5) = 10;
                        v27 = v26 + 8;
                        v26 = v27;
                    }
                }
                // 0x401c76
                v22 += 4;
                v13 = v21;
                if (g71 >= v21) {
                    // break -> 0x401c89
                    break;
                }
                *(int32_t *)(v5 - 4) = 256;
                v23 = _malloc((int32_t)&g80);
                v13 = g71;
            }
        }
        int32_t v28 = v17 + 4; // 0x401c1e
        v10 = v20 + v28;
        v14 = v5;
        v8 = v28;
        v11 = 0;
        v6 = v5;
        if (v13 >= 1) {
            while (true) {
              lab_0x401c8f:
                // 0x401c8f
                v12 = v11;
                v9 = v8;
                int32_t v29 = v14;
                int32_t * v30 = (int32_t *)v10; // 0x401c8f
                int32_t v31 = *v30; // 0x401c8f
                v16 = v29;
                if (v31 == -1) {
                    goto lab_0x401ccc;
                } else {
                    // 0x401c96
                    v18 = (char *)v9;
                    char v32 = *v18; // 0x401c96
                    v16 = v29;
                    if ((v32 & 1) == 0) {
                        goto lab_0x401ccc;
                    } else {
                        // 0x401c9e
                        v7 = v31;
                        v15 = v29;
                        if ((v32 & 8) != 0) {
                            goto lab_0x401cae;
                        } else {
                            int32_t v33 = v29 - 4; // 0x401ca3
                            *(int32_t *)v33 = v31;
                            int32_t v34 = GetFileType(&g80); // 0x401ca4
                            v16 = v33;
                            if (v34 == 0) {
                                goto lab_0x401ccc;
                            } else {
                                // 0x401ca3
                                v7 = *v30;
                                v15 = v33;
                                goto lab_0x401cae;
                            }
                        }
                    }
                }
            }
        }
    }
  lab_0x401cd5:;
    int32_t v35 = 0; // 0x401cd5
    int32_t v36 = v6; // 0x401cd5
    int32_t v37; // 0x401ba5
    int32_t v38; // 0x401ba5
    int32_t v39; // 0x401ba5
    char * v40; // 0x401ce7
    while (true) {
      lab_0x401cd7:;
        int32_t v41 = v36;
        v37 = v35;
        int32_t v42 = g69 + 8 * v37; // 0x401cdc
        int32_t * v43 = (int32_t *)v42; // 0x401cdc
        if (*v43 != -1) {
            char * v44 = (char *)(v42 + 4); // 0x401d32
            *v44 = *v44 | -128;
            v39 = v41;
            goto lab_0x401d36;
        } else {
            // 0x401ce5
            v40 = (char *)(v42 + 4);
            *v40 = -127;
            int32_t * v45; // 0x401ba5
            int32_t v46; // 0x401ba5
            int32_t v47; // 0x401ba5
            if (v37 != 0) {
                int32_t v48 = v41 - 4; // 0x401cfc
                v45 = (int32_t *)v48;
                v46 = v48;
                v47 = (int32_t)(v37 != 1) - 11;
            } else {
                int32_t v49 = v41 - 4;
                int32_t * v50 = (int32_t *)v49;
                *v50 = -10;
                v45 = v50;
                v46 = v49;
                v47 = -10;
            }
            // 0x401cfc
            *v45 = v47;
            int32_t * v51 = GetStdHandle((int32_t)&g80); // 0x401cfd
            v38 = v46;
            if (v51 == (int32_t *)-1) {
                goto lab_0x401d21;
            } else {
                int32_t v52 = (int32_t)v51; // 0x401cfd
                int32_t v53 = v41 - 8; // 0x401d0a
                *(int32_t *)v53 = v52;
                int32_t v54 = GetFileType(&g80); // 0x401d0b
                v38 = v53;
                if (v54 == 0) {
                    goto lab_0x401d21;
                } else {
                    int32_t v55 = v54 & 255; // 0x401d15
                    *v43 = v52;
                    v38 = v53;
                    if (v55 != 2) {
                        // 0x401d27
                        v39 = v53;
                        if (v55 == 3) {
                            // 0x401d2c
                            *v40 = *v40 | 8;
                            v39 = v53;
                        }
                        goto lab_0x401d36;
                    } else {
                        goto lab_0x401d21;
                    }
                }
            }
        }
    }
  lab_0x401d3c:;
    // 0x401d3c
    int32_t v56; // 0x401ba5
    *(int32_t *)(v56 - 4) = g71;
    return SetHandleCount((int32_t)&g80);
  lab_0x401d36:
    // 0x401d36
    v56 = v39;
    int32_t v57 = v37 + 1; // 0x401d36
    v35 = v57;
    v36 = v56;
    if (v57 == 3) {
        // break -> 0x401d3c
        goto lab_0x401d3c;
    }
    goto lab_0x401cd7;
  lab_0x401d21:
    // 0x401d21
    *v40 = *v40 | 64;
    v39 = v38;
    goto lab_0x401d36;
  lab_0x401ccc:;
    int32_t v58 = v12 + 1; // 0x401ccc
    v10 += 4;
    v14 = v16;
    v8 = v9 + 1;
    v11 = v58;
    v6 = v16;
    if (v58 == v13) {
        // break -> 0x401cd5
        goto lab_0x401cd5;
    }
    goto lab_0x401c8f;
  lab_0x401cae:;
    int32_t v59 = *(int32_t *)(4 * v12 / 32 + (int32_t)&g69); // 0x401cb8
    int32_t v60 = v59 + (8 * v12 & 248); // 0x401cbf
    *(int32_t *)v60 = v7;
    *(char *)(v60 + 4) = *v18;
    v16 = v15;
    goto lab_0x401ccc;
}

// Address range: 0x401d50 - 0x401d8c
int32_t function_401d50(int32_t a1) {
    int32_t * v1 = HeapCreate((int32_t)(bool)(a1 == 0), 0x1000, 0); // 0x401d61
    g68 = (int32_t)v1;
    if (v1 == NULL) {
        // 0x401d85
        return 0;
    }
    int32_t result = 1; // 0x401d77
    if (function_402a65() == 0) {
        // 0x401d79
        HeapDestroy((int32_t *)g68);
        result = 0;
    }
    // 0x401d85
    return result;
}

// Address range: 0x401e59 - 0x401e62
int32_t function_401e59(void) {
    // 0x401e59
    int32_t result; // 0x401e59
    return result;
}

// Address range: 0x401e7c - 0x401f41
int32_t function_401e7c(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401e7c
    int32_t v1; // 0x401e7c
    int32_t v2 = v1;
    *(char *)v2 = (char)(v1 / 256 ^ v2 ^ v1);
    char * v3 = (char *)v1; // bp-4, 0x401e84
    int32_t v4 = (int32_t)&v3; // 0x401e85
    int32_t v5 = v4; // bp-28, 0x401e8d
    if ((*(int32_t *)(a1 + 4) & 6) != 0) {
        // 0x401f24
        __local_unwind2();
        // 0x401f39
        return 1;
    }
    int32_t v6 = a1; // bp-12, 0x401ea2
    int32_t v7 = &v6; // 0x401eab
    *(int32_t *)(a2 - 4) = v7;
    int32_t v8 = *(int32_t *)(a2 + 12); // 0x401eb1
    if (v8 == -1) {
        // 0x401f39
        return 1;
    }
    int32_t v9 = &v5;
    int32_t v10 = 12 * v8;
    int32_t v11 = v10; // 0x401ec4
    int32_t v12 = v7; // 0x401ec4
    int32_t v13 = a2; // 0x401ec4
    int32_t v14 = v9; // 0x401ec4
    int32_t v15 = v4; // 0x401ec4
    int32_t v16; // 0x401ec6
    int32_t * v17; // 0x401ec6
    int32_t * v18; // 0x401ec7
    int32_t v19; // 0x401ed0
    int32_t v20; // 0x401ed1
    int32_t v21; // 0x401e7c
    int32_t v22; // 0x401f01
    if (*(int32_t *)(*(int32_t *)(a2 + 8) + 4 + v10) != 0) {
        // 0x401ec6
        v16 = v9 - 4;
        v17 = (int32_t *)v16;
        *v17 = v8;
        v18 = (int32_t *)(v9 - 8);
        *v18 = v4;
        v19 = *v17;
        v20 = *(int32_t *)(v4 + 12);
        if (v7 == 0) {
            // 0x401ec6
            v11 = 12 * v19;
            v12 = 0;
            v13 = v20;
            v14 = v9;
            v15 = v4;
        } else {
            // 0x401ed8
            if (v7 < 0) {
                // break -> 0x401f39
                break;
            }
            // 0x401eda
            *v17 = v20;
            __global_unwind2();
            *v17 = v19;
            *v18 = v20;
            __local_unwind2();
            *v17 = 1;
            __NLG_Notify();
            v21 = 12 * v19;
            v22 = *(int32_t *)(*(int32_t *)(v20 + 8) + v21);
            *(int32_t *)(v20 + 12) = v22;
            v11 = v21;
            v12 = v22;
            v13 = v20;
            v14 = v16;
            v15 = v20 + 16;
        }
    }
    int32_t v23 = v13;
    int32_t v24 = *(int32_t *)(v23 + 8); // 0x401f0b
    int32_t v25 = *(int32_t *)(v24 + v11); // 0x401f11
    int32_t result = 1; // 0x401eba
    while (v25 != -1) {
        int32_t v26 = v25;
        v9 = v14;
        int32_t v27 = v15;
        int32_t v28 = v12;
        v10 = 12 * v26;
        v11 = v10;
        v12 = v28;
        v13 = v23;
        v14 = v9;
        v15 = v27;
        if (*(int32_t *)(v24 + 4 + v10) != 0) {
            // 0x401ec6
            v16 = v9 - 4;
            v17 = (int32_t *)v16;
            *v17 = v26;
            v18 = (int32_t *)(v9 - 8);
            *v18 = v27;
            v19 = *v17;
            v20 = *(int32_t *)(v27 + 12);
            if (v28 == 0) {
                // 0x401ec6
                v11 = 12 * v19;
                v12 = 0;
                v13 = v20;
                v14 = v9;
                v15 = v27;
            } else {
                // 0x401ed8
                result = 0;
                if (v28 < 0) {
                    // break -> 0x401f39
                    break;
                }
                // 0x401eda
                *v17 = v20;
                __global_unwind2();
                *v17 = v19;
                *v18 = v20;
                __local_unwind2();
                *v17 = 1;
                __NLG_Notify();
                v21 = 12 * v19;
                v22 = *(int32_t *)(*(int32_t *)(v20 + 8) + v21);
                *(int32_t *)(v20 + 12) = v22;
                v11 = v21;
                v12 = v22;
                v13 = v20;
                v14 = v16;
                v15 = v20 + 16;
            }
        }
        // 0x401f0b
        v23 = v13;
        v24 = *(int32_t *)(v23 + 8);
        v25 = *(int32_t *)(v24 + v11);
        result = 1;
    }
    // 0x401f39
    return result;
}

// Address range: 0x401f5c - 0x401f95
int32_t __FF_MSGBANNER(void) {
    // 0x401f5c
    if (g31 == 1) {
        // 0x401f73
        __NMSG_WRITE(252);
        // 0x401f94
        return __NMSG_WRITE(255);
    }
    // 0x401f66
    if (g31 != 0 || g11 != 1) {
        // 0x401f94
        return g31;
    }
    // 0x401f73
    __NMSG_WRITE(252);
    // 0x401f94
    return __NMSG_WRITE(255);
}

// Address range: 0x401f95 - 0x4020e8
int32_t __NMSG_WRITE(int32_t a1) {
    int32_t result = &g18; // 0x401fa3
    int32_t v1 = 0; // 0x401fa3
    while (*(int32_t *)result != a1) {
        // 0x401fac
        result += 8;
        v1++;
        if (result >= (int32_t)&g20) {
            // break -> 0x401fb7
            break;
        }
    }
    int32_t v2 = 8 * v1; // 0x401fba
    if (*(int32_t *)(v2 + (int32_t)&g18) != a1) {
        // 0x4020e5
        return result;
    }
    // 0x401fc9
    if (g31 != 1) {
        // 0x401fd7
        if (g31 == 0 != (g11 == 1)) {
            // 0x401fe8
            if (a1 == 252) {
                // 0x4020e5
                return g31;
            }
            // 0x401ff4
            int32_t lpFilename; // bp-424, 0x401f95
            int32_t nameSize = GetModuleFileNameA(NULL, (char *)&lpFilename, 260); // 0x402002
            int32_t v3 = &lpFilename;
            if (nameSize == 0) {
                // 0x40200c
                function_402540(v3);
            }
            int32_t v4 = function_4026b0(v3); // 0x40202d
            int32_t v5 = v3; // 0x402037
            if (v4 >= 60) {
                // 0x402039
                int32_t v6; // bp-483, 0x401f95
                v5 = function_4026b0(v3) + (int32_t)&v6;
                function_403340(v5, "...", 3);
            }
            // 0x402062
            int32_t v7; // bp-164, 0x401f95
            function_402540((int32_t)&v7);
            function_402550(&v7, v5);
            function_402550(&v7, (int32_t)"\n\n");
            function_402550(&v7, *(int32_t *)(v2 + (int32_t)&g19));
            // 0x4020e5
            return function_4032ae(&v7, "Microsoft Visual C++ Runtime Library", 0x12010);
        }
    }
    // 0x4020bf
    function_4026b0(*(int32_t *)(v2 + (int32_t)&g19));
    bool result2 = WriteFile(GetStdHandle(-12), &g80, (int32_t)&g80, &g80, (struct _OVERLAPPED *)&g80); // 0x4020df
    // 0x4020e5
    return result2;
}

// Address range: 0x4020e8 - 0x4020f9
int32_t function_4020e8(int32_t a1) {
    // 0x4020e8
    return function_4020f9(a1, 0, 4);
}

// Address range: 0x4020f9 - 0x40212a
int32_t function_4020f9(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = a1 & 255; // 0x4020f9
    char v2 = *(char *)(v1 + (int32_t)&g66); // 0x402102
    if ((v2 & (char)a3) != 0) {
        // 0x402125
        return 1;
    }
    // 0x40210a
    if (a2 == 0) {
        // 0x402125
        return 0;
    }
    uint16_t v3 = *(int16_t *)(2 * v1 + (int32_t)&g26); // 0x402111
    int32_t result = (int32_t)v3 & a2; // 0x402119
    if (result == 0) {
        // 0x402125
        return result;
    }
    // 0x402125
    return 1;
}

// Address range: 0x40212a - 0x4022c3
int32_t function_40212a(int32_t a1) {
    // 0x40212a
    int32_t v1; // 0x40212a
    int32_t CodePage = function_4022c3(a1, v1, v1, v1); // 0x402136
    if (CodePage == g61) {
        // 0x4022be
        return 0;
    }
    int32_t v2 = &g21; // 0x402151
    if (CodePage == 0) {
      lab_0x4022ad:
        // 0x4022ad
        function_402340();
        // 0x4022b2
        function_402369();
        // 0x4022be
        return 0;
    }
    int32_t v3 = 0;
    while (*(int32_t *)v2 != CodePage) {
        // 0x402162
        v2 += 48;
        if (v2 >= (int32_t)&g24) {
            // 0x40216d
            int32_t lpCPInfo; // bp-28, 0x40212a
            GetCPInfo(CodePage, (struct _cpinfo *)&lpCPInfo);
            if (g46 == 0) {
                return -1;
            } else {
                goto lab_0x4022ad;
            }
        }
        v3++;
    }
    // 0x4021d4
    __asm_rep_stosd_memset((char *)&g65, 0, 64);
    int32_t v4 = 48 * v3; // 0x4021e6
    bool v5; // 0x40212a
    char * v6 = v5 ? (char *)((int32_t)&g65 - 256) : (char *)((int32_t)&g65 + 256); // 0x4021e9
    *v6 = 0;
    int32_t v7 = v4 + (int32_t)&g23;
    int32_t v8 = 0;
    char v9 = *(char *)v7; // 0x4021f0
    unsigned char v10; // 0x4021fe
    int32_t v11; // 0x40212a
    int32_t v12; // 0x40212a
    int32_t v13; // 0x40212a
    char * v14; // 0x40212a
    unsigned char v15; // 0x4021f7
    int32_t v16; // 0x40221d
    char v17; // 0x40221e
    char * v18; // 0x402211
    if (v9 != 0) {
        // 0x4021f7
        v14 = (char *)(v8 + (int32_t)&g20);
        v17 = v9;
        v13 = v7;
        v15 = *(char *)(v13 + 1);
        while (v15 != 0) {
            // 0x4021fe
            v10 = v17;
            if (v15 >= v10) {
                // 0x402208
                v12 = v10;
                v18 = (char *)(v12 + (int32_t)&g66);
                *v18 = *v18 | *v14;
                v11 = v12 + 1;
                while (v12 != (int32_t)v15) {
                    // 0x402211
                    v12 = v11;
                    v18 = (char *)(v12 + (int32_t)&g66);
                    *v18 = *v18 | *v14;
                    v11 = v12 + 1;
                }
            }
            // 0x40221c
            v16 = v13 + 2;
            v17 = *(char *)v16;
            if (v17 == 0) {
                // break -> 0x402223
                break;
            }
            v13 = v16;
            v15 = *(char *)(v13 + 1);
        }
    }
    int32_t v19 = v8 + 1; // 0x402223
    int32_t v20 = v7 + 8; // 0x40222d
    while (v19 != 4) {
        // 0x4021f0
        v7 = v20;
        v8 = v19;
        v9 = *(char *)v7;
        if (v9 != 0) {
            // 0x4021f7
            v14 = (char *)(v8 + (int32_t)&g20);
            v17 = v9;
            v13 = v7;
            v15 = *(char *)(v13 + 1);
            while (v15 != 0) {
                // 0x4021fe
                v10 = v17;
                if (v15 >= v10) {
                    // 0x402208
                    v12 = v10;
                    v18 = (char *)(v12 + (int32_t)&g66);
                    *v18 = *v18 | *v14;
                    v11 = v12 + 1;
                    while (v12 != (int32_t)v15) {
                        // 0x402211
                        v12 = v11;
                        v18 = (char *)(v12 + (int32_t)&g66);
                        *v18 = *v18 | *v14;
                        v11 = v12 + 1;
                    }
                }
                // 0x40221c
                v16 = v13 + 2;
                v17 = *(char *)v16;
                if (v17 == 0) {
                    // break -> 0x402223
                    break;
                }
                v13 = v16;
                v15 = *(char *)(v13 + 1);
            }
        }
        // 0x402223
        v19 = v8 + 1;
        v20 = v7 + 8;
    }
    // 0x40222f
    g63 = 1;
    g61 = CodePage;
    int32_t v21 = function_40230d(CodePage); // 0x402242
    int32_t v22 = v4 + (int32_t)&g22; // 0x402247
    g62 = *(int32_t *)v22;
    int32_t v23 = v5 ? -4 : 4; // 0x402252
    int32_t v24 = v23 + (int32_t)&g62; // 0x402252
    int32_t v25 = v22 + v23; // 0x402252
    *(int32_t *)v24 = *(int32_t *)v25;
    g67 = v21;
    *(int32_t *)(v24 + v23) = *(int32_t *)(v25 + v23);
    // 0x4022b2
    function_402369();
    // 0x4022be
    return 0;
}

// Address range: 0x4022c3 - 0x4022c7
int32_t function_4022c3(int32_t result, int32_t a2, int32_t a3, int32_t a4) {
    // 0x4022c3
    return result;
}

// Address range: 0x40230d - 0x402340
int32_t function_40230d(int32_t a1) {
    int32_t result = 1041; // 0x40230d
    switch (a1) {
        case 936: {
            // 0x402325
            return 2052;
        }
        default: {
            int32_t v1 = a1 - 949; // 0x40231d
            result = 1042;
            if (v1 != 0) {
                // 0x402322
                result = v1 == 1 ? 1028 : 0;
            }
        }
        case 932: {
            // 0x402325
            return result;
        }
    }
}

// Address range: 0x402340 - 0x402369
int32_t function_402340(void) {
    // 0x402340
    __asm_rep_stosd_memset((char *)&g65, 0, 64);
    bool v1; // 0x402340
    char * v2 = v1 ? (char *)((int32_t)&g65 - 256) : (char *)((int32_t)&g65 + 256); // 0x40234d
    *v2 = 0;
    g61 = 0;
    g63 = 0;
    g67 = 0;
    g62 = 0;
    int32_t * v3 = v1 ? (int32_t *)((int32_t)&g62 - 4) : (int32_t *)((int32_t)&g62 + 4); // 0x402365
    *v3 = 0;
    int32_t * v4 = v1 ? (int32_t *)((int32_t)&g62 - 8) : (int32_t *)((int32_t)&g62 + 8); // 0x402366
    *v4 = 0;
    return 0;
}

// Address range: 0x402369 - 0x4024ee
int32_t function_402369(void) {
    // 0x402369
    int32_t lpCPInfo; // bp-24, 0x402369
    GetCPInfo(g61, (struct _cpinfo *)&lpCPInfo);
    int32_t v1 = 0; // 0x4024a4
    int32_t v2; // 0x402369
    while (true) {
      lab_0x4024a9:
        // 0x4024a9
        v2 = v1;
        int32_t v3; // 0x402369
        if (v2 < 91) {
            char * v4 = (char *)(v2 + (int32_t)&g66); // 0x4024b3
            *v4 = *v4 | 16;
            // 0x4024bf
            v3 = v2 + 32;
            *(char *)(v2 + (int32_t)&g64) = (char)v3;
            goto lab_0x4024e6;
        } else {
            if (v2 < 123) {
                char * v5 = (char *)(v2 + (int32_t)&g66); // 0x4024d1
                *v5 = *v5 | 32;
                // 0x4024bf
                v3 = v2 + 224;
                *(char *)(v2 + (int32_t)&g64) = (char)v3;
                goto lab_0x4024e6;
            } else {
                // 0x4024df
                *(char *)(v2 + (int32_t)&g64) = 0;
                goto lab_0x4024e6;
            }
        }
    }
    // 0x4024eb
    return 256;
  lab_0x4024e6:
    // 0x4024e6
    v1 = v2 + 1;
    if (v1 == 256) {
        return 256;
    }
    goto lab_0x4024a9;
}

// Address range: 0x4024ee - 0x40250a
int32_t function_4024ee(void) {
    // 0x4024ee
    int32_t result; // 0x4024ee
    if (g73 == 0) {
        int32_t v1 = function_40212a(-3); // 0x4024f9
        g73 = 1;
        result = v1;
    }
    // 0x402509
    return result;
}

// Address range: 0x40250a - 0x402539
int32_t function_40250a(int32_t lpMem) {
    // 0x40250a
    if (lpMem == 0) {
        // 0x402537
        int32_t result; // 0x40250a
        return result;
    }
    // 0x402513
    int32_t v1; // 0x40250a
    int32_t v2 = function_402aa3(lpMem, v1); // 0x402514
    if (v2 != 0) {
        // 0x40251f
        return function_402ace(v2, lpMem);
    }
    // 0x402537
    return HeapFree((int32_t *)g68, 0, (int32_t *)lpMem);
}

// Address range: 0x402540 - 0x402547
int32_t function_402540(int32_t a1) {
    // 0x402540
    int32_t v1; // 0x402540
    return function_4025b1(v1, (int32_t)&g80, (int32_t)&g80);
}

// Address range: 0x402550 - 0x4025b1
int32_t function_402550(int32_t * a1, int32_t a2) {
    int32_t v1 = (int32_t)a1;
    int32_t v2 = v1; // 0x40255b
    int32_t v3 = v1; // 0x40255b
    int32_t result; // 0x4025a2
    if ((v1 & 3) != 0) {
        while (*(char *)v2 != 0) {
            // 0x402564
            v2++;
            v3 = v2;
            if ((v2 & 3) == 0) {
                goto lab_0x40256c;
            }
        }
        // 0x40259f
        result = function_4025b1((int32_t)&g80, (int32_t)&g80, (int32_t)&g80);
        return result;
    }
  lab_0x40256c:;
    int32_t v4 = v3; // 0x402550
    uint32_t result4; // 0x40256c
    while (true) {
        // 0x40256c
        result4 = *(int32_t *)v4;
        if (((result4 ^ -0x7efeff00 ^ result4 + 0x7efefeff) & -0x7efeff00) != 0) {
            if ((char)result4 == 0) {
                // break -> 0x4025ae
                break;
            }
            if ((result4 & 0xff00) == 0) {
                int32_t result2 = function_4025b1((int32_t)&g80, (int32_t)&g80, (int32_t)&g80); // 0x4025ac
                return result2;
            }
            if ((result4 & 0xff0000) == 0) {
                int32_t result3 = function_4025b1((int32_t)&g80, (int32_t)&g80, (int32_t)&g80); // 0x4025a7
                return result3;
            }
            if (result4 < 0x1000000) {
                // 0x40259f
                result = function_4025b1((int32_t)&g80, (int32_t)&g80, (int32_t)&g80);
                return result;
            }
        }
        // 0x40256c
        v4 += 4;
    }
    // 0x4025ae
    return result4;
}

// Address range: 0x4025b1 - 0x402630
int32_t function_4025b1(int32_t a1, int32_t result, int32_t a3) {
    int32_t v1 = a3; // 0x4025bb
    int32_t v2 = a3; // 0x4025bb
    int32_t v3; // 0x4025b1
    if ((a3 & 3) != 0) {
        char v4 = *(char *)v1; // 0x4025bd
        int32_t v5; // 0x4025b1
        while (v4 != 0) {
            // 0x4025c4
            v1++;
            *(char *)v5 = v4;
            int32_t v6 = v5 + 1; // 0x4025c6
            v5 = v6;
            v2 = v1;
            v3 = v6;
            if ((v1 & 3) == 0) {
                goto lab_0x4025d6;
            }
            v4 = *(char *)v1;
        }
        // 0x402628
        *(char *)v5 = 0;
        return result;
    }
  lab_0x4025d6:;
    int32_t v7 = v2; // 0x4025b1
    int32_t v8 = v3; // 0x4025b1
    int32_t v9; // 0x4025b1
    while (true) {
        int32_t v10 = v8;
        uint32_t v11 = *(int32_t *)v7;
        if (((v11 ^ -0x7efeff00 ^ v11 + 0x7efefeff) & -0x7efeff00) != 0) {
            // 0x4025f0
            v9 = v10;
            if ((char)v11 == 0) {
                // break -> 0x402628
                break;
            }
            if ((v11 & 0xff00) == 0) {
                // 0x40261f
                *(int16_t *)v10 = (int16_t)v11;
                return result;
            }
            if ((v11 & 0xff0000) == 0) {
                // 0x402612
                *(int16_t *)v10 = (int16_t)v11;
                *(char *)(v10 + 2) = 0;
                return result;
            }
            if (v11 < 0x1000000) {
                // 0x40260a
                *(int32_t *)v10 = v11;
                return result;
            }
        }
        // 0x4025d1
        *(int32_t *)v10 = v11;
        v7 += 4;
        v8 = v10 + 4;
    }
    // 0x402628
    *(char *)v9 = 0;
    return result;
}

// Address range: 0x40266e - 0x4026a4
int32_t __heap_alloc(uint32_t a1) {
    // 0x40266e
    if (g25 >= a1) {
        // 0x40267b
        int32_t v1; // 0x40266e
        int32_t result = function_402df9(a1, v1); // 0x40267c
        if (result != 0) {
            // 0x4026a2
            return result;
        }
    }
    int32_t dwBytes = a1 != 0 ? a1 + 15 & -16 : 16; // 0x402690
    // 0x4026a2
    return (int32_t)HeapAlloc((int32_t *)g68, 0, dwBytes);
}

// Address range: 0x4026b0 - 0x40272b
int32_t function_4026b0(int32_t a1) {
    int32_t v1 = a1; // 0x4026ba
    if ((a1 & 3) != 0) {
        int32_t v2 = a1;
        int32_t v3 = v2 + 1; // 0x4026be
        while (*(char *)v2 != 0) {
            // 0x4026c3
            v1 = v3;
            if ((v3 & 3) == 0) {
                goto lab_0x4026d0;
            }
            v2 = v3;
            v3 = v2 + 1;
        }
        // 0x402703
        return v3 + -1 - a1;
    }
  lab_0x4026d0:;
    int32_t v4 = v1; // 0x4026b0
    int32_t v5; // 0x4026b0
    while (true) {
        // 0x4026d0
        v5 = v4;
        uint32_t v6 = *(int32_t *)v5; // 0x4026d0
        int32_t v7 = v5 + 4; // 0x4026de
        if (((v6 ^ -0x7efeff00 ^ v6 + 0x7efefeff) & -0x7efeff00) != 0) {
            if ((char)v6 == 0) {
                // break -> 0x402721
                break;
            }
            if ((v6 & 0xff00) == 0) {
                // 0x402717
                return 1 - a1 + v5;
            }
            if ((v6 & 0xff0000) == 0) {
                // 0x40270d
                return 2 - a1 + v5;
            }
            int32_t v8 = v7; // 0x4026ff
            if (v6 < 0x1000000) {
                // 0x402703
                return v8 + -1 - a1;
            }
        }
        // 0x4026d0
        v4 = v7;
    }
    // 0x402721
    return v5 - a1;
}

// Address range: 0x402730 - 0x402a65
int32_t function_402730(int32_t result5, uint32_t a2, uint32_t a3) {
    int32_t result3 = a3 + a2; // 0x402742
    int32_t v1; // 0x402730
    int32_t v2; // 0x402730
    int32_t v3; // 0x402730
    int32_t v4; // 0x402730
    int32_t v5; // 0x402730
    int32_t result6; // 0x402730
    int32_t v6; // 0x402730
    int32_t v7; // 0x402730
    int32_t v8; // 0x402730
    int32_t v9; // 0x402730
    int32_t v10; // 0x402730
    int32_t v11; // 0x402730
    int32_t result2; // 0x402730
    int32_t result; // 0x402730
    if (result5 > a2 == result3 > result5) {
        int32_t v12 = a3 - 4; // 0x4028c8
        int32_t v13 = v12 + a2; // 0x4028c8
        int32_t v14 = v12 + result5; // 0x4028cc
        int32_t v15 = v14 & 3; // 0x4028d0
        if (v15 != 0) {
            // 0x4028fc
            g85 = a3;
            result2 = v15;
            result = result5;
            v9 = v13;
            v6 = v14;
            v10 = v13;
            v7 = v14;
            v11 = v13;
            v8 = v14;
            switch (a3) {
                case 0: {
                    return result;
                }
                case 1: {
                    goto lab_0x402a28;
                }
                case 2: {
                    goto lab_0x402a38;
                }
                case 3: {
                    goto lab_0x402a4c;
                }
                default: {
                    return result2;
                }
            }
        } else {
            int32_t v16 = -((a3 / 4));
            g84 = v16;
            if (a3 < 4) {
                // 0x402778
                return result3;
            }
            int32_t v17 = a3 & 3; // 0x4028db
            __asm_rep_movsd_memcpy((char *)v14, (char *)v13, v16);
            int32_t v18 = v14 + (a3 & -4); // 0x4028e4
            g83 = v17;
            result = result5;
            v9 = v18;
            v6 = v18;
            v10 = v18;
            v7 = v18;
            v11 = v18;
            v8 = v18;
            switch (v17) {
                case 0: {
                    return result;
                }
                case 1: {
                    goto lab_0x402a28;
                }
                case 2: {
                    goto lab_0x402a38;
                }
                case 3: {
                    goto lab_0x402a4c;
                }
                default: {
                    // 0x4028f02
                    // UNREACHABLE
                }
            }
        }
    } else {
        int32_t result4 = result5 & 3; // 0x402750
        if (result4 != 0) {
            // 0x40276c
            result = result5;
            if (a3 >= 4) {
                // 0x402778
                return result4;
            }
            // 0x402778
            return result;
        }
        int32_t v19 = a3 / 4; // 0x402758
        g82 = v19;
        result = result3;
        switch (v19) {
            case 0: {
                return result;
            }
            case 1: {
                // 0x402758
                result6 = a3 & -4;
                goto lab_0x40285c;
            }
            case 2: {
                // 0x402758
                v3 = a3 & -4;
                goto lab_0x402854;
            }
            case 3: {
                // 0x402758
                v4 = a3 & -4;
                goto lab_0x40284c;
            }
            case 4: {
                // 0x402758
                v5 = a3 & -4;
                goto lab_0x402844;
            }
            case 5: {
                // 0x402758
                v1 = a3 & -4;
                goto lab_0x40283c;
            }
            case 6: {
                // 0x402758
                v2 = a3 & -4;
                goto lab_0x402834;
            }
            case 7: {
                int32_t v20 = a3 & -4;
                int32_t v21 = v20 - 28;
                *(int32_t *)(v21 + result5) = *(int32_t *)(v21 + a2);
                v2 = v20;
                goto lab_0x402834;
            }
            default: {
                int32_t v22 = a3 & 3; // 0x40275b
                __asm_rep_movsd_memcpy((char *)result5, (char *)a2, v19);
                g81 = v22;
                result2 = result5;
                if (v22 < 2) {
                    // 0x402778
                    return result5;
                }
                // 0x402778
                return result2;
            }
        }
    }
  lab_0x402a28:
    // 0x402a28
    *(char *)(v6 + 3) = *(char *)(v9 + 3);
    return result5;
  lab_0x402a38:
    // 0x402a38
    *(char *)(v7 + 3) = *(char *)(v10 + 3);
    *(char *)(v7 + 2) = *(char *)(v10 + 2);
    return result5;
  lab_0x402a4c:
    // 0x402a4c
    *(char *)(v8 + 3) = *(char *)(v11 + 3);
    *(char *)(v8 + 2) = *(char *)(v11 + 2);
    *(char *)(v8 + 1) = *(char *)(v11 + 1);
    return result5;
  lab_0x40285c:;
    int32_t v23 = result6 - 4;
    *(int32_t *)(v23 + result5) = *(int32_t *)(v23 + a2);
    // 0x402778
    return result6;
  lab_0x402854:;
    int32_t v24 = v3 - 8;
    *(int32_t *)(v24 + result5) = *(int32_t *)(v24 + a2);
    result6 = v3;
    goto lab_0x40285c;
  lab_0x40284c:;
    int32_t v25 = v4 - 12;
    *(int32_t *)(v25 + result5) = *(int32_t *)(v25 + a2);
    v3 = v4;
    goto lab_0x402854;
  lab_0x402844:;
    int32_t v26 = v5 - 16;
    *(int32_t *)(v26 + result5) = *(int32_t *)(v26 + a2);
    v4 = v5;
    goto lab_0x40284c;
  lab_0x40283c:;
    int32_t v27 = v1 - 20;
    *(int32_t *)(v27 + result5) = *(int32_t *)(v27 + a2);
    v5 = v1;
    goto lab_0x402844;
  lab_0x402834:;
    int32_t v28 = v2 - 24;
    *(int32_t *)(v28 + result5) = *(int32_t *)(v28 + a2);
    v1 = v2;
    goto lab_0x40283c;
}

// Address range: 0x402a65 - 0x402aa3
int32_t function_402a65(void) {
    int32_t * v1 = HeapAlloc((int32_t *)g68, 0, 320); // 0x402a72
    int32_t result = (int32_t)v1; // 0x402a72
    g60 = result;
    if (v1 == NULL) {
        // 0x402a81
        return result;
    }
    // 0x402a82
    g58 = 0;
    g59 = 0;
    g57 = result;
    g55 = 16;
    return 1;
}

// Address range: 0x402aa3 - 0x402ace
int32_t function_402aa3(int32_t a1, int32_t a2) {
    uint32_t v1 = g60 + 20 * g59; // 0x402ab0
    if (g60 >= v1) {
        // 0x402acd
        return 0;
    }
    int32_t v2 = g60; // 0x402ab5
    int32_t result = v2; // 0x402ac4
    while (a1 - *(int32_t *)(v2 + 12) >= 0x100000) {
        // 0x402ac6
        v2 += 20;
        result = 0;
        if (v2 >= v1) {
            // break -> 0x402acd
            break;
        }
        result = v2;
    }
    // 0x402acd
    return result;
}

// Address range: 0x402ace - 0x402df9
int32_t function_402ace(int32_t a1, int32_t a2) {
    int32_t v1 = *(int32_t *)(a1 + 16); // 0x402adc
    int32_t v2 = a2 - 4; // 0x402ae4
    int32_t v3 = *(int32_t *)v2; // 0x402ae4
    int32_t v4 = (a2 - *(int32_t *)(a1 + 12)) / 0x8000; // 0x402aeb
    int32_t v5 = *(int32_t *)(a2 - 8); // 0x402af0
    int32_t v6 = v3 - 1; // 0x402af9
    int32_t v7 = *(int32_t *)(v6 + v2); // 0x402b0a
    int32_t v8 = v6; // 0x402b13
    if ((v7 & 1) == 0) {
        int32_t v9 = v3 + v2;
        int32_t * v10 = (int32_t *)(v9 + 3); // 0x402b26
        int32_t * v11 = (int32_t *)(v9 + 7); // 0x402b2a
        if (*v10 == *v11) {
            uint32_t v12 = v7 / 16 - 1; // 0x402b1a
            uint32_t v13 = v12 < 63 ? v12 : 63;
            int32_t v14 = v1 + 4 + v13;
            int32_t v15 = -1 - (0x80000000 >> (v13 & 31));
            int32_t v16 = 4 * v4;
            if (v13 >= 32) {
                int32_t * v17 = (int32_t *)(v1 + 196 + v16); // 0x402b67
                *v17 = *v17 & v15;
                char * v18 = (char *)v14; // 0x402b6e
                char v19 = *v18 - 1; // 0x402b6e
                *v18 = v19;
                if (v19 == 0) {
                    int32_t * v20 = (int32_t *)(a1 + 4); // 0x402b75
                    *v20 = *v20 & v15;
                }
            } else {
                int32_t * v21 = (int32_t *)(v1 + 68 + v16); // 0x402b45
                *v21 = *v21 & v15;
                char * v22 = (char *)v14; // 0x402b49
                char v23 = *v22 - 1; // 0x402b49
                *v22 = v23;
                if (v23 == 0) {
                    int32_t * v24 = (int32_t *)a1; // 0x402b50
                    *v24 = *v24 & v15;
                }
            }
        }
        // 0x402b78
        *(int32_t *)(*v11 + 4) = *v10;
        *(int32_t *)(*v10 + 8) = *v11;
        v8 = v7 + v6;
    }
    int32_t result = v1 + 324 + 516 * v4; // 0x402afd
    int32_t v25; // 0x402ace
    int32_t v26; // 0x402ace
    int32_t v27; // 0x402ace
    int32_t v28; // 0x402ace
    int32_t v29; // 0x402ace
    int32_t * v30; // 0x402ace
    int32_t * v31; // 0x402ace
    if ((v5 & 1) != 0) {
        uint32_t v32 = v8 / 16 - 1; // 0x402b99
        v31 = (int32_t *)(a2 + 4);
        v30 = (int32_t *)a2;
        v25 = v32 < 63 ? v32 : 63;
        v26 = v2;
        v28 = v8;
        goto lab_0x402c60;
    } else {
        int32_t v33 = v2 - v5; // 0x402bb1
        uint32_t v34 = v5 / 16 - 1; // 0x402bbf
        uint32_t v35 = v34 < 63 ? v34 : 63;
        int32_t v36 = v8 + v5; // 0x402bcd
        uint32_t v37 = v36 / 16 - 1; // 0x402bd8
        int32_t v38 = v37 < 63 ? v37 : 63;
        v27 = v33;
        v29 = v36;
        if (v35 == v38) {
            goto lab_0x402ce9;
        } else {
            // 0x402be3
            v30 = (int32_t *)(v33 + 4);
            v31 = (int32_t *)(v33 + 8);
            if (*v30 == *v31) {
                uint32_t v39 = v35 & 31;
                if (v35 >= 32) {
                    int32_t v40 = -1 - (0x80000000 >> v39);
                    int32_t * v41 = (int32_t *)(v1 + 196 + 4 * v4); // 0x402c25
                    *v41 = *v41 & v40;
                    char * v42 = (char *)(v1 + 4 + v35); // 0x402c2c
                    char v43 = *v42 - 1; // 0x402c2c
                    *v42 = v43;
                    if (v43 == 0) {
                        int32_t * v44 = (int32_t *)(a1 + 4); // 0x402c33
                        *v44 = *v44 & v40;
                    }
                } else {
                    int32_t v45 = v39 == 0 ? 0x7fffffff : -1 - (0x80000000 >> v39);
                    int32_t * v46 = (int32_t *)(v1 + 68 + 4 * v4); // 0x402c03
                    *v46 = *v46 & v45;
                    char * v47 = (char *)(v1 + 4 + v35); // 0x402c07
                    char v48 = *v47 - 1; // 0x402c07
                    *v47 = v48;
                    if (v48 == 0) {
                        int32_t * v49 = (int32_t *)a1; // 0x402c0e
                        *v49 = *v49 & v45;
                    }
                }
            }
            // 0x402c51
            *(int32_t *)(*v31 + 4) = *v30;
            *(int32_t *)(*v30 + 8) = *v31;
            v25 = v38;
            v26 = v33;
            v28 = v36;
            goto lab_0x402c60;
        }
    }
  lab_0x402c60:;
    int32_t v50 = 8 * v25 + result; // 0x402c63
    int32_t * v51 = (int32_t *)(v50 + 4); // 0x402c66
    *v30 = *v51;
    *v31 = v50;
    *v51 = v26;
    *(int32_t *)(*v30 + 8) = v26;
    v27 = v26;
    v29 = v28;
    if (*v30 == *v31) {
        char * v52 = (char *)(v1 + 4 + v25); // 0x402c86
        char v53 = *v52; // 0x402c86
        *v52 = v53 + 1;
        int32_t v54 = 0x80000000 >> (v25 & 31);
        if (v25 >= 32) {
            if (v53 == 0) {
                int32_t * v55 = (int32_t *)(a1 + 4); // 0x402cd0
                *v55 = *v55 | v54;
            }
            int32_t * v56 = (int32_t *)(v1 + 196 + 4 * v4); // 0x402ce4
            *v56 = *v56 | v54;
            v27 = v26;
            v29 = v28;
        } else {
            if (v53 == 0) {
                int32_t * v57 = (int32_t *)a1; // 0x402caa
                *v57 = *v57 | v54;
            }
            int32_t * v58 = (int32_t *)(v1 + 68 + 4 * v4); // 0x402cb9
            *v58 = *v58 | v54;
            v27 = v26;
            v29 = v28;
        }
    }
    goto lab_0x402ce9;
  lab_0x402ce9:;
    int32_t v59 = v29;
    *(int32_t *)v27 = v59;
    *(int32_t *)(v27 - 4 + v59) = v59;
    int32_t * v60 = (int32_t *)result; // 0x402cf2
    int32_t v61 = *v60 - 1; // 0x402cf2
    *v60 = v61;
    if (v61 != 0) {
        // 0x402df4
        return result;
    }
    int32_t v62 = g58; // 0x402cfa
    int32_t result2 = a1; // 0x402d01
    if (v62 != 0) {
        // 0x402d07
        int32_t lpAddress; // bp-36, 0x402ace
        int32_t v63 = &lpAddress; // 0x402aea
        *(int32_t *)(v63 - 4) = 0x4000;
        *(int32_t *)(v63 - 8) = 0x8000;
        *(int32_t *)(v63 - 12) = 0x8000 * g56 + *(int32_t *)(v62 + 12);
        int32_t dwSize; // 0x402ace
        VirtualFree((int32_t *)lpAddress, dwSize, dwSize);
        int32_t * v64 = (int32_t *)(g58 + 8); // 0x402d39
        *v64 = *v64 | 0x80000000 >> (g56 & 31);
        *(int32_t *)(*(int32_t *)(g58 + 16) + 196 + 4 * g56) = 0;
        char * v65 = (char *)(*(int32_t *)(g58 + 16) + 67); // 0x402d5a
        *v65 = *v65 - 1;
        int32_t v66 = g58; // 0x402d5d
        int32_t v67 = v66; // 0x402d69
        if (*(char *)(*(int32_t *)(v66 + 16) + 67) == 0) {
            int32_t * v68 = (int32_t *)(v66 + 4); // 0x402d6b
            *v68 = *v68 & -2;
            v67 = g58;
        }
        // 0x402d74
        result2 = a1;
        if (*(int32_t *)(v67 + 8) == -1) {
            // 0x402d7a
            *(int32_t *)(v63 - 16) = 0x8000;
            *(int32_t *)(v63 - 20) = 0;
            *(int32_t *)(v63 - 24) = *(int32_t *)(v67 + 12);
            VirtualFree(&g80, (int32_t)&g80, (int32_t)&g80);
            *(int32_t *)(v63 - 28) = *(int32_t *)(g58 + 16);
            *(int32_t *)(v63 - 32) = 0;
            *(int32_t *)(v63 - 36) = g68;
            HeapFree(&g80, (int32_t)&g80, &g80);
            *(int32_t *)(v63 - 40) = 20 * g59 - 20 + g60 - g58;
            *(int32_t *)(v63 - 44) = g58 + 20;
            *(int32_t *)(v63 - 48) = g58;
            function_403800((int32_t)&g80, (int32_t)&g80, (int32_t)&g80);
            g59--;
            g57 = g60;
            result2 = g58 < a1 ? a1 - 20 : a1;
        }
    }
    // 0x402de9
    g58 = result2;
    g56 = v4;
    // 0x402df4
    return result2;
}

// Address range: 0x402df9 - 0x403102
int32_t function_402df9(int32_t a1, int32_t a2) {
    uint32_t v1 = g60 + 20 * g59; // 0x402e10
    int32_t v2 = a1 + 23; // 0x402e19
    int32_t v3 = v2 / 16 - 1; // 0x402e25
    int32_t v4 = 0xffffffff >> (v3 & 31);
    int32_t v5 = v3 > 31 ? v4 : -1;
    int32_t v6 = v3 > 31 ? 0 : v4;
    uint32_t v7 = g57; // 0x402e49
    int32_t v8 = v7; // 0x402e55
    int32_t v9 = v7; // 0x402e55
    if (v7 < v1) {
        int32_t v10 = *(int32_t *)v8; // 0x402e5a
        v9 = v8;
        while ((v10 & v6 | *(int32_t *)(v8 + 4) & v5) == 0) {
            // 0x402e65
            v8 += 20;
            v9 = v8;
            if (v8 >= v1) {
                // break -> 0x402e70
                break;
            }
            v10 = *(int32_t *)v8;
            v9 = v8;
        }
    }
    int32_t v11 = v9; // 0x402e73
    if (v9 == v1) {
        int32_t v12 = g60; // 0x402e7c
        int32_t v13 = g60; // 0x402e7c
        if (g60 < v7) {
            int32_t v14 = *(int32_t *)(v12 + 4); // 0x402e7e
            v13 = v12;
            while ((*(int32_t *)v12 & v6 || v14 & v5) == 0) {
                int32_t v15 = v12 + 20; // 0x402e8c
                v12 = v15;
                v13 = v15;
                if (v15 >= v7) {
                    // break -> 0x402e93
                    break;
                }
                v14 = *(int32_t *)(v12 + 4);
                v13 = v12;
            }
        }
        // 0x402e93
        v11 = v13;
        if (v13 == v7) {
            int32_t v16 = v13; // 0x402e98
            int32_t v17 = v13; // 0x402e98
            if (v13 < v1) {
                v17 = v16;
                while (*(int32_t *)(v16 + 8) == 0) {
                    int32_t v18 = v16 + 20; // 0x402ea0
                    v16 = v18;
                    v17 = v18;
                    if (v18 >= v1) {
                        // break -> 0x402eab
                        break;
                    }
                    v17 = v16;
                }
            }
            int32_t v19 = v17; // 0x402eab
            if (v17 == v1) {
                int32_t v20 = g60; // 0x402eb4
                int32_t v21 = g60; // 0x402eb4
                if (g60 < v7) {
                    v21 = v20;
                    while (*(int32_t *)(v20 + 8) == 0) {
                        int32_t v22 = v20 + 20; // 0x402ebc
                        v20 = v22;
                        v21 = v22;
                        if (v22 >= v7) {
                            // break -> 0x402ec3
                            break;
                        }
                        v21 = v20;
                    }
                }
                // 0x402ec3
                v19 = v21;
                if (v21 == v7) {
                    int32_t v23 = function_403102(v21); // 0x402ec5
                    v19 = v23;
                    if (v23 == 0) {
                        // 0x4030fd
                        return 0;
                    }
                }
            }
            int32_t v24 = function_4031b3(v19); // 0x402ed4
            int32_t * v25 = (int32_t *)(v19 + 16); // 0x402eda
            *(int32_t *)*v25 = v24;
            v11 = v19;
            if (*(int32_t *)*v25 == -1) {
                // 0x4030fd
                return 0;
            }
        }
    }
    // 0x402eee
    g57 = v11;
    int32_t v26 = *(int32_t *)(v11 + 16); // 0x402ef4
    int32_t * v27 = (int32_t *)v26; // 0x402ef7
    int32_t v28 = *v27; // 0x402ef7
    int32_t v29; // 0x402df9
    int32_t v30; // 0x402df9
    int32_t v31; // 0x402df9
    if (v28 == -1) {
        // 0x402eee
        v29 = v26 + 68;
        v30 = v26 + 196;
        goto lab_0x402f15;
    } else {
        int32_t v32 = 4 * v28; // 0x402f01
        int32_t v33 = v26 + 196;
        int32_t v34 = v26 + 68;
        int32_t v35 = *(int32_t *)(v32 + v34); // 0x402f08
        v29 = v34;
        v30 = v33;
        v31 = v28;
        if ((v35 & v6 || *(int32_t *)(v32 + v33) & v5) != 0) {
            goto lab_0x402f4c;
        } else {
            goto lab_0x402f15;
        }
    }
  lab_0x402f15:;
    int32_t v36 = *(int32_t *)v29; // 0x402f1b
    v31 = 0;
    if ((v36 & v6 || *(int32_t *)v30 & v5) == 0) {
        int32_t v37 = v29;
        int32_t v38 = 1; // 0x402f38
        int32_t v39 = v37 + 4; // 0x402f3e
        int32_t v40 = *(int32_t *)v39; // 0x402f43
        int32_t v41 = v38; // 0x402f47
        v31 = v38;
        while ((v40 & v6 | *(int32_t *)(v37 + 132) & v5) == 0) {
            // 0x402f32
            v37 = v39;
            v38 = v41 + 1;
            v39 = v37 + 4;
            v40 = *(int32_t *)v39;
            v41 = v38;
            v31 = v38;
        }
    }
    goto lab_0x402f4c;
  lab_0x402f4c:;
    int32_t v42 = 4 * v31; // 0x402f60
    int32_t * v43 = (int32_t *)(v42 + v26 + 68); // 0x402f60
    int32_t v44 = *v43; // 0x402f60
    int32_t v45 = v44 & v6; // 0x402f64
    int32_t v46 = v45; // 0x402f66
    int32_t v47 = 0; // 0x402f66
    if (v45 == 0) {
        // 0x402f68
        v46 = *(int32_t *)(v26 + 196 + v42) & v5;
        v47 = 32;
    }
    int32_t v48 = v47; // 0x402f77
    if (v46 >= 0) {
        int32_t v49 = 2 * v46; // 0x402f79
        int32_t v50 = v47 + 1; // 0x402f7b
        int32_t v51 = v50; // 0x402f77
        int32_t v52 = v49; // 0x402f77
        v48 = v50;
        while (v49 >= 0) {
            // 0x402f79
            v49 = 2 * v52;
            v50 = v51 + 1;
            v51 = v50;
            v52 = v49;
            v48 = v50;
        }
    }
    int32_t v53 = v2 & -16; // 0x402e1c
    int32_t v54 = v26 + 324 + 516 * v31; // 0x402f56
    int32_t v55 = v54 + 4; // 0x402f81
    int32_t v56 = *(int32_t *)(8 * v48 + v55); // 0x402f81
    int32_t * v57 = (int32_t *)v56; // 0x402f85
    int32_t v58 = *v57 - v53; // 0x402f87
    int32_t v59 = v58 < 1040 ? v58 / 16 - 1 : 63;
    if (v59 == v48) {
        if (v58 == 0) {
            goto lab_0x4030bf;
        } else {
            // 0x4030b4
            *v57 = v58;
            *(int32_t *)(v58 + v56 - 4) = v58;
            goto lab_0x4030bf;
        }
    } else {
        int32_t * v60 = (int32_t *)(v56 + 4); // 0x402fa3
        int32_t * v61 = (int32_t *)(v56 + 8); // 0x402fa6
        if (*v60 == *v61) {
            uint32_t v62 = v48 & 31;
            if (v48 > 31) {
                int32_t v63 = -1 - (0x80000000 >> v62);
                int32_t * v64 = (int32_t *)(v26 + 196 + v42); // 0x402ff5
                *v64 = *v64 & v63;
                char * v65 = (char *)(v26 + 4 + v48); // 0x402ff7
                char v66 = *v65 - 1; // 0x402ff7
                *v65 = v66;
                if (v66 == 0) {
                    int32_t * v67 = (int32_t *)(v11 + 4); // 0x403004
                    *v67 = *v67 & v63;
                }
            } else {
                int32_t v68 = v62 == 0 ? 0x7fffffff : -1 - (0x80000000 >> v62);
                *v43 = v68 & v44;
                char * v69 = (char *)(v26 + 4 + v48); // 0x402fcd
                char v70 = *v69 - 1; // 0x402fcd
                *v69 = v70;
                if (v70 == 0) {
                    int32_t * v71 = (int32_t *)v11; // 0x402fd7
                    *v71 = *v71 & v68;
                }
            }
        }
        // 0x40300c
        *(int32_t *)(*v61 + 4) = *v60;
        *(int32_t *)(*v60 + 8) = *v61;
        if (v58 == 0) {
            goto lab_0x4030bf;
        } else {
            int32_t v72 = 8 * v59; // 0x40302b
            int32_t v73 = v72 + v54; // 0x40302f
            *v60 = *(int32_t *)(v72 + v55);
            *v61 = v73;
            *(int32_t *)(v73 + 4) = v56;
            *(int32_t *)(*v60 + 8) = v56;
            if (*v60 == *v61) {
                char * v74 = (char *)(v26 + 4 + v59); // 0x403049
                char v75 = *v74; // 0x403049
                *v74 = v75 + 1;
                int32_t v76 = 0x80000000 >> (v59 & 31);
                if (v59 > 31) {
                    if (v75 == 0) {
                        int32_t * v77 = (int32_t *)(v11 + 4); // 0x403094
                        *v77 = *v77 | v76;
                    }
                    int32_t * v78 = (int32_t *)(v26 + 196 + v42); // 0x4030ab
                    *v78 = *v78 | v76;
                } else {
                    if (v75 == 0) {
                        int32_t * v79 = (int32_t *)v11; // 0x40306a
                        *v79 = *v79 | v76;
                    }
                    // 0x40306c
                    *v43 = *v43 | v76;
                }
            }
            // 0x4030b4
            *v57 = v58;
            *(int32_t *)(v58 + v56 - 4) = v58;
            goto lab_0x4030bf;
        }
    }
  lab_0x4030bf:;
    int32_t v80 = v58 + v56; // 0x4030c2
    int32_t v81 = v53 | 1; // 0x4030c4
    *(int32_t *)v80 = v81;
    *(int32_t *)(v53 - 4 + v80) = v81;
    int32_t * v82 = (int32_t *)v54; // 0x4030d0
    int32_t v83 = *v82; // 0x4030d0
    *v82 = v83 + 1;
    if (v83 != 0 || v11 != g58) {
        // 0x4030f5
        *v27 = v31;
        // 0x4030fd
        return v80 + 4;
    }
    // 0x4030e3
    if (g56 == v31) {
        // 0x4030ee
        g58 = 0;
    }
    // 0x4030f5
    *v27 = v31;
    // 0x4030fd
    return v80 + 4;
}

// Address range: 0x403102 - 0x4031b3
int32_t function_403102(int32_t a1) {
    int32_t v1 = g59; // 0x403102
    int32_t v2 = g55; // 0x403107
    int32_t v3; // 0x403102
    int32_t v4; // 0x403102
    int32_t * v5; // 0x403102
    if (v1 != v2) {
        // 0x403102
        v3 = g60;
        v4 = v1;
        int32_t v6; // bp-8, 0x403102
        v5 = &v6;
    } else {
        int32_t v7 = g68; // bp-24, 0x403124
        int32_t * v8 = HeapReAlloc((int32_t *)g68, 0, (int32_t *)g60, 4 * (v2 + 80 + 4 * v2)); // 0x40312a
        if (v8 == NULL) {
            // 0x4031b0
            return 0;
        }
        int32_t v9 = (int32_t)v8; // 0x40312a
        g55 += 16;
        g60 = v9;
        v3 = v9;
        v4 = g59;
        v5 = &v7;
    }
    int32_t v10 = (int32_t)v5;
    *(int32_t *)(v10 - 4) = 0x41c4;
    *(int32_t *)(v10 - 8) = 8;
    *(int32_t *)(v10 - 12) = g68;
    int32_t v11 = 20 * v4 + v3; // 0x40315b
    int32_t * v12 = HeapAlloc(&g80, (int32_t)&g80, (int32_t)&g80); // 0x40315e
    int32_t * v13 = (int32_t *)(v11 + 16); // 0x403166
    *v13 = (int32_t)v12;
    if (v12 == NULL) {
        // 0x4031b0
        return 0;
    }
    // 0x40316b
    *(int32_t *)(v10 - 16) = 4;
    *(int32_t *)(v10 - 20) = 0x2000;
    *(int32_t *)(v10 - 24) = 0x100000;
    *(int32_t *)(v10 - 28) = 0;
    int32_t * memory = VirtualAlloc(&g80, (int32_t)&g80, (int32_t)&g80, (int32_t)&g80); // 0x403178
    *(int32_t *)(v11 + 12) = (int32_t)memory;
    int32_t result; // 0x403102
    if (memory != NULL) {
        // 0x403199
        *(int32_t *)(v11 + 8) = -1;
        *(int32_t *)v11 = 0;
        *(int32_t *)(v11 + 4) = 0;
        g59++;
        *(int32_t *)*v13 = -1;
        result = v11;
    } else {
        // 0x403185
        *(int32_t *)(v10 - 32) = *v13;
        *(int32_t *)(v10 - 36) = 0;
        *(int32_t *)(v10 - 40) = g68;
        HeapFree(&g80, (int32_t)&g80, &g80);
        result = 0;
    }
    // 0x4031b0
    return result;
}

// Address range: 0x4031b3 - 0x4032ae
int32_t function_4031b3(int32_t a1) {
    int32_t v1 = *(int32_t *)(a1 + 16); // 0x4031bd
    int32_t * v2 = (int32_t *)(a1 + 8); // 0x4031c0
    uint32_t v3 = *v2; // 0x4031c0
    int32_t v4 = 0; // 0x4031c7
    int32_t v5 = v3; // 0x4031c7
    int32_t result = 0; // 0x4031c7
    if (v3 >= 0) {
        v5 *= 2;
        v4++;
        result = v4;
        while (v5 >= 0) {
            // 0x4031c9
            v5 *= 2;
            v4++;
            result = v4;
        }
    }
    int32_t v6 = v1 + 324 + 516 * result; // 0x4031d9
    int32_t v7 = v6; // 0x4031e0
    for (int32_t i = 63; i > 0; i--) {
        int32_t v8 = v7;
        v7 = v8 + 8;
        *(int32_t *)v7 = v8;
        *(int32_t *)(v8 + 4) = v8;
    }
    uint32_t lpAddress = *(int32_t *)(a1 + 12) + 0x8000 * result; // 0x4031f6
    if (VirtualAlloc((int32_t *)lpAddress, 0x8000, 0x1000, 4) == NULL) {
        // 0x4032a9
        return -1;
    }
    if (lpAddress < 0xffff9000) {
        int32_t v9 = lpAddress + 16;
        *(int32_t *)(v9 - 8) = -1;
        *(int32_t *)(v9 + 4076) = -1;
        *(int32_t *)(v9 - 4) = 4080;
        *(int32_t *)v9 = v9 + 4092;
        *(int32_t *)(v9 + 4) = v9 - 0x1004;
        *(int32_t *)(v9 + 4072) = 4080;
        int32_t v10 = v9 + 0x1000; // 0x40325a
        while (v9 + 4080 <= lpAddress + 0x7000) {
            // 0x403223
            v9 = v10;
            *(int32_t *)(v9 - 8) = -1;
            *(int32_t *)(v9 + 4076) = -1;
            *(int32_t *)(v9 - 4) = 4080;
            *(int32_t *)v9 = v9 + 4092;
            *(int32_t *)(v9 + 4) = v9 - 0x1004;
            *(int32_t *)(v9 + 4072) = 4080;
            v10 = v9 + 0x1000;
        }
    }
    int32_t v11 = v6 + 504; // 0x403262
    *(int32_t *)(v6 + 508) = lpAddress + 12;
    *(int32_t *)(lpAddress + 20) = v11;
    *(int32_t *)(v6 + 512) = lpAddress + 0x700c;
    *(int32_t *)(lpAddress + 0x7010) = v11;
    int32_t v12 = 4 * result + v1;
    *(int32_t *)(v12 + 68) = 0;
    *(int32_t *)(v12 + 196) = 1;
    char * v13 = (char *)(v1 + 67); // 0x403285
    char v14 = *v13; // 0x403285
    *v13 = v14 + 1;
    if (v14 == 0) {
        int32_t * v15 = (int32_t *)(a1 + 4); // 0x403296
        *v15 = *v15 | 1;
    }
    uint32_t v16 = result & 31; // 0x4032a0
    *v2 = *v2 & (v16 == 0 ? 0x7fffffff : -1 - (0x80000000 >> v16));
    // 0x4032a9
    return result;
}

// Address range: 0x4032ae - 0x403337
int32_t function_4032ae(int32_t * a1, char * a2, int32_t a3) {
    // 0x4032ae
    int32_t v1; // bp-12, 0x4032ae
    int32_t * v2 = &v1; // 0x4032b9
    if (g47 == 0) {
        int32_t * moduleHandle = LoadLibraryA("user32.dll"); // 0x4032c0
        if (moduleHandle == NULL) {
            // 0x40332f
            return 0;
        }
        int32_t (*func)() = GetProcAddress(moduleHandle, "MessageBoxA"); // 0x4032d8
        g47 = (int32_t)func;
        if (func == NULL) {
            // 0x40332f
            return 0;
        }
        int32_t (*func2)() = GetProcAddress(moduleHandle, "GetActiveWindow"); // 0x4032e9
        int32_t v3 = (int32_t)moduleHandle; // bp-40, 0x4032f0
        g48 = (int32_t)func2;
        g49 = (int32_t)GetProcAddress(moduleHandle, "GetLastActivePopup");
        v2 = &v3;
    }
    int32_t v4 = (int32_t)v2;
    int32_t result = 0; // 0x403304
    int32_t v5 = 0; // 0x403304
    int32_t v6 = v4; // 0x403304
    if (g48 != 0) {
        // 0x40330e
        result = 0;
        v5 = g48;
        v6 = v4;
        if (g49 != 0) {
            int32_t v7 = v4 - 4; // 0x403317
            *(int32_t *)v7 = g48;
            result = g49;
            v5 = g49;
            v6 = v7;
        }
    }
    int32_t v8 = v6;
    *(int32_t *)(v8 - 4) = *(int32_t *)(v8 + 24);
    *(int32_t *)(v8 - 8) = *(int32_t *)(v8 + 20);
    *(int32_t *)(v8 - 12) = *(int32_t *)(v8 + 16);
    *(int32_t *)(v8 - 16) = v5;
    // 0x40332f
    return result;
}

// Address range: 0x403340 - 0x40343e
int32_t function_403340(int32_t result, char * a2, int32_t a3) {
    if (a3 == 0) {
        // 0x403392
        return result;
    }
    int32_t v1 = (int32_t)a2; // 0x40334d
    int32_t v2 = a3; // 0x40335b
    int32_t v3 = v1; // 0x40335b
    int32_t v4 = result; // 0x40335b
    int32_t v5; // 0x403340
    int32_t v6; // 0x403340
    int32_t v7; // 0x403340
    int32_t v8; // 0x403340
    int32_t v9; // 0x403340
    int32_t v10; // 0x403340
    int32_t v11; // 0x403340
    if ((v1 & 3) != 0) {
        char v12 = *(char *)v3; // 0x403364
        *(char *)v4 = v12;
        v2--;
        while (v2 != 0) {
            // 0x40336d
            v4++;
            if (v12 == 0) {
                // 0x40339a
                v6 = v2;
                v9 = v4;
                v7 = v2;
                v10 = v4;
                if ((v4 & 3) == 0) {
                    goto lab_0x4033b4;
                } else {
                    goto lab_0x4033a2;
                }
            }
            // 0x403371
            v3++;
            if ((v3 & 3) == 0) {
                // 0x403379
                v5 = v2;
                v11 = v3;
                v8 = v4;
                if (v2 >= 4) {
                    goto lab_0x4033d1;
                } else {
                    goto lab_0x403380;
                }
            }
            v12 = *(char *)v3;
            *(char *)v4 = v12;
            v2--;
        }
      lab_0x403392:
        // 0x403392
        return result;
    }
    // 0x40335d
    v2 = a3;
    v3 = v1;
    v4 = result;
    int32_t v13 = a3; // 0x403360
    v11 = v1;
    v8 = result;
    if (a3 >= 4) {
        goto lab_0x4033d1;
    } else {
        goto lab_0x403385;
    }
  lab_0x4033d1:;
    uint32_t v14 = *(int32_t *)v3;
    int32_t v15; // 0x403340
    if (((v14 ^ -0x7efeff00 ^ v14 + 0x7efefeff) & -0x7efeff00) != 0) {
        if ((char)v14 == 0) {
            // 0x40341b
            *(int32_t *)v15 = 0;
            goto lab_0x40341f;
        }
        if ((v14 & 0xff00) == 0) {
            // 0x403411
            *(int32_t *)v15 = v14 & 255;
            goto lab_0x40341f;
        }
        if ((v14 & 0xff0000) == 0) {
            // 0x403407
            *(int32_t *)v15 = v14 & 0xffff;
            goto lab_0x40341f;
        }
        if (v14 < 0x1000000) {
            // 0x403403
            *(int32_t *)v15 = v14;
            goto lab_0x40341f;
        }
    }
    int32_t v16 = v3 + 4; // 0x4033e1
    *(int32_t *)v4 = v14;
    int32_t v17 = v4 + 4; // 0x4033cb
    int32_t v18 = v2 / 4 - 1; // 0x4033ce
    v5 = v2;
    v11 = v16;
    v8 = v17;
    int32_t v19 = v18; // 0x4033cf
    int32_t v20 = v16; // 0x4033cf
    int32_t v21 = v17; // 0x4033cf
    while (v18 != 0) {
        // 0x4033d1
        v14 = *(int32_t *)v20;
        if (((v14 ^ -0x7efeff00 ^ v14 + 0x7efefeff) & -0x7efeff00) != 0) {
            if ((char)v14 == 0) {
                // 0x40341b
                *(int32_t *)v15 = 0;
                goto lab_0x40341f;
            }
            if ((v14 & 0xff00) == 0) {
                // 0x403411
                *(int32_t *)v15 = v14 & 255;
                goto lab_0x40341f;
            }
            if ((v14 & 0xff0000) == 0) {
                // 0x403407
                *(int32_t *)v15 = v14 & 0xffff;
                goto lab_0x40341f;
            }
            if (v14 < 0x1000000) {
                // 0x403403
                *(int32_t *)v15 = v14;
                goto lab_0x40341f;
            }
        }
        // 0x4033c9
        v16 = v20 + 4;
        *(int32_t *)v21 = v14;
        v17 = v21 + 4;
        v18 = v19 - 1;
        v5 = v2;
        v11 = v16;
        v8 = v17;
        v19 = v18;
        v20 = v16;
        v21 = v17;
    }
    goto lab_0x403380;
  lab_0x403385:;
    int32_t v22 = v11;
    int32_t v23 = v13;
    char v24 = *(char *)v22; // 0x403385
    *(char *)v8 = v24;
    int32_t v25 = v8 + 1; // 0x40338a
    int32_t v26 = v23; // 0x40338d
    int32_t v27 = v25; // 0x40338d
    while (v24 != 0) {
        int32_t v28 = v23 - 1; // 0x40338f
        if (v28 == 0) {
            // 0x403392
            return result;
        }
        v22++;
        v23 = v28;
        v24 = *(char *)v22;
        *(char *)v25 = v24;
        v25++;
        v26 = v23;
        v27 = v25;
    }
    goto lab_0x4033be;
  lab_0x403380:
    // 0x403380
    v13 = v5 & 3;
    if (v13 == 0) {
        // 0x403392
        return result;
    }
    goto lab_0x403385;
  lab_0x4033be:;
    int32_t v29 = v26 - 1; // 0x4033be
    int32_t v30 = v29; // 0x4033bf
    int32_t v31 = v27; // 0x4033bf
    if (v29 == 0) {
        // 0x403392
        return result;
    }
    goto lab_0x4033bb;
  lab_0x4033bb:
    // 0x4033bb
    *(char *)v31 = 0;
    v26 = v30;
    v27 = v31 + 1;
    goto lab_0x4033be;
  lab_0x4033b4:
    // 0x4033b4
    v30 = v7;
    v31 = v10;
    if (v7 >= 4) {
        goto lab_0x403427;
    } else {
        goto lab_0x4033bb;
    }
  lab_0x4033a2:
    // 0x4033a2
    *(char *)v9 = 0;
    int32_t v32 = v6 - 1; // 0x4033a5
    if (v32 == 0) {
        goto lab_0x403392;
    } else {
        int32_t v33 = v9 + 1; // 0x4033a4
        v6 = v32;
        v9 = v33;
        v7 = v32;
        v10 = v33;
        if ((v33 & 3) != 0) {
            goto lab_0x4033a2;
        } else {
            goto lab_0x4033b4;
        }
    }
  lab_0x403427:;
    int32_t v34 = v7 / 4; // 0x403427
    int32_t v35 = v10; // 0x403427
    goto lab_0x403429;
  lab_0x403429:
    // 0x403429
    *(int32_t *)v35 = 0;
    int32_t v36 = v35 + 4; // 0x40342b
    int32_t v37 = v34 - 1; // 0x40342e
    v34 = v37;
    v35 = v36;
    int32_t v38 = v36; // 0x40342f
    if (v37 != 0) {
        goto lab_0x403429;
    } else {
        goto lab_0x403431;
    }
  lab_0x403431:;
    int32_t v39 = v7 & 3; // 0x403431
    v30 = v39;
    v31 = v38;
    if (v39 != 0) {
        goto lab_0x4033bb;
    } else {
        goto lab_0x403392;
    }
  lab_0x40341f:
    // 0x40341f
    v38 = v15 + 4;
    int32_t v40; // 0x403340
    if (v40 == 1) {
        goto lab_0x403431;
    } else {
        goto lab_0x403427;
    }
}

// Address range: 0x40343e - 0x403662
int32_t function_40343e(int32_t a1, int32_t a2, char * a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x403453
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g52; // 0x40346c
    int32_t v3; // bp-60, 0x40343e
    int32_t * v4 = &v3; // 0x40346c
    if (g52 == 0) {
        int32_t v5 = 0; // bp-84, 0x40347f
        if (LCMapStringW(0, 256, (int16_t *)&g2, 1, NULL, 0) == 0) {
            int32_t v6 = 0; // bp-108, 0x40349b
            if (LCMapStringA(0, 256, (char *)&g1, 1, NULL, 0) == 0) {
                // 0x4035ce
                __writefsdword(0, v1);
                return 0;
            }
            // 0x4034aa
            g52 = 2;
            v2 = 2;
            v4 = &v6;
        } else {
            // 0x40348a
            g52 = 1;
            v2 = 1;
            v4 = &v5;
        }
    }
    int32_t v7 = (int32_t)a5;
    int32_t v8 = (int32_t)v4;
    int32_t v9 = v2; // 0x4034b7
    int32_t v10 = v7; // 0x4034b7
    if (a5 > NULL) {
        // 0x4034b9
        *(int32_t *)(v8 - 4) = v7;
        *(int32_t *)(v8 - 8) = a4;
        v10 = function_403662((int32_t)&g80, (int32_t)&g80);
        v9 = g52;
    }
    // 0x4034c9
    if (v9 == 2) {
        // 0x4034d3
        *(int32_t *)(v8 - 4) = a7;
        *(int32_t *)(v8 - 8) = a6;
        *(int32_t *)(v8 - 12) = v10;
        *(int32_t *)(v8 - 16) = a4;
        *(int32_t *)(v8 - 20) = a2;
        *(int32_t *)(v8 - 24) = a1;
        int32_t result = LCMapStringA((int32_t)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80); // 0x4034e5
        // 0x4035ce
        __writefsdword(0, v1);
        return result;
    }
    // 0x4034f0
    if (v9 != 1) {
        // 0x4035ce
        __writefsdword(0, v1);
        return 0;
    }
    int32_t v11 = a8 != 0 ? a8 : g51;
    *(int32_t *)(v8 - 4) = 0;
    *(int32_t *)(v8 - 8) = 0;
    *(int32_t *)(v8 - 12) = v10;
    *(int32_t *)(v8 - 16) = a4;
    *(int32_t *)(v8 - 20) = a9 == 0 ? 1 : 9;
    int32_t v12 = v8 - 24; // 0x40351a
    *(int32_t *)v12 = v11;
    int32_t v13 = MultiByteToWideChar((int32_t)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x40351d
    if (v13 == 0) {
        // 0x4035ce
        __writefsdword(0, v1);
        return 0;
    }
    // 0x403530
    function_403b40(v13);
    if (v12 == 0) {
        // 0x4035ce
        __writefsdword(0, v1);
        return 0;
    }
    // 0x403566
    *(int32_t *)(v8 - 28) = v13;
    *(int32_t *)(v8 - 32) = v12;
    *(int32_t *)(v8 - 36) = v10;
    *(int32_t *)(v8 - 40) = a4;
    *(int32_t *)(v8 - 44) = 1;
    *(int32_t *)(v8 - 48) = v11;
    int32_t v14 = MultiByteToWideChar((int32_t)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x403575
    if (v14 == 0) {
        // 0x4035ce
        __writefsdword(0, v1);
        return 0;
    }
    // 0x40357f
    *(int32_t *)(v8 - 52) = 0;
    *(int32_t *)(v8 - 56) = 0;
    *(int32_t *)(v8 - 60) = v13;
    *(int32_t *)(v8 - 64) = v12;
    *(int32_t *)(v8 - 68) = a2;
    int32_t v15 = v8 - 72; // 0x403588
    *(int32_t *)v15 = a1;
    int32_t Locale = LCMapStringW((int32_t)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x40358b
    if (Locale == 0) {
        // 0x4035ce
        __writefsdword(0, v1);
        return 0;
    }
    int32_t result2; // 0x40343e
    if (((int32_t)a3 & 4) == 0) {
        // 0x4035e0
        function_403b40(Locale);
        if (v15 == 0) {
            // 0x4035ce
            __writefsdword(0, v1);
            return 0;
        }
        // 0x403618
        *(int32_t *)(v8 - 76) = Locale;
        *(int32_t *)(v8 - 80) = v15;
        *(int32_t *)(v8 - 84) = v13;
        *(int32_t *)(v8 - 88) = v12;
        *(int32_t *)(v8 - 92) = a2;
        *(int32_t *)(v8 - 96) = a1;
        int32_t v16 = LCMapStringW((int32_t)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x403626
        if (v16 == 0) {
            // 0x4035ce
            __writefsdword(0, v1);
            return 0;
        }
        // 0x403630
        *(int32_t *)(v8 - 100) = 0;
        *(int32_t *)(v8 - 104) = 0;
        int32_t * v17 = (int32_t *)(v8 - 108);
        int32_t v18; // 0x40343e
        if (a7 != 0) {
            // 0x40363b
            *v17 = a7;
            int32_t v19 = v8 - 112; // 0x40363e
            *(int32_t *)v19 = a6;
            v18 = v19;
        } else {
            // 0x403637
            *v17 = 0;
            int32_t v20 = v8 - 112; // 0x403638
            *(int32_t *)v20 = 0;
            v18 = v20;
        }
        // 0x403641
        *(int32_t *)(v18 - 4) = Locale;
        *(int32_t *)(v18 - 8) = v15;
        *(int32_t *)(v18 - 12) = 544;
        *(int32_t *)(v18 - 16) = v11;
        int32_t v21 = WideCharToMultiByte((int32_t)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (char *)&g80, (bool *)&g80); // 0x40364b
        result2 = v21;
        if (v21 == 0) {
            // 0x4035ce
            __writefsdword(0, v1);
            return 0;
        }
    } else {
        // 0x4035a0
        result2 = Locale;
        if (a7 != 0) {
            // 0x4035a9
            if (Locale > a7) {
                // 0x4035ce
                __writefsdword(0, v1);
                return 0;
            }
            // 0x4035ae
            *(int32_t *)(v8 - 76) = a7;
            *(int32_t *)(v8 - 80) = a6;
            *(int32_t *)(v8 - 84) = v13;
            *(int32_t *)(v8 - 88) = v12;
            *(int32_t *)(v8 - 92) = a2;
            *(int32_t *)(v8 - 96) = a1;
            int32_t v22 = LCMapStringW(Locale, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x4035be
            result2 = Locale;
            if (v22 == 0) {
                // 0x4035ce
                __writefsdword(0, v1);
                return 0;
            }
        }
    }
    // 0x4035ce
    __writefsdword(0, v1);
    return result2;
}

// Address range: 0x403662 - 0x40368d
int32_t function_403662(int32_t a1, int32_t result) {
    int32_t v1 = a1; // 0x403670
    int32_t v2 = result; // 0x403670
    int32_t v3 = a1; // 0x403670
    if (result != 0) {
        v3 = v1;
        while (*(char *)v1 != 0) {
            // 0x403677
            v2--;
            v1++;
            v3 = v1;
            if (v2 == 0) {
                // break -> 0x40367f
                break;
            }
            v3 = v1;
        }
    }
    // 0x40367f
    if (*(char *)v3 != 0) {
        // 0x40368a
        return result;
    }
    // 0x403685
    return v3 - a1;
}

// Address range: 0x40368d - 0x4037d6
int32_t function_40368d(int32_t a1, char * a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = __readfsdword(0); // bp-20, 0x4036a2
    __writefsdword(0, (int32_t)&v1);
    int32_t v2 = g53; // 0x4036bc
    int32_t v3; // bp-56, 0x40368d
    int32_t * v4 = &v3; // 0x4036bc
    if (g53 == 0) {
        int32_t v5 = 1; // bp-72, 0x4036cb
        int32_t lpCharType; // bp-32, 0x40368d
        bool v6 = GetStringTypeW(1, (int16_t *)&g2, 1, (int16_t *)&lpCharType); // 0x4036cc
        int32_t v7 = 1; // 0x4036d4
        v4 = &v5;
        if (!v6) {
            int32_t v8 = 0; // bp-92, 0x4036e5
            bool v9 = GetStringTypeA(0, 1, (char *)&g1, 1, (int16_t *)&lpCharType); // 0x4036e6
            v7 = 2;
            v4 = &v8;
            if (!v9) {
                // 0x4037c4
                __writefsdword(0, v1);
                return 0;
            }
        }
        // 0x4036f7
        v2 = v7;
        g53 = v2;
    }
    int32_t v10 = (int32_t)a4;
    int32_t v11 = (int32_t)v4;
    if (v2 == 2) {
        // 0x403701
        *(int32_t *)(v11 - 4) = v10;
        *(int32_t *)(v11 - 8) = a3;
        *(int32_t *)(v11 - 12) = (int32_t)a2;
        *(int32_t *)(v11 - 16) = a1;
        *(int32_t *)(v11 - 20) = a6 != 0 ? a6 : g50;
        bool result = GetStringTypeA((int32_t)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (int16_t *)&g80); // 0x40371a
        // 0x4037c4
        __writefsdword(0, v1);
        return result;
    }
    // 0x403725
    if (v2 != 1) {
        // 0x4037c4
        __writefsdword(0, v1);
        return 0;
    }
    int32_t v12 = a5 != 0 ? a5 : g51;
    *(int32_t *)(v11 - 4) = 0;
    *(int32_t *)(v11 - 8) = 0;
    *(int32_t *)(v11 - 12) = a3;
    int32_t v13 = (int32_t)a2; // 0x403740
    *(int32_t *)(v11 - 16) = v13;
    *(int32_t *)(v11 - 20) = a7 == 0 ? 1 : 9;
    int32_t v14 = v11 - 24; // 0x40374f
    *(int32_t *)v14 = v12;
    int32_t v15 = MultiByteToWideChar((int32_t)&g80, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x403752
    if (v15 == 0) {
        // 0x4037c4
        __writefsdword(0, v1);
        return 0;
    }
    // 0x40375f
    function_403b40(v15);
    int32_t * v16 = (int32_t *)(v11 - 28); // 0x403779
    *v16 = 2 * v15;
    int32_t * v17 = (int32_t *)(v11 - 32); // 0x40377a
    *v17 = 0;
    int32_t * v18 = (int32_t *)(v11 - 36); // 0x40377b
    *v18 = v14;
    function_403b70(v14, (int32_t)&g80, (int32_t)&g80);
    if (v14 == 0) {
        // 0x4037c4
        __writefsdword(0, v1);
        return 0;
    }
    // 0x403799
    *v16 = v15;
    *v17 = v14;
    *v18 = a3;
    *(int32_t *)(v11 - 40) = v13;
    *(int32_t *)(v11 - 44) = 1;
    *(int32_t *)(v11 - 48) = v12;
    int32_t v19 = MultiByteToWideChar(-1, (int32_t)&g80, (char *)&g80, (int32_t)&g80, (int16_t *)&g80, (int32_t)&g80); // 0x4037a8
    int32_t result2 = 0; // 0x4037b0
    if (v19 != 0) {
        // 0x4037b2
        *(int32_t *)(v11 - 52) = v10;
        *(int32_t *)(v11 - 56) = v19;
        *(int32_t *)(v11 - 60) = v14;
        *(int32_t *)(v11 - 64) = a1;
        bool v20 = GetStringTypeW((int32_t)&g80, (int16_t *)&g80, (int32_t)&g80, (int16_t *)&g80); // 0x4037ba
        result2 = v20;
    }
    // 0x4037c4
    __writefsdword(0, v1);
    return result2;
}

// Address range: 0x4037d6 - 0x4037f1
int32_t __callnewh(int32_t a1) {
    // 0x4037d6
    return g54 != 0;
}

// Address range: 0x403800 - 0x403b35
int32_t function_403800(int32_t result5, uint32_t a2, uint32_t a3) {
    int32_t result3 = a3 + a2; // 0x403812
    int32_t v1; // 0x403800
    int32_t v2; // 0x403800
    int32_t v3; // 0x403800
    int32_t v4; // 0x403800
    int32_t v5; // 0x403800
    int32_t result6; // 0x403800
    int32_t v6; // 0x403800
    int32_t v7; // 0x403800
    int32_t v8; // 0x403800
    int32_t v9; // 0x403800
    int32_t v10; // 0x403800
    int32_t v11; // 0x403800
    int32_t result2; // 0x403800
    int32_t result; // 0x403800
    if (result5 > a2 == result3 > result5) {
        int32_t v12 = a3 - 4; // 0x403998
        int32_t v13 = v12 + a2; // 0x403998
        int32_t v14 = v12 + result5; // 0x40399c
        int32_t v15 = v14 & 3; // 0x4039a0
        if (v15 != 0) {
            // 0x4039cc
            g79 = a3;
            result2 = v15;
            result = result5;
            v9 = v13;
            v6 = v14;
            v10 = v13;
            v7 = v14;
            v11 = v13;
            v8 = v14;
            switch (a3) {
                case 0: {
                    return result;
                }
                case 1: {
                    goto lab_0x403af8;
                }
                case 2: {
                    goto lab_0x403b08;
                }
                case 3: {
                    goto lab_0x403b1c;
                }
                default: {
                    return result2;
                }
            }
        } else {
            int32_t v16 = -((a3 / 4));
            g78 = v16;
            if (a3 < 4) {
                // 0x403848
                return result3;
            }
            int32_t v17 = a3 & 3; // 0x4039ab
            __asm_rep_movsd_memcpy((char *)v14, (char *)v13, v16);
            int32_t v18 = v14 + (a3 & -4); // 0x4039b4
            g77 = v17;
            result = result5;
            v9 = v18;
            v6 = v18;
            v10 = v18;
            v7 = v18;
            v11 = v18;
            v8 = v18;
            switch (v17) {
                case 0: {
                    return result;
                }
                case 1: {
                    goto lab_0x403af8;
                }
                case 2: {
                    goto lab_0x403b08;
                }
                case 3: {
                    goto lab_0x403b1c;
                }
                default: {
                    // 0x4039c02
                    // UNREACHABLE
                }
            }
        }
    } else {
        int32_t result4 = result5 & 3; // 0x403820
        if (result4 != 0) {
            // 0x40383c
            result = result5;
            if (a3 >= 4) {
                // 0x403848
                return result4;
            }
            // 0x403848
            return result;
        }
        int32_t v19 = a3 / 4; // 0x403828
        g87 = v19;
        result = result3;
        switch (v19) {
            case 0: {
                return result;
            }
            case 1: {
                // 0x403828
                result6 = a3 & -4;
                goto lab_0x40392c;
            }
            case 2: {
                // 0x403828
                v3 = a3 & -4;
                goto lab_0x403924;
            }
            case 3: {
                // 0x403828
                v4 = a3 & -4;
                goto lab_0x40391c;
            }
            case 4: {
                // 0x403828
                v5 = a3 & -4;
                goto lab_0x403914;
            }
            case 5: {
                // 0x403828
                v1 = a3 & -4;
                goto lab_0x40390c;
            }
            case 6: {
                // 0x403828
                v2 = a3 & -4;
                goto lab_0x403904;
            }
            case 7: {
                int32_t v20 = a3 & -4;
                int32_t v21 = v20 - 28;
                *(int32_t *)(v21 + result5) = *(int32_t *)(v21 + a2);
                v2 = v20;
                goto lab_0x403904;
            }
            default: {
                int32_t v22 = a3 & 3; // 0x40382b
                __asm_rep_movsd_memcpy((char *)result5, (char *)a2, v19);
                g86 = v22;
                result2 = result5;
                if (v22 < 2) {
                    // 0x403848
                    return result5;
                }
                // 0x403848
                return result2;
            }
        }
    }
  lab_0x403af8:
    // 0x403af8
    *(char *)(v6 + 3) = *(char *)(v9 + 3);
    return result5;
  lab_0x403b08:
    // 0x403b08
    *(char *)(v7 + 3) = *(char *)(v10 + 3);
    *(char *)(v7 + 2) = *(char *)(v10 + 2);
    return result5;
  lab_0x403b1c:
    // 0x403b1c
    *(char *)(v8 + 3) = *(char *)(v11 + 3);
    *(char *)(v8 + 2) = *(char *)(v11 + 2);
    *(char *)(v8 + 1) = *(char *)(v11 + 1);
    return result5;
  lab_0x40392c:;
    int32_t v23 = result6 - 4;
    *(int32_t *)(v23 + result5) = *(int32_t *)(v23 + a2);
    // 0x403848
    return result6;
  lab_0x403924:;
    int32_t v24 = v3 - 8;
    *(int32_t *)(v24 + result5) = *(int32_t *)(v24 + a2);
    result6 = v3;
    goto lab_0x40392c;
  lab_0x40391c:;
    int32_t v25 = v4 - 12;
    *(int32_t *)(v25 + result5) = *(int32_t *)(v25 + a2);
    v3 = v4;
    goto lab_0x403924;
  lab_0x403914:;
    int32_t v26 = v5 - 16;
    *(int32_t *)(v26 + result5) = *(int32_t *)(v26 + a2);
    v4 = v5;
    goto lab_0x40391c;
  lab_0x40390c:;
    int32_t v27 = v1 - 20;
    *(int32_t *)(v27 + result5) = *(int32_t *)(v27 + a2);
    v5 = v1;
    goto lab_0x403914;
  lab_0x403904:;
    int32_t v28 = v2 - 24;
    *(int32_t *)(v28 + result5) = *(int32_t *)(v28 + a2);
    v1 = v2;
    goto lab_0x40390c;
}

// Address range: 0x403b40 - 0x403b6f
int32_t function_403b40(int32_t result) {
    // 0x403b40
    int32_t v1; // 0x403b40
    int32_t v2 = &v1; // 0x403b46
    int32_t v3 = v2; // 0x403b4a
    int32_t v4; // 0x403b40
    if ((uint32_t)v4 < 0x1000) {
        // 0x403b60
        int32_t v5; // 0x403b40
        *(int32_t *)(-4 - v5 + v2) = result;
        return result;
    }
    v3 -= 0x1000;
    int32_t v6; // 0x403b40
    int32_t v7 = v6 - 0x1000; // 0x403b52
    while (v7 >= 0x1000) {
        // 0x403b4c
        v3 -= 0x1000;
        v7 -= 0x1000;
    }
    // 0x403b60
    *(int32_t *)(-4 - v7 + v3) = result;
    return result;
}

// Address range: 0x403b70 - 0x403bc8
int32_t function_403b70(int32_t result, int32_t a2, int32_t a3) {
    // 0x403b70
    if (a3 == 0) {
        // 0x403bbd
        return result;
    }
    int32_t v1 = a2 & 255;
    int32_t v2 = v1; // 0x403b88
    int32_t v3 = a3; // 0x403b88
    int32_t v4 = result; // 0x403b88
    if (a3 >= 4) {
        int32_t v5 = -result & 3; // 0x403b8c
        int32_t v6 = a3; // 0x403b8f
        int32_t v7 = result; // 0x403b8f
        if (v5 != 0) {
            int32_t v8 = v5; // 0x403b91
            *(char *)result = (char)a2;
            int32_t v9 = result + 1; // 0x403b95
            v8--;
            int32_t v10 = v9; // 0x403b97
            while (v8 != 0) {
                // 0x403b93
                *(char *)v10 = (char)a2;
                v9 = v10 + 1;
                v8--;
                v10 = v9;
            }
            // 0x403b99
            v6 = a3 - v5;
            v7 = v9;
        }
        int32_t v11 = 0x1010101 * v1; // 0x403ba5
        int32_t v12 = v6 & 3; // 0x403ba9
        v2 = v11;
        v3 = v12;
        v4 = v7;
        if (v6 >= 4) {
            uint32_t v13 = v6 / 4; // 0x403bac
            __asm_rep_stosd_memset((char *)v7, v11, v13);
            v2 = v11;
            v3 = v12;
            bool v14; // 0x403b70
            v4 = v13 * (v14 ? -4 : 4) + v7;
            if (v12 == 0) {
                // 0x403bbd
                return result;
            }
        }
    }
    int32_t v15 = v3; // 0x403bba
    int32_t v16 = v4; // 0x403b70
    *(char *)v16 = (char)v2;
    v15--;
    v16++;
    while (v15 != 0) {
        // 0x403bb7
        *(char *)v16 = (char)v2;
        v15--;
        v16++;
    }
    // 0x403bbd
    return result;
}

// Address range: 0x403bc8 - 0x403bce
void _RtlUnwind_40_16(int32_t * TargetFrame, int32_t * TargetIp, struct _EXCEPTION_RECORD * ExceptionRecord, int32_t * ReturnValue) {
    // 0x403bc8
    RtlUnwind(TargetFrame, TargetIp, ExceptionRecord, ReturnValue);
}

// Address range: 0x287afb7 - 0x287afb8
int32_t function_287afb7(void) {
    // 0x287afb7
    int32_t result; // 0x287afb7
    return result;
}

// Address range: 0x287c087 - 0x287c088
int32_t function_287c087(void) {
    // 0x287c087
    int32_t result; // 0x287c087
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t __amsg_exit(void);
// int32_t __global_unwind2(void);
// int32_t __local_unwind2(void);
// int32_t __NLG_Notify(void);
// void * malloc(size_t size);

// --------------- Dynamically Linked Functions ---------------

// HDC BeginPaint(_In_ HWND hWnd, _Out_ LPPAINTSTRUCT lpPaint);
// HWND CreateWindowExA(_In_ DWORD dwExStyle, _In_opt_ LPCSTR lpClassName, _In_opt_ LPCSTR lpWindowName, _In_ DWORD dwStyle, _In_ int X, _In_ int Y, _In_ int nWidth, _In_ int nHeight, _In_opt_ HWND hWndParent, _In_opt_ HMENU hMenu, _In_opt_ HINSTANCE hInstance, _In_opt_ LPVOID lpParam);
// LRESULT DefWindowProcA(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL DestroyWindow(_In_ HWND hWnd);
// INT_PTR DialogBoxParamA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpTemplateName, _In_opt_ HWND hWndParent, _In_opt_ DLGPROC lpDialogFunc, _In_ LPARAM dwInitParam);
// LRESULT DispatchMessageA(_In_ const MSG * lpMsg);
// int DrawTextA(_In_ HDC hdc, LPCSTR lpchText, _In_ int cchText, _Inout_ LPRECT lprc, _In_ UINT format);
// BOOL EndDialog(_In_ HWND hDlg, _In_ INT_PTR nResult);
// BOOL EndPaint(_In_ HWND hWnd, _In_ const PAINTSTRUCT * lpPaint);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FreeEnvironmentStringsA(_In_ LPCH penv);
// BOOL FreeEnvironmentStringsW(_In_ LPWCH penv);
// BOOL GetClientRect(_In_ HWND hWnd, _Out_ LPRECT lpRect);
// LPSTR GetCommandLineA(VOID);
// BOOL GetCPInfo(_In_ UINT CodePage, _Out_ LPCPINFO lpCPInfo);
// HANDLE GetCurrentProcess(VOID);
// LPCH GetEnvironmentStrings(VOID);
// LPWCH GetEnvironmentStringsW(void);
// DWORD GetFileType(_In_ HANDLE hFile);
// BOOL GetMessageA(_Out_ LPMSG lpMsg, _In_opt_ HWND hWnd, _In_ UINT wMsgFilterMin, _In_ UINT wMsgFilterMax);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// HMODULE GetModuleHandleA(_In_opt_ LPCSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// VOID GetStartupInfoA(_Out_ LPSTARTUPINFOA lpStartupInfo);
// HANDLE GetStdHandle(_In_ DWORD nStdHandle);
// BOOL GetStringTypeA(_In_ LCID Locale, _In_ DWORD dwInfoType, LPCSTR lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType);
// BOOL GetStringTypeW(_In_ DWORD dwInfoType, LPCWCH lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType);
// NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion(VOID);
// LPVOID HeapAlloc(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ SIZE_T dwBytes);
// HANDLE HeapCreate(_In_ DWORD flOptions, _In_ SIZE_T dwInitialSize, _In_ SIZE_T dwMaximumSize);
// BOOL HeapDestroy(_In_ HANDLE hHeap);
// BOOL HeapFree(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem);
// LPVOID HeapReAlloc(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem, _In_ SIZE_T dwBytes);
// int LCMapStringA(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCSTR lpSrcStr, _In_ int cchSrc, LPSTR lpDestStr, _In_ int cchDest);
// int LCMapStringW(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCWSTR lpSrcStr, _In_ int cchSrc, LPWSTR lpDestStr, _In_ int cchDest);
// HACCEL LoadAcceleratorsA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpTableName);
// HCURSOR LoadCursorA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpCursorName);
// HICON LoadIconA(_In_opt_ HINSTANCE hInstance, _In_ LPCSTR lpIconName);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// int LoadStringA(_In_opt_ HINSTANCE hInstance, _In_ UINT uID, LPSTR lpBuffer, _In_ int cchBufferMax);
// int MultiByteToWideChar(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCCH lpMultiByteStr, _In_ int cbMultiByte, LPWSTR lpWideCharStr, _In_ int cchWideChar);
// VOID PostQuitMessage(_In_ int nExitCode);
// ATOM RegisterClassExA(_In_ const WNDCLASSEXA *);
// VOID RtlUnwind(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue);
// UINT SetHandleCount(_In_ UINT uNumber);
// BOOL ShowWindow(_In_ HWND hWnd, _In_ int nCmdShow);
// BOOL TerminateProcess(_In_ HANDLE hProcess, _In_ UINT uExitCode);
// int TranslateAcceleratorA(_In_ HWND hWnd, _In_ HACCEL hAccTable, _In_ LPMSG lpMsg);
// BOOL TranslateMessage(_In_ const MSG * lpMsg);
// LONG UnhandledExceptionFilter(_In_ struct _EXCEPTION_POINTERS * ExceptionInfo);
// BOOL UpdateWindow(_In_ HWND hWnd);
// LPVOID VirtualAlloc(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// BOOL VirtualFree(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType);
// int WideCharToMultiByte(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCWCH lpWideCharStr, _In_ int cchWideChar, LPSTR lpMultiByteStr, _In_ int cbMultiByte, _In_opt_ LPCCH lpDefaultChar, _Out_opt_ LPBOOL lpUsedDefaultChar);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (6.0)
// Detected functions: 59

