// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 * g_ptr21A48 = null; // 00021A48
word32 objects = 0x00; // 00021A60
ptr32 _environ = 0x00; // 00021A64
// subject_ctors.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

char g_str218E8[] = ""; // 000218E8
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 000116A8: void _fini(Register word32 o2, Register word32 o3, Register word32 o4, Register word32 o5)
void _fini(word32 o2, word32 o3, word32 o4, word32 o5)
{
	__do_global_dtors_aux(o2, o3, o4, o5);
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_43 g_t2175C = // 0002175C
	{
		&g_t11748,
	};
word32 ** g_ptr21760 = &g_ptr21A48; // 00021760
struct Eq_55 * g_ptr21764 = &g_t11748; // 00021764
struct Eq_97 * g_ptr21768 = &g_t11750; // 00021768
char * g_ptr2176C = &g_str21A60; // 0002176C
char * g_ptr21770 = &g_str218E8; // 00021770
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0001168C: Register word32 _init()
// Called from:
//      _start
word32 _init()
{
	word32 o3_32;
	word32 o4_33;
	word32 o5_34;
	return __do_global_ctors_aux(frame_dummy(out o3_32, out o4_33, out o5_34), o3_32, o4_33, o5_34);
}

// subject_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_97 ** g_ptr21774 = null; // 00021774
struct Eq_1174 * g_ptr21778 = null; // 00021778
// 000217A4: void atexit()
void atexit()
{
}

// 000217B0: void exit()
void exit()
{
}

// 000217BC: void _exit()
void _exit()
{
}

// 000217C8: void printf()
void printf()
{
}

// 000217D4: void malloc()
void malloc()
{
}

// 000217E0: void strcmp()
void strcmp()
{
}

// 000217EC: void strlen()
void strlen()
{
}

// 000217F8: void .umul()
void .umul()
{
}

// 00021804: void memcpy()
void memcpy()
{
}

// 00021810: void free()
void free()
{
}

// 0002181C: void abort()
void abort()
{
}

// 00021828: void memset()
void memset()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 _lib_version = 0x01; // 000116C0
Eq_55 g_t11748 = // 00011748
	{
		0x00,
		0x00,
		?? /* Can't read word32 at address 00011750 */ ,
		?? /* Can't read up32 at address 00011754 */ ,
	};
Eq_97 g_t11750 = // 00011750
	{
		?? /* Can't read word32 at address 00011750 */ ,
		?? /* Can't read word32 at address 00011754 */ ,
		,
		?? /* Can't read word32 at address 0001175C */ ,
		?? /* Can't read uint32 at address 00011760 */ ,
		,
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00010940: void _start(Register (ptr32 Eq_2) g1, Register word32 q0_32_96)
void _start(void (* g1)(), word32 q0_32_96)
{
	ptr32 fp;
	if (g1 == null)
	{
		atexit(&g_t116A8);
		_environ = fp + 0x44 + ((_init() << 0x02) + 0x04);
		exit(main(q0_32_96));
	}
	else
		atexit(g1);
}

// 000109B4: void __do_global_dtors_aux(Register word32 o2, Register word32 o3, Register word32 o4, Register word32 o5)
// Called from:
//      _fini
void __do_global_dtors_aux(word32 o2, word32 o3, word32 o4, word32 o5)
{
	word32 ** o1_27 = g_ptr21760;
	struct Eq_43 * l7_23 = &g_t2175C;
	if (**o1_27 != 0x00)
	{
		word32 ** l0_35 = o1_27;
		word32 * o0_36 = *o1_27;
		while (true)
		{
			struct Eq_65 * o0_38 = o0_36 + 1;
			*l0_35 = (word32 **) o0_38;
			<anonymous> * o0_41 = o0_38->ptrFFFFFFFC;
			o0_41();
			if (**l0_35 == 0x00)
				break;
			o0_36 = *l0_35;
		}
	}
	__deregister_frame_info(l7_23->ptr0008);
}

// 00010A30: void fini_dummy()
void fini_dummy()
{
}

// 00010A3C: Register word32 frame_dummy(Register out ptr32 o3Out, Register out ptr32 o4Out, Register out ptr32 o5Out)
// Called from:
//      _init
word32 frame_dummy(ptr32 & o3Out, ptr32 & o4Out, ptr32 & o5Out)
{
	ptr32 i3_34;
	ptr32 i4_35;
	ptr32 i5_36;
	word32 o2_42 = __register_frame_info(g_ptr21764, g_ptr21768, out i3_34, out i4_35, out i5_36);
	o3Out = i3_34;
	o4Out = i4_35;
	o5Out = i5_36;
	return o2_42;
}

// 00010A74: void init_dummy()
void init_dummy()
{
}

// 00010A80: Register int32 interleaved(Register int32 o0, Register word32 o1, Register word32 q0_32_96, Register out Eq_112 q0Out)
// Called from:
//      main
int32 interleaved(int32 o0, word32 o1, word32 q0_32_96, union Eq_112 & q0Out)
{
interleaved_entry:
	branch o1 != q0_32_96 l00010AB4
	goto l00010AA4
l00010A80:
l00010AA4:
	branch o0 >= 0x00 l00010AA8_ds_t
l00010AA8_ds_f:
	branch o0 >= 0x00 l00010AB8_ds_t
l00010AA8_ds_t:
	o0 = 0x02
	goto l00010AC4
l00010AAC:
l00010AB4:
	branch o0 >= 0x00 l00010AB8_ds_t
l00010AB8_ds_f:
	goto l00010ABC
l00010AB8_ds_f:
	goto l00010ABC
l00010AB8_ds_t:
	goto l00010AC0
l00010AB8_ds_t:
	goto l00010AC0
l00010ABC:
l00010AC0:
	o0 = 0x00
l00010AC4:
	q0Out.u1 = <invalid>
	return o0
interleaved_exit:
}

// 00010ACC: Register word32 main(Register word32 q0_32_96)
// Called from:
//      _start
word32 main(word32 q0_32_96)
{
	word128 q0_28;
	printf("Call with  1, 2.0, 3.0: %d\n", interleaved(0x01, 0x40000000, q0_32_96, out q0_28));
	word128 q0_47;
	printf("Call with -1, 2.0, 3.0: %d\n", interleaved(~0x00, 0x40000000, SLICE(q0_28, word32, 96), out q0_47));
	word128 q0_66;
	printf("Call with  1, 2.0, 2.0: %d\n", interleaved(0x01, 0x40000000, SLICE(q0_47, word32, 96), out q0_66));
	word128 q0_108;
	printf("Call with -1, 2.0, 2.0: %d\n", interleaved(~0x00, 0x40000000, SLICE(q0_66, word32, 96), out q0_108));
	return 0x00;
}

// 00010B70: Register (ptr32 byte) decode_uleb128(Register (ptr32 byte) o0, Register (ptr32 ui32) o1)
// Called from:
//      extract_cie_info
//      execute_cfa_insn
//      __frame_state_for
byte * decode_uleb128(byte * o0, ui32 * o1)
{
	word32 o2_10 = 0x00;
	ui32 o3_15 = 0x00;
	while (true)
	{
		ui32 g3_7 = (ui32) *o0;
		++o0;
		ui32 g2_11 = (g3_7 & 0x7F) << o2_10;
		if ((g3_7 & 0x80) == 0x00)
			break;
		o3_15 |= g2_11;
		o2_10 += 0x07;
	}
	ui32 o3_16 = o3_15 | g2_11;
	*o1 = o3_16;
	return o0;
}

// 00010BA4: Register (ptr32 byte) decode_sleb128(Register (ptr32 byte) o0, Register (ptr32 ui32) o1)
// Called from:
//      extract_cie_info
byte * decode_sleb128(byte * o0, ui32 * o1)
{
	word32 g3_10 = 0x00;
	ui32 o2_12 = 0x00;
	while (true)
	{
		ui32 o3_7 = (ui32) *o0;
		++o0;
		o2_12 |= (o3_7 & 0x7F) << g3_10;
		if ((o3_7 & 0x80) == 0x00)
			break;
		g3_10 += 0x07;
	}
	up32 g3_18 = g3_10 + 0x07;
	if (g3_18 < 0x1F && (o3_7 & 0x40) != 0x00)
		o2_12 |= ~0x00 << g3_18;
	*o1 = o2_12;
	return o0;
}

// 00010BF0: void fde_insert(Register (arr (ptr32 Eq_55)) o0, Register ui32 o1, Register (ptr32 Eq_55) o2)
// Called from:
//      add_fdes
void fde_insert(struct Eq_55 * o0[], ui32 o1, struct Eq_55 * o2)
{
	if (o1 != 0x00)
	{
		o0[o1] = o2;
		struct Eq_245 * o0_12 = o0 + (o1 << 0x02) / 4;
		while (true)
		{
			struct Eq_259 * o3_15 = o0_12->dw0000;
			struct Eq_255 * o2_16 = o0_12->dwFFFFFFFC;
			if (o3_15->dw0008 >= o2_16->dw0008)
				break;
			o1 += ~0x00;
			o0_12->dw0000 = o2_16;
			o0_12->dwFFFFFFFC = o3_15;
			if (o1 == 0x00)
				return;
			o0_12 = (struct Eq_245 *) &o0_12->dwFFFFFFFC;
		}
	}
	else
		o0[o1] = o2;
}

// 00010C38: Register (ptr32 Eq_55) count_fdes(Register (ptr32 Eq_55) o0)
// Called from:
//      frame_init
struct Eq_55 * count_fdes(struct Eq_55 * o0)
{
	struct Eq_55 * o1_21 = null;
	if (o0->dw0000 != 0x00)
	{
		while (true)
		{
			int32 g2_16;
			if (o0[1] != 0x00)
			{
				if (o0[2] != 0x00)
					o1_21 = (struct Eq_55 *) ((char *) &o1_21->dw0000 + 1);
				g2_16 = o0->dw0000;
			}
			else
				g2_16 = o0->dw0000;
			struct Eq_296 * g2_28 = o0 + g2_16 / 4;
			if (g2_28->dw0004 == 0x00)
				break;
			o0 = (struct Eq_55 *) &g2_28->dw0004;
		}
	}
	return o1_21;
}

// 00010C8C: Register ui32 add_fdes(Register (ptr32 Eq_55) o0, Register (ptr32 (arr (ptr32 Eq_55))) o1, Register (ptr32 ui32) o2, Register (ptr32 word32) o3, Register (ptr32 word32) o4, Register out (ptr32 void) l1Out, Register out (ptr32 Eq_55) i0Out, Register out (ptr32 Eq_326) i6Out)
// Called from:
//      frame_init
ui32 add_fdes(struct Eq_55 * o0, struct Eq_55 * (* o1)[], ui32 * o2, word32 * o3, word32 * o4, void & l1Out, struct Eq_55 & i0Out, struct Eq_326 & i6Out)
{
	struct Eq_326 * fp;
	void * l1_109;
	struct Eq_55 * i0_118 = o0;
	ui32 l0_21 = *o2;
	up32 l2_100 = *o3;
	if (o0->dw0000 != 0x00)
	{
		l1_109 = *o4;
		while (true)
		{
			int32 o0_35;
			if (i0_118[1] != 0x00)
			{
				if (i0_118[2] != 0x00)
				{
					fde_insert(o1, l0_21, i0_118);
					up32 o1_57 = i0_118[2];
					if (o1_57 < l2_100)
					{
						++l0_21;
						l2_100 = o1_57;
					}
					else
						++l0_21;
					void * o0_69 = (word32) i0_118[3].dw0000 + o1_57;
					if (o0_69 >= l1_109)
						l1_109 = o0_69;
				}
				o0_35 = i0_118->dw0000;
			}
			else
				o0_35 = i0_118->dw0000;
			struct Eq_364 * o0_81 = i0_118 + o0_35 / 4;
			if (o0_81->dw0004 == 0x00)
				break;
			i0_118 = (struct Eq_55 *) &o0_81->dw0004;
		}
		i0_118 = (struct Eq_55 *) &o0_81->dw0004;
	}
	else
		l1_109 = *o4;
	*o2 = l0_21;
	*o3 = l2_100;
	*o4 = l1_109;
	l1Out = l1_109;
	i0Out = i0_118;
	i6Out = fp;
	return l0_21;
}

// 00010D28: Register (ptr32 Eq_402) frame_init(Register (ptr32 Eq_97) o0, Register out (ptr32 (arr (ptr32 Eq_55))) l1Out, Register out (ptr32 Eq_405) i6Out)
// Called from:
//      find_fde
struct Eq_402 * frame_init(struct Eq_97 * o0, struct Eq_55 * (& l1Out, struct Eq_405 & i6Out)
{
	struct Eq_405 * fp;
	Eq_407 tLoc1C;
	Eq_408 tLoc18;
	Eq_409 tLoc14;
	uint32 o0_37;
	struct Eq_97 * i0_130 = o0;
	struct Eq_405 * i6_101 = fp;
	struct Eq_402 * o0_21 = o0[3];
	if (o0_21 != null)
	{
		struct Eq_402 * l0_38 = o0_21;
		tLoc14 = (Eq_409) 0x00;
		if (o0_21->dw0000 != 0x00)
		{
			do
			{
				tLoc14 = (Eq_409) ((word32) tLoc14 + count_fdes(l0_38->dw0000));
				++l0_38;
			} while (l0_38->dw0000 != 0x00);
			o0_37 = (uint32) tLoc14;
			o0[4] = (struct Eq_97) o0_37;
l00010D94:
			struct Eq_402 * l0_103;
			word32 o1_111;
			struct Eq_55 * (* l1_104)[];
			struct Eq_55 * (* o0_76)[] = malloc((size_t) (o0_37 << 0x02));
			tLoc18 = (Eq_408) ~0x00;
			tLoc1C = (Eq_407) 0x00;
			tLoc14 = (Eq_409) 0x00;
			struct Eq_402 * o1_84 = o0[3];
			if (o1_84 != null)
			{
				l1_104 = o0_76;
				l0_103 = o1_84;
				if (o1_84->dw0000 != 0x00)
				{
					struct Eq_55 * (* o1_120)[] = o0_76;
					while (true)
					{
						struct Eq_402 * l0_138 = add_fdes(l0_103->dw0000, o1_120, &i6_101->dwFFFFFFE8 + 1, &i6_101->dwFFFFFFE8, &i6_101->dwFFFFFFE4, out l1_104, out i0_130, out i6_101);
						l0_103 = l0_138 + 1;
						if (l0_138[1] == 0x00)
							break;
						o1_120 = l1_104;
					}
					o1_111 = i6_101->dwFFFFFFE8;
				}
				else
					o1_111 = (word32) tLoc18;
			}
			else
			{
				l0_103 = add_fdes(o0[2], o0_76, &tLoc14, &tLoc18, &tLoc1C, out l1_104, out i0_130, out i6_101);
				o1_111 = i6_101->dwFFFFFFE8;
			}
			i0_130[3] = (struct Eq_97) l1_104;
			word32 o0_158 = i6_101->dwFFFFFFE4;
			i0_130->dw0000 = o1_111;
			i0_130[1] = (struct Eq_97) o0_158;
			l1Out = l1_104;
			i6Out = i6_101;
			return l0_103;
		}
		o0_37 = (uint32) tLoc14;
	}
	else
	{
		tLoc14 = (Eq_409) count_fdes(o0[2]);
		o0_37 = (uint32) tLoc14;
	}
	o0[4] = (struct Eq_97) o0_37;
	goto l00010D94;
}

// 00010E38: Register (ptr32 Eq_573) find_fde(Register (ptr32 Eq_573) o0, Register out ptr32 i6Out)
// Called from:
//      __frame_state_for
struct Eq_573 * find_fde(struct Eq_573 * o0, ptr32 & i6Out)
{
	ptr32 fp;
	struct Eq_573 * l1_205;
	struct Eq_97 * l0_105 = *g_ptr21774;
	ptr32 i6_16 = fp;
	bool v33_207 = l0_105 == null;
	if (l0_105 == null)
	{
		l1_205 = o0;
		goto l00010EB4;
	}
	l1_205 = o0;
	struct Eq_573 * o0_34 = l0_105->dw0000;
	while (true)
	{
		bool v37_211;
		if (o0_34 == null)
		{
			l0_105 = frame_init(l0_105, out l1_205, out i6_16);
			v37_211 = l1_205 < l0_105->dw0000;
		}
		else
			v37_211 = l1_205 < o0_34;
		if (!v37_211)
		{
			if (l1_205 < l0_105[1])
			{
				v33_207 = l0_105 == null;
				goto l00010EB4;
			}
			l0_105 = (struct Eq_97 *) l0_105[5];
		}
		else
			l0_105 = (struct Eq_97 *) l0_105[5];
		if (l0_105 == null)
		{
			v33_207 = l0_105 == null;
l00010EB4:
			struct Eq_573 * i0_103;
			if (v33_207)
			{
				i0_103 = null;
				goto l00010F18;
			}
			i0_103 = null;
			uint32 o4_107 = l0_105[4];
			uint32 o3_108 = 0x00;
			if (o4_107 <= 0x00)
				goto l00010F18;
			uint32 o0_113 = o4_107;
			struct Eq_573 * o5_114[] = l0_105[3];
			while (true)
			{
				uint32 o2_116 = o0_113 >> 0x01;
				i0_103 = o5_114[o2_116];
				struct Eq_573 * o1_121 = i0_103->ptr0008;
				if (l1_205 < o1_121)
					o4_107 = o2_116;
				else
				{
					up32 o0_126 = i0_103->dw000C;
					if (l1_205 <= o1_121 + o0_126 / 16)
						goto l00010F18;
					o3_108 = o2_116 + 0x01;
				}
				if (o3_108 >= o4_107)
					break;
				o0_113 = o3_108 + o4_107;
			}
			i0_103 = null;
l00010F18:
			i6Out = i6_16;
			return i0_103;
		}
		o0_34 = l0_105->dw0000;
	}
}

// 00010F20: Register (ptr32 Eq_662) extract_cie_info(Register (ptr32 Eq_662) o0, Register (ptr32 Eq_663) o1, Register out (ptr32 Eq_662) i0Out, Register out (ptr32 Eq_663) i1Out, Register out ptr32 i6Out)
// Called from:
//      __frame_state_for
struct Eq_662 * extract_cie_info(struct Eq_662 * o0, struct Eq_663 * o1, struct Eq_662 & i0Out, struct Eq_663 & i1Out, ptr32 & i6Out)
{
	ptr32 fp;
	Eq_668 tLoc14;
	struct Eq_662 * i0_116;
	char * o1_27 = g_ptr2176C;
	word32 o0_30 = o0 - o0->dw0004;
	o1->ptr0000 = o0_30 + 0x0D;
	if (strcmp(o0_30 + 0x0D, o1_27) != 0x00 && (strcmp(o1->ptr0000, g_ptr21770) != 0x00 && (int32) (*o1->ptr0000) != 122))
		i0_116 = null;
	else
	{
		uint32 o0_56 = (uint32) strlen(o1->ptr0000);
		char * o2_58 = o1->ptr0000;
		struct Eq_704 * l0_62 = o2_58 + o0_56;
		byte * i0_63 = &l0_62->b0001;
		if (strcmp(o2_58, g_ptr21770) == 0x00)
		{
			o1->dw0004 = (ui32) l0_62->b0004 | ((ui32) l0_62->b0003 << 0x08 | ((ui32) l0_62->b0002 << 0x10 | (ui32) l0_62->b0001 << 0x18));
			i0_63 = (byte *) (&l0_62->b0004 + 1);
		}
		else
			o1->dw0004 = 0x00;
		byte * o0_100 = decode_sleb128(decode_uleb128(i0_63, &o1->dw0004 + 1), &o1->dw0004 + 2);
		char * o1_110 = o1->ptr0000;
		o1->dw0010 = (ui32) *o0_100;
		if ((int32) *o1_110 == 122)
			i0_116 = decode_uleb128(o0_100 + 1, &tLoc14) + Mem111[&tLoc14 + 0x00:word32];
		else
			i0_116 = (struct Eq_662 *) (o0_100 + 1);
	}
	i0Out = i0_116;
	i1Out = o1;
	i6Out = fp;
	return i0_116;
}

// 00011048: Register (ptr32 byte) execute_cfa_insn(Register (ptr32 byte) o0, Register (ptr32 void) o1, Register (ptr32 Eq_814) o2, Register out (ptr32 byte) i0Out, Register out (ptr32 void) i1Out, Register out (ptr32 Eq_817) i6Out)
// Called from:
//      __frame_state_for
byte * execute_cfa_insn(byte * o0, void * o1, struct Eq_814 * o2, byte & i0Out, void & i1Out, struct Eq_817 & i6Out)
{
	struct Eq_817 * fp;
	Eq_819 tLoc14;
	byte * i0_121;
	void * i1_101 = o1;
	struct Eq_817 * i6_111 = fp;
	uint32 o2_21 = (ui32) *o0;
	if ((o2_21 & 0x40) != 0x00)
		*i3_105 += .umul(o2_21 & 0x3F, o2->dw0008);
	else
	{
		i0_121 = o0 + 1;
		if ((o2_21 & 0x80) != 0x00)
		{
			decode_uleb128(o0 + 1, &tLoc14);
			i6_111->dwFFFFFFEC = .umul(tLoc14, o2->dw000C);
			((char *) i1_101 + (i6_111->tFFFFFFE8).u0)[428] = 0x01;
			Eq_878 o0_o1_89 = i6_111->tFFFFFFE8.u1;
			((char *) i1_101 + (SLICE(o0_o1_89, word32, 32) << 0x02))[16] = (char) (word32) o0_o1_89;
		}
		else
		{
			if ((o2_21 & 0xC0) == 0x00)
			{
				if (o2_21 >= 0x2E)
					abort();
				else
				{
					byte * o0_40 = *((char *) g_a110D0 + o2_21 * 0x04);
					i0Out = o0 + 1;
					i1Out = o1;
					i6Out = fp;
					return o0_40;
				}
			}
			((char *) o1 + (o2_21 & 0x3F))[428] = 0x00;
		}
	}
	i0Out = i0_121;
	i1Out = i1_101;
	i6Out = i6_111;
	return i0_121;
}

byte * g_a110D0[] = // 000110D0
	{
	};
// 000113F4: Register word32 __register_frame_info(Register (ptr32 Eq_55) o0, Register (ptr32 Eq_97) o1, Register out ptr32 i3Out, Register out ptr32 i4Out, Register out ptr32 i5Out)
// Called from:
//      frame_dummy
word32 __register_frame_info(struct Eq_55 * o0, struct Eq_97 * o1, ptr32 & i3Out, ptr32 & i4Out, ptr32 & i5Out)
{
	word32 o2;
	ptr32 o3;
	ptr32 o4;
	ptr32 o5;
	o1[2] = (struct Eq_97) o0;
	o1[1] = (struct Eq_97) 0x00;
	o1->dw0000 = 0x00;
	struct Eq_97 ** o1_28 = g_ptr21774;
	o1[3] = (struct Eq_97) null;
	struct Eq_97 * o0_30 = *o1_28;
	o1[4] = (struct Eq_97) 0x00;
	o1[5] = (struct Eq_97) o0_30;
	*o1_28 = (struct Eq_97 **) o1;
	i3Out = o3;
	i4Out = o4;
	i5Out = o5;
	return o2;
}

// 0001143C: void __register_frame_info_table(Register (ptr32 Eq_55) o0, Register (ptr32 Eq_97) o1)
void __register_frame_info_table(struct Eq_55 * o0, struct Eq_97 * o1)
{
	o1[2] = (struct Eq_97) o0;
	o1[3] = (struct Eq_97) o0;
	o1[1] = (struct Eq_97) 0x00;
	struct Eq_97 ** o1_28 = g_ptr21774;
	o1->dw0000 = 0x00;
	struct Eq_97 * o0_30 = *o1_28;
	o1[4] = (struct Eq_97) 0x00;
	o1[5] = (struct Eq_97) o0_30;
	*o1_28 = (struct Eq_97 **) o1;
}

// 00011484: void __deregister_frame_info(Register (ptr32 Eq_55) o0)
// Called from:
//      __do_global_dtors_aux
void __deregister_frame_info(struct Eq_55 * o0)
{
	struct Eq_97 ** o2_27 = g_ptr21774;
	if (*o2_27 == null)
		abort();
	else
	{
		struct Eq_97 * o1_32 = *o2_27;
		if (o1_32[2] == o0)
		{
			struct Eq_97 * o0_40 = o1_32[5];
			*o2_27 = (struct Eq_97 **) o0_40;
			if (o1_32->dw0000 != 0x00)
				free(o1_32[3]);
		}
	}
}

// 00011504: void __frame_state_for(Register (ptr32 Eq_573) o0)
void __frame_state_for(struct Eq_573 * o0)
{
	word32 i6_28;
	struct Eq_662 * o0_33 = find_fde(o0, out i6_28);
	if (o0_33 == null)
		return;
	void * i1_171;
	struct Eq_1028 * i6_129;
	up32 i0_158;
	byte * o0_57 = extract_cie_info(o0_33, i6_28 + ~0x27, out i0_158, out i1_171, out i6_129);
	if (o0_57 == null)
		return;
	int8 * o0_117;
	memset(&i6_129->dwFFFFFDBC + 1, 0x00, (size_t) 0x0218);
	word32 o1_71 = i6_129->dwFFFFFFDC;
	i6_129->wFFFFFF6A = (word16) (uipr32) i6_129->wFFFFFFEA;
	i6_129->dwFFFFFDC4 = o1_71;
	word32 * o0_76 = o0_33 - (o0_33->dw0004 + ~0x03);
	up32 o0_78 = o0_76 + *o0_76;
	if (o0_57 < o0_78 + 0x04)
	{
		byte * o0_114 = o0_57;
		while (true)
		{
			byte * o0_100 = execute_cfa_insn(o0_114, &i6_129->dwFFFFFDBC + 1, &i6_129->ptrFFFFFFD8, out i0_158, out i1_171, out i6_129);
			if (o0_100 >= o0_78 + 0x04)
				break;
			o0_114 = o0_100;
		}
		o0_117 = i6_129->ptrFFFFFFD8;
	}
	else
		o0_117 = i6_129->ptrFFFFFFD8;
	byte * l0_126;
	if ((int32) *o0_117 == 122)
		l0_126 = decode_uleb128(&o0_33->dw0008 + 2, &i6_129->dwFFFFFDBC) + i6_129->dwFFFFFDBC;
	else
		l0_126 = (byte *) (&o0_33->dw0008 + 2);
	ptr32 o0_147 = o0_33 + o0_33->dw0000 / 0x0C;
	up32 o1_146 = o0_33->dw0008;
	if (l0_126 < o0_147 + 0x04)
	{
		i6_129->dwFFFFFDB8 = o1_146;
		up32 o0_156 = i6_129->dwFFFFFDB8;
		while (o0_156 < i0_158)
		{
			byte * o0_178 = execute_cfa_insn(l0_126, &i6_129->dwFFFFFDBC + 1, &i6_129->ptrFFFFFFD8, out i0_158, out i1_171, out i6_129);
			l0_126 = o0_178;
			if (o0_178 >= o0_147 + 0x04)
				break;
			o0_156 = i6_129->dwFFFFFDB8;
		}
	}
	else
		i6_129->dwFFFFFDB8 = o1_146;
	memcpy(i1_171, &i6_129->dwFFFFFDBC + 1, (size_t) 0x0214);
}

// 0001162C: Register (ptr32 word32) __do_global_ctors_aux(Register word32 o2, Register word32 o3, Register word32 o4, Register word32 o5)
// Called from:
//      _init
word32 * __do_global_ctors_aux(word32 o2, word32 o3, word32 o4, word32 o5)
{
	word32 * l0_32;
	struct Eq_1174 * o0_27 = g_ptr21778;
	word32 o1_28 = o0_27->dwFFFFFFFC;
	if (o1_28 != ~0x00)
	{
		l0_32 = &o0_27->dwFFFFFFFC;
		do
		{
			<anonymous> * o0_36 = *l0_32;
			o0_36();
		} while (*l0_32 != (<anonymous> *) ~0x00);
	}
	else
		l0_32 = &o0_27->dwFFFFFFFC;
	return l0_32;
}

// 00011680: void init_dummy()
void init_dummy()
{
}

