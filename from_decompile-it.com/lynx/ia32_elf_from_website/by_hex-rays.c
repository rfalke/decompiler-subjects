/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_804A764();
// int fileno(FILE *stream);
// int scrollok(WINDOW *, bool);
// int fputs(const char *s, FILE *stream);
// int ungetmouse(MEVENT *);
// void abort(void);
// int *__errno_location(void);
// int sigemptyset(sigset_t *set);
// int sprintf(char *s, const char *format, ...);
// FILE *popen(const char *command, const char *modes);
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
// __pid_t getpid(void);
// int mkdir(const char *path, __mode_t mode);
// int inflateReset(z_streamp strm);
// char *strerror(int errnum);
// int mouseinterval(int);
// int getsockname(int fd, struct sockaddr *addr, socklen_t *len);
// int memcmp(const void *s1, const void *s2, size_t n);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// void freeaddrinfo(struct addrinfo *ai);
// void syslog(int pri, const char *fmt, ...);
// WINDOW *newwin(int, int, int, int);
// void *bsearch(const void *key, const void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// int random(void);
// int inflateEnd(z_streamp strm);
// int waddch(WINDOW *, const chtype);
// int __cdecl open64(_DWORD, _DWORD);
// int wmove(WINDOW *, int, int);
// int __cdecl gzopen64(_DWORD, _DWORD); weak
// int keypad(WINDOW *, bool);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int echo(void);
// void *realloc(void *ptr, size_t size);
// iconv_t iconv_open(const char *tocode, const char *fromcode);
// int unsetenv(const char *name);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// struct tm *localtime(const time_t *timer);
// int endwin(void);
// struct group *getgrnam(const char *name);
// int gzclose(gzFile file);
// double strtod(const char *nptr, char **endptr);
// char *strchr(const char *s, int c);
// char *getenv(const char *name);
// void *calloc(size_t nmemb, size_t size);
// int system(const char *command);
// char *strncpy(char *dest, const char *src, size_t n);
// int putchar(int c);
// char *ttyname(int fd);
// ssize_t write(int fd, const void *buf, size_t n);
// int doupdate(void);
// int resizeterm(int, int);
// int listen(int fd, int n);
// WINDOW *derwin(WINDOW *, int, int, int, int);
// int toupper(int c);
// char *fgets(char *s, int n, FILE *stream);
// int rename(const char *old, const char *new);
// void *memset(void *s, int c, size_t n);
// int __cdecl fopen64(_DWORD, _DWORD); weak
// int _IO_getc(_IO_FILE *fp);
// void _exit(int status);
// char *strrchr(const char *s, int c);
// char *ctermid(char *s);
// int chmod(const char *file, __mode_t mode);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int delwin(WINDOW *);
// int werase(WINDOW *);
// char *bindtextdomain(const char *domainname, const char *dirname);
// WINDOW *initscr(void);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void perror(const char *s);
// char *gettext(const char *msgid);
// int ungetc(int c, FILE *stream);
// int pnoutrefresh(WINDOW *, int, int, int, int, int, int);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// int wclrtoeol(WINDOW *);
// int inflate(z_streamp strm, int flush);
// int strtol(const char *nptr, char **endptr, int base);
// FILE *fdopen(int fd, const char *modes);
// int clearok(WINDOW *, bool);
// void free(void *ptr);
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// void openlog(const char *ident, int option, int facility);
// int pair_content(__int16, __int16 *, __int16 *);
// int getmouse(MEVENT *);
// mmask_t mousemask(mmask_t, mmask_t *);
// const char *curses_version(void);
// int nonl(void);
// int __cdecl truncate64(_DWORD, _DWORD, _DWORD); weak
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// int fflush(FILE *stream);
// DIR *opendir(const char *name);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int ioctl(int fd, unsigned int request, ...);
// int socket(int domain, int type, int protocol);
// int dup2(int fd, int fd2);
// const unsigned __int16 **__ctype_b_loc(void);
// int wtouchln(WINDOW *, int, int, int);
// int isatty(int fd);
// int getaddrinfo(const char *name, const char *service, const struct addrinfo *req, struct addrinfo **pai);
// __mode_t umask(__mode_t mask);
// int fclose(FILE *stream);
// time_t mktime(struct tm *tp);
// int wrefresh(WINDOW *);
// uint16_t ntohs(uint16_t netshort);
// int init_pair(__int16, __int16, __int16);
// int __cdecl readdir64(_DWORD); weak
// void *memcpy(void *dest, const void *src, size_t n);
// int execv(const char *path, char *const argv[]);
// size_t strlen(const char *s);
// char *mkdtemp(char *template);
// int unlink(const char *name);
// size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);
// struct passwd *getpwuid(__uid_t uid);
// const char *gai_strerror(int ecode);
// char *setlocale(int category, const char *locale);
// __pid_t waitpid(__pid_t pid, int *stat_loc, int options);
// void clearerr(FILE *stream);
// int fgetc(FILE *stream);
// int feof(FILE *stream);
// char *strcpy(char *dest, const char *src);
// int cbreak(void);
// int printf(const char *format, ...);
// int chdir(const char *path);
// char *ctime(const time_t *timer);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int atol(const char *nptr);
// int atoi(const char *nptr);
// int start_color(void);
// int putenv(char *string);
// double atof(const char *nptr);
// int wresize(WINDOW *, int, int);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// void srandom(unsigned int seed);
// const char *gzerror(gzFile file, int *errnum);
// int wgetch(WINDOW *);
// int closedir(DIR *dirp);
// int close(int fd);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int wbkgd(WINDOW *, chtype);
// int fprintf(FILE *stream, const char *format, ...);
// char *strstr(const char *haystack, const char *needle);
// time_t time(time_t *timer);
// char *strncat(char *dest, const char *src, size_t n);
// int remove(const char *filename);
// WINDOW *newpad(int, int);
// int execve(const char *path, char *const argv[], char *const envp[]);
// char *nl_langinfo(nl_item item);
// void *malloc(size_t size);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// bool has_colors(void);
// int iconv_close(iconv_t cd);
// int gethostname(char *name, size_t len);
// int fputc(int c, FILE *stream);
// int rmdir(const char *path);
// int waddnstr(WINDOW *, const char *, int);
// char *strtok(char *s, const char *delim);
// struct group *getgrgid(__gid_t gid);
// unsigned int sleep(unsigned int seconds);
// int sigaddset(sigset_t *set, int signo);
// int wborder(WINDOW *, chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int inflateInit_(z_streamp strm, const char *version, int stream_size);
// int getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, unsigned int flags);
// char *strcat(char *dest, const char *src);
// char *getcwd(char *buf, size_t size);
// int define_key(const char *, int);
// int vasprintf(char **, const char *, va_list);
// int assume_default_colors(int, int);
// int puts(const char *s);
// __pid_t fork(void);
// char *textdomain(const char *domainname);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// int wattr_off(WINDOW *, attr_t, void *);
// int sscanf(const char *s, const char *format, ...);
// int getgroups(int size, __gid_t list[]);
// int strncmp(const char *s1, const char *s2, size_t n);
// int wnoutrefresh(WINDOW *);
// int gzread(gzFile file, voidp buf, unsigned int len);
// int _IO_putc(int c, _IO_FILE *fp);
// char *strpbrk(const char *s, const char *accept);
// int pipe(int pipedes[2]);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// void closelog(void);
// int kill(__pid_t pid, int sig);
// int wclear(WINDOW *);
// int getpeername(int fd, struct sockaddr *addr, socklen_t *len);
// struct hostent *gethostbyname(const char *name);
// int ferror(FILE *stream);
// int nl(void);
// struct passwd *getpwnam(const char *name);
// int tolower(int c);
// int noecho(void);
// int strcmp(const char *s1, const char *s2);
// void wbkgdset(WINDOW *, chtype);
// void exit(int status);
// int pclose(FILE *stream);
// int napms(int);
// int __cdecl freopen64(_DWORD, _DWORD, _DWORD); weak
// int wattr_on(WINDOW *, attr_t, void *);
// __uid_t geteuid(void);
void __cdecl cleanup_sig(int sig);
void cleanup_files(); // idb
void cleanup(); // idb
int LYVersionIsRelease();
char *LYVersionStatus();
char *LYVersionDate();
void __cdecl dt_String(FILE *fp, const char *label, const char *value);
void __cdecl dt_Number(FILE *fp0, const char *label, int number, const char *units);
int __cdecl LYShowInfo(DocInfo *doc, DocInfo *newdoc, char *owner_address);
int editor_can_position();
int __cdecl edit_current_file(char *newfile, int cur, int lineno);
void __cdecl edit_temporary_file(char *filename, const char *position, const char *message);
int peek_mouse_levent(); // idb
int get_mouse_link(); // idb
int peek_mouse_link(); // idb
int __cdecl fancy_mouse(WINDOW *win, int row, int *position);
HTList *__cdecl whichRecall(RecallType recall);
void __cdecl LYRemoveFromCloset(HTList *list);
void __cdecl LYCloseCloset(RecallType recall);
char *__cdecl LYFindInCloset(RecallType recall, char *base);
void __cdecl LYAddToCloset(RecallType recall, char *str);
int __cdecl XYdist(int x1, int y1, int x2, int y2, int dx2);
int __cdecl set_clicked_link(int x, int y, int code, int clicks);
char *__cdecl LYstrncpy(char *dst, const char *src, int n);
char *__cdecl LYmbcsstrncpy(char *dst, const char *src, int n_bytes, int n_glyphs, BOOLEAN utf_flag);
const char *__cdecl LYmbcs_skip_glyphs(const char *data, int n_glyphs, BOOLEAN utf_flag);
const char *__cdecl LYmbcs_skip_cells(const char *data, int n_cells, BOOLEAN utf_flag);
int __cdecl LYmbcsstrlen(const char *str, BOOLEAN utf_flag, BOOLEAN count_gcells);
void __cdecl ena_csi(BOOLEAN flag);
int __cdecl lookup_tiname(char *name, const char *const *names);
const char *__cdecl expand_tiname(const char *first, size_t len, char **result, char *final);
const char *__cdecl expand_tichar(const char *first, char **result, char *final);
int __cdecl expand_substring(char *dst, const char *first, const char *last, char *final);
void __cdecl unescaped_char(const char *parse, int *keysym);
BOOLEAN __cdecl unescape_string(char *src, char *dst, char *final);
int __cdecl map_string_to_keysym(const char *str, int *keysym);
char *__cdecl skip_keysym(char *parse);
int __cdecl setkey_cmd(char *parse);
int __cdecl unsetkey_cmd(char *parse);
int read_keymap_file(); // idb
void setup_vtXXX_keymap(); // idb
int lynx_initialize_keymaps(); // idb
int __cdecl LYmouse_menu(int x, int y, int atlink, int code);
int __cdecl LYgetch_for(int code);
int LYgetch(); // idb
int LYgetch_choice(); // idb
int LYgetch_input(); // idb
int LYgetch_single(); // idb
void __cdecl LYLowerCase(char *arg_buffer);
void __cdecl LYUpperCase(char *arg_buffer);
BOOLEAN __cdecl LYRemoveNewlines(char *buffer);
char *__cdecl LYReduceBlanks(char *buffer);
char *__cdecl LYRemoveBlanks(char *buffer);
char *__cdecl LYSkipBlanks(char *buffer);
char *__cdecl LYSkipNonBlanks(char *buffer);
const char *__cdecl LYSkipCBlanks(const char *buffer);
const char *__cdecl LYSkipCNonBlanks(const char *buffer);
void __cdecl LYTrimLeading(char *buffer);
char *__cdecl LYTrimNewline(char *buffer);
void __cdecl LYTrimTrailing(char *buffer);
char *__cdecl LYElideString(char *str, int cut_pos);
BOOLEAN __cdecl LYTrimStartfile(char *buffer);
void __cdecl LYEscapeStartfile(char **buffer);
void __cdecl LYTrimAllStartfile(char *buffer);
void __cdecl LYSetupEdit(EditFieldData *edit, char *old, int maxstr, int maxdsp);
int __cdecl mbcs_glyphs(char *s, int len);
int __cdecl mbcs_skip(char *s, int pos);
int __cdecl cell2char(char *s, int cells);
int __cdecl LYEditInsert(EditFieldData *edit, const unsigned __int8 *s, int len, int map, BOOLEAN maxMessage);
int __cdecl LYEdit1(EditFieldData *edit, int ch_0, int action, BOOLEAN maxMessage);
int __cdecl get_popup_number(const char *msg, int *c, int *rel);
void __cdecl remember_column(EditFieldData *edit, int offset);
void __cdecl fill_edited_line(int prompting, int length, int ch_0);
void __cdecl LYRefreshEdit(EditFieldData *edit);
void __cdecl reinsertEdit(EditFieldData *edit, char *result);
int __cdecl caselessCmpList(const void *a, const void *b);
int __cdecl normalCmpList(const void *a, const void *b);
char **__cdecl sortedList(HTList *list, BOOLEAN ignorecase);
int __cdecl LYarrayLength(const char **list);
int __cdecl LYarrayWidth(const char **list);
void __cdecl FormatChoiceNum(char *dst, int num_choices, int choice, const char *value);
unsigned int __cdecl options_width(const char **list);
void __cdecl draw_option(WINDOW *win, int entry, int width, BOOLEAN reversed, int num_choices, int number, const char *value);
int __cdecl LYhandlePopupList(int cur_choice, int ly, int lx, const char **choices, int width, int i_length, int disabled, BOOLEAN for_mouse);
int __cdecl LYgetstr(char *inputline, int hidden, size_t bufsize, RecallType recall);
char *LYLineeditHelpURL();
char *__cdecl LYstrsep(char **stringp, const char *delim);
char *__cdecl LYstrstr(char *chptr, const char *tarptr);
const char *__cdecl LYno_attr_char_case_strstr(const char *chptr, const char *tarptr);
const char *__cdecl LYno_attr_char_strstr(const char *chptr, const char *tarptr);
const char *__cdecl LYno_attr_mbcs_case_strstr(const char *chptr, const char *tarptr, BOOLEAN utf_flag, BOOLEAN count_gcells, int *nstartp, int *nendp);
const char *__cdecl LYno_attr_mbcs_strstr(const char *chptr, const char *tarptr, BOOLEAN utf_flag, BOOLEAN count_gcells, int *nstartp, int *nendp);
char *__cdecl SNACopy(char **dest, const char *src, int n);
char *__cdecl SNACat(char **dest, const char *src, int n);
int __cdecl UniToLowerCase(int upper);
int __cdecl UPPER8(int ch1, int ch2);
char *__cdecl LYSafeGets(char **src, FILE *fp);
void __cdecl LYOpenCmdLogfile(int argc, char **argv);
bool LYHaveCmdScript();
void LYOpenCmdScript(); // idb
int __cdecl LYReadCmdKey(int mode);
void __cdecl LYWriteCmdKey(int ch_0);
void LYCloseCmdLogfile(); // idb
void __cdecl terminate_letter(int sig);
void __cdecl SafeHTUnEscape(char *string);
void __cdecl remove_tildes(char *string);
void __cdecl comma_append(char **dst, char *src);
void __cdecl extract_field(char **dst, char *src, const char *keyword);
void __cdecl extract_subject(char *dst, char *src);
void __cdecl extract_body(char **dst, char *src);
BOOLEAN __cdecl trim_comma(char *address);
BOOLEAN __cdecl convert_explorer(char *address);
int __cdecl header_prompt(const char *label, char **result, unsigned int limit);
void __cdecl show_addresses(char *addresses);
FILE *LYPipeToMailer(); // idb
void __cdecl mailform(const char *mailto_address, const char *mailto_subject, const char *mailto_content, const char *mailto_type);
void __cdecl mailmsg(int cur, char *owner_address, char *filename, char *linkname);
void __cdecl reply_by_mail(char *mail_address, char *filename, const char *title, const char *refid);
int LYSystemMail();
void __cdecl HTAlert(const char *Msg);
void __cdecl HTAlwaysAlert(const char *extra_prefix, const char *Msg);
void __cdecl HTInfoMsg(const char *Msg);
void __cdecl HTInfoMsg2(const char *Msg2, const char *Arg);
void __cdecl HTUserMsg(const char *Msg);
void __cdecl HTUserMsg2(const char *Msg2, const char *Arg);
void __cdecl HTProgress(const char *Msg);
const char *__cdecl HTProgressUnits(int rate);
const char *__cdecl sprint_bytes(char *s, off_t n, const char *was_units);
char *__cdecl sprint_tbuf(char *s, int t);
void __cdecl HTReadProgress(off_t bytes, off_t total);
int HTLastConfirmCancelled();
int __cdecl HTForcedPrompt(int option, const char *msg, int dft);
int __cdecl HTConfirmDefault(const char *Msg, int Dft);
BOOLEAN __cdecl HTConfirm(const char *Msg);
BOOLEAN __cdecl confirm_post_resub(const char *address, const char *title, int if_imgmap, int if_file);
char *__cdecl HTPrompt(const char *Msg, const char *deflt);
char *__cdecl HTPromptPassword(const char *Msg);
void __cdecl HTPromptUsernameAndPassword(const char *Msg, char **username, char **password, BOOLEAN IsProxy);
BOOLEAN __cdecl HTConfirmCookie(domain_entry *de, const char *server, const char *name, const char *value);
int __cdecl HTConfirmPostRedirect(const char *Redirecting_url, int server_status);
void LYSleepAlert(); // idb
void LYSleepDebug(); // idb
void LYSleepInfo(); // idb
void LYSleepMsg(); // idb
void LYSleepReplay(); // idb
pool_data *__cdecl ALLOC_IN_POOL(HTPool **ppoolptr, unsigned int request);
HTPool *POOL_NEW(); // idb
void __cdecl POOL_FREE(HTPool *poolptr);
void *__cdecl HText_pool_calloc(HText *text, unsigned int size);
void ht_justify_cleanup(); // idb
void __cdecl mark_justify_start_position(void *text);
void HText_halt(); // idb
BOOLEAN __cdecl mem_is_avail(size_t factor, size_t bytes);
void *__cdecl LY_check_calloc(size_t nmemb, size_t size);
int __cdecl StyleToCols(HText *text, HTLine *line, int nstyle);
void __cdecl LYClearHiText(TextAnchor *a);
void __cdecl LYSetHiText(TextAnchor *a, const char *text, int len);
void __cdecl LYAddHiText(TextAnchor *a, const char *text, int x);
int __cdecl LYAdjHiTextPos(TextAnchor *a, int count);
char *__cdecl LYGetHiTextStr(TextAnchor *a, int count);
int __cdecl LYGetHiTextPos(TextAnchor *a, int count);
void __cdecl LYCopyHiText(TextAnchor *a, TextAnchor *b);
void __cdecl HText_getChartransInfo(HText *me);
void __cdecl PerFormInfo_free(PerFormInfo *form);
void __cdecl free_form_fields(FormInfo *input_field);
void __cdecl FormList_delete(HTList *forms);
void __cdecl ResetPartialLinenos(HText *text);
HText *__cdecl HText_new(HTParentAnchor *anchor);
HText *__cdecl HText_new2(HTParentAnchor *anchor, HTStream *stream);
void __cdecl HText_free(HText *self);
int __cdecl display_line(HTLine *line, HText *text, int scrline, const char *target);
void __cdecl display_title(HText *text);
void __cdecl display_scrollbar(HText *text);
void __cdecl display_page(HText *text, int line_number, const char *target);
void __cdecl HText_beginAppend(HText *text);
int __cdecl set_style_by_embedded_chars(char *s, char *e, unsigned __int8 start_c, unsigned __int8 end_c);
void __cdecl move_anchors_in_region(HTLine *line, int line_number, TextAnchor **prev_anchor, int *prev_head_processed, int sbyte, int ebyte, int shift);
HTLine *__cdecl insert_blanks_in_line(HTLine *line, int line_number, HText *text, TextAnchor **prev_anchor, int ninserts, int *oldpos, int *newpos);
HTStyleChange *__cdecl skip_matched_and_correct_offsets(HTStyleChange *end, HTStyleChange *start, unsigned int split_pos);
void __cdecl split_line(HText *text, unsigned int split);
void __cdecl blank_lines(HText *text, int newlines);
void __cdecl HText_appendParagraph(HText *text);
void __cdecl HText_setStyle(HText *text, HTStyle *style);
void __cdecl HText_appendCharacter(HText *text, int ch_0);
void __cdecl internal_HTC(HText *text, int style, int dir);
void __cdecl HText_setLastChar(HText *text, char ch_0);
char __cdecl HText_getLastChar(HText *text);
void __cdecl HText_setIgnoreExcess(HText *text, BOOLEAN ignore);
int __cdecl HText_insertBlanksInStblLines(HText *me, int ncols);
void __cdecl HText_cancelStbl(HText *me);
void __cdecl HText_startStblTABLE(HText *me, __int16 alignment);
void __cdecl free_enclosed_stbl(HText *me);
int __cdecl HText_endStblTABLE(HText *me);
void __cdecl HText_startStblTR(HText *me, __int16 alignment);
void __cdecl HText_endStblTR(HText *me);
void __cdecl HText_startStblTD(HText *me, int colspan, int rowspan, __int16 alignment, BOOLEAN isheader);
void __cdecl HText_endStblTD(HText *me);
void __cdecl HText_startStblCOL(HText *me, int span, __int16 alignment, BOOLEAN isgroup);
void __cdecl HText_endStblCOLGROUP(HText *me);
void __cdecl HText_startStblRowGroup(HText *me, __int16 alignment);
void __cdecl add_link_number(HText *text, TextAnchor *a, BOOLEAN save_position);
int __cdecl HText_beginAnchor(HText *text, BOOLEAN underline, HTChildAnchor *anc);
BOOLEAN __cdecl HText_endAnchor0(HText *text, int number, int really);
void __cdecl HText_endAnchor(HText *text, int number);
BOOLEAN __cdecl HText_isAnchorBlank(HText *text, int number);
void __cdecl HText_appendText(HText *text, const char *str);
int __cdecl remove_special_attr_chars(char *buf);
void __cdecl HText_endAppend(HText *text);
void __cdecl HText_trimHightext(HText *text, BOOLEAN final, int stop_before);
HTParentAnchor *__cdecl HText_nodeAnchor(HText *text);
HTChildAnchor *__cdecl HText_childNextNumber(int number, void **prev);
void __cdecl HText_FormDescNumber(int number, const char **desc);
int __cdecl HTGetRelLinkNum(int num, int rel, int cur);
int __cdecl HTGetLinkInfo(int number, int want_go, int *go_line, int *linknum, char **hightext, char **lname);
BOOLEAN __cdecl same_anchor_or_field(int numberA, FormInfo *formA, int numberB, FormInfo *formB, BOOLEAN ta_same);
BOOLEAN __cdecl HText_TAHasMoreLines(int curlink, int direction);
int __cdecl HTGetLinkOrFieldStart(int curlink, int *go_line, int *linknum, int direction, BOOLEAN ta_skip);
BOOLEAN __cdecl HText_getFirstTargetInLine(HText *text, int line_num, BOOLEAN utf_flag, int *offset, int *tLen, char **data, const char *target);
int HText_getNumOfLines(); // idb
int HText_getNumOfBytes(); // idb
const char *HText_getTitle(); // idb
const char *HText_getStyle(); // idb
const char *HText_getSugFname(); // idb
void __cdecl HTCheckFnameForCompression(char **fname, HTParentAnchor *anchor, BOOLEAN strip_ok);
const char *HText_getLastModified(); // idb
const char *HText_getDate(); // idb
const char *HText_getServer(); // idb
void __cdecl HText_pageDisplay(int line_num, char *target);
int HText_pageHasPrevTarget();
int __cdecl HText_closestAnchor(HText *text, int offset);
int __cdecl HText_locateAnchor(HText *text, int anchor_number);
BOOLEAN __cdecl anchor_is_numbered(TextAnchor *Anchor_ptr);
int __cdecl HText_getAbsLineNumber(HText *text, int anchor_number);
int __cdecl HText_anchorRelativeTo(HText *text, int top_lineno, int anchor_number);
int __cdecl HText_LinksInLines(HText *text, int line_num, int Lines);
void __cdecl HText_setStale(HText *text);
void __cdecl HText_refresh(HText *text);
int __cdecl HText_sourceAnchors(HText *text);
BOOLEAN __cdecl HText_canScrollUp(HText *text);
_BOOL4 HText_canScrollDown();
void __cdecl HText_scrollTop(HText *text);
void __cdecl HText_scrollDown(HText *text);
void __cdecl HText_scrollUp(HText *text);
void __cdecl HText_scrollBottom(HText *text);
BOOLEAN __cdecl HText_select(HText *text);
BOOLEAN __cdecl HText_POSTReplyLoaded(DocInfo *doc);
BOOLEAN __cdecl HTFindPoundSelector(const char *selector);
BOOLEAN __cdecl HText_selectAnchor(HText *text, HTChildAnchor *anchor);
void __cdecl HText_applyStyle(HText *me, HTStyle *style);
void __cdecl HText_updateStyle(HText *me, HTStyle *style);
HTStyle *__cdecl HText_selectionStyle(HText *me, HTStyleSheet *sheet);
void __cdecl HText_replaceSel(HText *me, const char *aString, HTStyle *aStyle);
void __cdecl HTextApplyToSimilar(HText *me, HTStyle *style);
void __cdecl HTextSelectUnstyled(HText *me, HTStyleSheet *sheet);
void __cdecl HText_unlinkSelection(HText *me);
HTAnchor *__cdecl HText_referenceSelected(HText *me);
int HText_getTopOfScreen(); // idb
int __cdecl HText_getLines(HText *text);
int __cdecl HText_getPreferredTopLine(HText *text, int line_number);
HTAnchor *__cdecl HText_linkSelTo(HText *me, HTAnchor *anchor);
void HTSearchQueries_free(); // idb
void __cdecl HTAddSearchQuery(char *query);
int __cdecl do_www_search(DocInfo *doc);
void __cdecl write_offset(FILE *fp, HTLine *line);
void __cdecl write_hyphen(FILE *fp);
int __cdecl TrimmedLength(char *string);
void __cdecl print_wwwfile_to_fd(FILE *fp, BOOLEAN is_email, BOOLEAN is_reply);
void __cdecl print_crawl_to_fd(FILE *fp, char *thelink, char *thetitle);
void __cdecl adjust_search_result(DocInfo *doc, int tentative_result, int start_line);
BOOLEAN __cdecl anchor_has_target(TextAnchor *a, char *target);
TextAnchor *__cdecl line_num_to_anchor(int line_num);
int __cdecl line_num_in_text(HText *text, HTLine *line);
TextAnchor *__cdecl get_prev_anchor(TextAnchor *a);
int __cdecl www_search_forward(int start_line, DocInfo *doc, char *target, HTLine *line, int count);
int __cdecl www_search_backward(int start_line, DocInfo *doc, char *target, HTLine *line, int count);
void __cdecl www_user_search(int start_line, DocInfo *doc, char *target, int direction);
void __cdecl user_message(const char *message, const char *argument);
const char *HText_getOwner(); // idb
void __cdecl HText_setMainTextOwner(const char *owner);
const char *HText_getRevTitle(); // idb
const char *HText_getContentBase(); // idb
const char *HText_getContentLocation(); // idb
const char *HText_getMessageID(); // idb
void HTuncache_current_document(); // idb
_BOOL4 useSourceCache();
_BOOL4 useMemoryCache();
_BOOL4 HTreparse_document();
int HTcan_reparse_document();
void __cdecl trace_setting_change(const char *name, int prev_setting, int new_setting);
_BOOL4 HTdocument_settings_changed();
int HTisDocumentSource(); // idb
char *HTLoadedDocumentURL();
bstring *HTLoadedDocumentPost_data(); // idb
char *HTLoadedDocumentTitle();
int HTLoadedDocumentIsHEAD();
int HTLoadedDocumentIsSafe();
char *HTLoadedDocumentCharset();
int HTLoadedDocumentEightbit();
void __cdecl HText_setNodeAnchorBookmark(const char *bookmark);
char *HTLoadedDocumentBookmark();
int __cdecl HText_LastLineSize(HText *text, BOOLEAN IgnoreSpaces);
BOOLEAN __cdecl HText_LastLineEmpty(HText *text, BOOLEAN IgnoreSpaces);
int __cdecl HText_LastLineOffset(HText *text);
int __cdecl HText_PreviousLineSize(HText *text, BOOLEAN IgnoreSpaces);
BOOLEAN __cdecl HText_PreviousLineEmpty(HText *text, BOOLEAN IgnoreSpaces);
int __cdecl HText_TrueLineSize(HTLine *line, HText *text, BOOLEAN IgnoreSpaces);
BOOLEAN __cdecl HText_TrueEmptyLine(HTLine *line, HText *text, BOOLEAN IgnoreSpaces);
void __cdecl HText_NegateLineOne(HText *text);
BOOLEAN __cdecl HText_inLineOne(HText *text);
void __cdecl HText_RemovePreviousLine(HText *text);
int __cdecl HText_getCurrentColumn(HText *text);
int __cdecl HText_getMaximumColumn(HText *text);
void __cdecl HText_setTabID(HText *text, const char *name);
int __cdecl HText_getTabIDColumn(HText *text, const char *name);
void __cdecl HText_AddHiddenLink(HText *text, TextAnchor *textanchor);
int __cdecl HText_HiddenLinkCount(HText *text);
const char *__cdecl HText_HiddenLinkAt(HText *text, int number);
void __cdecl HText_beginForm(char *action, char *method, char *enctype, char *title, const char *accept_cs);
void __cdecl HText_endForm(HText *text);
void __cdecl HText_beginSelect(char *name, int name_cs, BOOLEAN multiple, char *size);
int __cdecl HText_getOptionNum(HText *text);
char *__cdecl HText_skipOptionNumPrefix(char *opname);
char *__cdecl HText_setLastOptionValue(HText *text, char *value, char *submit_value, int order, BOOLEAN checked, int val_cs, int submit_val_cs);
int __cdecl HText_beginInput(HText *text, BOOLEAN underline, InputFieldData *I);
void __cdecl HText_endInput(HText *text);
double __cdecl get_trans_q(int cs_from, char *givenmime);
int __cdecl find_best_target_cs(char **best_csname, int cs_from, const char *acceptstring);
void __cdecl load_a_file(const char *val_used, bstring **result);
const char *__cdecl guess_content_type(const char *filename);
void __cdecl cannot_transcode(BOOLEAN *had_warning, const char *target_csname);
unsigned int __cdecl check_form_specialchars(const char *value);
void __cdecl UpdateBoundary(char **Boundary, bstring *data);
char *__cdecl convert_to_base64(const char *src, int len);
char *__cdecl escape_or_quote_name(const char *name, QuoteData quoting, const char *MultipartContentType);
char *__cdecl escape_or_quote_value(const char *value, QuoteData quoting);
int __cdecl check_if_base64_needed(int submit_method, bstring *data);
int __cdecl HText_SubmitForm(FormInfo *submit_item, DocInfo *doc, char *link_name, char *link_value);
void HText_DisableCurrentForm(); // idb
void __cdecl HText_ResetForm(FormInfo *form);
BOOLEAN __cdecl HText_HaveUserChangedForms(HText *text);
void __cdecl HText_activateRadioButton(FormInfo *form);
char *__cdecl stub_HTAnchor_address(HTAnchor *me);
void __cdecl HText_setToolbar(HText *text);
BOOLEAN __cdecl HText_hasToolbar(HText *text);
void __cdecl HText_setNoCache(HText *text);
BOOLEAN __cdecl HText_hasNoCacheSet(HText *text);
BOOLEAN __cdecl HText_hasUTF8OutputSet(HText *text);
void __cdecl HText_setKcode(HText *text, const char *charset, LYUCcharset *p_in);
void __cdecl HText_setBreakPoint(HText *text);
BOOLEAN __cdecl HText_AreDifferent(HTParentAnchor *anchor, const char *full_address);
int __cdecl increment_tagged_htline(HTLine *ht, TextAnchor *a, int *lx_val, int *old_val, int incr, int mode);
void __cdecl insert_new_textarea_anchor(TextAnchor **curr_anchor, HTLine **exit_htline);
void __cdecl update_subsequent_anchors(int newlines, TextAnchor *start_anchor, HTLine *start_htline, int start_tag);
BOOLEAN __cdecl IsFormsTextarea(FormInfo *form, TextAnchor *anchor_ptr);
int __cdecl finish_ExtEditForm(LinkInfo *form_link, TextAnchor *start_anchor, char *ed_temp, int orig_cnt);
int __cdecl HText_ExtEditForm(LinkInfo *form_link);
void __cdecl HText_ExpandTextarea(LinkInfo *form_link, int newlines);
int __cdecl HText_InsertFile(LinkInfo *form_link);
int GetColumn(); // idb
BOOLEAN __cdecl DidWrap(int y0, int x0);
void __cdecl redraw_part_of_line(HTLine *line, const char *str, int len, HText *text);
void __cdecl redraw_lines_of_link(int cur);
void HTMark_asSource(); // idb
HTkcode __cdecl HText_getKcode(HText *text);
void __cdecl HText_updateKcode(HText *text, HTkcode kcode);
HTkcode __cdecl HText_getSpecifiedKcode(HText *text);
void __cdecl HText_updateSpecifiedKcode(HText *text, HTkcode kcode);
int HTMainText_Get_UCLYhndl(); // idb
int __cdecl getfile(DocInfo *doc, int *target);
void __cdecl srcmode_for_next_retrieval(int mode);
int __cdecl follow_link_number(int c, int cur, DocInfo *doc, int *num);
void __cdecl add_trusted(char *str, int type);
BOOLEAN __cdecl exec_ok(const char *source, const char *linktext, int type);
int __cdecl fix_httplike_urls(DocInfo *doc, UrlTypes type);
void LYStdinArgs_free(); // idb
void reset_signals(); // idb
void __cdecl exit_immediately(int code);
BOOLEAN __cdecl GetStdin(char **buf, BOOLEAN marker);
void SetLocale(); // idb
int __cdecl main(int argc, const char **argv, const char **envp);
void LYRegisterLynxProtocols(); // idb
void reload_read_cfg(); // idb
void disable_pausing(); // idb
void force_dump_mode(); // idb
int __cdecl parse_authentication(char *next_arg, char **result);
int __cdecl anonymous_fun(char *next_arg);
int __cdecl assume_charset_fun(char *next_arg);
int __cdecl assume_local_charset_fun(char *next_arg);
int __cdecl assume_unrec_charset_fun(char *next_arg);
int __cdecl auth_fun(char *next_arg);
int __cdecl base_fun(char *next_arg);
int __cdecl cache_fun(char *next_arg);
int __cdecl child_fun(char *next_arg);
int __cdecl child_relaxed_fun(char *next_arg);
int __cdecl crawl_fun(char *next_arg);
int __cdecl display_fun(char *next_arg);
int __cdecl display_charset_fun(char *next_arg);
int __cdecl dump_output_fun(char *next_arg);
int __cdecl editor_fun(char *next_arg);
int __cdecl error_file_fun(char *next_arg);
int __cdecl exec_fun(char *next_arg);
int __cdecl get_data_fun(char *next_arg);
int __cdecl help_fun(char *next_arg);
int __cdecl hiddenlinks_fun(char *next_arg);
int __cdecl homepage_fun(char *next_arg);
int __cdecl mime_header_fun(char *next_arg);
int __cdecl newschunksize_fun(char *next_arg);
int __cdecl newsmaxchunk_fun(char *next_arg);
int __cdecl nobold_fun(char *next_arg);
int __cdecl nobrowse_fun(char *next_arg);
int __cdecl nocolor_fun(char *next_arg);
int __cdecl nopause_fun(char *next_arg);
int __cdecl nomore_fun(char *next_arg);
int __cdecl noreverse_fun(char *next_arg);
int __cdecl nounderline_fun(char *next_arg);
int __cdecl pauth_fun(char *next_arg);
int __cdecl post_data_fun(char *next_arg);
const char *__cdecl show_restriction(const char *name);
int __cdecl restrictions_fun(char *next_arg);
int __cdecl selective_fun(char *next_arg);
int __cdecl source_fun(char *next_arg);
int __cdecl traversal_fun(char *next_arg);
int __cdecl version_fun(char *next_arg);
int __cdecl width_fun(char *next_arg);
void __cdecl print_help_strings(const char *name, const char *help, const char *value, BOOLEAN option);
void __cdecl print_help_and_exit(int exit_status);
int __cdecl arg_eqs_parse(const char *a, char *b, char **c);
BOOLEAN __cdecl parse_arg(char **argv, unsigned int mask, int *countp);
void __cdecl FatalProblem(int sig);
int __cdecl sametext(char *een, char *twee);
void TracelogOpenFailed(); // idb
BOOLEAN __cdecl LYReopenTracelog(BOOLEAN *trace_flag_ptr);
void __cdecl turn_trace_back_on(BOOLEAN *trace_flag_ptr);
FILE *TraceFP(); // idb
int LYOpenTraceLog();
void LYCloseTracelog(); // idb
void handle_LYK_TRACE_TOGGLE(); // idb
void __cdecl LYSetNewline(int value);
int LYGetNewline(); // idb
void __cdecl LYChgNewline(int adjust);
_BOOL4 reparse_document();
BOOLEAN __cdecl reparse_or_reload(int *cmd);
void __cdecl set_address(DocInfo *doc, const char *address);
void __cdecl copy_address(DocInfo *dst, DocInfo *src);
void __cdecl free_address(DocInfo *doc);
void __cdecl move_address(DocInfo *dst, DocInfo *src);
BOOLEAN __cdecl LYMainLoop_pageDisplay(int line_num);
BOOLEAN __cdecl set_curdoc_link(int nextlink);
void __cdecl goto_line(int nextline);
void __cdecl set_curdoc_link_by_mouse(int nextlink);
int do_change_link(); // idb
void __cdecl do_check_goto_URL(char *user_input_buffer, char **old_user_input, BOOLEAN *force_load);
BOOLEAN __cdecl do_check_recall(int ch_0, char *user_input_buffer, char **old_user_input, int URLTotal, int *URLNum, RecallType recall, BOOLEAN *FirstURLRecall);
void do_cleanup_after_delete(); // idb
int __cdecl find_link_near_col(int col, int delta);
int __cdecl DoTraversal(int c, BOOLEAN *crawl_ok);
int __cdecl handle_LYK_ACTIVATE(int *c, int cmd, BOOLEAN *try_internal, BOOLEAN *refresh_screen, BOOLEAN *force_load, int real_cmd);
void __cdecl handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen, int *old_c, int real_c);
void __cdecl handle_LYK_CLEAR_AUTH(int *old_c, int real_c);
int __cdecl handle_LYK_COMMAND(char *user_input_buffer);
void __cdecl handle_LYK_COMMENT(BOOLEAN *refresh_screen, char **owner_address_p, int *old_c, int real_c);
BOOLEAN __cdecl handle_LYK_COOKIE_JAR(int *cmd);
void handle_LYK_CREATE(); // idb
void __cdecl handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen, int *old_c, int real_c);
void __cdecl handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen, int *old_c, int real_c);
int __cdecl handle_LYK_DOWNLOAD(int *cmd, int *old_c, int real_c);
void __cdecl handle_LYK_DOWN_xxx(int *old_c, int real_c, int scroll_by);
void __cdecl handle_LYK_DOWN_HALF(int *old_c, int real_c);
void __cdecl handle_LYK_DOWN_LINK(int *follow_col, int *old_c, int real_c);
void __cdecl handle_LYK_DOWN_TWO(int *old_c, int real_c);
int __cdecl handle_LYK_DWIMEDIT(int *cmd, int *old_c, int real_c);
int __cdecl handle_LYK_ECGOTO(int *ch_0, char *user_input_buffer, char **old_user_input, int *old_c, int real_c);
void __cdecl handle_LYK_EDIT(int *old_c, int real_c);
void __cdecl handle_LYK_DWIMHELP(const char **cshelpfile);
void __cdecl handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen, int *old_c, int real_c);
int __cdecl handle_LYK_ELGOTO(int *ch_0, char *user_input_buffer, char **old_user_input, int *old_c, int real_c);
void __cdecl handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen);
void __cdecl handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen);
BOOLEAN __cdecl handle_LYK_FASTBACKW_LINK(int *cmd, int *old_c, int real_c);
void __cdecl handle_LYK_FASTFORW_LINK(int *old_c, int real_c);
void handle_LYK_FIRST_LINK(); // idb
BOOLEAN __cdecl handle_LYK_GOTO(int *ch_0, char *user_input_buffer, char **old_user_input, RecallType *recall, int *URLTotal, int *URLNum, BOOLEAN *FirstURLRecall, int *old_c, int real_c);
void __cdecl handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen);
BOOLEAN __cdecl handle_LYK_HEAD(int *cmd);
void __cdecl handle_LYK_HELP(const char **cshelpfile);
void handle_LYK_HISTORICAL(); // idb
BOOLEAN __cdecl handle_LYK_HISTORY(BOOLEAN ForcePush);
BOOLEAN __cdecl handle_LYK_IMAGE_TOGGLE(int *cmd);
void __cdecl handle_LYK_INDEX(int *old_c, int real_c);
void __cdecl handle_LYK_INDEX_SEARCH(BOOLEAN *force_load, BOOLEAN ForcePush, int *old_c, int real_c);
BOOLEAN __cdecl handle_LYK_INFO(int *cmd);
BOOLEAN __cdecl handle_LYK_INLINE_TOGGLE(int *cmd);
void __cdecl handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen, int *old_c, int real_c);
BOOLEAN __cdecl handle_LYK_JUMP(int c, char *user_input_buffer, char **old_user_input, RecallType *recall, BOOLEAN *FirstURLRecall, int *URLNum, int *URLTotal, int *ch_0, int *old_c, int real_c);
void __cdecl handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag, BOOLEAN *emacs_keys_flag, int *old_c, int real_c);
void handle_LYK_LAST_LINK(); // idb
void handle_LYK_LEFT_LINK(); // idb
BOOLEAN __cdecl handle_LYK_LIST(int *cmd);
void __cdecl handle_LYK_MAIN_MENU(int *old_c, int real_c);
void handle_LYK_MINIMAL(); // idb
void __cdecl handle_LYK_MODIFY(BOOLEAN *refresh_screen);
BOOLEAN __cdecl handle_LYK_NESTED_TABLES(int *cmd);
BOOLEAN __cdecl handle_LYK_OPTIONS(int *cmd, BOOLEAN *refresh_screen);
void handle_NEXT_DOC(); // idb
void __cdecl handle_LYK_NEXT_LINK(int c, int *old_c, int real_c);
void __cdecl handle_LYK_NEXT_PAGE(int *old_c, int real_c);
BOOLEAN __cdecl handle_LYK_NOCACHE(int *old_c, int real_c);
void __cdecl handle_LYK_PREV_LINK(int *arrowup, int *old_c, int real_c);
int __cdecl handle_PREV_DOC(int *cmd, int *old_c, int real_c);
void __cdecl handle_LYK_PREV_PAGE(int *old_c, int real_c);
void __cdecl handle_LYK_PRINT(BOOLEAN *ForcePush, int *old_c, int real_c);
int handle_LYK_QUIT();
BOOLEAN __cdecl handle_LYK_RAW_TOGGLE(int *cmd);
void __cdecl handle_LYK_RELOAD(int real_cmd);
void __cdecl handle_LYK_REMOVE(BOOLEAN *refresh_screen);
void handle_LYK_RIGHT_LINK(); // idb
void __cdecl handle_LYK_SHELL(BOOLEAN *refresh_screen, int *old_c, int real_c);
void handle_LYK_SOFT_DQUOTES(); // idb
int wrap_reparse_document(); // idb
void __cdecl handle_LYK_SOURCE(char **ownerS_address_p);
void handle_LYK_SWITCH_DTD(); // idb
void handle_LYK_TAG_LINK(); // idb
void handle_LYK_TOGGLE_HELP(); // idb
void __cdecl handle_LYK_TOOLBAR(BOOLEAN *try_internal, BOOLEAN *force_load, int *old_c, int real_c);
void __cdecl handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr);
void handle_LYK_UPLOAD(); // idb
void __cdecl handle_LYK_UP_xxx(int *arrowup, int *old_c, int real_c, int scroll_by);
void __cdecl handle_LYK_UP_HALF(int *arrowup, int *old_c, int real_c);
void __cdecl handle_LYK_UP_LINK(int *follow_col, int *arrowup, int *old_c, int real_c);
void __cdecl handle_LYK_UP_TWO(int *arrowup, int *old_c, int real_c);
void __cdecl handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen, int *old_c, int real_c);
BOOLEAN __cdecl handle_LYK_VLINKS(int *cmd, BOOLEAN *newdoc_link_is_absolute);
void __cdecl handle_LYK_WHEREIS(int cmd, BOOLEAN *refresh_screen);
void __cdecl handle_LYK_digit(int c, BOOLEAN *force_load, char *user_input_buffer, int *old_c, int real_c, BOOLEAN *try_internal);
void handle_LYK_CHDIR(); // idb
int __cdecl repeat_to_delta(int n);
void __cdecl handle_LYK_SHIFT_LEFT(BOOLEAN *flag, int count);
void __cdecl handle_LYK_SHIFT_RIGHT(BOOLEAN *flag, int count);
BOOLEAN __cdecl handle_LYK_LINEWRAP_TOGGLE(int *cmd, BOOLEAN *flag);
_BOOL4 mainloop();
int __cdecl are_different(DocInfo *doc1, DocInfo *doc2);
void __cdecl HTAddGotoURL(char *url);
void __cdecl show_main_statusline(const LinkInfo curlink, int for_what);
void __cdecl repaint_main_statusline(int for_what);
void __cdecl form_noviceline(int disabled);
void __cdecl exit_immediately_with_error_message(int state, BOOLEAN first_file);
void __cdecl status_link(char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx);
char *LYDownLoadAddress();
int __cdecl string_to_attr(char *name);
char *__cdecl attr_to_string(int code);
void __cdecl LYbox(WINDOW *win, BOOLEAN formfield);
void __cdecl setStyle(int style, int color, int cattr, int mono);
void __cdecl setHashStyle(int style, int color, int cattr, int mono, char *element);
void __cdecl LYAttrset(WINDOW *win, int color, int mono);
void __cdecl curses_w_style(WINDOW *win, int style, int dir);
void __cdecl wcurses_css(WINDOW *win, char *name, int dir);
void __cdecl curses_css(char *name, int dir);
void __cdecl curses_style(int style, int dir);
int __cdecl get_color_pair(int n);
int __cdecl lynx_color_cfg_attr(int code);
int __cdecl encode_color_attr(int color_attr);
int __cdecl decode_mono_code(int mono_code);
int LYgetTableAttr(); // idb
char *__cdecl LYgetTableString(int code);
void __cdecl lynx_init_color_pair(int n);
void __cdecl lynx_map_color(int n);
int __cdecl lynx_chg_color(int color, int fg, int bg);
void __cdecl lynx_set_color(int a);
void __cdecl lynx_standout(int flag);
void lynx_init_colors(); // idb
void lynx_setup_colors(); // idb
void __cdecl LYnoVideo(int a);
void start_curses(); // idb
void __cdecl lynx_enable_mouse(int state);
void __cdecl lynx_nl2crlf(int normal);
void stop_curses(); // idb
BOOLEAN __cdecl setup(char *terminal);
int __cdecl dumbterm(char *terminal);
void __cdecl LYpaddstr(WINDOW *the_window, int width, const char *the_string);
void __cdecl LYsubwindow(WINDOW *param);
WINDOW *LYtopwindow(); // idb
WINDOW *__cdecl LYstartPopup(int *top_y, int *left_x, int *height, int *width);
void LYstartTargetEmphasis(); // idb
void LYstopTargetEmphasis(); // idb
void __cdecl LYtouchline(int row);
void __cdecl LYwaddnstr(WINDOW *w, const char *src, size_t len);
int __cdecl LYstrExtent(const char *string, int len, int maxCells);
int __cdecl LYstrExtent2(const char *string, int len);
int __cdecl LYstrCells(const char *string);
int LYscreenHeight(); // idb
int LYscreenWidth(); // idb
void LYnormalColor(); // idb
void LYclear(); // idb
void LYclrtoeol(); // idb
void LYerase(); // idb
void __cdecl LYmove(int y, int x);
void LYrefresh(); // idb
void lynx_force_repaint(); // idb
void lynx_start_title_color(); // idb
void lynx_stop_title_color(); // idb
void __cdecl lynx_start_link_color(int flag, int pending);
void __cdecl lynx_stop_link_color(int flag, int pending);
void lynx_stop_target_color(); // idb
void lynx_start_target_color(); // idb
void lynx_start_status_color(); // idb
void lynx_stop_status_color(); // idb
void lynx_start_h1_color(); // idb
void lynx_stop_h1_color(); // idb
void lynx_start_prompt_color(); // idb
void lynx_stop_prompt_color(); // idb
void lynx_start_radio_color(); // idb
void lynx_stop_radio_color(); // idb
void lynx_stop_all_colors(); // idb
void lynx_start_bold(); // idb
void lynx_start_reverse(); // idb
void lynx_start_underline(); // idb
void lynx_stop_bold(); // idb
void lynx_stop_reverse(); // idb
void lynx_stop_underline(); // idb
void LYSetDisplayLines(); // idb
void __cdecl LYstowCursor(WINDOW *win, int row, int col);
int __cdecl LYgetattrs(WINDOW *win);
int __cdecl LYindex2MBM(int n);
int __cdecl LYMBM2index(int ch_0);
void show_bookmark_not_defined(); // idb
const char *__cdecl get_bookmark_filename(char **URL);
const char *__cdecl convert_mosaic_bookmark_file(const char *filename_buffer);
void __cdecl save_bookmark_link(const char *address, const char *title);
void __cdecl remove_bookmark_link(int cur, char *cur_bookmark_page);
int select_multi_bookmarks(); // idb
int select_menu_multi_bookmarks(); // idb
int LYHaveSubBookmarks();
void __cdecl LYMBM_statusline(const char *text);
BOOLEAN __cdecl havevisible(const char *Title);
BOOLEAN __cdecl have8bit(const char *Title);
char *__cdecl title_convert8bit(const char *Title);
void __cdecl set_default_bookmark_page(char *value);
time_t __cdecl LYmktime(char *string, BOOLEAN absolute);
LY_TEMP *__cdecl FindTempfileByName(const char *name);
LY_TEMP *__cdecl FindTempfileByFP(FILE *fp);
char *__cdecl LYGetEnv(const char *name);
size_t __cdecl utf8_length(BOOLEAN utf_flag, const char *data);
void __cdecl LYFreeHilites(int first, int last);
void __cdecl LYSetHilite(int cur, const char *text);
void __cdecl LYAddHilite(int cur, char *text, int x);
const char *__cdecl LYGetHiliteStr(int cur, int count);
int __cdecl LYGetHilitePos(int cur, int count);
BOOLEAN __cdecl show_whereis_targets(int flag, int cur, int count, const char *target, BOOLEAN TargetEmphasisON, BOOLEAN utf_flag);
int __cdecl find_cached_style(int cur, int flag);
void __cdecl LYhighlight(int flag, int cur, const char *target);
void __cdecl free_and_clear(char **pointer);
void __cdecl convert_to_spaces(char *string, BOOLEAN condense);
char *__cdecl strip_trailing_slash(char *dirname);
void __cdecl remove_most_blanks(char *buffer);
void __cdecl statusline(const char *text);
const char *__cdecl novice_lines(int lineno);
void toggle_novice_line(); // idb
void __cdecl noviceline(int more_flag);
int LYReopenInput(); // idb
int __cdecl LYConsoleInputFD(BOOLEAN need_selectable);
void __cdecl LYFakeZap(BOOLEAN set);
int DontCheck(); // idb
int HTCheckForInterrupt(); // idb
BOOLEAN __cdecl LYisAbsPath(const char *path);
BOOLEAN __cdecl LYisRootPath(const char *path);
BOOLEAN __cdecl LYisLocalFile(const char *filename);
BOOLEAN __cdecl LYisLocalHost(const char *filename);
void __cdecl LYFreeStringList(HTList *list);
void LYLocalhostAliases_free(); // idb
void __cdecl LYAddLocalhostAlias(char *alias);
BOOLEAN __cdecl LYisLocalAlias(const char *filename);
UrlTypes __cdecl LYCheckForProxyURL(char *filename);
BOOLEAN __cdecl compare_type(char *tst, const char *cmp, size_t len);
UrlTypes __cdecl is_url(char *filename);
void __cdecl LYFixCursesOn(const char *reason);
BOOLEAN __cdecl LYFixCursesOnForAccess(const char *addr, const char *physical);
BOOLEAN __cdecl LYCanDoHEAD(const char *address);
BOOLEAN __cdecl LYCloseInput(FILE *fp);
BOOLEAN __cdecl LYCloseOutput(FILE *fp);
BOOLEAN __cdecl LYCanWriteFile(const char *filename);
BOOLEAN __cdecl LYCanReadFile(const char *filename);
void __cdecl remove_backslashes(char *buf);
int inlocaldomain();
void __cdecl LYExtSignal(int sig, LYSigHandlerFunc_t *handler);
BOOLEAN __cdecl LYToggleSigDfl(int sig, sigaction *where, int to_dfl);
void __cdecl size_change(int sig);
void HTSugFilenames_free(); // idb
void __cdecl HTAddSugFilename(char *fname);
void __cdecl change_sug_filename(char *fname);
int __cdecl fmt_tempname(char *result, const char *prefix, const char *suffix);
int __cdecl number2arrows(int number);
BOOLEAN __cdecl strn_dash_equ(const char *p1, const char *p2, int len);
const char *__cdecl index_to_restriction(int inx);
int __cdecl find_restriction(const char *name, int len);
void __cdecl parse_restrictions(const char *s);
void __cdecl print_restrictions_to_fd(FILE *fp);
void LYCheckMail(); // idb
void __cdecl LYEnsureAbsoluteURL(char **href, const char *name, int fixit);
void __cdecl LYConvertToURL(char **AllocatedString, int fixit);
BOOLEAN __cdecl LYExpandHostForURL(char **AllocatedString, char *prefix_list, char *suffix_list);
BOOLEAN __cdecl LYAddSchemeForURL(char **AllocatedString, const char *default_scheme);
void __cdecl LYTrimRelFromAbsPath(char *path);
void __cdecl LYDoCSI(char *url, const char *comment, char **csi);
char *__cdecl Current_Dir(char *pathname);
char *__cdecl CheckDir(char *path);
char *HomeEnv(); // idb
const char *Home_Dir(); // idb
char *__cdecl LYPathLeaf(char *pathname);
BOOLEAN __cdecl LYPathOffHomeOK(char *fbuffer, size_t fbuffer_size);
char *__cdecl FindLeadingTilde(char *pathname, BOOLEAN embedded);
char *__cdecl LYAbsOrHomePath(char **fname);
char *__cdecl LYTildeExpand(char **pathname, BOOLEAN embedded);
void __cdecl LYAddPathToHome(char *fbuffer, size_t fbuffer_size, const char *fname);
char *__cdecl LYAddPathToSave(char *fname);
BOOLEAN __cdecl IsOurSymlink(const char *name);
BOOLEAN __cdecl IsOurFile(const char *name);
FILE *__cdecl OpenHiddenFile(const char *name, const char *mode);
FILE *__cdecl LYNewBinFile(const char *name);
FILE *__cdecl LYNewTxtFile(const char *name);
FILE *__cdecl LYAppendToTxtFile(const char *name);
void __cdecl LYRelaxFilePermissions(const char *name);
BOOLEAN __cdecl LYCachedTemp(char *result, char **cached);
FILE *__cdecl LYOpenTemp(char *result, const char *suffix, const char *mode);
FILE *__cdecl LYReopenTemp(char *name);
FILE *__cdecl LYOpenTempRewrite(char *fname, const char *suffix, const char *mode);
FILE *__cdecl LYOpenScratch(char *result, const char *prefix);
void __cdecl LY_close_temp(LY_TEMP *p);
void __cdecl LYCloseTemp(char *name);
void __cdecl LYCloseTempFP(FILE *fp);
int __cdecl LYRemoveTemp(char *name);
void LYCleanupTemp(); // idb
void __cdecl LYRenamedTemp(char *oldname, char *newname);
void LYCheckBibHost(); // idb
BOOLEAN __cdecl LYIsUIPage3(const char *url, UIP_t type, int flagparam);
void __cdecl LYRegisterUIPage(const char *url, UIP_t type);
void LYUIPages_free(); // idb
const char *__cdecl wwwName(const char *pathname);
BOOLEAN __cdecl LYValidateFilename(char *result, char *given);
int __cdecl LYValidateOutput(char *filename);
void __cdecl LYLocalFileToURL(char **target, const char *source);
FILE *__cdecl InternalPageFP(char *filename, int reuse_flag);
void __cdecl WriteInternalTitle(FILE *fp0, const char *Title);
void __cdecl BeginInternalPage(FILE *fp0, const char *Title, const char *HelpURL);
void __cdecl EndInternalPage(FILE *fp0);
char *__cdecl trimPoundSelector(char *address);
void __cdecl LYTrimPathSep(char *path);
void __cdecl LYAddPathSep(char **path);
void __cdecl LYAddPathSep0(char *path);
char *__cdecl LYLastPathSep(const char *path);
void __cdecl LYTrimHtmlSep(char *path);
void __cdecl LYAddHtmlSep(char **path);
void __cdecl LYAddHtmlSep0(char *path);
int __cdecl LYCopyFile(char *src, char *dst);
int __cdecl LYSystem(char *command);
const char *LYSysShell(); // idb
char *LYgetXDisplay(); // idb
void __cdecl LYsetXDisplay(char *new_display);
void get_clip_release(); // idb
_BOOL4 clip_grab();
char *get_clip_grab(); // idb
int __cdecl put_clip(const char *s);
void __cdecl LYmsec_delay(unsigned int msec);
void __cdecl LYOpenlog(const char *banner);
BOOLEAN __cdecl looks_like_password(char *first, char *last);
void __cdecl LYSyslog(char *arg);
void LYCloselog(); // idb
_BOOL4 LYCheckUserAgent();
void validate_x_display(); // idb
void __cdecl summarize_x_display(char *display_option);
void SetupChosenShowColor(); // idb
int __cdecl add_it(char *text, int len);
void __cdecl addlbl(const char *text);
void LYoptions(); // idb
int __cdecl widest_choice(const char **choices);
void __cdecl show_choice(const char *choice, int width);
int __cdecl boolean_choice(int cur_choice, int line, int column, const char **choices);
void __cdecl terminate_options(int sig);
void edit_bookmarks(); // idb
int __cdecl popup_choice(int cur_choice, int line, int column, const char **choices, int i_length, int disabled, BOOLEAN for_mouse);
void __cdecl PutOptValues(FILE *fp, int value, OptValues *table);
BOOLEAN __cdecl GetOptValues(OptValues *table, char *value, int *result);
PostPair *__cdecl break_data(bstring *data);
BOOLEAN __cdecl isLynxOptionsPage(const char *address, const char *portion);
int __cdecl postoptions(DocInfo *newdoc);
char *NewSecureValue(); // idb
void __cdecl PutLabel(FILE *fp, const char *name, const char *value);
const char *__cdecl check_if_write_lynxrc(const char **table);
const char *will_save_cookies(); // idb
const char *will_save_images(); // idb
void __cdecl LYMenuVisitedLinks(FILE *fp0, int disable_all);
int __cdecl gen_options(char **newfile);
BOOLEAN __cdecl is_true(char *string);
char *__cdecl find_colon(char *buffer);
void __cdecl free_item_list(lynx_list_item_type **ptr);
void free_all_item_lists(); // idb
void __cdecl add_item_to_list(char *buffer, lynx_list_item_type **list_ptr, int special);
lynx_list_item_type *__cdecl find_item_by_number(lynx_list_item_type *list_ptr, char *number);
int __cdecl match_item_by_name(lynx_list_item_type *ptr, char *name, BOOLEAN only_overriders);
int __cdecl check_color(char *color, int the_default);
const char *__cdecl lookup_color(int code);
void __cdecl exit_with_color_syntax(char *error_line);
void __cdecl parse_color(char *buffer);
int __cdecl assume_charset_fun_0(char *value);
int __cdecl assume_local_charset_fun_0(char *value);
int __cdecl assume_unrec_charset_fun_0(char *value);
int __cdecl character_set_fun(char *value);
int __cdecl outgoing_mail_charset_fun(char *value);
int __cdecl assumed_color_fun(char *buffer);
int __cdecl color_fun(char *value);
int __cdecl default_colors_fun(char *value);
int __cdecl default_bookmark_file_fun(char *value);
int __cdecl default_cache_size_fun(char *value);
int __cdecl default_editor_fun(char *value);
int __cdecl numbers_as_arrows_fun(char *value);
int __cdecl dired_menu_fun(char *value);
int __cdecl jumpfile_fun(char *value);
int __cdecl keymap_fun(char *key);
int __cdecl localhost_alias_fun(char *value);
int __cdecl lynxcgi_environment_fun(char *value);
int __cdecl lynx_sig_file_fun(char *value);
int __cdecl news_chunk_size_fun(char *value);
int __cdecl news_max_chunk_fun(char *value);
int __cdecl news_posting_fun(char *value);
int __cdecl cern_rulesfile_fun(char *value);
int __cdecl referer_with_query_fun(char *value);
int __cdecl suffix_fun(char *value);
int __cdecl suffix_order_fun(char *value);
int __cdecl system_editor_fun(char *value);
int __cdecl viewer_fun(char *value);
int __cdecl nonrest_sigwinch_fun(char *value);
void __cdecl html_src_bad_syntax(char *value, char *option_name);
int __cdecl parse_html_src_spec(HTlexeme lexeme_code, char *value, char *option_name);
int __cdecl psrcspec_fun(char *s);
int __cdecl read_htmlsrc_attrname_xform(char *str);
int __cdecl read_htmlsrc_tagname_xform(char *str);
void free_lynx_cfg(); // idb
Config_Type_0 *__cdecl lookup_config(char *name);
char *__cdecl actual_filename(const char *cfg_filename, const char *parent_filename, const char *dft_filename);
FILE *__cdecl LYOpenCFG(const char *cfg_filename, const char *parent_filename, const char *dft_filename);
void __cdecl LYSetConfigValue(char *name, char *value);
void __cdecl do_read_cfg(const char *cfg_filename, const char *parent_filename, int nesting_level, FILE *fp0, optidx_set_t *allowed);
void __cdecl read_cfg(const char *cfg_filename, const char *parent_filename, int nesting_level, FILE *fp0);
void __cdecl extra_cfg_link(FILE *fp, const char *href, const char *name);
int __cdecl lynx_cfg_infopage(DocInfo *newdoc);
int __cdecl lynx_compile_opts(DocInfo *newdoc);
BOOLEAN __cdecl link_has_target(int cur, char *target);
int __cdecl check_next_target_in_links(int *cur, char *target);
int __cdecl check_prev_target_in_links(int *cur, char *target);
BOOLEAN __cdecl textsearch(DocInfo *cur_doc, char *prev_target, int target_size, int direction);
void __cdecl trace_history(const char *tag);
void __cdecl LYAddVisitedLink(DocInfo *doc);
BOOLEAN __cdecl LYwouldPush(const char *title, const char *docurl);
void __cdecl LYFreePostData(DocInfo *doc);
void __cdecl LYFreeDocInfo(DocInfo *doc);
void clean_extra_history(); // idb
int __cdecl are_identical(HistInfo *doc, DocInfo *doc1);
void __cdecl LYAllocHistory(int entries);
int __cdecl LYpush(DocInfo *doc, BOOLEAN force_push);
void __cdecl LYpop(DocInfo *doc);
void __cdecl LYhist_prev(DocInfo *doc);
void __cdecl LYhist_prev_register(DocInfo *doc);
int __cdecl LYhist_next(DocInfo *doc, DocInfo *newdoc);
void __cdecl LYpop_num(int number, DocInfo *doc);
int __cdecl showhistory(char **newfile);
BOOLEAN __cdecl historytarget(DocInfo *newdoc);
int __cdecl LYShowVisitedLinks(char **newfile);
void __cdecl to_stack(char *str);
void __cdecl LYstatusline_messages_on_exit(char **buf);
void __cdecl LYstore_message2(const char *message, const char *argument);
void __cdecl LYstore_message(const char *message);
int __cdecl LYLoadMESSAGES(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
char **__cdecl options_list(OptionType *opt_ptr);
int __cdecl change_form_link_ex(int cur, DocInfo *newdoc, BOOLEAN *refresh_screen, BOOLEAN use_last_tfpos, BOOLEAN immediate_submit, BOOLEAN redraw_only);
int __cdecl change_form_link(int cur, DocInfo *newdoc, BOOLEAN *refresh_screen, BOOLEAN use_last_tfpos, BOOLEAN immediate_submit);
void __cdecl LYSetLastTFPos(int pos);
int __cdecl form_getstr(int cur, BOOLEAN use_last_tfpos, BOOLEAN redraw_only);
void __cdecl show_formlink_statusline(const FormInfo *form, int for_what);
void __cdecl set_environ(int name, const char *value, const char *no_value);
char *__cdecl suggested_filename(DocInfo *newdoc);
void __cdecl SetupFilename(char *filename, const char *sug_filename);
int __cdecl RecallFilename(char *filename, BOOLEAN *first, int *now, int *total, int flag);
BOOLEAN __cdecl confirm_by_pages(const char *prompt, int lines_in_file, int lines_per_page);
void __cdecl send_file_to_file(DocInfo *newdoc, char *content_base, char *sug_filename);
void __cdecl send_file_to_mail(DocInfo *newdoc, char *content_base, char *content_location);
void __cdecl send_file_to_printer(DocInfo *newdoc, char *content_base, char *sug_filename, int printer_number);
void __cdecl send_file_to_screen(DocInfo *newdoc, char *content_base, BOOLEAN Lpansi);
int __cdecl printfile(DocInfo *newdoc);
char *__cdecl subject_translate8bit(char *source);
int __cdecl print_options(char **newfile, const char *printed_url, int lines_in_file);
char *GetFileName(); // idb
BOOLEAN __cdecl getBool(char *src);
const char *__cdecl LYputEnum(Config_Enum *table, int value);
BOOLEAN __cdecl LYgetEnum(Config_Enum *table, char *name, int *result);
int __cdecl get_assume_charset(char *value);
void __cdecl put_assume_charset(FILE *fp, config_type *tbl);
int __cdecl get_display_charset(char *value);
void __cdecl put_display_charset(FILE *fp, config_type *tbl);
int __cdecl get_editor(char *value);
void __cdecl put_editor(FILE *fp, config_type *tbl);
int __cdecl get_tagsoup(char *value);
void __cdecl put_tagsoup(FILE *fp, config_type *tbl);
Config_Type_1 *__cdecl lookup_config_0(const char *name);
int __cdecl f(char *c);
int __cdecl read_rc(int val);
void __cdecl read_rc(FILE *fp);
void __cdecl write_list(FILE *fp, const char *list);
void __cdecl explain_keypad_mode(FILE *fp);
int __cdecl save_rc(FILE *fp);
BOOLEAN __cdecl will_save_rc(const char *name);
int __cdecl enable_lynxrc(char *value);
void __cdecl LYDownload(char *line);
int __cdecl SuffixIs(char *filename, const char *suffix);
int __cdecl LYdownload_options(char **newfile, char *data_file);
BOOLEAN __cdecl message_has_content(const char *filename, BOOLEAN *nonspaces);
char *__cdecl LYNewsPost(char *newsgroups, BOOLEAN followup);
void __cdecl terminate_message(int sig);
HTList *LYcommandList(); // idb
Kcmd *__cdecl LYKeycodeToKcmd(LYKeymapCode code);
Kcmd *__cdecl LYStringToKcmd(const char *name);
char *__cdecl LYKeycodeToString(int c, BOOLEAN upper8);
int __cdecl LYStringToKeycode(char *src);
char *__cdecl pretty_html(int c);
char *__cdecl format_binding(LYKeymap_t *table, int i);
void __cdecl print_binding(HTStream *target, int i, BOOLEAN both);
int __cdecl lacname_to_lac(const char *func);
int __cdecl lecname_to_lec(const char *func);
int __cdecl lkcstring_to_lkc(const char *src);
int __cdecl LYLoadKeymap(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
int __cdecl remap(char *key, const char *func, BOOLEAN for_dired);
void __cdecl set_any_keys(ANY_KEYS *table, int size);
void __cdecl reset_any_keys(ANY_KEYS *table, int size);
void set_vms_keys(); // idb
void set_vi_keys(); // idb
void reset_vi_keys(); // idb
void set_emacs_keys(); // idb
void reset_emacs_keys(); // idb
void set_numbers_as_arrows(); // idb
void reset_numbers_as_arrows(); // idb
char *__cdecl key_for_func(int func);
char *__cdecl fmt_keys(int lkc_first, int lkc_second);
int __cdecl best_reverse_keymap(int lac);
char *__cdecl key_for_func_ext(int lac, int context_code);
BOOLEAN __cdecl LYisNonAlnumKeyname(int ch_0, int KeyName);
int __cdecl LYReverseKeymap(int KeyName);
void __cdecl strtolower(char *i);
void __cdecl actually_set_style(HTStructured *me);
void __cdecl change_paragraph_style(HTStructured *me, HTStyle *style);
BOOLEAN __cdecl LYBadHTML(HTStructured *me);
void __cdecl HTML_put_character(HTStructured *me, char c);
void __cdecl HTML_put_string(HTStructured *me, const char *s);
void __cdecl HTML_write(HTStructured *me, const char *s, int l);
void __cdecl addClassName(const char *prefix, const char *actual, int length);
void __cdecl HTMLSRC_apply_markup(HTStructured *context, HTlexeme lexeme, BOOLEAN start, int tag_charset);
void __cdecl LYStartArea(HTStructured *obj, const char *href, const char *alt, const char *title, int tag_charset);
void __cdecl LYHandleFIG(HTStructured *me, const BOOLEAN *present, const char **value, BOOLEAN isobject, BOOLEAN imagemap, const char *id, const char *src, BOOLEAN convert, BOOLEAN start, BOOLEAN *intern_flag);
void __cdecl clear_objectdata(HTStructured *me);
int __cdecl HTML_start_element(HTStructured *me, int element_number, const BOOLEAN *present, const char **value, int tag_charset, char **include);
int __cdecl HTML_end_element(HTStructured *me, int element_number, char **include);
int __cdecl HTML_put_entity(HTStructured *me, int entity_number);
void __cdecl HTML_free(HTStructured *me);
void __cdecl HTML_abort(HTStructured *me, HTError e);
void get_styles(); // idb
HTStyle *__cdecl LYstyles(int style_number);
HTStructured *__cdecl HTML_new(HTParentAnchor *anchor, HTFormat format_out, HTStream_0 *stream);
void __cdecl CacheThru_do_free(HTStream_0 *me);
void __cdecl CacheThru_free(HTStream_0 *me);
void __cdecl CacheThru_abort(HTStream_0 *me, HTError e);
void __cdecl CacheThru_put_character(HTStream_0 *me, char c_in);
void __cdecl CacheThru_put_string(HTStream_0 *me, const char *str);
void __cdecl CacheThru_write(HTStream_0 *me, const char *str, int l);
HTStream_0 *__cdecl CacheThru_new(HTParentAnchor *anchor, HTStream_0 *target);
HTStream_0 *__cdecl HTMLToPlain(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink);
HTStream_0 *__cdecl HTMLParsedPresent(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink);
HTStream_0 *__cdecl HTMLToC(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink);
HTStream_0 *__cdecl HTMLPresent(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink);
int __cdecl HTLoadError(HTStream_0 *sink, int number, const char *message);
char *__cdecl MakeNewTitle(const char **value, int src_type);
char *__cdecl MakeNewImageValue(const char **value);
char *__cdecl MakeNewMapValue(const char **value, const char *mapstr);
void __cdecl HTFWriter_error(HTStream_1 *me, char *id);
void __cdecl HTFWriter_put_character(HTStream_1 *me, char c);
void __cdecl HTFWriter_put_string(HTStream_1 *me, const char *s);
void __cdecl HTFWriter_write(HTStream_1 *me, const char *s, int l);
void __cdecl HTFWriter_free(HTStream_1 *me);
void __cdecl HTFWriter_abort(HTStream_1 *me, HTError e);
HTStream_1 *__cdecl HTFWriter_new(FILE *fp);
char *__cdecl mailcap_substitute(HTParentAnchor *anchor, HTPresentation *pres, char *fnam);
HTStream_1 *__cdecl HTSaveAndExecute(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink);
HTStream_1 *__cdecl HTSaveToFile(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink);
HTStream_1 *__cdecl HTCompressed(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink);
HTStream_1 *__cdecl HTDumpToStdout(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink);
void HTFormatInit(); // idb
void HTPreparsedFormatInit(); // idb
char *__cdecl GetCommand(char *s, char **t);
char *__cdecl Cleanse(char *s);
void __cdecl TrimCommand(char *command);
int __cdecl ProcessMailcapEntry(FILE *fp, MailcapEntry *mc, AcceptMedia media);
const char *__cdecl LYSkipQuoted(const char *s);
const char *__cdecl LYSkipToken(const char *s);
const char *__cdecl LYSkipValue(const char *s);
char *__cdecl LYCopyValue(const char *s);
char *__cdecl LYGetContentType(const char *name, const char *params);
BOOLEAN __cdecl LYMailcapUsesPctS(const char *controlstring);
int __cdecl BuildCommand(HTChunk *cmd, const char *controlstring, const char *TmpFileName, const char *params);
int __cdecl LYTestMailcapCommand(const char *testcommand, const char *params);
char *__cdecl LYMakeMailcapCommand(const char *command, const char *params, const char *filename);
int __cdecl RememberTestResult(int mode, char *cmd, int result);
int __cdecl PassesTest(MailcapEntry *mc);
int __cdecl ProcessMailcapFile(char *file, AcceptMedia media);
int __cdecl ExitWithError(const char *txt);
int __cdecl HTLoadTypesConfigFile(char *fn, AcceptMedia media);
void HTFileInit(); // idb
int __cdecl HTGetLine(char *s, int n, FILE *f);
void __cdecl HTGetWord(char *word, char *line, char stop, char stop2);
int __cdecl HTLoadExtensionsConfigFile(char *fn);
HTStyleSheet *__cdecl DefaultStyle(HTStyle ***result_array);
int __cdecl LYUpload(char *line);
int __cdecl LYUpload_options(char **newfile, char *directory);
void no_leak_checking(); // idb
int __cdecl LYatexit(void (*function)(void));
void LYCompleteExit(); // idb
void __cdecl __noreturn LYexit(int status);
void __cdecl outofmem(const char *fname, const char *func);
void LYJumpTable_free(); // idb
void __cdecl LYAddJumpShortcut(HTList *historyp, char *shortcut);
BOOLEAN __cdecl LYJumpInit(char *config);
char *__cdecl LYJump(int key);
unsigned int __cdecl LYRead_Jumpfile(JumpTable *jtp);
int __cdecl LYCompare(const void *e1, const void *e2);
int __cdecl showlist(DocInfo *newdoc, BOOLEAN titles);
void __cdecl print_refs(FILE *fp, BOOLEAN titles, int refs);
void __cdecl print_hidden_refs(FILE *fp, int refs, int hidden_links);
void __cdecl printlist(FILE *fp, BOOLEAN titles);
void __cdecl remember_alloced(void *ptr);
void __cdecl add_environment_value(const char *env_value);
void __cdecl add_lynxcgi_environment(const char *variable_name);
BOOLEAN __cdecl can_exec_cgi(const char *linktext, const char *linkargs);
int __cdecl LYLoadCGI(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
void __cdecl final_perror(const char *msg, BOOLEAN clean_flag);
void __cdecl exit_with_perror(const char *msg);
BOOLEAN __cdecl lookup_link(char *target);
void __cdecl add_to_table(char *target);
void __cdecl add_to_traverse_list(char *fname, char *prev_link_name);
void dump_traversal_history(); // idb
void __cdecl add_to_reject_list(char *target);
BOOLEAN __cdecl lookup_reject(char *target);
int __cdecl EditBinding(int xlkc);
BOOLEAN __cdecl LYRemapEditBinding(int xlkc, int lec, int select_edi);
int __cdecl LYKeyForEditAction(int lec);
int __cdecl LYEditKeyForAction(int lac, int *pmodkey);
int LYEditmapDeclared(); // idb
void __cdecl HTMLSetCharacterHandling(int i);
void __cdecl Set_HTCJK(const char *inMIMEname, const char *outMIMEname);
void __cdecl HTMLSetRawModeDefault(int i);
void __cdecl HTMLSetUseDefaultRawMode(int i, BOOLEAN modeflag);
void __cdecl HTMLSetHaveCJKCharacterSet(int i);
void __cdecl HTMLSetDisplayCharsetMatchLocale(int i);
int __cdecl UCGetLYhndl_byAnyName(char *value);
const char *__cdecl HTMLGetEntityName(UCode_t code);
UCode_t __cdecl HTMLGetEntityUCValue(const char *name);
void __cdecl HTMLUseCharacterSet(int i);
int LYCharSetsDeclared(); // idb
void __cdecl LYEntify(char **str, BOOLEAN isTITLE);
void __cdecl LYTrimHead(char *str);
void __cdecl LYTrimTail(char *str);
char *__cdecl LYFindEndOfComment(char *str);
void __cdecl LYFillLocalFileURL(char **href, const char *base);
void __cdecl LYAddMETAcharsetToFD(FILE *fd, int disp_chndl);
char *__cdecl LYUppercaseA_OL_String(int seqnum);
char *__cdecl LYLowercaseA_OL_String(int seqnum);
char *__cdecl LYUppercaseI_OL_String(int seqnum);
char *__cdecl LYLowercaseI_OL_String(int seqnum);
void __cdecl LYZero_OL_Counter(HTStructured_0 *me);
void __cdecl LYGetChartransInfo(HTStructured_0 *me);
char *__cdecl UCPutUtf8ToBuffer(char *q, UCode_t code, BOOLEAN terminate);
char **__cdecl LYUCFullyTranslateString(char **str, int cs_from, int cs_to, BOOLEAN do_ent, BOOLEAN use_lynx_specials, BOOLEAN plain_space, BOOLEAN hidden, BOOLEAN Back, CharUtil_st stype);
BOOLEAN __cdecl LYUCTranslateHTMLString(char **str, int cs_from, int cs_to, BOOLEAN use_lynx_specials, BOOLEAN plain_space, BOOLEAN hidden, CharUtil_st stype);
BOOLEAN __cdecl LYUCTranslateBackFormData(char **str, int cs_from, int cs_to, BOOLEAN plain_space);
char *__cdecl LYParseTagParam(char *from, const char *name);
void __cdecl LYParseRefreshURL(char *content, char **p_seconds, char **p_address);
void __cdecl LYHandleMETA(HTStructured_0 *me, const BOOLEAN *present, const char **value, char **include);
void __cdecl LYHandlePlike(HTStructured_0 *me, const BOOLEAN *present, const char **value, char **include, int align_idx, BOOLEAN start);
void __cdecl LYHandleSELECT(HTStructured_0 *me, const BOOLEAN *present, const char **value, char **include, BOOLEAN start);
int __cdecl LYLegitimizeHREF(HTStructured_0 *me, char **href, BOOLEAN force_slash, BOOLEAN strip_dots);
void __cdecl LYCheckForContentBase(HTStructured_0 *me);
void __cdecl LYCheckForID(HTStructured_0 *me, const BOOLEAN *present, const char **value, int attribute);
void __cdecl LYHandleID(HTStructured_0 *me, const char *id);
BOOLEAN __cdecl LYoverride_default_alignment(HTStructured_0 *me);
void __cdecl LYEnsureDoubleSpace(HTStructured_0 *me);
void __cdecl LYEnsureSingleSpace(HTStructured_0 *me);
void __cdecl LYResetParagraphAlignment(HTStructured_0 *me);
BOOLEAN __cdecl LYCheckForCSI(HTParentAnchor *anchor, char **url);
BOOLEAN __cdecl LYCommentHacks(HTParentAnchor *anchor, const char *comment);
void __cdecl LYformTitle(char **dst, const char *src);
void __cdecl ImageMapList_free(HTList *theList);
BOOLEAN __cdecl LYAddImageMap(char *address, char *title, HTParentAnchor *node_anchor);
BOOLEAN __cdecl LYAddMapElement(char *map, char *address, char *title, HTParentAnchor *node_anchor, BOOLEAN intern_flag);
BOOLEAN __cdecl LYHaveImageMap(char *address);
void __cdecl fill_DocAddress(DocAddress *wwwdoc, char *address, HTParentAnchor *anAnchor, HTParentAnchor **punderlying);
HTList *__cdecl get_the_list(DocAddress *wwwdoc, char *address, HTParentAnchor *anchor, HTParentAnchor **punderlying);
int __cdecl LYLoadIMGmap(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
void __cdecl LYPrintImgMaps(FILE *fp);
void __cdecl MemAllocCopy(char **dest, const char *start, const char *end);
cookie *newCookie(); // idb
void __cdecl freeCookie(cookie *co);
BOOLEAN __cdecl host_matches(const char *A, const char *B);
BOOLEAN __cdecl port_matches(int port, const char *list);
int __cdecl ignore_trailing_slash(const char *a);
BOOLEAN __cdecl is_prefix(const char *a, const char *b);
domain_entry *__cdecl find_domain_entry(const char *name);
void __cdecl store_cookie(cookie *co, const char *hostname, const char *path);
char *__cdecl scan_cookie_sublist(char *hostname, char *path, int port, HTList *sublist, char *header, BOOLEAN secure);
char *__cdecl alloc_attr_value(const char *value_start, const char *value_end);
unsigned int __cdecl parse_attribute(unsigned int flags, cookie *cur_cookie, int *cookie_len, const char *attr_start, int attr_len, char *value, const char *address, char *hostname, int port);
void __cdecl LYProcessSetCookies(const char *SetCookie, const char *SetCookie2, const char *address, char *hostname, char *path, int port);
void __cdecl LYSetCookie(const char *SetCookie, const char *SetCookie2, const char *address);
char *__cdecl LYAddCookieHeader(char *hostname, char *path, int port, BOOLEAN secure);
void __cdecl LYLoadCookies(char *cookie_file);
FILE *__cdecl NewCookieFile(char *cookie_file);
void __cdecl LYStoreCookies(char *cookie_file);
int __cdecl LYHandleCookies(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
void __cdecl cookie_domain_flag_set(char *domainstr, int flag);
void LYConfigCookies(); // idb
char *__cdecl TrimLowercase(char *buffer);
void __cdecl parse_either(char *attrs, int dft_color, int *monop, int *colorp);
void __cdecl parse_attributes(char *mono, char *fg, char *bg, int style, char *element);
void __cdecl parse_style(char *param);
void style_deleteStyleList(); // idb
void free_colorstylestuff(); // idb
void initialise_default_stylesheet(); // idb
void style_initialiseHashTable(); // idb
void parse_userstyles(); // idb
void __cdecl HStyle_addStyle(char *buffer);
int __cdecl style_readFromFileREC(char *lss_filename, char *parent_filename);
int __cdecl style_readFromFile(char *filename);
void __cdecl TrimColorClass(const char *tagname, char *styleclassname, int *phcode);
void __cdecl FastTrimColorClass(const char *tag_name, int name_len, char *stylename, char **pstylename_end, int *phcode);
void cache_tag_styles(); // idb
unsigned int *__cdecl RefCachedStyle(int y, int x);
BOOLEAN __cdecl ValidCachedStyle(int y, int x);
unsigned int __cdecl GetCachedStyle(int y, int x);
void __cdecl SetCachedStyle(int y, int x, unsigned int value);
void ResetCachedStyles(); // idb
void FreeCachedStyles(); // idb
int __cdecl hash_code(const char *string);
int __cdecl hash_code_lowercase_on_fly(const char *string);
int __cdecl hash_code_aggregate_char(char c, int hash);
int __cdecl hash_code_aggregate_lower_str(const char *string, int hash_was);
int __cdecl html_src_tag_index(char *tagname);
void __cdecl append_close_tag(char *tagname, HT_tagspec **head, HT_tagspec **tail);
void __cdecl append_open_tag(char *tagname, char *classname, HT_tagspec **head, HT_tagspec **tail);
int __cdecl html_src_parse_tagspec(char *ts, HTlexeme lexeme, BOOLEAN checkonly, BOOLEAN isstart);
void __cdecl html_src_clean_item(HTlexeme l);
void html_src_clean_data(); // idb
void html_src_on_lynxcfg_reload(); // idb
void __cdecl failed_init(const char *tag, int lexeme);
void __cdecl HTMLSRC_init_caches(BOOLEAN dont_exit);
const char *__cdecl cellstate_s(cellstate_t state);
STable_info *__cdecl Stbl_startTABLE(__int16 alignment);
void __cdecl free_rowinfo(STable_rowinfo *me);
void __cdecl Stbl_free(STable_info *me);
int __cdecl Stbl_addCellToRow(STable_rowinfo *me, STable_cellinfo *colinfo, int ncolinfo, STable_states *s, int colspan, int alignment, int isheader, int lineno, int *ppos);
int __cdecl Stbl_reserveCellsInRow(STable_rowinfo *me, int icell, int colspan);
int __cdecl Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td, int lineno, int pos);
int __cdecl Stbl_reserveCellsInTable(STable_info *me, int icell, int colspan, int rowspan);
void __cdecl Stbl_cancelRowSpans(STable_info *me);
int __cdecl Stbl_addRowToTable(STable_info *me, int alignment, int lineno);
int __cdecl Stbl_finishRowInTable(STable_info *me);
void __cdecl update_sumcols0(STable_cellinfo *sumcols, STable_rowinfo *lastrow, int pos, int len, int icell, int ispan, int allocated_sumcols);
int __cdecl get_remaining_colspan(STable_rowinfo *me, STable_cellinfo *colinfo, int ncolinfo, int colspan, int ncols_sofar);
int __cdecl Stbl_fakeFinishCellInTable(STable_info *me, STable_rowinfo *lastrow, int lineno, int finishing);
int __cdecl Stbl_addCellToTable(STable_info *me, int colspan, int rowspan, int alignment, int isheader, int lineno, int offset_not_used_yet, int pos);
int __cdecl Stbl_finishCellInTable(STable_info *me, int end_td, int lineno, int offset, int pos);
int __cdecl Stbl_addColInfo(STable_info *me, int colspan, __int16 alignment, BOOLEAN isgroup);
int __cdecl Stbl_finishColGroup(STable_info *me);
int __cdecl Stbl_addRowGroup(STable_info *me, __int16 alignment);
int __cdecl Stbl_finishTABLE(STable_info *me);
__int16 __cdecl Stbl_getAlignment(STable_info *me);
int __cdecl get_fixup_positions(STable_rowinfo *me, int *oldpos, int *newpos, STable_cellinfo *sumcols);
int __cdecl Stbl_getFixupPositions(STable_info *me, int lineno, int *oldpos, int *newpos);
int __cdecl Stbl_getStartLine(STable_info *me);
int __cdecl Stbl_getStartLineDeep(STable_info *me);
void __cdecl Stbl_update_enclosing(STable_info *me, int max_width, int last_lineno);
void __cdecl Stbl_set_enclosing(STable_info *me, STable_info *enclosing, _TextAnchor *enclosing_last_anchor_before_stbl);
STable_info *__cdecl Stbl_get_enclosing(STable_info *me);
_TextAnchor *__cdecl Stbl_get_last_anchor_before(STable_info *me);
void __cdecl date_error(const char *s);
time_t __cdecl ToSeconds(time_t Hours, time_t Minutes, time_t Seconds, MERIDIAN Meridian);
time_t __cdecl Convert(time_t Month, time_t Day, time_t Year, time_t Hours, time_t Minutes, time_t Seconds, MERIDIAN Meridian, DSTMODE dst);
time_t __cdecl DSTcorrect(time_t Start, time_t Future);
time_t __cdecl RelativeMonth(time_t Start, time_t RelMonth);
int __cdecl LookupWord(char *buff, int length);
int date_lex(); // idb
int __cdecl GetTimeInfo(TIMEINFO *Now);
time_t __cdecl parsedate(char *p, TIMEINFO *now);
int yygrowstack(); // idb
int date_parse(); // idb
void __cdecl set_inverse_transl(int i);
unsigned __int16 *__cdecl set_translate(int m);
int __cdecl UC_valid_UC_charset(int UC_charset_hndl);
void __cdecl UC_con_set_trans(int UC_charset_in_hndl, int Gn, int update_flag);
int __cdecl con_insert_unipair(unsigned __int16 unicode, unsigned __int16 fontpos, int fordefault);
int __cdecl con_insert_unipair_str(unsigned __int16 unicode, const char *replace_str, int fordefault);
void __cdecl con_clear_unimap(int fordefault);
void __cdecl con_clear_unimap_str(int fordefault);
void con_set_default_unimap(); // idb
int __cdecl UC_con_set_unimap(int UC_charset_out_hndl, int update_flag);
int __cdecl UC_con_set_unimap_str(unsigned __int16 ct, unipair_str *list, int fordefault);
int __cdecl conv_uni_to_pc(int ucs, int usedefault);
int __cdecl conv_uni_to_str(char *outbuf, int buflen, int ucs, int usedefault);
void UCconsole_map_init(); // idb
int __cdecl UCTransUniChar(int unicode, int charset_out);
int __cdecl UCTransUniCharStr(char *outbuf, int buflen, int unicode, int charset_out, int chk_single_flag);
int __cdecl UC_MapGN(int UChndl, int update_flag);
int __cdecl UCTransChar(char ch_in, int charset_in, int charset_out);
UCode_t __cdecl UCTransJPToUni(char *inbuf, int buflen, int charset_in);
UCode_t __cdecl UCTransToUni(char ch_in, int charset_in);
int __cdecl UCReverseTransChar(char ch_out, int charset_in, int charset_out);
int __cdecl UCTransCharStr(char *outbuf, int buflen, char ch_in, int charset_in, int charset_out, int chk_single_flag);
int __cdecl UC_FindGN_byMIME(const char *UC_MIMEcharset);
int __cdecl UCGetRawUniMode_byLYhndl(int i);
int __cdecl getLYhndl_byCP(const char *prefix, const char *codepage);
int __cdecl UCGetLYhndl_byMIME(const char *value);
void UCreset_allocated_LYCharSets(); // idb
const char **__cdecl UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned int lowest8);
int __cdecl UC_Register_with_LYCharSets(int s, const char *UC_MIMEcharset, const char *UC_LYNXcharset, int lowest_eightbit);
void __cdecl UC_Charset_Setup(const char *UC_MIMEcharset, const char *UC_LYNXcharset, const unsigned __int8 *unicount, const unsigned __int16 *unitable, int nnuni, unimapdesc_str replacedesc, int lowest_eight, int UC_rawuni, int codepage);
int __cdecl UC_NoUctb_Register_with_LYCharSets(const char *UC_MIMEcharset, const char *UC_LYNXcharset, int lowest_eightbit, int UC_rawuni, int codepage);
void __cdecl UC_Charset_NoUctb_Setup(const char *UC_MIMEcharset, const char *UC_LYNXcharset, int trydefault, int lowest_eight, int UC_rawuni, int codepage);
void UCInit(); // idb
int __cdecl safeUCGetLYhndl_byMIME(const char *value);
void LYFindLocaleCharset(); // idb
BOOLEAN __cdecl UCCanUniTranslateFrom(int from);
BOOLEAN __cdecl UCCanTranslateUniTo(int to);
BOOLEAN __cdecl UCCanTranslateFromTo(int from, int to);
BOOLEAN __cdecl UCNeedNotTranslate(int from, int to);
void __cdecl UCSetTransParams(UCTransParams *pT, int cs_in, const LYUCcharset *p_in, int cs_out, const LYUCcharset *p_out);
void __cdecl UCTransParams_clear(UCTransParams *pT);
void __cdecl UCSetBoxChars(int cset, int *pvert_out, int *phori_out, int vert_in, int hori_in);
BOOLEAN __cdecl UCPutUtf8_charstring(HTStream *target, putc_func_t *myPutc, int code);
BOOLEAN __cdecl UCConvertUniToUtf8(UCode_t code, char *buffer);
UCode_t __cdecl UCGetUniFromUtf8String(char **ppuni);
void __cdecl UCChangeTerminalCodepage(int newcs, LYUCcharset *p);
void __cdecl format(char **result, char *fmt, char *parm);
char *__cdecl format_command(char *command, char *param);
char *__cdecl lookup_external(char *param, BOOLEAN only_overriders);
BOOLEAN __cdecl run_external(char *param, BOOLEAN only_overriders);
BOOLEAN __cdecl cannot_stat(const char *name);
BOOLEAN __cdecl ok_stat(const char *name, stat *sb);
BOOLEAN __cdecl ok_lstat(char *name, stat *sb);
BOOLEAN __cdecl ok_file_or_dir(stat *sb);
int __cdecl LYExecv(const char *path, char **argv, char *msg);
int __cdecl make_directory(char *path);
int __cdecl remove_file(char *path);
int __cdecl remove_directory(char *path);
int __cdecl touch_file(char *path);
int __cdecl move_file(char *source, char *target);
BOOLEAN __cdecl not_already_exists(char *name);
BOOLEAN __cdecl dir_has_same_owner(stat *info, int owner);
int remove_tagged(); // idb
int __cdecl modify_tagged(char *testpath);
int __cdecl modify_name(char *testpath);
int __cdecl modify_location(char *testpath);
int __cdecl local_modify(DocInfo *doc, char **newpath);
int __cdecl create_file(char *current_location);
int __cdecl create_directory(char *current_location);
int __cdecl local_create(DocInfo *doc);
int __cdecl remove_single(char *testpath);
int __cdecl local_remove(DocInfo *doc);
int __cdecl permit_bits(char *string_mode);
int __cdecl permit_location(char *destpath, char *srcpath, char **newpath);
void __cdecl tagflag(int flag, int cur);
void __cdecl showtags(HTList *t);
char *__cdecl DirectoryOf(char *pathname);
char *__cdecl match_op(const char *prefix, char *data);
char *__cdecl build_command(char *line, char *dirname, char *arg);
int __cdecl local_dired(DocInfo *doc);
int __cdecl dired_options(DocInfo *doc, char **newfile);
char *__cdecl get_filename(const char *prompt, char *buf, size_t bufsize);
void clear_tags(); // idb
void __cdecl add_menu_item(char *str);
void reset_dired_menu(); // idb
char *__cdecl render_item(const char *s, const char *path, const char *dir, char *buf, int bufsize, BOOLEAN url_syntax);
char *__cdecl HTStrip(char *s);
void __cdecl scan(char *name, struct_parts *parts);
char *__cdecl strchr_or_end(char *string, int ch_0);
char *__cdecl HTParsePort(char *host, int *portp);
char *__cdecl HTParse(const char *aName, const char *relatedName, int wanted);
const char *__cdecl HTParseAnchor(const char *aName);
void __cdecl HTSimplify(char *filename);
char *__cdecl HTRelative(const char *aName, const char *relatedName);
char *__cdecl HTEscape(const char *str, unsigned __int8 mask);
char *__cdecl HTEscapeUnsafe(const char *str);
char *__cdecl HTEscapeSP(const char *str, unsigned __int8 mask);
char __cdecl from_hex(char c);
char *__cdecl HTUnEscape(char *str);
char *__cdecl HTUnEscapeSome(char *str, const char *do_trans);
void __cdecl HTMake822Word(char **str, int quoted);
BOOLEAN __cdecl HTRegisterProtocol(HTProtocol *protocol);
void HTAccessInit(); // idb
BOOLEAN __cdecl override_proxy(const char *addr);
int __cdecl get_physical(const char *addr, HTParentAnchor *anchor);
void __cdecl LYUCPushAssumed(HTParentAnchor *anchor);
int LYUCPopAssumed(); // idb
int __cdecl HTLoad(const char *addr, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink);
HTStream *__cdecl HTSaveStream(HTParentAnchor *anchor);
BOOLEAN __cdecl HTLoadDocument(const char *full_address, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink);
BOOLEAN __cdecl HTLoadAbsolute(const DocAddress *docaddr);
BOOLEAN __cdecl HTLoadRelative(const char *relative_name, HTParentAnchor *here);
BOOLEAN __cdecl HTLoadAnchor(HTAnchor *destination);
char __cdecl hex_1(int i);
BOOLEAN __cdecl HTSearch(const char *keywords, HTParentAnchor *here);
BOOLEAN __cdecl HTSearchAbsolute(const char *keywords, char *indexname);
void __cdecl strip_userid(char *host);
BOOLEAN __cdecl acceptEncoding(int code);
int __cdecl HTLoadHTTP(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
char *__cdecl FormatStr(char **bufp, char *start, const char *entry);
char *__cdecl FormatNum(char **bufp, char *start, int entry);
void __cdecl LYListFmtParse(const char *fmtstr, DIRED *data, char *file, HTStructured_1 *target, char *tail);
void __cdecl HTSetSuffix5(const char *suffix, const char *representation, const char *encoding, const char *desc, double value);
char *__cdecl HTCacheFileName(const char *name);
char *__cdecl HTURLPath_toFile(const char *name, BOOLEAN expand_all, BOOLEAN is_remote);
char *__cdecl HTnameOfFile_WWW(const char *name, BOOLEAN WWW_prefix, BOOLEAN expand_all);
char *__cdecl WWW_nameOfFile(const char *name);
const char *__cdecl HTFileSuffix(HTAtom *rep, const char *enc);
HTFormat __cdecl HTFileFormat(const char *filename, HTAtom **pencoding, const char **pdesc);
HTFormat __cdecl HTCharsetFormat(HTFormat format, HTParentAnchor *anchor, int default_LYhndl);
void __cdecl LYGetFileInfo(const char *filename, HTParentAnchor **pfile_anchor, HTFormat *pformat, HTAtom **pencoding, const char **pdesc, const char **pcharset, int *pfile_cs);
float __cdecl HTFileValue(const char *filename);
CompressFileType __cdecl HTCompressFileType(const char *filename, const char *dots, int *rootlen);
const char *__cdecl HTCompressTypeToSuffix(CompressFileType method);
const char *__cdecl HTCompressTypeToEncoding(CompressFileType method);
CompressFileType __cdecl HTEncodingToCompressType(const char *coding);
CompressFileType __cdecl HTContentTypeToCompressType(const char *ct);
CompressFileType __cdecl HTContentToCompressType(HTParentAnchor *anchor);
BOOLEAN __cdecl HTEditable(const char *filename);
HTStream *__cdecl HTFileSaveStream(HTParentAnchor *anchor);
void __cdecl HTDirEntry(HTStructured_1 *target, const char *tail, const char *entry);
BOOLEAN __cdecl view_structured(HTFormat format_out);
void __cdecl HTStructured_doctype(HTStructured_1 *target, HTFormat format_out);
void __cdecl HTStructured_meta(HTStructured_1 *target, HTFormat format_out);
BOOLEAN __cdecl HTDirTitles(HTStructured_1 *target, HTParentAnchor *anchor, HTFormat format_out, BOOLEAN tildeIsTop);
void __cdecl do_readme(HTStructured_1 *target, const char *localname);
const char *__cdecl file_type(const char *path);
int __cdecl dired_cmp(void *a, void *b);
int __cdecl print_local_dir(DIR *dp, char *localname, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink);
int __cdecl HTStat(const char *filename, stat *data);
int __cdecl decompressAndParse(HTParentAnchor *anchor, HTFormat format_out, HTStream *sink, char *nodename, char *filename, HTAtom *myEncoding, HTFormat format, int *statusp);
int __cdecl HTLoadFile(const char *addr, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink);
const char *__cdecl HTGetProgramPath(ProgramPaths code);
void __cdecl HTSetProgramPath(ProgramPaths code, const char *path);
void HTInitProgramPaths(); // idb
HTBTree *__cdecl HTBTree_new(HTComparer comp);
void __cdecl HTBTElement_free(HTBTElement *element);
void __cdecl HTBTree_free(HTBTree *tree);
void __cdecl HTBTElementAndObject_free(HTBTElement *element);
void __cdecl HTBTreeAndObject_free(HTBTree *tree);
void *__cdecl HTBTree_search(HTBTree *tree, void *object);
void __cdecl HTBTree_add(HTBTree *tree, void *object);
HTBTElement *__cdecl HTBTree_next(HTBTree *tree, HTBTElement *ele);
char *__cdecl HTVMS_name(const char *nn, const char *fn);
int next_data_char(); // idb
int __cdecl close_connection(connection *con);
void init_help_message_cache(); // idb
void __cdecl help_message_cache_add(char *string);
char *help_message_cache_non_empty(); // idb
char *help_message_cache_contents(); // idb
int __cdecl write_cmd(const char *cmd);
BOOLEAN __cdecl find_response(HTList *list);
int __cdecl response(const char *cmd);
int __cdecl send_cmd_1(const char *verb);
int __cdecl send_cmd_2(const char *verb, const char *param);
int __cdecl set_mac_binary(eServerType ServerType);
void __cdecl get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList);
void __cdecl set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList);
int __cdecl get_connection(const char *arg, HTParentAnchor *anchor);
void reset_master_socket(); // idb
void __cdecl set_master_socket(int value);
int close_master_socket(); // idb
unsigned int get_listen_socket();
void set_years_and_date(); // idb
void __cdecl free_entryinfo_struct_contents(EntryInfo *entry_info);
BOOLEAN __cdecl is_ls_date(char *s);
void __cdecl parse_eplf_line(char *line, EntryInfo *info);
void __cdecl parse_ls_line(char *line, EntryInfo *entry_info);
void __cdecl parse_dls_line(char *line, EntryInfo *entry_info, char **pspilledname);
void __cdecl parse_vms_dir_entry(char *line, EntryInfo *entry_info);
void __cdecl parse_ms_windows_dir_entry(char *line, EntryInfo *entry_info);
void __cdecl parse_cms_dir_entry(char *line, EntryInfo *entry_info);
EntryInfo *__cdecl parse_dir_entry(char *entry, BOOLEAN *first, char **pspilledname);
int __cdecl compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2);
int __cdecl read_directory(HTParentAnchor *parent, const char *address, HTFormat format_out, HTStream *sink);
int __cdecl setup_connection(const char *name, HTParentAnchor *anchor);
int __cdecl HTFTPLoad(const char *name, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink);
void HTClearFTPPassword(); // idb
int __cdecl HTInetStatus(const char *where);
unsigned int __cdecl HTCardinal(int *pstatus, char **pp, unsigned int max_value);
const char *__cdecl HTInetString(SockA *soc_in);
BOOLEAN __cdecl valid_hostname(char *name);
void __cdecl quench(int sig);
void __cdecl dump_hostent(const char *msgprefix, const hostent *phost);
size_t __cdecl fill_rehostent(char *rehostent, size_t rehostentsize, const hostent *phost);
unsigned int __cdecl readit(int fd, char *buffer, unsigned int length);
hostent *__cdecl LYGetHostByName(char *str);
addrinfo *__cdecl HTGetAddrInfo(const char *str, const int defport);
void get_host_details(); // idb
char *HTHostName();
BOOLEAN __cdecl HTWasInterrupted(int *status);
void __cdecl set_timeout(timeval *timeoutp);
int __cdecl HTDoConnect(const char *url, const char *protocol, int default_port, int *s);
int __cdecl HTDoRead(int fildes, void *buf, unsigned int nbyte);
void __cdecl fake_put_character(void *p, char c);
const char *__cdecl state_name(sgml_state n);
HTElement *pool_alloc(); // idb
void __cdecl pool_free(HTElement *e);
void __cdecl HTMLSRC_apply_markup_0(HTStream_2 *context, HTlexeme lexeme, BOOLEAN start);
void __cdecl set_chartrans_handling(HTStream_2 *context, HTParentAnchor *anchor, int chndl);
void __cdecl change_chartrans_handling(HTStream_2 *context);
void __cdecl handle_attribute_name(HTStream_2 *context, const char *s);
void __cdecl handle_attribute_value(HTStream_2 *context, const char *s);
BOOLEAN __cdecl put_special_unicodes(HTStream_2 *context, UCode_t code);
void __cdecl put_pretty_entity(HTStream_2 *context, int term);
void __cdecl put_pretty_number(HTStream_2 *context);
void __cdecl handle_entity(HTStream_2 *context, char term);
void __cdecl handle_comment(HTStream_2 *context);
void __cdecl handle_identifier(HTStream_2 *context);
void __cdecl handle_doctype(HTStream_2 *context);
void __cdecl handle_marked(HTStream_2 *context);
void __cdecl handle_processing_instruction(HTStream_2 *context);
void __cdecl handle_sgmlent(HTStream_2 *context);
void __cdecl handle_sgmlele(HTStream_2 *context);
void __cdecl handle_sgmlatt(HTStream_2 *context);
BOOLEAN __cdecl element_valid_within(HTTag *new_tag, HTTag *stacked_tag, BOOLEAN direct);
canclose_t __cdecl can_close(HTTag *new_tag, HTTag *stacked_tag);
void __cdecl do_close_stacked(HTStream_2 *context);
int __cdecl is_on_stack(HTStream_2 *context, HTTag *old_tag);
void __cdecl end_element(HTStream_2 *context, HTTag *old_tag);
void __cdecl start_element(HTStream_2 *context);
HTTag *__cdecl SGMLFindTag(const SGML_dtd *dtd, const char *s);
void __cdecl SGML_free(HTStream_2 *context);
void __cdecl SGML_abort(HTStream_2 *context, HTError e);
void __cdecl transform_tag(HTStream_2 *context, HTChunk *string);
BOOLEAN __cdecl ignore_when_empty(HTTag *tag);
void __cdecl discard_empty(HTStream_2 *context);
BOOLEAN __cdecl end_if_prettysrc(HTStream_2 *context, HTChunk *string, char end_ch);
void __cdecl SGML_character(HTStream_2 *context, char c_in);
void __cdecl SGML_string(HTStream_2 *context, const char *str);
void __cdecl SGML_write(HTStream_2 *context, const char *str, int l);
HTStream_2 *__cdecl SGML_new(const SGML_dtd *dtd, HTParentAnchor *anchor, HTStructured *target);
int SGML_offset(); // idb
void __cdecl JISx0201TO0208_EUC(unsigned __int8 IHI, unsigned __int8 ILO, unsigned __int8 *OHI, unsigned __int8 *OLO);
int __cdecl IS_SJIS_STR(const unsigned __int8 *str);
unsigned __int8 *__cdecl SJIS_TO_JIS1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *JCODE);
unsigned __int8 *__cdecl JIS_TO_SJIS1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *SJCODE);
unsigned __int8 *__cdecl EUC_TO_SJIS1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *SJCODE);
void __cdecl JISx0201TO0208_SJIS(unsigned __int8, unsigned __int8 *, unsigned __int8 *);
unsigned __int8 *__cdecl SJIS_TO_EUC1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *data);
unsigned __int8 *__cdecl SJIS_TO_EUC(unsigned __int8 *src, unsigned __int8 *dst);
unsigned __int8 *__cdecl EUC_TO_SJIS(unsigned __int8 *src, unsigned __int8 *dst);
unsigned __int8 *__cdecl EUC_TO_JIS(unsigned __int8 *src, unsigned __int8 *dst, const char *toK, const char *toA);
const unsigned __int8 *__cdecl repairJIStoEUC(const unsigned __int8 *src, unsigned __int8 **dstp);
unsigned __int8 *__cdecl TO_EUC(const unsigned __int8 *jis, unsigned __int8 *euc);
int __cdecl is_EUC_JP(unsigned __int8 *euc);
void __cdecl TO_SJIS(const unsigned __int8 *arg, unsigned __int8 *sjis);
void __cdecl TO_JIS(const unsigned __int8 *arg, unsigned __int8 *jis);
void __cdecl HTSwitchDTD(int new_flag);
void __cdecl HTStartAnchor(HTStructured_1 *obj, const char *name, const char *href);
void __cdecl HTStartAnchor5(HTStructured_1 *obj, const char *name, const char *href, const char *linktype, int tag_charset);
void __cdecl HTStartIsIndex(HTStructured_1 *obj, const char *prompt, const char *href);
void __cdecl HTChunkInit(HTChunk *ch_0, int grow);
HTChunk *__cdecl HTChunkCreate(int grow);
HTChunk *__cdecl HTChunkCreateMayFail(int grow, int failok);
HTChunk *__cdecl HTChunkCreate2(int grow, size_t needed);
void __cdecl HTChunkClear(HTChunk *ch_0);
void __cdecl HTChunkFree(HTChunk *ch_0);
BOOLEAN __cdecl HTChunkRealloc(HTChunk *ch_0, int growby);
void __cdecl HTChunkPutc(HTChunk *ch_0, char c);
HTChunk *__cdecl HTChunkPutc2(HTChunk *ch_0, char c);
void __cdecl HTChunkEnsure(HTChunk *ch_0, int needed);
void __cdecl HTChunkPutb(HTChunk *ch_0, const char *b, int l);
HTChunk *__cdecl HTChunkPutb2(HTChunk *ch_0, const char *b, int l);
void __cdecl HTChunkPutUtf8Char(HTChunk *ch_0, UCode_t code);
void __cdecl HTChunkTerminate(HTChunk *ch_0);
void __cdecl HTChunkPuts(HTChunk *ch_0, const char *s);
HTChunk *__cdecl HTChunkPuts2(HTChunk *ch_0, const char *s);
void __cdecl HTPlain_getChartransInfo(HTStream_3 *me, HTParentAnchor *anchor);
void __cdecl HTPlain_put_character(HTStream_3 *me, char c);
void __cdecl HTPlain_put_string(HTStream_3 *me, const char *s);
void __cdecl HTPlain_write(HTStream_3 *me, const char *s, int l);
void __cdecl HTPlain_free(HTStream_3 *me);
void __cdecl HTPlain_abort(HTStream_3 *me, HTError e);
HTStream_3 *__cdecl HTPlainPresent(HTPresentation *pres, HTParentAnchor *anchor, HTStream_3 *sink);
void __cdecl flush_breaks(HTStructured_2 *me);
void __cdecl HTMLGen_flush(HTStructured_2 *me);
void __cdecl do_cstyle_flush(HTStructured_2 *me);
void __cdecl allow_break(HTStructured_2 *me, int new_cleanness, BOOLEAN dlbc);
void __cdecl HTMLGen_put_character(HTStructured_2 *me, char c);
void __cdecl HTMLGen_put_string(HTStructured_2 *me, const char *s);
void __cdecl HTMLGen_write(HTStructured_2 *me, const char *s, int l);
int __cdecl HTMLGen_start_element(HTStructured_2 *me, int element_number, const BOOLEAN *present, const char **value, int charset, char **insert);
int __cdecl HTMLGen_end_element(HTStructured_2 *me, int element_number, char **insert);
int __cdecl HTMLGen_put_entity(HTStructured_2 *me, int entity_number);
void __cdecl HTMLGen_free(HTStructured_2 *me);
void __cdecl PlainToHTML_free(HTStructured_2 *me);
void __cdecl HTMLGen_abort(HTStructured_2 *me, HTError e);
void __cdecl PlainToHTML_abort(HTStructured_2 *me, HTError e);
HTStructured_2 *__cdecl HTMLGenerator(HTStream_4 *output);
HTStream_4 *__cdecl HTPlainToHTML(HTPresentation *pres, HTParentAnchor *anchor, HTStream_4 *sink);
HTAtom *__cdecl HTAtom_for(const char *string);
BOOLEAN __cdecl mime_match(const char *name, const char *templ);
HTList *__cdecl HTAtom_templateMatches(const char *templ);
unsigned __int16 __cdecl HASH_FUNCTION(const char *cp_address);
HTParentAnchor0 *__cdecl HTParentAnchor0_new(const char *address, unsigned __int16 hash);
HTParentAnchor *__cdecl HTParentAnchor_new(HTParentAnchor0 *parent);
HTChildAnchor *__cdecl HTChildAnchor_new(HTParentAnchor0 *parent);
HTChildAnchor *__cdecl HText_pool_ChildAnchor_new(HTParentAnchor *parent);
BOOLEAN __cdecl HTSEquivalent(const char *s, const char *t);
BOOLEAN __cdecl HTBEquivalent(const bstring *s, const bstring *t);
int __cdecl compare_anchors(void *l, void *r);
HTChildAnchor *__cdecl HTAnchor_findNamedChild(HTParentAnchor0 *parent, const char *tag);
HTChildAnchor *__cdecl HTAnchor_addChild(HTParentAnchor *parent);
HTChildAnchor *__cdecl HTAnchor_findChildAndLink(HTParentAnchor *parent, const char *tag, const char *href, HTLinkType *ltype);
HTParentAnchor *__cdecl HTAnchor_findAddress(const DocAddress *newdoc);
HTParentAnchor0 *__cdecl HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc);
HTParentAnchor *__cdecl HTAnchor_findSimpleAddress(const char *url);
BOOLEAN __cdecl HTAnchor_link(HTChildAnchor *child, HTAnchor *destination, HTLinkType *type);
void __cdecl deleteLinks(HTChildAnchor *me);
BOOLEAN __cdecl HTAnchor_delete(HTParentAnchor0 *me);
void __cdecl HTAnchor_delete_links(HTParentAnchor *me);
void __cdecl HTParentAnchor_free(HTParentAnchor *me);
void __cdecl HTAnchor_clearSourceCache(HTParentAnchor *me);
HTParentAnchor *__cdecl HTAnchor_parent(HTAnchor *me);
void __cdecl HTAnchor_setDocument(HTParentAnchor *me, HyperDoc *doc);
HyperDoc *__cdecl HTAnchor_document(HTParentAnchor *me);
char *__cdecl HTAnchor_address(HTAnchor *me);
void __cdecl HTAnchor_setFormat(HTParentAnchor *me, HTFormat form);
HTFormat __cdecl HTAnchor_format(HTParentAnchor *me);
void __cdecl HTAnchor_setIndex(HTParentAnchor *me, const char *address);
void __cdecl HTAnchor_setPrompt(HTParentAnchor *me, const char *prompt);
BOOLEAN __cdecl HTAnchor_isIndex(HTParentAnchor *me);
BOOLEAN __cdecl HTAnchor_isISMAPScript(HTAnchor *me);
const char *__cdecl HTAnchor_style(HTParentAnchor *me);
void __cdecl HTAnchor_setStyle(HTParentAnchor *me, const char *style);
const char *__cdecl HTAnchor_title(HTParentAnchor *me);
void __cdecl HTAnchor_setTitle(HTParentAnchor *me, const char *title);
void __cdecl HTAnchor_appendTitle(HTParentAnchor *me, const char *title);
const char *__cdecl HTAnchor_bookmark(HTParentAnchor *me);
void __cdecl HTAnchor_setBookmark(HTParentAnchor *me, const char *bookmark);
const char *__cdecl HTAnchor_owner(HTParentAnchor *me);
void __cdecl HTAnchor_setOwner(HTParentAnchor *me, const char *owner);
const char *__cdecl HTAnchor_RevTitle(HTParentAnchor *me);
void __cdecl HTAnchor_setRevTitle(HTParentAnchor *me, const char *title);
const char *__cdecl HTAnchor_citehost(HTParentAnchor *me);
void __cdecl HTAnchor_setCitehost(HTParentAnchor *me, const char *citehost);
const char *__cdecl HTAnchor_SugFname(HTParentAnchor *me);
const char *__cdecl HTAnchor_content_type_params(HTParentAnchor *me);
const char *__cdecl HTAnchor_content_encoding(HTParentAnchor *me);
const char *__cdecl HTAnchor_content_type(HTParentAnchor *me);
const char *__cdecl HTAnchor_last_modified(HTParentAnchor *me);
const char *__cdecl HTAnchor_date(HTParentAnchor *me);
const char *__cdecl HTAnchor_server(HTParentAnchor *me);
BOOLEAN __cdecl HTAnchor_safe(HTParentAnchor *me);
const char *__cdecl HTAnchor_content_base(HTParentAnchor *me);
const char *__cdecl HTAnchor_content_location(HTParentAnchor *me);
const char *__cdecl HTAnchor_messageID(HTParentAnchor *me);
BOOLEAN __cdecl HTAnchor_setMessageID(HTParentAnchor *me, const char *messageid);
const char *__cdecl HTAnchor_subject(HTParentAnchor *me);
BOOLEAN __cdecl HTAnchor_setSubject(HTParentAnchor *me, const char *subject);
HTAnchor *__cdecl HTAnchor_followLink(HTChildAnchor *me);
HTAnchor *__cdecl HTAnchor_followTypedLink(HTChildAnchor *me, HTLinkType *type);
HTList *__cdecl HTAnchor_methods(HTParentAnchor *me);
void *__cdecl HTAnchor_protocol(HTParentAnchor *me);
void __cdecl HTAnchor_setProtocol(HTParentAnchor *me, void *protocol);
char *__cdecl HTAnchor_physical(HTParentAnchor *me);
void __cdecl HTAnchor_setPhysical(HTParentAnchor *me, char *physical);
LYUCcharset *__cdecl HTAnchor_getUCInfoStage(HTParentAnchor *me, int which_stage);
int __cdecl HTAnchor_getUCLYhndl(HTParentAnchor *me, int which_stage);
LYUCcharset *__cdecl HTAnchor_setUCInfoStage(HTParentAnchor *me, int LYhndl, int which_stage, int set_by);
LYUCcharset *__cdecl HTAnchor_resetUCInfoStage(HTParentAnchor *me, int LYhndl, int which_stage, int set_by);
LYUCcharset *__cdecl HTAnchor_copyUCInfoStage(HTParentAnchor *me, int to_stage, int from_stage, int set_by);
HTStyle *HTStyleNew(); // idb
HTStyle *__cdecl HTStyleNewNamed(const char *name);
HTStyle *__cdecl HTStyleFree(HTStyle *self);
HTStyle *__cdecl HTStyleNamed(HTStyleSheet *self, const char *name);
HTStyleSheet *__cdecl HTStyleSheetAddStyle(HTStyleSheet *self, HTStyle *style);
HTStyleSheet *__cdecl HTStyleSheetRemoveStyle(HTStyleSheet *self, HTStyle *style);
HTStyleSheet *HTStyleSheetNew(); // idb
HTStyleSheet *__cdecl HTStyleSheetFree(HTStyleSheet *self);
HTList *HTList_new(); // idb
void __cdecl HTList_delete(HTList *me);
HTList *__cdecl HTList_reverse(HTList *start);
HTList *__cdecl HTList_appendList(HTList *start, HTList *tail);
void __cdecl HTList_linkObject(HTList *me, void *newObject, HTList *newNode);
void __cdecl HTList_addObject(HTList *me, void *newObject);
void __cdecl HTList_appendObject(HTList *me, void *newObject);
void __cdecl HTList_insertObjectAt(HTList *me, void *newObject, int pos);
BOOLEAN __cdecl HTList_unlinkObject(HTList *me, void *oldObject);
BOOLEAN __cdecl HTList_removeObject(HTList *me, void *oldObject);
void *__cdecl HTList_removeObjectAt(HTList *me, int position);
void *__cdecl HTList_unlinkLastObject(HTList *me);
void *__cdecl HTList_removeLastObject(HTList *me);
void *__cdecl HTList_removeFirstObject(HTList *me);
int __cdecl HTList_count(HTList *me);
int __cdecl HTList_indexOf(HTList *me, void *object);
void *__cdecl HTList_objectAt(HTList *me, int position);
int __cdecl strcasecomp8(const char *a, const char *b);
int __cdecl strncasecomp8(const char *a, const char *b, int n);
int __cdecl strcasecomp(const char *a, const char *b);
int __cdecl strncasecomp(const char *a, const char *b, int n);
int __cdecl strcasecomp_asterisk(const char *a, const char *b);
char *__cdecl HTSACopy(char **dest, const char *src);
char *__cdecl HTSACat(char **dest, const char *src);
void __cdecl HTSAFree_extra(char *s);
char *__cdecl HTSACopy_extra(char **dest, const char *src);
char *__cdecl HTNextField(char **pstr);
char *__cdecl HTNextTok(char **pstr, const char *delims, const char *bracks, char *found);
char *__cdecl HTAlloc(char *ptr, size_t length);
char *__cdecl StrAllocVsprintf(char **pstr, size_t dst_len, const char *fmt, va_list *ap);
char *HTSprintf(char **pstr, const char *fmt, ...);
char *HTSprintf0(char **pstr, const char *fmt, ...);
char *__cdecl HTQuoteParameter(const char *parameter);
int __cdecl HTCountCommandArgs(const char *command);
const char *__cdecl HTAfterCommandArg(const char *command, int number);
void __cdecl HTAddXpand(char **result, const char *command, int number, const char *parameter);
void __cdecl HTAddToCmd(char **result, const char *command, int number, const char *string);
void __cdecl HTAddParam(char **result, const char *command, int number, const char *parameter);
void __cdecl HTEndParam(char **result, const char *command, int number);
void __cdecl HTSABCopy(bstring **dest, const char *src, int len);
void __cdecl HTSABCopy0(bstring **dest, const char *src);
void __cdecl HTSABCat(bstring **dest, const char *src, int len);
void __cdecl HTSABCat0(bstring **dest, const char *src);
BOOLEAN __cdecl HTSABEql(bstring *a, bstring *b);
void __cdecl HTSABFree(bstring **ptr);
bstring *HTBprintf(bstring **pstr, const char *fmt, ...);
void __cdecl trace_bstring2(const char *text, int size);
void __cdecl trace_bstring(bstring *data);
int __cdecl HTAddRule(HTRuleOp op, const char *pattern, const char *equiv, const char *cond_op, const char *cond);
void HTClearRules(); // idb
BOOLEAN __cdecl rule_cond_ok(rule *r);
char *__cdecl HTTranslate(const char *required);
int __cdecl HTSetConfiguration(char *config);
int __cdecl HTLoadRules(const char *filename);
void __cdecl HTSetPresentation(const char *representation, const char *command, const char *testcommand, double quality, double secs, double secs_per_byte, int maxbytes, AcceptMedia media);
void __cdecl HTSetConversion(const char *representation_in, const char *representation_out, HTConverter *converter, float quality, float secs, float secs_per_byte, int maxbytes, AcceptMedia media);
void __cdecl HTInitInput(int file_number);
int HTGetCharacter(); // idb
int __cdecl half_match(char *trial_type, char *target);
BOOLEAN __cdecl failsMailcap(HTPresentation *pres, HTParentAnchor *anchor);
HTPresentation *__cdecl HTFindPresentation(HTFormat rep_in, HTFormat rep_out, HTPresentation *fill_in, HTParentAnchor *anchor);
HTStream_5 *__cdecl HTStreamStack(HTFormat rep_in, HTFormat rep_out, HTStream_5 *sink, HTParentAnchor *anchor);
void __cdecl HTReorderPresentation(HTFormat rep_in, HTFormat rep_out);
void HTFilterPresentations(); // idb
float __cdecl HTStackValue(HTFormat rep_in, HTFormat rep_out, float initial_value, int length);
void HTDisplayPartial(); // idb
void HTFinishDisplayPartial(); // idb
int __cdecl HTCopy(HTParentAnchor *anchor, int file_number, void *handle, HTStream_5 *sink);
int __cdecl HTFileCopy(FILE *fp, HTStream_5 *sink);
int __cdecl HTMemCopy(HTChunk *chunk, HTStream_5 *sink);
int __cdecl HTGzFileCopy(gzFile gzfp, HTStream_5 *sink);
const char *__cdecl LynxZError(int status);
int __cdecl HTZzFileCopy(FILE *zzfp, HTStream_5 *sink);
void __cdecl HTCopyNoCR(HTParentAnchor *anchor, int file_number, HTStream_5 *sink);
int __cdecl HTParseSocket(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, int file_number, HTStream_5 *sink);
int __cdecl HTParseFile(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, FILE *fp, HTStream_5 *sink);
int __cdecl HTParseMem(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, HTChunk *chunk, HTStream_5 *sink);
int __cdecl HTCloseGzFile(gzFile gzfp);
int __cdecl HTParseGzFile(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, gzFile gzfp, HTStream_5 *sink);
int __cdecl HTParseZzFile(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, FILE *zzfp, HTStream_5 *sink);
void __cdecl NetToText_put_character(HTStream_5 *me, char net_char);
void __cdecl NetToText_put_string(HTStream_5 *me, const char *s);
void __cdecl NetToText_put_block(HTStream_5 *me, const char *s, int l);
void __cdecl NetToText_free(HTStream_5 *me);
void __cdecl NetToText_abort(HTStream_5 *me, HTError e);
HTStream_5 *__cdecl HTNetToText(HTStream_5 *sink);
void __cdecl HTErrorStream_put_character(HTStream_5 *me, char c);
void __cdecl HTErrorStream_put_string(HTStream_5 *me, const char *s);
void __cdecl HTErrorStream_write(HTStream_5 *me, const char *s, int l);
void __cdecl HTErrorStream_free(HTStream_5 *me);
void __cdecl HTErrorStream_abort(HTStream_5 *me, HTError e);
HTStream_5 *HTErrorStream(); // idb
void __cdecl HTMIME_TrimDoubleQuotes(char *value);
BOOLEAN __cdecl content_is_compressed(HTStream_6 *me);
void __cdecl dequote(char *url);
const char *__cdecl UncompressedContentType(HTStream_6 *me, CompressFileType method);
int __cdecl pumpData(HTStream_6 *me);
int __cdecl dispatchField(HTStream_6 *me);
void __cdecl HTMIME_put_character(HTStream_6 *me, char c);
void __cdecl HTMIME_put_string(HTStream_6 *me, const char *s);
void __cdecl HTMIME_write(HTStream_6 *me, const char *s, int l);
void __cdecl HTMIME_free(HTStream_6 *me);
void __cdecl HTMIME_abort(HTStream_6 *me, HTError e);
HTStream_6 *__cdecl HTMIMEConvert(HTPresentation *pres, HTParentAnchor *anchor, HTStream_6 *sink);
HTStream_6 *__cdecl HTNetMIME(HTPresentation *pres, HTParentAnchor *anchor, HTStream_6 *sink);
HTStream_6 *__cdecl HTMIMERedirect(HTPresentation *pres, HTParentAnchor *anchor, HTStream_6 *sink);
void __cdecl HTmmdec_base64(char **t, char *s);
void __cdecl HTmmdec_quote(char **t, char *s);
void __cdecl HTmmdecode(char **target, char *source);
int __cdecl HTrjis(char **t, char *s);
int __cdecl HTmaybekanji(int c1, int c2);
void free_NNTP_AuthInfo(); // idb
void load_NNTP_AuthInfo(); // idb
char *HTGetNewsHost();
void __cdecl HTSetNewsHost(const char *value);
int initialize();
int __cdecl response_0(char *command);
BOOLEAN __cdecl match(const char *unknown, const char *ctemplate);
NNTPAuthResult __cdecl HTHandleAuthInfo(char *host);
char *__cdecl author_name(char *email);
char *__cdecl author_address(char *email);
void __cdecl start_anchor(const char *href);
void __cdecl start_link(const char *href, const char *rev);
void __cdecl start_list(int seqnum);
void __cdecl write_anchor(const char *text, const char *addr);
void __cdecl write_anchors(char *text);
void abort_socket(); // idb
BOOLEAN __cdecl valid_header(char *line);
void __cdecl post_article(char *postfile);
char *__cdecl decode_mime(char **str);
int __cdecl read_article(HTParentAnchor *thisanchor);
int __cdecl read_list(char *arg);
int __cdecl read_group(const char *groupName, int first_required, int last_required);
int __cdecl HTLoadNews(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *stream);
void HTClearNNTPAuthInfo(); // idb
void init_acceptable(); // idb
char __cdecl from_hex_0(char c);
void __cdecl write_anchor_0(const char *text, const char *addr);
void __cdecl parse_menu(const char *arg, HTParentAnchor *anAnchor);
void __cdecl parse_cso(const char *arg, HTParentAnchor *anAnchor);
void __cdecl display_cso(const char *arg, HTParentAnchor *anAnchor);
void __cdecl display_index(const char *arg, HTParentAnchor *anAnchor);
void __cdecl de_escape(char *command, const char *selector);
void free_CSOfields(); // idb
void __cdecl interpret_cso_key(const char *key, char *buf, int *length, CSOformgen_context *ctx, HTStream *Target);
int __cdecl parse_cso_field_info(CSOfield_info *blk);
int __cdecl parse_cso_fields(char *buf, int size);
int __cdecl generate_cso_form(char *host, int port, char *buf, HTStream *Target);
int __cdecl generate_cso_report(HTStream *Target);
int __cdecl HTLoadCSO(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
int __cdecl HTLoadGopher(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
void __cdecl do_system(char *command);
int __cdecl remote_session(char *acc_method, char *host);
int __cdecl HTLoadTelnet(const char *addr, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink);
int initialize_0();
void __cdecl start_anchor_0(const char *href);
int __cdecl response_1(char *command, char *sitename, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink);
int __cdecl HTLoadFinger(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *stream);
char __cdecl from_hex_1(char c);
void __cdecl WSRCParser_put_character(HTStream_7 *me, char c);
void __cdecl give_parameter(HTStream_7 *me, int p);
void __cdecl WSRC_gen_html(HTStream_7 *me, BOOLEAN source_file);
void __cdecl WSRCParser_put_string(HTStream_7 *context, const char *str);
void __cdecl WSRCParser_write(HTStream_7 *context, const char *str, int l);
void __cdecl WSRCParser_free(HTStream_7 *me);
void __cdecl WSRCParser_abort(HTStream_7 *me, HTError e);
HTStream_7 *__cdecl HTWSRCConvert(HTPresentation *pres, HTParentAnchor *anchor, HTStream_7 *sink);
void __cdecl HTAAForwardAuth_set(const char *scheme_name, const char *scheme_specifics);
void HTAAForwardAuth_reset(); // idb
HTAAServer *__cdecl HTAAServer_new(const char *hostname, int portnumber, BOOLEAN IsProxy);
void __cdecl HTAAServer_delete(HTAAServer *killme);
HTAAServer *__cdecl HTAAServer_lookup(const char *hostname, int portnumber, BOOLEAN IsProxy);
HTAASetup *__cdecl HTAASetup_lookup(const char *hostname, int portnumber, const char *docname, BOOLEAN IsProxy);
HTAASetup *__cdecl HTAASetup_new(HTAAServer *server, char *ctemplate, HTList *valid_schemes, HTAssocList **scheme_specifics);
void __cdecl HTAASetup_delete(HTAASetup *killme);
void __cdecl HTAASetup_updateSpecifics(HTAASetup *setup, HTAssocList **specifics);
HTAARealm *__cdecl HTAARealm_lookup(HTList *realm_table, const char *realmname);
HTAARealm *__cdecl HTAARealm_new(HTList *realm_table, const char *realmname, const char *username, const char *password);
char *__cdecl compose_auth_string(HTAAScheme scheme, HTAASetup *setup, BOOLEAN IsProxy);
HTAAScheme __cdecl HTAA_selectScheme(HTAASetup *setup);
void free_HTAAGlobals(); // idb
char *__cdecl HTAA_composeAuth(const char *hostname, const int portnumber, const char *docname, BOOLEAN IsProxy);
BOOLEAN __cdecl HTAA_shouldRetryWithAuth(char *start_of_headers, int length, int soc, BOOLEAN IsProxy);
void HTClearHTTPAuthInfo(); // idb
BOOLEAN __cdecl isNumber(const char *s);
int HTAA_getUid(); // idb
int HTAA_getGid(); // idb
void __cdecl HTAA_setIds(HTAAProt *prot, const char *ids);
void __cdecl HTAA_parseProtFile(HTAAProt *prot, FILE *fp);
HTAAProt *__cdecl HTAAProt_new(const char *cur_docname, const char *prot_filename, const char *ids);
void __cdecl HTAA_setDefaultProtection(const char *cur_docname, const char *prot_filename, const char *ids);
void __cdecl HTAA_setCurrentProtection(const char *cur_docname, const char *prot_filename, const char *ids);
HTAAProt *HTAA_getCurrentProtection(); // idb
HTAAProt *HTAA_getDefaultProtection(); // idb
void HTAA_clearProtections(); // idb
void __cdecl save_gid_info(const char *name, int user);
void __cdecl save_uid_info(const char *name, int user);
const char *__cdecl HTAA_UidToName(int uid);
int __cdecl HTAA_NameToUid(const char *name);
const char *__cdecl HTAA_GidToName(int gid);
int __cdecl HTAA_NameToGid(const char *name);
HTAssocList *HTAssocList_new(); // idb
void __cdecl HTAssocList_delete(HTAssocList *alist);
void __cdecl HTAssocList_add(HTAssocList *alist, const char *name, const char *value);
char *__cdecl HTAssocList_lookup(HTAssocList *alist, const char *name);
void __cdecl unlex(LexItem lex_item);
LexItem __cdecl lex(FILE *fp);
const char *__cdecl lex_verbose(LexItem lex_item);
int __cdecl HTUU_encode(unsigned __int8 *bufin, unsigned int nbytes, char *bufcoded);
int __cdecl HTUU_decode(char *bufcoded, unsigned __int8 *bufplain, int outbufsize);
HTAAScheme __cdecl HTAAScheme_enum(const char *name);
const char *__cdecl HTAAScheme_name(HTAAScheme scheme);
HTAAMethod __cdecl HTAAMethod_enum(const char *name);
const char *__cdecl HTAAMethod_name(HTAAMethod method);
BOOLEAN __cdecl HTAAMethod_inList(HTAAMethod method, HTList *list);
BOOLEAN __cdecl HTAA_templateMatch(const char *ctemplate, const char *filename);
BOOLEAN __cdecl HTAA_templateCaseMatch(const char *ctemplate, const char *filename);
char *__cdecl HTAA_makeProtectionTemplate(const char *docname);
HTList *__cdecl HTAA_parseArgList(char *str);
void __cdecl HTAA_setupReader(char *start_of_headers, int length, int soc);
char *HTAA_getUnfoldedLine(); // idb
void __cdecl syntax_error(FILE *fp, const char *msg, LexItem lex_item);
AddressDefList *__cdecl parse_address_part(FILE *fp);
UserDefList *__cdecl parse_user_part(FILE *fp);
Item *__cdecl parse_item(FILE *fp);
ItemList *__cdecl parse_item_list(FILE *fp);
GroupDef *__cdecl HTAA_parseGroupDef(FILE *fp);
void __cdecl print_item(Item *item);
void __cdecl print_item_list(ItemList *item_list);
void __cdecl HTAA_printGroupDef(GroupDef *group_def);
int __cdecl stat64(int, int);
int __cdecl lstat64(int, int);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_8149C04; // weak
const char relatedName = '\0'; // idb
const char value = '\0'; // idb
const LYmouse_menu::$ACDC932C58A61000CBA8BA34D071C8D9 possible_entries_12321[26] =
{
  { "Quit", 14, 1u },
  { "Home page", 48, 1u },
  { "Previous document", 37, 1u },
  { "Beginning of document", 22, 1u },
  { "Page up", 16, 1u },
  { "Half page up", 19, 1u },
  { "Two lines up", 17, 1u },
  { "History", 36, 1u },
  { "Help", 43, 0u },
  { "Do nothing (refresh)", 21, 0u },
  { "Load again", 12, 1u },
  { "Edit Doc URL and load", 42, 1u },
  { "Edit Link URL and load", 83, 2u },
  { "Show info", 56, 0u },
  { "Search", 51, 1u },
  { "Print", 57, 1u },
  { "Two lines down", 18, 1u },
  { "Half page down", 20, 1u },
  { "Page down", 15, 1u },
  { "End of document", 23, 1u },
  { "Bookmarks", 60, 1u },
  { "Cookie jar", 79, 1u },
  { "Search index", 50, 1u },
  { "Set Options", 49, 1u },
  { "Activate this link", 40, 2u },
  { "Download", 63, 2u }
}; // idb
const unipair_case unicode_to_lower_case[705] =
{
  { 65u, 97u },
  { 66u, 98u },
  { 67u, 99u },
  { 68u, 100u },
  { 69u, 101u },
  { 70u, 102u },
  { 71u, 103u },
  { 72u, 104u },
  { 73u, 105u },
  { 74u, 106u },
  { 75u, 107u },
  { 76u, 108u },
  { 77u, 109u },
  { 78u, 110u },
  { 79u, 111u },
  { 80u, 112u },
  { 81u, 113u },
  { 82u, 114u },
  { 83u, 115u },
  { 84u, 116u },
  { 85u, 117u },
  { 86u, 118u },
  { 87u, 119u },
  { 88u, 120u },
  { 89u, 121u },
  { 90u, 122u },
  { 192u, 224u },
  { 193u, 225u },
  { 194u, 226u },
  { 195u, 227u },
  { 196u, 228u },
  { 197u, 229u },
  { 198u, 230u },
  { 199u, 231u },
  { 200u, 232u },
  { 201u, 233u },
  { 202u, 234u },
  { 203u, 235u },
  { 204u, 236u },
  { 205u, 237u },
  { 206u, 238u },
  { 207u, 239u },
  { 208u, 240u },
  { 209u, 241u },
  { 210u, 242u },
  { 211u, 243u },
  { 212u, 244u },
  { 213u, 245u },
  { 214u, 246u },
  { 216u, 248u },
  { 217u, 249u },
  { 218u, 250u },
  { 219u, 251u },
  { 220u, 252u },
  { 221u, 253u },
  { 222u, 254u },
  { 256u, 257u },
  { 258u, 259u },
  { 260u, 261u },
  { 262u, 263u },
  { 264u, 265u },
  { 266u, 267u },
  { 268u, 269u },
  { 270u, 271u },
  { 272u, 273u },
  { 274u, 275u },
  { 276u, 277u },
  { 278u, 279u },
  { 280u, 281u },
  { 282u, 283u },
  { 284u, 285u },
  { 286u, 287u },
  { 288u, 289u },
  { 290u, 291u },
  { 292u, 293u },
  { 294u, 295u },
  { 296u, 297u },
  { 298u, 299u },
  { 300u, 301u },
  { 302u, 303u },
  { 304u, 105u },
  { 306u, 307u },
  { 308u, 309u },
  { 310u, 311u },
  { 313u, 314u },
  { 315u, 316u },
  { 317u, 318u },
  { 319u, 320u },
  { 321u, 322u },
  { 323u, 324u },
  { 325u, 326u },
  { 327u, 328u },
  { 330u, 331u },
  { 332u, 333u },
  { 334u, 335u },
  { 336u, 337u },
  { 338u, 339u },
  { 340u, 341u },
  { 342u, 343u },
  { 344u, 345u },
  { 346u, 347u },
  { 348u, 349u },
  { 350u, 351u },
  { 352u, 353u },
  { 354u, 355u },
  { 356u, 357u },
  { 358u, 359u },
  { 360u, 361u },
  { 362u, 363u },
  { 364u, 365u },
  { 366u, 367u },
  { 368u, 369u },
  { 370u, 371u },
  { 372u, 373u },
  { 374u, 375u },
  { 376u, 255u },
  { 377u, 378u },
  { 379u, 380u },
  { 381u, 382u },
  { 385u, 595u },
  { 386u, 387u },
  { 388u, 389u },
  { 390u, 596u },
  { 391u, 392u },
  { 393u, 598u },
  { 394u, 599u },
  { 395u, 396u },
  { 398u, 477u },
  { 399u, 601u },
  { 400u, 603u },
  { 401u, 402u },
  { 403u, 608u },
  { 404u, 611u },
  { 406u, 617u },
  { 407u, 616u },
  { 408u, 409u },
  { 412u, 623u },
  { 413u, 626u },
  { 415u, 629u },
  { 416u, 417u },
  { 418u, 419u },
  { 420u, 421u },
  { 423u, 424u },
  { 425u, 643u },
  { 428u, 429u },
  { 430u, 648u },
  { 431u, 432u },
  { 433u, 650u },
  { 434u, 651u },
  { 435u, 436u },
  { 437u, 438u },
  { 439u, 658u },
  { 440u, 441u },
  { 444u, 445u },
  { 452u, 454u },
  { 453u, 454u },
  { 455u, 457u },
  { 456u, 457u },
  { 458u, 460u },
  { 459u, 460u },
  { 461u, 462u },
  { 463u, 464u },
  { 465u, 466u },
  { 467u, 468u },
  { 469u, 470u },
  { 471u, 472u },
  { 473u, 474u },
  { 475u, 476u },
  { 478u, 479u },
  { 480u, 481u },
  { 482u, 483u },
  { 484u, 485u },
  { 486u, 487u },
  { 488u, 489u },
  { 490u, 491u },
  { 492u, 493u },
  { 494u, 495u },
  { 497u, 499u },
  { 498u, 499u },
  { 500u, 501u },
  { 506u, 507u },
  { 508u, 509u },
  { 510u, 511u },
  { 512u, 513u },
  { 514u, 515u },
  { 516u, 517u },
  { 518u, 519u },
  { 520u, 521u },
  { 522u, 523u },
  { 524u, 525u },
  { 526u, 527u },
  { 528u, 529u },
  { 530u, 531u },
  { 532u, 533u },
  { 534u, 535u },
  { 902u, 940u },
  { 904u, 941u },
  { 905u, 942u },
  { 906u, 943u },
  { 908u, 972u },
  { 910u, 973u },
  { 911u, 974u },
  { 913u, 945u },
  { 914u, 946u },
  { 915u, 947u },
  { 916u, 948u },
  { 917u, 949u },
  { 918u, 950u },
  { 919u, 951u },
  { 920u, 952u },
  { 921u, 953u },
  { 922u, 954u },
  { 923u, 955u },
  { 924u, 956u },
  { 925u, 957u },
  { 926u, 958u },
  { 927u, 959u },
  { 928u, 960u },
  { 929u, 961u },
  { 931u, 963u },
  { 932u, 964u },
  { 933u, 965u },
  { 934u, 966u },
  { 935u, 967u },
  { 936u, 968u },
  { 937u, 969u },
  { 938u, 970u },
  { 939u, 971u },
  { 994u, 995u },
  { 996u, 997u },
  { 998u, 999u },
  { 1000u, 1001u },
  { 1002u, 1003u },
  { 1004u, 1005u },
  { 1006u, 1007u },
  { 1025u, 1105u },
  { 1026u, 1106u },
  { 1027u, 1107u },
  { 1028u, 1108u },
  { 1029u, 1109u },
  { 1030u, 1110u },
  { 1031u, 1111u },
  { 1032u, 1112u },
  { 1033u, 1113u },
  { 1034u, 1114u },
  { 1035u, 1115u },
  { 1036u, 1116u },
  { 1038u, 1118u },
  { 1039u, 1119u },
  { 1040u, 1072u },
  { 1041u, 1073u },
  { 1042u, 1074u },
  { 1043u, 1075u },
  { 1044u, 1076u },
  { 1045u, 1077u },
  { 1046u, 1078u },
  { 1047u, 1079u },
  { 1048u, 1080u },
  { 1049u, 1081u },
  { 1050u, 1082u },
  { 1051u, 1083u },
  { 1052u, 1084u },
  { 1053u, 1085u },
  { 1054u, 1086u },
  { 1055u, 1087u },
  { 1056u, 1088u },
  { 1057u, 1089u },
  { 1058u, 1090u },
  { 1059u, 1091u },
  { 1060u, 1092u },
  { 1061u, 1093u },
  { 1062u, 1094u },
  { 1063u, 1095u },
  { 1064u, 1096u },
  { 1065u, 1097u },
  { 1066u, 1098u },
  { 1067u, 1099u },
  { 1068u, 1100u },
  { 1069u, 1101u },
  { 1070u, 1102u },
  { 1071u, 1103u },
  { 1120u, 1121u },
  { 1122u, 1123u },
  { 1124u, 1125u },
  { 1126u, 1127u },
  { 1128u, 1129u },
  { 1130u, 1131u },
  { 1132u, 1133u },
  { 1134u, 1135u },
  { 1136u, 1137u },
  { 1138u, 1139u },
  { 1140u, 1141u },
  { 1142u, 1143u },
  { 1144u, 1145u },
  { 1146u, 1147u },
  { 1148u, 1149u },
  { 1150u, 1151u },
  { 1152u, 1153u },
  { 1168u, 1169u },
  { 1170u, 1171u },
  { 1172u, 1173u },
  { 1174u, 1175u },
  { 1176u, 1177u },
  { 1178u, 1179u },
  { 1180u, 1181u },
  { 1182u, 1183u },
  { 1184u, 1185u },
  { 1186u, 1187u },
  { 1188u, 1189u },
  { 1190u, 1191u },
  { 1192u, 1193u },
  { 1194u, 1195u },
  { 1196u, 1197u },
  { 1198u, 1199u },
  { 1200u, 1201u },
  { 1202u, 1203u },
  { 1204u, 1205u },
  { 1206u, 1207u },
  { 1208u, 1209u },
  { 1210u, 1211u },
  { 1212u, 1213u },
  { 1214u, 1215u },
  { 1217u, 1218u },
  { 1219u, 1220u },
  { 1223u, 1224u },
  { 1227u, 1228u },
  { 1232u, 1233u },
  { 1234u, 1235u },
  { 1236u, 1237u },
  { 1238u, 1239u },
  { 1240u, 1241u },
  { 1242u, 1243u },
  { 1244u, 1245u },
  { 1246u, 1247u },
  { 1248u, 1249u },
  { 1250u, 1251u },
  { 1252u, 1253u },
  { 1254u, 1255u },
  { 1256u, 1257u },
  { 1258u, 1259u },
  { 1262u, 1263u },
  { 1264u, 1265u },
  { 1266u, 1267u },
  { 1268u, 1269u },
  { 1272u, 1273u },
  { 1329u, 1377u },
  { 1330u, 1378u },
  { 1331u, 1379u },
  { 1332u, 1380u },
  { 1333u, 1381u },
  { 1334u, 1382u },
  { 1335u, 1383u },
  { 1336u, 1384u },
  { 1337u, 1385u },
  { 1338u, 1386u },
  { 1339u, 1387u },
  { 1340u, 1388u },
  { 1341u, 1389u },
  { 1342u, 1390u },
  { 1343u, 1391u },
  { 1344u, 1392u },
  { 1345u, 1393u },
  { 1346u, 1394u },
  { 1347u, 1395u },
  { 1348u, 1396u },
  { 1349u, 1397u },
  { 1350u, 1398u },
  { 1351u, 1399u },
  { 1352u, 1400u },
  { 1353u, 1401u },
  { 1354u, 1402u },
  { 1355u, 1403u },
  { 1356u, 1404u },
  { 1357u, 1405u },
  { 1358u, 1406u },
  { 1359u, 1407u },
  { 1360u, 1408u },
  { 1361u, 1409u },
  { 1362u, 1410u },
  { 1363u, 1411u },
  { 1364u, 1412u },
  { 1365u, 1413u },
  { 1366u, 1414u },
  { 4256u, 4304u },
  { 4257u, 4305u },
  { 4258u, 4306u },
  { 4259u, 4307u },
  { 4260u, 4308u },
  { 4261u, 4309u },
  { 4262u, 4310u },
  { 4263u, 4311u },
  { 4264u, 4312u },
  { 4265u, 4313u },
  { 4266u, 4314u },
  { 4267u, 4315u },
  { 4268u, 4316u },
  { 4269u, 4317u },
  { 4270u, 4318u },
  { 4271u, 4319u },
  { 4272u, 4320u },
  { 4273u, 4321u },
  { 4274u, 4322u },
  { 4275u, 4323u },
  { 4276u, 4324u },
  { 4277u, 4325u },
  { 4278u, 4326u },
  { 4279u, 4327u },
  { 4280u, 4328u },
  { 4281u, 4329u },
  { 4282u, 4330u },
  { 4283u, 4331u },
  { 4284u, 4332u },
  { 4285u, 4333u },
  { 4286u, 4334u },
  { 4287u, 4335u },
  { 4288u, 4336u },
  { 4289u, 4337u },
  { 4290u, 4338u },
  { 4291u, 4339u },
  { 4292u, 4340u },
  { 4293u, 4341u },
  { 7680u, 7681u },
  { 7682u, 7683u },
  { 7684u, 7685u },
  { 7686u, 7687u },
  { 7688u, 7689u },
  { 7690u, 7691u },
  { 7692u, 7693u },
  { 7694u, 7695u },
  { 7696u, 7697u },
  { 7698u, 7699u },
  { 7700u, 7701u },
  { 7702u, 7703u },
  { 7704u, 7705u },
  { 7706u, 7707u },
  { 7708u, 7709u },
  { 7710u, 7711u },
  { 7712u, 7713u },
  { 7714u, 7715u },
  { 7716u, 7717u },
  { 7718u, 7719u },
  { 7720u, 7721u },
  { 7722u, 7723u },
  { 7724u, 7725u },
  { 7726u, 7727u },
  { 7728u, 7729u },
  { 7730u, 7731u },
  { 7732u, 7733u },
  { 7734u, 7735u },
  { 7736u, 7737u },
  { 7738u, 7739u },
  { 7740u, 7741u },
  { 7742u, 7743u },
  { 7744u, 7745u },
  { 7746u, 7747u },
  { 7748u, 7749u },
  { 7750u, 7751u },
  { 7752u, 7753u },
  { 7754u, 7755u },
  { 7756u, 7757u },
  { 7758u, 7759u },
  { 7760u, 7761u },
  { 7762u, 7763u },
  { 7764u, 7765u },
  { 7766u, 7767u },
  { 7768u, 7769u },
  { 7770u, 7771u },
  { 7772u, 7773u },
  { 7774u, 7775u },
  { 7776u, 7777u },
  { 7778u, 7779u },
  { 7780u, 7781u },
  { 7782u, 7783u },
  { 7784u, 7785u },
  { 7786u, 7787u },
  { 7788u, 7789u },
  { 7790u, 7791u },
  { 7792u, 7793u },
  { 7794u, 7795u },
  { 7796u, 7797u },
  { 7798u, 7799u },
  { 7800u, 7801u },
  { 7802u, 7803u },
  { 7804u, 7805u },
  { 7806u, 7807u },
  { 7808u, 7809u },
  { 7810u, 7811u },
  { 7812u, 7813u },
  { 7814u, 7815u },
  { 7816u, 7817u },
  { 7818u, 7819u },
  { 7820u, 7821u },
  { 7822u, 7823u },
  { 7824u, 7825u },
  { 7826u, 7827u },
  { 7828u, 7829u },
  { 7840u, 7841u },
  { 7842u, 7843u },
  { 7844u, 7845u },
  { 7846u, 7847u },
  { 7848u, 7849u },
  { 7850u, 7851u },
  { 7852u, 7853u },
  { 7854u, 7855u },
  { 7856u, 7857u },
  { 7858u, 7859u },
  { 7860u, 7861u },
  { 7862u, 7863u },
  { 7864u, 7865u },
  { 7866u, 7867u },
  { 7868u, 7869u },
  { 7870u, 7871u },
  { 7872u, 7873u },
  { 7874u, 7875u },
  { 7876u, 7877u },
  { 7878u, 7879u },
  { 7880u, 7881u },
  { 7882u, 7883u },
  { 7884u, 7885u },
  { 7886u, 7887u },
  { 7888u, 7889u },
  { 7890u, 7891u },
  { 7892u, 7893u },
  { 7894u, 7895u },
  { 7896u, 7897u },
  { 7898u, 7899u },
  { 7900u, 7901u },
  { 7902u, 7903u },
  { 7904u, 7905u },
  { 7906u, 7907u },
  { 7908u, 7909u },
  { 7910u, 7911u },
  { 7912u, 7913u },
  { 7914u, 7915u },
  { 7916u, 7917u },
  { 7918u, 7919u },
  { 7920u, 7921u },
  { 7922u, 7923u },
  { 7924u, 7925u },
  { 7926u, 7927u },
  { 7928u, 7929u },
  { 7944u, 7936u },
  { 7945u, 7937u },
  { 7946u, 7938u },
  { 7947u, 7939u },
  { 7948u, 7940u },
  { 7949u, 7941u },
  { 7950u, 7942u },
  { 7951u, 7943u },
  { 7960u, 7952u },
  { 7961u, 7953u },
  { 7962u, 7954u },
  { 7963u, 7955u },
  { 7964u, 7956u },
  { 7965u, 7957u },
  { 7976u, 7968u },
  { 7977u, 7969u },
  { 7978u, 7970u },
  { 7979u, 7971u },
  { 7980u, 7972u },
  { 7981u, 7973u },
  { 7982u, 7974u },
  { 7983u, 7975u },
  { 7992u, 7984u },
  { 7993u, 7985u },
  { 7994u, 7986u },
  { 7995u, 7987u },
  { 7996u, 7988u },
  { 7997u, 7989u },
  { 7998u, 7990u },
  { 7999u, 7991u },
  { 8008u, 8000u },
  { 8009u, 8001u },
  { 8010u, 8002u },
  { 8011u, 8003u },
  { 8012u, 8004u },
  { 8013u, 8005u },
  { 8025u, 8017u },
  { 8027u, 8019u },
  { 8029u, 8021u },
  { 8031u, 8023u },
  { 8040u, 8032u },
  { 8041u, 8033u },
  { 8042u, 8034u },
  { 8043u, 8035u },
  { 8044u, 8036u },
  { 8045u, 8037u },
  { 8046u, 8038u },
  { 8047u, 8039u },
  { 8072u, 8064u },
  { 8073u, 8065u },
  { 8074u, 8066u },
  { 8075u, 8067u },
  { 8076u, 8068u },
  { 8077u, 8069u },
  { 8078u, 8070u },
  { 8079u, 8071u },
  { 8088u, 8080u },
  { 8089u, 8081u },
  { 8090u, 8082u },
  { 8091u, 8083u },
  { 8092u, 8084u },
  { 8093u, 8085u },
  { 8094u, 8086u },
  { 8095u, 8087u },
  { 8104u, 8096u },
  { 8105u, 8097u },
  { 8106u, 8098u },
  { 8107u, 8099u },
  { 8108u, 8100u },
  { 8109u, 8101u },
  { 8110u, 8102u },
  { 8111u, 8103u },
  { 8120u, 8112u },
  { 8121u, 8113u },
  { 8122u, 8048u },
  { 8123u, 8049u },
  { 8124u, 8115u },
  { 8136u, 8050u },
  { 8137u, 8051u },
  { 8138u, 8052u },
  { 8139u, 8053u },
  { 8140u, 8131u },
  { 8152u, 8144u },
  { 8153u, 8145u },
  { 8154u, 8054u },
  { 8155u, 8055u },
  { 8168u, 8160u },
  { 8169u, 8161u },
  { 8170u, 8058u },
  { 8171u, 8059u },
  { 8172u, 8165u },
  { 8184u, 8056u },
  { 8185u, 8057u },
  { 8186u, 8060u },
  { 8187u, 8061u },
  { 8188u, 8179u },
  { 8544u, 8560u },
  { 8545u, 8561u },
  { 8546u, 8562u },
  { 8547u, 8563u },
  { 8548u, 8564u },
  { 8549u, 8565u },
  { 8550u, 8566u },
  { 8551u, 8567u },
  { 8552u, 8568u },
  { 8553u, 8569u },
  { 8554u, 8570u },
  { 8555u, 8571u },
  { 8556u, 8572u },
  { 8557u, 8573u },
  { 8558u, 8574u },
  { 8559u, 8575u },
  { 9398u, 9424u },
  { 9399u, 9425u },
  { 9400u, 9426u },
  { 9401u, 9427u },
  { 9402u, 9428u },
  { 9403u, 9429u },
  { 9404u, 9430u },
  { 9405u, 9431u },
  { 9406u, 9432u },
  { 9407u, 9433u },
  { 9408u, 9434u },
  { 9409u, 9435u },
  { 9410u, 9436u },
  { 9411u, 9437u },
  { 9412u, 9438u },
  { 9413u, 9439u },
  { 9414u, 9440u },
  { 9415u, 9441u },
  { 9416u, 9442u },
  { 9417u, 9443u },
  { 9418u, 9444u },
  { 9419u, 9445u },
  { 9420u, 9446u },
  { 9421u, 9447u },
  { 9422u, 9448u },
  { 9423u, 9449u },
  { 65313u, 65345u },
  { 65314u, 65346u },
  { 65315u, 65347u },
  { 65316u, 65348u },
  { 65317u, 65349u },
  { 65318u, 65350u },
  { 65319u, 65351u },
  { 65320u, 65352u },
  { 65321u, 65353u },
  { 65322u, 65354u },
  { 65323u, 65355u },
  { 65324u, 65356u },
  { 65325u, 65357u },
  { 65326u, 65358u },
  { 65327u, 65359u },
  { 65328u, 65360u },
  { 65329u, 65361u },
  { 65330u, 65362u },
  { 65331u, 65363u },
  { 65332u, 65364u },
  { 65333u, 65365u },
  { 65334u, 65366u },
  { 65335u, 65367u },
  { 65336u, 65368u },
  { 65337u, 65369u },
  { 65338u, 65370u }
}; // idb
const char position = '\0'; // idb
const char byte_814C6F9 = '\0'; // idb
const char aYnav[] = "YNAV\a"; // idb
const char byte_814CBAC = '\0'; // idb
const char aQ[] = "q\x00\"\x00;\x00,"; // idb
const char basis_64_23258[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // idb
const char byte_814EF17 = '\0'; // idb
const char locale = '\0'; // idb
const restrictions_fun::$7AD48B1D67F4DD0953F834F23718D769 table_12539[38] =
{
  { "all", "restricts all options." },
  { "bookmark", "disallow changing the location of the bookmark file" },
  { "bookmark_exec", "disallow execution links via the bookmark file" },
  {
    "change_exec_perms",
    "disallow changing the eXecute permission on files\n(but still allow it for directories) when local file\nmanagement is enabled."
  },
  {
    "chdir",
    "disallow changing the working directory of lynx, e.g.,\nto affect the behavior of download command"
  },
  { "compileopts_info", "disable info on options used to compile the binary" },
  {
    "default",
    "same as commandline option -anonymous.  Sets the\ndefault service restrictions for anonymous users.  Set to\nall restricted, except for: inside_telnet, outside_telnet,\ninside_ftp, outside_ftp, inside_rlogin, outside_rlogin,\ninside_news, outside_news, telnet_port, jump, mail, print,\nexec, and goto.  The settings for these, as well as\nadditional goto restrictions for specific URL schemes\nthat are also applied, are derived from definitions\nwithin userdefs.h."
  },
  { "dired_support", "disallow local file management" },
  { "disk_save", "disallow saving to disk in the download and print menus" },
  { "dotfiles", "disallow access to, or creation of, hidden (dot) files" },
  { "download", "disallow some downloaders in the download menu" },
  { "editor", "disallow editing" },
  { "exec", "disable execution scripts" },
  { "exec_frozen", "disallow the user from changing the execution link option" },
  { "externals", "disable passing URLs to some external programs" },
  {
    "file_url",
    "disallow using G)oto, served links or bookmarks for\nfile: URL's"
  },
  { "goto", "disable the 'g' (goto) command" },
  { "inside_ftp", "disallow ftps coming from inside your domain" },
  {
    "inside_news",
    "disallow USENET news reading and posting coming\nfrom inside your domain"
  },
  { "inside_rlogin", "disallow rlogins coming from inside your domain" },
  { "inside_telnet", "disallow telnets coming from inside your domain" },
  { "jump", "disable the 'j' (jump) command" },
  { "lynxcfg_info", "disable viewing of lynx.cfg configuration file info" },
  { "lynxcfg_xinfo", "disable extended lynx.cfg viewing and reloading" },
  { "lynxcgi", "disallow execution of Lynx CGI URLs" },
  { "mail", "disallow mail" },
  { "multibook", "disallow multiple bookmark files" },
  { "news_post", "disallow USENET News posting." },
  { "option_save", "disallow saving options in .lynxrc" },
  { "outside_ftp", "disallow ftp coming from outside your domain" },
  {
    "outside_news",
    "disallow USENET news reading and posting coming\nfrom outside your domain"
  },
  { "outside_rlogin", "disallow rlogins coming from outside your domain" },
  { "outside_telnet", "disallow telnets coming from outside your domain" },
  { "print", "disallow most print options" },
  {
    "shell",
    "disallow shell escapes, and lynxexec, lynxprog or lynxcgi\nG)oto's"
  },
  { "suspend", "disallow Control-Z suspends with escape to shell" },
  { "telnet_port", "disallow specifying a port in telnet G)oto's" },
  { "useragent", "disallow modifications of the User-Agent header" }
}; // idb
char *const help = "restricts all options."; // idb
const char byte_81534E7 = '\0'; // idb
_UNKNOWN unk_815571C; // weak
const char byte_8155B15 = '\0'; // idb
const char byte_8156400[4] = { '\0', '\0', '\0', '\0' }; // idb
const $3F09A9C5F4FC42240A87120DA6DA1211 restrictions[58] =
{
  { "default", &had_restrictions_default, '\x01' },
  { "all", &had_restrictions_all, '\x01' },
  { "inside_telnet", &no_inside_telnet, '\x01' },
  { "outside_telnet", &no_outside_telnet, '\0' },
  { "telnet_port", &no_telnet_port, '\0' },
  { "inside_ftp", &no_inside_ftp, '\x01' },
  { "outside_ftp", &no_outside_ftp, '\0' },
  { "inside_rlogin", &no_inside_rlogin, '\x01' },
  { "outside_rlogin", &no_outside_rlogin, '\0' },
  { "suspend", &no_suspend, '\0' },
  { "editor", &no_editor, '\0' },
  { "shell", &no_shell, '\0' },
  { "bookmark", &no_bookmark, '\0' },
  { "multibook", &no_multibook, '\0' },
  { "bookmark_exec", &no_bookmark_exec, '\0' },
  { "option_save", &no_option_save, '\0' },
  { "print", &no_print, '\0' },
  { "download", &no_download, '\0' },
  { "disk_save", &no_disk_save, '\0' },
  { "exec", &no_exec, '\0' },
  { "lynxcgi", &no_lynxcgi, '\0' },
  { "exec_frozen", &exec_frozen, '\0' },
  { "goto", &no_goto, '\x01' },
  { "jump", &no_jump, '\0' },
  { "file_url", &no_file_url, '\0' },
  { "news_post", &no_newspost, '\0' },
  { "inside_news", &no_inside_news, '\x01' },
  { "outside_news", &no_outside_news, '\0' },
  { "mail", &no_mail, '\x01' },
  { "dotfiles", &no_dotfiles, '\0' },
  { "useragent", &no_useragent, '\0' },
  { "chdir", &no_chdir, '\0' },
  { "dired_support", &no_dired_support, '\0' },
  { "change_exec_perms", &no_change_exec_perms, '\0' },
  { "externals", &no_externals, '\0' },
  { "lynxcfg_info", &no_lynxcfg_info, '\0' },
  { "lynxcfg_xinfo", &no_lynxcfg_xinfo, '\0' },
  { "compileopts_info", &no_compileopts_info, '\0' },
  { "goto_bibp", &no_goto_bibp, '\x01' },
  { "goto_configinfo", &no_goto_configinfo, '\0' },
  { "goto_cso", &no_goto_cso, '\0' },
  { "goto_file", &no_goto_file, '\0' },
  { "goto_finger", &no_goto_finger, '\x01' },
  { "goto_ftp", &no_goto_ftp, '\0' },
  { "goto_gopher", &no_goto_gopher, '\0' },
  { "goto_http", &no_goto_http, '\x01' },
  { "goto_https", &no_goto_https, '\0' },
  { "goto_lynxcgi", &no_goto_lynxcgi, '\0' },
  { "goto_lynxexec", &no_goto_lynxexec, '\0' },
  { "goto_lynxprog", &no_goto_lynxprog, '\0' },
  { "goto_mailto", &no_goto_mailto, '\x01' },
  { "goto_news", &no_goto_news, '\0' },
  { "goto_nntp", &no_goto_nntp, '\0' },
  { "goto_rlogin", &no_goto_rlogin, '\0' },
  { "goto_snews", &no_goto_snews, '\0' },
  { "goto_telnet", &no_goto_telnet, '\0' },
  { "goto_tn3270", &no_goto_tn3270, '\0' },
  { "goto_wais", &no_goto_wais, '\x01' }
}; // idb
const char Msg[4] = { '\0', '\0', '\0', '\0' }; // idb
const char bracks = '\0'; // idb
const lynx_compile_opts::$C33B68E2991F096225018D80272E5FFB config_defines_12971[184] =
{
  { "ALT_CHAR_SET", "acs_map" },
  { "ANSI_VARARGS", "1" },
  { "BZIP2_PATH", "\"/bin/bzip2\"" },
  { "CAN_SET_ERRNO", "1" },
  { "CJK_EX", "1" },
  { "COLOR_CURSES", "1" },
  { "COMPRESS_PATH", "\"/usr/bin/compress\"" },
  { "DIRED_SUPPORT", "1" },
  { "DISP_PARTIAL", "1" },
  { "DONT_TRACK_INTERNAL_LINKS", "1" },
  { "ENABLE_IPV6", "1" },
  { "ENABLE_NLS", "1" },
  { "EXEC_LINKS", "1" },
  { "EXEC_SCRIPTS", "1" },
  { "EXP_ALT_BINDINGS", "1" },
  { "EXP_JAPANESEUTF8_SUPPORT", "1" },
  { "EXP_JUSTIFY_ELTS", "1" },
  { "EXP_NESTED_TABLES", "1" },
  { "FANCY_CURSES", "1" },
  { "GETGROUPS_T", "gid_t" },
  { "GZIP_PATH", "\"/bin/gzip\"" },
  { "HAVE_ALLOCA", "1" },
  { "HAVE_ALLOCA_H", "1" },
  { "HAVE___ARGZ_COUNT", "1" },
  { "HAVE_ARGZ_H", "1" },
  { "HAVE___ARGZ_NEXT", "1" },
  { "HAVE___ARGZ_STRINGIFY", "1" },
  { "HAVE_ARPA_INET_H", "1" },
  { "HAVE_ASSUME_DEFAULT_COLORS", "1" },
  { "HAVE_CBREAK", "1" },
  { "HAVE_CTERMID", "1" },
  { "HAVE_CURSES_VERSION", "1" },
  { "HAVE_CUSERID", "1" },
  { "HAVE_DCGETTEXT", "1" },
  { "HAVE_DEFINE_KEY", "1" },
  { "HAVE_DELSCREEN", "1" },
  { "HAVE_DIRENT_H", "1" },
  { "HAVE_FCNTL_H", "1" },
  { "HAVE_FTIME", "1" },
  { "HAVE_GAI_STRERROR", "1" },
  { "HAVE_GETADDRINFO", "1" },
  { "HAVE_GETATTRS", "1" },
  { "HAVE_GETBEGX", "1" },
  { "HAVE_GETBEGY", "1" },
  { "HAVE_GETBKGD", "1" },
  { "HAVE_GETCWD", "1" },
  { "HAVE_GETGROUPS", "1" },
  { "HAVE_GETTEXT", "1" },
  { "HAVE_GETTIMEOFDAY", "1" },
  { "HAVE_GETUID", "1" },
  { "HAVE_ICONV", "1" },
  { "HAVE_INET_ATON", "1" },
  { "HAVE_INTTYPES_H", "1" },
  { "HAVE_KEYPAD", "1" },
  { "HAVE_LANGINFO_CODESET", "1" },
  { "HAVE_LC_MESSAGES", "1" },
  { "HAVE_LIBINTL_H", "1" },
  { "HAVE_LIMITS_H", "1" },
  { "HAVE_LOCALE_H", "1" },
  { "HAVE_LSTAT", "1" },
  { "HAVE_LYHELP_H", "1" },
  { "HAVE_MALLOC_H", "1" },
  { "HAVE_MBSTATE_T", "1" },
  { "HAVE_MKDTEMP", "1" },
  { "HAVE_MKTEMP", "1" },
  { "HAVE_MMAP", "1" },
  { "HAVE_MUNMAP", "1" },
  { "HAVE_NAPMS", "1" },
  { "HAVE__NC_FREEALL", "1" },
  { "HAVE__NC_FREE_AND_EXIT", "1" },
  { "HAVE_NCURSESW_TERM_H", "1" },
  { "HAVE_NEWPAD", "1" },
  { "HAVE_NEWTERM", "1" },
  { "HAVE_NL_TYPES_H", "1" },
  { "HAVE_PNOUTREFRESH", "1" },
  { "HAVE_POPEN", "1" },
  { "HAVE_PUTENV", "1" },
  { "HAVE_READDIR", "1" },
  { "HAVE_RESIZETERM", "1" },
  { "HAVE_SETENV", "1" },
  { "HAVE_SETLOCALE", "1" },
  { "HAVE_SETUID", "1" },
  { "HAVE_SIGACTION", "1" },
  { "HAVE_SIZECHANGE", "1" },
  { "HAVE_STDARG_H", "1" },
  { "HAVE_STDLIB_H", "1" },
  { "HAVE_STPCPY", "1" },
  { "HAVE_STRCASECMP", "1" },
  { "HAVE_STRCHR", "1" },
  { "HAVE_STRERROR", "1" },
  { "HAVE_STRING_H", "1" },
  { "HAVE_SYS_FCNTL_H", "1" },
  { "HAVE_SYS_IOCTL_H", "1" },
  { "HAVE_SYSLOG_H", "1" },
  { "HAVE_SYS_PARAM_H", "1" },
  { "HAVE_SYS_TIMEB_H", "1" },
  { "HAVE_SYS_WAIT_H", "1" },
  { "HAVE_TERM_H", "1" },
  { "HAVE_TERMIO_H", "1" },
  { "HAVE_TERMIOS_H", "1" },
  { "HAVE_TOUCHLINE", "1" },
  { "HAVE_TOUCHWIN", "1" },
  { "HAVE_TRUNCATE", "1" },
  { "HAVE_TTYNAME", "1" },
  { "HAVE_TTYTYPE", "1" },
  { "HAVE_UNISTD_H", "1" },
  { "HAVE_UNSETENV", "1" },
  { "HAVE_USE_DEFAULT_COLORS", "1" },
  { "HAVE_USE_LEGACY_CODING", "1" },
  { "HAVE_USLEEP", "1" },
  { "HAVE_UTMP", "1" },
  { "HAVE_UTMP_UT_HOST", "1" },
  { "HAVE_UTMP_UT_SESSION", "1" },
  { "HAVE_UTMP_UT_XSTATUS", "1" },
  { "HAVE_UTMP_UT_XTIME", "1" },
  { "HAVE_VASPRINTF", "1" },
  { "HAVE_WAITPID", "1" },
  { "HAVE_WATTR_GET", "1" },
  { "HAVE_WBORDER", "1" },
  { "HAVE_WREDRAWLN", "1" },
  { "HAVE_WRESIZE", "1" },
  { "ICONV_CONST", &bracks },
  { "INSTALL_ARGS", "\"-c\"" },
  { "INSTALL_PATH", "\"/usr/bin/install\"" },
  { "LOCALE", "1" },
  { "LONG_LIST", "1" },
  { "lstat", "stat" },
  { "LYNX_CFG_FILE", "\"/etc/lynx-cur/lynx.cfg\"" },
  { "LYNX_CFG_H", "1" },
  { "LYNXCGI_LINKS", "1" },
  { "LYNX_LSS_FILE", "\"/etc/lynx-cur/lynx.lss\"" },
  { "LYNX_RAND_MAX", "INT_MAX" },
  { "lynx_rand", "random" },
  { "lynx_srand", "srandom" },
  { "MIME_LIBDIR", "\"/etc/\"" },
  { "MV_PATH", "\"/bin/mv\"" },
  { "NCURSES", "1" },
  { "NSL_FORK", "1" },
  { "OK_GZIP", "1" },
  { "OK_OVERRIDE", "1" },
  { "OK_PERMIT", "1" },
  { "OK_TAR", "1" },
  { "OK_UUDECODE", "1" },
  { "OK_ZIP", "1" },
  { "RLOGIN_PATH", "\"/usr/bin/rlogin\"" },
  { "RM_PATH", "\"/bin/rm\"" },
  { "SIZEOF_INT", "4" },
  { "SIZEOF_LONG", "4" },
  { "SIZEOF_OFF_T", "8" },
  { "SIZEOF_TIME_T", "4" },
  { "STDC_HEADERS", "1" },
  { "SYSLOG_REQUESTED_URLS", "1" },
  { "SYSTEM_MAIL_FLAGS", "\"-t -oi\"" },
  { "SYSTEM_MAIL", "\"/usr/sbin/sendmail\"" },
  { "SYSTEM_NAME", "\"linux-gnu\"" },
  { "TAR_DOWN_OPTIONS", "\"-xf\"" },
  { "TAR_FILE_OPTIONS", "\"\"" },
  { "TAR_PATH", "\"/bin/tar\"" },
  { "TAR_PIPE_OPTIONS", "\"-\"" },
  { "TAR_UP_OPTIONS", "\"-cf\"" },
  { "TELNET_PATH", "\"/usr/bin/telnet\"" },
  { "TERMIO_AND_CURSES", "1" },
  { "UNCOMPRESS_PATH", "\"/bin/gunzip\"" },
  { "UNDERLINE_LINKS", "0" },
  { "UNIX", "1" },
  { "UNZIP_PATH", "\"/usr/bin/unzip\"" },
  { "USE_COLOR_STYLE", "1" },
  { "USE_DEFAULT_COLORS", "1" },
  { "USE_EXTERNALS", "1" },
  { "USE_FILE_UPLOAD", "1" },
  { "USE_GNUTLS_FUNCS", "1" },
  { "USE_LOCALE_CHARSET", "1" },
  { "USE_PERSISTENT_COOKIES", "1" },
  { "USE_PRETTYSRC", "1" },
  { "USE_READPROGRESS", "1" },
  { "USE_SCROLLBAR", "1" },
  { "USE_SOURCE_CACHE", "1" },
  { "USE_SYSV_UTMP", "1" },
  { "USE_ZLIB", "1" },
  { "ut_xstatus", "ut_exit.e_exit" },
  { "UUDECODE_PATH", "\"/usr/bin/uudecode\"" },
  { "WIDEC_CURSES", "1" },
  { "ZCAT_PATH", "\"/bin/zcat\"" },
  { "ZIP_PATH", "\"/usr/bin/zip\"" }
}; // idb
char *off_815BC44[242] =
{
  "acs_map",
  "ANSI_VARARGS",
  "1",
  "BZIP2_PATH",
  "\"/bin/bzip2\"",
  "CAN_SET_ERRNO",
  "1",
  "CJK_EX",
  "1",
  "COLOR_CURSES",
  "1",
  "COMPRESS_PATH",
  "\"/usr/bin/compress\"",
  "DIRED_SUPPORT",
  "1",
  "DISP_PARTIAL",
  "1",
  "DONT_TRACK_INTERNAL_LINKS",
  "1",
  "ENABLE_IPV6",
  "1",
  "ENABLE_NLS",
  "1",
  "EXEC_LINKS",
  "1",
  "EXEC_SCRIPTS",
  "1",
  "EXP_ALT_BINDINGS",
  "1",
  "EXP_JAPANESEUTF8_SUPPORT",
  "1",
  "EXP_JUSTIFY_ELTS",
  "1",
  "EXP_NESTED_TABLES",
  "1",
  "FANCY_CURSES",
  "1",
  "GETGROUPS_T",
  "gid_t",
  "GZIP_PATH",
  "\"/bin/gzip\"",
  "HAVE_ALLOCA",
  "1",
  "HAVE_ALLOCA_H",
  "1",
  "HAVE___ARGZ_COUNT",
  "1",
  "HAVE_ARGZ_H",
  "1",
  "HAVE___ARGZ_NEXT",
  "1",
  "HAVE___ARGZ_STRINGIFY",
  "1",
  "HAVE_ARPA_INET_H",
  "1",
  "HAVE_ASSUME_DEFAULT_COLORS",
  "1",
  "HAVE_CBREAK",
  "1",
  "HAVE_CTERMID",
  "1",
  "HAVE_CURSES_VERSION",
  "1",
  "HAVE_CUSERID",
  "1",
  "HAVE_DCGETTEXT",
  "1",
  "HAVE_DEFINE_KEY",
  "1",
  "HAVE_DELSCREEN",
  "1",
  "HAVE_DIRENT_H",
  "1",
  "HAVE_FCNTL_H",
  "1",
  "HAVE_FTIME",
  "1",
  "HAVE_GAI_STRERROR",
  "1",
  "HAVE_GETADDRINFO",
  "1",
  "HAVE_GETATTRS",
  "1",
  "HAVE_GETBEGX",
  "1",
  "HAVE_GETBEGY",
  "1",
  "HAVE_GETBKGD",
  "1",
  "HAVE_GETCWD",
  "1",
  "HAVE_GETGROUPS",
  "1",
  "HAVE_GETTEXT",
  "1",
  "HAVE_GETTIMEOFDAY",
  "1",
  "HAVE_GETUID",
  "1",
  "HAVE_ICONV",
  "1",
  "HAVE_INET_ATON",
  "1",
  "HAVE_INTTYPES_H",
  "1",
  "HAVE_KEYPAD",
  "1",
  "HAVE_LANGINFO_CODESET",
  "1",
  "HAVE_LC_MESSAGES",
  "1",
  "HAVE_LIBINTL_H",
  "1",
  "HAVE_LIMITS_H",
  "1",
  "HAVE_LOCALE_H",
  "1",
  "HAVE_LSTAT",
  "1",
  "HAVE_LYHELP_H",
  "1",
  "HAVE_MALLOC_H",
  "1",
  "HAVE_MBSTATE_T",
  "1",
  "HAVE_MKDTEMP",
  "1",
  "HAVE_MKTEMP",
  "1",
  "HAVE_MMAP",
  "1",
  "HAVE_MUNMAP",
  "1",
  "HAVE_NAPMS",
  "1",
  "HAVE__NC_FREEALL",
  "1",
  "HAVE__NC_FREE_AND_EXIT",
  "1",
  "HAVE_NCURSESW_TERM_H",
  "1",
  "HAVE_NEWPAD",
  "1",
  "HAVE_NEWTERM",
  "1",
  "HAVE_NL_TYPES_H",
  "1",
  "HAVE_PNOUTREFRESH",
  "1",
  "HAVE_POPEN",
  "1",
  "HAVE_PUTENV",
  "1",
  "HAVE_READDIR",
  "1",
  "HAVE_RESIZETERM",
  "1",
  "HAVE_SETENV",
  "1",
  "HAVE_SETLOCALE",
  "1",
  "HAVE_SETUID",
  "1",
  "HAVE_SIGACTION",
  "1",
  "HAVE_SIZECHANGE",
  "1",
  "HAVE_STDARG_H",
  "1",
  "HAVE_STDLIB_H",
  "1",
  "HAVE_STPCPY",
  "1",
  "HAVE_STRCASECMP",
  "1",
  "HAVE_STRCHR",
  "1",
  "HAVE_STRERROR",
  "1",
  "HAVE_STRING_H",
  "1",
  "HAVE_SYS_FCNTL_H",
  "1",
  "HAVE_SYS_IOCTL_H",
  "1",
  "HAVE_SYSLOG_H",
  "1",
  "HAVE_SYS_PARAM_H",
  "1",
  "HAVE_SYS_TIMEB_H",
  "1",
  "HAVE_SYS_WAIT_H",
  "1",
  "HAVE_TERM_H",
  "1",
  "HAVE_TERMIO_H",
  "1",
  "HAVE_TERMIOS_H",
  "1",
  "HAVE_TOUCHLINE",
  "1",
  "HAVE_TOUCHWIN",
  "1",
  "HAVE_TRUNCATE",
  "1",
  "HAVE_TTYNAME",
  "1",
  "HAVE_TTYTYPE",
  "1",
  "HAVE_UNISTD_H",
  "1",
  "HAVE_UNSETENV",
  "1",
  "HAVE_USE_DEFAULT_COLORS",
  "1",
  "HAVE_USE_LEGACY_CODING",
  "1",
  "HAVE_USLEEP",
  "1",
  "HAVE_UTMP",
  "1",
  "HAVE_UTMP_UT_HOST",
  "1",
  "HAVE_UTMP_UT_SESSION",
  "1",
  "HAVE_UTMP_UT_XSTATUS",
  "1",
  "HAVE_UTMP_UT_XTIME",
  "1",
  "HAVE_VASPRINTF",
  "1",
  "HAVE_WAITPID",
  "1",
  "HAVE_WATTR_GET",
  "1",
  "HAVE_WBORDER",
  "1",
  "HAVE_WREDRAWLN",
  "1",
  "HAVE_WRESIZE",
  "1",
  "ICONV_CONST"
}; // weak
const lynx_compile_opts::$C33B68E2991F096225018D80272E5FFB config_cache_12967[282] =
{
  { &bracks, &bracks },
  { "alt_char_set", "'acs_map'" },
  { "ansi_cc", "'-DCC_HAS_PROTOS'" },
  { "ansi_varargs", "'yes'" },
  { "baddef_remove", "'no'" },
  { "bool_defs", "'yes'" },
  { "build_alias", "'i686-pc-linux-gnu'" },
  { "build", "'i686-pc-linux-gnu'" },
  { "c_compiler_gnu", "'yes'" },
  { "c_const", "'yes'" },
  { "cc_u_d_options", "'yes'" },
  { "c_inline", "'inline'" },
  { "color_curses", "'yes'" },
  { "curses_dir", "'no'" },
  { "dcl_errno", "'yes'" },
  { "dcl_sys_errlist", "'yes'" },
  { "dcl_sys_nerr", "'yes'" },
  { "define_sigwinch", "'yes'" },
  { "env_build_alias_set", "''" },
  { "env_build_alias_value", "''" },
  { "env_CC_set", "''" },
  { "env_CC_value", "''" },
  { "env_CFLAGS_set", "'set'" },
  { "env_CFLAGS_value", "'-g'" },
  { "env_CPPFLAGS_set", "''" },
  { "env_CPPFLAGS_value", "''" },
  { "env_CPP_set", "''" },
  { "env_CPP_value", "''" },
  { "env_host_alias_set", "''" },
  { "env_host_alias_value", "''" },
  { "env_LDFLAGS_set", "''" },
  { "env_LDFLAGS_value", "''" },
  { "env_target_alias_set", "''" },
  { "env_target_alias_value", "''" },
  { "fancy_curses", "'yes'" },
  { "find_linkage_gnutls", "'no'" },
  { "find_linkage_iconv", "'yes'" },
  { "find_linkage_intl", "'yes'" },
  { "find_linkage_z", "'yes'" },
  { "fionbio", "'ioctl'" },
  { "force_use_gnu_gettext", "'no'" },
  { "func_alloca_works", "'yes'" },
  { "func___argz_count", "'yes'" },
  { "func___argz_next", "'yes'" },
  { "func___argz_stringify", "'yes'" },
  { "func_assume_default_colors", "'yes'" },
  { "func_cbreak", "'yes'" },
  { "func_ctermid", "'yes'" },
  { "func_curses_version", "'yes'" },
  { "func_cuserid", "'yes'" },
  { "func_dcgettext", "'yes'" },
  { "func_decl_getgrgid", "'yes'" },
  { "func_decl_getgrnam", "'yes'" },
  { "func_decl_strstr", "'yes'" },
  { "func_define_key", "'yes'" },
  { "func_delscreen", "'yes'" },
  { "func_feof_unlocked", "'yes'" },
  { "func_fgets_unlocked", "'yes'" },
  { "func_fork_works", "'yes'" },
  { "func_fork", "'yes'" },
  { "func_fseeko", "'yes'" },
  { "func_ftime", "'yes'" },
  { "func_getattrs", "'yes'" },
  { "func_getbegx", "'yes'" },
  { "func_getbegy", "'yes'" },
  { "func_getcwd", "'yes'" },
  { "func_getegid", "'yes'" },
  { "func_geteuid", "'yes'" },
  { "func_getgid", "'yes'" },
  { "func_getgroups", "'yes'" },
  { "func_gethostbyname", "'yes'" },
  { "func_gethostname", "'yes'" },
  { "func_getpagesize", "'yes'" },
  { "func_gettext", "'yes'" },
  { "func_gettimeofday", "'yes'" },
  { "func_getuid", "'yes'" },
  { "func_iconv", "'yes'" },
  { "func_keypad", "'yes'" },
  { "func_lstat", "'yes'" },
  { "func_mempcpy", "'yes'" },
  { "func_mkdtemp", "'yes'" },
  { "func_mktemp", "'yes'" },
  { "func_mktime", "'yes'" },
  { "func_mmap_fixed_mapped", "'yes'" },
  { "func_munmap", "'yes'" },
  { "func_napms", "'yes'" },
  { "func__nc_freeall", "'yes'" },
  { "func__nc_free_and_exit", "'yes'" },
  { "func_newpad", "'yes'" },
  { "func_newterm", "'yes'" },
  { "func_pnoutrefresh", "'yes'" },
  { "func_popen", "'yes'" },
  { "func_putenv", "'yes'" },
  { "func_readdir", "'yes'" },
  { "func_resizeterm", "'yes'" },
  { "func_setenv", "'yes'" },
  { "func_setlocale", "'yes'" },
  { "func_setuid", "'yes'" },
  { "func_sigaction", "'yes'" },
  { "func_socket", "'yes'" },
  { "func_stpcpy", "'yes'" },
  { "func_strcasecmp", "'yes'" },
  { "func_strchr", "'yes'" },
  { "func_strdup", "'yes'" },
  { "func_strerror", "'yes'" },
  { "func_strstr", "'yes'" },
  { "func_strtoul", "'yes'" },
  { "func_touchline", "'yes'" },
  { "func_touchwin", "'yes'" },
  { "func_truncate", "'yes'" },
  { "func_tsearch", "'yes'" },
  { "func_ttyname", "'yes'" },
  { "func_unsetenv", "'yes'" },
  { "func_use_default_colors", "'yes'" },
  { "func_use_legacy_coding", "'yes'" },
  { "func_usleep", "'yes'" },
  { "func_vasprintf", "'yes'" },
  { "func_vfork_works", "'yes'" },
  { "func_vfork", "'yes'" },
  { "func_waitpid", "'yes'" },
  { "func_wattr_get", "'yes'" },
  { "func_wborder", "'yes'" },
  { "func_wredrawln", "'yes'" },
  { "func_wresize", "'yes'" },
  { "func_zError", "'no'" },
  { "getaddrinfo", "'yes'" },
  { "gnu_library_2_1", "'yes'" },
  { "gnu_source", "'yes'" },
  { "gnutls_compat", "'no'" },
  { "have_errno", "'no'" },
  { "have_gnutls", "'no'" },
  { "have_h_errno", "'no'" },
  { "have_inet_aton", "'yes'" },
  { "have_sys_errlist", "'yes'" },
  { "have_sys_nerr", "'yes'" },
  { "have_ttytype", "'yes'" },
  { "have_utmp_ut_host", "'yes'" },
  { "have_utmp", "'utmp'" },
  { "have_utmp_ut_name", "'ut_name'" },
  { "have_utmp_ut_session", "'yes'" },
  { "have_utmp_ut_syslen", "'no'" },
  { "have_utmp_ut_xstatus", "'ut_exit.e_exit'" },
  { "have_utmp_ut_xtime", "'yes'" },
  { "header_argz_h", "'yes'" },
  { "header_arpa_inet_h", "'yes'" },
  { "header_dirent_dirent_h", "'yes'" },
  { "header_fcntl_h", "'yes'" },
  { "header_intl", "''" },
  { "header_inttypes_h", "'yes'" },
  { "header_lastlog_h", "'yes'" },
  { "header_libgt", "''" },
  { "header_libintl_h", "'yes'" },
  { "header_limits_h", "'yes'" },
  { "header_locale_h", "'yes'" },
  { "header_malloc_h", "'yes'" },
  { "header_memory_h", "'yes'" },
  { "header_ncursesw_term_h", "'yes'" },
  { "header_nl_types_h", "'yes'" },
  { "header_path_gnutls", "'/usr/local/include'" },
  { "header_path_iconv", "''" },
  { "header_path_intl", "''" },
  { "header_paths_h", "'yes'" },
  { "header_path_z", "'/usr/include'" },
  { "header_stdarg_h", "'yes'" },
  { "header_stdc", "'yes'" },
  { "header_stddef_h", "'yes'" },
  { "header_stdint_h", "'yes'" },
  { "header_stdlib_h", "'yes'" },
  { "header_string_h", "'yes'" },
  { "header_strings_h", "'yes'" },
  { "header_sys_fcntl_h", "'yes'" },
  { "header_sys_filio_h", "'no'" },
  { "header_sys_ioctl_h", "'yes'" },
  { "header_syslog_h", "'yes'" },
  { "header_sys_param_h", "'yes'" },
  { "header_sys_stat_h", "'yes'" },
  { "header_sys_timeb_h", "'yes'" },
  { "header_sys_time_h", "'yes'" },
  { "header_sys_types_h", "'yes'" },
  { "header_sys_wait_h", "'yes'" },
  { "header_term_h", "'yes'" },
  { "header_termio_h", "'yes'" },
  { "header_termios_h", "'yes'" },
  { "header_time", "'yes'" },
  { "header_unistd_h", "'yes'" },
  { "header_varargs_h", "'no'" },
  { "header_vfork_h", "'no'" },
  { "host_alias", "'i686-pc-linux-gnu'" },
  { "host", "'i686-pc-linux-gnu'" },
  { "ipv6type", "'linux-glibc'" },
  { "langinfo_codeset", "'yes'" },
  { "lib_dir_opendir", "'no'" },
  { "lib_inet_main", "'no'" },
  { "library_path_gnutls", "''" },
  { "library_path_iconv", "''" },
  { "library_path_intl", "''" },
  { "library_path_z", "''" },
  { "locale", "'yes'" },
  { "ncurses_broken", "'no'" },
  { "ncurses_header", "'curses.h'" },
  { "ncurses_version", "'5.7.20090207'" },
  { "need_xopen_extension", "'no'" },
  { "netlibs", "''" },
  { "ngroups", "'yes'" },
  { "objext", "'o'" },
  { "path_BZIP2", "'/bin/bzip2'" },
  { "path_COMPRESS", "'/usr/bin/compress'" },
  { "path_GMSGFMT", "'/usr/bin/msgfmt'" },
  { "path_GZIP", "'/bin/gzip'" },
  { "path_install", "'/usr/bin/install -c'" },
  { "path_INSTALL", "'/usr/bin/install -c'" },
  { "path_lastlog", "'_PATH_LASTLOG'" },
  { "path_MSGFMT", "'/usr/bin/msgfmt'" },
  { "path_MV", "'/bin/mv'" },
  { "path_NCURSES_CONFIG", "'/usr/bin/ncursesw5-config'" },
  { "path_PKG_CONFIG", "'/usr/bin/pkg-config'" },
  { "path_RLOGIN", "'/usr/bin/rlogin'" },
  { "path_RM", "'/bin/rm'" },
  { "path_TAR", "'/bin/tar'" },
  { "path_TELNET", "'/usr/bin/telnet'" },
  { "path_UNCOMPRESS", "'/bin/gunzip'" },
  { "path_UNZIP", "'/usr/bin/unzip'" },
  { "path_UUDECODE", "'/usr/bin/uudecode'" },
  { "path_XGETTEXT", "'/usr/bin/xgettext'" },
  { "path_ZCAT", "'/bin/zcat'" },
  { "path_ZIP", "'/usr/bin/zip'" },
  { "prog_ac_ct_AR", "'ar'" },
  { "prog_ac_ct_CC", "'gcc'" },
  { "prog_ac_ct_RANLIB", "'ranlib'" },
  { "prog_cc_g", "'yes'" },
  { "prog_cc_stdc", "''" },
  { "prog_CPP", "'gcc -E'" },
  { "prog_make_make_set", "'yes'" },
  { "proto_iconv_arg1", "''" },
  { "proto_iconv_const", "'no'" },
  { "rand_max", "'INT_MAX'" },
  { "screen", "'ncursesw'" },
  { "set_errno", "'yes'" },
  { "sizechange", "'yes'" },
  { "sizeof_int", "'4'" },
  { "sizeof_long", "'4'" },
  { "sizeof_off_t", "'8'" },
  { "sizeof_time_t", "'4'" },
  { "srand_func", "'srandom/random'" },
  { "struct_dirent64", "'no'" },
  { "subst_AR_OPTS", "'rv'" },
  { "sys_file_offset_bits", "'64'" },
  { "sys_largefile_CC", "'no'" },
  { "sys_large_files", "'no'" },
  { "sys_largefile_source", "'no'" },
  { "system_mail_flags", "'-t -oi'" },
  { "SYSTEM_MAIL", "'/usr/sbin/sendmail'" },
  { "system_name", "'linux-gnu'" },
  { "sysv_utmp", "'yes'" },
  { "target_alias", "'i686-pc-linux-gnu'" },
  { "target", "'i686-pc-linux-gnu'" },
  { "term_header", "'term.h'" },
  { "termio_and_curses", "'yes'" },
  { "termio_and_termios", "'yes'" },
  { "tm_gmtoff", "'yes'" },
  { "type_getgroups", "'gid_t'" },
  { "type_int", "'yes'" },
  { "type_long", "'yes'" },
  { "type_mode_t", "'yes'" },
  { "type_off_t", "'yes'" },
  { "type_pid_t", "'yes'" },
  { "type_size_t", "'yes'" },
  { "type_socklen_t", "'yes'" },
  { "type_time_t", "'yes'" },
  { "type_uid_t", "'yes'" },
  { "type_unionwait", "'no'" },
  { "use_gnu_gettext", "'no'" },
  { "use_libgnutls", "'/usr'" },
  { "use_libnss_compat", "'no'" },
  { "use_libsocks5", "'no'" },
  { "use_libsocks", "'no'" },
  { "use_libssl", "'no'" },
  { "utf8_lib", "'yes'" },
  { "val_LC_MESSAGES", "'yes'" },
  { "widec_curses", "'yes'" },
  { "widec_mbstate", "'no'" },
  { "working_alloca_h", "'yes'" }
}; // idb
_UNKNOWN off_815D4A4; // weak
_UNKNOWN unk_815DFD2; // weak
const char sug_filename = '\0'; // idb
const char asc_815F777[1] = "\n"; // idb
_UNKNOWN unk_815FE34; // weak
_UNKNOWN unk_81625F4; // weak
_UNKNOWN unk_8162FEA; // weak
const char byte_81631B6 = '\0'; // idb
const char byte_81646F7 = '\0'; // idb
const $8C88F600735D8E7AF3D7B58860F871C9 named_keys[24] =
{
  { 9, "<tab>" },
  { 13, "<return>" },
  { 27, "ESC" },
  { 32, "<space>" },
  { 60, "<" },
  { 62, ">" },
  { 127, "<delete>" },
  { 256, "Up Arrow" },
  { 257, "Down Arrow" },
  { 258, "Right Arrow" },
  { 259, "Left Arrow" },
  { 260, "Page Down" },
  { 261, "Page Up" },
  { 262, "Home" },
  { 263, "End" },
  { 264, "F1" },
  { 265, "Do key" },
  { 266, "Find key" },
  { 267, "Select key" },
  { 268, "Insert key" },
  { 269, "Remove key" },
  { 270, "(DO_NOTHING)" },
  { 271, "Back Tab" },
  { 285, "mouse pseudo key" }
}; // idb
const pretty_html::$DFD70A683CB2E12914EC10A9015A61B4 table_9908[4] = { { 60, "&lt;" }, { 62, "&gt;" }, { 34, "&quot;" }, { 38, "&amp;" } }; // idb
char *const off_8164CC4 = "&lt;"; // idb
const char actual = '\0'; // idb
const HTStructuredClass HTMLPresentation =
{
  "Lynx_HTML_Handler",
  &HTML_free,
  &HTML_abort,
  &HTML_put_character,
  &HTML_put_string,
  &HTML_write,
  &HTML_start_element,
  &HTML_end_element,
  &HTML_put_entity
}; // idb
const HTStreamClass PassThruCache =
{
  "PassThruCache",
  &CacheThru_free,
  &CacheThru_abort,
  &CacheThru_put_character,
  &CacheThru_put_string,
  &CacheThru_write
}; // idb
const HTStreamClass HTFWriter =
{
  "FileWriter",
  &HTFWriter_free,
  &HTFWriter_abort,
  &HTFWriter_put_character,
  &HTFWriter_put_string,
  &HTFWriter_write
}; // idb
const char byte_81673EB = '\0'; // idb
_UNKNOWN unk_8168E75; // weak
const char linkargs[3] = { '\0', '\0', '\0' }; // idb
const names_pairs OLD_charset_names[47] =
{
  { "ISO Latin 1", "iso-8859-1" },
  { "ISO Latin 2", "iso-8859-2" },
  { "WinLatin1 (cp1252)", "windows-1252" },
  { "DEC Multinational", "dec-mcs" },
  { "Macintosh (8 bit)", "macintosh" },
  { "NeXT character set", "next" },
  { "KOI8-R Cyrillic", "koi8-r" },
  { "Chinese", "euc-cn" },
  { "Japanese (EUC)", "euc-jp" },
  { "Japanese (SJIS)", "shift_jis" },
  { "Korean", "euc-kr" },
  { "Taipei (Big5)", "big5" },
  { "Vietnamese (VISCII)", "viscii" },
  { "7 bit approximations", "us-ascii" },
  { "Transparent", "x-transparent" },
  { "DosLatinUS (cp437)", "cp437" },
  { "IBM PC character set", "cp437" },
  { "DosLatin1 (cp850)", "cp850" },
  { "IBM PC codepage 850", "cp850" },
  { "DosLatin2 (cp852)", "cp852" },
  { "PC Latin2 CP 852", "cp852" },
  { "DosCyrillic (cp866)", "cp866" },
  { "DosArabic (cp864)", "cp864" },
  { "DosGreek (cp737)", "cp737" },
  { "DosBaltRim (cp775)", "cp775" },
  { "DosGreek2 (cp869)", "cp869" },
  { "DosHebrew (cp862)", "cp862" },
  { "WinLatin2 (cp1250)", "windows-1250" },
  { "WinCyrillic (cp1251)", "windows-1251" },
  { "WinGreek (cp1253)", "windows-1253" },
  { "WinHebrew (cp1255)", "windows-1255" },
  { "WinArabic (cp1256)", "windows-1256" },
  { "WinBaltRim (cp1257)", "windows-1257" },
  { "ISO Latin 3", "iso-8859-3" },
  { "ISO Latin 4", "iso-8859-4" },
  { "ISO 8859-5 Cyrillic", "iso-8859-5" },
  { "ISO 8859-6 Arabic", "iso-8859-6" },
  { "ISO 8859-7 Greek", "iso-8859-7" },
  { "ISO 8859-8 Hebrew", "iso-8859-8" },
  { "ISO-8859-8-I", "iso-8859-8" },
  { "ISO-8859-8-E", "iso-8859-8" },
  { "ISO 8859-9 (Latin 5)", "iso-8859-9" },
  { "ISO 8859-10", "iso-8859-10" },
  { "UNICODE UTF 8", "utf-8" },
  { "RFC 1345 w/o Intro", "mnemonic+ascii+0" },
  { "RFC 1345 Mnemonic", "mnemonic" },
  { NULL, NULL }
}; // idb
_UNKNOWN unk_816A0B7; // weak
const UC_entity_info unicode_entities_10252[996] =
{
  { "AElig", 198u },
  { "Aacgr", 902u },
  { "Aacute", 193u },
  { "Abreve", 258u },
  { "Acirc", 194u },
  { "Acy", 1040u },
  { "Agr", 913u },
  { "Agrave", 192u },
  { "Alpha", 913u },
  { "Amacr", 256u },
  { "Aogon", 260u },
  { "Aring", 197u },
  { "Atilde", 195u },
  { "Auml", 196u },
  { "Barwed", 8966u },
  { "Bcy", 1041u },
  { "Beta", 914u },
  { "Bgr", 914u },
  { "CHcy", 1063u },
  { "Cacute", 262u },
  { "Cap", 8914u },
  { "Ccaron", 268u },
  { "Ccedil", 199u },
  { "Ccirc", 264u },
  { "Cdot", 266u },
  { "Chi", 935u },
  { "Cup", 8915u },
  { "DJcy", 1026u },
  { "DScy", 1029u },
  { "DZcy", 1039u },
  { "Dagger", 8225u },
  { "Dcaron", 270u },
  { "Dcy", 1044u },
  { "Delta", 916u },
  { "Dgr", 916u },
  { "Dot", 168u },
  { "DotDot", 8412u },
  { "Dstrok", 272u },
  { "EEacgr", 905u },
  { "EEgr", 919u },
  { "ENG", 330u },
  { "ETH", 208u },
  { "Eacgr", 904u },
  { "Eacute", 201u },
  { "Ecaron", 282u },
  { "Ecirc", 202u },
  { "Ecy", 1069u },
  { "Edot", 278u },
  { "Egr", 917u },
  { "Egrave", 200u },
  { "Emacr", 274u },
  { "Eogon", 280u },
  { "Epsilon", 917u },
  { "Eta", 919u },
  { "Euml", 203u },
  { "Fcy", 1060u },
  { "GJcy", 1027u },
  { "Gamma", 915u },
  { "Gbreve", 286u },
  { "Gcedil", 290u },
  { "Gcirc", 284u },
  { "Gcy", 1043u },
  { "Gdot", 288u },
  { "Gg", 8921u },
  { "Ggr", 915u },
  { "Gt", 8811u },
  { "HARDcy", 1066u },
  { "Hcirc", 292u },
  { "Hstrok", 294u },
  { "IEcy", 1045u },
  { "IJlig", 306u },
  { "IOcy", 1025u },
  { "Iacgr", 906u },
  { "Iacute", 205u },
  { "Icirc", 206u },
  { "Icy", 1048u },
  { "Idigr", 938u },
  { "Idot", 304u },
  { "Igr", 921u },
  { "Igrave", 204u },
  { "Imacr", 298u },
  { "Iogon", 302u },
  { "Iota", 921u },
  { "Itilde", 296u },
  { "Iukcy", 1030u },
  { "Iuml", 207u },
  { "Jcirc", 308u },
  { "Jcy", 1049u },
  { "Jsercy", 1032u },
  { "Jukcy", 1028u },
  { "KHcy", 1061u },
  { "KHgr", 935u },
  { "KJcy", 1036u },
  { "Kappa", 922u },
  { "Kcedil", 310u },
  { "Kcy", 1050u },
  { "Kgr", 922u },
  { "LJcy", 1033u },
  { "Lacute", 313u },
  { "Lambda", 923u },
  { "Larr", 8606u },
  { "Lcaron", 317u },
  { "Lcedil", 315u },
  { "Lcy", 1051u },
  { "Lgr", 923u },
  { "Ll", 8920u },
  { "Lmidot", 319u },
  { "Lstrok", 321u },
  { "Lt", 8810u },
  { "Mcy", 1052u },
  { "Mgr", 924u },
  { "Mu", 924u },
  { "NJcy", 1034u },
  { "Nacute", 323u },
  { "Ncaron", 327u },
  { "Ncedil", 325u },
  { "Ncy", 1053u },
  { "Ngr", 925u },
  { "Ntilde", 209u },
  { "Nu", 925u },
  { "OElig", 338u },
  { "OHacgr", 911u },
  { "OHgr", 937u },
  { "Oacgr", 908u },
  { "Oacute", 211u },
  { "Ocirc", 212u },
  { "Ocy", 1054u },
  { "Odblac", 336u },
  { "Ogr", 927u },
  { "Ograve", 210u },
  { "Omacr", 332u },
  { "Omega", 937u },
  { "Omicron", 927u },
  { "Oslash", 216u },
  { "Otilde", 213u },
  { "Ouml", 214u },
  { "PHgr", 934u },
  { "PSgr", 936u },
  { "Pcy", 1055u },
  { "Pgr", 928u },
  { "Phi", 934u },
  { "Pi", 928u },
  { "Prime", 8243u },
  { "Psi", 936u },
  { "Racute", 340u },
  { "Rarr", 8608u },
  { "Rcaron", 344u },
  { "Rcedil", 342u },
  { "Rcy", 1056u },
  { "Rgr", 929u },
  { "Rho", 929u },
  { "SHCHcy", 1065u },
  { "SHcy", 1064u },
  { "SOFTcy", 1068u },
  { "Sacute", 346u },
  { "Scaron", 352u },
  { "Scedil", 350u },
  { "Scirc", 348u },
  { "Scy", 1057u },
  { "Sgr", 931u },
  { "Sigma", 931u },
  { "Sub", 8912u },
  { "Sup", 8913u },
  { "THORN", 222u },
  { "THgr", 920u },
  { "TSHcy", 1035u },
  { "TScy", 1062u },
  { "Tau", 932u },
  { "Tcaron", 356u },
  { "Tcedil", 354u },
  { "Tcy", 1058u },
  { "Tgr", 932u },
  { "Theta", 920u },
  { "Tstrok", 358u },
  { "Uacgr", 910u },
  { "Uacute", 218u },
  { "Ubrcy", 1038u },
  { "Ubreve", 364u },
  { "Ucirc", 219u },
  { "Ucy", 1059u },
  { "Udblac", 368u },
  { "Udigr", 939u },
  { "Ugr", 933u },
  { "Ugrave", 217u },
  { "Umacr", 362u },
  { "Uogon", 370u },
  { "Upsi", 933u },
  { "Upsilon", 933u },
  { "Uring", 366u },
  { "Utilde", 360u },
  { "Uuml", 220u },
  { "Vcy", 1042u },
  { "Vdash", 8873u },
  { "Verbar", 8214u },
  { "Vvdash", 8874u },
  { "Wcirc", 372u },
  { "Xgr", 926u },
  { "Xi", 926u },
  { "YAcy", 1071u },
  { "YIcy", 1031u },
  { "YUcy", 1070u },
  { "Yacute", 221u },
  { "Ycirc", 374u },
  { "Ycy", 1067u },
  { "Yuml", 376u },
  { "ZHcy", 1046u },
  { "Zacute", 377u },
  { "Zcaron", 381u },
  { "Zcy", 1047u },
  { "Zdot", 379u },
  { "Zeta", 918u },
  { "Zgr", 918u },
  { "aacgr", 940u },
  { "aacute", 225u },
  { "abreve", 259u },
  { "acirc", 226u },
  { "acute", 180u },
  { "acy", 1072u },
  { "aelig", 230u },
  { "agr", 945u },
  { "agrave", 224u },
  { "alefsym", 8501u },
  { "aleph", 8501u },
  { "alpha", 945u },
  { "amacr", 257u },
  { "amalg", 8720u },
  { "amp", 38u },
  { "and", 8743u },
  { "ang", 8736u },
  { "ang90", 8735u },
  { "angmsd", 8737u },
  { "angsph", 8738u },
  { "angst", 8491u },
  { "aogon", 261u },
  { "ap", 8776u },
  { "ape", 8778u },
  { "apos", 700u },
  { "aring", 229u },
  { "ast", 42u },
  { "asymp", 8776u },
  { "atilde", 227u },
  { "auml", 228u },
  { "b.Delta", 916u },
  { "b.Gamma", 915u },
  { "b.Lambda", 923u },
  { "b.Omega", 937u },
  { "b.Phi", 934u },
  { "b.Pi", 928u },
  { "b.Psi", 936u },
  { "b.Sigma", 931u },
  { "b.Theta", 920u },
  { "b.Upsi", 933u },
  { "b.Xi", 926u },
  { "b.alpha", 945u },
  { "b.beta", 946u },
  { "b.chi", 967u },
  { "b.delta", 948u },
  { "b.epsi", 949u },
  { "b.epsis", 949u },
  { "b.epsiv", 949u },
  { "b.eta", 951u },
  { "b.gamma", 947u },
  { "b.gammad", 988u },
  { "b.iota", 953u },
  { "b.kappa", 954u },
  { "b.kappav", 1008u },
  { "b.lambda", 955u },
  { "b.mu", 956u },
  { "b.nu", 957u },
  { "b.omega", 974u },
  { "b.phis", 966u },
  { "b.phiv", 981u },
  { "b.pi", 960u },
  { "b.piv", 982u },
  { "b.psi", 968u },
  { "b.rho", 961u },
  { "b.rhov", 1009u },
  { "b.sigma", 963u },
  { "b.sigmav", 962u },
  { "b.tau", 964u },
  { "b.thetas", 952u },
  { "b.thetav", 977u },
  { "b.upsi", 965u },
  { "b.xi", 958u },
  { "b.zeta", 950u },
  { "barwed", 8892u },
  { "bcong", 8780u },
  { "bcy", 1073u },
  { "bdquo", 8222u },
  { "becaus", 8757u },
  { "bepsi", 8717u },
  { "bernou", 8492u },
  { "beta", 946u },
  { "beth", 8502u },
  { "bgr", 946u },
  { "blank", 9251u },
  { "blk12", 9618u },
  { "blk14", 9617u },
  { "blk34", 9619u },
  { "block", 9608u },
  { "bottom", 8869u },
  { "bowtie", 8904u },
  { "boxDL", 9559u },
  { "boxDR", 9556u },
  { "boxDl", 9558u },
  { "boxDr", 9555u },
  { "boxH", 9552u },
  { "boxHD", 9574u },
  { "boxHU", 9577u },
  { "boxHd", 9572u },
  { "boxHu", 9575u },
  { "boxUL", 9565u },
  { "boxUR", 9562u },
  { "boxUl", 9564u },
  { "boxUr", 9561u },
  { "boxV", 9553u },
  { "boxVH", 9580u },
  { "boxVL", 9571u },
  { "boxVR", 9568u },
  { "boxVh", 9579u },
  { "boxVl", 9570u },
  { "boxVr", 9567u },
  { "boxdL", 9557u },
  { "boxdR", 9554u },
  { "boxdl", 9488u },
  { "boxdr", 9484u },
  { "boxh", 9472u },
  { "boxhD", 9573u },
  { "boxhU", 9576u },
  { "boxhd", 9516u },
  { "boxhu", 9524u },
  { "boxuL", 9563u },
  { "boxuR", 9560u },
  { "boxul", 9496u },
  { "boxur", 9492u },
  { "boxv", 9474u },
  { "boxvH", 9578u },
  { "boxvL", 9569u },
  { "boxvR", 9566u },
  { "boxvh", 9532u },
  { "boxvl", 9508u },
  { "boxvr", 9500u },
  { "bprime", 8245u },
  { "breve", 728u },
  { "brkbar", 166u },
  { "brvbar", 166u },
  { "bsim", 8765u },
  { "bsime", 8909u },
  { "bsol", 92u },
  { "bull", 8226u },
  { "bump", 8782u },
  { "bumpe", 8783u },
  { "cacute", 263u },
  { "cap", 8745u },
  { "caret", 8257u },
  { "caron", 711u },
  { "ccaron", 269u },
  { "ccedil", 231u },
  { "ccirc", 265u },
  { "cdot", 267u },
  { "cedil", 184u },
  { "cent", 162u },
  { "chcy", 1095u },
  { "check", 10003u },
  { "chi", 967u },
  { "cir", 9675u },
  { "circ", 710u },
  { "cire", 8791u },
  { "clubs", 9827u },
  { "colon", 58u },
  { "colone", 8788u },
  { "comma", 44u },
  { "commat", 64u },
  { "comp", 8705u },
  { "compfn", 8728u },
  { "cong", 8773u },
  { "conint", 8750u },
  { "coprod", 8720u },
  { "copy", 169u },
  { "copysr", 8471u },
  { "crarr", 8629u },
  { "cross", 10007u },
  { "cuepr", 8926u },
  { "cuesc", 8927u },
  { "cularr", 8630u },
  { "cup", 8746u },
  { "cupre", 8828u },
  { "curarr", 8631u },
  { "curren", 164u },
  { "cuvee", 8910u },
  { "cuwed", 8911u },
  { "dArr", 8659u },
  { "dagger", 8224u },
  { "daleth", 8504u },
  { "darr", 8595u },
  { "darr2", 8650u },
  { "dash", 8208u },
  { "dashv", 8867u },
  { "dblac", 733u },
  { "dcaron", 271u },
  { "dcy", 1076u },
  { "deg", 176u },
  { "delta", 948u },
  { "dgr", 948u },
  { "dharl", 8643u },
  { "dharr", 8642u },
  { "diam", 8900u },
  { "diams", 9830u },
  { "die", 168u },
  { "divide", 247u },
  { "divonx", 8903u },
  { "djcy", 1106u },
  { "dlarr", 8601u },
  { "dlcorn", 8990u },
  { "dlcrop", 8973u },
  { "dollar", 36u },
  { "dot", 729u },
  { "drarr", 8600u },
  { "drcorn", 8991u },
  { "drcrop", 8972u },
  { "dscy", 1109u },
  { "dstrok", 273u },
  { "dtri", 9663u },
  { "dtrif", 9662u },
  { "dzcy", 1119u },
  { "eDot", 8785u },
  { "eacgr", 941u },
  { "eacute", 233u },
  { "ecaron", 283u },
  { "ecir", 8790u },
  { "ecirc", 234u },
  { "ecolon", 8789u },
  { "ecy", 1101u },
  { "edot", 279u },
  { "eeacgr", 942u },
  { "eegr", 951u },
  { "efDot", 8786u },
  { "egr", 949u },
  { "egrave", 232u },
  { "egs", 8925u },
  { "ell", 8467u },
  { "els", 8924u },
  { "emacr", 275u },
  { "emdash", 8212u },
  { "empty", 8709u },
  { "emsp", 8195u },
  { "emsp13", 8196u },
  { "emsp14", 8197u },
  { "endash", 8211u },
  { "eng", 331u },
  { "ensp", 8194u },
  { "eogon", 281u },
  { "epsi", 949u },
  { "epsilon", 949u },
  { "epsis", 8714u },
  { "equals", 61u },
  { "equiv", 8801u },
  { "erDot", 8787u },
  { "esdot", 8784u },
  { "eta", 951u },
  { "eth", 240u },
  { "euml", 235u },
  { "euro", 8364u },
  { "excl", 33u },
  { "exist", 8707u },
  { "fcy", 1092u },
  { "female", 9792u },
  { "ffilig", 64259u },
  { "fflig", 64256u },
  { "ffllig", 64260u },
  { "filig", 64257u },
  { "flat", 9837u },
  { "fllig", 64258u },
  { "fnof", 402u },
  { "forall", 8704u },
  { "fork", 8916u },
  { "frac12", 189u },
  { "frac13", 8531u },
  { "frac14", 188u },
  { "frac15", 8533u },
  { "frac16", 8537u },
  { "frac18", 8539u },
  { "frac23", 8532u },
  { "frac25", 8534u },
  { "frac34", 190u },
  { "frac35", 8535u },
  { "frac38", 8540u },
  { "frac45", 8536u },
  { "frac56", 8538u },
  { "frac58", 8541u },
  { "frac78", 8542u },
  { "frasl", 8260u },
  { "frown", 8994u },
  { "gE", 8807u },
  { "gacute", 501u },
  { "gamma", 947u },
  { "gammad", 988u },
  { "gbreve", 287u },
  { "gcedil", 291u },
  { "gcirc", 285u },
  { "gcy", 1075u },
  { "gdot", 289u },
  { "ge", 8805u },
  { "gel", 8923u },
  { "ges", 8805u },
  { "ggr", 947u },
  { "gimel", 8503u },
  { "gjcy", 1107u },
  { "gl", 8823u },
  { "gnE", 8809u },
  { "gne", 8809u },
  { "gnsim", 8935u },
  { "grave", 96u },
  { "gsdot", 8919u },
  { "gsim", 8819u },
  { "gt", 62u },
  { "gvnE", 8809u },
  { "hArr", 8660u },
  { "hairsp", 8202u },
  { "half", 189u },
  { "hamilt", 8459u },
  { "hardcy", 1098u },
  { "harr", 8596u },
  { "harrw", 8621u },
  { "hcirc", 293u },
  { "hearts", 9829u },
  { "hellip", 8230u },
  { "hibar", 175u },
  { "horbar", 8213u },
  { "hstrok", 295u },
  { "hybull", 8259u },
  { "hyphen", 45u },
  { "iacgr", 943u },
  { "iacute", 237u },
  { "icirc", 238u },
  { "icy", 1080u },
  { "idiagr", 912u },
  { "idigr", 970u },
  { "iecy", 1077u },
  { "iexcl", 161u },
  { "iff", 8660u },
  { "igr", 953u },
  { "igrave", 236u },
  { "ijlig", 307u },
  { "imacr", 299u },
  { "image", 8465u },
  { "incare", 8453u },
  { "infin", 8734u },
  { "inodot", 305u },
  { "int", 8747u },
  { "intcal", 8890u },
  { "iocy", 1105u },
  { "iogon", 303u },
  { "iota", 953u },
  { "iquest", 191u },
  { "isin", 8712u },
  { "itilde", 297u },
  { "iukcy", 1110u },
  { "iuml", 239u },
  { "jcirc", 309u },
  { "jcy", 1081u },
  { "jsercy", 1112u },
  { "jukcy", 1108u },
  { "kappa", 954u },
  { "kappav", 1008u },
  { "kcedil", 311u },
  { "kcy", 1082u },
  { "kgr", 954u },
  { "kgreen", 312u },
  { "khcy", 1093u },
  { "khgr", 967u },
  { "kjcy", 1116u },
  { "lAarr", 8666u },
  { "lArr", 8656u },
  { "lE", 8806u },
  { "lacute", 314u },
  { "lagran", 8466u },
  { "lambda", 955u },
  { "lang", 9001u },
  { "laquo", 171u },
  { "larr", 8592u },
  { "larr2", 8647u },
  { "larrhk", 8617u },
  { "larrlp", 8619u },
  { "larrtl", 8610u },
  { "lcaron", 318u },
  { "lcedil", 316u },
  { "lceil", 8968u },
  { "lcub", 123u },
  { "lcy", 1083u },
  { "ldot", 8918u },
  { "ldquo", 8220u },
  { "ldquor", 8222u },
  { "le", 8804u },
  { "leg", 8922u },
  { "les", 8804u },
  { "lfloor", 8970u },
  { "lg", 8822u },
  { "lgr", 955u },
  { "lhard", 8637u },
  { "lharu", 8636u },
  { "lhblk", 9604u },
  { "ljcy", 1113u },
  { "lmidot", 320u },
  { "lnE", 8808u },
  { "lne", 8808u },
  { "lnsim", 8934u },
  { "lowast", 8727u },
  { "lowbar", 95u },
  { "loz", 9674u },
  { "lozf", 10022u },
  { "lpar", 40u },
  { "lrarr2", 8646u },
  { "lrhar2", 8651u },
  { "lrm", 8206u },
  { "lsaquo", 8249u },
  { "lsh", 8624u },
  { "lsim", 8818u },
  { "lsqb", 91u },
  { "lsquo", 8216u },
  { "lsquor", 8218u },
  { "lstrok", 322u },
  { "lt", 60u },
  { "lthree", 8907u },
  { "ltimes", 8905u },
  { "ltri", 9667u },
  { "ltrie", 8884u },
  { "ltrif", 9666u },
  { "lvnE", 8808u },
  { "macr", 175u },
  { "male", 9794u },
  { "malt", 10016u },
  { "map", 8614u },
  { "marker", 9646u },
  { "mcy", 1084u },
  { "mdash", 8212u },
  { "mgr", 956u },
  { "micro", 181u },
  { "mid", 8739u },
  { "middot", 183u },
  { "minus", 8722u },
  { "minusb", 8863u },
  { "mldr", 8230u },
  { "mnplus", 8723u },
  { "models", 8871u },
  { "mu", 956u },
  { "mumap", 8888u },
  { "nVDash", 8879u },
  { "nVdash", 8878u },
  { "nabla", 8711u },
  { "nacute", 324u },
  { "nap", 8777u },
  { "napos", 329u },
  { "natur", 9838u },
  { "nbsp", 160u },
  { "ncaron", 328u },
  { "ncedil", 326u },
  { "ncong", 8775u },
  { "ncy", 1085u },
  { "ndash", 8211u },
  { "ne", 8800u },
  { "nearr", 8599u },
  { "nequiv", 8802u },
  { "nexist", 8708u },
  { "nge", 8817u },
  { "nges", 8817u },
  { "ngr", 957u },
  { "ngt", 8815u },
  { "nhArr", 8654u },
  { "nharr", 8622u },
  { "ni", 8715u },
  { "njcy", 1114u },
  { "nlArr", 8653u },
  { "nlarr", 8602u },
  { "nldr", 8229u },
  { "nle", 8816u },
  { "nles", 8816u },
  { "nlt", 8814u },
  { "nltri", 8938u },
  { "nltrie", 8940u },
  { "nmid", 8740u },
  { "not", 172u },
  { "notin", 8713u },
  { "npar", 8742u },
  { "npr", 8832u },
  { "npre", 8928u },
  { "nrArr", 8655u },
  { "nrarr", 8603u },
  { "nrtri", 8939u },
  { "nrtrie", 8941u },
  { "nsc", 8833u },
  { "nsce", 8929u },
  { "nsim", 8769u },
  { "nsime", 8772u },
  { "nspar", 8742u },
  { "nsub", 8836u },
  { "nsubE", 8840u },
  { "nsube", 8840u },
  { "nsup", 8837u },
  { "nsupE", 8841u },
  { "nsupe", 8841u },
  { "ntilde", 241u },
  { "nu", 957u },
  { "num", 35u },
  { "numero", 8470u },
  { "numsp", 8199u },
  { "nvDash", 8877u },
  { "nvdash", 8876u },
  { "nwarr", 8598u },
  { "oS", 9416u },
  { "oacgr", 972u },
  { "oacute", 243u },
  { "oast", 8859u },
  { "ocir", 8858u },
  { "ocirc", 244u },
  { "ocy", 1086u },
  { "odash", 8861u },
  { "odblac", 337u },
  { "odot", 8857u },
  { "oelig", 339u },
  { "ogon", 731u },
  { "ogr", 959u },
  { "ograve", 242u },
  { "ohacgr", 974u },
  { "ohgr", 969u },
  { "ohm", 8486u },
  { "olarr", 8634u },
  { "oline", 8254u },
  { "omacr", 333u },
  { "omega", 969u },
  { "omicron", 959u },
  { "ominus", 8854u },
  { "oplus", 8853u },
  { "or", 8744u },
  { "orarr", 8635u },
  { "order", 8500u },
  { "ordf", 170u },
  { "ordm", 186u },
  { "oslash", 248u },
  { "osol", 8856u },
  { "otilde", 245u },
  { "otimes", 8855u },
  { "ouml", 246u },
  { "par", 8741u },
  { "para", 182u },
  { "part", 8706u },
  { "pcy", 1087u },
  { "percnt", 37u },
  { "period", 46u },
  { "permil", 8240u },
  { "perp", 8869u },
  { "pgr", 960u },
  { "phgr", 966u },
  { "phi", 966u },
  { "phis", 966u },
  { "phiv", 981u },
  { "phmmat", 8499u },
  { "phone", 9742u },
  { "pi", 960u },
  { "piv", 982u },
  { "planck", 8463u },
  { "plus", 43u },
  { "plusb", 8862u },
  { "plusdo", 8724u },
  { "plusmn", 177u },
  { "pound", 163u },
  { "pr", 8826u },
  { "pre", 8828u },
  { "prime", 8242u },
  { "prnsim", 8936u },
  { "prod", 8719u },
  { "prop", 8733u },
  { "prsim", 8830u },
  { "psgr", 968u },
  { "psi", 968u },
  { "puncsp", 8200u },
  { "quest", 63u },
  { "quot", 34u },
  { "rAarr", 8667u },
  { "rArr", 8658u },
  { "racute", 341u },
  { "radic", 8730u },
  { "rang", 9002u },
  { "raquo", 187u },
  { "rarr", 8594u },
  { "rarr2", 8649u },
  { "rarrhk", 8618u },
  { "rarrlp", 8620u },
  { "rarrtl", 8611u },
  { "rarrw", 8605u },
  { "rcaron", 345u },
  { "rcedil", 343u },
  { "rceil", 8969u },
  { "rcub", 125u },
  { "rcy", 1088u },
  { "rdquo", 8221u },
  { "rdquor", 8220u },
  { "real", 8476u },
  { "rect", 9645u },
  { "reg", 174u },
  { "rfloor", 8971u },
  { "rgr", 961u },
  { "rhard", 8641u },
  { "rharu", 8640u },
  { "rho", 961u },
  { "rhov", 1009u },
  { "ring", 730u },
  { "rlarr2", 8644u },
  { "rlhar2", 8652u },
  { "rlm", 8207u },
  { "rpar", 41u },
  { "rsaquo", 8250u },
  { "rsh", 8625u },
  { "rsqb", 93u },
  { "rsquo", 8217u },
  { "rsquor", 8216u },
  { "rthree", 8908u },
  { "rtimes", 8906u },
  { "rtri", 9657u },
  { "rtrie", 8885u },
  { "rtrif", 9656u },
  { "rx", 8478u },
  { "sacute", 347u },
  { "samalg", 8720u },
  { "sbquo", 8218u },
  { "sbsol", 92u },
  { "sc", 8827u },
  { "scaron", 353u },
  { "sccue", 8829u },
  { "sce", 8829u },
  { "scedil", 351u },
  { "scirc", 349u },
  { "scnsim", 8937u },
  { "scsim", 8831u },
  { "scy", 1089u },
  { "sdot", 8901u },
  { "sdotb", 8865u },
  { "sect", 167u },
  { "semi", 59u },
  { "setmn", 8726u },
  { "sext", 10038u },
  { "sfgr", 962u },
  { "sfrown", 8994u },
  { "sgr", 963u },
  { "sharp", 9839u },
  { "shchcy", 1097u },
  { "shcy", 1096u },
  { "shy", 173u },
  { "sigma", 963u },
  { "sigmaf", 962u },
  { "sigmav", 962u },
  { "sim", 8764u },
  { "sime", 8771u },
  { "smile", 8995u },
  { "softcy", 1100u },
  { "sol", 47u },
  { "spades", 9824u },
  { "spar", 8741u },
  { "sqcap", 8851u },
  { "sqcup", 8852u },
  { "sqsub", 8847u },
  { "sqsube", 8849u },
  { "sqsup", 8848u },
  { "sqsupe", 8850u },
  { "squ", 9633u },
  { "square", 9633u },
  { "squf", 9642u },
  { "ssetmn", 8726u },
  { "ssmile", 8995u },
  { "sstarf", 8902u },
  { "star", 9734u },
  { "starf", 9733u },
  { "sub", 8834u },
  { "subE", 8838u },
  { "sube", 8838u },
  { "subnE", 8842u },
  { "subne", 8842u },
  { "sum", 8721u },
  { "sung", 9834u },
  { "sup", 8835u },
  { "sup1", 185u },
  { "sup2", 178u },
  { "sup3", 179u },
  { "supE", 8839u },
  { "supe", 8839u },
  { "supnE", 8843u },
  { "supne", 8843u },
  { "szlig", 223u },
  { "target", 8982u },
  { "tau", 964u },
  { "tcaron", 357u },
  { "tcedil", 355u },
  { "tcy", 1090u },
  { "tdot", 8411u },
  { "telrec", 8981u },
  { "tgr", 964u },
  { "there4", 8756u },
  { "theta", 952u },
  { "thetas", 952u },
  { "thetasym", 977u },
  { "thetav", 977u },
  { "thgr", 952u },
  { "thinsp", 8201u },
  { "thkap", 8776u },
  { "thksim", 8764u },
  { "thorn", 254u },
  { "tilde", 732u },
  { "times", 215u },
  { "timesb", 8864u },
  { "top", 8868u },
  { "tprime", 8244u },
  { "trade", 8482u },
  { "trie", 8796u },
  { "tscy", 1094u },
  { "tshcy", 1115u },
  { "tstrok", 359u },
  { "twixt", 8812u },
  { "uArr", 8657u },
  { "uacgr", 973u },
  { "uacute", 250u },
  { "uarr", 8593u },
  { "uarr2", 8648u },
  { "ubrcy", 1118u },
  { "ubreve", 365u },
  { "ucirc", 251u },
  { "ucy", 1091u },
  { "udblac", 369u },
  { "udiagr", 944u },
  { "udigr", 971u },
  { "ugr", 965u },
  { "ugrave", 249u },
  { "uharl", 8639u },
  { "uharr", 8638u },
  { "uhblk", 9600u },
  { "ulcorn", 8988u },
  { "ulcrop", 8975u },
  { "umacr", 363u },
  { "uml", 168u },
  { "uogon", 371u },
  { "uplus", 8846u },
  { "upsi", 965u },
  { "upsih", 978u },
  { "upsilon", 965u },
  { "urcorn", 8989u },
  { "urcrop", 8974u },
  { "uring", 367u },
  { "utilde", 361u },
  { "utri", 9653u },
  { "utrif", 9652u },
  { "uuml", 252u },
  { "vArr", 8661u },
  { "vDash", 8872u },
  { "varr", 8597u },
  { "vcy", 1074u },
  { "vdash", 8866u },
  { "veebar", 8891u },
  { "vellip", 8942u },
  { "verbar", 124u },
  { "vltri", 8882u },
  { "vprime", 8242u },
  { "vprop", 8733u },
  { "vrtri", 8883u },
  { "vsubnE", 8842u },
  { "vsubne", 8842u },
  { "vsupnE", 8843u },
  { "vsupne", 8843u },
  { "wcirc", 373u },
  { "wedgeq", 8793u },
  { "weierp", 8472u },
  { "wreath", 8768u },
  { "xcirc", 9675u },
  { "xdtri", 9661u },
  { "xgr", 958u },
  { "xhArr", 8596u },
  { "xharr", 8596u },
  { "xi", 958u },
  { "xlArr", 8656u },
  { "xrArr", 8658u },
  { "xutri", 9651u },
  { "yacute", 253u },
  { "yacy", 1103u },
  { "ycirc", 375u },
  { "ycy", 1099u },
  { "yen", 165u },
  { "yicy", 1111u },
  { "yucy", 1102u },
  { "yuml", 255u },
  { "zacute", 378u },
  { "zcaron", 382u },
  { "zcy", 1079u },
  { "zdot", 380u },
  { "zeta", 950u },
  { "zgr", 950u },
  { "zhcy", 1078u },
  { "zwj", 8205u },
  { "zwnj", 8204u }
}; // idb
const char byte_816D938[4] = { '\0', '\0', '\0', '\0' }; // idb
_UNKNOWN unk_816DCA5; // weak
const char byte_816DF60 = '\0'; // idb
const LYConfigCookies::$1AAB0E6403962717F25D494B2A4600D6 table_13950[10] =
{
  { &LYCookieSAcceptDomains, 0, 1 },
  { &LYCookieSRejectDomains, 1, 1 },
  { &LYCookieSStrictCheckDomains, 5, 1 },
  { &LYCookieSLooseCheckDomains, 6, 1 },
  { &LYCookieSQueryCheckDomains, 4, 1 },
  { &LYCookieAcceptDomains, 0, 0 },
  { &LYCookieRejectDomains, 1, 0 },
  { &LYCookieStrictCheckDomains, 5, 0 },
  { &LYCookieLooseCheckDomains, 6, 0 },
  { &LYCookieQueryCheckDomains, 4, 0 }
}; // idb
_UNKNOWN unk_816F168; // weak
const initialise_default_stylesheet::$5F4D5E08207C128B37B2866BE69AA03B table2_10585[27] =
{
  { 0, "normal" },
  { 1, "a" },
  { 2, "status" },
  { 4, "b" },
  { 4, "blink" },
  { 4, "cite" },
  { 4, "del" },
  { 4, "em" },
  { 4, "i" },
  { 4, "ins" },
  { 4, "strike" },
  { 4, "strong" },
  { 4, "u" },
  { 6, "alink" },
  { 7, "whereis" },
  { 4, "span.htmlsrc_comment" },
  { 4, "span.htmlsrc_tag" },
  { 4, "span.htmlsrc_attrib" },
  { 4, "span.htmlsrc_attrval" },
  { 4, "span.htmlsrc_abracket" },
  { 4, "span.htmlsrc_entity" },
  { 4, "span.htmlsrc_href" },
  { 4, "span.htmlsrc_entire" },
  { 4, "span.htmlsrc_badseq" },
  { 4, "span.htmlsrc_badtag" },
  { 4, "span.htmlsrc_badattr" },
  { 4, "span.htmlsrc_sgmlspecial" }
}; // idb
const char byte_816F697 = '\0'; // idb
_UNKNOWN unk_816FD97; // weak
const __int16 yylhs[36] =
{
  -1,
  0,
  0,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  2,
  2,
  2,
  2,
  2,
  1,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  8,
  8,
  8,
  8,
  3,
  3
}; // idb
const __int16 yylen[36] =
{
  2,
  0,
  2,
  1,
  2,
  1,
  1,
  2,
  1,
  2,
  4,
  4,
  6,
  6,
  1,
  1,
  2,
  2,
  1,
  1,
  3,
  5,
  2,
  4,
  2,
  3,
  5,
  6,
  3,
  9,
  2,
  2,
  2,
  2,
  0,
  1
}; // idb
const __int16 yydefred[59] =
{
  1,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  5,
  0,
  8,
  0,
  0,
  0,
  32,
  30,
  35,
  0,
  33,
  31,
  0,
  0,
  0,
  9,
  0,
  19,
  0,
  18,
  4,
  7,
  0,
  0,
  0,
  25,
  28,
  0,
  0,
  16,
  17,
  0,
  0,
  0,
  23,
  0,
  11,
  10,
  0,
  0,
  26,
  0,
  0,
  21,
  0,
  27,
  13,
  12,
  0,
  0,
  29
}; // idb
const __int16 yydgoto[9] = { 1, 27, 28, 23, 6, 7, 8, 9, 10 }; // idb
const __int16 yysindex[59] =
{
  0,
  -240,
  -41,
  -256,
  -227,
  -45,
  0,
  -251,
  0,
  -251,
  0,
  -254,
  -249,
  -22,
  0,
  0,
  0,
  -237,
  0,
  0,
  -235,
  -228,
  -226,
  0,
  -236,
  0,
  -224,
  0,
  0,
  0,
  -223,
  -39,
  -222,
  0,
  0,
  -58,
  -7,
  0,
  0,
  -15,
  -220,
  -215,
  0,
  -218,
  0,
  0,
  -217,
  -216,
  0,
  -214,
  -234,
  0,
  -8,
  0,
  0,
  0,
  -213,
  -212,
  0
}; // idb
const __int16 yyrindex[59] =
{
  0,
  0,
  0,
  0,
  0,
  5,
  0,
  26,
  0,
  31,
  0,
  0,
  0,
  11,
  0,
  0,
  0,
  37,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  21,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
const __int16 yygindex[9] = { 0, -17, 44, -31, 0, 0, 0, 0, 0 }; // idb
const __int16 yytable[301] =
{
  43,
  34,
  22,
  12,
  45,
  34,
  41,
  24,
  13,
  38,
  30,
  22,
  25,
  21,
  26,
  31,
  15,
  2,
  44,
  55,
  3,
  20,
  32,
  4,
  5,
  16,
  3,
  33,
  34,
  25,
  37,
  6,
  14,
  54,
  14,
  15,
  35,
  24,
  36,
  25,
  46,
  39,
  42,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  56,
  57,
  58,
  29,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  0,
  0,
  0,
  25,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  17,
  18,
  19,
  20,
  11,
  0,
  40,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  34,
  34,
  0,
  34,
  34,
  34,
  0,
  34,
  34,
  0,
  22,
  34,
  34,
  22,
  0,
  15,
  22,
  22,
  15,
  0,
  20,
  15,
  15,
  20,
  0,
  3,
  20,
  20,
  3,
  0,
  6,
  14,
  3,
  6,
  14,
  0,
  24,
  6,
  14,
  24,
  0,
  0,
  24
}; // idb
const __int16 yycheck[301] =
{
  58,
  0,
  47,
  44,
  35,
  0,
  45,
  258,
  264,
  26,
  264,
  0,
  263,
  58,
  265,
  264,
  0,
  257,
  35,
  50,
  260,
  0,
  44,
  263,
  264,
  259,
  0,
  264,
  263,
  263,
  266,
  0,
  0,
  50,
  261,
  262,
  264,
  0,
  264,
  263,
  47,
  264,
  264,
  58,
  264,
  260,
  264,
  264,
  264,
  263,
  58,
  264,
  264,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  259,
  -1,
  -1,
  -1,
  263,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  259,
  260,
  261,
  262,
  263,
  260,
  -1,
  260,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  257,
  258,
  -1,
  260,
  257,
  258,
  -1,
  264,
  265,
  -1,
  257,
  264,
  265,
  260,
  -1,
  257,
  263,
  264,
  260,
  -1,
  257,
  263,
  264,
  260,
  -1,
  257,
  263,
  264,
  260,
  -1,
  257,
  257,
  264,
  260,
  260,
  -1,
  257,
  264,
  264,
  260,
  -1,
  -1,
  263
}; // idb
const TABLE MonthDayTable[19] =
{
  { "january", 260, 1 },
  { "february", 260, 2 },
  { "march", 260, 3 },
  { "april", 260, 4 },
  { "may", 260, 5 },
  { "june", 260, 6 },
  { "july", 260, 7 },
  { "august", 260, 8 },
  { "september", 260, 9 },
  { "october", 260, 10 },
  { "november", 260, 11 },
  { "december", 260, 12 },
  { "sunday", 257, 0 },
  { "monday", 257, 0 },
  { "tuesday", 257, 0 },
  { "wednesday", 257, 0 },
  { "thursday", 257, 0 },
  { "friday", 257, 0 },
  { "saturday", 257, 0 }
}; // idb
const TABLE UnitsTable[9] =
{
  { "year", 261, 12 },
  { "month", 261, 1 },
  { "week", 262, 604800 },
  { "day", 262, 86400 },
  { "hour", 262, 3600 },
  { "minute", 262, 60 },
  { "min", 262, 60 },
  { "second", 262, 1 },
  { "sec", 262, 1 }
}; // idb
_UNKNOWN unk_817098C; // weak
const TABLE TimezoneTable[55] =
{
  { &unk_817098C, 265, 0 },
  { &unk_8170990, 265, 0 },
  { &unk_8170993, 265, 0 },
  { &unk_8170997, 265, 0 },
  { &unk_817099B, 265, 0 },
  { &unk_817099D, 265, 0 },
  { &unk_81709A1, 258, 0 },
  { &unk_81709A5, 265, 210 },
  { &unk_81709A9, 258, 210 },
  { &unk_81709AD, 265, 240 },
  { &unk_81709B1, 258, 240 },
  { &unk_81709B5, 265, 300 },
  { &unk_81709B9, 258, 300 },
  { &unk_81709BD, 265, 360 },
  { &unk_81709C1, 258, 360 },
  { &unk_81709C5, 265, 420 },
  { &unk_81709C9, 258, 420 },
  { &unk_81709CD, 265, 480 },
  { &unk_81709D1, 258, 480 },
  { &unk_81709D5, 265, 540 },
  { &unk_81709D9, 258, 540 },
  { "akst", 265, 540 },
  { "akdt", 258, 540 },
  { "hst", 265, 600 },
  { "hast", 265, 600 },
  { "hadt", 258, 600 },
  { "ces", 258, -60 },
  { "cest", 258, -60 },
  { "mez", 265, -60 },
  { "mezt", 258, -60 },
  { "cet", 265, -60 },
  { "met", 265, -60 },
  { "mez", 265, -60 },
  { "mewt", 265, -60 },
  { "mest", 258, -60 },
  { "mes", 258, -60 },
  { "mesz", 258, -60 },
  { "msz", 258, -60 },
  { "metdst", 258, -60 },
  { "eet", 265, -120 },
  { "msk", 265, -180 },
  { "msd", 258, -180 },
  { "wast", 265, -480 },
  { "wadt", 258, -480 },
  { "hkt", 265, -480 },
  { "cct", 265, -480 },
  { "jst", 265, -540 },
  { "kst", 265, -540 },
  { "kdt", 265, -540 },
  { "cast", 265, -570 },
  { "cadt", 258, -570 },
  { "east", 265, -600 },
  { "eadt", 258, -600 },
  { "nzst", 265, -720 },
  { "nzdt", 258, -720 }
}; // idb
TABLE stru_8170D14 = { NULL, 0, 0 }; // weak
const int LeapYears_7979[17] =
{
  1972,
  1976,
  1980,
  1984,
  1988,
  1992,
  1996,
  2000,
  2004,
  2008,
  2012,
  2016,
  2020,
  2024,
  2028,
  2032,
  2036
}; // idb
int dword_8170D64[7] = { 0, 0, 0, 0, 0, 0, 0 }; // weak
const int DaysLeap_7978[13] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; // idb
const int DaysNormal_7977[13] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; // idb
const unsigned __int8 dfont_unicount_windows_1250[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u
}; // idb
const unsigned __int16 dfont_unitable_windows_1250[235] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  8364u,
  8218u,
  8222u,
  8230u,
  8224u,
  8225u,
  8240u,
  352u,
  1064u,
  8249u,
  346u,
  356u,
  381u,
  1046u,
  377u,
  8216u,
  8217u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  8482u,
  353u,
  1096u,
  8250u,
  347u,
  357u,
  382u,
  1078u,
  378u,
  160u,
  711u,
  780u,
  728u,
  774u,
  321u,
  164u,
  260u,
  166u,
  167u,
  168u,
  776u,
  169u,
  350u,
  171u,
  172u,
  173u,
  174u,
  379u,
  176u,
  778u,
  177u,
  731u,
  808u,
  322u,
  180u,
  181u,
  956u,
  182u,
  183u,
  184u,
  807u,
  261u,
  351u,
  187u,
  317u,
  733u,
  779u,
  318u,
  380u,
  340u,
  193u,
  194u,
  258u,
  196u,
  313u,
  262u,
  199u,
  268u,
  1063u,
  201u,
  280u,
  203u,
  282u,
  205u,
  206u,
  270u,
  272u,
  323u,
  327u,
  211u,
  212u,
  336u,
  214u,
  215u,
  344u,
  366u,
  218u,
  368u,
  220u,
  221u,
  354u,
  223u,
  341u,
  225u,
  226u,
  259u,
  228u,
  314u,
  263u,
  231u,
  269u,
  679u,
  1095u,
  233u,
  281u,
  235u,
  283u,
  237u,
  238u,
  271u,
  273u,
  324u,
  328u,
  243u,
  244u,
  337u,
  246u,
  247u,
  345u,
  367u,
  250u,
  369u,
  252u,
  253u,
  355u,
  729u,
  775u,
  903u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1250 = { 8u, &repl_map_windows_1250, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_windows_1251[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_windows_1251[222] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  1026u,
  1027u,
  8218u,
  1107u,
  8222u,
  8230u,
  8224u,
  8225u,
  8364u,
  8240u,
  1033u,
  8249u,
  1034u,
  1036u,
  1035u,
  1039u,
  1106u,
  8216u,
  8217u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  8482u,
  1113u,
  8250u,
  1114u,
  1116u,
  1115u,
  1119u,
  160u,
  1038u,
  1118u,
  1032u,
  164u,
  1168u,
  166u,
  167u,
  1025u,
  169u,
  1028u,
  171u,
  172u,
  173u,
  174u,
  1031u,
  176u,
  177u,
  1030u,
  1110u,
  1169u,
  181u,
  182u,
  183u,
  1105u,
  8470u,
  1108u,
  187u,
  1112u,
  1029u,
  1109u,
  1111u,
  1040u,
  1041u,
  1042u,
  1043u,
  1044u,
  1045u,
  1046u,
  1047u,
  1048u,
  1049u,
  1050u,
  1051u,
  1052u,
  1053u,
  1054u,
  1055u,
  1056u,
  1057u,
  1058u,
  1059u,
  1060u,
  1061u,
  1062u,
  1063u,
  1064u,
  1065u,
  1066u,
  1067u,
  1068u,
  1069u,
  1070u,
  1071u,
  1072u,
  1073u,
  1074u,
  1075u,
  1076u,
  1077u,
  1078u,
  1079u,
  1080u,
  1081u,
  1082u,
  1083u,
  1084u,
  1085u,
  1086u,
  1087u,
  1088u,
  1089u,
  1090u,
  1091u,
  1092u,
  1093u,
  1094u,
  1095u,
  1096u,
  1097u,
  1098u,
  1099u,
  1100u,
  1101u,
  1102u,
  1103u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1251 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_windows_1252[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  4u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_windows_1252[229] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  8364u,
  8218u,
  402u,
  8222u,
  8230u,
  8224u,
  8225u,
  710u,
  770u,
  8240u,
  352u,
  8249u,
  338u,
  381u,
  8216u,
  8217u,
  8220u,
  8221u,
  733u,
  779u,
  8226u,
  8211u,
  8212u,
  732u,
  8482u,
  353u,
  8250u,
  339u,
  382u,
  376u,
  160u,
  161u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  776u,
  169u,
  170u,
  171u,
  172u,
  173u,
  174u,
  175u,
  772u,
  176u,
  778u,
  177u,
  178u,
  179u,
  180u,
  181u,
  956u,
  182u,
  183u,
  775u,
  903u,
  8231u,
  184u,
  807u,
  185u,
  186u,
  187u,
  188u,
  189u,
  190u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  208u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  215u,
  216u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  240u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  247u,
  248u,
  249u,
  250u,
  251u,
  252u,
  253u,
  254u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1252 = { 9u, &repl_map_windows_1252, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_windows_1253[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_windows_1253[208] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  8364u,
  8218u,
  402u,
  8222u,
  8230u,
  8224u,
  8225u,
  8240u,
  8249u,
  8216u,
  701u,
  8217u,
  700u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  8482u,
  8250u,
  160u,
  901u,
  902u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  169u,
  171u,
  172u,
  173u,
  174u,
  8213u,
  176u,
  177u,
  178u,
  179u,
  900u,
  181u,
  182u,
  183u,
  904u,
  905u,
  906u,
  187u,
  908u,
  189u,
  910u,
  911u,
  912u,
  913u,
  914u,
  915u,
  916u,
  917u,
  918u,
  919u,
  920u,
  921u,
  922u,
  923u,
  924u,
  925u,
  926u,
  927u,
  928u,
  929u,
  931u,
  932u,
  933u,
  934u,
  935u,
  936u,
  937u,
  938u,
  939u,
  940u,
  941u,
  942u,
  943u,
  944u,
  945u,
  946u,
  947u,
  948u,
  949u,
  950u,
  951u,
  952u,
  953u,
  954u,
  955u,
  956u,
  957u,
  958u,
  959u,
  960u,
  961u,
  962u,
  963u,
  964u,
  965u,
  966u,
  967u,
  968u,
  969u,
  970u,
  971u,
  972u,
  973u,
  974u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1253 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_windows_1255[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_windows_1255[200] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  8364u,
  8218u,
  402u,
  8222u,
  8230u,
  8224u,
  8225u,
  710u,
  8240u,
  8249u,
  8216u,
  8217u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  732u,
  8482u,
  8250u,
  160u,
  161u,
  162u,
  163u,
  8362u,
  165u,
  166u,
  167u,
  168u,
  169u,
  215u,
  171u,
  172u,
  173u,
  174u,
  175u,
  176u,
  177u,
  178u,
  179u,
  180u,
  181u,
  182u,
  183u,
  184u,
  185u,
  247u,
  187u,
  188u,
  189u,
  190u,
  191u,
  1456u,
  1457u,
  1458u,
  1459u,
  1460u,
  1461u,
  1462u,
  1463u,
  1464u,
  1465u,
  1467u,
  1468u,
  1469u,
  1470u,
  1471u,
  1472u,
  1473u,
  1474u,
  1475u,
  1520u,
  1521u,
  1522u,
  1523u,
  1524u,
  1488u,
  1489u,
  1490u,
  1491u,
  1492u,
  1493u,
  1494u,
  1495u,
  1496u,
  1497u,
  1498u,
  1499u,
  1500u,
  1501u,
  1502u,
  1503u,
  1504u,
  1505u,
  1506u,
  1507u,
  1508u,
  1509u,
  1510u,
  1511u,
  1512u,
  1513u,
  1514u,
  8206u,
  8207u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1255 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_windows_1256[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_windows_1256[223] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  8364u,
  1662u,
  8218u,
  402u,
  8222u,
  8230u,
  8224u,
  8225u,
  710u,
  8240u,
  1657u,
  8249u,
  338u,
  1670u,
  1688u,
  1672u,
  1711u,
  8216u,
  8217u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  1705u,
  8482u,
  1681u,
  8250u,
  339u,
  8204u,
  8205u,
  1722u,
  160u,
  1548u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  169u,
  1726u,
  171u,
  172u,
  173u,
  174u,
  175u,
  176u,
  177u,
  178u,
  179u,
  180u,
  181u,
  182u,
  183u,
  184u,
  185u,
  1563u,
  187u,
  188u,
  189u,
  190u,
  1567u,
  1729u,
  1569u,
  1570u,
  1571u,
  1572u,
  1573u,
  1574u,
  1575u,
  1576u,
  1577u,
  1578u,
  1579u,
  1580u,
  1581u,
  1582u,
  1583u,
  1584u,
  1585u,
  1586u,
  1587u,
  1588u,
  1589u,
  1590u,
  215u,
  1591u,
  1592u,
  1593u,
  1594u,
  1600u,
  1601u,
  1602u,
  1603u,
  224u,
  1604u,
  226u,
  1605u,
  1606u,
  1607u,
  1608u,
  231u,
  232u,
  233u,
  234u,
  235u,
  1609u,
  1610u,
  238u,
  239u,
  1611u,
  1612u,
  1613u,
  1614u,
  244u,
  1615u,
  1616u,
  247u,
  1617u,
  249u,
  1618u,
  251u,
  252u,
  8206u,
  8207u,
  1746u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1256 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_windows_1257[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_windows_1257[211] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  8364u,
  8218u,
  8222u,
  8230u,
  8224u,
  8225u,
  8240u,
  8249u,
  168u,
  711u,
  184u,
  8216u,
  8217u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  8482u,
  8250u,
  175u,
  731u,
  160u,
  162u,
  163u,
  164u,
  166u,
  167u,
  216u,
  169u,
  342u,
  171u,
  172u,
  173u,
  174u,
  198u,
  176u,
  177u,
  178u,
  179u,
  180u,
  181u,
  182u,
  183u,
  248u,
  185u,
  343u,
  187u,
  188u,
  189u,
  190u,
  230u,
  260u,
  302u,
  256u,
  262u,
  196u,
  197u,
  280u,
  274u,
  268u,
  201u,
  377u,
  278u,
  290u,
  310u,
  298u,
  315u,
  352u,
  323u,
  325u,
  211u,
  332u,
  213u,
  214u,
  215u,
  370u,
  321u,
  346u,
  362u,
  220u,
  379u,
  381u,
  223u,
  261u,
  303u,
  257u,
  263u,
  228u,
  229u,
  281u,
  275u,
  269u,
  233u,
  378u,
  279u,
  291u,
  311u,
  299u,
  316u,
  353u,
  324u,
  326u,
  243u,
  333u,
  245u,
  246u,
  247u,
  371u,
  322u,
  347u,
  363u,
  252u,
  380u,
  382u,
  729u
}; // idb
const unimapdesc_str dfont_replacedesc_windows_1257 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp437[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  2u,
  3u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  1u,
  1u,
  1u,
  2u,
  3u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp437[247] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  199u,
  252u,
  971u,
  233u,
  226u,
  228u,
  224u,
  229u,
  231u,
  234u,
  235u,
  232u,
  239u,
  970u,
  238u,
  236u,
  196u,
  197u,
  201u,
  904u,
  230u,
  198u,
  244u,
  246u,
  242u,
  251u,
  249u,
  255u,
  214u,
  220u,
  939u,
  162u,
  163u,
  165u,
  8359u,
  402u,
  225u,
  940u,
  237u,
  943u,
  243u,
  972u,
  250u,
  973u,
  241u,
  209u,
  170u,
  186u,
  191u,
  8976u,
  172u,
  189u,
  188u,
  161u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  9569u,
  9570u,
  9558u,
  9557u,
  9571u,
  9553u,
  9559u,
  9565u,
  9564u,
  9563u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  9566u,
  9567u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  9575u,
  9576u,
  9572u,
  9573u,
  9561u,
  9560u,
  9554u,
  9555u,
  9579u,
  9578u,
  9496u,
  9484u,
  9608u,
  9604u,
  9612u,
  9616u,
  9600u,
  945u,
  223u,
  946u,
  915u,
  960u,
  931u,
  8721u,
  963u,
  181u,
  956u,
  964u,
  934u,
  920u,
  952u,
  937u,
  8486u,
  948u,
  8734u,
  966u,
  248u,
  949u,
  8712u,
  8714u,
  8745u,
  8801u,
  177u,
  8805u,
  8807u,
  8804u,
  8806u,
  8992u,
  643u,
  8993u,
  247u,
  8776u,
  176u,
  778u,
  8729u,
  775u,
  903u,
  183u,
  8231u,
  8730u,
  8319u,
  178u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp437 = { 12u, &repl_map_cp437, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp737[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp737[231] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  913u,
  914u,
  915u,
  916u,
  917u,
  918u,
  919u,
  920u,
  921u,
  922u,
  923u,
  924u,
  925u,
  926u,
  927u,
  928u,
  929u,
  931u,
  932u,
  933u,
  934u,
  935u,
  936u,
  937u,
  945u,
  946u,
  947u,
  611u,
  948u,
  949u,
  950u,
  951u,
  952u,
  953u,
  305u,
  954u,
  955u,
  956u,
  181u,
  957u,
  958u,
  959u,
  960u,
  961u,
  963u,
  962u,
  964u,
  965u,
  650u,
  966u,
  967u,
  968u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  9569u,
  9570u,
  9558u,
  9557u,
  9571u,
  9553u,
  9559u,
  9565u,
  9564u,
  9563u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  9566u,
  9567u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  9575u,
  9576u,
  9572u,
  9573u,
  9561u,
  9560u,
  9554u,
  9555u,
  9579u,
  9578u,
  9496u,
  9484u,
  9608u,
  9604u,
  9612u,
  9616u,
  9600u,
  969u,
  940u,
  941u,
  942u,
  970u,
  943u,
  972u,
  973u,
  971u,
  252u,
  974u,
  902u,
  904u,
  905u,
  906u,
  908u,
  910u,
  911u,
  177u,
  8805u,
  8804u,
  938u,
  939u,
  247u,
  8776u,
  176u,
  8729u,
  775u,
  903u,
  183u,
  8730u,
  8319u,
  178u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp737 = { 9u, &repl_map_cp737, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp775[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp775[223] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  262u,
  252u,
  233u,
  257u,
  228u,
  291u,
  229u,
  263u,
  322u,
  275u,
  342u,
  343u,
  299u,
  377u,
  196u,
  197u,
  201u,
  230u,
  198u,
  333u,
  246u,
  290u,
  162u,
  346u,
  347u,
  214u,
  220u,
  248u,
  163u,
  216u,
  215u,
  164u,
  256u,
  298u,
  243u,
  379u,
  380u,
  378u,
  8221u,
  166u,
  169u,
  174u,
  172u,
  189u,
  188u,
  321u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  260u,
  268u,
  280u,
  278u,
  9571u,
  9553u,
  9559u,
  9565u,
  302u,
  352u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  370u,
  362u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  381u,
  261u,
  269u,
  281u,
  279u,
  303u,
  353u,
  371u,
  363u,
  382u,
  9496u,
  9484u,
  9608u,
  9604u,
  9612u,
  9616u,
  9600u,
  211u,
  223u,
  332u,
  323u,
  245u,
  213u,
  181u,
  324u,
  310u,
  311u,
  315u,
  316u,
  326u,
  274u,
  325u,
  8217u,
  173u,
  177u,
  8220u,
  190u,
  182u,
  167u,
  247u,
  8222u,
  176u,
  8729u,
  183u,
  185u,
  179u,
  178u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp775 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp850[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  4u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp850[247] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  199u,
  252u,
  971u,
  233u,
  941u,
  226u,
  228u,
  224u,
  229u,
  231u,
  234u,
  235u,
  232u,
  239u,
  970u,
  238u,
  236u,
  196u,
  197u,
  201u,
  904u,
  230u,
  198u,
  244u,
  246u,
  242u,
  251u,
  249u,
  255u,
  214u,
  220u,
  939u,
  248u,
  163u,
  216u,
  215u,
  402u,
  225u,
  940u,
  237u,
  943u,
  243u,
  972u,
  250u,
  973u,
  241u,
  209u,
  170u,
  186u,
  191u,
  174u,
  172u,
  189u,
  188u,
  161u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  193u,
  902u,
  194u,
  192u,
  169u,
  9571u,
  9553u,
  9559u,
  9565u,
  162u,
  165u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  227u,
  195u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  164u,
  240u,
  208u,
  202u,
  203u,
  200u,
  305u,
  953u,
  205u,
  906u,
  206u,
  207u,
  938u,
  9496u,
  9484u,
  9608u,
  9604u,
  166u,
  204u,
  9600u,
  211u,
  908u,
  223u,
  212u,
  210u,
  245u,
  213u,
  181u,
  956u,
  254u,
  222u,
  218u,
  219u,
  217u,
  253u,
  221u,
  175u,
  772u,
  180u,
  769u,
  173u,
  177u,
  8215u,
  819u,
  190u,
  182u,
  167u,
  247u,
  184u,
  807u,
  176u,
  778u,
  168u,
  776u,
  183u,
  775u,
  903u,
  8231u,
  185u,
  179u,
  178u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp850 = { 8u, &repl_map_cp850, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp852[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  3u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  2u,
  2u,
  2u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp852[251] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  199u,
  252u,
  971u,
  233u,
  941u,
  226u,
  228u,
  367u,
  263u,
  231u,
  322u,
  235u,
  336u,
  337u,
  238u,
  377u,
  196u,
  262u,
  201u,
  904u,
  313u,
  314u,
  244u,
  246u,
  317u,
  318u,
  346u,
  347u,
  214u,
  220u,
  939u,
  356u,
  357u,
  321u,
  215u,
  269u,
  679u,
  1095u,
  225u,
  940u,
  237u,
  943u,
  243u,
  972u,
  250u,
  973u,
  260u,
  261u,
  381u,
  1046u,
  382u,
  1078u,
  280u,
  281u,
  172u,
  378u,
  268u,
  1063u,
  351u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  193u,
  902u,
  194u,
  282u,
  350u,
  9571u,
  9553u,
  9559u,
  9565u,
  379u,
  380u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  258u,
  259u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  164u,
  273u,
  272u,
  270u,
  203u,
  271u,
  327u,
  205u,
  906u,
  206u,
  283u,
  9496u,
  9484u,
  9608u,
  9604u,
  354u,
  366u,
  9600u,
  211u,
  908u,
  223u,
  212u,
  323u,
  324u,
  328u,
  352u,
  1064u,
  353u,
  1096u,
  340u,
  218u,
  341u,
  368u,
  253u,
  221u,
  355u,
  180u,
  769u,
  173u,
  733u,
  779u,
  731u,
  808u,
  711u,
  780u,
  728u,
  774u,
  167u,
  247u,
  184u,
  807u,
  176u,
  778u,
  168u,
  776u,
  729u,
  775u,
  903u,
  369u,
  344u,
  345u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp852 = { 7u, &repl_map_cp852, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp857[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp857[221] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  199u,
  252u,
  233u,
  226u,
  228u,
  224u,
  229u,
  231u,
  234u,
  235u,
  232u,
  239u,
  238u,
  305u,
  196u,
  197u,
  201u,
  230u,
  198u,
  244u,
  246u,
  242u,
  251u,
  249u,
  304u,
  214u,
  220u,
  248u,
  163u,
  216u,
  350u,
  351u,
  225u,
  237u,
  243u,
  250u,
  241u,
  209u,
  286u,
  287u,
  191u,
  174u,
  172u,
  189u,
  188u,
  161u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  193u,
  194u,
  192u,
  169u,
  9571u,
  9553u,
  9559u,
  9565u,
  162u,
  165u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  227u,
  195u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  164u,
  186u,
  170u,
  202u,
  203u,
  200u,
  205u,
  206u,
  207u,
  9496u,
  9484u,
  9608u,
  9604u,
  166u,
  204u,
  9600u,
  211u,
  223u,
  212u,
  210u,
  245u,
  213u,
  181u,
  215u,
  218u,
  219u,
  217u,
  236u,
  255u,
  175u,
  180u,
  173u,
  177u,
  190u,
  182u,
  167u,
  247u,
  184u,
  176u,
  168u,
  183u,
  185u,
  179u,
  178u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp857 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp862[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp862[224] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  1488u,
  1489u,
  1490u,
  1491u,
  1492u,
  1493u,
  1494u,
  1495u,
  1496u,
  1497u,
  1498u,
  1499u,
  1500u,
  1501u,
  1502u,
  1503u,
  1504u,
  1505u,
  1506u,
  1507u,
  1508u,
  1509u,
  1510u,
  1511u,
  1512u,
  1513u,
  1514u,
  162u,
  163u,
  165u,
  8359u,
  402u,
  225u,
  237u,
  243u,
  250u,
  241u,
  209u,
  170u,
  186u,
  191u,
  8976u,
  172u,
  189u,
  188u,
  161u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  9569u,
  9570u,
  9558u,
  9557u,
  9571u,
  9553u,
  9559u,
  9565u,
  9564u,
  9563u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  9566u,
  9567u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  9575u,
  9576u,
  9572u,
  9573u,
  9561u,
  9560u,
  9554u,
  9555u,
  9579u,
  9578u,
  9496u,
  9484u,
  9608u,
  9604u,
  9612u,
  9616u,
  9600u,
  945u,
  223u,
  915u,
  960u,
  931u,
  963u,
  181u,
  964u,
  934u,
  920u,
  937u,
  948u,
  8734u,
  966u,
  949u,
  8745u,
  8801u,
  177u,
  8805u,
  8804u,
  8992u,
  8993u,
  247u,
  8776u,
  176u,
  8729u,
  183u,
  8730u,
  8319u,
  178u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp862 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp864[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_cp864[218] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  176u,
  183u,
  8729u,
  8730u,
  9618u,
  9472u,
  9474u,
  9532u,
  9508u,
  9516u,
  9500u,
  9524u,
  9488u,
  9484u,
  9492u,
  9496u,
  946u,
  8734u,
  966u,
  177u,
  189u,
  188u,
  8776u,
  171u,
  187u,
  65271u,
  65272u,
  65275u,
  65276u,
  160u,
  173u,
  65154u,
  163u,
  164u,
  65156u,
  65166u,
  65167u,
  65173u,
  65177u,
  1548u,
  65181u,
  65185u,
  65189u,
  1632u,
  1633u,
  1634u,
  1635u,
  1636u,
  1637u,
  1638u,
  1639u,
  1640u,
  1641u,
  65233u,
  1563u,
  65201u,
  65205u,
  65209u,
  1567u,
  162u,
  65152u,
  65153u,
  65155u,
  65157u,
  65226u,
  65163u,
  65165u,
  65169u,
  65171u,
  65175u,
  65179u,
  65183u,
  65187u,
  65191u,
  65193u,
  65195u,
  65197u,
  65199u,
  65203u,
  65207u,
  65211u,
  65215u,
  65217u,
  65221u,
  65227u,
  65231u,
  166u,
  172u,
  247u,
  215u,
  65225u,
  1600u,
  65235u,
  65239u,
  65243u,
  65247u,
  65251u,
  65255u,
  65259u,
  65261u,
  65263u,
  65267u,
  65213u,
  65228u,
  65230u,
  65229u,
  65249u,
  65149u,
  1617u,
  65253u,
  65257u,
  65260u,
  65264u,
  65266u,
  65232u,
  65237u,
  65269u,
  65270u,
  65245u,
  65241u,
  65265u,
  9632u
}; // idb
const unimapdesc_str dfont_replacedesc_cp864 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp866[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp866[224] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  1040u,
  1041u,
  1042u,
  1043u,
  1044u,
  1045u,
  1046u,
  1047u,
  1048u,
  1049u,
  1050u,
  1051u,
  1052u,
  1053u,
  1054u,
  1055u,
  1056u,
  1057u,
  1058u,
  1059u,
  1060u,
  1061u,
  1062u,
  1063u,
  1064u,
  1065u,
  1066u,
  1067u,
  1068u,
  1069u,
  1070u,
  1071u,
  1072u,
  1073u,
  1074u,
  1075u,
  1076u,
  1077u,
  1078u,
  1079u,
  1080u,
  1081u,
  1082u,
  1083u,
  1084u,
  1085u,
  1086u,
  1087u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  9569u,
  9570u,
  9558u,
  9557u,
  9571u,
  9553u,
  9559u,
  9565u,
  9564u,
  9563u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  9566u,
  9567u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  9575u,
  9576u,
  9572u,
  9573u,
  9561u,
  9560u,
  9554u,
  9555u,
  9579u,
  9578u,
  9496u,
  9484u,
  9608u,
  9604u,
  9612u,
  9616u,
  9600u,
  1088u,
  1089u,
  1090u,
  1091u,
  1092u,
  1093u,
  1094u,
  1095u,
  1096u,
  1097u,
  1098u,
  1099u,
  1100u,
  1101u,
  1102u,
  1103u,
  1025u,
  1105u,
  1028u,
  1108u,
  1031u,
  1111u,
  1038u,
  1118u,
  176u,
  8729u,
  183u,
  8730u,
  8470u,
  164u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp866 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp869[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp869[217] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  902u,
  183u,
  172u,
  166u,
  8216u,
  701u,
  8217u,
  700u,
  904u,
  8213u,
  905u,
  906u,
  938u,
  908u,
  910u,
  939u,
  169u,
  911u,
  178u,
  179u,
  940u,
  163u,
  941u,
  942u,
  943u,
  970u,
  912u,
  972u,
  973u,
  913u,
  914u,
  915u,
  916u,
  917u,
  918u,
  919u,
  189u,
  920u,
  921u,
  171u,
  187u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  922u,
  923u,
  924u,
  925u,
  9571u,
  9553u,
  9559u,
  9565u,
  926u,
  927u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  928u,
  929u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  931u,
  932u,
  933u,
  934u,
  935u,
  936u,
  937u,
  945u,
  946u,
  947u,
  9496u,
  9484u,
  9608u,
  9604u,
  948u,
  949u,
  9600u,
  950u,
  951u,
  952u,
  953u,
  954u,
  955u,
  956u,
  957u,
  958u,
  959u,
  960u,
  961u,
  963u,
  962u,
  964u,
  900u,
  173u,
  177u,
  965u,
  966u,
  967u,
  167u,
  968u,
  901u,
  176u,
  168u,
  969u,
  971u,
  944u,
  974u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp869 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  13u,
  2u,
  8u,
  3u,
  2u,
  2u,
  2u,
  6u,
  2u,
  2u,
  34u,
  100u,
  6u,
  8u,
  6u,
  5u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  5u,
  4u,
  2u,
  2u,
  2u,
  3u,
  3u,
  12u,
  2u,
  7u,
  4u,
  13u,
  2u,
  10u,
  5u,
  15u,
  4u,
  6u,
  8u,
  3u,
  8u,
  11u,
  3u,
  4u,
  7u,
  7u,
  5u,
  13u,
  3u,
  3u,
  8u,
  5u,
  7u,
  3u,
  2u,
  2u,
  3u,
  2u,
  5u,
  12u,
  3u,
  7u,
  4u,
  12u,
  2u,
  11u,
  6u,
  13u,
  6u,
  5u,
  6u,
  3u,
  7u,
  14u,
  3u,
  3u,
  7u,
  7u,
  5u,
  13u,
  4u,
  4u,
  2u,
  6u,
  6u,
  2u,
  3u,
  2u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int16 dfont_unitable[616] =
{
  32u,
  4960u,
  8192u,
  8194u,
  8196u,
  8197u,
  8198u,
  8199u,
  8200u,
  8201u,
  8287u,
  12288u,
  12351u,
  33u,
  65281u,
  34u,
  8220u,
  8221u,
  8222u,
  8223u,
  65282u,
  65378u,
  65379u,
  35u,
  1488u,
  65283u,
  36u,
  65284u,
  37u,
  65285u,
  38u,
  65286u,
  39u,
  769u,
  8217u,
  8218u,
  8219u,
  65287u,
  40u,
  65288u,
  41u,
  65289u,
  42u,
  638u,
  10017u,
  10026u,
  10027u,
  10028u,
  10029u,
  10030u,
  10031u,
  10032u,
  10033u,
  10034u,
  10035u,
  10036u,
  10037u,
  10038u,
  10039u,
  10040u,
  10041u,
  10042u,
  10043u,
  10044u,
  10045u,
  10050u,
  10051u,
  10052u,
  10053u,
  10054u,
  10055u,
  10056u,
  10057u,
  10058u,
  10059u,
  65290u,
  43u,
  726u,
  9484u,
  9485u,
  9486u,
  9487u,
  9488u,
  9489u,
  9490u,
  9491u,
  9492u,
  9493u,
  9494u,
  9495u,
  9496u,
  9497u,
  9498u,
  9499u,
  9500u,
  9501u,
  9502u,
  9503u,
  9504u,
  9505u,
  9506u,
  9507u,
  9508u,
  9509u,
  9510u,
  9511u,
  9512u,
  9513u,
  9514u,
  9515u,
  9516u,
  9517u,
  9518u,
  9519u,
  9520u,
  9521u,
  9522u,
  9523u,
  9524u,
  9525u,
  9526u,
  9527u,
  9528u,
  9529u,
  9530u,
  9531u,
  9532u,
  9533u,
  9534u,
  9535u,
  9536u,
  9537u,
  9538u,
  9539u,
  9540u,
  9541u,
  9542u,
  9543u,
  9544u,
  9545u,
  9546u,
  9547u,
  9548u,
  9549u,
  9550u,
  9551u,
  9552u,
  9553u,
  9554u,
  9555u,
  9556u,
  9557u,
  9558u,
  9559u,
  9560u,
  9561u,
  9562u,
  9563u,
  9564u,
  9565u,
  9566u,
  9567u,
  9568u,
  9569u,
  9570u,
  9571u,
  9572u,
  9573u,
  9574u,
  9575u,
  9576u,
  9577u,
  9578u,
  9579u,
  9580u,
  65291u,
  44u,
  806u,
  807u,
  4963u,
  65292u,
  65380u,
  45u,
  727u,
  809u,
  8208u,
  8209u,
  8211u,
  8213u,
  65293u,
  46u,
  802u,
  803u,
  8228u,
  65294u,
  65377u,
  47u,
  823u,
  824u,
  8725u,
  65295u,
  48u,
  65296u,
  49u,
  65297u,
  50u,
  65298u,
  51u,
  65299u,
  52u,
  65300u,
  53u,
  65301u,
  54u,
  65302u,
  55u,
  65303u,
  56u,
  65304u,
  57u,
  65305u,
  58u,
  720u,
  1474u,
  4961u,
  65306u,
  59u,
  690u,
  801u,
  65307u,
  60u,
  65308u,
  61u,
  65309u,
  62u,
  65310u,
  63u,
  660u,
  65311u,
  64u,
  601u,
  65312u,
  65u,
  192u,
  193u,
  194u,
  195u,
  256u,
  258u,
  260u,
  461u,
  593u,
  7944u,
  65313u,
  66u,
  65314u,
  67u,
  262u,
  264u,
  266u,
  268u,
  4909u,
  65315u,
  68u,
  270u,
  4861u,
  65316u,
  69u,
  200u,
  201u,
  202u,
  203u,
  274u,
  276u,
  278u,
  280u,
  282u,
  603u,
  4772u,
  65317u,
  70u,
  65318u,
  71u,
  284u,
  286u,
  288u,
  290u,
  486u,
  500u,
  610u,
  4893u,
  65319u,
  72u,
  292u,
  295u,
  4629u,
  65320u,
  73u,
  204u,
  205u,
  206u,
  207u,
  296u,
  298u,
  300u,
  302u,
  304u,
  463u,
  618u,
  617u,
  4773u,
  65321u,
  74u,
  308u,
  607u,
  65322u,
  75u,
  310u,
  488u,
  4797u,
  8490u,
  65323u,
  76u,
  313u,
  315u,
  317u,
  619u,
  620u,
  671u,
  65324u,
  77u,
  625u,
  65325u,
  78u,
  209u,
  323u,
  325u,
  327u,
  331u,
  4765u,
  65326u,
  79u,
  210u,
  211u,
  212u,
  213u,
  332u,
  334u,
  465u,
  490u,
  596u,
  65327u,
  80u,
  4917u,
  65328u,
  81u,
  611u,
  4693u,
  65329u,
  82u,
  340u,
  342u,
  344u,
  602u,
  640u,
  65330u,
  83u,
  346u,
  348u,
  350u,
  352u,
  643u,
  65331u,
  84u,
  354u,
  356u,
  4901u,
  65332u,
  85u,
  217u,
  218u,
  219u,
  360u,
  362u,
  364u,
  366u,
  370u,
  467u,
  631u,
  650u,
  65333u,
  86u,
  652u,
  65334u,
  87u,
  372u,
  65335u,
  88u,
  9745u,
  9746u,
  10003u,
  10004u,
  10007u,
  10008u,
  65336u,
  89u,
  221u,
  374u,
  376u,
  65337u,
  90u,
  377u,
  379u,
  381u,
  541u,
  4837u,
  65338u,
  91u,
  810u,
  65339u,
  92u,
  65340u,
  93u,
  65341u,
  94u,
  770u,
  65342u,
  95u,
  65343u,
  96u,
  700u,
  768u,
  8216u,
  65344u,
  97u,
  225u,
  226u,
  227u,
  257u,
  259u,
  261u,
  462u,
  1463u,
  4771u,
  7936u,
  65345u,
  98u,
  4709u,
  65346u,
  99u,
  263u,
  265u,
  267u,
  269u,
  4733u,
  65347u,
  100u,
  271u,
  4853u,
  65348u,
  101u,
  232u,
  233u,
  234u,
  235u,
  275u,
  277u,
  279u,
  281u,
  283u,
  4768u,
  65349u,
  102u,
  65350u,
  103u,
  285u,
  287u,
  289u,
  291u,
  487u,
  501u,
  609u,
  4877u,
  8458u,
  65351u,
  104u,
  293u,
  1471u,
  4613u,
  8462u,
  65352u,
  105u,
  237u,
  238u,
  239u,
  297u,
  299u,
  301u,
  303u,
  305u,
  464u,
  1460u,
  4770u,
  65353u,
  106u,
  309u,
  496u,
  669u,
  4869u,
  65354u,
  107u,
  311u,
  489u,
  4781u,
  65355u,
  108u,
  314u,
  316u,
  318u,
  4621u,
  65356u,
  109u,
  4637u,
  65357u,
  110u,
  241u,
  324u,
  326u,
  328u,
  4757u,
  65358u,
  111u,
  242u,
  243u,
  244u,
  245u,
  333u,
  335u,
  466u,
  491u,
  1464u,
  4774u,
  4941u,
  8500u,
  65359u,
  112u,
  4949u,
  65360u,
  113u,
  4677u,
  65361u,
  114u,
  341u,
  343u,
  345u,
  633u,
  4653u,
  65362u,
  115u,
  347u,
  349u,
  351u,
  353u,
  4661u,
  65363u,
  116u,
  355u,
  357u,
  4725u,
  65364u,
  117u,
  249u,
  250u,
  251u,
  361u,
  363u,
  365u,
  367u,
  371u,
  468u,
  1468u,
  4769u,
  65365u,
  118u,
  1520u,
  4717u,
  65366u,
  119u,
  373u,
  4813u,
  65367u,
  120u,
  65368u,
  121u,
  253u,
  255u,
  375u,
  4845u,
  65369u,
  122u,
  378u,
  380u,
  382u,
  4829u,
  65370u,
  123u,
  65371u,
  124u,
  781u,
  65372u,
  125u,
  65373u,
  126u,
  771u,
  820u,
  65374u
}; // idb
const unimapdesc_str dfont_replacedesc = { 2610u, &repl_map, 1, 0 }; // idb
const unsigned __int8 dfont_unicount_dec_mcs[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_dec_mcs[176] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  161u,
  162u,
  163u,
  165u,
  167u,
  164u,
  169u,
  170u,
  171u,
  176u,
  177u,
  178u,
  179u,
  181u,
  182u,
  183u,
  185u,
  186u,
  187u,
  188u,
  189u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  338u,
  216u,
  217u,
  218u,
  219u,
  220u,
  376u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  339u,
  248u,
  249u,
  250u,
  251u,
  252u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_dec_mcs = { 17u, &repl_map_dec_mcs, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_hp_roman8[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_hp_roman8[190] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  192u,
  194u,
  200u,
  202u,
  203u,
  206u,
  207u,
  180u,
  715u,
  710u,
  168u,
  732u,
  217u,
  219u,
  8356u,
  175u,
  221u,
  253u,
  176u,
  199u,
  231u,
  209u,
  241u,
  161u,
  191u,
  164u,
  163u,
  165u,
  167u,
  402u,
  162u,
  226u,
  234u,
  244u,
  251u,
  225u,
  233u,
  243u,
  250u,
  224u,
  232u,
  242u,
  249u,
  228u,
  235u,
  246u,
  252u,
  197u,
  238u,
  216u,
  198u,
  229u,
  237u,
  248u,
  230u,
  196u,
  236u,
  214u,
  220u,
  201u,
  239u,
  223u,
  212u,
  193u,
  195u,
  227u,
  208u,
  240u,
  205u,
  204u,
  211u,
  210u,
  213u,
  245u,
  352u,
  353u,
  218u,
  376u,
  255u,
  222u,
  254u,
  183u,
  181u,
  182u,
  190u,
  8212u,
  188u,
  189u,
  170u,
  186u,
  171u,
  9632u,
  187u,
  177u
}; // idb
const unimapdesc_str dfont_replacedesc_hp_roman8 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_1[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  4u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_1[201] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  8199u,
  161u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  776u,
  169u,
  170u,
  171u,
  172u,
  173u,
  174u,
  175u,
  772u,
  176u,
  778u,
  177u,
  178u,
  179u,
  180u,
  181u,
  956u,
  182u,
  183u,
  775u,
  903u,
  8231u,
  184u,
  807u,
  185u,
  186u,
  187u,
  188u,
  189u,
  190u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  208u,
  272u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  215u,
  216u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  240u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  247u,
  248u,
  249u,
  250u,
  251u,
  252u,
  253u,
  254u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_1 = { 67u, &repl_map_iso_8859_1, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_2[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_2[209] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  260u,
  728u,
  774u,
  321u,
  164u,
  317u,
  346u,
  167u,
  168u,
  776u,
  352u,
  1064u,
  350u,
  356u,
  377u,
  173u,
  381u,
  1046u,
  379u,
  176u,
  778u,
  261u,
  731u,
  808u,
  322u,
  180u,
  318u,
  347u,
  711u,
  780u,
  184u,
  807u,
  353u,
  1096u,
  351u,
  357u,
  378u,
  733u,
  779u,
  382u,
  1078u,
  380u,
  340u,
  193u,
  194u,
  258u,
  196u,
  313u,
  262u,
  199u,
  268u,
  1063u,
  201u,
  280u,
  203u,
  282u,
  205u,
  206u,
  270u,
  272u,
  208u,
  323u,
  327u,
  211u,
  212u,
  336u,
  214u,
  215u,
  183u,
  344u,
  366u,
  218u,
  368u,
  220u,
  221u,
  354u,
  223u,
  341u,
  225u,
  226u,
  259u,
  228u,
  314u,
  263u,
  231u,
  269u,
  679u,
  1095u,
  233u,
  281u,
  235u,
  283u,
  237u,
  238u,
  271u,
  273u,
  324u,
  328u,
  243u,
  244u,
  337u,
  246u,
  247u,
  345u,
  367u,
  250u,
  369u,
  252u,
  253u,
  355u,
  729u,
  775u,
  903u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_2 = { 7u, &repl_map_iso_8859_2, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_3[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_3[184] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  294u,
  728u,
  163u,
  164u,
  292u,
  167u,
  168u,
  304u,
  350u,
  286u,
  308u,
  173u,
  379u,
  176u,
  295u,
  178u,
  179u,
  180u,
  181u,
  293u,
  183u,
  184u,
  305u,
  351u,
  287u,
  309u,
  189u,
  380u,
  192u,
  193u,
  194u,
  196u,
  266u,
  264u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  209u,
  210u,
  211u,
  212u,
  288u,
  214u,
  215u,
  284u,
  217u,
  218u,
  219u,
  220u,
  364u,
  348u,
  223u,
  224u,
  225u,
  226u,
  228u,
  267u,
  265u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  241u,
  242u,
  243u,
  244u,
  289u,
  246u,
  247u,
  285u,
  249u,
  250u,
  251u,
  252u,
  365u,
  349u,
  729u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_3 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_4[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_4[97] =
{
  160u,
  260u,
  312u,
  342u,
  164u,
  296u,
  315u,
  167u,
  168u,
  352u,
  274u,
  290u,
  358u,
  173u,
  381u,
  175u,
  176u,
  261u,
  731u,
  343u,
  180u,
  297u,
  316u,
  711u,
  184u,
  353u,
  275u,
  291u,
  359u,
  330u,
  382u,
  331u,
  256u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  302u,
  268u,
  201u,
  280u,
  203u,
  278u,
  205u,
  206u,
  298u,
  272u,
  208u,
  325u,
  332u,
  310u,
  212u,
  213u,
  214u,
  215u,
  216u,
  370u,
  218u,
  219u,
  220u,
  360u,
  362u,
  223u,
  257u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  303u,
  269u,
  233u,
  281u,
  235u,
  279u,
  237u,
  238u,
  299u,
  273u,
  326u,
  333u,
  311u,
  244u,
  245u,
  246u,
  247u,
  248u,
  371u,
  250u,
  251u,
  252u,
  361u,
  363u,
  729u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_4 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_5[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_5[208] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  1025u,
  1026u,
  1027u,
  1028u,
  1029u,
  1030u,
  304u,
  1031u,
  938u,
  1032u,
  1033u,
  1034u,
  1035u,
  1036u,
  173u,
  1038u,
  1039u,
  1040u,
  1041u,
  1042u,
  1043u,
  915u,
  1044u,
  1045u,
  1046u,
  381u,
  1047u,
  1048u,
  1049u,
  1050u,
  1051u,
  923u,
  1052u,
  1053u,
  1054u,
  1055u,
  928u,
  1056u,
  1057u,
  1058u,
  1059u,
  1060u,
  934u,
  1061u,
  1062u,
  1063u,
  268u,
  1064u,
  352u,
  1065u,
  1066u,
  1067u,
  1068u,
  1069u,
  1070u,
  1071u,
  1072u,
  1073u,
  1074u,
  1075u,
  1076u,
  1077u,
  1078u,
  382u,
  1079u,
  1080u,
  1081u,
  1082u,
  1083u,
  955u,
  1084u,
  1085u,
  1086u,
  1087u,
  960u,
  1088u,
  1089u,
  1090u,
  1091u,
  1092u,
  966u,
  1093u,
  1094u,
  1095u,
  269u,
  1096u,
  353u,
  1097u,
  1098u,
  1099u,
  305u,
  1100u,
  1101u,
  1102u,
  1103u,
  8470u,
  1105u,
  1106u,
  1107u,
  1108u,
  1109u,
  1110u,
  1111u,
  970u,
  1112u,
  1113u,
  1114u,
  1115u,
  1116u,
  167u,
  1118u,
  1119u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_5 = { 4u, &repl_map_iso_8859_5, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_6[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_6[146] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  164u,
  1548u,
  173u,
  1563u,
  1567u,
  1569u,
  1570u,
  1571u,
  1572u,
  1573u,
  1574u,
  1575u,
  1576u,
  1577u,
  1578u,
  1579u,
  1580u,
  1581u,
  1582u,
  1583u,
  1584u,
  1585u,
  1586u,
  1587u,
  1588u,
  1589u,
  1590u,
  1591u,
  1592u,
  1593u,
  1594u,
  1600u,
  1601u,
  1602u,
  1603u,
  1604u,
  1605u,
  1606u,
  1607u,
  1608u,
  1609u,
  1610u,
  1611u,
  1612u,
  1613u,
  1614u,
  1615u,
  1616u,
  1617u,
  1618u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_6 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_7[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  3u,
  3u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  4u,
  2u,
  2u,
  2u,
  1u,
  2u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  0u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  2u,
  2u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_7[220] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  701u,
  8216u,
  881u,
  700u,
  8217u,
  882u,
  163u,
  8364u,
  8367u,
  166u,
  167u,
  168u,
  169u,
  890u,
  171u,
  172u,
  173u,
  8213u,
  176u,
  177u,
  178u,
  179u,
  900u,
  901u,
  902u,
  8123u,
  183u,
  775u,
  903u,
  8231u,
  904u,
  8137u,
  905u,
  8139u,
  906u,
  8155u,
  187u,
  908u,
  8185u,
  189u,
  910u,
  8171u,
  911u,
  8187u,
  912u,
  913u,
  914u,
  915u,
  1043u,
  916u,
  917u,
  918u,
  919u,
  920u,
  921u,
  922u,
  923u,
  1051u,
  924u,
  925u,
  926u,
  927u,
  928u,
  1055u,
  929u,
  931u,
  932u,
  933u,
  934u,
  1060u,
  935u,
  1061u,
  936u,
  937u,
  938u,
  939u,
  940u,
  8049u,
  941u,
  8051u,
  942u,
  8053u,
  943u,
  8055u,
  944u,
  945u,
  946u,
  947u,
  611u,
  948u,
  240u,
  949u,
  950u,
  951u,
  952u,
  953u,
  305u,
  954u,
  955u,
  956u,
  181u,
  957u,
  958u,
  959u,
  960u,
  961u,
  962u,
  963u,
  964u,
  965u,
  650u,
  966u,
  967u,
  968u,
  969u,
  970u,
  971u,
  252u,
  972u,
  8057u,
  973u,
  8059u,
  974u,
  8061u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_7 = { 6u, &repl_map_iso_8859_7, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_8[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_8[155] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  169u,
  215u,
  171u,
  172u,
  173u,
  174u,
  175u,
  176u,
  177u,
  178u,
  179u,
  180u,
  181u,
  182u,
  183u,
  184u,
  185u,
  247u,
  187u,
  188u,
  189u,
  190u,
  8215u,
  1488u,
  1489u,
  1490u,
  1491u,
  1492u,
  1493u,
  1494u,
  1495u,
  1496u,
  1497u,
  1498u,
  1499u,
  1500u,
  1501u,
  1502u,
  1503u,
  1504u,
  1505u,
  1506u,
  1507u,
  1508u,
  1509u,
  1510u,
  1511u,
  1512u,
  1513u,
  1514u,
  8206u,
  8207u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_8 = { 22u, &repl_map_iso_8859_8, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_9[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  3u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  3u,
  2u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_9[205] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  1067u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  161u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  776u,
  169u,
  170u,
  171u,
  172u,
  173u,
  174u,
  175u,
  772u,
  176u,
  778u,
  177u,
  178u,
  179u,
  180u,
  181u,
  956u,
  182u,
  183u,
  775u,
  903u,
  184u,
  807u,
  185u,
  186u,
  187u,
  188u,
  189u,
  190u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  286u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  215u,
  216u,
  217u,
  218u,
  219u,
  220u,
  304u,
  1048u,
  1030u,
  350u,
  1064u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  287u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  247u,
  248u,
  249u,
  250u,
  251u,
  252u,
  305u,
  953u,
  1099u,
  351u,
  1096u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_9 = { 8u, &repl_map_iso_8859_9, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_10[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_10[191] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  260u,
  274u,
  290u,
  298u,
  296u,
  310u,
  167u,
  315u,
  272u,
  352u,
  358u,
  381u,
  173u,
  362u,
  330u,
  176u,
  261u,
  275u,
  291u,
  299u,
  297u,
  311u,
  183u,
  316u,
  273u,
  353u,
  359u,
  382u,
  8213u,
  363u,
  331u,
  256u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  302u,
  268u,
  201u,
  280u,
  203u,
  278u,
  205u,
  206u,
  207u,
  208u,
  325u,
  332u,
  211u,
  212u,
  213u,
  214u,
  360u,
  216u,
  370u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  257u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  303u,
  269u,
  233u,
  281u,
  235u,
  279u,
  237u,
  238u,
  239u,
  240u,
  326u,
  333u,
  243u,
  244u,
  245u,
  246u,
  361u,
  248u,
  371u,
  250u,
  251u,
  252u,
  253u,
  254u,
  312u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_10 = { 1u, &repl_map_iso_8859_10, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_13[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_13[191] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  8221u,
  162u,
  163u,
  164u,
  8222u,
  166u,
  167u,
  216u,
  169u,
  342u,
  171u,
  172u,
  173u,
  174u,
  198u,
  176u,
  177u,
  178u,
  179u,
  8220u,
  181u,
  182u,
  183u,
  248u,
  185u,
  343u,
  187u,
  188u,
  189u,
  190u,
  230u,
  260u,
  302u,
  256u,
  262u,
  196u,
  197u,
  280u,
  274u,
  268u,
  201u,
  377u,
  278u,
  290u,
  310u,
  298u,
  315u,
  352u,
  323u,
  325u,
  211u,
  332u,
  213u,
  214u,
  215u,
  370u,
  321u,
  346u,
  362u,
  220u,
  379u,
  381u,
  223u,
  261u,
  303u,
  257u,
  263u,
  228u,
  229u,
  281u,
  275u,
  269u,
  233u,
  378u,
  279u,
  291u,
  311u,
  299u,
  316u,
  353u,
  324u,
  326u,
  243u,
  333u,
  245u,
  246u,
  247u,
  371u,
  322u,
  347u,
  363u,
  252u,
  380u,
  382u,
  8217u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_13 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_14[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_14[191] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  7682u,
  7683u,
  163u,
  266u,
  267u,
  7690u,
  167u,
  7808u,
  169u,
  7810u,
  7691u,
  7922u,
  173u,
  174u,
  376u,
  7710u,
  7711u,
  288u,
  289u,
  7744u,
  7745u,
  182u,
  7766u,
  7809u,
  7767u,
  7811u,
  7776u,
  7923u,
  7812u,
  7813u,
  7777u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  372u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  7786u,
  216u,
  217u,
  218u,
  219u,
  220u,
  221u,
  374u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  373u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  7787u,
  248u,
  249u,
  250u,
  251u,
  252u,
  253u,
  375u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_14 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_iso_8859_15[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_iso_8859_15[191] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  160u,
  161u,
  162u,
  163u,
  8364u,
  165u,
  352u,
  167u,
  353u,
  169u,
  170u,
  171u,
  172u,
  173u,
  174u,
  175u,
  176u,
  177u,
  178u,
  179u,
  381u,
  181u,
  182u,
  183u,
  381u,
  185u,
  186u,
  187u,
  338u,
  339u,
  376u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  208u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  215u,
  216u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  240u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  247u,
  248u,
  249u,
  250u,
  251u,
  252u,
  253u,
  254u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_iso_8859_15 = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_koi8_r[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  2u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_koi8_r[239] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  9472u,
  9474u,
  9484u,
  9488u,
  9492u,
  9496u,
  9500u,
  9508u,
  9516u,
  9524u,
  9532u,
  9600u,
  9604u,
  9608u,
  9612u,
  9616u,
  9617u,
  9618u,
  9619u,
  8992u,
  9632u,
  8729u,
  8730u,
  8776u,
  8804u,
  8805u,
  160u,
  8993u,
  176u,
  178u,
  183u,
  8231u,
  247u,
  9552u,
  9553u,
  9554u,
  1105u,
  9555u,
  9556u,
  9557u,
  9558u,
  9559u,
  9560u,
  9561u,
  9562u,
  9563u,
  9564u,
  9565u,
  9566u,
  9567u,
  9568u,
  9569u,
  1025u,
  9570u,
  9571u,
  9572u,
  9573u,
  9574u,
  9575u,
  9576u,
  9577u,
  9578u,
  9579u,
  9580u,
  169u,
  1102u,
  1072u,
  1073u,
  1094u,
  1076u,
  1077u,
  1092u,
  966u,
  1075u,
  1093u,
  1080u,
  1081u,
  1082u,
  1083u,
  955u,
  1084u,
  1085u,
  1086u,
  1087u,
  960u,
  1103u,
  1088u,
  1089u,
  1090u,
  1091u,
  1078u,
  382u,
  1074u,
  1100u,
  1099u,
  305u,
  1079u,
  1096u,
  353u,
  1101u,
  1097u,
  1095u,
  269u,
  1098u,
  1070u,
  1040u,
  1041u,
  1062u,
  1044u,
  1045u,
  1060u,
  934u,
  1043u,
  915u,
  1061u,
  1048u,
  1049u,
  1050u,
  1051u,
  923u,
  1052u,
  1053u,
  1054u,
  1055u,
  928u,
  1071u,
  1056u,
  1057u,
  1058u,
  1059u,
  1046u,
  381u,
  1042u,
  1068u,
  1067u,
  1047u,
  1064u,
  352u,
  1069u,
  1065u,
  1063u,
  268u,
  1066u
}; // idb
const unimapdesc_str dfont_replacedesc_koi8_r = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_macintosh[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  4u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_macintosh[226] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  196u,
  197u,
  199u,
  201u,
  209u,
  214u,
  220u,
  225u,
  224u,
  226u,
  228u,
  227u,
  229u,
  231u,
  233u,
  232u,
  234u,
  235u,
  237u,
  236u,
  238u,
  239u,
  241u,
  243u,
  242u,
  244u,
  246u,
  245u,
  250u,
  249u,
  251u,
  252u,
  8224u,
  176u,
  162u,
  163u,
  167u,
  8226u,
  182u,
  223u,
  174u,
  169u,
  8482u,
  180u,
  168u,
  8800u,
  198u,
  216u,
  8734u,
  177u,
  8804u,
  8805u,
  165u,
  181u,
  8706u,
  8721u,
  8719u,
  960u,
  8747u,
  170u,
  186u,
  8486u,
  230u,
  248u,
  191u,
  161u,
  172u,
  8730u,
  402u,
  8776u,
  8710u,
  171u,
  187u,
  8230u,
  160u,
  192u,
  195u,
  213u,
  338u,
  339u,
  8211u,
  8212u,
  8220u,
  8221u,
  8216u,
  8217u,
  247u,
  9674u,
  255u,
  376u,
  8260u,
  164u,
  8249u,
  8250u,
  64257u,
  64258u,
  8225u,
  183u,
  775u,
  903u,
  8231u,
  8218u,
  8222u,
  8240u,
  194u,
  202u,
  193u,
  203u,
  200u,
  205u,
  206u,
  207u,
  204u,
  211u,
  212u,
  210u,
  218u,
  219u,
  217u,
  305u,
  710u,
  732u,
  175u,
  728u,
  729u,
  730u,
  184u,
  733u,
  731u,
  711u
}; // idb
const unimapdesc_str dfont_replacedesc_macintosh = { 14u, &repl_map_macintosh, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_mnemonic[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_mnemonic[1] = { 0u }; // idb
const unimapdesc_str dfont_replacedesc_mnemonic = { 1851u, &repl_map_mnemonic, 0, 0 }; // idb
const unsigned __int8 dfont_unicount_next[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_next[222] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  160u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  208u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  181u,
  215u,
  247u,
  169u,
  161u,
  162u,
  163u,
  8260u,
  165u,
  402u,
  167u,
  164u,
  8217u,
  8220u,
  171u,
  8249u,
  8250u,
  64257u,
  64258u,
  174u,
  8211u,
  8224u,
  8225u,
  183u,
  166u,
  182u,
  8226u,
  8218u,
  8222u,
  8221u,
  187u,
  8230u,
  8240u,
  172u,
  191u,
  185u,
  715u,
  180u,
  710u,
  732u,
  175u,
  728u,
  729u,
  168u,
  178u,
  730u,
  184u,
  179u,
  733u,
  731u,
  711u,
  8212u,
  177u,
  188u,
  189u,
  190u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  198u,
  237u,
  170u,
  238u,
  239u,
  240u,
  241u,
  321u,
  216u,
  338u,
  186u,
  242u,
  243u,
  244u,
  245u,
  246u,
  230u,
  249u,
  250u,
  251u,
  305u,
  252u,
  253u,
  322u,
  248u,
  339u,
  223u,
  254u,
  255u
}; // idb
const unimapdesc_str dfont_replacedesc_next = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_mnemonic_ascii_0[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int16 dfont_unitable_mnemonic_ascii_0[1] = { 0u }; // idb
const unimapdesc_str dfont_replacedesc_mnemonic_ascii_0 = { 1941u, &repl_map_mnemonic_ascii_0, 0, 0 }; // idb
const unsigned __int8 dfont_unicount_viscii[256] =
{
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  1u,
  1u,
  0u,
  1u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  0u,
  0u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_viscii[142] =
{
  7858u,
  7860u,
  7850u,
  9u,
  10u,
  12u,
  13u,
  7926u,
  7926u,
  7924u,
  7928u,
  26u,
  7924u,
  7840u,
  7854u,
  7856u,
  7862u,
  7844u,
  7846u,
  7848u,
  7852u,
  7868u,
  7864u,
  7870u,
  7872u,
  7874u,
  7876u,
  7878u,
  7888u,
  7890u,
  7892u,
  7894u,
  7896u,
  7906u,
  7898u,
  7900u,
  7902u,
  7882u,
  7886u,
  7884u,
  7880u,
  7910u,
  360u,
  7908u,
  7922u,
  213u,
  7855u,
  7857u,
  7863u,
  7845u,
  7847u,
  7849u,
  7853u,
  7869u,
  7865u,
  7871u,
  7873u,
  7875u,
  7877u,
  7879u,
  7889u,
  7891u,
  7893u,
  7895u,
  7904u,
  416u,
  7897u,
  7901u,
  7903u,
  7883u,
  7920u,
  7912u,
  7914u,
  7916u,
  417u,
  7899u,
  431u,
  192u,
  193u,
  194u,
  195u,
  7842u,
  258u,
  7859u,
  7861u,
  200u,
  201u,
  202u,
  7866u,
  204u,
  205u,
  296u,
  7923u,
  272u,
  7913u,
  210u,
  211u,
  212u,
  7841u,
  7927u,
  7915u,
  7917u,
  217u,
  218u,
  7929u,
  7925u,
  221u,
  7905u,
  432u,
  224u,
  225u,
  226u,
  227u,
  7843u,
  259u,
  7919u,
  7851u,
  232u,
  233u,
  234u,
  7867u,
  236u,
  237u,
  297u,
  7881u,
  273u,
  240u,
  7921u,
  242u,
  243u,
  244u,
  245u,
  7887u,
  7885u,
  7909u,
  249u,
  250u,
  361u,
  7911u,
  253u,
  7907u,
  7918u
}; // idb
const unimapdesc_str dfont_replacedesc_viscii = { 8u, &repl_map_viscii, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_cp866u[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_cp866u[224] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  1040u,
  1041u,
  1042u,
  1043u,
  1044u,
  1045u,
  1046u,
  1047u,
  1048u,
  1049u,
  1050u,
  1051u,
  1052u,
  1053u,
  1054u,
  1055u,
  1056u,
  1057u,
  1058u,
  1059u,
  1060u,
  1061u,
  1062u,
  1063u,
  1064u,
  1065u,
  1066u,
  1067u,
  1068u,
  1069u,
  1070u,
  1071u,
  1072u,
  1073u,
  1074u,
  1075u,
  1076u,
  1077u,
  1078u,
  1079u,
  1080u,
  1081u,
  1082u,
  1083u,
  1084u,
  1085u,
  1086u,
  1087u,
  9617u,
  9618u,
  9619u,
  9474u,
  9508u,
  9569u,
  9570u,
  9558u,
  9557u,
  9571u,
  9553u,
  9559u,
  9565u,
  9564u,
  9563u,
  9488u,
  9492u,
  9524u,
  9516u,
  9500u,
  9472u,
  9532u,
  9566u,
  9567u,
  9562u,
  9556u,
  9577u,
  9574u,
  9568u,
  9552u,
  9580u,
  9575u,
  9576u,
  9572u,
  9573u,
  9561u,
  9560u,
  9554u,
  9555u,
  9579u,
  9578u,
  9496u,
  9484u,
  9608u,
  9604u,
  9612u,
  9616u,
  9600u,
  1088u,
  1089u,
  1090u,
  1091u,
  1092u,
  1093u,
  1094u,
  1095u,
  1096u,
  1097u,
  1098u,
  1099u,
  1100u,
  1101u,
  1102u,
  1103u,
  1025u,
  1105u,
  1168u,
  1169u,
  1028u,
  1108u,
  1030u,
  1110u,
  1031u,
  1111u,
  183u,
  8730u,
  8470u,
  164u,
  9632u,
  160u
}; // idb
const unimapdesc_str dfont_replacedesc_cp866u = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_koi8_u[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_koi8_u[224] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  9472u,
  9474u,
  9484u,
  9488u,
  9492u,
  9496u,
  9500u,
  9508u,
  9516u,
  9524u,
  9532u,
  9600u,
  9604u,
  9608u,
  9612u,
  9616u,
  9617u,
  9618u,
  9619u,
  8992u,
  9632u,
  8729u,
  8730u,
  8776u,
  8804u,
  8805u,
  160u,
  8993u,
  176u,
  178u,
  183u,
  247u,
  9552u,
  9553u,
  9554u,
  1105u,
  1108u,
  9556u,
  1110u,
  1111u,
  9559u,
  9560u,
  9561u,
  9562u,
  9563u,
  1169u,
  9565u,
  9566u,
  9567u,
  9568u,
  9569u,
  1025u,
  1028u,
  9571u,
  1030u,
  1031u,
  9574u,
  9575u,
  9576u,
  9577u,
  9578u,
  1168u,
  9580u,
  169u,
  1102u,
  1072u,
  1073u,
  1094u,
  1076u,
  1077u,
  1092u,
  1075u,
  1093u,
  1080u,
  1081u,
  1082u,
  1083u,
  1084u,
  1085u,
  1086u,
  1087u,
  1103u,
  1088u,
  1089u,
  1090u,
  1091u,
  1078u,
  1074u,
  1100u,
  1099u,
  1079u,
  1096u,
  1101u,
  1097u,
  1095u,
  1098u,
  1070u,
  1040u,
  1041u,
  1062u,
  1044u,
  1045u,
  1060u,
  1043u,
  1061u,
  1048u,
  1049u,
  1050u,
  1051u,
  1052u,
  1053u,
  1054u,
  1055u,
  1071u,
  1056u,
  1057u,
  1058u,
  1059u,
  1046u,
  1042u,
  1068u,
  1067u,
  1047u,
  1064u,
  1069u,
  1065u,
  1063u,
  1066u
}; // idb
const unimapdesc_str dfont_replacedesc_koi8_u = { 0u, NULL, 0, 1 }; // idb
const unsigned __int8 dfont_unicount_ptcp154[256] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u
}; // idb
const unsigned __int16 dfont_unitable_ptcp154[223] =
{
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  1174u,
  1170u,
  1262u,
  1171u,
  8222u,
  8230u,
  1206u,
  1198u,
  1202u,
  1199u,
  1184u,
  1250u,
  1186u,
  1178u,
  1210u,
  1208u,
  1175u,
  8216u,
  8217u,
  8220u,
  8221u,
  8226u,
  8211u,
  8212u,
  1203u,
  1207u,
  1185u,
  1251u,
  1187u,
  1179u,
  1211u,
  1209u,
  160u,
  1038u,
  1118u,
  1032u,
  1256u,
  1176u,
  1200u,
  167u,
  1025u,
  169u,
  1240u,
  171u,
  172u,
  1263u,
  174u,
  1180u,
  176u,
  1201u,
  1030u,
  1110u,
  1177u,
  1257u,
  182u,
  183u,
  1105u,
  8470u,
  1241u,
  187u,
  1112u,
  1194u,
  1195u,
  1181u,
  1040u,
  1041u,
  1042u,
  1043u,
  1044u,
  1045u,
  1046u,
  1047u,
  1048u,
  1049u,
  1050u,
  1051u,
  1052u,
  1053u,
  1054u,
  1055u,
  1056u,
  1057u,
  1058u,
  1059u,
  1060u,
  1061u,
  1062u,
  1063u,
  1064u,
  1065u,
  1066u,
  1067u,
  1068u,
  1069u,
  1070u,
  1071u,
  1072u,
  1073u,
  1074u,
  1075u,
  1076u,
  1077u,
  1078u,
  1079u,
  1080u,
  1081u,
  1082u,
  1083u,
  1084u,
  1085u,
  1086u,
  1087u,
  1088u,
  1089u,
  1090u,
  1091u,
  1092u,
  1093u,
  1094u,
  1095u,
  1096u,
  1097u,
  1098u,
  1099u,
  1100u,
  1101u,
  1102u,
  1103u
}; // idb
const unimapdesc_str dfont_replacedesc_ptcp154 = { 0u, NULL, 0, 1 }; // idb
const char byte_817D5C4 = '\0'; // idb
_UNKNOWN unk_817EA87; // weak
const unsigned __int8 isAcceptable[96] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  7u,
  6u,
  0u,
  7u,
  7u,
  4u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  0u,
  0u,
  0u,
  0u,
  7u,
  0u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  7u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
const unsigned __int8 crfc[96] =
{
  1u,
  0u,
  3u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  0u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  1u,
  1u,
  0u,
  1u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  1u,
  2u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  3u
}; // idb
_UNKNOWN unk_817EEA0; // weak
const char byte_817EECB = '\0'; // idb
char a0123456789abcd_0[17] = "0123456789ABCDEF"; // weak
const BOOLEAN isAcceptable_11707[96] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
const char byte_817F5C0 = '\0'; // idb
const char entry = '\0'; // idb
const char nn = '\0'; // idb
const char byte_81822F1 = '\0'; // idb
_UNKNOWN unk_8182AE5; // weak
const HTStreamClass SGMLParser =
{
  "SGMLParser",
  &SGML_free,
  &SGML_abort,
  &SGML_character,
  &SGML_string,
  &SGML_write
}; // idb
const HTTag tags_table0[119] =
{
  {
    &unk_8184060,
    1,
    '\x01',
    &A_attr,
    25,
    &A_attr_type,
    SGML_EMPTY,
    8,
    45063,
    65303,
    227207,
    490407,
    548943,
    20
  },
  {
    "ABBR",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "ACRONYM",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "ADDRESS",
    7,
    '\x01',
    &ADDRESS_attr,
    8,
    &ADDRESS_attr_type,
    SGML_MIXED,
    512,
    61775,
    589823,
    222848,
    749487,
    525079,
    0
  },
  {
    "APPLET",
    6,
    '\x01',
    &APPLET_attr,
    17,
    &APPLET_attr_type,
    SGML_MIXED,
    8192,
    45263,
    589823,
    229279,
    753599,
    536591,
    0
  },
  {
    "AREA",
    4,
    '\x01',
    &AREA_attr,
    18,
    &AREA_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    32768,
    262143,
    3871,
    1
  },
  {
    "AU",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "AUTHOR",
    6,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "B",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    569423,
    720895,
    685967,
    1015743,
    1,
    20
  },
  {
    "BANNER",
    6,
    '\0',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    512,
    64399,
    65535,
    196608,
    196608,
    525087,
    0
  },
  {
    "BASE",
    4,
    '\x01',
    &BASE_attr,
    6,
    &BASE_attr_type,
    SGML_EMPTY,
    262144,
    0,
    0,
    327680,
    327680,
    524303,
    1
  },
  {
    "BASEFONT",
    8,
    '\x01',
    &FONT_attr,
    11,
    &FONT_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227247,
    229295,
    585728,
    1
  },
  {
    "BDO",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    222848,
    749487,
    831,
    0
  },
  {
    "BGSOUND",
    7,
    '\x01',
    &BGSOUND_attr,
    9,
    &BGSOUND_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    489391,
    491439,
    553743,
    1
  },
  {
    "BIG",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    "BLINK",
    5,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    569423,
    589823,
    685967,
    1015727,
    1,
    20
  },
  {
    "BLOCKQUOTE",
    10,
    '\x01',
    &BQ_attr,
    9,
    &BQ_attr_type,
    SGML_MIXED,
    512,
    719823,
    720895,
    747136,
    749487,
    525087,
    0
  },
  {
    "BODY",
    4,
    '\x01',
    &BODY_attr,
    15,
    &BODY_attr_type,
    SGML_MIXED,
    131072,
    195471,
    196607,
    196608,
    196608,
    917375,
    3
  },
  {
    "BODYTEXT",
    8,
    '\x01',
    &BODYTEXT_attr,
    14,
    &BODYTEXT_attr_type,
    SGML_MIXED,
    131072,
    64399,
    720895,
    197120,
    753583,
    586111,
    3
  },
  {
    &unk_8184500,
    2,
    '\x01',
    &BQ_attr,
    9,
    &BQ_attr_type,
    SGML_MIXED,
    512,
    719823,
    720895,
    747136,
    749487,
    525087,
    0
  },
  {
    "BR",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227263,
    491455,
    528415,
    1
  },
  {
    "BUTTON",
    6,
    '\x01',
    &BUTTON_attr,
    15,
    &BUTTON_attr_type,
    SGML_MIXED,
    8192,
    47879,
    65335,
    14223,
    229311,
    529247,
    0
  },
  {
    "CAPTION",
    7,
    '\x01',
    &CAPTION_attr,
    9,
    &CAPTION_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    27136,
    749479,
    525151,
    0
  },
  {
    "CENTER",
    6,
    '\x01',
    &DIV_attr,
    8,
    &DIV_attr_type,
    SGML_MIXED,
    512,
    588751,
    589823,
    747136,
    749479,
    526111,
    0
  },
  {
    "CITE",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    2,
    569423,
    589823,
    685967,
    1015743,
    2,
    16
  },
  {
    "CODE",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    2,
    0
  },
  {
    &unk_8184680,
    3,
    '\x01',
    &COL_attr,
    13,
    &COL_attr_type,
    SGML_EMPTY,
    16384,
    0,
    0,
    2080,
    225191,
    560991,
    1
  },
  {
    "COLGROUP",
    8,
    '\x01',
    &COL_attr,
    13,
    &COL_attr_type,
    SGML_EMPTY,
    32,
    16384,
    16384,
    2048,
    225191,
    558943,
    1
  },
  {
    "COMMENT",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    4,
    0,
    0,
    685999,
    524287,
    3,
    0
  },
  {
    "CREDIT",
    6,
    '\x01',
    &CREDIT_attr,
    7,
    &CREDIT_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    27136,
    753599,
    525071,
    0
  },
  {
    "DD",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1024,
    64463,
    589823,
    2048,
    749567,
    526111,
    1
  },
  {
    &unk_8184744,
    3,
    '\x01',
    &DEL_attr,
    8,
    &DEL_attr_type,
    SGML_MIXED,
    2,
    572367,
    589823,
    688015,
    1015743,
    3,
    0
  },
  {
    "DFN",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569551,
    589823,
    554895,
    1015743,
    3,
    0
  },
  {
    &unk_8183D40,
    3,
    '\x01',
    &UL_attr,
    14,
    &UL_attr_type,
    SGML_MIXED,
    2048,
    46080,
    63327,
    226944,
    225207,
    544639,
    0
  },
  {
    &unk_8184798,
    3,
    '\x01',
    &DIV_attr,
    8,
    &DIV_attr_type,
    SGML_MIXED,
    512,
    588687,
    589823,
    747168,
    753663,
    525087,
    4
  },
  {
    &unk_81847E8,
    2,
    '\x01',
    &DL_attr,
    8,
    &DL_attr_type,
    SGML_MIXED,
    2048,
    50304,
    589823,
    222848,
    753591,
    1887,
    0
  },
  {
    "DLC",
    3,
    '\x01',
    &DL_attr,
    8,
    &DL_attr_type,
    SGML_MIXED,
    2048,
    50304,
    589823,
    222848,
    753591,
    1887,
    0
  },
  {
    "DT",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1024,
    45135,
    45567,
    2048,
    98303,
    526111,
    1
  },
  {
    "EM",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    2,
    569423,
    589823,
    685967,
    1015727,
    3,
    16
  },
  {
    "EMBED",
    5,
    '\x01',
    &EMBED_attr,
    21,
    &EMBED_attr_type,
    SGML_EMPTY,
    8192,
    585991,
    589815,
    749503,
    753599,
    130943,
    1
  },
  {
    "FIELDSET",
    8,
    '\x01',
    &FIELDSET_attr,
    7,
    &FIELDSET_attr_type,
    SGML_MIXED,
    512,
    588623,
    589695,
    550791,
    753655,
    557151,
    0
  },
  {
    &unk_81849D8,
    3,
    '\x01',
    &FIG_attr,
    17,
    &FIG_attr_type,
    SGML_MIXED,
    512,
    64256,
    589823,
    222848,
    749503,
    557903,
    0
  },
  {
    &unk_8184A18,
    2,
    '\x01',
    &FN_attr,
    7,
    &FN_attr_type,
    SGML_MIXED,
    512,
    588751,
    589823,
    747136,
    753343,
    528719,
    0
  },
  {
    "FONT",
    4,
    '\x01',
    &FONT_attr,
    11,
    &FONT_attr_type,
    SGML_EMPTY,
    1,
    569423,
    589823,
    751503,
    1015743,
    1,
    20
  },
  {
    "FORM",
    4,
    '\x01',
    &FORM_attr,
    17,
    &FORM_attr_type,
    SGML_EMPTY,
    128,
    65391,
    65407,
    224775,
    208647,
    560639,
    0
  },
  {
    "FRAME",
    5,
    '\x01',
    &FRAME_attr,
    12,
    &FRAME_attr_type,
    SGML_EMPTY,
    65536,
    0,
    0,
    65536,
    65536,
    655359,
    1
  },
  {
    "FRAMESET",
    8,
    '\x01',
    &FRAMESET_attr,
    4,
    &FRAMESET_attr_type,
    SGML_MIXED,
    65536,
    589824,
    589824,
    589824,
    602112,
    655359,
    0
  },
  {
    "H1",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H2",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H3",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H4",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H5",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H6",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "HEAD",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    262144,
    323584,
    290816,
    65536,
    65536,
    655231,
    7
  },
  {
    &unk_8184E18,
    2,
    '\x01',
    &HR_attr,
    13,
    &HR_attr_type,
    SGML_EMPTY,
    16384,
    0,
    0,
    261760,
    262079,
    556855,
    1
  },
  {
    "HTML",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    65536,
    523151,
    524287,
    0,
    0,
    131071,
    3
  },
  {
    "HY",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227231,
    491455,
    528415,
    1
  },
  {
    "I",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    "IFRAME",
    6,
    '\x01',
    &IFRAME_attr,
    14,
    &IFRAME_attr_type,
    SGML_MIXED,
    8192,
    588751,
    589823,
    747423,
    749503,
    865119,
    0
  },
  {
    &unk_8184F60,
    3,
    '\x01',
    &IMG_attr,
    22,
    &IMG_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227231,
    229311,
    524288,
    1
  },
  {
    "INPUT",
    5,
    '\x01',
    &INPUT_attr,
    35,
    &INPUT_attr_type,
    SGML_EMPTY,
    64,
    0,
    0,
    16263,
    229255,
    561231,
    1
  },
  {
    "INS",
    3,
    '\x01',
    &DEL_attr,
    8,
    &DEL_attr_type,
    SGML_MIXED,
    2,
    572367,
    589823,
    688015,
    1015743,
    3,
    0
  },
  {
    "ISINDEX",
    7,
    '\x01',
    &ISINDEX_attr,
    9,
    &ISINDEX_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    489359,
    524207,
    524295,
    1
  },
  {
    "KBD",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    0,
    0,
    161679,
    491455,
    3,
    0
  },
  {
    "KEYGEN",
    6,
    '\x01',
    &KEYGEN_attr,
    8,
    &KEYGEN_attr_type,
    SGML_EMPTY,
    64,
    0,
    0,
    32695,
    229303,
    524400,
    1
  },
  {
    "LABEL",
    5,
    '\x01',
    &LABEL_attr,
    11,
    &LABEL_attr_type,
    SGML_MIXED,
    2,
    12367,
    65535,
    26527,
    225215,
    7,
    0
  },
  {
    "LEGEND",
    6,
    '\x01',
    &LEGEND_attr,
    9,
    &LEGEND_attr_type,
    SGML_MIXED,
    2,
    45135,
    589695,
    512,
    753575,
    3,
    0
  },
  {
    "LH",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1024,
    47999,
    589823,
    2048,
    622591,
    526111,
    1
  },
  {
    &unk_8185340,
    2,
    '\x01',
    &LI_attr,
    13,
    &LI_attr_type,
    SGML_EMPTY,
    1024,
    48127,
    589823,
    2048,
    622591,
    526111,
    1
  },
  {
    "LINK",
    4,
    '\x01',
    &LINK_attr,
    14,
    &LINK_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    327680,
    327680,
    65407,
    1
  },
  {
    "LISTING",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_LITTERAL,
    2048,
    0,
    0,
    222720,
    225024,
    528159,
    0
  },
  {
    &unk_8185440,
    3,
    '\x01',
    &MAP_attr,
    8,
    &MAP_attr_type,
    SGML_MIXED,
    32768,
    32768,
    32768,
    229327,
    229311,
    1823,
    0
  },
  {
    "MARQUEE",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    16384,
    15,
    585759,
    227207,
    753575,
    536604,
    0
  },
  {
    "MATH",
    4,
    '\x01',
    &MATH_attr,
    8,
    &MATH_attr_type,
    SGML_LITTERAL,
    4,
    45151,
    589823,
    161679,
    1015743,
    31,
    0
  },
  {
    "MENU",
    4,
    '\x01',
    &UL_attr,
    14,
    &UL_attr_type,
    SGML_MIXED,
    2048,
    46080,
    63327,
    95872,
    225207,
    561023,
    0
  },
  {
    "META",
    4,
    '\x01',
    &META_attr,
    4,
    &META_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    327680,
    327680,
    65407,
    1
  },
  {
    "NEXTID",
    6,
    '\x01',
    &NEXTID_attr,
    1,
    &NEXTID_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    327680,
    131063,
    1,
    1
  },
  {
    "NOFRAMES",
    8,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    131072,
    195471,
    65535,
    94208,
    94208,
    53087,
    0
  },
  {
    "NOTE",
    4,
    '\x01',
    &NOTE_attr,
    10,
    &NOTE_attr_type,
    SGML_MIXED,
    512,
    48047,
    589823,
    226992,
    753663,
    525087,
    0
  },
  {
    "OBJECT",
    6,
    '\x01',
    &OBJECT_attr,
    26,
    &OBJECT_attr_type,
    SGML_LITTERAL,
    8192,
    588751,
    589823,
    747423,
    749503,
    540511,
    32
  },
  {
    &unk_8185738,
    2,
    '\x01',
    &OL_attr,
    12,
    &OL_attr_type,
    SGML_MIXED,
    2048,
    50176,
    589823,
    226944,
    753591,
    561023,
    0
  },
  {
    "OPTION",
    6,
    '\x01',
    &OPTION_attr,
    13,
    &OPTION_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    64,
    229375,
    525087,
    1
  },
  {
    "OVERLAY",
    7,
    '\x01',
    &OVERLAY_attr,
    12,
    &OVERLAY_attr_type,
    SGML_EMPTY,
    16384,
    0,
    0,
    512,
    229311,
    540543,
    1
  },
  {
    &unk_81858A0,
    1,
    '\x01',
    &P_attr,
    9,
    &P_attr_type,
    SGML_EMPTY,
    256,
    45135,
    589823,
    222848,
    749479,
    524567,
    1
  },
  {
    "PARAM",
    5,
    '\x01',
    &PARAM_attr,
    18,
    &PARAM_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    210176,
    229375,
    529760,
    1
  },
  {
    "PLAINTEXT",
    9,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_LITTERAL,
    65536,
    1048575,
    1048575,
    589824,
    589824,
    262143,
    1
  },
  {
    "PRE",
    3,
    '\0',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    512,
    61519,
    61534,
    222848,
    225264,
    526110,
    0
  },
  {
    &unk_81859D8,
    1,
    '\x01',
    &Q_attr,
    8,
    &Q_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015727,
    3,
    0
  },
  {
    "S",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    0
  },
  {
    "SAMP",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    2,
    16
  },
  {
    "SCRIPT",
    6,
    '\x01',
    &SCRIPT_attr,
    16,
    &SCRIPT_attr_type,
    SGML_LITTERAL,
    8192,
    0,
    0,
    491423,
    491519,
    556895,
    0
  },
  {
    "SELECT",
    6,
    '\x01',
    &SELECT_attr,
    22,
    &SELECT_attr_type,
    SGML_MIXED,
    64,
    32768,
    32768,
    16303,
    212927,
    528223,
    8
  },
  {
    "SHY",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227231,
    491455,
    528415,
    1
  },
  {
    "SMALL",
    5,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    "SPAN",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    524291,
    0
  },
  {
    "SPOT",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    8,
    0,
    0,
    262135,
    262135,
    8,
    1
  },
  {
    "STRIKE",
    6,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    0
  },
  {
    "STRONG",
    6,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    2,
    569423,
    589823,
    685967,
    1015727,
    3,
    16
  },
  {
    "STYLE",
    5,
    '\x01',
    &STYLE_attr,
    9,
    &STYLE_attr_type,
    SGML_LITTERAL,
    262144,
    0,
    0,
    484239,
    487343,
    524319,
    0
  },
  {
    "SUB",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    4,
    569439,
    589823,
    554911,
    1015743,
    7,
    0
  },
  {
    "SUP",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    4,
    569439,
    589823,
    554911,
    1015743,
    7,
    0
  },
  {
    &unk_8185C48,
    3,
    '\x01',
    &TAB_attr,
    11,
    &TAB_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227215,
    360367,
    1,
    1
  },
  {
    "TABLE",
    5,
    '\x01',
    &TABLE_attr,
    22,
    &TABLE_attr_type,
    SGML_MIXED,
    2048,
    61920,
    589823,
    222848,
    749479,
    574847,
    0
  },
  {
    "TBODY",
    5,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_EMPTY,
    32,
    32,
    589823,
    2176,
    753591,
    575327,
    3
  },
  {
    &unk_8185E30,
    2,
    '\x01',
    &TD_attr,
    23,
    &TD_attr_type,
    SGML_EMPTY,
    1024,
    64463,
    589823,
    32,
    753591,
    575327,
    1
  },
  {
    "TEXTAREA",
    8,
    '\x01',
    &TEXTAREA_attr,
    22,
    &TEXTAREA_attr_type,
    SGML_LITTERAL,
    64,
    0,
    0,
    32655,
    212927,
    528223,
    64
  },
  {
    "TEXTFLOW",
    8,
    '\x01',
    &BODYTEXT_attr,
    14,
    &BODYTEXT_attr_type,
    SGML_MIXED,
    131072,
    588799,
    655359,
    620464,
    753591,
    634895,
    3
  },
  {
    "TFOOT",
    5,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_EMPTY,
    32,
    32,
    589823,
    2048,
    753591,
    577375,
    1
  },
  {
    "TH",
    2,
    '\x01',
    &TD_attr,
    23,
    &TD_attr_type,
    SGML_EMPTY,
    1024,
    64463,
    65535,
    32,
    753591,
    577375,
    1
  },
  {
    "THEAD",
    5,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_EMPTY,
    32,
    32,
    589823,
    2048,
    753591,
    577375,
    1
  },
  {
    "TITLE",
    5,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_RCDATA,
    262144,
    0,
    0,
    327680,
    327680,
    799,
    12
  },
  {
    &unk_8185F80,
    2,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_EMPTY,
    32,
    1024,
    589823,
    2080,
    753591,
    575327,
    1
  },
  {
    "TT",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    16
  },
  {
    "U",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    &unk_8186028,
    2,
    '\x01',
    &UL_attr,
    14,
    &UL_attr_type,
    SGML_MIXED,
    2048,
    50304,
    589823,
    222848,
    753663,
    526175,
    0
  },
  {
    "VAR",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    1,
    0
  },
  {
    "WBR",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    0,
    0,
    227215,
    491455,
    528415,
    1
  },
  {
    "XMP",
    3,
    '\0',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_LITTERAL,
    2048,
    0,
    0,
    223200,
    225279,
    34655,
    1
  },
  {
    "OBJECT",
    6,
    '\x01',
    &OBJECT_attr,
    26,
    &OBJECT_attr_type,
    SGML_MIXED,
    8192,
    588751,
    589823,
    747423,
    749503,
    540511,
    8
  }
}; // idb
const HTTag tags_table1[119] =
{
  {
    &unk_8184060,
    1,
    '\x01',
    &A_attr,
    25,
    &A_attr_type,
    SGML_MIXED,
    8,
    45063,
    65303,
    227207,
    490407,
    548943,
    20
  },
  {
    "ABBR",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "ACRONYM",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "ADDRESS",
    7,
    '\x01',
    &ADDRESS_attr,
    8,
    &ADDRESS_attr_type,
    SGML_MIXED,
    512,
    61775,
    589823,
    222848,
    749487,
    525079,
    0
  },
  {
    "APPLET",
    6,
    '\x01',
    &APPLET_attr,
    17,
    &APPLET_attr_type,
    SGML_MIXED,
    8192,
    45263,
    589823,
    229279,
    753599,
    536591,
    0
  },
  {
    "AREA",
    4,
    '\x01',
    &AREA_attr,
    18,
    &AREA_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    32768,
    262143,
    3871,
    1
  },
  {
    "AU",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "AUTHOR",
    6,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    3,
    0
  },
  {
    "B",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    720895,
    685967,
    1015743,
    1,
    20
  },
  {
    "BANNER",
    6,
    '\0',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    512,
    64399,
    65535,
    196608,
    196608,
    525087,
    0
  },
  {
    "BASE",
    4,
    '\x01',
    &BASE_attr,
    6,
    &BASE_attr_type,
    SGML_EMPTY,
    262144,
    0,
    0,
    327680,
    327680,
    524303,
    1
  },
  {
    "BASEFONT",
    8,
    '\x01',
    &FONT_attr,
    11,
    &FONT_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227247,
    229295,
    585728,
    1
  },
  {
    "BDO",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    222848,
    749487,
    831,
    0
  },
  {
    "BGSOUND",
    7,
    '\x01',
    &BGSOUND_attr,
    9,
    &BGSOUND_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    489391,
    491439,
    553743,
    1
  },
  {
    "BIG",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    "BLINK",
    5,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015727,
    1,
    20
  },
  {
    "BLOCKQUOTE",
    10,
    '\x01',
    &BQ_attr,
    9,
    &BQ_attr_type,
    SGML_MIXED,
    512,
    719823,
    720895,
    747136,
    749487,
    525087,
    0
  },
  {
    "BODY",
    4,
    '\x01',
    &BODY_attr,
    15,
    &BODY_attr_type,
    SGML_MIXED,
    131072,
    195471,
    196607,
    196608,
    196608,
    917375,
    3
  },
  {
    "BODYTEXT",
    8,
    '\x01',
    &BODYTEXT_attr,
    14,
    &BODYTEXT_attr_type,
    SGML_MIXED,
    131072,
    64399,
    720895,
    197120,
    753583,
    586111,
    3
  },
  {
    &unk_8184500,
    2,
    '\x01',
    &BQ_attr,
    9,
    &BQ_attr_type,
    SGML_MIXED,
    512,
    719823,
    720895,
    747136,
    749487,
    525087,
    0
  },
  {
    "BR",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227263,
    491455,
    528415,
    1
  },
  {
    "BUTTON",
    6,
    '\x01',
    &BUTTON_attr,
    15,
    &BUTTON_attr_type,
    SGML_MIXED,
    8192,
    47879,
    65335,
    14223,
    229311,
    529247,
    0
  },
  {
    "CAPTION",
    7,
    '\x01',
    &CAPTION_attr,
    9,
    &CAPTION_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    27136,
    749479,
    525151,
    0
  },
  {
    "CENTER",
    6,
    '\x01',
    &DIV_attr,
    8,
    &DIV_attr_type,
    SGML_MIXED,
    512,
    588751,
    589823,
    747136,
    749479,
    526111,
    0
  },
  {
    "CITE",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    2,
    16
  },
  {
    "CODE",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    2,
    0
  },
  {
    &unk_8184680,
    3,
    '\x01',
    &COL_attr,
    13,
    &COL_attr_type,
    SGML_EMPTY,
    16384,
    0,
    0,
    2080,
    225191,
    560991,
    1
  },
  {
    "COLGROUP",
    8,
    '\x01',
    &COL_attr,
    13,
    &COL_attr_type,
    SGML_ELEMENT,
    32,
    16384,
    16384,
    2048,
    225191,
    558943,
    1
  },
  {
    "COMMENT",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_PCDATA,
    4,
    0,
    0,
    685999,
    524287,
    3,
    0
  },
  {
    "CREDIT",
    6,
    '\x01',
    &CREDIT_attr,
    7,
    &CREDIT_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    27136,
    753599,
    525071,
    0
  },
  {
    "DD",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1024,
    64463,
    589823,
    2048,
    749567,
    526111,
    1
  },
  {
    &unk_8184744,
    3,
    '\x01',
    &DEL_attr,
    8,
    &DEL_attr_type,
    SGML_MIXED,
    2,
    572367,
    589823,
    688015,
    1015743,
    3,
    0
  },
  {
    "DFN",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569551,
    589823,
    554895,
    1015743,
    3,
    0
  },
  {
    &unk_8183D40,
    3,
    '\x01',
    &UL_attr,
    14,
    &UL_attr_type,
    SGML_MIXED,
    2048,
    46080,
    63327,
    226944,
    225207,
    544639,
    0
  },
  {
    &unk_8184798,
    3,
    '\x01',
    &DIV_attr,
    8,
    &DIV_attr_type,
    SGML_MIXED,
    512,
    588687,
    589823,
    747168,
    753663,
    525087,
    4
  },
  {
    &unk_81847E8,
    2,
    '\x01',
    &DL_attr,
    8,
    &DL_attr_type,
    SGML_MIXED,
    2048,
    50304,
    589823,
    222848,
    753591,
    1887,
    0
  },
  {
    "DLC",
    3,
    '\x01',
    &DL_attr,
    8,
    &DL_attr_type,
    SGML_MIXED,
    2048,
    50304,
    589823,
    222848,
    753591,
    1887,
    0
  },
  {
    "DT",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1024,
    45135,
    45567,
    2048,
    98303,
    526111,
    1
  },
  {
    "EM",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015727,
    3,
    16
  },
  {
    "EMBED",
    5,
    '\x01',
    &EMBED_attr,
    21,
    &EMBED_attr_type,
    SGML_EMPTY,
    8192,
    585991,
    589815,
    749503,
    753599,
    130943,
    1
  },
  {
    "FIELDSET",
    8,
    '\x01',
    &FIELDSET_attr,
    7,
    &FIELDSET_attr_type,
    SGML_MIXED,
    512,
    588623,
    589695,
    550791,
    753655,
    557151,
    0
  },
  {
    &unk_81849D8,
    3,
    '\x01',
    &FIG_attr,
    17,
    &FIG_attr_type,
    SGML_MIXED,
    512,
    64256,
    589823,
    222848,
    749503,
    557903,
    0
  },
  {
    &unk_8184A18,
    2,
    '\x01',
    &FN_attr,
    7,
    &FN_attr_type,
    SGML_MIXED,
    512,
    588751,
    589823,
    747136,
    753343,
    528719,
    0
  },
  {
    "FONT",
    4,
    '\x01',
    &FONT_attr,
    11,
    &FONT_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    751503,
    1015743,
    1,
    20
  },
  {
    "FORM",
    4,
    '\x01',
    &FORM_attr,
    17,
    &FORM_attr_type,
    SGML_MIXED,
    128,
    65391,
    65407,
    224775,
    208647,
    560639,
    0
  },
  {
    "FRAME",
    5,
    '\x01',
    &FRAME_attr,
    12,
    &FRAME_attr_type,
    SGML_EMPTY,
    65536,
    0,
    0,
    65536,
    65536,
    655359,
    1
  },
  {
    "FRAMESET",
    8,
    '\x01',
    &FRAMESET_attr,
    4,
    &FRAMESET_attr_type,
    SGML_ELEMENT,
    65536,
    589824,
    589824,
    589824,
    602112,
    655359,
    0
  },
  {
    "H1",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H2",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H3",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H4",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H5",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "H6",
    2,
    '\0',
    &H_attr,
    14,
    &H_attr_type,
    SGML_MIXED,
    256,
    45135,
    45151,
    222848,
    229295,
    524567,
    0
  },
  {
    "HEAD",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_ELEMENT,
    262144,
    323584,
    290816,
    65536,
    65536,
    655231,
    7
  },
  {
    &unk_8184E18,
    2,
    '\x01',
    &HR_attr,
    13,
    &HR_attr_type,
    SGML_EMPTY,
    16384,
    0,
    0,
    261760,
    262079,
    556855,
    1
  },
  {
    "HTML",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    65536,
    523151,
    524287,
    0,
    0,
    131071,
    3
  },
  {
    "HY",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227231,
    491455,
    528415,
    1
  },
  {
    "I",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    "IFRAME",
    6,
    '\x01',
    &IFRAME_attr,
    14,
    &IFRAME_attr_type,
    SGML_MIXED,
    8192,
    588751,
    589823,
    747423,
    749503,
    865119,
    0
  },
  {
    &unk_8184F60,
    3,
    '\x01',
    &IMG_attr,
    22,
    &IMG_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227231,
    229311,
    524288,
    1
  },
  {
    "INPUT",
    5,
    '\x01',
    &INPUT_attr,
    35,
    &INPUT_attr_type,
    SGML_EMPTY,
    64,
    0,
    0,
    16263,
    229255,
    561231,
    1
  },
  {
    "INS",
    3,
    '\x01',
    &DEL_attr,
    8,
    &DEL_attr_type,
    SGML_MIXED,
    2,
    572367,
    589823,
    688015,
    1015743,
    3,
    0
  },
  {
    "ISINDEX",
    7,
    '\x01',
    &ISINDEX_attr,
    9,
    &ISINDEX_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    489359,
    524207,
    524295,
    1
  },
  {
    "KBD",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    0,
    0,
    161679,
    491455,
    3,
    0
  },
  {
    "KEYGEN",
    6,
    '\x01',
    &KEYGEN_attr,
    8,
    &KEYGEN_attr_type,
    SGML_EMPTY,
    64,
    0,
    0,
    32695,
    229303,
    524400,
    1
  },
  {
    "LABEL",
    5,
    '\x01',
    &LABEL_attr,
    11,
    &LABEL_attr_type,
    SGML_MIXED,
    2,
    12367,
    65535,
    26527,
    225215,
    7,
    0
  },
  {
    "LEGEND",
    6,
    '\x01',
    &LEGEND_attr,
    9,
    &LEGEND_attr_type,
    SGML_MIXED,
    2,
    45135,
    589695,
    512,
    753575,
    3,
    0
  },
  {
    "LH",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1024,
    47999,
    589823,
    2048,
    622591,
    526111,
    1
  },
  {
    &unk_8185340,
    2,
    '\x01',
    &LI_attr,
    13,
    &LI_attr_type,
    SGML_MIXED,
    1024,
    48127,
    589823,
    2048,
    622591,
    526111,
    1
  },
  {
    "LINK",
    4,
    '\x01',
    &LINK_attr,
    14,
    &LINK_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    327680,
    327680,
    65407,
    1
  },
  {
    "LISTING",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_LITTERAL,
    2048,
    0,
    0,
    222720,
    225024,
    528159,
    0
  },
  {
    &unk_8185440,
    3,
    '\x01',
    &MAP_attr,
    8,
    &MAP_attr_type,
    SGML_ELEMENT,
    32768,
    32768,
    32768,
    229327,
    229311,
    1823,
    0
  },
  {
    "MARQUEE",
    7,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    16384,
    15,
    585759,
    227207,
    753575,
    536604,
    0
  },
  {
    "MATH",
    4,
    '\x01',
    &MATH_attr,
    8,
    &MATH_attr_type,
    SGML_PCDATA,
    4,
    45151,
    589823,
    161679,
    1015743,
    31,
    0
  },
  {
    "MENU",
    4,
    '\x01',
    &UL_attr,
    14,
    &UL_attr_type,
    SGML_MIXED,
    2048,
    46080,
    63327,
    95872,
    225207,
    561023,
    0
  },
  {
    "META",
    4,
    '\x01',
    &META_attr,
    4,
    &META_attr_type,
    SGML_EMPTY,
    32768,
    0,
    0,
    327680,
    327680,
    65407,
    1
  },
  {
    "NEXTID",
    6,
    '\x01',
    &NEXTID_attr,
    1,
    &NEXTID_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    327680,
    131063,
    1,
    1
  },
  {
    "NOFRAMES",
    8,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    131072,
    195471,
    65535,
    94208,
    94208,
    53087,
    0
  },
  {
    "NOTE",
    4,
    '\x01',
    &NOTE_attr,
    10,
    &NOTE_attr_type,
    SGML_MIXED,
    512,
    48047,
    589823,
    226992,
    753663,
    525087,
    0
  },
  {
    "OBJECT",
    6,
    '\x01',
    &OBJECT_attr,
    26,
    &OBJECT_attr_type,
    SGML_LITTERAL,
    8192,
    588751,
    589823,
    747423,
    749503,
    540511,
    32
  },
  {
    &unk_8185738,
    2,
    '\x01',
    &OL_attr,
    12,
    &OL_attr_type,
    SGML_MIXED,
    2048,
    50176,
    589823,
    226944,
    753591,
    561023,
    0
  },
  {
    "OPTION",
    6,
    '\x01',
    &OPTION_attr,
    13,
    &OPTION_attr_type,
    SGML_PCDATA,
    32768,
    0,
    0,
    64,
    229375,
    525087,
    1
  },
  {
    "OVERLAY",
    7,
    '\x01',
    &OVERLAY_attr,
    12,
    &OVERLAY_attr_type,
    SGML_PCDATA,
    16384,
    0,
    0,
    512,
    229311,
    540543,
    1
  },
  {
    &unk_81858A0,
    1,
    '\x01',
    &P_attr,
    9,
    &P_attr_type,
    SGML_MIXED,
    256,
    45135,
    589823,
    222848,
    749479,
    524567,
    1
  },
  {
    "PARAM",
    5,
    '\x01',
    &PARAM_attr,
    18,
    &PARAM_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    210176,
    229375,
    529760,
    1
  },
  {
    "PLAINTEXT",
    9,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_LITTERAL,
    65536,
    1048575,
    1048575,
    589824,
    589824,
    262143,
    1
  },
  {
    "PRE",
    3,
    '\0',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    512,
    61519,
    61534,
    222848,
    225264,
    526110,
    0
  },
  {
    &unk_81859D8,
    1,
    '\x01',
    &Q_attr,
    8,
    &Q_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015727,
    3,
    0
  },
  {
    "S",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    0
  },
  {
    "SAMP",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    2,
    16
  },
  {
    "SCRIPT",
    6,
    '\x01',
    &SCRIPT_attr,
    16,
    &SCRIPT_attr_type,
    SGML_SCRIPT,
    8192,
    0,
    0,
    491423,
    491519,
    556895,
    0
  },
  {
    "SELECT",
    6,
    '\x01',
    &SELECT_attr,
    22,
    &SELECT_attr_type,
    SGML_ELEMENT,
    64,
    32768,
    32768,
    16303,
    212927,
    528223,
    8
  },
  {
    "SHY",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227231,
    491455,
    528415,
    1
  },
  {
    "SMALL",
    5,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    "SPAN",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    524291,
    0
  },
  {
    "SPOT",
    4,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    8,
    0,
    0,
    262135,
    262135,
    8,
    1
  },
  {
    "STRIKE",
    6,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    0
  },
  {
    "STRONG",
    6,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015727,
    3,
    16
  },
  {
    "STYLE",
    5,
    '\x01',
    &STYLE_attr,
    9,
    &STYLE_attr_type,
    SGML_CDATA,
    262144,
    0,
    0,
    484239,
    487343,
    524319,
    0
  },
  {
    "SUB",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    4,
    569439,
    589823,
    554911,
    1015743,
    7,
    0
  },
  {
    "SUP",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    4,
    569439,
    589823,
    554911,
    1015743,
    7,
    0
  },
  {
    &unk_8185C48,
    3,
    '\x01',
    &TAB_attr,
    11,
    &TAB_attr_type,
    SGML_EMPTY,
    4096,
    0,
    0,
    227215,
    360367,
    1,
    1
  },
  {
    "TABLE",
    5,
    '\x01',
    &TABLE_attr,
    22,
    &TABLE_attr_type,
    SGML_ELEMENT,
    2048,
    61920,
    589823,
    222848,
    749479,
    574847,
    0
  },
  {
    "TBODY",
    5,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_ELEMENT,
    32,
    32,
    589823,
    2176,
    753591,
    575327,
    3
  },
  {
    &unk_8185E30,
    2,
    '\x01',
    &TD_attr,
    23,
    &TD_attr_type,
    SGML_MIXED,
    1024,
    64463,
    589823,
    32,
    753591,
    575327,
    1
  },
  {
    "TEXTAREA",
    8,
    '\x01',
    &TEXTAREA_attr,
    22,
    &TEXTAREA_attr_type,
    SGML_PCDATA,
    64,
    0,
    0,
    32655,
    212927,
    528223,
    64
  },
  {
    "TEXTFLOW",
    8,
    '\x01',
    &BODYTEXT_attr,
    14,
    &BODYTEXT_attr_type,
    SGML_MIXED,
    131072,
    588799,
    655359,
    620464,
    753591,
    634895,
    3
  },
  {
    "TFOOT",
    5,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_ELEMENT,
    32,
    32,
    589823,
    2048,
    753591,
    577375,
    1
  },
  {
    "TH",
    2,
    '\x01',
    &TD_attr,
    23,
    &TD_attr_type,
    SGML_MIXED,
    1024,
    64463,
    65535,
    32,
    753591,
    577375,
    1
  },
  {
    "THEAD",
    5,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_ELEMENT,
    32,
    32,
    589823,
    2048,
    753591,
    577375,
    1
  },
  {
    "TITLE",
    5,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_PCDATA,
    262144,
    0,
    0,
    327680,
    327680,
    799,
    12
  },
  {
    &unk_8185F80,
    2,
    '\x01',
    &TR_attr,
    13,
    &TR_attr_type,
    SGML_MIXED,
    32,
    1024,
    589823,
    2080,
    753591,
    575327,
    1
  },
  {
    "TT",
    2,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    16
  },
  {
    "U",
    1,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    1,
    569423,
    589823,
    685967,
    1015743,
    1,
    20
  },
  {
    &unk_8186028,
    2,
    '\x01',
    &UL_attr,
    14,
    &UL_attr_type,
    SGML_MIXED,
    2048,
    50304,
    589823,
    222848,
    753663,
    526175,
    0
  },
  {
    "VAR",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_MIXED,
    2,
    569423,
    589823,
    685967,
    1015743,
    1,
    0
  },
  {
    "WBR",
    3,
    '\x01',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_EMPTY,
    1,
    0,
    0,
    227215,
    491455,
    528415,
    1
  },
  {
    "XMP",
    3,
    '\0',
    &GEN_attr,
    7,
    &GEN_attr_type,
    SGML_LITTERAL,
    2048,
    0,
    0,
    223200,
    225279,
    34655,
    1
  },
  {
    "OBJECT",
    6,
    '\x01',
    &OBJECT_attr,
    26,
    &OBJECT_attr_type,
    SGML_MIXED,
    8192,
    588751,
    589823,
    747423,
    749503,
    540511,
    8
  }
}; // idb
const SGML_dtd HTML_dtd = { &tags, 118, &entities, 112u }; // idb
const HTStreamClass HTPlain =
{
  "PlainPresenter",
  &HTPlain_free,
  &HTPlain_abort,
  &HTPlain_put_character,
  &HTPlain_put_string,
  &HTPlain_write
}; // idb
const HTStructuredClass HTMLGeneration =
{
  "HTMLGen",
  &HTMLGen_free,
  &HTMLGen_abort,
  &HTMLGen_put_character,
  &HTMLGen_put_string,
  &HTMLGen_write,
  &HTMLGen_start_element,
  &HTMLGen_end_element,
  &HTMLGen_put_entity
}; // idb
const HTStructuredClass PlainToHTMLConversion =
{
  "plaintexttoHTML",
  &HTMLGen_free,
  &PlainToHTML_abort,
  &HTMLGen_put_character,
  &HTMLGen_put_string,
  &HTMLGen_write,
  NULL,
  NULL,
  NULL
}; // idb
const char byte_818B605[3] = { '\0', '\0', '\0' }; // idb
_UNKNOWN unk_818BB68; // weak
_UNKNOWN unk_818C0AC; // weak
_UNKNOWN unk_818C117; // weak
const HTStreamClass HTErrorStreamClass =
{
  "ErrorStream",
  &HTErrorStream_free,
  &HTErrorStream_abort,
  &HTErrorStream_put_character,
  &HTErrorStream_put_string,
  &HTErrorStream_write
}; // idb
_UNKNOWN unk_818C740; // weak
const HTStreamClass HTMIME =
{
  "MIMEParser",
  &HTMIME_free,
  &HTMIME_abort,
  &HTMIME_put_character,
  &HTMIME_put_string,
  &HTMIME_write
}; // idb
const char byte_818EC67 = '\0'; // idb
const char hex_2[17] = "0123456789abcdef"; // idb
const char byte_818FA9B = '\0'; // idb
const char byte_81909DB = '\0'; // idb
const char byte_8190AC3 = '\0'; // idb
_UNKNOWN unk_8190EEC; // weak
_UNKNOWN unk_8190EEF; // weak
_UNKNOWN unk_8190F46; // weak
const char byte_8191195 = '\0'; // idb
_UNKNOWN unk_81918B7; // weak
_UNKNOWN unk_8192001; // weak
int (*dword_8193FFC)(void) = NULL; // weak
char tempfile_11105[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
const char *table_9431[11] =
{
  "emacs",
  "jed",
  "jmacs",
  "joe",
  "jove",
  "jpico",
  "jstar",
  "nano",
  "pico",
  "rjoe",
  "vi"
}; // idb
int mouse_link = -1; // idb
BOOLEAN csi_is_csi = '\x01'; // idb
Keysym_String_List Keysym_Strings[16] =
{
  { "UPARROW", 259 },
  { "DNARROW", 258 },
  { "RTARROW", 261 },
  { "LTARROW", 260 },
  { "PGDOWN", 338 },
  { "PGUP", 339 },
  { "HOME", 262 },
  { "END", 360 },
  { "F1", 265 },
  { "DO_KEY", 280 },
  { "FIND_KEY", 362 },
  { "SELECT_KEY", 385 },
  { "INSERT_KEY", 331 },
  { "REMOVE_KEY", 330 },
  { "DO_NOTHING", 1294 },
  { NULL, -1 }
}; // idb
read_keymap_file::$A01C798FCB7911154585058D4140FC70 table_12243[2] = { { "setkey", &setkey_cmd }, { "unsetkey", &unsetkey_cmd } }; // idb
int (__cdecl *off_8194544)(int) = &setkey_cmd; // weak
Keysym_String_List table_12296[21] =
{
  { "\x1B[A", 259 },
  { "\x1BOA", 259 },
  { "\x1B[B", 258 },
  { "\x1BOB", 258 },
  { "\x1B[C", 261 },
  { "\x1BOC", 261 },
  { "\x1B[D", 260 },
  { "\x1BOD", 260 },
  { "\x1B[1~", 362 },
  { "\x1B[2~", 331 },
  { "\x1B[3~", 330 },
  { "\x1B[4~", 385 },
  { "\x1B[5~", 339 },
  { "\x1B[6~", 338 },
  { "\x1B[7~", 262 },
  { "\x1B[8~", 360 },
  { "\x1B[11~", 265 },
  { "\x1B[28~", 265 },
  { "\x1BOP", 265 },
  { "\x1B[OP", 265 },
  { "\x1B[29~", 280 }
}; // idb
char killbuffer[1024] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
BOOLEAN first_14673 = '\x01'; // idb
char *phelp_15712 = &helpbuf_15711; // idb
char helpbuf_15711[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int lasthelp_lineedit_15710 = -1; // idb
off_t kb_units_10657 = 1024LL; // idb
const char *HTAppName = "Lynx"; // idb
const char *HTAppVersion = "2.8.7dev.11"; // idb
int HTCurSelectGroupCharset = -1; // idb
int HTCurSelectGroupType = 4; // idb
const char *checked_box = "[X]"; // idb
const char *unchecked_box = "[ ]"; // idb
const char *checked_radio = "(*)"; // idb
const char *unchecked_radio = "( )"; // idb
BOOLEAN LYsb_arrow = '\x01'; // idb
int LYsb_begin = -1; // idb
int LYsb_end = -1; // idb
HTStyle default_style =
{
  NULL,
  "(Unstyled)",
  0,
  &byte_814CBAC,
  0,
  1,
  0,
  0,
  NULL,
  0,
  0,
  0,
  1,
  1,
  0,
  NULL,
  '\0',
  '\0',
  0,
  0,
  0
}; // idb
int charset_last_displayed_12722 = -1; // idb
HTProtocol scm = { "source-cache-mem", NULL, NULL }; // idb
trust trusted_exec_default = { "file://localhost/", &byte_814EF17, 0, NULL }; // idb
trust always_trusted_exec_default = { "none", &byte_814EF17, 1, NULL }; // idb
trust trusted_cgi_default = { &byte_814EF17, &byte_814EF17, 2, NULL }; // idb
trust *trusted_exec = &trusted_exec_default; // idb
trust *always_trusted_exec = &always_trusted_exec_default; // idb
trust *trusted_cgi = &trusted_cgi_default; // idb
BOOLEAN first_12231 = '\x01'; // idb
BOOLEAN syslog_requested_urls = '\x01'; // idb
int LYAutoUncacheDirLists = 2; // idb
int dir_list_style = 2; // idb
int HTCacheSize = 10; // idb
int www_search_result = -1; // idb
int LYShowColor = -1; // idb
int LYrcShowColor = -1; // idb
BOOLEAN LYUseFormsOptions = '\x01'; // idb
BOOLEAN LYUseDefShoCur = '\x01'; // idb
BOOLEAN LYUserSpecifiedURL = '\x01'; // idb
BOOLEAN lynx_mode = '\x01'; // idb
BOOLEAN number_fields_on_left = '\x01'; // idb
BOOLEAN number_links_on_left = '\x01'; // idb
BOOLEAN verbose_img = '\x01'; // idb
BOOLEAN telnet_ok = '\x01'; // idb
BOOLEAN news_ok = '\x01'; // idb
BOOLEAN rlogin_ok = '\x01'; // idb
BOOLEAN ftp_ok = '\x01'; // idb
BOOLEAN no_dotfiles = '\x01'; // idb
BOOLEAN ftp_passive = '\x01'; // idb
BOOLEAN no_filereferer = '\x01'; // idb
char LYRefererWithQuery[1] = "D"; // idb
BOOLEAN LYNewsPosting = '\x01'; // idb
BOOLEAN LYNoFromHeader = '\x01'; // idb
BOOLEAN LYSelectPopups = '\x01'; // idb
BOOLEAN LYSetCookies = '\x01'; // idb
BOOLEAN LYUseDefSelPop = '\x01'; // idb
BOOLEAN LYUseDefaultRawMode = '\x01'; // idb
BOOLEAN pseudo_inline_alts = '\x01'; // idb
BOOLEAN scan_for_buried_news_references = '\x01'; // idb
int LYStatusLine = -1; // idb
int LYcols = 80; // idb
int LYlines = 24; // idb
int max_cookies_domain = 50; // idb
int max_cookies_global = 500; // idb
int max_cookies_buffer = 4096; // idb
int outgoing_mail_charset = -1; // idb
BOOLEAN nested_tables = '\x01'; // idb
BOOLEAN LYShowTransferRate = '\x01'; // idb
int LYTransferRate = 2; // idb
int LYAcceptEncoding = 15; // idb
int LYAcceptMedia = 1; // idb
int LYHiddenLinks = 1; // idb
BOOLEAN LYUseTraceLog = '\x01'; // idb
BOOLEAN LYStripDotDotURLs = '\x01'; // idb
BOOLEAN LYPrependBaseToSource = '\x01'; // idb
BOOLEAN LYPrependCharsetToSource = '\x01'; // idb
BOOLEAN LYQuitDefaultYes = '\x01'; // idb
int connect_timeout = 18000; // idb
int reading_timeout = 18000; // idb
int justify_max_void_percent = 35; // idb
BOOLEAN display_partial_flag = '\x01'; // idb
int partial_threshold = -1; // idb
BOOLEAN LYUseBuiltinSuffixes = '\x01'; // idb
BOOLEAN LYuse_default_colors = '\x01'; // idb
Config_Enum table_12416[4] = { { "merge", 0 }, { "listonly", 1 }, { "ignore", 2 }, { NULL, -1 } }; // idb
const char *Usage_12540[4] =
{
  &locale,
  "USAGE: lynx -restrictions=[option][,option][,option]",
  "List of Options:",
  "  ?                 when used alone, list restrictions in effect."
}; // idb
Config_Type Arg_Table[136] =
{
  {
    "accept_all_cookies",
    36,
    135981204,
    "\naccept cookies without prompting if Set-Cookie handling\nis on"
  },
  {
    "anonymous",
    66,
    134719678,
    "apply restrictions for anonymous account,\nsee also -restrictions"
  },
  {
    "assume_charset",
    4164,
    134719732,
    "=MIMEname\ncharset for documents that don't specify it"
  },
  {
    "assume_local_charset",
    4164,
    134719791,
    "=MIMEname\ncharset assumed for local files"
  },
  {
    "assume_unrec_charset",
    4164,
    134719820,
    "=MIMEname\nuse this instead of unrecognized charsets"
  },
  {
    "auth",
    4164,
    134719849,
    "=id:pw\nauthentication information for protected documents"
  },
  {
    "base",
    68,
    134719881,
    "prepend a request URL comment and BASE tag to text/html\noutputs for -source dumps"
  },
  {
    "bibhost",
    4180,
    135981484,
    "=URL\nlocal bibp server (default http://bibhost/)"
  },
  { "book", 36, 135981215, "use the bookmark page as the startfile" },
  {
    "buried_news",
    20,
    135875700,
    "toggles scanning of news articles for buried references"
  },
  { "cache", 4164, 134719941, "=NUMBER\nNUMBER of documents cached in memory" },
  { "case", 36, 135981103, "enable case sensitive user searching" },
  { "center", 20, 135981202, "toggle center alignment in HTML TABLE" },
  {
    "cfg",
    4178,
    135981376,
    "=FILENAME\nspecifies a lynx.cfg file other than the default"
  },
  {
    "child",
    68,
    134719996,
    "exit on left-arrow in startfile, and disable save to disk"
  },
  {
    "child_relaxed",
    68,
    134720027,
    "exit on left-arrow in startfile (allows save to disk)"
  },
  {
    "cmd_log",
    4178,
    136096440,
    "=FILENAME\nlog keystroke commands to the given file"
  },
  {
    "cmd_script",
    4178,
    136096456,
    "=FILENAME\nread keystroke commands from the given file\n(see -cmd_log)"
  },
  {
    "connect_timeout",
    4196,
    135875760,
    "=N\nset the N-second connection timeout"
  },
  {
    "cookie_file",
    84,
    135981496,
    "=FILENAME\nspecifies a file to use to read cookies"
  },
  {
    "cookie_save_file",
    84,
    135981500,
    "=FILENAME\nspecifies a file to use to store cookies"
  },
  { "cookies", 20, 135875696, "toggles handling of Set-Cookie headers" },
  { "core", 20, 135981556, "toggles forced core dumps on fatal errors" },
  {
    "crawl",
    68,
    134720044,
    "with -traversal, output each page to a file\nwith -dump, format output as with -traversal, but to stdout"
  },
  {
    "curses_pads",
    20,
    135878400,
    "uses curses pad feature to support left/right shifting"
  },
  {
    "debug_partial",
    20,
    135981548,
    "incremental display stages with MessageSecs delay"
  },
  {
    "delay",
    4228,
    136096464,
    "=NNN\nset NNN-second delay at statusline message"
  },
  {
    "display",
    4164,
    134720071,
    "=DISPLAY\nset the display variable for X exec'ed programs"
  },
  {
    "display_charset",
    4164,
    134720101,
    "=MIMEname\ncharset for the terminal output"
  },
  {
    "dont_wrap_pre",
    36,
    135981535,
    "inhibit wrapping of text in <pre> when -dump'ing and\n-crawl'ing, mark wrapped lines in interactive session"
  },
  { "dump", 68, 134720181, "dump the first file to stdout and exit" },
  {
    "editor",
    4164,
    134720196,
    "=EDITOR\nenable edit mode with specified editor"
  },
  { "emacskeys", 36, 135981109, "enable emacs-like key movement" },
  {
    "enable_scrollback",
    20,
    135981068,
    "\ntoggles compatibility with comm programs' scrollback\nkeys (may be incompatible with some curses packages)"
  },
  { "error_file", 4164, 134720241, "=FILE\nwrite the HTTP status code here" },
  { "exec", 68, 134720265, "enable local program execution" },
  {
    "force_empty_hrefless_a",
    36,
    135981539,
    "\nforce HREF-less 'A' elements to be empty (close them as\nsoon as they are seen)"
  },
  {
    "force_html",
    36,
    135981201,
    "forces the first document to be interpreted as HTML"
  },
  {
    "force_secure",
    20,
    135981532,
    "toggles forcing of the secure flag for SSL cookies"
  },
  {
    "forms_options",
    20,
    135875676,
    "toggles forms-based vs old-style options menu"
  },
  { "from", 20, 135875694, "toggle transmission of From headers" },
  { "ftp", 52, 135875686, "disable ftp access" },
  {
    "get_data",
    66,
    134720282,
    "user data for get forms, read from stdin,\nterminated by '---' on a line"
  },
  { "head", 36, 135981203, "send a HEAD request" },
  { "help", 65, 134720469, "print this usage message" },
  {
    "hiddenlinks",
    4164,
    134720494,
    "=[option]\nhidden links: options are merge, listonly, or ignore"
  },
  {
    "historical",
    20,
    135981112,
    "toggles use of '>' or '-->' as terminator for comments"
  },
  { "homepage", 4164, 134720568, "=URL\nset homepage separate from start page" },
  { "image_links", 20, 135981217, "toggles inclusion of links for all images" },
  { "index", 4180, 135981360, "=URL\nset the default index file to URL" },
  {
    "ismap",
    20,
    135981512,
    "toggles inclusion of ISMAP links when client-side\nMAPs are present"
  },
  { "justify", 36, 135981536, "do justification of text" },
  {
    "link",
    4196,
    135981460,
    "=NUMBER\nstarting count for lnk#.dat files produced by -crawl"
  },
  {
    "listonly",
    20,
    135981106,
    "with -dump, forces it to show only the list of links"
  },
  { "localhost", 36, 135981198, "disable URLs that point to remote hosts" },
  {
    "locexec",
    36,
    135981063,
    "enable local program execution from local files only"
  },
  {
    "lss",
    4178,
    135981560,
    "=FILENAME\nspecifies a lynx.lss file other than the default"
  },
  { "mime_header", 68, 134720618, "include mime headers and force source dump" },
  { "minimal", 20, 135981115, "toggles minimal versus valid comment parsing" },
  { "nested_tables", 20, 135875732, "toggles nested-tables logic" },
  {
    "newschunksize",
    4164,
    134720704,
    "=NUMBER\nnumber of articles in chunked news listings"
  },
  {
    "newsmaxchunk",
    4164,
    134720764,
    "=NUMBER\nmaximum news articles in listings before chunking"
  },
  { "nobold", 68, 134720824, "disable bold video-attribute" },
  { "nobrowse", 68, 134720849, "disable directory browsing" },
  { "nocc", 36, 135981533, "disable Cc: prompts for self copies of mailings" },
  { "nocolor", 68, 134720869, "turn off color support" },
  { "noexec", 52, 135981062, "disable local program execution (DEFAULT)" },
  {
    "nofilereferer",
    36,
    135875689,
    "disable transmission of Referer headers for file URLs"
  },
  { "nolist", 36, 135981222, "disable the link list feature in dumps" },
  {
    "nolog",
    52,
    135981110,
    "disable mailing of error messages to document owners"
  },
  {
    "nomargins",
    36,
    135981223,
    "disable the right/left margins in the default\nstyle-sheet"
  },
  { "nomore", 68, 134720904, "disable -more- string in statusline messages" },
  {
    "nonrestarting_sigwinch",
    36,
    135981549,
    "\nmake window size change handler non-restarting"
  },
  {
    "nonumbers",
    36,
    135981580,
    "disable the link/form numbering feature in dumps"
  },
  { "nopause", 68, 134720889, "disable forced pauses for statusline messages" },
  {
    "noprint",
    36,
    135981170,
    "disable some print functions, like -restrictions=print"
  },
  { "noredir", 36, 135981225, "don't follow Location: redirection" },
  { "noreferer", 36, 135981210, "disable transmission of Referer headers" },
  { "noreverse", 68, 134720921, "disable reverse video-attribute" },
  {
    "nostatus",
    36,
    135981197,
    "disable the miscellaneous information messages"
  },
  { "notitle", 36, 135981224, "disable the title at the top of each page" },
  { "nounderline", 68, 134720946, "disable underline video-attribute" },
  {
    "number_fields",
    36,
    135981582,
    "force numbering of links as well as form input fields"
  },
  { "number_links", 36, 135981581, "force numbering of links" },
  {
    "partial",
    20,
    135875772,
    "toggles display partial pages while downloading"
  },
  {
    "partial_thres",
    4196,
    135875776,
    "[=NUMBER]\nnumber of lines to render before repainting display\nwith partial-display logic"
  },
  { "passive-ftp", 20, 135875688, "toggles passive ftp connection" },
  {
    "pauth",
    4164,
    134720971,
    "=id:pw\nauthentication information for protected proxy server"
  },
  {
    "popup",
    52,
    135875697,
    "toggles handling of single-choice SELECT options via\npopup windows or as lists of radio buttons"
  },
  {
    "post_data",
    66,
    134721003,
    "user data for post forms, read from stdin,\nterminated by '---' on a line"
  },
  {
    "preparsed",
    36,
    135981534,
    "show parsed text/html with -source and in source view\nto visualize how lynx behaves with invalid HTML"
  },
  {
    "prettysrc",
    36,
    135994982,
    "do syntax highlighting and hyperlink handling in source\nview"
  },
  {
    "print",
    52,
    135981170,
    "enable print functions (DEFAULT), opposite of -noprint"
  },
  {
    "pseudo_inlines",
    20,
    135875699,
    "toggles pseudo-ALTs for inlines with no ALT string"
  },
  {
    "raw",
    52,
    135875698,
    "toggles default setting of 8-bit character translations\nor CJK mode for the startup character set"
  },
  { "realm", 36, 135981216, "restricts access to URLs in the starting realm" },
  { "read_timeout", 4196, 135875764, "=N\nset the N-second read-timeout" },
  {
    "reload",
    36,
    136000420,
    "flushes the cache on a proxy server\n(only the first document affected)"
  },
  { "restrictions", 68, 134721155, "=[options]\nuse -restrictions to see list" },
  {
    "resubmit_posts",
    20,
    135981097,
    "toggles forced resubmissions (no-cache) of forms with\nmethod POST when the documents they returned are sought\nwith the PREV_DOC command or from the History List"
  },
  { "rlogin", 52, 135875685, "disable rlogins" },
  { "scrollbar", 20, 135971156, "toggles showing scrollbar" },
  {
    "scrollbar_arrow",
    20,
    135875456,
    "toggles showing arrows at ends of the scrollbar"
  },
  {
    "selective",
    68,
    134721749,
    "require .www_browsable files to browse directories"
  },
  {
    "short_url",
    36,
    135981128,
    "enables examination of beginning and end of long URL in\nstatus line"
  },
  {
    "show_cursor",
    20,
    135875677,
    "toggles hiding of the cursor in the lower right corner"
  },
  { "show_rate", 20, 135875733, "toggles display of transfer rate" },
  {
    "soft_dquotes",
    20,
    135981117,
    "toggles emulation of the old Netscape and Mosaic\nbug which treated '>' as a co-terminator for\ndouble-quotes and tags"
  },
  {
    "source",
    68,
    134721769,
    "dump the source of the first file to stdout and exit"
  },
  { "stack_dump", 36, 135981574, "disable SIGINT cleanup handler" },
  {
    "startfile_ok",
    36,
    135981226,
    "allow non-http startfile and homepage with -validate"
  },
  {
    "stderr",
    36,
    135981108,
    "write warning messages to standard error when -dump\nor -source is used"
  },
  { "stdin", 36, 135981572, "read startfile from standard input" },
  { "syslog", 4180, 135981044, "=text\ninformation for syslog call" },
  { "syslog-urls", 36, 135875648, "log requested URLs with syslog" },
  { "tagsoup", 36, 135981573, "use TagSoup rather than SortaSGML parser" },
  { "telnet", 52, 135875683, "disable telnets" },
  { "term", 4212, 135981576, "=TERM\nset terminal type to TERM" },
  {
    "tlog",
    18,
    135875752,
    "toggles use of a Lynx Trace Log for the current\nsession"
  },
  { "tna", 36, 135981541, "turn on \"Textfields Need Activation\" mode" },
  { "trace", 33, 136019752, "turns on Lynx trace mode" },
  { "trace_mask", 97, 136019756, "customize Lynx trace mode" },
  {
    "traversal",
    68,
    134721848,
    "traverse all http links derived from startfile"
  },
  {
    "trim_input_fields",
    34,
    135981098,
    "\ntrim input text/textarea fields in forms"
  },
  {
    "underline_links",
    20,
    135981092,
    "toggles use of underline/bold attribute for links"
  },
  { "underscore", 20, 135981118, "toggles use of _underline_ format in dumps" },
  { "use_mouse", 36, 135981211, "turn on mouse support" },
  {
    "useragent",
    4180,
    135981280,
    "=Name\nset alternate Lynx User-Agent header"
  },
  {
    "validate",
    34,
    135981093,
    "accept only http URLs (meant for validation)\nimplies more restrictions than -anonymous, but\ngoto is allowed for http and https"
  },
  {
    "verbose",
    20,
    135875682,
    "toggles [LINK], [IMAGE] and [INLINE] comments\nwith filenames of these images"
  },
  { "version", 65, 134721875, "print Lynx version information" },
  { "vikeys", 36, 135981119, "enable vi-like key movement" },
  {
    "width",
    4164,
    134722235,
    "=NUMBER\nscreen width for formatting of dumps (default is 80)"
  },
  {
    "with_backspaces",
    36,
    135981538,
    "emit backspaces in output if -dumping or -crawling\n(like 'man' does)"
  },
  { "xhtml-parsing", 36, 135981099, "enable XHTML 1.0 parsing" },
  { NULL, 0, 0, NULL }
}; // idb
do_check_goto_URL::$8212C7EB327EFE2C60031DBD77B57C6A table_11782[29] =
{
  { "file:", &no_file_url },
  { "file:", &no_goto_file },
  { "lynxexec:", &no_goto_lynxexec },
  { "lynxprog:", &no_goto_lynxprog },
  { "lynxcgi:", &no_goto_lynxcgi },
  { "cso:", &no_goto_cso },
  { "finger:", &no_goto_finger },
  { "ftp:", &no_goto_ftp },
  { "gopher:", &no_goto_gopher },
  { "http:", &no_goto_http },
  { "https:", &no_goto_https },
  { "mailto:", &no_goto_mailto },
  { "rlogin:", &no_goto_rlogin },
  { "telnet:", &no_goto_telnet },
  { "tn3270:", &no_goto_tn3270 },
  { "wais:", &no_goto_wais },
  { "bibp:", &no_goto_bibp },
  { "news:", &no_goto_news },
  { "nntp:", &no_goto_nntp },
  { "snews:", &no_goto_snews },
  { "lynxexec:", &local_exec_on_local_files },
  { "lynxprog:", &local_exec_on_local_files },
  { "LYNXCFG:", &no_goto_configinfo },
  { "LYNXCOMPILEOPTS:", &no_goto_configinfo },
  { "LYNXCOOKIE:", &always_11778 },
  { "LYNXDIRED:", &always_11778 },
  { "LYNXDOWNLOAD:", &always_11778 },
  { "LYNXOPTIONS:", &always_11778 },
  { "LYNXPRINT:", &always_11778 }
}; // idb
_UNKNOWN off_81955A4; // weak
int wrap_16871[8] = { 0, 0, 12, 9, 8, 6, 4, 3 }; // idb
const char *choices_16870[9] =
{
  "Try to fit screen width",
  "No line wrap in columns",
  "Wrap columns at screen width",
  "Wrap columns at 3/4 screen width",
  "Wrap columns at 2/3 screen width",
  "Wrap columns at 1/2 screen width",
  "Wrap columns at 1/3 screen width",
  "Wrap columns at 1/4 screen width",
  NULL
}; // idb
BOOLEAN LYuseCursesPads = '\x01'; // idb
$DBB1E1E6705BC4B806160C1C96DE9354 Mono_Attrs[7] =
{
  { "normal", 0 },
  { "bold", 2097152 },
  { "reverse", 262144 },
  { "underline", 131072 },
  { "standout", 65536 },
  { "blink", 524288 },
  { "dim", 1048576 }
}; // idb
$913762FBC94D78C2A01B743F5E433185 lynx_color_cfg[8] =
{
  { -1, 1, -1, 1 },
  { 4, 0, -1, 1 },
  { 11, 0, 4, 0 },
  { 2, 0, -1, 1 },
  { 5, 0, -1, 1 },
  { 4, 0, -1, 1 },
  { 1, 0, -1, 1 },
  { 5, 0, 6, 0 }
}; // idb
int can_fix_11245 = 1; // idb
char MBMcodes_10881[27] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // idb
BOOLEAN first_14418 = '\x01'; // idb
BOOLEAN firsttime_14684 = '\x01'; // idb
uip_entry ly_uip[13] =
{
  { UIP_HISTORY_0, 3u, NULL, NULL, NULL },
  { UIP_DOWNLOAD_OPTIONS_0, 0u, NULL, NULL, NULL },
  { UIP_PRINT_OPTIONS_0, 0u, NULL, NULL, NULL },
  { UIP_SHOWINFO_0, 3u, NULL, NULL, NULL },
  { UIP_LIST_PAGE_0, 3u, NULL, NULL, NULL },
  { UIP_VLINKS_0, 3u, NULL, NULL, NULL },
  { UIP_OPTIONS_MENU_0, 3u, NULL, NULL, NULL },
  { UIP_DIRED_MENU_0, 0u, NULL, NULL, NULL },
  { UIP_PERMIT_OPTIONS_0, 0u, NULL, NULL, NULL },
  { UIP_UPLOAD_OPTIONS_0, 3u, NULL, NULL, NULL },
  { UIP_LYNXCFG_0, 3u, NULL, NULL, NULL },
  { UIP_CONFIG_DEF_0, 3u, NULL, NULL, NULL },
  { UIP_TRACELOG_0, 0u, NULL, NULL, NULL }
}; // idb
int LYChosenShowColor = -1; // idb
const char *userMode_choices_11250[4] = { "Novice", "Intermediate", "Advanced", NULL }; // idb
const char *mbm_choices_11249[4] = { "OFF     ", "STANDARD", "ADVANCED", NULL }; // idb
const char *keypad_choices_11248[4] =
{
  "Numbers act as arrows",
  "Links are numbered",
  "Links and form fields are numbered",
  NULL
}; // idb
const char *fileSort_choices_11247[5] = { "By Filename", "By Type", "By Size", "By Date", NULL }; // idb
const char *dirList_choices_11246[4] = { "Directories first", "Files first", "Mixed style", NULL }; // idb
const char *caseless_choices_11245[3] = { "CASE INSENSITIVE", "CASE SENSITIVE", NULL }; // idb
const char *bool_choices_11244[3] = { "OFF", "ON", NULL }; // idb
OptValues bool_values[3] = { { 0, "OFF", "OFF" }, { 1, "ON", "ON" }, { 0, NULL, NULL } }; // idb
const char *secure_string = "secure"; // idb
const char *save_options_string = "save_options"; // idb
const char *cookies_string = "set_cookies"; // idb
const char *cookies_ignore_all_string = "ignore"; // idb
const char *cookies_up_to_user_string = "ask user"; // idb
const char *cookies_accept_all_string = "accept all"; // idb
const char *x_display_string = "display"; // idb
const char *editor_string = "file_editor"; // idb
const char *emacs_keys_string = "emacs_keys"; // idb
const char *keypad_mode_string = "keypad_mode"; // idb
OptValues keypad_mode_values[5] =
{
  { 0, "Numbers act as arrows", "number_arrows" },
  { 1, "Links are numbered", "links_numbered" },
  { 2, "Links and form fields are numbered", "links_and_forms" },
  { 3, "Form fields are numbered", "forms_numbered" },
  { 0, NULL, NULL }
}; // idb
const char *lineedit_mode_string = "lineedit_mode"; // idb
const char *mail_address_string = "personal_mail_address"; // idb
const char *search_type_string = "case_sensitive_searching"; // idb
const char *anonftp_password_string = "anonftp_password"; // idb
OptValues search_type_values[3] =
{
  { 0, "Case insensitive", "case_insensitive" },
  { 1, "Case sensitive", "case_sensitive" },
  { 0, NULL, NULL }
}; // idb
const char *show_color_string = "show_color"; // idb
OptValues show_color_values[5] =
{
  { 0, "NEVER", "NEVER" },
  { 1, "OFF", "OFF" },
  { 2, "ON", "ON" },
  { 3, "ALWAYS", "ALWAYS" },
  { 0, NULL, NULL }
}; // idb
const char *show_cursor_string = "show_cursor"; // idb
const char *underline_links_string = "underline_links"; // idb
const char *show_scrollbar_string = "scrollbar"; // idb
OptValues prompt_values[4] =
{
  { 0, "prompt normally", "prompt normally" },
  { 1, "force yes-response", "force yes-response" },
  { 2, "force no-response", "force no-response" },
  { 0, NULL, NULL }
}; // idb
const char *cookie_prompt_string = "force_cookie_prompt"; // idb
const char *user_mode_string = "user_mode"; // idb
OptValues user_mode_values[4] =
{
  { 0, "Novice", "Novice" },
  { 1, "Intermediate", "Intermediate" },
  { 2, "Advanced", "Advanced" },
  { 0, NULL, NULL }
}; // idb
const char *vi_keys_string = "vi_keys"; // idb
const char *visited_links_string = "visited_links"; // idb
OptValues visited_links_values[6] =
{
  { 0, "By First Visit", "first_visited" },
  { 4, "By First Visit Reversed", "first_visited_reversed" },
  { 1, "As Visit Tree", "visit_tree" },
  { 2, "By Last Visit", "last_visited" },
  { 6, "By Last Visit Reversed", "last_visited_reversed" },
  { 0, NULL, NULL }
}; // idb
const char *DTD_recovery_string = "tagsoup"; // idb
OptValues DTD_type_values[3] =
{
  { 1, "relaxed (TagSoup mode)", "tagsoup" },
  { 0, "strict (SortaSGML mode)", "sortasgml" },
  { 0, NULL, NULL }
}; // idb
const char *select_popups_string = "select_popups"; // idb
const char *images_string = "images"; // idb
const char *images_ignore_all_string = "ignore"; // idb
const char *images_use_label_string = "as labels"; // idb
const char *images_use_links_string = "as links"; // idb
const char *verbose_images_string = "verbose_images"; // idb
OptValues verbose_images_type_values[3] = { { 0, "OFF", "OFF" }, { 1, "show filename", "ON" }, { 0, NULL, NULL } }; // idb
const char *mbm_string = "multi_bookmark"; // idb
OptValues mbm_values[4] =
{
  { 0, "OFF", "OFF" },
  { 1, "STANDARD", "STANDARD" },
  { 2, "ADVANCED", "ADVANCED" },
  { 0, NULL, NULL }
}; // idb
const char *single_bookmark_string = "bookmark_file"; // idb
const char *assume_char_set_string = "assume_charset"; // idb
const char *display_char_set_string = "character_set"; // idb
const char *raw_mode_string = "raw_mode"; // idb
const char *locale_charset_string = "locale_charset"; // idb
const char *show_dotfiles_string = "show_dotfiles"; // idb
const char *dired_list_string = "dir_list_style"; // idb
OptValues dired_list_values[4] =
{
  { 0, "Directories first", "dired_dir" },
  { 1, "Files first", "dired_files" },
  { 2, "Mixed style", "dired_mixed" },
  { 0, NULL, NULL }
}; // idb
const char *dired_sort_string = "dir_list_order"; // idb
OptValues dired_sort_values[8] =
{
  { 0, "By Name", "dired_by_name" },
  { 4, "By Type", "dired_by_type" },
  { 1, "By Size", "dired_by_size" },
  { 2, "By Date", "dired_by_date" },
  { 3, "By Mode", "dired_by_mode" },
  { 5, "By User", "dired_by_user" },
  { 6, "By Group", "dired_by_group" },
  { 0, NULL, NULL }
}; // idb
const char *passive_ftp_string = "ftp_passive"; // idb
const char *ftp_sort_string = "file_sorting_method"; // idb
OptValues ftp_sort_values[5] =
{
  { 0, "By Name", "ftp_by_name" },
  { 1, "By Type", "ftp_by_type" },
  { 2, "By Size", "ftp_by_size" },
  { 3, "By Date", "ftp_by_date" },
  { 0, NULL, NULL }
}; // idb
const char *show_rate_string = "show_kb_rate"; // idb
OptValues rate_values[6] =
{
  { 0, "Do not show rate", "rate_off" },
  { 1, "Show %s/sec rate", "rate_bytes" },
  { 2, "Show %s/sec rate", "rate_kb" },
  { 3, "Show %s/sec, ETA", "rate_eta_bytes" },
  { 4, "Show %s/sec, ETA", "rate_eta_kb" },
  { 0, NULL, NULL }
}; // idb
const char *preferred_media_string = "preferred_media_types"; // idb
OptValues media_values[6] =
{
  { 1, "Accept lynx's internal types", "media_opt1" },
  { 5, "Also accept lynx.cfg's types", "media_opt2" },
  { 13, "Also accept user's types", "media_opt3" },
  { 29, "Also accept system's types", "media_opt4" },
  { 31, "Accept all types", "media_all" },
  { 0, NULL, NULL }
}; // idb
const char *preferred_encoding_string = "preferred_encoding"; // idb
OptValues encoding_values[7] =
{
  { 0, "None", "encoding_none" },
  { 1, "gzip", "encoding_gzip" },
  { 2, "deflate", "encoding_deflate" },
  { 4, "compress", "encoding_compress" },
  { 8, "bzip2", "encoding_bzip2" },
  { 15, "All", "encoding_all" },
  { 0, NULL, NULL }
}; // idb
const char *preferred_doc_char_string = "preferred_charset"; // idb
const char *preferred_doc_lang_string = "preferred_language"; // idb
const char *user_agent_string = "useragent"; // idb
char oops_14639[2] = "?"; // idb
const char *table_14706[3] = { "set_cookies", "accept_all_cookies", NULL }; // idb
const char *table_14713[3] = { "make_pseudo_alts_for_inlines", "make_links_for_all_images", NULL }; // idb
char tempfile_14731[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
BOOLEAN LYUseNoviceLineTwo = '\x01'; // idb
int default_fg = -1; // idb
int default_bg = -1; // idb
const char *Color_Strings[16] =
{
  "black",
  "red",
  "green",
  "brown",
  "blue",
  "magenta",
  "cyan",
  "lightgray",
  "gray",
  "brightred",
  "brightgreen",
  "yellow",
  "brightblue",
  "brightmagenta",
  "brightcyan",
  "white"
}; // idb
Config_Enum lexemnames_12106[13] =
{
  { "comm", 0 },
  { "tag", 1 },
  { "attrib", 2 },
  { "attrval", 3 },
  { "abracket", 4 },
  { "entity", 5 },
  { "href", 6 },
  { "entire", 7 },
  { "badseq", 8 },
  { "badtag", 9 },
  { "badattr", 10 },
  { "sgmlspecial", 11 },
  { NULL, -1 }
}; // idb
Config_Type_0 Config_Table[208] =
{
  { "accept_all_cookies", CONF_BOOL, 135981204, NULL },
  { "alertsecs", CONF_TIME, 136096424, NULL },
  { "always_resubmit_posts", CONF_BOOL, 135981097, NULL },
  { "always_trusted_exec", CONF_ADD_TRUSTED, 1, NULL },
  { "assume_charset", CONF_FUN, 134900739, NULL },
  { "assume_local_charset", CONF_FUN, 134900798, NULL },
  { "assume_unrec_charset", CONF_FUN, 134900827, NULL },
  { "assumed_color", CONF_FUN, 134900926, NULL },
  { "auto_uncache_dirlists", CONF_INT, 135875652, NULL },
  { "bibp_bibhost", CONF_STR, 135981484, NULL },
  { "bibp_globalserver", CONF_STR, 135981488, NULL },
  { "block_multi_bookmarks", CONF_BOOL, 135981208, NULL },
  { "bold_h1", CONF_BOOL, 135981100, NULL },
  { "bold_headers", CONF_BOOL, 135981101, NULL },
  { "bold_name_anchors", CONF_BOOL, 135981102, NULL },
  { "broken_ftp_epsv", CONF_ADD_STRING, 135981176, NULL },
  { "broken_ftp_retr", CONF_ADD_STRING, 135981180, NULL },
  { "bzip2_path", CONF_PRG, 1, NULL },
  { "case_sensitive_always_on", CONF_BOOL, 135981103, NULL },
  { "character_set", CONF_FUN, 134900856, NULL },
  { "checkmail", CONF_BOOL, 135981104, NULL },
  { "chmod_path", CONF_PRG, 2, NULL },
  { "collapse_br_tags", CONF_BOOL, 135875692, NULL },
  { "color", CONF_FUN, 134901168, NULL },
  { "color_style", CONF_STR, 135981564, NULL },
  { "compress_path", CONF_PRG, 3, NULL },
  { "copy_path", CONF_PRG, 4, NULL },
  { "connect_timeout", CONF_INT, 135875760, NULL },
  { "cookie_accept_domains", CONF_STR, 135981248, NULL },
  { "cookie_file", CONF_STR, 135981496, NULL },
  { "cookie_loose_invalid_domains", CONF_STR, 135981252, NULL },
  { "cookie_query_invalid_domains", CONF_STR, 135981256, NULL },
  { "cookie_reject_domains", CONF_STR, 135981260, NULL },
  { "cookie_save_file", CONF_STR, 135981500, NULL },
  { "cookie_strict_invalid_domains", CONF_STR, 135981264, NULL },
  { "cso_proxy", CONF_ENV, 0, NULL },
  { "delaysecs", CONF_TIME, 136096464, NULL },
  { "default_bookmark_file", CONF_FUN, 134901306, NULL },
  { "default_cache_size", CONF_FUN, 134901330, NULL },
  { "default_colors", CONF_FUN, 134901192, NULL },
  { "default_editor", CONF_FUN, 134901379, NULL },
  { "default_index_file", CONF_STR, 135981360, NULL },
  { "default_keypad_mode", CONF_ENUM, 135981120, &tbl_keypad_mode },
  { "default_keypad_mode_is_numbers_as_arrows", CONF_FUN, 134901422, NULL },
  { "default_user_mode", CONF_ENUM, 135981124, &tbl_user_mode },
  { "dired_menu", CONF_FUN, 134901472, NULL },
  { "downloader", CONF_ADD_ITEM, 135981076, NULL },
  { "emacs_keys_always_on", CONF_BOOL, 135981109, NULL },
  { "enable_lynxrc", CONF_FUN, 134949793, NULL },
  { "enable_scrollback", CONF_BOOL, 135981068, NULL },
  { "external", CONF_ADD_ITEM, 135981080, NULL },
  { "finger_proxy", CONF_ENV, 0, NULL },
  { "force_8bit_toupper", CONF_BOOL, 135981213, NULL },
  { "force_cookie_prompt", CONF_ENUM, 136096432, &tbl_force_prompt },
  { "force_empty_hrefless_a", CONF_BOOL, 135981539, NULL },
  { "force_ssl_cookies_secure", CONF_BOOL, 135981532, NULL },
  { "forms_options", CONF_BOOL, 135875676, NULL },
  { "ftp_passive", CONF_BOOL, 135875688, NULL },
  { "ftp_proxy", CONF_ENV, 0, NULL },
  { "global_extension_map", CONF_STR, 135981336, NULL },
  { "global_mailcap", CONF_STR, 135981340, NULL },
  { "gopher_proxy", CONF_ENV, 0, NULL },
  { "gotobuffer", CONF_BOOL, 135981111, NULL },
  { "gzip_path", CONF_PRG, 6, NULL },
  { "helpfile", CONF_STR, 135981344, NULL },
  { "hidden_link_marker", CONF_STR, 135981544, NULL },
  { "historical_comments", CONF_BOOL, 135981112, NULL },
  { "htmlsrc_attrname_xform", CONF_FUN, 134905939, NULL },
  { "htmlsrc_tagname_xform", CONF_FUN, 134906097, NULL },
  { "http_proxy", CONF_ENV, 0, NULL },
  { "https_proxy", CONF_ENV, 0, NULL },
  { "include", CONF_INCLUDE, 0, NULL },
  { "inflate_path", CONF_PRG, 7, NULL },
  { "infosecs", CONF_TIME, 136096428, NULL },
  { "install_path", CONF_PRG, 8, NULL },
  { "jump_prompt", CONF_STR, 135981368, NULL },
  { "jumpbuffer", CONF_BOOL, 135981114, NULL },
  { "jumpfile", CONF_FUN, 134901496, NULL },
  { "justify", CONF_BOOL, 135981536, NULL },
  { "justify_max_void_percent", CONF_INT, 135875768, NULL },
  { "keymap", CONF_FUN, 134901628, NULL },
  { "leftarrow_in_textfield_prompt", CONF_BOOL, 135981542, NULL },
  { "list_format", CONF_STR, 135981040, NULL },
  { "list_news_dates", CONF_BOOL, 135981206, NULL },
  { "list_news_numbers", CONF_BOOL, 135981207, NULL },
  { "locale_charset", CONF_BOOL, 135981537, NULL },
  { "local_domain", CONF_STR, 135981276, NULL },
  { "localhost_alias", CONF_FUN, 134902657, NULL },
  { "local_execution_links_always_on", CONF_BOOL, 135981062, NULL },
  { "local_execution_links_on_but_not_remote", CONF_BOOL, 135981063, NULL },
  { "lynx_host_name", CONF_STR, 135981272, NULL },
  { "lynx_sig_file", CONF_FUN, 134902705, NULL },
  { "lynxcgi_document_root", CONF_STR, 135981064, NULL },
  { "lynxcgi_environment", CONF_FUN, 134902681, NULL },
  { "mail_system_error_logging", CONF_BOOL, 135981110, NULL },
  { "make_links_for_all_images", CONF_BOOL, 135981217, NULL },
  { "make_pseudo_alts_for_inlines", CONF_BOOL, 135875699, NULL },
  { "max_cookies_buffer", CONF_INT, 135875724, NULL },
  { "max_cookies_domain", CONF_INT, 135875716, NULL },
  { "max_cookies_global", CONF_INT, 135875720, NULL },
  { "messagesecs", CONF_TIME, 136096416, NULL },
  { "minimal_comments", CONF_BOOL, 135981115, NULL },
  { "mkdir_path", CONF_PRG, 9, NULL },
  { "multi_bookmark_support", CONF_ENUM, 135981456, &tbl_multi_bookmarks },
  { "mv_path", CONF_PRG, 10, NULL },
  { "ncr_in_bookmarks", CONF_BOOL, 135981214, NULL },
  { "nested_tables", CONF_BOOL, 135875732, NULL },
  { "news_chunk_size", CONF_FUN, 134902987, NULL },
  { "news_max_chunk", CONF_FUN, 134903041, NULL },
  { "news_posting", CONF_FUN, 134903095, NULL },
  { "news_proxy", CONF_ENV, 0, NULL },
  { "newspost_proxy", CONF_ENV, 0, NULL },
  { "newsreply_proxy", CONF_ENV, 0, NULL },
  { "nntp_proxy", CONF_ENV, 0, NULL },
  { "nntpserver", CONF_ENV2, 0, NULL },
  { "number_fields_on_left", CONF_BOOL, 135875680, NULL },
  { "number_links_on_left", CONF_BOOL, 135875681, NULL },
  { "no_dot_files", CONF_BOOL, 135875687, NULL },
  { "no_file_referer", CONF_BOOL, 135875689, NULL },
  { "no_forced_core_dump", CONF_BOOL, 135981556, NULL },
  { "no_from_header", CONF_BOOL, 135875694, NULL },
  { "no_ismap_if_usemap", CONF_BOOL, 135981512, NULL },
  { "no_margins", CONF_BOOL, 135981223, NULL },
  { "no_proxy", CONF_ENV, 0, NULL },
  { "no_referer_header", CONF_BOOL, 135981210, NULL },
  { "no_table_center", CONF_BOOL, 135981202, NULL },
  { "no_title", CONF_BOOL, 135981224, NULL },
  { "nonrestarting_sigwinch", CONF_FUN, 134905219, NULL },
  { "outgoing_mail_charset", CONF_FUN, 134900897, NULL },
  { "partial", CONF_BOOL, 135875772, NULL },
  { "partial_thres", CONF_INT, 135875776, NULL },
  { "persistent_cookies", CONF_BOOL, 135981492, NULL },
  { "personal_extension_map", CONF_STR, 135981404, NULL },
  { "personal_mailcap", CONF_STR, 135981412, NULL },
  { "positionable_editor", CONF_ADD_STRING, 135981552, NULL },
  { "preferred_charset", CONF_STR, 135981416, NULL },
  { "preferred_encoding", CONF_ENUM, 135875740, &tbl_preferred_encoding },
  { "preferred_language", CONF_STR, 135981372, NULL },
  { "preferred_media_types", CONF_ENUM, 135875744, &tbl_preferred_media },
  { "prepend_base_to_source", CONF_BOOL, 135875756, NULL },
  { "prepend_charset_to_source", CONF_BOOL, 135875757, NULL },
  { "prettysrc", CONF_BOOL, 135994982, NULL },
  { "prettysrc_spec", CONF_FUN, 134905707, NULL },
  { "prettysrc_view_no_anchor_numbering", CONF_BOOL, 135994984, NULL },
  { "printer", CONF_ADD_ITEM, 135981072, NULL },
  { "quit_default_yes", CONF_BOOL, 135875758, NULL },
  { "read_timeout", CONF_INT, 135875764, NULL },
  { "referer_with_query", CONF_FUN, 134903462, NULL },
  { "replaysecs", CONF_TIME, 136096448, NULL },
  { "reuse_tempfiles", CONF_BOOL, 135981550, NULL },
  { "rlogin_path", CONF_PRG, 11, NULL },
  { "rm_path", CONF_PRG, 12, NULL },
  { "rule", CONF_FUN, 135441213, NULL },
  { "rulesfile", CONF_FUN, 134903141, NULL },
  { "save_space", CONF_STR, 135981380, NULL },
  { "scan_for_buried_news_refs", CONF_BOOL, 135875700, NULL },
  { "scrollbar", CONF_BOOL, 135971156, NULL },
  { "scrollbar_arrow", CONF_BOOL, 135875456, NULL },
  { "seek_frag_area_in_cur", CONF_BOOL, 135875754, NULL },
  { "seek_frag_map_in_cur", CONF_BOOL, 135875753, NULL },
  { "set_cookies", CONF_BOOL, 135875696, NULL },
  { "show_cursor", CONF_BOOL, 135981091, NULL },
  { "show_kb_name", CONF_STR, 135981504, NULL },
  { "show_kb_rate", CONF_ENUM, 135875736, &tbl_transfer_rate },
  { "snews_proxy", CONF_ENV, 0, NULL },
  { "snewspost_proxy", CONF_ENV, 0, NULL },
  { "snewsreply_proxy", CONF_ENV, 0, NULL },
  { "soft_dquotes", CONF_BOOL, 135981117, NULL },
  { "source_cache", CONF_ENUM, 135971148, &tbl_source_cache },
  { "source_cache_for_aborted", CONF_ENUM, 135971152, &tbl_abort_source_cache },
  { "ssl_cert_file", CONF_STR, 135981516, NULL },
  { "startfile", CONF_STR, 135981428, NULL },
  { "strip_dotdot_urls", CONF_BOOL, 135875755, NULL },
  { "substitute_underscores", CONF_BOOL, 135981118, NULL },
  { "suffix", CONF_FUN, 134903562, NULL },
  { "suffix_order", CONF_FUN, 134904382, NULL },
  { "syslog_requested_urls", CONF_BOOL, 135875648, NULL },
  { "syslog_text", CONF_STR, 135981044, NULL },
  { "system_editor", CONF_FUN, 134904627, NULL },
  { "system_mail", CONF_STR, 135981436, NULL },
  { "system_mail_flags", CONF_STR, 135981440, NULL },
  { "tagsoup", CONF_FUN, 134945851, NULL },
  { "tar_path", CONF_PRG, 15, NULL },
  { "telnet_path", CONF_PRG, 16, NULL },
  { "textfields_need_activation", CONF_BOOL, 135981541, NULL },
  { "tn3270_path", CONF_PRG, 17, NULL },
  { "touch_path", CONF_PRG, 18, NULL },
  { "trim_input_fields", CONF_BOOL, 135981098, NULL },
  { "trusted_exec", CONF_ADD_TRUSTED, 0, NULL },
  { "trusted_lynxcgi", CONF_ADD_TRUSTED, 2, NULL },
  { "uncompress_path", CONF_PRG, 19, NULL },
  { "underline_links", CONF_BOOL, 135981092, NULL },
  { "unzip_path", CONF_PRG, 20, NULL },
  { "uploader", CONF_ADD_ITEM, 135981084, NULL },
  { "url_domain_prefixes", CONF_STR, 135981300, NULL },
  { "url_domain_suffixes", CONF_STR, 135981304, NULL },
  { "use_mouse", CONF_BOOL, 135981211, NULL },
  { "use_select_popups", CONF_BOOL, 135875695, NULL },
  { "uudecode_path", CONF_PRG, 21, NULL },
  { "verbose_images", CONF_BOOL, 135875682, NULL },
  { "vi_keys_always_on", CONF_BOOL, 135981119, NULL },
  { "viewer", CONF_FUN, 134904666, NULL },
  { "wais_proxy", CONF_ENV, 0, NULL },
  { "xloadimage_command", CONF_STR, 135981508, NULL },
  { "xhtml_parsing", CONF_BOOL, 135981099, NULL },
  { "zcat_path", CONF_PRG, 22, NULL },
  { "zip_path", CONF_PRG, 23, NULL },
  { NULL, CONF_NIL, 0, NULL }
}; // idb
char tempfile_12787[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char tempfile_12963[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
BOOLEAN first_10558 = '\x01'; // idb
int Visited_Links_As = 6; // idb
char tempfile_11687[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char tempfile_11922[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
HTProtocol LYLynxStatusMessages = { "LYNXMESSAGES", &LYLoadMESSAGES, NULL }; // idb
int LastTFPos = -1; // idb
const char *names_10883[4] =
{
  "LYNX_PRINT_TITLE",
  "LYNX_PRINT_URL",
  "LYNX_PRINT_DATE",
  "LYNX_PRINT_LASTMOD"
}; // idb
BOOLEAN first_mail_preparsed_11280 = '\x01'; // idb
char my_temp_11758[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
Config_Enum tbl_DTD_recovery[7] =
{
  { "true", 1 },
  { "false", 0 },
  { "on", 1 },
  { "off", 0 },
  { "sortasgml", 1 },
  { "tagsoup", 0 },
  { NULL, -1 }
}; // idb
Config_Enum tbl_keypad_mode[7] =
{
  { "FIELDS_ARE_NUMBERED", 3 },
  { "LINKS_AND_FIELDS_ARE_NUMBERED", 2 },
  { "LINKS_ARE_NUMBERED", 1 },
  { "LINKS_ARE_NOT_NUMBERED", 0 },
  { "LINKS_AND_FORM_FIELDS_ARE_NUMBERED", 2 },
  { "NUMBERS_AS_ARROWS", 0 },
  { NULL, 0 }
}; // idb
Config_Enum tbl_preferred_encoding[7] =
{
  { "none", 0 },
  { "gzip", 1 },
  { "deflate", 2 },
  { "compress", 4 },
  { "bzip2", 8 },
  { "all", 15 },
  { NULL, -1 }
}; // idb
Config_Type_1 Config_Table_0[48] =
{
  {
    "accept_all_cookies",
    1,
    CONF_BOOL_0,
    135981204,
    NULL,
    NULL,
    NULL,
    "accept_all_cookies allows the user to tell Lynx to automatically\naccept all cookies if desired.  The default is \"FALSE\" which will\nprompt for each cookie.  Set accept_all_cookies to \"TRUE\" to accept\nall cookies.\n"
  },
  {
    "assume_charset",
    0,
    CONF_FUN_0,
    134945390,
    NULL,
    NULL,
    &put_assume_charset,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "anonftp_password",
    1,
    CONF_STR_0,
    135981308,
    NULL,
    NULL,
    NULL,
    "anonftp_password allows the user to tell Lynx to use the personal\nemail address as the password for anonymous ftp.  If no value is given,\nLynx will use the personal email address.  Set anonftp_password\nto a different value if you choose.\n"
  },
  {
    "bookmark_file",
    1,
    CONF_STR_0,
    135981320,
    NULL,
    NULL,
    NULL,
    "bookmark_file specifies the name and location of the default bookmark\nfile into which the user can paste links for easy access at a later\ndate.\n"
  },
  {
    "case_sensitive_searching",
    1,
    CONF_BOOL_0,
    135981103,
    NULL,
    NULL,
    NULL,
    "If case_sensitive_searching is \"on\" then when the user invokes a search\nusing the 's' or '/' keys, the search performed will be case sensitive\ninstead of case INsensitive.  The default is usually \"off\".\n"
  },
  {
    "character_set",
    1,
    CONF_FUN_0,
    134945579,
    NULL,
    NULL,
    &put_display_charset,
    "The character_set definition controls the representation of 8 bit\ncharacters for your terminal.  If 8 bit characters do not show up\ncorrectly on your screen you may try changing to a different 8 bit\nset or using the 7 bit character approximations.\nCurrent valid characters sets are:\n"
  },
  {
    "cookie_accept_domains",
    1,
    CONF_LIS,
    135981232,
    NULL,
    NULL,
    NULL,
    "cookie_accept_domains and cookie_reject_domains are comma-delimited\nlists of domains from which Lynx should automatically accept or reject\nall cookies.  If a domain is specified in both options, rejection will\ntake precedence.  The accept_all_cookies parameter will override any\nsettings made here.\n"
  },
  {
    "cookie_file",
    1,
    CONF_STR_0,
    135981496,
    NULL,
    NULL,
    NULL,
    "cookie_file specifies the file from which to read persistent cookies.\nThe default is ~/.lynx_cookies.\n"
  },
  {
    "cookie_loose_invalid_domains",
    1,
    CONF_STR_0,
    135981236,
    NULL,
    NULL,
    NULL,
    "cookie_loose_invalid_domains, cookie_strict_invalid_domains, and\ncookie_query_invalid_domains are comma-delimited lists of which domains\nshould be subjected to varying degrees of validity checking.  If a\ndomain is set to strict checking, strict conformance to RFC2109 will\nbe applied.  A domain with loose checking will be allowed to set cookies\nwith an invalid path or domain attribute.  All domains will default to\nquerying the user for an invalid path or domain.\n"
  },
  {
    "cookie_query_invalid_domains",
    1,
    CONF_STR_0,
    135981240,
    NULL,
    NULL,
    NULL,
    NULL
  },
  { "cookie_reject_domains", 1, CONF_LIS, 135981244, NULL, NULL, NULL, NULL },
  {
    "cookie_strict_invalid_domains",
    1,
    CONF_STR_0,
    135981268,
    NULL,
    NULL,
    NULL,
    NULL
  },
  {
    "dir_list_order",
    1,
    CONF_ENUM_0,
    135981056,
    NULL,
    &tbl_dir_list_order,
    NULL,
    "dir_list_order specifies the directory list order under DIRED_SUPPORT\n(if implemented).  The default is \"ORDER_BY_NAME\"\n"
  },
  {
    "dir_list_style",
    1,
    CONF_ENUM_0,
    135875656,
    NULL,
    &tbl_dir_list_style,
    NULL,
    "dir_list_styles specifies the directory list style under DIRED_SUPPORT\n(if implemented).  The default is \"MIXED_STYLE\", which sorts both\nfiles and directories together.  \"FILES_FIRST\" lists files first and\n\"DIRECTORIES_FIRST\" lists directories first.\n"
  },
  {
    "display",
    0,
    CONF_STR_0,
    135981444,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "emacs_keys",
    1,
    CONF_BOOL_0,
    135981109,
    NULL,
    NULL,
    NULL,
    "If emacs_keys is to \"on\" then the normal EMACS movement keys:\n  ^N = down    ^P = up\n  ^B = left    ^F = right\nwill be enabled.\n"
  },
  {
    "file_editor",
    1,
    CONF_FUN_0,
    134945739,
    NULL,
    NULL,
    &put_editor,
    "file_editor specifies the editor to be invoked when editing local files\nor sending mail.  If no editor is specified, then file editing is disabled\nunless it is activated from the command line, and the built-in line editor\nwill be used for sending mail.\n"
  },
  {
    "file_sorting_method",
    1,
    CONF_ENUM_0,
    136000576,
    NULL,
    &tbl_file_sort,
    NULL,
    "The file_sorting_method specifies which value to sort on when viewing\nfile lists such as FTP directories.  The options are:\n   BY_FILENAME -- sorts on the name of the file\n   BY_TYPE     -- sorts on the type of the file\n   BY_SIZE     -- sorts on the size of the file\n   BY_DATE     -- sorts on the date of the file\n"
  },
  {
    "force_cookie_prompt",
    0,
    CONF_ENUM_0,
    136096432,
    NULL,
    &tbl_force_prompt,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "ftp_passive",
    0,
    CONF_BOOL_0,
    135875688,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "keypad_mode",
    1,
    CONF_ENUM_0,
    135981120,
    NULL,
    &tbl_keypad_mode,
    NULL,
    NULL
  },
  {
    "lineedit_mode",
    1,
    CONF_ARRAY,
    135988800,
    &LYLineeditNames,
    NULL,
    NULL,
    "lineedit_mode specifies the key binding used for inputting strings in\nprompts and forms.  If lineedit_mode is set to \"Default Binding\" then\nthe following control characters are used for moving and deleting:\n\n             Prev  Next       Enter = Accept input\n   Move char: <-    ->        ^G    = Cancel input\n   Move word: ^P    ^N        ^U    = Erase line\n Delete char: ^H    ^R        ^A    = Beginning of line\n Delete word: ^B    ^F        ^E    = End of line\n\nCurrent lineedit modes are:\n"
  },
  {
    "locale_charset",
    0,
    CONF_BOOL_0,
    135981537,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "make_pseudo_alts_for_inlines",
    0,
    CONF_BOOL_0,
    135875699,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "make_links_for_all_images",
    0,
    CONF_BOOL_0,
    135981217,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "multi_bookmark",
    1,
    CONF_MBM,
    0,
    NULL,
    NULL,
    NULL,
    "The following allow you to define sub-bookmark files and descriptions.\nThe format is multi_bookmark<capital_letter>=<filename>,<description>\nUp to 26 bookmark files (for the English capital letters) are allowed.\nWe start with \"multi_bookmarkB\" since 'A' is the default (see above).\n"
  },
  {
    "personal_mail_address",
    1,
    CONF_STR_0,
    135981408,
    NULL,
    NULL,
    NULL,
    "personal_mail_address specifies your personal mail address.  The\naddress will be sent during HTTP file transfers for authorization and\nlogging purposes, and for mailed comments.\nIf you do not want this information given out, set the NO_FROM_HEADER\nto TRUE in lynx.cfg, or use the -nofrom command line switch.  You also\ncould leave this field blank, but then you won't have it included in\nyour mailed comments.\n"
  },
  {
    "preferred_charset",
    1,
    CONF_STR_0,
    135981416,
    NULL,
    NULL,
    NULL,
    "preferred_charset specifies the character set in MIME notation (e.g.,\nISO-8859-2, ISO-8859-5) which Lynx will indicate you prefer in requests\nto http servers using an Accept-Charset header.  The value should NOT\ninclude ISO-8859-1 or US-ASCII, since those values are always assumed\nby default.  May be a comma-separated list.\nIf a file in that character set is available, the server will send it.\nIf no Accept-Charset header is present, the default is that any\ncharacter set is acceptable.  If an Accept-Charset header is present,\nand if the server cannot send a response which is acceptable\naccording to the Accept-Charset header, then the server SHOULD send\nan error response, though the sending of an unacceptable response\nis also allowed.\n"
  },
  {
    "preferred_encoding",
    0,
    CONF_ENUM_0,
    135875740,
    NULL,
    &tbl_preferred_encoding,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "preferred_language",
    1,
    CONF_STR_0,
    135981372,
    NULL,
    NULL,
    NULL,
    "preferred_language specifies the language in MIME notation (e.g., en,\nfr, may be a comma-separated list in decreasing preference)\nwhich Lynx will indicate you prefer in requests to http servers.\nIf a file in that language is available, the server will send it.\nOtherwise, the server will send the file in its default language.\n"
  },
  {
    "preferred_media_types",
    0,
    CONF_ENUM_0,
    135875744,
    NULL,
    &tbl_preferred_media,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "raw_mode",
    0,
    CONF_BOOL_0,
    136096460,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "scrollbar",
    0,
    CONF_BOOL_0,
    135971156,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "select_popups",
    1,
    CONF_BOOL_0,
    135875695,
    NULL,
    NULL,
    NULL,
    "select_popups specifies whether the OPTIONs in a SELECT block which\nlacks a MULTIPLE attribute are presented as a vertical list of radio\nbuttons or via a popup menu.  Note that if the MULTIPLE attribute is\npresent in the SELECT start tag, Lynx always will create a vertical list\nof checkboxes for the OPTIONs.  A value of \"on\" will set popup menus\nas the default while a value of \"off\" will set use of radio boxes.\nThe default can be overridden via the -popup command line toggle.\n"
  },
  {
    "set_cookies",
    0,
    CONF_BOOL_0,
    135875696,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "show_color",
    1,
    CONF_ENUM_0,
    135875672,
    NULL,
    &tbl_show_colors,
    NULL,
    "show_color specifies how to set the color mode at startup.  A value of\n\"never\" will force color mode off (treat the terminal as monochrome)\nat startup even if the terminal appears to be color capable.  A value of\n\"always\" will force color mode on even if the terminal appears to be\nmonochrome, if this is supported by the library used to build lynx.\nA value of \"default\" will yield the behavior of assuming\na monochrome terminal unless color capability is inferred at startup\nbased on the terminal type, or the -color command line switch is used, or\nthe COLORTERM environment variable is set.  The default behavior always is\nused in anonymous accounts or if the \"option_save\" restriction is set.\nThe effect of the saved value can be overridden via\nthe -color and -nocolor command line switches.\nThe mode set at startup can be changed via the \"show color\" option in\nthe 'o'ptions menu.  If the option settings are saved, the \"on\" and\n\"off\" \"show color\" settings will be treated as \"default\".\n"
  },
  {
    "show_cursor",
    1,
    CONF_BOOL_0,
    135981091,
    NULL,
    NULL,
    NULL,
    "show_cursor specifies whether to 'hide' the cursor to the right (and\nbottom, if possible) of the screen, or to place it to the left of the\ncurrent link in documents, or current option in select popup windows.\nPositioning the cursor to the left of the current link or option is\nhelpful for speech or braille interfaces, and when the terminal is\none which does not distinguish the current link based on highlighting\nor color.  A value of \"on\" will set positioning to the left as the\ndefault while a value of \"off\" will set 'hiding' of the cursor.\nThe default can be overridden via the -show_cursor command line toggle.\n"
  },
  {
    "show_dotfiles",
    1,
    CONF_BOOL_0,
    135981200,
    NULL,
    NULL,
    NULL,
    "show_dotfiles specifies that the directory listing should include\n\"hidden\" (dot) files/directories.  If set \"on\", this will be\nhonored only if enabled via userdefs.h and/or lynx.cfg, and not\nrestricted via a command line switch.  If display of hidden files\nis disabled, creation of such files via Lynx also is disabled.\n"
  },
  {
    "show_kb_rate",
    0,
    CONF_ENUM_0,
    135875736,
    NULL,
    &tbl_transfer_rate,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "sub_bookmarks",
    1,
    CONF_ENUM_0,
    135981456,
    NULL,
    &tbl_multi_bookmarks,
    NULL,
    "If sub_bookmarks is not turned \"off\", and multiple bookmarks have\nbeen defined (see below), then all bookmark operations will first\nprompt the user to select an active sub-bookmark file.  If the default\nLynx bookmark_file is defined (see above), it will be used as the\ndefault selection.  When this option is set to \"advanced\", and the\nuser mode is advanced, the 'v'iew bookmark command will invoke a\nstatusline prompt instead of the menu seen in novice and intermediate\nuser modes.  When this option is set to \"standard\", the menu will be\npresented regardless of user mode.\n"
  },
  {
    "tagsoup",
    0,
    CONF_FUN_0,
    134945851,
    NULL,
    NULL,
    &put_tagsoup,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "underline_links",
    0,
    CONF_BOOL_0,
    135981092,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "user_mode",
    1,
    CONF_ENUM_0,
    135981124,
    NULL,
    &tbl_user_mode,
    NULL,
    "user_mode specifies the users level of knowledge with Lynx.  The\ndefault is \"NOVICE\" which displays two extra lines of help at the\nbottom of the screen to aid the user in learning the basic Lynx\ncommands.  Set user_mode to \"INTERMEDIATE\" to turn off the extra info.\nUse \"ADVANCED\" to see the URL of the currently selected link at the\nbottom of the screen.\n"
  },
  {
    "useragent",
    0,
    CONF_STR_0,
    135981280,
    NULL,
    NULL,
    NULL,
    "Normally disabled.  See ENABLE_LYNXRC in lynx.cfg\n"
  },
  {
    "verbose_images",
    1,
    CONF_BOOL_0,
    135875682,
    NULL,
    NULL,
    NULL,
    "If verbose_images is \"on\", lynx will print the name of the image\nsource file in place of [INLINE], [LINK] or [IMAGE]\nSee also VERBOSE_IMAGES in lynx.cfg\n"
  },
  {
    "vi_keys",
    1,
    CONF_BOOL_0,
    135981119,
    NULL,
    NULL,
    NULL,
    "If vi_keys is set to \"on\", then the normal VI movement keys:\n  j = down    k = up\n  h = left    l = right\nwill be enabled.  These keys are only lower case.\nCapital 'H', 'J' and 'K will still activate help, jump shortcuts,\nand the keymap display, respectively.\n"
  },
  {
    "visited_links",
    1,
    CONF_ENUM_0,
    135884896,
    NULL,
    &tbl_visited_links,
    NULL,
    "The visited_links setting controls how Lynx organizes the information\nin the Visited Links Page.\n"
  },
  { NULL, 1, CONF_NIL_0, 0, NULL, NULL, NULL, NULL }
}; // idb
char LYValidDownloadFile[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char tempfile_9853[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
LYKeymap_t keymap[661] =
{
  0u,
  69u,
  22u,
  16u,
  0u,
  14u,
  23u,
  15u,
  0u,
  36u,
  31u,
  39u,
  79u,
  21u,
  39u,
  18u,
  0u,
  17u,
  98u,
  12u,
  104u,
  64u,
  38u,
  82u,
  21u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  15u,
  62u,
  77u,
  74u,
  25u,
  0u,
  0u,
  75u,
  19u,
  20u,
  66u,
  15u,
  90u,
  16u,
  89u,
  51u,
  80u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  1u,
  65u,
  32u,
  56u,
  33u,
  43u,
  78u,
  58u,
  16u,
  99u,
  63u,
  83u,
  91u,
  42u,
  43u,
  45u,
  71u,
  72u,
  73u,
  48u,
  52u,
  49u,
  57u,
  14u,
  59u,
  50u,
  95u,
  37u,
  61u,
  0u,
  46u,
  0u,
  47u,
  67u,
  11u,
  68u,
  24u,
  81u,
  76u,
  58u,
  16u,
  54u,
  63u,
  55u,
  91u,
  41u,
  43u,
  45u,
  71u,
  72u,
  73u,
  48u,
  53u,
  49u,
  57u,
  13u,
  59u,
  50u,
  95u,
  37u,
  60u,
  0u,
  46u,
  0u,
  47u,
  100u,
  102u,
  101u,
  105u,
  36u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  26u,
  27u,
  39u,
  37u,
  15u,
  16u,
  22u,
  23u,
  44u,
  39u,
  22u,
  23u,
  17u,
  18u,
  69u,
  30u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  69u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u
}; // idb
LYKeymap_t key_override[661] =
{
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  38u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  95u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  91u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  94u,
  0u,
  0u,
  0u,
  0u,
  93u,
  0u,
  95u,
  96u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  92u,
  0u,
  0u,
  91u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  94u,
  0u,
  0u,
  0u,
  0u,
  93u,
  0u,
  95u,
  96u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  69u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
Kcmd revmap[107] =
{
  { LYK_UNKNOWN_0, "UNMAPPED", NULL },
  { LYK_COMMAND_0, "COMMAND", "prompt for, execute a command" },
  { LYK_1_0, "1", NULL },
  { LYK_2_0, "2", NULL },
  { LYK_3_0, "3", NULL },
  { LYK_4_0, "4", NULL },
  { LYK_5_0, "5", NULL },
  { LYK_6_0, "6", NULL },
  { LYK_7_0, "7", NULL },
  { LYK_8_0, "8", NULL },
  { LYK_9_0, "9", NULL },
  { LYK_SOURCE_0, "SOURCE", "toggle source/presentation for current document" },
  { LYK_RELOAD_0, "RELOAD", "reload the current document" },
  { LYK_QUIT_0, "QUIT", "quit the browser" },
  { LYK_ABORT_0, "ABORT", "quit the browser unconditionally" },
  { LYK_NEXT_PAGE_0, "NEXT_PAGE", "view the next page of the document" },
  { LYK_PREV_PAGE_0, "PREV_PAGE", "view the previous page of the document" },
  { LYK_UP_TWO_0, "UP_TWO", "go back two lines in the document" },
  { LYK_DOWN_TWO_0, "DOWN_TWO", "go forward two lines in the document" },
  { LYK_UP_HALF_0, "UP_HALF", "go back half a page in the document" },
  { LYK_DOWN_HALF_0, "DOWN_HALF", "go forward half a page in the document" },
  { LYK_REFRESH_0, "REFRESH", "refresh the screen to clear garbled text" },
  { LYK_HOME_0, "HOME", "go to the beginning of the current document" },
  { LYK_END_0, "END", "go to the end of the current document" },
  { LYK_FIRST_LINK_0, "FIRST_LINK", "make the first link on the line current" },
  { LYK_LAST_LINK_0, "LAST_LINK", "make the last link on the line current" },
  { LYK_PREV_LINK_0, "PREV_LINK", "make the previous link current" },
  { LYK_NEXT_LINK_0, "NEXT_LINK", "make the next link current" },
  {
    LYK_LPOS_PREV_LINK_0,
    "LPOS_PREV_LINK",
    "make previous link current, same column for input"
  },
  {
    LYK_LPOS_NEXT_LINK_0,
    "LPOS_NEXT_LINK",
    "make next link current, same column for input"
  },
  {
    LYK_FASTBACKW_LINK_0,
    "FASTBACKW_LINK",
    "previous link or text area, only stops on links"
  },
  {
    LYK_FASTFORW_LINK_0,
    "FASTFORW_LINK",
    "next link or text area, only stops on links"
  },
  { LYK_UP_LINK_0, "UP_LINK", "move up the page to a previous link" },
  { LYK_DOWN_LINK_0, "DOWN_LINK", "move down the page to another link" },
  { LYK_RIGHT_LINK_0, "RIGHT_LINK", "move right to another link" },
  { LYK_LEFT_LINK_0, "LEFT_LINK", "move left to a previous link" },
  { LYK_HISTORY_0, "HISTORY", "display stack of currently-suspended documents" },
  { LYK_PREV_DOC_0, "PREV_DOC", "go back to the previous document" },
  { LYK_NEXT_DOC_0, "NEXT_DOC", "undo going back to the previous document" },
  { LYK_ACTIVATE_0, "ACTIVATE", "go to the document given by the current link" },
  { LYK_SUBMIT_0, "MOUSE_SUBMIT", "DO NOT MAP:  follow current link, submit" },
  { LYK_GOTO_0, "GOTO", "go to a document given as a URL" },
  { LYK_ECGOTO_0, "ECGOTO", "edit the current document's URL and go to it" },
  { LYK_HELP_0, "HELP", "display help on using the browser" },
  { LYK_DWIMHELP_0, "DWIMHELP", "display help page that may depend on context" },
  { LYK_INDEX_0, "INDEX", "display an index of potentially useful documents" },
  { LYK_NOCACHE_0, "NOCACHE", "force submission of form or link with no-cache" },
  {
    LYK_INTERRUPT_0,
    "INTERRUPT",
    "interrupt network connection or transmission"
  },
  { LYK_MAIN_MENU_0, "MAIN_MENU", "return to the first screen (home page)" },
  { LYK_OPTIONS_0, "OPTIONS", "display and change option settings" },
  { LYK_INDEX_SEARCH_0, "INDEX_SEARCH", "allow searching of an index" },
  { LYK_WHEREIS_0, "WHEREIS", "search within the current document" },
  { LYK_PREV_0, "PREV", "search for the previous occurence" },
  { LYK_NEXT_0, "NEXT", "search for the next occurence" },
  {
    LYK_COMMENT_0,
    "COMMENT",
    "send a comment to the author of the current document"
  },
  { LYK_EDIT_0, "EDIT", "edit the current document or a form's textarea" },
  { LYK_INFO_0, "INFO", "display information on the current document and link" },
  { LYK_PRINT_0, "PRINT", "display choices for printing the current document" },
  { LYK_ADD_BOOKMARK_0, "ADD_BOOKMARK", "add to your personal bookmark list" },
  {
    LYK_DEL_BOOKMARK_0,
    "DEL_BOOKMARK",
    "delete from your personal bookmark list"
  },
  { LYK_VIEW_BOOKMARK_0, "VIEW_BOOKMARK", "view your personal bookmark list" },
  {
    LYK_VLINKS_0,
    "VLINKS",
    "list links visited during the current Lynx session"
  },
  { LYK_SHELL_0, "SHELL", "escape from the browser to the system" },
  { LYK_DOWNLOAD_0, "DOWNLOAD", "download the current link to your computer" },
  { LYK_TRACE_TOGGLE_0, "TRACE_TOGGLE", "toggle tracing of browser operations" },
  {
    LYK_TRACE_LOG_0,
    "TRACE_LOG",
    "view trace log if started in the current session"
  },
  {
    LYK_IMAGE_TOGGLE_0,
    "IMAGE_TOGGLE",
    "toggle handling of all images as links"
  },
  {
    LYK_INLINE_TOGGLE_0,
    "INLINE_TOGGLE",
    "toggle pseudo-ALTs for inlines with no ALT string"
  },
  { LYK_HEAD_0, "HEAD", "send a HEAD request for the current document or link" },
  { LYK_DO_NOTHING_0, "DO_NOTHING", NULL },
  {
    LYK_TOGGLE_HELP_0,
    "TOGGLE_HELP",
    "show other commands in the novice help menu"
  },
  { LYK_JUMP_0, "JUMP", "go directly to a target document or action" },
  { LYK_KEYMAP_0, "KEYMAP", "display the current key map" },
  { LYK_LIST_0, "LIST", "list the references (links) in the current document" },
  {
    LYK_TOOLBAR_0,
    "TOOLBAR",
    "go to Toolbar or Banner in the current document"
  },
  {
    LYK_HISTORICAL_0,
    "HISTORICAL",
    "toggle historical vs.  valid/minimal comment parsing"
  },
  { LYK_MINIMAL_0, "MINIMAL", "toggle minimal vs.  valid comment parsing" },
  {
    LYK_SOFT_DQUOTES_0,
    "SOFT_DQUOTES",
    "toggle valid vs.  soft double-quote parsing"
  },
  {
    LYK_RAW_TOGGLE_0,
    "RAW_TOGGLE",
    "toggle raw 8-bit translations or CJK mode ON or OFF"
  },
  { LYK_COOKIE_JAR_0, "COOKIE_JAR", "examine the Cookie Jar" },
  {
    LYK_F_LINK_NUM_0,
    "F_LINK_NUM",
    "invoke the 'Follow link (or page) number:' prompt"
  },
  {
    LYK_CLEAR_AUTH_0,
    "CLEAR_AUTH",
    "clear all authorization info for this session"
  },
  { LYK_SWITCH_DTD_0, "SWITCH_DTD", "switch between two ways of parsing HTML" },
  {
    LYK_ELGOTO_0,
    "ELGOTO",
    "edit the current link's URL or ACTION and go to it"
  },
  {
    LYK_CHANGE_LINK_0,
    "CHANGE_LINK",
    "force reset of the current link on the page"
  },
  {
    LYK_DWIMEDIT_0,
    "DWIMEDIT",
    "use external editor for context-dependent purpose"
  },
  {
    LYK_EDIT_TEXTAREA_0,
    "EDITTEXTAREA",
    "use an external editor to edit a form's textarea"
  },
  {
    LYK_GROW_TEXTAREA_0,
    "GROWTEXTAREA",
    "add 5 new blank lines to the bottom of a textarea"
  },
  {
    LYK_INSERT_FILE_0,
    "INSERTFILE",
    "insert file into a textarea (just above cursorline)"
  },
  { LYK_EXTERN_LINK_0, "EXTERN_LINK", "run external program with current link" },
  { LYK_EXTERN_PAGE_0, "EXTERN_PAGE", "run external program with current page" },
  { LYK_DIRED_MENU_0, "DIRED_MENU", "display a full menu of file operations" },
  { LYK_CREATE_0, "CREATE", "create a new file or directory" },
  { LYK_REMOVE_0, "REMOVE", "remove a file or directory" },
  {
    LYK_MODIFY_0,
    "MODIFY",
    "modify the name or location of a file or directory"
  },
  { LYK_TAG_LINK_0, "TAG_LINK", "tag a file or directory for later action" },
  {
    LYK_UPLOAD_0,
    "UPLOAD",
    "upload from your computer to the current directory"
  },
  {
    LYK_INSTALL_0,
    "INSTALL",
    "install file or tagged files into a system area"
  },
  { LYK_CHG_CENTER_0, "CHANGE_CENTER", "toggle center alignment in HTML TABLE" },
  { LYK_CHDIR_0, "CHDIR", "change current directory" },
  { LYK_SHIFT_LEFT_0, "SHIFT_LEFT", "shift the screen left" },
  { LYK_SHIFT_RIGHT_0, "SHIFT_RIGHT", "shift the screen right" },
  { LYK_LINEWRAP_TOGGLE_0, "LINEWRAP_TOGGLE", "toggle linewrap on/off" },
  { LYK_PASTE_URL_0, "PASTE_URL", "Goto the URL in the clipboard" },
  { LYK_TO_CLIPBOARD_0, "TO_CLIPBOARD", "link's URL to Clip Board" },
  { LYK_NESTED_TABLES_0, "NESTED_TABLES", "toggle nested-table parsing on/off" },
  { LYK_UNKNOWN_0, NULL, &byte_81646F7 }
}; // idb
emap ekmap[37] =
{
  { &unk_81648A0, 0, "Do Nothing" },
  { "CHAR", 1, "Insert printable char" },
  { "ENTER", 2, "Input complete, return char/lynxkeycode" },
  { "TAB", 3, "Input complete, return TAB" },
  { "STOP", 4, "Input deactivated" },
  { "ABORT", 5, "Input cancelled" },
  { "PASS", 6, "In fields: input complete, or Do Nothing" },
  { "DELN", 7, "Delete next/curr char" },
  { "DELP", 9, "Delete prev      char" },
  { "DELNW", 10, "Delete next word" },
  { "DELPW", 11, "Delete prev word" },
  { "ERASE", 12, "Erase the line" },
  { "BOL", 13, "Go to begin of line" },
  { "EOL", 14, "Go to end   of line" },
  { "FORW", 15, "Cursor forwards" },
  { "FORW_RL", 16, "Cursor forwards or right link" },
  { "BACK", 17, "Cursor backwards" },
  { "BACK_LL", 18, "Cursor backwards or left link" },
  { "FORWW", 19, "Word forward" },
  { "BACKW", 20, "Word back" },
  { "LOWER", 21, "Lower case the line" },
  { "UPPER", 22, "Upper case the line" },
  { "LKCMD", 23, "Invoke command prompt" },
  { "AIX", 24, "Hex 97" },
  { "DELBL", 25, "Delete back to BOL" },
  { "DELEL", 26, "Delete thru EOL" },
  { "SWMAP", 27, "Switch input keymap" },
  { "TPOS", 28, "Transpose characters" },
  { "SETM1", 29, "Set modifier 1 flag" },
  { "SETM2", 30, "Set modifier 2 flag" },
  { "UNMOD", 31, "Fall back to no-modifier command" },
  { "C1CHAR", 32, "Insert C1 char if printable" },
  { "SETMARK", 33, "emacs-like set-mark-command" },
  { "XPMARK", 34, "emacs-like exchange-point-and-mark" },
  { "KILLREG", 35, "emacs-like kill-region" },
  { "YANK", 36, "emacs-like yank" },
  { "PASTE", 37, "ClipBoard to Lynx" }
}; // idb
HTProtocol LYLynxKeymap = { "LYNXKEYMAP", &LYLoadKeymap, NULL }; // idb
ANY_KEYS vms_keys_table[2] = { { 26, 14u, 0u }, { 36, 62u, 0u } }; // idb
ANY_KEYS vi_keys_table[4] = { { 104, 37u, 0u }, { 106, 27u, 0u }, { 107, 26u, 0u }, { 108, 39u, 0u } }; // idb
ANY_KEYS emacs_keys_table[4] = { { 2, 37u, 0u }, { 14, 27u, 0u }, { 16, 26u, 0u }, { 6, 39u, 0u } }; // idb
ANY_KEYS number_keys_table[9] =
{
  { 49, 23u, 0u },
  { 50, 27u, 0u },
  { 51, 15u, 0u },
  { 52, 37u, 0u },
  { 53, 69u, 0u },
  { 54, 39u, 0u },
  { 55, 22u, 0u },
  { 56, 26u, 0u },
  { 57, 16u, 0u }
}; // idb
const char *LYToolbarName = "LynxPseudoToolbar"; // idb
int reverse_mailcap = 1; // idb
HTStyleSheet sheet = { "default.style", &HTStyleHeadingRight }; // idb
BOOLEAN last_titles_10557 = '\x01'; // idb
BOOLEAN first_time_11222 = '\x01'; // idb
HTProtocol LYLynxCGI = { "lynxcgi", &LYLoadCGI, NULL }; // idb
__int16 Mod1Binding[274] =
{
  0,
  13,
  20,
  31,
  4123,
  4182,
  19,
  5,
  11,
  31,
  2,
  4125,
  6,
  2,
  19,
  31,
  20,
  0,
  20,
  0,
  0,
  6,
  0,
  35,
  34,
  31,
  6,
  0,
  6,
  6,
  31,
  0,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  6,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  4118,
  31,
  4119,
  31,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  32,
  31,
  13,
  20,
  31,
  10,
  4182,
  19,
  4183,
  1,
  4184,
  1,
  12,
  21,
  1,
  6,
  31,
  1,
  0,
  0,
  0,
  0,
  22,
  0,
  0,
  0,
  0,
  31,
  31,
  31,
  31,
  31,
  11,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  31,
  6,
  6,
  4140,
  31,
  4147,
  4149,
  31,
  0,
  31,
  31,
  31,
  31
}; // idb
__int16 *Mod2Binding = &Mod1Binding; // idb
__int16 *Mod3Binding = &Mod1Binding; // idb
LYEditCode *LYLineEditors[3] = { &DefaultEditBinding, &BetterEditBinding, &BashlikeEditBinding }; // idb
const char *LYLineeditNames[4] = { "Default Binding", "Alternate Bindings", "Bash-like Bindings", NULL }; // idb
const char *LYLineeditHelpURLs[4] =
{
  "keystrokes/edit_help.html.gz",
  "keystrokes/alt_edit_help.html.gz.gz",
  "keystrokes/bashlike_edit_help.html.gz.gz",
  NULL
}; // idb
BOOLEAN DisplayCharsetMatchLocale = '\x01'; // idb
int current_char_set = -1; // idb
int linedrawing_char_set = -1; // idb
const char *SevenBitApproximations[112] =
{
  &unk_81696F1,
  &unk_81696F4,
  &unk_81696F4,
  &unk_81696F4,
  &unk_81696F4,
  &unk_81696F4,
  &unk_81696F6,
  &unk_81696F9,
  &unk_81696FB,
  &unk_81696FE,
  &unk_8169701,
  &unk_8169701,
  &unk_8169701,
  &unk_8169701,
  &unk_8169703,
  &unk_8169703,
  &unk_8169703,
  &unk_8169703,
  &unk_8169705,
  &unk_8169707,
  &unk_8169707,
  &unk_8169707,
  &unk_8169707,
  &unk_8169707,
  &unk_8169709,
  &unk_816970C,
  &unk_816970E,
  &unk_816970E,
  &unk_816970E,
  &unk_8169710,
  &unk_8169713,
  &unk_8169715,
  &unk_8169715,
  &unk_8169717,
  &unk_8169719,
  &unk_816971C,
  &unk_8169666,
  &unk_8169715,
  &unk_8169715,
  &unk_8169719,
  &unk_816971F,
  &unk_816971F,
  &unk_8169721,
  &unk_8169723,
  &unk_8169725,
  &unk_8169729,
  &unk_816972D,
  &unk_8169731,
  &unk_81696C8,
  &unk_8169735,
  &unk_8169737,
  &unk_8169737,
  &unk_8169737,
  &unk_8169686,
  &unk_8169688,
  &unk_8169686,
  &unk_8169688,
  &unk_8169739,
  &unk_8169737,
  " 1/2",
  " 1/4",
  " 3/4",
  &unk_8169694,
  &unk_8169686,
  "i",
  "i",
  "!",
  "`i",
  "?",
  "i",
  "<<",
  &unk_81696A6,
  &unk_8169686,
  &unk_8169686,
  "u",
  ".",
  &unk_81696AC,
  &unk_8169686,
  "NOT",
  "n",
  "o",
  "o",
  "o",
  "-a",
  "-o",
  "o",
  "o",
  "oe",
  "P:",
  "+-",
  "-L-",
  &unk_81696C8,
  ">>",
  "(R)",
  "S:",
  &unk_81696D0,
  "^1",
  "^2",
  "^3",
  "ss",
  &unk_8169688,
  "p",
  "*",
  "(TM)",
  "u",
  "u",
  "u",
  &unk_81696C8,
  "ue",
  "y",
  "YEN",
  "y"
}; // idb
const char **LYCharSets[60] =
{
  &ISO_Latin1,
  &SevenBitApproximations,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
const char *LYchar_set_names[61] =
{
  "Western (ISO-8859-1)",
  "7 bit approximations (US-ASCII)",
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // idb
LYUCcharset LYCharSet_UC[60] =
{
  { -1, "iso-8859-1", 1, 0, 3, 3, 432, 432 },
  { -1, "us-ascii", 0, 0, 1, 1, 48, 48 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 },
  { 0, NULL, 0, 0, 0, 0, 0, 0 }
}; // idb
int LYlowest_eightbit[60] =
{
  160,
  999,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
const char *LYEntityNames[96] =
{
  "nbsp",
  "iexcl",
  "cent",
  "pound",
  "curren",
  "yen",
  "brvbar",
  "sect",
  "uml",
  "copy",
  "ordf",
  "laquo",
  "not",
  "shy",
  "reg",
  "hibar",
  "deg",
  "plusmn",
  "sup2",
  "sup3",
  "acute",
  "micro",
  "para",
  "middot",
  "cedil",
  "sup1",
  "ordm",
  "raquo",
  "frac14",
  "frac12",
  "frac34",
  "iquest",
  "Agrave",
  "Aacute",
  "Acirc",
  "Atilde",
  "Auml",
  "Aring",
  "AElig",
  "Ccedil",
  "Egrave",
  "Eacute",
  "Ecirc",
  "Euml",
  "Igrave",
  "Iacute",
  "Icirc",
  "Iuml",
  "ETH",
  "Ntilde",
  "Ograve",
  "Oacute",
  "Ocirc",
  "Otilde",
  "Ouml",
  "times",
  "Oslash",
  "Ugrave",
  "Uacute",
  "Ucirc",
  "Uuml",
  "Yacute",
  "THORN",
  "szlig",
  "agrave",
  "aacute",
  "acirc",
  "atilde",
  "auml",
  "aring",
  "aelig",
  "ccedil",
  "egrave",
  "eacute",
  "ecirc",
  "euml",
  "igrave",
  "iacute",
  "icirc",
  "iuml",
  "eth",
  "ntilde",
  "ograve",
  "oacute",
  "ocirc",
  "otilde",
  "ouml",
  "divide",
  "oslash",
  "ugrave",
  "uacute",
  "ucirc",
  "uuml",
  "yacute",
  "thorn",
  "yuml"
}; // idb
int OL_VOID = -29998; // idb
const char *hex = "0123456789ABCDEF"; // idb
HTProtocol LYLynxIMGmap = { "LYNXIMGMAP", &LYLoadIMGmap, NULL }; // idb
LYLoadCookies::$FA2974897CD56D4CB1D8823F595C8EE6 tok_values_13111[8] =
{
  { &domain_13101, 256u },
  { &what_13105, 8u },
  { &path_13102, 256u },
  { &secure_13106, 8u },
  { &expires_a_13107, 16u },
  { &name_13103, 256u },
  { &value_13104, 4100u },
  { NULL, 0u }
}; // idb
HTProtocol LYLynxCookies = { "LYNXCOOKIE", &LYHandleCookies, NULL }; // idb
bucket nostyle_bucket = { "<NOSTYLE>", 0, 0, 0, 0, NULL }; // idb
int s_a = -1; // idb
int s_aedit = -1; // idb
int s_aedit_arr = -1; // idb
int s_aedit_pad = -1; // idb
int s_aedit_sel = -1; // idb
int s_alert = -1; // idb
int s_alink = -1; // idb
int s_curedit = -1; // idb
int s_forw_backw = -1; // idb
int s_hot_paste = -1; // idb
int s_menu_active = -1; // idb
int s_menu_bg = -1; // idb
int s_menu_entry = -1; // idb
int s_menu_frame = -1; // idb
int s_menu_number = -1; // idb
int s_menu_sb = -1; // idb
unsigned int s_normal = 4294967295u; // idb
int s_prompt_edit = -1; // idb
int s_prompt_edit_arr = -1; // idb
int s_prompt_edit_pad = -1; // idb
int s_prompt_sel = -1; // idb
int s_status = -1; // idb
int s_title = -1; // idb
int s_whereis = -1; // idb
int s_sb_aa = -1; // idb
int s_sb_bar = -1; // idb
int s_sb_bg = -1; // idb
int s_sb_naa = -1; // idb
parse_style::$10A5D14B04C31CD10E83E4EE953226EA table_10468[27] =
{
  { "default", -1, NULL },
  { "alink", 127, NULL },
  { "a", 8, NULL },
  { "a", 0, NULL },
  { "status", 126, NULL },
  { "label", 129, NULL },
  { "value", 130, NULL },
  { "normal", 128, NULL },
  { "candy", 131, NULL },
  { "whereis", 132, &s_whereis },
  { "edit.active.pad", 133, &s_aedit_pad },
  { "edit.active.arrow", 133, &s_aedit_arr },
  { "edit.active.marked", 133, &s_aedit_sel },
  { "edit.active", 133, &s_aedit },
  { "edit.current", 133, &s_curedit },
  { "edit.prompt.pad", 133, &s_prompt_edit_pad },
  { "edit.prompt.arrow", 133, &s_prompt_edit_arr },
  { "edit.prompt.marked", 133, &s_prompt_sel },
  { "edit.prompt", 133, &s_prompt_edit },
  { "forwbackw.arrow", 133, &s_forw_backw },
  { "hot.paste", 133, &s_hot_paste },
  { "menu.frame", 133, &s_menu_frame },
  { "menu.bg", 133, &s_menu_bg },
  { "menu.n", 133, &s_menu_number },
  { "menu.entry", 133, &s_menu_entry },
  { "menu.active", 133, &s_menu_active },
  { "menu.sb", 133, &s_menu_sb }
}; // idb
int firsttime_10655 = 1; // idb
const char *HTL_tagspecs_defaults[12] =
{
  "span.htmlsrc_comment:!span",
  "span.htmlsrc_tag:!span",
  "span.htmlsrc_attrib:!span",
  "span.htmlsrc_attrval:!span",
  "span.htmlsrc_abracket:!span",
  "span.htmlsrc_entity:!span",
  "span.htmlsrc_href:!span",
  "span.htmlsrc_entire:!span",
  "span.htmlsrc_badseq:!span",
  "span.htmlsrc_badtag:!span",
  "span.htmlsrc_badattr:!span",
  "span.htmlsrc_sgmlspecial:!span"
}; // idb
int tagname_transform = 2; // idb
int attrname_transform = 2; // idb
unipair_str repl_map[2610] =
{
  { 161u, &unk_8174630 },
  { 162u, &unk_8174632 },
  { 163u, &unk_8174636 },
  { 164u, &unk_817463A },
  { 165u, &unk_817463E },
  { 166u, &unk_8174642 },
  { 167u, &unk_8174644 },
  { 168u, &unk_8174647 },
  { 169u, &unk_8174649 },
  { 170u, &unk_817464D },
  { 171u, &unk_8174650 },
  { 172u, &unk_8174653 },
  { 174u, &unk_8174657 },
  { 175u, &unk_817465B },
  { 176u, &unk_817465D },
  { 177u, &unk_8174661 },
  { 178u, &unk_8174664 },
  { 179u, &unk_8174667 },
  { 180u, &unk_817466A },
  { 181u, &unk_817466C },
  { 182u, &unk_817466E },
  { 183u, &unk_8174671 },
  { 184u, &unk_8174673 },
  { 185u, &unk_8174675 },
  { 186u, &unk_8174678 },
  { 187u, &unk_817467B },
  { 188u, " 1/4" },
  { 189u, " 1/2" },
  { 190u, " 3/4" },
  { 191u, "?" },
  { 196u, "Ae" },
  { 197u, "AA" },
  { 198u, "AE" },
  { 199u, "C," },
  { 208u, "D-" },
  { 214u, "Oe" },
  { 215u, " *" },
  { 216u, "O/" },
  { 220u, "Ue" },
  { 222u, "TH" },
  { 223u, "ss" },
  { 224u, "`a" },
  { 228u, "ae" },
  { 229u, "aa" },
  { 230u, "ae" },
  { 231u, "c," },
  { 236u, "`i" },
  { 240u, "d-" },
  { 246u, "oe" },
  { 247u, "-:" },
  { 248u, "o/" },
  { 252u, "ue" },
  { 254u, "th" },
  { 272u, "D/" },
  { 273u, "d/" },
  { 294u, "H/" },
  { 306u, "IJ" },
  { 307u, "ij" },
  { 312u, "kk" },
  { 319u, "L." },
  { 320u, "l." },
  { 321u, "L/" },
  { 322u, "l/" },
  { 329u, "'n" },
  { 330u, "NG" },
  { 336u, "O\"" },
  { 337u, "o\"" },
  { 338u, "OE" },
  { 339u, "oe" },
  { 358u, "T/" },
  { 359u, "t/" },
  { 368u, "U\"" },
  { 369u, "u\"" },
  { 383u, "s1" },
  { 391u, "C2" },
  { 392u, "c2" },
  { 401u, "F2" },
  { 402u, " f" },
  { 408u, "K2" },
  { 409u, "k2" },
  { 416u, "O9" },
  { 417u, "o9" },
  { 418u, "OI" },
  { 419u, "oi" },
  { 422u, "yr" },
  { 431u, "U9" },
  { 432u, "u9" },
  { 437u, "Z/" },
  { 438u, "z/" },
  { 439u, "ED" },
  { 469u, "U:-" },
  { 470u, "u:-" },
  { 471u, "U:'" },
  { 472u, "u:'" },
  { 473u, "U:<" },
  { 474u, "u:<" },
  { 475u, "U:!" },
  { 476u, "u:!" },
  { 478u, "A1" },
  { 479u, "a1" },
  { 480u, "A7" },
  { 481u, "a7" },
  { 482u, "A3" },
  { 483u, "a3" },
  { 484u, "G/" },
  { 485u, "g/" },
  { 492u, "O1" },
  { 493u, "o1" },
  { 494u, "EZ" },
  { 495u, "ez" },
  { 506u, "AA'" },
  { 507u, "aa'" },
  { 508u, "AE'" },
  { 509u, "ae'" },
  { 510u, "O/'" },
  { 511u, "o/'" },
  { 512u, "A!!" },
  { 513u, "a!!" },
  { 514u, "A)" },
  { 515u, "a)" },
  { 516u, "E!!" },
  { 517u, "e!!" },
  { 518u, "E)" },
  { 519u, "e)" },
  { 520u, "I!!" },
  { 521u, "i!!" },
  { 522u, "I)" },
  { 523u, "i)" },
  { 524u, "O!!" },
  { 525u, "o!!" },
  { 526u, "O)" },
  { 527u, "o)" },
  { 528u, "R!!" },
  { 529u, "r!!" },
  { 530u, "R)" },
  { 531u, "r)" },
  { 532u, "U!!" },
  { 533u, "u!!" },
  { 534u, "U)" },
  { 535u, "u)" },
  { 594u, "A." },
  { 595u, "b`" },
  { 598u, "d." },
  { 599u, "d`" },
  { 600u, "@<umd>" },
  { 604u, "V\"" },
  { 605u, "R<umd>" },
  { 606u, "O\"" },
  { 608u, "g`" },
  { 612u, "o-" },
  { 613u, "j<rnd>" },
  { 614u, "h<?>" },
  { 616u, "i\"" },
  { 621u, "l." },
  { 622u, "z<lat>" },
  { 623u, "u-" },
  { 624u, "j<vel>" },
  { 627u, "n." },
  { 628u, "n\"" },
  { 629u, "@." },
  { 630u, "&." },
  { 634u, "*<lat>" },
  { 635u, "r." },
  { 637u, "*." },
  { 640u, "r\"" },
  { 641u, "g\"" },
  { 642u, "s." },
  { 644u, "J`" },
  { 647u, "t!" },
  { 648u, "t." },
  { 649u, "u\"" },
  { 651u, "r<lbd>" },
  { 653u, "w<vls>" },
  { 654u, "l^" },
  { 655u, "I." },
  { 656u, "z." },
  { 658u, "Z" },
  { 661u, "H<vcd>" },
  { 662u, "l!" },
  { 663u, "c!" },
  { 664u, "p!" },
  { 665u, "b<trl>" },
  { 667u, "G`" },
  { 670u, "k!" },
  { 672u, "q`" },
  { 676u, "d3" },
  { 678u, "ts" },
  { 679u, "tS" },
  { 688u, "<h>" },
  { 689u, "<?>" },
  { 691u, "<r>" },
  { 695u, "<w>" },
  { 699u, ";S" },
  { 710u, "^" },
  { 711u, "'<" },
  { 712u, &unk_8174642 },
  { 713u, "1-" },
  { 715u, "1!" },
  { 721u, ":\\" },
  { 728u, "'(" },
  { 729u, "'." },
  { 730u, "'0" },
  { 731u, "';" },
  { 732u, "~" },
  { 733u, "'\"" },
  { 741u, "_T" },
  { 742u, "_H" },
  { 743u, "_M" },
  { 744u, "_L" },
  { 745u, "_B" },
  { 748u, "_v" },
  { 750u, "''" },
  { 779u, "''" },
  { 782u, "||" },
  { 783u, "``" },
  { 804u, "<?>" },
  { 805u, "<o>" },
  { 811u, "<w>" },
  { 820u, "<H>" },
  { 832u, "`" },
  { 833u, &unk_817466A },
  { 834u, "~" },
  { 836u, "'%" },
  { 837u, "j3" },
  { 839u, "=" },
  { 864u, "~~" },
  { 884u, &unk_817466A },
  { 885u, &unk_8174673 },
  { 890u, "j3" },
  { 894u, "?%" },
  { 900u, "'*" },
  { 901u, "'%" },
  { 902u, "A'" },
  { 903u, ".*" },
  { 904u, "E'" },
  { 905u, "Y%" },
  { 906u, "I'" },
  { 908u, "O'" },
  { 910u, "U%" },
  { 911u, "W%" },
  { 912u, "i3" },
  {
    913u,
    "A\x00B\x00G\x00D\x00E\x00Y\x00I\x00K\x00L\x00M\x00N\x00C\x00O\x00P\x00R\x00S\x00T\x00U\x00F\x00X\x00Q"
  },
  { 914u, (const char *)0x8174922 },
  { 915u, (const char *)0x8174924 },
  { 916u, (const char *)0x8174926 },
  { 917u, (const char *)0x8174928 },
  { 918u, "Z" },
  { 919u, (const char *)0x817492A },
  { 920u, "TH" },
  { 921u, (const char *)0x817492C },
  { 922u, (const char *)0x817492E },
  { 923u, (const char *)0x8174930 },
  { 924u, (const char *)0x8174932 },
  { 925u, (const char *)0x8174934 },
  { 926u, (const char *)0x8174936 },
  { 927u, (const char *)0x8174938 },
  { 928u, (const char *)0x817493A },
  { 929u, (const char *)0x817493C },
  { 931u, (const char *)0x817493E },
  { 932u, (const char *)0x8174940 },
  { 933u, (const char *)0x8174942 },
  { 934u, (const char *)0x8174944 },
  { 935u, (const char *)0x8174946 },
  { 936u, (const char *)0x8174948 },
  { 937u, "W*" },
  { 938u, "J" },
  { 939u, "V*" },
  { 940u, "a'" },
  { 941u, "e'" },
  { 942u, "y%" },
  { 943u, "i'" },
  { 944u, "u3" },
  { 945u, "a" },
  { 946u, "b" },
  { 947u, "g" },
  { 948u, "d" },
  { 949u, "e" },
  { 950u, "z" },
  { 951u, "y" },
  { 952u, "th" },
  { 953u, "i" },
  { 954u, "k" },
  { 955u, "l" },
  { 956u, "m" },
  { 957u, "n" },
  { 958u, "c" },
  { 959u, "o" },
  { 960u, "p" },
  { 961u, "r" },
  { 962u, "*s" },
  { 963u, "s\x00t\x00f\x00x\x00q\x00w\x00j" },
  { 964u, (const char *)0x8174986 },
  { 965u, &unk_817466C },
  { 966u, (const char *)0x8174988 },
  { 967u, (const char *)0x817498A },
  { 968u, (const char *)0x817498C },
  { 969u, (const char *)0x817498E },
  { 970u, (const char *)0x8174990 },
  { 971u, "v*" },
  { 972u, "o'" },
  { 973u, "u%" },
  { 974u, "w%" },
  { 976u, "beta " },
  { 977u, "theta " },
  { 978u, "upsi " },
  { 981u, "phi " },
  { 982u, "pi " },
  { 983u, "k." },
  { 986u, "T3" },
  { 987u, "t3" },
  { 988u, "M3" },
  { 989u, "m3" },
  { 990u, "K3" },
  { 991u, "k3" },
  { 992u, "P3" },
  { 993u, "p3" },
  { 1008u, "kappa " },
  { 1009u, "rho " },
  { 1011u, "J" },
  { 1012u, "'%" },
  { 1013u, "j3" },
  { 1026u, "D%" },
  { 1027u, "G%" },
  { 1028u, "IE" },
  { 1029u, "DS" },
  { 1030u, "II" },
  { 1031u, "YI" },
  { 1032u, "J%" },
  { 1033u, "LJ" },
  { 1034u, "NJ" },
  { 1035u, "Ts" },
  { 1036u, "KJ" },
  { 1038u, "V%" },
  { 1039u, "DZ" },
  { 1025u, "IO" },
  {
    1040u,
    "A\x00B\x00G\x00D\x00E\x00Y\x00I\x00K\x00L\x00M\x00N\x00C\x00O\x00P\x00R\x00S\x00T\x00U\x00F\x00X\x00Q"
  },
  { 1041u, (const char *)0x8174922 },
  { 1042u, "V" },
  { 1043u, (const char *)0x8174924 },
  { 1044u, (const char *)0x8174926 },
  { 1045u, (const char *)0x8174928 },
  { 1046u, "ZH" },
  { 1047u, "Z" },
  { 1048u, (const char *)0x817492C },
  { 1049u, "J" },
  { 1050u, (const char *)0x817492E },
  { 1051u, (const char *)0x8174930 },
  { 1052u, (const char *)0x8174932 },
  { 1053u, (const char *)0x8174934 },
  { 1054u, (const char *)0x8174938 },
  { 1055u, (const char *)0x817493A },
  { 1056u, (const char *)0x817493C },
  { 1057u, (const char *)0x817493E },
  { 1058u, (const char *)0x8174940 },
  { 1059u, (const char *)0x8174942 },
  { 1060u, (const char *)0x8174944 },
  { 1061u, "H" },
  { 1062u, (const char *)0x8174936 },
  { 1063u, "CH" },
  { 1064u, "SH" },
  { 1065u, "SCH" },
  { 1066u, &unk_8174647 },
  { 1067u, (const char *)0x817492A },
  { 1068u, &unk_817466A },
  { 1069u, "`E" },
  { 1070u, "YU" },
  { 1071u, "YA" },
  { 1072u, "a" },
  { 1073u, "b" },
  { 1074u, "v" },
  { 1075u, "g" },
  { 1076u, "d" },
  { 1077u, "e" },
  { 1078u, "zh" },
  { 1079u, "z" },
  { 1080u, "i" },
  { 1081u, (const char *)0x8174990 },
  { 1082u, "k" },
  { 1083u, "l" },
  { 1084u, "m" },
  { 1085u, "n" },
  { 1086u, "o" },
  { 1087u, "p" },
  { 1088u, "r" },
  { 1089u, "s\x00t\x00f\x00x\x00q\x00w\x00j" },
  { 1090u, (const char *)0x8174986 },
  { 1091u, &unk_817466C },
  { 1092u, (const char *)0x8174988 },
  { 1093u, "h" },
  { 1094u, "c" },
  { 1095u, "ch" },
  { 1096u, "sh" },
  { 1097u, "sch" },
  { 1098u, &unk_8174647 },
  { 1099u, "y" },
  { 1100u, &unk_817466A },
  { 1101u, "`e" },
  { 1102u, "yu" },
  { 1103u, "ya" },
  { 1105u, "io" },
  { 1106u, "d%" },
  { 1107u, "g%" },
  { 1108u, "ie" },
  { 1109u, "ds" },
  { 1110u, "ii" },
  { 1111u, "yi" },
  { 1112u, "j%" },
  { 1113u, "lj" },
  { 1114u, "nj" },
  { 1115u, "ts" },
  { 1116u, "kj" },
  { 1118u, "v%" },
  { 1119u, "dz" },
  { 1122u, "Y3" },
  { 1123u, "y3" },
  { 1130u, "O3" },
  { 1131u, "o3" },
  { 1138u, "F3" },
  { 1139u, "f3" },
  { 1140u, "V3" },
  { 1141u, "v3" },
  { 1152u, "C3" },
  { 1153u, "c3" },
  { 1168u, "G3" },
  { 1169u, "g3" },
  { 1236u, "AE" },
  { 1237u, "ae" },
  { 1521u, "oy" },
  { 1522u, "ey" },
  { 1489u, "B+" },
  { 1490u, "G+" },
  { 1491u, "D+" },
  { 1492u, "H+" },
  { 1493u, "W+" },
  { 1494u, "Z+" },
  { 1495u, "X+" },
  { 1496u, "Tj" },
  { 1497u, "J+" },
  { 1498u, "K%" },
  { 1499u, "K+" },
  { 1500u, "L+" },
  { 1501u, "M%" },
  { 1502u, "M+" },
  { 1503u, "N%" },
  { 1504u, "N+" },
  { 1505u, "S+" },
  { 1506u, "E+" },
  { 1507u, "P%" },
  { 1508u, "P+" },
  { 1509u, "Zj" },
  { 1510u, "ZJ" },
  { 1511u, "Q+" },
  { 1512u, "R+" },
  { 1513u, "Sh" },
  { 1514u, "T+" },
  { 1548u, ",+" },
  { 1563u, ";+" },
  { 1567u, "?+" },
  { 1569u, "H'" },
  { 1570u, "aM" },
  { 1571u, "aH" },
  { 1572u, "wH" },
  { 1573u, "ah" },
  { 1574u, "yH" },
  { 1575u, "a+" },
  { 1576u, "b+" },
  { 1577u, "tm" },
  { 1578u, "t+" },
  { 1579u, "tk" },
  { 1580u, "g+" },
  { 1581u, "hk" },
  { 1582u, "x+" },
  { 1583u, "d+" },
  { 1584u, "dk" },
  { 1585u, "r+" },
  { 1586u, "z+" },
  { 1587u, "s+" },
  { 1588u, "sn" },
  { 1589u, "c+" },
  { 1590u, "dd" },
  { 1591u, "tj" },
  { 1592u, "zH" },
  { 1593u, "e+" },
  { 1594u, "i+" },
  { 1600u, "++" },
  { 1601u, "f+" },
  { 1602u, "q+" },
  { 1603u, "k+" },
  { 1604u, "l+" },
  { 1605u, "m+" },
  { 1606u, "n+" },
  { 1607u, "h+" },
  { 1608u, "w+" },
  { 1609u, "j+" },
  { 1610u, "y+" },
  { 1611u, ":+" },
  { 1612u, "\"+" },
  { 1613u, "=+" },
  { 1614u, "/+" },
  { 1615u, "'+" },
  { 1616u, "1+" },
  { 1617u, "3+" },
  { 1618u, "0+" },
  { 1632u, "0a" },
  { 1633u, "1a" },
  { 1634u, "2a" },
  { 1635u, "3a" },
  { 1636u, "4a" },
  { 1637u, "5a" },
  { 1638u, "6a" },
  { 1639u, "7a" },
  { 1640u, "8a" },
  { 1641u, "9a" },
  { 1648u, "aS" },
  { 1662u, "p+" },
  { 1665u, "hH" },
  { 1670u, "tc" },
  { 1688u, "zj" },
  { 1700u, "v+" },
  { 1711u, "gf" },
  { 1776u, "0a" },
  { 1777u, "1a" },
  { 1778u, "2a" },
  { 1779u, "3a" },
  { 1780u, "4a" },
  { 1781u, "5a" },
  { 1782u, "6a" },
  { 1783u, "7a" },
  { 1784u, "8a" },
  { 1785u, "9a" },
  { 4608u, "he" },
  { 4609u, "hu" },
  { 4610u, "hi" },
  { 4611u, "ha" },
  { 4612u, "hE" },
  { 4614u, "ho" },
  { 4616u, "le" },
  { 4617u, "lu" },
  { 4618u, "li" },
  { 4619u, "la" },
  { 4620u, "lE" },
  { 4622u, "lo" },
  { 4623u, "lWa" },
  { 4624u, "He" },
  { 4625u, "Hu" },
  { 4626u, "Hi" },
  { 4627u, "Ha" },
  { 4628u, "HE" },
  { 4630u, "Ho" },
  { 4631u, "HWa" },
  { 4632u, "me" },
  { 4633u, "mu" },
  { 4634u, "mi" },
  { 4635u, "ma" },
  { 4636u, "mE" },
  { 4638u, "mo" },
  { 4639u, "mWa" },
  { 4640u, "`se" },
  { 4641u, "`su" },
  { 4642u, "`si" },
  { 4643u, "`sa" },
  { 4644u, "`sE" },
  { 4645u, "`s" },
  { 4646u, "`so" },
  { 4647u, "`sWa" },
  { 4648u, "re" },
  { 4649u, "ru" },
  { 4650u, "ri" },
  { 4651u, "ra" },
  { 4652u, "rE" },
  { 4654u, "ro" },
  { 4655u, "rWa" },
  { 4656u, "se" },
  { 4657u, "su" },
  { 4658u, "si" },
  { 4659u, "sa" },
  { 4660u, "sE" },
  { 4662u, "so" },
  { 4663u, "sWa" },
  { 4664u, "xe" },
  { 4665u, "xu" },
  { 4666u, "xi" },
  { 4667u, "xa" },
  { 4668u, "xE" },
  { 4669u, "xa" },
  { 4670u, "xo" },
  { 4671u, "xWa" },
  { 4672u, "qe" },
  { 4673u, "qu" },
  { 4674u, "qi" },
  { 4675u, "qa" },
  { 4676u, "qE" },
  { 4678u, "qo" },
  { 4680u, "qWe" },
  { 4682u, "qWi" },
  { 4683u, "qWa" },
  { 4684u, "qWE" },
  { 4685u, "qW" },
  { 4688u, "Qe" },
  { 4689u, "Qu" },
  { 4690u, "Qi" },
  { 4691u, "Qa" },
  { 4692u, "QE" },
  { 4694u, "Qo" },
  { 4696u, "QWe" },
  { 4698u, "QWi" },
  { 4699u, "QWa" },
  { 4700u, "QWE" },
  { 4701u, "QW" },
  { 4704u, "be" },
  { 4705u, "bu" },
  { 4706u, "bi" },
  { 4707u, "ba" },
  { 4708u, "bE" },
  { 4710u, "bo" },
  { 4711u, "bWa" },
  { 4712u, "ve" },
  { 4713u, "vu" },
  { 4714u, "vi" },
  { 4715u, "va" },
  { 4716u, "vE" },
  { 4718u, "vo" },
  { 4719u, "vWa" },
  { 4720u, "te" },
  { 4721u, "tu" },
  { 4722u, "ti" },
  { 4723u, "ta" },
  { 4724u, "tE" },
  { 4726u, "to" },
  { 4727u, "tWa" },
  { 4728u, "ce" },
  { 4729u, "cu" },
  { 4730u, "ci" },
  { 4731u, "ca" },
  { 4732u, "cE" },
  { 4734u, "co" },
  { 4735u, "cWa" },
  { 4736u, "`he" },
  { 4737u, "`hu" },
  { 4738u, "`hi" },
  { 4739u, "`ha" },
  { 4740u, "`hE" },
  { 4741u, "`h" },
  { 4742u, "`ho" },
  { 4744u, "hWe" },
  { 4746u, "hWi" },
  { 4747u, "hWa" },
  { 4748u, "hWE" },
  { 4749u, "hW" },
  { 4752u, "na" },
  { 4753u, "nu" },
  { 4754u, "ni" },
  { 4755u, "na" },
  { 4756u, "nE" },
  { 4758u, "no" },
  { 4759u, "nWa" },
  { 4760u, "Ne" },
  { 4761u, "Nu" },
  { 4762u, "Ni" },
  { 4763u, "Na" },
  { 4764u, "NE" },
  { 4766u, "No" },
  { 4767u, "NWa" },
  { 4775u, "e3" },
  { 4776u, "ke" },
  { 4777u, "ku" },
  { 4778u, "ki" },
  { 4779u, "ka" },
  { 4780u, "kE" },
  { 4782u, "ko" },
  { 4784u, "kWe" },
  { 4786u, "kWi" },
  { 4787u, "kWa" },
  { 4788u, "kWE" },
  { 4789u, "kW" },
  { 4792u, "Ke" },
  { 4793u, "Ku" },
  { 4794u, "Ki" },
  { 4795u, "Ka" },
  { 4796u, "KE" },
  { 4798u, "Ko" },
  { 4800u, "KWe" },
  { 4802u, "KWi" },
  { 4803u, "KWa" },
  { 4804u, "KWE" },
  { 4805u, "KW" },
  { 4808u, "we" },
  { 4809u, "wu" },
  { 4810u, "wi" },
  { 4811u, "wa" },
  { 4812u, "wE" },
  { 4814u, "wo" },
  { 4816u, "`e" },
  { 4817u, "`u" },
  { 4818u, "`i" },
  { 4819u, "`a" },
  { 4820u, "`E" },
  { 4821u, "`I" },
  { 4822u, "`o" },
  { 4824u, "ze" },
  { 4825u, "zu" },
  { 4826u, "zi" },
  { 4827u, "za" },
  { 4828u, "zE" },
  { 4830u, "zo" },
  { 4831u, "zWa" },
  { 4832u, "Ze" },
  { 4833u, "Zu" },
  { 4834u, "Zi" },
  { 4835u, "Za" },
  { 4836u, "ZE" },
  { 4838u, "Zo" },
  { 4839u, "ZWa" },
  { 4840u, "ye" },
  { 4841u, "yu" },
  { 4842u, "yi" },
  { 4843u, "ya" },
  { 4844u, "yE" },
  { 4846u, "yo" },
  { 4847u, "yWa" },
  { 4848u, "de" },
  { 4849u, "du" },
  { 4850u, "di" },
  { 4851u, "da" },
  { 4852u, "dE" },
  { 4854u, "do" },
  { 4855u, "dWa" },
  { 4856u, "De" },
  { 4857u, "Du" },
  { 4858u, "Di" },
  { 4859u, "Da" },
  { 4860u, "DE" },
  { 4862u, "Do" },
  { 4863u, "DWa" },
  { 4864u, "je" },
  { 4865u, "ju" },
  { 4866u, "ji" },
  { 4867u, "ja" },
  { 4868u, "jE" },
  { 4870u, "jo" },
  { 4871u, "jWa" },
  { 4872u, "ga" },
  { 4873u, "gu" },
  { 4874u, "gi" },
  { 4875u, "ga" },
  { 4876u, "gE" },
  { 4878u, "go" },
  { 4880u, "gWu" },
  { 4882u, "gWi" },
  { 4883u, "gWa" },
  { 4884u, "gWE" },
  { 4885u, "gW" },
  { 4888u, "Ge" },
  { 4889u, "Gu" },
  { 4890u, "Gi" },
  { 4891u, "Ga" },
  { 4892u, "GE" },
  { 4894u, "Go" },
  { 4895u, "GWa" },
  { 4896u, "Te" },
  { 4897u, "Tu" },
  { 4898u, "Ti" },
  { 4899u, "Ta" },
  { 4900u, "TE" },
  { 4902u, "To" },
  { 4903u, "TWa" },
  { 4904u, "Ce" },
  { 4905u, "Ca" },
  { 4906u, "Cu" },
  { 4907u, "Ca" },
  { 4908u, "CE" },
  { 4910u, "Co" },
  { 4911u, "CWa" },
  { 4912u, "Pe" },
  { 4913u, "Pu" },
  { 4914u, "Pi" },
  { 4915u, "Pa" },
  { 4916u, "PE" },
  { 4918u, "Po" },
  { 4919u, "PWa" },
  { 4920u, "SWe" },
  { 4921u, "SWu" },
  { 4922u, "SWi" },
  { 4923u, "SWa" },
  { 4924u, "SWE" },
  { 4925u, "SW" },
  { 4926u, "SWo" },
  { 4927u, "SWa" },
  { 4928u, "`Sa" },
  { 4929u, "`Su" },
  { 4930u, "`Si" },
  { 4931u, "`Sa" },
  { 4932u, "`SE" },
  { 4933u, "`S" },
  { 4934u, "`So" },
  { 4936u, "fa" },
  { 4937u, "fu" },
  { 4938u, "fi" },
  { 4939u, "fa" },
  { 4940u, "fE" },
  { 4942u, "fo" },
  { 4943u, "fWa" },
  { 4944u, "pe" },
  { 4945u, "pu" },
  { 4946u, "pi" },
  { 4947u, "pa" },
  { 4948u, "pE" },
  { 4950u, "po" },
  { 4951u, "pWa" },
  { 4952u, "mYa" },
  { 4953u, "rYa" },
  { 4954u, "fYa" },
  { 4962u, "::" },
  { 4964u, ";" },
  { 4965u, "-:" },
  { 4966u, ":-" },
  { 4967u, "`?" },
  { 4968u, ":|:" },
  { 4969u, "`1" },
  { 4970u, "`2" },
  { 4971u, "`3" },
  { 4972u, "`4" },
  { 4973u, "`5" },
  { 4974u, "`6" },
  { 4975u, "`7" },
  { 4976u, "`8" },
  { 4977u, "`9" },
  { 4978u, "`10" },
  { 4979u, "`20" },
  { 4980u, "`30" },
  { 4981u, "`40" },
  { 4982u, "`50" },
  { 4983u, "`60" },
  { 4984u, "`70" },
  { 4985u, "`80" },
  { 4986u, "`90" },
  { 4987u, "`100" },
  { 4988u, "`10000" },
  { 7680u, "A-0" },
  { 7681u, "a-0" },
  { 7682u, "B." },
  { 7683u, "b." },
  { 7684u, "B-." },
  { 7685u, "b-." },
  { 7686u, "B_" },
  { 7687u, "b_" },
  { 7688u, "C,'" },
  { 7689u, "c,'" },
  { 7690u, "D." },
  { 7691u, "d." },
  { 7692u, "D-." },
  { 7693u, "d-." },
  { 7694u, "D_" },
  { 7695u, "d_" },
  { 7696u, "D," },
  { 7697u, "d," },
  { 7698u, "D->" },
  { 7699u, "d->" },
  { 7700u, "E-!" },
  { 7701u, "e-!" },
  { 7702u, "E-'" },
  { 7703u, "e-'" },
  { 7704u, "E->" },
  { 7705u, "e->" },
  { 7706u, "E-?" },
  { 7707u, "e-?" },
  { 7708u, "E,(" },
  { 7709u, "e,(" },
  { 7710u, "F." },
  { 7711u, "f." },
  { 7712u, "G-" },
  { 7713u, "g-" },
  { 7714u, "H." },
  { 7715u, "h." },
  { 7716u, "H-." },
  { 7717u, "h-." },
  { 7718u, "H:" },
  { 7719u, "h:" },
  { 7720u, "H," },
  { 7721u, "h," },
  { 7722u, "H-(" },
  { 7723u, "h-(" },
  { 7724u, "I-?" },
  { 7725u, "i-?" },
  { 7726u, "I:'" },
  { 7727u, "i:'" },
  { 7728u, "K'" },
  { 7729u, "k'" },
  { 7730u, "K-." },
  { 7731u, "k-." },
  { 7732u, "K_" },
  { 7733u, "k_" },
  { 7734u, "L-." },
  { 7735u, "l-." },
  { 7736u, "L--." },
  { 7737u, "l--." },
  { 7738u, "L_" },
  { 7739u, "l_" },
  { 7740u, "L->" },
  { 7741u, "l->" },
  { 7742u, "M'" },
  { 7743u, "m'" },
  { 7744u, "M." },
  { 7745u, "m." },
  { 7746u, "M-." },
  { 7747u, "m-." },
  { 7748u, "N." },
  { 7749u, "n." },
  { 7750u, "N-." },
  { 7751u, "n-." },
  { 7752u, "N_" },
  { 7753u, "n_" },
  { 7754u, "N->" },
  { 7755u, "n->" },
  { 7756u, "O?'" },
  { 7757u, "o?'" },
  { 7758u, "O?:" },
  { 7759u, "o?:" },
  { 7760u, "O-!" },
  { 7761u, "o-!" },
  { 7762u, "O-'" },
  { 7763u, "o-'" },
  { 7764u, "P'" },
  { 7765u, "p'" },
  { 7766u, "P." },
  { 7767u, "p." },
  { 7768u, "R." },
  { 7769u, "r." },
  { 7770u, "R-." },
  { 7771u, "r-." },
  { 7772u, "R--." },
  { 7773u, "r--." },
  { 7774u, "R_" },
  { 7775u, "r_" },
  { 7776u, "S." },
  { 7777u, "s." },
  { 7778u, "S-." },
  { 7779u, "s-." },
  { 7780u, "S'." },
  { 7781u, "s'." },
  { 7782u, "S<." },
  { 7783u, "s<." },
  { 7784u, "S.-." },
  { 7785u, "s.-." },
  { 7786u, "T." },
  { 7787u, "t." },
  { 7788u, "T-." },
  { 7789u, "t-." },
  { 7790u, "T_" },
  { 7791u, "t_" },
  { 7792u, "T->" },
  { 7793u, "t->" },
  { 7794u, "U--:" },
  { 7795u, "u--:" },
  { 7796u, "U-?" },
  { 7797u, "u-?" },
  { 7798u, "U->" },
  { 7799u, "u->" },
  { 7800u, "U?'" },
  { 7801u, "u?'" },
  { 7802u, "U-:" },
  { 7803u, "u-:" },
  { 7804u, "V?" },
  { 7805u, "v?" },
  { 7806u, "V-." },
  { 7807u, "v-." },
  { 7808u, "W!" },
  { 7809u, "w!" },
  { 7810u, "W'" },
  { 7811u, &unk_8172597 },
  { 7812u, "W:" },
  { 7813u, "w:" },
  { 7814u, "W." },
  { 7815u, "w." },
  { 7816u, "W-." },
  { 7817u, "w-." },
  { 7818u, "X." },
  { 7819u, "x." },
  { 7820u, "X:" },
  { 7821u, "x:" },
  { 7822u, "Y." },
  { 7823u, "y." },
  { 7824u, "Z>" },
  { 7825u, "z>" },
  { 7826u, "Z-." },
  { 7827u, "z-." },
  { 7828u, "Z_" },
  { 7829u, "z_" },
  { 7830u, "h_" },
  { 7831u, "t:" },
  { 7832u, "w0" },
  { 7833u, "y0" },
  { 7840u, "A-." },
  { 7841u, "a-." },
  { 7842u, "A2" },
  { 7843u, "a2" },
  { 7844u, "A>'" },
  { 7845u, "a>'" },
  { 7846u, "A>!" },
  { 7847u, "a>!" },
  { 7848u, "A>2" },
  { 7849u, "a>2" },
  { 7850u, "A>?" },
  { 7851u, "a>?" },
  { 7852u, "A>-." },
  { 7853u, "a>-." },
  { 7854u, "A('" },
  { 7855u, "a('" },
  { 7856u, "A(!" },
  { 7857u, "a(!" },
  { 7858u, "A(2" },
  { 7859u, "a(2" },
  { 7860u, "A(?" },
  { 7861u, "a(?" },
  { 7862u, "A(-." },
  { 7863u, "a(-." },
  { 7864u, "E-." },
  { 7865u, "e-." },
  { 7866u, "E2" },
  { 7867u, "e2" },
  { 7868u, "E?" },
  { 7869u, "e?" },
  { 7870u, "E>'" },
  { 7871u, "e>'" },
  { 7872u, "E>!" },
  { 7873u, "e>!" },
  { 7874u, "E>2" },
  { 7875u, "e>2" },
  { 7876u, "E>?" },
  { 7877u, "e>?" },
  { 7878u, "E>-." },
  { 7879u, "e>-." },
  { 7880u, "I2" },
  { 7881u, "i2" },
  { 7882u, "I-." },
  { 7883u, "i-." },
  { 7884u, "O-." },
  { 7885u, "o-." },
  { 7886u, "O2" },
  { 7887u, "o2" },
  { 7888u, "O>'" },
  { 7889u, "o>'" },
  { 7890u, "O>!" },
  { 7891u, "o>!" },
  { 7892u, "O>2" },
  { 7893u, "o>2" },
  { 7894u, "O>?" },
  { 7895u, "o>?" },
  { 7896u, "O>-." },
  { 7897u, "o>-." },
  { 7898u, "O9'" },
  { 7899u, "o9'" },
  { 7900u, "O9!" },
  { 7901u, "o9!" },
  { 7902u, "O92" },
  { 7903u, "o92" },
  { 7904u, "O9?" },
  { 7905u, "o9?" },
  { 7906u, "O9-." },
  { 7907u, "o9-." },
  { 7908u, "U-." },
  { 7909u, "u-." },
  { 7910u, "U2" },
  { 7911u, "u2" },
  { 7912u, "U9'" },
  { 7913u, "u9'" },
  { 7914u, "U9!" },
  { 7915u, "u9!" },
  { 7916u, "U92" },
  { 7917u, "u92" },
  { 7918u, "U9?" },
  { 7919u, "u9?" },
  { 7920u, "U9-." },
  { 7921u, "u9-." },
  { 7922u, "Y!" },
  { 7923u, "y!" },
  { 7924u, "Y-." },
  { 7925u, "y-." },
  { 7926u, "Y2" },
  { 7927u, "y2" },
  { 7928u, "Y?" },
  { 7929u, "y?" },
  { 7937u, "ha" },
  { 7938u, "`a" },
  { 7939u, "h`a" },
  { 7940u, "a'" },
  { 7941u, "ha'" },
  { 7942u, "a~" },
  { 7943u, "ha~" },
  { 7945u, "hA" },
  { 7946u, "`A" },
  { 7947u, "h`A" },
  { 7948u, "A'" },
  { 7949u, "hA'" },
  { 7950u, "A~" },
  { 7951u, "hA~" },
  { 7953u, "he" },
  { 7961u, "hE" },
  { 7985u, "hi" },
  { 7993u, "hI" },
  { 8001u, "ho" },
  { 8009u, "hO" },
  { 8017u, "hu" },
  { 8025u, "hU" },
  { 8127u, ",," },
  { 8128u, "?*" },
  { 8129u, "?:" },
  { 8141u, ",!" },
  { 8142u, ",'" },
  { 8143u, "?," },
  { 8157u, ";!" },
  { 8158u, ";'" },
  { 8159u, "?;" },
  { 8165u, "rh" },
  { 8172u, "Rh" },
  { 8173u, "!:" },
  { 8175u, "!*" },
  { 8190u, ";;" },
  { 8193u, "  " },
  { 8195u, "  " },
  { 8206u, "(->)" },
  { 8207u, "(<-)" },
  { 8202u, &unk_8175347 },
  { 8212u, "--" },
  { 8214u, "||" },
  { 8215u, "=2" },
  { 8224u, "/-" },
  { 8225u, "/=" },
  { 8226u, " o " },
  { 8227u, " > " },
  { 8229u, ".." },
  { 8230u, "..." },
  { 8231u, &unk_8174671 },
  { 8232u, "\r" },
  { 8233u, "\r\n" },
  { 8236u, &unk_8175347 },
  { 8237u, &unk_8175347 },
  { 8239u, &unk_8175347 },
  { 8240u, " 0/00" },
  { 8241u, " 0/000" },
  { 8242u, &unk_817466A },
  { 8243u, "''" },
  { 8244u, "'''" },
  { 8245u, "`" },
  { 8246u, "``" },
  { 8247u, "```" },
  { 8248u, "^" },
  { 8249u, "<" },
  { 8250u, ">" },
  { 8251u, ":X" },
  { 8252u, "!!" },
  { 8253u, "?!" },
  { 8254u, "'-" },
  { 8258u, "***" },
  { 8259u, " - " },
  { 8260u, "/" },
  { 8261u, "[-" },
  { 8262u, "-]" },
  { 8263u, "??" },
  { 8264u, "?!" },
  { 8265u, "!?" },
  { 8267u, "|P" },
  { 8270u, "*" },
  { 8273u, "**" },
  { 8274u, "./." },
  { 8275u, "~" },
  { 8278u, " .: " },
  { 8279u, "''''" },
  { 8280u, " .:. " },
  { 8281u, " :.: " },
  { 8282u, " : " },
  { 8283u, " .:. " },
  { 8284u, ":+:" },
  { 8304u, "^0" },
  { 8308u, "^4" },
  { 8309u, "^5" },
  { 8310u, "^6" },
  { 8311u, "^7" },
  { 8312u, "^8" },
  { 8313u, "^9" },
  { 8314u, "^+" },
  { 8315u, "^-" },
  { 8316u, "^=" },
  { 8317u, "^(" },
  { 8318u, "^)" },
  { 8319u, "^n" },
  { 8320u, "_0" },
  { 8321u, "_1" },
  { 8322u, "_2" },
  { 8323u, "_3" },
  { 8324u, "_4" },
  { 8325u, "_5" },
  { 8326u, "_6" },
  { 8327u, "_7" },
  { 8328u, "_8" },
  { 8329u, "_9" },
  { 8330u, "_+" },
  { 8331u, "_-" },
  { 8332u, "_=" },
  { 8333u, "(" },
  { 8334u, ")" },
  { 8353u, "C//" },
  { 8354u, "Cr" },
  { 8355u, "Ff" },
  { 8356u, "Li" },
  { 8357u, "m/" },
  { 8358u, "N=" },
  { 8359u, "Pt" },
  { 8360u, "Rs" },
  { 8361u, "W=" },
  { 8362u, "rJ" },
  { 8363u, "d_" },
  { 8364u, "EUR" },
  { 8365u, "K-" },
  { 8366u, "T//" },
  { 8367u, "Dp" },
  { 8369u, "P=" },
  { 8370u, "G|" },
  { 8371u, "A=" },
  { 8373u, "C|" },
  { 8448u, "a/c" },
  { 8449u, "a/s" },
  { 8451u, "oC" },
  { 8452u, "CL" },
  { 8453u, "c/o" },
  { 8454u, "c/u" },
  { 8457u, "oF" },
  { 8463u, "\\hbar " },
  { 8465u, "Im" },
  { 8467u, "l" },
  { 8470u, "No." },
  { 8471u, "(P)" },
  { 8472u, (const char *)0x817493A },
  { 8476u, "Re" },
  { 8478u, "Rx" },
  { 8480u, "(SM)" },
  { 8481u, "TEL" },
  { 8482u, "(TM)" },
  { 8485u, "oz." },
  { 8486u, "Ohm" },
  { 8491u, "Ang." },
  { 8494u, "est." },
  { 8501u, "Aleph " },
  { 8502u, "Bet " },
  { 8503u, "Gimel " },
  { 8504u, "Dalet " },
  { 8507u, " FAX" },
  { 8531u, " 1/3" },
  { 8532u, " 2/3" },
  { 8533u, " 1/5" },
  { 8534u, " 2/5" },
  { 8535u, " 3/5" },
  { 8536u, " 4/5" },
  { 8537u, " 1/6" },
  { 8538u, " 5/6" },
  { 8539u, " 1/8" },
  { 8540u, " 3/8" },
  { 8541u, " 5/8" },
  { 8542u, " 7/8" },
  { 8543u, " 1/" },
  { 8544u, (const char *)0x817492C },
  { 8545u, "II" },
  { 8546u, "III" },
  { 8547u, "IV" },
  { 8548u, "V" },
  { 8549u, "VI" },
  { 8550u, "VII" },
  { 8551u, "VIII" },
  { 8552u, "IX" },
  { 8553u, (const char *)0x8174946 },
  { 8554u, "XI" },
  { 8555u, "XII" },
  { 8556u, (const char *)0x8174930 },
  { 8557u, (const char *)0x8174936 },
  { 8558u, (const char *)0x8174926 },
  { 8559u, (const char *)0x8174932 },
  { 8560u, "i" },
  { 8561u, "ii" },
  { 8562u, "iii" },
  { 8563u, "iv" },
  { 8564u, "v" },
  { 8565u, "vi" },
  { 8566u, "vii" },
  { 8567u, "viii" },
  { 8568u, "ix" },
  { 8569u, (const char *)0x817498A },
  { 8570u, "xi" },
  { 8571u, "xii" },
  { 8572u, "l" },
  { 8573u, "c" },
  { 8574u, "d" },
  { 8575u, "m" },
  { 8576u, "1000RCD" },
  { 8577u, "5000R" },
  { 8578u, "10000R" },
  { 8592u, "<-" },
  { 8593u, "^|" },
  { 8594u, "->" },
  { 8595u, "|v" },
  { 8596u, "<->" },
  { 8597u, "^|v" },
  { 8598u, "^\\" },
  { 8599u, "/^" },
  { 8600u, "\\v" },
  { 8601u, "v/" },
  { 8602u, "</-" },
  { 8603u, "-/>" },
  { 8604u, "<~" },
  { 8605u, "~>" },
  { 8606u, "<<-" },
  { 8607u, "^^|" },
  { 8608u, "->>" },
  { 8609u, "|vv" },
  { 8610u, "<-<" },
  { 8611u, ">->" },
  { 8612u, "<-|" },
  { 8613u, "^|_" },
  { 8614u, "|->" },
  { 8616u, "^|v_" },
  { 8621u, "<~>" },
  { 8622u, "<-/->" },
  { 8623u, "Nv" },
  { 8624u, "<^|" },
  { 8625u, "|^>" },
  { 8626u, "<v|" },
  { 8627u, "|v>" },
  { 8628u, "-v" },
  { 8629u, "RET" },
  { 8634u, "u<" },
  { 8635u, ">u" },
  { 8636u, "<-" },
  { 8637u, "<-" },
  { 8638u, "^|" },
  { 8639u, "^|" },
  { 8640u, "->" },
  { 8641u, "->" },
  { 8642u, "|v" },
  { 8643u, "|v" },
  { 8644u, "<=>" },
  { 8645u, "^||v" },
  { 8646u, "<=>" },
  { 8647u, "<<=" },
  { 8648u, "^|^|" },
  { 8649u, "=>>" },
  { 8650u, "|v|v" },
  { 8651u, "<=>" },
  { 8652u, "<=>" },
  { 8653u, "<=/=" },
  { 8654u, "<=/=>" },
  { 8655u, "=/=>" },
  { 8656u, "<=" },
  { 8657u, "^||" },
  { 8658u, "=>" },
  { 8659u, "||v" },
  { 8660u, "<=>" },
  { 8661u, "^||v" },
  { 8662u, "^\\\\" },
  { 8663u, "//^" },
  { 8664u, "\\\\v" },
  { 8665u, "v//" },
  { 8666u, "<-=" },
  { 8667u, "=->" },
  { 8668u, "<~" },
  { 8669u, "~>" },
  { 8670u, "^|=|" },
  { 8671u, "|=|v" },
  { 8672u, "<-" },
  { 8673u, "^:" },
  { 8674u, "->" },
  { 8675u, ":v" },
  { 8676u, "|<-" },
  { 8677u, "->|" },
  { 8678u, "<-" },
  { 8679u, "^|" },
  { 8680u, "->" },
  { 8681u, "|v" },
  { 8682u, "^!" },
  { 8683u, "^I" },
  { 8684u, "^-I" },
  { 8685u, "^|I" },
  { 8686u, "^^|" },
  { 8687u, "^^I" },
  { 8688u, "|->" },
  { 8690u, "\\v_|" },
  { 8691u, "^|v" },
  { 8692u, "-o>" },
  { 8693u, "|v^|" },
  { 8694u, "=->>>" },
  { 8695u, "<-|-" },
  { 8696u, "-|->" },
  { 8697u, "<-|->" },
  { 8698u, "<-||-" },
  { 8699u, "-||->" },
  { 8700u, "<-||->" },
  { 8701u, "<-" },
  { 8702u, "->" },
  { 8703u, "<->" },
  { 8704u, "FA" },
  { 8705u, (const char *)0x8174936 },
  { 8706u, "\\partial" },
  { 8707u, "TE" },
  { 8708u, "TDNE" },
  { 8709u, "{}" },
  { 8710u, "Delta" },
  { 8711u, "Nabla" },
  { 8712u, "(-" },
  { 8713u, "!(-" },
  { 8714u, "(-" },
  { 8715u, "-)" },
  { 8716u, "!-)" },
  { 8717u, "-)" },
  { 8718u, " qed" },
  { 8719u, "\\prod" },
  { 8721u, "\\sum" },
  { 8722u, &unk_817465B },
  { 8723u, "-/+" },
  { 8724u, ".+" },
  { 8726u, " - " },
  { 8727u, "*" },
  { 8728u, "Ob" },
  { 8729u, "sb" },
  { 8730u, " SQRT " },
  { 8731u, " ROOT3 " },
  { 8732u, " ROOT4 " },
  { 8733u, "0(" },
  { 8734u, "infty" },
  { 8735u, "-L" },
  { 8736u, "-V" },
  { 8741u, "PP" },
  { 8742u, " !PP " },
  { 8743u, "AND" },
  { 8744u, "OR" },
  { 8745u, "(U" },
  { 8746u, ")U" },
  { 8747u, "\\int " },
  { 8748u, "\\int\\int " },
  { 8749u, "\\int\\int\\int " },
  { 8750u, "Io" },
  { 8756u, ".:" },
  { 8757u, ":." },
  { 8758u, ":R" },
  { 8759u, "::" },
  { 8760u, ".-" },
  { 8761u, "-:" },
  { 8764u, "?1" },
  { 8766u, "CG" },
  { 8769u, "!~" },
  { 8770u, "-~" },
  { 8771u, "?-" },
  { 8772u, "!~-" },
  { 8773u, "?=" },
  { 8774u, "~!=" },
  { 8775u, "!~=" },
  { 8776u, "~=" },
  { 8777u, " !~= " },
  { 8779u, "~3" },
  { 8780u, "=?" },
  { 8784u, "=..." },
  { 8787u, "HI" },
  { 8788u, ":=" },
  { 8789u, "=:" },
  { 8800u, "!=" },
  { 8801u, "=3" },
  { 8802u, " !=3 " },
  { 8803u, "=4" },
  { 8804u, "<=" },
  { 8805u, ">=" },
  { 8806u, ".LE." },
  { 8807u, ".GE." },
  { 8808u, ".LT.NOT.EQ." },
  { 8809u, ".GT.NOT.EQ." },
  { 8810u, &unk_8174650 },
  { 8811u, &unk_817467B },
  { 8814u, "!<" },
  { 8815u, "!>" },
  { 8816u, "!<=" },
  { 8817u, "!>=" },
  { 8818u, "<~" },
  { 8819u, ">~" },
  { 8820u, "!<~" },
  { 8821u, "!>~" },
  { 8822u, " <> " },
  { 8823u, " >< " },
  { 8824u, " !<> " },
  { 8825u, " !>< " },
  { 8834u, "(C" },
  { 8835u, ")C" },
  { 8836u, " !(C " },
  { 8837u, " !)C " },
  { 8838u, "(_" },
  { 8839u, ")_" },
  { 8840u, "!(_" },
  { 8841u, "!)_" },
  { 8842u, "(!_" },
  { 8843u, ")!_" },
  { 8847u, "[" },
  { 8848u, "]" },
  { 8849u, "[_" },
  { 8850u, "]_" },
  { 8853u, "(+)" },
  { 8854u, "(-)" },
  { 8855u, "(x)" },
  { 8856u, "(/)" },
  { 8857u, "(.)" },
  { 8858u, "(o)" },
  { 8859u, "(*)" },
  { 8860u, "(=)" },
  { 8861u, "(-)" },
  { 8862u, "[+]" },
  { 8863u, "[-]" },
  { 8864u, "[x]" },
  { 8865u, "[.]" },
  { 8869u, "-T" },
  { 8871u, " MODELS " },
  { 8872u, " TRUE " },
  { 8873u, " FORCES " },
  { 8876u, " !PROVES " },
  { 8877u, " NOT TRUE " },
  { 8878u, " !FORCES " },
  { 8882u, " NORMAL SUBGROUP OF " },
  { 8883u, " CONTAINS AS NORMAL SUBGROUP " },
  { 8884u, " NORMAL SUBGROUP OF OR EQUAL TO " },
  { 8885u, " CONTAINS AS NORMAL SUBGROUP OR EQUAL TO " },
  { 8888u, " MULTIMAP " },
  { 8890u, " INTERCALATE " },
  { 8891u, " XOR " },
  { 8892u, " NAND " },
  { 8901u, " DOT " },
  { 8902u, " STAR " },
  { 8918u, "<." },
  { 8919u, ">." },
  { 8920u, "<<<" },
  { 8921u, ">>>" },
  { 8922u, "<=|>" },
  { 8923u, ">=|<" },
  { 8924u, "=<" },
  { 8925u, "=>" },
  { 8930u, "![_" },
  { 8931u, "!]_" },
  { 8932u, "[!_" },
  { 8933u, "]!_" },
  { 8934u, "<!~" },
  { 8935u, ">!~" },
  { 8942u, ":3" },
  { 8943u, ".3" },
  { 8962u, "Eh" },
  { 8963u, "^" },
  { 8964u, "v" },
  { 8967u, "~~" },
  { 8968u, "<7" },
  { 8969u, ">7" },
  { 8970u, "7<" },
  { 8971u, "7>" },
  { 8976u, "NI" },
  { 8978u, "(A" },
  { 8981u, "TR" },
  { 8984u, "88" },
  { 8986u, "(-/)" },
  { 8987u, " >i< " },
  { 8992u, "Iu" },
  { 8993u, "Il" },
  { 8994u, ":(" },
  { 8995u, ":)" },
  { 8996u, "|^|" },
  { 8997u, " OPT " },
  { 8998u, "[X>" },
  { 8999u, "[X]" },
  { 9000u, "[kbd]" },
  { 9001u, "</" },
  { 9002u, "/>" },
  { 9003u, "<X]" },
  { 9095u, " ALT " },
  { 9111u, "<-pp" },
  { 9112u, "pp->" },
  { 9113u, "[PrSc]" },
  { 9114u, "[ClSc]" },
  { 9166u, " CR " },
  { 9167u, "_^_" },
  { 9178u, "GROUND" },
  { 9251u, "Vs" },
  { 9280u, "1h" },
  { 9281u, "3h" },
  { 9282u, "2h" },
  { 9283u, "4h" },
  { 9286u, "1j" },
  { 9287u, "2j" },
  { 9288u, "3j" },
  { 9289u, "4j" },
  { 9312u, "1-o" },
  { 9313u, "2-o" },
  { 9314u, "3-o" },
  { 9315u, "4-o" },
  { 9316u, "5-o" },
  { 9317u, "6-o" },
  { 9318u, "7-o" },
  { 9319u, "8-o" },
  { 9320u, "9-o" },
  { 9321u, "10-o" },
  { 9322u, "11-o" },
  { 9323u, "12-o" },
  { 9324u, "13-o" },
  { 9325u, "14-o" },
  { 9326u, "15-o" },
  { 9327u, "16-o" },
  { 9328u, "17-o" },
  { 9329u, "18-o" },
  { 9330u, "19-o" },
  { 9331u, "20-o" },
  { 9332u, "(1)" },
  { 9333u, "(2)" },
  { 9334u, "(3)" },
  { 9335u, "(4)" },
  { 9336u, "(5)" },
  { 9337u, "(6)" },
  { 9338u, "(7)" },
  { 9339u, "(8)" },
  { 9340u, "(9)" },
  { 9341u, "(10)" },
  { 9342u, "(11)" },
  { 9343u, "(12)" },
  { 9344u, "(13)" },
  { 9345u, "(14)" },
  { 9346u, "(15)" },
  { 9347u, "(16)" },
  { 9348u, "(17)" },
  { 9349u, "(18)" },
  { 9350u, "(19)" },
  { 9351u, "(20)" },
  { 9352u, "1." },
  { 9353u, "2." },
  { 9354u, "3." },
  { 9355u, "4." },
  { 9356u, "5." },
  { 9357u, "6." },
  { 9358u, "7." },
  { 9359u, "8." },
  { 9360u, "9." },
  { 9361u, "10." },
  { 9362u, "11." },
  { 9363u, "12." },
  { 9364u, "13." },
  { 9365u, "14." },
  { 9366u, "15." },
  { 9367u, "16." },
  { 9368u, "17." },
  { 9369u, "18." },
  { 9370u, "19." },
  { 9371u, "20." },
  { 9372u, "(a)" },
  { 9373u, "(b)" },
  { 9374u, &unk_8174649 },
  { 9375u, "(d)" },
  { 9376u, "(e)" },
  { 9377u, "(f)" },
  { 9378u, "(g)" },
  { 9379u, "(h)" },
  { 9380u, "(i)" },
  { 9381u, "(j)" },
  { 9382u, "(k)" },
  { 9383u, "(l)" },
  { 9384u, "(m)" },
  { 9385u, "(n)" },
  { 9386u, "(o)" },
  { 9387u, "(p)" },
  { 9388u, "(q)" },
  { 9389u, "(r)" },
  { 9390u, "(s)" },
  { 9391u, "(t)" },
  { 9392u, "(u)" },
  { 9393u, "(v)" },
  { 9394u, "(w)" },
  { 9395u, "(x)" },
  { 9396u, "(y)" },
  { 9397u, "(z)" },
  { 9398u, "A-o" },
  { 9399u, "B-o" },
  { 9400u, "C-o" },
  { 9401u, "D-o" },
  { 9402u, "E-o" },
  { 9403u, "F-o" },
  { 9404u, "G-o" },
  { 9405u, "H-o" },
  { 9406u, "I-o" },
  { 9407u, "J-o" },
  { 9408u, "K-o" },
  { 9409u, "L-o" },
  { 9410u, "M-o" },
  { 9411u, "N-o" },
  { 9412u, "O-o" },
  { 9413u, "P-o" },
  { 9414u, "Q-o" },
  { 9415u, "R-o" },
  { 9416u, "S-o" },
  { 9417u, "T-o" },
  { 9418u, "U-o" },
  { 9419u, "V-o" },
  { 9420u, "W-o" },
  { 9421u, "X-o" },
  { 9422u, "Y-o" },
  { 9423u, "Z-o" },
  { 9424u, "a-o" },
  { 9425u, "b-o" },
  { 9426u, "c-o" },
  { 9427u, "d-o" },
  { 9428u, "e-o" },
  { 9429u, "f-o" },
  { 9430u, "g-o" },
  { 9431u, "h-o" },
  { 9432u, "i-o" },
  { 9433u, "j-o" },
  { 9434u, "k-o" },
  { 9435u, "l-o" },
  { 9436u, "m-o" },
  { 9437u, "n-o" },
  { 9438u, "o-o" },
  { 9439u, "p-o" },
  { 9440u, "q-o" },
  { 9441u, "r-o" },
  { 9442u, "s-o" },
  { 9443u, "t-o" },
  { 9444u, "u-o" },
  { 9445u, "v-o" },
  { 9446u, "w-o" },
  { 9447u, "x-o" },
  { 9448u, "y-o" },
  { 9449u, "z-o" },
  { 9450u, "0-o" },
  { 9472u, &unk_817465B },
  { 9473u, "=" },
  { 9474u, &unk_8174642 },
  { 9475u, &unk_8174642 },
  { 9476u, &unk_817465B },
  { 9477u, "=" },
  { 9478u, &unk_8174642 },
  { 9479u, &unk_8174642 },
  { 9480u, &unk_817465B },
  { 9481u, "=" },
  { 9482u, &unk_8174642 },
  { 9483u, &unk_8174642 },
  { 9585u, "/" },
  { 9586u, "\\" },
  { 9600u, "TB" },
  { 9604u, "LB" },
  { 9608u, "FB" },
  { 9612u, "lB" },
  { 9616u, "RB" },
  { 9617u, ".S" },
  { 9618u, ":S" },
  { 9619u, "?S" },
  { 9632u, "fS" },
  { 9633u, "OS" },
  { 9634u, "RO" },
  { 9635u, "Rr" },
  { 9636u, "RF" },
  { 9637u, "RY" },
  { 9638u, "RH" },
  { 9639u, "RZ" },
  { 9640u, "RK" },
  { 9641u, "RX" },
  { 9642u, "sB" },
  { 9644u, "SR" },
  { 9645u, "Or" },
  { 9650u, "^" },
  { 9651u, "uT" },
  { 9654u, "|>" },
  { 9655u, "Tr" },
  { 9658u, "|>" },
  { 9660u, "v" },
  { 9661u, "dT" },
  { 9664u, "<|" },
  { 9665u, "Tl" },
  { 9668u, "<|" },
  { 9670u, "Db" },
  { 9671u, "Dw" },
  { 9674u, "LZ" },
  { 9675u, "0m" },
  { 9678u, "0o" },
  { 9679u, "0M" },
  { 9680u, "0L" },
  { 9681u, "0R" },
  { 9688u, "Sn" },
  { 9689u, "Ic" },
  { 9698u, "Fd" },
  { 9699u, "Bd" },
  { 9711u, "Ci" },
  { 9728u, "SU" },
  { 9729u, "cOo" },
  { 9730u, "J" },
  { 9731u, "\"8\"" },
  { 9733u, "*" },
  { 9734u, "*" },
  { 9735u, "<v" },
  { 9736u, "Rv" },
  { 9737u, "Sol" },
  { 9738u, "Asc." },
  { 9739u, "Desc." },
  { 9740u, "Conj." },
  { 9741u, "Opp." },
  { 9742u, "TEL" },
  { 9743u, "tel" },
  { 9747u, (const char *)0x8174946 },
  { 9748u, "\"J\"" },
  { 9749u, "Joe" },
  { 9754u, "<==" },
  { 9755u, "==>" },
  { 9756u, "<--" },
  { 9757u, "||^" },
  { 9758u, "-->" },
  { 9759u, "||v" },
  { 9760u, "!X!" },
  { 9761u, "!Z!" },
  { 9762u, "!R!" },
  { 9763u, "!B!" },
  { 9764u, "2TS" },
  { 9766u, (const char *)0x8174986 },
  { 9767u, "XP" },
  { 9768u, (const char *)0x8174986 },
  { 9769u, "+" },
  { 9770u, "(*" },
  { 9773u, "'\\,)" },
  { 9774u, "(PEACE)" },
  { 9775u, "Pd" },
  { 9776u, "-HVN-" },
  { 9777u, "-LAK-" },
  { 9778u, "-FIR-" },
  { 9779u, "-THR-" },
  { 9780u, "-WND-" },
  { 9781u, "-WTR-" },
  { 9782u, "-MTN-" },
  { 9783u, "-RTH-" },
  { 9784u, "*" },
  { 9785u, ":-(" },
  { 9786u, ":-)" },
  { 9787u, "(-:" },
  { 9788u, "su" },
  { 9789u, "Lun1" },
  { 9790u, "Lun3" },
  { 9791u, "Mer" },
  { 9792u, "Ven" },
  { 9793u, "Ter" },
  { 9794u, "Mar" },
  { 9795u, "Jup" },
  { 9796u, "Sat" },
  { 9797u, "Ura" },
  { 9798u, "Nep" },
  { 9799u, "Plu" },
  { 9800u, "Ari" },
  { 9801u, "Tau" },
  { 9802u, "Gem" },
  { 9803u, "Cnc" },
  { 9804u, "Leo" },
  { 9805u, "Vir" },
  { 9806u, "Lib" },
  { 9807u, "Sco" },
  { 9808u, "Sgr" },
  { 9809u, "Cap" },
  { 9810u, "Aqr" },
  { 9811u, "Psc" },
  { 9812u, "k" },
  { 9813u, (const char *)0x817498C },
  { 9814u, "r" },
  { 9815u, "b" },
  { 9816u, "n" },
  { 9817u, "p" },
  { 9818u, (const char *)0x817492E },
  { 9819u, (const char *)0x8174948 },
  { 9820u, (const char *)0x817493C },
  { 9821u, (const char *)0x8174922 },
  { 9822u, (const char *)0x8174934 },
  { 9823u, (const char *)0x817493A },
  { 9824u, "cS" },
  { 9825u, "ch" },
  { 9826u, "cd" },
  { 9827u, "cC" },
  { 9828u, "cs" },
  { 9829u, "cH" },
  { 9830u, "cD" },
  { 9831u, "cc" },
  { 9833u, "d" },
  { 9834u, "d`" },
  { 9835u, "d-d" },
  { 9836u, "d=d" },
  { 9837u, "b" },
  { 9838u, (const char *)0x8174934 },
  { 9839u, "#" },
  { 9840u, (const char *)0x8174986 },
  { 9841u, (const char *)0x8174986 },
  { 9842u, "/_\\" },
  { 9843u, "/1\\" },
  { 9844u, "/2\\" },
  { 9845u, "/3\\" },
  { 9846u, "/4\\" },
  { 9847u, "/5\\" },
  { 9848u, "/6\\" },
  { 9849u, "/7\\" },
  { 9850u, "/_\\" },
  { 9851u, "/_\\" },
  { 9852u, "/P\\" },
  { 9853u, "/p\\" },
  { 9854u, "(oo)" },
  { 9855u, "oL" },
  { 9856u, "d1" },
  { 9857u, "d2" },
  { 9858u, "d3" },
  { 9859u, "d4" },
  { 9860u, "d5" },
  { 9861u, "d6" },
  { 9862u, "(.)" },
  { 9863u, "(:)" },
  { 9864u, "((.))" },
  { 9865u, "((:))" },
  { 9872u, " f " },
  { 9873u, " F " },
  { 9874u, "'X`" },
  { 9875u, "+-)" },
  { 9876u, ",X," },
  { 9877u, "$" },
  { 9878u, "^T^" },
  { 9882u, "}T{" },
  { 9883u, ":*:" },
  { 9884u, "}|{" },
  { 9888u, "!!!" },
  { 9889u, "!V!" },
  { 9890u, "f.f." },
  { 9891u, "m.m." },
  { 9892u, "m.f." },
  { 9893u, "mf." },
  { 9894u, "xm." },
  { 9895u, "xmf." },
  { 9898u, "o" },
  { 9899u, (const char *)0x8174938 },
  { 9900u, "o" },
  { 9901u, "oo" },
  { 9902u, "o|o" },
  { 9903u, "o-o" },
  { 9904u, "/b/" },
  { 9905u, "/c/" },
  { 9906u, "n." },
  { 9986u, "8<" },
  { 9988u, ">8" },
  { 9990u, "(TEL)" },
  { 9992u, "+->-" },
  { 9993u, "[v]" },
  { 9996u, "mV," },
  { 10005u, " x" },
  { 10006u, " X" },
  { 10009u, "+" },
  { 10010u, "+" },
  { 10011u, "+" },
  { 10012u, "+" },
  { 10013u, (const char *)0x8174986 },
  { 10014u, (const char *)0x8174986 },
  { 10015u, (const char *)0x8174986 },
  { 10016u, "-X" },
  { 10070u, "<x>" },
  { 10072u, &unk_8174642 },
  { 10073u, &unk_8174642 },
  { 10074u, &unk_8174642 },
  { 10075u, &unk_817466A },
  { 10076u, &unk_817466A },
  { 10077u, &unk_8174647 },
  { 10078u, &unk_8174647 },
  { 10082u, &unk_8174630 },
  { 10083u, &unk_8174630 },
  { 10085u, "<3" },
  { 10088u, "(" },
  { 10089u, ")" },
  { 10090u, "(" },
  { 10091u, ")" },
  { 10092u, "<" },
  { 10093u, ">" },
  { 10094u, "<" },
  { 10095u, ">" },
  { 10096u, "<" },
  { 10097u, ">" },
  { 10098u, "[" },
  { 10099u, "]" },
  { 10100u, "{" },
  { 10101u, "}" },
  { 10102u, "((1))" },
  { 10103u, "((2))" },
  { 10104u, "((3))" },
  { 10105u, "((4))" },
  { 10106u, "((5))" },
  { 10107u, "((6))" },
  { 10108u, "((7))" },
  { 10109u, "((8))" },
  { 10110u, "((9))" },
  { 10111u, "((10))" },
  { 10112u, "(1)" },
  { 10113u, "(2)" },
  { 10114u, "(3)" },
  { 10115u, "(4)" },
  { 10116u, "(5)" },
  { 10117u, "(6)" },
  { 10118u, "(7)" },
  { 10119u, "(8)" },
  { 10120u, "(9)" },
  { 10121u, "(10)" },
  { 10122u, "((1))" },
  { 10123u, "((2))" },
  { 10124u, "((3))" },
  { 10125u, "((4))" },
  { 10126u, "((5))" },
  { 10127u, "((6))" },
  { 10128u, "((7))" },
  { 10129u, "((8))" },
  { 10130u, "((9))" },
  { 10131u, "((10))" },
  { 10132u, "->" },
  { 10136u, "\\v" },
  { 10137u, "->" },
  { 10138u, "/^" },
  { 10139u, "->" },
  { 10140u, "->" },
  { 10141u, "->" },
  { 10142u, "->" },
  { 10143u, "->" },
  { 10144u, "->" },
  { 10145u, "->" },
  { 10146u, ">" },
  { 10147u, ">" },
  { 10148u, ">" },
  { 10149u, "->" },
  { 10150u, "->" },
  { 10151u, "->" },
  { 10152u, "->" },
  { 10153u, "->" },
  { 10154u, "->" },
  { 10155u, "->" },
  { 10156u, "->" },
  { 10157u, "->" },
  { 10158u, "->" },
  { 10159u, "->" },
  { 10160u, "->" },
  { 10162u, "(->)" },
  { 10163u, ">>->" },
  { 10164u, "vv\\v" },
  { 10165u, ">>->" },
  { 10166u, "^^/^" },
  { 10167u, "vv\\v" },
  { 10168u, ">>->" },
  { 10169u, "^^/^" },
  { 10170u, "->" },
  { 10171u, "->" },
  { 10172u, "->" },
  { 10173u, "->" },
  { 10174u, "->" },
  { 10224u, "^||||" },
  { 10225u, "||||v" },
  { 10226u, "vO" },
  { 10227u, "Ov" },
  { 10228u, "(+)>" },
  { 10229u, "<---" },
  { 10230u, "--->" },
  { 10231u, "<--->" },
  { 10232u, "<===" },
  { 10233u, "===>" },
  { 10234u, "<===>" },
  { 10235u, "<---|" },
  { 10236u, "|--->" },
  { 10237u, "<===|" },
  { 10238u, "|===>" },
  { 10239u, "~~~>" },
  { 10496u, "-|->>" },
  { 10497u, "-||->>" },
  { 10498u, "<=|=" },
  { 10499u, "=|=>" },
  { 10500u, "<=|=>" },
  { 10501u, "|->>" },
  { 10502u, "<=|" },
  { 10503u, "|=>" },
  { 10504u, "|-|v" },
  { 10505u, "^|-|" },
  { 10506u, "^|||" },
  { 10507u, "|||v" },
  { 10508u, "<- -" },
  { 10509u, "- ->" },
  { 10510u, "<- - -" },
  { 10511u, "- - ->" },
  { 10512u, ">- - ->" },
  { 10513u, "->" },
  { 10515u, "|v_" },
  { 10516u, ">-|->" },
  { 10517u, ">-||->" },
  { 10518u, ">->>" },
  { 10519u, ">-|->>" },
  { 10520u, ">-||->>" },
  { 10521u, "-<" },
  { 10522u, ">-" },
  { 10523u, "-<<" },
  { 10524u, ">>-" },
  { 10525u, "<><-" },
  { 10526u, "-><>" },
  { 10527u, "<><-|" },
  { 10528u, "|-><>" },
  { 10529u, "^\\v" },
  { 10530u, "v/^" },
  { 10531u, "^\\," },
  { 10532u, ",/^" },
  { 10535u, "^X^" },
  { 10539u, (const char *)0x8174946 },
  { 10540u, (const char *)0x8174946 },
  { 10541u, "Xv^" },
  { 10542u, "X^v" },
  { 10543u, "X ^" },
  { 10544u, "X v" },
  { 10545u, "^X^" },
  { 10546u, "^X^" },
  { 10547u, "~>" },
  { 10548u, "-^" },
  { 10549u, "-v" },
  { 10552u, ")v" },
  { 10553u, "(v" },
  { 10565u, "->+" },
  { 10566u, "<-+" },
  { 10567u, "-x->" },
  { 10568u, "<-o->" },
  { 10569u, "^^|o" },
  { 10570u, "<->" },
  { 10571u, "<->" },
  { 10572u, "^|v" },
  { 10573u, "^|v" },
  { 10574u, "<->" },
  { 10575u, "^|v" },
  { 10576u, "<->" },
  { 10577u, "^|v" },
  { 10578u, "|<-" },
  { 10579u, "->|" },
  { 10581u, "|v_" },
  { 10582u, "|<-" },
  { 10583u, "->|" },
  { 10585u, "|v_" },
  { 10586u, "<-|" },
  { 10587u, "|->" },
  { 10588u, "^|_" },
  { 10590u, "<-|" },
  { 10591u, "|->" },
  { 10592u, "^|_" },
  { 10594u, "<=" },
  { 10595u, "^||" },
  { 10596u, "=>" },
  { 10597u, "||v" },
  { 10608u, "=)" },
  { 10752u, "(.)" },
  { 10753u, "(+)" },
  { 10754u, "(x)" },
  { 10761u, " *" },
  { 10764u, "\\int\\int\\int\\int " },
  { 10799u, (const char *)0x817498A },
  { 10800u, ".x" },
  { 10801u, "x_" },
  { 10803u, "xx" },
  { 10804u, "(x" },
  { 10805u, "x)" },
  { 10807u, "((x))" },
  { 10808u, "(/)" },
  { 10809u, "/+\\" },
  { 10810u, "/-\\" },
  { 10811u, "/x\\" },
  { 10868u, "::=" },
  { 10869u, "==" },
  { 10870u, "===" },
  { 10871u, ":=:" },
  { 11008u, "/^" },
  { 11009u, "^\\" },
  { 11010u, "\\v" },
  { 11011u, "v/" },
  { 11012u, "<->" },
  { 11013u, "<-" },
  { 11014u, "^|" },
  { 11015u, "|v" },
  { 11016u, "/^" },
  { 11017u, "^\\" },
  { 11018u, "\\v" },
  { 11019u, "v/" },
  { 11020u, "<->" },
  { 11021u, "^|v" },
  { 11022u, "-v" },
  { 11023u, "-^" },
  { 11024u, "v-" },
  { 11025u, "^-" },
  { 11791u, "__" },
  { 11806u, ".~" },
  { 11807u, "~." },
  { 11816u, "((" },
  { 11817u, "))" },
  { 11818u, ":." },
  { 11819u, ".:" },
  { 11820u, "::" },
  { 11823u, "~" },
  { 12289u, ",_" },
  { 12290u, "._" },
  { 12291u, "+\"" },
  { 12292u, "JIS" },
  { 12293u, "*_" },
  { 12294u, ";_" },
  { 12295u, "0_" },
  { 12298u, "<+" },
  { 12299u, ">+" },
  { 12300u, "<'" },
  { 12301u, ">'" },
  { 12302u, "<\"" },
  { 12303u, ">\"" },
  { 12304u, "(\"" },
  { 12305u, ")\"" },
  { 12306u, "=T" },
  { 12307u, "=_" },
  { 12308u, "('" },
  { 12309u, ")'" },
  { 12310u, "(I" },
  { 12311u, ")I" },
  { 12314u, "[[" },
  { 12315u, "]]" },
  { 12316u, "-?" },
  { 12320u, "=T:)" },
  { 12353u, "A5" },
  { 12354u, "a5" },
  { 12355u, "I5" },
  { 12356u, "i5" },
  { 12357u, "U5" },
  { 12358u, "u5" },
  { 12359u, "E5" },
  { 12360u, "e5" },
  { 12361u, "O5" },
  { 12362u, "o5" },
  { 12363u, "ka" },
  { 12364u, "ga" },
  { 12365u, "ki" },
  { 12366u, "gi" },
  { 12367u, "ku" },
  { 12368u, "gu" },
  { 12369u, "ke" },
  { 12370u, "ge" },
  { 12371u, "ko" },
  { 12372u, "go" },
  { 12373u, "sa" },
  { 12374u, "za" },
  { 12375u, "si" },
  { 12376u, "zi" },
  { 12377u, "su" },
  { 12378u, "zu" },
  { 12379u, "se" },
  { 12380u, "ze" },
  { 12381u, "so" },
  { 12382u, "zo" },
  { 12383u, "ta" },
  { 12384u, "da" },
  { 12385u, "ti" },
  { 12386u, "di" },
  { 12387u, "tU" },
  { 12388u, "tu" },
  { 12389u, "du" },
  { 12390u, "te" },
  { 12391u, "de" },
  { 12392u, "to" },
  { 12393u, "do" },
  { 12394u, "na" },
  { 12395u, "ni" },
  { 12396u, "nu" },
  { 12397u, "ne" },
  { 12398u, "no" },
  { 12399u, "ha" },
  { 12400u, "ba" },
  { 12401u, "pa" },
  { 12402u, "hi" },
  { 12403u, "bi" },
  { 12404u, "pi" },
  { 12405u, "hu" },
  { 12406u, "bu" },
  { 12407u, "pu" },
  { 12408u, "he" },
  { 12409u, "be" },
  { 12410u, "pe" },
  { 12411u, "ho" },
  { 12412u, "bo" },
  { 12413u, "po" },
  { 12414u, "ma" },
  { 12415u, "mi" },
  { 12416u, "mu" },
  { 12417u, "me" },
  { 12418u, "mo" },
  { 12419u, "yA" },
  { 12420u, "ya" },
  { 12421u, "yU" },
  { 12422u, "yu" },
  { 12423u, "yO" },
  { 12424u, "yo" },
  { 12425u, "ra" },
  { 12426u, "ri" },
  { 12427u, "ru" },
  { 12428u, "re" },
  { 12429u, "ro" },
  { 12430u, "wA" },
  { 12431u, "wa" },
  { 12432u, "wi" },
  { 12433u, "we" },
  { 12434u, "wo" },
  { 12435u, "n5" },
  { 12436u, "vu" },
  { 12443u, "\"5" },
  { 12444u, "05" },
  { 12445u, "*5" },
  { 12446u, "+5" },
  { 12449u, "a6" },
  { 12450u, "A6" },
  { 12451u, "i6" },
  { 12452u, "I6" },
  { 12453u, "u6" },
  { 12454u, "U6" },
  { 12455u, "e6" },
  { 12456u, "E6" },
  { 12457u, "o6" },
  { 12458u, "O6" },
  { 12459u, "Ka" },
  { 12460u, "Ga" },
  { 12461u, "Ki" },
  { 12462u, "Gi" },
  { 12463u, "Ku" },
  { 12464u, "Gu" },
  { 12465u, "Ke" },
  { 12466u, "Ge" },
  { 12467u, "Ko" },
  { 12468u, "Go" },
  { 12469u, "Sa" },
  { 12470u, "Za" },
  { 12471u, "Si" },
  { 12472u, "Zi" },
  { 12473u, "Su" },
  { 12474u, "Zu" },
  { 12475u, "Se" },
  { 12476u, "Ze" },
  { 12477u, "So" },
  { 12478u, "Zo" },
  { 12479u, "Ta" },
  { 12480u, "Da" },
  { 12481u, "Ti" },
  { 12482u, "Di" },
  { 12483u, "TU" },
  { 12484u, "Tu" },
  { 12485u, "Du" },
  { 12486u, "Te" },
  { 12487u, "De" },
  { 12488u, "To" },
  { 12489u, "Do" },
  { 12490u, "Na" },
  { 12491u, "Ni" },
  { 12492u, "Nu" },
  { 12493u, "Ne" },
  { 12494u, "No" },
  { 12495u, "Ha" },
  { 12496u, "Ba" },
  { 12497u, "Pa" },
  { 12498u, "Hi" },
  { 12499u, "Bi" },
  { 12500u, "Pi" },
  { 12501u, "Hu" },
  { 12502u, "Bu" },
  { 12503u, "Pu" },
  { 12504u, "He" },
  { 12505u, "Be" },
  { 12506u, "Pe" },
  { 12507u, "Ho" },
  { 12508u, "Bo" },
  { 12509u, "Po" },
  { 12510u, "Ma" },
  { 12511u, "Mi" },
  { 12512u, "Mu" },
  { 12513u, "Me" },
  { 12514u, "Mo" },
  { 12515u, "YA" },
  { 12516u, "Ya" },
  { 12517u, "YU" },
  { 12518u, "Yu" },
  { 12519u, "YO" },
  { 12520u, "Yo" },
  { 12521u, "Ra" },
  { 12522u, "Ri" },
  { 12523u, "Ru" },
  { 12524u, "Re" },
  { 12525u, "Ro" },
  { 12526u, "WA" },
  { 12527u, "Wa" },
  { 12528u, "Wi" },
  { 12529u, "We" },
  { 12530u, "Wo" },
  { 12531u, "N6" },
  { 12532u, "Vu" },
  { 12533u, "KA" },
  { 12534u, "KE" },
  { 12535u, "Va" },
  { 12536u, "Vi" },
  { 12537u, "Ve" },
  { 12538u, "Vo" },
  { 12539u, ".6" },
  { 12540u, "-6" },
  { 12541u, "*6" },
  { 12542u, "+6" },
  { 12549u, "b4" },
  { 12550u, "p4" },
  { 12551u, "m4" },
  { 12552u, "f4" },
  { 12553u, "d4" },
  { 12554u, "t4" },
  { 12555u, "n4" },
  { 12556u, "l4" },
  { 12557u, "g4" },
  { 12558u, "k4" },
  { 12559u, "h4" },
  { 12560u, "j4" },
  { 12561u, "q4" },
  { 12562u, "x4" },
  { 12563u, "zh" },
  { 12564u, "ch" },
  { 12565u, "sh" },
  { 12566u, "r4" },
  { 12567u, "z4" },
  { 12568u, "c4" },
  { 12569u, "s4" },
  { 12570u, "a4" },
  { 12571u, "o4" },
  { 12572u, "e4" },
  { 12573u, "eh4" },
  { 12574u, "ai" },
  { 12575u, "ei" },
  { 12576u, "au" },
  { 12577u, "ou" },
  { 12578u, "an" },
  { 12579u, "en" },
  { 12580u, "aN" },
  { 12581u, "eN" },
  { 12582u, "er" },
  { 12583u, "i4" },
  { 12584u, "u4" },
  { 12585u, "iu" },
  { 12586u, "v4" },
  { 12587u, "nG" },
  { 12588u, "gn" },
  { 12828u, "(JU)" },
  { 12832u, "1c" },
  { 12833u, "2c" },
  { 12834u, "3c" },
  { 12835u, "4c" },
  { 12836u, "5c" },
  { 12837u, "6c" },
  { 12838u, "7c" },
  { 12839u, "8c" },
  { 12840u, "9c" },
  { 12841u, "10c" },
  { 12927u, "KSC" },
  { 13250u, "am" },
  { 13272u, "pm" },
  { 64256u, "ff" },
  { 64257u, "fi" },
  { 64258u, "fl" },
  { 64259u, "ffi" },
  { 64260u, "ffl" },
  { 64261u, "St" },
  { 64262u, "st" },
  { 65149u, "3+;" },
  { 65154u, "aM." },
  { 65156u, "aH." },
  { 65160u, "ah." },
  { 65165u, "a+-" },
  { 65166u, "a+." },
  { 65167u, "b+-" },
  { 65168u, "b+." },
  { 65169u, "b+," },
  { 65170u, "b+;" },
  { 65171u, "tm-" },
  { 65172u, "tm." },
  { 65173u, "t+-" },
  { 65174u, "t+." },
  { 65175u, "t+," },
  { 65176u, "t+;" },
  { 65177u, "tk-" },
  { 65178u, "tk." },
  { 65179u, "tk," },
  { 65180u, "tk;" },
  { 65181u, "g+-" },
  { 65182u, "g+." },
  { 65183u, "g+," },
  { 65184u, "g+;" },
  { 65185u, "hk-" },
  { 65186u, "hk." },
  { 65187u, "hk," },
  { 65188u, "hk;" },
  { 65189u, "x+-" },
  { 65190u, "x+." },
  { 65191u, "x+," },
  { 65192u, "x+;" },
  { 65193u, "d+-" },
  { 65194u, "d+." },
  { 65195u, "dk-" },
  { 65196u, "dk." },
  { 65197u, "r+-" },
  { 65198u, "r+." },
  { 65199u, "z+-" },
  { 65200u, "z+." },
  { 65201u, "s+-" },
  { 65202u, "s+." },
  { 65203u, "s+," },
  { 65204u, "s+;" },
  { 65205u, "sn-" },
  { 65206u, "sn." },
  { 65207u, "sn," },
  { 65208u, "sn;" },
  { 65209u, "c+-" },
  { 65210u, "c+." },
  { 65211u, "c+," },
  { 65212u, "c+;" },
  { 65213u, "dd-" },
  { 65214u, "dd." },
  { 65215u, "dd," },
  { 65216u, "dd;" },
  { 65217u, "tj-" },
  { 65218u, "tj." },
  { 65219u, "tj," },
  { 65220u, "tj;" },
  { 65221u, "zH-" },
  { 65222u, "zH." },
  { 65223u, "zH," },
  { 65224u, "zH;" },
  { 65225u, "e+-" },
  { 65226u, "e+." },
  { 65227u, "e+," },
  { 65228u, "e+;" },
  { 65229u, "i+-" },
  { 65230u, "i+." },
  { 65231u, "i+," },
  { 65232u, "i+;" },
  { 65233u, "f+-" },
  { 65234u, "f+." },
  { 65235u, "f+," },
  { 65236u, "f+;" },
  { 65237u, "q+-" },
  { 65238u, "q+." },
  { 65239u, "q+," },
  { 65240u, "q+;" },
  { 65241u, "k+-" },
  { 65242u, "k+." },
  { 65243u, "k+," },
  { 65244u, "k+;" },
  { 65245u, "l+-" },
  { 65246u, "l+." },
  { 65247u, "l+," },
  { 65248u, "l+;" },
  { 65249u, "m+-" },
  { 65250u, "m+." },
  { 65251u, "m+," },
  { 65252u, "m+;" },
  { 65253u, "n+-" },
  { 65254u, "n+." },
  { 65255u, "n+," },
  { 65256u, "n+;" },
  { 65257u, "h+-" },
  { 65258u, "h+." },
  { 65259u, "h+," },
  { 65260u, "h+;" },
  { 65261u, "w+-" },
  { 65262u, "w+." },
  { 65263u, "j+-" },
  { 65264u, "j+." },
  { 65265u, "y+-" },
  { 65266u, "y+." },
  { 65267u, "y+," },
  { 65268u, "y+;" },
  { 65269u, "lM-" },
  { 65270u, "lM." },
  { 65271u, "lH-" },
  { 65272u, "lH." },
  { 65273u, "lh-" },
  { 65274u, "lh." },
  { 65275u, "la-" },
  { 65276u, "la." },
  { 65279u, &unk_8175347 },
  { 0u, "NUL" },
  { 1u, "SH" },
  { 2u, "SX" },
  { 3u, "EX" },
  { 4u, "ET" },
  { 5u, "ENQ" },
  { 6u, "AK" },
  { 7u, "BL" },
  { 8u, "BS" },
  { 9u, "HT" },
  { 10u, "LF" },
  { 11u, "VT" },
  { 12u, "FF" },
  { 13u, "CR" },
  { 14u, "SO" },
  { 15u, "SI" },
  { 16u, "DL" },
  { 17u, "DC1" },
  { 18u, "DC2" },
  { 19u, "DC3" },
  { 20u, "DC4" },
  { 21u, "NAK" },
  { 22u, "SYN" },
  { 23u, "EB" },
  { 24u, "CN" },
  { 25u, "EM" },
  { 26u, "SB" },
  { 27u, "ESC" },
  { 28u, "FS" },
  { 29u, "GS" },
  { 30u, "RS" },
  { 31u, "US" },
  { 127u, "DT" },
  { 133u, "\n" }
}; // idb
const char *UC_GNsetMIMEnames[4] = { "iso-8859-1", "x-dec-graphics", "cp437", "x-transparent" }; // idb
int UC_GNhandles[4] = { -1, -1, -1, -1 }; // idb
unsigned __int16 translations[4][256] =
{
  {
    0u,
    1u,
    2u,
    3u,
    4u,
    5u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    30u,
    31u,
    32u,
    33u,
    34u,
    35u,
    36u,
    37u,
    38u,
    39u,
    40u,
    41u,
    42u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    63u,
    64u,
    65u,
    66u,
    67u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    85u,
    86u,
    87u,
    88u,
    89u,
    90u,
    91u,
    92u,
    93u,
    94u,
    95u,
    96u,
    97u,
    98u,
    99u,
    100u,
    101u,
    102u,
    103u,
    104u,
    105u,
    106u,
    107u,
    108u,
    109u,
    110u,
    111u,
    112u,
    113u,
    114u,
    115u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    122u,
    123u,
    124u,
    125u,
    126u,
    127u,
    128u,
    129u,
    130u,
    131u,
    132u,
    133u,
    134u,
    135u,
    136u,
    137u,
    138u,
    139u,
    140u,
    141u,
    142u,
    143u,
    144u,
    145u,
    146u,
    147u,
    148u,
    149u,
    150u,
    151u,
    152u,
    153u,
    154u,
    155u,
    156u,
    157u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    166u,
    167u,
    168u,
    169u,
    170u,
    171u,
    172u,
    173u,
    174u,
    175u,
    176u,
    177u,
    178u,
    179u,
    180u,
    181u,
    182u,
    183u,
    184u,
    185u,
    186u,
    187u,
    188u,
    189u,
    190u,
    191u,
    192u,
    193u,
    194u,
    195u,
    196u,
    197u,
    198u,
    199u,
    200u,
    201u,
    202u,
    203u,
    204u,
    205u,
    206u,
    207u,
    208u,
    209u,
    210u,
    211u,
    212u,
    213u,
    214u,
    215u,
    216u,
    217u,
    218u,
    219u,
    220u,
    221u,
    222u,
    223u,
    224u,
    225u,
    226u,
    227u,
    228u,
    229u,
    230u,
    231u,
    232u,
    233u,
    234u,
    235u,
    236u,
    237u,
    238u,
    239u,
    240u,
    241u,
    242u,
    243u,
    244u,
    245u,
    246u,
    247u,
    248u,
    249u,
    250u,
    251u,
    252u,
    253u,
    254u,
    255u
  },
  {
    0u,
    1u,
    2u,
    3u,
    4u,
    5u,
    6u,
    7u,
    8u,
    9u,
    10u,
    11u,
    12u,
    13u,
    14u,
    15u,
    16u,
    17u,
    18u,
    19u,
    20u,
    21u,
    22u,
    23u,
    24u,
    25u,
    26u,
    27u,
    28u,
    29u,
    30u,
    31u,
    32u,
    33u,
    34u,
    35u,
    36u,
    37u,
    38u,
    39u,
    40u,
    41u,
    42u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    63u,
    64u,
    65u,
    66u,
    67u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    85u,
    86u,
    87u,
    88u,
    89u,
    90u,
    91u,
    92u,
    93u,
    94u,
    160u,
    9670u,
    9618u,
    9225u,
    9228u,
    9229u,
    9226u,
    176u,
    177u,
    9252u,
    9227u,
    9496u,
    9488u,
    9484u,
    9492u,
    9532u,
    63488u,
    63489u,
    9472u,
    63491u,
    63492u,
    9500u,
    9508u,
    9524u,
    9516u,
    9474u,
    8804u,
    8805u,
    960u,
    8800u,
    163u,
    183u,
    127u,
    128u,
    129u,
    130u,
    131u,
    132u,
    133u,
    134u,
    135u,
    136u,
    137u,
    138u,
    139u,
    140u,
    141u,
    142u,
    143u,
    144u,
    145u,
    146u,
    147u,
    148u,
    149u,
    150u,
    151u,
    152u,
    153u,
    154u,
    155u,
    156u,
    157u,
    158u,
    159u,
    160u,
    161u,
    162u,
    163u,
    164u,
    165u,
    166u,
    167u,
    168u,
    169u,
    170u,
    171u,
    172u,
    173u,
    174u,
    175u,
    176u,
    177u,
    178u,
    179u,
    180u,
    181u,
    182u,
    183u,
    184u,
    185u,
    186u,
    187u,
    188u,
    189u,
    190u,
    191u,
    192u,
    193u,
    194u,
    195u,
    196u,
    197u,
    198u,
    199u,
    200u,
    201u,
    202u,
    203u,
    204u,
    205u,
    206u,
    207u,
    208u,
    209u,
    210u,
    211u,
    212u,
    213u,
    214u,
    215u,
    216u,
    217u,
    218u,
    219u,
    220u,
    221u,
    222u,
    223u,
    224u,
    225u,
    226u,
    227u,
    228u,
    229u,
    230u,
    231u,
    232u,
    233u,
    234u,
    235u,
    236u,
    237u,
    238u,
    239u,
    240u,
    241u,
    242u,
    243u,
    244u,
    245u,
    246u,
    247u,
    248u,
    249u,
    250u,
    251u,
    252u,
    253u,
    254u,
    255u
  },
  {
    0u,
    9786u,
    9787u,
    9829u,
    9830u,
    9827u,
    9824u,
    8226u,
    9688u,
    9675u,
    9689u,
    9794u,
    9792u,
    9834u,
    9835u,
    9788u,
    9658u,
    9668u,
    8597u,
    8252u,
    182u,
    167u,
    9644u,
    8616u,
    8593u,
    8595u,
    8594u,
    8592u,
    8735u,
    8596u,
    9650u,
    9660u,
    32u,
    33u,
    34u,
    35u,
    36u,
    37u,
    38u,
    39u,
    40u,
    41u,
    42u,
    43u,
    44u,
    45u,
    46u,
    47u,
    48u,
    49u,
    50u,
    51u,
    52u,
    53u,
    54u,
    55u,
    56u,
    57u,
    58u,
    59u,
    60u,
    61u,
    62u,
    63u,
    64u,
    65u,
    66u,
    67u,
    68u,
    69u,
    70u,
    71u,
    72u,
    73u,
    74u,
    75u,
    76u,
    77u,
    78u,
    79u,
    80u,
    81u,
    82u,
    83u,
    84u,
    85u,
    86u,
    87u,
    88u,
    89u,
    90u,
    91u,
    92u,
    93u,
    94u,
    95u,
    96u,
    97u,
    98u,
    99u,
    100u,
    101u,
    102u,
    103u,
    104u,
    105u,
    106u,
    107u,
    108u,
    109u,
    110u,
    111u,
    112u,
    113u,
    114u,
    115u,
    116u,
    117u,
    118u,
    119u,
    120u,
    121u,
    122u,
    123u,
    124u,
    125u,
    126u,
    8962u,
    199u,
    252u,
    233u,
    226u,
    228u,
    224u,
    229u,
    231u,
    234u,
    235u,
    232u,
    239u,
    238u,
    236u,
    196u,
    197u,
    201u,
    230u,
    198u,
    244u,
    246u,
    242u,
    251u,
    249u,
    255u,
    214u,
    220u,
    162u,
    163u,
    165u,
    8359u,
    402u,
    225u,
    237u,
    243u,
    250u,
    241u,
    209u,
    170u,
    186u,
    191u,
    8976u,
    172u,
    189u,
    188u,
    161u,
    171u,
    187u,
    9617u,
    9618u,
    9619u,
    9474u,
    9508u,
    9569u,
    9570u,
    9558u,
    9557u,
    9571u,
    9553u,
    9559u,
    9565u,
    9564u,
    9563u,
    9488u,
    9492u,
    9524u,
    9516u,
    9500u,
    9472u,
    9532u,
    9566u,
    9567u,
    9562u,
    9556u,
    9577u,
    9574u,
    9568u,
    9552u,
    9580u,
    9575u,
    9576u,
    9572u,
    9573u,
    9561u,
    9560u,
    9554u,
    9555u,
    9579u,
    9578u,
    9496u,
    9484u,
    9608u,
    9604u,
    9612u,
    9616u,
    9600u,
    945u,
    223u,
    915u,
    960u,
    931u,
    963u,
    181u,
    964u,
    934u,
    920u,
    937u,
    948u,
    8734u,
    966u,
    949u,
    8745u,
    8801u,
    177u,
    8805u,
    8804u,
    8992u,
    8993u,
    247u,
    8776u,
    176u,
    8729u,
    183u,
    8730u,
    8319u,
    178u,
    9632u,
    160u
  },
  {
    61440u,
    61441u,
    61442u,
    61443u,
    61444u,
    61445u,
    61446u,
    61447u,
    61448u,
    61449u,
    61450u,
    61451u,
    61452u,
    61453u,
    61454u,
    61455u,
    61456u,
    61457u,
    61458u,
    61459u,
    61460u,
    61461u,
    61462u,
    61463u,
    61464u,
    61465u,
    61466u,
    61467u,
    61468u,
    61469u,
    61470u,
    61471u,
    61472u,
    61473u,
    61474u,
    61475u,
    61476u,
    61477u,
    61478u,
    61479u,
    61480u,
    61481u,
    61482u,
    61483u,
    61484u,
    61485u,
    61486u,
    61487u,
    61488u,
    61489u,
    61490u,
    61491u,
    61492u,
    61493u,
    61494u,
    61495u,
    61496u,
    61497u,
    61498u,
    61499u,
    61500u,
    61501u,
    61502u,
    61503u,
    61504u,
    61505u,
    61506u,
    61507u,
    61508u,
    61509u,
    61510u,
    61511u,
    61512u,
    61513u,
    61514u,
    61515u,
    61516u,
    61517u,
    61518u,
    61519u,
    61520u,
    61521u,
    61522u,
    61523u,
    61524u,
    61525u,
    61526u,
    61527u,
    61528u,
    61529u,
    61530u,
    61531u,
    61532u,
    61533u,
    61534u,
    61535u,
    61536u,
    61537u,
    61538u,
    61539u,
    61540u,
    61541u,
    61542u,
    61543u,
    61544u,
    61545u,
    61546u,
    61547u,
    61548u,
    61549u,
    61550u,
    61551u,
    61552u,
    61553u,
    61554u,
    61555u,
    61556u,
    61557u,
    61558u,
    61559u,
    61560u,
    61561u,
    61562u,
    61563u,
    61564u,
    61565u,
    61566u,
    61567u,
    61568u,
    61569u,
    61570u,
    61571u,
    61572u,
    61573u,
    61574u,
    61575u,
    61576u,
    61577u,
    61578u,
    61579u,
    61580u,
    61581u,
    61582u,
    61583u,
    61584u,
    61585u,
    61586u,
    61587u,
    61588u,
    61589u,
    61590u,
    61591u,
    61592u,
    61593u,
    61594u,
    61595u,
    61596u,
    61597u,
    61598u,
    61599u,
    61600u,
    61601u,
    61602u,
    61603u,
    61604u,
    61605u,
    61606u,
    61607u,
    61608u,
    61609u,
    61610u,
    61611u,
    61612u,
    61613u,
    61614u,
    61615u,
    61616u,
    61617u,
    61618u,
    61619u,
    61620u,
    61621u,
    61622u,
    61623u,
    61624u,
    61625u,
    61626u,
    61627u,
    61628u,
    61629u,
    61630u,
    61631u,
    61632u,
    61633u,
    61634u,
    61635u,
    61636u,
    61637u,
    61638u,
    61639u,
    61640u,
    61641u,
    61642u,
    61643u,
    61644u,
    61645u,
    61646u,
    61647u,
    61648u,
    61649u,
    61650u,
    61651u,
    61652u,
    61653u,
    61654u,
    61655u,
    61656u,
    61657u,
    61658u,
    61659u,
    61660u,
    61661u,
    61662u,
    61663u,
    61664u,
    61665u,
    61666u,
    61667u,
    61668u,
    61669u,
    61670u,
    61671u,
    61672u,
    61673u,
    61674u,
    61675u,
    61676u,
    61677u,
    61678u,
    61679u,
    61680u,
    61681u,
    61682u,
    61683u,
    61684u,
    61685u,
    61686u,
    61687u,
    61688u,
    61689u,
    61690u,
    61691u,
    61692u,
    61693u,
    61694u,
    61695u
  }
}; // idb
int default_UChndl = -1; // idb
int UCLYhndl_HTFile_for_unspec = -1; // idb
int UCLYhndl_for_unspec = -1; // idb
int UCLYhndl_for_unrec = -1; // idb
int LATIN1 = -1; // idb
int US_ASCII = -1; // idb
int UTF8_handle = -1; // idb
int TRANSPARENT = -1; // idb
dired_menu defmenu[32] =
{
  {
    0,
    &byte_817D5C4,
    "Change directory",
    &byte_817D5C4,
    "LYNXDIRED://CHDIR",
    NULL
  },
  {
    0,
    &byte_817D5C4,
    "New File",
    "(in current directory)",
    "LYNXDIRED://NEW_FILE%d",
    NULL
  },
  {
    0,
    &byte_817D5C4,
    "New Directory",
    "(in current directory)",
    "LYNXDIRED://NEW_FOLDER%d",
    NULL
  },
  {
    3,
    &byte_817D5C4,
    "Modify File Name",
    "(of current selection)",
    "LYNXDIRED://MODIFY_NAME%p",
    NULL
  },
  {
    2,
    &byte_817D5C4,
    "Modify Directory Name",
    "(of current selection)",
    "LYNXDIRED://MODIFY_NAME%p",
    NULL
  },
  {
    4,
    &byte_817D5C4,
    "Modify Name",
    "(of selected symbolic link)",
    "LYNXDIRED://MODIFY_NAME%p",
    NULL
  },
  {
    3,
    &byte_817D5C4,
    "Modify File Permissions",
    "(of current selection)",
    "LYNXDIRED://PERMIT_SRC%p",
    NULL
  },
  {
    2,
    &byte_817D5C4,
    "Modify Directory Permissions",
    "(of current selection)",
    "LYNXDIRED://PERMIT_SRC%p",
    NULL
  },
  {
    3,
    &byte_817D5C4,
    "Change Location",
    "(of selected file)",
    "LYNXDIRED://MODIFY_LOCATION%p",
    NULL
  },
  {
    2,
    &byte_817D5C4,
    "Change Location",
    "(of selected directory)",
    "LYNXDIRED://MODIFY_LOCATION%p",
    NULL
  },
  {
    4,
    &byte_817D5C4,
    "Change Location",
    "(of selected symbolic link)",
    "LYNXDIRED://MODIFY_LOCATION%p",
    NULL
  },
  {
    3,
    &byte_817D5C4,
    "Remove File",
    "(current selection)",
    "LYNXDIRED://REMOVE_SINGLE%p",
    NULL
  },
  {
    2,
    &byte_817D5C4,
    "Remove Directory",
    "(current selection)",
    "LYNXDIRED://REMOVE_SINGLE%p",
    NULL
  },
  {
    4,
    &byte_817D5C4,
    "Remove Symbolic Link",
    "(current selection)",
    "LYNXDIRED://REMOVE_SINGLE%p",
    NULL
  },
  {
    3,
    &byte_817D5C4,
    "UUDecode",
    "(current selection)",
    "LYNXDIRED://UUDECODE%p",
    NULL
  },
  {
    3,
    ".tar.Z",
    "Expand",
    "(current selection)",
    "LYNXDIRED://UNTAR_Z%p",
    NULL
  },
  {
    3,
    ".tar.gz",
    "Expand",
    "(current selection)",
    "LYNXDIRED://UNTAR_GZ%p",
    NULL
  },
  { 3, ".tgz", "Expand", "(current selection)", "LYNXDIRED://UNTAR_GZ%p", NULL },
  {
    3,
    ".Z",
    "Uncompress",
    "(current selection)",
    "LYNXDIRED://DECOMPRESS%p",
    NULL
  },
  {
    3,
    ".gz",
    "Uncompress",
    "(current selection)",
    "LYNXDIRED://UNGZIP%p",
    NULL
  },
  {
    3,
    ".zip",
    "Uncompress",
    "(current selection)",
    "LYNXDIRED://UNZIP%p",
    NULL
  },
  { 3, ".tar", "UnTar", "(current selection)", "LYNXDIRED://UNTAR%p", NULL },
  { 2, &byte_817D5C4, "Tar", "(current selection)", "LYNXDIRED://TAR%p", NULL },
  {
    2,
    &byte_817D5C4,
    "Tar and compress",
    "(using GNU gzip)",
    "LYNXDIRED://TAR_GZ%p",
    NULL
  },
  {
    2,
    &byte_817D5C4,
    "Package and compress",
    "(using zip)",
    "LYNXDIRED://ZIP%p",
    NULL
  },
  {
    3,
    &byte_817D5C4,
    "Compress",
    "(using Unix compress)",
    "LYNXDIRED://COMPRESS%p",
    NULL
  },
  { 3, &byte_817D5C4, "Compress", "(using gzip)", "LYNXDIRED://GZIP%p", NULL },
  { 3, &byte_817D5C4, "Compress", "(using zip)", "LYNXDIRED://ZIP%p", NULL },
  {
    1,
    &byte_817D5C4,
    "Move all tagged items to another location.",
    &byte_817D5C4,
    "LYNXDIRED://MOVE_TAGGED%d",
    NULL
  },
  {
    1,
    &byte_817D5C4,
    "Remove all tagged files and directories.",
    &byte_817D5C4,
    "LYNXDIRED://REMOVE_TAGGED",
    NULL
  },
  {
    1,
    &byte_817D5C4,
    "Untag all tagged files and directories.",
    &byte_817D5C4,
    "LYNXDIRED://CLEAR_TAGGED",
    NULL
  },
  { 0, NULL, NULL, NULL, NULL, NULL }
}; // idb
char LYValidPermitFile[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char tempfile_11559[256] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char empty_string_8447[4] = { '\0', '\0', '\0', '\0' }; // idb
const char *hex_0 = "0123456789ABCDEF"; // idb
int pushed_assume_LYhndl = -1; // idb
char *empty_11000 = &byte_817F5C0; // idb
HTProtocol HTTP = { "http", &HTLoadHTTP, NULL }; // idb
HTProtocol HTTPS = { "https", &HTLoadHTTP, NULL }; // idb
int HTDirAccess = 2; // idb
const char *HTMountRoot = "/Net/"; // idb
const char *HTCacheRoot = "/tmp/W3_Cache_"; // idb
HTSuffix no_suffix = { "*", NULL, NULL, NULL, 1.0 }; // idb
HTSuffix unknown_suffix = { "*.*", NULL, NULL, NULL, 1.0 }; // idb
const char *ptbits_11098[9] = { "--T", "--t", "-wT", "-wt", "r-T", "r-t", "rwT", "rwt", NULL }; // idb
const char *psbits_11097[9] = { "--S", "--s", "-wS", "-ws", "r-S", "r-s", "rwS", "rws", NULL }; // idb
const char *pbits_11096[9] = { "---", "--x", "-w-", "-wx", "r--", "r-x", "rw-", "rwx", NULL }; // idb
HTProtocol HTFTP = { "ftp", &HTLoadFile, NULL }; // idb
HTProtocol HTFile = { "file", &HTLoadFile, &HTFileSaveStream }; // idb
int data_soc = -1; // idb
BOOLEAN firstuse_10755 = '\x01'; // idb
const char *months[12] =
{
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
}; // idb
int TREAT_SJIS = 1; // idb
const char *table_15794[63] =
{
  &unk_818396C,
  &unk_818396F,
  &unk_8183972,
  &unk_8183975,
  &unk_8183978,
  &unk_818397B,
  &unk_818397E,
  &unk_8183981,
  &unk_8183984,
  &unk_8183987,
  &unk_818398A,
  &unk_818398D,
  &unk_8183990,
  &unk_8183993,
  &unk_8183996,
  &unk_8183999,
  &unk_818399C,
  &unk_818399F,
  &unk_81839A2,
  &unk_81839A5,
  &unk_81839A8,
  &unk_81839AB,
  &unk_81839AE,
  &unk_81839B1,
  &unk_81839B4,
  &unk_81839B7,
  &unk_81839BA,
  &unk_81839BD,
  &unk_81839C0,
  &unk_81839C3,
  &unk_81839C6,
  &unk_81839C9,
  &unk_81839CC,
  &unk_81839CF,
  &unk_81839D2,
  &unk_81839D5,
  &unk_81839D8,
  &unk_81839DB,
  &unk_81839DE,
  &unk_81839E1,
  &unk_81839E4,
  &unk_81839E7,
  &unk_81839EA,
  &unk_81839ED,
  &unk_81839F0,
  &unk_81839F3,
  &unk_81839F6,
  &unk_81839F9,
  &unk_81839FC,
  &unk_81839FF,
  &unk_8183A02,
  &unk_8183A05,
  &unk_8183A08,
  &unk_8183A0B,
  &unk_8183A0E,
  &unk_8183A11,
  &unk_8183A14,
  &unk_8183A17,
  &unk_8183A1A,
  &unk_8183A1D,
  &unk_8183A20,
  &unk_8183A23,
  &unk_8183A26
}; // idb
int HTPlain_lastraw = -1; // idb
const char *HTLibraryVersion = "2.14"; // idb
float HTMaxSecs = 1.0e10; // idb
char dummy_head_11307[2] = { 'x', '\x01' }; // idb
HTStreamClass NetToTextClass =
{
  "NetToText",
  &NetToText_free,
  &NetToText_abort,
  &NetToText_put_character,
  &NetToText_put_string,
  &NetToText_put_block
}; // idb
char HTmm64[66] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; // idb
char HTmmquote[17] = "0123456789ABCDEF"; // idb
int HTNewsChunkSize = 30; // idb
int HTNewsMaxChunk = 40; // idb
char empty_11029[4] = { '\0', '\0', '\0', '\0' }; // idb
HTProtocol HTNews = { "news", &HTLoadNews, NULL }; // idb
HTProtocol HTNNTP = { "nntp", &HTLoadNews, NULL }; // idb
HTProtocol HTNewsPost = { "newspost", &HTLoadNews, NULL }; // idb
HTProtocol HTNewsReply = { "newsreply", &HTLoadNews, NULL }; // idb
HTProtocol HTSNews = { "snews", &HTLoadNews, NULL }; // idb
HTProtocol HTSNewsPost = { "snewspost", &HTLoadNews, NULL }; // idb
HTProtocol HTSNewsReply = { "snewsreply", &HTLoadNews, NULL }; // idb
const char *ctemplate_10585[25] =
{
  "<HTML>\n<HEAD>\n<TITLE>CSO/PH Query Form for $(HOST)</TITLE>\n</HEAD>\n<BODY>",
  "<H2><I>CSO/PH Query Form</I> for <EM>$(HOST)</EM></H2>",
  "To search the database for a name, fill in one or more of the fields",
  "in the form below and activate the 'Submit query' button.  At least",
  "one of the entered fields must be flagged as indexed.",
  "<HR><FORM method=\"POST\" action=\"cso://$(HOST)/\">",
  "[ <input type=\"submit\" value=\"Submit query\"> | ",
  "<input type=\"reset\" value=\"Clear fields\"> ]",
  "<P><DL>",
  "   <DT>Search parameters (* indicates indexed field):",
  "   <DD>",
  "$(NAMEFLD)    <DL COMPACT>\n    <DT><I>$(FDESC)</I>$(FNDX)",
  "    <DD>Last: <input name=\"q_$(FID)\" type=\"text\" size=49$(FSIZE2)>",
  "    <DD>First: <input name=\"q_$(FID)\" type=\"text\" size=48$(FSIZE2)>",
  "$(QFIELDS)    <DT><I>$(FDESC)</I>$(FNDX)",
  "    <DD><input name=\"q_$(FID)\" type=\"text\" $(FSIZE)>\n$(NEXTFLD)",
  "    </DL>",
  "   </DL>\n<P><DL>",
  "   <DT>Output format:",
  "   <DD>Returned data option: <select name=\"return\">",
  "    <option>default<option selected>all<option>selected</select><BR>",
  "$(RFIELDS)    <input type=\"checkbox\" name=\"r_$(FID)\"$(FDEF)> $(FDESC)<BR>",
  "$(NEXTFLD)    ",
  "   </DL></FORM><HR>\n</BODY>\n</HTML>",
  NULL
}; // idb
HTProtocol HTGopher = { "gopher", &HTLoadGopher, NULL }; // idb
HTProtocol HTCSO = { "cso", &HTLoadCSO, NULL }; // idb
HTProtocol HTTelnet = { "telnet", &HTLoadTelnet, NULL }; // idb
HTProtocol HTRlogin = { "rlogin", &HTLoadTelnet, NULL }; // idb
HTProtocol HTTn3270 = { "tn3270", &HTLoadTelnet, NULL }; // idb
HTProtocol HTFinger = { "finger", &HTLoadFinger, NULL }; // idb
const char *par_name[24] =
{
  "version",
  "ip-address",
  "ip-name",
  "tcp-port",
  "database-name",
  "cost",
  "cost-unit",
  "free",
  "maintainer",
  "description",
  "keyword-list",
  "source",
  "window-geometry",
  "configuration",
  "script",
  "update-time",
  "contact-at",
  "last-contacted",
  "confidence",
  "num-docs-to-request",
  "font",
  "font-size",
  "unknown",
  NULL
}; // idb
HTStreamClass WSRCParserClass =
{
  "WSRCParser",
  &WSRCParser_free,
  &WSRCParser_abort,
  &WSRCParser_put_character,
  &WSRCParser_put_string,
  &WSRCParser_write
}; // idb
int current_portnumber = 80; // idb
int proxy_portnumber = 80; // idb
int HTlex_line = 1; // idb
char six2pr[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // idb
int first_4934 = 1; // idb
int in_soc = -1; // idb
int COLORS; // weak
WINDOW *stdscr; // idb
WINDOW *curscr; // idb
char *strnames; // idb
FILE *stderr; // idb
int LINES; // weak
int COLS; // weak
FILE *stdin; // idb
FILE *stdout; // idb
int cur_term; // weak
chtype dword_81AABCC; // idb
chtype dword_81AABD0; // idb
chtype dword_81AABD4; // idb
chtype dword_81AABD8; // idb
chtype dword_81AABE0; // idb
chtype dword_81AACA4; // idb
char *strfnames; // idb
int COLOR_PAIRS; // weak
char ttytype[256]; // idb
char temp_11056[12]; // idb
int label_columns; // idb
char s_str_13245[1024]; // idb
char prev_target_buffer_14672[1024]; // idb
char prev_target_14671[1024]; // idb
HTList *URL_edit_history; // idb
HTList *MAIL_edit_history; // idb
int have_levent; // idb
MEVENT levent; // idb
FILE *cmd_logfile; // idb
FILE *cmd_script; // idb
char *personal_name_11174; // idb
const char *kbunits_10638; // idb
const char *bunits_10637; // idb
double last_active_10725; // idb
double last_10724; // idb
double first_10723; // idb
char *line_10715; // idb
off_t transfer_rate_10714; // idb
off_t total_last_10713; // idb
off_t bytes_last_10712; // idb
BOOLEAN conf_cancelled[16]; // idb
HText *HTMainText; // idb
HTParentAnchor *HTMainAnchor; // idb
char *HTCurSelectGroupSize; // idb
int LYCacheSource; // idb
int LYCacheSourceForAborted; // idb
BOOLEAN LYShowScrollbar; // idb
BOOLEAN in_DT[3]; // idb
HTList *search_queries; // idb
int HTFormNumber; // idb
int HTFormFields; // idb
char *HTCurSelectGroup; // idb
char *HTCurSelectedOptionValue; // idb
BOOLEAN underline_on; // idb
BOOLEAN bold_on; // idb
BOOLEAN have_raw_nbsps[2]; // idb
int ctrl_chars_on_this_line; // idb
int utfxtra_on_this_line; // idb
HTList *loaded_texts; // idb
int last_nlinks_12721; // idb
char *HTFormAction; // idb
char *HTFormEnctype; // idb
char *HTFormTitle; // idb
char *HTFormAcceptCharset; // idb
BOOLEAN HTFormDisabled[16]; // idb
HTStyleChange stylechanges_buffers[2][64]; // idb
int justify_start_position; // idb
int ht_num_runs; // idb
ht_run_info ht_runs[1024]; // idb
BOOLEAN this_line_was_split[4]; // idb
TextAnchor *last_anchor_of_previous_line; // idb
char underscore_string[1025]; // idb
int HTFormMethod; // idb
PerFormInfo *HTCurrentForm; // idb
int HTNoDataOK; // idb
char *list_format; // idb
char *syslog_txt; // idb
BOOLEAN lynx_edit_mode; // idb
BOOLEAN no_dired_support[3]; // idb
HTList *tagged; // idb
int dir_list_order; // idb
BOOLEAN prev_lynx_edit_mode; // idb
BOOLEAN no_change_exec_perms; // idb
BOOLEAN local_exec; // idb
BOOLEAN local_exec_on_local_files; // idb
char *LYCgiDocumentRoot; // idb
BOOLEAN enable_scrollback; // idb
char empty_string[3]; // idb
lynx_list_item_type *printers; // idb
lynx_list_item_type *downloaders; // idb
lynx_list_item_type *externals; // idb
lynx_list_item_type *uploaders; // idb
BOOLEAN LYJumpFileURL; // idb
BOOLEAN LYPermitURL; // idb
BOOLEAN LYRestricted; // idb
BOOLEAN LYShowCursor; // idb
BOOLEAN LYUnderlineLinks; // idb
BOOLEAN LYValidate; // idb
BOOLEAN LYforce_no_cache; // idb
BOOLEAN LYinternal_flag; // idb
BOOLEAN LYoverride_no_cache; // idb
BOOLEAN LYresubmit_posts; // idb
BOOLEAN LYtrimInputFields; // idb
BOOLEAN LYxhtml_parsing; // idb
BOOLEAN bold_H1; // idb
BOOLEAN bold_headers; // idb
BOOLEAN case_sensitive; // idb
BOOLEAN check_mail; // idb
BOOLEAN child_lynx; // idb
BOOLEAN dump_links_only; // idb
BOOLEAN dump_output_immediately; // idb
BOOLEAN dump_to_stderr; // idb
BOOLEAN emacs_keys; // idb
BOOLEAN error_logging; // idb
BOOLEAN goto_buffer; // idb
BOOLEAN historical_comments; // idb
BOOLEAN is_www_index; // idb
BOOLEAN jump_buffer; // idb
BOOLEAN minimal_comments; // idb
BOOLEAN recent_sizechange; // idb
BOOLEAN soft_dquotes; // idb
BOOLEAN use_underscore; // idb
BOOLEAN vi_keys; // idb
int keypad_mode; // idb
int user_mode; // idb
BOOLEAN long_url_ok; // idb
BOOLEAN system_editor; // idb
BOOLEAN had_restrictions_default; // idb
BOOLEAN had_restrictions_all; // idb
BOOLEAN no_bookmark; // idb
BOOLEAN no_bookmark_exec; // idb
BOOLEAN no_chdir; // idb
BOOLEAN no_disk_save; // idb
BOOLEAN no_download; // idb
BOOLEAN no_editor; // idb
BOOLEAN no_exec; // idb
BOOLEAN no_file_url; // idb
BOOLEAN no_goto; // idb
BOOLEAN no_goto_cso; // idb
BOOLEAN no_goto_file; // idb
BOOLEAN no_goto_finger; // idb
BOOLEAN no_goto_ftp; // idb
BOOLEAN no_goto_gopher; // idb
BOOLEAN no_goto_http; // idb
BOOLEAN no_goto_https; // idb
BOOLEAN no_goto_lynxcgi; // idb
BOOLEAN no_goto_lynxexec; // idb
BOOLEAN no_goto_lynxprog; // idb
BOOLEAN no_goto_mailto; // idb
BOOLEAN no_goto_rlogin; // idb
BOOLEAN no_goto_telnet; // idb
BOOLEAN no_goto_tn3270; // idb
BOOLEAN no_goto_wais; // idb
BOOLEAN no_inside_ftp; // idb
BOOLEAN no_inside_rlogin; // idb
BOOLEAN no_inside_telnet; // idb
BOOLEAN no_jump; // idb
BOOLEAN no_lynxcfg_info; // idb
BOOLEAN no_lynxcgi; // idb
BOOLEAN no_mail; // idb
BOOLEAN no_multibook; // idb
BOOLEAN no_option_save; // idb
BOOLEAN no_outside_ftp; // idb
BOOLEAN no_outside_rlogin; // idb
BOOLEAN no_outside_telnet; // idb
BOOLEAN no_print; // idb
BOOLEAN no_shell; // idb
BOOLEAN no_suspend; // idb
BOOLEAN no_telnet_port; // idb
BOOLEAN no_useragent[2]; // idb
HTList *broken_ftp_epsv; // idb
HTList *broken_ftp_retr; // idb
char *ftp_lasthost; // idb
BOOLEAN no_goto_news; // idb
BOOLEAN no_goto_nntp; // idb
BOOLEAN no_goto_snews; // idb
BOOLEAN no_inside_news; // idb
BOOLEAN no_newspost; // idb
BOOLEAN no_outside_news; // idb
BOOLEAN no_externals; // idb
BOOLEAN no_lynxcfg_xinfo; // idb
BOOLEAN no_compileopts_info; // idb
BOOLEAN no_statusline; // idb
BOOLEAN local_host_only; // idb
BOOLEAN override_no_download; // idb
BOOLEAN show_dotfiles; // idb
BOOLEAN LYforce_HTML_mode; // idb
BOOLEAN no_table_center; // idb
BOOLEAN HEAD_request; // idb
BOOLEAN LYAcceptAllCookies; // idb
BOOLEAN LYCancelledFetch; // idb
BOOLEAN LYListNewsDates; // idb
BOOLEAN LYListNewsNumbers; // idb
BOOLEAN LYMBMBlocked; // idb
BOOLEAN LYNoRefererForThis; // idb
BOOLEAN LYNoRefererHeader; // idb
BOOLEAN LYUseMouse; // idb
BOOLEAN LYisConfiguredForX; // idb
BOOLEAN UCForce8bitTOUPPER; // idb
BOOLEAN UCSaveBookmarksInUnicode; // idb
BOOLEAN bookmark_start; // idb
BOOLEAN check_realm; // idb
BOOLEAN clickable_images; // idb
BOOLEAN crawl; // idb
BOOLEAN keep_mime_headers; // idb
BOOLEAN more_text; // idb
BOOLEAN more_links; // idb
BOOLEAN no_list; // idb
BOOLEAN no_margins; // idb
BOOLEAN no_title; // idb
BOOLEAN no_url_redirection; // idb
BOOLEAN startfile_ok; // idb
BOOLEAN traversal; // idb
char *BookmarkPage; // idb
char *LYHostName; // idb
char *LYLocalDomain; // idb
char *LYUserAgent; // idb
char *LYUserAgentDefault; // idb
char *LynxHome; // idb
char *LynxSigFile; // idb
char *UCAssume_MIMEcharset; // idb
char *URLDomainPrefixes; // idb
char *URLDomainSuffixes; // idb
char *anonftp_password; // idb
char *authentication_info[2]; // idb
char *bookmark_page; // idb
char *editor; // idb
char *form_get_data; // idb
char *form_post_data; // idb
char *global_extension_map; // idb
char *global_type_map; // idb
char *helpfile; // idb
char *helpfilepath; // idb
char *homepage; // idb
char *http_error_file; // idb
char *indexfile; // idb
char *jumpfile; // idb
char *jumpprompt; // idb
char *language; // idb
char *lynx_cfg_file; // idb
char *lynx_save_space; // idb
char *lynx_temp_space; // idb
char *lynxjumpfile; // idb
char *lynxlinksfile; // idb
char *lynxlistfile; // idb
char *original_dir; // idb
char *personal_extension_map; // idb
char *personal_mail_address; // idb
char *personal_type_map; // idb
char *pref_charset; // idb
char *proxyauth_info[2]; // idb
char *startfile; // idb
char *startrealm; // idb
char *system_mail; // idb
char *system_mail_flags; // idb
char *x_display; // idb
int nhist; // idb
BOOLEAN nomore[4]; // idb
int LYMultiBookmarks; // idb
int crawl_count; // idb
int dump_output_width; // idb
int dump_server_status; // idb
int lynx_temp_subspace; // idb
int nlinks; // idb
BOOLEAN BibP_bibhost_available; // idb
BOOLEAN BibP_bibhost_checked; // idb
BOOLEAN no_goto_bibp[2]; // idb
char *BibP_bibhost; // idb
char *BibP_globalserver; // idb
BOOLEAN persistent_cookies[4]; // idb
char *LYCookieFile; // idb
char *LYCookieSaveFile; // idb
char *LYTransferName; // idb
char *XLoadImageCommand; // idb
BOOLEAN LYNoISMAPifUSEMAP[4]; // idb
char *SSL_cert_file; // idb
int Old_DTD; // idb
FILE *LYTraceLogFP; // idb
char *LYTraceLogPath; // idb
BOOLEAN LYForceSSLCookiesSecure; // idb
BOOLEAN LYNoCc; // idb
BOOLEAN LYPreparsedSource; // idb
BOOLEAN dont_wrap_pre; // idb
BOOLEAN ok_justify; // idb
BOOLEAN LYLocaleCharset; // idb
BOOLEAN with_backspaces; // idb
BOOLEAN textfields_need_activation; // idb
BOOLEAN textfields_activation_option; // idb
BOOLEAN textfield_prompt_at_left_edge[2]; // idb
char *hidden_link_marker; // idb
BOOLEAN debug_display_partial; // idb
BOOLEAN LYNonRestartingSIGWINCH; // idb
BOOLEAN LYReuseTempfiles; // idb
BOOLEAN FileInitAlreadyDone; // idb
HTList *positionable_editor; // idb
BOOLEAN LYNoCore; // idb
BOOLEAN restore_sigpipe_for_children[3]; // idb
char *lynx_lss_file2; // idb
char *lynx_lss_file; // idb
char *lynx_version_putenv_command; // idb
BOOLEAN startfile_stdin; // idb
BOOLEAN DTD_recovery; // idb
BOOLEAN stack_dump[2]; // idb
char *terminal; // idb
BOOLEAN no_numbers; // idb
BOOLEAN number_links; // idb
BOOLEAN number_fields; // idb
BOOLEAN LYPrependBase; // idb
HTList *LYStdinArgs; // idb
char *nonoption; // idb
BOOLEAN no_options_further_12842; // idb
const char *pgm; // idb
HTLinkType *HTInternalLink; // idb
HTAtom *WWW_SOURCE; // idb
HTList *Goto_URLs; // idb
char *LYRequestTitle; // idb
char *LYRequestReferer; // idb
BOOLEAN display_partial[4]; // idb
int NumOfLines_partial; // idb
int Newline; // idb
char *traversal_host; // idb
char *traversal_link_to_add; // idb
char *owner_address; // idb
char *ownerS_address; // idb
BOOLEAN textinput_activated; // idb
BOOLEAN from_source_cache[15]; // idb
DocInfo temp_13241; // idb
char *shell_15964; // idb
char buf_16744[256]; // idb
char byte_81AEAA1; // weak
char prev_target[1024]; // idb
DocInfo newdoc; // idb
DocInfo curdoc; // idb
int lynx_has_color; // idb
WINDOW *LYwin; // idb
int LYshiftWin; // idb
int LYwideLines; // idb
int LYtableCols; // idb
BOOLEAN LYCursesON[12]; // idb
char result_10340[136]; // idb
BOOLEAN lynx_called_initscr[4]; // idb
WINDOW *LYscreen; // idb
int was_11223; // idb
int waiting_11244; // idb
int did_save_11243; // idb
termios saved_tty_11242; // idb
int fake_max_11684; // idb
WINDOW *fake_win_11683; // idb
int Masked_Attr; // idb
$A01EC9CCAB028BB7EB0BC3A4862DE084 lynx_color_pairs[25]; // idb
WINDOW *my_subwindow; // idb
BOOLEAN is_mosaic_hotlist[32]; // idb
char filename_buffer_10939[256]; // idb
char newfile_10985[256]; // idb
HTList *sug_filenames; // idb
BOOLEAN mustshow[4]; // idb
HTList *localhost_aliases; // idb
char *HomeDir; // idb
int lineno; // idb
int fake_zap; // idb
int last_13072; // idb
unsigned int counter_14423; // idb
unsigned __int8 used_tempname_14420[1251]; // idb
int names_used_14419; // idb
int lastsize_14688; // idb
time_t lasttime_14687; // idb
time_t lastcheck_14686; // idb
char *mf_14685; // idb
const char *homedir_15738; // idb
char buf_17042[256]; // idb
char *display_putenv_command_17405; // idb
FILE *paste_handle; // idb
char *paste_buf; // idb
LY_TEMP *ly_temp; // idb
BOOLEAN can_do_colors[4]; // idb
char *secure_value; // idb
BOOLEAN have_read_cfg; // idb
BOOLEAN default_color_reset[3]; // idb
char *lynxcfginfo_url; // idb
char *configinfo_url; // idb
char prev_target_buffer_10557[512]; // idb
HTList *Visited_Links; // idb
VisitedLink *PrevVisitedLink; // idb
VisitedLink *PrevActiveVisitedLink; // idb
int topOfStack; // idb
VisitedLink Latest_first; // idb
VisitedLink Latest_last; // idb
VisitedLink *Latest_tree; // idb
VisitedLink *First_tree; // idb
VisitedLink *Last_by_first; // idb
char *buffstack[40]; // idb
char *pointers_10884[4]; // idb
BOOLEAN term_message[4]; // idb
HTList *myList_9708; // idb
char buf_9806[30]; // idb
char buf_9909[30]; // idb
char *buf_10346; // idb
BOOLEAN did_vi_keys; // idb
BOOLEAN did_emacs_keys; // idb
BOOLEAN did_number_keys[6]; // idb
BOOLEAN source_cache_file_error[4]; // idb
HTStyleSheet *styleSheet; // idb
HTStyle *default_style_0; // idb
char *Style_className; // idb
char *Style_className_end; // idb
size_t Style_className_len; // idb
HTStyle *styles[149]; // idb
int hcode; // idb
char *WWW_Download_File; // idb
BOOLEAN LYCancelDownload[4]; // idb
RememberTestResult::cmdlist_s *cmdlist_10828; // idb
HTStyle *st_array[50]; // idb
HTStyleSheet *result; // idb
char curloc_10253[256]; // idb
char tempfile_10249[256]; // idb
BOOLEAN LYOutOfMemory[4]; // idb
int topOfStack_0; // idb
void (*callstack[50])(void); // idb
JumpTable *JThead; // idb
char buf_10543[124]; // idb
char tempfile_10556[256]; // idb
char **env; // idb
int envc_size; // idb
int envc; // idb
HTList *alloced; // idb
char *user_agent; // idb
char *server_software; // idb
char *accept_language; // idb
char *post_len; // idb
int current_lineedit; // idb
int escape_bound; // idb
HTkcode kanji_code; // idb
BOOLEAN LYHaveCJKCharacterSet; // idb
BOOLEAN force_old_UCLYhndl_on_reload[3]; // idb
int LYNumCharsets; // idb
const char **p_entity_values; // idb
char OLstring_11402[8]; // idb
char OLstring_11440[8]; // idb
char OLstring_11478[20]; // idb
char OLstring_11558[20]; // idb
BOOLEAN LYMapsOnly[4]; // idb
HTList *LynxMaps; // idb
HTList *domain_list; // idb
HTList *cookie_list; // idb
int total_cookies; // idb
int number_of_file_cookies; // idb
char expires_a_13107[16]; // idb
char secure_13106[8]; // idb
char value_13104[4100]; // idb
char name_13103[256]; // idb
char path_13102[256]; // idb
char domain_13101[256]; // idb
int last_styles[129]; // idb
int last_colorattr_ptr; // idb
BOOLEAN force_current_tag_style[4]; // idb
HTList *lss_styles; // idb
void *cached_styles_ptr; // idb
int cached_styles_rows; // idb
int cached_styles_cols; // idb
int colorPairs; // idb
unsigned __int8 our_pairs[2][1][17][17]; // idb
BOOLEAN psrc_convert_string; // idb
BOOLEAN psrc_view; // idb
BOOLEAN LYpsrc; // idb
BOOLEAN mark_htext_as_source; // idb
BOOLEAN psrcview_no_anchor_numbering[4]; // idb
int LastTzone_8447; // idb
time_t LastTime_8446; // idb
char *yyInput; // idb
DSTMODE yyDSTmode; // idb
int yyHaveDate; // idb
int yyHaveRel; // idb
int yyHaveTime; // idb
time_t yyTimezone; // idb
time_t yyDay; // idb
time_t yyHour; // idb
time_t yyMinutes; // idb
time_t yyMonth; // idb
time_t yySeconds; // idb
time_t yyYear; // idb
MERIDIAN yyMeridian; // idb
time_t yyRelMonth; // idb
time_t yyRelSeconds; // idb
__int16 *yyss; // idb
__int16 *yysslim; // idb
YYSTYPE *yyvs; // idb
unsigned int yystacksize; // idb
int UCNumCharsets; // idb
int UCInitialized; // idb
unsigned __int16 *UC_translate; // idb
unsigned __int8 *inv_translate; // idb
unsigned __int8 *inverse_translations[4]; // idb
int hashtable_contents_valid; // idb
int hashtable_str_contents_valid; // idb
unsigned __int16 **uni_pagedir[32]; // idb
char ***uni_pagedir_str[32]; // idb
const unsigned __int16 *UC_current_unitable; // idb
unimapdesc_str *UC_current_unitable_str; // idb
int unidefault_contents_valid; // idb
int unidefault_str_contents_valid; // idb
unsigned __int16 **unidefault_pagedir[32]; // idb
char ***unidefault_pagedir_str[32]; // idb
const unsigned __int16 *UC_default_unitable; // idb
const unimapdesc_str *UC_default_unitable_str; // idb
int UC_lastautoGN; // idb
int inx_8156; // idb
char buffer_8152[3]; // idb
char byte_81B2131; // weak
char byte_81B2132; // weak
int nested_8520; // idb
char dummy_8793[2]; // idb
UC_charset UCInfo[60]; // idb
unsigned __int8 inv_norm_transl[512]; // idb
const char **remember_allocated_LYCharSets[60]; // idb
dired_menu *menu_head; // idb
char tempfile_12181[256]; // idb
char *HTClientHost; // idb
FILE *HTlogfile; // idb
BOOLEAN HTSecure; // idb
BOOLEAN HTPermitRedir; // idb
BOOLEAN using_proxy[2]; // idb
HTFormat HTOutputFormat; // idb
HTStream *HTOutputStream; // idb
char *use_this_url_instead; // idb
int redirection_attempts; // idb
HTList *protocols; // idb
char *pushed_assume_MIMEname; // idb
BOOLEAN reloading[4]; // idb
char *redirecting_url; // idb
BOOLEAN permanent_redirection; // idb
BOOLEAN redirect_post_content[19]; // idb
int HTDirReadme; // idb
HTList *HTSuffixes; // idb
const char *program_paths[24]; // idb
int HTfileSortMethod; // idb
BOOLEAN HaveYears[4]; // idb
connection *connections; // idb
connection *control; // idb
char *user_entered_password; // idb
char *last_username_and_host; // idb
int Broken_RETR; // idb
int Broken_EPSV; // idb
eServerType server_type; // idb
int unsure_type; // idb
BOOLEAN use_list[4]; // idb
int interrupted_in_next_data_char; // idb
BOOLEAN have_socket[4]; // idb
char *vmsname_10181; // idb
char *help_message_buffer; // idb
int flagbase_11668; // idb
time_t base_11667; // idb
char ThisYear[8]; // idb
char LastYear[8]; // idb
int TheDate; // idb
char response_text[257]; // idb
unsigned int master_socket; // idb
char port_command[255]; // idb
fd_set open_sockets; // idb
unsigned int num_sockets; // idb
PortNumber passive_port; // idb
char data_buffer[2048]; // idb
char *data_read_pointer; // idb
char *data_write_pointer; // idb
int lynx_nsl_status; // idb
char *hostname; // idb
char hostbuf_9499[64]; // idb
AlignedHOSTENT aligned_full_rehostent_9956; // idb
int my_errno; // idb
HTCJKlang HTCJK; // idb
BOOLEAN HTPassEightBitRaw; // idb
BOOLEAN HTPassEightBitNum; // idb
BOOLEAN HTPassHighCtrlRaw; // idb
BOOLEAN HTPassHighCtrlNum; // idb
int depth; // idb
int current_is_class; // idb
BOOLEAN FoundEntity[16]; // idb
HTTag *last_11978[64]; // idb
HTTag empty_tag_12329; // idb
int repair_JIS; // idb
int nje_16124; // idb
int sgml_offset; // idb
char *entity_string; // idb
char replace_buf[64]; // idb
HTTag HTTag_unrecognized; // idb
HTTag tags[119]; // idb
int HTPlain_bs_pending; // idb
char replace_buf_0[64]; // idb
char *Style_className_0; // idb
char myHash[128]; // idb
int hcode_0; // idb
BOOLEAN initialised[4]; // idb
char *t1_4974; // idb
char *n1_4973; // idb
HTAtom *hash_table[101]; // idb
HTList adult_table[1001]; // idb
BOOLEAN WWW_TraceFlag[4]; // idb
int WWW_TraceMask; // idb
char *HTBinDir; // idb
char *HTSearchScript; // idb
rule *rules; // idb
rule *rule_tail; // idb
HTList *HTPresentations; // idb
HTPresentation *default_presentation; // idb
int interrupted_in_htgetcharacter; // idb
char result_11300[80]; // idb
char input_buffer[4096]; // idb
char *input_pointer; // idb
char *input_limit; // idb
int input_file_number; // idb
HTStream_5 HTBaseStreamInstance; // idb
int HTmmcont; // idb
char *HTNewsHost; // idb
char *NewsHost; // idb
char *NewsHREF; // idb
int HTCanPost; // idb
HTStream *rawtarget; // idb
BOOLEAN rawtext[4]; // idb
HTList *NNTP_AuthInfo; // idb
char *name; // idb
char *address; // idb
char *dbuf; // idb
BOOLEAN initialized[4]; // idb
int s; // idb
char response_text_0[513]; // idb
HTStructured_1 *target; // idb
HTStructuredClass targetClass; // idb
HTStreamClass rawtargetClass; // idb
HTParentAnchor *node_anchor; // idb
int diagnostic; // idb
BOOLEAN HT_Is_Gopher_URL[4]; // idb
CSOfield_info *CSOfields; // idb
BOOLEAN acceptable_inited[4]; // idb
int s_0; // idb
HTStructured_1 *target_0; // idb
HTStructuredClass targetClass_0; // idb
BOOLEAN acceptable[256]; // idb
BOOLEAN initialized_0[4]; // idb
int finger_fd; // idb
HTStructured_1 *target_1; // idb
HTStructuredClass targetClass_1; // idb
BOOLEAN free_HTAAGlobalsSet[4]; // idb
char *HTAA_composeAuthResult; // idb
char *compose_auth_stringResult; // idb
HTList *server_table; // idb
char *secret_key; // idb
HTAASetup *current_setup; // idb
char *current_hostname; // idb
char *current_docname; // idb
char *HTAAForwardAuth; // idb
HTAASetup *proxy_setup; // idb
char *proxy_hostname; // idb
char *proxy_docname; // idb
HTList *prot_cache; // idb
HTAAProt *default_prot; // idb
HTAAProt *current_prot; // idb
HTList *known_grp; // idb
HTList *known_pwd; // idb
BOOLEAN uidgid_cache_inited[24]; // idb
LexItem lex_pushed_back; // idb
FILE *cache; // idb
char msg_4952[70]; // idb
int lex_cnt; // idb
BOOLEAN lex_template[20]; // idb
unsigned __int8 pr2six[256]; // idb
char *buffer; // idb
size_t buffer_length; // idb
char *start_pointer; // idb
char *end_pointer; // idb
BOOLEAN term_letter[16]; // idb
BOOLEAN form_in_htext; // idb
BOOLEAN can_justify_this_line[2]; // idb
int wait_for_this_stacked_elt; // idb
BOOLEAN can_justify_here[24]; // idb
char star_string[1025]; // idb
BOOLEAN ftp_local_passive[32]; // idb
LinkInfo links[1024]; // idb
unsigned int MessageSecs; // idb
int size_history; // idb
unsigned int AlertSecs; // idb
int InfoSecs; // idb
int cookie_noprompt; // idb
int display_lines; // idb
char *lynx_cmd_logfile; // idb
HistInfo *history; // idb
int ReplaySecs; // idb
BOOLEAN LYDefaultRawMode[4]; // idb
char *lynx_cmd_script; // idb
BOOLEAN LYRawMode[4]; // idb
int DebugSecs; // idb
HTCharStyle displayStyles[133]; // idb
int Current_Attr; // idb
char *MBM_A_subdescript[26]; // idb
char *MBM_A_subbookmark[26]; // idb
BOOLEAN term_options[4]; // idb
int nhist_extra; // idb
int forced_UCLYhdnl; // idb
BOOLEAN force_classname[4]; // idb
int current_tag_style; // idb
bucket hashStyles[8193]; // idb
int cached_tag_styles[118]; // idb
char *forced_classname; // idb
BOOLEAN psrc_nested_call[32]; // idb
HT_tagspec *lexeme_start[12]; // idb
BOOLEAN sgml_in_psrc_was_initialized[16]; // idb
HT_tagspec *lexeme_end[12]; // idb
char *HTL_tagspecs[12]; // idb
BOOLEAN psrc_first_tag[4]; // idb
YYSTYPE *yyvsp; // idb
int yychar; // idb
YYSTYPE yyval; // idb
int yyerrflag; // idb
YYSTYPE yylval; // idb
int yynerrs; // idb
__int16 *yyssp; // idb
char class_string[256]; // idb
char HTlex_buffer[40]; // idb


//----- (0804A764) --------------------------------------------------------
int sub_804A764()
{
  return dword_8193FFC();
}
// 8193FFC: using guessed type int (*dword_8193FFC)(void);

//----- (0804B4E4) --------------------------------------------------------
void __cdecl cleanup_sig(int sig)
{
  char *v1; // eax

  signal(1, (__sighandler_t)1);
  signal(2, (__sighandler_t)1);
  signal(15, (__sighandler_t)1);
  if ( traversal )
    dump_traversal_history();
  if ( sig == 1 )
  {
    cleanup_files();
  }
  else
  {
    if ( !dump_output_immediately )
      cleanup();
    if ( sig )
    {
      v1 = gettext("Exiting via interrupt:");
      printf("\n\n%s %d\n\n", v1, sig);
      fflush(stdout);
    }
  }
  if ( sig )
    exit_immediately(0);
  reset_signals();
}

//----- (0804B5A4) --------------------------------------------------------
void cleanup_files()
{
  LYCleanupTemp();
  if ( lynx_temp_space )
  {
    free(lynx_temp_space);
    lynx_temp_space = 0;
  }
}

//----- (0804B5D1) --------------------------------------------------------
void cleanup()
{
  signal(1, (__sighandler_t)1);
  signal(15, (__sighandler_t)1);
  signal(2, (__sighandler_t)1);
  if ( LYCursesON[0] )
  {
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
    lynx_stop_all_colors();
    LYrefresh();
    stop_curses();
  }
  if ( persistent_cookies[0] )
    LYStoreCookies(LYCookieSaveFile);
  cleanup_files();
  LYCloseTracelog();
}

//----- (0804B670) --------------------------------------------------------
int LYVersionIsRelease()
{
  return 0;
}

//----- (0804B67A) --------------------------------------------------------
char *LYVersionStatus()
{
  if ( (unsigned __int8)LYVersionIsRelease() )
    return gettext("latest release");
  else
    return gettext("development version");
}

//----- (0804B6AE) --------------------------------------------------------
char *LYVersionDate()
{
  LYstrncpy(temp_11056, "14 Dec 2008 16:24:56 -0800", 11);
  return temp_11056;
}

//----- (0804B6D7) --------------------------------------------------------
void __cdecl dt_String(FILE *fp, const char *label, const char *value)
{
  char *the_value; // [esp+18h] [ebp-10h] BYREF
  char *the_label; // [esp+1Ch] [ebp-Ch] BYREF
  int need; // [esp+20h] [ebp-8h]
  int have; // [esp+24h] [ebp-4h]

  the_label = 0;
  the_value = 0;
  HTSACopy(&the_label, label);
  HTSACopy(&the_value, value);
  have = strlen(the_label);
  need = LYstrExtent(the_label, have, label_columns);
  LYEntify(&the_label, 1);
  LYEntify(&the_value, 1);
  fwrite("<dt>", 1u, 4u, fp);
  while ( need++ < label_columns )
    fwrite("&nbsp;", 1u, 6u, fp);
  fprintf(fp, "<em>%s</em> %s\n", the_label, the_value);
  if ( the_label )
  {
    free(the_label);
    the_label = 0;
  }
  if ( the_value )
    free(the_value);
}

//----- (0804B811) --------------------------------------------------------
void __cdecl dt_Number(FILE *fp0, const char *label, int number, const char *units)
{
  char *value; // [esp+24h] [ebp-4h] BYREF

  value = 0;
  HTSprintf(&value, "%ld %s", number, units);
  dt_String(fp0, label, value);
  if ( value )
    free(value);
}

//----- (0804B873) --------------------------------------------------------
int __cdecl LYShowInfo(DocInfo *doc, DocInfo *newdoc, char *owner_address)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *address; // ebx
  char *v9; // eax
  int v10; // ebx
  char *v11; // esi
  FILE *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // ebx
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // esi
  int st_size; // ebx
  char *v25; // eax
  char *v26; // ebx
  char *v27; // eax
  char *v28; // ebx
  char *v29; // eax
  char *v30; // ebx
  char *v31; // eax
  char *v32; // eax
  size_t v33; // eax
  size_t v34; // eax
  size_t v35; // eax
  size_t v36; // eax
  size_t v37; // eax
  char *v38; // eax
  size_t v39; // eax
  size_t v40; // eax
  size_t v41; // eax
  size_t v42; // eax
  size_t v43; // eax
  char *v44; // eax
  size_t v45; // eax
  size_t v46; // eax
  size_t v47; // eax
  size_t v48; // eax
  size_t v49; // eax
  char *v50; // eax
  char *v51; // eax
  char *v52; // ebx
  char *v53; // eax
  char *v54; // ebx
  char *v55; // eax
  char *v56; // eax
  const char *MIMEname; // ebx
  char *v58; // eax
  char *v59; // eax
  char *v60; // eax
  char *v61; // eax
  char *expires; // ebx
  char *v63; // eax
  char *cache_control; // ebx
  char *v65; // eax
  char *v66; // esi
  int content_length; // ebx
  char *v68; // eax
  char *v69; // esi
  int NumOfBytes; // ebx
  char *v71; // eax
  char *content_language; // ebx
  char *v73; // eax
  char *v74; // eax
  char *post_content_type; // ebx
  char *v76; // eax
  char *v77; // eax
  char *v78; // esi
  int NumOfLines; // ebx
  char *v80; // eax
  char *v81; // eax
  char *v82; // eax
  char *v83; // eax
  char *v84; // eax
  char *v85; // eax
  char *v86; // ebx
  char *v87; // eax
  char *v88; // eax
  const char *v89; // ebx
  char *v90; // eax
  char *v91; // eax
  char *v92; // eax
  char *submit_action; // ebx
  char *v94; // eax
  char *v95; // eax
  char *v96; // eax
  char *v99; // [esp+24h] [ebp-534h]
  const char *v100; // [esp+28h] [ebp-530h]
  const char *v101; // [esp+2Ch] [ebp-52Ch]
  char *str; // [esp+30h] [ebp-528h]
  int len; // [esp+34h] [ebp-524h]
  const char *value; // [esp+38h] [ebp-520h]
  const char *src; // [esp+3Ch] [ebp-51Ch]
  char *v106; // [esp+40h] [ebp-518h]
  char *v107; // [esp+44h] [ebp-514h]
  const char *v108; // [esp+48h] [ebp-510h]
  const char *v109; // [esp+4Ch] [ebp-50Ch]
  stat dir_info; // [esp+68h] [ebp-4F0h] BYREF
  char *enctype; // [esp+C8h] [ebp-490h]
  int method; // [esp+CCh] [ebp-48Ch]
  LYUCcharset *p_in; // [esp+D0h] [ebp-488h]
  int buf_size; // [esp+D4h] [ebp-484h]
  int next_to_last; // [esp+D8h] [ebp-480h]
  char *last_slash; // [esp+DCh] [ebp-47Ch]
  const char *name; // [esp+E0h] [ebp-478h]
  char *temp; // [esp+E4h] [ebp-474h] BYREF
  const char *cp; // [esp+E8h] [ebp-470h]
  char *Title; // [esp+ECh] [ebp-46Ch] BYREF
  FILE *fp0; // [esp+F0h] [ebp-468h]
  int url_type; // [esp+F4h] [ebp-464h]
  BOOLEAN LYInfoAdvanced; // [esp+FBh] [ebp-45Dh]
  char buf[1024]; // [esp+FCh] [ebp-45Ch] BYREF
  char modes[80]; // [esp+4FCh] [ebp-5Ch] BYREF
  unsigned int v126; // [esp+54Ch] [ebp-Ch]

  v126 = __readgsdword(0x14u);
  Title = 0;
  temp = 0;
  LYInfoAdvanced = user_mode == 2;
  if ( LYReuseTempfiles )
  {
    fp0 = LYOpenTempRewrite(tempfile_11105, ".html", "w");
  }
  else
  {
    LYRemoveTemp(tempfile_11105);
    fp0 = LYOpenTemp(tempfile_11105, ".html", "w");
  }
  if ( fp0 )
  {
    LYLocalFileToURL(&newdoc->address, tempfile_11105);
    if ( nlinks > 0 )
    {
      if ( links[doc->link].lname )
      {
        url_type = is_url(links[doc->link].lname);
        if ( url_type )
        {
          if ( url_type == 26 || url_type == 27 )
          {
            last_slash = strrchr(links[doc->link].lname, 47);
            next_to_last = strlen(links[doc->link].lname) - 1;
            if ( last_slash - links[doc->link].lname == next_to_last )
              links[doc->link].lname[next_to_last] = 0;
          }
        }
      }
    }
    label_columns = 9;
    v4 = gettext("Information about the current document");
    WriteInternalTitle(fp0, v4);
    v99 = LYVersionStatus();
    if ( (unsigned __int8)LYVersionIsRelease() )
      v100 = "http://lynx.isc.org/";
    else
      v100 = "http://lynx.isc.org/current/";
    v5 = LYVersionDate();
    fprintf(fp0, "<h1>%s %s (%s) (<a href=\"%s\">%s</a>)", "Lynx", "2.8.7dev.11", v5, v100, v99);
    fwrite("</h1>\n", 1u, 6u, fp0);
    if ( lynx_edit_mode && nlinks > 0 )
    {
      v6 = gettext("Directory that you are currently viewing");
      fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v6);
      temp = HTnameOfFile_WWW(doc->address, 0, 1);
      v7 = gettext("Name:");
      dt_String(fp0, v7, temp);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      address = doc->address;
      v9 = gettext("URL:");
      dt_String(fp0, v9, address);
      fwrite("\n</dl>\n", 1u, 7u, fp0);
      temp = HTnameOfFile_WWW(links[doc->link].lname, 0, 1);
      if ( lstat64((int)temp, (int)&dir_info) == -1 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v10 = *__errno_location();
          v11 = temp;
          v12 = TraceFP();
          fprintf(v12, "lstat(%s) failed, errno=%d\n", v11, v10);
        }
        v13 = gettext("Failed to obtain status of current link!");
        HTAlert(v13);
      }
      else
      {
        label_columns = 16;
        if ( (dir_info.st_mode & 0xF000) == 0x4000 )
        {
          v14 = gettext("Directory that you have currently selected");
          fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v14);
        }
        else if ( (dir_info.st_mode & 0xF000) == 0x8000 )
        {
          v15 = gettext("File that you have currently selected");
          fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v15);
        }
        else
        {
          if ( (dir_info.st_mode & 0xF000) == 40960 )
            v16 = gettext("Symbolic link that you have currently selected");
          else
            v16 = gettext("Item that you have currently selected");
          fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v16);
        }
        v17 = temp;
        v18 = gettext("Full name:");
        dt_String(fp0, v18, v17);
        if ( (dir_info.st_mode & 0xF000) == 40960 )
        {
          buf_size = readlink(temp, buf, 0x3FFu);
          if ( buf_size == -1 )
          {
            v19 = gettext("Unable to follow link");
            sprintf(buf, "%.*s", 1023, v19);
          }
          else
          {
            buf[buf_size] = 0;
          }
          v20 = gettext("Points to file:");
          dt_String(fp0, v20, buf);
        }
        name = HTAA_UidToName(dir_info.st_uid);
        if ( *name )
        {
          v21 = gettext("Name of owner:");
          dt_String(fp0, v21, name);
        }
        name = HTAA_GidToName(dir_info.st_gid);
        if ( *name )
        {
          v22 = gettext("Group name:");
          dt_String(fp0, v22, name);
        }
        if ( (dir_info.st_mode & 0xF000) == 0x8000 )
        {
          v23 = gettext("(bytes)");
          st_size = dir_info.st_size;
          v25 = gettext("File size:");
          dt_Number(fp0, v25, st_size, v23);
        }
        v26 = ctime(&dir_info.st_ctim.tv_sec);
        v27 = gettext("Creation date:");
        dt_String(fp0, v27, v26);
        v28 = ctime(&dir_info.st_mtim.tv_sec);
        v29 = gettext("Last modified:");
        dt_String(fp0, v29, v28);
        v30 = ctime(&dir_info.st_atim.tv_sec);
        v31 = gettext("Last accessed:");
        dt_String(fp0, v31, v30);
        fwrite("\n</dl>\n", 1u, 7u, fp0);
        label_columns = 9;
        v32 = gettext("Access Permissions");
        fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v32);
        modes[0] = 0;
        modes[1] = 0;
        modes[2] = 0;
        if ( (dir_info.st_mode & 0x100) != 0 )
        {
          v33 = strlen(modes);
          memcpy(&modes[v33], ", read", 7u);
        }
        if ( (dir_info.st_mode & 0x80) != 0 )
        {
          v34 = strlen(modes);
          memcpy(&modes[v34], ", write", 8u);
        }
        if ( (dir_info.st_mode & 0x40) != 0 )
        {
          if ( (dir_info.st_mode & 0xF000) == 0x4000 )
          {
            v35 = strlen(modes);
            memcpy(&modes[v35], ", search", 9u);
          }
          else
          {
            v36 = strlen(modes);
            memcpy(&modes[v36], ", execute", 0xAu);
            if ( (dir_info.st_mode & 0x800) != 0 )
            {
              v37 = strlen(modes);
              memcpy(&modes[v37], ", setuid", 9u);
            }
          }
        }
        v38 = gettext("Owner:");
        dt_String(fp0, v38, &modes[2]);
        modes[0] = 0;
        modes[1] = 0;
        modes[2] = 0;
        if ( (dir_info.st_mode & 0x20) != 0 )
        {
          v39 = strlen(modes);
          memcpy(&modes[v39], ", read", 7u);
        }
        if ( (dir_info.st_mode & 0x10) != 0 )
        {
          v40 = strlen(modes);
          memcpy(&modes[v40], ", write", 8u);
        }
        if ( (dir_info.st_mode & 8) != 0 )
        {
          if ( (dir_info.st_mode & 0xF000) == 0x4000 )
          {
            v41 = strlen(modes);
            memcpy(&modes[v41], ", search", 9u);
          }
          else
          {
            v42 = strlen(modes);
            memcpy(&modes[v42], ", execute", 0xAu);
            if ( (dir_info.st_mode & 0x400) != 0 )
            {
              v43 = strlen(modes);
              memcpy(&modes[v43], ", setgid", 9u);
            }
          }
        }
        v44 = gettext("Group:");
        dt_String(fp0, v44, &modes[2]);
        modes[0] = 0;
        modes[1] = 0;
        modes[2] = 0;
        if ( (dir_info.st_mode & 4) != 0 )
        {
          v45 = strlen(modes);
          memcpy(&modes[v45], ", read", 7u);
        }
        if ( (dir_info.st_mode & 2) != 0 )
        {
          v46 = strlen(modes);
          memcpy(&modes[v46], ", write", 8u);
        }
        if ( (dir_info.st_mode & 1) != 0 )
        {
          if ( (dir_info.st_mode & 0xF000) == 0x4000 )
          {
            v47 = strlen(modes);
            memcpy(&modes[v47], ", search", 9u);
          }
          else
          {
            v48 = strlen(modes);
            memcpy(&modes[v48], ", execute", 0xAu);
            if ( (dir_info.st_mode & 0x200) != 0 )
            {
              v49 = strlen(modes);
              memcpy(&modes[v49], ", sticky", 9u);
            }
          }
        }
        v50 = gettext("World:");
        dt_String(fp0, v50, &modes[2]);
        fwrite("\n</dl>\n", 1u, 7u, fp0);
      }
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
    }
    else
    {
      v51 = gettext("File that you are currently viewing");
      fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v51);
      LYformTitle(&Title, doc->title);
      if ( !doc->isHEAD || strstr(Title, " (HEAD)") || strstr(Title, " - HEAD") )
        v101 = (const char *)&unk_8149C04;
      else
        v101 = " (HEAD)";
      HTSprintf(&temp, "%s%s", Title, v101);
      v52 = temp;
      v53 = gettext("Linkname:");
      dt_String(fp0, v53, v52);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      dt_String(fp0, "URL:", doc->address);
      if ( HTLoadedDocumentCharset() )
      {
        v54 = HTLoadedDocumentCharset();
        v55 = gettext("Charset:");
        dt_String(fp0, v55, v54);
      }
      else
      {
        p_in = HTAnchor_getUCInfoStage(HTMainAnchor, 1);
        if ( !p_in || !p_in->MIMEname || !*p_in->MIMEname || HTAnchor_getUCLYhndl(HTMainAnchor, 1) < 0 )
          p_in = HTAnchor_getUCInfoStage(HTMainAnchor, 0);
        if ( p_in )
        {
          if ( p_in->MIMEname )
          {
            if ( *p_in->MIMEname )
            {
              if ( HTAnchor_getUCLYhndl(HTMainAnchor, 0) >= 0 )
              {
                v56 = gettext("(assumed)");
                HTSprintf(&temp, "%s %s", p_in->MIMEname, v56);
                MIMEname = p_in->MIMEname;
                v58 = gettext("Charset:");
                dt_String(fp0, v58, MIMEname);
                if ( temp )
                {
                  free(temp);
                  temp = 0;
                }
              }
            }
          }
        }
      }
      cp = HText_getServer();
      if ( cp && *cp )
      {
        v59 = gettext("Server:");
        dt_String(fp0, v59, cp);
      }
      cp = HText_getDate();
      if ( cp && *cp )
      {
        v60 = gettext("Date:");
        dt_String(fp0, v60, cp);
      }
      cp = HText_getLastModified();
      if ( cp && *cp )
      {
        v61 = gettext("Last Mod:");
        dt_String(fp0, v61, cp);
      }
      if ( LYInfoAdvanced )
      {
        if ( HTMainAnchor && HTMainAnchor->expires )
        {
          expires = HTMainAnchor->expires;
          v63 = gettext("Expires:");
          dt_String(fp0, v63, expires);
        }
        if ( HTMainAnchor && HTMainAnchor->cache_control )
        {
          cache_control = HTMainAnchor->cache_control;
          v65 = gettext("Cache-Control:");
          dt_String(fp0, v65, cache_control);
        }
        if ( HTMainAnchor && HTMainAnchor->content_length > 0 )
        {
          v66 = gettext("bytes");
          content_length = HTMainAnchor->content_length;
          v68 = gettext("Content-Length:");
          dt_Number(fp0, v68, content_length, v66);
        }
        else
        {
          v69 = gettext("bytes");
          NumOfBytes = HText_getNumOfBytes();
          v71 = gettext("Length:");
          dt_Number(fp0, v71, NumOfBytes, v69);
        }
        if ( HTMainAnchor && HTMainAnchor->content_language )
        {
          content_language = HTMainAnchor->content_language;
          v73 = gettext("Language:");
          dt_String(fp0, v73, content_language);
        }
      }
      if ( doc->post_data )
      {
        str = doc->post_data->str;
        if ( doc->post_data )
          len = doc->post_data->len;
        else
          len = 0;
        v74 = gettext("Post Data:");
        fprintf(fp0, "<dt><em>%s</em> <xmp>%.*s</xmp>\n", v74, len, str);
        post_content_type = doc->post_content_type;
        v76 = gettext("Post Content Type:");
        dt_String(fp0, v76, post_content_type);
      }
      if ( owner_address )
        value = owner_address;
      else
        value = gettext("None");
      v77 = gettext("Owner(s):");
      dt_String(fp0, v77, value);
      v78 = gettext("lines");
      NumOfLines = HText_getNumOfLines();
      v80 = gettext("size:");
      dt_Number(fp0, v80, NumOfLines, v78);
      if ( lynx_mode == 2 )
      {
        src = gettext("forms mode");
      }
      else
      {
        if ( HTisDocumentSource() )
          v106 = gettext("source");
        else
          v106 = gettext("normal");
        src = v106;
      }
      HTSACopy(&temp, src);
      if ( doc->safe )
      {
        v81 = gettext(", safe");
        HTSACat(&temp, v81);
      }
      if ( doc->internal_link )
      {
        v82 = gettext(", via internal link");
        HTSACat(&temp, v82);
      }
      if ( LYInfoAdvanced )
      {
        if ( HText_hasNoCacheSet(HTMainText) )
        {
          v83 = gettext(", no-cache");
          HTSACat(&temp, v83);
        }
        if ( HTAnchor_isISMAPScript((HTAnchor *)HTMainAnchor) )
        {
          v84 = gettext(", ISMAP script");
          HTSACat(&temp, v84);
        }
        if ( doc->bookmark )
        {
          v85 = gettext(", bookmark file");
          HTSACat(&temp, v85);
        }
      }
      v86 = temp;
      v87 = gettext("mode:");
      dt_String(fp0, v87, v86);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      fwrite("\n</dl>\n", 1u, 7u, fp0);
      if ( nlinks <= 0 )
      {
        v96 = gettext("No Links on the current page");
        fprintf(fp0, "<h2>%s</h2>", v96);
      }
      else
      {
        v88 = gettext("Link that you currently have selected");
        fprintf(fp0, "<h2>%s</h2>\n<dl compact>", v88);
        v89 = LYGetHiliteStr(doc->link, 0);
        v90 = gettext("Linkname:");
        dt_String(fp0, v90, v89);
        if ( lynx_mode == 2 && links[doc->link].type == 1 )
        {
          if ( links[doc->link].l_form->submit_method )
          {
            method = links[doc->link].l_form->submit_method;
            enctype = links[doc->link].l_form->submit_enctype;
            if ( method == 2 )
            {
              v107 = "POST";
            }
            else
            {
              if ( method == 3 )
                v108 = "(email)";
              else
                v108 = "GET";
              v107 = (char *)v108;
            }
            v91 = gettext("Method:");
            dt_String(fp0, v91, v107);
            if ( enctype && *enctype )
              v109 = enctype;
            else
              v109 = "application/x-www-form-urlencoded";
            v92 = gettext("Enctype:");
            dt_String(fp0, v92, v109);
          }
          if ( links[doc->link].l_form->submit_action )
          {
            submit_action = links[doc->link].l_form->submit_action;
            v94 = gettext("Action:");
            dt_String(fp0, v94, submit_action);
          }
          if ( !links[doc->link].l_form->submit_method || !links[doc->link].l_form->submit_action )
          {
            v95 = gettext("(Form field)");
            fprintf(fp0, "<dt>&nbsp;%s\n", v95);
          }
        }
        else if ( links[doc->link].lname )
        {
          dt_String(fp0, "URL:", links[doc->link].lname);
        }
        else
        {
          dt_String(fp0, "URL:", (const char *)&unk_8149C04);
        }
        fwrite("\n</dl>\n", 1u, 7u, fp0);
      }
    }
    EndInternalPage(fp0);
    LYrefresh();
    LYCloseTemp(tempfile_11105);
    if ( Title )
    {
      free(Title);
      Title = 0;
    }
    return 0;
  }
  else
  {
    v3 = gettext("Can't open temporary file!");
    HTAlert(v3);
    return -1;
  }
}

//----- (0804D090) --------------------------------------------------------
int editor_can_position()
{
  const char *object; // [esp+14h] [ebp-14h]
  unsigned int n; // [esp+1Ch] [ebp-Ch]
  HTList *p; // [esp+20h] [ebp-8h]

  p = positionable_editor;
  for ( n = 0; n <= 0xA; ++n )
  {
    if ( strstr(editor, table_9431[n]) )
      return 1;
  }
  if ( positionable_editor )
  {
    while ( 1 )
    {
      if ( p && (p = p->next) != 0 )
        object = (const char *)p->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( !strcmp(editor, object) )
        return 1;
    }
  }
  return 0;
}

//----- (0804D13D) --------------------------------------------------------
int __cdecl edit_current_file(char *newfile, int cur, int lineno)
{
  FILE *v3; // edx
  char *v4; // eax
  char *v5; // eax
  FILE *v6; // eax
  int ly; // [esp+20h] [ebp-78h]
  char *number_sign; // [esp+34h] [ebp-64h]
  char *colon; // [esp+38h] [ebp-60h]
  char *filename; // [esp+3Ch] [ebp-5Ch] BYREF
  int result; // [esp+40h] [ebp-58h]
  char position[80]; // [esp+44h] [ebp-54h] BYREF
  unsigned int v15; // [esp+94h] [ebp-4h]
  int linenoa; // [esp+A8h] [ebp+10h]

  v15 = __readgsdword(0x14u);
  result = 0;
  filename = 0;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "edit_current_file(newfile=%s, cur=%d, lineno=%d)\n", newfile, cur, lineno);
  }
  if ( LYisLocalFile(newfile) )
  {
    number_sign = trimPoundSelector(newfile);
    if ( !strncmp(newfile, "file://localhost/", 0x10u) )
      colon = newfile + 16;
    else
      colon = strchr(newfile, 58);
    HTSACopy(&filename, colon + 1);
    HTUnEscape(filename);
    if ( LYCanReadFile(filename) )
      goto LABEL_13;
    if ( filename )
    {
      free(filename);
      filename = 0;
    }
    filename = HTParse(newfile, &relatedName, 5);
    HTUnEscape(filename);
    if ( LYCanReadFile(filename) )
    {
LABEL_13:
      if ( cur < 0 )
        cur = 0;
      position[0] = 0;
      if ( nlinks )
        ly = links[cur].ly;
      else
        ly = 0;
      linenoa = ly + lineno;
      if ( linenoa > 0 )
        sprintf(position, "%d", linenoa);
      edit_temporary_file(filename, position, 0);
      result = 1;
    }
    else
    {
      v5 = gettext("Could not access file.");
      HTAlert(v5);
    }
    if ( number_sign )
      *number_sign = 35;
    if ( filename )
    {
      free(filename);
      filename = 0;
    }
    if ( WWW_TraceFlag[0] )
    {
      v6 = TraceFP();
      fprintf(v6, "edit_current_file returns %d\n", result);
    }
    return result;
  }
  else
  {
    v4 = gettext("Lynx cannot currently (e)dit remote WWW files.");
    HTUserMsg(v4);
    return 0;
  }
}

//----- (0804D39E) --------------------------------------------------------
void __cdecl edit_temporary_file(char *filename, const char *position, const char *message)
{
  int v3; // edx
  int v4; // edx
  char *v5; // ebx
  FILE *v6; // eax
  FILE *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // [esp+14h] [ebp-F4h]
  stat stat_info; // [esp+28h] [ebp-E0h] BYREF
  edit_temporary_file::$282D118E43687E1C7640A6922C6B4310 __u_2; // [esp+88h] [ebp-80h]
  edit_temporary_file::$282D118E43687E1C7640A6922C6B4310 __u_1; // [esp+8Ch] [ebp-7Ch]
  edit_temporary_file::$282D118E43687E1C7640A6922C6B4310 __u_0; // [esp+90h] [ebp-78h]
  edit_temporary_file::$282D118E43687E1C7640A6922C6B4310 __u; // [esp+94h] [ebp-74h]
  int save_err; // [esp+98h] [ebp-70h]
  int rv; // [esp+9Ch] [ebp-6Ch]
  int params; // [esp+A0h] [ebp-68h]
  const char *editor_arg; // [esp+A4h] [ebp-64h]
  char *command; // [esp+A8h] [ebp-60h] BYREF
  const char *format; // [esp+ACh] [ebp-5Ch]
  char exitcode[80]; // [esp+B0h] [ebp-58h] BYREF
  unsigned int v26; // [esp+100h] [ebp-8h]

  v26 = __readgsdword(0x14u);
  format = "%s %s";
  command = 0;
  editor_arg = &relatedName;
  params = 1;
  if ( strstr(editor, "pico") )
    editor_arg = " -t";
  if ( (unsigned __int8)editor_can_position() && *position )
  {
    format = "%s +%s%s %s";
    HTAddXpand(&command, "%s +%s%s %s", params, editor);
    HTAddParam(&command, format, params + 1, position);
    HTAddParam(&command, format, params + 2, editor_arg);
    v3 = params + 3;
    params += 4;
    HTAddParam(&command, format, v3, filename);
    HTEndParam(&command, format, params);
  }
  else
  {
    HTAddXpand(&command, format, params, editor);
    v4 = params + 1;
    params += 2;
    HTAddParam(&command, format, v4, filename);
    HTEndParam(&command, format, params);
  }
  if ( message )
  {
    mustshow[0] = 1;
    statusline(message);
  }
  if ( WWW_TraceFlag[0] )
  {
    v5 = command;
    v6 = TraceFP();
    fprintf(v6, "LYEdit: %s\n", v5);
  }
  if ( WWW_TraceFlag[0] && !LYTraceLogFP )
    sleep(MessageSecs);
  stop_curses();
  *__errno_location() = 0;
  rv = LYSystem(command);
  if ( rv )
  {
    start_curses();
    save_err = *__errno_location();
    if ( WWW_TraceFlag[0] )
    {
      if ( save_err )
        v13 = strerror(save_err);
      else
        v13 = "reason unknown";
      v7 = TraceFP();
      fprintf(v7, "ExtEditForm: system() returned %d (0x%x), %s\n", rv, rv, v13);
    }
    LYFixCursesOn("show error warning:");
    if ( rv == -1 )
    {
      v8 = strerror(save_err);
      v9 = gettext("Error starting editor, %s");
      HTUserMsg2(v9, v8);
    }
    else
    {
      __u.__in = rv;
      if ( (char)((rv & 0x7F) + 1) >> 1 <= 0 )
      {
        __u_0.__in = rv;
        if ( (rv & 0x7F) != 0 || (__u_1.__in = rv, (rv & 0xFF00) >> 8 == 127) )
        {
          v12 = gettext("Error spawning editor, check your editor definition in the options menu");
          HTAlwaysAlert(0, v12);
        }
        else
        {
          __u_2.__in = rv;
          sprintf(exitcode, "%d", (rv & 0xFF00) >> 8);
          v11 = gettext("Editor returned with error status %s");
          HTUserMsg2(v11, exitcode);
        }
      }
      else
      {
        v10 = gettext("Editor killed by signal");
        HTAlwaysAlert(0, v10);
      }
    }
  }
  else
  {
    start_curses();
  }
  HTSprintf0(&command, "%s~", filename);
  if ( !stat64((int)command, (int)&stat_info) )
    remove(command);
  if ( command )
    free(command);
}

//----- (0804D7BC) --------------------------------------------------------
int peek_mouse_levent()
{
  if ( have_levent <= 0 )
    return 0;
  ungetmouse(&levent);
  --have_levent;
  return 1;
}

//----- (0804D7F9) --------------------------------------------------------
int get_mouse_link()
{
  int t; // [esp+Ch] [ebp-4h]

  t = mouse_link;
  mouse_link = -1;
  if ( t < 0 )
    return -1;
  return t;
}

//----- (0804D823) --------------------------------------------------------
int peek_mouse_link()
{
  return mouse_link;
}

//----- (0804D82D) --------------------------------------------------------
int __cdecl fancy_mouse(WINDOW *win, int row, int *position)
{
  int begy; // [esp+Ch] [ebp-5Ch]
  int begx; // [esp+14h] [ebp-54h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+20h] [ebp-48h]
  int v9; // [esp+2Ch] [ebp-3Ch]
  int v10; // [esp+30h] [ebp-38h]
  int v11; // [esp+38h] [ebp-30h]
  int v12; // [esp+40h] [ebp-28h]
  int v13; // [esp+44h] [ebp-24h]
  MEVENT event; // [esp+48h] [ebp-20h] BYREF
  int delta; // [esp+5Ch] [ebp-Ch]
  int mypos; // [esp+60h] [ebp-8h]
  int cmd; // [esp+64h] [ebp-4h]

  cmd = 69;
  getmouse(&event);
  if ( (event.bstate & 0x1C) == 0 )
  {
    if ( (event.bstate & 0x1C000) != 0 )
      return 13;
    return cmd;
  }
  if ( win )
    begy = win->_begy;
  else
    begy = -1;
  mypos = event.y - begy;
  delta = event.y - begy - row;
  if ( win )
    begx = win->_begx;
  else
    begx = -1;
  if ( event.x >= begx
    && (!win ? (v6 = -1) : (v6 = win->_begx), !win ? (v7 = -1) : (v7 = win->_maxx + 1), event.x < v7 + v6)
    || (event.bstate & 0x7000000) != 0 )
  {
    if ( win )
      v9 = win->_maxy + 1;
    else
      v9 = -1;
    if ( mypos + 1 == v9 )
    {
      if ( (event.bstate & 0x10) != 0 )
      {
        return 23;
      }
      else if ( (event.bstate & 8) != 0 )
      {
        return 15;
      }
      else
      {
        return 27;
      }
    }
    else
    {
      if ( win )
        v10 = win->_maxy + 1;
      else
        v10 = -1;
      if ( v10 > mypos )
      {
        if ( mypos )
        {
          if ( mypos >= 0 )
          {
            if ( win )
              v11 = win->_begx + 1;
            else
              v11 = 0;
            if ( event.x > v11
              && (!win ? (v12 = -1) : (v12 = win->_begx),
                  !win ? (v13 = -1) : (v13 = win->_maxx + 1),
                  event.x < v13 + v12 - 2) )
            {
              if ( (event.bstate & 0x7000000) != 0 )
              {
                *position += delta;
                return -1;
              }
              else
              {
                *position += delta;
                return 39;
              }
            }
            else
            {
              *position += delta;
              return -1;
            }
          }
          else if ( (event.bstate & 0x18) != 0 )
          {
            return 22;
          }
          else
          {
            return 16;
          }
        }
        else if ( (event.bstate & 0x10) != 0 )
        {
          return 22;
        }
        else if ( (event.bstate & 8) != 0 )
        {
          return 16;
        }
        else
        {
          return 26;
        }
      }
      else if ( (event.bstate & 0x18) != 0 )
      {
        return 23;
      }
      else
      {
        return 15;
      }
    }
  }
  return 13;
}

//----- (0804DB0A) --------------------------------------------------------
HTList *__cdecl whichRecall(RecallType recall)
{
  HTList **list; // [esp+14h] [ebp-4h]

  if ( recall == RECALL_CMD )
    return LYcommandList();
  if ( recall == RECALL_MAIL )
    list = &MAIL_edit_history;
  else
    list = &URL_edit_history;
  if ( !*list )
    *list = HTList_new();
  return *list;
}

//----- (0804DB60) --------------------------------------------------------
void __cdecl LYRemoveFromCloset(HTList *list)
{
  void *data; // [esp+14h] [ebp-4h]

  data = HTList_removeFirstObject(list);
  if ( data )
    free(data);
}

//----- (0804DB94) --------------------------------------------------------
void __cdecl LYCloseCloset(RecallType recall)
{
  HTList *list; // [esp+14h] [ebp-4h]

  for ( list = whichRecall(recall); list && list->next; LYRemoveFromCloset(list) )
    ;
  HTList_delete(list);
}

//----- (0804DBD2) --------------------------------------------------------
char *__cdecl LYFindInCloset(RecallType recall, char *base)
{
  char *object; // [esp+10h] [ebp-18h]
  unsigned int len; // [esp+1Ch] [ebp-Ch]
  HTList *list; // [esp+24h] [ebp-4h]

  list = whichRecall(recall);
  len = strlen(base);
  while ( list && list->next )
  {
    list = list->next;
    if ( list )
      object = (char *)list->object;
    else
      object = 0;
    if ( !strncmp(base, object, len) )
      return object;
  }
  return 0;
}
// 804DBFA: conditional instruction was optimized away because %list.4!=0

//----- (0804DC63) --------------------------------------------------------
void __cdecl LYAddToCloset(RecallType recall, char *str)
{
  char *data; // [esp+10h] [ebp-8h] BYREF
  HTList *list; // [esp+14h] [ebp-4h]

  list = whichRecall(recall);
  data = 0;
  HTSACopy(&data, str);
  HTList_addObject(list, data);
  while ( HTList_count(list) > 100 )
    LYRemoveFromCloset(list);
}

//----- (0804DCC1) --------------------------------------------------------
int __cdecl XYdist(int x1, int y1, int x2, int y2, int dx2)
{
  int yerr; // [esp+10h] [ebp-8h]
  int xerr; // [esp+14h] [ebp-4h]

  xerr = 3 * (x2 - x1);
  yerr = 9 * (y2 - y1);
  if ( xerr < 0 )
    xerr = 3 * (x1 - x2 - dx2) + 1;
  if ( xerr < 0 )
    xerr = 0;
  if ( yerr < 0 )
    yerr = -9 * (y2 - y1);
  if ( yerr )
  {
    if ( xerr <= 8 )
      yerr += 9 - xerr;
    return 2 * xerr + yerr;
  }
  else if ( xerr <= 0 )
  {
    return 0;
  }
  else
  {
    return 2 * xerr - 1;
  }
}
// 804DD59: conditional instruction was optimized away because %yerr.4!=0

//----- (0804DD78) --------------------------------------------------------
int __cdecl set_clicked_link(int x, int y, int code, int clicks)
{
  int v4; // esi
  int v5; // ebx
  int v7; // [esp+8h] [ebp-B0h]
  int v8; // [esp+20h] [ebp-98h]
  int v9; // [esp+24h] [ebp-94h]
  _BOOL4 v10; // [esp+28h] [ebp-90h]
  int v16; // [esp+44h] [ebp-74h]
  int v17; // [esp+48h] [ebp-70h]
  int cury; // [esp+50h] [ebp-68h]
  int curx; // [esp+54h] [ebp-64h]
  const char *text; // [esp+78h] [ebp-40h]
  const char *texta; // [esp+78h] [ebp-40h]
  int count; // [esp+7Ch] [ebp-3Ch]
  int is_text; // [esp+80h] [ebp-38h]
  int lx; // [esp+84h] [ebp-34h]
  int len; // [esp+88h] [ebp-30h]
  int cur_err; // [esp+8Ch] [ebp-2Ch]
  int mouse_err; // [esp+90h] [ebp-28h]
  int l; // [esp+94h] [ebp-24h]
  int h; // [esp+98h] [ebp-20h]
  int c; // [esp+A0h] [ebp-18h]
  int i; // [esp+A4h] [ebp-14h]
  int right; // [esp+A8h] [ebp-10h]
  int ya; // [esp+C4h] [ebp+Ch]

  right = LYcols - (LYShowScrollbar != 0) - 5;
  c = -1;
  if ( LYlines - 1 == y || !y )
  {
    v10 = !y && HText_hasToolbar(HTMainText);
    mouse_link = -2;
    if ( !x && v10 )
      return 2122;
    if ( !y && LYcols - (LYShowScrollbar != 0) == x && s_hot_paste != -1 )
      return 2151;
    if ( clicks <= 1 )
    {
      if ( v10 + 6 <= x )
      {
        if ( x <= right )
        {
          if ( y )
            return 2063;
          else
            return 2064;
        }
        else if ( code == 3 && y )
        {
          return 258;
        }
        else
        {
          return 2084;
        }
      }
      else
      {
        if ( code == 3 && y )
          return 259;
        if ( s_forw_backw == -1 || x - v10 <= 2 )
          return 2085;
        else
          return 2086;
      }
    }
    else if ( v10 + 6 <= x )
    {
      if ( x <= right )
      {
        if ( y )
          return 2071;
        else
          return 2070;
      }
      else if ( code == 3 && y )
      {
        return 263;
      }
      else
      {
        return 2109;
      }
    }
    else if ( code == 3 && y )
    {
      return 262;
    }
    else
    {
      return 2096;
    }
  }
  if ( LYcols - 1 != x || !LYShowScrollbar || LYsb_begin < 0 )
  {
    mouse_err = 29;
    for ( i = 0; i < nlinks; ++i )
    {
      lx = links[i].lx;
      is_text = 0;
      count = 0;
      text = LYGetHiliteStr(i, 0);
      if ( links[i].type == 1
        && (links[i].l_form->type == 1
         || links[i].l_form->type == 12
         || links[i].l_form->type == 2
         || links[i].l_form->type == 11
         || links[i].l_form->type == 9) )
      {
        is_text = 1;
      }
      if ( text )
      {
        if ( is_text )
          len = links[i].l_form->size;
        else
          len = strlen(text);
        for ( cur_err = XYdist(x, y, links[i].lx, links[i].ly, len); cur_err > 0; cur_err = v9 )
        {
          texta = LYGetHiliteStr(i, ++count);
          if ( !texta )
            break;
          v4 = strlen(texta);
          v5 = count + links[i].ly;
          v7 = LYGetHilitePos(i, count);
          v8 = XYdist(x, y, v7, v5, v4);
          v9 = cur_err;
          if ( cur_err > v8 )
            v9 = v8;
        }
        if ( cur_err > 0 && is_text )
          --cur_err;
        if ( !cur_err )
        {
          if ( LYwin )
            cury = LYwin->_cury;
          else
            cury = -1;
          if ( LYwin )
            curx = LYwin->_curx;
          else
            curx = -1;
          if ( clicks > 1 && is_text && links[i].l_form->type == 12 )
          {
            if ( code == 2 && cury == y && curx >= lx && curx - lx <= len )
            {
              c = 2088;
              mouse_link = -1;
            }
            else
            {
              c = 2088;
              mouse_link = i;
            }
            mouse_err = 0;
          }
          else
          {
            if ( code == 2 && cury == y && curx >= lx && curx - lx <= len )
            {
              mouse_link = -1;
            }
            else
            {
              if ( is_text )
                have_levent = 1;
              mouse_link = i;
            }
            mouse_err = 0;
          }
          break;
        }
        if ( cur_err < mouse_err )
        {
          mouse_err = cur_err;
          mouse_link = i;
        }
      }
    }
    if ( mouse_link < 0 )
    {
      if ( 2 * y <= LYlines )
      {
        if ( 4 * y >= LYlines )
          return 2065;
        else
          return 2067;
      }
      else if ( 4 * y >= 3 * LYlines )
      {
        return 2068;
      }
      else
      {
        return 2066;
      }
    }
    else if ( mouse_err )
    {
      if ( mouse_err >= 0 )
        return 2132;
    }
    else if ( c == -1 )
    {
      return 2087;
    }
    return c;
  }
  if ( LYsb_arrow )
    v16 = 2;
  else
    v16 = 0;
  h = display_lines - v16;
  mouse_link = -2;
  if ( LYsb_arrow )
    v17 = 2;
  else
    v17 = 1;
  ya = y - v17;
  if ( ya < 0 )
    return 2065;
  if ( ya >= h )
    return 2066;
  if ( clicks <= 1 )
  {
    if ( ya >= LYsb_begin )
    {
      if ( ya < LYsb_end )
      {
        mouse_link = -1;
        return c;
      }
      return 2063;
    }
    else
    {
      return 2064;
    }
  }
  else
  {
    l = HText_getNumOfLines() + 1 - display_lines;
    if ( l > 0 )
      LYSetNewline((int)((long double)l * (double)((long double)ya / (long double)(h - 1)) + 1.0 + 0.5));
    return LYReverseKeymap(69);
  }
}

//----- (0804E53C) --------------------------------------------------------
char *__cdecl LYstrncpy(char *dst, const char *src, int n)
{
  signed int len; // [esp+20h] [ebp-8h]
  char *val; // [esp+24h] [ebp-4h]

  if ( !src )
    src = &value;
  len = strlen(src);
  if ( n < 0 )
    n = 0;
  val = strncpy(dst, src, n);
  if ( len >= n )
    dst[n] = 0;
  else
    dst[len] = 0;
  return val;
}

//----- (0804E5A7) --------------------------------------------------------
char *__cdecl LYmbcsstrncpy(char *dst, const char *src, int n_bytes, int n_glyphs, BOOLEAN utf_flag)
{
  int i_glyphs; // [esp+Ch] [ebp-Ch]
  int i_bytes; // [esp+10h] [ebp-8h]
  char *val; // [esp+14h] [ebp-4h]

  val = dst;
  i_bytes = 0;
  i_glyphs = 0;
  if ( n_bytes < 0 )
    n_bytes = 0;
  if ( n_glyphs < 0 )
    n_glyphs = 0;
  while ( *src && i_bytes < n_bytes )
  {
    if ( utf_flag )
    {
      if ( (*src & 0xC0) != 128 && i_glyphs++ >= n_glyphs )
      {
        *dst = 0;
        return val;
      }
    }
    *dst++ = *src++;
    ++i_bytes;
  }
  *dst = 0;
  return val;
}

//----- (0804E657) --------------------------------------------------------
const char *__cdecl LYmbcs_skip_glyphs(const char *data, int n_glyphs, BOOLEAN utf_flag)
{
  int i_glyphs; // [esp+10h] [ebp-4h]

  i_glyphs = 0;
  if ( n_glyphs < 0 )
    n_glyphs = 0;
  if ( data && *data )
  {
    if ( utf_flag )
    {
      while ( *data )
      {
        if ( (*data & 0xC0) != 128 && i_glyphs++ >= n_glyphs )
          break;
        ++data;
      }
    }
    else
    {
      do
      {
        if ( n_glyphs-- <= 0 )
          break;
        ++data;
      }
      while ( *data );
    }
  }
  return data;
}
// 804E6B2: conditional instruction was optimized away because %utf_flag.1!=0

//----- (0804E6ED) --------------------------------------------------------
const char *__cdecl LYmbcs_skip_cells(const char *data, int n_cells, BOOLEAN utf_flag)
{
  int v3; // edx
  int target; // [esp+1Ch] [ebp-Ch]
  int actual; // [esp+20h] [ebp-8h]
  const char *result; // [esp+24h] [ebp-4h]

  target = n_cells;
  do
  {
    v3 = target--;
    result = LYmbcs_skip_glyphs(data, v3, utf_flag);
    actual = LYstrExtent2(data, result - data);
  }
  while ( actual > 0 && actual > n_cells );
  return result;
}

//----- (0804E751) --------------------------------------------------------
int __cdecl LYmbcsstrlen(const char *str, BOOLEAN utf_flag, BOOLEAN count_gcells)
{
  int len; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  len = 0;
  if ( str && *str )
  {
    if ( count_gcells )
    {
      return LYstrCells(str);
    }
    else
    {
      for ( i = 0; str[i]; ++i )
      {
        if ( str[i] <= 2 || str[i] > 8 )
        {
          ++len;
          if ( !utf_flag || (str[i] & 0xC0) == 128 )
          {
            if ( !utf_flag && HTCJK && str[i] < 0 && str[i + 1] && (str[i + 1] <= 2 || str[i + 1] > 8) )
              ++i;
          }
          else
          {
            for ( j = 0; str[i + 1] && (str[i + 1] <= 2 || str[i + 1] > 8) && j <= 4 && (str[i + 1] & 0xC0) == 128; ++j )
              ++i;
          }
        }
      }
    }
  }
  return len;
}
// 804E83A: conditional instruction was optimized away because %utf_flag.1!=0
// 804E86C: conditional instruction was optimized away because %count_gcells.1==0

//----- (0804E8C9) --------------------------------------------------------
void __cdecl ena_csi(BOOLEAN flag)
{
  csi_is_csi = flag;
}

//----- (0804E8E0) --------------------------------------------------------
int __cdecl lookup_tiname(char *name, const char *const *names)
{
  int code; // [esp+24h] [ebp-4h]

  for ( code = 0; names[code]; ++code )
  {
    if ( !strcmp(names[code], name) )
      return code;
  }
  return -1;
}

//----- (0804E934) --------------------------------------------------------
const char *__cdecl expand_tiname(const char *first, size_t len, char **result, char *final)
{
  char *v4; // ebx
  int code; // [esp+2Ch] [ebp-200Ch]
  char name[8192]; // [esp+30h] [ebp-2008h] BYREF
  unsigned int v8; // [esp+2030h] [ebp-8h]

  v8 = __readgsdword(0x14u);
  strncpy(name, first, len);
  name[len] = 0;
  code = lookup_tiname(name, (const char *const *)&strnames);
  if ( code >= 0 || (code = lookup_tiname(name, (const char *const *)&strfnames), code >= 0) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(cur_term + 16) + 4 * code) )
    {
      LYstrncpy(*result, *(const char **)(*(_DWORD *)(cur_term + 16) + 4 * code), final - *result);
      v4 = *result;
      *result = &v4[strlen(*result)];
    }
  }
  return &first[len];
}
// 81AAB08: using guessed type int cur_term;

//----- (0804EA7A) --------------------------------------------------------
const char *__cdecl expand_tichar(const char *first, char **result, char *final)
{
  size_t v3; // eax
  const char *firsta; // [esp+24h] [ebp-74h]
  char *last; // [esp+2Ch] [ebp-6Ch] BYREF
  const char *name; // [esp+30h] [ebp-68h]
  int value; // [esp+34h] [ebp-64h]
  int radix; // [esp+38h] [ebp-60h]
  int limit; // [esp+3Ch] [ebp-5Ch]
  int ch_0; // [esp+40h] [ebp-58h]
  char tmp[80]; // [esp+44h] [ebp-54h] BYREF
  unsigned int v13; // [esp+94h] [ebp-4h]

  v13 = __readgsdword(0x14u);
  limit = 0;
  radix = 0;
  value = 0;
  name = 0;
  ch_0 = *first;
  firsta = first + 1;
  switch ( ch_0 )
  {
    case 'E':
    case 'e':
      value = 27;
      break;
    case 'a':
      name = "bel";
      break;
    case 'b':
      value = 8;
      break;
    case 'd':
      radix = 10;
      limit = 3;
      break;
    case 'f':
      value = 12;
      break;
    case 'n':
      value = 10;
      break;
    case 'r':
      value = 13;
      break;
    case 't':
      value = 9;
      break;
    case 'v':
      value = 11;
      break;
    case 'x':
      radix = 16;
      limit = 2;
      break;
    default:
      if ( ((*__ctype_b_loc())[ch_0] & 0x800) != 0 )
      {
        radix = 8;
        limit = 3;
        firsta = first;
      }
      else
      {
        value = *firsta;
      }
      break;
  }
  if ( radix )
  {
    last = 0;
    LYstrncpy(tmp, firsta, limit);
    value = strtol(tmp, &last, radix);
    if ( last )
    {
      if ( last != tmp )
        firsta += last - tmp;
    }
  }
  if ( name )
  {
    v3 = strlen(name);
    expand_tiname(name, v3, result, final);
  }
  else
  {
    *(*result)++ = value;
  }
  return firsta;
}

//----- (0804EC60) --------------------------------------------------------
int __cdecl expand_substring(char *dst, const char *first, const char *last, char *final)
{
  size_t v4; // eax
  char *v5; // eax
  char *v6; // edx
  char *v7; // eax
  char *v8; // edx
  char *was; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  int ch_0; // [esp+24h] [ebp-4h]
  int ch_0a; // [esp+24h] [ebp-4h]

  while ( first < last )
  {
    ch_0 = *first++;
    if ( ch_0 == 92 )
    {
      first = expand_tichar(first, &dst, final);
    }
    else if ( ch_0 == 94 )
    {
      ch_0a = *first++;
      if ( ch_0a == 40 )
      {
        s = strchr(first, 41);
        was = dst;
        if ( !s )
        {
          v4 = strlen(first);
          s = (char *)&first[v4];
        }
        first = expand_tiname(first, s - first, &dst, final);
        if ( dst == was )
          return 0;
        if ( *first )
          ++first;
      }
      else if ( ch_0a == 63 )
      {
        v5 = dst;
        *dst = 127;
        dst = v5 + 1;
      }
      else if ( (ch_0a & 0x3Fu) > 0x1F )
      {
        v7 = dst;
        *dst = 94;
        dst = v7 + 1;
        --first;
      }
      else
      {
        v6 = dst;
        *dst = ch_0a & 0x1F;
        dst = v6 + 1;
      }
    }
    else
    {
      if ( !ch_0 )
        LOBYTE(ch_0) = 0x80;
      v8 = dst;
      *dst = ch_0;
      dst = v8 + 1;
    }
  }
  *dst = 0;
  return 1;
}

//----- (0804EDD3) --------------------------------------------------------
void __cdecl unescaped_char(const char *parse, int *keysym)
{
  size_t len; // [esp+20h] [ebp-2008h]
  char buf[8192]; // [esp+24h] [ebp-2004h] BYREF
  unsigned int v4; // [esp+2024h] [ebp-4h]

  v4 = __readgsdword(0x14u);
  len = strlen(parse);
  if ( len > 2 )
  {
    expand_substring(buf, parse + 1, &parse[len - 1], &buf[0x1FFF]);
    if ( strlen(buf) == 1 )
      *keysym = buf[0];
  }
}

//----- (0804EE8D) --------------------------------------------------------
BOOLEAN __cdecl unescape_string(char *src, char *dst, char *final)
{
  const char *v4; // [esp+8h] [ebp-20h]
  int keysym; // [esp+20h] [ebp-8h] BYREF
  BOOLEAN ok; // [esp+27h] [ebp-1h]

  ok = 0;
  if ( *src == 39 )
  {
    keysym = -1;
    unescaped_char(src, &keysym);
    if ( keysym >= 0 )
    {
      *dst = keysym;
      dst[1] = 0;
      return 1;
    }
  }
  else if ( *src == 34 )
  {
    v4 = &src[strlen(src) - 1];
    return expand_substring(dst, src + 1, v4, final);
  }
  return ok;
}

//----- (0804EF20) --------------------------------------------------------
int __cdecl map_string_to_keysym(const char *str, int *keysym)
{
  int v2; // edx
  int v3; // edx
  int v4; // edx
  size_t v7; // [esp+1Ch] [ebp-202Ch]
  const char *stra; // [esp+24h] [ebp-2024h]
  Keysym_String_List *k; // [esp+28h] [ebp-2020h]
  int value; // [esp+2Ch] [ebp-201Ch]
  char *tmp; // [esp+30h] [ebp-2018h] BYREF
  size_t len; // [esp+34h] [ebp-2014h]
  int othersym; // [esp+38h] [ebp-2010h]
  char *other; // [esp+3Ch] [ebp-200Ch]
  int modifier; // [esp+40h] [ebp-2008h]
  char buf[8192]; // [esp+44h] [ebp-2004h] BYREF
  unsigned int v17; // [esp+2044h] [ebp-4h]

  stra = str;
  v17 = __readgsdword(0x14u);
  modifier = 0;
  *keysym = -1;
  if ( !strncasecomp(str, "LAC:", 4) )
  {
    other = strchr(str + 4, 58);
    if ( other )
    {
      othersym = lecname_to_lec(other + 1);
      if ( othersym >= 0 && other - str - 4 <= 0x1FFF )
      {
        strncpy(buf, str + 4, other - str - 4);
        buf[other - str - 4] = 0;
        *keysym = lacname_to_lac(buf);
        if ( *keysym >= 0 )
        {
          v2 = *keysym | (othersym << 8);
          BYTE1(v2) |= 0x80u;
          *keysym = v2;
          return *keysym;
        }
      }
    }
    *keysym = lacname_to_lac(str + 4);
    if ( *keysym >= 0 )
    {
      v3 = *keysym;
      BYTE1(v3) = BYTE1(*keysym) | 8;
      *keysym = v3;
      return *keysym;
    }
  }
  if ( !strncasecomp(str, "Meta-", 5) )
  {
    stra = str + 5;
    modifier = 0x2000;
    if ( str[5] )
    {
      len = strlen(stra);
      if ( len == 1 )
      {
        *keysym = modifier | *(unsigned __int8 *)stra;
        return *keysym;
      }
      if ( len == 2
        && *stra == 94
        && (((*__ctype_b_loc())[*((unsigned __int8 *)str + 6)] & 0x400) != 0 || str[6] > 63 && str[6] <= 95) )
      {
        *keysym = modifier | str[6] & 0x1F;
        return *keysym;
      }
      if ( len == 2 && *stra == 94 && str[6] == 63 )
      {
        *keysym = modifier | 0x7F;
        return *keysym;
      }
      if ( *stra == 94 || *stra == 92 )
      {
        v7 = len;
        if ( len > 0x1C )
          v7 = 28;
        expand_substring(buf, stra, &stra[v7], &buf[0x1FFF]);
        if ( strlen(buf) <= 1 )
        {
          *keysym = modifier | (unsigned __int8)buf[0];
          return *keysym;
        }
      }
    }
  }
  if ( *stra == 39 )
  {
    unescaped_char(stra, keysym);
  }
  else if ( ((*__ctype_b_loc())[*(unsigned __int8 *)stra] & 0x800) != 0 )
  {
    value = strtol(stra, &tmp, 0);
    if ( ((*__ctype_b_loc())[(unsigned __int8)*tmp] & 8) == 0 )
    {
      *keysym = value;
      if ( *keysym > 255 )
      {
        v4 = *keysym;
        BYTE1(v4) = BYTE1(*keysym) | 4;
        *keysym = v4;
      }
    }
  }
  else
  {
    for ( k = Keysym_Strings; k->string; ++k )
    {
      if ( !strcmp(k->string, stra) )
      {
        *keysym = k->value;
        break;
      }
    }
  }
  if ( *keysym >= 0 )
    *keysym |= modifier;
  return *keysym;
}

//----- (0804F48B) --------------------------------------------------------
char *__cdecl skip_keysym(char *parse)
{
  int escaped; // [esp+10h] [ebp-8h]
  int quoted; // [esp+14h] [ebp-4h]

  quoted = 0;
  escaped = 0;
  while ( *parse )
  {
    if ( escaped )
    {
      escaped = 0;
    }
    else if ( quoted )
    {
      if ( *parse == 92 )
      {
        escaped = 1;
      }
      else if ( *parse == quoted )
      {
        quoted = 0;
      }
    }
    else if ( *parse == 92 )
    {
      escaped = 1;
    }
    else if ( *parse == 34 || *parse == 39 )
    {
      quoted = *parse;
    }
    else if ( ((*__ctype_b_loc())[(unsigned __int8)*parse] & 0x2000) != 0 )
    {
      break;
    }
    ++parse;
  }
  if ( quoted || escaped )
    return 0;
  else
    return parse;
}

//----- (0804F571) --------------------------------------------------------
int __cdecl setkey_cmd(char *parse)
{
  FILE *v1; // edx
  FILE *v2; // eax
  FILE *v3; // eax
  int v4; // ebx
  FILE *v5; // eax
  int v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  int keysym; // [esp+24h] [ebp-2014h] BYREF
  char *t; // [esp+28h] [ebp-2010h]
  char *s; // [esp+2Ch] [ebp-200Ch]
  char buf[8192]; // [esp+30h] [ebp-2008h] BYREF
  unsigned int v17; // [esp+2030h] [ebp-8h]

  v17 = __readgsdword(0x14u);
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "KEYMAP(PA): in=%s", parse);
  }
  s = skip_keysym(parse);
  if ( !s )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v10 = TraceFP();
      fprintf(v10, "KEYMAP(SKIP) no key description\n");
    }
    return -1;
  }
  if ( ((*__ctype_b_loc())[(unsigned __int8)*s] & 0x2000) == 0 )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v9 = TraceFP();
      fprintf(v9, "KEYMAP(SKIP) junk after key description: '%s'\n", s);
    }
    return -1;
  }
  *s = 0;
  s = LYSkipBlanks(s + 1);
  t = skip_keysym(s);
  if ( !t )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v2 = TraceFP();
      fprintf(v2, "KEYMAP(SKIP) no key expansion found\n");
    }
    return -1;
  }
  if ( t != s )
    *t = 0;
  if ( map_string_to_keysym(s, &keysym) < 0 )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v8 = TraceFP();
      fprintf(v8, "KEYMAP(SKIP) could not map to keysym\n");
    }
    return -1;
  }
  if ( unescape_string(parse, buf, &buf[0x1FFF]) )
  {
    if ( LYTraceLogFP )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v6 = keysym;
        v7 = TraceFP();
        fprintf(v7, "KEYMAP(DEF) keysym=%#x, seq='%s'\n", v6, buf);
      }
    }
    else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v4 = keysym;
      v5 = TraceFP();
      fprintf(v5, "KEYMAP(DEF) keysym=%#x\n", v4);
    }
    return define_key(buf, keysym);
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "KEYMAP(SKIP) could unescape key\n");
    }
    return 0;
  }
}

//----- (0804F8A6) --------------------------------------------------------
int __cdecl unsetkey_cmd(char *parse)
{
  int keysym; // [esp+10h] [ebp-8h] BYREF
  char *s; // [esp+14h] [ebp-4h]

  s = skip_keysym(parse);
  if ( s != parse )
  {
    *s = 0;
    if ( map_string_to_keysym(parse, &keysym) >= 0 )
      define_key(0, keysym);
  }
  return 0;
}

//----- (0804F8F8) --------------------------------------------------------
int read_keymap_file()
{
  int (__cdecl *v0)(char *); // ebx
  char *v1; // eax
  char *v2; // eax
  size_t len; // [esp+18h] [ebp-120h]
  const char *s; // [esp+1Ch] [ebp-11Ch]
  size_t n; // [esp+20h] [ebp-118h]
  int linenum; // [esp+24h] [ebp-114h]
  FILE *fp; // [esp+28h] [ebp-110h]
  char *line; // [esp+2Ch] [ebp-10Ch] BYREF
  char file[256]; // [esp+30h] [ebp-108h] BYREF
  unsigned int v11; // [esp+130h] [ebp-8h]

  v11 = __readgsdword(0x14u);
  line = 0;
  LYAddPathToHome(file, 0x100u, ".lynx-keymaps");
  fp = (FILE *)fopen64(file, "r");
  if ( fp )
  {
    linenum = 0;
    while ( LYSafeGets(&line, fp) )
    {
      s = LYSkipBlanks(line);
      ++linenum;
      if ( *s && *s != 35 )
      {
        for ( n = 0; n <= 1; ++n )
        {
          len = strlen(table_12243[n].name);
          if ( strlen(s) > len && !strncmp(s, table_12243[n].name, len) )
          {
            v0 = (int (__cdecl *)(char *))*(&off_8194544 + 2 * n);
            v1 = LYSkipBlanks((char *)&s[len]);
            if ( v0(v1) < 0 )
            {
              v2 = gettext("Error processing line %d of %s\n");
              fprintf(stderr, v2, linenum, file);
            }
          }
        }
      }
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
    LYCloseInput(fp);
  }
  return 0;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);
// 8194544: using guessed type int (__cdecl *off_8194544)(int);

//----- (0804FB14) --------------------------------------------------------
void setup_vtXXX_keymap()
{
  size_t n; // [esp+14h] [ebp-4h]

  for ( n = 0; n <= 0x14; ++n )
    define_key(table_12296[n].string, table_12296[n].value);
}

//----- (0804FB4F) --------------------------------------------------------
int lynx_initialize_keymaps()
{
  setup_vtXXX_keymap();
  return read_keymap_file();
}

//----- (0804FB61) --------------------------------------------------------
int __cdecl LYmouse_menu(int x, int y, int atlink, int code)
{
  int v5; // [esp+2Ch] [ebp-FCh]
  int column; // [esp+30h] [ebp-F8h]
  int cur_choice; // [esp+34h] [ebp-F4h]
  const char *choices[27]; // [esp+44h] [ebp-E4h] BYREF
  int actions[26]; // [esp+B0h] [ebp-78h]
  int filter_out; // [esp+118h] [ebp-10h]
  int retlac; // [esp+11Ch] [ebp-Ch]
  int c1; // [esp+120h] [ebp-8h]
  int c; // [esp+124h] [ebp-4h]

  if ( atlink )
    v5 = 1;
  else
    v5 = 2;
  filter_out = v5;
  c1 = 0;
  for ( c = 0; c <= 25; ++c )
  {
    if ( (possible_entries_12321[c].flag & filter_out) == 0 )
    {
      choices[c1] = possible_entries_12321[c].txt;
      actions[c1++] = possible_entries_12321[c].action;
    }
  }
  choices[c1] = 0;
  if ( x <= 5 )
    column = 1;
  else
    column = x - 5;
  if ( atlink )
    cur_choice = 1;
  else
    cur_choice = 9;
  c = popup_choice(cur_choice, y, column, choices, c1, 0, 1);
  if ( term_options[0] )
  {
    retlac = 69;
    term_options[0] = 0;
  }
  else
  {
    retlac = actions[c];
  }
  if ( code == 2 && mouse_link == -1 )
  {
    switch ( retlac )
    {
      case 12:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 22:
      case 23:
      case 36:
      case 37:
      case 42:
      case 43:
      case 48:
      case 49:
      case 50:
      case 51:
      case 56:
      case 57:
      case 60:
      case 79:
        goto LABEL_22;
      case 14:
        retlac = 13;
LABEL_22:
        mouse_link = -3;
        break;
      default:
        break;
    }
  }
  if ( retlac == 69 || retlac == 21 )
    mouse_link = -1;
  if ( code == 2 && retlac == 69 )
    repaint_main_statusline(2);
  return retlac;
}

//----- (0804FD24) --------------------------------------------------------
int __cdecl LYgetch_for(int code)
{
  WINDOW *v1; // eax
  FILE *v2; // eax
  int v3; // ebx
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // eax
  WINDOW *v7; // eax
  WINDOW *v8; // eax
  WINDOW *v9; // eax
  WINDOW *v10; // eax
  WINDOW *v11; // eax
  WINDOW *v12; // eax
  WINDOW *v13; // eax
  WINDOW *v14; // eax
  WINDOW *v15; // eax
  WINDOW *v16; // eax
  int v17; // eax
  FILE *v18; // eax
  WINDOW *v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // ebx
  FILE *v23; // eax
  int v24; // ebx
  FILE *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  char *v28; // eax
  int v29; // edx
  int v32; // [esp+28h] [ebp-50h]
  int v34; // [esp+30h] [ebp-48h]
  MEVENT event; // [esp+3Ch] [ebp-3Ch] BYREF
  int atlink; // [esp+50h] [ebp-28h]
  int lac; // [esp+54h] [ebp-24h]
  int current_modifier; // [esp+5Ch] [ebp-1Ch]
  int d; // [esp+60h] [ebp-18h]
  int c; // [esp+64h] [ebp-14h]
  int b; // [esp+68h] [ebp-10h]
  int a; // [esp+6Ch] [ebp-Ch]
  BOOLEAN done_esc; // [esp+73h] [ebp-5h]

  d = -1;
  current_modifier = 0;
  done_esc = 0;
  have_levent = 0;
  while ( 2 )
  {
    if ( *__errno_location() == 4 )
      *__errno_location() = 0;
    clearerr(stdin);
    v1 = LYtopwindow();
    c = wgetch(v1);
    lynx_nl2crlf(0);
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "GETCH: Got %#x.\n", c);
    }
    if ( c == -1 && *__errno_location() == 4 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = recent_sizechange;
        v4 = TraceFP();
        fprintf(v4, "Got EOF with EINTR, recent_sizechange so far is %d\n", v3);
      }
      if ( !recent_sizechange )
      {
        size_change(0);
        if ( WWW_TraceFlag[0] )
        {
          v5 = recent_sizechange;
          v6 = TraceFP();
          fprintf(v6, "Now recent_sizechange is %d\n", v5);
        }
      }
      *__errno_location() = 0;
      return 270;
    }
    if ( feof(stdin) || ferror(stdin) || c == -1 )
    {
      if ( !recent_sizechange )
      {
        cleanup();
        exit_immediately(0);
      }
      return 7;
    }
    if ( !escape_bound && (c == 27 || csi_is_csi && c == 155) )
    {
      done_esc = 1;
      v7 = LYtopwindow();
      b = wgetch(v7);
      if ( b == 91 || b == 79 )
      {
        v8 = LYtopwindow();
        a = wgetch(v8);
      }
      else
      {
        a = b;
      }
      switch ( a )
      {
        case '1':
          if ( (b == 91 || c == 155) && (v9 = LYtopwindow(), d = wgetch(v9), d == 126) )
            c = 266;
          else
            done_esc = 0;
          break;
        case '2':
          if ( b == 91 || c == 155 )
          {
            v10 = LYtopwindow();
            d = wgetch(v10);
            if ( d == 126 )
            {
              c = 268;
            }
            else if ( d == 56 || d == 57 )
            {
              v11 = LYtopwindow();
              if ( wgetch(v11) == 126 )
              {
                if ( d == 56 )
                {
                  c = 264;
                }
                else if ( d == 57 )
                {
                  c = 265;
                }
                d = -1;
              }
            }
          }
          else
          {
            done_esc = 0;
          }
          break;
        case '3':
          if ( (b == 91 || c == 155) && (v12 = LYtopwindow(), d = wgetch(v12), d == 126) )
            c = 269;
          else
            done_esc = 0;
          break;
        case '4':
          if ( (b == 91 || c == 155) && (v13 = LYtopwindow(), d = wgetch(v13), d == 126) )
            c = 267;
          else
            done_esc = 0;
          break;
        case '5':
          if ( (b == 91 || c == 155) && (v14 = LYtopwindow(), d = wgetch(v14), d == 126) )
            c = 261;
          else
            done_esc = 0;
          break;
        case '6':
          if ( (b == 91 || c == 155) && (v15 = LYtopwindow(), d = wgetch(v15), d == 126) )
            c = 260;
          else
            done_esc = 0;
          break;
        case 'A':
          c = 256;
          break;
        case 'B':
          c = 257;
          break;
        case 'C':
          c = 258;
          break;
        case 'D':
          c = 259;
          break;
        case 'M':
          c = 10;
          break;
        case 'P':
          c = 264;
          break;
        case '[':
          if ( b != 91 && c != 155 )
            goto LABEL_92;
          v16 = LYtopwindow();
          d = wgetch(v16);
          if ( d == 65 )
            c = 264;
          break;
        case 'k':
          if ( b == 79 )
            c = 43;
          else
            done_esc = 0;
          break;
        case 'l':
          c = 43;
          break;
        case 'm':
          c = 45;
          break;
        case 'p':
          c = 48;
          break;
        case 'q':
          c = 263;
          break;
        case 'r':
          c = 257;
          break;
        case 's':
          c = 260;
          break;
        case 't':
          c = 259;
          break;
        case 'u':
          c = 264;
          break;
        case 'v':
          c = 258;
          break;
        case 'w':
          c = 262;
          break;
        case 'x':
          c = 256;
          break;
        case 'y':
          c = 261;
          break;
        default:
LABEL_92:
          if ( c == 27 && a == b && b != 91 )
          {
            current_modifier = 0x2000;
            c = a;
            v17 = a;
            LOBYTE(v17) = 0;
            done_esc = v17 == 0;
          }
          else
          {
            if ( WWW_TraceFlag[0] )
            {
              v18 = TraceFP();
              fprintf(v18, "Unknown key sequence: %d:%d:%d\n", c, b, a);
            }
            if ( WWW_TraceFlag[0] && !LYTraceLogFP )
              sleep(MessageSecs);
          }
          break;
      }
      if ( ((*__ctype_b_loc())[a] & 0x800) != 0 && (b == 91 || c == 155) && d != -1 && d != 126 )
      {
        v19 = LYtopwindow();
        d = wgetch(v19);
      }
      if ( !done_esc )
      {
        v20 = a;
        LOBYTE(v20) = 0;
        if ( !v20 )
        {
          if ( a != b || b == 91 || c == 155 || c != 27 )
          {
            done_esc = 1;
          }
          else
          {
            current_modifier = 0x2000;
            c = a;
            done_esc = 1;
          }
        }
      }
    }
    if ( c >= 0 && (c & 0x8000) != 0 )
    {
      if ( code != 2 && code != 3 )
      {
        if ( (c & 0x8000) != 0 )
        {
          v21 = (unsigned __int8)c;
          BYTE1(v21) = 8;
          v32 = v21;
        }
        else
        {
          v32 = c;
        }
        c = v32;
      }
    }
    else if ( c >= 0 && (c & 0x400) != 0 )
    {
      c &= ~0x400u;
      done_esc = 1;
    }
    if ( c >= 0 && (c & 0x8000) == 0 && (c & 0x2000) != 0 )
    {
      current_modifier = 0x2000;
      c &= 0x7FFu;
    }
    if ( c >= 0 && (c & 0x8800) != 0 )
      done_esc = 1;
    if ( done_esc )
      goto LABEL_221;
    switch ( c )
    {
      case 258:
        c = 257;
        goto LABEL_221;
      case 259:
        c = 256;
        goto LABEL_221;
      case 260:
        c = 259;
        goto LABEL_221;
      case 261:
        c = 258;
        goto LABEL_221;
      case 262:
        c = 262;
        goto LABEL_221;
      case 263:
        c = 127;
        goto LABEL_221;
      case 265:
        c = 264;
        goto LABEL_221;
      case 280:
        c = 265;
        goto LABEL_221;
      case 330:
        c = 269;
        goto LABEL_221;
      case 331:
        c = 268;
        goto LABEL_221;
      case 333:
        c = 18;
        goto LABEL_221;
      case 338:
        c = 260;
        goto LABEL_221;
      case 339:
        c = 261;
        goto LABEL_221;
      case 343:
        c = 10;
        goto LABEL_221;
      case 347:
        c = 263;
        goto LABEL_221;
      case 348:
        c = 262;
        goto LABEL_221;
      case 349:
        c = 261;
        goto LABEL_221;
      case 350:
        c = 270;
        goto LABEL_221;
      case 351:
        c = 263;
        goto LABEL_221;
      case 352:
        c = 260;
        goto LABEL_221;
      case 353:
        c = 271;
        goto LABEL_221;
      case 360:
        c = 263;
        goto LABEL_221;
      case 362:
        c = 266;
        goto LABEL_221;
      case 363:
        c = 264;
        goto LABEL_221;
      case 371:
        c = 265;
        goto LABEL_221;
      case 385:
        c = 267;
        goto LABEL_221;
      case 409:
        if ( WWW_TraceFlag[0] )
        {
          v26 = TraceFP();
          fprintf(v26, "KEY_MOUSE\n");
        }
        if ( code == 1 )
        {
          c = 285;
LABEL_221:
          if ( (c & 0x8800) != 0 )
            return c;
          if ( c + 1 <= 660 )
            return current_modifier | c;
          return 0;
        }
        if ( code == 4 )
        {
          getmouse(&event);
          c = 270;
          goto LABEL_221;
        }
        lac = 0;
        c = -1;
        mouse_link = -1;
        if ( !getmouse(&event) )
        {
          levent = event;
          if ( (event.bstate & 4) != 0 )
          {
            c = set_clicked_link(event.x, event.y, code, 1);
            goto LABEL_213;
          }
          if ( (event.bstate & 8) != 0 )
          {
            c = set_clicked_link(event.x, event.y, code, 2);
            if ( c == 2088 && code == 2 )
              lac = 40;
            goto LABEL_213;
          }
          if ( (event.bstate & 0x4000) != 0 )
          {
            c = 2085;
            goto LABEL_213;
          }
          if ( code != 3 && (event.bstate & 0x30C3) == 0 )
          {
            if ( (event.bstate & 0x100) != 0 )
            {
              c = set_clicked_link(event.x, event.y, code, 1);
              atlink = c == 2087;
              if ( c != 2087 )
                mouse_link = -1;
              lac = LYmouse_menu(event.x, event.y, atlink, code);
              if ( lac == 40 )
              {
                if ( mouse_link == -1 )
                {
                  lac = 39;
                }
                else if ( mouse_link >= 0
                       && textfields_need_activation
                       && links[mouse_link].type == 1
                       && (links[mouse_link].l_form->type == 1
                        || links[mouse_link].l_form->type == 12
                        || links[mouse_link].l_form->type == 2
                        || links[mouse_link].l_form->type == 11
                        || links[mouse_link].l_form->type == 9) )
                {
                  lac = 39;
                }
              }
              if ( lac == 39 && mouse_link == -1 )
              {
                v28 = gettext("No link chosen");
                HTAlert(v28);
                lac = 21;
              }
              if ( LYReverseKeymap(lac) < 0 )
              {
                v29 = lac;
                BYTE1(v29) = BYTE1(lac) | 8;
                v34 = v29;
              }
              else
              {
                v34 = LYReverseKeymap(lac);
              }
              c = v34;
            }
LABEL_213:
            if ( code == 2 && mouse_link == -1 && lac != 21 && lac != 40 )
            {
              ungetmouse(&event);
              wgetch(LYwin);
              c = 285;
            }
            if ( c + 1 > 660 && (c & 0x800) != 0 )
              return c;
            goto LABEL_221;
          }
          continue;
        }
        if ( WWW_TraceFlag[0] )
        {
          v27 = TraceFP();
          fprintf(v27, "Mouse error: no event available!\n");
        }
        if ( code )
          return 270;
        else
          return 0;
      case 410:
        if ( WWW_TraceFlag[0] )
        {
          v22 = recent_sizechange;
          v23 = TraceFP();
          fprintf(v23, "Got KEY_RESIZE, recent_sizechange so far is %d\n", v22);
        }
        size_change(0);
        if ( WWW_TraceFlag[0] )
        {
          v24 = recent_sizechange;
          v25 = TraceFP();
          fprintf(v25, "Now recent_sizechange is %d\n", v24);
        }
        if ( recent_sizechange )
        {
          c = 270;
          goto LABEL_221;
        }
        recent_sizechange = 1;
        continue;
      default:
        goto LABEL_221;
    }
  }
}
// 805021B: conditional instruction was optimized away because %c.4==1B
// 8050341: conditional instruction was optimized away because %c.4>=0
// 8050396: conditional instruction was optimized away because %c.4>=0

//----- (080509C7) --------------------------------------------------------
int LYgetch()
{
  return LYReadCmdKey(0);
}

//----- (080509DB) --------------------------------------------------------
int LYgetch_choice()
{
  int ch_0; // [esp+14h] [ebp-4h]

  ch_0 = LYReadCmdKey(1);
  if ( ch_0 == 3 )
    return 7;
  return ch_0;
}

//----- (08050A02) --------------------------------------------------------
int LYgetch_input()
{
  int ch_0; // [esp+14h] [ebp-4h]

  ch_0 = LYReadCmdKey(2);
  if ( ch_0 == 3 )
    return 7;
  return ch_0;
}

//----- (08050A29) --------------------------------------------------------
int LYgetch_single()
{
  int ch_0; // [esp+14h] [ebp-4h]

  ch_0 = LYReadCmdKey(4);
  if ( ch_0 == 3 )
    return 7;
  if ( ch_0 > 0 && ch_0 <= 255 )
  {
    if ( ((*__ctype_b_loc())[(unsigned __int8)ch_0] & 0x200) != 0 )
      return toupper((unsigned __int8)ch_0);
    else
      return (unsigned __int8)ch_0;
  }
  return ch_0;
}

//----- (08050AA4) --------------------------------------------------------
void __cdecl LYLowerCase(char *arg_buffer)
{
  char v1; // [esp+13h] [ebp-15h]
  size_t i; // [esp+24h] [ebp-4h]

  for ( i = 0; arg_buffer[i]; ++i )
  {
    if ( arg_buffer[i] < 0 && arg_buffer[i + 1] )
    {
      if ( kanji_code != SJIS || (unsigned __int8)arg_buffer[i] <= 0xA0u || (unsigned __int8)arg_buffer[i] > 0xDFu )
        ++i;
    }
    else
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)arg_buffer[i]] & 0x100) != 0 )
        v1 = tolower((unsigned __int8)arg_buffer[i]);
      else
        v1 = arg_buffer[i];
      arg_buffer[i] = v1;
    }
  }
}

//----- (08050B78) --------------------------------------------------------
void __cdecl LYUpperCase(char *arg_buffer)
{
  char v1; // [esp+13h] [ebp-15h]
  size_t i; // [esp+24h] [ebp-4h]

  for ( i = 0; arg_buffer[i]; ++i )
  {
    if ( arg_buffer[i] < 0 && arg_buffer[i + 1] )
    {
      if ( kanji_code != SJIS || (unsigned __int8)arg_buffer[i] <= 0xA0u || (unsigned __int8)arg_buffer[i] > 0xDFu )
        ++i;
    }
    else
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)arg_buffer[i]] & 0x200) != 0 )
        v1 = toupper((unsigned __int8)arg_buffer[i]);
      else
        v1 = arg_buffer[i];
      arg_buffer[i] = v1;
    }
  }
}

//----- (08050C4C) --------------------------------------------------------
BOOLEAN __cdecl LYRemoveNewlines(char *buffer)
{
  char *buf; // [esp+4h] [ebp-14h]
  char *old; // [esp+14h] [ebp-4h]

  if ( !buffer )
    return 0;
  for ( buf = buffer; *buf && *buf != 10 && *buf != 13; ++buf )
    ;
  if ( !*buf )
    return 0;
  for ( old = buf; *old; ++old )
  {
    if ( *old != 10 && *old != 13 )
      *buf++ = *old;
  }
  *buf = 0;
  return 1;
}

//----- (08050CDB) --------------------------------------------------------
char *__cdecl LYReduceBlanks(char *buffer)
{
  if ( buffer && *buffer )
  {
    LYTrimLeading(buffer);
    LYTrimTrailing(buffer);
    convert_to_spaces(buffer, 1);
  }
  return buffer;
}

//----- (08050D1F) --------------------------------------------------------
char *__cdecl LYRemoveBlanks(char *buffer)
{
  char *buf; // [esp+4h] [ebp-14h]
  char *old; // [esp+14h] [ebp-4h]

  if ( !buffer )
    return 0;
  for ( buf = buffer; *buf && ((*__ctype_b_loc())[(unsigned __int8)*buf] & 0x2000) == 0; ++buf )
    ;
  if ( *buf )
  {
    for ( old = buf; *old; ++old )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)*old] & 0x2000) == 0 )
        *buf++ = *old;
    }
    *buf = 0;
  }
  return buf;
}

//----- (08050DD6) --------------------------------------------------------
char *__cdecl LYSkipBlanks(char *buffer)
{
  while ( ((*__ctype_b_loc())[(unsigned __int8)*buffer] & 0x2000) != 0 )
    ++buffer;
  return buffer;
}

//----- (08050E0B) --------------------------------------------------------
char *__cdecl LYSkipNonBlanks(char *buffer)
{
  while ( *buffer && ((*__ctype_b_loc())[(unsigned __int8)*buffer] & 0x2000) == 0 )
    ++buffer;
  return buffer;
}

//----- (08050E4A) --------------------------------------------------------
const char *__cdecl LYSkipCBlanks(const char *buffer)
{
  while ( ((*__ctype_b_loc())[*(unsigned __int8 *)buffer] & 0x2000) != 0 )
    ++buffer;
  return buffer;
}

//----- (08050E7F) --------------------------------------------------------
const char *__cdecl LYSkipCNonBlanks(const char *buffer)
{
  while ( *buffer && ((*__ctype_b_loc())[*(unsigned __int8 *)buffer] & 0x2000) == 0 )
    ++buffer;
  return buffer;
}

//----- (08050EBE) --------------------------------------------------------
void __cdecl LYTrimLeading(char *buffer)
{
  bool v1; // al
  char *skipped; // [esp+14h] [ebp-4h]

  skipped = LYSkipBlanks(buffer);
  do
  {
    *buffer = *skipped;
    v1 = *buffer++ != 0;
    ++skipped;
  }
  while ( v1 );
}

//----- (08050EF6) --------------------------------------------------------
char *__cdecl LYTrimNewline(char *buffer)
{
  size_t i; // [esp+14h] [ebp-4h]

  for ( i = strlen(buffer); i && (buffer[i - 1] == 10 || buffer[i - 1] == 13); buffer[i] = 0 )
    --i;
  return buffer;
}

//----- (08050F47) --------------------------------------------------------
void __cdecl LYTrimTrailing(char *buffer)
{
  size_t i; // [esp+14h] [ebp-4h]

  for ( i = strlen(buffer); i && ((*__ctype_b_loc())[(unsigned __int8)buffer[i - 1]] & 0x2000) != 0; buffer[i] = 0 )
    --i;
}

//----- (08050F9F) --------------------------------------------------------
char *__cdecl LYElideString(char *str, int cut_pos)
{
  bool v2; // al
  int len; // [esp+14h] [ebp-414h]
  char *d; // [esp+18h] [ebp-410h]
  char *s; // [esp+1Ch] [ebp-40Ch]
  char buff[1024]; // [esp+20h] [ebp-408h] BYREF
  unsigned int v8; // [esp+420h] [ebp-8h]

  v8 = __readgsdword(0x14u);
  LYstrncpy(buff, str, 1023);
  len = strlen(buff);
  if ( LYcols - (LYShowScrollbar != 0) - 9 < len )
  {
    buff[cut_pos] = 46;
    buff[cut_pos + 1] = 46;
    s = &buff[len + 10 + (LYShowScrollbar != 0) - LYcols + cut_pos];
    d = &buff[cut_pos + 2];
    do
    {
      if ( s < buff )
        break;
      if ( d < buff )
        break;
      if ( &buff[LYcols] <= d )
        break;
      *d = *s;
      v2 = *d++ != 0;
      ++s;
    }
    while ( v2 );
    buff[LYcols] = 0;
  }
  strcpy(s_str_13245, buff);
  return s_str_13245;
}

//----- (08051128) --------------------------------------------------------
BOOLEAN __cdecl LYTrimStartfile(char *buffer)
{
  LYTrimHead(buffer);
  if ( (*buffer != 108 && *buffer != 76 || strncasecomp(buffer, "lynxexec:", 9))
    && (*buffer != 108 && *buffer != 76 || strncasecomp(buffer, "lynxprog:", 9)) )
  {
    return 0;
  }
  HTUnEscapeSome(buffer, " \r\n\t");
  convert_to_spaces(buffer, 1);
  return 1;
}

//----- (080511D5) --------------------------------------------------------
void __cdecl LYEscapeStartfile(char **buffer)
{
  char *escaped; // [esp+14h] [ebp-4h]

  if ( !LYTrimStartfile(*buffer) )
  {
    escaped = HTEscapeUnsafe(*buffer);
    HTSACopy(buffer, escaped);
    if ( escaped )
      free(escaped);
  }
}

//----- (08051228) --------------------------------------------------------
void __cdecl LYTrimAllStartfile(char *buffer)
{
  if ( !LYTrimStartfile(buffer) )
    LYRemoveBlanks(buffer);
}

//----- (0805124A) --------------------------------------------------------
void __cdecl LYSetupEdit(EditFieldData *edit, char *old, int maxstr, int maxdsp)
{
  int cury; // [esp+10h] [ebp-8h]
  int curx; // [esp+14h] [ebp-4h]

  if ( LYwin )
    cury = LYwin->_cury;
  else
    cury = -1;
  edit->sy = cury;
  if ( LYwin )
    curx = LYwin->_curx;
  else
    curx = -1;
  edit->sx = curx;
  edit->pad = 32;
  edit->dirty = 1;
  edit->panon = 0;
  edit->current_modifiers = 0;
  edit->maxlen = maxstr;
  edit->dspwdth = maxdsp;
  edit->margin = 0;
  edit->pos = strlen(old);
  edit->mark = -1;
  edit->xpan = 0;
  if ( maxstr > maxdsp )
  {
    if ( edit->dspwdth > 4 )
      edit->panon = 1;
    edit->margin = edit->dspwdth / 4;
    if ( edit->margin > 10 )
      edit->margin = 10;
  }
  LYstrncpy(edit->buffer, old, maxstr);
  edit->strlen = strlen(edit->buffer);
}

//----- (0805137E) --------------------------------------------------------
int __cdecl mbcs_glyphs(char *s, int len)
{
  int i; // [esp+8h] [ebp-8h]
  int ia; // [esp+8h] [ebp-8h]
  int glyphs; // [esp+Ch] [ebp-4h]

  glyphs = 0;
  if ( LYCharSet_UC[current_char_set].enc == 7 )
  {
    for ( i = 0; s[i] && i < len; ++i )
    {
      if ( (s[i] & 0xC0) != 128 )
        ++glyphs;
    }
  }
  else if ( HTCJK )
  {
    for ( ia = 0; s[ia] && ia < len; ++ia )
    {
      if ( s[ia] < 0 )
        ++ia;
      ++glyphs;
    }
  }
  else
  {
    return len;
  }
  return glyphs;
}

//----- (0805142B) --------------------------------------------------------
int __cdecl mbcs_skip(char *s, int pos)
{
  int i; // [esp+8h] [ebp-8h]
  int p; // [esp+Ch] [ebp-4h]
  int pa; // [esp+Ch] [ebp-4h]

  if ( LYCharSet_UC[current_char_set].enc == 7 )
  {
    i = 0;
    p = 0;
    while ( s[i] )
    {
      if ( (s[i] & 0xC0) != 128 )
        ++p;
      if ( p > pos )
        break;
      ++i;
    }
  }
  else if ( HTCJK )
  {
    i = 0;
    for ( pa = 0; s[i] && pa < pos; ++pa )
    {
      if ( s[i] < 0 )
        ++i;
      ++i;
    }
  }
  else
  {
    return pos;
  }
  return i;
}

//----- (080514DE) --------------------------------------------------------
int __cdecl cell2char(char *s, int cells)
{
  int pos; // [esp+Ch] [ebp-Ch]
  int len; // [esp+10h] [ebp-8h]

  len = strlen(s);
  for ( pos = 0; pos <= len && LYstrExtent2(s, pos) < cells; ++pos )
    ;
  if ( pos > len )
    pos = len;
  return mbcs_glyphs(s, pos);
}

//----- (08051553) --------------------------------------------------------
int __cdecl LYEditInsert(EditFieldData *edit, const unsigned __int8 *s, int len, int map, BOOLEAN maxMessage)
{
  char *v5; // eax
  int overflow; // [esp+14h] [ebp-14h]
  int edited; // [esp+18h] [ebp-10h]
  signed int length; // [esp+20h] [ebp-8h]

  length = strlen(edit->buffer);
  edited = 0;
  overflow = 0;
  if ( edit->maxlen - (len + length) < 0 )
  {
    overflow = 1;
    len = 0;
    if ( edit->maxlen <= length )
      goto finish;
    len = edit->maxlen - length;
  }
  edit->buffer[length + len] = 0;
  while ( edit->pos <= length )
  {
    edit->buffer[length + len] = edit->buffer[length];
    --length;
  }
  strncpy(&edit->buffer[edit->pos], (const char *)s, len);
  edited = 1;
finish:
  edit->pos += len;
  edit->strlen += len;
  if ( edited )
    edit->dirty = 1;
  if ( overflow && maxMessage )
  {
    mustshow[0] = 1;
    v5 = gettext("Maximum length reached!  Delete text or move off field.");
    statusline(v5);
  }
  if ( edit->mark <= edit->pos )
  {
    if ( edit->mark < ~edit->pos )
      edit->mark -= len;
  }
  else
  {
    edit->mark += len;
  }
  if ( edit->mark >= 0 )
    edit->mark = ~edit->mark;
  return edited;
}

//----- (080516E9) --------------------------------------------------------
int __cdecl LYEdit1(EditFieldData *edit, int ch_0, int action, BOOLEAN maxMessage)
{
  char *v4; // eax
  int pos; // ebx
  int v6; // ebx
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  int v10; // ecx
  int v11; // ecx
  char *v12; // eax
  int v14; // [esp+18h] [ebp-30h]
  int n; // [esp+1Ch] [ebp-2Ch]
  int yanklen; // [esp+2Ch] [ebp-1Ch]
  int reglen; // [esp+30h] [ebp-18h]
  int offsetb; // [esp+34h] [ebp-14h]
  int offset; // [esp+34h] [ebp-14h]
  int offsetc; // [esp+34h] [ebp-14h]
  int offseta; // [esp+34h] [ebp-14h]
  signed int length; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int ia; // [esp+3Ch] [ebp-Ch]
  int ib; // [esp+3Ch] [ebp-Ch]
  int ic; // [esp+3Ch] [ebp-Ch]
  char ih; // [esp+3Ch] [ebp-Ch]
  int ii; // [esp+3Ch] [ebp-Ch]
  int id; // [esp+3Ch] [ebp-Ch]
  int ie; // [esp+3Ch] [ebp-Ch]
  int ig; // [esp+3Ch] [ebp-Ch]
  char uch[5]; // [esp+43h] [ebp-5h] BYREF
  int ch_0a; // [esp+54h] [ebp+Ch]

  if ( edit->maxlen <= 0 )
    return 0;
  length = strlen(edit->buffer);
  edit->strlen = length;
  switch ( action )
  {
    case 1:
      uch[0] = ch_0;
      LYEditInsert(edit, (const unsigned __int8 *)uch, 1, 0, maxMessage);
      return 0;
    case 7:
      if ( edit->pos >= length )
        goto LABEL_140;
      pos = edit->pos;
      edit->pos = pos + mbcs_skip(&edit->buffer[pos], 1);
      goto LABEL_71;
    case 9:
LABEL_71:
      if ( length && edit->pos )
      {
        v6 = edit->pos;
        v7 = mbcs_glyphs(edit->buffer, v6);
        offseta = v6 - mbcs_skip(edit->buffer, v7 - 1);
        edit->pos -= offseta;
        for ( ic = edit->pos; length - offseta + 1 > ic; ++ic )
          edit->buffer[ic] = edit->buffer[ic + offseta];
        if ( edit->mark >= 0 )
          edit->mark = ~edit->mark;
        if ( edit->mark <= ~edit->pos )
          edit->mark += offseta;
      }
      goto LABEL_140;
    case 10:
      offsetb = edit->pos;
      LYEdit1(edit, 0, 19, 0);
      offset = edit->pos - offsetb;
      edit->pos -= offset;
      goto shrink;
    case 11:
      offsetc = edit->pos;
      LYEdit1(edit, 0, 20, 0);
      offset = offsetc - edit->pos;
shrink:
      for ( ia = edit->pos; length - offset + 1 > ia; ++ia )
        edit->buffer[ia] = edit->buffer[ia + offset];
      if ( edit->mark >= 0 )
        edit->mark = ~edit->mark;
      if ( edit->mark <= ~edit->pos - offset )
        edit->mark += offset;
      if ( ~edit->pos - offset < edit->mark && edit->mark < ~edit->pos )
        edit->mark = ~edit->pos;
      goto LABEL_140;
    case 12:
      edit->buffer[0] = 0;
      edit->mark = -1;
      goto LABEL_42;
    case 13:
LABEL_42:
      edit->pos = 0;
      goto LABEL_140;
    case 14:
      edit->pos = length;
      goto LABEL_140;
    case 15:
    case 16:
      if ( edit->pos < length )
      {
        v8 = edit->pos;
        edit->pos = v8 + mbcs_skip(&edit->buffer[v8], 1);
        goto LABEL_140;
      }
      if ( action != 16 )
        goto LABEL_140;
      return -ch_0;
    case 17:
    case 18:
      if ( edit->pos > 0 )
      {
        v9 = mbcs_glyphs(edit->buffer, edit->pos);
        edit->pos = mbcs_skip(edit->buffer, v9 - 1);
        goto LABEL_140;
      }
      if ( action != 18 )
        goto LABEL_140;
      return -ch_0;
    case 19:
      while ( ((*__ctype_b_loc())[(unsigned __int8)edit->buffer[edit->pos]] & 8) != 0 || edit->buffer[edit->pos] < 0 )
        ++edit->pos;
      while ( ((*__ctype_b_loc())[(unsigned __int8)edit->buffer[edit->pos]] & 8) == 0
           && edit->buffer[edit->pos] >= 0
           && edit->buffer[edit->pos] )
        ++edit->pos;
      goto LABEL_140;
    case 20:
      while ( edit->pos
           && ((*__ctype_b_loc())[(unsigned __int8)edit->buffer[edit->pos - 1]] & 8) == 0
           && edit->buffer[edit->pos - 1] >= 0 )
        --edit->pos;
      while ( edit->pos
           && (((*__ctype_b_loc())[(unsigned __int8)edit->buffer[edit->pos - 1]] & 8) != 0
            || edit->buffer[edit->pos - 1] < 0) )
        --edit->pos;
      goto LABEL_140;
    case 21:
      LYLowerCase(edit->buffer);
      goto LABEL_140;
    case 22:
      LYUpperCase(edit->buffer);
      goto LABEL_140;
    case 25:
      for ( ib = edit->pos; length + 1 > ib; ++ib )
        edit->buffer[ib - edit->pos] = edit->buffer[ib];
      if ( edit->mark >= 0 )
        edit->mark = ~edit->mark;
      if ( edit->mark > ~edit->pos )
        edit->mark = -1;
      else
        edit->mark += edit->pos;
      edit->pos = 0;
      goto LABEL_140;
    case 26:
      edit->buffer[edit->pos] = 0;
      if ( edit->mark >= 0 )
        edit->mark = ~edit->mark;
      if ( edit->mark <= ~edit->pos )
        edit->mark = -1;
      goto LABEL_140;
    case 28:
      if ( LYCharSet_UC[current_char_set].enc == 7 || HTCJK )
        goto LABEL_140;
      if ( length <= 1 || !edit->pos )
        return ch_0;
      if ( edit->pos == length )
        --edit->pos;
      if ( edit->mark < 0 )
        edit->mark = ~edit->mark;
      if ( edit->mark == edit->pos || edit->mark == edit->pos + 1 )
        edit->mark = edit->pos - 1;
      if ( edit->mark >= 0 )
        edit->mark = ~edit->mark;
      if ( edit->buffer[edit->pos - 1] == edit->buffer[edit->pos] )
      {
        ++edit->pos;
      }
      else
      {
        ih = edit->buffer[edit->pos - 1];
        edit->buffer[edit->pos - 1] = edit->buffer[edit->pos];
        v10 = edit->pos;
        edit->buffer[v10] = ih;
        edit->pos = v10 + 1;
      }
      goto LABEL_140;
    case 32:
      ch_0 = (unsigned __int8)ch_0;
      if ( (unsigned __int8)ch_0 + 64 >= LYlowest_eightbit[current_char_set] )
        ch_0a = (unsigned __int8)ch_0a + 64;
      if ( edit->pos <= edit->maxlen && edit->strlen < edit->maxlen )
      {
        if ( edit->mark <= edit->pos )
        {
          if ( edit->mark < ~edit->pos )
            --edit->mark;
        }
        else
        {
          ++edit->mark;
        }
        if ( edit->mark >= 0 )
          edit->mark = ~edit->mark;
        for ( i = length; edit->pos <= i; --i )
          edit->buffer[i + 1] = edit->buffer[i];
        edit->buffer[length + 1] = 0;
        edit->buffer[edit->pos++] = ch_0a;
        goto LABEL_140;
      }
      if ( maxMessage )
      {
        mustshow[0] = 1;
        v4 = gettext("Maximum length reached!  Delete text or move off field.");
        statusline(v4);
      }
      return ch_0a;
    case 33:
      edit->mark = edit->pos;
      return 0;
    case 34:
      if ( edit->mark < 0 )
        edit->mark = ~edit->mark;
      if ( edit->mark == edit->pos )
        return 0;
      ii = edit->pos;
      edit->pos = edit->mark;
      edit->mark = ii;
      goto LABEL_140;
    case 35:
      if ( edit->mark < 0 )
        edit->mark = ~edit->mark;
      if ( edit->mark == edit->pos )
      {
        killbuffer[0] = 0;
        return 0;
      }
      if ( edit->mark > edit->pos )
        LYEdit1(edit, 0, 34, 0);
      reglen = edit->pos - edit->mark;
      n = reglen;
      if ( reglen > 1023 )
        n = 1023;
      LYstrncpy(killbuffer, &edit->buffer[edit->mark], n);
      for ( id = edit->mark; edit->buffer[id + reglen]; ++id )
        edit->buffer[id] = edit->buffer[id + reglen];
      edit->buffer[id] = edit->buffer[id + reglen];
      edit->pos = edit->mark;
      if ( edit->mark >= 0 )
        edit->mark = ~edit->mark;
      goto LABEL_140;
    case 36:
      if ( killbuffer[0] )
      {
        yanklen = strlen(killbuffer);
        if ( yanklen + edit->pos > edit->maxlen || yanklen + edit->strlen > edit->maxlen )
        {
          if ( maxMessage )
          {
            mustshow[0] = 1;
            v12 = gettext("Maximum length reached!  Delete text or move off field.");
            statusline(v12);
          }
        }
        else
        {
          edit->mark = ~edit->pos;
          for ( ie = length; edit->pos <= ie; --ie )
            edit->buffer[ie + yanklen] = edit->buffer[ie];
          for ( ig = 0; ig < yanklen; ++ig )
          {
            v11 = edit->pos;
            edit->buffer[v11] = killbuffer[ig];
            edit->pos = v11 + 1;
          }
        }
LABEL_140:
        edit->dirty = 1;
        edit->strlen = strlen(edit->buffer);
        v14 = 0;
      }
      else
      {
        edit->mark = ~edit->pos;
        v14 = 0;
      }
      break;
    default:
      return ch_0;
  }
  return v14;
}
// 80516E9: using guessed type unsigned __int8 uch[5];

//----- (080522A6) --------------------------------------------------------
int __cdecl get_popup_number(const char *msg, int *c, int *rel)
{
  char *v3; // eax
  int v6; // [esp+18h] [ebp-A0h]
  int num; // [esp+34h] [ebp-84h]
  char *p; // [esp+38h] [ebp-80h]
  char temp[120]; // [esp+3Ch] [ebp-7Ch] BYREF
  unsigned int v10; // [esp+B4h] [ebp-4h]

  v10 = __readgsdword(0x14u);
  p = temp;
  temp[0] = *c;
  temp[1] = 0;
  mustshow[0] = 1;
  statusline(msg);
  if ( LYgetstr(temp, 0, 0x78u, NORECALL) >= 0 && temp[0] )
  {
    *rel = 0;
    num = atoi(temp);
    while ( ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x800) != 0 )
      ++p;
    v6 = *p;
    if ( v6 == 43 || v6 == 45 )
    {
      *rel = *p++;
      *c = *p;
    }
    else if ( *p )
    {
      *c = *p++;
      *rel = *p;
    }
    if ( *p == 103 || *p == 71 )
    {
      *c = 103;
    }
    else if ( *p == 112 || *p == 80 )
    {
      *c = 112;
    }
    else
    {
      *c = 0;
    }
    if ( *rel != 43 && *rel != 45 )
      *rel = 0;
    return num;
  }
  else
  {
    v3 = gettext("Cancelled!!!");
    HTInfoMsg(v3);
    *c = 0;
    *rel = 0;
    return 0;
  }
}

//----- (080524C5) --------------------------------------------------------
void __cdecl remember_column(EditFieldData *edit, int offset)
{
  int curx; // [esp+4h] [ebp-14h]

  if ( LYwin )
    curx = LYwin->_curx;
  else
    curx = -1;
  edit->offset2col[offset] = curx;
}

//----- (08052529) --------------------------------------------------------
void __cdecl fill_edited_line(int prompting, int length, int ch_0)
{
  int style; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int i; // [esp+24h] [ebp-4h]

  if ( prompting )
    style = s_prompt_edit_pad;
  else
    style = s_aedit_pad;
  curses_style(style, 1);
  for ( i = 0; i < length; ++i )
    waddch(LYwin, (unsigned __int8)ch_0);
  if ( prompting )
    v4 = s_prompt_edit_pad;
  else
    v4 = s_aedit_pad;
  curses_style(v4, 0);
}

//----- (080525B4) --------------------------------------------------------
void __cdecl LYRefreshEdit(EditFieldData *edit)
{
  FILE *v1; // eax
  FILE *v2; // edx
  int v3; // [esp+4h] [ebp-A4h]
  const char *v4; // [esp+18h] [ebp-90h]
  int v5; // [esp+2Ch] [ebp-7Ch]
  int col; // [esp+3Ch] [ebp-6Ch]
  const char *next; // [esp+44h] [ebp-64h]
  const char *last; // [esp+48h] [ebp-60h]
  int cell; // [esp+4Ch] [ebp-5Ch]
  int old_cells; // [esp+50h] [ebp-58h]
  int prompting; // [esp+54h] [ebp-54h]
  int estyle; // [esp+58h] [ebp-50h]
  int rgt_shift; // [esp+5Ch] [ebp-4Ch]
  int lft_shift; // [esp+60h] [ebp-48h]
  char *str; // [esp+64h] [ebp-44h]
  int i; // [esp+6Ch] [ebp-3Ch]
  int ia; // [esp+6Ch] [ebp-3Ch]
  int lft_chars; // [esp+74h] [ebp-34h]
  int lft_charsa; // [esp+74h] [ebp-34h]
  int pos_cells; // [esp+80h] [ebp-28h]
  int lft_cells; // [esp+84h] [ebp-24h]
  int dpy_cells; // [esp+88h] [ebp-20h]
  int all_cells; // [esp+8Ch] [ebp-1Ch]
  int lft_bytes; // [esp+90h] [ebp-18h]
  int dpy_bytes; // [esp+94h] [ebp-14h]
  size_t all_bytes; // [esp+9Ch] [ebp-Ch]
  bool utf_flag; // [esp+A3h] [ebp-5h]

  lft_shift = 0;
  rgt_shift = 0;
  prompting = 0;
  if ( !edit->dirty || !edit->dspwdth )
    return;
  edit->dirty = 0;
  all_bytes = strlen(edit->buffer);
  edit->strlen = all_bytes;
  all_cells = LYstrCells(edit->buffer);
  pos_cells = LYstrExtent2(edit->buffer, edit->pos);
  mbcs_glyphs(edit->buffer, edit->xpan);
  mbcs_glyphs(edit->buffer, edit->pos);
  mbcs_glyphs(edit->buffer, all_bytes);
  lft_bytes = edit->xpan;
  lft_cells = LYstrExtent2(edit->buffer, lft_bytes);
  if ( lft_cells + edit->dspwdth <= all_cells && lft_cells + edit->dspwdth - edit->margin <= pos_cells )
  {
    lft_cells = pos_cells - edit->dspwdth + edit->margin;
    lft_chars = cell2char(edit->buffer, lft_cells);
    lft_bytes = mbcs_skip(edit->buffer, lft_chars);
  }
  if ( lft_cells + edit->margin > pos_cells )
  {
    lft_cells = pos_cells - edit->margin;
    if ( lft_cells < 0 )
      lft_cells = 0;
    lft_charsa = cell2char(edit->buffer, lft_cells);
    lft_bytes = mbcs_skip(edit->buffer, lft_charsa);
  }
  LYmove(edit->sy, edit->sx);
  if ( edit->panon && lft_cells )
  {
    curses_style(s_aedit_arr, 1);
    LYmove(edit->sy, edit->sx);
    waddch(LYwin, dword_81AABD0);
    curses_style(s_aedit_arr, 0);
    lft_shift = 1;
  }
  str = &edit->buffer[lft_bytes];
  edit->xpan = lft_bytes;
  dpy_cells = all_cells - lft_cells;
  if ( edit->dspwdth - lft_shift < all_cells - lft_cells )
  {
    rgt_shift = 1;
    dpy_cells = edit->dspwdth - lft_shift - 1;
  }
  do
  {
    v3 = cell2char(str, dpy_cells);
    dpy_bytes = mbcs_skip(str, v3);
    if ( !rgt_shift )
      break;
    old_cells = dpy_cells;
    dpy_cells = LYstrExtent2(str, dpy_bytes);
    if ( dpy_cells > old_cells )
      dpy_cells = old_cells - 1;
  }
  while ( dpy_cells < old_cells );
  if ( edit->sy == LYlines - 1 )
    prompting = 1;
  if ( prompting )
    estyle = s_prompt_edit;
  else
    estyle = s_aedit;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    if ( prompting )
      v4 = "prompt";
    else
      v4 = "active";
    v1 = TraceFP();
    fprintf(v1, "STYLE.getstr: switching to <edit.%s>.\n", v4);
  }
  if ( estyle == -1 )
    LYwin->_attrs = 0;
  else
    curses_style(estyle, 1);
  if ( edit->hidden )
  {
    utf_flag = LYCharSet_UC[current_char_set].enc == 7;
    cell = 0;
    fill_edited_line(0, dpy_cells, 42);
    i = 0;
    do
    {
      last = &str[i];
      next = LYmbcs_skip_glyphs(&str[i], 1, utf_flag);
      while ( i < next - str )
        edit->offset2col[i++] = cell + edit->sx;
      cell += LYstrExtent2(last, next - last);
    }
    while ( i < dpy_bytes );
    edit->offset2col[i] = cell + edit->sx;
    goto LABEL_86;
  }
  if ( edit->mark >= 0 && edit->xpan > edit->mark )
  {
    if ( prompting )
      curses_style(s_prompt_sel, 1);
    else
      curses_style(s_aedit_sel, 1);
  }
  remember_column(edit, 0);
  for ( ia = 0; ia < dpy_bytes; ++ia )
  {
    if ( edit->mark >= 0
      && (ia + edit->xpan == edit->mark && edit->pos > edit->mark
       || ia + edit->xpan == edit->pos && edit->pos < edit->mark) )
    {
      if ( prompting )
        curses_style(s_prompt_sel, 1);
      else
        curses_style(s_aedit_sel, 1);
    }
    if ( edit->mark >= 0
      && (ia + edit->xpan == edit->mark && edit->pos < edit->mark
       || ia + edit->xpan == edit->pos && edit->pos > edit->mark) )
    {
      if ( prompting )
        curses_style(s_prompt_sel, 0);
      else
        curses_style(s_aedit_sel, 0);
    }
    if ( str[ia] == 1
      || str[ia] == 2
      || str[ia] == -96
      && !HTPassHighCtrlRaw
      && HTCJK == NOCJK
      && (LYCharSet_UC[current_char_set].enc == 2 || (LYCharSet_UC[current_char_set].like8859 & 0x80) != 0) )
    {
      goto LABEL_74;
    }
    if ( str[ia] == 9 )
    {
      col = edit->offset2col[ia] - edit->sx;
      while ( (++col & 7) != 0 )
        waddch(LYwin, 0x20u);
LABEL_74:
      waddch(LYwin, 0x20u);
      goto LABEL_76;
    }
    waddch(LYwin, (unsigned __int8)str[ia]);
LABEL_76:
    remember_column(edit, ia + 1);
  }
  if ( edit->mark >= 0
    && (dpy_bytes + edit->xpan <= edit->mark && dpy_bytes + edit->xpan > edit->pos
     || dpy_bytes + edit->xpan > edit->mark && dpy_bytes + edit->xpan <= edit->pos) )
  {
    if ( prompting )
      curses_style(s_prompt_sel, 0);
    else
      curses_style(s_aedit_sel, 0);
  }
LABEL_86:
  fill_edited_line(prompting, edit->dspwdth + edit->sx - edit->offset2col[dpy_bytes], edit->pad);
  if ( edit->panon && dpy_bytes && rgt_shift )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "Draw right-scroller offset (%d + %d)\n", dpy_cells, lft_shift);
    }
    if ( prompting )
      v5 = s_prompt_edit_arr;
    else
      v5 = s_aedit_arr;
    curses_style(v5, 1);
    LYmove(edit->sy, lft_shift + dpy_cells + edit->sx);
    waddch(LYwin, dword_81AABCC);
    if ( prompting )
      curses_style(s_prompt_edit_arr, 0);
    else
      curses_style(s_aedit_arr, 0);
  }
  LYmove(edit->sy, edit->offset2col[edit->pos - edit->xpan]);
  if ( estyle != -1 )
    curses_style(estyle, 0);
  LYrefresh();
}
// 80527BA: conditional instruction was optimized away because %prompting.4==0
// 805281D: conditional instruction was optimized away because %prompting.4==0

//----- (08052F5D) --------------------------------------------------------
void __cdecl reinsertEdit(EditFieldData *edit, char *result)
{
  int v2; // edx

  if ( result )
  {
    LYEdit1(edit, 0, 12, 0);
    while ( *result )
    {
      v2 = EditBinding(*result);
      LOBYTE(v2) = v2 & 0x7F;
      LYEdit1(edit, *result++, v2, 0);
    }
  }
}

//----- (08052FD8) --------------------------------------------------------
int __cdecl caselessCmpList(const void *a, const void *b)
{
  return strcasecomp(*(const char **)a, *(const char **)b);
}

//----- (08052FF6) --------------------------------------------------------
int __cdecl normalCmpList(const void *a, const void *b)
{
  return strcmp(*(const char **)a, *(const char **)b);
}

//----- (08053014) --------------------------------------------------------
char **__cdecl sortedList(HTList *list, BOOLEAN ignorecase)
{
  char *object; // [esp+1Ch] [ebp-2Ch]
  int (*compar)(const void *, const void *); // [esp+20h] [ebp-28h]
  char **result; // [esp+34h] [ebp-14h]
  unsigned int jk; // [esp+38h] [ebp-10h]
  unsigned int k; // [esp+3Ch] [ebp-Ch]
  unsigned int ka; // [esp+3Ch] [ebp-Ch]
  unsigned int j; // [esp+40h] [ebp-8h]
  unsigned int ja; // [esp+40h] [ebp-8h]
  unsigned int count; // [esp+44h] [ebp-4h]

  count = HTList_count(list);
  j = 0;
  result = (char **)calloc(count + 1, 4u);
  if ( !result )
    outofmem("./LYStrings.c", "sortedList");
  while ( list && list->next )
  {
    list = list->next;
    if ( list )
      object = (char *)list->object;
    else
      object = 0;
    result[j++] = object;
  }
  if ( count > 1 )
  {
    if ( ignorecase )
      compar = caselessCmpList;
    else
      compar = normalCmpList;
    qsort(result, count, 4u, compar);
    for ( ja = 0; result[ja]; ++ja )
    {
      for ( k = ja; result[k] && !strcmp(result[ja], result[k]); ++k )
        ;
      ka = k - 1;
      if ( ja != ka )
      {
        for ( jk = ja; ; ++jk )
        {
          result[jk] = result[ka + jk - ja];
          if ( !result[jk] )
            break;
        }
      }
    }
  }
  return result;
}
// 805307C: conditional instruction was optimized away because %list.4!=0

//----- (080531AB) --------------------------------------------------------
int __cdecl LYarrayLength(const char **list)
{
  int result; // [esp+Ch] [ebp-4h]

  for ( result = 0; *list++ != 0; ++result )
    ;
  return result;
}

//----- (080531D5) --------------------------------------------------------
int __cdecl LYarrayWidth(const char **list)
{
  const char *v1; // eax
  int check; // [esp+10h] [ebp-8h]
  int result; // [esp+14h] [ebp-4h]

  result = 0;
  while ( *list )
  {
    v1 = *list++;
    check = strlen(v1);
    if ( check > result )
      result = check;
  }
  return result;
}

//----- (08053214) --------------------------------------------------------
void __cdecl FormatChoiceNum(char *dst, int num_choices, int choice, const char *value)
{
  int v4; // [esp+24h] [ebp-14h]

  if ( num_choices < 0 )
  {
    LYstrncpy(dst, value, 1023);
  }
  else
  {
    if ( num_choices <= 9 )
      v4 = 1;
    else
      v4 = 2;
    sprintf(dst, "%*d: %.*s", v4, choice + 1, 1015 - v4, value);
  }
}

//----- (08053293) --------------------------------------------------------
unsigned int __cdecl options_width(const char **list)
{
  int count; // [esp+10h] [ebp-8h]
  unsigned int width; // [esp+14h] [ebp-4h]

  width = 0;
  for ( count = 0; list[count]; ++count )
  {
    if ( strlen(list[count]) > width )
      width = strlen(list[count]);
  }
  return width;
}

//----- (080532EF) --------------------------------------------------------
void __cdecl draw_option(
        WINDOW *win,
        int entry,
        int width,
        BOOLEAN reversed,
        int num_choices,
        int number,
        const char *value)
{
  int style; // [esp+14h] [ebp-424h]
  int v8; // [esp+18h] [ebp-420h]
  char Cnum[1024]; // [esp+34h] [ebp-404h] BYREF
  unsigned int v10; // [esp+434h] [ebp-4h]

  v10 = __readgsdword(0x14u);
  FormatChoiceNum(Cnum, num_choices, number, &::value);
  wmove(win, entry, 1);
  curses_w_style(win, s_menu_entry, 1);
  waddch(win, 0x20u);
  curses_w_style(win, s_menu_entry, 0);
  curses_w_style(win, s_menu_number, 1);
  waddnstr(win, Cnum, -1);
  curses_w_style(win, s_menu_number, 0);
  if ( reversed )
    style = s_menu_active;
  else
    style = s_menu_entry;
  curses_w_style(win, style, 1);
  LYpaddstr(win, width, value);
  if ( reversed )
    v8 = s_menu_active;
  else
    v8 = s_menu_entry;
  curses_w_style(win, v8, 0);
  curses_w_style(win, s_menu_entry, 1);
  waddch(win, 0x20u);
  curses_w_style(win, s_menu_entry, 0);
}

//----- (08053519) --------------------------------------------------------
int __cdecl LYhandlePopupList(
        int cur_choice,
        int ly,
        int lx,
        const char **choices,
        int width,
        int i_length,
        int disabled,
        BOOLEAN for_mouse)
{
  char *v8; // eax
  FILE *v9; // eax
  int v10; // ebx
  int v11; // esi
  int v12; // edi
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  int v19; // ebx
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // eax
  char *v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *v27; // eax
  char *v28; // eax
  char *v29; // eax
  char *v30; // eax
  int v32; // [esp+30h] [ebp-508h]
  int v34; // [esp+38h] [ebp-500h]
  int v35; // [esp+3Ch] [ebp-4FCh]
  int v36; // [esp+40h] [ebp-4F8h]
  int v37; // [esp+44h] [ebp-4F4h]
  int v38; // [esp+48h] [ebp-4F0h]
  int v39; // [esp+4Ch] [ebp-4ECh]
  BOOLEAN for_mousea; // [esp+54h] [ebp-4E4h]
  const char **choicesa; // [esp+58h] [ebp-4E0h]
  char *msg; // [esp+68h] [ebp-4D0h] BYREF
  int curpage; // [esp+6Ch] [ebp-4CCh]
  int row; // [esp+70h] [ebp-4C8h]
  int limit; // [esp+74h] [ebp-4C4h]
  int check; // [esp+78h] [ebp-4C0h]
  int can_scroll_was; // [esp+7Ch] [ebp-4BCh]
  int can_scroll; // [esp+80h] [ebp-4B8h]
  const char **Cptr; // [esp+84h] [ebp-4B4h]
  const char *popup_status_msg; // [esp+88h] [ebp-4B0h]
  int number; // [esp+8Ch] [ebp-4ACh]
  int QueryNum; // [esp+90h] [ebp-4A8h]
  int QueryTotal; // [esp+94h] [ebp-4A4h]
  RecallType recall; // [esp+98h] [ebp-4A0h]
  int ch_0; // [esp+9Ch] [ebp-49Ch]
  char *cp; // [esp+A0h] [ebp-498h]
  int npages; // [esp+A4h] [ebp-494h]
  int Lnum; // [esp+A8h] [ebp-490h]
  int lines_to_show; // [esp+ACh] [ebp-48Ch]
  int window_offset; // [esp+B0h] [ebp-488h]
  int length; // [esp+B4h] [ebp-484h]
  int bottom; // [esp+B8h] [ebp-480h] BYREF
  int top; // [esp+BCh] [ebp-47Ch] BYREF
  int max_choices; // [esp+C0h] [ebp-478h]
  int num_choices; // [esp+C4h] [ebp-474h]
  WINDOW *form_window; // [esp+C8h] [ebp-470h]
  int orig_choice; // [esp+CCh] [ebp-46Ch]
  int rel; // [esp+D0h] [ebp-468h] BYREF
  int j; // [esp+D4h] [ebp-464h]
  int i; // [esp+D8h] [ebp-460h]
  int cmd; // [esp+DCh] [ebp-45Ch]
  int c; // [esp+E0h] [ebp-458h] BYREF
  BOOLEAN ReDraw; // [esp+E5h] [ebp-453h]
  BOOLEAN FirstRecall; // [esp+E6h] [ebp-452h]
  BOOLEAN numbered; // [esp+E7h] [ebp-451h]
  char buffer[1024]; // [esp+E8h] [ebp-450h] BYREF
  char Cnum[64]; // [esp+4E8h] [ebp-50h] BYREF
  unsigned int v79; // [esp+528h] [ebp-10h]

  choicesa = choices;
  for_mousea = for_mouse;
  v79 = __readgsdword(0x14u);
  numbered = keypad_mode != 0;
  c = 0;
  cmd = 0;
  i = 0;
  j = 0;
  rel = 0;
  num_choices = 0;
  max_choices = 0;
  length = -1;
  window_offset = 0;
  ch_0 = 0;
  FirstRecall = 1;
  ReDraw = 0;
  popup_status_msg = 0;
  Cptr = 0;
  can_scroll = 0;
  can_scroll_was = 0;
  orig_choice = cur_choice;
  if ( cur_choice < 0 )
    cur_choice = 0;
  if ( first_14673 )
  {
    prev_target_buffer_14672[0] = 0;
    first_14673 = 0;
  }
  prev_target_14671[0] = 0;
  if ( search_queries )
    v32 = HTList_count(search_queries);
  else
    v32 = 0;
  QueryTotal = v32;
  recall = v32 > 0;
  QueryNum = v32;
  num_choices = LYarrayLength(choicesa) - 1;
  if ( width <= 0 )
    width = options_width(choicesa);
  if ( numbered )
  {
    sprintf(Cnum, "%d: ", num_choices);
    Lnum = strlen(Cnum);
    max_choices = num_choices;
  }
  else
  {
    Lnum = 0;
    max_choices = -1;
  }
  top = ly + ~cur_choice;
  if ( top < 0 )
    top = 0;
  if ( i_length > 0 )
    --i_length;
  else
    i_length = num_choices;
  bottom = i_length + top + 3;
  if ( user_mode )
    lines_to_show = LYlines - 2;
  else
    lines_to_show = LYlines - 4;
  if ( for_mousea && !user_mode && lines_to_show > 2 )
    --lines_to_show;
  if ( bottom > lines_to_show )
  {
    if ( i_length + 3 <= lines_to_show )
    {
      top = lines_to_show + 1 + -3 - i_length;
      bottom = lines_to_show + 1;
    }
    else
    {
      top = 0;
      bottom = i_length + 3;
      if ( i_length + 3 > lines_to_show )
        bottom = lines_to_show + 1;
    }
  }
  length = bottom - top - 2;
  if ( length <= num_choices )
    can_scroll = 4;
  if ( ly + 2 > bottom )
  {
    bottom = ly + 2;
    if ( lines_to_show + 1 < ly + 2 )
      bottom = lines_to_show + 1;
    top = bottom - length - 2;
  }
  if ( for_mousea )
  {
    check = Lnum + width + 4;
    limit = LYcols;
    if ( check < LYcols )
    {
      if ( check + lx - 1 <= limit )
      {
        if ( lx <= 0 )
          lx = 1;
      }
      else
      {
        lx = limit + 1 - check;
      }
    }
  }
  width += Lnum;
  bottom -= top;
  if ( num_choices <= 0 )
    return orig_choice;
  if ( cur_choice > num_choices )
    return orig_choice;
  form_window = LYstartPopup(&top, &lx, &bottom, &width);
  if ( !form_window )
    return orig_choice;
  width -= Lnum;
  bottom += top;
  if ( disabled )
  {
    popup_status_msg = gettext("UNMODIFIABLE choice list.  Use return or arrow keys to review or leave.");
  }
  else if ( for_mousea )
  {
    popup_status_msg = gettext("Left mouse button or return to select, arrow keys to scroll.");
  }
  else
  {
    popup_status_msg = gettext("(Choice list) Hit return and use arrow keys and return to select option.");
  }
  mustshow[0] = 1;
  statusline(popup_status_msg);
  if ( cur_choice >= length )
    window_offset = cur_choice - length + 1;
  if ( num_choices + 1 <= length )
    v34 = 1;
  else
    v34 = (length + num_choices) / length;
  npages = v34;
redraw:
  for ( i = 0; i <= num_choices; ++i )
  {
    if ( i >= window_offset && i - window_offset < length )
      draw_option(form_window, i + 1 - window_offset, width, 0, max_choices, i, choicesa[i]);
  }
  LYbox(form_window, numbered == 0);
  Cptr = 0;
LABEL_300:
  while ( cmd != 39 )
  {
    row = i + 1 - window_offset;
    if ( can_scroll )
    {
      if ( window_offset )
        v35 = 2;
      else
        v35 = 0;
      can_scroll = v35 | (num_choices - window_offset >= length);
      if ( (can_scroll_was & ~can_scroll) != 0 )
      {
        LYbox(form_window, numbered == 0);
        can_scroll_was = 0;
      }
      if ( ((unsigned __int8)can_scroll & (unsigned __int8)~(_BYTE)can_scroll_was & 2) != 0 )
      {
        wmove(form_window, 1, Lnum + width + 3);
        curses_w_style(form_window, s_menu_sb, 1);
        waddch(form_window, dword_81AABD4);
        curses_w_style(form_window, s_menu_sb, 0);
      }
      if ( ((unsigned __int8)can_scroll & (unsigned __int8)~(_BYTE)can_scroll_was & 1) != 0 )
      {
        wmove(form_window, length, Lnum + width + 3);
        curses_w_style(form_window, s_menu_sb, 1);
        waddch(form_window, dword_81AABD8);
        curses_w_style(form_window, s_menu_sb, 0);
      }
    }
    if ( Cptr )
      draw_option(form_window, row, width, 0, max_choices, i, Cptr[i]);
    Cptr = choicesa;
    i = cur_choice;
    row = cur_choice + 1 - window_offset;
    draw_option(form_window, row, width, 1, max_choices, cur_choice, choicesa[cur_choice]);
    LYstowCursor(form_window, row, 1);
    c = LYgetch_choice();
    if ( !term_options[0] && c != 3 && c != 7 )
    {
      if ( c == -1 )
      {
        if ( keymap[0] != 47 )
          goto LABEL_87;
      }
      else if ( (c & 0x8800) != 0 )
      {
        if ( (unsigned __int8)c != 47 )
          goto LABEL_87;
      }
      else if ( keymap[(c & 0x7FF) + 1] != 47 )
      {
LABEL_87:
        if ( c == 285 )
        {
          cmd = fancy_mouse(form_window, row, &cur_choice);
          if ( cmd < 0 )
            goto redraw;
          if ( cmd == 39 )
            break;
        }
        else
        {
          if ( c == -1 )
          {
            v36 = keymap[0];
          }
          else
          {
            if ( (c & 0x8800) != 0 )
              v37 = (unsigned __int8)c;
            else
              v37 = keymap[(c & 0x7FF) + 1];
            v36 = v37;
          }
          cmd = v36;
        }
        goto LABEL_98;
      }
    }
    cmd = 13;
LABEL_98:
    switch ( cmd )
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        goto LABEL_100;
      case 13:
      case 14:
      case 37:
      case 47:
        cur_choice = orig_choice;
        cmd = 39;
        goto LABEL_300;
      case 15:
        if ( num_choices - length + 1 != window_offset )
        {
          cur_choice -= window_offset;
          window_offset += length;
          if ( num_choices - length < window_offset )
            window_offset = num_choices - length + 1;
          cur_choice += window_offset;
          goto redraw;
        }
        if ( cur_choice < num_choices )
          cur_choice = num_choices;
        goto LABEL_300;
      case 16:
        if ( window_offset )
        {
          cur_choice -= window_offset;
          window_offset -= length;
          if ( window_offset < 0 )
            window_offset = 0;
          cur_choice += window_offset;
          goto redraw;
        }
        if ( cur_choice > 0 )
          cur_choice = 0;
        goto LABEL_300;
      case 17:
        cur_choice -= 2;
        if ( cur_choice < 0 )
          cur_choice = 0;
        if ( cur_choice - window_offset >= 0 )
          goto LABEL_300;
        window_offset -= 2;
        if ( window_offset < 0 )
          window_offset = 0;
        goto redraw;
      case 18:
        cur_choice += 2;
        if ( cur_choice > num_choices )
          cur_choice = num_choices;
        if ( cur_choice - window_offset < length )
          goto LABEL_300;
        window_offset += 2;
        if ( num_choices - length + 1 < window_offset )
          window_offset = num_choices - length + 1;
        goto redraw;
      case 19:
        cur_choice -= length / 2;
        if ( cur_choice < 0 )
          cur_choice = 0;
        if ( cur_choice - window_offset >= 0 )
          goto LABEL_300;
        window_offset -= length / 2;
        if ( window_offset < 0 )
          window_offset = 0;
        goto redraw;
      case 20:
        cur_choice += length / 2;
        if ( cur_choice > num_choices )
          cur_choice = num_choices;
        if ( cur_choice - window_offset < length )
          goto LABEL_300;
        window_offset += length / 2;
        if ( num_choices - length + 1 < window_offset )
          window_offset = num_choices - length + 1;
        goto redraw;
      case 21:
        lynx_force_repaint();
        LYrefresh();
        goto LABEL_300;
      case 22:
        cur_choice = 0;
        if ( window_offset <= 0 )
          goto LABEL_300;
        window_offset = 0;
        goto redraw;
      case 23:
        cur_choice = num_choices;
        if ( num_choices - length + 1 == window_offset )
          goto LABEL_300;
        window_offset = num_choices - length + 1;
        goto redraw;
      case 26:
      case 28:
      case 30:
      case 32:
        if ( cur_choice > 0 )
          --cur_choice;
        if ( cur_choice - window_offset >= 0 )
          goto LABEL_300;
        --window_offset;
        goto redraw;
      case 27:
      case 29:
      case 31:
      case 33:
        if ( cur_choice < num_choices )
          ++cur_choice;
        if ( cur_choice - window_offset < length )
          goto LABEL_300;
        ++window_offset;
        goto redraw;
      case 51:
        goto LABEL_209;
      case 53:
        if ( recall )
        {
          if ( !prev_target_buffer_14672[0] )
          {
            cp = (char *)HTList_objectAt(search_queries, 0);
            if ( cp )
            {
              LYstrncpy(prev_target_buffer_14672, cp, 1023);
              QueryNum = 0;
              FirstRecall = 0;
            }
          }
        }
        strcpy(prev_target_14671, prev_target_buffer_14672);
LABEL_209:
        if ( !prev_target_14671[0] )
        {
          mustshow[0] = 1;
          v22 = gettext("Enter a whereis query: ");
          statusline(v22);
          ch_0 = LYgetstr(prev_target_14671, 0, 0x400u, recall);
          if ( ch_0 < 0 )
            goto LABEL_267;
        }
        while ( 2 )
        {
          if ( !prev_target_14671[0] && (recall == NORECALL || ch_0 != 256 && ch_0 != 257) )
          {
LABEL_267:
            v29 = gettext("Cancelled!!!");
            HTInfoMsg(v29);
            goto restore_popup_statusline;
          }
          if ( recall && ch_0 == 256 )
          {
            if ( FirstRecall )
            {
              FirstRecall = 0;
              if ( prev_target_buffer_14672[0] )
              {
                for ( QueryNum = QueryTotal - 1; QueryNum > 0; --QueryNum )
                {
                  cp = (char *)HTList_objectAt(search_queries, QueryNum);
                  if ( cp )
                  {
                    if ( !strcmp(prev_target_buffer_14672, cp) )
                      break;
                  }
                }
              }
              else
              {
                QueryNum = 0;
              }
            }
            else
            {
              ++QueryNum;
            }
            if ( QueryNum >= QueryTotal )
              QueryNum = 0;
            cp = (char *)HTList_objectAt(search_queries, QueryNum);
            if ( cp )
            {
              LYstrncpy(prev_target_14671, cp, 1023);
              if ( prev_target_buffer_14672[0] && !strcmp(prev_target_buffer_14672, prev_target_14671) )
              {
                mustshow[0] = 1;
                v23 = gettext("Edit the current query: ");
                statusline(v23);
              }
              else if ( prev_target_buffer_14672[0] && QueryTotal == 2
                     || !prev_target_buffer_14672[0] && QueryTotal == 1 )
              {
                mustshow[0] = 1;
                v24 = gettext("Edit the previous query: ");
                statusline(v24);
              }
              else
              {
                mustshow[0] = 1;
                v25 = gettext("Edit a previous query: ");
                statusline(v25);
              }
              ch_0 = LYgetstr(prev_target_14671, 0, 0x400u, recall);
              if ( ch_0 < 0 )
                goto LABEL_267;
              continue;
            }
          }
          else if ( recall && ch_0 == 257 )
          {
            if ( FirstRecall )
            {
              FirstRecall = 0;
              if ( prev_target_buffer_14672[0] )
              {
                for ( QueryNum = 0; QueryTotal - 1 > QueryNum; ++QueryNum )
                {
                  cp = (char *)HTList_objectAt(search_queries, QueryNum);
                  if ( cp )
                  {
                    if ( !strcmp(prev_target_buffer_14672, cp) )
                      break;
                  }
                }
              }
              else
              {
                QueryNum = QueryTotal - 1;
              }
            }
            else
            {
              --QueryNum;
            }
            if ( QueryNum < 0 )
              QueryNum = QueryTotal - 1;
            cp = (char *)HTList_objectAt(search_queries, QueryNum);
            if ( cp )
            {
              LYstrncpy(prev_target_14671, cp, 1023);
              if ( prev_target_buffer_14672[0] && !strcmp(prev_target_buffer_14672, prev_target_14671) )
              {
                mustshow[0] = 1;
                v26 = gettext("Edit the current query: ");
                statusline(v26);
              }
              else if ( prev_target_buffer_14672[0] && QueryTotal == 2
                     || !prev_target_buffer_14672[0] && QueryTotal == 1 )
              {
                mustshow[0] = 1;
                v27 = gettext("Edit the previous query: ");
                statusline(v27);
              }
              else
              {
                mustshow[0] = 1;
                v28 = gettext("Edit a previous query: ");
                statusline(v28);
              }
              ch_0 = LYgetstr(prev_target_14671, 0, 0x400u, recall);
              if ( ch_0 < 0 )
                goto LABEL_267;
              continue;
            }
          }
          break;
        }
        strcpy(prev_target_buffer_14672, prev_target_14671);
        HTAddSearchQuery(prev_target_buffer_14672);
        for ( j = 1; (&Cptr[j])[i]; ++j )
        {
          FormatChoiceNum(buffer, max_choices, j + i, (&Cptr[j])[i]);
          if ( case_sensitive )
          {
            if ( strstr(buffer, prev_target_buffer_14672) )
              break;
          }
          else if ( LYstrstr(buffer, prev_target_buffer_14672) )
          {
            break;
          }
        }
        if ( (&Cptr[j])[i] )
        {
          cur_choice += j;
          if ( cur_choice - window_offset >= length )
          {
            window_offset += j;
            if ( num_choices - length + 1 < window_offset )
              window_offset = num_choices - length + 1;
            ReDraw = 1;
          }
        }
        else
        {
          if ( !cur_choice )
            goto LABEL_293;
          for ( j = 0; j < cur_choice; ++j )
          {
            FormatChoiceNum(buffer, max_choices, j + 1, Cptr[j]);
            if ( case_sensitive )
            {
              if ( strstr(buffer, prev_target_buffer_14672) )
                break;
            }
            else if ( LYstrstr(buffer, prev_target_buffer_14672) )
            {
              break;
            }
          }
          if ( j < cur_choice )
          {
            j = cur_choice - j;
            cur_choice -= j;
            if ( cur_choice - window_offset < 0 )
            {
              window_offset -= j;
              if ( window_offset < 0 )
                window_offset = 0;
              ReDraw = 1;
            }
          }
          else
          {
LABEL_293:
            v30 = gettext("'%s' not found!");
            HTUserMsg2(v30, prev_target_buffer_14672);
          }
        }
restore_popup_statusline:
        mustshow[0] = 1;
        statusline(popup_status_msg);
        prev_target_14671[0] = 0;
        if ( search_queries )
          v39 = HTList_count(search_queries);
        else
          v39 = 0;
        QueryTotal = v39;
        recall = v39 > 0;
        QueryNum = v39;
        if ( ReDraw != 1 )
          goto LABEL_300;
        ReDraw = 0;
        goto redraw;
      case 80:
        c = 0;
LABEL_100:
        v8 = gettext("Select option (or page) number: ");
        number = get_popup_number(v8, &c, &rel);
        if ( WWW_TraceFlag[0] )
        {
          v9 = TraceFP();
          fprintf(v9, "got popup option number %d, ", number);
        }
        if ( WWW_TraceFlag[0] )
        {
          v10 = cur_choice;
          v11 = c;
          v12 = rel;
          v13 = TraceFP();
          fprintf(v13, "rel='%c', c='%c', cur_choice=%d\n", v12, v11, v10);
        }
        if ( c == 112 )
        {
          if ( cur_choice + 1 <= length )
            v38 = 1;
          else
            v38 = (length + cur_choice) / length;
          curpage = v38;
          if ( WWW_TraceFlag[0] )
          {
            v14 = TraceFP();
            fprintf(v14, "  curpage=%d\n", curpage);
          }
          if ( rel == 43 )
          {
            number += curpage;
          }
          else if ( rel == 45 )
          {
            number = curpage - number;
          }
        }
        else if ( rel == 43 )
        {
          number += cur_choice + 1;
        }
        else if ( rel == 45 )
        {
          number = cur_choice - number + 1;
        }
        if ( rel && WWW_TraceFlag[0] )
        {
          v15 = TraceFP();
          fprintf(v15, "new number=%d\n", number);
        }
        if ( c == 112 )
        {
          if ( number > 1 )
          {
            if ( number >= npages )
            {
              if ( num_choices - length + 1 <= window_offset )
              {
                v17 = gettext("You are already at the end of this option list.");
                HTUserMsg(v17);
                mustshow[0] = 1;
                statusline(popup_status_msg);
                goto LABEL_300;
              }
              window_offset = length * (npages - 1);
              if ( num_choices - length < window_offset )
                window_offset = num_choices - length + 1;
              if ( cur_choice < window_offset )
                cur_choice = window_offset;
              goto LABEL_133;
            }
            if ( length * (number - 1) == window_offset )
            {
              msg = 0;
              v18 = gettext("You are already at page %d of this option list.");
              HTSprintf0(&msg, v18, number);
              HTUserMsg(msg);
              if ( msg )
              {
                free(msg);
                msg = 0;
              }
LABEL_137:
              mustshow[0] = 1;
              statusline(popup_status_msg);
              goto LABEL_300;
            }
            window_offset = length * (number - 1);
            cur_choice = window_offset;
            mustshow[0] = 1;
            statusline(popup_status_msg);
          }
          else
          {
            if ( !window_offset )
            {
              v16 = gettext("You are already at the beginning of this option list.");
              HTUserMsg(v16);
              mustshow[0] = 1;
              statusline(popup_status_msg);
              goto LABEL_300;
            }
            window_offset = 0;
            cur_choice = 0;
            mustshow[0] = 1;
            statusline(popup_status_msg);
          }
          goto redraw;
        }
        if ( number <= 0 )
          goto LABEL_137;
        if ( --number > num_choices || c )
        {
          if ( c == 103 )
          {
            if ( cur_choice == number )
            {
              msg = 0;
              v19 = number + 1;
              v20 = gettext("Option number %d already is current.");
              HTSprintf0(&msg, v20, v19);
              HTUserMsg(msg);
              if ( msg )
              {
                free(msg);
                msg = 0;
              }
            }
            else
            {
              if ( number <= num_choices )
              {
                j = number - cur_choice;
                cur_choice = number;
                if ( j <= 0 || cur_choice - window_offset < length )
                {
                  if ( cur_choice - window_offset < 0 )
                  {
                    window_offset -= abs32(j);
                    if ( window_offset < 0 )
                      window_offset = 0;
                  }
                }
                else
                {
                  window_offset += j;
                  if ( num_choices - length + 1 < window_offset )
                    window_offset = num_choices - length + 1;
                }
LABEL_133:
                mustshow[0] = 1;
                statusline(popup_status_msg);
                goto redraw;
              }
              v21 = gettext("You have entered an invalid option number.");
              HTUserMsg(v21);
            }
          }
          goto LABEL_137;
        }
        cur_choice = number;
        cmd = 39;
        break;
      default:
        goto LABEL_300;
    }
  }
  LYsubwindow(0);
  if ( disabled )
    return orig_choice;
  else
    return cur_choice;
}

//----- (080551A5) --------------------------------------------------------
int __cdecl LYgetstr(char *inputline, int hidden, size_t bufsize, RecallType recall)
{
  FILE *v4; // eax
  FILE *v5; // eax
  int current_modifiers; // eax
  int v7; // eax
  char *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  int v12; // eax
  int curx; // [esp+2Ch] [ebp-449Ch]
  int v15; // [esp+30h] [ebp-4498h]
  bool v17; // [esp+3Ah] [ebp-448Eh]
  bool v18; // [esp+3Bh] [ebp-448Dh]
  int cury; // [esp+3Ch] [ebp-448Ch]
  int v20; // [esp+40h] [ebp-4488h]
  unsigned __int8 *e1; // [esp+50h] [ebp-4478h]
  int len; // [esp+54h] [ebp-4474h]
  unsigned __int8 *e; // [esp+58h] [ebp-4470h]
  const char *s; // [esp+5Ch] [ebp-446Ch]
  int num_options; // [esp+60h] [ebp-4468h]
  int cur_choice; // [esp+64h] [ebp-4464h]
  int cur_choicea; // [esp+64h] [ebp-4464h]
  char **data; // [esp+70h] [ebp-4458h]
  HTList *list; // [esp+74h] [ebp-4454h]
  int last_xlkc; // [esp+78h] [ebp-4450h]
  int last_xlec; // [esp+7Ch] [ebp-444Ch]
  int xlec; // [esp+80h] [ebp-4448h]
  int ch_0; // [esp+84h] [ebp-4444h]
  int ch_0a; // [esp+84h] [ebp-4444h]
  bool refresh_mb; // [esp+97h] [ebp-4431h]
  EditFieldData MyEdit; // [esp+98h] [ebp-4430h] BYREF
  unsigned int v37; // [esp+44C4h] [ebp-4h]

  v37 = __readgsdword(0x14u);
  xlec = -2;
  last_xlkc = -1;
  refresh_mb = 1;
  if ( LYwin )
    curx = LYwin->_curx;
  else
    curx = -1;
  if ( bufsize > 0x3FF )
    v15 = 1023;
  else
    v15 = bufsize - 1;
  LYSetupEdit(&MyEdit, inputline, v15, LYcols - (LYShowScrollbar != 0) - curx);
  MyEdit.hidden = hidden;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "called LYgetstr\n");
  }
  while ( 1 )
  {
    do
    {
again:
      if ( refresh_mb )
        LYRefreshEdit(&MyEdit);
      ch_0 = LYReadCmdKey(3);
    }
    while ( !refresh_mb && EditBinding(ch_0) != 1 );
    if ( term_letter[0] || term_options[0] || term_message[0] )
      ch_0 = 7;
    if ( recall && (ch_0 == 256 || ch_0 == 257) )
      break;
    ch_0a = MyEdit.current_modifiers | ch_0;
    MyEdit.current_modifiers = 0;
    if ( last_xlkc != -1 )
    {
      if ( ch_0a == last_xlkc )
        ch_0a |= 0x1000u;
      last_xlkc = -1;
    }
    if ( ch_0a == -1 )
    {
      v17 = keymap[0] == 21;
    }
    else
    {
      if ( (ch_0a & 0x8800) != 0 )
        v18 = (unsigned __int8)ch_0a == 21;
      else
        v18 = keymap[(ch_0a & 0x7FF) + 1] == 21;
      v17 = v18;
    }
    if ( !v17 )
    {
      last_xlec = xlec;
      xlec = EditBinding(ch_0a);
      if ( (xlec & 0x80) == 0 || (xlec & 0x1000) != 0 )
      {
        last_xlkc = -1;
      }
      else
      {
        last_xlkc = ch_0a;
        xlec &= ~0x80u;
      }
      switch ( xlec )
      {
        case 2:
          LYstrncpy(inputline, MyEdit.buffer, bufsize);
          if ( !hidden )
            LYAddToCloset(recall, MyEdit.buffer);
          if ( WWW_TraceFlag[0] )
          {
            v9 = TraceFP();
            fprintf(v9, "LYgetstr(%s) LYE_ENTER\n", inputline);
          }
          return ch_0a;
        case 3:
          if ( xlec == last_xlec && recall )
          {
            list = whichRecall(recall);
            if ( list && list->next )
            {
              data = sortedList(list, recall == RECALL_CMD);
              cur_choice = 0;
              num_options = LYarrayLength((const char **)data);
              while ( cur_choice < num_options && strcasecomp(data[cur_choice], MyEdit.buffer) < 0 )
                ++cur_choice;
              if ( LYwin )
                cury = LYwin->_cury;
              else
                cury = -1;
              if ( LYwin )
                v20 = LYwin->_curx;
              else
                v20 = -1;
              cur_choicea = LYhandlePopupList(cur_choice, 0, v20, (const char **)data, -1, -1, 0, 0);
              if ( cur_choicea >= 0 )
              {
                if ( recall == RECALL_CMD )
                {
                  mustshow[0] = 1;
                  statusline(": ");
                }
                reinsertEdit(&MyEdit, data[cur_choicea]);
              }
              LYmove(cury, v20);
              if ( data )
                free(data);
            }
          }
          else
          {
            v8 = LYFindInCloset(recall, MyEdit.buffer);
            reinsertEdit(&MyEdit, v8);
          }
          goto again;
        case 4:
          if ( WWW_TraceFlag[0] )
          {
            v11 = TraceFP();
            fprintf(v11, "LYgetstr LYE_STOP\n");
          }
          textfields_need_activation = 1;
          return -1;
        case 5:
          *inputline = 0;
          if ( WWW_TraceFlag[0] )
          {
            v10 = TraceFP();
            fprintf(v10, "LYgetstr LYE_ABORT\n");
          }
          return -1;
        case 6:
        case 23:
          goto again;
        case 29:
          current_modifiers = MyEdit.current_modifiers;
          BYTE1(current_modifiers) = BYTE1(MyEdit.current_modifiers) | 0x40;
          MyEdit.current_modifiers = current_modifiers;
          goto again;
        case 30:
          v7 = MyEdit.current_modifiers;
          BYTE1(v7) = BYTE1(MyEdit.current_modifiers) | 0x20;
          MyEdit.current_modifiers = v7;
          goto again;
        case 37:
          s = get_clip_grab();
          if ( !s )
            goto again;
          len = strlen(s);
          e = (unsigned __int8 *)&s[len];
          if ( len <= 0 )
            goto LABEL_79;
          e1 = (unsigned __int8 *)s;
          break;
        default:
          if ( (xlec & 0x1000) == 0 )
          {
            v12 = EditBinding(ch_0a);
            LOBYTE(v12) = v12 & 0x7F;
            if ( LYEdit1(&MyEdit, ch_0a, v12, 0) )
            {
              if ( !refresh_mb )
                LYEdit1(&MyEdit, 0, 9, 0);
            }
            else
            {
              refresh_mb = !refresh_mb || HTCJK == NOCJK || ch_0a <= 128 || ch_0a > 254;
            }
          }
          goto again;
      }
      while ( e1 < e )
      {
        if ( *e1 > 0x1Fu )
        {
          ++e1;
        }
        else
        {
          if ( e1 > (unsigned __int8 *)s )
            LYEditInsert(&MyEdit, (const unsigned __int8 *)s, e1 - (unsigned __int8 *)s, 0, 1);
          s = (const char *)e1;
          if ( *e1 != 9 )
            break;
          LYEditInsert(&MyEdit, " ", 1, 0, 1);
          s = (const char *)++e1;
        }
      }
      if ( e1 > (unsigned __int8 *)s )
        LYEditInsert(&MyEdit, (const unsigned __int8 *)s, e1 - (unsigned __int8 *)s, 0, 1);
LABEL_79:
      get_clip_release();
    }
  }
  LYstrncpy(inputline, MyEdit.buffer, bufsize);
  LYAddToCloset(recall, MyEdit.buffer);
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "LYgetstr(%s) recall\n", inputline);
  }
  return ch_0;
}

//----- (08055ADA) --------------------------------------------------------
char *LYLineeditHelpURL()
{
  char *v0; // ebx

  if ( lasthelp_lineedit_15710 == current_lineedit )
    return helpbuf_15711;
  if ( lasthelp_lineedit_15710 == -1 )
  {
    LYstrncpy(helpbuf_15711, helpfilepath, 255);
    v0 = phelp_15712;
    phelp_15712 = &v0[strlen(helpbuf_15711)];
  }
  if ( !LYLineeditHelpURLs[current_lineedit]
    || !*LYLineeditHelpURLs[current_lineedit]
    || strlen(LYLineeditHelpURLs[current_lineedit]) > 256 - (int)phelp_15712 + 135875136 )
  {
    return 0;
  }
  LYstrncpy(phelp_15712, LYLineeditHelpURLs[current_lineedit], 255 - (_DWORD)phelp_15712 + 135875136);
  lasthelp_lineedit_15710 = current_lineedit;
  return helpbuf_15711;
}

//----- (08055BEB) --------------------------------------------------------
char *__cdecl LYstrsep(char **stringp, const char *delim)
{
  char *out; // [esp+20h] [ebp-8h]
  char *tmp; // [esp+24h] [ebp-4h]

  if ( !stringp || !*stringp )
    return 0;
  out = *stringp;
  tmp = strpbrk(*stringp, delim);
  if ( tmp )
  {
    *tmp = 0;
    *stringp = tmp + 1;
  }
  else
  {
    *stringp = 0;
  }
  return out;
}

//----- (08055C56) --------------------------------------------------------
char *__cdecl LYstrstr(char *chptr, const char *tarptr)
{
  int len; // [esp+24h] [ebp-4h]

  len = strlen(tarptr);
  while ( *chptr )
  {
    if ( !UPPER8(*chptr, *tarptr) && !strncasecomp8(chptr + 1, tarptr + 1, len - 1) )
      return chptr;
    ++chptr;
  }
  return 0;
}

//----- (08055CD6) --------------------------------------------------------
const char *__cdecl LYno_attr_char_case_strstr(const char *chptr, const char *tarptr)
{
  const char *tmpchptr; // [esp+10h] [ebp-8h]
  const char *tmptarptr; // [esp+14h] [ebp-4h]

  if ( !chptr )
    return 0;
  while ( *chptr > 2 && *chptr <= 8 && *chptr )
    ++chptr;
  while ( 1 )
  {
    if ( !*chptr )
      return 0;
    if ( !UPPER8(*chptr, *tarptr) )
      break;
LABEL_19:
    ++chptr;
  }
  tmpchptr = chptr + 1;
  tmptarptr = tarptr + 1;
  if ( !tarptr[1] )
    return chptr;
  while ( 1 )
  {
    if ( *tmpchptr > 2 && *tmpchptr <= 8 )
    {
      ++tmpchptr;
    }
    else
    {
      if ( UPPER8(*tmpchptr, *tmptarptr) )
        goto LABEL_19;
      ++tmpchptr;
      ++tmptarptr;
    }
    if ( !*tmptarptr )
      return chptr;
    if ( !*tmpchptr )
      goto LABEL_19;
  }
}

//----- (08055DE5) --------------------------------------------------------
const char *__cdecl LYno_attr_char_strstr(const char *chptr, const char *tarptr)
{
  const char *tmpchptr; // [esp+4h] [ebp-8h]
  const char *tmptarptr; // [esp+8h] [ebp-4h]

  if ( !chptr )
    return 0;
  while ( *chptr > 2 && *chptr <= 8 && *chptr )
    ++chptr;
  while ( 1 )
  {
    if ( !*chptr )
      return 0;
    if ( *chptr == *tarptr )
      break;
LABEL_19:
    ++chptr;
  }
  tmpchptr = chptr + 1;
  tmptarptr = tarptr + 1;
  if ( !tarptr[1] )
    return chptr;
  while ( 1 )
  {
    if ( *tmpchptr > 2 && *tmpchptr <= 8 )
    {
      ++tmpchptr;
    }
    else
    {
      if ( *tmpchptr != *tmptarptr )
        goto LABEL_19;
      ++tmpchptr;
      ++tmptarptr;
    }
    if ( !*tmptarptr )
      return chptr;
    if ( !*tmpchptr )
      goto LABEL_19;
  }
}

//----- (08055ECC) --------------------------------------------------------
const char *__cdecl LYno_attr_mbcs_case_strstr(
        const char *chptr,
        const char *tarptr,
        BOOLEAN utf_flag,
        BOOLEAN count_gcells,
        int *nstartp,
        int *nendp)
{
  int tarlen; // [esp+24h] [ebp-14h]
  int offset; // [esp+28h] [ebp-10h]
  int len; // [esp+2Ch] [ebp-Ch]
  const char *tmptarptr; // [esp+30h] [ebp-8h]
  const char *tmpchptr; // [esp+34h] [ebp-4h]

  len = 0;
  if ( !chptr || !tarptr )
    return 0;
  while ( *chptr > 2 && *chptr <= 8 && *chptr )
    ++chptr;
  while ( 1 )
  {
    if ( !*chptr )
      return 0;
    if ( !utf_flag && HTCJK && *chptr < 0 && *chptr == *tarptr && chptr[1] && (chptr[1] <= 2 || chptr[1] > 8)
      || !UPPER8(*chptr, *tarptr) )
    {
      break;
    }
    if ( (!utf_flag || (*chptr & 0xC0) != 128) && (*chptr <= 2 || *chptr > 8) )
    {
      if ( !utf_flag && HTCJK && *chptr < 0 && chptr[1] && (chptr[1] <= 2 || chptr[1] > 8) )
      {
        ++chptr;
        if ( count_gcells )
          ++len;
      }
      ++len;
    }
LABEL_79:
    ++chptr;
  }
  tarlen = 0;
  offset = len++;
  tmpchptr = chptr + 1;
  tmptarptr = tarptr + 1;
  if ( !tarptr[1] )
  {
    if ( nstartp )
      *nstartp = offset;
    if ( nendp )
      *nendp = len;
    return chptr;
  }
  if ( utf_flag || HTCJK == NOCJK || *chptr >= 0 || *chptr != *tarptr || !*tmpchptr || *tmpchptr > 2 && *tmpchptr <= 8 )
    goto LABEL_41;
  if ( *tmpchptr != *tmptarptr )
  {
    ++chptr;
    if ( count_gcells )
      ++len;
    goto LABEL_79;
  }
  tmpchptr = chptr + 2;
  tmptarptr = tarptr + 2;
  if ( count_gcells )
    tarlen = 1;
  if ( *tmptarptr )
  {
    while ( 1 )
    {
LABEL_41:
      if ( *tmpchptr > 2 && *tmpchptr <= 8 )
      {
        ++tmpchptr;
      }
      else
      {
        if ( utf_flag || HTCJK == NOCJK || *tmpchptr >= 0 )
        {
          if ( UPPER8(*tmpchptr, *tmptarptr) )
            goto LABEL_79;
        }
        else
        {
          if ( *tmpchptr != *tmptarptr || tmpchptr[1] != tmptarptr[1] || tmpchptr[1] > 2 && tmpchptr[1] <= 8 )
            goto LABEL_79;
          ++tmpchptr;
          ++tmptarptr;
          if ( count_gcells )
            ++tarlen;
        }
        if ( !utf_flag || (*tmptarptr & 0xC0) != 128 )
          ++tarlen;
        ++tmpchptr;
        ++tmptarptr;
      }
      if ( !*tmptarptr )
        break;
      if ( !*tmpchptr )
        goto LABEL_79;
    }
    if ( nstartp )
      *nstartp = offset;
    if ( nendp )
      *nendp = len + tarlen;
    return chptr;
  }
  else
  {
    if ( nstartp )
      *nstartp = offset;
    if ( nendp )
      *nendp = len + tarlen;
    return chptr;
  }
}

//----- (0805628E) --------------------------------------------------------
const char *__cdecl LYno_attr_mbcs_strstr(
        const char *chptr,
        const char *tarptr,
        BOOLEAN utf_flag,
        BOOLEAN count_gcells,
        int *nstartp,
        int *nendp)
{
  int tarlen; // [esp+18h] [ebp-14h]
  int offset; // [esp+1Ch] [ebp-10h]
  int len; // [esp+20h] [ebp-Ch]
  const char *tmptarptr; // [esp+24h] [ebp-8h]
  const char *tmpchptr; // [esp+28h] [ebp-4h]

  len = 0;
  if ( !chptr || !tarptr )
    return 0;
  while ( *chptr > 2 && *chptr <= 8 && *chptr )
    ++chptr;
  while ( 1 )
  {
    if ( !*chptr )
      return 0;
    if ( *chptr == *tarptr )
      break;
    if ( (!utf_flag || (*chptr & 0xC0) != 128) && (*chptr <= 2 || *chptr > 8) )
    {
      if ( !utf_flag && HTCJK && *chptr < 0 && chptr[1] && (chptr[1] <= 2 || chptr[1] > 8) )
      {
        ++chptr;
        if ( count_gcells )
          ++len;
      }
      ++len;
    }
LABEL_71:
    ++chptr;
  }
  tarlen = 0;
  offset = len++;
  tmpchptr = chptr + 1;
  tmptarptr = tarptr + 1;
  if ( !tarptr[1] )
  {
    if ( nstartp )
      *nstartp = offset;
    if ( nendp )
      *nendp = len;
    return chptr;
  }
  if ( utf_flag || HTCJK == NOCJK || *chptr >= 0 || !*tmpchptr || *tmpchptr > 2 && *tmpchptr <= 8 )
    goto LABEL_33;
  if ( *tmpchptr != *tmptarptr )
  {
    ++chptr;
    if ( count_gcells )
      ++len;
    goto LABEL_71;
  }
  tmpchptr = chptr + 2;
  tmptarptr = tarptr + 2;
  if ( count_gcells )
    tarlen = 1;
  if ( *tmptarptr )
  {
    while ( 1 )
    {
LABEL_33:
      if ( *tmpchptr > 2 && *tmpchptr <= 8 )
      {
        ++tmpchptr;
      }
      else
      {
        if ( utf_flag || HTCJK == NOCJK || *tmpchptr >= 0 )
        {
          if ( *tmpchptr != *tmptarptr )
            goto LABEL_71;
        }
        else
        {
          if ( *tmpchptr != *tmptarptr || tmpchptr[1] != tmptarptr[1] || tmpchptr[1] > 2 && tmpchptr[1] <= 8 )
            goto LABEL_71;
          ++tmpchptr;
          ++tmptarptr;
          if ( count_gcells )
            ++tarlen;
        }
        if ( !utf_flag || (*tmptarptr & 0xC0) != 128 )
          ++tarlen;
        ++tmpchptr;
        ++tmptarptr;
      }
      if ( !*tmptarptr )
        break;
      if ( !*tmpchptr )
        goto LABEL_71;
    }
    if ( nstartp )
      *nstartp = offset;
    if ( nendp )
      *nendp = len + tarlen;
    return chptr;
  }
  else
  {
    if ( nstartp )
      *nstartp = offset;
    if ( nendp )
      *nendp = len + tarlen;
    return chptr;
  }
}

//----- (080565C8) --------------------------------------------------------
char *__cdecl SNACopy(char **dest, const char *src, int n)
{
  FILE *v3; // eax

  if ( *dest )
  {
    free(*dest);
    *dest = 0;
  }
  if ( src )
  {
    *dest = (char *)malloc(n + 1);
    if ( !*dest )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "Tried to malloc %d bytes\n", n);
      }
      outofmem("./LYStrings.c", "SNACopy");
    }
    strncpy(*dest, src, n);
    (*dest)[n] = 0;
  }
  return *dest;
}

//----- (08056682) --------------------------------------------------------
char *__cdecl SNACat(char **dest, const char *src, int n)
{
  int length; // [esp+24h] [ebp-4h]

  if ( src && *src )
  {
    if ( *dest )
    {
      length = strlen(*dest);
      *dest = (char *)realloc(*dest, n + length + 1);
      if ( !*dest )
        outofmem("./LYStrings.c", "SNACat");
      strncpy(&(*dest)[length], src, n);
      (*dest)[length + n] = 0;
    }
    else
    {
      *dest = (char *)malloc(n + 1);
      if ( !*dest )
        outofmem("./LYStrings.c", "SNACat");
      memcpy(*dest, src, n);
      (*dest)[n] = 0;
    }
  }
  return *dest;
}

//----- (08056797) --------------------------------------------------------
int __cdecl UniToLowerCase(int upper)
{
  int diff; // [esp+4h] [ebp-10h]
  size_t low; // [esp+8h] [ebp-Ch]
  size_t high; // [esp+Ch] [ebp-8h]
  size_t i; // [esp+10h] [ebp-4h]

  if ( upper <= 0 )
    return upper;
  low = 0;
  high = 705;
  while ( low < high )
  {
    i = low + ((high - low) >> 1);
    diff = unicode_to_lower_case[i].upper - upper;
    if ( diff < 0 )
      low = i + 1;
    if ( diff > 0 )
      high = i;
    if ( !diff )
      return unicode_to_lower_case[i].lower;
  }
  return upper;
}

//----- (0805682D) --------------------------------------------------------
int __cdecl UPPER8(int ch1, int ch2)
{
  int v2; // ebx
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  UCode_t uni_ch1; // [esp+2Ch] [ebp-Ch]
  UCode_t uni_ch2; // [esp+30h] [ebp-8h]

  if ( ch1 == ch2 )
    return 0;
  if ( !ch2 )
    return (unsigned __int8)ch1;
  if ( !ch1 )
    return -(unsigned __int8)ch2;
  if ( (ch1 & 0x80u) != 0 || (ch2 & 0x80u) != 0 )
  {
    if ( (ch1 & 0x80u) == 0 || (ch2 & 0x80u) == 0 )
    {
      return -10;
    }
    else if ( DisplayCharsetMatchLocale )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)ch1] & 0x200) != 0 )
        v7 = toupper((unsigned __int8)ch1);
      else
        v7 = (unsigned __int8)ch1;
      if ( ((*__ctype_b_loc())[(unsigned __int8)ch2] & 0x200) != 0 )
        v8 = toupper((unsigned __int8)ch2);
      else
        v8 = (unsigned __int8)ch2;
      return v7 - v8;
    }
    else
    {
      uni_ch2 = UCTransToUni(ch2, current_char_set);
      if ( uni_ch2 >= 0 )
      {
        uni_ch1 = UCTransToUni(ch1, current_char_set);
        v2 = UniToLowerCase(uni_ch1);
        return v2 - UniToLowerCase(uni_ch2);
      }
      else
      {
        return (unsigned __int8)ch1;
      }
    }
  }
  else
  {
    if ( ((*__ctype_b_loc())[(unsigned __int8)ch1] & 0x200) != 0 )
      v5 = toupper((unsigned __int8)ch1);
    else
      v5 = (unsigned __int8)ch1;
    if ( ((*__ctype_b_loc())[(unsigned __int8)ch2] & 0x200) != 0 )
      v6 = toupper((unsigned __int8)ch2);
    else
      v6 = (unsigned __int8)ch2;
    return v5 - v6;
  }
}

//----- (08056A34) --------------------------------------------------------
char *__cdecl LYSafeGets(char **src, FILE *fp)
{
  char *result; // [esp+20h] [ebp-2008h] BYREF
  char buffer[8192]; // [esp+24h] [ebp-2004h] BYREF
  unsigned int v5; // [esp+2024h] [ebp-4h]

  v5 = __readgsdword(0x14u);
  result = 0;
  if ( src )
    result = *src;
  if ( result )
    *result = 0;
  do
  {
    if ( !fgets(buffer, 0x2000, fp) )
      break;
    if ( buffer[0] )
      result = HTSACat(&result, buffer);
  }
  while ( !strchr(buffer, 10) );
  if ( ferror(fp) )
  {
    if ( !result )
      goto LABEL_16;
    goto LABEL_15;
  }
  if ( feof(fp) && result && !*result )
  {
LABEL_15:
    free(result);
    result = 0;
  }
LABEL_16:
  if ( src )
    *src = result;
  return result;
}
// 8056B5E: conditional instruction was optimized away because %result.4!=0

//----- (08056BA8) --------------------------------------------------------
void __cdecl LYOpenCmdLogfile(int argc, char **argv)
{
  char *v2; // eax
  int n; // [esp+24h] [ebp-4h]

  if ( lynx_cmd_logfile )
  {
    cmd_logfile = LYNewTxtFile(lynx_cmd_logfile);
    if ( cmd_logfile )
    {
      v2 = LYVersionDate();
      fprintf(cmd_logfile, "# Command logfile created by %s %s (%s)\n", "Lynx", "2.8.7dev.11", v2);
      for ( n = 0; n < argc; ++n )
        fprintf(cmd_logfile, "# Arg%d = %s\n", n, argv[n]);
    }
  }
}

//----- (08056C48) --------------------------------------------------------
bool LYHaveCmdScript()
{
  return cmd_script != 0;
}

//----- (08056C57) --------------------------------------------------------
void LYOpenCmdScript()
{
  const char *v0; // ebx
  FILE *v1; // eax
  const char *v2; // [esp+10h] [ebp-8h]

  if ( lynx_cmd_script )
  {
    cmd_script = (FILE *)fopen64(lynx_cmd_script, "r");
    if ( WWW_TraceFlag[0] )
    {
      if ( cmd_script )
        v2 = "SUCCESS";
      else
        v2 = "FAIL";
      v0 = lynx_cmd_script;
      v1 = TraceFP();
      fprintf(v1, "LYOpenCmdScript(%s) %s\n", v0, v2);
    }
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08056CD3) --------------------------------------------------------
int __cdecl LYReadCmdKey(int mode)
{
  char *v1; // eax
  FILE *v2; // edx
  char *v3; // ebx
  FILE *v4; // edx
  char *tmp; // [esp+34h] [ebp-14h]
  char *tmpa; // [esp+34h] [ebp-14h]
  char *src; // [esp+38h] [ebp-10h]
  char *srca; // [esp+38h] [ebp-10h]
  char *buffer; // [esp+3Ch] [ebp-Ch] BYREF
  int ch_0; // [esp+40h] [ebp-8h]

  ch_0 = -1;
  if ( cmd_script )
  {
    buffer = 0;
    while ( ch_0 < 0 && LYSafeGets(&buffer, cmd_script) )
    {
      LYTrimTrailing(buffer);
      src = LYSkipBlanks(buffer);
      tmp = LYSkipNonBlanks(src);
      if ( tmp - src == 3 )
      {
        if ( strncasecomp(src, "key", 3) )
        {
          if ( !strncasecomp(src, "set", 3) )
          {
            srca = LYSkipBlanks(tmp);
            for ( tmpa = srca; *tmpa && ((*__ctype_b_loc())[(unsigned __int8)*tmpa] & 0x2000) == 0 && *tmpa != 61; ++tmpa )
              ;
            if ( *tmpa )
            {
              *tmpa = 0;
              tmpa = LYSkipBlanks(tmpa + 1);
            }
            if ( WWW_TraceFlag[0] )
            {
              v2 = TraceFP();
              fprintf(v2, "LYSetConfigValue(%s, %s)\n", srca, tmpa);
            }
            LYSetConfigValue(srca, tmpa);
          }
        }
        else
        {
          v1 = LYSkipBlanks(tmp);
          ch_0 = LYStringToKeycode(v1);
        }
      }
      else if ( tmp - src == 4 && !strncasecomp(src, "exit", 4) )
      {
        exit_immediately(0);
      }
    }
    if ( feof(cmd_script) )
    {
      fclose(cmd_script);
      cmd_script = 0;
    }
    if ( ch_0 >= 0 )
    {
      LYSleepReplay();
      LYrefresh();
    }
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
  }
  else
  {
    ch_0 = LYgetch_for(mode);
  }
  if ( WWW_TraceFlag[0] )
  {
    v3 = LYKeycodeToString(ch_0, 1);
    v4 = TraceFP();
    fprintf(v4, "LYReadCmdKey(%d) ->%s (%#x)\n", mode, v3, ch_0);
  }
  LYWriteCmdKey(ch_0);
  return ch_0;
}

//----- (08056F71) --------------------------------------------------------
void __cdecl LYWriteCmdKey(int ch_0)
{
  char *v1; // eax

  if ( cmd_logfile )
  {
    v1 = LYKeycodeToString(ch_0, 0);
    fprintf(cmd_logfile, "key %s\n", v1);
  }
}

//----- (08056FAF) --------------------------------------------------------
void LYCloseCmdLogfile()
{
  if ( cmd_logfile )
  {
    LYCloseOutput(cmd_logfile);
    cmd_logfile = 0;
  }
  if ( cmd_script )
  {
    LYCloseInput(cmd_script);
    cmd_script = 0;
  }
  if ( lynx_cmd_logfile )
  {
    free(lynx_cmd_logfile);
    lynx_cmd_logfile = 0;
  }
  if ( lynx_cmd_script )
  {
    free(lynx_cmd_script);
    lynx_cmd_script = 0;
  }
}

//----- (08057038) --------------------------------------------------------
void __cdecl terminate_letter(int sig)
{
  term_letter[0] = 1;
  signal(2, terminate_letter);
}

//----- (0805705B) --------------------------------------------------------
void __cdecl SafeHTUnEscape(char *string)
{
  char *v1; // eax
  int flg; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  flg = 0;
  HTUnEscape(string);
  for ( i = 0; string[i]; ++i )
  {
    if ( string[i] < 0 || ((*__ctype_b_loc())[(unsigned __int8)string[i]] & 0x4000) == 0 )
    {
      string[i] = 63;
      flg = 1;
    }
  }
  if ( flg )
  {
    v1 = gettext("Warning!  Control codes in mail address replaced by ?");
    HTAlert(v1);
  }
}

//----- (080570ED) --------------------------------------------------------
void __cdecl remove_tildes(char *string)
{
  if ( *string == 126 )
    *string = 32;
}

//----- (08057102) --------------------------------------------------------
void __cdecl comma_append(char **dst, char *src)
{
  if ( *src )
  {
    while ( *src == 44 || ((*__ctype_b_loc())[(unsigned __int8)*src] & 0x2000) != 0 )
      ++src;
    if ( *src )
    {
      if ( *dst && **dst )
      {
        HTSACat(dst, ",");
        HTSACat(dst, src);
      }
      else
      {
        HTSACopy(dst, src);
      }
    }
  }
}

//----- (080571A4) --------------------------------------------------------
void __cdecl extract_field(char **dst, char *src, const char *keyword)
{
  FILE *v3; // edx
  char *v4; // [esp+14h] [ebp-14h]
  char *cp1; // [esp+1Ch] [ebp-Ch]
  char *cp; // [esp+20h] [ebp-8h]
  char *cpa; // [esp+20h] [ebp-8h]
  size_t len; // [esp+24h] [ebp-4h]

  len = strlen(keyword);
  for ( cp = src + 1; *cp; ++cp )
  {
    if ( (*(cp - 1) == 63 || *(cp - 1) == 38) && !strncasecomp(cp, keyword, len) )
    {
      cpa = &cp[len];
      cp1 = strchr(cpa, 38);
      if ( cp1 )
        *cp1 = 0;
      comma_append(dst, cpa);
      if ( !cp1 )
        break;
      *cp1 = 38;
      cp = cp1;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( *dst )
      v4 = *dst;
    else
      v4 = "(null)";
    v3 = TraceFP();
    fprintf(v3, "extract_field(%s) = '%s'\n", keyword, v4);
  }
}

//----- (080572B0) --------------------------------------------------------
void __cdecl extract_subject(char *dst, char *src)
{
  FILE *v2; // eax
  char *v3; // [esp+14h] [ebp-14h]
  char *cp1; // [esp+18h] [ebp-10h]
  char *cp; // [esp+1Ch] [ebp-Ch]
  char *cpa; // [esp+1Ch] [ebp-Ch]
  size_t len; // [esp+20h] [ebp-8h]

  len = strlen("subject=");
  for ( cp = src + 1; *cp && (*(cp - 1) != 63 && *(cp - 1) != 38 || strncasecomp(cp, "subject=", len)); ++cp )
    ;
  if ( *cp )
  {
    cpa = &cp[len];
    cp1 = strchr(cpa, 38);
    if ( cp1 )
      *cp1 = 0;
    if ( *cpa )
    {
      strncpy(dst, cpa, 0x46u);
      dst[70] = 0;
      SafeHTUnEscape(dst);
    }
    if ( cp1 )
      *cp1 = 38;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( dst )
      v3 = dst;
    else
      v3 = "(null)";
    v2 = TraceFP();
    fprintf(v2, "extract_subject(%s) = '%s'\n", "subject=", v3);
  }
}

//----- (080573DF) --------------------------------------------------------
void __cdecl extract_body(char **dst, char *src)
{
  FILE *v2; // eax
  char *v3; // [esp+14h] [ebp-24h]
  char *temp; // [esp+1Ch] [ebp-1Ch] BYREF
  char *cp1; // [esp+20h] [ebp-18h]
  char *cp0; // [esp+24h] [ebp-14h]
  char *cp; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int len; // [esp+30h] [ebp-8h]
  const char *keyword; // [esp+34h] [ebp-4h]

  keyword = "body=";
  len = strlen("body=");
  temp = 0;
  for ( cp = src + 1; *cp; ++cp )
  {
    if ( (*(cp - 1) == 63 || *(cp - 1) == 38) && !strncasecomp(cp, keyword, len) )
    {
      cp += len;
      cp1 = strchr(cp, 38);
      if ( cp1 )
        *cp1 = 0;
      if ( *cp )
      {
        HTSACopy(&temp, cp);
        HTUnEscape(temp);
        for ( cp0 = temp; ; cp0 = cp + 1 )
        {
          cp = strchr(cp0, 10);
          if ( !cp )
            break;
          *cp = 0;
          if ( cp > cp0 && *(cp - 1) == 13 )
            *(cp - 1) = 0;
          i = 0;
          for ( len = strlen(cp0); len > 78; len = strlen(&cp0[i]) )
          {
            HTSprintf(dst, "%.78s\n", &cp0[i]);
            i += 78;
          }
          HTSprintf(dst, "%s\n", &cp0[i]);
        }
        i = 0;
        for ( len = strlen(cp0); len > 78; len = strlen(&cp0[i]) )
        {
          HTSprintf(dst, "%.78s\n", &cp0[i]);
          i += 78;
        }
        if ( len )
          HTSprintf(dst, "%s\n", &cp0[i]);
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
      }
      if ( !cp1 )
        break;
      *cp1 = 38;
      cp = cp1;
      cp1 = 0;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( *dst )
      v3 = *dst;
    else
      v3 = "(null)";
    v2 = TraceFP();
    fprintf(v2, "extract_body(%s) = '%s'\n", keyword, v3);
  }
}

//----- (08057667) --------------------------------------------------------
BOOLEAN __cdecl trim_comma(char *address)
{
  if ( address[strlen(address) - 1] == 44 )
    address[strlen(address) - 1] = 0;
  return *address == 0;
}

//----- (080576A6) --------------------------------------------------------
BOOLEAN __cdecl convert_explorer(char *address)
{
  char *cp1; // [esp+Ch] [ebp-Ch]
  char *cp1a; // [esp+Ch] [ebp-Ch]
  char *cp0; // [esp+10h] [ebp-8h]
  const char *cp; // [esp+14h] [ebp-4h]

  for ( cp = address; ; cp = cp1 )
  {
    cp1a = strchr(cp, 64);
    if ( !cp1a )
      break;
    cp1 = cp1a + 1;
    cp0 = strchr(cp1, 59);
    if ( cp0 )
    {
      *cp0 = 44;
      cp1 = cp0 + 1;
    }
  }
  return trim_comma(address);
}

//----- (08057712) --------------------------------------------------------
int __cdecl header_prompt(const char *label, char **result, unsigned int limit)
{
  char *v3; // eax
  size_t v4; // ebx
  char *v5; // eax
  char *v6; // eax
  size_t v7; // ebx
  char *v8; // eax
  int v10; // [esp+18h] [ebp-420h]
  char buffer[1024]; // [esp+30h] [ebp-408h] BYREF
  unsigned int v12; // [esp+430h] [ebp-8h]

  v12 = __readgsdword(0x14u);
  if ( *result )
  {
    v3 = gettext(" Use Control-U to erase the default.\n");
    v4 = strlen(v3);
    v5 = gettext(" Use Control-U to erase the default.\n");
    LYwaddnstr(LYwin, v5, v4);
    LYstrncpy(buffer, *result, 1023);
  }
  else
  {
    buffer[0] = 0;
  }
  if ( limit > 0x400 )
    limit = 1024;
  v6 = gettext(label);
  v7 = strlen(v6);
  v8 = gettext(label);
  LYwaddnstr(LYwin, v8, v7);
  LYwaddnstr(LYwin, ": ", 2u);
  v10 = LYgetstr(buffer, 0, limit, NORECALL) >= 0 && !term_letter[0];
  LYwaddnstr(LYwin, "\n", 1u);
  if ( v10 )
  {
    remove_tildes(buffer);
    HTSACopy(result, buffer);
  }
  term_letter[0] = 0;
  return v10;
}

//----- (080578DA) --------------------------------------------------------
void __cdecl show_addresses(char *addresses)
{
  size_t v1; // [esp+8h] [ebp-20h]
  size_t v2; // [esp+8h] [ebp-20h]
  char *cp1; // [esp+20h] [ebp-8h]

  while ( 1 )
  {
    cp1 = strchr(addresses, 44);
    if ( !cp1 )
      break;
    *cp1 = 0;
    while ( *addresses == 32 )
      ++addresses;
    if ( *addresses )
    {
      v1 = strlen(addresses);
      LYwaddnstr(LYwin, addresses, v1);
      LYwaddnstr(LYwin, ",\n  ", 4u);
    }
    *cp1 = 44;
    addresses = cp1 + 1;
  }
  if ( *addresses )
  {
    v2 = strlen(addresses);
    LYwaddnstr(LYwin, addresses, v2);
  }
}

//----- (080579A8) --------------------------------------------------------
FILE *LYPipeToMailer()
{
  char *v0; // ebx
  FILE *v1; // eax
  const char *v3; // [esp+10h] [ebp-18h]
  FILE *fp; // [esp+1Ch] [ebp-Ch]
  char *buffer; // [esp+20h] [ebp-8h] BYREF

  buffer = 0;
  fp = 0;
  if ( (unsigned __int8)LYSystemMail() )
  {
    HTSprintf0(&buffer, "%s %s", system_mail, system_mail_flags);
    fp = popen(buffer, "w");
    if ( WWW_TraceFlag[0] )
    {
      if ( fp )
        v3 = "OK";
      else
        v3 = "FAIL";
      v0 = buffer;
      v1 = TraceFP();
      fprintf(v1, "popen(%s) %s\n", v0, v3);
    }
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
  }
  return fp;
}

//----- (08057A6E) --------------------------------------------------------
void __cdecl mailform(
        const char *mailto_address,
        const char *mailto_subject,
        const char *mailto_content,
        const char *mailto_type)
{
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  const char *v14; // [esp+14h] [ebp-2F4h]
  const char *v15; // [esp+18h] [ebp-2F0h]
  const char *v16; // [esp+1Ch] [ebp-2ECh]
  const char *v17; // [esp+20h] [ebp-2E8h]
  const char *v18; // [esp+24h] [ebp-2E4h]
  char *mailto_contenta; // [esp+2Ch] [ebp-2DCh]
  int i; // [esp+40h] [ebp-2C8h]
  int ia; // [esp+40h] [ebp-2C8h]
  int len; // [esp+44h] [ebp-2C4h]
  int lena; // [esp+44h] [ebp-2C4h]
  char *searchpart; // [esp+4Ch] [ebp-2BCh] BYREF
  char *cp; // [esp+50h] [ebp-2B8h]
  char *keywords; // [esp+54h] [ebp-2B4h] BYREF
  char *ccaddr; // [esp+58h] [ebp-2B0h] BYREF
  char *address; // [esp+5Ch] [ebp-2ACh] BYREF
  FILE *fd; // [esp+60h] [ebp-2A8h]
  char buf[512]; // [esp+64h] [ebp-2A4h] BYREF
  char subject[80]; // [esp+264h] [ebp-A4h] BYREF
  char self[80]; // [esp+2B4h] [ebp-54h] BYREF
  unsigned int v33; // [esp+304h] [ebp-4h]

  mailto_contenta = (char *)mailto_content;
  v33 = __readgsdword(0x14u);
  address = 0;
  ccaddr = 0;
  keywords = 0;
  cp = 0;
  searchpart = 0;
  if ( WWW_TraceFlag[0] )
  {
    if ( mailto_address )
      v14 = mailto_address;
    else
      v14 = "(null)";
    v4 = TraceFP();
    fprintf(v4, "mailto_address: \"%s\"\n", v14);
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( mailto_subject )
      v15 = mailto_subject;
    else
      v15 = "(null)";
    v5 = TraceFP();
    fprintf(v5, "mailto_subject: \"%s\"\n", v15);
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( mailto_content )
      v16 = mailto_content;
    else
      v16 = "(null)";
    v6 = TraceFP();
    fprintf(v6, "mailto_content: \"%s\"\n", v16);
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( mailto_type )
      v17 = mailto_type;
    else
      v17 = "(null)";
    v7 = TraceFP();
    fprintf(v7, "mailto_type:    \"%s\"\n", v17);
  }
  if ( (unsigned __int8)LYSystemMail() )
  {
    if ( !mailto_address || !mailto_content )
    {
      v8 = gettext("Malformed mailto form submission!  Cancelled!");
      HTAlert(v8);
      return;
    }
    subject[0] = 0;
    self[0] = 0;
    cp = strchr(mailto_address, 10);
    if ( cp )
      *cp = 0;
    HTSACopy(&address, mailto_address);
    cp = strchr(address, 63);
    if ( cp )
    {
      HTSACopy(&searchpart, cp);
      *cp = 0;
      cp = searchpart + 1;
      if ( searchpart[1] )
      {
        extract_subject(subject, searchpart);
        extract_field(&address, searchpart, "to=");
        extract_field(&ccaddr, searchpart, "cc=");
        extract_field(&keywords, searchpart, "keywords=");
        if ( keywords )
        {
          if ( *keywords )
          {
            SafeHTUnEscape(keywords);
          }
          else
          {
            free(keywords);
            keywords = 0;
          }
        }
        if ( searchpart )
        {
          free(searchpart);
          searchpart = 0;
        }
      }
    }
    if ( convert_explorer(address) )
    {
      v9 = gettext("Malformed mailto form submission!  Cancelled!");
      HTAlert(v9);
cleanup:
      if ( address )
      {
        free(address);
        address = 0;
      }
      if ( ccaddr )
      {
        free(ccaddr);
        ccaddr = 0;
      }
      if ( keywords )
        free(keywords);
      return;
    }
    if ( ccaddr && convert_explorer(ccaddr) && ccaddr )
    {
      free(ccaddr);
      ccaddr = 0;
    }
    SafeHTUnEscape(address);
    if ( ccaddr )
      SafeHTUnEscape(ccaddr);
    if ( !subject[0] )
    {
      if ( mailto_subject && *mailto_subject )
        LYstrncpy(subject, mailto_subject, 70);
      else
        sprintf(subject, "mailto:%.63s", address);
    }
    mustshow[0] = 1;
    v10 = gettext("Subject: ");
    statusline(v10);
    if ( LYgetstr(subject, 0, 0x46u, NORECALL) < 0 )
    {
LABEL_49:
      v11 = gettext("Mailto form submission Cancelled!!!");
      HTInfoMsg(v11);
      goto cleanup;
    }
    if ( !LYNoCc )
    {
      if ( personal_mail_address && *personal_mail_address )
        v18 = personal_mail_address;
      else
        v18 = &position;
      sprintf(self, "%.*s", 70, v18);
      mustshow[0] = 1;
      statusline("Cc: ");
      if ( LYgetstr(self, 0, 0x46u, NORECALL) < 0 )
        goto LABEL_49;
      remove_tildes(self);
      if ( ccaddr )
      {
        HTSACat(&ccaddr, ",");
        HTSACat(&ccaddr, self);
      }
      else
      {
        HTSACopy(&ccaddr, self);
      }
    }
    fd = LYPipeToMailer();
    if ( fd )
    {
      if ( mailto_type && *mailto_type )
      {
        fwrite("Mime-Version: 1.0\n", 1u, 0x12u, fd);
        fprintf(fd, "Content-Type: %s\n", mailto_type);
      }
      fprintf(fd, "To: %s\n", address);
      if ( personal_mail_address && *personal_mail_address )
        fprintf(fd, "From: %s\n", personal_mail_address);
      if ( ccaddr && *ccaddr )
        fprintf(fd, "Cc: %s\n", ccaddr);
      fprintf(fd, "Subject: %s\n\n", subject);
      if ( keywords && *keywords )
        fprintf(fd, "Keywords: %s\n", keywords);
      mustshow[0] = 1;
      v13 = gettext("Sending form content...");
      statusline(v13);
      while ( 1 )
      {
        cp = strchr(mailto_contenta, 10);
        if ( !cp )
          break;
        *cp = 0;
        i = 0;
        for ( len = strlen(mailto_contenta); len > 78; len = strlen(&mailto_contenta[i]) )
        {
          strncpy(buf, &mailto_contenta[i], 0x4Eu);
          buf[78] = 0;
          fprintf(fd, "%s\n", buf);
          i += 78;
        }
        fprintf(fd, "%s\n", &mailto_contenta[i]);
        mailto_contenta = cp + 1;
      }
      ia = 0;
      for ( lena = strlen(mailto_contenta); lena > 78; lena = strlen(&mailto_contenta[ia]) )
      {
        strncpy(buf, &mailto_contenta[ia], 0x4Eu);
        buf[78] = 0;
        fprintf(fd, "%s\n", buf);
        ia += 78;
      }
      if ( lena )
        fprintf(fd, "%s\n", &mailto_contenta[ia]);
      pclose(fd);
      LYSleepMsg();
    }
    else
    {
      v12 = gettext("Mailto form submission failed!");
      HTAlert(v12);
    }
    goto cleanup;
  }
}
// 8057DA6: conditional instruction was optimized away because %keywords.4!=0

//----- (0805842D) --------------------------------------------------------
void __cdecl mailmsg(int cur, char *owner_address, char *filename, char *linkname)
{
  FILE *v4; // eax
  FILE *v5; // eax
  char *target; // esi
  char *lname; // ebx
  char *v8; // eax
  const char *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  FILE *ofp; // [esp+24h] [ebp-24h]
  char *cp; // [esp+28h] [ebp-20h]
  const char *cpa; // [esp+28h] [ebp-20h]
  char *cmd; // [esp+2Ch] [ebp-1Ch] BYREF
  char *searchpart; // [esp+30h] [ebp-18h] BYREF
  char *address; // [esp+34h] [ebp-14h] BYREF
  FILE *fp; // [esp+38h] [ebp-10h]
  FILE *fd; // [esp+3Ch] [ebp-Ch]

  address = 0;
  searchpart = 0;
  cmd = 0;
  if ( (unsigned __int8)LYSystemMail() && owner_address && *owner_address )
  {
    cp = strchr(owner_address, 10);
    if ( cp )
      *cp = 0;
    if ( strncasecomp(owner_address, "lynx-dev@", 9) )
    {
      HTSACopy(&address, owner_address);
      cpa = strchr(address, 63);
      if ( cpa )
      {
        HTSACopy(&searchpart, cpa);
        *cpa = 0;
        if ( searchpart[1] )
          extract_field(&address, searchpart, "to=");
      }
      convert_explorer(address);
      SafeHTUnEscape(address);
      if ( trim_comma(address) )
      {
        if ( address )
        {
          free(address);
          address = 0;
        }
        if ( WWW_TraceFlag[0] )
        {
          v4 = TraceFP();
          fprintf(v4, "mailmsg: No address in '%s'.\n", owner_address);
        }
      }
      else
      {
        fd = LYPipeToMailer();
        if ( fd )
        {
          fprintf(fd, "To: %s\n", address);
          fprintf(fd, "Subject: Lynx Error in %s\n", filename);
          if ( personal_mail_address && *personal_mail_address )
            fprintf(fd, "Cc: %s\n", personal_mail_address);
          fprintf(fd, "X-URL: %s\n", filename);
          fprintf(fd, "X-Mailer: %s, Version %s\n\n", "Lynx", "2.8.7dev.11");
          target = links[cur].target;
          lname = links[cur].lname;
          v8 = gettext("The link   %s :?: %s \n");
          fprintf(fd, v8, lname, target);
          v9 = LYGetHiliteStr(cur, 0);
          v10 = gettext("called \"%s\"\n");
          fprintf(fd, v10, v9);
          v11 = gettext("in the file \"%s\" called \"%s\"\n");
          fprintf(fd, v11, filename, linkname);
          v12 = gettext("was requested but was not available.");
          fprintf(fd, "%s\n\n", v12);
          v13 = gettext("Thought you might want to know.");
          fprintf(fd, "%s\n\n", v13);
          v14 = gettext("This message was automatically generated by");
          fprintf(fd, "%s\n", v14);
          fprintf(fd, "%s %s", "Lynx", "2.8.7dev.11");
          if ( LynxSigFile )
          {
            fp = (FILE *)fopen64(LynxSigFile, "r");
            if ( fp )
            {
              fwrite("-- \n", 1u, 4u, fd);
              while ( LYSafeGets(&cmd, fp) )
                fputs(cmd, fd);
              LYCloseInput(fp);
            }
          }
          pclose(fd);
          if ( traversal )
          {
            ofp = LYAppendToTxtFile("traverse.errors");
            if ( !ofp )
            {
              ofp = LYNewTxtFile("traverse.errors");
              if ( !ofp )
              {
                v15 = gettext("Unable to open traversal errors output file");
                perror(v15);
                exit_immediately(1);
              }
            }
            fprintf(ofp, "%s\t%s \tin %s\n", links[cur].lname, links[cur].target, filename);
            LYCloseOutput(ofp);
          }
          if ( address )
            free(address);
        }
        else
        {
          if ( address )
          {
            free(address);
            address = 0;
          }
          if ( WWW_TraceFlag[0] )
          {
            v5 = TraceFP();
            fprintf(v5, "mailmsg: '%s' failed.\n", cmd);
          }
        }
      }
    }
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0805891C) --------------------------------------------------------
void __cdecl reply_by_mail(char *mail_address, char *filename, const char *title, const char *refid)
{
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  size_t v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  size_t v13; // ebx
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  size_t v17; // ebx
  char *v18; // eax
  char *v19; // eax
  size_t v20; // ebx
  char *v21; // eax
  char *v22; // eax
  size_t v23; // ebx
  char *v24; // eax
  char *v25; // eax
  size_t v26; // ebx
  char *v27; // eax
  char *v28; // eax
  size_t v29; // ebx
  char *v30; // eax
  char *v31; // eax
  size_t v32; // ebx
  char *v33; // eax
  char *v34; // eax
  size_t v35; // ebx
  char *v36; // eax
  char *v37; // ebx
  FILE *v38; // eax
  char *v39; // eax
  char *v40; // eax
  size_t v41; // ebx
  char *v42; // eax
  char *v43; // eax
  size_t v44; // ebx
  char *v45; // eax
  size_t v46; // eax
  char *v47; // eax
  size_t v48; // ebx
  char *v49; // eax
  char *v50; // eax
  size_t v51; // ebx
  char *v52; // eax
  char *v53; // eax
  size_t v54; // ebx
  char *v55; // eax
  const char *v56; // ebx
  char *v57; // eax
  char *v58; // ebx
  char *v59; // eax
  char *v60; // eax
  char *v61; // eax
  char *v62; // eax
  char *v63; // eax
  const char *v64; // [esp+18h] [ebp-15D0h]
  const char *v65; // [esp+1Ch] [ebp-15CCh]
  char *v66; // [esp+20h] [ebp-15C8h]
  char *v67; // [esp+24h] [ebp-15C4h]
  bool v68; // [esp+28h] [ebp-15C0h]
  char *Msg; // [esp+2Ch] [ebp-15BCh]
  const char *v70; // [esp+30h] [ebp-15B8h]
  char *buffer; // [esp+44h] [ebp-15A4h] BYREF
  int n; // [esp+48h] [ebp-15A0h]
  char *header; // [esp+4Ch] [ebp-159Ch] BYREF
  int c; // [esp+50h] [ebp-1598h]
  int i; // [esp+54h] [ebp-1594h]
  char *cp1; // [esp+58h] [ebp-1590h]
  char *cp; // [esp+5Ch] [ebp-158Ch]
  char *body; // [esp+60h] [ebp-1588h] BYREF
  char *searchpart; // [esp+64h] [ebp-1584h] BYREF
  char *keywords; // [esp+68h] [ebp-1580h] BYREF
  char *ccaddr; // [esp+6Ch] [ebp-157Ch] BYREF
  char *the_subject; // [esp+70h] [ebp-1578h] BYREF
  char *to_address; // [esp+74h] [ebp-1574h] BYREF
  char *cc_address; // [esp+78h] [ebp-1570h] BYREF
  char *from_address; // [esp+7Ch] [ebp-156Ch] BYREF
  const char *label; // [esp+80h] [ebp-1568h]
  FILE *fp; // [esp+84h] [ebp-1564h]
  FILE *fd; // [esp+88h] [ebp-1560h]
  BOOLEAN is_preparsed; // [esp+8Fh] [ebp-1559h]
  char buf[4096]; // [esp+90h] [ebp-1558h] BYREF
  char user_input[1024]; // [esp+1090h] [ebp-558h] BYREF
  char my_tmpfile[256]; // [esp+1490h] [ebp-158h] BYREF
  char default_subject[80]; // [esp+1590h] [ebp-58h] BYREF
  unsigned int v94; // [esp+15E0h] [ebp-8h]

  v94 = __readgsdword(0x14u);
  label = 0;
  from_address = 0;
  cc_address = 0;
  to_address = 0;
  the_subject = 0;
  ccaddr = 0;
  keywords = 0;
  searchpart = 0;
  body = 0;
  cp = 0;
  cp1 = 0;
  c = 0;
  header = 0;
  if ( WWW_TraceFlag[0] )
  {
    if ( refid )
      v64 = refid;
    else
      v64 = "(null)";
    if ( title )
      v65 = title;
    else
      v65 = "(null)";
    if ( filename )
      v66 = filename;
    else
      v66 = "(null)";
    if ( mail_address )
      v67 = mail_address;
    else
      v67 = "(null)";
    v4 = TraceFP();
    fprintf(v4, "reply_by_mail(\"%s\", \"%s\", \"%s\", \"%s\")\n", v67, v66, v65, v64);
  }
  term_letter[0] = 0;
  if ( (unsigned __int8)LYSystemMail() )
  {
    if ( !mail_address || !*mail_address )
    {
      v5 = gettext("No email address is present in mailto URL!");
      HTAlert(v5);
      return;
    }
    HTSACopy(&to_address, mail_address);
    fd = LYOpenTemp(my_tmpfile, ".txt", "w");
    if ( !fd )
    {
      v6 = gettext("Unable to open temporary file for mailto URL!");
      HTAlert(v6);
      return;
    }
    default_subject[0] = 0;
    cp = strchr(to_address, 63);
    if ( cp )
    {
      HTSACopy(&searchpart, cp);
      *cp = 0;
      cp = searchpart + 1;
      if ( searchpart[1] )
      {
        extract_subject(default_subject, searchpart);
        extract_field(&to_address, searchpart, "to=");
        extract_field(&ccaddr, searchpart, "cc=");
        extract_field(&keywords, searchpart, "keywords=");
        if ( keywords )
        {
          if ( *keywords )
          {
            SafeHTUnEscape(keywords);
          }
          else
          {
            free(keywords);
            keywords = 0;
          }
        }
        extract_body(&body, searchpart);
        if ( searchpart )
        {
          free(searchpart);
          searchpart = 0;
        }
      }
    }
    if ( convert_explorer(to_address) )
    {
      v7 = gettext("No email address is present in mailto URL!");
      HTAlert(v7);
cancelled:
      v63 = gettext("Cancelled!!!");
      HTInfoMsg(v63);
      LYCloseTempFP(fd);
      scrollok(LYwin, 0);
      goto cleanup;
    }
    if ( ccaddr && convert_explorer(ccaddr) && ccaddr )
    {
      free(ccaddr);
      ccaddr = 0;
    }
    SafeHTUnEscape(to_address);
    if ( ccaddr )
      SafeHTUnEscape(ccaddr);
    if ( !default_subject[0] && title && *title )
    {
      strncpy(default_subject, title, 0x46u);
      default_subject[70] = 0;
    }
    signal(2, terminate_letter);
    HTSprintf(&header, "To: %s\n", to_address);
    if ( strncasecomp(LYCharSet_UC[current_char_set].MIMEname, "us-ascii", 8) )
    {
      HTSACat(&header, "Mime-Version: 1.0\n");
      if ( !LYHaveCJKCharacterSet && strncasecomp(LYCharSet_UC[current_char_set].MIMEname, "x-", 2) )
        HTSprintf(&header, "Content-Type: text/plain; charset=%s\n", LYCharSet_UC[current_char_set].MIMEname);
      HTSACat(&header, "Content-Transfer-Encoding: 8bit\n");
    }
    if ( filename && *filename )
      HTSprintf(&header, "X-URL: %s\n", filename);
    else
      HTSprintf(&header, "X-URL: mailto:%s\n", to_address);
    HTSprintf(&header, "X-Mailer: %s, Version %s\n", "Lynx", "2.8.7dev.11");
    if ( refid && *refid )
      HTSprintf(&header, "In-Reply-To: <%s>\n", refid);
    LYclear();
    LYmove(2, 0);
    scrollok(LYwin, 1);
    if ( body )
    {
      v8 = gettext("You are sending a message with body to:\n  ");
      v9 = strlen(v8);
      v10 = gettext("You are sending a message with body to:\n  ");
    }
    else
    {
      v11 = gettext("You are sending a comment to:\n  ");
      v9 = strlen(v11);
      v10 = gettext("You are sending a comment to:\n  ");
    }
    LYwaddnstr(LYwin, v10, v9);
    show_addresses(to_address);
    cp = ccaddr;
    if ( ccaddr )
    {
      if ( strchr(cp, 44) )
      {
        v12 = gettext("\n With copies to:\n  ");
        v13 = strlen(v12);
        v14 = gettext("\n With copies to:\n  ");
      }
      else
      {
        v15 = gettext("\n With copy to:\n  ");
        v13 = strlen(v15);
        v14 = gettext("\n With copy to:\n  ");
      }
      LYwaddnstr(LYwin, v14, v13);
      show_addresses(ccaddr);
    }
    v16 = gettext("\n\nUse Ctrl-G to cancel if you do not want to send a message\n");
    v17 = strlen(v16);
    v18 = gettext("\n\nUse Ctrl-G to cancel if you do not want to send a message\n");
    LYwaddnstr(LYwin, v18, v17);
    v19 = gettext("\n Please enter your name, or leave it blank to remain anonymous\n");
    v20 = strlen(v19);
    v21 = gettext("\n Please enter your name, or leave it blank to remain anonymous\n");
    LYwaddnstr(LYwin, v21, v20);
    label = "X-Personal_Name: ";
    if ( !header_prompt("X-Personal_Name: ", &personal_name_11174, 0x400u) )
      goto cancelled;
    if ( *personal_name_11174 )
      HTSprintf(&header, "%s: %s\n", label, personal_name_11174);
    v22 = gettext("\n Please enter a mail address or some other\n");
    v23 = strlen(v22);
    v24 = gettext("\n Please enter a mail address or some other\n");
    LYwaddnstr(LYwin, v24, v23);
    v25 = gettext(" means to contact you, if you desire a response.\n");
    v26 = strlen(v25);
    v27 = gettext(" means to contact you, if you desire a response.\n");
    LYwaddnstr(LYwin, v27, v26);
    label = "From";
    if ( personal_mail_address )
      HTSACopy(&from_address, personal_mail_address);
    if ( !header_prompt(label, &from_address, 0x400u) )
      goto cancelled;
    HTSprintf(&header, "%s: %s\n", label, from_address);
    v28 = gettext("\n Please enter a subject line.\n");
    v29 = strlen(v28);
    v30 = gettext("\n Please enter a subject line.\n");
    LYwaddnstr(LYwin, v30, v29);
    label = "Subject";
    if ( default_subject[0] )
    {
      HTSACopy(&the_subject, default_subject);
    }
    else if ( filename && *filename )
    {
      HTSprintf(&the_subject, "%s", filename);
    }
    else
    {
      HTSprintf(&the_subject, "mailto:%s", to_address);
    }
    if ( !header_prompt(label, &the_subject, 0x46u) )
      goto cancelled;
    if ( !LYNoCc )
    {
      v31 = gettext("\n Enter a mail address for a CC of your message.\n");
      v32 = strlen(v31);
      v33 = gettext("\n Enter a mail address for a CC of your message.\n");
      LYwaddnstr(LYwin, v33, v32);
      v34 = gettext(" (Leave blank if you don't want a copy.)\n");
      v35 = strlen(v34);
      v36 = gettext(" (Leave blank if you don't want a copy.)\n");
      LYwaddnstr(LYwin, v36, v35);
      if ( personal_mail_address )
        HTSACopy(&cc_address, personal_mail_address);
      if ( !header_prompt("Cc", &cc_address, 0x400u) )
        goto cancelled;
      comma_append(&ccaddr, cc_address);
    }
    HTSprintf(&header, "%s: %s\n", label, the_subject);
    if ( ccaddr && *ccaddr )
      HTSprintf(&header, "Cc: %s\n", ccaddr);
    if ( keywords && *keywords )
      HTSprintf(&header, "Keywords: %s\n", keywords);
    HTSACat(&header, "\n");
    if ( WWW_TraceFlag[0] )
    {
      v37 = header;
      v38 = TraceFP();
      fprintf(v38, "**header==\n%s", v37);
    }
    if ( no_editor || !editor || !*editor )
    {
      if ( body )
      {
        LYclear();
        LYmove(0, 0);
        v40 = gettext("\n Please review the message body:\n\n");
        v41 = strlen(v40);
        v42 = gettext("\n Please review the message body:\n\n");
        LYwaddnstr(LYwin, v42, v41);
        LYrefresh();
        cp1 = body;
        for ( i = LYlines - 5; ; --i )
        {
          cp = strchr(cp1, 10);
          if ( !cp )
            break;
          if ( i <= 0 )
          {
            v43 = gettext("\nPress RETURN to continue: ");
            v44 = strlen(v43);
            v45 = gettext("\nPress RETURN to continue: ");
            LYwaddnstr(LYwin, v45, v44);
            LYrefresh();
            c = LYgetch();
            LYwaddnstr(LYwin, "\n", 1u);
            if ( term_letter[0] || c == 3 || c == 7 )
              goto cancelled;
            if ( c == -1 )
            {
              if ( keymap[0] == 47 )
                goto cancelled;
            }
            else if ( (c & 0x8800) != 0 )
            {
              if ( (unsigned __int8)c == 47 )
                goto cancelled;
            }
            else if ( keymap[(c & 0x7FF) + 1] == 47 )
            {
              goto cancelled;
            }
            i = LYlines - 2;
          }
          *cp++ = 0;
          fprintf(fd, "%s\n", cp1);
          v46 = strlen(cp1);
          LYwaddnstr(LYwin, cp1, v46);
          LYwaddnstr(LYwin, "\n", 1u);
          cp1 = cp;
        }
        while ( i >= 0 )
        {
          LYwaddnstr(LYwin, "\n", 1u);
          --i;
        }
        LYrefresh();
        LYCloseTempFP(fd);
        scrollok(LYwin, 0);
      }
      else
      {
        v47 = gettext("\n Please enter your message below.");
        v48 = strlen(v47);
        v49 = gettext("\n Please enter your message below.");
        LYwaddnstr(LYwin, v49, v48);
        v50 = gettext("\n When you are done, press enter and put a single period (.)");
        v51 = strlen(v50);
        v52 = gettext("\n When you are done, press enter and put a single period (.)");
        LYwaddnstr(LYwin, v52, v51);
        v53 = gettext("\n on a line and press enter again.");
        v54 = strlen(v53);
        v55 = gettext("\n on a line and press enter again.");
        LYwaddnstr(LYwin, v55, v54);
        LYwaddnstr(LYwin, "\n\n", 2u);
        LYrefresh();
        user_input[0] = 0;
        if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 || term_letter[0] || !strcmp(user_input, ".") )
          goto cancelled;
        while ( strcmp(user_input, ".") && !term_letter[0] )
        {
          LYwaddnstr(LYwin, "\n", 1u);
          remove_tildes(user_input);
          fprintf(fd, "%s\n", user_input);
          user_input[0] = 0;
          if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 )
            goto cancelled;
        }
        fputc(10, fd);
        LYCloseTempFP(fd);
        scrollok(LYwin, 0);
      }
LABEL_144:
      signal(2, (__sighandler_t)1);
      LYStatusLine = LYlines - 1;
      if ( body )
        v70 = gettext("Send this message?");
      else
        v70 = gettext("Send this comment?");
      c = HTConfirm(v70);
      LYStatusLine = -1;
      if ( c == 1 )
      {
        if ( !body )
        {
          if ( LynxSigFile )
          {
            fp = (FILE *)fopen64(LynxSigFile, "r");
            if ( fp )
            {
              LYStatusLine = LYlines - 1;
              if ( term_letter[0] )
              {
                mustshow[0] = 1;
                v56 = LynxSigFile;
                v57 = gettext("Append '%s'?");
                user_message(v57, v56);
                c = 0;
              }
              else
              {
                buffer = 0;
                v58 = LynxSigFile;
                v59 = gettext("Append '%s'?");
                HTSprintf0(&buffer, v59, v58);
                c = HTConfirm(buffer);
                if ( buffer )
                {
                  free(buffer);
                  buffer = 0;
                }
              }
              LYStatusLine = -1;
              if ( c == 1 )
              {
                fd = (FILE *)fopen64(my_tmpfile, "a+");
                if ( fd )
                {
                  buffer = 0;
                  fwrite("-- \n", 1u, 4u, fd);
                  while ( LYSafeGets(&buffer, fp) )
                    fputs(buffer, fd);
                  LYCloseOutput(fd);
                  if ( buffer )
                  {
                    free(buffer);
                    buffer = 0;
                  }
                }
              }
              LYCloseInput(fp);
            }
          }
        }
        LYclear();
        mustshow[0] = 1;
        v60 = gettext("Sending your message...");
        statusline(v60);
        signal(2, (__sighandler_t)1);
        fp = LYPipeToMailer();
        if ( !fp )
        {
          v61 = gettext("Cancelled!!!");
          HTInfoMsg(v61);
        }
        if ( fp )
        {
          fd = (FILE *)fopen64(my_tmpfile, "r");
          if ( fd )
          {
            fputs(header, fp);
            while ( 1 )
            {
              n = fread(buf, 1u, 0x1000u, fd);
              if ( !n )
                break;
              fwrite(buf, 1u, n, fp);
            }
            pclose(fp);
            LYCloseInput(fd);
          }
          else
          {
            v62 = gettext("Cancelled!!!");
            HTInfoMsg(v62);
            pclose(fp);
          }
        }
      }
      else
      {
        LYclear();
      }
      goto cleanup;
    }
    if ( body )
    {
      for ( cp1 = body; ; cp1 = cp )
      {
        cp = strchr(cp1, 10);
        if ( !cp )
          break;
        *cp++ = 0;
        fprintf(fd, "%s\n", cp1);
      }
    }
    else if ( *HTLoadedDocumentURL() )
    {
      v68 = LYPreparsedSource && HTisDocumentSource();
      is_preparsed = v68;
      Msg = v68 ? gettext("Do you wish to include the preparsed source?") : gettext(
                                                                              "Do you wish to include the original message?");
      if ( HTConfirm(Msg) == 1 )
        print_wwwfile_to_fd(fd, 1, is_preparsed == 0);
    }
    LYCloseTempFP(fd);
    scrollok(LYwin, 0);
    if ( term_letter[0] || c == 3 || c == 7 )
      goto cleanup;
    if ( c == -1 )
    {
      if ( keymap[0] != 47 )
        goto LABEL_115;
    }
    else if ( (c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)c != 47 )
        goto LABEL_115;
    }
    else if ( keymap[(c & 0x7FF) + 1] != 47 )
    {
LABEL_115:
      v39 = gettext("Spawning your selected editor to edit mail message");
      edit_temporary_file(my_tmpfile, &position, v39);
      goto LABEL_144;
    }
cleanup:
    signal(2, cleanup_sig);
    term_letter[0] = 0;
    if ( header )
    {
      free(header);
      header = 0;
    }
    LYRemoveTemp(my_tmpfile);
    if ( from_address )
    {
      free(from_address);
      from_address = 0;
    }
    if ( the_subject )
    {
      free(the_subject);
      the_subject = 0;
    }
    if ( cc_address )
    {
      free(cc_address);
      cc_address = 0;
    }
    if ( to_address )
    {
      free(to_address);
      to_address = 0;
    }
    if ( ccaddr )
    {
      free(ccaddr);
      ccaddr = 0;
    }
    if ( keywords )
    {
      free(keywords);
      keywords = 0;
    }
    if ( body )
      free(body);
  }
}
// 8058C5C: conditional instruction was optimized away because %keywords.4!=0
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0805A0F9) --------------------------------------------------------
int LYSystemMail()
{
  char *v0; // eax

  if ( system_mail && strcmp(system_mail, "unknown") )
  {
    return 1;
  }
  else
  {
    v0 = gettext("No system mailer configured");
    HTAlert(v0);
    return 0;
  }
}

//----- (0805A148) --------------------------------------------------------
void __cdecl HTAlert(const char *Msg)
{
  FILE *v1; // edx
  FILE *v2; // eax
  char *v3; // edx
  char *v4; // edx
  char *v5; // edx

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "\nAlert!: %s\n\n", Msg);
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fflush(v2);
  }
  mustshow[0] = 1;
  v3 = gettext("Alert!: %s");
  user_message(v3, Msg);
  v4 = gettext("Alert!: %s");
  LYstore_message2(v4, Msg);
  if ( dump_output_immediately && dump_to_stderr )
  {
    fflush(stdout);
    v5 = gettext("Alert!: %s");
    fprintf(stderr, v5, Msg);
    fputc(10, stderr);
    fflush(stderr);
  }
  LYSleepAlert();
}

//----- (0805A245) --------------------------------------------------------
void __cdecl HTAlwaysAlert(const char *extra_prefix, const char *Msg)
{
  char *v2; // edx
  char *v3; // edx
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *stream; // [esp+14h] [ebp-14h]
  const char *v7; // [esp+18h] [ebp-10h]
  const char *format; // [esp+1Ch] [ebp-Ch]
  FILE *v9; // [esp+20h] [ebp-8h]
  FILE *v10; // [esp+24h] [ebp-4h]

  if ( dump_output_immediately || !LYCursesON[0] )
  {
    if ( extra_prefix )
    {
      if ( WWW_TraceFlag[0] )
        stream = stdout;
      else
        stream = stderr;
      fprintf(stream, "%s %s!\n", extra_prefix, Msg);
      fflush(stdout);
      v2 = gettext("Alert!: %s");
      LYstore_message2(v2, Msg);
      LYSleepAlert();
    }
    else
    {
      if ( Msg )
        v7 = Msg;
      else
        v7 = &byte_814C6F9;
      format = gettext("Alert!: %s");
      if ( WWW_TraceFlag[0] )
        v9 = stdout;
      else
        v9 = stderr;
      fprintf(v9, format, v7);
      fflush(stdout);
      v3 = gettext("Alert!: %s");
      LYstore_message2(v3, Msg);
      LYSleepAlert();
      if ( WWW_TraceFlag[0] )
        v10 = stdout;
      else
        v10 = stderr;
      fputc(10, v10);
    }
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "\nAlert!: %s\n\n", Msg);
    }
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fflush(v5);
    }
  }
  else
  {
    HTAlert(Msg);
  }
}

//----- (0805A3E5) --------------------------------------------------------
void __cdecl HTInfoMsg(const char *Msg)
{
  FILE *v1; // eax

  mustshow[0] = 1;
  statusline(Msg);
  if ( Msg && *Msg )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "Info message: %s\n", Msg);
    }
    LYstore_message(Msg);
    LYSleepInfo();
  }
}

//----- (0805A448) --------------------------------------------------------
void __cdecl HTInfoMsg2(const char *Msg2, const char *Arg)
{
  FILE *v2; // eax
  FILE *v3; // edx
  FILE *v4; // eax

  mustshow[0] = 1;
  user_message(Msg2, Arg);
  if ( Msg2 && *Msg2 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "Info message: ");
    }
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, Msg2, Arg);
    }
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "\n");
    }
    LYstore_message2(Msg2, Arg);
    LYSleepInfo();
  }
}

//----- (0805A506) --------------------------------------------------------
void __cdecl HTUserMsg(const char *Msg)
{
  FILE *v1; // eax

  mustshow[0] = 1;
  statusline(Msg);
  if ( Msg && *Msg )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "User message: %s\n", Msg);
    }
    LYstore_message(Msg);
    LYSleepMsg();
  }
}

//----- (0805A569) --------------------------------------------------------
void __cdecl HTUserMsg2(const char *Msg2, const char *Arg)
{
  FILE *v2; // eax
  FILE *v3; // edx
  FILE *v4; // eax

  mustshow[0] = 1;
  user_message(Msg2, Arg);
  if ( Msg2 && *Msg2 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "User message: ");
    }
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, Msg2, Arg);
    }
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "\n");
    }
    LYstore_message2(Msg2, Arg);
    LYSleepMsg();
  }
}

//----- (0805A627) --------------------------------------------------------
void __cdecl HTProgress(const char *Msg)
{
  FILE *v1; // eax

  statusline(Msg);
  LYstore_message(Msg);
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "%s\n", Msg);
  }
  LYSleepDebug();
}

//----- (0805A673) --------------------------------------------------------
const char *__cdecl HTProgressUnits(int rate)
{
  if ( !bunits_10637 )
  {
    bunits_10637 = gettext("bytes");
    kbunits_10638 = gettext(LYTransferName);
  }
  if ( rate == 2 || rate == 4 )
    return kbunits_10638;
  else
    return bunits_10637;
}

//----- (0805A6C8) --------------------------------------------------------
const char *__cdecl sprint_bytes(char *s, off_t n, const char *was_units)
{
  char *v3; // edx
  const char *u; // [esp+3Ch] [ebp-Ch]

  u = HTProgressUnits(LYTransferRate);
  if ( LYTransferRate == 2 || LYTransferRate == 4 )
  {
    if ( 10 * kb_units_10657 > n )
    {
      if ( n <= 999 )
      {
        sprintf(s, "%lld", n);
        u = HTProgressUnits(1);
      }
      else
      {
        sprintf(s, "%.2g", (double)((long double)n / (long double)kb_units_10657));
      }
    }
    else
    {
      sprintf(s, "%lld", n / kb_units_10657);
    }
  }
  else
  {
    sprintf(s, "%lld", n);
  }
  if ( !was_units || was_units != u )
  {
    v3 = &s[strlen(s)];
    sprintf(v3, " %s", u);
  }
  return u;
}

//----- (0805A869) --------------------------------------------------------
char *__cdecl sprint_tbuf(char *s, int t)
{
  if ( t <= 3600 )
  {
    if ( t <= 60 )
      sprintf(s, "%ld sec", t);
    else
      sprintf(s, "%ldm%lds", t / 60, t % 60);
  }
  else
  {
    sprintf(s, "%ldh%ldm%lds", t / 3600, t / 60 % 60, t % 60);
  }
  return s;
}

//----- (0805AA02) --------------------------------------------------------
void __cdecl HTReadProgress(off_t bytes, off_t total)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // eax
  const char *v10; // ebx
  FILE *v11; // eax
  __int64 bytesa; // [esp+40h] [ebp-138h]
  double now; // [esp+48h] [ebp-130h]
  timeval tv; // [esp+54h] [ebp-124h] BYREF
  const char *was_units; // [esp+5Ch] [ebp-11Ch]
  int renew; // [esp+60h] [ebp-118h]
  char transferp[80]; // [esp+64h] [ebp-114h] BYREF
  char totalp[80]; // [esp+B4h] [ebp-C4h] BYREF
  char bytesp[80]; // [esp+104h] [ebp-74h] BYREF
  char tbuf[16]; // [esp+154h] [ebp-24h] BYREF
  unsigned int v22; // [esp+164h] [ebp-14h]

  bytesa = bytes;
  v22 = __readgsdword(0x14u);
  renew = 0;
  gettimeofday(&tv, 0);
  now = (long double)tv.tv_sec + (long double)tv.tv_usec / 1000000.0;
  if ( !LYShowTransferRate )
    LYTransferRate = 0;
  if ( bytes )
  {
    if ( bytes < 0 )
    {
      bytesa = bytes_last_10712;
      total = total_last_10713;
    }
  }
  else
  {
    last_active_10725 = (long double)tv.tv_sec + (long double)tv.tv_usec / 1000000.0;
    last_10724 = last_active_10725;
    first_10723 = last_active_10725;
    bytes_last_10712 = 0LL;
  }
  if ( bytesa > 0 && now > (long double)first_10723 )
  {
    if ( transfer_rate_10714 <= 0 )
      transfer_rate_10714 = (__int64)((long double)bytesa / (now - first_10723));
    total_last_10713 = total;
    if ( now >= last_10724 + 0.2 )
      renew = 1;
    if ( renew )
    {
      if ( now > (long double)last_10724 )
      {
        last_10724 = (long double)tv.tv_sec + (long double)tv.tv_usec / 1000000.0;
        if ( bytesa != bytes_last_10712 )
          last_active_10725 = (long double)tv.tv_sec + (long double)tv.tv_usec / 1000000.0;
        bytes_last_10712 = bytesa;
        transfer_rate_10714 = (__int64)((long double)bytesa / (now - first_10723));
      }
      if ( total <= 0 )
        was_units = 0;
      else
        was_units = sprint_bytes(totalp, total, 0);
      sprint_bytes(bytesp, bytesa, was_units);
      if ( total <= 0 )
      {
        v3 = gettext("Read %s of data");
        HTSprintf0(&line_10715, v3, bytesp);
      }
      else
      {
        v2 = gettext("Read %s of %s of data");
        HTSprintf0(&line_10715, v2, bytesp, totalp);
      }
      if ( LYTransferRate && transfer_rate_10714 > 0 )
      {
        sprint_bytes(transferp, transfer_rate_10714, 0);
        v4 = gettext(", %s/sec");
        HTSprintf(&line_10715, v4, transferp);
      }
      if ( LYTransferRate == 3 || LYTransferRate == 4 )
      {
        if ( now - last_active_10725 >= 5.0 )
        {
          v5 = sprint_tbuf(tbuf, (int)(now - last_active_10725));
          v6 = gettext(" (stalled for %s)");
          HTSprintf(&line_10715, v6, v5);
        }
        if ( total > 0 && transfer_rate_10714 )
        {
          v7 = sprint_tbuf(tbuf, (total - bytesa) / transfer_rate_10714);
          v8 = gettext(", ETA %s");
          HTSprintf(&line_10715, v8, v7);
        }
      }
      HTSACat(&line_10715, ".");
      if ( total < -1 )
      {
        v9 = gettext(" (Press 'z' to abort)");
        HTSACat(&line_10715, v9);
      }
      statusline(line_10715);
      if ( WWW_TraceFlag[0] )
      {
        v10 = line_10715;
        v11 = TraceFP();
        fprintf(v11, "%s\n", v10);
      }
    }
  }
}

//----- (0805B052) --------------------------------------------------------
int HTLastConfirmCancelled()
{
  if ( conf_cancelled[0] )
  {
    conf_cancelled[0] = 0;
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (0805B07A) --------------------------------------------------------
int __cdecl HTForcedPrompt(int option, const char *msg, int dft)
{
  char *msg2; // [esp+1Ch] [ebp-Ch] BYREF
  const char *show; // [esp+20h] [ebp-8h]
  int result; // [esp+24h] [ebp-4h]

  result = 0;
  show = 0;
  msg2 = 0;
  switch ( option )
  {
    case 0:
      return HTConfirmDefault(msg, dft);
    case 1:
      show = gettext("yes");
      result = 1;
LABEL_8:
      HTSprintf(&msg2, "%s %s", msg, show);
      HTUserMsg(msg2);
      free(msg2);
      return result;
    case 2:
      show = gettext("no");
      result = 0;
      goto LABEL_8;
  }
  return HTConfirmDefault(msg, dft);
}

//----- (0805B14A) --------------------------------------------------------
int __cdecl HTConfirmDefault(const char *Msg, int Dft)
{
  int v2; // esi
  int v3; // ebx
  FILE *v4; // edx
  FILE *v5; // eax
  FILE *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  FILE *v9; // eax
  int v11; // [esp+20h] [ebp-48h]
  int v12; // [esp+24h] [ebp-44h]
  int v13; // [esp+28h] [ebp-40h]
  int v14; // [esp+30h] [ebp-38h]
  int v15; // [esp+34h] [ebp-34h]
  const char *v16; // [esp+38h] [ebp-30h]
  const char *v17; // [esp+3Ch] [ebp-2Ch]
  int c; // [esp+48h] [ebp-20h]
  char *msg; // [esp+4Ch] [ebp-1Ch] BYREF
  int result; // [esp+50h] [ebp-18h]
  const char *msg_no; // [esp+54h] [ebp-14h]
  const char *msg_yes; // [esp+58h] [ebp-10h]
  char fallback_n; // [esp+5Eh] [ebp-Ah]
  char fallback_y; // [esp+5Fh] [ebp-9h]

  msg_yes = gettext("yes");
  msg_no = gettext("no");
  result = -1;
  if ( ((*__ctype_b_loc())[*(unsigned __int8 *)msg_yes] & 0x200) != 0 )
    v11 = toupper(*(unsigned __int8 *)msg_yes);
  else
    v11 = *(unsigned __int8 *)msg_yes;
  if ( ((*__ctype_b_loc())[*(unsigned __int8 *)msg_no] & 0x200) != 0 )
    v12 = toupper(*(unsigned __int8 *)msg_no);
  else
    v12 = *(unsigned __int8 *)msg_no;
  if ( v11 == v12 )
  {
    msg_yes = "yes";
    msg_no = "no";
  }
  conf_cancelled[0] = 0;
  if ( dump_output_immediately )
  {
    if ( Dft == -2 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v2 = *msg_no;
        v3 = *msg_yes;
        v4 = TraceFP();
        fprintf(v4, "Confirm: %s (%c/%c) ", Msg, v3, v2);
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      if ( Dft == 1 )
        v13 = *msg_yes;
      else
        v13 = *msg_no;
      v5 = TraceFP();
      fprintf(v5, "Confirm: %s (%c) ", Msg, v13);
    }
    if ( WWW_TraceFlag[0] )
    {
      v6 = TraceFP();
      fprintf(v6, "- NO, not interactive.\n");
    }
    return 0;
  }
  msg = 0;
  fallback_y = 121;
  fallback_n = 110;
  if ( *msg_yes == 121 || *msg_no == fallback_y )
    fallback_y = 0;
  if ( *msg_yes == fallback_n || *msg_no == fallback_n )
    fallback_n = 0;
  if ( Dft == -2 )
  {
    HTSprintf0(&msg, "%s (%c/%c) ", Msg, *msg_yes, *msg_no);
  }
  else if ( Dft == 1 )
  {
    HTSprintf0(&msg, "%s (%c) ", Msg, *msg_yes);
  }
  else
  {
    HTSprintf0(&msg, "%s (%c) ", Msg, *msg_no);
  }
  if ( LYTraceLogFP && WWW_TraceFlag[0] )
  {
    v7 = msg;
    v8 = TraceFP();
    fprintf(v8, "Confirm: %s", v7);
  }
  mustshow[0] = 1;
  statusline(msg);
  if ( msg )
  {
    free(msg);
    msg = 0;
  }
  while ( result < 0 )
  {
    c = LYgetch_single();
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)msg_yes] & 0x200) != 0 )
      v14 = toupper(*(unsigned __int8 *)msg_yes);
    else
      v14 = *(unsigned __int8 *)msg_yes;
    if ( v14 == c )
    {
      result = 1;
    }
    else
    {
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)msg_no] & 0x200) != 0 )
        v15 = toupper(*(unsigned __int8 *)msg_no);
      else
        v15 = *(unsigned __int8 *)msg_no;
      if ( v15 == c )
      {
        result = 0;
      }
      else if ( fallback_y && fallback_y == c )
      {
        result = 1;
      }
      else if ( fallback_n && fallback_n == c )
      {
        result = 0;
      }
      else
      {
        if ( c == 3 || c == 7 )
          goto LABEL_62;
        if ( c == -1 )
        {
          if ( keymap[0] != 47 )
            goto LABEL_63;
LABEL_62:
          conf_cancelled[0] = 1;
          result = 0;
        }
        else
        {
          if ( (c & 0x8800) != 0 )
          {
            if ( (unsigned __int8)c != 47 )
              goto LABEL_63;
            goto LABEL_62;
          }
          if ( keymap[(c & 0x7FF) + 1] == 47 )
            goto LABEL_62;
LABEL_63:
          if ( Dft != -2 )
          {
            result = Dft;
            break;
          }
        }
      }
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( conf_cancelled[0] )
      v16 = ", cancelled";
    else
      v16 = &byte_814C6F9;
    if ( result )
      v17 = "YES";
    else
      v17 = "NO";
    v9 = TraceFP();
    fprintf(v9, "- %s%s.\n", v17, v16);
  }
  return result;
}

//----- (0805B5FB) --------------------------------------------------------
BOOLEAN __cdecl HTConfirm(const char *Msg)
{
  return HTConfirmDefault(Msg, -2);
}

//----- (0805B616) --------------------------------------------------------
BOOLEAN __cdecl confirm_post_resub(const char *address, const char *title, int if_imgmap, int if_file)
{
  char *v4; // eax
  size_t maxlen; // [esp+20h] [ebp-108h]
  char *temp; // [esp+24h] [ebp-104h]
  char *tempa; // [esp+24h] [ebp-104h]
  char *tempb; // [esp+24h] [ebp-104h]
  char *msg; // [esp+28h] [ebp-100h]
  size_t len1; // [esp+2Ch] [ebp-FCh]
  BOOLEAN res; // [esp+33h] [ebp-F5h]
  BOOLEAN resa; // [esp+33h] [ebp-F5h]
  BOOLEAN resb; // [esp+33h] [ebp-F5h]
  char buf[240]; // [esp+34h] [ebp-F4h] BYREF
  unsigned int v17; // [esp+124h] [ebp-4h]

  v17 = __readgsdword(0x14u);
  msg = gettext("Resubmit POST content to %s ?");
  maxlen = LYcols - (LYShowScrollbar != 0) - 5;
  if ( !address )
    return 0;
  if ( strncasecomp(address, "LYNXIMGMAP:", 11) )
  {
    if ( *address != 102 && *address != 70 || strncasecomp(address, "file:", 5) )
    {
      if ( dump_output_immediately )
        return 0;
      goto LABEL_19;
    }
    if ( if_file <= 0 )
      return 0;
    if ( if_file == 1 )
      return 1;
  }
  else
  {
    if ( if_imgmap <= 0 )
      return 0;
    if ( if_imgmap == 1 )
      return 1;
  }
  msg = gettext("List from document with POST data.  Reload %s ?");
LABEL_19:
  if ( maxlen > 0xEF )
    maxlen = 239;
  len1 = strlen(msg);
  if ( len1 + strlen(address) > maxlen )
  {
    temp = HTParse(address, &byte_814C6F9, 29);
    if ( len1 + strlen(temp) > maxlen )
    {
      if ( temp )
        free(temp);
      if ( title && len1 + strlen(title) <= maxlen )
      {
        sprintf(buf, msg, title);
        return HTConfirm(buf);
      }
      else
      {
        tempa = HTParse(address, &byte_814C6F9, 25);
        if ( len1 + strlen(tempa) > maxlen )
        {
          if ( tempa )
            free(tempa);
          tempb = HTParse(address, &byte_814C6F9, 8);
          if ( tempb && *tempb && len1 + strlen(tempb) <= maxlen )
          {
            sprintf(buf, msg, tempb);
            resb = HTConfirm(buf);
            free(tempb);
            return resb;
          }
          else
          {
            if ( tempb )
              free(tempb);
            v4 = gettext("Document from Form with POST content.  Resubmit?");
            return HTConfirm(v4);
          }
        }
        else
        {
          sprintf(buf, msg, tempa);
          resa = HTConfirm(buf);
          if ( tempa )
            free(tempa);
          return resa;
        }
      }
    }
    else
    {
      sprintf(buf, msg, temp);
      res = HTConfirm(buf);
      if ( temp )
        free(temp);
      return res;
    }
  }
  else
  {
    sprintf(buf, msg, address);
    return HTConfirm(buf);
  }
}
// 805BA89: conditional instruction was optimized away because %temp.4!=0

//----- (0805BB07) --------------------------------------------------------
char *__cdecl HTPrompt(const char *Msg, const char *deflt)
{
  char *rep; // [esp+18h] [ebp-D0h] BYREF
  char Tmp[200]; // [esp+1Ch] [ebp-CCh] BYREF
  unsigned int v5; // [esp+E4h] [ebp-4h]

  v5 = __readgsdword(0x14u);
  rep = 0;
  Tmp[0] = 0;
  Tmp[199] = 0;
  mustshow[0] = 1;
  statusline(Msg);
  if ( deflt )
    strncpy(Tmp, deflt, 0xC7u);
  if ( !dump_output_immediately )
    LYgetstr(Tmp, 0, 0xC8u, NORECALL);
  HTSACopy(&rep, Tmp);
  return rep;
}

//----- (0805BBE2) --------------------------------------------------------
char *__cdecl HTPromptPassword(const char *Msg)
{
  char *v1; // eax
  char *text; // [esp+10h] [ebp-88h]
  char *result; // [esp+18h] [ebp-80h] BYREF
  char pw[120]; // [esp+1Ch] [ebp-7Ch] BYREF
  unsigned int v6; // [esp+94h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  result = 0;
  pw[0] = 0;
  if ( dump_output_immediately )
  {
    v1 = gettext("lynx: Password required!!!");
    printf("\n%s\n", v1);
    HTSACopy(&result, &byte_814C6F9);
  }
  else
  {
    mustshow[0] = 1;
    if ( Msg )
      text = (char *)Msg;
    else
      text = gettext("Password: ");
    statusline(text);
    LYgetstr(pw, 1, 0x78u, NORECALL);
    HTSACopy(&result, pw);
  }
  return result;
}

//----- (0805BCCF) --------------------------------------------------------
void __cdecl HTPromptUsernameAndPassword(const char *Msg, char **username, char **password, BOOLEAN IsProxy)
{
  char *v4; // eax
  char *v5; // edx
  char *v6; // ebx
  char *v7; // eax
  char *v8; // eax
  char *src; // [esp+8h] [ebp-20h]
  char *v10; // [esp+Ch] [ebp-1Ch]
  char *v11; // [esp+10h] [ebp-18h]
  char *v12; // [esp+14h] [ebp-14h]
  char *v13; // [esp+18h] [ebp-10h]
  char *v14; // [esp+1Ch] [ebp-Ch]

  if ( !IsProxy && authentication_info[0] && authentication_info[1]
    || IsProxy == 1 && proxyauth_info[0] && proxyauth_info[1] )
  {
    if ( IsProxy )
      src = proxyauth_info[0];
    else
      src = authentication_info[0];
    HTSACopy(username, src);
    if ( IsProxy )
    {
      if ( proxyauth_info[0] )
      {
        free(proxyauth_info[0]);
        proxyauth_info[0] = 0;
      }
    }
    else if ( authentication_info[0] )
    {
      free(authentication_info[0]);
      authentication_info[0] = 0;
    }
    if ( IsProxy )
      v10 = proxyauth_info[1];
    else
      v10 = authentication_info[1];
    HTSACopy(password, v10);
    if ( IsProxy )
    {
      if ( !proxyauth_info[1] )
        return;
      goto LABEL_20;
    }
    if ( authentication_info[1] )
      goto LABEL_22;
  }
  else if ( dump_output_immediately )
  {
    if ( !IsProxy && authentication_info[0] || IsProxy == 1 && proxyauth_info[0] )
    {
      if ( IsProxy )
        v11 = proxyauth_info[0];
      else
        v11 = authentication_info[0];
      HTSACopy(username, v11);
      if ( IsProxy )
      {
        if ( proxyauth_info[0] )
        {
          free(proxyauth_info[0]);
          proxyauth_info[0] = 0;
        }
      }
      else if ( authentication_info[0] )
      {
        free(authentication_info[0]);
        authentication_info[0] = 0;
      }
    }
    else
    {
      HTSACopy(username, "WWWuser");
    }
    if ( !IsProxy && authentication_info[1] || IsProxy == 1 && proxyauth_info[1] )
    {
      if ( IsProxy )
        v12 = proxyauth_info[1];
      else
        v12 = authentication_info[1];
      HTSACopy(password, v12);
      if ( IsProxy )
      {
        if ( proxyauth_info[1] )
        {
          free(proxyauth_info[1]);
          proxyauth_info[1] = 0;
        }
      }
      else if ( authentication_info[1] )
      {
        free(authentication_info[1]);
        authentication_info[1] = 0;
      }
    }
    else
    {
      HTSACopy(password, &byte_814C6F9);
    }
    v4 = gettext("lynx: Username and Password required!!!");
    printf("\n%s\n", v4);
  }
  else
  {
    if ( !IsProxy && authentication_info[0] || IsProxy == 1 && proxyauth_info[0] )
    {
      if ( IsProxy )
        v13 = proxyauth_info[0];
      else
        v13 = authentication_info[0];
      HTSACopy(username, v13);
      if ( IsProxy )
      {
        if ( proxyauth_info[0] )
        {
          free(proxyauth_info[0]);
          proxyauth_info[0] = 0;
        }
      }
      else if ( authentication_info[0] )
      {
        free(authentication_info[0]);
        authentication_info[0] = 0;
      }
    }
    if ( Msg )
    {
      v5 = HTPrompt(Msg, *username);
    }
    else
    {
      v6 = *username;
      v7 = gettext("Username: ");
      v5 = HTPrompt(v7, v6);
    }
    *username = v5;
    if ( !IsProxy && authentication_info[1] || IsProxy == 1 && proxyauth_info[1] )
    {
      if ( IsProxy )
        v14 = proxyauth_info[1];
      else
        v14 = authentication_info[1];
      HTSACopy(password, v14);
      if ( IsProxy )
      {
        if ( proxyauth_info[1] )
        {
LABEL_20:
          free(proxyauth_info[1]);
          proxyauth_info[1] = 0;
        }
      }
      else if ( authentication_info[1] )
      {
LABEL_22:
        free(authentication_info[1]);
        authentication_info[1] = 0;
      }
    }
    else if ( *username && **username )
    {
      v8 = gettext("Password: ");
      *password = HTPromptPassword(v8);
    }
    else
    {
      HTSACopy(password, &byte_814C6F9);
    }
  }
}

//----- (0805C142) --------------------------------------------------------
BOOLEAN __cdecl HTConfirmCookie(domain_entry *de, const char *server, const char *name, const char *value)
{
  int v4; // ebx
  int v5; // ebx
  FILE *v6; // eax
  int v7; // esi
  int v8; // ebx
  FILE *v9; // eax
  char *v10; // ebx
  char *v11; // eax
  char *v12; // eax
  char *domain; // ebx
  char *v14; // eax
  char *v15; // eax
  int v18; // [esp+38h] [ebp-40h]
  int v19; // [esp+3Ch] [ebp-3Ch]
  char *s; // [esp+4Ch] [ebp-2Ch]
  const char *p; // [esp+50h] [ebp-28h]
  char *message; // [esp+54h] [ebp-24h] BYREF
  int percentage; // [esp+58h] [ebp-20h]
  int space_free; // [esp+5Ch] [ebp-1Ch]
  int valuelen; // [esp+60h] [ebp-18h]
  int namelen; // [esp+64h] [ebp-14h]
  const char *prompt; // [esp+68h] [ebp-10h]
  int ch_0; // [esp+6Ch] [ebp-Ch]

  prompt = gettext("%s cookie: %.*s=%.*s  Allow? (Y/N/Always/neVer)");
  if ( !de )
    return 0;
  if ( de->bv == ACCEPT_ALWAYS )
    return 1;
  if ( de->bv == REJECT_ALWAYS )
    return 0;
  if ( !dump_output_immediately )
  {
    if ( !LYAcceptAllCookies )
    {
      message = 0;
      v4 = LYcols - (LYShowScrollbar != 0);
      v5 = v4 + 10 - LYstrCells(prompt);
      space_free = v5 - strlen(server);
      if ( space_free < 0 )
        space_free = 0;
      namelen = strlen(name);
      valuelen = strlen(value);
      if ( valuelen + namelen > space_free )
      {
        percentage = 100 * space_free / (valuelen + namelen);
        namelen = namelen * percentage / 100;
        valuelen = valuelen * percentage / 100;
      }
      HTSprintf(&message, prompt, server, namelen, name, valuelen, value);
      mustshow[0] = 1;
      statusline(message);
      if ( message )
      {
        free(message);
        message = 0;
      }
    }
    while ( 1 )
    {
      if ( LYAcceptAllCookies )
      {
        ch_0 = 65;
      }
      else
      {
        ch_0 = LYgetch_single();
        gettext("Y/N/A/V");
        s = aYnav;
        if ( !strchr(aYnav, ch_0) && ((*__ctype_b_loc())[ch_0] & 0x400) != 0 )
        {
          p = strrchr(prompt, 40);
          if ( p )
          {
            if ( WWW_TraceFlag[0] )
            {
              v6 = TraceFP();
              fprintf(v6, "Looking for %c in %s\n", ch_0, p);
            }
            while ( *p != 41 && *p && ((*__ctype_b_loc())[(unsigned __int8)*s] & 0x400) != 0 )
            {
              if ( ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x400) != 0 )
              {
                v18 = *p;
                v19 = ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x200) != 0 ? toupper(*(unsigned __int8 *)p) : *(unsigned __int8 *)p;
                if ( v18 == v19 )
                {
                  if ( WWW_TraceFlag[0] )
                  {
                    v7 = *s;
                    v8 = *p;
                    v9 = TraceFP();
                    fprintf(v9, "...testing %c/%c\n", v8, v7);
                  }
                  if ( *p == ch_0 )
                  {
                    ch_0 = *s;
                    break;
                  }
                  ++s;
                }
              }
              ++p;
            }
          }
        }
      }
      if ( ch_0 == 78 )
      {
reject:
        v12 = gettext("Rejecting this cookie.");
        HTUserMsg(v12);
        return 0;
      }
      if ( ch_0 > 78 )
      {
        if ( ch_0 == 86 )
        {
          de->bv = REJECT_ALWAYS;
          domain = de->domain;
          v14 = gettext("ne'V'er allowing from domain '%s'.");
          HTUserMsg2(v14, domain);
          return 0;
        }
        if ( ch_0 == 89 )
        {
          v15 = gettext("Allowing this cookie.");
          HTInfoMsg(v15);
          return 1;
        }
      }
      else if ( ch_0 == 65 )
      {
        de->bv = ACCEPT_ALWAYS;
        v10 = de->domain;
        v11 = gettext("'A'lways allowing from domain '%s'.");
        HTUserMsg2(v11, v10);
        return 1;
      }
      if ( ch_0 == 3 || ch_0 == 7 )
        goto reject;
      if ( ch_0 == -1 )
      {
        if ( keymap[0] == 47 )
          goto reject;
      }
      else if ( (ch_0 & 0x8800) != 0 )
      {
        if ( (unsigned __int8)ch_0 == 47 )
          goto reject;
      }
      else if ( keymap[(ch_0 & 0x7FF) + 1] == 47 )
      {
        goto reject;
      }
    }
  }
  return LYSetCookies;
}

//----- (0805C62D) --------------------------------------------------------
int __cdecl HTConfirmPostRedirect(const char *Redirecting_url, int server_status)
{
  char *v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+14h] [ebp-34h]
  char *v10; // [esp+24h] [ebp-24h]
  int on_screen; // [esp+34h] [ebp-14h]
  char *url; // [esp+38h] [ebp-10h] BYREF
  char *StatusInfo; // [esp+3Ch] [ebp-Ch] BYREF
  char *show_POST_url; // [esp+40h] [ebp-8h] BYREF
  int result; // [esp+44h] [ebp-4h]

  result = -1;
  show_POST_url = 0;
  StatusInfo = 0;
  url = 0;
  on_screen = 0;
  if ( server_status == 303 || server_status == 302 )
    return 303;
  if ( dump_output_immediately )
  {
    if ( server_status == 301 )
      return 303;
    else
      return 0;
  }
  if ( user_mode )
  {
    if ( server_status == 301 )
      v10 = gettext("Redirection of POST content.  P)roceed, see U)RL, use G)ET or C)ancel");
    else
      v10 = gettext("Redirection of POST content.  P)roceed, see U)RL, or C)ancel");
    HTSprintf0(&StatusInfo, "%d %.*s", server_status, 251, v10);
    v6 = gettext("Location: ");
    HTSACopy(&show_POST_url, v6);
    HTSACat(&show_POST_url, Redirecting_url);
  }
  else
  {
    on_screen = 2;
    LYmove(LYlines - 2, 0);
    v2 = gettext("Server asked for %d redirection of POST content to");
    HTSprintf0(&StatusInfo, v2, server_status);
    v3 = strlen(StatusInfo);
    LYwaddnstr(LYwin, StatusInfo, v3);
    LYclrtoeol();
    LYmove(LYlines - 1, 0);
    if ( LYcols > 249 )
      HTSprintf0(&url, "URL: %.*s", 250, Redirecting_url);
    else
      HTSprintf0(&url, "URL: %.*s", LYcols - (LYShowScrollbar != 0) - 5, Redirecting_url);
    v4 = strlen(url);
    LYwaddnstr(LYwin, url, v4);
    LYclrtoeol();
    mustshow[0] = 1;
    if ( server_status == 301 )
      v5 = gettext("P)roceed, use G)ET or C)ancel ");
    else
      v5 = gettext("P)roceed, or C)ancel ");
    statusline(v5);
  }
  while ( result < 0 )
  {
    if ( on_screen )
    {
      if ( on_screen == 1 )
      {
        mustshow[0] = 1;
        statusline(show_POST_url);
      }
    }
    else
    {
      mustshow[0] = 1;
      statusline(StatusInfo);
    }
    v8 = LYgetch_single();
    if ( v8 == 71 )
    {
      if ( server_status != 301 )
        goto LABEL_45;
      if ( show_POST_url )
      {
        free(show_POST_url);
        show_POST_url = 0;
      }
      result = 303;
    }
    else if ( v8 > 71 )
    {
      if ( v8 == 80 )
      {
        if ( show_POST_url )
        {
          free(show_POST_url);
          show_POST_url = 0;
        }
        result = 1;
      }
      else
      {
        if ( v8 != 85 )
          goto LABEL_45;
        if ( user_mode )
          on_screen = on_screen != 1;
      }
    }
    else if ( v8 == 7 || v8 == 67 )
    {
      if ( show_POST_url )
      {
        free(show_POST_url);
        show_POST_url = 0;
      }
      result = 0;
    }
    else
    {
LABEL_45:
      if ( on_screen == 1 )
        on_screen = 0;
      else
        on_screen = 2;
    }
  }
  if ( StatusInfo )
  {
    free(StatusInfo);
    StatusInfo = 0;
  }
  if ( url )
  {
    free(url);
    url = 0;
  }
  return result;
}

//----- (0805C9E8) --------------------------------------------------------
void LYSleepAlert()
{
  if ( !crawl && !traversal )
  {
    if ( LYCursesON[0] )
      napms(AlertSecs);
  }
}

//----- (0805CA1E) --------------------------------------------------------
void LYSleepDebug()
{
  if ( !crawl && !traversal )
  {
    if ( LYCursesON[0] )
      napms(DebugSecs);
  }
}

//----- (0805CA54) --------------------------------------------------------
void LYSleepInfo()
{
  if ( !crawl && !traversal )
  {
    if ( LYCursesON[0] )
      napms(InfoSecs);
  }
}

//----- (0805CA8A) --------------------------------------------------------
void LYSleepMsg()
{
  if ( !crawl && !traversal )
  {
    if ( LYCursesON[0] )
      napms(MessageSecs);
  }
}

//----- (0805CAC0) --------------------------------------------------------
void LYSleepReplay()
{
  if ( !crawl && !traversal )
  {
    if ( LYCursesON[0] )
      napms(ReplaySecs);
  }
}

//----- (0805CAF8) --------------------------------------------------------
pool_data *__cdecl ALLOC_IN_POOL(HTPool **ppoolptr, unsigned int request)
{
  HTPool *newpool; // [esp+14h] [ebp-14h]
  unsigned int n; // [esp+1Ch] [ebp-Ch]
  unsigned int na; // [esp+1Ch] [ebp-Ch]
  pool_data *ptr; // [esp+20h] [ebp-8h]
  HTPool *pool; // [esp+24h] [ebp-4h]

  pool = *ppoolptr;
  if ( !*ppoolptr )
    return 0;
  n = request;
  if ( !request )
    n = 1;
  if ( (n & 7) != 0 )
    n = n - (n & 7) + 8;
  na = n >> 2;
  if ( na + pool->used > 0x7FA )
  {
    newpool = (HTPool *)LY_check_calloc(1u, 0x1FF0u);
    if ( newpool )
    {
      newpool->prev = pool;
      newpool->used = na;
      ptr = (pool_data *)newpool;
      *ppoolptr = newpool;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    ptr = &pool->data[pool->used];
    pool->used += na;
  }
  return ptr;
}

//----- (0805CBE3) --------------------------------------------------------
HTPool *POOL_NEW()
{
  HTPool *poolptr; // [esp+14h] [ebp-4h]

  poolptr = (HTPool *)LY_check_calloc(1u, 0x1FF0u);
  if ( poolptr )
  {
    poolptr->prev = 0;
    poolptr->used = 0;
  }
  return poolptr;
}

//----- (0805CC25) --------------------------------------------------------
void __cdecl POOL_FREE(HTPool *poolptr)
{
  _HTPool *prev; // [esp+10h] [ebp-8h]

  while ( poolptr )
  {
    prev = poolptr->prev;
    free(poolptr);
    poolptr = prev;
  }
}

//----- (0805CC58) --------------------------------------------------------
void *__cdecl HText_pool_calloc(HText *text, unsigned int size)
{
  return ALLOC_IN_POOL(&text->pool, size);
}

//----- (0805CC78) --------------------------------------------------------
void ht_justify_cleanup()
{
  int v0; // [esp+0h] [ebp-4h]

  if ( ok_justify && !psrc_view )
    v0 = -1;
  else
    v0 = 30002;
  wait_for_this_stacked_elt = v0;
  can_justify_here[0] = 1;
  can_justify_this_line[0] = 1;
  form_in_htext = 0;
  last_anchor_of_previous_line = 0;
  this_line_was_split[0] = 0;
  in_DT[0] = 0;
  have_raw_nbsps[0] = 0;
}

//----- (0805CCE2) --------------------------------------------------------
void __cdecl mark_justify_start_position(void *text)
{
  if ( text )
  {
    if ( *((_DWORD *)text + 1) )
      justify_start_position = *(unsigned __int16 *)(*((_DWORD *)text + 1) + 10);
  }
}

//----- (0805CD09) --------------------------------------------------------
void HText_halt()
{
  if ( HTFormNumber > 0 )
    HText_DisableCurrentForm();
  if ( HTMainText )
  {
    if ( HTMainText->halted <= 1 )
      HTMainText->halted = 2;
  }
}

//----- (0805CD47) --------------------------------------------------------
BOOLEAN __cdecl mem_is_avail(size_t factor, size_t bytes)
{
  void *p; // [esp+14h] [ebp-4h]

  if ( bytes <= 0x1387 && factor )
    bytes = 5000;
  if ( !factor )
    factor = 1;
  p = malloc(bytes * factor);
  if ( !p )
    return 0;
  free(p);
  return 1;
}

//----- (0805CDB0) --------------------------------------------------------
void *__cdecl LY_check_calloc(size_t nmemb, size_t size)
{
  FILE *v2; // edx
  char *v3; // eax
  char *v4; // eax
  const char *v6; // [esp+1Ch] [ebp-1Ch]
  const char *address; // [esp+20h] [ebp-18h]
  HText *t; // [esp+28h] [ebp-10h]
  int n; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  if ( !mem_is_avail(4u, size * nmemb) )
  {
    n = HTList_count(loaded_texts);
    for ( i = n - 1; i > 0; --i )
    {
      t = (HText *)HTList_objectAt(loaded_texts, i);
      if ( WWW_TraceFlag[0] )
      {
        if ( t && t->node_anchor && t->node_anchor->post_data )
          v6 = " with POST data";
        else
          v6 = &byte_814CBAC;
        if ( t && t->node_anchor && t->node_anchor->address )
          address = t->node_anchor->address;
        else
          address = "unknown anchor";
        v2 = TraceFP();
        fprintf(v2, "\nBUG *** Emergency freeing document %d/%d for '%s'%s!\n", i + 1, n, address, v6);
      }
      HTList_removeObjectAt(loaded_texts, i);
      HText_free(t);
      if ( mem_is_avail(4u, size * nmemb) )
        return calloc(nmemb, size);
    }
    LYFakeZap(1);
    if ( !HTMainText || HTMainText->halted <= 1 )
    {
      if ( mem_is_avail(2u, size * nmemb) )
      {
        if ( !HTMainText || !HTMainText->halted )
        {
          if ( mem_is_avail(0, 0x2BCu) )
          {
            v4 = gettext("Memory exhausted, will interrupt transfer!");
            HTAlert(v4);
            if ( HTMainText )
              HTMainText->halted = 1;
          }
        }
      }
      else
      {
        HText_halt();
        if ( mem_is_avail(0, 0x2BCu) )
        {
          v3 = gettext("Memory exhausted, display interrupted!");
          HTAlert(v3);
        }
      }
    }
  }
  return calloc(nmemb, size);
}

//----- (0805D017) --------------------------------------------------------
int __cdecl StyleToCols(HText *text, HTLine *line, int nstyle)
{
  size_t v3; // eax
  int utf_extra; // [esp+24h] [ebp-14h]
  char *last; // [esp+28h] [ebp-10h]
  const char *data; // [esp+2Ch] [ebp-Ch]
  int nchars; // [esp+30h] [ebp-8h]
  int result; // [esp+34h] [ebp-4h]

  result = line->offset;
  nchars = *(_WORD *)&line->styles[nstyle] >> 2;
  data = line->data;
  last = &line->data[line->size];
  while ( nchars > 0 && data < last )
  {
    if ( *data <= 2 || *data >= 8 )
    {
      v3 = utf8_length(text->T.output_utf8, data);
      utf_extra = v3 + 1;
      if ( v3 )
      {
        result += LYstrExtent(data, utf_extra, 2);
        data += utf_extra;
      }
      else if ( HTCJK && *data < 0 )
      {
        data += 2;
        result += 2;
      }
      else
      {
        ++data;
        ++result;
      }
      --nchars;
    }
    else
    {
      ++data;
    }
  }
  return result;
}

//----- (0805D11B) --------------------------------------------------------
void __cdecl LYClearHiText(TextAnchor *a)
{
  if ( a->lites.hl_info )
  {
    free(a->lites.hl_info);
    a->lites.hl_info = 0;
  }
  a->lites.hl_base.hl_text = 0;
  a->lites.hl_len = 0;
}

//----- (0805D158) --------------------------------------------------------
void __cdecl LYSetHiText(TextAnchor *a, const char *text, int len)
{
  if ( text )
  {
    a->lites.hl_base.hl_text = (char *)ALLOC_IN_POOL(&HTMainText->pool, len + 2);
    memcpy(a->lites.hl_base.hl_text, text, len);
    a->lites.hl_base.hl_text[len] = 0;
    a->lites.hl_len = 1;
  }
}

//----- (0805D1C0) --------------------------------------------------------
void __cdecl LYAddHiText(TextAnchor *a, const char *text, int x)
{
  size_t v3; // eax
  unsigned int want; // [esp+18h] [ebp-10h]
  unsigned int need; // [esp+1Ch] [ebp-Ch]
  HiliteInfo *have; // [esp+20h] [ebp-8h]
  HiliteInfo *havea; // [esp+20h] [ebp-8h]

  have = a->lites.hl_info;
  need = a->lites.hl_len++ - 1;
  want = 8 * a->lites.hl_len;
  if ( have )
    havea = (HiliteInfo *)realloc(have, want);
  else
    havea = (HiliteInfo *)malloc(want);
  a->lites.hl_info = havea;
  v3 = strlen(text);
  havea[need].hl_text = (char *)ALLOC_IN_POOL(&HTMainText->pool, v3 + 2);
  strcpy(havea[need].hl_text, text);
  havea[need].hl_x = x;
}

//----- (0805D296) --------------------------------------------------------
int __cdecl LYAdjHiTextPos(TextAnchor *a, int count)
{
  char *result; // [esp+14h] [ebp-4h]

  if ( a->lites.hl_len > count )
  {
    if ( count <= 0 )
      result = a->lites.hl_base.hl_text;
    else
      result = a->lites.hl_info[-(1 - count)].hl_text;
  }
  else
  {
    result = 0;
  }
  if ( result )
    return LYSkipBlanks(result) - result;
  else
    return 0;
}

//----- (0805D30B) --------------------------------------------------------
char *__cdecl LYGetHiTextStr(TextAnchor *a, int count)
{
  char *result; // [esp+14h] [ebp-4h]

  if ( a->lites.hl_len > count )
  {
    if ( count <= 0 )
      result = a->lites.hl_base.hl_text;
    else
      result = a->lites.hl_info[-(1 - count)].hl_text;
  }
  else
  {
    result = 0;
  }
  return &result[LYAdjHiTextPos(a, count)];
}

//----- (0805D36F) --------------------------------------------------------
int __cdecl LYGetHiTextPos(TextAnchor *a, int count)
{
  int result; // [esp+14h] [ebp-4h]

  if ( a->lites.hl_len > count )
  {
    if ( count <= 0 )
      result = a->line_pos;
    else
      result = a->lites.hl_info[-(1 - count)].hl_x;
  }
  else
  {
    result = -1;
  }
  return LYAdjHiTextPos(a, count) + result;
}

//----- (0805D3D8) --------------------------------------------------------
void __cdecl LYCopyHiText(TextAnchor *a, TextAnchor *b)
{
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+8h] [ebp-20h]
  const char *s; // [esp+20h] [ebp-8h]
  int count; // [esp+24h] [ebp-4h]

  LYClearHiText(a);
  for ( count = 0; ; ++count )
  {
    s = LYGetHiTextStr(b, count);
    if ( !s )
      break;
    if ( count )
    {
      v3 = LYGetHiTextPos(b, count);
      LYAddHiText(a, s, v3);
    }
    else
    {
      v2 = strlen(s);
      LYSetHiText(a, s, v2);
    }
  }
}

//----- (0805D464) --------------------------------------------------------
void __cdecl HText_getChartransInfo(HText *me)
{
  me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 3);
  if ( me->UCLYhndl < 0 )
  {
    HTAnchor_setUCInfoStage(me->node_anchor, current_char_set, 3, 3);
    me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 3);
  }
  me->UCI = HTAnchor_getUCInfoStage(me->node_anchor, 3);
}

//----- (0805D505) --------------------------------------------------------
void __cdecl PerFormInfo_free(PerFormInfo *form)
{
  if ( form )
  {
    if ( form->accept_cs )
    {
      free(form->accept_cs);
      form->accept_cs = 0;
    }
    if ( form->thisacceptcs )
    {
      free(form->thisacceptcs);
      form->thisacceptcs = 0;
    }
    free(form);
  }
}
// 805D559: conditional instruction was optimized away because %form.4!=0

//----- (0805D56F) --------------------------------------------------------
void __cdecl free_form_fields(FormInfo *input_field)
{
  OptionType *tmp; // [esp+10h] [ebp-8h]
  OptionType *optptr; // [esp+14h] [ebp-4h]

  if ( input_field->type == 7 && input_field->select_list )
  {
    optptr = input_field->select_list;
    while ( optptr )
    {
      tmp = optptr;
      optptr = optptr->next;
      if ( tmp->name )
      {
        free(tmp->name);
        tmp->name = 0;
      }
      if ( tmp->cp_submit_value )
      {
        free(tmp->cp_submit_value);
        tmp->cp_submit_value = 0;
      }
      free(tmp);
    }
    input_field->select_list = 0;
    input_field->value = 0;
    input_field->orig_value = 0;
    input_field->cp_submit_value = 0;
    input_field->orig_submit_value = 0;
  }
  else
  {
    if ( input_field->value )
    {
      free(input_field->value);
      input_field->value = 0;
    }
    if ( input_field->orig_value )
    {
      free(input_field->orig_value);
      input_field->orig_value = 0;
    }
    if ( input_field->cp_submit_value )
    {
      free(input_field->cp_submit_value);
      input_field->cp_submit_value = 0;
    }
    if ( input_field->orig_submit_value )
    {
      free(input_field->orig_submit_value);
      input_field->orig_submit_value = 0;
    }
  }
  if ( input_field->name )
  {
    free(input_field->name);
    input_field->name = 0;
  }
  if ( input_field->submit_action )
  {
    free(input_field->submit_action);
    input_field->submit_action = 0;
  }
  if ( input_field->submit_enctype )
  {
    free(input_field->submit_enctype);
    input_field->submit_enctype = 0;
  }
  if ( input_field->submit_title )
  {
    free(input_field->submit_title);
    input_field->submit_title = 0;
  }
  if ( input_field->accept_cs )
  {
    free(input_field->accept_cs);
    input_field->accept_cs = 0;
  }
}
// 805D5F1: conditional instruction was optimized away because %tmp.4!=0

//----- (0805D773) --------------------------------------------------------
void __cdecl FormList_delete(HTList *forms)
{
  PerFormInfo *object; // [esp+4h] [ebp-14h]
  HTList *cur; // [esp+14h] [ebp-4h]

  cur = forms;
  while ( 1 )
  {
    if ( cur && (cur = cur->next) != 0 )
      object = (PerFormInfo *)cur->object;
    else
      object = 0;
    if ( !object )
      break;
    PerFormInfo_free(object);
  }
  HTList_delete(forms);
}

//----- (0805D7CB) --------------------------------------------------------
void __cdecl ResetPartialLinenos(HText *text)
{
  if ( text )
  {
    text->first_lineno_last_disp_partial = -1;
    text->last_lineno_last_disp_partial = -1;
  }
}

//----- (0805D7F0) --------------------------------------------------------
HText *__cdecl HText_new(HTParentAnchor *anchor)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  HText *v4; // eax
  LYUCcharset *UCInfoStage; // edx
  __int16 v8; // [esp+22h] [ebp-26h]
  bool v9; // [esp+24h] [ebp-24h]
  bool v10; // [esp+2Bh] [ebp-1Dh]
  bool v11; // [esp+2Ch] [ebp-1Ch]
  HText *self; // [esp+38h] [ebp-10h]
  HTLine *line; // [esp+3Ch] [ebp-Ch]

  self = (HText *)calloc(1u, 0x904u);
  if ( !self )
    return 0;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "GridText: start HText_new\n");
  }
  if ( HTMainText )
  {
    if ( HText_hasUTF8OutputSet(HTMainText)
      && (unsigned __int8)HTLoadedDocumentEightbit()
      && LYCharSet_UC[current_char_set].enc == 7 )
    {
      self->had_utf8 = HTMainText->has_utf8;
    }
    else
    {
      self->had_utf8 = HTMainText->has_utf8;
    }
    HTMainText->has_utf8 = 0;
  }
  if ( !loaded_texts )
    loaded_texts = HTList_new();
  if ( anchor->document )
  {
    HTList_removeObject(loaded_texts, anchor->document);
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "GridText: Auto-uncaching\n");
    }
    HTAnchor_delete_links(anchor);
    *(_DWORD *)anchor->document = 0;
    HText_free((HText *)anchor->document);
    anchor->document = 0;
  }
  HTList_addObject(loaded_texts, self);
  if ( HTList_count(loaded_texts) > HTCacheSize )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "GridText: Freeing off cached doc.\n");
    }
    v4 = (HText *)HTList_removeFirstObject(loaded_texts);
    HText_free(v4);
  }
  self->pool = POOL_NEW();
  if ( !self->pool )
    outofmem("./GridText.c", "HText_New");
  self->last_line = &self->temp_line[0].base;
  line = self->last_line;
  line->prev = line;
  line->next = line->prev;
  line->size = 0;
  line->offset = line->size;
  line->data[line->size] = 0;
  line->numstyles = 0;
  line->styles = stylechanges_buffers[0];
  self->Lines = 0;
  self->last_anchor = 0;
  self->first_anchor = self->last_anchor;
  self->last_anchor_before_split = 0;
  self->style = &default_style;
  self->top_of_screen = 0;
  self->node_anchor = anchor;
  self->last_anchor_number = 0;
  self->stale = 1;
  self->toolbar = 0;
  self->tabs = 0;
  self->clickable_images = clickable_images;
  self->pseudo_inline_alts = pseudo_inline_alts;
  self->verbose_img = verbose_img;
  self->raw_mode = LYUseDefaultRawMode;
  self->historical_comments = historical_comments;
  self->minimal_comments = minimal_comments;
  self->soft_dquotes = soft_dquotes;
  self->old_dtd = Old_DTD;
  self->keypad_mode = keypad_mode;
  self->disp_lines = LYlines;
  if ( LYwideLines )
    v8 = 1014;
  else
    v8 = LYcols;
  self->disp_cols = v8;
  if ( anchor->bookmark
    || LYIsUIPage3(anchor->address, UIP_LIST_PAGE_0, 0)
    || LYIsUIPage3(anchor->address, UIP_ADDRLIST_PAGE_0, 0) )
  {
    self->hiddenlinkflag = 0;
  }
  else
  {
    self->hiddenlinkflag = LYHiddenLinks;
  }
  self->hidden_links = 0;
  v9 = anchor->no_cache || anchor->post_data;
  self->no_cache = v9;
  self->LastChar = 0;
  self->IgnoreExcess = 0;
  if ( LYpsrc )
  {
    v11 = mark_htext_as_source || psrc_view;
    v10 = v11;
  }
  else
  {
    v10 = HTOutputFormat == WWW_SOURCE;
  }
  self->source = v10;
  mark_htext_as_source = 0;
  HTAnchor_setDocument(anchor, (HyperDoc *)self);
  HTFormNumber = 0;
  HTMainText = self;
  HTMainAnchor = anchor;
  self->display_on_the_fly = 0;
  self->kcode = NOKANJI;
  self->specified_kcode = NOKANJI;
  self->detected_kcode = DET_NOTYET;
  self->SJIS_status = SJIS_state_neutral;
  self->EUC_status = EUC_state_neutral;
  self->state = S_text;
  self->kanji_buf = 0;
  self->in_sjis = 0;
  self->have_8bit_chars = 0;
  HText_getChartransInfo(self);
  UCSetTransParams(&self->T, self->UCLYhndl, self->UCI, current_char_set, &LYCharSet_UC[current_char_set]);
  UCInfoStage = HTAnchor_getUCInfoStage(anchor, 3);
  HText_setKcode(self, anchor->charset, UCInfoStage);
  if ( underscore_string[0] != 46 )
  {
    memset(underscore_string, 46, 0x3FFu);
    underscore_string[1023] = 0;
    underscore_string[1024] = 0;
    memset(star_string, 95, 0x3FFu);
    star_string[1023] = 0;
    star_string[1024] = 0;
  }
  underline_on = 0;
  bold_on = 0;
  if ( display_partial_flag )
  {
    display_partial[0] = 1;
    NumOfLines_partial = 0;
  }
  ResetPartialLinenos(self);
  ht_justify_cleanup();
  return self;
}

//----- (0805DE7F) --------------------------------------------------------
HText *__cdecl HText_new2(HTParentAnchor *anchor, HTStream *stream)
{
  HText *result; // [esp+14h] [ebp-4h]

  result = HText_new(anchor);
  if ( stream )
  {
    result->target = stream;
    result->targetClass = *stream->isa;
  }
  return result;
}

//----- (0805DEE7) --------------------------------------------------------
void __cdecl HText_free(HText *self)
{
  void **object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]
  TextAnchor *l; // [esp+24h] [ebp-4h]

  if ( self )
  {
    while ( self->first_anchor )
    {
      l = self->first_anchor;
      self->first_anchor = l->next;
      if ( l->link_type == 2 && l->input_field )
        free_form_fields(l->input_field);
      if ( l->lites.hl_info )
      {
        free(l->lites.hl_info);
        l->lites.hl_info = 0;
      }
    }
    FormList_delete(self->forms);
    if ( self->tabs )
    {
      cur = self->tabs;
      while ( 1 )
      {
        if ( cur && (cur = cur->next) != 0 )
          object = (void **)cur->object;
        else
          object = 0;
        if ( !object )
          break;
        if ( *object )
        {
          free(*object);
          *object = 0;
        }
        free(object);
      }
      HTList_delete(self->tabs);
      self->tabs = 0;
    }
    if ( self->hidden_links )
    {
      LYFreeStringList(self->hidden_links);
      self->hidden_links = 0;
    }
    if ( self->node_anchor )
    {
      HTAnchor_resetUCInfoStage(self->node_anchor, -1, 2, 0);
      HTAnchor_resetUCInfoStage(self->node_anchor, -1, 3, 0);
      HTAnchor_clearSourceCache(self->node_anchor);
      HTAnchor_delete_links(self->node_anchor);
      HTAnchor_setDocument(self->node_anchor, 0);
      if ( HTAnchor_delete(self->node_anchor->parent) )
        HTMainAnchor = 0;
    }
    POOL_FREE(self->pool);
    free(self);
  }
}
// 805E106: conditional instruction was optimized away because %self.4!=0
// 805DFBF: conditional instruction was optimized away because %var_14.4!=0

//----- (0805E11C) --------------------------------------------------------
int __cdecl display_line(HTLine *line, HText *text, int scrline, const char *target)
{
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  int v8; // [esp+10h] [ebp-48h]
  int v9; // [esp+14h] [ebp-44h]
  int v10; // [esp+1Ch] [ebp-3Ch]
  int v11; // [esp+20h] [ebp-38h]
  int v12; // [esp+24h] [ebp-34h]
  int v13; // [esp+28h] [ebp-30h]
  int v14; // [esp+2Ch] [ebp-2Ch]
  int i; // [esp+30h] [ebp-28h]
  int ia; // [esp+30h] [ebp-28h]
  int j; // [esp+34h] [ebp-24h]
  char buffer[7]; // [esp+39h] [ebp-1Fh] BYREF
  int x; // [esp+40h] [ebp-18h]
  int y; // [esp+44h] [ebp-14h]
  int current_style; // [esp+48h] [ebp-10h]
  size_t utf_extra; // [esp+4Ch] [ebp-Ch]
  char *data; // [esp+50h] [ebp-8h]
  char LastDisplayChar; // [esp+57h] [ebp-1h]

  utf_extra = 0;
  LastDisplayChar = 32;
  current_style = 0;
  LYmove(scrline, 0);
  buffer[2] = 0;
  buffer[1] = 0;
  buffer[0] = 0;
  LYclrtoeol();
  j = line->offset;
  if ( LYwideLines )
    v8 = 1014;
  else
    v8 = LYcols;
  if ( v8 <= j )
  {
    if ( LYwideLines )
      v9 = 1013;
    else
      v9 = LYcols - 1;
    j = v9;
  }
  if ( line->size )
  {
    for ( i = 0; i < j; ++i )
      waddch(LYwin, 0x20u);
  }
  else
  {
    i = j;
  }
  data = line->data;
  ia = i + 1;
  while ( 1 )
  {
    v14 = LYwideLines ? 1014 : LYcols;
    if ( v14 < ia )
      break;
    buffer[0] = *data;
    if ( !buffer[0] )
      break;
    ++data;
    while ( line->numstyles > current_style && (*(_WORD *)&line->styles[current_style] >> 2) + line->offset + 1 <= ia )
    {
      curses_style(*((unsigned __int16 *)&line->styles[current_style] + 1), *(_BYTE *)&line->styles[current_style] & 3);
      ++current_style;
    }
    if ( buffer[0] == 7 )
    {
      if ( !*data && ((*__ctype_b_loc())[(unsigned __int8)LastDisplayChar] & 0x2000) == 0 && LastDisplayChar != 45 )
      {
        buffer[0] = 45;
        goto LABEL_27;
      }
    }
    else if ( buffer[0] == 8 )
    {
      if ( !dump_output_immediately )
      {
        waddch(LYwin, 0x2Bu);
        ++ia;
      }
    }
    else
    {
LABEL_27:
      if ( text->T.output_utf8 && buffer[0] < 0 )
      {
        text->has_utf8 = 1;
        utf_extra = utf8_length(text->T.output_utf8, data - 1);
        LastDisplayChar = 77;
      }
      if ( utf_extra )
      {
        strncpy(&buffer[1], data, utf_extra);
        buffer[utf_extra + 1] = 0;
        v4 = strlen(buffer);
        LYwaddnstr(LYwin, buffer, v4);
        buffer[1] = 0;
        data += utf_extra;
        utf_extra = 0;
        goto LABEL_51;
      }
      if ( HTCJK == NOCJK || buffer[0] >= 0 )
      {
        v6 = strlen(buffer);
        LYwaddnstr(LYwin, buffer, v6);
        LastDisplayChar = buffer[0];
        goto LABEL_51;
      }
      if ( LYwideLines )
        v10 = 1014;
      else
        v10 = LYcols;
      if ( v10 < ia )
        goto LABEL_51;
      buffer[1] = *data;
      buffer[2] = 0;
      ++data;
      ++ia;
      v5 = strlen(buffer);
      LYwaddnstr(LYwin, buffer, v5);
      buffer[1] = 0;
      LastDisplayChar = 77;
      v11 = LYwin ? LYwin->_cury : -1;
      y = v11;
      v12 = LYwin ? LYwin->_curx : -1;
      x = v12;
      v13 = LYwideLines ? 1014 : LYcols;
      if ( v13 > x && x )
LABEL_51:
        ++ia;
    }
  }
  waddch(LYwin, 0xAu);
  while ( line->numstyles > current_style )
  {
    curses_style(*((unsigned __int16 *)&line->styles[current_style] + 1), *(_BYTE *)&line->styles[current_style] & 3);
    ++current_style;
  }
  return 0;
}

//----- (0805E577) --------------------------------------------------------
void __cdecl display_title(HText *text)
{
  size_t v1; // eax
  int v2; // ebx
  size_t v3; // ebx
  int v4; // ebx
  char *v5; // ebx
  int v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  char *src; // [esp+20h] [ebp-58h]
  int v10; // [esp+24h] [ebp-54h]
  int v11; // [esp+28h] [ebp-50h]
  chtype v12; // [esp+2Ch] [ebp-4Ch]
  int limit; // [esp+44h] [ebp-34h]
  int toolbar; // [esp+48h] [ebp-30h]
  int j; // [esp+4Ch] [ebp-2Ch]
  int i; // [esp+50h] [ebp-28h]
  int ia; // [esp+50h] [ebp-28h]
  signed int ib; // [esp+50h] [ebp-28h]
  unsigned __int8 *tmp; // [esp+54h] [ebp-24h]
  char *title; // [esp+58h] [ebp-20h] BYREF
  char percent[20]; // [esp+5Ch] [ebp-1Ch] BYREF
  unsigned int v22; // [esp+70h] [ebp-8h]

  v22 = __readgsdword(0x14u);
  title = 0;
  toolbar = 0;
  if ( text )
  {
    lynx_start_title_color();
    if ( last_colorattr_ptr <= 0 )
      curses_style(s_title, 2);
    else
      curses_style(s_title, 1);
    if ( HTAnchor_title(text->node_anchor) )
      src = (char *)HTAnchor_title(text->node_anchor);
    else
      src = " ";
    HTSACopy(&title, src);
    LYReduceBlanks(title);
    limit = LYscreenWidth();
    if ( limit > 9 )
    {
      if ( display_lines > 0 || LYlines <= 0 || text->top_of_screen > 99999 || text->Lines > 999999 )
      {
        if ( text->Lines < display_lines || display_lines <= 0 )
        {
          percent[0] = 0;
        }
        else
        {
          if ( text->Lines <= display_lines )
            v10 = 0;
          else
            v10 = text->Lines - display_lines;
          if ( text->top_of_screen > v10 )
            v11 = (display_lines + text->Lines) / display_lines;
          else
            v11 = (display_lines + text->top_of_screen) / display_lines;
          sprintf(percent, " (p%d of %d)", v11, (display_lines + text->Lines) / display_lines);
        }
      }
      else
      {
        sprintf(percent, " (l%d of %d)", text->top_of_screen, text->Lines);
      }
    }
    else
    {
      percent[0] = 0;
    }
    if ( HTCJK )
    {
      if ( *title )
      {
        v1 = strlen(title);
        tmp = (unsigned __int8 *)calloc(2 * (v1 + 128), 1u);
        if ( tmp )
        {
          if ( kanji_code == EUC )
          {
            TO_EUC((const unsigned __int8 *)title, tmp);
          }
          else if ( kanji_code == SJIS )
          {
            TO_SJIS((const unsigned __int8 *)title, tmp);
          }
          else
          {
            i = 0;
            j = 0;
            while ( title[i] )
            {
              if ( title[i] != 27 )
                tmp[j++] = title[i];
              ++i;
            }
            tmp[j] = 0;
          }
          HTSACopy(&title, (const char *)tmp);
          free(tmp);
        }
      }
    }
    LYmove(0, 0);
    LYclrtoeol();
    if ( HText_hasToolbar(text) )
    {
      waddch(LYwin, 0x23u);
      toolbar = 1;
    }
    if ( s_forw_backw != -1 && (nhist || nhist_extra > 1) )
    {
      if ( nhist )
        v12 = dword_81AABD0;
      else
        v12 = 32;
      curses_style(s_forw_backw, 1);
      if ( nhist )
      {
        waddch(LYwin, v12);
        waddch(LYwin, v12);
        waddch(LYwin, v12);
      }
      else
      {
        LYmove(0, toolbar + 3);
      }
      if ( nhist_extra > 1 )
      {
        waddch(LYwin, dword_81AABCC);
        waddch(LYwin, dword_81AABCC);
        waddch(LYwin, dword_81AABCC);
      }
      curses_style(s_forw_backw, 0);
    }
    v2 = limit - (LYShowScrollbar != 0);
    v3 = v2 - strlen(percent);
    ia = v3 - LYstrCells(title);
    if ( ia <= 0 )
    {
      v4 = limit - (LYShowScrollbar != 0);
      ib = v4 - strlen(percent) - 3;
      if ( ib > 0 )
      {
        v5 = title;
        v6 = LYstrExtent2(title, ib);
        memcpy(&v5[v6], "...", 4u);
      }
      else
      {
        *title = 0;
      }
      ia = 0;
    }
    LYmove(0, ia);
    v7 = strlen(title);
    LYwaddnstr(LYwin, title, v7);
    if ( percent[0] )
    {
      v8 = strlen(percent);
      LYwaddnstr(LYwin, percent, v8);
    }
    waddch(LYwin, 0xAu);
    if ( title )
    {
      free(title);
      title = 0;
    }
    if ( s_hot_paste != -1 )
    {
      LYmove(0, LYcols - (LYShowScrollbar != 0));
      curses_style(s_hot_paste, 1);
      waddch(LYwin, dword_81AABCC);
      curses_style(s_hot_paste, 0);
      LYmove(1, 0);
    }
    curses_style(s_title, 0);
    lynx_stop_title_color();
  }
}
// 805E891: conditional instruction was optimized away because %tmp.4!=0

//----- (0805EC06) --------------------------------------------------------
void __cdecl display_scrollbar(HText *text)
{
  int v1; // [esp+14h] [ebp-44h]
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int shown; // [esp+38h] [ebp-20h]
  int sh; // [esp+3Ch] [ebp-1Ch]
  int top_skip; // [esp+44h] [ebp-14h]
  int off; // [esp+48h] [ebp-10h]
  int h; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]

  if ( LYsb_arrow )
    v1 = 2;
  else
    v1 = 0;
  h = display_lines - v1;
  off = LYsb_arrow != 0;
  LYsb_end = -1;
  LYsb_begin = -1;
  if ( LYShowScrollbar && text && h > 2 && text->Lines > display_lines )
  {
    if ( text->top_of_screen < text->Lines - display_lines )
    {
      shown = display_lines;
    }
    else
    {
      shown = text->Lines - text->top_of_screen;
      if ( shown <= 0 )
        shown = 1;
    }
    sh = (text->Lines / 2 + h * shown) / text->Lines;
    if ( sh <= 0 )
      sh = 1;
    if ( h - 1 <= sh )
      sh = h - 2;
    if ( text->top_of_screen )
    {
      if ( text->Lines + 1 - (display_lines + text->top_of_screen) > 0 )
        top_skip = (int)((long double)(h - sh - 1)
                       * (long double)text->top_of_screen
                       / (long double)(text->Lines - display_lines + 1)
                       + 1.0);
      else
        top_skip = h - sh;
    }
    else
    {
      top_skip = 0;
    }
    LYsb_begin = top_skip;
    LYsb_end = top_skip + sh;
    if ( LYsb_arrow )
    {
      if ( top_skip )
        v2 = s_sb_aa;
      else
        v2 = s_sb_naa;
      if ( last_colorattr_ptr <= 0 )
        curses_style(v2, 2);
      else
        curses_style(v2, 1);
      LYmove(1, LYcols - (LYShowScrollbar != 0) + LYshiftWin);
      waddch(LYwin, dword_81AABD4);
      curses_style(v2, 0);
    }
    if ( last_colorattr_ptr <= 0 )
      curses_style(s_sb_bg, 2);
    else
      curses_style(s_sb_bg, 1);
    for ( i = 1; i <= h; ++i )
    {
      if ( i - 1 <= top_skip && i > top_skip )
        curses_style(s_sb_bar, 1);
      if ( i - 1 <= top_skip + sh && top_skip + sh < i )
        curses_style(s_sb_bar, 0);
      LYmove(off + i, LYcols - (LYShowScrollbar != 0) + LYshiftWin);
      if ( i <= top_skip || top_skip + sh < i )
        waddch(LYwin, dword_81AACA4);
      else
        waddch(LYwin, dword_81AABE0);
    }
    curses_style(s_sb_bg, 0);
    if ( LYsb_arrow )
    {
      if ( h - sh == top_skip )
        v3 = s_sb_naa;
      else
        v3 = s_sb_aa;
      if ( last_colorattr_ptr <= 0 )
        curses_style(v3, 2);
      else
        curses_style(v3, 1);
      LYmove(h + 2, LYshiftWin + LYcols - (LYShowScrollbar != 0));
      waddch(LYwin, dword_81AABD8);
      curses_style(v3, 0);
    }
  }
}

//----- (0805F0D2) --------------------------------------------------------
void __cdecl display_page(HText *text, int line_number, const char *target)
{
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  int v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  FILE *v9; // eax
  int cury; // [esp+18h] [ebp-90h]
  int curx; // [esp+1Ch] [ebp-8Ch]
  const char *v12; // [esp+20h] [ebp-88h]
  int v13; // [esp+28h] [ebp-80h]
  char *v14; // [esp+2Ch] [ebp-7Ch]
  char *v15; // [esp+30h] [ebp-78h]
  char *v16; // [esp+34h] [ebp-74h]
  char tmp[7]; // [esp+41h] [ebp-67h] BYREF
  char *cp_AnchorAddress; // [esp+48h] [ebp-60h]
  char *s; // [esp+4Ch] [ebp-5Ch]
  int count; // [esp+50h] [ebp-58h]
  char *hi_string; // [esp+54h] [ebp-54h]
  int y; // [esp+58h] [ebp-50h]
  size_t utf_extra; // [esp+5Ch] [ebp-4Ch]
  int len; // [esp+60h] [ebp-48h]
  int x_pos; // [esp+64h] [ebp-44h]
  int written; // [esp+68h] [ebp-40h]
  int itmp; // [esp+6Ch] [ebp-3Ch]
  int LenNeeded; // [esp+70h] [ebp-38h] BYREF
  int offset; // [esp+74h] [ebp-34h]
  char *data; // [esp+78h] [ebp-30h]
  int last_disp_partial; // [esp+7Ch] [ebp-2Ch]
  HTAnchor *link_dest_intl; // [esp+80h] [ebp-28h]
  HTAnchor *link_dest; // [esp+84h] [ebp-24h]
  FormInfo *FormInfo_ptr; // [esp+88h] [ebp-20h]
  int stop_before_for_anchors; // [esp+8Ch] [ebp-1Ch]
  TextAnchor *Anchor_ptr; // [esp+90h] [ebp-18h]
  const char *cp; // [esp+94h] [ebp-14h]
  int title_lines; // [esp+98h] [ebp-10h]
  int i; // [esp+9Ch] [ebp-Ch]
  HTLine *line; // [esp+A0h] [ebp-8h]
  BOOLEAN display_flag; // [esp+A7h] [ebp-1h]
  int line_numbera; // [esp+B4h] [ebp+Ch]

  line = 0;
  title_lines = 1;
  Anchor_ptr = 0;
  display_flag = 0;
  link_dest_intl = 0;
  last_disp_partial = -1;
  lynx_mode = 1;
  if ( text )
  {
    if ( display_partial[0] || recent_sizechange || text->stale )
      ResetPartialLinenos(text);
    tmp[2] = 0;
    tmp[1] = 0;
    tmp[0] = 0;
    if ( target && !*target )
      target = 0;
    text->page_has_target = 0;
    if ( display_lines > 0 )
    {
      line = text->last_line->prev;
      line_numbera = HText_getPreferredTopLine(text, line_number);
      i = 0;
      for ( line = text->last_line->next; i < line_numbera && text->last_line != line; line = line->next )
      {
        if ( LYNoCore )
        {
          if ( !line->next )
          {
            if ( enable_scrollback )
            {
              waddch(LYwin, 0x2Au);
              LYrefresh();
              LYclear();
            }
            LYwaddnstr(LYwin, "\n\nError drawing page!\nBad HText structure!\n", 0x2Bu);
            LYrefresh();
            nlinks = 0;
            return;
          }
        }
        else if ( !line->next )
        {
          __assert_fail("line->next != ((void *)0)", "./GridText.c", 0x7E0u, "display_page");
        }
        ++i;
      }
      if ( LYlowest_eightbit[current_char_set] <= 255
        && current_char_set != charset_last_displayed_12722
        && LYCursesON[0] )
      {
        charset_last_displayed_12722 = current_char_set;
      }
      if ( enable_scrollback )
      {
        waddch(LYwin, 0x2Au);
        LYrefresh();
        LYclear();
      }
      if ( text->stale || text->top_of_screen + display_lines != line_numbera )
        last_colorattr_ptr = 0;
      text->top_of_screen = line_numbera;
      text->top_of_screen_line = line;
      if ( no_title )
      {
        LYmove(0, 0);
        title_lines = 0;
      }
      else
      {
        display_title(text);
      }
      display_flag = 1;
      if ( display_partial[0]
        || text->first_lineno_last_disp_partial != line_numbera
        || text->last_lineno_last_disp_partial < line_numbera )
      {
        ResetCachedStyles();
      }
      if ( display_partial[0] && text->stbl )
      {
        stop_before_for_anchors = Stbl_getStartLineDeep(text->stbl);
        if ( line_numbera + display_lines < stop_before_for_anchors )
          stop_before_for_anchors = line_numbera + display_lines;
      }
      else
      {
        stop_before_for_anchors = line_numbera + display_lines;
      }
      if ( line )
      {
        if ( display_partial[0] || text->first_lineno_last_disp_partial != line_numbera )
          text->has_utf8 = 0;
        for ( i = 0; i < display_lines; ++i )
        {
          if ( LYNoCore )
          {
            if ( !line )
            {
              if ( enable_scrollback )
              {
                waddch(LYwin, 0x2Au);
                LYrefresh();
                LYclear();
              }
              LYwaddnstr(LYwin, "\n\nError drawing page!\nBad HText structure!\n", 0x2Bu);
              LYrefresh();
              nlinks = 0;
              return;
            }
          }
          else if ( !line )
          {
            __assert_fail("line != ((void *)0)", "./GridText.c", 0x848u, "display_page");
          }
          if ( display_partial[0]
            || text->first_lineno_last_disp_partial != line_numbera
            || i + line_numbera > text->last_lineno_last_disp_partial )
          {
            display_line(line, text, i + 1, target);
          }
          else
          {
            LYmove(title_lines + i + 1, 0);
          }
          data = line->data;
          offset = line->offset;
          while ( target && *target )
          {
            v12 = case_sensitive ? LYno_attr_mbcs_strstr(data, target, text->T.output_utf8, 1, 0, &LenNeeded) : LYno_attr_mbcs_case_strstr(data, target, text->T.output_utf8, 1, 0, &LenNeeded);
            cp = v12;
            if ( !v12 )
              break;
            v13 = LYwideLines ? 1014 : LYcols;
            if ( LenNeeded + line->offset > v13 )
              break;
            itmp = 0;
            written = 0;
            x_pos = offset + cp - data;
            len = strlen(target);
            utf_extra = 0;
            text->page_has_target = 1;
            LYstartTargetEmphasis();
            while ( written < len )
            {
              tmp[0] = data[itmp];
              if ( !tmp[0] )
                break;
              if ( tmp[0] <= 2 || tmp[0] >= 8 )
              {
                if ( &data[itmp] >= cp )
                {
                  if ( &data[itmp] == cp )
                    LYmove(i + title_lines, x_pos);
                  utf_extra = utf8_length(text->T.output_utf8, &data[itmp]);
                  if ( utf_extra )
                  {
                    strncpy(&tmp[1], &line->data[itmp + 1], utf_extra);
                    tmp[utf_extra + 1] = 0;
                    itmp += utf_extra;
                    v3 = strlen(tmp);
                    LYwaddnstr(LYwin, tmp, v3);
                    tmp[1] = 0;
                    written += utf_extra + 1;
                    utf_extra = 0;
                  }
                  else if ( HTCJK && tmp[0] < 0 )
                  {
                    tmp[1] = data[++itmp];
                    v4 = strlen(tmp);
                    LYwaddnstr(LYwin, tmp, v4);
                    tmp[1] = 0;
                    written += 2;
                  }
                  else
                  {
                    v5 = strlen(tmp);
                    LYwaddnstr(LYwin, tmp, v5);
                    ++written;
                  }
                }
              }
              else
              {
                --x_pos;
              }
              ++itmp;
            }
            LYstopTargetEmphasis();
            if ( LYwin )
              cury = LYwin->_cury;
            else
              cury = -1;
            y = cury;
            if ( LYwin )
              curx = LYwin->_curx;
            else
              curx = -1;
            offset = curx;
            data += itmp;
            LYmove(title_lines + i + 1, 0);
          }
          if ( text->last_line == line )
          {
            ++i;
            while ( i < display_lines )
            {
              LYmove(i + title_lines, 0);
              LYclrtoeol();
              ++i;
            }
            break;
          }
          if ( display_partial[0] )
            last_disp_partial = i + line_numbera;
          display_flag = 1;
          line = line->next;
        }
      }
      text->next_line = line;
      text->stale = 0;
      nlinks = 0;
      for ( Anchor_ptr = text->first_anchor;
            Anchor_ptr && Anchor_ptr->line_num <= stop_before_for_anchors;
            Anchor_ptr = Anchor_ptr->next )
      {
        if ( Anchor_ptr->line_num >= line_numbera && Anchor_ptr->line_num < stop_before_for_anchors )
        {
          hi_string = LYGetHiTextStr(Anchor_ptr, 0);
          if ( Anchor_ptr->show_anchor && hi_string && *hi_string && (Anchor_ptr->link_type & 1) != 0 )
          {
            for ( count = 0; ; ++count )
            {
              s = LYGetHiTextStr(Anchor_ptr, count);
              if ( !count )
                LYSetHilite(nlinks, s);
              if ( !s )
                break;
              if ( count )
              {
                v6 = LYGetHiTextPos(Anchor_ptr, count);
                LYAddHilite(nlinks, s, v6);
              }
            }
            links[nlinks].inUnderline = Anchor_ptr->inUnderline;
            links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
            links[nlinks].anchor_number = Anchor_ptr->number;
            links[nlinks].anchor_line_num = Anchor_ptr->line_num;
            link_dest = HTAnchor_followLink(Anchor_ptr->anchor);
            cp_AnchorAddress = 0;
            if ( traversal )
              cp_AnchorAddress = stub_HTAnchor_address(link_dest);
            else
              cp_AnchorAddress = HTAnchor_address(link_dest);
            if ( links[nlinks].lname )
            {
              free(links[nlinks].lname);
              links[nlinks].lname = 0;
            }
            if ( cp_AnchorAddress )
              links[nlinks].lname = cp_AnchorAddress;
            else
              HTSACopy((char **)(68 * nlinks + 136026784), empty_string);
            links[nlinks].lx = Anchor_ptr->line_pos;
            links[nlinks].ly = Anchor_ptr->line_num + 1 - line_numbera;
            if ( link_dest_intl )
              links[nlinks].type = 6;
            else
              links[nlinks].type = 2;
            links[nlinks].target = empty_string;
            links[nlinks++].l_form = 0;
            display_flag = 1;
          }
          else if ( Anchor_ptr->link_type != 2 || Anchor_ptr->input_field->type == 8 )
          {
            if ( hi_string && *hi_string && WWW_TraceFlag[0] )
            {
              v7 = TraceFP();
              fprintf(v7, "\nGridText: Not showing link, hightext=%s\n", hi_string);
            }
          }
          else
          {
            lynx_mode = 2;
            FormInfo_ptr = Anchor_ptr->input_field;
            links[nlinks].sgml_offset = Anchor_ptr->sgml_offset;
            links[nlinks].anchor_number = Anchor_ptr->number;
            links[nlinks].anchor_line_num = Anchor_ptr->line_num;
            links[nlinks].l_form = FormInfo_ptr;
            links[nlinks].lx = Anchor_ptr->line_pos;
            links[nlinks].ly = Anchor_ptr->line_num + 1 - line_numbera;
            links[nlinks].type = 1;
            links[nlinks].inUnderline = Anchor_ptr->inUnderline;
            links[nlinks].target = empty_string;
            HTSACopy((char **)(68 * nlinks + 136026784), empty_string);
            switch ( FormInfo_ptr->type )
            {
              case 4:
                if ( FormInfo_ptr->num_value )
                  v14 = (char *)checked_radio;
                else
                  v14 = (char *)unchecked_radio;
                LYSetHilite(nlinks, v14);
                break;
              case 3:
                if ( FormInfo_ptr->num_value )
                  v15 = (char *)checked_box;
                else
                  v15 = (char *)unchecked_box;
                LYSetHilite(nlinks, v15);
                break;
              case 2:
                if ( LYstrCells(FormInfo_ptr->value) > 1023 )
                  v16 = star_string;
                else
                  v16 = (char *)(1023 - LYstrCells(FormInfo_ptr->value) + 136025696);
                LYSetHilite(nlinks, v16);
                break;
              default:
                LYSetHilite(nlinks, FormInfo_ptr->value);
                break;
            }
            LYhighlight(0, nlinks++, target);
            display_flag = 1;
          }
        }
        if ( nlinks == 1024 )
        {
          if ( LYCursesON[0] )
          {
            v8 = gettext("Maximum links per page exceeded!  Use half-page or two-line scrolling.");
            HTAlert(v8);
          }
          if ( WWW_TraceFlag[0] )
          {
            v9 = TraceFP();
            fprintf(v9, "\ndisplay_page: MAXLINKS reached.\n");
          }
          break;
        }
      }
      LYFreeHilites(nlinks, last_nlinks_12721);
      last_nlinks_12721 = nlinks;
      more_links = 0;
      if ( traversal && Anchor_ptr && Anchor_ptr->next )
        more_links = 1;
      if ( !display_flag )
        LYwaddnstr(LYwin, "\n     Document is empty", 0x17u);
      display_scrollbar(text);
      if ( !display_partial[0]
        || !display_flag
        || text->top_of_screen > last_disp_partial
        || enable_scrollback
        || recent_sizechange )
      {
        ResetPartialLinenos(text);
      }
      else
      {
        text->first_lineno_last_disp_partial = text->top_of_screen;
        text->last_lineno_last_disp_partial = last_disp_partial;
      }
      LYrefresh();
    }
  }
  else
  {
    if ( enable_scrollback )
    {
      waddch(LYwin, 0x2Au);
      LYrefresh();
      LYclear();
    }
    LYwaddnstr(LYwin, "\n\nError accessing document!\nNo data available!\n", 0x2Fu);
    LYrefresh();
    nlinks = 0;
  }
}

//----- (08060085) --------------------------------------------------------
void __cdecl HText_beginAppend(HText *text)
{
  text->permissible_split = 0;
  text->in_line_1 = 1;
}

//----- (080600A1) --------------------------------------------------------
int __cdecl set_style_by_embedded_chars(char *s, char *e, unsigned __int8 start_c, unsigned __int8 end_c)
{
  int ret; // [esp+14h] [ebp-4h]

  ret = 0;
  while ( --e >= s && *e != end_c )
  {
    if ( *e == start_c )
      return 1;
  }
  return ret;
}

//----- (080600F8) --------------------------------------------------------
void __cdecl move_anchors_in_region(
        HTLine *line,
        int line_number,
        TextAnchor **prev_anchor,
        int *prev_head_processed,
        int sbyte,
        int ebyte,
        int shift)
{
  int v7; // [esp+4h] [ebp-14h]
  int last; // [esp+Ch] [ebp-Ch]
  int head_processed; // [esp+10h] [ebp-8h]
  TextAnchor *a; // [esp+14h] [ebp-4h]

  head_processed = *prev_head_processed;
  a = *prev_anchor;
  while ( a && a->line_num <= line_number )
  {
    if ( a->extent )
      v7 = a->extent - 1;
    else
      v7 = 0;
    last = v7 + a->line_pos;
    if ( a->line_num >= line_number - 1 )
    {
      if ( a->line_num == line_number - 1 )
        last += ~line->prev->size;
      if ( last >= sbyte )
      {
        if ( !head_processed && a->line_num == line_number && a->line_pos >= ebyte )
          break;
        if ( !head_processed && a->line_num == line_number && a->line_pos >= sbyte )
        {
          a->line_pos += shift;
          a->extent -= shift;
          head_processed = 1;
        }
        if ( last >= ebyte )
          break;
        a->extent += shift;
      }
    }
    a = a->next;
    head_processed = 0;
  }
  *prev_anchor = a;
  *prev_head_processed = head_processed;
}

//----- (0806025D) --------------------------------------------------------
HTLine *__cdecl insert_blanks_in_line(
        HTLine *line,
        int line_number,
        HText *text,
        TextAnchor **prev_anchor,
        int ninserts,
        int *oldpos,
        int *newpos)
{
  unsigned int v7; // eax
  int v11; // [esp+2Ch] [ebp-4Ch]
  int v12; // [esp+30h] [ebp-48h]
  int v13; // [esp+34h] [ebp-44h]
  int delta; // [esp+40h] [ebp-38h]
  char *t; // [esp+48h] [ebp-30h]
  char *copied; // [esp+4Ch] [ebp-2Ch]
  char *pre; // [esp+50h] [ebp-28h]
  char *s; // [esp+54h] [ebp-24h]
  char *newdata; // [esp+58h] [ebp-20h]
  HTLineTemp *mod_line; // [esp+5Ch] [ebp-1Ch]
  int head_processed; // [esp+60h] [ebp-18h] BYREF
  int shift; // [esp+64h] [ebp-14h]
  int added_chars; // [esp+68h] [ebp-10h]
  int istyle; // [esp+6Ch] [ebp-Ch]
  int ip_0; // [esp+70h] [ebp-8h]
  int ioldc; // [esp+74h] [ebp-4h]

  ioldc = 0;
  istyle = 0;
  added_chars = 0;
  shift = 0;
  s = line->data;
  pre = line->data;
  copied = line->data;
  if ( !line || !line->size || !ninserts )
    return 0;
  for ( ip_0 = 0; ip_0 < ninserts; ++ip_0 )
  {
    if ( newpos[ip_0] > oldpos[ip_0] && newpos[ip_0] - oldpos[ip_0] > added_chars )
      added_chars = newpos[ip_0] - oldpos[ip_0];
  }
  if ( added_chars + line->size > 1022 )
    return 0;
  if ( text->last_line == line )
  {
    if ( text->temp_line == (HTLineTemp *)line )
      mod_line = &text->temp_line[1];
    else
      mod_line = text->temp_line;
  }
  else
  {
    mod_line = (HTLineTemp *)ALLOC_IN_POOL(&HTMainText->pool, added_chars + line->size + 20);
  }
  if ( !mod_line )
    return 0;
  if ( !*prev_anchor )
    *prev_anchor = text->first_anchor;
  v11 = *prev_anchor && (*prev_anchor)->line_num < line_number;
  head_processed = v11;
  memcpy(mod_line, line, 0x14u);
  newdata = mod_line->base.data;
  t = mod_line->base.data;
  for ( ip_0 = 0; ip_0 <= ninserts; ++ip_0 )
  {
    if ( ip_0 >= ninserts )
    {
      if ( line->size <= 0x400u )
        v13 = 1025;
      else
        v13 = line->size + 1;
      v12 = v13;
    }
    else
    {
      v12 = oldpos[ip_0];
    }
    pre = s;
    while ( *s )
    {
      if ( text && text->T.output_utf8 && *s < 0 && (unsigned __int8)*s <= 0xBFu )
      {
        pre = s + 1;
      }
      else if ( *s <= 2 || *s > 8 )
      {
        if ( ioldc >= v12 )
          break;
        ++ioldc;
        pre = s + 1;
      }
      ++s;
    }
    if ( ip_0 )
      move_anchors_in_region(
        line,
        line_number,
        prev_anchor,
        &head_processed,
        copied - line->data,
        pre - line->data,
        shift);
    while ( line->numstyles > istyle && *(_WORD *)&mod_line->base.styles[istyle] >> 2 < v12 )
    {
      *(_WORD *)&mod_line->base.styles[istyle] = (4
                                                * (((*(_WORD *)&mod_line->base.styles[istyle] >> 2) + shift) & 0x3FFF)) | *(_WORD *)&mod_line->base.styles[istyle] & 3;
      ++istyle;
    }
    while ( copied < pre )
      *t++ = *copied++;
    if ( ip_0 < ninserts )
    {
      delta = newpos[ip_0] - oldpos[ip_0] - shift;
      if ( delta >= 0 )
      {
        shift = newpos[ip_0] - oldpos[ip_0];
      }
      else
      {
        while ( 1 )
        {
          v7 = (unsigned int)delta++ >> 31;
          if ( (unsigned __int8)v7 != 1 || t <= newdata || *(t - 1) != 32 )
            break;
          --t;
          --shift;
        }
      }
      while ( delta-- > 0 )
        *t++ = 32;
    }
  }
  while ( pre < s )
    *t++ = *pre++;
  if ( head_processed && *prev_anchor && (*prev_anchor)->line_num == line_number )
    (*prev_anchor)->extent += shift;
  *t = 0;
  mod_line->base.size = (_WORD)t - (_WORD)newdata;
  return &mod_line->base;
}

//----- (080606F2) --------------------------------------------------------
HTStyleChange *__cdecl skip_matched_and_correct_offsets(
        HTStyleChange *end,
        HTStyleChange *start,
        unsigned int split_pos)
{
  HTStyleChange *tmp; // [esp+Ch] [ebp-8h]
  int level; // [esp+10h] [ebp-4h]

  level = 0;
  for ( tmp = end; tmp >= start; --tmp )
  {
    if ( *((_WORD *)tmp + 1) == *((_WORD *)end + 1) )
    {
      if ( (*(_BYTE *)tmp & 3) != 0 )
      {
        if ( (*(_BYTE *)tmp & 3) != 1 )
          return 0;
        if ( !++level )
          return tmp;
      }
      else
      {
        --level;
      }
    }
    if ( *(_WORD *)tmp >> 2 > split_pos )
      *(_WORD *)tmp = (4 * (split_pos & 0x3FFF)) | *(_WORD *)tmp & 3;
  }
  return 0;
}

//----- (080607A2) --------------------------------------------------------
void __cdecl split_line(HText *text, unsigned int split)
{
  int size; // ebx
  FILE *v3; // edx
  FILE *v4; // eax
  unsigned __int16 v5; // cx
  unsigned __int16 v6; // cx
  FILE *v7; // edx
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  int v11; // ebx
  FILE *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  int extent; // esi
  int line_pos; // edi
  int line_num; // ebx
  FILE *v19; // edx
  FILE *v20; // eax
  FILE *v21; // eax
  int v22; // esi
  int v23; // edi
  int v24; // ebx
  FILE *v25; // eax
  int v26; // ebx
  FILE *v27; // eax
  HTCoord indent1st; // [esp+3Ch] [ebp-10Ch]
  int v29; // [esp+40h] [ebp-108h]
  __int16 v30; // [esp+46h] [ebp-102h]
  int v31; // [esp+48h] [ebp-100h]
  int v32; // [esp+4Ch] [ebp-FCh]
  int v33; // [esp+50h] [ebp-F8h]
  int v34; // [esp+54h] [ebp-F4h]
  int v35; // [esp+5Ch] [ebp-ECh]
  int v36; // [esp+60h] [ebp-E8h]
  int v37; // [esp+64h] [ebp-E4h]
  char v38; // [esp+6Bh] [ebp-DDh]
  unsigned int i_1; // [esp+74h] [ebp-D4h]
  unsigned int i_1a; // [esp+74h] [ebp-D4h]
  char *p2_0; // [esp+78h] [ebp-D0h]
  char *p2; // [esp+7Ch] [ebp-CCh]
  int delta; // [esp+80h] [ebp-C8h]
  int i_0; // [esp+84h] [ebp-C4h]
  int *newpos; // [esp+88h] [ebp-C0h]
  int *oldpos; // [esp+8Ch] [ebp-BCh]
  int utf_extra; // [esp+90h] [ebp-B8h]
  HTLine *jline; // [esp+94h] [ebp-B4h]
  int r_a; // [esp+98h] [ebp-B0h]
  int r_; // [esp+98h] [ebp-B0h]
  int d_; // [esp+9Ch] [ebp-ACh]
  int total_cell_len; // [esp+A0h] [ebp-A8h]
  int total_byte_len; // [esp+A4h] [ebp-A4h]
  ht_run_info *r; // [esp+A8h] [ebp-A0h]
  char *jp; // [esp+ACh] [ebp-9Ch]
  int end; // [esp+B0h] [ebp-98h]
  int start; // [esp+B4h] [ebp-94h]
  int n_0; // [esp+B8h] [ebp-90h]
  int len; // [esp+BCh] [ebp-8Ch]
  int moved; // [esp+C0h] [ebp-88h]
  HTLine *temp; // [esp+C4h] [ebp-84h]
  int n; // [esp+C8h] [ebp-80h]
  HTStyleChange *at_end; // [esp+CCh] [ebp-7Ch]
  HTStyleChange *scan; // [esp+D0h] [ebp-78h]
  HTStyleChange *to; // [esp+D4h] [ebp-74h]
  HTStyleChange *from; // [esp+D8h] [ebp-70h]
  int i; // [esp+DCh] [ebp-6Ch]
  unsigned int plen; // [esp+E0h] [ebp-68h]
  HTLineTemp *line; // [esp+ECh] [ebp-5Ch]
  HTLine *previous; // [esp+F0h] [ebp-58h]
  HTLine *previousa; // [esp+F0h] [ebp-58h]
  int ctrl_chars_on_previous_line; // [esp+F4h] [ebp-54h]
  char *cp; // [esp+F8h] [ebp-50h]
  char *cpa; // [esp+F8h] [ebp-50h]
  char *cpb; // [esp+F8h] [ebp-50h]
  char *p; // [esp+FCh] [ebp-4Ch]
  char *pa; // [esp+FCh] [ebp-4Ch]
  int t_bold; // [esp+100h] [ebp-48h]
  int t_underline; // [esp+104h] [ebp-44h]
  signed int s_pre; // [esp+108h] [ebp-40h]
  int s_post; // [esp+10Ch] [ebp-3Ch]
  signed int s; // [esp+110h] [ebp-38h]
  int TailTrim; // [esp+114h] [ebp-34h]
  unsigned int SpecialAttrChars; // [esp+118h] [ebp-30h]
  int HeadTrim; // [esp+11Ch] [ebp-2Ch]
  int CurLine; // [esp+120h] [ebp-28h]
  TextAnchor *a; // [esp+124h] [ebp-24h]
  int new_offset; // [esp+128h] [ebp-20h]
  int new_offseta; // [esp+128h] [ebp-20h]
  int spare; // [esp+130h] [ebp-18h]
  HTStyle *style; // [esp+134h] [ebp-14h]
  __int16 alignment; // [esp+138h] [ebp-10h]
  char c; // [esp+13Bh] [ebp-Dh]

  style = text->style;
  if ( text->in_line_1 )
    indent1st = text->style->indent1st;
  else
    indent1st = text->style->leftIndent;
  CurLine = text->Lines;
  HeadTrim = 0;
  SpecialAttrChars = 0;
  t_underline = underline_on;
  t_bold = bold_on;
  ctrl_chars_on_previous_line = 0;
  previous = text->last_line;
  if ( text->temp_line == (HTLineTemp *)previous )
    line = &text->temp_line[1];
  else
    line = text->temp_line;
  if ( !line )
    return;
  memset(line, 0, 0x14u);
  ctrl_chars_on_this_line = 0;
  utfxtra_on_this_line = 0;
  text->LastChar = 32;
  cp = previous->data;
  if ( previous->data[0] == 5 || *cp == 3 )
  {
    v29 = previous->data[1];
    switch ( v29 )
    {
      case 5:
        goto LABEL_15;
      case 8:
        previous->data[1] = previous->data[0];
        *cp = 8;
        break;
      case 3:
LABEL_15:
        if ( LOBYTE(previous[1].next) == 8 )
        {
          LOBYTE(previous[1].next) = previous->data[1];
          previous->data[1] = previous->data[0];
          *cp = 8;
        }
        break;
    }
  }
  if ( previous->size < split )
  {
    if ( WWW_TraceFlag[0] )
    {
      size = previous->size;
      v3 = TraceFP();
      fprintf(v3, "*** split_line: split==%u greater than last_line->size==%d !\n", split, size);
    }
    if ( split > 0x400 )
    {
      split = previous->size;
      cpa = strrchr(previous->data, 32);
      if ( cpa && cpa - previous->data > 1 )
        split = cpa - previous->data;
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "                split adjusted to %u.\n", split);
      }
    }
  }
  ++text->Lines;
  previous->next->prev = &line->base;
  line->base.prev = previous;
  line->base.next = previous->next;
  previous->next = &line->base;
  text->last_line = &line->base;
  line->base.size = 0;
  line->base.offset = 0;
  text->permissible_split = 0;
  line->base.data[0] = 0;
  alignment = style->alignment;
  if ( split )
  {
    if ( !dump_output_immediately || !use_underscore )
      t_underline = set_style_by_embedded_chars(previous->data, &previous->data[split], 3u, 4u);
    t_bold = set_style_by_embedded_chars(previous->data, &previous->data[split], 5u, 6u);
  }
  if ( (!dump_output_immediately || !use_underscore) && t_underline )
  {
    v5 = line->base.size;
    line->base.data[v5] = 3;
    line->base.size = v5 + 1;
    line->base.data[line->base.size] = 0;
    ++ctrl_chars_on_this_line;
    SpecialAttrChars = 1;
  }
  if ( t_bold )
  {
    v6 = line->base.size;
    line->base.data[v6] = 5;
    line->base.size = v6 + 1;
    line->base.data[line->base.size] = 0;
    ++ctrl_chars_on_this_line;
    ++SpecialAttrChars;
  }
  if ( split )
  {
    previous->data[previous->size] = 0;
    previous->size = split;
    for ( p = &previous->data[split];
          (*p == 32 || *p == 1)
       && (HeadTrim
        || text->first_anchor
        || underline_on
        || bold_on
        || alignment != 1
        || style->wordWrap
        || style->freeFormat
        || style->spaceBefore
        || style->spaceAfter)
       || *p == 7;
          ++p )
    {
      ++HeadTrim;
    }
    plen = strlen(p);
    if ( plen )
    {
      for ( i = plen - 1; i >= 0; --i )
      {
        if ( p[i] == 3 || p[i] == 4 || p[i] == 5 || p[i] == 6 || p[i] == 7 )
        {
          ++ctrl_chars_on_this_line;
        }
        else if ( text->T.output_utf8 && (p[i] & 0xC0) == 128 )
        {
          ++utfxtra_on_this_line;
        }
        if ( p[i] == 7 && (signed int)text->permissible_split < i )
          text->permissible_split = i + 1;
      }
      ctrl_chars_on_this_line += utfxtra_on_this_line;
      strcat(line->base.data, p);
      line->base.size += plen;
    }
  }
  for ( pa = &previous->data[previous->size - 1];
        previous->data <= pa
     && (*pa == 32 || *pa == 1)
     && !psrc_view
     && (ctrl_chars_on_this_line
      || HeadTrim
      || text->first_anchor
      || underline_on
      || bold_on
      || alignment != 1
      || style->wordWrap
      || style->freeFormat
      || style->spaceBefore
      || style->spaceAfter);
        --pa )
  {
    ;
  }
  TailTrim = &previous->data[previous->size - 1] - pa;
  previous->size -= TailTrim;
  pa[1] = 0;
  if ( split )
    s = split;
  else
    s = TailTrim + previous->size;
  s_post = HeadTrim + s;
  s_pre = s - TailTrim;
  if ( WWW_TraceFlag[0] )
  {
    v7 = TraceFP();
    fprintf(v7, "GridText: split_line(%u [now:%d]) called\n", split, s);
  }
  if ( (HTStyleChange (*)[64])previous->styles == stylechanges_buffers )
    line->base.styles = (HTStyleChange *)(stylechanges_buffers + 256);
  else
    line->base.styles = stylechanges_buffers[0];
  line->base.numstyles = 0;
  from = &previous->styles[-(1 - previous->numstyles)];
  for ( to = line->base.styles + 63; previous->styles <= from && line->base.styles <= to; --to )
  {
    *to = *from;
    if ( *(_WORD *)to >> 2 <= s_post )
    {
      if ( *(_WORD *)to >> 2 <= s_pre || (*(_BYTE *)to & 3) != 1 && (*(_BYTE *)to & 3) != 2 )
        break;
      if ( *(_WORD *)to >> 2 < s )
        v30 = 0;
      else
        v30 = SpecialAttrChars & 0x3FFF;
      *(_WORD *)to = (4 * v30) | *(_WORD *)to & 3;
    }
    else
    {
      *(_WORD *)to = (4 * (((*(_WORD *)to >> 2) + SpecialAttrChars - s_post) & 0x3FFF)) | *(_WORD *)to & 3;
    }
    --from;
  }
  scan = from;
  at_end = from;
  while ( previous->styles <= scan && previous->styles <= at_end )
  {
    if ( (*(_BYTE *)scan & 3) != 0 )
    {
      if ( (*(_BYTE *)scan & 3) == 1 )
      {
        if ( (*(_BYTE *)at_end & 3) == 1
          && *((_WORD *)at_end + 1) == *((_WORD *)scan + 1)
          && *(_WORD *)at_end >> 2 >= s_pre )
        {
          --at_end;
        }
        else
        {
          if ( &previous->styles[63] <= at_end )
          {
            if ( WWW_TraceFlag[0] )
            {
              v9 = TraceFP();
              fprintf(v9, "BUG: style overflow before split_line.\n");
            }
            break;
          }
          *(_BYTE *)++at_end &= 0xFCu;
          *((_WORD *)at_end + 1) = *((_WORD *)scan + 1);
          *(_WORD *)at_end = (4 * (s_pre & 0x3FFF)) | *(_WORD *)at_end & 3;
        }
        if ( &line->base.styles[63] <= to
          || (*(_BYTE *)&to[1] & 3) != 0
          || *(_WORD *)&to[1] >> 2 > SpecialAttrChars
          || *((_WORD *)&to[1] + 1) != *((_WORD *)scan + 1) )
        {
          if ( line->base.styles > to )
          {
            if ( WWW_TraceFlag[0] )
            {
              v10 = TraceFP();
              fprintf(v10, "BUG: style overflow after split_line.\n");
            }
            break;
          }
          *to = *scan;
          *(_WORD *)to = (4 * (SpecialAttrChars & 0x3FFF)) | *(_WORD *)to & 3;
          --to;
        }
        else
        {
          ++to;
        }
      }
    }
    else
    {
      scan = skip_matched_and_correct_offsets(scan, previous->styles, s_pre);
      if ( !scan )
      {
        if ( WWW_TraceFlag[0] )
        {
          v8 = TraceFP();
          fprintf(v8, "BUG: styles improperly nested.\n");
        }
        break;
      }
    }
    if ( *(_WORD *)scan >> 2 > s_pre )
      *(_WORD *)scan = (4 * (s_pre & 0x3FFF)) | *(_WORD *)scan & 3;
    --scan;
  }
  line->base.numstyles = &line->base.styles[63] - to;
  if ( line->base.numstyles && line->base.numstyles <= 0x3Fu )
  {
    for ( n = 0; line->base.numstyles > n; ++n )
      line->base.styles[n] = to[n + 1];
  }
  else if ( !line->base.numstyles )
  {
    *(_WORD *)line->base.styles |= 0xFFFCu;
  }
  previous->numstyles = at_end - previous->styles + 1;
  if ( !previous->numstyles )
    *(_WORD *)previous->styles |= 0xFFFCu;
  temp = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool, previous->size + 20);
  if ( !temp )
    outofmem("./GridText.c", "split_line_2");
  memcpy(temp, previous, previous->size + 20);
  temp->styles = ALLOC_IN_POOL(&HTMainText->pool, 4 * previous->numstyles);
  if ( !temp->styles )
    outofmem("./GridText.c", "split_line_2");
  memcpy(temp->styles, previous->styles, 4 * previous->numstyles);
  previousa = temp;
  temp->prev->next = temp;
  temp->next->prev = temp;
  temp->data[temp->size] = 0;
  spare = 0;
  if ( this_line_was_split[0] || alignment == 3 || alignment == 2 || text->stbl )
  {
    for ( cpb = temp->data; *cpb; ++cpb )
    {
      if ( *cpb == 3 || *cpb == 4 || *cpb == 5 || *cpb == 6 || *cpb == 7 )
        ++ctrl_chars_on_previous_line;
    }
    if ( temp->size && temp->data[temp->size - 1] == 7 )
      --ctrl_chars_on_previous_line;
    if ( text->stbl )
    {
      if ( LYtableCols > 0 )
      {
        v32 = LYcols * LYtableCols / 12;
      }
      else
      {
        if ( LYwideLines )
          v33 = 1014;
        else
          v33 = LYcols;
        v32 = v33;
      }
      v31 = v32 - (LYShowScrollbar != 0);
    }
    else
    {
      v31 = LYcols - (LYShowScrollbar != 0);
    }
    v11 = v31 - style->rightIndent - indent1st;
    spare = v11 - LYstrExtent2(temp->data, temp->size);
    if ( spare < 0 && LYwideLines )
      spare = 0;
  }
  new_offset = temp->offset;
  v34 = style->alignment;
  if ( v34 == 2 )
  {
    new_offseta = indent1st + spare + new_offset;
  }
  else if ( v34 == 3 )
  {
    new_offseta = indent1st + spare / 2 + new_offset;
  }
  else
  {
    new_offseta = indent1st + new_offset;
  }
  temp->offset = new_offseta & ~(unsigned __int16)(new_offseta >> 31);
  if ( text->stbl )
    Stbl_finishCellInTable(text->stbl, 0, text->Lines - 1, temp->offset, temp->size - ctrl_chars_on_previous_line);
  text->in_line_1 = 0;
  if ( s > 0 )
  {
    moved = 0;
    a = text->last_anchor_before_split;
    if ( !a )
      a = text->first_anchor;
    while ( a )
    {
      if ( a->line_num == CurLine )
      {
        len = a->extent;
        n_0 = a->number;
        start = a->line_pos;
        end = len + start;
        text->last_anchor_before_split = a;
        if ( start >= s_pre )
        {
          if ( start >= s || len || n_0 && (!a->show_anchor || moved) )
          {
            moved = 1;
            ++a->line_num;
            if ( WWW_TraceFlag[0] )
            {
              extent = a->extent;
              line_pos = a->line_pos;
              line_num = a->line_num;
              v19 = TraceFP();
              fprintf(
                v19,
                "anchor %d: (T,H,S)=(%d,%d,%d); (line,pos,ext):(%d,%d,%d), ",
                n_0,
                TailTrim,
                HeadTrim,
                SpecialAttrChars,
                line_num,
                line_pos,
                extent);
            }
            if ( end < s_post )
            {
              if ( WWW_TraceFlag[0] )
              {
                v20 = TraceFP();
                fprintf(v20, "Move end +%d, ", s_post - end);
              }
              LOWORD(len) = s_post - start;
            }
            if ( start < s_post )
            {
              if ( WWW_TraceFlag[0] )
              {
                v21 = TraceFP();
                fprintf(v21, "Move start +%d, ", s_post - start);
              }
              LOWORD(len) = start - s_post + len;
              LOWORD(start) = HeadTrim + s;
            }
            a->line_pos = start - s_post + SpecialAttrChars;
            a->extent = len;
            if ( WWW_TraceFlag[0] )
            {
              v22 = a->extent;
              v23 = a->line_pos;
              v24 = a->line_num;
              v25 = TraceFP();
              fprintf(v25, "->(%d,%d,%d)\n", v24, v23, v22);
            }
          }
          else
          {
            if ( WWW_TraceFlag[0] )
            {
              v15 = TraceFP();
              fprintf(v15, "anchor %d: no relocation, empty-finished", n_0);
            }
            a->line_pos = s_pre;
          }
        }
        else if ( end > s_pre )
        {
          if ( WWW_TraceFlag[0] )
          {
            v12 = TraceFP();
            fprintf(v12, "anchor %d: no relocation", n_0);
          }
          if ( end <= s_post )
          {
            if ( WWW_TraceFlag[0] )
            {
              v14 = TraceFP();
              fprintf(v14, ", cut the end.\n");
            }
            a->extent = s_pre - start;
          }
          else
          {
            if ( WWW_TraceFlag[0] )
            {
              v13 = TraceFP();
              fprintf(v13, " of the start.\n");
            }
            a->extent += SpecialAttrChars - (TailTrim + HeadTrim);
          }
        }
      }
      else if ( a->line_num > CurLine )
      {
        break;
      }
      a = a->next;
    }
  }
  if ( !this_line_was_split[0]
    || spare <= 0
    || text->stbl
    || justify_max_void_percent <= 0
    || justify_max_void_percent > 100
    || (!text->stbl ? (v35 = LYcols - (LYShowScrollbar != 0)) : (LYtableCols > 0 ? (v36 = LYcols * LYtableCols / 12) : (LYwideLines ? (v37 = 1014) : (v37 = LYcols), v36 = v37),
                                                                 v35 = v36 - (LYShowScrollbar != 0)),
        100 * spare / (ctrl_chars_on_previous_line + v35 - style->rightIndent - indent1st) > justify_max_void_percent) )
  {
    if ( wait_for_this_stacked_elt >= 0
      || text->style->alignment != 1 && text->style->alignment
      || HTCJK
      || in_DT[0]
      || !can_justify_here[0]
      || !can_justify_this_line[0]
      || form_in_htext )
    {
      if ( have_raw_nbsps[0] )
      {
        for ( i_1 = 0; temp->size > i_1; ++i_1 )
        {
          if ( temp->data[i_1] == 1 )
            temp->data[i_1] = 32;
        }
        for ( i_1a = 0; line->base.size > i_1a; ++i_1a )
        {
          if ( line->base.data[i_1a] == 1 )
            line->base.data[i_1a] = 32;
        }
      }
    }
    else
    {
      if ( line->base.size && !text->stbl && WWW_TraceFlag[0] )
      {
        v26 = line->base.size;
        v27 = TraceFP();
        fprintf(v27, "BUG: justification: shouldn't happen - new line is not empty!\n\t'%.*s'\n", v26, line->base.data);
      }
      for ( p2_0 = temp->data; *p2_0; ++p2_0 )
      {
        if ( *p2_0 == 1 )
          *p2_0 = 32;
      }
    }
  }
  else
  {
    jp = &temp->data[justify_start_position];
    r = ht_runs;
    total_byte_len = 0;
    total_cell_len = 0;
    ht_num_runs = 0;
    ht_runs[0].cell_len = 0;
    ht_runs[0].byte_len = ht_runs[0].cell_len;
    while ( 1 )
    {
      c = *jp;
      if ( !*jp )
        break;
      if ( c == 32 )
      {
        total_byte_len += r->byte_len;
        total_cell_len += r->cell_len;
        ++r;
        ++ht_num_runs;
        r->cell_len = 0;
        r->byte_len = r->cell_len;
      }
      else
      {
        ++r->byte_len;
        if ( c <= 2 || c > 8 )
        {
          ++r->cell_len;
          if ( c == 1 )
          {
            *jp = 32;
          }
          else if ( text->T.output_utf8 && c < 0 )
          {
            utf_extra = utf8_length(text->T.output_utf8, jp);
            r->byte_len += utf_extra;
            jp += utf_extra;
          }
        }
      }
      ++jp;
    }
    if ( ++ht_num_runs != 1 )
    {
      oldpos = (int *)malloc(8 * (ht_num_runs - 1));
      newpos = &oldpos[-(1 - ht_num_runs)];
      i_0 = 1;
      if ( !oldpos )
        outofmem("./GridText.c", "split_line_3");
      d_ = spare / (ht_num_runs - 1);
      r_a = spare % (ht_num_runs - 1);
      *oldpos = ht_runs[0].cell_len + justify_start_position + 1;
      *newpos = d_ + (r_a > 0) + *oldpos;
      r_ = r_a - 1;
      while ( ht_num_runs - 1 > i_0 )
      {
        delta = ht_runs[i_0].cell_len + 1;
        oldpos[i_0] = delta + oldpos[-(1 - i_0)];
        newpos[i_0] = delta + newpos[-(1 - i_0)] + d_ + (r_-- > 0);
        ++i_0;
      }
      jline = insert_blanks_in_line(temp, CurLine, text, &last_anchor_of_previous_line, ht_num_runs - 1, oldpos, newpos);
      free(oldpos);
      if ( !jline )
        outofmem("./GridText.c", "split_line_4");
      temp->next->prev = jline;
      temp->prev->next = jline;
      previousa = jline;
    }
    if ( justify_start_position )
    {
      for ( p2 = previousa->data; &previousa->data[justify_start_position] > p2; ++p2 )
      {
        if ( *p2 == 1 )
          v38 = 32;
        else
          v38 = *p2;
        *p2 = v38;
      }
    }
  }
  can_justify_this_line[0] = 1;
  justify_start_position = 0;
  this_line_was_split[0] = 0;
  have_raw_nbsps[0] = 0;
}

//----- (080621DB) --------------------------------------------------------
void __cdecl blank_lines(HText *text, int newlines)
{
  HTLine *line; // [esp+20h] [ebp-8h]

  if ( !HText_LastLineEmpty(text, 0) )
  {
    ++newlines;
LABEL_15:
    while ( newlines )
    {
      split_line(text, 0);
      --newlines;
    }
    text->in_line_1 = 1;
    return;
  }
  line = text->last_line->prev;
  if ( (!no_title || text->last_line != line) && (text->last_line != line || newlines != 1) )
  {
    while ( line && text->last_line != line && HText_TrueEmptyLine(line, text, 0) && newlines )
    {
      --newlines;
      line = line->prev;
    }
    goto LABEL_15;
  }
}

//----- (080622A5) --------------------------------------------------------
void __cdecl HText_appendParagraph(HText *text)
{
  HTCoord newlines; // [esp+14h] [ebp-14h]

  newlines = text->style->spaceBefore;
  if ( newlines < text->style->spaceAfter )
    newlines = text->style->spaceAfter;
  blank_lines(text, newlines);
}

//----- (080622F7) --------------------------------------------------------
void __cdecl HText_setStyle(HText *text, HTStyle *style)
{
  char *name; // ebx
  FILE *v3; // eax
  int newlines; // [esp+10h] [ebp-18h]
  int before; // [esp+1Ch] [ebp-Ch]
  int after; // [esp+20h] [ebp-8h]

  if ( style )
  {
    after = text->style->spaceAfter;
    before = style->spaceBefore;
    if ( WWW_TraceFlag[0] )
    {
      name = style->name;
      v3 = TraceFP();
      fprintf(v3, "GridText: Change to style %s\n", name);
    }
    newlines = before;
    if ( before < after )
      newlines = after;
    blank_lines(text, newlines);
    text->style = style;
  }
}

//----- (08062386) --------------------------------------------------------
void __cdecl HText_appendCharacter(HText *text, int ch_0)
{
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  unsigned __int16 v6; // cx
  unsigned __int16 v7; // cx
  unsigned __int16 v8; // cx
  unsigned __int16 v9; // cx
  unsigned __int16 size; // cx
  unsigned __int16 v11; // cx
  unsigned __int16 v12; // cx
  unsigned __int16 v13; // cx
  unsigned __int16 v14; // cx
  unsigned __int16 v15; // cx
  unsigned __int16 v16; // cx
  int v17; // ebx
  int v18; // esi
  FILE *v19; // eax
  unsigned __int16 v20; // cx
  unsigned __int16 v21; // cx
  unsigned __int16 v22; // cx
  unsigned __int16 v23; // cx
  unsigned __int16 v24; // cx
  unsigned __int16 v25; // cx
  int v26; // ebx
  int v27; // esi
  FILE *v28; // eax
  unsigned __int16 v29; // cx
  unsigned __int16 v30; // cx
  char *v31; // [esp+4h] [ebp-1A4h]
  eSJIS_status SJIS_status; // [esp+20h] [ebp-188h]
  eEUC_status EUC_status; // [esp+24h] [ebp-184h]
  eDetectedKCode detected_kcode; // [esp+28h] [ebp-180h]
  HTCoord indent1st; // [esp+2Ch] [ebp-17Ch]
  int v36; // [esp+38h] [ebp-170h]
  int v37; // [esp+40h] [ebp-168h]
  int v38; // [esp+44h] [ebp-164h]
  int v39; // [esp+48h] [ebp-160h]
  int v40; // [esp+4Ch] [ebp-15Ch]
  int v41; // [esp+50h] [ebp-158h]
  int v42; // [esp+54h] [ebp-154h]
  int v43; // [esp+58h] [ebp-150h]
  int v44; // [esp+5Ch] [ebp-14Ch]
  int v45; // [esp+60h] [ebp-148h]
  int v46; // [esp+64h] [ebp-144h]
  int v47; // [esp+68h] [ebp-140h]
  int v48; // [esp+6Ch] [ebp-13Ch]
  int v49; // [esp+70h] [ebp-138h]
  int v50; // [esp+74h] [ebp-134h]
  int v51; // [esp+78h] [ebp-130h]
  _BOOL4 v52; // [esp+80h] [ebp-128h]
  int v53; // [esp+84h] [ebp-124h]
  int v54; // [esp+88h] [ebp-120h]
  int v55; // [esp+8Ch] [ebp-11Ch]
  int v56; // [esp+90h] [ebp-118h]
  int v57; // [esp+94h] [ebp-114h]
  int v58; // [esp+98h] [ebp-110h]
  int v59; // [esp+A0h] [ebp-108h]
  int v60; // [esp+A4h] [ebp-104h]
  int v61; // [esp+A8h] [ebp-100h]
  int v62; // [esp+ACh] [ebp-FCh]
  int v63; // [esp+B0h] [ebp-F8h]
  int v64; // [esp+B4h] [ebp-F4h]
  int v65; // [esp+B8h] [ebp-F0h]
  int v66; // [esp+BCh] [ebp-ECh]
  int v67; // [esp+C0h] [ebp-E8h]
  int v68; // [esp+C4h] [ebp-E4h]
  int v69; // [esp+C8h] [ebp-E0h]
  int v70; // [esp+CCh] [ebp-DCh]
  int v71; // [esp+D0h] [ebp-D8h]
  int v72; // [esp+D4h] [ebp-D4h]
  int v73; // [esp+D8h] [ebp-D0h]
  _BOOL4 v74; // [esp+DCh] [ebp-CCh]
  _BOOL4 v75; // [esp+E4h] [ebp-C4h]
  int v76; // [esp+ECh] [ebp-BCh]
  int v77; // [esp+F0h] [ebp-B8h]
  int v78; // [esp+F4h] [ebp-B4h]
  int v79; // [esp+FCh] [ebp-ACh]
  int v80; // [esp+100h] [ebp-A8h]
  int v81; // [esp+104h] [ebp-A4h]
  int v82; // [esp+108h] [ebp-A0h]
  int v83; // [esp+10Ch] [ebp-9Ch]
  int v84; // [esp+110h] [ebp-98h]
  int v85; // [esp+118h] [ebp-90h]
  int v86; // [esp+11Ch] [ebp-8Ch]
  int v87; // [esp+120h] [ebp-88h]
  unsigned __int16 v88; // [esp+12Ah] [ebp-7Eh]
  char v89; // [esp+133h] [ebp-75h]
  char v90; // [esp+134h] [ebp-74h]
  char v91; // [esp+135h] [ebp-73h]
  unsigned __int16 v92; // [esp+136h] [ebp-72h]
  char v93; // [esp+13Eh] [ebp-6Ah]
  char v94; // [esp+13Fh] [ebp-69h]
  HTFont font; // [esp+14Ch] [ebp-5Ch]
  int number; // [esp+150h] [ebp-58h]
  int nominal; // [esp+154h] [ebp-54h]
  eGridState saved_state; // [esp+158h] [ebp-50h]
  int saved_kanji_buf; // [esp+15Ch] [ebp-4Ch]
  int here; // [esp+16Ch] [ebp-3Ch]
  int target; // [esp+174h] [ebp-34h]
  const HTTabStop *Tab; // [esp+178h] [ebp-30h]
  int i; // [esp+17Ch] [ebp-2Ch]
  eDetectedKCode save_d_kcode; // [esp+180h] [ebp-28h]
  int limit; // [esp+188h] [ebp-20h]
  HTStyle *style; // [esp+190h] [ebp-18h]
  HTLine *line; // [esp+194h] [ebp-14h]
  HTLine *linea; // [esp+194h] [ebp-14h]
  unsigned __int8 tmp[2]; // [esp+19Bh] [ebp-Dh] BYREF
  unsigned __int8 lo; // [esp+19Dh] [ebp-Bh] BYREF
  unsigned __int8 hi; // [esp+19Eh] [ebp-Ah] BYREF
  unsigned __int8 c; // [esp+19Fh] [ebp-9h]

  if ( !text )
    return;
  if ( text->halted > 1 )
  {
    if ( text->halted == 2 )
    {
      text->halted = 0;
      text->kanji_buf = 0;
      v31 = gettext(" *** MEMORY EXHAUSTED ***");
      HText_appendText(text, v31);
    }
    text->halted = 3;
    return;
  }
  if ( HTCJK == JAPANESE
    && text->detected_kcode != DET_MIXED
    && text->specified_kcode != SJIS
    && text->specified_kcode != EUC )
  {
    c = ch_0;
    save_d_kcode = text->detected_kcode;
    SJIS_status = text->SJIS_status;
    if ( SJIS_status == SJIS_state_in_kanji )
    {
      if ( c <= 0x3Fu || c == 127 || c > 0xFCu )
      {
        text->SJIS_status = SJIS_state_has_bad_code;
        if ( text->EUC_status == EUC_state_has_bad_code )
          text->detected_kcode = DET_MIXED;
        else
          text->detected_kcode = DET_EUC;
      }
      else
      {
        text->SJIS_status = SJIS_state_neutral;
      }
    }
    else if ( SJIS_status == SJIS_state_neutral )
    {
      if ( (c <= 0x80u || c > 0x9Fu) && (c <= 0xDFu || c > 0xEFu) )
      {
        if ( (c & 0x80u) != 0 && (c <= 0xA0u || c > 0xDFu) )
        {
          text->SJIS_status = SJIS_state_has_bad_code;
          if ( text->EUC_status == EUC_state_has_bad_code )
            text->detected_kcode = DET_MIXED;
          else
            text->detected_kcode = DET_EUC;
        }
      }
      else
      {
        text->SJIS_status = SJIS_state_in_kanji;
      }
    }
    EUC_status = text->EUC_status;
    if ( EUC_status == EUC_state_in_kanji )
    {
      if ( c <= 0xA0u || c == 0xFF )
      {
        text->EUC_status = EUC_state_has_bad_code;
        if ( text->SJIS_status == SJIS_state_has_bad_code )
          text->detected_kcode = DET_MIXED;
        else
          text->detected_kcode = DET_SJIS;
      }
      else
      {
        text->EUC_status = EUC_state_neutral;
      }
    }
    else if ( EUC_status )
    {
      if ( EUC_status == EUC_state_in_kana )
      {
        if ( c <= 0xA0u || c > 0xDFu )
        {
          text->EUC_status = EUC_state_has_bad_code;
          if ( text->SJIS_status == SJIS_state_has_bad_code )
            text->detected_kcode = DET_MIXED;
          else
            text->detected_kcode = DET_SJIS;
        }
        else
        {
          text->EUC_status = EUC_state_neutral;
        }
      }
    }
    else if ( c <= 0xA0u || c == 0xFF )
    {
      if ( c == 0x8E )
      {
        text->EUC_status = EUC_state_in_kana;
      }
      else if ( (c & 0x80u) != 0 )
      {
        text->EUC_status = EUC_state_has_bad_code;
        if ( text->SJIS_status == SJIS_state_has_bad_code )
          text->detected_kcode = DET_MIXED;
        else
          text->detected_kcode = DET_SJIS;
      }
    }
    else
    {
      text->EUC_status = EUC_state_in_kanji;
    }
    if ( text->detected_kcode != save_d_kcode )
    {
      detected_kcode = text->detected_kcode;
      if ( detected_kcode == DET_EUC )
      {
        if ( WWW_TraceFlag[0] )
        {
          v3 = TraceFP();
          fprintf(v3, "TH_JP_AUTO_DETECT: This document's kcode seems EUC.\n");
        }
      }
      else if ( detected_kcode )
      {
        if ( detected_kcode == DET_MIXED )
        {
          if ( WWW_TraceFlag[0] )
          {
            v4 = TraceFP();
            fprintf(v4, "TH_JP_AUTO_DETECT: This document's kcode seems mixed!\n");
          }
        }
        else if ( WWW_TraceFlag[0] )
        {
          v5 = TraceFP();
          fprintf(v5, "TH_JP_AUTO_DETECT: This document's kcode is unexpected!\n");
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "TH_JP_AUTO_DETECT: This document's kcode seems SJIS.\n");
      }
    }
  }
  if ( (ch_0 != 27 || HTCJK)
    && ((ch_0 & 0x80u) == 0
     || HTCJK
     || text->T.transp
     || text->T.output_utf8
     || (unsigned __int8)ch_0 >= LYlowest_eightbit[current_char_set])
    && ((_BYTE)ch_0 != 0x9B
     || HTCJK
     || HTPassHighCtrlRaw
     || text->T.transp
     || text->T.output_utf8
     || LYlowest_eightbit[current_char_set] <= 155) )
  {
    line = text->last_line;
    style = text->style;
    if ( text->in_line_1 )
      indent1st = style->indent1st;
    else
      indent1st = style->leftIndent;
    if ( HTCJK )
    {
      switch ( text->state )
      {
        case S_text:
          if ( ch_0 != 27 )
            goto LABEL_122;
          text->state = S_esc;
          text->kanji_buf = 0;
          break;
        case S_esc:
          if ( ch_0 == 36 )
          {
            text->state = S_dollar;
          }
          else
          {
            if ( ch_0 != 40 )
            {
              text->state = S_text;
              goto LABEL_93;
            }
            text->state = S_paren;
          }
          break;
        case S_dollar:
LABEL_93:
          if ( ch_0 == 64 || ch_0 == 66 || ch_0 == 65 )
          {
            text->state = S_nonascii_text;
            if ( ch_0 == 64 || ch_0 == 66 )
              text->kcode = JIS;
          }
          else
          {
            if ( ch_0 != 40 )
            {
              text->state = S_text;
              goto LABEL_122;
            }
            text->state = S_dollar_paren;
          }
          break;
        case S_paren:
          if ( ch_0 == 66 || ch_0 == 74 || ch_0 == 84 )
          {
            text->permissible_split = text->last_line->size;
            text->state = S_text;
          }
          else
          {
            if ( ch_0 != 73 )
            {
              text->state = S_text;
              goto LABEL_122;
            }
            text->state = S_jisx0201_text;
            text->permissible_split = text->last_line->size;
            text->kcode = JIS;
          }
          break;
        case S_nonascii_text:
          if ( ch_0 != 27 )
          {
            if ( (unsigned __int8)ch_0 > 0x1Fu )
            {
              ch_0 |= 0x80u;
            }
            else
            {
              text->state = S_text;
              text->kanji_buf = 0;
              if ( HTCJK == JAPANESE )
                text->kcode = NOKANJI;
            }
            goto LABEL_122;
          }
          text->state = S_esc;
          text->kanji_buf = 0;
          if ( HTCJK == JAPANESE )
            text->kcode = NOKANJI;
          break;
        case S_dollar_paren:
          if ( ch_0 != 67 )
          {
            text->state = S_text;
            goto LABEL_122;
          }
          text->state = S_nonascii_text;
          break;
        case S_jisx0201_text:
          if ( ch_0 != 27 )
          {
            text->kanji_buf = -114;
            ch_0 |= 0x80u;
            goto LABEL_122;
          }
          text->state = S_esc;
          text->kanji_buf = 0;
          text->kcode = NOKANJI;
          break;
        default:
LABEL_122:
          if ( text->kanji_buf )
            goto check_WrapSource;
          if ( (ch_0 & 0x80) == 0 )
            goto LABEL_135;
          if ( text->kcode != JIS
            && (text->kcode == SJIS
             || text->detected_kcode == DET_SJIS && text->specified_kcode == NOKANJI
             || text->kcode == NOKANJI && text->specified_kcode == SJIS)
            && (unsigned __int8)ch_0 > 0xA0u
            && (unsigned __int8)ch_0 <= 0xDFu )
          {
            lo = ch_0;
            hi = text->kanji_buf;
            JISx0201TO0208_SJIS(ch_0, &hi, &lo);
            ch_0 = (char)lo;
            text->kanji_buf = hi;
            text->permissible_split = text->last_line->size;
            goto LABEL_135;
          }
          text->kanji_buf = ch_0;
          text->permissible_split = text->last_line->size;
          break;
      }
      return;
    }
    if ( ch_0 == 27 )
      return;
LABEL_135:
    if ( HTCJK && (ch_0 == 5 || ch_0 == 6) )
    {
      text->permissible_split = line->size;
      if ( HTCJK == JAPANESE )
        text->kcode = NOKANJI;
    }
    if ( ch_0 <= 2 || ch_0 >= 8 )
    {
      if ( ch_0 == 8 )
      {
        size = line->size;
        line->data[size] = 8;
        line->size = size + 1;
        line->data[line->size] = 0;
        return;
      }
      goto LABEL_174;
    }
    if ( line->size > 0x3FEu || !with_backspaces || HTCJK || text->T.output_utf8 )
      return;
    switch ( ch_0 )
    {
      case 3:
        v6 = line->size;
        line->data[v6] = 3;
        line->size = v6 + 1;
        line->data[line->size] = 0;
        underline_on = 1;
        if ( !dump_output_immediately || !use_underscore )
          ++ctrl_chars_on_this_line;
        return;
      case 4:
        v7 = line->size;
        line->data[v7] = 4;
        line->size = v7 + 1;
        line->data[line->size] = 0;
        underline_on = 0;
        if ( !dump_output_immediately || !use_underscore )
          ++ctrl_chars_on_this_line;
        return;
      case 5:
        v8 = line->size;
        line->data[v8] = 5;
        line->size = v8 + 1;
        line->data[line->size] = 0;
        bold_on = 1;
        ++ctrl_chars_on_this_line;
        return;
      case 6:
        v9 = line->size;
        line->data[v9] = 6;
        line->size = v9 + 1;
        line->data[line->size] = 0;
        bold_on = 0;
        ++ctrl_chars_on_this_line;
        return;
    }
    if ( ch_0 != 7 )
      goto LABEL_174;
    if ( line->size && text->permissible_split < line->size )
    {
      for ( i = text->permissible_split + 1;
            line->data[i]
         && (line->data[i] > 2u && line->data[i] <= 8u
          || ((*__ctype_b_loc())[(unsigned __int8)line->data[i]] & 0x2000) != 0
          || line->data[i] == 45
          || line->data[i] == 1
          || line->data[i] == 2);
            ++i )
      {
        ;
      }
      if ( line->data[i] )
      {
LABEL_174:
        if ( text->T.output_utf8 )
        {
          if ( (ch_0 & 0xC0) == 128 )
          {
            if ( line->size > 0x3FFu
              || (!line->size || line->data[line->size - 1] != 7 ? (v36 = 0) : (v36 = 1),
                  !text->stbl ? (v37 = LYcols - (LYShowScrollbar != 0)) : (LYtableCols > 0 ? (v38 = LYcols * LYtableCols / 12) : (LYwideLines ? (v39 = 1014) : (v39 = LYcols), v38 = v39),
                                                                           v37 = v38 - (LYShowScrollbar != 0)),
                  v36 + indent1st + line->offset + line->size - ctrl_chars_on_this_line >= v37) )
            {
              if ( !text->permissible_split || text->source )
              {
                for ( text->permissible_split = line->size;
                      text->permissible_split
                   && text->T.output_utf8
                   && (line->data[text->permissible_split - 1] & 0xC0) == 128;
                      --text->permissible_split )
                {
                  ;
                }
                if ( text->permissible_split && line->data[text->permissible_split - 1] < 0 )
                  --text->permissible_split;
                if ( text->permissible_split == line->size )
                  text->permissible_split = 0;
              }
              split_line(text, text->permissible_split);
              line = text->last_line;
              if ( text->source && line->size == ctrl_chars_on_this_line )
                HText_appendCharacter(text, 8);
            }
            v11 = line->size;
            line->data[v11] = ch_0;
            line->size = v11 + 1;
            line->data[line->size] = 0;
            ++utfxtra_on_this_line;
            ++ctrl_chars_on_this_line;
            return;
          }
          if ( (ch_0 & 0x80) != 0 && line->size > 0x3F9u )
          {
            if ( !text->permissible_split || text->source )
            {
              text->permissible_split = line->size;
              if ( text->permissible_split == line->size )
                text->permissible_split = 0;
            }
            split_line(text, text->permissible_split);
            line = text->last_line;
            if ( text->source && line->size == ctrl_chars_on_this_line )
              HText_appendCharacter(text, 8);
          }
        }
        if ( ch_0 == 10 )
        {
          split_line(text, 0);
          text->in_line_1 = 1;
          if ( HTCJK == JAPANESE )
            text->kcode = NOKANJI;
          return;
        }
        if ( ch_0 == 2 )
          ch_0 = 32;
        if ( ch_0 == 13 )
        {
          split_line(text, 0);
          text->in_line_1 = 0;
          if ( HTCJK == JAPANESE )
            text->kcode = NOKANJI;
          return;
        }
        if ( ch_0 == 9 )
        {
          if ( line->size && line->data[line->size - 1] == 7 )
          {
            line->data[--line->size] = 0;
            --ctrl_chars_on_this_line;
          }
          here = indent1st + line->size + line->offset - ctrl_chars_on_this_line;
          if ( style->tabs )
          {
            for ( Tab = style->tabs; Tab->position <= here; ++Tab )
            {
              if ( !Tab->position )
                goto LABEL_250;
            }
            target = Tab->position;
          }
          else
          {
            if ( !text->in_line_1 || style->leftIndent <= here )
              goto LABEL_250;
            target = style->leftIndent;
          }
          if ( text->stbl )
          {
            if ( LYtableCols > 0 )
            {
              v41 = LYcols * LYtableCols / 12;
            }
            else
            {
              if ( LYwideLines )
                v42 = 1014;
              else
                v42 = LYcols;
              v41 = v42;
            }
            v40 = v41 - (LYShowScrollbar != 0);
          }
          else
          {
            v40 = LYcols - (LYShowScrollbar != 0);
          }
          if ( v40 - style->rightIndent >= target || HTOutputFormat == WWW_SOURCE )
          {
            text->permissible_split = line->size;
            if ( text->stbl )
            {
              if ( LYtableCols > 0 )
              {
                v44 = LYcols * LYtableCols / 12;
              }
              else
              {
                if ( LYwideLines )
                  v45 = 1014;
                else
                  v45 = LYcols;
                v44 = v45;
              }
              v43 = v44 - (LYShowScrollbar != 0);
            }
            else
            {
              v43 = LYcols - (LYShowScrollbar != 0);
            }
            if ( v43 < target )
            {
              if ( text->stbl )
              {
                if ( LYtableCols > 0 )
                {
                  v47 = LYcols * LYtableCols / 12;
                }
                else
                {
                  if ( LYwideLines )
                    v48 = 1014;
                  else
                    v48 = LYcols;
                  v47 = v48;
                }
                v46 = v47 - (LYShowScrollbar != 0);
              }
              else
              {
                v46 = LYcols - (LYShowScrollbar != 0);
              }
              target = v46;
            }
            if ( line->size )
            {
              while ( here < target )
              {
                v12 = line->size;
                line->data[v12] = 32;
                line->size = v12 + 1;
                line->data[line->size] = 0;
                ++here;
              }
            }
            else
            {
              line->offset += target - here;
            }
            return;
          }
LABEL_250:
          split_line(text, 0);
          return;
        }
check_WrapSource:
        if ( (text->source || dont_wrap_pre) && text == HTMainText )
        {
          if ( text->stbl )
          {
            if ( LYtableCols > 0 )
            {
              v50 = LYcols * LYtableCols / 12;
            }
            else
            {
              v51 = LYwideLines ? 1014 : LYcols;
              v50 = v51;
            }
            v49 = v50 - (LYShowScrollbar != 0);
          }
          else
          {
            v49 = LYcols - (LYShowScrollbar != 0);
          }
          v52 = HTCJK && text->kanji_buf;
          if ( v49 - style->rightIndent - v52 <= line->size + line->offset - ctrl_chars_on_this_line )
            goto LABEL_322;
          if ( text->T.output_utf8 )
          {
            if ( (~(_BYTE)ch_0 & 0xC0) != 0 )
            {
              v53 = 0;
            }
            else
            {
              if ( (~(_BYTE)ch_0 & 0x20) != 0 )
              {
                v54 = 1;
              }
              else
              {
                if ( (~(_BYTE)ch_0 & 0x10) != 0 )
                {
                  v55 = 2;
                }
                else
                {
                  if ( (~(_BYTE)ch_0 & 8) != 0 )
                  {
                    v56 = 3;
                  }
                  else
                  {
                    if ( (~(_BYTE)ch_0 & 4) != 0 )
                    {
                      v57 = 4;
                    }
                    else
                    {
                      v58 = (~(_BYTE)ch_0 & 2) != 0 ? 5 : 0;
                      v57 = v58;
                    }
                    v56 = v57;
                  }
                  v55 = v56;
                }
                v54 = v55;
              }
              v53 = v54;
            }
            if ( text->stbl )
            {
              if ( LYtableCols > 0 )
              {
                v60 = LYcols * LYtableCols / 12;
              }
              else
              {
                v61 = LYwideLines ? 1014 : LYcols;
                v60 = v61;
              }
              v59 = v60 - (LYShowScrollbar != 0);
            }
            else
            {
              v59 = LYcols - (LYShowScrollbar != 0);
            }
            if ( line->size + line->offset - ctrl_chars_on_this_line + v53 >= v59 )
            {
LABEL_322:
              split_line(text, 0);
              line = text->last_line;
              saved_kanji_buf = text->kanji_buf;
              saved_state = text->state;
              text->kanji_buf = 0;
              text->state = S_text;
              HText_appendCharacter(text, 8);
              text->kanji_buf = saved_kanji_buf;
              text->state = saved_state;
            }
          }
        }
        if ( ch_0 == 32 )
        {
          text->permissible_split = text->last_line->size;
          if ( HTCJK == JAPANESE )
            text->kcode = NOKANJI;
        }
        if ( text->IgnoreExcess )
        {
          nominal = indent1st + line->offset + line->size - ctrl_chars_on_this_line;
          if ( text->stbl )
          {
            if ( LYtableCols > 0 )
            {
              v63 = LYcols * LYtableCols / 12;
            }
            else
            {
              if ( LYwideLines )
                v64 = 1014;
              else
                v64 = LYcols;
              v63 = v64;
            }
            v62 = v63 - (LYShowScrollbar != 0);
          }
          else
          {
            v62 = LYcols - (LYShowScrollbar != 0);
          }
          limit = v62;
          if ( (keypad_mode == 3 || keypad_mode == 2) && !number_fields_on_left )
          {
            if ( text->last_anchor )
            {
              number = text->last_anchor->number;
              if ( number > 0 )
              {
                if ( number > 99999 )
                {
                  v65 = 8;
                }
                else
                {
                  if ( number > 9999 )
                  {
                    v66 = 7;
                  }
                  else
                  {
                    if ( number > 999 )
                    {
                      v67 = 6;
                    }
                    else
                    {
                      if ( number > 99 )
                      {
                        v68 = 5;
                      }
                      else
                      {
                        if ( number <= 9 )
                          v69 = 3;
                        else
                          v69 = 4;
                        v68 = v69;
                      }
                      v67 = v68;
                    }
                    v66 = v67;
                  }
                  v65 = v66;
                }
                limit = v62 - v65;
              }
            }
          }
          if ( nominal + style->rightIndent >= limit )
            return;
          if ( text->stbl )
          {
            if ( LYtableCols > 0 )
            {
              v71 = LYcols * LYtableCols / 12;
            }
            else
            {
              v72 = LYwideLines ? 1014 : LYcols;
              v71 = v72;
            }
            v70 = v71 - (LYShowScrollbar != 0);
          }
          else
          {
            v70 = LYcols - (LYShowScrollbar != 0);
          }
          if ( v70 <= nominal )
            return;
        }
        v73 = line->size + indent1st + line->offset;
        v74 = line->size && line->data[line->size - 1] == 7;
        v75 = HTCJK && text->kanji_buf;
        if ( text->stbl )
        {
          if ( LYtableCols > 0 )
          {
            v77 = LYcols * LYtableCols / 12;
          }
          else
          {
            if ( LYwideLines )
              v78 = 1014;
            else
              v78 = LYcols;
            v77 = v78;
          }
          v76 = v77 - (LYShowScrollbar != 0);
        }
        else
        {
          v76 = LYcols - (LYShowScrollbar != 0);
        }
        if ( v75 + v74 + v73 + style->rightIndent - ctrl_chars_on_this_line >= v76 )
          goto LABEL_416;
        if ( !text->T.output_utf8 )
          goto LABEL_438;
        if ( (~(_BYTE)ch_0 & 0xC0) != 0 )
        {
          v79 = 0;
        }
        else
        {
          if ( (~(_BYTE)ch_0 & 0x20) != 0 )
          {
            v80 = 1;
          }
          else
          {
            if ( (~(_BYTE)ch_0 & 0x10) != 0 )
            {
              v81 = 2;
            }
            else
            {
              if ( (~(_BYTE)ch_0 & 8) != 0 )
              {
                v82 = 3;
              }
              else
              {
                if ( (~(_BYTE)ch_0 & 4) != 0 )
                {
                  v83 = 4;
                }
                else
                {
                  v84 = (~(_BYTE)ch_0 & 2) != 0 ? 5 : 0;
                  v83 = v84;
                }
                v82 = v83;
              }
              v81 = v82;
            }
            v80 = v81;
          }
          v79 = v80;
        }
        if ( text->stbl )
        {
          if ( LYtableCols > 0 )
          {
            v86 = LYcols * LYtableCols / 12;
          }
          else
          {
            v87 = LYwideLines ? 1014 : LYcols;
            v86 = v87;
          }
          v85 = v86 - (LYShowScrollbar != 0) - 1;
        }
        else
        {
          v85 = LYcols - (LYShowScrollbar != 0) - 1;
        }
        if ( v79 + v74 + v73 - ctrl_chars_on_this_line >= v85 )
        {
LABEL_416:
          if ( style->wordWrap && HTOutputFormat != WWW_SOURCE )
          {
            if ( wait_for_this_stacked_elt < 0
              && (text->style->alignment == 1 || !text->style->alignment)
              && HTCJK == NOCJK
              && !in_DT[0]
              && can_justify_here[0]
              && can_justify_this_line[0]
              && !form_in_htext )
            {
              this_line_was_split[0] = 1;
            }
            split_line(text, text->permissible_split);
            if ( ch_0 == 32 )
              return;
LABEL_440:
            if ( ch_0 == 1
              && (wait_for_this_stacked_elt >= 0
               || text->style->alignment != 1 && text->style->alignment
               || HTCJK
               || in_DT[0]
               || !can_justify_here[0]
               || !can_justify_this_line[0]
               || form_in_htext) )
            {
              ch_0 = 32;
            }
            else
            {
              have_raw_nbsps[0] = 1;
            }
            if ( (ch_0 & 0x80) != 0 )
              text->have_8bit_chars = 1;
            font = style->font;
            linea = text->last_line;
            if ( HTCJK == NOCJK || !text->kanji_buf )
            {
              if ( HTCJK )
              {
                v88 = linea->size;
                if ( kanji_code )
                {
                  v89 = ch_0;
                }
                else
                {
                  if ( (font & 1) != 0 )
                  {
                    if ( ((*__ctype_b_loc())[(unsigned __int8)ch_0] & 0x200) != 0 )
                      v91 = toupper((unsigned __int8)ch_0);
                    else
                      v91 = ch_0;
                    v90 = v91;
                  }
                  else
                  {
                    v90 = ch_0;
                  }
                  v89 = v90;
                }
                linea->data[v88] = v89;
                linea->size = v88 + 1;
              }
              else
              {
                v92 = linea->size;
                if ( (font & 1) != 0 )
                {
                  if ( ((*__ctype_b_loc())[(unsigned __int8)ch_0] & 0x200) != 0 )
                    v94 = toupper((unsigned __int8)ch_0);
                  else
                    v94 = ch_0;
                  v93 = v94;
                }
                else
                {
                  v93 = ch_0;
                }
                linea->data[v92] = v93;
                linea->size = v92 + 1;
              }
              goto LABEL_540;
            }
            hi = text->kanji_buf;
            lo = ch_0;
            if ( HTCJK == JAPANESE )
            {
              if ( text->kcode != JIS )
              {
                if ( lo <= 0x3Fu
                  || lo == 127
                  || lo > 0xFCu
                  || (hi <= 0x80u || hi > 0x9Fu) && (hi <= 0xDFu || hi > 0xEFu) )
                {
                  text->kcode = hi > 0xA0u && hi != 0xFF && lo > 0xA0u && lo != 0xFF
                             || hi == 0x8E && lo > 0xA0u && lo <= 0xDFu;
                }
                else if ( (hi <= 0xA0u || lo <= 0xA0u || lo == 0xFF) && (hi != 0x8E || lo <= 0xA0u || lo > 0xDFu) )
                {
                  text->kcode = SJIS;
                }
                else if ( text->specified_kcode )
                {
                  text->kcode = text->specified_kcode;
                }
                else if ( text->detected_kcode == DET_EUC )
                {
                  text->kcode = EUC;
                }
                else if ( text->detected_kcode )
                {
                  if ( hi == 0x8E && lo > 0xA0u && lo <= 0xDFu && text->kcode != EUC )
                    text->kcode = SJIS;
                }
                else
                {
                  text->kcode = SJIS;
                }
              }
              if ( kanji_code == EUC )
              {
                if ( text->kcode == SJIS )
                {
                  SJIS_TO_EUC1(hi, lo, tmp);
                  v13 = linea->size;
                  linea->data[v13] = tmp[0];
                  linea->size = v13 + 1;
                  v14 = linea->size;
                  linea->data[v14] = tmp[1];
                  linea->size = v14 + 1;
                }
                else if ( (hi <= 0xA0u || hi == 0xFF || lo <= 0xA0u || lo == 0xFF)
                       && (hi != 0x8E || lo <= 0xA0u || lo > 0xDFu) )
                {
                  if ( WWW_TraceFlag[0] )
                  {
                    v17 = lo;
                    v18 = hi;
                    v19 = TraceFP();
                    fprintf(v19, "This character (%X:%X) doesn't seem Japanese\n", v18, v17);
                  }
                  v20 = linea->size;
                  linea->data[v20] = 61;
                  linea->size = v20 + 1;
                  v21 = linea->size;
                  linea->data[v21] = 61;
                  linea->size = v21 + 1;
                }
                else
                {
                  JISx0201TO0208_EUC(hi, lo, &hi, &lo);
                  v15 = linea->size;
                  linea->data[v15] = hi;
                  linea->size = v15 + 1;
                  v16 = linea->size;
                  linea->data[v16] = lo;
                  linea->size = v16 + 1;
                }
                goto LABEL_521;
              }
              if ( kanji_code != SJIS )
              {
LABEL_521:
                text->kanji_buf = 0;
LABEL_540:
                linea->data[linea->size] = 0;
                if ( (font & 0x10) != 0 )
                  HText_appendCharacter(text, 1);
                if ( ch_0 == 7 )
                {
                  ++ctrl_chars_on_this_line;
                  text->permissible_split = text->last_line->size;
                }
                if ( ch_0 == 8 )
                  ++ctrl_chars_on_this_line;
                return;
              }
              if ( text->kcode == EUC || text->kcode == JIS )
              {
                EUC_TO_SJIS1(hi, lo, tmp);
                v22 = linea->size;
                linea->data[v22] = tmp[0];
                linea->size = v22 + 1;
                v23 = linea->size;
                linea->data[v23] = tmp[1];
                linea->size = v23 + 1;
                goto LABEL_521;
              }
              if ( lo <= 0x3Fu || lo == 127 || lo > 0xFCu || (hi <= 0x80u || hi > 0x9Fu) && (hi <= 0xDFu || hi > 0xEFu) )
              {
                v24 = linea->size;
                linea->data[v24] = 61;
                linea->size = v24 + 1;
                v25 = linea->size;
                linea->data[v25] = 61;
                linea->size = v25 + 1;
                if ( WWW_TraceFlag[0] )
                {
                  v26 = lo;
                  v27 = hi;
                  v28 = TraceFP();
                  fprintf(v28, "This character (%X:%X) doesn't seem Japanese\n", v27, v26);
                }
                goto LABEL_521;
              }
            }
            v29 = linea->size;
            linea->data[v29] = hi;
            linea->size = v29 + 1;
            v30 = linea->size;
            linea->data[v30] = lo;
            linea->size = v30 + 1;
            goto LABEL_521;
          }
          if ( HTOutputFormat == WWW_SOURCE )
          {
            if ( line->size <= 0x3FEu )
              goto LABEL_440;
          }
          else if ( (dump_output_immediately || crawl && traversal) && dont_wrap_pre && line->size <= 0x3FEu )
          {
            goto LABEL_440;
          }
        }
        else
        {
LABEL_438:
          if ( line->size <= 0x3FEu )
            goto LABEL_440;
        }
        split_line(text, 0);
        goto LABEL_440;
      }
    }
  }
}
// 806451E: conditional instruction was optimized away because %hi.1 is in (E0..EF)

//----- (08064B7D) --------------------------------------------------------
void __cdecl internal_HTC(HText *text, int style, int dir)
{
  HTStyleChange *v3; // ecx
  HTStyleChange *v4; // ecx
  HTStyleChange *v5; // ecx
  HTLine *line; // [esp+Ch] [ebp-8h]

  if ( text )
  {
    line = text->last_line;
    if ( line->numstyles
      && !dir
      && (*(_BYTE *)&line->styles[-(1 - line->numstyles)] & 3) != 0
      && *((unsigned __int16 *)&line->styles[-(1 - line->numstyles)] + 1) == style
      && *(_WORD *)&line->styles[-(1 - line->numstyles)] >> 2 == line->size - ctrl_chars_on_this_line )
    {
      --line->numstyles;
    }
    else if ( line->numstyles <= 0x3Fu )
    {
      v3 = &line->styles[line->numstyles];
      *(_WORD *)v3 = (4 * (line->size & 0x3FFF)) | *(_WORD *)v3 & 3;
      if ( *(_WORD *)&line->styles[line->numstyles] >> 2 >= ctrl_chars_on_this_line )
      {
        v4 = &line->styles[line->numstyles];
        *(_WORD *)v4 = (4 * (((*(_WORD *)v4 >> 2) - ctrl_chars_on_this_line) & 0x3FFF)) | *(_WORD *)v4 & 3;
      }
      *((_WORD *)&line->styles[line->numstyles] + 1) = style;
      v5 = &line->styles[line->numstyles];
      *(_BYTE *)v5 = dir & 3 | *(_BYTE *)v5 & 0xFC;
      ++line->numstyles;
    }
  }
}

//----- (08064D85) --------------------------------------------------------
void __cdecl HText_setLastChar(HText *text, char ch_0)
{
  if ( text )
    text->LastChar = ch_0;
}

//----- (08064DA6) --------------------------------------------------------
char __cdecl HText_getLastChar(HText *text)
{
  if ( text )
    return text->LastChar;
  else
    return 0;
}

//----- (08064DCB) --------------------------------------------------------
void __cdecl HText_setIgnoreExcess(HText *text, BOOLEAN ignore)
{
  if ( text )
    text->IgnoreExcess = ignore;
}

//----- (08064DEC) --------------------------------------------------------
int __cdecl HText_insertBlanksInStblLines(HText *me, int ncols)
{
  FILE *v2; // eax
  int v3; // ebx
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // edx
  FILE *v7; // edx
  int v8; // ebx
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  int v13; // ebx
  FILE *v14; // edx
  FILE *v15; // eax
  int v18; // [esp+24h] [ebp-74h]
  int v19; // [esp+28h] [ebp-70h]
  int v20; // [esp+2Ch] [ebp-6Ch]
  int ip_1; // [esp+34h] [ebp-64h]
  int width_0; // [esp+38h] [ebp-60h]
  int width; // [esp+3Ch] [ebp-5Ch]
  int ip_0; // [esp+40h] [ebp-58h]
  int i; // [esp+44h] [ebp-54h]
  HTStyle *style; // [esp+48h] [ebp-50h]
  int table_offset; // [esp+4Ch] [ebp-4Ch]
  int spare; // [esp+50h] [ebp-48h]
  int indent; // [esp+54h] [ebp-44h]
  int max_width; // [esp+58h] [ebp-40h]
  int lines_changed; // [esp+5Ch] [ebp-3Ch]
  int added_chars_before; // [esp+60h] [ebp-38h]
  int last_nonempty; // [esp+64h] [ebp-34h]
  int first_lineno_pass2; // [esp+68h] [ebp-30h]
  int last_lineno; // [esp+6Ch] [ebp-2Ch]
  int lineno; // [esp+74h] [ebp-24h]
  int linenoa; // [esp+74h] [ebp-24h]
  int ninserts; // [esp+78h] [ebp-20h]
  int *newpos; // [esp+7Ch] [ebp-1Ch]
  int *oldpos; // [esp+80h] [ebp-18h]
  HTLine *first_line; // [esp+84h] [ebp-14h]
  HTLine *mod_line; // [esp+88h] [ebp-10h]
  HTLine *line; // [esp+8Ch] [ebp-Ch]
  HTLine *linea; // [esp+8Ch] [ebp-Ch]
  __int16 alignment; // [esp+92h] [ebp-6h]

  first_line = 0;
  last_nonempty = -1;
  added_chars_before = 0;
  lines_changed = 0;
  max_width = 0;
  i = 0;
  lineno = Stbl_getStartLine(me->stbl);
  if ( lineno < 0 || me->Lines < lineno )
    return -1;
  oldpos = (int *)calloc(2 * ncols, 4u);
  if ( !oldpos )
    return -1;
  newpos = &oldpos[ncols];
  line = me->last_line->next;
  while ( i < lineno )
  {
    if ( !line )
    {
      free(oldpos);
      return -1;
    }
    line = line->next;
    ++i;
  }
  last_lineno = me->Lines;
  first_lineno_pass2 = last_lineno;
  while ( line && lineno <= last_lineno )
  {
    ninserts = Stbl_getFixupPositions(me->stbl, lineno, oldpos, newpos);
    if ( ninserts < 0 )
      goto LABEL_63;
    if ( !first_line )
    {
      first_line = line;
      first_lineno_pass2 = lineno;
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "line %d first to adjust  --  newpos:", lineno);
        for ( ip_0 = 0; ip_0 < ncols; ++ip_0 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v3 = newpos[ip_0];
            v4 = TraceFP();
            fprintf(v4, " %d", v3);
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          v5 = TraceFP();
          fprintf(v5, "\n");
        }
      }
    }
    if ( me->last_line == line )
    {
      if ( !line->size || HText_TrueEmptyLine(line, me, 0) )
        goto LABEL_63;
      if ( first_line == line )
        first_line = 0;
      split_line(me, 0);
      line = me->last_line->prev;
      if ( !first_line )
        first_line = me->last_line->prev;
    }
    if ( ninserts )
    {
      mod_line = insert_blanks_in_line(line, lineno, me, &me->last_anchor_before_stbl, ninserts, oldpos, newpos);
      if ( mod_line )
      {
        if ( me->last_line == line )
          me->last_line = mod_line;
        else
          added_chars_before += mod_line->size - line->size;
        line->prev->next = mod_line;
        line->next->prev = mod_line;
        ++lines_changed;
        if ( line == first_line )
          first_line = mod_line;
        line = mod_line;
        if ( me->first_lineno_last_disp_partial >= 0 )
        {
          if ( me->first_lineno_last_disp_partial < lineno )
          {
            if ( me->last_lineno_last_disp_partial >= lineno )
              me->last_lineno_last_disp_partial = lineno - 1;
          }
          else
          {
            ResetPartialLinenos(me);
          }
        }
      }
      width_0 = HText_TrueLineSize(line, me, 0);
      if ( width_0 > max_width )
        max_width = width_0;
      if ( nested_tables && width_0 && last_nonempty < lineno )
        last_nonempty = lineno;
      if ( WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, "line %d true/max width:%d/%d oldpos:", lineno, width_0, max_width);
        for ( ip_1 = 0; ip_1 < ninserts; ++ip_1 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v8 = oldpos[ip_1];
            v9 = TraceFP();
            fprintf(v9, " %d", v8);
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          v10 = TraceFP();
          fprintf(v10, "\n");
        }
      }
    }
    else
    {
      width = HText_TrueLineSize(line, me, 0);
      if ( width > max_width )
        max_width = width;
      if ( nested_tables && width && last_nonempty < lineno )
        last_nonempty = lineno;
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "line %d true/max width:%d/%d oldpos: NONE\n", lineno, width, max_width);
      }
    }
LABEL_63:
    line = line->next;
    ++lineno;
  }
  style = me->style;
  alignment = Stbl_getAlignment(me->stbl);
  if ( alignment == -1 )
    alignment = style->alignment;
  indent = style->leftIndent;
  if ( me->stbl )
  {
    if ( LYtableCols > 0 )
    {
      v19 = LYcols * LYtableCols / 12;
    }
    else
    {
      if ( LYwideLines )
        v20 = 1014;
      else
        v20 = LYcols;
      v19 = v20;
    }
    v18 = v19 - (LYShowScrollbar != 0);
  }
  else
  {
    v18 = LYcols - (LYShowScrollbar != 0);
  }
  spare = v18 - style->rightIndent - indent - max_width;
  if ( spare >= 0 || spare + style->rightIndent < 0 )
  {
    if ( spare < 0 )
      spare += style->rightIndent;
  }
  else
  {
    spare = 0;
  }
  if ( spare >= 0 || indent + spare < 0 )
  {
    if ( spare < 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v11 = TraceFP();
        fprintf(v11, "BUG: insertBlanks: resulting table too wide by %d positions!\n", -spare);
      }
      spare = 0;
      indent = 0;
    }
  }
  else
  {
    indent += spare;
    spare = 0;
  }
  if ( alignment == 2 )
  {
    table_offset = indent + spare;
  }
  else if ( alignment == 3 )
  {
    table_offset = indent + spare / 2;
  }
  else
  {
    table_offset = indent;
  }
  if ( WWW_TraceFlag[0] )
  {
    v12 = TraceFP();
    fprintf(v12, "changing offsets");
  }
  linea = first_line;
  for ( linenoa = first_lineno_pass2; linea && linenoa <= last_lineno && me->last_line != linea; ++linenoa )
  {
    if ( Stbl_getFixupPositions(me->stbl, linenoa, oldpos, newpos) >= 0 && linea->offset != table_offset )
    {
      if ( me->first_lineno_last_disp_partial >= 0 )
      {
        if ( me->first_lineno_last_disp_partial < linenoa )
        {
          if ( me->last_lineno_last_disp_partial >= linenoa )
            me->last_lineno_last_disp_partial = linenoa - 1;
        }
        else
        {
          ResetPartialLinenos(me);
        }
      }
      if ( WWW_TraceFlag[0] )
      {
        v13 = table_offset - linea->offset;
        v14 = TraceFP();
        fprintf(v14, " %d:%d", linenoa, v13);
      }
      linea->offset = table_offset & ~(unsigned __int16)(table_offset >> 31);
    }
    linea = linea->next;
  }
  if ( nested_tables && max_width )
    Stbl_update_enclosing(me->stbl, max_width, last_nonempty);
  if ( WWW_TraceFlag[0] )
  {
    v15 = TraceFP();
    fprintf(v15, " %d:done\n", linenoa);
  }
  free(oldpos);
  return lines_changed;
}

//----- (08065643) --------------------------------------------------------
void __cdecl HText_cancelStbl(HText *me)
{
  FILE *v1; // eax
  FILE *v2; // eax
  STable_info *enclosing; // [esp+10h] [ebp-8h]
  STable_info *stbl; // [esp+14h] [ebp-4h]

  if ( me && me->stbl )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "cancelStbl: ok, will do.\n");
    }
    if ( nested_tables )
    {
      for ( stbl = me->stbl; stbl; stbl = enclosing )
      {
        enclosing = Stbl_get_enclosing(stbl);
        Stbl_free(stbl);
      }
    }
    else
    {
      Stbl_free(me->stbl);
    }
    me->stbl = 0;
  }
  else if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "cancelStbl: ignored.\n");
  }
}

//----- (08065709) --------------------------------------------------------
void __cdecl HText_startStblTABLE(HText *me, __int16 alignment)
{
  FILE *v2; // eax
  FILE *v3; // eax
  STable_info *current; // [esp+24h] [ebp-4h]

  current = me->stbl;
  if ( me )
  {
    if ( nested_tables )
    {
      if ( current )
        split_line(me, 0);
    }
    else if ( me->stbl )
    {
      HText_cancelStbl(me);
    }
    me->stbl = Stbl_startTABLE(alignment);
    if ( me->stbl )
    {
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "startStblTABLE: started.\n");
      }
      if ( nested_tables )
        Stbl_set_enclosing(me->stbl, current, me->last_anchor_before_stbl);
      me->last_anchor_before_stbl = me->last_anchor;
    }
    else if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "startStblTABLE: failed.\n");
    }
  }
}

//----- (08065818) --------------------------------------------------------
void __cdecl free_enclosed_stbl(HText *me)
{
  STable_info *stbl; // ebx
  FILE *v2; // eax
  STable_info *object; // [esp+10h] [ebp-18h]
  HTList *list; // [esp+20h] [ebp-8h]

  if ( me->enclosed_stbl )
  {
    list = me->enclosed_stbl;
    while ( 1 )
    {
      if ( list && (list = list->next) != 0 )
        object = (STable_info *)list->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( WWW_TraceFlag[0] )
      {
        stbl = me->stbl;
        v2 = TraceFP();
        fprintf(v2, "endStblTABLE: finally free %p\n", stbl);
      }
      Stbl_free(object);
    }
    HTList_delete(me->enclosed_stbl);
    me->enclosed_stbl = 0;
  }
}

//----- (080658CE) --------------------------------------------------------
int __cdecl HText_endStblTABLE(HText *me)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  STable_info *stbl; // ebx
  FILE *v6; // eax
  FILE *v7; // eax
  const char *v10; // [esp+20h] [ebp-18h]
  STable_info *enclosing; // [esp+28h] [ebp-10h]
  int lines_changed; // [esp+2Ch] [ebp-Ch]
  int ncols; // [esp+30h] [ebp-8h]

  enclosing = 0;
  if ( me && me->stbl )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "endStblTABLE: ok, will try.\n");
    }
    ncols = Stbl_finishTABLE(me->stbl);
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "endStblTABLE: ncols = %d.\n", ncols);
    }
    if ( ncols > 0 )
    {
      lines_changed = HText_insertBlanksInStblLines(me, ncols);
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "endStblTABLE: changed %d lines, done.\n", lines_changed);
      }
      NumOfLines_partial -= lines_changed;
    }
    if ( nested_tables )
    {
      enclosing = Stbl_get_enclosing(me->stbl);
      me->last_anchor_before_stbl = Stbl_get_last_anchor_before(me->stbl);
      if ( enclosing )
      {
        if ( !me->enclosed_stbl )
          me->enclosed_stbl = HTList_new();
        HTList_addObject(me->enclosed_stbl, me->stbl);
        if ( WWW_TraceFlag[0] )
        {
          stbl = me->stbl;
          v6 = TraceFP();
          fprintf(v6, "endStblTABLE: postpone free %p\n", stbl);
        }
      }
      else
      {
        Stbl_free(me->stbl);
        free_enclosed_stbl(me);
      }
      me->stbl = enclosing;
    }
    else
    {
      Stbl_free(me->stbl);
      me->stbl = 0;
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( enclosing )
        v10 = &byte_814CBAC;
      else
        v10 = " NO";
      v7 = TraceFP();
      fprintf(v7, "endStblTABLE: have%s enclosing table (%p)\n", v10, enclosing);
    }
    return enclosing != 0;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "endStblTABLE: ignored.\n");
    }
    free_enclosed_stbl(me);
    return 0;
  }
}

//----- (08065B34) --------------------------------------------------------
void __cdecl HText_startStblTR(HText *me, __int16 alignment)
{
  if ( me && me->stbl && Stbl_addRowToTable(me->stbl, alignment, me->Lines) < 0 )
    HText_cancelStbl(me);
}

//----- (08065B8B) --------------------------------------------------------
void __cdecl HText_endStblTR(HText *me)
{
  ;
}

//----- (08065BA1) --------------------------------------------------------
void __cdecl HText_startStblTD(HText *me, int colspan, int rowspan, __int16 alignment, BOOLEAN isheader)
{
  FILE *v5; // eax
  FILE *v6; // eax
  int LineOffset; // [esp+18h] [ebp-20h]
  int pos; // [esp+20h] [ebp-18h]

  if ( me && me->stbl )
  {
    if ( colspan < 0 )
      colspan = 1;
    if ( colspan > 200 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "*** COLSPAN=%d is too large, ignored!\n", colspan);
      }
      colspan = 1;
    }
    if ( rowspan > 200 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "*** ROWSPAN=%d is too large, ignored!\n", rowspan);
      }
      rowspan = 1;
    }
    pos = HText_LastLineSize(me, 0);
    LineOffset = HText_LastLineOffset(me);
    if ( Stbl_addCellToTable(me->stbl, colspan, rowspan, alignment, isheader, me->Lines, LineOffset, pos) < 0 )
      HText_cancelStbl(me);
  }
}

//----- (08065CD2) --------------------------------------------------------
void __cdecl HText_endStblTD(HText *me)
{
  int LineSize; // ebx
  int LineOffset; // eax

  if ( me && me->stbl )
  {
    LineSize = HText_LastLineSize(me, 0);
    LineOffset = HText_LastLineOffset(me);
    if ( Stbl_finishCellInTable(me->stbl, 1, me->Lines, LineOffset, LineSize) < 0 )
      HText_cancelStbl(me);
  }
}

//----- (08065D51) --------------------------------------------------------
void __cdecl HText_startStblCOL(HText *me, int span, __int16 alignment, BOOLEAN isgroup)
{
  FILE *v4; // eax

  if ( me && me->stbl )
  {
    if ( span <= 0 )
      span = 1;
    if ( span > 200 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "*** SPAN=%d is too large, ignored!\n", span);
      }
      span = 1;
    }
    if ( Stbl_addColInfo(me->stbl, span, alignment, isgroup) < 0 )
      HText_cancelStbl(me);
  }
}

//----- (08065DFF) --------------------------------------------------------
void __cdecl HText_endStblCOLGROUP(HText *me)
{
  if ( me && me->stbl && Stbl_finishColGroup(me->stbl) < 0 )
    HText_cancelStbl(me);
}

//----- (08065E3A) --------------------------------------------------------
void __cdecl HText_startStblRowGroup(HText *me, __int16 alignment)
{
  if ( me && me->stbl && Stbl_addRowGroup(me->stbl, alignment) < 0 )
    HText_cancelStbl(me);
}

//----- (08065E84) --------------------------------------------------------
void __cdecl add_link_number(HText *text, TextAnchor *a, BOOLEAN save_position)
{
  int saved_linenum; // [esp+1Ch] [ebp-2Ch]
  char saved_lastchar; // [esp+23h] [ebp-25h]
  char marker[32]; // [esp+24h] [ebp-24h] BYREF
  unsigned int v6; // [esp+44h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  if ( a->number > 0 && (!text->source || !psrcview_no_anchor_numbering[0]) && (keypad_mode == 1 || keypad_mode == 2) )
  {
    saved_lastchar = text->LastChar;
    saved_linenum = text->Lines;
    sprintf(marker, "[%d]", a->number);
    HText_appendText(text, marker);
    if ( saved_linenum && text->Lines && saved_lastchar != 32 )
      text->LastChar = 93;
    if ( save_position )
    {
      a->line_num = text->Lines;
      a->line_pos = text->last_line->size;
    }
  }
}

//----- (08065F90) --------------------------------------------------------
int __cdecl HText_beginAnchor(HText *text, BOOLEAN underline, HTChildAnchor *anc)
{
  TextAnchor *a; // [esp+24h] [ebp-4h]

  a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool, 0x34u);
  if ( !a )
    outofmem("./GridText.c", "HText_beginAnchor");
  a->inUnderline = underline;
  a->sgml_offset = SGML_offset();
  a->line_num = text->Lines;
  a->line_pos = text->last_line->size;
  if ( text->last_anchor )
    text->last_anchor->next = a;
  else
    text->first_anchor = a;
  a->next = 0;
  a->anchor = anc;
  a->extent = 0;
  a->link_type = 1;
  text->last_anchor = a;
  if ( HTAnchor_followLink(anc) )
    a->number = ++text->last_anchor_number;
  else
    a->number = 0;
  if ( number_links_on_left )
    add_link_number(text, a, 1);
  return a->number;
}

//----- (080660CF) --------------------------------------------------------
BOOLEAN __cdecl HText_endAnchor0(HText *text, int number, int really)
{
  int link_type; // ebx
  int v4; // esi
  FILE *v5; // eax
  FILE *v6; // eax
  HTAnchor *v7; // eax
  int v8; // ebx
  int v9; // esi
  int v10; // edi
  FILE *v11; // edx
  int extent; // ebx
  int line_pos; // esi
  int line_num; // edi
  FILE *v15; // edx
  int v16; // ebx
  int v17; // esi
  int v18; // edi
  FILE *v19; // edx
  bool v22; // [esp+20h] [ebp-58h]
  __int16 v23; // [esp+26h] [ebp-52h]
  int v24; // [esp+28h] [ebp-50h]
  TextAnchor *anc; // [esp+34h] [ebp-44h]
  TextAnchor *anca; // [esp+34h] [ebp-44h]
  int NumSize; // [esp+38h] [ebp-40h]
  int NumSizea; // [esp+38h] [ebp-40h]
  int NumSizeb; // [esp+38h] [ebp-40h]
  __int16 extent_adjust; // [esp+3Ch] [ebp-3Ch]
  __int16 extent_adjusta; // [esp+3Ch] [ebp-3Ch]
  int BlankExtent; // [esp+40h] [ebp-38h]
  int CurBlankExtent; // [esp+44h] [ebp-34h]
  HTLine *start; // [esp+48h] [ebp-30h]
  HTLine *starta; // [esp+48h] [ebp-30h]
  HTLine *prev; // [esp+4Ch] [ebp-2Ch]
  HTLine *last; // [esp+50h] [ebp-28h]
  int l; // [esp+54h] [ebp-24h]
  int k; // [esp+58h] [ebp-20h]
  int ka; // [esp+58h] [ebp-20h]
  int kb; // [esp+58h] [ebp-20h]
  int kc; // [esp+58h] [ebp-20h]
  int j; // [esp+5Ch] [ebp-1Ch]
  int ja; // [esp+5Ch] [ebp-1Ch]
  int jb; // [esp+5Ch] [ebp-1Ch]
  int jc; // [esp+5Ch] [ebp-1Ch]
  int jd; // [esp+5Ch] [ebp-1Ch]
  int je; // [esp+5Ch] [ebp-1Ch]
  int jf; // [esp+5Ch] [ebp-1Ch]
  int jg; // [esp+5Ch] [ebp-1Ch]
  int jh; // [esp+5Ch] [ebp-1Ch]
  int ji; // [esp+5Ch] [ebp-1Ch]
  int jj; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+60h] [ebp-18h]
  int ia; // [esp+60h] [ebp-18h]
  int ib; // [esp+60h] [ebp-18h]
  int ic; // [esp+60h] [ebp-18h]
  int id; // [esp+60h] [ebp-18h]
  TextAnchor *a; // [esp+64h] [ebp-14h]

  if ( number <= 0 || text->last_anchor->number == number )
  {
    a = text->last_anchor;
  }
  else
  {
    for ( a = text->first_anchor; a && a->number != number; a = a->next )
      ;
    if ( !a )
      a = text->last_anchor;
  }
  if ( WWW_TraceFlag[0] )
  {
    link_type = a->link_type;
    v4 = a->number;
    v5 = TraceFP();
    fprintf(v5, "GridText:HText_endAnchor0: number:%d link_type:%d\n", v4, link_type);
  }
  if ( a->link_type != 2 )
  {
    if ( a->number )
    {
      v22 = 0;
      if ( keypad_mode == 1 || keypad_mode == 2 )
      {
        if ( text->hiddenlinkflag
          || LYNoISMAPifUSEMAP[0]
          && (!text->node_anchor || !text->node_anchor->bookmark)
          && (v7 = HTAnchor_followLink(a->anchor), HTAnchor_isISMAPScript(v7)) )
        {
          v22 = 1;
        }
      }
      last = text->last_line;
      prev = last->prev;
      start = last;
      CurBlankExtent = 0;
      BlankExtent = 0;
      extent_adjust = 0;
      l = text->Lines;
      if ( a->line_num < l )
      {
        for ( i = last->size; i > 0 && ((*__ctype_b_loc())[(unsigned __int8)last->data[i - 1]] & 0x2000) != 0; --i )
          --extent_adjust;
      }
      while ( a->line_num < l )
      {
        extent_adjust += start->size;
        start = start->prev;
        --l;
      }
      extent_adjusta = start->size - a->line_pos + extent_adjust;
      starta = last;
      a->extent += extent_adjusta;
      if ( a->extent <= (int)last->size )
        ia = a->extent;
      else
        ia = last->size;
      j = last->size - ia;
      k = j;
      while ( last->size > j
           && (last->data[j] > 2 && last->data[j] <= 8
            || ((*__ctype_b_loc())[(unsigned __int8)last->data[j]] & 0x2000) != 0
            || last->data[j] == 1
            || last->data[j] == 2) )
      {
        --ia;
        ++j;
      }
      if ( !ia )
      {
        if ( a->extent <= (int)last->size )
          BlankExtent = a->extent;
        else
          BlankExtent = last->size;
        CurBlankExtent = BlankExtent;
      }
      while ( !ia
           && (a->extent > CurBlankExtent
            || a->extent == CurBlankExtent
            && !k
            && text->last_line != prev
            && (!prev->size || prev->data[prev->size - 1] == 93)) )
      {
        starta = prev;
        ja = CurBlankExtent + prev->size - a->extent;
        k = ja;
        if ( ja >= 0 )
        {
          ia = a->extent - CurBlankExtent;
        }
        else
        {
          ja = 0;
          ia = prev->size;
        }
        while ( prev->size > ja
             && (prev->data[ja] > 2 && prev->data[ja] <= 8
              || ((*__ctype_b_loc())[(unsigned __int8)prev->data[ja]] & 0x2000) != 0
              || prev->data[ja] == 1
              || prev->data[ja] == 2) )
        {
          --ia;
          ++ja;
        }
        if ( !ia )
        {
          if ( a->extent <= CurBlankExtent + prev->size
            && (a->extent != CurBlankExtent + prev->size
             || k
             || prev->prev == text->last_line
             || prev->prev->size && prev->prev->data[prev->prev->size - 1] != 93) )
          {
            BlankExtent = a->extent;
            break;
          }
          CurBlankExtent += prev->size;
          BlankExtent = CurBlankExtent;
          prev = prev->prev;
        }
      }
      if ( !really )
      {
        a->extent -= extent_adjusta;
        return ia == 0;
      }
      if ( ia )
      {
        if ( !number_links_on_left )
          add_link_number(text, a, 0);
        a->show_anchor = 1;
        if ( BlankExtent && WWW_TraceFlag[0] )
        {
          extent = a->extent;
          line_pos = a->line_pos;
          line_num = a->line_num;
          v15 = TraceFP();
          fprintf(
            v15,
            "HText_endAnchor0: blanks (line,pos,ext,BlankExtent):(%d,%d,%d,%d)",
            line_num,
            line_pos,
            extent,
            BlankExtent);
        }
      }
      else
      {
        a->show_anchor = 0;
        if ( WWW_TraceFlag[0] )
        {
          v8 = a->extent;
          v9 = a->line_pos;
          v10 = a->line_num;
          v11 = TraceFP();
          fprintf(v11, "HText_endAnchor0: hidden (line,pos,ext,BlankExtent):(%d,%d,%d,%d)", v10, v9, v8, BlankExtent);
        }
        if ( v22 )
        {
          if ( starta == last )
          {
            jb = last->size - a->extent - 1;
          }
          else
          {
            prev = starta->prev;
            jb = CurBlankExtent + starta->size - a->extent - 1;
          }
          if ( jb < 0 )
            jb = 0;
          ib = jb;
          if ( starta->data[jb] == 93 )
          {
            jc = jb - 1;
            NumSize = 1;
            while ( jc >= 0 && ((*__ctype_b_loc())[(unsigned __int8)starta->data[jc]] & 0x800) != 0 )
            {
              --jc;
              ++NumSize;
            }
            while ( jc < 0 )
            {
              ++jc;
              --NumSize;
            }
            if ( starta->data[jc] == 91 )
            {
              NumSizea = NumSize + 1;
              if ( starta == last && (signed int)text->permissible_split > jc )
              {
                if ( (signed int)(text->permissible_split - NumSizea) >= jc )
                  text->permissible_split -= NumSizea;
                else
                  text->permissible_split = jc;
              }
              for ( ka = jc + NumSizea; starta->size > ka; ++ka )
                starta->data[jc++] = starta->data[ka];
              for ( anc = a; anc; anc = anc->next )
              {
                if ( anc->line_num == a->line_num && anc->line_pos >= NumSizea )
                  anc->line_pos -= NumSizea;
              }
              starta->size = jc;
              starta->data[jc] = 0;
              for ( jd = jc + 1; jd < ka; ++jd )
                starta->data[jd] = 0;
            }
            else if ( prev && prev->size > 1u )
            {
              kb = ib + 1;
              for ( je = prev->size - 1; je >= 0 && prev->data[je] > 2 && prev->data[je] <= 8; --je )
                ;
              ic = je + 1;
              while ( je >= 0 && ((*__ctype_b_loc())[(unsigned __int8)prev->data[je]] & 0x800) != 0 )
              {
                --je;
                ++NumSize;
              }
              while ( je < 0 )
              {
                ++je;
                --NumSize;
              }
              if ( prev->data[je] == 91 )
              {
                while ( prev->size > ic )
                  prev->data[je++] = prev->data[ic++];
                prev->size = je;
                prev->data[je] = 0;
                while ( je < ic )
                  prev->data[je++] = 0;
                if ( starta == last && text->permissible_split )
                {
                  if ( (signed int)text->permissible_split >= kb )
                    text->permissible_split -= kb;
                  else
                    text->permissible_split = 0;
                }
                jf = 0;
                id = kb;
                while ( starta->size > kb )
                  starta->data[jf++] = starta->data[kb++];
                for ( anca = a; anca; anca = anca->next )
                {
                  if ( anca->line_num == a->line_num && anca->line_pos >= id )
                    anca->line_pos -= id;
                }
                starta->size = jf;
                starta->data[jf] = 0;
                for ( jg = jf + 1; jg < kb; ++jg )
                  starta->data[jg] = 0;
              }
              else
              {
                a->show_anchor = 1;
              }
            }
            else
            {
              a->show_anchor = 1;
            }
          }
          else if ( prev && prev->size > 2u )
          {
            for ( jh = prev->size - 1; jh >= 0 && prev->data[jh] > 2 && prev->data[jh] <= 8; --jh )
              ;
            if ( jh < 0 )
              jh = 0;
            if ( jh > 1
              && prev->data[jh] == 93
              && ((*__ctype_b_loc())[(unsigned __int8)prev->data[jh - 1]] & 0x800) != 0 )
            {
              ji = jh - 1;
              NumSizeb = 1;
              while ( ji >= 0 && ((*__ctype_b_loc())[(unsigned __int8)prev->data[ji]] & 0x800) != 0 )
              {
                --ji;
                ++NumSizeb;
              }
              while ( ji < 0 )
              {
                ++ji;
                --NumSizeb;
              }
              if ( prev->data[ji] == 91 )
              {
                for ( kc = ji + NumSizeb + 1; prev->size > kc; ++kc )
                  prev->data[ji++] = prev->data[kc];
                prev->size = ji;
                prev->data[ji] = 0;
                for ( jj = ji + 1; jj < kc; ++jj )
                  prev->data[jj] = 0;
              }
              else
              {
                a->show_anchor = 1;
              }
            }
            else
            {
              a->show_anchor = 1;
            }
          }
          else
          {
            a->show_anchor = 1;
          }
        }
      }
      if ( a->show_anchor )
      {
        if ( a->extent <= BlankExtent )
          v23 = 0;
        else
          v23 = BlankExtent;
        a->extent -= v23;
      }
      else
      {
        a->extent = 0;
        if ( text->hiddenlinkflag )
        {
          a->number = 0;
          --text->last_anchor_number;
          HText_AddHiddenLink(text, a);
        }
      }
      if ( (BlankExtent || a->extent <= 0 || a->number <= 0) && WWW_TraceFlag[0] )
      {
        v24 = a->extent;
        v16 = a->line_pos;
        v17 = a->line_num;
        v18 = a->number;
        v19 = TraceFP();
        fprintf(v19, "->[%d](%d,%d,%d,%d)\n", v18, v17, v16, v24, BlankExtent);
      }
    }
    else
    {
      if ( !really )
        return 0;
      a->show_anchor = 0;
      a->extent = 0;
    }
    return 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    v6 = TraceFP();
    fprintf(v6, "BUG: HText_endAnchor0: internal error: last anchor was input field!\n");
  }
  return 0;
}

//----- (08066E6B) --------------------------------------------------------
void __cdecl HText_endAnchor(HText *text, int number)
{
  HText_endAnchor0(text, number, 1);
}

//----- (08066E8D) --------------------------------------------------------
BOOLEAN __cdecl HText_isAnchorBlank(HText *text, int number)
{
  return HText_endAnchor0(text, number, 0);
}

//----- (08066EAF) --------------------------------------------------------
void __cdecl HText_appendText(HText *text, const char *str)
{
  const char *p; // [esp+14h] [ebp-4h]

  if ( str && text->halted != 3 )
  {
    for ( p = str; *p; ++p )
      HText_appendCharacter(text, *p);
  }
}

//----- (08066EF9) --------------------------------------------------------
int __cdecl remove_special_attr_chars(char *buf)
{
  char *cp; // [esp+0h] [ebp-8h]
  int soft_newline_count; // [esp+4h] [ebp-4h]

  soft_newline_count = 0;
  for ( cp = buf; *cp; ++cp )
  {
    soft_newline_count += *cp == 8;
    if ( *cp <= 2 || *cp > 8 )
      *buf++ = *cp;
  }
  *buf = 0;
  return soft_newline_count;
}

//----- (08066F5B) --------------------------------------------------------
void __cdecl HText_endAppend(HText *text)
{
  FILE *v1; // eax
  char *data; // ebx
  FILE *v3; // eax
  char *v4; // ebx
  FILE *v5; // eax
  _line *next_to_the_last_line; // [esp+1Ch] [ebp-Ch]
  HTLine *line_ptr; // [esp+20h] [ebp-8h]

  if ( text )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "GridText: Entering HText_endAppend\n");
    }
    split_line(text, 0);
    if ( text->halted )
    {
      if ( text->stbl )
        HText_cancelStbl(text);
      LYFakeZap(0);
      text->halted = 0;
    }
    else if ( text->stbl )
    {
      HText_endStblTABLE(text);
    }
    line_ptr = text->last_line->next;
    while ( !text->last_line->data[0] && text->Lines > 2 )
    {
      next_to_the_last_line = text->last_line->prev;
      if ( WWW_TraceFlag[0] )
      {
        data = text->last_line->data;
        v3 = TraceFP();
        fprintf(v3, "GridText: Removing bottom blank line: `%s'\n", data);
      }
      next_to_the_last_line->next = line_ptr;
      line_ptr->prev = next_to_the_last_line;
      text->last_line = next_to_the_last_line;
      --text->Lines;
      if ( WWW_TraceFlag[0] )
      {
        v4 = text->last_line->data;
        v5 = TraceFP();
        fprintf(v5, "GridText: New bottom line: `%s'\n", v4);
      }
    }
    HText_trimHightext(text, 1, -1);
  }
}

//----- (080670E3) --------------------------------------------------------
void __cdecl HText_trimHightext(HText *text, BOOLEAN final, int stop_before)
{
  FILE *v3; // eax
  int Lines; // ebx
  FILE *v5; // edx
  int extent; // ebx
  int number; // esi
  int sgml_offset; // edi
  FILE *v9; // eax
  char *data; // ebx
  FILE *v11; // eax
  size_t v12; // ebx
  FILE *v13; // eax
  FILE *v14; // eax
  int v15; // ebx
  __int16 v16; // ax
  int v17; // esi
  int v18; // ebx
  FILE *v19; // eax
  int line_pos; // [esp+24h] [ebp-54h]
  int hi_offseta; // [esp+2Ch] [ebp-4Ch]
  int hi_offset; // [esp+2Ch] [ebp-4Ch]
  char *hi_string; // [esp+30h] [ebp-48h] BYREF
  HTLine *old_line_ptr2; // [esp+34h] [ebp-44h]
  int size; // [esp+38h] [ebp-40h]
  int anchor_col; // [esp+3Ch] [ebp-3Ch]
  int count_line; // [esp+40h] [ebp-38h]
  int actual_len; // [esp+44h] [ebp-34h]
  int hilite_len; // [esp+48h] [ebp-30h]
  char *hilite_str; // [esp+4Ch] [ebp-2Ch]
  HTLine *line_ptr2; // [esp+50h] [ebp-28h]
  HTLine *line_ptr; // [esp+54h] [ebp-24h]
  TextAnchor *prev_a; // [esp+58h] [ebp-20h]
  TextAnchor *anchor_ptr; // [esp+5Ch] [ebp-1Ch]
  int cur_shift; // [esp+60h] [ebp-18h]
  int cur_line; // [esp+64h] [ebp-14h]
  unsigned __int8 ch_0; // [esp+6Bh] [ebp-Dh]

  prev_a = 0;
  if ( text )
  {
    if ( final )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "GridText: Entering HText_trimHightext (final)\n");
      }
    }
    else
    {
      if ( stop_before < 0 || text->Lines < stop_before )
        stop_before = text->Lines;
      if ( WWW_TraceFlag[0] )
      {
        Lines = text->Lines;
        v5 = TraceFP();
        fprintf(v5, "GridText: Entering HText_trimHightext (partial: 0..%d/%d)\n", stop_before, Lines);
      }
    }
    line_ptr = text->last_line->next;
    cur_line = 0;
    anchor_ptr = text->first_anchor;
    while ( 2 )
    {
      if ( anchor_ptr )
      {
        while ( 1 )
        {
          while ( anchor_ptr->line_num > cur_line )
          {
            line_ptr = line_ptr->next;
            ++cur_line;
          }
          if ( !final )
          {
            if ( cur_line >= stop_before
              || anchor_ptr->line_num >= text->Lines - 1 && anchor_ptr->line_pos >= (int)text->last_line->prev->size )
            {
              return;
            }
            if ( !anchor_ptr->extent
              && anchor_ptr->number
              && (anchor_ptr->link_type & 1) != 0
              && !anchor_ptr->show_anchor
              && anchor_ptr->number == text->last_anchor_number )
            {
              goto LABEL_80;
            }
          }
          if ( LYGetHiTextStr(anchor_ptr, 0) )
            goto LABEL_80;
          if ( anchor_ptr->line_pos > (int)line_ptr->size )
            anchor_ptr->line_pos = line_ptr->size;
          if ( anchor_ptr->line_pos < 0 )
          {
            anchor_ptr->line_pos = 0;
            anchor_ptr->line_num = cur_line;
          }
          if ( WWW_TraceFlag[0] )
          {
            extent = anchor_ptr->extent;
            number = anchor_ptr->number;
            sgml_offset = anchor_ptr->sgml_offset;
            line_pos = anchor_ptr->line_pos;
            v9 = TraceFP();
            fprintf(
              v9,
              "GridText: Anchor found on line:%d col:%d [%05d:%d] ext:%d\n",
              cur_line,
              line_pos,
              sgml_offset,
              number,
              extent);
          }
          cur_shift = 0;
          if ( (anchor_ptr->link_type & 1) != 0 )
          {
            for ( ch_0 = line_ptr->data[anchor_ptr->line_pos];
                  ((*__ctype_b_loc())[ch_0] & 0x2000) != 0 || ch_0 > 2u && ch_0 <= 8u;
                  ch_0 = line_ptr->data[anchor_ptr->line_pos] )
            {
              ++anchor_ptr->line_pos;
              --anchor_ptr->extent;
              ++cur_shift;
            }
          }
          if ( anchor_ptr->extent < 0 )
            anchor_ptr->extent = 0;
          if ( WWW_TraceFlag[0] )
          {
            data = line_ptr->data;
            v11 = TraceFP();
            fprintf(v11, "anchor text: '%s'\n", data);
          }
          v12 = anchor_ptr->line_pos;
          if ( v12 < strlen(line_ptr->data) )
            goto LABEL_49;
          if ( text->Lines <= cur_line
            || !anchor_ptr->extent
            && anchor_ptr->line_pos == line_ptr->size
            && (!prev_a || prev_a->line_num <= anchor_ptr->line_num) )
          {
            break;
          }
          ++anchor_ptr->line_num;
          anchor_ptr->line_pos = 0;
          if ( WWW_TraceFlag[0] )
          {
            v13 = TraceFP();
            fprintf(v13, "found anchor at end of line\n");
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          v14 = TraceFP();
          fprintf(v14, "found anchor at end of line, leaving it there\n");
        }
LABEL_49:
        if ( anchor_ptr->extent <= 0 || anchor_ptr->line_pos < 0 )
        {
          LYClearHiText(anchor_ptr);
          LYSetHiText(anchor_ptr, &byte_814CBAC, 0);
        }
        else
        {
          size = line_ptr->size - anchor_ptr->line_pos;
          if ( anchor_ptr->extent < size )
            size = anchor_ptr->extent;
          LYClearHiText(anchor_ptr);
          LYSetHiText(anchor_ptr, &line_ptr->data[anchor_ptr->line_pos], size);
        }
        hilite_str = LYGetHiTextStr(anchor_ptr, 0);
        hilite_len = strlen(hilite_str);
        actual_len = anchor_ptr->extent;
        line_ptr2 = line_ptr;
        count_line = cur_line;
        while ( actual_len > hilite_len )
        {
          old_line_ptr2 = line_ptr2;
          ++count_line;
          line_ptr2 = line_ptr2->next;
          if ( !final && count_line >= stop_before )
          {
            LYClearHiText(anchor_ptr);
            break;
          }
          if ( text->last_line == old_line_ptr2 )
            break;
          if ( line_ptr2 )
          {
            hi_string = 0;
            hi_offseta = line_ptr2->offset;
            SNACopy(&hi_string, line_ptr2->data, actual_len - hilite_len);
            v15 = actual_len;
            actual_len = v15 - strlen(hi_string);
            hi_offset = remove_special_attr_chars(hi_string) + hi_offseta;
            if ( (anchor_ptr->link_type & 1) != 0 )
              LYTrimTrailing(hi_string);
            if ( hi_string && *hi_string )
            {
              LYAddHiText(anchor_ptr, hi_string, hi_offset);
            }
            else if ( actual_len > hilite_len )
            {
              LYAddHiText(anchor_ptr, &byte_814CBAC, hi_offset);
            }
            if ( hi_string )
            {
              free(hi_string);
              hi_string = 0;
            }
          }
        }
        if ( final || count_line < stop_before )
        {
          hilite_str = LYGetHiTextStr(anchor_ptr, 0);
          remove_special_attr_chars(hilite_str);
          if ( (anchor_ptr->link_type & 1) != 0 )
            LYTrimTrailing(hilite_str);
          anchor_col = anchor_ptr->line_pos;
          if ( anchor_ptr->line_pos > 0 )
          {
            v16 = LYstrExtent2(line_ptr->data, anchor_col);
            anchor_ptr->line_pos = v16;
            if ( line_ptr->data[0] == 8 )
              ++anchor_ptr->line_pos;
          }
          anchor_ptr->line_pos += line_ptr->offset;
          anchor_ptr->line_num = cur_line;
          if ( WWW_TraceFlag[0] )
          {
            v17 = anchor_ptr->number;
            v18 = anchor_ptr->line_pos;
            v19 = TraceFP();
            fprintf(
              v19,
              "GridText:     add link on line %d col %d [%d] %s\n",
              cur_line,
              v18,
              v17,
              "in HText_trimHightext");
          }
LABEL_80:
          prev_a = anchor_ptr;
          anchor_ptr = anchor_ptr->next;
          continue;
        }
      }
      break;
    }
  }
}

//----- (08067805) --------------------------------------------------------
HTParentAnchor *__cdecl HText_nodeAnchor(HText *text)
{
  return text->node_anchor;
}

//----- (0806780F) --------------------------------------------------------
HTChildAnchor *__cdecl HText_childNextNumber(int number, void **prev)
{
  TextAnchor *a; // [esp+10h] [ebp-4h]

  a = (TextAnchor *)*prev;
  if ( !HTMainText || number <= 0 )
    return 0;
  if ( number == 1 || !a )
    a = HTMainText->first_anchor;
  while ( a && a->number != number )
    a = a->next;
  if ( !a )
    return 0;
  *prev = a;
  return a->anchor;
}

//----- (0806788F) --------------------------------------------------------
void __cdecl HText_FormDescNumber(int number, const char **desc)
{
  TextAnchor *a; // [esp+14h] [ebp-4h]

  if ( desc )
  {
    if ( HTMainText && HTMainText->first_anchor && number > 0 )
    {
      for ( a = HTMainText->first_anchor; ; a = a->next )
      {
        if ( !a )
          goto LABEL_13;
        if ( a->number == number )
          break;
      }
      if ( a->input_field && a->input_field->type )
      {
LABEL_13:
        switch ( a->input_field->type )
        {
          case 1:
            *desc = gettext("text entry field");
            break;
          case 2:
            *desc = gettext("password entry field");
            break;
          case 3:
            *desc = gettext("checkbox");
            break;
          case 4:
            *desc = gettext("radio button");
            break;
          case 5:
            *desc = gettext("submit button");
            break;
          case 6:
            *desc = gettext("reset button");
            break;
          case 7:
            *desc = gettext("popup menu");
            break;
          case 8:
            *desc = gettext("hidden form field");
            break;
          case 9:
            *desc = gettext("text entry area");
            break;
          case 0xA:
            *desc = gettext("range entry field");
            break;
          case 0xB:
            *desc = gettext("file entry field");
            break;
          case 0xC:
            *desc = gettext("text-submit field");
            break;
          case 0xD:
            *desc = gettext("image-submit button");
            break;
          case 0xE:
            *desc = gettext("keygen field");
            break;
          default:
            *desc = gettext("unknown form field");
            break;
        }
        return;
      }
    }
    *desc = gettext("unknown field or link");
  }
}

//----- (08067AA2) --------------------------------------------------------
int __cdecl HTGetRelLinkNum(int num, int rel, int cur)
{
  HText *v3; // ebx
  FILE *v4; // edx
  int v5; // ebx
  FILE *v6; // edx
  FILE *v7; // edx
  int number; // ebx
  int line_num; // esi
  FILE *v10; // eax
  FILE *v11; // edx
  _BOOL4 v13; // [esp+20h] [ebp-38h]
  const char *v14; // [esp+24h] [ebp-34h]
  int curanchor; // [esp+34h] [ebp-24h]
  int curpos; // [esp+3Ch] [ebp-1Ch]
  int curline; // [esp+40h] [ebp-18h]
  int scrtop; // [esp+44h] [ebp-14h]
  TextAnchor *l; // [esp+48h] [ebp-10h]
  TextAnchor *a; // [esp+4Ch] [ebp-Ch]

  l = 0;
  scrtop = HText_getTopOfScreen();
  curline = links[cur].anchor_line_num;
  curpos = links[cur].lx;
  v13 = curline >= scrtop && scrtop + display_lines > curline;
  curanchor = links[cur].anchor_number;
  if ( WWW_TraceFlag[0] )
  {
    v3 = HTMainText;
    v4 = TraceFP();
    fprintf(v4, "HTGetRelLinkNum(%d,%d,%d) -- HTMainText=%p\n", num, rel, cur, v3);
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( v13 )
      v14 = "on_screen";
    else
      v14 = "0";
    v5 = display_lines;
    v6 = TraceFP();
    fprintf(v6, "  scrtop=%d, curline=%d, curanchor=%d, display_lines=%d, %s\n", scrtop, curline, curanchor, v5, v14);
  }
  if ( !HTMainText )
    return 0;
  if ( !rel )
    return num;
  if ( v13 && curanchor )
  {
    if ( WWW_TraceFlag[0] )
    {
      v7 = TraceFP();
      fprintf(v7, "curanchor=%d at line %d on screen\n", curanchor, curline);
    }
    if ( rel == 43 )
    {
      return num + curanchor;
    }
    else if ( rel == 45 )
    {
      return curanchor - num;
    }
    else
    {
      return num;
    }
  }
  else
  {
    for ( a = HTMainText->first_anchor; a; a = a->next )
    {
      if ( WWW_TraceFlag[0] )
      {
        number = a->number;
        line_num = a->line_num;
        v10 = TraceFP();
        fprintf(v10, "  a->line_num=%d, a->number=%d\n", line_num, number);
      }
      if ( a->line_num >= scrtop )
        break;
      if ( a->number )
      {
        l = a;
        curanchor = a->number;
      }
    }
    if ( WWW_TraceFlag[0] )
    {
      v11 = TraceFP();
      fprintf(v11, "  a=%p, l=%p, curanchor=%d\n", a, l, curanchor);
    }
    if ( v13 )
    {
      while ( a )
      {
        if ( a->number )
        {
          l = a;
          curanchor = a->number;
        }
        if ( a->line_num == curline && a->line_pos == curpos )
          break;
        a = a->next;
      }
    }
    if ( rel == 43 )
    {
      return num + curanchor;
    }
    else if ( rel == 45 )
    {
      if ( l )
      {
        return curanchor + 1 - num;
      }
      else
      {
        while ( a && !a->number )
          a = a->next;
        if ( a )
          return a->number - num;
        else
          return 0;
      }
    }
    else
    {
      return num;
    }
  }
}

//----- (08067DDA) --------------------------------------------------------
int __cdecl HTGetLinkInfo(int number, int want_go, int *go_line, int *linknum, char **hightext, char **lname)
{
  char *cp_freeme; // [esp+18h] [ebp-20h]
  int max_offset; // [esp+1Ch] [ebp-1Ch]
  int prev_prev_anchor_line; // [esp+20h] [ebp-18h]
  int prev_anchor_line; // [esp+24h] [ebp-14h]
  int anchors_this_screen; // [esp+28h] [ebp-10h]
  int anchors_this_line; // [esp+2Ch] [ebp-Ch]
  HTAnchor *link_dest; // [esp+30h] [ebp-8h]
  TextAnchor *a; // [esp+34h] [ebp-4h]

  anchors_this_line = 0;
  anchors_this_screen = 0;
  prev_anchor_line = -1;
  prev_prev_anchor_line = -1;
  if ( !HTMainText )
    return 0;
  for ( a = HTMainText->first_anchor; ; a = a->next )
  {
    if ( !a )
      return 0;
    if ( a->show_anchor && (a->link_type != 2 || a->input_field->type != 8) )
    {
      if ( a->line_num == prev_anchor_line )
      {
        ++anchors_this_line;
      }
      else
      {
        anchors_this_line = 1;
        prev_prev_anchor_line = prev_anchor_line;
        prev_anchor_line = a->line_num;
      }
      if ( a->line_num >= HTMainText->top_of_screen )
        ++anchors_this_screen;
    }
    if ( a->number == number )
      break;
  }
  if ( want_go || a->link_type == 2 )
  {
    if ( a->show_anchor )
    {
      if ( anchors_this_screen <= 0
        || anchors_this_screen > nlinks
        || a->line_num < HTMainText->top_of_screen
        || a->line_num >= HTMainText->top_of_screen + display_lines )
      {
        max_offset = 3;
        if ( display_lines <= 3 )
          max_offset = display_lines - 1;
        *go_line = prev_anchor_line - max_offset;
        if ( *go_line <= prev_prev_anchor_line )
          *go_line = prev_prev_anchor_line + 1;
        if ( *go_line < 0 )
          *go_line = 0;
        if ( linknum )
          *linknum = anchors_this_line - 1;
      }
      else
      {
        *go_line = HTMainText->top_of_screen;
        if ( linknum )
          *linknum = anchors_this_screen - 1;
      }
      return 8;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *hightext = LYGetHiTextStr(a, 0);
    link_dest = HTAnchor_followLink(a->anchor);
    if ( traversal )
      cp_freeme = stub_HTAnchor_address(link_dest);
    else
      cp_freeme = HTAnchor_address(link_dest);
    HTSACopy(lname, cp_freeme);
    if ( cp_freeme )
      free(cp_freeme);
    return 2;
  }
}

//----- (08068058) --------------------------------------------------------
BOOLEAN __cdecl same_anchor_or_field(int numberA, FormInfo *formA, int numberB, FormInfo *formB, BOOLEAN ta_same)
{
  if ( numberA > 0 || numberB > 0 )
  {
    if ( numberA == numberB )
      return 1;
    if ( !ta_same )
      return 0;
  }
  if ( !formA && !formB )
    return 0;
  if ( formA == formB )
    return 1;
  if ( !ta_same )
    return 0;
  if ( !formA || !formB )
    return 0;
  if ( formA->type != formB->type || formA->type != 9 || formB->type != 9 )
    return 0;
  if ( formA->number == formB->number )
    return !formA->name || !formB->name || strcmp(formA->name, formB->name) == 0;
  return 0;
}

//----- (08068152) --------------------------------------------------------
BOOLEAN __cdecl HText_TAHasMoreLines(int curlink, int direction)
{
  BOOLEAN v4; // [esp+18h] [ebp-30h]
  FormInfo *formB; // [esp+1Ch] [ebp-2Ch]
  FormInfo *formA; // [esp+24h] [ebp-24h]
  BOOLEAN v7; // [esp+28h] [ebp-20h]
  FormInfo *v8; // [esp+2Ch] [ebp-1Ch]
  FormInfo *v9; // [esp+34h] [ebp-14h]
  TextAnchor *prev_a; // [esp+40h] [ebp-8h]
  TextAnchor *a; // [esp+44h] [ebp-4h]
  TextAnchor *aa; // [esp+44h] [ebp-4h]

  prev_a = 0;
  if ( !HTMainText )
    return 0;
  if ( direction >= 0 )
  {
    for ( aa = HTMainText->first_anchor; ; aa = aa->next )
    {
      if ( !aa )
        return 0;
      if ( aa->link_type == 2 && links[curlink].l_form == aa->input_field )
        break;
      if ( links[curlink].anchor_number && aa->number >= links[curlink].anchor_number )
        return 0;
    }
    v7 = 0;
    if ( aa->next )
    {
      v8 = aa->next->link_type == 2 ? aa->next->input_field : 0;
      v9 = aa->link_type == 2 ? aa->input_field : 0;
      if ( same_anchor_or_field(aa->number, v9, aa->next->number, v8, 1) )
        return 1;
    }
    return v7;
  }
  else
  {
    for ( a = HTMainText->first_anchor; ; a = a->next )
    {
      if ( !a )
        return 0;
      if ( a->link_type == 2 && links[curlink].l_form == a->input_field )
        break;
      if ( links[curlink].anchor_number && a->number >= links[curlink].anchor_number )
        return 0;
      prev_a = a;
    }
    v4 = 0;
    if ( prev_a )
    {
      formB = prev_a->link_type == 2 ? prev_a->input_field : 0;
      formA = a->link_type == 2 ? a->input_field : 0;
      if ( same_anchor_or_field(a->number, formA, prev_a->number, formB, 1) )
        return 1;
    }
    return v4;
  }
}
// 80681C2: conditional instruction was optimized away because %a.4!=0
// 80682F8: conditional instruction was optimized away because %a.4!=0

//----- (080683EC) --------------------------------------------------------
int __cdecl HTGetLinkOrFieldStart(int curlink, int *go_line, int *linknum, int direction, BOOLEAN ta_skip)
{
  int v6; // [esp+20h] [ebp-88h]
  int v7; // [esp+20h] [ebp-88h]
  FormInfo *formB; // [esp+34h] [ebp-74h]
  FormInfo *formA; // [esp+3Ch] [ebp-6Ch]
  FormInfo *input_field; // [esp+44h] [ebp-64h]
  _FormInfo *l_form; // [esp+4Ch] [ebp-5Ch]
  FormInfo *v13; // [esp+54h] [ebp-54h]
  _FormInfo *v14; // [esp+5Ch] [ebp-4Ch]
  HTGetLinkOrFieldStart::agroup current; // [esp+64h] [ebp-44h] BYREF
  HTGetLinkOrFieldStart::agroup previous; // [esp+74h] [ebp-34h] BYREF
  int screensahead; // [esp+84h] [ebp-24h]
  int screensback; // [esp+88h] [ebp-20h]
  int max_offset; // [esp+8Ch] [ebp-1Ch]
  HTGetLinkOrFieldStart::agroup *group_to_go; // [esp+90h] [ebp-18h]
  int prev_prev_anchor_line; // [esp+94h] [ebp-14h]
  int prev_anchor_line; // [esp+98h] [ebp-10h]
  int anchors_this_line; // [esp+9Ch] [ebp-Ch]
  TextAnchor *a; // [esp+A0h] [ebp-8h]

  anchors_this_line = 0;
  prev_anchor_line = -1;
  prev_prev_anchor_line = -1;
  group_to_go = 0;
  if ( !HTMainText )
    return 0;
  current.anc = 0;
  previous.anc = 0;
  current.prev_anchor_line = -1;
  previous.prev_anchor_line = -1;
  current.anchors_this_line = 0;
  previous.anchors_this_line = 0;
  current.anchors_this_group = 0;
  previous.anchors_this_group = 0;
  for ( a = HTMainText->first_anchor; a; a = a->next )
  {
    if ( a->show_anchor && (a->link_type != 2 || a->input_field->type != 8) )
    {
      if ( a->line_num == prev_anchor_line )
      {
        ++anchors_this_line;
      }
      else
      {
        anchors_this_line = 1;
        prev_prev_anchor_line = prev_anchor_line;
        prev_anchor_line = a->line_num;
      }
      if ( current.anc
        && (a->link_type != 2 ? (formB = 0) : (formB = a->input_field),
            current.anc->link_type != 2 ? (formA = 0) : (formA = current.anc->input_field),
            same_anchor_or_field(current.anc->number, formA, a->number, formB, ta_skip)) )
      {
        ++current.anchors_this_group;
      }
      else
      {
        previous = current;
        current.anc = a;
        current.prev_anchor_line = prev_prev_anchor_line;
        current.anchors_this_line = anchors_this_line;
        current.anchors_this_group = 1;
      }
      if ( curlink < 0 )
      {
        if ( a->line_num >= HTMainText->top_of_screen )
        {
          if ( direction >= 0 )
          {
            if ( direction )
            {
              group_to_go = &current;
            }
            else if ( previous.anc )
            {
              group_to_go = &previous;
            }
            else
            {
              group_to_go = &current;
            }
          }
          else
          {
            group_to_go = &previous;
          }
          break;
        }
      }
      else
      {
        if ( a->link_type == 2 )
          input_field = a->input_field;
        else
          input_field = 0;
        if ( links[curlink].type == 1 )
          l_form = links[curlink].l_form;
        else
          l_form = 0;
        if ( same_anchor_or_field(links[curlink].anchor_number, l_form, a->number, input_field, ta_skip) )
        {
          if ( direction == -1 )
          {
            group_to_go = &previous;
            break;
          }
          if ( !direction )
          {
            group_to_go = &current;
            break;
          }
        }
        else if ( direction > 0 && previous.anc )
        {
          v13 = previous.anc->link_type == 2 ? previous.anc->input_field : 0;
          v14 = links[curlink].type == 1 ? links[curlink].l_form : 0;
          if ( same_anchor_or_field(links[curlink].anchor_number, v14, previous.anc->number, v13, ta_skip) )
          {
            group_to_go = &current;
            break;
          }
        }
      }
    }
  }
  if ( !group_to_go && curlink < 0 && direction <= 0 )
    group_to_go = &current;
  if ( !group_to_go )
    return 0;
  a = group_to_go->anc;
  if ( !a )
    return 0;
  if ( a->line_num < HTMainText->top_of_screen
    && a->line_num >= HTMainText->top_of_screen - display_lines
    && (curlink < 0 && group_to_go->anchors_this_group == 1
     || direction < 0
     && group_to_go != &current
     && current.anc
     && current.anc->line_num >= HTMainText->top_of_screen
     && group_to_go->anchors_this_group == 1
     || a->next && a->next->line_num >= HTMainText->top_of_screen) )
  {
    return 16;
  }
  if ( a->line_num > display_lines )
  {
    if ( a->line_num >= HTMainText->top_of_screen )
    {
      if ( HTMainText->Lines - a->line_num > display_lines )
      {
        if ( a->line_num < HTMainText->top_of_screen + display_lines )
        {
          max_offset = 3;
        }
        else
        {
          v7 = a->line_num - HTMainText->top_of_screen;
          screensahead = v7 / display_lines;
          max_offset = a->line_num - HTMainText->top_of_screen - v7 / display_lines * display_lines;
        }
      }
      else
      {
        max_offset = a->line_num + ~HTMainText->Lines + display_lines;
      }
    }
    else
    {
      v6 = HTMainText->top_of_screen - a->line_num + display_lines - 1;
      screensback = v6 / display_lines;
      max_offset = a->line_num + v6 / display_lines * display_lines - HTMainText->top_of_screen;
    }
  }
  else
  {
    max_offset = 0;
  }
  if ( max_offset >= 0 )
  {
    if ( max_offset >= display_lines )
      max_offset = display_lines - 1;
  }
  else
  {
    max_offset = 0;
  }
  *go_line = a->line_num - max_offset;
  if ( *go_line <= group_to_go->prev_anchor_line )
    *go_line = group_to_go->prev_anchor_line + 1;
  if ( *go_line < 0 )
    *go_line = 0;
  if ( linknum )
    *linknum = group_to_go->anchors_this_line - 1;
  return 8;
}
// 80684D2: conditional instruction was optimized away because %a.4!=0
// 8068596: conditional instruction was optimized away because %curlink.4>=0
// 80685A0: conditional instruction was optimized away because %a.4!=0
// 8068679: conditional instruction was optimized away because %curlink.4>=0

//----- (08068A53) --------------------------------------------------------
BOOLEAN __cdecl HText_getFirstTargetInLine(
        HText *text,
        int line_num,
        BOOLEAN utf_flag,
        int *offset,
        int *tLen,
        char **data,
        const char *target)
{
  const char *v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+30h] [ebp-28h]
  int i; // [esp+40h] [ebp-18h]
  int LenNeeded; // [esp+44h] [ebp-14h] BYREF
  int HitOffset; // [esp+48h] [ebp-10h] BYREF
  int LineOffset; // [esp+4Ch] [ebp-Ch]
  char *LineData; // [esp+50h] [ebp-8h]
  HTLine *line; // [esp+54h] [ebp-4h]

  if ( !text || line_num < 0 || text->Lines < line_num || !target || !*target )
    return 0;
  i = 0;
  for ( line = text->last_line->next; i < line_num && text->last_line != line; line = line->next )
  {
    if ( !line->next )
      return 0;
    ++i;
  }
  if ( !line && MEMORY[0x12] )
    return 0;
  LineData = line->data;
  LineOffset = line->offset;
  if ( case_sensitive )
    v9 = LYno_attr_mbcs_strstr(LineData, target, utf_flag, 1, &HitOffset, &LenNeeded);
  else
    v9 = LYno_attr_mbcs_case_strstr(LineData, target, utf_flag, 1, &HitOffset, &LenNeeded);
  if ( !v9 )
    return 0;
  v10 = LYwideLines ? 1014 : LYcols;
  if ( LenNeeded + LineOffset > v10 )
    return 0;
  *offset = LineOffset + HitOffset;
  *tLen = LenNeeded - HitOffset;
  HTSACopy(data, v9);
  remove_special_attr_chars(*data);
  return 1;
}

//----- (08068BFC) --------------------------------------------------------
int HText_getNumOfLines()
{
  if ( HTMainText )
    return HTMainText->Lines;
  else
    return 0;
}

//----- (08068C27) --------------------------------------------------------
int HText_getNumOfBytes()
{
  HTLine *line; // [esp+10h] [ebp-8h]
  int result; // [esp+14h] [ebp-4h]

  result = -1;
  if ( HTMainText )
  {
    for ( line = HTMainText->last_line->next; HTMainText->last_line != line; line = line->next )
      result += strlen(line->data) + 1;
  }
  return result;
}

//----- (08068C89) --------------------------------------------------------
const char *HText_getTitle()
{
  if ( HTMainText )
    return HTAnchor_title(HTMainText->node_anchor);
  else
    return 0;
}

//----- (08068CB8) --------------------------------------------------------
const char *HText_getStyle()
{
  if ( HTMainText )
    return HTAnchor_style(HTMainText->node_anchor);
  else
    return 0;
}

//----- (08068CE7) --------------------------------------------------------
const char *HText_getSugFname()
{
  if ( HTMainText )
    return HTAnchor_SugFname(HTMainText->node_anchor);
  else
    return 0;
}

//----- (08068D16) --------------------------------------------------------
void __cdecl HTCheckFnameForCompression(char **fname, HTParentAnchor *anchor, BOOLEAN strip_ok)
{
  int rootlen; // [esp+1Ch] [ebp-1Ch] BYREF
  CompressFileType second; // [esp+20h] [ebp-18h]
  CompressFileType method; // [esp+24h] [ebp-14h]
  const char *suffix; // [esp+28h] [ebp-10h]
  char *cp; // [esp+2Ch] [ebp-Ch]
  char *dot; // [esp+30h] [ebp-8h]
  char *fn; // [esp+34h] [ebp-4h]

  fn = *fname;
  dot = 0;
  cp = 0;
  suffix = &byte_814CBAC;
  if ( !fn )
    return;
  if ( !anchor )
    return;
  fn = LYPathLeaf(fn);
  if ( !*fn )
    return;
  method = HTContentToCompressType(anchor);
  if ( method == cftNone && !strip_ok )
    return;
  dot = strrchr(fn, 46);
  if ( dot && !strcasecomp(dot, ".tgz") )
  {
    if ( method == cftNone )
      memcpy(dot, ".tar", 5u);
    return;
  }
  dot = strrchr(fn, 46);
  if ( !dot )
    goto LABEL_22;
  rootlen = 0;
  if ( HTCompressFileType(fn, ".", &rootlen) )
  {
    if ( method == cftNone )
      *dot = 0;
    return;
  }
  second = HTCompressFileType(fn, "-_", &rootlen);
  if ( second )
  {
    cp = &fn[rootlen];
    if ( method )
    {
      *cp = 46;
      if ( second == cftCompress )
        LYUpperCase(cp);
      else
        LYLowerCase(cp);
    }
    else
    {
      if ( dot + 1 == cp )
        --cp;
      *cp = 0;
    }
  }
  else
  {
LABEL_22:
    suffix = HTCompressTypeToSuffix(method);
    if ( *suffix )
    {
      if ( !dot || (++dot, *dot) )
        HTSACat(fname, suffix);
      else
        HTSACat(fname, suffix + 1);
    }
  }
}

//----- (08068F21) --------------------------------------------------------
const char *HText_getLastModified()
{
  if ( HTMainText )
    return HTAnchor_last_modified(HTMainText->node_anchor);
  else
    return 0;
}

//----- (08068F50) --------------------------------------------------------
const char *HText_getDate()
{
  if ( HTMainText )
    return HTAnchor_date(HTMainText->node_anchor);
  else
    return 0;
}

//----- (08068F7F) --------------------------------------------------------
const char *HText_getServer()
{
  if ( HTMainText )
    return HTAnchor_server(HTMainText->node_anchor);
  else
    return 0;
}

//----- (08068FAE) --------------------------------------------------------
void __cdecl HText_pageDisplay(int line_num, char *target)
{
  FILE *v2; // eax
  FILE *v3; // eax
  int stop_before; // [esp+24h] [ebp-4h]

  if ( (debug_display_partial || LYTraceLogFP) && WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "GridText: HText_pageDisplay at line %d started\n", line_num);
  }
  if ( display_partial[0] )
  {
    stop_before = -1;
    if ( HTMainText && HTMainText->stbl )
      stop_before = Stbl_getStartLineDeep(HTMainText->stbl);
    HText_trimHightext(HTMainText, 0, stop_before);
  }
  display_page(HTMainText, line_num - 1, target);
  if ( display_partial[0] && debug_display_partial )
    LYSleepMsg();
  is_www_index = HTAnchor_isIndex(HTMainAnchor);
  if ( debug_display_partial || LYTraceLogFP )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "GridText: HText_pageDisplay finished\n");
    }
  }
}

//----- (080690D2) --------------------------------------------------------
int HText_pageHasPrevTarget()
{
  if ( HTMainText )
    return (unsigned __int8)HTMainText->page_has_target;
  else
    return 0;
}

//----- (080690FC) --------------------------------------------------------
int __cdecl HText_closestAnchor(HText *text, int offset)
{
  TextAnchor *closest; // [esp+Ch] [ebp-14h]
  TextAnchor *Anchor_ptr; // [esp+10h] [ebp-10h]
  int newdiff; // [esp+14h] [ebp-Ch]
  int absdiff; // [esp+18h] [ebp-8h]
  int result; // [esp+1Ch] [ebp-4h]

  result = -1;
  absdiff = 0;
  closest = 0;
  for ( Anchor_ptr = text->first_anchor; Anchor_ptr; Anchor_ptr = Anchor_ptr->next )
  {
    if ( Anchor_ptr->sgml_offset == offset )
    {
      result = Anchor_ptr->number;
      break;
    }
    newdiff = abs32(Anchor_ptr->sgml_offset - offset);
    if ( !absdiff || absdiff > newdiff )
    {
      absdiff = newdiff;
      closest = Anchor_ptr;
    }
  }
  if ( result < 0 && closest )
    return closest->number;
  return result;
}

//----- (0806919A) --------------------------------------------------------
int __cdecl HText_locateAnchor(HText *text, int anchor_number)
{
  TextAnchor *Anchor_ptr; // [esp+8h] [ebp-8h]
  int result; // [esp+Ch] [ebp-4h]

  result = -1;
  for ( Anchor_ptr = text->first_anchor; Anchor_ptr; Anchor_ptr = Anchor_ptr->next )
  {
    if ( Anchor_ptr->number == anchor_number )
      return Anchor_ptr->sgml_offset;
  }
  return result;
}

//----- (080691E5) --------------------------------------------------------
BOOLEAN __cdecl anchor_is_numbered(TextAnchor *Anchor_ptr)
{
  BOOLEAN result; // [esp+Fh] [ebp-1h]

  result = 0;
  if ( Anchor_ptr->show_anchor && (Anchor_ptr->link_type & 1) != 0 )
    return 1;
  if ( Anchor_ptr->link_type == 2 && Anchor_ptr->input_field->type != 8 )
    return 1;
  return result;
}

//----- (08069237) --------------------------------------------------------
int __cdecl HText_getAbsLineNumber(HText *text, int anchor_number)
{
  TextAnchor *Anchor_ptr; // [esp+Ch] [ebp-8h]
  int result; // [esp+10h] [ebp-4h]

  result = -1;
  if ( anchor_number >= 0 && text )
  {
    for ( Anchor_ptr = text->first_anchor; Anchor_ptr; Anchor_ptr = Anchor_ptr->next )
    {
      if ( anchor_is_numbered(Anchor_ptr) && Anchor_ptr->number == anchor_number )
        return Anchor_ptr->line_num;
    }
  }
  return result;
}

//----- (0806929D) --------------------------------------------------------
int __cdecl HText_anchorRelativeTo(HText *text, int top_lineno, int anchor_number)
{
  TextAnchor *Anchor_ptr; // [esp+8h] [ebp-Ch]
  int from_top; // [esp+Ch] [ebp-8h]
  int result; // [esp+10h] [ebp-4h]

  result = 0;
  from_top = 0;
  for ( Anchor_ptr = text->first_anchor; Anchor_ptr; Anchor_ptr = Anchor_ptr->next )
  {
    if ( Anchor_ptr->number == anchor_number )
      return from_top;
    if ( anchor_is_numbered(Anchor_ptr) && Anchor_ptr->line_num >= top_lineno )
      ++from_top;
  }
  return result;
}

//----- (0806930A) --------------------------------------------------------
int __cdecl HText_LinksInLines(HText *text, int line_num, int Lines)
{
  TextAnchor *Anchor_ptr; // [esp+4h] [ebp-10h]
  int end; // [esp+8h] [ebp-Ch]
  int total; // [esp+10h] [ebp-4h]

  total = 0;
  end = Lines + line_num - 1;
  if ( !text )
    return 0;
  for ( Anchor_ptr = text->first_anchor; Anchor_ptr && Anchor_ptr->line_num <= end; Anchor_ptr = Anchor_ptr->next )
  {
    if ( Anchor_ptr->line_num >= line_num - 1
      && Anchor_ptr->line_num < end
      && Anchor_ptr->show_anchor
      && (Anchor_ptr->link_type != 2 || Anchor_ptr->input_field->type != 8) )
    {
      ++total;
    }
  }
  return total;
}

//----- (080693B0) --------------------------------------------------------
void __cdecl HText_setStale(HText *text)
{
  text->stale = 1;
}

//----- (080693BF) --------------------------------------------------------
void __cdecl HText_refresh(HText *text)
{
  if ( text->stale )
    display_page(text, text->top_of_screen, &byte_814CBAC);
}

//----- (080693F5) --------------------------------------------------------
int __cdecl HText_sourceAnchors(HText *text)
{
  if ( text )
    return text->last_anchor_number;
  else
    return -1;
}

//----- (0806941B) --------------------------------------------------------
BOOLEAN __cdecl HText_canScrollUp(HText *text)
{
  return text->top_of_screen != 0;
}

//----- (0806942E) --------------------------------------------------------
_BOOL4 HText_canScrollDown()
{
  return HTMainText && display_lines + HTMainText->top_of_screen <= HTMainText->Lines;
}

//----- (08069475) --------------------------------------------------------
void __cdecl HText_scrollTop(HText *text)
{
  display_page(text, 0, &byte_814CBAC);
}

//----- (08069498) --------------------------------------------------------
void __cdecl HText_scrollDown(HText *text)
{
  display_page(text, text->top_of_screen + display_lines, &byte_814CBAC);
}

//----- (080694C8) --------------------------------------------------------
void __cdecl HText_scrollUp(HText *text)
{
  display_page(text, text->top_of_screen - display_lines, &byte_814CBAC);
}

//----- (080694FB) --------------------------------------------------------
void __cdecl HText_scrollBottom(HText *text)
{
  display_page(text, text->Lines - display_lines, &byte_814CBAC);
}

//----- (0806952E) --------------------------------------------------------
BOOLEAN __cdecl HText_select(HText *text)
{
  if ( text != HTMainText )
  {
    if ( text )
      text->page_has_target = 0;
    ResetPartialLinenos(text);
    ResetPartialLinenos(HTMainText);
    if ( HTMainText )
    {
      if ( HText_hasUTF8OutputSet(HTMainText)
        && (unsigned __int8)HTLoadedDocumentEightbit()
        && LYCharSet_UC[current_char_set].enc == 7 )
      {
        text->had_utf8 = HTMainText->has_utf8;
      }
      else
      {
        text->had_utf8 = 0;
      }
      HTMainText->has_utf8 = 0;
      text->has_utf8 = 0;
    }
    HTMainText = text;
    HTMainAnchor = text->node_anchor;
    if ( loaded_texts && HTList_removeObject(loaded_texts, text) )
      HTList_addObject(loaded_texts, text);
  }
  return 1;
}

//----- (08069626) --------------------------------------------------------
BOOLEAN __cdecl HText_POSTReplyLoaded(DocInfo *doc)
{
  void *object; // [esp+14h] [ebp-24h]
  const char *address; // [esp+24h] [ebp-14h]
  bstring *post_data; // [esp+28h] [ebp-10h]
  HTList *cur; // [esp+2Ch] [ebp-Ch]
  BOOLEAN is_head; // [esp+37h] [ebp-1h]

  cur = loaded_texts;
  if ( !loaded_texts || !doc )
    return 0;
  post_data = doc->post_data;
  if ( !post_data )
    return 0;
  address = doc->address;
  if ( !address )
    return 0;
  is_head = doc->isHEAD;
  while ( 1 )
  {
    if ( cur && (cur = cur->next) != 0 )
      object = cur->object;
    else
      object = 0;
    if ( !object )
      break;
    if ( *(_DWORD *)object
      && *(_DWORD *)(*(_DWORD *)object + 20)
      && HTSABEql(post_data, *(bstring **)(*(_DWORD *)object + 20))
      && *(_DWORD *)(*(_DWORD *)object + 16)
      && !strcmp(address, *(const char **)(*(_DWORD *)object + 16))
      && *(_BYTE *)(*(_DWORD *)object + 85) == is_head )
    {
      return 1;
    }
  }
  return 0;
}

//----- (0806972E) --------------------------------------------------------
BOOLEAN __cdecl HTFindPoundSelector(const char *selector)
{
  FILE *v1; // eax
  int v2; // ebx
  int number; // esi
  FILE *v4; // eax
  TextAnchor *a; // [esp+2Ch] [ebp-Ch]

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "FindPound: searching for \"%s\"\n", selector);
  }
  for ( a = HTMainText->first_anchor; ; a = a->next )
  {
    if ( !a )
      return 0;
    if ( a->anchor && a->anchor->tag && !strcmp(a->anchor->tag, selector) )
      break;
  }
  www_search_result = a->line_num + 1;
  if ( WWW_TraceFlag[0] )
  {
    v2 = www_search_result;
    number = a->number;
    v4 = TraceFP();
    fprintf(v4, "FindPound: Selecting anchor [%d] at line %d\n", number, v2);
  }
  if ( !strcmp(selector, LYToolbarName) )
    --www_search_result;
  return 1;
}

//----- (0806983D) --------------------------------------------------------
BOOLEAN __cdecl HText_selectAnchor(HText *text, HTChildAnchor *anchor)
{
  FILE *v2; // eax
  int number; // ebx
  FILE *v4; // edx
  int l; // [esp+2Ch] [ebp-Ch]
  TextAnchor *a; // [esp+30h] [ebp-8h]

  for ( a = text->first_anchor; a && a->anchor != anchor; a = a->next )
    ;
  if ( a )
  {
    if ( text != HTMainText )
    {
      HTMainText = text;
      HTMainAnchor = text->node_anchor;
    }
    l = a->line_num;
    if ( WWW_TraceFlag[0] )
    {
      number = a->number;
      v4 = TraceFP();
      fprintf(v4, "HText: Selecting anchor [%d] at line %d\n", number, l);
    }
    if ( text->stale || text->top_of_screen > l || text->top_of_screen + display_lines + 1 <= l )
    {
      www_search_result = l - display_lines / 3;
      return 1;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HText: No such anchor in this text!\n");
    }
    return 0;
  }
}

//----- (0806996A) --------------------------------------------------------
void __cdecl HText_applyStyle(HText *me, HTStyle *style)
{
  ;
}

//----- (0806996F) --------------------------------------------------------
void __cdecl HText_updateStyle(HText *me, HTStyle *style)
{
  ;
}

//----- (08069974) --------------------------------------------------------
HTStyle *__cdecl HText_selectionStyle(HText *me, HTStyleSheet *sheet)
{
  return 0;
}

//----- (0806997E) --------------------------------------------------------
void __cdecl HText_replaceSel(HText *me, const char *aString, HTStyle *aStyle)
{
  ;
}

//----- (08069983) --------------------------------------------------------
void __cdecl HTextApplyToSimilar(HText *me, HTStyle *style)
{
  ;
}

//----- (08069988) --------------------------------------------------------
void __cdecl HTextSelectUnstyled(HText *me, HTStyleSheet *sheet)
{
  ;
}

//----- (0806998D) --------------------------------------------------------
void __cdecl HText_unlinkSelection(HText *me)
{
  ;
}

//----- (08069992) --------------------------------------------------------
HTAnchor *__cdecl HText_referenceSelected(HText *me)
{
  return 0;
}

//----- (0806999C) --------------------------------------------------------
int HText_getTopOfScreen()
{
  if ( HTMainText )
    return HTMainText->top_of_screen;
  else
    return 0;
}

//----- (080699CA) --------------------------------------------------------
int __cdecl HText_getLines(HText *text)
{
  return text->Lines;
}

//----- (080699D8) --------------------------------------------------------
int __cdecl HText_getPreferredTopLine(HText *text, int line_number)
{
  if ( text->Lines < display_lines )
    return 0;
  if ( text->Lines < line_number )
    return text->Lines + 2 - display_lines;
  if ( line_number < 0 )
    return 0;
  return line_number;
}

//----- (08069A3D) --------------------------------------------------------
HTAnchor *__cdecl HText_linkSelTo(HText *me, HTAnchor *anchor)
{
  return 0;
}

//----- (08069A47) --------------------------------------------------------
void HTSearchQueries_free()
{
  LYFreeStringList(search_queries);
  search_queries = 0;
}

//----- (08069A66) --------------------------------------------------------
void __cdecl HTAddSearchQuery(char *query)
{
  void *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]
  char *new_query; // [esp+24h] [ebp-4h] BYREF

  new_query = 0;
  if ( query && *query )
  {
    HTSACopy(&new_query, query);
    if ( search_queries )
    {
      cur = search_queries;
      while ( 1 )
      {
        if ( cur && (cur = cur->next) != 0 )
          object = cur->object;
        else
          object = 0;
        if ( !object )
          break;
        if ( !strcmp((const char *)object, new_query) )
        {
          HTList_removeObject(search_queries, object);
          free(object);
          break;
        }
      }
      HTList_addObject(search_queries, new_query);
    }
    else
    {
      search_queries = HTList_new();
      HTList_addObject(search_queries, new_query);
    }
  }
}
// 8069B03: conditional instruction was optimized away because %var_14.4!=0

//----- (08069B62) --------------------------------------------------------
int __cdecl do_www_search(DocInfo *doc)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *address; // ebx
  FILE *v11; // eax
  int v13; // [esp+14h] [ebp-244h]
  _BOOL4 v14; // [esp+18h] [ebp-240h]
  char *cp_freeme; // [esp+30h] [ebp-228h]
  int QueryNum; // [esp+34h] [ebp-224h]
  int ch_0; // [esp+40h] [ebp-218h]
  char *tmpaddress; // [esp+44h] [ebp-214h] BYREF
  char *cp; // [esp+48h] [ebp-210h]
  BOOLEAN PreviousSearch; // [esp+4Fh] [ebp-209h]
  char temp[256]; // [esp+50h] [ebp-208h] BYREF
  char searchstring[256]; // [esp+150h] [ebp-108h] BYREF
  unsigned int v24; // [esp+250h] [ebp-8h]

  v24 = __readgsdword(0x14u);
  tmpaddress = 0;
  PreviousSearch = 0;
  cp = strchr(doc->address, 63);
  if ( cp )
  {
    PreviousSearch = 1;
    LYstrncpy(searchstring, cp + 1, 255);
    for ( cp = searchstring; *cp; ++cp )
    {
      if ( *cp == 43 )
        *cp = 32;
    }
    HTUnEscape(searchstring);
    strcpy(temp, searchstring);
    HTAddSearchQuery(searchstring);
  }
  else
  {
    searchstring[0] = 0;
    temp[0] = 0;
  }
  if ( searchstring[0] )
  {
    mustshow[0] = 1;
    v2 = gettext("Edit the current query: ");
    statusline(v2);
  }
  else if ( HTMainAnchor->isIndexPrompt )
  {
    mustshow[0] = 1;
    statusline(HTMainAnchor->isIndexPrompt);
  }
  else
  {
    mustshow[0] = 1;
    v1 = gettext("Enter a database query: ");
    statusline(v1);
  }
  if ( search_queries )
    v13 = HTList_count(search_queries);
  else
    v13 = 0;
  v14 = PreviousSearch && v13 > 1 || !PreviousSearch && v13 > 0;
  QueryNum = v13;
  while ( 1 )
  {
    ch_0 = LYgetstr(searchstring, 0, 0x100u, (RecallType)v14);
    if ( ch_0 >= 0 && searchstring[0] && ch_0 != 256 && ch_0 != 257 )
      break;
    if ( v14 && ch_0 == 256 )
    {
      if ( PreviousSearch )
      {
        QueryNum = 1;
        PreviousSearch = 0;
      }
      else
      {
        ++QueryNum;
      }
      if ( QueryNum >= v13 )
        QueryNum = 0;
      cp = (char *)HTList_objectAt(search_queries, QueryNum);
      if ( !cp )
        goto LABEL_63;
      LYstrncpy(searchstring, cp, 255);
      if ( temp[0] && !strcmp(temp, searchstring) )
        goto LABEL_38;
      if ( (!temp[0] || v13 != 2) && (temp[0] || v13 != 1) )
        goto LABEL_44;
LABEL_43:
      mustshow[0] = 1;
      v4 = gettext("Edit the previous query: ");
      statusline(v4);
    }
    else
    {
      if ( !v14 || ch_0 != 257 )
        goto LABEL_63;
      if ( PreviousSearch )
      {
        QueryNum = v13 - 1;
        PreviousSearch = 0;
      }
      else
      {
        --QueryNum;
      }
      if ( QueryNum < 0 )
        QueryNum = v13 - 1;
      cp = (char *)HTList_objectAt(search_queries, QueryNum);
      if ( !cp )
        goto LABEL_63;
      LYstrncpy(searchstring, cp, 255);
      if ( temp[0] && !strcmp(temp, searchstring) )
      {
LABEL_38:
        mustshow[0] = 1;
        v3 = gettext("Edit the current query: ");
        statusline(v3);
      }
      else
      {
        if ( temp[0] && v13 == 2 || !temp[0] && v13 == 1 )
          goto LABEL_43;
LABEL_44:
        mustshow[0] = 1;
        v5 = gettext("Edit a previous query: ");
        statusline(v5);
      }
    }
  }
  LYTrimLeading(searchstring);
  if ( !searchstring[0] )
  {
LABEL_63:
    v6 = gettext("Cancelled!!!");
    HTInfoMsg(v6);
    return 3;
  }
  LYTrimTrailing(searchstring);
  if ( LYforce_no_cache || strcmp(temp, searchstring) )
  {
    HTAddSearchQuery(searchstring);
    cp = strchr(doc->address, 63);
    if ( cp )
      *cp = 0;
    HTSACopy(&tmpaddress, doc->address);
    HTSACat(&tmpaddress, "?");
    HTSACat(&tmpaddress, searchstring);
    v8 = tmpaddress;
    v9 = gettext("Getting %s");
    user_message(v9, v8);
    LYSyslog(tmpaddress);
    if ( tmpaddress )
    {
      free(tmpaddress);
      tmpaddress = 0;
    }
    if ( cp )
      *cp = 63;
    if ( HTSearch(searchstring, HTMainAnchor) )
    {
      if ( traversal )
        cp_freeme = stub_HTAnchor_address((HTAnchor *)HTMainAnchor);
      else
        cp_freeme = HTAnchor_address((HTAnchor *)HTMainAnchor);
      HTSACopy(&doc->address, cp_freeme);
      if ( cp_freeme )
        free(cp_freeme);
      if ( WWW_TraceFlag[0] )
      {
        address = doc->address;
        v11 = TraceFP();
        fprintf(v11, "\ndo_www_search: newfile: %s\n", address);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v7 = gettext("Use Control-R to resubmit the current query.");
    HTUserMsg(v7);
    return 3;
  }
}

//----- (0806A2F6) --------------------------------------------------------
void __cdecl write_offset(FILE *fp, HTLine *line)
{
  int i; // [esp+14h] [ebp-4h]

  if ( line->data[0] )
  {
    for ( i = 0; line->offset > i; ++i )
      fputc(32, fp);
  }
}

//----- (0806A338) --------------------------------------------------------
void __cdecl write_hyphen(FILE *fp)
{
  int v1; // [esp+14h] [ebp-4h]

  if ( dump_output_immediately
    && LYRawMode[0]
    && LYlowest_eightbit[current_char_set] <= 173
    && (LYCharSet_UC[current_char_set].enc != 2 && (LYCharSet_UC[current_char_set].like8859 & 0x80) == 0 ? (v1 = 0) : (v1 = 1),
        v1) )
  {
    fputc(173, fp);
  }
  else
  {
    fputc(45, fp);
  }
}

//----- (0806A3D6) --------------------------------------------------------
int __cdecl TrimmedLength(char *string)
{
  bool v1; // al
  char *src; // [esp+14h] [ebp-14h]
  char *srca; // [esp+14h] [ebp-14h]
  char *dst; // [esp+18h] [ebp-10h]
  unsigned int ch_0; // [esp+1Ch] [ebp-Ch]
  int adjust; // [esp+20h] [ebp-8h]
  size_t result; // [esp+24h] [ebp-4h]

  result = strlen(string);
  if ( !HTisDocumentSource() )
  {
    for ( adjust = result; adjust > 0; --adjust )
    {
      ch_0 = (unsigned __int8)string[adjust - 1];
      if ( ((*__ctype_b_loc())[ch_0] & 0x2000) == 0 && (ch_0 <= 2 || ch_0 > 8) )
        break;
    }
    if ( result != adjust )
    {
      dst = &string[adjust];
      src = &string[adjust];
      do
      {
        srca = LYSkipBlanks(src);
        *dst = *srca;
        v1 = *dst++ == 0;
        src = srca + 1;
      }
      while ( !v1 );
      return dst - string - 1;
    }
  }
  return result;
}

//----- (0806A4A3) --------------------------------------------------------
void __cdecl print_wwwfile_to_fd(FILE *fp, BOOLEAN is_email, BOOLEAN is_reply)
{
  bool v3; // [esp+18h] [ebp-30h]
  int i; // [esp+1Ch] [ebp-2Ch]
  unsigned int ch_0; // [esp+30h] [ebp-18h]
  HTLine *line; // [esp+38h] [ebp-10h]
  int limit; // [esp+3Ch] [ebp-Ch]
  int first; // [esp+40h] [ebp-8h]
  BOOLEAN in_u; // [esp+46h] [ebp-2h]
  BOOLEAN in_b; // [esp+47h] [ebp-1h]

  first = 1;
  in_b = 0;
  in_u = 0;
  v3 = !is_email && !is_reply && HTMainText && with_backspaces && HTCJK == NOCJK && !HTMainText->T.output_utf8;
  if ( HTMainText )
  {
    for ( line = HTMainText->last_line->next; ; line = line->next )
    {
      if ( first )
      {
        first = 0;
        if ( !is_reply && (!is_email || strncmp(line->data, "From ", 5u)) )
          goto LABEL_22;
      }
      else
      {
        if ( line->data[0] == 8 )
          goto LABEL_22;
        fputc(10, fp);
        if ( !is_reply && (!is_email || strncmp(line->data, "From ", 5u)) )
          goto LABEL_22;
      }
      fputc(62, fp);
LABEL_22:
      write_offset(fp, line);
      limit = TrimmedLength(line->data);
      for ( i = 0; i < limit; ++i )
      {
        ch_0 = (unsigned __int8)line->data[i];
        if ( ch_0 > 2 && (unsigned __int8)line->data[i] <= 8u )
        {
          if ( ch_0 == 7 && i + 1 >= limit )
          {
            write_hyphen(fp);
          }
          else if ( dump_output_immediately && use_underscore )
          {
            if ( ch_0 - 3 <= 1 )
              fputc(95, fp);
          }
          else if ( v3 )
          {
            if ( ch_0 == 4 )
            {
              in_u = 0;
            }
            else if ( (unsigned __int8)line->data[i] > 4u )
            {
              if ( ch_0 == 5 )
              {
                if ( in_u )
                  in_u = 0;
                in_b = 1;
              }
              else if ( ch_0 == 6 )
              {
                in_b = 0;
              }
            }
            else if ( ch_0 == 3 && !in_b )
            {
              in_u = 1;
            }
          }
        }
        else if ( in_b )
        {
          fputc(ch_0, fp);
          fputc(8, fp);
          fputc(ch_0, fp);
        }
        else
        {
          if ( in_u )
          {
            fputc(95, fp);
            fputc(8, fp);
          }
          fputc(ch_0, fp);
        }
      }
      if ( HTMainText->last_line == line )
      {
        fputc(10, fp);
        return;
      }
    }
  }
}

//----- (0806A7EB) --------------------------------------------------------
void __cdecl print_crawl_to_fd(FILE *fp, char *thelink, char *thetitle)
{
  int i; // [esp+14h] [ebp-14h]
  unsigned int ch_0; // [esp+18h] [ebp-10h]
  HTLine *line; // [esp+1Ch] [ebp-Ch]
  int limit; // [esp+20h] [ebp-8h]
  int first; // [esp+24h] [ebp-4h]

  first = 1;
  if ( HTMainText )
  {
    line = HTMainText->last_line->next;
    fprintf(fp, "THE_URL:%s\n", thelink);
    if ( thetitle )
      fprintf(fp, "THE_TITLE:%s\n", thetitle);
    while ( 1 )
    {
      if ( !first && line->data[0] != 8 )
        fputc(10, fp);
      first = 0;
      write_offset(fp, line);
      limit = TrimmedLength(line->data);
      for ( i = 0; i < limit; ++i )
      {
        ch_0 = (unsigned __int8)line->data[i];
        if ( ch_0 > 2 && (unsigned __int8)line->data[i] <= 8u )
        {
          if ( ch_0 == 7 && i + 1 >= limit )
            write_hyphen(fp);
        }
        else
        {
          fputc(ch_0, fp);
        }
      }
      if ( HTMainText->last_line == line )
        break;
      line = line->next;
    }
    fputc(10, fp);
    if ( !no_list && (keypad_mode == 1 || keypad_mode == 2) )
      printlist(fp, 0);
  }
}

//----- (0806A95D) --------------------------------------------------------
void __cdecl adjust_search_result(DocInfo *doc, int tentative_result, int start_line)
{
  bool v3; // [esp+0h] [ebp-24h]
  int i; // [esp+8h] [ebp-1Ch]
  int max_offset; // [esp+Ch] [ebp-18h]
  int goal; // [esp+10h] [ebp-14h]
  int nl_closest; // [esp+14h] [ebp-10h]
  TextAnchor *a; // [esp+18h] [ebp-Ch]
  int anch_line; // [esp+1Ch] [ebp-8h]

  if ( tentative_result > 0 )
  {
    anch_line = -1;
    nl_closest = -1;
    goal = 4;
    v3 = HTMainText->top_of_screen < tentative_result && HTMainText->top_of_screen + display_lines >= tentative_result;
    if ( display_lines < 4 )
      goal = display_lines;
    max_offset = goal - 1;
    if ( !v3 || nlinks <= 0 )
      goto LABEL_19;
    for ( i = 0; i < nlinks; ++i )
    {
      if ( doc->line + links[i].ly - 1 <= tentative_result )
        nl_closest = i;
      if ( doc->line + links[i].ly - 1 >= tentative_result )
        break;
    }
    if ( nl_closest >= 0 && doc->line + links[nl_closest].ly - 1 == tentative_result )
    {
      www_search_result = doc->line;
      doc->link = nl_closest;
    }
    else
    {
LABEL_19:
      for ( a = HTMainText->first_anchor; a && a->line_num <= tentative_result - 1; a = a->next )
        anch_line = a->line_num + 1;
      if ( anch_line < 0
        || tentative_result - max_offset > anch_line
        || anch_line <= start_line && HTMainText->top_of_screen < tentative_result )
      {
        if ( tentative_result - start_line <= 0 || tentative_result + ~start_line > max_offset )
        {
          if ( HTMainText->top_of_screen >= tentative_result
            || tentative_result > start_line
            || goal + HTMainText->top_of_screen < tentative_result )
          {
            if ( tentative_result > goal )
              www_search_result = tentative_result - max_offset;
            else
              www_search_result = 1;
          }
          else
          {
            www_search_result = HTMainText->top_of_screen + 1;
          }
        }
        else
        {
          www_search_result = start_line + 1;
        }
      }
      else
      {
        www_search_result = anch_line;
      }
      if ( doc->line == www_search_result && nl_closest >= 0 )
        doc->link = nl_closest;
    }
  }
}
// 806A9C5: conditional instruction was optimized away because %goal.4==4

//----- (0806ABCF) --------------------------------------------------------
BOOLEAN __cdecl anchor_has_target(TextAnchor *a, char *target)
{
  bool v3; // [esp+10h] [ebp-28h]
  bool v5; // [esp+12h] [ebp-26h]
  bool v6; // [esp+13h] [ebp-25h]
  bool v7; // [esp+14h] [ebp-24h]
  bool v8; // [esp+15h] [ebp-23h]
  bool v9; // [esp+16h] [ebp-22h]
  bool v10; // [esp+17h] [ebp-21h]
  int count; // [esp+24h] [ebp-14h]
  char *cp; // [esp+28h] [ebp-10h]
  const char *cpa; // [esp+28h] [ebp-10h]
  const char *cpb; // [esp+28h] [ebp-10h]
  char *sp_0; // [esp+2Ch] [ebp-Ch]
  char *stars; // [esp+30h] [ebp-8h] BYREF
  OptionType *option; // [esp+34h] [ebp-4h]

  stars = 0;
  for ( count = 0; ; ++count )
  {
    cp = LYGetHiTextStr(a, count);
    if ( !cp )
      break;
    if ( case_sensitive )
      v3 = LYno_attr_char_strstr(cp, target) != 0;
    else
      v3 = LYno_attr_char_case_strstr(cp, target) != 0;
    if ( v3 )
      return 1;
  }
  if ( !a->input_field || !a->input_field->value || a->input_field->type == 8 )
    return 0;
  if ( a->input_field->type != 2 )
  {
    switch ( a->input_field->type )
    {
      case 7:
        for ( option = a->input_field->select_list; option; option = option->next )
        {
          if ( case_sensitive )
            v7 = LYno_attr_char_strstr(option->name, target) != 0;
          else
            v7 = LYno_attr_char_case_strstr(option->name, target) != 0;
          if ( v7 )
            return 1;
        }
        break;
      case 4:
        if ( a->input_field->num_value )
          cpa = checked_radio;
        else
          cpa = unchecked_radio;
        if ( case_sensitive )
          v8 = LYno_attr_char_strstr(cpa, target) != 0;
        else
          v8 = LYno_attr_char_case_strstr(cpa, target) != 0;
        if ( v8 )
          return 1;
        break;
      case 3:
        if ( a->input_field->num_value )
          cpb = checked_box;
        else
          cpb = unchecked_box;
        if ( case_sensitive )
          v9 = LYno_attr_char_strstr(cpb, target) != 0;
        else
          v9 = LYno_attr_char_case_strstr(cpb, target) != 0;
        if ( v9 )
          return 1;
        break;
      default:
        if ( case_sensitive )
          v10 = LYno_attr_char_strstr(a->input_field->value, target) != 0;
        else
          v10 = LYno_attr_char_case_strstr(a->input_field->value, target) != 0;
        if ( v10 )
          return 1;
        break;
    }
    return 0;
  }
  if ( case_sensitive )
    v5 = LYno_attr_char_strstr(a->input_field->value, target) != 0;
  else
    v5 = LYno_attr_char_case_strstr(a->input_field->value, target) != 0;
  if ( v5 )
    return 1;
  HTSACopy(&stars, a->input_field->value);
  for ( sp_0 = stars; *sp_0; ++sp_0 )
    *sp_0 = 42;
  if ( case_sensitive )
    v6 = LYno_attr_char_strstr(stars, target) != 0;
  else
    v6 = LYno_attr_char_case_strstr(stars, target) != 0;
  if ( !v6 )
  {
    if ( stars )
    {
      free(stars);
      stars = 0;
    }
    return 0;
  }
  if ( stars )
  {
    free(stars);
    stars = 0;
  }
  return 1;
}

//----- (0806AF78) --------------------------------------------------------
TextAnchor *__cdecl line_num_to_anchor(int line_num)
{
  TextAnchor *a; // [esp+Ch] [ebp-4h]

  if ( !HTMainText )
    return 0;
  for ( a = HTMainText->first_anchor; a && a->line_num < line_num; a = a->next )
    ;
  return a;
}

//----- (0806AFBE) --------------------------------------------------------
int __cdecl line_num_in_text(HText *text, HTLine *line)
{
  _line *temp; // [esp+8h] [ebp-8h]
  int result; // [esp+Ch] [ebp-4h]

  result = 1;
  temp = text->last_line->next;
  while ( temp != line )
  {
    temp = temp->next;
    ++result;
  }
  return result;
}

//----- (0806AFF1) --------------------------------------------------------
TextAnchor *__cdecl get_prev_anchor(TextAnchor *a)
{
  TextAnchor *q; // [esp+8h] [ebp-8h]
  TextAnchor *p; // [esp+Ch] [ebp-4h]

  if ( !a->prev )
  {
    p = HTMainText->first_anchor;
    if ( p )
    {
      while ( 1 )
      {
        q = p->next;
        if ( !p->next )
          break;
        q->prev = p;
        p = q;
      }
    }
  }
  return a->prev;
}

//----- (0806B03C) --------------------------------------------------------
int __cdecl www_search_forward(int start_line, DocInfo *doc, char *target, HTLine *line, int count)
{
  char *v5; // edx
  TextAnchor *a; // [esp+20h] [ebp-8h]
  int wrapped; // [esp+24h] [ebp-4h]

  wrapped = 0;
  a = line_num_to_anchor(count - 1);
  while ( 1 )
  {
    while ( a && a->line_num == count - 1 )
    {
      if ( a->show_anchor && (a->link_type != 2 || a->input_field->type != 8) && anchor_has_target(a, target) )
      {
        adjust_search_result(doc, count, start_line);
        return 1;
      }
      a = a->next;
    }
    if ( case_sensitive ? LYno_attr_char_strstr(line->data, target) != 0 : LYno_attr_char_case_strstr(
                                                                             line->data,
                                                                             target) != 0 )
      break;
    if ( count == start_line && wrapped || wrapped > 1 )
    {
      v5 = gettext("'%s' not found!");
      HTUserMsg2(v5, target);
      return -1;
    }
    if ( HTMainText->last_line == line )
    {
      count = 0;
      ++wrapped;
    }
    line = line->next;
    ++count;
  }
  if ( count > 0 )
    adjust_search_result(doc, count, start_line);
  return 0;
}

//----- (0806B1BF) --------------------------------------------------------
int __cdecl www_search_backward(int start_line, DocInfo *doc, char *target, HTLine *line, int count)
{
  char *v5; // edx
  TextAnchor *a; // [esp+20h] [ebp-8h]
  int wrapped; // [esp+24h] [ebp-4h]

  wrapped = 0;
  a = line_num_to_anchor(count - 1);
  while ( 1 )
  {
    while ( a && a->line_num == count - 1 )
    {
      if ( a->show_anchor && (a->link_type != 2 || a->input_field->type != 8) && anchor_has_target(a, target) )
      {
        adjust_search_result(doc, count, start_line);
        return 1;
      }
      a = get_prev_anchor(a);
    }
    if ( case_sensitive ? LYno_attr_char_strstr(line->data, target) != 0 : LYno_attr_char_case_strstr(
                                                                             line->data,
                                                                             target) != 0 )
      break;
    if ( count == start_line && wrapped || wrapped > 1 )
    {
      v5 = gettext("'%s' not found!");
      HTUserMsg2(v5, target);
      return -1;
    }
    if ( HTMainText->last_line->next == line )
    {
      count = line_num_in_text(HTMainText, HTMainText->last_line) + 1;
      ++wrapped;
    }
    line = line->prev;
    --count;
  }
  if ( count > 0 )
    adjust_search_result(doc, count, start_line);
  return 0;
}

//----- (0806B36F) --------------------------------------------------------
void __cdecl www_user_search(int start_line, DocInfo *doc, char *target, int direction)
{
  int count; // [esp+20h] [ebp-8h]
  _line *line; // [esp+24h] [ebp-4h]

  if ( HTMainText )
  {
    line = HTMainText->last_line->next;
    if ( direction + start_line <= 0 )
    {
      line = HTMainText->last_line;
      count = line_num_in_text(HTMainText, line);
    }
    else
    {
      for ( count = 1; start_line + direction > count; ++count )
      {
        if ( HTMainText->last_line == line )
        {
          line = HTMainText->last_line->next;
          count = 1;
          break;
        }
        line = line->next;
      }
    }
    if ( direction < 0 )
      www_search_backward(start_line, doc, target, line, count);
    else
      www_search_forward(start_line, doc, target, line, count);
  }
}

//----- (0806B45E) --------------------------------------------------------
void __cdecl user_message(const char *message, const char *argument)
{
  char *temp; // [esp+24h] [ebp-4h] BYREF

  if ( message )
  {
    temp = 0;
    if ( argument )
      HTSprintf0(&temp, message, argument);
    else
      HTSprintf0(&temp, message, &byte_814CBAC);
    statusline(temp);
    if ( temp )
      free(temp);
  }
  else
  {
    mustshow[0] = 0;
  }
}

//----- (0806B4CE) --------------------------------------------------------
const char *HText_getOwner()
{
  if ( HTMainText )
    return HTAnchor_owner(HTMainText->node_anchor);
  else
    return 0;
}

//----- (0806B4FD) --------------------------------------------------------
void __cdecl HText_setMainTextOwner(const char *owner)
{
  if ( HTMainText )
    HTAnchor_setOwner(HTMainText->node_anchor, owner);
}

//----- (0806B524) --------------------------------------------------------
const char *HText_getRevTitle()
{
  if ( HTMainText )
    return HTAnchor_RevTitle(HTMainText->node_anchor);
  else
    return 0;
}

//----- (0806B553) --------------------------------------------------------
const char *HText_getContentBase()
{
  if ( HTMainText )
    return HTAnchor_content_base(HTMainText->node_anchor);
  else
    return 0;
}

//----- (0806B582) --------------------------------------------------------
const char *HText_getContentLocation()
{
  if ( HTMainText )
    return HTAnchor_content_location(HTMainText->node_anchor);
  else
    return 0;
}

//----- (0806B5B1) --------------------------------------------------------
const char *HText_getMessageID()
{
  if ( HTMainText )
    return HTAnchor_messageID(HTMainText->node_anchor);
  else
    return 0;
}

//----- (0806B5E0) --------------------------------------------------------
void HTuncache_current_document()
{
  FILE *v0; // eax
  FILE *v1; // eax
  const char *v2; // [esp+10h] [ebp-18h]
  const char *address; // [esp+14h] [ebp-14h]
  HTParentAnchor *htmain_anchor; // [esp+24h] [ebp-4h]

  if ( HTMainText )
  {
    htmain_anchor = HTMainText->node_anchor;
    if ( HTMainText->node_anchor && (!HTOutputFormat || HTOutputFormat != WWW_SOURCE) && htmain_anchor->UCStages )
    {
      free(htmain_anchor->UCStages);
      htmain_anchor->UCStages = 0;
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( htmain_anchor && htmain_anchor->post_data )
        v2 = " with POST data";
      else
        v2 = &byte_814CBAC;
      if ( htmain_anchor && htmain_anchor->address )
        address = htmain_anchor->address;
      else
        address = "unknown anchor";
      v0 = TraceFP();
      fprintf(v0, "\nHTuncache.. freeing document for '%s'%s\n", address, v2);
    }
    HTList_removeObject(loaded_texts, HTMainText);
    HText_free(HTMainText);
    HTMainText = 0;
  }
  else if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "HTuncache.. HTMainText already is NULL!\n");
  }
}

//----- (0806B70C) --------------------------------------------------------
_BOOL4 useSourceCache()
{
  FILE *v0; // eax
  const char *v2; // [esp+14h] [ebp-14h]
  bool result; // [esp+27h] [ebp-1h]

  result = 0;
  if ( LYCacheSource == 1 )
  {
    result = HTMainAnchor->source_cache_file != 0;
    if ( WWW_TraceFlag[0] )
    {
      if ( HTMainAnchor->source_cache_file )
        v2 = &byte_814CBAC;
      else
        v2 = " not";
      v0 = TraceFP();
      fprintf(v0, "SourceCache: file-cache%s found\n", v2);
    }
  }
  return result;
}

//----- (0806B775) --------------------------------------------------------
_BOOL4 useMemoryCache()
{
  FILE *v0; // eax
  const char *v2; // [esp+14h] [ebp-14h]
  bool result; // [esp+27h] [ebp-1h]

  result = 0;
  if ( LYCacheSource == 2 )
  {
    result = HTMainAnchor->source_cache_chunk != 0;
    if ( WWW_TraceFlag[0] )
    {
      if ( HTMainAnchor->source_cache_chunk )
        v2 = &byte_814CBAC;
      else
        v2 = " not";
      v0 = TraceFP();
      fprintf(v0, "SourceCache: memory-cache%s found\n", v2);
    }
  }
  return result;
}

//----- (0806B7DE) --------------------------------------------------------
_BOOL4 HTreparse_document()
{
  FILE *v0; // eax
  char *source_cache_file; // ebx
  FILE *v2; // eax
  HTAtom *v3; // eax
  const char *name; // ebx
  FILE *v5; // eax
  char *v6; // ebx
  FILE *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // ebx
  FILE *v11; // eax
  FILE *v12; // eax
  HTChunk *source_cache_chunk; // ebx
  FILE *v14; // eax
  char *v15; // eax
  FILE *v16; // eax
  bool v19; // [esp+18h] [ebp-30h]
  const char *v20; // [esp+1Ch] [ebp-2Ch]
  const char *v21; // [esp+20h] [ebp-28h]
  HTFormat format_0; // [esp+30h] [ebp-18h]
  HTFormat format_0a; // [esp+30h] [ebp-18h]
  int ret; // [esp+34h] [ebp-14h]
  HTAtom *format; // [esp+38h] [ebp-10h]
  FILE *fp; // [esp+3Ch] [ebp-Ch]
  bool ok; // [esp+43h] [ebp-5h]

  ok = 0;
  if ( !HTMainAnchor || !LYCacheSource )
  {
    if ( WWW_TraceFlag[0] )
    {
      v0 = TraceFP();
      fprintf(v0, "HTreparse_document returns FALSE\n");
    }
    return 0;
  }
  if ( !useSourceCache() )
  {
    if ( useMemoryCache() )
    {
      format_0 = HTAtom_for("text/html");
      if ( WWW_TraceFlag[0] )
      {
        source_cache_chunk = HTMainAnchor->source_cache_chunk;
        v14 = TraceFP();
        fprintf(v14, "SourceCache: Reparsing from memory chunk %p\n", source_cache_chunk);
      }
      if ( (!HTOutputFormat || HTOutputFormat != WWW_SOURCE) && HTMainAnchor->UCStages )
      {
        free(HTMainAnchor->UCStages);
        HTMainAnchor->UCStages = 0;
      }
      if ( HTMainAnchor->content_type )
        format_0a = HTAtom_for(HTMainAnchor->content_type);
      else
        format_0a = HTCharsetFormat(format_0, HTMainAnchor, UCLYhndl_for_unspec);
      if ( HText_HaveUserChangedForms(HTMainText) )
      {
        v15 = gettext("Reloading document.  Any form entries will be lost!");
        HTAlert(v15);
      }
      HTAnchor_setProtocol(HTMainAnchor, &scm);
      ok = HTParseMem(format_0a, HTOutputFormat, HTMainAnchor, HTMainAnchor->source_cache_chunk, 0) == 200;
      if ( WWW_TraceFlag[0] )
      {
        if ( ok )
          v21 = "succeeded";
        else
          v21 = "failed";
        v16 = TraceFP();
        fprintf(v16, "Reparse memory %s\n", v21);
      }
    }
    return ok;
  }
  if ( WWW_TraceFlag[0] )
  {
    source_cache_file = HTMainAnchor->source_cache_file;
    v2 = TraceFP();
    fprintf(v2, "SourceCache: Reparsing file %s\n", source_cache_file);
  }
  if ( (!HTOutputFormat || HTOutputFormat != WWW_SOURCE) && HTMainAnchor->UCStages )
  {
    free(HTMainAnchor->UCStages);
    HTMainAnchor->UCStages = 0;
  }
  if ( HTMainAnchor->content_type )
  {
    format = HTAtom_for(HTMainAnchor->content_type);
  }
  else
  {
    v3 = HTFileFormat(HTMainAnchor->source_cache_file, 0, 0);
    format = HTCharsetFormat(v3, HTMainAnchor, UCLYhndl_for_unspec);
  }
  if ( WWW_TraceFlag[0] )
  {
    name = format->name;
    v5 = TraceFP();
    fprintf(v5, "  Content type is \"%s\"\n", name);
  }
  fp = (FILE *)fopen64(HTMainAnchor->source_cache_file, "r");
  if ( fp )
  {
    if ( HText_HaveUserChangedForms(HTMainText) )
    {
      v8 = gettext("Reloading document.  Any form entries will be lost!");
      HTAlert(v8);
    }
    HTAnchor_setProtocol(HTMainAnchor, &HTFile);
    ret = HTParseFile(format, HTOutputFormat, HTMainAnchor, fp, 0);
    LYCloseInput(fp);
    if ( ret == 206 )
    {
      v9 = gettext("Loading incomplete.");
      HTInfoMsg(v9);
      if ( WWW_TraceFlag[0] )
      {
        v10 = HTLoadedDocumentURL();
        v11 = TraceFP();
        fprintf(v11, "SourceCache: `%s' has been accessed, partial content.\n", v10);
      }
    }
    v19 = ret == 200 || ret == 206;
    ok = v19;
    if ( WWW_TraceFlag[0] )
    {
      if ( v19 )
        v20 = "succeeded";
      else
        v20 = "failed";
      v12 = TraceFP();
      fprintf(v12, "Reparse file %s\n", v20);
    }
    return ok;
  }
  if ( WWW_TraceFlag[0] )
  {
    v6 = HTMainAnchor->source_cache_file;
    v7 = TraceFP();
    fprintf(v7, "  Cannot read file %s\n", v6);
  }
  LYRemoveTemp(HTMainAnchor->source_cache_file);
  if ( HTMainAnchor->source_cache_file )
  {
    free(HTMainAnchor->source_cache_file);
    HTMainAnchor->source_cache_file = 0;
  }
  return 0;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0806BC9E) --------------------------------------------------------
int HTcan_reparse_document()
{
  FILE *v0; // eax
  BOOLEAN result; // [esp+23h] [ebp-5h]

  result = 0;
  if ( HTMainAnchor && LYCacheSource )
  {
    if ( useSourceCache() )
    {
      result = LYCanReadFile(HTMainAnchor->source_cache_file);
    }
    else if ( useMemoryCache() )
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    v0 = TraceFP();
    fprintf(v0, "HTcan_reparse_document -> %d\n", result);
  }
  return (unsigned __int8)result;
}

//----- (0806BD20) --------------------------------------------------------
void __cdecl trace_setting_change(const char *name, int prev_setting, int new_setting)
{
  FILE *v3; // edx

  if ( prev_setting != new_setting )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(
        v3,
        "HTdocument_settings_changed: %s setting has changed (was %d, now %d)\n",
        name,
        prev_setting,
        new_setting);
    }
  }
}

//----- (0806BD69) --------------------------------------------------------
_BOOL4 HTdocument_settings_changed()
{
  int disp_lines; // ebx
  int disp_cols; // esi
  FILE *v2; // eax
  int v5; // [esp+28h] [ebp-20h]
  int v6; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  bool v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+3Ch] [ebp-Ch]

  if ( HTMainText && (unsigned __int8)HTcan_reparse_document() )
  {
    if ( WWW_TraceFlag[0] )
    {
      trace_setting_change("CLICKABLE_IMAGES", HTMainText->clickable_images, clickable_images);
      trace_setting_change("PSEUDO_INLINE_ALTS", HTMainText->pseudo_inline_alts, pseudo_inline_alts);
      trace_setting_change("VERBOSE_IMG", HTMainText->verbose_img, verbose_img);
      trace_setting_change("RAW_MODE", HTMainText->raw_mode, LYUseDefaultRawMode);
      trace_setting_change("HISTORICAL_COMMENTS", HTMainText->historical_comments, historical_comments);
      trace_setting_change("MINIMAL_COMMENTS", HTMainText->minimal_comments, minimal_comments);
      trace_setting_change("SOFT_DQUOTES", HTMainText->soft_dquotes, soft_dquotes);
      trace_setting_change("OLD_DTD", HTMainText->old_dtd, Old_DTD);
      trace_setting_change("KEYPAD_MODE", HTMainText->keypad_mode, keypad_mode);
      if ( HTMainText->disp_lines != LYlines || (LYwideLines ? (v5 = 1014) : (v5 = LYcols), HTMainText->disp_cols != v5) )
      {
        if ( WWW_TraceFlag[0] )
        {
          v6 = LYlines;
          if ( LYwideLines )
            v7 = 1014;
          else
            v7 = LYcols;
          disp_lines = HTMainText->disp_lines;
          disp_cols = HTMainText->disp_cols;
          v2 = TraceFP();
          fprintf(
            v2,
            "HTdocument_settings_changed: Screen size has changed (was %dx%d, now %dx%d)\n",
            disp_cols,
            disp_lines,
            v7,
            v6);
        }
      }
    }
    v8 = 1;
    if ( HTMainText->clickable_images == clickable_images
      && HTMainText->pseudo_inline_alts == pseudo_inline_alts
      && HTMainText->verbose_img == verbose_img
      && HTMainText->raw_mode == LYUseDefaultRawMode
      && HTMainText->historical_comments == historical_comments
      && (HTMainText->minimal_comments == minimal_comments || historical_comments)
      && HTMainText->soft_dquotes == soft_dquotes
      && HTMainText->old_dtd == Old_DTD
      && HTMainText->keypad_mode == keypad_mode )
    {
      v9 = LYwideLines ? 1014 : LYcols;
      if ( HTMainText->disp_cols == v9 )
        return 0;
    }
    return v8;
  }
  else
  {
    return 0;
  }
}

//----- (0806C12B) --------------------------------------------------------
int HTisDocumentSource()
{
  if ( HTMainText )
    return HTMainText->source;
  else
    return 0;
}

//----- (0806C15A) --------------------------------------------------------
char *HTLoadedDocumentURL()
{
  if ( !HTMainText )
    return (char *)&byte_814CBAC;
  if ( HTMainText->node_anchor && HTMainText->node_anchor->address )
    return HTMainText->node_anchor->address;
  return (char *)&byte_814CBAC;
}

//----- (0806C1A6) --------------------------------------------------------
bstring *HTLoadedDocumentPost_data()
{
  if ( HTMainText && HTMainText->node_anchor && HTMainText->node_anchor->post_data )
    return HTMainText->node_anchor->post_data;
  else
    return 0;
}

//----- (0806C1E9) --------------------------------------------------------
char *HTLoadedDocumentTitle()
{
  if ( !HTMainText )
    return (char *)&byte_814CBAC;
  if ( HTMainText->node_anchor && HTMainText->node_anchor->title )
    return HTMainText->node_anchor->title;
  return (char *)&byte_814CBAC;
}

//----- (0806C235) --------------------------------------------------------
int HTLoadedDocumentIsHEAD()
{
  if ( HTMainText )
  {
    if ( HTMainText->node_anchor && HTMainText->node_anchor->isHEAD )
      return (unsigned __int8)HTMainText->node_anchor->isHEAD;
    else
      return 0;
  }
  else
  {
    return 0;
  }
}

//----- (0806C27E) --------------------------------------------------------
int HTLoadedDocumentIsSafe()
{
  if ( HTMainText )
  {
    if ( HTMainText->node_anchor && HTMainText->node_anchor->safe )
      return (unsigned __int8)HTMainText->node_anchor->safe;
    else
      return 0;
  }
  else
  {
    return 0;
  }
}

//----- (0806C2C7) --------------------------------------------------------
char *HTLoadedDocumentCharset()
{
  if ( !HTMainText )
    return 0;
  if ( HTMainText->node_anchor && HTMainText->node_anchor->charset )
    return HTMainText->node_anchor->charset;
  return 0;
}

//----- (0806C313) --------------------------------------------------------
int HTLoadedDocumentEightbit()
{
  if ( HTMainText )
    return (unsigned __int8)HTMainText->have_8bit_chars;
  else
    return 0;
}

//----- (0806C33D) --------------------------------------------------------
void __cdecl HText_setNodeAnchorBookmark(const char *bookmark)
{
  if ( HTMainText )
  {
    if ( HTMainText->node_anchor )
      HTAnchor_setBookmark(HTMainText->node_anchor, bookmark);
  }
}

//----- (0806C36F) --------------------------------------------------------
char *HTLoadedDocumentBookmark()
{
  if ( !HTMainText )
    return 0;
  if ( HTMainText->node_anchor && HTMainText->node_anchor->bookmark )
    return HTMainText->node_anchor->bookmark;
  return 0;
}

//----- (0806C3BB) --------------------------------------------------------
int __cdecl HText_LastLineSize(HText *text, BOOLEAN IgnoreSpaces)
{
  if ( text && text->last_line && text->last_line->size )
    return HText_TrueLineSize(text->last_line, text, IgnoreSpaces);
  else
    return 0;
}

//----- (0806C414) --------------------------------------------------------
BOOLEAN __cdecl HText_LastLineEmpty(HText *text, BOOLEAN IgnoreSpaces)
{
  if ( text && text->last_line && text->last_line->size )
    return HText_TrueEmptyLine(text->last_line, text, IgnoreSpaces);
  else
    return 1;
}

//----- (0806C46B) --------------------------------------------------------
int __cdecl HText_LastLineOffset(HText *text)
{
  if ( text && text->last_line )
    return text->last_line->offset;
  else
    return 0;
}

//----- (0806C49F) --------------------------------------------------------
int __cdecl HText_PreviousLineSize(HText *text, BOOLEAN IgnoreSpaces)
{
  _line *line; // [esp+24h] [ebp-4h]

  if ( !text || !text->last_line )
    return 0;
  line = text->last_line->prev;
  if ( line )
    return HText_TrueLineSize(line, text, IgnoreSpaces);
  else
    return 0;
}

//----- (0806C501) --------------------------------------------------------
BOOLEAN __cdecl HText_PreviousLineEmpty(HText *text, BOOLEAN IgnoreSpaces)
{
  _line *line; // [esp+24h] [ebp-4h]

  if ( !text || !text->last_line )
    return 1;
  line = text->last_line->prev;
  if ( line )
    return HText_TrueEmptyLine(line, text, IgnoreSpaces);
  else
    return 1;
}

//----- (0806C55E) --------------------------------------------------------
int __cdecl HText_TrueLineSize(HTLine *line, HText *text, BOOLEAN IgnoreSpaces)
{
  int true_size; // [esp+10h] [ebp-8h]
  size_t i; // [esp+14h] [ebp-4h]
  size_t ia; // [esp+14h] [ebp-4h]

  true_size = 0;
  if ( !line || !line->size )
    return 0;
  if ( IgnoreSpaces )
  {
    for ( i = 0; line->size > i; ++i )
    {
      if ( (line->data[i] <= 2u || line->data[i] > 8u)
        && (!text || !text->T.output_utf8 || line->data[i] >= 0 || (line->data[i] & 0xC0) == 192)
        && ((*__ctype_b_loc())[(unsigned __int8)line->data[i]] & 0x2000) == 0
        && line->data[i] != 1
        && line->data[i] != 2 )
      {
        ++true_size;
      }
    }
  }
  else
  {
    for ( ia = 0; line->size > ia; ++ia )
    {
      if ( (line->data[ia] <= 2 || line->data[ia] > 8)
        && (!text || !text->T.output_utf8 || line->data[ia] >= 0 || (line->data[ia] & 0xC0) == 192) )
      {
        ++true_size;
      }
    }
  }
  return true_size;
}

//----- (0806C6EE) --------------------------------------------------------
BOOLEAN __cdecl HText_TrueEmptyLine(HTLine *line, HText *text, BOOLEAN IgnoreSpaces)
{
  size_t i; // [esp+14h] [ebp-4h]
  size_t ia; // [esp+14h] [ebp-4h]

  if ( !line || !line->size )
    return 1;
  if ( IgnoreSpaces )
  {
    for ( i = 0; line->size > i; ++i )
    {
      if ( (line->data[i] <= 2u || line->data[i] > 8u)
        && (!text || !text->T.output_utf8 || line->data[i] >= 0 || (line->data[i] & 0xC0) == 192)
        && ((*__ctype_b_loc())[(unsigned __int8)line->data[i]] & 0x2000) == 0
        && line->data[i] != 1
        && line->data[i] != 2 )
      {
        return 0;
      }
    }
  }
  else
  {
    for ( ia = 0; line->size > ia; ++ia )
    {
      if ( (line->data[ia] <= 2 || line->data[ia] > 8)
        && (!text || !text->T.output_utf8 || line->data[ia] >= 0 || (line->data[ia] & 0xC0) == 192) )
      {
        return 0;
      }
    }
  }
  return 1;
}

//----- (0806C87A) --------------------------------------------------------
void __cdecl HText_NegateLineOne(HText *text)
{
  if ( text )
    text->in_line_1 = 0;
}

//----- (0806C88F) --------------------------------------------------------
BOOLEAN __cdecl HText_inLineOne(HText *text)
{
  if ( text )
    return text->in_line_1;
  else
    return 1;
}

//----- (0806C8B4) --------------------------------------------------------
void __cdecl HText_RemovePreviousLine(HText *text)
{
  HTLine *previous; // [esp+8h] [ebp-8h]

  if ( text )
  {
    if ( text->Lines > 1 )
    {
      previous = text->last_line->prev->prev;
      previous->next = text->last_line;
      text->last_line->prev = previous;
      --text->Lines;
    }
  }
}

//----- (0806C911) --------------------------------------------------------
int __cdecl HText_getCurrentColumn(HText *text)
{
  HTCoord indent1st; // [esp+14h] [ebp-14h]
  int column; // [esp+20h] [ebp-8h]

  column = 0;
  if ( text )
  {
    if ( text->in_line_1 )
      indent1st = text->style->indent1st;
    else
      indent1st = text->style->leftIndent;
    return HText_LastLineSize(text, 0) + indent1st + text->last_line->offset;
  }
  return column;
}

//----- (0806C986) --------------------------------------------------------
int __cdecl HText_getMaximumColumn(HText *text)
{
  int v2; // [esp+0h] [ebp-14h]
  int column; // [esp+10h] [ebp-4h]

  if ( LYwideLines )
    v2 = 1014;
  else
    v2 = LYcols;
  column = v2;
  if ( text )
    return v2 - text->style->rightIndent;
  return column;
}

//----- (0806C9C6) --------------------------------------------------------
void __cdecl HText_setTabID(HText *text, const char *name)
{
  const char **object; // [esp+14h] [ebp-14h]
  HTList *last; // [esp+1Ch] [ebp-Ch]
  HTList *cur; // [esp+20h] [ebp-8h]
  HTTabID *Tab; // [esp+24h] [ebp-4h]

  cur = text->tabs;
  last = 0;
  if ( text && name && *name )
  {
    if ( cur )
    {
      while ( 1 )
      {
        if ( cur && (cur = cur->next) != 0 )
          object = (const char **)cur->object;
        else
          object = 0;
        if ( !object )
          break;
        if ( *object && !strcmp(*object, name) )
          return;
        last = cur;
      }
      if ( last )
        cur = last;
    }
    else
    {
      text->tabs = HTList_new();
      cur = text->tabs;
    }
    Tab = (HTTabID *)calloc(1u, 8u);
    if ( !Tab )
      outofmem("./GridText.c", "HText_setTabID");
    HTList_addObject(cur, Tab);
    HTSACopy(&Tab->name, name);
    Tab->column = HText_getCurrentColumn(text);
  }
}
// 806CA99: conditional instruction was optimized away because %Tab.4==0

//----- (0806CB05) --------------------------------------------------------
int __cdecl HText_getTabIDColumn(HText *text, const char *name)
{
  void *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]
  int column; // [esp+24h] [ebp-4h]

  column = 0;
  cur = text->tabs;
  if ( text && name && *name && cur )
  {
    do
    {
      if ( cur && (cur = cur->next) != 0 )
        object = cur->object;
      else
        object = 0;
    }
    while ( object && (!*(_DWORD *)object || strcmp(*(const char **)object, name)) );
    if ( object )
      return *((_DWORD *)object + 1);
  }
  return column;
}

//----- (0806CBA3) --------------------------------------------------------
void __cdecl HText_AddHiddenLink(HText *text, TextAnchor *textanchor)
{
  char *v2; // eax
  HTAnchor *dest; // [esp+14h] [ebp-4h]

  if ( text && textanchor && textanchor->anchor )
  {
    if ( !text->hidden_links )
      text->hidden_links = HTList_new();
    dest = HTAnchor_followLink(textanchor->anchor);
    if ( dest && (text->hiddenlinkflag != 2 || !text->hidden_links || !text->hidden_links->next) )
    {
      v2 = HTAnchor_address(dest);
      HTList_appendObject(text->hidden_links, v2);
    }
  }
}

//----- (0806CC4E) --------------------------------------------------------
int __cdecl HText_HiddenLinkCount(HText *text)
{
  int count; // [esp+14h] [ebp-4h]

  count = 0;
  if ( text && text->hidden_links )
    return HTList_count(text->hidden_links);
  return count;
}

//----- (0806CC87) --------------------------------------------------------
const char *__cdecl HText_HiddenLinkAt(HText *text, int number)
{
  char *href; // [esp+14h] [ebp-4h]

  href = 0;
  if ( text && text->hidden_links && number >= 0 )
    return (const char *)HTList_objectAt(text->hidden_links, number);
  return href;
}

//----- (0806CCCD) --------------------------------------------------------
void __cdecl HText_beginForm(char *action, char *method, char *enctype, char *title, const char *accept_cs)
{
  char *v5; // eax
  int v6; // ebx
  const char *v7; // esi
  FILE *v8; // eax
  const char *v9; // [esp+28h] [ebp-30h]
  const char *v10; // [esp+2Ch] [ebp-2Ch]
  const char *v11; // [esp+30h] [ebp-28h]
  const char *v12; // [esp+34h] [ebp-24h]
  const char *v13; // [esp+38h] [ebp-20h]
  const char *v14; // [esp+3Ch] [ebp-1Ch]
  PerFormInfo *newform; // [esp+4Ch] [ebp-Ch]

  HTFormMethod = 1;
  ++HTFormNumber;
  HTFormFields = 0;
  HTFormDisabled[0] = 0;
  if ( action )
  {
    if ( !strncasecomp(action, "mailto:", 7) )
      HTFormMethod = 3;
    HTSACopy(&HTFormAction, action);
  }
  else
  {
    v5 = HTLoadedDocumentURL();
    HTSACopy(&HTFormAction, v5);
  }
  if ( method && HTFormMethod != 3 && (!strcasecomp(method, "post") || !strcasecomp(method, "pget")) )
    HTFormMethod = 2;
  if ( enctype && *enctype )
  {
    HTSACopy(&HTFormEnctype, enctype);
    if ( HTFormMethod != 3 && !strncasecomp(enctype, "multipart/form-data", 19) )
      HTFormMethod = 2;
  }
  else if ( HTFormEnctype )
  {
    free(HTFormEnctype);
    HTFormEnctype = 0;
  }
  if ( title && *title )
  {
    HTSACopy(&HTFormTitle, title);
  }
  else if ( HTFormTitle )
  {
    free(HTFormTitle);
    HTFormTitle = 0;
  }
  if ( accept_cs )
  {
    HTSACopy(&HTFormAcceptCharset, accept_cs);
    LYRemoveBlanks(HTFormAcceptCharset);
    LYLowerCase(HTFormAcceptCharset);
  }
  newform = (PerFormInfo *)calloc(1u, 0x20u);
  if ( !newform )
    outofmem("./GridText.c", "HText_beginForm");
  newform->number = HTFormNumber;
  PerFormInfo_free(HTCurrentForm);
  HTCurrentForm = newform;
  if ( WWW_TraceFlag[0] )
  {
    if ( HTFormAcceptCharset )
      v9 = HTFormAcceptCharset;
    else
      v9 = &byte_814CBAC;
    if ( HTFormAcceptCharset )
      v10 = " Accept-charset:";
    else
      v10 = &byte_814CBAC;
    if ( HTFormEnctype )
      v11 = HTFormEnctype;
    else
      v11 = &byte_814CBAC;
    if ( HTFormEnctype )
      v12 = " Enctype:";
    else
      v12 = &byte_814CBAC;
    if ( HTFormTitle )
      v13 = HTFormTitle;
    else
      v13 = &byte_814CBAC;
    if ( HTFormTitle )
      v14 = " Title:";
    else
      v14 = &byte_814CBAC;
    v6 = HTFormMethod;
    v7 = HTFormAction;
    v8 = TraceFP();
    fprintf(v8, "BeginForm: action:%s Method:%d%s%s%s%s%s%s\n", v7, v6, v14, v13, v12, v11, v10, v9);
  }
}

//----- (0806CFE4) --------------------------------------------------------
void __cdecl HText_endForm(HText *text)
{
  FILE *v1; // eax
  TextAnchor *a; // [esp+14h] [ebp-4h]

  if ( HTFormFields == 1 && text && text->first_anchor )
  {
    for ( a = text->first_anchor; a; a = a->next )
    {
      if ( a->link_type == 2 && a->input_field->number == HTFormNumber && a->input_field->type == 1 )
      {
        a->input_field->submit_action = 0;
        HTSACopy(&a->input_field->submit_action, HTFormAction);
        if ( HTFormEnctype )
          HTSACopy(&a->input_field->submit_enctype, HTFormEnctype);
        if ( HTFormTitle )
          HTSACopy(&a->input_field->submit_title, HTFormTitle);
        a->input_field->submit_method = HTFormMethod;
        a->input_field->type = 12;
        if ( HTFormDisabled[0] )
          a->input_field->disabled = 1;
        break;
      }
    }
  }
  if ( HTCurrentForm )
  {
    if ( HTFormDisabled[0] )
      HTCurrentForm->disabled = 1;
    HTCurrentForm->accept_cs = HTFormAcceptCharset;
    HTFormAcceptCharset = 0;
    if ( !text->forms )
      text->forms = HTList_new();
    HTList_appendObject(text->forms, HTCurrentForm);
    HTCurrentForm = 0;
  }
  else if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "endForm:    HTCurrentForm is missing!\n");
  }
  if ( HTCurSelectGroup )
  {
    free(HTCurSelectGroup);
    HTCurSelectGroup = 0;
  }
  if ( HTCurSelectGroupSize )
  {
    free(HTCurSelectGroupSize);
    HTCurSelectGroupSize = 0;
  }
  if ( HTCurSelectedOptionValue )
  {
    free(HTCurSelectedOptionValue);
    HTCurSelectedOptionValue = 0;
  }
  if ( HTFormAction )
  {
    free(HTFormAction);
    HTFormAction = 0;
  }
  if ( HTFormEnctype )
  {
    free(HTFormEnctype);
    HTFormEnctype = 0;
  }
  if ( HTFormTitle )
  {
    free(HTFormTitle);
    HTFormTitle = 0;
  }
  if ( HTFormAcceptCharset )
  {
    free(HTFormAcceptCharset);
    HTFormAcceptCharset = 0;
  }
  HTFormFields = 0;
  HTFormDisabled[0] = 0;
}

//----- (0806D2A2) --------------------------------------------------------
void __cdecl HText_beginSelect(char *name, int name_cs, BOOLEAN multiple, char *size)
{
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // eax
  const char *v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  const char *v9; // [esp+28h] [ebp-10h]
  const char *MIMEname; // [esp+2Ch] [ebp-Ch]

  HTSACopy(&HTCurSelectGroup, name);
  HTCurSelectGroupCharset = name_cs;
  if ( multiple )
    HTCurSelectGroupType = 3;
  else
    HTCurSelectGroupType = 4;
  HTSACopy(&HTCurSelectGroupSize, size);
  if ( WWW_TraceFlag[0] )
  {
    if ( HTCurSelectGroupSize )
      v7 = HTCurSelectGroupSize;
    else
      v7 = "<NULL>";
    v8 = HTCurSelectGroupType;
    if ( HTCurSelectGroup )
      v9 = HTCurSelectGroup;
    else
      v9 = "<NULL>";
    v4 = TraceFP();
    fprintf(v4, "HText_beginSelect: name=%s type=%d size=%s\n", v9, v8, v7);
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( HTCurSelectGroupCharset < 0 )
      MIMEname = "<UNKNOWN>";
    else
      MIMEname = LYCharSet_UC[HTCurSelectGroupCharset].MIMEname;
    v5 = HTCurSelectGroupCharset;
    v6 = TraceFP();
    fprintf(v6, "HText_beginSelect: name_cs=%d \"%s\"\n", v5, MIMEname);
  }
}

//----- (0806D3C9) --------------------------------------------------------
int __cdecl HText_getOptionNum(HText *text)
{
  FILE *v1; // eax
  int n; // [esp+1Ch] [ebp-Ch]
  OptionType *op; // [esp+20h] [ebp-8h]
  TextAnchor *a; // [esp+24h] [ebp-4h]

  n = 1;
  if ( !text || !text->last_anchor )
    return 0;
  a = text->last_anchor;
  if ( a->link_type != 2 || !a->input_field || a->input_field->type != 7 )
    return 0;
  for ( op = a->input_field->select_list; op; op = op->next )
    ++n;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "HText_getOptionNum: Got number '%d'.\n", n);
  }
  return n;
}

//----- (0806D482) --------------------------------------------------------
char *__cdecl HText_skipOptionNumPrefix(char *opname)
{
  bool v1; // al
  _BOOL4 v2; // eax
  int i; // [esp+10h] [ebp-8h]
  char *cp; // [esp+14h] [ebp-4h]
  char *cpa; // [esp+14h] [ebp-4h]
  char *cpb; // [esp+14h] [ebp-4h]

  if ( keypad_mode != 3 && keypad_mode != 2 )
    return opname;
  if ( !opname )
    return opname;
  if ( !*opname )
    return opname;
  cp = opname + 1;
  if ( *opname != 40 )
    return opname;
  if ( !*cp )
    return opname;
  v1 = ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x800) != 0;
  cpa = opname + 2;
  if ( !v1 )
    return opname;
  while ( *cpa && ((*__ctype_b_loc())[(unsigned __int8)*cpa] & 0x800) != 0 )
    ++cpa;
  if ( !*cpa )
    return opname;
  v2 = *cpa == 41;
  cpb = cpa + 1;
  if ( !v2 )
    return opname;
  for ( i = cpb - opname; i <= 4 && *cpb == 95; ++i )
    ++cpb;
  if ( i <= 4 )
    return opname;
  return cpb;
}

//----- (0806D5C2) --------------------------------------------------------
char *__cdecl HText_setLastOptionValue(
        HText *text,
        char *value,
        char *submit_value,
        int order,
        BOOLEAN checked,
        int val_cs,
        int submit_val_cs)
{
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  int type; // ebx
  FILE *v11; // eax
  FormInfo *input_field; // ebx
  size_t v13; // eax
  FormInfo *v14; // ebx
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // edx
  FILE *v18; // eax
  char *v20; // [esp+20h] [ebp-88h]
  const char *v22; // [esp+28h] [ebp-80h]
  const char *src; // [esp+2Ch] [ebp-7Ch]
  int v24; // [esp+34h] [ebp-74h]
  const char *v25; // [esp+38h] [ebp-70h]
  int v26; // [esp+3Ch] [ebp-6Ch]
  signed int v27; // [esp+40h] [ebp-68h]
  signed int v28; // [esp+48h] [ebp-60h]
  const char *v29; // [esp+50h] [ebp-58h]
  const char *MIMEname; // [esp+54h] [ebp-54h]
  const char *v31; // [esp+58h] [ebp-50h]
  const char *v32; // [esp+5Ch] [ebp-4Ch]
  FormInfo *last_input_0; // [esp+64h] [ebp-44h]
  int curlen_0; // [esp+6Ch] [ebp-3Ch]
  int newlen; // [esp+74h] [ebp-34h]
  FormInfo *last_input; // [esp+78h] [ebp-30h]
  OptionType *new_ptr; // [esp+7Ch] [ebp-2Ch]
  OptionType *op_ptr; // [esp+80h] [ebp-28h]
  int j; // [esp+84h] [ebp-24h]
  int ja; // [esp+84h] [ebp-24h]
  int jb; // [esp+84h] [ebp-24h]
  int i; // [esp+88h] [ebp-20h]
  int ia; // [esp+88h] [ebp-20h]
  int ib; // [esp+88h] [ebp-20h]
  int number; // [esp+8Ch] [ebp-1Ch]
  unsigned __int8 *tmp; // [esp+90h] [ebp-18h]
  char *ret_Value; // [esp+94h] [ebp-14h]
  char *cp1; // [esp+98h] [ebp-10h]
  char *cp; // [esp+9Ch] [ebp-Ch]
  char *cpa; // [esp+9Ch] [ebp-Ch]
  char *cpb; // [esp+9Ch] [ebp-Ch]
  BOOLEAN first_option; // [esp+A3h] [ebp-5h]

  ret_Value = 0;
  number = 0;
  if ( !value || !text || !text->last_anchor || !text->last_anchor->input_field || text->last_anchor->link_type != 2 )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( value )
        v20 = value;
      else
        v20 = "<NULL>";
      v7 = TraceFP();
      fprintf(v7, "HText_setLastOptionValue: invalid call!  value:%s!\n", v20);
    }
    return 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( checked )
      v22 = "on";
    else
      v22 = "off";
    v8 = TraceFP();
    fprintf(v8, "Entering HText_setLastOptionValue: value:\"%s\", checked:%s\n", value, v22);
  }
  if ( *value )
  {
    for ( cp = &value[strlen(value) - 1];
          cp >= value
       && (((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x2000) != 0
        || (unsigned __int8)*cp > 2u && (unsigned __int8)*cp <= 8u);
          --cp )
    {
      ;
    }
    cp[1] = 0;
  }
  for ( cpa = value;
        ((*__ctype_b_loc())[(unsigned __int8)*cpa] & 0x2000) != 0
     || (unsigned __int8)*cpa > 2u && (unsigned __int8)*cpa <= 8u;
        ++cpa )
  {
    ;
  }
  if ( HTCurSelectGroupType == 4 && LYSelectPopups && (keypad_mode == 3 || keypad_mode == 2) )
  {
    cp1 = HText_skipOptionNumPrefix(cpa);
    if ( cp1 > cpa )
    {
      i = 0;
      j = cp1 - cpa;
      while ( ((*__ctype_b_loc())[(unsigned __int8)cp1[i]] & 0x2000) != 0
           || (unsigned __int8)cp1[i] > 2u && (unsigned __int8)cp1[i] <= 8u )
        ++i;
      if ( i > 0 )
      {
        while ( cp1[i] )
          cpa[j++] = cp1[i++];
        cpa[j] = 0;
      }
    }
  }
  if ( HTCurSelectGroupType == 3 )
  {
    HTSACopy(&text->last_anchor->input_field->value, cpa);
    text->last_anchor->input_field->value_cs = val_cs;
    HText_appendText(text, cpa);
LABEL_129:
    if ( WWW_TraceFlag[0] )
    {
      if ( order == 3 )
        v29 = " LAST_ORDER";
      else
        v29 = &byte_814CBAC;
      v15 = TraceFP();
      fprintf(v15, "HText_setLastOptionValue:%s value=\"%s\"\n", v29, value);
      if ( WWW_TraceFlag[0] )
      {
        if ( val_cs < 0 )
          MIMEname = "<UNKNOWN>";
        else
          MIMEname = LYCharSet_UC[val_cs].MIMEname;
        v16 = TraceFP();
        fprintf(v16, "            val_cs=%d \"%s\"", val_cs, MIMEname);
      }
      if ( submit_value )
      {
        if ( WWW_TraceFlag[0] )
        {
          if ( HTCurSelectGroupType == 3 )
            v31 = "(ignored)";
          else
            v31 = &byte_814CBAC;
          if ( submit_val_cs < 0 )
            v32 = "<UNKNOWN>";
          else
            v32 = LYCharSet_UC[submit_val_cs].MIMEname;
          v17 = TraceFP();
          fprintf(v17, " (submit_val_cs %d \"%s\") submit_value%s=\"%s\"\n", submit_val_cs, v32, v31, submit_value);
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v18 = TraceFP();
        fprintf(v18, "\n");
      }
    }
    return ret_Value;
  }
  if ( !LYSelectPopups )
  {
    if ( submit_value )
      src = submit_value;
    else
      src = cpa;
    HTSACopy(&text->last_anchor->input_field->value, src);
    if ( submit_value )
      v24 = submit_val_cs;
    else
      v24 = val_cs;
    text->last_anchor->input_field->value_cs = v24;
    HText_appendText(text, cpa);
    goto LABEL_129;
  }
  op_ptr = text->last_anchor->input_field->select_list;
  first_option = 0;
  LYReduceBlanks(value);
  if ( op_ptr )
  {
    while ( op_ptr->next )
    {
      ++number;
      op_ptr = op_ptr->next;
    }
    ++number;
    new_ptr = (OptionType *)calloc(1u, 0x10u);
    op_ptr->next = new_ptr;
    if ( !new_ptr )
      outofmem("./GridText.c", "HText_setLastOptionValue");
    goto LABEL_69;
  }
  if ( text->last_anchor->input_field->type == 7 )
  {
    input_field = text->last_anchor->input_field;
    input_field->select_list = (OptionType *)calloc(1u, 0x10u);
    new_ptr = input_field->select_list;
    if ( !new_ptr )
      outofmem("./GridText.c", "HText_setLastOptionValue");
    first_option = 1;
LABEL_69:
    new_ptr->name = 0;
    new_ptr->cp_submit_value = 0;
    new_ptr->next = 0;
    for ( cpb = value;
          ((*__ctype_b_loc())[(unsigned __int8)*cpb] & 0x2000) != 0
       || (unsigned __int8)*cpb > 2u && (unsigned __int8)*cpb <= 8u;
          ++cpb )
    {
      ;
    }
    ia = 0;
    ja = 0;
    while ( cpb[ia] )
    {
      if ( cpb[ia] == 1 || cpb[ia] == 2 )
      {
        cpb[ja++] = 32;
      }
      else if ( cpb[ia] != 7 && ((unsigned __int8)cpb[ia] <= 2u || (unsigned __int8)cpb[ia] > 8u) )
      {
        cpb[ja++] = cpb[ia];
      }
      ++ia;
    }
    cpb[ja] = 0;
    if ( HTCJK )
    {
      if ( cpb )
      {
        v13 = strlen(cpb);
        tmp = (unsigned __int8 *)calloc(2 * v13 + 1, 1u);
        if ( tmp )
        {
          if ( kanji_code == EUC )
          {
            TO_EUC((const unsigned __int8 *)cpb, tmp);
            val_cs = current_char_set;
          }
          else if ( kanji_code == SJIS )
          {
            TO_SJIS((const unsigned __int8 *)cpb, tmp);
            val_cs = current_char_set;
          }
          else
          {
            ib = 0;
            jb = 0;
            while ( cpb[ib] )
            {
              if ( cpb[ib] != 27 )
                tmp[jb++] = cpb[ib];
              ++ib;
            }
          }
          HTSACopy(&new_ptr->name, (const char *)tmp);
          free(tmp);
        }
      }
    }
    else
    {
      HTSACopy(&new_ptr->name, cpb);
    }
    if ( submit_value )
      v25 = submit_value;
    else
      v25 = HText_skipOptionNumPrefix(new_ptr->name);
    HTSACopy(&new_ptr->cp_submit_value, v25);
    if ( submit_value )
      v26 = submit_val_cs;
    else
      v26 = val_cs;
    new_ptr->value_cs = v26;
    if ( first_option )
    {
      last_input = text->last_anchor->input_field;
      HTSACopy(&HTCurSelectedOptionValue, new_ptr->name);
      last_input->num_value = 0;
      if ( last_input->value )
      {
        free(last_input->value);
        last_input->value = 0;
      }
      if ( last_input->cp_submit_value )
      {
        free(last_input->cp_submit_value);
        last_input->cp_submit_value = 0;
      }
      last_input->value = last_input->select_list->name;
      last_input->orig_value = last_input->select_list->name;
      last_input->cp_submit_value = last_input->select_list->cp_submit_value;
      last_input->orig_submit_value = last_input->select_list->cp_submit_value;
      last_input->value_cs = new_ptr->value_cs;
    }
    else
    {
      newlen = strlen(new_ptr->name);
      if ( HTCurSelectedOptionValue )
        v27 = strlen(HTCurSelectedOptionValue);
      else
        v27 = 0;
      if ( newlen > v27 )
      {
        if ( newlen - v27 > 1023 )
          HTSACat(&HTCurSelectedOptionValue, underscore_string);
        else
          HTSACat(&HTCurSelectedOptionValue, (const char *)(v27 - newlen + 135981023));
      }
    }
    if ( checked )
    {
      curlen_0 = strlen(new_ptr->name);
      v28 = HTCurSelectedOptionValue ? strlen(HTCurSelectedOptionValue) : 0;
      last_input_0 = text->last_anchor->input_field;
      last_input_0->num_value = number;
      last_input_0->value = new_ptr->name;
      last_input_0->orig_value = new_ptr->name;
      last_input_0->cp_submit_value = new_ptr->cp_submit_value;
      last_input_0->orig_submit_value = new_ptr->cp_submit_value;
      last_input_0->value_cs = new_ptr->value_cs;
      HTSACopy(&HTCurSelectedOptionValue, new_ptr->name);
      if ( v28 > curlen_0 )
      {
        if ( v28 - curlen_0 > 1023 )
          HTSACat(&HTCurSelectedOptionValue, underscore_string);
        else
          HTSACat(&HTCurSelectedOptionValue, (const char *)(curlen_0 - v28 + 135981023));
      }
    }
    if ( order == 3 )
    {
      if ( !HTCurSelectedOptionValue )
        HTSACopy(&HTCurSelectedOptionValue, &byte_814CBAC);
      v14 = text->last_anchor->input_field;
      v14->size = strlen(HTCurSelectedOptionValue);
      ret_Value = HTCurSelectedOptionValue;
    }
    goto LABEL_129;
  }
  if ( WWW_TraceFlag[0] )
  {
    v9 = TraceFP();
    fprintf(v9, "HText_setLastOptionValue: last input_field not F_OPTION_LIST_TYPE (%d)\n", 7);
  }
  if ( WWW_TraceFlag[0] )
  {
    type = text->last_anchor->input_field->type;
    v11 = TraceFP();
    fprintf(v11, "                          but %d, ignoring!\n", type);
  }
  return 0;
}
// 806DC69: conditional instruction was optimized away because %tmp.4!=0

//----- (0806E0C9) --------------------------------------------------------
int __cdecl HText_beginInput(HText *text, BOOLEAN underline, InputFieldData *I)
{
  FILE *v3; // eax
  size_t v4; // eax
  int v5; // eax
  int v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  int v9; // eax
  int v10; // eax
  FILE *v11; // eax
  char *name; // ebx
  FILE *v13; // eax
  int v14; // ebx
  FILE *v15; // eax
  int v16; // ebx
  FILE *v17; // eax
  const char *type; // [esp+20h] [ebp-A8h]
  int v20; // [esp+24h] [ebp-A4h]
  unsigned int v22; // [esp+30h] [ebp-98h]
  char *str; // [esp+34h] [ebp-94h]
  int v24; // [esp+38h] [ebp-90h]
  int v25; // [esp+3Ch] [ebp-8Ch]
  int v26; // [esp+40h] [ebp-88h]
  unsigned int v27; // [esp+44h] [ebp-84h]
  int size; // [esp+48h] [ebp-80h]
  char *value; // [esp+4Ch] [ebp-7Ch]
  const char *MIMEname; // [esp+50h] [ebp-78h]
  int name_cs; // [esp+54h] [ebp-74h]
  const char *v32; // [esp+58h] [ebp-70h]
  const char *v33; // [esp+5Ch] [ebp-6Ch]
  int value_cs; // [esp+60h] [ebp-68h]
  const char *v35; // [esp+64h] [ebp-64h]
  int i2; // [esp+80h] [ebp-48h]
  TextAnchor *b; // [esp+84h] [ebp-44h]
  int MaximumSize; // [esp+88h] [ebp-40h]
  int MaximumSizea; // [esp+88h] [ebp-40h]
  signed int adjust_marker; // [esp+8Ch] [ebp-3Ch]
  int j; // [esp+90h] [ebp-38h]
  int i; // [esp+94h] [ebp-34h]
  unsigned __int8 *tmp; // [esp+98h] [ebp-30h]
  char *IValue; // [esp+9Ch] [ebp-2Ch] BYREF
  const char *cp_option; // [esp+A0h] [ebp-28h]
  FormInfo *f; // [esp+A4h] [ebp-24h]
  TextAnchor *a; // [esp+A8h] [ebp-20h]
  BOOLEAN had_bracket; // [esp+AFh] [ebp-19h]
  char marker[16]; // [esp+B0h] [ebp-18h] BYREF
  unsigned int v50; // [esp+C0h] [ebp-8h]

  v50 = __readgsdword(0x14u);
  cp_option = 0;
  IValue = 0;
  adjust_marker = 0;
  if ( WWW_TraceFlag[0] )
  {
    if ( I->type )
      type = I->type;
    else
      type = &byte_814CBAC;
    v3 = TraceFP();
    fprintf(v3, "GridText: Entering HText_beginInput type=%s\n", type);
  }
  a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool, 0x34u);
  f = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool, 0x60u);
  if ( !a || !f )
    outofmem("./GridText.c", "HText_beginInput");
  a->sgml_offset = SGML_offset();
  a->inUnderline = underline;
  a->line_num = text->Lines;
  a->line_pos = text->last_line->size;
  if ( I->type && !strcmp(I->type, "OPTION") && HTCurSelectGroupType == 4 && !LYSelectPopups )
  {
    I->type = "RADIO";
    I->name = HTCurSelectGroup;
    I->name_cs = HTCurSelectGroupCharset;
  }
  if ( I->name && I->type && !strcasecomp(I->type, "radio") )
  {
    if ( text->last_anchor )
    {
      i2 = 0;
      for ( b = text->first_anchor; b; b = b->next )
      {
        if ( b->link_type == 2
          && b->input_field->type == 4
          && b->input_field->number == HTFormNumber
          && !strcmp(b->input_field->name, I->name) )
        {
          if ( I->checked && b->input_field->num_value )
          {
            b->input_field->num_value = 0;
            HTSACopy(&b->input_field->orig_value, "0");
            break;
          }
          ++i2;
        }
      }
      if ( !i2 )
        I->checked = 1;
    }
    else
    {
      I->checked = 1;
    }
  }
  a->next = 0;
  a->anchor = 0;
  a->link_type = 2;
  a->show_anchor = 1;
  LYClearHiText(a);
  a->extent = 2;
  a->input_field = f;
  f->select_list = 0;
  f->number = HTFormNumber;
  v20 = HTFormDisabled[0] || I->disabled;
  f->disabled = v20;
  f->no_cache = 0;
  ++HTFormFields;
  if ( HTFormMethod == 2 )
    f->no_cache = 1;
  if ( I->value )
    HTSACopy(&IValue, I->value);
  if ( IValue && HTCJK && (!I->type || strcasecomp(I->type, "hidden")) )
  {
    v4 = strlen(IValue);
    tmp = (unsigned __int8 *)calloc(2 * v4 + 1, 1u);
    if ( tmp )
    {
      if ( kanji_code == EUC )
      {
        TO_EUC((const unsigned __int8 *)IValue, tmp);
        I->value_cs = current_char_set;
      }
      else if ( kanji_code == SJIS )
      {
        TO_SJIS((const unsigned __int8 *)IValue, tmp);
        I->value_cs = current_char_set;
      }
      else
      {
        i = 0;
        j = 0;
        while ( IValue[i] )
        {
          if ( IValue[i] != 27 )
            tmp[j++] = IValue[i];
          ++i;
        }
      }
      HTSACopy(&IValue, (const char *)tmp);
      free(tmp);
    }
  }
  if ( I->type && !strcmp(I->type, "OPTION") )
  {
    cp_option = I->type;
    I->type = HTCurSelectGroupType == 4 ? "OPTION_LIST" : "CHECKBOX";
    I->name = HTCurSelectGroup;
    I->name_cs = HTCurSelectGroupCharset;
    if ( HTCurSelectGroupSize )
    {
      v5 = atoi(HTCurSelectGroupSize);
      f->size_l = v5;
      if ( HTCurSelectGroupSize )
      {
        free(HTCurSelectGroupSize);
        HTCurSelectGroupSize = 0;
      }
    }
  }
  if ( I->size )
  {
    f->size = I->size;
    if ( !f->size && !cp_option )
      f->size = 20;
  }
  else
  {
    f->size = 20;
  }
  if ( I->maxlength )
  {
    v6 = atoi(I->maxlength);
    f->maxlength = v6;
  }
  else
  {
    f->maxlength = 0;
  }
  f->num_value = I->checked == 1;
  if ( I->type )
  {
    if ( strcasecomp(I->type, "password") )
    {
      if ( strcasecomp(I->type, "checkbox") )
      {
        if ( strcasecomp(I->type, "radio") )
        {
          if ( strcasecomp(I->type, "submit") )
          {
            if ( strcasecomp(I->type, "image") )
            {
              if ( strcasecomp(I->type, "reset") )
              {
                if ( strcasecomp(I->type, "OPTION_LIST") )
                {
                  if ( strcasecomp(I->type, "hidden") )
                  {
                    if ( strcasecomp(I->type, "textarea") )
                    {
                      if ( strcasecomp(I->type, "range") )
                      {
                        if ( strcasecomp(I->type, "file") )
                        {
                          if ( strcasecomp(I->type, "keygen") )
                            f->type = 1;
                          else
                            f->type = 14;
                        }
                        else
                        {
                          f->type = 11;
                          if ( WWW_TraceFlag[0] )
                          {
                            v7 = TraceFP();
                            fprintf(v7, "ok, got a file uploader\n");
                          }
                        }
                      }
                      else
                      {
                        f->type = 10;
                      }
                    }
                    else
                    {
                      f->type = 9;
                    }
                  }
                  else
                  {
                    f->type = 8;
                    --HTFormFields;
                    f->size = 0;
                  }
                }
                else
                {
                  f->type = 7;
                }
              }
              else
              {
                f->type = 6;
              }
            }
            else
            {
              f->type = 13;
            }
          }
          else
          {
            f->type = 5;
          }
        }
        else
        {
          f->type = 4;
        }
      }
      else
      {
        f->type = 3;
      }
    }
    else
    {
      f->type = 2;
    }
  }
  else
  {
    f->type = 1;
  }
  if ( I->name )
  {
    HTSACopy(&f->name, I->name);
    f->name_cs = I->name_cs;
LABEL_113:
    if ( text->last_anchor )
      text->last_anchor->next = a;
    else
      text->first_anchor = a;
    if ( IValue )
    {
      if ( f->type == 7 || f->type == 3 )
      {
        HTSACopy(&f->value, IValue);
        HTSACopy(&f->cp_submit_value, IValue);
      }
      else
      {
        HTSACopy(&f->value, IValue);
      }
      f->value_cs = I->value_cs;
    }
    else if ( f->type != 7 )
    {
      HTSACopy(&f->value, &byte_814CBAC);
      f->value_cs = current_char_set;
    }
    switch ( f->type )
    {
      case 6:
        if ( f->value && *f->value )
        {
          v9 = strlen(f->value);
          f->size = v9;
        }
        else
        {
          HTSACopy(&f->value, "Reset");
          f->size = 5;
        }
        break;
      case 0xD:
      case 5:
        if ( f->value && *f->value )
        {
          v10 = strlen(f->value);
          f->size = v10;
        }
        else if ( f->type == 13 )
        {
          HTSACopy(&f->value, "[IMAGE]-Submit");
          f->size = 14;
        }
        else
        {
          HTSACopy(&f->value, "Submit");
          f->size = 6;
        }
        f->submit_action = 0;
        HTSACopy(&f->submit_action, HTFormAction);
        if ( HTFormEnctype )
          HTSACopy(&f->submit_enctype, HTFormEnctype);
        if ( HTFormTitle )
          HTSACopy(&f->submit_title, HTFormTitle);
        f->submit_method = HTFormMethod;
        break;
      case 4:
      case 3:
        f->size = 3;
        if ( !IValue )
        {
          if ( f->type == 3 )
            HTSACopy(&f->value, "on");
          else
            HTSACopy(&f->value, &byte_814CBAC);
        }
        break;
    }
    if ( IValue )
    {
      free(IValue);
      IValue = 0;
    }
    if ( f->type == 4 || f->type == 3 )
    {
      if ( f->num_value )
        HTSACopy(&f->orig_value, "1");
      else
        HTSACopy(&f->orig_value, "0");
    }
    else if ( f->type == 7 )
    {
      f->orig_value = 0;
    }
    else
    {
      HTSACopy(&f->orig_value, f->value);
    }
    if ( I->accept_cs )
    {
      HTSACopy(&f->accept_cs, I->accept_cs);
      LYRemoveBlanks(f->accept_cs);
      LYLowerCase(f->accept_cs);
    }
    v22 = f->type;
    if ( v22 <= 0xE && ((1 << v22) & 0x4500) != 0 )
    {
      a->number = 0;
    }
    else if ( keypad_mode == 3 || keypad_mode == 2 )
    {
      a->number = ++text->last_anchor_number;
    }
    else
    {
      a->number = 0;
    }
    if ( (keypad_mode == 3 || keypad_mode == 2) && a->number > 0 )
    {
      sprintf(marker, "[%d]", a->number);
      adjust_marker = strlen(marker);
      if ( number_fields_on_left )
      {
        had_bracket = f->type == 7;
        str = had_bracket ? &marker[1] : marker;
        HText_appendText(text, str);
        if ( had_bracket )
          HText_appendCharacter(text, 91);
      }
      a->line_num = text->Lines;
      a->line_pos = text->last_line->size;
    }
    else
    {
      marker[0] = 0;
    }
    if ( text->stbl )
    {
      if ( LYtableCols > 0 )
      {
        v25 = LYcols * LYtableCols / 12;
      }
      else
      {
        if ( LYwideLines )
          v26 = 1014;
        else
          v26 = LYcols;
        v25 = v26;
      }
      v24 = v25 - (LYShowScrollbar != 0) + 1;
    }
    else
    {
      v24 = LYcols - (LYShowScrollbar != 0) + 1;
    }
    MaximumSize = v24 - adjust_marker;
    v27 = f->type;
    if ( v27 <= 0xD && ((1 << v27) & 0x2262) != 0 )
    {
      MaximumSizea = ~text->style->leftIndent - text->style->rightIndent + MaximumSize;
      if ( keypad_mode == 3 || keypad_mode == 2 )
      {
        if ( number_fields_on_left || f->type != 1 || a->line_pos + 10 >= MaximumSizea )
          MaximumSizea -= strlen(marker);
        else
          MaximumSizea -= a->line_pos;
      }
      I->value = f->value;
    }
    else
    {
      MaximumSizea = MaximumSize - 10;
    }
    if ( MaximumSizea <= 0 )
      MaximumSizea = 1;
    if ( f->size > MaximumSizea )
      f->size = MaximumSizea;
    text->last_anchor = a;
    if ( HTCurrentForm )
    {
      if ( !HTCurrentForm->first_field )
        HTCurrentForm->first_field = f;
      HTCurrentForm->last_field = f;
      ++HTCurrentForm->nfields;
      if ( f->accept_cs && !HTFormAcceptCharset )
        HTSACopy(&HTFormAcceptCharset, f->accept_cs);
      if ( !text->forms )
        text->forms = HTList_new();
    }
    else if ( WWW_TraceFlag[0] )
    {
      v11 = TraceFP();
      fprintf(v11, "beginInput: HTCurrentForm is missing!\n");
    }
    if ( WWW_TraceFlag[0] )
    {
      size = f->size;
      if ( f->value )
        value = f->value;
      else
        value = (char *)&byte_814CBAC;
      name = f->name;
      v13 = TraceFP();
      fprintf(v13, "Input link: name=%s\nvalue=%s\nsize=%d\n", name, value, size);
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( I->name_cs < 0 )
        MIMEname = "<UNKNOWN>";
      else
        MIMEname = LYCharSet_UC[I->name_cs].MIMEname;
      name_cs = I->name_cs;
      if ( f->name_cs < 0 )
        v32 = "<UNKNOWN>";
      else
        v32 = LYCharSet_UC[f->name_cs].MIMEname;
      v14 = f->name_cs;
      v15 = TraceFP();
      fprintf(v15, "Input link: name_cs=%d \"%s\" (from %d \"%s\")\n", v14, v32, name_cs, MIMEname);
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( I->value_cs < 0 )
        v33 = "<UNKNOWN>";
      else
        v33 = LYCharSet_UC[I->value_cs].MIMEname;
      value_cs = I->value_cs;
      if ( f->value_cs < 0 )
        v35 = "<UNKNOWN>";
      else
        v35 = LYCharSet_UC[f->value_cs].MIMEname;
      v16 = f->value_cs;
      v17 = TraceFP();
      fprintf(v17, "            value_cs=%d \"%s\" (from %d \"%s\")\n", v16, v35, value_cs, v33);
    }
    if ( I->size && f->size > adjust_marker )
      f->size -= adjust_marker;
    return f->size;
  }
  if ( f->type == 6 || f->type == 5 || f->type == 13 )
  {
    HTSACopy(&f->name, &byte_814CBAC);
    goto LABEL_113;
  }
  if ( WWW_TraceFlag[0] )
  {
    v8 = TraceFP();
    fprintf(v8, "GridText: No name present in input field; not displaying\n");
  }
  if ( IValue )
  {
    free(IValue);
    IValue = 0;
  }
  return 0;
}
// 806E560: conditional instruction was optimized away because %tmp.4!=0

//----- (0806F29D) --------------------------------------------------------
void __cdecl HText_endInput(HText *text)
{
  char marker[20]; // [esp+20h] [ebp-18h] BYREF
  unsigned int v2; // [esp+34h] [ebp-4h]

  v2 = __readgsdword(0x14u);
  if ( (keypad_mode == 3 || keypad_mode == 2)
    && !number_fields_on_left
    && text
    && text->last_anchor
    && text->last_anchor->number > 0 )
  {
    HText_setIgnoreExcess(text, 0);
    sprintf(marker, "[%d]", text->last_anchor->number);
    HText_appendText(text, marker);
  }
}

//----- (0806F351) --------------------------------------------------------
double __cdecl get_trans_q(int cs_from, char *givenmime)
{
  int v3; // [esp+4h] [ebp-34h]
  double df_0; // [esp+18h] [ebp-20h]
  const char *ptok; // [esp+20h] [ebp-18h]
  const char *pval; // [esp+24h] [ebp-14h]
  char *field; // [esp+28h] [ebp-10h] BYREF
  char *pair; // [esp+2Ch] [ebp-Ch] BYREF
  char *p; // [esp+30h] [ebp-8h]
  BOOLEAN tq; // [esp+37h] [ebp-1h]

  df_0 = 1.0;
  if ( givenmime && *givenmime )
  {
    p = strchr(givenmime, 59);
    if ( p )
      *p++ = 0;
    if ( !strcmp(givenmime, "*") )
      v3 = UCGetLYhndl_byMIME("utf-8");
    else
      v3 = UCGetLYhndl_byMIME(givenmime);
    tq = UCCanTranslateFromTo(cs_from, v3);
    if ( tq )
    {
      if ( p && *p )
      {
        field = p;
        while ( 1 )
        {
          pair = HTNextTok(&field, &aQ[4], &aQ[2], 0);
          if ( !pair )
            break;
          ptok = HTNextTok(&pair, "= ", 0, 0);
          if ( ptok )
          {
            pval = HTNextField(&pair);
            if ( pval )
            {
              if ( !strcasecomp(ptok, aQ) )
              {
                df_0 = strtod(pval, 0);
                return (long double)tq * df_0;
              }
            }
          }
        }
        return (long double)tq * df_0;
      }
      else
      {
        return (double)tq;
      }
    }
    else
    {
      return 0.0;
    }
  }
  else
  {
    return 0.0;
  }
}

//----- (0806F4EA) --------------------------------------------------------
int __cdecl find_best_target_cs(char **best_csname, int cs_from, const char *acceptstring)
{
  double q; // [esp+18h] [ebp-20h]
  double bestq; // [esp+20h] [ebp-18h]
  char *nextfield; // [esp+28h] [ebp-10h] BYREF
  char *field; // [esp+2Ch] [ebp-Ch]
  char *bestmime; // [esp+30h] [ebp-8h]
  char *paccept; // [esp+34h] [ebp-4h] BYREF

  paccept = 0;
  bestq = -1.0;
  bestmime = 0;
  HTSACopy(&paccept, acceptstring);
  nextfield = paccept;
  while ( 1 )
  {
    field = HTNextTok(&nextfield, &aQ[6], &aQ[2], 0);
    if ( !field )
      break;
    if ( *field )
    {
      q = get_trans_q(cs_from, field);
      if ( q > (long double)bestq )
      {
        bestq = q;
        bestmime = field;
      }
    }
  }
  if ( bestmime )
  {
    if ( !strcmp(bestmime, "*") )
      HTSACopy(best_csname, "utf-8");
    else
      HTSACopy(best_csname, bestmime);
    if ( paccept )
    {
      free(paccept);
      paccept = 0;
    }
    if ( bestq <= 0.0 )
      return -1;
    else
      return UCGetLYhndl_byMIME(*best_csname);
  }
  else
  {
    if ( paccept )
    {
      free(paccept);
      paccept = 0;
    }
    return -1;
  }
}

//----- (0806F634) --------------------------------------------------------
void __cdecl load_a_file(const char *val_used, bstring **result)
{
  FILE *v2; // eax
  char *v3; // eax
  int bytes; // [esp+18h] [ebp-110h]
  FILE *fd; // [esp+1Ch] [ebp-10Ch]
  char buffer[257]; // [esp+23h] [ebp-105h] BYREF
  unsigned int v7; // [esp+124h] [ebp-4h]

  v7 = __readgsdword(0x14u);
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "Ok, about to convert %s to mime/thingy\n", val_used);
  }
  if ( *val_used )
  {
    fd = (FILE *)fopen64(val_used, "rb");
    if ( fd )
    {
      while ( 1 )
      {
        bytes = fread(buffer, 1u, 0x100u, fd);
        if ( !bytes )
          break;
        HTSABCat(result, buffer, bytes);
      }
      LYCloseInput(fd);
    }
    else
    {
      v3 = gettext("Can't open file for uploading");
      HTAlert(v3);
    }
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0806F74C) --------------------------------------------------------
const char *__cdecl guess_content_type(const char *filename)
{
  HTFormat format; // [esp+1Ch] [ebp-Ch]
  const char *desc; // [esp+20h] [ebp-8h] BYREF
  HTAtom *encoding; // [esp+24h] [ebp-4h] BYREF

  format = HTFileFormat(filename, &encoding, &desc);
  if ( format && format->name && *format->name )
    return format->name;
  else
    return "text/plain";
}

//----- (0806F7A2) --------------------------------------------------------
void __cdecl cannot_transcode(BOOLEAN *had_warning, const char *target_csname)
{
  char *v2; // eax
  char *argument; // [esp+14h] [ebp-4h]

  if ( !*had_warning )
  {
    *had_warning = 1;
    mustshow[0] = 1;
    if ( target_csname )
      argument = (char *)target_csname;
    else
      argument = "UNKNOWN";
    v2 = gettext("Warning: Cannot transcode form data to charset %s!");
    user_message(v2, argument);
    LYSleepAlert();
  }
}

//----- (0806F7F6) --------------------------------------------------------
unsigned int __cdecl check_form_specialchars(const char *value)
{
  unsigned int result; // [esp+Ch] [ebp-4h]

  result = 0;
  while ( value && *value && result != 3 )
  {
    if ( *value == 1 || *value == 2 || *value == 7 )
    {
      result |= 2u;
    }
    else if ( *value < 0 )
    {
      result |= 1u;
    }
    ++value;
  }
  return result;
}

//----- (0806F85C) --------------------------------------------------------
void __cdecl UpdateBoundary(char **Boundary, bstring *data)
{
  int len; // [esp+Ch] [ebp-2Ch]
  char *str; // [esp+10h] [ebp-28h]
  char v4; // [esp+17h] [ebp-21h]
  char *want; // [esp+20h] [ebp-18h] BYREF
  char *text; // [esp+24h] [ebp-14h]
  int last; // [esp+28h] [ebp-10h]
  int have; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]
  char temp[2]; // [esp+36h] [ebp-2h] BYREF

  have = strlen(*Boundary);
  if ( data )
    len = data->len;
  else
    len = 0;
  last = len;
  if ( data )
    str = data->str;
  else
    str = 0;
  text = str;
  want = *Boundary;
  for ( j = 0; last - have >= j; ++j )
  {
    if ( *want == text[j] && !memcmp(want, &text[j], have) )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)text[j + have]] & 0x800) != 0 )
        v4 = 97;
      else
        v4 = 48;
      temp[0] = v4;
      temp[1] = 0;
      HTSACat(&want, temp);
      ++have;
    }
  }
  *Boundary = want;
}

//----- (0806F96E) --------------------------------------------------------
char *__cdecl convert_to_base64(const char *src, int len)
{
  const char *c_0; // [esp+1Ch] [ebp-2Ch]
  const char *c; // [esp+24h] [ebp-24h]
  int chunk; // [esp+28h] [ebp-20h]
  const char *stra; // [esp+30h] [ebp-18h]
  char *r; // [esp+34h] [ebp-14h]
  char *ra; // [esp+34h] [ebp-14h]
  int rlen; // [esp+3Ch] [ebp-Ch]
  char *dest; // [esp+40h] [ebp-8h]
  unsigned __int8 c3; // [esp+45h] [ebp-3h]
  unsigned __int8 c2; // [esp+46h] [ebp-2h]
  unsigned __int8 c1; // [esp+47h] [ebp-1h]

  rlen = 4 * ((len + 2) / 3);
  if ( rlen )
    rlen += (rlen - 1) / 76 + 1;
  dest = (char *)malloc(rlen + 1);
  if ( !dest )
    outofmem("./GridText.c", "convert_to_base64");
  r = dest;
  chunk = 0;
  while ( len > 0 )
  {
    if ( chunk == 19 )
    {
      for ( c = "\n"; c < ""; ++c )
        *r++ = *c;
      chunk = 0;
    }
    c1 = *src;
    stra = src + 1;
    c2 = *stra;
    src = stra + 1;
    *r = basis_64_23258[c1 >> 2];
    r[1] = basis_64_23258[(16 * (c1 & 3)) | (c2 >> 4)];
    ra = r + 2;
    if ( len <= 2 )
    {
      if ( len == 2 )
        *ra = basis_64_23258[4 * (c2 & 0xF)];
      else
        *ra = 61;
      ra[1] = 61;
      r = ra + 2;
    }
    else
    {
      c3 = *src++;
      *ra = basis_64_23258[(4 * (c2 & 0xF)) | (c3 >> 6)];
      ra[1] = basis_64_23258[c3 & 0x3F];
      r = ra + 2;
    }
    len -= 3;
    ++chunk;
  }
  if ( rlen )
  {
    for ( c_0 = "\n"; c_0 < ""; ++c_0 )
      *r++ = *c_0;
  }
  *r = 0;
  return dest;
}

//----- (0806FB99) --------------------------------------------------------
char *__cdecl escape_or_quote_name(const char *name, QuoteData quoting, const char *MultipartContentType)
{
  char *escaped1; // [esp+24h] [ebp-4h] BYREF

  escaped1 = 0;
  if ( (unsigned int)quoting > QUOTE_BASE64 )
  {
    if ( quoting == QUOTE_SPECIAL )
      return HTEscapeSP(name, 1u);
  }
  else if ( quoting )
  {
    HTSACopy(&escaped1, "Content-Disposition: form-data");
    HTSprintf(&escaped1, "; name=\"%s\"", name);
    if ( MultipartContentType )
      HTSprintf(&escaped1, MultipartContentType, "text/plain");
    if ( quoting == QUOTE_BASE64 )
      HTSACat(&escaped1, "\r\nContent-Transfer-Encoding: base64");
    HTSACat(&escaped1, "\r\n\r\n");
  }
  else
  {
    HTSACopy(&escaped1, name);
  }
  return escaped1;
}

//----- (0806FC76) --------------------------------------------------------
char *__cdecl escape_or_quote_value(const char *value, QuoteData quoting)
{
  int v3; // [esp+4h] [ebp-24h]
  char *escaped2; // [esp+24h] [ebp-4h] BYREF

  escaped2 = 0;
  if ( quoting == QUOTE_BASE64 )
  {
    v3 = strlen(value);
    return convert_to_base64(value, v3);
  }
  else if ( (unsigned int)quoting < QUOTE_BASE64 )
  {
    if ( value )
      HTSACopy(&escaped2, value);
    else
      HTSACopy(&escaped2, &byte_814CBAC);
  }
  else if ( quoting == QUOTE_SPECIAL )
  {
    return HTEscapeSP(value, 1u);
  }
  return escaped2;
}

//----- (0806FD00) --------------------------------------------------------
int __cdecl check_if_base64_needed(int submit_method, bstring *data)
{
  FILE *v2; // edx
  char *str; // [esp+1Ch] [ebp-2Ch]
  int len; // [esp+20h] [ebp-28h]
  int ch_0; // [esp+2Ch] [ebp-1Ch]
  int n; // [esp+34h] [ebp-14h]
  int col; // [esp+38h] [ebp-10h]
  int width; // [esp+40h] [ebp-8h]
  BOOLEAN printable; // [esp+47h] [ebp-1h]

  width = 0;
  printable = 1;
  if ( data )
    str = data->str;
  else
    str = 0;
  if ( str )
  {
    col = 0;
    if ( data )
      len = data->len;
    else
      len = 0;
    for ( n = 0; n < len; ++n )
    {
      ch_0 = (unsigned __int8)str[n];
      if ( (ch_0 & 0x80u) != 0 || (unsigned __int8)str[n] <= 0x1Fu && ch_0 != 10 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "nonprintable %d:%#x\n", n, ch_0);
        }
        printable = 0;
      }
      if ( ch_0 == 10 || ch_0 == 13 )
      {
        if ( width < col )
          width = col;
        col = 0;
      }
      else
      {
        ++col;
      }
    }
    if ( width < col )
      width = col;
  }
  return !printable && submit_method == 3 && width > 72;
}

//----- (0806FE2D) --------------------------------------------------------
int __cdecl HText_SubmitForm(FormInfo *submit_item, DocInfo *doc, char *link_name, char *link_value)
{
  FILE *v4; // edx
  FILE *v5; // eax
  int number; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  char *v9; // eax
  int v10; // ebx
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  FILE *v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  int type; // ebx
  FILE *v23; // eax
  FILE *v24; // eax
  int v25; // ebx
  FILE *v26; // eax
  FILE *v27; // eax
  FILE *v28; // eax
  char *submit_action; // ebx
  char *v30; // eax
  char *v31; // eax
  char *v32; // ebx
  FILE *v33; // eax
  char *cp_submit_value; // [esp+2Ch] [ebp-18Ch]
  QuoteData v37; // [esp+30h] [ebp-188h]
  int v38; // [esp+34h] [ebp-184h]
  char *name; // [esp+38h] [ebp-180h]
  char *value; // [esp+40h] [ebp-178h]
  const char *v41; // [esp+44h] [ebp-174h]
  char *v42; // [esp+48h] [ebp-170h]
  char *v43; // [esp+4Ch] [ebp-16Ch]
  char *v44; // [esp+50h] [ebp-168h]
  char *v45; // [esp+54h] [ebp-164h]
  const char *v46; // [esp+58h] [ebp-160h]
  const char *v47; // [esp+5Ch] [ebp-15Ch]
  const char *MIMEname; // [esp+60h] [ebp-158h]
  int value_cs; // [esp+64h] [ebp-154h]
  char *v50; // [esp+68h] [ebp-150h]
  const char *v51; // [esp+6Ch] [ebp-14Ch]
  char *v52; // [esp+70h] [ebp-148h]
  const char *v53; // [esp+74h] [ebp-144h]
  const char *v54; // [esp+78h] [ebp-140h]
  const char *v55; // [esp+7Ch] [ebp-13Ch]
  int name_cs; // [esp+80h] [ebp-138h]
  char *v57; // [esp+84h] [ebp-134h]
  const char *v58; // [esp+88h] [ebp-130h]
  char *v59; // [esp+8Ch] [ebp-12Ch]
  int len; // [esp+94h] [ebp-124h]
  const char *src; // [esp+98h] [ebp-120h]
  bstring *data; // [esp+9Ch] [ebp-11Ch]
  char *v63; // [esp+A0h] [ebp-118h]
  int first; // [esp+A4h] [ebp-114h]
  char *v65; // [esp+A8h] [ebp-110h]
  const char *v66; // [esp+B0h] [ebp-108h]
  const char *v67; // [esp+B4h] [ebp-104h]
  const char *v68; // [esp+B8h] [ebp-100h]
  const char *v69; // [esp+BCh] [ebp-FCh]
  const char *v70; // [esp+C0h] [ebp-F8h]
  const char *v71; // [esp+C4h] [ebp-F4h]
  const char *v72; // [esp+C8h] [ebp-F0h]
  const char *v73; // [esp+D0h] [ebp-E8h]
  const char *v74; // [esp+D4h] [ebp-E4h]
  const char *v75; // [esp+D8h] [ebp-E0h]
  const char *v76; // [esp+DCh] [ebp-DCh]
  const char *v77; // [esp+E0h] [ebp-D8h]
  const char *v78; // [esp+E4h] [ebp-D4h]
  const char *v79; // [esp+E8h] [ebp-D0h]
  const char *v80; // [esp+ECh] [ebp-CCh]
  const char *v81; // [esp+F0h] [ebp-C8h]
  const char *v82; // [esp+F4h] [ebp-C4h]
  const char *v83; // [esp+F8h] [ebp-C0h]
  const char *v84; // [esp+FCh] [ebp-BCh]
  int v85; // [esp+100h] [ebp-B8h]
  char *v86; // [esp+104h] [ebp-B4h]
  int v87; // [esp+108h] [ebp-B0h]
  const char *mailto_type; // [esp+10Ch] [ebp-ACh]
  const char *mailto_content; // [esp+110h] [ebp-A8h]
  const char *mailto_subject; // [esp+114h] [ebp-A4h]
  const char *Title; // [esp+118h] [ebp-A0h]
  const char *str; // [esp+11Ch] [ebp-9Ch]
  char *copied_fname; // [esp+120h] [ebp-98h] BYREF
  const char *t; // [esp+124h] [ebp-94h]
  const char *marker; // [esp+128h] [ebp-90h]
  QuoteData quoting; // [esp+12Ch] [ebp-8Ch]
  int out_cs; // [esp+130h] [ebp-88h]
  FormInfo *form_ptr_0; // [esp+134h] [ebp-84h]
  unsigned int name_is_special; // [esp+138h] [ebp-80h]
  unsigned int field_is_special; // [esp+13Ch] [ebp-7Ch]
  char *val; // [esp+140h] [ebp-78h]
  FormInfo *form_ptr; // [esp+144h] [ebp-74h]
  unsigned int form_is_special; // [esp+148h] [ebp-70h]
  int textarea_lineno; // [esp+14Ch] [ebp-6Ch]
  int target_cs; // [esp+150h] [ebp-68h]
  int result; // [esp+154h] [ebp-64h]
  int form_number; // [esp+158h] [ebp-60h]
  int anchor_limit; // [esp+15Ch] [ebp-5Ch]
  int anchor_count; // [esp+160h] [ebp-58h]
  const char *val_used; // [esp+164h] [ebp-54h]
  char *previous_blanks; // [esp+168h] [ebp-50h] BYREF
  const char *name_used; // [esp+16Ch] [ebp-4Ch]
  char *last_textarea_name; // [esp+170h] [ebp-48h]
  char *escaped2; // [esp+174h] [ebp-44h]
  char *escaped1; // [esp+178h] [ebp-40h] BYREF
  char *copied_val_used; // [esp+17Ch] [ebp-3Ch] BYREF
  char *copied_name_used; // [esp+180h] [ebp-38h] BYREF
  char *content_type_out; // [esp+184h] [ebp-34h] BYREF
  char *MultipartContentType; // [esp+188h] [ebp-30h] BYREF
  char *Boundary; // [esp+18Ch] [ebp-2Ch] BYREF
  bstring *my_query; // [esp+190h] [ebp-28h] BYREF
  TextAnchor *anchor_ptr; // [esp+194h] [ebp-24h]
  PostData *my_data; // [esp+198h] [ebp-20h]
  PerFormInfo *thisform; // [esp+19Ch] [ebp-1Ch]
  const char *target_csname; // [esp+1A0h] [ebp-18h]
  const char *out_csname; // [esp+1A4h] [ebp-14h]
  BOOLEAN first_one; // [esp+1A9h] [ebp-Fh]
  BOOLEAN skip_field; // [esp+1AAh] [ebp-Eh]
  BOOLEAN SemiColon; // [esp+1ABh] [ebp-Dh]
  BOOLEAN PlainText; // [esp+1ACh] [ebp-Ch]
  BOOLEAN success; // [esp+1ADh] [ebp-Bh]
  BOOLEAN have_accept_cs; // [esp+1AEh] [ebp-Ah]
  BOOLEAN had_chartrans_warning[9]; // [esp+1AFh] [ebp-9h] BYREF

  had_chartrans_warning[0] = 0;
  have_accept_cs = 0;
  PlainText = 0;
  SemiColon = 0;
  skip_field = 0;
  target_csname = 0;
  my_data = 0;
  my_query = 0;
  Boundary = 0;
  MultipartContentType = 0;
  content_type_out = 0;
  copied_name_used = 0;
  copied_val_used = 0;
  escaped1 = 0;
  escaped2 = 0;
  last_textarea_name = 0;
  name_used = &byte_814CBAC;
  previous_blanks = 0;
  val_used = &byte_814CBAC;
  anchor_count = 0;
  anchor_limit = 0;
  form_number = submit_item->number;
  result = 0;
  target_cs = -1;
  textarea_lineno = 0;
  form_is_special = 0;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "SubmitForm\n  link_name=%s\n  link_value=%s\n", link_name, link_value);
  }
  if ( !HTMainText )
    return 0;
  thisform = (PerFormInfo *)HTList_objectAt(HTMainText->forms, form_number - 1);
  if ( thisform )
  {
    if ( thisform->number != form_number )
    {
      if ( WWW_TraceFlag[0] )
      {
        number = thisform->number;
        v7 = TraceFP();
        fprintf(v7, "SubmitForm: failed sanity check, %d!=%d !\n", number, form_number);
      }
      thisform = 0;
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "SubmitForm: form %d not in HTMainText's list!\n", form_number);
  }
  if ( submit_item->submit_action && *submit_item->submit_action )
  {
    if ( submit_item->submit_method == 3 && strncasecomp(submit_item->submit_action, "mailto:", 7) )
    {
      v9 = gettext("Malformed mailto form submission!  Cancelled!");
      HTAlert(v9);
      return 0;
    }
    else
    {
      if ( !submit_item->submit_enctype || strncasecomp(submit_item->submit_enctype, "text/plain", 10) )
      {
        if ( !submit_item->submit_enctype
          || strncasecomp(submit_item->submit_enctype, "application/sgml-form-urlencoded", 32) )
        {
          if ( submit_item->submit_enctype && !strncasecomp(submit_item->submit_enctype, "multipart/form-data", 19) )
            Boundary = "xnyLAaB03X";
        }
        else
        {
          SemiColon = 1;
        }
      }
      else
      {
        PlainText = 1;
      }
      if ( thisform && submit_item->accept_cs && strcasecomp(submit_item->accept_cs, "UNKNOWN") )
      {
        have_accept_cs = 1;
        target_cs = find_best_target_cs(&thisform->thisacceptcs, current_char_set, submit_item->accept_cs);
      }
      if ( thisform && !have_accept_cs && thisform->accept_cs && strcasecomp(thisform->accept_cs, "UNKNOWN") )
      {
        have_accept_cs = 1;
        target_cs = find_best_target_cs(&thisform->thisacceptcs, current_char_set, thisform->accept_cs);
      }
      if ( have_accept_cs && target_cs >= 0 && thisform->thisacceptcs )
        target_csname = thisform->thisacceptcs;
      if ( target_cs < 0 && HTMainText->node_anchor->charset && *HTMainText->node_anchor->charset )
      {
        target_cs = UCGetLYhndl_byMIME(HTMainText->node_anchor->charset);
        if ( target_cs < 0 )
        {
          target_cs = UCLYhndl_for_unspec;
          target_csname = LYCharSet_UC[UCLYhndl_for_unspec].MIMEname;
        }
        else
        {
          target_csname = HTMainText->node_anchor->charset;
        }
      }
      if ( target_cs < 0 )
        target_cs = UCLYhndl_for_unspec;
      for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
      {
        if ( anchor_ptr->link_type == 2 )
        {
          if ( anchor_ptr->input_field->number != form_number || anchor_ptr->input_field->disabled )
          {
            if ( anchor_ptr->input_field->number > form_number )
              break;
          }
          else
          {
            form_ptr = anchor_ptr->input_field;
            if ( form_ptr->cp_submit_value )
              cp_submit_value = form_ptr->cp_submit_value;
            else
              cp_submit_value = form_ptr->value;
            val = cp_submit_value;
            field_is_special = check_form_specialchars(cp_submit_value);
            name_is_special = check_form_specialchars(form_ptr->name);
            form_is_special = name_is_special | field_is_special;
            if ( field_is_special
              && target_cs >= 0
              && ((field_is_special & 1) != 0
               || LYCharSet_UC[target_cs].enc != 2 && (LYCharSet_UC[target_cs].like8859 & 0x80) == 0)
              && !UCNeedNotTranslate(form_ptr->value_cs, target_cs)
              && !UCCanTranslateFromTo(form_ptr->value_cs, target_cs) )
            {
              if ( UCCanTranslateFromTo(target_cs, form_ptr->value_cs) )
              {
                target_cs = form_ptr->value_cs;
                target_csname = 0;
              }
              else
              {
                target_cs = -1;
              }
            }
            if ( name_is_special
              && target_cs >= 0
              && ((name_is_special & 1) != 0
               || LYCharSet_UC[target_cs].enc != 2 && (LYCharSet_UC[target_cs].like8859 & 0x80) == 0)
              && !UCNeedNotTranslate(form_ptr->name_cs, target_cs)
              && !UCCanTranslateFromTo(form_ptr->name_cs, target_cs) )
            {
              if ( UCCanTranslateFromTo(target_cs, form_ptr->name_cs) )
              {
                target_cs = form_ptr->value_cs;
                target_csname = 0;
              }
              else
              {
                target_cs = -1;
              }
            }
            ++anchor_limit;
          }
        }
      }
      if ( anchor_limit )
      {
        my_data = (PostData *)calloc(anchor_limit, 0x18u);
        if ( !my_data )
          outofmem("./GridText.c", "HText_SubmitForm");
      }
      if ( !target_csname && target_cs >= 0 )
      {
        if ( (form_is_special & 1) != 0 )
        {
          target_csname = LYCharSet_UC[target_cs].MIMEname;
        }
        else if ( (form_is_special & 2) != 0 )
        {
          target_csname = LYCharSet_UC[target_cs].MIMEname;
        }
        else
        {
          target_csname = "us-ascii";
        }
      }
      if ( submit_item->submit_method != 1 || Boundary )
      {
        if ( SemiColon == 1 )
        {
          HTSACopy(&content_type_out, "application/sgml-form-urlencoded");
        }
        else if ( PlainText == 1 )
        {
          HTSACopy(&content_type_out, "text/plain");
        }
        else if ( Boundary )
        {
          HTSACopy(&content_type_out, "multipart/form-data");
        }
        else
        {
          HTSACopy(&content_type_out, "application/x-www-form-urlencoded");
        }
        if ( have_accept_cs || (form_is_special & 1) != 0 || (form_is_special & 2) != 0 )
        {
          if ( target_cs >= 0 && target_csname )
          {
            if ( !Boundary
              && (HTMainText->node_anchor->charset
               && (strcmp(HTMainText->node_anchor->charset, "iso-8859-1") || strcmp(target_csname, "iso-8859-1"))
               || !HTMainText->node_anchor->charset && target_cs != UCLYhndl_for_unspec) )
            {
              HTSprintf(&content_type_out, "; charset=%s", target_csname);
            }
          }
          else
          {
            cannot_transcode(had_chartrans_warning, target_csname);
          }
        }
      }
      else
      {
        copied_fname = 0;
        HTSACopy(&copied_fname, submit_item->submit_action);
        strtok(copied_fname, "#");
        strtok(copied_fname, "?");
        HTSACat(&copied_fname, "?");
        HTSABCat0(&my_query, copied_fname);
      }
      out_csname = target_csname;
      for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
      {
        if ( anchor_ptr->link_type == 2 )
        {
          if ( anchor_ptr->input_field->number != form_number || anchor_ptr->input_field->disabled )
          {
            if ( anchor_ptr->input_field->number > form_number )
              break;
          }
          else
          {
            form_ptr_0 = anchor_ptr->input_field;
            if ( PlainText )
            {
              v37 = NO_QUOTE;
            }
            else
            {
              if ( Boundary )
                v38 = 1;
              else
                v38 = 3;
              v37 = v38;
            }
            quoting = v37;
            if ( form_ptr_0->type != 9 )
              textarea_lineno = 0;
            if ( WWW_TraceFlag[0] )
            {
              v10 = anchor_count + 1;
              v11 = TraceFP();
              fprintf(v11, "SubmitForm[%d/%d]: ", v10, anchor_limit);
            }
            if ( form_ptr_0->name )
              name = form_ptr_0->name;
            else
              name = (char *)&byte_814CBAC;
            name_used = name;
            switch ( form_ptr_0->type )
            {
              case 1:
              case 2:
              case 3:
              case 4:
              case 7:
              case 8:
              case 9:
                goto LABEL_170;
              case 5:
              case 0xC:
              case 0xD:
                if ( form_ptr_0->name && *form_ptr_0->name && !strcmp(form_ptr_0->name, link_name) )
                {
                  if ( form_ptr_0->type == 12
                    || form_ptr_0->value && *form_ptr_0->value && !strcmp(form_ptr_0->value, link_value) )
                  {
LABEL_170:
                    if ( form_ptr_0->cp_submit_value )
                      val_used = form_ptr_0->cp_submit_value;
                    else
                      val_used = form_ptr_0->value;
                    if ( check_form_specialchars(val_used) )
                    {
                      HTSACopy(&copied_val_used, val_used);
                      success = LYUCTranslateBackFormData(&copied_val_used, form_ptr_0->value_cs, target_cs, PlainText);
                      if ( WWW_TraceFlag[0] )
                      {
                        if ( success )
                          v46 = "OK";
                        else
                          v46 = "FAILED";
                        if ( target_csname )
                          v47 = target_csname;
                        else
                          v47 = "???";
                        if ( form_ptr_0->value_cs < 0 )
                          MIMEname = "???";
                        else
                          MIMEname = LYCharSet_UC[form_ptr_0->value_cs].MIMEname;
                        value_cs = form_ptr_0->value_cs;
                        if ( form_ptr_0->name )
                          v50 = form_ptr_0->name;
                        else
                          v50 = (char *)&byte_814CBAC;
                        v18 = TraceFP();
                        fprintf(v18, "field \"%s\" %d %s -> %d %s %s\n", v50, value_cs, MIMEname, target_cs, v47, v46);
                      }
                      if ( success )
                        val_used = copied_val_used;
                    }
                    else
                    {
                      if ( WWW_TraceFlag[0] )
                      {
                        if ( target_csname )
                          v51 = target_csname;
                        else
                          v51 = "???";
                        if ( form_ptr_0->name )
                          v52 = form_ptr_0->name;
                        else
                          v52 = (char *)&byte_814CBAC;
                        v19 = TraceFP();
                        fprintf(v19, "field \"%s\" %d %s OK\n", v52, target_cs, v51);
                      }
                      success = 1;
                    }
                    if ( success )
                    {
                      out_cs = target_cs;
                    }
                    else
                    {
                      cannot_transcode(had_chartrans_warning, target_csname);
                      out_cs = form_ptr_0->value_cs;
                    }
                    if ( out_cs >= 0 )
                      out_csname = LYCharSet_UC[out_cs].MIMEname;
                    if ( Boundary )
                    {
                      HTSACopy(&MultipartContentType, "\r\nContent-Type: %s");
                      if ( success || form_ptr_0->value_cs >= 0 )
                      {
                        if ( success )
                        {
                          if ( !target_csname )
                            target_csname = LYCharSet_UC[target_cs].MIMEname;
                        }
                        else
                        {
                          target_csname = 0;
                        }
                      }
                      else
                      {
                        out_csname = "UNKNOWN-8BIT";
                      }
                      if ( strcmp(out_csname, "iso-8859-1") )
                        HTSprintf(&MultipartContentType, "; charset=%s", out_csname);
                    }
                    if ( form_ptr_0->type != 9
                      || (++textarea_lineno, textarea_lineno <= 1)
                      || !last_textarea_name
                      || !form_ptr_0->name
                      || strcmp(last_textarea_name, form_ptr_0->name) )
                    {
                      if ( check_form_specialchars(name_used) )
                      {
                        HTSACopy(&copied_name_used, name_used);
                        success = LYUCTranslateBackFormData(
                                    &copied_name_used,
                                    form_ptr_0->name_cs,
                                    target_cs,
                                    PlainText);
                        if ( WWW_TraceFlag[0] )
                        {
                          if ( success )
                            v53 = "OK";
                          else
                            v53 = "FAILED";
                          if ( target_csname )
                            v54 = target_csname;
                          else
                            v54 = "???";
                          if ( form_ptr_0->name_cs < 0 )
                            v55 = "???";
                          else
                            v55 = LYCharSet_UC[form_ptr_0->name_cs].MIMEname;
                          name_cs = form_ptr_0->name_cs;
                          if ( form_ptr_0->name )
                            v57 = form_ptr_0->name;
                          else
                            v57 = (char *)&byte_814CBAC;
                          v20 = TraceFP();
                          fprintf(v20, "name \"%s\" %d %s -> %d %s %s\n", v57, name_cs, v55, target_cs, v54, v53);
                        }
                        if ( success )
                          name_used = copied_name_used;
                        if ( Boundary )
                        {
                          if ( success )
                          {
                            if ( !target_csname )
                              target_csname = LYCharSet_UC[target_cs].MIMEname;
                          }
                          else
                          {
                            HTSACopy(&MultipartContentType, &byte_814CBAC);
                            target_csname = 0;
                          }
                        }
                      }
                      else
                      {
                        if ( WWW_TraceFlag[0] )
                        {
                          if ( target_csname )
                            v58 = target_csname;
                          else
                            v58 = "???";
                          if ( form_ptr_0->name )
                            v59 = form_ptr_0->name;
                          else
                            v59 = (char *)&byte_814CBAC;
                          v21 = TraceFP();
                          fprintf(v21, "name \"%s\" %d %s OK\n", v59, target_cs, v58);
                        }
                        success = 1;
                        if ( Boundary )
                          HTSACopy(&copied_name_used, name_used);
                      }
                      if ( !success )
                        cannot_transcode(had_chartrans_warning, target_csname);
                      if ( Boundary )
                      {
                        HTMake822Word(&copied_name_used, 0);
                        name_used = copied_name_used;
                      }
                    }
                  }
                  else
                  {
                    if ( WWW_TraceFlag[0] )
                    {
                      v16 = TraceFP();
                      fprintf(v16, "skipping submit field with ");
                    }
                    if ( WWW_TraceFlag[0] )
                    {
                      if ( link_name )
                        v44 = link_name;
                      else
                        v44 = "???";
                      if ( form_ptr_0->name )
                        v45 = form_ptr_0->name;
                      else
                        v45 = "???";
                      v17 = TraceFP();
                      fprintf(v17, "name \"%s\" for link_name \"%s\", %s!\n", v45, v44, "values are different");
                    }
                  }
                }
                else
                {
                  if ( WWW_TraceFlag[0] )
                  {
                    v14 = TraceFP();
                    fprintf(v14, "skipping submit field with ");
                  }
                  if ( WWW_TraceFlag[0] )
                  {
                    if ( form_ptr_0->name && *form_ptr_0->name )
                      v41 = "not current link";
                    else
                      v41 = "no field name";
                    if ( link_name )
                      v42 = link_name;
                    else
                      v42 = "???";
                    if ( form_ptr_0->name )
                      v43 = form_ptr_0->name;
                    else
                      v43 = "???";
                    v15 = TraceFP();
                    fprintf(v15, "name \"%s\" for link_name \"%s\", %s.\n", v43, v42, v41);
                  }
                }
                break;
              case 6:
                if ( WWW_TraceFlag[0] )
                {
                  v12 = TraceFP();
                  fprintf(v12, "reset\n");
                }
                break;
              case 0xB:
                if ( form_ptr_0->value )
                  value = form_ptr_0->value;
                else
                  value = (char *)&byte_814CBAC;
                val_used = value;
                if ( WWW_TraceFlag[0] )
                {
                  v13 = TraceFP();
                  fprintf(v13, "I will submit %s (from %s)\n", val_used, name_used);
                }
                break;
              default:
                if ( WWW_TraceFlag[0] )
                {
                  type = form_ptr_0->type;
                  v23 = TraceFP();
                  fprintf(v23, "What type is %d?\n", type);
                }
                break;
            }
            skip_field = 0;
            my_data[anchor_count].first = 1;
            my_data[anchor_count].type = form_ptr_0->type;
            switch ( form_ptr_0->type )
            {
              case 1:
              case 2:
              case 7:
              case 8:
                break;
              case 3:
              case 4:
                if ( !form_ptr_0->num_value )
                  skip_field = 1;
                break;
              case 5:
              case 0xC:
              case 0xD:
                if ( !form_ptr_0->name
                  || !*form_ptr_0->name
                  || strcmp(form_ptr_0->name, link_name)
                  || form_ptr_0->type != 12
                  && (!form_ptr_0->value || !*form_ptr_0->value || strcmp(form_ptr_0->value, link_value)) )
                {
                  skip_field = 1;
                }
                break;
              case 9:
                if ( last_textarea_name && !strcmp(last_textarea_name, form_ptr_0->name) )
                {
                  my_data[anchor_count].first = 0;
                }
                else
                {
                  textarea_lineno = 1;
                  last_textarea_name = form_ptr_0->name;
                }
                break;
              case 0xB:
                load_a_file(val_used, &my_data[anchor_count].data);
                break;
              default:
                skip_field = 1;
                break;
            }
            if ( !skip_field )
            {
              HTSACopy(&my_data[anchor_count].name, name_used);
              HTSACopy(&my_data[anchor_count].value, val_used);
              if ( !my_data[anchor_count].data )
                HTSABCat0(&my_data[anchor_count].data, val_used);
              my_data[anchor_count].quote = quoting;
              if ( quoting == QUOTE_MULTI
                && check_if_base64_needed(submit_item->submit_method, my_data[anchor_count].data) )
              {
                if ( WWW_TraceFlag[0] )
                {
                  v24 = TraceFP();
                  fprintf(v24, "will encode as base64\n");
                }
                my_data[anchor_count].quote = QUOTE_BASE64;
                if ( my_data[anchor_count].data )
                  len = my_data[anchor_count].data->len;
                else
                  len = 0;
                if ( my_data[anchor_count].data )
                  src = my_data[anchor_count].data->str;
                else
                  src = 0;
                escaped2 = convert_to_base64(src, len);
                HTSABCopy0(&my_data[anchor_count].data, escaped2);
                if ( escaped2 )
                {
                  free(escaped2);
                  escaped2 = 0;
                }
              }
            }
            ++anchor_count;
            if ( copied_name_used )
            {
              free(copied_name_used);
              copied_name_used = 0;
            }
            if ( copied_val_used )
            {
              free(copied_val_used);
              copied_val_used = 0;
            }
          }
        }
      }
      if ( copied_name_used )
      {
        free(copied_name_used);
        copied_name_used = 0;
      }
      if ( my_data )
      {
        first_one = 1;
        if ( content_type_out && Boundary )
        {
          Boundary = 0;
          HTSACopy(&Boundary, "LYNX");
          for ( anchor_count = 0; anchor_count < anchor_limit; ++anchor_count )
          {
            if ( my_data[anchor_count].data )
              UpdateBoundary(&Boundary, my_data[anchor_count].data);
          }
          HTSprintf(&content_type_out, "; boundary=%s", Boundary);
        }
        for ( anchor_count = 0; anchor_count < anchor_limit; ++anchor_count )
        {
          if ( my_data[anchor_count].name && my_data[anchor_count].value )
          {
            if ( WWW_TraceFlag[0] )
            {
              data = my_data[anchor_count].data;
              if ( my_data[anchor_count].value )
                v63 = my_data[anchor_count].value;
              else
                v63 = (char *)&byte_814CBAC;
              first = my_data[anchor_count].first;
              if ( my_data[anchor_count].name )
                v65 = my_data[anchor_count].name;
              else
                v65 = (char *)&byte_814CBAC;
              v25 = anchor_count + 1;
              v26 = TraceFP();
              fprintf(
                v26,
                "processing [%d:%d] name=%s(first:%d, value=%s, data=%p)\n",
                v25,
                anchor_limit,
                v65,
                first,
                v63,
                data);
            }
            if ( my_data[anchor_count].first )
            {
              if ( first_one )
              {
                if ( Boundary )
                  HTBprintf(&my_query, "--%s\r\n", Boundary);
                first_one = 0;
              }
              else if ( PlainText )
              {
                HTSABCat0(&my_query, "\n");
              }
              else if ( SemiColon )
              {
                HTSABCat0(&my_query, &aQ[4]);
              }
              else if ( Boundary )
              {
                HTBprintf(&my_query, "\r\n--%s\r\n", Boundary);
              }
              else
              {
                HTSABCat0(&my_query, "&");
              }
            }
            HTSABCat(&my_data[anchor_count].data, &byte_814CBAC, 1);
            name_used = my_data[anchor_count].name;
            val_used = my_data[anchor_count].value;
            switch ( my_data[anchor_count].type )
            {
              case 1:
              case 2:
              case 7:
              case 8:
                escaped1 = escape_or_quote_name(
                             my_data[anchor_count].name,
                             my_data[anchor_count].quote,
                             MultipartContentType);
                escaped2 = escape_or_quote_value(val_used, my_data[anchor_count].quote);
                if ( PlainText && *escaped2 )
                  v66 = "\n";
                else
                  v66 = &byte_814CBAC;
                if ( PlainText )
                  v67 = "\n";
                else
                  v67 = &byte_814CBAC;
                if ( Boundary )
                  v68 = &byte_814CBAC;
                else
                  v68 = "=";
                HTBprintf(&my_query, "%s%s%s%s%s", escaped1, v68, v67, escaped2, v66);
                break;
              case 3:
              case 4:
                escaped1 = escape_or_quote_name(
                             my_data[anchor_count].name,
                             my_data[anchor_count].quote,
                             MultipartContentType);
                escaped2 = escape_or_quote_value(val_used, my_data[anchor_count].quote);
                if ( PlainText && *escaped2 )
                  v69 = "\n";
                else
                  v69 = &byte_814CBAC;
                if ( PlainText )
                  v70 = "\n";
                else
                  v70 = &byte_814CBAC;
                if ( Boundary )
                  v71 = &byte_814CBAC;
                else
                  v71 = "=";
                HTBprintf(&my_query, "%s%s%s%s%s", escaped1, v71, v70, escaped2, v69);
                break;
              case 5:
              case 0xC:
              case 0xD:
                escaped1 = escape_or_quote_name(
                             my_data[anchor_count].name,
                             my_data[anchor_count].quote,
                             MultipartContentType);
                escaped2 = escape_or_quote_value(val_used, my_data[anchor_count].quote);
                if ( my_data[anchor_count].type == 13 )
                {
                  if ( Boundary )
                  {
                    strchr(escaped1, 61)[1] = 0;
                    HTBprintf(
                      &my_query,
                      "%s\"%s.x\"\r\n\r\n0\r\n--%s\r\n%s\"%s.y\"\r\n\r\n0",
                      escaped1,
                      my_data[anchor_count].name,
                      Boundary,
                      escaped1,
                      my_data[anchor_count].name);
                  }
                  else
                  {
                    if ( PlainText && *escaped1 )
                      v72 = "\n";
                    else
                      v72 = &byte_814CBAC;
                    if ( PlainText )
                    {
                      v73 = "\n";
                    }
                    else
                    {
                      if ( SemiColon )
                        v74 = aQ + 4;
                      else
                        v74 = "&";
                      v73 = v74;
                    }
                    HTBprintf(&my_query, "%s.x=0%s%s.y=0%s", escaped1, v73, escaped1, v72);
                  }
                }
                else
                {
                  if ( PlainText && *escaped2 )
                    v75 = "\n";
                  else
                    v75 = &byte_814CBAC;
                  if ( PlainText )
                    v76 = "\n";
                  else
                    v76 = &byte_814CBAC;
                  if ( Boundary )
                    v77 = &byte_814CBAC;
                  else
                    v77 = "=";
                  HTBprintf(&my_query, "%s%s%s%s%s", escaped1, v77, v76, escaped2, v75);
                }
                break;
              case 9:
                escaped2 = escape_or_quote_value(val_used, my_data[anchor_count].quote);
                if ( my_data[anchor_count].first )
                {
                  textarea_lineno = 1;
                  if ( PlainText )
                  {
                    if ( previous_blanks )
                    {
                      free(previous_blanks);
                      previous_blanks = 0;
                    }
                  }
                  else if ( Boundary )
                  {
                    HTSACopy(&previous_blanks, "\r\n");
                  }
                  else
                  {
                    HTSACopy(&previous_blanks, "%0d%0a");
                  }
                  escaped1 = escape_or_quote_name(name_used, my_data[anchor_count].quote, MultipartContentType);
                  if ( PlainText && *escaped2 )
                    v78 = "\n";
                  else
                    v78 = &byte_814CBAC;
                  if ( PlainText )
                    v79 = "\n";
                  else
                    v79 = &byte_814CBAC;
                  if ( Boundary )
                    v80 = &byte_814CBAC;
                  else
                    v80 = "=";
                  HTBprintf(&my_query, "%s%s%s%s%s", escaped1, v80, v79, escaped2, v78);
                }
                else
                {
                  if ( PlainText )
                  {
                    v81 = "\n";
                  }
                  else
                  {
                    if ( Boundary )
                      v82 = "\r\n";
                    else
                      v82 = "%0d%0a";
                    v81 = v82;
                  }
                  marker = v81;
                  if ( *escaped2 )
                  {
                    if ( previous_blanks )
                    {
                      HTSABCat0(&my_query, previous_blanks);
                      if ( previous_blanks )
                      {
                        free(previous_blanks);
                        previous_blanks = 0;
                      }
                    }
                    HTSABCat0(&my_query, escaped2);
                    if ( PlainText || Boundary )
                      HTSABCat0(&my_query, marker);
                    else
                      HTSACopy(&previous_blanks, marker);
                  }
                  else
                  {
                    HTSACat(&previous_blanks, marker);
                  }
                }
                break;
              case 0xB:
                if ( PlainText )
                {
                  HTSACopy(&escaped1, my_data[anchor_count].name);
                }
                else if ( Boundary )
                {
                  t = guess_content_type(val_used);
                  copied_fname = 0;
                  HTSACopy(&escaped1, "Content-Disposition: form-data");
                  HTSprintf(&escaped1, "; name=\"%s\"", my_data[anchor_count].name);
                  HTSACopy(&copied_fname, val_used);
                  HTMake822Word(&copied_fname, 0);
                  HTSprintf(&escaped1, "; filename=\"%s\"", copied_fname);
                  if ( copied_fname )
                  {
                    free(copied_fname);
                    copied_fname = 0;
                  }
                  HTSprintf(&escaped1, "\r\nContent-Type: %s", t);
                  if ( my_data[anchor_count].quote == QUOTE_BASE64 )
                    HTSACat(&escaped1, "\r\nContent-Transfer-Encoding: base64");
                  HTSACat(&escaped1, "\r\n\r\n");
                }
                else
                {
                  escaped1 = HTEscapeSP(my_data[anchor_count].name, 1u);
                }
                if ( PlainText )
                  v83 = "\n";
                else
                  v83 = &byte_814CBAC;
                if ( Boundary )
                  v84 = &byte_814CBAC;
                else
                  v84 = "=";
                HTBprintf(&my_query, "%s%s%s", escaped1, v84, v83);
                if ( my_data[anchor_count].data && my_data[anchor_count].data->len > 1 )
                {
                  v85 = my_data[anchor_count].data ? my_data[anchor_count].data->len - 1 : -1;
                  v86 = my_data[anchor_count].data ? my_data[anchor_count].data->str : 0;
                  HTSABCat(&my_query, v86, v85);
                  if ( PlainText )
                    HTBprintf(&my_query, "\n");
                }
                break;
              default:
                break;
            }
            if ( escaped1 )
            {
              free(escaped1);
              escaped1 = 0;
            }
            if ( escaped2 )
            {
              free(escaped2);
              escaped2 = 0;
            }
          }
        }
        if ( Boundary )
          HTBprintf(&my_query, "\r\n--%s--\r\n", Boundary);
        if ( WWW_TraceFlag[0] )
        {
          v87 = my_query ? my_query->len : 0;
          v27 = TraceFP();
          fprintf(v27, "Query %d{", v87);
          trace_bstring(my_query);
          if ( WWW_TraceFlag[0] )
          {
            v28 = TraceFP();
            fprintf(v28, "}\n");
          }
        }
      }
      if ( submit_item->submit_method == 3 )
      {
        submit_action = submit_item->submit_action;
        v30 = gettext("Submitting %s");
        HTUserMsg2(v30, submit_action);
        HTSABCat(&my_query, &byte_814CBAC, 1);
        mailto_type = content_type_out;
        if ( my_query )
          mailto_content = my_query->str;
        else
          mailto_content = 0;
        if ( submit_item->submit_title && *submit_item->submit_title )
        {
          mailto_subject = submit_item->submit_title;
        }
        else
        {
          if ( HText_getTitle() )
            Title = HText_getTitle();
          else
            Title = &byte_814CBAC;
          mailto_subject = Title;
        }
        mailform((const char *)submit_item->submit_action + 7, mailto_subject, mailto_content, mailto_type);
        result = 0;
        HTSABFree(&my_query);
        if ( content_type_out )
        {
          free(content_type_out);
          content_type_out = 0;
        }
      }
      else
      {
        mustshow[0] = 1;
        v31 = gettext("Submitting form...");
        statusline(v31);
        if ( submit_item->submit_method == 2 || Boundary )
        {
          LYFreePostData(doc);
          doc->post_data = my_query;
          doc->post_content_type = content_type_out;
          if ( WWW_TraceFlag[0] )
          {
            v32 = content_type_out;
            v33 = TraceFP();
            fprintf(v33, "GridText - post_data set:\n%s\n", v32);
          }
          HTSACopy(&doc->address, submit_item->submit_action);
        }
        else
        {
          HTSABCat(&my_query, &byte_814CBAC, 1);
          if ( my_query )
            str = my_query->str;
          else
            str = 0;
          HTSACopy(&doc->address, str);
          LYFreePostData(doc);
          if ( content_type_out )
          {
            free(content_type_out);
            content_type_out = 0;
          }
        }
        result = 1;
      }
      if ( MultipartContentType )
      {
        free(MultipartContentType);
        MultipartContentType = 0;
      }
      if ( previous_blanks )
      {
        free(previous_blanks);
        previous_blanks = 0;
      }
      if ( Boundary )
      {
        free(Boundary);
        Boundary = 0;
      }
      if ( my_data )
      {
        for ( anchor_count = 0; anchor_count < anchor_limit; ++anchor_count )
        {
          if ( my_data[anchor_count].name )
          {
            free(my_data[anchor_count].name);
            my_data[anchor_count].name = 0;
          }
          if ( my_data[anchor_count].value )
          {
            free(my_data[anchor_count].value);
            my_data[anchor_count].value = 0;
          }
          HTSABFree(&my_data[anchor_count].data);
        }
        if ( my_data )
        {
          free(my_data);
          my_data = 0;
        }
      }
      return result;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v8 = TraceFP();
      fprintf(v8, "SubmitForm: no action given\n");
    }
    return 0;
  }
}

//----- (080724E9) --------------------------------------------------------
void HText_DisableCurrentForm()
{
  TextAnchor *anchor_ptr; // [esp+Ch] [ebp-4h]

  HTFormDisabled[0] = 1;
  if ( HTMainText )
  {
    for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
    {
      if ( anchor_ptr->link_type == 2 && anchor_ptr->input_field->number == HTFormNumber )
        anchor_ptr->input_field->disabled = 1;
    }
  }
}

//----- (08072549) --------------------------------------------------------
void __cdecl HText_ResetForm(FormInfo *form)
{
  char *v1; // eax
  TextAnchor *anchor_ptr; // [esp+14h] [ebp-4h]

  mustshow[0] = 1;
  v1 = gettext("Resetting form...");
  statusline(v1);
  if ( HTMainText )
  {
    for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
    {
      if ( anchor_ptr->link_type == 2 )
      {
        if ( anchor_ptr->input_field->number == form->number )
        {
          if ( anchor_ptr->input_field->type == 4 || anchor_ptr->input_field->type == 3 )
          {
            anchor_ptr->input_field->num_value = *anchor_ptr->input_field->orig_value != 48;
          }
          else if ( anchor_ptr->input_field->type == 7 )
          {
            anchor_ptr->input_field->value = anchor_ptr->input_field->orig_value;
            anchor_ptr->input_field->cp_submit_value = anchor_ptr->input_field->orig_submit_value;
          }
          else
          {
            HTSACopy(&anchor_ptr->input_field->value, anchor_ptr->input_field->orig_value);
          }
        }
        else if ( anchor_ptr->input_field->number > form->number )
        {
          return;
        }
      }
    }
  }
}

//----- (08072675) --------------------------------------------------------
BOOLEAN __cdecl HText_HaveUserChangedForms(HText *text)
{
  TextAnchor *anchor_ptr; // [esp+24h] [ebp-4h]

  if ( !text )
    return 0;
  for ( anchor_ptr = text->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
  {
    if ( anchor_ptr->link_type == 2 )
    {
      if ( anchor_ptr->input_field->type == 4 || anchor_ptr->input_field->type == 3 )
      {
        if ( *anchor_ptr->input_field->orig_value == 48 && anchor_ptr->input_field->num_value == 1
          || *anchor_ptr->input_field->orig_value != 48 && !anchor_ptr->input_field->num_value )
        {
          return 1;
        }
      }
      else if ( anchor_ptr->input_field->type == 7 )
      {
        if ( strcmp(anchor_ptr->input_field->value, anchor_ptr->input_field->orig_value) )
          return 1;
        if ( strcmp(anchor_ptr->input_field->cp_submit_value, anchor_ptr->input_field->orig_submit_value) )
          return 1;
      }
      else if ( strcmp(anchor_ptr->input_field->value, anchor_ptr->input_field->orig_value) )
      {
        return 1;
      }
    }
  }
  return 0;
}

//----- (080727B4) --------------------------------------------------------
void __cdecl HText_activateRadioButton(FormInfo *form)
{
  int form_number; // [esp+10h] [ebp-8h]
  TextAnchor *anchor_ptr; // [esp+14h] [ebp-4h]

  form_number = form->number;
  if ( HTMainText )
  {
    for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
    {
      if ( anchor_ptr->link_type == 2 && anchor_ptr->input_field->type == 4 )
      {
        if ( anchor_ptr->input_field->number == form_number )
        {
          if ( !strcmp(anchor_ptr->input_field->name, form->name) && anchor_ptr->input_field->num_value )
          {
            anchor_ptr->input_field->num_value = 0;
            break;
          }
        }
        else if ( anchor_ptr->input_field->number > form_number )
        {
          break;
        }
      }
    }
    form->num_value = 1;
  }
}

//----- (08072868) --------------------------------------------------------
char *__cdecl stub_HTAnchor_address(HTAnchor *me)
{
  char *addr; // [esp+14h] [ebp-4h] BYREF

  addr = 0;
  if ( me )
    HTSACopy(&addr, me->parent->address);
  return addr;
}

//----- (08072897) --------------------------------------------------------
void __cdecl HText_setToolbar(HText *text)
{
  if ( text )
    text->toolbar = 1;
}

//----- (080728AC) --------------------------------------------------------
BOOLEAN __cdecl HText_hasToolbar(HText *text)
{
  return text && text->toolbar;
}

//----- (080728DC) --------------------------------------------------------
void __cdecl HText_setNoCache(HText *text)
{
  if ( text )
    text->no_cache = 1;
}

//----- (080728F1) --------------------------------------------------------
BOOLEAN __cdecl HText_hasNoCacheSet(HText *text)
{
  return text && text->no_cache;
}

//----- (08072921) --------------------------------------------------------
BOOLEAN __cdecl HText_hasUTF8OutputSet(HText *text)
{
  return text && text->T.output_utf8;
}

//----- (08072951) --------------------------------------------------------
void __cdecl HText_setKcode(HText *text, const char *charset, LYUCcharset *p_in)
{
  bool charset_explicit; // [esp+27h] [ebp-1h]

  if ( text && (charset || p_in) )
  {
    charset_explicit = charset != 0;
    if ( !charset || !*charset )
      charset = p_in->MIMEname;
    if ( charset && *charset )
    {
      if ( charset_explicit
        && (!strcmp(charset, "shift_jis") || !strcmp(charset, "x-sjis") || !strcmp(charset, "x-shift-jis")) )
      {
        text->kcode = SJIS;
      }
      else if ( charset_explicit
             && strcmp(charset, "utf-8")
             && (p_in && p_in->enc == 5
              || !strcmp(charset, "x-euc")
              || !strcmp(charset, "euc-jp")
              || !strncmp(charset, "x-euc-", 6u)
              || !strcmp(charset, "euc-kr")
              || !strcmp(charset, "iso-2022-kr")
              || !strcmp(charset, "big5")
              || !strcmp(charset, "cn-big5")
              || !strcmp(charset, "euc-cn")
              || !strcmp(charset, "gb2312")
              || !strncmp(charset, "cn-gb", 5u)
              || !strcmp(charset, "iso-2022-cn")) )
      {
        text->kcode = EUC;
      }
      else
      {
        text->kcode = NOKANJI;
        if ( HTCJK && (!p_in || p_in->enc != 5 && p_in->enc != 7) )
          HTCJK = NOCJK;
      }
      if ( !charset_explicit || !strcmp(charset, "utf-8") )
      {
        if ( UCAssume_MIMEcharset )
        {
          if ( !strcmp(UCAssume_MIMEcharset, "euc-jp") )
          {
            text->specified_kcode = EUC;
            text->kcode = text->specified_kcode;
          }
          else if ( !strcmp(UCAssume_MIMEcharset, "shift_jis") )
          {
            text->specified_kcode = SJIS;
            text->kcode = text->specified_kcode;
          }
        }
      }
      else
      {
        text->specified_kcode = text->kcode;
      }
    }
  }
}

//----- (08072C5D) --------------------------------------------------------
void __cdecl HText_setBreakPoint(HText *text)
{
  if ( text )
    text->permissible_split = text->last_line->size;
}

//----- (08072C7E) --------------------------------------------------------
BOOLEAN __cdecl HText_AreDifferent(HTParentAnchor *anchor, const char *full_address)
{
  char *address; // [esp+14h] [ebp-14h]
  char *MTpound; // [esp+1Ch] [ebp-Ch]
  HTParentAnchor *MTanc; // [esp+24h] [ebp-4h]

  if ( !HTMainText || !anchor || !full_address )
    return 1;
  MTanc = HTMainText->node_anchor;
  if ( !HTMainText->node_anchor->address || !anchor->address )
    return 1;
  if ( !strchr(full_address, 35) )
    return 1;
  if ( !strncasecomp(anchor->address, "LYNXIMGMAP:", 11) )
    return 1;
  if ( MTanc->isHEAD != anchor->isHEAD )
    return 1;
  if ( strncasecomp(MTanc->address, "LYNXIMGMAP:", 11) )
    address = MTanc->address;
  else
    address = MTanc->address + 11;
  MTpound = trimPoundSelector(address);
  if ( !strcmp(address, anchor->address) )
  {
    if ( MTpound )
      *MTpound = 35;
    if ( MTanc->address == address )
    {
      if ( MTanc->post_data )
      {
        if ( !anchor->post_data )
          return 1;
        if ( !HTSABEql(MTanc->post_data, anchor->post_data) )
          return 1;
      }
      else if ( anchor->post_data )
      {
        return 1;
      }
    }
    return 0;
  }
  if ( MTpound )
    *MTpound = 35;
  return 1;
}

//----- (08072E14) --------------------------------------------------------
int __cdecl increment_tagged_htline(HTLine *ht, TextAnchor *a, int *lx_val, int *old_val, int incr, int mode)
{
  size_t v8; // eax
  char *v10; // [esp+4h] [ebp-C64h]
  HTLine *hta; // [esp+24h] [ebp-C44h]
  HTLine *temp; // [esp+2Ch] [ebp-C3Ch]
  int fixup; // [esp+30h] [ebp-C38h]
  int post_n; // [esp+34h] [ebp-C34h]
  int pre_n; // [esp+38h] [ebp-C30h]
  int new_na; // [esp+3Ch] [ebp-C2Ch]
  int new_n; // [esp+3Ch] [ebp-C2Ch]
  int new_nb; // [esp+3Ch] [ebp-C2Ch]
  int n; // [esp+40h] [ebp-C28h]
  int na; // [esp+40h] [ebp-C28h]
  int nb; // [esp+40h] [ebp-C28h]
  int val; // [esp+44h] [ebp-C24h]
  int vala; // [esp+44h] [ebp-C24h]
  char *t; // [esp+48h] [ebp-C20h]
  char *ta; // [esp+48h] [ebp-C20h]
  char *s; // [esp+50h] [ebp-C18h]
  char *p; // [esp+54h] [ebp-C14h]
  TextAnchor *nxt_anchor; // [esp+58h] [ebp-C10h]
  TextAnchor *nxt_anchora; // [esp+58h] [ebp-C10h]
  TextAnchor *st_anchor; // [esp+5Ch] [ebp-C0Ch]
  BOOLEAN valid; // [esp+62h] [ebp-C06h]
  BOOLEAN valida; // [esp+62h] [ebp-C06h]
  BOOLEAN plx; // [esp+63h] [ebp-C05h]
  char lxbuf[2048]; // [esp+64h] [ebp-C04h] BYREF
  char buf[1024]; // [esp+864h] [ebp-404h] BYREF
  unsigned int v36; // [esp+C64h] [ebp-4h]

  hta = ht;
  v36 = __readgsdword(0x14u);
  st_anchor = a;
  p = ht->data;
  s = buf;
  plx = 0;
  fixup = 0;
  if ( *lx_val )
  {
    for ( nxt_anchor = a; nxt_anchor && nxt_anchor->line_num == a->line_num; nxt_anchor = nxt_anchor->next )
      nxt_anchor->line_pos += *(_WORD *)lx_val;
    fixup = *lx_val;
    *lx_val = 0;
    if ( a )
      st_anchor = a->next;
  }
  while ( *p )
  {
    if ( *p == 91 )
    {
      *s++ = *p;
      t = ++p;
      n = 0;
      valid = 1;
      while ( *t != 93 )
      {
        if ( !*t )
        {
          valid = 0;
          plx = 1;
          break;
        }
        if ( ((*__ctype_b_loc())[(unsigned __int8)*t++] & 0x800) == 0 )
        {
          valid = 0;
          break;
        }
        ++n;
      }
      if ( valid )
      {
        if ( n > 0 )
        {
          val = atoi(p);
          if ( *old_val == val || !*old_val )
          {
            if ( *old_val )
              ++*old_val;
            sprintf(s, "%d", incr + val);
            new_na = strlen(s);
            s += new_na;
            p += n;
            new_n = new_na - n;
            if ( new_n )
            {
              for ( nxt_anchora = st_anchor;
                    nxt_anchora && nxt_anchora->line_num == a->line_num;
                    nxt_anchora = nxt_anchora->next )
              {
                nxt_anchora->line_pos += new_n;
              }
              if ( st_anchor )
                st_anchor = st_anchor->next;
            }
          }
        }
      }
      pre_n = strlen(p);
      post_n = strlen(ht->next->data);
      if ( plx && post_n + pre_n + 2 <= 2047 )
      {
        strcpy(lxbuf, p);
        strcat(lxbuf, ht->next->data);
        ta = lxbuf;
        na = 0;
        valida = 1;
        while ( *ta != 93 )
        {
          if ( ((*__ctype_b_loc())[(unsigned __int8)*ta++] & 0x800) == 0 )
          {
            valida = 0;
            break;
          }
          ++na;
        }
        if ( valida )
        {
          if ( na > 0 && post_n + na + 2 <= 1023 )
          {
            vala = atoi(lxbuf);
            if ( *old_val == vala || !*old_val )
            {
              if ( *old_val )
                ++*old_val;
              sprintf(lxbuf, "%d", incr + vala);
              new_nb = strlen(lxbuf);
              v10 = strchr(ht->next->data, 93);
              strcat(lxbuf, v10);
              s = &strncpy(s, lxbuf, pre_n)[pre_n];
              strcpy(ht->next->data, &lxbuf[pre_n]);
              *lx_val = new_nb - na;
            }
          }
        }
        break;
      }
    }
    else
    {
      *s++ = *p++;
    }
  }
  *s = 0;
  nb = strlen(ht->data);
  if ( mode == 1 )
  {
    buf[nb] = 0;
  }
  else if ( strlen(buf) > ht->size )
  {
    v8 = strlen(buf);
    temp = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool, v8 + 20);
    if ( !temp )
      outofmem("./GridText.c", "increment_tagged_htline");
    memcpy(temp, ht, sizeof(HTLine));
    temp->styles = ALLOC_IN_POOL(&HTMainText->pool, 4 * ht->numstyles);
    if ( !temp->styles )
      outofmem("./GridText.c", "increment_tagged_htline");
    memcpy(temp->styles, ht->styles, 4 * ht->numstyles);
    hta = temp;
    temp->prev->next = temp;
    temp->next->prev = temp;
  }
  strcpy(hta->data, buf);
  return strlen(buf) - nb + fixup;
}

//----- (080735AC) --------------------------------------------------------
void __cdecl insert_new_textarea_anchor(TextAnchor **curr_anchor, HTLine **exit_htline)
{
  int i; // [esp+18h] [ebp-20h]
  int lx; // [esp+1Ch] [ebp-1Ch] BYREF
  int curr_tag; // [esp+20h] [ebp-18h] BYREF
  HTLine *l; // [esp+24h] [ebp-14h]
  FormInfo *f; // [esp+28h] [ebp-10h]
  TextAnchor *a; // [esp+2Ch] [ebp-Ch]
  HTLine *htline; // [esp+30h] [ebp-8h]
  TextAnchor *anchor; // [esp+34h] [ebp-4h]

  anchor = *curr_anchor;
  a = 0;
  f = 0;
  l = 0;
  curr_tag = 0;
  lx = 0;
  htline = HTMainText->last_line->next;
  for ( i = 0; anchor->line_num != i; ++i )
  {
    htline = htline->next;
    if ( HTMainText->last_line == htline )
      break;
  }
  l = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool, 0x414u);
  a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool, 0x34u);
  f = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool, 0x60u);
  if ( !a || !l || !f )
    outofmem("./GridText.c", "insert_new_textarea_anchor");
  a->next = anchor->next;
  a->number = anchor->number;
  a->line_pos = anchor->line_pos;
  a->extent = anchor->extent;
  a->sgml_offset = SGML_offset();
  a->line_num = anchor->line_num + 1;
  LYCopyHiText(a, anchor);
  a->link_type = anchor->link_type;
  a->input_field = f;
  a->show_anchor = anchor->show_anchor;
  a->inUnderline = anchor->inUnderline;
  a->expansion_anch = 1;
  a->anchor = 0;
  HTSACopy(&f->name, anchor->input_field->name);
  f->number = anchor->input_field->number;
  f->type = anchor->input_field->type;
  HTSACopy(&f->orig_value, &byte_814CBAC);
  f->size = anchor->input_field->size;
  f->maxlength = anchor->input_field->maxlength;
  f->no_cache = anchor->input_field->no_cache;
  f->disabled = anchor->input_field->disabled;
  f->value_cs = current_char_set;
  l->next = htline->next;
  l->prev = htline;
  l->offset = htline->offset;
  l->size = htline->size;
  l->numstyles = htline->numstyles;
  l->styles = htline->styles;
  strcpy(l->data, htline->data);
  htline->next->prev = l;
  htline->next = l;
  if ( keypad_mode == 3 || keypad_mode == 2 )
  {
    ++a->number;
    increment_tagged_htline(l, a, &lx, &curr_tag, 1, 1);
  }
  if ( HTMainText->last_anchor == anchor )
    HTMainText->last_anchor = a;
  if ( HTMainText->last_line == htline )
    HTMainText->last_line = l;
  anchor->next = a;
  *curr_anchor = a;
  *exit_htline = l->next;
}

//----- (080738E4) --------------------------------------------------------
void __cdecl update_subsequent_anchors(int newlines, TextAnchor *start_anchor, HTLine *start_htline, int start_tag)
{
  FILE *v4; // eax
  FILE *v5; // eax
  char *v6; // eax
  int hang; // [esp+20h] [ebp-18h]
  int lx; // [esp+24h] [ebp-14h] BYREF
  int tag_adj; // [esp+28h] [ebp-10h]
  int line_adj; // [esp+2Ch] [ebp-Ch]
  HTLine *htline; // [esp+30h] [ebp-8h]
  TextAnchor *anchor; // [esp+34h] [ebp-4h]

  htline = start_htline;
  line_adj = 0;
  tag_adj = 0;
  lx = 0;
  hang = 0;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "GridText: adjusting struct's to add %d new line(s)\n", newlines);
  }
  for ( anchor = start_anchor->next; anchor; anchor = anchor->next )
  {
    if ( (keypad_mode == 3 || keypad_mode == 2) && anchor->number )
      anchor->number += newlines;
    anchor->line_num += newlines;
  }
  if ( keypad_mode == 3 || keypad_mode == 2 )
  {
    anchor = start_anchor->next;
    while ( HTMainText->last_line->next != htline )
    {
      while ( anchor && anchor->number - newlines != start_tag )
      {
        ++hang;
        if ( anchor->next == anchor || hang >= 100000 )
        {
          v6 = gettext("Hang Detect: TextAnchor struct corrupted - suggest aborting!");
          HTAlert(v6);
          goto finish;
        }
        anchor = anchor->next;
      }
      if ( !anchor )
        break;
      line_adj = increment_tagged_htline(htline, anchor, &lx, &start_tag, newlines, 0);
      htline->size += line_adj;
      tag_adj += line_adj;
      htline = htline->next;
    }
  }
finish:
  nlinks += newlines;
  HTMainText->Lines += newlines;
  HTMainText->last_anchor_number += newlines;
  more_text = HText_canScrollDown();
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "GridText: TextAnchor and HTLine struct's adjusted\n");
  }
}

//----- (08073AE9) --------------------------------------------------------
BOOLEAN __cdecl IsFormsTextarea(FormInfo *form, TextAnchor *anchor_ptr)
{
  return anchor_ptr->link_type == 2
      && anchor_ptr->input_field->type == 9
      && anchor_ptr->input_field->number == form->number
      && !strcmp(anchor_ptr->input_field->name, form->name);
}

//----- (08073B4E) --------------------------------------------------------
int __cdecl finish_ExtEditForm(LinkInfo *form_link, TextAnchor *start_anchor, char *ed_temp, int orig_cnt)
{
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  FILE *v8; // eax
  stat stat_info; // [esp+20h] [ebp-B8h] BYREF
  int i; // [esp+80h] [ebp-58h]
  int skip_num; // [esp+84h] [ebp-54h]
  char *skip_at; // [esp+88h] [ebp-50h]
  int wanted_fieldlen_wrap; // [esp+8Ch] [ebp-4Ch]
  int len_in; // [esp+90h] [ebp-48h]
  int len0; // [esp+94h] [ebp-44h]
  int len; // [esp+98h] [ebp-40h]
  int newlines; // [esp+9Ch] [ebp-3Ch]
  int match_tag; // [esp+A0h] [ebp-38h]
  char *cp; // [esp+A4h] [ebp-34h]
  char *lp; // [esp+A8h] [ebp-30h]
  char *line; // [esp+ACh] [ebp-2Ch]
  char *ebuf; // [esp+B0h] [ebp-28h]
  HTLine *htline; // [esp+B4h] [ebp-24h] BYREF
  int line_cnt; // [esp+B8h] [ebp-20h]
  int exit_line; // [esp+BCh] [ebp-1Ch]
  int entry_line; // [esp+C0h] [ebp-18h]
  TextAnchor *end_anchor; // [esp+C4h] [ebp-14h] BYREF
  TextAnchor *anchor_ptr; // [esp+C8h] [ebp-10h]
  FILE *fp; // [esp+CCh] [ebp-Ch]
  size_t size; // [esp+D0h] [ebp-8h]
  BOOLEAN wrapalert; // [esp+D7h] [ebp-1h]

  end_anchor = 0;
  wrapalert = 0;
  entry_line = form_link->anchor_line_num;
  exit_line = 0;
  line_cnt = 1;
  htline = 0;
  match_tag = 0;
  newlines = 0;
  wanted_fieldlen_wrap = -1;
  skip_at = 0;
  skip_num = 0;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "GridText: entered HText_ExtEditForm()\n");
  }
  if ( stat64((int)ed_temp, (int)&stat_info) < 0
    || (stat_info.st_mode & 0xF000) != 0x8000
    || (size = stat_info.st_size) == 0 )
  {
    size = 0;
    ebuf = (char *)calloc(1u, 1u);
    if ( !ebuf )
      outofmem("./GridText.c", "HText_ExtEditForm");
    while ( 1 )
    {
LABEL_12:
      if ( !size )
      {
LABEL_22:
        line = (char *)malloc(0x400u);
        if ( !line )
          outofmem("./GridText.c", "HText_ExtEditForm");
        anchor_ptr = start_anchor;
        if ( start_anchor->input_field->size <= 4 || anchor_ptr->input_field->size > 1023 )
          wanted_fieldlen_wrap = 0;
        len_in = 0;
        len = 0;
        lp = ebuf;
        while ( line_cnt <= orig_cnt || *lp || len && !*lp )
        {
          if ( skip_at )
          {
            len0 = skip_at - lp;
            strncpy(line, lp, skip_at - lp);
            line[len0] = 0;
            lp = &skip_at[skip_num];
            skip_at = 0;
            skip_num = 0;
          }
          else
          {
            len0 = 0;
          }
          line[len0] = 0;
          cp = strchr(lp, 10);
          if ( cp )
          {
            len_in = cp - lp;
            len = cp - lp;
          }
          else
          {
            len_in = strlen(lp);
            len = len_in;
          }
          if ( wanted_fieldlen_wrap < 0 && !wrapalert && len0 + len >= start_anchor->input_field->size )
          {
            cp = strchr(lp, 32);
            if ( cp )
            {
              if ( cp - lp < start_anchor->input_field->size - 1 )
              {
                LYFixCursesOn("ask for confirmation:");
                LYerase();
                v6 = gettext("Wrap lines to fit displayed area?");
                if ( HTConfirmDefault(v6, 0) )
                  wanted_fieldlen_wrap = start_anchor->input_field->size - 1;
                else
                  wanted_fieldlen_wrap = 0;
              }
            }
          }
          if ( wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap )
          {
            for ( i = wanted_fieldlen_wrap - len0; i + len0 >= wanted_fieldlen_wrap / 4; --i )
            {
              if ( ((*__ctype_b_loc())[(unsigned __int8)lp[i]] & 0x2000) != 0 )
              {
                len = i + 1;
                cp = &lp[i];
                if ( lp[i + 1] != 10
                  && ((*__ctype_b_loc())[(unsigned __int8)cp[1]] & 0x2000) != 0
                  && ((*__ctype_b_loc())[(unsigned __int8)cp[2]] & 0x2000) == 0 )
                {
                  ++len;
                  ++cp;
                }
                if ( ((*__ctype_b_loc())[(unsigned __int8)cp[1]] & 0x2000) == 0 )
                {
                  while ( *cp && *cp != 13 && *cp != 10 && cp - lp <= len + 3 * wanted_fieldlen_wrap / 4 )
                    ++cp;
                  if ( *cp == 13 && cp[1] == 10 )
                    ++cp;
                  if ( *cp == 10
                    && (cp[1] == 13 || cp[1] == 10 || ((*__ctype_b_loc())[(unsigned __int8)cp[1]] & 0x2000) == 0) )
                  {
                    *cp = 32;
                    while ( ((*__ctype_b_loc())[(unsigned __int8)*(cp - 1)] & 0x2000) != 0 )
                    {
                      ++skip_num;
                      --cp;
                    }
                    skip_at = cp;
                  }
                }
                break;
              }
            }
          }
          if ( wanted_fieldlen_wrap > 0 && len0 + len > wanted_fieldlen_wrap )
          {
            for ( i = len - 1;
                  i + len0 + 1 > wanted_fieldlen_wrap && ((*__ctype_b_loc())[(unsigned __int8)lp[i]] & 0x2000) != 0;
                  --i )
            {
              ;
            }
            if ( i + len0 + 1 > wanted_fieldlen_wrap )
              len = wanted_fieldlen_wrap - len0;
          }
          if ( len0 + len > 1023 )
          {
            if ( !wrapalert )
            {
              LYFixCursesOn("show alert:");
              v7 = gettext("Very long lines have been wrapped!");
              HTAlert(v7);
              wrapalert = 1;
            }
            for ( i = 1023 - len0; i > 0; --i )
            {
              if ( ((*__ctype_b_loc())[(unsigned __int8)lp[i]] & 0x2000) != 0 )
              {
                len = i;
                break;
              }
            }
            if ( len0 + len > 1023 )
              len = 1023 - len0;
          }
          strncat(line, lp, len);
          line[len0 + len] = 0;
          if ( line_cnt > orig_cnt )
          {
            insert_new_textarea_anchor(&end_anchor, &htline);
            anchor_ptr = end_anchor;
            ++newlines;
          }
          HTSACopy(&anchor_ptr->input_field->value, line);
          if ( len + len0 <= 0 )
          {
            if ( !exit_line )
              exit_line = anchor_ptr->line_num;
          }
          else
          {
            exit_line = 0;
          }
          lp += len;
          if ( *lp && ((*__ctype_b_loc())[(unsigned __int8)*lp] & 0x2000) != 0 )
            ++lp;
          end_anchor = anchor_ptr;
          anchor_ptr = anchor_ptr->next;
          if ( anchor_ptr )
            match_tag = anchor_ptr->number;
          ++line_cnt;
        }
        if ( WWW_TraceFlag[0] )
        {
          v8 = TraceFP();
          fprintf(v8, "GridText: edited text inserted into lynx struct's\n");
        }
        if ( newlines > 0 )
          update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
        if ( line )
        {
          free(line);
          line = 0;
        }
        if ( ebuf )
        {
          free(ebuf);
          ebuf = 0;
        }
        return exit_line - entry_line;
      }
      if ( LYtrimInputFields )
      {
        if ( ((*__ctype_b_loc())[(unsigned __int8)ebuf[size - 1]] & 0x2000) != 0 )
          goto LABEL_11;
      }
      else if ( ebuf[size - 1] == 13 || ebuf[size - 1] == 10 )
      {
        goto LABEL_11;
      }
      if ( ebuf[size - 1] )
        goto LABEL_22;
LABEL_11:
      ebuf[--size] = 0;
    }
  }
  ebuf = (char *)calloc(size + 1, 1u);
  if ( ebuf )
  {
    fp = (FILE *)fopen64(ed_temp, "r");
    size = fread(ebuf, 1u, size, fp);
    LYCloseInput(fp);
    ebuf[size] = 0;
    goto LABEL_12;
  }
  v5 = gettext("Not enough memory for file!");
  HTAlwaysAlert(0, v5);
  return 0;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08074412) --------------------------------------------------------
int __cdecl HText_ExtEditForm(LinkInfo *form_link)
{
  FILE *v1; // eax
  const char *name; // ebx
  FILE *v3; // eax
  const char *v4; // ebx
  FILE *v5; // eax
  const char *v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  _FormInfo *form; // [esp+30h] [ebp-38h]
  int offset; // [esp+34h] [ebp-34h]
  int orig_cnt; // [esp+38h] [ebp-30h]
  int entry_line; // [esp+3Ch] [ebp-2Ch]
  int start_line; // [esp+40h] [ebp-28h]
  TextAnchor *start_anchor; // [esp+44h] [ebp-24h]
  TextAnchor *anchor_ptr; // [esp+48h] [ebp-20h]
  FILE *fp; // [esp+4Ch] [ebp-1Ch]
  char *ed_temp; // [esp+50h] [ebp-18h]
  BOOLEAN firstanchor; // [esp+55h] [ebp-13h]
  char ed_offset[10]; // [esp+56h] [ebp-12h] BYREF
  unsigned int v22; // [esp+60h] [ebp-8h]

  v22 = __readgsdword(0x14u);
  start_anchor = 0;
  firstanchor = 1;
  start_line = 0;
  entry_line = form_link->anchor_line_num;
  orig_cnt = 0;
  form = form_link->l_form;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "GridText: entered HText_ExtEditForm()\n");
  }
  ed_temp = (char *)malloc(0x100u);
  fp = LYOpenTemp(ed_temp, &byte_814CBAC, "w");
  if ( fp )
  {
    for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
    {
      if ( IsFormsTextarea(form, anchor_ptr) )
      {
        if ( firstanchor )
        {
          firstanchor = 0;
          start_anchor = anchor_ptr;
          start_line = anchor_ptr->line_num;
        }
        ++orig_cnt;
        fputs(anchor_ptr->input_field->value, fp);
        fputc(10, fp);
      }
      else if ( !firstanchor )
      {
        break;
      }
    }
    LYCloseTempFP(fp);
    if ( WWW_TraceFlag[0] )
    {
      name = form->name;
      v3 = TraceFP();
      fprintf(v3, "GridText: TEXTAREA name=|%s| dumped to tempfile\n", name);
    }
    if ( WWW_TraceFlag[0] )
    {
      v4 = editor;
      v5 = TraceFP();
      fprintf(v5, "GridText: invoking editor (%s) on tempfile\n", v4);
    }
    ed_offset[0] = 0;
    if ( entry_line - start_line > 0 && (unsigned __int8)editor_can_position() )
      sprintf(ed_offset, "%d", entry_line - start_line + 1);
    edit_temporary_file(ed_temp, ed_offset, 0);
    if ( WWW_TraceFlag[0] )
    {
      v6 = editor;
      v7 = TraceFP();
      fprintf(v7, "GridText: returned from editor (%s)\n", v6);
    }
    if ( form->disabled )
      offset = 0;
    else
      offset = finish_ExtEditForm(form_link, start_anchor, ed_temp, orig_cnt);
    LYRemoveTemp(ed_temp);
    if ( ed_temp )
      free(ed_temp);
    if ( WWW_TraceFlag[0] )
    {
      v8 = TraceFP();
      fprintf(v8, "GridText: exiting HText_ExtEditForm()\n");
    }
    return offset;
  }
  else
  {
    if ( ed_temp )
      free(ed_temp);
    return 0;
  }
}

//----- (080746D4) --------------------------------------------------------
void __cdecl HText_ExpandTextarea(LinkInfo *form_link, int newlines)
{
  FILE *v2; // eax
  char *name; // ebx
  FILE *v4; // edx
  FILE *v5; // eax
  int i; // [esp+18h] [ebp-20h]
  int match_tag; // [esp+1Ch] [ebp-1Ch]
  HTLine *htline; // [esp+20h] [ebp-18h] BYREF
  FormInfo *form; // [esp+24h] [ebp-14h]
  TextAnchor *end_anchor; // [esp+28h] [ebp-10h] BYREF
  TextAnchor *anchor_ptr; // [esp+2Ch] [ebp-Ch]
  BOOLEAN firstanchor; // [esp+33h] [ebp-5h]

  end_anchor = 0;
  firstanchor = 1;
  form = form_link->l_form;
  htline = 0;
  match_tag = 0;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "GridText: entered HText_ExpandTextarea()\n");
  }
  if ( newlines > 0 )
  {
    for ( anchor_ptr = HTMainText->first_anchor; anchor_ptr; anchor_ptr = anchor_ptr->next )
    {
      if ( IsFormsTextarea(form, anchor_ptr) )
      {
        if ( firstanchor )
          firstanchor = 0;
        end_anchor = anchor_ptr;
      }
      else if ( !firstanchor )
      {
        break;
      }
    }
    for ( i = 1; i <= newlines; ++i )
    {
      insert_new_textarea_anchor(&end_anchor, &htline);
      HTSACopy(&end_anchor->input_field->value, &byte_814CBAC);
      if ( end_anchor->next )
        match_tag = end_anchor->next->number;
    }
    if ( WWW_TraceFlag[0] )
    {
      name = form->name;
      v4 = TraceFP();
      fprintf(v4, "GridText: %d blank line(s) added to TEXTAREA name=|%s|\n", newlines, name);
    }
    update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "GridText: exiting HText_ExpandTextarea()\n");
    }
  }
}

//----- (08074845) --------------------------------------------------------
int __cdecl HText_InsertFile(LinkInfo *form_link)
{
  FILE *v1; // eax
  char *v2; // eax
  FILE *v3; // eax
  char *v4; // eax
  char *v5; // eax
  FILE *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  int v14; // [esp+24h] [ebp-C4h]
  stat stat_info; // [esp+30h] [ebp-B8h] BYREF
  int i; // [esp+90h] [ebp-58h]
  int len; // [esp+94h] [ebp-54h]
  int newlines; // [esp+98h] [ebp-50h]
  int match_tag; // [esp+9Ch] [ebp-4Ch]
  int file_cs; // [esp+A0h] [ebp-48h] BYREF
  int entry_line; // [esp+A4h] [ebp-44h]
  char *cp; // [esp+A8h] [ebp-40h]
  char *lp; // [esp+ACh] [ebp-3Ch]
  char *line; // [esp+B0h] [ebp-38h]
  char *fbuf; // [esp+B4h] [ebp-34h]
  HTLine *l; // [esp+B8h] [ebp-30h]
  FormInfo *f; // [esp+BCh] [ebp-2Ch]
  TextAnchor *a; // [esp+C0h] [ebp-28h]
  HTLine *htline; // [esp+C4h] [ebp-24h] BYREF
  FormInfo *form; // [esp+C8h] [ebp-20h]
  TextAnchor *end_anchor; // [esp+CCh] [ebp-1Ch] BYREF
  TextAnchor *prev_anchor; // [esp+D0h] [ebp-18h]
  TextAnchor *anchor_ptr; // [esp+D4h] [ebp-14h]
  char *fn; // [esp+D8h] [ebp-10h]
  FILE *fp; // [esp+DCh] [ebp-Ch]
  size_t size; // [esp+E0h] [ebp-8h]
  BOOLEAN truncalert; // [esp+E6h] [ebp-2h]
  BOOLEAN firstanchor; // [esp+E7h] [ebp-1h]

  prev_anchor = 0;
  end_anchor = 0;
  firstanchor = 1;
  truncalert = 0;
  form = form_link->l_form;
  htline = 0;
  a = 0;
  f = 0;
  l = 0;
  entry_line = form_link->anchor_line_num;
  match_tag = 0;
  newlines = 0;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "GridText: entered HText_InsertFile()\n");
  }
  fn = GetFileName();
  if ( fn )
  {
    if ( (no_dotfiles || !show_dotfiles) && *LYPathLeaf(fn) == 46 )
    {
      v4 = gettext("File name may not begin with a dot.");
      HTUserMsg(v4);
      return 0;
    }
    else if ( stat64((int)fn, (int)&stat_info) >= 0 && (size = stat_info.st_size) != 0 )
    {
      fbuf = (char *)calloc(size + 1, 1u);
      if ( fbuf )
      {
        LYGetFileInfo(fn, 0, 0, 0, 0, 0, &file_cs);
        fp = (FILE *)fopen64(fn, "r");
        if ( fp )
        {
          size = fread(fbuf, 1u, size, fp);
          LYCloseInput(fp);
          if ( fn )
          {
            free(fn);
            fn = 0;
          }
          fbuf[size] = 0;
          for ( anchor_ptr = HTMainText->first_anchor;
                anchor_ptr && (!IsFormsTextarea(form, anchor_ptr) || anchor_ptr->line_num != entry_line);
                anchor_ptr = anchor_ptr->next )
          {
            prev_anchor = anchor_ptr;
          }
          htline = HTMainText->last_line->next;
          for ( i = 0; anchor_ptr->line_num != i; ++i )
          {
            htline = htline->next;
            if ( HTMainText->last_line == htline )
              break;
          }
          l = (HTLine *)ALLOC_IN_POOL(&HTMainText->pool, 0x414u);
          a = (TextAnchor *)ALLOC_IN_POOL(&HTMainText->pool, 0x34u);
          f = (FormInfo *)ALLOC_IN_POOL(&HTMainText->pool, 0x60u);
          if ( !a || !l || !f )
            outofmem("./GridText.c", "HText_InsertFile");
          a->next = anchor_ptr;
          a->number = anchor_ptr->number;
          a->line_pos = anchor_ptr->line_pos;
          a->extent = anchor_ptr->extent;
          a->sgml_offset = SGML_offset();
          a->line_num = anchor_ptr->line_num;
          LYCopyHiText(a, anchor_ptr);
          a->link_type = anchor_ptr->link_type;
          a->input_field = f;
          a->show_anchor = anchor_ptr->show_anchor;
          a->inUnderline = anchor_ptr->inUnderline;
          a->expansion_anch = 1;
          a->anchor = 0;
          HTSACopy(&f->name, anchor_ptr->input_field->name);
          f->number = anchor_ptr->input_field->number;
          f->type = anchor_ptr->input_field->type;
          HTSACopy(&f->orig_value, &byte_814CBAC);
          f->size = anchor_ptr->input_field->size;
          f->maxlength = anchor_ptr->input_field->maxlength;
          f->no_cache = anchor_ptr->input_field->no_cache;
          f->disabled = anchor_ptr->input_field->disabled;
          if ( file_cs < 0 )
            v14 = current_char_set;
          else
            v14 = file_cs;
          f->value_cs = v14;
          l->offset = htline->offset;
          l->size = htline->size;
          l->numstyles = htline->numstyles;
          l->styles = htline->styles;
          strcpy(l->data, htline->data);
          if ( HTMainText->first_anchor == anchor_ptr )
            HTMainText->first_anchor = a;
          if ( prev_anchor )
            prev_anchor->next = a;
          htline = htline->prev;
          l->next = htline->next;
          l->prev = htline;
          htline->next->prev = l;
          htline->next = l;
          htline = htline->next;
          htline = htline->next;
          anchor_ptr = a;
          ++newlines;
          line = (char *)malloc(0x400u);
          if ( !line )
            outofmem("./GridText.c", "HText_InsertFile");
          match_tag = anchor_ptr->number;
          len = 0;
          lp = fbuf;
          while ( *lp )
          {
            cp = strchr(lp, 10);
            if ( cp )
              len = cp - lp;
            else
              len = strlen(lp);
            if ( len > 1023 )
            {
              if ( !truncalert )
              {
                v9 = gettext("Very long lines have been truncated!");
                HTAlert(v9);
                truncalert = 1;
              }
              len = 1023;
              if ( lp[1023] )
                lp[len + 1] = 0;
            }
            strncpy(line, lp, len);
            line[len] = 0;
            if ( !firstanchor )
            {
              insert_new_textarea_anchor(&end_anchor, &htline);
              anchor_ptr = end_anchor;
              ++newlines;
            }
            HTSACopy(&anchor_ptr->input_field->value, line);
            if ( file_cs >= 0 )
              anchor_ptr->input_field->value_cs = file_cs;
            lp += len;
            if ( *lp )
              ++lp;
            firstanchor = 0;
            end_anchor = anchor_ptr;
            anchor_ptr = anchor_ptr->next;
          }
          if ( WWW_TraceFlag[0] )
          {
            v10 = TraceFP();
            fprintf(v10, "GridText: file inserted into lynx struct's\n");
          }
          update_subsequent_anchors(newlines, end_anchor, htline, match_tag);
          if ( line )
          {
            free(line);
            line = 0;
          }
          if ( fbuf )
          {
            free(fbuf);
            fbuf = 0;
          }
          if ( WWW_TraceFlag[0] )
          {
            v11 = TraceFP();
            fprintf(v11, "GridText: exiting HText_InsertFile()\n");
          }
          return newlines;
        }
        else
        {
          free(fbuf);
          free(fn);
          v8 = gettext("Can't open file for reading.");
          HTAlert(v8);
          return 0;
        }
      }
      else
      {
        free(fn);
        v7 = gettext("Not enough memory for file!");
        HTAlert(v7);
        return 0;
      }
    }
    else
    {
      v5 = gettext("Nothing to insert - file is 0-length.");
      HTInfoMsg(v5);
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "GridText: file insert aborted - file=|%s|- was 0-length\n", fn);
      }
      if ( fn )
      {
        free(fn);
        fn = 0;
      }
      return 0;
    }
  }
  else
  {
    v2 = gettext("File insert cancelled!!!");
    HTInfoMsg(v2);
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "GridText: file insert cancelled - no filename provided\n");
    }
    return 0;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0807503A) --------------------------------------------------------
int GetColumn()
{
  if ( LYwin )
    return LYwin->_curx;
  else
    return -1;
}

//----- (08075094) --------------------------------------------------------
BOOLEAN __cdecl DidWrap(int y0, int x0)
{
  int cury; // [esp+0h] [ebp-1Ch]
  int curx; // [esp+4h] [ebp-18h]
  int v5; // [esp+8h] [ebp-14h]
  BOOLEAN result; // [esp+1Bh] [ebp-1h]

  result = 0;
  if ( LYwin )
    cury = LYwin->_cury;
  else
    cury = -1;
  if ( LYwin )
    curx = LYwin->_curx;
  else
    curx = -1;
  if ( LYwideLines )
    v5 = 1014;
  else
    v5 = LYcols;
  if ( v5 <= curx || !curx && cury != y0 )
    return 1;
  return result;
}

//----- (08075121) --------------------------------------------------------
void __cdecl redraw_part_of_line(HTLine *line, const char *str, int len, HText *text)
{
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  int cury; // [esp+14h] [ebp-44h]
  int curx; // [esp+18h] [ebp-40h]
  int v9; // [esp+20h] [ebp-38h]
  int i; // [esp+24h] [ebp-34h]
  char buffer[7]; // [esp+2Dh] [ebp-2Bh] BYREF
  int XP; // [esp+34h] [ebp-24h]
  int YP; // [esp+38h] [ebp-20h]
  int scols; // [esp+3Ch] [ebp-1Ch]
  int tcols; // [esp+40h] [ebp-18h]
  int current_style; // [esp+44h] [ebp-14h]
  size_t utf_extra; // [esp+48h] [ebp-10h]
  const char *end_of_data; // [esp+4Ch] [ebp-Ch]
  const char *data; // [esp+50h] [ebp-8h]
  char LastDisplayChar; // [esp+57h] [ebp-1h]

  utf_extra = 0;
  current_style = 0;
  LastDisplayChar = 32;
  if ( LYwin )
    cury = LYwin->_cury;
  else
    cury = -1;
  YP = cury;
  if ( LYwin )
    curx = LYwin->_curx;
  else
    curx = -1;
  XP = curx;
  buffer[2] = 0;
  buffer[1] = 0;
  buffer[0] = 0;
  data = str;
  end_of_data = &str[len];
  i = curx + 1;
  while ( data < end_of_data )
  {
    buffer[0] = *data++;
    tcols = GetColumn();
    for ( scols = StyleToCols(text, line, current_style);
          line->numstyles > current_style && tcols >= scols;
          scols = StyleToCols(text, line, current_style) )
    {
      curses_style(*((unsigned __int16 *)&line->styles[current_style] + 1), *(_BYTE *)&line->styles[current_style] & 3);
      ++current_style;
    }
    if ( buffer[0] == 7 )
    {
      if ( !*data && ((*__ctype_b_loc())[(unsigned __int8)LastDisplayChar] & 0x2000) == 0 && LastDisplayChar != 45 )
      {
        buffer[0] = 45;
        goto LABEL_20;
      }
    }
    else if ( buffer[0] == 8 )
    {
      if ( !dump_output_immediately )
      {
        waddch(LYwin, 0x2Bu);
        ++i;
      }
    }
    else
    {
LABEL_20:
      if ( text->T.output_utf8 && buffer[0] < 0 )
      {
        utf_extra = utf8_length(text->T.output_utf8, data - 1);
        LastDisplayChar = 77;
      }
      if ( utf_extra )
      {
        strncpy(&buffer[1], data, utf_extra);
        buffer[utf_extra + 1] = 0;
        v4 = strlen(buffer);
        LYwaddnstr(LYwin, buffer, v4);
        buffer[1] = 0;
        data += utf_extra;
        utf_extra = 0;
      }
      else if ( HTCJK && buffer[0] < 0 )
      {
        if ( LYwideLines )
          v9 = 1014;
        else
          v9 = LYcols;
        if ( v9 >= i )
        {
          buffer[1] = *data;
          buffer[2] = 0;
          ++data;
          ++i;
          v5 = strlen(buffer);
          LYwaddnstr(LYwin, buffer, v5);
          buffer[1] = 0;
          LastDisplayChar = 77;
        }
      }
      else
      {
        v6 = strlen(buffer);
        LYwaddnstr(LYwin, buffer, v6);
        LastDisplayChar = buffer[0];
      }
      if ( !DidWrap(YP, XP) )
        ++i;
    }
  }
  while ( line->numstyles > current_style )
  {
    curses_style(*((unsigned __int16 *)&line->styles[current_style] + 1), *(_BYTE *)&line->styles[current_style] & 3);
    ++current_style;
  }
}

//----- (08075496) --------------------------------------------------------
void __cdecl redraw_lines_of_link(int cur)
{
  int v2; // edx
  HText *v3; // ebx
  int v4; // [esp+8h] [ebp-30h]
  const char *text; // [esp+1Ch] [ebp-1Ch]
  int count; // [esp+20h] [ebp-18h]
  int col; // [esp+24h] [ebp-14h]
  int row; // [esp+28h] [ebp-10h]
  int lines_back; // [esp+2Ch] [ebp-Ch]
  HTLine *todr1; // [esp+30h] [ebp-8h]

  if ( HTMainText->next_line == HTMainText->last_line )
    lines_back = HTMainText->Lines + 1 - links[cur].ly - HTMainText->top_of_screen;
  else
    lines_back = 1 - links[cur].ly + display_lines;
  for ( todr1 = HTMainText->next_line; lines_back-- > 0; todr1 = todr1->prev )
    ;
  row = links[cur].ly;
  if ( no_title )
    --row;
  for ( count = 0; row <= display_lines; ++count )
  {
    text = LYGetHiliteStr(cur, count);
    if ( !text )
      break;
    col = LYGetHilitePos(cur, count);
    v2 = row++;
    LYmove(v2, col);
    v3 = HTMainText;
    v4 = strlen(text);
    redraw_part_of_line(todr1, text, v4, v3);
    todr1 = todr1->next;
  }
}

//----- (08075606) --------------------------------------------------------
void HTMark_asSource()
{
  if ( HTMainText )
    HTMainText->source = 1;
}

//----- (08075620) --------------------------------------------------------
HTkcode __cdecl HText_getKcode(HText *text)
{
  return text->kcode;
}

//----- (0807562E) --------------------------------------------------------
void __cdecl HText_updateKcode(HText *text, HTkcode kcode)
{
  text->kcode = kcode;
}

//----- (0807563F) --------------------------------------------------------
HTkcode __cdecl HText_getSpecifiedKcode(HText *text)
{
  return text->specified_kcode;
}

//----- (0807564D) --------------------------------------------------------
void __cdecl HText_updateSpecifiedKcode(HText *text, HTkcode kcode)
{
  text->specified_kcode = kcode;
}

//----- (0807565E) --------------------------------------------------------
int HTMainText_Get_UCLYhndl()
{
  if ( HTMainText )
    return HTAnchor_getUCLYhndl(HTMainText->node_anchor, 0);
  else
    return -1;
}

//----- (08075698) --------------------------------------------------------
int __cdecl getfile(DocInfo *doc, int *target)
{
  FILE *v2; // eax
  char *address; // ebx
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // ebx
  char *v8; // eax
  char *v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  char *v14; // eax
  size_t v15; // eax
  size_t v16; // eax
  size_t v17; // eax
  size_t v18; // eax
  char *v19; // eax
  FILE *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // eax
  char *v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *v27; // eax
  const char *v28; // ebx
  char *v29; // eax
  char *v30; // eax
  char *v31; // eax
  const char *v32; // ebx
  char *v33; // eax
  int v34; // ebx
  char *v35; // ebx
  char *v36; // eax
  char *v37; // eax
  char *v38; // ebx
  char *v39; // eax
  char *v40; // eax
  char *v41; // eax
  char *v42; // eax
  char *v43; // eax
  char *v44; // eax
  char *v45; // eax
  char *v46; // ebx
  FILE *v47; // eax
  char *v48; // ebx
  char *v49; // ebx
  FILE *v50; // eax
  const char *v51; // eax
  const char *v52; // eax
  char *v53; // ebx
  char *v54; // eax
  FILE *v55; // eax
  char *v56; // eax
  char *v57; // eax
  const char *v58; // ebx
  char *v59; // eax
  char *v60; // eax
  FILE *v61; // eax
  const char *v62; // ebx
  char *v63; // eax
  FILE *v64; // eax
  const char *v65; // eax
  char *v66; // eax
  bstring *v67; // eax
  BOOLEAN isHEAD; // bl
  char *v69; // ebx
  char *v70; // eax
  FILE *v71; // eax
  const char *refid; // [esp+14h] [ebp-64h]
  char *name; // [esp+1Ch] [ebp-5Ch]
  const char *v76; // [esp+20h] [ebp-58h]
  DocAddress WWWDoc; // [esp+24h] [ebp-54h] BYREF
  char *fname; // [esp+38h] [ebp-40h] BYREF
  HTParentAnchor *tmpanchor_0; // [esp+3Ch] [ebp-3Ch]
  int status; // [esp+40h] [ebp-38h]
  char *proxy_0; // [esp+44h] [ebp-34h]
  char *proxy; // [esp+48h] [ebp-30h]
  const char *title; // [esp+4Ch] [ebp-2Ch]
  HTParentAnchor *tmpanchor; // [esp+50h] [ebp-28h]
  char *last_slash; // [esp+54h] [ebp-24h]
  const char *ref_url; // [esp+58h] [ebp-20h]
  int value; // [esp+5Ch] [ebp-1Ch] BYREF
  char *cp1; // [esp+60h] [ebp-18h]
  char *temp; // [esp+64h] [ebp-14h] BYREF
  char *cp; // [esp+68h] [ebp-10h]
  char *pound; // [esp+6Ch] [ebp-Ch]
  UrlTypes url_type; // [esp+70h] [ebp-8h]

  url_type = NOT_A_URL_TYPE_0;
  cp = 0;
  temp = 0;
  if ( LYCancelDownload[0] )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "getfile:    resetting LYCancelDownload to FALSE\n");
    }
    LYCancelDownload[0] = 0;
  }
  LYFakeZap(0);
  redirection_attempts = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      WWWDoc = *(DocAddress *)&doc->address;
      HTPermitRedir = 0;
      if ( WWW_Download_File )
      {
        free(WWW_Download_File);
        WWW_Download_File = 0;
      }
      redirect_post_content[0] = 0;
      HTNoDataOK = 0;
      if ( WWW_TraceFlag[0] )
      {
        address = doc->address;
        v4 = TraceFP();
        fprintf(v4, "getfile: getting %s\n\n", address);
      }
      temp = HTParse(doc->address, &byte_814EF17, 8);
      if ( temp && strlen(temp) > 3 )
      {
        cp1 = strchr(temp, 64);
        if ( !cp1 )
          cp1 = temp;
        cp = strrchr(cp1, 58);
        if ( cp )
        {
          if ( sscanf(++cp, "%ld", &value) == 1 )
          {
            if ( value == 19 || value == 65555 )
            {
              v5 = gettext("Port 19 not permitted in URLs.");
              HTAlert(v5);
              if ( temp )
              {
                free(temp);
                temp = 0;
              }
              return 3;
            }
            if ( value == 25 || value == 65561 )
            {
              v6 = gettext("Port 25 not permitted in URLs.");
              HTAlert(v6);
              if ( temp )
              {
                free(temp);
                temp = 0;
              }
              return 3;
            }
            if ( value > 0xFFFF || value < 0 )
            {
              fname = 0;
              v7 = value;
              v8 = gettext("Port %lu not permitted in URLs.");
              HTSprintf0(&fname, v8, v7);
              HTAlert(fname);
              if ( fname )
              {
                free(fname);
                fname = 0;
              }
              if ( temp )
              {
                free(temp);
                temp = 0;
              }
              return 3;
            }
          }
          else if ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x800) != 0 )
          {
            v9 = gettext("URL has a bad port field.");
            HTAlert(v9);
            if ( temp )
            {
              free(temp);
              temp = 0;
            }
            return 3;
          }
        }
      }
      cp = 0;
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      url_type = is_url(doc->address);
      if ( url_type == NOT_A_URL_TYPE_0 )
      {
        if ( WWW_TraceFlag[0] && !LYTraceLogFP )
          sleep(MessageSecs);
        v69 = doc->address;
        v70 = gettext("Badly formed address %s");
        HTUserMsg2(v70, v69);
        if ( WWW_TraceFlag[0] )
        {
          v71 = TraceFP();
          fprintf(v71, "\n");
        }
        return 3;
      }
      if ( LYValidate
        && !LYPermitURL
        && url_type != HTTP_URL_TYPE_0
        && url_type != HTTPS_URL_TYPE_0
        && url_type != LYNXHIST_URL_TYPE_0
        && url_type != LYNXKEYMAP_URL_TYPE_0
        && url_type != LYNXIMGMAP_URL_TYPE_0
        && url_type != LYNXCOOKIE_URL_TYPE_0
        && url_type != LYNXMESSAGES_URL_TYPE_0
        && (url_type != LYNXOPTIONS_URL_TYPE_0 || !WWWDoc.post_data) )
      {
        v10 = strlen(helpfilepath);
        if ( strncmp(WWWDoc.address, helpfilepath, v10) )
        {
          if ( !lynxlistfile || (v11 = strlen(lynxlistfile), strncmp(WWWDoc.address, lynxlistfile, v11)) )
          {
            if ( !lynxlinksfile || (v12 = strlen(lynxlinksfile), strncmp(WWWDoc.address, lynxlinksfile, v12)) )
            {
              if ( !lynxjumpfile || (v13 = strlen(lynxjumpfile), strncmp(WWWDoc.address, lynxjumpfile, v13)) )
              {
                v14 = gettext("Not an http URL or form ACTION!");
                HTUserMsg(v14);
                return 3;
              }
            }
          }
        }
      }
      if ( traversal )
      {
        if ( url_type != HTTP_URL_TYPE_0 && url_type != LYNXIMGMAP_URL_TYPE_0 )
          return 3;
      }
      else if ( check_realm )
      {
        if ( !LYPermitURL && !LYJumpFileURL )
        {
          v15 = strlen(startrealm);
          if ( strncmp(startrealm, WWWDoc.address, v15) )
          {
            if ( url_type != LYNXHIST_URL_TYPE_0
              && url_type != LYNXKEYMAP_URL_TYPE_0
              && url_type != LYNXIMGMAP_URL_TYPE_0
              && url_type != LYNXCOOKIE_URL_TYPE_0
              && url_type != LYNXPRINT_URL_TYPE_0
              && url_type != LYNXOPTIONS_URL_TYPE_0
              && url_type != LYNXCFG_URL_TYPE_0
              && url_type != LYNXCOMPILE_OPTS_URL_TYPE_0
              && url_type != LYNXMESSAGES_URL_TYPE_0
              && url_type != LYNXDOWNLOAD_URL_TYPE_0
              && url_type != MAILTO_URL_TYPE_0
              && url_type != NEWSPOST_URL_TYPE_0
              && url_type != NEWSREPLY_URL_TYPE_0
              && url_type != SNEWSPOST_URL_TYPE_0
              && url_type != SNEWSREPLY_URL_TYPE_0
              && (LYUserSpecifiedURL
               || url_type != LYNXEXEC_URL_TYPE_0 && url_type != LYNXPROG_URL_TYPE_0 && url_type != LYNXCGI_URL_TYPE_0)
              && (!WWWDoc.bookmark || !*WWWDoc.bookmark) )
            {
              v16 = strlen(helpfilepath);
              if ( strncmp(WWWDoc.address, helpfilepath, v16) )
              {
                if ( !lynxlistfile || (v17 = strlen(lynxlistfile), strncmp(WWWDoc.address, lynxlistfile, v17)) )
                {
                  if ( !lynxjumpfile || (v18 = strlen(lynxjumpfile), strncmp(WWWDoc.address, lynxjumpfile, v18)) )
                  {
                    v19 = gettext("URL is not in starting realm!");
                    HTUserMsg(v19);
                    return 3;
                  }
                }
              }
            }
          }
        }
      }
      if ( WWWDoc.post_data
        && url_type != HTTP_URL_TYPE_0
        && url_type != HTTPS_URL_TYPE_0
        && url_type != LYNXCGI_URL_TYPE_0
        && url_type != LYNXIMGMAP_URL_TYPE_0
        && url_type != GOPHER_URL_TYPE_0
        && url_type != CSO_URL_TYPE_0
        && url_type != PROXY_URL_TYPE_0
        && url_type != LYNXOPTIONS_URL_TYPE_0
        && (url_type != FILE_URL_TYPE_0
         || !LYIsUIPage3(WWWDoc.address, UIP_LIST_PAGE_0, 1) && !LYIsUIPage3(WWWDoc.address, UIP_ADDRLIST_PAGE_0, 1)) )
      {
        if ( WWW_TraceFlag[0] )
        {
          v20 = TraceFP();
          fprintf(v20, "getfile: dropping post_data!\n");
        }
        v21 = gettext("POST not supported for this URL - ignoring POST data!");
        HTAlert(v21);
        LYFreePostData(doc);
        WWWDoc.post_data = 0;
        WWWDoc.post_content_type = 0;
      }
      LYSyslog(doc->address);
      switch ( url_type )
      {
        case UNKNOWN_URL_TYPE_0:
        case AFS_URL_TYPE_0:
        case PROSPERO_URL_TYPE_0:
          v22 = gettext("Unsupported URL scheme!");
          HTAlert(v22);
          return 3;
        case DATA_URL_TYPE_0:
          v23 = gettext("Unsupported data: URL!  Use SHOWINFO, for now.");
          HTAlert(v23);
          return 3;
        case LYNXPRINT_URL_TYPE_0:
          return printfile(doc);
        case LYNXOPTIONS_URL_TYPE_0:
          return postoptions(doc);
      }
      if ( url_type == LYNXCFG_URL_TYPE_0 && !no_lynxcfg_info )
        return lynx_cfg_infopage(doc);
      if ( url_type == LYNXCOMPILE_OPTS_URL_TYPE_0 && !no_compileopts_info )
        return lynx_compile_opts(doc);
      switch ( url_type )
      {
        case NEWSPOST_URL_TYPE_0:
        case NEWSREPLY_URL_TYPE_0:
        case SNEWSPOST_URL_TYPE_0:
        case SNEWSREPLY_URL_TYPE_0:
          if ( no_newspost )
          {
            v24 = gettext("News posting is disabled!");
            HTUserMsg(v24);
            return 3;
          }
          if ( !news_ok && (url_type == NEWSPOST_URL_TYPE_0 || url_type == NEWSREPLY_URL_TYPE_0) )
          {
LABEL_134:
            v25 = gettext("USENET news access is disabled!");
            HTUserMsg(v25);
            return 3;
          }
          HTLoadAbsolute(&WWWDoc);
          return 3;
        case LYNXDOWNLOAD_URL_TYPE_0:
          LYDownload(doc->address);
          return 1;
        case LYNXDIRED_URL_TYPE_0:
          if ( no_dired_support[0] )
          {
            v26 = gettext("File management support is disabled!");
            HTUserMsg(v26);
            return 3;
          }
          else
          {
            local_dired(doc);
            WWWDoc = *(DocAddress *)&doc->address;
            return HTLoadAbsolute(&WWWDoc) != 0;
          }
      }
      if ( LYNoRefererHeader || LYNoRefererForThis )
      {
        v27 = HTLoadedDocumentURL();
        HTSACopy(&LYRequestReferer, v27);
      }
      else
      {
        ref_url = HTLoadedDocumentURL();
        if ( !strncasecomp(ref_url, "LYNXIMGMAP:", 11) )
          ref_url += 11;
        if ( no_filereferer == 1 && (*ref_url == 102 || *ref_url == 70) && !strncasecomp(ref_url, "file:", 5) )
          LYNoRefererForThis = 1;
        if ( !LYNoRefererForThis && (cp = strchr(ref_url, 63)) != 0 && strchr(cp, 61) )
        {
          if ( LYRefererWithQuery[0] == 83 )
          {
            HTSACopy(&LYRequestReferer, ref_url);
          }
          else if ( LYRefererWithQuery[0] == 80 )
          {
            if ( LYRequestReferer )
            {
              free(LYRequestReferer);
              LYRequestReferer = 0;
            }
            LYRequestReferer = HTParse(ref_url, &byte_814EF17, 57);
          }
          else
          {
            LYNoRefererForThis = 1;
          }
          cp = 0;
        }
        else if ( !LYNoRefererForThis )
        {
          HTSACopy(&LYRequestReferer, ref_url);
        }
      }
      switch ( url_type )
      {
        case LYNXHIST_URL_TYPE_0:
          if ( !historytarget(doc) || !doc || !doc->address )
            return 0;
          WWWDoc = *(DocAddress *)&doc->address;
          lynx_edit_mode = 0;
          return HTLoadAbsolute(&WWWDoc) != 0;
        case LYNXEXEC_URL_TYPE_0:
        case LYNXPROG_URL_TYPE_0:
          if ( !no_exec || (v28 = doc->address + 9, v29 = HTLoadedDocumentURL(), exec_ok(v29, v28, 1)) )
          {
            if ( no_bookmark_exec && HTLoadedDocumentBookmark() )
            {
              v31 = gettext("Execution via bookmarks is disabled.");
              HTUserMsg(v31);
            }
            else if ( local_exec
                   || local_exec_on_local_files
                   && (v32 = doc->address + 9, v33 = HTLoadedDocumentURL(), exec_ok(v33, v32, 0)) )
            {
              fname = 0;
              last_slash = strrchr(doc->address, 47);
              v34 = last_slash - doc->address;
              if ( v34 == strlen(doc->address) - 1 )
              {
                v35 = doc->address;
                v35[strlen(v35) - 1] = 0;
              }
              HTSACopy(&fname, doc->address);
              LYTildeExpand(&fname, 1);
              HTInfoMsg(doc->address);
              stop_curses();
              v36 = strstr(fname, "//");
              if ( v36 == fname + 9 )
                LYSystem(fname + 11);
              else
                LYSystem(fname + 9);
              if ( fname )
              {
                free(fname);
                fname = 0;
              }
              if ( url_type != LYNXPROG_URL_TYPE_0 )
              {
                signal(2, (__sighandler_t)1);
                v37 = gettext("Press <return> to return to Lynx.");
                printf("\n%s", v37);
                fflush(stdout);
                LYgetch();
              }
              if ( !dump_output_immediately )
              {
                start_curses();
                LYAddVisitedLink(doc);
              }
            }
            else
            {
              fname = 0;
              v38 = key_for_func(49);
              v39 = gettext("Execution is not enabled for this file.  See the Options menu (use %s).");
              HTSprintf0(&fname, v39, v38);
              HTAlert(fname);
              if ( fname )
              {
                free(fname);
                fname = 0;
              }
            }
          }
          else
          {
            v30 = gettext("Execution is disabled.");
            HTUserMsg(v30);
          }
          return 3;
        case MAILTO_URL_TYPE_0:
          if ( no_mail )
          {
            v40 = gettext("Mail access is disabled!");
            HTUserMsg(v40);
          }
          else
          {
            tmpanchor = HTAnchor_findAddress(&WWWDoc);
            fname = 0;
            title = &byte_814EF17;
            if ( HTAnchor_title(tmpanchor) )
            {
              title = HTAnchor_title(tmpanchor);
            }
            else if ( HTMainAnchor && !LYUserSpecifiedURL )
            {
              title = HTAnchor_subject(HTMainAnchor);
              if ( title && *title )
              {
                if ( strncasecomp(title, "Re:", 3) )
                {
                  HTSACopy(&fname, "Re: ");
                  HTSACat(&fname, title);
                  title = fname;
                }
              }
              else
              {
                title = &byte_814EF17;
              }
            }
            cp = strchr(doc->address, 58) + 1;
            if ( !HTMainAnchor || LYUserSpecifiedURL )
              refid = 0;
            else
              refid = HTMainAnchor->message_id;
            if ( !HTMainAnchor || LYUserSpecifiedURL )
              reply_by_mail(cp, doc->address, title, refid);
            else
              reply_by_mail(cp, HTMainAnchor->address, title, refid);
            if ( fname )
            {
              free(fname);
              fname = 0;
            }
          }
          return 3;
      }
      if ( local_host_only
        && url_type != LYNXKEYMAP_URL_TYPE_0
        && url_type != LYNXIMGMAP_URL_TYPE_0
        && url_type != LYNXCOOKIE_URL_TYPE_0
        && url_type != LYNXMESSAGES_URL_TYPE_0
        && url_type != LYNXCGI_URL_TYPE_0
        && (url_type != NEWS_URL_TYPE_0 || !strncmp(doc->address, "news://", 7u))
        && !LYisLocalHost(doc->address)
        && !LYisLocalAlias(doc->address) )
      {
        v41 = gettext("Only files and servers on the local host can be accessed.");
        HTUserMsg(v41);
        return 3;
      }
      if ( url_type == TELNET_URL_TYPE_0 || url_type == TN3270_URL_TYPE_0 || url_type == TELNET_GOPHER_URL_TYPE_0 )
      {
        if ( !telnet_ok )
        {
          v42 = gettext("Telnet access is disabled!");
          HTUserMsg(v42);
          return 3;
        }
        if ( no_telnet_port && strchr((const char *)doc->address + 7, 58) )
        {
          v43 = gettext("Telnet port specifications are disabled.");
          HTUserMsg(v43);
          return 3;
        }
        if ( url_type == TN3270_URL_TYPE_0 )
        {
          name = "tn3270_proxy";
        }
        else
        {
          if ( url_type == TELNET_GOPHER_URL_TYPE_0 )
            v76 = "gopher_proxy";
          else
            v76 = "telnet_proxy";
          name = (char *)v76;
        }
        proxy = LYGetEnv(name);
        if ( !proxy
          || override_proxy(doc->address)
          || !strncasecomp(proxy, "telnet:", 7)
          || !strncasecomp(proxy, "tn3270:", 7)
          || !strncasecomp(proxy, "rlogin:", 7) )
        {
          stop_curses();
          HTLoadAbsolute(&WWWDoc);
          if ( !dump_output_immediately )
          {
            start_curses();
            fflush(stdout);
            LYAddVisitedLink(doc);
          }
          return 3;
        }
        goto LABEL_282;
      }
      if ( !news_ok && (url_type == NEWS_URL_TYPE_0 || url_type == NNTP_URL_TYPE_0) )
        goto LABEL_134;
      if ( url_type == RLOGIN_URL_TYPE_0 )
        break;
      if ( url_type != INDEX_GOPHER_URL_TYPE_0 || strchr(doc->address, 63) )
        goto LABEL_282;
      cp = strstr(doc->address, "%09");
      if ( !cp )
      {
        if ( !HTLoadAbsolute(&WWWDoc) )
          return 0;
        status = do_www_search(doc);
        if ( status == 3 )
        {
          LYpop(doc);
          WWWDoc = *(DocAddress *)&doc->address;
          return HTLoadAbsolute(&WWWDoc);
        }
        else
        {
          lynx_edit_mode = 0;
        }
        return status;
      }
      *cp = 0;
      HTSACopy(&temp, doc->address);
      cp += 3;
      if ( *cp )
      {
        if ( strncmp(cp, "%09", 3u) )
        {
          HTSACat(&temp, "?");
          HTSACat(&temp, cp);
          cp = strstr(temp, "%09");
          if ( cp )
            *cp = 0;
        }
      }
      HTSACopy(&doc->address, temp);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
    }
    if ( !rlogin_ok )
    {
      v44 = gettext("Rlogin access is disabled!");
      HTUserMsg(v44);
      return 3;
    }
    proxy_0 = LYGetEnv("rlogin_proxy");
    if ( !proxy_0
      || override_proxy(doc->address)
      || !strncasecomp(proxy_0, "telnet:", 7)
      || !strncasecomp(proxy_0, "tn3270:", 7)
      || !strncasecomp(proxy_0, "rlogin:", 7) )
    {
      stop_curses();
      HTLoadAbsolute(&WWWDoc);
      fflush(stdout);
      if ( !dump_output_immediately )
      {
        start_curses();
        LYAddVisitedLink(doc);
      }
      return 3;
    }
LABEL_282:
    if ( !ftp_ok && (url_type == FTP_URL_TYPE_0 || url_type == NCFTP_URL_TYPE_0) )
    {
      v45 = gettext("Ftp access is disabled!");
      HTUserMsg(v45);
      return 3;
    }
    if ( url_type == HTML_GOPHER_URL_TYPE_0 )
    {
      fname = 0;
      cp = strchr((const char *)doc->address + 9, 47);
      if ( cp )
      {
        if ( !strncmp(++cp, "hGET%20/", 8u) )
        {
          HTSACopy(&fname, "http://");
          if ( WWW_TraceFlag[0] )
          {
            v46 = doc->address;
            v47 = TraceFP();
            fprintf(v47, "getfile: URL '%s'\n", v46);
          }
          *cp = 0;
          HTSACat(&fname, (const char *)doc->address + 9);
          if ( !strchr(fname + 6, 58) )
          {
            HTSACat(&fname, "70/");
            v48 = fname;
            v48[strlen(fname) - 4] = 58;
          }
          if ( strlen(cp + 7) > 1 )
            HTSACat(&fname, cp + 8);
          HTSACopy(&doc->address, fname);
          if ( WWW_TraceFlag[0] )
          {
            v49 = doc->address;
            v50 = TraceFP();
            fprintf(v50, "  changed to '%s'\n", v49);
          }
          if ( fname )
          {
            free(fname);
            fname = 0;
          }
          url_type = HTTP_URL_TYPE_0;
        }
      }
    }
    if ( url_type == HTTP_URL_TYPE_0
      || url_type == HTTPS_URL_TYPE_0
      || url_type == FTP_URL_TYPE_0
      || url_type == NCFTP_URL_TYPE_0
      || url_type == CSO_URL_TYPE_0 )
    {
      fix_httplike_urls(doc, url_type);
    }
    WWWDoc.address = doc->address;
    lynx_edit_mode = 0;
    if ( url_type == BIBP_URL_TYPE_0 )
    {
      fname = 0;
      if ( !BibP_bibhost_checked )
        LYCheckBibHost();
      if ( BibP_bibhost_available )
      {
        HTSACopy(&fname, BibP_bibhost);
      }
      else if ( HTMainAnchor && HTAnchor_citehost(HTMainAnchor) )
      {
        v51 = HTAnchor_citehost(HTMainAnchor);
        HTSACopy(&fname, v51);
      }
      else
      {
        HTSACopy(&fname, BibP_globalserver);
      }
      if ( HTMainAnchor && HTAnchor_citehost(HTMainAnchor) )
      {
        HTSACat(&fname, "bibp1.0/resolve?citehost=");
        v52 = HTAnchor_citehost(HTMainAnchor);
        HTSACat(&fname, v52);
        HTSACat(&fname, "&usin=");
      }
      else
      {
        HTSACat(&fname, "bibp1.0/resolve?usin=");
      }
      HTSACat(&fname, (const char *)doc->address + 5);
      HTSACopy(&doc->address, fname);
      WWWDoc.address = doc->address;
      if ( fname )
      {
        free(fname);
        fname = 0;
      }
    }
    if ( url_type == FILE_URL_TYPE_0 )
    {
      LYTildeExpand(&doc->address, 1);
      WWWDoc.address = doc->address;
    }
    if ( WWW_TraceFlag[0] && !LYTraceLogFP )
      sleep(MessageSecs);
    v53 = doc->address;
    v54 = gettext("Getting %s");
    user_message(v54, v53);
    if ( WWW_TraceFlag[0] )
    {
      v55 = TraceFP();
      fprintf(v55, "\n");
    }
    if ( HTLoadAbsolute(&WWWDoc) )
      break;
    if ( !use_this_url_instead )
    {
      if ( HTNoDataOK )
        return 3;
      else
        return 0;
    }
    if ( is_url(use_this_url_instead) == NOT_A_URL_TYPE_0 )
    {
      v56 = gettext("Location URL is not absolute.");
      HTUserMsg(v56);
      temp = HTParse(use_this_url_instead, WWWDoc.address, 31);
      if ( temp && *temp )
        HTSACopy(&use_this_url_instead, temp);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
    }
    url_type = is_url(use_this_url_instead);
    if ( !HTPermitRedir
      && (url_type == LYNXDOWNLOAD_URL_TYPE_0
       || url_type == LYNXEXEC_URL_TYPE_0
       || url_type == LYNXPROG_URL_TYPE_0
       || url_type == LYNXDIRED_URL_TYPE_0
       || url_type == LYNXPRINT_URL_TYPE_0
       || url_type == LYNXOPTIONS_URL_TYPE_0
       || url_type == LYNXCFG_URL_TYPE_0
       || url_type == LYNXCOMPILE_OPTS_URL_TYPE_0
       || url_type == LYNXHIST_URL_TYPE_0
       || url_type == LYNXCOOKIE_URL_TYPE_0
       || url_type == LYNXMESSAGES_URL_TYPE_0
       || LYValidate && url_type != HTTP_URL_TYPE_0 && url_type != HTTPS_URL_TYPE_0
       || (no_file_url || no_goto_file) && url_type == FILE_URL_TYPE_0
       || no_goto_lynxcgi && url_type == LYNXCGI_URL_TYPE_0
       || no_goto_bibp[0] && url_type == BIBP_URL_TYPE_0
       || no_goto_cso && url_type == CSO_URL_TYPE_0
       || no_goto_finger && url_type == FINGER_URL_TYPE_0
       || no_goto_ftp && (url_type == FTP_URL_TYPE_0 || url_type == NCFTP_URL_TYPE_0)
       || no_goto_gopher && url_type == GOPHER_URL_TYPE_0
       || no_goto_http && url_type == HTTP_URL_TYPE_0
       || no_goto_https && url_type == HTTPS_URL_TYPE_0
       || no_goto_mailto && url_type == MAILTO_URL_TYPE_0
       || no_goto_news && url_type == NEWS_URL_TYPE_0
       || no_goto_nntp && url_type == NNTP_URL_TYPE_0
       || no_goto_rlogin && url_type == RLOGIN_URL_TYPE_0
       || no_goto_snews && url_type == SNEWS_URL_TYPE_0
       || no_goto_telnet && url_type == TELNET_URL_TYPE_0
       || no_goto_tn3270 && url_type == TN3270_URL_TYPE_0
       || no_goto_wais && url_type == WAIS_URL_TYPE_0) )
    {
      v57 = gettext("Illegal redirection URL received from server!");
      HTAlert(v57);
      v58 = use_this_url_instead;
      if ( LYCursesON[0] )
      {
        v59 = gettext("Illegal URL: %s");
        HTUserMsg2(v59, v58);
      }
      else
      {
        v60 = gettext("Illegal URL: %s");
        fprintf(stderr, v60, v58);
      }
      if ( use_this_url_instead )
      {
        free(use_this_url_instead);
        use_this_url_instead = 0;
      }
      return 3;
    }
    pound = strchr(doc->address, 35);
    if ( pound && !strchr(use_this_url_instead, 35) )
    {
      if ( WWW_TraceFlag[0] )
      {
        v61 = TraceFP();
        fprintf(v61, "getfile: Adding fragment '%s' to redirection URL.\n", pound);
      }
      HTSACat(&use_this_url_instead, pound);
      doc->link = -1;
    }
    if ( WWW_TraceFlag[0] && !LYTraceLogFP )
      sleep(MessageSecs);
    v62 = use_this_url_instead;
    v63 = gettext("Using %s");
    HTUserMsg2(v63, v62);
    if ( WWW_TraceFlag[0] )
    {
      v64 = TraceFP();
      fprintf(v64, "\n");
    }
    HTSACopy(&doc->address, use_this_url_instead);
    if ( use_this_url_instead )
    {
      free(use_this_url_instead);
      use_this_url_instead = 0;
    }
    if ( !redirect_post_content[0] )
      LYFreePostData(doc);
  }
  lynx_mode = 1;
  pound = strchr(doc->address, 35);
  if ( WWW_Download_File )
  {
    tmpanchor_0 = HTAnchor_findAddress(&WWWDoc);
    fname = 0;
    if ( HTAnchor_SugFname(tmpanchor_0) )
    {
      v65 = HTAnchor_SugFname(tmpanchor_0);
      HTSACopy(&fname, v65);
    }
    else
    {
      HTSACopy(&fname, doc->address);
    }
    HTCheckFnameForCompression(&fname, tmpanchor_0, 0);
    if ( LYdownload_options(&fname, WWW_Download_File) >= 0 )
    {
      LYAddVisitedLink(doc);
      HTSACopy(&doc->address, fname);
      if ( fname )
      {
        free(fname);
        fname = 0;
      }
      doc->internal_link = 0;
      WWWDoc.address = doc->address;
      LYFreePostData(doc);
      WWWDoc.post_data = 0;
      WWWDoc.post_content_type = 0;
      doc->bookmark = 0;
      WWWDoc.bookmark = doc->bookmark;
      doc->isHEAD = 0;
      WWWDoc.isHEAD = doc->isHEAD;
      doc->safe = 0;
      WWWDoc.safe = doc->safe;
      HTOutputFormat = HTAtom_for("www/present");
      return HTLoadAbsolute(&WWWDoc) != 0;
    }
    else
    {
      if ( fname )
      {
        free(fname);
        fname = 0;
      }
      return 0;
    }
  }
  else
  {
    if ( !pound )
    {
      v66 = HTLoadedDocumentURL();
      if ( strcmp(doc->address, v66)
        || (v67 = HTLoadedDocumentPost_data(), !HTSABEql(doc->post_data, v67))
        || (isHEAD = doc->isHEAD, isHEAD != (unsigned __int8)HTLoadedDocumentIsHEAD()) )
      {
        LYAddVisitedLink(doc);
        return 3;
      }
    }
    if ( pound )
    {
      if ( !HTMainText )
        return 3;
      if ( HTFindPoundSelector(pound + 1) )
      {
        *target = www_search_result;
        doc->link = -1;
      }
    }
    return 1;
  }
}

//----- (0807770E) --------------------------------------------------------
void __cdecl srcmode_for_next_retrieval(int mode)
{
  if ( mode >= 0 )
  {
    if ( mode )
    {
      if ( LYpsrc )
        psrc_view = 1;
      else
        HTOutputFormat = WWW_SOURCE;
    }
    else if ( HTOutputFormat == WWW_SOURCE )
    {
      HTOutputFormat = HTAtom_for("www/present");
    }
    else if ( LYpsrc )
    {
      psrc_view = 0;
    }
  }
  else
  {
    HTOutputFormat = HTAtom_for("www/present");
    psrc_view = 0;
  }
}

//----- (08077790) --------------------------------------------------------
int __cdecl follow_link_number(int c, int cur, DocInfo *doc, int *num)
{
  FILE *v4; // edx
  char *v5; // eax
  char *v6; // eax
  int v7; // ebx
  FILE *v8; // eax
  int v9; // ebx
  FILE *v10; // eax
  FILE *v11; // eax
  int v14; // [esp+38h] [ebp-D0h]
  int v15; // [esp+3Ch] [ebp-CCh]
  int v16; // [esp+40h] [ebp-C8h]
  int v17; // [esp+44h] [ebp-C4h]
  bool v18; // [esp+48h] [ebp-C0h]
  char *text; // [esp+5Ch] [ebp-ACh] BYREF
  int info; // [esp+60h] [ebp-A8h]
  int curpage; // [esp+64h] [ebp-A4h]
  int npages; // [esp+68h] [ebp-A0h]
  int nlines; // [esp+6Ch] [ebp-9Ch]
  int curline; // [esp+70h] [ebp-98h]
  int new_link; // [esp+74h] [ebp-94h] BYREF
  int new_top; // [esp+78h] [ebp-90h] BYREF
  int rel; // [esp+7Ch] [ebp-8Ch]
  char *p; // [esp+80h] [ebp-88h]
  BOOLEAN want_go; // [esp+87h] [ebp-81h]
  char temp[120]; // [esp+88h] [ebp-80h] BYREF
  unsigned int v31; // [esp+100h] [ebp-8h]
  int ca; // [esp+110h] [ebp+8h]

  v31 = __readgsdword(0x14u);
  p = temp;
  rel = 0;
  curline = *num;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "follow_link_number(%d,%d,...)\n", c, cur);
  }
  temp[0] = c;
  temp[1] = 0;
  *num = -1;
  mustshow[0] = 1;
  v5 = gettext("Follow link (or goto link or page) number: ");
  statusline(v5);
  if ( LYgetstr(temp, 0, 0x78u, NORECALL) >= 0 && temp[0] )
  {
    *num = atoi(p);
    while ( ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x800) != 0 )
      ++p;
    ca = *p;
    if ( ca == 43 || *p == 45 )
    {
      rel = *p++;
      ca = *p;
    }
    else if ( *p )
    {
      rel = *++p;
    }
    if ( WWW_TraceFlag[0] )
    {
      v7 = *num;
      v8 = TraceFP();
      fprintf(v8, "  temp=%s, *num=%d, rel='%c'\n", temp, v7, rel);
    }
    if ( (ca == 112 || ca == 80) && !display_lines )
    {
      if ( WWW_TraceFlag[0] )
      {
        v9 = LYlines;
        v10 = TraceFP();
        fprintf(v10, " curline=%d, LYlines=%d, display too small!\n", curline, v9);
      }
      return 5;
    }
    else if ( ca == 112 || ca == 80 )
    {
      nlines = HText_getNumOfLines();
      if ( nlines + 1 <= display_lines )
        v14 = 1;
      else
        v14 = (display_lines + nlines) / display_lines;
      npages = v14;
      if ( curline + 1 <= display_lines )
        v15 = 1;
      else
        v15 = (display_lines + curline) / display_lines;
      curpage = v15;
      if ( WWW_TraceFlag[0] )
      {
        v11 = TraceFP();
        fprintf(v11, " nlines=%d, npages=%d, curline=%d, curpage=%d\n", nlines, npages, curline, curpage);
      }
      if ( *num <= 0 )
        *num = rel == 0;
      if ( rel == 43 )
      {
        *num += curpage;
      }
      else if ( rel == 45 )
      {
        *num = curpage - *num;
      }
      if ( npages <= 1 )
      {
        v16 = 1;
      }
      else
      {
        if ( *num > npages )
          v17 = (npages - 1) * display_lines + 1;
        else
          v17 = (*num - 1) * display_lines + 1;
        v16 = v17;
      }
      doc->line = v16;
      return 3;
    }
    else
    {
      v18 = ca == 103 || ca == 71;
      want_go = v18;
      if ( rel )
        *num = HTGetRelLinkNum(*num, rel, cur);
      if ( *num <= 0 )
      {
        return 5;
      }
      else
      {
        text = 0;
        info = HTGetLinkInfo(*num, want_go, &new_top, &new_link, &text, &links[cur].lname);
        if ( text )
          LYSetHilite(cur, text);
        if ( info == 6 )
        {
          links[cur].type = 6;
          return 1;
        }
        else if ( info == 8 )
        {
          doc->line = new_top + 1;
          doc->link = new_link;
          return 2;
        }
        else if ( info )
        {
          links[cur].type = 2;
          return 1;
        }
        else
        {
          return 5;
        }
      }
    }
  }
  else
  {
    v6 = gettext("Cancelled!!!");
    HTInfoMsg(v6);
    return 270;
  }
}

//----- (08077DA8) --------------------------------------------------------
void __cdecl add_trusted(char *str, int type)
{
  char *path; // [esp+10h] [ebp-8h]
  char *patha; // [esp+10h] [ebp-8h]
  trust *tp; // [esp+14h] [ebp-4h]

  if ( str )
  {
    if ( first_12231 )
      first_12231 = 0;
    path = strchr(str, 9);
    if ( path )
    {
      *path = 0;
      patha = path + 1;
    }
    else
    {
      patha = (char *)&byte_814EF17;
    }
    tp = (trust *)malloc(0x10u);
    if ( !tp )
      outofmem("./LYGetFile.c", "add_trusted");
    tp->src = 0;
    tp->path = 0;
    tp->type = type;
    HTSACopy(&tp->src, str);
    HTSACopy(&tp->path, patha);
    if ( type )
    {
      if ( type == 1 )
      {
        if ( always_trusted_exec == &always_trusted_exec_default )
          tp->next = 0;
        else
          tp->next = always_trusted_exec;
        always_trusted_exec = tp;
      }
      else if ( type == 2 )
      {
        if ( trusted_cgi == &trusted_cgi_default )
          tp->next = 0;
        else
          tp->next = trusted_cgi;
        trusted_cgi = tp;
      }
    }
    else
    {
      if ( trusted_exec == &trusted_exec_default )
        tp->next = 0;
      else
        tp->next = trusted_exec;
      trusted_exec = tp;
    }
  }
}

//----- (08077F0D) --------------------------------------------------------
BOOLEAN __cdecl exec_ok(const char *source, const char *linktext, int type)
{
  char *v3; // eax
  char *v4; // eax
  int v5; // ebx
  char *v6; // eax
  char *src; // ebx
  FILE *v8; // edx
  char *path; // ebx
  FILE *v10; // edx
  size_t v11; // edx
  size_t v12; // edx
  char *v13; // eax
  const char *command; // [esp+1Ch] [ebp-1Ch]
  char *buf; // [esp+20h] [ebp-18h] BYREF
  int Type; // [esp+24h] [ebp-14h]
  const char *allowed_extra_chars; // [esp+28h] [ebp-10h]
  const char *cp; // [esp+2Ch] [ebp-Ch]
  trust *tp; // [esp+30h] [ebp-8h]

  Type = type;
  if ( LYJumpFileURL )
    return 1;
  if ( Type )
  {
    if ( Type == 1 )
    {
      tp = always_trusted_exec;
    }
    else
    {
      if ( Type != 2 )
      {
        v3 = gettext("Executable link rejected due to malformed request.");
        HTAlert(v3);
        return 0;
      }
      tp = trusted_cgi;
    }
  }
  else
  {
    tp = trusted_exec;
  }
  if ( strstr(linktext, "../") )
  {
    v4 = gettext("Executable link rejected due to relative path string ('../').");
    HTAlert(v4);
    return 0;
  }
  else
  {
    if ( Type == 2 )
      allowed_extra_chars = " _-:./@~$&+=\t";
    else
      allowed_extra_chars = " _-:./@~$+=\t";
    for ( cp = linktext; *cp; ++cp )
    {
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)cp] & 8) == 0 && !strchr(allowed_extra_chars, *cp) )
      {
        buf = 0;
        v5 = *cp;
        v6 = gettext("Executable link rejected due to `%c' character.");
        HTSprintf0(&buf, v6, v5);
        HTAlert(buf);
        if ( buf )
        {
          free(buf);
          buf = 0;
        }
        return 0;
      }
    }
    while ( 1 )
    {
      while ( tp )
      {
        if ( tp->type == Type )
        {
          command = linktext;
          if ( strstr(linktext, "//") == linktext )
            command = linktext + 2;
          if ( WWW_TraceFlag[0] )
          {
            src = tp->src;
            v8 = TraceFP();
            fprintf(v8, "comparing source\n\t'%s'\n\t'%s'\n", source, src);
          }
          if ( WWW_TraceFlag[0] )
          {
            path = tp->path;
            v10 = TraceFP();
            fprintf(v10, "comparing command\n\t'%s'\n\t'%s'\n", command, path);
          }
          v11 = strlen(tp->src);
          if ( !strncmp(source, tp->src, v11) )
          {
            v12 = strlen(tp->path);
            if ( !strncmp(command, tp->path, v12) )
              return 1;
          }
        }
        tp = tp->next;
      }
      if ( Type || always_trusted_exec == &always_trusted_exec_default )
        break;
      Type = 1;
      tp = always_trusted_exec;
    }
    if ( !no_exec || type != 1 )
    {
      v13 = gettext("Executable link rejected due to location or path.");
      HTAlert(v13);
    }
    return 0;
  }
}

//----- (080781E2) --------------------------------------------------------
int __cdecl fix_httplike_urls(DocInfo *doc, UrlTypes type)
{
  char *v2; // ebx
  char *address; // ebx
  FILE *v4; // eax
  char *v5; // ebx
  FILE *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  char *v9; // ebx
  FILE *v10; // eax
  char *v11; // ebx
  char *v12; // ebx
  FILE *v13; // eax
  char *v14; // ebx
  FILE *v15; // eax
  char *second; // [esp+2Ch] [ebp-1Ch]
  const char *first; // [esp+30h] [ebp-18h]
  char *path_0; // [esp+34h] [ebp-14h] BYREF
  char *path; // [esp+38h] [ebp-10h]
  char *proxy; // [esp+3Ch] [ebp-Ch]
  char *slash; // [esp+40h] [ebp-8h]

  if ( strchr(doc->address, 35) )
    return 0;
  if ( type == FTP_URL_TYPE_0 && (v2 = doc->address, v2[strlen(v2) - 1] == 47) )
  {
    path = HTParse(doc->address, &byte_814EF17, 5);
    if ( path )
    {
      if ( *path == 47 && !path[1] )
      {
        if ( path )
        {
          free(path);
          path = 0;
        }
        return 0;
      }
      if ( path )
      {
        free(path);
        path = 0;
      }
    }
    proxy = LYGetEnv("ftp_proxy");
    if ( proxy && !override_proxy(doc->address) )
      return 0;
    if ( WWW_TraceFlag[0] )
    {
      address = doc->address;
      v4 = TraceFP();
      fprintf(v4, "fix_httplike_urls: URL '%s'\n", address);
    }
    LYTrimHtmlSep(doc->address);
    if ( WWW_TraceFlag[0] )
    {
      v5 = doc->address;
      v6 = TraceFP();
      fprintf(v6, "            changed to '%s'\n", v5);
    }
    if ( WWW_TraceFlag[0] && !LYTraceLogFP )
      sleep(MessageSecs);
  }
  else if ( type == NCFTP_URL_TYPE_0 )
  {
    path_0 = 0;
    first = doc->address;
    second = strchr(first, 58);
    if ( WWW_TraceFlag[0] )
    {
      v7 = doc->address;
      v8 = TraceFP();
      fprintf(v8, "fix_httplike_urls: URL '%s'\n", v7);
    }
    *second = 0;
    HTSprintf0(&path_0, "%s//%s%s", "ftp:", first, second + 1);
    if ( doc->address )
    {
      free(doc->address);
      doc->address = 0;
    }
    doc->address = path_0;
    if ( WWW_TraceFlag[0] )
    {
      v9 = doc->address;
      v10 = TraceFP();
      fprintf(v10, "            changed to '%s'\n", v9);
    }
    if ( WWW_TraceFlag[0] && !LYTraceLogFP )
      sleep(MessageSecs);
  }
  slash = strrchr(doc->address, 47);
  if ( slash )
  {
    if ( *(slash - 1) != 47 || *(slash - 2) != 58 )
      return 0;
    if ( type == HTTP_URL_TYPE_0 || type == HTTPS_URL_TYPE_0 )
    {
      v11 = slash - 2;
      if ( v11 != strchr(doc->address, 58) )
        return 0;
      if ( strchr(doc->address, 63) )
        return 0;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v12 = doc->address;
    v13 = TraceFP();
    fprintf(v13, "fix_httplike_urls: URL '%s'\n", v12);
  }
  LYAddHtmlSep(&doc->address);
  if ( WWW_TraceFlag[0] )
  {
    v14 = doc->address;
    v15 = TraceFP();
    fprintf(v15, "            changed to '%s'\n", v14);
  }
  if ( WWW_TraceFlag[0] && !LYTraceLogFP )
    sleep(MessageSecs);
  return 1;
}

//----- (080785C4) --------------------------------------------------------
void LYStdinArgs_free()
{
  LYFreeStringList(LYStdinArgs);
  LYStdinArgs = 0;
}

//----- (080785E3) --------------------------------------------------------
void reset_signals()
{
  signal(1, 0);
  signal(15, 0);
  signal(2, 0);
  if ( no_suspend )
    signal(20, 0);
}

//----- (08078646) --------------------------------------------------------
void __cdecl __noreturn exit_immediately(int code)
{
  reset_signals();
  LYexit(code);
}

//----- (0807865E) --------------------------------------------------------
BOOLEAN __cdecl GetStdin(char **buf, BOOLEAN marker)
{
  char *v2; // ebx
  FILE *v3; // eax
  FILE *v4; // eax
  char *v7; // [esp+1Ch] [ebp-Ch]

  if ( !LYSafeGets(buf, stdin) || marker && !strncmp(*buf, "---", 3u) )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( *buf )
        v7 = *buf;
      else
        v7 = (char *)&locale;
      v4 = TraceFP();
      fprintf(v4, "...mark: %s\n", v7);
    }
    return 0;
  }
  else
  {
    LYTrimTrailing(*buf);
    if ( WWW_TraceFlag[0] )
    {
      v2 = *buf;
      v3 = TraceFP();
      fprintf(v3, "...data: %s\n", v2);
    }
    return 1;
  }
}

//----- (08078739) --------------------------------------------------------
void SetLocale()
{
  const char *cp; // [esp+14h] [ebp-4h]

  setlocale(6, &locale);
  cp = LYGetEnv("LYNX_LOCALEDIR");
  if ( !cp )
    cp = "/usr/share/locale";
  bindtextdomain("lynx", cp);
  textdomain("lynx");
}

//----- (08078790) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char *v3; // eax
  char *v4; // eax
  FILE *v5; // eax
  char *v6; // ebx
  FILE *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  FILE *v10; // eax
  char *v11; // eax
  char *v12; // ebx
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  const char *v17; // ebx
  FILE *v18; // eax
  FILE *v19; // eax
  char *v20; // ebx
  char *v21; // eax
  int v22; // eax
  int v23; // eax
  char *v24; // eax
  char *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  char *v28; // ebx
  char *v29; // eax
  FILE *v30; // eax
  FILE *v31; // eax
  const char *v32; // eax
  const char *v33; // esi
  int v34; // edi
  int v35; // ebx
  FILE *v36; // eax
  char *object; // [esp+4h] [ebp-2DCh]
  _BOOL4 fd; // [esp+8h] [ebp-2D8h]
  bool v39; // [esp+Ch] [ebp-2D4h]
  bool v40; // [esp+10h] [ebp-2D0h]
  bool v41; // [esp+14h] [ebp-2CCh]
  bool v42; // [esp+18h] [ebp-2C8h]
  bool v43; // [esp+1Ch] [ebp-2C4h]
  bool v44; // [esp+20h] [ebp-2C0h]
  bool v45; // [esp+24h] [ebp-2BCh]
  bool v46; // [esp+28h] [ebp-2B8h]
  char **v47; // [esp+2Ch] [ebp-2B4h]
  stat data; // [esp+34h] [ebp-2ACh] BYREF
  char *v49; // [esp+94h] [ebp-24Ch] BYREF
  int v50; // [esp+98h] [ebp-248h]
  char *s; // [esp+9Ch] [ebp-244h] BYREF
  int v52; // [esp+A0h] [ebp-240h]
  int i; // [esp+A4h] [ebp-23Ch]
  HTList *v54; // [esp+A8h] [ebp-238h]
  char *buffer; // [esp+ACh] [ebp-234h] BYREF
  char *src; // [esp+B0h] [ebp-230h]
  FILE *stream; // [esp+B4h] [ebp-22Ch]
  char *fname; // [esp+B8h] [ebp-228h]
  char *dest; // [esp+BCh] [ebp-224h] BYREF
  int code; // [esp+C0h] [ebp-220h]
  int countp; // [esp+C4h] [ebp-21Ch] BYREF
  char v62; // [esp+CBh] [ebp-215h]
  char result[256]; // [esp+CCh] [ebp-214h] BYREF
  char pathname[256]; // [esp+1CCh] [ebp-114h] BYREF
  unsigned int v65; // [esp+2CCh] [ebp-14h]
  int *p_argc; // [esp+2D0h] [ebp-10h]

  p_argc = &argc;
  v47 = (char **)argv;
  v65 = __readgsdword(0x14u);
  code = 0;
  dest = 0;
  v62 = 0;
  ftp_lasthost = (char *)calloc(1u, 1u);
  LYShowColor = 2;
  pgm = *v47;
  fname = LYLastPathSep(pgm);
  if ( fname )
    pgm = fname + 1;
  if ( LYGetEnv("LYNX_TRACE") )
    WWW_TraceFlag[0] = 1;
  fname = LYGetEnv("LYNX_TRACE_FILE");
  if ( !fname )
    fname = "Lynx.trace";
  LYTraceLogPath = (char *)malloc(0x100u);
  LYAddPathToHome(LYTraceLogPath, 0x100u, fname);
  for ( countp = 1; countp < argc; ++countp )
    parse_arg(&v47[countp], 1u, &countp);
  LYOpenTraceLog();
  SetLocale();
  memset(links, 0, sizeof(links));
  LYAllocHistory(8);
  memset(MBM_A_subbookmark, 0, 0x1Au);
  memset(MBM_A_subdescript, 0, 0x1Au);
  HTSACopy(&list_format, "    %p %4l %-8.8o %-8.8g %7s %-12.12d %a");
  AlertSecs = 3000;
  DebugSecs = 0;
  InfoSecs = 1000;
  MessageSecs = 2000;
  ReplaySecs = 0;
  HTSACopy(&LYTransferName, "KiB");
  HTSACopy(&helpfile, "http://lynx.isc.org/release/lynx2-8-6/lynx_help/lynx_help_main.html");
  HTSACopy(&startfile, "http://lynx.isc.org/");
  LYEscapeStartfile(&startfile);
  HTSACopy(&indexfile, "http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/MetaIndex.html");
  HTSACopy(&global_type_map, "/etc/mailcap");
  HTSACopy(&personal_type_map, "~/.mailcap");
  HTSACopy(&global_extension_map, "/etc/mime.types");
  HTSACopy(&personal_extension_map, "~/.mime.types");
  HTSACopy(&language, "en");
  HTSACopy(&pref_charset, &locale);
  HTSACopy(&system_mail, "/usr/sbin/sendmail");
  HTSACopy(&system_mail_flags, "-t -oi");
  HTSACopy(&LYUserAgent, "Lynx");
  HTSACat(&LYUserAgent, "/");
  HTSACat(&LYUserAgent, "2.8.7dev.11");
  if ( HTLibraryVersion )
  {
    HTSACat(&LYUserAgent, " libwww-FM/");
    HTSACat(&LYUserAgent, HTLibraryVersion);
  }
  HTSACopy(&LYUserAgentDefault, LYUserAgent);
  HTSACopy(&lynx_version_putenv_command, "LYNX_VERSION=");
  HTSACat(&lynx_version_putenv_command, "2.8.7dev.11");
  putenv(lynx_version_putenv_command);
  fname = LYGetEnv("LYNX_TEMP_SPACE");
  if ( fname || (fname = LYGetEnv("TMPDIR")) != 0 )
    HTSACopy(&lynx_temp_space, fname);
  else
    HTSACopy(&lynx_temp_space, "/tmp/");
  LYTildeExpand(&lynx_temp_space, 1);
  fname = strstr(lynx_temp_space, "$USER");
  if ( fname )
  {
    src = LYGetEnv("USER");
    if ( src )
    {
      *fname = 0;
      HTSACopy(&dest, lynx_temp_space);
      *fname = 36;
      HTSACat(&dest, src);
      fname += 5;
      HTSACat(&dest, fname);
      HTSACopy(&lynx_temp_space, dest);
      if ( dest )
      {
        free(dest);
        dest = 0;
      }
    }
  }
  LYAddPathSep(&lynx_temp_space);
  HTSACopy(&lynx_temp_space, lynx_temp_space);
  if ( HTStat(lynx_temp_space, &data) < 0 && mkdir(lynx_temp_space, 0x1C0u) < 0 || (data.st_mode & 0xF000) != 0x4000 )
  {
    v3 = gettext("No such directory");
    fprintf(stderr, "%s: %s\n", lynx_temp_space, v3);
    exit_immediately(1);
  }
  v4 = HTHostName();
  HTSACopy(&LYHostName, v4);
  HTSACopy(&LYLocalDomain, "ukans.edu");
  HTSACopy(&URLDomainPrefixes, "www.");
  HTSACopy(&URLDomainSuffixes, ".com,.edu,.net,.org");
  HTSACopy(&XLoadImageCommand, "xli %s &");
  HTSACopy(&SSL_cert_file, 0);
  HTSACopy(&BibP_globalserver, "http://usin.org/");
  HTSACopy(&BibP_bibhost, "http://bibhost/");
  no_newspost = LYNewsPosting == 0;
  for ( countp = 1; countp < argc; ++countp )
    parse_arg(&v47[countp], 2u, &countp);
  for ( countp = 1; ; ++countp )
  {
    if ( countp >= argc )
      goto LABEL_32;
    if ( !strcmp(v47[countp], "-") )
      break;
  }
  v62 = 1;
LABEL_32:
  if ( v62 == 1 )
  {
    buffer = 0;
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "processing stdin arguments\n");
    }
    while ( GetStdin(&buffer, 1) )
    {
      v49 = buffer;
      v50 = 0;
      LYTrimTrailing(buffer);
      if ( parse_arg(&v49, 2u, 0) || !*buffer )
      {
        if ( WWW_TraceFlag[0] )
        {
          v8 = buffer;
          v9 = TraceFP();
          fprintf(v9, "...complete:%s\n", v8);
        }
      }
      else
      {
        s = 0;
        if ( !LYStdinArgs )
          LYStdinArgs = HTList_new();
        HTSACopy(&s, buffer);
        HTList_appendObject(LYStdinArgs, s);
        if ( WWW_TraceFlag[0] )
        {
          v6 = s;
          v7 = TraceFP();
          fprintf(v7, "...StdinArg:%s\n", v6);
        }
      }
    }
    if ( WWW_TraceFlag[0] )
    {
      v10 = TraceFP();
      fprintf(v10, "...done with stdin arguments\n");
    }
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
  }
  if ( LYValidate == 1 )
  {
    parse_restrictions("all");
    LYUseTraceLog = 0;
  }
  if ( lynx_cmd_script )
  {
    LYTildeExpand(&lynx_cmd_script, 1);
    LYOpenCmdScript();
  }
  if ( lynx_cmd_logfile )
  {
    LYTildeExpand(&lynx_cmd_logfile, 1);
    LYOpenCmdLogfile(argc, v47);
  }
  v11 = gettext("Jump to (use '?' for list): ");
  HTSACopy(&jumpprompt, v11);
  if ( !lynx_cfg_file )
  {
    fname = LYGetEnv("LYNX_CFG");
    if ( fname || (fname = LYGetEnv("lynx_cfg")) != 0 )
      HTSACopy(&lynx_cfg_file, fname);
  }
  if ( !lynx_cfg_file )
    HTSACopy(&lynx_cfg_file, "/etc/lynx-cur/lynx.cfg");
  LYTildeExpand(&lynx_cfg_file, 0);
  if ( !LYCanReadFile(lynx_cfg_file) )
  {
    v12 = lynx_cfg_file;
    v13 = gettext("\nConfiguration file \"%s\" is not available.\n\n");
    fprintf(stderr, v13, v12);
    exit_immediately(1);
  }
  if ( !LYCharSetsDeclared() )
  {
    v14 = gettext("\nLynx character sets not declared.\n\n");
    fprintf(stderr, v14);
    exit_immediately(1);
  }
  current_char_set = safeUCGetLYhndl_byMIME("iso-8859-1");
  UCLYhndl_for_unspec = LATIN1;
  HTSACopy(&UCAssume_MIMEcharset, LYCharSet_UC[LATIN1].MIMEname);
  if ( !LYEditmapDeclared() )
  {
    v15 = gettext("\nLynx edit map not declared.\n\n");
    fprintf(stderr, v15);
    exit_immediately(1);
  }
  lynx_setup_colors();
  v16 = Current_Dir(pathname);
  if ( !strcmp(v16, ".") )
  {
    fname = LYGetEnv("PWD");
    if ( fname )
      HTSACopy(&original_dir, fname);
  }
  else
  {
    HTSACopy(&original_dir, pathname);
  }
  LYstrncpy(pathname, ".lynxsig", 255);
  if ( LYPathOffHomeOK(pathname, 0x100u) )
  {
    HTSACopy(&LynxSigFile, pathname);
    LYAddPathToHome(pathname, 0x100u, LynxSigFile);
    HTSACopy(&LynxSigFile, pathname);
    if ( WWW_TraceFlag[0] )
    {
      v17 = LynxSigFile;
      v18 = TraceFP();
      fprintf(v18, "LYNX_SIG_FILE set to '%s'\n", v17);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v19 = TraceFP();
    fprintf(v19, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", ".lynxsig");
  }
  HTSwitchDTD(1);
  read_cfg(lynx_cfg_file, "main program", 1, 0);
  if ( lynx_lss_file2 )
  {
    if ( lynx_lss_file )
    {
      free(lynx_lss_file);
      lynx_lss_file = 0;
    }
    lynx_lss_file = lynx_lss_file2;
    lynx_lss_file2 = 0;
  }
  if ( !lynx_lss_file )
  {
    fname = LYGetEnv("LYNX_LSS");
    if ( fname || (fname = LYGetEnv("lynx_lss")) != 0 )
      HTSACopy(&lynx_lss_file, fname);
  }
  if ( !lynx_lss_file )
    HTSACopy(&lynx_lss_file, "/etc/lynx-cur/lynx.lss");
  LYTildeExpand(&lynx_lss_file, 1);
  if ( lynx_lss_file && *lynx_lss_file && !LYCanReadFile(lynx_lss_file) )
  {
    v20 = lynx_lss_file;
    v21 = gettext("\nLynx file \"%s\" is not available.\n\n");
    fprintf(stderr, v21, v20);
    exit_immediately(1);
  }
  style_readFromFile(lynx_lss_file);
  read_rc(0);
  LYFindLocaleCharset();
  fname = LYGetEnv("WWW_HOME");
  if ( fname )
  {
    HTSACopy(&startfile, fname);
    LYEscapeStartfile(&startfile);
  }
  HTSACopy(&LynxHome, startfile);
  LYEnsureAbsoluteURL(&LynxHome, "LynxHome", 0);
  for ( countp = 1; countp < argc; ++countp )
    parse_arg(&v47[countp], 4u, &countp);
  if ( LYStdinArgs )
  {
    v54 = LYStdinArgs;
    v50 = 0;
    while ( 1 )
    {
      if ( v54 && (v54 = v54->next) != 0 )
        object = (char *)v54->object;
      else
        object = 0;
      v49 = object;
      if ( !object )
        break;
      parse_arg(&v49, 4u, 0);
    }
    LYStdinArgs_free();
  }
  if ( !v62 && !startfile_stdin )
  {
    v22 = fileno(stdin);
    if ( !isatty(v22) )
    {
      fd = 1;
      if ( !fileno(stdout) )
      {
        v23 = fileno(stderr);
        if ( !isatty(v23) )
          fd = 0;
      }
      if ( isatty(fd) )
      {
        for ( i = 0; ; ++i )
        {
          v52 = fgetc(stdin);
          if ( v52 == -1 )
            break;
        }
        if ( i )
        {
          v24 = gettext("Ignored %d characters from standard input.\n");
          fprintf(stderr, v24, i);
          v25 = gettext("Use \"-stdin\" or \"-\" to tell how to handle piped input.\n");
          fprintf(stderr, v25);
        }
      }
    }
  }
  if ( startfile_stdin )
  {
    s = 0;
    if ( WWW_TraceFlag[0] )
    {
      v26 = TraceFP();
      fprintf(v26, "processing stdin startfile\n");
    }
    stream = LYOpenTemp(result, ".html", "w");
    if ( stream )
    {
      HTSACopy(&startfile, result);
      while ( GetStdin(&s, 0) )
      {
        fputs(s, stream);
        fputc(10, stream);
      }
      if ( s )
      {
        free(s);
        s = 0;
      }
      LYCloseTempFP(stream);
    }
    if ( WWW_TraceFlag[0] )
    {
      v27 = TraceFP();
      fprintf(v27, "...done stdin startfile\n");
    }
  }
  if ( Old_DTD )
    HTSwitchDTD(Old_DTD == 0);
  HTMLUseCharacterSet(current_char_set);
  if ( persistent_cookies[0] )
  {
    if ( LYCookieFile )
    {
      LYTildeExpand(&LYCookieFile, 0);
    }
    else
    {
      LYCookieFile = (char *)malloc(0x100u);
      LYAddPathToHome(LYCookieFile, 0x100u, ".lynx_cookies");
    }
    LYLoadCookies(LYCookieFile);
  }
  if ( LYCookieSaveFile )
    LYTildeExpand(&LYCookieSaveFile, 0);
  if ( !LYCookieSaveFile )
  {
    if ( dump_output_immediately )
      HTSACopy(&LYCookieSaveFile, "/dev/null");
    else
      HTSACopy(&LYCookieSaveFile, LYCookieFile);
  }
  fname = LYGetEnv("LYNX_HELPFILE");
  if ( fname )
    HTSACopy(&helpfile, fname);
  HTSACopy(&helpfilepath, helpfile);
  fname = LYPathLeaf(helpfilepath);
  if ( fname != helpfilepath )
    *fname = 0;
  LYAddHtmlSep(&helpfilepath);
  fname = LYGetEnv("LYNX_SAVE_SPACE");
  if ( fname )
    HTSACopy(&lynx_save_space, fname);
  if ( lynx_save_space && !*lynx_save_space && lynx_save_space )
  {
    free(lynx_save_space);
    lynx_save_space = 0;
  }
  if ( lynx_save_space )
  {
    LYTildeExpand(&lynx_save_space, 1);
    LYAddPathSep(&lynx_save_space);
  }
  HTFormatInit();
  if ( !FileInitAlreadyDone )
    HTFileInit();
  if ( !LYCheckUserAgent() )
  {
    v28 = gettext("User-Agent string does not contain \"Lynx\" or \"L_y_n_x\"");
    v29 = gettext("Warning:");
    HTAlwaysAlert(v29, v28);
  }
  if ( LYPreparsedSource )
    HTPreparsedFormatInit();
  if ( emacs_keys )
    set_emacs_keys();
  if ( vi_keys )
    set_vi_keys();
  if ( no_numbers )
  {
    number_links = 0;
    number_fields = 0;
    keypad_mode = 0;
    set_numbers_as_arrows();
  }
  if ( crawl && !number_links )
    keypad_mode = 0;
  if ( keypad_mode != 1 && keypad_mode != 2 )
  {
    if ( number_fields )
      keypad_mode = 2;
    if ( number_links )
      keypad_mode = 1;
    set_numbers_as_arrows();
  }
  if ( !LYUseDefSelPop )
    LYSelectPopups = LYSelectPopups == 0;
  if ( !LYUseDefShoCur )
    LYShowCursor = LYShowCursor == 0;
  if ( LYPrependBase && HTAtom_for("www/download") == HTOutputFormat )
    LYPrependBaseToSource = 1;
  if ( no_multibook )
    LYMBMBlocked = 1;
  if ( dump_output_immediately || LYMBMBlocked || no_multibook )
  {
    LYMultiBookmarks = 0;
    LYMBMBlocked = 1;
    no_multibook = 1;
  }
  if ( dump_output_immediately )
    LYCacheSource = 0;
  if ( dump_output_immediately )
    display_partial_flag = 0;
  if ( !dump_output_immediately )
    signal(1, cleanup_sig);
  signal(15, cleanup_sig);
  LYExtSignal(28, size_change);
  if ( !WWW_TraceFlag[0] && !dump_output_immediately && !stack_dump[0] )
  {
    signal(2, cleanup_sig);
    signal(11, FatalProblem);
    signal(4, FatalProblem);
    if ( signal(13, (__sighandler_t)1) != (__sighandler_t)1 )
      restore_sigpipe_for_children[0] = 1;
  }
  if ( no_suspend )
    signal(20, (__sighandler_t)1);
  if ( HEAD_request && LYCanDoHEAD(startfile) != 1 )
  {
    fprintf(stderr, "The '-head' switch is for http HEAD requests and cannot be used for\n'%s'.\n", startfile);
    exit_immediately(1);
  }
  if ( keep_mime_headers && LYCanDoHEAD(startfile) != 1 )
  {
    fprintf(stderr, "The '-mime_header' switch is for http URLs and cannot be used for\n'%s'.\n", startfile);
    exit_immediately(1);
  }
  if ( traversal && strncmp(startfile, "http", 4u) )
  {
    fprintf(stderr, "The '-traversal' switch is for http URLs and cannot be used for\n'%s'.\n", startfile);
    exit_immediately(1);
  }
  if ( !dump_output_immediately )
    HTMLSRC_init_caches(0);
  if ( !dump_output_immediately )
    setup(terminal);
  LYEnsureAbsoluteURL(&startfile, "STARTFILE", 0);
  if ( homepage )
    LYEnsureAbsoluteURL(&homepage, "HOMEPAGE", 0);
  if ( homepage && *homepage )
    HTSACopy(&LynxHome, homepage);
  else
    HTSACopy(&homepage, startfile);
  if ( (unsigned __int8)inlocaldomain() )
  {
    if ( WWW_TraceFlag[0] )
    {
      v30 = TraceFP();
      fprintf(v30, "LYMain: User in Local domain\n");
    }
    v39 = !no_inside_telnet && telnet_ok;
    telnet_ok = v39;
    v40 = !no_inside_news && news_ok;
    news_ok = v40;
    v41 = !no_inside_ftp && ftp_ok;
    ftp_ok = v41;
    v42 = !no_inside_rlogin && rlogin_ok;
    rlogin_ok = v42;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v31 = TraceFP();
      fprintf(v31, "LYMain: User in REMOTE domain\n");
    }
    v43 = !no_outside_telnet && telnet_ok;
    telnet_ok = v43;
    v44 = !no_outside_news && news_ok;
    news_ok = v44;
    v45 = !no_outside_ftp && ftp_ok;
    ftp_ok = v45;
    v46 = !no_outside_rlogin && rlogin_ok;
    rlogin_ok = v46;
  }
  LYSetConfigValue("broken_ftp_retr", "ProFTPD 1.2.5");
  LYSetConfigValue("broken_ftp_retr", "spftp/");
  LYSetConfigValue("broken_ftp_epsv", "(Version wu-2.6.2-12)");
  if ( !bookmark_page || !*bookmark_page )
  {
    dest = 0;
    HTSprintf0(&dest, "lynx_bookmarks%s", ".html");
    set_default_bookmark_page(dest);
    if ( dest )
    {
      free(dest);
      dest = 0;
    }
  }
  if ( !BookmarkPage || !*BookmarkPage )
    set_default_bookmark_page(bookmark_page);
  LYOpenlog(syslog_txt);
  if ( x_display && *x_display )
    LYisConfiguredForX = 1;
  if ( dump_output_immediately )
  {
    if ( !crawl || number_links || number_fields )
    {
      if ( no_numbers )
      {
        keypad_mode = 0;
      }
      else if ( !no_list && keypad_mode != 1 && keypad_mode != 2 )
      {
        if ( number_fields )
          keypad_mode = 2;
        else
          keypad_mode = 1;
      }
    }
    else
    {
      keypad_mode = 0;
    }
    if ( dump_output_width > 0 )
      LYcols = dump_output_width;
    HTAddGotoURL(startfile);
    for ( countp = HTList_count(Goto_URLs) - 1; countp >= 0; --countp )
    {
      v32 = (const char *)HTList_objectAt(Goto_URLs, countp);
      HTSACopy(&startfile, v32);
      if ( WWW_TraceFlag[0] )
      {
        v33 = startfile;
        v34 = HTList_count(Goto_URLs);
        v35 = countp + 1;
        v36 = TraceFP();
        fprintf(v36, "dumping %d:%d %s\n", v35, v34, v33);
      }
      code = mainloop();
      if ( !no_list && !crawl )
        printlist(stdout, 0);
      if ( countp )
        putchar(10);
    }
    if ( persistent_cookies[0] )
      LYStoreCookies(LYCookieSaveFile);
    exit_immediately(code);
  }
  cache_tag_styles();
  if ( with_backspaces )
    with_backspaces = 0;
  ena_csi(LYlowest_eightbit[current_char_set] > 155);
  code = mainloop();
  LYCloseCloset(RECALL_URL);
  LYCloseCloset(RECALL_MAIL);
  cleanup();
  exit_immediately(code);
}

//----- (0807A470) --------------------------------------------------------
void LYRegisterLynxProtocols()
{
  HTRegisterProtocol(&LYLynxKeymap);
  HTRegisterProtocol(&LYLynxCGI);
  HTRegisterProtocol(&LYLynxIMGmap);
  HTRegisterProtocol(&LYLynxCookies);
  HTRegisterProtocol(&LYLynxStatusMessages);
}

//----- (0807A4B4) --------------------------------------------------------
void reload_read_cfg()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  char *LYCookieSaveFile_flag; // [esp+24h] [ebp-14h] BYREF
  char *LYCookieFile_flag; // [esp+28h] [ebp-10h] BYREF
  FILE *rcfp; // [esp+2Ch] [ebp-Ch]
  char *tempfile; // [esp+30h] [ebp-8h]
  BOOLEAN persistent_cookies_flag; // [esp+37h] [ebp-1h]

  if ( !no_option_save )
  {
    tempfile = (char *)calloc(0x100u, 1u);
    if ( tempfile )
    {
      rcfp = LYOpenTemp(tempfile, ".rc", "w");
      if ( rcfp )
      {
        if ( save_rc(rcfp) )
        {
          persistent_cookies_flag = persistent_cookies[0];
          LYCookieFile_flag = 0;
          LYCookieSaveFile_flag = 0;
          if ( persistent_cookies[0] )
          {
            HTSACopy(&LYCookieFile_flag, LYCookieFile);
            HTSACopy(&LYCookieSaveFile_flag, LYCookieSaveFile);
          }
          html_src_on_lynxcfg_reload();
          free_lynx_cfg();
          source_cache_file_error[0] = 0;
          read_cfg(lynx_cfg_file, "main program", 1, 0);
          rcfp = (FILE *)fopen64(tempfile, "r");
          read_rc(rcfp);
          LYRemoveTemp(tempfile);
          if ( tempfile )
          {
            free(tempfile);
            tempfile = 0;
          }
          LYSetDisplayLines();
          if ( persistent_cookies[0] != persistent_cookies_flag )
          {
            persistent_cookies[0] = persistent_cookies_flag;
            v3 = gettext("persistent cookies state will be changed in next session only.");
            HTAlert(v3);
          }
          if ( persistent_cookies[0] )
          {
            if ( strcmp(LYCookieFile, LYCookieFile_flag) )
            {
              HTSACopy(&LYCookieFile, LYCookieFile_flag);
              if ( WWW_TraceFlag[0] )
              {
                v4 = TraceFP();
                fprintf(v4, "cookie file can be changed in next session only, restored.\n");
              }
            }
            if ( strcmp(LYCookieSaveFile, LYCookieSaveFile_flag) )
            {
              HTSACopy(&LYCookieSaveFile, LYCookieSaveFile_flag);
              if ( WWW_TraceFlag[0] )
              {
                v5 = TraceFP();
                fprintf(v5, "cookie save file can be changed in next session only, restored.\n");
              }
            }
            if ( LYCookieFile_flag )
            {
              free(LYCookieFile_flag);
              LYCookieFile_flag = 0;
            }
            if ( LYCookieSaveFile_flag )
              free(LYCookieSaveFile_flag);
          }
        }
        else
        {
          v2 = gettext("Unable to save Options!");
          HTAlwaysAlert(0, v2);
          LYRemoveTemp(tempfile);
          free(tempfile);
          tempfile = 0;
        }
      }
      else
      {
        free(tempfile);
        tempfile = 0;
        v1 = gettext("Can't open temporary file!");
        HTAlwaysAlert(0, v1);
      }
    }
    else
    {
      v0 = gettext("Not enough memory!");
      HTAlwaysAlert(0, v0);
    }
  }
}
// 807A52F: conditional instruction was optimized away because %tempfile.4!=0
// 807A59E: conditional instruction was optimized away because %tempfile.4!=0
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0807A78D) --------------------------------------------------------
void disable_pausing()
{
  AlertSecs = 0;
  DebugSecs = 0;
  InfoSecs = 0;
  MessageSecs = 0;
  ReplaySecs = 0;
}

//----- (0807A7C4) --------------------------------------------------------
void force_dump_mode()
{
  dump_output_immediately = 1;
  disable_pausing();
  LYcols = 80;
}

//----- (0807A7DF) --------------------------------------------------------
int __cdecl parse_authentication(char *next_arg, char **result)
{
  size_t v3; // [esp+8h] [ebp-20h]
  char *cp; // [esp+20h] [ebp-8h]
  char *cpa; // [esp+20h] [ebp-8h]
  char *auth_info; // [esp+24h] [ebp-4h] BYREF

  auth_info = 0;
  if ( next_arg )
  {
    HTSACopy(&auth_info, next_arg);
    v3 = strlen(next_arg);
    memset(next_arg, 32, v3);
  }
  if ( auth_info )
  {
    cp = strchr(auth_info, 58);
    if ( cp )
    {
      *cp = 0;
      cpa = cp + 1;
      HTUnEscape(cpa);
      HTSACopy(result + 1, cpa);
    }
    if ( *auth_info )
    {
      HTUnEscape(auth_info);
      HTSACopy(result, auth_info);
    }
    if ( auth_info )
    {
      free(auth_info);
      auth_info = 0;
    }
  }
  return 0;
}

//----- (0807A8BE) --------------------------------------------------------
int __cdecl anonymous_fun(char *next_arg)
{
  if ( !LYValidate && !LYRestricted )
    parse_restrictions("default");
  LYRestricted = 1;
  return 0;
}

//----- (0807A8F4) --------------------------------------------------------
int __cdecl assume_charset_fun(char *next_arg)
{
  UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
  HTSACopy(&UCAssume_MIMEcharset, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return 0;
}

//----- (0807A92F) --------------------------------------------------------
int __cdecl assume_local_charset_fun(char *next_arg)
{
  UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(next_arg);
  return 0;
}

//----- (0807A94C) --------------------------------------------------------
int __cdecl assume_unrec_charset_fun(char *next_arg)
{
  UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(next_arg);
  return 0;
}

//----- (0807A969) --------------------------------------------------------
int __cdecl auth_fun(char *next_arg)
{
  parse_authentication(next_arg, authentication_info);
  return 0;
}

//----- (0807A989) --------------------------------------------------------
int __cdecl base_fun(char *next_arg)
{
  LYPrependBase = 1;
  if ( HTAtom_for("www/dump") == HTOutputFormat )
    HTOutputFormat = HTAtom_for("www/download");
  return 0;
}

//----- (0807A9C5) --------------------------------------------------------
int __cdecl cache_fun(char *next_arg)
{
  if ( next_arg )
    HTCacheSize = atoi(next_arg);
  if ( HTCacheSize <= 1 )
    HTCacheSize = 2;
  return 0;
}

//----- (0807A9FC) --------------------------------------------------------
int __cdecl child_fun(char *next_arg)
{
  child_lynx = 1;
  no_disk_save = 1;
  no_mail = 1;
  return 0;
}

//----- (0807AA1B) --------------------------------------------------------
int __cdecl child_relaxed_fun(char *next_arg)
{
  child_lynx = 1;
  return 0;
}

//----- (0807AA2C) --------------------------------------------------------
int __cdecl crawl_fun(char *next_arg)
{
  crawl = 1;
  LYcols = 80;
  return 0;
}

//----- (0807AA47) --------------------------------------------------------
int __cdecl display_fun(char *next_arg)
{
  if ( next_arg )
    LYsetXDisplay(next_arg);
  return 0;
}

//----- (0807AA65) --------------------------------------------------------
int __cdecl display_charset_fun(char *next_arg)
{
  char *v1; // eax
  int i; // [esp+24h] [ebp-4h]

  i = UCGetLYhndl_byMIME(next_arg);
  if ( i >= 0 )
  {
    current_char_set = i;
  }
  else
  {
    v1 = gettext("Lynx: ignoring unrecognized charset=%s\n");
    fprintf(stderr, v1, next_arg);
  }
  return 0;
}

//----- (0807AAB5) --------------------------------------------------------
int __cdecl dump_output_fun(char *next_arg)
{
  force_dump_mode();
  return 0;
}

//----- (0807AAC4) --------------------------------------------------------
int __cdecl editor_fun(char *next_arg)
{
  if ( next_arg )
    HTSACopy(&editor, next_arg);
  system_editor = 1;
  return 0;
}

//----- (0807AAF1) --------------------------------------------------------
int __cdecl error_file_fun(char *next_arg)
{
  if ( next_arg )
    http_error_file = next_arg;
  return 0;
}

//----- (0807AB09) --------------------------------------------------------
int __cdecl exec_fun(char *next_arg)
{
  local_exec = 1;
  return 0;
}

//----- (0807AB1A) --------------------------------------------------------
int __cdecl get_data_fun(char *next_arg)
{
  char *v1; // ebx
  FILE *v2; // eax
  const char *v3; // ebx
  FILE *v4; // eax
  char *buf; // [esp+1Ch] [ebp-Ch] BYREF
  char **get_data; // [esp+20h] [ebp-8h]

  buf = 0;
  force_dump_mode();
  HTSACopy(&form_get_data, "?");
  get_data = &form_get_data;
  while ( GetStdin(&buf, 1) )
    HTSACat(get_data, buf);
  if ( WWW_TraceFlag[0] )
  {
    v1 = *get_data;
    v2 = TraceFP();
    fprintf(v2, "get_data:%s\n", v1);
  }
  if ( WWW_TraceFlag[0] )
  {
    v3 = form_get_data;
    v4 = TraceFP();
    fprintf(v4, "get_data:%s\n", v3);
  }
  return 0;
}

//----- (0807ABD5) --------------------------------------------------------
int __cdecl __noreturn help_fun(char *next_arg)
{
  print_help_and_exit(0);
}

//----- (0807ABEE) --------------------------------------------------------
int __cdecl hiddenlinks_fun(char *next_arg)
{
  if ( next_arg )
  {
    if ( !LYgetEnum(table_12416, next_arg, &LYHiddenLinks) )
      print_help_and_exit(-1);
  }
  else
  {
    LYHiddenLinks = 0;
  }
  return 0;
}

//----- (0807AC38) --------------------------------------------------------
int __cdecl homepage_fun(char *next_arg)
{
  if ( next_arg )
  {
    HTSACopy(&homepage, next_arg);
    LYEscapeStartfile(&homepage);
  }
  return 0;
}

//----- (0807AC6A) --------------------------------------------------------
int __cdecl mime_header_fun(char *next_arg)
{
  HTAtom *v2; // [esp+4h] [ebp-4h]

  keep_mime_headers = 1;
  force_dump_mode();
  if ( LYPrependBase )
    v2 = HTAtom_for("www/download");
  else
    v2 = HTAtom_for("www/dump");
  HTOutputFormat = v2;
  LYcols = 1014;
  return 0;
}

//----- (0807ACC0) --------------------------------------------------------
int __cdecl newschunksize_fun(char *next_arg)
{
  if ( next_arg )
  {
    HTNewsChunkSize = atoi(next_arg);
    if ( HTNewsChunkSize > HTNewsMaxChunk )
      HTNewsMaxChunk = HTNewsChunkSize;
  }
  return 0;
}

//----- (0807ACFC) --------------------------------------------------------
int __cdecl newsmaxchunk_fun(char *next_arg)
{
  if ( next_arg )
  {
    HTNewsMaxChunk = atoi(next_arg);
    if ( HTNewsChunkSize > HTNewsMaxChunk )
      HTNewsChunkSize = HTNewsMaxChunk;
  }
  return 0;
}

//----- (0807AD38) --------------------------------------------------------
int __cdecl nobold_fun(char *next_arg)
{
  LYnoVideo(1);
  return 0;
}

//----- (0807AD51) --------------------------------------------------------
int __cdecl nobrowse_fun(char *next_arg)
{
  HTDirAccess = 0;
  return 0;
}

//----- (0807AD65) --------------------------------------------------------
int __cdecl nocolor_fun(char *next_arg)
{
  LYShowColor = 0;
  return 0;
}

//----- (0807AD79) --------------------------------------------------------
int __cdecl nopause_fun(char *next_arg)
{
  disable_pausing();
  return 0;
}

//----- (0807AD88) --------------------------------------------------------
int __cdecl nomore_fun(char *next_arg)
{
  nomore[0] = 1;
  return 0;
}

//----- (0807AD99) --------------------------------------------------------
int __cdecl noreverse_fun(char *next_arg)
{
  LYnoVideo(2);
  return 0;
}

//----- (0807ADB2) --------------------------------------------------------
int __cdecl nounderline_fun(char *next_arg)
{
  LYnoVideo(4);
  return 0;
}

//----- (0807ADCB) --------------------------------------------------------
int __cdecl pauth_fun(char *next_arg)
{
  parse_authentication(next_arg, proxyauth_info);
  return 0;
}

//----- (0807ADEB) --------------------------------------------------------
int __cdecl post_data_fun(char *next_arg)
{
  char *buf; // [esp+10h] [ebp-8h] BYREF
  char **post_data; // [esp+14h] [ebp-4h]

  buf = 0;
  force_dump_mode();
  post_data = &form_post_data;
  while ( GetStdin(&buf, 1) )
    HTSACat(post_data, buf);
  return 0;
}

//----- (0807AE36) --------------------------------------------------------
const char *__cdecl show_restriction(const char *name)
{
  int restriction; // [esp+14h] [ebp-14h]

  restriction = find_restriction(name, -1);
  if ( !restriction )
    return "off";
  if ( restriction == 1 )
    return "on";
  return "?";
}

//----- (0807AE83) --------------------------------------------------------
int __cdecl restrictions_fun(char *next_arg)
{
  size_t v1; // ebx
  const char *v3; // [esp+10h] [ebp-28h]
  const char *value; // [esp+1Ch] [ebp-1Ch]
  const char *valuea; // [esp+1Ch] [ebp-1Ch]
  const char *name; // [esp+20h] [ebp-18h]
  unsigned int column; // [esp+24h] [ebp-14h]
  unsigned int k; // [esp+28h] [ebp-10h]
  unsigned int j; // [esp+2Ch] [ebp-Ch]
  unsigned int ja; // [esp+2Ch] [ebp-Ch]
  int jb; // [esp+2Ch] [ebp-Ch]
  BOOLEAN first; // [esp+32h] [ebp-6h]
  BOOLEAN found; // [esp+33h] [ebp-5h]

  column = 0;
  if ( !next_arg || !*next_arg )
  {
    for ( j = 0; j <= 3; ++j )
      puts(Usage_12540[j]);
    for ( ja = 0; ja <= 0x25; ++ja )
    {
      if ( !strcmp(table_12539[ja].name, "all") || !strcmp(table_12539[ja].name, "default") )
        value = 0;
      else
        value = show_restriction(table_12539[ja].name);
      print_help_strings(table_12539[ja].name, (&help)[2 * ja], value, 0);
    }
    first = 1;
    for ( jb = 0; ; ++jb )
    {
      found = 0;
      name = index_to_restriction(jb);
      if ( !name )
        break;
      for ( k = 0; k <= 0x25; ++k )
      {
        if ( !strcmp(name, table_12539[k].name) )
          found = 1;
      }
      if ( !found )
      {
        if ( first )
          puts("Other restrictions (see the user's guide):");
        valuea = show_restriction(table_12539[jb].name);
        if ( column )
          v3 = ", ";
        else
          v3 = "  ";
        printf("%s%s (%s)", v3, name, valuea);
        v1 = strlen(name);
        column += v1 + strlen(valuea) + 5;
        if ( column > 0x32 )
        {
          column = 0;
          putchar(10);
        }
        first = 0;
      }
    }
    if ( column )
      putchar(10);
    exit_immediately(0);
  }
  if ( *next_arg == 63 )
  {
    print_restrictions_to_fd(stdout);
    exit_immediately(0);
  }
  parse_restrictions(next_arg);
  return 0;
}

//----- (0807B0D5) --------------------------------------------------------
int __cdecl selective_fun(char *next_arg)
{
  HTDirAccess = 1;
  return 0;
}

//----- (0807B0E9) --------------------------------------------------------
int __cdecl source_fun(char *next_arg)
{
  HTAtom *v2; // [esp+4h] [ebp-4h]

  force_dump_mode();
  if ( LYPrependBase )
    v2 = HTAtom_for("www/download");
  else
    v2 = HTAtom_for("www/dump");
  HTOutputFormat = v2;
  LYcols = 1014;
  return 0;
}

//----- (0807B138) --------------------------------------------------------
int __cdecl traversal_fun(char *next_arg)
{
  traversal = 1;
  LYcols = 1014;
  return 0;
}

//----- (0807B153) --------------------------------------------------------
int __cdecl __noreturn version_fun(char *next_arg)
{
  char *v1; // ebx
  char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *result[2]; // [esp+20h] [ebp-8h] BYREF

  result[0] = 0;
  SetLocale();
  v1 = LYVersionDate();
  v2 = gettext("%s Version %s (%s)");
  HTSprintf0(result, v2, "Lynx", "2.8.7dev.11", v1);
  HTSACat(result, "\n");
  HTSprintf(result, "libwww-FM %s", HTLibraryVersion);
  v3 = curses_version();
  HTSprintf(result, ", %s", v3);
  HTSprintf(result, "(wide)");
  puts(result[0]);
  free(result[0]);
  v4 = gettext("Built on %s %s %s\n");
  printf(v4, "linux-gnu", "May 21 2010", "12:03:35");
  puts(&locale);
  v5 = gettext("Copyrights held by the Lynx Developers Group,");
  puts(v5);
  v6 = gettext("the University of Kansas, CERN, and other contributors.");
  puts(v6);
  v7 = gettext("Distributed under the GNU General Public License (Version 2).");
  puts(v7);
  v8 = gettext("See http://lynx.isc.org/ and the online help for more information.");
  puts(v8);
  puts(&locale);
  exit_immediately(0);
}

//----- (0807B2BB) --------------------------------------------------------
int __cdecl width_fun(char *next_arg)
{
  int v2; // [esp+4h] [ebp-14h]
  int w; // [esp+14h] [ebp-4h]

  if ( next_arg )
  {
    w = atoi(next_arg);
    if ( w > 0 )
    {
      v2 = w;
      if ( w > 1014 )
        v2 = 1014;
      dump_output_width = v2;
    }
  }
  return 0;
}

//----- (0807B300) --------------------------------------------------------
void __cdecl print_help_strings(const char *name, const char *help, const char *value, BOOLEAN option)
{
  const char *v5; // [esp+1Ch] [ebp-1Ch]
  int first; // [esp+28h] [ebp-10h]
  int c; // [esp+2Ch] [ebp-Ch]
  int pad; // [esp+30h] [ebp-8h]
  int pada; // [esp+30h] [ebp-8h]
  int padb; // [esp+30h] [ebp-8h]

  pad = -2 - option - strlen(name) + 20;
  if ( option )
    v5 = "-";
  else
    v5 = &locale;
  fprintf(stdout, "  %s%s", v5, name);
  if ( *help == 61 )
  {
    first = pad;
  }
  else
  {
    for ( pada = pad - 1; pada > 0; --pada )
      fputc(32, stdout);
    fputc(32, stdout);
    first = 0;
  }
  if ( strchr(help, 10) )
  {
    while ( 1 )
    {
      c = *help;
      if ( !*help )
        break;
      if ( c == 10 )
      {
        padb = --first;
        if ( first >= 0 )
          c = 32;
        else
          padb = 20;
        fputc(c, stdout);
        while ( padb-- != 0 )
          fputc(32, stdout);
      }
      else
      {
        fputc(c, stdout);
      }
      ++help;
      --first;
    }
  }
  else
  {
    fputs(help, stdout);
  }
  if ( value )
    printf(" (%s)", value);
  fputc(10, stdout);
}

//----- (0807B4C0) --------------------------------------------------------
void __cdecl __noreturn print_help_and_exit(int exit_status)
{
  const char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v4; // [esp+18h] [ebp-420h]
  char *v5; // [esp+20h] [ebp-418h]
  ParseUnion *q; // [esp+24h] [ebp-414h]
  char *value; // [esp+28h] [ebp-410h]
  Config_Type *p; // [esp+2Ch] [ebp-40Ch]
  char temp[1024]; // [esp+30h] [ebp-408h] BYREF
  unsigned int v10; // [esp+430h] [ebp-8h]

  v10 = __readgsdword(0x14u);
  if ( !pgm )
    pgm = "lynx";
  v1 = pgm;
  v2 = gettext("USAGE: %s [options] [file]\n");
  fprintf(stdout, v2, v1);
  v3 = gettext("Options are:\n");
  fprintf(stdout, v3);
  print_help_strings(&locale, "receive options and arguments from stdin", 0, 1);
  for ( p = Arg_Table; ; ++p )
  {
    if ( !p->name )
      exit_immediately(exit_status);
    value = temp;
    q = (ParseUnion *)&p->value;
    v4 = p->type & 0xFF0;
    if ( v4 == 48 )
    {
      if ( *q->set_value )
        v5 = "off";
      else
        v5 = "on";
      strcpy(temp, v5);
    }
    else if ( (p->type & 0xFF0u) > 0x30 )
    {
      if ( v4 != 112 )
      {
        if ( v4 == 128 )
        {
          sprintf(temp, "%.3f", (double)((long double)*q->int_value / 1000.0));
          goto LABEL_27;
        }
        if ( v4 == 96 )
        {
          sprintf(temp, "%d", *q->int_value);
          goto LABEL_27;
        }
LABEL_26:
        value = 0;
        goto LABEL_27;
      }
      value = (char *)*q->int_value;
      if ( value && !*value )
        value = 0;
    }
    else
    {
      if ( v4 != 16 && v4 != 32 )
        goto LABEL_26;
      if ( *q->set_value )
        strcpy(temp, "on");
      else
        strcpy(temp, "off");
    }
LABEL_27:
    print_help_strings(p->name, p->help_string, value, 1);
  }
}

//----- (0807B776) --------------------------------------------------------
int __cdecl arg_eqs_parse(const char *a, char *b, char **c)
{
  int result; // [esp+14h] [ebp-4h]

  result = -1;
  *c = 0;
  while ( result < 0 )
  {
    if ( *a != *b || !*a || !*b )
    {
      if ( *a )
      {
        if ( *a != 95 || *b != 45 )
          result = 0;
      }
      else
      {
        switch ( *b )
        {
          case 0:
            result = 1;
            break;
          case 9:
          case 32:
            *c = LYSkipBlanks(b);
            result = 1;
            break;
          case 43:
            goto LABEL_11;
          case 45:
            if ( ((*__ctype_b_loc())[(unsigned __int8)b[1]] & 0x400) != 0 )
            {
              result = 0;
            }
            else
            {
LABEL_11:
              *c = b;
              result = 1;
            }
            break;
          case 58:
          case 61:
            *c = b + 1;
            result = 1;
            break;
          default:
            result = 0;
            break;
        }
      }
    }
    ++a;
    ++b;
  }
  return result;
}

//----- (0807B8A0) --------------------------------------------------------
BOOLEAN __cdecl parse_arg(char **argv, unsigned int mask, int *countp)
{
  FILE *v3; // eax
  const char *v4; // ebx
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  int v8; // ebx
  FILE *v9; // edx
  int *def_value; // ebx
  char *v11; // ebx
  const char *v12; // esi
  char *v13; // eax
  int v15; // [esp+14h] [ebp-44h]
  char *v17; // [esp+1Ch] [ebp-3Ch]
  int v18; // [esp+20h] [ebp-38h]
  int v19; // [esp+24h] [ebp-34h]
  float ival; // [esp+34h] [ebp-24h] BYREF
  char *temp_ptr; // [esp+38h] [ebp-20h] BYREF
  char *next_arg; // [esp+3Ch] [ebp-1Ch] BYREF
  ParseFunc fun; // [esp+40h] [ebp-18h]
  ParseUnion *q; // [esp+44h] [ebp-14h]
  char *src; // [esp+48h] [ebp-10h]
  Config_Type *p; // [esp+4Ch] [ebp-Ch]

  src = *argv;
  if ( WWW_TraceFlag[0] )
  {
    if ( countp )
      v15 = *countp;
    else
      v15 = -1;
    v3 = TraceFP();
    fprintf(v3, "parse_arg(arg_name=%s, mask=%u, count=%d)\n", src, mask, v15);
  }
  if ( (countp == 0) == mask )
  {
    no_options_further_12842 = 0;
    if ( nonoption )
    {
      free(nonoption);
      nonoption = 0;
    }
  }
  if ( *src == 45 && no_options_further_12842 != 1 )
  {
    if ( !strcmp(src, "--") )
    {
      no_options_further_12842 = 1;
      return 1;
    }
    else if ( *++src )
    {
      if ( *src == 45 )
        ++src;
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "parse_arg lookup(%s)\n", src);
      }
      for ( p = Arg_Table; ; ++p )
      {
        if ( !p->name )
        {
          if ( !pgm )
            pgm = "LYNX";
          v11 = *argv;
          v12 = pgm;
          v13 = gettext("%s: Invalid Option: %s\n");
          fprintf(stderr, v13, v12, v11);
          print_help_and_exit(-1);
        }
        q = (ParseUnion *)&p->value;
        next_arg = 0;
        temp_ptr = 0;
        if ( *p->name == *src )
        {
          if ( arg_eqs_parse(p->name, src, &next_arg) )
            break;
        }
      }
      if ( (p->type & 0x1000) != 0 )
      {
        if ( !next_arg )
        {
          next_arg = argv[1];
          if ( countp )
          {
            if ( next_arg )
              ++*countp;
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          if ( next_arg )
            v17 = next_arg;
          else
            v17 = "(null)";
          v7 = TraceFP();
          fprintf(v7, "...arg:%s\n", v17);
        }
      }
      if ( (mask & p->type) != 0 )
      {
        v18 = p->type & 0xFF0;
        if ( v18 == 64 )
        {
          fun = (ParseFunc)q->def_value;
          if ( fun )
            fun(next_arg);
        }
        else if ( (p->type & 0xFF0u) > 0x40 )
        {
          if ( v18 == 96 )
          {
            if ( q->def_value && next_arg )
            {
              def_value = (int *)q->def_value;
              *def_value = strtol(next_arg, &temp_ptr, 0);
            }
          }
          else if ( (p->type & 0xFF0u) > 0x60 )
          {
            if ( v18 == 112 )
            {
              if ( q->def_value && next_arg )
                *q->int_value = (int)next_arg;
            }
            else if ( v18 == 128 && q->def_value && next_arg && sscanf(next_arg, "%f", &ival) == 1 )
            {
              *q->int_value = (int)(ival * 1000.0);
            }
          }
          else if ( v18 == 80 && q->def_value && next_arg )
          {
            HTSACopy(q->str_value, next_arg);
          }
        }
        else if ( (v18 == 32 || v18 == 48 || v18 == 16) && q->def_value )
        {
          if ( next_arg )
          {
            if ( *next_arg != 49 && *next_arg != 43 && strcasecomp(next_arg, "on") && strcasecomp(next_arg, "true") )
            {
              if ( *next_arg == 48
                || *next_arg == 45
                || !strcasecomp(next_arg, "off")
                || !strcasecomp(next_arg, "false") )
              {
                *q->set_value = 0;
              }
            }
            else
            {
              *q->set_value = 1;
            }
          }
          else
          {
            v19 = p->type & 0xFF0;
            switch ( v19 )
            {
              case 32:
                *q->set_value = 1;
                break;
              case 48:
                *q->set_value = 0;
                break;
              case 16:
                *q->set_value = *q->set_value == 0;
                break;
            }
          }
        }
        Old_DTD = DTD_recovery;
        return 1;
      }
      else
      {
        if ( WWW_TraceFlag[0] )
        {
          v8 = p->type & 7;
          v9 = TraceFP();
          fprintf(v9, "...skip (mask %u/%d)\n", mask, v8);
        }
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( mask == 4 )
    {
      if ( nonoption )
      {
        LYEnsureAbsoluteURL(&nonoption, "NONOPTION", 0);
        HTAddGotoURL(nonoption);
        if ( nonoption )
        {
          free(nonoption);
          nonoption = 0;
        }
      }
      HTSACopy(&nonoption, src);
    }
    HTSACopy(&startfile, src);
    LYEscapeStartfile(&startfile);
    if ( WWW_TraceFlag[0] )
    {
      v4 = startfile;
      v5 = TraceFP();
      fprintf(v5, "parse_arg startfile:%s\n", v4);
    }
    return countp != 0;
  }
}

//----- (0807BEBF) --------------------------------------------------------
void __cdecl __noreturn FatalProblem(int sig)
{
  char *v1; // eax

  signal(1, (__sighandler_t)1);
  signal(15, (__sighandler_t)1);
  signal(2, (__sighandler_t)1);
  signal(11, (__sighandler_t)1);
  signal(4, (__sighandler_t)1);
  fflush(stderr);
  fflush(stdout);
  if ( LYOutOfMemory[0] && LYCursesON[0] )
    LYSleepAlert();
  cleanup_sig(0);
  signal(11, 0);
  signal(4, 0);
  if ( !LYOutOfMemory[0] )
  {
    fprintf(stderr, "\r\nA Fatal error has occurred in %s Ver. %s\r\n", "Lynx", "2.8.7dev.11");
    fwrite(
      "\r\n"
      "Please notify your system administrator to confirm a bug, and\r\n"
      "if confirmed, to notify the lynx-dev list.  Bug reports should\r\n"
      "have concise descriptions of the command and/or URL which causes\r\n"
      "the problem, the operating system name with version number, the\r\n"
      "TCPIP implementation, and any other relevant information.\r\n",
      1u,
      0x13Fu,
      stderr);
    if ( sig || !LYNoCore )
      fwrite("\r\nDo NOT mail the core file if one was generated.\r\n", 1u, 0x33u, stderr);
    if ( sig )
      fprintf(stderr, "\r\nLynx now exiting with signal:  %d\r\n\r\n", sig);
    if ( LYNoCore )
      exit_immediately(1);
    abort();
  }
  LYOutOfMemory[0] = 0;
  v1 = gettext("Memory exhausted!  Program aborted!");
  printf("\r\n%s\r\n\r\n", v1);
  fflush(stdout);
  exit_immediately(1);
}

//----- (0807C0A0) --------------------------------------------------------
int __cdecl sametext(char *een, char *twee)
{
  return !een || !twee || strcmp(een, twee) == 0;
}

//----- (0807C0DD) --------------------------------------------------------
void TracelogOpenFailed()
{
  char *v0; // eax
  char *v1; // eax

  WWW_TraceFlag[0] = 0;
  if ( !LYCursesON[0] )
  {
    v1 = gettext("Trace Log open failed.  Trace off!");
    fprintf(stderr, "%s\n", v1);
    exit_immediately(1);
  }
  v0 = gettext("Trace Log open failed.  Trace off!");
  HTUserMsg(v0);
}

//----- (0807C13F) --------------------------------------------------------
BOOLEAN __cdecl LYReopenTracelog(BOOLEAN *trace_flag_ptr)
{
  FILE *v1; // eax

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "\nTurning off TRACE for fetch of log.\n");
  }
  LYCloseTracelog();
  LYTraceLogFP = LYAppendToTxtFile(LYTraceLogPath);
  if ( LYTraceLogFP )
  {
    if ( WWW_TraceFlag[0] )
    {
      WWW_TraceFlag[0] = 0;
      *trace_flag_ptr = 1;
    }
    return 1;
  }
  else
  {
    TracelogOpenFailed();
    return 0;
  }
}

//----- (0807C1B4) --------------------------------------------------------
void __cdecl turn_trace_back_on(BOOLEAN *trace_flag_ptr)
{
  FILE *v1; // eax

  if ( *trace_flag_ptr == 1 )
  {
    WWW_TraceFlag[0] = 1;
    *trace_flag_ptr = 0;
    v1 = TraceFP();
    fwrite("Turning TRACE back on.\n\n", 1u, 0x18u, v1);
  }
}

//----- (0807C1F8) --------------------------------------------------------
FILE *TraceFP()
{
  if ( LYTraceLogFP )
    return LYTraceLogFP;
  else
    return stderr;
}

//----- (0807C21E) --------------------------------------------------------
int LYOpenTraceLog()
{
  char *v0; // ebx
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax

  if ( !WWW_TraceFlag[0] || !LYUseTraceLog || LYTraceLogFP )
    return 1;
  LYTraceLogFP = LYNewTxtFile(LYTraceLogPath);
  if ( LYTraceLogFP )
  {
    fflush(stdout);
    fflush(stderr);
    v0 = gettext("Lynx Trace Log");
    v1 = TraceFP();
    fprintf(v1, "\t\t%s (%s)\n\n", v0, "2.8.7dev.11");
    if ( LYValidate )
    {
      if ( LYRestricted && had_restrictions_default )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "Validate and some anonymous restrictions are set.\n");
        }
      }
      else if ( had_restrictions_default )
      {
        if ( WWW_TraceFlag[0] )
        {
          v3 = TraceFP();
          fprintf(v3, "Validate restrictions set, restriction \"default\" was given.\n");
        }
      }
      else if ( LYRestricted )
      {
        if ( WWW_TraceFlag[0] )
        {
          v4 = TraceFP();
          fprintf(v4, "Validate restrictions set, additional anonymous restrictions ignored.\n");
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "Validate restrictions are set.\n");
      }
    }
    else if ( LYRestricted )
    {
      if ( had_restrictions_all )
      {
        if ( WWW_TraceFlag[0] )
        {
          v6 = TraceFP();
          fprintf(v6, "Anonymous restrictions set, restriction \"all\" was given.\n");
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, "Anonymous restrictions are set.\n");
      }
    }
    else if ( had_restrictions_all && had_restrictions_default )
    {
      if ( WWW_TraceFlag[0] )
      {
        v8 = TraceFP();
        fprintf(v8, "Restrictions \"all\" and \"default\" were given.\n");
      }
    }
    else if ( had_restrictions_default )
    {
      if ( WWW_TraceFlag[0] )
      {
        v9 = TraceFP();
        fprintf(v9, "Restriction \"default\" was given.\n");
      }
    }
    else if ( had_restrictions_all && WWW_TraceFlag[0] )
    {
      v10 = TraceFP();
      fprintf(v10, "\"all\" restrictions are set.\n");
    }
    return 1;
  }
  TracelogOpenFailed();
  return 0;
}

//----- (0807C4B9) --------------------------------------------------------
void LYCloseTracelog()
{
  if ( LYTraceLogFP )
  {
    fflush(stdout);
    fflush(stderr);
    fclose(LYTraceLogFP);
    LYTraceLogFP = 0;
  }
}

//----- (0807C4FB) --------------------------------------------------------
void handle_LYK_TRACE_TOGGLE()
{
  const char *Msg; // [esp+4h] [ebp-4h]

  WWW_TraceFlag[0] = WWW_TraceFlag[0] == 0;
  if ( (unsigned __int8)LYOpenTraceLog() )
  {
    if ( WWW_TraceFlag[0] )
      Msg = gettext("Trace ON!");
    else
      Msg = gettext("Trace OFF!");
    HTUserMsg(Msg);
  }
}

//----- (0807C553) --------------------------------------------------------
void __cdecl LYSetNewline(int value)
{
  Newline = value;
}

//----- (0807C560) --------------------------------------------------------
int LYGetNewline()
{
  return Newline;
}

//----- (0807C56A) --------------------------------------------------------
void __cdecl LYChgNewline(int adjust)
{
  Newline += adjust;
}

//----- (0807C57C) --------------------------------------------------------
_BOOL4 reparse_document()
{
  bool result; // [esp+17h] [ebp-1h]

  from_source_cache[0] = 1;
  result = HTreparse_document();
  from_source_cache[0] = result;
  return result;
}

//----- (0807C5AD) --------------------------------------------------------
BOOLEAN __cdecl reparse_or_reload(int *cmd)
{
  if ( reparse_document() )
    return 0;
  *cmd = 12;
  return 1;
}

//----- (0807C5D5) --------------------------------------------------------
void __cdecl set_address(DocInfo *doc, const char *address)
{
  HTSACopy(&doc->address, address);
}

//----- (0807C5F2) --------------------------------------------------------
void __cdecl copy_address(DocInfo *dst, DocInfo *src)
{
  HTSACopy(&dst->address, src->address);
}

//----- (0807C612) --------------------------------------------------------
void __cdecl free_address(DocInfo *doc)
{
  if ( doc->address )
  {
    free(doc->address);
    doc->address = 0;
  }
}

//----- (0807C63C) --------------------------------------------------------
void __cdecl move_address(DocInfo *dst, DocInfo *src)
{
  copy_address(dst, src);
  free_address(src);
}

//----- (0807C661) --------------------------------------------------------
BOOLEAN __cdecl LYMainLoop_pageDisplay(int line_num)
{
  int prev_newline; // [esp+20h] [ebp-8h]
  char *pound; // [esp+24h] [ebp-4h]

  prev_newline = Newline;
  Newline = line_num;
  if ( from_source_cache[0] )
    goto LABEL_12;
  if ( !display_partial[0] )
    goto LABEL_12;
  if ( newdoc.line != 1 )
    goto LABEL_12;
  if ( line_num != 1 )
    goto LABEL_12;
  if ( prev_newline != 1 )
    goto LABEL_12;
  pound = strchr(newdoc.address, 35);
  if ( !pound || !*pound || !pound[1] )
    goto LABEL_12;
  if ( HTFindPoundSelector(pound + 1) )
  {
    Newline = www_search_result;
LABEL_12:
    HText_pageDisplay(Newline, prev_target);
    return 1;
  }
  Newline = 1;
  return 0;
}

//----- (0807C727) --------------------------------------------------------
BOOLEAN __cdecl set_curdoc_link(int nextlink)
{
  BOOLEAN result; // [esp+27h] [ebp-1h]

  result = 0;
  if ( curdoc.link != nextlink && nextlink >= 0 && nextlink < nlinks )
  {
    if ( curdoc.link >= 0 && curdoc.link < nlinks )
    {
      LYhighlight(0, curdoc.link, prev_target);
      result = 1;
    }
    curdoc.link = nextlink;
  }
  return result;
}

//----- (0807C792) --------------------------------------------------------
void __cdecl goto_line(int nextline)
{
  int v1; // ebx
  FILE *v2; // eax
  FILE *v3; // edx
  int old_link; // [esp+1Ch] [ebp-Ch]
  int n; // [esp+20h] [ebp-8h]

  old_link = newdoc.link;
  newdoc.link = 0;
  for ( n = 0; n < nlinks; ++n )
  {
    if ( links[n].anchor_line_num + 1 == nextline )
    {
      if ( WWW_TraceFlag[0] )
      {
        v1 = HText_getTopOfScreen() + 1;
        v2 = TraceFP();
        fprintf(v2, "top_of_screen %d\n", v1);
      }
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "goto_line(%d) -> link %d -> %d\n", nextline, old_link, n);
      }
      newdoc.link = n;
      return;
    }
  }
}

//----- (0807C85B) --------------------------------------------------------
void __cdecl set_curdoc_link_by_mouse(int nextlink)
{
  if ( set_curdoc_link(nextlink) )
  {
    LYhighlight(1, nextlink, prev_target);
    LYmsec_delay(0x14u);
  }
}

//----- (0807C899) --------------------------------------------------------
int do_change_link()
{
  char *v0; // eax
  char *msgtmp; // [esp+20h] [ebp-8h] BYREF
  int mouse_tmp; // [esp+24h] [ebp-4h]

  mouse_tmp = get_mouse_link();
  if ( mouse_tmp == -1 )
    return 0;
  if ( mouse_tmp >= 0 && mouse_tmp < nlinks )
  {
    set_curdoc_link_by_mouse(mouse_tmp);
    return 0;
  }
  msgtmp = 0;
  v0 = gettext("Internal error: Invalid mouse link %d!");
  HTSprintf0(&msgtmp, v0, mouse_tmp);
  HTAlert(msgtmp);
  if ( msgtmp )
  {
    free(msgtmp);
    msgtmp = 0;
  }
  return -1;
}

//----- (0807C92C) --------------------------------------------------------
void __cdecl do_check_goto_URL(char *user_input_buffer, char **old_user_input, BOOLEAN *force_load)
{
  size_t v3; // edx
  const char *name; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  unsigned int n; // [esp+1Ch] [ebp-Ch]
  BOOLEAN found; // [esp+23h] [ebp-5h]

  found = 0;
  if ( *user_input_buffer == 35 )
  {
    if ( user_input_buffer[1] )
    {
      if ( HTFindPoundSelector(user_input_buffer + 1) )
      {
        HTAddGotoURL(user_input_buffer);
        trimPoundSelector(curdoc.address);
        HTSACat(&curdoc.address, user_input_buffer);
      }
    }
  }
  else
  {
    HTSACopy(old_user_input, user_input_buffer);
    LYEnsureAbsoluteURL(old_user_input, &byte_81534E7, 1);
    sprintf(user_input_buffer, "%.*s", 1023, *old_user_input);
    if ( *old_user_input )
    {
      free(*old_user_input);
      *old_user_input = 0;
    }
    for ( n = 0; n <= 0x1C; ++n )
    {
      if ( **((_BYTE **)&off_81955A4 + 2 * n) )
      {
        v3 = strlen(table_11782[n].name);
        if ( !strncmp(user_input_buffer, table_11782[n].name, v3) )
        {
          found = 1;
          name = table_11782[n].name;
          v5 = gettext("You are not allowed to goto \"%s\" URLs");
          HTUserMsg2(v5, name);
          break;
        }
      }
    }
    if ( !found )
    {
      if ( LYValidate && strncasecomp(user_input_buffer, "http:", 5) && strncasecomp(user_input_buffer, "https:", 6) )
      {
        v6 = gettext("Goto a non-http URL is disallowed!");
        HTUserMsg(v6);
      }
      else
      {
        set_address(&newdoc, user_input_buffer);
        newdoc.isHEAD = 0;
        if ( are_different(&curdoc, &newdoc) )
        {
          v7 = gettext("A URL specified by the user");
          HTSACopy(&newdoc.title, v7);
          LYFreePostData(&newdoc);
          if ( newdoc.bookmark )
          {
            free(newdoc.bookmark);
            newdoc.bookmark = 0;
          }
          newdoc.safe = 0;
          newdoc.internal_link = 0;
          *force_load = 1;
          if ( lynx_edit_mode && LYAutoUncacheDirLists > 1 )
            HTuncache_current_document();
        }
        LYUserSpecifiedURL = 1;
        HTAddGotoURL(newdoc.address);
      }
    }
  }
}

//----- (0807CBB7) --------------------------------------------------------
BOOLEAN __cdecl do_check_recall(
        int ch_0,
        char *user_input_buffer,
        char **old_user_input,
        int URLTotal,
        int *URLNum,
        RecallType recall,
        BOOLEAN *FirstURLRecall)
{
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *cp; // [esp+20h] [ebp-8h]
  char *cpa; // [esp+20h] [ebp-8h]

  if ( !*old_user_input )
    HTSACopy(old_user_input, &byte_81534E7);
  while ( 1 )
  {
    while ( 1 )
    {
      LYTrimAllStartfile(user_input_buffer);
      if ( !*user_input_buffer && (recall == NORECALL || ch_0 != 256 && ch_0 != 257) )
      {
        LYstrncpy(user_input_buffer, *old_user_input, 1023);
        if ( *old_user_input )
        {
          free(*old_user_input);
          *old_user_input = 0;
        }
LABEL_53:
        v13 = gettext("Cancelled!!!");
        HTInfoMsg(v13);
        return 0;
      }
      if ( recall == NORECALL || ch_0 != 256 )
        break;
      if ( *FirstURLRecall )
      {
        *FirstURLRecall = 0;
        *URLNum = 0;
      }
      else
      {
        ++*URLNum;
      }
      if ( *URLNum >= URLTotal )
        *URLNum = 0;
      cp = (char *)HTList_objectAt(Goto_URLs, *URLNum);
      if ( cp )
      {
        LYstrncpy(user_input_buffer, cp, 1023);
        if ( goto_buffer && **old_user_input && !strcmp(*old_user_input, user_input_buffer) )
        {
          mustshow[0] = 1;
          v7 = gettext("Edit the current Goto URL: ");
          statusline(v7);
        }
        else if ( goto_buffer && URLTotal == 2 || !goto_buffer && URLTotal == 1 )
        {
          mustshow[0] = 1;
          v8 = gettext("Edit the previous Goto URL: ");
          statusline(v8);
        }
        else
        {
          mustshow[0] = 1;
          v9 = gettext("Edit a previous Goto URL: ");
          statusline(v9);
        }
        ch_0 = LYgetstr(user_input_buffer, 0, 0x400u, recall);
        if ( ch_0 < 0 )
        {
          LYstrncpy(user_input_buffer, *old_user_input, 1023);
          if ( *old_user_input )
          {
            free(*old_user_input);
            *old_user_input = 0;
          }
          goto LABEL_53;
        }
      }
    }
    if ( recall == NORECALL || ch_0 != 257 )
      return 1;
    if ( *FirstURLRecall )
    {
      *FirstURLRecall = 0;
      *URLNum = URLTotal - 1;
    }
    else
    {
      --*URLNum;
    }
    if ( *URLNum < 0 )
      *URLNum = URLTotal - 1;
    cpa = (char *)HTList_objectAt(Goto_URLs, *URLNum);
    if ( cpa )
    {
      LYstrncpy(user_input_buffer, cpa, 1023);
      if ( goto_buffer && **old_user_input && !strcmp(*old_user_input, user_input_buffer) )
      {
        mustshow[0] = 1;
        v10 = gettext("Edit the current Goto URL: ");
        statusline(v10);
      }
      else if ( goto_buffer && URLTotal == 2 || !goto_buffer && URLTotal == 1 )
      {
        mustshow[0] = 1;
        v11 = gettext("Edit the previous Goto URL: ");
        statusline(v11);
      }
      else
      {
        mustshow[0] = 1;
        v12 = gettext("Edit a previous Goto URL: ");
        statusline(v12);
      }
      ch_0 = LYgetstr(user_input_buffer, 0, 0x400u, recall);
      if ( ch_0 < 0 )
      {
        LYstrncpy(user_input_buffer, *old_user_input, 1023);
        if ( *old_user_input )
        {
          free(*old_user_input);
          *old_user_input = 0;
        }
        goto LABEL_53;
      }
    }
  }
}

//----- (0807CFE6) --------------------------------------------------------
void do_cleanup_after_delete()
{
  HTuncache_current_document();
  move_address(&newdoc, &curdoc);
  newdoc.line = curdoc.line;
  if ( curdoc.link == nlinks - 1 )
    newdoc.link = curdoc.link - 1;
  else
    newdoc.link = curdoc.link;
}

//----- (0807D03C) --------------------------------------------------------
int __cdecl find_link_near_col(int col, int delta)
{
  bool v4; // [esp+17h] [ebp-21h]
  const char *text; // [esp+20h] [ebp-18h]
  int cx_0; // [esp+24h] [ebp-14h]
  int cx_0a; // [esp+24h] [ebp-14h]
  int dist; // [esp+28h] [ebp-10h]
  int best; // [esp+2Ch] [ebp-Ch]
  int cy; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]

  for ( i = curdoc.link; ; i += delta )
  {
    if ( delta <= 0 )
      v4 = i >= 0;
    else
      v4 = i < nlinks;
    if ( !v4 )
      return -1;
    if ( delta * (links[i].ly - links[curdoc.link].ly) > 0 )
      break;
  }
  cy = links[i].ly;
  best = -1;
  dist = 1000000;
  while ( 1 )
  {
    if ( delta <= 0 )
    {
      if ( i < 0 )
        return best;
    }
    else if ( i >= nlinks )
    {
      return best;
    }
    if ( links[i].ly != cy )
      break;
    cx_0 = links[i].lx;
    text = LYGetHiliteStr(i, 0);
    if ( text )
      cx_0 += strlen(text) >> 1;
    cx_0a = cx_0 - col;
    if ( cx_0a < 0 )
      cx_0a = -cx_0a;
    if ( cx_0a < dist )
    {
      dist = cx_0a;
      best = i;
    }
    i += delta;
  }
  return best;
}

//----- (0807D199) --------------------------------------------------------
int __cdecl DoTraversal(int c, BOOLEAN *crawl_ok)
{
  size_t v2; // eax
  size_t v3; // eax
  FILE *v4; // eax
  bool v6; // [esp+18h] [ebp-20h]
  char *v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int link; // [esp+24h] [ebp-14h]
  bool rlink_allowed; // [esp+35h] [ebp-3h]
  int ca; // [esp+40h] [ebp+8h]

  v6 = nlinks > 0 && links[curdoc.link].type != 1 && links[curdoc.link].lname;
  if ( v6 )
  {
    if ( !lookup_reject(links[curdoc.link].lname) && traversal_host && links[curdoc.link].lname )
    {
      if ( strncasecomp(links[curdoc.link].lname, "LYNXIMGMAP:", 11) )
      {
        v2 = strlen(traversal_host);
        rlink_allowed = strncmp(traversal_host, links[curdoc.link].lname, v2) == 0;
      }
      else
      {
        v3 = strlen(traversal_host);
        rlink_allowed = strncmp(traversal_host, (const char *)links[curdoc.link].lname + 11, v3) == 0;
      }
    }
    else
    {
      rlink_allowed = 0;
    }
  }
  else
  {
    rlink_allowed = 0;
  }
  if ( v6 && rlink_allowed )
  {
    if ( lookup_link(links[curdoc.link].lname) )
    {
      if ( more_links || curdoc.link >= 0 && curdoc.link < nlinks - 1 )
      {
        ca = 257;
      }
      else if ( !strcmp(curdoc.title, "Entry into main screen") || nhist <= 0 )
      {
        if ( !dump_output_immediately )
        {
          cleanup();
          exit_immediately(1);
        }
        ca = -1;
      }
      else
      {
        ca = 259;
      }
    }
    else
    {
      HTSACopy(&traversal_link_to_add, links[curdoc.link].lname);
      if ( strncasecomp(traversal_link_to_add, "LYNXIMGMAP:", 11) )
        *crawl_ok = 1;
      ca = 258;
    }
  }
  else
  {
    if ( v6 )
      add_to_reject_list(links[curdoc.link].lname);
    if ( more_links || curdoc.link >= 0 && curdoc.link < nlinks - 1 )
    {
      ca = 257;
    }
    else if ( !strcmp(curdoc.title, "Entry into main screen") || nhist <= 0 )
    {
      if ( !dump_output_immediately )
      {
        cleanup();
        exit_immediately(1);
      }
      ca = -1;
    }
    else
    {
      ca = 259;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v7 = LYKeycodeToString(ca, 0);
    v8 = nlinks;
    if ( nlinks <= 0 )
      link = 0;
    else
      link = curdoc.link;
    v4 = TraceFP();
    fprintf(v4, "DoTraversal(%d:%d) -> %s\n", link, v8, v7);
  }
  return ca;
}

//----- (0807D548) --------------------------------------------------------
int __cdecl handle_LYK_ACTIVATE(
        int *c,
        int cmd,
        BOOLEAN *try_internal,
        BOOLEAN *refresh_screen,
        BOOLEAN *force_load,
        int real_cmd)
{
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *submit_action; // ebx
  FILE *v11; // eax
  const char *v12; // eax
  const char *Title; // eax
  char *v14; // eax
  char *v15; // eax
  size_t v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  const char *v20; // eax
  char *v21; // eax
  LinkInfo v23; // [esp+0h] [ebp-88h] BYREF
  int v24; // [esp+54h] [ebp-34h]
  const void *v25; // [esp+58h] [ebp-30h]
  LinkInfo *v26; // [esp+5Ch] [ebp-2Ch]
  int for_what; // [esp+64h] [ebp-24h]
  _BOOL4 v29; // [esp+68h] [ebp-20h]
  int len; // [esp+6Ch] [ebp-1Ch]
  char *src; // [esp+70h] [ebp-18h]
  char *s2; // [esp+74h] [ebp-14h]
  char *s1; // [esp+78h] [ebp-10h]

  if ( do_change_link() == -1 )
  {
    LYforce_no_cache = 0;
    reloading[0] = 0;
    return 1;
  }
  if ( nlinks <= 0 )
    return 0;
  if ( links[curdoc.link].type != 1 )
  {
    if ( no_file_url
      && (*links[curdoc.link].lname == 102 || *links[curdoc.link].lname == 70)
      && !strncasecomp(links[curdoc.link].lname, "file:", 5) )
    {
      if ( *curdoc.address != 102 && *curdoc.address != 70 || strncasecomp(curdoc.address, "file:", 5) )
      {
        if ( strncasecomp(curdoc.address, "LYNXKEYMAP:", 11) && strncasecomp(curdoc.address, "LYNXCOOKIE:", 11)
          || (v16 = strlen(helpfilepath), strncmp(links[curdoc.link].lname, helpfilepath, v16)) )
        {
          v17 = gettext("file: URLs via served links are disallowed!");
          HTAlert(v17);
          reloading[0] = 0;
          return 0;
        }
      }
      if ( curdoc.bookmark )
      {
        v18 = gettext("file: URLs via bookmarks are disallowed!");
        HTAlert(v18);
        reloading[0] = 0;
        return 0;
      }
    }
    if ( !strncasecomp(links[curdoc.link].lname, "LYNXCOOKIE:", 11)
      && ((s2 = gettext("Cookie Jar"), !curdoc.title) ? (s1 = (char *)&byte_81534E7) : (s1 = curdoc.title),
          strcmp(s1, s2) || strncasecomp(curdoc.address, "LYNXCOOKIE:", 11))
      || !strncasecomp(links[curdoc.link].lname, "LYNXDIRED:", 10)
      && !LYIsUIPage3(curdoc.address, UIP_DIRED_MENU_0, 1)
      && !LYIsUIPage3(curdoc.address, UIP_PERMIT_OPTIONS_0, 1)
      && !LYIsUIPage3(curdoc.address, UIP_UPLOAD_OPTIONS_0, 1)
      || !strncasecomp(links[curdoc.link].lname, "LYNXDOWNLOAD:", 13)
      && !LYIsUIPage3(curdoc.address, UIP_DOWNLOAD_OPTIONS_0, 1)
      || !strncasecomp(links[curdoc.link].lname, "LYNXHIST:", 9)
      && !LYIsUIPage3(curdoc.address, UIP_HISTORY_0, 1)
      && !LYIsUIPage3(curdoc.address, UIP_LIST_PAGE_0, 1)
      && !LYIsUIPage3(curdoc.address, UIP_ADDRLIST_PAGE_0, 1)
      || !strncasecomp(links[curdoc.link].lname, "LYNXPRINT:", 10)
      && !LYIsUIPage3(curdoc.address, UIP_PRINT_OPTIONS_0, 1) )
    {
      v19 = gettext("This special URL is not allowed in external documents!");
      HTAlert(v19);
      HTOutputFormat = HTAtom_for("www/present");
      LYforce_no_cache = 0;
      reloading[0] = 0;
      return 0;
    }
    if ( run_external(links[curdoc.link].lname, 1) )
    {
      *refresh_screen = 1;
      return 0;
    }
    set_address(&newdoc, links[curdoc.link].lname);
    v20 = LYGetHiliteStr(curdoc.link, 0);
    HTSACopy(&newdoc.title, v20);
    if ( are_different(&curdoc, &newdoc) )
    {
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      if ( !strncasecomp(newdoc.address, "LYNXMESSAGES:", 13) )
        LYforce_no_cache = 1;
    }
    if ( !no_jump && lynxjumpfile && curdoc.address && !strcmp(lynxjumpfile, curdoc.address) )
    {
      LYJumpFileURL = 1;
      LYUserSpecifiedURL = 1;
    }
    else if ( curdoc.title
           && (LYIsUIPage3(curdoc.address, UIP_HISTORY_0, 1)
            || (v21 = gettext("History Page"), !strcmp(curdoc.title, v21)))
           || curdoc.bookmark
           || lynxjumpfile && !strcmp(lynxjumpfile, curdoc.address) )
    {
      LYUserSpecifiedURL = 1;
    }
    else if ( no_filereferer == 1
           && (*curdoc.address == 102 || *curdoc.address == 70)
           && !strncasecomp(curdoc.address, "file:", 5) )
    {
      LYNoRefererForThis = 1;
    }
    newdoc.link = 0;
    *force_load = 1;
    psrc_view = 0;
    if ( lynx_edit_mode )
    {
      if ( LYAutoUncacheDirLists > 1 )
        HTuncache_current_document();
      HTUnEscapeSome(newdoc.address, "/");
      if ( strcasecomp(newdoc.address, "file://localhost/") )
        strip_trailing_slash(newdoc.address);
    }
    if ( !strncasecomp(curdoc.address, "LYNXCOOKIE:", 11) )
      HTuncache_current_document();
    return 0;
  }
  if ( real_cmd == 39
    && textfields_need_activation
    && (links[curdoc.link].l_form->type == 1
     || links[curdoc.link].l_form->type == 12
     || links[curdoc.link].l_form->type == 2
     || links[curdoc.link].l_form->type == 11
     || links[curdoc.link].l_form->type == 9) )
  {
    textinput_activated = 1;
    v26 = &v23;
    v25 = (const void *)(68 * curdoc.link + 136026784);
    v24 = 17;
    qmemcpy(&v23, v25, sizeof(v23));
    show_main_statusline(v23, 2);
    textfields_need_activation = textfields_activation_option;
    return 0;
  }
  if ( links[curdoc.link].l_form->type == 5
    || links[curdoc.link].l_form->type == 13
    || links[curdoc.link].l_form->type == 12 )
  {
    if ( links[curdoc.link].l_form->disabled == 1 )
    {
LABEL_17:
      HTOutputFormat = HTAtom_for("www/present");
      LYforce_no_cache = 0;
      reloading[0] = 0;
      return 0;
    }
    if ( !links[curdoc.link].l_form->submit_action || !*links[curdoc.link].l_form->submit_action )
    {
      v6 = gettext("** Bad HTML!!  No form action defined. **");
      HTUserMsg(v6);
      HTOutputFormat = HTAtom_for("www/present");
      LYforce_no_cache = 0;
      reloading[0] = 0;
      return 0;
    }
    if ( links[curdoc.link].l_form->submit_method == 3 && no_mail )
    {
      v7 = gettext("Mail disallowed!  Cannot submit.");
      HTAlert(v7);
      HTOutputFormat = HTAtom_for("www/present");
      LYforce_no_cache = 0;
      reloading[0] = 0;
      return 0;
    }
    if ( no_file_url
      && (*links[curdoc.link].l_form->submit_action == 102 || *links[curdoc.link].l_form->submit_action == 70)
      && !strncasecomp(links[curdoc.link].l_form->submit_action, "file:", 5) )
    {
      v8 = gettext("file: ACTIONs are disallowed!");
      HTAlert(v8);
      HTOutputFormat = HTAtom_for("www/present");
      LYforce_no_cache = 0;
      reloading[0] = 0;
      return 0;
    }
    if ( !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXCOOKIE:", 11)
      || !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXDIRED:", 10)
      && (no_dired_support[0]
       || strncasecomp((const char *)links[curdoc.link].l_form->submit_action + 10, "//PERMIT_LOCATION", 17)
       || !LYIsUIPage3(curdoc.address, UIP_PERMIT_OPTIONS_0, 1))
      || !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXDOWNLOAD:", 13)
      || !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXHIST:", 9)
      || !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXKEYMAP:", 11)
      || !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXIMGMAP:", 11)
      || !strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXPRINT:", 10)
      || (*links[curdoc.link].l_form->submit_action == 108 || *links[curdoc.link].l_form->submit_action == 76)
      && !strncasecomp(links[curdoc.link].l_form->submit_action, "lynxexec:", 9)
      || (*links[curdoc.link].l_form->submit_action == 108 || *links[curdoc.link].l_form->submit_action == 76)
      && !strncasecomp(links[curdoc.link].l_form->submit_action, "lynxprog:", 9) )
    {
      v9 = gettext("This special URL cannot be a form ACTION!");
      HTAlert(v9);
      if ( WWW_TraceFlag[0] )
      {
        submit_action = links[curdoc.link].l_form->submit_action;
        v11 = TraceFP();
        fprintf(v11, "LYMainLoop: Rejected '%s'\n", submit_action);
      }
      goto LABEL_17;
    }
    if ( check_realm )
      LYPermitURL = 1;
    if ( no_filereferer == 1
      && (*curdoc.address == 102 || *curdoc.address == 70)
      && !strncasecomp(curdoc.address, "file:", 5) )
    {
      LYNoRefererForThis = 1;
    }
    if ( links[curdoc.link].l_form->submit_method != 3 )
    {
      v12 = LYGetHiliteStr(curdoc.link, 0);
      HTSACopy(&newdoc.title, v12);
    }
  }
  if ( links[curdoc.link].l_form->type == 1
    || links[curdoc.link].l_form->type == 12
    || links[curdoc.link].l_form->type == 2
    || links[curdoc.link].l_form->type == 11
    || links[curdoc.link].l_form->type == 9 )
  {
    for_what = real_cmd == 46 || real_cmd == 63 || real_cmd == 68 || real_cmd == 40 && !textinput_activated ? 0 : 2;
    show_formlink_statusline(links[curdoc.link].l_form, for_what);
    if ( !user_mode && textinput_activated && (real_cmd == 39 || real_cmd == 40) )
      form_noviceline(links[curdoc.link].l_form->disabled);
  }
  v29 = real_cmd == 40 || real_cmd == 46 || real_cmd == 63 || real_cmd == 68;
  *c = change_form_link(curdoc.link, &newdoc, refresh_screen, 0, v29);
  if ( *c != 2046 || *refresh_screen )
  {
    if ( (links[curdoc.link].l_form->type == 5
       || links[curdoc.link].l_form->type == 13
       || links[curdoc.link].l_form->type == 12)
      && links[curdoc.link].l_form->submit_method != 3 )
    {
      if ( HText_getTitle() )
      {
        Title = HText_getTitle();
        HTSACopy(&newdoc.title, Title);
      }
      else if ( curdoc.title )
      {
        HTSACopy(&newdoc.title, curdoc.title);
      }
    }
    goto LABEL_105;
  }
  if ( HTAtom_for("www/download") != HTOutputFormat
    || !newdoc.post_data
    || newdoc.safe
    || HText_POSTReplyLoaded(&newdoc) != 1
    || (v14 = gettext("Document from Form with POST content.  Resubmit?"), HTConfirm(v14)) )
  {
    if ( check_realm && !LYValidate )
      LYPermitURL = 1;
LABEL_105:
    if ( *c == 2046 )
    {
      *c = 270;
    }
    else if ( *c == 23 )
    {
      *c = 270;
      *refresh_screen = 1;
    }
    else
    {
      if ( (*c & 0x8000) == 0 && (*c & 0x800) != 0 && LYReverseKeymap((unsigned __int8)*c) >= 0 )
        LYReverseKeymap((unsigned __int8)*c);
      if ( (real_cmd == 39 || real_cmd == 40)
        && (links[curdoc.link].l_form->type == 1
         || links[curdoc.link].l_form->type == 12
         || links[curdoc.link].l_form->type == 2
         || links[curdoc.link].l_form->type == 11
         || links[curdoc.link].l_form->type == 9)
        && textinput_activated )
      {
        return 3;
      }
    }
    return 2;
  }
  v15 = gettext("Cancelled!!!");
  HTInfoMsg(v15);
  HTOutputFormat = HTAtom_for("www/present");
  LYforce_no_cache = 0;
  copy_address(&newdoc, &curdoc);
  HTSACopy(&newdoc.title, curdoc.title);
  if ( curdoc.post_data )
    len = curdoc.post_data->len;
  else
    len = 0;
  if ( curdoc.post_data )
    src = curdoc.post_data->str;
  else
    src = 0;
  HTSABCopy(&newdoc.post_data, src, len);
  HTSACopy(&newdoc.post_content_type, curdoc.post_content_type);
  HTSACopy(&newdoc.bookmark, curdoc.bookmark);
  newdoc.isHEAD = curdoc.isHEAD;
  newdoc.safe = curdoc.safe;
  newdoc.internal_link = curdoc.internal_link;
  return 0;
}

//----- (0807E8FC) --------------------------------------------------------
void __cdecl handle_LYK_ADD_BOOKMARK(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  const char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *needle; // [esp+14h] [ebp-14h]
  int c; // [esp+24h] [ebp-4h]

  if ( LYValidate )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v3 = gettext("Bookmark features are currently disabled.");
      HTUserMsg(v3);
    }
    return;
  }
  if ( LYIsUIPage3(curdoc.address, UIP_HISTORY_0, 1)
    || LYIsUIPage3(curdoc.address, UIP_SHOWINFO_0, 1)
    || LYIsUIPage3(curdoc.address, UIP_PRINT_OPTIONS_0, 1)
    || LYIsUIPage3(curdoc.address, UIP_DIRED_MENU_0, 1)
    || LYIsUIPage3(curdoc.address, UIP_PERMIT_OPTIONS_0, 1)
    || LYIsUIPage3(curdoc.address, UIP_UPLOAD_OPTIONS_0, 1)
    || LYIsUIPage3(curdoc.address, UIP_DOWNLOAD_OPTIONS_0, 1)
    || !strncasecomp(curdoc.address, "LYNXCOOKIE:", 11)
    || LYIsUIPage3(curdoc.address, UIP_OPTIONS_MENU_0, 1)
    || nlinks > 0
    && (!links[curdoc.link].lname
     || !strncasecomp(links[curdoc.link].lname, "LYNXHIST:", 9)
     || !strncasecomp(links[curdoc.link].lname, "LYNXPRINT:", 10)
     || !strncasecomp(links[curdoc.link].lname, "LYNXDIRED:", 10)
     || !strncasecomp(links[curdoc.link].lname, "LYNXDOWNLOAD:", 13)
     || !strncasecomp(links[curdoc.link].lname, "LYNXCOOKIE:", 11)
     || !strncasecomp(links[curdoc.link].lname, "LYNXPRINT:", 10)) )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v12 = gettext("History, showinfo, menu and list files cannot be saved as bookmarks.");
      HTUserMsg(v12);
    }
  }
  else
  {
    if ( nlinks > 0 )
    {
      if ( curdoc.post_data
        || curdoc.bookmark
        || LYIsUIPage3(curdoc.address, UIP_LIST_PAGE_0, 1)
        || LYIsUIPage3(curdoc.address, UIP_ADDRLIST_PAGE_0, 1)
        || LYIsUIPage3(curdoc.address, UIP_VLINKS_0, 1) )
      {
        if ( !LYMultiBookmarks
          && curdoc.bookmark
          && (*bookmark_page != 46 ? (needle = bookmark_page) : (needle = bookmark_page + 1),
              strstr(curdoc.address, needle)) )
        {
          mustshow[0] = 1;
          v5 = gettext("Reproduce L)ink in this bookmark file or C)ancel? (l,c): ");
          statusline(v5);
        }
        else
        {
          if ( curdoc.post_data && links[curdoc.link].type == 6 )
            goto LABEL_48;
          mustshow[0] = 1;
          v6 = gettext("Save L)ink to bookmark file or C)ancel? (l,c): ");
          statusline(v6);
        }
        c = LYgetch_single();
      }
      else
      {
        mustshow[0] = 1;
        v4 = gettext("Save D)ocument or L)ink to bookmark file or C)ancel? (d,l,c): ");
        statusline(v4);
        c = LYgetch_single();
        if ( c == 68 )
        {
LABEL_52:
          save_bookmark_link(curdoc.address, curdoc.title);
          *refresh_screen = 1;
check_add_bookmark_to_self:
          if ( curdoc.bookmark && BookmarkPage && !strcmp(curdoc.bookmark, BookmarkPage) )
          {
            HTuncache_current_document();
            move_address(&newdoc, &curdoc);
            HTSACopy(&newdoc.bookmark, curdoc.bookmark);
            newdoc.line = curdoc.line;
            newdoc.link = curdoc.link;
            newdoc.internal_link = 0;
          }
          return;
        }
      }
      if ( c != 76 )
        return;
      if ( !curdoc.post_data || links[curdoc.link].type != 6 )
      {
        if ( links[curdoc.link].type == 1 )
        {
          v8 = gettext("Cannot save form fields/links");
          HTUserMsg(v8);
          return;
        }
        v7 = LYGetHiliteStr(curdoc.link, 0);
        save_bookmark_link(links[curdoc.link].lname, v7);
        *refresh_screen = 1;
        goto check_add_bookmark_to_self;
      }
LABEL_48:
      v9 = gettext("Documents from forms with POST content cannot be saved as bookmarks.");
      HTUserMsg(v9);
      return;
    }
    if ( curdoc.post_data )
      goto LABEL_48;
    if ( curdoc.bookmark )
    {
      v10 = gettext("There are no links in this bookmark file!");
      HTUserMsg(v10);
      return;
    }
    mustshow[0] = 1;
    v11 = gettext("Save D)ocument to bookmark file or C)ancel? (d,c): ");
    statusline(v11);
    if ( LYgetch_single() == 68 )
      goto LABEL_52;
  }
}

//----- (0807EF83) --------------------------------------------------------
void __cdecl handle_LYK_CLEAR_AUTH(int *old_c, int real_c)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  if ( *old_c != real_c )
  {
    *old_c = real_c;
    v2 = gettext("Clear all authorization info for this session?");
    if ( HTConfirm(v2) )
    {
      if ( authentication_info[0] )
      {
        free(authentication_info[0]);
        authentication_info[0] = 0;
      }
      if ( authentication_info[1] )
      {
        free(authentication_info[1]);
        authentication_info[1] = 0;
      }
      if ( proxyauth_info[0] )
      {
        free(proxyauth_info[0]);
        proxyauth_info[0] = 0;
      }
      if ( proxyauth_info[1] )
      {
        free(proxyauth_info[1]);
        proxyauth_info[1] = 0;
      }
      HTClearHTTPAuthInfo();
      HTClearNNTPAuthInfo();
      HTClearFTPPassword();
      v3 = gettext("Authorization info cleared.");
      HTUserMsg(v3);
    }
    else
    {
      v4 = gettext("Cancelled!!!");
      HTUserMsg(v4);
    }
  }
}

//----- (0807F076) --------------------------------------------------------
int __cdecl handle_LYK_COMMAND(char *user_input_buffer)
{
  FILE *v1; // edx
  int code; // [esp+1Ch] [ebp-1Ch]
  char *tmp; // [esp+28h] [ebp-10h]
  char *src; // [esp+2Ch] [ebp-Ch]
  Kcmd *mp; // [esp+30h] [ebp-8h]

  *user_input_buffer = 0;
  mustshow[0] = 1;
  statusline(": ");
  if ( LYgetstr(user_input_buffer, 0, 0x400u, RECALL_CMD) < 0 )
    return 0;
  src = LYSkipBlanks(user_input_buffer);
  tmp = LYSkipNonBlanks(src);
  *tmp = 0;
  mp = LYStringToKcmd(src);
  if ( mp )
    code = mp->code;
  else
    code = 0;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "LYK_COMMAND(%s.%s) = %d\n", src, tmp, code);
  }
  if ( code )
    return code;
  if ( *src )
    return -1;
  else
    return 0;
}

//----- (0807F182) --------------------------------------------------------
void __cdecl handle_LYK_COMMENT(BOOLEAN *refresh_screen, char **owner_address_p, int *old_c, int real_c)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // ebx
  char *v10; // edx
  char *title; // [esp+1Ch] [ebp-2Ch]
  char *v12; // [esp+20h] [ebp-28h]
  char *tmptitle; // [esp+2Ch] [ebp-1Ch] BYREF
  const char *id; // [esp+30h] [ebp-18h]
  const char *kp; // [esp+34h] [ebp-14h]
  char *cp; // [esp+38h] [ebp-10h]
  char *address; // [esp+3Ch] [ebp-Ch] BYREF
  int c; // [esp+40h] [ebp-8h]

  if ( !*owner_address_p && strncasecomp(curdoc.address, "http", 4) )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v4 = gettext("No owner is defined for this file so you cannot send a comment");
      HTUserMsg(v4);
    }
    return;
  }
  if ( no_mail )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("Mail is disallowed so you cannot send a comment");
      HTUserMsg(v5);
    }
    return;
  }
  v6 = gettext("Do you wish to send a comment?");
  if ( !HTConfirmDefault(v6, 0) )
    return;
  if ( *owner_address_p )
    goto LABEL_27;
  address = 0;
  tmptitle = HTParse(curdoc.address, &byte_81534E7, 4);
  if ( tmptitle )
  {
    HTUnEscape(tmptitle);
    if ( *tmptitle == 126 && strlen(tmptitle) > 1 )
    {
      cp = strchr(tmptitle + 1, 47);
      if ( cp )
        *cp = 0;
      HTSACopy(&address, "mailto:");
      HTSACat(&address, tmptitle + 1);
      HTSACat(&address, "@");
    }
    if ( tmptitle )
    {
      free(tmptitle);
      tmptitle = 0;
    }
  }
  if ( !address )
    HTSACopy(&address, "mailto:WebMaster@");
  tmptitle = HTParse(curdoc.address, &byte_81534E7, 8);
  HTSACat(&address, tmptitle);
  v7 = address;
  v8 = gettext("No owner is defined. Use %s?");
  HTSprintf0(&tmptitle, v8, v7);
  c = HTConfirmDefault(tmptitle, 0);
  if ( tmptitle )
  {
    free(tmptitle);
    tmptitle = 0;
  }
  if ( c == 1 )
  {
    HTSACopy(owner_address_p, address);
    if ( address )
    {
      free(address);
      address = 0;
    }
LABEL_27:
    if ( is_url(*owner_address_p) == MAILTO_URL_TYPE_0 )
    {
      kp = HText_getRevTitle();
      id = HText_getMessageID();
      tmptitle = 0;
      if ( !kp )
      {
        if ( HTMainAnchor )
        {
          kp = HTAnchor_subject(HTMainAnchor);
          if ( kp )
          {
            if ( *kp && strncasecomp(kp, "Re: ", 4) )
            {
              HTSACopy(&tmptitle, "Re: ");
              HTSACat(&tmptitle, kp);
              kp = tmptitle;
            }
          }
        }
      }
      if ( strchr(*owner_address_p, 58) )
      {
        if ( kp )
          title = (char *)kp;
        else
          title = (char *)&byte_81534E7;
        v9 = curdoc.address;
        v10 = strchr(*owner_address_p, 58) + 1;
        reply_by_mail(v10, v9, title, id);
      }
      else
      {
        if ( kp )
          v12 = (char *)kp;
        else
          v12 = (char *)&byte_81534E7;
        reply_by_mail(*owner_address_p, curdoc.address, v12, id);
      }
      if ( tmptitle )
      {
        free(tmptitle);
        tmptitle = 0;
      }
      *refresh_screen = 1;
    }
    else
    {
      set_address(&newdoc, *owner_address_p);
      newdoc.internal_link = 0;
    }
    return;
  }
  if ( address )
  {
    free(address);
    address = 0;
  }
}

//----- (0807F599) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_COOKIE_JAR(int *cmd)
{
  if ( strncasecomp(curdoc.address, "LYNXCOOKIE:", 11) )
  {
    set_address(&newdoc, "LYNXCOOKIE:/");
    LYFreePostData(&newdoc);
    if ( newdoc.bookmark )
    {
      free(newdoc.bookmark);
      newdoc.bookmark = 0;
    }
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.internal_link = 0;
    LYforce_no_cache = 1;
    if ( LYValidate || check_realm )
      LYPermitURL = 1;
    return 0;
  }
  else
  {
    *cmd = 37;
    return 1;
  }
}

//----- (0807F652) --------------------------------------------------------
void handle_LYK_CREATE()
{
  if ( lynx_edit_mode && !no_dired_support[0] && local_create(&curdoc) > 0 )
  {
    if ( LYAutoUncacheDirLists > 0 )
      HTuncache_current_document();
    move_address(&newdoc, &curdoc);
    LYFreePostData(&newdoc);
    if ( newdoc.bookmark )
    {
      free(newdoc.bookmark);
      newdoc.bookmark = 0;
    }
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link & ~(curdoc.link >> 31);
    LYclear();
  }
}

//----- (0807F707) --------------------------------------------------------
void __cdecl handle_LYK_DEL_BOOKMARK(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  char *v3; // eax

  if ( curdoc.bookmark )
  {
    v3 = gettext("Do you really want to delete this link from your bookmark file?");
    if ( HTConfirmDefault(v3, 0) == 1 )
    {
      remove_bookmark_link(links[curdoc.link].anchor_number - 1, curdoc.bookmark);
      do_cleanup_after_delete();
    }
  }
  else
  {
    *refresh_screen = 1;
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      lynx_force_repaint();
    }
  }
}

//----- (0807F787) --------------------------------------------------------
void __cdecl handle_LYK_DIRED_MENU(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  const char *s2; // [esp+10h] [ebp-8h]
  const char *s1; // [esp+14h] [ebp-4h]

  if ( lynx_edit_mode && !no_dired_support[0] && !LYIsUIPage3(curdoc.address, UIP_DIRED_MENU_0, 1) )
  {
    s2 = gettext("File Management Options");
    if ( curdoc.title )
      s1 = curdoc.title;
    else
      s1 = &byte_81534E7;
    if ( strcmp(s1, s2) )
    {
      dired_options(&curdoc, &newdoc.address);
      *refresh_screen = 1;
    }
  }
}

//----- (0807F823) --------------------------------------------------------
int __cdecl handle_LYK_DOWNLOAD(int *cmd, int *old_c, int real_c)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  const char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  const char *v19; // eax
  char *v20; // eax
  int len; // [esp+10h] [ebp-18h]
  int number; // [esp+24h] [ebp-4h]

  if ( LYValidate || no_download && !override_no_download && no_disk_save )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v3 = gettext("The 'd'ownload command is currently disabled.");
      HTUserMsg(v3);
    }
    return 0;
  }
  if ( LYIsUIPage3(curdoc.address, UIP_DOWNLOAD_OPTIONS_0, 1) )
    return 0;
  if ( do_change_link() == -1 )
    return 1;
  if ( nlinks <= 0 )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v20 = gettext("Nothing to download.");
      HTUserMsg(v20);
    }
    return 0;
  }
  if ( links[curdoc.link].type != 1 )
  {
    if ( strncasecomp(curdoc.address, "LYNXCOOKIE:", 11) )
    {
      if ( LYIsUIPage3(curdoc.address, UIP_PRINT_OPTIONS_0, 1) )
      {
        if ( *old_c != real_c )
        {
          *old_c = real_c;
          v8 = gettext("You cannot download a printing option.");
          HTUserMsg(v8);
        }
      }
      else if ( LYIsUIPage3(curdoc.address, UIP_UPLOAD_OPTIONS_0, 1) )
      {
        if ( *old_c != real_c )
        {
          *old_c = real_c;
          v9 = gettext("You cannot download an upload option.");
          HTUserMsg(v9);
        }
      }
      else if ( LYIsUIPage3(curdoc.address, UIP_PERMIT_OPTIONS_0, 1) )
      {
        if ( *old_c != real_c )
        {
          *old_c = real_c;
          v10 = gettext("You cannot download an permit option.");
          HTUserMsg(v10);
        }
      }
      else if ( !lynx_edit_mode || no_dired_support[0] || strstr(links[curdoc.link].lname, "/SugFile=") )
      {
        if ( !LYIsUIPage3(curdoc.address, UIP_HISTORY_0, 1) || strncasecomp(links[curdoc.link].lname, "LYNXHIST:", 9) )
        {
          if ( !strncmp(links[curdoc.link].lname, "data:", 5u) )
          {
            if ( *old_c != real_c )
            {
              *old_c = real_c;
              v15 = gettext("Unsupported data: URL!  Use SHOWINFO, for now.");
              HTAlert(v15);
            }
          }
          else if ( strncasecomp(links[curdoc.link].lname, "LYNXCOOKIE:", 11)
                 && strncasecomp(links[curdoc.link].lname, "LYNXDIRED:", 10)
                 && strncasecomp(links[curdoc.link].lname, "LYNXDOWNLOAD:", 13)
                 && strncasecomp(links[curdoc.link].lname, "LYNXPRINT:", 10)
                 && strncasecomp(links[curdoc.link].lname, "LYNXOPTIONS:", 12)
                 && strncasecomp(links[curdoc.link].lname, "LYNXHIST:", 9)
                 && strncasecomp(links[curdoc.link].lname, "LYNXHIST:", 9)
                 && strncasecomp(links[curdoc.link].lname, "LYNXCOMPILEOPTS:", 16)
                 && (*links[curdoc.link].lname != 108 && *links[curdoc.link].lname != 76
                  || strncasecomp(links[curdoc.link].lname, "lynxexec:", 9))
                 && (*links[curdoc.link].lname != 108 && *links[curdoc.link].lname != 76
                  || strncasecomp(links[curdoc.link].lname, "lynxprog:", 9)) )
          {
            if ( strncasecomp(links[curdoc.link].lname, "mailto:", 7) )
            {
              if ( !local_host_only
                || LYisLocalHost(links[curdoc.link].lname)
                || LYisLocalAlias(links[curdoc.link].lname) )
              {
                set_address(&newdoc, links[curdoc.link].lname);
                v19 = LYGetHiliteStr(curdoc.link, 0);
                HTSACopy(&newdoc.title, v19);
                if ( are_different(&curdoc, &newdoc) )
                {
                  LYFreePostData(&newdoc);
                  if ( newdoc.bookmark )
                  {
                    free(newdoc.bookmark);
                    newdoc.bookmark = 0;
                  }
                  newdoc.isHEAD = 0;
                  newdoc.safe = 0;
                }
                newdoc.internal_link = 0;
                newdoc.link = user_mode == 0;
                HTOutputFormat = HTAtom_for("www/download");
                LYforce_no_cache = 1;
              }
              else
              {
                v18 = gettext("Only files and servers on the local host can be accessed.");
                HTUserMsg(v18);
              }
            }
            else
            {
              v17 = gettext("You cannot download a mailto: link.");
              HTUserMsg(v17);
            }
          }
          else
          {
            v16 = gettext("This special URL cannot be downloaded!");
            HTUserMsg(v16);
          }
        }
        else
        {
          number = atoi((const char *)links[curdoc.link].lname + 9);
          if ( number >= nhist || number < 0 )
          {
            v11 = gettext("This special URL cannot be downloaded!");
            HTUserMsg(v11);
            return 0;
          }
          if ( history[number].hdoc.post_data )
          {
            if ( history[number].hdoc.safe != 1 )
            {
              v12 = gettext("Document from Form with POST content.  Resubmit?");
              if ( !HTConfirm(v12) )
              {
                v13 = gettext("Cancelled!!!");
                HTInfoMsg(v13);
                return 0;
              }
            }
          }
          copy_address(&newdoc, &history[number].hdoc);
          v14 = LYGetHiliteStr(curdoc.link, 0);
          HTSACopy(&newdoc.title, v14);
          HTSACopy(&newdoc.bookmark, history[number].hdoc.bookmark);
          LYFreePostData(&newdoc);
          if ( history[number].hdoc.post_data )
          {
            len = history[number].hdoc.post_data->len;
            if ( history[number].hdoc.post_data )
              HTSABCopy(&newdoc.post_data, history[number].hdoc.post_data->str, len);
            else
              HTSABCopy(&newdoc.post_data, 0, len);
          }
          if ( history[number].hdoc.post_content_type )
            HTSACopy(&newdoc.post_content_type, history[number].hdoc.post_content_type);
          newdoc.isHEAD = history[number].hdoc.isHEAD;
          newdoc.safe = history[number].hdoc.safe;
          newdoc.internal_link = 0;
          newdoc.link = user_mode == 0;
          HTOutputFormat = HTAtom_for("www/download");
          LYUserSpecifiedURL = 1;
          LYforce_no_cache = 1;
        }
      }
      else
      {
        copy_address(&temp_13241, &newdoc);
        set_address(&newdoc, links[curdoc.link].lname);
        if ( LYdownload_options(&newdoc.address, links[curdoc.link].lname) >= 0 )
          newdoc.internal_link = 0;
        else
          copy_address(&newdoc, &temp_13241);
        LYFreeDocInfo(&temp_13241);
      }
    }
    else if ( *old_c != real_c )
    {
      *old_c = real_c;
      v7 = gettext("You cannot download cookies.");
      HTUserMsg(v7);
    }
    return 0;
  }
  if ( links[curdoc.link].l_form->type != 5
    && links[curdoc.link].l_form->type != 13
    && links[curdoc.link].l_form->type != 12 )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v6 = gettext("You cannot download an input field.");
      HTUserMsg(v6);
    }
    return 0;
  }
  if ( links[curdoc.link].l_form->submit_method == 3 )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v4 = gettext("Form has a mailto action!  Cannot download.");
      HTUserMsg(v4);
    }
    return 0;
  }
  else if ( strncasecomp(links[curdoc.link].l_form->submit_action, "LYNXOPTIONS:", 12) )
  {
    HTOutputFormat = HTAtom_for("www/download");
    LYforce_no_cache = 1;
    *cmd = 39;
    return 2;
  }
  else
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("This special URL cannot be downloaded!");
      HTUserMsg(v5);
    }
    return 0;
  }
}

//----- (080803EA) --------------------------------------------------------
void __cdecl handle_LYK_DOWN_xxx(int *old_c, int real_c, int scroll_by)
{
  char *v3; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( more_text )
  {
    Newline += scroll_by;
    if ( nlinks > 0 && curdoc.link >= 0 && links[curdoc.link].ly > scroll_by )
    {
      newdoc.link = curdoc.link;
      for ( i = 0; links[i].ly <= scroll_by; ++i )
        --newdoc.link;
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v3 = gettext("You are already at the end of this document.");
    HTInfoMsg(v3);
  }
}

//----- (0808049E) --------------------------------------------------------
void __cdecl handle_LYK_DOWN_HALF(int *old_c, int real_c)
{
  handle_LYK_DOWN_xxx(old_c, real_c, display_lines / 2);
}

//----- (080804CB) --------------------------------------------------------
void __cdecl handle_LYK_DOWN_LINK(int *follow_col, int *old_c, int real_c)
{
  int v3; // ebx
  char *v4; // eax
  char *v5; // eax
  const char *text; // [esp+1Ch] [ebp-Ch]
  int newlink; // [esp+20h] [ebp-8h]

  if ( curdoc.link >= nlinks - 1 )
  {
    if ( more_text )
    {
      Newline += display_lines;
    }
    else if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("You are already at the end of this document.");
      HTInfoMsg(v5);
    }
  }
  else
  {
    if ( *follow_col == -1 )
    {
      text = LYGetHiliteStr(curdoc.link, 0);
      *follow_col = links[curdoc.link].lx;
      if ( text )
      {
        v3 = *follow_col;
        *follow_col = v3 + (strlen(text) >> 1);
      }
    }
    newlink = find_link_near_col(*follow_col, 1);
    if ( newlink < 0 )
    {
      if ( more_text )
      {
        Newline += display_lines;
      }
      else if ( *old_c != real_c )
      {
        *old_c = real_c;
        v4 = gettext("There are no links below this line of the document.");
        HTUserMsg(v4);
      }
    }
    else
    {
      set_curdoc_link(newlink);
    }
  }
}

//----- (08080608) --------------------------------------------------------
void __cdecl handle_LYK_DOWN_TWO(int *old_c, int real_c)
{
  handle_LYK_DOWN_xxx(old_c, real_c, 2);
}

//----- (0808062A) --------------------------------------------------------
int __cdecl handle_LYK_DWIMEDIT(int *cmd, int *old_c, int real_c)
{
  char *v3; // eax
  char *v4; // eax

  if ( nlinks > 0 && links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 )
  {
    *cmd = 86;
    return 2;
  }
  else if ( nlinks > 0 && links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 1 )
  {
    v3 = gettext("This field cannot be (e)dited with an external editor.");
    HTUserMsg(v3);
    return 1;
  }
  else if ( no_editor )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v4 = gettext("External editing is currently disabled.");
      HTUserMsg(v4);
    }
    return 1;
  }
  else
  {
    return 0;
  }
}

//----- (08080728) --------------------------------------------------------
int __cdecl handle_LYK_ECGOTO(int *ch_0, char *user_input_buffer, char **old_user_input, int *old_c, int real_c)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax

  if ( !no_goto || LYValidate )
  {
    if ( LYIsUIPage3(curdoc.address, UIP_DIRED_MENU_0, 1)
      || LYIsUIPage3(curdoc.address, UIP_PERMIT_OPTIONS_0, 1)
      || LYIsUIPage3(curdoc.address, UIP_UPLOAD_OPTIONS_0, 1) )
    {
      if ( *old_c != real_c )
      {
        *old_c = real_c;
        v6 = gettext("You cannot edit File Management URLs");
        HTUserMsg(v6);
      }
      return 0;
    }
    else
    {
      HTSACopy(old_user_input, user_input_buffer);
      LYstrncpy(user_input_buffer, curdoc.address, 1023);
      if ( curdoc.post_data )
      {
        v7 = gettext("Current document has POST data.");
        HTAlert(v7);
      }
      mustshow[0] = 1;
      v8 = gettext("Edit this document's URL: ");
      statusline(v8);
      *ch_0 = LYgetstr(user_input_buffer, 0, 0x400u, RECALL_URL);
      if ( *ch_0 >= 0
        && *user_input_buffer
        && strcmp(user_input_buffer, curdoc.address)
        && (LYTrimAllStartfile(user_input_buffer), *user_input_buffer) )
      {
        return 2;
      }
      else
      {
        v9 = gettext("Cancelled!!!");
        HTInfoMsg(v9);
        LYstrncpy(user_input_buffer, *old_user_input, 1023);
        if ( *old_user_input )
        {
          free(*old_user_input);
          *old_user_input = 0;
        }
        return 0;
      }
    }
  }
  else
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("Goto a random URL is disallowed!");
      HTUserMsg(v5);
    }
    return 0;
  }
}

//----- (0808093F) --------------------------------------------------------
void __cdecl handle_LYK_EDIT(int *old_c, int real_c)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  stat dir_info; // [esp+20h] [ebp-68h] BYREF
  char *tp; // [esp+80h] [ebp-8h] BYREF
  char *cp; // [esp+84h] [ebp-4h]

  tp = 0;
  if ( no_editor )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v2 = gettext("The 'e'dit command is currently disabled.");
      HTUserMsg(v2);
    }
  }
  else if ( lynx_edit_mode && editor && *editor && !no_dired_support[0] )
  {
    if ( nlinks > 0 )
    {
      cp = links[curdoc.link].lname;
      if ( is_url(cp) == FILE_URL_TYPE_0 )
      {
        cp = HTnameOfFile_WWW(cp, 0, 1);
        HTSACopy(&tp, cp);
        if ( cp )
        {
          free(cp);
          cp = 0;
        }
        if ( stat64((int)tp, (int)&dir_info) == -1 )
        {
          v3 = gettext("System error - failure to get status.");
          HTAlert(v3);
        }
        else if ( (dir_info.st_mode & 0xF000) == 0x8000 )
        {
          HTSACopy(&tp, links[curdoc.link].lname);
          HTUnEscapeSome(tp, "/");
          if ( edit_current_file(tp, curdoc.link, Newline) )
          {
            if ( LYAutoUncacheDirLists > 0 )
              HTuncache_current_document();
            move_address(&newdoc, &curdoc);
            newdoc.line = curdoc.line;
            newdoc.link = curdoc.link;
            LYclear();
          }
        }
        if ( tp )
        {
          free(tp);
          tp = 0;
        }
      }
    }
  }
  else if ( editor && *editor )
  {
    if ( edit_current_file(newdoc.address, curdoc.link, Newline) )
    {
      HTuncache_current_document();
      LYforce_no_cache = 1;
      free_address(&curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
      LYclear();
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v4 = gettext("No editor is defined!");
    HTUserMsg(v4);
  }
}

//----- (08080BD3) --------------------------------------------------------
void __cdecl handle_LYK_DWIMHELP(const char **cshelpfile)
{
  if ( curdoc.link >= 0
    && curdoc.link < nlinks
    && links[curdoc.link].type == 1
    && !links[curdoc.link].l_form->disabled
    && (links[curdoc.link].l_form->type == 1
     || links[curdoc.link].l_form->type == 12
     || links[curdoc.link].l_form->type == 2
     || links[curdoc.link].l_form->type == 11
     || links[curdoc.link].l_form->type == 9) )
  {
    *cshelpfile = LYLineeditHelpURL();
  }
}

//----- (08080CD6) --------------------------------------------------------
void __cdecl handle_LYK_EDIT_TEXTAREA(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax

  if ( no_editor )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v3 = gettext("External editing is currently disabled.");
      HTUserMsg(v3);
    }
  }
  else if ( editor && *editor )
  {
    if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 )
    {
      stop_curses();
      HText_ExtEditForm((LinkInfo *)(68 * curdoc.link + 136026784));
      start_curses();
      *refresh_screen = 1;
    }
    else
    {
      v5 = gettext("Not in a TEXTAREA; cannot use external editor.");
      HTInfoMsg(v5);
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v4 = gettext("No editor is defined!");
    HTUserMsg(v4);
  }
}

//----- (08080DDD) --------------------------------------------------------
int __cdecl handle_LYK_ELGOTO(int *ch_0, char *user_input_buffer, char **old_user_input, int *old_c, int real_c)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  const char *src; // [esp+20h] [ebp-8h]
  const char *s2; // [esp+24h] [ebp-4h]

  if ( !no_goto || LYValidate )
  {
    if ( nlinks > 0
      && curdoc.link >= 0
      && (links[curdoc.link].type != 1
       || links[curdoc.link].l_form->type == 5
       || links[curdoc.link].l_form->type == 13
       || links[curdoc.link].l_form->type == 12) )
    {
      if ( links[curdoc.link].type != 1
        || links[curdoc.link].l_form->submit_action && *links[curdoc.link].l_form->submit_action )
      {
        if ( !strncasecomp(links[curdoc.link].lname, "LYNXDIRED:", 10)
          || LYIsUIPage3(curdoc.address, UIP_DIRED_MENU_0, 1)
          || LYIsUIPage3(curdoc.address, UIP_PERMIT_OPTIONS_0, 1)
          || LYIsUIPage3(curdoc.address, UIP_UPLOAD_OPTIONS_0, 1) )
        {
          if ( *old_c != real_c )
          {
            *old_c = real_c;
            v8 = gettext("You cannot edit File Management URLs");
            HTUserMsg(v8);
          }
          return 0;
        }
        else
        {
          HTSACopy(old_user_input, user_input_buffer);
          if ( links[curdoc.link].type == 1 )
            src = links[curdoc.link].l_form->submit_action;
          else
            src = links[curdoc.link].lname;
          LYstrncpy(user_input_buffer, src, 1023);
          mustshow[0] = 1;
          v9 = gettext("Edit the current link's URL: ");
          statusline(v9);
          *ch_0 = LYgetstr(user_input_buffer, 0, 0x400u, RECALL_URL);
          if ( *ch_0 >= 0
            && *user_input_buffer
            && (links[curdoc.link].type != 1 ? (s2 = links[curdoc.link].lname) : (s2 = links[curdoc.link].l_form->submit_action),
                strcmp(user_input_buffer, s2) && (LYTrimAllStartfile(user_input_buffer), *user_input_buffer)) )
          {
            return 2;
          }
          else
          {
            v10 = gettext("Cancelled!!!");
            HTInfoMsg(v10);
            LYstrncpy(user_input_buffer, *old_user_input, 1023);
            if ( *old_user_input )
            {
              free(*old_user_input);
              *old_user_input = 0;
            }
            return 0;
          }
        }
      }
      else
      {
        if ( *old_c != real_c )
        {
          *old_c = real_c;
          v7 = gettext("** Bad HTML!!  No form action defined. **");
          HTUserMsg(v7);
        }
        return 0;
      }
    }
    else
    {
      if ( *old_c != real_c )
      {
        *old_c = real_c;
        v6 = gettext("You are not on a form submission button or normal link.");
        HTUserMsg(v6);
      }
      return 0;
    }
  }
  else
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("Goto a random URL is disallowed!");
      HTUserMsg(v5);
    }
    return 0;
  }
}

//----- (080811EA) --------------------------------------------------------
void __cdecl handle_LYK_EXTERN_LINK(BOOLEAN *refresh_screen)
{
  if ( nlinks > 0 )
  {
    if ( links[curdoc.link].lname )
    {
      run_external(links[curdoc.link].lname, 0);
      *refresh_screen = 1;
    }
  }
}

//----- (0808123F) --------------------------------------------------------
void __cdecl handle_LYK_EXTERN_PAGE(BOOLEAN *refresh_screen)
{
  if ( curdoc.address )
  {
    run_external(curdoc.address, 0);
    *refresh_screen = 1;
  }
}

//----- (0808126B) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_FASTBACKW_LINK(int *cmd, int *old_c, int real_c)
{
  char *v3; // eax
  char *thisname_0; // [esp+18h] [ebp-20h]
  int thisgroup_0; // [esp+1Ch] [ebp-1Ch]
  char *thisname; // [esp+20h] [ebp-18h]
  int thisgroup; // [esp+24h] [ebp-14h]
  BOOLEAN code; // [esp+28h] [ebp-10h]
  int res; // [esp+2Ch] [ebp-Ch]
  int nextlink; // [esp+30h] [ebp-8h]
  int samepage; // [esp+34h] [ebp-4h]

  samepage = 0;
  nextlink = curdoc.link;
  code = 0;
  if ( nlinks > 1 )
  {
    if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 )
    {
      thisgroup = links[curdoc.link].l_form->number;
      thisname = links[curdoc.link].l_form->name;
      if ( curdoc.link <= 0
        || links[0].type == 1
        && links[0].l_form->type == 9
        && links[0].l_form->number == thisgroup
        && sametext(links[0].l_form->name, thisname) )
      {
        if ( more_text
          || Newline != 1
          || links[0].type != 1
          || links[0].l_form->type != 9
          || links[0].l_form->number != thisgroup
          || !sametext(links[0].l_form->name, thisname)
          || links[nlinks - 1].type == 1
          && links[nlinks - 1].l_form->type == 9
          && links[nlinks - 1].l_form->number == thisgroup
          && sametext(links[nlinks - 1].l_form->name, thisname) )
        {
          if ( !more_text && Newline == 1 && curdoc.link > 0 )
          {
            nextlink = 0;
            samepage = 1;
          }
        }
        else
        {
          nextlink = nlinks - 1;
          samepage = 1;
        }
      }
      else
      {
        do
          --nextlink;
        while ( links[nextlink].type == 1
             && links[nextlink].l_form->type == 9
             && links[nextlink].l_form->number == thisgroup
             && sametext(links[nextlink].l_form->name, thisname) );
        samepage = 1;
      }
    }
    else if ( curdoc.link <= 0 )
    {
      if ( !more_text && Newline == 1 )
      {
        nextlink = nlinks - 1;
        samepage = 1;
      }
    }
    else
    {
      nextlink = curdoc.link - 1;
      samepage = 1;
    }
  }
  if ( samepage )
  {
    if ( nextlink > 0 && links[nextlink].type == 1 && links[nextlink].l_form->type == 9 )
    {
      thisgroup_0 = links[nextlink].l_form->number;
      thisname_0 = links[nextlink].l_form->name;
      if ( links[0].type == 1
        && links[0].l_form->type == 9
        && links[0].l_form->number == thisgroup_0
        && sametext(links[0].l_form->name, thisname_0) )
      {
        nextlink = 0;
      }
      else
      {
        while ( nextlink > 1
             && links[nextlink - 1].type == 1
             && links[nextlink - 1].l_form->type == 9
             && links[nextlink - 1].l_form->number == thisgroup_0
             && sametext(links[nextlink - 1].l_form->name, thisname_0) )
          --nextlink;
      }
    }
    set_curdoc_link(nextlink);
  }
  else if ( Newline > 1 && (res = HTGetLinkOrFieldStart(curdoc.link, &Newline, &newdoc.link, -1, 1)) != 0 )
  {
    if ( res == 16 )
    {
      if ( nlinks > 0 )
        curdoc.link = 0;
      *cmd = 26;
      return 1;
    }
    else
    {
      ++Newline;
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v3 = gettext("There are no links above this line of the document.");
    HTInfoMsg(v3);
  }
  return code;
}

//----- (08081765) --------------------------------------------------------
void __cdecl handle_LYK_FASTFORW_LINK(int *old_c, int real_c)
{
  char *v2; // eax
  char *thisname; // [esp+18h] [ebp-10h]
  int thisgroup; // [esp+1Ch] [ebp-Ch]
  int nextlink; // [esp+20h] [ebp-8h]
  int samepage; // [esp+24h] [ebp-4h]

  samepage = 0;
  nextlink = curdoc.link;
  if ( nlinks > 1 )
  {
    if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 )
    {
      thisgroup = links[curdoc.link].l_form->number;
      thisname = links[curdoc.link].l_form->name;
      if ( curdoc.link >= nlinks - 1
        || links[nlinks - 1].type == 1
        && links[nlinks - 1].l_form->type == 9
        && links[nlinks - 1].l_form->number == thisgroup
        && sametext(links[nlinks - 1].l_form->name, thisname) )
      {
        if ( !more_text && Newline == 1 && curdoc.link > 0 )
        {
          nextlink = 0;
          samepage = 1;
        }
      }
      else
      {
        do
          ++nextlink;
        while ( links[nextlink].type == 1
             && links[nextlink].l_form->type == 9
             && links[nextlink].l_form->number == thisgroup
             && sametext(links[nextlink].l_form->name, thisname) );
        samepage = 1;
      }
    }
    else if ( curdoc.link >= nlinks - 1 )
    {
      if ( !more_text && Newline == 1 && curdoc.link > 0 )
      {
        nextlink = 0;
        samepage = 1;
      }
    }
    else
    {
      nextlink = curdoc.link + 1;
      samepage = 1;
    }
  }
  if ( samepage )
  {
    set_curdoc_link(nextlink);
  }
  else if ( !more_text && Newline == 1 && curdoc.link == nlinks - 1 )
  {
    set_curdoc_link(0);
  }
  else if ( more_text && HTGetLinkOrFieldStart(curdoc.link, &Newline, &newdoc.link, 1, 1) )
  {
    ++Newline;
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v2 = gettext("There are no links below this line of the document.");
    HTInfoMsg(v2);
  }
}

//----- (08081A5A) --------------------------------------------------------
void handle_LYK_FIRST_LINK()
{
  int i; // [esp+14h] [ebp-4h]

  i = curdoc.link;
  do
    --i;
  while ( i >= 0 && links[i].ly == links[curdoc.link].ly );
  set_curdoc_link(i + 1);
}

//----- (08081AAE) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_GOTO(
        int *ch_0,
        char *user_input_buffer,
        char **old_user_input,
        RecallType *recall,
        int *URLTotal,
        int *URLNum,
        BOOLEAN *FirstURLRecall,
        int *old_c,
        int real_c)
{
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  int v14; // [esp+14h] [ebp-4h]

  if ( !no_goto || LYValidate )
  {
    HTSACopy(old_user_input, user_input_buffer);
    if ( !goto_buffer )
      *user_input_buffer = 0;
    if ( Goto_URLs )
      v14 = HTList_count(Goto_URLs);
    else
      v14 = 0;
    *URLTotal = v14;
    if ( goto_buffer && *user_input_buffer )
    {
      *recall = *URLTotal > 1;
      *URLNum = 0;
      *FirstURLRecall = 0;
    }
    else
    {
      *recall = *URLTotal > 0;
      *URLNum = *URLTotal;
      *FirstURLRecall = 1;
    }
    mustshow[0] = 1;
    v10 = gettext("URL to open: ");
    statusline(v10);
    *ch_0 = LYgetstr(user_input_buffer, 0, 0x400u, *recall);
    if ( *ch_0 >= 0 )
    {
      return 1;
    }
    else
    {
      LYstrncpy(user_input_buffer, *old_user_input, 1023);
      if ( *old_user_input )
      {
        free(*old_user_input);
        *old_user_input = 0;
      }
      v11 = gettext("Cancelled!!!");
      HTInfoMsg(v11);
      return 0;
    }
  }
  else
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v9 = gettext("Goto a random URL is disallowed!");
      HTUserMsg(v9);
    }
    return 0;
  }
}

//----- (08081C4F) --------------------------------------------------------
void __cdecl handle_LYK_GROW_TEXTAREA(BOOLEAN *refresh_screen)
{
  char *v1; // eax

  if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 )
  {
    HText_ExpandTextarea((LinkInfo *)(68 * curdoc.link + 136026784), 5);
    *refresh_screen = 1;
  }
  else
  {
    v1 = gettext("Not in a TEXTAREA; cannot use command.");
    HTInfoMsg(v1);
  }
}

//----- (08081CD3) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_HEAD(int *cmd)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v12; // [esp+Ch] [ebp-1Ch]
  char *address; // [esp+14h] [ebp-14h]
  int c; // [esp+24h] [ebp-4h]
  int ca; // [esp+24h] [ebp-4h]

  if ( nlinks <= 0
    || links[curdoc.link].type == 1
    && links[curdoc.link].l_form->type != 5
    && links[curdoc.link].l_form->type != 13
    && links[curdoc.link].l_form->type != 12 )
  {
    if ( curdoc.post_data )
    {
      if ( curdoc.safe != 1 )
      {
        v8 = gettext("Document from POST action, HEAD may not be understood.  Proceed?");
        if ( !HTConfirm(v8) )
          goto LABEL_45;
      }
    }
    if ( nlinks <= 0 )
    {
      ca = 68;
    }
    else
    {
      mustshow[0] = 1;
      v10 = gettext("Send HEAD request for D)ocument, or C)ancel? (d,c): ");
      statusline(v10);
      ca = LYgetch_single();
    }
    if ( ca != 68 )
      return 0;
    if ( strncasecomp(curdoc.address, "LYNXIMGMAP:", 11) )
      address = curdoc.address;
    else
      address = curdoc.address + 11;
    if ( LYCanDoHEAD(address) != 1 )
      goto LABEL_11;
    HEAD_request = 1;
    LYforce_no_cache = 1;
    HTSACopy(&newdoc.title, curdoc.title);
    if ( (unsigned __int8)HTLoadedDocumentIsHEAD() )
      goto LABEL_17;
    goto LABEL_55;
  }
  mustshow[0] = 1;
  v1 = gettext("Send HEAD request for D)ocument or L)ink, or C)ancel? (d,l,c): ");
  statusline(v1);
  c = LYgetch_single();
  if ( c == 68 )
  {
    if ( strncasecomp(curdoc.address, "LYNXIMGMAP:", 11) )
      v12 = curdoc.address;
    else
      v12 = curdoc.address + 11;
    if ( LYCanDoHEAD(v12) != 1 )
    {
LABEL_11:
      v2 = gettext("Sorry, the document is not an http URL.");
      HTUserMsg(v2);
      return 0;
    }
    if ( curdoc.post_data )
    {
      if ( curdoc.safe != 1 )
      {
        v3 = gettext("Document from POST action, HEAD may not be understood.  Proceed?");
        if ( !HTConfirm(v3) )
        {
LABEL_45:
          v9 = gettext("Cancelled!!!");
          HTInfoMsg(v9);
          return 0;
        }
      }
    }
    HEAD_request = 1;
    LYforce_no_cache = 1;
    HTSACopy(&newdoc.title, curdoc.title);
    if ( (unsigned __int8)HTLoadedDocumentIsHEAD() )
    {
LABEL_17:
      HText_setNoCache(HTMainText);
      free_address(&curdoc);
      return 0;
    }
LABEL_55:
    HTSACat(&newdoc.title, " - HEAD");
    return 0;
  }
  if ( c != 76 )
    return 0;
  if ( links[curdoc.link].type != 1
    && strncmp(links[curdoc.link].lname, "http", 4u)
    && strncmp(links[curdoc.link].lname, "LYNXIMGMAP:http", 0xFu)
    && LYCanDoHEAD(links[curdoc.link].lname) != 1
    && (links[curdoc.link].type != 6 || !curdoc.address || strncmp(curdoc.address, "http", 4u)) )
  {
    v4 = gettext("Sorry, the link is not an http URL.");
    HTUserMsg(v4);
    return 0;
  }
  if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->disabled )
  {
    v5 = gettext("Sorry, the ACTION for this form is disabled.");
    HTUserMsg(v5);
    return 0;
  }
  if ( links[curdoc.link].type == 1
    && links[curdoc.link].l_form->submit_action
    && (*links[curdoc.link].l_form->submit_action != 108 && *links[curdoc.link].l_form->submit_action != 76
     || strncasecomp(links[curdoc.link].l_form->submit_action, "lynxcgi:", 8))
    && strncmp(links[curdoc.link].l_form->submit_action, "http", 4u) )
  {
    v6 = gettext("Sorry, the ACTION for this form is not an http URL.");
    HTUserMsg(v6);
    return 0;
  }
  if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->submit_method == 2 )
  {
    v7 = gettext("Form submit action is POST, HEAD may not be understood.  Proceed?");
    if ( !HTConfirm(v7) )
      goto LABEL_45;
  }
  HEAD_request = 1;
  LYforce_no_cache = 1;
  *cmd = 39;
  return 1;
}

//----- (080822BE) --------------------------------------------------------
void __cdecl handle_LYK_HELP(const char **cshelpfile)
{
  char *v1; // eax
  char *my_value; // [esp+24h] [ebp-4h] BYREF

  my_value = 0;
  if ( !*cshelpfile )
    *cshelpfile = helpfile;
  HTSACopy(&my_value, *cshelpfile);
  LYEnsureAbsoluteURL(&my_value, *cshelpfile, 0);
  if ( strcmp(curdoc.address, my_value) )
  {
    set_address(&newdoc, my_value);
    v1 = gettext("Help Screen");
    HTSACopy(&newdoc.title, v1);
    LYFreePostData(&newdoc);
    if ( newdoc.bookmark )
    {
      free(newdoc.bookmark);
      newdoc.bookmark = 0;
    }
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.internal_link = 0;
  }
  if ( my_value )
  {
    free(my_value);
    my_value = 0;
  }
  *cshelpfile = 0;
}

//----- (080823BC) --------------------------------------------------------
void handle_LYK_HISTORICAL()
{
  char *v0; // eax
  const char *Msg; // [esp+10h] [ebp-8h]
  const char *v2; // [esp+14h] [ebp-4h]

  if ( !(unsigned __int8)HTcan_reparse_document() )
  {
    if ( !curdoc.post_data || curdoc.safe == 1 || confirm_post_resub(curdoc.address, 0, 0, 0) )
    {
      HText_setNoCache(HTMainText);
      move_address(&newdoc, &curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
    }
    else
    {
      v0 = gettext("Document will not be reloaded!");
      HTInfoMsg(v0);
    }
  }
  historical_comments = historical_comments == 0;
  if ( minimal_comments )
  {
    if ( historical_comments )
      Msg = gettext("Historical comment parsing ON (Minimal is overridden)!");
    else
      Msg = gettext("Historical comment parsing OFF (Minimal is in effect)!");
    HTAlert(Msg);
  }
  else
  {
    if ( historical_comments )
      v2 = gettext("Historical comment parsing ON (Valid is overridden)!");
    else
      v2 = gettext("Historical comment parsing OFF (Valid is in effect)!");
    HTAlert(v2);
  }
  reparse_document();
}

//----- (080824E8) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_HISTORY(BOOLEAN ForcePush)
{
  char *v1; // eax

  if ( !curdoc.title || LYIsUIPage3(curdoc.address, UIP_HISTORY_0, 1) )
    return 0;
  if ( WWW_TraceFlag[0] && !LYUseTraceLog && LYCursesON[0] )
  {
    LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
    LYrefresh();
  }
  LYpush(&curdoc, ForcePush);
  if ( showhistory(&newdoc.address) >= 0 )
  {
    LYRegisterUIPage(newdoc.address, UIP_HISTORY_0);
    v1 = gettext("History Page");
    HTSACopy(&newdoc.title, v1);
    LYFreePostData(&newdoc);
    if ( newdoc.bookmark )
    {
      free(newdoc.bookmark);
      newdoc.bookmark = 0;
    }
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.internal_link = 0;
    newdoc.link = 1;
    free_address(&curdoc);
    if ( LYValidate || check_realm )
      LYPermitURL = 1;
    return 1;
  }
  else
  {
    LYpop(&curdoc);
    return 1;
  }
}

//----- (0808266C) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_IMAGE_TOGGLE(int *cmd)
{
  const char *Msg; // [esp+4h] [ebp-4h]

  clickable_images = clickable_images == 0;
  if ( clickable_images )
    Msg = gettext("Links will be included for all images!  Reloading...");
  else
    Msg = gettext("Standard image handling restored!  Reloading...");
  HTUserMsg(Msg);
  return reparse_or_reload(cmd);
}

//----- (080826C6) --------------------------------------------------------
void __cdecl handle_LYK_INDEX(int *old_c, int real_c)
{
  char *v2; // eax
  char *v3; // eax

  if ( strcmp(curdoc.address, indexfile) )
  {
    if ( *indexfile )
    {
      set_address(&newdoc, indexfile);
      v3 = gettext("System Index");
      HTSACopy(&newdoc.title, v3);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
    }
    else if ( *old_c != real_c )
    {
      *old_c = real_c;
      v2 = gettext("No index is currently available.");
      HTUserMsg(v2);
    }
  }
}

//----- (08082797) --------------------------------------------------------
void __cdecl handle_LYK_INDEX_SEARCH(BOOLEAN *force_load, BOOLEAN ForcePush, int *old_c, int real_c)
{
  const char *v4; // ebx
  char *v5; // eax
  char *v6; // eax
  int len; // [esp+10h] [ebp-18h]
  const char *src; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  const char *str; // [esp+1Ch] [ebp-Ch]

  if ( is_www_index )
  {
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    if ( do_www_search(&newdoc) == 1 )
    {
      if ( WWW_TraceFlag[0] && !LYUseTraceLog && LYCursesON[0] )
      {
        LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
        LYrefresh();
      }
      LYpush(&curdoc, ForcePush);
      copy_address(&curdoc, &newdoc);
      if ( curdoc.post_data )
        len = curdoc.post_data->len;
      else
        len = 0;
      if ( curdoc.post_data )
        src = curdoc.post_data->str;
      else
        src = 0;
      HTSABCopy(&newdoc.post_data, src, len);
      HTSACopy(&newdoc.post_content_type, curdoc.post_content_type);
      newdoc.internal_link = 0;
      curdoc.line = -1;
      Newline = 0;
    }
    else if ( use_this_url_instead )
    {
      v4 = use_this_url_instead;
      v5 = gettext("Using %s");
      HTUserMsg2(v5, v4);
      HTSACopy(&newdoc.title, "A URL specified by redirection");
      set_address(&newdoc, use_this_url_instead);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      if ( use_this_url_instead )
      {
        free(use_this_url_instead);
        use_this_url_instead = 0;
      }
      *force_load = 1;
    }
    else
    {
      copy_address(&newdoc, &curdoc);
      if ( curdoc.post_data )
        v9 = curdoc.post_data->len;
      else
        v9 = 0;
      if ( curdoc.post_data )
        str = curdoc.post_data->str;
      else
        str = 0;
      HTSABCopy(&newdoc.post_data, str, v9);
      HTSACopy(&newdoc.post_content_type, curdoc.post_content_type);
      HTSACopy(&newdoc.bookmark, curdoc.bookmark);
      newdoc.isHEAD = curdoc.isHEAD;
      newdoc.safe = curdoc.safe;
      newdoc.internal_link = curdoc.internal_link;
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v6 = gettext("Not a searchable indexed document -- press '/' to search for a text string");
    HTUserMsg(v6);
  }
}

//----- (08082A81) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_INFO(int *cmd)
{
  char *v1; // eax

  if ( LYIsUIPage3(curdoc.address, UIP_SHOWINFO_0, 1) )
  {
    *cmd = 37;
    return 1;
  }
  else
  {
    if ( do_change_link() != -1 && LYShowInfo(&curdoc, &newdoc, owner_address) >= 0 )
    {
      LYRegisterUIPage(newdoc.address, UIP_SHOWINFO_0);
      v1 = gettext("Information about the current document");
      HTSACopy(&newdoc.title, v1);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      LYforce_no_cache = 1;
      if ( LYValidate || check_realm )
        LYPermitURL = 1;
    }
    return 0;
  }
}

//----- (08082B8E) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_INLINE_TOGGLE(int *cmd)
{
  const char *Msg; // [esp+4h] [ebp-4h]

  pseudo_inline_alts = pseudo_inline_alts == 0;
  if ( pseudo_inline_alts )
    Msg = gettext("Pseudo_ALTs will be inserted for inlines without ALT strings!  Reloading...");
  else
    Msg = gettext("Inlines without an ALT string specified will be ignored!  Reloading...");
  HTUserMsg(Msg);
  return reparse_or_reload(cmd);
}

//----- (08082BE8) --------------------------------------------------------
void __cdecl handle_LYK_INSERT_FILE(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax

  if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 )
  {
    if ( no_file_url || no_goto_file || !HTDirAccess || HTDirAccess == 1 )
    {
      if ( *old_c != real_c )
      {
        *old_c = real_c;
        if ( no_goto_file )
        {
          v3 = gettext("You are not allowed to goto \"%s\" URLs");
          HTUserMsg2(v3, "file:");
        }
        else
        {
          v4 = gettext("Access to local files denied.");
          HTUserMsg(v4);
        }
        v5 = gettext("File insert cancelled!!!");
        HTInfoMsg(v5);
      }
    }
    else
    {
      HText_InsertFile((LinkInfo *)(68 * curdoc.link + 136026784));
      *refresh_screen = 1;
    }
  }
  else
  {
    v6 = gettext("Not in a TEXTAREA; cannot use command.");
    HTInfoMsg(v6);
  }
}

//----- (08082D01) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_JUMP(
        int c,
        char *user_input_buffer,
        char **old_user_input,
        RecallType *recall,
        BOOLEAN *FirstURLRecall,
        int *URLNum,
        int *URLTotal,
        int *ch_0,
        int *old_c,
        int real_c)
{
  char *v10; // eax
  const char *ret; // [esp+24h] [ebp-4h]
  char *reta; // [esp+24h] [ebp-4h]

  if ( !no_jump && JThead )
  {
    LYJumpFileURL = 1;
    ret = LYJump(c);
    if ( ret )
    {
      reta = HTParse(ret, startfile, 31);
      if ( !LYTrimStartfile(reta) )
        LYRemoveBlanks(user_input_buffer);
      set_address(&newdoc, reta);
      HTSACopy(&lynxjumpfile, reta);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      if ( reta )
        free(reta);
      LYUserSpecifiedURL = 1;
    }
    else
    {
      LYJumpFileURL = 0;
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    if ( no_jump )
      v10 = gettext("Jumping to a shortcut URL is disallowed!");
    else
      v10 = gettext("No jump file is currently available.");
    HTUserMsg(v10);
  }
  return 0;
}

//----- (08082E5C) --------------------------------------------------------
void __cdecl handle_LYK_KEYMAP(BOOLEAN *vi_keys_flag, BOOLEAN *emacs_keys_flag, int *old_c, int real_c)
{
  char *v4; // eax

  if ( *old_c != real_c )
  {
    *old_c = real_c;
    set_address(&newdoc, "LYNXKEYMAP:");
    v4 = gettext("Current Key Map");
    HTSACopy(&newdoc.title, v4);
    LYFreePostData(&newdoc);
    if ( newdoc.bookmark )
    {
      free(newdoc.bookmark);
      newdoc.bookmark = 0;
    }
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.internal_link = 0;
    if ( *vi_keys_flag != vi_keys || *emacs_keys_flag != emacs_keys )
    {
      LYforce_no_cache = 1;
      *vi_keys_flag = vi_keys;
      *emacs_keys_flag = emacs_keys;
    }
    if ( !no_dired_support[0] )
      prev_lynx_edit_mode = lynx_edit_mode;
    LYforce_no_cache = 1;
  }
}

//----- (08082F4A) --------------------------------------------------------
void handle_LYK_LAST_LINK()
{
  int i; // [esp+14h] [ebp-4h]

  i = curdoc.link;
  do
    ++i;
  while ( i < nlinks && links[i].ly == links[curdoc.link].ly );
  set_curdoc_link(i - 1);
}

//----- (08082FA2) --------------------------------------------------------
void handle_LYK_LEFT_LINK()
{
  if ( curdoc.link > 0 && links[curdoc.link].ly == links[curdoc.link - 1].ly )
    set_curdoc_link(curdoc.link - 1);
}

//----- (08082FF4) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_LIST(int *cmd)
{
  char *v1; // eax
  const char *s2; // [esp+Ch] [ebp-Ch]
  const char *s1; // [esp+10h] [ebp-8h]

  s2 = gettext("List Page");
  if ( curdoc.title )
    s1 = curdoc.title;
  else
    s1 = &byte_81534E7;
  if ( !strcmp(s1, s2) && LYIsUIPage3(curdoc.address, UIP_LIST_PAGE_0, 1) )
  {
    *cmd = 37;
    return 1;
  }
  else if ( showlist(&newdoc, 1) >= 0 )
  {
    v1 = gettext("List Page");
    HTSACopy(&newdoc.title, v1);
    if ( LYValidate || check_realm )
    {
      LYPermitURL = 1;
      HTSACopy(&lynxlistfile, newdoc.address);
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

//----- (080830DF) --------------------------------------------------------
void __cdecl handle_LYK_MAIN_MENU(int *old_c, int real_c)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  if ( !strcmp(curdoc.address, homepage) )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v4 = gettext("You are already at main screen!");
      HTUserMsg(v4);
    }
  }
  else
  {
    v2 = gettext("Do you really want to go to the Main screen?");
    if ( HTConfirmDefault(v2, 0) == 1 )
    {
      set_address(&newdoc, homepage);
      v3 = gettext("Entry into main screen");
      HTSACopy(&newdoc.title, v3);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      LYhighlight(0, curdoc.link, prev_target);
      if ( lynx_edit_mode )
      {
        if ( LYAutoUncacheDirLists > 1 )
          HTuncache_current_document();
      }
    }
  }
}

//----- (080831FC) --------------------------------------------------------
void handle_LYK_MINIMAL()
{
  char *v0; // eax
  const char *Msg; // [esp+10h] [ebp-8h]
  const char *v2; // [esp+14h] [ebp-4h]

  if ( !historical_comments && !(unsigned __int8)HTcan_reparse_document() )
  {
    if ( !curdoc.post_data || curdoc.safe == 1 || confirm_post_resub(curdoc.address, 0, 0, 0) )
    {
      HText_setNoCache(HTMainText);
      move_address(&newdoc, &curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
    }
    else
    {
      v0 = gettext("Document will not be reloaded!");
      HTInfoMsg(v0);
    }
  }
  minimal_comments = minimal_comments == 0;
  if ( historical_comments )
  {
    if ( minimal_comments )
      v2 = gettext("Minimal comment parsing ON (but Historical is in effect)!");
    else
      v2 = gettext("Minimal comment parsing OFF (Historical is in effect)!");
    HTAlert(v2);
  }
  else
  {
    if ( minimal_comments )
      Msg = gettext("Minimal comment parsing ON (and in effect)!");
    else
      Msg = gettext("Minimal comment parsing OFF (Valid is in effect)!");
    HTAlert(Msg);
  }
  reparse_document();
}

//----- (08083337) --------------------------------------------------------
void __cdecl handle_LYK_MODIFY(BOOLEAN *refresh_screen)
{
  int ret; // [esp+14h] [ebp-4h]

  if ( lynx_edit_mode && nlinks > 0 && !no_dired_support[0] )
  {
    ret = local_modify(&curdoc, &newdoc.address);
    if ( ret == -99 )
    {
      *refresh_screen = 1;
    }
    else if ( ret )
    {
      if ( LYAutoUncacheDirLists > 0 )
        HTuncache_current_document();
      move_address(&newdoc, &curdoc);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
      LYclear();
    }
  }
}

//----- (08083414) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_NESTED_TABLES(int *cmd)
{
  const char *Msg; // [esp+4h] [ebp-4h]

  nested_tables = nested_tables == 0;
  if ( nested_tables )
    Msg = gettext("Parsing nested-tables toggled ON!  Reloading...");
  else
    Msg = gettext("Parsing nested-tables toggled OFF!  Reloading...");
  HTUserMsg(Msg);
  return reparse_or_reload(cmd);
}

//----- (0808346E) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_OPTIONS(int *cmd, BOOLEAN *refresh_screen)
{
  char *v2; // eax
  char *src; // [esp+1Ch] [ebp-4Ch]
  char *v5; // [esp+20h] [ebp-48h]
  char *v6; // [esp+24h] [ebp-44h]
  char *s2; // [esp+28h] [ebp-40h]
  char *v8; // [esp+2Ch] [ebp-3Ch]
  char *v9; // [esp+30h] [ebp-38h]
  char *v10; // [esp+34h] [ebp-34h]
  char *v11; // [esp+38h] [ebp-30h]
  char *v12; // [esp+3Ch] [ebp-2Ch]
  int v13; // [esp+40h] [ebp-28h]
  char *CurrentNegoCharset; // [esp+48h] [ebp-20h] BYREF
  char *CurrentNegoLanguage; // [esp+4Ch] [ebp-1Ch] BYREF
  char *CurrentUserAgent; // [esp+50h] [ebp-18h] BYREF
  int HTfileSortMethod_flag; // [esp+54h] [ebp-14h]
  int CurrentCharSet_flag; // [esp+58h] [ebp-10h]
  int CurrentAssumeCharSet_flag; // [esp+5Ch] [ebp-Ch]
  BOOLEAN canreparse_post; // [esp+61h] [ebp-7h]
  BOOLEAN user_mode_flag; // [esp+62h] [ebp-6h]
  BOOLEAN show_dotfiles_flag; // [esp+63h] [ebp-5h]
  BOOLEAN keypad_mode_flag; // [esp+64h] [ebp-4h]
  BOOLEAN verbose_img_flag; // [esp+65h] [ebp-3h]
  BOOLEAN LYSelectPopups_flag; // [esp+66h] [ebp-2h]
  BOOLEAN LYUseDefaultRawMode_flag; // [esp+67h] [ebp-1h]

  if ( LYUseFormsOptions )
  {
    if ( LYIsUIPage3(curdoc.address, UIP_OPTIONS_MENU_0, 1) )
    {
      *cmd = 37;
      return 1;
    }
    else
    {
      set_address(&newdoc, "LYNXOPTIONS:/");
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      LYforce_no_cache = 1;
      if ( LYValidate || check_realm )
        LYPermitURL = 1;
      return 0;
    }
  }
  else
  {
    LYUseDefaultRawMode_flag = LYUseDefaultRawMode;
    LYSelectPopups_flag = LYSelectPopups;
    verbose_img_flag = verbose_img;
    keypad_mode_flag = keypad_mode;
    show_dotfiles_flag = show_dotfiles;
    user_mode_flag = user_mode;
    CurrentAssumeCharSet_flag = UCLYhndl_for_unspec;
    CurrentCharSet_flag = current_char_set;
    HTfileSortMethod_flag = HTfileSortMethod;
    CurrentUserAgent = 0;
    CurrentNegoLanguage = 0;
    CurrentNegoCharset = 0;
    if ( LYUserAgent )
      src = LYUserAgent;
    else
      src = (char *)&byte_81534E7;
    HTSACopy(&CurrentUserAgent, src);
    if ( language )
      v5 = language;
    else
      v5 = (char *)&byte_81534E7;
    HTSACopy(&CurrentNegoLanguage, v5);
    if ( pref_charset )
      v6 = pref_charset;
    else
      v6 = (char *)&byte_81534E7;
    HTSACopy(&CurrentNegoCharset, v6);
    LYoptions();
    if ( keypad_mode_flag == keypad_mode
      && (user_mode_flag == user_mode || user_mode_flag && user_mode)
      && (HTfileSortMethod_flag == HTfileSortMethod && show_dotfiles_flag == show_dotfiles
       || (*curdoc.address != 102 && *curdoc.address != 70 || strncasecomp(curdoc.address, "file:", 5))
       && strncasecomp(curdoc.address, "ftp:", 4))
      && CurrentCharSet_flag == current_char_set
      && CurrentAssumeCharSet_flag == UCLYhndl_for_unspec
      && verbose_img_flag == verbose_img
      && LYUseDefaultRawMode_flag == LYUseDefaultRawMode
      && LYSelectPopups_flag == LYSelectPopups )
    {
      s2 = LYUserAgent ? LYUserAgent : (char *)&byte_81534E7;
      if ( !strcmp(CurrentUserAgent, s2) )
      {
        v8 = language ? language : (char *)&byte_81534E7;
        if ( !strcmp(CurrentNegoLanguage, v8) )
        {
          v9 = pref_charset ? pref_charset : (char *)&byte_81534E7;
          if ( !strcmp(CurrentNegoCharset, v9) )
            goto LABEL_90;
        }
      }
      if ( strncmp(curdoc.address, "http", 4u)
        && (*curdoc.address != 108 && *curdoc.address != 76 || strncasecomp(curdoc.address, "lynxcgi:", 8)) )
      {
        goto LABEL_90;
      }
    }
    canreparse_post = 0;
    if ( curdoc.post_data )
    {
      if ( curdoc.safe != 1 )
      {
        canreparse_post = HTcan_reparse_document();
        if ( !canreparse_post && !confirm_post_resub(curdoc.address, curdoc.title, 2, 1) )
        {
          v2 = gettext("Document will not be reloaded!");
          HTInfoMsg(v2);
LABEL_90:
          if ( CurrentUserAgent )
          {
            free(CurrentUserAgent);
            CurrentUserAgent = 0;
          }
          if ( CurrentNegoLanguage )
          {
            free(CurrentNegoLanguage);
            CurrentNegoLanguage = 0;
          }
          if ( CurrentNegoCharset )
          {
            free(CurrentNegoCharset);
            CurrentNegoCharset = 0;
          }
          *refresh_screen = 1;
          return 0;
        }
      }
    }
    copy_address(&newdoc, &curdoc);
    if ( LYUserAgent )
      v10 = LYUserAgent;
    else
      v10 = (char *)&byte_81534E7;
    if ( strcmp(CurrentUserAgent, v10)
      || (!language ? (v11 = (char *)&byte_81534E7) : (v11 = language),
          strcmp(CurrentNegoLanguage, v11)
       || (!pref_charset ? (v12 = (char *)&byte_81534E7) : (v12 = pref_charset), strcmp(CurrentNegoCharset, v12))) )
    {
      if ( !strncmp(curdoc.address, "http", 4u)
        || ((*curdoc.address == 108 || *curdoc.address == 76) && !strncasecomp(curdoc.address, "lynxcgi:", 8) ? (v13 = 0) : (v13 = 1),
            !v13) )
      {
        reloading[0] = 1;
      }
    }
    if ( HTisDocumentSource() )
      srcmode_for_next_retrieval(1);
    if ( reloading[0] || !reparse_document() )
    {
      if ( !canreparse_post || confirm_post_resub(curdoc.address, curdoc.title, 2, 1) )
      {
        HEAD_request = HTLoadedDocumentIsHEAD();
        HText_setNoCache(HTMainText);
        newdoc.line = curdoc.line;
        newdoc.link = curdoc.link;
        LYforce_no_cache = 1;
        free_address(&curdoc);
        goto LABEL_90;
      }
      if ( HTisDocumentSource() )
        srcmode_for_next_retrieval(0);
      if ( CurrentUserAgent )
      {
        free(CurrentUserAgent);
        CurrentUserAgent = 0;
      }
      if ( CurrentNegoLanguage )
      {
        free(CurrentNegoLanguage);
        CurrentNegoLanguage = 0;
      }
      if ( CurrentNegoCharset )
      {
        free(CurrentNegoCharset);
        CurrentNegoCharset = 0;
      }
      return 0;
    }
    else
    {
      if ( CurrentUserAgent )
      {
        free(CurrentUserAgent);
        CurrentUserAgent = 0;
      }
      if ( CurrentNegoLanguage )
      {
        free(CurrentNegoLanguage);
        CurrentNegoLanguage = 0;
      }
      if ( CurrentNegoCharset )
      {
        free(CurrentNegoCharset);
        CurrentNegoCharset = 0;
      }
      return 0;
    }
  }
}

//----- (08083B4B) --------------------------------------------------------
void handle_NEXT_DOC()
{
  char *v0; // eax

  if ( LYhist_next(&curdoc, &newdoc) )
  {
    free_address(&curdoc);
  }
  else
  {
    v0 = gettext("No next document present");
    HTUserMsg(v0);
  }
}

//----- (08083B8D) --------------------------------------------------------
void __cdecl handle_LYK_NEXT_LINK(int c, int *old_c, int real_c)
{
  char *v3; // eax
  char *thisname; // [esp+20h] [ebp-8h]
  int thisgroup; // [esp+24h] [ebp-4h]

  if ( curdoc.link >= nlinks - 1 )
  {
    if ( !more_text && Newline == 1 && curdoc.link == nlinks - 1 )
    {
      set_curdoc_link(0);
    }
    else if ( more_text )
    {
      Newline += display_lines;
    }
    else if ( *old_c != real_c )
    {
      *old_c = real_c;
      v3 = gettext("You are already at the end of this document.");
      HTInfoMsg(v3);
    }
  }
  else
  {
    LYhighlight(0, curdoc.link, prev_target);
    if ( links[curdoc.link].type == 1 && links[curdoc.link].l_form->type == 9 && c == 9 )
    {
      thisgroup = links[curdoc.link].l_form->number;
      thisname = links[curdoc.link].l_form->name;
      do
        ++curdoc.link;
      while ( curdoc.link < nlinks - 1
           && links[curdoc.link].type == 1
           && links[curdoc.link].l_form->type == 9
           && links[curdoc.link].l_form->number == thisgroup
           && sametext(links[curdoc.link].l_form->name, thisname) );
    }
    else
    {
      ++curdoc.link;
    }
  }
}

//----- (08083D85) --------------------------------------------------------
void __cdecl handle_LYK_NEXT_PAGE(int *old_c, int real_c)
{
  char *v2; // eax

  if ( more_text )
  {
    Newline += display_lines;
  }
  else if ( curdoc.link >= nlinks - 1 )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v2 = gettext("You are already at the end of this document.");
      HTInfoMsg(v2);
    }
  }
  else
  {
    set_curdoc_link(nlinks - 1);
  }
}

//----- (08083DF6) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_NOCACHE(int *old_c, int real_c)
{
  char *v2; // eax

  if ( nlinks <= 0 )
    return 1;
  if ( links[curdoc.link].type != 1
    || links[curdoc.link].l_form->type == 5
    || links[curdoc.link].l_form->type == 13
    || links[curdoc.link].l_form->type == 12 )
  {
    LYforce_no_cache = 1;
    reloading[0] = 1;
    return 1;
  }
  if ( *old_c != real_c )
  {
    *old_c = real_c;
    v2 = gettext("You are not on a form submission button or normal link.");
    HTUserMsg(v2);
  }
  return 0;
}

//----- (08083EC2) --------------------------------------------------------
void __cdecl handle_LYK_PREV_LINK(int *arrowup, int *old_c, int real_c)
{
  char *v3; // eax
  int v4; // [esp+14h] [ebp-14h]

  if ( curdoc.link <= 0 )
  {
    if ( more_text || curdoc.link || Newline != 1 )
    {
      if ( curdoc.line <= 1 )
      {
        if ( *old_c != real_c )
        {
          *old_c = real_c;
          v3 = gettext("You are already at the beginning of this document.");
          HTInfoMsg(v3);
        }
      }
      else
      {
        if ( Newline > display_lines )
          v4 = display_lines;
        else
          v4 = Newline - 1;
        Newline -= v4;
        if ( v4 >= display_lines || nlinks <= 0 || curdoc.link || v4 + links[0].ly - 1 > display_lines )
          *arrowup = 1;
        else
          newdoc.link = HText_LinksInLines(HTMainText, 1, v4) - 1;
      }
    }
    else
    {
      set_curdoc_link(nlinks - 1);
    }
  }
  else
  {
    set_curdoc_link(curdoc.link - 1);
  }
}

//----- (08083FEA) --------------------------------------------------------
int __cdecl handle_PREV_DOC(int *cmd, int *old_c, int real_c)
{
  char *v3; // eax
  char *address; // ebx
  char *v5; // eax
  char *v6; // eax
  DocAddress WWWDoc; // [esp+14h] [ebp-24h] BYREF
  HText *text; // [esp+28h] [ebp-10h]
  HTParentAnchor *tmpanchor; // [esp+2Ch] [ebp-Ch]
  BOOLEAN first; // [esp+32h] [ebp-6h]
  BOOLEAN conf; // [esp+33h] [ebp-5h]

  if ( nhist > 0 )
  {
    conf = 0;
    first = 1;
    HTLastConfirmCancelled();
    while ( nhist > 0 )
    {
      conf = 0;
      if ( !history[nhist - 1].hdoc.post_data )
        break;
      WWWDoc = *(DocAddress *)&history[nhist - 1].hdoc.address;
      tmpanchor = HTAnchor_findAddress(&WWWDoc);
      if ( HTAnchor_safe(tmpanchor) )
        break;
      text = (HText *)HTAnchor_document(tmpanchor);
      if ( (text
         || strncasecomp(WWWDoc.address, "LYNXIMGMAP:", 11)
         && (conf = confirm_post_resub(WWWDoc.address, history[nhist - 1].hdoc.title, 0, 0)) != 0)
        && (!LYresubmit_posts
         || conf
         || !are_different(&history[nhist - 1].hdoc, &curdoc) && !are_different(&history[nhist - 1].hdoc, &newdoc)
         || confirm_post_resub(WWWDoc.address, history[nhist - 1].hdoc.title, 2, 2)) )
      {
        if ( conf )
          LYforce_no_cache = 1;
        break;
      }
      if ( (unsigned __int8)HTLastConfirmCancelled() )
      {
        if ( !first && curdoc.internal_link )
          free_address(&curdoc);
        *cmd = 69;
        return 2;
      }
      if ( nhist == 1 )
      {
        v3 = gettext("Cancelled!!!");
        HTInfoMsg(v3);
        *old_c = 0;
        *cmd = 69;
        return 2;
      }
      address = WWWDoc.address;
      v5 = gettext("Skipping %s");
      HTUserMsg2(v5, address);
      do
        LYpop(&curdoc);
      while ( nhist > 1 && !are_different(&history[nhist - 1].hdoc, &curdoc) );
      first = 0;
    }
    if ( !first )
      curdoc.internal_link = 0;
    LYhist_prev_register(&curdoc);
    free_address(&newdoc);
    if ( lynx_edit_mode && LYAutoUncacheDirLists > 1 )
      HTuncache_current_document();
    return 0;
  }
  if ( child_lynx != 1 )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v6 = gettext("You are already at the first document");
      HTUserMsg(v6);
    }
    return 0;
  }
  return 1;
}

//----- (08084392) --------------------------------------------------------
void __cdecl handle_LYK_PREV_PAGE(int *old_c, int real_c)
{
  char *v2; // eax

  if ( Newline <= 1 )
  {
    if ( curdoc.link <= 0 )
    {
      if ( *old_c != real_c )
      {
        *old_c = real_c;
        v2 = gettext("You are already at the beginning of this document.");
        HTInfoMsg(v2);
      }
    }
    else
    {
      set_curdoc_link(0);
    }
  }
  else
  {
    Newline -= display_lines;
  }
}

//----- (080843F5) --------------------------------------------------------
void __cdecl handle_LYK_PRINT(BOOLEAN *ForcePush, int *old_c, int real_c)
{
  char *v3; // eax
  int NumOfLines; // eax
  char *v5; // eax

  if ( LYValidate )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v3 = gettext("The 'p'rint command is currently disabled.");
      HTUserMsg(v3);
    }
  }
  else if ( !LYIsUIPage3(curdoc.address, UIP_PRINT_OPTIONS_0, 1) )
  {
    NumOfLines = HText_getNumOfLines();
    if ( print_options(&newdoc.address, curdoc.address, NumOfLines) >= 0 )
    {
      LYRegisterUIPage(newdoc.address, UIP_PRINT_OPTIONS_0);
      v5 = gettext("Printing Options");
      HTSACopy(&newdoc.title, v5);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      *ForcePush = 1;
      if ( check_realm )
        LYPermitURL = 1;
    }
  }
}

//----- (08084506) --------------------------------------------------------
int handle_LYK_QUIT()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int c; // [esp+24h] [ebp-4h]

  if ( LYQuitDefaultYes == 1 )
  {
    v0 = gettext("Are you sure you want to quit?");
    c = HTConfirmDefault(v0, 1);
  }
  else
  {
    v1 = gettext("Are you sure you want to quit?");
    c = HTConfirmDefault(v1, 0);
  }
  if ( LYQuitDefaultYes != 1 )
  {
    if ( c == 1 )
      return 1;
LABEL_10:
    v2 = gettext("Excellent!!!");
    HTInfoMsg(v2);
    return 0;
  }
  if ( !c )
    goto LABEL_10;
  return 1;
}

//----- (080845AE) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_RAW_TOGGLE(int *cmd)
{
  char *v1; // eax
  const char *Msg; // [esp+14h] [ebp-4h]

  if ( HTLoadedDocumentCharset() )
  {
    v1 = gettext("charset for this document specified explicitly, sorry...");
    HTUserMsg(v1);
    return 0;
  }
  else
  {
    LYUseDefaultRawMode = LYUseDefaultRawMode == 0;
    if ( LYRawMode[0] )
      Msg = gettext("Raw 8-bit or CJK mode toggled OFF!  Reloading...");
    else
      Msg = gettext("Raw 8-bit or CJK mode toggled ON!  Reloading...");
    HTUserMsg(Msg);
    HTMLSetCharacterHandling(current_char_set);
    return reparse_or_reload(cmd);
  }
}

//----- (0808463F) --------------------------------------------------------
void __cdecl handle_LYK_RELOAD(int real_cmd)
{
  char *v1; // eax
  char *v2; // eax

  if ( !curdoc.post_data
    || curdoc.safe == 1
    || (v1 = gettext("Document from Form with POST content.  Resubmit?"), HTConfirm(v1)) )
  {
    if ( HTisDocumentSource() )
    {
      forced_UCLYhdnl = HTMainText_Get_UCLYhndl();
      if ( forced_UCLYhdnl >= 0 )
        force_old_UCLYhndl_on_reload[0] = 1;
      srcmode_for_next_retrieval(1);
    }
    HEAD_request = HTLoadedDocumentIsHEAD();
    HText_setNoCache(HTMainText);
    newdoc.line = curdoc.line;
    newdoc.link = curdoc.link;
    free_address(&curdoc);
    if ( real_cmd == 12 )
      reloading[0] = 1;
  }
  else
  {
    v2 = gettext("Cancelled!!!");
    HTInfoMsg(v2);
  }
}

//----- (080846FC) --------------------------------------------------------
void __cdecl handle_LYK_REMOVE(BOOLEAN *refresh_screen)
{
  int linkno; // [esp+14h] [ebp-4h]

  if ( lynx_edit_mode && nlinks > 0 && !no_dired_support[0] )
  {
    linkno = curdoc.link;
    local_remove(&curdoc);
    if ( LYAutoUncacheDirLists <= 0 )
    {
      if ( curdoc.link != linkno )
        *refresh_screen = 1;
    }
    else
    {
      do_cleanup_after_delete();
    }
  }
}

//----- (08084757) --------------------------------------------------------
void handle_LYK_RIGHT_LINK()
{
  if ( curdoc.link < nlinks - 1 && links[curdoc.link].ly == links[curdoc.link + 1].ly )
    set_curdoc_link(curdoc.link + 1);
}

//----- (080847B2) --------------------------------------------------------
void __cdecl handle_LYK_SHELL(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  char *v3; // eax
  const char *v4; // eax
  char *v5; // eax

  if ( no_shell )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("Spawning is currently disabled.");
      HTUserMsg(v5);
    }
  }
  else
  {
    stop_curses();
    v3 = gettext("Spawning your default shell.  Use 'exit' to return to Lynx.\n");
    printf("%s\r\n", v3);
    if ( !shell_15964 )
    {
      v4 = LYSysShell();
      HTSACopy(&shell_15964, v4);
    }
    LYSystem(shell_15964);
    start_curses();
    *refresh_screen = 1;
  }
}

//----- (08084844) --------------------------------------------------------
void handle_LYK_SOFT_DQUOTES()
{
  char *v0; // eax
  const char *Msg; // [esp+14h] [ebp-4h]

  if ( !(unsigned __int8)HTcan_reparse_document() )
  {
    if ( !curdoc.post_data || curdoc.safe == 1 || confirm_post_resub(curdoc.address, 0, 1, 1) )
    {
      HText_setNoCache(HTMainText);
      move_address(&newdoc, &curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
    }
    else
    {
      v0 = gettext("Document will not be reloaded!");
      HTInfoMsg(v0);
    }
  }
  soft_dquotes = soft_dquotes == 0;
  if ( soft_dquotes )
    Msg = gettext("Soft double-quote parsing ON!");
  else
    Msg = gettext("Soft double-quote parsing OFF!");
  HTUserMsg(Msg);
  reparse_document();
}

//----- (0808492D) --------------------------------------------------------
int wrap_reparse_document()
{
  int link; // ebx
  FILE *v1; // eax
  bool v2; // al
  FILE *v3; // eax
  FILE *v4; // eax
  int Anchor; // ebx
  int v6; // esi
  FILE *v7; // eax
  int anchor_number; // [esp+18h] [ebp-30h]
  int sgml_offset; // [esp+1Ch] [ebp-2Ch]
  int top_lineno; // [esp+20h] [ebp-28h]
  int new_lineno; // [esp+24h] [ebp-24h]
  int new_anchor; // [esp+28h] [ebp-20h]
  int old_from_top; // [esp+30h] [ebp-18h]
  int old_line_num; // [esp+34h] [ebp-14h]
  int result; // [esp+3Ch] [ebp-Ch]

  if ( nlinks <= 0 || curdoc.link < 0 )
    anchor_number = -1;
  else
    anchor_number = links[curdoc.link].anchor_number;
  old_line_num = HText_getAbsLineNumber(HTMainText, anchor_number);
  old_from_top = old_line_num - Newline + 1;
  if ( nlinks <= 0 || curdoc.link < 0 )
    sgml_offset = -1;
  else
    sgml_offset = links[curdoc.link].sgml_offset;
  if ( WWW_TraceFlag[0] )
  {
    link = curdoc.link;
    v1 = TraceFP();
    fprintf(v1, "original anchor %d, topline %d, link %d, offset %d\n", anchor_number, old_line_num, link, sgml_offset);
  }
  v2 = reparse_document();
  result = v2;
  if ( v2 && sgml_offset >= 0 )
  {
    new_anchor = HText_closestAnchor(HTMainText, sgml_offset);
    new_lineno = HText_getAbsLineNumber(HTMainText, new_anchor);
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "old anchor %d -> new anchor %d\n", anchor_number, new_anchor);
    }
    if ( new_lineno - old_from_top < 0 )
      old_from_top = new_lineno;
    top_lineno = HText_getPreferredTopLine(HTMainText, new_lineno - old_from_top) + 1;
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "preferred top %d\n", top_lineno);
    }
    if ( top_lineno == Newline )
    {
      newdoc.link = curdoc.link;
    }
    else
    {
      Newline = top_lineno;
      newdoc.link = HText_anchorRelativeTo(HTMainText, top_lineno - 1, new_anchor);
      curdoc.link = newdoc.link;
      if ( WWW_TraceFlag[0] )
      {
        Anchor = HText_locateAnchor(HTMainText, new_anchor);
        v6 = curdoc.link;
        v7 = TraceFP();
        fprintf(v7, "adjusted anchor %d, topline %d, link %d, offset %d\n", new_anchor, top_lineno, v6, Anchor);
      }
    }
  }
  return result;
}

//----- (08084BA4) --------------------------------------------------------
void __cdecl handle_LYK_SOURCE(char **ownerS_address_p)
{
  char *v1; // eax
  char *v2; // eax
  const char *Owner; // [esp+4h] [ebp-24h]
  bool v4; // [esp+17h] [ebp-11h]
  BOOLEAN canreparse_post; // [esp+27h] [ebp-1h]

  canreparse_post = 0;
  if ( !curdoc.post_data
    || curdoc.safe == 1
    || (canreparse_post = HTcan_reparse_document()) != 0
    || (!curdoc.isHEAD ? (v4 = confirm_post_resub(curdoc.address, curdoc.title, 1, 1) == 0) : (v1 = gettext("Document from Form with POST content.  Resubmit?"),
                                                                                               v4 = HTConfirm(v1) == 0),
        !v4) )
  {
    if ( HTisDocumentSource() )
    {
      srcmode_for_next_retrieval(-1);
    }
    else
    {
      if ( HText_getOwner() )
      {
        Owner = HText_getOwner();
        HTSACopy(ownerS_address_p, Owner);
      }
      LYUCPushAssumed(HTMainAnchor);
      srcmode_for_next_retrieval(1);
    }
    if ( wrap_reparse_document() )
    {
      HTOutputFormat = HTAtom_for("www/present");
      if ( psrc_view )
        HTMark_asSource();
      psrc_view = 0;
      if ( *ownerS_address_p )
      {
        free(*ownerS_address_p);
        *ownerS_address_p = 0;
      }
      LYUCPopAssumed();
      HTMLSetCharacterHandling(current_char_set);
    }
    else if ( canreparse_post )
    {
      srcmode_for_next_retrieval(0);
      LYUCPopAssumed();
    }
    else
    {
      if ( curdoc.title )
        HTSACopy(&newdoc.title, curdoc.title);
      free_address(&curdoc);
      LYforce_no_cache = 1;
    }
  }
  else
  {
    v2 = gettext("Cancelled!!!");
    HTInfoMsg(v2);
  }
}

//----- (08084D48) --------------------------------------------------------
void handle_LYK_SWITCH_DTD()
{
  char *v0; // eax
  const char *Msg; // [esp+14h] [ebp-14h]
  BOOLEAN canreparse; // [esp+27h] [ebp-1h]

  canreparse = HTcan_reparse_document();
  if ( !canreparse )
  {
    if ( !curdoc.post_data || curdoc.safe == 1 || confirm_post_resub(curdoc.address, 0, 1, 1) )
    {
      if ( HTisDocumentSource() && LYPreparsedSource )
        srcmode_for_next_retrieval(1);
      HText_setNoCache(HTMainText);
      move_address(&newdoc, &curdoc);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
    }
    else
    {
      v0 = gettext("Document will not be reloaded!");
      HTInfoMsg(v0);
    }
  }
  Old_DTD = Old_DTD == 0;
  HTSwitchDTD(Old_DTD == 0);
  if ( Old_DTD )
    Msg = gettext("Now using TagSoup parsing of HTML.");
  else
    Msg = gettext("Now using SortaSGML parsing of HTML!");
  HTUserMsg(Msg);
  if ( canreparse )
  {
    if ( HTisDocumentSource() && LYPreparsedSource )
      srcmode_for_next_retrieval(1);
    if ( !reparse_document() )
      srcmode_for_next_retrieval(0);
  }
}

//----- (08084EA4) --------------------------------------------------------
void handle_LYK_TAG_LINK()
{
  const char *v0; // eax
  const char *v1; // eax
  const char *v2; // eax
  char *object; // [esp+14h] [ebp-14h]
  char *tagname; // [esp+1Ch] [ebp-Ch] BYREF
  HTList *t1; // [esp+20h] [ebp-8h]
  BOOLEAN found; // [esp+27h] [ebp-1h]

  if ( lynx_edit_mode )
  {
    if ( nlinks > 0 && !no_dired_support[0] )
    {
      v0 = LYGetHiliteStr(curdoc.link, 0);
      if ( strcmp(v0, "..") )
      {
        if ( dir_list_style == 2 )
        {
          v1 = LYGetHiliteStr(curdoc.link, 0);
          if ( !strcmp(v1, "../") )
            return;
        }
        else
        {
          v2 = LYGetHiliteStr(curdoc.link, 0);
          if ( !strncmp(v2, "Up to ", 6u) )
            return;
        }
        t1 = tagged;
        tagname = 0;
        found = 0;
        while ( 1 )
        {
          if ( t1 && (t1 = t1->next) != 0 )
            object = (char *)t1->object;
          else
            object = 0;
          tagname = object;
          if ( !object )
            break;
          if ( !strcmp(links[curdoc.link].lname, tagname) )
          {
            found = 1;
            HTList_removeObject(tagged, tagname);
            if ( tagname )
            {
              free(tagname);
              tagname = 0;
            }
            tagflag(0, curdoc.link);
            break;
          }
        }
        if ( !found )
        {
          if ( !tagged )
            tagged = HTList_new();
          tagname = 0;
          HTSACopy(&tagname, links[curdoc.link].lname);
          HTList_addObject(tagged, tagname);
          tagflag(1, curdoc.link);
        }
        if ( curdoc.link >= nlinks - 1 )
        {
          if ( !more_text && Newline == 1 && curdoc.link == nlinks - 1 )
          {
            set_curdoc_link(0);
          }
          else if ( more_text )
          {
            Newline += display_lines;
          }
        }
        else
        {
          set_curdoc_link(curdoc.link + 1);
        }
      }
    }
  }
}

//----- (08085113) --------------------------------------------------------
void handle_LYK_TOGGLE_HELP()
{
  if ( !user_mode )
  {
    toggle_novice_line();
    noviceline(more_text);
  }
}

//----- (0808513B) --------------------------------------------------------
void __cdecl handle_LYK_TOOLBAR(BOOLEAN *try_internal, BOOLEAN *force_load, int *old_c, int real_c)
{
  char *v4; // eax
  char *toolbar; // [esp+20h] [ebp-8h] BYREF
  char *cp; // [esp+24h] [ebp-4h]

  toolbar = 0;
  if ( HText_hasToolbar(HTMainText) )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      cp = trimPoundSelector(curdoc.address);
      HTSprintf0(&toolbar, "%s#%s", curdoc.address, LYToolbarName);
      if ( cp )
        *cp = 35;
      set_address(&newdoc, toolbar);
      if ( toolbar )
      {
        free(toolbar);
        toolbar = 0;
      }
      *try_internal = 1;
      *force_load = 1;
    }
  }
  else if ( *old_c != real_c )
  {
    *old_c = real_c;
    v4 = gettext("Document has no Toolbar links or Banner.");
    HTUserMsg(v4);
  }
}

//----- (0808521A) --------------------------------------------------------
void __cdecl handle_LYK_TRACE_LOG(BOOLEAN *trace_flag_ptr)
{
  char *v1; // eax
  char *v2; // eax

  if ( LYTraceLogFP )
  {
    if ( !LYIsUIPage3(curdoc.address, UIP_TRACELOG_0, 1) && LYReopenTracelog(trace_flag_ptr) )
    {
      LYLocalFileToURL(&newdoc.address, LYTraceLogPath);
      LYRegisterUIPage(newdoc.address, UIP_TRACELOG_0);
      v2 = gettext("Lynx Trace Log");
      HTSACopy(&newdoc.title, v2);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      if ( LYValidate || check_realm )
        LYPermitURL = 1;
      LYforce_no_cache = 1;
    }
  }
  else
  {
    v1 = gettext("No trace log has been started for this session.");
    HTUserMsg(v1);
  }
}

//----- (08085327) --------------------------------------------------------
void handle_LYK_UPLOAD()
{
  char *v0; // eax

  if ( !LYIsUIPage3(curdoc.address, UIP_UPLOAD_OPTIONS_0, 1) && lynx_edit_mode && !no_dired_support[0] )
  {
    LYUpload_options(&newdoc.address, curdoc.address);
    v0 = gettext("Upload Options");
    HTSACopy(&newdoc.title, v0);
    LYFreePostData(&newdoc);
    if ( newdoc.bookmark )
    {
      free(newdoc.bookmark);
      newdoc.bookmark = 0;
    }
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.internal_link = 0;
    if ( LYAutoUncacheDirLists > 0 )
      HTuncache_current_document();
  }
}

//----- (080853F2) --------------------------------------------------------
void __cdecl handle_LYK_UP_xxx(int *arrowup, int *old_c, int real_c, int scroll_by)
{
  int link; // ebx
  char *v5; // eax

  if ( Newline <= 1 )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("You are already at the beginning of this document.");
      HTInfoMsg(v5);
    }
  }
  else
  {
    if ( Newline - scroll_by <= 0 )
      scroll_by = Newline - 1;
    Newline -= scroll_by;
    if ( nlinks > 0 && curdoc.link >= 0 )
    {
      if ( scroll_by + links[curdoc.link].ly > display_lines )
      {
        *arrowup = 1;
      }
      else
      {
        link = curdoc.link;
        newdoc.link = link + HText_LinksInLines(HTMainText, Newline, scroll_by);
      }
    }
  }
}

//----- (080854CE) --------------------------------------------------------
void __cdecl handle_LYK_UP_HALF(int *arrowup, int *old_c, int real_c)
{
  handle_LYK_UP_xxx(arrowup, old_c, real_c, display_lines / 2);
}

//----- (08085502) --------------------------------------------------------
void __cdecl handle_LYK_UP_LINK(int *follow_col, int *arrowup, int *old_c, int real_c)
{
  int v4; // ebx
  char *v5; // eax
  char *v6; // eax
  int v7; // [esp+10h] [ebp-18h]
  const char *text; // [esp+1Ch] [ebp-Ch]
  int newlink; // [esp+20h] [ebp-8h]

  if ( curdoc.link <= 0 || links[0].ly == links[curdoc.link].ly && HText_LinksInLines(HTMainText, 1, Newline - 1) )
  {
    if ( curdoc.line <= 1 || Newline <= 1 )
    {
      if ( *old_c != real_c )
      {
        *old_c = real_c;
        v6 = gettext("You are already at the beginning of this document.");
        HTInfoMsg(v6);
      }
    }
    else
    {
      if ( Newline > display_lines )
        v7 = display_lines;
      else
        v7 = Newline - 1;
      Newline -= v7;
      if ( v7 >= display_lines || nlinks <= 0 || curdoc.link < 0 || v7 + links[0].ly - 1 > display_lines )
        *arrowup = 1;
      else
        newdoc.link = HText_LinksInLines(HTMainText, 1, v7) - 1;
    }
  }
  else
  {
    if ( *follow_col == -1 )
    {
      text = LYGetHiliteStr(curdoc.link, 0);
      *follow_col = links[curdoc.link].lx;
      if ( text )
      {
        v4 = *follow_col;
        *follow_col = v4 + (strlen(text) >> 1);
      }
    }
    newlink = find_link_near_col(*follow_col, -1);
    if ( newlink < 0 )
    {
      if ( *old_c != real_c )
      {
        *old_c = real_c;
        v5 = gettext("There are no links above this line of the document.");
        HTUserMsg(v5);
      }
    }
    else
    {
      set_curdoc_link(newlink);
    }
  }
}

//----- (080856FF) --------------------------------------------------------
void __cdecl handle_LYK_UP_TWO(int *arrowup, int *old_c, int real_c)
{
  handle_LYK_UP_xxx(arrowup, old_c, real_c, 2);
}

//----- (08085728) --------------------------------------------------------
void __cdecl handle_LYK_VIEW_BOOKMARK(BOOLEAN *refresh_screen, int *old_c, int real_c)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  const char *cp; // [esp+14h] [ebp-4h]

  if ( LYValidate )
  {
    if ( *old_c != real_c )
    {
      *old_c = real_c;
      v3 = gettext("Bookmark features are currently disabled.");
      HTUserMsg(v3);
    }
  }
  else
  {
    cp = get_bookmark_filename(&newdoc.address);
    if ( cp )
    {
      if ( !*cp || !strcmp(cp, " ") || !strcmp(curdoc.address, newdoc.address) )
      {
        if ( LYMultiBookmarks )
          *refresh_screen = 1;
      }
      else
      {
        LYforce_no_cache = 1;
        v4 = gettext("Bookmark file");
        HTSACopy(&newdoc.title, v4);
        HTSACopy(&newdoc.bookmark, BookmarkPage);
        LYFreePostData(&newdoc);
        newdoc.isHEAD = 0;
        newdoc.safe = 0;
        newdoc.internal_link = 0;
      }
    }
    else if ( *old_c != real_c )
    {
      *old_c = real_c;
      v5 = gettext("Unable to open bookmark file, use 'a' to save a link first");
      LYMBM_statusline(v5);
      LYSleepAlert();
      if ( LYMultiBookmarks )
        *refresh_screen = 1;
    }
  }
}

//----- (0808586C) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_VLINKS(int *cmd, BOOLEAN *newdoc_link_is_absolute)
{
  char *v2; // eax
  char *v3; // eax
  int c; // [esp+24h] [ebp-4h]

  if ( LYIsUIPage3(curdoc.address, UIP_VLINKS_0, 1) )
  {
    *cmd = 37;
    return 1;
  }
  else
  {
    c = LYShowVisitedLinks(&newdoc.address);
    if ( c >= 0 )
    {
      v3 = gettext("Visited Links Page");
      HTSACopy(&newdoc.title, v3);
      LYFreePostData(&newdoc);
      if ( newdoc.bookmark )
      {
        free(newdoc.bookmark);
        newdoc.bookmark = 0;
      }
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      newdoc.internal_link = 0;
      if ( c > 0 )
      {
        *newdoc_link_is_absolute = 1;
        newdoc.link = c - 1;
      }
      if ( LYValidate || check_realm )
      {
        LYPermitURL = 1;
        HTSACopy(&lynxlinksfile, newdoc.address);
      }
      return 0;
    }
    else
    {
      v2 = gettext("No previously visited links available!");
      HTUserMsg(v2);
      return 0;
    }
  }
}

//----- (08085987) --------------------------------------------------------
void __cdecl handle_LYK_WHEREIS(int cmd, BOOLEAN *refresh_screen)
{
  bool v2; // [esp+18h] [ebp-20h]
  int direction; // [esp+1Ch] [ebp-1Ch]
  int v4; // [esp+20h] [ebp-18h]
  char *remember_old_target; // [esp+28h] [ebp-10h] BYREF
  int oldcur; // [esp+2Ch] [ebp-Ch]
  BOOLEAN found; // [esp+32h] [ebp-6h]
  BOOLEAN have_target_onscreen; // [esp+33h] [ebp-5h]

  v2 = prev_target[0] && (unsigned __int8)HText_pageHasPrevTarget();
  have_target_onscreen = v2;
  oldcur = curdoc.link;
  remember_old_target = 0;
  if ( v2 )
    HTSACopy(&remember_old_target, prev_target);
  else
    HTSACopy(&remember_old_target, &byte_81534E7);
  if ( cmd == 51 )
    prev_target[0] = 0;
  if ( cmd == 51 )
  {
    direction = 0;
  }
  else
  {
    if ( cmd == 53 )
      v4 = 1;
    else
      v4 = -1;
    direction = v4;
  }
  found = textsearch(&curdoc, prev_target, 1023, direction);
  if ( www_search_result < 0 || curdoc.line == www_search_result )
  {
    if ( found )
    {
      if ( have_target_onscreen )
      {
        if ( curdoc.line == www_search_result
          && curdoc.link == oldcur
          && curdoc.link >= 0
          && nlinks > 0
          && links[curdoc.link].ly >= display_lines / 3 )
        {
          *refresh_screen = 1;
        }
        else if ( case_sensitive && strcmp(prev_target, remember_old_target)
               || !case_sensitive && strcasecomp8(prev_target, remember_old_target) )
        {
          *refresh_screen = 1;
        }
      }
      else
      {
        *refresh_screen = 1;
      }
    }
    else
    {
      *refresh_screen = have_target_onscreen;
    }
  }
  else
  {
    *refresh_screen = 1;
  }
  if ( remember_old_target )
    free(remember_old_target);
}
// 8085A95: conditional instruction was optimized away because %found.1!=0

//----- (08085B7B) --------------------------------------------------------
void __cdecl handle_LYK_digit(
        int c,
        BOOLEAN *force_load,
        char *user_input_buffer,
        int *old_c,
        int real_c,
        BOOLEAN *try_internal)
{
  const char *v6; // eax
  int v7; // ebx
  char *v8; // eax
  char *v9; // eax
  int v10; // ebx
  char *v11; // eax
  char *v12; // [esp+4h] [ebp-34h]
  char *v13; // [esp+4h] [ebp-34h]
  int link; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  char *temp; // [esp+28h] [ebp-10h] BYREF
  int number; // [esp+2Ch] [ebp-Ch] BYREF
  int lindx; // [esp+30h] [ebp-8h]

  if ( nlinks <= 0 )
    link = 0;
  else
    link = curdoc.link;
  lindx = link;
  temp = 0;
  number = curdoc.line;
  v15 = follow_link_number(c, link, &newdoc, &number);
  if ( v15 == 2 )
  {
    Newline = newdoc.line;
    newdoc.line = 1;
    if ( curdoc.line != Newline || nlinks <= 0 || curdoc.link < 0 )
      return;
    if ( curdoc.link != newdoc.link )
    {
      set_curdoc_link(newdoc.link);
      newdoc.link = 0;
      return;
    }
    HTSACopy(&temp, user_input_buffer);
    v7 = number;
    v12 = gettext("Link number %d already is current.");
    sprintf(user_input_buffer, v12, v7);
    HTUserMsg(user_input_buffer);
    LYstrncpy(user_input_buffer, temp, 1023);
    if ( !temp )
      return;
    goto LABEL_22;
  }
  if ( v15 <= 2 )
  {
    if ( v15 == 1 )
    {
      set_address(&newdoc, links[lindx].lname);
      v6 = LYGetHiliteStr(lindx, 0);
      HTSACopy(&newdoc.title, v6);
      if ( are_different(&curdoc, &newdoc) )
      {
        LYFreePostData(&newdoc);
        if ( newdoc.bookmark )
        {
          free(newdoc.bookmark);
          newdoc.bookmark = 0;
        }
        newdoc.isHEAD = 0;
        newdoc.safe = 0;
        if ( !strncasecomp(newdoc.address, "LYNXMESSAGES:", 13) )
          LYforce_no_cache = 1;
      }
      newdoc.internal_link = 0;
      *force_load = 1;
    }
    return;
  }
  if ( v15 != 3 )
  {
    if ( v15 == 5 )
    {
      *old_c = real_c;
      v11 = gettext("You have entered an invalid link number.");
      HTUserMsg(v11);
    }
    return;
  }
  Newline = newdoc.line;
  newdoc.line = 1;
  if ( curdoc.line != Newline )
    return;
  if ( Newline <= 1 )
  {
    v8 = gettext("You are already at the beginning of this document.");
    HTInfoMsg(v8);
    return;
  }
  if ( !more_text )
  {
    v9 = gettext("You are already at the end of this document.");
    HTInfoMsg(v9);
    return;
  }
  HTSACopy(&temp, user_input_buffer);
  v10 = number;
  v13 = gettext("You are already at page %d of this document.");
  sprintf(user_input_buffer, v13, v10);
  HTUserMsg(user_input_buffer);
  LYstrncpy(user_input_buffer, temp, 1023);
  if ( temp )
  {
LABEL_22:
    free(temp);
    temp = 0;
  }
}

//----- (08085EC6) --------------------------------------------------------
void handle_LYK_CHDIR()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  char *v4; // ebx
  FILE *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // [esp+10h] [ebp-118h]
  char *addr; // [esp+18h] [ebp-110h] BYREF
  char *p; // [esp+1Ch] [ebp-10Ch] BYREF
  char buf2[256]; // [esp+20h] [ebp-108h] BYREF
  unsigned int v15; // [esp+120h] [ebp-8h]

  v15 = __readgsdword(0x14u);
  p = 0;
  if ( no_chdir )
  {
    v0 = gettext("Changing working-directory is currently disabled.");
    HTUserMsg(v0);
  }
  else
  {
    mustshow[0] = 1;
    v1 = gettext("cd to:");
    statusline(v1);
    if ( LYgetstr(buf_16744, 0, 0xFFu, NORECALL) >= 0 && buf_16744[0] )
    {
      if ( buf_16744[0] == 126 && (byte_81AEAA1 == 47 || !byte_81AEAA1) )
      {
        v3 = Home_Dir();
        HTSprintf0(&p, "%s%s", v3, &byte_81AEAA1);
      }
      else
      {
        HTSACopy(&p, buf_16744);
      }
      if ( WWW_TraceFlag[0] )
      {
        v4 = p;
        v5 = TraceFP();
        fprintf(v5, "changing directory to '%s'\n", v4);
      }
      if ( chdir(p) )
      {
        v11 = *__errno_location();
        if ( v11 == 13 )
        {
          v6 = gettext("Could not access directory.");
          HTInfoMsg(v6);
        }
        else if ( v11 == 20 )
        {
          v7 = gettext("A component of path is not a directory");
          HTInfoMsg(v7);
        }
        else
        {
          if ( v11 == 2 )
            v8 = gettext("No such directory");
          else
            v8 = gettext("failed to change directory");
          HTInfoMsg(v8);
        }
      }
      else if ( !no_dired_support[0] && (lynx_edit_mode || LYIsUIPage3(curdoc.address, UIP_DIRED_MENU_0, 1)) )
      {
        addr = 0;
        Current_Dir(buf2);
        LYLocalFileToURL(&addr, buf2);
        newdoc.address = addr;
        newdoc.isHEAD = 0;
        v9 = gettext("A URL specified by the user");
        HTSACopy(&newdoc.title, v9);
        LYFreePostData(&newdoc);
        if ( newdoc.bookmark )
        {
          free(newdoc.bookmark);
          newdoc.bookmark = 0;
        }
        newdoc.safe = 0;
        newdoc.internal_link = 0;
        if ( lynx_edit_mode && LYAutoUncacheDirLists > 1 )
          HTuncache_current_document();
      }
      else
      {
        v10 = gettext("Done!");
        HTInfoMsg(v10);
      }
      if ( p )
        free(p);
    }
    else
    {
      v2 = gettext("Cancelled!!!");
      HTInfoMsg(v2);
    }
  }
}
// 81AEAA1: using guessed type char byte_81AEAA1;

//----- (080861E3) --------------------------------------------------------
int __cdecl repeat_to_delta(int n)
{
  int threshold; // [esp+14h] [ebp-4h]

  for ( threshold = LYcols / 3; threshold > 0; threshold = 2 * threshold / 3 )
  {
    if ( n >= threshold )
      return threshold;
  }
  return n;
}

//----- (08086252) --------------------------------------------------------
void __cdecl handle_LYK_SHIFT_LEFT(BOOLEAN *flag, int count)
{
  char *v2; // eax
  int v3; // ebx

  if ( LYwideLines )
  {
    if ( LYshiftWin > 0 )
    {
      v3 = LYshiftWin;
      LYshiftWin = v3 - repeat_to_delta(count);
      *flag = 1;
    }
    if ( LYshiftWin < 0 )
      LYshiftWin = 0;
  }
  else
  {
    v2 = gettext("Shifting is disabled while line-wrap is in effect");
    HTAlert(v2);
  }
}

//----- (080862BC) --------------------------------------------------------
void __cdecl handle_LYK_SHIFT_RIGHT(BOOLEAN *flag, int count)
{
  char *v2; // eax

  if ( LYwideLines )
  {
    LYshiftWin += repeat_to_delta(count);
    *flag = 1;
  }
  else
  {
    v2 = gettext("Shifting is disabled while line-wrap is in effect");
    HTAlert(v2);
  }
}

//----- (08086303) --------------------------------------------------------
BOOLEAN __cdecl handle_LYK_LINEWRAP_TOGGLE(int *cmd, BOOLEAN *flag)
{
  const char *Msg; // [esp+24h] [ebp-14h]
  int c; // [esp+34h] [ebp-4h]

  if ( LYwin == stdscr )
    return 0;
  c = popup_choice(LYwideLines == 0, LYlines / 2 - 2, (LYcols - (LYShowScrollbar != 0)) / 2 - 6, choices_16870, 8, 0, 1);
  if ( term_options[0] )
    return 0;
  LYwideLines = c;
  LYtableCols = wrap_16871[c];
  if ( !c )
    LYshiftWin = 0;
  *flag = 1;
  if ( LYwideLines )
    Msg = gettext("Linewrap OFF!");
  else
    Msg = gettext("Linewrap ON!");
  HTUserMsg(Msg);
  return reparse_or_reload(cmd);
}

//----- (0808641F) --------------------------------------------------------
_BOOL4 mainloop()
{
  char *v0; // eax
  const char *v1; // ebx
  FILE *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *address; // ebx
  FILE *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  const char *v12; // eax
  unsigned int v13; // eax
  char *v14; // eax
  const char *v15; // eax
  const char *v16; // eax
  char *v17; // eax
  char *v18; // ebx
  FILE *v19; // eax
  const char *Style; // eax
  const char *v21; // eax
  const char *Owner; // eax
  char *v23; // eax
  HTAtom *v24; // ebx
  const char *v25; // ebx
  FILE *v26; // eax
  char *v27; // eax
  char *v28; // eax
  const char *v29; // ebx
  FILE *v30; // eax
  char *v31; // eax
  const char *v32; // eax
  int link; // ebx
  FILE *v34; // eax
  char *v35; // eax
  char *v36; // eax
  size_t v37; // eax
  char *v38; // eax
  char *v39; // eax
  char *v40; // eax
  char *v41; // eax
  char *v42; // eax
  char *v43; // eax
  LinkInfo v45; // [esp+0h] [ebp-698h] BYREF
  int v46; // [esp+48h] [ebp-650h]
  const void *v47; // [esp+4Ch] [ebp-64Ch]
  LinkInfo *v48; // [esp+50h] [ebp-648h]
  int v49; // [esp+54h] [ebp-644h]
  const void *v50; // [esp+58h] [ebp-640h]
  LinkInfo *v51; // [esp+5Ch] [ebp-63Ch]
  int v52; // [esp+60h] [ebp-638h]
  int v53; // [esp+64h] [ebp-634h]
  const void *v54; // [esp+68h] [ebp-630h]
  LinkInfo *v55; // [esp+6Ch] [ebp-62Ch]
  int v56; // [esp+70h] [ebp-628h]
  char *a; // [esp+74h] [ebp-624h]
  char *v58; // [esp+78h] [ebp-620h]
  char *v59; // [esp+7Ch] [ebp-61Ch]
  char *v60; // [esp+80h] [ebp-618h]
  char *v61; // [esp+84h] [ebp-614h]
  char *target; // [esp+88h] [ebp-610h]
  char *lname; // [esp+8Ch] [ebp-60Ch]
  int v65; // [esp+94h] [ebp-604h]
  char *src; // [esp+98h] [ebp-600h]
  int v67; // [esp+9Ch] [ebp-5FCh]
  char *str; // [esp+A0h] [ebp-5F8h]
  char *s2; // [esp+A4h] [ebp-5F4h]
  char *v70; // [esp+A8h] [ebp-5F0h]
  char *v71; // [esp+ACh] [ebp-5ECh]
  char *title; // [esp+B0h] [ebp-5E8h]
  int v73; // [esp+B4h] [ebp-5E4h]
  char *v74; // [esp+B8h] [ebp-5E0h]
  bool v75; // [esp+BFh] [ebp-5D9h]
  char *v76; // [esp+C0h] [ebp-5D8h]
  _BOOL4 v77; // [esp+C4h] [ebp-5D4h]
  _BOOL4 v78; // [esp+C8h] [ebp-5D0h]
  int for_what; // [esp+CCh] [ebp-5CCh]
  char *format; // [esp+D0h] [ebp-5C8h]
  FILE *stream; // [esp+D4h] [ebp-5C4h]
  int v82; // [esp+D8h] [ebp-5C0h]
  int v83; // [esp+DCh] [ebp-5BCh]
  int v84; // [esp+E0h] [ebp-5B8h]
  int v85; // [esp+E4h] [ebp-5B4h]
  bool v86; // [esp+EAh] [ebp-5AEh]
  bool v87; // [esp+EBh] [ebp-5ADh]
  int v88; // [esp+ECh] [ebp-5ACh]
  unsigned int v89; // [esp+F0h] [ebp-5A8h]
  int v90; // [esp+F4h] [ebp-5A4h]
  int v91; // [esp+F8h] [ebp-5A0h]
  int v92; // [esp+FCh] [ebp-59Ch]
  bool v93; // [esp+102h] [ebp-596h]
  bool v94; // [esp+103h] [ebp-595h]
  int v95; // [esp+104h] [ebp-594h]
  int v96; // [esp+108h] [ebp-590h]
  int v97; // [esp+10Ch] [ebp-58Ch]
  int v98; // [esp+110h] [ebp-588h]
  int v99; // [esp+114h] [ebp-584h]
  int v100; // [esp+118h] [ebp-580h]
  DocInfo tmpDocInfo; // [esp+124h] [ebp-574h]
  DocAddress WWWDoc; // [esp+14Ch] [ebp-54Ch] BYREF
  unsigned __int8 *s1; // [esp+160h] [ebp-538h]
  int nl2; // [esp+164h] [ebp-534h]
  int len2; // [esp+168h] [ebp-530h]
  char *buf; // [esp+16Ch] [ebp-52Ch]
  unsigned __int8 *t; // [esp+170h] [ebp-528h]
  unsigned __int8 *e; // [esp+174h] [ebp-524h]
  unsigned __int8 *s_0; // [esp+178h] [ebp-520h]
  int ch2; // [esp+17Ch] [ebp-51Ch]
  char *s; // [esp+180h] [ebp-518h]
  HTAtom *encoding; // [esp+184h] [ebp-514h] BYREF
  const char *name; // [esp+188h] [ebp-510h]
  FILE *ofp; // [esp+18Ch] [ebp-50Ch]
  char *mail_owner; // [esp+190h] [ebp-508h]
  HTParentAnchor *tmpanchor; // [esp+194h] [ebp-504h]
  const char *cp1; // [esp+198h] [ebp-500h]
  int tmpNewline; // [esp+19Ch] [ebp-4FCh] BYREF
  int last_key; // [esp+1A0h] [ebp-4F8h]
  int key_count; // [esp+1A4h] [ebp-4F4h]
  int follow_col; // [esp+1A8h] [ebp-4F0h] BYREF
  int i; // [esp+1ACh] [ebp-4ECh]
  unsigned int len; // [esp+1B0h] [ebp-4E8h]
  char *temp; // [esp+1B4h] [ebp-4E4h] BYREF
  int URLNum; // [esp+1B8h] [ebp-4E0h] BYREF
  int URLTotal; // [esp+1BCh] [ebp-4DCh] BYREF
  RecallType recall; // [esp+1C0h] [ebp-4D8h] BYREF
  int ch_0; // [esp+1C4h] [ebp-4D4h] BYREF
  char *cp; // [esp+1C8h] [ebp-4D0h] BYREF
  FILE *cfp; // [esp+1CCh] [ebp-4CCh]
  const char *cshelpfile; // [esp+1D0h] [ebp-4C8h] BYREF
  int show_help; // [esp+1D4h] [ebp-4C4h]
  int arrowup; // [esp+1D8h] [ebp-4C0h] BYREF
  int getresult; // [esp+1DCh] [ebp-4BCh]
  int real_cmd; // [esp+1E0h] [ebp-4B8h]
  int cmd; // [esp+1E4h] [ebp-4B4h] BYREF
  int pending_form_c; // [esp+1E8h] [ebp-4B0h]
  int old_c; // [esp+1ECh] [ebp-4ACh] BYREF
  int real_c; // [esp+1F0h] [ebp-4A8h]
  int c; // [esp+1F4h] [ebp-4A4h] BYREF
  BOOLEAN use_last_tfpos; // [esp+1F8h] [ebp-4A0h]
  BOOLEAN curlink_is_editable; // [esp+1F9h] [ebp-49Fh]
  BOOLEAN newdoc_link_is_absolute; // [esp+1FAh] [ebp-49Eh] BYREF
  BOOLEAN override_LYresubmit_posts; // [esp+1FBh] [ebp-49Dh]
  BOOLEAN ForcePush; // [esp+1FCh] [ebp-49Ch] BYREF
  BOOLEAN FirstURLRecall; // [esp+1FDh] [ebp-49Bh] BYREF
  BOOLEAN forced_HTML_mode; // [esp+1FEh] [ebp-49Ah]
  BOOLEAN trace_mode_flag; // [esp+1FFh] [ebp-499h] BYREF
  BOOLEAN emacs_keys_flag; // [esp+200h] [ebp-498h] BYREF
  BOOLEAN vi_keys_flag; // [esp+201h] [ebp-497h] BYREF
  BOOLEAN crawl_ok; // [esp+202h] [ebp-496h] BYREF
  BOOLEAN try_internal; // [esp+203h] [ebp-495h] BYREF
  BOOLEAN force_load; // [esp+204h] [ebp-494h] BYREF
  BOOLEAN refresh_screen; // [esp+205h] [ebp-493h] BYREF
  BOOLEAN popped_doc; // [esp+206h] [ebp-492h]
  BOOLEAN first_file; // [esp+207h] [ebp-491h]
  char user_input_buffer[1024]; // [esp+208h] [ebp-490h] BYREF
  char cfile[128]; // [esp+608h] [ebp-90h] BYREF
  unsigned int v159; // [esp+688h] [ebp-10h]

  v159 = __readgsdword(0x14u);
  c = 0;
  real_c = 0;
  old_c = 0;
  pending_form_c = -1;
  cmd = 69;
  real_cmd = 69;
  arrowup = 0;
  show_help = 0;
  cshelpfile = 0;
  first_file = 1;
  popped_doc = 0;
  refresh_screen = 0;
  force_load = 0;
  try_internal = 0;
  crawl_ok = 0;
  vi_keys_flag = vi_keys;
  emacs_keys_flag = emacs_keys;
  trace_mode_flag = 0;
  forced_HTML_mode = LYforce_HTML_mode;
  ch_0 = 0;
  recall = NORECALL;
  URLTotal = 0;
  FirstURLRecall = 1;
  temp = 0;
  ForcePush = 0;
  override_LYresubmit_posts = 0;
  newdoc_link_is_absolute = 0;
  follow_col = -1;
  key_count = 0;
  last_key = 0;
  HTInternalLink = HTAtom_for("internal link");
  WWW_SOURCE = HTAtom_for("www/source");
  newdoc.address = 0;
  newdoc.title = 0;
  newdoc.post_data = 0;
  newdoc.post_content_type = 0;
  newdoc.bookmark = 0;
  newdoc.internal_link = 0;
  curdoc.address = 0;
  curdoc.title = 0;
  curdoc.post_data = 0;
  curdoc.post_content_type = 0;
  curdoc.bookmark = 0;
  curdoc.internal_link = 0;
  curdoc.style = 0;
  newdoc.style = 0;
  nhist = 0;
  user_input_buffer[1023] = 0;
  prev_target[0] = 0;
  user_input_buffer[0] = 0;
  while ( 1 )
  {
    set_address(&newdoc, startfile);
    HTSACopy(&startrealm, startfile);
    v0 = gettext("Entry into main screen");
    HTSACopy(&newdoc.title, v0);
    newdoc.isHEAD = 0;
    newdoc.safe = 0;
    newdoc.line = 1;
    newdoc.link = 0;
    if ( WWW_TraceFlag[0] )
    {
      v1 = startfile;
      v2 = TraceFP();
      fprintf(v2, "Entering mainloop, startfile=%s\n", v1);
    }
    if ( form_post_data )
    {
      HTSABCopy0(&newdoc.post_data, form_post_data);
      HTSACopy(&newdoc.post_content_type, "application/x-www-form-urlencoded");
    }
    else if ( form_get_data )
    {
      HTSACat(&newdoc.address, form_get_data);
    }
    if ( !bookmark_start )
      break;
    if ( LYValidate )
    {
      v3 = gettext("Bookmark features are currently disabled.");
      HTAlert(v3);
      bookmark_start = 0;
    }
    else if ( traversal )
    {
      v4 = gettext("Bookmark files cannot be traversed (only http URLs).");
      HTAlert(v4);
      traversal = 0;
      crawl = 0;
      bookmark_start = 0;
    }
    else
    {
      cp1 = get_bookmark_filename(&newdoc.address);
      if ( cp1 && *cp1 && strcmp(cp1, " ") )
      {
        v5 = gettext("Bookmark file");
        HTSACopy(&newdoc.title, v5);
        HTSACopy(&newdoc.bookmark, BookmarkPage);
        HTSACopy(&startrealm, newdoc.address);
        LYFreePostData(&newdoc);
        newdoc.isHEAD = 0;
        newdoc.safe = 0;
        if ( WWW_TraceFlag[0] )
        {
          address = newdoc.address;
          v7 = TraceFP();
          fprintf(v7, "Using bookmarks=%s\n", address);
        }
        break;
      }
      v8 = gettext("Unable to open bookmark file, use 'a' to save a link first");
      HTUserMsg(v8);
      bookmark_start = 0;
    }
  }
  if ( form_post_data )
  {
    free(form_post_data);
    form_post_data = 0;
  }
  if ( form_get_data )
  {
    free(form_get_data);
    form_get_data = 0;
  }
  LYSetDisplayLines();
LABEL_24:
  if ( curdoc.style )
    force_load = 1;
  if ( LYforce_no_cache || force_load || are_different(&curdoc, &newdoc) )
  {
    force_load = 0;
    if ( WWW_TraceFlag[0] && LYCursesON[0] )
    {
      LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
      LYrefresh();
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( curdoc.address && newdoc.address )
        {
          if ( strncasecomp(newdoc.address, "LYNXDOWNLOAD:", 13) )
            LYpush(&curdoc, ForcePush);
        }
        else if ( !newdoc.address )
        {
          LYhist_prev(&newdoc);
          popped_doc = 1;
          LYoverride_no_cache = !newdoc.bookmark
                             && (!newdoc.post_data
                              || newdoc.safe
                              || !LYresubmit_posts
                              || override_LYresubmit_posts
                              || !are_different(&curdoc, &newdoc));
        }
        override_LYresubmit_posts = 0;
        if ( HEAD_request )
        {
          if ( newdoc.address )
          {
            if ( LYCanDoHEAD(newdoc.address) == 1 )
            {
              newdoc.isHEAD = 1;
            }
            else if ( !strncasecomp(newdoc.address, "LYNXIMGMAP:", 11)
                   && LYCanDoHEAD((const char *)newdoc.address + 11) == 1 )
            {
              HTSACopy(&temp, (const char *)newdoc.address + 11);
              free_address(&newdoc);
              newdoc.address = temp;
              newdoc.isHEAD = 1;
              temp = 0;
            }
          }
          try_internal = 0;
          HEAD_request = 0;
        }
        if ( LYUseTraceLog == 1 && !trace_mode_flag )
        {
          if ( LYTraceLogFP )
          {
            if ( LYIsUIPage3(newdoc.address, UIP_TRACELOG_0, 1) )
            {
              WWWDoc = *(DocAddress *)&newdoc.address;
              tmpanchor = HTAnchor_findAddress(&WWWDoc);
              if ( !HTAnchor_document(tmpanchor) && !LYReopenTracelog(&trace_mode_flag) )
              {
                old_c = 0;
                cmd = 37;
                goto new_cmd;
              }
            }
          }
        }
        LYRequestTitle = newdoc.title;
        if ( newdoc.bookmark )
          LYforce_HTML_mode = 1;
        if ( LYValidate
          && startfile_ok
          && newdoc.address
          && startfile
          && homepage
          && (!strcmp(newdoc.address, startfile) || !strcmp(newdoc.address, homepage)) )
        {
          LYPermitURL = 1;
        }
        prev_target[0] = 0;
        Newline = newdoc.line;
        psrc_first_tag[0] = 1;
        textfields_need_activation = textfields_activation_option;
        if ( LYRequestReferer )
        {
          free(LYRequestReferer);
          LYRequestReferer = 0;
        }
        if ( popped_doc )
          LYNoRefererForThis = 1;
        tmpDocInfo = newdoc;
        tmpNewline = -1;
        getresult = getfile(&newdoc, &tmpNewline);
        if ( reloading[0] || popped_doc || tmpNewline < 0 )
          newdoc.link = tmpDocInfo.link;
        else
          Newline = tmpNewline;
        v56 = getresult;
        if ( getresult == 1 )
          break;
        if ( v56 != 3 )
        {
          if ( v56 )
            goto LABEL_224;
          LYoverride_no_cache = 0;
          LYinternal_flag = 0;
          turn_trace_back_on(&trace_mode_flag);
          if ( !first_file && !LYCancelledFetch )
          {
            if ( error_logging
              && nhist > 0
              && !popped_doc
              && !LYUserSpecifiedURL
              && HTMainText
              && nlinks > 0
              && curdoc.link < nlinks )
            {
              a = newdoc.address ? newdoc.address : (char *)&byte_81534E7;
              if ( strncasecomp(a, "LYNXHIST:", 9) )
              {
                v58 = newdoc.address ? newdoc.address : (char *)&byte_81534E7;
                if ( strncasecomp(v58, "LYNXCOOKIE:", 11) )
                {
                  mail_owner = 0;
                  if ( owner_address && !strncasecomp(owner_address, "mailto:", 7) )
                    mail_owner = owner_address + 7;
                  if ( mail_owner )
                    mailmsg(curdoc.link, mail_owner, history[nhist - 1].hdoc.address, history[nhist - 1].hdoc.title);
                }
              }
            }
            if ( traversal )
            {
              ofp = LYAppendToTxtFile("traverse.errors");
              if ( !ofp )
              {
                ofp = LYNewTxtFile("traverse.errors");
                if ( !ofp )
                {
                  v9 = gettext("Unable to open traversal errors output file");
                  perror(v9);
                  exit_immediately(1);
                }
              }
              if ( nhist <= 0 )
              {
                target = links[curdoc.link].target;
                if ( popped_doc )
                  lname = newdoc.address;
                else
                  lname = links[curdoc.link].lname;
                fprintf(ofp, "%s %s\t\n", lname, target);
              }
              else
              {
                v59 = history[nhist - 1].hdoc.address;
                v60 = links[curdoc.link].target;
                if ( popped_doc )
                  v61 = newdoc.address;
                else
                  v61 = links[curdoc.link].lname;
                fprintf(ofp, "%s %s\tin %s\n", v61, v60, v59);
              }
              LYCloseOutput(ofp);
            }
          }
          if ( !nhist )
          {
            exit_immediately_with_error_message(0, first_file);
            return 1;
          }
        }
        LYoverride_no_cache = 0;
        popped_doc = 0;
        LYinternal_flag = 0;
        turn_trace_back_on(&trace_mode_flag);
        free_address(&newdoc);
        if ( newdoc.bookmark )
        {
          free(newdoc.bookmark);
          newdoc.bookmark = 0;
        }
        LYJumpFileURL = 0;
        reloading[0] = 0;
        LYPermitURL = 0;
        LYCancelledFetch = 0;
        ForcePush = 0;
        LYforce_HTML_mode = 0;
        force_old_UCLYhndl_on_reload[0] = 0;
        if ( traversal )
        {
          crawl_ok = 0;
          if ( traversal_link_to_add )
          {
            if ( !lookup_reject(traversal_link_to_add) )
              add_to_reject_list(traversal_link_to_add);
            if ( traversal_link_to_add )
            {
              free(traversal_link_to_add);
              traversal_link_to_add = 0;
            }
          }
        }
        if ( nhist )
        {
          LYforce_no_cache = 0;
          if ( !history[nhist - 1].hdoc.post_data || history[nhist - 1].hdoc.safe )
          {
            override_LYresubmit_posts = 1;
          }
          else
          {
            if ( !HText_POSTReplyLoaded(&history[nhist - 1].hdoc) )
            {
              if ( curdoc.address )
              {
                copy_address(&newdoc, &curdoc);
                HTSACopy(&newdoc.title, curdoc.title);
                if ( curdoc.post_data )
                  v67 = curdoc.post_data->len;
                else
                  v67 = 0;
                if ( curdoc.post_data )
                  str = curdoc.post_data->str;
                else
                  str = 0;
                HTSABCopy(&newdoc.post_data, str, v67);
                HTSACopy(&newdoc.post_content_type, curdoc.post_content_type);
                newdoc.isHEAD = curdoc.isHEAD;
                newdoc.safe = curdoc.safe;
                newdoc.internal_link = curdoc.internal_link;
                newdoc.line = curdoc.line;
                newdoc.link = curdoc.link;
              }
              else
              {
                v10 = HTLoadedDocumentURL();
                set_address(&newdoc, v10);
                v11 = HTLoadedDocumentTitle();
                HTSACopy(&newdoc.title, v11);
                if ( HTMainAnchor && HTMainAnchor->post_data )
                {
                  v65 = HTMainAnchor->post_data->len;
                  if ( HTMainAnchor->post_data )
                    src = HTMainAnchor->post_data->str;
                  else
                    src = 0;
                  HTSABCopy(&newdoc.post_data, src, v65);
                  HTSACopy(&newdoc.post_content_type, HTMainAnchor->post_content_type);
                }
                else
                {
                  HTSABFree(&newdoc.post_data);
                }
                newdoc.isHEAD = HTLoadedDocumentIsHEAD();
                newdoc.safe = HTLoadedDocumentIsSafe();
                newdoc.internal_link = 0;
              }
              cmd = 37;
              goto new_cmd;
            }
            override_LYresubmit_posts = 1;
          }
        }
        else
        {
          if ( !first_file || !homepage || !strcmp(homepage, startfile) )
          {
            exit_immediately_with_error_message(3, first_file);
            return 1;
          }
          set_address(&newdoc, homepage);
          LYFreePostData(&newdoc);
          if ( newdoc.bookmark )
          {
            free(newdoc.bookmark);
            newdoc.bookmark = 0;
          }
          HTSACopy(&startfile, homepage);
          newdoc.isHEAD = 0;
          newdoc.safe = 0;
          newdoc.internal_link = 0;
        }
      }
      LYoverride_no_cache = 0;
      LYinternal_flag = 0;
      turn_trace_back_on(&trace_mode_flag);
      if ( first_file != 1 || dump_output_immediately || newdoc.bookmark && *newdoc.bookmark )
        break;
      if ( LYisLocalFile(newdoc.address) != 1 )
        break;
      s2 = gettext("Bookmark file");
      v70 = (char *)(HText_getTitle() ? HText_getTitle() : &byte_81534E7);
      if ( strcmp(v70, s2) )
        break;
      temp = HTParse(newdoc.address, &byte_81534E7, 5);
      if ( !temp )
        break;
      v12 = Home_Dir();
      name = wwwName(v12);
      len = strlen(name);
      if ( strncmp(temp, name, len) )
        goto LABEL_200;
      v13 = strlen(temp);
      if ( v13 <= len )
        goto LABEL_200;
      cp = 0;
      if ( temp[len] == 47 )
      {
        if ( strchr(&temp[len + 1], 47) )
          HTSprintf0(&cp, ".%s", &temp[len]);
        else
          HTSACopy(&cp, &temp[len + 1]);
      }
      else
      {
        HTSACopy(&cp, &temp[len]);
      }
      for ( i = 0; i <= 25; ++i )
      {
        if ( MBM_A_subbookmark[i] && !strcmp(cp, MBM_A_subbookmark[i]) )
        {
          HTSACopy(&BookmarkPage, MBM_A_subbookmark[i]);
          break;
        }
      }
      if ( cp )
      {
        free(cp);
        cp = 0;
      }
      if ( i > 25 )
        goto LABEL_200;
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      if ( LYValidate )
      {
        v14 = gettext("Bookmark features are currently disabled.");
        HTAlert(v14);
        return 1;
      }
      temp = HTParse(newdoc.address, &byte_81534E7, 25);
      if ( !temp )
      {
LABEL_200:
        cp = 0;
        break;
      }
      set_address(&newdoc, temp);
      HTuncache_current_document();
      free_address(&curdoc);
      v15 = Home_Dir();
      v16 = wwwName(v15);
      HTSACat(&newdoc.address, v16);
      HTSACat(&newdoc.address, "/");
      if ( !strncmp(BookmarkPage, "./", 2u) )
        v71 = BookmarkPage + 2;
      else
        v71 = BookmarkPage;
      HTSACat(&newdoc.address, v71);
      v17 = gettext("Bookmark file");
      HTSACopy(&newdoc.title, v17);
      HTSACopy(&newdoc.bookmark, BookmarkPage);
      if ( curdoc.style )
        HTSACopy(&newdoc.style, curdoc.style);
      HTSACopy(&startrealm, newdoc.address);
      LYFreePostData(&newdoc);
      newdoc.isHEAD = 0;
      newdoc.safe = 0;
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      if ( !strcmp(homepage, startfile) )
        HTSACopy(&homepage, newdoc.address);
      HTSACopy(&startfile, newdoc.address);
      if ( WWW_TraceFlag[0] )
      {
        v18 = newdoc.address;
        v19 = TraceFP();
        fprintf(v19, "Reloading as bookmarks=%s\n", v18);
      }
    }
    if ( temp )
    {
      free(temp);
      temp = 0;
    }
    if ( traversal )
    {
      if ( traversal_link_to_add )
      {
        if ( !lookup_link(traversal_link_to_add) )
          add_to_table(traversal_link_to_add);
        if ( traversal_link_to_add )
        {
          free(traversal_link_to_add);
          traversal_link_to_add = 0;
        }
      }
      if ( curdoc.address && curdoc.title && strncasecomp(curdoc.address, "LYNXIMGMAP:", 11) )
        add_to_traverse_list(curdoc.address, curdoc.title);
    }
    if ( newdoc.address && curdoc.address && !strncasecomp(newdoc.address, "LYNXDOWNLOAD:", 13) )
    {
      copy_address(&newdoc, &curdoc);
      if ( curdoc.title )
        title = curdoc.title;
      else
        title = (char *)&byte_81534E7;
      HTSACopy(&newdoc.title, title);
      HTSACopy(&newdoc.bookmark, curdoc.bookmark);
      newdoc.line = curdoc.line;
      newdoc.link = curdoc.link;
      newdoc.internal_link = 0;
    }
    display_partial[0] = 0;
    if ( Newline > 1 || popped_doc == 1 )
      www_search_result = -1;
    curdoc.line = -1;
LABEL_224:
    if ( WWW_TraceFlag[0] && (!LYTraceLogFP || trace_mode_flag) )
      LYSleepAlert();
    copy_address(&curdoc, &newdoc);
    if ( newdoc.post_data )
      v73 = newdoc.post_data->len;
    else
      v73 = 0;
    if ( newdoc.post_data )
      v74 = newdoc.post_data->str;
    else
      v74 = 0;
    HTSABCopy(&curdoc.post_data, v74, v73);
    HTSACopy(&curdoc.post_content_type, newdoc.post_content_type);
    HTSACopy(&curdoc.bookmark, newdoc.bookmark);
    Style = HText_getStyle();
    HTSACopy(&curdoc.style, Style);
    if ( curdoc.style )
      style_readFromFile(curdoc.style);
    curdoc.isHEAD = newdoc.isHEAD;
    curdoc.internal_link = newdoc.internal_link;
    if ( ownerS_address )
    {
      if ( LYpsrc )
        v75 = psrc_view != 0;
      else
        v75 = HTOutputFormat == WWW_SOURCE;
      if ( v75 && !HText_getOwner() )
        HText_setMainTextOwner(ownerS_address);
      if ( ownerS_address )
      {
        free(ownerS_address);
        ownerS_address = 0;
      }
    }
    if ( HText_getTitle() )
    {
      v21 = HText_getTitle();
      HTSACopy(&curdoc.title, v21);
    }
    else if ( !dump_output_immediately )
    {
      HTSACopy(&curdoc.title, newdoc.title);
    }
    Owner = HText_getOwner();
    HTSACopy(&owner_address, Owner);
    curdoc.safe = HTLoadedDocumentIsSafe();
    if ( !dump_output_immediately )
      LYAddVisitedLink(&curdoc);
    HTOutputFormat = HTAtom_for("www/present");
    psrc_view = 0;
    HTMLSetCharacterHandling(current_char_set);
    LYUserSpecifiedURL = 0;
    LYJumpFileURL = 0;
    LYNoRefererForThis = 0;
    reloading[0] = 0;
    HEAD_request = 0;
    LYPermitURL = 0;
    ForcePush = 0;
    LYforce_HTML_mode = 0;
    force_old_UCLYhndl_on_reload[0] = 0;
    popped_doc = 0;
    pending_form_c = -1;
  }
  if ( dump_output_immediately )
  {
    if ( crawl )
    {
      print_crawl_to_fd(stdout, curdoc.address, curdoc.title);
    }
    else if ( !dump_links_only )
    {
      print_wwwfile_to_fd(stdout, 0, 0);
    }
    return dump_server_status > 399;
  }
  if ( recent_sizechange )
  {
    resizeterm(LYlines, LYcols);
    wresize(LYwin, LYlines, LYcols);
    refresh_screen = 1;
    if ( HTMainText )
      HText_setStale(HTMainText);
    recent_sizechange = 0;
    LYSetDisplayLines();
  }
  if ( www_search_result != -1 )
  {
    Newline = www_search_result;
    www_search_result = -1;
  }
  if ( first_file == 1 )
  {
    first_file = 0;
    temp = HTParse(curdoc.address, &byte_81534E7, 25);
    if ( temp && *temp )
    {
      HTSACopy(&startrealm, temp);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      temp = HTParse(curdoc.address, &byte_81534E7, 5);
      if ( temp )
      {
        if ( forced_HTML_mode
          && !dump_output_immediately
          && !curdoc.bookmark
          && (*curdoc.address == 102 || *curdoc.address == 70)
          && !strncasecomp(curdoc.address, "file:", 5)
          && strlen(temp) > 1 )
        {
          v24 = HTFileFormat(temp, &encoding, 0);
          if ( v24 != HTAtom_for("text/html") )
            HTSetSuffix5(temp, "text/html", "8bit", 0, 1.0);
        }
        cp = strrchr(temp, 47);
        if ( cp )
        {
          cp[1] = 0;
          HTSACat(&startrealm, temp);
        }
      }
      else
      {
        LYAddHtmlSep(&startrealm);
      }
    }
    else
    {
      v23 = gettext("None");
      HTSACopy(&startrealm, v23);
    }
    if ( temp )
    {
      free(temp);
      temp = 0;
    }
    if ( WWW_TraceFlag[0] )
    {
      v25 = startrealm;
      v26 = TraceFP();
      fprintf(v26, "Starting realm is '%s'\n\n", v25);
    }
    if ( traversal )
    {
      if ( curdoc.address && !lookup_link(curdoc.address) )
      {
        if ( strncasecomp(curdoc.address, "LYNXIMGMAP:", 11) )
          crawl_ok = 1;
        add_to_table(curdoc.address);
      }
      if ( curdoc.address )
        v76 = curdoc.address;
      else
        v76 = "NULL";
      if ( !strncmp(v76, "http", 4u) )
      {
        if ( check_realm )
        {
          HTSACopy(&traversal_host, startrealm);
        }
        else
        {
          temp = HTParse(curdoc.address, &byte_81534E7, 25);
          if ( temp && *temp )
          {
            HTSACopy(&traversal_host, temp);
            LYAddHtmlSep(&traversal_host);
          }
          else
          {
            v28 = gettext("None");
            HTSACopy(&traversal_host, v28);
          }
          if ( temp )
          {
            free(temp);
            temp = 0;
          }
        }
      }
      else
      {
        v27 = gettext("None");
        HTSACopy(&traversal_host, v27);
      }
      if ( WWW_TraceFlag[0] )
      {
        v29 = traversal_host;
        v30 = TraceFP();
        fprintf(v30, "Traversal host is '%s'\n\n", v29);
      }
    }
    if ( startfile )
    {
      if ( homepage && strcmp(startfile, homepage) )
        HTAddGotoURL(homepage);
      if ( strcmp(startfile, newdoc.address) || !newdoc.post_data )
        HTAddGotoURL(startfile);
    }
    if ( WWW_TraceFlag[0] )
    {
      refresh_screen = 1;
      if ( !LYTraceLogFP || trace_mode_flag )
        LYSleepAlert();
    }
  }
  if ( HTdocument_settings_changed() && (unsigned __int8)HTcan_reparse_document() )
  {
    v31 = gettext("Reparsing document under current settings...");
    HTInfoMsg(v31);
    reparse_document();
  }
  if ( from_source_cache[0] )
  {
    from_source_cache[0] = 0;
    curdoc.line = -1;
  }
  if ( curdoc.line == Newline )
  {
    if ( newdoc.link < 0 )
      newdoc.link = 0;
  }
  else
  {
    refresh_screen = 0;
    HText_pageDisplay(Newline, prev_target);
    if ( lynx_edit_mode && nlinks > 0 && tagged && tagged->next )
      showtags(tagged);
    more_text = HText_canScrollDown();
    if ( newdoc.link < 0 )
      goto_line(Newline);
    Newline = HText_getTopOfScreen() + 1;
    curdoc.line = Newline;
    if ( !curdoc.title )
    {
      if ( HText_getTitle() )
      {
        v32 = HText_getTitle();
        HTSACopy(&curdoc.title, v32);
      }
      else
      {
        HTSACopy(&curdoc.title, newdoc.title);
      }
    }
    if ( newdoc_link_is_absolute )
    {
      newdoc_link_is_absolute = 0;
      if ( curdoc.line > 1 )
      {
        link = newdoc.link;
        newdoc.link = link - HText_LinksInLines(HTMainText, 1, curdoc.line - 1);
      }
    }
    if ( arrowup )
    {
      curdoc.link = nlinks - 1;
      arrowup = 0;
    }
    else
    {
      curdoc.link = newdoc.link;
      if ( newdoc.link < nlinks )
      {
        if ( curdoc.link < 0 && nlinks > 0 )
          curdoc.link = 0;
      }
      else
      {
        curdoc.link = nlinks - 1;
      }
    }
    show_help = 0;
    newdoc.line = 1;
    newdoc.link = 0;
    curdoc.line = Newline;
  }
  if ( refresh_screen )
  {
    if ( enable_scrollback )
      LYclear();
    else
      LYerase();
    HText_pageDisplay(Newline, prev_target);
    if ( lynx_edit_mode && nlinks > 0 && tagged && tagged->next )
      showtags(tagged);
    more_text = HText_canScrollDown();
    if ( curdoc.link < nlinks )
    {
      if ( curdoc.link < 0 && nlinks > 0 )
        curdoc.link = 0;
    }
    else
    {
      curdoc.link = nlinks - 1;
    }
    if ( !user_mode )
      noviceline(more_text);
    refresh_screen = 0;
  }
  v77 = nlinks > 0
     && links[curdoc.link].type == 1
     && (links[curdoc.link].l_form->type == 1
      || links[curdoc.link].l_form->type == 12
      || links[curdoc.link].l_form->type == 2
      || links[curdoc.link].l_form->type == 11
      || links[curdoc.link].l_form->type == 9);
  curlink_is_editable = v77;
  v78 = v77 && (real_cmd == 28 || real_cmd == 29);
  use_last_tfpos = v78;
  if ( !textfields_need_activation )
    textinput_activated = 1;
  if ( check_mail && !no_mail )
    LYCheckMail();
  if ( show_help )
  {
    show_help = 0;
  }
  else
  {
    if ( curlink_is_editable && textinput_activated )
      for_what = 2;
    else
      for_what = 0;
    v55 = &v45;
    v54 = (const void *)(68 * curdoc.link + 136026784);
    v53 = 17;
    qmemcpy(&v45, v54, sizeof(v45));
    show_main_statusline(v45, for_what);
  }
  if ( nlinks > 0 && (!curlink_is_editable || !textinput_activated) )
    LYhighlight(1, curdoc.link, prev_target);
  if ( !traversal )
  {
    if ( !curlink_is_editable || !textinput_activated && pending_form_c == -1 )
    {
      c = LYgetch();
      real_c = c;
      if ( c != last_key )
        key_count = 0;
      ++key_count;
      last_key = c;
      if ( c == 3 )
      {
        signal(2, cleanup_sig);
        old_c = 0;
        cmd = 13;
        goto new_cmd;
      }
      if ( c >= 0 && (c & 0x8000) == 0 && (c & 0x2000) != 0 && EditBinding(c) != 6 )
      {
        v89 = c & 0xFFFFF800;
        if ( LYReverseKeymap(0) < 0 )
          v90 = 2048;
        else
          v90 = LYReverseKeymap(0);
        c = v90 | v89;
      }
      if ( old_c != real_c )
        old_c = 0;
      goto LABEL_578;
    }
    if ( pending_form_c == -1 )
    {
      if ( !user_mode )
        form_noviceline(links[curdoc.link].l_form->disabled);
      real_c = change_form_link(curdoc.link, &newdoc, &refresh_screen, use_last_tfpos, 0);
    }
    else
    {
      real_c = pending_form_c;
      pending_form_c = -1;
    }
    if ( textfields_need_activation )
      textinput_activated = 0;
    if ( real_c == 2046 )
    {
      v82 = 270;
    }
    else
    {
      if ( (real_c & 0x8000) != 0 )
      {
        v83 = real_c;
      }
      else
      {
        if ( (real_c & 0x800) != 0 )
        {
          if ( LYReverseKeymap((unsigned __int8)real_c) < 0 )
            v85 = (unsigned __int8)real_c | 0x800;
          else
            v85 = LYReverseKeymap((unsigned __int8)real_c);
          v84 = v85;
        }
        else
        {
          v84 = real_c & 0x7FF;
        }
        v83 = v84;
      }
      v82 = v83;
    }
    c = v82;
    if ( v82 != 270 && peek_mouse_link() != -1 && peek_mouse_link() != -2 )
      old_c = 0;
    if ( peek_mouse_link() >= 0 )
    {
      if ( real_c == -1 )
      {
        if ( keymap[0] != 84 )
          goto LABEL_443;
      }
      else if ( (real_c & 0x8800) != 0 )
      {
        if ( (unsigned __int8)real_c != 84 )
        {
LABEL_443:
          do_change_link();
          if ( (c == 10 || c == 13)
            && links[curdoc.link].type == 1
            && (links[curdoc.link].l_form->type == 1
             || links[curdoc.link].l_form->type == 12
             || links[curdoc.link].l_form->type == 2
             || links[curdoc.link].l_form->type == 11
             || links[curdoc.link].l_form->type == 9)
            && !textfields_need_activation )
          {
            c = 270;
          }
          goto LABEL_578;
        }
      }
      else if ( keymap[(real_c & 0x7FF) + 1] != 84 )
      {
        goto LABEL_443;
      }
    }
    if ( links[curdoc.link].type != 1
      || links[curdoc.link].l_form->type != 9
      || !textfields_need_activation
      || links[curdoc.link].l_form->disabled
      || peek_mouse_link() >= 0 )
    {
      goto LABEL_533;
    }
    if ( real_c == -1 )
    {
      if ( keymap[0] == 27 )
        goto LABEL_486;
    }
    else if ( (real_c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)real_c == 27 )
        goto LABEL_486;
    }
    else if ( keymap[(real_c & 0x7FF) + 1] == 27 )
    {
      goto LABEL_486;
    }
    if ( real_c == -1 )
    {
      if ( keymap[0] == 39 )
        goto LABEL_486;
    }
    else if ( (real_c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)real_c == 39 )
        goto LABEL_486;
    }
    else if ( keymap[(real_c & 0x7FF) + 1] == 39 )
    {
      goto LABEL_486;
    }
    if ( real_c == -1 )
    {
      if ( keymap[0] == 29 )
        goto LABEL_486;
    }
    else if ( (real_c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)real_c == 29 )
        goto LABEL_486;
    }
    else if ( keymap[(real_c & 0x7FF) + 1] == 29 )
    {
      goto LABEL_486;
    }
    if ( real_c == -1 )
    {
      if ( keymap[0] != 33 )
        goto LABEL_494;
    }
    else if ( (real_c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)real_c != 33 )
        goto LABEL_494;
    }
    else if ( keymap[(real_c & 0x7FF) + 1] != 33 )
    {
      goto LABEL_494;
    }
LABEL_486:
    if ( curdoc.link < nlinks - 1
      && links[curdoc.link + 1].type == 1
      && links[curdoc.link + 1].l_form->type == 9
      && links[curdoc.link].l_form->number == links[curdoc.link + 1].l_form->number
      && !strcmp(links[curdoc.link].l_form->name, links[curdoc.link + 1].l_form->name)
      || curdoc.link == nlinks - 1 && more_text && HText_TAHasMoreLines(curdoc.link, 1) )
    {
      goto LABEL_523;
    }
LABEL_494:
    if ( real_c == -1 )
    {
      if ( keymap[0] == 26 )
        goto LABEL_515;
    }
    else if ( (real_c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)real_c == 26 )
        goto LABEL_515;
    }
    else if ( keymap[(real_c & 0x7FF) + 1] == 26 )
    {
      goto LABEL_515;
    }
    if ( real_c == -1 )
    {
      if ( keymap[0] != 28 )
        goto LABEL_508;
    }
    else if ( (real_c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)real_c != 28 )
      {
LABEL_508:
        if ( real_c == -1 )
        {
          if ( keymap[0] != 32 )
            goto LABEL_533;
        }
        else if ( (real_c & 0x8800) != 0 )
        {
          if ( (unsigned __int8)real_c != 32 )
            goto LABEL_533;
        }
        else if ( keymap[(real_c & 0x7FF) + 1] != 32 )
        {
          goto LABEL_533;
        }
      }
    }
    else if ( keymap[(real_c & 0x7FF) + 1] != 28 )
    {
      goto LABEL_508;
    }
LABEL_515:
    if ( curdoc.link > 0
      && links[curdoc.link - 1].type == 1
      && links[curdoc.link - 1].l_form->type == 9
      && links[curdoc.link].l_form->number == links[curdoc.link - 1].l_form->number
      && !strcmp(links[curdoc.link].l_form->name, links[curdoc.link - 1].l_form->name)
      || !curdoc.link && curdoc.line > 1 && HText_TAHasMoreLines(curdoc.link, -1) )
    {
LABEL_523:
      textinput_activated = 1;
      if ( c == 10 || c == 13 )
      {
        if ( real_c == -1 )
        {
          v86 = keymap[0] == 39;
        }
        else
        {
          v87 = (real_c & 0x8800) != 0 ? (unsigned __int8)real_c == 39 : keymap[(real_c & 0x7FF) + 1] == 39;
          v86 = v87;
        }
        if ( v86 )
          c = 2075;
      }
      goto LABEL_578;
    }
LABEL_533:
    v88 = c;
    if ( c == 10 || v88 == 13 )
    {
      if ( links[curdoc.link].type == 1
        && links[curdoc.link].l_form->type == 9
        && (curdoc.link == nlinks - 1 && (!more_text || !HText_TAHasMoreLines(curdoc.link, 1))
         || curdoc.link < nlinks - 1 && (links[curdoc.link + 1].type != 1 || links[curdoc.link + 1].l_form->type != 9)
         || curdoc.link < nlinks - 1
         && links[curdoc.link + 1].type == 1
         && links[curdoc.link + 1].l_form->type == 9
         && (links[curdoc.link].l_form->number != links[curdoc.link + 1].l_form->number
          || strcmp(links[curdoc.link].l_form->name, links[curdoc.link + 1].l_form->name))) )
      {
        HText_ExpandTextarea((LinkInfo *)(68 * curdoc.link + 136026784), 1);
        if ( links[curdoc.link].ly >= display_lines )
        {
          Newline += display_lines / 2;
          if ( nlinks > 0 && curdoc.link >= 0 && links[curdoc.link].ly > display_lines / 2 )
          {
            newdoc.link = curdoc.link;
            for ( i = 0; links[i].ly <= display_lines / 2; ++i )
              --newdoc.link;
            ++newdoc.link;
          }
        }
        else
        {
          refresh_screen = 1;
        }
        if ( textfields_need_activation )
        {
          textinput_activated = 1;
          textfields_need_activation = textfields_activation_option;
        }
      }
      c = 2075;
    }
    else if ( old_c != c && old_c != real_c && c != real_c )
    {
      real_c = c;
    }
    goto LABEL_578;
  }
  if ( crawl && crawl_ok )
  {
    crawl_ok = 0;
    sprintf(cfile, "lnk%08d.dat", crawl_count);
    ++crawl_count;
    cfp = LYNewTxtFile(cfile);
    if ( !cfp )
    {
      if ( !dump_output_immediately )
        cleanup();
      format = gettext("Fatal error - could not open output file %s\n");
      if ( dump_output_immediately )
        stream = stderr;
      else
        stream = stdout;
      fprintf(stream, format, cfile);
      if ( !dump_output_immediately )
        exit_immediately(1);
      return 1;
    }
    print_crawl_to_fd(cfp, curdoc.address, curdoc.title);
    LYCloseOutput(cfp);
  }
LABEL_578:
  if ( recent_sizechange && c <= 0 )
    c = 270;
new_keyboard_input:
  if ( !traversal || (c = DoTraversal(c, &crawl_ok), c >= 0) )
  {
    if ( c == -1 )
    {
      v91 = keymap[0];
    }
    else
    {
      if ( (c & 0x8800) != 0 )
        v92 = (unsigned __int8)c;
      else
        v92 = keymap[(c & 0x7FF) + 1];
      v91 = v92;
    }
    cmd = v91;
    if ( lynx_edit_mode && !no_dired_support[0] )
    {
      if ( c == -1 )
      {
        v93 = key_override[0] != 0;
      }
      else
      {
        v94 = (c & 0x8800) != 0 ? (unsigned __int8)c != 0 : key_override[(c & 0x7FF) + 1] != 0;
        v93 = v94;
      }
      if ( v93 )
      {
        if ( c == -1 )
        {
          v95 = key_override[0];
        }
        else
        {
          if ( (c & 0x8800) != 0 )
            v96 = (unsigned __int8)c;
          else
            v96 = key_override[(c & 0x7FF) + 1];
          v95 = v96;
        }
        cmd = v95;
      }
    }
    real_cmd = cmd;
    while ( 1 )
    {
new_cmd:
      force_old_UCLYhndl_on_reload[0] = 0;
      if ( WWW_TraceFlag[0] )
      {
        v34 = TraceFP();
        fflush(v34);
      }
      if ( cmd != 32 && cmd != 33 )
        follow_col = -1;
      v52 = cmd + 1;
      switch ( cmd )
      {
        case -1:
          v35 = gettext("Unknown or ambiguous command");
          HTUserMsg(v35);
          goto LABEL_24;
        case 1:
          cmd = handle_LYK_COMMAND(user_input_buffer);
          continue;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          goto LABEL_633;
        case 11:
          handle_LYK_SOURCE(&ownerS_address);
          goto LABEL_24;
        case 12:
          goto LABEL_639;
        case 13:
          if ( !(unsigned __int8)handle_LYK_QUIT() )
            goto LABEL_24;
          return 0;
        case 14:
          return 0;
        case 15:
          handle_LYK_NEXT_PAGE(&old_c, real_c);
          goto LABEL_24;
        case 16:
          handle_LYK_PREV_PAGE(&old_c, real_c);
          goto LABEL_24;
        case 17:
          handle_LYK_UP_TWO(&arrowup, &old_c, real_c);
          goto LABEL_24;
        case 18:
          handle_LYK_DOWN_TWO(&old_c, real_c);
          goto LABEL_24;
        case 19:
          handle_LYK_UP_HALF(&arrowup, &old_c, real_c);
          goto LABEL_24;
        case 20:
          handle_LYK_DOWN_HALF(&old_c, real_c);
          goto LABEL_24;
        case 21:
          refresh_screen = 1;
          lynx_force_repaint();
          goto LABEL_24;
        case 22:
          if ( curdoc.line > 1 )
          {
            Newline = 1;
            goto LABEL_24;
          }
          cmd = 16;
          continue;
        case 23:
          i = HText_getNumOfLines() - display_lines + 2;
          if ( i > 0 && Newline != i )
          {
            Newline = i;
            arrowup = 1;
            goto LABEL_24;
          }
          cmd = 15;
          break;
        case 24:
          handle_LYK_FIRST_LINK();
          goto LABEL_24;
        case 25:
          handle_LYK_LAST_LINK();
          goto LABEL_24;
        case 26:
        case 28:
          handle_LYK_PREV_LINK(&arrowup, &old_c, real_c);
          goto LABEL_24;
        case 27:
        case 29:
          handle_LYK_NEXT_LINK(c, &old_c, real_c);
          goto LABEL_24;
        case 30:
          if ( !handle_LYK_FASTBACKW_LINK(&cmd, &old_c, real_c) )
            goto LABEL_24;
          continue;
        case 31:
          handle_LYK_FASTFORW_LINK(&old_c, real_c);
          goto LABEL_24;
        case 32:
          handle_LYK_UP_LINK(&follow_col, &arrowup, &old_c, real_c);
          goto LABEL_24;
        case 33:
          handle_LYK_DOWN_LINK(&follow_col, &old_c, real_c);
          goto LABEL_24;
        case 34:
          handle_LYK_RIGHT_LINK();
          goto LABEL_24;
        case 35:
          handle_LYK_LEFT_LINK();
          goto LABEL_24;
        case 36:
          if ( !handle_LYK_HISTORY(ForcePush) )
            goto LABEL_731;
          goto LABEL_24;
        case 37:
LABEL_731:
          v97 = handle_PREV_DOC(&cmd, &old_c, real_c);
          if ( v97 == 1 )
            return 0;
          if ( v97 != 2 )
            goto LABEL_24;
          continue;
        case 38:
          handle_NEXT_DOC();
          goto LABEL_24;
        case 39:
        case 40:
          goto LABEL_737;
        case 41:
          if ( handle_LYK_GOTO(
                 &ch_0,
                 user_input_buffer,
                 &temp,
                 &recall,
                 &URLTotal,
                 &URLNum,
                 &FirstURLRecall,
                 &old_c,
                 real_c)
            && do_check_recall(ch_0, user_input_buffer, &temp, URLTotal, &URLNum, recall, &FirstURLRecall) )
          {
            goto LABEL_801;
          }
          goto LABEL_24;
        case 42:
          if ( handle_LYK_ECGOTO(&ch_0, user_input_buffer, &temp, &old_c, real_c) )
            goto LABEL_801;
          goto LABEL_24;
        case 43:
          goto LABEL_748;
        case 44:
          handle_LYK_DWIMHELP(&cshelpfile);
LABEL_748:
          handle_LYK_HELP(&cshelpfile);
          goto LABEL_24;
        case 45:
          handle_LYK_INDEX(&old_c, real_c);
          goto LABEL_24;
        case 46:
          if ( !handle_LYK_NOCACHE(&old_c, real_c) )
            goto LABEL_24;
LABEL_737:
          v98 = handle_LYK_ACTIVATE(&c, cmd, &try_internal, &refresh_screen, &force_load, real_cmd);
          if ( v98 == 2 )
            goto new_keyboard_input;
          if ( v98 == 3 )
            pending_form_c = c;
          goto LABEL_24;
        case 47:
        case 69:
          goto LABEL_24;
        case 48:
          handle_LYK_MAIN_MENU(&old_c, real_c);
          goto LABEL_24;
        case 49:
          if ( !handle_LYK_OPTIONS(&cmd, &refresh_screen) )
            goto LABEL_24;
          continue;
        case 50:
          handle_LYK_INDEX_SEARCH(&force_load, ForcePush, &old_c, real_c);
          goto LABEL_24;
        case 51:
        case 52:
        case 53:
          handle_LYK_WHEREIS(cmd, &refresh_screen);
          goto LABEL_24;
        case 54:
          handle_LYK_COMMENT(&refresh_screen, &owner_address, &old_c, real_c);
          goto LABEL_24;
        case 55:
          goto LABEL_763;
        case 56:
          if ( !handle_LYK_INFO(&cmd) )
            goto LABEL_24;
          continue;
        case 57:
          handle_LYK_PRINT(&ForcePush, &old_c, real_c);
          goto LABEL_24;
        case 58:
          handle_LYK_ADD_BOOKMARK(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 59:
          handle_LYK_DEL_BOOKMARK(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 60:
          handle_LYK_VIEW_BOOKMARK(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 61:
          if ( !handle_LYK_VLINKS(&cmd, &newdoc_link_is_absolute) )
            goto LABEL_24;
          continue;
        case 62:
          handle_LYK_SHELL(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 63:
          v100 = handle_LYK_DOWNLOAD(&cmd, &old_c, real_c);
          if ( v100 == 1 || v100 != 2 )
            goto LABEL_24;
          continue;
        case 64:
          handle_LYK_TRACE_TOGGLE();
          goto LABEL_24;
        case 65:
          handle_LYK_TRACE_LOG(&trace_mode_flag);
          goto LABEL_24;
        case 66:
          if ( !handle_LYK_IMAGE_TOGGLE(&cmd) )
            goto LABEL_24;
          continue;
        case 67:
          if ( !handle_LYK_INLINE_TOGGLE(&cmd) )
            goto LABEL_24;
          continue;
        case 68:
          if ( !handle_LYK_HEAD(&cmd) )
            goto LABEL_24;
          continue;
        case 70:
          handle_LYK_TOGGLE_HELP();
          goto LABEL_24;
        case 71:
          if ( handle_LYK_JUMP(
                 c,
                 user_input_buffer,
                 &temp,
                 &recall,
                 &FirstURLRecall,
                 &URLNum,
                 &URLTotal,
                 &ch_0,
                 &old_c,
                 real_c)
            && do_check_recall(ch_0, user_input_buffer, &temp, URLTotal, &URLNum, recall, &FirstURLRecall) )
          {
            goto LABEL_801;
          }
          goto LABEL_24;
        case 72:
          handle_LYK_KEYMAP(&vi_keys_flag, &emacs_keys_flag, &old_c, real_c);
          goto LABEL_24;
        case 73:
          if ( !handle_LYK_LIST(&cmd) )
            goto LABEL_24;
          continue;
        case 74:
          handle_LYK_TOOLBAR(&try_internal, &force_load, &old_c, real_c);
          goto LABEL_24;
        case 75:
          handle_LYK_HISTORICAL();
          goto LABEL_24;
        case 76:
          handle_LYK_MINIMAL();
          goto LABEL_24;
        case 77:
          handle_LYK_SOFT_DQUOTES();
          goto LABEL_24;
        case 78:
          if ( !handle_LYK_RAW_TOGGLE(&cmd) )
            goto LABEL_24;
          continue;
        case 79:
          if ( !handle_LYK_COOKIE_JAR(&cmd) )
            goto LABEL_24;
          continue;
        case 80:
          c = 0;
LABEL_633:
          handle_LYK_digit(c, &force_load, user_input_buffer, &old_c, real_c, &try_internal);
          goto LABEL_24;
        case 81:
          handle_LYK_CLEAR_AUTH(&old_c, real_c);
          goto LABEL_24;
        case 82:
          handle_LYK_SWITCH_DTD();
          goto LABEL_24;
        case 83:
          if ( handle_LYK_ELGOTO(&ch_0, user_input_buffer, &temp, &old_c, real_c) )
LABEL_801:
            do_check_goto_URL(user_input_buffer, &temp, &force_load);
          goto LABEL_24;
        case 84:
          do_change_link();
          goto LABEL_24;
        case 85:
          v99 = handle_LYK_DWIMEDIT(&cmd, &old_c, real_c);
          if ( v99 == 1 )
            goto LABEL_24;
          if ( v99 == 2 )
            continue;
LABEL_763:
          handle_LYK_EDIT(&old_c, real_c);
          goto LABEL_24;
        case 86:
          handle_LYK_EDIT_TEXTAREA(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 87:
          handle_LYK_GROW_TEXTAREA(&refresh_screen);
          goto LABEL_24;
        case 88:
          handle_LYK_INSERT_FILE(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 89:
          handle_LYK_EXTERN_LINK(&refresh_screen);
          goto LABEL_24;
        case 90:
          handle_LYK_EXTERN_PAGE(&refresh_screen);
          goto LABEL_24;
        case 91:
          handle_LYK_DIRED_MENU(&refresh_screen, &old_c, real_c);
          goto LABEL_24;
        case 92:
          handle_LYK_CREATE();
          goto LABEL_24;
        case 93:
          handle_LYK_REMOVE(&refresh_screen);
          goto LABEL_24;
        case 94:
          handle_LYK_MODIFY(&refresh_screen);
          goto LABEL_24;
        case 95:
          handle_LYK_TAG_LINK();
          goto LABEL_24;
        case 96:
          handle_LYK_UPLOAD();
          goto LABEL_24;
        case 98:
          if ( no_table_center )
          {
            no_table_center = 0;
            v38 = gettext("TABLE center enable.");
          }
          else
          {
            no_table_center = 1;
            v38 = gettext("TABLE center disable.");
          }
          HTInfoMsg(v38);
LABEL_639:
          handle_LYK_RELOAD(real_cmd);
          goto LABEL_24;
        case 99:
          handle_LYK_CHDIR();
          goto LABEL_24;
        case 100:
          handle_LYK_SHIFT_LEFT(&refresh_screen, key_count);
          goto LABEL_24;
        case 101:
          handle_LYK_SHIFT_RIGHT(&refresh_screen, key_count);
          goto LABEL_24;
        case 102:
          if ( !handle_LYK_LINEWRAP_TOGGLE(&cmd, &refresh_screen) )
            goto LABEL_24;
          continue;
        case 103:
          if ( !no_goto || LYValidate )
          {
            s_0 = (unsigned __int8 *)get_clip_grab();
            if ( s_0 )
            {
              len2 = strlen((const char *)s_0);
              e = &s_0[len2];
              while ( s_0 < e && strchr(" \t\n\r", *s_0) )
                ++s_0;
              while ( s_0 < e && strchr(" \t\n\r", *(e - 1)) )
                --e;
              if ( *s_0 == 60 && e > s_0 && *(e - 1) == 62 )
              {
                ++s_0;
                --e;
                if ( !strncasecomp((const char *)s_0, "URL:", 4) )
                  s_0 += 4;
              }
              if ( s_0 < e )
              {
                len = e - s_0 + 1;
                if ( len <= 0x3FF )
                  len = 1024;
                buf = (char *)malloc(len);
                strncpy(buf, (const char *)s_0, e - s_0);
                buf[e - s_0] = 0;
                t = (unsigned __int8 *)buf;
                while ( s_0 < e )
                {
                  if ( strchr(" \t\n\r", *s_0) )
                  {
                    nl2 = 0;
                    s1 = s_0;
                    while ( strchr(" \t\n\r", *s_0) )
                    {
                      if ( !nl2 )
                        nl2 = *s_0 == 10;
                      ++s_0;
                    }
                    if ( !nl2 )
                    {
                      while ( s1 < s_0 )
                      {
                        if ( *s1 != 13 )
                          *t = *s1;
                        ++t;
                        ++s1;
                      }
                    }
                  }
                  else
                  {
                    *t++ = *s_0++;
                  }
                }
                *t = 0;
                get_clip_release();
                do_check_goto_URL(buf, &temp, &force_load);
                free(buf);
              }
              else
              {
                v43 = gettext("No URL in the clipboard.");
                HTInfoMsg(v43);
              }
            }
          }
          else
          {
            v42 = gettext("Goto a random URL is disallowed!");
            HTUserMsg(v42);
          }
          goto LABEL_24;
        case 104:
          if ( nlinks <= 0 || !links[curdoc.link].lname || links[curdoc.link].type == 1 )
          {
            s = curdoc.address;
          }
          else
          {
            mustshow[0] = 1;
            statusline("Copy D)ocument's or L)ink's URL to clipboard or C)ancel?");
            ch2 = LYgetch_single();
            if ( ch2 == 68 )
            {
              s = curdoc.address;
            }
            else
            {
              if ( ch2 == 67 )
                goto LABEL_24;
              s = links[curdoc.link].lname;
            }
          }
          if ( !s || !*s )
          {
            v39 = gettext("Current URL is empty.");
            HTInfoMsg(v39);
          }
          if ( put_clip(s) )
          {
            v40 = gettext("Copy to clipboard failed.");
            HTInfoMsg(v40);
          }
          else
          {
            if ( curdoc.address == s )
              v41 = gettext("Document URL put to clipboard.");
            else
              v41 = gettext("Link URL put to clipboard.");
            HTInfoMsg(v41);
          }
          goto LABEL_24;
        case 105:
          if ( !handle_LYK_NESTED_TABLES(&cmd) )
            goto LABEL_24;
          continue;
        default:
          if ( curdoc.link >= 0
            && curdoc.link < nlinks
            && links[curdoc.link].type == 1
            && (links[curdoc.link].l_form->type == 1
             || links[curdoc.link].l_form->type == 12
             || links[curdoc.link].l_form->type == 2
             || links[curdoc.link].l_form->type == 11
             || links[curdoc.link].l_form->type == 9) )
          {
            if ( textfields_need_activation )
            {
              v51 = &v45;
              v50 = (const void *)(68 * curdoc.link + 136026784);
              v49 = 17;
              qmemcpy(&v45, v50, sizeof(v45));
              show_main_statusline(v45, 0);
            }
            else
            {
              v48 = &v45;
              v47 = (const void *)(68 * curdoc.link + 136026784);
              v46 = 17;
              qmemcpy(&v45, v47, sizeof(v45));
              show_main_statusline(v45, 2);
            }
          }
          else
          {
            if ( more_text )
              v36 = gettext("-- press space for more, use arrow keys to move, '?' for help, 'q' to quit.");
            else
              v36 = gettext("Commands: Use arrow keys to move, '?' for help, 'q' to quit, '<-' to go back.");
            HTInfoMsg(v36);
          }
          show_help = 1;
          if ( WWW_TraceFlag[0] )
          {
            sprintf(cfile, "%d", c);
            v37 = strlen(cfile);
            LYwaddnstr(LYwin, cfile, v37);
            cfile[0] = 0;
          }
          goto LABEL_24;
      }
    }
  }
  return 1;
}

//----- (0808AD77) --------------------------------------------------------
int __cdecl are_different(DocInfo *doc1, DocInfo *doc2)
{
  char *cp2; // [esp+20h] [ebp-8h]
  char *cp1; // [esp+24h] [ebp-4h]

  if ( !doc1->address || !doc2->address )
    return 1;
  if ( doc1->isHEAD != doc2->isHEAD )
    return 1;
  cp1 = trimPoundSelector(doc1->address);
  cp2 = trimPoundSelector(doc2->address);
  if ( !strcmp(doc1->address, doc2->address) )
  {
    if ( cp1 )
      *cp1 = 35;
    if ( cp2 )
      *cp2 = 35;
    if ( doc1->post_data )
    {
      if ( !doc2->post_data )
        return 1;
      if ( !HTSABEql(doc1->post_data, doc2->post_data) )
        return 1;
    }
    else if ( doc2->post_data )
    {
      return 1;
    }
    return 0;
  }
  if ( cp1 )
    *cp1 = 35;
  if ( cp2 )
    *cp2 = 35;
  return 1;
}

//----- (0808AE93) --------------------------------------------------------
void __cdecl HTAddGotoURL(char *url)
{
  FILE *v1; // eax
  void *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]
  char *copy; // [esp+24h] [ebp-4h] BYREF

  copy = 0;
  if ( url && *url )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTAddGotoURL %s\n", url);
    }
    HTSACopy(&copy, url);
    if ( Goto_URLs )
    {
      cur = Goto_URLs;
      while ( 1 )
      {
        if ( cur && (cur = cur->next) != 0 )
          object = cur->object;
        else
          object = 0;
        if ( !object )
          break;
        if ( !strcmp((const char *)object, copy) )
        {
          HTList_removeObject(Goto_URLs, object);
          free(object);
          break;
        }
      }
      HTList_addObject(Goto_URLs, copy);
    }
    else
    {
      Goto_URLs = HTList_new();
      HTList_addObject(Goto_URLs, copy);
    }
  }
}
// 808AF59: conditional instruction was optimized away because %var_14.4!=0

//----- (0808AFB8) --------------------------------------------------------
void __cdecl show_main_statusline(const LinkInfo curlink, int for_what)
{
  char *v2; // eax
  char *v3; // eax
  int v4; // ebx
  size_t v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  size_t v12; // [esp+8h] [ebp-A0h]
  char *cp; // [esp+18h] [ebp-90h]
  char *indx; // [esp+1Ch] [ebp-8Ch]
  char buf[128]; // [esp+20h] [ebp-88h] BYREF
  unsigned int v16; // [esp+A0h] [ebp-8h]

  v16 = __readgsdword(0x14u);
  if ( !user_mode && for_what != 2 )
    noviceline(more_text);
  if ( HTisDocumentSource() )
  {
    mustshow[0] = 1;
    v2 = gettext("Currently viewing document source.  Press '\\' to return to rendered version.");
    statusline(v2);
  }
  else if ( lynx_mode != 2 || nlinks <= 0 || user_mode == 2 && (curlink.type & 2) != 0 )
  {
    if ( user_mode == 2 && nlinks > 0 )
    {
      cp = 0;
      if ( curlink.type == 6 && strncasecomp(curlink.lname, "LYNXIMGMAP:", 11) )
        cp = strchr(curlink.lname, 35);
      if ( !cp )
        cp = curlink.lname;
      status_link(cp, more_text, is_www_index);
    }
    else if ( is_www_index && more_text )
    {
      v6 = key_for_func(50);
      v7 = gettext("--More--  This is a searchable index.  Use %s to search.");
      sprintf(buf, v7, v6);
      mustshow[0] = 1;
      statusline(buf);
    }
    else if ( is_www_index )
    {
      v8 = key_for_func(50);
      v9 = gettext("This is a searchable index.  Use %s to search.");
      sprintf(buf, v9, v8);
      mustshow[0] = 1;
      statusline(buf);
    }
    else if ( more_text )
    {
      mustshow[0] = 1;
      if ( user_mode )
        v10 = gettext("-- press space for more, use arrow keys to move, '?' for help, 'q' to quit.");
      else
        v10 = gettext("-- press space for next page --");
      statusline(v10);
    }
    else
    {
      mustshow[0] = 1;
      v11 = gettext("Commands: Use arrow keys to move, '?' for help, 'q' to quit, '<-' to go back.");
      statusline(v11);
    }
  }
  else
  {
    if ( curlink.type == 1 )
    {
      show_formlink_statusline(curlink.l_form, for_what);
    }
    else
    {
      v3 = gettext("(NORMAL LINK)   Use right-arrow or <return> to activate.");
      statusline(v3);
    }
    if ( is_www_index )
    {
      indx = gettext("-index-");
      v4 = LYcols - (LYShowScrollbar != 0);
      v5 = strlen(indx);
      LYmove(LYlines - 1, v4 - v5);
      lynx_start_reverse();
      v12 = strlen(indx);
      LYwaddnstr(LYwin, indx, v12);
      lynx_stop_reverse();
    }
  }
  if ( !LYShowCursor )
    LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
}

//----- (0808B334) --------------------------------------------------------
void __cdecl repaint_main_statusline(int for_what)
{
  LinkInfo v1; // [esp+0h] [ebp-68h] BYREF
  int v2; // [esp+54h] [ebp-14h]
  const void *v3; // [esp+58h] [ebp-10h]
  LinkInfo *v4; // [esp+5Ch] [ebp-Ch]

  if ( curdoc.link >= 0 && curdoc.link < nlinks )
  {
    v4 = &v1;
    v3 = (const void *)(68 * curdoc.link + 136026784);
    v2 = 17;
    qmemcpy(&v1, v3, sizeof(v1));
    show_main_statusline(v1, for_what);
  }
}

//----- (0808B396) --------------------------------------------------------
void __cdecl form_noviceline(int disabled)
{
  char *v1; // eax
  size_t v2; // ebx
  char *v3; // eax
  char *v4; // eax
  size_t v5; // ebx
  char *v6; // eax
  char *v7; // eax
  size_t v8; // ebx
  char *v9; // eax
  int v10; // eax
  char *v11; // eax
  int v12; // eax
  char *v13; // eax
  size_t v14; // eax
  char *erasekey; // [esp+1Ch] [ebp-Ch]
  char *temp[2]; // [esp+20h] [ebp-8h] BYREF

  LYmove(LYlines - 2, 0);
  LYclrtoeol();
  if ( !disabled )
  {
    v1 = gettext("            Enter text into the field by typing on the keyboard              ");
    v2 = strlen(v1);
    v3 = gettext("            Enter text into the field by typing on the keyboard              ");
    LYwaddnstr(LYwin, v3, v2);
  }
  LYmove(LYlines - 1, 0);
  LYclrtoeol();
  if ( !disabled )
  {
    if ( EditBinding(21) == 12 )
    {
      v4 = gettext("    Ctrl-U to delete all text in field, [Backspace] to delete a character    ");
      v5 = strlen(v4);
      v6 = gettext("    Ctrl-U to delete all text in field, [Backspace] to delete a character    ");
      LYwaddnstr(LYwin, v6, v5);
    }
    else if ( EditBinding(21) == 25 )
    {
      v7 = gettext("      Ctrl-U to delete text in field, [Backspace] to delete a character    ");
      v8 = strlen(v7);
      v9 = gettext("      Ctrl-U to delete text in field, [Backspace] to delete a character    ");
      LYwaddnstr(LYwin, v9, v8);
    }
    else
    {
      temp[0] = 0;
      v10 = LYKeyForEditAction(12);
      erasekey = fmt_keys(v10, -1);
      if ( erasekey )
      {
        v11 = gettext("    %s to delete all text in field, [Backspace] to delete a character    ");
        HTSprintf0(temp, v11, erasekey);
      }
      else
      {
        v12 = LYKeyForEditAction(25);
        erasekey = fmt_keys(v12, -1);
        if ( erasekey )
        {
          v13 = gettext("      %s to delete text in field, [Backspace] to delete a character    ");
          HTSprintf0(temp, v13, erasekey);
        }
      }
      if ( temp[0] )
      {
        v14 = strlen(temp[0]);
        LYwaddnstr(LYwin, temp[0], v14);
        if ( temp[0] )
        {
          free(temp[0]);
          temp[0] = 0;
        }
      }
      if ( erasekey )
        free(erasekey);
    }
  }
}

//----- (0808B5B4) --------------------------------------------------------
void __cdecl exit_immediately_with_error_message(int state, BOOLEAN first_file)
{
  char *v2; // eax
  const char *v3; // [esp+1Ch] [ebp-2Ch]
  char *v4; // [esp+20h] [ebp-28h]
  char *v5; // [esp+28h] [ebp-20h]
  char *v6; // [esp+2Ch] [ebp-1Ch]
  char *buf2; // [esp+40h] [ebp-8h] BYREF
  char *buf; // [esp+44h] [ebp-4h] BYREF

  buf = 0;
  buf2 = 0;
  if ( first_file )
    LYstatusline_messages_on_exit(&buf2);
  if ( !state )
  {
    if ( buf2 && (v2 = gettext("Can't Access"), strstr(buf2, v2)) )
      v3 = &byte_81534E7;
    else
      v3 = startfile;
    v4 = gettext("lynx: Can't access startfile");
    if ( buf2 )
      HTSprintf0(&buf, "%s\n%s %s\n", buf2, v4, v3);
    else
      HTSprintf0(&buf, "%s\n%s %s\n", &byte_81534E7, v4, v3);
  }
  if ( state == 3 )
  {
    v5 = gettext("      Exiting...");
    v6 = gettext("lynx: Start file could not be found or is not text/html or text/plain");
    if ( buf2 )
      HTSprintf0(&buf, "%s\n%s\n%s\n", buf2, v6, v5);
    else
      HTSprintf0(&buf, "%s\n%s\n%s\n", &byte_81534E7, v6, v5);
  }
  if ( buf2 )
  {
    free(buf2);
    buf2 = 0;
  }
  if ( !dump_output_immediately )
    cleanup();
  if ( dump_output_immediately )
    fputs(buf, stderr);
  else
    fputs(buf, stdout);
  if ( buf )
  {
    free(buf);
    buf = 0;
  }
  if ( !dump_output_immediately )
    exit_immediately(1);
}

//----- (0808B75F) --------------------------------------------------------
void __cdecl status_link(char *curlink_name, BOOLEAN show_more, BOOLEAN show_indx)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  FILE *v6; // eax
  int n; // [esp+28h] [ebp-420h]
  int na; // [esp+28h] [ebp-420h]
  int cut_to_pos; // [esp+2Ch] [ebp-41Ch]
  int cut_from_pos; // [esp+30h] [ebp-418h]
  char *buf; // [esp+34h] [ebp-414h] BYREF
  int length; // [esp+38h] [ebp-410h]
  int prefix; // [esp+3Ch] [ebp-40Ch]
  char format[1024]; // [esp+40h] [ebp-408h] BYREF
  unsigned int v15; // [esp+440h] [ebp-8h]

  v15 = __readgsdword(0x14u);
  prefix = 0;
  format[0] = 0;
  if ( show_more && !nomore[0] )
  {
    v3 = gettext("-more-");
    sprintf(format, "%.*s ", 1022, v3);
    prefix = strlen(format);
  }
  if ( show_indx )
  {
    v4 = gettext("-index-");
    sprintf(&format[prefix], "%.*s ", 1022 - prefix, v4);
  }
  prefix = strlen(format);
  length = strlen(curlink_name);
  if ( LYcols - (LYShowScrollbar != 0) - 1 >= prefix && prefix <= 1022 )
  {
    sprintf(&format[prefix], "%%.%ds", LYcols - (LYShowScrollbar != 0) - 1 - prefix);
    if ( length + prefix > LYcols - (LYShowScrollbar != 0) - 1 && long_url_ok )
    {
      buf = 0;
      HTSACopy(&buf, curlink_name);
      for ( cut_to_pos = length - 2; cut_to_pos > 0 && buf[cut_to_pos] != 47; --cut_to_pos )
        ;
      for ( cut_from_pos = cut_to_pos - 4;
            cut_from_pos > 0
         && (buf[cut_from_pos] != 47
          || length - cut_to_pos + cut_from_pos + prefix + 4 >= LYcols - (LYShowScrollbar != 0) - 1);
            --cut_from_pos )
      {
        ;
      }
      if ( cut_from_pos > 0 )
      {
        for ( n = 1; n <= 3; ++n )
          buf[n + cut_from_pos] = 46;
        for ( na = 0; cut_to_pos + na <= length; ++na )
          buf[na + 4 + cut_from_pos] = buf[na + cut_to_pos];
      }
      mustshow[0] = 1;
      user_message(format, buf);
      if ( WWW_TraceFlag[0] )
      {
        v5 = buf;
        v6 = TraceFP();
        fprintf(v6, "lastline = %s\n", v5);
      }
      if ( buf )
      {
        free(buf);
        buf = 0;
      }
    }
    else
    {
      mustshow[0] = 1;
      user_message(format, curlink_name);
    }
  }
  else
  {
    mustshow[0] = 1;
    user_message("%s", format);
  }
}

//----- (0808BB66) --------------------------------------------------------
char *LYDownLoadAddress()
{
  if ( newdoc.address )
    return newdoc.address;
  else
    return (char *)&byte_81534E7;
}

//----- (0808BB8C) --------------------------------------------------------
int __cdecl string_to_attr(char *name)
{
  unsigned int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 6; ++i )
  {
    if ( !strcasecomp(Mono_Attrs[i].name, name) )
      return Mono_Attrs[i].code;
  }
  return 0;
}

//----- (0808BBDD) --------------------------------------------------------
char *__cdecl attr_to_string(int code)
{
  size_t v1; // eax
  char *v2; // edx
  _BOOL4 v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  const char *bg; // [esp+20h] [ebp-18h]
  const char *fg; // [esp+24h] [ebp-14h]
  int pair; // [esp+2Ch] [ebp-Ch]
  unsigned int i; // [esp+30h] [ebp-8h]
  __int16 b; // [esp+34h] [ebp-4h] BYREF
  __int16 f; // [esp+36h] [ebp-2h] BYREF

  pair = (unsigned __int16)(code & 0xFF00) >> 8;
  v4 = pair && (code & 0x200000) != 0;
  if ( v4 )
    code &= ~0x200000u;
  result_10340[0] = 0;
  for ( i = 0; i <= 6; ++i )
  {
    if ( (code & Mono_Attrs[i].code) != 0 )
    {
      if ( result_10340[0] )
      {
        v1 = strlen(result_10340);
        memcpy((void *)(v1 + 135983168), "+", 2u);
      }
      strcat(result_10340, Mono_Attrs[i].name);
    }
  }
  if ( pair && pair_content(pair, &f, &b) != -1 )
  {
    if ( v4 )
      v5 = COLORS + f;
    else
      v5 = f;
    fg = lookup_color(v5);
    bg = lookup_color(b);
    if ( result_10340[0] )
      strcat(result_10340, "+");
    v2 = &result_10340[strlen(result_10340)];
    sprintf(v2, "%s/%s", fg, bg);
  }
  return result_10340;
}
// 81AA440: using guessed type int COLORS;

//----- (0808BD63) --------------------------------------------------------
void __cdecl LYbox(WINDOW *win, BOOLEAN formfield)
{
  int boxhori; // [esp+3Ch] [ebp-Ch] BYREF
  int boxvert; // [esp+40h] [ebp-8h] BYREF

  UCSetBoxChars(current_char_set, &boxvert, &boxhori, 0, 0);
  curses_w_style(win, s_menu_frame, 1);
  if ( boxvert && boxhori )
  {
    if ( boxvert == 42 || boxhori == 42 )
      wborder(win, boxvert, boxvert, boxhori, boxhori, 0x2Au, 0x2Au, 0x2Au, 0x2Au);
    else
      wborder(win, boxvert, boxvert, boxhori, boxhori, 0x2Fu, 0x5Cu, 0x5Cu, 0x2Fu);
  }
  else
  {
    wborder(win, boxvert, boxvert, boxhori, boxhori, 0, 0, 0, 0);
  }
  curses_w_style(win, s_menu_frame, 0);
  wrefresh(win);
}

//----- (0808BEF1) --------------------------------------------------------
void __cdecl setStyle(int style, int color, int cattr, int mono)
{
  displayStyles[style].color = color;
  displayStyles[style].cattr = cattr;
  displayStyles[style].mono = mono;
}

//----- (0808BF41) --------------------------------------------------------
void __cdecl setHashStyle(int style, int color, int cattr, int mono, char *element)
{
  FILE *v5; // edx

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    v5 = TraceFP();
    fprintf(v5, "CSS(SET): <%s> hash=%d, ca=%#x, ma=%#x\n", element, style, color, mono);
  }
  hashStyles[style].color = color;
  hashStyles[style].cattr = cattr;
  hashStyles[style].mono = mono;
  hashStyles[style].code = style;
  if ( hashStyles[style].name )
  {
    free(hashStyles[style].name);
    hashStyles[style].name = 0;
  }
  HTSACopy((char **)(24 * style + 136098368), element);
}

//----- (0808BFFE) --------------------------------------------------------
void __cdecl LYAttrset(WINDOW *win, int color, int mono)
{
  char *v3; // ebx
  FILE *v4; // edx
  char *v5; // ebx
  FILE *v6; // edx
  FILE *v7; // eax

  if ( lynx_has_color && LYShowColor > 1 && color >= 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( (WWW_TraceMask & 2) != 0 )
      {
        v3 = attr_to_string(color);
        v4 = TraceFP();
        fprintf(v4, "CSS:LYAttrset color %#x -> (%s)\n", color, v3);
      }
    }
    win->_attrs = color;
  }
  else if ( mono < 0 )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v7 = TraceFP();
      fprintf(v7, "CSS:LYAttrset (A_NORMAL)\n");
    }
    win->_attrs = 0;
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v5 = attr_to_string(mono);
      v6 = TraceFP();
      fprintf(v6, "CSS:LYAttrset mono %#x -> (%s)\n", mono, v5);
    }
    win->_attrs = mono;
  }
}

//----- (0808C10B) --------------------------------------------------------
void __cdecl curses_w_style(WINDOW *win, int style, int dir)
{
  FILE *v3; // eax
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // eax
  int v7; // ebx
  const char *v8; // ebx
  FILE *v9; // edx
  bucket *v10; // [esp+28h] [ebp-30h]
  int color; // [esp+2Ch] [ebp-2Ch]
  int code; // [esp+30h] [ebp-28h]
  const char *name; // [esp+34h] [ebp-24h]
  const char *v14; // [esp+38h] [ebp-20h]
  int cury; // [esp+3Ch] [ebp-1Ch]
  int curx; // [esp+40h] [ebp-18h]

  if ( style == -1 )
    v10 = &nostyle_bucket;
  else
    v10 = (bucket *)(24 * style + 136098368);
  if ( !v10->name )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( (WWW_TraceMask & 2) != 0 )
      {
        v3 = TraceFP();
        fprintf(v3, "CSS.CS:Style %d not configured\n", style);
      }
    }
    return;
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    color = v10->color;
    code = v10->code;
    name = v10->name;
    if ( dir )
      v14 = (const char *)&unk_815571C;
    else
      v14 = "/";
    v4 = TraceFP();
    fprintf(v4, "CSS.CS:<%s%s> style %d code %#x, color %#x\n", v14, name, style, code, color);
  }
  if ( win )
    cury = win->_cury;
  else
    cury = -1;
  if ( win )
    curx = win->_curx;
  else
    curx = -1;
  if ( style == s_normal && dir )
  {
    LYAttrset(win, v10->color, v10->mono);
    if ( win == LYwin )
      SetCachedStyle(cury, curx, s_normal);
    return;
  }
  if ( dir == 1 )
  {
    if ( last_colorattr_ptr > 127 )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v5 = last_styles[last_colorattr_ptr];
        v6 = TraceFP();
        fprintf(
          v6,
          "........... %s (0x%x) %s\r\n",
          "attribute cache FULL, dropping last",
          v5,
          "in LynxChangeStyle(curses_w_style)");
      }
      last_colorattr_ptr = 127;
    }
    v7 = last_colorattr_ptr;
    last_styles[v7] = LYgetattrs(win);
    last_colorattr_ptr = v7 + 1;
  }
  else if ( dir != 2 )
  {
    if ( !dir )
    {
      if ( last_colorattr_ptr )
      {
        --last_colorattr_ptr;
        LYAttrset(win, last_styles[last_colorattr_ptr], last_styles[last_colorattr_ptr]);
      }
      else
      {
        LYAttrset(win, 0, -1);
      }
    }
    return;
  }
  if ( style != s_alink
    && style != s_curedit
    && style != s_aedit
    && style != s_aedit_sel
    && style != s_aedit_pad
    && style != s_aedit_arr )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v8 = v10->name;
      v9 = TraceFP();
      fprintf(v9, "CACHED: <%s> @(%d,%d)\n", v8, cury, curx);
    }
    if ( win == LYwin )
      SetCachedStyle(cury, curx, style);
  }
  LYAttrset(win, v10->color, v10->mono);
}

//----- (0808C47F) --------------------------------------------------------
void __cdecl wcurses_css(WINDOW *win, char *name, int dir)
{
  FILE *v3; // eax
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // eax
  int v7; // [esp+4h] [ebp-24h]
  char *pclass; // [esp+18h] [ebp-10h]
  int tmpHash; // [esp+1Ch] [ebp-Ch]
  int try_again; // [esp+20h] [ebp-8h]

  try_again = 1;
  while ( try_again )
  {
    tmpHash = hash_code(name);
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "CSSTRIM:trying to set [%s] style - ", name);
    }
    if ( tmpHash == -1 )
    {
      pclass = strrchr(name, 46);
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v4 = TraceFP();
        fprintf(v4, "undefined, trimming at %p\n", pclass);
      }
      if ( pclass )
        *pclass = 0;
      else
        try_again = 0;
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v5 = hash_code(name);
        v6 = TraceFP();
        fprintf(v6, "ok (%d)\n", v5);
      }
      v7 = hash_code(name);
      curses_w_style(win, v7, dir);
      try_again = 0;
    }
  }
}

//----- (0808C5B6) --------------------------------------------------------
void __cdecl curses_css(char *name, int dir)
{
  wcurses_css(LYwin, name, dir);
}

//----- (0808C5D9) --------------------------------------------------------
void __cdecl curses_style(int style, int dir)
{
  curses_w_style(LYwin, style, dir);
}

//----- (0808C5FC) --------------------------------------------------------
int __cdecl get_color_pair(int n)
{
  if ( n <= 24 && lynx_color_pairs[n].fg == default_fg && lynx_color_pairs[n].bg == default_bg )
    return 0;
  else
    return n << 8;
}

//----- (0808C647) --------------------------------------------------------
int __cdecl lynx_color_cfg_attr(int code)
{
  int fg; // [esp+8h] [ebp-8h]
  int result; // [esp+Ch] [ebp-4h]

  result = 0;
  if ( code >= 0 && code <= 7 )
  {
    fg = lynx_color_cfg[code].fg;
    if ( COLORS - 1 < fg && (fg & COLORS) != 0 )
      return 0x200000;
  }
  return result;
}
// 81AA440: using guessed type int COLORS;

//----- (0808C694) --------------------------------------------------------
int __cdecl encode_color_attr(int color_attr)
{
  int code; // [esp+Ch] [ebp-8h]
  int result; // [esp+10h] [ebp-4h]

  code = (color_attr & 0x200000) != 0;
  if ( (color_attr & 0x140000) != 0 )
    code |= 2u;
  if ( (color_attr & 0x20000) != 0 )
    code |= 4u;
  result = lynx_color_cfg_attr(code);
  if ( code + 1 < COLOR_PAIRS )
    return get_color_pair(code + 1) | result;
  return result;
}
// 81AB39C: using guessed type int COLOR_PAIRS;

//----- (0808C710) --------------------------------------------------------
int __cdecl decode_mono_code(int mono_code)
{
  int result; // [esp+Ch] [ebp-4h]

  result = 0;
  if ( (mono_code & 1) != 0 )
    result = 0x200000;
  if ( (mono_code & 2) != 0 )
    result |= 0x40000u;
  if ( (mono_code & 4) != 0 )
    return result | 0x20000;
  return result;
}

//----- (0808C761) --------------------------------------------------------
int LYgetTableAttr()
{
  int result; // [esp+10h] [ebp-4h]

  if ( lynx_has_color && LYShowColor > 1 )
    result = encode_color_attr(Current_Attr);
  else
    result = Current_Attr;
  return result & ~Masked_Attr;
}

//----- (0808C7A0) --------------------------------------------------------
char *__cdecl LYgetTableString(int code)
{
  int v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  char *v6; // ebx
  FILE *v7; // eax
  char *result; // [esp+24h] [ebp-24h] BYREF
  unsigned int n; // [esp+28h] [ebp-20h]
  int bg; // [esp+2Ch] [ebp-1Ch]
  int fg; // [esp+30h] [ebp-18h]
  int mono; // [esp+34h] [ebp-14h]
  int pair; // [esp+38h] [ebp-10h]
  int second; // [esp+3Ch] [ebp-Ch]
  int mask; // [esp+40h] [ebp-8h]

  mask = decode_mono_code(code);
  second = encode_color_attr(mask);
  pair = (unsigned __int16)(second & 0xFF00) >> 8;
  v1 = mask;
  LOBYTE(v1) = 0;
  mono = v1;
  fg = lynx_color_pairs[pair].fg;
  bg = lynx_color_pairs[pair].bg;
  result = 0;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "LYgetTableString(%d)\n", code);
  }
  if ( !fg && !bg )
    fg = 7;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "%#x -> %#x (mono %#x pair %d) fg=%d, bg=%d\n", mask, second, mono, pair, fg, bg);
  }
  for ( n = 0; n <= 6; ++n )
  {
    if ( (mono & Mono_Attrs[n].code) != 0 )
    {
      if ( result )
        HTSACat(&result, "+");
      HTSACat(&result, Mono_Attrs[n].name);
    }
  }
  if ( !result )
    HTSACopy(&result, "normal");
  HTSACat(&result, ":");
  v4 = lookup_color(fg);
  HTSACat(&result, v4);
  if ( bg >= 0 )
  {
    HTSACat(&result, ":");
    v5 = lookup_color(bg);
    HTSACat(&result, v5);
  }
  if ( WWW_TraceFlag[0] )
  {
    v6 = result;
    v7 = TraceFP();
    fprintf(v7, "->%s\n", v6);
  }
  return result;
}

//----- (0808C987) --------------------------------------------------------
void __cdecl lynx_init_color_pair(int n)
{
  ;
}

//----- (0808C98C) --------------------------------------------------------
void __cdecl lynx_map_color(int n)
{
  FILE *v1; // eax
  int j; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "lynx_map_color(%d)\n", n);
  }
  if ( n + 1 <= 24 )
  {
    for ( j = n + 1; j <= 24; j += 8 )
    {
      lynx_color_pairs[j].fg = lynx_color_cfg[n].fg;
      lynx_color_pairs[j].bg = lynx_color_cfg[n].bg;
    }
    lynx_color_pairs[n + 9].bg = lynx_color_cfg[0].bg;
  }
  lynx_init_color_pair(n);
}

//----- (0808CA26) --------------------------------------------------------
int __cdecl lynx_chg_color(int color, int fg, int bg)
{
  FILE *v3; // edx

  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "lynx_chg_color(color=%d, fg=%d, bg=%d)\n", color, fg, bg);
  }
  if ( fg == -3 || bg == -3 )
    return -1;
  if ( color < 0 || color > 7 )
    return -1;
  lynx_color_cfg[color].fg = fg;
  lynx_color_cfg[color].bg = bg;
  lynx_map_color(color);
  return 0;
}

//----- (0808CAC8) --------------------------------------------------------
void __cdecl lynx_set_color(int a)
{
  WINDOW *v1; // [esp+4h] [ebp-Ch]
  int v2; // [esp+8h] [ebp-8h]
  int color_pair; // [esp+Ch] [ebp-4h]

  if ( lynx_has_color && LYShowColor > 1 )
  {
    v1 = LYwin;
    v2 = lynx_color_cfg_attr(a);
    if ( a + 1 >= COLOR_PAIRS )
      color_pair = 0;
    else
      color_pair = get_color_pair(a + 1);
    v1->_attrs = color_pair | v2;
  }
}
// 81AB39C: using guessed type int COLOR_PAIRS;

//----- (0808CB2E) --------------------------------------------------------
void __cdecl lynx_standout(int flag)
{
  if ( flag )
    wattr_on(LYwin, 0x40000u, 0);
  else
    wattr_off(LYwin, 0x40000u, 0);
}

//----- (0808CB78) --------------------------------------------------------
void lynx_init_colors()
{
  int v0; // ebx
  int v1; // esi
  FILE *v2; // eax
  unsigned int n; // [esp+1Ch] [ebp-Ch]

  if ( lynx_has_color )
  {
    if ( WWW_TraceFlag[0] )
    {
      v0 = default_bg;
      v1 = default_fg;
      v2 = TraceFP();
      fprintf(v2, "lynx_init_colors (default %d/%d)\n", v1, v0);
    }
    lynx_color_cfg[0].fg = default_fg;
    lynx_color_cfg[0].bg = default_bg;
    for ( n = 0; n <= 7; ++n )
      lynx_init_color_pair(n);
  }
  else
  {
    LYShowColor = LYShowColor != 0;
  }
}

//----- (0808CC0D) --------------------------------------------------------
void lynx_setup_colors()
{
  FILE *v0; // eax
  int n; // [esp+14h] [ebp-4h]
  int na; // [esp+14h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    v0 = TraceFP();
    fprintf(v0, "lynx_setup_colors\n");
  }
  if ( !LYuse_default_colors )
  {
    for ( n = 0; n <= 7; ++n )
    {
      if ( lynx_color_cfg[n].dft_fg )
        lynx_color_cfg[n].fg = 0;
      if ( lynx_color_cfg[n].dft_bg )
        lynx_color_cfg[n].bg = 7;
    }
  }
  for ( na = 0; na <= 7; ++na )
    lynx_map_color(na);
}

//----- (0808CCB3) --------------------------------------------------------
void __cdecl LYnoVideo(int a)
{
  FILE *v1; // eax

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "LYnoVideo(%d)\n", a);
  }
  Masked_Attr = decode_mono_code(a);
}

//----- (0808CCF4) --------------------------------------------------------
void start_curses()
{
  int v0; // eax
  FILE *v1; // eax
  char *v2; // ebx
  FILE *v3; // eax
  int v4; // ebx
  int v5; // esi
  FILE *v6; // eax
  int v7; // ebx
  int v8; // esi
  FILE *v9; // eax
  int bg; // esi
  int fg; // ebx
  FILE *v12; // eax
  FILE *v13; // eax
  unsigned int n; // [esp+24h] [ebp-14h]
  int keypad_on; // [esp+28h] [ebp-10h]
  BOOLEAN savesize; // [esp+2Fh] [ebp-9h]

  keypad_on = 0;
  v0 = fileno(stdout);
  if ( isatty(v0) && LYReopenInput() < 0 )
  {
    fwrite("Cannot open tty input\n", 1u, 0x16u, stderr);
    exit_immediately(1);
  }
  if ( !LYscreen )
  {
    savesize = recent_sizechange;
    size_change(0);
    recent_sizechange = savesize;
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "Screen size: %s()\n", "initscr");
    }
    LYscreen = initscr();
    if ( !LYscreen )
    {
      v2 = gettext("Terminal initialisation failed - unknown terminal type?");
      v3 = TraceFP();
      fprintf(v3, "%s\n", v2);
      exit_immediately(1);
    }
    lynx_called_initscr[0] = 1;
    LYlines = LYscreenHeight();
    LYcols = LYscreenWidth();
    size_change(0);
    recent_sizechange = 0;
    if ( WWW_TraceFlag[0] )
    {
      v4 = LYcols;
      v5 = LYlines;
      v6 = TraceFP();
      fprintf(v6, "Screen size is now %d x %d\n", v5, v4);
    }
    if ( LYuseCursesPads )
    {
      LYwin = newpad(LYlines, 1014);
      LYshiftWin = 0;
      LYwideLines = 0;
    }
    else
    {
      LYwin = stdscr;
    }
    keypad(LYwin, 1);
    keypad_on = 1;
    if ( lynx_initialize_keymaps() == -1 )
    {
      endwin();
      exit_immediately(1);
    }
    if ( has_colors() )
    {
      lynx_has_color = 1;
      start_color();
      if ( COLORS > 16 )
        COLORS = 16;
      if ( COLORS <= 7 )
        COLORS = 2;
      if ( COLORS > 8 && COLORS != 16 )
        COLORS = 8;
      if ( LYuse_default_colors )
      {
        if ( assume_default_colors(default_fg, default_bg) )
        {
          default_fg = 7;
          default_bg = 0;
        }
        if ( WWW_TraceFlag[0] )
        {
          v7 = default_bg;
          v8 = default_fg;
          v9 = TraceFP();
          fprintf(v9, "initializing default colors %d/%d\n", v8, v7);
        }
        if ( default_fg >= 0 || default_bg >= 0 )
        {
          for ( n = 0; n <= 7; ++n )
          {
            if ( default_fg >= 0 && lynx_color_cfg[n].fg < 0 )
              lynx_color_cfg[n].fg = default_fg;
            if ( default_bg >= 0 && lynx_color_cfg[n].bg < 0 )
              lynx_color_cfg[n].bg = default_bg;
            if ( WWW_TraceFlag[0] )
            {
              bg = lynx_color_cfg[n].bg;
              fg = lynx_color_cfg[n].fg;
              v12 = TraceFP();
              fprintf(v12, "color_cfg[%u] = %d/%d\n", n, fg, bg);
            }
          }
          lynx_setup_colors();
        }
      }
    }
    if ( lynx_lss_file && *lynx_lss_file && LYCanReadFile(lynx_lss_file) )
      style_readFromFile(lynx_lss_file);
    parse_userstyles();
    lynx_init_colors();
  }
  cbreak();
  signal(2, cleanup_sig);
  noecho();
  if ( !keypad_on )
    keypad(LYwin, 1);
  lynx_enable_mouse(1);
  fflush(stdin);
  fflush(stdout);
  fflush(stderr);
  LYCursesON[0] = 1;
  if ( WWW_TraceFlag[0] )
  {
    v13 = TraceFP();
    fprintf(v13, "start_curses: done.\n");
  }
}
// 81AA440: using guessed type int COLORS;

//----- (0808D157) --------------------------------------------------------
void __cdecl lynx_enable_mouse(int state)
{
  int v1; // eax

  if ( LYUseMouse )
  {
    if ( state )
    {
      if ( !was_11223 )
      {
        v1 = mouseinterval(-1);
        ++was_11223;
        if ( v1 <= 199 )
          mouseinterval(300);
      }
      mousemask(0x501F1DFu, 0);
    }
    else
    {
      mousemask(0, 0);
    }
  }
}

//----- (0808D1D4) --------------------------------------------------------
void __cdecl lynx_nl2crlf(int normal)
{
  int v1; // eax

  if ( !did_save_11243 )
  {
    if ( cur_term )
    {
      saved_tty_11242 = *(termios *)(cur_term + 104);
      did_save_11243 = 1;
    }
    else
    {
      can_fix_11245 = 0;
    }
  }
  if ( can_fix_11245 )
  {
    if ( normal )
    {
      if ( !waiting_11244 )
      {
        *(_DWORD *)(cur_term + 108) |= 4u;
        waiting_11244 = 1;
        nonl();
      }
    }
    else if ( waiting_11244 )
    {
      *(termios *)(cur_term + 104) = saved_tty_11242;
      v1 = fileno(stdout);
      tcsetattr(v1, 1, &saved_tty_11242);
      waiting_11244 = 0;
      nl();
      LYrefresh();
    }
  }
}
// 81AAB08: using guessed type int cur_term;

//----- (0808D3E6) --------------------------------------------------------
void stop_curses()
{
  FILE *v0; // eax

  if ( LYCursesON[0] )
  {
    FreeCachedStyles();
    echo();
  }
  if ( LYCursesON[0] == 1 )
  {
    lynx_nl2crlf(1);
    lynx_enable_mouse(0);
    if ( LYscreen || lynx_called_initscr[0] )
      endwin();
  }
  fflush(stdout);
  fflush(stderr);
  LYCursesON[0] = 0;
  if ( WWW_TraceFlag[0] )
  {
    v0 = TraceFP();
    fprintf(v0, "stop_curses: done.\n");
  }
  signal(2, 0);
}

//----- (0808D496) --------------------------------------------------------
BOOLEAN __cdecl setup(char *terminal)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *cp; // [esp+18h] [ebp-10h]
  char *buffer; // [esp+1Ch] [ebp-Ch] BYREF
  char *term_putenv[2]; // [esp+20h] [ebp-8h] BYREF

  term_putenv[0] = 0;
  buffer = 0;
  cp = LYgetXDisplay();
  if ( cp )
  {
    HTSACopy(&x_display, cp);
  }
  else if ( x_display )
  {
    free(x_display);
    x_display = 0;
  }
  if ( terminal )
  {
    HTSprintf0(term_putenv, "TERM=%.106s", terminal);
    putenv(term_putenv[0]);
  }
  v1 = LYGetEnv("TERM");
  if ( dumbterm(v1) )
  {
    v2 = gettext("Your Terminal type is unknown!");
    printf("\n\n  %s\n\n", v2);
    v3 = gettext("Enter a terminal type:");
    printf("  %s [vt100] ", v3);
    if ( LYSafeGets(&buffer, stdin) )
    {
      LYTrimLeading(buffer);
      LYTrimTrailing(buffer);
    }
    if ( !buffer || !*buffer )
      HTSACopy(&buffer, "vt100");
    HTSprintf0(term_putenv, "TERM=%.106s", buffer);
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
    putenv(term_putenv[0]);
    v4 = LYGetEnv("TERM");
    v5 = gettext("TERMINAL TYPE IS SET TO");
    printf("\n%s %s\n", v5, v4);
    LYSleepMsg();
  }
  start_curses();
  if ( !strncmp(ttytype, "sun", 3u) )
    LYnoVideo(2);
  LYlines = LYscreenHeight();
  LYcols = LYscreenWidth();
  return 1;
}

//----- (0808D680) --------------------------------------------------------
int __cdecl dumbterm(char *terminal)
{
  int dumb; // [esp+14h] [ebp-4h]

  dumb = 0;
  if ( !terminal
    || !strcasecomp(terminal, "network")
    || !strcasecomp(terminal, "unknown")
    || !strcasecomp(terminal, "dialup")
    || !strcasecomp(terminal, "dumb")
    || !strcasecomp(terminal, "switch")
    || !strcasecomp(terminal, "ethernet") )
  {
    return 1;
  }
  return dumb;
}

//----- (0808D72D) --------------------------------------------------------
void __cdecl LYpaddstr(WINDOW *the_window, int width, const char *the_string)
{
  int curx; // [esp+10h] [ebp-18h]
  int actual; // [esp+18h] [ebp-10h]
  int widtha; // [esp+34h] [ebp+Ch]

  actual = strlen(the_string);
  if ( the_window )
    curx = the_window->_curx;
  else
    curx = -1;
  if ( width + curx > LYcols - (LYShowScrollbar != 0) )
    width = LYcols - (LYShowScrollbar != 0) - curx;
  if ( actual > width )
    actual = width;
  LYwaddnstr(the_window, the_string, actual);
  widtha = width - actual;
  while ( widtha-- > 0 )
    waddnstr(the_window, " ", -1);
}

//----- (0808D829) --------------------------------------------------------
void __cdecl LYsubwindow(WINDOW *param)
{
  int v1; // [esp+14h] [ebp-14h]
  int b; // [esp+24h] [ebp-4h]

  if ( param )
  {
    my_subwindow = param;
    keypad(param, 1);
    curses_w_style(my_subwindow, s_menu_bg, 1);
    b = LYgetattrs(my_subwindow);
    wbkgd(my_subwindow, b | 0x20);
    curses_w_style(my_subwindow, s_menu_bg, 0);
    scrollok(my_subwindow, 1);
  }
  else
  {
    if ( LYwin )
      v1 = LYwin->_maxy + 1;
    else
      v1 = -1;
    wtouchln(LYwin, 0, v1, 1);
    delwin(my_subwindow);
    my_subwindow = 0;
  }
}

//----- (0808D932) --------------------------------------------------------
WINDOW *LYtopwindow()
{
  if ( my_subwindow )
    return my_subwindow;
  else
    return LYwin;
}

//----- (0808D958) --------------------------------------------------------
WINDOW *__cdecl LYstartPopup(int *top_y, int *left_x, int *height, int *width)
{
  char *v4; // eax
  WINDOW *form_window; // [esp+20h] [ebp-8h]

  form_window = 0;
  if ( *left_x > 0 && *left_x + *width + 4 < LYcols - (LYShowScrollbar != 0) )
    form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
  if ( !form_window )
  {
    if ( *width <= LYcols - (LYShowScrollbar != 0) - 4 )
    {
      *left_x = LYcols - (LYShowScrollbar != 0) - 4 - *width;
      if ( *left_x <= 0 )
        *left_x = 1;
    }
    else
    {
      *width = LYcols - (LYShowScrollbar != 0) - 4;
      *left_x = 1;
    }
    form_window = newwin(*height, *width + 4, *top_y, *left_x - 1);
  }
  if ( form_window )
  {
    LYsubwindow(form_window);
  }
  else
  {
    v4 = gettext("Unable to create popup window!");
    HTAlert(v4);
  }
  return form_window;
}

//----- (0808DACB) --------------------------------------------------------
void LYstartTargetEmphasis()
{
  if ( s_whereis == -1 )
  {
    lynx_start_bold();
    lynx_start_reverse();
    lynx_start_underline();
  }
  else
  {
    curses_style(s_whereis, 1);
  }
}

//----- (0808DB03) --------------------------------------------------------
void LYstopTargetEmphasis()
{
  if ( s_whereis == -1 )
  {
    lynx_stop_underline();
    lynx_stop_reverse();
    lynx_stop_bold();
  }
  else
  {
    curses_style(s_whereis, 0);
  }
}

//----- (0808DB3B) --------------------------------------------------------
void __cdecl LYtouchline(int row)
{
  wtouchln(LYwin, row, 1, 1);
}

//----- (0808DB68) --------------------------------------------------------
void __cdecl LYwaddnstr(WINDOW *w, const char *src, size_t len)
{
  FILE *v3; // edx
  int cury; // [esp+1Ch] [ebp-4Ch]
  int curx; // [esp+20h] [ebp-48h]
  int v6; // [esp+24h] [ebp-44h]
  int v7; // [esp+28h] [ebp-40h]
  int v8; // [esp+2Ch] [ebp-3Ch]
  int v9; // [esp+30h] [ebp-38h]
  __int16 v10; // [esp+38h] [ebp-30h]
  int v11; // [esp+40h] [ebp-28h]
  WINDOW *sub; // [esp+4Ch] [ebp-1Ch]
  size_t inx; // [esp+50h] [ebp-18h]
  int x; // [esp+54h] [ebp-14h]

  if ( LYwin )
    cury = LYwin->_cury;
  else
    cury = -1;
  if ( LYwin )
    curx = LYwin->_curx;
  else
    curx = -1;
  if ( !LYuseCursesPads
    || LYwin != w
    || LYshiftWin
    || LYwideLines
    || (int)len <= LYcols - (LYShowScrollbar != 0) - curx
    || LYcols - (LYShowScrollbar != 0) <= curx )
  {
    if ( WWW_TraceFlag[0] )
    {
      v8 = LYwin ? LYwin->_cury : -1;
      v9 = LYwin ? LYwin->_curx : -1;
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v3 = TraceFP();
        fprintf(v3, "[%2d,%2d] LYwaddnstr(%.*s, %u)\n", v8, v9, len, src, len);
      }
    }
    if ( LYwin )
      v10 = LYwin->_curx;
    else
      LOBYTE(v10) = -1;
    for ( inx = 0; inx < len; ++inx )
    {
      if ( src[inx] == 9 )
      {
        if ( LYwin )
          v11 = LYwin->_curx;
        else
          v11 = -1;
        x = v11;
        while ( (((_BYTE)++x - (_BYTE)v10) & 7) != 0 )
          waddch(w, 0x20u);
        waddch(w, 0x20u);
      }
      else
      {
        waddch(w, (unsigned __int8)src[inx]);
      }
    }
  }
  else
  {
    sub = derwin(LYwin, LYlines, LYcols - (LYShowScrollbar != 0), 0, 0);
    if ( sub )
    {
      wmove(sub, cury, curx);
      LYwideLines = 1;
      LYwaddnstr(sub, src, len);
      v6 = sub->_cury;
      v7 = sub->_curx;
      delwin(sub);
      wmove(LYwin, v6, v7);
    }
    LYwideLines = 0;
  }
}
// 808DCD0: conditional instruction was optimized away because %sub.4!=0
// 808DCEF: conditional instruction was optimized away because %sub.4!=0

//----- (0808DF0D) --------------------------------------------------------
int __cdecl LYstrExtent(const char *string, int len, int maxCells)
{
  int cury; // [esp+10h] [ebp-28h]
  int curx; // [esp+14h] [ebp-24h]
  int n; // [esp+2Ch] [ebp-Ch]
  int used; // [esp+30h] [ebp-8h]
  int result; // [esp+34h] [ebp-4h]

  if ( len >= 0 )
    used = len;
  else
    used = strlen(string);
  result = used;
  if ( used > 0 && lynx_called_initscr[0] )
  {
    if ( fake_max_11684 < maxCells )
    {
      fake_max_11684 = 2 * (maxCells + 1);
      if ( fake_win_11683 )
      {
        delwin(fake_win_11683);
        fake_win_11683 = 0;
      }
    }
    if ( !fake_win_11683 )
      fake_win_11683 = newwin(2, fake_max_11684, 0, 0);
    if ( fake_win_11683 )
    {
      result = 0;
      wmove(fake_win_11683, 0, 0);
      for ( n = 0; n < used; ++n )
      {
        if ( string[n] && (string[n] <= 2 || string[n] > 8) )
        {
          waddch(fake_win_11683, (unsigned __int8)string[n]);
          if ( fake_win_11683 )
            cury = fake_win_11683->_cury;
          else
            cury = -1;
          if ( fake_win_11683 )
            curx = fake_win_11683->_curx;
          else
            curx = -1;
          if ( cury > 0 || curx > maxCells )
            break;
          result = curx;
        }
      }
    }
  }
  if ( result > maxCells )
    return maxCells;
  return result;
}

//----- (0808E0D3) --------------------------------------------------------
int __cdecl LYstrExtent2(const char *string, int len)
{
  return LYstrExtent(string, len, 8 * len);
}

//----- (0808E0F7) --------------------------------------------------------
int __cdecl LYstrCells(const char *string)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = strlen(string);
  return LYstrExtent2(string, v2);
}

//----- (0808E119) --------------------------------------------------------
int LYscreenHeight()
{
  int result; // [esp+Ch] [ebp-4h]

  result = LINES;
  if ( LINES <= 0 )
    return 24;
  return result;
}
// 81AAAE0: using guessed type int LINES;

//----- (0808E139) --------------------------------------------------------
int LYscreenWidth()
{
  int result; // [esp+Ch] [ebp-4h]

  result = COLS;
  if ( COLS <= 0 )
    return 80;
  return result;
}
// 81AAAE4: using guessed type int COLS;

//----- (0808E159) --------------------------------------------------------
void LYnormalColor()
{
  if ( LYwin != stdscr && displayStyles[128].color >= 0 )
  {
    wbkgd(LYwin, displayStyles[128].color | 0x20);
    LYrefresh();
  }
}

//----- (0808E19B) --------------------------------------------------------
void LYclear()
{
  wclear(LYwin);
  LYnormalColor();
}

//----- (0808E1B5) --------------------------------------------------------
void LYclrtoeol()
{
  wclrtoeol(LYwin);
}

//----- (0808E1CA) --------------------------------------------------------
void LYerase()
{
  werase(LYwin);
  LYnormalColor();
}

//----- (0808E1E4) --------------------------------------------------------
void __cdecl LYmove(int y, int x)
{
  wmove(LYwin, y, x);
}

//----- (0808E207) --------------------------------------------------------
void LYrefresh()
{
  int v0; // eax
  int cury; // [esp+28h] [ebp-20h]
  int curx; // [esp+2Ch] [ebp-1Ch]
  int x; // [esp+3Ch] [ebp-Ch]

  if ( LYwin == stdscr )
  {
    wrefresh(stdscr);
  }
  else
  {
    if ( LYwin )
      cury = LYwin->_cury;
    else
      cury = -1;
    if ( LYwin )
      curx = LYwin->_curx;
    else
      curx = -1;
    x = curx;
    if ( LYcols - (LYShowScrollbar != 0) < curx )
      x = LYcols - (LYShowScrollbar != 0);
    wmove(stdscr, cury, x);
    wnoutrefresh(stdscr);
    v0 = LYscreenWidth();
    pnoutrefresh(LYwin, 0, LYshiftWin, 0, 0, LYlines, v0 - 1);
    if ( my_subwindow )
    {
      wtouchln(my_subwindow, 0, my_subwindow->_maxy + 1, 1);
      wnoutrefresh(my_subwindow);
    }
    doupdate();
  }
}

//----- (0808E38D) --------------------------------------------------------
void lynx_force_repaint()
{
  clearok(curscr, 1);
}

//----- (0808E3AA) --------------------------------------------------------
void lynx_start_title_color()
{
  ;
}

//----- (0808E3AF) --------------------------------------------------------
void lynx_stop_title_color()
{
  ;
}

//----- (0808E3B4) --------------------------------------------------------
void __cdecl lynx_start_link_color(int flag, int pending)
{
  if ( !flag )
  {
    lynx_start_bold();
    if ( !pending )
      return;
    goto LABEL_6;
  }
  lynx_start_reverse();
  if ( lynx_has_color && LYShowColor > 1 )
LABEL_6:
    lynx_start_underline();
}

//----- (0808E3F1) --------------------------------------------------------
void __cdecl lynx_stop_link_color(int flag, int pending)
{
  int style; // [esp+14h] [ebp-4h]

  if ( flag == 1 )
    style = s_alink;
  else
    style = s_a;
  curses_style(style, 0);
}

//----- (0808E424) --------------------------------------------------------
void lynx_stop_target_color()
{
  lynx_stop_underline();
  lynx_stop_reverse();
  lynx_stop_bold();
}

//----- (0808E43B) --------------------------------------------------------
void lynx_start_target_color()
{
  lynx_start_bold();
  lynx_start_reverse();
  lynx_start_underline();
}

//----- (0808E452) --------------------------------------------------------
void lynx_start_status_color()
{
  if ( lynx_has_color && LYShowColor > 1 )
    lynx_set_color(2);
  else
    lynx_start_reverse();
}

//----- (0808E480) --------------------------------------------------------
void lynx_stop_status_color()
{
  if ( lynx_has_color && LYShowColor > 1 )
    lynx_set_color(0);
  else
    lynx_stop_reverse();
}

//----- (0808E4AE) --------------------------------------------------------
void lynx_start_h1_color()
{
  if ( bold_H1 || bold_headers )
    lynx_start_bold();
}

//----- (0808E4D1) --------------------------------------------------------
void lynx_stop_h1_color()
{
  if ( bold_H1 || bold_headers )
    lynx_stop_bold();
}

//----- (0808E4F4) --------------------------------------------------------
void lynx_start_prompt_color()
{
  lynx_start_reverse();
}

//----- (0808E501) --------------------------------------------------------
void lynx_stop_prompt_color()
{
  lynx_stop_reverse();
}

//----- (0808E50E) --------------------------------------------------------
void lynx_start_radio_color()
{
  lynx_start_bold();
}

//----- (0808E51B) --------------------------------------------------------
void lynx_stop_radio_color()
{
  lynx_stop_bold();
}

//----- (0808E528) --------------------------------------------------------
void lynx_stop_all_colors()
{
  lynx_stop_underline();
  lynx_stop_reverse();
  lynx_stop_bold();
}

//----- (0808E53F) --------------------------------------------------------
void lynx_start_bold()
{
  if ( LYUnderlineLinks )
    wattr_on(LYwin, 0x20000u, 0);
  else
    wattr_on(LYwin, 0x200000u, 0);
}

//----- (0808E57E) --------------------------------------------------------
void lynx_start_reverse()
{
  wattr_on(LYwin, 0x40000u, 0);
}

//----- (0808E5A3) --------------------------------------------------------
void lynx_start_underline()
{
  if ( LYUnderlineLinks )
    wattr_on(LYwin, 0x200000u, 0);
  else
    wattr_on(LYwin, 0x20000u, 0);
}

//----- (0808E5E2) --------------------------------------------------------
void lynx_stop_bold()
{
  if ( LYUnderlineLinks )
    wattr_off(LYwin, 0x20000u, 0);
  else
    wattr_off(LYwin, 0x200000u, 0);
}

//----- (0808E621) --------------------------------------------------------
void lynx_stop_reverse()
{
  wattr_off(LYwin, 0x40000u, 0);
}

//----- (0808E646) --------------------------------------------------------
void lynx_stop_underline()
{
  if ( LYUnderlineLinks )
    wattr_off(LYwin, 0x200000u, 0);
  else
    wattr_off(LYwin, 0x20000u, 0);
}

//----- (0808E685) --------------------------------------------------------
void LYSetDisplayLines()
{
  if ( no_title )
  {
    if ( user_mode )
      display_lines = LYlines - 1;
    else
      display_lines = LYlines - 3;
  }
  else if ( user_mode )
  {
    display_lines = LYlines - 2;
  }
  else
  {
    display_lines = LYlines - 4;
  }
}

//----- (0808E6E1) --------------------------------------------------------
void __cdecl LYstowCursor(WINDOW *win, int row, int col)
{
  if ( LYShowCursor )
    wmove(win, row, col);
  else
    LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
  wrefresh(win);
}

//----- (0808E74C) --------------------------------------------------------
int __cdecl LYgetattrs(WINDOW *win)
{
  return win->_attrs;
}

//----- (0808E780) --------------------------------------------------------
int __cdecl LYindex2MBM(int n)
{
  if ( n < 0 || n > 25 )
    return 63;
  else
    return MBMcodes_10881[n];
}

//----- (0808E7B0) --------------------------------------------------------
int __cdecl LYMBM2index(int ch_0)
{
  int v2; // [esp+10h] [ebp-18h]
  char *result; // [esp+20h] [ebp-8h]

  if ( ((*__ctype_b_loc())[(unsigned __int8)ch_0] & 0x200) != 0 )
    v2 = toupper((unsigned __int8)ch_0);
  else
    v2 = (unsigned __int8)ch_0;
  if ( v2 > 0 && (result = strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZ", v2)) != 0 && result - "ABCDEFGHIJKLMNOPQRSTUVWXYZ" <= 25 )
    return result - "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  else
    return -1;
}

//----- (0808E849) --------------------------------------------------------
void show_bookmark_not_defined()
{
  char *v0; // ebx
  char *v1; // eax
  char *string_buffer; // [esp+20h] [ebp-8h] BYREF

  string_buffer = 0;
  v0 = key_for_func(49);
  v1 = gettext("Bookmark file is not defined. Use %s to see options.");
  HTSprintf0(&string_buffer, v1, v0);
  LYMBM_statusline(string_buffer);
  if ( string_buffer )
    free(string_buffer);
}

//----- (0808E8AE) --------------------------------------------------------
const char *__cdecl get_bookmark_filename(char **URL)
{
  const char *v1; // ebx
  FILE *v2; // eax
  const char *v4; // [esp+4h] [ebp-24h]
  int MBM_tmp; // [esp+18h] [ebp-10h]
  FILE *fp; // [esp+1Ch] [ebp-Ch]
  char *string_buffer; // [esp+20h] [ebp-8h] BYREF

  string_buffer = 0;
  MBM_tmp = select_multi_bookmarks();
  if ( MBM_tmp == -2 )
    return &byte_8155B15;
  if ( MBM_tmp == -1 )
  {
    show_bookmark_not_defined();
    return " ";
  }
  else
  {
    HTSACopy(&BookmarkPage, MBM_A_subbookmark[MBM_tmp]);
    LYAddPathToHome(filename_buffer_10939, 0x100u, BookmarkPage);
    if ( WWW_TraceFlag[0] )
    {
      v1 = BookmarkPage;
      v2 = TraceFP();
      fprintf(v2, "\nget_bookmark_filename: SEEKING %s\n   AS %s\n\n", v1, filename_buffer_10939);
    }
    fp = (FILE *)fopen64(filename_buffer_10939, "r");
    if ( fp )
    {
      if ( LYSafeGets(&string_buffer, fp)
        && *LYTrimNewline(string_buffer)
        && !strncmp(string_buffer, "ncsa-xmosaic-hotlist-format-1", 0x1Du) )
      {
        is_mosaic_hotlist[0] = 1;
        v4 = convert_mosaic_bookmark_file(filename_buffer_10939);
        LYLocalFileToURL(URL, v4);
      }
      else
      {
        is_mosaic_hotlist[0] = 0;
        LYLocalFileToURL(URL, filename_buffer_10939);
      }
      if ( string_buffer )
      {
        free(string_buffer);
        string_buffer = 0;
      }
      LYCloseInput(fp);
      return filename_buffer_10939;
    }
    else
    {
      return 0;
    }
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0808EA41) --------------------------------------------------------
const char *__cdecl convert_mosaic_bookmark_file(const char *filename_buffer)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int line; // [esp+18h] [ebp-10h]
  char *buf; // [esp+1Ch] [ebp-Ch] BYREF
  FILE *nfp; // [esp+20h] [ebp-8h]
  FILE *fp; // [esp+24h] [ebp-4h]

  buf = 0;
  line = -2;
  LYRemoveTemp(newfile_10985);
  nfp = LYOpenTemp(newfile_10985, ".html", "w");
  if ( nfp )
  {
    fp = (FILE *)fopen64(filename_buffer, "r");
    if ( fp )
    {
      v2 = gettext("Converted Mosaic Hotlist");
      fprintf(nfp, "<head>\n<title>%s</title>\n</head>\n", v2);
      v3 = gettext(
             "     This file is an HTML representation of the X Mosaic hotlist file.\n"
             "     Outdated or invalid links may be removed by using the\n"
             "     remove bookmark command, it is usually the 'R' key but may have\n"
             "     been remapped by you or your system administrator.");
      fprintf(nfp, "%s\n\n<p>\n<ol>\n", v3);
      while ( LYSafeGets(&buf, fp) )
      {
        if ( line >= 0 )
        {
          LYTrimNewline(buf);
          if ( (line & 1) != 0 )
          {
            fprintf(nfp, "%s</a>\n", buf);
          }
          else if ( *buf )
          {
            strtok(buf, " ");
            fprintf(nfp, "<LI><a href=\"%s\">", buf);
          }
        }
        ++line;
      }
      LYCloseTempFP(nfp);
      LYCloseInput(fp);
      return newfile_10985;
    }
    else
    {
      return &byte_8155B15;
    }
  }
  else
  {
    v1 = gettext("Unable to open tempfile for X Mosaic hotlist conversion.");
    LYMBM_statusline(v1);
    LYSleepAlert();
    return &byte_8155B15;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0808EBC9) --------------------------------------------------------
void __cdecl save_bookmark_link(const char *address, const char *title)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  const char *v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // esi
  char *v12; // ebx
  char *v13; // eax
  char *v14; // eax
  const char *v15; // [esp+1Ch] [ebp-417Ch]
  DocAddress WWWDoc; // [esp+3Ch] [ebp-415Ch] BYREF
  char *TimeString; // [esp+50h] [ebp-4148h]
  time_t NowTime; // [esp+54h] [ebp-4144h] BYREF
  char *p; // [esp+58h] [ebp-4140h]
  const char *page; // [esp+5Ch] [ebp-413Ch]
  const char *url; // [esp+60h] [ebp-4138h]
  HText *text; // [esp+64h] [ebp-4134h]
  HTParentAnchor *tmpanchor; // [esp+68h] [ebp-4130h]
  int c; // [esp+6Ch] [ebp-412Ch]
  int i; // [esp+70h] [ebp-4128h]
  char *Title; // [esp+74h] [ebp-4124h] BYREF
  char *Address; // [esp+78h] [ebp-4120h] BYREF
  char *bookmark_URL; // [esp+7Ch] [ebp-411Ch] BYREF
  const char *filename; // [esp+80h] [ebp-4118h]
  FILE *fp; // [esp+84h] [ebp-4114h]
  BOOLEAN first_time; // [esp+8Bh] [ebp-410Dh]
  char tmp_buffer[8192]; // [esp+8Ch] [ebp-410Ch] BYREF
  char string_buffer[8192]; // [esp+208Ch] [ebp-210Ch] BYREF
  char filename_buffer[256]; // [esp+408Ch] [ebp-10Ch] BYREF
  unsigned int v35; // [esp+418Ch] [ebp-Ch]

  v35 = __readgsdword(0x14u);
  first_time = 0;
  bookmark_URL = 0;
  Address = 0;
  Title = 0;
  if ( !address || !*address )
  {
    v2 = gettext("Malformed address.");
    HTAlert(v2);
    return;
  }
  filename = get_bookmark_filename(&bookmark_URL);
  if ( filename )
  {
    if ( !*filename || !strcmp(filename, " ") )
    {
      if ( !bookmark_URL )
        return;
      goto LABEL_32;
    }
    LYstrncpy(filename_buffer, filename, 255);
  }
  else
  {
    first_time = 1;
    filename_buffer[0] = 0;
  }
  if ( BookmarkPage )
  {
    if ( LYMultiBookmarks
      && ((url = HTLoadedDocumentURL(), *BookmarkPage != 46) ? (v15 = BookmarkPage) : (v15 = BookmarkPage + 1),
          (page = v15, strstr(url, v15))
       && (v3 = gettext("Reproduce L)ink in this bookmark file or C)ancel? (l,c): "),
           LYMBM_statusline(v3),
           c = LYgetch_single(),
           c != 76)) )
    {
      if ( !bookmark_URL )
        return;
    }
    else
    {
      while ( 1 )
      {
        if ( HTCJK == JAPANESE )
        {
          if ( kanji_code == EUC )
          {
            TO_EUC((const unsigned __int8 *)title, (unsigned __int8 *)tmp_buffer);
          }
          else if ( kanji_code == SJIS )
          {
            TO_SJIS((const unsigned __int8 *)title, (unsigned __int8 *)tmp_buffer);
          }
          LYstrncpy(string_buffer, tmp_buffer, 0x1FFF);
        }
        else
        {
          LYstrncpy(string_buffer, title, 0x1FFF);
        }
        LYReduceBlanks(string_buffer);
        v4 = gettext("Title: ");
        LYMBM_statusline(v4);
        LYgetstr(string_buffer, 0, 0x2000u, NORECALL);
        if ( !string_buffer[0] )
          break;
        if ( havevisible(string_buffer) )
        {
          LYformTitle(&Title, string_buffer);
          LYEntify(&Title, 1);
          if ( UCSaveBookmarksInUnicode && have8bit(Title) && !LYHaveCJKCharacterSet )
          {
            p = title_convert8bit(Title);
            if ( Title )
            {
              free(Title);
              Title = 0;
            }
            Title = p;
          }
          if ( first_time )
            LYAddPathToHome(filename_buffer, 0x100u, BookmarkPage);
          if ( WWW_TraceFlag[0] )
          {
            v6 = BookmarkPage;
            v7 = TraceFP();
            fprintf(v7, "\nsave_bookmark_link: SEEKING %s\n   AS %s\n\n", v6, filename_buffer);
          }
          if ( first_time )
            v8 = (FILE *)fopen64(filename_buffer, "w");
          else
            v8 = (FILE *)fopen64(filename_buffer, "a+");
          fp = v8;
          if ( v8 )
          {
            HTSACopy(&Address, address);
            LYEntify(&Address, 0);
            if ( first_time )
            {
              fwrite("<head>\n", 1u, 7u, fp);
              LYAddMETAcharsetToFD(fp, -1);
              v10 = gettext("Bookmark file");
              fprintf(fp, "<title>%s</title>\n</head>\n", v10);
              v11 = gettext(
                      "Note: if you edit this file manually\n"
                      "      you should not change the format within the lines\n"
                      "      or add other HTML markup.\n"
                      "      Make sure any bookmark link is saved as a single line.");
              v12 = gettext(
                      "     This file also may be edited with a standard text editor to delete\n"
                      "     outdated or invalid links, or to change their order.");
              v13 = gettext(
                      "     You can delete links using the remove bookmark command.  It is usually\n"
                      "     the 'R' key but may have been remapped by you or your system\n"
                      "     administrator.");
              fprintf(fp, "%s<br>\n%s\n\n<!--\n%s\n-->\n\n<p>\n<ol>\n", v13, v12, v11);
            }
            if ( is_mosaic_hotlist[0] )
            {
              NowTime = time(0);
              TimeString = ctime(&NowTime);
              fprintf(fp, "%s %s%s\n", Address, TimeString, Title);
            }
            else
            {
              fprintf(fp, "<LI><a href=\"%s\">%s</a>\n", Address, Title);
            }
            LYCloseOutput(fp);
            if ( !first_time && nhist > 0 && bookmark_URL )
            {
              for ( i = 0; i < nhist; ++i )
              {
                if ( history[i].hdoc.bookmark && !strcmp(history[i].hdoc.address, bookmark_URL) )
                {
                  WWWDoc.address = history[i].hdoc.address;
                  WWWDoc.post_data = 0;
                  WWWDoc.post_content_type = 0;
                  WWWDoc.bookmark = history[i].hdoc.bookmark;
                  WWWDoc.isHEAD = 0;
                  WWWDoc.safe = 0;
                  tmpanchor = HTAnchor_findAddress(&WWWDoc);
                  text = (HText *)HTAnchor_document(tmpanchor);
                  if ( text )
                    HText_setNoCache(text);
                  break;
                }
              }
            }
            if ( Title )
            {
              free(Title);
              Title = 0;
            }
            if ( Address )
            {
              free(Address);
              Address = 0;
            }
            if ( bookmark_URL )
            {
              free(bookmark_URL);
              bookmark_URL = 0;
            }
            v14 = gettext("Done!");
            LYMBM_statusline(v14);
            LYSleepMsg();
          }
          else
          {
            v9 = gettext("ERROR - unable to open bookmark file.");
            LYMBM_statusline(v9);
            LYSleepAlert();
            if ( Title )
            {
              free(Title);
              Title = 0;
            }
            if ( bookmark_URL )
            {
              free(bookmark_URL);
              bookmark_URL = 0;
            }
          }
          return;
        }
      }
      v5 = gettext("Cancelled!!!");
      LYMBM_statusline(v5);
      LYSleepMsg();
      if ( !bookmark_URL )
        return;
    }
  }
  else if ( !bookmark_URL )
  {
    return;
  }
LABEL_32:
  free(bookmark_URL);
  bookmark_URL = 0;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0808F414) --------------------------------------------------------
void __cdecl remove_bookmark_link(int cur, char *cur_bookmark_page)
{
  FILE *v2; // eax
  FILE *v3; // edx
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  int *v10; // eax
  char *v11; // ebx
  FILE *v12; // eax
  char *v13; // eax
  int *v14; // eax
  char *v15; // ebx
  FILE *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  bool v20; // [esp+1Ch] [ebp-3ACh]
  stat stat_buf; // [esp+2Ch] [ebp-39Ch] BYREF
  const char *program; // [esp+8Ch] [ebp-33Ch]
  char *buffer; // [esp+90h] [ebp-338h] BYREF
  int keep_ol; // [esp+94h] [ebp-334h]
  int seen; // [esp+98h] [ebp-330h]
  char *cp; // [esp+A0h] [ebp-328h]
  int del_line; // [esp+A4h] [ebp-324h]
  mode_t mode; // [esp+A8h] [ebp-320h]
  int n; // [esp+ACh] [ebp-31Ch]
  char *buf; // [esp+B0h] [ebp-318h] BYREF
  FILE *nfp; // [esp+B4h] [ebp-314h]
  FILE *fp; // [esp+B8h] [ebp-310h]
  BOOLEAN retain; // [esp+BDh] [ebp-30Bh]
  BOOLEAN regular; // [esp+BEh] [ebp-30Ah]
  BOOLEAN keep_tempfile; // [esp+BFh] [ebp-309h]
  char homepath[256]; // [esp+C0h] [ebp-308h] BYREF
  char newfile[256]; // [esp+1C0h] [ebp-208h] BYREF
  char filename_buffer[256]; // [esp+2C0h] [ebp-108h] BYREF
  unsigned int v40; // [esp+3C0h] [ebp-8h]

  v40 = __readgsdword(0x14u);
  buf = 0;
  keep_tempfile = 0;
  regular = 0;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "remove_bookmark_link: deleting link number: %d\n", cur);
  }
  if ( cur_bookmark_page )
  {
    LYAddPathToHome(filename_buffer, 0x100u, cur_bookmark_page);
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "\nremove_bookmark_link: SEEKING %s\n   AS %s\n\n", cur_bookmark_page, filename_buffer);
    }
    fp = (FILE *)fopen64(filename_buffer, "r");
    if ( !fp )
    {
      v4 = gettext("Unable to open bookmark file for deletion of link.");
      HTAlert(v4);
      return;
    }
    LYAddPathToHome(homepath, 0x100u, &byte_8155B15);
    nfp = LYOpenScratch(newfile, homepath);
    if ( !nfp )
    {
      LYCloseInput(fp);
      v5 = gettext("Unable to open scratch file for deletion of link.");
      HTAlert(v5);
      return;
    }
    if ( !stat64((int)filename_buffer, (int)&stat_buf) )
    {
      v20 = (stat_buf.st_mode & 0xF000) == 0x8000 && stat_buf.st_nlink == 1;
      regular = v20;
      mode = LOBYTE(stat_buf.st_mode) | 0x180;
      chmod(newfile, mode);
      nfp = LYReopenTemp(newfile);
      if ( !nfp )
      {
        LYCloseInput(fp);
        v6 = gettext("Unable to reopen temporary file for deletion of link.");
        HTAlert(v6);
        return;
      }
    }
    if ( is_mosaic_hotlist[0] )
    {
      del_line = 2 * cur;
      n = -3;
      while ( LYSafeGets(&buf, fp) )
      {
        if ( ++n != del_line && del_line + 1 != n && fputs(buf, nfp) == -1 )
          goto failure;
      }
    }
    else
    {
      n = -1;
      while ( LYSafeGets(&buf, fp) )
      {
        keep_ol = 0;
        retain = 1;
        seen = 0;
        cp = buf;
        if ( !cur )
        {
          if ( LYstrstr(cp, "<ol><LI>") )
            keep_ol = 1;
        }
        while ( n < cur )
        {
          cp = LYstrstr(cp, "<a href=");
          if ( !cp )
            break;
          ++seen;
          if ( ++n == cur )
          {
            if ( seen != 1 || !LYstrstr(buf, "</a>") || LYstrstr(cp + 1, "<a href=") )
            {
              v7 = gettext("Link is not by itself all on one line in bookmark file.");
              HTAlert(v7);
              goto failure;
            }
            if ( WWW_TraceFlag[0] )
            {
              v8 = TraceFP();
              fprintf(v8, "remove_bookmark_link: skipping link %d\n", n);
            }
            if ( keep_ol )
              fwrite("<ol>\n", 1u, 5u, nfp);
            retain = 0;
          }
          cp += 8;
        }
        if ( retain && fputs(buf, nfp) == -1 )
          goto failure;
      }
    }
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    if ( WWW_TraceFlag[0] )
    {
      v9 = TraceFP();
      fprintf(v9, "remove_bookmark_link: files: %s %s\n", newfile, filename_buffer);
    }
    LYCloseInput(fp);
    fp = 0;
    if ( fflush(nfp) == -1 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v10 = __errno_location();
        v11 = strerror(*v10);
        v12 = TraceFP();
        fprintf(v12, "fflush(nfp): %s", v11);
      }
      goto failure;
    }
    LYCloseTempFP(nfp);
    nfp = 0;
    if ( !regular )
    {
      if ( !LYCopyFile(newfile, filename_buffer) )
      {
LABEL_79:
        LYRemoveTemp(newfile);
        return;
      }
      LYSleepAlert();
      v13 = gettext("Unable to copy temporary file for deletion of link.");
      HTUserMsg(v13);
      keep_tempfile = 1;
    }
    if ( rename(newfile, filename_buffer) != -1 )
    {
      if ( regular )
        chmod(filename_buffer, stat_buf.st_mode & 0xFFF);
      return;
    }
    if ( *__errno_location() == 18 )
    {
      buffer = 0;
      program = HTGetProgramPath(ppMV_0);
      if ( program )
      {
        HTAddParam(&buffer, "%s %s %s", 1, program);
        HTAddParam(&buffer, "%s %s %s", 2, newfile);
        HTAddParam(&buffer, "%s %s %s", 3, filename_buffer);
        HTEndParam(&buffer, "%s %s %s", 3);
        if ( !LYSystem(buffer) )
        {
          if ( regular )
            chmod(filename_buffer, stat_buf.st_mode & 0xFFF);
          if ( buffer )
          {
            free(buffer);
            buffer = 0;
          }
          return;
        }
      }
      if ( buffer )
      {
        free(buffer);
        buffer = 0;
      }
      keep_tempfile = 1;
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v14 = __errno_location();
        v15 = strerror(*v14);
        v16 = TraceFP();
        fprintf(v16, "rename(): %s", v15);
      }
      v17 = gettext("Error renaming temporary file.");
      HTAlert(v17);
      if ( WWW_TraceFlag[0] )
        perror("renaming the file");
    }
failure:
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    v18 = gettext("Bookmark deletion failed.");
    HTAlert(v18);
    if ( nfp )
      LYCloseTempFP(nfp);
    if ( fp )
      LYCloseInput(fp);
    if ( keep_tempfile )
    {
      v19 = gettext("File may be recoverable from %s during this session");
      HTUserMsg2(v19, newfile);
      return;
    }
    goto LABEL_79;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0808FCAA) --------------------------------------------------------
int select_multi_bookmarks()
{
  char *v0; // eax
  int c; // [esp+24h] [ebp-4h]
  int ca; // [esp+24h] [ebp-4h]

  if ( LYMultiBookmarks && (unsigned __int8)LYHaveSubBookmarks() )
  {
    if ( LYMultiBookmarks == 2 && user_mode == 2 )
    {
      v0 = gettext("Select subbookmark, '=' for menu, or ^G to cancel: ");
      LYMBM_statusline(v0);
      do
      {
        while ( 1 )
        {
          c = LYgetch();
          if ( LYisNonAlnumKeyname(c, 37) || c == 3 || c == 7 )
            return -2;
          if ( !LYisNonAlnumKeyname(c, 21) )
            break;
          lynx_force_repaint();
          LYrefresh();
        }
        if ( LYisNonAlnumKeyname(c, 39) )
        {
          if ( MBM_A_subbookmark[0] )
            return 0;
          else
            return -1;
        }
        if ( c == 61 )
          return select_menu_multi_bookmarks();
        ca = LYMBM2index(c);
      }
      while ( ca < 0 );
      if ( MBM_A_subbookmark[ca] )
        return ca;
      else
        return -1;
    }
    else
    {
      return select_menu_multi_bookmarks();
    }
  }
  else if ( MBM_A_subbookmark[0] )
  {
    return 0;
  }
  else
  {
    return -1;
  }
}

//----- (0808FE01) --------------------------------------------------------
int select_menu_multi_bookmarks()
{
  char *v0; // eax
  char *v1; // eax
  size_t v2; // eax
  char *v3; // eax
  size_t v4; // ebx
  char *v5; // eax
  int v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  char *v9; // eax
  size_t v10; // ebx
  char *v11; // eax
  char *v12; // eax
  size_t v13; // ebx
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *shead_buffer; // [esp+30h] [ebp-28h] BYREF
  int MBM_current; // [esp+34h] [ebp-24h]
  int MBM_to; // [esp+38h] [ebp-20h]
  int MBM_from; // [esp+3Ch] [ebp-1Ch]
  int MBM_screens; // [esp+40h] [ebp-18h]
  int MBM_allow; // [esp+44h] [ebp-14h]
  int MBM_tmp_count; // [esp+48h] [ebp-10h]
  int d; // [esp+4Ch] [ebp-Ch]
  int c; // [esp+50h] [ebp-8h]

  if ( !LYMultiBookmarks )
    return 0;
  MBM_allow = LYlines - 7;
  if ( LYlines - 7 > 0 )
  {
    MBM_screens = 25 / MBM_allow + 1;
    MBM_current = 1;
LABEL_6:
    MBM_from = MBM_allow * (MBM_current - 1);
    if ( MBM_from < 0 )
      MBM_from = 0;
    if ( MBM_current != 1 )
      ++MBM_from;
    MBM_to = MBM_current * MBM_allow;
    if ( MBM_current * MBM_allow > 25 )
      MBM_to = 25;
    LYclear();
    LYmove(1, 5);
    lynx_start_h1_color();
    if ( MBM_screens <= 1 )
    {
      v3 = gettext("       Select Bookmark");
      v4 = strlen(v3);
      v5 = gettext("       Select Bookmark");
      LYwaddnstr(LYwin, v5, v4);
    }
    else
    {
      shead_buffer = 0;
      v1 = gettext(" Select Bookmark (screen %d of %d)");
      HTSprintf0(&shead_buffer, v1, MBM_current, MBM_screens);
      v2 = strlen(shead_buffer);
      LYwaddnstr(LYwin, shead_buffer, v2);
      if ( shead_buffer )
      {
        free(shead_buffer);
        shead_buffer = 0;
      }
    }
    lynx_stop_h1_color();
    MBM_tmp_count = 0;
    for ( c = MBM_from; c <= MBM_to; ++c )
    {
      LYmove(MBM_tmp_count + 3, 5);
      v6 = LYindex2MBM(c);
      waddch(LYwin, v6);
      LYwaddnstr(LYwin, " : ", 3u);
      if ( MBM_A_subdescript[c] )
      {
        v7 = strlen(MBM_A_subdescript[c]);
        LYwaddnstr(LYwin, MBM_A_subdescript[c], v7);
      }
      LYmove(MBM_tmp_count + 3, 36);
      waddch(LYwin, 0x28u);
      if ( MBM_A_subbookmark[c] )
      {
        v8 = strlen(MBM_A_subbookmark[c]);
        LYwaddnstr(LYwin, MBM_A_subbookmark[c], v8);
      }
      waddch(LYwin, 0x29u);
      ++MBM_tmp_count;
    }
    if ( MBM_screens > 1 )
    {
      LYmove(LYlines - 2, 0);
      LYwaddnstr(LYwin, "'", 1u);
      lynx_start_bold();
      LYwaddnstr(LYwin, "[", 1u);
      lynx_stop_bold();
      LYwaddnstr(LYwin, "' ", 2u);
      v9 = gettext("previous");
      v10 = strlen(v9);
      v11 = gettext("previous");
      LYwaddnstr(LYwin, v11, v10);
      LYwaddnstr(LYwin, ", '", 3u);
      lynx_start_bold();
      LYwaddnstr(LYwin, "]", 1u);
      lynx_stop_bold();
      LYwaddnstr(LYwin, "' ", 2u);
      v12 = gettext("next screen");
      v13 = strlen(v12);
      v14 = gettext("next screen");
      LYwaddnstr(LYwin, v14, v13);
    }
    v15 = gettext("Select destination or ^G to Cancel: ");
    LYMBM_statusline(v15);
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          c = LYgetch();
          d = LYMBM2index(c);
          if ( d < 0 )
            break;
          if ( MBM_A_subbookmark[d] )
            return d;
          show_bookmark_not_defined();
          v16 = gettext("Select destination or ^G to Cancel: ");
          LYMBM_statusline(v16);
        }
        if ( LYisNonAlnumKeyname(c, 37) || c == 7 || c == 3 )
          return -2;
        if ( !LYisNonAlnumKeyname(c, 21) )
          break;
        lynx_force_repaint();
        LYrefresh();
      }
      if ( LYisNonAlnumKeyname(c, 39) )
        break;
      if ( (c == 93 || LYisNonAlnumKeyname(c, 15)) && MBM_screens > 1 )
      {
        if ( ++MBM_current > MBM_screens )
          MBM_current = 1;
        goto LABEL_6;
      }
      if ( (c == 91 || LYisNonAlnumKeyname(c, 16)) && MBM_screens > 1 )
      {
        if ( --MBM_current <= 0 )
          MBM_current = MBM_screens;
        goto LABEL_6;
      }
    }
    if ( MBM_A_subbookmark[0] )
      return 0;
    else
      return -1;
  }
  else
  {
    v0 = gettext("Screen too small! (8x35 min)");
    HTAlert(v0);
    return -2;
  }
}

//----- (08090388) --------------------------------------------------------
int LYHaveSubBookmarks()
{
  int i; // [esp+10h] [ebp-4h]

  for ( i = 1; i <= 24; ++i )
  {
    if ( MBM_A_subbookmark[i] && *MBM_A_subbookmark[i] )
      return 1;
  }
  return 0;
}

//----- (080903D0) --------------------------------------------------------
void __cdecl LYMBM_statusline(const char *text)
{
  if ( !LYMultiBookmarks || user_mode )
  {
    mustshow[0] = 1;
    statusline(text);
  }
  else
  {
    LYStatusLine = LYlines - 1;
    mustshow[0] = 1;
    statusline(text);
    LYStatusLine = -1;
  }
}

//----- (08090427) --------------------------------------------------------
BOOLEAN __cdecl havevisible(const char *Title)
{
  int unicode; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 c; // [esp+27h] [ebp-1h]

  while ( *Title )
  {
    c = *Title;
    if ( *Title > 0x20u && c <= 0x7Eu )
      return 1;
    if ( c > 0x20u && c != 127 )
    {
      if ( LYHaveCJKCharacterSet || !UCCanUniTranslateFrom(current_char_set) )
        return 1;
      unicode = UCTransToUni(*Title, current_char_set);
      if ( unicode > 32 && unicode <= 126 )
        return 1;
      if ( unicode > 32 && unicode != 160 && unicode != 173 && (unicode <= 0x1FFF || unicode > 8206) )
        return 1;
    }
    ++Title;
  }
  return 0;
}

//----- (08090508) --------------------------------------------------------
BOOLEAN __cdecl have8bit(const char *Title)
{
  while ( *Title )
  {
    if ( *Title < 0 )
      return 1;
    ++Title;
  }
  return 0;
}

//----- (0809053E) --------------------------------------------------------
char *__cdecl title_convert8bit(const char *Title)
{
  int unicode; // [esp+2Ch] [ebp-4Ch]
  int charset_out; // [esp+30h] [ebp-48h]
  int charset_in; // [esp+34h] [ebp-44h]
  char *buf; // [esp+38h] [ebp-40h] BYREF
  char *ncr; // [esp+3Ch] [ebp-3Ch] BYREF
  char *comment; // [esp+40h] [ebp-38h] BYREF
  char *q; // [esp+44h] [ebp-34h]
  char *p0; // [esp+48h] [ebp-30h]
  const char *p; // [esp+4Ch] [ebp-2Ch]
  char temp[2]; // [esp+52h] [ebp-26h] BYREF
  char replace_buf[32]; // [esp+54h] [ebp-24h] BYREF
  unsigned int v13; // [esp+74h] [ebp-4h]

  v13 = __readgsdword(0x14u);
  p = Title;
  comment = 0;
  ncr = 0;
  buf = 0;
  charset_in = current_char_set;
  charset_out = UCGetLYhndl_byMIME("us-ascii");
  while ( *p )
  {
    LYstrncpy(temp, p, 1);
    if ( temp[0] < 0 )
    {
      if ( UCTransCharStr(replace_buf, 32, temp[0], charset_in, charset_out, 1) > 0 )
        HTSACat(&comment, replace_buf);
      unicode = UCTransToUni(temp[0], charset_in);
      HTSACat(&ncr, "&#");
      sprintf(replace_buf, "%ld", unicode);
      HTSACat(&ncr, replace_buf);
      HTSACat(&ncr, ";");
    }
    else
    {
      HTSACat(&comment, temp);
      HTSACat(&ncr, temp);
    }
    ++p;
  }
  p0 = comment;
  q = comment;
  while ( *p0 )
  {
    if ( (unsigned __int8)*p0 > 0x1Fu && *p0 != 62 && (q == comment || *p0 != 45 || *(q - 1) != 45) )
      *q++ = *p0;
    ++p0;
  }
  *q = 0;
  HTSACat(&buf, "<!-- ");
  HTSACat(&buf, comment);
  HTSACat(&buf, " -->");
  HTSACat(&buf, ncr);
  if ( comment )
  {
    free(comment);
    comment = 0;
  }
  if ( ncr )
  {
    free(ncr);
    ncr = 0;
  }
  return buf;
}

//----- (08090794) --------------------------------------------------------
void __cdecl set_default_bookmark_page(char *value)
{
  char *v1; // eax

  if ( value )
  {
    if ( !bookmark_page || strcmp(bookmark_page, value) )
      HTSACopy(&bookmark_page, value);
    HTSACopy(&BookmarkPage, bookmark_page);
    HTSACopy(MBM_A_subbookmark, bookmark_page);
    v1 = gettext("Default Bookmark File");
    HTSACopy(MBM_A_subdescript, v1);
  }
}

//----- (0809081C) --------------------------------------------------------
time_t __cdecl LYmktime(char *string, BOOLEAN absolute)
{
  FILE *v2; // edx
  char *v3; // ebx
  time_t v4; // esi
  FILE *v5; // eax
  time_t result; // [esp+2Ch] [ebp-Ch] BYREF

  if ( string && *string )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "LYmktime: Parsing '%s'\n", string);
    }
    result = parsedate(string, 0);
    if ( !absolute && time(0) - result >= 0 )
      result = 0;
    if ( result && WWW_TraceFlag[0] )
    {
      v3 = ctime(&result);
      v4 = result;
      v5 = TraceFP();
      fprintf(v5, "LYmktime: clock=%d, ctime=%s", v4, v3);
    }
  }
  return result;
}

//----- (080908F0) --------------------------------------------------------
LY_TEMP *__cdecl FindTempfileByName(const char *name)
{
  LY_TEMP *p; // [esp+14h] [ebp-4h]

  for ( p = ly_temp; p && strcmp(p->name, name); p = p->next )
    ;
  return p;
}

//----- (0809092C) --------------------------------------------------------
LY_TEMP *__cdecl FindTempfileByFP(FILE *fp)
{
  LY_TEMP *p; // [esp+Ch] [ebp-4h]

  for ( p = ly_temp; p && p->file != fp; p = p->next )
    ;
  return p;
}

//----- (0809095A) --------------------------------------------------------
char *__cdecl LYGetEnv(const char *name)
{
  char *result; // [esp+14h] [ebp-4h]

  result = getenv(name);
  if ( result && *result )
    return result;
  else
    return 0;
}

//----- (08090992) --------------------------------------------------------
size_t __cdecl utf8_length(BOOLEAN utf_flag, const char *data)
{
  size_t utf_extra; // [esp+14h] [ebp-4h]

  utf_extra = 0;
  if ( utf_flag && *data < 0 )
  {
    if ( (*data & 0xE0) == 192 )
    {
      utf_extra = 1;
    }
    else if ( (*data & 0xF0) == 224 )
    {
      utf_extra = 2;
    }
    else if ( (*data & 0xF8) == 240 )
    {
      utf_extra = 3;
    }
    else if ( (*data & 0xFC) == 248 )
    {
      utf_extra = 4;
    }
    else if ( (*data & 0xFE) == 252 )
    {
      utf_extra = 5;
    }
    else
    {
      utf_extra = 0;
    }
    if ( strlen(data + 1) < utf_extra )
      return 0;
  }
  return utf_extra;
}

//----- (08090A79) --------------------------------------------------------
void __cdecl LYFreeHilites(int first, int last)
{
  while ( first < last )
  {
    LYSetHilite(first, 0);
    if ( links[first].lname )
    {
      free(links[first].lname);
      links[first].lname = 0;
    }
    ++first;
  }
}

//----- (08090AF1) --------------------------------------------------------
void __cdecl LYSetHilite(int cur, const char *text)
{
  links[cur].list.hl_base.hl_text = (char *)text;
  links[cur].list.hl_len = text != 0;
  if ( links[cur].list.hl_info )
  {
    free(links[cur].list.hl_info);
    links[cur].list.hl_info = 0;
  }
}

//----- (08090B78) --------------------------------------------------------
void __cdecl LYAddHilite(int cur, char *text, int x)
{
  unsigned int want; // [esp+8h] [ebp-10h]
  unsigned int need; // [esp+Ch] [ebp-Ch]
  HiliteInfo *have; // [esp+10h] [ebp-8h]
  HiliteInfo *havea; // [esp+10h] [ebp-8h]

  have = links[cur].list.hl_info;
  need = links[cur].list.hl_len++ - 1;
  want = links[cur].list.hl_len;
  if ( have )
    havea = (HiliteInfo *)realloc(have, 8 * want);
  else
    havea = (HiliteInfo *)malloc(8 * want);
  links[cur].list.hl_info = havea;
  havea[need].hl_text = text;
  havea[need].hl_x = x;
}

//----- (08090C27) --------------------------------------------------------
const char *__cdecl LYGetHiliteStr(int cur, int count)
{
  if ( links[cur].list.hl_len <= count )
    return 0;
  if ( count <= 0 )
    return links[cur].list.hl_base.hl_text;
  return links[cur].list.hl_info[-(1 - count)].hl_text;
}

//----- (08090C9D) --------------------------------------------------------
int __cdecl LYGetHilitePos(int cur, int count)
{
  if ( links[cur].list.hl_len <= count )
    return -1;
  if ( count <= 0 )
    return links[cur].lx;
  return links[cur].list.hl_info[-(1 - count)].hl_x;
}

//----- (08090D16) --------------------------------------------------------
BOOLEAN __cdecl show_whereis_targets(
        int flag,
        int cur,
        int count,
        const char *target,
        BOOLEAN TargetEmphasisON,
        BOOLEAN utf_flag)
{
  int v6; // ebx
  size_t v7; // eax
  size_t v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  size_t v14; // eax
  size_t v15; // eax
  size_t v16; // eax
  size_t v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  size_t v20; // eax
  size_t v21; // eax
  int n_glyphs; // [esp+20h] [ebp-518h]
  char *src; // [esp+24h] [ebp-514h]
  int v25; // [esp+28h] [ebp-510h]
  const char *v26; // [esp+2Ch] [ebp-50Ch]
  int v27; // [esp+30h] [ebp-508h]
  int v28; // [esp+34h] [ebp-504h]
  int v29; // [esp+38h] [ebp-500h]
  int v30; // [esp+3Ch] [ebp-4FCh]
  int v31; // [esp+40h] [ebp-4F8h]
  int v32; // [esp+44h] [ebp-4F4h]
  int v33; // [esp+48h] [ebp-4F0h]
  int v34; // [esp+4Ch] [ebp-4ECh]
  int v35; // [esp+50h] [ebp-4E8h]
  const char *v36; // [esp+54h] [ebp-4E4h]
  const char *v37; // [esp+5Ch] [ebp-4DCh]
  const char *v38; // [esp+64h] [ebp-4D4h]
  int v39; // [esp+6Ch] [ebp-4CCh]
  int v40; // [esp+74h] [ebp-4C4h]
  const char *v41; // [esp+78h] [ebp-4C0h]
  int cury; // [esp+7Ch] [ebp-4BCh]
  int curx; // [esp+80h] [ebp-4B8h]
  int v44; // [esp+84h] [ebp-4B4h]
  int v45; // [esp+88h] [ebp-4B0h]
  int v46; // [esp+8Ch] [ebp-4ACh]
  int v47; // [esp+90h] [ebp-4A8h]
  int v48; // [esp+94h] [ebp-4A4h]
  int v49; // [esp+98h] [ebp-4A0h]
  int v50; // [esp+9Ch] [ebp-49Ch]
  const char *v51; // [esp+A0h] [ebp-498h]
  const char *v52; // [esp+A8h] [ebp-490h]
  const char *v53; // [esp+B0h] [ebp-488h]
  int v54; // [esp+B8h] [ebp-480h]
  const char *v55; // [esp+BCh] [ebp-47Ch]
  int v56; // [esp+C0h] [ebp-478h]
  int v57; // [esp+C4h] [ebp-474h]
  char tmp[7]; // [esp+DDh] [ebp-45Bh] BYREF
  size_t utf_extra; // [esp+E4h] [ebp-454h]
  int hoffset; // [esp+E8h] [ebp-450h]
  int hLine; // [esp+ECh] [ebp-44Ch]
  int hLen; // [esp+F0h] [ebp-448h]
  int hlen; // [esp+F4h] [ebp-444h]
  int tlen; // [esp+F8h] [ebp-440h]
  const char *data; // [esp+FCh] [ebp-43Ch]
  int offset; // [esp+100h] [ebp-438h]
  int y; // [esp+104h] [ebp-434h]
  int len; // [esp+108h] [ebp-430h]
  int written; // [esp+10Ch] [ebp-42Ch]
  int itmp; // [esp+110h] [ebp-428h]
  int tLen; // [esp+114h] [ebp-424h] BYREF
  int Offset; // [esp+118h] [ebp-420h] BYREF
  int LenNeeded; // [esp+11Ch] [ebp-41Ch] BYREF
  int HitOffset; // [esp+120h] [ebp-418h] BYREF
  char *theData; // [esp+124h] [ebp-414h] BYREF
  const char *cp; // [esp+128h] [ebp-410h]
  const char *Data; // [esp+12Ch] [ebp-40Ch]
  char buffer[1024]; // [esp+130h] [ebp-408h] BYREF
  unsigned int v80; // [esp+530h] [ebp-8h]

  v80 = __readgsdword(0x14u);
  Data = 0;
  theData = 0;
  tmp[2] = 0;
  tmp[1] = 0;
  tmp[0] = 0;
  if ( target
    && *target
    && (links[cur].type & 2) != 0
    && LYGetHiliteStr(cur, count)
    && *LYGetHiliteStr(cur, count)
    && count + links[cur].ly < display_lines
    && HText_getFirstTargetInLine(
         HTMainText,
         count + links[cur].anchor_line_num,
         utf_flag,
         &Offset,
         &tLen,
         &theData,
         target) )
  {
    tlen = strlen(target);
    hLine = count + links[cur].ly;
    hoffset = LYGetHilitePos(cur, count);
    utf_extra = 0;
    v6 = LYcols - (LYShowScrollbar != 0);
    n_glyphs = v6 - LYGetHilitePos(cur, count);
    src = (char *)(LYGetHiliteStr(cur, count) ? LYGetHiliteStr(cur, count) : byte_8156400);
    LYmbcsstrncpy(buffer, src, 1023, n_glyphs, utf_flag);
    hlen = strlen(buffer);
    if ( HTCJK || utf_flag )
      v25 = LYmbcsstrlen(buffer, utf_flag, 1);
    else
      v25 = hlen;
    hLen = v25;
    if ( hoffset + v25 > Offset )
    {
      Data = theData;
      while ( Offset < hoffset && tLen + Offset <= hoffset )
      {
        data = &Data[tlen];
        offset = Offset + tLen;
        if ( case_sensitive )
          v26 = LYno_attr_mbcs_strstr(data, target, utf_flag, 1, &HitOffset, &LenNeeded);
        else
          v26 = LYno_attr_mbcs_case_strstr(data, target, utf_flag, 1, &HitOffset, &LenNeeded);
        cp = v26;
        if ( !v26 || offset + LenNeeded >= LYcols )
          goto highlight_search_done;
        Data = cp;
        Offset = offset + HitOffset;
      }
      data = buffer;
      offset = hoffset;
      if ( Offset >= hoffset || tLen + Offset <= offset )
      {
highlight_hit_within_hightext:
        while ( 1 )
        {
          v40 = flag == 1 ? hLen - 1 : hLen;
          if ( Offset - offset > v40 )
            break;
          if ( utf_flag )
            v41 = LYmbcs_skip_glyphs(data, Offset - offset, utf_flag);
          else
            v41 = &data[Offset - offset];
          data = v41;
          if ( utf_flag )
            LYrefresh();
          offset = Offset;
          itmp = 0;
          written = 0;
          len = tlen;
          LYmove(hLine, Offset);
          tmp[0] = data[itmp];
          utf_extra = utf8_length(utf_flag, &data[itmp]);
          if ( utf_extra )
          {
            LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
            itmp += utf_extra;
            if ( flag == 1 && (offset <= hoffset || !data[itmp + 1]) )
            {
              LYmove(hLine, offset + 1);
            }
            else
            {
              LYstartTargetEmphasis();
              TargetEmphasisON = 1;
              v13 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v13);
            }
            tmp[1] = 0;
            written += utf_extra + 1;
            utf_extra = 0;
          }
          else if ( HTCJK && tmp[0] < 0 )
          {
            tmp[1] = data[++itmp];
            if ( flag == 1 && (offset <= hoffset || !data[itmp + 1]) )
            {
              LYmove(hLine, offset + 2);
            }
            else
            {
              LYstartTargetEmphasis();
              TargetEmphasisON = 1;
              v14 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v14);
            }
            tmp[1] = 0;
            written += 2;
          }
          else
          {
            if ( flag == 1 && (offset <= hoffset || !data[itmp + 1]) )
            {
              LYmove(hLine, offset + 1);
            }
            else
            {
              LYstartTargetEmphasis();
              TargetEmphasisON = 1;
              v15 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v15);
            }
            ++written;
          }
          ++itmp;
          if ( !TargetEmphasisON && data[itmp] )
          {
            LYstartTargetEmphasis();
            TargetEmphasisON = 1;
          }
          while ( written < len )
          {
            tmp[0] = data[itmp];
            if ( !tmp[0] )
              break;
            utf_extra = utf8_length(utf_flag, &data[itmp]);
            if ( utf_extra )
            {
              LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
              itmp += utf_extra;
              if ( flag != 1 || data[itmp + 1] )
              {
                v16 = strlen(tmp);
                LYwaddnstr(LYwin, tmp, v16);
              }
              else
              {
                LYstopTargetEmphasis();
                TargetEmphasisON = 0;
                if ( LYwin )
                  cury = LYwin->_cury;
                else
                  cury = -1;
                y = cury;
                if ( LYwin )
                  curx = LYwin->_curx;
                else
                  curx = -1;
                offset = curx;
                LYmove(hLine, curx + 1);
              }
              tmp[1] = 0;
              written += utf_extra + 1;
              utf_extra = 0;
            }
            else if ( HTCJK && tmp[0] < 0 )
            {
              tmp[1] = data[++itmp];
              if ( flag != 1 || data[itmp + 1] )
              {
                v17 = strlen(tmp);
                LYwaddnstr(LYwin, tmp, v17);
              }
              else
              {
                LYstopTargetEmphasis();
                TargetEmphasisON = 0;
                if ( LYwin )
                  v44 = LYwin->_cury;
                else
                  v44 = -1;
                y = v44;
                if ( LYwin )
                  v45 = LYwin->_curx;
                else
                  v45 = -1;
                offset = v45;
                LYmove(hLine, v45 + 1);
              }
              tmp[1] = 0;
              written += 2;
            }
            else
            {
              if ( flag != 1 || data[itmp + 1] )
              {
                v18 = strlen(tmp);
                LYwaddnstr(LYwin, tmp, v18);
              }
              else
              {
                LYstopTargetEmphasis();
                TargetEmphasisON = 0;
                if ( LYwin )
                  v46 = LYwin->_cury;
                else
                  v46 = -1;
                y = v46;
                if ( LYwin )
                  v47 = LYwin->_curx;
                else
                  v47 = -1;
                offset = v47;
                LYmove(hLine, v47 + 1);
              }
              ++written;
            }
            ++itmp;
          }
          if ( TargetEmphasisON )
          {
            LYstopTargetEmphasis();
            TargetEmphasisON = 0;
          }
          v48 = LYwin ? LYwin->_cury : -1;
          y = v48;
          v49 = LYwin ? LYwin->_curx : -1;
          offset = v49;
          v50 = flag == 1 ? hLen - 1 : hLen;
          if ( hoffset + v50 <= offset )
            break;
          if ( case_sensitive )
          {
            v52 = utf_flag ? LYmbcs_skip_glyphs(Data, offset - Offset, utf_flag) : &Data[offset - Offset];
            data = v52;
            v51 = LYno_attr_mbcs_strstr(v52, target, utf_flag, 1, &HitOffset, &LenNeeded);
          }
          else
          {
            v53 = utf_flag ? LYmbcs_skip_glyphs(Data, offset - Offset, utf_flag) : &Data[offset - Offset];
            data = v53;
            v51 = LYno_attr_mbcs_case_strstr(v53, target, utf_flag, 1, &HitOffset, &LenNeeded);
          }
          cp = v51;
          if ( !v51 || offset + LenNeeded >= LYcols )
            break;
          v54 = flag == 1 ? hLen - 1 : hLen;
          if ( HitOffset + offset >= hoffset + v54 )
            break;
          if ( offset + tLen + HitOffset >= hLen + hoffset )
          {
            offset += HitOffset;
            if ( utf_flag )
              v55 = LYmbcs_skip_glyphs(Data, offset - hoffset, utf_flag);
            else
              v55 = &Data[offset - hoffset];
            data = v55;
            if ( utf_flag )
              LYrefresh();
            LYmove(hLine, offset);
            itmp = 0;
            written = 0;
            len = strlen(data);
            LYstartTargetEmphasis();
            TargetEmphasisON = 1;
            while ( written < len )
            {
              tmp[0] = data[itmp];
              if ( !tmp[0] )
                break;
              utf_extra = utf8_length(utf_flag, &data[itmp]);
              if ( utf_extra )
              {
                LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
                itmp += utf_extra;
                if ( flag != 1 || data[itmp + 1] )
                {
                  v19 = strlen(tmp);
                  LYwaddnstr(LYwin, tmp, v19);
                }
                else
                {
                  LYstopTargetEmphasis();
                  TargetEmphasisON = 0;
                  if ( LYwin )
                    v56 = LYwin->_cury;
                  else
                    v56 = -1;
                  y = v56;
                  if ( LYwin )
                    v57 = LYwin->_curx;
                  else
                    v57 = -1;
                  offset = v57;
                  LYmove(hLine, v57 + 1);
                }
                tmp[1] = 0;
                written += utf_extra + 1;
                utf_extra = 0;
              }
              else if ( HTCJK && tmp[0] < 0 )
              {
                tmp[1] = data[++itmp];
                if ( flag != 1 || data[itmp + 1] )
                {
                  v20 = strlen(tmp);
                  LYwaddnstr(LYwin, tmp, v20);
                }
                else
                {
                  LYstopTargetEmphasis();
                  TargetEmphasisON = 0;
                }
                tmp[1] = 0;
                written += 2;
              }
              else
              {
                if ( flag != 1 || data[itmp + 1] )
                {
                  v21 = strlen(tmp);
                  LYwaddnstr(LYwin, tmp, v21);
                }
                else
                {
                  LYstopTargetEmphasis();
                  TargetEmphasisON = 0;
                }
                ++written;
              }
              ++itmp;
            }
            if ( TargetEmphasisON )
              LYstopTargetEmphasis();
            break;
          }
          Data = cp;
          Offset = offset + HitOffset;
          data = buffer;
          offset = hoffset;
        }
      }
      else
      {
        itmp = 0;
        written = 0;
        len = tlen + Offset - offset;
        LYmove(hLine, offset);
        tmp[0] = *data;
        utf_extra = utf8_length(utf_flag, data);
        if ( utf_extra )
        {
          LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
          itmp += utf_extra;
          if ( flag == 1 )
          {
            LYmove(hLine, offset + 1);
          }
          else
          {
            LYstartTargetEmphasis();
            TargetEmphasisON = 1;
            v7 = strlen(tmp);
            LYwaddnstr(LYwin, tmp, v7);
          }
          tmp[1] = 0;
          written += utf_extra + 1;
          utf_extra = 0;
        }
        else if ( HTCJK && tmp[0] < 0 )
        {
          tmp[1] = data[++itmp];
          if ( flag == 1 )
          {
            LYmove(hLine, offset + 1);
          }
          else
          {
            LYstartTargetEmphasis();
            TargetEmphasisON = 1;
            v8 = strlen(tmp);
            LYwaddnstr(LYwin, tmp, v8);
          }
          tmp[1] = 0;
          written += 2;
        }
        else
        {
          if ( flag == 1 )
          {
            LYmove(hLine, offset + 1);
          }
          else
          {
            LYstartTargetEmphasis();
            TargetEmphasisON = 1;
            v9 = strlen(tmp);
            LYwaddnstr(LYwin, tmp, v9);
          }
          ++written;
        }
        ++itmp;
        if ( !TargetEmphasisON && data[itmp] )
        {
          LYstartTargetEmphasis();
          TargetEmphasisON = 1;
        }
        while ( written < len )
        {
          tmp[0] = data[itmp];
          if ( !tmp[0] )
            break;
          utf_extra = utf8_length(utf_flag, &data[itmp]);
          if ( utf_extra )
          {
            LYstrncpy(&tmp[1], &data[itmp + 1], utf_extra);
            itmp += utf_extra;
            if ( flag != 1 || data[itmp + 1] )
            {
              v10 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v10);
            }
            else
            {
              LYstopTargetEmphasis();
              TargetEmphasisON = 0;
              if ( LYwin )
                v27 = LYwin->_cury;
              else
                v27 = -1;
              y = v27;
              if ( LYwin )
                v28 = LYwin->_curx;
              else
                v28 = -1;
              offset = v28;
              LYmove(hLine, v28 + 1);
            }
            tmp[1] = 0;
            written += utf_extra + 1;
            utf_extra = 0;
          }
          else if ( HTCJK && tmp[0] < 0 )
          {
            tmp[1] = data[++itmp];
            if ( flag != 1 || data[itmp + 1] )
            {
              v11 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v11);
            }
            else
            {
              LYstopTargetEmphasis();
              TargetEmphasisON = 0;
              if ( LYwin )
                v29 = LYwin->_cury;
              else
                v29 = -1;
              y = v29;
              if ( LYwin )
                v30 = LYwin->_curx;
              else
                v30 = -1;
              offset = v30;
              LYmove(hLine, v30 + 1);
            }
            tmp[1] = 0;
            written += 2;
          }
          else
          {
            if ( flag != 1 || data[itmp + 1] )
            {
              v12 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v12);
            }
            else
            {
              LYstopTargetEmphasis();
              TargetEmphasisON = 0;
              if ( LYwin )
                v31 = LYwin->_cury;
              else
                v31 = -1;
              y = v31;
              if ( LYwin )
                v32 = LYwin->_curx;
              else
                v32 = -1;
              offset = v32;
              LYmove(hLine, v32 + 1);
            }
            ++written;
          }
          ++itmp;
        }
        if ( TargetEmphasisON )
        {
          LYstopTargetEmphasis();
          TargetEmphasisON = 0;
        }
        if ( LYwin )
          v33 = LYwin->_cury;
        else
          v33 = -1;
        y = v33;
        if ( LYwin )
          v34 = LYwin->_curx;
        else
          v34 = -1;
        offset = v34;
        if ( flag == 1 )
          v35 = hLen - 1;
        else
          v35 = hLen;
        if ( hoffset + v35 > offset )
        {
          if ( case_sensitive )
          {
            v37 = utf_flag ? LYmbcs_skip_glyphs(Data, offset - Offset, utf_flag) : &Data[offset - Offset];
            data = v37;
            v36 = LYno_attr_mbcs_strstr(v37, target, utf_flag, 1, &HitOffset, &LenNeeded);
          }
          else
          {
            v38 = utf_flag ? LYmbcs_skip_glyphs(Data, offset - Offset, utf_flag) : &Data[offset - Offset];
            data = v38;
            v36 = LYno_attr_mbcs_case_strstr(v38, target, utf_flag, 1, &HitOffset, &LenNeeded);
          }
          cp = v36;
          if ( v36 && offset + LenNeeded < LYcols )
          {
            v39 = flag == 1 ? hLen - 1 : hLen;
            if ( HitOffset + offset < hoffset + v39 )
            {
              Data = cp;
              Offset = offset + HitOffset;
              data = buffer;
              offset = hoffset;
              goto highlight_hit_within_hightext;
            }
          }
        }
      }
    }
  }
highlight_search_done:
  if ( theData )
  {
    free(theData);
    theData = 0;
  }
  return TargetEmphasisON;
}

//----- (080928F2) --------------------------------------------------------
int __cdecl find_cached_style(int cur, int flag)
{
  int v2; // esi
  int v3; // ebx
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // edx
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  int lx; // esi
  int ly; // ebx
  FILE *v12; // eax
  int x; // [esp+18h] [ebp-10h]
  int s; // [esp+1Ch] [ebp-Ch]

  s = s_alink;
  if ( textfields_need_activation
    && links[cur].type == 1
    && (links[cur].l_form->type == 1
     || links[cur].l_form->type == 12
     || links[cur].l_form->type == 2
     || links[cur].l_form->type == 11
     || links[cur].l_form->type == 9) )
  {
    s = s_curedit;
  }
  if ( flag == 1 )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      lx = links[cur].lx;
      ly = links[cur].ly;
      v12 = TraceFP();
      fprintf(v12, "STYLE.highlight.on: @(%d,%d).\n", ly, lx);
    }
  }
  else if ( ValidCachedStyle(links[cur].ly, links[cur].lx) )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v2 = links[cur].lx;
      v3 = links[cur].ly;
      v4 = TraceFP();
      fprintf(v4, "STYLE.highlight.off: cached style @(%d,%d): ", v3, v2);
    }
    s = GetCachedStyle(links[cur].ly, links[cur].lx);
    if ( s )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v8 = TraceFP();
        fprintf(v8, "found %d.\n", s);
      }
    }
    else
    {
      for ( x = links[cur].lx - 1; x >= 0; --x )
      {
        s = GetCachedStyle(links[cur].ly, x);
        if ( s )
        {
          SetCachedStyle(links[cur].ly, links[cur].lx, s);
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
          {
            v5 = x - links[cur].lx;
            v6 = TraceFP();
            fprintf(v6, "found %d, x_offset=%d.\n", s, v5);
          }
          break;
        }
      }
      if ( !s )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
        {
          v7 = TraceFP();
          fprintf(v7, "not found, assume <a>.\n");
        }
        return s_a;
      }
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v9 = TraceFP();
      fprintf(v9, "STYLE.highlight.off: can't use cache.\n");
    }
    return s_a;
  }
  return s;
}

//----- (08092CAB) --------------------------------------------------------
void __cdecl LYhighlight(int flag, int cur, const char *target)
{
  FILE *v3; // eax
  int lx; // esi
  int ly; // ebx
  FILE *v6; // edx
  int cached_style; // eax
  const char *v8; // eax
  int v10; // esi
  int v11; // ebx
  FILE *v12; // eax
  size_t v13; // eax
  FILE *v14; // eax
  size_t v15; // eax
  size_t v16; // eax
  int v17; // [esp+24h] [ebp-474h]
  const char *v18; // [esp+28h] [ebp-470h]
  int anchor_number; // [esp+2Ch] [ebp-46Ch]
  const char *v20; // [esp+30h] [ebp-468h]
  int n_glyphs; // [esp+38h] [ebp-460h]
  char *src; // [esp+3Ch] [ebp-45Ch]
  int v23; // [esp+40h] [ebp-458h]
  int style; // [esp+44h] [ebp-454h]
  char tmp[7]; // [esp+55h] [ebp-443h] BYREF
  int row; // [esp+5Ch] [ebp-43Ch]
  const char *text; // [esp+60h] [ebp-438h]
  int avail_space; // [esp+64h] [ebp-434h]
  int gllen; // [esp+68h] [ebp-430h]
  int len; // [esp+6Ch] [ebp-42Ch]
  const char *hi_string; // [esp+70h] [ebp-428h]
  int title_adjust; // [esp+74h] [ebp-424h]
  int hi_offset; // [esp+78h] [ebp-420h]
  int hi_count; // [esp+7Ch] [ebp-41Ch]
  int i; // [esp+80h] [ebp-418h]
  BOOLEAN hl2_drawn; // [esp+87h] [ebp-411h]
  BOOLEAN hl1_drawn; // [esp+88h] [ebp-410h]
  BOOLEAN utf_flag; // [esp+89h] [ebp-40Fh]
  BOOLEAN target1_drawn; // [esp+8Ah] [ebp-40Eh]
  BOOLEAN TargetEmphasisON; // [esp+8Bh] [ebp-40Dh]
  char buffer[1024]; // [esp+8Ch] [ebp-40Ch] BYREF
  unsigned int v42; // [esp+48Ch] [ebp-Ch]

  v42 = __readgsdword(0x14u);
  if ( no_title )
    v17 = -1;
  else
    v17 = 0;
  title_adjust = v17;
  TargetEmphasisON = 0;
  target1_drawn = 0;
  utf_flag = LYCharSet_UC[current_char_set].enc == 7;
  hl1_drawn = 0;
  hl2_drawn = 0;
  tmp[2] = 0;
  tmp[1] = 0;
  tmp[0] = 0;
  if ( cur < 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "LYhighlight cur %d (bug workaround)\n", cur);
    }
    cur = 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( target )
      v18 = target;
    else
      v18 = "(null)";
    anchor_number = links[cur].anchor_number;
    if ( flag )
      v20 = "on";
    else
      v20 = "off";
    lx = links[cur].lx;
    ly = links[cur].ly;
    v6 = TraceFP();
    fprintf(v6, "LYhighlight at(%2d,%2d) %s %d [%d]:%s\n", ly, lx, v20, cur, anchor_number, v18);
  }
  if ( nlinks > 0 )
  {
    if ( flag == 1 || links[cur].type == 1 )
    {
      LYmove(title_adjust + links[cur].ly, links[cur].lx);
      cached_style = find_cached_style(cur, flag);
      curses_style(cached_style, 1);
    }
    if ( links[cur].type == 1 )
    {
      avail_space = LYcols
                  - (LYShowScrollbar != 0)
                  - links[cur].lx
                  + (LYcols - (LYShowScrollbar != 0)) * (LYlines - links[cur].ly);
      text = LYGetHiliteStr(cur, 0);
      if ( !text )
        text = byte_8156400;
      if ( links[cur].l_form->size < avail_space )
        avail_space = links[cur].l_form->size;
      gllen = LYmbcsstrlen(text, utf_flag, 1);
      v8 = LYmbcs_skip_cells(text, avail_space, utf_flag);
      len = v8 - text;
      LYwaddnstr(LYwin, text, v8 - text);
      while ( gllen++ < avail_space )
        waddch(LYwin, 0x5Fu);
    }
    else if ( flag )
    {
      n_glyphs = LYcols - (LYShowScrollbar != 0) - links[cur].lx;
      if ( LYGetHiliteStr(cur, 0) )
        src = (char *)LYGetHiliteStr(cur, 0);
      else
        src = (char *)byte_8156400;
      LYmbcsstrncpy(buffer, src, 1023, n_glyphs, utf_flag);
      v13 = strlen(buffer);
      LYwaddnstr(LYwin, buffer, v13);
    }
    else
    {
      hl2_drawn = 1;
      redraw_lines_of_link(cur);
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v10 = links[cur].lx;
        v11 = links[cur].ly;
        v12 = TraceFP();
        fprintf(v12, "STYLE.highlight.off: NOFIX branch @(%d,%d).\n", v11, v10);
      }
    }
    if ( !hl2_drawn )
    {
      for ( hi_count = 1; ; ++hi_count )
      {
        hi_string = LYGetHiliteStr(cur, hi_count);
        if ( !hi_string || hi_count + links[cur].ly > display_lines )
          break;
        row = title_adjust + hi_count + links[cur].ly;
        hi_offset = LYGetHilitePos(cur, hi_count);
        lynx_stop_link_color(flag == 1, links[cur].inUnderline);
        LYmove(row, hi_offset);
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
        {
          if ( flag == 1 )
            v23 = s_alink;
          else
            v23 = s_a;
          v14 = TraceFP();
          fprintf(v14, "STYLE.highlight.line2: @(%d,%d), style=%d.\n", row, hi_offset, v23);
        }
        if ( flag == 1 )
          style = s_alink;
        else
          style = s_a;
        curses_style(style, 2);
        for ( i = 0; ; ++i )
        {
          tmp[0] = hi_string[i];
          if ( !tmp[0] || i + hi_offset >= LYcols )
            break;
          if ( hi_string[i] <= 2 || hi_string[i] > 8 )
          {
            if ( HTCJK && tmp[0] < 0 )
            {
              tmp[1] = hi_string[++i];
              v15 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v15);
              tmp[1] = 0;
            }
            else
            {
              v16 = strlen(tmp);
              LYwaddnstr(LYwin, tmp, v16);
            }
          }
        }
      }
      lynx_stop_link_color(flag == 1, links[cur].inUnderline);
    }
    for ( hi_count = target1_drawn != 0; LYGetHiliteStr(cur, hi_count); ++hi_count )
      TargetEmphasisON = show_whereis_targets(flag, cur, hi_count, target, TargetEmphasisON, utf_flag);
    if ( LYShowCursor )
    {
      if ( links[cur].lx <= 0 )
        LYmove(title_adjust + links[cur].ly, 0);
      else
        LYmove(title_adjust + links[cur].ly, links[cur].lx - 1);
    }
    else
    {
      LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
    }
    if ( flag )
      LYrefresh();
  }
}
// 809310E: conditional instruction was optimized away because %hl1_drawn.1==0

//----- (08093603) --------------------------------------------------------
void __cdecl free_and_clear(char **pointer)
{
  if ( *pointer )
  {
    free(*pointer);
    *pointer = 0;
    *pointer = 0;
  }
}

//----- (0809363C) --------------------------------------------------------
void __cdecl convert_to_spaces(char *string, BOOLEAN condense)
{
  int v2; // [esp+10h] [ebp-18h]
  char *ns; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  BOOLEAN last_is_space; // [esp+27h] [ebp-1h]

  last_is_space = 0;
  if ( string )
  {
    s = LYSkipNonBlanks(string);
    ns = s;
    while ( 1 )
    {
      if ( !*s )
      {
        *ns = 0;
        return;
      }
      v2 = *s;
      if ( v2 != 10 )
      {
        if ( v2 <= 10 )
        {
          if ( v2 != 9 )
            goto LABEL_15;
LABEL_9:
          if ( !condense || !last_is_space )
            *ns++ = 32;
          last_is_space = 1;
          goto LABEL_16;
        }
        if ( v2 != 13 )
        {
          if ( v2 != 32 )
          {
LABEL_15:
            *ns++ = *s;
            last_is_space = 0;
            goto LABEL_16;
          }
          goto LABEL_9;
        }
      }
      if ( !last_is_space )
      {
        *ns++ = 32;
        last_is_space = 1;
      }
LABEL_16:
      ++s;
    }
  }
}

//----- (080936F9) --------------------------------------------------------
char *__cdecl strip_trailing_slash(char *dirname)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = strlen(dirname) - 1; i >= 0 && dirname[i] == 47; --i )
    dirname[i] = 0;
  return dirname;
}

//----- (08093737) --------------------------------------------------------
void __cdecl remove_most_blanks(char *buffer)
{
  size_t v1; // eax
  bool v2; // [esp+14h] [ebp-14h]
  int length; // [esp+20h] [ebp-8h]

  length = strlen(buffer);
  v2 = length && buffer[length - 1] == 32;
  LYReduceBlanks(buffer);
  if ( v2 )
  {
    v1 = strlen(buffer);
    memcpy(&buffer[v1], " ", 2u);
  }
}

//----- (080937B1) --------------------------------------------------------
void __cdecl statusline(const char *text)
{
  size_t v1; // eax
  char *v2; // eax
  size_t v3; // eax
  int v4; // [esp+10h] [ebp-848h]
  int v5; // [esp+14h] [ebp-844h]
  int v6; // [esp+18h] [ebp-840h]
  int cury; // [esp+1Ch] [ebp-83Ch]
  int at_lineno; // [esp+38h] [ebp-820h]
  int j; // [esp+3Ch] [ebp-81Ch]
  int ja; // [esp+3Ch] [ebp-81Ch]
  int i; // [esp+40h] [ebp-818h]
  int ia; // [esp+40h] [ebp-818h]
  int ib; // [esp+40h] [ebp-818h]
  int len; // [esp+44h] [ebp-814h]
  int lena; // [esp+44h] [ebp-814h]
  unsigned __int8 *temp; // [esp+4Ch] [ebp-80Ch]
  BOOLEAN has_CJK; // [esp+52h] [ebp-806h]
  unsigned __int8 k; // [esp+53h] [ebp-805h]
  char text_buff[1024]; // [esp+54h] [ebp-804h] BYREF
  char buffer[1024]; // [esp+454h] [ebp-404h] BYREF
  unsigned int v21; // [esp+854h] [ebp-4h]

  v21 = __readgsdword(0x14u);
  if ( text && !dump_output_immediately && (mustshow[0] == 1 || no_statusline != 1) )
  {
    mustshow[0] = 0;
    LYstrncpy(text_buff, text, 1023);
    strchr(text_buff, 10);
    v4 = LYcols - (LYShowScrollbar != 0) - 1;
    if ( v4 > 1023 )
      v4 = 1023;
    if ( text_buff[0] && LYHaveCJKCharacterSet )
    {
      v1 = strlen(text_buff);
      temp = (unsigned __int8 *)calloc(v1 + 1, 1u);
      if ( !temp )
        outofmem("./LYUtils.c", "statusline");
      if ( kanji_code == EUC )
      {
        TO_EUC((const unsigned __int8 *)text_buff, temp);
      }
      else if ( kanji_code == SJIS )
      {
        strcpy((char *)temp, text_buff);
      }
      else
      {
        i = 0;
        j = 0;
        while ( text_buff[i] )
        {
          if ( text_buff[i] != 27 )
            temp[j++] = text_buff[i];
          ++i;
        }
        temp[j] = 0;
      }
      remove_most_blanks((char *)temp);
      ia = 0;
      ja = 0;
      len = 0;
      k = 0;
      while ( temp[ia] && len < v4 )
      {
        if ( k )
        {
          buffer[ja] = k;
          buffer[ja + 1] = temp[ia];
          ja += 2;
          k = 0;
          len += 2;
        }
        else if ( (temp[ia] & 0x80u) == 0 )
        {
          buffer[ja++] = temp[ia];
          ++len;
        }
        else
        {
          k = temp[ia];
        }
        ++ia;
      }
      buffer[ja] = 0;
      free(temp);
    }
    else
    {
      remove_most_blanks(text_buff);
      lena = strlen(text_buff);
      if ( lena > 1022 )
        lena = 1023;
      strncpy(buffer, text_buff, lena)[lena] = 0;
      while ( lena > 0 && LYstrExtent(buffer, lena, lena) > v4 )
        buffer[--lena] = 0;
    }
    if ( LYStatusLine < 0 )
    {
      if ( user_mode )
        at_lineno = LYlines - 1;
      else
        at_lineno = LYlines - 3;
    }
    else if ( LYlines - 1 <= LYStatusLine )
    {
      at_lineno = LYlines - 1;
    }
    else
    {
      at_lineno = LYStatusLine;
    }
    LYmove(at_lineno, 0);
    LYclrtoeol();
    if ( buffer[0] )
    {
      has_CJK = 0;
      if ( HTCJK )
      {
        for ( ib = 0; buffer[ib]; ++ib )
        {
          if ( buffer[ib] < 0 )
          {
            has_CJK = 1;
            break;
          }
        }
      }
      if ( has_CJK )
        LYrefresh();
      v2 = gettext("Alert!: %s");
      if ( !strncmp(buffer, v2, 5u) && hashStyles[s_alert].name )
        v5 = s_alert;
      else
        v5 = s_status;
      curses_style(v5, 1);
      v3 = strlen(buffer);
      LYwaddnstr(LYwin, buffer, v3);
      if ( lynx_has_color && LYShowColor > 1 )
        v6 = hashStyles[v5].color | 0x20;
      else
        v6 = 32;
      wbkgdset(LYwin, v6);
      if ( LYwin )
        cury = LYwin->_cury;
      else
        cury = -1;
      if ( cury == at_lineno )
        LYclrtoeol();
      if ( lynx_has_color && LYShowColor > 1 )
      {
        if ( s_normal == -1 )
          wbkgdset(LYwin, displayStyles[128].color | 0x20);
        else
          wbkgdset(LYwin, hashStyles[s_normal].color | 0x20);
      }
      else
      {
        wbkgdset(LYwin, 0x20u);
      }
      curses_style(v5, 0);
    }
    LYrefresh();
  }
}
// 8093AF0: conditional instruction was optimized away because %temp.4!=0

//----- (08093EC6) --------------------------------------------------------
const char *__cdecl novice_lines(int lineno)
{
  if ( lineno == 1 )
    return gettext("  O)ther cmds  B)ack  E)dit  D)ownload ^R)eload ^W)ipe screen  search doc: / \n");
  if ( lineno == 2 )
    return gettext("O)ther cmds  C)omment  History: <backspace>  Bookmarks: V)iew, A)dd, R)emove \n");
  if ( lineno )
    return byte_8156400;
  return gettext("  O)ther cmds  H)elp  K)eymap  G)oto  P)rint  M)ain screen  o)ptions  Q)uit  \n");
}

//----- (08093F23) --------------------------------------------------------
void toggle_novice_line()
{
  if ( !*novice_lines(++lineno) )
    lineno = 0;
}

//----- (08093F56) --------------------------------------------------------
void __cdecl noviceline(int more_flag)
{
  char *v1; // eax
  size_t v2; // ebx
  char *v3; // eax
  char *v4; // eax
  size_t v5; // ebx
  char *v6; // eax
  char *v7; // eax
  size_t v8; // ebx
  const char *v9; // eax
  const char *v10; // eax

  if ( !dump_output_immediately )
  {
    LYmove(LYlines - 2, 0);
    LYclrtoeol();
    v1 = gettext("  Arrow keys: Up and Down to move.  Right to follow a link; Left to go back.  \n");
    v2 = strlen(v1);
    v3 = gettext("  Arrow keys: Up and Down to move.  Right to follow a link; Left to go back.  \n");
    LYwaddnstr(LYwin, v3, v2);
    LYmove(LYlines - 1, 0);
    LYclrtoeol();
    if ( !lynx_edit_mode || no_dired_support[0] )
    {
      if ( LYUseNoviceLineTwo )
      {
        v7 = gettext(" H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history list \n");
        v8 = strlen(v7);
        v9 = gettext(" H)elp O)ptions P)rint G)o M)ain screen Q)uit /=search [delete]=history list \n");
      }
      else
      {
        v10 = novice_lines(lineno);
        v8 = strlen(v10);
        v9 = novice_lines(lineno);
      }
      LYwaddnstr(LYwin, v9, v8);
    }
    else
    {
      v4 = gettext("  C)reate  D)ownload  E)dit  F)ull menu  M)odify  R)emove  T)ag  U)pload     \n");
      v5 = strlen(v4);
      v6 = gettext("  C)reate  D)ownload  E)dit  F)ull menu  M)odify  R)emove  T)ag  U)pload     \n");
      LYwaddnstr(LYwin, v6, v5);
    }
    LYrefresh();
  }
}

//----- (080940B8) --------------------------------------------------------
int LYReopenInput()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  int v3; // eax
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // esi
  FILE *v7; // eax
  FILE *frp; // [esp+2Ch] [ebp-1Ch]
  int new_fd; // [esp+30h] [ebp-18h]
  const char *term_name; // [esp+34h] [ebp-14h]
  int result; // [esp+3Ch] [ebp-Ch]

  result = 0;
  if ( !fileno(stdin) && !isatty(0) && !LYConsoleInputFD(0) )
  {
    term_name = 0;
    new_fd = -1;
    v0 = fileno(stdout);
    if ( isatty(v0) )
    {
      v1 = fileno(stdout);
      term_name = ttyname(v1);
      if ( term_name )
        new_fd = open64(term_name, 0);
    }
    if ( new_fd == -1 )
    {
      v2 = fileno(stderr);
      if ( isatty(v2) )
      {
        v3 = fileno(stderr);
        term_name = ttyname(v3);
        if ( term_name )
          new_fd = open64(term_name, 0);
      }
    }
    if ( new_fd == -1 )
    {
      term_name = ctermid(0);
      if ( term_name )
        new_fd = open64(term_name, 0);
    }
    if ( new_fd == -1 )
    {
      term_name = "/dev/tty";
      new_fd = open64("/dev/tty", 0);
    }
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "LYReopenInput open(%s) returned %d.\n", term_name, new_fd);
    }
    if ( new_fd < 0 )
    {
      return -1;
    }
    else
    {
      close(new_fd);
      frp = (FILE *)freopen64(term_name, "r", stdin);
      if ( WWW_TraceFlag[0] )
      {
        v5 = fileno(stdin);
        v6 = stdin;
        v7 = TraceFP();
        fprintf(
          v7,
          "LYReopenInput freopen(%s,\"r\",stdin) returned %p, stdin is now %p with fd %d.\n",
          term_name,
          frp,
          v6,
          v5);
      }
      return 1;
    }
  }
  return result;
}
// 804B3F4: using guessed type int __cdecl freopen64(_DWORD, _DWORD, _DWORD);

//----- (080942DB) --------------------------------------------------------
int __cdecl LYConsoleInputFD(BOOLEAN need_selectable)
{
  int fd; // [esp+24h] [ebp-4h]

  fd = fileno(stdin);
  if ( !need_selectable || fd == -1 )
    return fd;
  if ( isatty(fd) )
    return fd;
  return -1;
}

//----- (08094335) --------------------------------------------------------
void __cdecl LYFakeZap(BOOLEAN set)
{
  FILE *v1; // eax
  int v2; // ebx
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  int v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax

  if ( set && fake_zap <= 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "\r *** Set simulated 'Z'");
    }
    if ( fake_zap && WWW_TraceFlag[0] )
    {
      v2 = fake_zap;
      v3 = TraceFP();
      fprintf(v3, ", %d pending", v2);
    }
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, " ***\n");
    }
    ++fake_zap;
  }
  else if ( !set && fake_zap )
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "\r *** Unset simulated 'Z'");
    }
    if ( WWW_TraceFlag[0] )
    {
      v6 = fake_zap;
      v7 = TraceFP();
      fprintf(v7, ", %d pending", v6);
    }
    if ( WWW_TraceFlag[0] )
    {
      v8 = TraceFP();
      fprintf(v8, " ***\n");
    }
    fake_zap = 0;
  }
}

//----- (08094477) --------------------------------------------------------
int DontCheck()
{
  timeval tv; // [esp+1Ch] [ebp-Ch] BYREF
  int next; // [esp+24h] [ebp-4h]

  if ( dump_output_immediately )
    return 1;
  if ( LYHaveCmdScript() )
    return 1;
  gettimeofday(&tv, 0);
  next = tv.tv_usec / 100000;
  if ( tv.tv_usec / 100000 == last_13072 )
    return 1;
  last_13072 = next;
  return 0;
}

//----- (080944FD) --------------------------------------------------------
int HTCheckForInterrupt()
{
  FILE *v0; // eax
  FILE *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int v4; // eax
  int v7; // [esp+20h] [ebp-B8h]
  int v8; // [esp+24h] [ebp-B4h]
  fd_set readfds; // [esp+2Ch] [ebp-ACh] BYREF
  timeval socket_timeout; // [esp+ACh] [ebp-2Ch] BYREF
  int Newline_partial; // [esp+B4h] [ebp-24h] BYREF
  int res; // [esp+B8h] [ebp-20h]
  const char *s; // [esp+BCh] [ebp-1Ch]
  fd_set *__arr; // [esp+C0h] [ebp-18h]
  unsigned int __i; // [esp+C4h] [ebp-14h]
  int ret; // [esp+C8h] [ebp-10h]
  int cmd; // [esp+CCh] [ebp-Ch]
  int c; // [esp+D0h] [ebp-8h]
  BOOLEAN do_refresh; // [esp+D7h] [ebp-1h] BYREF

  if ( fake_zap > 0 )
  {
    --fake_zap;
    if ( WWW_TraceFlag[0] )
    {
      v0 = TraceFP();
      fprintf(v0, "\r *** Got simulated 'Z' ***\n");
    }
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fflush(v1);
    }
    if ( WWW_TraceFlag[0] && !LYTraceLogFP )
      sleep(AlertSecs);
    return 1;
  }
  if ( DontCheck() )
    return 0;
  ret = 0;
  socket_timeout.tv_sec = 0;
  socket_timeout.tv_usec = 0;
  __arr = &readfds;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->fds_bits[__i] = 0;
  readfds.fds_bits[0] |= 1u;
  ret = select(1, &readfds, 0, 0, &socket_timeout);
  if ( ret == -1 && *__errno_location() == 4 )
    return 0;
  if ( (readfds.fds_bits[0] & 1) == 0 )
    return 0;
  c = LYgetch();
  if ( c == 3 || c == 7 )
    return 1;
  if ( c == -1 )
  {
    if ( keymap[0] != 47 )
      goto LABEL_30;
    return 1;
  }
  if ( (c & 0x8800) != 0 )
  {
    if ( (unsigned __int8)c != 47 )
      goto LABEL_30;
    return 1;
  }
  if ( keymap[(c & 0x7FF) + 1] == 47 )
    return 1;
LABEL_30:
  if ( c == -1 )
  {
    v7 = keymap[0];
  }
  else
  {
    if ( (c & 0x8800) != 0 )
      v8 = (unsigned __int8)c;
    else
      v8 = keymap[(c & 0x7FF) + 1];
    v7 = v8;
  }
  cmd = v7;
  if ( v7 == 64 )
  {
    handle_LYK_TRACE_TOGGLE();
  }
  else if ( v7 == 104 )
  {
    s = LYDownLoadAddress();
    if ( s && *s && !put_clip(s) )
    {
      v3 = gettext("Download document URL put to clipboard.");
      HTInfoMsg(v3);
    }
    else
    {
      v2 = gettext("Copy to clipboard failed.");
      HTInfoMsg(v2);
    }
  }
  else if ( display_partial[0] && NumOfLines_partial > 2 )
  {
    Newline_partial = LYGetNewline();
    switch ( cmd )
    {
      case 15:
        if ( HText_canScrollDown() )
          Newline_partial += display_lines;
        goto LABEL_76;
      case 16:
        if ( Newline_partial > 1 )
          Newline_partial -= display_lines;
        goto LABEL_76;
      case 17:
        if ( Newline_partial > 1 )
          Newline_partial -= 2;
        goto LABEL_76;
      case 18:
        if ( HText_canScrollDown() )
          Newline_partial += 2;
        goto LABEL_76;
      case 19:
        if ( Newline_partial > 1 )
          Newline_partial -= display_lines / 2;
        goto LABEL_76;
      case 20:
        if ( HText_canScrollDown() )
          Newline_partial += display_lines / 2;
        goto LABEL_76;
      case 21:
        goto LABEL_76;
      case 22:
        if ( Newline_partial > 1 )
          Newline_partial = 1;
        goto LABEL_76;
      case 23:
        if ( HText_canScrollDown() )
          Newline_partial = HText_getNumOfLines() - display_lines + 1;
        goto LABEL_76;
      case 30:
        if ( display_lines + 1 < Newline_partial )
        {
          res = HTGetLinkOrFieldStart(-1, &Newline_partial, 0, -1, 1);
          if ( res == 8 )
          {
            ++Newline_partial;
          }
          else if ( res == 16 )
          {
            Newline_partial -= display_lines;
          }
        }
        else
        {
          Newline_partial -= display_lines;
        }
        goto LABEL_76;
      case 31:
        if ( HText_canScrollDown() )
        {
          v4 = HText_LinksInLines(HTMainText, Newline_partial, display_lines);
          res = HTGetLinkOrFieldStart(v4 - 1, &Newline_partial, 0, 1, 1);
          if ( res == 8 )
            ++Newline_partial;
        }
        goto LABEL_76;
      case 51:
      case 52:
      case 53:
        handle_LYK_WHEREIS(cmd, &do_refresh);
        if ( www_search_result != -1 )
        {
          Newline_partial = www_search_result;
          www_search_result = -1;
        }
LABEL_76:
        if ( Newline_partial <= 0 )
          Newline_partial = 1;
        if ( LYMainLoop_pageDisplay(Newline_partial) )
          NumOfLines_partial = HText_getNumOfLines();
        return 0;
      default:
        return 0;
    }
  }
  return 0;
}

//----- (08094A52) --------------------------------------------------------
BOOLEAN __cdecl LYisAbsPath(const char *path)
{
  BOOLEAN result; // [esp+Fh] [ebp-1h]

  result = 0;
  if ( path && *path )
    return *path == 47;
  return result;
}

//----- (08094A80) --------------------------------------------------------
BOOLEAN __cdecl LYisRootPath(const char *path)
{
  return strlen(path) == 1 && *path == 47;
}

//----- (08094AB6) --------------------------------------------------------
BOOLEAN __cdecl LYisLocalFile(const char *filename)
{
  char *v2; // [esp+4h] [ebp-24h]
  char *cp; // [esp+1Ch] [ebp-Ch]
  char *acc_method; // [esp+20h] [ebp-8h]
  char *host; // [esp+24h] [ebp-4h]

  if ( !filename )
    return 0;
  host = HTParse(filename, byte_8156400, 8);
  if ( !host )
    return 0;
  if ( *host )
  {
    cp = strchr(host, 58);
    if ( cp )
      *cp = 0;
    acc_method = HTParse(filename, byte_8156400, 16);
    if ( acc_method
      && !strcmp("file", acc_method)
      && (!strcmp(host, "localhost") || (v2 = HTHostName(), !strcmp(host, v2))) )
    {
      free(host);
      free(acc_method);
      return 1;
    }
    else
    {
      free(host);
      if ( acc_method )
        free(acc_method);
      return 0;
    }
  }
  else
  {
    free(host);
    return 0;
  }
}
// 8094B14: conditional instruction was optimized away because %host.4!=0
// 8094BC1: conditional instruction was optimized away because %host.4!=0
// 8094BD9: conditional instruction was optimized away because %acc_method.4!=0
// 8094BF7: conditional instruction was optimized away because %host.4!=0

//----- (08094C2D) --------------------------------------------------------
BOOLEAN __cdecl LYisLocalHost(const char *filename)
{
  char *v2; // [esp+4h] [ebp-24h]
  char *cp; // [esp+20h] [ebp-8h]
  char *host; // [esp+24h] [ebp-4h]

  if ( !filename )
    return 0;
  host = HTParse(filename, byte_8156400, 8);
  if ( !host )
    return 0;
  if ( !*host )
    goto LABEL_12;
  cp = strchr(host, 58);
  if ( cp )
    *cp = 0;
  if ( !strcmp(host, "localhost") || !strcmp(host, LYHostName) || (v2 = HTHostName(), !strcmp(host, v2)) )
  {
    free(host);
    return 1;
  }
  else
  {
LABEL_12:
    free(host);
    return 0;
  }
}
// 8094C84: conditional instruction was optimized away because %host.4!=0
// 8094D0E: conditional instruction was optimized away because %host.4!=0
// 8094D2C: conditional instruction was optimized away because %host.4!=0

//----- (08094D4A) --------------------------------------------------------
void __cdecl LYFreeStringList(HTList *list)
{
  void *object; // [esp+4h] [ebp-14h]
  HTList *cur; // [esp+10h] [ebp-8h]

  if ( list )
  {
    cur = list;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = cur->object;
      else
        object = 0;
      if ( !object )
        break;
      free(object);
    }
    HTList_delete(list);
  }
}

//----- (08094DB5) --------------------------------------------------------
void LYLocalhostAliases_free()
{
  LYFreeStringList(localhost_aliases);
  localhost_aliases = 0;
}

//----- (08094DD4) --------------------------------------------------------
void __cdecl LYAddLocalhostAlias(char *alias)
{
  char *LocalAlias; // [esp+14h] [ebp-4h] BYREF

  LocalAlias = 0;
  if ( alias && *alias )
  {
    if ( !localhost_aliases )
      localhost_aliases = HTList_new();
    HTSACopy(&LocalAlias, alias);
    HTList_addObject(localhost_aliases, LocalAlias);
  }
}

//----- (08094E2D) --------------------------------------------------------
BOOLEAN __cdecl LYisLocalAlias(const char *filename)
{
  const char *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+18h] [ebp-10h]
  char *cp; // [esp+1Ch] [ebp-Ch]
  char *host; // [esp+24h] [ebp-4h]

  cur = localhost_aliases;
  if ( !localhost_aliases || !filename )
    return 0;
  host = HTParse(filename, byte_8156400, 8);
  if ( !host )
    return 0;
  if ( *host )
  {
    cp = strchr(host, 58);
    if ( cp )
      *cp = 0;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (const char *)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( !strcmp(host, object) )
      {
        free(host);
        return 1;
      }
    }
  }
  free(host);
  return 0;
}
// 8094E92: conditional instruction was optimized away because %host.4!=0
// 8094EED: conditional instruction was optimized away because %host.4!=0
// 8094F3D: conditional instruction was optimized away because %host.4!=0

//----- (08094F5B) --------------------------------------------------------
UrlTypes __cdecl LYCheckForProxyURL(char *filename)
{
  char *cp2; // [esp+1Ch] [ebp-Ch] BYREF
  char *cp1; // [esp+20h] [ebp-8h]
  char *cp; // [esp+24h] [ebp-4h]

  cp = filename;
  cp2 = 0;
  if ( !filename || !*cp )
    return 0;
  cp = LYSkipBlanks(cp);
  cp1 = strchr(cp + 1, 58);
  if ( !cp1 )
    return 0;
  cp2 = strchr(cp + 1, 47);
  if ( cp2 && cp2 < cp1 )
    return 0;
  *cp1 = 0;
  cp2 = 0;
  HTSACopy(&cp2, cp);
  *cp1 = 58;
  HTSACat(&cp2, "_proxy");
  if ( !LYGetEnv(cp2) )
  {
    if ( cp2 )
    {
      free(cp2);
      cp2 = 0;
    }
    ++cp1;
    if ( !*cp )
      return 0;
    if ( ((*__ctype_b_loc())[(unsigned __int8)*cp1] & 0x800) == 0 )
      return 1;
    while ( *cp1 && ((*__ctype_b_loc())[(unsigned __int8)*cp1] & 0x800) != 0 )
      ++cp1;
    return *cp1 && *cp1 != 47;
  }
  if ( cp2 )
  {
    free(cp2);
    cp2 = 0;
  }
  return 44;
}

//----- (08095118) --------------------------------------------------------
BOOLEAN __cdecl compare_type(char *tst, const char *cmp, size_t len)
{
  size_t i; // [esp+24h] [ebp-4h]

  if ( strncasecomp(tst, cmp, len) )
    return 0;
  if ( strncmp(tst, cmp, len) )
  {
    for ( i = 0; i < len; ++i )
      tst[i] = cmp[i];
  }
  return 1;
}

//----- (08095193) --------------------------------------------------------
UrlTypes __cdecl is_url(char *filename)
{
  int limit; // [esp+24h] [ebp-14h]
  UrlTypes result; // [esp+2Ch] [ebp-Ch]
  char *cp1; // [esp+30h] [ebp-8h]
  char *cp1a; // [esp+30h] [ebp-8h]
  char *cp; // [esp+34h] [ebp-4h]

  result = NOT_A_URL_TYPE_0;
  if ( filename && *filename )
  {
    if ( !strchr(filename, 58) )
      return 0;
    cp = LYSkipBlanks(filename);
    if ( *cp == 58 || *cp == 47 )
      return 0;
    limit = strlen(cp);
    switch ( *cp )
    {
      case 'B':
      case 'b':
        if ( compare_type(cp, "bibp:", 5u) )
          result = BIBP_URL_TYPE_0;
        goto LABEL_117;
      case 'D':
      case 'd':
        if ( compare_type(cp, "data:", 5u) )
          result = DATA_URL_TYPE_0;
        goto LABEL_117;
      case 'F':
      case 'f':
        if ( compare_type(cp, "file:", 5u) )
        {
          if ( LYisLocalFile(cp) )
          {
            result = FILE_URL_TYPE_0;
          }
          else if ( cp[5] == 47 && cp[6] == 47 )
          {
            result = FTP_URL_TYPE_0;
          }
        }
        else if ( limit > 5 && cp[4] == 47 && cp[5] == 47 && compare_type(cp, "ftp:", 4u) )
        {
          result = FTP_URL_TYPE_0;
        }
        else if ( limit > 8 && cp[7] == 47 && cp[8] == 47 && compare_type(cp, "finger:", 7u) )
        {
          result = FINGER_URL_TYPE_0;
        }
        goto LABEL_117;
      case 'L':
      case 'l':
        if ( compare_type(cp, "lynxexec:", 9u) )
        {
          result = LYNXEXEC_URL_TYPE_0;
        }
        else if ( compare_type(cp, "lynxprog:", 9u) )
        {
          result = LYNXPROG_URL_TYPE_0;
        }
        else if ( compare_type(cp, "lynxcgi:", 8u) )
        {
          result = LYNXCGI_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXPRINT:", 0xAu) )
        {
          result = LYNXPRINT_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXOPTIONS:", 0xCu) )
        {
          result = LYNXOPTIONS_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXCFG:", 8u) )
        {
          result = LYNXCFG_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXMESSAGES:", 0xDu) )
        {
          result = LYNXMESSAGES_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXCOMPILEOPTS:", 0x10u) )
        {
          result = LYNXCOMPILE_OPTS_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXDOWNLOAD:", 0xDu) )
        {
          result = LYNXDOWNLOAD_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXDIRED:", 0xAu) )
        {
          result = LYNXDIRED_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXHIST:", 9u) )
        {
          result = LYNXHIST_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXKEYMAP:", 0xBu) )
        {
          result = LYNXKEYMAP_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXIMGMAP:", 0xBu) )
        {
          is_url(cp + 11);
          result = LYNXIMGMAP_URL_TYPE_0;
        }
        else if ( compare_type(cp, "LYNXCOOKIE:", 0xBu) )
        {
          result = LYNXCOOKIE_URL_TYPE_0;
        }
        goto LABEL_117;
      case 'M':
      case 'm':
        if ( compare_type(cp, "mailto:", 7u) )
          result = MAILTO_URL_TYPE_0;
        goto LABEL_117;
      case 'N':
      case 'n':
        if ( compare_type(cp, "news:", 5u) )
        {
          result = NEWS_URL_TYPE_0;
        }
        else if ( compare_type(cp, "nntp:", 5u) )
        {
          result = NNTP_URL_TYPE_0;
        }
        else if ( compare_type(cp, "newspost:", 9u) )
        {
          result = NEWSPOST_URL_TYPE_0;
        }
        else if ( compare_type(cp, "newsreply:", 0xAu) )
        {
          result = NEWSREPLY_URL_TYPE_0;
        }
        goto LABEL_117;
      case 'S':
      case 's':
        if ( compare_type(cp, "snews:", 6u) )
        {
          result = SNEWS_URL_TYPE_0;
        }
        else if ( compare_type(cp, "snewspost:", 0xAu) )
        {
          result = NEWSPOST_URL_TYPE_0;
        }
        else if ( compare_type(cp, "snewsreply:", 0xBu) )
        {
          result = NEWSREPLY_URL_TYPE_0;
        }
        goto LABEL_117;
      default:
        if ( limit > 2 )
        {
          cp1 = strchr(cp + 3, 58);
          if ( !cp1 || cp1[1] != 47 || cp1[2] != 47 )
          {
            if ( cp1 && cp1 - cp > 1 && LYisAbsPath(cp1 + 1) )
              result = NCFTP_URL_TYPE_0;
            goto LABEL_117;
          }
        }
        break;
    }
    switch ( *cp )
    {
      case 'A':
      case 'a':
        if ( compare_type(cp, "afs:", 4u) )
          result = AFS_URL_TYPE_0;
        goto LABEL_117;
      case 'C':
      case 'c':
        if ( compare_type(cp, "cso:", 4u) )
          result = CSO_URL_TYPE_0;
        goto LABEL_117;
      case 'G':
      case 'g':
        if ( !compare_type(cp, "gopher:", 7u) )
          goto LABEL_117;
        if ( strlen(cp) <= 0xA || (cp1a = strchr(cp + 11, 47)) == 0 )
        {
          result = GOPHER_URL_TYPE_0;
LABEL_117:
          if ( result == NOT_A_URL_TYPE_0 )
            return LYCheckForProxyURL(filename);
          return result;
        }
        if ( ((*__ctype_b_loc())[(unsigned __int8)cp1a[1]] & 0x200) != 0 )
        {
          if ( toupper((unsigned __int8)cp1a[1]) != 72 )
          {
LABEL_94:
            if ( cp1a[1] != 119 )
            {
              if ( cp1a[1] == 84 || cp1a[1] == 56 )
              {
                result = TELNET_GOPHER_URL_TYPE_0;
              }
              else if ( cp1a[1] == 55 )
              {
                result = INDEX_GOPHER_URL_TYPE_0;
              }
              else
              {
                result = GOPHER_URL_TYPE_0;
              }
              goto LABEL_117;
            }
          }
        }
        else if ( cp1a[1] != 72 )
        {
          goto LABEL_94;
        }
        result = HTML_GOPHER_URL_TYPE_0;
        goto LABEL_117;
      case 'H':
      case 'h':
        if ( compare_type(cp, "http:", 5u) )
        {
          result = HTTP_URL_TYPE_0;
        }
        else if ( compare_type(cp, "https:", 6u) )
        {
          result = HTTPS_URL_TYPE_0;
        }
        goto LABEL_117;
      case 'P':
      case 'p':
        if ( compare_type(cp, "prospero:", 9u) )
          result = PROSPERO_URL_TYPE_0;
        goto LABEL_117;
      case 'R':
      case 'r':
        if ( compare_type(cp, "rlogin:", 7u) )
          result = RLOGIN_URL_TYPE_0;
        goto LABEL_117;
      case 'T':
      case 't':
        if ( compare_type(cp, "telnet:", 7u) )
        {
          result = TELNET_URL_TYPE_0;
        }
        else if ( compare_type(cp, "tn3270:", 7u) )
        {
          result = TN3270_URL_TYPE_0;
        }
        goto LABEL_117;
      case 'W':
      case 'w':
        if ( compare_type(cp, "wais:", 5u) )
          result = WAIS_URL_TYPE_0;
        goto LABEL_117;
      default:
        goto LABEL_117;
    }
  }
  return 0;
}

//----- (08095AE4) --------------------------------------------------------
void __cdecl LYFixCursesOn(const char *reason)
{
  FILE *v1; // eax

  if ( !dump_output_immediately && !LYCursesON[0] )
  {
    if ( reason )
    {
      if ( WWW_TraceFlag[0] )
      {
        v1 = TraceFP();
        fprintf(v1, "Forcing curses on to %s\n", reason);
      }
    }
    start_curses();
  }
}

//----- (08095B36) --------------------------------------------------------
BOOLEAN __cdecl LYFixCursesOnForAccess(const char *addr, const char *physical)
{
  char *v2; // eax
  char *cp1; // [esp+24h] [ebp-4h]

  if ( dump_output_immediately )
    return 0;
  if ( LYCursesON[0] )
    return 0;
  if ( !physical )
    return 0;
  if ( !strstr(addr, "://") )
    return 0;
  if ( strncasecomp(addr, "telnet:", 7) )
  {
    if ( strncasecomp(addr, "rlogin:", 7) )
    {
      if ( strncasecomp(addr, "tn3270:", 7) )
      {
        if ( !strncasecomp(addr, "gopher:", 7) )
          return 0;
        cp1 = strchr(addr + 11, 47);
        if ( !cp1 || cp1[1] != 84 && cp1[1] != 56 )
          return 0;
      }
    }
  }
  if ( !strncasecomp(physical, "telnet:", 7)
    || !strncasecomp(physical, "rlogin:", 7)
    || !strncasecomp(physical, "tn3270:", 7) )
  {
    return 0;
  }
  start_curses();
  v2 = gettext("Unexpected access protocol for this URL scheme.");
  HTAlert(v2);
  return 1;
}

//----- (08095CC6) --------------------------------------------------------
BOOLEAN __cdecl LYCanDoHEAD(const char *address)
{
  const char *s; // [esp+14h] [ebp-24h]
  const char *proxy; // [esp+20h] [ebp-18h]
  char *acc_method; // [esp+24h] [ebp-14h] BYREF
  char *cp; // [esp+28h] [ebp-10h]
  char *temp; // [esp+2Ch] [ebp-Ch]
  int isurl; // [esp+30h] [ebp-8h]
  char *temp0; // [esp+34h] [ebp-4h] BYREF

  temp0 = 0;
  if ( !address || !*address )
    return 0;
  if ( !strncmp(address, "http", 4u) )
    return 1;
  HTSACopy(&temp0, address);
  isurl = is_url(temp0);
  switch ( isurl )
  {
    case 0:
      if ( temp0 )
      {
        free(temp0);
        temp0 = 0;
      }
      return 0;
    case 25:
      if ( temp0 )
      {
        free(temp0);
        temp0 = 0;
      }
      return 1;
    case 7:
    case 8:
      temp = HTParse(address, byte_8156400, 4);
      cp = strrchr(temp, 47);
      if ( cp )
        s = cp;
      else
        s = temp;
      if ( strchr(s, 64) )
      {
        if ( temp0 )
        {
          free(temp0);
          temp0 = 0;
        }
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
        return 1;
      }
      if ( cp && ((*__ctype_b_loc())[(unsigned __int8)cp[1]] & 0x800) != 0 && !strchr(cp, 45) )
      {
        if ( temp0 )
        {
          free(temp0);
          temp0 = 0;
        }
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
        return 1;
      }
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      break;
  }
  if ( isurl != 3 )
  {
    acc_method = HTParse(temp0, byte_8156400, 16);
    if ( acc_method )
    {
      if ( *acc_method )
      {
        HTSACat(&acc_method, "_proxy");
        proxy = LYGetEnv(acc_method);
        if ( proxy )
        {
          if ( (!strncasecomp(proxy, "http:", 5)
             || (*proxy == 108 || *proxy == 76) && !strncasecomp(proxy, "lynxcgi:", 8))
            && !override_proxy(temp0) )
          {
            if ( temp0 )
            {
              free(temp0);
              temp0 = 0;
            }
            if ( acc_method )
            {
              free(acc_method);
              acc_method = 0;
            }
            return 1;
          }
        }
      }
    }
    if ( acc_method )
    {
      free(acc_method);
      acc_method = 0;
    }
  }
  if ( temp0 )
  {
    free(temp0);
    temp0 = 0;
  }
  return 0;
}

//----- (08096004) --------------------------------------------------------
BOOLEAN __cdecl LYCloseInput(FILE *fp)
{
  BOOLEAN v2; // [esp+7h] [ebp-11h]
  int err; // [esp+14h] [ebp-4h]

  v2 = 0;
  if ( fp )
  {
    err = ferror(fp);
    fclose(fp);
    if ( !err )
      return 1;
  }
  return v2;
}

//----- (0809603F) --------------------------------------------------------
BOOLEAN __cdecl LYCloseOutput(FILE *fp)
{
  char *v1; // eax
  int err; // [esp+14h] [ebp-4h]

  if ( fp )
  {
    err = ferror(fp);
    fclose(fp);
    if ( !err )
      return 1;
  }
  v1 = gettext("Cannot write to file.");
  HTAlert(v1);
  return 0;
}

//----- (0809608E) --------------------------------------------------------
BOOLEAN __cdecl LYCanWriteFile(const char *filename)
{
  FILE *v1; // eax
  char *v2; // eax

  v1 = (FILE *)fopen64(filename, "w");
  if ( LYCloseOutput(v1) )
  {
    remove(filename);
    return 1;
  }
  else
  {
    mustshow[0] = 1;
    v2 = gettext("Enter a new filename: ");
    statusline(v2);
    return 0;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080960E9) --------------------------------------------------------
BOOLEAN __cdecl LYCanReadFile(const char *filename)
{
  FILE *fp; // [esp+24h] [ebp-4h]

  if ( filename && *filename && (fp = (FILE *)fopen64(filename, "r")) != 0 )
    return LYCloseInput(fp);
  else
    return 0;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08096135) --------------------------------------------------------
void __cdecl remove_backslashes(char *buf)
{
  char *cp; // [esp+Ch] [ebp-4h]

  for ( cp = buf; *cp; ++cp )
  {
    if ( *cp == 92 )
    {
      if ( cp[1] == 92 )
        *buf++ = *cp;
    }
    else
    {
      *buf++ = *cp;
    }
  }
  *buf = 0;
}

//----- (0809619A) --------------------------------------------------------
int inlocaldomain()
{
  size_t v0; // ebx
  size_t v1; // ebx
  size_t v2; // eax
  FILE *v3; // eax
  const char *v5; // [esp+10h] [ebp-1A8h]
  char *mytty; // [esp+1Ch] [ebp-19Ch]
  char *myttya; // [esp+1Ch] [ebp-19Ch]
  const char *cp; // [esp+20h] [ebp-198h]
  FILE *fp; // [esp+24h] [ebp-194h]
  int n; // [esp+28h] [ebp-190h]
  int result; // [esp+2Ch] [ebp-18Ch]
  utmp me; // [esp+30h] [ebp-188h] BYREF
  unsigned int v13; // [esp+1B0h] [ebp-8h]

  v13 = __readgsdword(0x14u);
  mytty = 0;
  cp = ttyname(0);
  if ( cp )
    mytty = LYLastPathSep(cp);
  result = 0;
  if ( mytty && (fp = (FILE *)fopen64("/var/run/utmp", "r")) != 0 )
  {
    myttya = mytty + 1;
    do
      n = fread(&me, 0x180u, 1u, fp);
    while ( n > 0 && strcmp(me.ut_line, myttya) );
    LYCloseInput(fp);
    if ( n > 0 )
    {
      v0 = strlen(me.ut_host);
      if ( v0 > strlen(LYLocalDomain)
        && (v1 = strlen(me.ut_host), v2 = strlen(LYLocalDomain), !strcmp(LYLocalDomain, &me.ut_host[v1 - v2])) )
      {
        return 1;
      }
      else if ( !me.ut_host[0] )
      {
        return 1;
      }
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    if ( cp )
      v5 = cp;
    else
      v5 = "(null)";
    v3 = TraceFP();
    fprintf(v3, "Could not get ttyname (returned %s) or open UTMP file %s\n", v5, "/var/run/utmp");
  }
  return result;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080963AE) --------------------------------------------------------
void __cdecl LYExtSignal(int sig, LYSigHandlerFunc_t *handler)
{
  sigaction act; // [esp+1Ch] [ebp-8Ch] BYREF

  if ( sig == 28 && LYNonRestartingSIGWINCH )
  {
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    sigaction(28, &act, 0);
  }
  else
  {
    signal(sig, handler);
  }
}
// 80963ED: conditional instruction was optimized away because %sig.4==1C

//----- (0809642D) --------------------------------------------------------
BOOLEAN __cdecl LYToggleSigDfl(int sig, sigaction *where, int to_dfl)
{
  int *v3; // eax
  char *v4; // ebx
  FILE *v5; // eax
  sigaction oact; // [esp+14h] [ebp-94h] BYREF
  int rv; // [esp+A0h] [ebp-8h]

  rv = -1;
  if ( to_dfl == 1 )
  {
    rv = sigaction(sig, 0, &oact);
    if ( !rv )
    {
      if ( oact.sa_handler )
      {
        oact.sa_handler = 0;
        rv = sigaction(sig, &oact, where);
      }
      else if ( where )
      {
        memcpy(where, &oact, sizeof(sigaction));
        rv = 0;
      }
    }
  }
  else
  {
    rv = sigaction(sig, where, 0);
  }
  if ( !rv )
    return 1;
  if ( WWW_TraceFlag[0] )
  {
    v3 = __errno_location();
    v4 = strerror(*v3);
    v5 = TraceFP();
    fprintf(v5, "Error in LYToggleSigDfl: %s\n", v4);
  }
  return 0;
}

//----- (08096549) --------------------------------------------------------
void __cdecl size_change(int sig)
{
  int v1; // ebx
  int v2; // esi
  FILE *v3; // eax
  winsize win; // [esp+20h] [ebp-18h] BYREF
  int old_cols; // [esp+28h] [ebp-10h]
  int old_lines; // [esp+2Ch] [ebp-Ch]

  old_lines = LYlines;
  old_cols = LYcols;
  if ( !ioctl(0, 0x5413u, &win) )
  {
    if ( win.ws_row )
      LYlines = win.ws_row;
    if ( win.ws_col )
      LYcols = win.ws_col;
  }
  if ( LYlines <= 0 )
    LYlines = 24;
  if ( LYcols <= 0 )
    LYcols = 80;
  if ( LYlines != old_lines || LYcols != old_cols )
  {
    recent_sizechange = 1;
    if ( WWW_TraceFlag[0] )
    {
      v1 = LYcols;
      v2 = LYlines;
      v3 = TraceFP();
      fprintf(v3, "Window size changed from (%d,%d) to (%d,%d)\n", old_lines, old_cols, v2, v1);
    }
  }
  LYExtSignal(28, size_change);
}

//----- (0809664C) --------------------------------------------------------
void HTSugFilenames_free()
{
  LYFreeStringList(sug_filenames);
  sug_filenames = 0;
}

//----- (0809666B) --------------------------------------------------------
void __cdecl HTAddSugFilename(char *fname)
{
  void *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]
  char *tmp; // [esp+24h] [ebp-4h] BYREF

  tmp = 0;
  if ( fname && *fname )
  {
    HTSACopy(&tmp, fname);
    if ( sug_filenames )
    {
      cur = sug_filenames;
      while ( 1 )
      {
        if ( cur && (cur = cur->next) != 0 )
          object = cur->object;
        else
          object = 0;
        if ( !object )
          break;
        if ( !strcmp((const char *)object, tmp) )
        {
          HTList_removeObject(sug_filenames, object);
          free(object);
          break;
        }
      }
      HTList_addObject(sug_filenames, tmp);
    }
    else
    {
      sug_filenames = HTList_new();
      HTList_addObject(sug_filenames, tmp);
    }
  }
}
// 8096708: conditional instruction was optimized away because %var_14.4!=0

//----- (08096767) --------------------------------------------------------
void __cdecl change_sug_filename(char *fname)
{
  __pid_t v1; // eax
  __pid_t v2; // eax
  size_t v3; // ebx
  size_t v4; // [esp+8h] [ebp-40h]
  unsigned int v5; // [esp+1Ch] [ebp-2Ch]
  char *src; // [esp+20h] [ebp-28h]
  char *end; // [esp+30h] [ebp-18h]
  char *cp1; // [esp+34h] [ebp-14h]
  const char *cp1a; // [esp+34h] [ebp-14h]
  char *cp1b; // [esp+34h] [ebp-14h]
  const char *cp; // [esp+38h] [ebp-10h]
  const char *cpa; // [esp+38h] [ebp-10h]
  char *cpb; // [esp+38h] [ebp-10h]
  char *cpc; // [esp+38h] [ebp-10h]
  char *cpd; // [esp+38h] [ebp-10h]
  const char *cpe; // [esp+38h] [ebp-10h]
  char *cpf; // [esp+38h] [ebp-10h]
  char *cpg; // [esp+38h] [ebp-10h]
  char *cph; // [esp+38h] [ebp-10h]
  char *temp; // [esp+3Ch] [ebp-Ch] BYREF
  const char *cp2; // [esp+40h] [ebp-8h]

  temp = 0;
  end = &fname[strlen(fname)];
  HTUnEscape(fname);
  cp2 = wwwName(lynx_temp_space);
  if ( *cp2 == 47 )
  {
    v1 = getpid();
    HTSprintf0(&temp, "file://localhost%s%u", cp2, v1);
  }
  else
  {
    v2 = getpid();
    HTSprintf0(&temp, "file://localhost/%s%u", cp2, v2);
  }
  v4 = strlen(temp);
  if ( !strncmp(fname, temp, v4) )
  {
    cp = strrchr(fname, 46);
    v3 = strlen(cp);
    if ( v3 > strlen(temp) - 4 )
      cp = 0;
    if ( cp )
      src = (char *)cp;
    else
      src = (char *)byte_8156400;
    HTSACopy(&temp, src);
    sprintf(fname, "temp%.*s", 246, temp);
  }
  if ( temp )
  {
    free(temp);
    temp = 0;
  }
  if ( fname[strlen(fname) - 1] == 47 )
    fname[strlen(fname) - 1] = 0;
  cpa = strrchr(fname, 47);
  if ( cpa && strlen(cpa) > 1 )
  {
    cp1 = fname;
    for ( cpb = (char *)(cpa + 1); *cpb; ++cpb )
      *cp1++ = *cpb;
    *cp1 = 0;
  }
  if ( *(end - 1) == 93 )
  {
    cpc = strrchr(fname, 91);
    if ( cpc )
    {
      if ( cpc > fname )
      {
        cpd = cpc - 1;
        if ( *cpd == 32 )
        {
          while ( *cpd == 32 )
            *cpd-- = 0;
        }
      }
    }
  }
  cpe = strchr(fname, 91);
  if ( cpe )
  {
    cp1a = strrchr(cpe, 93);
    if ( cp1a )
    {
      if ( strlen(cp1a) > 1 )
      {
        cp1b = (char *)(cp1a + 1);
        cpf = fname;
        while ( *cp1b )
          *cpf++ = *cp1b++;
        *cpf = 0;
      }
    }
  }
  for ( cpg = fname; *cpg; ++cpg )
  {
    v5 = *cpg - 32;
    if ( v5 <= 0xF && ((1 << v5) & 0x8085) != 0 )
      *cpg = 45;
  }
  for ( cph = &fname[strlen(fname)]; cph < end; ++cph )
    *cph = 0;
}

//----- (08096A7D) --------------------------------------------------------
int __cdecl fmt_tempname(char *result, const char *prefix, const char *suffix)
{
  time_t v3; // eax
  char *v4; // eax
  unsigned int v5; // ebx
  __pid_t v6; // eax
  size_t v7; // ebx
  FILE *v8; // eax
  const char *suffixa; // [esp+34h] [ebp-124h]
  const char *prefixa; // [esp+38h] [ebp-120h]
  unsigned int mask; // [esp+40h] [ebp-118h]
  int code; // [esp+48h] [ebp-110h]
  char leaf[256]; // [esp+4Ch] [ebp-10Ch] BYREF
  unsigned int v15; // [esp+14Ch] [ebp-Ch]

  prefixa = prefix;
  suffixa = suffix;
  v15 = __readgsdword(0x14u);
  if ( !prefix )
    prefixa = byte_8156400;
  if ( !suffix )
    suffixa = byte_8156400;
  if ( first_14418 )
  {
    v3 = time(0);
    srandom((unsigned int)&result[v3]);
    first_14418 = 0;
  }
  counter_14423 = 10000;
  if ( names_used_14419 <= 9999 )
  {
    counter_14423 = (__int64)((long double)random() * 10000.0 / 2147483600.0 + 1.0);
    counter_14423 %= 0x2710u;
    mask = 1 << (counter_14423 & 7);
    if ( ((unsigned __int8)mask & used_tempname_14420[counter_14423 >> 3]) == 0 )
    {
      ++names_used_14419;
      used_tempname_14420[counter_14423 >> 3] |= mask;
    }
  }
  if ( names_used_14419 > 9999 )
  {
    v4 = gettext("Too many tempfiles");
    HTAlert(v4);
  }
  v5 = counter_14423;
  v6 = getpid();
  sprintf(leaf, "L%u-%uTMP%s", v6, v5, suffixa);
  v7 = strlen(prefixa);
  if ( v7 + strlen(leaf) > 0xFF )
  {
    sprintf(result, "%.*s", 255, leaf);
    code = 0;
  }
  else
  {
    sprintf(result, "%s%s", prefixa, leaf);
    code = 1;
  }
  if ( WWW_TraceFlag[0] )
  {
    v8 = TraceFP();
    fprintf(v8, "-> '%s'\n", result);
  }
  return code;
}

//----- (08096D73) --------------------------------------------------------
int __cdecl number2arrows(int number)
{
  switch ( number )
  {
    case '1':
      number = 263;
      break;
    case '2':
      number = 257;
      break;
    case '3':
      number = 260;
      break;
    case '4':
      number = 259;
      break;
    case '5':
      number = 270;
      break;
    case '6':
      number = 258;
      break;
    case '7':
      number = 262;
      break;
    case '8':
      number = 256;
      break;
    case '9':
      number = 261;
      break;
    default:
      return number;
  }
  return number;
}

//----- (08096DE8) --------------------------------------------------------
BOOLEAN __cdecl strn_dash_equ(const char *p1, const char *p2, int len)
{
  int v6; // [esp+4h] [ebp-4h]

  while ( len-- != 0 )
  {
    if ( !*p2 )
      return 0;
    v6 = *p1;
    if ( v6 == 45 || v6 == 95 )
    {
      if ( *p2 != 95 )
        return 0;
    }
    else
    {
      if ( !*p1 )
        return 0;
      if ( *p1 != *p2 )
        return 0;
    }
    ++p1;
    ++p2;
  }
  return 1;
}

//----- (08096E6B) --------------------------------------------------------
const char *__cdecl index_to_restriction(int inx)
{
  if ( inx < 0 || inx > 57 )
    return 0;
  else
    return restrictions[inx].name;
}

//----- (08096EA4) --------------------------------------------------------
int __cdecl find_restriction(const char *name, int len)
{
  unsigned int i; // [esp+24h] [ebp-4h]

  if ( len < 0 )
    len = strlen(name);
  for ( i = 0; i <= 0x39; ++i )
  {
    if ( strn_dash_equ(name, restrictions[i].name, len) )
      return *restrictions[i].flag;
  }
  return -1;
}

//----- (08096F26) --------------------------------------------------------
void __cdecl parse_restrictions(const char *s)
{
  char *v1; // edx
  unsigned int i; // [esp+14h] [ebp-14h]
  unsigned int ia; // [esp+14h] [ebp-14h]
  unsigned int ib; // [esp+14h] [ebp-14h]
  const char *word; // [esp+18h] [ebp-10h]
  BOOLEAN found; // [esp+23h] [ebp-5h]

  while ( *s )
  {
    s = LYSkipCBlanks(s);
    if ( !*s )
      break;
    word = s;
    while ( *s != 44 && *s )
      ++s;
    found = 0;
    if ( strn_dash_equ(word, "all", s - word) )
    {
      found = 1;
      for ( i = 2; i <= 0x39; ++i )
        *restrictions[i].flag = 1;
    }
    else if ( strn_dash_equ(word, "default", s - word) )
    {
      found = 1;
      for ( ia = 2; ia <= 0x39; ++ia )
        *restrictions[ia].flag = restrictions[ia].can == 0;
    }
    else
    {
      for ( ib = 0; ib <= 0x39; ++ib )
      {
        if ( strn_dash_equ(word, restrictions[ib].name, s - word) )
        {
          *restrictions[ib].flag = 1;
          found = 1;
          break;
        }
      }
    }
    if ( !found )
    {
      v1 = gettext("unknown restriction");
      printf("%s: %.*s\n", v1, s - word, word);
      exit_immediately(1);
    }
    if ( *s )
      ++s;
  }
  if ( no_shell )
  {
    no_goto_lynxexec = 1;
    no_goto_lynxprog = 1;
    no_goto_lynxcgi = 1;
    local_exec_on_local_files = 1;
  }
}

//----- (0809712B) --------------------------------------------------------
void __cdecl print_restrictions_to_fd(FILE *fp)
{
  char *v1; // [esp+4h] [ebp-24h]
  char *v2; // [esp+4h] [ebp-24h]
  unsigned int count; // [esp+20h] [ebp-8h]
  unsigned int i; // [esp+24h] [ebp-4h]
  unsigned int ia; // [esp+24h] [ebp-4h]

  count = 0;
  for ( i = 0; i <= 0x39; ++i )
  {
    if ( *restrictions[i].flag == 1 )
      ++count;
  }
  if ( count )
  {
    v2 = gettext("Restrictions set:\n");
    fprintf(fp, v2);
    for ( ia = 0; ia <= 0x39; ++ia )
    {
      if ( *restrictions[ia].flag == 1 && (strncmp(restrictions[ia].name, "goto_", 5u) || !no_goto) )
        fprintf(fp, "   %s\n", restrictions[ia].name);
    }
  }
  else
  {
    v1 = gettext("No restrictions set.\n");
    fprintf(fp, v1);
  }
}

//----- (0809723D) --------------------------------------------------------
void LYCheckMail()
{
  char *v0; // eax
  char *v1; // eax
  stat st; // [esp+34h] [ebp-64h] BYREF
  time_t now; // [esp+94h] [ebp-4h] BYREF

  if ( firsttime_14684 )
  {
    mf_14685 = LYGetEnv("MAIL");
    firsttime_14684 = 0;
    time(&lasttime_14687);
  }
  if ( mf_14685 )
  {
    time(&now);
    if ( now - lastcheck_14686 > 59 )
    {
      lastcheck_14686 = now;
      if ( stat64((int)mf_14685, (int)&st) >= 0 && (st.st_mode & 0xF000) == 0x8000 )
      {
        if ( st.st_size > 0 )
        {
          if ( (st.st_mtim.tv_sec == lasttime_14687 || st.st_mtim.tv_sec <= st.st_atim.tv_sec)
            && (!lastsize_14688 || st.st_size <= lastsize_14688) )
          {
            if ( !lastsize_14688 )
            {
              v1 = gettext("*** You have mail. ***");
              HTUserMsg(v1);
            }
          }
          else
          {
            v0 = gettext("*** You have new mail. ***");
            HTUserMsg(v0);
          }
        }
        lastsize_14688 = st.st_size;
        lasttime_14687 = st.st_mtim.tv_sec;
      }
      else
      {
        mf_14685 = 0;
      }
    }
  }
}

//----- (080973B3) --------------------------------------------------------
void __cdecl LYEnsureAbsoluteURL(char **href, const char *name, int fixit)
{
  FILE *v3; // eax
  char *v4; // [esp+1Ch] [ebp-1Ch]
  const char *v5; // [esp+20h] [ebp-18h]
  const char *v6; // [esp+24h] [ebp-14h]
  char *temp; // [esp+34h] [ebp-4h]

  if ( *href && **href )
  {
    LYFillLocalFileURL(href, "file://localhost");
    if ( strcasecomp(*href, "news:") )
    {
      if ( !strcasecomp(*href, "snews:") )
        HTSACat(href, "/*");
    }
    else
    {
      HTSACat(href, "*");
    }
    if ( is_url(*href) == NOT_A_URL_TYPE_0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = *href;
        if ( name )
          v5 = " ";
        else
          v5 = byte_8156400;
        if ( name )
          v6 = name;
        else
          v6 = byte_8156400;
        v3 = TraceFP();
        fprintf(v3, "%s%s'%s' is not a URL\n", v6, v5, v4);
      }
      LYConvertToURL(href, fixit);
    }
    temp = HTParse(*href, byte_8156400, 31);
    if ( temp && *temp )
      HTSACopy(href, temp);
    if ( temp )
      free(temp);
  }
}

//----- (08097533) --------------------------------------------------------
void __cdecl LYConvertToURL(char **AllocatedString, int fixit)
{
  const char *v2; // eax
  char *v3; // ebx
  char *v4; // esi
  FILE *v5; // eax
  char *v6; // ebx
  char *v7; // esi
  FILE *v8; // eax
  char *v9; // ebx
  char *v10; // esi
  FILE *v11; // eax
  char *v12; // ebx
  char *v13; // esi
  FILE *v14; // eax
  FILE *v15; // eax
  char *v16; // ebx
  FILE *v17; // eax
  char *v18; // ebx
  char *v19; // esi
  FILE *v20; // eax
  char *v21; // ebx
  char *v22; // esi
  FILE *v23; // eax
  const char *v24; // eax
  char *v25; // ebx
  char *v26; // esi
  FILE *v27; // eax
  const char *v28; // [esp+4h] [ebp-1A4h]
  const char *v29; // [esp+4h] [ebp-1A4h]
  char *v30; // [esp+18h] [ebp-190h]
  stat st; // [esp+20h] [ebp-188h] BYREF
  char *cp2; // [esp+80h] [ebp-128h] BYREF
  char *temp2; // [esp+84h] [ebp-124h] BYREF
  char *fragment; // [esp+88h] [ebp-120h]
  char *cp; // [esp+8Ch] [ebp-11Ch] BYREF
  char *temp; // [esp+90h] [ebp-118h] BYREF
  char *old_string; // [esp+94h] [ebp-114h] BYREF
  BOOLEAN is_local; // [esp+9Bh] [ebp-10Dh]
  char curdir[256]; // [esp+9Ch] [ebp-10Ch] BYREF
  unsigned int v40; // [esp+19Ch] [ebp-Ch]

  v40 = __readgsdword(0x14u);
  old_string = *AllocatedString;
  temp = 0;
  cp = 0;
  if ( !old_string || !*old_string )
    return;
  *AllocatedString = 0;
  HTSACopy(AllocatedString, "file://localhost");
  if ( *old_string == 47 )
  {
    if ( !old_string[1] )
    {
      HTSACat(AllocatedString, "/");
      goto LABEL_80;
    }
    if ( stat64((int)old_string, (int)&st) >= 0 || LYCanReadFile(old_string) )
    {
      HTSACopy(&temp, old_string);
      LYTrimRelFromAbsPath(temp);
      if ( WWW_TraceFlag[0] )
      {
        v18 = temp;
        v19 = old_string;
        v20 = TraceFP();
        fprintf(v20, "Converted '%s' to '%s'\n", v19, v18);
      }
      cp = HTEscape(temp, 4u);
      HTSACat(AllocatedString, cp);
      if ( cp )
      {
        free(cp);
        cp = 0;
      }
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      if ( WWW_TraceFlag[0] )
      {
        v21 = *AllocatedString;
        v22 = old_string;
        v23 = TraceFP();
        fprintf(v23, "Converted '%s' to '%s'\n", v22, v21);
      }
      goto LABEL_80;
    }
    if ( old_string[1] == 126 )
    {
      v24 = Home_Dir();
      v29 = wwwName(v24);
      HTSACat(AllocatedString, v29);
      cp = strchr(old_string + 1, 47);
      if ( !cp || (HTSACopy(&temp, cp), LYTrimRelFromAbsPath(temp), HTSACat(AllocatedString, temp), !temp) )
      {
LABEL_80:
        if ( WWW_TraceFlag[0] )
        {
          v25 = *AllocatedString;
          v26 = old_string;
          v27 = TraceFP();
          fprintf(v27, "Converted '%s' to '%s'\n", v26, v25);
        }
        goto LABEL_82;
      }
    }
    else
    {
      HTSACopy(&temp, old_string);
      LYTrimRelFromAbsPath(temp);
      HTSACat(AllocatedString, temp);
      if ( !temp )
        goto LABEL_80;
    }
    free(temp);
    temp = 0;
    goto LABEL_80;
  }
  fragment = 0;
  if ( *old_string != 126 )
  {
    temp2 = 0;
    is_local = 0;
    Current_Dir(curdir);
    HTSACopy(&temp, curdir);
    HTSACat(&temp, "/");
    HTSACat(&temp, old_string);
    LYTrimRelFromAbsPath(temp);
    if ( WWW_TraceFlag[0] )
    {
      v6 = temp;
      v7 = old_string;
      v8 = TraceFP();
      fprintf(v8, "Converted '%s' to '%s'\n", v7, v6);
    }
    if ( stat64((int)temp, (int)&st) >= 0 || LYCanReadFile(temp) )
    {
      cp = HTEscape(temp, 4u);
      HTSACat(AllocatedString, cp);
      if ( cp )
      {
        free(cp);
        cp = 0;
      }
      if ( WWW_TraceFlag[0] )
      {
        v9 = *AllocatedString;
        v10 = old_string;
        v11 = TraceFP();
        fprintf(v11, "Converted '%s' to '%s'\n", v10, v9);
      }
      is_local = 1;
    }
    else
    {
      cp2 = 0;
      HTSACopy(&temp2, curdir);
      LYAddPathSep(&temp2);
      HTSACopy(&cp, old_string);
      fragment = trimPoundSelector(cp);
      HTUnEscape(cp);
      HTSACat(&temp2, cp);
      HTSACopy(&cp2, temp2);
      LYTrimRelFromAbsPath(temp2);
      if ( !strcmp(temp2, temp) || stat64((int)temp2, (int)&st) < 0 && !LYCanReadFile(temp2) )
      {
        if ( strchr(curdir, 35) || strchr(curdir, 37) )
        {
          if ( temp )
          {
            free(temp);
            temp = 0;
          }
          if ( !strcmp(cp2, temp2) )
          {
            temp = HTEscape(curdir, 4u);
            LYAddHtmlSep(&temp);
            HTSACat(&temp, old_string);
          }
          else
          {
            temp = HTEscape(temp2, 4u);
            if ( fragment )
            {
              *fragment = 35;
              HTSACat(&temp, fragment);
            }
          }
        }
      }
      else
      {
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
        if ( !strcmp(cp2, temp2) )
        {
          temp = HTEscape(curdir, 4u);
          LYAddHtmlSep(&temp);
          HTSACat(&temp, old_string);
        }
        else
        {
          temp = HTEscape(temp2, 4u);
          if ( fragment )
          {
            *fragment = 35;
            HTSACat(&temp, fragment);
          }
        }
        HTSACat(AllocatedString, temp);
        if ( WWW_TraceFlag[0] )
        {
          v12 = *AllocatedString;
          v13 = old_string;
          v14 = TraceFP();
          fprintf(v14, "Converted '%s' to '%s'\n", v13, v12);
        }
        is_local = 1;
      }
      if ( cp )
      {
        free(cp);
        cp = 0;
      }
      if ( cp2 )
      {
        free(cp2);
        cp2 = 0;
      }
    }
    if ( is_local )
      goto LABEL_58;
    if ( WWW_TraceFlag[0] )
    {
      if ( temp2 )
        v30 = temp2;
      else
        v30 = temp;
      v15 = TraceFP();
      fprintf(v15, "Can't stat() or fopen() '%s'\n", v30);
    }
    if ( LYExpandHostForURL(&old_string, URLDomainPrefixes, URLDomainSuffixes) )
    {
      if ( !LYAddSchemeForURL(&old_string, "http://") )
      {
        HTSACopy(AllocatedString, "http://");
        HTSACat(AllocatedString, old_string);
        goto LABEL_56;
      }
    }
    else if ( !fixit )
    {
      HTSACat(AllocatedString, temp);
LABEL_56:
      if ( WWW_TraceFlag[0] )
      {
        v16 = *AllocatedString;
        v17 = TraceFP();
        fprintf(v17, "Trying: '%s'\n", v16);
      }
LABEL_58:
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      if ( temp2 )
      {
        free(temp2);
        temp2 = 0;
      }
      goto LABEL_82;
    }
    HTSACopy(AllocatedString, old_string);
    goto LABEL_56;
  }
  v2 = Home_Dir();
  v28 = wwwName(v2);
  HTSACat(AllocatedString, v28);
  cp = strchr(old_string, 47);
  if ( cp )
  {
    HTSACopy(&temp, cp);
    LYTrimRelFromAbsPath(temp);
    HTSACat(AllocatedString, temp);
    if ( temp )
    {
      free(temp);
      temp = 0;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v3 = *AllocatedString;
    v4 = old_string;
    v5 = TraceFP();
    fprintf(v5, "Converted '%s' to '%s'\n", v4, v3);
  }
LABEL_82:
  if ( old_string )
  {
    free(old_string);
    old_string = 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( !LYTraceLogFP )
      sleep(AlertSecs);
  }
}
// 80979E4: conditional instruction was optimized away because %fragment.4!=0
// 8097B49: conditional instruction was optimized away because %fragment.4!=0

//----- (08098073) --------------------------------------------------------
BOOLEAN __cdecl LYExpandHostForURL(char **AllocatedString, char *prefix_list, char *suffix_list)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  char *v6; // esi
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  char *v10; // ebx
  FILE *v11; // eax
  char *v12; // ebx
  char *v13; // ebx
  char *v14; // ebx
  char *v15; // eax
  char *v16; // eax
  char *v17; // ebx
  char *v18; // esi
  char *v19; // eax
  char *v20; // ebx
  FILE *v21; // eax
  char *v24; // [esp+18h] [ebp-90h]
  char *v25; // [esp+1Ch] [ebp-8Ch]
  const char *src; // [esp+20h] [ebp-88h]
  const char *v27; // [esp+24h] [ebp-84h]
  const char *v28; // [esp+28h] [ebp-80h]
  const char *v29; // [esp+2Ch] [ebp-7Ch]
  addrinfo hints; // [esp+3Ch] [ebp-6Ch] BYREF
  int error; // [esp+5Ch] [ebp-4Ch]
  addrinfo *res; // [esp+60h] [ebp-48h] BYREF
  char *Fragment; // [esp+64h] [ebp-44h]
  char *Path; // [esp+68h] [ebp-40h]
  char *host; // [esp+6Ch] [ebp-3Ch] BYREF
  char *HostColon; // [esp+70h] [ebp-38h]
  char *Host; // [esp+74h] [ebp-34h] BYREF
  char *MsgStr; // [esp+78h] [ebp-30h] BYREF
  char *StrColon; // [esp+7Ch] [ebp-2Ch]
  char *Str; // [esp+80h] [ebp-28h] BYREF
  const char *EndS; // [esp+84h] [ebp-24h]
  const char *StartS; // [esp+88h] [ebp-20h]
  char *DomainSuffix; // [esp+8Ch] [ebp-1Ch] BYREF
  const char *EndP; // [esp+90h] [ebp-18h]
  const char *StartP; // [esp+94h] [ebp-14h]
  char *DomainPrefix; // [esp+98h] [ebp-10h] BYREF
  BOOLEAN Startup; // [esp+9Eh] [ebp-Ah]
  BOOLEAN GotHost; // [esp+9Fh] [ebp-9h]

  DomainPrefix = 0;
  DomainSuffix = 0;
  Str = 0;
  StrColon = 0;
  MsgStr = 0;
  Host = 0;
  HostColon = 0;
  host = 0;
  Path = 0;
  Fragment = 0;
  GotHost = 0;
  Startup = helpfilepath == 0;
  if ( !*AllocatedString || !**AllocatedString || **AllocatedString == 47 || **AllocatedString == 35 )
    return GotHost;
  if ( !strncmp(*AllocatedString, "..", 2u) || !strncmp(*AllocatedString, "./", 2u) )
    return GotHost;
  HTSACopy(&Str, *AllocatedString);
  Path = strchr(Str, 47);
  if ( Path )
    *Path = 0;
  else
    Fragment = trimPoundSelector(Str);
  StrColon = strrchr(Str, 58);
  if ( StrColon && ((*__ctype_b_loc())[(unsigned __int8)StrColon[1]] & 0x800) != 0 )
  {
    if ( StrColon == Str )
      goto cleanup;
    *StrColon = 0;
  }
  HTSACopy(&host, Str);
  HTUnEscape(host);
  if ( LYCursesON[0] )
  {
    v3 = gettext("Looking up ");
    HTSACopy(&MsgStr, v3);
    HTSACat(&MsgStr, host);
    v4 = gettext(" first");
    HTSACat(&MsgStr, v4);
    HTProgress(MsgStr);
  }
  else if ( Startup && !dump_output_immediately )
  {
    v5 = gettext(" first");
    v6 = host;
    v7 = gettext("Looking up ");
    fprintf(stdout, "%s '%s'%s\r\n", v7, v6, v5);
  }
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  error = getaddrinfo(host, "80", &hints, &res);
  if ( !error && res )
  {
    if ( LYCursesON[0] && HTCheckForInterrupt() && WWW_TraceFlag[0] )
    {
      v8 = host;
      v9 = TraceFP();
      fprintf(v9, "LYExpandHostForURL: Ignoring interrupt because '%s' resolved.\n", v8);
    }
    GotHost = 1;
    goto cleanup;
  }
  if ( LYCursesON[0] && lynx_nsl_status == -29998 )
  {
    if ( WWW_TraceFlag[0] )
      goto LABEL_31;
    goto cleanup;
  }
  if ( !prefix_list || (v12 = Str, v12[strlen(Str) - 1] == 46) )
    v24 = (char *)byte_8156400;
  else
    v24 = prefix_list;
  StartP = v24;
  if ( *v24
    && *StartP != 46
    && (!strncasecomp(*AllocatedString, "www.", 4)
     || !strncasecomp(*AllocatedString, "ftp.", 4)
     || !strncasecomp(*AllocatedString, "gopher.", 7)
     || !strncasecomp(*AllocatedString, "wais.", 5)
     || !strncasecomp(*AllocatedString, "cso.", 4)
     || !strncasecomp(*AllocatedString, "ns.", 3)
     || !strncasecomp(*AllocatedString, "ph.", 3)
     || !strncasecomp(*AllocatedString, "finger.", 7)
     || !strncasecomp(*AllocatedString, "news.", 5)
     || !strncasecomp(*AllocatedString, "nntp.", 5)) )
  {
    StartP = byte_8156400;
  }
  while ( *StartP && (*StartP <= 0x20u || *StartP == 44) )
    ++StartP;
  for ( EndP = StartP; *EndP && *EndP > 0x20u && *EndP != 44; ++EndP )
    ;
  HTSACopy(&DomainPrefix, StartP);
  DomainPrefix[EndP - StartP] = 0;
LABEL_59:
  if ( !suffix_list || *Str == 46 )
    v25 = (char *)byte_8156400;
  else
    v25 = suffix_list;
  for ( StartS = v25; *StartS && (*StartS <= 0x20u || *StartS == 44); ++StartS )
    ;
  for ( EndS = StartS; *EndS && *EndS > 0x20u && *EndS != 44; ++EndS )
    ;
  HTSACopy(&DomainSuffix, StartS);
  DomainSuffix[EndS - StartS] = 0;
  while ( 1 )
  {
    HTSACopy(&Host, DomainPrefix);
    if ( *Str == 46 )
      src = Str + 1;
    else
      src = Str;
    HTSACat(&Host, src);
    v13 = Host;
    if ( v13[strlen(Host) - 1] == 46 )
    {
      v14 = Host;
      v14[strlen(Host) - 1] = 0;
    }
    HTSACat(&Host, DomainSuffix);
    HostColon = strrchr(Host, 58);
    if ( HostColon && ((*__ctype_b_loc())[(unsigned __int8)HostColon[1]] & 0x800) != 0 )
      *HostColon = 0;
    HTSACopy(&host, Host);
    HTUnEscape(host);
    if ( LYCursesON[0] )
    {
      v15 = gettext("Looking up ");
      HTSACopy(&MsgStr, v15);
      HTSACat(&MsgStr, host);
      v16 = gettext(", guessing...");
      HTSACat(&MsgStr, v16);
      HTProgress(MsgStr);
    }
    else if ( Startup && !dump_output_immediately )
    {
      v17 = gettext(", guessing...");
      v18 = host;
      v19 = gettext("Looking up ");
      fprintf(stdout, "%s '%s'%s\n", v19, v18, v17);
    }
    GotHost = LYGetHostByName(host) != 0;
    if ( HostColon )
      *HostColon = 58;
    if ( GotHost )
      goto LABEL_108;
    if ( LYCursesON[0] && lynx_nsl_status == -29998 )
      break;
    if ( *EndS )
      v27 = EndS + 1;
    else
      v27 = EndS;
    for ( StartS = v27; *StartS && (*StartS <= 0x20u || *StartS == 44); ++StartS )
      ;
    for ( EndS = StartS; *EndS && *EndS > 0x20u && *EndS != 44; ++EndS )
      ;
    LYstrncpy(DomainSuffix, StartS, EndS - StartS);
LABEL_108:
    if ( GotHost || !*DomainSuffix )
    {
      if ( !GotHost )
      {
        if ( *EndP )
          v28 = EndP + 1;
        else
          v28 = EndP;
        for ( StartP = v28; *StartP && (*StartP <= 0x20u || *StartP == 44); ++StartP )
          ;
        for ( EndP = StartP; *EndP && *EndP > 0x20u && *EndP != 44; ++EndP )
          ;
        LYstrncpy(DomainPrefix, StartP, EndP - StartP);
      }
      if ( GotHost || !*DomainPrefix )
      {
        if ( GotHost )
        {
          if ( StrColon && !strchr(Host, 58) )
          {
            *StrColon = 58;
            HTSACat(&Host, StrColon);
          }
          if ( Path )
          {
            *Path = 47;
            HTSACat(&Host, Path);
          }
          else if ( Fragment )
          {
            HTSACat(&Host, "/");
            if ( Fragment )
              *Fragment = 35;
            HTSACat(&Host, Fragment);
          }
          HTSACopy(AllocatedString, Host);
        }
        if ( LYCursesON[0] && HTCheckForInterrupt() && WWW_TraceFlag[0] )
        {
          if ( GotHost )
            v29 = "resolved";
          else
            v29 = "timed out";
          v20 = host;
          v21 = TraceFP();
          fprintf(v21, "LYExpandHostForURL: Ignoring interrupt because '%s' %s.\n", v20, v29);
        }
        goto cleanup;
      }
      goto LABEL_59;
    }
  }
  if ( !WWW_TraceFlag[0] )
    goto cleanup;
LABEL_31:
  v10 = host;
  v11 = TraceFP();
  fprintf(v11, "LYExpandHostForURL: Interrupted while '%s' failed to resolve.\n", v10);
cleanup:
  if ( DomainPrefix )
  {
    free(DomainPrefix);
    DomainPrefix = 0;
  }
  if ( DomainSuffix )
  {
    free(DomainSuffix);
    DomainSuffix = 0;
  }
  if ( Str )
  {
    free(Str);
    Str = 0;
  }
  if ( MsgStr )
  {
    free(MsgStr);
    MsgStr = 0;
  }
  if ( Host )
  {
    free(Host);
    Host = 0;
  }
  if ( host )
  {
    free(host);
    host = 0;
  }
  return GotHost;
}

//----- (08098BB3) --------------------------------------------------------
BOOLEAN __cdecl LYAddSchemeForURL(char **AllocatedString, const char *default_scheme)
{
  char *Str; // [esp+20h] [ebp-8h] BYREF
  BOOLEAN GotScheme; // [esp+27h] [ebp-1h]

  Str = 0;
  GotScheme = 0;
  if ( !*AllocatedString || !**AllocatedString )
    return GotScheme;
  if ( strncasecomp(*AllocatedString, "www", 3) )
  {
    if ( strncasecomp(*AllocatedString, "ftp", 3) )
    {
      if ( strncasecomp(*AllocatedString, "gopher", 6) )
      {
        if ( strncasecomp(*AllocatedString, "wais", 4) )
        {
          if ( strncasecomp(*AllocatedString, "cso", 3)
            && strncasecomp(*AllocatedString, "ns.", 3)
            && strncasecomp(*AllocatedString, "ph.", 3) )
          {
            if ( strncasecomp(*AllocatedString, "finger", 6) )
            {
              if ( strncasecomp(*AllocatedString, "news", 4) )
              {
                if ( !strncasecomp(*AllocatedString, "nntp", 4) )
                {
                  HTSACopy(&Str, "nntp://");
                  GotScheme = 1;
                }
              }
              else
              {
                if ( default_scheme && (strstr(default_scheme, "news") || strstr(default_scheme, "nntp")) )
                  HTSACopy(&Str, default_scheme);
                else
                  HTSACopy(&Str, "news://");
                GotScheme = 1;
              }
            }
            else
            {
              HTSACopy(&Str, "finger://");
              GotScheme = 1;
            }
          }
          else
          {
            HTSACopy(&Str, "cso://");
            GotScheme = 1;
          }
        }
        else
        {
          HTSACopy(&Str, "wais://");
          GotScheme = 1;
        }
      }
      else
      {
        HTSACopy(&Str, "gopher://");
        GotScheme = 1;
      }
    }
    else
    {
      HTSACopy(&Str, "ftp://");
      GotScheme = 1;
    }
  }
  else
  {
    if ( default_scheme && strstr(default_scheme, "http") )
      HTSACopy(&Str, default_scheme);
    else
      HTSACopy(&Str, "http://");
    GotScheme = 1;
  }
  if ( GotScheme == 1 )
  {
    HTSACat(&Str, *AllocatedString);
    HTSACopy(AllocatedString, Str);
    if ( Str )
    {
      free(Str);
      Str = 0;
    }
    return GotScheme;
  }
  else if ( default_scheme && *default_scheme )
  {
    HTSACopy(&Str, default_scheme);
    GotScheme = 1;
    HTSACat(&Str, *AllocatedString);
    HTSACopy(AllocatedString, Str);
    if ( Str )
    {
      free(Str);
      Str = 0;
    }
    return GotScheme;
  }
  else
  {
    return GotScheme;
  }
}

//----- (08098F49) --------------------------------------------------------
void __cdecl LYTrimRelFromAbsPath(char *path)
{
  int i; // [esp+Ch] [ebp-Ch]
  char *cp; // [esp+10h] [ebp-8h]
  bool TerminalSlash; // [esp+17h] [ebp-1h]

  if ( path && *path == 47 )
  {
    TerminalSlash = path[strlen(path) - 1] == 47;
    HTSimplify(path);
    cp = path;
    while ( cp[1] == 46 )
    {
      if ( cp[2] )
      {
        if ( cp[2] == 47 )
        {
          cp += 2;
        }
        else if ( cp[2] != 46 || cp[3] )
        {
          if ( cp[2] != 46 || cp[3] != 47 )
            break;
          cp += 3;
        }
        else
        {
          cp[1] = 0;
        }
      }
      else
      {
        cp[1] = 0;
      }
    }
    if ( cp > path )
    {
      for ( i = 0; cp[i]; ++i )
        path[i] = cp[i];
      path[i] = 0;
    }
    if ( !TerminalSlash )
      LYTrimPathSep(path);
  }
}

//----- (08099062) --------------------------------------------------------
void __cdecl LYDoCSI(char *url, const char *comment, char **csi)
{
  if ( comment && !strncmp(comment, "!--#", 4u) && !strncasecomp(comment + 4, "lynxCSI", 7) )
  {
    HTSACat(csi, "\n<p align=\"center\">URL: ");
    HTSACat(csi, url);
    HTSACat(csi, "</p>\n\n");
  }
}

//----- (080990F0) --------------------------------------------------------
char *__cdecl Current_Dir(char *pathname)
{
  if ( !getcwd(pathname, 0x100u) )
    memcpy(pathname, ".", 2u);
  return pathname;
}

//----- (08099132) --------------------------------------------------------
char *__cdecl CheckDir(char *path)
{
  stat stat_info; // [esp+8h] [ebp-60h] BYREF

  if ( !LYisAbsPath(path) || HTStat(path, &stat_info) < 0 || (stat_info.st_mode & 0xF000) != 0x4000 )
    return 0;
  return path;
}

//----- (08099178) --------------------------------------------------------
char *HomeEnv()
{
  char *v0; // eax

  v0 = LYGetEnv("HOME");
  return CheckDir(v0);
}

//----- (0809919A) --------------------------------------------------------
const char *Home_Dir()
{
  __uid_t v0; // eax
  char *v1; // eax
  struct passwd *pw; // [esp+10h] [ebp-8h]
  char *cp; // [esp+14h] [ebp-4h]

  if ( !homedir_15738 )
  {
    cp = HomeEnv();
    if ( cp )
    {
      HTSACopy(&HomeDir, cp);
    }
    else
    {
      v0 = geteuid();
      pw = getpwuid(v0);
      if ( pw && pw->pw_dir )
        HTSACopy(&HomeDir, pw->pw_dir);
      else
        HTSACopy(&HomeDir, "/tmp");
    }
    homedir_15738 = HomeDir;
  }
  if ( !homedir_15738 )
  {
    v1 = gettext("Cannot find HOME directory");
    puts(v1);
    exit_immediately(1);
  }
  return homedir_15738;
}

//----- (08099259) --------------------------------------------------------
char *__cdecl LYPathLeaf(char *pathname)
{
  char *leaf; // [esp+24h] [ebp-4h]

  leaf = strrchr(pathname, 47);
  if ( leaf )
    ++leaf;
  if ( leaf )
    return leaf;
  else
    return pathname;
}

//----- (08099298) --------------------------------------------------------
BOOLEAN __cdecl LYPathOffHomeOK(char *fbuffer, size_t fbuffer_size)
{
  char *cp1; // [esp+1Ch] [ebp-Ch]
  char *cp; // [esp+20h] [ebp-8h]
  char *file; // [esp+24h] [ebp-4h] BYREF

  file = 0;
  if ( !fbuffer || fbuffer_size <= 1 || !*fbuffer )
    return 0;
  HTSACopy(&file, fbuffer);
  cp = file;
  if ( *file != 126 )
    goto LABEL_26;
  if ( file[1] == 47 )
  {
    if ( file[2] )
    {
      if ( strchr(file + 2, 47) )
        *cp = 46;
      else
        cp += 2;
      goto LABEL_26;
    }
    if ( file )
    {
      free(file);
      file = 0;
    }
    return 0;
  }
  else if ( file[1] && (cp1 = strchr(file + 1, 47)) != 0 )
  {
    cp = cp1 - 1;
    if ( cp1[1] )
    {
      if ( strchr(cp + 2, 47) )
        *cp = 46;
      else
        cp += 2;
LABEL_26:
      if ( is_url(cp) || *cp == 47 )
      {
        if ( file )
        {
          free(file);
          file = 0;
        }
        return 0;
      }
      else
      {
        HTSimplify(cp);
        if ( !strncmp(cp, "./", 2u) && !strchr(cp + 2, 47) )
          cp += 2;
        if ( !*cp || *cp == 47 || cp[strlen(cp) - 1] == 47 || strstr(cp, "..") || !strcmp(cp, ".") )
        {
          if ( file )
          {
            free(file);
            file = 0;
          }
          return 0;
        }
        else
        {
          if ( fbuffer_size <= 3 || !strncmp(cp, "./", 2u) || !strchr(cp, 47) )
          {
            if ( strlen(cp) > fbuffer_size - 1 )
              cp[fbuffer_size - 1] = 0;
            strcpy(fbuffer, cp);
          }
          else
          {
            memcpy(fbuffer, "./", 3u);
            if ( strlen(cp) > fbuffer_size - 3 )
              cp[fbuffer_size - 3] = 0;
            strcat(fbuffer, cp);
          }
          if ( file )
          {
            free(file);
            file = 0;
          }
          return 1;
        }
      }
    }
    if ( file )
    {
      free(file);
      file = 0;
    }
    return 0;
  }
  else
  {
    if ( file )
    {
      free(file);
      file = 0;
    }
    return 0;
  }
}

//----- (080995FE) --------------------------------------------------------
char *__cdecl FindLeadingTilde(char *pathname, BOOLEAN embedded)
{
  char *result; // [esp+10h] [ebp-4h]

  result = pathname;
  if ( pathname )
  {
    if ( embedded )
    {
      while ( *pathname )
      {
        if ( *pathname == 47 && pathname[1] == 126 )
        {
          ++pathname;
          break;
        }
        ++pathname;
      }
    }
    if ( *pathname == 126 )
      return pathname;
  }
  return result;
}

//----- (0809965E) --------------------------------------------------------
char *__cdecl LYAbsOrHomePath(char **fname)
{
  char temp[256]; // [esp+24h] [ebp-104h] BYREF
  unsigned int v3; // [esp+124h] [ebp-4h]

  v3 = __readgsdword(0x14u);
  if ( !LYisAbsPath(*fname) )
  {
    if ( **fname == 126 )
    {
      LYTildeExpand(fname, 0);
    }
    else
    {
      LYAddPathToHome(temp, 0x100u, *fname);
      HTSACopy(fname, temp);
    }
  }
  return *fname;
}

//----- (0809970B) --------------------------------------------------------
char *__cdecl LYTildeExpand(char **pathname, BOOLEAN embedded)
{
  char *v2; // ebx
  FILE *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  char *v6; // ebx
  FILE *v7; // eax
  const char *v9; // [esp+4h] [ebp-24h]
  const char *v10; // [esp+4h] [ebp-24h]
  char *second; // [esp+18h] [ebp-10h] BYREF
  char *first; // [esp+1Ch] [ebp-Ch] BYREF
  char *temp; // [esp+20h] [ebp-8h]

  temp = FindLeadingTilde(*pathname, embedded);
  if ( *temp == 126 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = *pathname;
      v3 = TraceFP();
      fprintf(v3, "LYTildeExpand %s\n", v2);
    }
    if ( temp[1] == 47 )
    {
      first = 0;
      second = 0;
      HTSACopy(&first, *pathname);
      first[temp - *pathname] = 0;
      HTSACopy(&second, temp + 2);
      HTSACopy(pathname, first);
      v4 = Home_Dir();
      v9 = wwwName(v4);
      HTSACat(pathname, v9);
      LYAddPathSep(pathname);
      HTSACat(pathname, second);
      if ( first )
      {
        free(first);
        first = 0;
      }
      if ( second )
      {
        free(second);
        second = 0;
      }
    }
    else if ( !temp[1] )
    {
      v5 = Home_Dir();
      v10 = wwwName(v5);
      HTSACopy(pathname, v10);
    }
    if ( WWW_TraceFlag[0] )
    {
      v6 = *pathname;
      v7 = TraceFP();
      fprintf(v7, "expanded path %s\n", v6);
    }
  }
  return *pathname;
}

//----- (080998A6) --------------------------------------------------------
void __cdecl LYAddPathToHome(char *fbuffer, size_t fbuffer_size, const char *fname)
{
  const char *v3; // eax
  const char *v4; // [esp+14h] [ebp-14h]
  int len; // [esp+1Ch] [ebp-Ch]
  const char *file; // [esp+20h] [ebp-8h]
  char *home; // [esp+24h] [ebp-4h] BYREF

  home = 0;
  file = fname;
  if ( fbuffer )
  {
    if ( fbuffer_size <= 1 )
    {
      *fbuffer = 0;
      return;
    }
    fbuffer[fbuffer_size - 1] = 0;
    if ( !fname )
      file = byte_8156400;
    v3 = Home_Dir();
    HTSACopy(&home, v3);
    if ( !home || !*home )
      HTSACopy(&home, "/error");
    len = fbuffer_size + ~strlen(home);
    if ( len <= 0 )
    {
      LYstrncpy(fbuffer, home, fbuffer_size - 1);
      if ( !home )
        return;
      goto LABEL_16;
    }
    if ( !strncmp(file, "./", 2u) )
      v4 = file + 2;
    else
      v4 = file;
    sprintf(fbuffer, "%s/%.*s", home, len, v4);
    if ( home )
LABEL_16:
      free(home);
  }
}

//----- (080999EC) --------------------------------------------------------
char *__cdecl LYAddPathToSave(char *fname)
{
  char *result; // [esp+20h] [ebp-108h] BYREF
  char temp[256]; // [esp+24h] [ebp-104h] BYREF
  unsigned int v4; // [esp+124h] [ebp-4h]

  v4 = __readgsdword(0x14u);
  result = 0;
  if ( LYisAbsPath(fname) )
  {
    HTSACopy(&result, fname);
  }
  else if ( lynx_save_space )
  {
    HTSACopy(&result, lynx_save_space);
  }
  else
  {
    LYAddPathToHome(temp, 0x100u, fname);
    HTSACopy(&result, temp);
  }
  return result;
}

//----- (08099AB2) --------------------------------------------------------
BOOLEAN __cdecl IsOurSymlink(const char *name)
{
  FILE *v1; // edx
  char *clone; // [esp+20h] [ebp-18h] BYREF
  char *cutoff; // [esp+24h] [ebp-14h]
  char *buffer; // [esp+28h] [ebp-10h]
  int used; // [esp+2Ch] [ebp-Ch]
  int size; // [esp+30h] [ebp-8h]
  BOOLEAN result; // [esp+37h] [ebp-1h]

  result = 0;
  size = 256;
  buffer = (char *)malloc(0x100u);
  if ( buffer )
  {
    do
    {
      used = readlink(name, buffer, size - 1);
      if ( used != size - 1 )
        break;
      size *= 2;
      buffer = (char *)realloc(buffer, size);
    }
    while ( buffer );
    if ( used <= 0 )
    {
      if ( buffer )
      {
        free(buffer);
        buffer = 0;
      }
    }
    else
    {
      buffer[used] = 0;
    }
  }
  if ( buffer )
  {
    if ( !LYisAbsPath(buffer) )
    {
      cutoff = LYLastPathSep(name);
      clone = 0;
      if ( cutoff )
      {
        HTSprintf0(&clone, "%.*s%s%s", cutoff - name, name, "/", buffer);
        if ( buffer )
        {
          free(buffer);
          buffer = 0;
        }
        buffer = clone;
      }
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v1 = TraceFP();
      fprintf(v1, "IsOurSymlink(%s -> %s)\n", name, buffer);
    }
    result = IsOurFile(buffer);
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
  }
  return result;
}

//----- (08099C3B) --------------------------------------------------------
BOOLEAN __cdecl IsOurFile(const char *name)
{
  __uid_t st_uid; // ebx
  int v2; // ebx
  FILE *v3; // edx
  char *v5; // [esp+10h] [ebp-78h]
  stat data; // [esp+14h] [ebp-74h] BYREF
  char *leaf; // [esp+74h] [ebp-14h]
  char *path; // [esp+78h] [ebp-10h] BYREF
  int linked; // [esp+7Ch] [ebp-Ch]
  BOOLEAN result; // [esp+83h] [ebp-5h]

  result = 0;
  if ( *name != 126 && !lstat64((int)name, (int)&data) )
  {
    if ( (data.st_mode & 0xF000) == 0x8000
      && (data.st_mode & 0x12) == 0
      && data.st_nlink == 1
      && (st_uid = data.st_uid, st_uid == getuid())
      || (data.st_mode & 0xF000) == 40960 && IsOurSymlink(name) )
    {
      linked = 0;
      path = 0;
      HTSACopy(&path, name);
      do
      {
        leaf = LYPathLeaf(path);
        if ( leaf != path )
          *--leaf = 0;
        v5 = *path ? path : "/";
        if ( lstat64((int)v5, (int)&data) )
          break;
        if ( (data.st_mode & 0xF000) == 40960 )
        {
          linked = 1;
        }
        else if ( (data.st_mode & 0xF000) == 0x4000 )
        {
          if ( linked )
          {
            linked = 0;
            if ( data.st_uid || (data.st_mode & 2) != 0 )
            {
              linked = 1;
              break;
            }
          }
        }
        else if ( linked )
        {
          break;
        }
      }
      while ( leaf != path );
      if ( path )
      {
        free(path);
        path = 0;
      }
      result = linked == 0;
    }
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v2 = result;
    v3 = TraceFP();
    fprintf(v3, "IsOurFile(%s) %d\n", name, v2);
  }
  return result;
}

//----- (08099E02) --------------------------------------------------------
FILE *__cdecl OpenHiddenFile(const char *name, const char *mode)
{
  char *v3; // [esp+14h] [ebp-74h]
  stat data; // [esp+18h] [ebp-70h] BYREF
  mode_t save; // [esp+78h] [ebp-10h]
  int fd; // [esp+7Ch] [ebp-Ch]
  FILE *fp; // [esp+80h] [ebp-8h]
  BOOLEAN binary; // [esp+87h] [ebp-1h]

  fp = 0;
  binary = strchr(mode, 98) != 0;
  if ( *mode == 119 )
  {
    fd = open64(name, 193);
    if ( fd < 0 && *__errno_location() == 17 && IsOurFile(name) )
    {
      remove(name);
      fd = open64(name, 193);
    }
    if ( fd >= 0 )
      return fdopen(fd, mode);
  }
  else if ( *mode == 97 )
  {
    if ( !IsOurFile(name) || chmod(name, 0x180u) )
    {
      if ( lstat64((int)name, (int)&data) )
      {
        if ( binary )
          v3 = "wb";
        else
          v3 = "w";
        return OpenHiddenFile(name, v3);
      }
    }
    else
    {
      return (FILE *)fopen64(name, mode);
    }
  }
  else
  {
    save = umask(0x3Fu);
    if ( !chmod(name, 0x180u) || *__errno_location() == 2 )
      fp = (FILE *)fopen64(name, mode);
    umask(save);
  }
  return fp;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08099FBD) --------------------------------------------------------
FILE *__cdecl LYNewBinFile(const char *name)
{
  return OpenHiddenFile(name, "wb");
}

//----- (08099FDE) --------------------------------------------------------
FILE *__cdecl LYNewTxtFile(const char *name)
{
  return OpenHiddenFile(name, "w");
}

//----- (08099FFF) --------------------------------------------------------
FILE *__cdecl LYAppendToTxtFile(const char *name)
{
  return OpenHiddenFile(name, "a+");
}

//----- (0809A020) --------------------------------------------------------
void __cdecl LYRelaxFilePermissions(const char *name)
{
  stat stat_buf; // [esp+10h] [ebp-68h] BYREF
  mode_t save; // [esp+70h] [ebp-8h]
  mode_t mode; // [esp+74h] [ebp-4h]

  if ( !stat64((int)name, (int)&stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )
  {
    mode = stat_buf.st_mode & 0x1FF;
    if ( mode == 384 )
    {
      save = umask(0x3Fu);
      mode = (mode & 0x1C0 | 0x36) & ~save;
      umask(save);
      chmod(name, mode);
    }
  }
}

//----- (0809A0A4) --------------------------------------------------------
BOOLEAN __cdecl LYCachedTemp(char *result, char **cached)
{
  if ( !*cached )
    return 0;
  LYstrncpy(result, *cached, 256);
  if ( *cached )
  {
    free(*cached);
    *cached = 0;
  }
  if ( LYCanReadFile(result) )
    remove(result);
  return 1;
}

//----- (0809A118) --------------------------------------------------------
FILE *__cdecl LYOpenTemp(char *result, const char *suffix, const char *mode)
{
  FILE *v3; // edx
  FILE *v4; // eax
  __uid_t st_uid; // ebx
  int v6; // edi
  __uid_t v7; // ebx
  const char *v8; // esi
  FILE *v9; // eax
  const char *v10; // ebx
  FILE *v11; // eax
  int *v12; // eax
  char *v13; // eax
  const char *v14; // ebx
  FILE *v15; // eax
  int *v16; // eax
  char *v17; // ebx
  FILE *v18; // edx
  FILE *v19; // eax
  int v22; // [esp+24h] [ebp-84h]
  stat sb; // [esp+2Ch] [ebp-7Ch] BYREF
  int old_mask; // [esp+8Ch] [ebp-1Ch]
  LY_TEMP *p; // [esp+90h] [ebp-18h]
  FILE *fp; // [esp+94h] [ebp-14h]
  BOOLEAN make_it; // [esp+99h] [ebp-Fh]
  char wrt; // [esp+9Ah] [ebp-Eh]
  BOOLEAN txt; // [esp+9Bh] [ebp-Dh]

  fp = 0;
  txt = 1;
  wrt = 114;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "LYOpenTemp(,%s,%s)\n", suffix, mode);
  }
  if ( !result )
    return 0;
  while ( *mode )
  {
    v22 = *mode++;
    switch ( v22 )
    {
      case 'b':
        txt = 0;
        break;
      case 'w':
        wrt = 119;
        break;
      case 'a':
        wrt = 97;
        break;
      default:
        if ( WWW_TraceFlag[0] )
        {
          v4 = TraceFP();
          fprintf(v4, "%s @%d: BUG\n", "./LYUtils.c", 5954);
        }
        return 0;
    }
  }
  if ( !lynx_temp_subspace )
  {
    make_it = 0;
    if ( lstat64((int)lynx_temp_space, (int)&sb) || (sb.st_mode & 0xF000) != 0x4000 )
    {
      make_it = 1;
      if ( WWW_TraceFlag[0] )
      {
        v10 = lynx_temp_space;
        v11 = TraceFP();
        fprintf(v11, "lynx_temp_space is not a directory %s\n", v10);
      }
    }
    else
    {
      st_uid = sb.st_uid;
      if ( st_uid != getuid() || (sb.st_mode & 0x12) != 0 )
      {
        make_it = 1;
        if ( WWW_TraceFlag[0] )
        {
          v6 = sb.st_mode & 0x1FF;
          v7 = sb.st_uid;
          v8 = lynx_temp_space;
          v9 = TraceFP();
          fprintf(v9, "lynx_temp_space is not our directory %s owner %d mode %03o\n", v8, v7, v6);
        }
      }
    }
    if ( make_it )
    {
      old_mask = umask(0x3Fu);
      HTSACat(&lynx_temp_space, "lynxXXXXXXXXXX");
      if ( !mkdtemp(lynx_temp_space) )
      {
        v12 = __errno_location();
        v13 = strerror(*v12);
        printf("%s: %s\n", lynx_temp_space, v13);
        exit_immediately(1);
      }
      umask(old_mask);
      lynx_temp_subspace = 1;
      HTSACat(&lynx_temp_space, "/");
      if ( WWW_TraceFlag[0] )
      {
        v14 = lynx_temp_space;
        v15 = TraceFP();
        fprintf(v15, "made subdirectory %s\n", v14);
      }
    }
    else
    {
      lynx_temp_subspace = -1;
    }
  }
  do
  {
    if ( !fmt_tempname(result, lynx_temp_space, suffix) )
      return 0;
    if ( txt )
    {
      if ( wrt == 97 )
      {
        fp = LYAppendToTxtFile(result);
      }
      else if ( wrt == 119 )
      {
        fp = LYNewTxtFile(result);
      }
    }
    else
    {
      fp = LYNewBinFile(result);
    }
    if ( !fp && *__errno_location() != 17 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v16 = __errno_location();
        v17 = strerror(*v16);
        v18 = TraceFP();
        fprintf(v18, "... LYOpenTemp(%s) failed: %s\n", result, v17);
      }
      return 0;
    }
  }
  while ( !fp );
  p = (LY_TEMP *)calloc(1u, 0x10u);
  if ( !p )
    outofmem("./LYUtils.c", "LYOpenTemp");
  p->next = ly_temp;
  HTSACopy(&p->name, result);
  p->file = fp;
  p->outs = wrt != 114;
  ly_temp = p;
  if ( WWW_TraceFlag[0] )
  {
    v19 = TraceFP();
    fprintf(v19, "... LYOpenTemp(%s)\n", result);
  }
  return fp;
}

//----- (0809A540) --------------------------------------------------------
FILE *__cdecl LYReopenTemp(char *name)
{
  FILE *fp; // [esp+10h] [ebp-8h]
  LY_TEMP *p; // [esp+14h] [ebp-4h]

  fp = 0;
  LYCloseTemp(name);
  p = FindTempfileByName(name);
  if ( p )
  {
    p->file = LYAppendToTxtFile(name);
    return p->file;
  }
  return fp;
}

//----- (0809A58D) --------------------------------------------------------
FILE *__cdecl LYOpenTempRewrite(char *fname, const char *suffix, const char *mode)
{
  FILE *v3; // edx
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  int *v7; // eax
  char *v8; // ebx
  FILE *v9; // edx
  FILE *v10; // eax
  const char *v13; // [esp+1Ch] [ebp-8Ch]
  const char *v14; // [esp+20h] [ebp-88h]
  const char *v15; // [esp+24h] [ebp-84h]
  int v16; // [esp+28h] [ebp-80h]
  const char *v17; // [esp+30h] [ebp-78h]
  stat stat_buf; // [esp+34h] [ebp-74h] BYREF
  LY_TEMP *p; // [esp+94h] [ebp-14h]
  FILE *fp; // [esp+98h] [ebp-10h]
  BOOLEAN still_open; // [esp+9Eh] [ebp-Ah]
  BOOLEAN is_ours; // [esp+9Fh] [ebp-9h]
  BOOLEAN writable_exists; // [esp+A0h] [ebp-8h]
  BOOLEAN registered; // [esp+A1h] [ebp-7h]
  char wrt; // [esp+A2h] [ebp-6h]
  BOOLEAN txt; // [esp+A3h] [ebp-5h]

  fp = 0;
  txt = 1;
  wrt = 114;
  registered = 0;
  writable_exists = 0;
  is_ours = 0;
  still_open = 0;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "LYOpenTempRewrite(%s,%s,%s)\n", fname, suffix, mode);
  }
  if ( !*fname )
    return LYOpenTemp(fname, suffix, mode);
  p = FindTempfileByName(fname);
  if ( p )
  {
    registered = 1;
    if ( p->file )
      still_open = 1;
    if ( WWW_TraceFlag[0] )
    {
      if ( still_open )
        v13 = ", still open!";
      else
        v13 = ".";
      v4 = TraceFP();
      fprintf(v4, "...used before%s\n", v13);
    }
  }
  if ( registered )
  {
    writable_exists = HTEditable(fname);
    if ( writable_exists )
      is_ours = IsOurFile(fname);
    if ( WWW_TraceFlag[0] )
    {
      if ( is_ours )
        v14 = "is our file.";
      else
        v14 = "is NOT our file.";
      if ( writable_exists )
        v15 = "exists and is writable, ";
      else
        v15 = byte_8156400;
      v5 = TraceFP();
      fprintf(v5, "...%s%s\n", v15, v14);
    }
  }
  if ( still_open || !registered || writable_exists && !is_ours )
    return LYOpenTemp(fname, suffix, mode);
  if ( !is_ours && !lstat64((int)fname, (int)&stat_buf) )
    return LYOpenTemp(fname, suffix, mode);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !*mode )
        {
          if ( is_ours )
          {
            if ( txt == 1 )
            {
              if ( !truncate64(fname, 0, 0) )
                return LYReopenTemp(fname);
              if ( WWW_TraceFlag[0] )
              {
                v7 = __errno_location();
                v8 = strerror(*v7);
                v9 = TraceFP();
                fprintf(v9, "... truncate(%s,0) failed: %s\n", fname, v8);
              }
              return LYOpenTemp(fname, suffix, mode);
            }
            remove(fname);
          }
          if ( txt )
          {
            if ( wrt == 97 )
            {
              fp = LYAppendToTxtFile(fname);
            }
            else if ( wrt == 119 )
            {
              fp = LYNewTxtFile(fname);
            }
          }
          else
          {
            fp = LYNewBinFile(fname);
          }
          p->file = fp;
          if ( WWW_TraceFlag[0] )
          {
            if ( fp )
              v17 = "ok";
            else
              v17 = "failed";
            v10 = TraceFP();
            fprintf(v10, "... LYOpenTempRewrite(%s), %s\n", fname, v17);
          }
          return fp;
        }
        v16 = *mode++;
        if ( v16 != 98 )
          break;
        txt = 0;
      }
      if ( v16 != 119 )
        break;
      wrt = 119;
    }
    if ( v16 != 97 )
      break;
    wrt = 97;
  }
  if ( WWW_TraceFlag[0] )
  {
    v6 = TraceFP();
    fprintf(v6, "%s @%d: BUG\n", "./LYUtils.c", 6157);
  }
  return fp;
}
// 804ACF4: using guessed type int __cdecl truncate64(_DWORD, _DWORD, _DWORD);

//----- (0809A9D7) --------------------------------------------------------
FILE *__cdecl LYOpenScratch(char *result, const char *prefix)
{
  FILE *v2; // eax
  LY_TEMP *p; // [esp+20h] [ebp-8h]
  FILE *fp; // [esp+24h] [ebp-4h]

  if ( !fmt_tempname(result, prefix, ".html") )
    return 0;
  fp = LYNewTxtFile(result);
  if ( fp )
  {
    p = (LY_TEMP *)calloc(1u, 0x10u);
    if ( !p )
      outofmem("./LYUtils.c", "LYOpenScratch");
    p->next = ly_temp;
    HTSACopy(&p->name, result);
    p->file = fp;
    ly_temp = p;
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "LYOpenScratch(%s)\n", result);
  }
  return fp;
}

//----- (0809AAB3) --------------------------------------------------------
void __cdecl LY_close_temp(LY_TEMP *p)
{
  if ( p->file )
  {
    if ( p->outs )
      LYCloseOutput(p->file);
    else
      LYCloseInput(p->file);
    p->file = 0;
  }
}

//----- (0809AAF8) --------------------------------------------------------
void __cdecl LYCloseTemp(char *name)
{
  FILE *v1; // eax
  FILE *v2; // eax
  const char *v3; // [esp+14h] [ebp-14h]
  LY_TEMP *p; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "LYCloseTemp(%s)\n", name);
  }
  p = FindTempfileByName(name);
  if ( p )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( p->file )
        v3 = ", closed";
      else
        v3 = byte_8156400;
      v2 = TraceFP();
      fprintf(v2, "...LYCloseTemp(%s)%s\n", name, v3);
    }
    LY_close_temp(p);
  }
}

//----- (0809AB92) --------------------------------------------------------
void __cdecl LYCloseTempFP(FILE *fp)
{
  FILE *v1; // eax
  const char *name; // ebx
  FILE *v3; // eax
  LY_TEMP *p; // [esp+20h] [ebp-8h]

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "LYCloseTempFP\n");
  }
  p = FindTempfileByFP(fp);
  if ( p )
  {
    LY_close_temp(p);
    if ( WWW_TraceFlag[0] )
    {
      name = p->name;
      v3 = TraceFP();
      fprintf(v3, "...LYCloseTempFP(%s)\n", name);
    }
  }
}

//----- (0809AC0C) --------------------------------------------------------
int __cdecl LYRemoveTemp(char *name)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  const char *v5; // [esp+14h] [ebp-14h]
  int code; // [esp+1Ch] [ebp-Ch]
  LY_TEMP *q; // [esp+20h] [ebp-8h]
  LY_TEMP *p; // [esp+24h] [ebp-4h]

  code = -1;
  if ( name && *name )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "LYRemoveTemp(%s)\n", name);
    }
    p = ly_temp;
    q = 0;
    while ( p )
    {
      if ( !strcmp(name, p->name) )
      {
        if ( q )
          q->next = p->next;
        else
          ly_temp = p->next;
        LY_close_temp(p);
        code = remove(name);
        if ( WWW_TraceFlag[0] )
        {
          if ( p->file )
            v5 = ", closed";
          else
            v5 = byte_8156400;
          v2 = TraceFP();
          fprintf(v2, "...LYRemoveTemp done(%d)%s\n", code, v5);
        }
        if ( WWW_TraceFlag[0] )
        {
          v3 = TraceFP();
          fflush(v3);
        }
        if ( p->name )
        {
          free(p->name);
          p->name = 0;
        }
        free(p);
        return code;
      }
      q = p;
      p = p->next;
    }
  }
  return code;
}
// 809AD48: conditional instruction was optimized away because %p.4!=0

//----- (0809AD7B) --------------------------------------------------------
void LYCleanupTemp()
{
  FILE *v0; // eax
  char result[256]; // [esp+24h] [ebp-104h] BYREF
  unsigned int v2; // [esp+124h] [ebp-4h]

  v2 = __readgsdword(0x14u);
  while ( ly_temp )
    LYRemoveTemp(ly_temp->name);
  if ( lynx_temp_subspace > 0 )
  {
    LYstrncpy(result, lynx_temp_space, 255);
    LYTrimPathSep(result);
    if ( WWW_TraceFlag[0] )
    {
      v0 = TraceFP();
      fprintf(v0, "LYCleanupTemp removing %s\n", result);
    }
    rmdir(result);
    lynx_temp_subspace = -1;
  }
}

//----- (0809AE37) --------------------------------------------------------
void __cdecl LYRenamedTemp(char *oldname, char *newname)
{
  FILE *v2; // edx
  LY_TEMP *p; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "LYRenamedTemp(old=%s, new=%s)\n", oldname, newname);
  }
  p = FindTempfileByName(oldname);
  if ( p )
    HTSACopy(&p->name, newname);
}

//----- (0809AE9A) --------------------------------------------------------
void LYCheckBibHost()
{
  DocAddress bibhostIcon; // [esp+10h] [ebp-18h] BYREF
  BOOLEAN saveFlag; // [esp+27h] [ebp-1h]

  bibhostIcon.address = 0;
  HTSACopy(&bibhostIcon.address, BibP_bibhost);
  HTSACat(&bibhostIcon.address, "bibp1.0/bibpicon.jpg");
  memset(&bibhostIcon.post_data, 0, 14);
  saveFlag = traversal;
  traversal = 1;
  BibP_bibhost_available = HTLoadAbsolute(&bibhostIcon) == 1;
  traversal = saveFlag;
  BibP_bibhost_checked = 1;
}

//----- (0809AF23) --------------------------------------------------------
BOOLEAN __cdecl LYIsUIPage3(const char *url, UIP_t type, int flagparam)
{
  bool v5; // [esp+17h] [ebp-21h]
  bool v6; // [esp+18h] [ebp-20h]
  bool v7; // [esp+1Fh] [ebp-19h]
  bool v8; // [esp+20h] [ebp-18h]
  const char *object; // [esp+24h] [ebp-14h]
  HTList *l0; // [esp+28h] [ebp-10h]
  size_t l; // [esp+30h] [ebp-8h]
  size_t la; // [esp+30h] [ebp-8h]
  unsigned int i; // [esp+34h] [ebp-4h]

  if ( !url )
    return 0;
  for ( i = 0; ; ++i )
  {
    if ( i > 0xC )
      return 0;
    if ( ly_uip[i].type == type )
      break;
  }
  if ( !ly_uip[i].url )
    return 0;
  if ( (flagparam & 1) != 0 )
  {
    l = strlen(ly_uip[i].url);
    v6 = !strncmp(ly_uip[i].url, url, l) && (!url[l] || url[l] == 35);
    v5 = v6;
  }
  else
  {
    v5 = strcmp(ly_uip[i].url, url) == 0;
  }
  if ( v5 )
    return 1;
  if ( (ly_uip[i].flags & 1) != 0 )
  {
    l0 = ly_uip[i].alturls;
    while ( 1 )
    {
      if ( l0 && (l0 = l0->next) != 0 )
        object = (const char *)l0->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( (flagparam & 1) != 0 )
      {
        la = strlen(object);
        v8 = !strncmp(object, url, la) && (!url[la] || url[la] == 35);
        v7 = v8;
      }
      else
      {
        v7 = strcmp(object, url) == 0;
      }
      if ( v7 )
        return 1;
    }
  }
  return 0;
}

//----- (0809B164) --------------------------------------------------------
void __cdecl LYRegisterUIPage(const char *url, UIP_t type)
{
  const char *object; // [esp+10h] [ebp-18h]
  HTList *l0; // [esp+14h] [ebp-14h]
  int n; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+20h] [ebp-8h]

  for ( i = 0; i <= 0xC; ++i )
  {
    if ( ly_uip[i].type == type )
    {
      if ( !ly_uip[i].url || !url || strcmp(ly_uip[i].url, url) )
      {
        if ( ly_uip[i].url && url && (ly_uip[i].flags & 1) != 0 )
        {
          n = 0;
          l0 = ly_uip[i].alturls;
          while ( 1 )
          {
            if ( l0 && (l0 = l0->next) != 0 )
              object = (const char *)l0->object;
            else
              object = 0;
            if ( !object )
              break;
            if ( !strcmp(object, url) )
              return;
            if ( !strcmp(object, ly_uip[i].url) )
              goto LABEL_13;
            ++n;
          }
          if ( !ly_uip[i].alturls )
            ly_uip[i].alturls = HTList_new();
          if ( n >= HTCacheSize && (ly_uip[i].flags & 2) != 0 )
            HTList_removeFirstObject(ly_uip[i].alturls);
          HTList_addObject(ly_uip[i].alturls, ly_uip[i].url);
          ly_uip[i].url = 0;
          HTSACopy((char **)(20 * i + 135878696), url);
        }
        else
        {
LABEL_13:
          HTSACopy((char **)(20 * i + 135878696), url);
        }
      }
      return;
    }
  }
}

//----- (0809B3EF) --------------------------------------------------------
void LYUIPages_free()
{
  unsigned int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0xC; ++i )
  {
    if ( ly_uip[i].url )
    {
      free(ly_uip[i].url);
      ly_uip[i].url = 0;
    }
    if ( ly_uip[i].file )
    {
      free(ly_uip[i].file);
      ly_uip[i].file = 0;
    }
    LYFreeStringList(ly_uip[i].alturls);
    ly_uip[i].alturls = 0;
  }
}

//----- (0809B4D5) --------------------------------------------------------
const char *__cdecl wwwName(const char *pathname)
{
  return pathname;
}

//----- (0809B4ED) --------------------------------------------------------
BOOLEAN __cdecl LYValidateFilename(char *result, char *given)
{
  char *v2; // eax
  const char *v3; // eax
  size_t v4; // ebx
  size_t v5; // ebx
  const char *cp2; // [esp+1Ch] [ebp-Ch]
  char *cp; // [esp+20h] [ebp-8h]
  char *cpa; // [esp+20h] [ebp-8h]

  if ( !strcmp(given, "/dev/null") )
    return 0;
  if ( *given == 124 )
  {
    if ( no_shell )
    {
      v2 = gettext("Spawning is currently disabled.");
      HTUserMsg(v2);
      return 0;
    }
    else
    {
      LYstrncpy(result, given, 256);
      return 1;
    }
  }
  else
  {
    cp = FindLeadingTilde(given, 1);
    if ( cp != given )
    {
      v3 = Home_Dir();
      cp2 = wwwName(v3);
      if ( cp2 )
      {
        v4 = strlen(cp2);
        if ( v4 + strlen(given) <= 0xFF )
        {
          *cp = 0;
          strcpy(result, given);
          LYTrimPathSep(result);
          strcat(result, cp2);
          strcat(result, cp + 1);
          strcpy(given, result);
        }
      }
    }
    if ( LYisAbsPath(given) )
      cpa = 0;
    else
      cpa = Current_Dir(buf_17042);
    *result = 0;
    if ( cpa )
    {
      LYTrimPathSep(cpa);
      if ( strlen(cpa) > 0xFD )
        return 0;
      sprintf(result, "%s/", cpa);
    }
    v5 = strlen(result);
    if ( v5 + strlen(given) <= 0xFE )
    {
      strcat(result, given);
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

//----- (0809B6DE) --------------------------------------------------------
int __cdecl LYValidateOutput(char *filename)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  int c; // [esp+14h] [ebp-4h]

  if ( *filename == 124 )
    return 89;
  if ( !no_dotfiles && show_dotfiles || *LYPathLeaf(filename) != 46 )
  {
    if ( LYCanReadFile(filename) )
    {
      v2 = gettext("File exists.  Overwrite?");
      c = HTConfirm(v2);
      if ( (unsigned __int8)HTLastConfirmCancelled() )
      {
        v3 = gettext("Save request cancelled!!!");
        HTInfoMsg(v3);
        return 3;
      }
      if ( !c )
        return 78;
    }
    return 89;
  }
  v1 = gettext("File name may not begin with a dot.");
  HTAlert(v1);
  return 78;
}

//----- (0809B7A9) --------------------------------------------------------
void __cdecl LYLocalFileToURL(char **target, const char *source)
{
  const char *leaf; // [esp+20h] [ebp-108h]
  char temp[256]; // [esp+24h] [ebp-104h] BYREF
  unsigned int v4; // [esp+124h] [ebp-4h]

  v4 = __readgsdword(0x14u);
  HTSACopy(target, "file://localhost");
  leaf = wwwName(source);
  if ( !LYisAbsPath(source) )
  {
    Current_Dir(temp);
    if ( temp[0] != 47 )
      LYAddHtmlSep(target);
    HTSACat(target, temp);
  }
  if ( *leaf != 47 )
    LYAddHtmlSep(target);
  HTSACat(target, leaf);
}

//----- (0809B890) --------------------------------------------------------
FILE *__cdecl InternalPageFP(char *filename, int reuse_flag)
{
  char *v2; // eax
  FILE *fp; // [esp+24h] [ebp-4h]

  if ( LYReuseTempfiles && reuse_flag )
  {
    fp = LYOpenTempRewrite(filename, ".html", "wb");
  }
  else
  {
    LYRemoveTemp(filename);
    fp = LYOpenTemp(filename, ".html", "wb");
  }
  if ( !fp )
  {
    v2 = gettext("Can't open temporary file!");
    HTAlert(v2);
  }
  return fp;
}

//----- (0809B90F) --------------------------------------------------------
void __cdecl WriteInternalTitle(FILE *fp0, const char *Title)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // [esp+4h] [ebp-24h]
  char *Address; // [esp+24h] [ebp-4h] BYREF

  fwrite("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n", 1u, 0x40u, fp0);
  fwrite("<html>\n<head>\n", 1u, 0xEu, fp0);
  LYAddMETAcharsetToFD(fp0, -1);
  v4 = gettext("List Page");
  if ( !strcmp(Title, v4) )
  {
    v2 = HTLoadedDocumentURL();
    if ( !strchr(v2, 34) )
    {
      Address = 0;
      v3 = HTLoadedDocumentURL();
      HTSACopy(&Address, v3);
      LYEntify(&Address, 0);
      fprintf(fp0, "<base href=\"%s\">\n", Address);
      if ( Address )
      {
        free(Address);
        Address = 0;
      }
    }
  }
  fprintf(fp0, "<title>%s</title>\n</head>\n<body>\n", Title);
}

//----- (0809BA23) --------------------------------------------------------
void __cdecl BeginInternalPage(FILE *fp0, const char *Title, const char *HelpURL)
{
  const char *v3; // ebx
  char *v4; // [esp+10h] [ebp-18h]
  char *v5; // [esp+10h] [ebp-18h]

  WriteInternalTitle(fp0, Title);
  if ( !user_mode && LYwouldPush(Title, 0) && HelpURL )
  {
    v3 = helpfilepath;
    v4 = gettext(" Version ");
    fprintf(fp0, "<h1>%s (%s%s%s), <a href=\"%s%s\">help</a></h1>\n", Title, "Lynx", v4, "2.8.7dev.11", v3, HelpURL);
  }
  else
  {
    v5 = gettext(" Version ");
    fprintf(fp0, "<h1>%s (%s%s%s)</h1>\n", Title, "Lynx", v5, "2.8.7dev.11");
  }
}

//----- (0809BAF1) --------------------------------------------------------
void __cdecl EndInternalPage(FILE *fp0)
{
  fwrite("</body>\n</html>", 1u, 0xFu, fp0);
}

//----- (0809BB1C) --------------------------------------------------------
char *__cdecl trimPoundSelector(char *address)
{
  char *pound; // [esp+14h] [ebp-4h]

  pound = strchr(address, 35);
  if ( pound )
    *pound = 0;
  return pound;
}

//----- (0809BB49) --------------------------------------------------------
void __cdecl LYTrimPathSep(char *path)
{
  size_t len; // [esp+14h] [ebp-4h]

  if ( path )
  {
    len = strlen(path);
    if ( len )
    {
      if ( path[len - 1] == 47 )
        path[len - 1] = 0;
    }
  }
}

//----- (0809BB87) --------------------------------------------------------
void __cdecl LYAddPathSep(char **path)
{
  const char *temp; // [esp+10h] [ebp-8h]
  size_t len; // [esp+14h] [ebp-4h]

  if ( path )
  {
    temp = *path;
    if ( *path )
    {
      len = strlen(temp);
      if ( len )
      {
        if ( temp[len - 1] != 47 )
          HTSACat(path, "/");
      }
    }
  }
}

//----- (0809BBDA) --------------------------------------------------------
void __cdecl LYAddPathSep0(char *path)
{
  size_t len; // [esp+14h] [ebp-4h]

  if ( path )
  {
    len = strlen(path);
    if ( len )
    {
      if ( len <= 0xFD && path[len - 1] != 47 )
        strcat(path, "/");
    }
  }
}

//----- (0809BC28) --------------------------------------------------------
char *__cdecl LYLastPathSep(const char *path)
{
  return strrchr(path, 47);
}

//----- (0809BC49) --------------------------------------------------------
void __cdecl LYTrimHtmlSep(char *path)
{
  size_t len; // [esp+14h] [ebp-4h]

  if ( path )
  {
    len = strlen(path);
    if ( len )
    {
      if ( path[len - 1] == 47 )
        path[len - 1] = 0;
    }
  }
}

//----- (0809BC87) --------------------------------------------------------
void __cdecl LYAddHtmlSep(char **path)
{
  const char *temp; // [esp+10h] [ebp-8h]
  size_t len; // [esp+14h] [ebp-4h]

  if ( path )
  {
    temp = *path;
    if ( *path )
    {
      len = strlen(temp);
      if ( len )
      {
        if ( temp[len - 1] != 47 )
          HTSACat(path, "/");
      }
    }
  }
}

//----- (0809BCDA) --------------------------------------------------------
void __cdecl LYAddHtmlSep0(char *path)
{
  size_t len; // [esp+14h] [ebp-4h]

  if ( path )
  {
    len = strlen(path);
    if ( len )
    {
      if ( len <= 0xFD && path[len - 1] != 47 )
        strcat(path, "/");
    }
  }
}

//----- (0809BD28) --------------------------------------------------------
int __cdecl LYCopyFile(char *src, char *dst)
{
  char *v2; // ebx
  FILE *v3; // eax
  char *v4; // eax
  int len; // [esp+28h] [ebp-2020h]
  FILE *fout; // [esp+2Ch] [ebp-201Ch]
  FILE *fin; // [esp+30h] [ebp-2018h]
  char *the_command; // [esp+34h] [ebp-2014h] BYREF
  const char *program; // [esp+38h] [ebp-2010h]
  int code; // [esp+3Ch] [ebp-200Ch]
  unsigned __int8 buff[8192]; // [esp+40h] [ebp-2008h] BYREF
  unsigned int v13; // [esp+2040h] [ebp-8h]

  v13 = __readgsdword(0x14u);
  program = HTGetProgramPath(ppCOPY_0);
  if ( program )
  {
    the_command = 0;
    HTAddParam(&the_command, "%s %s %s", 1, program);
    HTAddParam(&the_command, "%s %s %s", 2, src);
    HTAddParam(&the_command, "%s %s %s", 3, dst);
    HTEndParam(&the_command, "%s %s %s", 3);
    if ( WWW_TraceFlag[0] )
    {
      v2 = the_command;
      v3 = TraceFP();
      fprintf(v3, "command: %s\n", v2);
    }
    stop_curses();
    code = LYSystem(the_command);
    start_curses();
    if ( the_command )
    {
      free(the_command);
      the_command = 0;
    }
  }
  else
  {
    code = -1;
    fin = (FILE *)fopen64(src, "rb");
    if ( fin )
    {
      fout = (FILE *)fopen64(dst, "wb");
      if ( fout )
      {
        code = 0;
        while ( 1 )
        {
          len = fread(buff, 1u, 0x2000u, fin);
          if ( len <= 0 )
            break;
          fwrite(buff, 1u, len, fout);
          if ( ferror(fout) )
          {
            code = -1;
            break;
          }
        }
        LYCloseOutput(fout);
      }
      LYCloseInput(fin);
    }
  }
  if ( code )
  {
    v4 = gettext("Cannot write to file.");
    HTAlert(v4);
  }
  return code;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0809BFC3) --------------------------------------------------------
int __cdecl LYSystem(char *command)
{
  FILE *v1; // eax
  FILE *v2; // eax
  sigaction saved_sigtstp_act; // [esp+1Ch] [ebp-9Ch] BYREF
  int saved_errno; // [esp+A8h] [ebp-10h]
  int do_free; // [esp+ACh] [ebp-Ch]
  int code; // [esp+B0h] [ebp-8h]
  BOOLEAN sigtstp_saved; // [esp+B7h] [ebp-1h]

  do_free = 0;
  sigtstp_saved = 0;
  saved_errno = 0;
  fflush(stdout);
  fflush(stderr);
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "LYSystem(%s)\n", command);
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fflush(v2);
  }
  if ( restore_sigpipe_for_children[0] )
    signal(13, 0);
  if ( !dump_output_immediately && !LYCursesON[0] && !no_suspend )
    sigtstp_saved = LYToggleSigDfl(20, &saved_sigtstp_act, 1);
  code = system(command);
  saved_errno = *__errno_location();
  if ( sigtstp_saved )
    LYToggleSigDfl(20, &saved_sigtstp_act, 0);
  if ( restore_sigpipe_for_children[0] )
    signal(13, (__sighandler_t)1);
  fflush(stdout);
  fflush(stderr);
  if ( do_free && command )
    free(command);
  *__errno_location() = saved_errno;
  return code;
}

//----- (0809C13E) --------------------------------------------------------
const char *LYSysShell()
{
  return "exec $SHELL";
}

//----- (0809C157) --------------------------------------------------------
char *LYgetXDisplay()
{
  return LYGetEnv("DISPLAY");
}

//----- (0809C16B) --------------------------------------------------------
void __cdecl LYsetXDisplay(char *new_display)
{
  char *new_displaya; // [esp+20h] [ebp+8h]

  if ( new_display )
  {
    HTSprintf0(&display_putenv_command_17405, "DISPLAY=%s", new_display);
    putenv(display_putenv_command_17405);
    new_displaya = LYgetXDisplay();
    if ( new_displaya )
      HTSACopy(&x_display, new_displaya);
  }
}

//----- (0809C1C2) --------------------------------------------------------
void get_clip_release()
{
  if ( paste_handle )
    pclose(paste_handle);
  if ( paste_buf )
  {
    free(paste_buf);
    paste_buf = 0;
  }
}

//----- (0809C209) --------------------------------------------------------
_BOOL4 clip_grab()
{
  const char *cmd; // [esp+24h] [ebp-4h]

  cmd = LYGetEnv("RL_PASTE_CMD");
  if ( paste_handle )
    pclose(paste_handle);
  if ( !cmd )
    return 0;
  paste_handle = popen(cmd, "r");
  return paste_handle != 0;
}

//----- (0809C279) --------------------------------------------------------
char *get_clip_grab()
{
  int off; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  int len; // [esp+24h] [ebp-4h]

  size = 1008;
  off = 0;
  if ( !clip_grab() )
    return 0;
  if ( !paste_handle )
    return 0;
  if ( paste_buf )
  {
    free(paste_buf);
    paste_buf = 0;
  }
  paste_buf = (char *)malloc(0x3F0u);
  while ( 1 )
  {
    len = fread(&paste_buf[off], 1u, 0x3EFu, paste_handle);
    paste_buf[len + off] = 0;
    if ( len <= 1006 || strchr(&paste_buf[off], 13) || strchr(&paste_buf[off], 10) )
      break;
    size += 1007;
    paste_buf = (char *)realloc(paste_buf, size);
    off += len;
  }
  return paste_buf;
}

//----- (0809C3B8) --------------------------------------------------------
int __cdecl put_clip(const char *s)
{
  int res; // [esp+18h] [ebp-10h]
  int l; // [esp+1Ch] [ebp-Ch]
  FILE *fh; // [esp+20h] [ebp-8h]
  const char *cmd; // [esp+24h] [ebp-4h]

  cmd = LYGetEnv("RL_CLCOPY_CMD");
  l = strlen(s);
  if ( !cmd )
    return -1;
  fh = popen(cmd, "w");
  if ( !fh )
    return -1;
  res = fwrite(s, 1u, l, fh);
  if ( !pclose(fh) && res == l )
    return 0;
  else
    return -1;
}

//----- (0809C45F) --------------------------------------------------------
void __cdecl LYmsec_delay(unsigned int msec)
{
  napms(msec);
}

//----- (0809C472) --------------------------------------------------------
void __cdecl LYOpenlog(const char *banner)
{
  FILE *v1; // eax
  const char *v2; // [esp+14h] [ebp-4h]

  if ( syslog_requested_urls )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( banner )
        v2 = banner;
      else
        v2 = "(null)";
      v1 = TraceFP();
      fprintf(v1, "LYOpenlog(%s)\n", v2);
    }
    openlog("lynx", 1, 168);
    if ( banner )
      syslog(6, "Session start:%s", banner);
    else
      syslog(6, "Session start");
  }
}

//----- (0809C51A) --------------------------------------------------------
BOOLEAN __cdecl looks_like_password(char *first, char *last)
{
  BOOLEAN result; // [esp+Fh] [ebp-1h]

  result = 0;
  while ( first <= last )
  {
    if ( *first == 47 || *first == 58 )
      return 0;
    result = 1;
    ++first;
  }
  return result;
}

//----- (0809C556) --------------------------------------------------------
void __cdecl LYSyslog(char *arg)
{
  FILE *v1; // eax
  char *v2; // ebx
  FILE *v3; // eax
  char *v4; // [esp+10h] [ebp-18h]
  char *buf; // [esp+14h] [ebp-14h] BYREF
  char *atsign; // [esp+18h] [ebp-10h]
  char *colon2; // [esp+1Ch] [ebp-Ch]
  char *colon1; // [esp+20h] [ebp-8h]

  if ( syslog_requested_urls )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "LYSyslog %s\n", arg);
    }
    if ( is_url(arg)
      && (colon1 = strchr(arg, 58)) != 0
      && !strncmp(colon1, "://", 3u)
      && (colon2 = strchr(colon1 + 3, 58)) != 0
      && (atsign = strchr(colon1, 64)) != 0
      && colon2 < atsign
      && looks_like_password(colon2 + 1, atsign - 1) )
    {
      buf = 0;
      HTSACopy(&buf, arg);
      buf[colon2 - arg + 1] = 0;
      HTSACat(&buf, "******");
      HTSACat(&buf, atsign);
      syslog(174, "%s", buf);
      if ( WWW_TraceFlag[0] )
      {
        v2 = buf;
        v3 = TraceFP();
        fprintf(v3, "...alter %s\n", v2);
      }
      if ( buf )
      {
        free(buf);
        buf = 0;
      }
    }
    else
    {
      if ( arg )
        v4 = arg;
      else
        v4 = "(null)";
      syslog(174, "%s", v4);
    }
  }
}

//----- (0809C745) --------------------------------------------------------
void LYCloselog()
{
  if ( syslog_requested_urls )
  {
    syslog(6, "Session over");
    closelog();
  }
}

//----- (0809C774) --------------------------------------------------------
_BOOL4 LYCheckUserAgent()
{
  return !LYUserAgent
      || !*LYUserAgent
      || strstr(LYUserAgent, "Lynx")
      || strstr(LYUserAgent, "lynx")
      || strstr(LYUserAgent, "L_y_n_x")
      || strstr(LYUserAgent, "l_y_n_x");
}

//----- (0809C803) --------------------------------------------------------
void validate_x_display()
{
  char *cp; // [esp+14h] [ebp-4h]

  cp = LYgetXDisplay();
  if ( cp )
  {
    HTSACopy(&x_display, cp);
  }
  else if ( x_display )
  {
    free(x_display);
    x_display = 0;
  }
}

//----- (0809C84E) --------------------------------------------------------
void __cdecl summarize_x_display(char *display_option)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax

  if ( (x_display || *display_option) && (!x_display || strcmp(x_display, display_option)) )
  {
    if ( *display_option )
    {
      mustshow[0] = 1;
      v4 = gettext("Failed to set DISPLAY variable!");
    }
    else
    {
      mustshow[0] = 1;
      v4 = gettext("Failed to clear DISPLAY variable!");
    }
    statusline(v4);
  }
  else if ( x_display || LYisConfiguredForX != 1 )
  {
    if ( !x_display || LYisConfiguredForX )
    {
      mustshow[0] = 1;
      v3 = gettext("Value accepted!");
      statusline(v3);
    }
    else
    {
      mustshow[0] = 1;
      v2 = gettext("Value accepted! -- WARNING: Lynx is NOT configured for XWINDOWS!");
      statusline(v2);
    }
  }
  else
  {
    mustshow[0] = 1;
    v1 = gettext("Value accepted! -- WARNING: Lynx is configured for XWINDOWS!");
    statusline(v1);
  }
}

//----- (0809C957) --------------------------------------------------------
void SetupChosenShowColor()
{
  int v0; // [esp+Ch] [ebp-Ch]
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  can_do_colors[0] = 1;
  if ( LYCursesON[0] )
    can_do_colors[0] = has_colors();
  if ( !no_option_save && LYChosenShowColor == -1 )
  {
    if ( LYrcShowColor )
    {
      if ( LYrcShowColor == 3 )
      {
        if ( can_do_colors[0] )
        {
          if ( LYShowColor <= 1 )
            v1 = 1;
          else
            v1 = 3;
          LYChosenShowColor = v1;
        }
        else
        {
          LYChosenShowColor = 3;
        }
      }
      else
      {
        if ( LYShowColor <= 1 )
          v2 = 1;
        else
          v2 = 2;
        LYChosenShowColor = v2;
      }
    }
    else
    {
      if ( LYShowColor <= 1 )
        v0 = 0;
      else
        v0 = 2;
      LYChosenShowColor = v0;
    }
  }
}

//----- (0809CA2F) --------------------------------------------------------
int __cdecl add_it(char *text, int len)
{
  size_t v3; // [esp+8h] [ebp-10h]

  if ( len )
  {
    text[len] = 0;
    v3 = strlen(text);
    LYwaddnstr(LYwin, text, v3);
  }
  return 0;
}

//----- (0809CA6F) --------------------------------------------------------
void __cdecl addlbl(const char *text)
{
  int d; // [esp+18h] [ebp-60h]
  int da; // [esp+18h] [ebp-60h]
  int s; // [esp+1Ch] [ebp-5Ch]
  BOOLEAN b; // [esp+23h] [ebp-55h]
  char actual[80]; // [esp+24h] [ebp-54h] BYREF
  unsigned int v6; // [esp+74h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  b = 0;
  d = 0;
  for ( s = 0; text[s]; ++s )
  {
    actual[d++] = text[s];
    if ( text[s] == 40 )
    {
      da = add_it(actual, d - 1);
      lynx_start_bold();
      b = 1;
      actual[da] = text[s];
      d = da + 1;
    }
    else if ( text[s] == 41 )
    {
      d = add_it(actual, d);
      lynx_stop_bold();
      b = 0;
    }
  }
  add_it(actual, d);
  if ( b )
    lynx_stop_bold();
}

//----- (0809CB64) --------------------------------------------------------
void LYoptions()
{
  char *v0; // eax
  size_t v1; // eax
  size_t v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  char *v13; // eax
  size_t v14; // ebx
  char *v15; // eax
  char *v16; // eax
  size_t v17; // ebx
  char *v18; // eax
  char *v19; // eax
  size_t v20; // ebx
  char *v21; // eax
  char *v22; // eax
  size_t v23; // ebx
  char *v24; // eax
  char *v25; // eax
  size_t v26; // ebx
  char *v27; // eax
  char *v28; // eax
  size_t v29; // ebx
  char *v30; // eax
  char *v31; // eax
  char *v32; // eax
  size_t v33; // ebx
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  char *v37; // eax
  size_t v38; // eax
  size_t v39; // eax
  char *v40; // eax
  char *v41; // eax
  char *v42; // eax
  size_t v43; // eax
  char *v44; // eax
  char *v45; // eax
  char *v46; // eax
  size_t v47; // eax
  char *v48; // eax
  char *v49; // eax
  size_t v50; // ebx
  char *v51; // eax
  char *v52; // eax
  size_t v53; // ebx
  char *v54; // eax
  size_t v55; // eax
  char *v56; // eax
  size_t v57; // eax
  size_t v58; // eax
  char *v59; // eax
  size_t v60; // eax
  char *v61; // eax
  char *v62; // eax
  char *v63; // eax
  char *v64; // eax
  size_t v65; // eax
  size_t v66; // eax
  char *v67; // eax
  char *v68; // eax
  char *v69; // eax
  int v70; // eax
  int v71; // eax
  BOOLEAN v72; // al
  char *v73; // eax
  size_t v74; // eax
  size_t v75; // eax
  char *v76; // eax
  char *v77; // eax
  char *v78; // eax
  size_t v79; // eax
  size_t v80; // eax
  char *v81; // eax
  char *v82; // eax
  BOOLEAN v83; // al
  BOOLEAN v84; // al
  char *v85; // eax
  BOOLEAN v86; // al
  BOOLEAN v87; // al
  char *v88; // eax
  char *v89; // eax
  int v90; // eax
  int v91; // eax
  int v92; // eax
  char *v93; // eax
  char *v94; // eax
  BOOLEAN v95; // al
  int v96; // eax
  int v97; // eax
  int v98; // eax
  int v99; // eax
  int v100; // eax
  int v101; // eax
  int v102; // eax
  int v103; // eax
  char *v104; // eax
  size_t v105; // eax
  size_t v106; // eax
  char *v107; // eax
  char *v108; // eax
  char *v109; // eax
  char *v110; // eax
  char *v111; // eax
  char *v112; // eax
  char *v113; // eax
  char *v114; // eax
  const char *v115; // [esp+48h] [ebp-620h]
  const char *v116; // [esp+4Ch] [ebp-61Ch]
  const char *v117; // [esp+CCh] [ebp-59Ch]
  const char *v118; // [esp+D0h] [ebp-598h]
  const char *v119; // [esp+E0h] [ebp-588h]
  const char *v120; // [esp+ECh] [ebp-57Ch]
  int v121; // [esp+158h] [ebp-510h]
  bool v122; // [esp+1ACh] [ebp-4BCh]
  char *choices[10]; // [esp+200h] [ebp-468h] BYREF
  char *terminal_0; // [esp+228h] [ebp-440h]
  int chosen; // [esp+22Ch] [ebp-43Ch]
  char *terminal; // [esp+230h] [ebp-438h]
  const char **assume_list; // [esp+234h] [ebp-434h]
  int curval; // [esp+238h] [ebp-430h]
  int i; // [esp+23Ch] [ebp-42Ch]
  char *cp; // [esp+240h] [ebp-428h]
  int CurrentShowColor; // [esp+244h] [ebp-424h]
  int CurrentAssumeCharSet; // [esp+248h] [ebp-420h]
  int CurrentCharSet; // [esp+24Ch] [ebp-41Ch]
  int ch_0; // [esp+250h] [ebp-418h]
  int response; // [esp+254h] [ebp-414h]
  BOOLEAN again; // [esp+25Bh] [ebp-40Dh]
  BOOLEAN old_use_assume_charset; // [esp+25Ch] [ebp-40Ch]
  BOOLEAN use_assume_charset; // [esp+25Dh] [ebp-40Bh]
  BOOLEAN AddValueAccepted; // [esp+25Eh] [ebp-40Ah]
  BOOLEAN CurrentRawMode; // [esp+25Fh] [ebp-409h]
  char display_option[1024]; // [esp+260h] [ebp-408h] BYREF
  unsigned int v142; // [esp+660h] [ebp-8h]

  v142 = __readgsdword(0x14u);
  CurrentCharSet = current_char_set;
  CurrentAssumeCharSet = UCLYhndl_for_unspec;
  CurrentShowColor = LYShowColor;
  CurrentRawMode = LYRawMode[0];
  AddValueAccepted = 0;
  cp = 0;
  if ( LYlines <= 22 )
  {
    v0 = gettext("Screen height must be at least 23 lines for the Options menu!");
    HTAlert(v0);
    return;
  }
  term_options[0] = 0;
  LYStatusLine = LYlines - 1;
  signal(2, terminate_options);
  if ( no_option_save )
  {
    if ( LYShowColor )
    {
      if ( LYShowColor == 3 )
        LYShowColor = 2;
    }
    else
    {
      LYShowColor = 1;
    }
  }
  else
  {
    SetupChosenShowColor();
  }
  use_assume_charset = user_mode == 2;
  old_use_assume_charset = user_mode == 2;
draw_options:
  old_use_assume_charset = use_assume_charset;
  if ( enable_scrollback )
    LYclear();
  else
    LYerase();
  LYmove(0, 5);
  lynx_start_h1_color();
  LYwaddnstr(LYwin, "         Options Menu (", 0x17u);
  LYwaddnstr(LYwin, "Lynx", 4u);
  LYwaddnstr(LYwin, " Version ", 9u);
  LYwaddnstr(LYwin, "2.8.7dev.11", 0xBu);
  waddch(LYwin, 0x29u);
  lynx_stop_h1_color();
  LYmove(2, 5);
  addlbl("(E)ditor                     : ");
  if ( editor && *editor )
    v1 = strlen(editor);
  else
    v1 = strlen("NONE");
  if ( editor && *editor )
    LYwaddnstr(LYwin, editor, v1);
  else
    LYwaddnstr(LYwin, "NONE", v1);
  LYmove(3, 5);
  addlbl("(D)ISPLAY variable           : ");
  if ( x_display && *x_display )
    v2 = strlen(x_display);
  else
    v2 = strlen("NONE");
  if ( x_display && *x_display )
    LYwaddnstr(LYwin, x_display, v2);
  else
    LYwaddnstr(LYwin, "NONE", v2);
  LYmove(4, 5);
  addlbl("mu(L)ti-bookmarks: ");
  v3 = strlen(mbm_choices_11249[LYMultiBookmarks]);
  LYwaddnstr(LYwin, mbm_choices_11249[LYMultiBookmarks], v3);
  LYmove(4, 34);
  if ( LYMultiBookmarks )
  {
    addlbl("review/edit (B)ookmarks files");
  }
  else
  {
    addlbl("(B)ookmark file: ");
    if ( bookmark_page && *bookmark_page )
      v4 = strlen(bookmark_page);
    else
      v4 = strlen("NONE");
    if ( bookmark_page && *bookmark_page )
      LYwaddnstr(LYwin, bookmark_page, v4);
    else
      LYwaddnstr(LYwin, "NONE", v4);
  }
  LYmove(5, 5);
  addlbl("(F)TP sort criteria          : ");
  if ( HTfileSortMethod )
  {
    if ( HTfileSortMethod == 2 )
    {
      v115 = "By Size    ";
    }
    else
    {
      if ( HTfileSortMethod == 1 )
        v116 = "By Type    ";
      else
        v116 = "By Date    ";
      v115 = v116;
    }
    LYwaddnstr(LYwin, v115, 0xBu);
  }
  else
  {
    LYwaddnstr(LYwin, "By Filename", 0xBu);
  }
  LYmove(6, 5);
  addlbl("(P)ersonal mail address      : ");
  if ( personal_mail_address && *personal_mail_address )
    v5 = strlen(personal_mail_address);
  else
    v5 = strlen("NONE");
  if ( personal_mail_address && *personal_mail_address )
    LYwaddnstr(LYwin, personal_mail_address, v5);
  else
    LYwaddnstr(LYwin, "NONE", v5);
  LYmove(7, 5);
  addlbl("(S)earching type             : ");
  if ( case_sensitive )
    LYwaddnstr(LYwin, "CASE SENSITIVE  ", 0x10u);
  else
    LYwaddnstr(LYwin, "CASE INSENSITIVE", 0x10u);
  if ( use_assume_charset )
    LYmove(11, 5);
  else
    LYmove(10, 5);
  addlbl("display (C)haracter set      : ");
  v6 = strlen(LYchar_set_names[current_char_set]);
  LYwaddnstr(LYwin, LYchar_set_names[current_char_set], v6);
  LYmove(8, 5);
  addlbl("preferred document lan(G)uage: ");
  if ( language && *language )
    v7 = strlen(language);
  else
    v7 = strlen("NONE");
  if ( language && *language )
    LYwaddnstr(LYwin, language, v7);
  else
    LYwaddnstr(LYwin, "NONE", v7);
  LYmove(9, 5);
  addlbl("preferred document c(H)arset : ");
  if ( pref_charset && *pref_charset )
    v8 = strlen(pref_charset);
  else
    v8 = strlen("NONE");
  if ( pref_charset && *pref_charset )
    LYwaddnstr(LYwin, pref_charset, v8);
  else
    LYwaddnstr(LYwin, "NONE", v8);
  if ( use_assume_charset )
  {
    LYmove(10, 5);
    addlbl("(^A)ssume charset if unknown : ");
    if ( UCAssume_MIMEcharset )
    {
      v9 = strlen(UCAssume_MIMEcharset);
      LYwaddnstr(LYwin, UCAssume_MIMEcharset, v9);
    }
    else
    {
      if ( UCLYhndl_for_unspec < 0 )
        v10 = strlen("NONE");
      else
        v10 = strlen(LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
      if ( UCLYhndl_for_unspec < 0 )
        LYwaddnstr(LYwin, "NONE", v10);
      else
        LYwaddnstr(LYwin, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname, v10);
    }
  }
  if ( use_assume_charset )
    LYmove(12, 5);
  else
    LYmove(11, 5);
  addlbl("Raw 8-bit or CJK m(O)de      : ");
  if ( LYRawMode[0] )
    LYwaddnstr(LYwin, "ON ", 3u);
  else
    LYwaddnstr(LYwin, "OFF", 3u);
  if ( use_assume_charset )
    LYmove(12, 44);
  else
    LYmove(11, 44);
  addlbl("show color (&)  : ");
  if ( !no_option_save )
  {
    if ( LYChosenShowColor != 1 )
    {
      if ( LYChosenShowColor <= 1 )
      {
        if ( !LYChosenShowColor )
          LYwaddnstr(LYwin, "NEVER     ", 0xAu);
        goto LABEL_113;
      }
      if ( LYChosenShowColor != 2 )
      {
        if ( LYChosenShowColor == 3 )
        {
          if ( !has_colors() )
            LYwaddnstr(LYwin, "Always try", 0xAu);
          else
            LYwaddnstr(LYwin, "ALWAYS    ", 0xAu);
        }
        goto LABEL_113;
      }
      goto LABEL_98;
    }
LABEL_99:
    LYwaddnstr(LYwin, "OFF", 3u);
    goto LABEL_113;
  }
  if ( LYShowColor != 1 )
    goto LABEL_99;
LABEL_98:
  LYwaddnstr(LYwin, "ON ", 3u);
LABEL_113:
  if ( use_assume_charset )
    LYmove(13, 5);
  else
    LYmove(12, 5);
  addlbl("(V)I keys: ");
  if ( vi_keys )
    LYwaddnstr(LYwin, "ON ", 3u);
  else
    LYwaddnstr(LYwin, "OFF", 3u);
  if ( use_assume_charset )
    LYmove(13, 22);
  else
    LYmove(12, 22);
  addlbl("e(M)acs keys: ");
  if ( emacs_keys )
    LYwaddnstr(LYwin, "ON ", 3u);
  else
    LYwaddnstr(LYwin, "OFF", 3u);
  if ( use_assume_charset )
    LYmove(13, 44);
  else
    LYmove(12, 44);
  addlbl("sho(W) dot files: ");
  if ( no_dotfiles || !show_dotfiles )
    LYwaddnstr(LYwin, "OFF", 3u);
  else
    LYwaddnstr(LYwin, "ON ", 3u);
  if ( use_assume_charset )
    LYmove(14, 5);
  else
    LYmove(13, 5);
  addlbl("popups for selec(T) fields   : ");
  if ( LYSelectPopups )
    LYwaddnstr(LYwin, "ON ", 3u);
  else
    LYwaddnstr(LYwin, "OFF", 3u);
  if ( use_assume_charset )
    LYmove(14, 44);
  else
    LYmove(13, 44);
  addlbl("show cursor (@) : ");
  if ( LYShowCursor )
    LYwaddnstr(LYwin, "ON ", 3u);
  else
    LYwaddnstr(LYwin, "OFF", 3u);
  if ( use_assume_charset )
    LYmove(15, 5);
  else
    LYmove(14, 5);
  addlbl("(K)eypad mode                : ");
  if ( (keypad_mode == 3 || keypad_mode == 2) && (keypad_mode == 1 || keypad_mode == 2) )
  {
    LYwaddnstr(LYwin, "Links and form fields are numbered", 0x22u);
  }
  else
  {
    if ( keypad_mode == 1 || keypad_mode == 2 )
    {
      v117 = "Links are numbered                ";
    }
    else
    {
      if ( keypad_mode == 3 || keypad_mode == 2 )
        v118 = "Form fields are numbered          ";
      else
        v118 = "Numbers act as arrows             ";
      v117 = v118;
    }
    LYwaddnstr(LYwin, v117, 0x22u);
  }
  if ( use_assume_charset )
    LYmove(16, 5);
  else
    LYmove(15, 5);
  addlbl("li(N)e edit style            : ");
  v11 = strlen(LYLineeditNames[current_lineedit]);
  LYwaddnstr(LYwin, LYLineeditNames[current_lineedit], v11);
  if ( use_assume_charset )
    LYmove(18, 5);
  else
    LYmove(17, 5);
  addlbl("l(I)st directory style       : ");
  if ( dir_list_style == 1 )
  {
    LYwaddnstr(LYwin, "Files first      ", 0x11u);
  }
  else
  {
    if ( dir_list_style == 2 )
      v119 = "Mixed style      ";
    else
      v119 = "Directories first";
    LYwaddnstr(LYwin, v119, 0x11u);
  }
  if ( use_assume_charset )
    LYmove(19, 5);
  else
    LYmove(18, 5);
  addlbl("(U)ser mode                  : ");
  if ( user_mode )
  {
    if ( user_mode == 1 )
      v120 = "Intermediate";
    else
      v120 = "Advanced    ";
    LYwaddnstr(LYwin, v120, 0xCu);
  }
  else
  {
    LYwaddnstr(LYwin, "Novice      ", 0xCu);
  }
  addlbl("  verbose images (!) : ");
  if ( verbose_img )
    LYwaddnstr(LYwin, "ON ", 3u);
  else
    LYwaddnstr(LYwin, "OFF", 3u);
  if ( use_assume_charset )
    LYmove(20, 5);
  else
    LYmove(19, 5);
  addlbl("user (A)gent                 : ");
  if ( LYUserAgent && *LYUserAgent )
    v12 = strlen(LYUserAgent);
  else
    v12 = strlen("NONE");
  if ( LYUserAgent && *LYUserAgent )
    LYwaddnstr(LYwin, LYUserAgent, v12);
  else
    LYwaddnstr(LYwin, "NONE", v12);
  LYmove(LYlines - 3, 2);
  v13 = gettext("Select ");
  v14 = strlen(v13);
  v15 = gettext("Select ");
  LYwaddnstr(LYwin, v15, v14);
  lynx_start_bold();
  v16 = gettext("capital letter");
  v17 = strlen(v16);
  v18 = gettext("capital letter");
  LYwaddnstr(LYwin, v18, v17);
  lynx_stop_bold();
  v19 = gettext(" of option line,");
  v20 = strlen(v19);
  v21 = gettext(" of option line,");
  LYwaddnstr(LYwin, v21, v20);
  if ( !no_option_save )
  {
    LYwaddnstr(LYwin, " '", 2u);
    lynx_start_bold();
    LYwaddnstr(LYwin, ">", 1u);
    lynx_stop_bold();
    LYwaddnstr(LYwin, "'", 1u);
    v22 = gettext(" to save,");
    v23 = strlen(v22);
    v24 = gettext(" to save,");
    LYwaddnstr(LYwin, v24, v23);
  }
  v25 = gettext(" or ");
  v26 = strlen(v25);
  v27 = gettext(" or ");
  LYwaddnstr(LYwin, v27, v26);
  LYwaddnstr(LYwin, "'", 1u);
  lynx_start_bold();
  LYwaddnstr(LYwin, "r", 1u);
  lynx_stop_bold();
  LYwaddnstr(LYwin, "'", 1u);
  v28 = gettext(" to return to Lynx.");
  v29 = strlen(v28);
  v30 = gettext(" to return to Lynx.");
  LYwaddnstr(LYwin, v30, v29);
  response = 0;
LABEL_657:
  while ( response != 82 && !LYisNonAlnumKeyname(response, 37) && response != 62 && !term_options[0] )
  {
    if ( response != 3 && response != 7 )
    {
      if ( response == -1 )
      {
        if ( keymap[0] != 47 )
          goto LABEL_199;
      }
      else if ( (response & 0x8800) != 0 )
      {
        if ( (unsigned __int8)response != 47 )
          goto LABEL_199;
      }
      else if ( keymap[(response & 0x7FF) + 1] != 47 )
      {
        goto LABEL_199;
      }
    }
    if ( ((*__ctype_b_loc())[response] & 0x4000) == 0 )
      break;
LABEL_199:
    if ( AddValueAccepted == 1 )
    {
      mustshow[0] = 1;
      v31 = gettext("Value accepted!");
      statusline(v31);
      AddValueAccepted = 0;
    }
    LYmove(LYlines - 2, 0);
    lynx_start_prompt_color();
    v32 = gettext("Command: ");
    v33 = strlen(v32);
    v34 = gettext("Command: ");
    LYwaddnstr(LYwin, v34, v33);
    lynx_stop_prompt_color();
    LYrefresh();
    response = LYgetch_single();
    if ( term_options[0] )
      goto LABEL_212;
    if ( response == 3 || response == 7 )
      goto LABEL_211;
    if ( response == -1 )
    {
      if ( keymap[0] == 47 )
        goto LABEL_211;
    }
    else
    {
      if ( (response & 0x8800) == 0 )
      {
        if ( keymap[(response & 0x7FF) + 1] != 47 )
          goto LABEL_213;
LABEL_211:
        if ( ((*__ctype_b_loc())[response] & 0x4000) != 0 )
          goto LABEL_213;
LABEL_212:
        response = 82;
        goto LABEL_213;
      }
      if ( (unsigned __int8)response == 47 )
        goto LABEL_211;
    }
LABEL_213:
    if ( LYisNonAlnumKeyname(response, 21) )
    {
      lynx_force_repaint();
      goto draw_options;
    }
    switch ( response )
    {
      case 1:
        if ( use_assume_charset )
        {
          assume_list = (const char **)calloc(LYNumCharsets + 1, 4u);
          if ( !assume_list )
            outofmem("./LYOptions.c", "options");
          for ( i = 0; i < LYNumCharsets; ++i )
            assume_list[i] = LYCharSet_UC[i].MIMEname;
          curval = UCLYhndl_for_unspec;
          if ( UCLYhndl_for_unspec == current_char_set && UCAssume_MIMEcharset )
            curval = UCGetLYhndl_byMIME(UCAssume_MIMEcharset);
          if ( curval < 0 )
          {
            if ( LYRawMode[0] )
              v121 = current_char_set;
            else
              v121 = 0;
            curval = v121;
          }
          if ( LYSelectPopups )
            UCLYhndl_for_unspec = popup_choice(curval, 10, -1, assume_list, 0, 0, 0);
          else
            UCLYhndl_for_unspec = boolean_choice(curval, 10, -1, assume_list);
          if ( CurrentAssumeCharSet != UCLYhndl_for_unspec || UCLYhndl_for_unspec != curval )
          {
            if ( UCLYhndl_for_unspec != CurrentAssumeCharSet )
              HTSACopy(&UCAssume_MIMEcharset, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
            if ( HTCJK != JAPANESE )
              LYRawMode[0] = UCLYhndl_for_unspec == current_char_set;
            HTMLSetUseDefaultRawMode(current_char_set, LYRawMode[0]);
            HTMLSetCharacterHandling(current_char_set);
            CurrentAssumeCharSet = UCLYhndl_for_unspec;
            CurrentRawMode = LYRawMode[0];
            if ( !LYSelectPopups )
            {
              if ( use_assume_charset )
                LYmove(12, 36);
              else
                LYmove(11, 36);
              LYclrtoeol();
              if ( LYRawMode[0] )
                LYwaddnstr(LYwin, "ON ", 3u);
              else
                LYwaddnstr(LYwin, "OFF", 3u);
            }
          }
          if ( assume_list )
          {
            free(assume_list);
            assume_list = 0;
          }
          response = 32;
          if ( LYSelectPopups )
          {
            if ( term_options[0] )
              term_options[0] = 0;
            else
              AddValueAccepted = 1;
            goto draw_options;
          }
        }
        else
        {
          mustshow[0] = 1;
          v69 = gettext("That key requires Advanced User mode.");
          statusline(v69);
          AddValueAccepted = 0;
        }
        goto LABEL_657;
      case 33:
        if ( LYSelectPopups )
          verbose_img = popup_choice(verbose_img, 18, 71, bool_choices_11244, 2, 0, 0);
        else
          verbose_img = boolean_choice(verbose_img, 18, 71, bool_choices_11244);
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 38:
        if ( !no_option_save )
        {
          again = 0;
          choices[0] = 0;
          HTSACopy(choices, "NEVER     ");
          choices[1] = 0;
          HTSACopy(&choices[1], "OFF       ");
          choices[2] = 0;
          HTSACopy(&choices[2], "ON        ");
          choices[3] = 0;
          if ( !has_colors() )
            HTSACopy(&choices[3], "Always try");
          else
            HTSACopy(&choices[3], "ALWAYS    ");
          choices[4] = 0;
          do
          {
            if ( LYSelectPopups )
            {
              if ( use_assume_charset )
                v92 = popup_choice(LYChosenShowColor, 12, 62, (const char **)choices, 4, 0, 0);
              else
                v92 = popup_choice(LYChosenShowColor, 11, 62, (const char **)choices, 4, 0, 0);
              chosen = v92;
            }
            else
            {
              if ( use_assume_charset )
                v91 = boolean_choice(LYChosenShowColor, 12, 62, (const char **)choices);
              else
                v91 = boolean_choice(LYChosenShowColor, 11, 62, (const char **)choices);
              chosen = v91;
            }
            v122 = chosen == 2 && !has_colors();
            again = v122;
            if ( v122 )
            {
              terminal_0 = LYGetEnv("TERM");
              if ( terminal_0 )
              {
                v93 = gettext("Your '%s' terminal does not support color.");
                HTUserMsg2(v93, terminal_0);
              }
              else
              {
                v94 = gettext("Terminal does not support color");
                HTUserMsg(v94);
              }
            }
          }
          while ( again );
          LYChosenShowColor = chosen;
          if ( has_colors() )
            LYShowColor = chosen;
          if ( choices[0] )
          {
            free(choices[0]);
            choices[0] = 0;
          }
          if ( choices[1] )
          {
            free(choices[1]);
            choices[1] = 0;
          }
          if ( choices[2] )
          {
            free(choices[2]);
            choices[2] = 0;
          }
          if ( choices[3] )
          {
            free(choices[3]);
            choices[3] = 0;
          }
          goto LABEL_537;
        }
        if ( !has_colors() )
        {
          terminal = LYGetEnv("TERM");
          if ( terminal )
          {
            v88 = gettext("Your '%s' terminal does not support color.");
            HTUserMsg2(v88, terminal);
          }
          else
          {
            v89 = gettext("Terminal does not support color");
            HTUserMsg(v89);
          }
        }
        else
        {
          if ( use_assume_charset )
            v90 = boolean_choice(LYShowColor - 1, 12, 62, bool_choices_11244);
          else
            v90 = boolean_choice(LYShowColor - 1, 11, 62, bool_choices_11244);
          LYShowColor = v90;
          if ( v90 )
            LYShowColor = 2;
          else
            LYShowColor = 1;
LABEL_537:
          if ( CurrentShowColor != LYShowColor )
            lynx_force_repaint();
          CurrentShowColor = LYShowColor;
          response = 32;
          if ( LYSelectPopups && !no_option_save )
          {
            if ( term_options[0] )
              term_options[0] = 0;
            else
              AddValueAccepted = 1;
            goto draw_options;
          }
        }
        goto LABEL_657;
      case 62:
        if ( no_option_save )
        {
          v113 = gettext(" 'r' to return to Lynx ");
          HTInfoMsg(v113);
          response = 32;
        }
        else
        {
          v110 = gettext("Saving Options...");
          HTInfoMsg(v110);
          LYrcShowColor = LYChosenShowColor;
          if ( save_rc(0) )
          {
            v111 = gettext("Options saved!");
            HTInfoMsg(v111);
          }
          else
          {
            v112 = gettext("Unable to save Options!");
            HTAlert(v112);
          }
        }
        goto LABEL_657;
      case 64:
        if ( use_assume_charset )
          v95 = boolean_choice(LYShowCursor, 14, 62, bool_choices_11244);
        else
          v95 = boolean_choice(LYShowCursor, 13, 62, bool_choices_11244);
        LYShowCursor = v95;
        response = 32;
        goto LABEL_657;
      case 65:
        if ( no_useragent[0] )
        {
          mustshow[0] = 1;
          v109 = gettext("Changing of the User-Agent string is disabled!");
          statusline(v109);
          goto LABEL_647;
        }
        if ( LYUserAgent && *LYUserAgent )
        {
          LYstrncpy(display_option, LYUserAgent, 1023);
        }
        else
        {
          LYmove(4, 36);
          LYwaddnstr(LYwin, "    ", 4u);
          display_option[0] = 0;
        }
        mustshow[0] = 1;
        v104 = gettext("Hit RETURN to accept entered data.  Delete data to invoke the default.");
        statusline(v104);
        if ( use_assume_charset )
          LYmove(20, 36);
        else
          LYmove(19, 36);
        lynx_start_bold();
        ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
        lynx_stop_bold();
        if ( use_assume_charset )
          LYmove(20, 36);
        else
          LYmove(19, 36);
        if ( term_options[0] || ch_0 == -1 )
        {
          if ( LYUserAgent && *LYUserAgent )
            v105 = strlen(LYUserAgent);
          else
            v105 = strlen("NONE");
          if ( LYUserAgent && *LYUserAgent )
            goto LABEL_629;
LABEL_638:
          LYwaddnstr(LYwin, "NONE", v105);
          goto LABEL_640;
        }
        if ( !display_option[0] )
        {
          HTSACopy(&LYUserAgent, LYUserAgentDefault);
          if ( LYUserAgent && *LYUserAgent )
            v105 = strlen(LYUserAgent);
          else
            v105 = strlen("NONE");
          if ( LYUserAgent && *LYUserAgent )
          {
LABEL_629:
            LYwaddnstr(LYwin, LYUserAgent, v105);
            goto LABEL_640;
          }
          goto LABEL_638;
        }
        HTSACopy(&LYUserAgent, display_option);
        v106 = strlen(display_option);
        LYwaddnstr(LYwin, display_option, v106);
LABEL_640:
        LYclrtoeol();
        if ( ch_0 == -1 )
        {
          v107 = gettext("Cancelled!!!");
          HTInfoMsg(v107);
          HTInfoMsg(Msg);
        }
        else
        {
          if ( LYCheckUserAgent() )
          {
            mustshow[0] = 1;
            v108 = gettext("Value accepted!");
          }
          else
          {
            mustshow[0] = 1;
            v108 = gettext("Use \"L_y_n_x\" or \"Lynx\" in User-Agent, or it looks like intentional deception!");
          }
          statusline(v108);
        }
LABEL_647:
        response = 32;
        goto LABEL_657;
      case 66:
        if ( no_bookmark )
        {
          mustshow[0] = 1;
          v63 = gettext("You are not allowed to change the bookmark file!");
          statusline(v63);
          goto LABEL_327;
        }
        if ( LYMultiBookmarks )
        {
          edit_bookmarks();
          signal(2, terminate_options);
          goto draw_options;
        }
        if ( bookmark_page && *bookmark_page )
        {
          LYstrncpy(display_option, bookmark_page, 1023);
        }
        else
        {
          LYmove(4, 50);
          LYclrtoeol();
          display_option[0] = 0;
        }
        mustshow[0] = 1;
        v56 = gettext("Hit RETURN to accept entered data.");
        statusline(v56);
        LYmove(4, 50);
        lynx_start_bold();
        ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
        lynx_stop_bold();
        LYmove(4, 50);
        if ( term_options[0] || ch_0 == -1 || !display_option[0] )
        {
          if ( bookmark_page && *bookmark_page )
            v57 = strlen(bookmark_page);
          else
            v57 = strlen("NONE");
          if ( bookmark_page && *bookmark_page )
            LYwaddnstr(LYwin, bookmark_page, v57);
          else
            LYwaddnstr(LYwin, "NONE", v57);
LABEL_323:
          LYclrtoeol();
          if ( ch_0 == -1 )
          {
            v61 = gettext("Cancelled!!!");
            HTInfoMsg(v61);
            HTInfoMsg(Msg);
          }
          else
          {
            mustshow[0] = 1;
            v62 = gettext("Value accepted!");
            statusline(v62);
          }
LABEL_327:
          response = 32;
          goto LABEL_657;
        }
        if ( LYPathOffHomeOK(display_option, 0x400u) )
        {
          HTSACopy(&bookmark_page, display_option);
          HTSACopy(MBM_A_subbookmark, bookmark_page);
          v60 = strlen(bookmark_page);
          LYwaddnstr(LYwin, bookmark_page, v60);
          goto LABEL_323;
        }
        if ( bookmark_page && *bookmark_page )
          v58 = strlen(bookmark_page);
        else
          v58 = strlen("NONE");
        if ( bookmark_page && *bookmark_page )
          LYwaddnstr(LYwin, bookmark_page, v58);
        else
          LYwaddnstr(LYwin, "NONE", v58);
        LYclrtoeol();
        mustshow[0] = 1;
        v59 = gettext("Use a filepath off your home directory!");
        statusline(v59);
        response = 32;
        break;
      case 67:
        if ( LYSelectPopups )
        {
          if ( use_assume_charset )
            v71 = popup_choice(current_char_set, 11, -1, LYchar_set_names, 0, 0, 0);
          else
            v71 = popup_choice(current_char_set, 10, -1, LYchar_set_names, 0, 0, 0);
          current_char_set = v71;
        }
        else
        {
          if ( use_assume_charset )
            v70 = boolean_choice(current_char_set, 11, -1, LYchar_set_names);
          else
            v70 = boolean_choice(current_char_set, 10, -1, LYchar_set_names);
          current_char_set = v70;
        }
        if ( CurrentCharSet != current_char_set )
        {
          LYUseDefaultRawMode = 1;
          HTMLUseCharacterSet(current_char_set);
          CurrentCharSet = current_char_set;
          CurrentRawMode = LYRawMode[0];
          if ( !LYSelectPopups )
          {
            if ( use_assume_charset )
              LYmove(12, 36);
            else
              LYmove(11, 36);
            LYclrtoeol();
            if ( LYRawMode[0] )
              LYwaddnstr(LYwin, "ON ", 3u);
            else
              LYwaddnstr(LYwin, "OFF", 3u);
          }
        }
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 68:
        if ( x_display && *x_display )
        {
          LYstrncpy(display_option, x_display, 1023);
        }
        else
        {
          LYmove(3, 36);
          LYwaddnstr(LYwin, "    ", 4u);
          display_option[0] = 0;
        }
        mustshow[0] = 1;
        v42 = gettext("Hit RETURN to accept entered data.");
        statusline(v42);
        LYmove(3, 36);
        lynx_start_bold();
        ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
        lynx_stop_bold();
        LYmove(3, 36);
        if ( term_options[0] || ch_0 == -1 || x_display && !strcmp(x_display, display_option) )
        {
          if ( x_display && *x_display )
            v43 = strlen(x_display);
          else
            v43 = strlen("NONE");
          if ( x_display && *x_display )
            LYwaddnstr(LYwin, x_display, v43);
          else
            LYwaddnstr(LYwin, "NONE", v43);
          LYclrtoeol();
          if ( ch_0 == -1 )
          {
            v44 = gettext("Cancelled!!!");
            HTInfoMsg(v44);
            HTInfoMsg(Msg);
          }
          else
          {
            mustshow[0] = 1;
            v45 = gettext("Value accepted!");
            statusline(v45);
          }
          response = 32;
        }
        else if ( display_option[0] || x_display && *x_display )
        {
          LYsetXDisplay(display_option);
          validate_x_display();
          cp = 0;
          if ( x_display )
            v47 = strlen(x_display);
          else
            v47 = strlen("NONE");
          if ( x_display )
            LYwaddnstr(LYwin, x_display, v47);
          else
            LYwaddnstr(LYwin, "NONE", v47);
          LYclrtoeol();
          summarize_x_display(display_option);
          response = 32;
        }
        else
        {
          LYwaddnstr(LYwin, "NONE", 4u);
          LYclrtoeol();
          mustshow[0] = 1;
          v46 = gettext("Value accepted!");
          statusline(v46);
          response = 32;
        }
        goto LABEL_657;
      case 69:
        if ( no_editor )
        {
          mustshow[0] = 1;
          v35 = gettext("The 'e'dit command is currently disabled.");
          statusline(v35);
        }
        else if ( system_editor )
        {
          mustshow[0] = 1;
          v36 = gettext("You are not allowed to change which editor to use!");
          statusline(v36);
        }
        else
        {
          if ( editor && *editor )
          {
            LYstrncpy(display_option, editor, 1023);
          }
          else
          {
            LYmove(2, 36);
            LYwaddnstr(LYwin, "    ", 4u);
            display_option[0] = 0;
          }
          mustshow[0] = 1;
          v37 = gettext("Hit RETURN to accept entered data.");
          statusline(v37);
          LYmove(2, 36);
          lynx_start_bold();
          ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
          lynx_stop_bold();
          LYmove(2, 36);
          if ( term_options[0] || ch_0 == -1 )
          {
            if ( editor && *editor )
              v38 = strlen(editor);
            else
              v38 = strlen("NONE");
            if ( editor && *editor )
              LYwaddnstr(LYwin, editor, v38);
            else
              LYwaddnstr(LYwin, "NONE", v38);
          }
          else if ( display_option[0] )
          {
            HTSACopy(&editor, display_option);
            v39 = strlen(display_option);
            LYwaddnstr(LYwin, display_option, v39);
          }
          else
          {
            if ( editor )
            {
              free(editor);
              editor = 0;
            }
            LYwaddnstr(LYwin, "NONE", 4u);
          }
          LYclrtoeol();
          if ( ch_0 == -1 )
          {
            v40 = gettext("Cancelled!!!");
            HTInfoMsg(v40);
            HTInfoMsg(Msg);
          }
          else
          {
            mustshow[0] = 1;
            v41 = gettext("Value accepted!");
            statusline(v41);
          }
        }
        response = 32;
        goto LABEL_657;
      case 70:
        if ( LYSelectPopups )
          HTfileSortMethod = popup_choice(HTfileSortMethod, 5, -1, fileSort_choices_11247, 4, 0, 0);
        else
          HTfileSortMethod = boolean_choice(HTfileSortMethod, 5, -1, fileSort_choices_11247);
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 71:
        if ( language && *language )
        {
          LYstrncpy(display_option, language, 1023);
        }
        else
        {
          LYmove(8, 36);
          LYwaddnstr(LYwin, "    ", 4u);
          display_option[0] = 0;
        }
        mustshow[0] = 1;
        v73 = gettext("Hit RETURN to accept entered data.");
        statusline(v73);
        LYmove(8, 36);
        lynx_start_bold();
        ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
        lynx_stop_bold();
        LYmove(8, 36);
        if ( term_options[0] || ch_0 == -1 )
        {
          if ( language && *language )
            v74 = strlen(language);
          else
            v74 = strlen("NONE");
          if ( language && *language )
            LYwaddnstr(LYwin, language, v74);
          else
            LYwaddnstr(LYwin, "NONE", v74);
        }
        else if ( display_option[0] )
        {
          HTSACopy(&language, display_option);
          v75 = strlen(display_option);
          LYwaddnstr(LYwin, display_option, v75);
        }
        else
        {
          if ( language )
          {
            free(language);
            language = 0;
          }
          LYwaddnstr(LYwin, "NONE", 4u);
        }
        LYclrtoeol();
        if ( ch_0 == -1 )
        {
          v76 = gettext("Cancelled!!!");
          HTInfoMsg(v76);
          HTInfoMsg(Msg);
        }
        else
        {
          mustshow[0] = 1;
          v77 = gettext("Value accepted!");
          statusline(v77);
        }
        response = 32;
        goto LABEL_657;
      case 72:
        if ( pref_charset && *pref_charset )
        {
          LYstrncpy(display_option, pref_charset, 1023);
        }
        else
        {
          LYmove(9, 36);
          LYwaddnstr(LYwin, "    ", 4u);
          display_option[0] = 0;
        }
        mustshow[0] = 1;
        v78 = gettext("Hit RETURN to accept entered data.");
        statusline(v78);
        LYmove(9, 36);
        lynx_start_bold();
        ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
        lynx_stop_bold();
        LYmove(9, 36);
        if ( term_options[0] || ch_0 == -1 )
        {
          if ( pref_charset && *pref_charset )
            v79 = strlen(pref_charset);
          else
            v79 = strlen("NONE");
          if ( pref_charset && *pref_charset )
            LYwaddnstr(LYwin, pref_charset, v79);
          else
            LYwaddnstr(LYwin, "NONE", v79);
        }
        else if ( display_option[0] )
        {
          HTSACopy(&pref_charset, display_option);
          v80 = strlen(display_option);
          LYwaddnstr(LYwin, display_option, v80);
        }
        else
        {
          if ( pref_charset )
          {
            free(pref_charset);
            pref_charset = 0;
          }
          LYwaddnstr(LYwin, "NONE", 4u);
        }
        LYclrtoeol();
        if ( ch_0 == -1 )
        {
          v81 = gettext("Cancelled!!!");
          HTInfoMsg(v81);
          HTInfoMsg(Msg);
        }
        else
        {
          mustshow[0] = 1;
          v82 = gettext("Value accepted!");
          statusline(v82);
        }
        response = 32;
        goto LABEL_657;
      case 73:
        if ( LYSelectPopups )
        {
          if ( use_assume_charset )
            v101 = popup_choice(dir_list_style, 18, -1, dirList_choices_11246, 3, 0, 0);
          else
            v101 = popup_choice(dir_list_style, 17, -1, dirList_choices_11246, 3, 0, 0);
          dir_list_style = v101;
        }
        else
        {
          if ( use_assume_charset )
            v100 = boolean_choice(dir_list_style, 18, -1, dirList_choices_11246);
          else
            v100 = boolean_choice(dir_list_style, 17, -1, dirList_choices_11246);
          dir_list_style = v100;
        }
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 75:
        if ( LYSelectPopups )
        {
          if ( use_assume_charset )
            v97 = popup_choice(keypad_mode, 15, -1, keypad_choices_11248, 3, 0, 0);
          else
            v97 = popup_choice(keypad_mode, 14, -1, keypad_choices_11248, 3, 0, 0);
          keypad_mode = v97;
        }
        else
        {
          if ( use_assume_charset )
            v96 = boolean_choice(keypad_mode, 15, -1, keypad_choices_11248);
          else
            v96 = boolean_choice(keypad_mode, 14, -1, keypad_choices_11248);
          keypad_mode = v96;
        }
        if ( keypad_mode )
          reset_numbers_as_arrows();
        else
          set_numbers_as_arrows();
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 76:
        if ( LYMBMBlocked )
        {
          mustshow[0] = 1;
          v48 = gettext("Multiple bookmark support is not available.");
          statusline(v48);
          response = 32;
        }
        else
        {
          if ( LYSelectPopups )
            LYMultiBookmarks = popup_choice(LYMultiBookmarks, 4, 23, mbm_choices_11249, 3, 0, 0);
          else
            LYMultiBookmarks = boolean_choice(LYMultiBookmarks, 4, 24, mbm_choices_11249);
          if ( !LYSelectPopups )
          {
            LYmove(4, 34);
            LYclrtoeol();
            if ( LYMultiBookmarks )
            {
              v49 = gettext("review/edit B)ookmarks files");
              v50 = strlen(v49);
              v51 = gettext("review/edit B)ookmarks files");
              LYwaddnstr(LYwin, v51, v50);
            }
            else
            {
              v52 = gettext("B)ookmark file: ");
              v53 = strlen(v52);
              v54 = gettext("B)ookmark file: ");
              LYwaddnstr(LYwin, v54, v53);
              if ( bookmark_page && *bookmark_page )
                v55 = strlen(bookmark_page);
              else
                v55 = strlen("NONE");
              if ( bookmark_page && *bookmark_page )
                LYwaddnstr(LYwin, bookmark_page, v55);
              else
                LYwaddnstr(LYwin, "NONE", v55);
            }
          }
          response = 32;
          if ( LYSelectPopups )
          {
            if ( term_options[0] )
              term_options[0] = 0;
            else
              AddValueAccepted = 1;
            goto draw_options;
          }
        }
        goto LABEL_657;
      case 77:
        if ( use_assume_charset )
          v84 = boolean_choice(emacs_keys, 13, 36, bool_choices_11244);
        else
          v84 = boolean_choice(emacs_keys, 12, 36, bool_choices_11244);
        emacs_keys = v84;
        if ( v84 )
          set_emacs_keys();
        else
          reset_emacs_keys();
        response = 32;
        goto LABEL_657;
      case 78:
        if ( LYSelectPopups )
        {
          if ( use_assume_charset )
            v99 = popup_choice(current_lineedit, 16, -1, LYLineeditNames, 0, 0, 0);
          else
            v99 = popup_choice(current_lineedit, 15, -1, LYLineeditNames, 0, 0, 0);
          current_lineedit = v99;
        }
        else
        {
          if ( use_assume_charset )
            v98 = boolean_choice(current_lineedit, 16, -1, LYLineeditNames);
          else
            v98 = boolean_choice(current_lineedit, 15, -1, LYLineeditNames);
          current_lineedit = v98;
        }
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 79:
        if ( use_assume_charset )
          v72 = boolean_choice(LYRawMode[0], 12, -1, bool_choices_11244);
        else
          v72 = boolean_choice(LYRawMode[0], 11, -1, bool_choices_11244);
        LYRawMode[0] = v72;
        if ( CurrentRawMode != v72 )
        {
          HTMLSetUseDefaultRawMode(current_char_set, LYRawMode[0]);
          HTMLSetCharacterHandling(current_char_set);
          CurrentRawMode = LYRawMode[0];
        }
        response = 32;
        goto LABEL_657;
      case 80:
        if ( personal_mail_address && *personal_mail_address )
        {
          LYstrncpy(display_option, personal_mail_address, 1023);
        }
        else
        {
          LYmove(6, 36);
          LYwaddnstr(LYwin, "    ", 4u);
          display_option[0] = 0;
        }
        mustshow[0] = 1;
        v64 = gettext("Hit RETURN to accept entered data.");
        statusline(v64);
        LYmove(6, 36);
        lynx_start_bold();
        ch_0 = LYgetstr(display_option, 0, 0x400u, NORECALL);
        lynx_stop_bold();
        LYmove(6, 36);
        if ( term_options[0] || ch_0 == -1 )
        {
          if ( personal_mail_address && *personal_mail_address )
            v65 = strlen(personal_mail_address);
          else
            v65 = strlen("NONE");
          if ( personal_mail_address && *personal_mail_address )
            LYwaddnstr(LYwin, personal_mail_address, v65);
          else
            LYwaddnstr(LYwin, "NONE", v65);
        }
        else if ( display_option[0] )
        {
          HTSACopy(&personal_mail_address, display_option);
          v66 = strlen(display_option);
          LYwaddnstr(LYwin, display_option, v66);
        }
        else
        {
          if ( personal_mail_address )
          {
            free(personal_mail_address);
            personal_mail_address = 0;
          }
          LYwaddnstr(LYwin, "NONE", 4u);
        }
        LYclrtoeol();
        if ( ch_0 == -1 )
        {
          v67 = gettext("Cancelled!!!");
          HTInfoMsg(v67);
          HTInfoMsg(Msg);
        }
        else
        {
          mustshow[0] = 1;
          v68 = gettext("Value accepted!");
          statusline(v68);
        }
        response = 32;
        goto LABEL_657;
      case 82:
        goto LABEL_657;
      case 83:
        case_sensitive = boolean_choice(case_sensitive, 7, -1, caseless_choices_11245);
        response = 32;
        goto LABEL_657;
      case 84:
        if ( use_assume_charset )
          v87 = boolean_choice(LYSelectPopups, 14, 36, bool_choices_11244);
        else
          v87 = boolean_choice(LYSelectPopups, 13, 36, bool_choices_11244);
        LYSelectPopups = v87;
        response = 32;
        goto LABEL_657;
      case 85:
        if ( LYSelectPopups )
        {
          if ( use_assume_charset )
            v103 = popup_choice(user_mode, 19, -1, userMode_choices_11250, 3, 0, 0);
          else
            v103 = popup_choice(user_mode, 18, -1, userMode_choices_11250, 3, 0, 0);
          user_mode = v103;
          use_assume_charset = v103 > 1;
        }
        else
        {
          if ( use_assume_charset )
            v102 = boolean_choice(user_mode, 19, -1, userMode_choices_11250);
          else
            v102 = boolean_choice(user_mode, 18, -1, userMode_choices_11250);
          user_mode = v102;
          use_assume_charset = v102 > 1;
        }
        LYSetDisplayLines();
        response = 32;
        if ( LYSelectPopups )
        {
          if ( term_options[0] )
            term_options[0] = 0;
          else
            AddValueAccepted = 1;
          goto draw_options;
        }
        goto LABEL_657;
      case 86:
        if ( use_assume_charset )
          v83 = boolean_choice(vi_keys, 13, 15, bool_choices_11244);
        else
          v83 = boolean_choice(vi_keys, 12, 15, bool_choices_11244);
        vi_keys = v83;
        if ( v83 )
          set_vi_keys();
        else
          reset_vi_keys();
        response = 32;
        goto LABEL_657;
      case 87:
        if ( no_dotfiles )
        {
          mustshow[0] = 1;
          v85 = gettext("Access to dot files is disabled!");
          statusline(v85);
        }
        else
        {
          if ( use_assume_charset )
            v86 = boolean_choice(show_dotfiles, 13, 62, bool_choices_11244);
          else
            v86 = boolean_choice(show_dotfiles, 12, 62, bool_choices_11244);
          show_dotfiles = v86;
        }
        response = 32;
        goto LABEL_657;
      default:
        if ( no_option_save )
          v114 = gettext(" 'r' to return to Lynx ");
        else
          v114 = gettext(" '>' to save, or 'r' to return to Lynx ");
        HTInfoMsg(v114);
        goto LABEL_657;
    }
  }
  term_options[0] = 0;
  LYStatusLine = -1;
  signal(2, cleanup_sig);
}

//----- (080A09F5) --------------------------------------------------------
int __cdecl widest_choice(const char **choices)
{
  int len; // [esp+Ch] [ebp-Ch]
  int width; // [esp+10h] [ebp-8h]
  int n; // [esp+14h] [ebp-4h]

  width = 0;
  for ( n = 0; choices[n]; ++n )
  {
    len = strlen(choices[n]);
    if ( width < len )
      width = len;
  }
  return width;
}

//----- (080A0A47) --------------------------------------------------------
void __cdecl show_choice(const char *choice, int width)
{
  size_t v3; // [esp+8h] [ebp-20h]
  signed int len; // [esp+24h] [ebp-4h]

  len = strlen(choice);
  v3 = strlen(choice);
  LYwaddnstr(LYwin, choice, v3);
  while ( len++ < width )
    waddch(LYwin, 0x20u);
}

//----- (080A0AA9) --------------------------------------------------------
int __cdecl boolean_choice(int cur_choice, int line, int column, const char **choices)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+Ch] [ebp-2Ch]
  int v9; // [esp+10h] [ebp-28h]
  int v10; // [esp+14h] [ebp-24h]
  int width; // [esp+20h] [ebp-18h]
  int orig_choice; // [esp+24h] [ebp-14h]
  int number; // [esp+2Ch] [ebp-Ch]
  int numbera; // [esp+2Ch] [ebp-Ch]
  int response; // [esp+34h] [ebp-4h]

  response = 0;
  if ( column < 0 )
    v8 = 36;
  else
    v8 = column;
  orig_choice = cur_choice;
  width = widest_choice(choices);
  for ( number = 0; choices[number]; ++number )
    ;
  numbera = number - 1;
  mustshow[0] = 1;
  v4 = gettext("Hit any key to change value; RETURN to accept.");
  statusline(v4);
  LYmove(line, v8);
  lynx_start_reverse();
  show_choice(choices[cur_choice], width);
  if ( LYShowCursor )
    LYmove(line, v8 - 1);
  LYrefresh();
  term_options[0] = 0;
  while ( 1 )
  {
    LYmove(line, v8);
    if ( !term_options[0] )
      response = LYgetch_single();
    if ( term_options[0] )
      goto LABEL_23;
    if ( response == 3 || response == 7 )
      goto LABEL_22;
    if ( response == -1 )
    {
      if ( keymap[0] == 47 )
        goto LABEL_22;
    }
    else
    {
      if ( (response & 0x8800) == 0 )
      {
        if ( keymap[(response & 0x7FF) + 1] != 47 )
          goto LABEL_24;
LABEL_22:
        if ( ((*__ctype_b_loc())[response] & 0x4000) != 0 )
          goto LABEL_24;
LABEL_23:
        response = 10;
        term_options[0] = 1;
        cur_choice = orig_choice;
        goto LABEL_24;
      }
      if ( (unsigned __int8)response == 47 )
        goto LABEL_22;
    }
LABEL_24:
    if ( response == 10 || response == 13 )
      break;
    if ( response == -1 )
    {
      v9 = keymap[0];
    }
    else
    {
      v10 = (response & 0x8800) != 0 ? (unsigned __int8)response : keymap[(response & 0x7FF) + 1];
      v9 = v10;
    }
    if ( v9 == 39 )
      break;
    switch ( v9 )
    {
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
        if ( v9 - 1 > numbera )
          goto LABEL_43;
        cur_choice = v9 - 1;
        break;
      case 13:
      case 14:
      case 37:
        cur_choice = orig_choice;
        term_options[0] = 1;
        break;
      case 16:
      case 17:
      case 19:
      case 26:
      case 28:
      case 30:
      case 32:
      case 35:
        if ( cur_choice )
          --cur_choice;
        else
          cur_choice = numbera;
        break;
      case 21:
        lynx_force_repaint();
        LYrefresh();
        break;
      case 22:
        cur_choice = 0;
        break;
      case 23:
        cur_choice = numbera;
        break;
      default:
LABEL_43:
        if ( cur_choice == numbera )
          cur_choice = 0;
        else
          ++cur_choice;
        break;
    }
    show_choice(choices[cur_choice], width);
    if ( LYShowCursor )
      LYmove(line, v8 - 1);
    LYrefresh();
  }
  LYmove(line, v8);
  lynx_stop_reverse();
  show_choice(choices[cur_choice], width);
  if ( term_options[0] )
  {
    term_options[0] = 0;
    v5 = gettext("Cancelled!!!");
    HTInfoMsg(v5);
    HTInfoMsg(Msg);
  }
  else
  {
    mustshow[0] = 1;
    v6 = gettext("Value accepted!");
    statusline(v6);
  }
  return cur_choice;
}

//----- (080A0DFB) --------------------------------------------------------
void __cdecl terminate_options(int sig)
{
  term_options[0] = 1;
  signal(2, terminate_options);
}

//----- (080A0E1E) --------------------------------------------------------
void edit_bookmarks()
{
  char *v0; // eax
  size_t v1; // eax
  char *v2; // eax
  size_t v3; // ebx
  char *v4; // eax
  unsigned __int8 v5; // al
  size_t v6; // eax
  size_t v7; // eax
  unsigned __int8 v8; // al
  size_t v9; // eax
  size_t v10; // eax
  char *v11; // eax
  size_t v12; // ebx
  char *v13; // eax
  char *v14; // eax
  size_t v15; // ebx
  char *v16; // eax
  char *v17; // eax
  size_t v18; // ebx
  char *v19; // eax
  char *v20; // eax
  size_t v21; // ebx
  char *v22; // eax
  char *v23; // eax
  size_t v24; // ebx
  char *v25; // eax
  char *v26; // eax
  size_t v27; // ebx
  char *v28; // eax
  char *v29; // eax
  char *v30; // eax
  char *v31; // eax
  char *v32; // eax
  int v33; // eax
  char *v34; // eax
  unsigned __int8 v35; // al
  size_t v36; // eax
  char *v37; // eax
  size_t v38; // eax
  int v39; // [esp+18h] [ebp-130h]
  char *ehead_buffer; // [esp+28h] [ebp-120h] BYREF
  int a; // [esp+2Ch] [ebp-11Ch]
  int MBM_current; // [esp+30h] [ebp-118h]
  int ch_0; // [esp+34h] [ebp-114h]
  int def_response; // [esp+38h] [ebp-110h]
  int response; // [esp+3Ch] [ebp-10Ch]
  char MBM_tmp_line[256]; // [esp+40h] [ebp-108h] BYREF
  unsigned int v47; // [esp+140h] [ebp-8h]

  v47 = __readgsdword(0x14u);
  response = 0;
  def_response = 0;
  MBM_current = 1;
  term_options[0] = 0;
  signal(2, terminate_options);
draw_bookmark_list:
  if ( enable_scrollback )
    LYclear();
  else
    LYerase();
  LYmove(0, 5);
  lynx_start_h1_color();
  if ( LYlines > 32 )
  {
    v2 = gettext("         Editing Bookmark DESCRIPTION and FILEPATH");
    v3 = strlen(v2);
    v4 = gettext("         Editing Bookmark DESCRIPTION and FILEPATH");
    LYwaddnstr(LYwin, v4, v3);
  }
  else
  {
    ehead_buffer = 0;
    v0 = gettext("Editing Bookmark DESCRIPTION and FILEPATH (%d of 2)");
    HTSprintf0(&ehead_buffer, v0, MBM_current);
    v1 = strlen(ehead_buffer);
    LYwaddnstr(LYwin, ehead_buffer, v1);
    if ( ehead_buffer )
    {
      free(ehead_buffer);
      ehead_buffer = 0;
    }
  }
  lynx_stop_h1_color();
  if ( LYlines > 32 )
  {
    for ( a = 0; a <= 25; ++a )
    {
      LYmove(a + 3, 5);
      v8 = LYindex2MBM(a);
      waddch(LYwin, v8);
      LYwaddnstr(LYwin, " : ", 3u);
      if ( MBM_A_subdescript[a] )
      {
        v9 = strlen(MBM_A_subdescript[a]);
        LYwaddnstr(LYwin, MBM_A_subdescript[a], v9);
      }
      LYmove(a + 3, 35);
      LYwaddnstr(LYwin, "| ", 2u);
      if ( MBM_A_subbookmark[a] )
      {
        v10 = strlen(MBM_A_subbookmark[a]);
        LYwaddnstr(LYwin, MBM_A_subbookmark[a], v10);
      }
    }
  }
  else
  {
    for ( a = 13 * MBM_current - 13; 25 * MBM_current / 2 >= a; ++a )
    {
      LYmove(a + 3 + -13 * MBM_current + 13, 5);
      v5 = LYindex2MBM(a);
      waddch(LYwin, v5);
      LYwaddnstr(LYwin, " : ", 3u);
      if ( MBM_A_subdescript[a] )
      {
        v6 = strlen(MBM_A_subdescript[a]);
        LYwaddnstr(LYwin, MBM_A_subdescript[a], v6);
      }
      LYmove(a + 3 + -13 * MBM_current + 13, 35);
      LYwaddnstr(LYwin, "| ", 2u);
      if ( MBM_A_subbookmark[a] )
      {
        v7 = strlen(MBM_A_subbookmark[a]);
        LYwaddnstr(LYwin, MBM_A_subbookmark[a], v7);
      }
    }
  }
  if ( LYlines <= 32 )
  {
    LYmove(LYlines - 4, 0);
    LYwaddnstr(LYwin, "'", 1u);
    lynx_start_bold();
    LYwaddnstr(LYwin, "[", 1u);
    lynx_stop_bold();
    LYwaddnstr(LYwin, "' ", 2u);
    v11 = gettext("previous");
    v12 = strlen(v11);
    v13 = gettext("previous");
    LYwaddnstr(LYwin, v13, v12);
    LYwaddnstr(LYwin, ", '", 3u);
    lynx_start_bold();
    LYwaddnstr(LYwin, "]", 1u);
    lynx_stop_bold();
    LYwaddnstr(LYwin, "' ", 2u);
    v14 = gettext("next screen");
    v15 = strlen(v14);
    v16 = gettext("next screen");
    LYwaddnstr(LYwin, v16, v15);
  }
  LYmove(LYlines - 3, 0);
  if ( !no_option_save )
  {
    LYwaddnstr(LYwin, "'", 1u);
    lynx_start_bold();
    LYwaddnstr(LYwin, ">", 1u);
    lynx_stop_bold();
    LYwaddnstr(LYwin, "'", 1u);
    v17 = gettext(" to save,");
    v18 = strlen(v17);
    v19 = gettext(" to save,");
    LYwaddnstr(LYwin, v19, v18);
  }
  v20 = gettext(" or ");
  v21 = strlen(v20);
  v22 = gettext(" or ");
  LYwaddnstr(LYwin, v22, v21);
  LYwaddnstr(LYwin, "'", 1u);
  lynx_start_bold();
  LYwaddnstr(LYwin, "^G", 2u);
  lynx_stop_bold();
  LYwaddnstr(LYwin, "'", 1u);
  v23 = gettext(" to return to Lynx.");
  v24 = strlen(v23);
  v25 = gettext(" to return to Lynx.");
  LYwaddnstr(LYwin, v25, v24);
LABEL_112:
  while ( !term_options[0] && !LYisNonAlnumKeyname(response, 37) )
  {
    if ( response == 3 || response == 7 )
    {
LABEL_123:
      if ( ((*__ctype_b_loc())[response] & 0x4000) == 0 )
        break;
      goto LABEL_124;
    }
    if ( response == -1 )
    {
      if ( keymap[0] == 47 )
        goto LABEL_123;
    }
    else if ( (response & 0x8800) != 0 )
    {
      if ( (unsigned __int8)response == 47 )
        goto LABEL_123;
    }
    else if ( keymap[(response & 0x7FF) + 1] == 47 )
    {
      goto LABEL_123;
    }
LABEL_124:
    if ( response == 62 )
      break;
    LYmove(LYlines - 2, 0);
    lynx_start_prompt_color();
    v26 = gettext("Letter: ");
    v27 = strlen(v26);
    v28 = gettext("Letter: ");
    LYwaddnstr(LYwin, v28, v27);
    lynx_stop_prompt_color();
    LYrefresh();
    if ( def_response )
      v39 = def_response;
    else
      v39 = LYgetch_single();
    response = v39;
    def_response = 0;
    if ( !term_options[0] )
    {
      if ( response == 3 || response == 7 )
        goto LABEL_43;
      if ( response == -1 )
      {
        if ( keymap[0] != 47 )
          goto LABEL_44;
        goto LABEL_43;
      }
      if ( (response & 0x8800) != 0 )
      {
        if ( (unsigned __int8)response != 47 )
          goto LABEL_44;
        goto LABEL_43;
      }
      if ( keymap[(response & 0x7FF) + 1] == 47 )
      {
LABEL_43:
        if ( ((*__ctype_b_loc())[response] & 0x4000) != 0 )
          goto LABEL_44;
      }
      else
      {
LABEL_44:
        if ( !LYisNonAlnumKeyname(response, 37) )
        {
          if ( response == 62 )
          {
            if ( no_option_save )
            {
              v32 = gettext(" 'r' to return to Lynx ");
              HTInfoMsg(v32);
              response = 32;
            }
            else
            {
              v29 = gettext("Saving Options...");
              HTInfoMsg(v29);
              if ( save_rc(0) )
              {
                v30 = gettext("Options saved!");
                HTInfoMsg(v30);
              }
              else
              {
                v31 = gettext("Unable to save Options!");
                HTAlert(v31);
              }
            }
          }
          else if ( LYisNonAlnumKeyname(response, 21) )
          {
            lynx_force_repaint();
          }
          else
          {
            if ( (response == 93 || LYisNonAlnumKeyname(response, 15)) && LYlines <= 32 )
            {
              if ( ++MBM_current > 2 )
                MBM_current = 1;
              goto draw_bookmark_list;
            }
            if ( (response == 91 || LYisNonAlnumKeyname(response, 16)) && LYlines <= 32 )
            {
              if ( --MBM_current <= 0 )
                MBM_current = 2;
              goto draw_bookmark_list;
            }
            for ( a = 0; a <= 25; ++a )
            {
              v33 = LYMBM2index(response);
              if ( v33 == a )
              {
                if ( LYlines <= 32 )
                {
                  if ( MBM_current == 1 && a > 12 )
                  {
                    MBM_current = 2;
                    def_response = response;
                    goto draw_bookmark_list;
                  }
                  if ( MBM_current == 2 && a <= 11 )
                  {
                    MBM_current = 1;
                    def_response = response;
                    goto draw_bookmark_list;
                  }
                }
                mustshow[0] = 1;
                v34 = gettext("Hit RETURN to accept entered data.");
                statusline(v34);
                if ( a > 0 )
                {
                  lynx_start_bold();
                  if ( LYlines > 32 )
                    LYmove(a + 3, 9);
                  else
                    LYmove(a + 3 + -13 * MBM_current + 13, 9);
                  if ( MBM_A_subdescript[a] )
                    LYstrncpy(MBM_tmp_line, MBM_A_subdescript[a], 255);
                  else
                    LYstrncpy(MBM_tmp_line, Msg, 255);
                  ch_0 = LYgetstr(MBM_tmp_line, 0, 0x100u, NORECALL);
                  lynx_stop_bold();
                  if ( MBM_tmp_line[0] )
                  {
                    HTSACopy(&MBM_A_subdescript[a], MBM_tmp_line);
                  }
                  else if ( MBM_A_subdescript[a] )
                  {
                    free(MBM_A_subdescript[a]);
                    MBM_A_subdescript[a] = 0;
                  }
                  if ( LYlines > 32 )
                    LYmove(a + 3, 5);
                  else
                    LYmove(a + 3 + -13 * MBM_current + 13, 5);
                  v35 = LYindex2MBM(a);
                  waddch(LYwin, v35);
                  LYwaddnstr(LYwin, " : ", 3u);
                  if ( MBM_A_subdescript[a] )
                  {
                    v36 = strlen(MBM_A_subdescript[a]);
                    LYwaddnstr(LYwin, MBM_A_subdescript[a], v36);
                  }
                  LYclrtoeol();
                  LYrefresh();
                }
                if ( LYlines > 32 )
                  LYmove(a + 3, 35);
                else
                  LYmove(a + 3 + -13 * MBM_current + 13, 35);
                LYwaddnstr(LYwin, "| ", 2u);
                lynx_start_bold();
                if ( MBM_A_subbookmark[a] )
                  LYstrncpy(MBM_tmp_line, MBM_A_subbookmark[a], 255);
                else
                  LYstrncpy(MBM_tmp_line, Msg, 255);
                ch_0 = LYgetstr(MBM_tmp_line, 0, 0x100u, NORECALL);
                lynx_stop_bold();
                if ( MBM_tmp_line[0] )
                {
                  if ( LYPathOffHomeOK(MBM_tmp_line, 0x100u) )
                  {
                    HTSACopy(&MBM_A_subbookmark[a], MBM_tmp_line);
                    if ( !a )
                      HTSACopy(&bookmark_page, MBM_A_subbookmark[0]);
                  }
                  else
                  {
                    v37 = gettext("Use a filepath off your home directory!");
                    LYMBM_statusline(v37);
                    LYSleepAlert();
                  }
                }
                else if ( a )
                {
                  if ( MBM_A_subbookmark[a] )
                  {
                    free(MBM_A_subbookmark[a]);
                    MBM_A_subbookmark[a] = 0;
                  }
                }
                else
                {
                  HTSACopy(MBM_A_subbookmark, bookmark_page);
                }
                if ( LYlines > 32 )
                  LYmove(a + 3, 35);
                else
                  LYmove(a + 3 + -13 * MBM_current + 13, 35);
                LYwaddnstr(LYwin, "| ", 2u);
                if ( MBM_A_subbookmark[a] )
                {
                  v38 = strlen(MBM_A_subbookmark[a]);
                  LYwaddnstr(LYwin, MBM_A_subbookmark[a], v38);
                }
                LYclrtoeol();
                LYmove(LYlines - 1, 0);
                LYclrtoeol();
                goto LABEL_112;
              }
            }
          }
        }
      }
    }
  }
  term_options[0] = 0;
  signal(2, cleanup_sig);
}

//----- (080A1E83) --------------------------------------------------------
int __cdecl popup_choice(
        int cur_choice,
        int line,
        int column,
        const char **choices,
        int i_length,
        int disabled,
        BOOLEAN for_mouse)
{
  char *v7; // eax
  char *v8; // eax
  int cur_choicea; // [esp+30h] [ebp+8h]

  if ( column < 0 )
    column = 35;
  term_options[0] = 0;
  cur_choicea = LYhandlePopupList(cur_choice, line, column, choices, -1, i_length, disabled, for_mouse);
  if ( (unsigned int)(cur_choicea - 13) <= 0x18 && ((1 << (cur_choicea - 13)) & 0x1000003) != 0 )
  {
    term_options[0] = 1;
    if ( !for_mouse )
    {
      v7 = gettext("Cancelled!!!");
      HTUserMsg(v7);
    }
  }
  if ( disabled || term_options[0] )
  {
    mustshow[0] = 1;
    statusline(Msg);
  }
  else if ( !for_mouse )
  {
    mustshow[0] = 1;
    v8 = gettext("Value accepted!");
    statusline(v8);
  }
  return cur_choicea;
}

//----- (080A1F74) --------------------------------------------------------
void __cdecl PutOptValues(FILE *fp, int value, OptValues *table)
{
  char *v3; // [esp+20h] [ebp-8h]
  const char *v4; // [esp+24h] [ebp-4h]

  while ( table->LongName )
  {
    if ( table->HtmlName )
    {
      v3 = gettext(table->LongName);
      if ( table->value == value )
        v4 = "selected";
      else
        v4 = Msg;
      fprintf(fp, "<option value=\"%s\" %s>%s\n", table->HtmlName, v4, v3);
    }
    ++table;
  }
}

//----- (080A1FEC) --------------------------------------------------------
BOOLEAN __cdecl GetOptValues(OptValues *table, char *value, int *result)
{
  while ( table->LongName )
  {
    if ( table->HtmlName && !strcmp(value, table->HtmlName) )
    {
      *result = table->value;
      return 1;
    }
    ++table;
  }
  return 0;
}

//----- (080A203F) --------------------------------------------------------
PostPair *__cdecl break_data(bstring *data)
{
  FILE *v1; // eax
  const char *value; // esi
  const char *tag; // ebx
  FILE *v4; // edx
  size_t len; // [esp+2Ch] [ebp-1Ch]
  size_t i; // [esp+30h] [ebp-18h]
  int count; // [esp+34h] [ebp-14h]
  PostPair *q; // [esp+38h] [ebp-10h]
  char *p; // [esp+3Ch] [ebp-Ch] BYREF

  count = 0;
  if ( !data || !data->len )
    return 0;
  p = data->str;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "break_data %s\n", p);
  }
  q = (PostPair *)calloc(1u, 8u);
  if ( !q )
    outofmem("./LYOptions.c", "break_data(calloc)");
  do
  {
    q[count].value = LYstrsep(&p, "&");
    q[count].tag = LYstrsep(&q[count].value, "=");
    HTUnEscape(q[count].tag);
    len = strlen(q[count].value);
    for ( i = 0; i < len; ++i )
    {
      if ( q[count].value[i] == 43 )
      {
        if ( i && q[count].value[i + 1] == 43 && ((*__ctype_b_loc())[(unsigned __int8)q[count].value[i + 2]] & 8) != 0 )
        {
          q[count].value[i] = 32;
          i += 2;
        }
        else
        {
          q[count].value[i] = 32;
        }
      }
    }
    HTUnEscape(q[count].value);
    if ( WWW_TraceFlag[0] )
    {
      value = q[count].value;
      tag = q[count].tag;
      v4 = TraceFP();
      fprintf(v4, "...item[%d] tag=%s, value=%s\n", count, tag, value);
    }
    q = (PostPair *)realloc(q, 8 * (++count + 1));
    if ( !q )
      outofmem("./LYOptions.c", "break_data(realloc)");
    q[count].tag = 0;
  }
  while ( p && *p );
  return q;
}
// 80A205F: conditional instruction was optimized away because %data.4!=0
// 80A207B: conditional instruction was optimized away because %data.4!=0

//----- (080A22E7) --------------------------------------------------------
BOOLEAN __cdecl isLynxOptionsPage(const char *address, const char *portion)
{
  int len; // [esp+20h] [ebp-8h]
  BOOLEAN result; // [esp+27h] [ebp-1h]
  const char *addressa; // [esp+30h] [ebp+8h]

  result = 0;
  if ( !strncasecomp(address, "LYNXOPTIONS:", 12) )
  {
    len = strlen(portion);
    addressa = address + 12;
    if ( !strncasecomp(addressa, portion, len) && (!addressa[len] || addressa[len] == 47) )
      return 1;
  }
  return result;
}

//----- (080A2367) --------------------------------------------------------
int __cdecl postoptions(DocInfo *newdoc)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  char *v18; // eax
  FILE *v19; // eax
  const char *src; // [esp+14h] [ebp-64h]
  const char *v23; // [esp+18h] [ebp-60h]
  const char *v24; // [esp+1Ch] [ebp-5Ch]
  int v25; // [esp+20h] [ebp-58h]
  DocAddress WWWDoc; // [esp+24h] [ebp-54h] BYREF
  int j_0; // [esp+38h] [ebp-40h]
  int newval_2; // [esp+3Ch] [ebp-3Ch]
  int newval_1; // [esp+40h] [ebp-38h]
  int j; // [esp+44h] [ebp-34h]
  int newval_0; // [esp+48h] [ebp-30h]
  int newval; // [esp+4Ch] [ebp-2Ch] BYREF
  int status; // [esp+50h] [ebp-28h]
  int CurrentShowColor; // [esp+54h] [ebp-24h]
  int old_media_value; // [esp+58h] [ebp-20h]
  int display_char_set_old; // [esp+5Ch] [ebp-1Ch]
  int code; // [esp+60h] [ebp-18h] BYREF
  int i; // [esp+64h] [ebp-14h]
  PostPair *data; // [esp+68h] [ebp-10h]
  BOOLEAN need_end_reload; // [esp+6Fh] [ebp-9h]
  BOOLEAN need_reload; // [esp+70h] [ebp-8h]
  BOOLEAN assume_char_set_changed; // [esp+71h] [ebp-7h]
  BOOLEAN raw_mode_old; // [esp+72h] [ebp-6h]
  BOOLEAN save_all; // [esp+73h] [ebp-5h]

  data = 0;
  code = 0;
  save_all = 0;
  display_char_set_old = current_char_set;
  old_media_value = LYAcceptMedia;
  raw_mode_old = LYRawMode[0];
  assume_char_set_changed = 0;
  need_reload = 0;
  need_end_reload = 0;
  CurrentShowColor = LYShowColor;
  if ( isLynxOptionsPage(newdoc->address, "//MBM_MENU") )
  {
    if ( newdoc->post_data )
    {
      free(newdoc->post_data);
      newdoc->post_data = 0;
    }
    if ( no_bookmark )
    {
      v1 = gettext("You are not allowed to change the bookmark file!");
      HTAlert(v1);
      return 3;
    }
    else if ( dump_output_immediately )
    {
      return 0;
    }
    else
    {
      edit_bookmarks();
      return 3;
    }
  }
  if ( !isLynxOptionsPage(newdoc->address, "/") )
  {
    v2 = gettext("Random URL is disallowed!  Use a shortcut.");
    HTAlert(v2);
    return 3;
  }
  data = break_data(newdoc->post_data);
  if ( !data )
  {
    status = gen_options(&newdoc->address);
    if ( status == 1 )
    {
      WWWDoc = *(DocAddress *)&newdoc->address;
      if ( HTLoadAbsolute(&WWWDoc) )
      {
        LYRegisterUIPage(newdoc->address, UIP_OPTIONS_MENU_0);
        lynx_edit_mode = 0;
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      HTAlwaysAlert("Unexpected way of accessing", newdoc->address);
      if ( newdoc->address )
      {
        free(newdoc->address);
        newdoc->address = 0;
      }
      return status;
    }
  }
  v3 = HTLoadedDocumentURL();
  if ( !LYIsUIPage3(v3, UIP_OPTIONS_MENU_0, 0) )
  {
    v4 = HTLoadedDocumentURL();
    if ( !LYIsUIPage3(v4, UIP_VLINKS_0, 0) )
    {
      newval = 0;
      v5 = key_for_func_ext(49, 0);
      v6 = gettext("Use %s to invoke the Options menu!");
      HTSprintf0((char **)&newval, v6, v5);
      HTAlert((const char *)newval);
      if ( newval )
      {
        free((void *)newval);
        newval = 0;
      }
      if ( data )
      {
        free(data);
        data = 0;
      }
      return 0;
    }
  }
  for ( i = 0; ; ++i )
  {
    if ( !data[i].tag )
    {
      LYFindLocaleCharset();
      if ( old_media_value != LYAcceptMedia )
        HTFilterPresentations();
      if ( display_char_set_old != current_char_set || raw_mode_old != LYRawMode[0] || assume_char_set_changed )
      {
        if ( display_char_set_old != current_char_set )
        {
          LYUseDefaultRawMode = 1;
          HTMLUseCharacterSet(current_char_set);
        }
        if ( assume_char_set_changed && HTCJK != JAPANESE )
          LYRawMode[0] = UCLYhndl_for_unspec == current_char_set;
        if ( raw_mode_old != LYRawMode[0] || assume_char_set_changed )
        {
          HTMLSetUseDefaultRawMode(current_char_set, LYRawMode[0]);
          HTMLSetCharacterHandling(current_char_set);
        }
        need_reload = 1;
      }
      HTSABFree(&newdoc->post_data);
      if ( data )
      {
        free(data);
        data = 0;
      }
      if ( save_all )
      {
        v10 = gettext("Saving Options...");
        HTInfoMsg(v10);
        LYrcShowColor = LYChosenShowColor;
        if ( save_rc(0) )
        {
          v11 = gettext("Options saved!");
          HTInfoMsg(v11);
        }
        else
        {
          v12 = gettext("Unable to save Options!");
          HTAlert(v12);
        }
      }
      if ( WWW_TraceFlag[0] )
      {
        v13 = TraceFP();
        fprintf(v13, "\nLYOptions.c/postoptions(): exiting...\n");
      }
      if ( WWW_TraceFlag[0] )
      {
        if ( need_reload )
          v23 = "TRUE";
        else
          v23 = "FALSE";
        v14 = TraceFP();
        fprintf(v14, "                            need_reload = %s\n", v23);
      }
      if ( WWW_TraceFlag[0] )
      {
        if ( need_end_reload )
          v24 = "TRUE";
        else
          v24 = "FALSE";
        v15 = TraceFP();
        fprintf(v15, "                            need_end_reload = %s\n", v24);
      }
      LYpop(newdoc);
      WWWDoc = *(DocAddress *)&newdoc->address;
      LYforce_no_cache = 0;
      LYoverride_no_cache = 1;
      if ( !HTLoadAbsolute(&WWWDoc) )
        return 0;
      HTuncache_current_document();
      LYpop(newdoc);
      WWWDoc = *(DocAddress *)&newdoc->address;
      LYforce_no_cache = 0;
      LYoverride_no_cache = 1;
      if ( !HTLoadAbsolute(&WWWDoc) )
        return 0;
      reloading[0] = 0;
      if ( need_end_reload == 1 )
      {
        if ( !strncmp(newdoc->address, "http", 4u)
          || (*newdoc->address != 108 && *newdoc->address != 76 || strncasecomp(newdoc->address, "lynxcgi:", 8) ? (v25 = 0) : (v25 = 1),
              !v25) )
        {
          reloading[0] = 1;
          need_reload = 1;
        }
      }
      if ( need_reload )
      {
        if ( HTisDocumentSource() )
          srcmode_for_next_retrieval(1);
        if ( reloading[0] || !(unsigned __int8)HTcan_reparse_document() )
        {
          if ( !newdoc->post_data || newdoc->safe || confirm_post_resub(newdoc->address, newdoc->title, 2, 1) )
          {
            HEAD_request = HTLoadedDocumentIsHEAD();
            HTuncache_current_document();
            LYpush(newdoc, 0);
            if ( WWW_TraceFlag[0] )
            {
              v19 = TraceFP();
              fprintf(v19, "LYOptions.c/postoptions(): now really exit.\n\n");
            }
            return 3;
          }
          else
          {
            v18 = gettext("Document will not be reloaded!");
            HTInfoMsg(v18);
            if ( HTisDocumentSource() )
              srcmode_for_next_retrieval(0);
            return 1;
          }
        }
        else
        {
          if ( !HTreparse_document() )
            srcmode_for_next_retrieval(0);
          if ( WWW_TraceFlag[0] )
          {
            v17 = TraceFP();
            fprintf(v17, "LYOptions.c/postoptions(): now really exit.\n\n");
          }
          return 1;
        }
      }
      else
      {
        if ( WWW_TraceFlag[0] )
        {
          v16 = TraceFP();
          fprintf(v16, "LYOptions.c/postoptions(): now really exit.\n\n");
        }
        return 1;
      }
    }
    if ( !strcmp(data[i].tag, secure_string) )
      break;
LABEL_35:
    if ( !strcmp(data[i].tag, save_options_string) && !no_option_save )
      save_all = 1;
    if ( !strcmp(data[i].tag, cookies_string) )
    {
      if ( !strcmp(data[i].value, cookies_ignore_all_string) )
      {
        LYSetCookies = 0;
      }
      else if ( !strcmp(data[i].value, cookies_up_to_user_string) )
      {
        LYSetCookies = 1;
        LYAcceptAllCookies = 0;
      }
      else if ( !strcmp(data[i].value, cookies_accept_all_string) )
      {
        LYSetCookies = 1;
        LYAcceptAllCookies = 1;
      }
    }
    if ( !strcmp(data[i].tag, x_display_string) )
    {
      LYsetXDisplay(data[i].value);
      validate_x_display();
      summarize_x_display(data[i].value);
    }
    if ( !strcmp(data[i].tag, editor_string) )
    {
      if ( editor )
      {
        free(editor);
        editor = 0;
      }
      HTSACopy(&editor, data[i].value);
    }
    if ( !strcmp(data[i].tag, emacs_keys_string) && GetOptValues(bool_values, data[i].value, &code) )
    {
      emacs_keys = code;
      if ( (_BYTE)code )
        set_emacs_keys();
      else
        reset_emacs_keys();
    }
    if ( !strcmp(data[i].tag, keypad_mode_string) )
    {
      newval = 0;
      if ( GetOptValues(keypad_mode_values, data[i].value, &newval) )
      {
        if ( keypad_mode != newval )
        {
          keypad_mode = newval;
          need_reload = 1;
          if ( newval )
            reset_numbers_as_arrows();
          else
            set_numbers_as_arrows();
        }
      }
    }
    if ( !strcmp(data[i].tag, lineedit_mode_string) )
    {
      newval_0 = atoi(data[i].value);
      for ( j = 0; LYLineeditNames[j]; ++j )
      {
        if ( j == newval_0 )
          current_lineedit = newval_0;
      }
    }
    if ( !strcmp(data[i].tag, mail_address_string) )
    {
      if ( personal_mail_address )
      {
        free(personal_mail_address);
        personal_mail_address = 0;
      }
      HTSACopy(&personal_mail_address, data[i].value);
    }
    if ( !strcmp(data[i].tag, anonftp_password_string) )
    {
      if ( anonftp_password )
      {
        free(anonftp_password);
        anonftp_password = 0;
      }
      HTSACopy(&anonftp_password, data[i].value);
    }
    if ( !strcmp(data[i].tag, search_type_string) && GetOptValues(search_type_values, data[i].value, &code) )
      case_sensitive = code;
    if ( !strcmp(data[i].tag, DTD_recovery_string)
      && GetOptValues(DTD_type_values, data[i].value, &code)
      && Old_DTD != code )
    {
      Old_DTD = code;
      HTSwitchDTD(code == 0);
      need_reload = 1;
    }
    if ( !strcmp(data[i].tag, select_popups_string) && GetOptValues(bool_values, data[i].value, &code) )
      LYSelectPopups = code;
    if ( !strcmp(data[i].tag, show_color_string) && GetOptValues(show_color_values, data[i].value, &LYChosenShowColor) )
    {
      if ( can_do_colors[0] )
        LYShowColor = LYChosenShowColor;
      if ( CurrentShowColor != LYShowColor )
        lynx_force_repaint();
      CurrentShowColor = LYShowColor;
    }
    if ( !strcmp(data[i].tag, show_cursor_string) && GetOptValues(bool_values, data[i].value, &code) )
      LYShowCursor = code;
    if ( !strcmp(data[i].tag, underline_links_string) && GetOptValues(bool_values, data[i].value, &code) )
      LYUnderlineLinks = code;
    if ( !strcmp(data[i].tag, show_scrollbar_string) && GetOptValues(bool_values, data[i].value, &code) )
    {
      LYShowScrollbar = code;
      need_reload = 1;
    }
    if ( !strcmp(data[i].tag, cookie_prompt_string) )
      GetOptValues(prompt_values, data[i].value, &cookie_noprompt);
    if ( !strcmp(data[i].tag, user_mode_string) && GetOptValues(user_mode_values, data[i].value, &user_mode) )
      LYSetDisplayLines();
    if ( !strcmp(data[i].tag, visited_links_string) )
      GetOptValues(visited_links_values, data[i].value, &Visited_Links_As);
    if ( !strcmp(data[i].tag, images_string) )
    {
      if ( !strcmp(data[i].value, images_ignore_all_string) && (pseudo_inline_alts || clickable_images) )
      {
        pseudo_inline_alts = 0;
        clickable_images = 0;
        need_reload = 1;
      }
      else if ( !strcmp(data[i].value, images_use_label_string) && (pseudo_inline_alts != 1 || clickable_images) )
      {
        pseudo_inline_alts = 1;
        clickable_images = 0;
        need_reload = 1;
      }
      else if ( !strcmp(data[i].value, images_use_links_string) && clickable_images != 1 )
      {
        clickable_images = 1;
        need_reload = 1;
      }
    }
    if ( !strcmp(data[i].tag, verbose_images_string)
      && GetOptValues(verbose_images_type_values, data[i].value, &code)
      && verbose_img != code )
    {
      verbose_img = code;
      need_reload = 1;
    }
    if ( !strcmp(data[i].tag, vi_keys_string) && GetOptValues(bool_values, data[i].value, &code) )
    {
      vi_keys = code;
      if ( (_BYTE)code )
        set_vi_keys();
      else
        reset_vi_keys();
    }
    if ( !strcmp(data[i].tag, mbm_string) && !LYMBMBlocked )
      GetOptValues(mbm_values, data[i].value, &LYMultiBookmarks);
    if ( !strcmp(data[i].tag, single_bookmark_string) && !no_bookmark && *data[i].value )
    {
      if ( bookmark_page )
      {
        free(bookmark_page);
        bookmark_page = 0;
      }
      HTSACopy(&bookmark_page, data[i].value);
    }
    if ( !strcmp(data[i].tag, assume_char_set_string) )
    {
      newval_1 = UCGetLYhndl_byMIME(data[i].value);
      if ( newval_1 >= 0
        && (raw_mode_old && safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset) != newval_1
         || !raw_mode_old && newval_1 != UCLYhndl_for_unspec) )
      {
        UCLYhndl_for_unspec = newval_1;
        HTSACopy(&UCAssume_MIMEcharset, data[i].value);
        assume_char_set_changed = 1;
      }
    }
    if ( !strcmp(data[i].tag, locale_charset_string) && GetOptValues(bool_values, data[i].value, &code) )
      LYLocaleCharset = code;
    if ( !strcmp(data[i].tag, display_char_set_string) )
    {
      newval_2 = atoi(data[i].value);
      for ( j_0 = 0; LYchar_set_names[j_0]; ++j_0 )
      {
        if ( j_0 == newval_2 )
          current_char_set = newval_2;
      }
    }
    if ( !strcmp(data[i].tag, raw_mode_string) && GetOptValues(bool_values, data[i].value, &code) )
      LYRawMode[0] = code;
    if ( !strcmp(data[i].tag, passive_ftp_string) )
      ftp_passive = code;
    if ( !strcmp(data[i].tag, ftp_sort_string) )
      GetOptValues(ftp_sort_values, data[i].value, &HTfileSortMethod);
    if ( !strcmp(data[i].tag, dired_list_string) )
      GetOptValues(dired_list_values, data[i].value, &dir_list_style);
    if ( !strcmp(data[i].tag, dired_sort_string) )
      GetOptValues(dired_sort_values, data[i].value, &dir_list_order);
    if ( !strcmp(data[i].tag, show_dotfiles_string) && !no_dotfiles && GetOptValues(bool_values, data[i].value, &code) )
      show_dotfiles = code;
    if ( !strcmp(data[i].tag, show_rate_string) && GetOptValues(rate_values, data[i].value, &code) )
      LYTransferRate = code;
    if ( !strcmp(data[i].tag, preferred_media_string) )
      GetOptValues(media_values, data[i].value, &LYAcceptMedia);
    if ( !strcmp(data[i].tag, preferred_encoding_string) )
      GetOptValues(encoding_values, data[i].value, &LYAcceptEncoding);
    if ( !strcmp(data[i].tag, preferred_doc_char_string) && strcmp(pref_charset, data[i].value) )
    {
      if ( pref_charset )
      {
        free(pref_charset);
        pref_charset = 0;
      }
      HTSACopy(&pref_charset, data[i].value);
      need_end_reload = 1;
    }
    if ( !strcmp(data[i].tag, preferred_doc_lang_string) && strcmp(language, data[i].value) )
    {
      if ( language )
      {
        free(language);
        language = 0;
      }
      HTSACopy(&language, data[i].value);
      need_end_reload = 1;
    }
    if ( !strcmp(data[i].tag, user_agent_string) && !no_useragent[0] && strcmp(LYUserAgent, data[i].value) )
    {
      need_end_reload = 1;
      if ( LYUserAgent )
      {
        free(LYUserAgent);
        LYUserAgent = 0;
      }
      if ( *data[i].value )
        src = data[i].value;
      else
        src = LYUserAgentDefault;
      HTSACopy(&LYUserAgent, src);
      if ( !LYCheckUserAgent() )
      {
        v9 = gettext("Use \"L_y_n_x\" or \"Lynx\" in User-Agent, or it looks like intentional deception!");
        HTAlert(v9);
      }
    }
  }
  if ( secure_value && !strcmp(data[i].value, secure_value) )
  {
    if ( secure_value )
    {
      free(secure_value);
      secure_value = 0;
    }
    goto LABEL_35;
  }
  newval = 0;
  v7 = key_for_func_ext(49, 0);
  v8 = gettext("Use %s to invoke the Options menu!");
  HTSprintf0((char **)&newval, v8, v7);
  HTAlert((const char *)newval);
  if ( data )
  {
    free(data);
    data = 0;
  }
  return 3;
}

//----- (080A3AF0) --------------------------------------------------------
char *NewSecureValue()
{
  int key; // [esp+24h] [ebp-4h]

  if ( secure_value )
  {
    free(secure_value);
    secure_value = 0;
  }
  secure_value = (char *)malloc(0x50u);
  if ( !secure_value )
    return oops_14639;
  key = random();
  sprintf(secure_value, "%ld", key);
  return secure_value;
}

//----- (080A3B6B) --------------------------------------------------------
void __cdecl PutLabel(FILE *fp, const char *name, const char *value)
{
  int v5; // [esp+4h] [ebp-24h]
  const char *v6; // [esp+14h] [ebp-14h]
  int need; // [esp+1Ch] [ebp-Ch]

  v5 = strlen(name);
  need = LYstrExtent(name, v5, 33);
  if ( no_margins )
    v6 = Msg;
  else
    v6 = "&nbsp;&nbsp;";
  fprintf(fp, "%s%s", v6, name);
  if ( !will_save_rc(value) || no_option_save )
  {
    if ( need < 30 )
    {
      fwrite("&nbsp;", 1u, 6u, fp);
      ++need;
    }
    fwrite("(!)", 1u, 3u, fp);
    while ( need++ < 30 )
      fwrite("&nbsp;", 1u, 6u, fp);
  }
  else
  {
    while ( need++ < 33 )
      fwrite("&nbsp;", 1u, 6u, fp);
  }
  fwrite(": ", 1u, 2u, fp);
}

//----- (080A3CE4) --------------------------------------------------------
const char *__cdecl check_if_write_lynxrc(const char **table)
{
  const char *result; // [esp+10h] [ebp-8h]
  int n; // [esp+14h] [ebp-4h]

  result = 0;
  for ( n = 0; table[n]; ++n )
  {
    result = table[n];
    if ( !will_save_rc(result) )
      break;
  }
  return result;
}

//----- (080A3D2F) --------------------------------------------------------
const char *will_save_cookies()
{
  return check_if_write_lynxrc(table_14706);
}

//----- (080A3D43) --------------------------------------------------------
const char *will_save_images()
{
  return check_if_write_lynxrc(table_14713);
}

//----- (080A3D57) --------------------------------------------------------
void __cdecl LYMenuVisitedLinks(FILE *fp0, int disable_all)
{
  const char *v2; // [esp+14h] [ebp-4h]

  if ( disable_all )
    v2 = "disabled";
  else
    v2 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", visited_links_string, v2);
  PutOptValues(fp0, Visited_Links_As, visited_links_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
}

//----- (080A3DD7) --------------------------------------------------------
int __cdecl gen_options(char **newfile)
{
  char *v1; // eax
  const char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  const char *v9; // ebx
  char *v10; // eax
  const char *v11; // ebx
  char *v12; // eax
  const char *v13; // ebx
  char *v14; // eax
  const char *v15; // ebx
  char *v16; // eax
  const char *v17; // ebx
  char *v18; // eax
  const char *v19; // ebx
  char *v20; // eax
  const char *v21; // ebx
  char *v22; // eax
  const char *v23; // ebx
  char *v24; // eax
  const char *v25; // ebx
  char *v26; // eax
  const char *v27; // ebx
  char *v28; // eax
  const char *v29; // ebx
  char *v30; // eax
  const char *v31; // ebx
  char *v32; // eax
  const char *v33; // ebx
  char *v34; // eax
  const char *v35; // ebx
  char *v36; // eax
  const char *v37; // ebx
  char *v38; // eax
  const char *v39; // ebx
  char *v40; // eax
  const char *v41; // ebx
  char *v42; // eax
  const char *v43; // ebx
  char *v44; // eax
  const char *v45; // ebx
  char *v46; // eax
  const char *v47; // ebx
  char *v48; // eax
  const char *v49; // ebx
  char *v50; // eax
  const char *v51; // ebx
  char *v52; // eax
  const char *v53; // ebx
  char *v54; // eax
  const char *v55; // ebx
  char *v56; // eax
  const char *v57; // ebx
  char *v58; // eax
  const char *v59; // ebx
  char *v60; // eax
  const char *v61; // ebx
  char *v62; // eax
  const char *v63; // ebx
  char *v64; // eax
  const char *v65; // ebx
  char *v66; // eax
  const char *v67; // ebx
  char *v68; // eax
  const char *v69; // ebx
  char *v70; // eax
  const char *v71; // ebx
  char *v72; // eax
  const char *v73; // ebx
  char *v74; // eax
  const char *v75; // ebx
  char *v76; // eax
  const char *v77; // ebx
  char *v78; // eax
  const char *v79; // eax
  const char *v80; // ebx
  char *v81; // eax
  const char *v82; // ebx
  char *v83; // eax
  char *v84; // eax
  const char *v85; // ebx
  char *v86; // eax
  const char *v87; // ebx
  char *v88; // eax
  char *v89; // eax
  char *v90; // eax
  char *v91; // eax
  char *v92; // eax
  size_t v94; // [esp+1Ch] [ebp-1ACh]
  int v95; // [esp+24h] [ebp-1A4h]
  char *v97; // [esp+2Ch] [ebp-19Ch]
  const char *v98; // [esp+30h] [ebp-198h]
  const char *v99; // [esp+34h] [ebp-194h]
  const char *v100; // [esp+38h] [ebp-190h]
  const char *v101; // [esp+3Ch] [ebp-18Ch]
  const char *v102; // [esp+40h] [ebp-188h]
  const char *v103; // [esp+44h] [ebp-184h]
  char *v104; // [esp+48h] [ebp-180h]
  const char *v105; // [esp+4Ch] [ebp-17Ch]
  const char *v106; // [esp+50h] [ebp-178h]
  char *v107; // [esp+54h] [ebp-174h]
  const char *v108; // [esp+58h] [ebp-170h]
  char *v109; // [esp+5Ch] [ebp-16Ch]
  const char *v110; // [esp+60h] [ebp-168h]
  char *v111; // [esp+64h] [ebp-164h]
  const char *v112; // [esp+68h] [ebp-160h]
  const char *v113; // [esp+6Ch] [ebp-15Ch]
  char *v114; // [esp+70h] [ebp-158h]
  const char *v115; // [esp+74h] [ebp-154h]
  const char *v116; // [esp+78h] [ebp-150h]
  const char *v117; // [esp+7Ch] [ebp-14Ch]
  const char *v118; // [esp+80h] [ebp-148h]
  const char *v119; // [esp+84h] [ebp-144h]
  char *v120; // [esp+88h] [ebp-140h]
  const char *v121; // [esp+8Ch] [ebp-13Ch]
  char *v122; // [esp+90h] [ebp-138h]
  const char *v123; // [esp+94h] [ebp-134h]
  const char *v124; // [esp+98h] [ebp-130h]
  const char *v125; // [esp+9Ch] [ebp-12Ch]
  const char *v126; // [esp+A0h] [ebp-128h]
  char *v127; // [esp+A4h] [ebp-124h]
  const char *v128; // [esp+A8h] [ebp-120h]
  const char *v129; // [esp+ACh] [ebp-11Ch]
  char *v130; // [esp+B0h] [ebp-118h]
  const char *v131; // [esp+B4h] [ebp-114h]
  const char *v132; // [esp+B8h] [ebp-110h]
  const char *v133; // [esp+BCh] [ebp-10Ch]
  const char *v134; // [esp+C0h] [ebp-108h]
  char *v135; // [esp+C4h] [ebp-104h]
  const char *v136; // [esp+C8h] [ebp-100h]
  const char *v137; // [esp+CCh] [ebp-FCh]
  const char *v138; // [esp+D0h] [ebp-F8h]
  const char *v139; // [esp+D4h] [ebp-F4h]
  const char *v140; // [esp+D8h] [ebp-F0h]
  const char *v141; // [esp+DCh] [ebp-ECh]
  const char *v142; // [esp+E0h] [ebp-E8h]
  const char *v143; // [esp+E4h] [ebp-E4h]
  const char *v144; // [esp+E8h] [ebp-E0h]
  const char *v145; // [esp+ECh] [ebp-DCh]
  char *v146; // [esp+F0h] [ebp-D8h]
  const char *v147; // [esp+F4h] [ebp-D4h]
  char *v148; // [esp+F8h] [ebp-D0h]
  const char *v149; // [esp+FCh] [ebp-CCh]
  char *v150; // [esp+100h] [ebp-C8h]
  const char *v151; // [esp+104h] [ebp-C4h]
  const char *v152; // [esp+108h] [ebp-C0h]
  char *v153; // [esp+10Ch] [ebp-BCh]
  const char *v154; // [esp+110h] [ebp-B8h]
  const char *v155; // [esp+114h] [ebp-B4h]
  const char *v156; // [esp+118h] [ebp-B0h]
  const char *v157; // [esp+11Ch] [ebp-ACh]
  const char *v158; // [esp+120h] [ebp-A8h]
  const char *v159; // [esp+124h] [ebp-A4h]
  const char *v160; // [esp+128h] [ebp-A0h]
  const char *v161; // [esp+12Ch] [ebp-9Ch]
  const char *v162; // [esp+130h] [ebp-98h]
  const char *v163; // [esp+134h] [ebp-94h]
  const char *v164; // [esp+138h] [ebp-90h]
  const char *v165; // [esp+13Ch] [ebp-8Ch]
  const char *v166; // [esp+140h] [ebp-88h]
  char *v167; // [esp+144h] [ebp-84h]
  const char *v168; // [esp+148h] [ebp-80h]
  const char *v169; // [esp+14Ch] [ebp-7Ch]
  const char *v170; // [esp+150h] [ebp-78h]
  const char *v171; // [esp+154h] [ebp-74h]
  const char *v172; // [esp+158h] [ebp-70h]
  const char *v173; // [esp+15Ch] [ebp-6Ch]
  const char *v174; // [esp+160h] [ebp-68h]
  char *v175; // [esp+164h] [ebp-64h]
  const char *v176; // [esp+168h] [ebp-60h]
  char *v177; // [esp+16Ch] [ebp-5Ch]
  const char *v178; // [esp+170h] [ebp-58h]
  const char *v179; // [esp+174h] [ebp-54h]
  const char *v180; // [esp+178h] [ebp-50h]
  const char *v181; // [esp+17Ch] [ebp-4Ch]
  char *message; // [esp+190h] [ebp-38h] BYREF
  int curval; // [esp+194h] [ebp-34h]
  size_t len; // [esp+198h] [ebp-30h]
  size_t text_len; // [esp+19Ch] [ebp-2Ch]
  size_t cset_len; // [esp+1A0h] [ebp-28h]
  FILE *fp0; // [esp+1A4h] [ebp-24h]
  int i; // [esp+1A8h] [ebp-20h]
  BOOLEAN disable_all; // [esp+1AFh] [ebp-19h]
  char temp[16]; // [esp+1B0h] [ebp-18h] BYREF
  unsigned int v191; // [esp+1C0h] [ebp-8h]

  v191 = __readgsdword(0x14u);
  disable_all = 0;
  cset_len = 0;
  if ( LYcols - (LYShowScrollbar != 0) <= 45 )
  {
    v94 = 7;
  }
  else
  {
    if ( no_margins )
      v95 = 35;
    else
      v95 = 37;
    v94 = LYcols - (LYShowScrollbar != 0) - v95;
  }
  text_len = v94;
  fp0 = InternalPageFP(tempfile_14731, 1);
  if ( !fp0 )
    return 0;
  LYLocalFileToURL(newfile, tempfile_14731);
  LYforce_no_cache = 1;
  if ( !LYUseFormsOptions )
    disable_all = 1;
  v1 = gettext("Options Menu");
  BeginInternalPage(fp0, v1, 0);
  fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", "LYNXOPTIONS:");
  v2 = NewSecureValue();
  fprintf(fp0, "<input name=\"%s\" type=\"hidden\" value=\"%s\">\n", secure_string, v2);
  fwrite("<p align=center>\n", 1u, 0x11u, fp0);
  if ( !disable_all )
  {
    v3 = gettext("Accept Changes");
    fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", v3);
    v4 = gettext("Reset Changes");
    fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", v4);
    v5 = gettext("Left Arrow cancels changes");
    fprintf(fp0, "%s - \n", v5);
  }
  v6 = gettext("HELP!");
  fprintf(fp0, "<a href=\"%s%s\">%s</a>\n", helpfilepath, "keystrokes/option_help.html.gz", v6);
  if ( !no_option_save )
  {
    if ( !disable_all )
    {
      v7 = gettext("Save options to disk");
      fprintf(fp0, "<p align=center>%s: ", v7);
      fprintf(fp0, "<input type=\"checkbox\" name=\"%s\">\n", save_options_string);
    }
    v8 = gettext("(options marked with (!) will not be saved)");
    fprintf(fp0, "<br>%s\n", v8);
  }
  fwrite("<pre>\n", 1u, 6u, fp0);
  v97 = gettext("General Preferences");
  if ( no_margins )
    v98 = Msg;
  else
    v98 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v98, v97);
  v9 = user_mode_string;
  v10 = gettext("User mode");
  PutLabel(fp0, v10, v9);
  if ( disable_all )
    v99 = "disabled";
  else
    v99 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", user_mode_string, v99);
  PutOptValues(fp0, user_mode, user_mode_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v11 = editor_string;
  v12 = gettext("Editor");
  PutLabel(fp0, v12, v11);
  if ( disable_all )
  {
    v100 = "disabled";
  }
  else
  {
    if ( no_editor || system_editor )
      v101 = "disabled";
    else
      v101 = Msg;
    v100 = v101;
  }
  if ( editor )
    v102 = editor;
  else
    v102 = Msg;
  fprintf(fp0, "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n", text_len, editor_string, v102, v100);
  v13 = search_type_string;
  v14 = gettext("Type of Search");
  PutLabel(fp0, v14, v13);
  if ( disable_all )
    v103 = "disabled";
  else
    v103 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", search_type_string, v103);
  PutOptValues(fp0, case_sensitive, search_type_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v104 = gettext("Security and Privacy");
  if ( no_margins )
    v105 = Msg;
  else
    v105 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v105, v104);
  v15 = will_save_cookies();
  v16 = gettext("Cookies");
  PutLabel(fp0, v16, v15);
  if ( disable_all )
    v106 = "disabled";
  else
    v106 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", cookies_string, v106);
  v107 = gettext(cookies_ignore_all_string);
  if ( LYSetCookies )
    v108 = Msg;
  else
    v108 = "selected";
  fprintf(fp0, "<option value=\"%s\" %s>%s\n", cookies_ignore_all_string, v108, v107);
  v109 = gettext(cookies_up_to_user_string);
  if ( !LYSetCookies || LYAcceptAllCookies )
    v110 = Msg;
  else
    v110 = "selected";
  fprintf(fp0, "<option value=\"%s\" %s>%s\n", cookies_up_to_user_string, v110, v109);
  v111 = gettext(cookies_accept_all_string);
  if ( LYSetCookies && LYAcceptAllCookies )
    v112 = "selected";
  else
    v112 = Msg;
  fprintf(fp0, "<option value=\"%s\" %s>%s\n", cookies_accept_all_string, v112, v111);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v17 = cookie_prompt_string;
  v18 = gettext("Invalid-Cookie Prompting");
  PutLabel(fp0, v18, v17);
  if ( disable_all )
    v113 = "disabled";
  else
    v113 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", cookie_prompt_string, v113);
  PutOptValues(fp0, cookie_noprompt, prompt_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v114 = gettext("Keyboard Input");
  if ( no_margins )
    v115 = Msg;
  else
    v115 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v115, v114);
  v19 = keypad_mode_string;
  v20 = gettext("Keypad mode");
  PutLabel(fp0, v20, v19);
  if ( disable_all )
    v116 = "disabled";
  else
    v116 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", keypad_mode_string, v116);
  PutOptValues(fp0, keypad_mode, keypad_mode_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v21 = emacs_keys_string;
  v22 = gettext("Emacs keys");
  PutLabel(fp0, v22, v21);
  if ( disable_all )
    v117 = "disabled";
  else
    v117 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", emacs_keys_string, v117);
  PutOptValues(fp0, emacs_keys, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v23 = vi_keys_string;
  v24 = gettext("VI keys");
  PutLabel(fp0, v24, v23);
  if ( disable_all )
    v118 = "disabled";
  else
    v118 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", vi_keys_string, v118);
  PutOptValues(fp0, vi_keys, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  if ( LYLineeditNames[1] )
  {
    v25 = lineedit_mode_string;
    v26 = gettext("Line edit style");
    PutLabel(fp0, v26, v25);
    if ( disable_all )
      v119 = "disabled";
    else
      v119 = Msg;
    fprintf(fp0, "<select name=\"%s\" %s>\n", lineedit_mode_string, v119);
    for ( i = 0; LYLineeditNames[i]; ++i )
    {
      sprintf(temp, "%d", i);
      v120 = gettext(LYLineeditNames[i]);
      if ( i == current_lineedit )
        v121 = "selected";
      else
        v121 = Msg;
      fprintf(fp0, "<option value=\"%s\" %s>%s\n", temp, v121, v120);
    }
    fwrite("</select>\n", 1u, 0xAu, fp0);
  }
  v122 = gettext("Display and Character Set");
  if ( no_margins )
    v123 = Msg;
  else
    v123 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v123, v122);
  v27 = locale_charset_string;
  v28 = gettext("Use locale-based character set");
  PutLabel(fp0, v28, v27);
  if ( disable_all )
    v124 = "disabled";
  else
    v124 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", locale_charset_string, v124);
  PutOptValues(fp0, LYLocaleCharset, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v29 = display_char_set_string;
  v30 = gettext("Display character set");
  PutLabel(fp0, v30, v29);
  if ( disable_all )
  {
    v125 = "disabled";
  }
  else
  {
    if ( LYLocaleCharset )
      v126 = "disabled";
    else
      v126 = Msg;
    v125 = v126;
  }
  fprintf(fp0, "<select name=\"%s\" %s>\n", display_char_set_string, v125);
  for ( i = 0; LYchar_set_names[i]; ++i )
  {
    len = strlen(LYchar_set_names[i]);
    if ( len > cset_len )
      cset_len = len;
    sprintf(temp, "%d", i);
    v127 = gettext(LYchar_set_names[i]);
    if ( i == current_char_set )
      v128 = "selected";
    else
      v128 = Msg;
    fprintf(fp0, "<option value=\"%s\" %s>%s\n", temp, v128, v127);
  }
  fwrite("</select>\n", 1u, 0xAu, fp0);
  curval = UCLYhndl_for_unspec;
  if ( UCLYhndl_for_unspec == current_char_set )
    curval = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
  v31 = assume_char_set_string;
  v32 = gettext("Assumed document character set");
  PutLabel(fp0, v32, v31);
  if ( disable_all )
    v129 = "disabled";
  else
    v129 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", assume_char_set_string, v129);
  for ( i = 0; i < LYNumCharsets; ++i )
  {
    v130 = gettext(LYCharSet_UC[i].MIMEname);
    if ( i == curval )
      v131 = "selected";
    else
      v131 = Msg;
    fprintf(fp0, "<option value=\"%s\" %s>%s\n", LYCharSet_UC[i].MIMEname, v131, v130);
  }
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v33 = raw_mode_string;
  if ( LYHaveCJKCharacterSet )
    v34 = gettext("CJK mode");
  else
    v34 = gettext("Raw 8-bit");
  PutLabel(fp0, v34, v33);
  if ( disable_all )
    v132 = "disabled";
  else
    v132 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", raw_mode_string, v132);
  PutOptValues(fp0, LYRawMode[0], bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v35 = x_display_string;
  v36 = gettext("X Display");
  PutLabel(fp0, v36, v35);
  if ( disable_all )
    v133 = "disabled";
  else
    v133 = Msg;
  if ( x_display )
    v134 = x_display;
  else
    v134 = Msg;
  fprintf(fp0, "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n", text_len, x_display_string, v134, v133);
  v135 = gettext("Document Appearance");
  if ( no_margins )
    v136 = Msg;
  else
    v136 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v136, v135);
  SetupChosenShowColor();
  v37 = show_color_string;
  v38 = gettext("Show color");
  PutLabel(fp0, v38, v37);
  if ( no_option_save )
  {
    if ( disable_all )
    {
      v137 = "disabled";
    }
    else
    {
      if ( can_do_colors[0] )
        v138 = Msg;
      else
        v138 = "disabled";
      v137 = v138;
    }
    fprintf(fp0, "<select name=\"%s\" %s>\n", show_color_string, v137);
    if ( LYShowColor )
    {
      if ( LYShowColor == 3 )
        LYShowColor = 2;
    }
    else
    {
      LYShowColor = 1;
    }
    PutOptValues(fp0, LYShowColor - 1, bool_values);
  }
  else
  {
    if ( disable_all )
      v139 = "disabled";
    else
      v139 = Msg;
    fprintf(fp0, "<select name=\"%s\" %s>\n", show_color_string, v139);
    if ( can_do_colors[0] )
    {
      show_color_values[2].HtmlName = "ON";
      show_color_values[3].LongName = "ALWAYS";
    }
    else
    {
      show_color_values[2].HtmlName = 0;
      show_color_values[3].LongName = "Always try";
    }
    PutOptValues(fp0, LYChosenShowColor, show_color_values);
  }
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v39 = show_cursor_string;
  v40 = gettext("Show cursor");
  PutLabel(fp0, v40, v39);
  if ( disable_all )
    v140 = "disabled";
  else
    v140 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", show_cursor_string, v140);
  PutOptValues(fp0, LYShowCursor, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v41 = underline_links_string;
  v42 = gettext("Underline links");
  PutLabel(fp0, v42, v41);
  if ( disable_all )
    v141 = "disabled";
  else
    v141 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", underline_links_string, v141);
  PutOptValues(fp0, LYUnderlineLinks, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v43 = show_scrollbar_string;
  v44 = gettext("Show scrollbar");
  PutLabel(fp0, v44, v43);
  if ( disable_all )
    v142 = "disabled";
  else
    v142 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", show_scrollbar_string, v142);
  PutOptValues(fp0, LYShowScrollbar, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v45 = select_popups_string;
  v46 = gettext("Popups for select fields");
  PutLabel(fp0, v46, v45);
  if ( disable_all )
    v143 = "disabled";
  else
    v143 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", select_popups_string, v143);
  PutOptValues(fp0, LYSelectPopups, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v47 = DTD_recovery_string;
  v48 = gettext("HTML error recovery");
  PutLabel(fp0, v48, v47);
  if ( disable_all )
    v144 = "disabled";
  else
    v144 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", DTD_recovery_string, v144);
  PutOptValues(fp0, Old_DTD, DTD_type_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v49 = will_save_images();
  v50 = gettext("Show images");
  PutLabel(fp0, v50, v49);
  if ( disable_all )
    v145 = "disabled";
  else
    v145 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", images_string, v145);
  v146 = gettext(images_ignore_all_string);
  if ( pseudo_inline_alts || clickable_images )
    v147 = Msg;
  else
    v147 = "selected";
  fprintf(fp0, "<option value=\"%s\" %s>%s\n", images_ignore_all_string, v147, v146);
  v148 = gettext(images_use_label_string);
  if ( !pseudo_inline_alts || clickable_images )
    v149 = Msg;
  else
    v149 = "selected";
  fprintf(fp0, "<option value=\"%s\" %s>%s\n", images_use_label_string, v149, v148);
  v150 = gettext(images_use_links_string);
  if ( clickable_images )
    v151 = "selected";
  else
    v151 = Msg;
  fprintf(fp0, "<option value=\"%s\" %s>%s\n", images_use_links_string, v151, v150);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v51 = verbose_images_string;
  v52 = gettext("Verbose images");
  PutLabel(fp0, v52, v51);
  if ( disable_all )
    v152 = "disabled";
  else
    v152 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", verbose_images_string, v152);
  PutOptValues(fp0, verbose_img, verbose_images_type_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v153 = gettext("Headers Transferred to Remote Servers");
  if ( no_margins )
    v154 = Msg;
  else
    v154 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v154, v153);
  v53 = mail_address_string;
  v54 = gettext("Personal mail address");
  PutLabel(fp0, v54, v53);
  if ( disable_all )
    v155 = "disabled";
  else
    v155 = Msg;
  if ( personal_mail_address )
    v156 = personal_mail_address;
  else
    v156 = Msg;
  fprintf(fp0, "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n", text_len, mail_address_string, v156, v155);
  v55 = mail_address_string;
  v56 = gettext("Password for anonymous ftp");
  PutLabel(fp0, v56, v55);
  if ( disable_all )
    v157 = "disabled";
  else
    v157 = Msg;
  if ( anonftp_password )
    v158 = anonftp_password;
  else
    v158 = Msg;
  fprintf(
    fp0,
    "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",
    text_len,
    anonftp_password_string,
    v158,
    v157);
  v57 = preferred_media_string;
  v58 = gettext("Preferred media type");
  PutLabel(fp0, v58, v57);
  if ( disable_all )
    v159 = "disabled";
  else
    v159 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", preferred_media_string, v159);
  PutOptValues(fp0, LYAcceptMedia, media_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v59 = preferred_encoding_string;
  v60 = gettext("Preferred encoding");
  PutLabel(fp0, v60, v59);
  if ( disable_all )
    v160 = "disabled";
  else
    v160 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", preferred_encoding_string, v160);
  PutOptValues(fp0, LYAcceptEncoding, encoding_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v61 = preferred_doc_char_string;
  v62 = gettext("Preferred document character set");
  PutLabel(fp0, v62, v61);
  if ( disable_all )
    v161 = "disabled";
  else
    v161 = Msg;
  if ( pref_charset )
    v162 = pref_charset;
  else
    v162 = Msg;
  fprintf(
    fp0,
    "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",
    cset_len + 2,
    preferred_doc_char_string,
    v162,
    v161);
  v63 = preferred_doc_lang_string;
  v64 = gettext("Preferred document language");
  PutLabel(fp0, v64, v63);
  if ( disable_all )
    v163 = "disabled";
  else
    v163 = Msg;
  if ( language )
    v164 = language;
  else
    v164 = Msg;
  fprintf(
    fp0,
    "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",
    cset_len + 2,
    preferred_doc_lang_string,
    v164,
    v163);
  if ( !no_useragent[0] )
  {
    v65 = user_agent_string;
    v66 = gettext("User-Agent header");
    PutLabel(fp0, v66, v65);
    if ( disable_all )
      v165 = "disabled";
    else
      v165 = Msg;
    if ( LYUserAgent )
      v166 = LYUserAgent;
    else
      v166 = Msg;
    fprintf(fp0, "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n", text_len, user_agent_string, v166, v165);
  }
  v167 = gettext("Listing and Accessing Files");
  if ( no_margins )
    v168 = Msg;
  else
    v168 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v168, v167);
  v67 = passive_ftp_string;
  v68 = gettext("Use Passive FTP");
  PutLabel(fp0, v68, v67);
  if ( disable_all )
    v169 = "disabled";
  else
    v169 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", passive_ftp_string, v169);
  PutOptValues(fp0, ftp_passive, bool_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v69 = ftp_sort_string;
  v70 = gettext("FTP sort criteria");
  PutLabel(fp0, v70, v69);
  if ( disable_all )
    v170 = "disabled";
  else
    v170 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", ftp_sort_string, v170);
  PutOptValues(fp0, HTfileSortMethod, ftp_sort_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v71 = dired_list_string;
  v72 = gettext("Local directory sort criteria");
  PutLabel(fp0, v72, v71);
  if ( disable_all )
    v171 = "disabled";
  else
    v171 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", dired_list_string, v171);
  PutOptValues(fp0, dir_list_style, dired_list_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v73 = dired_sort_string;
  v74 = gettext("Local directory sort order");
  PutLabel(fp0, v74, v73);
  if ( disable_all )
    v172 = "disabled";
  else
    v172 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", dired_sort_string, v172);
  PutOptValues(fp0, dir_list_order, dired_sort_values);
  fwrite("</select>\n", 1u, 0xAu, fp0);
  if ( !no_dotfiles )
  {
    v75 = show_dotfiles_string;
    v76 = gettext("Show dot files");
    PutLabel(fp0, v76, v75);
    if ( disable_all )
      v173 = "disabled";
    else
      v173 = Msg;
    fprintf(fp0, "<select name=\"%s\" %s>\n", show_dotfiles_string, v173);
    PutOptValues(fp0, show_dotfiles, bool_values);
    fwrite("</select>\n", 1u, 0xAu, fp0);
  }
  v77 = show_rate_string;
  v78 = gettext("Show transfer rate");
  PutLabel(fp0, v78, v77);
  if ( disable_all )
    v174 = "disabled";
  else
    v174 = Msg;
  fprintf(fp0, "<select name=\"%s\" %s>\n", show_rate_string, v174);
  for ( i = 0; rate_values[i].LongName; ++i )
  {
    message = 0;
    v79 = HTProgressUnits(rate_values[i].value);
    HTSprintf0(&message, rate_values[i].LongName, v79);
    v175 = gettext(message);
    if ( rate_values[i].value == LYTransferRate )
      v176 = "selected";
    else
      v176 = Msg;
    fprintf(fp0, "<option value=\"%s\" %s>%s\n", rate_values[i].HtmlName, v176, v175);
    if ( message )
    {
      free(message);
      message = 0;
    }
  }
  fwrite("</select>\n", 1u, 0xAu, fp0);
  v177 = gettext("Special Files and Screens");
  if ( no_margins )
    v178 = Msg;
  else
    v178 = "&nbsp;&nbsp;";
  fprintf(fp0, "\n%s<em>%s</em>\n", v178, v177);
  if ( !LYMBMBlocked )
  {
    v80 = mbm_string;
    v81 = gettext("Multi-bookmarks");
    PutLabel(fp0, v81, v80);
    if ( disable_all )
      v179 = "disabled";
    else
      v179 = Msg;
    fprintf(fp0, "<select name=\"%s\" %s>\n", mbm_string, v179);
    PutOptValues(fp0, LYMultiBookmarks, mbm_values);
    fwrite("</select>\n", 1u, 0xAu, fp0);
  }
  if ( LYMultiBookmarks )
  {
    v82 = mbm_string;
    v83 = gettext("Review/edit Bookmarks files");
    PutLabel(fp0, v83, v82);
    v84 = gettext("Goto multi-bookmark menu");
    fprintf(fp0, "<a href=\"%s\">%s</a>\n", "LYNXOPTIONS://MBM_MENU", v84);
  }
  else
  {
    v85 = single_bookmark_string;
    v86 = gettext("Bookmarks file");
    PutLabel(fp0, v86, v85);
    if ( disable_all )
      v180 = "disabled";
    else
      v180 = Msg;
    if ( bookmark_page )
      v181 = bookmark_page;
    else
      v181 = Msg;
    fprintf(
      fp0,
      "<input size=%d type=\"text\" name=\"%s\" value=\"%s\" %s>\n",
      text_len,
      single_bookmark_string,
      v181,
      v180);
  }
  v87 = visited_links_string;
  v88 = gettext("Visited Pages");
  PutLabel(fp0, v88, v87);
  LYMenuVisitedLinks(fp0, disable_all);
  if ( !no_lynxcfg_info )
  {
    v89 = gettext("View the file ");
    fprintf(fp0, "\n  %s<a href=\"%s\">lynx.cfg</a>.\n", v89, "LYNXCFG:");
  }
  fwrite("\n</pre>\n", 1u, 8u, fp0);
  if ( !disable_all )
  {
    fwrite("<p align=center>\n", 1u, 0x11u, fp0);
    v90 = gettext("Accept Changes");
    fprintf(fp0, "<input type=\"submit\" value=\"%s\"> - \n", v90);
    v91 = gettext("Reset Changes");
    fprintf(fp0, "<input type=\"reset\" value=\"%s\"> - \n", v91);
    v92 = gettext("Left Arrow cancels changes");
    fprintf(fp0, "%s\n", v92);
  }
  fwrite("</form>\n", 1u, 8u, fp0);
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  return 1;
}

//----- (080A6360) --------------------------------------------------------
BOOLEAN __cdecl is_true(char *string)
{
  return !strcasecomp(string, "TRUE") || !strcasecomp(string, "ON");
}

//----- (080A63A4) --------------------------------------------------------
char *__cdecl find_colon(char *buffer)
{
  char *buf; // [esp+Ch] [ebp-8h]
  char ch_0; // [esp+13h] [ebp-1h]

  buf = buffer;
  if ( !buffer )
    return 0;
  while ( 1 )
  {
    ch_0 = *buf;
    if ( !*buf )
      break;
    if ( ch_0 == 58 )
      return buf;
    if ( ch_0 == 92 && !*++buf )
      break;
    ++buf;
  }
  return 0;
}

//----- (080A6400) --------------------------------------------------------
void __cdecl free_item_list(lynx_list_item_type **ptr)
{
  lynx_list_item_type *next; // [esp+10h] [ebp-8h]
  lynx_list_item_type *cur; // [esp+14h] [ebp-4h]

  for ( cur = *ptr; cur; cur = next )
  {
    next = cur->next;
    if ( cur->name )
    {
      free(cur->name);
      cur->name = 0;
    }
    if ( cur->command )
    {
      free(cur->command);
      cur->command = 0;
    }
    free(cur);
  }
  *ptr = 0;
}
// 80A6460: conditional instruction was optimized away because %cur.4!=0

//----- (080A648B) --------------------------------------------------------
void free_all_item_lists()
{
  free_item_list(&printers);
  free_item_list(&downloaders);
  free_item_list(&uploaders);
  free_item_list(&externals);
}

//----- (080A64C3) --------------------------------------------------------
void __cdecl add_item_to_list(char *buffer, lynx_list_item_type **list_ptr, int special)
{
  bool v3; // al
  lynx_list_item_type *prev_item; // [esp+24h] [ebp-14h]
  lynx_list_item_type *cur_item; // [esp+28h] [ebp-10h]
  char *last_colon; // [esp+2Ch] [ebp-Ch]
  char *last_colona; // [esp+2Ch] [ebp-Ch]
  char *next_colon; // [esp+30h] [ebp-8h]
  char *next_colona; // [esp+30h] [ebp-8h]
  char *next_colonb; // [esp+30h] [ebp-8h]
  char *colon; // [esp+34h] [ebp-4h]
  char *colona; // [esp+34h] [ebp-4h]

  last_colon = strrchr(buffer, 58);
  if ( last_colon && *(last_colon - 1) != 92 )
  {
    *last_colon = 0;
    last_colona = last_colon + 1;
    if ( strcasecomp(last_colona, "XWINDOWS") )
    {
      if ( !strcasecomp(last_colona, "NON_XWINDOWS") && LYgetXDisplay() )
        return;
    }
    else if ( !LYgetXDisplay() )
    {
      return;
    }
  }
  if ( *list_ptr )
  {
    for ( prev_item = *list_ptr; prev_item->next; prev_item = prev_item->next )
      ;
    cur_item = (lynx_list_item_type *)calloc(1u, 0x18u);
    if ( !cur_item )
      outofmem("./LYReadCFG.c", "read_cfg");
    prev_item->next = cur_item;
  }
  else
  {
    cur_item = (lynx_list_item_type *)calloc(1u, 0x18u);
    if ( !cur_item )
      outofmem("./LYReadCFG.c", "read_cfg");
    *list_ptr = cur_item;
  }
  cur_item->next = 0;
  cur_item->name = 0;
  cur_item->command = 0;
  cur_item->always_enabled = 0;
  cur_item->override_primary_action = 0;
  cur_item->pagelen = 66;
  colon = find_colon(buffer);
  if ( colon )
  {
    cur_item->name = (char *)calloc(colon - buffer + 1, 1u);
    if ( !cur_item->name )
      outofmem("./LYReadCFG.c", "read_cfg");
    LYstrncpy(cur_item->name, buffer, colon - buffer);
    remove_backslashes(cur_item->name);
    next_colon = find_colon(colon + 1);
    if ( !next_colon )
      next_colon = &colon[strlen(colon)];
    if ( next_colon - (colon + 1) > 0 )
    {
      cur_item->command = (char *)calloc(next_colon - colon, 1u);
      if ( !cur_item->command )
        outofmem("./LYReadCFG.c", "read_cfg");
      LYstrncpy(cur_item->command, colon + 1, next_colon - (colon + 1));
      remove_backslashes(cur_item->command);
    }
    v3 = *next_colon != 0;
    next_colona = next_colon + 1;
    if ( v3 )
    {
      colona = next_colona;
      next_colonb = strchr(next_colona, 58);
      if ( next_colonb )
        *next_colonb++ = 0;
      cur_item->always_enabled = is_true(colona);
      if ( next_colonb )
      {
        if ( special )
          cur_item->pagelen = atoi(next_colonb);
        else
          cur_item->override_primary_action = is_true(next_colonb);
      }
    }
  }
}

//----- (080A67DF) --------------------------------------------------------
lynx_list_item_type *__cdecl find_item_by_number(lynx_list_item_type *list_ptr, char *number)
{
  bool v2; // al
  int value; // [esp+14h] [ebp-4h]

  value = atoi(number);
  while ( 1 )
  {
    v2 = value-- >= 0;
    if ( !v2 || !list_ptr )
      break;
    list_ptr = list_ptr->next;
  }
  return list_ptr;
}

//----- (080A681B) --------------------------------------------------------
int __cdecl match_item_by_name(lynx_list_item_type *ptr, char *name, BOOLEAN only_overriders)
{
  int v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+10h] [ebp-8h]

  v5 = 0;
  if ( ptr->command )
  {
    v4 = strlen(ptr->name);
    if ( !strncasecomp(ptr->name, name, v4) && (!only_overriders || ptr->override_primary_action) )
      return 1;
  }
  return v5;
}

//----- (080A6884) --------------------------------------------------------
int __cdecl check_color(char *color, int the_default)
{
  FILE *v2; // edx
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  int i; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    v2 = TraceFP();
    fprintf(v2, "check_color(%s,%d)\n", color, the_default);
  }
  if ( strcasecomp(color, "default") )
  {
    if ( strcasecomp(color, "nocolor") )
    {
      for ( i = 0; ; ++i )
      {
        if ( i > 15 )
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
          {
            v5 = TraceFP();
            fprintf(v5, "=> ERR_COLOR\n");
          }
          return -3;
        }
        if ( !strcasecomp(color, Color_Strings[i]) )
          break;
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v4 = TraceFP();
        fprintf(v4, "=> %d\n", i);
      }
      return i;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    if ( LYuse_default_colors && !default_color_reset[0] )
      the_default = -1;
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "=> default %d\n", the_default);
    }
    return the_default;
  }
}

//----- (080A6A0C) --------------------------------------------------------
const char *__cdecl lookup_color(int code)
{
  unsigned int n; // [esp+10h] [ebp-4h]

  for ( n = 0; n <= 0xF; ++n )
  {
    if ( n == code )
      return Color_Strings[n];
  }
  return "default";
}

//----- (080A6A48) --------------------------------------------------------
void __cdecl __noreturn exit_with_color_syntax(char *error_line)
{
  char *v1; // eax
  char *v2; // eax
  unsigned int i; // [esp+2Ch] [ebp-Ch]

  v1 = gettext(
         "Syntax Error parsing COLOR in configuration file:\n"
         "The line must be of the form:\n"
         "COLOR:INTEGER:FOREGROUND:BACKGROUND\n"
         "\n"
         "Here FOREGROUND and BACKGROUND must be one of:\n"
         "The special strings 'nocolor' or 'default', or\n");
  fprintf(stderr, v1);
  for ( i = 0; i <= 0xF; i += 4 )
    fprintf(
      stderr,
      "%16s %16s %16s %16s\n",
      Color_Strings[i],
      Color_Strings[i + 1],
      Color_Strings[i + 2],
      Color_Strings[i + 3]);
  v2 = gettext("Offending line:");
  fprintf(stderr, "%s\nCOLOR:%s\n", v2, error_line);
  exit_immediately(1);
}

//----- (080A6B18) --------------------------------------------------------
void __cdecl parse_color(char *buffer)
{
  int v1; // ebx
  int v2; // eax
  char *temp; // [esp+14h] [ebp-14h] BYREF
  char *bg; // [esp+18h] [ebp-10h]
  char *fg; // [esp+1Ch] [ebp-Ch]
  int color; // [esp+20h] [ebp-8h]

  temp = 0;
  HTSACopy(&temp, buffer);
  color = atoi(buffer);
  fg = find_colon(buffer);
  if ( !fg )
    exit_with_color_syntax(temp);
  *fg++ = 0;
  bg = find_colon(fg);
  if ( !bg )
    exit_with_color_syntax(temp);
  *bg++ = 0;
  v1 = check_color(bg, default_bg);
  v2 = check_color(fg, default_fg);
  if ( lynx_chg_color(color, v2, v1) < 0 )
    exit_with_color_syntax(temp);
  if ( temp )
    free(temp);
}

//----- (080A6C03) --------------------------------------------------------
int __cdecl assume_charset_fun_0(char *value)
{
  UCLYhndl_for_unspec = safeUCGetLYhndl_byMIME(value);
  HTSACopy(&UCAssume_MIMEcharset, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
  return 0;
}

//----- (080A6C3E) --------------------------------------------------------
int __cdecl assume_local_charset_fun_0(char *value)
{
  UCLYhndl_HTFile_for_unspec = safeUCGetLYhndl_byMIME(value);
  return 0;
}

//----- (080A6C5B) --------------------------------------------------------
int __cdecl assume_unrec_charset_fun_0(char *value)
{
  UCLYhndl_for_unrec = safeUCGetLYhndl_byMIME(value);
  return 0;
}

//----- (080A6C78) --------------------------------------------------------
int __cdecl character_set_fun(char *value)
{
  int i; // [esp+14h] [ebp-4h]

  i = UCGetLYhndl_byAnyName(value);
  if ( i >= 0 )
    current_char_set = i;
  return 0;
}

//----- (080A6CA1) --------------------------------------------------------
int __cdecl outgoing_mail_charset_fun(char *value)
{
  outgoing_mail_charset = UCGetLYhndl_byMIME(value);
  return 0;
}

//----- (080A6CBE) --------------------------------------------------------
int __cdecl assumed_color_fun(char *buffer)
{
  FILE *v1; // eax
  char *temp; // [esp+Ch] [ebp-Ch] BYREF
  char *bg; // [esp+10h] [ebp-8h]
  char *fg; // [esp+14h] [ebp-4h]

  fg = buffer;
  temp = 0;
  if ( LYuse_default_colors )
  {
    HTSACopy(&temp, buffer);
    bg = find_colon(fg);
    if ( !bg )
      exit_with_color_syntax(temp);
    *bg++ = 0;
    default_fg = check_color(fg, default_fg);
    default_bg = check_color(bg, default_bg);
    if ( default_fg == -3 || default_bg == -3 )
      exit_with_color_syntax(temp);
    if ( temp )
    {
      free(temp);
      temp = 0;
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "...ignored since DEFAULT_COLORS:off\n");
  }
  return 0;
}

//----- (080A6DB0) --------------------------------------------------------
int __cdecl color_fun(char *value)
{
  parse_color(value);
  return 0;
}

//----- (080A6DC8) --------------------------------------------------------
int __cdecl default_colors_fun(char *value)
{
  LYuse_default_colors = is_true(value);
  if ( LYuse_default_colors )
  {
    default_fg = -1;
    default_bg = -1;
  }
  else
  {
    default_color_reset[0] = 1;
    if ( default_fg == -1 || default_bg == -1 )
    {
      default_fg = 7;
      default_bg = 0;
      lynx_setup_colors();
    }
  }
  return 0;
}

//----- (080A6E3A) --------------------------------------------------------
int __cdecl default_bookmark_file_fun(char *value)
{
  set_default_bookmark_page(value);
  return 0;
}

//----- (080A6E52) --------------------------------------------------------
int __cdecl default_cache_size_fun(char *value)
{
  HTCacheSize = atoi(value);
  if ( HTCacheSize <= 1 )
    HTCacheSize = 2;
  return 0;
}

//----- (080A6E83) --------------------------------------------------------
int __cdecl default_editor_fun(char *value)
{
  if ( !system_editor )
    HTSACopy(&editor, value);
  return 0;
}

//----- (080A6EAE) --------------------------------------------------------
int __cdecl numbers_as_arrows_fun(char *value)
{
  keypad_mode = is_true(value) == 0;
  return 0;
}

//----- (080A6EE0) --------------------------------------------------------
int __cdecl dired_menu_fun(char *value)
{
  add_menu_item(value);
  return 0;
}

//----- (080A6EF8) --------------------------------------------------------
int __cdecl jumpfile_fun(char *value)
{
  char *v1; // ebx
  FILE *v2; // eax
  char *buffer; // [esp+20h] [ebp-8h] BYREF

  buffer = 0;
  HTSprintf0(&buffer, "JUMPFILE:%s", value);
  if ( !LYJumpInit(buffer) && WWW_TraceFlag[0] )
  {
    v1 = buffer;
    v2 = TraceFP();
    fprintf(v2, "Failed to register %s\n", v1);
  }
  if ( buffer )
  {
    free(buffer);
    buffer = 0;
  }
  return 0;
}

//----- (080A6F7C) --------------------------------------------------------
int __cdecl keymap_fun(char *key)
{
  char *v1; // edx
  char *v2; // edx
  char *v3; // ebx
  char *v4; // edx
  int v5; // eax
  char *v6; // edx
  char *v7; // edx
  char *v8; // edx
  char *v10; // [esp+4h] [ebp-44h]
  char *v11; // [esp+4h] [ebp-44h]
  char *s; // [esp+20h] [ebp-28h]
  char *sselect_edi; // [esp+28h] [ebp-20h] BYREF
  int select_edi; // [esp+2Ch] [ebp-1Ch]
  int lec; // [esp+30h] [ebp-18h]
  int lkc; // [esp+34h] [ebp-14h]
  char *efunc; // [esp+38h] [ebp-10h]
  char *func; // [esp+3Ch] [ebp-Ch]
  BOOLEAN success; // [esp+43h] [ebp-5h]

  func = strchr(key, 58);
  if ( !func )
    return 0;
  *func++ = 0;
  efunc = strchr(func, 58);
  if ( efunc == func )
  {
    func = 0;
  }
  else
  {
    if ( efunc && !strncasecomp(efunc + 1, "DIRED", 5) )
    {
      v10 = strtok(func, " \t\n:#");
      if ( remap(key, v10, 1) )
      {
        if ( func && !strcmp("TOGGLE_HELP", func) )
          LYUseNoviceLineTwo = 0;
      }
      else
      {
        v1 = gettext("key remapping of %s to %s for %s failed\n");
        fprintf(stderr, v1, key, func, efunc + 1);
      }
      return 0;
    }
    v11 = strtok(func, " \t\n:#");
    if ( remap(key, v11, 0) )
    {
      if ( func && !strcmp("TOGGLE_HELP", func) )
        LYUseNoviceLineTwo = 0;
    }
    else
    {
      v2 = gettext("key remapping of %s to %s failed\n");
      fprintf(stderr, v2, key, func);
    }
  }
  if ( !efunc )
    return 0;
  s = func ? 0 : ++efunc;
  if ( strtok(s, " \t\n:#") != efunc || !*efunc )
    return 0;
  success = 0;
  lkc = lkcstring_to_lkc(key);
  lec = -1;
  select_edi = 0;
  sselect_edi = strtok(0, " \t\n:#");
  if ( sselect_edi )
  {
    if ( *sselect_edi )
      select_edi = strtol(sselect_edi, &sselect_edi, 10);
    if ( *sselect_edi )
    {
      v3 = sselect_edi;
      v4 = gettext("invalid line-editor selection %s for key %s, selecting all\n");
      fprintf(stderr, v4, v3, key);
      select_edi = 0;
    }
  }
  if ( success || strcasecomp(efunc, "PASS!") )
    goto LABEL_35;
  if ( func )
  {
    v5 = lacname_to_lac(func);
    BYTE1(v5) |= 0x10u;
    lec = v5;
    success = LYRemapEditBinding(lkc, v5, select_edi);
  }
  if ( !success )
  {
    v6 = gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n");
    fprintf(stderr, v6, key, lkc, lec, efunc);
LABEL_35:
    if ( !success )
    {
      lec = lecname_to_lec(efunc);
      success = LYRemapEditBinding(lkc, lec, select_edi);
    }
    if ( !success )
    {
      if ( lec == -1 )
      {
        v8 = gettext("setting of line-editor binding for key %s (0x%x) for %s failed\n");
        fprintf(stderr, v8, key, lkc, efunc);
      }
      else
      {
        v7 = gettext("setting of line-editor binding for key %s (0x%x) to 0x%x for %s failed\n");
        fprintf(stderr, v7, key, lkc, lec, efunc);
      }
    }
  }
  return 0;
}

//----- (080A7381) --------------------------------------------------------
int __cdecl localhost_alias_fun(char *value)
{
  LYAddLocalhostAlias(value);
  return 0;
}

//----- (080A7399) --------------------------------------------------------
int __cdecl lynxcgi_environment_fun(char *value)
{
  add_lynxcgi_environment(value);
  return 0;
}

//----- (080A73B1) --------------------------------------------------------
int __cdecl lynx_sig_file_fun(char *value)
{
  const char *v1; // ebx
  FILE *v2; // eax
  FILE *v3; // eax
  char temp[256]; // [esp+20h] [ebp-108h] BYREF
  unsigned int v6; // [esp+120h] [ebp-8h]

  v6 = __readgsdword(0x14u);
  LYstrncpy(temp, value, 255);
  if ( LYPathOffHomeOK(temp, 0x100u) )
  {
    HTSACopy(&LynxSigFile, temp);
    LYAddPathToHome(temp, 0x100u, LynxSigFile);
    HTSACopy(&LynxSigFile, temp);
    if ( WWW_TraceFlag[0] )
    {
      v1 = LynxSigFile;
      v2 = TraceFP();
      fprintf(v2, "LYNX_SIG_FILE set to '%s'\n", v1);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "LYNX_SIG_FILE '%s' is bad. Ignoring.\n", ".lynxsig");
  }
  return 0;
}

//----- (080A74CB) --------------------------------------------------------
int __cdecl news_chunk_size_fun(char *value)
{
  HTNewsChunkSize = atoi(value);
  if ( HTNewsChunkSize > HTNewsMaxChunk )
    HTNewsMaxChunk = HTNewsChunkSize;
  return 0;
}

//----- (080A7501) --------------------------------------------------------
int __cdecl news_max_chunk_fun(char *value)
{
  HTNewsMaxChunk = atoi(value);
  if ( HTNewsChunkSize > HTNewsMaxChunk )
    HTNewsChunkSize = HTNewsMaxChunk;
  return 0;
}

//----- (080A7537) --------------------------------------------------------
int __cdecl news_posting_fun(char *value)
{
  LYNewsPosting = is_true(value);
  no_newspost = LYNewsPosting == 0;
  return 0;
}

//----- (080A7565) --------------------------------------------------------
int __cdecl cern_rulesfile_fun(char *value)
{
  char *v1; // eax
  char *v3; // [esp+14h] [ebp-14h]
  char *rulesfile2; // [esp+20h] [ebp-8h] BYREF
  char *rulesfile1; // [esp+24h] [ebp-4h] BYREF

  rulesfile1 = 0;
  rulesfile2 = 0;
  if ( HTLoadRules(value) < 0 )
  {
    HTSACopy(&rulesfile1, value);
    LYTrimLeading(value);
    LYTrimTrailing(value);
    HTSACopy(&rulesfile2, value);
    LYTildeExpand(&rulesfile2, 0);
    if ( !strcmp(rulesfile1, rulesfile2) || HTLoadRules(rulesfile2) < 0 )
    {
      if ( rulesfile2 && *rulesfile2 )
        v3 = rulesfile2;
      else
        v3 = gettext("(no name)");
      v1 = gettext("Lynx: cannot start, CERN rules file %s is not available\n");
      fprintf(stderr, v1, v3);
      exit_immediately(1);
    }
    if ( rulesfile1 )
    {
      free(rulesfile1);
      rulesfile1 = 0;
    }
    if ( rulesfile2 )
    {
      free(rulesfile2);
      rulesfile2 = 0;
    }
  }
  return 0;
}

//----- (080A76A6) --------------------------------------------------------
int __cdecl referer_with_query_fun(char *value)
{
  if ( strncasecomp(value, "SEND", 4) )
  {
    if ( strncasecomp(value, "PARTIAL", 7) )
      LYRefererWithQuery[0] = 68;
    else
      LYRefererWithQuery[0] = 80;
  }
  else
  {
    LYRefererWithQuery[0] = 83;
  }
  return 0;
}

//----- (080A770A) --------------------------------------------------------
int __cdecl suffix_fun(char *value)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // edx
  const char *v5; // [esp+24h] [ebp-34h]
  double df_0; // [esp+30h] [ebp-28h]
  char *description; // [esp+44h] [ebp-14h]
  char *sq; // [esp+48h] [ebp-10h]
  char *encoding; // [esp+4Ch] [ebp-Ch]
  char *p; // [esp+50h] [ebp-8h] BYREF
  char *mime_type; // [esp+54h] [ebp-4h]

  encoding = 0;
  sq = 0;
  description = 0;
  if ( strlen(value) > 2 && (mime_type = strchr(value, 58)) != 0 )
  {
    *mime_type++ = 0;
    if ( *mime_type )
    {
      encoding = strchr(mime_type, 58);
      if ( encoding )
      {
        *encoding++ = 0;
        sq = strchr(encoding, 58);
        if ( sq )
        {
          *sq++ = 0;
          description = strchr(sq, 58);
          if ( description )
          {
            *description++ = 0;
            p = strchr(sq, 58);
            if ( p )
              *p = 0;
            LYTrimTail(description);
          }
          LYRemoveBlanks(sq);
          if ( !*sq )
            sq = 0;
        }
        LYRemoveBlanks(encoding);
        LYLowerCase(encoding);
        if ( !*encoding )
          encoding = 0;
      }
    }
    LYRemoveBlanks(mime_type);
    if ( *mime_type )
      goto LABEL_24;
    if ( WWW_TraceFlag[0] )
    {
      if ( encoding )
        v5 = encoding;
      else
        v5 = "what?";
      v2 = TraceFP();
      fprintf(v2, "SUFFIX:%s without MIME type for %s\n", value, v5);
    }
    mime_type = 0;
    if ( encoding )
    {
LABEL_24:
      if ( !encoding )
      {
        if ( strstr(mime_type, "tex")
          || strstr(mime_type, "postscript")
          || strstr(mime_type, "sh")
          || strstr(mime_type, "troff")
          || strstr(mime_type, "rtf") )
        {
          encoding = "8bit";
        }
        else
        {
          encoding = "binary";
        }
      }
      if ( sq )
      {
        df_0 = strtod(sq, &p);
        if ( p == sq && df_0 <= 0.0 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v3 = TraceFP();
            fprintf(v3, "Invalid q=%s for SUFFIX:%s, using -1.0\n", sq, value);
          }
          HTSetSuffix5(value, mime_type, encoding, description, -1.0);
        }
        else
        {
          HTSetSuffix5(value, mime_type, encoding, description, df_0);
        }
      }
      else
      {
        HTSetSuffix5(value, mime_type, encoding, description, 1.0);
      }
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "Invalid SUFFIX:%s ignored.\n", value);
  }
  return 0;
}

//----- (080A7A3E) --------------------------------------------------------
int __cdecl suffix_order_fun(char *value)
{
  FILE *v1; // eax
  const char *optn; // [esp+1Ch] [ebp-Ch]
  char *p; // [esp+20h] [ebp-8h] BYREF
  BOOLEAN want_file_init_now; // [esp+27h] [ebp-1h]

  p = value;
  want_file_init_now = 0;
  LYUseBuiltinSuffixes = 1;
  while ( 1 )
  {
    optn = HTNextTok(&p, ", ", &bracks, 0);
    if ( !optn )
      break;
    if ( strcasecomp(optn, "NO_BUILTIN") )
    {
      if ( strcasecomp(optn, "PRECEDENCE_HERE") )
      {
        if ( strcasecomp(optn, "PRECEDENCE_OTHER") )
        {
          if ( WWW_TraceFlag[0] )
          {
            v1 = TraceFP();
            fprintf(v1, "Invalid SUFFIX_ORDER:%s\n", optn);
          }
          break;
        }
        want_file_init_now = 0;
      }
      else
      {
        want_file_init_now = 1;
      }
    }
    else
    {
      LYUseBuiltinSuffixes = 0;
    }
  }
  if ( want_file_init_now && !FileInitAlreadyDone )
  {
    HTFileInit();
    FileInitAlreadyDone = 1;
  }
  return 0;
}

//----- (080A7B33) --------------------------------------------------------
int __cdecl system_editor_fun(char *value)
{
  HTSACopy(&editor, value);
  system_editor = 1;
  return 0;
}

//----- (080A7B5A) --------------------------------------------------------
int __cdecl viewer_fun(char *value)
{
  char *environment; // [esp+3Ch] [ebp-Ch]
  char *environmenta; // [esp+3Ch] [ebp-Ch]
  char *viewer; // [esp+40h] [ebp-8h]
  char *viewera; // [esp+40h] [ebp-8h]

  if ( strlen(value) > 2 )
  {
    viewer = strchr(value, 58);
    if ( viewer )
    {
      *viewer = 0;
      viewera = viewer + 1;
      LYRemoveBlanks(value);
      LYLowerCase(value);
      environment = strrchr(viewera, 58);
      if ( !environment || strlen(viewera) <= 1 || *(environment - 1) == 92 )
      {
        remove_backslashes(viewera);
        HTSetPresentation(value, viewera, 0, 1.0, 3.0, 0.0, 0, mediaCFG_0);
        return 0;
      }
      *environment = 0;
      environmenta = environment + 1;
      remove_backslashes(viewera);
      if ( strcasecomp(environmenta, "XWINDOWS") )
      {
        if ( !strcasecomp(environmenta, "NON_XWINDOWS") && LYgetXDisplay() )
          return 0;
      }
      else if ( !LYgetXDisplay() )
      {
        return 0;
      }
      HTSetPresentation(value, viewera, 0, 1.0, 3.0, 0.0, 0, mediaCFG_0);
    }
  }
  return 0;
}

//----- (080A7D83) --------------------------------------------------------
int __cdecl nonrest_sigwinch_fun(char *value)
{
  if ( strncasecomp(value, "XWINDOWS", 8) )
    LYNonRestartingSIGWINCH = is_true(value);
  else
    LYNonRestartingSIGWINCH = LYgetXDisplay() != 0;
  return 0;
}

//----- (080A7DD0) --------------------------------------------------------
void __cdecl __noreturn html_src_bad_syntax(char *value, char *option_name)
{
  char *buf; // [esp+24h] [ebp-4h] BYREF

  buf = 0;
  HTSprintf0(&buf, "HTMLSRC_%s", option_name);
  LYUpperCase(buf);
  fprintf(stderr, "Bad syntax in TAGSPEC %s:%s\n", buf, value);
  exit_immediately(1);
}

//----- (080A7E34) --------------------------------------------------------
int __cdecl parse_html_src_spec(HTlexeme lexeme_code, char *value, char *option_name)
{
  FILE *v3; // edx
  char *ts2; // [esp+24h] [ebp-4h]

  if ( value && *value )
  {
    ts2 = strchr(value, 58);
    if ( !ts2 )
      html_src_bad_syntax(value, option_name);
    *ts2 = 0;
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "LYReadCFG - parsing tagspec '%s:%s' for option '%s'\n", value, ts2, option_name);
    }
    html_src_clean_item(lexeme_code);
    if ( !html_src_parse_tagspec(value, lexeme_code, 1, 1) || !html_src_parse_tagspec(ts2, lexeme_code, 1, 1) )
    {
      *ts2 = 58;
      html_src_bad_syntax(value, option_name);
    }
    *ts2 = 58;
    HTSACopy(&HTL_tagspecs[lexeme_code], value);
  }
  return 0;
}

//----- (080A7F6B) --------------------------------------------------------
int __cdecl psrcspec_fun(char *s)
{
  FILE *v1; // eax
  const char *v2; // ebx
  FILE *v3; // edx
  int found; // [esp+1Ch] [ebp-Ch] BYREF
  char *e; // [esp+20h] [ebp-8h]

  e = strchr(s, 58);
  if ( e )
  {
    *e = 0;
    if ( LYgetEnum(lexemnames_12106, s, &found) )
    {
      parse_html_src_spec((HTlexeme)found, e + 1, s);
    }
    else if ( WWW_TraceFlag[0] )
    {
      v2 = e + 1;
      v3 = TraceFP();
      fprintf(v3, "bad format of PRETTYSRC_SPEC setting value, ignored %s:%s\n", s, v2);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "bad format of PRETTYSRC_SPEC setting value, ignored %s\n", s);
  }
  return 0;
}

//----- (080A8053) --------------------------------------------------------
int __cdecl read_htmlsrc_attrname_xform(char *str)
{
  int v1; // ebx
  FILE *v2; // eax
  FILE *v3; // eax
  int val; // [esp+20h] [ebp-8h] BYREF

  if ( sscanf(str, "%d", &val) == 1 )
  {
    if ( val >= 0 && val <= 2 )
    {
      attrname_transform = val;
    }
    else if ( WWW_TraceFlag[0] )
    {
      v1 = val;
      v2 = TraceFP();
      fprintf(v2, "bad value for htmlsrc_attrname_xform (ignored - must be one of 0,1,2): %d\n", v1);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "bad value for htmlsrc_attrname_xform (ignored): %s\n", str);
  }
  return 0;
}

//----- (080A80F1) --------------------------------------------------------
int __cdecl read_htmlsrc_tagname_xform(char *str)
{
  int v1; // ebx
  FILE *v2; // eax
  FILE *v3; // eax
  int val; // [esp+20h] [ebp-8h] BYREF

  if ( sscanf(str, "%d", &val) == 1 )
  {
    if ( val >= 0 && val <= 2 )
    {
      tagname_transform = val;
    }
    else if ( WWW_TraceFlag[0] )
    {
      v1 = val;
      v2 = TraceFP();
      fprintf(v2, "bad value for htmlsrc_tagname_xform (ignored - must be one of 0,1,2): %d\n", v1);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "bad value for htmlsrc_tagname_xform (ignored): %s\n", str);
  }
  return 0;
}

//----- (080A818F) --------------------------------------------------------
void free_lynx_cfg()
{
  char *eqls; // [esp+8h] [ebp-10h]
  char *name; // [esp+Ch] [ebp-Ch]
  void ***q; // [esp+10h] [ebp-8h]
  Config_Type_0 *tbl; // [esp+14h] [ebp-4h]

  for ( tbl = Config_Table; tbl->name; ++tbl )
  {
    q = (void ***)&tbl->value;
    if ( tbl->type == CONF_ENV && *q )
    {
      name = (char *)**q;
      eqls = strchr(name, 61);
      if ( eqls )
      {
        *eqls = 0;
        unsetenv(name);
      }
      if ( **q )
      {
        free(**q);
        **q = 0;
      }
      if ( *q )
      {
        free(*q);
        *q = 0;
      }
    }
  }
  free_all_item_lists();
  reset_dired_menu();
  if ( lynxcfginfo_url )
  {
    free(lynxcfginfo_url);
    lynxcfginfo_url = 0;
  }
  if ( configinfo_url )
  {
    free(configinfo_url);
    configinfo_url = 0;
  }
}

//----- (080A829A) --------------------------------------------------------
Config_Type_0 *__cdecl lookup_config(char *name)
{
  char v2; // [esp+Fh] [ebp-19h]
  int v3; // [esp+14h] [ebp-14h]
  Config_Type_0 *tbl; // [esp+20h] [ebp-8h]
  unsigned __int8 ch1; // [esp+26h] [ebp-2h]

  tbl = Config_Table;
  if ( ((*__ctype_b_loc())[(unsigned __int8)*name] & 0x200) != 0 )
    v2 = toupper((unsigned __int8)*name);
  else
    v2 = *name;
  while ( tbl->name )
  {
    ch1 = *tbl->name;
    v3 = ((*__ctype_b_loc())[ch1] & 0x200) != 0 ? toupper(ch1) : ch1;
    if ( v2 == v3 && !strcasecomp(name, tbl->name) )
      break;
    ++tbl;
  }
  return tbl;
}

//----- (080A8377) --------------------------------------------------------
char *__cdecl actual_filename(const char *cfg_filename, const char *parent_filename, const char *dft_filename)
{
  const char *v3; // eax
  char *my_filename[2]; // [esp+20h] [ebp-8h] BYREF

  my_filename[0] = 0;
  if ( LYisAbsPath(cfg_filename) || !parent_filename && LYCanReadFile(cfg_filename) )
    goto LABEL_12;
  if ( *cfg_filename == 126 && cfg_filename[1] == 47 )
  {
    v3 = Home_Dir();
    HTSprintf0(my_filename, "%s%s", v3, cfg_filename + 1);
    return my_filename[0];
  }
  if ( parent_filename )
  {
    HTSACopy(my_filename, parent_filename);
    *LYPathLeaf(my_filename[0]) = 0;
    HTSACat(my_filename, cfg_filename);
  }
  if ( !my_filename[0] || !LYCanReadFile(my_filename[0]) )
  {
    HTSACopy(my_filename, dft_filename);
    *LYPathLeaf(my_filename[0]) = 0;
    HTSACat(my_filename, cfg_filename);
    if ( !LYCanReadFile(my_filename[0]) )
LABEL_12:
      HTSACopy(my_filename, cfg_filename);
  }
  return my_filename[0];
}

//----- (080A84B1) --------------------------------------------------------
FILE *__cdecl LYOpenCFG(const char *cfg_filename, const char *parent_filename, const char *dft_filename)
{
  FILE *v3; // eax
  FILE *result; // [esp+20h] [ebp-8h]
  char *my_file; // [esp+24h] [ebp-4h]

  my_file = actual_filename(cfg_filename, parent_filename, dft_filename);
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "opening config file %s\n", my_file);
  }
  result = (FILE *)fopen64(my_file, "r");
  if ( my_file )
    free(my_file);
  return result;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080A852F) --------------------------------------------------------
void __cdecl LYSetConfigValue(char *name, char *value)
{
  BOOLEAN *def_value; // ebx
  _DWORD *v3; // ebx
  char *my_value; // [esp+24h] [ebp-14h] BYREF
  char *temp; // [esp+28h] [ebp-10h] BYREF
  ParseUnion *q; // [esp+2Ch] [ebp-Ch]
  Config_Type_0 *tbl; // [esp+30h] [ebp-8h]

  tbl = lookup_config(name);
  q = (ParseUnion *)&tbl->value;
  temp = 0;
  switch ( tbl->type )
  {
    case CONF_BOOL:
      if ( q->def_value )
      {
        def_value = (BOOLEAN *)q->def_value;
        *def_value = is_true(value);
      }
      break;
    case CONF_FUN:
      if ( q->def_value )
        ((void (__cdecl *)(char *))q->add_value)(value);
      break;
    case CONF_TIME:
      if ( q->def_value && sscanf(value, "%f", &my_value) == 1 )
        *q->int_value = (int)(*(float *)&my_value * 1000.0);
      break;
    case CONF_ENUM:
      if ( tbl->table )
        LYgetEnum(tbl->table, value, q->int_value);
      break;
    case CONF_INT:
      if ( q->def_value && sscanf(value, "%d", &my_value) == 1 )
        *q->add_value = (lynx_list_item_type *)my_value;
      break;
    case CONF_STR:
      if ( q->def_value )
        HTSACopy(q->str_value, value);
      break;
    case CONF_PRG:
      if ( HTSACopy(&temp, value) )
        HTSetProgramPath((ProgramPaths)q->add_value, temp);
      break;
    case CONF_ENV:
    case CONF_ENV2:
      if ( tbl->type == CONF_ENV )
        LYLowerCase(name);
      else
        LYUpperCase(name);
      if ( !LYGetEnv(name) )
      {
        if ( !q->def_value )
          q->def_value = (int)calloc(1u, 4u);
        HTSprintf0(q->str_value, "%s=%s", name, value);
        putenv(*q->str_value);
      }
      break;
    case CONF_ADD_ITEM:
      if ( q->def_value )
        add_item_to_list(value, q->add_value, q->def_value == (_DWORD)&printers);
      break;
    case CONF_ADD_STRING:
      if ( !*q->int_value )
      {
        v3 = (_DWORD *)q->def_value;
        *v3 = HTList_new();
      }
      if ( q->def_value )
      {
        *(float *)&my_value = 0.0;
        HTSACopy(&my_value, value);
        HTList_appendObject(*q->lst_value, my_value);
      }
      break;
    case CONF_ADD_TRUSTED:
      add_trusted(value, q->def_value);
      break;
    default:
      return;
  }
}

//----- (080A880E) --------------------------------------------------------
void __cdecl do_read_cfg(
        const char *cfg_filename,
        const char *parent_filename,
        int nesting_level,
        FILE *fp0,
        optidx_set_t *allowed)
{
  FILE *v5; // eax
  char *v6; // eax
  char *v7; // edx
  char *v8; // edx
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  size_t v14; // eax
  Conf_Types type; // [esp+18h] [ebp-220h]
  bool v16; // [esp+20h] [ebp-218h]
  lynx_list_item_type *cur_download; // [esp+40h] [ebp-1F8h]
  char *cp1_0; // [esp+44h] [ebp-1F4h] BYREF
  unsigned int i_0; // [esp+48h] [ebp-1F0h]
  unsigned int i1; // [esp+4Ch] [ebp-1ECh]
  unsigned int i; // [esp+50h] [ebp-1E8h]
  Config_Type_0 *tbl2; // [esp+54h] [ebp-1E4h]
  char *my_file; // [esp+58h] [ebp-1E0h]
  const char *sep; // [esp+5Ch] [ebp-1DCh]
  char *cp1; // [esp+60h] [ebp-1D8h] BYREF
  char *url; // [esp+64h] [ebp-1D4h] BYREF
  char *p2; // [esp+68h] [ebp-1D0h]
  char *p1; // [esp+6Ch] [ebp-1CCh]
  optidx_set_t *resultant_set; // [esp+70h] [ebp-1C8h]
  ParseUnion *q; // [esp+74h] [ebp-1C4h]
  Config_Type_0 *tbl; // [esp+78h] [ebp-1C0h]
  char *cp; // [esp+7Ch] [ebp-1BCh]
  char *value; // [esp+80h] [ebp-1B8h]
  char *name; // [esp+84h] [ebp-1B4h]
  char *buffer; // [esp+88h] [ebp-1B0h] BYREF
  FILE *fp; // [esp+8Ch] [ebp-1ACh]
  BOOLEAN any_optname_found; // [esp+90h] [ebp-1A8h]
  char savechar; // [esp+91h] [ebp-1A7h]
  optidx_set_t anded_set; // [esp+92h] [ebp-1A6h] BYREF
  optidx_set_t cur_set; // [esp+161h] [ebp-D7h] BYREF
  unsigned int v41; // [esp+230h] [ebp-8h]

  v41 = __readgsdword(0x14u);
  buffer = 0;
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "Loading cfg file '%s'.\n", cfg_filename);
  }
  if ( nesting_level > 10 )
  {
    v6 = gettext("More than %d nested lynx.cfg includes -- perhaps there is a loop?!?\n");
    fprintf(stderr, v6, nesting_level - 1);
    v7 = gettext("Last attempted include was '%s',\n");
    fprintf(stderr, v7, cfg_filename);
    v8 = gettext("included from '%s'.\n");
    fprintf(stderr, v8, parent_filename);
    exit_immediately(1);
  }
  if ( !cfg_filename || !*cfg_filename )
  {
    if ( WWW_TraceFlag[0] )
    {
      v9 = TraceFP();
      fprintf(v9, "No filename following -cfg switch!\n");
    }
    return;
  }
  fp = LYOpenCFG(cfg_filename, parent_filename, "/etc/lynx-cur/lynx.cfg");
  if ( !fp )
  {
    if ( WWW_TraceFlag[0] )
    {
      v10 = TraceFP();
      fprintf(v10, "lynx.cfg file not found as '%s'\n", cfg_filename);
    }
    return;
  }
  have_read_cfg = 1;
  while ( LYSafeGets(&buffer, fp) )
  {
    name = LYSkipBlanks(buffer);
    if ( ((*__ctype_b_loc())[(unsigned __int8)*name] & 4) == 0 )
    {
      LYTrimTrailing(name);
      if ( *name )
      {
        value = strchr(name, 58);
        if ( value )
        {
          *value++ = 0;
          cp = strrchr(value, 58);
          if ( !cp )
            cp = value;
          cp = strchr(cp, 35);
          if ( cp )
          {
            if ( ((*__ctype_b_loc())[(unsigned __int8)*--cp] & 0x2000) != 0 )
              *cp = 0;
          }
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
          {
            v12 = TraceFP();
            fprintf(v12, "LYReadCFG %s:%s\n", name, value);
          }
          tbl = lookup_config(name);
          if ( tbl->name )
          {
            if ( allowed && (*allowed)[tbl - Config_Table] )
            {
              if ( !fp0 )
                fprintf(stderr, "%s is not allowed in the %s\n", name, cfg_filename);
            }
            else
            {
              q = (ParseUnion *)&tbl->value;
              if ( fp0 && tbl->type != CONF_INCLUDE )
                type = CONF_NIL;
              else
                type = tbl->type;
              if ( (unsigned int)type > CONF_ADD_TRUSTED )
                goto LABEL_97;
              if ( ((1 << type) & 0x3BFE) != 0 )
              {
                LYSetConfigValue(name, value);
              }
              else if ( ((1 << type) & 0x400) != 0 )
              {
                resultant_set = 0;
                any_optname_found = 0;
                url = 0;
                cp1 = 0;
                sep = " for ";
                p1 = strstr(value, " for ");
                if ( p1 || (sep = ":", (p1 = strstr(value, ":")) != 0) )
                {
                  *p1 = 0;
                  v14 = strlen(sep);
                  p1 += v14;
                }
                if ( fp0 && !no_lynxcfg_xinfo )
                {
                  my_file = actual_filename(value, cfg_filename, "/etc/lynx-cur/lynx.cfg");
                  LYLocalFileToURL(&url, my_file);
                  if ( my_file )
                  {
                    free(my_file);
                    my_file = 0;
                  }
                  HTSACopy(&cp1, value);
                  if ( strchr(value, 38) || strchr(value, 60) )
                    LYEntify(&cp1, 1);
                  fprintf(fp0, "%s:<a href=\"%s\">%s</a>\n\n", name, url, cp1);
                  fprintf(fp0, "    #&lt;begin  %s&gt;\n", cp1);
                }
                if ( p1 )
                {
                  while ( 1 )
                  {
                    p1 = LYSkipBlanks(p1);
                    if ( !*p1 )
                      break;
                    p2 = LYSkipNonBlanks(p1);
                    savechar = *p2;
                    *p2 = 0;
                    tbl2 = lookup_config(p1);
                    if ( tbl2->name )
                    {
                      if ( !any_optname_found )
                      {
                        any_optname_found = 1;
                        for ( i = 0; i <= 0xCE; ++i )
                          cur_set[i] = 1;
                      }
                      cur_set[tbl2 - Config_Table] = 0;
                    }
                    else if ( !fp0 )
                    {
                      fprintf(stderr, "unknown option name %s in %s\n", p1, cfg_filename);
                    }
                    if ( !savechar || !p2[1] )
                      break;
                    p1 = p2 + 1;
                  }
                }
                if ( allowed )
                {
                  if ( any_optname_found )
                  {
                    for ( i1 = 0; i1 <= 0xCE; ++i1 )
                    {
                      v16 = (*allowed)[i1] || cur_set[i1];
                      anded_set[i1] = v16;
                    }
                    resultant_set = (optidx_set_t *)anded_set;
                  }
                  else
                  {
                    resultant_set = allowed;
                  }
                }
                else if ( any_optname_found )
                {
                  resultant_set = (optidx_set_t *)cur_set;
                }
                else
                {
                  resultant_set = 0;
                }
                if ( fp0 && !no_lynxcfg_xinfo && resultant_set )
                {
                  cp1_0 = 0;
                  fwrite("     Options allowed in this file:\n", 1u, 0x23u, fp0);
                  for ( i_0 = 0; i_0 <= 0xCE; ++i_0 )
                  {
                    if ( !(*resultant_set)[i_0] )
                    {
                      HTSACopy(&cp1_0, Config_Table[i_0].name);
                      LYUpperCase(cp1_0);
                      fprintf(fp0, "         * %s\n", cp1_0);
                    }
                  }
                  if ( cp1_0 )
                  {
                    free(cp1_0);
                    cp1_0 = 0;
                  }
                }
                do_read_cfg(value, cfg_filename, nesting_level + 1, fp0, resultant_set);
                if ( fp0 && !no_lynxcfg_xinfo )
                {
                  fprintf(fp0, "    #&lt;end of %s&gt;\n\n", cp1);
                  if ( url )
                  {
                    free(url);
                    url = 0;
                  }
                  if ( cp1 )
                  {
                    free(cp1);
                    cp1 = 0;
                  }
                }
              }
              else
              {
LABEL_97:
                if ( fp0 )
                {
                  if ( strchr(value, 38) || strchr(value, 60) )
                  {
                    cp1_0 = 0;
                    HTSACopy(&cp1_0, value);
                    LYEntify(&cp1_0, 1);
                    fprintf(fp0, "%s:%s\n", name, cp1_0);
                    if ( cp1_0 )
                    {
                      free(cp1_0);
                      cp1_0 = 0;
                    }
                  }
                  else
                  {
                    fprintf(fp0, "%s:%s\n", name, value);
                  }
                }
              }
            }
          }
          else if ( WWW_TraceFlag[0] )
          {
            v13 = TraceFP();
            fprintf(v13, "LYReadCFG: ignored %s:%s\n", name, value);
          }
        }
        else if ( WWW_TraceFlag[0] )
        {
          v11 = TraceFP();
          fprintf(v11, "LYReadCFG: missing ':' %s\n", name);
        }
      }
    }
  }
  LYCloseInput(fp);
  if ( downloaders )
  {
    for ( cur_download = downloaders; cur_download; cur_download = cur_download->next )
    {
      if ( cur_download->always_enabled )
      {
        override_no_download = 1;
        break;
      }
    }
  }
  LYConfigCookies();
}

//----- (080A93F3) --------------------------------------------------------
void __cdecl read_cfg(const char *cfg_filename, const char *parent_filename, int nesting_level, FILE *fp0)
{
  HTInitProgramPaths();
  do_read_cfg(cfg_filename, parent_filename, nesting_level, fp0, 0);
}

//----- (080A9428) --------------------------------------------------------
void __cdecl extra_cfg_link(FILE *fp, const char *href, const char *name)
{
  fprintf(fp, "<a href=\"%s\">%s</a>", href, name);
}

//----- (080A9451) --------------------------------------------------------
int __cdecl lynx_cfg_infopage(DocInfo *newdoc)
{
  char *v1; // ebx
  char *v2; // eax
  char *address; // ebx
  char *v4; // eax
  const char *v5; // ebx
  char *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // ebx
  const char *v22; // esi
  char *v23; // eax
  char *v24; // eax
  DocAddress WWWDoc; // [esp+20h] [ebp-28h] BYREF
  FILE *fp0; // [esp+34h] [ebp-14h]
  char *cp1; // [esp+38h] [ebp-10h] BYREF
  char *temp[3]; // [esp+3Ch] [ebp-Ch] BYREF

  temp[0] = 0;
  cp1 = 0;
  if ( !no_lynxcfg_xinfo && strstr(newdoc->address, "LYNXCFG://reload") )
  {
    reload_read_cfg();
    if ( HTMainText )
    {
      if ( nhist > 0 )
      {
        v1 = gettext("Lynx.cfg Information");
        v2 = HTLoadedDocumentTitle();
        if ( !strcmp(v2, v1) )
        {
          address = history[nhist - 1].hdoc.address;
          v4 = HTLoadedDocumentURL();
          if ( !strcmp(v4, address) )
          {
            if ( LYIsUIPage3(history[nhist - 1].hdoc.address, UIP_LYNXCFG_0, 1) )
            {
              if ( !lynxcfginfo_url || (v5 = lynxcfginfo_url, v6 = HTLoadedDocumentURL(), strcmp(v6, v5)) )
              {
                LYpop(newdoc);
                WWWDoc = *(DocAddress *)&newdoc->address;
                LYforce_no_cache = 0;
                LYoverride_no_cache = 1;
                if ( !HTLoadAbsolute(&WWWDoc) )
                  return 0;
                HTuncache_current_document();
                LYRegisterUIPage(0, UIP_LYNXCFG_0);
              }
            }
          }
        }
      }
    }
    if ( lynxcfginfo_url )
    {
      free(lynxcfginfo_url);
      lynxcfginfo_url = 0;
    }
  }
  if ( !LYforce_no_cache || !reloading[0] )
  {
    if ( !lynxcfginfo_url || LYCanReadFile(tempfile_12787) || !lynxcfginfo_url )
      goto LABEL_23;
    goto LABEL_22;
  }
  if ( lynxcfginfo_url )
  {
LABEL_22:
    free(lynxcfginfo_url);
    lynxcfginfo_url = 0;
  }
LABEL_23:
  if ( !lynxcfginfo_url )
  {
    fp0 = InternalPageFP(tempfile_12787, 1);
    if ( !fp0 )
      return 0;
    LYLocalFileToURL(&lynxcfginfo_url, tempfile_12787);
    LYforce_no_cache = 1;
    v7 = gettext("Lynx.cfg Information");
    BeginInternalPage(fp0, v7, 0);
    fwrite("<pre>\n", 1u, 6u, fp0);
    if ( no_lynxcfg_xinfo )
    {
      v24 = gettext("The following is read from your lynx.cfg file.");
      fprintf(fp0, "<em>%s</em>\n\n", v24);
    }
    else
    {
      if ( !strcmp(lynx_cfg_file, "/etc/lynx-cur/lynx.cfg") )
      {
        v11 = gettext("Please read the distribution");
        v12 = gettext("The following is read from your lynx.cfg file.");
        fprintf(fp0, "<em>%s\n%s", v12, v11);
        fwrite(" </em>lynx.cfg<em> ", 1u, 0x13u, fp0);
        v13 = gettext("for more comments.");
        fprintf(fp0, "%s</em>\n", v13);
      }
      else
      {
        v8 = gettext("Please read the distribution");
        v9 = gettext("The following is read from your lynx.cfg file.");
        fprintf(fp0, "<em>%s\n%s", v9, v8);
        LYLocalFileToURL(temp, "/etc/lynx-cur/lynx.cfg");
        fprintf(fp0, " <a href=\"%s\">lynx.cfg</a> ", temp[0]);
        if ( temp[0] )
        {
          free(temp[0]);
          temp[0] = 0;
        }
        v10 = gettext("for more comments.");
        fprintf(fp0, "%s</em>\n\n", v10);
      }
      if ( no_compileopts_info || no_lynxcfg_xinfo )
      {
        v17 = gettext("See also");
        fprintf(fp0, "%s ", v17);
        if ( !no_compileopts_info )
        {
          v18 = gettext("compile time options");
          extra_cfg_link(fp0, "LYNXCOMPILEOPTS:", v18);
        }
        if ( !no_lynxcfg_xinfo )
        {
          LYLocalFileToURL(temp, lynx_lss_file);
          v19 = gettext("color-style configuration");
          extra_cfg_link(fp0, temp[0], v19);
        }
        fwrite("\n\n", 1u, 2u, fp0);
      }
      else
      {
        v14 = gettext("See also");
        fprintf(fp0, "%s</pre><ul><li>", v14);
        v15 = gettext("compile time options");
        extra_cfg_link(fp0, "LYNXCOMPILEOPTS:", v15);
        fwrite("<li>", 1u, 4u, fp0);
        LYLocalFileToURL(temp, lynx_lss_file);
        v16 = gettext("color-style configuration");
        extra_cfg_link(fp0, temp[0], v16);
        fwrite("</ul><pre>\n", 1u, 0xBu, fp0);
      }
      if ( user_mode == 2 )
      {
        v20 = gettext("RELOAD THE CHANGES");
        fprintf(fp0, "  <a href=\"%s//reload\">%s</a>\n", "LYNXCFG:", v20);
      }
      LYLocalFileToURL(temp, lynx_cfg_file);
      HTSACopy(&cp1, lynx_cfg_file);
      if ( strchr(lynx_cfg_file, 38) || strchr(lynx_cfg_file, 60) )
        LYEntify(&cp1, 1);
      v21 = cp1;
      v22 = temp[0];
      v23 = gettext("Your primary configuration");
      fprintf(fp0, "\n    #<em>%s <a href=\"%s\">%s</a></em>\n", v23, v22, v21);
      if ( temp[0] )
      {
        free(temp[0]);
        temp[0] = 0;
      }
      if ( cp1 )
      {
        free(cp1);
        cp1 = 0;
      }
    }
    read_cfg(lynx_cfg_file, "main program", 1, fp0);
    fwrite("</pre>\n", 1u, 7u, fp0);
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);
    LYRegisterUIPage(lynxcfginfo_url, UIP_LYNXCFG_0);
  }
  HTSACopy(&newdoc->address, lynxcfginfo_url);
  WWWDoc = *(DocAddress *)&newdoc->address;
  if ( !HTLoadAbsolute(&WWWDoc) )
    return 0;
  lynx_edit_mode = 0;
  return 1;
}

//----- (080A9C14) --------------------------------------------------------
int __cdecl lynx_compile_opts(DocInfo *newdoc)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  DocAddress WWWDoc; // [esp+1Ch] [ebp-1Ch] BYREF
  FILE *fp0; // [esp+30h] [ebp-8h]
  unsigned int n; // [esp+34h] [ebp-4h]

  if ( LYforce_no_cache && reloading[0] )
  {
    if ( !configinfo_url )
      goto LABEL_9;
    goto LABEL_8;
  }
  if ( configinfo_url && !LYCanReadFile(tempfile_12963) && configinfo_url )
  {
LABEL_8:
    free(configinfo_url);
    configinfo_url = 0;
  }
LABEL_9:
  if ( !configinfo_url )
  {
    fp0 = InternalPageFP(tempfile_12963, 1);
    if ( !fp0 )
      return 0;
    LYLocalFileToURL(&configinfo_url, tempfile_12963);
    v1 = gettext("Configuration Definitions");
    BeginInternalPage(fp0, v1, 0);
    fwrite("<pre>\n", 1u, 6u, fp0);
    v2 = gettext(
           "The following data were derived during the automatic configuration/build\n"
           "process of this copy of Lynx.  When reporting a bug, please include a copy\n"
           "of this page.");
    fprintf(fp0, "\n%s<br>\n<em>config.cache</em>\n", v2);
    for ( n = 0; n <= 0x119; ++n )
      fprintf(fp0, "%-35s %s\n", config_cache_12967[n].name, *((const char **)&off_815D4A4 + 2 * n));
    v3 = gettext(
           "The following data were used as automatically-configured compile-time\n"
           "definitions when this copy of Lynx was built.");
    fprintf(fp0, "\n%s<br>\n<em>lynx_cfg.h</em>\n", v3);
    for ( n = 0; n <= 0xB7; ++n )
      fprintf(fp0, "%-35s %s\n", config_defines_12971[n].name, off_815BC44[2 * n]);
    fwrite("</pre>\n", 1u, 7u, fp0);
    EndInternalPage(fp0);
    LYCloseTempFP(fp0);
    LYRegisterUIPage(configinfo_url, UIP_CONFIG_DEF_0);
  }
  HTSACopy(&newdoc->address, configinfo_url);
  WWWDoc = *(DocAddress *)&newdoc->address;
  if ( !HTLoadAbsolute(&WWWDoc) )
    return 0;
  lynx_edit_mode = 0;
  return 1;
}
// 815BC44: using guessed type char *off_815BC44[242];

//----- (080A9EB4) --------------------------------------------------------
BOOLEAN __cdecl link_has_target(int cur, char *target)
{
  size_t v2; // eax
  bool v4; // [esp+10h] [ebp-28h]
  bool v6; // [esp+12h] [ebp-26h]
  bool v7; // [esp+13h] [ebp-25h]
  bool v8; // [esp+14h] [ebp-24h]
  bool v9; // [esp+15h] [ebp-23h]
  bool v10; // [esp+16h] [ebp-22h]
  bool v11; // [esp+17h] [ebp-21h]
  const char *text; // [esp+20h] [ebp-18h]
  int count; // [esp+24h] [ebp-14h]
  const char *cp; // [esp+28h] [ebp-10h]
  const char *cpa; // [esp+28h] [ebp-10h]
  char *stars; // [esp+2Ch] [ebp-Ch] BYREF
  OptionType *option; // [esp+30h] [ebp-8h]
  LinkInfo *a; // [esp+34h] [ebp-4h]

  a = (LinkInfo *)(68 * cur + 136026784);
  stars = 0;
  for ( count = 0; ; ++count )
  {
    text = LYGetHiliteStr(cur, count);
    if ( !text )
      break;
    if ( case_sensitive )
      v4 = LYno_attr_char_strstr(text, target) != 0;
    else
      v4 = LYno_attr_char_case_strstr(text, target) != 0;
    if ( v4 )
      return 1;
  }
  if ( !a->l_form || !a->l_form->value || a->l_form->type == 8 )
    return 0;
  if ( a->l_form->type != 2 )
  {
    switch ( a->l_form->type )
    {
      case 7:
        for ( option = a->l_form->select_list; option; option = option->next )
        {
          if ( case_sensitive )
            v8 = LYno_attr_char_strstr(option->name, target) != 0;
          else
            v8 = LYno_attr_char_case_strstr(option->name, target) != 0;
          if ( v8 )
            return 1;
        }
        break;
      case 4:
        if ( a->l_form->num_value )
          cp = checked_radio;
        else
          cp = unchecked_radio;
        if ( case_sensitive )
          v9 = LYno_attr_char_strstr(cp, target) != 0;
        else
          v9 = LYno_attr_char_case_strstr(cp, target) != 0;
        if ( v9 )
          return 1;
        break;
      case 3:
        if ( a->l_form->num_value )
          cpa = checked_box;
        else
          cpa = unchecked_box;
        if ( case_sensitive )
          v10 = LYno_attr_char_strstr(cpa, target) != 0;
        else
          v10 = LYno_attr_char_case_strstr(cpa, target) != 0;
        if ( v10 )
          return 1;
        break;
      default:
        if ( case_sensitive )
          v11 = LYno_attr_char_strstr(a->l_form->value, target) != 0;
        else
          v11 = LYno_attr_char_case_strstr(a->l_form->value, target) != 0;
        if ( v11 )
          return 1;
        break;
    }
    return 0;
  }
  if ( case_sensitive )
    v6 = LYno_attr_char_strstr(a->l_form->value, target) != 0;
  else
    v6 = LYno_attr_char_case_strstr(a->l_form->value, target) != 0;
  if ( v6 )
    return 1;
  HTSACopy(&stars, a->l_form->value);
  v2 = strlen(stars);
  memset(stars, 42, v2);
  if ( case_sensitive )
    v7 = LYno_attr_char_strstr(stars, target) != 0;
  else
    v7 = LYno_attr_char_case_strstr(stars, target) != 0;
  if ( !v7 )
  {
    if ( stars )
    {
      free(stars);
      stars = 0;
    }
    return 0;
  }
  if ( stars )
  {
    free(stars);
    stars = 0;
  }
  return 1;
}

//----- (080AA27D) --------------------------------------------------------
int __cdecl check_next_target_in_links(int *cur, char *target)
{
  int i; // [esp+24h] [ebp-4h]

  if ( nlinks )
  {
    for ( i = *cur + 1; i < nlinks; ++i )
    {
      if ( link_has_target(i, target) )
      {
        *cur = i;
        return 1;
      }
    }
  }
  return 0;
}

//----- (080AA2DA) --------------------------------------------------------
int __cdecl check_prev_target_in_links(int *cur, char *target)
{
  int i; // [esp+24h] [ebp-4h]

  if ( nlinks )
  {
    for ( i = *cur - 1; i >= 0; --i )
    {
      if ( link_has_target(i, target) )
      {
        *cur = i;
        return 1;
      }
    }
  }
  return 0;
}

//----- (080AA333) --------------------------------------------------------
BOOLEAN __cdecl textsearch(DocInfo *cur_doc, char *prev_target, int target_size, int direction)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int v14; // [esp+10h] [ebp-28h]
  int QueryNum; // [esp+18h] [ebp-20h]
  _BOOL4 recall; // [esp+20h] [ebp-18h]
  int ch_0; // [esp+24h] [ebp-14h]
  char *cp; // [esp+28h] [ebp-10h]
  char *cpa; // [esp+28h] [ebp-10h]
  char *cpb; // [esp+28h] [ebp-10h]
  char *cpc; // [esp+28h] [ebp-10h]
  int oldcur; // [esp+2Ch] [ebp-Ch]
  int offset; // [esp+30h] [ebp-8h]
  BOOLEAN FirstRecall; // [esp+37h] [ebp-1h]

  oldcur = cur_doc->link;
  ch_0 = 0;
  FirstRecall = 1;
  if ( first_10558 )
  {
    prev_target_buffer_10557[0] = 0;
    first_10558 = 0;
  }
  if ( search_queries )
    v14 = HTList_count(search_queries);
  else
    v14 = 0;
  recall = v14 > 0;
  QueryNum = v14;
  if ( direction )
    LYstrncpy(prev_target, prev_target_buffer_10557, target_size);
  if ( *prev_target
    || (mustshow[0] = 1,
        v4 = gettext("Enter a whereis query: "),
        statusline(v4),
        ch_0 = LYgetstr(prev_target, 0, target_size, (RecallType)recall),
        ch_0 >= 0) )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( !*prev_target && (v14 <= 0 || ch_0 != 256 && ch_0 != 257) )
        {
          v5 = gettext("Cancelled!!!");
          HTInfoMsg(v5);
          return 0;
        }
        if ( v14 <= 0 || ch_0 != 256 )
          break;
        if ( FirstRecall )
        {
          FirstRecall = 0;
          if ( prev_target_buffer_10557[0] )
          {
            for ( QueryNum = v14 - 1; QueryNum > 0; --QueryNum )
            {
              cp = (char *)HTList_objectAt(search_queries, QueryNum);
              if ( cp )
              {
                if ( !strcmp(prev_target_buffer_10557, cp) )
                  break;
              }
            }
          }
          else
          {
            QueryNum = 0;
          }
        }
        else
        {
          ++QueryNum;
        }
        if ( QueryNum >= v14 )
          QueryNum = 0;
        cpa = (char *)HTList_objectAt(search_queries, QueryNum);
        if ( !cpa )
          goto LABEL_67;
        LYstrncpy(prev_target, cpa, target_size);
        if ( prev_target_buffer_10557[0] && !strcmp(prev_target_buffer_10557, prev_target) )
        {
          mustshow[0] = 1;
          v6 = gettext("Edit the current query: ");
          statusline(v6);
        }
        else if ( prev_target_buffer_10557[0] && v14 == 2 || !prev_target_buffer_10557[0] && v14 == 1 )
        {
          mustshow[0] = 1;
          v7 = gettext("Edit the previous query: ");
          statusline(v7);
        }
        else
        {
          mustshow[0] = 1;
          v8 = gettext("Edit a previous query: ");
          statusline(v8);
        }
        ch_0 = LYgetstr(prev_target, 0, target_size, (RecallType)recall);
        if ( ch_0 < 0 )
          goto LABEL_66;
      }
      if ( v14 <= 0 || ch_0 != 257 )
        break;
      if ( FirstRecall )
      {
        FirstRecall = 0;
        if ( prev_target_buffer_10557[0] )
        {
          for ( QueryNum = 0; v14 - 1 > QueryNum; ++QueryNum )
          {
            cpb = (char *)HTList_objectAt(search_queries, QueryNum);
            if ( cpb )
            {
              if ( !strcmp(prev_target_buffer_10557, cpb) )
                break;
            }
          }
        }
        else
        {
          QueryNum = v14 - 1;
        }
      }
      else
      {
        --QueryNum;
      }
      if ( QueryNum < 0 )
        QueryNum = v14 - 1;
      cpc = (char *)HTList_objectAt(search_queries, QueryNum);
      if ( !cpc )
        break;
      LYstrncpy(prev_target, cpc, target_size);
      if ( prev_target_buffer_10557[0] && !strcmp(prev_target_buffer_10557, prev_target) )
      {
        mustshow[0] = 1;
        v9 = gettext("Edit the current query: ");
        statusline(v9);
      }
      else if ( prev_target_buffer_10557[0] && v14 == 2 || !prev_target_buffer_10557[0] && v14 == 1 )
      {
        mustshow[0] = 1;
        v10 = gettext("Edit the previous query: ");
        statusline(v10);
      }
      else
      {
        mustshow[0] = 1;
        v11 = gettext("Edit a previous query: ");
        statusline(v11);
      }
      ch_0 = LYgetstr(prev_target, 0, target_size, (RecallType)recall);
      if ( ch_0 < 0 )
        goto LABEL_66;
    }
LABEL_67:
    LYstrncpy(prev_target_buffer_10557, prev_target, 511);
    HTAddSearchQuery(prev_target_buffer_10557);
    if ( direction >= 0 )
    {
      if ( check_next_target_in_links(&cur_doc->link, prev_target) )
        goto LABEL_75;
      if ( nlinks )
        offset = links[cur_doc->link].ly - 1;
      else
        offset = display_lines - 1;
    }
    else
    {
      offset = 0;
      if ( check_prev_target_in_links(&cur_doc->link, prev_target) )
      {
LABEL_75:
        LYhighlight(0, oldcur, prev_target);
        return 1;
      }
    }
    www_user_search(offset + cur_doc->line, cur_doc, prev_target, direction);
    if ( cur_doc->link == oldcur )
      return www_search_result > 0;
    goto LABEL_75;
  }
LABEL_66:
  LYstrncpy(prev_target, prev_target_buffer_10557, target_size);
  v12 = gettext("Cancelled!!!");
  HTInfoMsg(v12);
  return 0;
}

//----- (080AA968) --------------------------------------------------------
void __cdecl trace_history(const char *tag)
{
  int v1; // ebx
  int v2; // esi
  int v3; // edi
  FILE *v4; // edx
  FILE *v5; // eax

  if ( WWW_TraceFlag[0] )
  {
    v1 = nhist_extra;
    v2 = size_history;
    v3 = nhist;
    v4 = TraceFP();
    fprintf(v4, "HISTORY %s %d/%d (%d extra)\n", tag, v3, v2, v1);
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fflush(v5);
    }
  }
}

//----- (080AA9E5) --------------------------------------------------------
void __cdecl LYAddVisitedLink(DocInfo *doc)
{
  char *title; // [esp+18h] [ebp-30h]
  const char *s2; // [esp+1Ch] [ebp-2Ch]
  char *s1; // [esp+20h] [ebp-28h]
  _VisitedLink *object; // [esp+24h] [ebp-24h]
  _VisitedLink *b; // [esp+30h] [ebp-18h]
  VisitedLink *a; // [esp+34h] [ebp-14h]
  int related; // [esp+38h] [ebp-10h]
  HTList *cur; // [esp+40h] [ebp-8h]
  VisitedLink *tmp; // [esp+44h] [ebp-4h]

  if ( doc->title )
    title = doc->title;
  else
    title = gettext("(No title.)");
  if ( doc->address && *doc->address )
  {
    if ( (doc->post_data
       || doc->isHEAD
       || doc->bookmark
       || !strncmp(doc->address, "LYNX", 4u)
       || !strncmp(doc->address, "file://localhost/", 0x11u))
      && ((related = 1, LYIsUIPage3(doc->address, UIP_HISTORY_0, 1))
       || LYIsUIPage3(doc->address, UIP_VLINKS_0, 1)
       || LYIsUIPage3(doc->address, UIP_SHOWINFO_0, 1)
       || !strncasecomp(doc->address, "LYNXMESSAGES:", 13)
       || (related = 0, LYIsUIPage3(doc->address, UIP_DIRED_MENU_0, 1))
       || LYIsUIPage3(doc->address, UIP_UPLOAD_OPTIONS_0, 1)
       || LYIsUIPage3(doc->address, UIP_PERMIT_OPTIONS_0, 1)
       || LYIsUIPage3(doc->address, UIP_PRINT_OPTIONS_0, 1)
       || LYIsUIPage3(doc->address, UIP_DOWNLOAD_OPTIONS_0, 1)
       || LYIsUIPage3(doc->address, UIP_OPTIONS_MENU_0, 1)
       || !strncasecomp(doc->address, "LYNXKEYMAP:", 11)
       || LYIsUIPage3(doc->address, UIP_LIST_PAGE_0, 1)
       || LYIsUIPage3(doc->address, UIP_CONFIG_DEF_0, 1)
       || LYIsUIPage3(doc->address, UIP_LYNXCFG_0, 1)
       || !strncasecomp(doc->address, "LYNXCOOKIE:", 11)
       || LYIsUIPage3(doc->address, UIP_TRACELOG_0, 1)) )
    {
      if ( !related )
        PrevVisitedLink = 0;
    }
    else
    {
      if ( !Visited_Links )
      {
        Visited_Links = HTList_new();
        Latest_last.prev_latest = &Latest_first;
        Latest_first.next_latest = &Latest_last;
        Latest_last.next_latest = 0;
        Latest_first.prev_latest = 0;
        First_tree = 0;
        Latest_tree = 0;
        Last_by_first = 0;
      }
      cur = Visited_Links;
      do
      {
        if ( cur && (cur = cur->next) != 0 )
          object = (_VisitedLink *)cur->object;
        else
          object = 0;
        if ( !object )
        {
          tmp = (VisitedLink *)calloc(1u, 0x1Cu);
          if ( !tmp )
            outofmem("./LYHistory.c", "LYAddVisitedLink");
          HTSACopy(&tmp->address, doc->address);
          LYformTitle(&tmp->title, title);
          HTList_appendObject(Visited_Links, tmp);
          tmp->prev_first = Last_by_first;
          Last_by_first = tmp;
          if ( PrevVisitedLink )
          {
            a = PrevVisitedLink;
            for ( b = PrevVisitedLink->next_tree; b && b->level > PrevVisitedLink->level; b = b->next_tree )
              a = b;
            if ( !b )
              Latest_tree = tmp;
            tmp->next_tree = a->next_tree;
            a->next_tree = tmp;
            tmp->level = PrevVisitedLink->level + 1;
          }
          else
          {
            if ( Latest_tree )
              Latest_tree->next_tree = tmp;
            tmp->level = 0;
            tmp->next_tree = 0;
            Latest_tree = tmp;
          }
          PrevActiveVisitedLink = tmp;
          PrevVisitedLink = tmp;
          if ( !First_tree )
            First_tree = tmp;
          Latest_last.prev_latest->next_latest = tmp;
          tmp->prev_latest = Latest_last.prev_latest;
          tmp->next_latest = &Latest_last;
          Latest_last.prev_latest = tmp;
          return;
        }
        if ( doc->address )
          s2 = doc->address;
        else
          s2 = (const char *)&unk_815DFD2;
        if ( object->address )
          s1 = object->address;
        else
          s1 = (char *)&unk_815DFD2;
      }
      while ( strcmp(s1, s2) );
      PrevActiveVisitedLink = object;
      PrevVisitedLink = object;
      if ( object->next_latest != &Latest_last )
      {
        object->prev_latest->next_latest = object->next_latest;
        object->next_latest->prev_latest = object->prev_latest;
        Latest_last.prev_latest->next_latest = object;
        object->prev_latest = Latest_last.prev_latest;
        object->next_latest = &Latest_last;
        Latest_last.prev_latest = object;
      }
    }
  }
  else
  {
    PrevVisitedLink = 0;
  }
}

//----- (080AAFFC) --------------------------------------------------------
BOOLEAN __cdecl LYwouldPush(const char *title, const char *docurl)
{
  char *v3; // [esp+4h] [ebp-24h]
  char *v4; // [esp+4h] [ebp-24h]
  char *v5; // [esp+4h] [ebp-24h]
  char *v6; // [esp+4h] [ebp-24h]
  char *v7; // [esp+4h] [ebp-24h]
  BOOLEAN v10; // [esp+14h] [ebp-14h]
  size_t ulen; // [esp+20h] [ebp-8h]

  if ( docurl )
  {
    if ( strncmp(docurl, "file://localhost/", 0x11u) )
      return 1;
    ulen = strlen(docurl);
    if ( ulen <= 5 || strcmp(&docurl[ulen - 5], ".html") )
      return 1;
  }
  if ( docurl )
  {
    return !LYIsUIPage3(docurl, UIP_HISTORY_0, 1)
        && !LYIsUIPage3(docurl, UIP_PRINT_OPTIONS_0, 1)
        && !LYIsUIPage3(docurl, UIP_DIRED_MENU_0, 1)
        && !LYIsUIPage3(docurl, UIP_UPLOAD_OPTIONS_0, 1)
        && !LYIsUIPage3(docurl, UIP_PERMIT_OPTIONS_0, 1);
  }
  else
  {
    v3 = gettext("History Page");
    v10 = 0;
    if ( strcmp(title, v3) )
    {
      v4 = gettext("Printing Options");
      if ( strcmp(title, v4) )
      {
        v5 = gettext("File Management Options");
        if ( strcmp(title, v5) )
        {
          v6 = gettext("Upload Options");
          if ( strcmp(title, v6) )
          {
            v7 = gettext("File Permission Options");
            if ( strcmp(title, v7) )
              return 1;
          }
        }
      }
    }
    return v10;
  }
}

//----- (080AB1ED) --------------------------------------------------------
void __cdecl LYFreePostData(DocInfo *doc)
{
  HTSABFree(&doc->post_data);
  if ( doc->post_content_type )
  {
    free(doc->post_content_type);
    doc->post_content_type = 0;
  }
}

//----- (080AB225) --------------------------------------------------------
void __cdecl LYFreeDocInfo(DocInfo *doc)
{
  if ( doc->title )
  {
    free(doc->title);
    doc->title = 0;
  }
  if ( doc->address )
  {
    free(doc->address);
    doc->address = 0;
  }
  if ( doc->bookmark )
  {
    free(doc->bookmark);
    doc->bookmark = 0;
  }
  LYFreePostData(doc);
}

//----- (080AB29B) --------------------------------------------------------
void clean_extra_history()
{
  trace_history("clean_extra_history");
  nhist += nhist_extra;
  while ( nhist_extra > 0 )
  {
    LYFreeDocInfo(&history[--nhist].hdoc);
    --nhist_extra;
  }
  trace_history("...clean_extra_history");
}

//----- (080AB30B) --------------------------------------------------------
int __cdecl are_identical(HistInfo *doc, DocInfo *doc1)
{
  int v3; // [esp+Ch] [ebp-Ch]
  char *s2; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( !strcmp(doc1->address, doc->hdoc.address) && HTSABEql(doc1->post_data, doc->hdoc.post_data) )
  {
    s2 = doc->hdoc.bookmark ? doc->hdoc.bookmark : (char *)&unk_815DFD2;
    s1 = doc1->bookmark ? doc1->bookmark : (char *)&unk_815DFD2;
    if ( !strcmp(s1, s2) && doc1->isHEAD == doc->hdoc.isHEAD )
      return 1;
  }
  return v3;
}

//----- (080AB3C2) --------------------------------------------------------
void __cdecl LYAllocHistory(int entries)
{
  int v1; // ebx
  FILE *v2; // edx
  HistInfo *v3; // eax
  int v4; // ebx
  FILE *v5; // edx
  int save; // [esp+1Ch] [ebp-Ch]
  unsigned int want; // [esp+20h] [ebp-8h]

  if ( WWW_TraceFlag[0] )
  {
    v1 = size_history;
    v2 = TraceFP();
    fprintf(v2, "LYAllocHistory %d vs %d\n", entries, v1);
  }
  if ( entries + 1 >= size_history )
  {
    save = size_history;
    size_history = 2 * (entries + 2);
    want = 88 * (entries + 2);
    if ( history )
      history = (HistInfo *)realloc(history, want);
    else
      history = (HistInfo *)malloc(want);
    if ( !history )
      outofmem("./LYHistory.c", "LYAllocHistory");
    while ( save < size_history )
    {
      v3 = &history[save++];
      memset(v3, 0, sizeof(HistInfo));
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v4 = size_history;
    v5 = TraceFP();
    fprintf(v5, "...LYAllocHistory %d vs %d\n", entries, v4);
  }
}

//----- (080AB4F5) --------------------------------------------------------
int __cdecl LYpush(DocInfo *doc, BOOLEAN force_push)
{
  FILE *v2; // eax
  FILE *v3; // eax
  char *title; // edi
  char *address; // ebx
  int v6; // esi
  FILE *v7; // eax
  int len; // [esp+18h] [ebp-40h]
  const char *src; // [esp+1Ch] [ebp-3Ch]
  int v12; // [esp+24h] [ebp-34h]
  DocAddress WWWDoc; // [esp+2Ch] [ebp-2Ch] BYREF
  char *temp; // [esp+40h] [ebp-18h] BYREF
  HTParentAnchor *thatparent; // [esp+44h] [ebp-14h]
  HTParentAnchor *thisparent; // [esp+48h] [ebp-10h]

  if ( !*doc->address )
    return 0;
  if ( force_push || LYwouldPush(doc->title, doc->address) )
  {
    if ( nhist > 0
      && are_identical(&history[nhist - 1], doc)
      && history[nhist - 1].hdoc.internal_link == doc->internal_link )
    {
      history[nhist - 1].hdoc.link = doc->link;
      history[nhist - 1].hdoc.line = doc->line;
      return 0;
    }
    else if ( nhist_extra > 0 && are_identical(&history[nhist], doc) )
    {
      history[nhist].hdoc.link = doc->link;
      history[nhist].hdoc.line = doc->line;
      --nhist_extra;
      LYAllocHistory(nhist);
      ++nhist;
      trace_history("LYpush: just move the cursor");
      return 1;
    }
    else
    {
      clean_extra_history();
      LYAllocHistory(nhist);
      history[nhist].hdoc.link = doc->link;
      history[nhist].hdoc.line = doc->line;
      history[nhist].hdoc.title = 0;
      LYformTitle(&history[nhist].hdoc.title, doc->title);
      history[nhist].hdoc.address = 0;
      HTSACopy(&history[nhist].hdoc.address, doc->address);
      history[nhist].hdoc.post_data = 0;
      if ( doc->post_data )
        len = doc->post_data->len;
      else
        len = 0;
      if ( doc->post_data )
        src = doc->post_data->str;
      else
        src = 0;
      HTSABCopy(&history[nhist].hdoc.post_data, src, len);
      history[nhist].hdoc.post_content_type = 0;
      HTSACopy(&history[nhist].hdoc.post_content_type, doc->post_content_type);
      history[nhist].hdoc.bookmark = 0;
      HTSACopy(&history[nhist].hdoc.bookmark, doc->bookmark);
      history[nhist].hdoc.isHEAD = doc->isHEAD;
      history[nhist].hdoc.safe = doc->safe;
      history[nhist].hdoc.internal_link = 0;
      history[nhist].intern_seq_start = -1;
      if ( doc->internal_link )
      {
        if ( nhist > 0 )
        {
          thatparent = 0;
          WWWDoc = *(DocAddress *)&doc->address;
          thisparent = HTAnchor_findAddress(&WWWDoc);
          if ( thisparent )
          {
            if ( strncasecomp(history[nhist - 1].hdoc.address, "LYNXIMGMAP:", 11)
              || !strncasecomp(doc->address, "LYNXIMGMAP:", 11) )
            {
              if ( strncasecomp(doc->address, "LYNXIMGMAP:", 11)
                || !strncasecomp(history[nhist - 1].hdoc.address, "LYNXIMGMAP:", 11) )
              {
                WWWDoc.address = history[nhist - 1].hdoc.address;
              }
              else
              {
                temp = 0;
                HTSACopy(&temp, "LYNXIMGMAP:");
                HTSACat(&temp, (const char *)doc->address + 11);
                WWWDoc.address = temp;
                WWWDoc.post_content_type = history[nhist - 1].hdoc.post_content_type;
                WWWDoc.bookmark = history[nhist - 1].hdoc.bookmark;
                WWWDoc.isHEAD = history[nhist - 1].hdoc.isHEAD;
                WWWDoc.safe = history[nhist - 1].hdoc.safe;
                thatparent = HTAnchor_findAddress(&WWWDoc);
                if ( temp )
                {
                  free(temp);
                  temp = 0;
                }
              }
            }
            else
            {
              WWWDoc.address = history[nhist - 1].hdoc.address + 11;
            }
            if ( !thatparent )
            {
              WWWDoc.post_data = history[nhist - 1].hdoc.post_data;
              WWWDoc.post_content_type = history[nhist - 1].hdoc.post_content_type;
              WWWDoc.bookmark = history[nhist - 1].hdoc.bookmark;
              WWWDoc.isHEAD = history[nhist - 1].hdoc.isHEAD;
              WWWDoc.safe = history[nhist - 1].hdoc.safe;
              thatparent = HTAnchor_findAddress(&WWWDoc);
            }
            if ( thatparent == thisparent && (!HTMainText || HTMainAnchor == thisparent) )
            {
              history[nhist].hdoc.internal_link = 1;
              v12 = history[nhist - 1].intern_seq_start < 0 ? nhist - 1 : history[nhist - 1].intern_seq_start;
              history[nhist].intern_seq_start = v12;
              if ( WWW_TraceFlag[0] )
              {
                v2 = TraceFP();
                fprintf(v2, "\nLYpush: pushed as internal link, OK\n");
              }
            }
          }
        }
        if ( !history[nhist].hdoc.internal_link && WWW_TraceFlag[0] )
        {
          v3 = TraceFP();
          fprintf(v3, "\nLYpush: push as internal link requested, %s\n", "but didn't check out!");
        }
      }
      if ( WWW_TraceFlag[0] )
      {
        title = doc->title;
        address = doc->address;
        v6 = nhist;
        v7 = TraceFP();
        fprintf(v7, "\nLYpush[%d]: address:%s\n        title:%s\n", v6, address, title);
      }
      ++nhist;
      return 1;
    }
  }
  else
  {
    if ( !LYforce_no_cache )
      LYoverride_no_cache = 1;
    return 0;
  }
}

//----- (080ABCCF) --------------------------------------------------------
void __cdecl LYpop(DocInfo *doc)
{
  char *title; // edi
  char *address; // ebx
  int v3; // esi
  FILE *v4; // eax

  if ( nhist > 0 )
  {
    clean_extra_history();
    --nhist;
    LYFreeDocInfo(doc);
    *doc = history[nhist].hdoc;
    LYSetNewline(doc->line);
    if ( WWW_TraceFlag[0] )
    {
      title = doc->title;
      address = doc->address;
      v3 = nhist;
      v4 = TraceFP();
      fprintf(v4, "LYpop[%d]: address:%s\n     title:%s\n", v3, address, title);
    }
  }
}

//----- (080ABDA4) --------------------------------------------------------
void __cdecl LYhist_prev(DocInfo *doc)
{
  trace_history("LYhist_prev");
  if ( nhist > 0 && (nhist_extra || nhist < size_history) )
  {
    --nhist;
    ++nhist_extra;
    LYpop_num(nhist, doc);
    trace_history("...LYhist_prev");
  }
}

//----- (080ABE14) --------------------------------------------------------
void __cdecl LYhist_prev_register(DocInfo *doc)
{
  trace_history("LYhist_prev_register");
  if ( nhist > 1 )
  {
    if ( nhist_extra )
    {
      history[nhist].hdoc.link = doc->link;
      history[nhist].hdoc.line = doc->line;
    }
    else if ( LYpush(doc, 0) )
    {
      --nhist;
      ++nhist_extra;
    }
    trace_history("...LYhist_prev_register");
  }
}

//----- (080ABEAC) --------------------------------------------------------
int __cdecl LYhist_next(DocInfo *doc, DocInfo *newdoc)
{
  if ( nhist_extra <= 1 )
    return 0;
  history[nhist].hdoc.link = doc->link;
  history[nhist].hdoc.line = doc->line;
  LYAllocHistory(nhist);
  ++nhist;
  --nhist_extra;
  LYpop_num(nhist, newdoc);
  return 1;
}

//----- (080ABF3F) --------------------------------------------------------
void __cdecl LYpop_num(int number, DocInfo *doc)
{
  FILE *v2; // eax
  int link; // ebx
  FILE *v4; // eax
  int line; // ebx
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  int len; // [esp+14h] [ebp-14h]
  char *src; // [esp+18h] [ebp-10h]
  char *title; // [esp+1Ch] [ebp-Ch]
  char *address; // [esp+20h] [ebp-8h]

  if ( number >= 0 && nhist_extra + nhist > number )
  {
    doc->link = history[number].hdoc.link;
    doc->line = history[number].hdoc.line;
    HTSACopy(&doc->title, history[number].hdoc.title);
    HTSACopy(&doc->address, history[number].hdoc.address);
    len = history[number].hdoc.post_data ? history[number].hdoc.post_data->len : 0;
    src = history[number].hdoc.post_data ? history[number].hdoc.post_data->str : 0;
    HTSABCopy(&doc->post_data, src, len);
    HTSACopy(&doc->post_content_type, history[number].hdoc.post_content_type);
    HTSACopy(&doc->bookmark, history[number].hdoc.bookmark);
    doc->isHEAD = history[number].hdoc.isHEAD;
    doc->safe = history[number].hdoc.safe;
    doc->internal_link = history[number].hdoc.internal_link;
    LYSetNewline(doc->line);
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "LYpop_num(%d)\n", number);
      if ( WWW_TraceFlag[0] )
      {
        link = doc->link;
        v4 = TraceFP();
        fprintf(v4, "  link    %d\n", link);
      }
      if ( WWW_TraceFlag[0] )
      {
        line = doc->line;
        v6 = TraceFP();
        fprintf(v6, "  line    %d\n", line);
      }
      if ( WWW_TraceFlag[0] )
      {
        if ( doc->title )
          title = doc->title;
        else
          title = (char *)&unk_815DFD2;
        v7 = TraceFP();
        fprintf(v7, "  title   %s\n", title);
      }
      if ( WWW_TraceFlag[0] )
      {
        if ( doc->address )
          address = doc->address;
        else
          address = (char *)&unk_815DFD2;
        v8 = TraceFP();
        fprintf(v8, "  address %s\n", address);
      }
    }
  }
}

//----- (080AC222) --------------------------------------------------------
int __cdecl showhistory(char **newfile)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v5; // [esp+4h] [ebp-44h]
  char *v6; // [esp+8h] [ebp-40h]
  char *v7; // [esp+Ch] [ebp-3Ch]
  const char *v9; // [esp+30h] [ebp-18h]
  const char *v10; // [esp+34h] [ebp-14h]
  FILE *fp0; // [esp+3Ch] [ebp-Ch]
  int x; // [esp+40h] [ebp-8h]
  char *Title; // [esp+44h] [ebp-4h] BYREF

  Title = 0;
  fp0 = InternalPageFP(tempfile_11687, 1);
  if ( !fp0 )
    return -1;
  LYLocalFileToURL(newfile, tempfile_11687);
  LYforce_HTML_mode = 1;
  LYforce_no_cache = 1;
  v5 = gettext("History Page");
  BeginInternalPage(fp0, v5, "keystrokes/history_help.html.gz");
  v7 = gettext("Your recent statusline messages");
  fprintf(fp0, "<p align=right> <a href=\"%s\">[%s]</a>\n", "LYNXMESSAGES:", v7);
  fwrite("<pre>\n", 1u, 6u, fp0);
  v6 = gettext("You selected:");
  fprintf(fp0, "<em>%s</em>\n", v6);
  for ( x = nhist + nhist_extra - 1; x >= 0; --x )
  {
    if ( !history[x].hdoc.title
      || (HTSACopy(&Title, history[x].hdoc.title),
          LYEntify(&Title, 1),
          LYTrimLeading(Title),
          LYTrimTrailing(Title),
          !*Title) )
    {
      v1 = gettext("(No title.)");
      HTSACopy(&Title, v1);
    }
    if ( x > 99 )
    {
      v9 = (const char *)&unk_815DFD2;
    }
    else
    {
      if ( x > 9 )
        v10 = " ";
      else
        v10 = "  ";
      v9 = v10;
    }
    fprintf(fp0, "%s<em>%d</em>. <tab id=t%d><a href=\"%s%d\">%s</a>\n", v9, x, x, "LYNXHIST:", x, Title);
    if ( history[x].hdoc.address )
    {
      HTSACopy(&Title, history[x].hdoc.address);
      LYEntify(&Title, 1);
    }
    else
    {
      v2 = gettext("(no address)");
      HTSACopy(&Title, v2);
    }
    if ( history[x].hdoc.internal_link )
    {
      if ( history[x].intern_seq_start == history[nhist - 1].intern_seq_start )
        v3 = gettext(" (internal)");
      else
        v3 = gettext(" (was internal)");
      HTSACat(&Title, v3);
    }
    fprintf(fp0, "<tab to=t%d>%s\n", x, Title);
  }
  fwrite("</pre>\n", 1u, 7u, fp0);
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  if ( Title )
  {
    free(Title);
    Title = 0;
  }
  return 0;
}

//----- (080AC5AC) --------------------------------------------------------
BOOLEAN __cdecl historytarget(DocInfo *newdoc)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *address; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  DocAddress WWWDoc; // [esp+20h] [ebp-28h] BYREF
  HText *text; // [esp+34h] [ebp-14h]
  HTParentAnchor *tmpanchor; // [esp+38h] [ebp-10h]
  int number; // [esp+3Ch] [ebp-Ch]
  BOOLEAN treat_as_intern; // [esp+43h] [ebp-5h]

  treat_as_intern = 0;
  if ( !newdoc
    || !newdoc->address
    || strlen(newdoc->address) <= 9
    || ((*__ctype_b_loc())[*((unsigned __int8 *)newdoc->address + 9)] & 0x800) == 0 )
  {
    return 0;
  }
  number = atoi((const char *)newdoc->address + 9);
  if ( number > nhist + nhist_extra || number < 0 )
    return 0;
  if ( HTMainText )
  {
    if ( nhist > 0 )
    {
      v1 = gettext("History Page");
      v2 = HTLoadedDocumentTitle();
      if ( !strcmp(v2, v1) )
      {
        v3 = HTLoadedDocumentURL();
        if ( LYIsUIPage3(v3, UIP_HISTORY_0, 0) )
        {
          address = history[nhist - 1].hdoc.address;
          v5 = HTLoadedDocumentURL();
          if ( strcmp(v5, address) )
            HTuncache_current_document();
        }
      }
    }
  }
  LYpop_num(number, newdoc);
  if ( (!newdoc->internal_link || history[number].intern_seq_start != history[nhist - 1].intern_seq_start)
    && (nhist - 1 <= number || !history[nhist - 1].hdoc.internal_link || history[nhist - 1].intern_seq_start != number)
    || LYforce_no_cache == 1 && !LYoverride_no_cache )
  {
    newdoc->internal_link = 0;
  }
  if ( newdoc->post_data )
  {
    WWWDoc = *(DocAddress *)&newdoc->address;
    tmpanchor = HTAnchor_findAddress(&WWWDoc);
    text = (HText *)HTAnchor_document(tmpanchor);
    if ( (LYresubmit_posts != 1 && (LYforce_no_cache != 1 || LYoverride_no_cache) || treat_as_intern && !reloading[0])
      && text
      || strncasecomp(newdoc->address, "LYNXIMGMAP:", 11)
      && (v6 = gettext("Document from Form with POST content.  Resubmit?"), HTConfirm(v6) != 1) )
    {
      if ( !text )
      {
        v7 = gettext("Cancelled!!!");
        HTInfoMsg(v7);
        return 0;
      }
      LYforce_no_cache = 0;
      LYoverride_no_cache = 1;
    }
    else
    {
      LYforce_no_cache = 1;
      LYoverride_no_cache = 0;
    }
  }
  if ( number )
  {
    v8 = gettext(" (From History)");
    HTSACat(&newdoc->title, v8);
  }
  return 1;
}

//----- (080AC8B9) --------------------------------------------------------
int __cdecl LYShowVisitedLinks(char **newfile)
{
  char *v1; // eax
  char *v3; // [esp+4h] [ebp-74h]
  char *v4; // [esp+8h] [ebp-70h]
  _VisitedLink *object; // [esp+30h] [ebp-48h]
  const char *v7; // [esp+34h] [ebp-44h]
  int v8; // [esp+38h] [ebp-40h]
  int v9; // [esp+3Ch] [ebp-3Ch]
  char *v10; // [esp+40h] [ebp-38h]
  _VisitedLink *v11; // [esp+44h] [ebp-34h]
  const char *post_arrow; // [esp+4Ch] [ebp-2Ch]
  const char *arrow; // [esp+50h] [ebp-28h]
  int ret; // [esp+54h] [ebp-24h]
  int offset; // [esp+58h] [ebp-20h]
  HTList *cur; // [esp+5Ch] [ebp-1Ch]
  _VisitedLink *vl; // [esp+60h] [ebp-18h]
  FILE *fp0; // [esp+64h] [ebp-14h]
  int tot; // [esp+68h] [ebp-10h]
  int x; // [esp+6Ch] [ebp-Ch]
  char *Address; // [esp+70h] [ebp-8h] BYREF
  char *Title; // [esp+74h] [ebp-4h] BYREF

  Title = 0;
  Address = 0;
  cur = Visited_Links;
  ret = 0;
  if ( !Visited_Links )
    return -1;
  fp0 = InternalPageFP(tempfile_11922, 1);
  if ( !fp0 )
    return -1;
  LYLocalFileToURL(newfile, tempfile_11922);
  LYRegisterUIPage(*newfile, UIP_VLINKS_0);
  LYforce_HTML_mode = 1;
  LYforce_no_cache = 1;
  v3 = gettext("Visited Links Page");
  BeginInternalPage(fp0, v3, "keystrokes/visited_help.html.gz");
  fprintf(fp0, "<form action=\"%s\" method=\"post\">\n", "LYNXOPTIONS:");
  LYMenuVisitedLinks(fp0, 0);
  fwrite("<input type=\"submit\" value=\"Accept Changes\">\n", 1u, 0x2Du, fp0);
  fwrite("</form>\n", 1u, 8u, fp0);
  fwrite("<P>\n", 1u, 4u, fp0);
  fwrite("<pre>\n", 1u, 6u, fp0);
  v4 = gettext("You visited (POSTs, bookmark, menu and list files excluded):");
  fprintf(fp0, "<em>%s</em>\n", v4);
  if ( (Visited_Links_As & 4) != 0 )
  {
    x = HTList_count(Visited_Links);
    tot = x;
  }
  else
  {
    x = -1;
    tot = -1;
  }
  if ( (Visited_Links_As & 1) != 0 )
  {
    vl = First_tree;
  }
  else if ( (Visited_Links_As & 2) != 0 )
  {
    if ( (Visited_Links_As & 4) != 0 )
      vl = Latest_last.prev_latest;
    else
      vl = Latest_first.next_latest;
    if ( vl == &Latest_last || vl == &Latest_first )
      vl = 0;
  }
  else if ( (Visited_Links_As & 4) != 0 )
  {
    vl = Last_by_first;
  }
  else
  {
    if ( cur && (cur = cur->next) != 0 )
      object = (_VisitedLink *)cur->object;
    else
      object = 0;
    vl = object;
  }
  while ( vl )
  {
    arrow = (const char *)&unk_815DFD2;
    post_arrow = (const char *)&unk_815DFD2;
    if ( (Visited_Links_As & 4) != 0 )
      --x;
    else
      ++x;
    if ( vl == PrevActiveVisitedLink )
    {
      if ( (Visited_Links_As & 4) != 0 )
        ret = tot - x + 2;
      else
        ret = x + 3;
    }
    if ( vl == PrevActiveVisitedLink )
    {
      post_arrow = "<A NAME=current></A>";
      if ( vl->level && (Visited_Links_As & 1) != 0 )
        v7 = "==>";
      else
        v7 = "=>";
      arrow = v7;
      HTSACat(newfile, "#current");
    }
    if ( (Visited_Links_As & 1) != 0 )
    {
      offset = 2 * vl->level;
      if ( offset > 24 )
        offset = (offset + 24) / 2;
      if ( 3 * LYcols / 4 < offset )
        offset = 3 * LYcols / 4;
    }
    else
    {
      if ( x > 99 )
      {
        v8 = 0;
      }
      else
      {
        if ( x > 9 )
          v9 = 1;
        else
          v9 = 2;
        v8 = v9;
      }
      offset = v8;
    }
    if ( !vl->title
      || !*vl->title
      || (HTSACopy(&Title, vl->title), LYEntify(&Title, 1), LYTrimLeading(Title), LYTrimTrailing(Title), !*Title) )
    {
      v1 = gettext("(No title.)");
      HTSACopy(&Title, v1);
    }
    if ( vl->address && *vl->address )
    {
      HTSACopy(&Address, vl->address);
      LYEntify(&Address, 0);
      fprintf(
        fp0,
        "%-*s%s<em>%d</em>. <tab id=t%d><a href=\"%s\">%s</a>\n",
        offset,
        arrow,
        post_arrow,
        x,
        x,
        Address,
        Title);
    }
    else
    {
      fprintf(fp0, "%-*s%s<em>%d</em>. <tab id=t%d><em>%s</em>\n", offset, arrow, post_arrow, x, x, Title);
    }
    if ( Address )
    {
      HTSACopy(&Address, vl->address);
      LYEntify(&Address, 1);
    }
    if ( Address )
      v10 = Address;
    else
      v10 = gettext("(no address)");
    fprintf(fp0, "<tab to=t%d>%s\n", x, v10);
    if ( (Visited_Links_As & 1) != 0 )
    {
      vl = vl->next_tree;
    }
    else if ( (Visited_Links_As & 2) != 0 )
    {
      if ( (Visited_Links_As & 4) != 0 )
        vl = vl->prev_latest;
      else
        vl = vl->next_latest;
      if ( vl == &Latest_last || vl == &Latest_first )
        vl = 0;
    }
    else if ( (Visited_Links_As & 4) != 0 )
    {
      vl = vl->prev_first;
    }
    else
    {
      if ( cur && (cur = cur->next) != 0 )
        v11 = (_VisitedLink *)cur->object;
      else
        v11 = 0;
      vl = v11;
    }
  }
  fwrite("</pre>\n", 1u, 7u, fp0);
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  if ( Title )
  {
    free(Title);
    Title = 0;
  }
  if ( Address )
  {
    free(Address);
    Address = 0;
  }
  return ret;
}

//----- (080ACF58) --------------------------------------------------------
void __cdecl to_stack(char *str)
{
  if ( topOfStack > 39 )
    topOfStack = 0;
  if ( buffstack[topOfStack] )
  {
    free(buffstack[topOfStack]);
    buffstack[topOfStack] = 0;
  }
  buffstack[topOfStack++] = str;
  if ( topOfStack > 39 )
    topOfStack = 0;
}

//----- (080ACFD9) --------------------------------------------------------
void __cdecl LYstatusline_messages_on_exit(char **buf)
{
  int i; // [esp+14h] [ebp-4h]
  int ia; // [esp+14h] [ebp-4h]

  HTSACat(buf, "\n");
  i = topOfStack - 1;
  while ( ++i <= 39 )
  {
    if ( buffstack[i] )
    {
      HTSACat(buf, buffstack[i]);
      HTSACat(buf, "\n");
    }
  }
  ia = -1;
  while ( ++ia < topOfStack )
  {
    if ( buffstack[ia] )
    {
      HTSACat(buf, buffstack[ia]);
      HTSACat(buf, "\n");
    }
  }
}

//----- (080AD096) --------------------------------------------------------
void __cdecl LYstore_message2(const char *message, const char *argument)
{
  char *temp; // [esp+24h] [ebp-4h] BYREF

  if ( message )
  {
    temp = 0;
    if ( argument )
      HTSprintf0(&temp, message, argument);
    else
      HTSprintf0(&temp, message, &unk_815DFD2);
    to_stack(temp);
  }
}

//----- (080AD0E4) --------------------------------------------------------
void __cdecl LYstore_message(const char *message)
{
  char *temp; // [esp+14h] [ebp-4h] BYREF

  if ( message )
  {
    temp = 0;
    HTSACopy(&temp, message);
    to_stack(temp);
  }
}

//----- (080AD116) --------------------------------------------------------
int __cdecl LYLoadMESSAGES(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  char *name; // esi
  char *v5; // ebx
  char *v6; // eax
  void (*put_block)(HTStream *, const char *, int); // ebx
  size_t v8; // eax
  void (*v9)(HTStream *, const char *, int); // ebx
  size_t v10; // eax
  char *v11; // eax
  void (*v12)(HTStream *, const char *, int); // ebx
  size_t v13; // eax
  void (*v14)(HTStream *, const char *, int); // ebx
  size_t v15; // eax
  void (*v16)(HTStream *, const char *, int); // ebx
  size_t v17; // eax
  void (*v18)(HTStream *, const char *, int); // ebx
  size_t v19; // eax
  char *v20; // eax
  void (*v21)(HTStream *, const char *, int); // ebx
  size_t v22; // eax
  char *temp; // [esp+28h] [ebp-20h] BYREF
  int i; // [esp+2Ch] [ebp-1Ch]
  int nummsg; // [esp+30h] [ebp-18h]
  char *buf; // [esp+34h] [ebp-14h] BYREF
  HTStream *target; // [esp+38h] [ebp-10h]
  HTFormat format_in; // [esp+3Ch] [ebp-Ch]

  format_in = HTAtom_for("text/html");
  target = 0;
  buf = 0;
  nummsg = 0;
  temp = 0;
  i = 40;
  while ( --i >= 0 )
  {
    if ( buffstack[i] )
      ++nummsg;
  }
  target = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
  if ( target )
  {
    anAnchor->no_cache = 1;
    HTSprintf0(&buf, "<html>\n<head>\n");
    put_block = target->isa->put_block;
    v8 = strlen(buf);
    put_block(target, buf, v8);
    HTSprintf0(
      &buf,
      "<META %s content=\"text/html;charset=%s\">\n",
      "http-equiv=\"content-type\"",
      LYCharSet_UC[current_char_set].MIMEname);
    v9 = target->isa->put_block;
    v10 = strlen(buf);
    v9(target, buf, v10);
    v11 = gettext("Your recent statusline messages");
    HTSprintf0(&buf, "<title>%s</title>\n</head>\n<body>\n", v11);
    v12 = target->isa->put_block;
    v13 = strlen(buf);
    v12(target, buf, v13);
    if ( nummsg )
    {
      HTSprintf0(&buf, "<ol>\n");
      v14 = target->isa->put_block;
      v15 = strlen(buf);
      v14(target, buf, v15);
      i = topOfStack;
      while ( --i >= 0 )
      {
        if ( buffstack[i] )
        {
          HTSACopy(&temp, buffstack[i]);
          LYEntify(&temp, 1);
          HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg--, temp);
          v16 = target->isa->put_block;
          v17 = strlen(buf);
          v16(target, buf, v17);
        }
      }
      i = 40;
      while ( --i >= topOfStack )
      {
        if ( buffstack[i] )
        {
          HTSACopy(&temp, buffstack[i]);
          LYEntify(&temp, 1);
          HTSprintf0(&buf, "<li value=%d> <em>%s</em>\n", nummsg--, temp);
          v18 = target->isa->put_block;
          v19 = strlen(buf);
          v18(target, buf, v19);
        }
      }
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      HTSprintf0(&buf, "</ol>\n</body>\n</html>\n");
    }
    else
    {
      v20 = gettext("(No messages yet)");
      HTSprintf0(&buf, "<p>%s\n</body>\n</html>\n", v20);
    }
    v21 = target->isa->put_block;
    v22 = strlen(buf);
    v21(target, buf, v22);
    target->isa->_free(target);
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    return 200;
  }
  else
  {
    name = format_out->name;
    v5 = format_in->name;
    v6 = gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf, v6, v5, name);
    HTAlert(buf);
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    return -29999;
  }
}

//----- (080AD510) --------------------------------------------------------
char **__cdecl options_list(OptionType *opt_ptr)
{
  OptionType *tmp_ptr; // [esp+8h] [ebp-10h]
  int pass; // [esp+Ch] [ebp-Ch]
  size_t len; // [esp+10h] [ebp-8h]
  char **result; // [esp+14h] [ebp-4h]

  result = 0;
  for ( pass = 0; pass <= 1; ++pass )
  {
    tmp_ptr = opt_ptr;
    len = 0;
    while ( tmp_ptr )
    {
      if ( pass )
        result[len] = tmp_ptr->name;
      ++len;
      tmp_ptr = tmp_ptr->next;
    }
    if ( pass )
      result[len] = 0;
    else
      result = (char **)calloc(len + 1, 4u);
  }
  return result;
}

//----- (080AD5A0) --------------------------------------------------------
int __cdecl change_form_link_ex(
        int cur,
        DocInfo *newdoc,
        BOOLEAN *refresh_screen,
        BOOLEAN use_last_tfpos,
        BOOLEAN immediate_submit,
        BOOLEAN redraw_only)
{
  char *v6; // eax
  char *v7; // eax
  size_t v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v12; // [esp+20h] [ebp-68h]
  char *text; // [esp+2Ch] [ebp-5Ch]
  char *value; // [esp+38h] [ebp-50h]
  char *v16; // [esp+3Ch] [ebp-4Ch]
  int i_0; // [esp+4Ch] [ebp-3Ch]
  int i; // [esp+50h] [ebp-38h]
  OptionType *opt_ptr; // [esp+54h] [ebp-34h]
  char **my_data; // [esp+5Ch] [ebp-2Ch]
  int c; // [esp+68h] [ebp-20h]
  int newdoc_changed; // [esp+6Ch] [ebp-1Ch]
  char *link_value; // [esp+70h] [ebp-18h]
  char *link_name; // [esp+74h] [ebp-14h]
  _FormInfo *form; // [esp+78h] [ebp-10h]

  form = links[cur].l_form;
  link_name = form->name;
  link_value = form->value;
  newdoc_changed = 0;
  c = 270;
  if ( no_title )
    v12 = -1;
  else
    v12 = 0;
  if ( !form )
    return 270;
  my_data = options_list(form->select_list);
  LYmove(v12 + links[cur].ly, links[cur].lx);
  switch ( form->type )
  {
    case 1:
    case 2:
    case 9:
    case 0xB:
      c = form_getstr(cur, use_last_tfpos, redraw_only);
      if ( form->type == 2 )
      {
        if ( LYstrCells(form->value) > 1023 )
          v16 = star_string;
        else
          v16 = (char *)(1023 - LYstrCells(form->value) + 136025696);
        value = v16;
      }
      else
      {
        value = form->value;
      }
      LYSetHilite(cur, value);
      break;
    case 3:
      if ( form->disabled != 1 )
      {
        if ( form->num_value )
          text = (char *)unchecked_box;
        else
          text = (char *)checked_box;
        LYSetHilite(cur, text);
        form->num_value = form->num_value == 0;
      }
      break;
    case 4:
      if ( form->disabled != 1 )
      {
        if ( form->num_value )
        {
          if ( !user_mode )
          {
            v7 = gettext("One radio button must be checked at all times!");
            HTUserMsg(v7);
          }
        }
        else
        {
          lynx_start_radio_color();
          for ( i_0 = 0; i_0 < nlinks; ++i_0 )
          {
            if ( links[i_0].type == 1
              && links[i_0].l_form->type == 4
              && links[i_0].l_form->number == form->number
              && !strcmp(links[i_0].l_form->name, form->name)
              && links[i_0].l_form->num_value )
            {
              LYmove(links[i_0].ly, links[i_0].lx);
              v8 = strlen(unchecked_radio);
              LYwaddnstr(LYwin, unchecked_radio, v8);
              LYSetHilite(i_0, unchecked_radio);
            }
          }
          lynx_stop_radio_color();
          HText_activateRadioButton(form);
          LYSetHilite(cur, checked_radio);
        }
      }
      break;
    case 5:
    case 0xD:
      if ( form->disabled != 1 )
      {
        if ( form->no_cache && form->submit_method != 3 )
        {
          LYforce_no_cache = 1;
          reloading[0] = 1;
        }
        newdoc_changed = HText_SubmitForm(form, newdoc, link_name, link_value);
        if ( form->submit_method == 3 )
        {
          *refresh_screen = 1;
        }
        else
        {
          newdoc->link = 0;
          newdoc->internal_link = 0;
        }
      }
      break;
    case 6:
      if ( form->disabled != 1 )
      {
        HText_ResetForm(form);
        *refresh_screen = 1;
      }
      break;
    case 7:
      if ( form->select_list )
      {
        if ( form->disabled == 1 )
        {
          LYhandlePopupList(
            form->num_value,
            links[cur].ly,
            links[cur].lx,
            (const char **)my_data,
            form->size,
            form->size_l,
            form->disabled,
            0);
          if ( enable_scrollback )
            c = 12;
          else
            c = 23;
        }
        else
        {
          form->num_value = LYhandlePopupList(
                              form->num_value,
                              links[cur].ly,
                              links[cur].lx,
                              (const char **)my_data,
                              form->size,
                              form->size_l,
                              form->disabled,
                              0);
          opt_ptr = form->select_list;
          for ( i = 0; form->num_value > i; ++i )
            opt_ptr = opt_ptr->next;
          form->value = opt_ptr->name;
          form->cp_submit_value = opt_ptr->cp_submit_value;
          form->value_cs = opt_ptr->value_cs;
          if ( enable_scrollback )
            c = 12;
          else
            c = 23;
        }
      }
      else
      {
        v6 = gettext("Bad HTML!!  Unable to create popup window!");
        HTAlert(v6);
        c = 270;
      }
      break;
    case 0xC:
      if ( redraw_only )
      {
        c = form_getstr(cur, use_last_tfpos, 1);
      }
      else
      {
        if ( !immediate_submit )
          c = form_getstr(cur, use_last_tfpos, 0);
        if ( form->disabled == 1 && (c == 13 || c == 10 || immediate_submit) )
        {
          if ( peek_mouse_link() < 0 )
            c = 9;
          else
            c = 2087;
        }
        else if ( immediate_submit || (c == 13 || c == 10 || c == 2088) && peek_mouse_link() == -1 )
        {
          LYSetHilite(cur, form->value);
          if ( form->submit_action && *form->submit_action )
          {
            if ( form->submit_method == 3 && no_mail )
            {
              v10 = gettext("Mail disallowed!  Cannot submit.");
              HTAlert(v10);
              c = 270;
            }
            else if ( immediate_submit
                   || (!no_file_url
                    || *form->submit_action != 102 && *form->submit_action != 70
                    || strncasecomp(form->submit_action, "file:", 5))
                   && strncasecomp(form->submit_action, "lynx", 4) )
            {
              if ( form->no_cache && form->submit_method != 3 )
              {
                LYforce_no_cache = 1;
                reloading[0] = 1;
              }
              newdoc_changed = HText_SubmitForm(form, newdoc, link_name, form->value);
              if ( form->submit_method == 3 )
              {
                *refresh_screen = 1;
              }
              else
              {
                newdoc->link = 0;
                newdoc->internal_link = 0;
              }
              c = 270;
            }
            else
            {
              c = 2088;
            }
          }
          else
          {
            v9 = gettext("** Bad HTML!!  No form action defined. **");
            HTUserMsg(v9);
            c = 270;
          }
        }
        else
        {
          LYSetHilite(cur, form->value);
        }
      }
      break;
    default:
      break;
  }
  if ( newdoc_changed )
  {
    c = 2046;
  }
  else
  {
    LYforce_no_cache = 0;
    reloading[0] = 0;
  }
  if ( my_data )
    free(my_data);
  return c;
}

//----- (080ADDF9) --------------------------------------------------------
int __cdecl change_form_link(
        int cur,
        DocInfo *newdoc,
        BOOLEAN *refresh_screen,
        BOOLEAN use_last_tfpos,
        BOOLEAN immediate_submit)
{
  return change_form_link_ex(cur, newdoc, refresh_screen, use_last_tfpos, immediate_submit, 0);
}

//----- (080ADE3E) --------------------------------------------------------
void __cdecl LYSetLastTFPos(int pos)
{
  LastTFPos = pos;
}

//----- (080ADE4B) --------------------------------------------------------
int __cdecl form_getstr(int cur, BOOLEAN use_last_tfpos, BOOLEAN redraw_only)
{
  int v3; // eax
  char *v4; // eax
  int current_modifiers; // eax
  int v6; // eax
  int v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int v13; // eax
  char *v15; // eax
  char *v16; // eax
  int v18; // [esp+20h] [ebp-44D8h]
  int v19; // [esp+24h] [ebp-44D4h]
  unsigned int maxlength; // [esp+28h] [ebp-44D0h]
  int for_what; // [esp+2Ch] [ebp-44CCh]
  int v23; // [esp+34h] [ebp-44C4h]
  int v24; // [esp+38h] [ebp-44C0h]
  bool v25; // [esp+3Eh] [ebp-44BAh]
  bool v26; // [esp+3Fh] [ebp-44B9h]
  int v27; // [esp+40h] [ebp-44B8h]
  int v28; // [esp+48h] [ebp-44B0h]
  MEVENT event; // [esp+58h] [ebp-44A0h] BYREF
  int new_len; // [esp+6Ch] [ebp-448Ch]
  int old_len; // [esp+70h] [ebp-4488h]
  int rc; // [esp+74h] [ebp-4484h]
  int c; // [esp+78h] [ebp-4480h]
  unsigned __int8 *e1; // [esp+7Ch] [ebp-447Ch]
  int len; // [esp+80h] [ebp-4478h]
  char *buf; // [esp+84h] [ebp-4474h] BYREF
  unsigned __int8 *e; // [esp+88h] [ebp-4470h]
  unsigned __int8 *s; // [esp+8Ch] [ebp-446Ch]
  int cury; // [esp+90h] [ebp-4468h]
  int curx; // [esp+94h] [ebp-4464h]
  int last_xlkc; // [esp+98h] [ebp-4460h]
  int repeat; // [esp+9Ch] [ebp-445Ch]
  int action; // [esp+A0h] [ebp-4458h]
  int startline; // [esp+A4h] [ebp-4454h]
  int startcol; // [esp+A8h] [ebp-4450h]
  int max_length; // [esp+ACh] [ebp-444Ch]
  int far_col; // [esp+B0h] [ebp-4448h]
  int ch_0; // [esp+B4h] [ebp-4444h]
  char *value; // [esp+B8h] [ebp-4440h]
  FormInfo *form; // [esp+BCh] [ebp-443Ch]
  BOOLEAN Edited; // [esp+C1h] [ebp-4437h]
  BOOLEAN refresh_mb; // [esp+C2h] [ebp-4436h]
  BOOLEAN HaveMaxlength; // [esp+C3h] [ebp-4435h]
  EditFieldData MyEdit; // [esp+C4h] [ebp-4434h] BYREF
  unsigned int v55; // [esp+44F0h] [ebp-8h]

  v55 = __readgsdword(0x14u);
  form = links[cur].l_form;
  value = form->value;
  HaveMaxlength = 0;
  last_xlkc = -1;
  refresh_mb = 1;
  Edited = 0;
  if ( LYwin )
    v18 = LYwin->_cury;
  else
    v18 = -1;
  startline = v18;
  if ( LYwin )
    v19 = LYwin->_curx;
  else
    v19 = -1;
  startcol = v19;
  if ( v19 + form->size <= LYcols - (LYShowScrollbar != 0) )
    v3 = startcol + form->size;
  else
    v3 = LYcols - (LYShowScrollbar != 0);
  far_col = v3;
  if ( form->maxlength && form->maxlength <= 0x3FF )
    maxlength = form->maxlength;
  else
    maxlength = 1023;
  max_length = maxlength;
  if ( strlen(form->value) > maxlength )
  {
    value += strlen(form->value) - max_length;
    if ( !form->disabled && (form->submit_method != 3 || !no_mail) )
    {
      v4 = gettext("Form field value exceeds buffer length!  Trim the tail.");
      HTUserMsg(v4);
      if ( redraw_only )
        for_what = 0;
      else
        for_what = 2;
      show_formlink_statusline(form, for_what);
      LYmove(startline, startcol);
    }
  }
  LYSetupEdit(&MyEdit, value, max_length, far_col - startcol);
  MyEdit.pad = 95;
  MyEdit.hidden = form->type == 2;
  if ( use_last_tfpos )
  {
    if ( LastTFPos >= 0 && MyEdit.strlen > LastTFPos )
    {
      MyEdit.pos = LastTFPos;
      if ( !LastTFPos )
        MyEdit.mark = ~MyEdit.strlen;
    }
  }
  if ( peek_mouse_levent() && !use_last_tfpos )
    MyEdit.pos = 0;
  LYRefreshEdit(&MyEdit);
  if ( redraw_only )
    return 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          do
          {
again:
            repeat = -1;
            get_mouse_link();
            ch_0 = LYgetch_input();
          }
          while ( !refresh_mb && EditBinding(ch_0) != 1 && EditBinding(ch_0) != 24 );
          action = 0;
          if ( ch_0 != -1 && (ch_0 & 0x800) != 0 && (ch_0 & 0x8000) == 0 )
            goto breakfor;
          if ( ch_0 == 285 )
          {
            getmouse(&event);
            v23 = LYwin ? LYwin->_cury : -1;
            cury = v23;
            v24 = LYwin ? LYwin->_curx : -1;
            curx = v24;
            if ( event.y == cury )
            {
              repeat = event.x - curx;
              if ( event.x - curx >= 0 )
              {
                action = 15;
              }
              else
              {
                action = 17;
                repeat = -repeat;
              }
            }
            else
            {
              MyEdit.dirty = 1;
            }
            last_xlkc = -1;
          }
          else
          {
            if ( (ch_0 & 0x8000) == 0 )
              ch_0 |= MyEdit.current_modifiers;
            MyEdit.current_modifiers = 0;
            if ( last_xlkc != -1 )
            {
              if ( ch_0 == last_xlkc )
                ch_0 |= 0x1000u;
              last_xlkc = -1;
            }
          }
          if ( peek_mouse_link() != -1 )
            goto breakfor;
          if ( !action )
            action = EditBinding(ch_0);
          if ( (action & 0x80) == 0 || (action & 0x1000) != 0 )
          {
            last_xlkc = -1;
          }
          else
          {
            last_xlkc = ch_0;
            action &= ~0x80u;
          }
          if ( action != 29 )
            break;
          current_modifiers = MyEdit.current_modifiers;
          BYTE1(current_modifiers) = BYTE1(MyEdit.current_modifiers) | 0x40;
          MyEdit.current_modifiers = current_modifiers;
        }
        if ( action != 30 )
          break;
        v6 = MyEdit.current_modifiers;
        BYTE1(v6) = BYTE1(MyEdit.current_modifiers) | 0x20;
        MyEdit.current_modifiers = v6;
      }
      if ( action == 2 || action == 6 )
        goto breakfor;
      if ( (action & 0x1000) != 0 )
      {
        v7 = (unsigned __int8)action;
        BYTE1(v7) = 8;
        ch_0 = v7;
        goto breakfor;
      }
      if ( action == 23 )
      {
        mustshow[0] = 1;
        v8 = gettext("Enter Lynx keystroke command: ");
        statusline(v8);
        ch_0 = LYgetch();
        goto breakfor;
      }
      if ( action == 37 )
        break;
LABEL_106:
      if ( action == 24 && HTCJK == NOCJK && LYlowest_eightbit[current_char_set] > 151 )
        goto breakfor;
      switch ( action )
      {
        case 3:
          ch_0 = 9;
          goto breakfor;
        case 5:
          return 270;
        case 4:
          textfields_need_activation = 1;
          goto breakfor;
        case 0:
          if ( ch_0 == -1 )
          {
            v25 = keymap[0] == 21;
          }
          else
          {
            v26 = (ch_0 & 0x8800) != 0 ? (unsigned __int8)ch_0 == 21 : keymap[(ch_0 & 0x7FF) + 1] == 21;
            v25 = v26;
          }
          if ( v25 )
            goto breakfor;
          break;
      }
      if ( action == 17 && !MyEdit.pos && repeat == -1 )
      {
        c = 1;
        if ( textfield_prompt_at_left_edge[0] || strcmp(MyEdit.buffer, value) )
        {
          v11 = gettext("Do you want to go back to the previous document?");
          c = HTConfirmDefault(v11, 0);
        }
        if ( c == 1 )
          return ch_0;
        if ( form->disabled == 1 )
        {
          mustshow[0] = 1;
          v12 = gettext("Use arrows or tab to move off of field.");
        }
        else
        {
          mustshow[0] = 1;
          v12 = gettext("Enter text.  Use arrows or tab to move off of field.");
        }
        statusline(v12);
      }
      if ( form->disabled != 1 || (unsigned int)(action - 13) <= 0x15 && ((1 << (action - 13)) & 0x3000FF) != 0 )
      {
        if ( repeat < 0 )
          repeat = 1;
        while ( 2 )
        {
          if ( repeat-- == 0 )
          {
            if ( MyEdit.strlen < max_length )
            {
              if ( HaveMaxlength && MyEdit.strlen < max_length )
              {
                HaveMaxlength = 0;
                mustshow[0] = 1;
                v15 = gettext("Enter text.  Use arrows or tab to move off of field.");
                statusline(v15);
              }
            }
            else
            {
              HaveMaxlength = 1;
            }
            if ( strcmp(value, MyEdit.buffer) )
              Edited = 1;
            if ( refresh_mb )
              LYRefreshEdit(&MyEdit);
            LYSetLastTFPos(MyEdit.pos);
            goto again;
          }
          v13 = action;
          LOBYTE(v13) = action & 0x7F;
          rc = LYEdit1(&MyEdit, ch_0, v13, 1);
          if ( rc < 0 )
          {
            ch_0 = -rc;
            if ( action != 18 && action != 16 )
              goto breakfor;
            if ( cur >= 0 && cur < nlinks )
            {
              if ( action == 16 )
              {
                if ( nlinks - 1 > cur )
                  goto LABEL_149;
              }
              else if ( cur > 0 )
              {
LABEL_149:
                if ( action == 16 )
                  v27 = 1;
                else
                  v27 = -1;
                if ( links[cur + v27].ly == links[cur].ly )
                  goto breakfor;
              }
            }
          }
          if ( rc )
          {
            if ( !refresh_mb )
              LYEdit1(&MyEdit, 0, 9, 1);
          }
          else
          {
            refresh_mb = HTCJK == NOCJK || ch_0 <= 127 || ch_0 > 254 || !refresh_mb;
          }
          continue;
        }
      }
    }
    s = (unsigned __int8 *)get_clip_grab();
    buf = 0;
    if ( !s )
      goto breakfor;
    len = strlen((const char *)s);
    e = &s[len];
    if ( len > 0 )
      break;
    v10 = gettext("Clipboard empty or Not text data.");
    HTInfoMsg(v10);
  }
  e1 = s;
  while ( e1 < e )
  {
    if ( *e1 > 0x1Fu )
    {
      ++e1;
    }
    else
    {
      if ( e1 > s )
        LYEditInsert(&MyEdit, s, e1 - s, -1, 1);
      s = e1;
      if ( *e1 != 9 )
        break;
      LYEditInsert(&MyEdit, " ", 1, -1, 1);
      s = ++e1;
    }
  }
  if ( e1 > s )
    LYEditInsert(&MyEdit, s, e1 - s, -1, 1);
  while ( e1 < e && *e1 == 13 )
    ++e1;
  if ( e1 + 1 < e && *e1 == 10 )
    HTSACopy(&buf, (const char *)e1 + 1);
  get_clip_release();
  if ( MyEdit.strlen < max_length )
  {
    if ( HaveMaxlength && MyEdit.strlen < max_length )
    {
      HaveMaxlength = 0;
      mustshow[0] = 1;
      v9 = gettext("Enter text.  Use arrows or tab to move off of field.");
      statusline(v9);
    }
  }
  else
  {
    HaveMaxlength = 1;
  }
  if ( strcmp(value, MyEdit.buffer) )
    Edited = 1;
  if ( !buf )
  {
    LYRefreshEdit(&MyEdit);
    goto LABEL_106;
  }
  put_clip(buf);
  if ( buf )
  {
    free(buf);
    buf = 0;
  }
  ch_0 = 10;
breakfor:
  if ( Edited )
  {
    if ( form->value == value )
    {
      HTSACopy(&form->value, MyEdit.buffer);
    }
    else
    {
      old_len = strlen(form->value);
      new_len = strlen(value);
      if ( old_len <= new_len )
        v28 = 0;
      else
        v28 = old_len - new_len;
      form->value[v28] = 0;
      HTSACat(&form->value, MyEdit.buffer);
      v16 = gettext("Modified tail combined with head of form field value.");
      HTUserMsg(v16);
    }
    if ( LYtrimInputFields )
      LYTrimTrailing(form->value);
    if ( form->value && *form->value )
      form->value_cs = current_char_set;
  }
  return ch_0;
}

//----- (080AECD1) --------------------------------------------------------
void __cdecl show_formlink_statusline(const FormInfo *form, int for_what)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *xkey_info_0; // [esp+1Ch] [ebp-Ch]
  char *submit_str; // [esp+20h] [ebp-8h] BYREF
  char *xkey_info; // [esp+24h] [ebp-4h]

  switch ( form->type )
  {
    case 1:
      if ( form->disabled == 1 )
        goto LABEL_66;
      if ( for_what )
        v3 = gettext("(Text entry field) Enter text.  Use UP or DOWN arrows or tab to move off.");
      else
        v3 = gettext("(Text entry field) Inactive.  Press <return> to activate.");
      goto LABEL_69;
    case 2:
      if ( form->disabled == 1 )
      {
        v2 = gettext("UNMODIFIABLE form password.  Use UP or DOWN arrows or tab to move off.");
        statusline(v2);
        return;
      }
      if ( for_what )
        v3 = gettext("(Password entry field) Enter text.  Use UP or DOWN arrows or tab to move off.");
      else
        v3 = gettext("(Password entry field) Inactive.  Press <return> to activate.");
      goto LABEL_69;
    case 3:
      if ( form->disabled == 1 )
        v3 = gettext("UNMODIFIABLE form checkbox.  Use UP or DOWN arrows or tab to move off.");
      else
        v3 = gettext("(Checkbox Field)   Use right-arrow or <return> to toggle.");
      goto LABEL_69;
    case 4:
      if ( form->disabled == 1 )
        v3 = gettext("UNMODIFIABLE form radio button.  Use UP or DOWN arrows or tab to move off.");
      else
        v3 = gettext("(Radio Button)   Use right-arrow or <return> to toggle.");
      goto LABEL_69;
    case 5:
    case 0xD:
      if ( form->disabled == 1 )
      {
        v8 = gettext("DISABLED form submit button.  Use UP or DOWN arrows or tab to move off.");
        statusline(v8);
        return;
      }
      if ( form->submit_method == 3 )
      {
        if ( no_mail )
        {
          v9 = gettext("(mailto form submit button) Mail is disallowed so you cannot submit.");
          statusline(v9);
          return;
        }
        if ( user_mode != 2 )
        {
          v11 = gettext("(mailto form submit button) Use right-arrow or <return> to submit.");
          statusline(v11);
          return;
        }
        submit_str = 0;
        v10 = gettext("Submit mailto form to ");
        HTSACopy(&submit_str, v10);
        HTSACat(&submit_str, form->submit_action);
        statusline(submit_str);
        if ( !submit_str )
          return;
LABEL_57:
        free(submit_str);
        submit_str = 0;
        return;
      }
      if ( form->no_cache )
      {
        if ( user_mode != 2 )
        {
          v13 = gettext("(Form submit button) Use right-arrow or <return> to submit.");
          statusline(v13);
          return;
        }
        submit_str = 0;
        v12 = gettext("Submit to ");
        HTSACopy(&submit_str, v12);
        HTSACat(&submit_str, form->submit_action);
        statusline(submit_str);
        if ( !submit_str )
          return;
        goto LABEL_57;
      }
      if ( user_mode == 2 )
      {
        submit_str = 0;
        v14 = gettext("Submit ('x' for no cache) to ");
        HTSACopy(&submit_str, v14);
        HTSACat(&submit_str, form->submit_action);
        statusline(submit_str);
        if ( !submit_str )
          return;
        goto LABEL_57;
      }
      v15 = gettext("(Form submit button) Use right-arrow or <return> to submit ('x' for no cache).");
      statusline(v15);
      return;
    case 6:
      if ( form->disabled == 1 )
        v3 = gettext("DISABLED form reset button.  Use UP or DOWN arrows or tab to move off.");
      else
        v3 = gettext("(Form reset button)   Use right-arrow or <return> to reset form to defaults.");
      goto LABEL_69;
    case 7:
      if ( form->disabled == 1 )
        v3 = gettext("UNMODIFIABLE option list.  Use return or arrow keys to review or leave.");
      else
        v3 = gettext("(Option list) Hit return and use arrow keys and return to select option.");
      goto LABEL_69;
    case 9:
      if ( form->disabled == 1 )
      {
LABEL_66:
        v16 = gettext("UNMODIFIABLE form text field.  Use UP or DOWN arrows or tab to move off.");
        statusline(v16);
      }
      else
      {
        submit_str = 0;
        xkey_info_0 = 0;
        if ( !no_editor )
        {
          if ( editor )
          {
            xkey_info_0 = key_for_func_ext(86, for_what);
            if ( !xkey_info_0 )
              xkey_info_0 = key_for_func_ext(85, for_what);
          }
        }
        if ( xkey_info_0 && *xkey_info_0 )
        {
          if ( for_what )
            v17 = gettext("(Textarea) Enter text. Use UP/DOWN arrows or TAB to move off (%s for editor).");
          else
            v17 = gettext("(Textarea) Inactive.  Press <return> to activate (%s for editor).");
          HTSprintf0(&submit_str, v17, xkey_info_0);
          statusline(submit_str);
          if ( submit_str )
          {
            free(submit_str);
            submit_str = 0;
          }
        }
        else
        {
          if ( for_what )
            v18 = gettext("(Textarea) Enter text. Use UP/DOWN arrows or TAB to move off.");
          else
            v18 = gettext("(Textarea) Inactive.  Press <return> to activate.");
          statusline(v18);
        }
        if ( xkey_info_0 )
          free(xkey_info_0);
      }
      return;
    case 0xB:
      if ( form->disabled == 1 )
        v3 = gettext("UNMODIFIABLE file entry field.  Use UP or DOWN arrows or tab to move off.");
      else
        v3 = gettext("(File entry field) Enter filename.  Use UP or DOWN arrows or tab to move off.");
      goto LABEL_69;
    case 0xC:
      if ( form->disabled == 1 )
      {
        v4 = gettext("UNMODIFIABLE form field.  Use UP or DOWN arrows or tab to move off.");
        statusline(v4);
        return;
      }
      if ( form->submit_method == 3 )
      {
        if ( no_mail )
        {
          v5 = gettext("(mailto form field) Mail is disallowed so you cannot submit.");
          statusline(v5);
          return;
        }
        if ( for_what )
          v3 = gettext("(mailto form field) Enter text.  Use <return> to submit, arrows to move off.");
        else
          v3 = gettext("(mailto form field) Inactive.  Press <return> to change.");
        goto LABEL_69;
      }
      if ( form->no_cache )
      {
        if ( for_what )
          v3 = gettext("(Form field) Enter text.  Use <return> to submit, arrows or tab to move off.");
        else
          v3 = gettext("(Form field) Inactive. Press <return> to edit, press <return> twice to submit.");
LABEL_69:
        statusline(v3);
        return;
      }
      submit_str = 0;
      xkey_info = key_for_func_ext(46, for_what);
      if ( xkey_info && *xkey_info )
      {
        if ( for_what )
          v6 = gettext("(Form field) Enter text.  Use <return> to submit (%s for no cache).");
        else
          v6 = gettext("(Form field) Inactive.  Use <return> to edit (%s to submit with no cache).");
        HTSprintf0(&submit_str, v6, xkey_info);
        statusline(submit_str);
        if ( submit_str )
        {
          free(submit_str);
          submit_str = 0;
        }
      }
      else
      {
        if ( for_what )
          v7 = gettext("(Form field) Enter text.  Use <return> to submit.");
        else
          v7 = gettext("(Form field) Inactive.  Use <return> to edit.");
        statusline(v7);
      }
      if ( xkey_info )
      {
        free(xkey_info);
        xkey_info = 0;
      }
      return;
    default:
      return;
  }
}

//----- (080AF3E8) --------------------------------------------------------
void __cdecl set_environ(int name, const char *value, const char *no_value)
{
  char *envbuffer; // [esp+24h] [ebp-4h] BYREF

  envbuffer = 0;
  HTSACopy(&envbuffer, names_10883[name]);
  HTSACat(&envbuffer, "=");
  if ( value )
    HTSACat(&envbuffer, value);
  else
    HTSACat(&envbuffer, no_value);
  putenv(envbuffer);
  if ( pointers_10884[name] )
  {
    free(pointers_10884[name]);
    pointers_10884[name] = 0;
  }
  pointers_10884[name] = envbuffer;
}

//----- (080AF48F) --------------------------------------------------------
char *__cdecl suggested_filename(DocInfo *newdoc)
{
  const char *SugFname; // eax
  const char *v2; // ebx
  FILE *v3; // eax
  int rootlen; // [esp+1Ch] [ebp-Ch] BYREF
  char *sug_filename[2]; // [esp+20h] [ebp-8h] BYREF

  sug_filename[0] = 0;
  if ( HText_getSugFname() )
  {
    SugFname = HText_getSugFname();
    HTSACopy(sug_filename, SugFname);
  }
  else
  {
    HTSACopy(sug_filename, newdoc->address);
  }
  if ( HTCompressFileType(sug_filename[0], ".", &rootlen) )
    sug_filename[0][rootlen] = 0;
  if ( WWW_TraceFlag[0] )
  {
    v2 = sug_filename[0];
    v3 = TraceFP();
    fprintf(v3, "suggest %s\n", v2);
  }
  return sug_filename[0];
}

//----- (080AF52D) --------------------------------------------------------
void __cdecl SetupFilename(char *filename, const char *sug_filename)
{
  char *name; // ebx
  FILE *v3; // eax
  HTAtom *v4; // eax
  HTAtom *v5; // eax
  HTAtom *v6; // eax
  HTAtom *v7; // eax
  FILE *v8; // eax
  char *cp; // [esp+18h] [ebp-10h]
  HTAtom *encoding; // [esp+1Ch] [ebp-Ch] BYREF
  HTFormat format; // [esp+20h] [ebp-8h]

  LYstrncpy(filename, sug_filename, 255);
  change_sug_filename(filename);
  if ( !HTisDocumentSource() )
  {
    cp = strrchr(filename, 46);
    if ( cp )
    {
      if ( cp - filename <= 249 )
      {
        format = HTFileFormat(filename, &encoding, 0);
        if ( WWW_TraceFlag[0] )
        {
          name = format->name;
          v3 = TraceFP();
          fprintf(v3, "... format %s\n", name);
        }
        if ( !strcasecomp(format->name, "text/html")
          || encoding
          && (v4 = HTAtom_for("identity"), v4 != encoding)
          && (v5 = HTAtom_for("8bit"), v5 != encoding)
          && (v6 = HTAtom_for("binary"), v6 != encoding)
          && (v7 = HTAtom_for("7bit"), v7 != encoding) )
        {
          memcpy(cp, ".txt", 5u);
        }
      }
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v8 = TraceFP();
    fprintf(v8, "... result %s\n", filename);
  }
}

//----- (080AF6A1) --------------------------------------------------------
int __cdecl RecallFilename(char *filename, BOOLEAN *first, int *now, int *total, int flag)
{
  char *v5; // eax
  char *v6; // eax
  int v7; // edx
  char *v8; // eax
  int v10; // [esp+10h] [ebp-18h]
  _BOOL4 recall; // [esp+1Ch] [ebp-Ch]
  char *cp; // [esp+20h] [ebp-8h]
  char *cpa; // [esp+20h] [ebp-8h]
  int ch_0; // [esp+24h] [ebp-4h]

  if ( *now < 0 )
  {
    if ( sug_filenames )
      v10 = HTList_count(sug_filenames);
    else
      v10 = 0;
    *total = v10;
    *now = *total;
  }
  recall = *total > 0;
  ch_0 = LYgetstr(filename, 0, 0x100u, (RecallType)recall);
  if ( ch_0 >= 0 && *filename && ch_0 != 256 && ch_0 != 257 )
    return 2;
  if ( !recall || ch_0 != 256 )
  {
    if ( recall && ch_0 == 257 )
    {
      if ( *first )
      {
        *first = 0;
        v7 = *total - 1;
      }
      else
      {
        v7 = *now - 1;
      }
      *now = v7;
      if ( *now < 0 )
        goto LABEL_16;
      cpa = (char *)HTList_objectAt(sug_filenames, *now);
      if ( cpa )
      {
        LYstrncpy(filename, cpa, 255);
        if ( *total == 1 )
          goto LABEL_19;
        goto LABEL_20;
      }
    }
LABEL_31:
    if ( flag )
    {
      if ( flag == 1 )
        return 3;
    }
    else
    {
      v8 = gettext("Save request cancelled!!!");
      HTInfoMsg(v8);
    }
    return 3;
  }
  if ( *first )
  {
    *first = 0;
    *now = 0;
  }
  else
  {
    ++*now;
  }
  if ( *now < *total )
  {
    cp = (char *)HTList_objectAt(sug_filenames, *now);
    if ( cp )
    {
      LYstrncpy(filename, cp, 255);
      if ( *total == 1 )
      {
LABEL_19:
        mustshow[0] = 1;
        v6 = gettext("Edit the previous filename: ");
LABEL_21:
        statusline(v6);
        return 1;
      }
LABEL_20:
      mustshow[0] = 1;
      v6 = gettext("Edit a previous filename: ");
      goto LABEL_21;
    }
    goto LABEL_31;
  }
LABEL_16:
  *first = 1;
  *now = *total;
  mustshow[0] = 1;
  v5 = gettext("Enter a filename: ");
  statusline(v5);
  return 0;
}

//----- (080AF997) --------------------------------------------------------
BOOLEAN __cdecl confirm_by_pages(const char *prompt, int lines_in_file, int lines_per_page)
{
  char *v3; // eax
  char *msg; // [esp+2Ch] [ebp-Ch] BYREF
  int c; // [esp+30h] [ebp-8h]
  int pages; // [esp+34h] [ebp-4h]

  pages = lines_in_file / (lines_per_page + 1);
  if ( lines_in_file % (LYlines + 1) > 0 )
    ++pages;
  if ( pages <= 4 )
    return 1;
  msg = 0;
  HTSprintf0(&msg, prompt, pages);
  c = HTConfirmDefault(msg, 1);
  if ( msg )
  {
    free(msg);
    msg = 0;
  }
  if ( c == 1 )
  {
    LYwaddnstr(LYwin, "   Ok...", 8u);
    return 1;
  }
  v3 = gettext("Print request cancelled!!!");
  HTInfoMsg(v3);
  return 0;
}

//----- (080AFA7A) --------------------------------------------------------
void __cdecl send_file_to_file(DocInfo *newdoc, char *content_base, char *sug_filename)
{
  char *v3; // eax
  size_t v4; // ebx
  char *v5; // eax
  char *v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  int v9; // ebx
  FILE *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int v13; // ebx
  FILE *v14; // eax
  const char *Date; // eax
  const char *v16; // ebx
  const char *LastModified; // eax
  const char *v18; // eax
  const char *v19; // eax
  int v20; // [esp+18h] [ebp-240h]
  int v21; // [esp+1Ch] [ebp-23Ch]
  FILE *v22; // [esp+20h] [ebp-238h]
  int FnameTotal; // [esp+3Ch] [ebp-21Ch] BYREF
  int FnameNum; // [esp+40h] [ebp-218h] BYREF
  FILE *outfile_fp; // [esp+44h] [ebp-214h]
  const char *disp_charset; // [esp+48h] [ebp-210h]
  BOOLEAN use_cte; // [esp+4Eh] [ebp-20Ah]
  BOOLEAN FirstRecall; // [esp+4Fh] [ebp-209h] BYREF
  char filename[256]; // [esp+50h] [ebp-208h] BYREF
  char buffer[256]; // [esp+150h] [ebp-108h] BYREF
  unsigned int v32; // [esp+250h] [ebp-8h]

  v32 = __readgsdword(0x14u);
  FirstRecall = 1;
  FnameNum = -1;
  mustshow[0] = 1;
  v3 = gettext("Enter a filename: ");
  statusline(v3);
  while ( 1 )
  {
    SetupFilename(filename, sug_filename);
    if ( lynx_save_space )
    {
      v4 = strlen(lynx_save_space);
      if ( v4 + strlen(filename) <= 0xFF )
      {
        strcpy(buffer, lynx_save_space);
        strcat(buffer, filename);
        strcpy(filename, buffer);
      }
    }
    do
      v20 = RecallFilename(filename, &FirstRecall, &FnameNum, &FnameTotal, 0);
    while ( v20 == 1 );
    if ( v20 == 3 )
      break;
    if ( v20 )
    {
      if ( !LYValidateFilename(buffer, filename) )
      {
        v5 = gettext("Save request cancelled!!!");
        HTInfoMsg(v5);
        return;
      }
      v21 = LYValidateOutput(buffer);
      if ( v21 == 78 )
      {
        mustshow[0] = 1;
        v6 = gettext("Enter a new filename: ");
        statusline(v6);
        FirstRecall = 1;
        FnameNum = FnameTotal;
      }
      else
      {
        if ( v21 != 89 )
          return;
        if ( WWW_TraceFlag[0] )
        {
          v7 = TraceFP();
          fprintf(v7, "LYPrint: filename is %s, action is `%c'\n", buffer, 0);
        }
        if ( buffer[0] == 124 )
        {
          if ( !no_shell )
          {
            outfile_fp = popen(&buffer[1], "w");
            if ( outfile_fp )
              goto LABEL_32;
            if ( WWW_TraceFlag[0] )
            {
              v9 = *__errno_location();
              v10 = TraceFP();
              fprintf(v10, "LYPrint: errno is %d\n", v9);
            }
            goto LABEL_21;
          }
          v8 = gettext("Spawning is currently disabled.");
          HTUserMsg(v8);
          FirstRecall = 1;
          FnameNum = FnameTotal;
        }
        else
        {
          if ( (**__ctype_b_loc() & 0x200) != 0 && toupper(0) == 65 )
            v22 = LYAppendToTxtFile(buffer);
          else
            v22 = LYNewTxtFile(buffer);
          outfile_fp = v22;
          if ( v22 )
          {
LABEL_32:
            if ( LYPrependBaseToSource && HTisDocumentSource() )
            {
              fprintf(outfile_fp, "<!-- X-URL: %s -->\n", newdoc->address);
              if ( HText_getDate() )
              {
                Date = HText_getDate();
                fprintf(outfile_fp, "<!-- Date: %s -->\n", Date);
                if ( HText_getLastModified() )
                {
                  v16 = HText_getDate();
                  LastModified = HText_getLastModified();
                  if ( strcmp(LastModified, v16) )
                  {
                    v18 = HText_getLastModified();
                    if ( strcmp(v18, "Thu, 01 Jan 1970 00:00:01 GMT") )
                    {
                      v19 = HText_getLastModified();
                      fprintf(outfile_fp, "<!-- Last-Modified: %s -->\n", v19);
                    }
                  }
                }
              }
              fprintf(outfile_fp, "<BASE HREF=\"%s\">\n", content_base);
            }
            if ( LYPrependCharsetToSource )
            {
              if ( HTisDocumentSource() )
              {
                use_cte = HTLoadedDocumentEightbit();
                disp_charset = LYCharSet_UC[current_char_set].MIMEname;
                if ( use_cte )
                {
                  if ( !LYHaveCJKCharacterSet && strncasecomp(disp_charset, "x-", 2) )
                    fprintf(
                      outfile_fp,
                      "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n",
                      disp_charset);
                }
              }
            }
            print_wwwfile_to_fd(outfile_fp, 0, 0);
            if ( keypad_mode )
              printlist(outfile_fp, 0);
            if ( buffer[0] == 124 )
              pclose(outfile_fp);
            else
              LYCloseOutput(outfile_fp);
            HTAddSugFilename(buffer);
            return;
          }
          if ( WWW_TraceFlag[0] )
          {
            v13 = *__errno_location();
            v14 = TraceFP();
            fprintf(v14, "LYPrint: errno is %d\n", v13);
          }
LABEL_21:
          v11 = gettext("Cannot write to file.");
          HTAlert(v11);
          mustshow[0] = 1;
          v12 = gettext("Enter a new filename: ");
          statusline(v12);
          FirstRecall = 1;
          FnameNum = FnameTotal;
        }
      }
    }
  }
}

//----- (080B0085) --------------------------------------------------------
void __cdecl send_file_to_mail(DocInfo *newdoc, char *content_base, char *content_location)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  bool v8; // [esp+10h] [ebp-438h]
  bool v9; // [esp+14h] [ebp-434h]
  bool v10; // [esp+18h] [ebp-430h]
  char *subject; // [esp+30h] [ebp-418h] BYREF
  char *buffer; // [esp+34h] [ebp-414h]
  FILE *outfile_fp; // [esp+38h] [ebp-410h]
  const char *disp_charset; // [esp+3Ch] [ebp-40Ch]
  BOOLEAN use_type; // [esp+41h] [ebp-407h]
  BOOLEAN use_cte; // [esp+42h] [ebp-406h]
  BOOLEAN use_mime; // [esp+43h] [ebp-405h]
  char user_response[1024]; // [esp+44h] [ebp-404h] BYREF
  unsigned int v19; // [esp+444h] [ebp-4h]

  v19 = __readgsdword(0x14u);
  buffer = 0;
  subject = 0;
  if ( !(unsigned __int8)LYSystemMail() )
    return;
  if ( !LYPreparsedSource || !first_mail_preparsed_11280 || !HTisDocumentSource() )
    goto LABEL_8;
  v3 = gettext("Viewing preparsed source.  Are you sure you want to mail it?");
  if ( HTConfirmDefault(v3, 0) == 1 )
  {
    LYwaddnstr(LYwin, "   Ok...", 8u);
    first_mail_preparsed_11280 = 0;
LABEL_8:
    mustshow[0] = 1;
    v5 = gettext("Please enter a valid internet mail address: ");
    statusline(v5);
    LYstrncpy(user_response, personal_mail_address, 1023);
    if ( LYgetstr(user_response, 0, 0x400u, RECALL_MAIL) >= 0 && user_response[0] )
    {
      disp_charset = LYCharSet_UC[current_char_set].MIMEname;
      use_cte = HTLoadedDocumentEightbit();
      if ( !use_cte || !strncasecomp(disp_charset, "x-", 2) )
      {
        disp_charset = 0;
        use_cte = 0;
      }
      v8 = disp_charset || HTisDocumentSource();
      use_type = v8;
      subject = subject_translate8bit(newdoc->title);
      if ( newdoc->isHEAD )
      {
        if ( subject )
        {
          free(subject);
          subject = 0;
        }
        HTSACopy(&subject, "HEAD  ");
        HTSACat(&subject, newdoc->address);
      }
      outfile_fp = LYPipeToMailer();
      if ( outfile_fp )
      {
        use_cte = HTLoadedDocumentEightbit();
        disp_charset = LYCharSet_UC[current_char_set].MIMEname;
        if ( !use_cte || LYHaveCJKCharacterSet || !strncasecomp(disp_charset, "x-", 2) )
          disp_charset = 0;
        v9 = disp_charset || HTisDocumentSource();
        use_type = v9;
        v10 = use_cte || use_type;
        use_mime = v10;
        if ( v10 )
        {
          fwrite("Mime-Version: 1.0\n", 1u, 0x12u, outfile_fp);
          if ( use_cte )
            fwrite("Content-Transfer-Encoding: 8bit\n", 1u, 0x20u, outfile_fp);
        }
        if ( HTisDocumentSource() )
        {
          fwrite("Content-Type: text/html", 1u, 0x17u, outfile_fp);
          if ( disp_charset )
            fprintf(outfile_fp, "; charset=%s\n", disp_charset);
          else
            fputc(10, outfile_fp);
        }
        else if ( disp_charset )
        {
          fprintf(outfile_fp, "Content-Type: text/plain; charset=%s\n", disp_charset);
        }
        if ( use_mime )
        {
          if ( content_base )
            fprintf(outfile_fp, "Content-Base: %s\n", content_base);
          if ( content_location )
            fprintf(outfile_fp, "Content-Location: %s\n", content_location);
        }
        fprintf(outfile_fp, "To: %s\nSubject: %s\n", user_response, subject);
        fprintf(outfile_fp, "X-URL: %s\n\n", newdoc->address);
        if ( LYPrependBaseToSource && HTisDocumentSource() )
          fprintf(outfile_fp, "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n", newdoc->address, content_base);
        print_wwwfile_to_fd(outfile_fp, 1, 0);
        if ( keypad_mode )
          printlist(outfile_fp, 0);
        pclose(outfile_fp);
      }
      else
      {
        v7 = gettext("ERROR - Unable to mail file");
        HTAlert(v7);
      }
    }
    else
    {
      v6 = gettext("Mail request cancelled!!!");
      HTInfoMsg(v6);
    }
    goto done;
  }
  v4 = gettext("Mail request cancelled!!!");
  HTInfoMsg(v4);
done:
  if ( buffer )
  {
    free(buffer);
    buffer = 0;
  }
  if ( subject )
    free(subject);
}

//----- (080B065C) --------------------------------------------------------
void __cdecl send_file_to_printer(DocInfo *newdoc, char *content_base, char *sug_filename, int printer_number)
{
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  FILE *v12; // eax
  char *v13; // eax
  const char *Title; // eax
  const char *Date; // eax
  const char *LastModified; // eax
  int v17; // [esp+24h] [ebp-234h]
  int count; // [esp+34h] [ebp-224h]
  lynx_list_item_type *cur_printer; // [esp+38h] [ebp-220h]
  int FnameNum; // [esp+3Ch] [ebp-21Ch] BYREF
  int FnameTotal; // [esp+40h] [ebp-218h] BYREF
  char *the_command; // [esp+44h] [ebp-214h] BYREF
  FILE *outfile_fp; // [esp+48h] [ebp-210h]
  BOOLEAN FirstRecall; // [esp+4Fh] [ebp-209h] BYREF
  char my_temp[256]; // [esp+50h] [ebp-208h] BYREF
  char my_file[256]; // [esp+150h] [ebp-108h] BYREF
  unsigned int v27; // [esp+250h] [ebp-8h]

  v27 = __readgsdword(0x14u);
  FirstRecall = 1;
  the_command = 0;
  FnameNum = -1;
  if ( HTisDocumentSource() )
    v4 = LYOpenTemp(my_temp, ".html", "w");
  else
    v4 = LYOpenTemp(my_temp, ".txt", "w");
  outfile_fp = v4;
  if ( v4 )
  {
    if ( LYPrependBaseToSource && HTisDocumentSource() )
      fprintf(outfile_fp, "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n", newdoc->address, content_base);
    print_wwwfile_to_fd(outfile_fp, 0, 0);
    if ( keypad_mode )
      printlist(outfile_fp, 0);
    LYCloseTempFP(outfile_fp);
    count = 0;
    cur_printer = printers;
    while ( count < printer_number )
    {
      ++count;
      cur_printer = cur_printer->next;
    }
    if ( cur_printer->command )
    {
      if ( HTCountCommandArgs(cur_printer->command) <= 1 )
      {
LABEL_29:
        HTAddParam(&the_command, cur_printer->command, 1, my_temp);
        HTAddParam(&the_command, cur_printer->command, 2, my_file);
        HTEndParam(&the_command, cur_printer->command, 2);
        LYmove(1, 1);
        stop_curses();
        if ( WWW_TraceFlag[0] )
        {
          v11 = the_command;
          v12 = TraceFP();
          fprintf(v12, "command: %s\n", v11);
        }
        v13 = gettext("Printing file.  Please wait...");
        printf(v13);
        Title = HText_getTitle();
        set_environ(0, Title, &::sug_filename);
        set_environ(1, newdoc->address, &::sug_filename);
        Date = HText_getDate();
        set_environ(2, Date, &::sug_filename);
        LastModified = HText_getLastModified();
        set_environ(3, LastModified, &::sug_filename);
        LYSystem(the_command);
        if ( the_command )
        {
          free(the_command);
          the_command = 0;
        }
        LYRemoveTemp(my_temp);
        set_environ(0, &::sug_filename, &::sug_filename);
        set_environ(1, &::sug_filename, &::sug_filename);
        set_environ(2, &::sug_filename, &::sug_filename);
        set_environ(3, &::sug_filename, &::sug_filename);
        fflush(stdout);
        signal(2, cleanup_sig);
        LYSleepMsg();
        start_curses();
      }
      else
      {
        mustshow[0] = 1;
        v7 = gettext("Enter a filename: ");
        statusline(v7);
        while ( 1 )
        {
          SetupFilename(my_file, sug_filename);
          do
            v17 = RecallFilename(my_file, &FirstRecall, &FnameNum, &FnameTotal, 0);
          while ( v17 == 1 );
          if ( v17 == 3 )
            break;
          if ( v17 )
          {
            if ( !no_dotfiles && show_dotfiles || *LYPathLeaf(my_file) != 46 )
            {
              if ( !strcmp(my_file, "/dev/null") )
              {
                v10 = gettext("Print request cancelled!!!");
                HTInfoMsg(v10);
                return;
              }
              HTAddSugFilename(my_file);
              goto LABEL_29;
            }
            v8 = gettext("File name may not begin with a dot.");
            HTAlert(v8);
            mustshow[0] = 1;
            v9 = gettext("Enter a new filename: ");
            statusline(v9);
            FirstRecall = 1;
            FnameNum = FnameTotal;
          }
        }
      }
    }
    else
    {
      v6 = gettext("ERROR! - printer is misconfigured!");
      HTAlert(v6);
    }
  }
  else
  {
    v5 = gettext("ERROR - Unable to allocate file space!!!");
    HTAlert(v5);
  }
}

//----- (080B0B91) --------------------------------------------------------
void __cdecl send_file_to_screen(DocInfo *newdoc, char *content_base, BOOLEAN Lpansi)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  FILE *outfile_fp; // [esp+30h] [ebp-58h]
  char prompt[80]; // [esp+34h] [ebp-54h] BYREF
  unsigned int v8; // [esp+84h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  mustshow[0] = 1;
  if ( Lpansi )
    v3 = gettext("Be sure your printer is on-line.  Press <return> to start printing:");
  else
    v3 = gettext("Press <return> to begin: ");
  statusline(v3);
  prompt[0] = 0;
  if ( LYgetstr(prompt, 0, 0x50u, NORECALL) >= 0 )
  {
    outfile_fp = stdout;
    stop_curses();
    signal(2, (__sighandler_t)1);
    if ( LYPrependBaseToSource && HTisDocumentSource() )
      fprintf(outfile_fp, "<!-- X-URL: %s -->\n<BASE HREF=\"%s\">\n\n", newdoc->address, content_base);
    if ( Lpansi )
      printf("\x1B[5i");
    print_wwwfile_to_fd(outfile_fp, 0, 0);
    if ( keypad_mode )
      printlist(outfile_fp, 0);
    if ( Lpansi )
    {
      printf(asc_815F777);
      printf("\x1B[4i");
      fflush(stdout);
    }
    else
    {
      v5 = gettext("Press <return> to finish: ");
      fprintf(stdout, "\n\n%s", v5);
      fflush(stdout);
      LYgetch();
    }
    start_curses();
  }
  else
  {
    v4 = gettext("Print request cancelled!!!");
    HTInfoMsg(v4);
  }
}

//----- (080B0D5C) --------------------------------------------------------
int __cdecl printfile(DocInfo *newdoc)
{
  const char *ContentBase; // eax
  const char *ContentLocation; // eax
  int v3; // ebx
  char *v4; // eax
  char *v5; // eax
  DocAddress WWWDoc; // [esp+28h] [ebp-40h] BYREF
  int type; // [esp+3Ch] [ebp-2Ch]
  int printer_number; // [esp+40h] [ebp-28h]
  int pagelen; // [esp+44h] [ebp-24h]
  int lines_in_file; // [esp+48h] [ebp-20h]
  char *sug_filename; // [esp+4Ch] [ebp-1Ch]
  char *link_info; // [esp+50h] [ebp-18h] BYREF
  char *cp; // [esp+54h] [ebp-14h]
  char *content_location; // [esp+58h] [ebp-10h] BYREF
  char *content_base; // [esp+5Ch] [ebp-Ch] BYREF
  BOOLEAN Lpansi; // [esp+63h] [ebp-5h]

  Lpansi = 0;
  content_base = 0;
  content_location = 0;
  cp = 0;
  link_info = 0;
  sug_filename = 0;
  lines_in_file = 0;
  pagelen = 0;
  printer_number = 0;
  type = 0;
  HTSACopy(&link_info, (const char *)newdoc->address + 12);
  LYpop(newdoc);
  WWWDoc = *(DocAddress *)&newdoc->address;
  if ( !HTLoadAbsolute(&WWWDoc) )
    return 0;
  if ( HText_getContentBase() )
  {
    ContentBase = HText_getContentBase();
    HTSACopy(&content_base, ContentBase);
    LYRemoveBlanks(content_base);
    if ( !content_base || !*content_base )
    {
      if ( content_base )
      {
        free(content_base);
        content_base = 0;
      }
    }
  }
  if ( HTisDocumentSource() )
  {
    if ( HText_getContentLocation() )
    {
      ContentLocation = HText_getContentLocation();
      HTSACopy(&content_location, ContentLocation);
      LYRemoveBlanks(content_location);
      if ( !content_location || !*content_location )
      {
        if ( content_location )
        {
          free(content_location);
          content_location = 0;
        }
      }
    }
    if ( !content_base )
    {
      if ( content_location && is_url(content_location) )
        HTSACopy(&content_base, content_location);
      else
        HTSACopy(&content_base, newdoc->address);
    }
    if ( !content_location )
      HTSACopy(&content_location, newdoc->address);
  }
  sug_filename = suggested_filename(newdoc);
  cp = strstr(link_info, "lines=");
  if ( cp )
  {
    *cp = 0;
    cp += 6;
    lines_in_file = atoi(cp);
  }
  if ( strstr(link_info, "LOCAL_FILE") )
  {
    type = 1;
  }
  else if ( strstr(link_info, "TO_SCREEN") )
  {
    type = 2;
  }
  else if ( strstr(link_info, "LPANSI") )
  {
    Lpansi = 1;
    type = 2;
  }
  else if ( strstr(link_info, "MAIL_FILE") )
  {
    type = 4;
  }
  else if ( strstr(link_info, "PRINTER") )
  {
    type = 5;
    cp = strstr(link_info, "number=");
    if ( cp )
    {
      cp += 7;
      printer_number = atoi(cp);
    }
    cp = strstr(link_info, "pagelen=");
    if ( cp )
    {
      cp += 8;
      pagelen = atoi(cp);
    }
    else
    {
      pagelen = 66;
    }
  }
  if ( type == 2 )
  {
    v3 = LYlines;
    v4 = gettext("File is %d screens long.  Are you sure you want to print?");
    if ( confirm_by_pages(v4, lines_in_file, v3) )
      send_file_to_screen(newdoc, content_base, Lpansi);
  }
  else if ( type > 2 )
  {
    if ( type == 4 )
    {
      send_file_to_mail(newdoc, content_base, content_location);
    }
    else if ( type == 5 )
    {
      v5 = gettext("File is %d pages long.  Are you sure you want to print?");
      if ( confirm_by_pages(v5, lines_in_file, pagelen) )
        send_file_to_printer(newdoc, content_base, sug_filename, printer_number);
    }
  }
  else if ( type == 1 )
  {
    send_file_to_file(newdoc, content_base, sug_filename);
  }
  if ( link_info )
  {
    free(link_info);
    link_info = 0;
  }
  if ( sug_filename )
  {
    free(sug_filename);
    sug_filename = 0;
  }
  if ( content_base )
  {
    free(content_base);
    content_base = 0;
  }
  if ( content_location )
  {
    free(content_location);
    content_location = 0;
  }
  return 1;
}

//----- (080B11F4) --------------------------------------------------------
char *__cdecl subject_translate8bit(char *source)
{
  int i; // [esp+18h] [ebp-10h]
  char *target; // [esp+24h] [ebp-4h] BYREF

  target = 0;
  i = outgoing_mail_charset;
  HTSACopy(&target, source);
  if ( i < 0 || i == current_char_set || LYCharSet_UC[current_char_set].enc == 5 || LYCharSet_UC[i].enc == 5 )
    return target;
  LYUCTranslateBackFormData(&target, current_char_set, i, 1);
  return target;
}

//----- (080B1291) --------------------------------------------------------
int __cdecl print_options(char **newfile, const char *printed_url, int lines_in_file)
{
  char *v3; // ebx
  char *v4; // esi
  char *v5; // eax
  char *v7; // [esp+4h] [ebp-64h]
  char *v8; // [esp+8h] [ebp-60h]
  char *v9; // [esp+8h] [ebp-60h]
  char *v10; // [esp+8h] [ebp-60h]
  char *v11; // [esp+10h] [ebp-58h]
  char *v12; // [esp+10h] [ebp-58h]
  char *v13; // [esp+10h] [ebp-58h]
  char *v14; // [esp+10h] [ebp-58h]
  char *v16; // [esp+30h] [ebp-38h]
  char *v17; // [esp+34h] [ebp-34h]
  char *v18; // [esp+38h] [ebp-30h]
  char *s; // [esp+3Ch] [ebp-2Ch]
  lynx_list_item_type *cur_printer; // [esp+4Ch] [ebp-1Ch]
  FILE *fp0; // [esp+50h] [ebp-18h]
  int pages; // [esp+54h] [ebp-14h]
  int count; // [esp+58h] [ebp-10h]
  char *buffer; // [esp+5Ch] [ebp-Ch] BYREF

  buffer = 0;
  fp0 = InternalPageFP(my_temp_11758, 1);
  if ( !fp0 )
    return -1;
  LYLocalFileToURL(newfile, my_temp_11758);
  v7 = gettext("Printing Options");
  BeginInternalPage(fp0, v7, "keystrokes/print_help.html.gz");
  fwrite("<pre>\n", 1u, 6u, fp0);
  pages = (lines_in_file + 65) / 66;
  v16 = gettext("(approximately)");
  if ( pages <= 1 )
    v17 = gettext("page");
  else
    v17 = gettext("pages");
  v3 = gettext("Number of pages:");
  v4 = gettext("Number of lines:");
  v5 = gettext("Document:");
  HTSprintf0(
    &buffer,
    "   <em>%s</em> %s\n   <em>%s</em> %d\n   <em>%s</em> %d %s %s\n",
    v5,
    printed_url,
    v4,
    lines_in_file,
    v3,
    pages,
    v17,
    v16);
  fputs(buffer, fp0);
  if ( buffer )
  {
    free(buffer);
    buffer = 0;
  }
  if ( no_print || no_disk_save || no_mail )
  {
    v8 = gettext("Some print functions have been disabled!");
    fprintf(fp0, "   <em>%s</em>\n", v8);
  }
  if ( user_mode )
    v18 = gettext("Print options:");
  else
    v18 = gettext("Standard print options:");
  fprintf(fp0, "\n%s\n", v18);
  if ( no_disk_save || no_print )
  {
    v9 = gettext("Save to disk disabled");
    fprintf(fp0, "   <em>%s</em>\n", v9);
  }
  else
  {
    v11 = gettext("Save to a local file");
    fprintf(fp0, "   <a href=\"%s//LOCAL_FILE/lines=%d\">%s</a>\n", "LYNXPRINT:", lines_in_file, v11);
  }
  if ( !no_mail && !local_host_only )
  {
    v12 = gettext("Mail the file");
    fprintf(fp0, "   <a href=\"%s//MAIL_FILE/lines=%d\">%s</a>\n", "LYNXPRINT:", lines_in_file, v12);
  }
  v13 = gettext("Print to the screen");
  fprintf(fp0, "   <a href=\"%s//TO_SCREEN/lines=%d\">%s</a>\n", "LYNXPRINT:", lines_in_file, v13);
  v14 = gettext("Print out on a printer attached to your vt100 terminal");
  fprintf(fp0, "   <a href=\"%s//LPANSI/lines=%d\">%s</a>\n", "LYNXPRINT:", lines_in_file, v14);
  if ( !user_mode )
  {
    v10 = gettext("Local additions:");
    fprintf(fp0, "\n%s\n", v10);
  }
  count = 0;
  cur_printer = printers;
  while ( cur_printer )
  {
    if ( !no_print || cur_printer->always_enabled )
    {
      fprintf(
        fp0,
        "   <a href=\"%s//PRINTER/number=%d/pagelen=%d/lines=%d\">",
        "LYNXPRINT:",
        count,
        cur_printer->pagelen,
        lines_in_file);
      if ( cur_printer->name )
        s = cur_printer->name;
      else
        s = "No Name Given";
      fputs(s, fp0);
      fwrite("</a>\n", 1u, 5u, fp0);
    }
    cur_printer = cur_printer->next;
    ++count;
  }
  fwrite("</pre>\n", 1u, 7u, fp0);
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  LYforce_no_cache = 1;
  return 0;
}

//----- (080B16F5) --------------------------------------------------------
char *GetFileName()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  size_t v5; // eax
  int v7; // [esp+20h] [ebp-288h]
  stat stat_info; // [esp+34h] [ebp-274h] BYREF
  int FnameTotal; // [esp+94h] [ebp-214h] BYREF
  int FnameNum; // [esp+98h] [ebp-210h] BYREF
  char *fn; // [esp+9Ch] [ebp-20Ch]
  BOOLEAN FirstRecall; // [esp+A3h] [ebp-205h] BYREF
  char tbuf[256]; // [esp+A4h] [ebp-204h] BYREF
  char fbuf[256]; // [esp+1A4h] [ebp-104h] BYREF
  unsigned int v16; // [esp+2A4h] [ebp-4h]

  v16 = __readgsdword(0x14u);
  FirstRecall = 1;
  FnameNum = -1;
  mustshow[0] = 1;
  v0 = gettext("Enter a filename: ");
  statusline(v0);
  while ( 1 )
  {
    while ( 1 )
    {
      do
      {
        SetupFilename(fbuf, &sug_filename);
        do
          v7 = RecallFilename(fbuf, &FirstRecall, &FnameNum, &FnameTotal, 1);
        while ( v7 == 1 );
        if ( v7 == 3 )
          return 0;
      }
      while ( !v7 );
      HTAddSugFilename(fbuf);
      if ( !LYValidateFilename(tbuf, fbuf) )
        return 0;
      if ( stat64((int)tbuf, (int)&stat_info) >= 0
        && ((stat_info.st_mode & 0xF000) == 0x8000 || (stat_info.st_mode & 0xF000) == 40960) )
      {
        break;
      }
      v1 = gettext("File does not exist.");
      HTInfoMsg(v1);
      mustshow[0] = 1;
      v2 = gettext("File does not exist - reenter or cancel:");
      statusline(v2);
      FirstRecall = 1;
      FnameNum = FnameTotal;
    }
    if ( LYCanReadFile(tbuf) )
      break;
    v3 = gettext("File is not readable.");
    HTInfoMsg(v3);
    mustshow[0] = 1;
    v4 = gettext("File is not readable - reenter or cancel:");
    statusline(v4);
    FirstRecall = 1;
    FnameNum = FnameTotal;
  }
  v5 = strlen(tbuf);
  fn = (char *)calloc(v5 + 1, 1u);
  if ( !fn )
    outofmem("./LYPrint.c", "GetFileName");
  return strcpy(fn, tbuf);
}

//----- (080B193C) --------------------------------------------------------
BOOLEAN __cdecl getBool(char *src)
{
  return !strncasecomp(src, "on", 2) || !strncasecomp(src, "true", 4);
}

//----- (080B1996) --------------------------------------------------------
const char *__cdecl LYputEnum(Config_Enum *table, int value)
{
  while ( table->name )
  {
    if ( table->value == value )
      return table->name;
    ++table;
  }
  return "?";
}

//----- (080B19CC) --------------------------------------------------------
BOOLEAN __cdecl LYgetEnum(Config_Enum *table, char *name, int *result)
{
  int match; // [esp+1Ch] [ebp-Ch]
  int len; // [esp+20h] [ebp-8h]
  Config_Enum *found; // [esp+24h] [ebp-4h]

  found = 0;
  len = strlen(name);
  match = 0;
  if ( !len )
    return 0;
  while ( table->name )
  {
    if ( !strncasecomp(table->name, name, len) )
    {
      found = table;
      if ( !strcasecomp(table->name, name) )
      {
        match = 1;
        break;
      }
      ++match;
    }
    ++table;
  }
  if ( match != 1 )
    return 0;
  *result = found->value;
  return 1;
}

//----- (080B1A6E) --------------------------------------------------------
int __cdecl get_assume_charset(char *value)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < LYNumCharsets; ++i )
  {
    if ( !strcasecomp(value, LYCharSet_UC[i].MIMEname) )
    {
      UCLYhndl_for_unspec = i;
      return 0;
    }
  }
  return 0;
}

//----- (080B1ABB) --------------------------------------------------------
void __cdecl put_assume_charset(FILE *fp, config_type *tbl)
{
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < LYNumCharsets; ++i )
    fprintf(fp, "#    %s\n", LYCharSet_UC[i].MIMEname);
  fprintf(fp, "%s=%s\n\n", tbl->name, LYCharSet_UC[UCLYhndl_for_unspec].MIMEname);
}

//----- (080B1B2B) --------------------------------------------------------
int __cdecl get_display_charset(char *value)
{
  int i; // [esp+14h] [ebp-4h]

  i = UCGetLYhndl_byAnyName(value);
  if ( i >= 0 )
    current_char_set = i;
  return 0;
}

//----- (080B1B5B) --------------------------------------------------------
void __cdecl put_display_charset(FILE *fp, config_type *tbl)
{
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; LYchar_set_names[i]; ++i )
    fprintf(fp, "#    %s\n", LYchar_set_names[i]);
  fprintf(fp, "%s=%s\n\n", tbl->name, LYchar_set_names[current_char_set]);
}

//----- (080B1BCB) --------------------------------------------------------
int __cdecl get_editor(char *value)
{
  if ( !system_editor )
    HTSACopy(&editor, value);
  return 0;
}

//----- (080B1BF6) --------------------------------------------------------
void __cdecl put_editor(FILE *fp, config_type *tbl)
{
  const char *v2; // [esp+14h] [ebp-4h]

  if ( editor )
    v2 = editor;
  else
    v2 = (const char *)&unk_815FE34;
  fprintf(fp, "%s=%s\n\n", tbl->name, v2);
}

//----- (080B1C3B) --------------------------------------------------------
int __cdecl get_tagsoup(char *value)
{
  int found; // [esp+24h] [ebp-4h] BYREF

  found = Old_DTD;
  if ( LYgetEnum(tbl_DTD_recovery, value, &found) && Old_DTD != found )
  {
    Old_DTD = found;
    HTSwitchDTD(found == 0);
  }
  return 0;
}

//----- (080B1C98) --------------------------------------------------------
void __cdecl put_tagsoup(FILE *fp, config_type *tbl)
{
  const char *v2; // [esp+Ch] [ebp-Ch]

  v2 = LYputEnum(tbl_DTD_recovery, Old_DTD);
  fprintf(fp, "%s=%s\n\n", tbl->name, v2);
}

//----- (080B1CD7) --------------------------------------------------------
Config_Type_1 *__cdecl lookup_config_0(const char *name)
{
  char v2; // [esp+Fh] [ebp-19h]
  int v3; // [esp+14h] [ebp-14h]
  Config_Type_1 *tbl; // [esp+20h] [ebp-8h]
  unsigned __int8 ch1; // [esp+26h] [ebp-2h]

  tbl = Config_Table_0;
  if ( ((*__ctype_b_loc())[*(unsigned __int8 *)name] & 0x200) != 0 )
    v2 = toupper(*(unsigned __int8 *)name);
  else
    v2 = *name;
  while ( tbl->name )
  {
    if ( tbl->enabled )
    {
      ch1 = *tbl->name;
      v3 = ((*__ctype_b_loc())[ch1] & 0x200) != 0 ? toupper(ch1) : ch1;
      if ( v2 == v3 && !strcasecomp(name, tbl->name) )
        break;
    }
    ++tbl;
  }
  return tbl;
}

//----- (080B1DC5) --------------------------------------------------------
int __cdecl f(char *c)
{
  int result; // eax

  return result;
}
// 80B1DC5: variable 'result' is possibly undefined

//----- (080B1DCD) --------------------------------------------------------
int __cdecl read_rc(int val)
{
  ParseUnion *q; // [esp+10h] [ebp-8h]

  q->def_value = (int)f;
  if ( val )
    f(0);
  if ( val )
    ((void (__cdecl *)(_DWORD))q->add_value)(0);
  return val;
}
// 80B1DDD: variable 'q' is possibly undefined

//----- (080B1E0E) --------------------------------------------------------
void __cdecl read_rc(FILE *fp)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  int v5; // eax
  FILE *v6; // eax
  BOOLEAN *def_value; // ebx
  int v8; // eax
  size_t v9; // eax
  FILE *fpa; // [esp+20h] [ebp-238h]
  int ival; // [esp+2Ch] [ebp-22Ch] BYREF
  const char *special; // [esp+30h] [ebp-228h]
  ParseUnion *q; // [esp+34h] [ebp-224h]
  Config_Type_1 *tbl; // [esp+38h] [ebp-220h]
  char *notes; // [esp+3Ch] [ebp-21Ch]
  char *value; // [esp+40h] [ebp-218h]
  char *name; // [esp+44h] [ebp-214h]
  int n; // [esp+48h] [ebp-210h]
  char *buffer; // [esp+4Ch] [ebp-20Ch] BYREF
  char MBM_line[256]; // [esp+50h] [ebp-208h] BYREF
  char rcfile[256]; // [esp+150h] [ebp-108h] BYREF
  unsigned int v22; // [esp+250h] [ebp-8h]

  fpa = fp;
  v22 = __readgsdword(0x14u);
  buffer = 0;
  if ( fp )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "read_rc used passed-in stream\n");
    }
  }
  else
  {
    LYAddPathToHome(rcfile, 0x100u, ".lynxrc");
    fpa = (FILE *)fopen64(rcfile, "r");
    if ( !fpa )
      return;
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "read_rc opened %s\n", rcfile);
    }
  }
LABEL_52:
  while ( LYSafeGets(&buffer, fpa) )
  {
    LYTrimTrailing(buffer);
    name = LYSkipBlanks(buffer);
    if ( ((*__ctype_b_loc())[(unsigned __int8)*name] & 4) == 0 && *name )
    {
      value = strchr(name, 61);
      if ( value )
      {
        *value++ = 0;
        LYTrimTrailing(name);
        value = LYSkipBlanks(value);
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
        {
          v4 = TraceFP();
          fprintf(v4, "LYrcFile %s:%s\n", name, value);
        }
        tbl = lookup_config_0(name);
        if ( tbl->name )
          goto LABEL_62;
        special = "multi_bookmark";
        v5 = strlen("multi_bookmark");
        if ( !strncasecomp(name, special, v5) )
          tbl = lookup_config_0(special);
        if ( tbl->name )
        {
LABEL_62:
          q = (ParseUnion *)&tbl->value;
          switch ( tbl->type )
          {
            case CONF_ARRAY:
              for ( n = 0; tbl->strings[n]; ++n )
              {
                if ( !strcasecomp(value, tbl->strings[n]) )
                {
                  *q->int_value = n;
                  goto LABEL_52;
                }
              }
              break;
            case CONF_BOOL_0:
              if ( q->def_value )
              {
                def_value = (BOOLEAN *)q->def_value;
                *def_value = getBool(value);
              }
              break;
            case CONF_FUN_0:
              if ( q->def_value )
                ((void (__cdecl *)(char *))q->add_value)(value);
              break;
            case CONF_INT_0:
              if ( q->def_value && sscanf(value, "%d", &ival) == 1 )
                *q->int_value = ival;
              break;
            case CONF_ENUM_0:
              if ( tbl->table )
                LYgetEnum(tbl->table, value, q->int_value);
              break;
            case CONF_LIS:
              if ( q->def_value )
              {
                if ( *q->int_value )
                  HTSACat(q->str_value, ",");
                HTSACat(q->str_value, value);
              }
              break;
            case CONF_MBM:
              for ( n = 1; n <= 25; ++n )
              {
                v8 = LYindex2MBM(n);
                sprintf(MBM_line, "multi_bookmark%c", v8);
                if ( !strcasecomp(name, MBM_line) )
                {
                  notes = strchr(value, 44);
                  if ( notes )
                  {
                    *notes++ = 0;
                    LYTrimTrailing(value);
                    notes = LYSkipBlanks(notes);
                  }
                  else
                  {
                    v9 = strlen(value);
                    notes = &value[v9];
                  }
                  HTSACopy(&MBM_A_subbookmark[n], value);
                  HTSACopy(&MBM_A_subdescript[n], notes);
                  goto LABEL_52;
                }
              }
              break;
            case CONF_STR_0:
              if ( q->def_value )
                HTSACopy(q->str_value, value);
              break;
            default:
              goto LABEL_52;
          }
        }
        else if ( WWW_TraceFlag[0] )
        {
          v6 = TraceFP();
          fprintf(v6, "LYrcFile: ignored %s=%s\n", name, value);
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "LYrcFile: missing '=' %s\n", name);
      }
    }
  }
  LYCloseInput(fpa);
  LYConfigCookies();
  if ( LYrcShowColor )
  {
    if ( LYrcShowColor == 3 )
    {
      if ( LYShowColor )
        LYShowColor = 3;
    }
  }
  else if ( LYShowColor == 2 )
  {
    LYShowColor = 1;
  }
  set_default_bookmark_page(bookmark_page);
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080B249D) --------------------------------------------------------
void __cdecl write_list(FILE *fp, const char *list)
{
  int ch_0; // [esp+20h] [ebp-8h]
  int first; // [esp+24h] [ebp-4h]

  first = 1;
  while ( *list )
  {
    ch_0 = *list++;
    if ( first )
    {
      fwrite(&unk_81625F4, 1u, 2u, fp);
      first = 0;
    }
    if ( ch_0 == 10 )
      first = 1;
    fputc(ch_0, fp);
  }
}

//----- (080B2517) --------------------------------------------------------
void __cdecl explain_keypad_mode(FILE *fp)
{
  char *v1; // [esp+4h] [ebp-4h]
  char *v2; // [esp+4h] [ebp-4h]
  char *v3; // [esp+4h] [ebp-4h]
  char *v4; // [esp+4h] [ebp-4h]

  v1 = gettext(
         "If keypad_mode is set to \"NUMBERS_AS_ARROWS\", then the numbers on\n"
         "your keypad when the numlock is on will act as arrow keys:\n"
         "            8 = Up Arrow\n"
         "  4 = Left Arrow    6 = Right Arrow\n"
         "            2 = Down Arrow\n"
         "and the corresponding keyboard numbers will act as arrow keys,\n"
         "regardless of whether numlock is on.\n");
  write_list(fp, v1);
  v2 = gettext(
         "If keypad_mode is set to \"LINKS_ARE_NUMBERED\", then numbers will\n"
         "appear next to each link and numbers are used to select links.\n");
  write_list(fp, v2);
  v3 = gettext(
         "If keypad_mode is set to \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\", then\n"
         "numbers will appear next to each link and visible form input field.\n"
         "Numbers are used to select links, or to move the \"current link\" to a\n"
         "form input field or button.  In addition, options in popup menus are\n"
         "indexed so that the user may type an option number to select an option in\n"
         "a popup menu, even if the option isn't visible on the screen.  Reference\n"
         "lists and output from the list command also enumerate form inputs.\n");
  write_list(fp, v3);
  v4 = gettext(
         "NOTE: Some fixed format documents may look disfigured when\n"
         "\"LINKS_ARE_NUMBERED\" or \"LINKS_AND_FORM_FIELDS_ARE_NUMBERED\" are\n"
         "enabled.\n");
  write_list(fp, v4);
}

//----- (080B258B) --------------------------------------------------------
int __cdecl save_rc(FILE *fp)
{
  char *v2; // [esp+4h] [ebp-144h]
  char *v3; // [esp+4h] [ebp-144h]
  char *v4; // [esp+4h] [ebp-144h]
  char *v5; // [esp+4h] [ebp-144h]
  char *v6; // [esp+4h] [ebp-144h]
  char *v7; // [esp+4h] [ebp-144h]
  char *v8; // [esp+8h] [ebp-140h]
  char *v9; // [esp+8h] [ebp-140h]
  int v10; // [esp+8h] [ebp-140h]
  const char *v11; // [esp+Ch] [ebp-13Ch]
  const char *v13; // [esp+18h] [ebp-130h]
  char *s; // [esp+1Ch] [ebp-12Ch]
  const char *v15; // [esp+20h] [ebp-128h]
  FILE *fpa; // [esp+24h] [ebp-124h]
  ParseUnion *q; // [esp+34h] [ebp-114h]
  int n; // [esp+38h] [ebp-110h]
  int na; // [esp+38h] [ebp-110h]
  Config_Type_1 *tbl; // [esp+3Ch] [ebp-10Ch]
  char rcfile[256]; // [esp+44h] [ebp-104h] BYREF
  unsigned int v22; // [esp+144h] [ebp-4h]

  fpa = fp;
  v22 = __readgsdword(0x14u);
  tbl = Config_Table_0;
  if ( !fp )
  {
    LYAddPathToHome(rcfile, 0x100u, ".lynxrc");
    fpa = LYNewTxtFile(rcfile);
    if ( !fpa )
      return 0;
  }
  v2 = gettext("Lynx User Defaults File\n\n");
  write_list(fpa, v2);
  v3 = gettext(
         "This file contains options saved from the Lynx Options Screen (normally\n"
         "with the 'o' key).  To save options with that screen, you must select the\n"
         "checkbox:\n");
  write_list(fpa, v3);
  v8 = gettext("Save options to disk");
  fprintf(fpa, "#\t%s\n", v8);
  fwrite("#\n", 1u, 2u, fpa);
  v4 = gettext("You must then save the settings using the link on the line above the\ncheckbox:\n");
  write_list(fpa, v4);
  v9 = gettext("Accept Changes");
  fprintf(fpa, "#\t%s\n", v9);
  fwrite("#\n", 1u, 2u, fpa);
  v5 = gettext(
         "You may also use the command-line option \"-forms_options\", which displays\n"
         "the simpler Options Menu instead.  Save options with that using the '>' key.\n"
         "\n");
  write_list(fpa, v5);
  v6 = gettext(
         "There is normally no need to edit this file manually, since the defaults\n"
         "here can be controlled from the Options Screen, and the next time options\n"
         "are saved from the Options Screen this file will be completely rewritten.\n"
         "You have been warned...\n"
         "\n"
         "If you are looking for the general configuration file - it is normally\n"
         "called \"lynx.cfg\".  It has different content and a different format.\n"
         "It is not this file.\n");
  write_list(fpa, v6);
  fputc(10, fpa);
  while ( tbl->name )
  {
    q = (ParseUnion *)&tbl->value;
    if ( tbl->enabled )
    {
      if ( tbl->note )
      {
        v7 = gettext(tbl->note);
        write_list(fpa, v7);
      }
      else if ( tbl->table == tbl_keypad_mode )
      {
        explain_keypad_mode(fpa);
      }
      switch ( tbl->type )
      {
        case CONF_ARRAY:
          for ( n = 0; tbl->strings[n]; ++n )
            fprintf(fpa, "#    %s\n", tbl->strings[n]);
          fprintf(fpa, "%s=%s\n\n", tbl->name, tbl->strings[*q->int_value]);
          break;
        case CONF_BOOL_0:
          if ( *q->set_value )
            v13 = "on";
          else
            v13 = "off";
          fprintf(fpa, "%s=%s\n\n", tbl->name, v13);
          break;
        case CONF_FUN_0:
          if ( tbl->write_it )
            tbl->write_it(fpa, tbl);
          break;
        case CONF_INT_0:
          fprintf(fpa, "%s=%d\n\n", tbl->name, *q->int_value);
          break;
        case CONF_ENUM_0:
          v11 = LYputEnum(tbl->table, *q->int_value);
          fprintf(fpa, "%s=%s\n\n", tbl->name, v11);
          break;
        case CONF_LIS:
        case CONF_STR_0:
          if ( q->def_value && *q->int_value )
            v15 = (const char *)*q->int_value;
          else
            v15 = (const char *)&unk_815FE34;
          fprintf(fpa, "%s=%s\n\n", tbl->name, v15);
          break;
        case CONF_MBM:
          for ( na = 1; na <= 25; ++na )
          {
            v10 = LYindex2MBM(na);
            fprintf(fpa, "multi_bookmark%c=", v10);
            if ( MBM_A_subbookmark[na] )
              s = MBM_A_subbookmark[na];
            else
              s = (char *)&unk_815FE34;
            fputs(s, fpa);
            if ( MBM_A_subdescript[na] && *MBM_A_subdescript[na] )
              fprintf(fpa, ",%s", MBM_A_subdescript[na]);
            fputc(10, fpa);
          }
          fputc(10, fpa);
          break;
        default:
          break;
      }
      ++tbl;
    }
    else
    {
      ++tbl;
    }
  }
  if ( fp )
    LYCloseTempFP(fpa);
  else
    LYCloseOutput(fpa);
  return 1;
}

//----- (080B2B81) --------------------------------------------------------
BOOLEAN __cdecl will_save_rc(const char *name)
{
  return lookup_config_0(name)->name != 0;
}

//----- (080B2BA1) --------------------------------------------------------
int __cdecl enable_lynxrc(char *value)
{
  char *colon; // [esp+10h] [ebp-8h]
  char *colona; // [esp+10h] [ebp-8h]
  Config_Type_1 *tbl; // [esp+14h] [ebp-4h]

  colon = strchr(value, 58);
  if ( colon )
  {
    *colon = 0;
    colona = colon + 1;
    LYTrimLeading(value);
    LYTrimTrailing(value);
    for ( tbl = Config_Table_0; tbl->name; ++tbl )
    {
      if ( !strcasecomp(value, tbl->name) )
      {
        tbl->enabled = getBool(colona);
        return 0;
      }
    }
  }
  return 0;
}

//----- (080B2C30) --------------------------------------------------------
void __cdecl LYDownload(char *line)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  FILE *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // ebx
  FILE *v18; // eax
  char *v19; // eax
  char *v20; // eax
  int v21; // [esp+18h] [ebp-250h]
  int v22; // [esp+1Ch] [ebp-24Ch]
  int FnameNum; // [esp+28h] [ebp-240h]
  _BOOL4 recall; // [esp+30h] [ebp-238h]
  int ch_0; // [esp+34h] [ebp-234h]
  int ch_0a; // [esp+34h] [ebp-234h]
  lynx_list_item_type *download_command; // [esp+38h] [ebp-230h]
  char *cp; // [esp+3Ch] [ebp-22Ch]
  char *cpa; // [esp+3Ch] [ebp-22Ch]
  char *cpb; // [esp+3Ch] [ebp-22Ch]
  char *cpc; // [esp+3Ch] [ebp-22Ch]
  char *the_command; // [esp+40h] [ebp-228h] BYREF
  int count; // [esp+44h] [ebp-224h]
  int method_number; // [esp+48h] [ebp-220h]
  char *sug_file; // [esp+4Ch] [ebp-21Ch]
  char *file; // [esp+50h] [ebp-218h]
  char *method; // [esp+54h] [ebp-214h]
  char *Line; // [esp+58h] [ebp-210h] BYREF
  BOOLEAN SecondS; // [esp+5Eh] [ebp-20Ah]
  BOOLEAN FirstRecall; // [esp+5Fh] [ebp-209h]
  char command[256]; // [esp+60h] [ebp-208h] BYREF
  char buffer[256]; // [esp+160h] [ebp-108h] BYREF
  unsigned int v43; // [esp+260h] [ebp-8h]

  v43 = __readgsdword(0x14u);
  Line = 0;
  sug_file = 0;
  the_command = 0;
  FirstRecall = 1;
  SecondS = 0;
  if ( !LYValidDownloadFile[0] )
    goto failed;
  HTSACopy(&Line, line);
  file = strstr(Line, "/File=");
  if ( !file )
    goto failed;
  *file = 0;
  file += 6;
  sug_file = strstr(file + 1, "/SugFile=");
  if ( sug_file )
  {
    *sug_file = 0;
    sug_file += 9;
    HTUnEscape(sug_file);
  }
  if ( strcmp(file, LYValidDownloadFile) )
    goto failed;
  if ( !strncmp(file, "file://localhost", 0x10u) )
  {
    file += 16;
  }
  else if ( (*file == 102 || *file == 70) && !strncasecomp(file, "file:", 5) )
  {
    file += 5;
  }
  HTUnEscape(file);
  method = strstr(Line, "Method=");
  if ( !method )
    goto failed;
  method += 7;
  method_number = atoi(method);
  if ( sug_filenames )
    v21 = HTList_count(sug_filenames);
  else
    v21 = 0;
  recall = v21 > 0;
  FnameNum = v21;
  if ( method_number >= 0 )
  {
    buffer[0] = 0;
    count = 0;
    download_command = downloaders;
    while ( count < method_number )
    {
      ++count;
      download_command = download_command->next;
    }
    if ( download_command->command )
    {
      if ( HTCountCommandArgs(download_command->command) <= 1 )
      {
LABEL_97:
        count = 1;
        HTAddParam(&the_command, download_command->command, 1, file);
        if ( HTCountCommandArgs(download_command->command) > 1 )
          HTAddParam(&the_command, download_command->command, ++count, buffer);
        HTEndParam(&the_command, download_command->command, count);
        if ( WWW_TraceFlag[0] )
        {
          v17 = the_command;
          v18 = TraceFP();
          fprintf(v18, "command: %s\n", v17);
        }
        stop_curses();
        LYSystem(the_command);
        if ( the_command )
        {
          free(the_command);
          the_command = 0;
        }
        start_curses();
        goto LABEL_105;
      }
      mustshow[0] = 1;
      v10 = gettext("Enter a filename: ");
      statusline(v10);
again:
      if ( sug_file )
        strncpy(buffer, sug_file, 0x7Fu);
      else
        buffer[0] = 0;
      while ( 1 )
      {
        ch_0a = LYgetstr(buffer, 0, 0x100u, (RecallType)recall);
        if ( ch_0a >= 0 && buffer[0] && ch_0a != 256 && ch_0a != 257 )
        {
          if ( (no_dotfiles || !show_dotfiles) && *LYPathLeaf(buffer) == 46 )
          {
            v14 = gettext("File name may not begin with a dot.");
            HTAlert(v14);
            mustshow[0] = 1;
            v15 = gettext("Enter a new filename: ");
            statusline(v15);
            goto again;
          }
          if ( strcmp(buffer, "/dev/null") )
          {
            SecondS = 1;
            goto LABEL_97;
          }
cancelled:
          v20 = gettext("Cancelling!");
          HTInfoMsg(v20);
          if ( !Line )
            return;
LABEL_112:
          free(Line);
          return;
        }
        if ( v21 > 0 && ch_0a == 256 )
        {
          if ( FirstRecall )
          {
            FirstRecall = 0;
            FnameNum = 0;
          }
          else
          {
            ++FnameNum;
          }
          if ( FnameNum >= v21 )
            goto LABEL_77;
          cpb = (char *)HTList_objectAt(sug_filenames, FnameNum);
          if ( !cpb )
            goto cancelled;
          LYstrncpy(buffer, cpb, 255);
          if ( v21 == 1 )
            goto LABEL_80;
LABEL_81:
          mustshow[0] = 1;
          v13 = gettext("Edit a previous filename: ");
          statusline(v13);
        }
        else
        {
          if ( v21 <= 0 || ch_0a != 257 )
            goto cancelled;
          if ( FirstRecall )
          {
            FirstRecall = 0;
            FnameNum = v21 - 1;
          }
          else
          {
            --FnameNum;
          }
          if ( FnameNum < 0 )
          {
LABEL_77:
            FirstRecall = 1;
            FnameNum = v21;
            mustshow[0] = 1;
            v11 = gettext("Enter a filename: ");
            statusline(v11);
            goto again;
          }
          cpc = (char *)HTList_objectAt(sug_filenames, FnameNum);
          if ( !cpc )
            goto cancelled;
          LYstrncpy(buffer, cpc, 255);
          if ( v21 != 1 )
            goto LABEL_81;
LABEL_80:
          mustshow[0] = 1;
          v12 = gettext("Edit the previous filename: ");
          statusline(v12);
        }
      }
    }
    v16 = gettext("ERROR! - download command is misconfigured.");
    HTAlert(v16);
failed:
    v19 = gettext("Unable to download file.");
    HTAlert(v19);
    if ( !Line )
      return;
    goto LABEL_112;
  }
  mustshow[0] = 1;
  v1 = gettext("Enter a filename: ");
  statusline(v1);
retry:
  while ( 2 )
  {
    while ( 2 )
    {
      while ( 2 )
      {
        if ( sug_file )
          LYstrncpy(buffer, sug_file, 127);
        else
          buffer[0] = 0;
        while ( 1 )
        {
          ch_0 = LYgetstr(buffer, 0, 0x80u, (RecallType)recall);
          if ( ch_0 >= 0 && buffer[0] && ch_0 != 256 && ch_0 != 257 )
            break;
          if ( v21 > 0 && ch_0 == 256 )
          {
            if ( FirstRecall )
            {
              FirstRecall = 0;
              FnameNum = 0;
            }
            else
            {
              ++FnameNum;
            }
            if ( FnameNum >= v21 )
              goto LABEL_31;
            cp = (char *)HTList_objectAt(sug_filenames, FnameNum);
            if ( !cp )
              goto cancelled;
            LYstrncpy(buffer, cp, 255);
            if ( v21 == 1 )
              goto LABEL_34;
LABEL_35:
            mustshow[0] = 1;
            v4 = gettext("Edit a previous filename: ");
            statusline(v4);
          }
          else
          {
            if ( v21 <= 0 || ch_0 != 257 )
              goto cancelled;
            if ( FirstRecall )
            {
              FirstRecall = 0;
              FnameNum = v21 - 1;
            }
            else
            {
              --FnameNum;
            }
            if ( FnameNum < 0 )
            {
LABEL_31:
              FirstRecall = 1;
              FnameNum = v21;
              mustshow[0] = 1;
              v2 = gettext("Enter a filename: ");
              statusline(v2);
              goto retry;
            }
            cpa = (char *)HTList_objectAt(sug_filenames, FnameNum);
            if ( !cpa )
              goto cancelled;
            LYstrncpy(buffer, cpa, 255);
            if ( v21 != 1 )
              goto LABEL_35;
LABEL_34:
            mustshow[0] = 1;
            v3 = gettext("Edit the previous filename: ");
            statusline(v3);
          }
        }
        strcpy(command, buffer);
        if ( !LYValidateFilename(buffer, command) )
          goto cancelled;
        if ( buffer[0] == 124 )
        {
          v5 = gettext("Cannot write to file.");
          HTAlert(v5);
          mustshow[0] = 1;
          v6 = gettext("Enter a new filename: ");
          statusline(v6);
          FirstRecall = 1;
          FnameNum = v21;
          continue;
        }
        break;
      }
      v22 = LYValidateOutput(buffer);
      if ( v22 == 78 )
      {
        mustshow[0] = 1;
        v7 = gettext("Enter a new filename: ");
        statusline(v7);
        FirstRecall = 1;
        FnameNum = v21;
        continue;
      }
      break;
    }
    if ( v22 != 89 )
    {
      if ( !Line )
        return;
      goto LABEL_112;
    }
    if ( WWW_TraceFlag[0] )
    {
      v8 = TraceFP();
      fprintf(v8, "LYDownload: filename is %s\n", buffer);
    }
    if ( !LYCanWriteFile(buffer) )
    {
      FirstRecall = 1;
      FnameNum = v21;
      continue;
    }
    break;
  }
  SecondS = 1;
  v9 = gettext("Saving...");
  HTInfoMsg(v9);
  LYCopyFile(file, buffer);
  LYRelaxFilePermissions(buffer);
LABEL_105:
  if ( SecondS == 1 )
    HTAddSugFilename(buffer);
  if ( Line )
  {
    free(Line);
    Line = 0;
  }
}

//----- (080B38A2) --------------------------------------------------------
int __cdecl SuffixIs(char *filename, const char *suffix)
{
  size_t need; // [esp+20h] [ebp-8h]
  size_t have; // [esp+24h] [ebp-4h]

  have = strlen(filename);
  need = strlen(suffix);
  return have > need && !strcmp(&filename[have - need], suffix);
}

//----- (080B3901) --------------------------------------------------------
int __cdecl LYdownload_options(char **newfile, char *data_file)
{
  char *v2; // eax
  char *v3; // ebx
  char *v4; // eax
  char *v5; // ebx
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v12; // [esp+20h] [ebp-38h]
  char *v13; // [esp+24h] [ebp-34h]
  const char *s; // [esp+30h] [ebp-28h]
  char *source; // [esp+38h] [ebp-20h]
  char *target; // [esp+3Ch] [ebp-1Ch] BYREF
  int count; // [esp+40h] [ebp-18h]
  lynx_list_item_type *cur_download; // [esp+44h] [ebp-14h]
  FILE *fp0; // [esp+48h] [ebp-10h]
  char *sug_filename; // [esp+4Ch] [ebp-Ch] BYREF
  char *downloaded_url; // [esp+50h] [ebp-8h] BYREF

  downloaded_url = 0;
  sug_filename = 0;
  HTSACopy(&sug_filename, *newfile);
  change_sug_filename(sug_filename);
  fp0 = InternalPageFP(tempfile_9853, 1);
  if ( !fp0 )
    return -1;
  HTSACopy(&downloaded_url, *newfile);
  LYLocalFileToURL(newfile, tempfile_9853);
  LYstrncpy(LYValidDownloadFile, data_file, 255);
  LYforce_no_cache = 1;
  v2 = gettext("Download Options");
  BeginInternalPage(fp0, v2, "Lynx_users_guide.html.gz#RemoteSource");
  fwrite("<pre>\n", 1u, 6u, fp0);
  v3 = downloaded_url;
  v4 = gettext("Downloaded link:");
  fprintf(fp0, "<em>%s</em> %s\n", v4, v3);
  if ( downloaded_url )
  {
    free(downloaded_url);
    downloaded_url = 0;
  }
  v5 = sug_filename;
  v6 = gettext("Suggested file name:");
  fprintf(fp0, "<em>%s</em> %s\n", v6, v5);
  if ( user_mode )
    v12 = gettext("Download options:");
  else
    v12 = gettext("Standard download options:");
  fprintf(fp0, "\n%s\n", v12);
  if ( no_disk_save )
  {
    v8 = gettext("Save to disk disabled.");
    fprintf(fp0, "   <em>%s</em>\n", v8);
  }
  else if ( !lynx_edit_mode )
  {
    v13 = gettext("Save to disk");
    if ( lynx_save_space )
      fprintf(
        fp0,
        "   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
        "LYNXDOWNLOAD:",
        data_file,
        lynx_save_space,
        sug_filename,
        v13);
    else
      fprintf(
        fp0,
        "   <a href=\"%s//Method=-1/File=%s/SugFile=%s%s\">%s</a>\n",
        "LYNXDOWNLOAD:",
        data_file,
        (const char *)&unk_8162FEA,
        sug_filename,
        v13);
    if ( SuffixIs(data_file, ".html") || SuffixIs(data_file, ".txt") )
    {
      target = 0;
      source = LYAddPathToSave(data_file);
      LYLocalFileToURL(&target, source);
      v7 = gettext("View temporary file");
      fprintf(fp0, "   <a href=\"%s\">%s</a>\n", target, v7);
      if ( source )
        free(source);
      if ( target )
      {
        free(target);
        target = 0;
      }
    }
  }
  if ( !user_mode )
  {
    v9 = gettext("Local additions:");
    fprintf(fp0, "\n%s\n", v9);
  }
  if ( downloaders )
  {
    count = 0;
    cur_download = downloaders;
    while ( cur_download )
    {
      if ( !no_download || cur_download->always_enabled )
      {
        fprintf(
          fp0,
          "   <a href=\"%s//Method=%d/File=%s/SugFile=%s\">",
          "LYNXDOWNLOAD:",
          count,
          data_file,
          sug_filename);
        if ( cur_download->name )
          s = cur_download->name;
        else
          s = gettext("No Name Given");
        fputs(s, fp0);
        fwrite("</a>\n", 1u, 5u, fp0);
      }
      cur_download = cur_download->next;
      ++count;
    }
  }
  fwrite("</pre>\n", 1u, 7u, fp0);
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  LYRegisterUIPage(*newfile, UIP_DOWNLOAD_OPTIONS_0);
  if ( sug_filename )
  {
    free(sug_filename);
    sug_filename = 0;
  }
  return 0;
}

//----- (080B3D78) --------------------------------------------------------
BOOLEAN __cdecl message_has_content(const char *filename, BOOLEAN *nonspaces)
{
  FILE *v2; // eax
  const char *v4; // [esp+10h] [ebp-18h]
  char *cp; // [esp+18h] [ebp-10h]
  char *buffer; // [esp+1Ch] [ebp-Ch] BYREF
  FILE *fp; // [esp+20h] [ebp-8h]
  char firstnonblank; // [esp+26h] [ebp-2h]
  BOOLEAN in_headers; // [esp+27h] [ebp-1h]

  buffer = 0;
  in_headers = 1;
  *nonspaces = 0;
  if ( filename && (fp = (FILE *)fopen64(filename, "r")) != 0 )
  {
    while ( 1 )
    {
      if ( !LYSafeGets(&buffer, fp) )
      {
        if ( buffer )
        {
          free(buffer);
          buffer = 0;
        }
        LYCloseInput(fp);
        return 0;
      }
      cp = buffer;
      firstnonblank = 0;
      LYTrimNewline(buffer);
      while ( *cp )
      {
        if ( firstnonblank || ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x8000u) == 0 )
        {
          if ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x2000) == 0 )
            *nonspaces = 1;
        }
        else
        {
          firstnonblank = *cp;
        }
        ++cp;
      }
      if ( firstnonblank && firstnonblank != 62 && !in_headers )
        break;
      if ( !firstnonblank )
        in_headers = 0;
    }
    LYCloseInput(fp);
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
    return 1;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( filename )
        v4 = filename;
      else
        v4 = "(null)";
      v2 = TraceFP();
      fprintf(v2, "Failed to open file %s for reading!\n", v4);
    }
    return 0;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080B3F07) --------------------------------------------------------
char *__cdecl LYNewsPost(char *newsgroups, BOOLEAN followup)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  size_t v5; // ebx
  char *v6; // eax
  size_t v7; // eax
  char *v8; // eax
  size_t v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  size_t v13; // ebx
  char *v14; // eax
  size_t v15; // eax
  char *v16; // eax
  size_t v17; // ebx
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  size_t v23; // ebx
  char *v24; // eax
  char *v25; // eax
  size_t v26; // ebx
  char *v27; // eax
  char *v28; // eax
  size_t v29; // ebx
  char *v30; // eax
  char *v31; // eax
  char *v32; // eax
  char *v33; // eax
  char *v34; // eax
  char *v35; // ebx
  char *v36; // eax
  const char *v37; // ebx
  char *v38; // eax
  char *v39; // eax
  char *buffer; // [esp+28h] [ebp-A40h] BYREF
  char *msg; // [esp+2Ch] [ebp-A3Ch] BYREF
  FILE *fp; // [esp+30h] [ebp-A38h]
  char *org; // [esp+34h] [ebp-A34h]
  char *References; // [esp+38h] [ebp-A30h] BYREF
  char *NewsGroups; // [esp+3Ch] [ebp-A2Ch] BYREF
  char *postfile; // [esp+40h] [ebp-A28h] BYREF
  FILE *fc; // [esp+44h] [ebp-A24h]
  FILE *fd; // [esp+48h] [ebp-A20h]
  int len; // [esp+4Ch] [ebp-A1Ch]
  int c; // [esp+50h] [ebp-A18h]
  const char *kp; // [esp+54h] [ebp-A14h]
  char *cp; // [esp+58h] [ebp-A10h] BYREF
  BOOLEAN nonspaces; // [esp+5Eh] [ebp-A0Ah] BYREF
  BOOLEAN nonempty; // [esp+5Fh] [ebp-A09h]
  char CJKinput[1024]; // [esp+60h] [ebp-A08h] BYREF
  char user_input[1024]; // [esp+460h] [ebp-608h] BYREF
  char CJKfile[256]; // [esp+860h] [ebp-208h] BYREF
  char my_tempfile[256]; // [esp+960h] [ebp-108h] BYREF
  unsigned int v61; // [esp+A60h] [ebp-8h]

  v61 = __readgsdword(0x14u);
  cp = 0;
  kp = 0;
  c = 0;
  fd = 0;
  fc = 0;
  postfile = 0;
  NewsGroups = 0;
  References = 0;
  org = 0;
  fp = 0;
  nonempty = 0;
  nonspaces = 0;
  if ( !newsgroups || !*newsgroups )
    return postfile;
  if ( no_newspost )
    return postfile;
  fd = LYOpenTemp(my_tempfile, ".html", "w");
  if ( !fd )
  {
    v2 = gettext("Can't open temporary file!");
    HTAlert(v2);
    return postfile;
  }
  CJKfile[0] = 0;
  if ( UCGetLYhndl_byMIME("euc-jp") == current_char_set || UCGetLYhndl_byMIME("shift_jis") == current_char_set )
  {
    fc = LYOpenTemp(CJKfile, ".html", "w");
    if ( !fc )
    {
      v3 = gettext("Can't open temporary file!");
      HTAlert(v3);
      LYRemoveTemp(my_tempfile);
      return postfile;
    }
  }
  HTSACopy(&NewsGroups, newsgroups);
  cp = strstr(NewsGroups, ";ref=");
  if ( cp )
  {
    *cp = 0;
    cp += 5;
    if ( *cp == 60 )
    {
      HTSACopy(&References, cp);
    }
    else
    {
      HTSACopy(&References, "<");
      HTSACat(&References, cp);
      HTSACat(&References, ">");
    }
    HTUnEscape(References);
    cp = strchr(References, 64);
    if ( !cp || References + 1 >= cp || ((*__ctype_b_loc())[(unsigned __int8)cp[1]] & 8) == 0 )
    {
      if ( References )
      {
        free(References);
        References = 0;
      }
    }
  }
  HTUnEscape(NewsGroups);
  if ( *NewsGroups )
  {
    signal(2, terminate_message);
    term_message[0] = 0;
    LYclear();
    LYmove(2, 0);
    scrollok(LYwin, 1);
    v4 = gettext("You will be posting to:");
    v5 = strlen(v4);
    v6 = gettext("You will be posting to:");
    LYwaddnstr(LYwin, v6, v5);
    LYwaddnstr(LYwin, "\n\t", 2u);
    v7 = strlen(NewsGroups);
    LYwaddnstr(LYwin, NewsGroups, v7);
    waddch(LYwin, 0xAu);
    v8 = gettext("\n\n Please provide your mail address for the From: header\n");
    v9 = strlen(v8);
    v10 = gettext("\n\n Please provide your mail address for the From: header\n");
    LYwaddnstr(LYwin, v10, v9);
    if ( personal_mail_address )
      sprintf(user_input, "From: %.*s", 1016, personal_mail_address);
    else
      sprintf(user_input, "From: %.*s", 1016, &byte_81631B6);
    if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 || term_message[0] )
      goto LABEL_28;
    fprintf(fd, "%s\n", user_input);
    v12 = gettext("\n\n Please provide or edit the Subject: header\n");
    v13 = strlen(v12);
    v14 = gettext("\n\n Please provide or edit the Subject: header\n");
    LYwaddnstr(LYwin, v14, v13);
    memcpy(user_input, "Subject: ", 0xAu);
    if ( followup == 1 && nhist > 0 )
    {
      kp = HText_getTitle();
      if ( kp )
      {
        kp = LYSkipCBlanks(kp);
        if ( HTCJK == JAPANESE )
        {
          CJKinput[0] = 0;
          if ( kanji_code == EUC )
          {
            TO_EUC((const unsigned __int8 *)kp, (unsigned __int8 *)CJKinput);
            kp = CJKinput;
          }
          else if ( kanji_code == SJIS )
          {
            TO_SJIS((const unsigned __int8 *)kp, (unsigned __int8 *)CJKinput);
            kp = CJKinput;
          }
        }
        if ( strncasecomp(kp, "Re:", 3) )
        {
          v15 = strlen(user_input);
          memcpy(&user_input[v15], "Re: ", 5u);
        }
        len = strlen(user_input);
        LYstrncpy(&user_input[len], kp, 1023 - len);
      }
    }
    cp = 0;
    if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 || term_message[0] )
    {
LABEL_28:
      v11 = gettext("News Post Cancelled!!!");
      HTInfoMsg(v11);
      LYCloseTempFP(fd);
      scrollok(LYwin, 0);
      goto cleanup;
    }
    fprintf(fd, "%s\n", user_input);
    HTSACopy(&cp, "Organization: ");
    org = LYGetEnv("ORGANIZATION");
    if ( org || (org = LYGetEnv("NEWS_ORGANIZATION")) != 0 )
    {
      HTSACat(&cp, org);
    }
    else
    {
      fp = (FILE *)fopen64("/etc/organization", "r");
      if ( fp )
      {
        msg = 0;
        if ( LYSafeGets(&msg, fp) && user_input[0] )
        {
          LYTrimNewline(msg);
          HTSACat(&cp, msg);
        }
        if ( msg )
        {
          free(msg);
          msg = 0;
        }
        LYCloseInput(fp);
      }
    }
    LYstrncpy(user_input, cp, 1008);
    if ( cp )
    {
      free(cp);
      cp = 0;
    }
    v16 = gettext("\n\n Please provide or edit the Organization: header\n");
    v17 = strlen(v16);
    v18 = gettext("\n\n Please provide or edit the Organization: header\n");
    LYwaddnstr(LYwin, v18, v17);
    if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 || term_message[0] )
    {
LABEL_87:
      v31 = gettext("News Post Cancelled!!!");
      HTInfoMsg(v31);
      LYCloseTempFP(fd);
      scrollok(LYwin, 0);
      goto cleanup;
    }
    fprintf(fd, "%s\n", user_input);
    if ( References )
      fprintf(fd, "References: %s\n", References);
    fprintf(fd, "Newsgroups: %s\nSummary: \nKeywords: \n\n", NewsGroups);
    if ( !no_editor && editor && *editor )
    {
      if ( followup && nhist > 0 )
      {
        if ( term_message[0] )
        {
          mustshow[0] = 1;
          v19 = gettext("Do you wish to include the original message?");
          statusline(v19);
        }
        else
        {
          v20 = gettext("Do you wish to include the original message?");
          if ( HTConfirm(v20) == 1 )
            print_wwwfile_to_fd(fd, 0, 1);
        }
      }
      LYCloseTempFP(fd);
      scrollok(LYwin, 0);
      if ( term_message[0] || c == 3 || c == 7 )
        goto cleanup;
      if ( c == -1 )
      {
        if ( keymap[0] == 47 )
          goto cleanup;
      }
      else if ( (c & 0x8800) != 0 )
      {
        if ( (unsigned __int8)c == 47 )
          goto cleanup;
      }
      else if ( keymap[(c & 0x7FF) + 1] == 47 )
      {
        goto cleanup;
      }
      v21 = gettext("Spawning your selected editor to edit news message");
      edit_temporary_file(my_tempfile, &byte_81631B6, v21);
      nonempty = message_has_content(my_tempfile, &nonspaces);
    }
    else
    {
      v22 = gettext("\n\n Please enter your message below.");
      v23 = strlen(v22);
      v24 = gettext("\n\n Please enter your message below.");
      LYwaddnstr(LYwin, v24, v23);
      v25 = gettext("\n When you are done, press enter and put a single period (.)");
      v26 = strlen(v25);
      v27 = gettext("\n When you are done, press enter and put a single period (.)");
      LYwaddnstr(LYwin, v27, v26);
      v28 = gettext("\n on a line and press enter again.");
      v29 = strlen(v28);
      v30 = gettext("\n on a line and press enter again.");
      LYwaddnstr(LYwin, v30, v29);
      LYwaddnstr(LYwin, "\n\n", 2u);
      LYrefresh();
      user_input[0] = 0;
      if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 || term_message[0] )
        goto LABEL_87;
      while ( strcmp(user_input, ".") && !term_message[0] )
      {
        waddch(LYwin, 0xAu);
        fprintf(fd, "%s\n", user_input);
        if ( !nonempty )
          nonempty = user_input[0] != 0;
        user_input[0] = 0;
        if ( LYgetstr(user_input, 0, 0x400u, NORECALL) < 0 )
          goto LABEL_87;
      }
      fputc(10, fd);
      LYCloseTempFP(fd);
      scrollok(LYwin, 0);
    }
    if ( nonempty )
    {
      LYStatusLine = LYlines - 1;
      v32 = gettext("Post this message?");
      c = HTConfirm(v32);
      LYStatusLine = -1;
      if ( c != 1 )
      {
        LYclear();
        goto cleanup;
      }
    }
    else
    {
      v33 = gettext("Message has no original text!");
      HTAlert(v33);
      if ( !nonspaces )
        goto cleanup;
      v34 = gettext("Post this message?");
      if ( HTConfirmDefault(v34, 0) != 1 )
        goto cleanup;
    }
    if ( LynxSigFile )
    {
      fp = (FILE *)fopen64(LynxSigFile, "r");
      if ( fp )
      {
        msg = 0;
        v35 = LynxSigFile;
        v36 = gettext("Append '%s'?");
        HTSprintf0(&msg, v36, v35);
        LYStatusLine = LYlines - 1;
        if ( term_message[0] )
        {
          mustshow[0] = 1;
          v37 = LynxSigFile;
          v38 = gettext("Append '%s'?");
          user_message(v38, v37);
        }
        else if ( HTConfirm(msg) == 1 )
        {
          fd = LYAppendToTxtFile(my_tempfile);
          if ( fd )
          {
            buffer = 0;
            fwrite("-- \n", 1u, 4u, fd);
            while ( LYSafeGets(&buffer, fp) )
              fputs(buffer, fd);
            LYCloseOutput(fd);
          }
        }
        LYCloseInput(fp);
        if ( msg )
        {
          free(msg);
          msg = 0;
        }
        LYStatusLine = -1;
      }
    }
    LYclear();
    if ( CJKfile[0] && (fd = (FILE *)fopen64(my_tempfile, "r")) != 0 )
    {
      buffer = 0;
      while ( LYSafeGets(&buffer, fd) )
      {
        TO_JIS((const unsigned __int8 *)buffer, (unsigned __int8 *)CJKinput);
        fputs(CJKinput, fc);
      }
      LYCloseTempFP(fc);
      HTSACopy(&postfile, CJKfile);
      LYCloseInput(fd);
      LYRemoveTemp(my_tempfile);
      strcpy(my_tempfile, CJKfile);
      CJKfile[0] = 0;
    }
    else
    {
      HTSACopy(&postfile, my_tempfile);
    }
    if ( !followup )
      LYforce_no_cache = 1;
    LYStatusLine = LYlines - 1;
    v39 = gettext("Posting to newsgroup(s)...");
    HTUserMsg(v39);
    LYStatusLine = -1;
    goto cleanup;
  }
  LYCloseTempFP(fd);
cleanup:
  signal(2, cleanup_sig);
  term_message[0] = 0;
  if ( !postfile )
    LYRemoveTemp(my_tempfile);
  LYRemoveTemp(CJKfile);
  if ( NewsGroups )
  {
    free(NewsGroups);
    NewsGroups = 0;
  }
  if ( References )
  {
    free(References);
    References = 0;
  }
  return postfile;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080B5141) --------------------------------------------------------
void __cdecl terminate_message(int sig)
{
  term_message[0] = 1;
  signal(2, terminate_message);
}

//----- (080B5164) --------------------------------------------------------
HTList *LYcommandList()
{
  char *data; // [esp+10h] [ebp-8h] BYREF
  unsigned int j; // [esp+14h] [ebp-4h]

  if ( !myList_9708 )
  {
    myList_9708 = HTList_new();
    for ( j = 0; revmap[j].name; ++j )
    {
      if ( revmap[j].doc )
      {
        data = 0;
        HTSACopy(&data, revmap[j].name);
        HTList_addObject(myList_9708, data);
      }
    }
  }
  return myList_9708;
}

//----- (080B51FE) --------------------------------------------------------
Kcmd *__cdecl LYKeycodeToKcmd(LYKeymapCode code)
{
  Kcmd *result; // [esp+8h] [ebp-8h]
  unsigned int j; // [esp+Ch] [ebp-4h]

  result = 0;
  if ( code )
  {
    for ( j = 0; revmap[j].name; ++j )
    {
      if ( revmap[j].code == code )
        return (Kcmd *)(12 * j + 135891232);
    }
  }
  return result;
}

//----- (080B5266) --------------------------------------------------------
Kcmd *__cdecl LYStringToKcmd(const char *name)
{
  Kcmd *maybe; // [esp+24h] [ebp-14h]
  Kcmd *result; // [esp+28h] [ebp-10h]
  unsigned int j; // [esp+2Ch] [ebp-Ch]
  int need; // [esp+30h] [ebp-8h]
  BOOLEAN exact; // [esp+37h] [ebp-1h]

  need = strlen(name);
  exact = 0;
  result = 0;
  maybe = 0;
  if ( name && *name )
  {
    for ( j = 0; revmap[j].name; ++j )
    {
      if ( !strcasecomp(revmap[j].name, name) )
      {
        result = (Kcmd *)(12 * j + 135891232);
        break;
      }
      if ( !exact && !strncasecomp(revmap[j].name, name, need) )
      {
        if ( maybe )
        {
          if ( revmap[j].name[need] && maybe->name[need] )
          {
            maybe = 0;
            exact = 1;
          }
        }
        else
        {
          maybe = (Kcmd *)(12 * j + 135891232);
        }
      }
    }
  }
  if ( result )
    return result;
  else
    return maybe;
}

//----- (080B53AA) --------------------------------------------------------
char *__cdecl LYKeycodeToString(int c, BOOLEAN upper8)
{
  unsigned int n; // [esp+20h] [ebp-8h]
  BOOLEAN named; // [esp+27h] [ebp-1h]

  named = 0;
  for ( n = 0; n <= 0x17; ++n )
  {
    if ( named_keys[n].key == c )
    {
      named = 1;
      strcpy(buf_9806, named_keys[n].name);
      break;
    }
  }
  if ( !named )
  {
    if ( c > 32 && c <= 126 || upper8 && c > 32 && c <= 255 && LYlowest_eightbit[current_char_set] >= c )
    {
      sprintf(buf_9806, "%c", c);
    }
    else if ( c > 31 )
    {
      if ( c <= 255 )
        sprintf(buf_9806, "0x%x", c);
      else
        sprintf(buf_9806, "key-0x%x", c);
    }
    else
    {
      sprintf(buf_9806, "^%c", c | 0x40);
    }
  }
  return buf_9806;
}

//----- (080B54E3) --------------------------------------------------------
int __cdecl LYStringToKeycode(char *src)
{
  char *dst; // [esp+18h] [ebp-10h] BYREF
  int len; // [esp+1Ch] [ebp-Ch]
  int key; // [esp+20h] [ebp-8h]
  unsigned int n; // [esp+24h] [ebp-4h]

  key = -1;
  len = strlen(src);
  if ( len == 1 )
  {
    key = *src;
  }
  else if ( len == 2 && *src == 94 )
  {
    key = src[1] & 0x1F;
  }
  else if ( len <= 2 || strncasecomp(src, "0x", 2) )
  {
    if ( len > 6 && !strncasecomp(src, "key-", 4) )
    {
      dst = 0;
      key = strtol(src + 4, &dst, 0);
      if ( !dst || !*dst )
        key = -1;
    }
  }
  else
  {
    dst = 0;
    key = strtol(src, &dst, 0);
    if ( dst && *dst )
      key = -1;
  }
  if ( key < 0 )
  {
    for ( n = 0; n <= 0x17; ++n )
    {
      if ( !strcasecomp(named_keys[n].name, src) )
        return named_keys[n].key;
    }
  }
  return key;
}

//----- (080B564D) --------------------------------------------------------
char *__cdecl pretty_html(int c)
{
  unsigned int n; // [esp+24h] [ebp-14h]
  int adj; // [esp+28h] [ebp-10h]
  int adja; // [esp+28h] [ebp-10h]
  char *dst; // [esp+2Ch] [ebp-Ch]
  char *src; // [esp+30h] [ebp-8h]
  BOOLEAN found; // [esp+37h] [ebp-1h]
  int ca; // [esp+40h] [ebp+8h]

  src = LYKeycodeToString(c, 1);
  if ( !src )
    return 0;
  dst = buf_9909;
  adj = 0;
  while ( 1 )
  {
    ca = *src++;
    if ( !ca )
      break;
    found = 0;
    for ( n = 0; n <= 3; ++n )
    {
      if ( table_9908[n].code == ca )
      {
        found = 1;
        strcpy(dst, (&off_8164CC4)[2 * n]);
        adj = strlen(dst) + adj - 1;
        dst += strlen(dst);
        break;
      }
    }
    if ( !found )
      *dst++ = ca;
  }
  adja = 135986657 - (_DWORD)dst + adj;
  while ( adja-- > 0 )
    *dst++ = 32;
  *dst = 0;
  return buf_9909;
}

//----- (080B5768) --------------------------------------------------------
char *__cdecl format_binding(LYKeymap_t *table, int i)
{
  Kcmd *rmap; // [esp+28h] [ebp-10h]
  const char *formatted; // [esp+2Ch] [ebp-Ch]
  char *buf; // [esp+30h] [ebp-8h] BYREF
  LYKeymapCode the_key; // [esp+34h] [ebp-4h]

  the_key = table[i];
  buf = 0;
  rmap = LYKeycodeToKcmd(the_key);
  if ( !rmap )
    return 0;
  if ( !rmap->name )
    return 0;
  if ( !rmap->doc )
    return 0;
  formatted = pretty_html(i - 1);
  if ( !formatted )
    return 0;
  HTSprintf0(&buf, "%-*s %-13s %s\n", 11, formatted, rmap->name, rmap->doc);
  return buf;
}

//----- (080B580F) --------------------------------------------------------
void __cdecl print_binding(HTStream *target, int i, BOOLEAN both)
{
  void (*put_block)(HTStream *, const char *, int); // ebx
  void (*v4)(HTStream *, const char *, int); // ebx
  void (*v5)(HTStream *, const char *, int); // ebx
  void (*v6)(HTStream *, const char *, int); // ebx
  size_t v7; // [esp+8h] [ebp-20h]
  size_t v8; // [esp+8h] [ebp-20h]
  size_t v9; // [esp+8h] [ebp-20h]
  size_t v10; // [esp+8h] [ebp-20h]
  LYKeymapCode lac1; // [esp+1Ch] [ebp-Ch]
  char *buf; // [esp+20h] [ebp-8h]
  char *bufa; // [esp+20h] [ebp-8h]
  int ia; // [esp+34h] [ebp+Ch]

  lac1 = LYK_UNKNOWN_0;
  if ( prev_lynx_edit_mode && !no_dired_support[0] && (lac1 = key_override[i]) != LYK_UNKNOWN_0 )
  {
    buf = format_binding(key_override, i);
    if ( !buf )
      goto LABEL_10;
    put_block = target->isa->put_block;
    v7 = strlen(buf);
    put_block(target, buf, v7);
  }
  else
  {
    buf = format_binding(keymap, i);
    if ( !buf )
      goto LABEL_10;
    lac1 = keymap[i];
    v4 = target->isa->put_block;
    v8 = strlen(buf);
    v4(target, buf, v8);
  }
  free(buf);
LABEL_10:
  if ( !both )
    return;
  ia = i - 32;
  if ( prev_lynx_edit_mode && !no_dired_support[0] && key_override[ia] )
  {
    if ( key_override[ia] != lac1 )
    {
      bufa = format_binding(key_override, ia);
      if ( bufa )
      {
        v5 = target->isa->put_block;
        v9 = strlen(bufa);
        v5(target, bufa, v9);
        goto LABEL_21;
      }
    }
  }
  else if ( keymap[ia] != lac1 )
  {
    bufa = format_binding(keymap, ia);
    if ( bufa )
    {
      v6 = target->isa->put_block;
      v10 = strlen(bufa);
      v6(target, bufa, v10);
LABEL_21:
      free(bufa);
    }
  }
}
// 80B589E: conditional instruction was optimized away because %buf.4!=0
// 80B590B: conditional instruction was optimized away because %buf.4!=0
// 80B59BC: conditional instruction was optimized away because %buf.4!=0
// 80B5A2F: conditional instruction was optimized away because %buf.4!=0

//----- (080B5A49) --------------------------------------------------------
int __cdecl lacname_to_lac(const char *func)
{
  Kcmd *mp; // [esp+14h] [ebp-4h]

  mp = LYStringToKcmd(func);
  if ( mp )
    return mp->code;
  else
    return -1;
}

//----- (080B5A79) --------------------------------------------------------
int __cdecl lecname_to_lec(const char *func)
{
  emap *mp; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( func && *func )
  {
    i = 0;
    for ( mp = ekmap; mp->name; ++mp )
    {
      if ( !strcmp(mp->name, func) )
        return mp->code;
      ++i;
    }
  }
  return -1;
}

//----- (080B5ADF) --------------------------------------------------------
int __cdecl lkcstring_to_lkc(const char *src)
{
  int v1; // eax
  int c; // [esp+24h] [ebp-4h] BYREF

  c = -1;
  if ( strlen(src) == 1 )
  {
    c = *src;
  }
  else if ( strlen(src) == 2 && *src == 94 )
  {
    c = src[1] & 0x1F;
  }
  else if ( strlen(src) > 1 && ((*__ctype_b_loc())[*(unsigned __int8 *)src] & 0x800) != 0 )
  {
    if ( sscanf(src, "%i", &c) != 1 )
      return -1;
  }
  else
  {
    map_string_to_keysym(src, &c);
    if ( c >= 0 )
    {
      if ( (c & 0x7FFu) > 0xFF && (c & 0x400) == 0 )
        return -1;
      v1 = c;
      BYTE1(v1) = BYTE1(c) & 0xFB;
      c = v1;
    }
  }
  if ( c == 27 )
    escape_bound = 1;
  if ( c >= -1 )
    return c;
  else
    return -1;
}

//----- (080B5C0E) --------------------------------------------------------
int __cdecl LYLoadKeymap(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  char *name; // esi
  char *v5; // ebx
  char *v6; // eax
  char *v7; // eax
  void (*put_block)(HTStream *, const char *, int); // ebx
  size_t v9; // eax
  void (*v10)(HTStream *, const char *, int); // ebx
  size_t v11; // eax
  void (*v12)(HTStream *, const char *, int); // ebx
  size_t v13; // eax
  int i; // [esp+20h] [ebp-18h]
  int ia; // [esp+20h] [ebp-18h]
  char *buf; // [esp+24h] [ebp-14h] BYREF
  HTStream *target; // [esp+28h] [ebp-10h]
  HTFormat format_in; // [esp+2Ch] [ebp-Ch]

  format_in = HTAtom_for("text/html");
  buf = 0;
  target = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
  if ( target )
  {
    anAnchor->no_cache = 1;
    v7 = gettext("Current Key Map");
    HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n", v7);
    put_block = target->isa->put_block;
    v9 = strlen(buf);
    put_block(target, buf, v9);
    HTSprintf0(&buf, "<pre>\n");
    v10 = target->isa->put_block;
    v11 = strlen(buf);
    v10(target, buf, v11);
    for ( i = 98; i <= 123; ++i )
      print_binding(target, i, 1);
    for ( ia = 1; ia <= 660; ++ia )
    {
      if ( (ia > 127 || ia <= 32 || ((*__ctype_b_loc())[-(1 - ia)] & 0x400) == 0) && (LYUseMouse || keymap[ia] != 84) )
        print_binding(target, ia, 0);
    }
    HTSprintf0(&buf, "</pre>\n</body>\n</html>\n");
    v12 = target->isa->put_block;
    v13 = strlen(buf);
    v12(target, buf, v13);
    target->isa->_free(target);
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    return 200;
  }
  else
  {
    name = format_out->name;
    v5 = format_in->name;
    v6 = gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf, v6, v5, name);
    HTAlert(buf);
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    return -29999;
  }
}

//----- (080B5E62) --------------------------------------------------------
int __cdecl remap(char *key, const char *func, BOOLEAN for_dired)
{
  int code; // eax
  int c; // [esp+20h] [ebp-8h]
  Kcmd *mp; // [esp+24h] [ebp-4h]

  if ( !func )
    return 0;
  c = lkcstring_to_lkc(key);
  if ( c < 0 )
    return 0;
  if ( (c & 0x8800) != 0 )
    return 0;
  if ( (c & 0x7FF) != c )
    c &= 0x7FFu;
  if ( c + 1 > 660 )
    return 0;
  mp = LYStringToKcmd(func);
  if ( !mp )
    return 0;
  if ( for_dired )
    key_override[c + 1] = mp->code;
  else
    keymap[c + 1] = mp->code;
  if ( c )
    return c;
  code = mp->code;
  BYTE1(code) = ((unsigned __int16)mp->code >> 8) | 8;
  return code;
}

//----- (080B5F57) --------------------------------------------------------
void __cdecl set_any_keys(ANY_KEYS *table, int size)
{
  int k; // [esp+8h] [ebp-8h]
  int j; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < size; ++j )
  {
    k = table[j].code + 1;
    table[j].save = keymap[k];
    keymap[k] = table[j].map;
  }
}

//----- (080B5FB7) --------------------------------------------------------
void __cdecl reset_any_keys(ANY_KEYS *table, int size)
{
  int j; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < size; ++j )
    keymap[table[j].code + 1] = table[j].save;
}

//----- (080B5FFD) --------------------------------------------------------
void set_vms_keys()
{
  set_any_keys(vms_keys_table, 2);
}

//----- (080B6019) --------------------------------------------------------
void set_vi_keys()
{
  set_any_keys(vi_keys_table, 4);
  did_vi_keys = 1;
}

//----- (080B603C) --------------------------------------------------------
void reset_vi_keys()
{
  if ( did_vi_keys )
  {
    reset_any_keys(vi_keys_table, 4);
    did_vi_keys = 0;
  }
}

//----- (080B606A) --------------------------------------------------------
void set_emacs_keys()
{
  set_any_keys(emacs_keys_table, 4);
  did_emacs_keys = 1;
}

//----- (080B608D) --------------------------------------------------------
void reset_emacs_keys()
{
  if ( did_emacs_keys )
  {
    reset_any_keys(emacs_keys_table, 4);
    did_emacs_keys = 0;
  }
}

//----- (080B60BB) --------------------------------------------------------
void set_numbers_as_arrows()
{
  set_any_keys(number_keys_table, 9);
  did_number_keys[0] = 1;
}

//----- (080B60DE) --------------------------------------------------------
void reset_numbers_as_arrows()
{
  if ( did_number_keys[0] )
  {
    reset_any_keys(number_keys_table, 9);
    did_number_keys[0] = 0;
  }
}

//----- (080B610C) --------------------------------------------------------
char *__cdecl key_for_func(int func)
{
  char *src; // [esp+14h] [ebp-14h]
  char *formatted; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  i = LYReverseKeymap(func);
  if ( i < 0 )
  {
    if ( !buf_10346 )
      HTSACopy(&buf_10346, &byte_81646F7);
  }
  else
  {
    formatted = LYKeycodeToString(i, 1);
    if ( formatted )
      src = formatted;
    else
      src = "?";
    HTSACopy(&buf_10346, src);
  }
  return buf_10346;
}

//----- (080B618A) --------------------------------------------------------
char *__cdecl fmt_keys(int lkc_first, int lkc_second)
{
  char *v2; // ebx
  const char *v5; // [esp+1Ch] [ebp-1Ch]
  const char *fmt_second; // [esp+24h] [ebp-14h]
  const char *fmt_first; // [esp+28h] [ebp-10h]
  char *buf; // [esp+2Ch] [ebp-Ch] BYREF
  BOOLEAN quotes; // [esp+33h] [ebp-5h]

  buf = 0;
  quotes = 0;
  if ( lkc_first < 0 )
    return 0;
  fmt_first = LYKeycodeToString(lkc_first, 1);
  if ( fmt_first && strlen(fmt_first) == 1 && *fmt_first != 39 )
    quotes = 1;
  if ( quotes )
  {
    if ( lkc_second < 0 )
    {
      HTSprintf0(&buf, "'%s'", fmt_first);
      return buf;
    }
    HTSprintf0(&buf, "'%s", fmt_first);
  }
  else
  {
    HTSACopy(&buf, fmt_first);
  }
  if ( lkc_second < 0 )
    return buf;
  fmt_second = LYKeycodeToString(lkc_second, 1);
  if ( fmt_second )
  {
    if ( quotes )
      v5 = "'";
    else
      v5 = &byte_81646F7;
    if ( (strlen(fmt_second) <= 2 || *fmt_second == 60) && (strlen(buf) <= 2 || (v2 = buf, v2[strlen(buf) - 1] == 62)) )
      HTSprintf(&buf, "%s%s%s", &byte_81646F7, fmt_second, v5);
    else
      HTSprintf(&buf, "%s%s%s", " ", fmt_second, v5);
    return buf;
  }
  if ( buf )
  {
    free(buf);
    buf = 0;
  }
  return 0;
}

//----- (080B6334) --------------------------------------------------------
int __cdecl best_reverse_keymap(int lac)
{
  int v2; // [esp+4h] [ebp-38h]
  int v4; // [esp+10h] [ebp-2Ch]
  int v5; // [esp+14h] [ebp-28h]
  int v6; // [esp+18h] [ebp-24h]
  int v7; // [esp+1Ch] [ebp-20h]
  int v8; // [esp+20h] [ebp-1Ch]
  int v9; // [esp+24h] [ebp-18h]
  int v10; // [esp+28h] [ebp-14h]
  int i; // [esp+38h] [ebp-4h]

  for ( i = 97; i >= 0; i = v5 )
  {
    if ( lynx_edit_mode && !no_dired_support[0] && lac )
    {
      v2 = (i & 0x8800) != 0 ? (unsigned __int8)i : key_override[(i & 0x7FF) + 1];
      if ( v2 == lac )
        return i;
    }
    if ( (i & 0x8800) != 0 )
      v4 = (unsigned __int8)i;
    else
      v4 = keymap[(i & 0x7FF) + 1];
    if ( v4 == lac )
      return i;
    if ( i == 122 )
    {
      v5 = 32;
    }
    else
    {
      if ( i == 96 )
      {
        v6 = 123;
      }
      else
      {
        if ( i == 126 )
        {
          v7 = 0;
        }
        else
        {
          if ( i == 31 )
          {
            v8 = 256;
          }
          else
          {
            if ( i == 659 )
            {
              v9 = 127;
            }
            else
            {
              if ( i == 255 )
                v10 = -1;
              else
                v10 = i + 1;
              v9 = v10;
            }
            v8 = v9;
          }
          v7 = v8;
        }
        v6 = v7;
      }
      v5 = v6;
    }
  }
  return -1;
}
// 80B636C: conditional instruction was optimized away because %c.4>=0
// 80B63CC: conditional instruction was optimized away because %c.4>=0

//----- (080B64CB) --------------------------------------------------------
char *__cdecl key_for_func_ext(int lac, int context_code)
{
  int v2; // eax
  int modkey; // [esp+20h] [ebp-8h] BYREF
  int lkc; // [esp+24h] [ebp-4h]

  modkey = -1;
  if ( context_code == 2 )
  {
    lkc = LYEditKeyForAction(lac, &modkey);
    if ( lkc >= 0 )
    {
      if ( (lkc & 0x7000) != 0 )
      {
        v2 = lkc;
        BYTE1(v2) = BYTE1(lkc) & 0x8F;
        return fmt_keys(modkey, v2);
      }
      return fmt_keys(lkc, -1);
    }
  }
  lkc = best_reverse_keymap(lac);
  if ( lkc < 0 )
    return 0;
  if ( context_code != 2 )
    return fmt_keys(lkc, -1);
  modkey = LYKeyForEditAction(23);
  if ( modkey >= 0 )
    return fmt_keys(modkey, lkc);
  else
    return 0;
}

//----- (080B65AE) --------------------------------------------------------
BOOLEAN __cdecl LYisNonAlnumKeyname(int ch_0, int KeyName)
{
  return ch_0 >= 0
      && ch_0 <= 660
      && (ch_0 <= 0 || !strchr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", ch_0))
      && keymap[ch_0 + 1] == KeyName;
}

//----- (080B660A) --------------------------------------------------------
int __cdecl LYReverseKeymap(int KeyName)
{
  int i; // [esp+10h] [ebp-4h]

  for ( i = 1; i <= 660; ++i )
  {
    if ( keymap[i] == KeyName )
      return i - 1;
  }
  return -1;
}

//----- (080B6650) --------------------------------------------------------
void __cdecl strtolower(char *i)
{
  char v1; // [esp+7h] [ebp-1h]

  if ( i )
  {
    while ( *i )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)*i] & 0x100) != 0 )
        v1 = tolower((unsigned __int8)*i);
      else
        v1 = *i;
      *i++ = v1;
    }
  }
}

//----- (080B66BA) --------------------------------------------------------
void __cdecl actually_set_style(HTStructured *me)
{
  LYUCcharset *UCInfoStage; // esi
  int UCLYhndl; // eax

  if ( me->text )
  {
    HText_setStyle(me->text, me->new_style);
  }
  else
  {
    LYGetChartransInfo((HTStructured_0 *)me);
    UCInfoStage = HTAnchor_getUCInfoStage(me->node_anchor, 3);
    UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 3);
    UCSetTransParams(&me->T, me->UCLYhndl, me->UCI, UCLYhndl, UCInfoStage);
    me->text = HText_new2(me->node_anchor, (HTStream *)me->target);
    HText_beginAppend(me->text);
    HText_setStyle(me->text, me->new_style);
    me->in_word = 0;
    LYCheckForContentBase((HTStructured_0 *)me);
  }
  me->old_style = me->new_style;
  me->style_change = 0;
}

//----- (080B67DB) --------------------------------------------------------
void __cdecl change_paragraph_style(HTStructured *me, HTStyle *style)
{
  if ( me->new_style != style )
  {
    me->style_change = 1;
    me->new_style = style;
  }
  me->in_word = 0;
}

//----- (080B680E) --------------------------------------------------------
BOOLEAN __cdecl LYBadHTML(HTStructured *me)
{
  char *v1; // eax

  if ( WWW_TraceFlag[0] || me->inBadHTML )
    return 1;
  v1 = gettext("** Bad HTML!!  Use -trace to diagnose. **");
  HTUserMsg(v1);
  me->inBadHTML = 1;
  return 0;
}

//----- (080B685B) --------------------------------------------------------
void __cdecl HTML_put_character(HTStructured *me, char c)
{
  int tag_number; // [esp+10h] [ebp-8h]
  char ca; // [esp+14h] [ebp-4h]

  ca = c;
  if ( LYMapsOnly[0] && me->sp->tag_number != 79 )
    return;
  if ( me->lastraw == 13 && c == 10 )
  {
    me->lastraw = -1;
    return;
  }
  me->lastraw = c;
  if ( c == 13 )
    ca = 10;
  switch ( me->sp->tag_number )
  {
    case 0x1C:
      return;
    case 0x49:
      HTChunkPutc(&me->math, ca);
      return;
    case 0x4F:
      HTChunkPutc(&me->object, ca);
      return;
    case 0x51:
    case 0x5B:
      goto LABEL_21;
    case 0x5A:
      HTChunkPutc(&me->script, ca);
      return;
    case 0x62:
      HTChunkPutc(&me->style_block, ca);
      return;
    case 0x69:
      HTChunkPutc(&me->textarea, ca);
      return;
    case 0x6E:
      if ( ca != 7 )
      {
        if ( ca == 10 || ca == 9 )
          HTChunkPutc(&me->title, 32);
        else
          HTChunkPutc(&me->title, ca);
      }
      return;
    default:
      if ( me->inSELECT && me->sp->tag_number )
      {
LABEL_21:
        HTChunkPutc(&me->option, ca);
        return;
      }
      tag_number = me->sp->tag_number;
      if ( tag_number == 85 )
        goto LABEL_36;
      if ( tag_number > 85 )
      {
        if ( tag_number == 86 )
        {
          if ( (ca != 10 || !me->inLABEL || me->inP) && (ca != 10 || me->inPRE) )
          {
            me->inP = 1;
            me->inLABEL = 0;
            HText_appendCharacter(me->text, ca);
          }
          me->inPRE = 1;
          goto LABEL_63;
        }
        if ( tag_number == 117 )
        {
LABEL_36:
          me->inP = 1;
          me->inLABEL = 0;
          HText_appendCharacter(me->text, ca);
          goto LABEL_63;
        }
      }
      else if ( tag_number == 70 )
      {
        goto LABEL_36;
      }
      if ( me->sp->style->id != 37 )
      {
        if ( me->sp->style->id != 38 && me->sp->style->id != 36 )
        {
          if ( me->style_change )
          {
            if ( ca == 10 || ca == 32 )
              return;
            if ( me->style_change )
              actually_set_style(me);
          }
          if ( ca == 10 )
          {
            if ( me->in_word )
            {
              if ( HText_getLastChar(me->text) != 32 )
              {
                me->inP = 1;
                me->inLABEL = 0;
                HText_appendCharacter(me->text, 32);
              }
              me->in_word = 0;
            }
          }
          else if ( ca == 32 || ca == 9 )
          {
            if ( HText_getLastChar(me->text) != 32 )
            {
              me->inP = 1;
              me->inLABEL = 0;
              HText_appendCharacter(me->text, 32);
            }
          }
          else
          {
            me->inP = 1;
            me->inLABEL = 0;
            HText_appendCharacter(me->text, ca);
            me->in_word = 1;
          }
          goto LABEL_63;
        }
        goto LABEL_36;
      }
      if ( (ca != 10 || !me->inLABEL || me->inP) && (ca != 10 || me->inPRE) )
      {
        me->inP = 1;
        me->inLABEL = 0;
        HText_appendCharacter(me->text, ca);
      }
      me->inPRE = 1;
LABEL_63:
      if ( ca == 10 || ca == 9 )
        HText_setLastChar(me->text, 32);
      else
        HText_setLastChar(me->text, ca);
      return;
  }
}
// 80B6906: conditional instruction was optimized away because %c.1 is in (<7u|==8|B..C|>=Eu)
// 80B6A6E: conditional instruction was optimized away because %c.1!=D
// 80B6AE3: conditional instruction was optimized away because %c.1!=D
// 80B6B2F: conditional instruction was optimized away because %c.1!=D
// 80B6BCA: conditional instruction was optimized away because %c.1!=D
// 80B6CEB: conditional instruction was optimized away because %c.1 is in (<9u|B..C|E..1F|>=21u)
// 80B6D49: conditional instruction was optimized away because %c.1 is in (<9u|B..C|>=Eu)

//----- (080B6D8D) --------------------------------------------------------
void __cdecl HTML_put_string(HTStructured *me, const char *s)
{
  const char *p; // [esp+2Ch] [ebp-Ch]
  char *translated_string; // [esp+30h] [ebp-8h] BYREF
  char c; // [esp+37h] [ebp-1h]

  translated_string = 0;
  if ( !s || LYMapsOnly[0] && me->sp->tag_number != 79 )
    return;
  if ( psrc_convert_string )
  {
    HTSACopy(&translated_string, s);
    LYUCTranslateHTMLString(&translated_string, me->tag_charset, current_char_set, 1, 1, 0, st_HTML_0);
    s = translated_string;
  }
  switch ( me->sp->tag_number )
  {
    case 0x1C:
      goto LABEL_63;
    case 0x46:
    case 0x55:
    case 0x56:
    case 0x75:
      goto LABEL_10;
    case 0x49:
      HTChunkPuts(&me->math, s);
      goto LABEL_63;
    case 0x4F:
      HTChunkPuts(&me->object, s);
      goto LABEL_63;
    case 0x51:
    case 0x5B:
      HTChunkPuts(&me->option, s);
      goto LABEL_63;
    case 0x5A:
      HTChunkPuts(&me->script, s);
      goto LABEL_63;
    case 0x62:
      HTChunkPuts(&me->style_block, s);
      goto LABEL_63;
    case 0x69:
      HTChunkPuts(&me->textarea, s);
      goto LABEL_63;
    case 0x6E:
      HTChunkPuts(&me->title, s);
      goto LABEL_63;
    default:
      if ( me->sp->style->freeFormat )
      {
        p = s;
        if ( !me->style_change )
          goto LABEL_62;
        while ( *p && (*p == 10 || *p == 13 || *p == 32 || *p == 9) )
          ++p;
        if ( !*p )
          goto LABEL_63;
        if ( me->style_change )
          actually_set_style(me);
        while ( 1 )
        {
LABEL_62:
          if ( !*p )
            goto LABEL_63;
          if ( *p != 13 || p[1] == 10 )
            c = *p;
          else
            c = 10;
          if ( me->style_change )
          {
            if ( c == 10 || c == 32 || c == 9 )
              goto LABEL_61;
            if ( me->style_change )
              actually_set_style(me);
          }
          if ( c == 10 )
          {
            if ( me->in_word )
            {
              if ( HText_getLastChar(me->text) != 32 )
                HText_appendCharacter(me->text, 32);
              me->in_word = 0;
            }
          }
          else if ( c == 32 || c == 9 )
          {
            if ( HText_getLastChar(me->text) != 32 )
              HText_appendCharacter(me->text, 32);
          }
          else if ( c != 13 )
          {
            HText_appendCharacter(me->text, c);
            me->in_word = 1;
          }
          if ( c == 10 || c == 9 || c == 13 && HText_getLastChar(me->text) == 32 )
            HText_setLastChar(me->text, 32);
          else
            HText_setLastChar(me->text, c);
LABEL_61:
          ++p;
        }
      }
      if ( psrc_view )
      {
        while ( *s )
          HTML_put_character(me, *s++);
      }
      else
      {
LABEL_10:
        HText_appendText(me->text, s);
      }
LABEL_63:
      if ( psrc_convert_string )
      {
        psrc_convert_string = 0;
        if ( translated_string )
          free(translated_string);
      }
      return;
  }
}

//----- (080B71D1) --------------------------------------------------------
void __cdecl HTML_write(HTStructured *me, const char *s, int l)
{
  char *p; // [esp+14h] [ebp-4h]

  if ( !LYMapsOnly[0] || me->sp->tag_number == 79 )
  {
    for ( p = (char *)s; p < &s[l]; ++p )
      HTML_put_character(me, *p);
  }
}

//----- (080B722A) --------------------------------------------------------
void __cdecl addClassName(const char *prefix, const char *actual, int length)
{
  unsigned int have; // [esp+20h] [ebp-8h]
  int offset; // [esp+24h] [ebp-4h]

  offset = strlen(prefix);
  have = Style_className_end - Style_className;
  if ( Style_className_end - Style_className + length + offset + 1 >= Style_className_len )
  {
    Style_className_len += 2 * (length + offset + 1 + have + 512);
    if ( Style_className )
      Style_className = (char *)realloc(Style_className, Style_className_len);
    else
      Style_className = (char *)malloc(Style_className_len);
    if ( !Style_className )
      outofmem("./HTML.c", "addClassName");
    Style_className_end = &Style_className[have];
  }
  if ( offset )
    strcpy(Style_className_end, prefix);
  if ( length )
    memcpy(&Style_className_end[offset], actual, length);
  Style_className_end[length + offset] = 0;
  strtolower(Style_className_end);
  Style_className_end += length + offset;
}

//----- (080B7372) --------------------------------------------------------
void __cdecl HTMLSRC_apply_markup(HTStructured *context, HTlexeme lexeme, BOOLEAN start, int tag_charset)
{
  FILE *v4; // eax
  HT_tagspec **v5; // [esp+24h] [ebp-24h]
  char *format; // [esp+2Ch] [ebp-1Ch]
  HT_tagspec *ts; // [esp+40h] [ebp-8h]

  if ( start )
    v5 = lexeme_start;
  else
    v5 = lexeme_end;
  for ( ts = v5[lexeme]; ts; ts = ts->next )
  {
    if ( ts->start )
    {
      current_tag_style = ts->style;
      force_current_tag_style[0] = 1;
      forced_classname = ts->class_name;
      force_classname[0] = 1;
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( ts->start )
        format = "SRCSTART %d\n";
      else
        format = "SRCSTOP %d\n";
      v4 = TraceFP();
      fprintf(v4, format, lexeme);
    }
    if ( ts->start )
      HTML_start_element(context, ts->element, ts->present, (const char **)ts->value, tag_charset, 0);
    else
      HTML_end_element(context, ts->element, 0);
  }
}

//----- (080B749C) --------------------------------------------------------
void __cdecl LYStartArea(HTStructured *obj, const char *href, const char *alt, const char *title, int tag_charset)
{
  const char *new_value[18]; // [esp+34h] [ebp-64h] BYREF
  int i; // [esp+7Ch] [ebp-1Ch]
  BOOLEAN new_present[18]; // [esp+82h] [ebp-16h] BYREF
  unsigned int v8; // [esp+94h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  for ( i = 0; i <= 17; ++i )
    new_present[i] = 0;
  if ( alt )
  {
    new_present[1] = 1;
    new_value[1] = alt;
  }
  if ( title && *title )
  {
    new_present[17] = 1;
    new_value[17] = title;
  }
  if ( href )
  {
    new_present[6] = 1;
    new_value[6] = href;
  }
  obj->isa->start_element(obj, 5, new_present, new_value, tag_charset, 0);
}

//----- (080B7565) --------------------------------------------------------
void __cdecl LYHandleFIG(
        HTStructured *me,
        const BOOLEAN *present,
        const char **value,
        BOOLEAN isobject,
        BOOLEAN imagemap,
        const char *id,
        const char *src,
        BOOLEAN convert,
        BOOLEAN start,
        BOOLEAN *intern_flag)
{
  bool v10; // [esp+14h] [ebp-34h]
  HTLinkType *ltype; // [esp+18h] [ebp-30h]
  char *s; // [esp+1Ch] [ebp-2Ch]
  const char *v13; // [esp+20h] [ebp-28h]
  char *href[2]; // [esp+40h] [ebp-8h] BYREF

  if ( start == 1 )
  {
    me->inFIG = 1;
    if ( me->inA )
    {
      if ( HTML_dtd.tags->contents )
        ++me->skip_stack;
      HTML_end_element(me, 0, 0);
    }
    if ( isobject )
    {
      me->inFIGwithP = 0;
      HTML_put_character(me, 32);
    }
    else
    {
      LYEnsureDoubleSpace((HTStructured_0 *)me);
      LYResetParagraphAlignment((HTStructured_0 *)me);
      me->inFIGwithP = 1;
    }
    if ( id && *id )
    {
      if ( present && convert )
        LYCheckForID((HTStructured_0 *)me, present, value, 6);
      else
        LYHandleID((HTStructured_0 *)me, id);
    }
    me->in_word = 0;
    me->inP = 0;
    if ( clickable_images && src && *src )
    {
      href[0] = 0;
      HTSACopy(href, src);
      v10 = href[0] && (*href[0] == 35 || !*href[0]);
      *intern_flag = v10;
      LYLegitimizeHREF((HTStructured_0 *)me, href, 1, 1);
      if ( *href[0] )
      {
        if ( intern_flag )
          ltype = HTInternalLink;
        else
          ltype = 0;
        me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor, 0, href[0], ltype);
        HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
        if ( !me->inBoldH )
          HText_appendCharacter(me->text, 5);
        if ( isobject )
        {
          if ( imagemap )
            v13 = "(IMAGE)";
          else
            v13 = "(OBJECT)";
          s = (char *)v13;
        }
        else
        {
          s = "[FIGURE]";
        }
        HTML_put_string(me, s);
        if ( !me->inBoldH )
          HText_appendCharacter(me->text, 6);
        HText_endAnchor(me->text, 0);
        HTML_put_character(me, 45);
        HTML_put_character(me, 32);
        me->in_word = 0;
      }
      if ( href[0] )
      {
        free(href[0]);
        href[0] = 0;
      }
    }
  }
  else
  {
    if ( me->inFIGwithP )
      LYEnsureDoubleSpace((HTStructured_0 *)me);
    else
      HTML_put_character(me, 32);
    LYResetParagraphAlignment((HTStructured_0 *)me);
    me->inFIGwithP = 0;
    me->inFIG = 0;
    change_paragraph_style(me, me->sp->style);
    if ( me->List_Nesting_Level >= 0 )
    {
      if ( me->style_change )
        actually_set_style(me);
      HText_NegateLineOne(me->text);
    }
  }
}

//----- (080B792A) --------------------------------------------------------
void __cdecl clear_objectdata(HTStructured *me)
{
  if ( me )
  {
    HTChunkClear(&me->object);
    me->object_started = 0;
    me->object_declare = 0;
    me->object_shapes = 0;
    me->object_ismap = 0;
    if ( me->object_usemap )
    {
      free(me->object_usemap);
      me->object_usemap = 0;
    }
    if ( me->object_id )
    {
      free(me->object_id);
      me->object_id = 0;
    }
    if ( me->object_title )
    {
      free(me->object_title);
      me->object_title = 0;
    }
    if ( me->object_data )
    {
      free(me->object_data);
      me->object_data = 0;
    }
    if ( me->object_type )
    {
      free(me->object_type);
      me->object_type = 0;
    }
    if ( me->object_classid )
    {
      free(me->object_classid);
      me->object_classid = 0;
    }
    if ( me->object_codebase )
    {
      free(me->object_codebase);
      me->object_codebase = 0;
    }
    if ( me->object_codetype )
    {
      free(me->object_codetype);
      me->object_codetype = 0;
    }
    if ( me->object_name )
    {
      free(me->object_name);
      me->object_name = 0;
    }
  }
}

//----- (080B7ABC) --------------------------------------------------------
#error "80B7ABC: too big function (funcsize=0)"

//----- (080C8F82) --------------------------------------------------------
int __cdecl HTML_end_element(HTStructured *me, int element_number, char **include)
{
  const char *v3; // ebx
  FILE *v4; // eax
  int skip_stack; // ebx
  FILE *v6; // eax
  int objects_mixed_open; // esi
  int v8; // ebx
  FILE *v9; // eax
  int objects_figged_open; // esi
  int v11; // ebx
  FILE *v12; // eax
  int v13; // ebx
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  char *v18; // ebx
  FILE *v19; // eax
  char *v20; // ebx
  FILE *v21; // eax
  FILE *v22; // eax
  FILE *v23; // eax
  int Underline_Level; // ebx
  FILE *v25; // eax
  int v26; // ebx
  FILE *v27; // eax
  char *v28; // ebx
  FILE *v29; // eax
  char *v30; // ebx
  FILE *v31; // eax
  FILE *v32; // eax
  char *v33; // ebx
  FILE *v34; // eax
  FILE *v35; // eax
  FILE *v36; // eax
  FILE *v37; // eax
  FILE *v38; // eax
  FILE *v39; // eax
  FILE *v40; // eax
  FILE *v41; // eax
  char *v42; // ebx
  FILE *v43; // eax
  FILE *v44; // eax
  FILE *v45; // eax
  FILE *v46; // eax
  size_t v47; // eax
  FILE *v48; // eax
  FILE *v49; // eax
  const char *v50; // ebx
  FILE *v51; // eax
  char *v53; // [esp+4h] [ebp-224h]
  char *v54; // [esp+4h] [ebp-224h]
  const char *v56; // [esp+30h] [ebp-1F8h]
  const char *v57; // [esp+34h] [ebp-1F4h]
  const char *name; // [esp+38h] [ebp-1F0h]
  char *v59; // [esp+3Ch] [ebp-1ECh]
  char *v60; // [esp+40h] [ebp-1E8h]
  char *v61; // [esp+44h] [ebp-1E4h]
  char *v62; // [esp+48h] [ebp-1E0h]
  const char *v63; // [esp+4Ch] [ebp-1DCh]
  const char *v64; // [esp+50h] [ebp-1D8h]
  const char *v65; // [esp+54h] [ebp-1D4h]
  const char *v66; // [esp+58h] [ebp-1D0h]
  const char *v67; // [esp+5Ch] [ebp-1CCh]
  const char *src; // [esp+60h] [ebp-1C8h]
  const char *v69; // [esp+64h] [ebp-1C4h]
  const char *v70; // [esp+68h] [ebp-1C0h]
  const char *v71; // [esp+6Ch] [ebp-1BCh]
  const char *v72; // [esp+70h] [ebp-1B8h]
  const char *v73; // [esp+74h] [ebp-1B4h]
  const char *v74; // [esp+78h] [ebp-1B0h]
  int List_Nesting_Level; // [esp+7Ch] [ebp-1ACh]
  const char *v76; // [esp+80h] [ebp-1A8h]
  char v77; // [esp+8Bh] [ebp-19Dh]
  char v78; // [esp+93h] [ebp-195h]
  char **includea; // [esp+94h] [ebp-194h]
  InputFieldData I; // [esp+9Ch] [ebp-18Ch] BYREF
  HTkcode specified_kcode; // [esp+F4h] [ebp-134h]
  HTkcode kcode; // [esp+F8h] [ebp-130h]
  char *ptr; // [esp+FCh] [ebp-12Ch]
  int j_0; // [esp+100h] [ebp-128h]
  int j; // [esp+104h] [ebp-124h]
  char *data_0; // [esp+108h] [ebp-120h]
  int chars; // [esp+10Ch] [ebp-11Ch]
  char *data; // [esp+110h] [ebp-118h] BYREF
  char *last_map; // [esp+114h] [ebp-114h]
  char *first_map; // [esp+118h] [ebp-110h]
  char *last_end; // [esp+11Ch] [ebp-10Ch]
  char *first_end; // [esp+120h] [ebp-108h]
  char *start; // [esp+124h] [ebp-104h]
  int e; // [esp+128h] [ebp-100h]
  int s; // [esp+12Ch] [ebp-FCh]
  int tag_charset; // [esp+130h] [ebp-F8h]
  HTTag *tag; // [esp+134h] [ebp-F4h]
  char *cp; // [esp+138h] [ebp-F0h]
  char *temp; // [esp+13Ch] [ebp-ECh] BYREF
  int status; // [esp+140h] [ebp-E8h]
  int i; // [esp+144h] [ebp-E4h]
  BOOLEAN have_param; // [esp+14Bh] [ebp-DDh]
  BOOLEAN reached_awaited_stacked_elt; // [esp+14Ch] [ebp-DCh]
  BOOLEAN skip_stack_requested; // [esp+14Dh] [ebp-DBh]
  BOOLEAN intern_flag; // [esp+14Eh] [ebp-DAh] BYREF
  BOOLEAN BreakFlag; // [esp+14Fh] [ebp-D9h]
  char buf[200]; // [esp+150h] [ebp-D8h] BYREF
  unsigned int v108; // [esp+218h] [ebp-10h]

  includea = include;
  v108 = __readgsdword(0x14u);
  i = 0;
  status = 0;
  temp = 0;
  cp = 0;
  BreakFlag = 0;
  intern_flag = 0;
  skip_stack_requested = 0;
  reached_awaited_stacked_elt = 0;
  if ( psrc_view && !sgml_in_psrc_was_initialized[0] && !psrc_nested_call[0] )
  {
    tag = &HTML_dtd.tags[element_number];
    tag_charset = 0;
    psrc_nested_call[0] = 1;
    HTMLSRC_apply_markup(me, HTL_abracket, 1, 0);
    HTML_put_string(me, "</");
    HTMLSRC_apply_markup(me, HTL_abracket, 0, 0);
    HTMLSRC_apply_markup(me, HTL_tag, 1, 0);
    if ( tagname_transform )
    {
      HTML_put_string(me, tag->name);
    }
    else
    {
      LYstrncpy(buf, tag->name, 199);
      LYLowerCase(buf);
      HTML_put_string(me, buf);
    }
    HTMLSRC_apply_markup(me, HTL_tag, 0, tag_charset);
    HTMLSRC_apply_markup(me, HTL_abracket, 1, tag_charset);
    HTML_put_character(me, 62);
    HTMLSRC_apply_markup(me, HTL_abracket, 0, tag_charset);
    psrc_nested_call[0] = 0;
    return 0;
  }
  if ( (me->sp >= &me->stack[799] || me->sp->tag_number != element_number)
    && HTML_dtd.tags[element_number].contents
    && WWW_TraceFlag[0] )
  {
    if ( me->sp == &me->stack[799] )
    {
      v56 = "none";
    }
    else
    {
      if ( me->sp->tag_number < 0 )
      {
        v57 = "*invalid tag*";
      }
      else
      {
        if ( me->sp->tag_number > 117 )
          name = "special tag";
        else
          name = HTML_dtd.tags[me->sp->tag_number].name;
        v57 = name;
      }
      v56 = v57;
    }
    v3 = HTML_dtd.tags[element_number].name;
    v4 = TraceFP();
    fprintf(v4, "HTML: end of element %s when expecting end of %s\n", v3, v56);
  }
  if ( LYMapsOnly[0] && element_number != 71 && element_number != 5 && element_number != 79 )
    return 0;
  if ( HTML_dtd.tags[element_number].contents )
  {
    skip_stack_requested = me->skip_stack > 0;
    if ( me->sp->tag_number != element_number
      && me->skip_stack <= 0
      && HTML_dtd.tags[67].contents
      && (me->sp->tag_number == 114
       || me->sp->tag_number == 80
       || me->sp->tag_number == 74
       || me->sp->tag_number == 33
       || me->sp->tag_number == 68)
      && (element_number == 47
       || element_number == 48
       || element_number == 49
       || element_number == 50
       || element_number == 51
       || element_number == 52) )
    {
      BreakFlag = 1;
    }
    if ( !me->skip_stack && element_number == 79 && me->sp->tag_number == 149 && me->sp < &me->stack[799] )
      me->sp->tag_number = 79;
    if ( me->skip_stack <= 0 )
    {
      if ( element_number != 79
        || me->sp->tag_number == 79
        || me->sp->tag_number == 149
        || me->objects_mixed_open <= 0
        || me->objects_figged_open > 0 && me->sp->tag_number == 41 )
      {
        if ( me->stack_overrun == 1 && me->sp->tag_number != element_number )
          return 0;
        if ( element_number == 91 && me->sp->tag_number != 91 )
          return 0;
        if ( me->sp->tag_number != element_number
          && HTML_dtd.tags[67].contents == SGML_EMPTY
          && (me->sp->tag_number == 114
           || me->sp->tag_number == 80
           || me->sp->tag_number == 74
           || me->sp->tag_number == 33
           || me->sp->tag_number == 68)
          && (element_number == 47
           || element_number == 48
           || element_number == 49
           || element_number == 50
           || element_number == 51
           || element_number == 52) )
        {
          return 0;
        }
        if ( me->sp >= &me->stack[799] )
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
          {
            v15 = TraceFP();
            fprintf(v15, "Stack underflow error!  Tried to pop off more styles than exist in stack\n");
          }
        }
        else
        {
          if ( me->stack - me->sp + 800 == wait_for_this_stacked_elt )
            reached_awaited_stacked_elt = 1;
          if ( element_number == 79 && me->sp->tag_number == 41 && me->objects_figged_open > 0 )
          {
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
            {
              if ( me->sp->style->name )
                v61 = me->sp->style->name;
              else
                v61 = "(null)";
              objects_figged_open = me->objects_figged_open;
              v11 = &me->stack[799] - me->sp;
              v12 = TraceFP();
              fprintf(
                v12,
                "HTML:end_element[%d]: %s (level %d), %s - %s\n",
                v11,
                "Special OBJECT->FIG handling",
                objects_figged_open,
                "treating as end FIG",
                v61);
            }
            --me->objects_figged_open;
            element_number = 41;
          }
          ++me->sp;
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
          {
            if ( me->sp->style->name )
              v62 = me->sp->style->name;
            else
              v62 = "(null)";
            v13 = &me->stack[799] - me->sp;
            v14 = TraceFP();
            fprintf(v14, "HTML:end_element[%d]: Popped style off stack - %s\n", v13, v62);
          }
        }
      }
      else
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
        {
          if ( me->sp->style->name )
            v60 = me->sp->style->name;
          else
            v60 = "(null)";
          objects_mixed_open = me->objects_mixed_open;
          v8 = &me->stack[799] - me->sp;
          v9 = TraceFP();
          fprintf(
            v9,
            "HTML:end_element[%d]: %s (level %d), %s - %s\n",
            v8,
            "Special OBJECT handling",
            objects_mixed_open,
            "leaving on stack",
            v60);
        }
        --me->objects_mixed_open;
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        if ( me->sp->style->name )
          v59 = me->sp->style->name;
        else
          v59 = "(null)";
        skip_stack = me->skip_stack;
        v6 = TraceFP();
        fprintf(v6, "HTML:end_element: Internal call (level %d), leaving on stack - %s\n", skip_stack, v59);
      }
      --me->skip_stack;
    }
  }
  if ( BreakFlag == 1 )
  {
    if ( reached_awaited_stacked_elt )
      wait_for_this_stacked_elt = -1;
    return 0;
  }
  if ( me->inTEXTAREA && element_number != 105 && LYBadHTML(me) && WWW_TraceFlag[0] )
  {
    v16 = TraceFP();
    fprintf(v16, "Bad HTML: Missing TEXTAREA end tag\n");
  }
  if ( !me->text && !LYMapsOnly[0] && me->style_change )
    actually_set_style(me);
  switch ( element_number )
  {
    case 0:
      if ( me->inA )
      {
        me->inA = 0;
        if ( hidden_link_marker && *hidden_link_marker && HText_isAnchorBlank(me->text, me->CurrentANum) )
          HText_appendText(me->text, hidden_link_marker);
        if ( me->style_change )
          actually_set_style(me);
        if ( me->inBoldA == 1 && !me->inBoldH )
          HText_appendCharacter(me->text, 6);
        HText_endAnchor(me->text, me->CurrentANum);
        me->CurrentANum = 0;
        me->inBoldA = 0;
        if ( me->Underline_Level > 0 && !me->inUnderline )
          goto LABEL_249;
      }
      goto LABEL_689;
    case 1:
    case 2:
    case 6:
    case 7:
    case 12:
    case 14:
    case 21:
    case 25:
    case 30:
    case 32:
    case 37:
    case 63:
    case 65:
    case 67:
    case 68:
    case 82:
    case 89:
    case 93:
    case 94:
    case 100:
    case 103:
    case 107:
    case 109:
    case 112:
    case 115:
      goto LABEL_689;
    case 3:
    case 9:
    case 16:
    case 19:
    case 72:
      change_paragraph_style(me, me->sp->style);
      if ( me->style_change )
        actually_set_style(me);
      if ( me->sp->tag_number == element_number )
        LYEnsureDoubleSpace((HTStructured_0 *)me);
      if ( me->List_Nesting_Level >= 0 )
        goto LABEL_674;
      goto LABEL_689;
    case 4:
      if ( me->inAPPLETwithP )
        LYEnsureDoubleSpace((HTStructured_0 *)me);
      else
        HTML_put_character(me, 32);
      LYResetParagraphAlignment((HTStructured_0 *)me);
      me->inAPPLETwithP = 0;
      me->inAPPLET = 0;
      change_paragraph_style(me, me->sp->style);
      goto LABEL_689;
    case 8:
    case 15:
    case 24:
    case 38:
    case 57:
    case 97:
    case 113:
      if ( me->Underline_Level > 0 )
      {
        --me->Underline_Level;
        if ( me->inUnderline && me->Underline_Level <= 0 )
        {
          HText_appendCharacter(me->text, 4);
          me->inUnderline = 0;
          if ( WWW_TraceFlag[0] )
          {
            v23 = TraceFP();
            fprintf(v23, "Ending underline\n");
          }
        }
        else if ( WWW_TraceFlag[0] )
        {
          Underline_Level = me->Underline_Level;
          v25 = TraceFP();
          fprintf(v25, "Underline Level is %d\n", Underline_Level);
        }
      }
      goto LABEL_689;
    case 17:
      if ( (me->inA || me->inSELECT || me->inTEXTAREA) && LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        if ( me->inA )
          v70 = "A";
        else
          v70 = &actual;
        if ( (me->inSELECT || me->inTEXTAREA) && me->inA )
          v71 = ", ";
        else
          v71 = &actual;
        if ( me->inTEXTAREA )
          v72 = "TEXTAREA";
        else
          v72 = &actual;
        if ( me->inSELECT && me->inTEXTAREA )
          v73 = ", ";
        else
          v73 = &actual;
        if ( me->inSELECT )
          v74 = "SELECT";
        else
          v74 = &actual;
        v22 = TraceFP();
        fprintf(v22, "Bad HTML: %s%s%s%s%s not closed before BODY end tag *****\n", v74, v73, v72, v71, v70);
      }
      goto LABEL_689;
    case 22:
      LYEnsureDoubleSpace((HTStructured_0 *)me);
      LYResetParagraphAlignment((HTStructured_0 *)me);
      me->inCAPTION = 0;
      change_paragraph_style(me, me->sp->style);
      me->inLABEL = 0;
      goto LABEL_689;
    case 23:
    case 34:
      if ( me->Division_Level >= 0 )
        --me->Division_Level;
      if ( me->Division_Level >= 0 && me->sp->style->alignment != me->DivisionAlignments[me->Division_Level] )
      {
        if ( me->inP )
          LYEnsureSingleSpace((HTStructured_0 *)me);
        me->sp->style->alignment = me->DivisionAlignments[me->Division_Level];
      }
      change_paragraph_style(me, me->sp->style);
      if ( me->style_change )
      {
        actually_set_style(me);
        if ( me->List_Nesting_Level >= 0 )
          HText_NegateLineOne(me->text);
      }
      else if ( me->inP )
      {
        LYEnsureSingleSpace((HTStructured_0 *)me);
      }
      me->current_default_alignment = me->sp->style->alignment;
      goto LABEL_689;
    case 27:
      if ( me->inTABLE )
        HText_endStblCOLGROUP(me->text);
      goto LABEL_689;
    case 29:
      LYEnsureDoubleSpace((HTStructured_0 *)me);
      LYResetParagraphAlignment((HTStructured_0 *)me);
      me->inCREDIT = 0;
      change_paragraph_style(me, me->sp->style);
      me->inLABEL = 0;
      goto LABEL_689;
    case 31:
    case 88:
    case 96:
      HTML_put_character(me, 32);
      if ( !me->inUnderline )
        HText_appendCharacter(me->text, 3);
      HTML_put_string(me, ":DEL]");
      if ( !me->inUnderline )
        HText_appendCharacter(me->text, 4);
      goto LABEL_264;
    case 33:
    case 35:
    case 74:
    case 114:
      goto LABEL_292;
    case 40:
    case 58:
    case 66:
    case 77:
      LYEnsureDoubleSpace((HTStructured_0 *)me);
      LYResetParagraphAlignment((HTStructured_0 *)me);
      change_paragraph_style(me, me->sp->style);
      goto LABEL_689;
    case 41:
      LYHandleFIG(me, 0, 0, 0, 0, 0, 0, 0, 0, &intern_flag);
      goto LABEL_689;
    case 42:
    case 78:
      change_paragraph_style(me, me->sp->style);
      if ( me->style_change )
        actually_set_style(me);
      if ( me->sp->tag_number == element_number )
        LYEnsureDoubleSpace((HTStructured_0 *)me);
      if ( me->List_Nesting_Level >= 0 )
        HText_NegateLineOne(me->text);
      me->inLABEL = 0;
      goto LABEL_689;
    case 43:
      me->inFONT = 0;
      goto LABEL_689;
    case 44:
      if ( !me->inFORM && LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        v44 = TraceFP();
        fprintf(v44, "Bad HTML: Unmatched FORM end tag\n");
      }
      form_in_htext = 0;
      if ( me->inSELECT )
      {
        if ( LYBadHTML(me) && WWW_TraceFlag[0] )
        {
          v45 = TraceFP();
          fprintf(v45, "Bad HTML: Open SELECT at FORM end. Faking SELECT end tag. *****\n");
        }
        if ( me->sp->tag_number != 91 && HTML_dtd.tags[91].contents )
          ++me->skip_stack;
        HTML_end_element(me, 91, include);
      }
      me->inFORM = 0;
      HText_endForm(me->text);
      if ( me->List_Nesting_Level < 0 || me->inP )
        goto LABEL_299;
      goto LABEL_689;
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
      if ( me->Division_Level < 0 )
      {
        if ( me->sp->style->id == 47 || me->sp->style->id == 41 )
        {
          me->sp->style->alignment = 3;
        }
        else if ( me->sp->style->id == 49 )
        {
          me->sp->style->alignment = 2;
        }
        else
        {
          me->sp->style->alignment = 1;
        }
      }
      else
      {
        me->sp->style->alignment = me->DivisionAlignments[me->Division_Level];
      }
      change_paragraph_style(me, me->sp->style);
      if ( me->style_change )
        actually_set_style(me);
      if ( (styles[element_number]->font & 2) != 0 )
      {
        if ( !me->inBoldA && me->inBoldH == 1 )
          HText_appendCharacter(me->text, 6);
        me->inBoldH = 0;
      }
      if ( me->List_Nesting_Level >= 0 )
        HText_NegateLineOne(me->text);
      if ( me->Underline_Level > 0 && !me->inUnderline )
      {
LABEL_249:
        HText_appendCharacter(me->text, 3);
        me->inUnderline = 1;
      }
      goto LABEL_689;
    case 53:
      if ( me->inBASE
        && (LYIsUIPage3(me->node_anchor->address, UIP_LIST_PAGE_0, 0)
         || LYIsUIPage3(me->node_anchor->address, UIP_ADDRLIST_PAGE_0, 0)) )
      {
        HTSACopy(&me->node_anchor->content_base, me->base_href);
      }
      if ( HText_hasToolbar(me->text) )
        HText_appendParagraph(me->text);
      goto LABEL_689;
    case 55:
      if ( (me->inA || me->inSELECT || me->inTEXTAREA) && LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        if ( me->inA )
          v63 = "A";
        else
          v63 = &actual;
        if ( (me->inSELECT || me->inTEXTAREA) && me->inA )
          v64 = ", ";
        else
          v64 = &actual;
        if ( me->inTEXTAREA )
          v65 = "TEXTAREA";
        else
          v65 = &actual;
        if ( me->inSELECT && me->inTEXTAREA )
          v66 = ", ";
        else
          v66 = &actual;
        if ( me->inSELECT )
          v67 = "SELECT";
        else
          v67 = &actual;
        v17 = TraceFP();
        fprintf(v17, "Bad HTML: %s%s%s%s%s not closed before HTML end tag *****\n", v67, v66, v65, v64, v63);
      }
      goto LABEL_689;
    case 61:
      HTML_put_character(me, 32);
      if ( !me->inUnderline )
        HText_appendCharacter(me->text, 3);
      HTML_put_string(me, ":INS]");
      if ( !me->inUnderline )
        HText_appendCharacter(me->text, 4);
LABEL_264:
      HTML_put_character(me, 32);
      me->in_word = 0;
      goto LABEL_689;
    case 70:
    case 85:
    case 117:
      goto LABEL_276;
    case 71:
      if ( me->map_address )
      {
        free(me->map_address);
        me->map_address = 0;
      }
      goto LABEL_689;
    case 73:
      HTChunkPutc(&me->math, 32);
      HTChunkTerminate(&me->math);
      if ( me->math.size > 2 )
      {
        LYEnsureSingleSpace((HTStructured_0 *)me);
        if ( !me->inUnderline )
          HText_appendCharacter(me->text, 3);
        HTML_put_string(me, "[MATH:");
        HText_appendCharacter(me->text, 4);
        HTML_put_character(me, 32);
        HTML_put_string(me, me->math.data);
        HText_appendCharacter(me->text, 3);
        HTML_put_string(me, ":MATH]");
        if ( !me->inUnderline )
          HText_appendCharacter(me->text, 4);
        LYEnsureSingleSpace((HTStructured_0 *)me);
      }
      HTChunkClear(&me->math);
      goto LABEL_689;
    case 79:
      s = 0;
      e = 0;
      start = 0;
      first_end = 0;
      last_end = 0;
      first_map = 0;
      last_map = 0;
      have_param = 0;
      data = 0;
      HTChunkTerminate(&me->object);
      for ( data = me->object.data; ; data = cp + 1 )
      {
        cp = strchr(data, 60);
        if ( !cp )
          break;
        if ( !strncmp(cp, "<!--", 4u) )
        {
          cp = LYFindEndOfComment(cp);
        }
        else if ( s
               || strncasecomp(cp, "<PARAM", 6)
               || ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 8) != 0
               || cp[6] == 95
               || cp[6] == 45
               || cp[6] == 46
               || cp[6] == 58 )
        {
          if ( strncasecomp(cp, "<OBJECT", 7)
            || ((*__ctype_b_loc())[(unsigned __int8)cp[7]] & 8) != 0
            || cp[7] == 95
            || cp[7] == 45
            || cp[7] == 46
            || cp[7] == 58 )
          {
            if ( strncasecomp(cp, "</OBJECT", 8)
              || ((*__ctype_b_loc())[(unsigned __int8)cp[8]] & 8) != 0
              || cp[8] == 95
              || cp[8] == 45
              || cp[8] == 46
              || cp[8] == 58 )
            {
              if ( strncasecomp(cp, "<MAP", 4)
                || ((*__ctype_b_loc())[(unsigned __int8)cp[4]] & 8) != 0
                || cp[4] == 95
                || cp[4] == 45
                || cp[4] == 46
                || cp[4] == 58 )
              {
                if ( !strncasecomp(cp, "</MAP", 5)
                  && ((*__ctype_b_loc())[(unsigned __int8)cp[5]] & 8) == 0
                  && cp[5] != 95
                  && cp[5] != 45
                  && cp[5] != 46
                  && cp[5] != 58 )
                {
                  last_map = cp;
                }
              }
              else
              {
                if ( !first_map )
                  first_map = cp;
                last_map = cp;
              }
            }
            else
            {
              if ( !e )
                first_end = cp;
              last_end = cp;
              ++e;
            }
          }
          else
          {
            if ( !s )
              start = cp;
            ++s;
          }
        }
        else
        {
          have_param = 1;
        }
      }
      if ( s < e )
      {
        if ( LYBadHTML(me) && WWW_TraceFlag[0] )
        {
          v28 = me->object.data;
          v29 = TraceFP();
          fprintf(v29, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content:\n%s\n", v28);
        }
        goto End_Object;
      }
      if ( s <= e )
      {
        if ( WWW_TraceFlag[0] )
        {
          v33 = me->object.data;
          v34 = TraceFP();
          fprintf(v34, "HTML:OBJECT content:\n%s\n", v33);
        }
        if ( me->object_declare == 1 )
        {
          if ( me->object_id && *me->object_id && !LYMapsOnly[0] )
            LYHandleID((HTStructured_0 *)me, me->object_id);
          if ( WWW_TraceFlag[0] )
          {
            v35 = TraceFP();
            fprintf(v35, "HTML: DECLAREd OBJECT.  Ignoring!\n");
          }
          goto End_Object;
        }
        if ( me->object_name && !LYMapsOnly[0] )
        {
          if ( me->object_id && *me->object_id )
            LYHandleID((HTStructured_0 *)me, me->object_id);
          if ( WWW_TraceFlag[0] )
          {
            v36 = TraceFP();
            fprintf(v36, "HTML: NAMEd OBJECT.  Ignoring!\n");
          }
          goto End_Object;
        }
        if ( s <= 0 )
          goto LABEL_437;
        if ( !start || !first_end || first_end <= start )
        {
          if ( LYBadHTML(me) && WWW_TraceFlag[0] )
          {
            v38 = TraceFP();
            fprintf(v38, "Bad HTML: Unmatched OBJECT start and end tags.  Discarding content.\n");
          }
          goto End_Object;
        }
        if ( LYMapsOnly[0] )
        {
          if ( last_map && last_map >= first_end )
            e = 0;
          else
            *first_end = 0;
          data = 0;
          if ( !LYMapsOnly[0] || first_map && first_map <= start )
            HTSACopy(&data, me->object.data);
          else
            HTSACopy(&data, start);
          if ( e > 0 )
          {
            for ( i = e; i > 0; --i )
              HTSACat(&data, "</OBJECT>");
          }
          if ( !include )
            includea = &me->xinclude;
          HTSACat(includea, data);
          if ( WWW_TraceFlag[0] )
          {
            if ( s <= 1 )
              v76 = &actual;
            else
              v76 = "s";
            v37 = TraceFP();
            fprintf(v37, "HTML: Recycling nested OBJECT%s.\n", v76);
          }
          if ( !data )
            goto End_Object;
        }
        else
        {
LABEL_437:
          if ( me->object_shapes == 1 && !LYMapsOnly[0] )
          {
            if ( WWW_TraceFlag[0] )
            {
              v39 = TraceFP();
              fprintf(v39, "HTML: OBJECT has SHAPES.  Converting to FIG.\n");
            }
            if ( !include )
              includea = &me->xinclude;
            HTSACat(includea, "<FIG ISOBJECT IMAGEMAP");
            if ( me->object_ismap == 1 )
              HTSACat(includea, " IMAGEMAP");
            if ( me->object_id )
            {
              HTSACat(includea, " ID=\"");
              HTSACat(includea, me->object_id);
              HTSACat(includea, "\"");
            }
            if ( me->object_data && !me->object_classid )
            {
              HTSACat(includea, " SRC=\"");
              HTSACat(includea, me->object_data);
              HTSACat(includea, "\"");
            }
            HTSACat(includea, ">");
            --me->object.size;
            HTChunkPuts(&me->object, "</FIG>");
            HTChunkTerminate(&me->object);
            HTSACat(includea, me->object.data);
            goto End_Object;
          }
          if ( !me->object_usemap || LYMapsOnly[0] )
          {
            if ( me->object_id && *me->object_id && !LYMapsOnly[0] )
              LYHandleID((HTStructured_0 *)me, me->object_id);
            if ( me->object.size > 1 )
            {
              if ( !include )
                includea = &me->xinclude;
              HTSACat(includea, me->object.data);
            }
            if ( clickable_images
              && !LYMapsOnly[0]
              && me->object_data
              && !have_param
              && !me->object_classid
              && !me->object_codebase
              && !me->object_codetype )
            {
              if ( !includea )
                includea = &me->xinclude;
              if ( me->inA )
                HTSACat(includea, "</A>");
              HTSACat(includea, " -<A HREF=\"");
              HTSACat(includea, me->object_data);
              HTSACat(includea, "\">");
              if ( !me->object_type || strncasecomp(me->object_type, "image/", 6) )
                HTSACat(includea, "(OBJECT)");
              else
                HTSACat(includea, "(IMAGE)");
              HTSACat(includea, "</A> ");
            }
            goto End_Object;
          }
          if ( WWW_TraceFlag[0] )
          {
            v40 = TraceFP();
            fprintf(v40, "HTML: OBJECT has USEMAP.  Converting to IMG.\n");
          }
          if ( !include )
            includea = &me->xinclude;
          HTSACat(includea, "<IMG ISOBJECT");
          if ( me->object_id )
          {
            HTSACat(includea, " ID=\"");
            HTSACat(includea, me->object_id);
            HTSACat(includea, "\"");
          }
          if ( me->object_data && !me->object_classid )
          {
            HTSACat(includea, " SRC=\"");
            HTSACat(includea, me->object_data);
            HTSACat(includea, "\"");
          }
          if ( me->object_title )
          {
            HTSACat(includea, " TITLE=\"");
            HTSACat(includea, me->object_title);
            HTSACat(includea, "\" ALT=\"");
            HTSACat(includea, me->object_title);
            HTSACat(includea, "\"");
          }
          if ( me->object_usemap )
          {
            HTSACat(includea, " USEMAP=\"");
            HTSACat(includea, me->object_usemap);
            if ( me->object_ismap == 1 )
              HTSACat(includea, "\" ISMAP>");
            else
              HTSACat(includea, "\">");
          }
          else
          {
            HTSACat(includea, ">");
          }
          if ( !first_map )
          {
End_Object:
            clear_objectdata(me);
            if ( !LYMapsOnly[0] )
              change_paragraph_style(me, me->sp->style);
            goto LABEL_689;
          }
          if ( !s )
          {
            HTSACat(includea, me->object.data);
            if ( WWW_TraceFlag[0] )
            {
              v41 = TraceFP();
              fprintf(v41, "HTML: MAP found, recycling object contents.\n");
            }
            goto End_Object;
          }
          data = 0;
          if ( last_map >= start )
          {
            if ( last_map >= first_end )
            {
              if ( last_map >= last_end )
              {
                i = 0;
              }
              else
              {
                *last_end = 0;
                i = 1;
              }
            }
            else
            {
              *first_end = 0;
              i = e;
            }
          }
          else
          {
            *start = 0;
            i = 0;
          }
          if ( first_map <= last_end )
          {
            if ( first_map <= start )
              HTSACopy(&data, me->object.data);
            else
              HTSACopy(&data, start);
          }
          else
          {
            HTSACopy(&data, "<OBJECT><");
            HTSACat(&data, last_end + 1);
            i = 0;
          }
          while ( i > 0 )
          {
            HTSACat(&data, "</OBJECT>");
            --i;
          }
          if ( WWW_TraceFlag[0] )
          {
            v42 = data;
            v43 = TraceFP();
            fprintf(v43, "%s:\n%s\n", "HTML: MAP and nested OBJECT tags.  Recycling parts", v42);
          }
          HTSACat(includea, data);
          if ( !data )
            goto End_Object;
        }
        free(data);
        data = 0;
        goto End_Object;
      }
      if ( !me->object_declare
        && !me->object_name
        && (!me->object_shapes || LYMapsOnly[0])
        && (!me->object_usemap || LYMapsOnly[0])
        && (!clickable_images
         || LYMapsOnly[0]
         || !me->object_data
         || have_param
         || me->object_classid
         || me->object_codebase
         || me->object_codetype) )
      {
        if ( WWW_TraceFlag[0] )
        {
          v30 = me->object.data;
          v31 = TraceFP();
          fprintf(v31, "%s:\n%s\n", "HTML: Nested OBJECT tags.  Recycling incomplete contents", v30);
        }
        status = 701;
        --me->object.size;
        HTChunkPuts(&me->object, "</OBJECT>");
        if ( !include )
          includea = &me->xinclude;
        SNACat(includea, me->object.data, me->object.size);
        clear_objectdata(me);
        HTML_start_element(me, 79, 0, 0, me->tag_charset, includea);
      }
      else
      {
        if ( WWW_TraceFlag[0] )
        {
          v32 = TraceFP();
          fprintf(v32, "HTML: Nested OBJECT tags.  Recycling.\n");
        }
        status = 700;
        --me->object.size;
        HTChunkPuts(&me->object, "</OBJECT>");
        if ( !LYMapsOnly[0] )
LABEL_688:
          change_paragraph_style(me, me->sp->style);
      }
LABEL_689:
      if ( reached_awaited_stacked_elt )
        wait_for_this_stacked_elt = -1;
      if ( me->xinclude )
      {
        HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
        HText_appendText(me->text, me->xinclude);
        if ( me->xinclude )
        {
          free(me->xinclude);
          me->xinclude = 0;
        }
      }
      if ( !skip_stack_requested )
      {
        FastTrimColorClass(
          HTML_dtd.tags[element_number].name,
          HTML_dtd.tags[element_number].name_len,
          Style_className,
          &Style_className_end,
          &hcode);
        if ( HTML_dtd.tags[element_number].contents || (HTML_dtd.tags[element_number].flags & 0x10) != 0 )
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
          {
            v50 = HTML_dtd.tags[element_number].name;
            v51 = TraceFP();
            fprintf(v51, "STYLE.end_element: ending non-\"EMPTY\" style <%s...>\n", v50);
          }
          internal_HTC(me->text, hcode, 0);
        }
      }
      return status;
    case 80:
      List_Nesting_Level = me->List_Nesting_Level;
      if ( List_Nesting_Level > 11 )
        List_Nesting_Level = 11;
      me->OL_Counter[List_Nesting_Level] = OL_VOID;
LABEL_292:
      --me->List_Nesting_Level;
      if ( WWW_TraceFlag[0] )
      {
        v26 = me->List_Nesting_Level;
        v27 = TraceFP();
        fprintf(v27, "HTML_end_element: Reducing List Nesting Level to %d\n", v26);
      }
      if ( element_number == 35 )
        in_DT[0] = 0;
      change_paragraph_style(me, me->sp->style);
      if ( me->style_change )
        actually_set_style(me);
      if ( me->List_Nesting_Level >= 0 )
LABEL_299:
        LYEnsureSingleSpace((HTStructured_0 *)me);
      goto LABEL_689;
    case 83:
      LYHandlePlike((HTStructured_0 *)me, 0, 0, include, 0, 0);
      goto LABEL_689;
    case 86:
      HText_appendCharacter(me->text, 10);
      me->inPRE = 0;
LABEL_276:
      if ( me->comment_start )
        HText_appendText(me->text, me->comment_start);
      change_paragraph_style(me, me->sp->style);
      if ( me->List_Nesting_Level < 0 )
        goto LABEL_689;
      if ( me->style_change )
        actually_set_style(me);
LABEL_674:
      HText_NegateLineOne(me->text);
      goto LABEL_689;
    case 87:
      if ( me->Quote_Level > 0 )
        --me->Quote_Level;
      if ( (me->Quote_Level & 1) != 0 )
        HTML_put_character(me, 39);
      else
        HTML_put_character(me, 34);
      goto LABEL_689;
    case 90:
      HTChunkTerminate(&me->script);
      if ( WWW_TraceFlag[0] )
      {
        v20 = me->script.data;
        v21 = TraceFP();
        fprintf(v21, "HTML: SCRIPT content =\n%s\n", v20);
      }
      HTChunkClear(&me->script);
      goto LABEL_689;
    case 91:
      if ( me->inSELECT )
      {
        me->inSELECT = 0;
        me->select_disabled = 0;
        if ( !me->inFORM && LYBadHTML(me) && WWW_TraceFlag[0] )
        {
          v49 = TraceFP();
          fprintf(v49, "Bad HTML: SELECT end tag not within FORM element *****\n");
        }
        HTChunkTerminate(&me->option);
        ptr = HText_setLastOptionValue(
                me->text,
                me->option.data,
                me->LastOptionValue,
                3,
                me->LastOptionChecked,
                me->UCLYhndl,
                me->tag_charset);
        if ( me->LastOptionValue )
        {
          free(me->LastOptionValue);
          me->LastOptionValue = 0;
        }
        me->LastOptionChecked = 0;
        if ( HTCurSelectGroupType != 3 && LYSelectPopups )
        {
          if ( ptr && (me->sp->tag_number == 86 || me->inPRE == 1 || !me->sp->style->freeFormat) && strlen(ptr) > 6 )
          {
            for ( i = 0; i <= 5; ++i )
            {
              if ( *ptr == 32 )
                HText_appendCharacter(me->text, 1);
              else
                HText_appendCharacter(me->text, *ptr);
              ++ptr;
            }
            HText_setIgnoreExcess(me->text, 1);
          }
          while ( ptr && *ptr )
          {
            if ( *ptr == 32 )
            {
              HText_appendCharacter(me->text, 1);
            }
            else
            {
              kcode = NOKANJI;
              specified_kcode = NOKANJI;
              if ( HTCJK == JAPANESE )
              {
                kcode = HText_getKcode(me->text);
                HText_updateKcode(me->text, kanji_code);
                specified_kcode = HText_getSpecifiedKcode(me->text);
                HText_updateSpecifiedKcode(me->text, kanji_code);
              }
              HText_appendCharacter(me->text, *ptr);
              if ( HTCJK == JAPANESE )
              {
                HText_updateKcode(me->text, kcode);
                HText_updateSpecifiedKcode(me->text, specified_kcode);
              }
            }
            ++ptr;
          }
          if ( !me->first_option )
          {
            HText_appendCharacter(me->text, 93);
            HText_endInput(me->text);
            HText_setLastChar(me->text, 93);
            me->in_word = 1;
          }
          HText_setIgnoreExcess(me->text, 0);
        }
        else
        {
          LYEnsureSingleSpace((HTStructured_0 *)me);
        }
        HTChunkClear(&me->option);
        if ( me->Underline_Level > 0 && !me->inUnderline )
        {
          HText_appendCharacter(me->text, 3);
          me->inUnderline = 1;
        }
        if ( me->needBoldH == 1 && !me->inBoldH )
        {
          HText_appendCharacter(me->text, 5);
          me->inBoldH = 1;
          me->needBoldH = 0;
        }
      }
      else if ( LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        v48 = TraceFP();
        fprintf(v48, "Bad HTML: Unmatched SELECT end tag *****\n");
      }
      goto LABEL_689;
    case 98:
      HTChunkTerminate(&me->style_block);
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v18 = me->style_block.data;
        v19 = TraceFP();
        fprintf(v19, "HTML: STYLE content =\n%s\n", v18);
      }
      HTChunkClear(&me->style_block);
      goto LABEL_689;
    case 99:
      HText_appendCharacter(me->text, 93);
      goto LABEL_689;
    case 102:
      if ( !nested_tables )
        me->inTABLE = 0;
      if ( me->sp->style->id != 37 )
      {
        if ( me->Division_Level >= 0 )
          --me->Division_Level;
        if ( me->Division_Level >= 0 )
          me->sp->style->alignment = me->DivisionAlignments[me->Division_Level];
        change_paragraph_style(me, me->sp->style);
        if ( me->style_change )
          actually_set_style(me);
        if ( nested_tables )
          me->inTABLE = HText_endStblTABLE(me->text);
        else
          HText_endStblTABLE(me->text);
        me->current_default_alignment = me->sp->style->alignment;
        if ( me->List_Nesting_Level >= 0 )
          goto LABEL_674;
      }
      goto LABEL_689;
    case 104:
    case 108:
      HText_endStblTD(me->text);
      goto LABEL_689;
    case 105:
      if ( me->inTEXTAREA )
      {
        me->inTEXTAREA = 0;
        memset(&I, 0, sizeof(I));
        I.value_cs = current_char_set;
        if ( me->style_change )
          actually_set_style(me);
        HTML_put_character(me, 32);
        me->in_word = 0;
        HText_appendCharacter(me->text, 13);
        HTChunkTerminate(&me->textarea);
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
        I.type = "textarea";
        I.size = me->textarea_cols;
        I.name = me->textarea_name;
        I.name_cs = me->textarea_name_cs;
        I.accept_cs = me->textarea_accept_cs;
        me->textarea_accept_cs = 0;
        I.disabled = me->textarea_disabled;
        I.id = me->textarea_id;
        me->UsePlainSpace = 1;
        if ( HTML_dtd.tags[element_number].contents == SGML_LITTERAL )
          LYUCTranslateHTMLString(
            &me->textarea.data,
            me->UCLYhndl,
            current_char_set,
            0,
            me->UsePlainSpace,
            me->HiddenValue,
            st_HTML_0);
        else
          LYUCFullyTranslateString(
            &me->textarea.data,
            me->UCLYhndl,
            current_char_set,
            0,
            0,
            me->UsePlainSpace,
            me->HiddenValue,
            0,
            st_HTML_0);
        data_0 = me->textarea.data;
        if ( *data_0 )
        {
          v47 = strlen(data_0);
          for ( cp = &data_0[v47 - 1]; cp >= data_0 && *cp == 10; --cp )
            *cp = 0;
          while ( *data_0 == 10 )
            ++data_0;
        }
        cp = strchr(data_0, 10);
        if ( cp )
        {
          *cp = 0;
          HTSACopy(&temp, data_0);
          *cp = 10;
          data_0 = cp + 1;
        }
        else
        {
          if ( *data_0 )
          {
            HTSACopy(&temp, data_0);
          }
          else if ( temp )
          {
            free(temp);
            temp = 0;
          }
          data_0 = (char *)&actual;
        }
        for ( i = 0; me->textarea_rows > i; ++i )
        {
          for ( j = 0; temp && temp[j]; ++j )
          {
            if ( temp[j] == 13 )
            {
              if ( temp[j + 1] )
                v77 = 32;
              else
                v77 = 0;
              temp[j] = v77;
            }
          }
          I.value = temp;
          for ( chars = HText_beginInput(me->text, me->inUnderline, &I); chars > 0; --chars )
            HTML_put_character(me, 95);
          HText_appendCharacter(me->text, 13);
          if ( *data_0 )
          {
            if ( *data_0 == 10 )
            {
              if ( temp )
              {
                free(temp);
                temp = 0;
              }
              ++data_0;
            }
            else
            {
              cp = strchr(data_0, 10);
              if ( cp )
              {
                *cp = 0;
                HTSACopy(&temp, data_0);
                *cp = 10;
                data_0 = cp + 1;
              }
              else
              {
                HTSACopy(&temp, data_0);
                data_0 = (char *)&actual;
              }
            }
          }
          else if ( temp )
          {
            free(temp);
            temp = 0;
          }
        }
        while ( *data_0 || temp )
        {
          for ( j_0 = 0; temp && temp[j_0]; ++j_0 )
          {
            if ( temp[j_0] == 13 )
            {
              if ( temp[j_0 + 1] )
                v78 = 32;
              else
                v78 = 0;
              temp[j_0] = v78;
            }
          }
          I.value = temp;
          chars = HText_beginInput(me->text, me->inUnderline, &I);
          for ( chars = me->textarea_cols; chars > 0; --chars )
            HTML_put_character(me, 95);
          HText_appendCharacter(me->text, 13);
          if ( *data_0 == 10 )
          {
            if ( temp )
            {
              free(temp);
              temp = 0;
            }
            ++data_0;
          }
          else
          {
            cp = strchr(data_0, 10);
            if ( cp )
            {
              *cp = 0;
              HTSACopy(&temp, data_0);
              *cp = 10;
              data_0 = cp + 1;
            }
            else if ( *data_0 )
            {
              HTSACopy(&temp, data_0);
              data_0 = (char *)&actual;
            }
            else if ( temp )
            {
              free(temp);
              temp = 0;
            }
          }
        }
        cp = 0;
        me->UsePlainSpace = 0;
        HTChunkClear(&me->textarea);
        if ( me->textarea_name )
        {
          free(me->textarea_name);
          me->textarea_name = 0;
        }
        me->textarea_name_cs = -1;
        if ( me->textarea_id )
        {
          free(me->textarea_id);
          me->textarea_id = 0;
        }
      }
      else if ( LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        v46 = TraceFP();
        fprintf(v46, "Bad HTML: Unmatched TEXTAREA end tag\n");
      }
      goto LABEL_689;
    case 110:
      HTChunkTerminate(&me->title);
      HTAnchor_setTitle(me->node_anchor, me->title.data);
      HTChunkClear(&me->title);
      if ( !me->node_anchor->bookmark
        || !*me->node_anchor->bookmark
        || !LYMultiBookmarks && (!bookmark_page || !*bookmark_page || !strcmp(me->node_anchor->bookmark, bookmark_page)) )
      {
        goto LABEL_689;
      }
      if ( !include )
        includea = &me->xinclude;
      i = 0;
      while ( 2 )
      {
        if ( i <= 25 )
        {
          if ( !MBM_A_subbookmark[i] || strcmp(MBM_A_subbookmark[i], me->node_anchor->bookmark) )
          {
            ++i;
            continue;
          }
          HTSACat(includea, "<H2><EM>");
          v53 = gettext("Description:");
          HTSACat(includea, v53);
          HTSACat(includea, "</EM> ");
          if ( MBM_A_subdescript[i] && *MBM_A_subdescript[i] )
          {
            HTSACopy(&temp, MBM_A_subdescript[i]);
          }
          else
          {
            src = gettext("(none)");
            HTSACopy(&temp, src);
          }
          LYEntify(&temp, 1);
          HTSACat(includea, temp);
          HTSACat(includea, "<BR><EM>&nbsp;&nbsp;&nbsp;");
          v54 = gettext("Filepath:");
          HTSACat(includea, v54);
          HTSACat(includea, "</EM> ");
          if ( MBM_A_subbookmark[i] && *MBM_A_subbookmark[i] )
            v69 = MBM_A_subbookmark[i];
          else
            v69 = gettext("(unknown)");
          HTSACopy(&temp, v69);
          LYEntify(&temp, 1);
          HTSACat(includea, temp);
          if ( temp )
          {
            free(temp);
            temp = 0;
          }
          HTSACat(includea, "</H2>");
        }
        break;
      }
      goto LABEL_689;
    case 111:
      HText_endStblTR(me->text);
      if ( !HText_LastLineEmpty(me->text, 0) )
      {
        HText_setLastChar(me->text, 32);
        HText_appendCharacter(me->text, 13);
      }
      me->in_word = 0;
      goto LABEL_689;
    default:
      goto LABEL_688;
  }
}

//----- (080CD7F7) --------------------------------------------------------
int __cdecl HTML_put_entity(HTStructured *me, int entity_number)
{
  if ( entity_number >= (int)HTML_dtd.number_of_entities )
    return -4;
  HTML_put_string(me, p_entity_values[entity_number]);
  return 0;
}

//----- (080CD842) --------------------------------------------------------
void __cdecl HTML_free(HTStructured *me)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  char *data; // ebx
  FILE *v5; // eax
  FILE *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  FILE *v9; // eax
  char *v10; // ebx
  FILE *v11; // eax
  FILE *v12; // eax
  char *v13; // ebx
  FILE *v14; // eax
  char *v15; // [esp+4h] [ebp-34h]
  char *include[2]; // [esp+30h] [ebp-8h] BYREF

  include[0] = 0;
  if ( !LYMapsOnly[0] || me->text )
  {
    if ( me->style_change )
      actually_set_style(me);
    if ( me->comment_end )
      HTML_put_string(me, me->comment_end);
    if ( me->text )
    {
      if ( me->inUnderline )
      {
        HText_appendCharacter(me->text, 4);
        me->inUnderline = 0;
        me->Underline_Level = 0;
        if ( WWW_TraceFlag[0] )
        {
          v1 = TraceFP();
          fprintf(v1, "HTML_free: Ending underline\n");
        }
      }
      if ( me->inA )
      {
        HTML_end_element(me, 0, include);
        me->inA = 0;
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "HTML_free: Ending HTML_A\n");
        }
      }
      if ( me->inFONT )
      {
        HTML_end_element(me, 43, include);
        me->inFONT = 0;
      }
      if ( me->inFORM )
      {
        HTML_end_element(me, 44, include);
        me->inFORM = 0;
      }
      if ( me->option.size > 0 )
      {
        if ( LYBadHTML(me) && WWW_TraceFlag[0] )
        {
          v3 = TraceFP();
          fprintf(v3, "Bad HTML: SELECT or OPTION not ended properly *****\n");
        }
        HTChunkTerminate(&me->option);
        if ( WWW_TraceFlag[0] )
        {
          data = me->option.data;
          v5 = TraceFP();
          fprintf(v5, "HTML_free: ***** leftover option data: %s\n", data);
        }
        HTML_put_string(me, me->option.data);
        HTChunkClear(&me->option);
      }
      if ( me->textarea.size > 0 )
      {
        if ( LYBadHTML(me) && WWW_TraceFlag[0] )
        {
          v6 = TraceFP();
          fprintf(v6, "Bad HTML: TEXTAREA not used properly *****\n");
        }
        HTChunkTerminate(&me->textarea);
        if ( WWW_TraceFlag[0] )
        {
          v7 = me->textarea.data;
          v8 = TraceFP();
          fprintf(v8, "HTML_free: ***** leftover textarea data: %s\n", v7);
        }
        HTML_put_string(me, me->textarea.data);
        HTChunkClear(&me->textarea);
      }
      if ( !dump_output_immediately && HText_sourceAnchors(me->text) <= 0 && HText_HiddenLinkCount(me->text) > 0 )
      {
        HTML_start_element(me, 83, 0, 0, -1, include);
        HTML_put_character(me, 91);
        HTML_start_element(me, 38, 0, 0, -1, include);
        v15 = gettext("Document has only hidden links.  Use the 'l'ist command.");
        HTML_put_string(me, v15);
        HTML_end_element(me, 38, include);
        HTML_put_character(me, 93);
        HTML_end_element(me, 83, include);
      }
      if ( me->xinclude )
      {
        HText_appendText(me->text, " *** LYNX ERROR ***\rUnparsed data:\r");
        HText_appendText(me->text, me->xinclude);
        if ( me->xinclude )
        {
          free(me->xinclude);
          me->xinclude = 0;
        }
      }
      HText_endAppend(me->text);
    }
    if ( me->option.size > 0 )
    {
      if ( LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        v9 = TraceFP();
        fprintf(v9, "Bad HTML: SELECT or OPTION not ended properly *****\n");
      }
      if ( WWW_TraceFlag[0] )
      {
        HTChunkTerminate(&me->option);
        if ( WWW_TraceFlag[0] )
        {
          v10 = me->option.data;
          v11 = TraceFP();
          fprintf(v11, "HTML_free: ***** leftover option data: %s\n", v10);
        }
      }
      HTChunkClear(&me->option);
    }
    if ( me->textarea.size > 0 )
    {
      if ( LYBadHTML(me) && WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "Bad HTML: TEXTAREA not used properly *****\n");
      }
      if ( WWW_TraceFlag[0] )
      {
        HTChunkTerminate(&me->textarea);
        if ( WWW_TraceFlag[0] )
        {
          v13 = me->textarea.data;
          v14 = TraceFP();
          fprintf(v14, "HTML_free: ***** leftover textarea data: %s\n", v13);
        }
      }
      HTChunkClear(&me->textarea);
    }
    if ( me->target )
      me->targetClass._free((HTStream *)me->target);
    if ( me->sp && me->sp->style && me->sp->style->name )
    {
      if ( me->sp->style->id == 1 || me->sp->style->id == 47 || me->sp->style->id == 41 )
      {
        me->sp->style->alignment = 3;
      }
      else if ( me->sp->style->id == 3 || me->sp->style->id == 49 )
      {
        me->sp->style->alignment = 2;
      }
      else
      {
        me->sp->style->alignment = 1;
      }
      styles[86]->alignment = 1;
    }
    if ( me->base_href )
    {
      free(me->base_href);
      me->base_href = 0;
    }
    if ( me->map_address )
    {
      free(me->map_address);
      me->map_address = 0;
    }
    if ( me->LastOptionValue )
    {
      free(me->LastOptionValue);
      me->LastOptionValue = 0;
    }
    clear_objectdata(me);
    if ( me )
      free(me);
  }
  else
  {
    if ( me->base_href )
    {
      free(me->base_href);
      me->base_href = 0;
    }
    if ( me->map_address )
    {
      free(me->map_address);
      me->map_address = 0;
    }
    clear_objectdata(me);
    if ( me->xinclude )
    {
      free(me->xinclude);
      me->xinclude = 0;
    }
    if ( me )
      free(me);
  }
}

//----- (080CE00C) --------------------------------------------------------
void __cdecl HTML_abort(HTStructured *me, HTError e)
{
  FILE *v2; // eax
  char *data; // ebx
  FILE *v4; // eax
  FILE *v5; // eax
  char *v6; // ebx
  FILE *v7; // eax
  char *include[2]; // [esp+20h] [ebp-8h] BYREF

  include[0] = 0;
  if ( me->text )
  {
    if ( me->inUnderline )
    {
      HText_appendCharacter(me->text, 4);
      me->inUnderline = 0;
      me->Underline_Level = 0;
    }
    if ( me->inA )
    {
      HTML_end_element(me, 0, include);
      me->inA = 0;
    }
    if ( me->inFONT )
    {
      HTML_end_element(me, 43, include);
      me->inFONT = 0;
    }
    if ( me->inFORM )
    {
      HTML_end_element(me, 44, include);
      me->inFORM = 0;
    }
    HText_endAppend(me->text);
  }
  if ( me->option.size > 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HTML_abort: SELECT or OPTION not ended properly *****\n");
      HTChunkTerminate(&me->option);
      if ( WWW_TraceFlag[0] )
      {
        data = me->option.data;
        v4 = TraceFP();
        fprintf(v4, "HTML_abort: ***** leftover option data: %s\n", data);
      }
    }
    HTChunkClear(&me->option);
  }
  if ( me->textarea.size > 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "HTML_abort: TEXTAREA not used properly *****\n");
      HTChunkTerminate(&me->textarea);
      if ( WWW_TraceFlag[0] )
      {
        v6 = me->textarea.data;
        v7 = TraceFP();
        fprintf(v7, "HTML_abort: ***** leftover textarea data: %s\n", v6);
      }
    }
    HTChunkClear(&me->textarea);
  }
  if ( me->target )
    me->targetClass._abort((HTStream *)me->target, e);
  if ( me->sp && me->sp->style && me->sp->style->name )
  {
    if ( me->sp->style->id == 1 || me->sp->style->id == 47 || me->sp->style->id == 41 )
    {
      me->sp->style->alignment = 3;
    }
    else if ( me->sp->style->id == 3 || me->sp->style->id == 49 )
    {
      me->sp->style->alignment = 2;
    }
    else
    {
      me->sp->style->alignment = 1;
    }
    styles[86]->alignment = 1;
  }
  if ( me->base_href )
  {
    free(me->base_href);
    me->base_href = 0;
  }
  if ( me->map_address )
  {
    free(me->map_address);
    me->map_address = 0;
  }
  if ( me->textarea_name )
  {
    free(me->textarea_name);
    me->textarea_name = 0;
  }
  if ( me->textarea_accept_cs )
  {
    free(me->textarea_accept_cs);
    me->textarea_accept_cs = 0;
  }
  if ( me->textarea_id )
  {
    free(me->textarea_id);
    me->textarea_id = 0;
  }
  if ( me->LastOptionValue )
  {
    free(me->LastOptionValue);
    me->LastOptionValue = 0;
  }
  if ( me->xinclude )
  {
    free(me->xinclude);
    me->xinclude = 0;
  }
  clear_objectdata(me);
  if ( me )
    free(me);
}

//----- (080CE45A) --------------------------------------------------------
void get_styles()
{
  HTStyle **st; // [esp+14h] [ebp-4h] BYREF

  st = 0;
  styleSheet = DefaultStyle(&st);
  default_style_0 = *st;
  styles[47] = st[41];
  styles[48] = st[42];
  styles[49] = st[43];
  styles[50] = st[44];
  styles[51] = st[45];
  styles[52] = st[46];
  styles[143] = st[47];
  styles[144] = st[48];
  styles[145] = st[49];
  styles[146] = st[1];
  styles[147] = st[2];
  styles[148] = st[3];
  styles[35] = st[22];
  styles[131] = st[23];
  styles[132] = st[24];
  styles[133] = st[25];
  styles[134] = st[26];
  styles[135] = st[27];
  styles[136] = st[28];
  styles[80] = st[8];
  styles[114] = styles[80];
  styles[119] = st[9];
  styles[120] = st[10];
  styles[121] = st[11];
  styles[122] = st[12];
  styles[123] = st[13];
  styles[124] = st[14];
  styles[33] = st[15];
  styles[74] = styles[33];
  styles[125] = st[16];
  styles[126] = st[17];
  styles[127] = st[18];
  styles[128] = st[19];
  styles[129] = st[20];
  styles[130] = st[21];
  styles[36] = st[29];
  styles[137] = st[30];
  styles[138] = st[31];
  styles[139] = st[32];
  styles[140] = st[33];
  styles[141] = st[34];
  styles[142] = st[35];
  styles[3] = st[39];
  styles[9] = st[4];
  styles[16] = st[5];
  styles[19] = st[6];
  styles[42] = st[7];
  styles[78] = st[40];
  styles[117] = st[36];
  styles[85] = styles[117];
  styles[86] = st[37];
  styles[70] = st[38];
}

//----- (080CE740) --------------------------------------------------------
HTStyle *__cdecl LYstyles(int style_number)
{
  if ( !styles[style_number] )
    get_styles();
  return styles[style_number];
}

//----- (080CE765) --------------------------------------------------------
HTStructured *__cdecl HTML_new(HTParentAnchor *anchor, HTFormat format_out, HTStream_0 *stream)
{
  FILE *v3; // eax
  HTAtom *v4; // edx
  LYUCcharset *UCInfoStage; // edx
  HTStream_0 *intermediate; // [esp+20h] [ebp-8h]
  HTStructured_0 *me; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "start HTML_new\n");
  }
  if ( HTAtom_for("text/plain") == format_out || HTAtom_for("www/present") == format_out )
  {
    me = (HTStructured_0 *)calloc(1u, 0x2144u);
    if ( !me )
      outofmem("./HTML.c", "HTML_new");
    get_styles();
    me->isa = &HTMLPresentation;
    me->node_anchor = anchor;
    me->CurrentA = 0;
    me->CurrentANum = 0;
    me->base_href = 0;
    me->map_address = 0;
    HTChunkInit(&me->title, 128);
    HTChunkInit(&me->object, 128);
    me->object_started = 0;
    me->object_declare = 0;
    me->object_shapes = 0;
    me->object_ismap = 0;
    me->object_id = 0;
    me->object_title = 0;
    me->object_data = 0;
    me->object_type = 0;
    me->object_classid = 0;
    me->object_codebase = 0;
    me->object_codetype = 0;
    me->object_usemap = 0;
    me->object_name = 0;
    HTChunkInit(&me->option, 128);
    me->first_option = 1;
    me->LastOptionValue = 0;
    me->LastOptionChecked = 0;
    me->select_disabled = 0;
    HTChunkInit(&me->textarea, 128);
    me->textarea_name = 0;
    me->textarea_name_cs = -1;
    me->textarea_accept_cs = 0;
    me->textarea_cols = 0;
    me->textarea_rows = 4;
    me->textarea_disabled = 0;
    me->textarea_id = 0;
    HTChunkInit(&me->math, 128);
    HTChunkInit(&me->style_block, 128);
    HTChunkInit(&me->script, 128);
    me->text = 0;
    me->style_change = 1;
    me->new_style = default_style_0;
    me->old_style = 0;
    me->current_default_alignment = 1;
    me->sp = &me->stack[799];
    me->skip_stack = 0;
    me->sp->tag_number = -1;
    me->sp->style = default_style_0;
    me->sp->style->alignment = 1;
    me->stack_overrun = 0;
    me->Division_Level = -1;
    me->Underline_Level = 0;
    me->Quote_Level = 0;
    me->UsePlainSpace = 0;
    me->HiddenValue = 0;
    me->lastraw = -1;
    me->List_Nesting_Level = -1;
    LYZero_OL_Counter(me);
    me->Last_OL_Count = 0;
    me->Last_OL_Type = 49;
    me->inA = 0;
    me->inAPPLET = 0;
    me->inAPPLETwithP = 0;
    me->inBadBASE = 0;
    me->inBadHREF = 0;
    me->inBadHTML = 0;
    me->inBASE = 0;
    me->node_anchor->inBASE = 0;
    me->inBoldA = 0;
    me->inBoldH = 0;
    me->inCAPTION = 0;
    me->inCREDIT = 0;
    me->inFIG = 0;
    me->inFIGwithP = 0;
    me->inFONT = 0;
    me->inFORM = 0;
    me->inLABEL = 0;
    me->inP = 0;
    me->inPRE = 0;
    me->inSELECT = 0;
    me->inTABLE = 0;
    me->inUnderline = 0;
    me->needBoldH = 0;
    me->comment_start = 0;
    me->comment_end = 0;
    addClassName(&actual, &actual, 0);
    class_string[0] = 0;
    LYGetChartransInfo(me);
    UCTransParams_clear(&me->T);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 1);
    if ( me->inUCLYhndl >= 0 )
    {
      UCInfoStage = HTAnchor_getUCInfoStage(me->node_anchor, 1);
    }
    else
    {
      me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 0);
      UCInfoStage = HTAnchor_getUCInfoStage(me->node_anchor, 0);
    }
    me->inUCI = UCInfoStage;
    me->outUCI = HTAnchor_getUCInfoStage(me->node_anchor, 2);
    me->outUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 2);
    me->target = (HTStream *)stream;
    if ( stream )
      me->targetClass = *stream->isa;
    return (HTStructured *)me;
  }
  else
  {
    v4 = HTAtom_for("text/html");
    intermediate = (HTStream_0 *)HTStreamStack(v4, format_out, (HTStream_5 *)stream, anchor);
    if ( !intermediate )
    {
      fprintf(stderr, "\n** Internal error: can't parse HTML to %s\n", format_out->name);
      exit_immediately(1);
    }
    return (HTStructured *)HTMLGenerator((HTStream_4 *)intermediate);
  }
}

//----- (080CEDA8) --------------------------------------------------------
void __cdecl CacheThru_do_free(HTStream_0 *me)
{
  char *source_cache_file; // ebx
  FILE *v2; // eax
  HTChunk *source_cache_chunk; // ebx
  FILE *v4; // eax
  char *filename; // ebx
  FILE *v6; // edx
  char *v7; // eax
  HTChunk *chunk; // ebx
  FILE *v9; // eax
  char *v10; // eax
  HTChunk *v11; // ebx
  FILE *v12; // edx
  char *cp_freeme_0; // [esp+1Ch] [ebp-Ch]
  char *cp_freeme; // [esp+20h] [ebp-8h]

  if ( me->anchor->source_cache_file )
  {
    if ( WWW_TraceFlag[0] )
    {
      source_cache_file = me->anchor->source_cache_file;
      v2 = TraceFP();
      fprintf(v2, "SourceCacheWriter: Removing previous file %s\n", source_cache_file);
    }
    LYRemoveTemp(me->anchor->source_cache_file);
    if ( me->anchor->source_cache_file )
    {
      free(me->anchor->source_cache_file);
      me->anchor->source_cache_file = 0;
    }
  }
  if ( me->anchor->source_cache_chunk )
  {
    if ( WWW_TraceFlag[0] )
    {
      source_cache_chunk = me->anchor->source_cache_chunk;
      v4 = TraceFP();
      fprintf(v4, "SourceCacheWriter: Removing previous memory chunk %p\n", source_cache_chunk);
    }
    HTChunkFree(me->anchor->source_cache_chunk);
    me->anchor->source_cache_chunk = 0;
  }
  if ( me->fp )
  {
    fflush(me->fp);
    if ( ferror(me->fp) )
      me->status = -1;
    LYCloseTempFP(me->fp);
    if ( me->status )
    {
      if ( !source_cache_file_error[0] )
      {
        v7 = gettext("Source cache error - disk full?");
        HTAlert(v7);
        source_cache_file_error[0] = 1;
      }
      LYRemoveTemp(me->filename);
      me->anchor->source_cache_file = 0;
    }
    else
    {
      cp_freeme = 0;
      me->anchor->source_cache_file = me->filename;
      if ( WWW_TraceFlag[0] )
      {
        cp_freeme = HTAnchor_address((HTAnchor *)me->anchor);
        filename = me->filename;
        v6 = TraceFP();
        fprintf(v6, "SourceCacheWriter: Committing file %s for URL %s to anchor\n", filename, cp_freeme);
      }
      if ( cp_freeme )
        free(cp_freeme);
    }
  }
  else if ( me->status )
  {
    if ( me->chunk )
    {
      if ( WWW_TraceFlag[0] )
      {
        chunk = me->chunk;
        v9 = TraceFP();
        fprintf(v9, "SourceCacheWriter: memory chunk %p had errors.\n", chunk);
      }
      HTChunkFree(me->chunk);
      me->last_chunk = 0;
      me->chunk = me->last_chunk;
    }
    v10 = gettext("Source cache error - not enough memory!");
    HTAlert(v10);
  }
  if ( me->chunk )
  {
    cp_freeme_0 = 0;
    me->anchor->source_cache_chunk = me->chunk;
    if ( WWW_TraceFlag[0] )
    {
      cp_freeme_0 = HTAnchor_address((HTAnchor *)me->anchor);
      v11 = me->chunk;
      v12 = TraceFP();
      fprintf(v12, "SourceCacheWriter: Committing memory chunk %p for URL %s to anchor\n", v11, cp_freeme_0);
    }
    if ( cp_freeme_0 )
      free(cp_freeme_0);
  }
}

//----- (080CF08D) --------------------------------------------------------
void __cdecl CacheThru_free(HTStream_0 *me)
{
  CacheThru_do_free(me);
  me->actions->_free((HTStream *)me->target);
  if ( me )
    free(me);
}

//----- (080CF0CC) --------------------------------------------------------
void __cdecl CacheThru_abort(HTStream_0 *me, HTError e)
{
  char *filename; // ebx
  FILE *v3; // eax
  HTChunk *chunk; // ebx
  FILE *v5; // eax

  if ( me->fp )
    LYCloseTempFP(me->fp);
  if ( LYCacheSourceForAborted )
  {
    me->status = 0;
    CacheThru_do_free(me);
  }
  else
  {
    if ( me->filename )
    {
      if ( WWW_TraceFlag[0] )
      {
        filename = me->filename;
        v3 = TraceFP();
        fprintf(v3, "SourceCacheWriter: Removing active file %s\n", filename);
      }
      LYRemoveTemp(me->filename);
      if ( me->filename )
      {
        free(me->filename);
        me->filename = 0;
      }
    }
    if ( me->chunk )
    {
      if ( WWW_TraceFlag[0] )
      {
        chunk = me->chunk;
        v5 = TraceFP();
        fprintf(v5, "SourceCacheWriter: Removing active memory chunk %p\n", chunk);
      }
      HTChunkFree(me->chunk);
    }
  }
  me->actions->_abort((HTStream *)me->target, e);
  if ( me )
    free(me);
}

//----- (080CF1F2) --------------------------------------------------------
void __cdecl CacheThru_put_character(HTStream_0 *me, char c_in)
{
  if ( !me->status )
  {
    if ( me->fp )
    {
      fputc(c_in, me->fp);
    }
    else if ( me->chunk )
    {
      me->last_chunk = HTChunkPutc2(me->last_chunk, c_in);
      if ( !me->last_chunk || !me->last_chunk->allocated )
        me->status = -1;
    }
  }
  me->actions->put_character((HTStream *)me->target, c_in);
}

//----- (080CF291) --------------------------------------------------------
void __cdecl CacheThru_put_string(HTStream_0 *me, const char *str)
{
  if ( !me->status )
  {
    if ( me->fp )
    {
      fputs(str, me->fp);
    }
    else if ( me->chunk )
    {
      me->last_chunk = HTChunkPuts2(me->last_chunk, str);
      if ( !me->last_chunk || !me->last_chunk->allocated )
        me->status = -1;
    }
  }
  me->actions->put_string((HTStream *)me->target, str);
}

//----- (080CF327) --------------------------------------------------------
void __cdecl CacheThru_write(HTStream_0 *me, const char *str, int l)
{
  if ( !me->status && l )
  {
    if ( me->fp )
    {
      fwrite(str, 1u, l, me->fp);
      if ( ferror(me->fp) )
        me->status = -1;
    }
    else if ( me->chunk )
    {
      me->last_chunk = HTChunkPutb2(me->last_chunk, str, l);
      if ( !me->last_chunk || !me->last_chunk->allocated )
        me->status = -1;
    }
  }
  me->actions->put_block((HTStream *)me->target, str, l);
}

//----- (080CF404) --------------------------------------------------------
HTStream_0 *__cdecl CacheThru_new(HTParentAnchor *anchor, HTStream_0 *target)
{
  const char *name; // ebx
  FILE *v3; // eax
  FILE *v4; // eax
  char *source_cache_file; // ebx
  FILE *v6; // eax
  FILE *v7; // edx
  FILE *v8; // edx
  HTChunk *source_cache_chunk; // ebx
  FILE *v10; // eax
  HTChunk *chunk; // ebx
  FILE *v12; // edx
  HTProtocol *p; // [esp+24h] [ebp-114h]
  HTStream_0 *stream; // [esp+28h] [ebp-110h]
  char *cp_freeme; // [esp+2Ch] [ebp-10Ch]
  char filename[256]; // [esp+30h] [ebp-108h] BYREF
  unsigned int v19; // [esp+130h] [ebp-8h]

  v19 = __readgsdword(0x14u);
  cp_freeme = 0;
  p = (HTProtocol *)anchor->protocol;
  if ( !LYCacheSource )
    return target;
  if ( strcmp(p->name, "http") && strcmp(p->name, "https") )
  {
    if ( WWW_TraceFlag[0] )
    {
      name = p->name;
      v3 = TraceFP();
      fprintf(v3, "SourceCacheWriter: Protocol is \"%s\"; not cached\n", name);
    }
    return target;
  }
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "start CacheThru_new\n");
  }
  stream = (HTStream_0 *)malloc(0x24u);
  if ( !stream )
    outofmem("./HTML.c", "CacheThru_new");
  stream->isa = &PassThruCache;
  stream->anchor = anchor;
  stream->fp = 0;
  stream->filename = 0;
  stream->chunk = 0;
  stream->target = target;
  stream->actions = target->isa;
  stream->status = 0;
  if ( LYCacheSource == 1 )
  {
    if ( anchor->source_cache_file && WWW_TraceFlag[0] )
    {
      source_cache_file = anchor->source_cache_file;
      v6 = TraceFP();
      fprintf(v6, "SourceCacheWriter: If successful, will replace source cache file %s\n", source_cache_file);
    }
    stream->fp = LYOpenTemp(filename, ".html", "wb");
    if ( !stream->fp )
    {
      if ( WWW_TraceFlag[0] )
      {
        cp_freeme = HTAnchor_address((HTAnchor *)anchor);
        v7 = TraceFP();
        fprintf(v7, "SourceCacheWriter: Cannot open source cache file for URL %s\n", cp_freeme);
      }
      free(stream);
      if ( cp_freeme )
        free(cp_freeme);
      return target;
    }
    HTSACopy(&stream->filename, filename);
    if ( WWW_TraceFlag[0] )
    {
      cp_freeme = HTAnchor_address((HTAnchor *)anchor);
      v8 = TraceFP();
      fprintf(v8, "SourceCacheWriter: Caching source for URL %s in file %s\n", cp_freeme, filename);
    }
    if ( cp_freeme )
    {
      free(cp_freeme);
      cp_freeme = 0;
    }
  }
  if ( LYCacheSource == 2 )
  {
    if ( anchor->source_cache_chunk && WWW_TraceFlag[0] )
    {
      source_cache_chunk = anchor->source_cache_chunk;
      v10 = TraceFP();
      fprintf(v10, "SourceCacheWriter: If successful, will replace memory chunk %p\n", source_cache_chunk);
    }
    stream->last_chunk = HTChunkCreateMayFail(4096, 1);
    stream->chunk = stream->last_chunk;
    if ( !stream->chunk )
      stream->status = -1;
    if ( WWW_TraceFlag[0] )
    {
      chunk = stream->chunk;
      cp_freeme = HTAnchor_address((HTAnchor *)anchor);
      v12 = TraceFP();
      fprintf(v12, "SourceCacheWriter: Caching source for URL %s in memory chunk %p\n", cp_freeme, chunk);
    }
    if ( cp_freeme )
      free(cp_freeme);
  }
  return stream;
}
// 80CF66C: conditional instruction was optimized away because %stream.4!=0

//----- (080CF871) --------------------------------------------------------
HTStream_0 *__cdecl HTMLToPlain(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink)
{
  FILE *v3; // eax
  HTStream_0 *v5; // [esp+4h] [ebp-14h]
  HTStructured *v6; // [esp+8h] [ebp-10h]

  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTMLToPlain calling CacheThru_new\n");
  }
  v6 = HTML_new(anchor, pres->rep_out, sink);
  v5 = (HTStream_0 *)SGML_new(&HTML_dtd, anchor, v6);
  return CacheThru_new(anchor, v5);
}

//----- (080CF8DD) --------------------------------------------------------
HTStream_0 *__cdecl HTMLParsedPresent(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink)
{
  HTAtom *rep_out; // ebx
  HTAtom *v4; // edx
  FILE *v5; // eax
  HTStream_0 *v7; // [esp+4h] [ebp-24h]
  HTStructured *v8; // [esp+8h] [ebp-20h]
  int structured_cset; // [esp+18h] [ebp-10h]
  int old_parser_cset; // [esp+1Ch] [ebp-Ch]
  HTStream_0 *intermediate; // [esp+20h] [ebp-8h]

  intermediate = sink;
  if ( !sink )
  {
    old_parser_cset = HTAnchor_getUCLYhndl(anchor, 1);
    structured_cset = HTAnchor_getUCLYhndl(anchor, 2);
    if ( structured_cset < 0 )
      structured_cset = HTAnchor_getUCLYhndl(anchor, 3);
    if ( structured_cset < 0 )
      structured_cset = current_char_set;
    HTAnchor_setUCInfoStage(anchor, structured_cset, 1, 5);
    if ( pres->rep_out == WWW_SOURCE )
      rep_out = HTAtom_for("www/present");
    else
      rep_out = pres->rep_out;
    v4 = HTAtom_for("text/plain");
    intermediate = (HTStream_0 *)HTStreamStack(v4, rep_out, 0, anchor);
    if ( old_parser_cset != structured_cset )
    {
      HTAnchor_resetUCInfoStage(anchor, old_parser_cset, 1, 0);
      if ( old_parser_cset >= 0 )
        HTAnchor_setUCInfoStage(anchor, old_parser_cset, 1, 2);
    }
  }
  if ( !intermediate )
    return 0;
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "HTMLParsedPresent calling CacheThru_new\n");
  }
  v8 = (HTStructured *)HTMLGenerator((HTStream_4 *)intermediate);
  v7 = (HTStream_0 *)SGML_new(&HTML_dtd, anchor, v8);
  return CacheThru_new(anchor, v7);
}

//----- (080CFAA9) --------------------------------------------------------
HTStream_0 *__cdecl HTMLToC(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink)
{
  FILE *v3; // eax
  HTAtom *v5; // [esp+4h] [ebp-24h]
  HTStream_0 *v6; // [esp+4h] [ebp-24h]
  HTStructured *html; // [esp+24h] [ebp-4h]

  if ( sink )
    sink->isa->put_string((HTStream *)sink, "/* ");
  v5 = HTAtom_for("text/plain");
  html = HTML_new(anchor, v5, sink);
  html->comment_start = "/* ";
  html->comment_end = " */\n";
  if ( !sink )
    HTML_put_string(html, html->comment_start);
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTMLToC calling CacheThru_new\n");
  }
  v6 = (HTStream_0 *)SGML_new(&HTML_dtd, anchor, html);
  return CacheThru_new(anchor, v6);
}

//----- (080CFB79) --------------------------------------------------------
HTStream_0 *__cdecl HTMLPresent(HTPresentation *pres, HTParentAnchor *anchor, HTStream_0 *sink)
{
  FILE *v3; // eax
  HTAtom *v5; // [esp+4h] [ebp-14h]
  HTStream_0 *v6; // [esp+4h] [ebp-14h]
  HTStructured *v7; // [esp+8h] [ebp-10h]

  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTMLPresent calling CacheThru_new\n");
  }
  v5 = HTAtom_for("www/present");
  v7 = HTML_new(anchor, v5, 0);
  v6 = (HTStream_0 *)SGML_new(&HTML_dtd, anchor, v7);
  return CacheThru_new(anchor, v6);
}

//----- (080CFBEC) --------------------------------------------------------
int __cdecl HTLoadError(HTStream_0 *sink, int number, const char *message)
{
  HTAlert(message);
  return -number;
}

//----- (080CFC04) --------------------------------------------------------
char *__cdecl MakeNewTitle(const char **value, int src_type)
{
  char *newtitle; // [esp+10h] [ebp-8h] BYREF
  char *ptr; // [esp+14h] [ebp-4h]

  newtitle = 0;
  HTSACopy(&newtitle, "[");
  if ( value && value[src_type] )
    ptr = strrchr(value[src_type], 47);
  else
    ptr = 0;
  if ( ptr )
    HTSACat(&newtitle, ptr + 1);
  else
    HTSACat(&newtitle, value[src_type]);
  HTSACat(&newtitle, "]");
  return newtitle;
}

//----- (080CFCAF) --------------------------------------------------------
char *__cdecl MakeNewImageValue(const char **value)
{
  char *v2; // [esp+14h] [ebp-14h]
  char *newtitle; // [esp+20h] [ebp-8h] BYREF
  char *ptr; // [esp+24h] [ebp-4h]

  newtitle = 0;
  HTSACopy(&newtitle, "[");
  if ( value[27] )
    v2 = strrchr(value[27], 47);
  else
    v2 = 0;
  ptr = v2;
  if ( v2 )
    HTSACat(&newtitle, ptr + 1);
  else
    HTSACat(&newtitle, value[27]);
  HTSACat(&newtitle, "]-Submit");
  return newtitle;
}

//----- (080CFD51) --------------------------------------------------------
char *__cdecl MakeNewMapValue(const char **value, const char *mapstr)
{
  char *newtitle; // [esp+10h] [ebp-8h] BYREF
  char *ptr; // [esp+14h] [ebp-4h]

  newtitle = 0;
  HTSACopy(&newtitle, "[");
  HTSACat(&newtitle, mapstr);
  if ( verbose_img && value[15] && *value[15] )
  {
    HTSACat(&newtitle, ":");
    ptr = strrchr(value[15], 47);
    if ( ptr )
      HTSACat(&newtitle, ptr + 1);
    else
      HTSACat(&newtitle, value[15]);
  }
  HTSACat(&newtitle, "]");
  return newtitle;
}

//----- (080CFE24) --------------------------------------------------------
void __cdecl HTFWriter_error(HTStream_1 *me, char *id)
{
  int *v2; // eax
  char *v3; // eax
  char buf[200]; // [esp+2Ch] [ebp-CCh] BYREF
  unsigned int v5; // [esp+F4h] [ebp-4h]

  v5 = __readgsdword(0x14u);
  v2 = __errno_location();
  v3 = strerror(*v2);
  sprintf(buf, "%.60s: %.60s: %.60s", id, me->isa->name, v3);
  HTAlert(buf);
}

//----- (080CFEAE) --------------------------------------------------------
void __cdecl HTFWriter_put_character(HTStream_1 *me, char c)
{
  if ( me->fp )
    _IO_putc(c, me->fp);
}

//----- (080CFEDC) --------------------------------------------------------
void __cdecl HTFWriter_put_string(HTStream_1 *me, const char *s)
{
  if ( me->fp )
    fputs(s, me->fp);
}

//----- (080CFF03) --------------------------------------------------------
void __cdecl HTFWriter_write(HTStream_1 *me, const char *s, int l)
{
  if ( me->fp )
  {
    if ( l != fwrite(s, 1u, l, me->fp) )
      HTFWriter_error(me, "HTFWriter_write");
  }
}

//----- (080CFF57) --------------------------------------------------------
void __cdecl HTFWriter_free(HTStream_1 *me)
{
  HTAtom *input_format; // ebx
  char *v2; // eax
  char *v3; // ebx
  char *v4; // eax
  HTAtom *output_format; // ebx
  char *addr; // [esp+24h] [ebp-14h] BYREF
  char *path; // [esp+28h] [ebp-10h] BYREF
  int len; // [esp+2Ch] [ebp-Ch]
  BOOLEAN skip_loadfile; // [esp+31h] [ebp-7h]
  BOOLEAN found; // [esp+32h] [ebp-6h]
  BOOLEAN use_zread; // [esp+33h] [ebp-5h]

  path = 0;
  addr = 0;
  use_zread = 0;
  found = 0;
  if ( me->fp )
    fflush(me->fp);
  if ( me->end_command )
  {
    LYCloseTempFP(me->fp);
    input_format = me->input_format;
    if ( input_format == HTAtom_for("www/compressed") )
    {
      if ( me->anchor->FileCache )
      {
        skip_loadfile = me->viewer_command != 0;
        HTSACopy(&path, me->anchor->FileCache);
        len = strlen(path);
        if ( len <= 3 || strcasecomp(&path[len - 2], "gz") && strcasecomp(&path[len - 2], "zz") )
        {
          if ( len <= 4 || strcasecomp(&path[len - 3], "bz2") )
          {
            if ( len > 2 && !strcasecomp(&path[len - 1], "Z") )
            {
              path[len - 2] = 0;
              remove(path);
            }
          }
          else
          {
            path[len - 4] = 0;
            remove(path);
          }
        }
        else if ( skip_loadfile )
        {
          path[len - 3] = 0;
          remove(path);
        }
        else
        {
          use_zread = 1;
        }
        if ( !use_zread )
        {
          if ( !dump_output_immediately )
          {
            mustshow[0] = 1;
            HTProgress(me->end_command);
          }
          if ( me->end_command && *me->end_command )
            LYSystem(me->end_command);
          found = LYCanReadFile(me->anchor->FileCache);
        }
        if ( found )
        {
          if ( !dump_output_immediately )
          {
            lynx_force_repaint();
            LYrefresh();
          }
          v2 = gettext("Error uncompressing temporary file!");
          HTAlert(v2);
          LYRemoveTemp(me->anchor->FileCache);
          if ( me->anchor->FileCache )
          {
            free(me->anchor->FileCache);
            me->anchor->FileCache = 0;
          }
        }
        else
        {
          LYLocalFileToURL(&addr, path);
          if ( !use_zread )
          {
            LYRenamedTemp(me->anchor->FileCache, path);
            HTSACopy(&me->anchor->FileCache, path);
            HTSACopy(&me->anchor->content_encoding, "binary");
          }
          if ( path )
          {
            free(path);
            path = 0;
          }
          if ( !skip_loadfile )
          {
            if ( HTAnchor_getUCLYhndl(me->anchor, 1) < 0 )
              HTAnchor_copyUCInfoStage(me->anchor, 1, 0, 2);
            HTAnchor_copyUCInfoStage(me->anchor, 1, 0, -1);
          }
          if ( !dump_output_immediately )
          {
            v3 = addr;
            v4 = gettext("Using %s");
            LYstore_message2(v4, v3);
          }
          if ( skip_loadfile )
          {
            if ( me->end_command )
            {
              free(me->end_command);
              me->end_command = 0;
            }
            HTAddParam(&me->end_command, me->viewer_command, 1, me->anchor->FileCache);
            HTEndParam(&me->end_command, me->viewer_command, 1);
            if ( !dump_output_immediately )
            {
              HTProgress(me->end_command);
              stop_curses();
            }
            LYSystem(me->end_command);
            if ( me->remove_command )
            {
              free(me->remove_command);
              me->remove_command = 0;
            }
            if ( !dump_output_immediately )
              start_curses();
          }
          else
          {
            HTLoadFile(addr, me->anchor, me->output_format, (HTStream *)me->sink);
          }
          if ( dump_output_immediately )
          {
            output_format = me->output_format;
            if ( output_format == HTAtom_for("www/present") )
            {
              if ( addr )
              {
                free(addr);
                addr = 0;
              }
              remove(me->anchor->FileCache);
              if ( me->anchor->FileCache )
              {
                free(me->anchor->FileCache);
                me->anchor->FileCache = 0;
              }
              if ( me->remove_command )
              {
                free(me->remove_command);
                me->remove_command = 0;
              }
              if ( me->end_command )
              {
                free(me->end_command);
                me->end_command = 0;
              }
              if ( me->viewer_command )
              {
                free(me->viewer_command);
                me->viewer_command = 0;
              }
              if ( me )
                goto LABEL_92;
              return;
            }
          }
        }
        if ( addr )
        {
          free(addr);
          addr = 0;
        }
      }
      if ( me->remove_command )
      {
        free(me->remove_command);
        me->remove_command = 0;
      }
      goto LABEL_79;
    }
    if ( !strcmp(me->end_command, "SaveToFile") )
    {
      if ( me->remove_command )
      {
        free(me->remove_command);
        me->remove_command = 0;
      }
      if ( dump_output_immediately )
        goto LABEL_79;
    }
    else
    {
      if ( !dump_output_immediately )
      {
        mustshow[0] = 1;
        HTProgress(me->end_command);
        stop_curses();
      }
      LYSystem(me->end_command);
      if ( me->remove_command )
      {
        free(me->remove_command);
        me->remove_command = 0;
      }
      if ( dump_output_immediately )
        goto LABEL_79;
    }
    start_curses();
LABEL_79:
    if ( me->end_command )
    {
      free(me->end_command);
      me->end_command = 0;
    }
  }
  if ( me->viewer_command )
  {
    free(me->viewer_command);
    me->viewer_command = 0;
  }
  if ( dump_output_immediately )
  {
    if ( me->anchor->FileCache )
      remove(me->anchor->FileCache);
    if ( me )
      free(me);
    if ( persistent_cookies[0] )
      LYStoreCookies(LYCookieSaveFile);
    exit_immediately(0);
  }
  if ( me )
LABEL_92:
    free(me);
}

//----- (080D06D0) --------------------------------------------------------
void __cdecl HTFWriter_abort(HTStream_1 *me, HTError e)
{
  FILE *v2; // eax
  FILE *v3; // eax
  int *v4; // eax
  char *v5; // esi
  char *remove_command; // ebx
  char *v7; // eax
  char buf[560]; // [esp+2Ch] [ebp-23Ch] BYREF
  unsigned int v9; // [esp+25Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "HTFWriter_abort called\n");
  }
  LYCloseTempFP(me->fp);
  if ( me->viewer_command )
  {
    free(me->viewer_command);
    me->viewer_command = 0;
  }
  if ( me->end_command )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "HTFWriter: Aborting: file not executed or saved.\n");
    }
    if ( me->end_command )
    {
      free(me->end_command);
      me->end_command = 0;
    }
    if ( me->remove_command )
    {
      chmod(me->remove_command, 0x180u);
      if ( unlink(me->remove_command) )
      {
        v4 = __errno_location();
        v5 = strerror(*v4);
        remove_command = me->remove_command;
        v7 = gettext("Error deleting file");
        sprintf(buf, "%.60s '%.400s': %.60s", v7, remove_command, v5);
        HTAlert(buf);
      }
      if ( me->remove_command )
      {
        free(me->remove_command);
        me->remove_command = 0;
      }
    }
  }
  if ( WWW_Download_File )
  {
    free(WWW_Download_File);
    WWW_Download_File = 0;
  }
  if ( me )
    free(me);
}

//----- (080D08D0) --------------------------------------------------------
HTStream_1 *__cdecl HTFWriter_new(FILE *fp)
{
  HTStream_1 *me; // [esp+24h] [ebp-4h]

  if ( !fp )
    return 0;
  me = (HTStream_1 *)calloc(1u, 0x24u);
  if ( !me )
    outofmem("./HTFWriter.c", "HTFWriter_new");
  me->isa = &HTFWriter;
  me->fp = fp;
  me->end_command = 0;
  me->remove_command = 0;
  me->anchor = 0;
  me->sink = 0;
  return me;
}

//----- (080D095B) --------------------------------------------------------
char *__cdecl mailcap_substitute(HTParentAnchor *anchor, HTPresentation *pres, char *fnam)
{
  char *prepend; // [esp+20h] [ebp-8h] BYREF
  char *result; // [esp+24h] [ebp-4h]

  result = LYMakeMailcapCommand(pres->command, anchor->content_type_params, fnam);
  if ( !LYMailcapUsesPctS(pres->command) )
  {
    prepend = 0;
    HTSprintf(&prepend, "( %s", result);
    HTAddParam(&prepend, "( %s ) < %s", 2, fnam);
    if ( result )
    {
      free(result);
      result = 0;
    }
    return prepend;
  }
  return result;
}

//----- (080D0A01) --------------------------------------------------------
HTStream_1 *__cdecl HTSaveAndExecute(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink)
{
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v6; // eax
  char *buf; // [esp+24h] [ebp-114h] BYREF
  HTStream_1 *me; // [esp+28h] [ebp-110h]
  const char *suffix; // [esp+2Ch] [ebp-10Ch]
  char fnam[256]; // [esp+30h] [ebp-108h] BYREF
  unsigned int v13; // [esp+130h] [ebp-8h]

  v13 = __readgsdword(0x14u);
  if ( traversal )
  {
    LYCancelledFetch = 1;
    return 0;
  }
  else
  {
    if ( pres->quality < 999.0 )
      goto LABEL_15;
    if ( dump_output_immediately )
    {
      LYCancelledFetch = 1;
      return 0;
    }
    if ( no_exec )
    {
      v3 = gettext("Execution is disabled.");
      HTAlert(v3);
      return (HTStream_1 *)HTPlainPresent(pres, anchor, (HTStream_3 *)sink);
    }
    if ( local_exec
      || local_exec_on_local_files && (LYJumpFileURL || !strncmp(anchor->address, "file://localhost", 0x10u)) )
    {
LABEL_15:
      if ( dump_output_immediately )
      {
        return HTSaveToFile(pres, anchor, sink);
      }
      else
      {
        me = (HTStream_1 *)calloc(1u, 0x24u);
        if ( !me )
          outofmem("./HTFWriter.c", "HTSaveAndExecute");
        me->isa = &HTFWriter;
        me->input_format = pres->rep;
        me->output_format = pres->rep_out;
        me->anchor = anchor;
        me->sink = sink;
        if ( LYCachedTemp(fnam, &anchor->FileCache) )
        {
          me->fp = LYOpenTempRewrite(fnam, ".bin", "wb");
        }
        else
        {
          if ( strcasecomp(pres->rep->name, "text/html") )
          {
            if ( strncasecomp(pres->rep->name, "text/", 5) )
            {
              suffix = HTFileSuffix(pres->rep, anchor->content_encoding);
              if ( !suffix || *suffix != 46 )
              {
                if ( strncasecomp(pres->rep->name, "application/", 12) )
                  suffix = ".html";
                else
                  suffix = ".bin";
              }
            }
            else
            {
              suffix = ".txt";
            }
          }
          else
          {
            suffix = ".html";
          }
          me->fp = LYOpenTemp(fnam, suffix, "wb");
        }
        if ( me->fp )
        {
          HTSACopy(&me->viewer_command, pres->command);
          me->end_command = mailcap_substitute(anchor, pres, fnam);
          me->remove_command = 0;
          HTAddParam(&me->remove_command, "%s", 1, fnam);
          HTEndParam(&me->remove_command, "%s", 1);
          HTSACopy(&anchor->FileCache, fnam);
          return me;
        }
        else
        {
          v6 = gettext("Can't open temporary file!");
          HTAlert(v6);
          if ( me )
          {
            free(me);
            me = 0;
          }
          return 0;
        }
      }
    }
    else
    {
      buf = 0;
      v4 = key_for_func(49);
      v5 = gettext("Execution is not enabled for this file.  See the Options menu (use %s).");
      HTSprintf0(&buf, v5, v4);
      HTAlert(buf);
      if ( buf )
      {
        free(buf);
        buf = 0;
      }
      return (HTStream_1 *)HTPlainPresent(pres, anchor, (HTStream_3 *)sink);
    }
  }
}

//----- (080D0F0B) --------------------------------------------------------
HTStream_1 *__cdecl HTSaveToFile(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink)
{
  char *v3; // eax
  char *name; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char *address; // [esp+14h] [ebp-134h]
  char *temp; // [esp+28h] [ebp-120h] BYREF
  int c; // [esp+2Ch] [ebp-11Ch]
  char *cp; // [esp+30h] [ebp-118h]
  const char *suffix; // [esp+34h] [ebp-114h]
  HTStream_1 *ret_obj; // [esp+38h] [ebp-110h]
  BOOLEAN IsBinary; // [esp+3Fh] [ebp-109h]
  char fnam[256]; // [esp+40h] [ebp-108h] BYREF
  unsigned int v22; // [esp+140h] [ebp-8h]

  v22 = __readgsdword(0x14u);
  c = 0;
  IsBinary = 1;
  ret_obj = (HTStream_1 *)calloc(1u, 0x24u);
  if ( !ret_obj )
    outofmem("./HTFWriter.c", "HTSaveToFile");
  ret_obj->isa = &HTFWriter;
  ret_obj->remove_command = 0;
  ret_obj->end_command = 0;
  ret_obj->input_format = pres->rep;
  ret_obj->output_format = pres->rep_out;
  ret_obj->anchor = anchor;
  ret_obj->sink = sink;
  if ( dump_output_immediately )
  {
    ret_obj->fp = stdout;
    if ( HTAtom_for("www/download") != HTOutputFormat )
      return ret_obj;
    goto Prepend_BASE;
  }
  LYCancelDownload[0] = 0;
  if ( HTAtom_for("www/download") == HTOutputFormat )
    goto LABEL_48;
  if ( traversal || no_download && !override_no_download && no_disk_save )
  {
    if ( !traversal )
    {
      v3 = gettext("This file cannot be displayed on this terminal.");
      HTAlert(v3);
    }
    LYCancelDownload[0] = 1;
    if ( traversal )
      LYCancelledFetch = 1;
    if ( ret_obj )
    {
      free(ret_obj);
      ret_obj = 0;
    }
    return 0;
  }
  cp = strchr(pres->rep->name, 59);
  if ( cp && strstr(cp + 1, "charset") || *pres->rep->name )
  {
    mustshow[0] = 1;
    name = pres->rep->name;
    v5 = gettext("%s  D)ownload, or C)ancel");
    user_message(v5, name);
  }
  else
  {
    mustshow[0] = 1;
    v6 = gettext("This file cannot be displayed on this terminal:  D)ownload, or C)ancel");
    statusline(v6);
  }
  while ( c != 68 && c != 67 && c != 3 && c != 7 )
  {
    if ( c == -1 )
    {
      if ( keymap[0] == 47 )
        break;
    }
    else if ( (c & 0x8800) != 0 )
    {
      if ( (unsigned __int8)c == 47 )
        break;
    }
    else if ( keymap[(c & 0x7FF) + 1] == 47 )
    {
      break;
    }
    c = LYgetch_single();
  }
  if ( c == 67 || c == 3 || c == 7 )
    goto LABEL_45;
  if ( c == -1 )
  {
    if ( keymap[0] != 47 )
      goto LABEL_48;
LABEL_45:
    mustshow[0] = 1;
    v7 = gettext("Cancelling file.");
    statusline(v7);
    LYCancelDownload[0] = 1;
    if ( ret_obj )
    {
      free(ret_obj);
      ret_obj = 0;
    }
    return 0;
  }
  if ( (c & 0x8800) != 0 )
  {
    if ( (unsigned __int8)c != 47 )
      goto LABEL_48;
    goto LABEL_45;
  }
  if ( keymap[(c & 0x7FF) + 1] == 47 )
    goto LABEL_45;
LABEL_48:
  if ( LYCachedTemp(fnam, &anchor->FileCache) )
  {
    ret_obj->fp = LYOpenTempRewrite(fnam, ".bin", "wb");
  }
  else
  {
    if ( strcasecomp(pres->rep->name, "text/html") )
    {
      if ( strncasecomp(pres->rep->name, "text/", 5) )
      {
        if ( strncasecomp(pres->rep->name, "application/", 12) )
        {
          suffix = HTFileSuffix(pres->rep, anchor->content_encoding);
          if ( !suffix || *suffix != 46 )
            suffix = ".html";
        }
        else
        {
          suffix = ".bin";
        }
      }
      else
      {
        suffix = ".txt";
      }
    }
    else
    {
      suffix = ".html";
    }
    ret_obj->fp = LYOpenTemp(fnam, suffix, "wb");
  }
  if ( ret_obj->fp )
  {
    if ( !strncasecomp(pres->rep->name, "text/", 5)
      || !strcasecomp(pres->rep->name, "application/postscript")
      || !strcasecomp(pres->rep->name, "application/x-RUNOFF-MANUAL") )
    {
      IsBinary = 0;
    }
    v9 = pres->rep->name;
    v10 = gettext("Content-type: %s");
    HTInfoMsg2(v10, v9);
    HTSACopy(&WWW_Download_File, fnam);
    ret_obj->remove_command = 0;
    HTAddParam(&ret_obj->remove_command, "%s", 1, fnam);
    HTEndParam(&ret_obj->remove_command, "%s", 1);
    HTSACopy(&ret_obj->end_command, "SaveToFile");
    mustshow[0] = 1;
    v11 = gettext("Retrieving file.  - PLEASE WAIT -");
    statusline(v11);
    HTSACopy(&anchor->FileCache, fnam);
Prepend_BASE:
    if ( LYPrependBaseToSource && !strncasecomp(pres->rep->name, "text/html", 9) && !anchor->content_encoding )
    {
      temp = 0;
      if ( anchor->content_base && *anchor->content_base )
      {
        HTSACopy(&temp, anchor->content_base);
      }
      else if ( anchor->content_location && *anchor->content_location )
      {
        HTSACopy(&temp, anchor->content_location);
      }
      if ( temp )
      {
        LYRemoveBlanks(temp);
        if ( is_url(temp) == NOT_A_URL_TYPE_0 )
        {
          if ( temp )
          {
            free(temp);
            temp = 0;
          }
        }
      }
      fprintf(ret_obj->fp, "<!-- X-URL: %s -->\n", anchor->address);
      if ( anchor->date )
      {
        if ( *anchor->date )
        {
          fprintf(ret_obj->fp, "<!-- Date: %s -->\n", anchor->date);
          if ( anchor->last_modified )
          {
            if ( *anchor->last_modified
              && strcmp(anchor->last_modified, anchor->date)
              && strcmp(anchor->last_modified, "Thu, 01 Jan 1970 00:00:01 GMT") )
            {
              fprintf(ret_obj->fp, "<!-- Last-Modified: %s -->\n", anchor->last_modified);
            }
          }
        }
      }
      if ( temp )
        address = temp;
      else
        address = anchor->address;
      fprintf(ret_obj->fp, "<BASE HREF=\"%s\">\n\n", address);
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
    }
    if ( LYPrependCharsetToSource && !strncasecomp(pres->rep->name, "text/html", 9) && !anchor->content_encoding )
    {
      temp = 0;
      if ( anchor->charset && *anchor->charset )
      {
        HTSACopy(&temp, anchor->charset);
        LYRemoveBlanks(temp);
        fprintf(ret_obj->fp, "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=%s\">\n\n", temp);
      }
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
    }
    return ret_obj;
  }
  v8 = gettext("Can't open output file!  Cancelling!");
  HTAlert(v8);
  if ( ret_obj )
  {
    free(ret_obj);
    ret_obj = 0;
  }
  return 0;
}

//----- (080D199D) --------------------------------------------------------
HTStream_1 *__cdecl HTCompressed(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink)
{
  HTAtom *rep_out; // ebx
  HTAtom *v4; // eax
  size_t v5; // eax
  FILE *v6; // eax
  char *v7; // eax
  CompressFileType v10; // [esp+24h] [ebp-254h]
  const char *program; // [esp+3Ch] [ebp-23Ch]
  const char *programa; // [esp+3Ch] [ebp-23Ch]
  const char *programb; // [esp+3Ch] [ebp-23Ch]
  const char *programc; // [esp+3Ch] [ebp-23Ch]
  const char *middle; // [esp+40h] [ebp-238h]
  const char *compress_suffix; // [esp+44h] [ebp-234h]
  char *uncompress_mask; // [esp+48h] [ebp-230h] BYREF
  const char *suffix; // [esp+4Ch] [ebp-22Ch]
  int i; // [esp+50h] [ebp-228h]
  int n; // [esp+54h] [ebp-224h]
  HTPresentation *Pnow; // [esp+58h] [ebp-220h]
  HTPresentation *Pres; // [esp+5Ch] [ebp-21Ch]
  char *type; // [esp+60h] [ebp-218h] BYREF
  HTFormat format; // [esp+64h] [ebp-214h]
  HTStream_1 *me; // [esp+68h] [ebp-210h]
  BOOLEAN can_present; // [esp+6Fh] [ebp-209h]
  char temp[256]; // [esp+70h] [ebp-208h] BYREF
  char fnam[256]; // [esp+170h] [ebp-108h] BYREF
  unsigned int v29; // [esp+270h] [ebp-8h]

  v29 = __readgsdword(0x14u);
  type = 0;
  Pres = 0;
  Pnow = 0;
  can_present = 0;
  uncompress_mask = 0;
  compress_suffix = &byte_81673EB;
  if ( !anchor || !anchor->content_encoding || !anchor->content_type )
  {
    format = HTAtom_for("application/octet-stream");
    return (HTStream_1 *)HTStreamStack(format, pres->rep_out, (HTStream_5 *)sink, anchor);
  }
  n = HTList_count(HTPresentations);
  for ( i = 0; i < n; ++i )
  {
    Pnow = (HTPresentation *)HTList_objectAt(HTPresentations, i);
    if ( !strcasecomp(Pnow->rep->name, anchor->content_type) )
    {
      rep_out = Pnow->rep_out;
      if ( rep_out == HTAtom_for("www/present") )
      {
        if ( Pres )
        {
          if ( Pres->quality > (long double)Pnow->quality )
            continue;
          Pres = Pnow;
        }
        else
        {
          Pres = Pnow;
        }
        can_present = 1;
        v10 = HTEncodingToCompressType(anchor->content_encoding);
        if ( v10 == cftGzip )
        {
          program = HTGetProgramPath(ppGZIP_0);
          if ( program )
          {
            HTSACopy(&uncompress_mask, program);
            HTSACat(&uncompress_mask, " -d --no-name %s");
            compress_suffix = "gz";
          }
        }
        else if ( (unsigned int)v10 > cftGzip )
        {
          if ( v10 == cftBzip2 )
          {
            programb = HTGetProgramPath(ppBZIP2_0);
            if ( programb )
            {
              HTSACopy(&uncompress_mask, programb);
              HTSACat(&uncompress_mask, " -d %s");
              compress_suffix = "bz2";
            }
          }
          else if ( v10 == cftDeflate )
          {
            programa = HTGetProgramPath(ppINFLATE_0);
            if ( programa )
            {
              HTSACopy(&uncompress_mask, programa);
              HTSACat(&uncompress_mask, " %s");
              compress_suffix = "zz";
            }
          }
        }
        else if ( v10 == cftCompress )
        {
          programc = HTGetProgramPath(ppUNCOMPRESS_0);
          if ( programc )
          {
            HTSACopy(&uncompress_mask, programc);
            HTSACat(&uncompress_mask, " %s");
            compress_suffix = "Z";
          }
        }
      }
    }
  }
  if ( !can_present
    || !uncompress_mask
    || strchr(anchor->content_type, 59)
    || HTAtom_for("www/download") == HTOutputFormat
    || !strcasecomp(pres->rep_out->name, "www/download")
    || traversal && strcasecomp(anchor->content_type, "text/html") && strcasecomp(anchor->content_type, "text/plain") )
  {
    if ( strchr(anchor->content_encoding, 47) )
    {
      HTSACopy(&type, anchor->content_encoding);
    }
    else
    {
      if ( strncasecomp(anchor->content_encoding, "x-", 2) )
        HTSACopy(&type, "application/x-");
      else
        HTSACopy(&type, "application/");
      HTSACat(&type, anchor->content_encoding);
    }
    format = HTAtom_for(type);
    if ( type )
    {
      free(type);
      type = 0;
    }
    if ( uncompress_mask )
    {
      free(uncompress_mask);
      uncompress_mask = 0;
    }
    return (HTStream_1 *)HTStreamStack(format, pres->rep_out, (HTStream_5 *)sink, anchor);
  }
  else
  {
    me = (HTStream_1 *)calloc(1u, 0x24u);
    if ( !me )
      outofmem("./HTFWriter.c", "HTCompressed");
    me->isa = &HTFWriter;
    me->input_format = pres->rep;
    me->output_format = pres->rep_out;
    me->anchor = anchor;
    me->sink = sink;
    if ( anchor->FileCache )
    {
      LYRemoveTemp(anchor->FileCache);
      if ( anchor->FileCache )
      {
        free(anchor->FileCache);
        anchor->FileCache = 0;
      }
    }
    middle = 0;
    if ( strcasecomp(anchor->content_type, "text/html") )
    {
      if ( strncasecomp(anchor->content_type, "text/", 5) )
      {
        if ( strncasecomp(anchor->content_type, "application/", 12) )
        {
          v4 = HTAtom_for(anchor->content_type);
          suffix = HTFileSuffix(v4, 0);
          if ( suffix && *suffix == 46 )
            middle = suffix + 1;
        }
        else
        {
          middle = ".bin" + 1;
        }
      }
      else
      {
        middle = ".txt" + 1;
      }
    }
    else
    {
      middle = "html";
    }
    temp[0] = 0;
    if ( middle )
    {
      v5 = strlen(temp);
      memcpy(&temp[v5], ".", 2u);
      strcat(temp, middle);
      strcat(temp, ".");
    }
    strcat(temp, compress_suffix);
    v6 = LYOpenTemp(fnam, temp, "wb");
    me->fp = v6;
    if ( me->fp )
    {
      if ( !dump_output_immediately
        && !traversal
        && (Pres->quality < 999.0
         || !no_exec
         && (local_exec
          || local_exec_on_local_files && (LYJumpFileURL || !strncmp(anchor->address, "file://localhost", 0x10u)))) )
      {
        HTSACopy(&me->viewer_command, Pres->command);
      }
      if ( *compress_suffix != 103 || me->viewer_command )
      {
        me->end_command = 0;
        HTAddParam(&me->end_command, uncompress_mask, 1, fnam);
        HTEndParam(&me->end_command, uncompress_mask, 1);
      }
      else
      {
        HTSACopy(&me->end_command, &byte_81673EB);
      }
      if ( uncompress_mask )
      {
        free(uncompress_mask);
        uncompress_mask = 0;
      }
      me->remove_command = 0;
      HTAddParam(&me->remove_command, "%s", 1, fnam);
      HTEndParam(&me->remove_command, "%s", 1);
      HTSACopy(&anchor->FileCache, fnam);
      return me;
    }
    else
    {
      v7 = gettext("Can't open temporary file!");
      HTAlert(v7);
      if ( uncompress_mask )
      {
        free(uncompress_mask);
        uncompress_mask = 0;
      }
      if ( me )
      {
        free(me);
        me = 0;
      }
      return 0;
    }
  }
}

//----- (080D2408) --------------------------------------------------------
HTStream_1 *__cdecl HTDumpToStdout(HTPresentation *pres, HTParentAnchor *anchor, HTStream_1 *sink)
{
  HTStream_1 *ret_obj; // [esp+14h] [ebp-4h]

  ret_obj = (HTStream_1 *)calloc(1u, 0x24u);
  if ( !ret_obj )
    outofmem("./HTFWriter.c", "HTDumpToStdout");
  ret_obj->isa = &HTFWriter;
  ret_obj->remove_command = 0;
  ret_obj->end_command = 0;
  ret_obj->anchor = anchor;
  ret_obj->fp = stdout;
  return ret_obj;
}

//----- (080D2478) --------------------------------------------------------
void HTFormatInit()
{
  FILE *v0; // eax
  char *v1; // eax
  HTAtom *v2; // ebx
  HTAtom *v3; // eax
  HTAtom *v4; // ebx
  HTAtom *v5; // eax

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v0 = TraceFP();
    fprintf(v0, "HTFormatInit\n");
  }
  if ( LYgetXDisplay() )
  {
    HTSetPresentation("application/postscript", "ghostview %s&", 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
    if ( XLoadImageCommand && *XLoadImageCommand )
    {
      HTSetPresentation("image/gif", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/x-xbm", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/x-xbitmap", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/x-png", XLoadImageCommand, 0, 2.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/png", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/x-rgb", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/x-tiff", XLoadImageCommand, 0, 2.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/tiff", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
      HTSetPresentation("image/jpeg", XLoadImageCommand, 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
    }
    HTSetPresentation("video/mpeg", "mpeg_play %s &", 0, 1.0, 3.0, 0.0, 0, mediaEXT_0);
  }
  HTSetPresentation("application/x-csh", "csh %s", 0, 999.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetPresentation("application/x-sh", "sh %s", 0, 999.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetPresentation("application/x-ksh", "ksh %s", 0, 999.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetConversion("message/x-http-redirection", "*", (HTConverter *)HTMIMERedirect, 2.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion(
    "message/x-http-redirection",
    "www/present",
    (HTConverter *)HTMIMERedirect,
    2.0,
    0.0,
    0.0,
    0,
    mediaINT_0);
  HTSetConversion(
    "message/x-http-redirection",
    "www/debug",
    (HTConverter *)HTMIMERedirect,
    1.0,
    0.0,
    0.0,
    0,
    mediaINT_0);
  HTSetConversion("www/mime", "www/present", (HTConverter *)HTMIMEConvert, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/mime", "www/download", (HTConverter *)HTMIMEConvert, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/mime", "www/source", (HTConverter *)HTMIMEConvert, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/mime", "www/dump", (HTConverter *)HTMIMEConvert, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/compressed", "www/download", (HTConverter *)HTCompressed, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/compressed", "www/present", (HTConverter *)HTCompressed, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/compressed", "www/source", (HTConverter *)HTCompressed, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/compressed", "www/dump", (HTConverter *)HTCompressed, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("application/html", "text/x-c", HTMLToC, 0.5, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("application/html", "text/plain", HTMLToPlain, 0.5, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/css", "text/plain", HTMLToPlain, 0.5, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("application/html", "www/present", HTMLPresent, 2.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("application/xhtml+xml", "www/present", HTMLPresent, 2.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("application/xml", "www/present", HTMLPresent, 2.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("application/html", "www/source", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion(
    "application/x-wais-source",
    "www/source",
    (HTConverter *)HTPlainPresent,
    1.0,
    0.0,
    0.0,
    0,
    mediaINT_0);
  HTSetConversion(
    "application/x-wais-source",
    "www/present",
    (HTConverter *)HTWSRCConvert,
    2.0,
    0.0,
    0.0,
    0,
    mediaINT_0);
  HTSetConversion(
    "application/x-wais-source",
    "www/download",
    (HTConverter *)HTWSRCConvert,
    1.0,
    0.0,
    0.0,
    0,
    mediaINT_0);
  HTSetConversion("application/x-wais-source", "www/dump", (HTConverter *)HTWSRCConvert, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("www/source", "www/present", (HTConverter *)HTSaveToFile, 1.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetConversion("www/source", "www/source", (HTConverter *)HTSaveToFile, 1.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetConversion("www/source", "www/download", (HTConverter *)HTSaveToFile, 1.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetConversion("www/source", "*", (HTConverter *)HTSaveToFile, 1.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetConversion("www/source", "www/dump", (HTConverter *)HTDumpToStdout, 1.0, 3.0, 0.0, 0, mediaEXT_0);
  HTSetConversion("text/x-sgml", "www/source", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/x-sgml", "www/present", HTMLPresent, 2.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/sgml", "www/source", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/sgml", "www/present", HTMLPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/css", "www/present", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/plain", "www/present", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/plain", "www/source", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/html", "www/source", (HTConverter *)HTPlainPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/html", "text/x-c", HTMLToC, 0.5, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/html", "text/plain", HTMLToPlain, 0.5, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/html", "www/present", HTMLPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  HTSetConversion("text/xml", "www/present", HTMLPresent, 2.0, 0.0, 0.0, 0, mediaINT_0);
  if ( LYisAbsPath(global_type_map) )
    HTLoadTypesConfigFile(global_type_map, mediaSYS_0);
  v1 = LYAbsOrHomePath(&personal_type_map);
  if ( IsOurFile(v1) && LYCanReadFile(personal_type_map) )
    HTLoadTypesConfigFile(personal_type_map, mediaUSR_0);
  v2 = HTAtom_for("www/present");
  v3 = HTAtom_for("text/plain");
  HTReorderPresentation(v3, v2);
  v4 = HTAtom_for("www/present");
  v5 = HTAtom_for("text/html");
  HTReorderPresentation(v5, v4);
  HTFilterPresentations();
}

//----- (080D3425) --------------------------------------------------------
void HTPreparsedFormatInit()
{
  FILE *v0; // eax

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v0 = TraceFP();
    fprintf(v0, "HTPreparsedFormatInit\n");
  }
  if ( LYPreparsedSource )
  {
    HTSetConversion("text/html", "www/source", HTMLParsedPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
    HTSetConversion("text/html", "www/dump", HTMLParsedPresent, 1.0, 0.0, 0.0, 0, mediaINT_0);
  }
}

//----- (080D34F8) --------------------------------------------------------
char *__cdecl GetCommand(char *s, char **t)
{
  size_t v2; // eax
  char *v3; // eax
  int quoted; // [esp+10h] [ebp-8h]
  char *s2; // [esp+14h] [ebp-4h]
  char *sa; // [esp+20h] [ebp+8h]

  quoted = 0;
  sa = LYSkipBlanks(s);
  v2 = strlen(sa);
  s2 = (char *)malloc(2 * v2 + 1);
  if ( !s2 )
  {
    v3 = gettext("Memory exhausted!  Program aborted!");
    ExitWithError(v3);
  }
  *t = s2;
  while ( sa && *sa )
  {
    if ( quoted )
    {
      if ( *sa == 37 )
        *s2++ = 37;
      *s2++ = *sa++;
      quoted = 0;
    }
    else
    {
      if ( *sa == 59 )
      {
        *s2 = 0;
        return sa + 1;
      }
      if ( *sa == 92 )
        quoted = 1;
      else
        *s2++ = *sa;
      ++sa;
    }
  }
  *s2 = 0;
  return 0;
}

//----- (080D35F4) --------------------------------------------------------
char *__cdecl Cleanse(char *s)
{
  LYTrimLeading(s);
  LYTrimTrailing(s);
  LYLowerCase(s);
  return s;
}

//----- (080D3620) --------------------------------------------------------
void __cdecl TrimCommand(char *command)
{
  int c0; // [esp+14h] [ebp-14h]
  int ch_0; // [esp+18h] [ebp-10h]
  char *d; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  BOOLEAN squote; // [esp+25h] [ebp-3h]
  BOOLEAN dquote; // [esp+26h] [ebp-2h]

  LYTrimTrailing(command);
  s = command;
  d = command;
  c0 = 32;
  dquote = 0;
  squote = 0;
  while ( 1 )
  {
    ch_0 = *s++;
    if ( !ch_0 )
      break;
    if ( squote )
    {
      if ( ch_0 == 39 )
        squote = 0;
    }
    else if ( dquote )
    {
      if ( ch_0 == 34 )
        dquote = 0;
    }
    else if ( ch_0 == 39 )
    {
      squote = 1;
    }
    else if ( ch_0 != 92 && ch_0 == 34 )
    {
      dquote = 1;
    }
    if ( !dquote && !squote )
    {
      if ( ch_0 == 9 )
        ch_0 = 32;
      if ( ch_0 == 32 && c0 == 32 )
        continue;
    }
    *d++ = ch_0;
    c0 = ch_0;
  }
  *d = 0;
}
// 80D3659: conditional instruction was optimized away because %escape.1==0
// 80D36AD: conditional instruction was optimized away because %dquote.1==0
// 80D36B7: conditional instruction was optimized away because %escape.1==0

//----- (080D3719) --------------------------------------------------------
int __cdecl ProcessMailcapEntry(FILE *fp, MailcapEntry *mc, AcceptMedia media)
{
  char *v3; // eax
  size_t v4; // eax
  char *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  char *testcommand; // ebx
  FILE *v9; // eax
  FILE *v10; // eax
  char *command; // ebx
  char *contenttype; // esi
  FILE *v13; // eax
  float v16; // [esp+3Ch] [ebp-3Ch]
  char *mallocd_string; // [esp+48h] [ebp-30h] BYREF
  char *eq; // [esp+4Ch] [ebp-2Ch]
  char *arg; // [esp+50h] [ebp-28h]
  char *LineBuf; // [esp+54h] [ebp-24h] BYREF
  char *t; // [esp+58h] [ebp-20h]
  char *s; // [esp+5Ch] [ebp-1Ch]
  char *rawentry; // [esp+60h] [ebp-18h]
  size_t need; // [esp+64h] [ebp-14h]
  size_t len; // [esp+68h] [ebp-10h]
  size_t rawentryalloc; // [esp+6Ch] [ebp-Ch]

  rawentryalloc = 2000;
  LineBuf = 0;
  rawentry = (char *)malloc(0x7D0u);
  if ( !rawentry )
  {
    v3 = gettext("Memory exhausted!  Program aborted!");
    ExitWithError(v3);
  }
  *rawentry = 0;
  while ( LYSafeGets(&LineBuf, fp) )
  {
    LYTrimNewline(LineBuf);
    if ( *LineBuf != 35 && *LineBuf )
    {
      len = strlen(LineBuf);
      v4 = strlen(rawentry);
      need = len + v4 + 1;
      if ( need > rawentryalloc )
      {
        rawentryalloc += need + 2000;
        rawentry = (char *)realloc(rawentry, rawentryalloc);
        if ( !rawentry )
        {
          v5 = gettext("Memory exhausted!  Program aborted!");
          ExitWithError(v5);
        }
      }
      if ( !len || LineBuf[len - 1] != 92 )
      {
        strcat(rawentry, LineBuf);
        break;
      }
      LineBuf[len - 1] = 0;
      strcat(rawentry, LineBuf);
    }
  }
  if ( LineBuf )
  {
    free(LineBuf);
    LineBuf = 0;
  }
  s = LYSkipBlanks(rawentry);
  t = s;
  if ( *s )
  {
    s = strchr(rawentry, 59);
    if ( s )
    {
      *s++ = 0;
      if ( strncasecomp(t, "text/html", 9) && strncasecomp(t, "text/plain", 10) )
      {
        LYRemoveBlanks(rawentry);
        LYLowerCase(rawentry);
        mc->needsterminal = 0;
        mc->copiousoutput = 0;
        mc->needtofree = 1;
        mc->testcommand = 0;
        mc->label = 0;
        mc->printcommand = 0;
        mc->contenttype = 0;
        HTSACopy(&mc->contenttype, rawentry);
        mc->quality = 1.0;
        mc->maxbytes = 0;
        t = GetCommand(s, &mc->command);
        if ( t )
        {
          for ( s = LYSkipBlanks(t); s; s = t )
          {
            t = GetCommand(s, &mallocd_string);
            arg = mallocd_string;
            eq = strchr(mallocd_string, 61);
            if ( eq )
            {
              *eq++ = 0;
              eq = LYSkipBlanks(eq);
            }
            if ( arg && *arg )
            {
              arg = Cleanse(arg);
              if ( !strcmp(arg, "needsterminal") )
              {
                mc->needsterminal = 1;
              }
              else if ( !strcmp(arg, "copiousoutput") )
              {
                mc->copiousoutput = 1;
              }
              else if ( eq && !strcmp(arg, "test") )
              {
                mc->testcommand = 0;
                HTSACopy(&mc->testcommand, eq);
                TrimCommand(mc->testcommand);
                if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
                {
                  testcommand = mc->testcommand;
                  v9 = TraceFP();
                  fprintf(v9, "ProcessMailcapEntry: Found testcommand:%s\n", testcommand);
                }
              }
              else if ( eq && !strcmp(arg, "description") )
              {
                mc->label = eq;
              }
              else if ( eq && !strcmp(arg, "label") )
              {
                mc->label = eq;
              }
              else if ( eq && !strcmp(arg, "print") )
              {
                mc->printcommand = eq;
              }
              else if ( !eq || strcmp(arg, "textualnewlines") )
              {
                if ( eq && !strcmp(arg, "q") )
                {
                  v16 = atof(eq);
                  mc->quality = v16;
                  if ( mc->quality > 0.0 && mc->quality < 0.001 )
                    mc->quality = 0.001;
                }
                else if ( eq && !strcmp(arg, "mxb") )
                {
                  mc->maxbytes = atol(eq);
                  if ( mc->maxbytes < 0 )
                    mc->maxbytes = 0;
                }
                else if ( strcmp(arg, "notes") && *arg && WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
                {
                  v10 = TraceFP();
                  fprintf(v10, "ProcessMailcapEntry: Ignoring mailcap flag '%s'.\n", arg);
                }
              }
            }
            if ( mallocd_string )
            {
              free(mallocd_string);
              mallocd_string = 0;
            }
          }
        }
        if ( rawentry )
        {
          free(rawentry);
          rawentry = 0;
        }
        if ( PassesTest(mc) )
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
          {
            command = mc->command;
            contenttype = mc->contenttype;
            v13 = TraceFP();
            fprintf(v13, "ProcessMailcapEntry Setting up conversion %s : %s\n", contenttype, command);
          }
          HTSetPresentation(mc->contenttype, mc->command, mc->testcommand, mc->quality, 3.0, 0.0, mc->maxbytes, media);
        }
        if ( mc->command )
        {
          free(mc->command);
          mc->command = 0;
        }
        if ( mc->testcommand )
        {
          free(mc->testcommand);
          mc->testcommand = 0;
        }
        if ( mc->contenttype )
        {
          free(mc->contenttype);
          mc->contenttype = 0;
        }
        return 1;
      }
      else
      {
        *--s = 59;
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
        {
          v7 = TraceFP();
          fprintf(v7, "ProcessMailcapEntry: Ignoring mailcap entry: %s\n", rawentry);
        }
        if ( rawentry )
        {
          free(rawentry);
          rawentry = 0;
        }
        return 0;
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v6 = TraceFP();
        fprintf(v6, "ProcessMailcapEntry: Ignoring invalid mailcap entry: %s\n", rawentry);
      }
      if ( rawentry )
      {
        free(rawentry);
        rawentry = 0;
      }
      return 0;
    }
  }
  else
  {
    if ( rawentry )
    {
      free(rawentry);
      rawentry = 0;
    }
    return 0;
  }
}

//----- (080D3EE5) --------------------------------------------------------
const char *__cdecl LYSkipQuoted(const char *s)
{
  int escaped; // [esp+Ch] [ebp-4h]
  const char *sa; // [esp+18h] [ebp+8h]

  escaped = 0;
  for ( sa = s + 1; *sa; ++sa )
  {
    if ( escaped )
    {
      escaped = 0;
    }
    else if ( *sa == 92 )
    {
      escaped = 1;
    }
    else if ( *sa == 34 )
    {
      ++sa;
      return sa;
    }
  }
  return sa;
}

//----- (080D3F3D) --------------------------------------------------------
const char *__cdecl LYSkipToken(const char *s)
{
  while ( *s && *s > 0x20u && !strchr("\"()<>@,;:\\/[]?.=", *s) )
    ++s;
  return s;
}

//----- (080D3F7F) --------------------------------------------------------
const char *__cdecl LYSkipValue(const char *s)
{
  if ( *s == 34 )
    return LYSkipQuoted(s);
  else
    return LYSkipToken(s);
}

//----- (080D3FB2) --------------------------------------------------------
char *__cdecl LYCopyValue(const char *s)
{
  char *v1; // ecx
  int k; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  char *result; // [esp+1Ch] [ebp-Ch] BYREF
  const char *t; // [esp+20h] [ebp-8h]

  result = 0;
  if ( *s == 34 )
  {
    t = LYSkipQuoted(s);
    HTSACopy(&result, s + 1);
    result[t - s - 2] = 0;
    k = 0;
    for ( j = 0; ; ++j )
    {
      if ( result[j] == 92 )
        ++j;
      v1 = &result[k];
      *v1 = result[j];
      if ( !*v1 )
        break;
      ++k;
    }
  }
  else
  {
    t = LYSkipToken(s);
    HTSACopy(&result, s);
    result[t - s] = 0;
  }
  return result;
}

//----- (080D4090) --------------------------------------------------------
char *__cdecl LYGetContentType(const char *name, const char *params)
{
  const char *v2; // eax
  const char *next; // [esp+24h] [ebp-14h]
  const char *test; // [esp+28h] [ebp-10h]
  const char *testa; // [esp+28h] [ebp-10h]
  const char *testb; // [esp+28h] [ebp-10h]
  size_t length; // [esp+2Ch] [ebp-Ch]
  char *result; // [esp+30h] [ebp-8h] BYREF
  BOOLEAN found; // [esp+37h] [ebp-1h]

  result = 0;
  if ( params )
  {
    if ( name )
    {
      length = strlen(name);
      test = strchr(params, 59);
      while ( test )
      {
        found = 0;
        testa = LYSkipCBlanks(test + 1);
        next = LYSkipToken(testa);
        if ( next - testa == length && !strncmp(testa, name, length) )
          found = 1;
        test = LYSkipCBlanks(next);
        if ( *test == 61 )
        {
          testb = LYSkipCBlanks(test + 1);
          if ( found )
            return LYCopyValue(testb);
          v2 = LYSkipValue(testb);
          test = LYSkipCBlanks(v2);
        }
        if ( *test != 59 )
          return result;
      }
    }
    else
    {
      HTSACopy(&result, params);
      *LYSkipNonBlanks(result) = 0;
    }
  }
  return result;
}

//----- (080D41C5) --------------------------------------------------------
BOOLEAN __cdecl LYMailcapUsesPctS(const char *controlstring)
{
  int v2; // [esp+14h] [ebp-24h]
  int escaped; // [esp+24h] [ebp-14h]
  int prefixed; // [esp+28h] [ebp-10h]
  char *next; // [esp+2Ch] [ebp-Ch]
  BOOLEAN result; // [esp+34h] [ebp-4h]

  result = 0;
  prefixed = 0;
  escaped = 0;
  while ( *controlstring )
  {
    if ( escaped )
    {
      escaped = 0;
    }
    else if ( *controlstring == 92 )
    {
      escaped = 1;
    }
    else if ( prefixed )
    {
      prefixed = 0;
      v2 = *controlstring;
      if ( v2 != 110 && v2 > 110 && v2 != 116 )
      {
        if ( v2 == 123 )
        {
          next = strchr(controlstring, 125);
          if ( next )
            controlstring = next;
        }
        else if ( v2 == 115 )
        {
          result = 1;
        }
      }
    }
    else
    {
      prefixed = *controlstring == 37;
    }
    ++controlstring;
  }
  return result;
}

//----- (080D42AB) --------------------------------------------------------
int __cdecl BuildCommand(HTChunk *cmd, const char *controlstring, const char *TmpFileName, const char *params)
{
  FILE *v4; // eax
  char *v5; // ebx
  FILE *v6; // eax
  int v7; // ebx
  FILE *v8; // eax
  int v10; // [esp+10h] [ebp-28h]
  int escaped; // [esp+14h] [ebp-24h]
  int prefixed; // [esp+18h] [ebp-20h]
  char *value; // [esp+1Ch] [ebp-1Ch]
  char *valuea; // [esp+1Ch] [ebp-1Ch]
  char *name; // [esp+20h] [ebp-18h] BYREF
  const char *next; // [esp+24h] [ebp-14h]
  const char *from; // [esp+28h] [ebp-10h]
  size_t TmpFileLen; // [esp+2Ch] [ebp-Ch]
  int result; // [esp+30h] [ebp-8h]

  result = 0;
  TmpFileLen = strlen(TmpFileName);
  prefixed = 0;
  escaped = 0;
  for ( from = controlstring; *from; ++from )
  {
    if ( escaped )
    {
      escaped = 0;
      HTChunkPutc(cmd, *from);
      continue;
    }
    if ( *from == 92 )
    {
      escaped = 1;
      continue;
    }
    if ( !prefixed )
    {
      if ( *from == 37 )
      {
        prefixed = 1;
        continue;
      }
LABEL_43:
      HTChunkPutc(cmd, *from);
      continue;
    }
    prefixed = 0;
    v10 = *from;
    if ( v10 == 110 )
      goto LABEL_17;
    if ( v10 <= 110 )
    {
      if ( v10 == 37 )
        goto LABEL_43;
      if ( v10 != 70 )
      {
LABEL_38:
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
        {
          v7 = *from;
          v8 = TraceFP();
          fprintf(v8, "BuildCommand: Ignoring unrecognized format code in mailcap file '%%%c'.\n", v7);
        }
        continue;
      }
LABEL_17:
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v4 = TraceFP();
        fprintf(v4, "BuildCommand: Bad mailcap \"test\" clause: %s\n", controlstring);
      }
      continue;
    }
    switch ( v10 )
    {
      case 't':
        value = LYGetContentType(0, params);
        if ( value )
        {
          HTChunkPuts(cmd, value);
          free(value);
        }
        break;
      case '{':
        next = strchr(from, 125);
        if ( !next )
          goto LABEL_38;
        if ( params )
        {
          ++from;
          name = 0;
          HTSprintf0(&name, "%.*s", next - from, from);
          valuea = LYGetContentType(name, params);
          if ( valuea )
          {
            HTChunkPuts(cmd, valuea);
            free(valuea);
          }
          else if ( !strcmp(name, "charset") )
          {
            HTChunkPuts(cmd, "ISO-8859-1");
          }
          else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
          {
            v5 = name;
            v6 = TraceFP();
            fprintf(v6, "BuildCommand no value for %s\n", v5);
          }
          if ( name )
          {
            free(name);
            name = 0;
          }
        }
        else
        {
          result = -1;
        }
        from = next;
        break;
      case 's':
        if ( TmpFileLen && TmpFileName )
          HTChunkPuts(cmd, TmpFileName);
        break;
      default:
        goto LABEL_38;
    }
  }
  HTChunkTerminate(cmd);
  return result;
}
// 80D440E: conditional instruction was optimized away because %value.4!=0
// 80D44E2: conditional instruction was optimized away because %value.4!=0

//----- (080D4611) --------------------------------------------------------
int __cdecl LYTestMailcapCommand(const char *testcommand, const char *params)
{
  char *v2; // eax
  const char *data; // ebx
  FILE *v4; // eax
  const char *v5; // ebx
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  HTChunk *expanded; // [esp+28h] [ebp-110h]
  int result; // [esp+2Ch] [ebp-10Ch]
  char TmpFileName[256]; // [esp+30h] [ebp-108h] BYREF
  unsigned int v13; // [esp+130h] [ebp-8h]

  v13 = __readgsdword(0x14u);
  if ( LYMailcapUsesPctS(testcommand) )
  {
    if ( !LYOpenTemp(TmpFileName, ".html", "w") )
    {
      v2 = gettext("Can't open temporary file!");
      ExitWithError(v2);
    }
    LYCloseTemp(TmpFileName);
  }
  else
  {
    TmpFileName[0] = 0;
  }
  expanded = HTChunkCreate(1024);
  if ( BuildCommand(expanded, testcommand, TmpFileName, params) )
  {
    result = 1;
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      data = expanded->data;
      v4 = TraceFP();
      fprintf(v4, "PassesTest: Deferring test command: %s\n", data);
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v5 = expanded->data;
      v6 = TraceFP();
      fprintf(v6, "PassesTest: Executing test command: %s\n", v5);
    }
    result = LYSystem(expanded->data);
    if ( result )
    {
      result = -1;
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v7 = TraceFP();
        fprintf(v7, "PassesTest: Test failed!\n");
      }
    }
    else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v8 = TraceFP();
      fprintf(v8, "PassesTest: Test passed!\n");
    }
  }
  HTChunkFree(expanded);
  LYRemoveTemp(TmpFileName);
  return result;
}

//----- (080D483F) --------------------------------------------------------
char *__cdecl LYMakeMailcapCommand(const char *command, const char *params, const char *filename)
{
  char *result; // [esp+20h] [ebp-8h] BYREF
  HTChunk *expanded; // [esp+24h] [ebp-4h]

  result = 0;
  expanded = HTChunkCreate(1024);
  BuildCommand(expanded, command, filename, params);
  HTSACopy(&result, expanded->data);
  HTChunkFree(expanded);
  return result;
}

//----- (080D48A7) --------------------------------------------------------
int __cdecl RememberTestResult(int mode, char *cmd, int result)
{
  RememberTestResult::cmdlist_s *cur; // [esp+24h] [ebp-4h]
  RememberTestResult::cmdlist_s *cura; // [esp+24h] [ebp-4h]
  RememberTestResult::cmdlist_s *curb; // [esp+24h] [ebp-4h]

  if ( mode == 1 )
  {
    for ( cura = cmdlist_10828; cura; cura = cura->next )
    {
      if ( !strcmp(cmd, cura->cmd) )
        return cura->result;
    }
    return -1;
  }
  else
  {
    if ( mode == 2 )
    {
      curb = (RememberTestResult::cmdlist_s *)calloc(1u, 0xCu);
      if ( !curb )
        outofmem("./HTInit.c", "RememberTestResult");
      curb->next = cmdlist_10828;
      HTSACopy(&curb->cmd, cmd);
      curb->result = result;
      cmdlist_10828 = curb;
    }
    else if ( !mode )
    {
      while ( cmdlist_10828 )
      {
        cur = cmdlist_10828->next;
        if ( cmdlist_10828->cmd )
        {
          free(cmdlist_10828->cmd);
          cmdlist_10828->cmd = 0;
        }
        if ( cmdlist_10828 )
        {
          free(cmdlist_10828);
          cmdlist_10828 = 0;
        }
        cmdlist_10828 = cur;
      }
    }
    return 0;
  }
}

//----- (080D49E5) --------------------------------------------------------
int __cdecl PassesTest(MailcapEntry *mc)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  int result; // [esp+24h] [ebp-4h]

  if ( !mc->testcommand )
    return 1;
  if ( !strcmp(mc->testcommand, "test \"$DISPLAY\"")
    || !strcmp(mc->testcommand, "test \"$DISPLAY\" != \"\"")
    || !strcmp(mc->testcommand, "test -n \"$DISPLAY\"") )
  {
    if ( mc->testcommand )
    {
      free(mc->testcommand);
      mc->testcommand = 0;
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v1 = TraceFP();
      fprintf(v1, "PassesTest: Testing for XWINDOWS environment.\n");
    }
    if ( LYgetXDisplay() )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v2 = TraceFP();
        fprintf(v2, "PassesTest: Test passed!\n");
      }
      return 1;
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v3 = TraceFP();
        fprintf(v3, "PassesTest: Test failed!\n");
      }
      return 0;
    }
  }
  else if ( !strcmp(mc->testcommand, "test -z \"$DISPLAY\"") )
  {
    if ( mc->testcommand )
    {
      free(mc->testcommand);
      mc->testcommand = 0;
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v4 = TraceFP();
      fprintf(v4, "PassesTest: Testing for NON_XWINDOWS environment.\n");
    }
    if ( LYgetXDisplay() )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v6 = TraceFP();
        fprintf(v6, "PassesTest: Test failed!\n");
      }
      return 0;
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v5 = TraceFP();
        fprintf(v5, "PassesTest: Test passed!\n");
      }
      return 1;
    }
  }
  else if ( !strcmp(mc->testcommand, "test -n \"$LYNX_VERSION\"") )
  {
    if ( mc->testcommand )
    {
      free(mc->testcommand);
      mc->testcommand = 0;
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v7 = TraceFP();
      fprintf(v7, "PassesTest: Testing for LYNX environment.\n");
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v8 = TraceFP();
      fprintf(v8, "PassesTest: Test passed!\n");
    }
    return 1;
  }
  else if ( !strcmp(mc->testcommand, "test -z \"$LYNX_VERSION\"") )
  {
    if ( mc->testcommand )
    {
      free(mc->testcommand);
      mc->testcommand = 0;
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v9 = TraceFP();
      fprintf(v9, "PassesTest: Testing for non-LYNX environment.\n");
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v10 = TraceFP();
      fprintf(v10, "PassesTest: Test failed!\n");
    }
    return 0;
  }
  else
  {
    result = RememberTestResult(1, mc->testcommand, 0);
    if ( result == -1 )
    {
      result = LYTestMailcapCommand(mc->testcommand, 0);
      RememberTestResult(2, mc->testcommand, result != 0);
    }
    if ( result != 1 && mc->testcommand )
    {
      free(mc->testcommand);
      mc->testcommand = 0;
    }
    if ( result >= 0 )
    {
      if ( !result && WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
      {
        v12 = TraceFP();
        fprintf(v12, "PassesTest: Test passed!\n");
      }
    }
    else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v11 = TraceFP();
      fprintf(v11, "PassesTest: Test failed!\n");
    }
    return result >= 0;
  }
}

//----- (080D4E63) --------------------------------------------------------
int __cdecl ProcessMailcapFile(char *file, AcceptMedia media)
{
  FILE *v2; // eax
  FILE *v3; // eax
  MailcapEntry mc; // [esp+18h] [ebp-30h] BYREF
  FILE *fp; // [esp+44h] [ebp-4h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v2 = TraceFP();
    fprintf(v2, "ProcessMailcapFile: Loading file '%s'.\n", file);
  }
  fp = (FILE *)fopen64(file, "r");
  if ( fp )
  {
    while ( fp && !feof(fp) )
      ProcessMailcapEntry(fp, &mc, media);
    LYCloseInput(fp);
    RememberTestResult(0, 0, 0);
    return 1;
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "ProcessMailcapFile: Could not open '%s'.\n", file);
    }
    return 0;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080D4F59) --------------------------------------------------------
int __cdecl __noreturn ExitWithError(const char *txt)
{
  FILE *v1; // edx

  if ( txt )
  {
    v1 = TraceFP();
    fprintf(v1, "Lynx: %s\n", txt);
  }
  exit_immediately(1);
}

//----- (080D4F96) --------------------------------------------------------
int __cdecl HTLoadTypesConfigFile(char *fn, AcceptMedia media)
{
  HTList *saved; // [esp+10h] [ebp-8h]
  int result; // [esp+14h] [ebp-4h]

  saved = HTPresentations;
  if ( reverse_mailcap )
    HTPresentations = 0;
  result = ProcessMailcapFile(fn, media);
  if ( reverse_mailcap )
  {
    if ( result && HTPresentations )
    {
      HTList_reverse(HTPresentations);
      HTList_appendList(HTPresentations, saved);
      if ( saved )
        free(saved);
    }
    else
    {
      HTPresentations = saved;
    }
  }
  return result;
}

//----- (080D5034) --------------------------------------------------------
void HTFileInit()
{
  FILE *v0; // eax
  FILE *v1; // eax
  char *v2; // eax

  if ( LYUseBuiltinSuffixes )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v0 = TraceFP();
      fprintf(v0, "HTFileInit: Loading default (HTInit) extension maps.\n");
    }
    HTSetSuffix5("*", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5("*.*", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".csh", "application/x-csh", "8bit", 0, 0.8);
    HTSetSuffix5(".sh", "application/x-sh", "8bit", 0, 0.8);
    HTSetSuffix5(".ksh", "application/x-ksh", "8bit", 0, 0.8);
    HTSetSuffix5(".saveme", "application/x-Binary", "binary", 0, 1.0);
    HTSetSuffix5(".dump", "application/x-Binary", "binary", 0, 1.0);
    HTSetSuffix5(".bin", "application/x-Binary", "binary", 0, 1.0);
    HTSetSuffix5(".arc", "application/x-Compressed", "binary", 0, 1.0);
    HTSetSuffix5(".alpha-exe", "application/x-Executable", "binary", 0, 1.0);
    HTSetSuffix5(".alpha_exe", "application/x-Executable", "binary", 0, 1.0);
    HTSetSuffix5(".AXP-exe", "application/x-Executable", "binary", 0, 1.0);
    HTSetSuffix5(".AXP_exe", "application/x-Executable", "binary", 0, 1.0);
    HTSetSuffix5(".VAX-exe", "application/x-Executable", "binary", 0, 1.0);
    HTSetSuffix5(".VAX_exe", "application/x-Executable", "binary", 0, 1.0);
    HTSetSuffix5(".exe", "application/octet-stream", "binary", "Executable", 1.0);
    HTSetSuffix5(".Z", "application/x-compress", "binary", "UNIX Compressed", 1.0);
    HTSetSuffix5(".Z", 0, "compress", "UNIX Compressed", 1.0);
    HTSetSuffix5(".exe.Z", "application/octet-stream", "compress", "Executable", 1.0);
    HTSetSuffix5(".tar_Z", "application/x-tar", "compress", "UNIX Compr. Tar", 1.0);
    HTSetSuffix5(".tar.Z", "application/x-tar", "compress", "UNIX Compr. Tar", 1.0);
    HTSetSuffix5("-gz", "application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz", "application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz", "application/x-gzip", "binary", "GNU Compressed", 1.0);
    HTSetSuffix5("-gz", 0, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5("_gz", 0, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5(".gz", 0, "gzip", "GNU Compressed", 1.0);
    HTSetSuffix5(".tar.gz", "application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".tgz", "application/x-tar", "gzip", "GNU Compr. Tar", 1.0);
    HTSetSuffix5(".wsrc", "application/x-wais-source", "8bit", "WAIS-source", 1.0);
    HTSetSuffix5(".zip", "application/zip", "binary", "Zip File", 1.0);
    HTSetSuffix5(".zz", "application/x-deflate", "binary", 0, 1.0);
    HTSetSuffix5(".zz", "application/deflate", "binary", 0, 1.0);
    HTSetSuffix5(".bz2", "application/x-bzip2", "binary", 0, 1.0);
    HTSetSuffix5(".bz2", "application/bzip2", "binary", 0, 1.0);
    HTSetSuffix5(".uu", "application/x-uuencoded", "7bit", "UUencoded", 1.0);
    HTSetSuffix5(".hqx", "application/mac-binhex40", "8bit", "Mac BinHex", 1.0);
    HTSetSuffix5(".o", "application/octet-stream", "binary", "Prog. Object", 0.5);
    HTSetSuffix5(".a", "application/octet-stream", "binary", "Prog. Library", 0.5);
    HTSetSuffix5(".so", "application/octet-stream", "binary", "Shared Lib", 0.5);
    HTSetSuffix5(".oda", "application/oda", "binary", "ODA", 1.0);
    HTSetSuffix5(".pdf", "application/pdf", "binary", "PDF", 1.0);
    HTSetSuffix5(".eps", "application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ai", "application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".ps", "application/postscript", "8bit", "Postscript", 1.0);
    HTSetSuffix5(".rtf", "application/rtf", "8bit", "RTF", 1.0);
    HTSetSuffix5(".dvi", "application/x-dvi", "8bit", "DVI", 1.0);
    HTSetSuffix5(".hdf", "application/x-hdf", "8bit", "HDF", 1.0);
    HTSetSuffix5(".cdf", "application/x-netcdf", "8bit", 0, 1.0);
    HTSetSuffix5(".nc", "application/x-netcdf", "8bit", 0, 1.0);
    HTSetSuffix5(".latex", "application/x-latex", "8bit", "LaTeX", 1.0);
    HTSetSuffix5(".tex", "text/x-tex", "8bit", "TeX", 1.0);
    HTSetSuffix5(".texinfo", "application/x-texinfo", "8bit", "Texinfo", 1.0);
    HTSetSuffix5(".texi", "application/x-texinfo", "8bit", "Texinfo", 1.0);
    HTSetSuffix5(".t", "application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".tr", "application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".roff", "application/x-troff", "8bit", "Troff", 1.0);
    HTSetSuffix5(".man", "application/x-troff-man", "8bit", "Man Page", 1.0);
    HTSetSuffix5(".me", "application/x-troff-me", "8bit", "Troff me", 1.0);
    HTSetSuffix5(".ms", "application/x-troff-ms", "8bit", "Troff ms", 1.0);
    HTSetSuffix5(".zoo", "application/x-Zoo File", "binary", 0, 1.0);
    HTSetSuffix5(".bak", 0, "binary", "Backup", 0.5);
    HTSetSuffix5(".bkp", "application/octet-stream", "binary", "VMS BAK File", 1.0);
    HTSetSuffix5(".bck", "application/octet-stream", "binary", "VMS BAK File", 1.0);
    HTSetSuffix5(".hlb", "application/octet-stream", "binary", "VMS Help Libr.", 1.0);
    HTSetSuffix5(".olb", "application/octet-stream", "binary", "VMS Obj. Libr.", 1.0);
    HTSetSuffix5(".tlb", "application/octet-stream", "binary", "VMS Text Libr.", 1.0);
    HTSetSuffix5(".obj", "application/octet-stream", "binary", "Prog. Object", 1.0);
    HTSetSuffix5(".decw$book", "application/octet-stream", "binary", "DEC BookReader", 1.0);
    HTSetSuffix5(".mem", "text/x-runoff-manual", "8bit", "RUNOFF-MANUAL", 1.0);
    HTSetSuffix5(".vsd", "application/visio", "binary", 0, 1.0);
    HTSetSuffix5(".lha", "application/x-lha", "binary", "lha File", 1.0);
    HTSetSuffix5(".lzh", "application/x-lzh", "binary", "lzh File", 1.0);
    HTSetSuffix5(".sea", "application/x-sea", "binary", "sea File", 1.0);
    HTSetSuffix5(".sit", "application/x-stuffit", "binary", "StuffIt", 1.0);
    HTSetSuffix5(".dms", "application/x-dms", "binary", "dms File", 1.0);
    HTSetSuffix5(".iff", "application/x-iff", "binary", "iff File", 1.0);
    HTSetSuffix5(".bcpio", "application/x-bcpio", "binary", 0, 1.0);
    HTSetSuffix5(".cpio", "application/x-cpio", "binary", 0, 1.0);
    HTSetSuffix5(".shar", "application/x-shar", "8bit", 0, 1.0);
    HTSetSuffix5(".share", "application/x-share", "8bit", 0, 1.0);
    HTSetSuffix5(".sv4cpio", "application/x-sv4cpio", "binary", 0, 1.0);
    HTSetSuffix5(".sv4crc", "application/x-sv4crc", "binary", 0, 1.0);
    HTSetSuffix5(".tar", "application/x-tar", "binary", "Tar File", 1.0);
    HTSetSuffix5(".ustar", "application/x-ustar", "binary", 0, 1.0);
    HTSetSuffix5(".snd", "audio/basic", "binary", 0, 1.0);
    HTSetSuffix5(".au", "audio/basic", "binary", 0, 1.0);
    HTSetSuffix5(".aifc", "audio/x-aiff", "binary", 0, 1.0);
    HTSetSuffix5(".aif", "audio/x-aiff", "binary", 0, 1.0);
    HTSetSuffix5(".aiff", "audio/x-aiff", "binary", 0, 1.0);
    HTSetSuffix5(".wav", "audio/x-wav", "binary", 0, 1.0);
    HTSetSuffix5(".midi", "audio/midi", "binary", 0, 1.0);
    HTSetSuffix5(".mod", "audio/mod", "binary", 0, 1.0);
    HTSetSuffix5(".gif", "image/gif", "binary", 0, 1.0);
    HTSetSuffix5(".ief", "image/ief", "binary", 0, 1.0);
    HTSetSuffix5(".jfif", "image/jpeg", "binary", 0, 1.0);
    HTSetSuffix5(".jfif-tbnl", "image/jpeg", "binary", 0, 1.0);
    HTSetSuffix5(".jpe", "image/jpeg", "binary", 0, 1.0);
    HTSetSuffix5(".jpg", "image/jpeg", "binary", 0, 1.0);
    HTSetSuffix5(".jpeg", "image/jpeg", "binary", 0, 1.0);
    HTSetSuffix5(".tif", "image/tiff", "binary", 0, 1.0);
    HTSetSuffix5(".tiff", "image/tiff", "binary", 0, 1.0);
    HTSetSuffix5(".ham", "image/ham", "binary", 0, 1.0);
    HTSetSuffix5(".ras", "image/x-cmu-rast", "binary", 0, 1.0);
    HTSetSuffix5(".pnm", "image/x-portable-anymap", "binary", 0, 1.0);
    HTSetSuffix5(".pbm", "image/x-portable-bitmap", "binary", 0, 1.0);
    HTSetSuffix5(".pgm", "image/x-portable-graymap", "binary", 0, 1.0);
    HTSetSuffix5(".ppm", "image/x-portable-pixmap", "binary", 0, 1.0);
    HTSetSuffix5(".png", "image/png", "binary", 0, 1.0);
    HTSetSuffix5(".rgb", "image/x-rgb", "binary", 0, 1.0);
    HTSetSuffix5(".xbm", "image/x-xbitmap", "binary", 0, 1.0);
    HTSetSuffix5(".xpm", "image/x-xpixmap", "binary", 0, 1.0);
    HTSetSuffix5(".xwd", "image/x-xwindowdump", "binary", 0, 1.0);
    HTSetSuffix5(".rtx", "text/richtext", "8bit", 0, 1.0);
    HTSetSuffix5(".tsv", "text/tab-separated-values", "8bit", 0, 1.0);
    HTSetSuffix5(".etx", "text/x-setext", "8bit", 0, 1.0);
    HTSetSuffix5(".mpg", "video/mpeg", "binary", 0, 1.0);
    HTSetSuffix5(".mpe", "video/mpeg", "binary", 0, 1.0);
    HTSetSuffix5(".mpeg", "video/mpeg", "binary", 0, 1.0);
    HTSetSuffix5(".mov", "video/quicktime", "binary", 0, 1.0);
    HTSetSuffix5(".qt", "video/quicktime", "binary", 0, 1.0);
    HTSetSuffix5(".avi", "video/x-msvideo", "binary", 0, 1.0);
    HTSetSuffix5(".movie", "video/x-sgi-movie", "binary", 0, 1.0);
    HTSetSuffix5(".mv", "video/x-sgi-movie", "binary", 0, 1.0);
    HTSetSuffix5(".mime", "message/rfc822", "8bit", 0, 1.0);
    HTSetSuffix5(".c", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".cc", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".c++", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".css", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".h", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".pl", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".text", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".txt", "text/plain", "8bit", 0, 1.0);
    HTSetSuffix5(".php", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".php3", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".html3", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".ht3", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".phtml", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".shtml", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".sht", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".htmlx", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".htm", "text/html", "8bit", 0, 1.0);
    HTSetSuffix5(".html", "text/html", "8bit", 0, 1.0);
  }
  else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "HTFileInit: Skipping all default (HTInit) extension maps!\n");
  }
  if ( LYisAbsPath(global_extension_map) )
    HTLoadExtensionsConfigFile(global_extension_map);
  v2 = LYAbsOrHomePath(&personal_extension_map);
  if ( IsOurFile(v2) )
  {
    if ( LYCanReadFile(personal_extension_map) )
      HTLoadExtensionsConfigFile(personal_extension_map);
  }
}

//----- (080D688F) --------------------------------------------------------
int __cdecl HTGetLine(char *s, int n, FILE *f)
{
  int i; // [esp+10h] [ebp-8h]
  int r; // [esp+14h] [ebp-4h]

  i = 0;
  if ( !f )
    return 1;
  while ( 1 )
  {
    r = fgetc(f);
    s[i] = r;
    if ( s[i] == 13 )
    {
      r = fgetc(f);
      if ( r == 10 )
      {
        s[i] = 10;
      }
      else if ( r != -1 )
      {
        ungetc(r, f);
      }
    }
    if ( r == -1 || s[i] == 10 || s[i] == 13 || n - 1 == i )
      break;
    ++i;
  }
  s[i] = 0;
  return feof(f) != 0;
}

//----- (080D696D) --------------------------------------------------------
void __cdecl HTGetWord(char *word, char *line, char stop, char stop2)
{
  bool v4; // al
  int y; // [esp+10h] [ebp-8h]
  int x; // [esp+14h] [ebp-4h]

  for ( x = 0; line[x] && line[x] != stop && line[x] != stop2; ++x )
    word[x] = line[x];
  word[x] = 0;
  if ( line[x] )
    ++x;
  y = 0;
  do
  {
    line[y] = line[x];
    v4 = line[y++] != 0;
    ++x;
  }
  while ( v4 );
}

//----- (080D6A19) --------------------------------------------------------
int __cdecl HTLoadExtensionsConfigFile(char *fn)
{
  FILE *v1; // eax
  FILE *v2; // eax
  char *v3; // ebx
  char *v4; // esi
  FILE *v5; // eax
  char *ext; // [esp+2Ch] [ebp-21Ch] BYREF
  int count; // [esp+30h] [ebp-218h]
  FILE *f; // [esp+34h] [ebp-214h]
  char *ct; // [esp+38h] [ebp-210h] BYREF
  char word[256]; // [esp+3Ch] [ebp-20Ch] BYREF
  char line[256]; // [esp+13Ch] [ebp-10Ch] BYREF
  unsigned int v14; // [esp+23Ch] [ebp-Ch]

  v14 = __readgsdword(0x14u);
  count = 0;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "HTLoadExtensionsConfigFile: Loading file '%s'.\n", fn);
  }
  f = (FILE *)fopen64(fn, "r");
  if ( f )
  {
    while ( !HTGetLine(line, 256, f) )
    {
      HTGetWord(word, line, 32, 9);
      if ( line[0] && word[0] != 35 )
      {
        ct = 0;
        HTSACopy(&ct, word);
        LYLowerCase(ct);
        while ( line[0] )
        {
          HTGetWord(word, line, 32, 9);
          if ( word[0] && word[0] != 32 )
          {
            ext = 0;
            HTSprintf0(&ext, ".%s", word);
            LYLowerCase(ext);
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
            {
              v3 = ct;
              v4 = ext;
              v5 = TraceFP();
              fprintf(v5, "setting suffix '%s' to '%s'.\n", v4, v3);
            }
            if ( strstr(ct, "tex")
              || strstr(ct, "postscript")
              || strstr(ct, "sh")
              || strstr(ct, "troff")
              || strstr(ct, "rtf") )
            {
              HTSetSuffix5(ext, ct, "8bit", 0, 1.0);
            }
            else
            {
              HTSetSuffix5(ext, ct, "binary", 0, 1.0);
            }
            ++count;
            if ( ext )
            {
              free(ext);
              ext = 0;
            }
          }
        }
        if ( ct )
        {
          free(ct);
          ct = 0;
        }
      }
    }
    LYCloseInput(f);
    return count;
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v2 = TraceFP();
      fprintf(v2, "HTLoadExtensionsConfigFile: Could not open '%s'.\n", fn);
    }
    return count;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080D6DC4) --------------------------------------------------------
HTStyleSheet *__cdecl DefaultStyle(HTStyle ***result_array)
{
  HTStyleSheet *v1; // eax
  HTStyle *styles; // edx
  HTStyle *r; // [esp+24h] [ebp-14h]
  HTStyle *q; // [esp+28h] [ebp-10h]
  HTStyle *qa; // [esp+28h] [ebp-10h]
  HTStyle *p; // [esp+2Ch] [ebp-Ch]
  HTStyle *pa; // [esp+2Ch] [ebp-Ch]

  if ( result )
  {
    qa = result->styles;
    pa = sheet.styles;
    while ( pa && qa )
    {
      r = qa->next;
      qmemcpy(qa, pa, sizeof(HTStyle));
      if ( no_margins )
      {
        qa->indent1st = 0;
        qa->leftIndent = 0;
        qa->rightIndent = 0;
      }
      st_array[qa->id] = qa;
      qa->next = r;
      pa = pa->next;
      qa = qa->next;
    }
  }
  else
  {
    v1 = HTStyleSheetNew();
    result = v1;
    styles = sheet.styles;
    v1->name = sheet.name;
    v1->styles = styles;
    result->styles = 0;
    for ( p = sheet.styles; p; p = p->next )
    {
      q = HTStyleNew();
      qmemcpy(q, p, sizeof(HTStyle));
      if ( no_margins )
      {
        q->indent1st = 0;
        q->leftIndent = 0;
        q->rightIndent = 0;
      }
      st_array[q->id] = q;
      q->next = result->styles;
      result->styles = q;
    }
  }
  *result_array = st_array;
  return result;
}

//----- (080D6F54) --------------------------------------------------------
int __cdecl LYUpload(char *line)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  char *v10; // ebx
  FILE *v11; // eax
  char *v12; // eax
  char *v13; // eax
  int v15; // [esp+18h] [ebp-140h]
  char *the_command; // [esp+30h] [ebp-128h] BYREF
  lynx_list_item_type *upload_command; // [esp+34h] [ebp-124h]
  char *filename; // [esp+38h] [ebp-120h] BYREF
  char *the_upload; // [esp+3Ch] [ebp-11Ch] BYREF
  int count; // [esp+40h] [ebp-118h]
  int method_number; // [esp+44h] [ebp-114h]
  char *directory; // [esp+48h] [ebp-110h]
  char *method; // [esp+4Ch] [ebp-10Ch]
  char tmpbuf[256]; // [esp+50h] [ebp-108h] BYREF
  unsigned int v26; // [esp+150h] [ebp-8h]

  v26 = __readgsdword(0x14u);
  the_upload = 0;
  filename = 0;
  upload_command = 0;
  the_command = 0;
  directory = strstr(line, "TO=");
  if ( !directory )
    goto failed;
  *(directory - 1) = 0;
  directory += 3;
  method = strstr(line, "UPLOAD=");
  if ( !method )
    goto failed;
  method += 7;
  method_number = atoi(method);
  count = 0;
  upload_command = uploaders;
  while ( count < method_number )
  {
    ++count;
    upload_command = upload_command->next;
  }
  if ( !upload_command->command )
  {
    v1 = gettext("ERROR! - upload command is misconfigured");
    HTAlert(v1);
failed:
    v12 = gettext("Unable to upload file.");
    HTAlert(v12);
    return 0;
  }
  if ( HTCountCommandArgs(upload_command->command) )
  {
    mustshow[0] = 1;
    v2 = gettext("Enter a filename: ");
    statusline(v2);
    while ( 1 )
    {
      tmpbuf[0] = 0;
      if ( LYgetstr(tmpbuf, 0, 0x100u, NORECALL) < 0 || !tmpbuf[0] )
        break;
      if ( strstr(tmpbuf, "../") )
      {
        v3 = gettext("Illegal redirection \"../\" found! Request ignored.");
        HTAlert(v3);
        break;
      }
      if ( strchr(tmpbuf, 47) )
      {
        v4 = gettext("Illegal character \"/\" found! Request ignored.");
        HTAlert(v4);
        break;
      }
      if ( tmpbuf[0] == 126 )
      {
        v5 = gettext("Illegal redirection using \"~\" found! Request ignored.");
        HTAlert(v5);
        break;
      }
      HTSprintf0(&filename, "%s/%s", directory, tmpbuf);
      if ( *filename == 124 )
      {
        v6 = gettext("Cannot write to file.");
        HTAlert(v6);
        mustshow[0] = 1;
        v7 = gettext("Enter a new filename: ");
        statusline(v7);
      }
      else
      {
        v15 = LYValidateOutput(filename);
        if ( v15 != 78 )
        {
          if ( v15 != 89 )
            break;
          if ( WWW_TraceFlag[0] )
          {
            v8 = filename;
            v9 = TraceFP();
            fprintf(v9, "LYUpload: filename is %s", v8);
          }
          if ( LYCanWriteFile(filename) )
          {
            HTAddParam(&the_upload, upload_command->command, 1, filename);
            HTEndParam(&the_upload, upload_command->command, 1);
            goto LABEL_27;
          }
        }
      }
    }
    v13 = gettext("Cancelling!");
    HTInfoMsg(v13);
    return 0;
  }
  else
  {
    HTSACopy(&the_upload, upload_command->command);
LABEL_27:
    HTAddParam(&the_command, "cd %s ; ", 1, directory);
    HTEndParam(&the_command, "cd %s ; ", 1);
    HTSACat(&the_command, the_upload);
    if ( WWW_TraceFlag[0] )
    {
      v10 = the_command;
      v11 = TraceFP();
      fprintf(v11, "command: %s\n", v10);
    }
    stop_curses();
    LYSystem(the_command);
    start_curses();
    if ( the_command )
    {
      free(the_command);
      the_command = 0;
    }
    if ( the_upload )
    {
      free(the_upload);
      the_upload = 0;
    }
    if ( filename )
      chmod(filename, 0x180u);
    if ( filename )
    {
      free(filename);
      filename = 0;
    }
    return 1;
  }
}

//----- (080D7456) --------------------------------------------------------
int __cdecl LYUpload_options(char **newfile, char *directory)
{
  char *v3; // [esp+4h] [ebp-24h]
  char *v4; // [esp+8h] [ebp-20h]
  char *v5; // [esp+8h] [ebp-20h]
  const char *s; // [esp+14h] [ebp-14h]
  char *cp; // [esp+18h] [ebp-10h]
  int count; // [esp+1Ch] [ebp-Ch]
  lynx_list_item_type *cur_upload; // [esp+20h] [ebp-8h]
  FILE *fp0; // [esp+24h] [ebp-4h]

  fp0 = InternalPageFP(tempfile_10249, 1);
  if ( !fp0 )
    return -1;
  cp = HTnameOfFile_WWW(directory, 0, 1);
  strcpy(curloc_10253, cp);
  LYTrimPathSep(curloc_10253);
  if ( cp )
    free(cp);
  LYLocalFileToURL(newfile, tempfile_10249);
  LYRegisterUIPage(*newfile, UIP_UPLOAD_OPTIONS_0);
  v3 = gettext("Upload Options");
  BeginInternalPage(fp0, v3, "Lynx_users_guide.html.gz#DirEd");
  fwrite("<pre>\n", 1u, 6u, fp0);
  v4 = gettext("Upload To:");
  fprintf(fp0, "   <em>%s</em> %s\n", v4, curloc_10253);
  v5 = gettext("Upload options:");
  fprintf(fp0, "\n%s\n", v5);
  if ( uploaders )
  {
    count = 0;
    cur_upload = uploaders;
    while ( cur_upload )
    {
      fprintf(fp0, "   <a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\">", count, curloc_10253);
      if ( cur_upload->name )
        s = cur_upload->name;
      else
        s = gettext("No Name Given");
      fputs(s, fp0);
      fwrite("</a>\n", 1u, 5u, fp0);
      cur_upload = cur_upload->next;
      ++count;
    }
  }
  else
  {
    fwrite("   &lt;NONE&gt;\n", 1u, 0x10u, fp0);
  }
  fwrite("</pre>\n", 1u, 7u, fp0);
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  LYforce_no_cache = 1;
  return 0;
}

//----- (080D76BC) --------------------------------------------------------
void no_leak_checking()
{
  ;
}

//----- (080D76C4) --------------------------------------------------------
int __cdecl LYatexit(void (*function)(void))
{
  FILE *v1; // eax

  if ( topOfStack_0 == 50 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "(LY)atexit: Too many functions, ignoring one!\n");
    }
    return -1;
  }
  else
  {
    callstack[topOfStack_0++] = function;
    return 0;
  }
}

//----- (080D7728) --------------------------------------------------------
void LYCompleteExit()
{
  while ( --topOfStack_0 >= 0 )
    callstack[topOfStack_0]();
}

//----- (080D7756) --------------------------------------------------------
void __cdecl __noreturn LYexit(int status)
{
  char *v1; // eax

  if ( LYOutOfMemory[0] == 1 )
  {
    signal(1, (__sighandler_t)1);
    signal(15, (__sighandler_t)1);
    signal(2, (__sighandler_t)1);
    signal(11, (__sighandler_t)1);
    signal(4, (__sighandler_t)1);
    fflush(stderr);
    fflush(stdout);
    if ( LYCursesON[0] )
      LYSleepAlert();
    cleanup_sig(0);
    signal(11, 0);
    signal(4, 0);
  }
  LYCloselog();
  LYCompleteExit();
  LYCloseCmdLogfile();
  cleanup_files();
  fflush(stderr);
  if ( LYOutOfMemory[0] == 1 )
  {
    LYOutOfMemory[0] = 0;
    v1 = gettext("Memory exhausted!  Program aborted!");
    printf("\r\n%s\r\n\r\n", v1);
    fflush(stdout);
  }
  LYCloseTracelog();
  exit(status);
}

//----- (080D7899) --------------------------------------------------------
void __cdecl __noreturn outofmem(const char *fname, const char *func)
{
  char *v2; // [esp+10h] [ebp-8h]

  v2 = gettext("Memory exhausted!  Aborting...");
  fprintf(stderr, "\n\n\n%s %s: %s\n", fname, func, v2);
  LYOutOfMemory[0] = 1;
  LYexit(-1);
}

//----- (080D78E8) --------------------------------------------------------
void LYJumpTable_free()
{
  JumpTable *next; // [esp+10h] [ebp-8h]
  JumpTable *cur; // [esp+14h] [ebp-4h]

  for ( cur = JThead; cur; cur = next )
  {
    next = cur->next;
    if ( cur->msg )
    {
      free(cur->msg);
      cur->msg = 0;
    }
    if ( cur->file )
    {
      free(cur->file);
      cur->file = 0;
    }
    if ( cur->shortcut )
    {
      free(cur->shortcut);
      cur->shortcut = 0;
    }
    if ( cur->history )
    {
      LYFreeStringList(cur->history);
      cur->history = 0;
    }
    if ( cur->table )
    {
      free(cur->table);
      cur->table = 0;
    }
    if ( cur->mp )
    {
      free(cur->mp);
      cur->mp = 0;
    }
    free(cur);
  }
  JThead = 0;
}
// 80D79D4: conditional instruction was optimized away because %cur.4!=0

//----- (080D7A04) --------------------------------------------------------
void __cdecl LYAddJumpShortcut(HTList *historyp, char *shortcut)
{
  void *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]
  char *tmp; // [esp+24h] [ebp-4h] BYREF

  tmp = 0;
  cur = historyp;
  if ( historyp && shortcut && *shortcut )
  {
    HTSACopy(&tmp, shortcut);
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( !strcmp((const char *)object, tmp) )
      {
        HTList_removeObject(historyp, object);
        free(object);
        break;
      }
    }
    HTList_addObject(historyp, tmp);
  }
}
// 80D7A79: conditional instruction was optimized away because %var_14.4!=0

//----- (080D7AD5) --------------------------------------------------------
BOOLEAN __cdecl LYJumpInit(char *config)
{
  const char *msg; // ebx
  JumpTable *jtptmp; // [esp+18h] [ebp-10h]
  const char *cp; // [esp+1Ch] [ebp-Ch]
  char *cpa; // [esp+1Ch] [ebp-Ch]
  JumpTable *jtp; // [esp+20h] [ebp-8h]

  jtp = (JumpTable *)calloc(1u, 0x24u);
  if ( !jtp )
    outofmem("./LYJump.c", "LYJumpInit");
  if ( strtok(config, ":\n") && (cp = strtok(0, ":\n")) != 0 )
  {
    HTSACopy(&jtp->file, cp);
    cpa = strtok(0, ":\n");
    if ( cpa || !JThead )
    {
      if ( cpa && !JThead )
      {
        JThead = jtp;
        HTSACopy(&jtp->msg, jumpprompt);
        if ( !jumpfile )
          HTSACopy(&jumpfile, JThead->file);
        jtp = (JumpTable *)calloc(1u, 0x24u);
        if ( !jtp )
          outofmem("./LYJump.c", "LYJumpInit");
        HTSACopy(&jtp->file, JThead->file);
      }
      if ( cpa )
      {
        jtp->key = remap(cpa, "JUMP", 0);
        cpa = strtok(0, "\n");
        if ( cpa && *cpa )
          HTSACopy(&jtp->msg, cpa);
        else
          cpa = 0;
      }
      if ( !cpa )
        HTSACopy(&jtp->msg, jumpprompt);
      msg = jtp->msg;
      if ( msg[strlen(msg) - 1] != 32 )
        HTSACat(&jtp->msg, " ");
      jtp->history = HTList_new();
      jtp->next = JThead;
      JThead = jtp;
      return 1;
    }
    else
    {
      jtptmp = JThead;
      jumpfile = jtp->file;
      free(jtp);
      while ( jtptmp && jtptmp->key )
        jtptmp = jtptmp->next;
      if ( jtptmp )
      {
        HTSACopy(&jtptmp->file, jumpfile);
        HTSACopy(&jtptmp->msg, jumpprompt);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    free(jtp);
    return 0;
  }
}
// 80D7B2D: conditional instruction was optimized away because %jtp.4!=0
// 80D7B6B: conditional instruction was optimized away because %jtp.4!=0
// 80D7BE2: conditional instruction was optimized away because %jtp.4!=0

//----- (080D7DED) --------------------------------------------------------
char *__cdecl LYJump(int key)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  int v12; // [esp+1Ch] [ebp-3Ch]
  bool v13; // [esp+23h] [ebp-35h]
  JumpDatum seeking; // [esp+28h] [ebp-30h] BYREF
  char *msg; // [esp+30h] [ebp-28h] BYREF
  int ShortcutNum; // [esp+34h] [ebp-24h]
  int ShortcutTotal; // [esp+38h] [ebp-20h]
  RecallType recall; // [esp+3Ch] [ebp-1Ch]
  int ch_0; // [esp+40h] [ebp-18h]
  JumpTable *jtp; // [esp+44h] [ebp-14h]
  char *cp; // [esp+48h] [ebp-10h]
  char *bp_0; // [esp+4Ch] [ebp-Ch]
  JumpDatum *found; // [esp+50h] [ebp-8h]
  BOOLEAN FirstShortcutRecall; // [esp+57h] [ebp-1h]

  FirstShortcutRecall = 1;
  if ( !JThead )
    return 0;
  for ( jtp = JThead; jtp && jtp->key && jtp->key != key; jtp = jtp->next )
    ;
  if ( jtp )
  {
    if ( !jtp->table )
      jtp->nel = LYRead_Jumpfile(jtp);
    if ( jtp->nel )
    {
      if ( jump_buffer && jtp->shortcut && *jtp->shortcut )
      {
        if ( jtp->shortcut && *jtp->shortcut )
        {
          if ( strlen(jtp->shortcut) > 0x77 )
            jtp->shortcut[119] = 0;
          strcpy(buf_10543, jtp->shortcut);
        }
      }
      else
      {
        buf_10543[0] = 0;
      }
      if ( jtp->history )
        v12 = HTList_count(jtp->history);
      else
        v12 = 0;
      ShortcutTotal = v12;
      if ( jump_buffer && buf_10543[0] )
      {
        recall = ShortcutTotal > 1;
        ShortcutNum = 0;
        FirstShortcutRecall = 0;
      }
      else
      {
        recall = ShortcutTotal > 0;
        ShortcutNum = ShortcutTotal;
        FirstShortcutRecall = 1;
      }
      statusline(jtp->msg);
      ch_0 = LYgetstr(buf_10543, 0, 0x78u, recall);
      if ( ch_0 < 0 )
      {
LABEL_83:
        v9 = gettext("Cancelled!!!");
        HTInfoMsg(v9);
        return 0;
      }
      else
      {
        while ( 1 )
        {
          while ( 1 )
          {
            bp_0 = buf_10543;
            if ( ((*__ctype_b_loc())[(unsigned __int8)key] & 0x200) != 0 )
              v13 = toupper((unsigned __int8)key) == 71;
            else
              v13 = (_BYTE)key == 71;
            if ( v13 && !strncmp(buf_10543, "o ", 2u) )
              ++bp_0;
            bp_0 = LYSkipBlanks(bp_0);
            if ( !*bp_0 && (recall == NORECALL || ch_0 != 256 && ch_0 != 257) )
            {
              buf_10543[0] = 0;
              HTSACopy(&jtp->shortcut, buf_10543);
              v2 = gettext("Cancelled!!!");
              HTInfoMsg(v2);
              return 0;
            }
            if ( recall == NORECALL || ch_0 != 256 )
              break;
            if ( FirstShortcutRecall )
            {
              FirstShortcutRecall = 0;
              ShortcutNum = 0;
            }
            else
            {
              ++ShortcutNum;
            }
            if ( ShortcutNum >= ShortcutTotal )
              ShortcutNum = 0;
            cp = (char *)HTList_objectAt(jtp->history, ShortcutNum);
            if ( !cp )
              goto LABEL_84;
            LYstrncpy(buf_10543, cp, 123);
            if ( jump_buffer && jtp->shortcut && !strcmp(buf_10543, jtp->shortcut) )
            {
              mustshow[0] = 1;
              v3 = gettext("Edit the current shortcut: ");
              statusline(v3);
            }
            else if ( jump_buffer && ShortcutTotal == 2 || !jump_buffer && ShortcutTotal == 1 )
            {
              mustshow[0] = 1;
              v4 = gettext("Edit the previous shortcut: ");
              statusline(v4);
            }
            else
            {
              mustshow[0] = 1;
              v5 = gettext("Edit a previous shortcut: ");
              statusline(v5);
            }
            ch_0 = LYgetstr(buf_10543, 0, 0x7Cu, recall);
            if ( ch_0 < 0 )
              goto LABEL_83;
          }
          if ( recall == NORECALL || ch_0 != 257 )
            break;
          if ( FirstShortcutRecall )
          {
            FirstShortcutRecall = 0;
            ShortcutNum = ShortcutTotal - 1;
          }
          else
          {
            --ShortcutNum;
          }
          if ( ShortcutNum < 0 )
            ShortcutNum = ShortcutTotal - 1;
          cp = (char *)HTList_objectAt(jtp->history, ShortcutNum);
          if ( !cp )
            break;
          LYstrncpy(buf_10543, cp, 123);
          if ( jump_buffer && jtp->shortcut && !strcmp(buf_10543, jtp->shortcut) )
          {
            mustshow[0] = 1;
            v6 = gettext("Edit the current shortcut: ");
            statusline(v6);
          }
          else if ( jump_buffer && ShortcutTotal == 2 || !jump_buffer && ShortcutTotal == 1 )
          {
            mustshow[0] = 1;
            v7 = gettext("Edit the previous shortcut: ");
            statusline(v7);
          }
          else
          {
            mustshow[0] = 1;
            v8 = gettext("Edit a previous shortcut: ");
            statusline(v8);
          }
          ch_0 = LYgetstr(buf_10543, 0, 0x7Cu, recall);
          if ( ch_0 < 0 )
            goto LABEL_83;
        }
LABEL_84:
        seeking.key = bp_0;
        found = (JumpDatum *)bsearch(&seeking, jtp->table, jtp->nel, 8u, LYCompare);
        if ( !found )
        {
          user_message("Unknown target '%s'", buf_10543);
          LYSleepAlert();
        }
        HTSACopy(&jtp->shortcut, bp_0);
        LYAddJumpShortcut(jtp->history, jtp->shortcut);
        if ( found )
          return found->url;
        else
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    msg = 0;
    v1 = gettext("Key '%c' is not mapped to a jump file!");
    HTSprintf0(&msg, v1, key);
    HTAlert(msg);
    if ( msg )
    {
      free(msg);
      msg = 0;
    }
    return 0;
  }
}

//----- (080D8478) --------------------------------------------------------
unsigned int __cdecl LYRead_Jumpfile(JumpTable *jtp)
{
  char *file; // ebx
  FILE *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *url; // esi
  char *key; // ebx
  FILE *v10; // eax
  ssize_t v13; // [esp+20h] [ebp-98h]
  stat st; // [esp+3Ch] [ebp-7Ch] BYREF
  unsigned int i; // [esp+9Ch] [ebp-1Ch]
  char *cp; // [esp+A0h] [ebp-18h]
  int fd; // [esp+A4h] [ebp-14h]
  char *mp; // [esp+A8h] [ebp-10h]
  unsigned int nel; // [esp+ACh] [ebp-Ch]

  if ( !jtp->file || !*jtp->file )
    return 0;
  if ( WWW_TraceFlag[0] )
  {
    file = jtp->file;
    v2 = TraceFP();
    fprintf(v2, "Read Jumpfile %s\n", file);
  }
  if ( stat64((int)jtp->file, (int)&st) >= 0 )
  {
    mp = (char *)calloc(LODWORD(st.st_size) + 1, 1u);
    if ( mp )
    {
      fd = open64(jtp->file, 0);
      if ( fd >= 0 )
      {
        v13 = read(fd, mp, st.st_size);
        if ( v13 >= st.st_size )
        {
          mp[LODWORD(st.st_size)] = 0;
          close(fd);
          nel = 0;
          for ( cp = mp; ; ++cp )
          {
            cp = strchr(cp, 10);
            if ( !cp )
              break;
            ++nel;
          }
          jtp->table = (JumpDatum *)malloc(8 * nel);
          if ( jtp->table )
          {
            jtp->mp = mp;
            cp = jtp->mp;
            i = 0;
            while ( i < nel )
            {
              if ( !strncmp(cp, "<!--", 4u) || !strncmp(cp, "<dl>", 4u) )
              {
                cp = strchr(cp, 10);
                if ( !cp )
                  return i;
                ++cp;
              }
              else
              {
                cp = LYstrstr(cp, "<dt>");
                if ( !cp )
                  return i;
                cp += 4;
                jtp->table[i].key = cp;
                cp = LYstrstr(cp, "<dd>");
                if ( !cp )
                  return i;
                *cp = 0;
                cp += 4;
                cp = LYstrstr(cp, "href=\"");
                if ( !cp )
                  return i;
                cp += 6;
                jtp->table[i].url = cp;
                cp = strchr(cp, 34);
                if ( !cp )
                  return i;
                *cp++ = 0;
                cp = strchr(cp, 10);
                if ( !cp )
                  return i;
                ++cp;
                if ( WWW_TraceFlag[0] )
                {
                  url = jtp->table[i].url;
                  key = jtp->table[i].key;
                  v10 = TraceFP();
                  fprintf(v10, "Read jumpfile[%u] key='%s', url='%s'\n", i, key, url);
                }
                ++i;
                if ( !cp )
                  return i;
              }
            }
            return i;
          }
          else
          {
            v7 = gettext("Out of memory reading jump table!");
            HTAlert(v7);
            if ( mp )
            {
              free(mp);
              mp = 0;
            }
            return 0;
          }
        }
        else
        {
          v6 = gettext("Error reading jump file!");
          HTAlert(v6);
          if ( mp )
          {
            free(mp);
            mp = 0;
          }
          return 0;
        }
      }
      else
      {
        v5 = gettext("Cannot open jump file!");
        HTAlert(v5);
        if ( mp )
        {
          free(mp);
          mp = 0;
        }
        return 0;
      }
    }
    else
    {
      v4 = gettext("Out of memory reading jump file!");
      HTAlert(v4);
      return 0;
    }
  }
  else
  {
    v3 = gettext("Cannot locate jump file!");
    HTAlert(v3);
    return 0;
  }
}

//----- (080D88E6) --------------------------------------------------------
int __cdecl LYCompare(const void *e1, const void *e2)
{
  return strcasecomp(*(const char **)e1, *(const char **)e2);
}

//----- (080D8904) --------------------------------------------------------
int __cdecl showlist(DocInfo *newdoc, BOOLEAN titles)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  const char *v9; // eax
  UIP_t type; // [esp+2Ch] [ebp-8Ch]
  char *v13; // [esp+30h] [ebp-88h]
  HTAnchor *v14; // [esp+38h] [ebp-80h]
  const char *v15; // [esp+3Ch] [ebp-7Ch]
  const char *v16; // [esp+40h] [ebp-78h]
  const char *v17; // [esp+44h] [ebp-74h]
  char *v18; // [esp+48h] [ebp-70h]
  const char *v19; // [esp+4Ch] [ebp-6Ch]
  char *v20; // [esp+50h] [ebp-68h]
  const char *v21; // [esp+5Ch] [ebp-5Ch]
  char *address; // [esp+78h] [ebp-40h]
  HTParentAnchor *parent; // [esp+7Ch] [ebp-3Ch]
  HTChildAnchor *child; // [esp+88h] [ebp-30h]
  void *helper; // [esp+8Ch] [ebp-2Ch] BYREF
  const char *desc; // [esp+90h] [ebp-28h] BYREF
  char *LinkTitle; // [esp+94h] [ebp-24h] BYREF
  char *cp; // [esp+98h] [ebp-20h]
  char *Title; // [esp+9Ch] [ebp-1Ch] BYREF
  char *Address; // [esp+A0h] [ebp-18h] BYREF
  FILE *fp0; // [esp+A4h] [ebp-14h]
  int hidden_links; // [esp+A8h] [ebp-10h]
  int refs; // [esp+ACh] [ebp-Ch]
  int cnt; // [esp+B0h] [ebp-8h]
  BOOLEAN intern_w_post; // [esp+B7h] [ebp-1h]

  Address = 0;
  Title = 0;
  cp = 0;
  LinkTitle = 0;
  intern_w_post = 0;
  desc = "unknown field or link";
  refs = HText_sourceAnchors(HTMainText);
  hidden_links = HText_HiddenLinkCount(HTMainText);
  if ( refs <= 0 && hidden_links > 0 && LYHiddenLinks != 1 )
  {
    v2 = gettext("There are only hidden links from this document.");
    HTUserMsg(v2);
    return -1;
  }
  if ( refs <= 0 && hidden_links <= 0 )
  {
    v3 = gettext("There are no references from this document.");
    HTUserMsg(v3);
    return -1;
  }
  fp0 = InternalPageFP(tempfile_10556, titles == last_titles_10557);
  if ( !fp0 )
    return -1;
  LYLocalFileToURL(&newdoc->address, tempfile_10556);
  if ( titles )
    type = UIP_LIST_PAGE_0;
  else
    type = UIP_ADDRLIST_PAGE_0;
  LYRegisterUIPage(newdoc->address, type);
  last_titles_10557 = titles;
  LYforce_HTML_mode = 1;
  LYforce_no_cache = 1;
  v4 = gettext("List Page");
  BeginInternalPage(fp0, v4, "keystrokes/follow_help.html.gz");
  v5 = HTLoadedDocumentURL();
  HTSACopy(&Address, v5);
  LYEntify(&Address, 0);
  if ( Address && *Address )
    v13 = Address;
  else
    v13 = gettext("this document:");
  v6 = gettext("References in ");
  fprintf(fp0, "%s%s<p>\n", v6, v13);
  if ( Address )
  {
    free(Address);
    Address = 0;
  }
  if ( refs > 0 )
  {
    if ( keypad_mode )
      fprintf(fp0, "<%s compact>\n", "ul");
    else
      fprintf(fp0, "<%s compact>\n", "ol");
    if ( hidden_links > 0 )
    {
      v7 = gettext("Visible links:");
      fprintf(fp0, "<lh><em>%s</em>\n", v7);
    }
  }
  if ( hidden_links > 0 && LYHiddenLinks == 2 )
    hidden_links = 0;
  helper = 0;
  for ( cnt = 1; cnt <= refs; ++cnt )
  {
    child = HText_childNextNumber(cnt, &helper);
    if ( child )
    {
      v14 = HTAnchor_followLink(child);
      parent = HTAnchor_parent(v14);
      address = HTAnchor_address(v14);
      if ( titles )
        v15 = HTAnchor_title(parent);
      else
        v15 = 0;
      if ( titles && child->type && child->dest == v14 && !strncmp(child->type->name, "RelTitle: ", 0xAu) )
      {
        HTSprintf0(&LinkTitle, "(%s)", (const char *)child->type->name + 10);
      }
      else if ( LinkTitle )
      {
        free(LinkTitle);
        LinkTitle = 0;
      }
      HTSACopy(&Address, address);
      if ( address )
        free(address);
      LYEntify(&Address, 1);
      if ( v15 && *v15 )
      {
        LYformTitle(&Title, v15);
        LYEntify(&Title, 1);
        if ( *Title )
        {
          cp = strchr(Address, 35);
        }
        else if ( Title )
        {
          free(Title);
          Title = 0;
        }
      }
      if ( Title && cp )
        v16 = cp + 1;
      else
        v16 = (const char *)&unk_8168E75;
      if ( Title && cp )
        v17 = " - ";
      else
        v17 = (const char *)&unk_8168E75;
      if ( Title )
        v18 = Title;
      else
        v18 = Address;
      if ( parent == (HTParentAnchor *)v14 || !Title )
        v19 = (const char *)&unk_8168E75;
      else
        v19 = "in ";
      if ( LinkTitle )
        v20 = LinkTitle;
      else
        v20 = (char *)&unk_8168E75;
      fprintf(
        fp0,
        "<li><a href=\"%s\"%s>%s%s%s%s%s</a>\n",
        Address,
        (const char *)&unk_8168E75,
        v20,
        v19,
        v18,
        v17,
        v16);
      if ( Address )
      {
        free(Address);
        Address = 0;
      }
      if ( Title )
      {
        free(Title);
        Title = 0;
      }
    }
    else if ( keypad_mode == 3 || keypad_mode == 2 )
    {
      HText_FormDescNumber(cnt, &desc);
      fprintf(fp0, "<li><a id=%d href=\"#%d\">form field</a> = <em>%s</em>\n", cnt, cnt, desc);
    }
  }
  if ( LinkTitle )
  {
    free(LinkTitle);
    LinkTitle = 0;
  }
  if ( hidden_links > 0 )
  {
    if ( refs > 0 )
    {
      if ( keypad_mode )
        fprintf(fp0, "\n</%s>\n\n<p>\n", "ul");
      else
        fprintf(fp0, "\n</%s>\n\n<p>\n", "ol");
    }
    if ( keypad_mode )
      v21 = "ul";
    else
      v21 = "ol continue";
    fprintf(fp0, "<%s compact>\n", v21);
    v8 = gettext("Hidden links:");
    fprintf(fp0, "<lh><em>%s</em>\n", v8);
  }
  for ( cnt = 0; cnt < hidden_links; ++cnt )
  {
    v9 = HText_HiddenLinkAt(HTMainText, cnt);
    HTSACopy(&Address, v9);
    LYEntify(&Address, 0);
    if ( Address && *Address )
    {
      fprintf(fp0, "<li><a href=\"%s\">%s</a>\n", Address, Address);
      if ( !Address )
        continue;
    }
    else if ( !Address )
    {
      continue;
    }
    free(Address);
    Address = 0;
  }
  if ( keypad_mode )
    fprintf(fp0, "\n</%s>\n", "ul");
  else
    fprintf(fp0, "\n</%s>\n", "ol");
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  if ( intern_w_post )
  {
    newdoc->internal_link = 1;
  }
  else
  {
    LYFreePostData(newdoc);
    newdoc->internal_link = 0;
  }
  newdoc->isHEAD = 0;
  newdoc->safe = 0;
  return 0;
}
// 80D8C2B: conditional instruction was optimized away because %dest_intl.4==0
// 80D8C61: conditional instruction was optimized away because %dest_intl.4==0
// 80D8CD9: conditional instruction was optimized away because %dest_intl.4==0
// 80D8EA5: conditional instruction was optimized away because %dest_intl.4==0

//----- (080D9132) --------------------------------------------------------
void __cdecl print_refs(FILE *fp, BOOLEAN titles, int refs)
{
  const char *v3; // [esp+18h] [ebp-30h]
  char *v4; // [esp+1Ch] [ebp-2Ch]
  const char *v5; // [esp+20h] [ebp-28h]
  HTParentAnchor *parent; // [esp+2Ch] [ebp-1Ch]
  HTAnchor *dest; // [esp+30h] [ebp-18h]
  HTChildAnchor *child; // [esp+34h] [ebp-14h]
  void *helper; // [esp+38h] [ebp-10h] BYREF
  const char *desc; // [esp+3Ch] [ebp-Ch] BYREF
  char *address; // [esp+40h] [ebp-8h]
  int cnt; // [esp+44h] [ebp-4h]

  address = 0;
  desc = gettext("unknown field or link");
  helper = 0;
  for ( cnt = 1; cnt <= refs; ++cnt )
  {
    child = HText_childNextNumber(cnt, &helper);
    if ( child )
    {
      dest = HTAnchor_followLink(child);
      if ( dest != (HTAnchor *)child )
      {
        parent = HTAnchor_parent(dest);
        if ( titles )
          v3 = HTAnchor_title(parent);
        else
          v3 = 0;
        address = HTAnchor_address(dest);
        if ( keypad_mode == 1 || keypad_mode == 2 )
          fprintf(fp, "%4d. ", cnt);
        if ( v3 )
          v4 = (char *)v3;
        else
          v4 = address;
        if ( parent == (HTParentAnchor *)dest || !v3 )
          v5 = (const char *)&unk_8168E75;
        else
          v5 = "in ";
        fprintf(fp, "%s%s\n", v5, v4);
        if ( address )
        {
          free(address);
          address = 0;
        }
      }
    }
    else if ( keypad_mode == 3 || keypad_mode == 2 )
    {
      HText_FormDescNumber(cnt, &desc);
      fprintf(fp, "%4d. form field = %s\n", cnt, desc);
    }
  }
}

//----- (080D92D6) --------------------------------------------------------
void __cdecl print_hidden_refs(FILE *fp, int refs, int hidden_links)
{
  const char *v3; // eax
  char *v4; // [esp+10h] [ebp-18h]
  const char *v5; // [esp+14h] [ebp-14h]
  char *address; // [esp+20h] [ebp-8h] BYREF
  int cnt; // [esp+24h] [ebp-4h]

  address = 0;
  v4 = gettext("Hidden links:");
  if ( refs <= 0 )
    v5 = (const char *)&unk_8168E75;
  else
    v5 = "\n";
  fprintf(fp, "%s   %s\n", v5, v4);
  for ( cnt = 0; cnt < hidden_links; ++cnt )
  {
    v3 = HText_HiddenLinkAt(HTMainText, cnt);
    HTSACopy(&address, v3);
    if ( !address || !*address )
    {
      if ( !address )
        continue;
LABEL_13:
      free(address);
      address = 0;
      continue;
    }
    if ( keypad_mode == 1 || keypad_mode == 2 )
      fprintf(fp, "%4d. ", refs + cnt + 1);
    fprintf(fp, "%s\n", address);
    if ( address )
      goto LABEL_13;
  }
}

//----- (080D93FE) --------------------------------------------------------
void __cdecl printlist(FILE *fp, BOOLEAN titles)
{
  char *v2; // [esp+8h] [ebp-20h]
  char *v3; // [esp+8h] [ebp-20h]
  int hidden_links; // [esp+20h] [ebp-8h]
  int refs; // [esp+24h] [ebp-4h]

  refs = HText_sourceAnchors(HTMainText);
  if ( refs > 0 || LYHiddenLinks == 1 )
  {
    hidden_links = HText_HiddenLinkCount(HTMainText);
    if ( refs > 0 || hidden_links > 0 )
    {
      if ( keypad_mode == 1 || keypad_mode == 2 || keypad_mode == 3 || keypad_mode == 2 )
      {
        v2 = gettext("References");
        fprintf(fp, "\n%s\n\n", v2);
      }
      if ( LYHiddenLinks == 2 )
        hidden_links = 0;
      if ( hidden_links > 0 )
      {
        v3 = gettext("Visible links");
        fprintf(fp, "   %s\n", v3);
      }
      print_refs(fp, titles, refs);
      if ( hidden_links > 0 )
        print_hidden_refs(fp, refs, hidden_links);
    }
  }
  LYPrintImgMaps(fp);
}

//----- (080D951C) --------------------------------------------------------
void __cdecl remember_alloced(void *ptr)
{
  if ( !alloced )
    alloced = HTList_new();
  HTList_addObject(alloced, ptr);
}

//----- (080D954C) --------------------------------------------------------
void __cdecl add_environment_value(const char *env_value)
{
  int v1; // ecx

  if ( envc == envc_size )
  {
    envc_size += 10;
    if ( env )
    {
      env = (char **)realloc(env, 4 * (envc_size + 2));
    }
    else
    {
      env = (char **)malloc(4 * (envc_size + 2));
      remember_alloced(env);
    }
    if ( !env )
      outofmem("./LYCgi.c", "LYCgi");
  }
  v1 = envc;
  env[envc] = (char *)env_value;
  envc = v1 + 1;
  env[v1 + 1] = 0;
}

//----- (080D9616) --------------------------------------------------------
void __cdecl add_lynxcgi_environment(const char *variable_name)
{
  char *add_value; // [esp+20h] [ebp-8h] BYREF
  char *env_value; // [esp+24h] [ebp-4h]

  env_value = LYGetEnv(variable_name);
  if ( env_value )
  {
    add_value = 0;
    HTSprintf0(&add_value, "%s=%s", variable_name, env_value);
    add_environment_value(add_value);
    remember_alloced(add_value);
  }
}

//----- (080D9670) --------------------------------------------------------
BOOLEAN __cdecl can_exec_cgi(const char *linktext, const char *linkargs)
{
  char *v2; // edx
  char *p; // [esp+24h] [ebp-14h]
  char *command; // [esp+28h] [ebp-10h] BYREF
  char *message; // [esp+2Ch] [ebp-Ch] BYREF
  const char *format; // [esp+30h] [ebp-8h]
  BOOLEAN result; // [esp+37h] [ebp-1h]

  format = gettext("Do you want to execute \"%s\"?");
  message = 0;
  command = 0;
  result = 1;
  v2 = HTLoadedDocumentURL();
  if ( !exec_ok(v2, linktext, 2) )
    return 0;
  if ( user_mode <= 1 )
  {
    HTSACopy(&command, linktext);
    if ( linkargs && *linkargs )
      HTSprintf(&command, " %s", linkargs);
    HTUnEscape(command);
    for ( p = command; *p; ++p )
    {
      if ( *p == 43 )
        *p = 32;
    }
    HTSprintf0(&message, format, command);
    result = HTConfirm(message);
    if ( message )
    {
      free(message);
      message = 0;
    }
    if ( command )
    {
      free(command);
      command = 0;
    }
  }
  return result;
}

//----- (080D979C) --------------------------------------------------------
int __cdecl LYLoadCGI(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  char *v4; // eax
  char *v5; // eax
  int *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  int *v9; // eax
  char *v10; // ebx
  FILE *v11; // eax
  char *v12; // ebx
  size_t v13; // eax
  char *v14; // ebx
  char *v15; // esi
  FILE *v16; // eax
  char *v17; // eax
  int *v18; // eax
  char *v19; // ebx
  FILE *v20; // eax
  char *v21; // ebx
  char *v22; // esi
  FILE *v23; // eax
  FILE *v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *name; // esi
  char *v28; // ebx
  char *v29; // eax
  char *v30; // eax
  int *v31; // eax
  char *v32; // ebx
  FILE *v33; // eax
  char *v34; // eax
  int *v35; // eax
  char *v36; // ebx
  FILE *v37; // eax
  FILE *v38; // eax
  char *post_content_type; // ebx
  FILE *v40; // eax
  FILE *v41; // eax
  FILE *v42; // eax
  int *v43; // eax
  char *v44; // ebx
  FILE *v45; // eax
  FILE *v46; // eax
  FILE *v47; // eax
  int *v48; // eax
  char *v49; // ebx
  FILE *v50; // eax
  FILE *v51; // eax
  int v52; // eax
  int v53; // eax
  int v54; // eax
  int v55; // eax
  char *v56; // eax
  char *v57; // eax
  char *v58; // eax
  int *v59; // eax
  char *v60; // ebx
  FILE *v61; // eax
  char *v62; // eax
  char *v63; // eax
  int *v64; // eax
  char *v65; // ebx
  FILE *v66; // eax
  char *v68; // [esp+4h] [ebp-524h]
  char *v69; // [esp+4h] [ebp-524h]
  char *v70; // [esp+4h] [ebp-524h]
  int v72; // [esp+20h] [ebp-508h]
  char *v73; // [esp+28h] [ebp-500h]
  int len; // [esp+2Ch] [ebp-4FCh]
  stat stat_buf; // [esp+48h] [ebp-4E0h] BYREF
  int fd2[2]; // [esp+A8h] [ebp-480h] BYREF
  int fd1[2]; // [esp+B0h] [ebp-478h] BYREF
  char *cr; // [esp+B8h] [ebp-470h]
  int exec_errno; // [esp+BCh] [ebp-46Ch]
  char **cur_argv; // [esp+C0h] [ebp-468h]
  int argv_cnt; // [esp+C4h] [ebp-464h]
  char **argv; // [esp+C8h] [ebp-460h]
  int total_written; // [esp+CCh] [ebp-45Ch]
  int remaining; // [esp+D0h] [ebp-458h]
  int written; // [esp+D4h] [ebp-454h]
  int total_chars; // [esp+D8h] [ebp-450h]
  int chars; // [esp+DCh] [ebp-44Ch]
  char *tmp; // [esp+E0h] [ebp-448h] BYREF
  int wstatus; // [esp+E4h] [ebp-444h] BYREF
  int pid; // [esp+E8h] [ebp-440h]
  HTStream *target; // [esp+ECh] [ebp-43Ch]
  HTFormat format_in; // [esp+F0h] [ebp-438h]
  char *path_translated; // [esp+F4h] [ebp-434h] BYREF
  char *pgm_buff; // [esp+F8h] [ebp-430h] BYREF
  char *path_info; // [esp+FCh] [ebp-42Ch] BYREF
  char *document_root; // [esp+100h] [ebp-428h] BYREF
  char *orig_pgm; // [esp+104h] [ebp-424h] BYREF
  int statrv; // [esp+108h] [ebp-420h]
  char *pgm_args; // [esp+10Ch] [ebp-41Ch]
  char *pgm; // [esp+110h] [ebp-418h] BYREF
  char *cp; // [esp+114h] [ebp-414h] BYREF
  int status; // [esp+118h] [ebp-410h]
  char buf[1024]; // [esp+11Ch] [ebp-40Ch] BYREF
  unsigned int v104; // [esp+51Ch] [ebp-Ch]

  v104 = __readgsdword(0x14u);
  status = 0;
  pgm = 0;
  pgm_args = 0;
  orig_pgm = 0;
  document_root = 0;
  path_info = 0;
  pgm_buff = 0;
  if ( !arg || !*arg || strlen(arg) <= 8 )
  {
    v4 = gettext("Bad request!");
    HTAlert(v4);
    status = -2;
    return -2;
  }
  if ( !strncmp(arg, "lynxcgi://localhost", 0x13u) )
    HTSACopy(&pgm, arg + 19);
  else
    HTSACopy(&pgm, arg + 8);
  cp = strchr(pgm, 63);
  if ( cp )
  {
    v5 = cp;
    *cp = 0;
    cp = v5 + 1;
    pgm_args = v5 + 1;
  }
  HTSACopy(&orig_pgm, pgm);
  cp = trimPoundSelector(pgm);
  if ( cp )
    pgm_args = 0;
  HTUnEscape(pgm);
  statrv = stat64((int)pgm, (int)&stat_buf);
  if ( statrv < 0 )
  {
    HTSACopy(&pgm_buff, pgm);
    while ( 1 )
    {
      if ( statrv >= 0 )
      {
        statrv = stat64((int)pgm_buff, (int)&stat_buf);
        if ( statrv >= 0 )
          break;
      }
      cp = strrchr(pgm_buff, 47);
      if ( !cp )
      {
        if ( WWW_TraceFlag[0] )
        {
          v6 = __errno_location();
          v7 = strerror(*v6);
          v8 = TraceFP();
          fprintf(v8, "LYNXCGI: %s: %s\n", "strrchr(pgm_buff, '/') returned NULL", v7);
        }
        break;
      }
      *cp = 0;
      statrv = 1;
    }
    if ( statrv >= 0 )
    {
      v12 = pgm;
      v13 = strlen(pgm_buff);
      HTSACopy(&path_info, &v12[v13]);
      strcpy(pgm, pgm_buff);
      if ( WWW_TraceFlag[0] )
      {
        v14 = path_info;
        v15 = pgm_buff;
        v16 = TraceFP();
        fprintf(v16, "LYNXCGI: stat() of %s succeeded, path_info=\"%s\".\n", v15, v14);
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      v9 = __errno_location();
      v10 = strerror(*v9);
      v11 = TraceFP();
      fprintf(v11, "LYNXCGI: %s: %s\n", "stat() of pgm_buff failed", v10);
    }
    if ( pgm_buff )
    {
      free(pgm_buff);
      pgm_buff = 0;
    }
  }
  if ( statrv )
  {
    v17 = gettext("Unable to access cgi script");
    HTAlert(v17);
    if ( WWW_TraceFlag[0] )
    {
      v18 = __errno_location();
      v19 = strerror(*v18);
      v20 = TraceFP();
      fprintf(v20, "LYNXCGI: %s: %s\n", "stat() failed", v19);
    }
    status = -4;
LABEL_196:
    if ( path_info )
    {
      free(path_info);
      path_info = 0;
    }
    if ( pgm )
    {
      free(pgm);
      pgm = 0;
    }
    if ( orig_pgm )
    {
      free(orig_pgm);
      orig_pgm = 0;
    }
    return status;
  }
  if ( (stat_buf.st_mode & 0xF000) == 0x8000 && (stat_buf.st_mode & 0x49) != 0 )
  {
    if ( !path_info
      || anAnchor == HTMainAnchor
      || reloading[0] && anAnchor->document
      || (v68 = HTLoadedDocumentURL(), !strcmp(arg, v68))
      || !HText_AreDifferent(anAnchor, arg)
      || !HTUnEscape(orig_pgm)
      || can_exec_cgi(orig_pgm, linkargs) )
    {
      if ( no_lynxcgi )
      {
        v25 = gettext("cgi support has been disabled.");
        HTUserMsg(v25);
        status = -29999;
      }
      else if ( !no_bookmark_exec
             || anAnchor == HTMainAnchor
             || reloading[0] && anAnchor->document
             || (v69 = HTLoadedDocumentURL(), !strcmp(arg, v69))
             || !HText_AreDifferent(anAnchor, arg)
             || !HTLoadedDocumentBookmark() )
      {
        if ( anAnchor == HTMainAnchor
          || reloading[0] && anAnchor->document
          || (v70 = HTLoadedDocumentURL(), !strcmp(arg, v70))
          || !HText_AreDifferent(anAnchor, arg)
          || can_exec_cgi(pgm, pgm_args) )
        {
          target = 0;
          if ( anAnchor->isHEAD || keep_mime_headers )
            format_in = HTAtom_for("text/plain");
          else
            format_in = HTAtom_for("www/mime");
          target = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
          if ( target )
          {
            if ( anAnchor->post_data && pipe(fd1) < 0 )
            {
              v30 = gettext("Unable to set up connection.");
              HTAlert(v30);
              if ( WWW_TraceFlag[0] )
              {
                v31 = __errno_location();
                v32 = strerror(*v31);
                v33 = TraceFP();
                fprintf(v33, "LYNXCGI: %s: %s\n", "pipe() failed", v32);
              }
              status = -3;
            }
            else if ( pipe(fd2) >= 0 )
            {
              if ( first_time_11222 )
              {
                first_time_11222 = 0;
                add_environment_value("REMOTE_HOST=localhost");
                add_environment_value("REMOTE_ADDR=127.0.0.1");
                HTSprintf0(&user_agent, "HTTP_USER_AGENT=%s/%s libwww/%s", "Lynx", "2.8.7dev.11", HTLibraryVersion);
                add_environment_value(user_agent);
                HTSprintf0(&server_software, "SERVER_SOFTWARE=%s/%s", "Lynx", "2.8.7dev.11");
                add_environment_value(server_software);
              }
              fflush(stdout);
              fflush(stderr);
              if ( WWW_TraceFlag[0] )
              {
                v38 = TraceFP();
                fflush(v38);
              }
              pid = fork();
              if ( pid <= 0 )
              {
                if ( !pid )
                {
                  argv = 0;
                  argv_cnt = 3;
                  cur_argv = 0;
                  close(fd2[0]);
                  v52 = fileno(stdout);
                  dup2(fd2[1], v52);
                  v53 = fileno(stderr);
                  dup2(fd2[1], v53);
                  close(fd2[1]);
                  if ( language && *language )
                  {
                    HTSprintf0(&accept_language, "HTTP_ACCEPT_LANGUAGE=%s", language);
                    add_environment_value(accept_language);
                  }
                  if ( pref_charset && *pref_charset )
                  {
                    cp = 0;
                    HTSACopy(&cp, "HTTP_ACCEPT_CHARSET=");
                    HTSACat(&cp, pref_charset);
                    add_environment_value(cp);
                  }
                  if ( anAnchor->post_data && anAnchor->post_content_type )
                  {
                    cp = 0;
                    HTSACopy(&cp, "CONTENT_TYPE=");
                    HTSACat(&cp, anAnchor->post_content_type);
                    add_environment_value(cp);
                  }
                  if ( anAnchor->post_data )
                  {
                    close(fd1[1]);
                    v54 = fileno(stdin);
                    dup2(fd1[0], v54);
                    close(fd1[0]);
                    add_environment_value("REQUEST_METHOD=POST");
                    if ( anAnchor->post_data )
                      len = anAnchor->post_data->len;
                    else
                      len = 0;
                    HTSprintf0(&post_len, "CONTENT_LENGTH=%d", len);
                    add_environment_value(post_len);
                  }
                  else
                  {
                    v55 = fileno(stdin);
                    close(v55);
                    if ( anAnchor->isHEAD )
                      add_environment_value("REQUEST_METHOD=HEAD");
                  }
                  if ( pgm_args )
                  {
                    for ( cp = pgm_args; *cp; ++cp )
                    {
                      if ( *cp == 43 )
                        ++argv_cnt;
                    }
                  }
                  argv = (char **)malloc(4 * argv_cnt);
                  if ( !argv )
                    outofmem("./LYCgi.c", "LYCgi");
                  cur_argv = argv + 1;
                  if ( pgm_args )
                  {
                    if ( is_www_index )
                    {
                      add_environment_value("REQUEST_METHOD=SEARCH");
                    }
                    else if ( !anAnchor->isHEAD && !anAnchor->post_data )
                    {
                      add_environment_value("REQUEST_METHOD=GET");
                    }
                    cp = 0;
                    HTSACopy(&cp, "QUERY_STRING=");
                    HTSACat(&cp, pgm_args);
                    add_environment_value(cp);
                    cp = pgm_args;
                    cr = pgm_args;
                    while ( *cp )
                    {
                      if ( *cp == 43 )
                      {
                        v57 = cp;
                        *cp = 0;
                        cp = v57 + 1;
                        v58 = HTUnEscape(cr);
                        *cur_argv++ = v58;
                        cr = cp;
                      }
                      ++cp;
                    }
                    v56 = HTUnEscape(cr);
                    *cur_argv++ = v56;
                  }
                  else if ( !anAnchor->isHEAD && !anAnchor->post_data )
                  {
                    add_environment_value("REQUEST_METHOD=GET");
                  }
                  *cur_argv = 0;
                  *argv = pgm;
                  if ( LYCgiDocumentRoot )
                  {
                    cp = 0;
                    HTSACopy(&cp, "DOCUMENT_ROOT=");
                    HTSACat(&cp, LYCgiDocumentRoot);
                    add_environment_value(cp);
                  }
                  if ( path_info )
                  {
                    cp = 0;
                    HTSACopy(&cp, "PATH_INFO=");
                    HTSACat(&cp, path_info);
                    add_environment_value(cp);
                  }
                  if ( LYCgiDocumentRoot )
                  {
                    if ( path_info )
                    {
                      HTSACopy(&document_root, LYCgiDocumentRoot);
                      LYTrimHtmlSep(document_root);
                      path_translated = document_root;
                      HTSACat(&path_translated, path_info);
                      cp = 0;
                      HTSACopy(&cp, "PATH_TRANSLATED=");
                      HTSACat(&cp, path_translated);
                      add_environment_value(cp);
                      if ( path_translated )
                      {
                        free(path_translated);
                        path_translated = 0;
                      }
                    }
                  }
                  execve(*argv, argv, env);
                  exec_errno = *__errno_location();
                  if ( WWW_TraceFlag[0] )
                  {
                    v59 = __errno_location();
                    v60 = strerror(*v59);
                    v61 = TraceFP();
                    fprintf(v61, "LYNXCGI: %s: %s\n", "execve failed", v60);
                  }
                  puts("Content-Type: text/plain\r\n\r");
                  if ( !anAnchor->isHEAD )
                  {
                    printf("exec of %s failed", pgm);
                    v62 = strerror(exec_errno);
                    printf(": %s.\r\n", v62);
                  }
                  fflush(stdout);
                  fflush(stderr);
                  _exit(1);
                }
                v63 = gettext("Unable to make connection");
                HTAlert(v63);
                if ( WWW_TraceFlag[0] )
                {
                  v64 = __errno_location();
                  v65 = strerror(*v64);
                  v66 = TraceFP();
                  fprintf(v66, "LYNXCGI: %s: %s\n", "fork() failed", v65);
                }
                status = -204;
                close(fd1[0]);
                close(fd1[1]);
                close(fd2[0]);
                close(fd2[1]);
                status = -1;
              }
              else
              {
                close(fd2[1]);
                if ( anAnchor->post_data )
                {
                  total_written = 0;
                  close(fd1[0]);
                  if ( WWW_TraceFlag[0] )
                  {
                    post_content_type = anAnchor->post_content_type;
                    v40 = TraceFP();
                    fprintf(v40, "LYNXCGI: Doing post, content-type '%s'\n", post_content_type);
                    if ( WWW_TraceFlag[0] )
                    {
                      v41 = TraceFP();
                      fprintf(v41, "LYNXCGI: Writing:\n");
                    }
                    trace_bstring(anAnchor->post_data);
                    if ( WWW_TraceFlag[0] )
                    {
                      v42 = TraceFP();
                      fprintf(v42, "----------------------------------\n");
                    }
                  }
                  if ( anAnchor->post_data )
                    v72 = anAnchor->post_data->len;
                  else
                    v72 = 0;
                  remaining = v72;
                  while ( 1 )
                  {
                    v73 = anAnchor->post_data ? anAnchor->post_data->str : 0;
                    written = write(fd1[1], &v73[total_written], remaining);
                    if ( !written )
                      break;
                    if ( written >= 0 )
                    {
                      if ( WWW_TraceFlag[0] )
                      {
                        v46 = TraceFP();
                        fprintf(v46, "LYNXCGI: Wrote %d bytes of POST data.\n", written);
                      }
                      total_written += written;
                      remaining -= written;
                      if ( !remaining )
                        break;
                    }
                    else if ( *__errno_location() != 4 )
                    {
                      if ( WWW_TraceFlag[0] )
                      {
                        v43 = __errno_location();
                        v44 = strerror(*v43);
                        v45 = TraceFP();
                        fprintf(v45, "LYNXCGI: %s: %s\n", "write() of POST data failed", v44);
                      }
                      break;
                    }
                  }
                  if ( remaining && WWW_TraceFlag[0] )
                  {
                    v47 = TraceFP();
                    fprintf(v47, "LYNXCGI: %d bytes remain unwritten!\n", remaining);
                  }
                  close(fd1[1]);
                }
                total_chars = 0;
                HTReadProgress(0LL, 0LL);
                while ( 1 )
                {
                  chars = read(fd2[0], buf, 0x400u);
                  if ( !chars )
                    break;
                  if ( chars >= 0 )
                  {
                    total_chars += chars;
                    HTReadProgress(total_chars, 0LL);
                    if ( WWW_TraceFlag[0] )
                    {
                      v51 = TraceFP();
                      fprintf(v51, "LYNXCGI: Rx: %.*s\n", chars, buf);
                    }
                    target->isa->put_block(target, buf, chars);
                  }
                  else if ( *__errno_location() != 4 )
                  {
                    if ( WWW_TraceFlag[0] )
                    {
                      v48 = __errno_location();
                      v49 = strerror(*v48);
                      v50 = TraceFP();
                      fprintf(v50, "LYNXCGI: %s: %s\n", "read() of CGI output failed", v49);
                    }
                    break;
                  }
                }
                if ( chars >= 0 || total_chars )
                {
                  if ( chars )
                    status = 206;
                  else
                    status = 200;
                }
                else
                {
                  status = -29999;
                  target->isa->_abort(target, 0);
                  target = 0;
                }
                while ( waitpid(pid, &wstatus, 0) == -1 && *__errno_location() == 4 )
                  ;
                close(fd2[0]);
              }
            }
            else
            {
              v34 = gettext("Unable to set up connection.");
              HTAlert(v34);
              if ( WWW_TraceFlag[0] )
              {
                v35 = __errno_location();
                v36 = strerror(*v35);
                v37 = TraceFP();
                fprintf(v37, "LYNXCGI: %s: %s\n", "pipe() failed", v36);
              }
              close(fd1[0]);
              close(fd1[1]);
              status = -3;
            }
          }
          else
          {
            tmp = 0;
            name = format_out->name;
            v28 = format_in->name;
            v29 = gettext("Sorry, no known way of converting %s to %s.");
            HTSprintf0(&tmp, v29, v28, name);
            HTAlert(tmp);
            if ( tmp )
            {
              free(tmp);
              tmp = 0;
            }
            status = -29999;
          }
          if ( target )
            target->isa->_free(target);
        }
        else
        {
          status = -29999;
        }
      }
      else
      {
        v26 = gettext("Execution via bookmarks is disabled.");
        HTUserMsg(v26);
        status = -29999;
      }
    }
    else
    {
      status = -29999;
    }
    goto LABEL_196;
  }
  wstatus = 0;
  if ( !path_info )
  {
    LYLocalFileToURL((char **)&wstatus, orig_pgm);
    if ( WWW_TraceFlag[0] )
    {
      v24 = TraceFP();
      fprintf(v24, "%s is not an executable file, passing the buck.\n", arg);
    }
    status = HTLoadFile((const char *)wstatus, anAnchor, format_out, sink);
    if ( wstatus )
    {
      free((void *)wstatus);
      wstatus = 0;
    }
    goto LABEL_196;
  }
  if ( WWW_TraceFlag[0] )
  {
    v21 = pgm;
    v22 = orig_pgm;
    v23 = TraceFP();
    fprintf(v23, "%s is not a file and %s not an executable, giving up.\n", v22, v21);
  }
  if ( path_info )
  {
    free(path_info);
    path_info = 0;
  }
  if ( pgm )
  {
    free(pgm);
    pgm = 0;
  }
  if ( orig_pgm )
  {
    free(orig_pgm);
    orig_pgm = 0;
  }
  status = -4;
  return -4;
}

//----- (080DAEAC) --------------------------------------------------------
void __cdecl final_perror(const char *msg, BOOLEAN clean_flag)
{
  int saved_errno; // [esp+14h] [ebp-4h]

  saved_errno = *__errno_location();
  if ( LYCursesON[0] )
  {
    if ( clean_flag )
      cleanup();
    else
      stop_curses();
  }
  *__errno_location() = saved_errno;
  perror(msg);
}

//----- (080DAEF6) --------------------------------------------------------
void __cdecl __noreturn exit_with_perror(const char *msg)
{
  final_perror(msg, 1);
  exit_immediately(1);
}

//----- (080DAF1D) --------------------------------------------------------
BOOLEAN __cdecl lookup_link(char *target)
{
  char *v1; // eax
  BOOLEAN result; // [esp+18h] [ebp-10h]
  char *line; // [esp+1Ch] [ebp-Ch] BYREF
  char *buffer; // [esp+20h] [ebp-8h] BYREF
  FILE *ifp; // [esp+24h] [ebp-4h]

  buffer = 0;
  line = 0;
  result = 0;
  ifp = (FILE *)fopen64("traverse.dat", "r");
  if ( ifp )
  {
    HTSprintf0(&line, "%s\n", target);
    while ( LYSafeGets(&buffer, ifp) )
    {
      if ( !strcmp(line, buffer) )
      {
        result = 1;
        break;
      }
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
    LYCloseInput(ifp);
    return result;
  }
  else
  {
    ifp = LYNewTxtFile("traverse.dat");
    if ( !ifp )
    {
      v1 = gettext("Unable to open traversal file.");
      exit_with_perror(v1);
    }
    LYCloseOutput(ifp);
    return 0;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080DB02E) --------------------------------------------------------
void __cdecl add_to_table(char *target)
{
  char *v1; // eax
  FILE *ifp; // [esp+24h] [ebp-4h]

  ifp = LYAppendToTxtFile("traverse.dat");
  if ( !ifp )
  {
    v1 = gettext("Unable to open traversal file.");
    exit_with_perror(v1);
  }
  fprintf(ifp, "%s\n", target);
  LYCloseOutput(ifp);
}

//----- (080DB084) --------------------------------------------------------
void __cdecl add_to_traverse_list(char *fname, char *prev_link_name)
{
  char *v2; // eax
  FILE *ifp; // [esp+24h] [ebp-4h]

  ifp = LYAppendToTxtFile("traverse2.dat");
  if ( !ifp )
  {
    v2 = gettext("Unable to open traversal found file.");
    exit_with_perror(v2);
  }
  fprintf(ifp, "%s\t%s\n", fname, prev_link_name);
  LYCloseOutput(ifp);
}

//----- (080DB0E1) --------------------------------------------------------
void dump_traversal_history()
{
  char *v0; // eax
  char *v1; // ebx
  char *v2; // eax
  FILE *ifp; // [esp+1Ch] [ebp-Ch]
  int x; // [esp+20h] [ebp-8h]

  if ( nhist > 0 )
  {
    ifp = LYAppendToTxtFile("traverse.dat");
    if ( ifp )
    {
      v1 = gettext("here is a list of the history stack so that you may rebuild");
      v2 = gettext("TRAVERSAL WAS INTERRUPTED");
      fprintf(ifp, "\n\n%s\n\n\t    %s\n\n", v2, v1);
      for ( x = nhist - 1; x >= 0; --x )
        fprintf(ifp, "%s\t%s\n", history[x].hdoc.title, history[x].hdoc.address);
      LYCloseOutput(ifp);
    }
    else
    {
      v0 = gettext("Unable to open traversal file.");
      final_perror(v0, 0);
    }
  }
}

//----- (080DB1C6) --------------------------------------------------------
void __cdecl add_to_reject_list(char *target)
{
  FILE *v1; // eax
  char *v2; // eax
  FILE *ifp; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "add_to_reject_list(%s)\n", target);
  }
  ifp = LYAppendToTxtFile("reject.dat");
  if ( !ifp )
  {
    v2 = gettext("Unable to open reject file.");
    exit_with_perror(v2);
  }
  fprintf(ifp, "%s\n", target);
  LYCloseOutput(ifp);
}

//----- (080DB245) --------------------------------------------------------
BOOLEAN __cdecl lookup_reject(char *target)
{
  FILE *v1; // edx
  int result; // [esp+24h] [ebp-14h]
  int len; // [esp+28h] [ebp-10h]
  char *line; // [esp+2Ch] [ebp-Ch] BYREF
  char *buffer; // [esp+30h] [ebp-8h] BYREF
  FILE *ifp; // [esp+34h] [ebp-4h]

  buffer = 0;
  line = 0;
  result = 0;
  ifp = (FILE *)fopen64("reject.dat", "r");
  if ( !ifp )
    return 0;
  HTSprintf0(&line, "%s", target);
  while ( LYSafeGets(&buffer, ifp) && !result )
  {
    LYTrimTrailing(buffer);
    len = strlen(buffer);
    if ( len > 0 )
    {
      if ( buffer[len - 1] == 42 )
      {
        if ( len == 1 || !strncmp(line, buffer, len - 1) )
          result = 1;
      }
      else if ( !strcmp(line, buffer) )
      {
        result = 1;
      }
    }
  }
  if ( buffer )
  {
    free(buffer);
    buffer = 0;
  }
  if ( line )
  {
    free(line);
    line = 0;
  }
  LYCloseInput(ifp);
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "lookup_reject(%s) -> %d\n", target, result);
  }
  return result;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080DB3BC) --------------------------------------------------------
int __cdecl EditBinding(int xlkc)
{
  int v3; // [esp+8h] [ebp-1Ch]
  int v4; // [esp+Ch] [ebp-18h]
  int v5; // [esp+10h] [ebp-14h]
  int c; // [esp+18h] [ebp-Ch]
  int xleac; // [esp+1Ch] [ebp-8h]

  c = xlkc & 0x7FF;
  if ( xlkc == -1 )
    return 0;
  if ( (xlkc & 0x8000) != 0 )
    return BYTE1(xlkc) & 0x7F;
  if ( (xlkc & 0x4000) != 0 )
  {
    if ( (xlkc & 0x7FFu) > 0x111 )
      v3 = 31;
    else
      v3 = Mod1Binding[c];
    xleac = v3;
  }
  else if ( (xlkc & 0x2000) != 0 )
  {
    if ( (xlkc & 0x7FFu) > 0x111 )
      v4 = 31;
    else
      v4 = Mod2Binding[c];
    xleac = v4;
  }
  else if ( (xlkc & 0x1000) != 0 )
  {
    if ( (xlkc & 0x7FFu) > 0x111 )
      v5 = 31;
    else
      v5 = Mod3Binding[c];
    xleac = v5;
  }
  else
  {
    xleac = LYLineEditors[current_lineedit][c];
  }
  if ( xleac == 31 )
    return LYLineEditors[current_lineedit][c];
  else
    return xleac;
}
// 80DB3F6: conditional instruction was optimized away because %xlkc.4!=FFFFFFFF

//----- (080DB525) --------------------------------------------------------
BOOLEAN __cdecl LYRemapEditBinding(int xlkc, int lec, int select_edi)
{
  int c; // [esp+8h] [ebp-Ch]
  int j; // [esp+Ch] [ebp-8h]
  BOOLEAN success; // [esp+13h] [ebp-1h]

  c = xlkc & 0x7FF;
  success = 0;
  if ( xlkc < 0 || (xlkc & 0x800) != 0 || (xlkc & 0x7FFu) > 0x295 )
    return 0;
  if ( (xlkc & 0x4000) != 0 )
  {
    if ( (xlkc & 0x7FFu) <= 0x111 )
    {
      Mod1Binding[c] = lec;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (xlkc & 0x2000) != 0 )
  {
    if ( (xlkc & 0x7FFu) <= 0x111 )
    {
      Mod2Binding[c] = lec;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (xlkc & 0x1000) != 0 )
  {
    if ( (xlkc & 0x7FFu) <= 0x111 )
    {
      Mod3Binding[c] = lec;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else if ( (unsigned int)lec <= 0xFF )
  {
    if ( select_edi <= 0 )
    {
      for ( j = 0; LYLineeditNames[j]; ++j )
      {
        success = 1;
        if ( select_edi >= 0 || select_edi + j + 1 )
          LYLineEditors[j][c] = lec;
      }
    }
    else if ( (unsigned int)select_edi <= 2 )
    {
      LYLineEditors[select_edi - 1][c] = lec;
      return 1;
    }
    return success;
  }
  else
  {
    return 0;
  }
}

//----- (080DB695) --------------------------------------------------------
int __cdecl LYKeyForEditAction(int lec)
{
  int v3; // [esp+4h] [ebp-28h]
  int v4; // [esp+8h] [ebp-24h]
  int v5; // [esp+Ch] [ebp-20h]
  int v6; // [esp+10h] [ebp-1Ch]
  int v7; // [esp+14h] [ebp-18h]
  int v8; // [esp+18h] [ebp-14h]
  int i; // [esp+24h] [ebp-8h]

  for ( i = 97; i >= 0; i = v3 )
  {
    if ( LYLineEditors[current_lineedit][i] == lec )
      return i;
    if ( i == 122 )
    {
      v3 = 32;
    }
    else
    {
      if ( i == 96 )
      {
        v4 = 123;
      }
      else
      {
        if ( i == 126 )
        {
          v5 = 0;
        }
        else
        {
          if ( i == 31 )
          {
            v6 = 256;
          }
          else
          {
            if ( i == 659 )
            {
              v7 = 127;
            }
            else
            {
              if ( i == 255 )
                v8 = -1;
              else
                v8 = i + 1;
              v7 = v8;
            }
            v6 = v7;
          }
          v5 = v6;
        }
        v4 = v5;
      }
      v3 = v4;
    }
  }
  return -1;
}

//----- (080DB778) --------------------------------------------------------
int __cdecl LYEditKeyForAction(int lac, int *pmodkey)
{
  int v2; // eax
  int v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // edx
  int v12; // edx
  int v13; // edx
  int v14; // edx
  int v15; // eax
  int v16; // edx
  int v17; // edx
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v23; // [esp+8h] [ebp-BCh]
  int v24; // [esp+10h] [ebp-B4h]
  int v25; // [esp+14h] [ebp-B0h]
  int v26; // [esp+18h] [ebp-ACh]
  int v27; // [esp+1Ch] [ebp-A8h]
  int v28; // [esp+20h] [ebp-A4h]
  int v29; // [esp+24h] [ebp-A0h]
  int v30; // [esp+28h] [ebp-9Ch]
  int v31; // [esp+30h] [ebp-94h]
  int v32; // [esp+38h] [ebp-8Ch]
  int v33; // [esp+3Ch] [ebp-88h]
  int v34; // [esp+40h] [ebp-84h]
  int v35; // [esp+44h] [ebp-80h]
  int v36; // [esp+48h] [ebp-7Ch]
  int v37; // [esp+4Ch] [ebp-78h]
  int v38; // [esp+50h] [ebp-74h]
  int v39; // [esp+58h] [ebp-6Ch]
  int v40; // [esp+60h] [ebp-64h]
  int v41; // [esp+64h] [ebp-60h]
  int v42; // [esp+68h] [ebp-5Ch]
  int v43; // [esp+6Ch] [ebp-58h]
  int v44; // [esp+70h] [ebp-54h]
  int v45; // [esp+74h] [ebp-50h]
  int v46; // [esp+78h] [ebp-4Ch]
  int v47; // [esp+80h] [ebp-44h]
  int v48; // [esp+88h] [ebp-3Ch]
  int v49; // [esp+8Ch] [ebp-38h]
  int v50; // [esp+90h] [ebp-34h]
  int v51; // [esp+94h] [ebp-30h]
  int v52; // [esp+98h] [ebp-2Ch]
  int v53; // [esp+9Ch] [ebp-28h]
  int v54; // [esp+A0h] [ebp-24h]
  int mod3found; // [esp+ACh] [ebp-18h]
  int mod2found; // [esp+B0h] [ebp-14h]
  int mod1found; // [esp+B4h] [ebp-10h]
  int i; // [esp+BCh] [ebp-8h]
  int ia; // [esp+BCh] [ebp-8h]
  int ib; // [esp+BCh] [ebp-8h]
  int ic; // [esp+BCh] [ebp-8h]
  int editaction; // [esp+C0h] [ebp-4h]
  int editactiona; // [esp+C0h] [ebp-4h]
  int editactionb; // [esp+C0h] [ebp-4h]
  int editactionc; // [esp+C0h] [ebp-4h]

  mod1found = -1;
  mod2found = -1;
  mod3found = -1;
  if ( pmodkey )
    *pmodkey = -1;
  for ( i = 97; i >= 0; i = v25 )
  {
    editaction = LYLineEditors[current_lineedit][i];
    v2 = lac;
    BYTE1(v2) = BYTE1(lac) | 0x10;
    if ( v2 == editaction )
      return i;
    if ( editaction == 6 )
    {
      if ( lynx_edit_mode && !no_dired_support[0] && lac )
      {
        v23 = (i & 0x8800) != 0 ? (unsigned __int8)i : key_override[(i & 0x7FF) + 1];
        if ( v23 == lac )
          return i;
      }
      v24 = (i & 0x8800) != 0 ? (unsigned __int8)i : keymap[(i & 0x7FF) + 1];
      if ( v24 == lac )
        return i;
    }
    if ( editaction == 3 )
    {
      if ( lynx_edit_mode && !no_dired_support[0] && lac && key_override[10] == lac )
        return i;
      if ( keymap[10] == lac )
        return i;
    }
    if ( editaction == 29 && mod1found < 0 )
      mod1found = i;
    if ( editaction == 30 && mod2found < 0 )
      mod2found = i;
    if ( (editaction & 0x80) != 0 && mod3found < 0 )
      mod3found = i;
    if ( i == 122 )
    {
      v25 = 32;
    }
    else
    {
      if ( i == 96 )
      {
        v26 = 123;
      }
      else
      {
        if ( i == 126 )
        {
          v27 = 0;
        }
        else
        {
          if ( i == 31 )
          {
            v28 = 256;
          }
          else
          {
            if ( i == 659 )
            {
              v29 = 127;
            }
            else
            {
              if ( i == 255 )
                v30 = -1;
              else
                v30 = i + 1;
              v29 = v30;
            }
            v28 = v29;
          }
          v27 = v28;
        }
        v26 = v27;
      }
      v25 = v26;
    }
  }
  if ( mod3found >= 0 )
  {
    for ( ia = mod3found; ia >= 0; ia = v33 )
    {
      if ( (LYLineEditors[current_lineedit][ia] & 0x80) != 0 )
      {
        editactiona = Mod3Binding[ia];
        if ( pmodkey )
          *pmodkey = ia;
        v3 = lac;
        BYTE1(v3) = BYTE1(lac) | 0x10;
        if ( v3 == editactiona )
        {
          v4 = ia;
          BYTE1(v4) = BYTE1(ia) | 0x10;
          return v4;
        }
        if ( editactiona == 6 )
        {
          if ( lynx_edit_mode && !no_dired_support[0] && lac )
          {
            v31 = (ia & 0x8800) != 0 ? (unsigned __int8)ia : key_override[(ia & 0x7FF) + 1];
            if ( v31 == lac )
            {
              v5 = ia;
              BYTE1(v5) = BYTE1(ia) | 0x10;
              return v5;
            }
          }
          v32 = (ia & 0x8800) != 0 ? (unsigned __int8)ia : keymap[(ia & 0x7FF) + 1];
          if ( v32 == lac )
          {
            v6 = ia;
            BYTE1(v6) = BYTE1(ia) | 0x10;
            return v6;
          }
        }
        if ( editactiona == 3 )
        {
          if ( lynx_edit_mode && !no_dired_support[0] && lac && key_override[10] == lac )
          {
            v7 = ia;
            BYTE1(v7) = BYTE1(ia) | 0x10;
            return v7;
          }
          if ( keymap[10] == lac )
          {
            v8 = ia;
            BYTE1(v8) = BYTE1(ia) | 0x10;
            return v8;
          }
        }
      }
      if ( ia == 122 )
      {
        v33 = 32;
      }
      else
      {
        if ( ia == 96 )
        {
          v34 = 123;
        }
        else
        {
          if ( ia == 126 )
          {
            v35 = 0;
          }
          else
          {
            if ( ia == 31 )
            {
              v36 = 256;
            }
            else
            {
              if ( ia == 273 )
              {
                v37 = 127;
              }
              else
              {
                if ( ia == 255 )
                  v38 = -1;
                else
                  v38 = ia + 1;
                v37 = v38;
              }
              v36 = v37;
            }
            v35 = v36;
          }
          v34 = v35;
        }
        v33 = v34;
      }
    }
  }
  if ( mod1found >= 0 )
  {
    if ( pmodkey )
      *pmodkey = mod1found;
    for ( ib = 97; ib >= 0; ib = v41 )
    {
      editactionb = Mod1Binding[ib];
      v9 = lac;
      BYTE1(v9) = BYTE1(lac) | 0x10;
      if ( v9 == editactionb )
      {
        v10 = ib;
        BYTE1(v10) = BYTE1(ib) | 0x40;
        return v10;
      }
      if ( editactionb == 6 )
      {
        if ( lynx_edit_mode && !no_dired_support[0] && lac )
        {
          v39 = (ib & 0x8800) != 0 ? (unsigned __int8)ib : key_override[(ib & 0x7FF) + 1];
          if ( v39 == lac )
          {
            v11 = ib;
            BYTE1(v11) = BYTE1(ib) | 0x40;
            return v11;
          }
        }
        v40 = (ib & 0x8800) != 0 ? (unsigned __int8)ib : keymap[(ib & 0x7FF) + 1];
        if ( v40 == lac )
        {
          v12 = ib;
          BYTE1(v12) = BYTE1(ib) | 0x40;
          return v12;
        }
      }
      if ( editactionb == 3 )
      {
        if ( lynx_edit_mode && !no_dired_support[0] && lac && key_override[10] == lac )
        {
          v13 = ib;
          BYTE1(v13) = BYTE1(ib) | 0x40;
          return v13;
        }
        if ( keymap[10] == lac )
        {
          v14 = ib;
          BYTE1(v14) = BYTE1(ib) | 0x40;
          return v14;
        }
      }
      if ( ib == 122 )
      {
        v41 = 32;
      }
      else
      {
        if ( ib == 96 )
        {
          v42 = 123;
        }
        else
        {
          if ( ib == 126 )
          {
            v43 = 0;
          }
          else
          {
            if ( ib == 31 )
            {
              v44 = 256;
            }
            else
            {
              if ( ib == 273 )
              {
                v45 = 127;
              }
              else
              {
                if ( ib == 255 )
                  v46 = -1;
                else
                  v46 = ib + 1;
                v45 = v46;
              }
              v44 = v45;
            }
            v43 = v44;
          }
          v42 = v43;
        }
        v41 = v42;
      }
    }
  }
  if ( mod2found >= 0 )
  {
    if ( pmodkey )
      *pmodkey = mod1found;
    for ( ic = 97; ic >= 0; ic = v49 )
    {
      editactionc = Mod2Binding[ic];
      v15 = lac;
      BYTE1(v15) = BYTE1(lac) | 0x10;
      if ( v15 == editactionc )
      {
        v16 = ic;
        BYTE1(v16) = BYTE1(ic) | 0x20;
        return v16;
      }
      if ( editactionc == 6 )
      {
        if ( lynx_edit_mode && !no_dired_support[0] && lac )
        {
          v47 = (ic & 0x8800) != 0 ? (unsigned __int8)ic : key_override[(ic & 0x7FF) + 1];
          if ( v47 == lac )
          {
            v17 = ic;
            BYTE1(v17) = BYTE1(ic) | 0x20;
            return v17;
          }
        }
        v48 = (ic & 0x8800) != 0 ? (unsigned __int8)ic : keymap[(ic & 0x7FF) + 1];
        if ( v48 == lac )
        {
          v18 = ic;
          BYTE1(v18) = BYTE1(ic) | 0x20;
          return v18;
        }
      }
      if ( editactionc == 3 )
      {
        if ( lynx_edit_mode && !no_dired_support[0] && lac && key_override[10] == lac )
        {
          v19 = ic;
          BYTE1(v19) = BYTE1(ic) | 0x20;
          return v19;
        }
        if ( keymap[10] == lac )
        {
          v20 = ic;
          BYTE1(v20) = BYTE1(ic) | 0x20;
          return v20;
        }
      }
      if ( ic == 122 )
      {
        v49 = 32;
      }
      else
      {
        if ( ic == 96 )
        {
          v50 = 123;
        }
        else
        {
          if ( ic == 126 )
          {
            v51 = 0;
          }
          else
          {
            if ( ic == 31 )
            {
              v52 = 256;
            }
            else
            {
              if ( ic == 273 )
              {
                v53 = 127;
              }
              else
              {
                if ( ic == 255 )
                  v54 = -1;
                else
                  v54 = ic + 1;
                v53 = v54;
              }
              v52 = v53;
            }
            v51 = v52;
          }
          v50 = v51;
        }
        v49 = v50;
      }
    }
  }
  if ( pmodkey )
    *pmodkey = -1;
  return -1;
}
// 80DB819: conditional instruction was optimized away because %c.4>=0
// 80DB88E: conditional instruction was optimized away because %c.4>=0
// 80DBB25: conditional instruction was optimized away because %c.4>=0
// 80DBB9F: conditional instruction was optimized away because %c.4>=0
// 80DBDA9: conditional instruction was optimized away because %c.4>=0
// 80DBE11: conditional instruction was optimized away because %c.4>=0
// 80DBFF9: conditional instruction was optimized away because %c.4>=0
// 80DC061: conditional instruction was optimized away because %c.4>=0

//----- (080DC1E3) --------------------------------------------------------
int LYEditmapDeclared()
{
  return 1;
}

//----- (080DC1F8) --------------------------------------------------------
void __cdecl HTMLSetCharacterHandling(int i)
{
  FILE *v1; // eax
  int v2; // ebx
  FILE *v3; // edx
  bool v4; // [esp+18h] [ebp-20h]
  const char *v5; // [esp+1Ch] [ebp-1Ch]
  const char *v6; // [esp+20h] [ebp-18h]
  const char *mime; // [esp+24h] [ebp-14h]
  int UCLYhndl_for_unspec_flag; // [esp+28h] [ebp-10h]
  int chndl; // [esp+2Ch] [ebp-Ch]
  BOOLEAN LYRawMode_flag; // [esp+33h] [ebp-5h]

  chndl = safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset);
  LYRawMode_flag = LYRawMode[0];
  UCLYhndl_for_unspec_flag = UCLYhndl_for_unspec;
  if ( LYCharSet_UC[i].enc == 5 )
  {
    mime = LYCharSet_UC[i].MIMEname;
    if ( !strcmp(mime, "euc-cn") )
    {
      HTCJK = CHINESE;
      kanji_code = EUC;
    }
    else if ( !strcmp(mime, "euc-jp") )
    {
      HTCJK = JAPANESE;
      kanji_code = EUC;
    }
    else if ( !strcmp(mime, "shift_jis") )
    {
      HTCJK = JAPANESE;
      kanji_code = SJIS;
    }
    else if ( !strcmp(mime, "euc-kr") )
    {
      HTCJK = KOREAN;
      kanji_code = EUC;
    }
    else if ( !strcmp(mime, "big5") )
    {
      HTCJK = TAIPEI;
      kanji_code = EUC;
    }
    if ( !LYUseDefaultRawMode )
      HTCJK = NOCJK;
    LYRawMode[0] = HTCJK != NOCJK;
    HTPassEightBitRaw = 0;
    HTPassEightBitNum = 0;
    HTPassHighCtrlRaw = HTCJK != NOCJK;
    HTPassHighCtrlNum = 0;
  }
  else
  {
    HTCJK = NOCJK;
    kanji_code = NOKANJI;
    if ( i == chndl )
      LYRawMode[0] = LYUseDefaultRawMode;
    else
      LYRawMode[0] = LYUseDefaultRawMode == 0;
    v4 = (LYCharSet_UC[i].codepoints & 2) != 0 || (LYCharSet_UC[i].like8859 & 0x100) != 0;
    HTPassEightBitNum = v4;
    if ( LYRawMode[0] )
      HTPassEightBitRaw = LYlowest_eightbit[i] <= 160;
    else
      HTPassEightBitRaw = 0;
    HTPassHighCtrlRaw = (LYRawMode[0] || i == chndl) && LYlowest_eightbit[i] <= 130;
    HTPassHighCtrlNum = 0;
  }
  if ( LYRawMode[0] )
  {
    UCLYhndl_for_unspec = i;
  }
  else if ( chndl == i || LYCharSet_UC[i].enc == 5 && LYCharSet_UC[chndl].enc == 5 )
  {
    UCLYhndl_for_unspec = LATIN1;
  }
  else
  {
    UCLYhndl_for_unspec = chndl;
  }
  ena_csi(LYlowest_eightbit[current_char_set] > 155);
  if ( WWW_TraceFlag[0] )
  {
    if ( LYRawMode_flag != LYRawMode[0] && WWW_TraceFlag[0] )
    {
      if ( LYRawMode[0] )
        v5 = "ON";
      else
        v5 = "OFF";
      if ( LYRawMode_flag )
        v6 = "ON";
      else
        v6 = "OFF";
      v1 = TraceFP();
      fprintf(v1, "HTMLSetCharacterHandling: LYRawMode changed %s -> %s\n", v6, v5);
    }
    if ( UCLYhndl_for_unspec_flag != UCLYhndl_for_unspec )
    {
      if ( WWW_TraceFlag[0] )
      {
        v2 = UCLYhndl_for_unspec;
        v3 = TraceFP();
        fprintf(v3, "HTMLSetCharacterHandling: UCLYhndl_for_unspec changed %d -> %d\n", UCLYhndl_for_unspec_flag, v2);
      }
    }
  }
}

//----- (080DC595) --------------------------------------------------------
void __cdecl Set_HTCJK(const char *inMIMEname, const char *outMIMEname)
{
  if ( LYRawMode[0] )
  {
    if ( (!strcmp(inMIMEname, "euc-jp") || !strcmp(inMIMEname, "utf-8") || !strcmp(inMIMEname, "shift_jis"))
      && (!strcmp(outMIMEname, "euc-jp") || !strcmp(outMIMEname, "shift_jis")) )
    {
      HTCJK = JAPANESE;
    }
    else if ( !strcmp(inMIMEname, "euc-cn") && !strcmp(outMIMEname, "euc-cn") )
    {
      HTCJK = CHINESE;
    }
    else if ( !strcmp(inMIMEname, "big5") && !strcmp(outMIMEname, "big5") )
    {
      HTCJK = TAIPEI;
    }
    else if ( !strcmp(inMIMEname, "euc-kr") && !strcmp(outMIMEname, "euc-kr") )
    {
      HTCJK = KOREAN;
    }
    else
    {
      HTCJK = NOCJK;
    }
  }
  else
  {
    HTCJK = NOCJK;
  }
}

//----- (080DC6F5) --------------------------------------------------------
void __cdecl HTMLSetRawModeDefault(int i)
{
  LYDefaultRawMode[0] = LYCharSet_UC[i].enc == 5;
}

//----- (080DC711) --------------------------------------------------------
void __cdecl HTMLSetUseDefaultRawMode(int i, BOOLEAN modeflag)
{
  if ( LYCharSet_UC[i].enc == 5 )
  {
    LYUseDefaultRawMode = modeflag;
  }
  else if ( i == safeUCGetLYhndl_byMIME(UCAssume_MIMEcharset) )
  {
    LYUseDefaultRawMode = modeflag;
  }
  else
  {
    LYUseDefaultRawMode = modeflag == 0;
  }
}

//----- (080DC76A) --------------------------------------------------------
void __cdecl HTMLSetHaveCJKCharacterSet(int i)
{
  LYHaveCJKCharacterSet = LYCharSet_UC[i].enc == 5;
}

//----- (080DC786) --------------------------------------------------------
void __cdecl HTMLSetDisplayCharsetMatchLocale(int i)
{
  bool match; // [esp+27h] [ebp-1h]

  if ( LYHaveCJKCharacterSet )
  {
    DisplayCharsetMatchLocale = 1;
  }
  else
  {
    match = !strncasecomp(LYCharSet_UC[i].MIMEname, "cp", 2)
         && !strncasecomp(LYCharSet_UC[i].MIMEname, "windows", 7)
         && UCForce8bitTOUPPER == 0;
    DisplayCharsetMatchLocale = match;
  }
}

//----- (080DC814) --------------------------------------------------------
int __cdecl UCGetLYhndl_byAnyName(char *value)
{
  FILE *v1; // eax
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  LYTrimTrailing(value);
  if ( !value )
    return -1;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "UCGetLYhndl_byAnyName(%s)\n", value);
  }
  for ( i = 0; i <= 59 && LYchar_set_names[i]; ++i )
  {
    if ( !strcmp(value, LYchar_set_names[i]) )
      return i;
  }
  for ( ia = 0; OLD_charset_names[ia].fullname; ++ia )
  {
    if ( !strcmp(value, OLD_charset_names[ia].fullname) )
      return UCGetLYhndl_byMIME(OLD_charset_names[ia].MIMEname);
  }
  return UCGetLYhndl_byMIME(value);
}

//----- (080DC908) --------------------------------------------------------
const char *__cdecl HTMLGetEntityName(UCode_t code)
{
  if ( code >= 0 && code <= 95 )
    return LYEntityNames[code];
  else
    return (const char *)&unk_816A0B7;
}

//----- (080DC93E) --------------------------------------------------------
UCode_t __cdecl HTMLGetEntityUCValue(const char *name)
{
  int diff; // [esp+24h] [ebp-14h]
  size_t low; // [esp+28h] [ebp-10h]
  size_t high; // [esp+2Ch] [ebp-Ch]
  size_t i; // [esp+30h] [ebp-8h]
  UCode_t value; // [esp+34h] [ebp-4h]

  value = 0;
  if ( !name || !*name )
    return 0;
  low = 0;
  high = 996;
  while ( high > low )
  {
    i = low + ((high - low) >> 1);
    diff = strcmp(unicode_entities_10252[i].name, name);
    if ( !diff )
      return unicode_entities_10252[i].code;
    if ( diff >= 0 )
      high = low + ((high - low) >> 1);
    else
      low = i + 1;
  }
  return value;
}

//----- (080DC9EF) --------------------------------------------------------
void __cdecl HTMLUseCharacterSet(int i)
{
  HTMLSetRawModeDefault(i);
  p_entity_values = LYCharSets[i];
  HTMLSetCharacterHandling(i);
  HTMLSetHaveCJKCharacterSet(i);
  HTMLSetDisplayCharsetMatchLocale(i);
}

//----- (080DCA32) --------------------------------------------------------
int LYCharSetsDeclared()
{
  UCInit();
  return UCInitialized;
}

//----- (080DCA44) --------------------------------------------------------
void __cdecl LYEntify(char **str, BOOLEAN isTITLE)
{
  size_t v2; // eax
  int in_sjis; // [esp+18h] [ebp-20h]
  LYEntify::_state state; // [esp+1Ch] [ebp-1Ch]
  int gts; // [esp+20h] [ebp-18h]
  int lts; // [esp+24h] [ebp-14h]
  int amps; // [esp+28h] [ebp-10h]
  char *cp; // [esp+2Ch] [ebp-Ch]
  char *q; // [esp+30h] [ebp-8h]
  char *qa; // [esp+30h] [ebp-8h]
  char *qb; // [esp+30h] [ebp-8h]
  char *qc; // [esp+30h] [ebp-8h]
  char *qd; // [esp+30h] [ebp-8h]
  char *qe; // [esp+30h] [ebp-8h]
  char *qf; // [esp+30h] [ebp-8h]
  const char *p; // [esp+34h] [ebp-4h]
  const char *pa; // [esp+34h] [ebp-4h]
  const char *pb; // [esp+34h] [ebp-4h]
  char *pc; // [esp+34h] [ebp-4h]

  p = *str;
  amps = 0;
  lts = 0;
  gts = 0;
  state = S_text_0;
  in_sjis = 0;
  if ( *str && *p )
  {
    while ( *p )
    {
      q = strchr(p, 38);
      if ( !q )
        break;
      ++amps;
      p = q + 1;
    }
    if ( isTITLE == 1 )
    {
      for ( pa = *str; *pa; pa = qa + 1 )
      {
        qa = strchr(pa, 60);
        if ( !qa )
          break;
        ++lts;
      }
    }
    if ( isTITLE == 1 )
    {
      for ( pb = *str; *pb; pb = qb + 1 )
      {
        qb = strchr(pb, 62);
        if ( !qb )
          break;
        ++gts;
      }
    }
    if ( amps || lts || gts )
    {
      v2 = strlen(*str);
      qc = (char *)calloc(3 * lts + 4 * amps + v2 + 3 * gts + 1, 1u);
      cp = qc;
      if ( !qc )
        outofmem("./LYCharUtils.c", "LYEntify");
      for ( pc = *str; *pc; ++pc )
      {
        if ( HTCJK )
        {
          switch ( state )
          {
            case S_text_0:
              if ( *pc != 27 )
                goto LABEL_54;
              state = S_esc_0;
              *qc++ = *pc;
              continue;
            case S_esc_0:
              if ( *pc == 36 )
              {
                state = S_dollar_0;
                *qc++ = *pc;
              }
              else
              {
                if ( *pc == 40 )
                  state = S_paren_0;
                else
                  state = S_text_0;
                *qc++ = *pc;
              }
              continue;
            case S_dollar_0:
              if ( *pc == 64 || *pc == 66 || *pc == 65 )
              {
                state = S_nonascii_text_0;
                *qc++ = *pc;
              }
              else
              {
                if ( *pc == 40 )
                  state = S_dollar_paren_0;
                else
                  state = S_text_0;
                *qc++ = *pc;
              }
              continue;
            case S_paren_0:
              if ( *pc == 66 || *pc == 74 || *pc == 84 )
              {
                state = S_text_0;
                *qc++ = *pc;
              }
              else
              {
                if ( *pc != 73 )
                  goto LABEL_51;
                state = S_nonascii_text_0;
                *qc++ = *pc;
              }
              continue;
            case S_nonascii_text_0:
LABEL_51:
              if ( *pc == 27 )
                state = S_esc_0;
              *qc++ = *pc;
              continue;
            case S_dollar_paren_0:
              if ( *pc == 67 )
                state = S_nonascii_text_0;
              else
                state = S_text_0;
              *qc++ = *pc;
              continue;
            default:
LABEL_54:
              if ( !pc[1] )
                goto LABEL_81;
              if ( (unsigned __int8)*pc > 0xA0u && *pc != -1 && (unsigned __int8)pc[1] > 0xA0u && pc[1] != -1
                || *pc == -114 && (unsigned __int8)pc[1] > 0xA0u && (unsigned __int8)pc[1] <= 0xDFu )
              {
                goto LABEL_80;
              }
              if ( (unsigned __int8)pc[1] <= 0x3Fu || pc[1] == 127 || (unsigned __int8)pc[1] > 0xFCu )
                goto LABEL_74;
              if ( (unsigned __int8)*pc <= 0x80u || (unsigned __int8)*pc > 0x9Fu )
              {
                if ( !in_sjis || (unsigned __int8)*pc <= 0xDFu || (unsigned __int8)*pc > 0xEFu )
                {
LABEL_74:
                  if ( (unsigned __int8)*pc <= 0xA0u
                    || *pc == -1
                    || ((unsigned __int8)pc[1] <= 0x3Fu || (unsigned __int8)pc[1] > 0x7Eu)
                    && ((unsigned __int8)pc[1] <= 0xA0u || pc[1] == -1) )
                  {
                    goto LABEL_81;
                  }
                }
              }
              else
              {
                in_sjis = 1;
              }
LABEL_80:
              *qc = *pc++;
              qc[1] = *pc;
              qc += 2;
              break;
          }
        }
        else
        {
LABEL_81:
          if ( *pc == 38 )
          {
            *qc = 38;
            qd = qc + 1;
            *qd++ = 97;
            *qd++ = 109;
            *qd = 112;
            qd[1] = 59;
            qc = qd + 2;
          }
          else if ( isTITLE && *pc == 60 )
          {
            *qc = 38;
            qe = qc + 1;
            *qe++ = 108;
            *qe = 116;
            qe[1] = 59;
            qc = qe + 2;
          }
          else if ( isTITLE && *pc == 62 )
          {
            *qc = 38;
            qf = qc + 1;
            *qf++ = 103;
            *qf = 116;
            qf[1] = 59;
            qc = qf + 2;
          }
          else
          {
            *qc++ = *pc;
          }
        }
      }
      *qc = 0;
      if ( *str )
      {
        free(*str);
        *str = 0;
      }
      *str = cp;
    }
  }
}

//----- (080DD029) --------------------------------------------------------
void __cdecl LYTrimHead(char *str)
{
  char *ns; // [esp+8h] [ebp-8h]
  char *s; // [esp+Ch] [ebp-4h]

  s = str;
  if ( str && *str )
  {
    while ( *s && (unsigned __int8)*s <= 0x20u && *s != 27 )
      ++s;
    if ( s > str )
    {
      ns = str;
      while ( *s )
        *ns++ = *s++;
      *ns = 0;
    }
  }
}

//----- (080DD09E) --------------------------------------------------------
void __cdecl LYTrimTail(char *str)
{
  int i; // [esp+14h] [ebp-4h]

  if ( str && *str )
  {
    for ( i = strlen(str) - 1; i >= 0 && (unsigned __int8)str[i] <= 0x20u; --i )
      str[i] = 0;
  }
}

//----- (080DD0E9) --------------------------------------------------------
char *__cdecl LYFindEndOfComment(char *str)
{
  LYFindEndOfComment::comment_state state; // [esp+1Ch] [ebp-Ch]
  char *cp1; // [esp+20h] [ebp-8h]
  char *cp; // [esp+24h] [ebp-4h]

  if ( !str )
    return 0;
  if ( strncmp(str, "<!--", 4u) )
    return str;
  cp = str + 4;
  if ( str[4] == 62 )
    return str + 4;
  cp1 = strchr(cp, 62);
  if ( !cp1 )
    return str;
  if ( *cp == 45 )
    return cp1;
  state = start2;
  while ( *cp )
  {
    if ( state == start2 )
    {
      if ( *cp == 45 )
        state = end1;
    }
    else if ( state )
    {
      if ( state == end1 )
      {
        if ( *cp != 45 )
          return cp1;
        state = end2;
      }
      else
      {
        if ( *cp == 62 )
          return cp;
        if ( *cp == 45 )
        {
          state = start1;
        }
        else if ( (unsigned __int8)*cp > 0x20u || *cp == 27 )
        {
          return cp1;
        }
      }
    }
    else
    {
      if ( *cp != 45 )
        return cp1;
      state = start2;
    }
    ++cp;
  }
  return cp1;
}
// 80DD1AD: conditional instruction was optimized away because %state.4==3

//----- (080DD25E) --------------------------------------------------------
void __cdecl LYFillLocalFileURL(char **href, const char *base)
{
  char *v2; // eax
  const char *temp2; // [esp+1Ch] [ebp-10Ch]
  char *temp; // [esp+20h] [ebp-108h] BYREF
  char curdir[256]; // [esp+24h] [ebp-104h] BYREF
  unsigned int v6; // [esp+124h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  temp = 0;
  if ( *href && **href )
  {
    if ( (!strcmp(*href, "//") || !strncmp(*href, "///", 3u))
      && base
      && (*base == 102 || *base == 70)
      && !strncasecomp(base, "file:", 5) )
    {
      HTSACopy(&temp, "file:");
      HTSACat(&temp, *href);
      HTSACopy(href, temp);
    }
    if ( (**href == 102 || **href == 70) && !strncasecomp(*href, "file:", 5) )
    {
      if ( (*href)[5] )
      {
        if ( !strcmp(*href, "file://") )
        {
          HTSACat(href, "localhost");
        }
        else if ( !strncmp(*href, "file:///", 8u) )
        {
          HTSACopy(&temp, *href + 7);
          LYLocalFileToURL(href, temp);
        }
        else if ( !strncmp(*href, "file:/", 6u) && (*href)[6] != 47 )
        {
          HTSACopy(&temp, *href + 5);
          LYLocalFileToURL(href, temp);
        }
      }
      else
      {
        HTSACat(href, "//localhost");
      }
    }
    if ( !strcmp(*href, "file://localhost") )
    {
      v2 = Current_Dir(curdir);
      temp2 = wwwName(v2);
      if ( *temp2 != 47 )
        LYAddHtmlSep(href);
      if ( strchr(temp2, 37) || strchr(temp2, 35) )
      {
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
        temp = HTEscape(temp2, 4u);
        HTSACat(href, temp);
      }
      else
      {
        HTSACat(href, temp2);
      }
    }
    if ( temp )
      free(temp);
  }
}

//----- (080DD62A) --------------------------------------------------------
void __cdecl LYAddMETAcharsetToFD(FILE *fd, int disp_chndl)
{
  if ( disp_chndl == -1 )
    disp_chndl = current_char_set;
  if ( fd && disp_chndl >= 0 && UCLYhndl_HTFile_for_unspec != disp_chndl )
  {
    if ( LYCharSet_UC[disp_chndl].enc )
      fprintf(
        fd,
        "<META %s content=\"text/html;charset=%s\">\n",
        "http-equiv=\"content-type\"",
        LYCharSet_UC[disp_chndl].MIMEname);
  }
}

//----- (080DD691) --------------------------------------------------------
char *__cdecl LYUppercaseA_OL_String(int seqnum)
{
  if ( seqnum > 1 )
  {
    if ( seqnum > 26 )
    {
      if ( seqnum > 702 )
      {
        if ( seqnum > 18278 )
          memcpy(OLstring_11402, "ZZZ.", 5u);
        else
          sprintf(
            OLstring_11402,
            "%c%c%c.",
            (seqnum - 27) / 676 + 64,
            (seqnum - 676 * ((seqnum - 27) / 676) - 1) / 26 + 64,
            seqnum - 26 * ((seqnum - 1) / 26) + 64);
      }
      else
      {
        sprintf(OLstring_11402, "%c%c.", (seqnum - 1) / 26 + 64, seqnum - 26 * ((seqnum - 1) / 26) + 64);
      }
    }
    else
    {
      sprintf(OLstring_11402, " %c.", seqnum + 64);
    }
  }
  else
  {
    memcpy(OLstring_11402, " A.", 4u);
  }
  return OLstring_11402;
}

//----- (080DD86C) --------------------------------------------------------
char *__cdecl LYLowercaseA_OL_String(int seqnum)
{
  if ( seqnum > 1 )
  {
    if ( seqnum > 26 )
    {
      if ( seqnum > 702 )
      {
        if ( seqnum > 18278 )
          memcpy(OLstring_11440, "zzz.", 5u);
        else
          sprintf(
            OLstring_11440,
            "%c%c%c.",
            (seqnum - 27) / 676 + 96,
            (seqnum - 676 * ((seqnum - 27) / 676) - 1) / 26 + 96,
            seqnum - 26 * ((seqnum - 1) / 26) + 96);
      }
      else
      {
        sprintf(OLstring_11440, "%c%c.", (seqnum - 1) / 26 + 96, seqnum - 26 * ((seqnum - 1) / 26) + 96);
      }
    }
    else
    {
      sprintf(OLstring_11440, " %c.", seqnum + 96);
    }
  }
  else
  {
    memcpy(OLstring_11440, " a.", 4u);
  }
  return OLstring_11440;
}

//----- (080DDA47) --------------------------------------------------------
char *__cdecl LYUppercaseI_OL_String(int seqnum)
{
  size_t v1; // eax
  size_t v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  size_t v14; // eax
  size_t v15; // eax
  size_t v16; // eax
  size_t v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  size_t v20; // eax
  size_t v21; // eax
  size_t v22; // eax
  int Arabic; // [esp+24h] [ebp-4h]

  Arabic = seqnum;
  if ( seqnum <= 2999 )
  {
    if ( seqnum == 50 )
    {
      memcpy(OLstring_11478, " L.", 4u);
      return OLstring_11478;
    }
    if ( seqnum > 50 )
    {
      switch ( seqnum )
      {
        case 500:
          memcpy(OLstring_11478, " D.", 4u);
          return OLstring_11478;
        case 1000:
          memcpy(OLstring_11478, " M.", 4u);
          return OLstring_11478;
        case 100:
          memcpy(OLstring_11478, " C.", 4u);
          return OLstring_11478;
      }
    }
    else
    {
      switch ( seqnum )
      {
        case 5:
          memcpy(OLstring_11478, " V.", 4u);
          return OLstring_11478;
        case 10:
          memcpy(OLstring_11478, " X.", 4u);
          return OLstring_11478;
        case 1:
          memcpy(OLstring_11478, " I.", 4u);
          return OLstring_11478;
      }
    }
    OLstring_11478[0] = 0;
    while ( Arabic > 999 )
    {
      v1 = strlen(OLstring_11478);
      memcpy((void *)(v1 + 135988840), "M", 2u);
      Arabic -= 1000;
    }
    if ( Arabic > 899 )
    {
      v2 = strlen(OLstring_11478);
      memcpy((void *)(v2 + 135988840), "CM", 3u);
      Arabic -= 900;
    }
    if ( Arabic > 499 )
    {
      v3 = strlen(OLstring_11478);
      memcpy((void *)(v3 + 135988840), "D", 2u);
      for ( Arabic -= 500; Arabic > 499; Arabic -= 10 )
      {
        v4 = strlen(OLstring_11478);
        memcpy((void *)(v4 + 135988840), "C", 2u);
      }
    }
    if ( Arabic > 399 )
    {
      v5 = strlen(OLstring_11478);
      memcpy((void *)(v5 + 135988840), "CD", 3u);
      Arabic -= 400;
    }
    while ( Arabic > 99 )
    {
      v6 = strlen(OLstring_11478);
      memcpy((void *)(v6 + 135988840), "C", 2u);
      Arabic -= 100;
    }
    if ( Arabic > 89 )
    {
      v7 = strlen(OLstring_11478);
      memcpy((void *)(v7 + 135988840), "XC", 3u);
      Arabic -= 90;
    }
    if ( Arabic > 49 )
    {
      v8 = strlen(OLstring_11478);
      memcpy((void *)(v8 + 135988840), "L", 2u);
      for ( Arabic -= 50; Arabic > 49; Arabic -= 10 )
      {
        v9 = strlen(OLstring_11478);
        memcpy((void *)(v9 + 135988840), "X", 2u);
      }
    }
    if ( Arabic > 39 )
    {
      v10 = strlen(OLstring_11478);
      memcpy((void *)(v10 + 135988840), "XL", 3u);
      Arabic -= 40;
    }
    while ( Arabic > 10 )
    {
      v11 = strlen(OLstring_11478);
      memcpy((void *)(v11 + 135988840), "X", 2u);
      Arabic -= 10;
    }
    switch ( Arabic )
    {
      case 1:
        v12 = strlen(OLstring_11478);
        memcpy((void *)(v12 + 135988840), "I.", 3u);
        break;
      case 2:
        v13 = strlen(OLstring_11478);
        memcpy((void *)(v13 + 135988840), "II.", 4u);
        break;
      case 3:
        v14 = strlen(OLstring_11478);
        memcpy((void *)(v14 + 135988840), "III.", 5u);
        break;
      case 4:
        v15 = strlen(OLstring_11478);
        memcpy((void *)(v15 + 135988840), "IV.", 4u);
        break;
      case 5:
        v16 = strlen(OLstring_11478);
        memcpy((void *)(v16 + 135988840), "V.", 3u);
        break;
      case 6:
        v17 = strlen(OLstring_11478);
        memcpy((void *)(v17 + 135988840), "VI.", 4u);
        break;
      case 7:
        v18 = strlen(OLstring_11478);
        memcpy((void *)(v18 + 135988840), "VII.", 5u);
        break;
      case 8:
        v19 = strlen(OLstring_11478);
        memcpy((void *)(v19 + 135988840), "VIII.", 6u);
        break;
      case 9:
        v20 = strlen(OLstring_11478);
        memcpy((void *)(v20 + 135988840), "IX.", 4u);
        break;
      case 10:
        v21 = strlen(OLstring_11478);
        memcpy((void *)(v21 + 135988840), "X.", 3u);
        break;
      default:
        v22 = strlen(OLstring_11478);
        memcpy((void *)(v22 + 135988840), ".", 2u);
        break;
    }
  }
  else
  {
    memcpy(OLstring_11478, "MMM.", 5u);
  }
  return OLstring_11478;
}

//----- (080DE063) --------------------------------------------------------
char *__cdecl LYLowercaseI_OL_String(int seqnum)
{
  size_t v1; // eax
  size_t v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax
  size_t v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  size_t v14; // eax
  size_t v15; // eax
  size_t v16; // eax
  size_t v17; // eax
  size_t v18; // eax
  size_t v19; // eax
  size_t v20; // eax
  size_t v21; // eax
  size_t v22; // eax
  int Arabic; // [esp+24h] [ebp-4h]

  Arabic = seqnum;
  if ( seqnum <= 2999 )
  {
    if ( seqnum == 50 )
    {
      memcpy(OLstring_11558, " l.", 4u);
      return OLstring_11558;
    }
    if ( seqnum > 50 )
    {
      switch ( seqnum )
      {
        case 500:
          memcpy(OLstring_11558, " d.", 4u);
          return OLstring_11558;
        case 1000:
          memcpy(OLstring_11558, " m.", 4u);
          return OLstring_11558;
        case 100:
          memcpy(OLstring_11558, " c.", 4u);
          return OLstring_11558;
      }
    }
    else
    {
      switch ( seqnum )
      {
        case 5:
          memcpy(OLstring_11558, " v.", 4u);
          return OLstring_11558;
        case 10:
          memcpy(OLstring_11558, " x.", 4u);
          return OLstring_11558;
        case 1:
          memcpy(OLstring_11558, " i.", 4u);
          return OLstring_11558;
      }
    }
    OLstring_11558[0] = 0;
    while ( Arabic > 999 )
    {
      v1 = strlen(OLstring_11558);
      memcpy((void *)(v1 + 135988860), "m", 2u);
      Arabic -= 1000;
    }
    if ( Arabic > 899 )
    {
      v2 = strlen(OLstring_11558);
      memcpy((void *)(v2 + 135988860), "cm", 3u);
      Arabic -= 900;
    }
    if ( Arabic > 499 )
    {
      v3 = strlen(OLstring_11558);
      memcpy((void *)(v3 + 135988860), "d", 2u);
      for ( Arabic -= 500; Arabic > 499; Arabic -= 10 )
      {
        v4 = strlen(OLstring_11558);
        memcpy((void *)(v4 + 135988860), "c", 2u);
      }
    }
    if ( Arabic > 399 )
    {
      v5 = strlen(OLstring_11558);
      memcpy((void *)(v5 + 135988860), "cd", 3u);
      Arabic -= 400;
    }
    while ( Arabic > 99 )
    {
      v6 = strlen(OLstring_11558);
      memcpy((void *)(v6 + 135988860), "c", 2u);
      Arabic -= 100;
    }
    if ( Arabic > 89 )
    {
      v7 = strlen(OLstring_11558);
      memcpy((void *)(v7 + 135988860), "xc", 3u);
      Arabic -= 90;
    }
    if ( Arabic > 49 )
    {
      v8 = strlen(OLstring_11558);
      memcpy((void *)(v8 + 135988860), "l", 2u);
      for ( Arabic -= 50; Arabic > 49; Arabic -= 10 )
      {
        v9 = strlen(OLstring_11558);
        memcpy((void *)(v9 + 135988860), "x", 2u);
      }
    }
    if ( Arabic > 39 )
    {
      v10 = strlen(OLstring_11558);
      memcpy((void *)(v10 + 135988860), "xl", 3u);
      Arabic -= 40;
    }
    while ( Arabic > 10 )
    {
      v11 = strlen(OLstring_11558);
      memcpy((void *)(v11 + 135988860), "x", 2u);
      Arabic -= 10;
    }
    switch ( Arabic )
    {
      case 1:
        v12 = strlen(OLstring_11558);
        memcpy((void *)(v12 + 135988860), "i.", 3u);
        break;
      case 2:
        v13 = strlen(OLstring_11558);
        memcpy((void *)(v13 + 135988860), "ii.", 4u);
        break;
      case 3:
        v14 = strlen(OLstring_11558);
        memcpy((void *)(v14 + 135988860), "iii.", 5u);
        break;
      case 4:
        v15 = strlen(OLstring_11558);
        memcpy((void *)(v15 + 135988860), "iv.", 4u);
        break;
      case 5:
        v16 = strlen(OLstring_11558);
        memcpy((void *)(v16 + 135988860), "v.", 3u);
        break;
      case 6:
        v17 = strlen(OLstring_11558);
        memcpy((void *)(v17 + 135988860), "vi.", 4u);
        break;
      case 7:
        v18 = strlen(OLstring_11558);
        memcpy((void *)(v18 + 135988860), "vii.", 5u);
        break;
      case 8:
        v19 = strlen(OLstring_11558);
        memcpy((void *)(v19 + 135988860), "viii.", 6u);
        break;
      case 9:
        v20 = strlen(OLstring_11558);
        memcpy((void *)(v20 + 135988860), "ix.", 4u);
        break;
      case 10:
        v21 = strlen(OLstring_11558);
        memcpy((void *)(v21 + 135988860), "x.", 3u);
        break;
      default:
        v22 = strlen(OLstring_11558);
        memcpy((void *)(v22 + 135988860), ".", 2u);
        break;
    }
  }
  else
  {
    memcpy(OLstring_11558, "mmm.", 5u);
  }
  return OLstring_11558;
}

//----- (080DE67F) --------------------------------------------------------
void __cdecl LYZero_OL_Counter(HTStructured_0 *me)
{
  int i; // [esp+Ch] [ebp-4h]

  if ( me )
  {
    for ( i = 0; i <= 11; ++i )
    {
      me->OL_Counter[i] = OL_VOID;
      me->OL_Type[i] = 49;
    }
    me->Last_OL_Count = 0;
    me->Last_OL_Type = 49;
  }
}

//----- (080DE6D8) --------------------------------------------------------
void __cdecl LYGetChartransInfo(HTStructured_0 *me)
{
  int chndl; // [esp+24h] [ebp-4h]

  me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 2);
  if ( me->UCLYhndl < 0 )
  {
    chndl = HTAnchor_getUCLYhndl(me->node_anchor, 3);
    if ( chndl < 0 )
    {
      chndl = current_char_set;
      HTAnchor_setUCInfoStage(me->node_anchor, current_char_set, 3, 3);
    }
    HTAnchor_setUCInfoStage(me->node_anchor, chndl, 2, 3);
    me->UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 2);
  }
  me->UCI = HTAnchor_getUCInfoStage(me->node_anchor, 2);
}

//----- (080DE7C5) --------------------------------------------------------
char *__cdecl UCPutUtf8ToBuffer(char *q, UCode_t code, BOOLEAN terminate)
{
  char *q_in; // [esp+14h] [ebp-4h]
  char *qa; // [esp+20h] [ebp+8h]
  char *qb; // [esp+20h] [ebp+8h]
  char *qc; // [esp+20h] [ebp+8h]
  char *qd; // [esp+20h] [ebp+8h]

  q_in = q;
  if ( !q )
    return 0;
  if ( code <= 127 || code == 0x7FFFFFFF )
    return 0;
  if ( code > 2047 )
  {
    if ( code > 0xFFFF )
    {
      if ( code > 0x1FFFFF )
      {
        if ( code > 0x3FFFFFF )
        {
          *q++ = (code >> 30) | 0xFC;
          *q = HIBYTE(code) & 0x3F | 0x80;
        }
        else
        {
          *q = HIBYTE(code) | 0xF8;
        }
        qd = q + 1;
        *qd++ = (code >> 18) & 0x3F | 0x80;
        *qd++ = (code >> 12) & 0x3F | 0x80;
        *qd = (code >> 6) & 0x3F | 0x80;
        qd[1] = code & 0x3F | 0x80;
        qa = qd + 2;
      }
      else
      {
        *q = (code >> 18) | 0xF0;
        qc = q + 1;
        *qc++ = (code >> 12) & 0x3F | 0x80;
        *qc = (code >> 6) & 0x3F | 0x80;
        qc[1] = code & 0x3F | 0x80;
        qa = qc + 2;
      }
    }
    else
    {
      *q = (code >> 12) | 0xE0;
      qb = q + 1;
      *qb = (code >> 6) & 0x3F | 0x80;
      qb[1] = code & 0x3F | 0x80;
      qa = qb + 2;
    }
  }
  else
  {
    *q = (code >> 6) | 0xC0;
    q[1] = code & 0x3F | 0x80;
    qa = q + 2;
  }
  if ( !terminate )
    return qa;
  *qa = 0;
  return q_in;
}

//----- (080DEA10) --------------------------------------------------------
char **__cdecl LYUCFullyTranslateString(
        char **str,
        int cs_from,
        int cs_to,
        BOOLEAN do_ent,
        BOOLEAN use_lynx_specials,
        BOOLEAN plain_space,
        BOOLEAN hidden,
        BOOLEAN Back,
        CharUtil_st stype)
{
  int v9; // eax
  FILE *v10; // eax
  bool v13; // [esp+24h] [ebp-124h]
  bool v14; // [esp+28h] [ebp-120h]
  int l; // [esp+2Ch] [ebp-11Ch]
  LYUCFullyTranslateString::_state v16; // [esp+38h] [ebp-110h]
  int v17; // [esp+3Ch] [ebp-10Ch]
  UCode_t v18; // [esp+48h] [ebp-100h]
  char *v19; // [esp+4Ch] [ebp-FCh]
  int v20; // [esp+50h] [ebp-F8h]
  int v21; // [esp+5Ch] [ebp-ECh]
  char *v22; // [esp+68h] [ebp-E0h]
  int v23; // [esp+6Ch] [ebp-DCh]
  int v24; // [esp+74h] [ebp-D4h]
  BOOLEAN do_enta; // [esp+94h] [ebp-B4h]
  UCTransParams T; // [esp+A0h] [ebp-A8h] BYREF
  char *pp; // [esp+ACh] [ebp-9Ch]
  int rev_c; // [esp+B0h] [ebp-98h]
  LYUCFullyTranslateString::_parsing_what what; // [esp+B4h] [ebp-94h]
  LYUCFullyTranslateString::_state state; // [esp+B8h] [ebp-90h]
  char *puni; // [esp+BCh] [ebp-8Ch] BYREF
  const char *name; // [esp+C0h] [ebp-88h]
  size_t len; // [esp+C4h] [ebp-84h]
  unsigned int lcode; // [esp+C8h] [ebp-80h] BYREF
  UCode_t code; // [esp+CCh] [ebp-7Ch]
  int lowest_8; // [esp+D0h] [ebp-78h]
  int uck; // [esp+D4h] [ebp-74h]
  char *esc; // [esp+D8h] [ebp-70h]
  char *cp; // [esp+DCh] [ebp-6Ch]
  HTChunk *chunk; // [esp+E0h] [ebp-68h]
  char *qs; // [esp+E4h] [ebp-64h]
  char *q; // [esp+E8h] [ebp-60h]
  char *p; // [esp+ECh] [ebp-5Ch]
  BOOLEAN from_is_utf8; // [esp+F3h] [ebp-55h]
  BOOLEAN no_bytetrans; // [esp+F4h] [ebp-54h]
  BOOLEAN repl_translated_C0; // [esp+F5h] [ebp-53h]
  BOOLEAN output_utf8; // [esp+F6h] [ebp-52h]
  char cpe; // [esp+F7h] [ebp-51h]
  char replace_buf[64]; // [esp+F8h] [ebp-50h] BYREF
  unsigned int v50; // [esp+138h] [ebp-10h]

  do_enta = do_ent;
  v50 = __readgsdword(0x14u);
  chunk = 0;
  cp = 0;
  cpe = 0;
  esc = 0;
  code = 0;
  output_utf8 = 0;
  repl_translated_C0 = 0;
  name = 0;
  from_is_utf8 = 0;
  state = S_text_1;
  what = P_text;
  if ( !str || !*str || !**str )
    return str;
  memset(replace_buf, 0, sizeof(replace_buf));
  if ( HTCJK == NOCJK
    || !strcmp(LYCharSet_UC[cs_from].MIMEname, "utf-8")
    || !strcmp(LYCharSet_UC[cs_to].MIMEname, "utf-8") )
  {
    if ( cs_to > 0 || cs_from != cs_to || Back && cs_to >= 0 )
    {
      v13 = !use_lynx_specials && !Back && UCNeedNotTranslate(cs_from, cs_to);
      no_bytetrans = v13;
    }
    else
    {
      no_bytetrans = 1;
    }
  }
  else
  {
    no_bytetrans = 1;
  }
  if ( do_ent && hidden && stype != st_URL_0 && !strchr(*str, 38) )
    do_enta = 0;
  if ( UCCanTranslateFromTo(cs_from, cs_to) )
  {
    if ( cs_to < 0 )
      do_enta = 0;
  }
  else
  {
    if ( cs_to < 0 )
      return 0;
    if ( !do_enta && no_bytetrans )
      return 0;
    no_bytetrans = 1;
  }
  if ( !do_enta && no_bytetrans )
    return str;
  p = *str;
  if ( no_bytetrans )
  {
    if ( do_enta )
    {
      v14 = LYCharSet_UC[cs_to].enc == 7 || HText_hasUTF8OutputSet(HTMainText);
      output_utf8 = v14;
      repl_translated_C0 = LYCharSet_UC[cs_to].enc == 3;
    }
  }
  else
  {
    UCTransParams_clear(&T);
    UCSetTransParams(&T, cs_from, &LYCharSet_UC[cs_from], cs_to, &LYCharSet_UC[cs_to]);
    from_is_utf8 = LYCharSet_UC[cs_from].enc == 7;
    output_utf8 = T.output_utf8;
    repl_translated_C0 = T.repl_translated_C0;
    puni = p;
  }
  lowest_8 = LYlowest_eightbit[cs_to];
  len = strlen(p) + 16;
  q = p;
  qs = p;
LABEL_427:
  while ( *p || state && state != S_nonascii_text_1 )
  {
    switch ( state )
    {
      case S_text_1:
        code = (unsigned __int8)*p;
        if ( *p == 27 )
        {
          if ( HTCJK && !hidden || stype )
          {
            state = S_esc_1;
            if ( stype == st_URL_0 )
            {
              if ( q != qs )
              {
                l = q - qs;
                if ( !chunk )
                  chunk = HTChunkCreate2(128, len + 1);
                HTChunkPutb(chunk, qs, l);
              }
              if ( chunk )
                goto LABEL_58;
              goto LABEL_57;
            }
            if ( stype == st_HTML_0 )
              *q++ = *p;
            ++p;
          }
          else if ( hidden )
          {
            state = S_trans_byte;
          }
          else
          {
            state = S_next_char;
          }
        }
        else
        {
          if ( do_enta )
            v16 = S_check_ent;
          else
            v16 = S_trans_byte;
          state = v16;
        }
        goto LABEL_427;
      case S_esc_1:
        if ( *p == 36 )
        {
          state = S_dollar_1;
          *q++ = *p++;
        }
        else if ( *p == 40 )
        {
          state = S_paren_1;
          *q++ = *p++;
        }
        else
        {
          state = S_text_1;
        }
        goto LABEL_427;
      case S_dollar_1:
        if ( *p == 64 || *p == 66 || *p == 65 )
        {
          state = S_nonascii_text_1;
          *q++ = *p++;
        }
        else if ( *p == 40 )
        {
          state = S_dollar_paren_1;
          *q++ = *p++;
        }
        else
        {
          state = S_text_1;
        }
        goto LABEL_427;
      case S_paren_1:
        if ( *p == 66 || *p == 74 || *p == 84 )
        {
          state = S_text_1;
          *q++ = *p++;
        }
        else if ( *p == 73 )
        {
          state = S_nonascii_text_1;
          *q++ = *p++;
        }
        else
        {
          state = S_text_1;
        }
        goto LABEL_427;
      case S_nonascii_text_1:
        if ( *p != 27 || (HTCJK == NOCJK || hidden) && stype == st_HTML_0 )
          goto LABEL_104;
        state = S_esc_1;
        if ( stype == st_URL_0 )
        {
          if ( q != qs )
          {
            v17 = q - qs;
            if ( !chunk )
              chunk = HTChunkCreate2(128, len + 1);
            HTChunkPutb(chunk, qs, v17);
          }
          if ( !chunk )
LABEL_57:
            chunk = HTChunkCreate2(128, len + 1);
LABEL_58:
          HTChunkPuts(chunk, "%1B");
          q = *str;
          qs = q;
          ++p;
        }
        else if ( stype )
        {
          ++p;
        }
        else
        {
LABEL_104:
          *q++ = *p++;
        }
        goto LABEL_427;
      case S_dollar_paren_1:
        if ( *p == 67 )
        {
          state = S_nonascii_text_1;
          *q++ = *p++;
        }
        else
        {
          state = S_text_1;
        }
        goto LABEL_427;
      case S_trans_byte:
        if ( !*p || no_bytetrans )
        {
          state = S_got_outchar;
          goto LABEL_427;
        }
        if ( Back )
        {
          if ( *p == 1 || *p == 2 )
          {
            if ( plain_space )
            {
              *p = 32;
              code = 32;
              state = S_got_outchar;
              goto LABEL_427;
            }
            code = 160;
            if ( LYCharSet_UC[cs_to].enc == 2 || (LYCharSet_UC[cs_to].like8859 & 0x80) != 0 )
            {
              state = S_got_outchar;
              goto LABEL_427;
            }
            if ( LYCharSet_UC[cs_from].enc != 2 && (LYCharSet_UC[cs_from].like8859 & 0x80) == 0 )
            {
              state = S_check_uni;
              goto LABEL_427;
            }
            *p = -96;
          }
          else if ( *p == 7 )
          {
            code = 173;
            if ( LYCharSet_UC[cs_to].enc == 2 || (LYCharSet_UC[cs_to].like8859 & 0x80) != 0 )
            {
              state = S_got_outchar;
              goto LABEL_427;
            }
            if ( LYCharSet_UC[cs_from].enc != 2 && (LYCharSet_UC[cs_from].like8859 & 0x80) == 0 )
            {
              state = S_check_uni;
              goto LABEL_427;
            }
            *p = -83;
          }
          else if ( output_utf8 )
          {
            if ( !strcmp(LYCharSet_UC[cs_from].MIMEname, "euc-jp")
              && ((unsigned __int8)*p > 0xA0u && *p != -1 && (unsigned __int8)p[1] > 0xA0u && p[1] != -1
               || *p == -114 && (unsigned __int8)p[1] > 0xA0u && (unsigned __int8)p[1] <= 0xDFu)
              || !strcmp(LYCharSet_UC[cs_from].MIMEname, "shift_jis")
              && (unsigned __int8)p[1] > 0x3Fu
              && p[1] != 127
              && (unsigned __int8)p[1] <= 0xFCu
              && ((unsigned __int8)*p > 0x80u && (unsigned __int8)*p <= 0x9Fu
               || (unsigned __int8)*p > 0xDFu && (unsigned __int8)*p <= 0xEFu) )
            {
              code = UCTransJPToUni(p++, 2, cs_from);
              state = S_check_uni;
              goto LABEL_427;
            }
          }
          else if ( code <= 126 || T.transp )
          {
            state = S_got_outchar;
            goto LABEL_427;
          }
          rev_c = UCReverseTransChar(*p, cs_to, cs_from);
          if ( rev_c > 127 )
          {
            *p = rev_c;
            code = rev_c;
            state = S_got_outchar;
            goto LABEL_427;
          }
        }
        else if ( code <= 126 )
        {
          state = S_got_outchar;
          goto LABEL_427;
        }
        if ( from_is_utf8 )
        {
          if ( (*p & 0xC0) == 192 )
          {
            puni = p;
            code = UCGetUniFromUtf8String(&puni);
            if ( code > 0 )
              what = P_utf8;
            else
              code = (unsigned __int8)*p;
          }
LABEL_173:
          if ( use_lynx_specials && !Back && (code == 160 || code == 173) )
          {
            if ( code == 160 )
              v18 = 1;
            else
              v18 = 7;
            code = v18;
            state = S_got_outchar;
          }
          else
          {
            state = S_check_uni;
          }
          goto LABEL_427;
        }
        if ( !use_lynx_specials
          || Back
          || code != 160 && code != 173
          || LYCharSet_UC[cs_from].enc != 2 && (LYCharSet_UC[cs_from].like8859 & 0x80) == 0 )
        {
          if ( T.trans_to_uni )
          {
            code = UCTransToUni(*p, cs_from);
            if ( code <= 0 )
              code = (unsigned __int8)*p;
          }
          else if ( !T.trans_from_uni )
          {
            state = S_got_outchar;
            goto LABEL_427;
          }
          goto LABEL_173;
        }
        if ( code == 160 )
        {
          *p = 1;
          code = 1;
        }
        else
        {
          *p = 7;
          code = 7;
        }
        state = S_got_outchar;
        break;
      case S_check_ent:
        if ( *p == 38 )
        {
          pp = p + 1;
          len = strlen(p + 1);
          if ( *pp == 35
            && len > 2
            && (pp[1] == 120 || pp[1] == 88)
            && (unsigned __int8)pp[2] <= 0x7Eu
            && ((*__ctype_b_loc())[(unsigned __int8)pp[2]] & 0x1000) != 0 )
          {
            what = P_hex;
            state = S_ncr;
          }
          else if ( *pp == 35
                 && len > 2
                 && (unsigned __int8)pp[1] <= 0x7Eu
                 && ((*__ctype_b_loc())[(unsigned __int8)pp[1]] & 0x800) != 0 )
          {
            what = P_decimal;
            state = S_ncr;
          }
          else if ( (unsigned __int8)*pp <= 0x7Eu && ((*__ctype_b_loc())[(unsigned __int8)*pp] & 0x400) != 0 )
          {
            what = P_named;
            state = S_named;
          }
          else
          {
            state = S_trans_byte;
          }
        }
        else
        {
          state = S_trans_byte;
        }
        goto LABEL_427;
      case S_ncr:
        if ( what == P_hex )
          p += 3;
        else
          p += 2;
        cp = p;
        while ( *p && (unsigned __int8)*p <= 0x7Eu )
        {
          if ( what == P_hex )
          {
            if ( ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x1000) != 0 )
              goto LABEL_204;
          }
          else if ( ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x800) != 0 )
          {
LABEL_204:
            ++p;
            continue;
          }
          break;
        }
        cpe = *p;
        if ( *p )
          *p++ = 0;
        if ( what == P_hex )
        {
          if ( sscanf(cp, "%lx", &lcode) != 1 )
            goto LABEL_218;
        }
        else if ( sscanf(cp, "%lu", &lcode) != 1 )
        {
          goto LABEL_218;
        }
        if ( (lcode & 0x80000000) != 0 )
        {
LABEL_218:
          state = S_recover;
          goto LABEL_427;
        }
        code = lcode;
        if ( lcode == 1 || code > 127 && code <= 155 )
        {
          switch ( code )
          {
            case 1:
              code = 9786;
              break;
            case 128:
              code = 8364;
              break;
            case 130:
              code = 8218;
              break;
            case 132:
              code = 8222;
              break;
            case 133:
              code = 8230;
              break;
            case 134:
              code = 8224;
              break;
            case 135:
              code = 8225;
              break;
            case 137:
              code = 8240;
              break;
            case 139:
              code = 8249;
              break;
            case 145:
              code = 8216;
              break;
            case 146:
              code = 8217;
              break;
            case 147:
              code = 8220;
              break;
            case 148:
              code = 8221;
              break;
            case 149:
              code = 8226;
              break;
            case 150:
              code = 8211;
              break;
            case 151:
              code = 8212;
              break;
            case 152:
              code = 732;
              break;
            case 153:
              code = 8482;
              break;
            case 155:
              code = 8250;
              break;
            default:
              break;
          }
        }
        state = S_check_uni;
        goto LABEL_427;
      case S_check_uni:
        if ( code <= 31 && code != 9 && code != 10 && code != 13 && HTCJK == NOCJK
          || code == 127 && !HTPassHighCtrlRaw && HTCJK == NOCJK
          || code > 127 && code <= 159 && !HTPassHighCtrlNum )
        {
          state = S_recover;
          goto LABEL_427;
        }
        if ( code > 159 && stype == st_URL_0 )
        {
          state = S_got_oututf8;
          goto LABEL_427;
        }
        if ( code != 160 )
          goto LABEL_271;
        if ( plain_space )
        {
          code = 32;
          state = S_got_outchar;
          goto LABEL_427;
        }
        if ( use_lynx_specials )
        {
          code = 1;
          state = S_got_outchar;
          goto LABEL_427;
        }
        if ( hidden && !Back
          || (LYCharSet_UC[cs_to].codepoints & 2) != 0
          || LYCharSet_UC[cs_to].enc == 2
          || (LYCharSet_UC[cs_to].like8859 & 0x80) != 0 )
        {
          state = S_got_outchar;
          goto LABEL_427;
        }
        if ( (LYCharSet_UC[cs_to].repertoire & 2) == 0 )
        {
          code = 32;
          state = S_got_outchar;
          goto LABEL_427;
        }
LABEL_271:
        if ( code != 173 )
          goto LABEL_282;
        if ( plain_space )
        {
          replace_buf[0] = 0;
          state = S_got_outstring;
          goto LABEL_427;
        }
        if ( Back && LYCharSet_UC[cs_to].enc != 2 && (LYCharSet_UC[cs_to].like8859 & 0x80) == 0 )
          goto LABEL_282;
        if ( hidden || Back )
        {
          state = S_got_outchar;
        }
        else if ( use_lynx_specials )
        {
          code = 7;
          state = S_got_outchar;
        }
        else
        {
LABEL_282:
          uck = UCTransUniChar(code, cs_to);
          if ( uck <= 31 || uck > 255 || uck > 126 && uck < lowest_8 )
          {
            if ( (uck == -4 || repl_translated_C0 && uck > 0 && uck <= 31)
              && (v9 = UCTransUniCharStr(replace_buf, 60, code, cs_to, 0), (uck = v9 >= 0) != 0) )
            {
              state = S_got_outstring;
            }
            else if ( !output_utf8 || code <= 127 || code == 0x7FFFFFFF )
            {
              if ( code == 8194 || code == 8195 || code == 8201 )
              {
                if ( hidden )
                {
                  state = S_recover;
                }
                else
                {
                  if ( plain_space )
                    code = 32;
                  else
                    code = 2;
                  state = S_got_outchar;
                }
              }
              else if ( code == 8204 || code == 8205 || code == 8206 || code == 8207 )
              {
                if ( WWW_TraceFlag[0] )
                {
                  v10 = TraceFP();
                  fprintf(v10, "LYUCFullyTranslateString: Ignoring '%ld'.\n", code);
                }
                replace_buf[0] = 0;
                state = S_got_outstring;
              }
              else if ( code <= 255 )
              {
                if ( code > 160 && !HTPassEightBitNum && cs_to != LATIN1 )
                  goto LABEL_319;
                state = S_got_outchar;
              }
              else
              {
                state = S_recover;
              }
            }
            else
            {
              state = S_got_oututf8;
            }
          }
          else
          {
            code = uck;
            state = S_got_outchar;
          }
        }
        goto LABEL_427;
      case S_named:
        for ( cp = ++p; *cp && (unsigned __int8)*cp <= 0x7Eu && ((*__ctype_b_loc())[(unsigned __int8)*cp] & 8) != 0; ++cp )
          ;
        cpe = *cp;
        *cp = 0;
        name = p;
        state = S_check_name;
        goto LABEL_427;
      case S_check_name:
        code = HTMLGetEntityUCValue(name);
        if ( code <= 0 || cpe == 61 && stype == st_URL_0 )
          state = S_recover;
        else
          state = S_check_uni;
        goto LABEL_427;
      case S_recover:
LABEL_319:
        if ( what == P_decimal || what == P_hex )
        {
          *q++ = 38;
          *q++ = 35;
          if ( what == P_hex )
            *q++ = 120;
          if ( cpe )
            *(p - 1) = cpe;
          p = cp;
          state = S_done;
        }
        else if ( what == P_named )
        {
          *cp = cpe;
          *q++ = 38;
          state = S_done;
        }
        else if ( T.output_utf8 || stype || hidden || HTPassEightBitRaw && (unsigned __int8)*p >= lowest_8 )
        {
          puni = p;
          code = (unsigned __int8)*p;
          state = S_got_outchar;
        }
        else
        {
          sprintf(replace_buf, "U%.2lX", code);
          state = S_got_outstring;
        }
        goto LABEL_427;
      case S_got_oututf8:
        if ( code > 255 || code > 127 && LYCharSet_UC[cs_to].enc == 7 )
        {
          UCPutUtf8ToBuffer(replace_buf, code, 1);
          state = S_got_outstring;
        }
        else
        {
          state = S_got_outchar;
        }
        goto LABEL_427;
      case S_got_outstring:
        switch ( what )
        {
          case P_decimal:
          case P_hex:
            if ( cpe != 59 && cpe )
              *--p = cpe;
            --p;
            break;
          case P_named:
            *cp = cpe;
            if ( *cp == 59 )
              v19 = cp;
            else
              v19 = cp - 1;
            p = v19;
            break;
          case P_utf8:
            p = puni;
            break;
        }
        if ( replace_buf[0] )
        {
          if ( stype == st_URL_0
            && ((code = replace_buf[0], replace_buf[0] == 127) || code <= 31 && code != 9 && code != 10 && code) )
          {
            state = S_put_urlstring;
          }
          else
          {
            if ( q != qs )
            {
              v20 = q - qs;
              if ( !chunk )
                chunk = HTChunkCreate2(128, len + 1);
              HTChunkPutb(chunk, qs, v20);
            }
            if ( !chunk )
              chunk = HTChunkCreate2(128, len + 1);
            HTChunkPuts(chunk, replace_buf);
            q = *str;
            qs = q;
            state = S_next_char;
          }
        }
        else
        {
          state = S_next_char;
        }
        goto LABEL_427;
      case S_put_urlstring:
        esc = HTEscape(replace_buf, 1u);
        if ( q != qs )
        {
          v21 = q - qs;
          if ( !chunk )
            chunk = HTChunkCreate2(128, len + 1);
          HTChunkPutb(chunk, qs, v21);
        }
        if ( !chunk )
          chunk = HTChunkCreate2(128, len + 1);
        HTChunkPuts(chunk, esc);
        q = *str;
        qs = q;
        if ( esc )
        {
          free(esc);
          esc = 0;
        }
        state = S_next_char;
        goto LABEL_427;
      case S_got_outchar:
        switch ( what )
        {
          case P_decimal:
          case P_hex:
            if ( cpe != 59 && cpe )
              *--p = cpe;
            --p;
            break;
          case P_named:
            *cp = cpe;
            if ( *cp == 59 )
              v22 = cp;
            else
              v22 = cp - 1;
            p = v22;
            break;
          case P_utf8:
            p = puni;
            break;
        }
        if ( stype != st_URL_0 || code <= 126 && (code > 31 || code == 9 || code == 10) )
        {
          if ( !hidden && code == 10 && *p == 10 && q != qs && *(q - 1) == 13 )
          {
            *(q - 1) = *p++;
            state = S_done;
          }
          else
          {
            *q++ = code;
            state = S_next_char;
          }
        }
        else
        {
          state = S_put_urlchar;
        }
        goto LABEL_427;
      case S_put_urlchar:
        *q++ = 37;
        if ( q <= p )
        {
          *q++ = hex[(code >> 4) & 0xF];
        }
        else
        {
          v23 = q - qs;
          if ( !chunk )
            chunk = HTChunkCreate2(128, len + 1);
          HTChunkPutb(chunk, qs, v23);
          q = *str;
          qs = q;
          *q++ = hex[(code >> 4) & 0xF];
        }
        if ( q <= p )
        {
          *q++ = hex[code & 0xF];
        }
        else
        {
          v24 = q - qs;
          if ( !chunk )
            chunk = HTChunkCreate2(128, len + 1);
          HTChunkPutb(chunk, qs, v24);
          q = *str;
          qs = q;
          *q++ = hex[code & 0xF];
        }
        goto LABEL_425;
      case S_next_char:
LABEL_425:
        ++p;
        goto LABEL_426;
      case S_done:
LABEL_426:
        state = S_text_1;
        what = P_text;
        goto LABEL_427;
      default:
        goto LABEL_427;
    }
  }
  *q = 0;
  if ( chunk )
  {
    HTChunkPutb(chunk, qs, q - qs + 1);
    if ( stype == st_URL_0 || stype == st_other_0 )
    {
      LYTrimHead(chunk->data);
      LYTrimTail(chunk->data);
    }
    HTSACopy(str, chunk->data);
    HTChunkFree(chunk);
  }
  else if ( stype == st_URL_0 || stype == st_other_0 )
  {
    LYTrimHead(qs);
    LYTrimTail(qs);
  }
  return str;
}
// 80DF61E: conditional instruction was optimized away because %code.4==AD
// 80DFE3E: conditional instruction was optimized away because %code.4 is in (A1..FF)
// 80E0627: conditional instruction was optimized away because %chunk.4!=0

//----- (080E0715) --------------------------------------------------------
BOOLEAN __cdecl LYUCTranslateHTMLString(
        char **str,
        int cs_from,
        int cs_to,
        BOOLEAN use_lynx_specials,
        BOOLEAN plain_space,
        BOOLEAN hidden,
        CharUtil_st stype)
{
  return LYUCFullyTranslateString(str, cs_from, cs_to, 1, use_lynx_specials, plain_space, hidden, 0, stype) != 0;
}

//----- (080E078C) --------------------------------------------------------
BOOLEAN __cdecl LYUCTranslateBackFormData(char **str, int cs_from, int cs_to, BOOLEAN plain_space)
{
  return LYUCFullyTranslateString(str, cs_from, cs_to, 0, 0, plain_space, 1, 1, st_HTML_0) != 0;
}

//----- (080E07ED) --------------------------------------------------------
char *__cdecl LYParseTagParam(char *from, const char *name)
{
  char *stringa; // [esp+1Ch] [ebp-Ch]
  char *stringb; // [esp+1Ch] [ebp-Ch]
  char *result; // [esp+20h] [ebp-8h] BYREF
  size_t len; // [esp+24h] [ebp-4h]

  len = strlen(name);
  result = 0;
  do
  {
    from = strchr(from, 59);
    if ( !from )
      return 0;
    while ( *from && (*from == 59 || ((*__ctype_b_loc())[(unsigned __int8)*from] & 0x2000) != 0) )
      ++from;
    if ( strlen(from) < len )
      return 0;
  }
  while ( strncasecomp(from, name, len) );
  for ( stringa = &from[len];
        *stringa && (((*__ctype_b_loc())[(unsigned __int8)*stringa] & 0x2000) != 0 || *stringa == 61);
        ++stringa )
  {
    ;
  }
  HTSACopy(&result, stringa);
  for ( len = 0;
        ((*__ctype_b_loc())[(unsigned __int8)stringa[len]] & 0x4000) != 0
     && ((*__ctype_b_loc())[(unsigned __int8)stringa[len]] & 0x2000) == 0;
        ++len )
  {
    ;
  }
  result[len] = 0;
  if ( len > 2 && *result == 39 && result[len - 1] == *result )
  {
    result[len - 1] = 0;
    for ( stringb = result; ; ++stringb )
    {
      *stringb = stringb[1];
      if ( !*stringb )
        break;
    }
  }
  return result;
}

//----- (080E09D4) --------------------------------------------------------
void __cdecl LYParseRefreshURL(char *content, char **p_seconds, char **p_address)
{
  FILE *v3; // eax
  char *v4; // [esp+20h] [ebp-18h]
  char *v5; // [esp+24h] [ebp-14h]
  char *Seconds; // [esp+2Ch] [ebp-Ch] BYREF
  char *cp1; // [esp+30h] [ebp-8h]
  char *cp; // [esp+34h] [ebp-4h]

  cp1 = 0;
  Seconds = 0;
  cp = LYSkipBlanks(content);
  if ( *cp && ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x800) != 0 )
  {
    for ( cp1 = cp; *cp1 && ((*__ctype_b_loc())[(unsigned __int8)*cp1] & 0x800) != 0; ++cp1 )
      ;
    SNACopy(&Seconds, cp, cp1 - cp);
  }
  *p_seconds = Seconds;
  *p_address = LYParseTagParam(content, "URL");
  if ( WWW_TraceFlag[0] )
  {
    if ( *p_address )
      v4 = *p_address;
    else
      v4 = (char *)byte_816D938;
    if ( *p_seconds )
      v5 = *p_seconds;
    else
      v5 = (char *)byte_816D938;
    v3 = TraceFP();
    fprintf(v3, "LYParseRefreshURL\n\tcontent: %s\n\tseconds: %s\n\taddress: %s\n", content, v5, v4);
  }
}

//----- (080E0B13) --------------------------------------------------------
void __cdecl LYHandleMETA(HTStructured_0 *me, const BOOLEAN *present, const char **value, char **include)
{
  FILE *v4; // eax
  time_t v5; // ebx
  int UCLYhndl; // eax
  int v7; // eax
  char *charset; // ebx
  FILE *v9; // eax
  char *v10; // eax
  char *v11; // [esp+28h] [ebp-90h]
  char *v12; // [esp+2Ch] [ebp-8Ch]
  char *v13; // [esp+30h] [ebp-88h]
  const char *a; // [esp+34h] [ebp-84h]
  const char *v15; // [esp+38h] [ebp-80h]
  char *v16; // [esp+3Ch] [ebp-7Ch]
  const char *v17; // [esp+40h] [ebp-78h]
  char *v18; // [esp+44h] [ebp-74h]
  bool v19; // [esp+48h] [ebp-70h]
  bool v20; // [esp+4Ch] [ebp-6Ch]
  bool v21; // [esp+50h] [ebp-68h]
  const char *v22; // [esp+58h] [ebp-60h]
  const char *v23; // [esp+60h] [ebp-58h]
  const char *v24; // [esp+64h] [ebp-54h]
  char *filename; // [esp+68h] [ebp-50h]
  char *Seconds; // [esp+70h] [ebp-48h] BYREF
  int chndl; // [esp+74h] [ebp-44h]
  char *cp4; // [esp+78h] [ebp-40h]
  LYUCcharset *p_out; // [esp+7Ch] [ebp-3Ch]
  LYUCcharset *p_in; // [esp+80h] [ebp-38h]
  int url_type; // [esp+84h] [ebp-34h]
  char *cp1; // [esp+88h] [ebp-30h]
  char *cp0; // [esp+8Ch] [ebp-2Ch]
  char *cp; // [esp+90h] [ebp-28h]
  char *temp; // [esp+94h] [ebp-24h]
  char *id_string; // [esp+98h] [ebp-20h]
  char *href; // [esp+9Ch] [ebp-1Ch] BYREF
  char *content; // [esp+A0h] [ebp-18h] BYREF
  char *name; // [esp+A4h] [ebp-14h] BYREF
  char *http_equiv; // [esp+A8h] [ebp-10h] BYREF
  BOOLEAN given_and_display_8859like; // [esp+ACh] [ebp-Ch]
  BOOLEAN given_is_8859like; // [esp+ADh] [ebp-Bh]
  BOOLEAN given_is_8859; // [esp+AEh] [ebp-Ah]
  BOOLEAN chartrans_ok; // [esp+AFh] [ebp-9h]

  http_equiv = 0;
  name = 0;
  content = 0;
  href = 0;
  id_string = 0;
  temp = 0;
  cp1 = 0;
  url_type = 0;
  if ( !me || !present )
    return;
  if ( present[1] )
  {
    if ( value[1] )
    {
      if ( *value[1] )
      {
        HTSACopy(&http_equiv, value[1]);
        convert_to_spaces(http_equiv, 1);
        LYUCTranslateHTMLString(&http_equiv, me->tag_charset, me->tag_charset, 0, 0, 1, st_other_0);
        if ( !*http_equiv )
        {
          if ( http_equiv )
          {
            free(http_equiv);
            http_equiv = 0;
          }
        }
      }
    }
  }
  if ( present[2] )
  {
    if ( value[2] )
    {
      if ( *value[2] )
      {
        HTSACopy(&name, value[2]);
        convert_to_spaces(name, 1);
        LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset, 0, 0, 1, st_other_0);
        if ( !*name )
        {
          if ( name )
          {
            free(name);
            name = 0;
          }
        }
      }
    }
  }
  if ( *present )
  {
    if ( *value )
    {
      if ( **value )
      {
        HTSACopy(&content, *value);
        convert_to_spaces(content, 0);
        LYTrimHead(content);
        LYTrimTail(content);
        if ( !*content )
        {
          if ( content )
          {
            free(content);
            content = 0;
          }
        }
      }
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( content )
      v11 = content;
    else
      v11 = "NULL";
    if ( name )
      v12 = name;
    else
      v12 = "NULL";
    if ( http_equiv )
      v13 = http_equiv;
    else
      v13 = "NULL";
    v4 = TraceFP();
    fprintf(v4, "LYHandleMETA: HTTP-EQUIV=\"%s\" NAME=\"%s\" CONTENT=\"%s\"\n", v13, v12, v11);
  }
  if ( !http_equiv && !name || !content )
    goto free_META_copies;
  if ( http_equiv )
    a = http_equiv;
  else
    a = byte_816D938;
  if ( !strcasecomp(a, "Pragma")
    || (!http_equiv ? (v15 = byte_816D938) : (v15 = http_equiv), !strcasecomp(v15, "Cache-Control")) )
  {
    LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset, 0, 0, 1, st_other_0);
    if ( !strcasecomp(content, "no-cache") )
    {
      me->node_anchor->no_cache = 1;
      HText_setNoCache(me->text);
    }
    if ( !me->node_anchor->cache_control )
    {
      v16 = http_equiv ? http_equiv : (char *)byte_816D938;
      if ( !strcasecomp(v16, "Cache-Control") )
      {
        LYLowerCase(content);
        HTSACopy(&me->node_anchor->cache_control, content);
        if ( !me->node_anchor->no_cache )
        {
          for ( cp0 = content; ; cp0 = cp )
          {
            cp = strstr(cp0, "no-cache");
            if ( !cp )
              break;
            for ( cp += 8; *cp && (unsigned __int8)*cp <= 0x20u; ++cp )
              ;
            if ( !*cp || *cp == 59 )
            {
              me->node_anchor->no_cache = 1;
              HText_setNoCache(me->text);
              break;
            }
          }
          if ( me->node_anchor->no_cache != 1 )
          {
            for ( cp0 = content; ; cp0 = cp )
            {
              cp = strstr(cp0, "max-age");
              if ( !cp )
                break;
              for ( cp += 7; *cp && (unsigned __int8)*cp <= 0x20u; ++cp )
                ;
              if ( *cp == 61 )
              {
                ++cp;
                while ( *cp && (unsigned __int8)*cp <= 0x20u )
                  ++cp;
                if ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x800) != 0 )
                {
                  cp0 = cp;
                  while ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x800) != 0 )
                    ++cp;
                  if ( *cp0 == 48 && cp0 + 1 == cp )
                    goto LABEL_92;
                }
              }
            }
          }
        }
      }
    }
    goto free_META_copies;
  }
  if ( http_equiv )
    v17 = http_equiv;
  else
    v17 = byte_816D938;
  if ( strcasecomp(v17, "Expires") )
  {
    if ( !me->node_anchor->charset || !*me->node_anchor->charset )
    {
      v18 = http_equiv ? http_equiv : (char *)byte_816D938;
      if ( !strcasecomp(v18, "Content-Type") )
      {
        p_in = 0;
        p_out = 0;
        LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset, 0, 0, 1, st_other_0);
        LYLowerCase(content);
        cp1 = strstr(content, "charset");
        if ( cp1 )
        {
          chartrans_ok = 0;
          Seconds = 0;
          for ( cp1 += 7; *cp1 == 32 || *cp1 == 61 || *cp1 == 34; ++cp1 )
            ;
          HTSACopy(&Seconds, cp1);
          for ( cp4 = Seconds; *cp4 && *cp4 != 34 && *cp4 != 59 && *cp4 != 58 && (unsigned __int8)*cp4 > 0x20u; ++cp4 )
            ;
          *cp4 = 0;
          cp4 = Seconds;
          chndl = UCGetLYhndl_byMIME(Seconds);
          if ( UCCanTranslateFromTo(chndl, current_char_set) )
          {
            chartrans_ok = 1;
            HTSACopy(&me->node_anchor->charset, cp4);
            HTAnchor_setUCInfoStage(me->node_anchor, chndl, 1, 3);
          }
          else if ( chndl < 0 )
          {
            chndl = UCLYhndl_for_unrec;
            if ( UCLYhndl_for_unrec < 0 )
              chndl = UCLYhndl_for_unspec;
            if ( UCCanTranslateFromTo(chndl, current_char_set) )
            {
              chartrans_ok = 1;
              HTAnchor_setUCInfoStage(me->node_anchor, chndl, 1, 3);
            }
          }
          if ( chartrans_ok )
          {
            p_in = HTAnchor_getUCInfoStage(me->node_anchor, 1);
            p_out = HTAnchor_setUCInfoStage(me->node_anchor, current_char_set, 3, 1);
            if ( !p_out )
              p_out = HTAnchor_getUCInfoStage(me->node_anchor, 3);
            if ( !strcmp(p_in->MIMEname, "x-transparent") )
            {
              HTPassEightBitRaw = 1;
              UCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 3);
              HTAnchor_setUCInfoStage(me->node_anchor, UCLYhndl, 1, 1);
            }
            if ( !strcmp(p_out->MIMEname, "x-transparent") )
            {
              HTPassEightBitRaw = 1;
              v7 = HTAnchor_getUCLYhndl(me->node_anchor, 1);
              HTAnchor_setUCInfoStage(me->node_anchor, v7, 3, 1);
            }
            if ( p_in->enc == 5 || p_in->enc == 7 )
            {
              if ( p_out->enc == 5 )
                Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
            }
            else
            {
              HTCJK = NOCJK;
              if ( (p_in->codepoints & 1) == 0 && chndl == current_char_set )
                HTPassEightBitRaw = 1;
            }
            LYGetChartransInfo(me);
            if ( me->UCLYhndl != chndl )
            {
              HTAnchor_setUCInfoStage(me->node_anchor, chndl, 0, 3);
              HTAnchor_setUCInfoStage(me->node_anchor, chndl, 1, 3);
              me->inUCLYhndl = HTAnchor_getUCLYhndl(me->node_anchor, 1);
              me->inUCI = HTAnchor_getUCInfoStage(me->node_anchor, 1);
            }
            UCSetTransParams(&me->T, me->inUCLYhndl, me->inUCI, me->outUCLYhndl, me->outUCI);
          }
          else
          {
            v19 = !strncmp(cp4, "iso-8859-", 9u) && ((*__ctype_b_loc())[(unsigned __int8)cp4[9]] & 0x800) != 0;
            given_is_8859 = v19;
            v20 = v19 || !strncmp(cp4, "windows-", 8u) || !strncmp(cp4, "cp12", 4u) || !strncmp(cp4, "cp-12", 5u);
            given_is_8859like = v20;
            v21 = v20
               && (strstr(LYchar_set_names[current_char_set], "ISO-8859")
                || strstr(LYchar_set_names[current_char_set], "windows-"));
            given_and_display_8859like = v21;
            if ( given_is_8859 )
            {
              for ( cp1 = cp4 + 10; *cp1 && ((*__ctype_b_loc())[(unsigned __int8)*cp1] & 0x800) != 0; ++cp1 )
                ;
              *cp1 = 0;
            }
            if ( given_and_display_8859like )
            {
              HTSACopy(&me->node_anchor->charset, cp4);
              HTPassEightBitRaw = 1;
            }
            if ( *cp4 )
              HTAlert(cp4);
            else
              HTAlert(me->node_anchor->charset);
          }
          if ( Seconds )
          {
            free(Seconds);
            Seconds = 0;
          }
          if ( me->node_anchor->charset && WWW_TraceFlag[0] )
          {
            charset = me->node_anchor->charset;
            v9 = TraceFP();
            fprintf(v9, "LYHandleMETA: New charset: %s\n", charset);
          }
        }
        HText_setKcode(me->text, me->node_anchor->charset, p_in);
        goto free_META_copies;
      }
    }
    if ( http_equiv )
      v22 = http_equiv;
    else
      v22 = byte_816D938;
    if ( !strcasecomp(v22, "Refresh") )
    {
      Seconds = 0;
      LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset, 0, 0, 1, st_other_0);
      LYParseRefreshURL(content, &Seconds, &href);
      if ( Seconds )
      {
        if ( href )
        {
          url_type = LYLegitimizeHREF(me, &href, 1, 0);
          if ( url_type )
          {
            if ( me->inBASE )
              LYFillLocalFileURL(&href, me->base_href);
            else
              LYFillLocalFileURL(&href, me->node_anchor->address);
          }
          else
          {
            v10 = gettext("Refresh URL is not absolute.");
            HTUserMsg(v10);
            if ( *href )
            {
              temp = HTParse(href, me->node_anchor->address, 31);
              HTSACopy(&href, temp);
              if ( temp )
              {
                free(temp);
                temp = 0;
              }
            }
            else
            {
              HTSACopy(&href, me->node_anchor->address);
              HText_setNoCache(me->text);
            }
          }
          if ( !strcmp(href, me->node_anchor->address) )
            HText_setNoCache(me->text);
        }
        else
        {
          HTSACopy(&href, me->node_anchor->address);
          HText_setNoCache(me->text);
        }
        cp = 0;
        if ( me->inA )
        {
          if ( me->inBoldA == 1 && !me->inBoldH )
            HText_appendCharacter(me->text, 6);
          me->inBoldA = 0;
          HText_endAnchor(me->text, me->CurrentANum);
          me->inA = 0;
          me->CurrentANum = 0;
        }
        me->CurrentA = HTAnchor_findChildAndLink(me->node_anchor, id_string, href, 0);
        if ( id_string )
          *cp = 35;
        if ( id_string )
        {
          free(id_string);
          id_string = 0;
        }
        LYEnsureSingleSpace(me);
        if ( !me->inUnderline )
          HText_appendCharacter(me->text, 3);
        HTML_put_string((HTStructured *)me, "REFRESH(");
        HTML_put_string((HTStructured *)me, Seconds);
        HTML_put_string((HTStructured *)me, " sec):");
        if ( Seconds )
        {
          free(Seconds);
          Seconds = 0;
        }
        if ( !me->inUnderline )
          HText_appendCharacter(me->text, 4);
        HTML_put_character((HTStructured *)me, 32);
        me->in_word = 0;
        HText_beginAnchor(me->text, me->inUnderline, me->CurrentA);
        if ( !me->inBoldH )
          HText_appendCharacter(me->text, 5);
        HTML_put_string((HTStructured *)me, href);
        if ( href )
        {
          free(href);
          href = 0;
        }
        if ( !me->inBoldH )
          HText_appendCharacter(me->text, 6);
        HText_endAnchor(me->text, 0);
        LYEnsureSingleSpace(me);
      }
      goto free_META_copies;
    }
    if ( me->node_anchor->SugFname && *me->node_anchor->SugFname
      || (!http_equiv ? (v23 = byte_816D938) : (v23 = http_equiv), strcasecomp(v23, "Content-Disposition")) )
    {
      if ( http_equiv )
        v24 = http_equiv;
      else
        v24 = byte_816D938;
      if ( !strcasecomp(v24, "Set-Cookie") )
      {
        filename = me->inBASE ? me->base_href : me->node_anchor->address;
        url_type = is_url(filename);
        if ( url_type == 2 || url_type == 20 )
        {
          if ( me->inBASE )
            LYSetCookie(content, 0, me->base_href);
          else
            LYSetCookie(content, 0, me->node_anchor->address);
        }
      }
      goto free_META_copies;
    }
    for ( cp = content; *cp && strncasecomp(cp, "filename", 8); ++cp )
      ;
    if ( !*cp )
      goto free_META_copies;
    cp = LYSkipBlanks(cp + 8);
    if ( *cp == 61 )
      ++cp;
    cp = LYSkipBlanks(cp);
    if ( !*cp )
      goto free_META_copies;
    HTSACopy(&me->node_anchor->SugFname, cp);
    if ( *me->node_anchor->SugFname == 34 )
    {
      cp = strchr((const char *)me->node_anchor->SugFname + 1, 34);
      if ( !cp )
      {
        if ( !me->node_anchor->SugFname )
          goto LABEL_229;
        goto LABEL_228;
      }
      cp[1] = 0;
      HTMIME_TrimDoubleQuotes(me->node_anchor->SugFname);
      if ( (!me->node_anchor->SugFname || !*me->node_anchor->SugFname) && me->node_anchor->SugFname )
      {
LABEL_228:
        free(me->node_anchor->SugFname);
        me->node_anchor->SugFname = 0;
      }
    }
LABEL_229:
    cp = me->node_anchor->SugFname;
    if ( cp )
    {
      while ( *cp )
      {
        if ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x2000) != 0 )
          *cp = 95;
        ++cp;
      }
    }
    goto free_META_copies;
  }
  LYUCTranslateHTMLString(&content, me->tag_charset, me->tag_charset, 0, 0, 1, st_other_0);
  HTSACopy(&me->node_anchor->expires, content);
  if ( me->node_anchor->no_cache )
    goto free_META_copies;
  if ( !strcmp(content, "0") )
  {
LABEL_92:
    me->node_anchor->no_cache = 1;
    HText_setNoCache(me->text);
    goto free_META_copies;
  }
  if ( !me->node_anchor->date )
  {
    if ( LYmktime(content, 0) )
      goto free_META_copies;
    goto LABEL_92;
  }
  v5 = LYmktime(content, 1);
  if ( v5 <= LYmktime(me->node_anchor->date, 1) )
    goto LABEL_92;
free_META_copies:
  if ( http_equiv )
  {
    free(http_equiv);
    http_equiv = 0;
  }
  if ( name )
  {
    free(name);
    name = 0;
  }
  if ( content )
    free(content);
}

//----- (080E20B0) --------------------------------------------------------
void __cdecl LYHandlePlike(
        HTStructured_0 *me,
        const BOOLEAN *present,
        const char **value,
        char **include,
        int align_idx,
        BOOLEAN start)
{
  HTStyle *style; // ebx

  if ( start )
  {
    if ( me->inFIG )
      me->inFIGwithP = 1;
    if ( me->inAPPLET )
      me->inAPPLETwithP = 1;
  }
  if ( me->style_change )
    actually_set_style((HTStructured *)me);
  if ( me->List_Nesting_Level < 0 )
  {
    if ( me->sp->tag_number == 3 )
    {
      if ( !HText_LastLineEmpty(me->text, 0) )
      {
        HText_setLastChar(me->text, 32);
        HText_appendCharacter(me->text, 13);
      }
    }
    else
    {
      if ( start )
      {
        if ( !me->inLABEL || me->inP )
          HText_appendParagraph(me->text);
      }
      else if ( me->sp->style->spaceAfter <= 0 )
      {
        LYEnsureSingleSpace(me);
      }
      else
      {
        LYEnsureDoubleSpace(me);
      }
      me->inLABEL = 0;
    }
  }
  else if ( me->inP )
  {
    if ( me->inFIG
      || me->inAPPLET
      || me->inCAPTION
      || me->inCREDIT
      || me->sp->style->spaceAfter > 0
      || start && me->sp->style->spaceBefore > 0 )
    {
      LYEnsureDoubleSpace(me);
    }
    else
    {
      LYEnsureSingleSpace(me);
    }
  }
  me->in_word = 0;
  if ( LYoverride_default_alignment(me) )
  {
    style = me->sp->style;
    style->alignment = LYstyles(me->sp->tag_number)->alignment;
  }
  else if ( me->List_Nesting_Level >= 0 && (me->sp->style->id == 1 || me->sp->style->id == 2 || me->sp->style->id == 3)
         || me->Division_Level < 0 && (!me->sp->style->id || me->sp->style->id == 37) )
  {
    me->sp->style->alignment = 1;
  }
  else
  {
    me->sp->style->alignment = me->current_default_alignment;
  }
  if ( start && present && present[align_idx] && value[align_idx] )
  {
    if ( strcasecomp(value[align_idx], "center") || me->List_Nesting_Level >= 0 && !me->inP )
    {
      if ( strcasecomp(value[align_idx], "right") || me->List_Nesting_Level >= 0 && !me->inP )
      {
        if ( !strcasecomp(value[align_idx], "left") || !strcasecomp(value[align_idx], "justify") )
          me->sp->style->alignment = 1;
      }
      else
      {
        me->sp->style->alignment = 2;
      }
    }
    else
    {
      me->sp->style->alignment = 3;
    }
  }
  me->inP = 0;
}

//----- (080E2490) --------------------------------------------------------
void __cdecl LYHandleSELECT(
        HTStructured_0 *me,
        const BOOLEAN *present,
        const char **value,
        char **include,
        BOOLEAN start)
{
  FILE *v5; // eax
  FILE *v6; // eax
  const char *v7; // ebx
  FILE *v8; // eax
  FILE *v9; // eax
  char *ptr; // [esp+38h] [ebp-20h]
  char *name; // [esp+40h] [ebp-18h] BYREF
  int i; // [esp+44h] [ebp-14h]
  BOOLEAN multiple; // [esp+4Bh] [ebp-Dh]

  if ( start == 1 )
  {
    name = 0;
    multiple = 0;
    me->select_disabled = 0;
    if ( !me->inFORM && LYBadHTML((HTStructured *)me) && WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "Bad HTML: SELECT start tag not within FORM tag\n");
    }
    if ( me->inTEXTAREA && LYBadHTML((HTStructured *)me) && WWW_TraceFlag[0] )
    {
      v6 = TraceFP();
      fprintf(v6, "Bad HTML: Missing TEXTAREA end tag\n");
    }
    me->inSELECT = 1;
    if ( present && present[11] && value[11] && *value[11] )
    {
      if ( strchr(value[11], 38) )
      {
        HTSACopy(&name, value[11]);
        LYUCTranslateHTMLString(&name, me->tag_charset, me->tag_charset, 0, 0, 1, st_HTML_0);
      }
      else
      {
        HTSACopy(&name, value[11]);
      }
    }
    else
    {
      HTSACopy(&name, byte_816D938);
    }
    if ( present && present[10] )
      multiple = 1;
    if ( present && present[4] )
      me->select_disabled = 1;
    if ( present && present[16] && value[16] && *value[16] && WWW_TraceFlag[0] )
    {
      v7 = value[16];
      v8 = TraceFP();
      fprintf(v8, "LYHandleSELECT: Ignoring SIZE=\"%s\" for SELECT.\n", v7);
    }
    if ( me->inBoldH == 1 && (!multiple || !LYSelectPopups) )
    {
      HText_appendCharacter(me->text, 6);
      me->inBoldH = 0;
      me->needBoldH = 1;
    }
    if ( me->inUnderline == 1 && (!multiple || !LYSelectPopups) )
    {
      HText_appendCharacter(me->text, 4);
      me->inUnderline = 0;
    }
    if ( !multiple
      && LYSelectPopups == 1
      && (me->sp->tag_number == 86 || me->inPRE == 1 || !me->sp->style->freeFormat)
      && HText_LastLineSize(me->text, 0) > LYcols - (LYShowScrollbar != 0) - 7 )
    {
      HTML_put_character((HTStructured *)me, 10);
      me->in_word = 0;
    }
    LYCheckForID(me, present, value, 7);
    HText_beginSelect(name, me->tag_charset, multiple, 0);
    if ( name )
    {
      free(name);
      name = 0;
    }
    me->first_option = 1;
  }
  else if ( me->inSELECT )
  {
    me->inSELECT = 0;
    me->select_disabled = 0;
    HTChunkTerminate(&me->option);
    ptr = HText_setLastOptionValue(
            me->text,
            me->option.data,
            me->LastOptionValue,
            3,
            me->LastOptionChecked,
            me->UCLYhndl,
            me->tag_charset);
    if ( me->LastOptionValue )
    {
      free(me->LastOptionValue);
      me->LastOptionValue = 0;
    }
    me->LastOptionChecked = 0;
    if ( HTCurSelectGroupType != 3 && LYSelectPopups )
    {
      if ( ptr && me->sp->tag_number == 86 && strlen(ptr) > 6 )
      {
        for ( i = 0; i <= 5; ++i )
        {
          if ( *ptr == 32 )
            HText_appendCharacter(me->text, 1);
          else
            HText_appendCharacter(me->text, *ptr);
          ++ptr;
        }
        HText_setIgnoreExcess(me->text, 1);
      }
      while ( ptr && *ptr )
      {
        if ( *ptr == 32 )
          HText_appendCharacter(me->text, 1);
        else
          HText_appendCharacter(me->text, *ptr);
        ++ptr;
      }
      if ( !me->first_option )
      {
        HText_appendCharacter(me->text, 93);
        HText_setLastChar(me->text, 93);
        me->in_word = 1;
      }
      HText_setIgnoreExcess(me->text, 0);
    }
    else
    {
      LYEnsureSingleSpace(me);
    }
    HTChunkClear(&me->option);
    if ( me->Underline_Level > 0 && !me->inUnderline )
    {
      HText_appendCharacter(me->text, 3);
      me->inUnderline = 1;
    }
    if ( me->needBoldH == 1 && !me->inBoldH )
    {
      HText_appendCharacter(me->text, 5);
      me->inBoldH = 1;
      me->needBoldH = 0;
    }
  }
  else if ( LYBadHTML((HTStructured *)me) && WWW_TraceFlag[0] )
  {
    v9 = TraceFP();
    fprintf(v9, "Bad HTML: Unmatched SELECT end tag\n");
  }
}
// 80E2843: conditional instruction was optimized away because %size.4==0

//----- (080E2B71) --------------------------------------------------------
int __cdecl LYLegitimizeHREF(HTStructured_0 *me, char **href, BOOLEAN force_slash, BOOLEAN strip_dots)
{
  char *v4; // ebx
  FILE *v5; // edx
  FILE *v6; // eax
  char *v7; // eax
  char *base_href; // [esp+28h] [ebp-30h]
  const char *str; // [esp+34h] [ebp-24h]
  char *cp; // [esp+38h] [ebp-20h]
  char *path; // [esp+3Ch] [ebp-1Ch]
  char *temp; // [esp+40h] [ebp-18h]
  char *pound; // [esp+48h] [ebp-10h]
  char *p; // [esp+4Ch] [ebp-Ch]
  char *pa; // [esp+4Ch] [ebp-Ch]
  UrlTypes url_type; // [esp+50h] [ebp-8h]

  if ( !me || !href || !*href || !**href )
    return 0;
  if ( !LYTrimStartfile(*href) )
  {
    p = LYSkipNonBlanks(*href);
    if ( *p )
    {
      pound = strchr(*href, 35);
      if ( pound && pound < p )
      {
        convert_to_spaces(p, 0);
      }
      else
      {
        if ( pound )
          *pound = 0;
        if ( LYRemoveNewlines(p) || strchr(p, 9) )
          LYRemoveBlanks(p);
        if ( pound )
        {
          pa = strchr(p, 0);
          *pound = 35;
          convert_to_spaces(pound, 0);
          if ( pa < pound )
            strcpy(pa, pound);
        }
      }
    }
  }
  if ( !**href )
    return 0;
  LYUCTranslateHTMLString(href, me->tag_charset, me->tag_charset, 0, 0, 1, st_URL_0);
  if ( me->inBASE )
    base_href = me->base_href;
  else
    base_href = me->node_anchor->address;
  url_type = is_url(*href);
  if ( url_type == NOT_A_URL_TYPE_0
    && force_slash
    && **href == 46
    && (!strcmp(*href, ".") || !strcmp(*href, ".."))
    && (*base_href != 102 && *base_href != 70 || strncasecomp(base_href, "file:", 5)) )
  {
    HTSACat(href, "/");
  }
  if ( url_type == NOT_A_URL_TYPE_0
    && LYStripDotDotURLs
    && strip_dots
    && **href == 46
    && !strncasecomp(base_href, "http", 4) )
  {
    str = byte_816D938;
    temp = HTParse(*href, base_href, 31);
    path = HTParse(temp, byte_816D938, 5);
    if ( !strncmp(path, "/..", 3u) )
    {
      cp = path + 3;
      if ( path[3] == 47 || !*cp )
      {
        if ( base_href[4] == 115 )
          str = "s";
        if ( WWW_TraceFlag[0] )
        {
          v4 = *href;
          v5 = TraceFP();
          fprintf(v5, "LYLegitimizeHREF: Bad value '%s' for http%s URL.\n", v4, str);
        }
        if ( WWW_TraceFlag[0] )
        {
          v6 = TraceFP();
          fprintf(v6, "                  Stripping lead dots.\n");
        }
        if ( !me->inBadHREF )
        {
          v7 = gettext("Bad partial reference!  Stripping lead dots.");
          HTUserMsg(v7);
          me->inBadHREF = 1;
        }
      }
      if ( *cp )
      {
        if ( *cp == 47 )
        {
          while ( !strncmp(cp, "/..", 3u) )
          {
            if ( cp[3] != 47 )
            {
              if ( !cp[3] )
              {
                cp[1] = 0;
                cp[2] = 0;
              }
              break;
            }
            cp += 3;
          }
          HTSACopy(href, cp);
        }
      }
      else
      {
        HTSACopy(href, "/");
      }
    }
    if ( temp )
      free(temp);
    if ( path )
      free(path);
  }
  return url_type;
}

//----- (080E3049) --------------------------------------------------------
void __cdecl LYCheckForContentBase(HTStructured_0 *me)
{
  const char *value[6]; // [esp+20h] [ebp-28h] BYREF
  BOOLEAN present[6]; // [esp+3Ah] [ebp-Eh] BYREF
  int i; // [esp+40h] [ebp-8h]
  char *cp; // [esp+44h] [ebp-4h] BYREF

  cp = 0;
  if ( me && me->node_anchor )
  {
    if ( me->node_anchor->content_base )
    {
      if ( !*me->node_anchor->content_base )
        return;
      HTSACopy(&cp, me->node_anchor->content_base);
      LYRemoveBlanks(cp);
    }
    else
    {
      if ( !me->node_anchor->content_location || !*me->node_anchor->content_location )
        return;
      HTSACopy(&cp, me->node_anchor->content_location);
      LYRemoveBlanks(cp);
      if ( is_url(cp) == NOT_A_URL_TYPE_0 )
      {
        if ( !cp )
          return;
        goto LABEL_10;
      }
    }
    if ( *cp )
    {
      for ( i = 0; i <= 5; ++i )
        present[i] = 0;
      present[1] = 1;
      value[1] = cp;
      me->isa->start_element((HTStructured *)me, 10, present, value, 0, 0);
      if ( cp )
        free(cp);
    }
    else if ( cp )
    {
LABEL_10:
      free(cp);
      cp = 0;
    }
  }
}

//----- (080E31E1) --------------------------------------------------------
void __cdecl LYCheckForID(HTStructured_0 *me, const BOOLEAN *present, const char **value, int attribute)
{
  char *temp; // [esp+30h] [ebp-8h] BYREF
  HTChildAnchor *ID_A; // [esp+34h] [ebp-4h]

  ID_A = 0;
  temp = 0;
  if ( me && me->text && present && present[attribute] && value[attribute] && *value[attribute] )
  {
    HTSACopy(&temp, value[attribute]);
    LYUCTranslateHTMLString(&temp, me->tag_charset, me->tag_charset, 0, 0, 1, st_URL_0);
    if ( *temp )
    {
      ID_A = HTAnchor_findChildAndLink(me->node_anchor, temp, 0, 0);
      if ( ID_A )
      {
        HText_beginAnchor(me->text, me->inUnderline, ID_A);
        HText_endAnchor(me->text, 0);
      }
    }
    if ( temp )
      free(temp);
  }
}

//----- (080E333F) --------------------------------------------------------
void __cdecl LYHandleID(HTStructured_0 *me, const char *id)
{
  HTChildAnchor *ID_A; // [esp+24h] [ebp-4h]

  if ( me && me->text && id && *id )
  {
    ID_A = HTAnchor_findChildAndLink(me->node_anchor, id, 0, 0);
    if ( ID_A )
    {
      HText_beginAnchor(me->text, me->inUnderline, ID_A);
      HText_endAnchor(me->text, 0);
    }
  }
}

//----- (080E33DC) --------------------------------------------------------
BOOLEAN __cdecl LYoverride_default_alignment(HTStructured_0 *me)
{
  int tag_number; // [esp+4h] [ebp-4h]

  if ( me )
  {
    tag_number = me->sp->tag_number;
    if ( tag_number != 19 )
    {
      if ( tag_number > 19 )
      {
        if ( tag_number != 42 && tag_number != 78 )
          return 0;
      }
      else if ( tag_number != 3 && tag_number != 16 )
      {
        return 0;
      }
    }
    me->sp->style->alignment = 1;
    return 1;
  }
  return 0;
}

//----- (080E3444) --------------------------------------------------------
void __cdecl LYEnsureDoubleSpace(HTStructured_0 *me)
{
  if ( me && me->text )
  {
    if ( HText_LastLineEmpty(me->text, 0) )
    {
      if ( HText_PreviousLineEmpty(me->text, 0) )
      {
        if ( me->List_Nesting_Level >= 0 )
          HText_NegateLineOne(me->text);
      }
      else
      {
        HText_setLastChar(me->text, 32);
        HText_appendCharacter(me->text, 13);
      }
    }
    else
    {
      HText_setLastChar(me->text, 32);
      HText_appendCharacter(me->text, 13);
      HText_appendCharacter(me->text, 13);
    }
    me->in_word = 0;
  }
}

//----- (080E352F) --------------------------------------------------------
void __cdecl LYEnsureSingleSpace(HTStructured_0 *me)
{
  if ( me && me->text )
  {
    if ( HText_LastLineEmpty(me->text, 0) )
    {
      if ( me->List_Nesting_Level >= 0 )
        HText_NegateLineOne(me->text);
    }
    else
    {
      HText_setLastChar(me->text, 32);
      HText_appendCharacter(me->text, 13);
    }
    me->in_word = 0;
  }
}

//----- (080E35B4) --------------------------------------------------------
void __cdecl LYResetParagraphAlignment(HTStructured_0 *me)
{
  if ( me )
  {
    if ( me->List_Nesting_Level < 0 && (me->Division_Level >= 0 || me->sp->style->id && me->sp->style->id != 37) )
      me->sp->style->alignment = me->current_default_alignment;
    else
      me->sp->style->alignment = 1;
  }
}

//----- (080E3629) --------------------------------------------------------
BOOLEAN __cdecl LYCheckForCSI(HTParentAnchor *anchor, char **url)
{
  if ( !anchor || !anchor->address )
    return 0;
  if ( *anchor->address != 102 && *anchor->address != 70 || strncasecomp(anchor->address, "file:", 5) )
    return 0;
  if ( !LYisLocalHost(anchor->address) )
    return 0;
  HTSACopy(url, anchor->address);
  return 1;
}

//----- (080E36BE) --------------------------------------------------------
BOOLEAN __cdecl LYCommentHacks(HTParentAnchor *anchor, const char *comment)
{
  char *p_0; // [esp+34h] [ebp-14h]
  char *p_0a; // [esp+34h] [ebp-14h]
  char *subject; // [esp+38h] [ebp-10h] BYREF
  char *p; // [esp+3Ch] [ebp-Ch]
  size_t len; // [esp+40h] [ebp-8h]
  const char *cp; // [esp+44h] [ebp-4h]

  cp = comment;
  if ( !comment )
    return 0;
  if ( !anchor || !anchor->address )
    return 0;
  if ( !strncmp(comment, "!--X-Message-Id: ", 0x11u) )
  {
    subject = 0;
    for ( cp = comment + 17; *cp && *cp <= 0x7Eu && ((*__ctype_b_loc())[*(unsigned __int8 *)cp] & 0x8000u) != 0; ++cp )
      ;
    if ( !strcmp(cp, " --") )
    {
      cp = comment + 17;
      HTSACopy(&subject, comment + 17);
      if ( LYUCTranslateHTMLString(&subject, 0, 0, 0, 0, 1, st_URL_0) )
      {
        for ( p = subject;
              *p && (unsigned __int8)*p <= 0x7Eu && ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x8000u) != 0;
              ++p )
        {
          ;
        }
        if ( !strcmp(p, " --") )
        {
          p = strchr(subject, 64);
          if ( p && p[1] )
          {
            p = subject;
            len = strlen(subject);
            if ( len > 7 && !strcmp(&p[len - 3], " --") )
            {
              p[len - 3] = 0;
              if ( HTAnchor_setMessageID(anchor, subject) )
              {
                if ( subject )
                {
                  free(subject);
                  subject = 0;
                }
                return 1;
              }
              else
              {
                if ( subject )
                {
                  free(subject);
                  subject = 0;
                }
                return 0;
              }
            }
            else
            {
              if ( subject )
              {
                free(subject);
                subject = 0;
              }
              return 0;
            }
          }
          else
          {
            if ( subject )
            {
              free(subject);
              subject = 0;
            }
            return 0;
          }
        }
        else
        {
          if ( subject )
          {
            free(subject);
            subject = 0;
          }
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else if ( !strncmp(comment, "!--X-Subject: ", 0xEu) )
  {
    subject = 0;
    for ( cp = comment + 14; *cp; ++cp )
    {
      if ( *cp > 0x7Eu || ((*__ctype_b_loc())[*(unsigned __int8 *)cp] & 0x4000) == 0 )
        return 0;
    }
    cp = comment + 14;
    HTSACopy(&subject, comment + 14);
    if ( LYUCTranslateHTMLString(&subject, 0, 0, 0, 1, 0, st_HTML_0) )
    {
      for ( p_0 = subject; ; ++p_0 )
      {
        if ( !*p_0 )
        {
          p_0a = subject;
          len = strlen(subject);
          if ( len > 3 && !strcmp(&p_0a[len - 3], " --") )
          {
            p_0a[len - 3] = 0;
            if ( HTAnchor_setSubject(anchor, subject) )
            {
              if ( subject )
              {
                free(subject);
                subject = 0;
              }
              return 1;
            }
            else
            {
              if ( subject )
              {
                free(subject);
                subject = 0;
              }
              return 0;
            }
          }
          else
          {
            if ( subject )
            {
              free(subject);
              subject = 0;
            }
            return 0;
          }
        }
        if ( (unsigned __int8)*p_0 > 0x7Eu || ((*__ctype_b_loc())[(unsigned __int8)*p_0] & 0x4000) == 0 )
          break;
      }
      if ( subject )
      {
        free(subject);
        subject = 0;
      }
      return 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

//----- (080E3B66) --------------------------------------------------------
void __cdecl LYformTitle(char **dst, const char *src)
{
  size_t v2; // eax
  FILE *v3; // eax
  unsigned __int8 *tmp_buffer; // [esp+24h] [ebp-4h]

  if ( HTCJK == JAPANESE )
  {
    v2 = strlen(src);
    tmp_buffer = (unsigned __int8 *)malloc(v2 + 1);
    if ( !tmp_buffer )
      outofmem("./LYCharUtils.c", "LYformTitle");
    if ( kanji_code == EUC )
    {
      TO_EUC((const unsigned __int8 *)src, tmp_buffer);
    }
    else if ( kanji_code == SJIS )
    {
      TO_SJIS((const unsigned __int8 *)src, tmp_buffer);
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "\nLYformTitle: kanji_code is an unexpected value.");
      }
      strcpy((char *)tmp_buffer, src);
    }
    HTSACopy(dst, (const char *)tmp_buffer);
    free(tmp_buffer);
  }
  else
  {
    HTSACopy(dst, src);
  }
}
// 80E3C3C: conditional instruction was optimized away because %tmp_buffer.4!=0

//----- (080E3C68) --------------------------------------------------------
void __cdecl ImageMapList_free(HTList *theList)
{
  void **v1; // [esp+10h] [ebp-18h]
  void *object; // [esp+14h] [ebp-14h]
  HTList *current; // [esp+18h] [ebp-10h]
  HTList *cur; // [esp+1Ch] [ebp-Ch]

  cur = theList;
  if ( theList )
  {
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( *(_DWORD *)object )
      {
        free(*(void **)object);
        *(_DWORD *)object = 0;
      }
      if ( *((_DWORD *)object + 1) )
      {
        free(*((void **)object + 1));
        *((_DWORD *)object + 1) = 0;
      }
      if ( *((_DWORD *)object + 2) )
      {
        current = (HTList *)*((_DWORD *)object + 2);
        while ( 1 )
        {
          if ( current && (current = current->next) != 0 )
            v1 = (void **)current->object;
          else
            v1 = 0;
          if ( !v1 )
            break;
          if ( *v1 )
          {
            free(*v1);
            *v1 = 0;
          }
          if ( v1[1] )
          {
            free(v1[1]);
            v1[1] = 0;
          }
          free(v1);
        }
        HTList_delete(*((HTList **)object + 2));
        *((_DWORD *)object + 2) = 0;
      }
      free(object);
    }
    HTList_delete(theList);
  }
}
// 80E3D22: conditional instruction was optimized away because %var_18.4!=0
// 80E3D88: conditional instruction was optimized away because %var_14.4!=0

//----- (080E3DDF) --------------------------------------------------------
BOOLEAN __cdecl LYAddImageMap(char *address, char *title, HTParentAnchor *node_anchor)
{
  void **v5; // [esp+Ch] [ebp-2Ch]
  LYImageMap *object; // [esp+10h] [ebp-28h]
  char **p_address; // [esp+14h] [ebp-24h]
  HTList *curele; // [esp+24h] [ebp-14h]
  HTList *theList; // [esp+28h] [ebp-10h]
  HTList *cur; // [esp+2Ch] [ebp-Ch]
  LYImageMap *old; // [esp+30h] [ebp-8h]

  old = 0;
  if ( !address || !*address )
    return 0;
  if ( !node_anchor || !node_anchor->address )
    return 0;
  if ( !LynxMaps )
    LynxMaps = HTList_new();
  theList = LynxMaps;
  if ( LynxMaps )
  {
    cur = LynxMaps;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (LYImageMap *)cur->object;
      else
        object = 0;
      old = object;
      if ( !object )
        break;
      if ( object->address && !strcmp(object->address, address) )
      {
        if ( object->address )
        {
          free(object->address);
          object->address = 0;
        }
        if ( object->title )
        {
          free(object->title);
          object->title = 0;
        }
        if ( object->elements )
        {
          curele = object->elements;
          while ( 1 )
          {
            if ( curele && (curele = curele->next) != 0 )
              v5 = (void **)curele->object;
            else
              v5 = 0;
            if ( !v5 )
              break;
            if ( *v5 )
            {
              free(*v5);
              *v5 = 0;
            }
            if ( v5[1] )
            {
              free(v5[1]);
              v5[1] = 0;
            }
            free(v5);
          }
          HTList_delete(object->elements);
          object->elements = 0;
        }
        break;
      }
    }
  }
  if ( old )
    p_address = &old->address;
  else
    p_address = (char **)calloc(1u, 0xCu);
  if ( !p_address )
    outofmem("./LYMap.c", "LYAddImageMap");
  HTSACopy(p_address, address);
  if ( title && *title )
    HTSACopy(p_address + 1, title);
  if ( p_address != (char **)old )
    HTList_addObject(theList, p_address);
  return 1;
}
// 80E3F39: conditional instruction was optimized away because %var_2C.4!=0

//----- (080E4079) --------------------------------------------------------
BOOLEAN __cdecl LYAddMapElement(
        char *map,
        char *address,
        char *title,
        HTParentAnchor *node_anchor,
        BOOLEAN intern_flag)
{
  FILE *v5; // eax
  void *object; // [esp+20h] [ebp-28h]
  void **v9; // [esp+24h] [ebp-24h]
  char *v10; // [esp+28h] [ebp-20h]
  HTList *cur; // [esp+38h] [ebp-10h]
  HTList *cura; // [esp+38h] [ebp-10h]
  LYMapElement *tmp; // [esp+44h] [ebp-4h]

  if ( !map || !*map || !address || !*address )
    return 0;
  if ( !node_anchor || !node_anchor->address )
    return 0;
  if ( !LynxMaps )
    LYAddImageMap(map, 0, node_anchor);
  cur = LynxMaps;
  do
  {
    if ( cur && (cur = cur->next) != 0 )
      object = cur->object;
    else
      object = 0;
  }
  while ( object && strcmp(*(const char **)object, map) );
  if ( !object )
    return 0;
  if ( !*((_DWORD *)object + 2) )
    *((_DWORD *)object + 2) = HTList_new();
  cura = (HTList *)*((_DWORD *)object + 2);
  while ( 1 )
  {
    if ( cura && (cura = cura->next) != 0 )
      v9 = (void **)cura->object;
    else
      v9 = 0;
    if ( !v9 )
      break;
    if ( !strcmp((const char *)*v9, address) )
    {
      if ( *v9 )
      {
        free(*v9);
        *v9 = 0;
      }
      if ( v9[1] )
      {
        free(v9[1]);
        v9[1] = 0;
      }
      HTList_removeObject(*((HTList **)object + 2), v9);
      free(v9);
      break;
    }
  }
  tmp = (LYMapElement *)calloc(1u, 8u);
  if ( tmp )
  {
    HTSACopy(&tmp->address, address);
    if ( title && *title )
      HTSACopy(&tmp->title, title);
    else
      HTSACopy(&tmp->title, address);
    HTList_appendObject(*((HTList **)object + 2), tmp);
    if ( WWW_TraceFlag[0] )
    {
      if ( title )
        v10 = title;
      else
        v10 = (char *)&unk_816DCA5;
      v5 = TraceFP();
      fprintf(v5, "LYAddMapElement\n\tmap     %s\n\taddress %s\n\ttitle   %s)\n", map, address, v10);
    }
    return 1;
  }
  else
  {
    perror("Out of memory in LYAddMapElement");
    return 0;
  }
}
// 80E430B: conditional instruction was optimized away because %address.4!=0
// 80E4320: conditional instruction was optimized away because %map.4!=0
// 80E4206: conditional instruction was optimized away because %var_24.4!=0

//----- (080E4367) --------------------------------------------------------
BOOLEAN __cdecl LYHaveImageMap(char *address)
{
  const char **object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+20h] [ebp-8h]

  cur = LynxMaps;
  if ( !LynxMaps || !address || !*address )
    return 0;
  while ( 1 )
  {
    if ( cur && (cur = cur->next) != 0 )
      object = (const char **)cur->object;
    else
      object = 0;
    if ( !object )
      break;
    if ( !strcmp(*object, address) )
      return 1;
  }
  return 0;
}

//----- (080E43EB) --------------------------------------------------------
void __cdecl fill_DocAddress(DocAddress *wwwdoc, char *address, HTParentAnchor *anAnchor, HTParentAnchor **punderlying)
{
  HTParentAnchor *underlying; // [esp+14h] [ebp-4h]

  if ( anAnchor && anAnchor->post_data )
  {
    wwwdoc->address = address;
    wwwdoc->post_data = anAnchor->post_data;
    wwwdoc->post_content_type = anAnchor->post_content_type;
    wwwdoc->bookmark = 0;
    wwwdoc->isHEAD = 0;
    wwwdoc->safe = 0;
    underlying = HTAnchor_findAddress(wwwdoc);
    if ( underlying->safe )
      wwwdoc->safe = 1;
    if ( punderlying )
      *punderlying = underlying;
  }
  else
  {
    wwwdoc->address = address;
    wwwdoc->post_data = 0;
    wwwdoc->post_content_type = 0;
    wwwdoc->bookmark = 0;
    wwwdoc->isHEAD = 0;
    wwwdoc->safe = 0;
    if ( punderlying )
      *punderlying = 0;
  }
}

//----- (080E44AE) --------------------------------------------------------
HTList *__cdecl get_the_list(DocAddress *wwwdoc, char *address, HTParentAnchor *anchor, HTParentAnchor **punderlying)
{
  if ( anchor && anchor->post_data )
  {
    fill_DocAddress(wwwdoc, address, anchor, punderlying);
    if ( punderlying && *punderlying )
      return (*punderlying)->imaps;
    else
      return anchor->imaps;
  }
  else
  {
    fill_DocAddress(wwwdoc, address, 0, punderlying);
    return LynxMaps;
  }
}

//----- (080E453F) --------------------------------------------------------
int __cdecl LYLoadIMGmap(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *name; // esi
  char *v12; // ebx
  char *v13; // eax
  void (*put_block)(HTStream *, const char *, int); // ebx
  size_t v15; // eax
  void (*v16)(HTStream *, const char *, int); // ebx
  size_t v17; // eax
  void (*v18)(HTStream *, const char *, int); // ebx
  size_t v19; // eax
  void (*v20)(HTStream *, const char *, int); // ebx
  size_t v21; // eax
  void (*v22)(HTStream *, const char *, int); // ebx
  size_t v23; // eax
  void (*v24)(HTStream *, const char *, int); // ebx
  size_t v25; // eax
  void (*v26)(HTStream *, const char *, int); // ebx
  size_t v27; // eax
  void (*v28)(HTStream *, const char *, int); // ebx
  size_t v29; // eax
  void (*v30)(HTStream *, const char *, int); // ebx
  size_t v31; // eax
  void (*v32)(HTStream *, const char *, int); // ebx
  size_t v33; // eax
  LYImageMap *object; // [esp+1Ch] [ebp-6Ch]
  LYImageMap *v37; // [esp+20h] [ebp-68h]
  LYMapElement *v38; // [esp+28h] [ebp-60h]
  DocAddress WWWDoc; // [esp+34h] [ebp-54h] BYREF
  HTFormat old_format_out; // [esp+48h] [ebp-40h]
  HTParentAnchor *underlying; // [esp+4Ch] [ebp-3Ch] BYREF
  char *cp; // [esp+50h] [ebp-38h]
  char *address; // [esp+54h] [ebp-34h]
  HTList *cur; // [esp+58h] [ebp-30h]
  HTList *theList; // [esp+5Ch] [ebp-2Ch]
  char *MapAddress; // [esp+60h] [ebp-28h] BYREF
  char *MapTitle; // [esp+64h] [ebp-24h] BYREF
  LYImageMap *theMap; // [esp+68h] [ebp-20h]
  LYMapElement *tmp; // [esp+6Ch] [ebp-1Ch]
  char *buf; // [esp+70h] [ebp-18h] BYREF
  HTStream *target; // [esp+74h] [ebp-14h]
  HTFormat format_in; // [esp+78h] [ebp-10h]
  BOOLEAN old_reloading; // [esp+7Eh] [ebp-Ah]
  BOOLEAN old_cache_setting; // [esp+7Fh] [ebp-9h]

  format_in = HTAtom_for("text/html");
  target = 0;
  buf = 0;
  tmp = 0;
  theMap = 0;
  MapTitle = 0;
  MapAddress = 0;
  cur = 0;
  address = 0;
  cp = 0;
  old_cache_setting = LYforce_no_cache;
  old_reloading = reloading[0];
  old_format_out = HTOutputFormat;
  if ( !strncasecomp(arg, "LYNXIMGMAP:", 11) )
    address = (char *)(arg + 11);
  if ( !address || !strchr(address, 58) )
  {
    v4 = gettext("Misdirected client-side image MAP request!");
    HTAlert(v4);
    return -29999;
  }
  theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
  if ( WWWDoc.safe )
    anAnchor->safe = 1;
  if ( !theList )
  {
    if ( anAnchor->post_data && !WWWDoc.safe )
    {
      if ( underlying && underlying->document && !LYforce_no_cache )
        goto LABEL_15;
      v5 = gettext("Document from Form with POST content.  Resubmit?");
      if ( HTConfirm(v5) != 1 )
        goto LABEL_15;
    }
    LYforce_no_cache = 1;
    reloading[0] = 1;
    HTOutputFormat = HTAtom_for("www/present");
    LYMapsOnly[0] = 1;
    if ( !HTLoadAbsolute(&WWWDoc) )
      goto LABEL_17;
    LYforce_no_cache = old_cache_setting;
    reloading[0] = old_reloading;
    HTOutputFormat = old_format_out;
    LYMapsOnly[0] = 0;
    theList = get_the_list(&WWWDoc, address, anAnchor, &underlying);
  }
  if ( !theList )
  {
    v8 = gettext("No client-side image MAPs are available!");
    HTAlert(v8);
    return -29999;
  }
  cur = theList;
  do
  {
    if ( cur && (cur = cur->next) != 0 )
      object = (LYImageMap *)cur->object;
    else
      object = 0;
    theMap = object;
  }
  while ( object && strcmp(theMap->address, address) );
  if ( theMap && !HTList_count(theMap->elements) )
  {
    if ( !anAnchor->post_data )
    {
      HTSACopy(&redirecting_url, address);
      return 399;
    }
    if ( WWWDoc.safe || underlying->document && !anAnchor->document && (LYinternal_flag || LYoverride_no_cache) )
    {
      HTSACopy(&redirecting_url, address);
      redirect_post_content[0] = 1;
      return 399;
    }
  }
  if ( !theMap || !theMap->elements )
  {
    if ( anAnchor->post_data && !WWWDoc.safe )
    {
      if ( underlying && underlying->document && !LYforce_no_cache
        || (v9 = gettext("Document from Form with POST content.  Resubmit?"), HTConfirm(v9) != 1) )
      {
LABEL_15:
        v6 = gettext("Image map from POST response not available!");
        HTAlert(v6);
        return -29999;
      }
    }
    LYforce_no_cache = 1;
    reloading[0] = 1;
    HTOutputFormat = HTAtom_for("www/present");
    LYMapsOnly[0] = 1;
    if ( !HTLoadAbsolute(&WWWDoc) )
    {
LABEL_17:
      LYforce_no_cache = old_cache_setting;
      reloading[0] = old_reloading;
      HTOutputFormat = old_format_out;
      LYMapsOnly[0] = 0;
      v7 = gettext("Client-side image MAP is not accessible!");
      HTAlert(v7);
      return -29999;
    }
    LYforce_no_cache = old_cache_setting;
    reloading[0] = old_reloading;
    HTOutputFormat = old_format_out;
    LYMapsOnly[0] = 0;
    cur = get_the_list(&WWWDoc, address, anAnchor, &underlying);
    do
    {
      if ( cur && (cur = cur->next) != 0 )
        v37 = (LYImageMap *)cur->object;
      else
        v37 = 0;
      theMap = v37;
    }
    while ( v37 && strcmp(theMap->address, address) );
    if ( !theMap || !theMap->elements )
    {
      v10 = gettext("Client-side image MAP is not available!");
      HTAlert(v10);
      return -29999;
    }
  }
  anAnchor->no_cache = 1;
  target = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
  if ( target )
  {
    if ( theMap->title && *theMap->title )
    {
      HTSACopy(&MapTitle, theMap->title);
    }
    else if ( anAnchor->title && *anAnchor->title )
    {
      HTSACopy(&MapTitle, anAnchor->title);
    }
    else if ( LYRequestTitle && *LYRequestTitle && strcasecomp(LYRequestTitle, "[USEMAP]") )
    {
      HTSACopy(&MapTitle, LYRequestTitle);
    }
    else
    {
      cp = strchr(address, 35);
      if ( cp )
        HTSACopy(&MapTitle, cp + 1);
    }
    if ( MapTitle && *MapTitle )
      LYEntify(&MapTitle, 1);
    else
      HTSACopy(&MapTitle, "[USEMAP]");
    HTSprintf0(&buf, "<html>\n<head>\n");
    put_block = target->isa->put_block;
    v15 = strlen(buf);
    put_block(target, buf, v15);
    HTSprintf0(
      &buf,
      "<META %s content=\"text/html;charset=%s\">\n",
      "http-equiv=\"content-type\"",
      LYCharSet_UC[current_char_set].MIMEname);
    v16 = target->isa->put_block;
    v17 = strlen(buf);
    v16(target, buf, v17);
    HTSprintf0(&buf, "<title>%s</title>\n", MapTitle);
    v18 = target->isa->put_block;
    v19 = strlen(buf);
    v18(target, buf, v19);
    HTSprintf0(&buf, "</head>\n<body>\n");
    v20 = target->isa->put_block;
    v21 = strlen(buf);
    v20(target, buf, v21);
    HTSprintf0(&buf, "<h1><em>%s</em></h1>\n", MapTitle);
    v22 = target->isa->put_block;
    v23 = strlen(buf);
    v22(target, buf, v23);
    HTSACopy(&MapAddress, address);
    LYEntify(&MapAddress, 0);
    HTSprintf0(&buf, "<h2><em>MAP:</em>&nbsp;%s</h2>\n", MapAddress);
    v24 = target->isa->put_block;
    v25 = strlen(buf);
    v24(target, buf, v25);
    if ( keypad_mode )
      HTSprintf0(&buf, "<%s compact>\n", "ul");
    else
      HTSprintf0(&buf, "<%s compact>\n", "ol");
    v26 = target->isa->put_block;
    v27 = strlen(buf);
    v26(target, buf, v27);
    cur = theMap->elements;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        v38 = (LYMapElement *)cur->object;
      else
        v38 = 0;
      tmp = v38;
      if ( !v38 )
        break;
      HTSACopy(&MapAddress, tmp->address);
      LYEntify(&MapAddress, 0);
      target->isa->put_block(target, "<li><a href=\"", 13);
      v28 = target->isa->put_block;
      v29 = strlen(MapAddress);
      v28(target, MapAddress, v29);
      target->isa->put_block(target, "\"", 1);
      target->isa->put_block(target, "\n>", 2);
      LYformTitle(&MapTitle, tmp->title);
      LYEntify(&MapTitle, 1);
      v30 = target->isa->put_block;
      v31 = strlen(MapTitle);
      v30(target, MapTitle, v31);
      target->isa->put_block(target, "</a>\n", 5);
    }
    if ( keypad_mode )
      HTSprintf0(&buf, "</%s>\n</body>\n</html>\n", "ul");
    else
      HTSprintf0(&buf, "</%s>\n</body>\n</html>\n", "ol");
    v32 = target->isa->put_block;
    v33 = strlen(buf);
    v32(target, buf, v33);
    target->isa->_free(target);
    if ( MapAddress )
    {
      free(MapAddress);
      MapAddress = 0;
    }
    if ( MapTitle )
    {
      free(MapTitle);
      MapTitle = 0;
    }
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    return 200;
  }
  else
  {
    name = format_out->name;
    v12 = format_in->name;
    v13 = gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buf, v13, v12, name);
    HTAlert(buf);
    if ( buf )
    {
      free(buf);
      buf = 0;
    }
    return -29999;
  }
}

//----- (080E5004) --------------------------------------------------------
void __cdecl LYPrintImgMaps(FILE *fp)
{
  const char *v1; // [esp+1Ch] [ebp-2Ch]
  const char **v2; // [esp+20h] [ebp-28h]
  const char **object; // [esp+24h] [ebp-24h]
  int count; // [esp+2Ch] [ebp-1Ch]
  HTList *inner; // [esp+38h] [ebp-10h]
  HTList *outer; // [esp+3Ch] [ebp-Ch]
  int only_len; // [esp+40h] [ebp-8h]
  char *only; // [esp+44h] [ebp-4h]

  only = HTLoadedDocumentURL();
  only_len = strlen(only);
  outer = LynxMaps;
  if ( HTList_count(LynxMaps) > 0 )
  {
    while ( 1 )
    {
      if ( outer && (outer = outer->next) != 0 )
        object = (const char **)outer->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( !only_len || !strncmp(only, *object, only_len) && (!(*object)[only_len] || (*object)[only_len] == 35) )
      {
        if ( object[1] && *object[1] )
          v1 = object[1];
        else
          v1 = "[USEMAP]";
        fprintf(fp, "\n%s\n", v1);
        fprintf(fp, "%s\n", *object);
        inner = (HTList *)object[2];
        count = 0;
        while ( 1 )
        {
          if ( inner && (inner = inner->next) != 0 )
            v2 = (const char **)inner->object;
          else
            v2 = 0;
          if ( !v2 )
            break;
          fprintf(fp, "%4d. %s", ++count, *v2);
          fputc(10, fp);
        }
      }
    }
  }
}

//----- (080E51A8) --------------------------------------------------------
void __cdecl MemAllocCopy(char **dest, const char *start, const char *end)
{
  char *temp; // [esp+24h] [ebp-4h]

  if ( start && end && end > start )
  {
    temp = (char *)calloc(end - start + 1, 1u);
    if ( !temp )
      outofmem("./LYCookie.c", "MemAllocCopy");
    LYstrncpy(temp, start, end - start);
    HTSACopy(dest, temp);
    free(temp);
  }
  else
  {
    HTSACopy(dest, &byte_816DF60);
  }
}
// 80E524E: conditional instruction was optimized away because %temp.4!=0

//----- (080E5264) --------------------------------------------------------
cookie *newCookie()
{
  cookie *p; // [esp+24h] [ebp-4h]

  p = (cookie *)calloc(1u, 0x38u);
  if ( !p )
    outofmem("./LYCookie.c", "newCookie");
  HTSprintf0(&p->lynxID, "%p", p);
  p->port = 80;
  return p;
}

//----- (080E52C4) --------------------------------------------------------
void __cdecl freeCookie(cookie *co)
{
  if ( co )
  {
    if ( co->lynxID )
    {
      free(co->lynxID);
      co->lynxID = 0;
    }
    if ( co->name )
    {
      free(co->name);
      co->name = 0;
    }
    if ( co->value )
    {
      free(co->value);
      co->value = 0;
    }
    if ( co->comment )
    {
      free(co->comment);
      co->comment = 0;
    }
    if ( co->commentURL )
    {
      free(co->commentURL);
      co->commentURL = 0;
    }
    if ( co->domain )
    {
      free(co->domain);
      co->domain = 0;
    }
    if ( co->path )
    {
      free(co->path);
      co->path = 0;
    }
    if ( co->PortList )
    {
      free(co->PortList);
      co->PortList = 0;
    }
    free(co);
  }
}
// 80E53E5: conditional instruction was optimized away because %co.4!=0

//----- (080E53FB) --------------------------------------------------------
BOOLEAN __cdecl host_matches(const char *A, const char *B)
{
  size_t v2; // ebx
  BOOLEAN v4; // [esp+13h] [ebp-15h]
  int diff; // [esp+20h] [ebp-8h]

  if ( *B == 46 || strcasecomp(A, B) )
  {
    v4 = 0;
    if ( *B == 46 )
    {
      if ( B[1] )
      {
        if ( B[1] != 46 && *A != 46 )
        {
          v2 = strlen(A);
          diff = v2 - strlen(B);
          if ( diff > 0 && !strcasecomp(&A[diff], B) )
            return 1;
        }
      }
    }
  }
  else
  {
    return 1;
  }
  return v4;
}

//----- (080E54AC) --------------------------------------------------------
BOOLEAN __cdecl port_matches(int port, const char *list)
{
  const char *number; // [esp+14h] [ebp-4h]

  number = list;
  if ( !list || ((*__ctype_b_loc())[*(unsigned __int8 *)list] & 0x800) == 0 )
    return 0;
  while ( *number )
  {
    if ( atoi(number) == port )
      return 1;
    while ( ((*__ctype_b_loc())[*(unsigned __int8 *)number] & 0x800) != 0 )
      ++number;
    while ( *number && ((*__ctype_b_loc())[*(unsigned __int8 *)number] & 0x800) == 0 )
      ++number;
  }
  return 0;
}

//----- (080E5571) --------------------------------------------------------
int __cdecl ignore_trailing_slash(const char *a)
{
  signed int len; // [esp+14h] [ebp-4h]

  for ( len = strlen(a); len > 1 && a[len - 1] == 47; --len )
    ;
  return len;
}

//----- (080E55A6) --------------------------------------------------------
BOOLEAN __cdecl is_prefix(const char *a, const char *b)
{
  int len_b; // [esp+20h] [ebp-8h]
  signed int len_a; // [esp+24h] [ebp-4h]

  len_a = ignore_trailing_slash(a);
  len_b = ignore_trailing_slash(b);
  if ( len_a > len_b )
    return 0;
  if ( !strncmp(a, b, len_a) )
    return len_a >= len_b || len_a <= 1 && *a == 47 || !b[len_a] || b[len_a] == 47;
  return 0;
}

//----- (080E563B) --------------------------------------------------------
domain_entry *__cdecl find_domain_entry(const char *name)
{
  invcheck_behaviour_t invcheck_bv; // esi
  behaviour_t bv; // edi
  const char *domain; // ebx
  FILE *v4; // eax
  FILE *v5; // eax
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  domain_entry *de; // [esp+24h] [ebp-14h]
  HTList *hl; // [esp+28h] [ebp-10h]

  de = 0;
  if ( name && *name )
  {
    for ( hl = domain_list; hl; hl = hl->next )
    {
      de = (domain_entry *)hl->object;
      if ( hl->object && de->domain )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
        {
          invcheck_bv = de->invcheck_bv;
          bv = de->bv;
          domain = de->domain;
          v4 = TraceFP();
          fprintf(v4, "...test_domain_entry(%s) bv:%u, invcheck_bv:%u\n", domain, bv, invcheck_bv);
        }
        if ( !strcasecomp(name, de->domain) )
          break;
      }
      de = 0;
    }
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    if ( de )
      v7 = de->invcheck_bv;
    else
      v7 = -1;
    if ( de )
      v8 = de->bv;
    else
      v8 = -1;
    v5 = TraceFP();
    fprintf(v5, "find_domain_entry(%s) bv:%d, invcheck_bv:%d\n", name, v8, v7);
  }
  return de;
}

//----- (080E5782) --------------------------------------------------------
void __cdecl store_cookie(cookie *co, const char *hostname, const char *path)
{
  char *v3; // ebx
  FILE *v4; // edx
  FILE *v5; // eax
  char *domain; // ebx
  FILE *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  char *v10; // ebx
  FILE *v11; // edx
  size_t v12; // ebx
  char *v13; // ebx
  FILE *v14; // edx
  char *v15; // ebx
  char *v16; // eax
  char *v17; // ebx
  FILE *v18; // edx
  char *v19; // ebx
  char *v20; // eax
  char *v21; // ebx
  FILE *v22; // edx
  FILE *v23; // eax
  FILE *v24; // eax
  FILE *v25; // eax
  invcheck_behaviour_t v26; // [esp+1Ch] [ebp-3Ch]
  invcheck_behaviour_t v27; // [esp+20h] [ebp-38h]
  char *msg; // [esp+24h] [ebp-34h] BYREF
  invcheck_behaviour_t invcheck_bv_0; // [esp+28h] [ebp-30h]
  invcheck_behaviour_t invcheck_bv; // [esp+2Ch] [ebp-2Ch]
  int invprompt_reasons; // [esp+30h] [ebp-28h]
  domain_entry *de; // [esp+34h] [ebp-24h]
  const char *ptr; // [esp+38h] [ebp-20h]
  int pos; // [esp+3Ch] [ebp-1Ch]
  time_t now; // [esp+40h] [ebp-18h]
  cookie *c2; // [esp+44h] [ebp-14h]
  HTList *next; // [esp+48h] [ebp-10h]
  HTList *hl; // [esp+4Ch] [ebp-Ch]
  BOOLEAN Replacement; // [esp+53h] [ebp-5h]

  now = time(0);
  de = 0;
  Replacement = 0;
  invprompt_reasons = 0;
  if ( !co )
    return;
  if ( !domain_list )
  {
    domain_list = HTList_new();
    total_cookies = 0;
  }
  cookie_list = 0;
  de = find_domain_entry(co->domain);
  if ( de )
    cookie_list = de->cookie_list;
  if ( !is_prefix(co->path, path) )
  {
    if ( de )
      v26 = de->invcheck_bv;
    else
      v26 = INVCHECK_QUERY;
    invcheck_bv = v26;
    if ( v26 == INVCHECK_STRICT )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        v3 = co->path;
        v4 = TraceFP();
        fprintf(v4, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n", v3, path);
      }
      goto LABEL_50;
    }
    if ( v26 == INVCHECK_QUERY )
      invprompt_reasons |= 1u;
  }
  if ( strcasecomp(co->domain, hostname) )
  {
    if ( !strchr(hostname, 46) )
    {
      if ( WWW_TraceFlag[0] )
      {
        if ( (WWW_TraceMask & 0x20) != 0 )
        {
          v5 = TraceFP();
          fprintf(v5, "store_cookie: Rejecting because '%s' has no dot.\n", hostname);
        }
      }
LABEL_50:
      freeCookie(co);
      return;
    }
    if ( *co->domain != 46 || !co->domain[1] )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        domain = co->domain;
        v7 = TraceFP();
        fprintf(v7, "store_cookie: Rejecting domain '%s'.\n", domain);
      }
      goto LABEL_50;
    }
    ptr = strchr((const char *)co->domain + 1, 46);
    if ( !ptr || !ptr[1] )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        v8 = co->domain;
        v9 = TraceFP();
        fprintf(v9, "store_cookie: Rejecting domain '%s'.\n", v8);
      }
      goto LABEL_50;
    }
    if ( !host_matches(hostname, co->domain) )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        v10 = co->domain;
        v11 = TraceFP();
        fprintf(v11, "store_cookie: Rejecting domain '%s' for host '%s'.\n", v10, hostname);
      }
      goto LABEL_50;
    }
    v12 = strlen(hostname);
    ptr = &hostname[v12 - strlen(co->domain)];
    if ( strchr(hostname, 46) < ptr )
    {
      if ( de )
        v27 = de->invcheck_bv;
      else
        v27 = INVCHECK_QUERY;
      invcheck_bv_0 = v27;
      if ( v27 == INVCHECK_STRICT )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
        {
          v13 = co->path;
          v14 = TraceFP();
          fprintf(v14, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n", v13, path);
        }
        goto LABEL_50;
      }
      if ( v27 == INVCHECK_QUERY )
        invprompt_reasons |= 2u;
    }
  }
  if ( invprompt_reasons )
  {
    msg = 0;
    if ( (invprompt_reasons & 2) != 0 )
    {
      v15 = co->domain;
      v16 = gettext("Accept invalid cookie domain=%s for '%s'?");
      HTSprintf0(&msg, v16, v15, hostname);
      if ( !HTForcedPrompt(cookie_noprompt, msg, 0) )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
        {
          v17 = co->domain;
          v18 = TraceFP();
          fprintf(v18, "store_cookie: Rejecting domain '%s' for host '%s'.\n", v17, hostname);
        }
        freeCookie(co);
        if ( msg )
        {
LABEL_58:
          free(msg);
          msg = 0;
          return;
        }
        return;
      }
    }
    if ( (invprompt_reasons & 1) != 0 )
    {
      v19 = co->path;
      v20 = gettext("Accept invalid cookie path=%s as a prefix of '%s'?");
      HTSprintf0(&msg, v20, v19, path);
      if ( !HTForcedPrompt(cookie_noprompt, msg, 0) )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
        {
          v21 = co->path;
          v22 = TraceFP();
          fprintf(v22, "store_cookie: Rejecting because '%s' is not a prefix of '%s'.\n", v21, path);
        }
        freeCookie(co);
        if ( msg )
          goto LABEL_58;
        return;
      }
    }
    if ( msg )
    {
      free(msg);
      msg = 0;
    }
  }
  if ( !de )
  {
    de = (domain_entry *)calloc(1u, 0x10u);
    if ( !de )
      outofmem("./LYCookie.c", "store_cookie");
    de->bv = QUERY_USER;
    de->invcheck_bv = INVCHECK_QUERY;
    de->cookie_list = HTList_new();
    cookie_list = de->cookie_list;
    HTSACopy(&de->domain, co->domain);
    HTList_appendObject(domain_list, de);
  }
  hl = cookie_list;
  pos = 0;
  while ( hl )
  {
    c2 = (cookie *)hl->object;
    next = hl->next;
    if ( c2 && (c2->flags & 4) != 0 && c2->expires <= now )
    {
      HTList_removeObject(cookie_list, c2);
      freeCookie(c2);
      c2 = 0;
      --total_cookies;
    }
    else if ( c2 && !strcasecomp(co->domain, c2->domain) && !strcmp(co->path, c2->path) && !strcmp(co->name, c2->name) )
    {
      HTList_removeObject(cookie_list, c2);
      freeCookie(c2);
      c2 = 0;
      --total_cookies;
      Replacement = 1;
    }
    else if ( c2 && c2->pathlen >= co->pathlen )
    {
      ++pos;
    }
    hl = next;
  }
  if ( (co->flags & 4) == 0 || co->expires > now )
  {
    if ( HTList_count(cookie_list) <= max_cookies_domain )
    {
      if ( total_cookies <= max_cookies_global )
      {
        if ( co->value )
        {
          if ( Replacement == 1 && de && de->bv != REJECT_ALWAYS
            || (co->flags & 0x20) != 0
            || HTConfirmCookie(de, hostname, co->name, co->value) )
          {
            HTList_insertObjectAt(cookie_list, co, pos);
            ++total_cookies;
            return;
          }
        }
        else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
        {
          v25 = TraceFP();
          fprintf(v25, "store_cookie: Value is NULL! Not storing cookie.\n");
        }
      }
      else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        v24 = TraceFP();
        fprintf(v24, "store_cookie: Total cookie limit exceeded!  Rejecting cookie.\n");
      }
    }
    else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
    {
      v23 = TraceFP();
      fprintf(v23, "store_cookie: Domain's cookie limit exceeded!  Rejecting cookie.\n");
    }
  }
  freeCookie(co);
}

//----- (080E60B0) --------------------------------------------------------
char *__cdecl scan_cookie_sublist(char *hostname, char *path, int port, HTList *sublist, char *header, BOOLEAN secure)
{
  FILE *v6; // eax
  FILE *v7; // eax
  size_t v8; // eax
  size_t v9; // ebx
  size_t v10; // eax
  size_t v11; // eax
  size_t v12; // eax
  size_t v13; // eax
  char *value; // [esp+24h] [ebp-54h]
  char *name; // [esp+28h] [ebp-50h]
  const char *v17; // [esp+2Ch] [ebp-4Ch]
  _BOOL4 v18; // [esp+30h] [ebp-48h]
  char *v19; // [esp+34h] [ebp-44h]
  int v20; // [esp+38h] [ebp-40h]
  char *domain; // [esp+3Ch] [ebp-3Ch]
  char *headera; // [esp+44h] [ebp-34h] BYREF
  HTList *sublista; // [esp+48h] [ebp-30h]
  char *patha; // [esp+4Ch] [ebp-2Ch]
  char *hostnamea; // [esp+50h] [ebp-28h]
  int len; // [esp+54h] [ebp-24h]
  time_t now; // [esp+58h] [ebp-20h]
  cookie *co; // [esp+5Ch] [ebp-1Ch]
  HTList *next; // [esp+60h] [ebp-18h]
  HTList *hl; // [esp+64h] [ebp-14h]
  char crlftab[8]; // [esp+68h] [ebp-10h] BYREF
  unsigned int v32; // [esp+70h] [ebp-8h]

  hostnamea = hostname;
  patha = path;
  sublista = sublist;
  headera = header;
  v32 = __readgsdword(0x14u);
  hl = sublist;
  next = 0;
  now = time(0);
  len = 0;
  sprintf(crlftab, "%c%c%c", 13, 10, 9);
  while ( hl )
  {
    co = (cookie *)hl->object;
    next = hl->next;
    if ( co && LYstrstr(hostnamea, co->domain) )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        if ( co->value )
          value = co->value;
        else
          value = "(no value)";
        if ( co->name )
          name = co->name;
        else
          name = "(no name)";
        v6 = TraceFP();
        fprintf(v6, "Checking cookie %p %s=%s\n", hl, name, value);
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        if ( (co->flags & 1) != 0 )
          v17 = " secure";
        else
          v17 = &byte_816DF60;
        v18 = co->pathlen > 0 && !is_prefix(co->path, patha);
        v19 = co->path;
        v20 = host_matches(hostnamea, co->domain);
        if ( co->domain )
          domain = co->domain;
        else
          domain = "(no domain)";
        v7 = TraceFP();
        fprintf(v7, "\t%s %s %d %s %s %d%s\n", hostnamea, domain, v20, patha, v19, v18, v17);
      }
    }
    if ( co && (co->flags & 4) != 0 && co->expires <= now )
    {
      HTList_removeObject(sublista, co);
      freeCookie(co);
      co = 0;
      --total_cookies;
    }
    if ( co && host_matches(hostnamea, co->domain) && (!co->pathlen || is_prefix(co->path, patha)) )
    {
      if ( (co->flags & 1) == 0 || secure )
      {
        if ( !co->PortList || port_matches(port, co->PortList) )
        {
          if ( headera )
          {
            HTSACat(&headera, "; ");
          }
          else if ( co->version > 0 )
          {
            HTSprintf0(&headera, "$Version=\"%d\"; ", co->version);
            v8 = strlen(headera);
            len += v8;
          }
          HTSACat(&headera, co->name);
          HTSACat(&headera, "=");
          if ( co->quoted )
          {
            HTSACat(&headera, "\"");
            ++len;
          }
          HTSACat(&headera, co->value);
          if ( co->quoted )
          {
            HTSACat(&headera, "\"");
            ++len;
          }
          v9 = strlen(co->name);
          v10 = strlen(co->value);
          len += v9 + v10 + 1;
          if ( co->version > 0 )
          {
            if ( co->path && (co->flags & 0x10) != 0 )
            {
              HTSACat(&headera, "; $Path=\"");
              HTSACat(&headera, co->path);
              HTSACat(&headera, "\"");
              v11 = strlen(co->path);
              len += v11 + 10;
            }
            if ( co->PortList && ((*__ctype_b_loc())[*(unsigned __int8 *)co->PortList] & 0x800) != 0 )
            {
              HTSACat(&headera, "; $Port=\"");
              HTSACat(&headera, co->PortList);
              HTSACat(&headera, "\"");
              v12 = strlen(co->PortList);
              len += v12 + 10;
            }
            if ( co->domain && (co->flags & 8) != 0 )
            {
              HTSACat(&headera, "; $Domain=\"");
              HTSACat(&headera, co->domain);
              HTSACat(&headera, "\"");
              v13 = strlen(co->domain);
              len += v13 + 12;
            }
          }
          goto LABEL_58;
        }
        hl = next;
      }
      else
      {
        hl = next;
      }
    }
    else
    {
LABEL_58:
      hl = next;
    }
  }
  return headera;
}

//----- (080E666B) --------------------------------------------------------
char *__cdecl alloc_attr_value(const char *value_start, const char *value_end)
{
  int value_len; // [esp+20h] [ebp-8h]
  char *value; // [esp+24h] [ebp-4h]

  value = 0;
  if ( value_start && value_end >= value_start )
  {
    value_len = value_end - value_start;
    if ( value_end - value_start > max_cookies_buffer )
      value_len = max_cookies_buffer;
    value = (char *)calloc(value_len + 1, 1u);
    if ( !value )
      outofmem("./LYCookie.c", "LYProcessSetCookies");
    LYstrncpy(value, value_start, value_len);
  }
  return value;
}

//----- (080E66F8) --------------------------------------------------------
unsigned int __cdecl parse_attribute(
        unsigned int flags,
        cookie *cur_cookie,
        int *cookie_len,
        const char *attr_start,
        int attr_len,
        char *value,
        const char *address,
        char *hostname,
        int port)
{
  int v9; // ebx
  int v10; // ebx
  char *commentURL; // ebx
  FILE *v12; // eax
  int v13; // ebx
  FILE *v14; // eax
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // ebx
  char *v20; // ebx
  time_t v21; // esi
  FILE *v22; // eax
  char *v23; // ebx
  time_t expires; // esi
  FILE *v25; // eax
  int temp_0; // [esp+18h] [ebp-20h]
  int temp; // [esp+1Ch] [ebp-1Ch]
  char *cp; // [esp+20h] [ebp-18h]
  char *ptr; // [esp+24h] [ebp-14h]
  char *ptra; // [esp+24h] [ebp-14h]
  int url_type; // [esp+28h] [ebp-10h]
  BOOLEAN known_attr; // [esp+2Fh] [ebp-9h]
  unsigned int flagsa; // [esp+40h] [ebp+8h]

  known_attr = 0;
  flagsa = flags & 0xFFFFFFFD;
  if ( attr_len != 6 || strncasecomp(attr_start, "secure", 6) )
  {
    if ( attr_len != 7 || strncasecomp(attr_start, "discard", 7) )
    {
      if ( attr_len != 7 || strncasecomp(attr_start, "comment", 7) )
      {
        if ( attr_len != 10 || strncasecomp(attr_start, "commentURL", 10) )
        {
          if ( attr_len != 6 || strncasecomp(attr_start, "domain", 6) )
          {
            if ( attr_len != 4 || strncasecomp(attr_start, "path", 4) )
            {
              if ( attr_len != 4 || strncasecomp(attr_start, "port", 4) )
              {
                if ( attr_len != 7 || strncasecomp(attr_start, "version", 7) )
                {
                  if ( attr_len != 7 || strncasecomp(attr_start, "max-age", 7) )
                  {
                    if ( attr_len == 7 && !strncasecomp(attr_start, "expires", 7) )
                    {
                      known_attr = 1;
                      if ( cur_cookie )
                      {
                        if ( (flagsa & 4) == 0 && (cur_cookie->flags & 4) == 0 )
                        {
                          if ( value )
                          {
                            cur_cookie->flags |= 4u;
                            cur_cookie->expires = LYmktime(value, 0);
                            if ( cur_cookie->expires > 0 && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
                            {
                              v23 = ctime(&cur_cookie->expires);
                              expires = cur_cookie->expires;
                              v25 = TraceFP();
                              fprintf(v25, "LYSetCookie: expires %d, %s", expires, v23);
                            }
                          }
                        }
                      }
                    }
                  }
                  else
                  {
                    known_attr = 1;
                    if ( cur_cookie && value && (flagsa & 4) == 0 )
                    {
                      temp_0 = strtol(value, 0, 10);
                      cur_cookie->flags |= 4u;
                      if ( *__errno_location() == -34 )
                      {
                        cur_cookie->expires = 0;
                      }
                      else
                      {
                        cur_cookie->expires = temp_0 + time(0);
                        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
                        {
                          v20 = ctime(&cur_cookie->expires);
                          v21 = cur_cookie->expires;
                          v22 = TraceFP();
                          fprintf(v22, "LYSetCookie: expires %d, %s", v21, v20);
                        }
                      }
                      flagsa |= 4u;
                    }
                  }
                }
                else
                {
                  known_attr = 1;
                  if ( cur_cookie )
                  {
                    if ( value )
                    {
                      if ( cur_cookie->version <= 0 )
                      {
                        temp = strtol(value, 0, 10);
                        if ( *__errno_location() != -34 )
                          cur_cookie->version = temp;
                      }
                    }
                  }
                }
              }
              else if ( cur_cookie && value && !cur_cookie->PortList )
              {
                for ( cp = value;
                      *cp && (((*__ctype_b_loc())[(unsigned __int8)*cp] & 0x800) != 0 || *cp == 44 || *cp == 32);
                      ++cp )
                {
                  ;
                }
                if ( *cp )
                {
                  known_attr = 0;
                }
                else
                {
                  if ( port_matches(port, value) )
                  {
                    HTSACopy(&cur_cookie->PortList, value);
                    v18 = *cookie_len;
                    *cookie_len = v18 + strlen(cur_cookie->PortList);
                  }
                  else
                  {
                    flagsa |= 1u;
                  }
                  known_attr = 1;
                }
              }
              else if ( cur_cookie )
              {
                if ( !cur_cookie->PortList )
                {
                  HTSprintf0(&cur_cookie->PortList, "%d", port);
                  v19 = *cookie_len;
                  *cookie_len = v19 + strlen(cur_cookie->PortList);
                }
                known_attr = 1;
              }
            }
            else
            {
              known_attr = 1;
              if ( cur_cookie && value && (cur_cookie->flags & 0x10) == 0 )
              {
                v16 = *cookie_len;
                *cookie_len = v16 - strlen(cur_cookie->path);
                HTSACopy(&cur_cookie->path, value);
                v17 = *cookie_len;
                cur_cookie->pathlen = strlen(cur_cookie->path);
                *cookie_len = v17 + cur_cookie->pathlen;
                cur_cookie->flags |= 0x10u;
              }
            }
          }
          else
          {
            known_attr = 1;
            if ( cur_cookie && value && (cur_cookie->flags & 8) == 0 )
            {
              v13 = *cookie_len;
              *cookie_len = v13 - strlen(cur_cookie->domain);
              if ( *value == 46 )
                goto LABEL_53;
              if ( !*value )
                goto LABEL_53;
              if ( !value[1] )
                goto LABEL_53;
              if ( !strcasecomp(value, hostname) )
                goto LABEL_53;
              ptr = strchr(value, 46);
              if ( !ptr || !ptr[1] )
                goto LABEL_53;
              for ( ptra = value; *ptra == 46 || ((*__ctype_b_loc())[(unsigned __int8)*ptra] & 0x800) != 0; ++ptra )
                ;
              if ( *ptra )
              {
                if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
                {
                  v14 = TraceFP();
                  fprintf(v14, "LYProcessSetCookies: Adding lead dot for domain value '%s'\n", value);
                }
                HTSACopy(&cur_cookie->domain, ".");
                HTSACat(&cur_cookie->domain, value);
              }
              else
              {
LABEL_53:
                HTSACopy(&cur_cookie->domain, value);
              }
              v15 = *cookie_len;
              *cookie_len = v15 + strlen(cur_cookie->domain);
              cur_cookie->flags |= 8u;
            }
          }
        }
        else
        {
          known_attr = 1;
          if ( cur_cookie && value && !cur_cookie->commentURL )
          {
            cur_cookie->commentURL = HTParse(value, address, 31);
            url_type = is_url(cur_cookie->commentURL);
            if ( url_type && (url_type == 2 || url_type == 20) )
            {
              v10 = *cookie_len;
              *cookie_len = v10 + strlen(cur_cookie->commentURL);
            }
            else
            {
              if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
              {
                commentURL = cur_cookie->commentURL;
                v12 = TraceFP();
                fprintf(v12, "LYProcessSetCookies: Rejecting commentURL value '%s'\n", commentURL);
              }
              if ( cur_cookie->commentURL )
              {
                free(cur_cookie->commentURL);
                cur_cookie->commentURL = 0;
              }
            }
          }
        }
      }
      else
      {
        known_attr = 1;
        if ( cur_cookie && value && !cur_cookie->comment )
        {
          HTSACopy(&cur_cookie->comment, value);
          v9 = *cookie_len;
          *cookie_len = v9 + strlen(cur_cookie->comment);
        }
      }
    }
    else if ( value )
    {
      known_attr = 0;
    }
    else
    {
      known_attr = 1;
      if ( cur_cookie )
        cur_cookie->flags |= 2u;
    }
  }
  else if ( value )
  {
    known_attr = 0;
  }
  else
  {
    known_attr = 1;
    if ( cur_cookie )
      cur_cookie->flags |= 1u;
  }
  if ( known_attr )
    flagsa |= 2u;
  return flagsa;
}

//----- (080E7022) --------------------------------------------------------
void __cdecl LYProcessSetCookies(
        const char *SetCookie,
        const char *SetCookie2,
        const char *address,
        char *hostname,
        char *path,
        int port)
{
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  size_t v9; // eax
  size_t v10; // eax
  size_t v11; // eax
  int v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  FILE *v18; // eax
  FILE *v19; // eax
  size_t v20; // eax
  size_t v21; // eax
  size_t v22; // eax
  int v23; // eax
  FILE *v24; // eax
  FILE *v25; // eax
  FILE *v26; // eax
  char *v27; // ebx
  time_t expires; // esi
  FILE *v29; // eax
  FILE *v30; // eax
  const char *v31; // [esp+30h] [ebp-C8h]
  bool v32; // [esp+34h] [ebp-C4h]
  char *v33; // [esp+38h] [ebp-C0h]
  char *name; // [esp+3Ch] [ebp-BCh]
  char *format; // [esp+40h] [ebp-B8h]
  char *v36; // [esp+44h] [ebp-B4h]
  char *v37; // [esp+48h] [ebp-B0h]
  const char *v38; // [esp+4Ch] [ebp-ACh]
  const char *v39; // [esp+50h] [ebp-A8h]
  const char *v40; // [esp+54h] [ebp-A4h]
  char *v41; // [esp+58h] [ebp-A0h]
  char *v42; // [esp+5Ch] [ebp-9Ch]
  const char *v43; // [esp+60h] [ebp-98h]
  bool v44; // [esp+64h] [ebp-94h]
  char *v45; // [esp+68h] [ebp-90h]
  char *v46; // [esp+6Ch] [ebp-8Ch]
  char *v47; // [esp+70h] [ebp-88h]
  char *v48; // [esp+74h] [ebp-84h]
  const char *v49; // [esp+78h] [ebp-80h]
  const char *v50; // [esp+7Ch] [ebp-7Ch]
  const char *v51; // [esp+80h] [ebp-78h]
  char *v52; // [esp+84h] [ebp-74h]
  char *v53; // [esp+88h] [ebp-70h]
  cookie *object; // [esp+8Ch] [ebp-6Ch]
  char *value_0; // [esp+9Ch] [ebp-5Ch]
  const char *cp1_0; // [esp+A0h] [ebp-58h]
  const char *cp1_0a; // [esp+A0h] [ebp-58h]
  const char *cp_0; // [esp+A4h] [ebp-54h]
  int spaces_0; // [esp+A8h] [ebp-50h]
  char *value; // [esp+ACh] [ebp-4Ch]
  const char *cp1; // [esp+B0h] [ebp-48h]
  const char *cp1a; // [esp+B0h] [ebp-48h]
  const char *cp; // [esp+B4h] [ebp-44h]
  int spaces; // [esp+B8h] [ebp-40h]
  unsigned int parse_flags; // [esp+BCh] [ebp-3Ch]
  int NumCookies; // [esp+C0h] [ebp-38h]
  int NumCookiesa; // [esp+C0h] [ebp-38h]
  int cookie_len; // [esp+C4h] [ebp-34h] BYREF
  cookie *co; // [esp+C8h] [ebp-30h]
  cookie *cur_cookie; // [esp+CCh] [ebp-2Ch]
  HTList *cl_0; // [esp+D0h] [ebp-28h]
  HTList *CombinedCookies; // [esp+D4h] [ebp-24h]
  const char *value_end; // [esp+D8h] [ebp-20h]
  const char *value_start; // [esp+DCh] [ebp-1Ch]
  const char *attr_end; // [esp+E0h] [ebp-18h]
  const char *attr_start; // [esp+E4h] [ebp-14h]
  const char *p; // [esp+E8h] [ebp-10h]
  BOOLEAN escaped_0; // [esp+EDh] [ebp-Bh]
  BOOLEAN escaped; // [esp+EEh] [ebp-Ah]
  BOOLEAN Quoted; // [esp+EFh] [ebp-9h]

  CombinedCookies = 0;
  cl_0 = 0;
  cur_cookie = 0;
  co = 0;
  cookie_len = 0;
  NumCookies = 0;
  Quoted = 0;
  parse_flags = 0;
  if ( (!SetCookie || !*SetCookie) && (!SetCookie2 || !*SetCookie2) )
    return;
  CombinedCookies = HTList_new();
  if ( SetCookie2 )
    v31 = SetCookie2;
  else
    v31 = &byte_816DF60;
  p = v31;
  if ( SetCookie && *p && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    v6 = TraceFP();
    fprintf(v6, "LYProcessSetCookies: Using Set-Cookie2 header.\n");
  }
  while ( NumCookies <= max_cookies_domain && *p )
  {
    value_end = 0;
    value_start = 0;
    attr_end = 0;
    attr_start = 0;
    p = LYSkipCBlanks(p);
    attr_start = p;
    while ( *p && ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x2000) == 0 && *p != 61 && *p != 59 && *p != 44 )
      ++p;
    attr_end = p;
    p = LYSkipCBlanks(p);
    if ( *p == 61 || !strncasecomp(attr_start, "Expires", 7) )
    {
      if ( *p == 61 )
        ++p;
      p = LYSkipCBlanks(p);
      if ( attr_end - attr_start != 7 || strncasecomp(attr_start, "Expires", 7) )
      {
        if ( attr_end - attr_start == 4
          && !strncasecomp(attr_start, "port", 4)
          && ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x800) != 0 )
        {
          value_start = p;
          while ( 1 )
          {
            while ( ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x800) != 0 )
              ++p;
            value_end = p;
            p = LYSkipCBlanks(p);
            if ( !*p || *p == 59 )
              break;
            if ( *p != 44 )
              goto LABEL_69;
            cp = LYSkipCBlanks(p + 1);
            if ( !*cp )
              goto LABEL_69;
            if ( ((*__ctype_b_loc())[*(unsigned __int8 *)cp] & 0x800) == 0 )
              goto LABEL_69;
            for ( cp1 = cp; ((*__ctype_b_loc())[*(unsigned __int8 *)cp1] & 0x800) != 0; ++cp1 )
              ;
            cp1a = LYSkipCBlanks(cp1);
            if ( *cp1a )
            {
              if ( *cp1a != 44 && *cp1a != 59 )
              {
LABEL_69:
                while ( *p && *p != 59 && *p != 44 )
                  ++p;
                value_end = p;
                if ( p > value_start && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
                {
                  --value_end;
                  while ( value_start + 1 < value_end
                       && ((*__ctype_b_loc())[*(unsigned __int8 *)value_end] & 0x2000) != 0
                       && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
                    --value_end;
                }
                break;
              }
            }
            p = cp;
          }
        }
        else if ( *p == 34 )
        {
          escaped = 0;
          value_start = ++p;
          while ( *p && (*p != 34 || escaped) )
          {
            v32 = !escaped && *p == 92;
            escaped = v32;
            ++p;
          }
          if ( p == value_start || *p != 34 || escaped )
          {
            --value_start;
            value_end = p;
            if ( *p )
              ++p;
            Quoted = 0;
          }
          else
          {
            value_end = p++;
            Quoted = 1;
          }
        }
        else
        {
          value_start = p;
          while ( *p && *p != 59 && *p != 44 )
            ++p;
          value_end = p;
          if ( p > value_start && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
          {
            --value_end;
            while ( value_start + 1 < value_end
                 && ((*__ctype_b_loc())[*(unsigned __int8 *)value_end] & 0x2000) != 0
                 && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
              --value_end;
          }
        }
      }
      else
      {
        value_start = p;
        if ( ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x800) != 0 )
        {
          spaces = 5;
        }
        else
        {
          while ( *p && ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x400) != 0 )
            ++p;
          while ( *p == 44 || ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x2000) != 0 )
            ++p;
          spaces = 5;
        }
        while ( *p && *p != 59 && *p != 44 && spaces )
        {
          if ( ((*__ctype_b_loc())[*(unsigned __int8 *)++p] & 0x2000) != 0 )
          {
            while ( ((*__ctype_b_loc())[*((unsigned __int8 *)p + 1)] & 0x2000) != 0 )
              ++p;
            --spaces;
          }
          else if ( *p == 45 )
          {
            --spaces;
          }
        }
        value_end = p;
      }
    }
    if ( *p == 59 || *p == 44 )
      ++p;
    if ( attr_end > attr_start )
    {
      value = alloc_attr_value(value_start, value_end);
      parse_flags = parse_attribute(
                      parse_flags,
                      cur_cookie,
                      &cookie_len,
                      attr_start,
                      attr_end - attr_start,
                      value,
                      address,
                      hostname,
                      port);
      if ( (parse_flags & 2) == 0 && value && value_end >= value_start )
      {
        if ( cookie_len > max_cookies_buffer || !cur_cookie || (parse_flags & 1) != 0 )
        {
          if ( cur_cookie )
          {
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
            {
              if ( cur_cookie->value )
                v33 = cur_cookie->value;
              else
                v33 = "[no value]";
              if ( cur_cookie->name )
                name = cur_cookie->name;
              else
                name = "[no name]";
              v7 = TraceFP();
              fprintf(v7, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n", name, v33);
            }
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
            {
              if ( (parse_flags & 1) != 0 )
                format = "                     due to excessive length!\n";
              else
                format = "                     due to invalid port!\n";
              v8 = TraceFP();
              fprintf(v8, format);
            }
            if ( (parse_flags & 1) != 0 )
              --NumCookies;
            freeCookie(cur_cookie);
            cur_cookie = 0;
          }
        }
        else
        {
          if ( cur_cookie->version <= 0 )
            cur_cookie->version = 1;
          HTList_appendObject(CombinedCookies, cur_cookie);
        }
        cur_cookie = newCookie();
        cookie_len = 0;
        ++NumCookies;
        MemAllocCopy(&cur_cookie->name, attr_start, attr_end);
        v9 = strlen(cur_cookie->name);
        cookie_len += v9;
        MemAllocCopy(&cur_cookie->value, value_start, value_end);
        v10 = strlen(cur_cookie->value);
        cookie_len += v10;
        HTSACopy(&cur_cookie->domain, hostname);
        v11 = strlen(cur_cookie->domain);
        cookie_len += v11;
        HTSACopy(&cur_cookie->path, path);
        v12 = strlen(cur_cookie->path);
        cur_cookie->pathlen = v12;
        cookie_len += cur_cookie->pathlen;
        cur_cookie->port = port;
        parse_flags = 0;
        cur_cookie->quoted = 1;
      }
      if ( value )
        free(value);
    }
  }
  if ( NumCookies > max_cookies_domain || cookie_len > max_cookies_buffer || !cur_cookie || (parse_flags & 1) != 0 )
  {
    if ( !cur_cookie || (parse_flags & 1) != 0 )
    {
      if ( !cur_cookie )
        goto LABEL_190;
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        if ( cur_cookie->value )
          v41 = cur_cookie->value;
        else
          v41 = "[no value]";
        if ( cur_cookie->name )
          v42 = cur_cookie->name;
        else
          v42 = "[no name]";
        v15 = TraceFP();
        fprintf(v15, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n", v42, v41);
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        v16 = TraceFP();
        fprintf(v16, "                     due to invalid port!\n");
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        if ( cur_cookie->value )
          v36 = cur_cookie->value;
        else
          v36 = "[no value]";
        if ( cur_cookie->name )
          v37 = cur_cookie->name;
        else
          v37 = "[no name]";
        v13 = TraceFP();
        fprintf(v13, "LYProcessSetCookies: Rejecting Set-Cookie2: %s=%s\n", v37, v36);
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        if ( NumCookies <= max_cookies_domain )
          v38 = "!\n";
        else
          v38 = "number!\n";
        if ( cookie_len <= max_cookies_buffer || NumCookies <= max_cookies_domain )
          v39 = &byte_816DF60;
        else
          v39 = " and ";
        if ( cookie_len <= max_cookies_buffer )
          v40 = &byte_816DF60;
        else
          v40 = "length";
        v14 = TraceFP();
        fprintf(v14, "                     due to excessive %s%s%s\n", v40, v39, v38);
      }
    }
    freeCookie(cur_cookie);
    cur_cookie = 0;
  }
  else
  {
    if ( cur_cookie->version <= 0 )
      cur_cookie->version = 1;
    HTList_appendObject(CombinedCookies, cur_cookie);
  }
LABEL_190:
  cookie_len = 0;
  NumCookiesa = 0;
  cur_cookie = 0;
  if ( !SetCookie || SetCookie2 && *SetCookie2 )
    v43 = &byte_816DF60;
  else
    v43 = SetCookie;
  p = v43;
  if ( SetCookie2 && *p && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    v17 = TraceFP();
    fprintf(v17, "LYProcessSetCookies: Using Set-Cookie header.\n");
  }
  while ( NumCookiesa <= max_cookies_domain && *p )
  {
    value_end = 0;
    value_start = 0;
    attr_end = 0;
    attr_start = 0;
    p = LYSkipCBlanks(p);
    attr_start = p;
    while ( *p && ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x2000) == 0 && *p != 61 && *p != 59 && *p != 44 )
      ++p;
    attr_end = p;
    p = LYSkipCBlanks(p);
    if ( *p == 61 || !strncasecomp(attr_start, "Expires", 7) )
    {
      if ( *p == 61 )
        ++p;
      p = LYSkipCBlanks(p);
      if ( attr_end - attr_start != 7 || strncasecomp(attr_start, "Expires", 7) )
      {
        if ( attr_end - attr_start == 4
          && !strncasecomp(attr_start, "port", 4)
          && ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x800) != 0 )
        {
          value_start = p;
          while ( 1 )
          {
            while ( ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x800) != 0 )
              ++p;
            value_end = p;
            p = LYSkipCBlanks(p);
            if ( !*p || *p == 59 )
              break;
            if ( *p != 44 )
              goto LABEL_256;
            cp_0 = LYSkipCBlanks(p + 1);
            if ( !*cp_0 )
              goto LABEL_256;
            if ( ((*__ctype_b_loc())[*(unsigned __int8 *)cp_0] & 0x800) == 0 )
              goto LABEL_256;
            for ( cp1_0 = cp_0; ((*__ctype_b_loc())[*(unsigned __int8 *)cp1_0] & 0x800) != 0; ++cp1_0 )
              ;
            cp1_0a = LYSkipCBlanks(cp1_0);
            if ( *cp1_0a )
            {
              if ( *cp1_0a != 44 && *cp1_0a != 59 )
              {
LABEL_256:
                while ( *p && *p != 59 && *p != 44 )
                  ++p;
                value_end = p;
                if ( p > value_start && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
                {
                  --value_end;
                  while ( value_start + 1 < value_end
                       && ((*__ctype_b_loc())[*(unsigned __int8 *)value_end] & 0x2000) != 0
                       && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
                    --value_end;
                }
                break;
              }
            }
            p = cp_0;
          }
        }
        else if ( *p == 34 )
        {
          escaped_0 = 0;
          value_start = ++p;
          while ( *p && (*p != 34 || escaped_0) )
          {
            v44 = !escaped_0 && *p == 92;
            escaped_0 = v44;
            ++p;
          }
          if ( p == value_start || *p != 34 || escaped_0 )
          {
            --value_start;
            value_end = p;
            if ( *p )
              ++p;
            Quoted = 0;
          }
          else
          {
            value_end = p++;
            Quoted = 1;
          }
        }
        else
        {
          value_start = p;
          while ( *p && *p != 59 && *p != 44 )
            ++p;
          value_end = p;
          if ( p > value_start && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
          {
            --value_end;
            while ( value_start + 1 < value_end
                 && ((*__ctype_b_loc())[*(unsigned __int8 *)value_end] & 0x2000) != 0
                 && ((*__ctype_b_loc())[*((unsigned __int8 *)value_end - 1)] & 0x2000) != 0 )
              --value_end;
          }
        }
      }
      else
      {
        value_start = p;
        if ( ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x800) != 0 )
        {
          spaces_0 = 5;
        }
        else
        {
          while ( *p && ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x400) != 0 )
            ++p;
          while ( *p == 44 || ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x2000) != 0 )
            ++p;
          spaces_0 = 5;
        }
        while ( *p && *p != 59 && *p != 44 && spaces_0 )
        {
          if ( ((*__ctype_b_loc())[*(unsigned __int8 *)++p] & 0x2000) != 0 )
          {
            while ( ((*__ctype_b_loc())[*((unsigned __int8 *)p + 1)] & 0x2000) != 0 )
              ++p;
            --spaces_0;
          }
          else if ( *p == 45 )
          {
            --spaces_0;
          }
        }
        value_end = p;
      }
    }
    if ( *p == 59 || *p == 44 )
      ++p;
    if ( attr_end > attr_start )
    {
      value_0 = alloc_attr_value(value_start, value_end);
      parse_flags = parse_attribute(
                      parse_flags,
                      cur_cookie,
                      &cookie_len,
                      attr_start,
                      attr_end - attr_start,
                      value_0,
                      address,
                      hostname,
                      port);
      if ( (parse_flags & 2) == 0 && value_0 && value_end >= value_start )
      {
        if ( cookie_len <= max_cookies_buffer && cur_cookie )
        {
          if ( SetCookie2 )
          {
            if ( cur_cookie->version <= 0 )
              cur_cookie->version = 1;
            cur_cookie->quoted = 1;
          }
          HTList_appendObject(CombinedCookies, cur_cookie);
        }
        else if ( cur_cookie )
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
          {
            if ( cur_cookie->value )
              v45 = cur_cookie->value;
            else
              v45 = "[no value]";
            if ( cur_cookie->name )
              v46 = cur_cookie->name;
            else
              v46 = "[no name]";
            v18 = TraceFP();
            fprintf(v18, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n", v46, v45);
          }
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
          {
            v19 = TraceFP();
            fprintf(v19, "                     due to excessive length!\n");
          }
          freeCookie(cur_cookie);
          cur_cookie = 0;
        }
        cur_cookie = newCookie();
        ++NumCookiesa;
        cookie_len = 0;
        MemAllocCopy(&cur_cookie->name, attr_start, attr_end);
        v20 = strlen(cur_cookie->name);
        cookie_len += v20;
        MemAllocCopy(&cur_cookie->value, value_start, value_end);
        v21 = strlen(cur_cookie->value);
        cookie_len += v21;
        HTSACopy(&cur_cookie->domain, hostname);
        v22 = strlen(cur_cookie->domain);
        cookie_len += v22;
        HTSACopy(&cur_cookie->path, path);
        v23 = strlen(cur_cookie->path);
        cur_cookie->pathlen = v23;
        cookie_len += cur_cookie->pathlen;
        cur_cookie->port = port;
        parse_flags = 0;
        cur_cookie->quoted = Quoted;
        Quoted = 0;
      }
      if ( value_0 )
        free(value_0);
    }
  }
  if ( NumCookiesa <= max_cookies_domain && cookie_len <= max_cookies_buffer && cur_cookie )
  {
    if ( SetCookie2 )
    {
      if ( cur_cookie->version <= 0 )
        cur_cookie->version = 1;
      cur_cookie->quoted = 1;
    }
    HTList_appendObject(CombinedCookies, cur_cookie);
  }
  else if ( cur_cookie )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
    {
      if ( cur_cookie->value )
        v47 = cur_cookie->value;
      else
        v47 = "[no value]";
      if ( cur_cookie->name )
        v48 = cur_cookie->name;
      else
        v48 = "[no name]";
      v24 = TraceFP();
      fprintf(v24, "LYProcessSetCookies: Rejecting Set-Cookie: %s=%s\n", v48, v47);
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
    {
      if ( NumCookiesa <= max_cookies_domain )
        v49 = "!\n";
      else
        v49 = "number!\n";
      if ( cookie_len <= max_cookies_buffer || NumCookiesa <= max_cookies_domain )
        v50 = &byte_816DF60;
      else
        v50 = " and ";
      if ( cookie_len <= max_cookies_buffer )
        v51 = &byte_816DF60;
      else
        v51 = "length";
      v25 = TraceFP();
      fprintf(v25, "                     due to excessive %s%s%s\n", v51, v50, v49);
    }
    freeCookie(cur_cookie);
    cur_cookie = 0;
  }
  cl_0 = CombinedCookies;
  while ( 1 )
  {
    if ( cl_0 && (cl_0 = cl_0->next) != 0 )
      object = (cookie *)cl_0->object;
    else
      object = 0;
    co = object;
    if ( !object )
      break;
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
    {
      if ( co->value )
        v52 = co->value;
      else
        v52 = "[no value]";
      if ( co->name )
        v53 = co->name;
      else
        v53 = "[no name]";
      v26 = TraceFP();
      fprintf(v26, "LYProcessSetCookie: attr=value pair: '%s=%s'\n", v53, v52);
    }
    if ( co->expires > 0 && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
    {
      v27 = ctime(&co->expires);
      expires = co->expires;
      v29 = TraceFP();
      fprintf(v29, "                    expires: %d, %s\n", expires, v27);
    }
    if ( !strncasecomp(address, "https:", 6) && LYForceSSLCookiesSecure == 1 && (co->flags & 1) == 0 )
    {
      co->flags |= 1u;
      if ( WWW_TraceFlag[0] )
      {
        if ( (WWW_TraceMask & 0x20) != 0 )
        {
          v30 = TraceFP();
          fprintf(v30, "                    Forced the 'secure' flag on.\n");
        }
      }
    }
    store_cookie(co, hostname, path);
  }
  HTList_delete(CombinedCookies);
}

//----- (080E89C6) --------------------------------------------------------
void __cdecl LYSetCookie(const char *SetCookie, const char *SetCookie2, const char *address)
{
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  const char *v7; // [esp+20h] [ebp-28h]
  const char *v8; // [esp+24h] [ebp-24h]
  int port; // [esp+34h] [ebp-14h]
  char *ptr; // [esp+38h] [ebp-10h]
  char *ptra; // [esp+38h] [ebp-10h]
  char *path; // [esp+3Ch] [ebp-Ch]
  char *hostname; // [esp+40h] [ebp-8h]
  BOOLEAN BadHeaders; // [esp+47h] [ebp-1h]

  BadHeaders = 0;
  port = 80;
  hostname = HTParse(address, &byte_816DF60, 8);
  if ( hostname && (ptr = strchr(hostname, 58)) != 0 )
  {
    *ptr = 0;
    port = atoi(ptr + 1);
  }
  else if ( !strncasecomp(address, "https:", 6) )
  {
    port = 443;
  }
  path = HTParse(address, &byte_816DF60, 5);
  if ( path )
  {
    ptra = strrchr(path, 47);
    if ( ptra )
    {
      if ( ptra == path )
        ptra[1] = 0;
      else
        *ptra = 0;
    }
  }
  if ( (!SetCookie || !*SetCookie) && (!SetCookie2 || !*SetCookie2) )
    BadHeaders = 1;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    if ( path )
      v7 = path;
    else
      v7 = &byte_816DF60;
    if ( hostname )
      v8 = hostname;
    else
      v8 = &byte_816DF60;
    v3 = TraceFP();
    fprintf(v3, "LYSetCookie called with host '%s', path '%s',\n", v8, v7);
  }
  if ( SetCookie && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    v4 = TraceFP();
    fprintf(v4, "    and Set-Cookie: '%s'\n", SetCookie);
  }
  if ( SetCookie2 && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    v5 = TraceFP();
    fprintf(v5, "    and Set-Cookie2: '%s'\n", SetCookie2);
  }
  if ( (!LYSetCookies || BadHeaders == 1) && WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    v6 = TraceFP();
    fprintf(v6, "    Ignoring this Set-Cookie/Set-Cookie2 request.\n");
  }
  if ( LYSetCookies && BadHeaders != 1 )
  {
    LYProcessSetCookies(SetCookie, SetCookie2, address, hostname, path, port);
    if ( hostname )
      free(hostname);
    if ( path )
      goto LABEL_47;
  }
  else
  {
    if ( hostname )
      free(hostname);
    if ( path )
LABEL_47:
      free(path);
  }
}

//----- (080E8CA0) --------------------------------------------------------
char *__cdecl LYAddCookieHeader(char *hostname, char *path, int port, BOOLEAN secure)
{
  FILE *v4; // eax
  char *v6; // [esp+18h] [ebp-20h]
  char *v7; // [esp+1Ch] [ebp-1Ch]
  domain_entry *de; // [esp+28h] [ebp-10h]
  HTList *next; // [esp+2Ch] [ebp-Ch]
  HTList *hl; // [esp+30h] [ebp-8h]
  char *header; // [esp+34h] [ebp-4h]

  header = 0;
  hl = domain_list;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    if ( path )
      v6 = path;
    else
      v6 = "(null)";
    if ( hostname )
      v7 = hostname;
    else
      v7 = "(null)";
    v4 = TraceFP();
    fprintf(v4, "LYCookie: Searching for '%s:%d', '%s'.\n", v7, port, v6);
  }
  while ( hl )
  {
    de = (domain_entry *)hl->object;
    next = hl->next;
    if ( hl->object )
    {
      if ( de->cookie_list && de->cookie_list->next )
      {
        header = scan_cookie_sublist(hostname, path, port, de->cookie_list, header, secure);
      }
      else if ( de->bv == QUERY_USER && de->invcheck_bv == INVCHECK_QUERY )
      {
        if ( de->domain )
        {
          free(de->domain);
          de->domain = 0;
        }
        HTList_delete(de->cookie_list);
        de->cookie_list = 0;
        HTList_removeObject(domain_list, de);
        if ( de )
          free(de);
      }
    }
    hl = next;
  }
  if ( header )
    return header;
  else
    return 0;
}

//----- (080E8E48) --------------------------------------------------------
void __cdecl LYLoadCookies(char *cookie_file)
{
  FILE *v1; // eax
  char *v2; // ebx
  size_t v3; // eax
  char *v4; // ebx
  FILE *v5; // eax
  int v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  char *v9; // ebx
  FILE *v10; // eax
  int v11; // eax
  char *tok_ptr; // [esp+18h] [ebp-20h] BYREF
  char *tok_out; // [esp+1Ch] [ebp-1Ch]
  int tok_loop; // [esp+20h] [ebp-18h]
  cookie *moo; // [esp+24h] [ebp-14h]
  time_t expires; // [esp+28h] [ebp-10h] BYREF
  char *buf; // [esp+2Ch] [ebp-Ch] BYREF
  FILE *cookie_handle; // [esp+30h] [ebp-8h]

  buf = 0;
  cookie_handle = (FILE *)fopen64(cookie_file, "r");
  if ( cookie_handle )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
    {
      v1 = TraceFP();
      fprintf(v1, "LYLoadCookies: reading cookies from %s\n", cookie_file);
    }
    number_of_file_cookies = 0;
    while ( LYSafeGets(&buf, cookie_handle) )
    {
      LYTrimNewline(buf);
      if ( *buf && *buf != 35 )
      {
        ++number_of_file_cookies;
        v2 = buf;
        v3 = strlen(buf);
        memcpy(&v2[v3], "\t", 2u);
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
        {
          v4 = buf;
          v5 = TraceFP();
          fprintf(v5, "LYLoadCookies: tokenising %s\n", v4);
        }
        tok_ptr = buf;
        tok_out = LYstrsep(&tok_ptr, "\t");
        for ( tok_loop = 0; tok_out && tok_values_13111[tok_loop].s; ++tok_loop )
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
          {
            v6 = tok_out - buf;
            v7 = TraceFP();
            fprintf(v7, "\t%d:[%03d]:[%s]\n", tok_loop, v6, tok_out);
          }
          LYstrncpy(tok_values_13111[tok_loop].s, tok_out, tok_values_13111[tok_loop].n);
          tok_out = LYstrsep(&tok_ptr, "\t");
        }
        if ( tok_values_13111[tok_loop].s )
        {
          if ( WWW_TraceFlag[0] )
          {
            if ( (WWW_TraceMask & 0x20) != 0 )
            {
              v8 = TraceFP();
              fprintf(v8, "*** wrong format: not enough tokens, ignoring line!\n");
            }
          }
        }
        else
        {
          expires = atol(expires_a_13107);
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
          {
            v9 = ctime(&expires);
            v10 = TraceFP();
            fprintf(v10, "expires:\t%s\n", v9);
          }
          moo = newCookie();
          HTSACopy(&moo->domain, domain_13101);
          HTSACopy(&moo->path, path_13102);
          HTSACopy(&moo->name, name_13103);
          if ( value_13104[0] == 34
            && value_13104[1]
            && value_13104[strlen(value_13104) - 1] == 34
            && value_13104[strlen(value_13104) - 2] != 92 )
          {
            value_13104[strlen(value_13104) - 1] = 0;
            HTSACopy(&moo->value, &value_13104[1]);
            moo->quoted = 1;
          }
          else
          {
            HTSACopy(&moo->value, value_13104);
          }
          v11 = strlen(moo->path);
          moo->pathlen = v11;
          moo->flags |= 0x34u;
          if ( domain_13101[0] == 46 )
            moo->flags |= 8u;
          if ( secure_13106[0] != 70 )
            moo->flags |= 1u;
          moo->expires = expires;
          store_cookie(moo, domain_13101, path_13102);
        }
      }
    }
    LYCloseInput(cookie_handle);
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080E923C) --------------------------------------------------------
FILE *__cdecl NewCookieFile(char *cookie_file)
{
  FILE *v1; // eax

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "LYStoreCookies: save cookies to %s on exit\n", cookie_file);
  }
  return LYNewTxtFile(cookie_file);
}

//----- (080E9284) --------------------------------------------------------
void __cdecl LYStoreCookies(char *cookie_file)
{
  time_t expires; // ebx
  FILE *v2; // edx
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  const char *v7; // [esp+34h] [ebp-44h]
  const char *value; // [esp+38h] [ebp-40h]
  const char *v9; // [esp+3Ch] [ebp-3Ch]
  const char *v10; // [esp+48h] [ebp-30h]
  const char *v11; // [esp+50h] [ebp-28h]
  time_t now; // [esp+5Ch] [ebp-1Ch]
  FILE *cookie_handle; // [esp+60h] [ebp-18h]
  cookie *co; // [esp+64h] [ebp-14h]
  domain_entry *de; // [esp+68h] [ebp-10h]
  HTList *cl_0; // [esp+6Ch] [ebp-Ch]
  HTList *dl_0; // [esp+70h] [ebp-8h]

  cookie_handle = 0;
  now = time(0);
  if ( cookie_file
    && *cookie_file
    && strcmp(cookie_file, "/dev/null")
    && (domain_list && domain_list->next || number_of_file_cookies)
    && (!number_of_file_cookies || (cookie_handle = NewCookieFile(cookie_file)) != 0) )
  {
    for ( dl_0 = domain_list; dl_0; dl_0 = dl_0->next )
    {
      de = (domain_entry *)dl_0->object;
      if ( dl_0->object )
      {
        for ( cl_0 = de->cookie_list; cl_0; cl_0 = cl_0->next )
        {
          co = (cookie *)cl_0->object;
          if ( cl_0->object )
          {
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
            {
              expires = co->expires;
              v2 = TraceFP();
              fprintf(v2, "LYStoreCookies: %d cf %d ", now, expires);
            }
            if ( (co->flags & 2) != 0 )
            {
              if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
              {
                v3 = TraceFP();
                fprintf(v3, "not stored - DISCARD\n");
              }
            }
            else if ( (co->flags & 4) != 0 )
            {
              if ( co->expires > now )
              {
                if ( !cookie_handle )
                {
                  cookie_handle = NewCookieFile(cookie_file);
                  if ( !cookie_handle )
                    return;
                }
                if ( co->quoted )
                  v7 = "\"";
                else
                  v7 = &byte_816DF60;
                if ( co->value )
                  value = co->value;
                else
                  value = &byte_816DF60;
                if ( co->quoted )
                  v9 = "\"";
                else
                  v9 = &byte_816DF60;
                if ( (co->flags & 1) != 0 )
                  v10 = "TRUE";
                else
                  v10 = "FALSE";
                if ( *de->domain == 46 )
                  v11 = "TRUE";
                else
                  v11 = "FALSE";
                fprintf(
                  cookie_handle,
                  "%s\t%s\t%s\t%s\t%d\t%s\t%s%s%s\n",
                  de->domain,
                  v11,
                  co->path,
                  v10,
                  co->expires,
                  co->name,
                  v9,
                  value,
                  v7);
                if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
                {
                  v6 = TraceFP();
                  fprintf(v6, "STORED\n");
                }
              }
              else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
              {
                v5 = TraceFP();
                fprintf(v5, "not stored - EXPIRED\n");
              }
            }
            else if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
            {
              v4 = TraceFP();
              fprintf(v4, "not stored - no expiration time\n");
            }
          }
        }
      }
    }
    if ( cookie_handle )
      LYCloseOutput(cookie_handle);
  }
}

//----- (080E95F0) --------------------------------------------------------
int __cdecl LYHandleCookies(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // ebx
  char *v18; // eax
  char *v19; // ebx
  char *v20; // eax
  char *v21; // eax
  char *v22; // eax
  char *v23; // esi
  char *v24; // ebx
  char *v25; // eax
  char *v26; // eax
  void (*put_block)(HTStream *, const char *, int); // ebx
  size_t v28; // eax
  char *v29; // ebx
  const char *v30; // esi
  char *v31; // eax
  void (*v32)(HTStream *, const char *, int); // ebx
  size_t v33; // eax
  char *v34; // eax
  void (*v35)(HTStream *, const char *, int); // ebx
  size_t v36; // eax
  char *v37; // eax
  void (*v38)(HTStream *, const char *, int); // ebx
  size_t v39; // eax
  void (*v40)(HTStream *, const char *, int); // ebx
  size_t v41; // eax
  void (*v42)(HTStream *, const char *, int); // ebx
  size_t v43; // eax
  char *v44; // eax
  char *v45; // eax
  char *v46; // eax
  void (*v47)(HTStream *, const char *, int); // ebx
  size_t v48; // eax
  void (*v49)(HTStream *, const char *, int); // ebx
  size_t v50; // eax
  char *v51; // eax
  char *v52; // eax
  void (*v53)(HTStream *, const char *, int); // ebx
  size_t v54; // eax
  char *v55; // eax
  void (*v56)(HTStream *, const char *, int); // ebx
  size_t v57; // eax
  void (*v58)(HTStream *, const char *, int); // ebx
  size_t v59; // eax
  void (*v60)(HTStream *, const char *, int); // ebx
  size_t v61; // eax
  void (*v62)(HTStream *, const char *, int); // ebx
  size_t v63; // eax
  void (*v64)(HTStream *, const char *, int); // ebx
  size_t v65; // eax
  char *v66; // eax
  void (*v67)(HTStream *, const char *, int); // ebx
  size_t v68; // eax
  void (*v69)(HTStream *, const char *, int); // ebx
  size_t v70; // eax
  void (*v71)(HTStream *, const char *, int); // ebx
  size_t v72; // eax
  behaviour_t bv; // [esp+2Ch] [ebp-6Ch]
  const char *v76; // [esp+30h] [ebp-68h]
  const char *v77; // [esp+34h] [ebp-64h]
  const char *v78; // [esp+38h] [ebp-60h]
  char *v79; // [esp+3Ch] [ebp-5Ch]
  int ch_0; // [esp+4Ch] [ebp-4Ch]
  char *Title; // [esp+50h] [ebp-48h] BYREF
  char *Address; // [esp+54h] [ebp-44h] BYREF
  char *comment; // [esp+58h] [ebp-40h] BYREF
  char *path; // [esp+5Ch] [ebp-3Ch] BYREF
  char *value; // [esp+60h] [ebp-38h] BYREF
  char *name; // [esp+64h] [ebp-34h] BYREF
  cookie *co; // [esp+68h] [ebp-30h]
  domain_entry *de; // [esp+6Ch] [ebp-2Ch]
  HTList *next; // [esp+70h] [ebp-28h]
  HTList *cl_0; // [esp+74h] [ebp-24h]
  HTList *dl_0; // [esp+78h] [ebp-20h]
  char *lynxID; // [esp+7Ch] [ebp-1Ch]
  char *domain; // [esp+80h] [ebp-18h]
  char *buf; // [esp+84h] [ebp-14h] BYREF
  HTStream *target; // [esp+88h] [ebp-10h]
  HTFormat format_in; // [esp+8Ch] [ebp-Ch]

  format_in = HTAtom_for("text/html");
  target = 0;
  buf = 0;
  domain = 0;
  lynxID = 0;
  name = 0;
  value = 0;
  path = 0;
  comment = 0;
  Address = 0;
  Title = 0;
  if ( domain_list && domain_list->next )
  {
    domain = HTParse(arg, &byte_816DF60, 8);
    if ( domain )
    {
      if ( *domain )
      {
        lynxID = HTParse(arg, &byte_816DF60, 4);
        if ( lynxID && !*lynxID )
        {
          free(lynxID);
          lynxID = 0;
        }
      }
      else
      {
        free(domain);
        domain = 0;
      }
    }
    if ( domain )
    {
      de = find_domain_entry(domain);
      if ( de )
      {
        free(domain);
        domain = 0;
        if ( !lynxID )
        {
          if ( de->cookie_list && de->cookie_list->next )
          {
            mustshow[0] = 1;
            v10 = gettext("D)elete domain's cookies, set allow A)lways/P)rompt/neV)er, or C)ancel? ");
            statusline(v10);
          }
          else
          {
            mustshow[0] = 1;
            v9 = gettext("D)elete domain, set allow A)lways/P)rompt/neV)er, or C)ancel? ");
            statusline(v9);
          }
          HTNoDataOK = 1;
          while ( 1 )
          {
            ch_0 = LYgetch_single();
            switch ( ch_0 )
            {
              case 'A':
                de->bv = ACCEPT_ALWAYS;
                v11 = de->domain;
                v12 = gettext("'A'lways allowing from domain '%s'.");
                HTUserMsg2(v12, v11);
                return -204;
              case 'C':
                goto reject;
              case 'D':
                if ( de->cookie_list && de->cookie_list->next )
                  goto Delete_all_cookies_in_domain;
                if ( de->domain )
                {
                  free(de->domain);
                  de->domain = 0;
                }
                HTList_delete(de->cookie_list);
                de->cookie_list = 0;
                HTList_removeObject(domain_list, de);
                if ( de )
                {
                  free(de);
                  de = 0;
                }
                goto LABEL_46;
              case 'P':
                de->bv = QUERY_USER;
                v17 = de->domain;
                v18 = gettext("'P'rompting to allow from domain '%s'.");
                HTUserMsg2(v18, v17);
                return -204;
              case 'V':
                de->bv = REJECT_ALWAYS;
                v19 = de->domain;
                v20 = gettext("ne'V'er allowing from domain '%s'.");
                HTUserMsg2(v20, v19);
                if ( !de->cookie_list )
                  return -204;
                if ( !de->cookie_list->next )
                  return -204;
                v21 = gettext("Delete all cookies in this domain?");
                if ( !HTConfirm(v21) )
                  return -204;
Delete_all_cookies_in_domain:
                for ( cl_0 = de->cookie_list; cl_0; cl_0 = next )
                {
                  next = cl_0->next;
                  co = (cookie *)cl_0->object;
                  if ( co )
                  {
                    HTList_removeObject(de->cookie_list, co);
                    freeCookie(co);
                    co = 0;
                    --total_cookies;
                  }
                }
                v15 = gettext("All cookies in the domain have been eaten!");
                HTProgress(v15);
                LYSleepMsg();
                if ( de->bv != QUERY_USER )
                  return -204;
                v16 = gettext("Delete this empty domain?");
                if ( HTConfirm(v16) )
                {
                  if ( de->domain )
                  {
                    free(de->domain);
                    de->domain = 0;
                  }
                  HTList_delete(de->cookie_list);
                  de->cookie_list = 0;
                  HTList_removeObject(domain_list, de);
                  if ( de )
                  {
                    free(de);
                    de = 0;
                  }
LABEL_46:
                  v14 = gettext("The domain has been eaten!");
                  HTProgress(v14);
                  LYSleepMsg();
                }
                goto LABEL_75;
              default:
                if ( ch_0 == 3 || ch_0 == 7 )
                  goto reject;
                if ( ch_0 == -1 )
                {
                  if ( keymap[0] == 47 )
                    goto reject;
                }
                else if ( (ch_0 & 0x8800) != 0 )
                {
                  if ( (unsigned __int8)ch_0 == 47 )
                    goto reject;
                }
                else if ( keymap[(ch_0 & 0x7FF) + 1] == 47 )
                {
reject:
                  v13 = gettext("Cancelled!!!");
                  HTUserMsg(v13);
                  return -204;
                }
                break;
            }
          }
        }
        for ( cl_0 = de->cookie_list; cl_0; cl_0 = cl_0->next )
        {
          co = (cookie *)cl_0->object;
          if ( co && !strcmp(lynxID, co->lynxID) )
          {
            v5 = gettext("Delete this cookie?");
            if ( !HTConfirm(v5) )
            {
              free(lynxID);
              lynxID = 0;
              HTNoDataOK = 1;
              return -204;
            }
            HTList_removeObject(de->cookie_list, co);
            freeCookie(co);
            co = 0;
            --total_cookies;
            if ( de->bv != QUERY_USER
              || de->cookie_list && de->cookie_list->next
              || (v6 = gettext("Delete this empty domain?"), !HTConfirm(v6)) )
            {
              v8 = gettext("The cookie has been eaten!");
              HTProgress(v8);
            }
            else
            {
              if ( de->domain )
              {
                free(de->domain);
                de->domain = 0;
              }
              HTList_delete(de->cookie_list);
              de->cookie_list = 0;
              HTList_removeObject(domain_list, de);
              if ( de )
              {
                free(de);
                de = 0;
              }
              v7 = gettext("The domain has been eaten!");
              HTProgress(v7);
            }
            LYSleepMsg();
            HTNoDataOK = 1;
            break;
          }
        }
      }
LABEL_75:
      if ( !domain_list || !domain_list->next )
      {
        v22 = gettext("All of the cookies in the jar have been eaten!");
        HTProgress(v22);
        LYSleepMsg();
      }
      if ( domain )
      {
        free(domain);
        domain = 0;
      }
      if ( lynxID )
      {
        free(lynxID);
        lynxID = 0;
      }
      return -204;
    }
    else
    {
      target = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
      if ( target )
      {
        v26 = gettext("Cookie Jar");
        HTSprintf0(&buf, "<html>\n<head>\n<title>%s</title>\n</head>\n<body>\n", v26);
        put_block = target->isa->put_block;
        v28 = strlen(buf);
        put_block(target, buf, v28);
        v29 = gettext("Cookie Jar");
        v30 = helpfilepath;
        v31 = gettext(", help on ");
        HTSprintf0(
          &buf,
          "<h1>%s (%s)%s<a href=\"%s%s\">%s</a></h1>\n",
          "Lynx",
          "2.8.7dev.11",
          v31,
          v30,
          "Lynx_users_guide.html.gz#Cookies",
          v29);
        v32 = target->isa->put_block;
        v33 = strlen(buf);
        v32(target, buf, v33);
        v34 = gettext("Activate links to gobble up cookies or entire domains,");
        HTSprintf0(&buf, "<note>%s\n", v34);
        v35 = target->isa->put_block;
        v36 = strlen(buf);
        v35(target, buf, v36);
        v37 = gettext("or to change a domain's 'allow' setting.");
        HTSprintf0(&buf, "%s</note>\n", v37);
        v38 = target->isa->put_block;
        v39 = strlen(buf);
        v38(target, buf, v39);
        HTSprintf0(&buf, "<dl compact>\n");
        v40 = target->isa->put_block;
        v41 = strlen(buf);
        v40(target, buf, v41);
        for ( dl_0 = domain_list; dl_0; dl_0 = dl_0->next )
        {
          de = (domain_entry *)dl_0->object;
          if ( de )
          {
            HTSprintf0(
              &buf,
              "<dt>%s<dd><a href=\"%s//%s/\">Domain=%s</a>\n",
              de->domain,
              "LYNXCOOKIE:",
              de->domain,
              de->domain);
            v42 = target->isa->put_block;
            v43 = strlen(buf);
            v42(target, buf, v43);
            bv = de->bv;
            if ( bv == REJECT_ALWAYS )
            {
              v45 = gettext("(Cookies never allowed.)");
              HTSprintf0(&buf, v45);
            }
            else if ( bv )
            {
              if ( bv == QUERY_USER )
              {
                v46 = gettext("(Cookies allowed via prompt.)");
                HTSprintf0(&buf, v46);
              }
            }
            else
            {
              v44 = gettext("(Cookies always allowed.)");
              HTSprintf0(&buf, v44);
            }
            v47 = target->isa->put_block;
            v48 = strlen(buf);
            v47(target, buf, v48);
            HTSprintf0(&buf, "\n");
            v49 = target->isa->put_block;
            v50 = strlen(buf);
            v49(target, buf, v50);
            for ( cl_0 = de->cookie_list; cl_0; cl_0 = cl_0->next )
            {
              co = (cookie *)cl_0->object;
              if ( co )
              {
                if ( co->name )
                {
                  HTSACopy(&name, co->name);
                  LYEntify(&name, 1);
                }
                else
                {
                  v51 = gettext("(No name.)");
                  HTSACopy(&name, v51);
                }
                if ( co->value )
                {
                  HTSACopy(&value, co->value);
                  LYEntify(&value, 1);
                }
                else
                {
                  v52 = gettext("(No value.)");
                  HTSACopy(&value, v52);
                }
                HTSprintf0(
                  &buf,
                  "<dd><a href=\"%s//%s/%s\">%s=%s</a>\n",
                  "LYNXCOOKIE:",
                  de->domain,
                  co->lynxID,
                  name,
                  value);
                if ( name )
                {
                  free(name);
                  name = 0;
                }
                if ( value )
                {
                  free(value);
                  value = 0;
                }
                v53 = target->isa->put_block;
                v54 = strlen(buf);
                v53(target, buf, v54);
                if ( (co->flags & 0x20) != 0 )
                {
                  v55 = gettext("(from a previous session)");
                  HTSprintf0(&buf, "%s\n", v55);
                  v56 = target->isa->put_block;
                  v57 = strlen(buf);
                  v56(target, buf, v57);
                }
                if ( co->path )
                {
                  HTSACopy(&path, co->path);
                  LYEntify(&path, 1);
                }
                else
                {
                  HTSACopy(&path, "/");
                }
                if ( (co->flags & 2) != 0 )
                  v76 = "YES";
                else
                  v76 = "NO";
                if ( (co->flags & 1) != 0 )
                  v77 = "YES";
                else
                  v77 = "NO";
                HTSprintf0(&buf, "<dd>Path=%s\n<dd>Port: %d Secure: %s Discard: %s\n", path, co->port, v77, v76);
                if ( path )
                {
                  free(path);
                  path = 0;
                }
                v58 = target->isa->put_block;
                v59 = strlen(buf);
                v58(target, buf, v59);
                if ( co->PortList )
                {
                  HTSprintf0(&buf, "<dD>PortList=\"%s\"\n", co->PortList);
                  v60 = target->isa->put_block;
                  v61 = strlen(buf);
                  v60(target, buf, v61);
                }
                if ( co->commentURL )
                {
                  HTSACopy(&Address, co->commentURL);
                  LYEntify(&Address, 0);
                  HTSACopy(&Title, co->commentURL);
                  LYEntify(&Title, 1);
                  HTSprintf0(&buf, "<dd>CommentURL: <a href=\"%s\">%s</a>\n", Address, Title);
                  if ( Address )
                  {
                    free(Address);
                    Address = 0;
                  }
                  if ( Title )
                  {
                    free(Title);
                    Title = 0;
                  }
                  v62 = target->isa->put_block;
                  v63 = strlen(buf);
                  v62(target, buf, v63);
                }
                if ( co->comment )
                {
                  HTSACopy(&comment, co->comment);
                  LYEntify(&comment, 1);
                  HTSprintf0(&buf, "<dd>Comment: %s\n", comment);
                  if ( comment )
                  {
                    free(comment);
                    comment = 0;
                  }
                  v64 = target->isa->put_block;
                  v65 = strlen(buf);
                  v64(target, buf, v65);
                }
                if ( (co->flags & 4) != 0 )
                  v78 = &byte_816DF60;
                else
                  v78 = "\n";
                if ( (co->flags & 4) != 0 )
                  v79 = ctime(&co->expires);
                else
                  v79 = gettext("(End of session.)");
                v66 = gettext("Maximum Gobble Date:");
                HTSprintf0(&buf, "<dd><em>%s</em> %s%s", v66, v79, v78);
                v67 = target->isa->put_block;
                v68 = strlen(buf);
                v67(target, buf, v68);
              }
            }
            HTSprintf0(&buf, "</dt>\n");
            v69 = target->isa->put_block;
            v70 = strlen(buf);
            v69(target, buf, v70);
          }
        }
        HTSprintf0(&buf, "</dl>\n</body>\n</html>\n");
        v71 = target->isa->put_block;
        v72 = strlen(buf);
        v71(target, buf, v72);
        target->isa->_free(target);
        if ( buf )
        {
          free(buf);
          buf = 0;
        }
        return 200;
      }
      else
      {
        v23 = format_out->name;
        v24 = format_in->name;
        v25 = gettext("Sorry, no known way of converting %s to %s.");
        HTSprintf0(&buf, v25, v24, v23);
        HTAlert(buf);
        if ( buf )
        {
          free(buf);
          buf = 0;
        }
        return -29999;
      }
    }
  }
  else
  {
    v4 = gettext("The Cookie Jar is empty.");
    HTProgress(v4);
    LYSleepMsg();
    HTNoDataOK = 1;
    return -204;
  }
}
// 80E9748: conditional instruction was optimized away because %domain.4!=0
// 80E97BE: conditional instruction was optimized away because %lynxID.4!=0
// 80E96C6: conditional instruction was optimized away because %domain.4!=0
// 80E970E: conditional instruction was optimized away because %lynxID.4!=0

//----- (080EA65E) --------------------------------------------------------
void __cdecl cookie_domain_flag_set(char *domainstr, int flag)
{
  char *v2; // ebx
  char *v3; // eax
  invcheck_behaviour_t invcheck_bv; // ebx
  behaviour_t bv; // esi
  FILE *v6; // edx
  const char *strsmall; // [esp+20h] [ebp-18h]
  char *dstr; // [esp+24h] [ebp-14h] BYREF
  char **str; // [esp+28h] [ebp-10h]
  domain_entry *de; // [esp+2Ch] [ebp-Ch]

  de = 0;
  str = (char **)calloc(1u, 4u);
  dstr = 0;
  if ( !str )
  {
    v2 = gettext("cookie_domain_flag_set error, aborting program");
    v3 = gettext("Internal");
    HTAlwaysAlert(v3, v2);
    exit_immediately(1);
  }
  if ( !domain_list )
  {
    domain_list = HTList_new();
    total_cookies = 0;
  }
  HTSACopy(&dstr, domainstr);
  *str = dstr;
  while ( 1 )
  {
    strsmall = LYstrsep(str, ",");
    if ( !strsmall )
      break;
    if ( *strsmall )
    {
      de = find_domain_entry(strsmall);
      if ( !de )
      {
        de = (domain_entry *)calloc(1u, 0x10u);
        if ( !de )
          outofmem("./LYCookie.c", "cookie_domain_flag_set");
        de->bv = ACCEPT_ALWAYS;
        de->invcheck_bv = INVCHECK_QUERY;
        switch ( flag )
        {
          case 0:
            de->invcheck_bv = INVCHECK_QUERY;
            break;
          case 1:
            de->invcheck_bv = INVCHECK_QUERY;
            break;
          case 2:
            de->invcheck_bv = INVCHECK_QUERY;
            break;
          case 4:
            de->bv = QUERY_USER;
            break;
          case 5:
            de->bv = QUERY_USER;
            break;
          case 6:
            de->bv = QUERY_USER;
            break;
          default:
            break;
        }
        HTSACopy(&de->domain, strsmall);
        de->cookie_list = HTList_new();
        HTList_appendObject(domain_list, de);
      }
      switch ( flag )
      {
        case 0:
          de->bv = ACCEPT_ALWAYS;
          break;
        case 1:
          de->bv = REJECT_ALWAYS;
          break;
        case 2:
          de->bv = QUERY_USER;
          break;
        case 4:
          de->invcheck_bv = INVCHECK_QUERY;
          break;
        case 5:
          de->invcheck_bv = INVCHECK_STRICT;
          break;
        case 6:
          de->invcheck_bv = INVCHECK_LOOSE;
          break;
        default:
          break;
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x20) != 0 )
      {
        invcheck_bv = de->invcheck_bv;
        bv = de->bv;
        v6 = TraceFP();
        fprintf(v6, "cookie_domain_flag_set (%s, bv=%u, invcheck_bv=%u)\n", strsmall, bv, invcheck_bv);
      }
    }
  }
  if ( str )
  {
    free(str);
    str = 0;
  }
  if ( dstr )
    free(dstr);
}

//----- (080EA914) --------------------------------------------------------
void LYConfigCookies()
{
  unsigned int n; // [esp+14h] [ebp-4h]

  for ( n = 0; n <= 9; ++n )
  {
    if ( *table_13950[n].domain )
    {
      cookie_domain_flag_set(*table_13950[n].domain, table_13950[n].flag);
      if ( table_13950[n].once )
      {
        if ( *table_13950[n].domain )
        {
          free(*(void **)table_13950[n].domain);
          *table_13950[n].domain = 0;
        }
      }
    }
  }
}

//----- (080EA9E8) --------------------------------------------------------
char *__cdecl TrimLowercase(char *buffer)
{
  LYRemoveBlanks(buffer);
  strtolower(buffer);
  return buffer;
}

//----- (080EAA09) --------------------------------------------------------
void __cdecl parse_either(char *attrs, int dft_color, int *monop, int *colorp)
{
  char v4; // [esp+17h] [ebp-11h]
  char *next; // [esp+1Ch] [ebp-Ch]
  int value; // [esp+20h] [ebp-8h]
  int valuea; // [esp+20h] [ebp-8h]

  while ( *attrs )
  {
    next = strchr(attrs, 43);
    if ( next )
      v4 = *next;
    else
      v4 = 0;
    if ( !next )
      next = &attrs[strlen(attrs)];
    if ( v4 )
      *next = 0;
    value = string_to_attr(attrs);
    if ( value )
    {
      *monop |= value;
    }
    else if ( colorp )
    {
      valuea = check_color(attrs, dft_color);
      if ( valuea != -3 )
        *colorp = valuea;
    }
    attrs = next;
    if ( v4 )
    {
      *next = v4;
      attrs = next + 1;
    }
  }
}

//----- (080EAAE0) --------------------------------------------------------
void __cdecl parse_attributes(char *mono, char *fg, char *bg, int style, char *element)
{
  FILE *v5; // edx
  int v6; // ebx
  int v7; // esi
  FILE *v8; // eax
  int v9; // ebx
  int v10; // esi
  int v11; // edi
  FILE *v12; // eax
  FILE *v13; // eax
  int v14; // ebx
  FILE *v15; // eax
  int v16; // [esp+34h] [ebp-44h]
  int v17; // [esp+38h] [ebp-40h]
  int iBold; // [esp+48h] [ebp-30h]
  int iBg; // [esp+4Ch] [ebp-2Ch]
  int iFg; // [esp+50h] [ebp-28h]
  int curPair; // [esp+54h] [ebp-24h]
  int newstyle; // [esp+58h] [ebp-20h]
  int cA; // [esp+5Ch] [ebp-1Ch] BYREF
  int bA; // [esp+60h] [ebp-18h] BYREF
  int fA; // [esp+64h] [ebp-14h] BYREF
  int mA[4]; // [esp+68h] [ebp-10h] BYREF

  mA[0] = 0;
  fA = default_fg;
  bA = default_bg;
  cA = 0;
  newstyle = hash_code(element);
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    v5 = TraceFP();
    fprintf(v5, "CSS(PA):style d=%d / h=%d, e=%s\n", style, newstyle, element);
  }
  parse_either(mono, -3, mA, 0);
  parse_either(bg, default_bg, &cA, &bA);
  parse_either(fg, default_fg, &cA, &fA);
  if ( style == -1 )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( (WWW_TraceMask & 2) != 0 )
      {
        v6 = bA;
        v7 = fA;
        v8 = TraceFP();
        fprintf(v8, "CSS(DEF):default_fg=%d, default_bg=%d\n", v7, v6);
      }
    }
    default_fg = fA;
    default_bg = bA;
    default_color_reset[0] = 1;
  }
  else
  {
    if ( fA == -2 )
    {
      bA = -2;
    }
    else if ( COLORS )
    {
      if ( fA >= COLORS || bA >= COLORS )
        cA = 0x200000;
      if ( fA >= COLORS )
        fA %= COLORS;
      if ( bA >= COLORS )
        bA %= COLORS;
    }
    else
    {
      cA = 0x200000;
      fA = -2;
      bA = -2;
    }
    if ( !lynx_has_color || COLOR_PAIRS - 1 <= colorPairs || fA == -2 )
    {
      if ( lynx_has_color && fA != -2 && WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v14 = COLOR_PAIRS - 1;
        v15 = TraceFP();
        fprintf(v15, "CSS(NC): maximum of %d colorpairs exhausted\n", v14);
      }
      if ( style <= 132 )
        setStyle(style, -1, -1, mA[0]);
      setHashStyle(newstyle, -1, -1, mA[0], element);
    }
    else
    {
      curPair = 0;
      iFg = (fA & ~(fA >> 31)) + 1;
      iBg = (bA & ~(bA >> 31)) + 1;
      iBold = (cA & 0x200000) != 0;
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v9 = cA;
        v10 = default_bg;
        v11 = bA;
        v16 = default_fg;
        v17 = fA;
        v12 = TraceFP();
        fprintf(v12, "parse_attributes %d/%d %d/%d %#x\n", v17, v16, v11, v10, v9);
      }
      if ( fA <= 15 && bA <= 15 && (cA || fA != default_fg || bA != default_bg) )
      {
        if ( *(_BYTE *)(iBg + 17 * iFg + 289 * iBold + 135994400) )
        {
          curPair = *(unsigned __int8 *)(iBg + 17 * iFg + 289 * iBold + 135994400);
        }
        else
        {
          curPair = ++colorPairs;
          init_pair(colorPairs, fA, bA);
          *(_BYTE *)(iBg + 17 * iFg + 289 * iBold + 135994400) = curPair;
        }
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v13 = TraceFP();
        fprintf(v13, "CSS(CURPAIR):%d\n", curPair);
      }
      if ( style <= 132 )
        setStyle(style, (curPair << 8) | cA, cA, mA[0]);
      setHashStyle(newstyle, cA | (curPair << 8), cA, mA[0], element);
    }
  }
}
// 80EADD3: conditional instruction was optimized away because %curPair.4==0
// 81AA440: using guessed type int COLORS;
// 81AB39C: using guessed type int COLOR_PAIRS;
// 80EAAE0: using guessed type int mA[4];

//----- (080EAFF2) --------------------------------------------------------
void __cdecl parse_style(char *param)
{
  FILE *v1; // eax
  char *v2; // ebx
  char *v3; // eax
  int v4; // ebx
  FILE *v5; // edx
  int *set_hash; // ebx
  const char *v7; // [esp+20h] [ebp-38h]
  HTTag *t; // [esp+2Ch] [ebp-2Ch]
  int element_number; // [esp+30h] [ebp-28h]
  char *bg; // [esp+34h] [ebp-24h]
  char *fg; // [esp+38h] [ebp-20h]
  char *mono; // [esp+3Ch] [ebp-1Ch]
  char *element; // [esp+40h] [ebp-18h]
  char *tmp; // [esp+44h] [ebp-14h]
  char *tmpa; // [esp+44h] [ebp-14h]
  char *tmpb; // [esp+44h] [ebp-14h]
  char *buffer; // [esp+48h] [ebp-10h] BYREF
  unsigned int n; // [esp+4Ch] [ebp-Ch]
  BOOLEAN found; // [esp+53h] [ebp-5h]

  found = 0;
  buffer = 0;
  if ( param )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v1 = TraceFP();
      fprintf(v1, "parse_style(%s)\n", param);
    }
    HTSACopy(&buffer, param);
    if ( buffer )
    {
      TrimLowercase(buffer);
      tmp = strchr(buffer, 58);
      if ( !tmp )
      {
        v2 = buffer;
        v3 = gettext(
               "Syntax Error parsing style in lss file:\n"
               "[%s]\n"
               "The line must be of the form:\n"
               "OBJECT:MONO:COLOR (ie em:bold:brightblue:white)\n"
               "where OBJECT is one of EM,STRONG,B,I,U,BLINK etc.\n"
               "\n");
        fprintf(stderr, v3, v2);
        exit_immediately(1);
      }
      *tmp = 0;
      element = buffer;
      mono = tmp + 1;
      tmpa = strchr(tmp + 1, 58);
      if ( tmpa )
      {
        *tmpa = 0;
        fg = tmpa + 1;
        tmpb = strchr(tmpa + 1, 58);
        if ( tmpb )
        {
          *tmpb = 0;
          bg = tmpb + 1;
        }
        else
        {
          bg = "default";
        }
      }
      else
      {
        fg = "nocolor";
        bg = "nocolor";
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        if ( hashStyles[hash_code(element)].name )
          v7 = "used";
        else
          v7 = (const char *)&unk_816F168;
        v4 = hash_code(element);
        v5 = TraceFP();
        fprintf(v5, "CSSPARSE:%s => %d %s\n", element, v4, v7);
      }
      for ( n = 0; n <= 0x1A; ++n )
      {
        if ( !strcasecomp(element, table_10468[n].name) )
        {
          parse_attributes(mono, fg, bg, table_10468[n].style, table_10468[n].name);
          if ( table_10468[n].set_hash )
          {
            set_hash = table_10468[n].set_hash;
            *set_hash = hash_code(table_10468[n].name);
          }
          found = 1;
          break;
        }
      }
      if ( found )
      {
        if ( !strcasecomp(element, "normal") )
        {
          parse_attributes(mono, fg, bg, 128, "html");
          s_normal = hash_code("html");
          LYnormalColor();
        }
      }
      else
      {
        element_number = -1;
        t = SGMLFindTag(&HTML_dtd, element);
        if ( t && t->name )
          element_number = -1227133513 * (((char *)t - (char *)HTML_dtd.tags) >> 3);
        if ( element_number < 0 || element_number > 117 )
          parse_attributes(mono, fg, bg, 133, element);
        else
          parse_attributes(mono, fg, bg, element_number + 8, element);
      }
      if ( buffer )
        free(buffer);
    }
  }
}

//----- (080EB3BE) --------------------------------------------------------
void style_deleteStyleList()
{
  LYFreeStringList(lss_styles);
  lss_styles = 0;
}

//----- (080EB3DD) --------------------------------------------------------
void free_colorstylestuff()
{
  style_initialiseHashTable();
  style_deleteStyleList();
  memset(our_pairs, 0, sizeof(our_pairs));
  FreeCachedStyles();
}

//----- (080EB410) --------------------------------------------------------
void initialise_default_stylesheet()
{
  FILE *v0; // eax
  char *value; // [esp+20h] [ebp-18h]
  char *name; // [esp+24h] [ebp-14h] BYREF
  int code; // [esp+28h] [ebp-10h]
  char *strong; // [esp+2Ch] [ebp-Ch]
  char *normal; // [esp+30h] [ebp-8h]
  unsigned int n; // [esp+34h] [ebp-4h]

  normal = LYgetTableString(0);
  strong = LYgetTableString(4);
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 || WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    v0 = TraceFP();
    fprintf(v0, "initialise_default_stylesheet\n");
  }
  for ( n = 0; HTML_dtd.number_of_tags > n; ++n )
  {
    name = 0;
    HTSprintf0(&name, "%s:%s", HTML_dtd.tags[n].name, normal);
    parse_style(name);
    if ( name )
    {
      free(name);
      name = 0;
    }
  }
  for ( n = 0; n <= 0x1A; ++n )
  {
    code = table2_10585[n].color;
    name = 0;
    if ( code )
    {
      if ( code == 4 )
      {
        value = strong;
        HTSprintf0(&name, "%s:%s", table2_10585[n].type, strong);
      }
      else
      {
        value = LYgetTableString(code);
        HTSprintf0(&name, "%s:%s", table2_10585[n].type, value);
      }
    }
    else
    {
      value = normal;
      HTSprintf0(&name, "%s:%s", table2_10585[n].type, normal);
    }
    parse_style(name);
    if ( name )
    {
      free(name);
      name = 0;
    }
    if ( value != normal && value != strong && value )
      free(value);
  }
  if ( normal )
  {
    free(normal);
    normal = 0;
  }
  if ( strong )
    free(strong);
}

//----- (080EB5FD) --------------------------------------------------------
void style_initialiseHashTable()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0x2000; ++i )
  {
    if ( firsttime_10655 )
    {
      hashStyles[i].name = 0;
    }
    else if ( hashStyles[i].name )
    {
      free(hashStyles[i].name);
      hashStyles[i].name = 0;
    }
    hashStyles[i].color = 0;
    hashStyles[i].cattr = 0;
    hashStyles[i].mono = 0;
  }
  if ( firsttime_10655 )
    firsttime_10655 = 0;
  s_alink = hash_code("alink");
  s_a = hash_code("a");
  s_status = hash_code("status");
  s_alert = hash_code("alert");
  s_title = hash_code("title");
  s_sb_bar = hash_code("scroll.bar");
  s_sb_bg = hash_code("scroll.back");
  s_sb_aa = hash_code("scroll.arrow");
  s_sb_naa = hash_code("scroll.noarrow");
}

//----- (080EB77B) --------------------------------------------------------
void parse_userstyles()
{
  FILE *v0; // eax
  char *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+20h] [ebp-8h]

  cur = lss_styles;
  colorPairs = 0;
  style_initialiseHashTable();
  if ( cur && cur->next )
  {
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (char *)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        v0 = TraceFP();
        fprintf(v0, "LSS:%s\n", object);
      }
      parse_style(object);
    }
  }
  else
  {
    initialise_default_stylesheet();
  }
  if ( s_prompt_edit == -1 )
    s_prompt_edit = s_normal;
  if ( s_prompt_edit_arr == -1 )
    s_prompt_edit_arr = s_prompt_edit;
  if ( s_prompt_edit_pad == -1 )
    s_prompt_edit_pad = s_prompt_edit;
  if ( s_prompt_sel == -1 )
    s_prompt_sel = s_prompt_edit;
  if ( s_aedit == -1 )
    s_aedit = s_alink;
  if ( s_aedit_arr == -1 )
    s_aedit_arr = s_aedit;
  if ( s_aedit_pad == -1 )
    s_aedit_pad = s_aedit;
  if ( s_curedit == -1 )
    s_curedit = s_aedit;
  if ( s_aedit_sel == -1 )
    s_aedit_sel = s_aedit;
  if ( s_menu_bg == -1 )
    s_menu_bg = s_normal;
  if ( s_menu_entry == -1 )
    s_menu_entry = s_menu_bg;
  if ( s_menu_frame == -1 )
    s_menu_frame = s_menu_bg;
  if ( s_menu_number == -1 )
    s_menu_number = s_menu_bg;
  if ( s_menu_active == -1 )
    s_menu_active = s_alink;
}
// 80EB7CD: conditional instruction was optimized away because %var_14.4!=0
// 80EB800: conditional instruction was optimized away because %var_14.4!=0

//----- (080EB95D) --------------------------------------------------------
void __cdecl HStyle_addStyle(char *buffer)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  char *v4; // [esp+1Ch] [ebp-1Ch]
  const char *v5; // [esp+20h] [ebp-18h]
  char *v6; // [esp+24h] [ebp-14h]
  char *name; // [esp+34h] [ebp-4h] BYREF

  name = 0;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 || WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "HStyle_addStyle(%s)\n", buffer);
  }
  HTSACopy(&name, buffer);
  TrimLowercase(name);
  if ( !lss_styles )
    lss_styles = HTList_new();
  if ( strncasecomp(name, "default:", 8) )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      if ( name )
        v6 = name;
      else
        v6 = "!?! empty !?!";
      v3 = TraceFP();
      fprintf(v3, "READCSS:%s\n", v6);
    }
    HTList_addObject(lss_styles, name);
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      if ( name )
        v4 = name;
      else
        v4 = "!?! empty !?!";
      if ( default_color_reset[0] )
        v5 = ".ignore";
      else
        v5 = (const char *)&unk_816F168;
      v2 = TraceFP();
      fprintf(v2, "READCSS.default%s:%s\n", v5, v4);
    }
    if ( !default_color_reset[0] )
      parse_style(name);
  }
}

//----- (080EBAF0) --------------------------------------------------------
int __cdecl style_readFromFileREC(char *lss_filename, char *parent_filename)
{
  FILE *v2; // eax
  FILE *v3; // eax
  char *v4; // edx
  char *v6; // [esp+10h] [ebp-18h]
  char *buffer; // [esp+20h] [ebp-8h] BYREF
  FILE *fh; // [esp+24h] [ebp-4h]

  buffer = 0;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    if ( lss_filename )
      v6 = lss_filename;
    else
      v6 = "?!? empty ?!?";
    v2 = TraceFP();
    fprintf(v2, "CSS:Reading styles from file: %s\n", v6);
  }
  if ( !lss_filename || !*lss_filename )
    return -1;
  fh = LYOpenCFG(lss_filename, parent_filename, "/etc/lynx-cur/lynx.lss");
  if ( fh )
  {
    if ( !parent_filename )
      free_colorstylestuff();
    while ( LYSafeGets(&buffer, fh) )
    {
      LYTrimTrailing(buffer);
      LYTrimTail(buffer);
      LYTrimHead(buffer);
      if ( strncasecomp(buffer, "include:", 8) )
      {
        if ( *buffer != 35 && (int)strlen(buffer) > 0 )
          HStyle_addStyle(buffer);
      }
      else
      {
        v4 = LYSkipBlanks(buffer + 8);
        style_readFromFileREC(v4, lss_filename);
      }
    }
    LYCloseInput(fh);
    if ( !parent_filename && LYCursesON[0] )
      parse_userstyles();
    return 0;
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "CSS:Can't open style file '%s', using defaults\n", lss_filename);
    }
    return -1;
  }
}

//----- (080EBCAC) --------------------------------------------------------
int __cdecl style_readFromFile(char *filename)
{
  return style_readFromFileREC(filename, 0);
}

//----- (080EBCC7) --------------------------------------------------------
void __cdecl TrimColorClass(const char *tagname, char *styleclassname, int *phcode)
{
  char *string; // [esp+18h] [ebp-60h]
  const char *lookfrom; // [esp+28h] [ebp-50h]
  char *start; // [esp+2Ch] [ebp-4Ch]
  char *end; // [esp+30h] [ebp-48h]
  char tmp[64]; // [esp+34h] [ebp-44h] BYREF
  unsigned int v8; // [esp+74h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  start = 0;
  sprintf(tmp, ";%.*s", 61, tagname);
  TrimLowercase(tmp);
  lookfrom = styleclassname;
  if ( styleclassname )
  {
    do
    {
      end = start;
      start = strstr(lookfrom, tmp);
      if ( start )
        lookfrom = start + 1;
    }
    while ( start );
    if ( end )
      *end = 0;
  }
  if ( lookfrom && *lookfrom )
    string = (char *)lookfrom;
  else
    string = &tmp[1];
  *phcode = hash_code(string);
}

//----- (080EBDAC) --------------------------------------------------------
void __cdecl FastTrimColorClass(
        const char *tag_name,
        int name_len,
        char *stylename,
        char **pstylename_end,
        int *phcode)
{
  FILE *v5; // edx
  FILE *v6; // eax
  char *format; // [esp+14h] [ebp-14h]
  char *tag_start; // [esp+20h] [ebp-8h]
  BOOLEAN found; // [esp+27h] [ebp-1h]

  tag_start = *pstylename_end;
  found = 0;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    v5 = TraceFP();
    fprintf(v5, "STYLE.fast-trim: [%s] from [%s]: ", tag_name, stylename);
  }
  while ( tag_start >= stylename )
  {
    while ( tag_start >= stylename && *tag_start != 59 )
      --tag_start;
    if ( !strncasecomp(tag_start + 1, tag_name, name_len) )
    {
      found = 1;
      break;
    }
    --tag_start;
  }
  if ( found )
  {
    *tag_start = 0;
    *pstylename_end = tag_start;
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
  {
    if ( found )
      format = "success.\n";
    else
      format = "failed.\n";
    v6 = TraceFP();
    fprintf(v6, format);
  }
  *phcode = hash_code(tag_start + 1);
}

//----- (080EBEB4) --------------------------------------------------------
void cache_tag_styles()
{
  int i; // [esp+14h] [ebp-D4h]
  char buf[200]; // [esp+18h] [ebp-D0h] BYREF
  unsigned int v2; // [esp+E0h] [ebp-8h]

  v2 = __readgsdword(0x14u);
  for ( i = 0; i <= 117; ++i )
  {
    LYstrncpy(buf, HTML_dtd.tags[i].name, 199);
    LYLowerCase(buf);
    cached_tag_styles[i] = hash_code(buf);
  }
}

//----- (080EBF63) --------------------------------------------------------
unsigned int *__cdecl RefCachedStyle(int y, int x)
{
  unsigned int *result; // [esp+14h] [ebp-4h]

  result = 0;
  if ( !cached_styles_ptr )
  {
    cached_styles_rows = display_lines;
    cached_styles_cols = LYcols;
    cached_styles_ptr = calloc(display_lines * LYcols, 4u);
  }
  if ( y >= 0 && x >= 0 && y < cached_styles_rows && x < cached_styles_cols )
    return (unsigned int *)((char *)cached_styles_ptr + 4 * y * cached_styles_cols + 4 * x);
  return result;
}

//----- (080EBFF5) --------------------------------------------------------
BOOLEAN __cdecl ValidCachedStyle(int y, int x)
{
  return RefCachedStyle(y, x) != 0;
}

//----- (080EC014) --------------------------------------------------------
unsigned int __cdecl GetCachedStyle(int y, int x)
{
  unsigned int *cache; // [esp+10h] [ebp-8h]
  unsigned int value; // [esp+14h] [ebp-4h]

  value = 0;
  cache = RefCachedStyle(y, x);
  if ( cache )
    return *cache;
  return value;
}

//----- (080EC049) --------------------------------------------------------
void __cdecl SetCachedStyle(int y, int x, unsigned int value)
{
  unsigned int *cache; // [esp+14h] [ebp-4h]

  cache = RefCachedStyle(y, x);
  if ( cache )
    *cache = value;
}

//----- (080EC074) --------------------------------------------------------
void ResetCachedStyles()
{
  if ( cached_styles_ptr )
    memset(cached_styles_ptr, 0, 4 * cached_styles_rows * cached_styles_cols);
}

//----- (080EC0B0) --------------------------------------------------------
void FreeCachedStyles()
{
  if ( cached_styles_ptr )
  {
    free(cached_styles_ptr);
    cached_styles_ptr = 0;
    cached_styles_rows = 0;
    cached_styles_cols = 0;
  }
}

//----- (080EC0F8) --------------------------------------------------------
int __cdecl hash_code(const char *string)
{
  int hash; // [esp+10h] [ebp-8h]

  hash = 0;
  while ( *string )
    hash = (3 * hash + *(unsigned __int8 *)string++) % 8193;
  return hash;
}

//----- (080EC16B) --------------------------------------------------------
int __cdecl hash_code_lowercase_on_fly(const char *string)
{
  int v2; // [esp+10h] [ebp-18h]
  int hash; // [esp+20h] [ebp-8h]

  hash = 0;
  while ( *string )
  {
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)string] & 0x100) != 0 )
      v2 = (unsigned __int8)tolower(*(unsigned __int8 *)string);
    else
      v2 = *(unsigned __int8 *)string;
    hash = (v2 + 3 * hash) % 8193;
    ++string;
  }
  return hash;
}

//----- (080EC22A) --------------------------------------------------------
int __cdecl hash_code_aggregate_char(char c, int hash)
{
  return (3 * hash + (unsigned __int8)c) % 8193;
}

//----- (080EC27F) --------------------------------------------------------
int __cdecl hash_code_aggregate_lower_str(const char *string, int hash_was)
{
  int v3; // [esp+10h] [ebp-18h]

  while ( *string )
  {
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)string] & 0x100) != 0 )
      v3 = (unsigned __int8)tolower(*(unsigned __int8 *)string);
    else
      v3 = *(unsigned __int8 *)string;
    hash_was = (v3 + 3 * hash_was) % 8193;
    ++string;
  }
  return hash_was;
}

//----- (080EC340) --------------------------------------------------------
int __cdecl html_src_tag_index(char *tagname)
{
  HTTag *tag; // [esp+24h] [ebp-4h]

  tag = SGMLFindTag(&HTML_dtd, tagname);
  if ( !tag || tag == &HTTag_unrecognized )
    return -1;
  else
    return -1227133513 * (((char *)tag - (char *)HTML_dtd.tags) >> 3);
}

//----- (080EC393) --------------------------------------------------------
void __cdecl append_close_tag(char *tagname, HT_tagspec **head, HT_tagspec **tail)
{
  HT_tagspec *subj; // [esp+18h] [ebp-10h]
  size_t nattr; // [esp+20h] [ebp-8h]
  int idx; // [esp+24h] [ebp-4h]

  idx = html_src_tag_index(tagname);
  nattr = HTML_dtd.tags[idx].number_of_attributes;
  if ( idx == -1 )
  {
    fprintf(stderr, "internal error: previous check didn't find bad HTML tag %s", tagname);
    exit_immediately(1);
  }
  subj = (HT_tagspec *)calloc(1u, 0x1Cu);
  subj->element = idx;
  subj->present = (BOOLEAN *)calloc(nattr, 1u);
  subj->value = (char **)calloc(nattr, 4u);
  subj->start = 0;
  subj->class_name = 0;
  if ( *head )
    (*tail)->next = subj;
  else
    *head = subj;
  *tail = subj;
}

//----- (080EC494) --------------------------------------------------------
void __cdecl append_open_tag(char *tagname, char *classname, HT_tagspec **head, HT_tagspec **tail)
{
  int v4; // [esp+4h] [ebp-24h]
  int hcode; // [esp+1Ch] [ebp-Ch]
  HT_tagspec *subj; // [esp+24h] [ebp-4h]

  append_close_tag(tagname, head, tail);
  subj = *tail;
  (*tail)->start = 1;
  hcode = hash_code_lowercase_on_fly(tagname);
  if ( classname && *classname )
  {
    v4 = hash_code_aggregate_char(46, hcode);
    hcode = hash_code_aggregate_lower_str(classname, v4);
    HTSACopy(&subj->class_name, classname);
  }
  else
  {
    HTSACopy(&subj->class_name, &byte_816F697);
  }
  subj->style = hcode;
}

//----- (080EC565) --------------------------------------------------------
int __cdecl html_src_parse_tagspec(char *ts, HTlexeme lexeme, BOOLEAN checkonly, BOOLEAN isstart)
{
  int v4; // ebx
  FILE *v5; // edx
  int v6; // ebx
  FILE *v7; // edx
  FILE *v8; // eax
  int v9; // ebx
  FILE *v10; // edx
  int v11; // ebx
  int v12; // esi
  FILE *v13; // edx
  int v14; // ebx
  FILE *v15; // edx
  int v16; // ebx
  FILE *v17; // edx
  HT_tagspec **v19; // [esp+24h] [ebp-64h]
  int v20; // [esp+28h] [ebp-60h]
  int v21; // [esp+2Ch] [ebp-5Ch]
  int v22; // [esp+30h] [ebp-58h]
  int idx_0; // [esp+4Ch] [ebp-3Ch]
  int idx; // [esp+50h] [ebp-38h]
  HT_tagspec *tail; // [esp+58h] [ebp-30h] BYREF
  HT_tagspec *head; // [esp+5Ch] [ebp-2Ch] BYREF
  html_src_check_state state; // [esp+60h] [ebp-28h]
  char *classend; // [esp+64h] [ebp-24h]
  char *classstart; // [esp+68h] [ebp-20h]
  char *tagend; // [esp+6Ch] [ebp-1Ch]
  char *tagstart; // [esp+70h] [ebp-18h]
  char *p; // [esp+74h] [ebp-14h]
  char after_excl; // [esp+7Bh] [ebp-Dh]
  char save1; // [esp+7Ch] [ebp-Ch]
  char save; // [esp+7Dh] [ebp-Bh]
  BOOLEAN code; // [esp+7Eh] [ebp-Ah]
  BOOLEAN stop; // [esp+7Fh] [ebp-9h]

  stop = 0;
  code = 0;
  p = ts;
  tagstart = 0;
  tagend = 0;
  after_excl = 0;
  state = HTSRC_CK_normal;
  head = 0;
  tail = 0;
  if ( isstart )
    v19 = lexeme_start;
  else
    v19 = lexeme_end;
  while ( !stop )
  {
    if ( state == HTSRC_CK_after_tagname )
    {
      v21 = *p;
      if ( v21 == 32 )
        goto LABEL_42;
      if ( v21 <= 32 )
      {
        if ( *p )
        {
          if ( v21 != 9 )
            goto LABEL_58;
        }
        else
        {
          stop = 1;
          code = 1;
        }
LABEL_42:
        save = *tagend;
        *tagend = 0;
        classstart = 0;
        if ( checkonly )
        {
          idx = html_src_tag_index(tagstart);
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
          {
            v8 = TraceFP();
            fprintf(v8, "tag index(%s) = %d\n", tagstart, idx);
          }
          *tagend = save;
          if ( idx == -1 )
          {
            stop = 1;
            goto LABEL_85;
          }
        }
        else if ( after_excl )
        {
          append_close_tag(tagstart, &head, &tail);
        }
        else
        {
          append_open_tag(tagstart, 0, &head, &tail);
        }
        state = HTSRC_CK_normal;
        after_excl = 0;
        goto LABEL_85;
      }
      if ( v21 != 46 )
      {
LABEL_58:
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
        {
          v11 = p + 1 - ts;
          v12 = *p;
          v13 = TraceFP();
          fprintf(v13, "unexpected char '%c' after tagname at column %d:\n\t%s\n", v12, v11, ts);
        }
        stop = 1;
        goto LABEL_85;
      }
      if ( after_excl )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
        {
          v9 = p + 1 - ts;
          v10 = TraceFP();
          fprintf(v10, "dot after '!' at column %d:\n\t%s\n", v9, ts);
        }
        stop = 1;
      }
      else
      {
        state = HTSRC_CK_seen_dot;
      }
    }
    else if ( (unsigned int)state < HTSRC_CK_after_tagname )
    {
      v20 = *p;
      if ( v20 == 32 )
        goto LABEL_85;
      if ( v20 <= 32 )
      {
        if ( !*p )
        {
          stop = 1;
          code = 1;
          goto LABEL_85;
        }
        if ( v20 == 9 )
          goto LABEL_85;
LABEL_22:
        if ( ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x400) != 0 || *p == 95 )
        {
          tagstart = p;
          while ( *p && (((*__ctype_b_loc())[(unsigned __int8)*p] & 8) != 0 || *p == 95) )
            ++p;
          tagend = p--;
          state = HTSRC_CK_after_tagname;
        }
        else
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
          {
            v6 = p + 1 - ts;
            v7 = TraceFP();
            fprintf(v7, "no name starting at column %d:\n\t%s\n", v6, ts);
          }
          stop = 1;
        }
        goto LABEL_85;
      }
      if ( v20 != 33 )
        goto LABEL_22;
      if ( state == HTSRC_CK_seen_excl )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
        {
          v4 = p + 1 - ts;
          v5 = TraceFP();
          fprintf(v5, "second '!' at column %d:\n\t%s\n", v4, ts);
        }
        stop = 1;
      }
      else
      {
        state = HTSRC_CK_seen_excl;
        after_excl = 1;
      }
    }
    else if ( state == HTSRC_CK_seen_dot )
    {
      v22 = *p;
      if ( v22 != 9 && v22 != 32 )
      {
        if ( *p )
        {
          if ( ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x400) != 0 || *p == 95 )
          {
            classstart = p;
            while ( *p && (((*__ctype_b_loc())[(unsigned __int8)*p] & 8) != 0 || *p == 95) )
              ++p;
            classend = p--;
            save = *classend;
            *classend = 0;
            save1 = *tagend;
            *tagend = 0;
            if ( checkonly )
            {
              idx_0 = html_src_tag_index(tagstart);
              *tagend = save1;
              *classend = save;
              if ( idx_0 == -1 )
                return 0;
            }
            else
            {
              append_open_tag(tagstart, classstart, &head, &tail);
            }
            state = HTSRC_CK_normal;
            after_excl = 0;
          }
          else
          {
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
            {
              v16 = p + 1 - ts;
              v17 = TraceFP();
              fprintf(v17, "no name starting at column %d:\n\t%s\n", v16, ts);
            }
            stop = 1;
          }
        }
        else
        {
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
          {
            v14 = p + 1 - ts;
            v15 = TraceFP();
            fprintf(v15, "expected text after dot at column %d:\n\t%s\n", v14, ts);
          }
          stop = 1;
        }
      }
    }
LABEL_85:
    ++p;
  }
  if ( code && !checkonly )
    v19[lexeme] = head;
  return code;
}

//----- (080ECB4D) --------------------------------------------------------
void __cdecl html_src_clean_item(HTlexeme l)
{
  HT_tagspec **v1; // [esp+4h] [ebp-14h]
  HT_tagspec *ts; // [esp+8h] [ebp-10h]
  HT_tagspec *cur; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( HTL_tagspecs[l] )
  {
    free(HTL_tagspecs[l]);
    HTL_tagspecs[l] = 0;
  }
  for ( i = 0; i <= 1; ++i )
  {
    if ( i )
      v1 = lexeme_start;
    else
      v1 = lexeme_end;
    ts = v1[l];
    v1[l] = 0;
    while ( ts )
    {
      if ( ts->present )
      {
        free(ts->present);
        ts->present = 0;
      }
      if ( ts->value )
      {
        free(ts->value);
        ts->value = 0;
      }
      if ( ts->start )
      {
        if ( ts->class_name )
        {
          free(ts->class_name);
          ts->class_name = 0;
        }
      }
      cur = ts;
      ts = ts->next;
      free(cur);
    }
  }
}
// 80ECC56: conditional instruction was optimized away because %cur.4!=0

//----- (080ECC84) --------------------------------------------------------
void html_src_clean_data()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 11; ++i )
    html_src_clean_item((HTlexeme)i);
}

//----- (080ECCAA) --------------------------------------------------------
void html_src_on_lynxcfg_reload()
{
  html_src_clean_data();
  HTMLSRC_init_caches(1);
}

//----- (080ECCC3) --------------------------------------------------------
void __cdecl __noreturn failed_init(const char *tag, int lexeme)
{
  char *v2; // edx
  char *v3; // eax

  v2 = gettext("parse-error while caching %s tagspec of lexeme %d\n");
  fprintf(stderr, v2, tag, lexeme);
  v3 = gettext("Use -trace -trace-mask=8 to see details in log.\n");
  fprintf(stderr, v3);
  exit_immediately(1);
}

//----- (080ECD23) --------------------------------------------------------
void __cdecl HTMLSRC_init_caches(BOOLEAN dont_exit)
{
  FILE *v1; // eax
  FILE *v2; // eax
  char *ts; // [esp+1Ch] [ebp-40Ch]
  char *p; // [esp+30h] [ebp-3F8h]
  int i; // [esp+34h] [ebp-3F4h]
  char buf[1000]; // [esp+38h] [ebp-3F0h] BYREF
  unsigned int v7; // [esp+420h] [ebp-8h]

  v7 = __readgsdword(0x14u);
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "HTMLSRC_init_caches(%d tagspecs)\n", 12);
  }
  for ( i = 0; i <= 11; ++i )
  {
    if ( HTL_tagspecs[i] )
      LYstrncpy(buf, HTL_tagspecs[i], 999);
    else
      LYstrncpy(buf, HTL_tagspecs_defaults[i], 999);
    HTSACopy(&HTL_tagspecs[i], buf);
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
    {
      v2 = TraceFP();
      fprintf(v2, "parsing lexeme %d: %s\n", i + 1, buf);
    }
    p = strchr(buf, 58);
    if ( p )
      *p = 0;
    if ( !html_src_parse_tagspec(buf, (HTlexeme)i, 0, 1) && !dont_exit )
      failed_init("1st", i);
    if ( p )
      ts = p + 1;
    else
      ts = 0;
    if ( !html_src_parse_tagspec(ts, (HTlexeme)i, 0, 0) && !dont_exit )
      failed_init("2nd", i);
  }
}

//----- (080ECF6C) --------------------------------------------------------
const char *__cdecl cellstate_s(cellstate_t state)
{
  const char *result; // [esp+10h] [ebp-4h]

  result = "?";
  switch ( state )
  {
    case CS_invalid:
      result = "CS_invalid";
      break;
    case CS__new:
      result = "CS__new";
      break;
    case CS__0new:
      result = "CS__0new";
      break;
    case CS__0eb:
      result = "CS__0eb";
      break;
    case CS__eb:
      result = "CS__eb";
      break;
    case CS__0cb:
      result = "CS__0cb";
      break;
    case CS__cb:
      result = "CS__cb";
      break;
    case CS__0ef:
      result = "CS__0ef";
      break;
    case CS__ef:
      result = "CS__ef";
      break;
    case CS__0cf:
      result = "CS__0cf";
      break;
    case CS__cf:
      result = "CS__cf";
      break;
    case CS__ebc:
      result = "CS__ebc";
      break;
    case CS__cbc:
      result = "CS__cbc";
      break;
    default:
      return result;
  }
  return result;
}

//----- (080ED00C) --------------------------------------------------------
STable_info *__cdecl Stbl_startTABLE(__int16 alignment)
{
  FILE *v1; // eax
  STable_info *me; // [esp+20h] [ebp-8h]

  me = (STable_info *)calloc(1u, 0x78u);
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "TRST:Stbl_startTABLE(align=%d)\n", alignment);
  }
  if ( me )
  {
    me->alignment = alignment;
    me->rowgroup_align = -1;
    me->pending_colgroup_align = -1;
    me->s.x_td = -1;
    me->s.icell_core = -1;
    if ( nested_tables )
      me->enclosing = 0;
  }
  return me;
}

//----- (080ED0BB) --------------------------------------------------------
void __cdecl free_rowinfo(STable_rowinfo *me)
{
  if ( me && me->allocated )
  {
    if ( me->cells )
    {
      free(me->cells);
      me->cells = 0;
    }
  }
}

//----- (080ED0F5) --------------------------------------------------------
void __cdecl Stbl_free(STable_info *me)
{
  FILE *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "TRST:Stbl_free()\n");
  }
  if ( me )
  {
    if ( me->allocated_rows )
    {
      if ( me->rows )
      {
        for ( i = 0; me->allocated_rows > i; ++i )
          free_rowinfo(&me->rows[i]);
        if ( me->rows )
        {
          free(me->rows);
          me->rows = 0;
        }
      }
    }
  }
  free_rowinfo(&me->rowspans2eog);
  if ( me && me->sumcols )
  {
    free(me->sumcols);
    me->sumcols = 0;
  }
  if ( me )
    free(me);
}

//----- (080ED1EB) --------------------------------------------------------
int __cdecl Stbl_addCellToRow(
        STable_rowinfo *me,
        STable_cellinfo *colinfo,
        int ncolinfo,
        STable_states *s,
        int colspan,
        int alignment,
        int isheader,
        int lineno,
        int *ppos)
{
  int v9; // ebx
  FILE *v10; // edx
  const char *v11; // ebx
  int pending_len; // esi
  int v13; // edi
  FILE *v14; // eax
  const char *v15; // ebx
  const char *v16; // esi
  FILE *v17; // edx
  unsigned __int32 v19; // [esp+30h] [ebp-48h]
  int v20; // [esp+34h] [ebp-44h]
  const char *v21; // [esp+38h] [ebp-40h]
  int ncells; // [esp+3Ch] [ebp-3Ch]
  int v23; // [esp+48h] [ebp-30h]
  int growby; // [esp+54h] [ebp-24h]
  int ret; // [esp+58h] [ebp-20h]
  _BOOL4 newstate; // [esp+5Ch] [ebp-1Ch]
  int i; // [esp+64h] [ebp-14h]
  int ia; // [esp+64h] [ebp-14h]
  int ib; // [esp+64h] [ebp-14h]
  STable_cellinfo *cells; // [esp+68h] [ebp-10h]

  if ( me->ncells )
    v20 = me->cells[me->ncells - 1].colspan;
  else
    v20 = 1;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v9 = *ppos;
    v10 = TraceFP();
    fprintf(v10, "TRST:Stbl_addCellToRow, line=%d, pos=%d, colspan=%d\n", lineno, v9, colspan);
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v21 = cellstate_s(s->state);
    v11 = cellstate_s(s->prev_state);
    pending_len = s->pending_len;
    v13 = s->lineno;
    ncells = me->ncells;
    v14 = TraceFP();
    fprintf(v14, " ncells=%d, stateLine=%d, pending_len=%d, pstate=%s, state=%s\n", ncells, v13, pending_len, v11, v21);
  }
  if ( me->ncells )
  {
    if ( s->prev_state == CS_invalid || s->state != CS__0new && s->state != CS__ef && s->state != CS__0ef )
      s->prev_state = s->state;
  }
  else
  {
    s->prev_state = CS_invalid;
  }
  newstate = !me->ncells || !*ppos;
  if ( me->ncells > 0 && s->pending_len > 0 )
  {
    if ( s->prev_state != CS__cbc )
      me->cells[me->ncells - 1].len = s->pending_len;
    s->pending_len = 0;
  }
  s->x_td = *ppos;
  if ( s->lineno == lineno )
  {
    switch ( s->prev_state )
    {
      case CS__new:
      case CS__cf:
        if ( me->fixed_line && me->Line != lineno )
          goto trace_and_fail;
        me->fixed_line = 1;
        me->Line = lineno;
        break;
      default:
        break;
    }
  }
  else
  {
    if ( !me->fixed_line )
    {
      if ( me->ncells && *ppos )
      {
        switch ( s->prev_state )
        {
          case CS__0new:
          case CS__0eb:
          case CS__0ef:
            goto LABEL_45;
          case CS__0cb:
          case CS__0cf:
            if ( *ppos > me->cells->pos )
              me->Line = lineno;
            me->fixed_line = 1;
            goto LABEL_45;
          case CS__cb:
          case CS__cf:
          case CS__cbc:
            goto trace_and_fail;
          default:
            me->fixed_line = 1;
            goto LABEL_45;
        }
      }
      v19 = s->prev_state + 1;
      if ( v19 <= 9 )
      {
        if ( ((1 << v19) & 0x2AD) != 0 )
        {
          if ( me->ncells > 0 )
          {
            for ( i = v20 + me->ncells - 2; me->ncells - 1 <= i; --i )
            {
              me->cells[i].pos = *ppos;
              me->cells[i].cLine = lineno;
            }
          }
          me->Line = lineno;
        }
        else if ( ((1 << v19) & 0x40) != 0 )
        {
          *ppos = me->cells[me->ncells - 1].pos + me->cells[me->ncells - 1].len;
        }
      }
    }
LABEL_45:
    if ( me->fixed_line && me->Line != lineno )
    {
      switch ( s->prev_state )
      {
        case CS_invalid:
        case CS__0new:
        case CS__0eb:
        case CS__0ef:
        case CS__cbc:
          break;
        case CS__0cb:
        case CS__0cf:
          if ( !*ppos || *ppos <= me->cells->pos )
            *ppos = me->cells[me->ncells - 1].pos + me->cells[me->ncells - 1].len;
          break;
        case CS__cb:
        case CS__cf:
          if ( *ppos > 0 )
            goto trace_and_fail;
          *ppos = me->cells[me->ncells - 1].pos + me->cells[me->ncells - 1].len;
          break;
        default:
          *ppos = me->cells[me->ncells - 1].pos;
          break;
      }
    }
    s->lineno = lineno;
  }
  s->state = newstate;
  if ( me->ncells > 0 && me->cells[me->ncells - 1].colspan > 1 )
    me->ncells += me->cells[me->ncells - 1].colspan - 1;
  while ( me->ncells < me->allocated && me->cells[me->ncells].alignment == -2 )
    ++me->ncells;
  for ( growby = 0; colspan + me->ncells + 1 > growby + me->allocated; growby += 16 )
    ;
  if ( growby )
  {
    if ( me->allocated || me->cells )
    {
      cells = (STable_cellinfo *)realloc(me->cells, 20 * (growby + me->allocated));
      for ( ia = 0; cells && ia < growby; ++ia )
        cells[ia + me->allocated].alignment = -1;
    }
    else
    {
      cells = (STable_cellinfo *)calloc(growby, 0x14u);
    }
    if ( !cells )
    {
trace_and_fail:
      ret = -1;
      goto trace_and_return;
    }
    me->allocated += growby;
    me->cells = cells;
  }
  me->cells[me->ncells].cLine = lineno;
  me->cells[me->ncells].pos = *ppos;
  me->cells[me->ncells].len = -1;
  me->cells[me->ncells].colspan = colspan;
  if ( alignment == -1 )
  {
    if ( me->ncells + 1 > ncolinfo )
      me->cells[me->ncells].alignment = me->alignment;
    else
      me->cells[me->ncells].alignment = colinfo[me->ncells].alignment;
    if ( me->cells[me->ncells].alignment == -1 )
      me->cells[me->ncells].alignment = me->alignment;
    if ( me->cells[me->ncells].alignment == -1 )
    {
      if ( isheader )
        v23 = 3;
      else
        v23 = 1;
      me->cells[me->ncells].alignment = v23;
    }
  }
  else
  {
    me->cells[me->ncells].alignment = alignment;
  }
  for ( ib = me->ncells + 1; colspan + me->ncells > ib; ++ib )
  {
    me->cells[ib].cLine = lineno;
    me->cells[ib].pos = *ppos;
    me->cells[ib].len = -1;
    me->cells[ib].colspan = 0;
    me->cells[ib].alignment = 1;
  }
  me->cells[colspan + me->ncells++].pos = -1;
  ret = me->ncells - 1;
trace_and_return:
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v15 = cellstate_s(s->state);
    v16 = cellstate_s(s->prev_state);
    v17 = TraceFP();
    fprintf(v17, " => prev_state=%s, state=%s, ret=%d\n", v16, v15, ret);
  }
  return ret;
}

//----- (080EDB6C) --------------------------------------------------------
int __cdecl Stbl_reserveCellsInRow(STable_rowinfo *me, int icell, int colspan)
{
  FILE *v3; // edx
  int growby; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int ia; // [esp+20h] [ebp-8h]
  STable_cellinfo *cells; // [esp+24h] [ebp-4h]

  growby = colspan + icell + 1 - me->allocated;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v3 = TraceFP();
    fprintf(v3, "TRST:Stbl_reserveCellsInRow(icell=%d, colspan=%d\n", icell, colspan);
  }
  if ( growby > 0 )
  {
    cells = (STable_cellinfo *)realloc(me->cells, 20 * (growby + me->allocated));
    if ( !cells )
      return -1;
    for ( i = 0; i < growby; ++i )
      cells[i + me->allocated].alignment = -1;
    me->allocated += growby;
    me->cells = cells;
  }
  for ( ia = icell; icell + colspan > ia; ++ia )
  {
    me->cells[ia].cLine = -1;
    me->cells[ia].pos = -1;
    me->cells[ia].len = -1;
    me->cells[ia].colspan = 0;
    me->cells[ia].alignment = -2;
  }
  me->cells[icell].colspan = colspan;
  return 0;
}

//----- (080EDD3B) --------------------------------------------------------
int __cdecl Stbl_finishCellInRow(STable_rowinfo *me, STable_states *s, int end_td, int lineno, int pos)
{
  int pending_len; // ebx
  int ncells; // esi
  FILE *v7; // edx
  const char *v8; // edi
  const char *v9; // ebx
  int cLine; // esi
  FILE *v11; // edx
  const char *v12; // ebx
  const char *v13; // esi
  FILE *v14; // edx
  _BOOL4 v17; // [esp+34h] [ebp-C4h]
  _BOOL4 v18; // [esp+38h] [ebp-C0h]
  int v19; // [esp+3Ch] [ebp-BCh]
  int v20; // [esp+40h] [ebp-B8h]
  int v21; // [esp+44h] [ebp-B4h]
  cellstate_t v22; // [esp+48h] [ebp-B0h]
  int v23; // [esp+4Ch] [ebp-ACh]
  int v24; // [esp+50h] [ebp-A8h]
  int v25; // [esp+54h] [ebp-A4h]
  cellstate_t v26; // [esp+58h] [ebp-A0h]
  int v27; // [esp+5Ch] [ebp-9Ch]
  int v28; // [esp+60h] [ebp-98h]
  int v29; // [esp+68h] [ebp-90h]
  int v30; // [esp+6Ch] [ebp-8Ch]
  int v31; // [esp+70h] [ebp-88h]
  cellstate_t v32; // [esp+74h] [ebp-84h]
  int v33; // [esp+78h] [ebp-80h]
  int v34; // [esp+7Ch] [ebp-7Ch]
  int v35; // [esp+80h] [ebp-78h]
  int v36; // [esp+84h] [ebp-74h]
  int v37; // [esp+88h] [ebp-70h]
  int v38; // [esp+90h] [ebp-68h]
  int v39; // [esp+94h] [ebp-64h]
  int v40; // [esp+98h] [ebp-60h]
  cellstate_t v41; // [esp+9Ch] [ebp-5Ch]
  cellstate_t v42; // [esp+A0h] [ebp-58h]
  int v43; // [esp+A4h] [ebp-54h]
  int v44; // [esp+A8h] [ebp-50h]
  int v45; // [esp+ACh] [ebp-4Ch]
  int v46; // [esp+B0h] [ebp-48h]
  int v47; // [esp+B4h] [ebp-44h]
  int v48; // [esp+B8h] [ebp-40h]
  int v49; // [esp+BCh] [ebp-3Ch]
  cellstate_t v50; // [esp+C0h] [ebp-38h]
  int len; // [esp+C4h] [ebp-34h]
  int v52; // [esp+C8h] [ebp-30h]
  int ret; // [esp+D8h] [ebp-20h]
  cellstate_t newstate; // [esp+E4h] [ebp-14h]
  STable_cellinfo *lastcell; // [esp+E8h] [ebp-10h]

  newstate = CS_invalid;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    pending_len = s->pending_len;
    ncells = me->ncells;
    v7 = TraceFP();
    fprintf(
      v7,
      "TRST:Stbl_finishCellInRow line=%d pos=%d end_td=%d ncells=%d pnd_len=%d\n",
      lineno,
      pos,
      end_td,
      ncells,
      pending_len);
  }
  if ( me->ncells <= 0 )
    return -1;
  lastcell = &me->cells[me->ncells - 1];
  v17 = lastcell->cLine != lineno || s->lineno != lineno;
  if ( v17 )
    v18 = pos == 0;
  else
    v18 = s->x_td >= pos;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v8 = cellstate_s(s->state);
    v9 = cellstate_s(s->prev_state);
    v19 = s->lineno;
    cLine = lastcell->cLine;
    v11 = TraceFP();
    fprintf(v11, " [lines: lastCell=%d state=%d multi=%d] empty=%d (prev)state=(%s) %s\n", cLine, v19, v17, v18, v9, v8);
  }
  if ( v17 )
  {
    if ( (end_td & 1) != 0 )
    {
      s->x_td = -1;
      switch ( s->state )
      {
        case CS_invalid:
          if ( !v18 && lastcell->len > 0 )
          {
            s->state = CS__0cf;
            ret = -1;
            goto trace_and_return;
          }
          lastcell->len = 0;
          lastcell->cLine = -1;
          if ( v18 )
            v30 = -1;
          else
            v30 = 11;
          newstate = v30;
          break;
        case CS__new:
          if ( v18 )
            v35 = 7;
          else
            v35 = 9;
          newstate = v35;
          break;
        case CS__0new:
          if ( v18 )
            v31 = 6;
          else
            v31 = 8;
          newstate = v31;
          break;
        case CS__0eb:
          if ( v18 )
            v32 = CS__0ef;
          else
            v32 = CS__0cf;
          s->state = v32;
          if ( me->fixed_line )
          {
            if ( v18 )
            {
              ret = lastcell->len & ~(lastcell->len >> 31);
            }
            else
            {
              if ( lastcell->len > 0 )
                v33 = -1;
              else
                v33 = 0;
              ret = v33;
            }
          }
          else if ( v18 )
          {
            ret = lastcell->len & ~(lastcell->len >> 31);
          }
          else
          {
            ret = 0;
          }
          goto trace_and_return;
        case CS__eb:
          s->state = CS__ef;
          if ( me->fixed_line )
          {
            if ( v18 )
            {
              ret = lastcell->len & ~(lastcell->len >> 31);
            }
            else
            {
              if ( lastcell->len > 0 )
                v36 = -1;
              else
                v36 = 0;
              ret = v36;
            }
          }
          else if ( v18 )
          {
            ret = lastcell->len & ~(lastcell->len >> 31);
          }
          else
          {
            if ( lastcell->len > 0 )
              v37 = -1;
            else
              v37 = 0;
            ret = v37;
          }
          goto trace_and_return;
        case CS__0cb:
          if ( s->pending_len )
          {
            if ( v18 )
              lastcell->len = s->pending_len;
            else
              lastcell->len = 0;
            s->pending_len = 0;
          }
          if ( !me->fixed_line )
          {
            if ( v18 )
            {
              if ( s->icell_core == -1 )
                s->icell_core = me->ncells - 1;
            }
            else if ( s->icell_core == -1 )
            {
              me->Line = -1;
            }
          }
          if ( s->pending_len && v18 )
          {
            lastcell->len = s->pending_len;
            s->pending_len = 0;
          }
          if ( v18 )
            v34 = 8;
          else
            v34 = 11;
          newstate = v34;
          break;
        case CS__cb:
          if ( s->pending_len && v18 )
          {
            lastcell->len = s->pending_len;
            s->pending_len = 0;
          }
          ret = -1;
          if ( !v18 )
            goto trace_and_return;
          if ( me->fixed_line )
          {
            if ( me->Line != lastcell->cLine )
              goto trace_and_return;
          }
          else
          {
            me->fixed_line = 1;
            me->Line = lastcell->cLine;
          }
          newstate = CS__cf;
          break;
        case CS__0ef:
          newstate = CS__0ef;
          break;
        case CS__ebc:
          lastcell->len = 0;
          if ( !me->fixed_line && !v18 && s->icell_core == -1 )
            lastcell->cLine = -1;
          s->pending_len = 0;
          if ( v18 )
            v38 = -1;
          else
            v38 = 11;
          newstate = v38;
          break;
        case CS__cbc:
          lastcell->len = 0;
          ret = -1;
          if ( me->fixed_line && me->Line == lastcell->cLine )
            goto trace_and_return;
          if ( !me->fixed_line && v18 && s->icell_core == -1 )
            me->Line = lineno;
          s->pending_len = 0;
          if ( v18 )
            v39 = -1;
          else
            v39 = 11;
          newstate = v39;
          break;
        default:
          break;
      }
    }
    else
    {
      switch ( s->state )
      {
        case CS_invalid:
          if ( v18 )
            v20 = -1;
          else
            v20 = 11;
          newstate = v20;
          break;
        case CS__new:
          if ( v18 )
            v25 = 3;
          else
            v25 = 5;
          newstate = v25;
          break;
        case CS__0new:
          if ( v18 )
            v21 = 2;
          else
            v21 = 4;
          newstate = v21;
          break;
        case CS__0eb:
          if ( v18 )
            v22 = CS__0eb;
          else
            v22 = CS__ebc;
          s->state = v22;
          if ( me->fixed_line )
          {
            if ( v18 )
            {
              ret = lastcell->len & ~(lastcell->len >> 31);
            }
            else
            {
              if ( lastcell->len > 0 )
                v23 = -1;
              else
                v23 = 0;
              ret = v23;
            }
          }
          else if ( v18 )
          {
            ret = lastcell->len & ~(lastcell->len >> 31);
          }
          else
          {
            ret = 0;
          }
          goto trace_and_return;
        case CS__eb:
          if ( v18 )
            v26 = CS__eb;
          else
            v26 = CS__ebc;
          s->state = v26;
          if ( me->fixed_line )
          {
            if ( v18 )
            {
              ret = lastcell->len & ~(lastcell->len >> 31);
            }
            else
            {
              if ( lastcell->len > 0 )
                v27 = -1;
              else
                v27 = 0;
              ret = v27;
            }
          }
          else if ( v18 )
          {
            ret = lastcell->len & ~(lastcell->len >> 31);
          }
          else
          {
            if ( lastcell->len > 0 )
              v28 = -1;
            else
              v28 = 0;
            ret = v28;
          }
          goto trace_and_return;
        case CS__0cb:
          if ( !me->fixed_line && !v18 && s->icell_core == -1 )
            me->Line = -1;
          if ( s->pending_len && v18 )
          {
            if ( me->fixed_line && me->Line == lastcell->cLine || s->icell_core == me->ncells - 1 )
              lastcell->len = s->pending_len;
            s->pending_len = 0;
          }
          if ( v18 )
            v24 = 4;
          else
            v24 = 11;
          newstate = v24;
          break;
        case CS__cb:
          if ( s->pending_len && v18 )
          {
            lastcell->len = s->pending_len;
            s->pending_len = 0;
          }
          ret = -1;
          if ( !v18 )
          {
            if ( !me->fixed_line )
            {
              me->fixed_line = 1;
              me->Line = lastcell->cLine;
            }
            s->state = CS__cbc;
            goto trace_and_return;
          }
          if ( me->fixed_line )
          {
            if ( me->Line != lastcell->cLine )
              goto trace_and_return;
          }
          else
          {
            me->fixed_line = 1;
            me->Line = lastcell->cLine;
          }
          newstate = CS__cb;
          break;
        case CS__ef:
          ret = 0;
          goto trace_and_return;
        case CS__cf:
          ret = lastcell->len;
          goto trace_and_return;
        case CS__cbc:
          if ( !me->fixed_line )
          {
            if ( v18 )
            {
              if ( s->icell_core == -1 )
                me->Line = lineno;
            }
            else if ( s->icell_core == -1 )
            {
              me->Line = -1;
            }
          }
          s->pending_len = 0;
          if ( v18 )
            v29 = -1;
          else
            v29 = 11;
          newstate = v29;
          break;
        default:
          break;
      }
    }
LABEL_264:
    s->state = newstate;
    ret = lastcell->len;
    if ( nested_tables && ret == -1 && !pos )
      ret = 0;
  }
  else if ( (end_td & 1) != 0 )
  {
    s->x_td = -1;
    switch ( s->state )
    {
      case CS_invalid:
        if ( !me->fixed_line || me->Line != lastcell->cLine )
          lastcell->len = 0;
        goto LABEL_229;
      case CS__new:
        ret = -1;
        if ( !v18 && s->prev_state == CS__cbc )
          break;
        if ( v18 )
          goto LABEL_245;
        if ( me->fixed_line )
        {
          if ( me->Line != lineno )
            break;
        }
        else
        {
          me->fixed_line = 1;
          me->Line = lineno;
        }
LABEL_245:
        if ( lastcell->len < 0 )
        {
          if ( v18 )
            v49 = 0;
          else
            v49 = pos - lastcell->pos;
          lastcell->len = v49;
        }
        if ( v18 )
          v50 = CS__ef;
        else
          v50 = CS__cf;
        s->state = v50;
        if ( me->fixed_line && me->Line != lineno )
          len = -1;
        else
          len = lastcell->len;
        ret = len;
        break;
      case CS__0new:
LABEL_229:
        if ( v18 )
          v47 = 6;
        else
          v47 = 8;
        newstate = v47;
        goto LABEL_263;
      case CS__0eb:
        newstate = CS__0ef;
        goto LABEL_263;
      case CS__eb:
        if ( v18 )
          v52 = 7;
        else
          v52 = 9;
        newstate = v52;
        goto LABEL_263;
      case CS__0cb:
        if ( v18 )
          v48 = 8;
        else
          v48 = 11;
        newstate = v48;
        goto LABEL_263;
      case CS__cb:
        newstate = CS__cf;
        goto LABEL_263;
      case CS__0ef:
        newstate = CS__0ef;
        goto LABEL_263;
      default:
LABEL_263:
        lastcell->len = pos - lastcell->pos;
        goto LABEL_264;
    }
  }
  else
  {
    switch ( s->state )
    {
      case CS_invalid:
      case CS__0new:
        if ( v18 )
          v40 = 0;
        else
          v40 = pos - lastcell->pos;
        s->pending_len = v40;
        if ( v18 )
          v41 = CS__0eb;
        else
          v41 = CS__0cb;
        s->state = v41;
        ret = 0;
        break;
      case CS__new:
        ret = -1;
        if ( !v18 && s->prev_state == CS__cbc )
          break;
        if ( v18 )
          goto LABEL_203;
        if ( me->fixed_line )
        {
          if ( me->Line != lineno )
            break;
        }
        else
        {
          me->fixed_line = 1;
          me->Line = lineno;
        }
LABEL_203:
        if ( v18 )
          v42 = CS__eb;
        else
          v42 = CS__cb;
        s->state = v42;
        if ( me->fixed_line )
        {
          s->pending_len = 0;
          if ( v18 )
            v44 = 0;
          else
            v44 = pos - lastcell->pos;
          lastcell->len = v44;
          ret = lastcell->len;
        }
        else
        {
          if ( v18 )
            v43 = 0;
          else
            v43 = pos - lastcell->pos;
          s->pending_len = v43;
          ret = 0;
        }
        break;
      case CS__0eb:
        newstate = CS__eb;
        goto LABEL_264;
      case CS__eb:
        if ( v18 )
          v45 = 3;
        else
          v45 = 10;
        newstate = v45;
        goto LABEL_264;
      case CS__0cb:
        newstate = CS__cb;
        goto LABEL_264;
      case CS__cb:
        if ( v18 )
          v46 = 5;
        else
          v46 = 11;
        newstate = v46;
        goto LABEL_264;
      case CS__ef:
        ret = 0;
        break;
      case CS__cf:
        ret = lastcell->len;
        break;
      default:
        goto LABEL_264;
    }
  }
trace_and_return:
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v12 = cellstate_s(s->state);
    v13 = cellstate_s(s->prev_state);
    v14 = TraceFP();
    fprintf(v14, " => prev_state=%s, state=%s, return=%d\n", v13, v12, ret);
  }
  return ret;
}
// 80EE21B: conditional instruction was optimized away because %empty.4 is in (1..FF)
// 80EE653: conditional instruction was optimized away because %empty.4 is in (1..FF)

//----- (080EEBA1) --------------------------------------------------------
int __cdecl Stbl_reserveCellsInTable(STable_info *me, int icell, int colspan, int rowspan)
{
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // edx
  int nmemb; // [esp+18h] [ebp-20h]
  STable_rowinfo *v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+20h] [ebp-18h]
  int v12; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int ia; // [esp+28h] [ebp-10h]
  int growby; // [esp+2Ch] [ebp-Ch]
  STable_rowinfo *row; // [esp+30h] [ebp-8h]
  STable_rowinfo *rows; // [esp+34h] [ebp-4h]

  if ( colspan <= 200 )
  {
    if ( rowspan <= 200 )
    {
      if ( me->nrows > 0 )
      {
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
        {
          v6 = TraceFP();
          fprintf(v6, "TRST:Stbl_reserveCellsInTable(icell=%d, colspan=%d, rowspan=%d)\n", icell, colspan, rowspan);
        }
        if ( !rowspan )
        {
          if ( !me->rowspans2eog.cells )
          {
            nmemb = icell + colspan;
            if ( icell + colspan <= 0 )
              nmemb = 1;
            me->rowspans2eog.cells = (STable_cellinfo *)calloc(nmemb, 0x14u);
            if ( !me->rowspans2eog.cells )
              return 0;
            me->rowspans2eog.allocated = icell + colspan;
          }
          Stbl_reserveCellsInRow(&me->rowspans2eog, icell, colspan);
        }
        growby = rowspan + me->nrows - 1 - me->allocated_rows;
        if ( growby > 0 )
        {
          rows = (STable_rowinfo *)realloc(me->rows, 36 * (rowspan + me->nrows - 1));
          if ( !rows )
            return 0;
          for ( i = 0; i < growby; ++i )
          {
            row = &rows[i + me->allocated_rows];
            row->allocated = 0;
            row->offset = 0;
            row->content = 0;
            if ( me->rowspans2eog.allocated )
            {
              row->cells = (STable_cellinfo *)calloc(me->rowspans2eog.allocated, 0x14u);
              if ( row->cells )
              {
                row->allocated = me->rowspans2eog.allocated;
                memcpy(row->cells, me->rowspans2eog.cells, 20 * row->allocated);
              }
            }
            else
            {
              row->cells = 0;
            }
            row->ncells = 0;
            row->fixed_line = 0;
            row->alignment = -1;
          }
          me->allocated_rows += growby;
          me->rows = rows;
        }
        for ( ia = me->nrows; ; ++ia )
        {
          v12 = rowspan ? rowspan + me->nrows - 1 : me->allocated_rows;
          if ( v12 <= ia )
            break;
          if ( !me->rows[ia].allocated )
          {
            v11 = colspan + icell;
            if ( colspan + icell <= 0 )
              v11 = 1;
            v10 = &me->rows[ia];
            v10->cells = (STable_cellinfo *)calloc(v11, 0x14u);
            if ( !me->rows[ia].cells )
              return 0;
            me->rows[ia].allocated = colspan + icell;
          }
          Stbl_reserveCellsInRow(&me->rows[ia], icell, colspan);
        }
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
      {
        v5 = TraceFP();
        fprintf(v5, "TRST:*** ROWSPAN=%d is too large, ignored!\n", rowspan);
      }
      return -1;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
    {
      v4 = TraceFP();
      fprintf(v4, "TRST:*** COLSPAN=%d is too large, ignored!\n", colspan);
    }
    return -1;
  }
}

//----- (080EEFAD) --------------------------------------------------------
void __cdecl Stbl_cancelRowSpans(STable_info *me)
{
  FILE *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "TRST:Stbl_cancelRowSpans()");
  }
  for ( i = me->nrows; me->allocated_rows > i; ++i )
  {
    if ( !me->rows[i].ncells )
    {
      if ( me->rows[i].cells )
      {
        free(me->rows[i].cells);
        me->rows[i].cells = 0;
      }
      me->rows[i].allocated = 0;
    }
  }
  free_rowinfo(&me->rowspans2eog);
  me->rowspans2eog.allocated = 0;
}

//----- (080EF0B1) --------------------------------------------------------
int __cdecl Stbl_addRowToTable(STable_info *me, int alignment, int lineno)
{
  FILE *v3; // edx
  int rowgroup_align; // [esp+20h] [ebp-28h]
  int growby; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  STable_rowinfo *row; // [esp+3Ch] [ebp-Ch]
  STable_rowinfo *rows; // [esp+40h] [ebp-8h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v3 = TraceFP();
    fprintf(v3, "TRST:Stbl_addRowToTable(alignment=%d, lineno=%d)\n", alignment, lineno);
  }
  if ( me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0 )
  {
    if ( me->s.pending_len > 0 )
      me->rows[me->nrows - 1].cells[me->rows[me->nrows - 1].ncells - 1].len = me->s.pending_len;
    me->s.pending_len = 0;
  }
  Stbl_finishRowInTable(me);
  if ( me->nrows > 0 && me->rows[me->nrows - 1].Line == lineno )
    me->rows[me->nrows - 1].Line = -1;
  me->s.pending_len = 0;
  me->s.x_td = -1;
  for ( growby = 0; me->nrows + 2 > growby + me->allocated_rows; growby += 16 )
    ;
  if ( growby )
  {
    if ( me->allocated_rows || me->rows )
    {
      rows = (STable_rowinfo *)realloc(me->rows, 36 * (growby + me->allocated_rows));
      for ( i = 0; rows && i < growby; ++i )
      {
        row = &rows[i + me->allocated_rows];
        if ( me->rowspans2eog.allocated )
        {
          row->cells = (STable_cellinfo *)calloc(me->rowspans2eog.allocated, 0x14u);
          if ( !row->cells )
          {
            free(rows);
            rows = 0;
            break;
          }
          row->allocated = me->rowspans2eog.allocated;
          memcpy(row->cells, me->rowspans2eog.cells, 20 * row->allocated);
        }
        else
        {
          row->allocated = 0;
          row->cells = 0;
        }
        row->ncells = 0;
        row->fixed_line = 0;
        row->alignment = -1;
        row->offset = 0;
        row->content = 0;
      }
    }
    else
    {
      rows = (STable_rowinfo *)calloc(growby, 0x24u);
    }
    if ( !rows )
      return -1;
    me->allocated_rows += growby;
    me->rows = rows;
  }
  me->rows[me->nrows].Line = lineno;
  if ( !me->nrows )
    me->startline = lineno;
  if ( alignment == -1 )
  {
    if ( me->rowgroup_align == -1 )
      rowgroup_align = me->alignment;
    else
      rowgroup_align = me->rowgroup_align;
    me->rows[me->nrows].alignment = rowgroup_align;
  }
  else
  {
    me->rows[me->nrows].alignment = alignment;
  }
  ++me->nrows;
  if ( me->pending_colgroup_next > me->ncolinfo )
  {
    me->ncolinfo = me->pending_colgroup_next;
    me->pending_colgroup_next = 0;
  }
  me->rows[me->nrows].Line = -1;
  me->rows[me->nrows].ended = ROW_not_ended;
  return me->nrows - 1;
}
// 80EF353: conditional instruction was optimized away because %rows.4!=0

//----- (080EF510) --------------------------------------------------------
int __cdecl Stbl_finishRowInTable(STable_info *me)
{
  FILE *v1; // eax
  STable_rowinfo *lastrow; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "TRST:Stbl_finishRowInTable()\n");
  }
  if ( !me->rows || !me->nrows )
    return -1;
  lastrow = &me->rows[me->nrows - 1];
  lastrow->ended = ROW_ended_by_endtr;
  if ( lastrow->ncells > 0 )
  {
    if ( me->s.pending_len > 0 )
      lastrow->cells[lastrow->ncells - 1].len = me->s.pending_len;
    me->s.pending_len = 0;
  }
  me->s.state = CS_invalid;
  me->s.prev_state = me->s.state;
  me->s.lineno = -1;
  if ( me->s.icell_core >= 0 && !lastrow->fixed_line && lastrow->cells[me->s.icell_core].cLine >= 0 )
    lastrow->Line = lastrow->cells[me->s.icell_core].cLine;
  me->s.icell_core = -1;
  return me->nrows;
}

//----- (080EF675) --------------------------------------------------------
void __cdecl update_sumcols0(
        STable_cellinfo *sumcols,
        STable_rowinfo *lastrow,
        int pos,
        int len,
        int icell,
        int ispan,
        int allocated_sumcols)
{
  int v7; // [esp+4h] [ebp-14h]
  int advance; // [esp+8h] [ebp-10h]
  int prevsumpos; // [esp+Ch] [ebp-Ch]
  int sumpos; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( len > 0 )
  {
    sumpos = pos;
    prevsumpos = sumcols[ispan + icell].pos;
    if ( ispan > 0 )
    {
      if ( len + lastrow->cells[icell].pos > pos )
        sumpos = len + lastrow->cells[icell].pos;
      if ( sumcols[ispan - 1 + icell].pos + sumcols[ispan - 1 + icell].len > sumpos )
        sumpos = sumcols[ispan - 1 + icell].pos + sumcols[ispan - 1 + icell].len;
    }
    advance = sumpos - prevsumpos;
    if ( sumpos - prevsumpos > 0 )
    {
      for ( i = icell + ispan; i < allocated_sumcols; ++i )
      {
        if ( ispan > 0 && sumcols[i].colspan < -1 && i + sumcols[i].colspan < ispan + icell )
        {
          advance = sumpos - sumcols[i].pos;
          if ( i > 0 )
          {
            v7 = sumcols[i - 1].len + sumcols[i - 1].pos - sumcols[i].pos;
            if ( v7 < advance )
              v7 = sumpos - sumcols[i].pos;
            advance = v7;
          }
          if ( advance <= 0 )
            break;
        }
        if ( sumcols[i].pos < 0 )
        {
          sumcols[i].pos = sumpos;
          return;
        }
        sumcols[i].pos += advance;
      }
    }
  }
}

//----- (080EF8E7) --------------------------------------------------------
int __cdecl get_remaining_colspan(
        STable_rowinfo *me,
        STable_cellinfo *colinfo,
        int ncolinfo,
        int colspan,
        int ncols_sofar)
{
  FILE *v5; // eax
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int i; // [esp+24h] [ebp-4h]
  int colspana; // [esp+3Ch] [ebp+14h]

  if ( me->ncells )
    v8 = me->cells[me->ncells - 1].colspan;
  else
    v8 = 1;
  if ( ncolinfo && v8 + me->ncells <= ncolinfo )
  {
    for ( i = v8 + me->ncells - 1; ncolinfo - 1 > i && colinfo[i].cLine != -2; ++i )
      ;
    colspana = i + 2 - (v8 + me->ncells);
  }
  else
  {
    v7 = ncols_sofar + 1 - (v8 + me->ncells);
    if ( v7 > 200 )
      v7 = 200;
    colspana = v7;
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v5 = TraceFP();
    fprintf(v5, "TRST:get_remaining_colspan; colspan = %d\n", colspana);
  }
  return colspana;
}

//----- (080EF9F7) --------------------------------------------------------
int __cdecl Stbl_fakeFinishCellInTable(STable_info *me, STable_rowinfo *lastrow, int lineno, int finishing)
{
  FILE *v4; // edx
  FILE *v5; // eax
  STable_rowinfo *v6; // ecx
  STable_rowinfo *v7; // edx
  FILE *v8; // eax
  FILE *v9; // eax
  const char *v12; // [esp+30h] [ebp-58h]
  int colspan; // [esp+34h] [ebp-54h]
  int n; // [esp+44h] [ebp-44h]
  int need_cells; // [esp+48h] [ebp-40h]
  STable_rowinfo *rows; // [esp+4Ch] [ebp-3Ch]
  int prev_row_n2; // [esp+54h] [ebp-34h]
  STable_rowinfo *prev_row; // [esp+58h] [ebp-30h]
  STable_rowinfo *prev_rowa; // [esp+58h] [ebp-30h]
  int prev_reserved_last; // [esp+5Ch] [ebp-2Ch]
  int need_reserved; // [esp+60h] [ebp-28h]
  int cs_0; // [esp+70h] [ebp-18h]
  int al_0; // [esp+74h] [ebp-14h]
  int i; // [esp+78h] [ebp-10h]
  int ia; // [esp+78h] [ebp-10h]
  int ib; // [esp+78h] [ebp-10h]
  int ic; // [esp+78h] [ebp-10h]
  int ncells; // [esp+7Ch] [ebp-Ch]
  int fake; // [esp+80h] [ebp-8h]
  STable_rowinfo *lastrowa; // [esp+94h] [ebp+Ch]

  fake = 0;
  if ( (unsigned int)(me->s.state - 2) <= 3 )
  {
    fake = 1;
  }
  else if ( !finishing )
  {
    fake = 1;
  }
  if ( !fake )
    return 0;
  ncells = lastrow->ncells;
  al_0 = lastrow->alignment;
  cs_0 = lastrow->cells[ncells - 1].colspan;
  need_reserved = 0;
  prev_reserved_last = -1;
  prev_row_n2 = 954437177 * (((char *)lastrow - (char *)me->rows) >> 2);
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v4 = TraceFP();
    fprintf(v4, "TRST:Stbl_fakeFinishCellInTable(lineno=%d, finishing=%d) START FAKING\n", lineno, finishing);
  }
  if ( finishing && Stbl_finishCellInTable(me, 3, lineno, 0, 0) < 0 )
    return -1;
  if ( Stbl_addRowToTable(me, al_0, lineno) < 0 )
    return -1;
  lastrowa = &me->rows[me->nrows - 1];
  lastrowa->content = 4;
  for ( i = 0; lastrowa->allocated > i; ++i )
  {
    if ( lastrowa->cells[i].alignment == -2 )
    {
      need_reserved = 1;
      break;
    }
  }
  prev_row = me->rows + prev_row_n2;
  for ( ia = ncells; prev_row->allocated > ia; ++ia )
  {
    if ( prev_row->cells[ia].alignment == -2 )
      prev_reserved_last = ia;
  }
  if ( need_reserved || prev_reserved_last >= 0 )
  {
    rows = (STable_rowinfo *)realloc(me->rows, 36 * (me->allocated_rows + 1));
    need_cells = prev_reserved_last + 1;
    if ( !rows )
      return -1;
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
    {
      v5 = TraceFP();
      fprintf(v5, "TRST:Stbl_fakeFinishCellInTable REALLOC ROWSPAN\n");
    }
    me->rows = rows;
    lastrowa = &me->rows[me->nrows - 1];
    prev_rowa = (STable_rowinfo *)((char *)me->rows + 4 * ((36 * prev_row_n2) >> 2));
    for ( n = ++me->allocated_rows - me->nrows - 1; n >= 0; --n )
    {
      v6 = &lastrowa[n + 1];
      v7 = &lastrowa[n];
      v6->Line = v7->Line;
      v6->ncells = v7->ncells;
      *(_DWORD *)&v6->fixed_line = *(_DWORD *)&v7->fixed_line;
      v6->ended = v7->ended;
      v6->content = v7->content;
      v6->offset = v7->offset;
      v6->allocated = v7->allocated;
      v6->cells = v7->cells;
      v6->alignment = v7->alignment;
    }
    lastrowa->allocated = 0;
    lastrowa->cells = 0;
    if ( prev_reserved_last != -1 )
    {
      lastrowa->cells = (STable_cellinfo *)calloc(need_cells, 0x14u);
      if ( !lastrowa->cells )
        return -1;
      lastrowa->allocated = need_cells;
      memcpy(lastrowa->cells, prev_rowa->cells, 20 * lastrowa->allocated);
      ib = -1;
      while ( ++ib < ncells )
      {
        if ( lastrowa->cells[ib].alignment == -2 )
          lastrowa->cells[ib].alignment = 1;
      }
    }
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    if ( finishing )
      v12 = ", last unfinished";
    else
      v12 = (const char *)&unk_816FD97;
    v8 = TraceFP();
    fprintf(v8, "TRST:Stbl_fakeFinishCellInTable FAKE %d elts%s\n", ncells, v12);
  }
  ic = 0;
  while ( ++ic <= ncells )
  {
    if ( ic == ncells )
      colspan = cs_0;
    else
      colspan = 1;
    if ( Stbl_addCellToTable(me, colspan, 1, al_0, 0, lineno, 0, 0) < 0 )
      return -1;
    lastrowa->content &= ~2u;
    if ( (!finishing || ic != ncells) && Stbl_finishCellInRow(lastrowa, &me->s, 3, lineno, 0) < 0 )
      return -1;
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v9 = TraceFP();
    fprintf(v9, "TRST:Stbl_fakeFinishCellInTable(lineno=%d) FINISH FAKING\n", lineno);
  }
  return 1;
}

//----- (080EFFCE) --------------------------------------------------------
int __cdecl Stbl_addCellToTable(
        STable_info *me,
        int colspan,
        int rowspan,
        int alignment,
        int isheader,
        int lineno,
        int offset_not_used_yet,
        int pos)
{
  int v8; // ebx
  FILE *v9; // edx
  int v12; // [esp+30h] [ebp-38h]
  int growby; // [esp+3Ch] [ebp-2Ch]
  int rc; // [esp+40h] [ebp-28h]
  int sumpos; // [esp+44h] [ebp-24h]
  int ncells; // [esp+48h] [ebp-20h]
  int icell; // [esp+4Ch] [ebp-1Ch]
  int i; // [esp+50h] [ebp-18h]
  STable_cellinfo *sumcol; // [esp+54h] [ebp-14h]
  STable_cellinfo *sumcols; // [esp+58h] [ebp-10h]
  STable_rowinfo *lastrow; // [esp+5Ch] [ebp-Ch]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v8 = pos;
    v9 = TraceFP();
    fprintf(
      v9,
      "TRST:Stbl_addCellToTable(lineno=%d, pos=%d, isheader=%d, cs=%d, rs=%d, al=%d)\n",
      lineno,
      v8,
      isheader,
      colspan,
      rowspan,
      alignment);
  }
  if ( !me->rows || !me->nrows )
    return -1;
  if ( me->rows[me->nrows - 1].ended )
    Stbl_addRowToTable(me, alignment, lineno);
  Stbl_finishCellInTable(me, 1, lineno, 0, pos);
  lastrow = &me->rows[me->nrows - 1];
  if ( nested_tables && !pos && lastrow->ncells > 0 && lastrow->cells[lastrow->ncells - 1].cLine != lineno )
  {
    rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 0);
    if ( rc < 0 )
      return -1;
    if ( rc )
      lastrow = &me->rows[me->nrows - 1];
  }
  if ( !colspan )
    colspan = get_remaining_colspan(lastrow, me->sumcols, me->ncolinfo, 0, me->ncols);
  ncells = lastrow->ncells;
  icell = Stbl_addCellToRow(lastrow, me->sumcols, me->ncolinfo, &me->s, colspan, alignment, isheader, lineno, &pos);
  if ( icell < 0 )
    return icell;
  if ( me->nrows == 1 && me->startline < lastrow->Line )
    me->startline = lastrow->Line;
  if ( rowspan != 1 )
  {
    Stbl_reserveCellsInTable(me, icell, colspan, rowspan);
    lastrow = &me->rows[me->nrows - 1];
  }
  lastrow->content |= 2u;
  for ( growby = 0; colspan + icell + 1 > growby + me->allocated_sumcols; growby += 16 )
    ;
  if ( growby )
  {
    if ( me->allocated_sumcols || me->sumcols )
    {
      sumcols = (STable_cellinfo *)realloc(me->sumcols, 20 * (growby + me->allocated_sumcols));
      for ( i = 0; sumcols && i < growby; ++i )
      {
        sumcol = &sumcols[i + me->allocated_sumcols];
        sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
        sumcol->len = 0;
        sumcol->colspan = 0;
        sumcol->cLine = 0;
        sumcol->alignment = -1;
      }
    }
    else
    {
      sumcols = (STable_cellinfo *)calloc(growby, 0x14u);
    }
    if ( !sumcols )
      return -1;
    me->allocated_sumcols += growby;
    me->sumcols = sumcols;
  }
  if ( icell + 1 > me->ncols )
    me->ncols = icell + 1;
  if ( colspan > 1 && colspan + me->sumcols[colspan + icell].colspan > 0 )
    me->sumcols[colspan + icell].colspan = -colspan;
  sumpos = pos;
  if ( ncells > 0 )
    sumpos = me->sumcols[ncells - 1].pos - lastrow->cells[ncells - 1].pos + pos;
  update_sumcols0(me->sumcols, lastrow, sumpos, sumpos - me->sumcols[icell].pos, icell, 0, me->allocated_sumcols);
  me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
  if ( LYwideLines )
    v12 = 1013;
  else
    v12 = LYcols - (LYShowScrollbar != 0);
  if ( me->maxpos <= v12 )
    return 0;
  else
    return -1;
}

//----- (080F0573) --------------------------------------------------------
int __cdecl Stbl_finishCellInTable(STable_info *me, int end_td, int lineno, int offset, int pos)
{
  FILE *v5; // edx
  int v7; // [esp+20h] [ebp-58h]
  int pending_len; // [esp+28h] [ebp-50h]
  int v10; // [esp+30h] [ebp-48h]
  int v11; // [esp+38h] [ebp-40h]
  int v12; // [esp+40h] [ebp-38h]
  int spanlend; // [esp+50h] [ebp-28h]
  int spanlen; // [esp+54h] [ebp-24h]
  int rc; // [esp+58h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-1Ch]
  int icell; // [esp+60h] [ebp-18h]
  int len; // [esp+68h] [ebp-10h]
  STable_rowinfo *lastrow; // [esp+6Ch] [ebp-Ch]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v5 = TraceFP();
    fprintf(v5, "TRST:Stbl_finishCellInTable(lineno=%d, pos=%d, off=%d, end_td=%d)\n", lineno, pos, offset, end_td);
  }
  if ( !me->nrows )
    return -1;
  lastrow = &me->rows[me->nrows - 1];
  icell = lastrow->ncells - 1;
  if ( icell < 0 )
    return lastrow->ncells - 1;
  if ( me->s.x_td == -1 )
  {
    if ( (end_td & 1) == 0 )
      lastrow->ended = ROW_ended_by_splitline;
    return 0;
  }
  else
  {
    if ( nested_tables )
    {
      if ( (end_td & 2) == 0 )
      {
        rc = Stbl_fakeFinishCellInTable(me, lastrow, lineno, 1);
        if ( rc )
        {
          if ( rc < 0 )
            return -1;
          lastrow = &me->rows[me->nrows - 1];
          icell = lastrow->ncells - 1;
        }
      }
    }
    len = Stbl_finishCellInRow(lastrow, &me->s, end_td, lineno, pos);
    if ( len == -1 )
    {
      return -1;
    }
    else
    {
      if ( len > 0 )
        pending_len = len;
      else
        pending_len = me->s.pending_len;
      if ( lastrow->Line == lineno )
        len = pending_len;
      if ( lastrow->cells[icell].colspan <= 1 )
      {
        if ( me->sumcols[icell].len < len )
        {
          if ( me->sumcols[icell + 1].colspan >= -1 )
            me->maxlen += len - me->sumcols[icell].len;
          me->sumcols[icell].len = len;
        }
      }
      else
      {
        spanlen = 0;
        spanlend = 0;
        for ( i = icell; icell + lastrow->cells[icell].colspan > i; ++i )
        {
          if ( me->sumcols[i].len > 0 )
          {
            spanlen += me->sumcols[i].len;
            if ( i > icell )
              ++spanlen;
          }
          v7 = me->sumcols[i + 1].pos - me->sumcols[icell].pos;
          if ( v7 < spanlend )
            v7 = spanlend;
          spanlend = v7;
        }
        if ( spanlend )
          --spanlend;
        if ( spanlend > spanlen )
          spanlen = spanlend;
        if ( len > spanlen )
          me->maxlen += len - spanlen;
      }
      if ( len > 0 )
      {
        update_sumcols0(me->sumcols, lastrow, pos, len, icell, lastrow->cells[icell].colspan, me->allocated_sumcols);
        me->maxpos = me->sumcols[me->allocated_sumcols - 1].pos;
      }
      if ( (end_td & 1) == 0 )
      {
        lastrow->ended = ROW_ended_by_splitline;
        lastrow->content |= 0x20u;
        lastrow->offset = offset;
      }
      if ( nested_tables )
      {
        if ( LYwideLines )
          v10 = 1013;
        else
          v10 = LYcols - (LYShowScrollbar != 0);
        if ( me->maxlen > v10 )
          return -1;
      }
      else
      {
        if ( LYwideLines )
          v11 = 1013;
        else
          v11 = LYcols - (LYShowScrollbar != 0);
        if ( pending_len - len + me->maxlen > v11 )
          return -1;
      }
      if ( LYwideLines )
        v12 = 1013;
      else
        v12 = LYcols - (LYShowScrollbar != 0);
      if ( me->maxpos <= v12 )
        return 0;
      else
        return -1;
    }
  }
}

//----- (080F0AA9) --------------------------------------------------------
int __cdecl Stbl_addColInfo(STable_info *me, int colspan, __int16 alignment, BOOLEAN isgroup)
{
  FILE *v4; // edx
  __int16 alignmenta; // [esp+1Ch] [ebp-2Ch]
  int growby; // [esp+2Ch] [ebp-1Ch]
  int icolinfo; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  int ia; // [esp+34h] [ebp-14h]
  int ib; // [esp+34h] [ebp-14h]
  STable_cellinfo *sumcol; // [esp+38h] [ebp-10h]
  STable_cellinfo *sumcols; // [esp+3Ch] [ebp-Ch]

  alignmenta = alignment;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v4 = TraceFP();
    fprintf(v4, "TRST:Stbl_addColInfo(cs=%d, al=%d, isgroup=%d)\n", colspan, alignment, isgroup);
  }
  if ( isgroup )
  {
    if ( me->pending_colgroup_next > me->ncolinfo )
      me->ncolinfo = me->pending_colgroup_next;
    me->pending_colgroup_next = colspan + me->ncolinfo;
    if ( me->ncolinfo > 0 )
      me->sumcols[me->ncolinfo - 1].cLine = -2;
    me->pending_colgroup_align = alignment;
  }
  else
  {
    for ( i = me->pending_colgroup_next - 1; colspan + me->ncolinfo <= i; --i )
      me->sumcols[i].alignment = -1;
    me->pending_colgroup_next = colspan + me->ncolinfo;
  }
  icolinfo = me->ncolinfo;
  if ( !isgroup )
    me->ncolinfo += colspan;
  for ( growby = 0; colspan + icolinfo + 1 > growby + me->allocated_sumcols; growby += 16 )
    ;
  if ( growby )
  {
    if ( me->allocated_sumcols )
    {
      sumcols = (STable_cellinfo *)realloc(me->sumcols, 20 * (growby + me->allocated_sumcols));
      for ( ia = 0; sumcols && ia < growby; ++ia )
      {
        sumcol = &sumcols[ia + me->allocated_sumcols];
        sumcol->pos = sumcols[me->allocated_sumcols - 1].pos;
        sumcol->len = 0;
        sumcol->colspan = 0;
        sumcol->cLine = 0;
      }
    }
    else
    {
      sumcols = (STable_cellinfo *)calloc(growby, 0x14u);
    }
    if ( !sumcols )
      return -1;
    me->allocated_sumcols += growby;
    me->sumcols = sumcols;
  }
  if ( alignment == -1 )
    alignmenta = me->pending_colgroup_align;
  for ( ib = icolinfo; icolinfo + colspan > ib; ++ib )
    me->sumcols[ib].alignment = alignmenta;
  return 0;
}

//----- (080F0D5C) --------------------------------------------------------
int __cdecl Stbl_finishColGroup(STable_info *me)
{
  FILE *v1; // eax

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "TRST:Stbl_finishColGroup()\n");
  }
  if ( me->pending_colgroup_next >= me->ncolinfo )
  {
    me->ncolinfo = me->pending_colgroup_next;
    if ( me->ncolinfo > 0 )
      me->sumcols[me->ncolinfo - 1].cLine = -2;
  }
  me->pending_colgroup_next = 0;
  me->pending_colgroup_align = -1;
  return 0;
}

//----- (080F0DF4) --------------------------------------------------------
int __cdecl Stbl_addRowGroup(STable_info *me, __int16 alignment)
{
  FILE *v2; // eax

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v2 = TraceFP();
    fprintf(v2, "TRST:Stbl_addRowGroup()\n");
  }
  Stbl_cancelRowSpans(me);
  me->rowgroup_align = alignment;
  return 0;
}

//----- (080F0E4C) --------------------------------------------------------
int __cdecl Stbl_finishTABLE(STable_info *me)
{
  FILE *v1; // eax
  ended_state ended; // esi
  int offset; // ebx
  FILE *v4; // edx
  ended_state v5; // ebx
  int v6; // esi
  FILE *v7; // edx
  int v11; // [esp+2Ch] [ebp-4Ch]
  int curcell; // [esp+40h] [ebp-38h]
  int max_width; // [esp+44h] [ebp-34h]
  int foundcell; // [esp+48h] [ebp-30h]
  int have_offsets; // [esp+4Ch] [ebp-2Ch]
  int minoffset; // [esp+50h] [ebp-28h]
  STable_rowinfo *nextrow; // [esp+54h] [ebp-24h]
  STable_rowinfo *nextrowa; // [esp+54h] [ebp-24h]
  STable_rowinfo *nextrowb; // [esp+54h] [ebp-24h]
  STable_rowinfo *nextrowc; // [esp+54h] [ebp-24h]
  STable_rowinfo *nextrowd; // [esp+54h] [ebp-24h]
  int non_empty; // [esp+58h] [ebp-20h]
  int leading; // [esp+5Ch] [ebp-1Ch]
  int j; // [esp+60h] [ebp-18h]
  int ja; // [esp+60h] [ebp-18h]
  int jb; // [esp+60h] [ebp-18h]
  int jc; // [esp+60h] [ebp-18h]
  int jd; // [esp+60h] [ebp-18h]
  int curpos; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  int ia; // [esp+68h] [ebp-10h]

  curpos = 0;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
  {
    v1 = TraceFP();
    fprintf(v1, "TRST:Stbl_finishTABLE()\n");
  }
  if ( !me || me->nrows <= 0 || me->ncols <= 0 )
    return -1;
  if ( me->nrows > 0 && me->rows[me->nrows - 1].ncells > 0 )
  {
    if ( me->s.pending_len > 0 )
      me->rows[me->nrows - 1].cells[me->rows[me->nrows - 1].ncells - 1].len = me->s.pending_len;
    me->s.pending_len = 0;
  }
  Stbl_finishRowInTable(me);
  for ( i = 0; me->nrows - 1 > i; ++i )
  {
    j = i + 1;
    leading = i;
    non_empty = 0;
    nextrow = &me->rows[i + 1];
    if ( (nextrow->content & 0x26) == 36 )
    {
      minoffset = nextrow[-1].offset;
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
      {
        ended = nextrow[-1].ended;
        offset = nextrow[-1].offset;
        v4 = TraceFP();
        fprintf(v4, "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%u.\n", i, offset, ended);
      }
      while ( me->nrows > j && (nextrow->content & 0x26) == 36 )
      {
        if ( nextrow->offset < minoffset )
          minoffset = nextrow->offset;
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
        {
          v5 = nextrow[-1].ended;
          v6 = nextrow->offset;
          v7 = TraceFP();
          fprintf(v7, "TRST:Stbl_finishTABLE, l=%d, offset=%d, ended=%u.\n", j, v6, v5);
        }
        ++nextrow;
        ++j;
      }
      i = j - 1;
      ja = leading;
      nextrowa = &me->rows[leading];
      have_offsets = 0;
      nextrowa->content |= 0x10u;
      while ( ja <= i )
      {
        nextrowa->offset -= minoffset;
        nextrowa->content |= 8u;
        if ( nextrowa->offset )
          have_offsets = 1;
        ++nextrowa;
        ++ja;
      }
      if ( have_offsets )
      {
        foundcell = -1;
        jb = leading + 1;
        nextrowb = &me->rows[leading + 1];
        while ( foundcell == -1 && jb <= i )
        {
          curcell = -1;
          while ( foundcell == -1 )
          {
            if ( ++curcell >= nextrowb->ncells )
              break;
            if ( nextrowb->cells[curcell].len )
            {
              foundcell = curcell;
              non_empty = jb;
            }
          }
          ++nextrowb;
          ++jb;
        }
        if ( foundcell != -1 )
        {
          max_width = 0;
          jc = leading;
          nextrowc = &me->rows[leading];
          while ( jc <= i )
          {
            if ( nextrowc->ncells > foundcell && nextrowc->cells[foundcell].len + nextrowc->offset > max_width )
              max_width = nextrowc->cells[foundcell].len + nextrowc->offset;
            ++nextrowc;
            ++jc;
          }
          update_sumcols0(
            me->sumcols,
            &me->rows[non_empty],
            0,
            max_width,
            foundcell,
            me->rows[non_empty].cells[foundcell].colspan,
            me->allocated_sumcols);
          jd = leading;
          nextrowd = &me->rows[leading];
          while ( jd <= i )
          {
            if ( nextrowd->ncells > foundcell )
              nextrowd->cells[foundcell].len = max_width;
            ++nextrowd;
            ++jd;
          }
        }
      }
    }
  }
  for ( ia = 0; me->ncols > ia; ++ia )
  {
    if ( me->sumcols[ia].pos >= curpos )
      curpos = me->sumcols[ia].pos;
    else
      me->sumcols[ia].pos = curpos;
    if ( me->sumcols[ia].len > 0 )
      curpos += me->sumcols[ia].len;
  }
  if ( LYwideLines )
    v11 = 1013;
  else
    v11 = LYcols - (LYShowScrollbar != 0);
  if ( v11 < curpos )
    return -1;
  else
    return me->ncols;
}

//----- (080F143A) --------------------------------------------------------
__int16 __cdecl Stbl_getAlignment(STable_info *me)
{
  if ( me )
    return me->alignment;
  else
    return -1;
}

//----- (080F145F) --------------------------------------------------------
int __cdecl get_fixup_positions(STable_rowinfo *me, int *oldpos, int *newpos, STable_cellinfo *sumcols)
{
  int v4; // eax
  int len; // [esp+4h] [ebp-34h]
  int colspan; // [esp+Ch] [ebp-2Ch]
  int offset; // [esp+18h] [ebp-20h]
  int ip_0; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  i = 0;
  ip_0 = 0;
  if ( !me )
    return -1;
  while ( me->ncells > i )
  {
    colspan = me->cells[i].colspan;
    if ( colspan <= 0 )
      colspan = 1;
    if ( me->cells[i].cLine == me->Line )
    {
      oldpos[ip_0] = me->cells[i].pos;
      if ( (me->content & 8) != 0 && (me->ncells - 1 == i || (me->content & 0x10) == 0) )
        offset = me->offset;
      else
        offset = 0;
      newpos[ip_0] = offset + sumcols[i].pos;
      if ( (me->cells[i].alignment == 3 || me->cells[i].alignment == 2) && me->cells[i].len > 0 )
      {
        len = sumcols[i].len;
        if ( len < sumcols[i + colspan].pos - newpos[ip_0] - 1 )
          len = sumcols[i + colspan].pos - newpos[ip_0] - 1;
        if ( me->cells[i].len < len )
        {
          if ( me->cells[i].alignment == 2 )
            v4 = newpos[ip_0] + len - me->cells[i].len;
          else
            v4 = newpos[ip_0] + (len - me->cells[i].len) / 2;
          newpos[ip_0] = v4;
        }
      }
      ++ip_0;
      i += colspan;
    }
    else
    {
      if ( me->cells[i].cLine > me->Line )
        return ip_0;
      i += colspan;
    }
  }
  return ip_0;
}

//----- (080F173C) --------------------------------------------------------
int __cdecl Stbl_getFixupPositions(STable_info *me, int lineno, int *oldpos, int *newpos)
{
  int ninserts; // [esp+18h] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-8h]
  STable_rowinfo *row; // [esp+20h] [ebp-4h]

  ninserts = -1;
  if ( !me || !me->nrows )
    return -1;
  for ( j = 0; me->nrows > j; ++j )
  {
    row = &me->rows[j];
    if ( row->Line == lineno )
      return get_fixup_positions(row, oldpos, newpos, me->sumcols);
  }
  return ninserts;
}

//----- (080F17D0) --------------------------------------------------------
int __cdecl Stbl_getStartLine(STable_info *me)
{
  if ( me )
    return me->startline;
  else
    return -1;
}

//----- (080F17F3) --------------------------------------------------------
int __cdecl Stbl_getStartLineDeep(STable_info *me)
{
  if ( !me )
    return -1;
  while ( me->enclosing )
    me = me->enclosing;
  return me->startline;
}

//----- (080F1827) --------------------------------------------------------
void __cdecl Stbl_update_enclosing(STable_info *me, int max_width, int last_lineno)
{
  int startline; // ebx
  FILE *v4; // edx
  FILE *v5; // eax
  STable_info *enclosing; // [esp+18h] [ebp-10h]
  _STable_info *stbl; // [esp+1Ch] [ebp-Ch]
  int l; // [esp+20h] [ebp-8h]

  if ( me && me->enclosing && max_width )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
    {
      startline = me->startline;
      v4 = TraceFP();
      fprintf(v4, "TRST:Stbl_update_enclosing, width=%d, lines=%d...%d.\n", max_width, startline, last_lineno);
    }
    for ( l = me->startline; l <= last_lineno; ++l )
    {
      if ( Stbl_finishCellInTable(me->enclosing, 0, l, 0, max_width) < 0 )
      {
        stbl = me->enclosing;
        if ( WWW_TraceFlag[0] && (WWW_TraceMask & 4) != 0 )
        {
          v5 = TraceFP();
          fprintf(v5, "TRST:Stbl_update_enclosing: width too large, aborting enclosing\n");
        }
        me->enclosing = 0;
        while ( stbl )
        {
          enclosing = stbl->enclosing;
          Stbl_free(stbl);
          stbl = enclosing;
        }
        return;
      }
    }
  }
}

//----- (080F194C) --------------------------------------------------------
void __cdecl Stbl_set_enclosing(
        STable_info *me,
        STable_info *enclosing,
        _TextAnchor *enclosing_last_anchor_before_stbl)
{
  if ( me )
  {
    me->enclosing = enclosing;
    me->enclosing_last_anchor_before_stbl = enclosing_last_anchor_before_stbl;
  }
}

//----- (080F1968) --------------------------------------------------------
STable_info *__cdecl Stbl_get_enclosing(STable_info *me)
{
  if ( me )
    return me->enclosing;
  else
    return 0;
}

//----- (080F198A) --------------------------------------------------------
_TextAnchor *__cdecl Stbl_get_last_anchor_before(STable_info *me)
{
  if ( me )
    return me->enclosing_last_anchor_before_stbl;
  else
    return 0;
}

//----- (080F19B0) --------------------------------------------------------
void __cdecl date_error(const char *s)
{
  ;
}

//----- (080F19B5) --------------------------------------------------------
time_t __cdecl ToSeconds(time_t Hours, time_t Minutes, time_t Seconds, MERIDIAN Meridian)
{
  if ( Minutes >= 0 && Minutes <= 59 && Seconds >= 0 && Seconds <= 61 )
  {
    if ( Meridian == MER24 )
    {
      if ( Hours < 0 || Hours > 23 )
        return -1;
    }
    else
    {
      if ( Hours <= 0 || Hours > 12 )
        return -1;
      if ( Hours == 12 )
        Hours = 0;
      if ( Meridian == MERpm )
        Hours += 12;
    }
    return 60 * (Minutes + 60 * Hours) + Seconds;
  }
  return -1;
}

//----- (080F1A52) --------------------------------------------------------
time_t __cdecl Convert(
        time_t Month,
        time_t Day,
        time_t Year,
        time_t Hours,
        time_t Minutes,
        time_t Seconds,
        MERIDIAN Meridian,
        DSTMODE dst)
{
  time_t tod; // [esp+24h] [ebp-14h] BYREF
  time_t Julian; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  const int *mp; // [esp+30h] [ebp-8h]
  const int *yp; // [esp+34h] [ebp-4h]

  if ( Year < 0 )
    Year = -Year;
  if ( Year <= 69 )
    Year += 2000;
  if ( Year <= 99 )
    Year += 1900;
  if ( Year <= 1969 )
    Year += 100;
  mp = DaysNormal_7977;
  for ( yp = LeapYears_7979; yp < dword_8170D64; ++yp )
  {
    if ( *yp == Year )
    {
      mp = DaysLeap_7978;
      break;
    }
  }
  if ( Year <= 1969 || Year > 2038 || Month <= 0 || Month > 12 || Day <= 0 || mp[Month] < Day )
    return -1;
  Julian = Day - 1 + 365 * Year - 719050;
  yp = LeapYears_7979;
  while ( yp < dword_8170D64 && *yp < Year )
  {
    ++yp;
    ++Julian;
  }
  for ( i = 1; i < Month; ++i )
    Julian += *++mp;
  Julian = 60 * yyTimezone + 86400 * Julian;
  tod = ToSeconds(Hours, Minutes, Seconds, Meridian);
  if ( tod < 0 )
    return -1;
  Julian += tod;
  tod = Julian;
  if ( dst == DSTon || dst == DSTmaybe && localtime(&tod)->tm_isdst )
    Julian -= 3600;
  return Julian;
}
// 8170D64: using guessed type int dword_8170D64[7];

//----- (080F1BEA) --------------------------------------------------------
time_t __cdecl DSTcorrect(time_t Start, time_t Future)
{
  struct tm *v2; // eax
  int StartDay; // [esp+20h] [ebp-8h]

  StartDay = (localtime(&Start)->tm_hour + 1) % 24;
  v2 = localtime(&Future);
  return Future - Start + 3600 * (StartDay - (v2->tm_hour + 1) % 24);
}

//----- (080F1C98) --------------------------------------------------------
time_t __cdecl RelativeMonth(time_t Start, time_t RelMonth)
{
  time_t v2; // eax
  time_t Month; // [esp+38h] [ebp-10h]
  struct tm *tm; // [esp+3Ch] [ebp-Ch]

  tm = localtime(&Start);
  Month = RelMonth + 12 * tm->tm_year + tm->tm_mon;
  v2 = Convert(Month % 12 + 1, tm->tm_mday, Month / 12 + 1900, tm->tm_hour, tm->tm_min, tm->tm_sec, MER24, DSTmaybe);
  return DSTcorrect(Start, v2);
}

//----- (080F1D89) --------------------------------------------------------
int __cdecl LookupWord(char *buff, int length)
{
  int c; // [esp+18h] [ebp-10h]
  int ca; // [esp+18h] [ebp-10h]
  YYSTYPE *tp; // [esp+1Ch] [ebp-Ch]
  const TABLE *tpa; // [esp+1Ch] [ebp-Ch]
  const TABLE *tpb; // [esp+1Ch] [ebp-Ch]
  const TABLE *tpc; // [esp+1Ch] [ebp-Ch]
  const TABLE *tpd; // [esp+1Ch] [ebp-Ch]
  const TABLE *tpe; // [esp+1Ch] [ebp-Ch]
  const char *q; // [esp+20h] [ebp-8h]
  char *qa; // [esp+20h] [ebp-8h]
  char *p; // [esp+24h] [ebp-4h]
  int lengtha; // [esp+34h] [ebp+Ch]
  int lengthb; // [esp+34h] [ebp+Ch]

  c = *buff;
  if ( length == 3 || length == 4 && buff[3] == 46 )
  {
    for ( tp = (YYSTYPE *)MonthDayTable; tp < (YYSTYPE *)"year"; tp += 3 )
    {
      q = (const char *)tp->Number;
      if ( *(char *)tp->Number == c && buff[1] == q[1] && buff[2] == q[2] )
      {
        yylval.Number = tp[2].Number;
        return tp[1].Number;
      }
    }
  }
  else
  {
    for ( tpa = MonthDayTable; tpa < (const TABLE *)"year"; ++tpa )
    {
      if ( *tpa->name == c && !strcmp(buff, tpa->name) )
      {
        yylval.Number = tpa->value;
        return tpa->type;
      }
    }
  }
  for ( tpb = TimezoneTable; tpb < &stru_8170D14; ++tpb )
  {
    if ( *tpb->name == c && buff[1] == *((_BYTE *)tpb->name + 1) && !strcmp(buff, tpb->name) )
    {
      yylval.Number = tpb->value;
      return tpb->type;
    }
  }
  if ( !strcmp(buff, "dst") )
    return 266;
  for ( tpc = UnitsTable; tpc < (const TABLE *)&unk_817098C; ++tpc )
  {
    if ( *tpc->name == c && !strcmp(buff, tpc->name) )
    {
      yylval.Number = tpc->value;
      return tpc->type;
    }
  }
  lengtha = length - 1;
  if ( lengtha > 0 && buff[lengtha] == 115 )
  {
    buff[lengtha] = 0;
    for ( tpd = UnitsTable; tpd < (const TABLE *)&unk_817098C; ++tpd )
    {
      if ( *tpd->name == c && !strcmp(buff, tpd->name) )
      {
        buff[lengtha] = 115;
        yylval.Number = tpd->value;
        return tpd->type;
      }
    }
    buff[lengtha] = 115;
  }
  lengthb = lengtha + 1;
  p = buff;
  for ( qa = buff; *qa; ++qa )
  {
    if ( *qa != 46 )
      *p++ = *qa;
  }
  *p = 0;
  if ( buff[1] == 109 && !buff[2] )
  {
    if ( *buff == 97 )
    {
      yylval.Number = 0;
      return 259;
    }
    if ( *buff == 112 )
    {
      yylval.Number = 1;
      return 259;
    }
  }
  if ( p - buff != lengthb )
  {
    ca = *buff;
    for ( tpe = TimezoneTable; tpe < &stru_8170D14; ++tpe )
    {
      if ( *tpe->name == ca && buff[1] == *((_BYTE *)tpe->name + 1) && !strcmp(buff, tpe->name) )
      {
        yylval.Number = tpe->value;
        return tpe->type;
      }
    }
  }
  yylval.Number = 0;
  return 265;
}
// 8170D14: using guessed type TABLE stru_8170D14;

//----- (080F213E) --------------------------------------------------------
int date_lex()
{
  int v1; // [esp+14h] [ebp-44h]
  int v2; // [esp+18h] [ebp-40h]
  YYSTYPE v3; // [esp+1Ch] [ebp-3Ch]
  char v5; // [esp+27h] [ebp-31h]
  int nesting; // [esp+2Ch] [ebp-2Ch]
  int i; // [esp+30h] [ebp-28h]
  int sign; // [esp+34h] [ebp-24h]
  char *p; // [esp+38h] [ebp-20h]
  int c; // [esp+3Ch] [ebp-1Ch]
  unsigned int ca; // [esp+3Ch] [ebp-1Ch]
  int cb; // [esp+3Ch] [ebp-1Ch]
  int cc; // [esp+3Ch] [ebp-1Ch]
  char buff[20]; // [esp+40h] [ebp-18h] BYREF
  unsigned int v15; // [esp+54h] [ebp-4h]

  v15 = __readgsdword(0x14u);
  while ( 1 )
  {
    while ( *yyInput >= 0 && ((*__ctype_b_loc())[*yyInput] & 0x2000) != 0 )
      ++yyInput;
    c = *yyInput;
    if ( c != 40 )
      break;
    nesting = 1;
    while ( 1 )
    {
      ca = *++yyInput;
      if ( ca == 41 && !--nesting )
        break;
      if ( ca == 40 )
      {
        ++nesting;
      }
      else
      {
        if ( ca > 0x7F )
          return 63;
        if ( !*yyInput )
          return 63;
        if ( ca == 13 )
          return 63;
        if ( ca == 92 && (!*++yyInput || (unsigned int)*yyInput > 0x7F) )
          return 63;
      }
    }
    ++yyInput;
  }
  if ( (c & 0x80u) == 0 && ((*__ctype_b_loc())[c] & 0x800) != 0 || c == 45 || c == 43 )
  {
    if ( c == 45 || c == 43 )
    {
      if ( c == 45 )
        v2 = -1;
      else
        v2 = 1;
      sign = v2;
      if ( *++yyInput < 0 || ((*__ctype_b_loc())[*yyInput] & 0x800) == 0 )
      {
        v1 = *--yyInput;
        ++yyInput;
        return v1;
      }
    }
    else
    {
      sign = 0;
    }
    for ( i = 0; ; i = cb + 10 * i - 48 )
    {
      cb = *yyInput++;
      if ( !cb || (cb & 0x80u) != 0 || ((*__ctype_b_loc())[cb] & 0x800) == 0 )
        break;
    }
    --yyInput;
    if ( sign >= 0 )
      v3.Number = i;
    else
      v3.Number = -i;
    yylval.Number = v3.Number;
    if ( sign )
      return 263;
    else
      return 264;
  }
  else if ( (c & 0x80u) == 0 && ((*__ctype_b_loc())[c] & 0x400) != 0 )
  {
    p = buff;
    while ( 1 )
    {
      cc = *yyInput++;
      if ( cc != 46 && ((cc & 0x80u) != 0 || ((*__ctype_b_loc())[cc] & 0x400) == 0) )
        break;
      if ( p < &buff[19] )
      {
        if ( (cc & 0x80u) == 0 && ((*__ctype_b_loc())[cc] & 0x100) != 0 )
          v5 = tolower(cc);
        else
          v5 = cc;
        *p++ = v5;
      }
    }
    *p = 0;
    --yyInput;
    return LookupWord(buff, p - buff);
  }
  else
  {
    return *yyInput++;
  }
}

//----- (080F2508) --------------------------------------------------------
int __cdecl GetTimeInfo(TIMEINFO *Now)
{
  timeval tv; // [esp+1Ch] [ebp-Ch] BYREF
  tm *tm; // [esp+24h] [ebp-4h]

  if ( gettimeofday(&tv, 0) != -1 )
  {
    Now->time = tv.tv_sec;
    Now->usec = tv.tv_usec;
    if ( Now->time - LastTime_8446 > 3600 )
    {
      LastTime_8446 = Now->time;
      tm = localtime(&Now->time);
      if ( !tm )
        return -1;
      LastTzone_8447 = -tm->tm_gmtoff / 60;
    }
    Now->tzone = LastTzone_8447;
    return 0;
  }
  return -1;
}

//----- (080F25C7) --------------------------------------------------------
time_t __cdecl parsedate(char *p, TIMEINFO *now)
{
  time_t v2; // eax
  TIMEINFO ti; // [esp+48h] [ebp-20h] BYREF
  time_t Start; // [esp+54h] [ebp-14h]
  tm *tm; // [esp+58h] [ebp-10h]

  yyInput = p;
  if ( !now )
  {
    now = &ti;
    GetTimeInfo(&ti);
  }
  tm = localtime(&now->time);
  yyYear = tm->tm_year + 1900;
  yyMonth = tm->tm_mon + 1;
  yyDay = tm->tm_mday;
  yyTimezone = now->tzone;
  if ( tm->tm_isdst )
    yyTimezone += 60;
  yyDSTmode = DSTmaybe;
  yyHour = 0;
  yyMinutes = 0;
  yySeconds = 0;
  yyMeridian = MER24;
  yyRelSeconds = 0;
  yyRelMonth = 0;
  yyHaveDate = 0;
  yyHaveRel = 0;
  yyHaveTime = 0;
  if ( date_parse() || yyHaveTime > 1 || yyHaveDate > 1 )
    return -1;
  if ( yyHaveDate || yyHaveTime )
  {
    Start = Convert(yyMonth, yyDay, yyYear, yyHour, yyMinutes, yySeconds, yyMeridian, yyDSTmode);
    if ( Start < 0 )
      return -1;
  }
  else
  {
    Start = now->time;
    if ( !yyHaveRel )
      Start += 60 * (-60 * tm->tm_hour - tm->tm_min) - tm->tm_sec;
  }
  Start += yyRelSeconds;
  if ( yyRelMonth )
  {
    v2 = RelativeMonth(Start, yyRelMonth);
    Start += v2;
  }
  if ( Start == -1 )
    return 0;
  else
    return Start;
}

//----- (080F27F3) --------------------------------------------------------
int yygrowstack()
{
  __int16 *v2; // [esp+10h] [ebp-18h]
  YYSTYPE *v3; // [esp+14h] [ebp-14h]
  unsigned int newsize; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( yystacksize )
  {
    if ( yystacksize > 0x1F3 )
      return -1;
    newsize = 2 * yystacksize;
    if ( 2 * yystacksize > 0x1F4 )
      newsize = 500;
  }
  else
  {
    newsize = 500;
  }
  i = yyssp - yyss;
  if ( yyss )
    v2 = (__int16 *)realloc(yyss, 2 * newsize);
  else
    v2 = (__int16 *)malloc(2 * newsize);
  if ( !v2 )
    return -1;
  yyss = v2;
  yyssp = &v2[i];
  if ( yyvs )
    v3 = (YYSTYPE *)realloc(yyvs, 4 * newsize);
  else
    v3 = (YYSTYPE *)malloc(4 * newsize);
  if ( !v3 )
    return -1;
  yyvs = v3;
  yyvsp = &v3[i];
  yystacksize = newsize;
  yysslim = &yyss[-(1 - newsize)];
  return 0;
}

//----- (080F2941) --------------------------------------------------------
int date_parse()
{
  int yystate; // [esp+28h] [ebp-10h]
  int yystatea; // [esp+28h] [ebp-10h]
  int yyn; // [esp+2Ch] [ebp-Ch]
  int yyna; // [esp+2Ch] [ebp-Ch]
  int yynb; // [esp+2Ch] [ebp-Ch]
  int yync; // [esp+2Ch] [ebp-Ch]
  int yynd; // [esp+2Ch] [ebp-Ch]
  int yym; // [esp+30h] [ebp-8h]
  int yyma; // [esp+30h] [ebp-8h]

  yynerrs = 0;
  yyerrflag = 0;
  yychar = -1;
  if ( yyss || !yygrowstack() )
  {
    yyssp = yyss;
    yyvsp = yyvs;
    yystate = 0;
    *yyss = 0;
    while ( 1 )
    {
      yyn = yydefred[yystate];
      if ( yydefred[yystate] )
        goto yyreduce;
      if ( yychar < 0 )
      {
        yychar = date_lex();
        if ( yychar < 0 )
          yychar = 0;
      }
      if ( yysindex[yystate] && (yyna = yychar + yysindex[yystate], yyna >= 0) && yyna <= 300 && yycheck[yyna] == yychar )
      {
        if ( yyssp >= yysslim && yygrowstack() )
          break;
        yystate = yytable[yyna];
        *++yyssp = yytable[yyna];
        ++yyvsp;
        yyvsp->Number = yylval.Number;
        yychar = -1;
        if ( yyerrflag > 0 )
          --yyerrflag;
      }
      else if ( yyrindex[yystate]
             && (yynb = yychar + yyrindex[yystate], yynb >= 0)
             && yynb <= 300
             && yycheck[yynb] == yychar )
      {
        yyn = yytable[yynb];
yyreduce:
        yym = yylen[yyn];
        if ( yylen[yyn] )
          yyval.Number = (time_t)yyvsp[1 - yym];
        else
          memset(&yyval, 0, sizeof(yyval));
        switch ( yyn )
        {
          case 3:
            ++yyHaveTime;
            goto LABEL_85;
          case 4:
            ++yyHaveTime;
            yyTimezone = yyvsp->Number;
            goto LABEL_85;
          case 5:
            ++yyHaveDate;
            goto LABEL_85;
          case 6:
            ++yyHaveDate;
            ++yyHaveTime;
            goto LABEL_85;
          case 7:
            ++yyHaveDate;
            ++yyHaveTime;
            yyTimezone = yyvsp->Number;
            goto LABEL_85;
          case 8:
            yyHaveRel = 1;
            goto LABEL_85;
          case 9:
            if ( yyvsp[-1].Number > 99 )
            {
              yyHour = yyvsp[-1].Number / 100;
              yyMinutes = yyvsp[-1].Number % 100;
            }
            else
            {
              yyHour = yyvsp[-1].Number;
              yyMinutes = 0;
            }
            yySeconds = 0;
            yyMeridian = yyvsp->Number;
            goto LABEL_85;
          case 10:
            yyHour = yyvsp[-3].Number;
            yyMinutes = yyvsp[-1].Number;
            yySeconds = 0;
            yyMeridian = yyvsp->Number;
            goto LABEL_85;
          case 11:
            yyHour = yyvsp[-3].Number;
            yyMinutes = yyvsp[-1].Number;
            yyTimezone = yyvsp->Number;
            yyMeridian = MER24;
            yyDSTmode = DSToff;
            goto LABEL_85;
          case 12:
            yyHour = yyvsp[-5].Number;
            yyMinutes = yyvsp[-3].Number;
            yySeconds = yyvsp[-1].Number;
            yyMeridian = yyvsp->Number;
            goto LABEL_85;
          case 13:
            yyHour = yyvsp[-5].Number;
            yyMinutes = yyvsp[-3].Number;
            yySeconds = yyvsp[-1].Number;
            yyTimezone = yyvsp->Number;
            yyMeridian = MER24;
            yyDSTmode = DSToff;
            goto LABEL_85;
          case 14:
            yyval.Number = yyvsp->Number;
            yyDSTmode = DSToff;
            goto LABEL_85;
          case 15:
            yyval.Number = yyvsp->Number;
            yyDSTmode = DSTon;
            goto LABEL_85;
          case 16:
            yyTimezone = yyvsp[-1].Number;
            yyDSTmode = DSTon;
            goto LABEL_85;
          case 17:
            if ( yyvsp[-1].Number )
              return 1;
            yyval.Number = yyvsp->Number;
            yyDSTmode = DSToff;
            goto LABEL_85;
          case 18:
            yyval.Number = yyvsp->Number;
            yyDSTmode = DSToff;
            goto LABEL_85;
          case 19:
            if ( yyvsp->Number >= 0 )
            {
              if ( yyvsp->Number > 9999 || yyvsp->Number % 100 > 59 )
                return 1;
              yyval.Number = -60 * (yyvsp->Number / 100) - yyvsp->Number % 100;
            }
            else
            {
              yyvsp->Number = -yyvsp->Number;
              if ( yyvsp->Number > 9999 || yyvsp->Number % 100 > 59 )
                return 1;
              yyval.Number = yyvsp->Number % 100 + 60 * (yyvsp->Number / 100);
            }
LABEL_85:
            yyssp -= yym;
            yystatea = *yyssp;
            yyvsp -= yym;
            yyma = yylhs[yyn];
            if ( yystatea || yylhs[yyn] )
            {
              if ( yygindex[yyma]
                && (yynd = yystatea + yygindex[yyma], yynd >= 0)
                && yynd <= 300
                && yycheck[yynd] == yystatea )
              {
                yystate = yytable[yynd];
              }
              else
              {
                yystate = yydgoto[yyma];
              }
              if ( yyssp >= yysslim && yygrowstack() )
                goto yyoverflow;
              *++yyssp = yystate;
              ++yyvsp;
              yyvsp->Number = yyval.Number;
            }
            else
            {
              yystate = 1;
              *++yyssp = 1;
              ++yyvsp;
              yyvsp->Number = yyval.Number;
              if ( yychar < 0 )
              {
                yychar = date_lex();
                if ( yychar < 0 )
                  yychar = 0;
              }
              if ( !yychar )
                return 0;
            }
            break;
          case 20:
            yyMonth = yyvsp[-2].Number;
            yyDay = yyvsp->Number;
            goto LABEL_85;
          case 21:
            if ( yyvsp[-4].Number <= 100 )
            {
              yyMonth = yyvsp[-4].Number;
              yyDay = yyvsp[-2].Number;
              yyYear = yyvsp->Number;
            }
            else
            {
              yyYear = yyvsp[-4].Number;
              yyMonth = yyvsp[-2].Number;
              yyDay = yyvsp->Number;
            }
            goto LABEL_85;
          case 22:
            yyMonth = yyvsp[-1].Number;
            yyDay = yyvsp->Number;
            goto LABEL_85;
          case 23:
            yyMonth = yyvsp[-3].Number;
            yyDay = yyvsp[-2].Number;
            yyYear = yyvsp->Number;
            goto LABEL_85;
          case 24:
            yyDay = yyvsp[-1].Number;
            yyMonth = yyvsp->Number;
            goto LABEL_85;
          case 25:
            yyDay = yyvsp[-2].Number;
            yyMonth = yyvsp[-1].Number;
            yyYear = yyvsp->Number;
            goto LABEL_85;
          case 26:
            yyDay = yyvsp[-2].Number;
            yyMonth = yyvsp[-1].Number;
            yyYear = yyvsp->Number;
            goto LABEL_85;
          case 27:
            yyDay = yyvsp[-3].Number;
            yyMonth = yyvsp[-1].Number;
            yyYear = -yyvsp->Number;
            goto LABEL_85;
          case 28:
            yyDay = yyvsp[-2].Number;
            yyMonth = -yyvsp[-1].Number;
            yyYear = -yyvsp->Number;
            yyDSTmode = DSToff;
            yyTimezone = 0;
            goto LABEL_85;
          case 29:
            yyMonth = yyvsp[-7].Number;
            yyDay = yyvsp[-6].Number;
            yyYear = yyvsp->Number;
            yyHour = yyvsp[-5].Number;
            yyMinutes = yyvsp[-3].Number;
            yySeconds = yyvsp[-1].Number;
            goto LABEL_85;
          case 30:
            yyRelSeconds += yyvsp->Number * yyvsp[-1].Number;
            goto LABEL_85;
          case 31:
            yyRelSeconds += yyvsp->Number * yyvsp[-1].Number;
            goto LABEL_85;
          case 32:
            yyRelMonth += yyvsp->Number * yyvsp[-1].Number;
            goto LABEL_85;
          case 33:
            yyRelMonth += yyvsp->Number * yyvsp[-1].Number;
            goto LABEL_85;
          case 34:
            yyval.Number = 2;
            goto LABEL_85;
          case 35:
            yyval.Number = yyvsp->Number;
            goto LABEL_85;
          default:
            goto LABEL_85;
        }
      }
      else
      {
        if ( !yyerrflag )
        {
          date_error("syntax error");
          ++yynerrs;
        }
        if ( yyerrflag > 2 )
        {
          if ( !yychar )
            return 1;
          yychar = -1;
        }
        else
        {
          yyerrflag = 3;
          while ( 1 )
          {
            if ( yysindex[*yyssp] )
            {
              yync = yysindex[*yyssp] + 256;
              if ( yync >= 0 && yync <= 300 && yycheck[yync] == 256 )
                break;
            }
            if ( yyssp <= yyss )
              return 1;
            --yyssp;
            --yyvsp;
          }
          if ( yyssp >= yysslim && yygrowstack() )
            break;
          yystate = yytable[yync];
          *++yyssp = yytable[yync];
          ++yyvsp;
          yyvsp->Number = yylval.Number;
        }
      }
    }
  }
yyoverflow:
  date_error("yacc stack overflow");
  return 1;
}

//----- (080F3548) --------------------------------------------------------
void __cdecl set_inverse_transl(int i)
{
  unsigned __int8 *v1; // [esp+14h] [ebp-14h]
  unsigned __int8 *q; // [esp+18h] [ebp-10h]
  int glyph; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]
  int ja; // [esp+24h] [ebp-4h]

  q = inverse_translations[i];
  if ( q
    || (!i ? (v1 = inv_norm_transl) : (v1 = (unsigned __int8 *)malloc(0x200u)),
        inverse_translations[i] = v1,
        (q = inverse_translations[i]) != 0) )
  {
    for ( j = 0; j <= 511; ++j )
      q[j] = 0;
    for ( ja = 0; ja <= 255; ++ja )
    {
      glyph = conv_uni_to_pc(translations[i][ja], 0);
      if ( glyph >= 0 && glyph <= 511 && q[glyph] <= 0x1Fu )
        q[glyph] = ja;
    }
  }
}

//----- (080F3637) --------------------------------------------------------
unsigned __int16 *__cdecl set_translate(int m)
{
  if ( !inverse_translations[m] )
    set_inverse_transl(m);
  inv_translate = inverse_translations[m];
  return translations[m];
}

//----- (080F3675) --------------------------------------------------------
int __cdecl UC_valid_UC_charset(int UC_charset_hndl)
{
  return UC_charset_hndl >= 0 && UC_charset_hndl < UCNumCharsets;
}

//----- (080F36A0) --------------------------------------------------------
void __cdecl UC_con_set_trans(int UC_charset_in_hndl, int Gn, int update_flag)
{
  FILE *v3; // edx
  unsigned __int16 *ptrans; // [esp+18h] [ebp-10h]
  const unsigned __int16 *p; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( UC_valid_UC_charset(UC_charset_in_hndl) )
  {
    ptrans = translations[Gn];
    p = UCInfo[UC_charset_in_hndl].unitable;
    for ( i = 0; i <= 255; ++i )
    {
      j = UCInfo[UC_charset_in_hndl].unicount[i];
      if ( UCInfo[UC_charset_in_hndl].unicount[i] )
      {
        ptrans[i] = *p;
        while ( j )
        {
          ++p;
          --j;
        }
      }
      else
      {
        ptrans[i] = -3;
      }
    }
    if ( update_flag )
      set_inverse_transl(Gn);
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "UC_con_set_trans: Invalid charset handle %d.\n", UC_charset_in_hndl);
  }
}

//----- (080F379B) --------------------------------------------------------
int __cdecl con_insert_unipair(unsigned __int16 unicode, unsigned __int16 fontpos, int fordefault)
{
  unsigned __int16 **v3; // ebx
  unsigned __int16 *p2; // [esp+14h] [ebp-14h]
  unsigned __int16 **p1; // [esp+18h] [ebp-10h]
  int n; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int ia; // [esp+20h] [ebp-8h]

  n = unicode >> 11;
  if ( fordefault )
    p1 = unidefault_pagedir[n];
  else
    p1 = uni_pagedir[n];
  if ( p1 )
  {
LABEL_13:
    p2 = p1[(unicode >> 6) & 0x1F];
    if ( !p2 )
    {
      v3 = &p1[(unicode >> 6) & 0x1F];
      *v3 = (unsigned __int16 *)malloc(0x80u);
      p2 = *v3;
      if ( !*v3 )
        return -1;
      for ( ia = 0; ia <= 63; ++ia )
        p2[ia] = -1;
    }
    p2[unicode & 0x3F] = fontpos;
    return 0;
  }
  p1 = (unsigned __int16 **)malloc(0x80u);
  if ( fordefault )
    unidefault_pagedir[n] = p1;
  else
    uni_pagedir[n] = p1;
  if ( p1 )
  {
    for ( i = 0; i <= 31; ++i )
      p1[i] = 0;
    goto LABEL_13;
  }
  return -1;
}

//----- (080F38F0) --------------------------------------------------------
int __cdecl con_insert_unipair_str(unsigned __int16 unicode, const char *replace_str, int fordefault)
{
  const char **p2; // [esp+14h] [ebp-14h]
  char ***p1; // [esp+18h] [ebp-10h]
  int n; // [esp+1Ch] [ebp-Ch]
  int na; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int ia; // [esp+20h] [ebp-8h]

  n = unicode >> 11;
  if ( fordefault )
    p1 = unidefault_pagedir_str[n];
  else
    p1 = uni_pagedir_str[n];
  if ( p1 )
  {
LABEL_13:
    na = (unicode >> 6) & 0x1F;
    if ( !p1[na] )
    {
      p1[na] = (char **)malloc(0x100u);
      if ( !p1[na] )
        return -1;
      p2 = (const char **)p1[na];
      for ( ia = 0; ia <= 63; ++ia )
        p2[ia] = 0;
    }
    p1[na][unicode & 0x3F] = (char *)replace_str;
    return 0;
  }
  p1 = (char ***)malloc(0x80u);
  if ( fordefault )
    unidefault_pagedir_str[n] = p1;
  else
    uni_pagedir_str[n] = p1;
  if ( p1 )
  {
    for ( i = 0; i <= 31; ++i )
      p1[i] = 0;
    goto LABEL_13;
  }
  return -1;
}

//----- (080F3A5A) --------------------------------------------------------
void __cdecl con_clear_unimap(int fordefault)
{
  unsigned __int16 **p1; // [esp+Ch] [ebp-Ch]
  unsigned __int16 **p1a; // [esp+Ch] [ebp-Ch]
  int j; // [esp+10h] [ebp-8h]
  int ja; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int ia; // [esp+14h] [ebp-4h]

  if ( fordefault )
  {
    for ( i = 0; i <= 31; ++i )
    {
      p1 = unidefault_pagedir[i];
      if ( p1 )
      {
        for ( j = 0; j <= 31; ++j )
        {
          if ( p1[j] )
          {
            free(p1[j]);
            p1[j] = 0;
          }
        }
        free(p1);
      }
      unidefault_pagedir[i] = 0;
    }
    unidefault_contents_valid = 1;
  }
  else
  {
    for ( ia = 0; ia <= 31; ++ia )
    {
      p1a = uni_pagedir[ia];
      if ( p1a )
      {
        for ( ja = 0; ja <= 31; ++ja )
        {
          if ( p1a[ja] )
          {
            free(p1a[ja]);
            p1a[ja] = 0;
          }
        }
        free(p1a);
      }
      uni_pagedir[ia] = 0;
    }
    hashtable_contents_valid = 1;
  }
}
// 80F3AD1: conditional instruction was optimized away because %p1.4!=0
// 80F3B77: conditional instruction was optimized away because %p1.4!=0

//----- (080F3BB3) --------------------------------------------------------
void __cdecl con_clear_unimap_str(int fordefault)
{
  char ***p1; // [esp+Ch] [ebp-Ch]
  char ***p1a; // [esp+Ch] [ebp-Ch]
  int j; // [esp+10h] [ebp-8h]
  int ja; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int ia; // [esp+14h] [ebp-4h]

  if ( fordefault )
  {
    for ( i = 0; i <= 31; ++i )
    {
      p1 = unidefault_pagedir_str[i];
      if ( p1 )
      {
        for ( j = 0; j <= 31; ++j )
        {
          if ( p1[j] )
          {
            free(p1[j]);
            p1[j] = 0;
          }
        }
        free(p1);
      }
      unidefault_pagedir_str[i] = 0;
    }
    unidefault_str_contents_valid = 1;
  }
  else
  {
    for ( ia = 0; ia <= 31; ++ia )
    {
      p1a = uni_pagedir_str[ia];
      if ( p1a )
      {
        for ( ja = 0; ja <= 31; ++ja )
        {
          if ( p1a[ja] )
          {
            free(p1a[ja]);
            p1a[ja] = 0;
          }
        }
        free(p1a);
      }
      uni_pagedir_str[ia] = 0;
    }
    hashtable_str_contents_valid = 1;
  }
}
// 80F3C2A: conditional instruction was optimized away because %p1.4!=0
// 80F3CD0: conditional instruction was optimized away because %p1.4!=0

//----- (080F3D0C) --------------------------------------------------------
void con_set_default_unimap()
{
  unsigned __int16 v0; // ax
  const unsigned __int16 *p; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  con_clear_unimap(1);
  p = dfont_unitable;
  for ( i = 0; i <= 255; ++i )
  {
    for ( j = dfont_unicount[i]; j; --j )
    {
      v0 = *p++;
      con_insert_unipair(v0, i, 1);
    }
  }
  UC_default_unitable = dfont_unitable;
  con_clear_unimap_str(1);
  UC_con_set_unimap_str(dfont_replacedesc.entry_ct, repl_map, 1);
  UC_default_unitable_str = &dfont_replacedesc;
}

//----- (080F3DC2) --------------------------------------------------------
int __cdecl UC_con_set_unimap(int UC_charset_out_hndl, int update_flag)
{
  FILE *v2; // eax
  unsigned __int16 v3; // ax
  const unsigned __int16 *p; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  if ( UC_valid_UC_charset(UC_charset_out_hndl) )
  {
    p = UCInfo[UC_charset_out_hndl].unitable;
    if ( p == UC_current_unitable )
    {
      return update_flag;
    }
    else
    {
      UC_current_unitable = UCInfo[UC_charset_out_hndl].unitable;
      con_clear_unimap(0);
      for ( i = 0; i <= 255; ++i )
      {
        for ( j = UCInfo[UC_charset_out_hndl].unicount[i]; j; --j )
        {
          v3 = *p++;
          con_insert_unipair(v3, i, 0);
        }
      }
      if ( update_flag )
      {
        for ( ia = 0; ia <= 3; ++ia )
          set_inverse_transl(ia);
      }
      return 0;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "UC_con_set_unimap: Invalid charset handle %d.\n", UC_charset_out_hndl);
    }
    return -1;
  }
}

//----- (080F3EEE) --------------------------------------------------------
int __cdecl UC_con_set_unimap_str(unsigned __int16 ct, unipair_str *list, int fordefault)
{
  int err1; // [esp+20h] [ebp-8h]
  int err; // [esp+24h] [ebp-4h]

  err = 0;
  while ( ct-- != 0 )
  {
    err1 = con_insert_unipair_str(list->unicode, list->replace_str, fordefault);
    if ( err1 )
      err = err1;
    ++list;
  }
  if ( !err )
  {
    if ( fordefault )
      unidefault_str_contents_valid = 1;
    else
      hashtable_str_contents_valid = 1;
  }
  return err;
}

//----- (080F3F71) --------------------------------------------------------
int __cdecl conv_uni_to_pc(int ucs, int usedefault)
{
  unsigned __int16 *p2; // [esp+8h] [ebp-Ch]
  unsigned __int16 **p1; // [esp+Ch] [ebp-8h]

  if ( ucs <= 0xFFFF )
  {
    if ( ucs <= 31 || ucs > 65533 )
      return -1;
    if ( ucs == 65279 || ucs > 8202 && ucs <= 8207 )
      return -2;
    if ( (ucs & 0xFFFFFE00) == 61440 )
      return ucs & 0x1FF;
  }
  else
  {
    ucs = 65533;
  }
  if ( usedefault )
  {
    if ( !unidefault_contents_valid )
      return -3;
    p1 = unidefault_pagedir[ucs >> 11];
  }
  else
  {
    if ( !hashtable_contents_valid )
      return -3;
    p1 = uni_pagedir[ucs >> 11];
  }
  if ( p1 && (p2 = p1[(ucs >> 6) & 0x1F]) != 0 && p2[ucs & 0x3F] <= 0x1FFu )
    return p2[ucs & 0x3F];
  else
    return -4;
}

//----- (080F408D) --------------------------------------------------------
int __cdecl conv_uni_to_str(char *outbuf, int buflen, int ucs, int usedefault)
{
  char **p2; // [esp+1Ch] [ebp-Ch]
  char ***p1; // [esp+20h] [ebp-8h]
  char *h; // [esp+24h] [ebp-4h]

  if ( ucs <= 0xFFFF )
  {
    if ( ucs <= 31 || ucs > 65533 )
      return -1;
    if ( ucs == 65279 || ucs > 8202 && ucs <= 8207 )
      return -2;
  }
  else
  {
    ucs = 65533;
  }
  if ( usedefault )
  {
    if ( !unidefault_str_contents_valid )
      return -3;
    p1 = unidefault_pagedir_str[ucs >> 11];
  }
  else
  {
    if ( !hashtable_str_contents_valid )
      return -3;
    p1 = uni_pagedir_str[ucs >> 11];
  }
  if ( !p1 )
    return -4;
  p2 = p1[(ucs >> 6) & 0x1F];
  if ( !p2 )
    return -4;
  h = p2[ucs & 0x3F];
  if ( !h )
    return -4;
  strncpy(outbuf, h, buflen - 1);
  return 1;
}

//----- (080F419E) --------------------------------------------------------
void UCconsole_map_init()
{
  con_set_default_unimap();
  UCInitialized = 1;
}

//----- (080F41B5) --------------------------------------------------------
int __cdecl UCTransUniChar(int unicode, int charset_out)
{
  int trydefault; // [esp+28h] [ebp-10h]
  int isdefault; // [esp+2Ch] [ebp-Ch]
  int UChndl_out; // [esp+30h] [ebp-8h]
  int rc; // [esp+34h] [ebp-4h]
  int rca; // [esp+34h] [ebp-4h]

  rc = 0;
  trydefault = 0;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if ( UChndl_out >= 0 )
  {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  else
  {
    if ( LYCharSet_UC[charset_out].codepage < 0 )
    {
      if ( unicode <= 127 )
        return unicode;
      else
        return LYCharSet_UC[charset_out].codepage;
    }
    UChndl_out = default_UChndl;
    if ( default_UChndl < 0 )
      return -12;
    isdefault = 1;
  }
  if ( !isdefault )
  {
    if ( UCInfo[UChndl_out].unitable != UC_current_unitable )
    {
      rca = UC_con_set_unimap(UChndl_out, 1);
      if ( rca < 0 )
        return rca;
    }
    rc = conv_uni_to_pc(unicode, 0);
    if ( rc >= 0 )
      return rc;
  }
  if ( isdefault || trydefault )
  {
    rc = conv_uni_to_pc(unicode, 1);
    if ( rc >= 0 )
      return rc;
  }
  if ( !isdefault && rc == -4 )
    rc = conv_uni_to_pc(65533, 0);
  if ( (isdefault || trydefault) && rc == -4 )
    return conv_uni_to_pc(65533, 1);
  return rc;
}

//----- (080F436C) --------------------------------------------------------
int __cdecl UCTransUniCharStr(char *outbuf, int buflen, int unicode, int charset_out, int chk_single_flag)
{
  FILE *v5; // eax
  char *tocode; // [esp+1Ch] [ebp-3Ch] BYREF
  size_t outleft; // [esp+20h] [ebp-38h] BYREF
  size_t inleft; // [esp+24h] [ebp-34h] BYREF
  char *pout; // [esp+28h] [ebp-30h] BYREF
  char *pin; // [esp+2Ch] [ebp-2Ch] BYREF
  iconv_t cd; // [esp+30h] [ebp-28h]
  const unsigned __int16 *ut; // [esp+34h] [ebp-24h]
  unimapdesc_str *repl; // [esp+38h] [ebp-20h]
  int trydefault; // [esp+3Ch] [ebp-1Ch]
  int isdefault; // [esp+40h] [ebp-18h]
  int UChndl_out; // [esp+44h] [ebp-14h]
  int ignore_err; // [esp+48h] [ebp-10h]
  int src; // [esp+4Ch] [ebp-Ch]
  int rc; // [esp+50h] [ebp-8h]
  char str[3]; // [esp+55h] [ebp-3h] BYREF

  rc = -14;
  src = 0;
  trydefault = 0;
  if ( buflen <= 1 )
    return -13;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if ( UChndl_out >= 0 )
  {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  else
  {
    if ( LYCharSet_UC[charset_out].codepage < 0 )
      return LYCharSet_UC[charset_out].codepage;
    UChndl_out = default_UChndl;
    if ( default_UChndl < 0 )
      return -12;
    isdefault = 1;
  }
  if ( chk_single_flag )
  {
    if ( !isdefault )
    {
      ut = UCInfo[UChndl_out].unitable;
      if ( ut != UC_current_unitable )
      {
        src = UC_con_set_unimap(UChndl_out, 1);
        if ( src < 0 )
          return src;
      }
    }
    src = conv_uni_to_pc(unicode, isdefault);
    if ( src > 31 )
    {
      *outbuf = src;
      outbuf[1] = 0;
      return 1;
    }
  }
  repl = (unimapdesc_str *)(60 * UChndl_out + 135995732);
  if ( isdefault )
    goto LABEL_65;
  if ( repl != UC_current_unitable_str )
  {
    con_clear_unimap_str(0);
    ignore_err = UC_con_set_unimap_str(repl->entry_ct, repl->entries, 0);
    UC_current_unitable_str = repl;
  }
  rc = conv_uni_to_str(outbuf, buflen, unicode, 0);
  if ( rc >= 0 )
    return strlen(outbuf);
LABEL_65:
  if ( trydefault && chk_single_flag && (src = conv_uni_to_pc(unicode, 1), src > 31) )
  {
    *outbuf = src;
    outbuf[1] = 0;
    return 1;
  }
  else
  {
    if ( isdefault || trydefault )
    {
      if ( !strcmp(LYCharSet_UC[charset_out].MIMEname, "shift_jis")
        || !strcmp(LYCharSet_UC[charset_out].MIMEname, "euc-jp") )
      {
        tocode = 0;
        str[0] = BYTE1(unicode);
        str[1] = unicode;
        str[2] = 0;
        pin = str;
        inleft = 2;
        pout = outbuf;
        outleft = buflen;
        HTSprintf0(&tocode, "%s//TRANSLIT", LYCharSet_UC[charset_out].MIMEname);
        cd = iconv_open(tocode, "UTF-16BE");
        if ( tocode )
        {
          free(tocode);
          tocode = 0;
        }
        if ( cd == (iconv_t)-1 )
          cd = iconv_open(LYCharSet_UC[charset_out].MIMEname, "UTF-16BE");
        rc = iconv(cd, &pin, &inleft, &pout, &outleft);
        iconv_close(cd);
        if ( pout - outbuf == 3 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v5 = TraceFP();
            fprintf(v5, "It seems to be a JIS X 0201 code(%ld). Not supported.\n", unicode);
          }
          pin = str;
          inleft = 2;
          pout = outbuf;
          outleft = buflen;
        }
        else if ( rc >= 0 )
        {
          *pout = 0;
          return strlen(outbuf);
        }
      }
      rc = conv_uni_to_str(outbuf, buflen, unicode, 1);
      if ( rc >= 0 )
        return strlen(outbuf);
    }
    if ( rc == -4 )
    {
      if ( !isdefault )
        rc = conv_uni_to_str(outbuf, buflen, 65533, 0);
      if ( rc == -4 && (isdefault || trydefault) )
        rc = conv_uni_to_str(outbuf, buflen, 65533, 1);
      if ( rc >= 0 )
        return strlen(outbuf);
    }
    if ( chk_single_flag && src == -4 )
    {
      if ( !isdefault )
        rc = conv_uni_to_pc(65533, 0);
      if ( rc == -4 && (isdefault || trydefault) )
        rc = conv_uni_to_pc(65533, 1);
      if ( rc <= 31 )
      {
        return rc;
      }
      else
      {
        *outbuf = rc;
        outbuf[1] = 0;
        return 1;
      }
    }
    else
    {
      return -4;
    }
  }
}

//----- (080F489E) --------------------------------------------------------
int __cdecl UC_MapGN(int UChndl, int update_flag)
{
  const char *MIMEname; // ebx
  FILE *v3; // edx
  int found; // [esp+28h] [ebp-10h]
  int Gn; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  found = 0;
  Gn = -1;
  for ( i = 0; i <= 3 && Gn < 0; ++i )
  {
    if ( UC_GNhandles[i] >= 0 )
    {
      if ( UC_GNhandles[i] == UChndl )
      {
        Gn = i;
        found = 1;
      }
    }
    else
    {
      Gn = i;
    }
  }
  if ( found )
    return Gn;
  if ( Gn < 0 )
  {
    if ( UC_lastautoGN == 1 )
      Gn = 2;
    else
      Gn = 1;
    UC_lastautoGN = Gn;
    UCInfo[UC_GNhandles[Gn]].GN = -1;
    UCInfo[UChndl].GN = Gn;
    UC_GNhandles[Gn] = UChndl;
  }
  else
  {
    UCInfo[UChndl].GN = Gn;
    UC_GNhandles[Gn] = UChndl;
  }
  if ( WWW_TraceFlag[0] )
  {
    MIMEname = UCInfo[UChndl].MIMEname;
    v3 = TraceFP();
    fprintf(v3, "UC_MapGN: Using %d <- %d (%s)\n", Gn, UChndl, MIMEname);
  }
  UC_con_set_trans(UChndl, Gn, update_flag);
  return Gn;
}

//----- (080F4A24) --------------------------------------------------------
int __cdecl UCTransChar(char ch_in, int charset_in, int charset_out)
{
  int upd; // [esp+24h] [ebp-24h]
  int trydefault; // [esp+2Ch] [ebp-1Ch]
  int isdefault; // [esp+30h] [ebp-18h]
  int UChndl_out; // [esp+34h] [ebp-14h]
  int UChndl_in; // [esp+38h] [ebp-10h]
  int rc; // [esp+3Ch] [ebp-Ch]
  int Gn; // [esp+40h] [ebp-8h]
  int unicode; // [esp+44h] [ebp-4h]

  rc = -4;
  trydefault = 0;
  upd = 0;
  if ( charset_in == charset_out )
    return (unsigned __int8)ch_in;
  if ( charset_in < 0 )
    return -11;
  UChndl_in = LYCharSet_UC[charset_in].UChndl;
  if ( UChndl_in < 0 )
    return -11;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if ( UChndl_out >= 0 )
  {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  else
  {
    if ( LYCharSet_UC[charset_out].codepage < 0 )
      return LYCharSet_UC[charset_out].codepage;
    UChndl_out = default_UChndl;
    if ( default_UChndl < 0 )
      return -12;
    isdefault = 1;
  }
  if ( !UCInfo[UChndl_in].num_uni )
    return -11;
  Gn = UCInfo[UChndl_in].GN;
  if ( Gn < 0 )
  {
    Gn = UC_MapGN(UChndl_in, 0);
    upd = 1;
  }
  if ( !isdefault )
  {
    if ( UCInfo[UChndl_out].unitable != UC_current_unitable )
    {
      rc = UC_con_set_unimap(UChndl_out, 1);
      if ( rc <= 0 )
      {
        if ( rc < 0 )
          return rc;
        goto LABEL_25;
      }
      goto LABEL_21;
    }
    if ( upd )
LABEL_21:
      set_inverse_transl(Gn);
  }
LABEL_25:
  UC_translate = set_translate(Gn);
  unicode = UC_translate[(unsigned __int8)ch_in];
  if ( !isdefault )
  {
    rc = conv_uni_to_pc(unicode, 0);
    if ( rc >= 0 )
      return rc;
  }
  if ( rc == -4 && (isdefault || trydefault) )
    rc = conv_uni_to_pc(unicode, 1);
  if ( rc == -4 && !isdefault )
    rc = conv_uni_to_pc(65533, 0);
  if ( rc == -4 && (isdefault || trydefault) )
    return conv_uni_to_pc(65533, 1);
  return rc;
}

//----- (080F4CCE) --------------------------------------------------------
UCode_t __cdecl UCTransJPToUni(char *inbuf, int buflen, int charset_in)
{
  iconv_t cd; // [esp+1Ch] [ebp-1Ch]
  size_t olen; // [esp+20h] [ebp-18h] BYREF
  size_t ilen; // [esp+24h] [ebp-14h] BYREF
  size_t rc; // [esp+28h] [ebp-10h]
  char *pout; // [esp+2Ch] [ebp-Ch] BYREF
  char *pin; // [esp+30h] [ebp-8h] BYREF
  char outbuf[3]; // [esp+35h] [ebp-3h] BYREF

  pin = inbuf;
  pout = outbuf;
  ilen = 2;
  olen = buflen;
  cd = iconv_open("UTF-16BE", LYCharSet_UC[charset_in].MIMEname);
  rc = iconv(cd, &pin, &ilen, &pout, &olen);
  iconv_close(cd);
  if ( ilen || olen )
    return -11;
  else
    return (unsigned __int8)outbuf[1] + ((unsigned __int8)outbuf[0] << 8);
}

//----- (080F4D75) --------------------------------------------------------
UCode_t __cdecl UCTransToUni(char ch_in, int charset_in)
{
  iconv_t cd; // [esp+30h] [ebp-28h]
  iconv_t cda; // [esp+30h] [ebp-28h]
  size_t olen; // [esp+34h] [ebp-24h] BYREF
  size_t ilen; // [esp+38h] [ebp-20h] BYREF
  size_t rc; // [esp+3Ch] [ebp-1Ch]
  char *pout; // [esp+40h] [ebp-18h] BYREF
  char *pin; // [esp+44h] [ebp-14h] BYREF
  int UChndl_in; // [esp+48h] [ebp-10h]
  int Gn; // [esp+4Ch] [ebp-Ch]
  char obuffer[3]; // [esp+54h] [ebp-4h] BYREF
  unsigned __int8 ch_iu; // [esp+57h] [ebp-1h]

  ch_iu = ch_in;
  if ( charset_in == LATIN1 )
    return ch_iu;
  if ( !strcmp(LYCharSet_UC[charset_in].MIMEname, "shift_jis") || !strcmp(LYCharSet_UC[charset_in].MIMEname, "euc-jp") )
  {
    pin = buffer_8152;
    pout = obuffer;
    olen = 2;
    ilen = 2;
    if ( !strcmp(LYCharSet_UC[charset_in].MIMEname, "shift_jis") )
    {
      if ( inx_8156 )
      {
        if ( (unsigned __int8)ch_in > 0x3Fu && ch_in != 127 && (unsigned __int8)ch_in <= 0xFCu )
        {
          byte_81B2131 = ch_in;
          byte_81B2132 = 0;
          cd = iconv_open("UTF-16BE", "Shift_JIS");
          rc = iconv(cd, &pin, &ilen, &pout, &olen);
          iconv_close(cd);
          inx_8156 = 0;
          if ( !ilen && !olen )
            return (unsigned __int8)obuffer[1] + ((unsigned __int8)obuffer[0] << 8);
        }
      }
      else if ( (unsigned __int8)ch_in > 0x80u && (unsigned __int8)ch_in <= 0x9Fu
             || (unsigned __int8)ch_in > 0xDFu && (unsigned __int8)ch_in <= 0xEFu )
      {
        buffer_8152[0] = ch_in;
        inx_8156 = 1;
        return -11;
      }
    }
    if ( !strcmp(LYCharSet_UC[charset_in].MIMEname, "euc-jp") )
    {
      if ( inx_8156 )
      {
        if ( (unsigned __int8)ch_in > 0xA0u && ch_in != -1 )
        {
          byte_81B2131 = ch_in;
          byte_81B2132 = 0;
          cda = iconv_open("UTF-16BE", "EUC-JP");
          rc = iconv(cda, &pin, &ilen, &pout, &olen);
          iconv_close(cda);
          inx_8156 = 0;
          if ( !ilen && !olen )
            return (unsigned __int8)obuffer[1] + ((unsigned __int8)obuffer[0] << 8);
        }
      }
      else if ( (unsigned __int8)ch_in > 0xA0u && ch_in != -1 )
      {
        buffer_8152[0] = ch_in;
        inx_8156 = 1;
        return -11;
      }
    }
    inx_8156 = 0;
  }
  if ( ch_in >= 0 && (unsigned __int8)ch_in > 0x1Fu )
    return ch_iu;
  if ( charset_in < 0 )
    return -11;
  if ( (unsigned __int8)ch_in <= 0x1Fu && LYCharSet_UC[charset_in].enc != 3 )
    return ch_iu;
  UChndl_in = LYCharSet_UC[charset_in].UChndl;
  if ( UChndl_in < 0 )
    return -11;
  if ( !UCInfo[UChndl_in].num_uni )
    return -11;
  Gn = UCInfo[UChndl_in].GN;
  if ( Gn < 0 )
    Gn = UC_MapGN(UChndl_in, 1);
  UC_translate = set_translate(Gn);
  return UC_translate[(unsigned __int8)ch_in];
}
// 81B2131: using guessed type char byte_81B2131;
// 81B2132: using guessed type char byte_81B2132;

//----- (080F5138) --------------------------------------------------------
int __cdecl UCReverseTransChar(char ch_out, int charset_in, int charset_out)
{
  int isdefault; // [esp+24h] [ebp-14h]
  int UChndl_out; // [esp+28h] [ebp-10h]
  int UChndl_in; // [esp+2Ch] [ebp-Ch]
  int rc; // [esp+30h] [ebp-8h]
  int Gn; // [esp+34h] [ebp-4h]

  rc = -1;
  if ( charset_in == charset_out )
    return (unsigned __int8)ch_out;
  if ( charset_in < 0 )
    return -11;
  UChndl_in = LYCharSet_UC[charset_in].UChndl;
  if ( UChndl_in < 0 )
    return -11;
  if ( !UCInfo[UChndl_in].num_uni )
    return -11;
  if ( charset_out < 0 )
    return -12;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if ( UChndl_out >= 0 )
  {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
  }
  else
  {
    if ( LYCharSet_UC[charset_out].codepage < 0 )
      return LYCharSet_UC[charset_out].codepage;
    UChndl_out = default_UChndl;
    if ( default_UChndl < 0 )
      return -12;
    isdefault = 1;
  }
  if ( isdefault || UCInfo[UChndl_out].unitable != UC_current_unitable )
    return UCTransChar(ch_out, charset_out, charset_in);
  Gn = UCInfo[UChndl_in].GN;
  if ( Gn < 0 )
    Gn = UC_MapGN(UChndl_in, 1);
  UC_translate = set_translate(Gn);
  if ( inv_translate )
    rc = inv_translate[(unsigned __int8)ch_out];
  if ( rc <= 31 )
    return UCTransChar(ch_out, charset_out, charset_in);
  else
    return rc;
}

//----- (080F5310) --------------------------------------------------------
int __cdecl UCTransCharStr(char *outbuf, int buflen, char ch_in, int charset_in, int charset_out, int chk_single_flag)
{
  int upd; // [esp+18h] [ebp-30h]
  int trydefault; // [esp+24h] [ebp-24h]
  int isdefault; // [esp+28h] [ebp-20h]
  int UChndl_out; // [esp+2Ch] [ebp-1Ch]
  int UChndl_in; // [esp+30h] [ebp-18h]
  int src; // [esp+38h] [ebp-10h]
  int srca; // [esp+38h] [ebp-10h]
  int rc; // [esp+3Ch] [ebp-Ch]
  int Gn; // [esp+40h] [ebp-8h]
  int unicode; // [esp+44h] [ebp-4h]

  rc = -14;
  src = 0;
  trydefault = 0;
  upd = 0;
  if ( buflen <= 1 )
    return -13;
  if ( chk_single_flag && charset_in == charset_out )
  {
    *outbuf = ch_in;
    outbuf[1] = 0;
    return 1;
  }
  if ( charset_in < 0 )
    return -11;
  UChndl_in = LYCharSet_UC[charset_in].UChndl;
  if ( UChndl_in < 0 )
    return -11;
  if ( !UCInfo[UChndl_in].num_uni )
    return -11;
  UChndl_out = LYCharSet_UC[charset_out].UChndl;
  if ( UChndl_out >= 0 )
  {
    isdefault = UCInfo[UChndl_out].replacedesc.isdefault;
    trydefault = UCInfo[UChndl_out].replacedesc.trydefault;
  }
  else
  {
    if ( LYCharSet_UC[charset_out].codepage < 0 )
      return LYCharSet_UC[charset_out].codepage;
    UChndl_out = default_UChndl;
    if ( default_UChndl < 0 )
      return -12;
    isdefault = 1;
  }
  Gn = UCInfo[UChndl_in].GN;
  if ( Gn < 0 )
  {
    Gn = UC_MapGN(UChndl_in, chk_single_flag == 0);
    upd = chk_single_flag;
  }
  UC_translate = set_translate(Gn);
  unicode = UC_translate[(unsigned __int8)ch_in];
  if ( chk_single_flag )
  {
    if ( isdefault )
      goto LABEL_29;
    if ( UCInfo[UChndl_out].unitable == UC_current_unitable )
    {
      if ( !upd )
        goto LABEL_29;
    }
    else
    {
      srca = UC_con_set_unimap(UChndl_out, 1);
      if ( srca <= 0 )
      {
        if ( srca < 0 )
          return srca;
        goto LABEL_29;
      }
    }
    set_inverse_transl(Gn);
LABEL_29:
    src = conv_uni_to_pc(unicode, isdefault);
    if ( src > 31 )
    {
      *outbuf = src;
      outbuf[1] = 0;
      return 1;
    }
  }
  if ( !isdefault )
  {
    if ( (unimapdesc_str *)(60 * UChndl_out + 135995732) != UC_current_unitable_str )
    {
      con_clear_unimap_str(0);
      UC_con_set_unimap_str(UCInfo[UChndl_out].replacedesc.entry_ct, UCInfo[UChndl_out].replacedesc.entries, 0);
      UC_current_unitable_str = (unimapdesc_str *)(60 * UChndl_out + 135995732);
    }
    rc = conv_uni_to_str(outbuf, buflen, unicode, 0);
    if ( rc >= 0 )
      return strlen(outbuf);
  }
  if ( trydefault )
  {
    if ( chk_single_flag )
    {
      src = conv_uni_to_pc(unicode, 1);
      if ( src > 31 )
      {
        *outbuf = src;
        outbuf[1] = 0;
        return 1;
      }
    }
  }
  if ( isdefault || trydefault )
  {
    rc = conv_uni_to_str(outbuf, buflen, unicode, 1);
    if ( rc >= 0 )
      return strlen(outbuf);
  }
  if ( rc == -4 )
  {
    if ( !isdefault )
      rc = conv_uni_to_str(outbuf, buflen, 65533, 0);
    if ( rc == -4 && (isdefault || trydefault) )
      rc = conv_uni_to_str(outbuf, buflen, 65533, 1);
    if ( rc >= 0 )
      return strlen(outbuf);
  }
  if ( !chk_single_flag || src != -4 )
    return -4;
  if ( !isdefault )
    rc = conv_uni_to_pc(65533, 0);
  if ( rc == -4 && (isdefault || trydefault) )
    rc = conv_uni_to_pc(65533, 1);
  if ( rc <= 31 )
  {
    if ( rc <= 0 )
      *outbuf = 0;
    return rc;
  }
  else
  {
    *outbuf = rc;
    outbuf[1] = 0;
    return 1;
  }
}

//----- (080F57E7) --------------------------------------------------------
int __cdecl UC_FindGN_byMIME(const char *UC_MIMEcharset)
{
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( !strcmp(UC_MIMEcharset, UC_GNsetMIMEnames[i]) )
      return i;
  }
  return -1;
}

//----- (080F5831) --------------------------------------------------------
int __cdecl UCGetRawUniMode_byLYhndl(int i)
{
  if ( i >= 0 )
    return LYCharSet_UC[i].enc;
  else
    return 0;
}

//----- (080F585A) --------------------------------------------------------
int __cdecl getLYhndl_byCP(const char *prefix, const char *codepage)
{
  char *cptmp; // [esp+10h] [ebp-8h] BYREF
  int result; // [esp+14h] [ebp-4h]

  result = -1;
  if ( nested_8520++ == 0 )
  {
    cptmp = 0;
    HTSACopy(&cptmp, prefix);
    HTSACat(&cptmp, codepage);
    result = UCGetLYhndl_byMIME(cptmp);
    if ( cptmp )
    {
      free(cptmp);
      cptmp = 0;
    }
  }
  --nested_8520;
  return result;
}

//----- (080F58E1) --------------------------------------------------------
int __cdecl UCGetLYhndl_byMIME(const char *value)
{
  FILE *v1; // eax
  FILE *v2; // eax
  int LYhndl; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( value && *value )
  {
    for ( i = 0; i <= 59 && i < LYNumCharsets && LYchar_set_names[i]; ++i )
    {
      if ( LYCharSet_UC[i].MIMEname && !strcasecomp(value, LYCharSet_UC[i].MIMEname) )
        return i;
    }
    if ( strcasecomp(value, "unicode-1-1-utf-8") && strcasecomp(value, "utf8") )
    {
      if ( strcasecomp(value, "x-euc-jp") )
      {
        if ( strcasecomp(value, "x-shift-jis") && strcasecomp(value, "x-sjis") )
        {
          if ( strcasecomp(value, "iso-2022-kr") )
          {
            if ( strcasecomp(value, "gb2312") && strncasecomp(value, "cn-gb", 5) && strcasecomp(value, "iso-2022-cn") )
            {
              if ( strcasecomp(value, "cn-big5") )
              {
                if ( strcasecomp(value, "x-mac-roman") && strcasecomp(value, "mac-roman") )
                {
                  if ( strcasecomp(value, "x-next")
                    && strcasecomp(value, "nextstep")
                    && strcasecomp(value, "x-nextstep") )
                  {
                    if ( strcasecomp(value, "iso-8859-1-windows-3.1-latin-1")
                      && strcasecomp(value, "cp1252")
                      && strcasecomp(value, "cp-1252")
                      && strcasecomp(value, "ibm1252")
                      && strcasecomp(value, "iso-8859-1-windows-3.0-latin-1") )
                    {
                      if ( strcasecomp(value, "iso-8859-2-windows-latin-2")
                        && strcasecomp(value, "cp1250")
                        && strcasecomp(value, "cp-1250")
                        && strcasecomp(value, "ibm1250") )
                      {
                        if ( (!strncasecomp(value, "ibm", 3) || !strncasecomp(value, "cp-", 3))
                          && ((*__ctype_b_loc())[*((unsigned __int8 *)value + 3)] & 0x800) != 0
                          && ((*__ctype_b_loc())[*((unsigned __int8 *)value + 4)] & 0x800) != 0
                          && ((*__ctype_b_loc())[*((unsigned __int8 *)value + 5)] & 0x800) != 0 )
                        {
                          LYhndl = getLYhndl_byCP("cp", value + 3);
                          if ( LYhndl < 0 )
                            return getLYhndl_byCP("windows-", value + 3);
                          else
                            return LYhndl;
                        }
                        else if ( !strncasecomp(value, "windows-", 8)
                               && ((*__ctype_b_loc())[*((unsigned __int8 *)value + 8)] & 0x800) != 0
                               && ((*__ctype_b_loc())[*((unsigned __int8 *)value + 9)] & 0x800) != 0
                               && ((*__ctype_b_loc())[*((unsigned __int8 *)value + 10)] & 0x800) != 0 )
                        {
                          return getLYhndl_byCP("cp", value + 8);
                        }
                        else if ( strcasecomp(value, "koi-8") )
                        {
                          if ( strcasecomp(value, "ANSI_X3.4-1968") )
                          {
                            if ( WWW_TraceFlag[0] )
                            {
                              v2 = TraceFP();
                              fprintf(v2, "UCGetLYhndl_byMIME: unrecognized MIME name \"%s\"\n", value);
                            }
                            return -1;
                          }
                          else
                          {
                            return US_ASCII;
                          }
                        }
                        else
                        {
                          return UCGetLYhndl_byMIME("koi8-r");
                        }
                      }
                      else
                      {
                        return UCGetLYhndl_byMIME("windows-1250");
                      }
                    }
                    else
                    {
                      return UCGetLYhndl_byMIME("windows-1252");
                    }
                  }
                  else
                  {
                    return UCGetLYhndl_byMIME("next");
                  }
                }
                else
                {
                  return UCGetLYhndl_byMIME("macintosh");
                }
              }
              else
              {
                return UCGetLYhndl_byMIME("big5");
              }
            }
            else
            {
              return UCGetLYhndl_byMIME("euc-cn");
            }
          }
          else
          {
            return UCGetLYhndl_byMIME("euc-kr");
          }
        }
        else
        {
          return UCGetLYhndl_byMIME("shift_jis");
        }
      }
      else
      {
        return UCGetLYhndl_byMIME("euc-jp");
      }
    }
    else
    {
      return UCGetLYhndl_byMIME("utf-8");
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "UCGetLYhndl_byMIME: NULL argument instead of MIME name.\n");
    }
    return -1;
  }
}

//----- (080F5EBD) --------------------------------------------------------
void UCreset_allocated_LYCharSets()
{
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i <= 59; ++i )
    remember_allocated_LYCharSets[i] = 0;
}

//----- (080F5EE6) --------------------------------------------------------
const char **__cdecl UC_setup_LYCharSets_repl(int UC_charset_in_hndl, unsigned int lowest8)
{
  unipair_str *list; // [esp+24h] [ebp-34h]
  unsigned __int8 *ti; // [esp+28h] [ebp-30h]
  int changed; // [esp+2Ch] [ebp-2Ch]
  int j; // [esp+30h] [ebp-28h]
  size_t i; // [esp+34h] [ebp-24h]
  size_t ia; // [esp+34h] [ebp-24h]
  unsigned int ib; // [esp+34h] [ebp-24h]
  size_t ic; // [esp+34h] [ebp-24h]
  const char *s8; // [esp+38h] [ebp-20h]
  const char *s7; // [esp+3Ch] [ebp-1Ch]
  char **tp; // [esp+40h] [ebp-18h]
  const unsigned __int16 *pp; // [esp+44h] [ebp-14h]
  char **prepl; // [esp+48h] [ebp-10h]
  const char **p; // [esp+4Ch] [ebp-Ch]
  const char **ISO_Latin1; // [esp+50h] [ebp-8h]
  unsigned __int16 ct; // [esp+54h] [ebp-4h]
  unsigned __int16 k; // [esp+56h] [ebp-2h]
  unsigned __int16 ka; // [esp+56h] [ebp-2h]

  ISO_Latin1 = LYCharSets[0];
  tp = (char **)malloc(0x180u);
  if ( !tp )
    return 0;
  for ( i = 0; i <= 0x5F; ++i )
    tp[i] = 0;
  ti = (unsigned __int8 *)malloc(0x60u);
  if ( ti )
  {
    for ( ia = 0; ia <= 0x5F; ++ia )
      ti[ia] = 0;
    pp = UCInfo[UC_charset_in_hndl].unitable;
    if ( UCInfo[UC_charset_in_hndl].num_uni > 0 )
    {
      for ( ib = 0; ib <= 0xFF; ++ib )
      {
        j = UCInfo[UC_charset_in_hndl].unicount[ib];
        if ( UCInfo[UC_charset_in_hndl].unicount[ib] )
        {
          k = *pp;
          if ( *pp > 0x9Fu && k <= 0xFFu && ib >= lowest8 )
            ti[k - 160] = ib;
          while ( j )
          {
            ++pp;
            --j;
          }
        }
      }
    }
    ct = UCInfo[UC_charset_in_hndl].replacedesc.entry_ct;
    for ( list = UCInfo[UC_charset_in_hndl].replacedesc.entries; ct-- != 0; ++list )
    {
      ka = list->unicode;
      if ( list->unicode > 0x9Fu && ka <= 0xFFu )
        tp[ka - 160] = (char *)list->replace_str;
    }
    prepl = (char **)malloc(4 * HTML_dtd.number_of_entities);
    if ( prepl )
    {
      p = (const char **)prepl;
      changed = 0;
      for ( ic = 0; HTML_dtd.number_of_entities > ic; ++ic )
      {
        s7 = SevenBitApproximations[ic];
        s8 = ISO_Latin1[ic];
        *p = s7;
        if ( s8 && *s8 > 0x9Fu && !s8[1] )
        {
          if ( ti[*(unsigned __int8 *)s8 - 160] < (unsigned __int8)lowest8
            || *s7 == ti[*(unsigned __int8 *)s8 - 160] && !s7[1] )
          {
            if ( tp[*(unsigned __int8 *)s8 - 160] && strcmp(s7, tp[*(unsigned __int8 *)s8 - 160]) )
            {
              *p = tp[*(unsigned __int8 *)s8 - 160];
              changed = 1;
            }
          }
          else
          {
            if ( ti[*(unsigned __int8 *)s8 - 160] == *s8 )
            {
              *p = s8;
            }
            else
            {
              dummy_8793[0] = ti[*(unsigned __int8 *)s8 - 160];
              *p = HTAtom_for(dummy_8793)->name;
            }
            changed = 1;
          }
        }
        ++p;
      }
      free(tp);
      free(ti);
      if ( changed )
      {
        return (const char **)prepl;
      }
      else
      {
        free(prepl);
        return 0;
      }
    }
    else
    {
      free(tp);
      free(ti);
      return 0;
    }
  }
  else
  {
    free(tp);
    return 0;
  }
}
// 80F5F50: conditional instruction was optimized away because %tp.4!=0
// 80F60E9: conditional instruction was optimized away because %tp.4!=0
// 80F6101: conditional instruction was optimized away because %ti.4!=0
// 80F62B3: conditional instruction was optimized away because %tp.4!=0
// 80F62CB: conditional instruction was optimized away because %ti.4!=0
// 80F62E9: conditional instruction was optimized away because %prepl.4!=0

//----- (080F6311) --------------------------------------------------------
int __cdecl UC_Register_with_LYCharSets(
        int s,
        const char *UC_MIMEcharset,
        const char *UC_LYNXcharset,
        int lowest_eightbit)
{
  FILE *v4; // edx
  const char **repl; // [esp+18h] [ebp-10h]
  int found; // [esp+1Ch] [ebp-Ch]
  int LYhndl; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  LYhndl = -1;
  if ( !LYNumCharsets )
  {
    for ( i = 0; i <= 59 && LYchar_set_names[i]; ++i )
      LYNumCharsets = i + 1;
  }
  for ( ia = 0; ia <= 59 && LYchar_set_names[ia] && LYhndl < 0; ++ia )
  {
    if ( LYCharSet_UC[ia].MIMEname && !strcmp(UC_MIMEcharset, LYCharSet_UC[ia].MIMEname) )
      LYhndl = ia;
  }
  if ( LYhndl >= 0 )
  {
    found = 1;
  }
  else
  {
    found = 0;
    if ( LYNumCharsets > 59 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "UC_Register_with_LYCharSets: Too many.  Ignoring %s/%s.", UC_MIMEcharset, UC_LYNXcharset);
      }
      return -1;
    }
    LYhndl = LYNumCharsets++;
    LYlowest_eightbit[LYhndl] = 999;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl + 1] = 0;
  }
  LYCharSet_UC[LYhndl].UChndl = s;
  LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
  LYCharSet_UC[LYhndl].enc = UCInfo[s].enc;
  LYCharSet_UC[LYhndl].codepage = UCInfo[s].codepage;
  if ( LYlowest_eightbit[LYhndl] <= lowest_eightbit )
  {
    if ( LYlowest_eightbit[LYhndl] < lowest_eightbit )
      UCInfo[s].lowest_eight = LYlowest_eightbit[LYhndl];
  }
  else
  {
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
  }
  if ( !found && LYhndl > 0 )
  {
    repl = UC_setup_LYCharSets_repl(s, UCInfo[s].lowest_eight);
    if ( repl )
    {
      LYCharSets[LYhndl] = repl;
      remember_allocated_LYCharSets[LYhndl] = repl;
    }
  }
  return LYhndl;
}

//----- (080F657C) --------------------------------------------------------
void __cdecl UC_Charset_Setup(
        const char *UC_MIMEcharset,
        const char *UC_LYNXcharset,
        const unsigned __int8 *unicount,
        const unsigned __int16 *unitable,
        int nnuni,
        unimapdesc_str replacedesc,
        int lowest_eight,
        int UC_rawuni,
        int codepage)
{
  FILE *v9; // edx
  int found; // [esp+20h] [ebp-18h]
  int i; // [esp+28h] [ebp-10h]
  int Gn; // [esp+2Ch] [ebp-Ch]
  int s; // [esp+30h] [ebp-8h]

  found = -1;
  for ( i = 0; i < UCNumCharsets && found < 0; ++i )
  {
    if ( !strcmp(UCInfo[i].MIMEname, UC_MIMEcharset) )
      found = i;
  }
  if ( found >= 0 )
  {
    s = found;
LABEL_13:
    UCInfo[s].LYNXname = UC_LYNXcharset;
    UCInfo[s].unicount = unicount;
    UCInfo[s].unitable = unitable;
    UCInfo[s].num_uni = nnuni;
    UCInfo[s].replacedesc = replacedesc;
    if ( replacedesc.isdefault )
      default_UChndl = s;
    Gn = UC_FindGN_byMIME(UC_MIMEcharset);
    if ( Gn >= 0 )
      UC_GNhandles[Gn] = s;
    UCInfo[s].GN = Gn;
    if ( UC_rawuni == 7 )
      lowest_eight = 128;
    UCInfo[s].lowest_eight = lowest_eight;
    UCInfo[s].enc = UC_rawuni;
    UCInfo[s].codepage = codepage;
    UCInfo[s].LYhndl = UC_Register_with_LYCharSets(s, UC_MIMEcharset, UC_LYNXcharset, lowest_eight);
    UCInfo[s].uc_status = 0;
    if ( found < 0 )
      ++UCNumCharsets;
    return;
  }
  if ( UCNumCharsets <= 59 )
  {
    s = UCNumCharsets;
    UCInfo[UCNumCharsets].MIMEname = UC_MIMEcharset;
    goto LABEL_13;
  }
  if ( WWW_TraceFlag[0] )
  {
    v9 = TraceFP();
    fprintf(v9, "UC_Charset_Setup: Too many.  Ignoring %s/%s.", UC_MIMEcharset, UC_LYNXcharset);
  }
}

//----- (080F67FF) --------------------------------------------------------
int __cdecl UC_NoUctb_Register_with_LYCharSets(
        const char *UC_MIMEcharset,
        const char *UC_LYNXcharset,
        int lowest_eightbit,
        int UC_rawuni,
        int codepage)
{
  FILE *v5; // edx
  int LYhndl; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int ia; // [esp+24h] [ebp-4h]

  if ( !LYNumCharsets )
  {
    for ( i = 0; i <= 59 && LYchar_set_names[i]; ++i )
      LYNumCharsets = i + 1;
  }
  for ( ia = 0; ia <= 59 && LYchar_set_names[ia]; ++ia )
  {
    if ( LYCharSet_UC[ia].MIMEname && !strcmp(UC_MIMEcharset, LYCharSet_UC[ia].MIMEname) )
      return -1;
  }
  if ( LYNumCharsets <= 59 )
  {
    LYhndl = LYNumCharsets++;
    LYlowest_eightbit[LYhndl] = lowest_eightbit;
    LYCharSets[LYhndl] = SevenBitApproximations;
    LYchar_set_names[LYhndl] = UC_LYNXcharset;
    LYchar_set_names[LYhndl + 1] = 0;
    LYCharSet_UC[LYhndl].UChndl = -1;
    LYCharSet_UC[LYhndl].MIMEname = UC_MIMEcharset;
    LYCharSet_UC[LYhndl].enc = UC_rawuni;
    LYCharSet_UC[LYhndl].codepage = codepage;
    return LYhndl;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "UC_NoUctb_Register_with_LYCharSets: Too many.  Ignoring %s/%s.", UC_MIMEcharset, UC_LYNXcharset);
    }
    return -1;
  }
}
// 80F68A1: conditional instruction was optimized away because %LYhndl.4==FFFFFFFF

//----- (080F6987) --------------------------------------------------------
void __cdecl UC_Charset_NoUctb_Setup(
        const char *UC_MIMEcharset,
        const char *UC_LYNXcharset,
        int trydefault,
        int lowest_eight,
        int UC_rawuni,
        int codepage)
{
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < UCNumCharsets; ++i )
  {
    if ( !strcmp(UCInfo[i].MIMEname, UC_MIMEcharset) )
      return;
  }
  if ( UC_rawuni == 7 )
    lowest_eight = 128;
  if ( !trydefault && !codepage )
    codepage = -12;
  UC_NoUctb_Register_with_LYCharSets(UC_MIMEcharset, UC_LYNXcharset, lowest_eight, UC_rawuni, codepage);
}

//----- (080F6A17) --------------------------------------------------------
void UCInit()
{
  UCreset_allocated_LYCharSets();
  UCconsole_map_init();
  UC_Charset_Setup(
    "iso-8859-1",
    "Western (ISO-8859-1)",
    dfont_unicount_iso_8859_1,
    dfont_unitable_iso_8859_1,
    201,
    dfont_replacedesc_iso_8859_1,
    160,
    2,
    819);
  UC_Charset_Setup(
    "iso-8859-15",
    "Western (ISO-8859-15)",
    dfont_unicount_iso_8859_15,
    dfont_unitable_iso_8859_15,
    191,
    dfont_replacedesc_iso_8859_15,
    160,
    2,
    0);
  UC_Charset_Setup(
    "cp850",
    "Western (cp850)",
    dfont_unicount_cp850,
    dfont_unitable_cp850,
    247,
    dfont_replacedesc_cp850,
    128,
    1,
    850);
  UC_Charset_Setup(
    "windows-1252",
    "Western (windows-1252)",
    dfont_unicount_windows_1252,
    dfont_unitable_windows_1252,
    229,
    dfont_replacedesc_windows_1252,
    128,
    1,
    1252);
  UC_Charset_Setup(
    "cp437",
    "IBM PC US codepage (cp437)",
    dfont_unicount_cp437,
    dfont_unitable_cp437,
    247,
    dfont_replacedesc_cp437,
    128,
    1,
    437);
  UC_Charset_Setup(
    "dec-mcs",
    "DEC Multinational",
    dfont_unicount_dec_mcs,
    dfont_unitable_dec_mcs,
    176,
    dfont_replacedesc_dec_mcs,
    161,
    2,
    0);
  UC_Charset_Setup(
    "macintosh",
    "Macintosh (8 bit)",
    dfont_unicount_macintosh,
    dfont_unitable_macintosh,
    226,
    dfont_replacedesc_macintosh,
    128,
    1,
    0);
  UC_Charset_Setup(
    "next",
    "NeXT character set",
    dfont_unicount_next,
    dfont_unitable_next,
    222,
    dfont_replacedesc_next,
    128,
    1,
    0);
  UC_Charset_Setup(
    "hp-roman8",
    "HP Roman8",
    dfont_unicount_hp_roman8,
    dfont_unitable_hp_roman8,
    190,
    dfont_replacedesc_hp_roman8,
    160,
    1,
    0);
  UC_Charset_NoUctb_Setup("euc-cn", "Chinese", 1, 128, 5, 0);
  UC_Charset_NoUctb_Setup("euc-jp", "Japanese (EUC-JP)", 1, 128, 5, 0);
  UC_Charset_NoUctb_Setup("shift_jis", "Japanese (Shift_JIS)", 1, 128, 5, 0);
  UC_Charset_NoUctb_Setup("euc-kr", "Korean", 1, 128, 5, 0);
  UC_Charset_NoUctb_Setup("big5", "Taipei (Big5)", 1, 128, 5, 0);
  UC_Charset_Setup(
    "viscii",
    "Vietnamese (VISCII)",
    dfont_unicount_viscii,
    dfont_unitable_viscii,
    142,
    dfont_replacedesc_viscii,
    128,
    3,
    0);
  UC_Charset_Setup(
    "us-ascii",
    "7 bit approximations (US-ASCII)",
    dfont_unicount,
    dfont_unitable,
    616,
    dfont_replacedesc,
    999,
    0,
    0);
  UC_Charset_NoUctb_Setup("x-transparent", "Transparent", 0, 128, 1, 0);
  UC_Charset_Setup(
    "iso-8859-2",
    "Eastern European (ISO-8859-2)",
    dfont_unicount_iso_8859_2,
    dfont_unitable_iso_8859_2,
    209,
    dfont_replacedesc_iso_8859_2,
    160,
    2,
    912);
  UC_Charset_Setup(
    "cp852",
    "Eastern European (cp852)",
    dfont_unicount_cp852,
    dfont_unitable_cp852,
    251,
    dfont_replacedesc_cp852,
    128,
    1,
    852);
  UC_Charset_Setup(
    "windows-1250",
    "Eastern European (windows-1250)",
    dfont_unicount_windows_1250,
    dfont_unitable_windows_1250,
    235,
    dfont_replacedesc_windows_1250,
    128,
    1,
    1250);
  UC_Charset_Setup(
    "iso-8859-3",
    "Latin 3 (ISO-8859-3)",
    dfont_unicount_iso_8859_3,
    dfont_unitable_iso_8859_3,
    184,
    dfont_replacedesc_iso_8859_3,
    160,
    2,
    913);
  UC_Charset_Setup(
    "iso-8859-4",
    "Latin 4 (ISO-8859-4)",
    dfont_unicount_iso_8859_4,
    dfont_unitable_iso_8859_4,
    97,
    dfont_replacedesc_iso_8859_4,
    160,
    2,
    914);
  UC_Charset_Setup(
    "iso-8859-13",
    "Baltic Rim (ISO-8859-13)",
    dfont_unicount_iso_8859_13,
    dfont_unitable_iso_8859_13,
    191,
    dfont_replacedesc_iso_8859_13,
    160,
    2,
    0);
  UC_Charset_Setup(
    "cp775",
    "Baltic Rim (cp775)",
    dfont_unicount_cp775,
    dfont_unitable_cp775,
    223,
    dfont_replacedesc_cp775,
    128,
    1,
    775);
  UC_Charset_Setup(
    "windows-1257",
    "Baltic Rim (windows-1257)",
    dfont_unicount_windows_1257,
    dfont_unitable_windows_1257,
    211,
    dfont_replacedesc_windows_1257,
    128,
    1,
    1257);
  UC_Charset_Setup(
    "iso-8859-5",
    "Cyrillic (ISO-8859-5)",
    dfont_unicount_iso_8859_5,
    dfont_unitable_iso_8859_5,
    208,
    dfont_replacedesc_iso_8859_5,
    160,
    2,
    915);
  UC_Charset_Setup(
    "cp866",
    "Cyrillic (cp866)",
    dfont_unicount_cp866,
    dfont_unitable_cp866,
    224,
    dfont_replacedesc_cp866,
    128,
    1,
    866);
  UC_Charset_Setup(
    "windows-1251",
    "Cyrillic (windows-1251)",
    dfont_unicount_windows_1251,
    dfont_unitable_windows_1251,
    222,
    dfont_replacedesc_windows_1251,
    128,
    1,
    1251);
  UC_Charset_Setup(
    "koi8-r",
    "Cyrillic (KOI8-R)",
    dfont_unicount_koi8_r,
    dfont_unitable_koi8_r,
    239,
    dfont_replacedesc_koi8_r,
    128,
    1,
    878);
  UC_Charset_Setup(
    "iso-8859-6",
    "Arabic (ISO-8859-6)",
    dfont_unicount_iso_8859_6,
    dfont_unitable_iso_8859_6,
    146,
    dfont_replacedesc_iso_8859_6,
    160,
    2,
    1089);
  UC_Charset_Setup(
    "cp864",
    "Arabic (cp864)",
    dfont_unicount_cp864,
    dfont_unitable_cp864,
    218,
    dfont_replacedesc_cp864,
    128,
    1,
    864);
  UC_Charset_Setup(
    "windows-1256",
    "Arabic (windows-1256)",
    dfont_unicount_windows_1256,
    dfont_unitable_windows_1256,
    223,
    dfont_replacedesc_windows_1256,
    128,
    1,
    1256);
  UC_Charset_Setup(
    "iso-8859-14",
    "Celtic (ISO-8859-14)",
    dfont_unicount_iso_8859_14,
    dfont_unitable_iso_8859_14,
    191,
    dfont_replacedesc_iso_8859_14,
    160,
    2,
    0);
  UC_Charset_Setup(
    "iso-8859-7",
    "Greek (ISO-8859-7)",
    dfont_unicount_iso_8859_7,
    dfont_unitable_iso_8859_7,
    220,
    dfont_replacedesc_iso_8859_7,
    160,
    2,
    813);
  UC_Charset_Setup(
    "cp737",
    "Greek (cp737)",
    dfont_unicount_cp737,
    dfont_unitable_cp737,
    231,
    dfont_replacedesc_cp737,
    128,
    1,
    737);
  UC_Charset_Setup(
    "cp869",
    "Greek2 (cp869)",
    dfont_unicount_cp869,
    dfont_unitable_cp869,
    217,
    dfont_replacedesc_cp869,
    134,
    1,
    869);
  UC_Charset_Setup(
    "windows-1253",
    "Greek (windows-1253)",
    dfont_unicount_windows_1253,
    dfont_unitable_windows_1253,
    208,
    dfont_replacedesc_windows_1253,
    128,
    1,
    1253);
  UC_Charset_Setup(
    "iso-8859-8",
    "Hebrew (ISO-8859-8)",
    dfont_unicount_iso_8859_8,
    dfont_unitable_iso_8859_8,
    155,
    dfont_replacedesc_iso_8859_8,
    160,
    2,
    916);
  UC_Charset_Setup(
    "cp862",
    "Hebrew (cp862)",
    dfont_unicount_cp862,
    dfont_unitable_cp862,
    224,
    dfont_replacedesc_cp862,
    128,
    1,
    862);
  UC_Charset_Setup(
    "windows-1255",
    "Hebrew (windows-1255)",
    dfont_unicount_windows_1255,
    dfont_unitable_windows_1255,
    200,
    dfont_replacedesc_windows_1255,
    128,
    1,
    1255);
  UC_Charset_Setup(
    "iso-8859-9",
    "Turkish (ISO-8859-9)",
    dfont_unicount_iso_8859_9,
    dfont_unitable_iso_8859_9,
    205,
    dfont_replacedesc_iso_8859_9,
    160,
    2,
    920);
  UC_Charset_Setup(
    "cp857",
    "Turkish (cp857)",
    dfont_unicount_cp857,
    dfont_unitable_cp857,
    221,
    dfont_replacedesc_cp857,
    128,
    1,
    857);
  UC_Charset_Setup(
    "iso-8859-10",
    "North European (ISO-8859-10)",
    dfont_unicount_iso_8859_10,
    dfont_unitable_iso_8859_10,
    191,
    dfont_replacedesc_iso_8859_10,
    160,
    2,
    0);
  UC_Charset_NoUctb_Setup("utf-8", "UNICODE (UTF-8)", 0, 128, 7, -4);
  UC_Charset_Setup(
    "mnemonic+ascii+0",
    "RFC 1345 w/o Intro",
    dfont_unicount_mnemonic_ascii_0,
    dfont_unitable_mnemonic_ascii_0,
    0,
    dfont_replacedesc_mnemonic_ascii_0,
    999,
    0,
    0);
  UC_Charset_Setup(
    "mnemonic",
    "RFC 1345 Mnemonic",
    dfont_unicount_mnemonic,
    dfont_unitable_mnemonic,
    0,
    dfont_replacedesc_mnemonic,
    999,
    0,
    0);
  UC_Charset_Setup(
    "cp866u",
    "Ukrainian Cyrillic (cp866u)",
    dfont_unicount_cp866u,
    dfont_unitable_cp866u,
    224,
    dfont_replacedesc_cp866u,
    128,
    1,
    0);
  UC_Charset_Setup(
    "koi8-u",
    "Ukrainian Cyrillic (KOI8-U)",
    dfont_unicount_koi8_u,
    dfont_unitable_koi8_u,
    224,
    dfont_replacedesc_koi8_u,
    128,
    1,
    0);
  UC_Charset_Setup(
    "ptcp154",
    "Cyrillic-Asian (PT154)",
    dfont_unicount_ptcp154,
    dfont_unitable_ptcp154,
    223,
    dfont_replacedesc_ptcp154,
    128,
    1,
    1540);
  LATIN1 = UCGetLYhndl_byMIME("iso-8859-1");
  US_ASCII = UCGetLYhndl_byMIME("us-ascii");
  UTF8_handle = UCGetLYhndl_byMIME("utf-8");
  TRANSPARENT = UCGetLYhndl_byMIME("x-transparent");
}

//----- (080F7CE9) --------------------------------------------------------
int __cdecl safeUCGetLYhndl_byMIME(const char *value)
{
  FILE *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  i = UCGetLYhndl_byMIME(value);
  if ( i == -1 )
  {
    i = LATIN1;
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "safeUCGetLYhndl_byMIME: ISO-8859-1 assumed.\n");
    }
  }
  return i;
}

//----- (080F7D32) --------------------------------------------------------
void LYFindLocaleCharset()
{
  int v0; // ebx
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  int value; // [esp+18h] [ebp-10h]
  const char *name; // [esp+1Ch] [ebp-Ch]
  BOOLEAN found; // [esp+23h] [ebp-5h]

  found = 0;
  if ( WWW_TraceFlag[0] )
  {
    v0 = LYLocaleCharset;
    v1 = TraceFP();
    fprintf(v1, "LYFindLocaleCharset(%d)\n", v0);
  }
  name = nl_langinfo(14);
  if ( name )
  {
    value = UCGetLYhndl_byMIME(name);
    if ( value < 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "Cannot find a handle for MIME name \"%s\"\n", name);
      }
    }
    else
    {
      found = 1;
      linedrawing_char_set = value;
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "Found name \"%s\" -> %d\n", name, value);
      }
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "Cannot find a MIME name for locale\n");
  }
  if ( found )
  {
    if ( LYLocaleCharset )
      current_char_set = linedrawing_char_set;
  }
}

//----- (080F7E44) --------------------------------------------------------
BOOLEAN __cdecl UCCanUniTranslateFrom(int from)
{
  return from >= 0 && strcmp(LYCharSet_UC[from].MIMEname, "x-transparent") != 0;
}

//----- (080F7E86) --------------------------------------------------------
BOOLEAN __cdecl UCCanTranslateUniTo(int to)
{
  return to >= 0;
}

//----- (080F7EA2) --------------------------------------------------------
BOOLEAN __cdecl UCCanTranslateFromTo(int from, int to)
{
  const char *toname; // [esp+20h] [ebp-8h]
  const char *fromname; // [esp+24h] [ebp-4h]

  if ( from == to )
    return 1;
  if ( from < 0 || to < 0 )
    return 0;
  if ( from == LATIN1 )
    return UCCanTranslateUniTo(to);
  if ( to == LATIN1 || LYCharSet_UC[to].enc == 7 )
    return UCCanUniTranslateFrom(from);
  fromname = LYCharSet_UC[from].MIMEname;
  toname = LYCharSet_UC[to].MIMEname;
  if ( !strcmp(fromname, "x-transparent") || !strcmp(toname, "x-transparent") )
    return 1;
  if ( !strcmp(fromname, "us-ascii") )
    return 1;
  if ( LYCharSet_UC[from].enc != 5 )
    return 1;
  if ( LYCharSet_UC[to].enc == 5 )
    return (!strcmp(toname, "euc-jp") || !strcmp(toname, "shift_jis"))
        && (!strcmp(fromname, "euc-jp") || !strcmp(fromname, "shift_jis"));
  return 0;
}

//----- (080F8028) --------------------------------------------------------
BOOLEAN __cdecl UCNeedNotTranslate(int from, int to)
{
  const char *fromname; // [esp+24h] [ebp-4h]

  if ( from == to )
    return 1;
  if ( from < 0 )
    return 0;
  if ( !LYCharSet_UC[from].enc )
    return 1;
  fromname = LYCharSet_UC[from].MIMEname;
  if ( !strcmp(fromname, "x-transparent") || !strcmp(fromname, "us-ascii") )
    return 1;
  if ( to < 0 )
    return 0;
  if ( to == LATIN1 && (LYCharSet_UC[from].codepoints & 1) != 0 )
    return 1;
  if ( !strcmp(LYCharSet_UC[to].MIMEname, "x-transparent") )
    return 1;
  if ( LYCharSet_UC[to].enc == 7 )
    return 0;
  if ( from == LATIN1 && (LYCharSet_UC[from].codepoints & 2) != 0 )
    return 1;
  if ( LYCharSet_UC[from].enc != 5 )
    return 0;
  if ( HTCJK )
    return HTCJK == JAPANESE && (!strcmp(fromname, "euc-jp") || !strcmp(fromname, "shift_jis"));
  return 0;
}

//----- (080F81C6) --------------------------------------------------------
void __cdecl UCSetTransParams(
        UCTransParams *pT,
        int cs_in,
        const LYUCcharset *p_in,
        int cs_out,
        const LYUCcharset *p_out)
{
  int v5; // edi
  int v6; // ebx
  const char *v7; // esi
  FILE *v8; // eax
  const char *MIMEname; // [esp+20h] [ebp-48h]
  bool v10; // [esp+24h] [ebp-44h]
  bool v11; // [esp+28h] [ebp-40h]
  bool v12; // [esp+2Ch] [ebp-3Ch]
  bool v13; // [esp+30h] [ebp-38h]
  bool v14; // [esp+34h] [ebp-34h]
  bool v15; // [esp+38h] [ebp-30h]
  bool v16; // [esp+3Ch] [ebp-2Ch]
  bool v17; // [esp+40h] [ebp-28h]
  bool v18; // [esp+44h] [ebp-24h]
  bool v19; // [esp+48h] [ebp-20h]

  if ( WWW_TraceFlag[0] )
  {
    v5 = UCGetLYhndl_byMIME(p_out->MIMEname);
    MIMEname = p_out->MIMEname;
    v6 = UCGetLYhndl_byMIME(p_in->MIMEname);
    v7 = p_in->MIMEname;
    v8 = TraceFP();
    fprintf(v8, "UCSetTransParams: from %s(%d) to %s(%d)\n", v7, v6, MIMEname, v5);
  }
  pT->trans_C0_to_uni = 0;
  v10 = !strcmp(p_in->MIMEname, "x-transparent") || !strcmp(p_out->MIMEname, "x-transparent");
  pT->transp = v10;
  if ( pT->transp )
  {
    pT->do_cjk = 0;
    pT->decode_utf8 = 0;
    pT->output_utf8 = 0;
    pT->do_8bitraw = 1;
    pT->use_raw_char_in = 1;
    pT->strip_raw_char_in = 0;
    pT->pass_160_173_raw = 1;
    pT->repl_translated_C0 = p_out->enc == 3;
    v11 = p_in->enc == 3 || p_out->enc == 3;
    pT->trans_C0_to_uni = v11;
  }
  else
  {
    v12 = p_in->enc == 5 && HTCJK;
    pT->do_cjk = v12;
    pT->decode_utf8 = p_in->enc == 7;
    pT->output_utf8 = p_out->enc == 7;
    if ( pT->do_cjk )
    {
      pT->trans_to_uni = 0;
      pT->do_8bitraw = 0;
      pT->pass_160_173_raw = 1;
      pT->use_raw_char_in = 0;
      pT->repl_translated_C0 = 0;
      pT->trans_from_uni = 0;
    }
    else
    {
      v13 = cs_in == LATIN1 || pT->decode_utf8 || (p_in->codepoints & 5) != 0;
      v14 = !v13 && UCCanUniTranslateFrom(cs_in);
      pT->trans_to_uni = v14;
      v15 = pT->trans_to_uni && p_in->enc == 3;
      pT->trans_C0_to_uni = v15;
      pT->repl_translated_C0 = p_out->enc == 3;
      pT->strip_raw_char_in = 0;
      v16 = v13 || pT->trans_to_uni;
      pT->do_8bitraw = !v16;
      v17 = !v16 && (p_in->like8859 & 0x80) == 0;
      pT->pass_160_173_raw = v17;
      v18 = !pT->output_utf8 && cs_in == cs_out && !pT->trans_C0_to_uni;
      pT->use_raw_char_in = v18;
      v19 = v16 && !pT->do_8bitraw && !pT->use_raw_char_in && UCCanTranslateUniTo(cs_out);
      pT->trans_from_uni = v19;
    }
  }
}

//----- (080F853F) --------------------------------------------------------
void __cdecl UCTransParams_clear(UCTransParams *pT)
{
  pT->transp = 0;
  pT->do_cjk = 0;
  pT->decode_utf8 = 0;
  pT->output_utf8 = 0;
  pT->do_8bitraw = 0;
  pT->use_raw_char_in = 0;
  pT->strip_raw_char_in = 0;
  pT->pass_160_173_raw = 0;
  pT->trans_to_uni = 0;
  pT->trans_C0_to_uni = 0;
  pT->repl_translated_C0 = 0;
  pT->trans_from_uni = 0;
}

//----- (080F8597) --------------------------------------------------------
void __cdecl UCSetBoxChars(int cset, int *pvert_out, int *phori_out, int vert_in, int hori_in)
{
  *pvert_out = vert_in;
  *phori_out = hori_in;
}

//----- (080F85D3) --------------------------------------------------------
BOOLEAN __cdecl UCPutUtf8_charstring(HTStream *target, putc_func_t *myPutc, int code)
{
  if ( code <= 127 )
    return 0;
  if ( code > 2047 )
  {
    if ( code > 0xFFFF )
    {
      if ( code > 0x1FFFFF )
      {
        if ( code > 0x3FFFFFF )
        {
          myPutc(target, (code >> 30) | 0xFC);
          myPutc(target, HIBYTE(code) & 0x3F | 0x80);
        }
        else
        {
          myPutc(target, HIBYTE(code) | 0xF8);
        }
        myPutc(target, (code >> 18) & 0x3F | 0x80);
        myPutc(target, (code >> 12) & 0x3F | 0x80);
        myPutc(target, (code >> 6) & 0x3F | 0x80);
        myPutc(target, code & 0x3F | 0x80);
      }
      else
      {
        myPutc(target, (code >> 18) | 0xF0);
        myPutc(target, (code >> 12) & 0x3F | 0x80);
        myPutc(target, (code >> 6) & 0x3F | 0x80);
        myPutc(target, code & 0x3F | 0x80);
      }
    }
    else
    {
      myPutc(target, (code >> 12) | 0xE0);
      myPutc(target, (code >> 6) & 0x3F | 0x80);
      myPutc(target, code & 0x3F | 0x80);
    }
  }
  else
  {
    myPutc(target, (code >> 6) | 0xC0);
    myPutc(target, code & 0x3F | 0x80);
  }
  return 1;
}

//----- (080F8868) --------------------------------------------------------
BOOLEAN __cdecl UCConvertUniToUtf8(UCode_t code, char *buffer)
{
  char *ch_0; // [esp+10h] [ebp-4h]
  char *ch_0a; // [esp+10h] [ebp-4h]

  ch_0 = buffer;
  if ( !buffer )
    return 0;
  if ( code > 0 )
  {
    if ( code > 2047 )
    {
      if ( code > 0xFFFF )
      {
        if ( code > 0x1FFFFF )
        {
          if ( code > 0x3FFFFFF )
          {
            *buffer = (code >> 30) | 0xFC;
            ch_0 = buffer + 1;
            buffer[1] = HIBYTE(code) & 0x3F | 0x80;
          }
          else
          {
            *buffer = HIBYTE(code) | 0xF8;
          }
          ch_0a = ch_0 + 1;
          *ch_0a++ = (code >> 18) & 0x3F | 0x80;
          *ch_0a++ = (code >> 12) & 0x3F | 0x80;
          *ch_0a++ = (code >> 6) & 0x3F | 0x80;
          *ch_0a = code & 0x3F | 0x80;
          ch_0a[1] = 0;
        }
        else
        {
          *buffer = (code >> 18) | 0xF0;
          buffer[1] = (code >> 12) & 0x3F | 0x80;
          buffer[2] = (code >> 6) & 0x3F | 0x80;
          buffer[3] = code & 0x3F | 0x80;
          buffer[4] = 0;
        }
      }
      else
      {
        *buffer = (code >> 12) | 0xE0;
        buffer[1] = (code >> 6) & 0x3F | 0x80;
        buffer[2] = code & 0x3F | 0x80;
        buffer[3] = 0;
      }
    }
    else
    {
      *buffer = (code >> 6) | 0xC0;
      buffer[1] = code & 0x3F | 0x80;
      buffer[2] = 0;
    }
    return 1;
  }
  else
  {
    *buffer = 0;
    return 0;
  }
}

//----- (080F8AA6) --------------------------------------------------------
UCode_t __cdecl UCGetUniFromUtf8String(char **ppuni)
{
  int i; // [esp+4h] [ebp-10h]
  int utf_count; // [esp+8h] [ebp-Ch]
  char *p; // [esp+Ch] [ebp-8h]
  char *pa; // [esp+Ch] [ebp-8h]
  char *pb; // [esp+Ch] [ebp-8h]
  int uc_out; // [esp+10h] [ebp-4h]

  uc_out = 0;
  p = *ppuni;
  if ( **ppuni >= 0 )
    return **ppuni;
  if ( (**ppuni & 0x40) == 0 )
    return -1;
  if ( (*p & 0xE0) == 192 )
  {
    utf_count = 1;
  }
  else if ( (*p & 0xF0) == 224 )
  {
    utf_count = 2;
  }
  else if ( (*p & 0xF8) == 240 )
  {
    utf_count = 3;
  }
  else if ( (*p & 0xFC) == 248 )
  {
    utf_count = 4;
  }
  else
  {
    if ( (*p & 0xFE) != 252 )
      return -1;
    utf_count = 5;
  }
  pa = *ppuni;
  for ( i = 0; i < utf_count; ++i )
  {
    if ( (*++pa & 0xC0) != 128 )
      return -1;
  }
  pb = *ppuni;
  switch ( utf_count )
  {
    case 1:
      uc_out = ((*pb & 0x1F) << 6) | pb[1] & 0x3F;
      break;
    case 2:
      uc_out = ((((*pb & 0xF) << 6) | pb[1] & 0x3F) << 6) | pb[2] & 0x3F;
      break;
    case 3:
      uc_out = ((((((*pb & 7) << 6) | pb[1] & 0x3F) << 6) | pb[2] & 0x3F) << 6) | pb[3] & 0x3F;
      break;
    case 4:
      uc_out = (((((((unsigned __int8)(*pb << 6) | pb[1] & 0x3F) << 6) | pb[2] & 0x3F) << 6) | pb[3] & 0x3F) << 6) | pb[4] & 0x3F;
      break;
    case 5:
      uc_out = ((((((((((*pb & 1) << 6) | pb[1] & 0x3F) << 6) | pb[2] & 0x3F) << 6) | pb[3] & 0x3F) << 6) | pb[4] & 0x3F) << 6) | pb[5] & 0x3F;
      break;
    default:
      break;
  }
  *ppuni = &pb[utf_count];
  return uc_out;
}

//----- (080F8DBC) --------------------------------------------------------
void __cdecl UCChangeTerminalCodepage(int newcs, LYUCcharset *p)
{
  FILE *v2; // eax

  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "UCChangeTerminalCodepage: Called, but not implemented!");
  }
}

//----- (080F8DE8) --------------------------------------------------------
void __cdecl format(char **result, char *fmt, char *parm)
{
  *result = 0;
  HTAddParam(result, fmt, 1, parm);
  HTEndParam(result, fmt, 1);
}

//----- (080F8E34) --------------------------------------------------------
char *__cdecl format_command(char *command, char *param)
{
  char *cmdbuf; // [esp+24h] [ebp-4h] BYREF

  cmdbuf = 0;
  format(&cmdbuf, command, param);
  return cmdbuf;
}

//----- (080F8E5F) --------------------------------------------------------
char *__cdecl lookup_external(char *param, BOOLEAN only_overriders)
{
  const char *name; // ebx
  FILE *v3; // edx
  char *v4; // eax
  FILE *v5; // edx
  char *v6; // eax
  int cury; // [esp+28h] [ebp-40h]
  int curx; // [esp+2Ch] [ebp-3Ch]
  lynx_list_item_type *ptr; // [esp+40h] [ebp-28h]
  char **choices; // [esp+44h] [ebp-24h]
  char *cmdbuf; // [esp+48h] [ebp-20h]
  int length; // [esp+4Ch] [ebp-1Ch]
  int cur_choice; // [esp+50h] [ebp-18h]
  int num_choices; // [esp+54h] [ebp-14h]
  int num_matched; // [esp+58h] [ebp-10h]
  int num_disabled; // [esp+5Ch] [ebp-Ch]
  int pass; // [esp+60h] [ebp-8h]
  int passa; // [esp+60h] [ebp-8h]

  length = 0;
  cmdbuf = 0;
  choices = 0;
  for ( pass = 0; pass <= 1; ++pass )
  {
    num_disabled = 0;
    num_matched = 0;
    num_choices = 0;
    for ( ptr = externals; ptr; ptr = ptr->next )
    {
      if ( match_item_by_name(ptr, param, only_overriders) )
      {
        ++num_matched;
        if ( WWW_TraceFlag[0] )
        {
          name = ptr->name;
          v3 = TraceFP();
          fprintf(v3, "EXTERNAL: '%s' <==> '%s'\n", name, param);
        }
        if ( !no_externals || ptr->always_enabled || only_overriders )
        {
          if ( pass )
          {
            cmdbuf = format_command(ptr->command, param);
            if ( length > 1 )
              choices[num_choices] = cmdbuf;
          }
          else
          {
            ++length;
          }
          ++num_choices;
        }
        else
        {
          ++num_disabled;
        }
      }
    }
    if ( length > 1 )
    {
      if ( pass )
        choices[num_choices] = 0;
      else
        choices = (char **)calloc(length + 1, 4u);
    }
  }
  if ( num_disabled && num_disabled == num_matched )
  {
    v4 = gettext("External support is currently disabled.");
    HTUserMsg(v4);
  }
  else if ( num_choices > 1 )
  {
    if ( LYwin )
      cury = LYwin->_cury;
    else
      cury = -1;
    if ( LYwin )
      curx = LYwin->_curx;
    else
      curx = -1;
    cur_choice = LYhandlePopupList(-1, 0, curx, (const char **)choices, -1, -1, 0, 1);
    wmove(LYwin, cury, curx);
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "selected choice %d of %d\n", cur_choice, num_choices);
    }
    if ( cur_choice < 0 )
    {
      v6 = gettext("Cancelled!!!");
      HTInfoMsg(v6);
      cmdbuf = 0;
    }
    for ( passa = 0; choices[passa]; ++passa )
    {
      if ( passa == cur_choice )
      {
        cmdbuf = choices[passa];
      }
      else if ( choices[passa] )
      {
        free(choices[passa]);
        choices[passa] = 0;
      }
    }
    if ( choices )
      free(choices);
  }
  return cmdbuf;
}
// 80F8F42: conditional instruction was optimized away because %pass.4 is in (==1|<0)
// 80F8FD0: variable 'num_disabled' is possibly undefined
// 80F8FD8: variable 'num_matched' is possibly undefined
// 80F8FF7: variable 'num_choices' is possibly undefined

//----- (080F9180) --------------------------------------------------------
BOOLEAN __cdecl run_external(char *param, BOOLEAN only_overriders)
{
  char *cmdbuf; // [esp+1Ch] [ebp-Ch]
  BOOLEAN found; // [esp+27h] [ebp-1h]

  found = 0;
  if ( !externals )
    return 0;
  cmdbuf = lookup_external(param, only_overriders);
  if ( cmdbuf && *cmdbuf )
  {
    HTUserMsg(cmdbuf);
    found = 1;
    stop_curses();
    fflush(stdout);
    LYSystem(cmdbuf);
    fflush(stdout);
    start_curses();
  }
  if ( cmdbuf )
    free(cmdbuf);
  return found;
}
// 80F91F0: conditional instruction was optimized away because %confirmed.4==1
// 80F91F6: conditional instruction was optimized away because %redraw_flag.4==1
// 80F9219: conditional instruction was optimized away because %redraw_flag.4==1

//----- (080F9254) --------------------------------------------------------
BOOLEAN __cdecl cannot_stat(const char *name)
{
  char *v1; // eax
  char *tmpbuf; // [esp+24h] [ebp-4h] BYREF

  tmpbuf = 0;
  v1 = gettext("Unable to get status of '%s'.");
  HTSprintf0(&tmpbuf, v1, name);
  HTAlert(tmpbuf);
  if ( tmpbuf )
  {
    free(tmpbuf);
    tmpbuf = 0;
  }
  return 0;
}

//----- (080F92B0) --------------------------------------------------------
BOOLEAN __cdecl ok_stat(const char *name, stat *sb)
{
  FILE *v2; // edx

  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "testing ok_stat(%s)\n", name);
  }
  if ( stat64((int)name, (int)sb) )
    return cannot_stat(name);
  else
    return 1;
}

//----- (080F9311) --------------------------------------------------------
BOOLEAN __cdecl ok_lstat(char *name, stat *sb)
{
  FILE *v2; // eax

  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "testing ok_lstat(%s)\n", name);
  }
  if ( lstat64((int)name, (int)sb) >= 0 )
    return 1;
  else
    return cannot_stat(name);
}

//----- (080F9370) --------------------------------------------------------
BOOLEAN __cdecl ok_file_or_dir(stat *sb)
{
  char *v1; // eax

  if ( (sb->st_mode & 0xF000) == 0x4000 || (sb->st_mode & 0xF000) == 0x8000 )
    return 1;
  v1 = gettext("The selected item is not a file or a directory!  Request ignored.");
  HTAlert(v1);
  return 0;
}

//----- (080F93BE) --------------------------------------------------------
int __cdecl LYExecv(const char *path, char **argv, char *msg)
{
  FILE *v3; // eax
  const char *v4; // ebx
  FILE *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int wstatus; // [esp+30h] [ebp-18h] BYREF
  int pid; // [esp+34h] [ebp-14h]
  char *tmpbuf; // [esp+38h] [ebp-10h] BYREF
  int n; // [esp+3Ch] [ebp-Ch]
  int rc; // [esp+40h] [ebp-8h]

  rc = 0;
  tmpbuf = 0;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "LYExecv path='%s'\n", path);
    for ( n = 0; argv[n]; ++n )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = argv[n];
        v5 = TraceFP();
        fprintf(v5, "argv[%d] = '%s'\n", n, v4);
      }
    }
  }
  rc = 1;
  stop_curses();
  pid = fork();
  if ( pid == -1 )
  {
    v6 = gettext("Unable to %s due to system error!");
    HTSprintf0(&tmpbuf, v6, msg);
    rc = 0;
  }
  else
  {
    if ( !pid )
    {
      execv(path, argv);
      LYexit(1);
    }
    while ( waitpid(pid, &wstatus, 0) == -1 && *__errno_location() == 4 )
      ;
    if ( (wstatus & 0x7F) == 0 && (wstatus & 0xFF00) >> 8
      || (char)((wstatus & 0x7F) + 1) >> 1 > 0 && (wstatus & 0x7F) != 0 )
    {
      v7 = gettext("Probable failure to %s due to system error!");
      HTSprintf0(&tmpbuf, v7, msg);
      rc = 0;
    }
  }
  if ( !rc )
    LYSleepAlert();
  start_curses();
  if ( tmpbuf )
  {
    if ( !rc )
      HTAlert(tmpbuf);
    if ( tmpbuf )
    {
      free(tmpbuf);
      tmpbuf = 0;
    }
  }
  return rc;
}

//----- (080F95BB) --------------------------------------------------------
int __cdecl make_directory(char *path)
{
  int v2; // [esp+10h] [ebp-28h]
  char *args[5]; // [esp+18h] [ebp-20h] BYREF
  char *msg; // [esp+2Ch] [ebp-Ch] BYREF
  const char *program; // [esp+30h] [ebp-8h]
  int code; // [esp+34h] [ebp-4h]

  program = HTGetProgramPath(ppMKDIR_0);
  if ( program )
  {
    msg = 0;
    HTSprintf0(&msg, "make directory %s", path);
    args[0] = "mkdir";
    args[1] = path;
    args[2] = 0;
    if ( LYExecv(program, args, msg) > 0 )
      v2 = 1;
    else
      v2 = -1;
    code = v2;
    if ( msg )
    {
      free(msg);
      msg = 0;
    }
  }
  else if ( mkdir(path, 0x1FFu) )
  {
    return -1;
  }
  else
  {
    return 1;
  }
  return code;
}

//----- (080F968F) --------------------------------------------------------
int __cdecl remove_file(char *path)
{
  char *v1; // eax
  char *args[5]; // [esp+18h] [ebp-20h] BYREF
  char *tmpbuf; // [esp+2Ch] [ebp-Ch] BYREF
  const char *program; // [esp+30h] [ebp-8h]
  int code; // [esp+34h] [ebp-4h]

  program = HTGetProgramPath(ppRM_0);
  if ( program )
  {
    tmpbuf = 0;
    args[0] = "rm";
    args[1] = "-f";
    args[2] = path;
    args[3] = 0;
    v1 = gettext("remove %s");
    HTSprintf0(&tmpbuf, v1, path);
    code = LYExecv(program, args, tmpbuf);
    if ( tmpbuf )
    {
      free(tmpbuf);
      tmpbuf = 0;
    }
  }
  else if ( remove(path) )
  {
    return -1;
  }
  else
  {
    return 1;
  }
  return code;
}

//----- (080F9751) --------------------------------------------------------
int __cdecl remove_directory(char *path)
{
  char *v1; // eax
  char *args[5]; // [esp+18h] [ebp-20h] BYREF
  char *tmpbuf; // [esp+2Ch] [ebp-Ch] BYREF
  const char *program; // [esp+30h] [ebp-8h]
  int code; // [esp+34h] [ebp-4h]

  program = HTGetProgramPath(ppRMDIR_0);
  if ( program )
  {
    tmpbuf = 0;
    args[0] = "rmdir";
    args[1] = path;
    args[2] = 0;
    v1 = gettext("remove %s");
    HTSprintf0(&tmpbuf, v1, path);
    code = LYExecv(program, args, tmpbuf);
    if ( tmpbuf )
    {
      free(tmpbuf);
      tmpbuf = 0;
    }
  }
  else if ( rmdir(path) )
  {
    return -1;
  }
  else
  {
    return 1;
  }
  return code;
}

//----- (080F980C) --------------------------------------------------------
int __cdecl touch_file(char *path)
{
  char *v1; // eax
  int v3; // [esp+14h] [ebp-34h]
  char *args[5]; // [esp+24h] [ebp-24h] BYREF
  FILE *fp; // [esp+38h] [ebp-10h]
  char *msg; // [esp+3Ch] [ebp-Ch] BYREF
  const char *program; // [esp+40h] [ebp-8h]
  int code; // [esp+44h] [ebp-4h]

  program = HTGetProgramPath(ppTOUCH_0);
  if ( program )
  {
    msg = 0;
    v1 = gettext("touch %s");
    HTSprintf0(&msg, v1, path);
    args[0] = "touch";
    args[1] = path;
    args[2] = 0;
    if ( LYExecv(program, args, msg) > 0 )
      v3 = 1;
    else
      v3 = -1;
    code = v3;
    if ( msg )
    {
      free(msg);
      msg = 0;
    }
  }
  else
  {
    fp = (FILE *)fopen64(path, "w");
    if ( fp )
    {
      fclose(fp);
      return 1;
    }
    else
    {
      return -1;
    }
  }
  return code;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (080F98F4) --------------------------------------------------------
int __cdecl move_file(char *source, char *target)
{
  char *v2; // eax
  char *v3; // eax
  FILE *v4; // edx
  int v6; // [esp+14h] [ebp-74h]
  stat sb; // [esp+1Ch] [ebp-6Ch] BYREF
  char *actual; // [esp+7Ch] [ebp-Ch] BYREF
  const char *program; // [esp+80h] [ebp-8h]
  int code; // [esp+84h] [ebp-4h]

  program = HTGetProgramPath(ppMV_0);
  if ( program )
  {
    actual = 0;
    v2 = gettext("move %s to %s");
    HTSprintf0(&actual, v2, source, target);
    LODWORD(sb.st_dev) = "mv";
    HIDWORD(sb.st_dev) = source;
    *(_DWORD *)&sb.__pad1 = target;
    sb.__st_ino = 0;
    if ( LYExecv(program, (char **)&sb, actual) > 0 )
      v6 = 1;
    else
      v6 = -1;
    code = v6;
    if ( actual )
    {
LABEL_19:
      free(actual);
      actual = 0;
    }
  }
  else
  {
    actual = 0;
    if ( !stat64((int)target, (int)&sb) && (sb.st_mode & 0xF000) == 0x4000 )
    {
      v3 = LYPathLeaf(source);
      HTSprintf0(&actual, "%s/%s", target, v3);
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "move_file source=%s, target=%s\n", source, target);
      }
      target = actual;
    }
    code = rename(source, target);
    if ( code )
    {
      code = LYCopyFile(source, target);
      if ( code >= 0 )
        code = remove(source);
    }
    if ( !code )
      code = 1;
    if ( actual != target && actual )
      goto LABEL_19;
  }
  return code;
}

//----- (080F9ABB) --------------------------------------------------------
BOOLEAN __cdecl not_already_exists(char *name)
{
  char *v1; // eax
  char *v2; // eax
  stat dir_info; // [esp+18h] [ebp-60h] BYREF

  if ( !stat64((int)name, (int)&dir_info) )
  {
    if ( (dir_info.st_mode & 0xF000) == 0x4000 )
    {
      v1 = gettext("There is already a directory with that name!  Request ignored.");
      HTAlert(v1);
    }
    else
    {
      if ( (dir_info.st_mode & 0xF000) == 0x8000 )
        v2 = gettext("There is already a file with that name!  Request ignored.");
      else
        v2 = gettext("The specified name is already in use!  Request ignored.");
      HTAlert(v2);
    }
    return 0;
  }
  if ( *__errno_location() != 2 )
  {
    cannot_stat(name);
    return 0;
  }
  return 1;
}

//----- (080F9B5E) --------------------------------------------------------
BOOLEAN __cdecl dir_has_same_owner(stat *info, int owner)
{
  char *v2; // eax
  char *v3; // eax

  if ( (info->st_mode & 0xF000) != 0x4000 )
  {
    v3 = gettext("Destination is not a valid directory!  Request denied.");
    HTAlert(v3);
    return 0;
  }
  if ( info->st_uid != owner )
  {
    v2 = gettext("Destination has different owner!  Request denied.");
    HTAlert(v2);
    return 0;
  }
  return 1;
}

//----- (080F9BBB) --------------------------------------------------------
int remove_tagged()
{
  char *v0; // eax
  char *object; // [esp+14h] [ebp-84h]
  stat dir_info; // [esp+1Ch] [ebp-7Ch] BYREF
  HTList *tag; // [esp+7Ch] [ebp-1Ch]
  int count; // [esp+80h] [ebp-18h]
  char *testpath; // [esp+84h] [ebp-14h]
  char *tmpbuf; // [esp+88h] [ebp-10h]
  char *cp; // [esp+8Ch] [ebp-Ch]
  int ans; // [esp+90h] [ebp-8h]
  BOOLEAN will_clear; // [esp+97h] [ebp-1h]

  will_clear = 1;
  tmpbuf = 0;
  testpath = 0;
  if ( !tagged || !tagged->next )
    return 0;
  v0 = gettext("Remove all tagged files and directories?");
  ans = HTConfirm(v0);
  count = 0;
  tag = tagged;
  while ( ans == 1 )
  {
    if ( tag && (tag = tag->next) != 0 )
      object = (char *)tag->object;
    else
      object = 0;
    cp = object;
    if ( !object )
      break;
    if ( is_url(cp) == FILE_URL_TYPE_0 )
    {
      testpath = HTnameOfFile_WWW(cp, 0, 1);
      LYTrimPathSep(testpath);
      will_clear = 1;
      if ( !ok_stat(testpath, &dir_info) )
      {
        will_clear = 0;
        break;
      }
      if ( remove_file(testpath) <= 0 )
      {
        if ( !count )
          count = -1;
        will_clear = 0;
        break;
      }
      ++count;
      if ( testpath )
      {
        free(testpath);
        testpath = 0;
      }
    }
  }
  if ( testpath )
  {
    free(testpath);
    testpath = 0;
  }
  if ( tmpbuf )
  {
    free(tmpbuf);
    tmpbuf = 0;
  }
  if ( will_clear )
    clear_tags();
  return count;
}

//----- (080F9D57) --------------------------------------------------------
int __cdecl modify_tagged(char *testpath)
{
  char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *object; // [esp+1Ch] [ebp-49Ch]
  char *v9; // [esp+20h] [ebp-498h]
  char *testpatha; // [esp+24h] [ebp-494h]
  stat dir_info; // [esp+28h] [ebp-490h] BYREF
  ino_t inode; // [esp+88h] [ebp-430h]
  dev_t dev; // [esp+90h] [ebp-428h]
  char *cp1; // [esp+98h] [ebp-420h] BYREF
  HTList *tag; // [esp+9Ch] [ebp-41Ch]
  int count; // [esp+A0h] [ebp-418h]
  char *srcpath; // [esp+A4h] [ebp-414h]
  char *savepath; // [esp+A8h] [ebp-410h] BYREF
  int owner; // [esp+ACh] [ebp-40Ch]
  char *cp; // [esp+B0h] [ebp-408h]
  char tmpbuf[1024]; // [esp+B4h] [ebp-404h] BYREF
  unsigned int v22; // [esp+4B4h] [ebp-4h]

  testpatha = testpath;
  v22 = __readgsdword(0x14u);
  srcpath = 0;
  count = 0;
  if ( !tagged || !tagged->next )
    return 0;
  mustshow[0] = 1;
  v1 = gettext("Enter new location for tagged items: ");
  statusline(v1);
  tmpbuf[0] = 0;
  LYgetstr(tmpbuf, 0, 0x400u, NORECALL);
  if ( !tmpbuf[0] )
    return 0;
  if ( testpath && *testpath && strcmp(testpath, "/") )
  {
    cp = testpath;
  }
  else
  {
    if ( tagged && tagged->next )
      object = (char *)tagged->next->object;
    else
      object = 0;
    cp = object;
    testpatha = 0;
  }
  if ( testpatha )
  {
    if ( !strncmp(cp, "file://localhost", 0x10u) )
    {
      cp += 16;
    }
    else if ( (*cp == 102 || *cp == 70) && !strncasecomp(cp, "file:", 5) )
    {
      cp += 5;
    }
    savepath = HTURLPath_toFile(cp, 1, 0);
  }
  else if ( cp )
  {
    v2 = strip_trailing_slash(cp);
    cp = HTParse(".", v2, 5);
    savepath = HTURLPath_toFile(cp, 1, 0);
    if ( cp )
    {
      free(cp);
      cp = 0;
    }
  }
  else
  {
    savepath = HTURLPath_toFile(".", 1, 0);
  }
  if ( !ok_stat(savepath, &dir_info) )
  {
    if ( savepath )
    {
      free(savepath);
      savepath = 0;
    }
    return 0;
  }
  dev = dir_info.st_dev;
  inode = dir_info.st_ino;
  owner = dir_info.st_uid;
  if ( tmpbuf[0] == 126 && tmpbuf[1] == 47 )
  {
    cp1 = 0;
    v3 = Home_Dir();
    HTSACopy(&cp1, v3);
    HTSACat(&cp1, &tmpbuf[1]);
    if ( strlen(cp1) > 0x3FF )
    {
      v4 = gettext("Path too long");
      HTAlert(v4);
      if ( savepath )
      {
        free(savepath);
        savepath = 0;
      }
      if ( cp1 )
      {
        free(cp1);
        cp1 = 0;
      }
      return 0;
    }
    LYstrncpy(tmpbuf, cp1, 1023);
    if ( cp1 )
    {
      free(cp1);
      cp1 = 0;
    }
  }
  if ( tmpbuf[0] == 47 )
  {
    HTSACopy(&savepath, tmpbuf);
  }
  else
  {
    LYAddPathSep(&savepath);
    HTSACat(&savepath, tmpbuf);
  }
  if ( ok_stat(savepath, &dir_info) )
  {
    if ( dev == dir_info.st_dev && inode == dir_info.st_ino )
    {
      v5 = gettext("Source and destination are the same location - request ignored!");
      HTAlert(v5);
      if ( savepath )
      {
        free(savepath);
        savepath = 0;
      }
      return 0;
    }
    else
    {
      if ( dir_has_same_owner(&dir_info, owner) )
      {
        count = 0;
        tag = tagged;
        while ( 1 )
        {
          if ( tag && (tag = tag->next) != 0 )
            v9 = (char *)tag->object;
          else
            v9 = 0;
          cp = v9;
          if ( !v9 )
            break;
          srcpath = HTnameOfFile_WWW(cp, 0, 1);
          if ( move_file(srcpath, savepath) < 0 )
          {
            if ( !count )
              count = -1;
            break;
          }
          if ( srcpath )
          {
            free(srcpath);
            srcpath = 0;
          }
          ++count;
        }
        clear_tags();
        if ( srcpath )
        {
          free(srcpath);
          srcpath = 0;
        }
      }
      if ( savepath )
      {
        free(savepath);
        savepath = 0;
      }
      return count;
    }
  }
  else
  {
    if ( savepath )
    {
      free(savepath);
      savepath = 0;
    }
    return 0;
  }
}

//----- (080FA429) --------------------------------------------------------
int __cdecl modify_name(char *testpath)
{
  char *v1; // eax
  char *v2; // eax
  char *testpatha; // [esp+24h] [ebp-274h]
  stat dir_info; // [esp+28h] [ebp-270h] BYREF
  int code; // [esp+88h] [ebp-210h]
  char *newpath; // [esp+8Ch] [ebp-20Ch] BYREF
  const char *cp; // [esp+90h] [ebp-208h]
  char tmpbuf[512]; // [esp+94h] [ebp-204h] BYREF
  unsigned int v11; // [esp+294h] [ebp-4h]

  v11 = __readgsdword(0x14u);
  newpath = 0;
  code = 0;
  testpatha = strip_trailing_slash(testpath);
  if ( !ok_stat(testpatha, &dir_info) )
    return code;
  if ( (dir_info.st_mode & 0xF000) == 0x4000 )
  {
    cp = gettext("Enter new name for directory: ");
LABEL_7:
    v1 = LYPathLeaf(testpatha);
    LYstrncpy(tmpbuf, v1, 511);
    if ( !get_filename(cp, tmpbuf, 0x200u) )
      return 0;
    if ( LYLastPathSep(tmpbuf) )
    {
      v2 = gettext("Illegal character (path-separator) found! Request ignored.");
      HTAlert(v2);
    }
    else if ( tmpbuf[0] )
    {
      cp = LYLastPathSep(testpatha);
      if ( cp )
        HTSprintf0(&newpath, "%.*s%s", cp - testpatha + 1, testpatha, tmpbuf);
      else
        HTSACopy(&newpath, tmpbuf);
      if ( not_already_exists(newpath) )
        code = move_file(testpatha, newpath);
      if ( newpath )
      {
        free(newpath);
        newpath = 0;
      }
    }
    return code;
  }
  if ( (dir_info.st_mode & 0xF000) == 0x8000 )
  {
    cp = gettext("Enter new name for file: ");
    goto LABEL_7;
  }
  return ok_file_or_dir(&dir_info);
}

//----- (080FA67E) --------------------------------------------------------
int __cdecl modify_location(char *testpath)
{
  char *v1; // eax
  const char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  const char *testpatha; // [esp+14h] [ebp-494h]
  stat dir_info; // [esp+18h] [ebp-490h] BYREF
  ino_t inode; // [esp+78h] [ebp-430h]
  dev_t dev; // [esp+80h] [ebp-428h]
  int code; // [esp+8Ch] [ebp-41Ch]
  char *savepath; // [esp+90h] [ebp-418h] BYREF
  char *newpath; // [esp+94h] [ebp-414h] BYREF
  int owner; // [esp+98h] [ebp-410h]
  char *sp_0; // [esp+9Ch] [ebp-40Ch]
  const char *cp; // [esp+A0h] [ebp-408h]
  char tmpbuf[1024]; // [esp+A4h] [ebp-404h] BYREF
  unsigned int v18; // [esp+4A4h] [ebp-4h]

  v18 = __readgsdword(0x14u);
  newpath = 0;
  savepath = 0;
  code = 0;
  testpatha = strip_trailing_slash(testpath);
  if ( !ok_stat(testpatha, &dir_info) )
    return 0;
  if ( (dir_info.st_mode & 0xF000) == 0x4000 )
  {
    if ( !HTGetProgramPath(ppMV_0) )
    {
      v1 = gettext("Could not access directory.");
      HTAlert(v1);
      return 0;
    }
    cp = gettext("Enter new location for directory: ");
  }
  else
  {
    if ( (dir_info.st_mode & 0xF000) != 0x8000 )
      return ok_file_or_dir(&dir_info);
    cp = gettext("Enter new location for file: ");
  }
  LYstrncpy(tmpbuf, testpatha, 1023);
  *LYPathLeaf(tmpbuf) = 0;
  if ( !get_filename(cp, tmpbuf, 0x400u) )
    return 0;
  if ( !tmpbuf[0] )
    return code;
  HTSACopy(&savepath, testpatha);
  HTSACopy(&newpath, testpatha);
  if ( tmpbuf[0] == 126 && (!tmpbuf[1] || tmpbuf[1] == 47) )
  {
    v2 = Home_Dir();
    HTSACopy(&newpath, v2);
    HTSACat(&newpath, &tmpbuf[1]);
    LYstrncpy(tmpbuf, newpath, 1023);
  }
  if ( LYisAbsPath(tmpbuf) )
  {
    HTSACopy(&newpath, tmpbuf);
LABEL_26:
    dev = dir_info.st_dev;
    inode = dir_info.st_ino;
    owner = dir_info.st_uid;
    if ( ok_stat(newpath, &dir_info) )
    {
      if ( dev == dir_info.st_dev && inode == dir_info.st_ino )
      {
        v4 = gettext("Source and destination are the same location!  Request ignored!");
        HTAlert(v4);
        code = 0;
      }
      else if ( dir_has_same_owner(&dir_info, owner) )
      {
        code = move_file(savepath, newpath);
      }
    }
    else
    {
      code = 0;
    }
    if ( newpath )
    {
      free(newpath);
      newpath = 0;
    }
    if ( savepath )
    {
      free(savepath);
      savepath = 0;
    }
    return code;
  }
  sp_0 = LYLastPathSep(newpath);
  if ( sp_0 )
  {
    *++sp_0 = 0;
    HTSACat(&newpath, tmpbuf);
    goto LABEL_26;
  }
  v3 = gettext("Unexpected failure - unable to find trailing path separator");
  HTAlert(v3);
  if ( newpath )
  {
    free(newpath);
    newpath = 0;
  }
  if ( savepath )
  {
    free(savepath);
    savepath = 0;
  }
  return 0;
}

//----- (080FAAF2) --------------------------------------------------------
int __cdecl local_modify(DocInfo *doc, char **newpath)
{
  char *v2; // eax
  char *v3; // eax
  int count; // [esp+18h] [ebp-210h]
  char *cp; // [esp+1Ch] [ebp-20Ch]
  char *cpa; // [esp+1Ch] [ebp-20Ch]
  int ans; // [esp+20h] [ebp-208h]
  char testpath[512]; // [esp+24h] [ebp-204h] BYREF
  unsigned int v11; // [esp+224h] [ebp-4h]

  v11 = __readgsdword(0x14u);
  if ( tagged && tagged->next )
  {
    cp = HTnameOfFile_WWW(doc->address, 0, 0);
    count = modify_tagged(cp);
    if ( cp )
      free(cp);
    if ( doc->link > nlinks - count - 1 )
      doc->link = nlinks - count - 1;
    doc->link &= ~(doc->link >> 31);
    return count;
  }
  if ( doc->link < 0 || doc->link > nlinks )
    return 0;
  mustshow[0] = 1;
  v2 = gettext("Modify name, location, or permission (n, l, or p): ");
  statusline(v2);
  ans = LYgetch_single();
  if ( !strchr("NLP", ans) )
    return 0;
  cpa = HTnameOfFile_WWW(links[doc->link].lname, 0, 1);
  if ( strlen(cpa) > 0x1FF )
  {
    if ( cpa )
      free(cpa);
    return 0;
  }
  LYstrncpy(testpath, cpa, 511);
  if ( cpa )
    free(cpa);
  if ( ans == 78 )
    return modify_name(testpath);
  if ( ans != 76 )
  {
    if ( ans == 80 )
      return permit_location(0, testpath, newpath);
    v3 = gettext("This feature not yet implemented!");
    HTAlert(v3);
    return 0;
  }
  if ( !modify_location(testpath) )
    return 0;
  if ( doc->link == nlinks - 1 )
    --doc->link;
  return 1;
}

//----- (080FADF9) --------------------------------------------------------
int __cdecl create_file(char *current_location)
{
  char *v1; // eax
  char *v2; // eax
  char *s; // [esp+10h] [ebp-218h]
  char *testpath; // [esp+1Ch] [ebp-20Ch] BYREF
  int code; // [esp+20h] [ebp-208h]
  char tmpbuf[512]; // [esp+24h] [ebp-204h] BYREF
  unsigned int v8; // [esp+224h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  code = 0;
  testpath = 0;
  tmpbuf[0] = 0;
  v1 = gettext("Enter name of file to create: ");
  if ( get_filename(v1, tmpbuf, 0x200u) )
  {
    if ( strstr(tmpbuf, "//") )
    {
      v2 = gettext("Illegal redirection \"//\" found! Request ignored.");
      HTAlert(v2);
    }
    else if ( tmpbuf[0] )
    {
      s = no_dotfiles || !show_dotfiles ? ".~/" : "~/";
      if ( !strchr(s, tmpbuf[0]) )
      {
        HTSACopy(&testpath, current_location);
        LYAddPathSep(&testpath);
        HTSACat(&testpath, tmpbuf);
        if ( not_already_exists(testpath) )
          code = touch_file(testpath);
        if ( testpath )
        {
          free(testpath);
          testpath = 0;
        }
      }
    }
  }
  return code;
}

//----- (080FAFA0) --------------------------------------------------------
int __cdecl create_directory(char *current_location)
{
  char *v1; // eax
  char *v2; // eax
  char *s; // [esp+10h] [ebp-218h]
  char *testpath; // [esp+1Ch] [ebp-20Ch] BYREF
  int code; // [esp+20h] [ebp-208h]
  char tmpbuf[512]; // [esp+24h] [ebp-204h] BYREF
  unsigned int v8; // [esp+224h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  code = 0;
  testpath = 0;
  tmpbuf[0] = 0;
  v1 = gettext("Enter name for new directory: ");
  if ( get_filename(v1, tmpbuf, 0x200u) )
  {
    if ( strstr(tmpbuf, "//") )
    {
      v2 = gettext("Illegal redirection \"//\" found! Request ignored.");
      HTAlert(v2);
    }
    else if ( tmpbuf[0] )
    {
      s = no_dotfiles || !show_dotfiles ? ".~/" : "~/";
      if ( !strchr(s, tmpbuf[0]) )
      {
        HTSACopy(&testpath, current_location);
        LYAddPathSep(&testpath);
        HTSACat(&testpath, tmpbuf);
        if ( not_already_exists(testpath) )
          code = make_directory(testpath);
        if ( testpath )
        {
          free(testpath);
          testpath = 0;
        }
      }
    }
  }
  return code;
}

//----- (080FB147) --------------------------------------------------------
int __cdecl local_create(DocInfo *doc)
{
  char *v1; // eax
  char *cp; // [esp+1Ch] [ebp-20Ch]
  int ans; // [esp+20h] [ebp-208h]
  char testpath[512]; // [esp+24h] [ebp-204h] BYREF
  unsigned int v7; // [esp+224h] [ebp-4h]

  v7 = __readgsdword(0x14u);
  cp = HTnameOfFile_WWW(doc->address, 0, 1);
  if ( strlen(cp) <= 0x1FF )
  {
    strcpy(testpath, cp);
    if ( cp )
      free(cp);
    mustshow[0] = 1;
    v1 = gettext("Create file or directory (f or d): ");
    statusline(v1);
    ans = LYgetch_single();
    if ( ans == 70 )
    {
      return create_file(testpath);
    }
    else if ( ans == 68 )
    {
      return create_directory(testpath);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ( cp )
      free(cp);
    return 0;
  }
}

//----- (080FB290) --------------------------------------------------------
int __cdecl remove_single(char *testpath)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v9; // [esp+14h] [ebp-74h]
  stat dir_info; // [esp+18h] [ebp-70h] BYREF
  char *tmpbuf; // [esp+78h] [ebp-10h] BYREF
  char *cp; // [esp+7Ch] [ebp-Ch]
  int code; // [esp+80h] [ebp-8h]
  BOOLEAN is_directory; // [esp+87h] [ebp-1h]

  code = 0;
  tmpbuf = 0;
  is_directory = 0;
  if ( !ok_lstat(testpath, &dir_info) )
    return 0;
  cp = LYLastPathSep(testpath);
  if ( cp )
    ++cp;
  else
    cp = testpath;
  switch ( dir_info.st_mode & 0xF000 )
  {
    case 16384:
      if ( strlen(cp) > 0x24 )
      {
        v2 = gettext("Remove directory?");
        HTSprintf0(&tmpbuf, v2);
      }
      else
      {
        v1 = gettext("Remove directory '%s'?");
        HTSprintf0(&tmpbuf, v1, cp);
      }
      is_directory = 1;
      goto LABEL_22;
    case 32768:
      if ( strlen(cp) > 0x3B )
      {
        v4 = gettext("Remove file?");
        HTSprintf0(&tmpbuf, v4);
      }
      else
      {
        v3 = gettext("Remove file '%s'?");
        HTSprintf0(&tmpbuf, v3, cp);
      }
LABEL_22:
      if ( HTConfirm(tmpbuf) == 1 )
      {
        if ( is_directory )
          v9 = remove_directory(testpath);
        else
          v9 = remove_file(testpath);
        code = v9;
      }
      if ( tmpbuf )
      {
        free(tmpbuf);
        tmpbuf = 0;
      }
      return code;
    case 40960:
      if ( strlen(cp) > 0x31 )
      {
        v6 = gettext("Remove symbolic link?");
        HTSprintf0(&tmpbuf, v6);
      }
      else
      {
        v5 = gettext("Remove symbolic link '%s'?");
        HTSprintf0(&tmpbuf, v5, cp);
      }
      goto LABEL_22;
  }
  cannot_stat(testpath);
  if ( tmpbuf )
  {
    free(tmpbuf);
    tmpbuf = 0;
  }
  return 0;
}

//----- (080FB4A4) --------------------------------------------------------
int __cdecl local_remove(DocInfo *doc)
{
  int i; // [esp+24h] [ebp-214h]
  int count; // [esp+28h] [ebp-210h]
  char *tp; // [esp+2Ch] [ebp-20Ch]
  char *cp; // [esp+30h] [ebp-208h]
  char testpath[512]; // [esp+34h] [ebp-204h] BYREF
  unsigned int v8; // [esp+234h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  if ( tagged && tagged->next )
  {
    count = remove_tagged();
    if ( doc->link > nlinks - count - 1 )
      doc->link = nlinks - count - 1;
    doc->link &= ~(doc->link >> 31);
    return count;
  }
  if ( doc->link < 0 || doc->link > nlinks )
    return 0;
  cp = links[doc->link].lname;
  if ( is_url(links[doc->link].lname) != FILE_URL_TYPE_0 )
    return 0;
  tp = HTnameOfFile_WWW(cp, 0, 1);
  if ( strlen(tp) > 0x1FF )
  {
    if ( tp )
      free(tp);
    return 0;
  }
  strcpy(testpath, tp);
  if ( tp )
    free(tp);
  i = strlen(testpath);
  if ( i && testpath[i - 1] == 47 )
    testpath[i - 1] = 0;
  if ( !remove_single(testpath) )
    return 0;
  if ( doc->link == nlinks - 1 )
    --doc->link;
  return 1;
}

//----- (080FB6F3) --------------------------------------------------------
int __cdecl permit_bits(char *string_mode)
{
  if ( !strcmp(string_mode, "IRUSR") )
    return 256;
  if ( !strcmp(string_mode, "IWUSR") )
    return 128;
  if ( !strcmp(string_mode, "IXUSR") )
    return 64;
  if ( !strcmp(string_mode, "IRGRP") )
    return 32;
  if ( !strcmp(string_mode, "IWGRP") )
    return 16;
  if ( !strcmp(string_mode, "IXGRP") )
    return 8;
  if ( !strcmp(string_mode, "IROTH") )
    return 4;
  if ( !strcmp(string_mode, "IWOTH") )
    return 2;
  return strcmp(string_mode, "IXOTH") == 0;
}

//----- (080FB834) --------------------------------------------------------
int __cdecl permit_location(char *destpath, char *srcpath, char **newpath)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  FILE *v13; // eax
  char *v14; // eax
  char *v15; // eax
  FILE *v16; // eax
  char *v17; // eax
  char *v18; // eax
  const char *v21; // [esp+24h] [ebp-1F4h]
  const char *v22; // [esp+2Ch] [ebp-1ECh]
  const char *v23; // [esp+34h] [ebp-1E4h]
  const char *v24; // [esp+3Ch] [ebp-1DCh]
  const char *v25; // [esp+44h] [ebp-1D4h]
  const char *v26; // [esp+4Ch] [ebp-1CCh]
  const char *v27; // [esp+54h] [ebp-1C4h]
  char *v28; // [esp+58h] [ebp-1C0h]
  char *srcpatha; // [esp+60h] [ebp-1B8h]
  char *destpatha; // [esp+64h] [ebp-1B4h]
  const char *destpathb; // [esp+64h] [ebp-1B4h]
  stat dir_info; // [esp+6Ch] [ebp-1ACh] BYREF
  char *args[5]; // [esp+CCh] [ebp-14Ch] BYREF
  char *tmpbuf; // [esp+E0h] [ebp-138h] BYREF
  int mask; // [esp+E4h] [ebp-134h]
  char *cr; // [esp+E8h] [ebp-130h]
  mode_t new_mode; // [esp+ECh] [ebp-12Ch]
  char *srcpath_url; // [esp+F0h] [ebp-128h]
  const char *group_name; // [esp+F4h] [ebp-124h]
  char *user_filename; // [esp+F8h] [ebp-120h]
  FILE *fp0; // [esp+FCh] [ebp-11Ch]
  const char *program; // [esp+100h] [ebp-118h]
  char *cp; // [esp+104h] [ebp-114h]
  char tmpdst[256]; // [esp+10Ah] [ebp-10Eh] BYREF
  char amode[10]; // [esp+20Ah] [ebp-Eh] BYREF
  unsigned int v46; // [esp+214h] [ebp-4h]

  v46 = __readgsdword(0x14u);
  if ( srcpath )
  {
    srcpatha = strip_trailing_slash(srcpath);
    if ( !ok_lstat(srcpatha, &dir_info) || !ok_file_or_dir(&dir_info) )
      return 0;
    user_filename = LYPathLeaf(srcpatha);
    LYRemoveTemp(tempfile_11559);
    fp0 = LYOpenTemp(tempfile_11559, ".html", "w");
    if ( fp0 )
    {
      LYLocalFileToURL(newpath, tempfile_11559);
      LYRegisterUIPage(*newpath, UIP_PERMIT_OPTIONS_0);
      group_name = HTAA_GidToName(dir_info.st_gid);
      LYstrncpy(LYValidPermitFile, srcpatha, 255);
      v4 = gettext("File Permission Options");
      fprintf(fp0, "<Html><Head>\n<Title>%s</Title>\n</Head>\n<Body>\n", v4);
      v5 = gettext("Permissions for ");
      fprintf(fp0, "<H1>%s%s</H1>\n", v5, user_filename);
      srcpath_url = HTEscape(srcpatha, 4u);
      fprintf(fp0, "<Form Action=\"%s//PERMIT_LOCATION%s\">\n", "LYNXDIRED:", srcpath_url);
      if ( srcpath_url )
      {
        free(srcpath_url);
        srcpath_url = 0;
      }
      v6 = gettext("Specify permissions below:");
      fprintf(fp0, "<Ol><Li>%s<Br><Br>\n", v6);
      v7 = gettext("Owner:");
      fprintf(fp0, "%s:<Br>\n", v7);
      if ( (dir_info.st_mode & 0x100) != 0 )
        v21 = "checked";
      else
        v21 = &byte_817D5C4;
      fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRUSR\" %s> Read<Br>\n", v21);
      if ( (dir_info.st_mode & 0x80) != 0 )
        fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n", "checked");
      else
        fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWUSR\" %s> Write<Br>\n", &byte_817D5C4);
      if ( !no_change_exec_perms || (dir_info.st_mode & 0xF000) == 0x4000 )
      {
        if ( (dir_info.st_mode & 0xF000) == 0x4000 )
          v22 = "Search";
        else
          v22 = "Execute";
        if ( (dir_info.st_mode & 0x40) != 0 )
          fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n", "checked", v22);
        else
          fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXUSR\" %s> %s<Br>\n", &byte_817D5C4, v22);
      }
      v8 = gettext("Group");
      fprintf(fp0, "%s %s:<Br>\n", v8, group_name);
      if ( (dir_info.st_mode & 0x20) != 0 )
        v23 = "checked";
      else
        v23 = &byte_817D5C4;
      fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IRGRP\" %s> Read<Br>\n", v23);
      if ( (dir_info.st_mode & 0x10) != 0 )
        fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n", "checked");
      else
        fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWGRP\" %s> Write<Br>\n", &byte_817D5C4);
      if ( !no_change_exec_perms || (dir_info.st_mode & 0xF000) == 0x4000 )
      {
        if ( (dir_info.st_mode & 0xF000) == 0x4000 )
          v24 = "Search";
        else
          v24 = "Execute";
        if ( (dir_info.st_mode & 8) != 0 )
          fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n", "checked", v24);
        else
          fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXGRP\" %s> %s<Br>\n", &byte_817D5C4, v24);
      }
      v9 = gettext("Others:");
      fprintf(fp0, "%s<Br>\n", v9);
      if ( (dir_info.st_mode & 4) != 0 )
        v25 = "checked";
      else
        v25 = &byte_817D5C4;
      fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IROTH\" %s> Read<Br>\n", v25);
      if ( (dir_info.st_mode & 2) != 0 )
        fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n", "checked");
      else
        fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IWOTH\" %s> Write<Br>\n", &byte_817D5C4);
      if ( !no_change_exec_perms || (dir_info.st_mode & 0xF000) == 0x4000 )
      {
        if ( (dir_info.st_mode & 0xF000) == 0x4000 )
          v26 = "Search";
        else
          v26 = "Execute";
        if ( (dir_info.st_mode & 1) != 0 )
          fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n", "checked", v26);
        else
          fprintf(fp0, "<Input Type=\"checkbox\" Name=\"mode\" Value=\"IXOTH\" %s> %s<Br>\n", &byte_817D5C4, v26);
      }
      if ( (dir_info.st_mode & 0xF000) == 0x4000 )
        v27 = "directory";
      else
        v27 = "file";
      v10 = gettext("form to permit");
      fprintf(
        fp0,
        "<Br>\n<Li><Input Type=\"submit\" Value=\"Submit\">  %s %s %s.\n</Ol>\n</Form>\n",
        v10,
        v27,
        user_filename);
      fwrite("</Body></Html>", 1u, 0xEu, fp0);
      LYCloseTempFP(fp0);
      LYforce_no_cache = 1;
      return -99;
    }
    else
    {
      v3 = gettext("Unable to open permit options file");
      HTAlert(v3);
      return 0;
    }
  }
  new_mode = 0;
  if ( !LYValidPermitFile[0] )
  {
    if ( LYCursesON[0] )
    {
      v11 = gettext("Special URL only valid from current File Permission menu!");
      HTAlert(v11);
    }
    else
    {
      v12 = gettext("Special URL only valid from current File Permission menu!");
      fprintf(stderr, "%s\n", v12);
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( destpath )
        v28 = destpath;
      else
        v28 = "NULL URL pointer";
      v13 = TraceFP();
      fprintf(v13, "permit_location: called for <%s>.\n", v28);
    }
    return 0;
  }
  for ( cp = destpath; *cp && *cp != 63; ++cp )
    ;
  if ( !*cp )
    return 0;
  *cp++ = 0;
  destpatha = HTURLPath_toFile(destpath, 1, 0);
  if ( !destpatha )
    return 0;
  if ( strlen(destpatha) > 0xFF )
  {
    free(destpatha);
    return 0;
  }
  strcpy(tmpdst, destpatha);
  free(destpatha);
  if ( strcmp(tmpdst, LYValidPermitFile) )
  {
    if ( LYCursesON[0] )
    {
      v14 = gettext("Special URL only valid from current File Permission menu!");
      HTAlert(v14);
    }
    else
    {
      v15 = gettext("Special URL only valid from current File Permission menu!");
      fprintf(stderr, "%s\n", v15);
    }
    if ( WWW_TraceFlag[0] )
    {
      v16 = TraceFP();
      fprintf(v16, "permit_location: called for file '%s'.\n", tmpdst);
    }
    return 0;
  }
  destpathb = strip_trailing_slash(tmpdst);
  if ( !ok_stat(destpathb, &dir_info) || !ok_file_or_dir(&dir_info) )
    return 0;
  while ( *cp )
  {
    for ( cr = cp; *cr && *cr != 38; ++cr )
      ;
    if ( *cr )
      *cr++ = 0;
    if ( strncmp(cp, "mode=", 5u) )
    {
      v18 = gettext("Invalid syntax format.");
      HTAlert(v18);
      return 0;
    }
    mask = permit_bits(cp + 5);
    if ( !mask )
    {
      v17 = gettext("Invalid mode format.");
      HTAlert(v17);
      return 0;
    }
    if ( !no_change_exec_perms || !strchr(cp + 5, 88) || (dir_info.st_mode & 0xF000) == 0x4000 )
      new_mode |= mask;
    cp = cr;
  }
  program = HTGetProgramPath(ppCHMOD_0);
  if ( !program )
  {
    if ( chmod(destpathb, new_mode) < 0 )
      return -1;
LABEL_110:
    LYforce_no_cache = 1;
    return 1;
  }
  tmpbuf = 0;
  HTSprintf0(&tmpbuf, "chmod %.4o %s", new_mode, destpathb);
  sprintf(amode, "%.4o", new_mode);
  args[0] = "chmod";
  args[1] = amode;
  args[2] = (char *)destpathb;
  args[3] = 0;
  if ( LYExecv(program, args, tmpbuf) > 0 )
  {
    if ( tmpbuf )
    {
      free(tmpbuf);
      tmpbuf = 0;
    }
    goto LABEL_110;
  }
  if ( tmpbuf )
  {
    free(tmpbuf);
    tmpbuf = 0;
  }
  return -1;
}
// 80FC059: conditional instruction was optimized away because %destpath.4!=0
// 80FC0A1: conditional instruction was optimized away because %destpath.4!=0

//----- (080FC45C) --------------------------------------------------------
void __cdecl tagflag(int flag, int cur)
{
  if ( nlinks > 0 )
  {
    LYmove(links[cur].ly, 2);
    lynx_stop_reverse();
    if ( flag == 1 )
      waddch(LYwin, 0x2Bu);
    else
      waddch(LYwin, 0x20u);
    if ( LYShowCursor )
      LYmove(links[cur].ly, links[cur].lx);
    else
      LYmove(LYlines - 1, LYcols - (LYShowScrollbar != 0) - 1);
    LYrefresh();
  }
}

//----- (080FC541) --------------------------------------------------------
void __cdecl showtags(HTList *t)
{
  const char *object; // [esp+14h] [ebp-14h]
  HTList *s; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i < nlinks; ++i )
  {
    s = t;
    while ( 1 )
    {
      if ( s && (s = s->next) != 0 )
        object = (const char *)s->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( !strcmp(links[i].lname, object) )
      {
        tagflag(1, i);
        break;
      }
    }
  }
}

//----- (080FC5D9) --------------------------------------------------------
char *__cdecl DirectoryOf(char *pathname)
{
  const char *result1; // [esp+Ch] [ebp-Ch]
  char *leaf; // [esp+10h] [ebp-8h]
  char *result; // [esp+14h] [ebp-4h] BYREF

  result = 0;
  HTSACopy(&result, pathname);
  leaf = LYPathLeaf(result);
  if ( leaf != result )
  {
    *leaf = 0;
    if ( !LYisRootPath(result) )
      LYTrimPathSep(result);
    result1 = wwwName(result);
    HTSACopy(&result, result1);
  }
  return result;
}

//----- (080FC65A) --------------------------------------------------------
char *__cdecl match_op(const char *prefix, char *data)
{
  int len; // [esp+24h] [ebp-4h]

  len = strlen(prefix);
  if ( !strncmp("LYNXDIRED://", data, 0xCu) && !strncmp(prefix, data + 12, len) )
    return &data[len + 12];
  else
    return 0;
}

//----- (080FC6CA) --------------------------------------------------------
char *__cdecl build_command(char *line, char *dirname, char *arg)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  const char *tar_path; // [esp+1Ch] [ebp-Ch]
  const char *program; // [esp+20h] [ebp-8h]
  const char *programa; // [esp+20h] [ebp-8h]
  const char *programb; // [esp+20h] [ebp-8h]
  const char *programc; // [esp+20h] [ebp-8h]
  const char *programd; // [esp+20h] [ebp-8h]
  const char *programe; // [esp+20h] [ebp-8h]
  const char *programf; // [esp+20h] [ebp-8h]
  const char *programg; // [esp+20h] [ebp-8h]
  const char *programh; // [esp+20h] [ebp-8h]
  const char *programi; // [esp+20h] [ebp-8h]
  const char *programj; // [esp+20h] [ebp-8h]
  char *buffer; // [esp+24h] [ebp-4h] BYREF
  const char *dirnamea; // [esp+34h] [ebp+Ch]
  const char *dirnameb; // [esp+34h] [ebp+Ch]
  const char *dirnamec; // [esp+34h] [ebp+Ch]
  const char *dirnamed; // [esp+34h] [ebp+Ch]
  const char *dirnamee; // [esp+34h] [ebp+Ch]
  const char *dirnamef; // [esp+34h] [ebp+Ch]
  const char *dirnameg; // [esp+34h] [ebp+Ch]
  const char *dirnameh; // [esp+34h] [ebp+Ch]
  const char *arga; // [esp+38h] [ebp+10h]
  const char *argb; // [esp+38h] [ebp+10h]
  char *argc; // [esp+38h] [ebp+10h]
  char *argd; // [esp+38h] [ebp+10h]
  char *arge; // [esp+38h] [ebp+10h]
  char *argf; // [esp+38h] [ebp+10h]
  char *argg; // [esp+38h] [ebp+10h]
  char *argh; // [esp+38h] [ebp+10h]
  const char *argi; // [esp+38h] [ebp+10h]
  const char *argj; // [esp+38h] [ebp+10h]
  char *argk; // [esp+38h] [ebp+10h]
  char *argl; // [esp+38h] [ebp+10h]
  const char *argm; // [esp+38h] [ebp+10h]

  buffer = 0;
  tar_path = HTGetProgramPath(ppTAR_0);
  arga = match_op("DECOMPRESS", line);
  if ( arga )
  {
    program = HTGetProgramPath(ppUNCOMPRESS_0);
    if ( program )
    {
      HTAddParam(&buffer, "%s %s", 1, program);
      HTAddParam(&buffer, "%s %s", 2, arga);
      HTEndParam(&buffer, "%s %s", 2);
    }
    return buffer;
  }
  argb = match_op("UUDECODE", line);
  if ( argb )
  {
    programa = HTGetProgramPath(ppUUDECODE_0);
    if ( programa )
    {
      HTAddParam(&buffer, "%s %s", 1, programa);
      HTAddParam(&buffer, "%s %s", 2, argb);
      HTEndParam(&buffer, "%s %s", 2);
      v3 = gettext("Warning!  UUDecoded file will exist in the directory you started Lynx.");
      HTAlert(v3);
    }
    return buffer;
  }
  if ( tar_path )
  {
    argc = match_op("UNTAR_GZ", line);
    if ( argc )
    {
      programb = HTGetProgramPath(ppGZIP_0);
      if ( programb )
      {
        dirnamea = DirectoryOf(argc);
        HTAddParam(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 1, dirnamea);
        HTAddParam(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 2, programb);
        HTAddParam(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 3, argc);
        HTAddParam(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 4, tar_path);
        HTAddToCmd(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 5, "-xf");
        HTAddToCmd(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 6, "-");
        HTEndParam(&buffer, "cd %s; %s -qdc %s |  %s %s %s", 6);
      }
      return buffer;
    }
    argd = match_op("UNTAR_Z", line);
    if ( argd )
    {
      programc = HTGetProgramPath(ppZCAT_0);
      if ( programc )
      {
        dirnameb = DirectoryOf(argd);
        HTAddParam(&buffer, "cd %s; %s %s |  %s %s %s", 1, dirnameb);
        HTAddParam(&buffer, "cd %s; %s %s |  %s %s %s", 2, programc);
        HTAddParam(&buffer, "cd %s; %s %s |  %s %s %s", 3, argd);
        HTAddParam(&buffer, "cd %s; %s %s |  %s %s %s", 4, tar_path);
        HTAddToCmd(&buffer, "cd %s; %s %s |  %s %s %s", 5, "-xf");
        HTAddToCmd(&buffer, "cd %s; %s %s |  %s %s %s", 6, "-");
        HTEndParam(&buffer, "cd %s; %s %s |  %s %s %s", 6);
      }
      return buffer;
    }
    arge = match_op("UNTAR", line);
    if ( arge )
    {
      dirnamec = DirectoryOf(arge);
      HTAddParam(&buffer, "cd %s; %s %s %s", 1, dirnamec);
      HTAddParam(&buffer, "cd %s; %s %s %s", 2, tar_path);
      HTAddToCmd(&buffer, "cd %s; %s %s %s", 3, "-xf");
      HTAddParam(&buffer, "cd %s; %s %s %s", 4, arge);
      HTEndParam(&buffer, "cd %s; %s %s %s", 4);
      return buffer;
    }
    argf = match_op("TAR_GZ", line);
    if ( argf )
    {
      programd = HTGetProgramPath(ppGZIP_0);
      if ( programd )
      {
        dirnamed = DirectoryOf(argf);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 1, dirnamed);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 2, tar_path);
        HTAddToCmd(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 3, "-cf");
        HTAddToCmd(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 4, "-");
        v4 = LYPathLeaf(argf);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 5, v4);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 6, programd);
        v5 = LYPathLeaf(argf);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 7, v5);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 8, ".tar.gz");
        HTEndParam(&buffer, "cd %s; %s %s %s %s | %s -qc >%s%s", 8);
      }
      return buffer;
    }
    argg = match_op("TAR_Z", line);
    if ( argg )
    {
      programe = HTGetProgramPath(ppCOMPRESS_0);
      if ( programe )
      {
        dirnamee = DirectoryOf(argg);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 1, dirnamee);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 2, tar_path);
        HTAddToCmd(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 3, "-cf");
        HTAddToCmd(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 4, "-");
        v6 = LYPathLeaf(argg);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 5, v6);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 6, programe);
        v7 = LYPathLeaf(argg);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 7, v7);
        HTAddParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 8, ".tar.Z");
        HTEndParam(&buffer, "cd %s; %s %s %s %s | %s >%s%s", 8);
      }
      return buffer;
    }
    argh = match_op("TAR", line);
    if ( argh )
    {
      dirnamef = DirectoryOf(argh);
      HTAddParam(&buffer, "cd %s; %s %s %s %s.tar %s", 1, dirnamef);
      HTAddParam(&buffer, "cd %s; %s %s %s %s.tar %s", 2, tar_path);
      HTAddToCmd(&buffer, "cd %s; %s %s %s %s.tar %s", 3, "-cf");
      HTAddToCmd(&buffer, "cd %s; %s %s %s %s.tar %s", 4, &byte_817D5C4);
      v8 = LYPathLeaf(argh);
      HTAddParam(&buffer, "cd %s; %s %s %s %s.tar %s", 5, v8);
      v9 = LYPathLeaf(argh);
      HTAddParam(&buffer, "cd %s; %s %s %s %s.tar %s", 6, v9);
      HTEndParam(&buffer, "cd %s; %s %s %s %s.tar %s", 6);
      return buffer;
    }
  }
  argi = match_op("GZIP", line);
  if ( argi )
  {
    programf = HTGetProgramPath(ppGZIP_0);
    if ( programf )
    {
      HTAddParam(&buffer, "%s -q %s", 1, programf);
      HTAddParam(&buffer, "%s -q %s", 2, argi);
      HTEndParam(&buffer, "%s -q %s", 2);
    }
    return buffer;
  }
  else
  {
    argj = match_op("UNGZIP", line);
    if ( argj )
    {
      programg = HTGetProgramPath(ppGZIP_0);
      if ( programg )
      {
        HTAddParam(&buffer, "%s -d %s", 1, programg);
        HTAddParam(&buffer, "%s -d %s", 2, argj);
        HTEndParam(&buffer, "%s -d %s", 2);
      }
      return buffer;
    }
    else
    {
      argk = match_op("ZIP", line);
      if ( argk )
      {
        programh = HTGetProgramPath(ppZIP_0);
        if ( programh )
        {
          dirnameg = DirectoryOf(argk);
          HTAddParam(&buffer, "cd %s; %s -rq %s.zip %s", 1, dirnameg);
          HTAddParam(&buffer, "cd %s; %s -rq %s.zip %s", 2, programh);
          v10 = LYPathLeaf(argk);
          HTAddParam(&buffer, "cd %s; %s -rq %s.zip %s", 3, v10);
          v11 = LYPathLeaf(argk);
          HTAddParam(&buffer, "cd %s; %s -rq %s.zip %s", 4, v11);
          HTEndParam(&buffer, "cd %s; %s -rq %s.zip %s", 4);
        }
        return buffer;
      }
      else
      {
        argl = match_op("UNZIP", line);
        if ( argl )
        {
          programi = HTGetProgramPath(ppUNZIP_0);
          if ( programi )
          {
            dirnameh = DirectoryOf(argl);
            HTAddParam(&buffer, "cd %s; %s -q %s", 1, dirnameh);
            HTAddParam(&buffer, "cd %s; %s -q %s", 2, programi);
            HTAddParam(&buffer, "cd %s; %s -q %s", 3, argl);
            HTEndParam(&buffer, "cd %s; %s -q %s", 3);
          }
          return buffer;
        }
        else
        {
          argm = match_op("COMPRESS", line);
          if ( argm )
          {
            programj = HTGetProgramPath(ppCOMPRESS_0);
            if ( programj )
            {
              HTAddParam(&buffer, "%s %s", 1, programj);
              HTAddParam(&buffer, "%s %s", 2, argm);
              HTEndParam(&buffer, "%s %s", 2);
            }
            return buffer;
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
}

//----- (080FD395) --------------------------------------------------------
int __cdecl local_dired(DocInfo *doc)
{
  FILE *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v5; // [esp+Ch] [ebp-2Ch]
  char *buffer; // [esp+18h] [ebp-20h]
  char *tmpbuf; // [esp+1Ch] [ebp-1Ch] BYREF
  char *tp; // [esp+20h] [ebp-18h] BYREF
  char *arg; // [esp+24h] [ebp-14h]
  char *line; // [esp+28h] [ebp-10h] BYREF
  char *line_url; // [esp+2Ch] [ebp-Ch]
  BOOLEAN do_pop_doc; // [esp+33h] [ebp-5h]

  line = 0;
  arg = 0;
  tp = 0;
  tmpbuf = 0;
  buffer = 0;
  do_pop_doc = 1;
  line_url = doc->address;
  if ( WWW_TraceFlag[0] )
  {
    if ( line_url )
      v5 = line_url;
    else
      v5 = gettext("NULL URL pointer");
    v1 = TraceFP();
    fprintf(v1, "local_dired: called for <%s>.\n", v5);
  }
  HTUnEscapeSome(line_url, "/");
  HTSACopy(&line, line_url);
  HTUnEscape(line);
  if ( match_op("CHDIR", line) )
  {
    handle_LYK_CHDIR();
    do_pop_doc = 0;
    arg = "blah";
LABEL_53:
    if ( tmpbuf )
    {
      free(tmpbuf);
      tmpbuf = 0;
    }
    if ( buffer )
      free(buffer);
    if ( line )
    {
      free(line);
      line = 0;
    }
    if ( tp )
    {
      free(tp);
      tp = 0;
    }
    if ( do_pop_doc )
      LYpop(doc);
    return 0;
  }
  arg = match_op("NEW_FILE", line);
  if ( arg )
  {
    if ( create_file(arg) > 0 )
      LYforce_no_cache = 1;
    goto LABEL_53;
  }
  arg = match_op("NEW_FOLDER", line);
  if ( arg )
  {
    if ( create_directory(arg) > 0 )
      LYforce_no_cache = 1;
    goto LABEL_53;
  }
  arg = match_op("MODIFY_NAME", line);
  if ( arg )
  {
    if ( modify_name(arg) > 0 )
      LYforce_no_cache = 1;
    goto LABEL_53;
  }
  arg = match_op("MODIFY_LOCATION", line);
  if ( arg )
  {
    if ( modify_location(arg) > 0 )
      LYforce_no_cache = 1;
    goto LABEL_53;
  }
  arg = match_op("MOVE_TAGGED", line_url);
  if ( arg )
  {
    if ( modify_tagged(arg) > 0 )
      LYforce_no_cache = 1;
    goto LABEL_53;
  }
  arg = match_op("PERMIT_SRC", line);
  if ( arg )
  {
    permit_location(0, arg, &tp);
    if ( tp )
    {
      if ( doc->address )
      {
        free(doc->address);
        doc->address = 0;
      }
      doc->address = tp;
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
  }
  else
  {
    arg = match_op("PERMIT_LOCATION", line_url);
    if ( arg )
    {
      permit_location(arg, 0, &tp);
      goto LABEL_53;
    }
    arg = match_op("REMOVE_SINGLE", line);
    if ( arg )
    {
      if ( remove_single(arg) > 0 )
        LYforce_no_cache = 1;
      goto LABEL_53;
    }
    arg = match_op("REMOVE_TAGGED", line);
    if ( arg )
    {
      if ( remove_tagged() )
        LYforce_no_cache = 1;
      goto LABEL_53;
    }
    arg = match_op("CLEAR_TAGGED", line);
    if ( arg )
    {
      clear_tags();
      goto LABEL_53;
    }
    arg = match_op("UPLOAD", line);
    if ( arg )
    {
      if ( LYUpload(line_url) )
        LYforce_no_cache = 1;
      goto LABEL_53;
    }
    LYTrimPathSep(line);
    if ( LYLastPathSep(line) )
    {
      buffer = build_command(line, 0, arg);
      if ( buffer )
      {
        if ( (int)strlen(buffer) >= LYcols - (LYShowScrollbar != 0) - 14 )
        {
          v3 = gettext("Executing system command. This might take a while.");
          HTSprintf0(&tmpbuf, v3);
        }
        else
        {
          v2 = gettext("Executing %s ");
          HTSprintf0(&tmpbuf, v2, buffer);
        }
        mustshow[0] = 1;
        statusline(tmpbuf);
        stop_curses();
        printf("%s\r\n", tmpbuf);
        LYSystem(buffer);
        start_curses();
        LYforce_no_cache = 1;
      }
      goto LABEL_53;
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
  }
  return 0;
}
// 80FD852: conditional instruction was optimized away because %dirname.4==0

//----- (080FD8EA) --------------------------------------------------------
int __cdecl dired_options(DocInfo *doc, char **newfile)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  const char *v7; // eax
  size_t v8; // ebx
  char *v9; // esi
  size_t v10; // ebx
  size_t v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  int v16; // [esp+1Ch] [ebp-8CCh]
  bool v17; // [esp+24h] [ebp-8C4h]
  char *v18; // [esp+28h] [ebp-8C0h]
  const char *relatedName; // [esp+2Ch] [ebp-8BCh]
  const char *v20; // [esp+34h] [ebp-8B4h]
  stat dir_info; // [esp+44h] [ebp-8A4h] BYREF
  int m; // [esp+A4h] [ebp-844h]
  int i; // [esp+A8h] [ebp-840h]
  char *cd; // [esp+ACh] [ebp-83Ch] BYREF
  char *cp1; // [esp+B0h] [ebp-838h] BYREF
  int n; // [esp+B4h] [ebp-834h]
  dired_menu *mp; // [esp+B8h] [ebp-830h]
  int count; // [esp+BCh] [ebp-82Ch]
  char *path_url; // [esp+C0h] [ebp-828h]
  char *dir_url; // [esp+C4h] [ebp-824h]
  FILE *fp0; // [esp+C8h] [ebp-820h]
  lynx_list_item_type *nxt; // [esp+CCh] [ebp-81Ch]
  char *dir; // [esp+D0h] [ebp-818h]
  char *path; // [esp+D4h] [ebp-814h] BYREF
  BOOLEAN nothing_tagged; // [esp+DBh] [ebp-80Dh]
  char buf[2048]; // [esp+DCh] [ebp-80Ch] BYREF
  unsigned int v37; // [esp+8DCh] [ebp-Ch]

  v37 = __readgsdword(0x14u);
  fp0 = InternalPageFP(tempfile_12181, 0);
  if ( !fp0 )
    return 0;
  LYLocalFileToURL(newfile, tempfile_12181);
  LYRegisterUIPage(*newfile, UIP_DIRED_MENU_0);
  if ( doc->link < 0 || doc->link >= nlinks + 1 )
  {
    HTSACopy(&path, &byte_817D5C4);
  }
  else
  {
    path = HTnameOfFile_WWW(links[doc->link].lname, 0, 1);
    LYTrimPathSep(path);
    if ( !ok_lstat(path, &dir_info) )
    {
      LYCloseTempFP(fp0);
      if ( path )
      {
        free(path);
        path = 0;
      }
      return 0;
    }
  }
  dir = HTnameOfFile_WWW(doc->address, 0, 1);
  LYTrimPathSep(dir);
  v17 = !tagged || !tagged->next;
  nothing_tagged = v17;
  v2 = gettext("File Management Options");
  BeginInternalPage(fp0, v2, "keystrokes/dired_help.html.gz");
  v3 = gettext("Current directory:");
  fprintf(fp0, "<em>%s</em> %s<br>\n", v3, dir);
  if ( nothing_tagged )
  {
    v4 = gettext("Current selection:");
    fprintf(fp0, "<em>%s</em> ", v4);
    if ( *path )
    {
      fprintf(fp0, "%s<p>\n", path);
    }
    else
    {
      v5 = gettext("Nothing currently selected.");
      fprintf(fp0, "%s.<p>\n", v5);
    }
  }
  else
  {
    n = HTList_count(tagged);
    cp1 = 0;
    cd = 0;
    if ( n == 1 )
      v18 = gettext("tagged item:");
    else
      v18 = gettext("tagged items:");
    v6 = gettext("Current selection:");
    fprintf(fp0, "<em>%s</em> %d %s", v6, n, v18);
    HTSACopy(&cd, doc->address);
    HTUnEscapeSome(cd, "/");
    LYAddHtmlSep(&cd);
    v16 = n;
    if ( n > 10 )
      v16 = 10;
    m = v16;
    for ( i = 1; i <= m; ++i )
    {
      if ( *cd )
        relatedName = cd;
      else
        relatedName = "file://localhost";
      v7 = (const char *)HTList_objectAt(tagged, i - 1);
      cp1 = HTRelative(v7, relatedName);
      HTUnEscape(cp1);
      LYEntify(&cp1, 1);
      if ( i == 1 )
        v20 = &byte_817D5C4;
      else
        v20 = " ,";
      fprintf(fp0, "%s<br>\n&nbsp;&nbsp;&nbsp;%s", v20, cp1);
      if ( cp1 )
      {
        free(cp1);
        cp1 = 0;
      }
    }
    if ( n > m )
      fwrite(" , ...", 1u, 6u, fp0);
    fwrite("<p>\n", 1u, 4u, fp0);
    if ( cd )
    {
      free(cd);
      cd = 0;
    }
  }
  if ( !menu_head )
  {
    for ( mp = defmenu; mp->href; ++mp )
      mp->next = mp + 1;
    --mp;
    mp->next = 0;
    menu_head = defmenu;
  }
  for ( mp = menu_head; mp; mp = mp->next )
  {
    if ( (mp->cond == 1 || nothing_tagged)
      && (mp->cond != 1 || !nothing_tagged)
      && (mp->cond != 2 || *path && (dir_info.st_mode & 0xF000) == 0x4000)
      && (mp->cond != 3 || *path && (dir_info.st_mode & 0xF000) == 0x8000)
      && (mp->cond != 4 || *path && (dir_info.st_mode & 0xF000) == 40960) )
    {
      if ( !*mp->sfx
        || (v8 = strlen(path), v8 >= strlen(mp->sfx))
        && (v9 = path, v10 = strlen(path), v11 = strlen(mp->sfx), !strcmp(mp->sfx, &v9[v10 - v11])) )
      {
        dir_url = HTEscape(dir, 4u);
        path_url = HTEscape(path, 4u);
        v12 = render_item(mp->href, path_url, dir_url, buf, 2048, 1);
        fprintf(fp0, "<a href=\"%s", v12);
        v13 = render_item(mp->link, path, dir, buf, 2048, 0);
        fprintf(fp0, "\">%s</a> ", v13);
        v14 = render_item(mp->rest, path, dir, buf, 2048, 0);
        fprintf(fp0, "%s<br>\n", v14);
        if ( dir_url )
        {
          free(dir_url);
          dir_url = 0;
        }
        if ( path_url )
        {
          free(path_url);
          path_url = 0;
        }
      }
    }
  }
  if ( path )
  {
    free(path);
    path = 0;
  }
  if ( uploaders )
  {
    fwrite("<p>Upload to current directory:<p>\n", 1u, 0x23u, fp0);
    count = 0;
    nxt = uploaders;
    while ( nxt )
    {
      fprintf(fp0, "<a href=\"LYNXDIRED://UPLOAD=%d/TO=%s\"> %s </a><br>\n", count, dir, nxt->name);
      nxt = nxt->next;
      ++count;
    }
  }
  if ( dir )
  {
    free(dir);
    dir = 0;
  }
  EndInternalPage(fp0);
  LYCloseTempFP(fp0);
  LYforce_no_cache = 1;
  return 0;
}

//----- (080FE2CA) --------------------------------------------------------
char *__cdecl get_filename(const char *prompt, char *buf, size_t bufsize)
{
  char *v3; // eax
  char *cp; // [esp+24h] [ebp-4h]
  char *cpa; // [esp+24h] [ebp-4h]

  mustshow[0] = 1;
  statusline(prompt);
  LYgetstr(buf, 0, bufsize, NORECALL);
  if ( !strstr(buf, "../") )
  {
    if ( !no_dotfiles && show_dotfiles )
      return buf;
    cp = LYLastPathSep(buf);
    cpa = cp ? cp + 1 : buf;
    if ( *cpa != 46 )
      return buf;
  }
  v3 = gettext("Illegal filename; request ignored.");
  HTAlert(v3);
  return 0;
}

//----- (080FE3A0) --------------------------------------------------------
void clear_tags()
{
  char *cp; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    cp = (char *)HTList_removeLastObject(tagged);
    if ( !cp )
      break;
    free(cp);
  }
  if ( !tagged || !tagged->next )
  {
    if ( tagged )
    {
      free(tagged);
      tagged = 0;
    }
  }
}

//----- (080FE414) --------------------------------------------------------
void __cdecl add_menu_item(char *str)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *cp; // [esp+Ch] [ebp-Ch]
  char *cpa; // [esp+Ch] [ebp-Ch]
  char *cpb; // [esp+Ch] [ebp-Ch]
  char *cpc; // [esp+Ch] [ebp-Ch]
  dired_menu *mp; // [esp+10h] [ebp-8h]
  dired_menu *tmp; // [esp+14h] [ebp-4h]
  char *stra; // [esp+20h] [ebp+8h]
  char *strb; // [esp+20h] [ebp+8h]
  char *strc; // [esp+20h] [ebp+8h]

  if ( menu_head == defmenu )
    menu_head = 0;
  tmp = (dired_menu *)calloc(1u, 0x18u);
  if ( !tmp )
    outofmem("./LYLocal.c", "add_menu_item");
  v1 = strchr(str, 58);
  *v1 = 0;
  cp = v1 + 1;
  if ( strcasecomp(str, "tag") )
  {
    if ( strcasecomp(str, "dir") )
    {
      if ( strcasecomp(str, "file") )
      {
        if ( !strcasecomp(str, "link") )
          tmp->cond = 4;
      }
      else
      {
        tmp->cond = 3;
      }
    }
    else
    {
      tmp->cond = 2;
    }
  }
  else
  {
    tmp->cond = 1;
  }
  stra = cp;
  v2 = strchr(cp, 58);
  *v2 = 0;
  cpa = v2 + 1;
  HTSACopy(&tmp->sfx, stra);
  strb = cpa;
  v3 = strchr(cpa, 58);
  *v3 = 0;
  cpb = v3 + 1;
  HTSACopy(&tmp->link, strb);
  strc = cpb;
  v4 = strchr(cpb, 58);
  *v4 = 0;
  cpc = v4 + 1;
  HTSACopy(&tmp->rest, strc);
  HTSACopy(&tmp->href, cpc);
  if ( menu_head )
  {
    for ( mp = menu_head; mp && mp->next; mp = mp->next )
      ;
    mp->next = tmp;
  }
  else
  {
    menu_head = tmp;
  }
}

//----- (080FE60E) --------------------------------------------------------
void reset_dired_menu()
{
  dired_menu *mp; // [esp+14h] [ebp-4h]

  if ( menu_head != defmenu )
  {
    for ( mp = menu_head; mp; mp = 0 )
    {
      if ( mp->sfx )
      {
        free(mp->sfx);
        mp->sfx = 0;
      }
      if ( mp->link )
      {
        free(mp->link);
        mp->link = 0;
      }
      if ( mp->rest )
      {
        free(mp->rest);
        mp->rest = 0;
      }
      if ( mp->href )
      {
        free(mp->href);
        mp->href = 0;
      }
      free(mp);
    }
    menu_head = 0;
  }
}
// 80FE6C4: conditional instruction was optimized away because %mp.4!=0

//----- (080FE6F4) --------------------------------------------------------
char *__cdecl render_item(const char *s, const char *path, const char *dir, char *buf, int bufsize, BOOLEAN url_syntax)
{
  char *v6; // eax
  int v8; // [esp+14h] [ebp-54h]
  char *v9; // [esp+18h] [ebp-50h]
  char *v10; // [esp+1Ch] [ebp-4Ch]
  char *v11; // [esp+20h] [ebp-48h]
  char *v12; // [esp+24h] [ebp-44h]
  char *v13; // [esp+28h] [ebp-40h]
  char *v14; // [esp+2Ch] [ebp-3Ch]
  const char *object; // [esp+30h] [ebp-38h]
  char *v16; // [esp+34h] [ebp-34h]
  char *v17; // [esp+38h] [ebp-30h]
  char *v18; // [esp+3Ch] [ebp-2Ch]
  char *p_overrun; // [esp+40h] [ebp-28h]
  HTList *cur; // [esp+54h] [ebp-14h]
  char *taglist; // [esp+58h] [ebp-10h] BYREF
  char *bp_0; // [esp+5Ch] [ebp-Ch]
  const char *cp; // [esp+60h] [ebp-8h]
  char overrun; // [esp+67h] [ebp-1h] BYREF

  overrun = 0;
  taglist = 0;
  bp_0 = buf;
  while ( *s && !overrun )
  {
    if ( *s != 37 )
    {
      if ( &buf[bufsize - 2] >= bp_0 )
        p_overrun = bp_0++;
      else
        p_overrun = &overrun;
      *p_overrun = *s;
      goto LABEL_81;
    }
    v8 = *++s;
    if ( v8 == 108 )
      goto LABEL_47;
    if ( v8 > 108 )
    {
      if ( v8 != 112 )
      {
        if ( v8 != 116 )
        {
LABEL_70:
          if ( &buf[bufsize - 2] >= bp_0 )
            v17 = bp_0++;
          else
            v17 = &overrun;
          *v17 = 37;
          if ( &buf[bufsize - 2] >= bp_0 )
            v18 = bp_0++;
          else
            v18 = &overrun;
          *v18 = *s;
          goto LABEL_81;
        }
LABEL_47:
        if ( tagged && tagged->next )
        {
          cur = tagged;
          while ( !overrun )
          {
            if ( cur && (cur = cur->next) != 0 )
              object = (const char *)cur->object;
            else
              object = 0;
            if ( !object )
              break;
            if ( *s == 108 && (cp = strrchr(object, 47)) != 0 )
              ++cp;
            else
              cp = object;
            HTSACat(&taglist, cp);
            HTSACat(&taglist, " ");
          }
        }
        if ( taglist )
        {
          for ( cp = taglist; *cp; ++cp )
          {
            if ( &buf[bufsize - 2] >= bp_0 )
              v16 = bp_0++;
            else
              v16 = &overrun;
            *v16 = *cp;
          }
          if ( taglist )
          {
            free(taglist);
            taglist = 0;
          }
        }
        goto LABEL_81;
      }
      cp = path;
      if ( *path != 47 )
      {
        if ( &buf[bufsize - 2] >= bp_0 )
          v10 = bp_0++;
        else
          v10 = &overrun;
        *v10 = 47;
      }
      while ( *cp )
      {
        if ( &buf[bufsize - 2] >= bp_0 )
          v11 = bp_0++;
        else
          v11 = &overrun;
        *v11 = *cp++;
      }
    }
    else
    {
      switch ( v8 )
      {
        case 'd':
          cp = dir;
          if ( *dir != 47 )
          {
            if ( &buf[bufsize - 2] >= bp_0 )
              v12 = bp_0++;
            else
              v12 = &overrun;
            *v12 = 47;
          }
          while ( *cp )
          {
            if ( &buf[bufsize - 2] >= bp_0 )
              v13 = bp_0++;
            else
              v13 = &overrun;
            *v13 = *cp++;
          }
          break;
        case 'f':
          cp = LYLastPathSep(path);
          if ( cp )
            ++cp;
          else
            cp = path;
          while ( *cp )
          {
            if ( &buf[bufsize - 2] >= bp_0 )
              v14 = bp_0++;
            else
              v14 = &overrun;
            *v14 = *cp++;
          }
          break;
        case '%':
          if ( &buf[bufsize - 2] >= bp_0 )
            v9 = bp_0++;
          else
            v9 = &overrun;
          *v9 = 37;
          break;
        default:
          goto LABEL_70;
      }
    }
LABEL_81:
    ++s;
  }
  if ( ((unsigned __int8)url_syntax & (unsigned __int8)overrun) != 0 )
  {
    v6 = gettext("Temporary URL or list would be too long.");
    HTAlert(v6);
    bp_0 = buf;
  }
  *bp_0 = 0;
  return buf;
}

//----- (080FEAE0) --------------------------------------------------------
char *__cdecl HTStrip(char *s)
{
  char *p; // [esp+Ch] [ebp-4h]
  char *pa; // [esp+Ch] [ebp-4h]

  for ( p = s; *p; ++p )
    ;
  for ( pa = p - 1; pa >= s && (*pa == 32 || *pa == 9 || *pa == 10); --pa )
    *pa = 0;
  while ( *s == 32 || *s == 9 || *s == 10 )
    ++s;
  return s;
}

//----- (080FEB61) --------------------------------------------------------
void __cdecl scan(char *name, struct_parts *parts)
{
  char *v2; // [esp+14h] [ebp-14h]
  char *p; // [esp+20h] [ebp-8h]
  char *pa; // [esp+20h] [ebp-8h]
  char *pb; // [esp+20h] [ebp-8h]
  char *pc; // [esp+20h] [ebp-8h]
  char *after_access; // [esp+24h] [ebp-4h]

  parts->access = 0;
  parts->host = 0;
  parts->absolute = 0;
  parts->relative = 0;
  parts->search = 0;
  parts->anchor = 0;
  after_access = name;
  for ( p = name; *p; ++p )
  {
    if ( *p == 58 )
    {
      *p = 0;
      parts->access = name;
      after_access = p + 1;
      break;
    }
    if ( *p == 47 || *p == 35 || *p == 59 || *p == 63 )
      break;
  }
  for ( pa = after_access; *pa; ++pa )
  {
    if ( *pa == 35 )
    {
      parts->anchor = pa + 1;
      *pa = 0;
      break;
    }
  }
  if ( *after_access == 47 )
  {
    if ( after_access[1] == 47 )
    {
      parts->host = after_access + 2;
      *after_access = 0;
      pb = strchr(parts->host, 47);
      if ( pb )
      {
        *pb = 0;
        parts->absolute = pb + 1;
      }
      else
      {
        pc = strchr(parts->host, 63);
        if ( pc )
        {
          *pc = 0;
          parts->search = pc + 1;
        }
      }
    }
    else
    {
      parts->absolute = after_access + 1;
    }
  }
  else
  {
    if ( *after_access )
      v2 = after_access;
    else
      v2 = 0;
    parts->relative = v2;
  }
  if ( parts->access
    && parts->anchor
    && strchr("lnsdLNSD", *parts->access)
    && (!parts->host && strcasecomp(parts->access, "lynxcgi")
     || !strcasecomp(parts->access, "nntp")
     || !strcasecomp(parts->access, "snews")
     || !strcasecomp(parts->access, "news")
     || !strcasecomp(parts->access, "data"))
    && (parts->relative || parts->absolute) )
  {
    *(parts->anchor - 1) = 35;
    parts->anchor = 0;
  }
}

//----- (080FEDF7) --------------------------------------------------------
char *__cdecl strchr_or_end(char *string, int ch_0)
{
  char *result; // [esp+14h] [ebp-4h]

  result = strchr(string, ch_0);
  if ( !result )
    return &string[strlen(string)];
  return result;
}

//----- (080FEE2E) --------------------------------------------------------
char *__cdecl HTParsePort(char *host, int *portp)
{
  int v2; // ebx
  FILE *v3; // eax
  int v5; // [esp+10h] [ebp-18h]
  char *next; // [esp+18h] [ebp-10h] BYREF
  char *result; // [esp+1Ch] [ebp-Ch]
  int brackets; // [esp+20h] [ebp-8h]

  brackets = 0;
  result = 0;
  *portp = 0;
  if ( host )
  {
    while ( *host && !result )
    {
      v5 = *host++;
      if ( v5 == 91 )
      {
        ++brackets;
      }
      else if ( v5 == 93 )
      {
        --brackets;
      }
      else if ( v5 == 58 && !brackets && ((*__ctype_b_loc())[(unsigned __int8)*host] & 0x800) != 0 )
      {
        next = 0;
        *portp = strtol(host, &next, 10);
        if ( next )
        {
          if ( next != host && !*next )
          {
            result = host - 1;
            if ( WWW_TraceFlag[0] )
            {
              v2 = *portp;
              v3 = TraceFP();
              fprintf(v3, "HTParsePort %d\n", v2);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080FEF59) --------------------------------------------------------
char *__cdecl HTParse(const char *aName, const char *relatedName, int wanted)
{
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  void *v6; // esp
  size_t v7; // eax
  FILE *v8; // eax
  char *relative; // ebx
  char *v10; // eax
  char *v11; // ebx
  char *v12; // eax
  size_t v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  size_t v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  size_t v22; // eax
  FILE *v23; // eax
  char *v24; // ebx
  FILE *v25; // eax
  const char *v27; // [esp+2Ch] [ebp-BCh]
  const char *v28; // [esp+30h] [ebp-B8h] BYREF
  const char *v29; // [esp+34h] [ebp-B4h]
  const char *v30; // [esp+38h] [ebp-B0h]
  const char *v31; // [esp+3Ch] [ebp-ACh]
  const char *v32; // [esp+40h] [ebp-A8h]
  const char *v33; // [esp+44h] [ebp-A4h]
  const char **v34; // [esp+48h] [ebp-A0h]
  char *access; // [esp+4Ch] [ebp-9Ch]
  char *src; // [esp+50h] [ebp-98h]
  int v37; // [esp+54h] [ebp-94h]
  UrlTypes v38; // [esp+58h] [ebp-90h]
  const char *relatedNamea; // [esp+5Ch] [ebp-8Ch]
  const char *aNamea; // [esp+60h] [ebp-88h]
  struct_parts related; // [esp+6Ch] [ebp-7Ch] BYREF
  struct_parts given; // [esp+84h] [ebp-64h] BYREF
  char *base; // [esp+9Ch] [ebp-4Ch]
  int want_detail; // [esp+A0h] [ebp-48h]
  int len3; // [esp+A4h] [ebp-44h]
  int portnumber; // [esp+A8h] [ebp-40h] BYREF
  char *h; // [esp+ACh] [ebp-3Ch]
  char *p2; // [esp+B0h] [ebp-38h]
  char *acc_method; // [esp+B4h] [ebp-34h]
  char *q; // [esp+B8h] [ebp-30h]
  char *p; // [esp+BCh] [ebp-2Ch]
  char *rel; // [esp+C0h] [ebp-28h]
  char *name; // [esp+C4h] [ebp-24h]
  unsigned int len2; // [esp+C8h] [ebp-20h]
  unsigned int len1; // [esp+CCh] [ebp-1Ch]
  unsigned int len; // [esp+D0h] [ebp-18h]
  char *return_value; // [esp+D4h] [ebp-14h] BYREF
  char *tail; // [esp+D8h] [ebp-10h]
  char *result; // [esp+DCh] [ebp-Ch]
  unsigned int v60; // [esp+E0h] [ebp-8h]

  aNamea = aName;
  relatedNamea = relatedName;
  v60 = __readgsdword(0x14u);
  result = 0;
  tail = 0;
  return_value = 0;
  name = 0;
  rel = 0;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTParse: aName:`%s'\n", aNamea);
  }
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "   relatedName:`%s'\n", relatedNamea);
  }
  if ( (wanted & 0x60) != 0 )
  {
    if ( (wanted & 0x60) == 96 )
      LOBYTE(wanted) = wanted | 4;
    if ( (wanted & 4) != 0 )
      LOBYTE(wanted) = wanted & 0x9F;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( (wanted & 0x40) != 0 )
      v27 = " QUERY";
    else
      v27 = (const char *)&unk_817EA87;
    if ( (wanted & 0x20) != 0 )
      v28 = " PATH";
    else
      v28 = (const char *)&unk_817EA87;
    if ( (wanted & 0x10) != 0 )
      v29 = " access";
    else
      v29 = (const char *)&unk_817EA87;
    if ( (wanted & 8) != 0 )
      v30 = " host";
    else
      v30 = (const char *)&unk_817EA87;
    if ( (wanted & 4) != 0 )
      v31 = " path";
    else
      v31 = (const char *)&unk_817EA87;
    if ( (wanted & 2) != 0 )
      v32 = " anchor";
    else
      v32 = (const char *)&unk_817EA87;
    if ( (wanted & 1) != 0 )
      v33 = " punc";
    else
      v33 = (const char *)&unk_817EA87;
    v5 = TraceFP();
    fprintf(v5, "   want:%s%s%s%s%s%s%s\n", v33, v32, v31, v30, v29, v28, v27);
  }
  len1 = strlen(aNamea) + 1;
  len2 = strlen(relatedNamea) + 1;
  len = len2 + len1 + 8;
  v6 = alloca(16 * ((len2 + len1 + 2 * len + 30) >> 4));
  v34 = &v28;
  tail = (char *)&v28;
  result = (char *)&v28;
  if ( !&v28 )
    outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTParse");
  *result = 0;
  name = &result[len];
  rel = &result[len + len1];
  memcpy(&result[len], aNamea, len1);
  scan(name, &given);
  if ( given.access && given.host && given.absolute || !*relatedNamea )
  {
    memset(&related, 0, sizeof(related));
  }
  else
  {
    memcpy(rel, relatedNamea, len2);
    scan(rel, &related);
  }
  if ( given.access
    && given.host
    && !given.relative
    && !given.absolute
    && (!strcmp(given.access, "http") || !strcmp(given.access, "https") || !strcmp(given.access, "ftp")) )
  {
    given.absolute = empty_string_8447;
  }
  if ( given.access )
    access = given.access;
  else
    access = related.access;
  acc_method = access;
  if ( (wanted & 0x10) != 0 )
  {
    if ( acc_method )
    {
      strcpy(tail, acc_method);
      v7 = strlen(tail);
      tail += v7;
      if ( (wanted & 1) != 0 )
      {
        *tail++ = 58;
        *tail = 0;
      }
    }
  }
  if ( given.access && related.access && strcmp(given.access, related.access) )
    memset(&related.host, 0, 20);
  if ( (wanted & 8) != 0 && (given.host || related.host) )
  {
    if ( (wanted & 1) != 0 )
    {
      *tail++ = 47;
      *tail++ = 47;
    }
    if ( given.host )
      src = given.host;
    else
      src = related.host;
    strcpy(tail, src);
    p2 = strchr(result, 64);
    if ( p2 )
      tail = p2 + 1;
    p2 = HTParsePort(result, &portnumber);
    if ( p2
      && acc_method
      && (!strcmp(acc_method, "http") && portnumber == 80
       || !strcmp(acc_method, "https") && portnumber == 443
       || !strcmp(acc_method, "gopher") && portnumber == 70
       || !strcmp(acc_method, "ftp") && portnumber == 21
       || !strcmp(acc_method, "wais") && portnumber == 210
       || !strcmp(acc_method, "nntp") && portnumber == 119
       || !strcmp(acc_method, "news") && portnumber == 119
       || !strcmp(acc_method, "newspost") && portnumber == 119
       || !strcmp(acc_method, "newsreply") && portnumber == 119
       || !strcmp(acc_method, "snews") && portnumber == 563
       || !strcmp(acc_method, "snewspost") && portnumber == 563
       || !strcmp(acc_method, "snewsreply") && portnumber == 563
       || !strcmp(acc_method, "finger") && portnumber == 79
       || !strcmp(acc_method, "telnet") && portnumber == 23
       || !strcmp(acc_method, "tn3270") && portnumber == 23
       || !strcmp(acc_method, "rlogin") && portnumber == 513
       || !strcmp(acc_method, "cso") && portnumber == 105) )
    {
      *p2 = 0;
    }
    if ( p2 )
    {
      if ( p2 != result )
      {
        h = p2 - 1;
        if ( *(p2 - 1) == 46 )
        {
          while ( *p2 )
            *h++ = *p2++;
          *h = 0;
        }
      }
    }
    else
    {
      len3 = strlen(tail);
      if ( len3 > 0 )
      {
        h = &tail[len3 - 1];
        if ( *h == 46 )
          *h = 0;
      }
    }
  }
  tail = LYRemoveBlanks(result);
  if ( !given.search || *(given.search - 1) )
  {
    if ( related.search && !related.absolute && !*(related.search - 1) )
    {
      related.absolute = related.search - 1;
      *(related.search - 1) = 63;
    }
  }
  else
  {
    given.absolute = given.search - 1;
    *(given.search - 1) = 63;
  }
  if ( given.host && related.host && strcmp(given.host, related.host) )
  {
    related.absolute = 0;
    related.relative = 0;
    related.anchor = 0;
  }
  if ( (wanted & 0x64) != 0 )
  {
    want_detail = wanted & 0x60;
    if ( !acc_method || given.absolute || !given.relative )
      goto LABEL_145;
    v37 = *acc_method;
    if ( v37 != 83 )
    {
      if ( v37 <= 83 )
      {
        if ( v37 != 78 )
        {
LABEL_145:
          if ( given.absolute )
          {
            if ( (wanted & 1) != 0 )
              *tail++ = 47;
            strcpy(tail, given.absolute);
            if ( WWW_TraceFlag[0] )
            {
              v8 = TraceFP();
              fprintf(v8, "HTParse: (ABS)\n");
            }
          }
          else if ( related.absolute )
          {
            base = tail;
            *tail++ = 47;
            strcpy(tail, related.absolute);
            if ( given.relative )
            {
              if ( *given.relative == 59 )
              {
                relative = given.relative;
                v10 = strchr_or_end(tail, 59);
                strcpy(v10, relative);
              }
              else if ( *given.relative == 63 )
              {
                v11 = given.relative;
                v12 = strchr_or_end(tail, 63);
                strcpy(v12, v11);
              }
              else
              {
                p = strchr(tail, 63);
                if ( !p )
                {
                  v13 = strlen(tail);
                  p = &tail[v13 - 1];
                }
                while ( *p != 47 )
                  --p;
                p[1] = 0;
                strcat(p, given.relative);
              }
              HTSimplify(base);
              if ( !*base )
                memcpy(base, "/", 2u);
            }
            if ( WWW_TraceFlag[0] )
            {
              v14 = TraceFP();
              fprintf(v14, "HTParse: (Related-ABS)\n");
            }
          }
          else if ( given.relative )
          {
            strcpy(tail, given.relative);
            if ( WWW_TraceFlag[0] )
            {
              v15 = TraceFP();
              fprintf(v15, "HTParse: (REL)\n");
            }
          }
          else if ( related.relative )
          {
            strcpy(tail, related.relative);
            if ( WWW_TraceFlag[0] )
            {
              v16 = TraceFP();
              fprintf(v16, "HTParse: (Related-REL)\n");
            }
          }
          else
          {
            if ( (*aNamea != 108 && *aNamea != 76 || strncasecomp(aNamea, "lynxcgi:", 8))
              && (*aNamea != 108 && *aNamea != 76 || strncasecomp(aNamea, "lynxexec:", 9))
              && (*aNamea != 108 && *aNamea != 76 || strncasecomp(aNamea, "lynxprog:", 9)) )
            {
              *tail++ = 47;
              *tail = 0;
            }
            if ( !strcmp(result, "news:/") )
              result[5] = 42;
            if ( WWW_TraceFlag[0] )
            {
              v17 = TraceFP();
              fprintf(v17, "HTParse: (No inheritance)\n");
            }
          }
          if ( want_detail )
          {
            p = strchr(tail, 63);
            if ( p )
            {
              *p = 0;
            }
            else if ( (wanted & 0x40) != 0 )
            {
              *tail = 0;
            }
          }
          goto LABEL_190;
        }
LABEL_139:
        if ( !strcasecomp(acc_method, "nntp") || !strcasecomp(acc_method, "news") && !strncasecomp(result, "news://", 7) )
        {
          given.absolute = given.relative;
          given.relative = 0;
        }
        goto LABEL_145;
      }
      if ( v37 == 110 )
        goto LABEL_139;
      if ( v37 != 115 )
        goto LABEL_145;
    }
    if ( !strcasecomp(acc_method, "snews") )
    {
      given.absolute = given.relative;
      given.relative = 0;
    }
    goto LABEL_145;
  }
LABEL_190:
  if ( (wanted & 2) != 0 && given.anchor && *given.anchor )
  {
    v18 = strlen(tail);
    tail += v18;
    if ( (wanted & 1) != 0 )
      *tail++ = 35;
    strcpy(tail, given.anchor);
  }
  p = strchr(result, 32);
  if ( p )
  {
    v38 = is_url(result);
    switch ( v38 )
    {
      case UNKNOWN_URL_TYPE_0:
        if ( WWW_TraceFlag[0] )
        {
          v19 = TraceFP();
          fprintf(v19, "HTParse:      ignore:`%s'\n", result);
        }
        break;
      case LYNXCGI_URL_TYPE_0:
      case LYNXEXEC_URL_TYPE_0:
      case LYNXPROG_URL_TYPE_0:
      case LYNXCACHE_URL_TYPE_0:
      case LYNXCFG_URL_TYPE_0:
      case LYNXCOMPILE_OPTS_URL_TYPE_0:
      case LYNXCOOKIE_URL_TYPE_0:
      case LYNXDIRED_URL_TYPE_0:
      case LYNXDOWNLOAD_URL_TYPE_0:
      case LYNXHIST_URL_TYPE_0:
      case LYNXIMGMAP_URL_TYPE_0:
      case LYNXKEYMAP_URL_TYPE_0:
      case LYNXMESSAGES_URL_TYPE_0:
      case LYNXOPTIONS_URL_TYPE_0:
      case LYNXPRINT_URL_TYPE_0:
        if ( WWW_TraceFlag[0] )
        {
          v20 = TraceFP();
          fprintf(v20, "HTParse:      spaces:`%s'\n", result);
        }
        break;
      default:
        if ( WWW_TraceFlag[0] )
        {
          v21 = TraceFP();
          fprintf(v21, "HTParse:      encode:`%s'\n", result);
        }
        do
        {
          v22 = strlen(p);
          for ( q = &p[v22 + 2]; p + 1 != q; --q )
            *q = *(q - 2);
          *p = 37;
          p[1] = 50;
          p[2] = 48;
          p = strchr(result, 32);
        }
        while ( p );
        break;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v23 = TraceFP();
    fprintf(v23, "HTParse:      result:`%s'\n", result);
  }
  HTSACopy(&return_value, result);
  if ( *relatedNamea )
  {
    if ( (wanted & 0x1D) == 29 )
    {
      LYFillLocalFileURL(&return_value, relatedNamea);
      if ( WWW_TraceFlag[0] )
      {
        v24 = return_value;
        v25 = TraceFP();
        fprintf(v25, "pass LYFillLocalFile:`%s'\n", v24);
      }
    }
  }
  return return_value;
}

//----- (080FFEAC) --------------------------------------------------------
const char *__cdecl HTParseAnchor(const char *aName)
{
  void *v1; // esp
  const char *aNamea[4]; // [esp+10h] [ebp-38h] BYREF
  struct_parts given; // [esp+20h] [ebp-28h] BYREF
  char *name; // [esp+38h] [ebp-10h]
  const char *p; // [esp+3Ch] [ebp-Ch]
  unsigned int v7; // [esp+40h] [ebp-8h]

  aNamea[0] = aName;
  v7 = __readgsdword(0x14u);
  for ( p = aName; *p && *p != 35; ++p )
    ;
  if ( *p == 35 )
  {
    v1 = alloca(16 * ((p - aNamea[0] + strlen(p) + 31) >> 4));
    name = (char *)aNamea;
    if ( !aNamea )
      outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTParseAnchor");
    strcpy(name, aNamea[0]);
    scan(name, &given);
    ++p;
    if ( !given.anchor )
    {
      while ( *p )
        ++p;
    }
  }
  return p;
}

//----- (080FFFAD) --------------------------------------------------------
void __cdecl HTSimplify(char *filename)
{
  char *q1; // [esp+1Ch] [ebp-Ch]
  char *q1a; // [esp+1Ch] [ebp-Ch]
  char *q1b; // [esp+1Ch] [ebp-Ch]
  char *q1c; // [esp+1Ch] [ebp-Ch]
  char *q1d; // [esp+1Ch] [ebp-Ch]
  char *q; // [esp+20h] [ebp-8h]
  char *qa; // [esp+20h] [ebp-8h]
  char *qb; // [esp+20h] [ebp-8h]
  char *qc; // [esp+20h] [ebp-8h]
  char *qd; // [esp+20h] [ebp-8h]
  char *p; // [esp+24h] [ebp-4h]
  char *pa; // [esp+24h] [ebp-4h]
  char *pb; // [esp+24h] [ebp-4h]

  if ( filename
    && *filename
    && filename[1]
    && *filename != 63
    && filename[1] != 63
    && filename[2] != 63
    && strchr(filename, 47) )
  {
    for ( p = filename + 2; *p && *p != 63; ++p )
    {
      if ( *p == 47 )
      {
        if ( p[1] == 46 && p[2] == 46 && (p[3] == 47 || p[3] == 63 || !p[3]) )
        {
          for ( q = p - 1; q >= filename && *q != 47; --q )
            ;
          if ( *q == 47 && strncmp(q, "/../", 4u) && strncmp(q, "/..?", 4u) && (q - 1 <= filename || *(q - 1) != 47) )
          {
            q1 = p + 3;
            pa = q;
            while ( *q1 )
              *pa++ = *q1++;
            *pa = 0;
            p = q - 1;
          }
        }
        else if ( p[1] == 46 && p[2] == 47 )
        {
          qa = p;
          for ( q1a = p + 2; *q1a; ++q1a )
            *qa++ = *q1a;
          *qa = 0;
          --p;
        }
        else if ( p[1] == 46 && p[2] == 63 )
        {
          qb = p + 1;
          for ( q1b = p + 2; *q1b; ++q1b )
            *qb++ = *q1b;
          *qb = 0;
          --p;
        }
        else if ( p[1] == 46 && !p[2] )
        {
          p[1] = 0;
        }
      }
    }
    if ( filename + 2 <= p && *p == 63 && *(p - 1) == 46 )
    {
      if ( *(p - 2) == 47 )
      {
        qc = p - 1;
        for ( q1c = p; *q1c; ++q1c )
          *qc++ = *q1c;
        *qc = 0;
        return;
      }
      if ( *(p - 2) == 46
        && filename + 4 <= p
        && *(p - 3) == 47
        && (*(p - 4) != 47 || filename + 4 < p && *(p - 5) != 58) )
      {
        for ( qd = p - 4; qd > filename && *qd != 47; --qd )
          ;
        if ( *qd == 47 )
        {
          if ( qd > filename && *(qd - 1) == 47 && (filename + 1 >= qd || *(qd - 1) == 58) )
            return;
          ++qd;
        }
        if ( strncmp(qd, "../", 3u) && strncmp(qd, "./", 2u) )
        {
          q1d = p;
          pb = qd;
          while ( *q1d )
            *pb++ = *q1d++;
          *pb = 0;
        }
      }
    }
  }
}

//----- (081003F4) --------------------------------------------------------
char *__cdecl HTRelative(const char *aName, const char *relatedName)
{
  size_t v2; // eax
  const char *v3; // ebx
  FILE *v4; // edx
  int levels; // [esp+14h] [ebp-24h]
  int slashes; // [esp+18h] [ebp-20h]
  const char *last_slash; // [esp+1Ch] [ebp-1Ch]
  const char *path; // [esp+20h] [ebp-18h]
  const char *after_access; // [esp+24h] [ebp-14h]
  const char *q; // [esp+28h] [ebp-10h]
  const char *p; // [esp+2Ch] [ebp-Ch]
  char *result[2]; // [esp+30h] [ebp-8h] BYREF

  result[0] = 0;
  p = aName;
  q = relatedName;
  after_access = 0;
  path = 0;
  last_slash = 0;
  slashes = 0;
  while ( *p && *p == *q )
  {
    if ( *p == 58 )
      after_access = p + 1;
    if ( *p == 47 )
    {
      last_slash = p;
      if ( ++slashes == 3 )
        path = p;
    }
    ++p;
    ++q;
  }
  if ( after_access )
  {
    if ( slashes > 2 )
    {
      if ( slashes == 3 )
      {
        HTSACopy(result, path);
      }
      else
      {
        levels = 0;
        while ( *q && *q != 35 )
        {
          if ( *q == 47 )
            ++levels;
          ++q;
        }
        v2 = strlen(last_slash);
        result[0] = (char *)calloc(3 * levels + v2 + 1, 1u);
        if ( !result[0] )
          outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTRelative");
        *result[0] = 0;
        while ( levels )
        {
          strcat(result[0], "../");
          --levels;
        }
        strcat(result[0], last_slash + 1);
      }
    }
    else
    {
      HTSACopy(result, after_access);
    }
  }
  else
  {
    HTSACopy(result, aName);
  }
  if ( WWW_TraceFlag[0] )
  {
    v3 = result[0];
    v4 = TraceFP();
    fprintf(v4, "HTparse: `%s' expressed relative to\n   `%s' is\n   `%s'.\n", aName, relatedName, v3);
  }
  return result[0];
}

//----- (081005CD) --------------------------------------------------------
char *__cdecl HTEscape(const char *str, unsigned __int8 mask)
{
  unsigned int unacceptable; // [esp+24h] [ebp-14h]
  char *result; // [esp+28h] [ebp-10h]
  char *q; // [esp+2Ch] [ebp-Ch]
  char *qa; // [esp+2Ch] [ebp-Ch]
  const char *p; // [esp+30h] [ebp-8h]
  const char *pa; // [esp+30h] [ebp-8h]
  unsigned __int8 a; // [esp+37h] [ebp-1h]

  unacceptable = 0;
  for ( p = str; *p; ++p )
  {
    if ( *p <= 0x1Fu || *p < 0 || (mask & isAcceptable[*(unsigned __int8 *)p - 32]) == 0 )
      ++unacceptable;
  }
  result = (char *)calloc(p - str + 2 * unacceptable + 1, 1u);
  if ( !result )
    outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTEscape");
  q = result;
  for ( pa = str; *pa; ++pa )
  {
    a = *pa;
    if ( *pa > 0x1Fu && (a & 0x80u) == 0 && (mask & isAcceptable[a - 32]) != 0 )
    {
      *q++ = *pa;
    }
    else
    {
      *q = 37;
      qa = q + 1;
      *qa = hex_0[a >> 4];
      qa[1] = hex_0[a & 0xF];
      q = qa + 2;
    }
  }
  *q = 0;
  return result;
}

//----- (08100722) --------------------------------------------------------
char *__cdecl HTEscapeUnsafe(const char *str)
{
  unsigned int unacceptable; // [esp+14h] [ebp-14h]
  char *result; // [esp+18h] [ebp-10h]
  char *q; // [esp+1Ch] [ebp-Ch]
  char *qa; // [esp+1Ch] [ebp-Ch]
  const char *p; // [esp+20h] [ebp-8h]
  const char *pa; // [esp+20h] [ebp-8h]
  unsigned __int8 a; // [esp+27h] [ebp-1h]

  unacceptable = 0;
  for ( p = str; *p; ++p )
  {
    if ( *p <= 0x20u || *p > 0x7Eu )
      ++unacceptable;
  }
  result = (char *)calloc(p - str + 2 * unacceptable + 1, 1u);
  if ( !result )
    outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTEscapeUnsafe");
  q = result;
  for ( pa = str; *pa; ++pa )
  {
    a = *pa;
    if ( *pa > 0x20u && a <= 0x7Eu )
    {
      *q++ = *pa;
    }
    else
    {
      *q = 37;
      qa = q + 1;
      *qa = hex_0[a >> 4];
      qa[1] = hex_0[a & 0xF];
      q = qa + 2;
    }
  }
  *q = 0;
  return result;
}

//----- (08100839) --------------------------------------------------------
char *__cdecl HTEscapeSP(const char *str, unsigned __int8 mask)
{
  unsigned int unacceptable; // [esp+24h] [ebp-14h]
  char *result; // [esp+28h] [ebp-10h]
  char *q; // [esp+2Ch] [ebp-Ch]
  char *qa; // [esp+2Ch] [ebp-Ch]
  const char *p; // [esp+30h] [ebp-8h]
  const char *pa; // [esp+30h] [ebp-8h]
  unsigned __int8 a; // [esp+37h] [ebp-1h]

  unacceptable = 0;
  for ( p = str; *p; ++p )
  {
    if ( *p != 32 && (*p <= 0x1Fu || *p < 0 || (mask & isAcceptable[*(unsigned __int8 *)p - 32]) == 0) )
      ++unacceptable;
  }
  result = (char *)calloc(p - str + 2 * unacceptable + 1, 1u);
  if ( !result )
    outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTEscape");
  q = result;
  for ( pa = str; *pa; ++pa )
  {
    a = *pa;
    if ( *pa == 32 )
    {
      *q++ = 43;
    }
    else if ( a > 0x1Fu && (a & 0x80u) == 0 && (mask & isAcceptable[a - 32]) != 0 )
    {
      *q++ = *pa;
    }
    else
    {
      *q = 37;
      qa = q + 1;
      *qa = hex_0[a >> 4];
      qa[1] = hex_0[a & 0xF];
      q = qa + 2;
    }
  }
  *q = 0;
  return result;
}

//----- (081009AA) --------------------------------------------------------
char __cdecl from_hex(char c)
{
  if ( c > 47 && c <= 57 )
    return c - 48;
  if ( c <= 64 || c > 70 )
    return c - 87;
  else
    return c - 55;
}

//----- (081009FD) --------------------------------------------------------
char *__cdecl HTUnEscape(char *str)
{
  char v1; // al
  char v2; // bl
  char v3; // al
  char *q; // [esp+1Ch] [ebp-Ch]
  char *p; // [esp+20h] [ebp-8h]

  p = str;
  q = str;
  if ( !str || !*str )
    return str;
  while ( *p )
  {
    if ( *p == 37
      && p[1]
      && p[2]
      && ((*__ctype_b_loc())[(unsigned __int8)p[1]] & 0x1000) != 0
      && ((*__ctype_b_loc())[(unsigned __int8)p[2]] & 0x1000) != 0 )
    {
      if ( *++p )
      {
        v1 = *p++;
        *q = 16 * from_hex(v1);
      }
      if ( *p )
      {
        v2 = *q;
        v3 = *p++;
        *q = v2 + from_hex(v3);
      }
      *q = *q;
      ++q;
    }
    else
    {
      *q++ = *p++;
    }
  }
  *q = 0;
  return str;
}

//----- (08100B5D) --------------------------------------------------------
char *__cdecl HTUnEscapeSome(char *str, const char *do_trans)
{
  char v2; // bl
  char *q; // [esp+18h] [ebp-10h]
  char *p; // [esp+1Ch] [ebp-Ch]
  char testcode; // [esp+23h] [ebp-5h]

  p = str;
  q = str;
  if ( !str || !*str || !do_trans || !*do_trans )
    return str;
  while ( *p )
  {
    if ( *p == 37
      && p[1]
      && p[2]
      && ((*__ctype_b_loc())[(unsigned __int8)p[1]] & 0x1000) != 0
      && ((*__ctype_b_loc())[(unsigned __int8)p[2]] & 0x1000) != 0
      && (v2 = 16 * from_hex(p[1]), (testcode = v2 + from_hex(p[2])) != 0)
      && strchr(do_trans, testcode) )
    {
      *q++ = testcode;
      p += 3;
    }
    else
    {
      *q++ = *p++;
    }
  }
  *q = 0;
  return str;
}

//----- (08100CC1) --------------------------------------------------------
void __cdecl HTMake822Word(char **str, int quoted)
{
  char *src; // [esp+14h] [ebp-24h]
  unsigned int added; // [esp+24h] [ebp-14h]
  char *result; // [esp+28h] [ebp-10h]
  char *q; // [esp+2Ch] [ebp-Ch]
  char *p; // [esp+30h] [ebp-8h]
  char *pa; // [esp+30h] [ebp-8h]
  unsigned __int8 a; // [esp+37h] [ebp-1h]
  unsigned __int8 aa; // [esp+37h] [ebp-1h]

  added = 0;
  if ( *str && **str )
  {
    for ( p = *str; *p; ++p )
    {
      a = *p;
      if ( (unsigned __int8)*p <= 0x1Fu || (a & 0x80u) != 0 || (crfc[a - 32] & 1) != 0 )
      {
        if ( !added )
          added = 2;
        if ( a <= 0x9Fu && a != 9 )
        {
          if ( a == 13 || a == 10 )
          {
            added += 2;
          }
          else if ( (a & 0x7Fu) <= 0x1F || (crfc[a - 32] & 2) != 0 )
          {
            ++added;
          }
        }
      }
    }
    if ( added )
    {
      result = (char *)calloc(added + p - *str + 1, 1u);
      if ( !result )
        outofmem("../../../WWW/Library/Implementation/HTParse.c", "HTMake822Word");
      q = result;
      if ( quoted )
      {
        *result = 34;
        q = result + 1;
      }
      for ( pa = *str; *pa; ++pa )
      {
        aa = *pa;
        if ( *pa != 9 && ((aa & 0x7Fu) <= 0x1F || (aa & 0x80u) == 0 && (crfc[aa - 32] & 2) != 0) )
          *q++ = 92;
        *q++ = *pa;
        if ( aa == 10 || aa == 13 && pa[1] != 10 )
          *q++ = 32;
      }
      if ( quoted )
        *q++ = 34;
      *q = 0;
      if ( *str )
      {
        free(*str);
        *str = 0;
      }
      *str = result;
    }
  }
  else
  {
    if ( quoted )
      src = (char *)&unk_817EEA0;
    else
      src = (char *)&unk_817EA87;
    HTSACopy(str, src);
  }
}

//----- (08100EE8) --------------------------------------------------------
BOOLEAN __cdecl HTRegisterProtocol(HTProtocol *protocol)
{
  if ( !protocols )
    protocols = HTList_new();
  HTList_addObject(protocols, protocol);
  return 1;
}

//----- (08100F1D) --------------------------------------------------------
void HTAccessInit()
{
  HTRegisterProtocol(&HTTP);
  HTRegisterProtocol(&HTTPS);
  HTRegisterProtocol(&HTFile);
  HTRegisterProtocol(&HTTelnet);
  HTRegisterProtocol(&HTTn3270);
  HTRegisterProtocol(&HTRlogin);
  HTRegisterProtocol(&HTFTP);
  HTRegisterProtocol(&HTNews);
  HTRegisterProtocol(&HTNNTP);
  HTRegisterProtocol(&HTNewsPost);
  HTRegisterProtocol(&HTNewsReply);
  HTRegisterProtocol(&HTSNews);
  HTRegisterProtocol(&HTSNewsPost);
  HTRegisterProtocol(&HTSNewsReply);
  HTRegisterProtocol(&HTGopher);
  HTRegisterProtocol(&HTCSO);
  HTRegisterProtocol(&HTFinger);
  LYRegisterLynxProtocols();
}

//----- (08100FF6) --------------------------------------------------------
BOOLEAN __cdecl override_proxy(const char *addr)
{
  char *v2; // [esp+4h] [ebp-44h]
  const char *v4; // [esp+14h] [ebp-34h]
  int t_len; // [esp+18h] [ebp-30h]
  int templ_port; // [esp+1Ch] [ebp-2Ch]
  const char *colon; // [esp+20h] [ebp-28h]
  const char *end; // [esp+24h] [ebp-24h]
  int h_len; // [esp+28h] [ebp-20h]
  int port; // [esp+2Ch] [ebp-1Ch]
  char *acc_method; // [esp+30h] [ebp-18h]
  char *acc_methoda; // [esp+30h] [ebp-18h]
  char *host; // [esp+38h] [ebp-10h]
  char *at; // [esp+3Ch] [ebp-Ch]
  char *p; // [esp+40h] [ebp-8h]
  char *no_proxy; // [esp+44h] [ebp-4h]

  no_proxy = getenv("no_proxy");
  port = 0;
  if ( no_proxy && !strcmp(no_proxy, "*") )
    return 1;
  if ( !addr )
    return 0;
  host = HTParse(addr, &byte_817EECB, 8);
  if ( host )
  {
    if ( *host )
    {
      at = strchr(host, 64);
      if ( at )
        v4 = at + 1;
      else
        v4 = host;
      acc_method = HTParse(addr, &byte_817EECB, 16);
      if ( acc_method )
      {
        if ( !strcmp("file", acc_method) )
        {
          if ( !strcmp(v4, "localhost") || (v2 = HTHostName(), !strcmp(v4, v2)) )
          {
            free(host);
            free(acc_method);
            return 1;
          }
        }
        free(acc_method);
      }
      if ( no_proxy )
      {
        p = strrchr(v4, 58);
        if ( p )
        {
          *p = 0;
          port = atoi(p + 1);
        }
        else
        {
          acc_methoda = HTParse(addr, &byte_817EECB, 16);
          if ( acc_methoda )
          {
            if ( !strcmp(acc_methoda, "http") )
            {
              port = 80;
            }
            else if ( !strcmp(acc_methoda, "https") )
            {
              port = 443;
            }
            else if ( !strcmp(acc_methoda, "ftp") )
            {
              port = 21;
            }
            else if ( !strcmp(acc_methoda, "gopher") )
            {
              port = 70;
            }
            else if ( !strcmp(acc_methoda, "cso") )
            {
              port = 105;
            }
            else if ( !strcmp(acc_methoda, "news") )
            {
              port = 119;
            }
            else if ( !strcmp(acc_methoda, "nntp") )
            {
              port = 119;
            }
            else if ( !strcmp(acc_methoda, "newspost") )
            {
              port = 119;
            }
            else if ( !strcmp(acc_methoda, "newsreply") )
            {
              port = 119;
            }
            else if ( !strcmp(acc_methoda, "snews") )
            {
              port = 563;
            }
            else if ( !strcmp(acc_methoda, "snewspost") )
            {
              port = 563;
            }
            else if ( !strcmp(acc_methoda, "snewsreply") )
            {
              port = 563;
            }
            else if ( !strcmp(acc_methoda, "wais") )
            {
              port = 210;
            }
            else if ( !strcmp(acc_methoda, "finger") )
            {
              port = 79;
            }
            else if ( !strcmp(acc_methoda, "telnet") )
            {
              port = 23;
            }
            else if ( !strcmp(acc_methoda, "tn3270") )
            {
              port = 23;
            }
            else if ( !strcmp(acc_methoda, "rlogin") )
            {
              port = 513;
            }
            free(acc_methoda);
          }
        }
        if ( !port )
          port = 80;
        h_len = strlen(v4);
        while ( *no_proxy )
        {
          colon = 0;
          templ_port = 0;
          while ( *no_proxy && ((unsigned __int8)*no_proxy <= 0x20u || *no_proxy == 44) )
            ++no_proxy;
          for ( end = no_proxy; *end && *end > 0x20u && *end != 44; ++end )
          {
            if ( *end == 58 )
              colon = end;
          }
          if ( colon )
          {
            templ_port = atoi(colon + 1);
            t_len = colon - no_proxy;
          }
          else
          {
            t_len = end - no_proxy;
          }
          if ( (!templ_port || templ_port == port)
            && t_len > 0
            && t_len <= h_len
            && !strncasecomp(&v4[h_len - t_len], no_proxy, t_len)
            || (!templ_port || templ_port == port)
            && t_len > 0
            && t_len <= h_len
            && ((*__ctype_b_loc())[(unsigned __int8)*no_proxy] & 0x800) != 0
            && !strncmp(host, no_proxy, t_len) )
          {
            free(host);
            return 1;
          }
          if ( !*end )
            break;
          no_proxy = (char *)(end + 1);
        }
      }
    }
    free(host);
    return 0;
  }
  return 0;
}
// 81010AC: conditional instruction was optimized away because %host.4!=0
// 810116E: conditional instruction was optimized away because %host.4!=0
// 8101186: conditional instruction was optimized away because %acc_method.4!=0
// 81011A7: conditional instruction was optimized away because %acc_method.4!=0
// 81011C5: conditional instruction was optimized away because %host.4!=0
// 8101489: conditional instruction was optimized away because %acc_method.4!=0
// 81015A7: conditional instruction was optimized away because %host.4!=0
// 8101625: conditional instruction was optimized away because %host.4!=0
// 8101664: conditional instruction was optimized away because %host.4!=0

//----- (08101682) --------------------------------------------------------
int __cdecl get_physical(const char *addr, HTParentAnchor *anchor)
{
  FILE *v2; // edx
  FILE *v3; // eax
  char *v4; // eax
  char *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  char *v9; // eax
  HTProtocol *p; // [esp+24h] [ebp-44h]
  int n; // [esp+28h] [ebp-40h]
  int i; // [esp+2Ch] [ebp-3Ch]
  char *gatewayed_0; // [esp+30h] [ebp-38h]
  char *path; // [esp+34h] [ebp-34h]
  char *cp; // [esp+38h] [ebp-30h]
  char *gatewayed; // [esp+3Ch] [ebp-2Ch] BYREF
  char *proxy; // [esp+40h] [ebp-28h]
  char *gateway; // [esp+44h] [ebp-24h]
  char *gateway_parameter; // [esp+48h] [ebp-20h] BYREF
  char *host_0; // [esp+4Ch] [ebp-1Ch]
  char *host; // [esp+50h] [ebp-18h]
  char *Server_addr; // [esp+54h] [ebp-14h] BYREF
  char *physical; // [esp+58h] [ebp-10h] BYREF
  char *acc_method; // [esp+5Ch] [ebp-Ch]
  int result; // [esp+60h] [ebp-8h]
  BOOLEAN override_flag; // [esp+67h] [ebp-1h]

  acc_method = 0;
  physical = 0;
  Server_addr = 0;
  override_flag = 0;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "get_physical %s\n", addr);
  }
  using_proxy[0] = 0;
  physical = HTTranslate(addr);
  if ( physical )
  {
    if ( anchor->isISMAPScript == 1 )
    {
      HTSACat(&physical, "?0,0");
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "HTAccess: Appending '?0,0' coordinate pair.\n");
      }
    }
    if ( !strncmp(physical, "Proxied=", 8u) )
    {
      HTAnchor_setPhysical(anchor, physical + 8);
      using_proxy[0] = 1;
    }
    else if ( !strncmp(physical, "NoProxy=", 8u) )
    {
      HTAnchor_setPhysical(anchor, physical + 8);
      override_flag = 1;
    }
    else
    {
      HTAnchor_setPhysical(anchor, physical);
    }
    if ( physical )
    {
      free(physical);
      physical = 0;
    }
    v4 = HTAnchor_physical(anchor);
    acc_method = HTParse(v4, "file:", 16);
    if ( !override_flag && !using_proxy[0] )
    {
      if ( strcasecomp(acc_method, "news") )
      {
        if ( strcasecomp(acc_method, "wais") || (host_0 = HTParse(addr, &byte_817EECB, 8)) == 0 )
        {
          HTSACopy(&Server_addr, addr);
        }
        else
        {
          if ( !strchr(host_0, 58) )
          {
            HTSACopy(&Server_addr, "wais://");
            HTSACat(&Server_addr, host_0);
            HTSACat(&Server_addr, ":210/");
          }
          free(host_0);
          host_0 = 0;
        }
      }
      else
      {
        host = HTParse(addr, &byte_817EECB, 8);
        if ( host )
        {
          if ( !strchr(host, 58) )
          {
            HTSACopy(&Server_addr, "news://");
            HTSACat(&Server_addr, host);
            HTSACat(&Server_addr, ":119/");
          }
          free(host);
          host = 0;
        }
        else if ( LYGetEnv("NNTPSERVER") )
        {
          HTSACopy(&Server_addr, "news://");
          v5 = LYGetEnv("NNTPSERVER");
          HTSACat(&Server_addr, v5);
          HTSACat(&Server_addr, ":119/");
        }
      }
      override_flag = override_proxy(Server_addr);
    }
    if ( !override_flag && !using_proxy[0] )
    {
      gateway_parameter = 0;
      HTSprintf0(&gateway_parameter, "WWW_%s_GATEWAY", acc_method);
      gateway = LYGetEnv(gateway_parameter);
      if ( !strcmp(acc_method, "file") )
        memcpy(gateway_parameter, "ftp_proxy", 0xAu);
      else
        sprintf(gateway_parameter, "%s_proxy", acc_method);
      proxy = LYGetEnv(gateway_parameter);
      if ( gateway_parameter )
      {
        free(gateway_parameter);
        gateway_parameter = 0;
      }
      if ( gateway && WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "Gateway found: %s\n", gateway);
      }
      if ( proxy && WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, "proxy server found: %s\n", proxy);
      }
      if ( proxy )
      {
        gatewayed = 0;
        HTSACopy(&gatewayed, proxy);
        if ( !strncmp(gatewayed, "http", 4u) )
        {
          cp = strrchr(gatewayed, 47);
          if ( cp )
          {
            if ( cp - gatewayed <= 7 )
              LYAddHtmlSep(&gatewayed);
          }
        }
        if ( !strncmp(addr, "file", 4u) )
        {
          HTSACat(&gatewayed, "ftp");
          HTSACat(&gatewayed, addr + 4);
        }
        else
        {
          HTSACat(&gatewayed, addr);
        }
        using_proxy[0] = 1;
        if ( anchor->isISMAPScript == 1 )
          HTSACat(&gatewayed, "?0,0");
        HTAnchor_setPhysical(anchor, gatewayed);
        if ( gatewayed )
        {
          free(gatewayed);
          gatewayed = 0;
        }
        if ( acc_method )
        {
          free(acc_method);
          acc_method = 0;
        }
        v8 = HTAnchor_physical(anchor);
        acc_method = HTParse(v8, "http:", 16);
      }
      else if ( gateway )
      {
        path = HTParse(addr, &byte_817EECB, 13);
        gatewayed_0 = HTParse(path + 1, gateway, 31);
        if ( path )
          free(path);
        HTAnchor_setPhysical(anchor, gatewayed_0);
        if ( gatewayed_0 )
          free(gatewayed_0);
        if ( acc_method )
        {
          free(acc_method);
          acc_method = 0;
        }
        v9 = HTAnchor_physical(anchor);
        acc_method = HTParse(v9, "http:", 16);
      }
    }
    if ( Server_addr )
    {
      free(Server_addr);
      Server_addr = 0;
    }
    result = -401;
    if ( !protocols )
      HTAccessInit();
    n = HTList_count(protocols);
    for ( i = 0; i < n; ++i )
    {
      p = (HTProtocol *)HTList_objectAt(protocols, i);
      if ( !strcmp(p->name, acc_method) )
      {
        HTAnchor_setProtocol(anchor, p);
        if ( acc_method )
        {
          free(acc_method);
          acc_method = 0;
        }
        result = 0;
        break;
      }
    }
    if ( acc_method )
    {
      free(acc_method);
      acc_method = 0;
    }
    return result;
  }
  else if ( redirecting_url )
  {
    return 399;
  }
  else
  {
    return -403;
  }
}
// 81018C3: conditional instruction was optimized away because %host.4!=0
// 81019D3: conditional instruction was optimized away because %host_0.4!=0

//----- (08101E41) --------------------------------------------------------
void __cdecl LYUCPushAssumed(HTParentAnchor *anchor)
{
  int v1; // ebx
  FILE *v2; // edx
  LYUCcharset *anchor_UCI; // [esp+1Ch] [ebp-Ch]
  int anchor_LYhndl; // [esp+20h] [ebp-8h]

  anchor_UCI = 0;
  if ( !anchor )
    goto LABEL_13;
  anchor_LYhndl = HTAnchor_getUCLYhndl(anchor, 1);
  if ( anchor_LYhndl >= 0 )
    anchor_UCI = HTAnchor_getUCInfoStage(anchor, 1);
  if ( anchor_UCI && anchor_UCI->MIMEname )
  {
    pushed_assume_MIMEname = UCAssume_MIMEcharset;
    UCAssume_MIMEcharset = 0;
    if ( HTCJK == JAPANESE )
      HTSACopy(&UCAssume_MIMEcharset, pushed_assume_MIMEname);
    else
      HTSACopy(&UCAssume_MIMEcharset, anchor_UCI->MIMEname);
    pushed_assume_LYhndl = anchor_LYhndl;
    if ( UCLYhndl_for_unspec != anchor_LYhndl )
    {
      if ( WWW_TraceFlag[0] )
      {
        v1 = UCLYhndl_for_unspec;
        v2 = TraceFP();
        fprintf(v2, "LYUCPushAssumed: UCLYhndl_for_unspec changed %d -> %d\n", v1, anchor_LYhndl);
      }
    }
    UCLYhndl_for_unspec = anchor_LYhndl;
  }
  else
  {
LABEL_13:
    pushed_assume_LYhndl = -1;
    if ( pushed_assume_MIMEname )
    {
      free(pushed_assume_MIMEname);
      pushed_assume_MIMEname = 0;
    }
  }
}

//----- (08101F76) --------------------------------------------------------
int LYUCPopAssumed()
{
  int v0; // ebx
  int v1; // esi
  FILE *v2; // eax

  if ( pushed_assume_LYhndl < 0 )
    return -1;
  if ( UCLYhndl_for_unspec != pushed_assume_LYhndl && WWW_TraceFlag[0] )
  {
    v0 = pushed_assume_LYhndl;
    v1 = UCLYhndl_for_unspec;
    v2 = TraceFP();
    fprintf(v2, "LYUCPopAssumed: UCLYhndl_for_unspec changed %d -> %d\n", v1, v0);
  }
  UCLYhndl_for_unspec = pushed_assume_LYhndl;
  pushed_assume_LYhndl = -1;
  if ( UCAssume_MIMEcharset )
  {
    free(UCAssume_MIMEcharset);
    UCAssume_MIMEcharset = 0;
  }
  UCAssume_MIMEcharset = pushed_assume_MIMEname;
  pushed_assume_MIMEname = 0;
  return UCLYhndl_for_unspec;
}

//----- (08102033) --------------------------------------------------------
int __cdecl HTLoad(const char *addr, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink)
{
  int (*load)(const char *, HTParentAnchor *, HTFormat, HTStream *); // ebx
  char *v5; // edx
  char *v7; // [esp+4h] [ebp-24h]
  char *v8; // [esp+8h] [ebp-20h]
  int status; // [esp+1Ch] [ebp-Ch]
  HTProtocol *p; // [esp+20h] [ebp-8h]

  status = get_physical(addr, anchor);
  if ( status == -403 )
  {
    LYFixCursesOn("show alert:");
    v8 = gettext("Access forbidden by rule");
    return HTLoadError((HTStream_0 *)sink, 500, v8);
  }
  else if ( status != 399 && status >= 0 )
  {
    v7 = HTAnchor_physical(anchor);
    LYFixCursesOnForAccess(addr, v7);
    p = (HTProtocol *)HTAnchor_protocol(anchor);
    anchor->parent->underway = 1;
    load = p->load;
    v5 = HTAnchor_physical(anchor);
    status = load(v5, anchor, format_out, sink);
    anchor->parent->underway = 0;
    LYUCPopAssumed();
  }
  return status;
}

//----- (08102113) --------------------------------------------------------
HTStream *__cdecl HTSaveStream(HTParentAnchor *anchor)
{
  HTProtocol *p; // [esp+14h] [ebp-4h]

  p = (HTProtocol *)HTAnchor_protocol(anchor);
  if ( p )
    return p->saveStream(anchor);
  else
    return 0;
}

//----- (0810214C) --------------------------------------------------------
BOOLEAN __cdecl HTLoadDocument(const char *full_address, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink)
{
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *address; // ebx
  FILE *v8; // eax
  const char *v9; // ebx
  FILE *v10; // eax
  char *v11; // eax
  FILE *v12; // eax
  HTAtom *v13; // ebx
  FILE *v14; // eax
  char *v15; // eax
  FILE *v16; // eax
  HyperDoc *v17; // eax
  char *v18; // eax
  FILE *v19; // eax
  HTAtom *v20; // ebx
  char *v21; // edx
  char *v22; // ebx
  FILE *v23; // edx
  FILE *v24; // eax
  const char *v25; // ebx
  FILE *v26; // eax
  FILE *v27; // eax
  char *v28; // eax
  FILE *v29; // eax
  FILE *v30; // eax
  FILE *v31; // eax
  FILE *v32; // eax
  char *v33; // eax
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  FILE *v37; // eax
  char *v39; // [esp+8h] [ebp-60h]
  const char *v41; // [esp+24h] [ebp-44h]
  const char *v42; // [esp+28h] [ebp-40h]
  const char *v43; // [esp+2Ch] [ebp-3Ch]
  const char *v44; // [esp+30h] [ebp-38h]
  DocAddress NewDoc; // [esp+38h] [ebp-30h] BYREF
  time_t theTime; // [esp+4Ch] [ebp-1Ch] BYREF
  char *cp; // [esp+50h] [ebp-18h] BYREF
  const char *address_to_load; // [esp+54h] [ebp-14h]
  HText *text; // [esp+58h] [ebp-10h]
  int status; // [esp+5Ch] [ebp-Ch]
  BOOLEAN ForcingNoCache; // [esp+63h] [ebp-5h]

  address_to_load = full_address;
  ForcingNoCache = LYforce_no_cache;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "HTAccess: loading document %s\n", address_to_load);
  }
  if ( use_this_url_instead )
  {
    free(use_this_url_instead);
    use_this_url_instead = 0;
  }
  permanent_redirection = 0;
  if ( redirection_attempts > 10 )
  {
    redirection_attempts = 0;
    v5 = gettext("Redirection limit of 10 URL's reached.");
    HTAlert(v5);
    return 0;
  }
  text = (HText *)HTAnchor_document(anchor);
  if ( LYinternal_flag )
  {
    if ( !text && !LYforce_no_cache )
    {
      if ( anchor->post_data )
      {
        if ( !anchor->safe )
        {
          if ( strncasecomp(full_address, "LYNXIMGMAP:", 11) )
          {
            v6 = gettext("Document with POST content not found in cache.  Resubmit?");
            if ( HTConfirm(v6) != 1 )
              return 0;
          }
        }
      }
    }
  }
  if ( !anchor->post_data )
  {
    while ( 1 )
    {
      cp = HTAnchor_physical(anchor);
      if ( !cp || strncmp(cp, "Location=", 9u) )
        break;
      if ( WWW_TraceFlag[0] )
      {
        address = anchor->address;
        v8 = TraceFP();
        fprintf(v8, "HTAccess: '%s' is a redirection URL.\n", address);
      }
      if ( WWW_TraceFlag[0] )
      {
        v9 = cp + 9;
        v10 = TraceFP();
        fprintf(v10, "HTAccess: Redirecting to '%s'\n", v9);
      }
      if ( ++redirection_attempts > 10 )
      {
        v11 = gettext("Redirection limit of 10 URL's reached.");
        HTAlert(v11);
        redirection_attempts = 0;
        if ( use_this_url_instead )
        {
          free(use_this_url_instead);
          use_this_url_instead = 0;
        }
        return 0;
      }
      HTSACopy(&use_this_url_instead, cp + 9);
      NewDoc.address = use_this_url_instead;
      NewDoc.post_data = 0;
      NewDoc.post_content_type = 0;
      NewDoc.bookmark = anchor->bookmark;
      NewDoc.isHEAD = anchor->isHEAD;
      NewDoc.safe = anchor->safe;
      anchor = HTAnchor_findAddress(&NewDoc);
    }
  }
  if ( use_this_url_instead )
  {
    if ( redirecting_url )
    {
      free(redirecting_url);
      redirecting_url = 0;
    }
    return 0;
  }
  text = (HText *)HTAnchor_document(anchor);
  if ( text && !LYforce_no_cache )
  {
    if ( LYoverride_no_cache || !HText_hasNoCacheSet(text) || !HText_AreDifferent(anchor, full_address) )
    {
      if ( WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "HTAccess: Document already in memory.\n");
      }
      HText_select(text);
      v13 = HTAnchor_format(anchor);
      if ( v13 == HTAtom_for("www/dired") )
        lynx_edit_mode = 1;
      redirection_attempts = 0;
      return 1;
    }
    ForcingNoCache = 1;
    HTSABFree(&anchor->post_data);
    if ( WWW_TraceFlag[0] )
    {
      v14 = TraceFP();
      fprintf(v14, "HTAccess: Auto-reloading document.\n");
    }
  }
  if ( HText_HaveUserChangedForms(text) )
  {
    v15 = gettext("Reloading document.  Any form entries will be lost!");
    HTAlert(v15);
  }
  LYforce_no_cache = 0;
  if ( ForcingNoCache && anchor->title )
  {
    free(anchor->title);
    anchor->title = 0;
  }
  status = HTLoad(address_to_load, anchor, format_out, sink);
  if ( WWW_TraceFlag[0] )
  {
    v16 = TraceFP();
    fprintf(v16, "HTAccess:  status=%d\n", status);
  }
  if ( text && status < 0 && (v17 = HTAnchor_document(anchor), v17 == (HyperDoc *)text) )
  {
    v18 = gettext("Loading failed, use a previous copy.");
    HTAlert(v18);
    if ( WWW_TraceFlag[0] )
    {
      v19 = TraceFP();
      fprintf(v19, "HTAccess: Loading failed, use a previous copy.\n");
    }
    HText_select(text);
    v20 = HTAnchor_format(anchor);
    if ( v20 == HTAtom_for("www/dired") )
      lynx_edit_mode = 1;
    redirection_attempts = 0;
    return 1;
  }
  else
  {
    if ( HTlogfile )
    {
      time(&theTime);
      v41 = status >= 0 ? "GET" : "FAIL";
      v42 = HTClientHost ? HTClientHost : "local";
      v21 = ctime(&theTime);
      fprintf(HTlogfile, "%24.24s %s %s %s\n", v21, v42, v41, full_address);
      fflush(HTlogfile);
      if ( WWW_TraceFlag[0] )
      {
        if ( status >= 0 )
          v43 = "GET";
        else
          v43 = "FAIL";
        if ( HTClientHost )
          v44 = HTClientHost;
        else
          v44 = "local";
        v22 = ctime(&theTime);
        v23 = TraceFP();
        fprintf(v23, "Log: %24.24s %s %s %s\n", v22, v44, v43, full_address);
      }
    }
    if ( status == 399 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v24 = TraceFP();
        fprintf(v24, "HTAccess: '%s' is a redirection URL.\n", address_to_load);
      }
      if ( WWW_TraceFlag[0] )
      {
        v25 = redirecting_url;
        v26 = TraceFP();
        fprintf(v26, "HTAccess: Redirecting to '%s'\n", v25);
      }
      if ( !strcmp(address_to_load, redirecting_url) )
      {
        ++redirection_attempts;
        if ( redirecting_url )
        {
          free(redirecting_url);
          redirecting_url = 0;
        }
        permanent_redirection = 0;
        return 1;
      }
      else
      {
        if ( permanent_redirection )
        {
          HTSACopy(&anchor->physical, "Location=");
          HTSACat(&anchor->physical, redirecting_url);
        }
        HTSACopy(&use_this_url_instead, redirecting_url);
        if ( ForcingNoCache )
          LYforce_no_cache = 1;
        ++redirection_attempts;
        if ( redirecting_url )
        {
          free(redirecting_url);
          redirecting_url = 0;
        }
        permanent_redirection = 0;
        return 0;
      }
    }
    else
    {
      redirection_attempts = 0;
      if ( redirecting_url )
      {
        free(redirecting_url);
        redirecting_url = 0;
      }
      permanent_redirection = 0;
      switch ( status )
      {
        case 200:
          if ( WWW_TraceFlag[0] )
          {
            v27 = TraceFP();
            fprintf(v27, "HTAccess: `%s' has been accessed.\n", full_address);
          }
          return 1;
        case 206:
          v28 = gettext("Loading incomplete.");
          HTAlert(v28);
          if ( WWW_TraceFlag[0] )
          {
            v29 = TraceFP();
            fprintf(v29, "HTAccess: `%s' has been accessed, partial content.\n", full_address);
          }
          return 1;
        case -204:
          if ( WWW_TraceFlag[0] )
          {
            v30 = TraceFP();
            fprintf(v30, "HTAccess: `%s' has been accessed, No data left.\n", full_address);
          }
          return 0;
        case -29999:
          if ( WWW_TraceFlag[0] )
          {
            v31 = TraceFP();
            fprintf(v31, "HTAccess: `%s' has been accessed, No data loaded.\n", full_address);
          }
          return 0;
        case -29998:
          if ( WWW_TraceFlag[0] )
          {
            v32 = TraceFP();
            fprintf(v32, "HTAccess: `%s' has been accessed, transfer interrupted.\n", full_address);
          }
          return 0;
        default:
          if ( status > 0 )
          {
            v33 = gettext("**** HTAccess: socket or file number returned by obsolete load routine!\n");
            fprintf(stderr, v33);
            v34 = gettext("**** HTAccess: Internal software error.  Please mail lynx-dev@nongnu.org!\n");
            fprintf(stderr, v34);
            v35 = gettext("**** HTAccess: Status returned was: %d\n");
            fprintf(stderr, v35, status);
            exit_immediately(1);
          }
          cp = 0;
          v36 = gettext("Can't Access");
          HTSACopy(&cp, v36);
          HTSACat(&cp, " `");
          HTSACat(&cp, full_address);
          HTSACat(&cp, "'");
          mustshow[0] = 1;
          HTProgress(cp);
          if ( cp )
          {
            free(cp);
            cp = 0;
          }
          if ( WWW_TraceFlag[0] )
          {
            v37 = TraceFP();
            fprintf(v37, "HTAccess: Can't access `%s'\n", full_address);
          }
          v39 = gettext("Unable to access document.");
          HTLoadError((HTStream_0 *)sink, 500, v39);
          return 0;
      }
    }
  }
}

//----- (08102B34) --------------------------------------------------------
BOOLEAN __cdecl HTLoadAbsolute(const DocAddress *docaddr)
{
  HTParentAnchor *Address; // eax
  HTStream *sink; // [esp+10h] [ebp-8h]
  HTFormat format_out; // [esp+14h] [ebp-4h]

  sink = HTOutputStream;
  if ( HTOutputFormat )
    format_out = HTOutputFormat;
  else
    format_out = HTAtom_for("www/present");
  Address = HTAnchor_findAddress(docaddr);
  return HTLoadDocument(docaddr->address, Address, format_out, sink);
}

//----- (08102B93) --------------------------------------------------------
BOOLEAN __cdecl HTLoadRelative(const char *relative_name, HTParentAnchor *here)
{
  DocAddress full_address; // [esp+18h] [ebp-20h] BYREF
  char *stripped; // [esp+2Ch] [ebp-Ch]
  char *mycopy; // [esp+30h] [ebp-8h] BYREF
  BOOLEAN result; // [esp+37h] [ebp-1h]

  mycopy = 0;
  memset(&full_address, 0, 18);
  HTSACopy(&mycopy, relative_name);
  stripped = HTStrip(mycopy);
  full_address.address = HTParse(stripped, here->address, 29);
  result = HTLoadAbsolute(&full_address);
  if ( full_address.address )
  {
    free(full_address.address);
    full_address.address = 0;
  }
  if ( mycopy )
  {
    free(mycopy);
    mycopy = 0;
  }
  return result;
}

//----- (08102C51) --------------------------------------------------------
BOOLEAN __cdecl HTLoadAnchor(HTAnchor *destination)
{
  HTStream *sink; // [esp+20h] [ebp-18h]
  HTFormat format_out; // [esp+24h] [ebp-14h]
  HText *text; // [esp+2Ch] [ebp-Ch]
  HTParentAnchor *parent; // [esp+30h] [ebp-8h]
  BOOLEAN loaded; // [esp+37h] [ebp-1h]

  loaded = 0;
  if ( !destination )
    return 0;
  parent = HTAnchor_parent(destination);
  if ( !HTAnchor_document(parent) )
  {
    sink = HTOutputStream;
    if ( HTOutputFormat )
      format_out = HTOutputFormat;
    else
      format_out = HTAtom_for("www/present");
    if ( !HTLoadDocument(parent->address, parent, format_out, sink) )
      return 0;
    loaded = 1;
  }
  text = (HText *)HTAnchor_document(parent);
  if ( destination == (HTAnchor *)parent || (HTAnchor *)parent->parent == destination )
  {
    if ( !loaded )
      HText_select(text);
  }
  else
  {
    HText_selectAnchor(text, (HTChildAnchor *)destination);
  }
  return 1;
}

//----- (08102D36) --------------------------------------------------------
char __cdecl hex_1(int i)
{
  return a0123456789abcd_0[i];
}

//----- (08102D4E) --------------------------------------------------------
BOOLEAN __cdecl HTSearch(const char *keywords, HTParentAnchor *here)
{
  size_t v2; // eax
  size_t v3; // eax
  char *escaped; // [esp+8h] [ebp-20h]
  char *address; // [esp+Ch] [ebp-1Ch] BYREF
  const char *e; // [esp+10h] [ebp-18h]
  const char *s; // [esp+14h] [ebp-14h]
  const char *p; // [esp+18h] [ebp-10h]
  char *u; // [esp+1Ch] [ebp-Ch]
  char *q; // [esp+20h] [ebp-8h]
  unsigned __int8 c; // [esp+26h] [ebp-2h]
  BOOLEAN result; // [esp+27h] [ebp-1h]

  address = 0;
  v2 = strlen(keywords);
  escaped = (char *)calloc(3 * v2 + 1, 1u);
  if ( !escaped )
    outofmem("../../../WWW/Library/Implementation/HTAccess.c", "HTSearch");
  HTSACopy(&address, here->isIndexAction);
  for ( s = keywords; *s && *s <= 0x20u; ++s )
    ;
  v3 = strlen(s);
  for ( e = &s[v3]; e > s && *(e - 1) <= 0x20u; --e )
    ;
  q = escaped;
  for ( p = s; p < e; ++p )
  {
    c = *p;
    if ( *p > 0x20u )
    {
      if ( HTCJK )
      {
        *q++ = *p;
      }
      else if ( c > 0x1Fu && (c & 0x80u) == 0 && isAcceptable_11707[c - 32] )
      {
        *q++ = *p;
      }
      else
      {
        *q++ = 37;
        *q++ = hex_1(c >> 4);
        *q++ = hex_1(c & 0xF);
      }
    }
    else
    {
      *q++ = 43;
    }
  }
  *q = 0;
  u = strchr(address, 63);
  if ( u )
    *u = 0;
  HTSACat(&address, "?");
  HTSACat(&address, escaped);
  free(escaped);
  result = HTLoadRelative(address, here);
  if ( address )
  {
    free(address);
    address = 0;
  }
  return result;
}
// 8102F1F: conditional instruction was optimized away because %escaped.4!=0

//----- (08102F67) --------------------------------------------------------
BOOLEAN __cdecl HTSearchAbsolute(const char *keywords, char *indexname)
{
  DocAddress abs_doc; // [esp+10h] [ebp-18h] BYREF
  HTParentAnchor *anchor; // [esp+24h] [ebp-4h]

  abs_doc.address = indexname;
  memset(&abs_doc.post_data, 0, 14);
  anchor = HTAnchor_findAddress(&abs_doc);
  return HTSearch(keywords, anchor);
}

//----- (08102FB4) --------------------------------------------------------
void __cdecl strip_userid(char *host)
{
  FILE *v1; // eax
  char *v2; // eax
  bool v3; // al
  char *msg; // [esp+18h] [ebp-10h] BYREF
  char *fake; // [esp+1Ch] [ebp-Ch]
  char *p2; // [esp+20h] [ebp-8h]
  char *p1; // [esp+24h] [ebp-4h]

  p1 = host;
  p2 = strchr(host, 64);
  if ( p2 )
  {
    *p2++ = 0;
    fake = HTParse(host, &byte_817F5C0, 8);
    if ( fake )
    {
      msg = 0;
      if ( WWW_TraceFlag[0] )
      {
        v1 = TraceFP();
        fprintf(v1, "parsed:%s\n", fake);
      }
      v2 = gettext("Address contains a username: %s");
      HTSprintf0(&msg, v2, host);
      HTAlert(msg);
      if ( msg )
      {
        free(msg);
        msg = 0;
      }
    }
    do
    {
      *p1 = *p2;
      v3 = *p1++ != 0;
      ++p2;
    }
    while ( v3 );
  }
}

//----- (081030AC) --------------------------------------------------------
BOOLEAN __cdecl acceptEncoding(int code)
{
  const char *program; // [esp+10h] [ebp-8h]
  BOOLEAN result; // [esp+17h] [ebp-1h]

  result = 0;
  if ( (code & LYAcceptEncoding) != 0 )
  {
    program = 0;
    if ( code == 2 )
    {
      program = HTGetProgramPath(ppINFLATE_0);
    }
    else if ( code > 2 )
    {
      if ( code == 4 )
      {
        program = HTGetProgramPath(ppCOMPRESS_0);
      }
      else if ( code == 8 )
      {
        program = HTGetProgramPath(ppBZIP2_0);
      }
    }
    else if ( code == 1 )
    {
      program = HTGetProgramPath(ppGZIP_0);
    }
    return program != 0;
  }
  return result;
}

//----- (08103143) --------------------------------------------------------
int __cdecl HTLoadHTTP(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  int v9; // ebx
  FILE *v10; // eax
  char *v11; // eax
  size_t v12; // eax
  FILE *v13; // eax
  char *v14; // ebx
  char *v15; // ebx
  FILE *v16; // eax
  char *v17; // eax
  char *v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  FILE *v22; // eax
  char *v23; // eax
  char *v24; // eax
  FILE *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  FILE *v28; // eax
  FILE *v29; // eax
  char *v30; // eax
  FILE *v31; // eax
  FILE *v32; // eax
  char *v33; // eax
  FILE *v34; // eax
  char *v35; // eax
  FILE *v36; // eax
  char *v37; // eax
  int v38; // ebx
  FILE *v39; // eax
  FILE *v40; // eax
  FILE *v41; // eax
  char *v42; // eax
  FILE *v43; // eax
  char *v44; // eax
  FILE *v45; // eax
  char *v46; // eax
  FILE *v47; // eax
  int v48; // ebx
  FILE *v49; // eax
  char *v50; // eax
  FILE *v51; // eax
  FILE *v52; // eax
  FILE *v53; // eax
  char *v54; // eax
  char *v55; // eax
  char *v56; // eax
  char *v57; // eax
  char *name; // ebx
  FILE *v59; // eax
  const char *v60; // ebx
  FILE *v61; // eax
  FILE *v62; // eax
  size_t v63; // eax
  size_t v64; // eax
  char *v65; // eax
  char *v66; // eax
  char *v67; // eax
  char *v68; // eax
  FILE *v69; // eax
  char *v70; // eax
  int v71; // ebx
  FILE *v72; // eax
  char *v73; // eax
  char *v74; // eax
  char *v75; // eax
  int v76; // ebx
  FILE *v77; // eax
  char *v78; // eax
  char *v79; // eax
  char *v80; // eax
  char *v81; // eax
  FILE *v82; // eax
  char *v83; // eax
  HTStream *v84; // eax
  char *v85; // esi
  char *v86; // ebx
  char *v87; // eax
  FILE *v88; // eax
  const char *v89; // ebx
  FILE *v90; // eax
  FILE *v91; // eax
  char *v92; // ebx
  const char *v93; // ebx
  FILE *v94; // eax
  const char *v96; // [esp+4Ch] [ebp-1ACh]
  const char *v97; // [esp+50h] [ebp-1A8h]
  const char *v98; // [esp+58h] [ebp-1A0h]
  int v99; // [esp+60h] [ebp-198h]
  int v100; // [esp+64h] [ebp-194h]
  char *format; // [esp+68h] [ebp-190h]
  char *v102; // [esp+6Ch] [ebp-18Ch]
  char *post_content_type; // [esp+70h] [ebp-188h]
  int v104; // [esp+78h] [ebp-180h]
  int v105; // [esp+7Ch] [ebp-17Ch]
  int v106; // [esp+80h] [ebp-178h]
  const char *src; // [esp+84h] [ebp-174h]
  char *v108; // [esp+88h] [ebp-170h]
  int v109; // [esp+8Ch] [ebp-16Ch]
  char *buf; // [esp+90h] [ebp-168h]
  char *v111; // [esp+94h] [ebp-164h]
  int v112; // [esp+98h] [ebp-160h]
  int v113; // [esp+A8h] [ebp-150h]
  int v114; // [esp+ACh] [ebp-14Ch]
  char *buffer; // [esp+C8h] [ebp-130h] BYREF
  FILE *error_file; // [esp+CCh] [ebp-12Ch]
  int fields; // [esp+D0h] [ebp-128h]
  int buffer_length; // [esp+D4h] [ebp-124h]
  char *path2; // [esp+D8h] [ebp-120h]
  char *host2; // [esp+DCh] [ebp-11Ch]
  char *cookie; // [esp+E0h] [ebp-118h]
  char *auth; // [esp+E4h] [ebp-114h]
  int portnumber; // [esp+E8h] [ebp-110h] BYREF
  char *colon; // [esp+ECh] [ebp-10Ch]
  char *hostname; // [esp+F0h] [ebp-108h]
  char *docname; // [esp+F4h] [ebp-104h]
  char *abspath; // [esp+F8h] [ebp-100h]
  int nn; // [esp+FCh] [ebp-FCh]
  char *pound; // [esp+100h] [ebp-F8h]
  const char *cp_0; // [esp+104h] [ebp-F4h]
  char *cp; // [esp+108h] [ebp-F0h]
  int k; // [esp+10Ch] [ebp-ECh]
  int j; // [esp+110h] [ebp-E8h]
  HTPresentation *pres; // [esp+114h] [ebp-E4h]
  char *host; // [esp+118h] [ebp-E0h]
  int i; // [esp+11Ch] [ebp-DCh]
  int n; // [esp+120h] [ebp-D8h]
  char *p1; // [esp+124h] [ebp-D4h]
  void *handle; // [esp+128h] [ebp-D0h]
  int len; // [esp+12Ch] [ebp-CCh]
  int server_status; // [esp+130h] [ebp-C8h] BYREF
  int rv; // [esp+134h] [ebp-C4h]
  int rawlength; // [esp+138h] [ebp-C0h]
  int length; // [esp+13Ch] [ebp-BCh]
  char *linebuf; // [esp+140h] [ebp-B8h] BYREF
  int real_length_of_line; // [esp+144h] [ebp-B4h]
  char *line_kept_clean; // [esp+148h] [ebp-B0h]
  char *line_buffer; // [esp+14Ch] [ebp-ACh]
  const char *METHOD; // [esp+150h] [ebp-A8h]
  HTFormat format_in; // [esp+154h] [ebp-A4h]
  HTStream *target; // [esp+158h] [ebp-A0h]
  int bytes_already_read; // [esp+15Ch] [ebp-9Ch]
  int status; // [esp+160h] [ebp-98h]
  char *start_of_data; // [esp+164h] [ebp-94h]
  char *eol; // [esp+168h] [ebp-90h]
  bstring *command; // [esp+16Ch] [ebp-8Ch] BYREF
  const char *url; // [esp+170h] [ebp-88h]
  int s; // [esp+174h] [ebp-84h] BYREF
  char crlf[3]; // [esp+178h] [ebp-80h] BYREF
  BOOLEAN end_of_file; // [esp+17Bh] [ebp-7Dh]
  BOOLEAN secure; // [esp+17Ch] [ebp-7Ch]
  BOOLEAN already_retrying; // [esp+17Dh] [ebp-7Bh]
  BOOLEAN doing_redirect; // [esp+17Eh] [ebp-7Ah]
  BOOLEAN auth_proxy; // [esp+17Fh] [ebp-79h]
  BOOLEAN show_407; // [esp+180h] [ebp-78h]
  BOOLEAN show_401; // [esp+181h] [ebp-77h]
  BOOLEAN first_Accept; // [esp+182h] [ebp-76h]
  BOOLEAN extensions; // [esp+183h] [ebp-75h]
  BOOLEAN had_header; // [esp+184h] [ebp-74h]
  BOOLEAN do_post; // [esp+185h] [ebp-73h]
  BOOLEAN do_head; // [esp+186h] [ebp-72h]
  char temp[80]; // [esp+187h] [ebp-71h] BYREF
  char server_version[21]; // [esp+1D7h] [ebp-21h] BYREF
  unsigned int v176; // [esp+1ECh] [ebp-Ch]

  v176 = __readgsdword(0x14u);
  url = arg;
  command = 0;
  do_head = 0;
  do_post = 0;
  real_length_of_line = 0;
  linebuf = 0;
  first_Accept = 1;
  show_401 = 0;
  show_407 = 0;
  auth_proxy = 0;
  already_retrying = 0;
  len = 0;
  handle = 0;
  if ( anAnchor->isHEAD )
  {
    do_head = 1;
  }
  else if ( anAnchor->post_data )
  {
    do_post = 1;
  }
  if ( !url )
  {
    status = -3;
    mustshow[0] = 1;
    v4 = gettext("Bad request!");
    HTProgress(v4);
    goto done;
  }
  if ( !*url )
  {
    status = -2;
    mustshow[0] = 1;
    v5 = gettext("Bad request!");
    HTProgress(v5);
    goto done;
  }
  sprintf(crlf, "%c%c", 13, 10);
  extensions = 1;
  while ( 1 )
  {
try_again:
    eol = 0;
    had_header = 0;
    length = 0;
    doing_redirect = 0;
    permanent_redirection = 0;
    redirect_post_content[0] = 0;
    target = 0;
    line_buffer = 0;
    line_kept_clean = 0;
    if ( !strncmp(url, "https", 5u) )
    {
      v6 = gettext("This client does not contain support for HTTPS URLs.");
      HTAlert(v6);
      status = -29999;
      goto done;
    }
    status = HTDoConnect(arg, "HTTP", 80, &s);
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, "HTTP: Interrupted on connect; recovering cleanly.\n");
      }
      mustshow[0] = 1;
      v8 = gettext("Connection interrupted.");
      HTProgress(v8);
      status = -29999;
      goto done;
    }
    if ( status < 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v9 = *__errno_location();
        v10 = TraceFP();
        fprintf(v10, "HTTP: Unable to connect to remote host for `%s' (errno = %d).\n", url, v9);
      }
      v11 = gettext("Unable to connect to remote host.");
      HTAlert(v11);
      status = -29999;
      goto done;
    }
    p1 = HTParse(url, &byte_817F5C0, 5);
    if ( do_post )
    {
      METHOD = "POST";
      HTSABCopy0(&command, "POST ");
    }
    else if ( do_head )
    {
      METHOD = "HEAD";
      HTSABCopy0(&command, "HEAD ");
    }
    else
    {
      METHOD = "GET";
      HTSABCopy0(&command, "GET ");
    }
    if ( using_proxy[0] )
      HTSABCat0(&command, p1 + 1);
    else
      HTSABCat0(&command, p1);
    if ( p1 )
    {
      free(p1);
      p1 = 0;
    }
    if ( extensions )
    {
      HTSABCat0(&command, " ");
      HTSABCat0(&command, "HTTP/1.0");
    }
    HTSABCat0(&command, crlf);
    if ( extensions )
    {
      host = 0;
      host = HTParse(anAnchor->address, &byte_817F5C0, 8);
      if ( host )
      {
        strip_userid(host);
        HTBprintf(&command, "Host: %s%c%c", host, 13, 10);
        if ( host )
        {
          free(host);
          host = 0;
        }
      }
      if ( !HTPresentations )
        HTFormatInit();
      n = HTList_count(HTPresentations);
      first_Accept = 1;
      len = 0;
      for ( i = 0; i < n; ++i )
      {
        pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
        if ( pres->get_accept )
        {
          if ( pres->quality >= 1.0 )
          {
            if ( pres->maxbytes <= 0 )
              temp[0] = 0;
            else
              sprintf(temp, ";mxb=%lld", pres->maxbytes);
          }
          else if ( pres->maxbytes <= 0 )
          {
            sprintf(temp, ";q=%4.3f", pres->quality);
          }
          else
          {
            sprintf(temp, ";q=%4.3f;mxb=%lld", pres->quality, pres->maxbytes);
          }
          if ( first_Accept )
            v96 = "Accept: ";
          else
            v96 = ", ";
          HTSprintf0(&linebuf, "%s%s%s", v96, pres->rep->name, temp);
          v12 = strlen(linebuf);
          len += v12;
          if ( len > 252 && !first_Accept )
          {
            HTSABCat0(&command, crlf);
            HTSprintf0(&linebuf, "Accept: %s%s", pres->rep->name, temp);
            len = strlen(linebuf);
          }
          HTSABCat0(&command, linebuf);
          first_Accept = 0;
        }
      }
      if ( first_Accept )
        v97 = "Accept: ";
      else
        v97 = ", ";
      HTBprintf(&command, "%s*/*;q=0.01%c%c", v97, 13, 10);
      first_Accept = 0;
      len = 0;
      if ( LYPrependBaseToSource && dump_output_immediately )
      {
        if ( WWW_TraceFlag[0] )
        {
          v13 = TraceFP();
          fprintf(v13, "omit Accept-Encoding to work-around interaction with -source\n");
        }
      }
      else
      {
        portnumber = 0;
        for ( j = 1; j <= 14; j *= 2 )
        {
          if ( acceptEncoding(j) )
          {
            for ( k = 0; tbl_preferred_encoding[k].name; ++k )
            {
              if ( tbl_preferred_encoding[k].value == j )
              {
                if ( portnumber )
                  HTSACat((char **)&portnumber, ", ");
                HTSACat((char **)&portnumber, tbl_preferred_encoding[k].name);
                break;
              }
            }
          }
        }
        if ( portnumber )
        {
          HTBprintf(&command, "Accept-Encoding: %s%c%c", (const char *)portnumber, 13, 10);
          free((void *)portnumber);
        }
      }
      if ( language && *language )
        HTBprintf(&command, "Accept-Language: %s%c%c", language, 13, 10);
      if ( pref_charset && *pref_charset )
      {
        HTSABCat0(&command, "Accept-Charset: ");
        HTSACopy(&linebuf, pref_charset);
        v14 = linebuf;
        if ( v14[strlen(linebuf) - 1] == 44 )
        {
          v15 = linebuf;
          v15[strlen(linebuf) - 1] = 0;
        }
        LYLowerCase(linebuf);
        if ( !strstr(linebuf, "iso-8859-1") )
          HTSACat(&linebuf, ", iso-8859-1;q=0.01");
        if ( !strstr(linebuf, "us-ascii") )
          HTSACat(&linebuf, ", us-ascii;q=0.01");
        HTSABCat0(&command, linebuf);
        HTBprintf(&command, "%c%c", 13, 10);
      }
      if ( reloading[0] )
      {
        HTBprintf(&command, "Pragma: no-cache%c%c", 13, 10);
        HTBprintf(&command, "Cache-Control: no-cache%c%c", 13, 10);
      }
      if ( LYUserAgent && *LYUserAgent )
      {
        cp = LYSkipBlanks(LYUserAgent);
        if ( *cp )
          HTBprintf(&command, "User-Agent: %.*s%c%c", 1521, LYUserAgent, 13, 10);
      }
      else
      {
        if ( HTAppVersion )
          v98 = HTAppVersion;
        else
          v98 = "0.0";
        if ( HTAppName )
          HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c", HTAppName, v98, HTLibraryVersion, 13, 10);
        else
          HTBprintf(&command, "User-Agent: %s/%s  libwww-FM/%s%c%c", "unknown", v98, HTLibraryVersion, 13, 10);
      }
      if ( personal_mail_address && !LYNoFromHeader )
        HTBprintf(&command, "From: %s%c%c", personal_mail_address, 13, 10);
      if ( !LYUserSpecifiedURL && !LYNoRefererHeader && !LYNoRefererForThis && *HTLoadedDocumentURL() )
      {
        cp_0 = LYRequestReferer;
        if ( !LYRequestReferer )
          cp_0 = HTLoadedDocumentURL();
        HTSABCat0(&command, "Referer: ");
        if ( strncasecomp(cp_0, "LYNXIMGMAP:", 11) )
        {
          HTSABCat0(&command, cp_0);
        }
        else
        {
          pound = strchr(cp_0, 35);
          if ( pound )
            v99 = pound - cp_0;
          else
            v99 = strlen(cp_0);
          nn = v99;
          HTSABCat(&command, cp_0 + 11, v99);
        }
        HTBprintf(&command, "%c%c", 13, 10);
      }
      cookie = 0;
      secure = strncmp(anAnchor->address, "https", 5u) == 0;
      abspath = HTParse(arg, &byte_817F5C0, 5);
      docname = HTParse(arg, &byte_817F5C0, 4);
      hostname = HTParse(arg, &byte_817F5C0, 8);
      if ( hostname && (colon = HTParsePort(hostname, &portnumber)) != 0 )
      {
        *colon = 0;
      }
      else if ( !strncmp(arg, "https", 5u) )
      {
        portnumber = 443;
      }
      else
      {
        portnumber = 80;
      }
      if ( using_proxy[0] )
      {
        host2 = 0;
        path2 = 0;
        if ( !strncmp(docname, "https", 5u) )
          v100 = 443;
        else
          v100 = 80;
        buffer = (char *)v100;
        host2 = HTParse(docname, &byte_817F5C0, 8);
        path2 = HTParse(docname, &byte_817F5C0, 5);
        if ( host2 )
        {
          colon = HTParsePort(host2, (int *)&buffer);
          if ( colon )
            *colon = 0;
        }
        auth_proxy = 0;
        auth = HTAA_composeAuth(host2, (const int)buffer, path2, 0);
        if ( auth && *auth )
        {
          HTBprintf(&command, "%s%c%c", auth, 13, 10);
          if ( WWW_TraceFlag[0] )
          {
            v16 = TraceFP();
            fprintf(v16, "HTTP: Sending authorization: %s\n", auth);
          }
        }
        else if ( !auth || *auth )
        {
          if ( WWW_TraceFlag[0] )
          {
            v19 = TraceFP();
            fprintf(v19, "HTTP: Not sending authorization (yet).\n");
          }
        }
        else
        {
          if ( traversal
            || dump_output_immediately
            || (v17 = gettext("Proceed without a username and password?"), !HTConfirm(v17)) )
          {
            if ( traversal || dump_output_immediately )
            {
              v18 = gettext("Can't proceed without a username and password.");
              HTAlert(v18);
            }
            HTSABFree(&command);
            if ( hostname )
            {
              free(hostname);
              hostname = 0;
            }
            if ( docname )
            {
              free(docname);
              docname = 0;
            }
            if ( abspath )
            {
              free(abspath);
              abspath = 0;
            }
            if ( host2 )
            {
              free(host2);
              host2 = 0;
            }
            if ( path2 )
            {
              free(path2);
              path2 = 0;
            }
            status = -29999;
            goto done;
          }
          show_401 = 1;
        }
        if ( !strncmp(docname, "http", 4u) )
          cookie = LYAddCookieHeader(host2, path2, (int)buffer, secure);
        if ( host2 )
        {
          free(host2);
          host2 = 0;
        }
        if ( path2 )
        {
          free(path2);
          path2 = 0;
        }
        auth_proxy = 1;
      }
      else
      {
        cookie = LYAddCookieHeader(hostname, abspath, portnumber, secure);
        auth_proxy = 0;
      }
      if ( cookie )
      {
        if ( *cookie != 36 )
        {
          HTSABCat0(&command, "Cookie2: $Version=\"1\"");
          HTSABCat0(&command, crlf);
          if ( WWW_TraceFlag[0] )
          {
            v20 = TraceFP();
            fprintf(v20, "HTTP: Sending Cookie2: $Version =\"1\"\n");
          }
        }
        if ( *cookie )
        {
          HTSABCat0(&command, "Cookie: ");
          HTSABCat0(&command, cookie);
          HTSABCat0(&command, crlf);
          if ( WWW_TraceFlag[0] )
          {
            v21 = TraceFP();
            fprintf(v21, "HTTP: Sending Cookie: %s\n", cookie);
          }
        }
        if ( cookie )
        {
          free(cookie);
          cookie = 0;
        }
      }
      if ( abspath )
      {
        free(abspath);
        abspath = 0;
      }
      auth = HTAA_composeAuth(hostname, portnumber, docname, auth_proxy);
      if ( auth && *auth )
      {
        HTBprintf(&command, "%s%c%c", auth, 13, 10);
        if ( WWW_TraceFlag[0] )
        {
          if ( auth_proxy )
            format = "HTTP: Sending proxy authorization: %s\n";
          else
            format = "HTTP: Sending authorization: %s\n";
          v22 = TraceFP();
          fprintf(v22, format, auth);
        }
      }
      else if ( !auth || *auth )
      {
        if ( WWW_TraceFlag[0] )
        {
          if ( auth_proxy )
            v102 = "HTTP: Not sending proxy authorization (yet).\n";
          else
            v102 = "HTTP: Not sending authorization (yet).\n";
          v25 = TraceFP();
          fprintf(v25, v102);
        }
      }
      else
      {
        if ( traversal
          || dump_output_immediately
          || (v23 = gettext("Proceed without a username and password?"), !HTConfirm(v23)) )
        {
          if ( traversal || dump_output_immediately )
          {
            v24 = gettext("Can't proceed without a username and password.");
            HTAlert(v24);
          }
          HTSABFree(&command);
          if ( hostname )
          {
            free(hostname);
            hostname = 0;
          }
          if ( docname )
          {
            free(docname);
            docname = 0;
          }
          status = -29999;
          goto done;
        }
        if ( auth_proxy == 1 )
          show_407 = 1;
        else
          show_401 = 1;
      }
      if ( hostname )
      {
        free(hostname);
        hostname = 0;
      }
      if ( docname )
      {
        free(docname);
        docname = 0;
      }
      auth_proxy = 0;
    }
    if ( do_post )
    {
      if ( WWW_TraceFlag[0] )
      {
        if ( anAnchor->post_content_type )
          post_content_type = anAnchor->post_content_type;
        else
          post_content_type = "lose";
        v26 = TraceFP();
        fprintf(v26, "HTTP: Doing post, content-type '%s'\n", post_content_type);
      }
      if ( anAnchor->post_content_type )
        HTBprintf(&command, "Content-type: %s%c%c", anAnchor->post_content_type, 13, 10);
      else
        HTBprintf(&command, "Content-type: %s%c%c", "lose", 13, 10);
      if ( anAnchor->post_data && anAnchor->post_data->len )
      {
        if ( anAnchor->post_data )
          v105 = anAnchor->post_data->len;
        else
          v105 = 0;
        v104 = v105;
      }
      else
      {
        v104 = 0;
      }
      HTBprintf(&command, "Content-length: %d%c%c", v104, 13, 10);
      HTSABCat0(&command, crlf);
      if ( anAnchor->post_data )
        v106 = anAnchor->post_data->len;
      else
        v106 = 0;
      if ( anAnchor->post_data )
        src = anAnchor->post_data->str;
      else
        src = 0;
      HTSABCat(&command, src, v106);
    }
    else
    {
      HTSABCat0(&command, crlf);
    }
    if ( WWW_TraceFlag[0] )
    {
      v27 = TraceFP();
      fprintf(v27, "Writing:\n");
      trace_bstring(command);
      if ( WWW_TraceFlag[0] )
      {
        if ( anAnchor->post_data )
          v108 = crlf;
        else
          v108 = (char *)&byte_817F5C0;
        v28 = TraceFP();
        fprintf(v28, "%s", v108);
      }
      if ( WWW_TraceFlag[0] )
      {
        v29 = TraceFP();
        fprintf(v29, "----------------------------------\n");
      }
    }
    mustshow[0] = 1;
    v30 = gettext("Sending HTTP request.");
    HTProgress(v30);
    if ( command )
      v109 = command->len;
    else
      v109 = 0;
    if ( command )
      buf = command->str;
    else
      buf = 0;
    status = write(s, buf, v109);
    HTSABFree(&command);
    if ( linebuf )
    {
      free(linebuf);
      linebuf = 0;
    }
    if ( status > 0 )
      goto LABEL_262;
    if ( !status )
      break;
    if ( *__errno_location() != 107 && *__errno_location() != 104 && *__errno_location() != 32
      || already_retrying
      || do_post )
    {
      if ( WWW_TraceFlag[0] )
      {
        v34 = TraceFP();
        fprintf(v34, "HTTP: Hit unexpected network WRITE error; aborting connection.\n");
      }
      close(s);
      status = -1;
      v35 = gettext("Unexpected network write error; connection aborted.");
      HTAlert(v35);
      goto done;
    }
    if ( WWW_TraceFlag[0] )
    {
      v32 = TraceFP();
      fprintf(v32, "HTTP: BONZO ON WRITE Trying again with HTTP0 request.\n");
    }
    mustshow[0] = 1;
    v33 = gettext("Retrying as HTTP0 request.");
    HTProgress(v33);
    close(s);
    extensions = 0;
    already_retrying = 1;
  }
  if ( WWW_TraceFlag[0] )
  {
    v31 = TraceFP();
    fprintf(v31, "HTTP: Got status 0 in initial write\n");
  }
LABEL_262:
  if ( WWW_TraceFlag[0] )
  {
    v36 = TraceFP();
    fprintf(v36, "HTTP: WRITE delivered OK\n");
  }
  mustshow[0] = 1;
  v37 = gettext("HTTP request sent; waiting for response.");
  HTProgress(v37);
  end_of_file = 0;
  buffer_length = 1536;
  line_buffer = (char *)calloc(0x600u, 1u);
  if ( !line_buffer )
    outofmem("../../../WWW/Library/Implementation/HTTP.c", "HTLoadHTTP");
  bytes_already_read = 0;
  HTReadProgress(0LL, 0LL);
  while ( 1 )
  {
    if ( buffer_length - length <= 255 )
    {
      buffer_length *= 2;
      line_buffer = (char *)realloc(line_buffer, buffer_length);
      if ( !line_buffer )
        outofmem("../../../WWW/Library/Implementation/HTTP.c", "HTLoadHTTP");
    }
    if ( WWW_TraceFlag[0] )
    {
      v38 = buffer_length - length - 1;
      v39 = TraceFP();
      fprintf(v39, "HTTP: Trying to read %d\n", v38);
    }
    status = HTDoRead(s, &line_buffer[length], buffer_length - length - 1);
    if ( WWW_TraceFlag[0] )
    {
      v40 = TraceFP();
      fprintf(v40, "HTTP: Read %d\n", status);
    }
    if ( status <= 0 )
    {
      if ( status == -29998 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v41 = TraceFP();
          fprintf(v41, "HTTP: Interrupted initial read.\n");
        }
        mustshow[0] = 1;
        v42 = gettext("Connection interrupted.");
        HTProgress(v42);
        close(s);
        status = -204;
        goto clean_up;
      }
      if ( status >= 0
        || *__errno_location() != 107 && *__errno_location() != 104 && *__errno_location() != 32
        || already_retrying
        || do_post )
      {
        if ( WWW_TraceFlag[0] )
        {
          v45 = TraceFP();
          fprintf(v45, "HTTP: Hit unexpected network read error; aborting connection; status %d.\n", status);
        }
        v46 = gettext("Unexpected network read error; connection aborted.");
        HTAlert(v46);
        close(s);
        status = -1;
        goto clean_up;
      }
      if ( WWW_TraceFlag[0] )
      {
        v43 = TraceFP();
        fprintf(v43, "HTTP: BONZO Trying again with HTTP0 request.\n");
      }
      close(s);
      if ( line_buffer )
      {
        free(line_buffer);
        line_buffer = 0;
      }
      if ( line_kept_clean )
      {
        free(line_kept_clean);
        line_kept_clean = 0;
      }
      goto LABEL_291;
    }
    bytes_already_read += status;
    HTReadProgress(bytes_already_read, 0LL);
    if ( !status )
      break;
    line_buffer[status + length] = 0;
    if ( line_buffer )
    {
      if ( line_kept_clean )
      {
        free(line_kept_clean);
        line_kept_clean = 0;
      }
      line_kept_clean = (char *)malloc(buffer_length);
      if ( !line_kept_clean )
        outofmem("../../../WWW/Library/Implementation/HTTP.c", "HTLoadHTTP");
      memcpy(line_kept_clean, line_buffer, buffer_length);
      real_length_of_line = status + length;
    }
    eol = strchr(&line_buffer[length], 10);
    if ( eol && eol != line_buffer && *(eol - 1) == 13 )
      *(eol - 1) = 32;
    length += status;
    if ( eol )
      *eol = 0;
    if ( eol || end_of_file || bytes_already_read > 99 )
      goto LABEL_312;
  }
  end_of_file = 1;
LABEL_312:
  rawlength = length;
  if ( WWW_TraceFlag[0] )
  {
    v47 = TraceFP();
    fprintf(v47, "HTTP: Rx: %s\n", line_buffer);
  }
  if ( extensions
    && (!strncmp(line_buffer, "<TITLE>Bad File Request</TITLE>", 0x1Fu)
     || !strncmp(line_buffer, "Address should begin with", 0x19u)
     || !strncmp(line_buffer, "<TITLE>Help ", 0xCu)
     || !strcmp(line_buffer, "Document address invalid or access not authorised")) )
  {
    if ( line_buffer )
    {
      free(line_buffer);
      line_buffer = 0;
    }
    if ( line_kept_clean )
    {
      free(line_kept_clean);
      line_kept_clean = 0;
    }
    extensions = 0;
    already_retrying = 1;
    if ( WWW_TraceFlag[0] )
    {
      v48 = s;
      v49 = TraceFP();
      fprintf(v49, "HTTP: close socket %d to retry with HTTP0\n", v48);
    }
    close(s);
    mustshow[0] = 1;
    v50 = gettext("Retrying as HTTP0 request.");
    HTProgress(v50);
    goto try_again;
  }
  server_version[0] = 0;
  fields = sscanf(line_buffer, "%20s %d", server_version, &server_status);
  if ( WWW_TraceFlag[0] )
  {
    v51 = TraceFP();
    fprintf(v51, "HTTP: Scanned %d fields from line_buffer\n", fields);
  }
  if ( http_error_file )
  {
    error_file = (FILE *)fopen64(http_error_file, "a+");
    if ( error_file )
    {
      fprintf(error_file, "   URL=%s (%s)\n", url, METHOD);
      fprintf(error_file, "STATUS=%s\n", line_buffer);
      fclose(error_file);
    }
  }
  if ( fields <= 1
    || !server_version[0]
    || server_version[0] != 72
    || server_version[1] != 84
    || server_version[2] != 84
    || server_version[3] != 80
    || server_version[4] != 47
    || server_version[6] != 46 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v52 = TraceFP();
      fprintf(v52, "--- Talking HTTP0.\n");
    }
    format_in = HTFileFormat(url, (HTAtom **)&buffer, 0);
    if ( !strncmp(format_in->name, "text/plain", 0xAu) )
    {
      if ( WWW_TraceFlag[0] )
      {
        v53 = TraceFP();
        fprintf(v53, "HTTP: format_in being changed to text/HTML\n");
      }
      format_in = HTAtom_for("text/html");
    }
    if ( buffer )
    {
      v54 = (char *)HTAtom_for("identity");
      if ( v54 != buffer )
      {
        v55 = (char *)HTAtom_for("8bit");
        if ( v55 != buffer )
        {
          v56 = (char *)HTAtom_for("binary");
          if ( v56 != buffer )
          {
            v57 = (char *)HTAtom_for("7bit");
            if ( v57 != buffer )
            {
              if ( WWW_TraceFlag[0] )
              {
                name = format_in->name;
                v59 = TraceFP();
                fprintf(v59, "HTTP: format_in is '%s',\n", name);
              }
              HTSACopy(&anAnchor->content_type, format_in->name);
              HTSACopy(&anAnchor->content_encoding, *((const char **)buffer + 1));
              format_in = HTAtom_for("www/compressed");
              if ( WWW_TraceFlag[0] )
              {
                v60 = (const char *)*((_DWORD *)buffer + 1);
                v61 = TraceFP();
                fprintf(v61, "        Treating as '%s' with encoding '%s'\n", "www/compressed", v60);
              }
            }
          }
        }
      }
    }
    start_of_data = line_kept_clean;
    goto LABEL_469;
  }
  format_in = HTAtom_for("www/mime");
  if ( WWW_TraceFlag[0] )
  {
    v62 = TraceFP();
    fprintf(v62, "--- Talking HTTP1.\n");
  }
  if ( eol )
    v111 = eol + 1;
  else
    v111 = empty_11000;
  start_of_data = v111;
  if ( eol )
    v112 = line_buffer - start_of_data + length;
  else
    v112 = 0;
  length = v112;
  while ( 1 )
  {
    v64 = strlen(line_buffer);
    if ( line_buffer[v64 - 1] != 32 )
      break;
    v63 = strlen(line_buffer);
    line_buffer[v63 - 1] = 0;
  }
  switch ( server_status / 100 )
  {
    case 1:
      v65 = gettext("Got unexpected Informational Status.");
      HTAlert(v65);
      do_head = 1;
      goto LABEL_469;
    case 2:
      if ( do_head )
        goto LABEL_369;
      switch ( server_status )
      {
        case 205:
          v66 = gettext("Request fulfilled.  Reset Content.");
          HTAlert(v66);
          close(s);
          status = -204;
          goto clean_up;
        case 206:
          HTAlert(line_buffer);
          close(s);
          status = -204;
          goto clean_up;
        case 204:
          HTAlert(line_buffer);
          close(s);
          HTNoDataOK = 1;
          status = -204;
          goto clean_up;
      }
LABEL_369:
      HTProgress(line_buffer);
      goto LABEL_469;
    case 3:
      if ( no_url_redirection || do_head || keep_mime_headers )
        goto LABEL_369;
      if ( server_status == 300 )
      {
        HTAlert(line_buffer);
        if ( traversal )
          goto LABEL_465;
        if ( !dump_output_immediately && HTAtom_for("www/download") == format_out )
          goto LABEL_468;
      }
      else
      {
        if ( server_status == 304 )
        {
          v67 = gettext("Got unexpected 304 Not Modified status.");
          HTAlert(v67);
          do_head = 1;
          goto LABEL_469;
        }
        if ( server_status == 305 || server_status == 306 || server_status > 307 )
        {
          HTAlert(line_buffer);
          if ( traversal )
            goto LABEL_465;
          if ( !dump_output_immediately && HTAtom_for("www/download") == format_out )
            goto LABEL_468;
        }
        else
        {
          if ( (dump_output_immediately || traversal)
            && do_post
            && server_status != 303
            && server_status != 302
            && server_status != 301 )
          {
            close(s);
            status = -1;
            v68 = gettext("Redirection of POST content requires user approval.");
            HTAlert(v68);
            if ( traversal )
              HTProgress(line_buffer);
            goto clean_up;
          }
          HTProgress(line_buffer);
          if ( server_status == 301 )
          {
            if ( do_post )
            {
              if ( WWW_TraceFlag[0] )
              {
                v69 = TraceFP();
                fprintf(v69, "HTTP: Have POST content.  Treating 301 (Permanent) as Temporary.\n");
              }
              v70 = gettext("Have POST content.  Treating Permanent Redirection as Temporary.\n");
              HTAlert(v70);
            }
            else
            {
              permanent_redirection = 1;
            }
          }
          doing_redirect = 1;
        }
      }
      goto LABEL_469;
    case 4:
      if ( server_status != 407 )
      {
        if ( server_status == 408 )
        {
          HTAlert(line_buffer);
          close(s);
          status = -204;
          goto done;
        }
        if ( server_status != 401 )
        {
          HTAlert(line_buffer);
          if ( traversal )
            goto LABEL_465;
          if ( !dump_output_immediately && HTAtom_for("www/download") == format_out )
            goto LABEL_468;
LABEL_469:
          if ( HTCheckForInterrupt() )
          {
            close(s);
            if ( doing_redirect )
            {
              if ( WWW_TraceFlag[0] )
              {
                v82 = TraceFP();
                fprintf(v82, "HTTP: Interrupted followup read.\n");
              }
              mustshow[0] = 1;
              v83 = gettext("Connection interrupted.");
              HTProgress(v83);
            }
            status = -29998;
            goto clean_up;
          }
          if ( do_head || keep_mime_headers )
          {
            start_of_data = line_kept_clean;
            length = rawlength;
            format_in = HTAtom_for("text/plain");
          }
          else if ( doing_redirect )
          {
            format_in = HTAtom_for("message/x-http-redirection");
            HTSACopy(&anAnchor->content_type, format_in->name);
            if ( traversal )
            {
              format_out = HTAtom_for("www/debug");
              if ( !sink )
              {
                sink = (HTStream *)HTErrorStream();
                v84 = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
LABEL_486:
                target = v84;
                if ( !v84 )
                {
                  buffer = 0;
                  close(s);
                  v85 = format_out->name;
                  v86 = format_in->name;
                  v87 = gettext("Sorry, no known way of converting %s to %s.");
                  HTSprintf0(&buffer, v87, v86, v85);
                  mustshow[0] = 1;
                  HTProgress(buffer);
                  if ( buffer )
                  {
                    free(buffer);
                    buffer = 0;
                  }
                  status = -1;
                  goto clean_up;
                }
                target->isa->put_block(target, start_of_data, length);
                rv = HTCopy(anAnchor, s, handle, (HTStream_5 *)target);
                if ( rv == -1 )
                {
                  if ( doing_redirect && traversal )
                    status = -1;
                  else
                    status = -29998;
                  close(s);
                  goto clean_up;
                }
                if ( rv != -2 || (target->isa->_abort(target, 0), doing_redirect) && redirecting_url )
                {
                  if ( rv == -29998 || rv == -2 )
                    close(s);
                  else
                    target->isa->_free(target);
                  if ( doing_redirect )
                  {
                    if ( redirecting_url )
                    {
                      if ( WWW_TraceFlag[0] )
                      {
                        v89 = redirecting_url;
                        v90 = TraceFP();
                        fprintf(v90, "HTTP: Picked up location '%s'\n", v89);
                      }
                      if ( rv == -29998 )
                      {
                        if ( redirecting_url )
                        {
                          free(redirecting_url);
                          redirecting_url = 0;
                        }
                        if ( WWW_TraceFlag[0] )
                        {
                          v91 = TraceFP();
                          fprintf(v91, "HTTP: Interrupted followup read.\n");
                        }
                        status = -29998;
                      }
                      else
                      {
                        HTProgress(line_buffer);
                        if ( server_status == 305 )
                        {
                          v92 = redirecting_url;
                          if ( v92[strlen(redirecting_url) - 1] != 47 )
                            HTSACat(&redirecting_url, "/");
                          HTSACat(&redirecting_url, anAnchor->address);
                          if ( WWW_TraceFlag[0] )
                          {
                            v93 = redirecting_url;
                            v94 = TraceFP();
                            fprintf(v94, "HTTP: Proxy URL is '%s'\n", v93);
                          }
                        }
                        if ( !do_post || server_status == 303 || server_status == 302 )
                        {
                          status = 399;
                        }
                        else
                        {
                          v113 = HTConfirmPostRedirect(redirecting_url, server_status);
                          if ( v113 )
                          {
                            if ( v113 != 303 )
                              redirect_post_content[0] = 1;
                            status = 399;
                          }
                          else
                          {
                            doing_redirect = 0;
                            if ( redirecting_url )
                            {
                              free(redirecting_url);
                              redirecting_url = 0;
                            }
                            status = -204;
                          }
                        }
                      }
                    }
                    else
                    {
                      if ( traversal )
                        v114 = -1;
                      else
                        v114 = 200;
                      status = v114;
                    }
                  }
                  else
                  {
                    status = 200;
                  }
                  goto clean_up;
                }
                close(s);
                if ( doing_redirect || already_retrying || do_post )
                {
                  status = -29999;
                  goto clean_up;
                }
                if ( WWW_TraceFlag[0] )
                {
                  v88 = TraceFP();
                  fprintf(v88, "HTTP: Trying again with HTTP0 request.\n");
                }
                if ( line_buffer )
                {
                  free(line_buffer);
                  line_buffer = 0;
                }
                if ( line_kept_clean )
                {
                  free(line_kept_clean);
                  line_kept_clean = 0;
                }
LABEL_291:
                extensions = 0;
                already_retrying = 1;
                mustshow[0] = 1;
                v44 = gettext("Retrying as HTTP0 request.");
                HTProgress(v44);
                goto try_again;
              }
            }
            else if ( !dump_output_immediately && HTAtom_for("www/download") == format_out )
            {
              format_out = HTAtom_for("www/present");
            }
          }
          v84 = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
          goto LABEL_486;
        }
        if ( show_401 )
          goto LABEL_469;
        if ( !HTAA_shouldRetryWithAuth(start_of_data, length, s, 0) )
        {
          if ( !traversal && !dump_output_immediately )
          {
            v74 = gettext("Show the 401 message body?");
            if ( HTConfirm(v74) )
              goto LABEL_469;
          }
          if ( traversal || dump_output_immediately )
          {
            v75 = gettext("Can't retry with authorization!  Contact the server's WebMaster.");
            HTAlert(v75);
          }
          goto LABEL_465;
        }
        close(s);
        if ( dump_output_immediately && !authentication_info[0] )
        {
          fwrite("HTTP: Access authorization required.\n", 1u, 0x25u, stderr);
          fwrite("       Use the -auth=id:pw parameter.\n", 1u, 0x26u, stderr);
          status = -204;
          goto clean_up;
        }
        if ( WWW_TraceFlag[0] )
        {
          v71 = s;
          v72 = TraceFP();
          fprintf(v72, "%s %d %s\n", "HTTP: close socket", v71, "to retry with Access Authorization");
        }
        mustshow[0] = 1;
        v73 = gettext("Retrying with access authorization information.");
        HTProgress(v73);
        if ( line_buffer )
        {
          free(line_buffer);
          line_buffer = 0;
        }
        if ( line_kept_clean )
          goto LABEL_424;
        goto try_again;
      }
      if ( !using_proxy[0] || show_407 )
        goto LABEL_469;
      if ( HTAA_shouldRetryWithAuth(start_of_data, length, s, 1) )
      {
        close(s);
        if ( dump_output_immediately && !proxyauth_info[0] )
        {
          fwrite("HTTP: Proxy authorization required.\n", 1u, 0x24u, stderr);
          fwrite("       Use the -pauth=id:pw parameter.\n", 1u, 0x27u, stderr);
          status = -204;
          goto clean_up;
        }
        if ( WWW_TraceFlag[0] )
        {
          v76 = s;
          v77 = TraceFP();
          fprintf(v77, "%s %d %s\n", "HTTP: close socket", v76, "to retry with Proxy Authorization");
        }
        mustshow[0] = 1;
        v78 = gettext("Retrying with proxy authorization information.");
        HTProgress(v78);
        if ( line_buffer )
        {
          free(line_buffer);
          line_buffer = 0;
        }
        if ( line_kept_clean )
        {
LABEL_424:
          free(line_kept_clean);
          line_kept_clean = 0;
          goto try_again;
        }
        goto try_again;
      }
      if ( !traversal && !dump_output_immediately )
      {
        v79 = gettext("Show the 407 message body?");
        if ( HTConfirm(v79) )
        {
          if ( dump_output_immediately || HTAtom_for("www/download") != format_out )
            goto LABEL_469;
LABEL_468:
          format_out = HTAtom_for("www/present");
          goto LABEL_469;
        }
      }
      if ( traversal || dump_output_immediately )
      {
        v80 = gettext("Can't retry with proxy authorization!  Contact the server's WebMaster.");
        HTAlert(v80);
      }
LABEL_465:
      close(s);
      status = -1;
clean_up:
      if ( line_buffer )
      {
        free(line_buffer);
        line_buffer = 0;
      }
      if ( line_kept_clean )
      {
        free(line_kept_clean);
        line_kept_clean = 0;
      }
done:
      reloading[0] = 0;
      dump_server_status = server_status;
      return status;
    case 5:
      HTAlert(line_buffer);
      if ( traversal )
        goto LABEL_465;
      if ( !dump_output_immediately && HTAtom_for("www/download") == format_out )
        goto LABEL_468;
      goto LABEL_469;
    default:
      v81 = gettext("Unknown status reply from server!");
      HTAlert(v81);
      HTAlert(line_buffer);
      if ( traversal )
        goto LABEL_465;
      if ( !dump_output_immediately && HTAtom_for("www/download") == format_out )
        goto LABEL_468;
      goto LABEL_469;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08106578) --------------------------------------------------------
char *__cdecl FormatStr(char **bufp, char *start, const char *entry)
{
  char fmt[512]; // [esp+34h] [ebp-204h] BYREF
  unsigned int v5; // [esp+234h] [ebp-4h]

  v5 = __readgsdword(0x14u);
  if ( *start )
  {
    sprintf(fmt, "%%%.*ss", 509, start);
    HTSprintf0(bufp, fmt, entry);
  }
  else if ( !*bufp || entry && *entry )
  {
    if ( entry )
      HTSACopy(bufp, entry);
  }
  else
  {
    **bufp = 0;
  }
  return *bufp;
}

//----- (0810666B) --------------------------------------------------------
char *__cdecl FormatNum(char **bufp, char *start, int entry)
{
  char fmt[512]; // [esp+24h] [ebp-204h] BYREF
  unsigned int v5; // [esp+224h] [ebp-4h]

  v5 = __readgsdword(0x14u);
  if ( *start )
  {
    sprintf(fmt, "%%%.*sd", 509, start);
    HTSprintf0(bufp, fmt, entry);
  }
  else
  {
    sprintf(fmt, "%d", entry);
    HTSACopy(bufp, fmt);
  }
  return *bufp;
}

//----- (08106737) --------------------------------------------------------
void __cdecl LYListFmtParse(const char *fmtstr, DIRED *data, char *file, HTStructured_1 *target, char *tail)
{
  char *v5; // ebx
  char *v6; // eax
  __mode_t v7; // [esp+28h] [ebp-170h]
  const char *v8; // [esp+2Ch] [ebp-16Ch]
  const char *v9; // [esp+30h] [ebp-168h]
  const char *v10; // [esp+34h] [ebp-164h]
  HTFormat format; // [esp+58h] [ebp-140h]
  const char *cp2; // [esp+5Ch] [ebp-13Ch] BYREF
  int len; // [esp+60h] [ebp-138h]
  char *datestr; // [esp+64h] [ebp-134h]
  time_t now; // [esp+68h] [ebp-130h]
  const char *name; // [esp+6Ch] [ebp-12Ch]
  char *buf; // [esp+70h] [ebp-128h] BYREF
  char *str; // [esp+74h] [ebp-124h] BYREF
  char *start; // [esp+78h] [ebp-120h]
  char *end; // [esp+7Ch] [ebp-11Ch]
  char *s; // [esp+80h] [ebp-118h]
  char type; // [esp+86h] [ebp-112h]
  char c; // [esp+87h] [ebp-111h]
  char tmp[256]; // [esp+88h] [ebp-110h] BYREF
  unsigned int v26; // [esp+188h] [ebp-10h]

  v26 = __readgsdword(0x14u);
  str = 0;
  buf = 0;
  if ( !data->file_info.st_mode )
    fmtstr = "    %a";
  HTSACopy(&str, fmtstr);
  s = str;
  v5 = str;
  end = &v5[strlen(str)];
LABEL_87:
  while ( *s )
  {
    start = s;
    while ( *s )
    {
      if ( *s == 37 )
      {
        if ( s[1] != 37 )
          break;
        ++s;
      }
      ++s;
    }
    *s = 0;
    if ( s > start )
      target->isa->put_string((HTStructured *)target, start);
    if ( s == end )
      break;
    start = ++s;
    while ( ((*__ctype_b_loc())[(unsigned __int8)*s] & 0x800) != 0
         || *s == 46
         || *s == 45
         || *s == 32
         || *s == 35
         || *s == 43
         || *s == 39 )
      ++s;
    c = *s;
    *s = 0;
    switch ( c )
    {
      case 0:
        target->isa->put_string((HTStructured *)target, start);
        goto LABEL_87;
      case 37:
        FormatStr(&buf, start, "%");
        goto LABEL_84;
      case 65:
      case 97:
        HTDirEntry(target, tail, data->file_name);
        FormatStr(&buf, start, data->file_name);
        target->isa->put_string((HTStructured *)target, buf);
        target->isa->end_element((HTStructured *)target, 0, 0);
        *buf = 0;
        if ( c != 65 && (data->file_info.st_mode & 0xF000) == 40960 )
        {
          len = readlink(file, tmp, 0xFFu);
          if ( len >= 0 )
          {
            target->isa->put_string((HTStructured *)target, " -> ");
            tmp[len] = 0;
            target->isa->put_string((HTStructured *)target, tmp);
          }
        }
        goto LABEL_84;
      case 75:
        if ( (data->file_info.st_mode & 0xF000) != 0x4000 )
          goto LABEL_47;
        FormatStr(&buf, start, &entry);
        HTSACat(&buf, " ");
        goto LABEL_84;
      case 84:
      case 116:
        if ( (data->file_info.st_mode & 0xF000) == 0x4000 )
        {
          if ( c == 84 )
          {
            FormatStr(&buf, start, &entry);
          }
          else
          {
            v6 = gettext("Directory");
            FormatStr(&buf, start, v6);
          }
        }
        else
        {
          format = HTFileFormat(file, 0, &cp2);
          if ( c == 84 )
          {
            FormatStr(&buf, start, format->name);
          }
          else
          {
            if ( !cp2 )
            {
              if ( !strncmp(format->name, "application", 0xBu) )
              {
                cp2 = format->name + 12;
                if ( !strncmp(cp2, "x-", 2u) )
                  cp2 += 2;
              }
              else
              {
                cp2 = format->name;
              }
            }
            FormatStr(&buf, start, cp2);
          }
        }
        goto LABEL_84;
      case 100:
        now = time(0);
        datestr = ctime(&data->file_info.st_mtim.tv_sec);
        if ( now - data->file_info.st_mtim.tv_sec > 15767999 )
          sprintf(tmp, "%.7s %.4s ", datestr + 4, datestr + 20);
        else
          sprintf(tmp, "%.12s", datestr + 4);
        FormatStr(&buf, start, tmp);
        goto LABEL_84;
      case 103:
        name = HTAA_GidToName(data->file_info.st_gid);
        if ( *name )
          goto LABEL_77;
        FormatNum(&buf, start, data->file_info.st_gid);
        goto LABEL_84;
      case 107:
LABEL_47:
        FormatNum(&buf, start, (data->file_info.st_size + 1023) / 1024);
        HTSACat(&buf, "K");
        goto LABEL_84;
      case 108:
        FormatNum(&buf, start, data->file_info.st_nlink);
        goto LABEL_84;
      case 111:
        name = HTAA_UidToName(data->file_info.st_uid);
        if ( *name )
LABEL_77:
          FormatStr(&buf, start, name);
        else
          FormatNum(&buf, start, data->file_info.st_uid);
        goto LABEL_84;
      case 112:
        v7 = data->file_info.st_mode & 0xF000;
        if ( v7 == 24576 )
        {
          type = 98;
          goto LABEL_66;
        }
        if ( v7 > 0x6000 )
        {
          switch ( v7 )
          {
            case 0xA000u:
              type = 108;
              goto LABEL_66;
            case 0xC000u:
              type = 115;
              goto LABEL_66;
            case 0x8000u:
              type = 45;
              goto LABEL_66;
          }
        }
        else
        {
          switch ( v7 )
          {
            case 0x2000u:
              type = 99;
              goto LABEL_66;
            case 0x4000u:
              type = 100;
              goto LABEL_66;
            case 0x1000u:
              type = 112;
              goto LABEL_66;
          }
        }
        type = 63;
LABEL_66:
        if ( (data->file_info.st_mode & 0x200) != 0 )
          v8 = ptbits_11098[data->file_info.st_mode & 7];
        else
          v8 = pbits_11096[data->file_info.st_mode & 7];
        if ( (data->file_info.st_mode & 0x400) != 0 )
          v9 = psbits_11097[(data->file_info.st_mode >> 3) & 7];
        else
          v9 = pbits_11096[(data->file_info.st_mode >> 3) & 7];
        if ( (data->file_info.st_mode & 0x800) != 0 )
          v10 = psbits_11097[(data->file_info.st_mode >> 6) & 7];
        else
          v10 = pbits_11096[(data->file_info.st_mode >> 6) & 7];
        sprintf(tmp, "%c%s%s%s", type, v10, v9, v8);
        FormatStr(&buf, start, tmp);
LABEL_84:
        if ( buf )
          target->isa->put_string((HTStructured *)target, buf);
        ++s;
        break;
      case 115:
        FormatNum(&buf, start, data->file_info.st_size);
        goto LABEL_84;
      default:
        fprintf(stderr, "Unknown format character `%c' in list format\n", c);
        goto LABEL_84;
    }
  }
  if ( buf )
  {
    free(buf);
    buf = 0;
  }
  target->isa->put_character((HTStructured *)target, 10);
  if ( str )
    free(str);
}

//----- (081071F5) --------------------------------------------------------
void __cdecl HTSetSuffix5(
        const char *suffix,
        const char *representation,
        const char *encoding,
        const char *desc,
        double value)
{
  HTAtom *v5; // ebx
  HTAtom *v6; // ebx
  HTAtom *v7; // ebx
  HTAtom *v8; // ebx
  HTAtom *v9; // ebx
  HTAtom *v10; // ebx
  HTAtom *v11; // ebx
  HTAtom *v12; // ebx
  bool v13; // [esp+Ch] [ebp-2Ch]
  HTSuffix *object; // [esp+10h] [ebp-28h]
  float v15; // [esp+14h] [ebp-24h]
  HTList *cur; // [esp+24h] [ebp-14h]
  HTSuffix *suff; // [esp+28h] [ebp-10h]

  v13 = !encoding
     || !*encoding
     || !strcmp(encoding, "identity")
     || !strcmp(encoding, "8bit")
     || !strcmp(encoding, "binary")
     || !strcmp(encoding, "7bit");
  if ( !strcmp(suffix, "*") )
  {
    suff = &no_suffix;
  }
  else if ( !strcmp(suffix, "*.*") )
  {
    suff = &unknown_suffix;
  }
  else
  {
    cur = HTSuffixes;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (HTSuffix *)cur->object;
      else
        object = 0;
      suff = object;
      if ( !object )
        break;
      if ( object->suffix && !strcmp(object->suffix, suffix) )
      {
        if ( v13 )
        {
          if ( !object->encoding )
            break;
          v5 = object->encoding;
          if ( v5 == HTAtom_for("identity") )
            break;
          v6 = object->encoding;
          if ( v6 == HTAtom_for("8bit") )
            break;
          v7 = object->encoding;
          if ( v7 == HTAtom_for("binary") )
            break;
          v8 = object->encoding;
          if ( v8 == HTAtom_for("7bit") )
            break;
        }
        if ( !v13 )
        {
          if ( object->encoding )
          {
            v9 = object->encoding;
            if ( v9 != HTAtom_for("identity") )
            {
              v10 = object->encoding;
              if ( v10 != HTAtom_for("8bit") )
              {
                v11 = object->encoding;
                if ( v11 != HTAtom_for("binary") )
                {
                  v12 = object->encoding;
                  if ( v12 != HTAtom_for("7bit") && !strcmp(encoding, object->encoding->name) )
                    break;
                }
              }
            }
          }
        }
      }
    }
    if ( !object )
    {
      suff = (HTSuffix *)calloc(1u, 0x14u);
      if ( !suff )
        outofmem("../../../WWW/Library/Implementation/HTFile.c", "HTSetSuffix");
      if ( !HTSuffixes )
        HTSuffixes = HTList_new();
      HTList_addObject(HTSuffixes, suff);
      HTSACopy(&suff->suffix, suffix);
    }
  }
  if ( representation )
    suff->rep = HTAtom_for(representation);
  suff->encoding = HTAtom_for(encoding);
  HTSACopy(&suff->desc, desc);
  v15 = value;
  suff->quality = v15;
}

//----- (08107504) --------------------------------------------------------
char *__cdecl HTCacheFileName(const char *name)
{
  char *result; // [esp+18h] [ebp-10h] BYREF
  char *path; // [esp+1Ch] [ebp-Ch]
  char *host; // [esp+20h] [ebp-8h]
  char *acc_method; // [esp+24h] [ebp-4h]

  acc_method = HTParse(name, &entry, 16);
  host = HTParse(name, &entry, 8);
  path = HTParse(name, &entry, 5);
  result = 0;
  HTSprintf0(&result, "%s/WWW/%s/%s%s", HTCacheRoot, acc_method, host, path);
  if ( path )
  {
    free(path);
    path = 0;
  }
  if ( acc_method )
  {
    free(acc_method);
    acc_method = 0;
  }
  if ( host )
  {
    free(host);
    host = 0;
  }
  return result;
}

//----- (081075EA) --------------------------------------------------------
char *__cdecl HTURLPath_toFile(const char *name, BOOLEAN expand_all, BOOLEAN is_remote)
{
  char *v3; // ebx
  FILE *v4; // edx
  char *result; // [esp+2Ch] [ebp-Ch] BYREF
  char *path; // [esp+30h] [ebp-8h] BYREF

  path = 0;
  result = 0;
  HTSACopy(&path, name);
  if ( expand_all )
    HTUnEscape(path);
  else
    HTUnEscapeSome(path, "/");
  if ( WWW_TraceFlag[0] )
  {
    v3 = path;
    v4 = TraceFP();
    fprintf(v4, "URLPath `%s' means path `%s'\n", name, v3);
  }
  HTSACopy(&result, path);
  if ( path )
  {
    free(path);
    path = 0;
  }
  return result;
}

//----- (081076A9) --------------------------------------------------------
char *__cdecl HTnameOfFile_WWW(const char *name, BOOLEAN WWW_prefix, BOOLEAN expand_all)
{
  char *v3; // eax
  FILE *v4; // edx
  char *v5; // ebx
  FILE *v6; // edx
  char *v7; // ebx
  FILE *v8; // edx
  char *result; // [esp+38h] [ebp-20h] BYREF
  const char *home; // [esp+3Ch] [ebp-1Ch]
  char *path; // [esp+40h] [ebp-18h]
  char *host; // [esp+44h] [ebp-14h]
  char *acc_method; // [esp+48h] [ebp-10h]

  acc_method = HTParse(name, &entry, 16);
  host = HTParse(name, &entry, 8);
  path = HTParse(name, &entry, 5);
  result = 0;
  if ( expand_all )
    HTUnEscape(path);
  else
    HTUnEscapeSome(path, "/");
  if ( !strcmp(acc_method, "file") || !*acc_method )
  {
    v3 = HTHostName();
    if ( !strcasecomp(host, v3) || !strcasecomp(host, "localhost") || !*host )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "Node `%s' means path `%s'\n", name, path);
      }
      goto LABEL_20;
    }
    if ( WWW_prefix )
    {
      HTSprintf0(&result, "%s%s%s", "/Net/", host, path);
      if ( WWW_TraceFlag[0] )
      {
        v5 = result;
        v6 = TraceFP();
        fprintf(v6, "Node `%s' means file `%s'\n", name, v5);
      }
      goto LABEL_21;
    }
LABEL_20:
    HTSACopy(&result, path);
    goto LABEL_21;
  }
  if ( !WWW_prefix )
    goto LABEL_20;
  home = LYGetEnv("HOME");
  if ( !home )
    home = "/tmp";
  HTSprintf0(&result, "%s/WWW/%s/%s%s", home, acc_method, host, path);
LABEL_21:
  if ( host )
  {
    free(host);
    host = 0;
  }
  if ( path )
  {
    free(path);
    path = 0;
  }
  if ( acc_method )
  {
    free(acc_method);
    acc_method = 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    v7 = result;
    v8 = TraceFP();
    fprintf(v8, "HTnameOfFile_WWW(%s,%d,%d) = %s\n", name, WWW_prefix, expand_all, v7);
  }
  return result;
}

//----- (08107961) --------------------------------------------------------
char *__cdecl WWW_nameOfFile(const char *name)
{
  char *v1; // eax
  const char *v2; // ebx
  FILE *v3; // edx
  char *result[2]; // [esp+20h] [ebp-8h] BYREF

  result[0] = 0;
  if ( !strncmp(HTMountRoot, name, 5u) )
  {
    HTSprintf0(result, "%s//%s", "file:", name + 5);
  }
  else
  {
    v1 = HTHostName();
    HTSprintf0(result, "%s//%s%s", "file:", v1, name);
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = result[0];
    v3 = TraceFP();
    fprintf(v3, "File `%s'\n\tmeans node `%s'\n", name, v2);
  }
  return result[0];
}

//----- (08107A1C) --------------------------------------------------------
const char *__cdecl HTFileSuffix(HTAtom *rep, const char *enc)
{
  HTAtom *encoding; // ebx
  HTAtom *v3; // ebx
  HTAtom *v4; // ebx
  HTAtom *v5; // ebx
  HTAtom *v6; // ebx
  HTAtom *v7; // ebx
  HTAtom *v8; // ebx
  HTAtom *v9; // ebx
  bool v11; // [esp+Ch] [ebp-1Ch]
  int i; // [esp+14h] [ebp-14h]
  int n; // [esp+18h] [ebp-10h]
  HTSuffix *suff; // [esp+1Ch] [ebp-Ch]

  v11 = !enc
     || !*enc
     || !strcmp(enc, "identity")
     || !strcmp(enc, "8bit")
     || !strcmp(enc, "binary")
     || !strcmp(enc, "7bit");
  n = HTList_count(HTSuffixes);
  for ( i = 0; i < n; ++i )
  {
    suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
    if ( suff->rep == rep )
    {
      if ( v11 )
      {
        if ( !suff->encoding )
          return suff->suffix;
        encoding = suff->encoding;
        if ( encoding == HTAtom_for("identity") )
          return suff->suffix;
        v3 = suff->encoding;
        if ( v3 == HTAtom_for("8bit") )
          return suff->suffix;
        v4 = suff->encoding;
        if ( v4 == HTAtom_for("binary") )
          return suff->suffix;
        v5 = suff->encoding;
        if ( v5 == HTAtom_for("7bit") )
          return suff->suffix;
      }
      if ( !v11 )
      {
        if ( suff->encoding )
        {
          v6 = suff->encoding;
          if ( v6 != HTAtom_for("identity") )
          {
            v7 = suff->encoding;
            if ( v7 != HTAtom_for("8bit") )
            {
              v8 = suff->encoding;
              if ( v8 != HTAtom_for("binary") )
              {
                v9 = suff->encoding;
                if ( v9 != HTAtom_for("7bit") && !strcmp(enc, suff->encoding->name) )
                  return suff->suffix;
              }
            }
          }
        }
      }
    }
  }
  return &entry;
}

//----- (08107C17) --------------------------------------------------------
HTFormat __cdecl HTFileFormat(const char *filename, HTAtom **pencoding, const char **pdesc)
{
  HTAtom *v3; // ebx
  HTAtom *v4; // ebx
  HTAtom *v5; // ebx
  HTAtom *v6; // ebx
  HTAtom *v7; // ebx
  HTAtom *encoding; // ebx
  HTAtom *v9; // ebx
  HTAtom *v10; // ebx
  HTAtom *v11; // ebx
  HTSuffix *v14; // [esp+14h] [ebp-34h]
  HTSuffix *v15; // [esp+18h] [ebp-30h]
  HTAtom *v16; // [esp+1Ch] [ebp-2Ch]
  size_t ls2; // [esp+28h] [ebp-20h]
  int j; // [esp+2Ch] [ebp-1Ch]
  int ls; // [esp+30h] [ebp-18h]
  int lf; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int n; // [esp+3Ch] [ebp-Ch]
  HTSuffix *suff; // [esp+40h] [ebp-8h]
  HTSuffix *suffa; // [esp+40h] [ebp-8h]

  if ( pencoding )
    *pencoding = 0;
  if ( pdesc )
    *pdesc = 0;
  if ( LYforce_HTML_mode )
  {
    if ( pencoding )
      *pencoding = HTAtom_for("8bit");
    return HTAtom_for("text/html");
  }
  else
  {
    lf = strlen(filename);
    n = HTList_count(HTSuffixes);
    for ( i = 0; i < n; ++i )
    {
      suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
      ls = strlen(suff->suffix);
      if ( ls <= lf && !strcasecomp(suff->suffix, &filename[lf - ls]) )
      {
        if ( pencoding )
          *pencoding = suff->encoding;
        if ( pdesc )
          *pdesc = suff->desc;
        if ( suff->rep )
          return suff->rep;
        for ( j = 0; j < n; ++j )
        {
          suffa = (HTSuffix *)HTList_objectAt(HTSuffixes, j);
          ls2 = strlen(suffa->suffix);
          if ( (int)(ls2 + ls) <= lf && !strncasecomp(suffa->suffix, &filename[lf - ls - ls2], ls2) && suffa->rep )
          {
            if ( pdesc && !*pdesc )
              *pdesc = suffa->desc;
            if ( pencoding )
            {
              if ( !*pencoding
                || (v3 = *pencoding, v3 == HTAtom_for("identity"))
                || (v4 = *pencoding, v4 == HTAtom_for("8bit"))
                || (v5 = *pencoding, v5 == HTAtom_for("binary"))
                || (v6 = *pencoding, v6 == HTAtom_for("7bit")) )
              {
                v7 = *pencoding;
                if ( v7 != HTAtom_for("7bit") )
                {
                  if ( suffa->encoding )
                  {
                    encoding = suffa->encoding;
                    if ( encoding != HTAtom_for("identity") )
                    {
                      v9 = suffa->encoding;
                      if ( v9 != HTAtom_for("8bit") )
                      {
                        v10 = suffa->encoding;
                        if ( v10 != HTAtom_for("binary") )
                        {
                          v11 = suffa->encoding;
                          if ( v11 != HTAtom_for("7bit") )
                            *pencoding = suffa->encoding;
                        }
                      }
                    }
                  }
                }
              }
            }
            return suffa->rep;
          }
        }
      }
    }
    if ( strchr(filename, 46) )
    {
      if ( unknown_suffix.rep )
        v15 = &unknown_suffix;
      else
        v15 = &no_suffix;
      v14 = v15;
    }
    else
    {
      v14 = &no_suffix;
    }
    if ( pencoding && !*pencoding )
    {
      if ( v14->encoding )
        v16 = v14->encoding;
      else
        v16 = HTAtom_for("binary");
      *pencoding = v16;
    }
    if ( v14->rep )
      return v14->rep;
    else
      return HTAtom_for("application/octet-stream");
  }
}

//----- (08107FA7) --------------------------------------------------------
HTFormat __cdecl HTCharsetFormat(HTFormat format, HTParentAnchor *anchor, int default_LYhndl)
{
  char *name; // ebx
  FILE *v4; // eax
  int UCLYhndl; // [esp+4h] [ebp-54h]
  int v7; // [esp+4h] [ebp-54h]
  bool v8; // [esp+14h] [ebp-44h]
  bool v9; // [esp+18h] [ebp-40h]
  bool v10; // [esp+1Ch] [ebp-3Ch]
  const char *Msg; // [esp+20h] [ebp-38h]
  LYUCcharset *p_out; // [esp+30h] [ebp-28h]
  LYUCcharset *p_in; // [esp+34h] [ebp-24h]
  int chndl; // [esp+38h] [ebp-20h]
  char *cp4; // [esp+3Ch] [ebp-1Ch]
  char *cp4a; // [esp+3Ch] [ebp-1Ch]
  char *cp3; // [esp+40h] [ebp-18h] BYREF
  char *cp2; // [esp+44h] [ebp-14h]
  char *cp1; // [esp+48h] [ebp-10h]
  char *cp; // [esp+4Ch] [ebp-Ch] BYREF
  BOOLEAN given_and_display_8859like; // [esp+50h] [ebp-8h]
  BOOLEAN given_is_8859like; // [esp+51h] [ebp-7h]
  BOOLEAN given_is_8859; // [esp+52h] [ebp-6h]
  BOOLEAN chartrans_ok; // [esp+53h] [ebp-5h]

  cp = 0;
  cp3 = 0;
  chartrans_ok = 0;
  if ( anchor->charset )
  {
    free(anchor->charset);
    anchor->charset = 0;
  }
  HTSACopy(&cp, format->name);
  LYLowerCase(cp);
  cp1 = strchr(cp, 59);
  if ( cp1 && (cp2 = strstr(cp1, "charset")) != 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      name = format->name;
      v4 = TraceFP();
      fprintf(v4, "HTCharsetFormat: Extended MIME Content-Type is %s\n", name);
    }
    for ( cp2 += 7; *cp2 == 32 || *cp2 == 61; ++cp2 )
      ;
    HTSACopy(&cp3, cp2);
    for ( cp4 = cp3; *cp4 && *cp4 != 34 && *cp4 != 59 && *cp4 != 58 && (unsigned __int8)*cp4 > 0x20u; ++cp4 )
      ;
    *cp4 = 0;
    cp4a = cp3;
    chndl = UCGetLYhndl_byMIME(cp3);
    if ( UCCanTranslateFromTo(chndl, current_char_set) )
    {
      chartrans_ok = 1;
      *cp1 = 0;
      format = HTAtom_for(cp);
      HTSACopy(&anchor->charset, cp4a);
      HTAnchor_setUCInfoStage(anchor, chndl, 0, 5);
    }
    else if ( chndl < 0 )
    {
      chndl = UCLYhndl_for_unrec;
      if ( UCLYhndl_for_unrec < 0 )
        chndl = UCLYhndl_for_unspec;
      if ( UCCanTranslateFromTo(chndl, current_char_set) )
      {
        chartrans_ok = 1;
        HTAnchor_setUCInfoStage(anchor, chndl, 0, 1);
      }
    }
    if ( chartrans_ok )
    {
      p_in = HTAnchor_getUCInfoStage(anchor, 0);
      p_out = HTAnchor_setUCInfoStage(anchor, current_char_set, 3, 1);
      if ( !p_out )
        p_out = HTAnchor_getUCInfoStage(anchor, 3);
      if ( !strcmp(p_in->MIMEname, "x-transparent") )
      {
        HTPassEightBitRaw = 1;
        UCLYhndl = HTAnchor_getUCLYhndl(anchor, 3);
        HTAnchor_setUCInfoStage(anchor, UCLYhndl, 0, 1);
      }
      if ( !strcmp(p_out->MIMEname, "x-transparent") )
      {
        HTPassEightBitRaw = 1;
        v7 = HTAnchor_getUCLYhndl(anchor, 0);
        HTAnchor_setUCInfoStage(anchor, v7, 3, 1);
      }
      if ( p_in->enc == 5 )
      {
        if ( p_out->enc == 5 )
          Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
      }
      else
      {
        HTCJK = NOCJK;
        if ( (p_in->codepoints & 1) == 0 && chndl == current_char_set )
          HTPassEightBitRaw = 1;
      }
    }
    else
    {
      v8 = !strncmp(cp4a, "iso-8859-", 9u) && ((*__ctype_b_loc())[(unsigned __int8)cp4a[9]] & 0x800) != 0;
      given_is_8859 = v8;
      v9 = v8 || !strncmp(cp4a, "windows-", 8u) || !strncmp(cp4a, "cp12", 4u) || !strncmp(cp4a, "cp-12", 5u);
      given_is_8859like = v9;
      v10 = v9
         && (strstr(LYchar_set_names[current_char_set], "ISO-8859")
          || strstr(LYchar_set_names[current_char_set], "windows-"));
      given_and_display_8859like = v10;
      if ( v10 )
      {
        *cp1 = 0;
        format = HTAtom_for(cp);
      }
      if ( given_is_8859 )
      {
        for ( cp1 = cp4a + 10; *cp1 && ((*__ctype_b_loc())[(unsigned __int8)*cp1] & 0x800) != 0; ++cp1 )
          ;
        *cp1 = 0;
      }
      if ( given_and_display_8859like )
      {
        HTSACopy(&anchor->charset, cp4a);
        HTPassEightBitRaw = 1;
      }
      if ( *cp4a )
        Msg = cp4a;
      else
        Msg = anchor->charset;
      HTAlert(Msg);
    }
    if ( cp3 )
    {
      free(cp3);
      cp3 = 0;
    }
  }
  else if ( cp1 )
  {
    *cp1 = 0;
    format = HTAtom_for(cp);
  }
  if ( cp )
  {
    free(cp);
    cp = 0;
  }
  if ( !chartrans_ok && !anchor->charset && default_LYhndl >= 0 )
    HTAnchor_setUCInfoStage(anchor, default_LYhndl, 0, 1);
  HTAnchor_copyUCInfoStage(anchor, 1, 0, -1);
  return format;
}

//----- (081085C6) --------------------------------------------------------
void __cdecl LYGetFileInfo(
        const char *filename,
        HTParentAnchor **pfile_anchor,
        HTFormat *pformat,
        HTAtom **pencoding,
        const char **pdesc,
        const char **pcharset,
        int *pfile_cs)
{
  FILE *v7; // edx
  char *name; // [esp+24h] [ebp-34h]
  char *v9; // [esp+28h] [ebp-30h]
  const char *v10; // [esp+2Ch] [ebp-2Ch]
  const char *v11; // [esp+30h] [ebp-28h]
  const char *v12; // [esp+34h] [ebp-24h]
  int file_cs; // [esp+3Ch] [ebp-1Ch]
  const char *file_csname; // [esp+40h] [ebp-18h]
  HTParentAnchor *file_anchor; // [esp+44h] [ebp-14h]
  HTAtom *myEnc; // [esp+48h] [ebp-10h] BYREF
  HTFormat format; // [esp+4Ch] [ebp-Ch]
  char *Aname; // [esp+50h] [ebp-8h] BYREF
  char *Afn; // [esp+54h] [ebp-4h]

  Aname = 0;
  myEnc = 0;
  Afn = HTEscape(filename, 4u);
  LYLocalFileToURL(&Aname, Afn);
  file_anchor = HTAnchor_findSimpleAddress(Aname);
  file_csname = file_anchor->charset;
  format = HTFileFormat(filename, &myEnc, pdesc);
  format = HTCharsetFormat(format, file_anchor, UCLYhndl_HTFile_for_unspec);
  file_cs = HTAnchor_getUCLYhndl(file_anchor, 0);
  if ( !file_csname )
  {
    if ( file_cs < 0 )
      file_csname = "display character set";
    else
      file_csname = LYCharSet_UC[file_cs].MIMEname;
  }
  if ( WWW_TraceFlag[0] )
  {
    name = format->name;
    if ( myEnc )
      v9 = myEnc->name;
    else
      v9 = (char *)&entry;
    if ( myEnc && *myEnc->name == 56 )
    {
      v10 = "n";
    }
    else
    {
      if ( myEnc )
      {
        v11 = &entry;
      }
      else
      {
        if ( *format->name == 97 )
          v12 = "n";
        else
          v12 = &entry;
        v11 = v12;
      }
      v10 = v11;
    }
    v7 = TraceFP();
    fprintf(
      v7,
      "GetFileInfo: '%s' is a%s %s %s file, charset=%s (%d).\n",
      filename,
      v10,
      v9,
      name,
      file_csname,
      file_cs);
  }
  if ( Afn )
  {
    free(Afn);
    Afn = 0;
  }
  if ( Aname )
  {
    free(Aname);
    Aname = 0;
  }
  if ( pfile_anchor )
    *pfile_anchor = file_anchor;
  if ( pformat )
    *pformat = format;
  if ( pencoding )
    *pencoding = myEnc;
  if ( pcharset )
    *pcharset = file_csname;
  if ( pfile_cs )
    *pfile_cs = file_cs;
}

//----- (081087D0) --------------------------------------------------------
float __cdecl HTFileValue(const char *filename)
{
  FILE *v1; // edx
  double quality; // [esp+18h] [ebp-30h]
  int ls; // [esp+34h] [ebp-14h]
  int lf; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int n; // [esp+40h] [ebp-8h]
  HTSuffix *suff; // [esp+44h] [ebp-4h]

  lf = strlen(filename);
  n = HTList_count(HTSuffixes);
  for ( i = 0; ; ++i )
  {
    if ( i >= n )
      return 0.30000001;
    suff = (HTSuffix *)HTList_objectAt(HTSuffixes, i);
    ls = strlen(suff->suffix);
    if ( ls <= lf && !strcmp(suff->suffix, &filename[lf - ls]) )
      break;
  }
  if ( WWW_TraceFlag[0] )
  {
    quality = suff->quality;
    v1 = TraceFP();
    fprintf(v1, "File: Value of %s is %.3f\n", filename, quality);
  }
  return suff->quality;
}

//----- (081088BA) --------------------------------------------------------
CompressFileType __cdecl HTCompressFileType(const char *filename, const char *dots, int *rootlen)
{
  const char *v3; // ebx
  FILE *v4; // edx
  const char *ftype; // [esp+24h] [ebp-14h]
  size_t len; // [esp+28h] [ebp-10h]
  CompressFileType result; // [esp+2Ch] [ebp-Ch]

  result = cftNone;
  len = strlen(filename);
  ftype = &filename[len];
  if ( len <= 4 || strcasecomp(ftype - 3, "bz2") || !strchr(dots, *(ftype - 4)) )
  {
    if ( len <= 3 || strcasecomp(ftype - 2, "gz") || !strchr(dots, *(ftype - 3)) )
    {
      if ( len <= 3 || strcasecomp(ftype - 2, "zz") || !strchr(dots, *(ftype - 3)) )
      {
        if ( len > 2 && !strcmp(ftype - 1, "Z") && strchr(dots, *(ftype - 2)) )
        {
          result = cftCompress;
          ftype -= 2;
        }
      }
      else
      {
        result = cftDeflate;
        ftype -= 3;
      }
    }
    else
    {
      result = cftGzip;
      ftype -= 3;
    }
  }
  else
  {
    result = cftBzip2;
    ftype -= 4;
  }
  *rootlen = ftype - filename;
  if ( WWW_TraceFlag[0] )
  {
    v3 = &filename[*rootlen];
    v4 = TraceFP();
    fprintf(v4, "HTCompressFileType(%s) returns %d:%s\n", filename, result, v3);
  }
  return result;
}

//----- (08108A6D) --------------------------------------------------------
const char *__cdecl HTCompressTypeToSuffix(CompressFileType method)
{
  if ( method == cftGzip )
    return ".gz";
  if ( (unsigned int)method > cftGzip )
  {
    if ( method == cftBzip2 )
      return ".bz2";
    if ( method == cftDeflate )
      return ".zz";
  }
  else if ( method == cftCompress )
  {
    return ".Z";
  }
  return &entry;
}

//----- (08108AD0) --------------------------------------------------------
const char *__cdecl HTCompressTypeToEncoding(CompressFileType method)
{
  if ( method == cftGzip )
    return "gzip";
  if ( (unsigned int)method > cftGzip )
  {
    if ( method == cftBzip2 )
      return "bzip2";
    if ( method == cftDeflate )
      return "deflate";
  }
  else if ( method == cftCompress )
  {
    return "compress";
  }
  return 0;
}

//----- (08108B33) --------------------------------------------------------
CompressFileType __cdecl HTEncodingToCompressType(const char *coding)
{
  CompressFileType result; // [esp+14h] [ebp-4h]

  result = cftNone;
  if ( !coding )
    return 0;
  if ( !strcasecomp(coding, "gzip") || !strcasecomp(coding, "x-gzip") )
    return 2;
  if ( !strcasecomp(coding, "compress") || !strcasecomp(coding, "x-compress") )
    return 1;
  if ( !strcasecomp(coding, "bzip2") || !strcasecomp(coding, "x-bzip2") )
    return 3;
  if ( !strcasecomp(coding, "deflate") || !strcasecomp(coding, "x-deflate") )
    return 4;
  return result;
}

//----- (08108C34) --------------------------------------------------------
CompressFileType __cdecl HTContentTypeToCompressType(const char *ct)
{
  CompressFileType method; // [esp+24h] [ebp-4h]

  method = cftNone;
  if ( !ct )
    return 0;
  if ( !strncasecomp(ct, "application/gzip", 16) || !strncasecomp(ct, "application/x-gzip", 18) )
    return 2;
  if ( !strncasecomp(ct, "application/compress", 20) || !strncasecomp(ct, "application/x-compress", 22) )
    return 1;
  if ( !strncasecomp(ct, "application/bzip2", 17) || !strncasecomp(ct, "application/x-bzip2", 19) )
    return 3;
  return method;
}

//----- (08108D2E) --------------------------------------------------------
CompressFileType __cdecl HTContentToCompressType(HTParentAnchor *anchor)
{
  const char *ce; // [esp+Ch] [ebp-Ch]
  const char *ct; // [esp+10h] [ebp-8h]
  CompressFileType method; // [esp+14h] [ebp-4h]

  method = cftNone;
  ct = HTAnchor_content_type(anchor);
  ce = HTAnchor_content_encoding(anchor);
  if ( !ce && ct )
    return HTContentTypeToCompressType(ct);
  if ( ce )
    return HTEncodingToCompressType(ce);
  return method;
}

//----- (08108D8C) --------------------------------------------------------
BOOLEAN __cdecl HTEditable(const char *filename)
{
  uid_t v1; // ebx
  __gid_t st_gid; // esi
  __uid_t st_uid; // edi
  FILE *v4; // edx
  gid_t v5; // ebx
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  __mode_t st_mode; // [esp+28h] [ebp-40080h]
  gid_t groups[65536]; // [esp+2Ch] [ebp-4007Ch] BYREF
  stat fileStatus; // [esp+4002Ch] [ebp-7Ch] BYREF
  int i2; // [esp+4008Ch] [ebp-1Ch]
  int i; // [esp+40090h] [ebp-18h]
  int ngroups; // [esp+40094h] [ebp-14h]
  uid_t myUid; // [esp+40098h] [ebp-10h]

  if ( stat64((int)filename, (int)&fileStatus) )
    return 0;
  ngroups = getgroups(0x10000, groups);
  myUid = geteuid();
  if ( WWW_TraceFlag[0] )
  {
    v1 = myUid;
    st_gid = fileStatus.st_gid;
    st_uid = fileStatus.st_uid;
    st_mode = fileStatus.st_mode;
    v4 = TraceFP();
    fprintf(v4, "File mode is 0%o, uid=%d, gid=%d. My uid=%d, %d groups (", st_mode, st_uid, st_gid, v1, ngroups);
    for ( i2 = 0; i2 < ngroups; ++i2 )
    {
      v5 = groups[i2];
      v6 = TraceFP();
      fprintf(v6, " %d", v5);
    }
    v7 = TraceFP();
    fwrite(")\n", 1u, 2u, v7);
  }
  if ( (fileStatus.st_mode & 2) != 0 )
    return 1;
  if ( (fileStatus.st_mode & 0x80) != 0 && fileStatus.st_uid == myUid )
    return 1;
  if ( (fileStatus.st_mode & 0x10) != 0 )
  {
    for ( i = 0; i < ngroups; ++i )
    {
      if ( groups[i] == fileStatus.st_gid )
        return 1;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v8 = TraceFP();
    fprintf(v8, "\tFile is not editable.\n");
  }
  return 0;
}

//----- (08108F37) --------------------------------------------------------
HTStream *__cdecl HTFileSaveStream(HTParentAnchor *anchor)
{
  FILE *fp; // [esp+1Ch] [ebp-Ch]
  char *localname; // [esp+20h] [ebp-8h]

  localname = HTnameOfFile_WWW(anchor->address, 1, 1);
  fp = (FILE *)fopen64(localname, "wb");
  if ( localname )
    free(localname);
  if ( fp )
    return (HTStream *)HTFWriter_new(fp);
  else
    return 0;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08108FB4) --------------------------------------------------------
void __cdecl HTDirEntry(HTStructured_1 *target, const char *tail, const char *entry)
{
  const char *href; // [esp+1Ch] [ebp-1Ch]
  int len; // [esp+28h] [ebp-10h]
  char *escaped; // [esp+2Ch] [ebp-Ch] BYREF
  char *stripped; // [esp+30h] [ebp-8h]
  char *relative; // [esp+34h] [ebp-4h] BYREF

  relative = 0;
  stripped = 0;
  escaped = 0;
  HTSACopy(&escaped, entry);
  LYTrimPathSep(escaped);
  if ( strcmp(escaped, "..") )
  {
    stripped = escaped;
    escaped = HTEscape(escaped, 2u);
    len = strlen(escaped);
    if ( len > 2
      && escaped[len - 3] == 37
      && escaped[len - 2] == 50
      && (((*__ctype_b_loc())[(unsigned __int8)escaped[len - 1]] & 0x200) != 0 ? toupper((unsigned __int8)escaped[len - 1]) == 70 : escaped[len - 1] == 70) )
    {
      escaped[len - 3] = 0;
    }
  }
  if ( tail && *tail )
  {
    relative = 0;
    if ( *escaped )
      HTSprintf0(&relative, "%s%s%s", tail, "/", escaped);
    else
      HTSprintf0(&relative, "%s%s%s", tail, &::entry, escaped);
    HTStartAnchor(target, 0, relative);
    if ( relative )
    {
      free(relative);
      relative = 0;
    }
  }
  else
  {
    if ( *escaped )
      href = escaped;
    else
      href = "/";
    HTStartAnchor(target, 0, href);
  }
  if ( stripped )
  {
    free(stripped);
    stripped = 0;
  }
  if ( escaped )
    free(escaped);
}

//----- (081091DC) --------------------------------------------------------
BOOLEAN __cdecl view_structured(HTFormat format_out)
{
  BOOLEAN result; // [esp+17h] [ebp-1h]

  result = 0;
  if ( psrc_view || HTAtom_for("www/dump") == format_out )
    return 1;
  return result;
}

//----- (0810920C) --------------------------------------------------------
void __cdecl HTStructured_doctype(HTStructured_1 *target, HTFormat format_out)
{
  if ( view_structured(format_out) )
    target->isa->put_string(
      (HTStructured *)target,
      "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n");
}

//----- (0810923B) --------------------------------------------------------
void __cdecl HTStructured_meta(HTStructured_1 *target, HTFormat format_out)
{
  if ( view_structured(format_out) )
    target->isa->put_string(
      (HTStructured *)target,
      "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">\n");
}

//----- (0810926A) --------------------------------------------------------
BOOLEAN __cdecl HTDirTitles(HTStructured_1 *target, HTParentAnchor *anchor, HTFormat format_out, BOOLEAN tildeIsTop)
{
  void (*v4)(HTStructured *, const char *); // ebx
  void (*v5)(HTStructured *, const char *); // ebx
  char *v7; // [esp+4h] [ebp-74h]
  char *v8; // [esp+4h] [ebp-74h]
  const char *name; // [esp+1Ch] [ebp-5Ch]
  void (*put_string)(HTStructured *, const char *); // [esp+20h] [ebp-58h]
  char *v11; // [esp+24h] [ebp-54h]
  void (*v12)(HTStructured *, const char *); // [esp+28h] [ebp-50h]
  char *v13; // [esp+2Ch] [ebp-4Ch]
  void (*v14)(HTStructured *, const char *); // [esp+30h] [ebp-48h]
  char *v15; // [esp+34h] [ebp-44h]
  char *printable; // [esp+4Ch] [ebp-2Ch] BYREF
  DIR *dp; // [esp+50h] [ebp-28h]
  char *relative; // [esp+54h] [ebp-24h] BYREF
  char *parent; // [esp+58h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-1Ch]
  char *cp; // [esp+60h] [ebp-18h] BYREF
  char *current; // [esp+64h] [ebp-14h]
  char *path; // [esp+68h] [ebp-10h]
  const char *logical; // [esp+6Ch] [ebp-Ch]
  BOOLEAN need_parent_link; // [esp+73h] [ebp-5h]

  logical = anchor->address;
  path = HTParse(logical, &entry, 5);
  cp = 0;
  need_parent_link = 0;
  if ( tildeIsTop && !strncmp(path, "/~", 2u) )
  {
    if ( path[2] )
    {
      for ( i = 0; path[i + 2]; ++i )
        path[i] = path[i + 2];
      path[i] = 0;
    }
    else
    {
      path[1] = 0;
    }
  }
  cp = strrchr(path, 59);
  if ( cp )
  {
    if ( !strncasecomp(cp + 1, "type=", 5) )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 0x200) != 0 )
      {
        if ( toupper((unsigned __int8)cp[6]) == 68 )
          goto LABEL_23;
      }
      else if ( cp[6] == 68 )
      {
        goto LABEL_23;
      }
      if ( ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 0x200) != 0 )
      {
        if ( toupper((unsigned __int8)cp[6]) == 65 )
          goto LABEL_23;
      }
      else if ( cp[6] == 65 )
      {
        goto LABEL_23;
      }
      if ( ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 0x200) != 0 )
      {
        if ( toupper((unsigned __int8)cp[6]) != 73 )
          goto LABEL_24;
        goto LABEL_23;
      }
      if ( cp[6] == 73 )
LABEL_23:
        *cp = 0;
    }
LABEL_24:
    cp = 0;
  }
  current = LYPathLeaf(path);
  relative = 0;
  if ( strncasecomp(path, "/%2F", 4) )
    name = path;
  else
    name = path + 1;
  relative = HTURLPath_toFile(name, 1, 1);
  if ( !strncasecomp(relative, "/vmsysu:", 8) || !strncasecomp(relative, "/anonymou.", 10) )
  {
    HTSACopy(&cp, relative + 1);
    HTSACopy(&relative, cp);
    if ( cp )
    {
      free(cp);
      cp = 0;
    }
  }
  HTStructured_doctype(target, format_out);
  target->isa->start_element((HTStructured *)target, 53, 0, 0, -1, 0);
  target->isa->put_character((HTStructured *)target, 10);
  target->isa->start_element((HTStructured *)target, 110, 0, 0, -1, 0);
  put_string = target->isa->put_string;
  if ( *relative )
    v11 = relative;
  else
    v11 = gettext("Welcome");
  put_string((HTStructured *)target, v11);
  v4 = target->isa->put_string;
  v7 = gettext(" directory");
  v4((HTStructured *)target, v7);
  target->isa->end_element((HTStructured *)target, 110, 0);
  target->isa->put_character((HTStructured *)target, 10);
  HTStructured_meta(target, format_out);
  target->isa->end_element((HTStructured *)target, 53, 0);
  target->isa->put_character((HTStructured *)target, 10);
  target->isa->start_element((HTStructured *)target, 17, 0, 0, -1, 0);
  target->isa->put_character((HTStructured *)target, 10);
  target->isa->start_element((HTStructured *)target, 48, 0, 0, -1, 0);
  v12 = target->isa->put_string;
  if ( *relative )
    v13 = gettext("Current directory is ");
  else
    v13 = (char *)&entry;
  v12((HTStructured *)target, v13);
  v14 = target->isa->put_string;
  if ( *relative )
    v15 = relative;
  else
    v15 = gettext("Welcome");
  v14((HTStructured *)target, v15);
  target->isa->end_element((HTStructured *)target, 48, 0);
  target->isa->put_character((HTStructured *)target, 10);
  if ( !strncasecomp(relative, "vmsysu:", 7) && (cp = strchr(relative, 46)) != 0 && !strchr(cp, 47)
    || !strncasecomp(relative, "anonymou.", 9) && !strchr(relative, 47) )
  {
    if ( relative )
    {
      free(relative);
      relative = 0;
    }
    if ( path )
    {
      free(path);
      path = 0;
    }
    return need_parent_link;
  }
  if ( relative )
  {
    free(relative);
    relative = 0;
  }
  if ( current - path > 0 && *(current - 1) == 47 && *current )
  {
    parent = 0;
    relative = 0;
    *(current - 1) = 0;
    parent = strrchr(path, 47);
    if ( parent && (!strcmp(parent, "/..") || !strncasecomp(parent, "/%2F", 4)) || !strncasecomp(current, "%2F", 3) )
    {
      if ( path )
      {
        free(path);
        path = 0;
      }
      return need_parent_link;
    }
    relative = 0;
    HTSprintf0(&relative, "%s/..", current);
    dp = 0;
    if ( LYisLocalFile(logical) )
    {
      printable = 0;
      if ( *path )
        HTSACopy(&printable, path);
      else
        HTSACopy(&printable, "/");
      if ( !strcmp(current, "..") )
      {
        HTSACat(&printable, "/../..");
      }
      else if ( !strcmp(current, ".") )
      {
        HTSACat(&printable, "/..");
      }
      HTUnEscape(printable);
      dp = opendir(printable);
      if ( dp )
      {
        closedir(dp);
        if ( printable )
        {
          free(printable);
          printable = 0;
        }
        need_parent_link = 1;
        if ( path )
        {
          free(path);
          path = 0;
        }
        if ( relative )
        {
          free(relative);
          relative = 0;
        }
        return need_parent_link;
      }
      else
      {
        if ( printable )
        {
          free(printable);
          printable = 0;
        }
        if ( relative )
        {
          free(relative);
          relative = 0;
        }
        if ( path )
        {
          free(path);
          path = 0;
        }
        return need_parent_link;
      }
    }
    HTStartAnchor(target, &entry, relative);
    if ( relative )
    {
      free(relative);
      relative = 0;
    }
    v5 = target->isa->put_string;
    v8 = gettext("Up to ");
    v5((HTStructured *)target, v8);
    if ( parent )
    {
      if ( !strcmp(current, ".") || !strcmp(current, "..") )
      {
        target->isa->put_string((HTStructured *)target, "..");
      }
      else
      {
        printable = 0;
        HTSACopy(&printable, parent + 1);
        HTUnEscape(printable);
        target->isa->put_string((HTStructured *)target, printable);
        if ( printable )
        {
          free(printable);
          printable = 0;
        }
      }
    }
    else
    {
      target->isa->put_character((HTStructured *)target, 47);
    }
    target->isa->end_element((HTStructured *)target, 0, 0);
    target->isa->put_character((HTStructured *)target, 10);
  }
  if ( path )
  {
    free(path);
    path = 0;
  }
  return need_parent_link;
}

//----- (08109CCB) --------------------------------------------------------
void __cdecl do_readme(HTStructured_1 *target, const char *localname)
{
  int ch_0; // [esp+3Ch] [ebp-Ch]
  char *readme_file_name; // [esp+40h] [ebp-8h] BYREF
  FILE *fp; // [esp+44h] [ebp-4h]

  readme_file_name = 0;
  HTSprintf0(&readme_file_name, "%s/%s", localname, "README");
  fp = (FILE *)fopen64(readme_file_name, "r");
  if ( fp )
  {
    ((void (__cdecl *)(HTStructured_1 *, int, _DWORD, _DWORD, int, _DWORD, const char *, void (*)(HTStructured *), void (*)(HTStructured *, HTError), void (*)(HTStructured *, char), void (*)(HTStructured *, const char *), void (*)(HTStructured *, const char *, int), int (*)(HTStructured *, int, const BOOLEAN *, const char **, int, char **), int (*)(HTStructured *, int, char **), int (*)(HTStructured *, int)))target->isa->start_element)(
      target,
      86,
      0,
      0,
      -1,
      0,
      target->isa->name,
      target->isa->_free,
      target->isa->_abort,
      target->isa->put_character,
      target->isa->put_string,
      target->isa->put_block,
      target->isa->start_element,
      target->isa->end_element,
      target->isa->put_entity);
    while ( 1 )
    {
      ch_0 = fgetc(fp);
      if ( ch_0 == -1 )
        break;
      target->isa->put_character((HTStructured *)target, ch_0);
    }
    target->isa->end_element((HTStructured *)target, 86, 0);
    HTDisplayPartial();
    fclose(fp);
  }
  if ( readme_file_name )
    free(readme_file_name);
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08109E07) --------------------------------------------------------
const char *__cdecl file_type(const char *path)
{
  char *type; // [esp+14h] [ebp-4h]

  while ( *path == 46 )
    ++path;
  type = strchr(path, 46);
  if ( !type )
    return &entry;
  return type;
}

//----- (08109E45) --------------------------------------------------------
int __cdecl dired_cmp(void *a, void *b)
{
  const char *v2; // ebx
  const char *v3; // eax
  int v5; // [esp+14h] [ebp-54h]
  int v6; // [esp+40h] [ebp-28h]
  int v7; // [esp+44h] [ebp-24h]
  int v8; // [esp+48h] [ebp-20h]
  int v9; // [esp+4Ch] [ebp-1Ch]
  int code; // [esp+54h] [ebp-14h]

  code = *((char *)a + 96) - *((char *)b + 96);
  if ( !code )
  {
    switch ( dir_list_order )
    {
      case 1:
        if ( *(_QWORD *)((char *)a + 44) < *(_QWORD *)((char *)b + 44) )
          v5 = 1;
        else
          v5 = -(*(_QWORD *)((char *)a + 44) > *(_QWORD *)((char *)b + 44));
        code = v5;
        break;
      case 2:
        if ( *((_DWORD *)a + 18) < *((_DWORD *)b + 18) )
          v6 = 1;
        else
          v6 = -(*((_DWORD *)a + 18) > *((_DWORD *)b + 18));
        code = v6;
        break;
      case 3:
        if ( *((_DWORD *)a + 4) < *((_DWORD *)b + 4) )
          v7 = -1;
        else
          v7 = *((_DWORD *)a + 4) > *((_DWORD *)b + 4);
        code = v7;
        break;
      case 4:
        v2 = file_type((const char *)b + 97);
        v3 = file_type((const char *)a + 97);
        code = strcmp(v3, v2);
        break;
      case 5:
        if ( *((_DWORD *)a + 6) < *((_DWORD *)b + 6) )
          v8 = -1;
        else
          v8 = *((_DWORD *)a + 6) > *((_DWORD *)b + 6);
        code = v8;
        break;
      case 6:
        if ( *((_DWORD *)a + 7) < *((_DWORD *)b + 7) )
          v9 = -1;
        else
          v9 = *((_DWORD *)a + 7) > *((_DWORD *)b + 7);
        code = v9;
        break;
      default:
        code = 0;
        break;
    }
  }
  if ( !code )
    return strcmp((const char *)a + 97, (const char *)b + 97);
  return code;
}

//----- (0810A07D) --------------------------------------------------------
int __cdecl print_local_dir(DIR *dp, char *localname, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink)
{
  FILE *v5; // eax
  const HTStructuredClass *isa; // edx
  char *v7; // eax
  size_t v8; // eax
  char *v9; // eax
  FILE *v10; // eax
  char *v11; // eax
  HTAtom *v13; // [esp+4h] [ebp-134h]
  int v14; // [esp+20h] [ebp-118h]
  char v15; // [esp+26h] [ebp-112h]
  char v16; // [esp+27h] [ebp-111h]
  void (*put_string)(HTStructured *, const char *); // [esp+28h] [ebp-110h]
  char *v18; // [esp+2Ch] [ebp-10Ch]
  int v19; // [esp+30h] [ebp-108h]
  stat link_info; // [esp+54h] [ebp-E4h] BYREF
  HTStructuredClass targetClass; // [esp+B4h] [ebp-84h]
  DIRED *entry; // [esp+D8h] [ebp-60h]
  int num_of_entries_output; // [esp+DCh] [ebp-5Ch]
  HTBTElement *next_element; // [esp+E0h] [ebp-58h]
  DIRED *data; // [esp+E4h] [ebp-54h]
  int num_of_entries; // [esp+E8h] [ebp-50h]
  stat *actual_info; // [esp+ECh] [ebp-4Ch]
  int i; // [esp+F0h] [ebp-48h]
  int status; // [esp+F4h] [ebp-44h]
  char *tmpfilename; // [esp+F8h] [ebp-40h] BYREF
  char *p; // [esp+FCh] [ebp-3Ch]
  char *tail; // [esp+100h] [ebp-38h] BYREF
  char *pathname; // [esp+104h] [ebp-34h]
  dirent *dirbuf; // [esp+108h] [ebp-30h]
  HTBTree *bt; // [esp+10Ch] [ebp-2Ch]
  HTStructured_1 *target; // [esp+110h] [ebp-28h]
  char test; // [esp+117h] [ebp-21h]
  char state; // [esp+118h] [ebp-20h]
  BOOLEAN preformatted; // [esp+119h] [ebp-1Fh]
  BOOLEAN need_parent_link; // [esp+11Ah] [ebp-1Eh]
  BOOLEAN present[25]; // [esp+11Bh] [ebp-1Dh]
  unsigned int v42; // [esp+134h] [ebp-4h]

  v42 = __readgsdword(0x14u);
  pathname = 0;
  tail = 0;
  tmpfilename = 0;
  need_parent_link = 0;
  preformatted = 0;
  num_of_entries = 0;
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "print_local_dir() started\n");
  }
  pathname = HTParse(anchor->address, &::entry, 5);
  p = strrchr(pathname, 47);
  if ( !p )
    p = "/";
  HTSACopy(&tail, p + 1);
  if ( pathname )
  {
    free(pathname);
    pathname = 0;
  }
  if ( UCLYhndl_HTFile_for_unspec >= 0 )
    HTAnchor_setUCInfoStage(anchor, UCLYhndl_HTFile_for_unspec, 1, 1);
  target = (HTStructured_1 *)HTML_new(anchor, format_out, (HTStream_0 *)sink);
  isa = target->isa;
  targetClass.name = target->isa->name;
  targetClass._free = isa->_free;
  targetClass._abort = isa->_abort;
  targetClass.put_character = isa->put_character;
  targetClass.put_string = isa->put_string;
  targetClass.put_block = isa->put_block;
  targetClass.start_element = isa->start_element;
  targetClass.end_element = isa->end_element;
  targetClass.put_entity = isa->put_entity;
  for ( i = 0; i <= 24; ++i )
    present[i] = i == 6;
  need_parent_link = HTDirTitles(target, anchor, format_out, 0);
  if ( *anchor->address != 108 && *anchor->address != 76 || strncasecomp(anchor->address, "lynxcgi:", 8) )
  {
    v13 = HTAtom_for("www/dired");
    HTAnchor_setFormat(anchor, v13);
    lynx_edit_mode = 1;
  }
  if ( HTDirReadme == 1 )
    do_readme(target, localname);
  bt = HTBTree_new(dired_cmp);
  mustshow[0] = 1;
  v7 = gettext("Reading directory...");
  HTProgress(v7);
  status = 200;
  while ( 1 )
  {
    dirbuf = (dirent *)readdir64(dp);
    if ( !dirbuf )
      break;
    data = 0;
    if ( dirbuf->d_ino
      && strcmp(dirbuf->d_name, ".")
      && (strcmp(dirbuf->d_name, "..") || need_parent_link)
      && (!strcmp(dirbuf->d_name, "..") || dirbuf->d_name[0] != 46 || !no_dotfiles && show_dotfiles) )
    {
      HTSACopy(&tmpfilename, localname);
      LYAddPathSep(&tmpfilename);
      HTSACat(&tmpfilename, dirbuf->d_name);
      v8 = strlen(dirbuf->d_name);
      data = (DIRED *)malloc(v8 + 104);
      if ( !data )
      {
        status = 206;
        break;
      }
      LYTrimPathSep(tmpfilename);
      actual_info = &data->file_info;
      if ( lstat64((int)tmpfilename, (int)data) >= 0 )
      {
        if ( (actual_info->st_mode & 0xF000) == 40960 )
        {
          actual_info = &link_info;
          if ( stat64((int)tmpfilename, (int)&link_info) < 0 )
            actual_info->st_mode = 0;
        }
      }
      else
      {
        actual_info->st_mode = 0;
      }
      strcpy(data->file_name, dirbuf->d_name);
      if ( (actual_info->st_mode & 0xF000) == 0x4000 )
      {
        if ( dir_list_style == 2 )
        {
          data->sort_tags = 32;
          LYAddPathSep0(data->file_name);
        }
        else if ( !strcmp(dirbuf->d_name, "..") )
        {
          data->sort_tags = 65;
        }
        else
        {
          data->sort_tags = 68;
        }
      }
      else if ( dir_list_style == 2 )
      {
        data->sort_tags = 32;
      }
      else if ( dir_list_style == 1 )
      {
        data->sort_tags = 67;
      }
      else
      {
        data->sort_tags = 70;
      }
      HTBTree_add(bt, data);
      if ( partial_threshold <= 0 )
        v14 = display_lines;
      else
        v14 = partial_threshold;
      if ( !(num_of_entries % v14) && HTCheckForInterrupt() )
      {
        status = 206;
        break;
      }
      ++num_of_entries;
    }
  }
  if ( status == 206 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v10 = TraceFP();
      fprintf(v10, "Reading the directory interrupted by user\n");
    }
  }
  else
  {
    mustshow[0] = 1;
    v9 = gettext("OK");
    HTProgress(v9);
  }
  next_element = HTBTree_next(bt, 0);
  num_of_entries_output = 0;
  state = 73;
  while ( next_element )
  {
    HTSACopy(&tmpfilename, localname);
    LYAddPathSep(&tmpfilename);
    entry = (DIRED *)next_element->object;
    HTSACat(&tmpfilename, entry->file_name);
    HTSimplify(tmpfilename);
    if ( strcmp((const char *)next_element->object + 97, "..") )
    {
      v15 = *((_BYTE *)next_element->object + 96) == 68 ? 68 : 70;
      test = v15;
      if ( state != v15 )
      {
        if ( *((_BYTE *)next_element->object + 96) == 68 )
          v16 = 68;
        else
          v16 = 70;
        state = v16;
        if ( preformatted )
        {
          target->isa->end_element((HTStructured *)target, 86, 0);
          target->isa->put_character((HTStructured *)target, 10);
          preformatted = 0;
        }
        target->isa->start_element((HTStructured *)target, 48, 0, 0, -1, 0);
        if ( dir_list_style != 2 )
        {
          target->isa->start_element((HTStructured *)target, 38, 0, 0, -1, 0);
          put_string = target->isa->put_string;
          if ( state == 68 )
            v18 = gettext("Subdirectories:");
          else
            v18 = gettext("Files:");
          put_string((HTStructured *)target, v18);
          target->isa->end_element((HTStructured *)target, 38, 0);
        }
        target->isa->end_element((HTStructured *)target, 48, 0);
        target->isa->put_character((HTStructured *)target, 10);
      }
    }
    if ( !preformatted )
    {
      target->isa->start_element((HTStructured *)target, 86, 0, 0, -1, 0);
      target->isa->put_character((HTStructured *)target, 10);
      preformatted = 1;
    }
    LYListFmtParse(list_format, entry, tmpfilename, target, tail);
    next_element = HTBTree_next(bt, next_element);
    if ( partial_threshold <= 0 )
      v19 = display_lines;
    else
      v19 = partial_threshold;
    if ( !(num_of_entries_output % v19) )
    {
      HTDisplayPartial();
      if ( HTCheckForInterrupt() )
      {
        mustshow[0] = 1;
        v11 = gettext("Data transfer interrupted.");
        HTProgress(v11);
        status = 206;
        break;
      }
    }
    ++num_of_entries_output;
  }
  if ( status == 200 && state == 73 )
  {
    target->isa->start_element((HTStructured *)target, 83, 0, 0, -1, 0);
    target->isa->put_string((HTStructured *)target, "Empty Directory");
  }
  if ( preformatted )
  {
    target->isa->end_element((HTStructured *)target, 86, 0);
    target->isa->put_character((HTStructured *)target, 10);
  }
  target->isa->end_element((HTStructured *)target, 17, 0);
  target->isa->put_character((HTStructured *)target, 10);
  if ( tmpfilename )
  {
    free(tmpfilename);
    tmpfilename = 0;
  }
  if ( tail )
  {
    free(tail);
    tail = 0;
  }
  HTBTreeAndObject_free(bt);
  if ( status == 200 )
  {
    if ( HTDirReadme == 2 )
      do_readme(target, localname);
    target->isa->_free((HTStructured *)target);
  }
  else
  {
    targetClass._abort((HTStructured *)target, 0);
  }
  HTFinishDisplayPartial();
  return status;
}
// 804AE14: using guessed type int __cdecl readdir64(_DWORD);

//----- (0810AAC2) --------------------------------------------------------
int __cdecl HTStat(const char *filename, stat *data)
{
  char *temp_name; // [esp+1Ch] [ebp-Ch] BYREF
  size_t len; // [esp+20h] [ebp-8h]
  int result; // [esp+24h] [ebp-4h]

  result = -1;
  len = strlen(filename);
  if ( !len || filename[len - 1] != 47 )
    return stat64((int)filename, (int)data);
  temp_name = 0;
  HTSprintf0(&temp_name, "%s.", filename);
  result = HTStat(temp_name, data);
  if ( temp_name )
  {
    free(temp_name);
    temp_name = 0;
  }
  return result;
}

//----- (0810AB5E) --------------------------------------------------------
int __cdecl decompressAndParse(
        HTParentAnchor *anchor,
        HTFormat format_out,
        HTStream *sink,
        char *nodename,
        char *filename,
        HTAtom *myEncoding,
        HTFormat format,
        int *statusp)
{
  CompressFileType v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  char *v15; // eax
  char *lastslash; // [esp+28h] [ebp-40h]
  char *anchor_path; // [esp+2Ch] [ebp-3Ch]
  char *sugfname; // [esp+30h] [ebp-38h] BYREF
  CompressFileType cft; // [esp+34h] [ebp-34h]
  CompressFileType method; // [esp+38h] [ebp-30h]
  HTList *methods; // [esp+3Ch] [ebp-2Ch]
  HTAtom *put; // [esp+40h] [ebp-28h]
  FILE *fp; // [esp+44h] [ebp-24h]
  int bin; // [esp+48h] [ebp-20h]
  char *localname; // [esp+4Ch] [ebp-1Ch]
  int rootlen; // [esp+50h] [ebp-18h] BYREF
  CompressFileType internal_decompress; // [esp+54h] [ebp-14h]
  gzFile gzfp; // [esp+58h] [ebp-10h]
  FILE *zzfp; // [esp+5Ch] [ebp-Ch]
  HTAtom *encoding; // [esp+60h] [ebp-8h] BYREF
  BOOLEAN failed_decompress; // [esp+67h] [ebp-1h]
  HTAtom *formata; // [esp+88h] [ebp+20h]

  encoding = 0;
  zzfp = 0;
  gzfp = 0;
  internal_decompress = cftNone;
  failed_decompress = 0;
  rootlen = 0;
  localname = filename;
  v8 = HTCompressFileType(filename, ".", &rootlen);
  bin = v8 != cftNone;
  if ( v8 )
    v9 = (FILE *)fopen64(localname, "rb");
  else
    v9 = (FILE *)fopen64(localname, "r");
  fp = v9;
  if ( WWW_TraceFlag[0] )
  {
    v10 = TraceFP();
    fprintf(v10, "HTLoadFile: Opening `%s' gives %p\n", localname, fp);
  }
  if ( !fp )
    return 0;
  if ( HTEditable(localname) )
  {
    put = HTAtom_for("PUT");
    methods = HTAnchor_methods(anchor);
    if ( HTList_indexOf(methods, put) == -1 )
      HTList_addObject(methods, put);
  }
  if ( !myEncoding
    || HTAtom_for("identity") == myEncoding
    || HTAtom_for("8bit") == myEncoding
    || HTAtom_for("binary") == myEncoding
    || HTAtom_for("7bit") == myEncoding )
  {
    cft = HTCompressFileType(localname, ".", &rootlen);
    if ( cft )
    {
      sugfname = 0;
      HTSACopy(&sugfname, localname);
      sugfname[rootlen] = 0;
      formata = HTFileFormat(sugfname, &encoding, 0);
      if ( sugfname )
      {
        free(sugfname);
        sugfname = 0;
      }
      format = HTCharsetFormat(formata, anchor, UCLYhndl_HTFile_for_unspec);
      HTSACopy(&anchor->content_type, format->name);
    }
    if ( cft == cftGzip )
    {
      HTSACopy(&anchor->content_encoding, "x-gzip");
      if ( strcmp(format_out->name, "www/download") )
      {
        fclose(fp);
        gzfp = (gzFile)gzopen64(localname, "rb");
        if ( WWW_TraceFlag[0] )
        {
          v14 = TraceFP();
          fprintf(v14, "HTLoadFile: gzopen of `%s' gives %p\n", localname, gzfp);
        }
        internal_decompress = cftGzip;
      }
    }
    else if ( (unsigned int)cft > cftGzip )
    {
      if ( cft == cftBzip2 )
      {
        HTSACopy(&anchor->content_encoding, "x-bzip2");
        format = HTAtom_for("www/compressed");
      }
      else if ( cft == cftDeflate )
      {
        HTSACopy(&anchor->content_encoding, "x-deflate");
        if ( strcmp(format_out->name, "www/download") )
        {
          zzfp = fp;
          fp = 0;
          if ( WWW_TraceFlag[0] )
          {
            v13 = TraceFP();
            fprintf(v13, "HTLoadFile: zzopen of `%s' gives %p\n", localname, zzfp);
          }
          internal_decompress = cftDeflate;
        }
      }
    }
    else if ( cft == cftCompress )
    {
      HTSACopy(&anchor->content_encoding, "x-compress");
      format = HTAtom_for("www/compressed");
    }
  }
  else
  {
    method = HTEncodingToCompressType(myEncoding->name);
    if ( !strcmp(format_out->name, "www/download") || method != cftGzip )
    {
      if ( !strcmp(format_out->name, "www/download") || method != cftDeflate )
      {
        HTSACopy(&anchor->content_type, format->name);
        HTSACopy(&anchor->content_encoding, myEncoding->name);
        format = HTAtom_for("www/compressed");
      }
      else
      {
        zzfp = fp;
        fp = 0;
        if ( WWW_TraceFlag[0] )
        {
          v12 = TraceFP();
          fprintf(v12, "HTLoadFile: zzopen of `%s' gives %p\n", localname, zzfp);
        }
        internal_decompress = cftDeflate;
      }
    }
    else
    {
      fclose(fp);
      gzfp = (gzFile)gzopen64(localname, "rb");
      if ( WWW_TraceFlag[0] )
      {
        v11 = TraceFP();
        fprintf(v11, "HTLoadFile: gzopen of `%s' gives %p\n", localname, gzfp);
      }
      internal_decompress = cftGzip;
    }
  }
  if ( internal_decompress )
  {
    if ( (unsigned int)internal_decompress <= cftGzip )
      failed_decompress = gzfp == 0;
    else
      failed_decompress = internal_decompress != cftDeflate || zzfp == 0;
    if ( failed_decompress )
    {
      v15 = gettext("Could not open file for decompression!");
      *statusp = HTLoadError(0, 1, v15);
    }
    else
    {
      sugfname = 0;
      if ( anchor->SugFname )
      {
        HTSACopy(&sugfname, anchor->SugFname);
      }
      else
      {
        anchor_path = HTParse(anchor->address, &entry, 5);
        HTUnEscape(anchor_path);
        lastslash = strrchr(anchor_path, 47);
        if ( lastslash )
          HTSACopy(&sugfname, lastslash + 1);
        if ( anchor_path )
          free(anchor_path);
      }
      if ( anchor->content_encoding )
      {
        free(anchor->content_encoding);
        anchor->content_encoding = 0;
      }
      if ( sugfname && *sugfname )
        HTCheckFnameForCompression(&sugfname, anchor, 1);
      if ( sugfname && *sugfname )
        HTSACopy(&anchor->SugFname, sugfname);
      if ( sugfname )
      {
        free(sugfname);
        sugfname = 0;
      }
      if ( gzfp )
      {
        *statusp = HTParseGzFile(format, format_out, anchor, gzfp, (HTStream_5 *)sink);
      }
      else if ( zzfp )
      {
        *statusp = HTParseZzFile(format, format_out, anchor, zzfp, (HTStream_5 *)sink);
      }
    }
  }
  else
  {
    *statusp = HTParseFile(format, format_out, anchor, fp, (HTStream_5 *)sink);
    fclose(fp);
  }
  return 1;
}
// 810B06F: conditional instruction was optimized away because %internal_decompress.4!=0
// 804A924: using guessed type int __cdecl gzopen64(_DWORD, _DWORD);
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0810B2B2) --------------------------------------------------------
int __cdecl HTLoadFile(const char *addr, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink)
{
  char *v4; // eax
  size_t v5; // eax
  unsigned int v6; // eax
  char *name; // ebx
  FILE *v8; // eax
  char *v9; // ebx
  FILE *v10; // eax
  char *v11; // ebx
  FILE *v12; // eax
  char *v13; // ebx
  FILE *v14; // eax
  char *v15; // eax
  int v16; // ebx
  FILE *v17; // edx
  char *v19; // [esp+8h] [ebp-180h]
  char *v20; // [esp+8h] [ebp-180h]
  char *v21; // [esp+8h] [ebp-180h]
  char *v22; // [esp+8h] [ebp-180h]
  char *v23; // [esp+8h] [ebp-180h]
  char *v24; // [esp+8h] [ebp-180h]
  double v26; // [esp+40h] [ebp-148h]
  stat file_info; // [esp+50h] [ebp-138h] BYREF
  stat dir_info; // [esp+B0h] [ebp-D8h] BYREF
  char *enable_file_name; // [esp+110h] [ebp-78h] BYREF
  DIR *dp_0; // [esp+114h] [ebp-74h]
  CompressFileType cft; // [esp+118h] [ebp-70h]
  const char *atomname; // [esp+11Ch] [ebp-6Ch]
  int rootlen; // [esp+120h] [ebp-68h] BYREF
  float value; // [esp+124h] [ebp-64h]
  float filevalue; // [esp+128h] [ebp-60h]
  HTFormat rep; // [esp+12Ch] [ebp-5Ch]
  HTAtom *enc; // [esp+130h] [ebp-58h] BYREF
  unsigned int baselen; // [esp+134h] [ebp-54h]
  char *base; // [esp+138h] [ebp-50h]
  char *best_name; // [esp+13Ch] [ebp-4Ch] BYREF
  HTAtom *best_enc; // [esp+140h] [ebp-48h]
  HTFormat best_rep; // [esp+144h] [ebp-44h]
  float best; // [esp+148h] [ebp-40h]
  dirent *dirbuf; // [esp+14Ch] [ebp-3Ch]
  DIR *dp; // [esp+150h] [ebp-38h]
  char *localname; // [esp+154h] [ebp-34h] BYREF
  int default_UCLYhndl; // [esp+158h] [ebp-30h]
  char *ftp_newhost; // [esp+15Ch] [ebp-2Ch]
  int status; // [esp+160h] [ebp-28h] BYREF
  HTAtom *myEncoding; // [esp+164h] [ebp-24h] BYREF
  char *newname; // [esp+168h] [ebp-20h] BYREF
  char *nodename; // [esp+16Ch] [ebp-1Ch]
  HTFormat format; // [esp+170h] [ebp-18h]
  char *acc_method; // [esp+174h] [ebp-14h]
  char *filename; // [esp+178h] [ebp-10h]
  BOOLEAN forget_multi; // [esp+17Fh] [ebp-9h]

  filename = 0;
  acc_method = 0;
  nodename = 0;
  newname = 0;
  myEncoding = 0;
  status = -1;
  HTSACopy(&newname, addr);
  filename = HTParse(newname, &entry, 5);
  nodename = HTParse(newname, &entry, 8);
  acc_method = HTParse(newname, &entry, 16);
  if ( !strcmp("ftp", acc_method) || strcmp("localhost", nodename) && (v4 = HTHostName(), strcmp(nodename, v4)) )
  {
    status = -1;
    if ( newname )
    {
      free(newname);
      newname = 0;
    }
    if ( filename )
    {
      free(filename);
      filename = 0;
    }
    if ( nodename )
    {
      free(nodename);
      nodename = 0;
    }
    if ( acc_method )
    {
      free(acc_method);
      acc_method = 0;
    }
    ftp_newhost = HTParse(addr, &entry, 8);
    if ( strcmp(ftp_lasthost, ftp_newhost) )
      ftp_local_passive[0] = ftp_passive;
    status = HTFTPLoad(addr, anchor, format_out, sink);
    if ( ftp_passive == ftp_local_passive[0] && (status > 399 || status < 0) )
    {
      ftp_local_passive[0] = ftp_passive == 0;
      status = HTFTPLoad(addr, anchor, format_out, sink);
    }
    free(ftp_lasthost);
    ftp_lasthost = ftp_newhost;
    return status;
  }
  if ( newname )
  {
    free(newname);
    newname = 0;
  }
  if ( acc_method )
  {
    free(acc_method);
    acc_method = 0;
  }
  if ( anchor->content_type && anchor->content_encoding )
  {
    format = HTAtom_for(anchor->content_type);
    myEncoding = HTAtom_for(anchor->content_encoding);
  }
  else
  {
    default_UCLYhndl = UCLYhndl_HTFile_for_unspec;
    if ( force_old_UCLYhndl_on_reload[0] )
    {
      force_old_UCLYhndl_on_reload[0] = 0;
      default_UCLYhndl = forced_UCLYhdnl;
    }
    format = HTFileFormat(filename, &myEncoding, 0);
    format = HTCharsetFormat(format, anchor, default_UCLYhndl);
  }
  if ( filename )
  {
    free(filename);
    filename = 0;
  }
  if ( HTSecure )
  {
LABEL_127:
    v15 = HTHostName();
    if ( !strcmp(nodename, v15) )
    {
      if ( nodename )
      {
        free(nodename);
        nodename = 0;
      }
      if ( WWW_TraceFlag[0] )
      {
        v16 = *__errno_location();
        v17 = TraceFP();
        fprintf(v17, "Can't open `%s', errno=%d\n", addr, v16);
      }
      v24 = gettext("Can't access requested file.");
      return HTLoadError((HTStream_0 *)sink, 403, v24);
    }
    else
    {
      status = -1;
      if ( nodename )
      {
        free(nodename);
        nodename = 0;
      }
      if ( strncmp(addr, "file://localhost", 0x10u) )
        return HTFTPLoad(addr, anchor, format_out, sink);
      return status;
    }
  }
  localname = HTnameOfFile_WWW(addr, 1, 1);
  if ( strlen(localname) > 6 )
  {
    v5 = strlen(localname);
    if ( !strcmp(&localname[v5 - 6], ".multi") )
    {
      dp = 0;
      forget_multi = 0;
      best = -1.0e20;
      best_rep = 0;
      best_enc = 0;
      best_name = 0;
      base = strrchr(localname, 47);
      baselen = 0;
      if ( base && base != localname )
      {
        *base++ = 0;
        baselen = strlen(base) - 6;
        base[baselen] = 0;
        dp = opendir(localname);
      }
      else
      {
        forget_multi = 1;
      }
      if ( forget_multi || !dp )
      {
        if ( localname )
        {
          free(localname);
          localname = 0;
        }
        if ( nodename )
        {
          free(nodename);
          nodename = 0;
        }
        v19 = gettext("Multiformat: directory scan failed.");
        return HTLoadError((HTStream_0 *)sink, 500, v19);
      }
      while ( 1 )
      {
        dirbuf = (dirent *)readdir64(dp);
        if ( !dirbuf )
          break;
        if ( dirbuf->d_ino )
        {
          v6 = strlen(dirbuf->d_name);
          if ( v6 > baselen && !strncmp(dirbuf->d_name, base, baselen) )
          {
            rep = HTFileFormat(dirbuf->d_name, &enc, 0);
            filevalue = HTFileValue(dirbuf->d_name);
            value = HTStackValue(rep, format_out, filevalue, 0);
            if ( value <= 0.0 )
            {
              rootlen = 0;
              atomname = 0;
              cft = HTCompressFileType(dirbuf->d_name, ".", &rootlen);
              enable_file_name = 0;
              enc = 0;
              if ( cft )
              {
                HTSACopy(&enable_file_name, dirbuf->d_name);
                enable_file_name[rootlen] = 0;
                format = HTFileFormat(enable_file_name, 0, 0);
                if ( enable_file_name )
                {
                  free(enable_file_name);
                  enable_file_name = 0;
                }
                value = HTStackValue(format, format_out, filevalue, 0);
                if ( cft == cftGzip )
                {
                  atomname = "application/x-gzip";
                }
                else if ( (unsigned int)cft > cftGzip )
                {
                  if ( cft == cftBzip2 )
                  {
                    atomname = "application/x-bzip2";
                  }
                  else if ( cft == cftDeflate )
                  {
                    atomname = "application/x-deflate";
                  }
                }
                else if ( cft == cftCompress )
                {
                  atomname = "application/x-compressed";
                }
              }
              if ( atomname )
              {
                value = HTStackValue(format, format_out, filevalue, 0);
                if ( value <= 0.0 )
                {
                  format = HTAtom_for(atomname);
                  value = HTStackValue(format, format_out, filevalue, 0);
                }
                if ( value <= 0.0 )
                {
                  format = HTAtom_for("www/compressed");
                  value = HTStackValue(format, format_out, filevalue, 0);
                }
              }
            }
            if ( value < -1.0e20 )
            {
              if ( WWW_TraceFlag[0] )
              {
                v26 = value;
                name = rep->name;
                v8 = TraceFP();
                fprintf(v8, "HTLoadFile: value of presenting %s is %f\n", name, v26);
              }
              if ( value > (long double)best )
              {
                best_rep = rep;
                best_enc = enc;
                best = value;
                HTSACopy(&best_name, dirbuf->d_name);
              }
            }
          }
        }
      }
      closedir(dp);
      if ( !best_rep )
      {
        if ( localname )
        {
          free(localname);
          localname = 0;
        }
        if ( nodename )
        {
          free(nodename);
          nodename = 0;
        }
        v20 = gettext("Could not find suitable representation for transmission.");
        return HTLoadError((HTStream_0 *)sink, 403, v20);
      }
      format = best_rep;
      myEncoding = best_enc;
      *(base - 1) = 47;
      *base = 0;
      HTSACat(&localname, best_name);
      if ( best_name )
      {
        free(best_name);
        best_name = 0;
      }
    }
  }
  if ( HTStat(localname, &dir_info) == -1 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v9 = localname;
      v10 = TraceFP();
      fprintf(v10, "HTLoadFile: can't stat %s\n", v9);
    }
LABEL_119:
    if ( decompressAndParse(anchor, format_out, sink, nodename, localname, myEncoding, format, &status) )
    {
      if ( nodename )
      {
        free(nodename);
        nodename = 0;
      }
      if ( localname )
      {
        free(localname);
        localname = 0;
      }
      return status;
    }
    if ( localname )
    {
      free(localname);
      localname = 0;
    }
    goto LABEL_127;
  }
  if ( (dir_info.st_mode & 0xF000) != 0x4000 )
  {
    if ( (dir_info.st_mode & 0xF000) == 0x8000 && dir_info.st_size <= 0x7FFFFFFF )
      anchor->content_length = dir_info.st_size;
    goto LABEL_119;
  }
  if ( WWW_TraceFlag[0] )
  {
    v11 = localname;
    v12 = TraceFP();
    fprintf(v12, "%s is a directory\n", v11);
  }
  if ( HTDirAccess )
  {
    if ( HTDirAccess == 1
      && (enable_file_name = 0,
          HTSprintf0(&enable_file_name, "%s/%s", localname, ".www_browsable"),
          stat64((int)enable_file_name, (int)&file_info)) )
    {
      if ( localname )
      {
        free(localname);
        localname = 0;
      }
      if ( nodename )
      {
        free(nodename);
        nodename = 0;
      }
      if ( enable_file_name )
      {
        free(enable_file_name);
        enable_file_name = 0;
      }
      v22 = gettext("Selective access is not enabled for this directory");
      return HTLoadError((HTStream_0 *)sink, 403, v22);
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v13 = localname;
        v14 = TraceFP();
        fprintf(v14, "Opening directory %s\n", v13);
      }
      dp_0 = opendir(localname);
      if ( dp_0 )
      {
        status = print_local_dir(dp_0, localname, anchor, format_out, sink);
        closedir(dp_0);
        if ( localname )
        {
          free(localname);
          localname = 0;
        }
        if ( nodename )
        {
          free(nodename);
          nodename = 0;
        }
        return status;
      }
      else
      {
        if ( localname )
        {
          free(localname);
          localname = 0;
        }
        if ( nodename )
        {
          free(nodename);
          nodename = 0;
        }
        v23 = gettext("This directory is not readable.");
        return HTLoadError((HTStream_0 *)sink, 403, v23);
      }
    }
  }
  else
  {
    if ( localname )
    {
      free(localname);
      localname = 0;
    }
    if ( nodename )
    {
      free(nodename);
      nodename = 0;
    }
    v21 = gettext("Directory browsing is not allowed.");
    return HTLoadError((HTStream_0 *)sink, 403, v21);
  }
}
// 804AE14: using guessed type int __cdecl readdir64(_DWORD);

//----- (0810BFC9) --------------------------------------------------------
const char *__cdecl HTGetProgramPath(ProgramPaths code)
{
  const char *result; // [esp+Ch] [ebp-4h]

  result = 0;
  if ( code && (unsigned int)code <= ppZIP_0 )
    return program_paths[code];
  return result;
}

//----- (0810BFF4) --------------------------------------------------------
void __cdecl HTSetProgramPath(ProgramPaths code, const char *path)
{
  const char *v2; // [esp+4h] [ebp-4h]

  if ( code && (unsigned int)code <= ppZIP_0 )
  {
    if ( path && *path )
      v2 = path;
    else
      v2 = 0;
    program_paths[code] = v2;
  }
}

//----- (0810C03A) --------------------------------------------------------
void HTInitProgramPaths()
{
  char *test; // [esp+8h] [ebp-10h]
  const char *path; // [esp+Ch] [ebp-Ch]
  int n; // [esp+10h] [ebp-8h]

  for ( n = 1; n <= 23; ++n )
  {
    switch ( n )
    {
      case 1:
        path = "/bin/bzip2";
        break;
      case 3:
        path = "/usr/bin/compress";
        break;
      case 6:
        path = "/bin/gzip";
        break;
      case 8:
        path = "/usr/bin/install";
        break;
      case 10:
        path = "/bin/mv";
        break;
      case 11:
        path = "/usr/bin/rlogin";
        break;
      case 12:
        path = "/bin/rm";
        break;
      case 15:
        path = "/bin/tar";
        break;
      case 16:
        path = "/usr/bin/telnet";
        break;
      case 19:
        path = "/bin/gunzip";
        break;
      case 20:
        path = "/usr/bin/unzip";
        break;
      case 21:
        path = "/usr/bin/uudecode";
        break;
      case 22:
        path = "/bin/zcat";
        break;
      case 23:
        path = "/usr/bin/zip";
        break;
      default:
        path = 0;
        break;
    }
    test = (char *)HTGetProgramPath((ProgramPaths)n);
    if ( test )
    {
      if ( test != path )
        free(test);
    }
    HTSetProgramPath((ProgramPaths)n, path);
  }
}

//----- (0810C138) --------------------------------------------------------
HTBTree *__cdecl HTBTree_new(HTComparer comp)
{
  HTBTree *tree; // [esp+14h] [ebp-4h]

  tree = (HTBTree *)malloc(8u);
  if ( !tree )
    outofmem("../../../WWW/Library/Implementation/HTBTree.c", "HTBTree_new");
  tree->compare = comp;
  tree->top = 0;
  return tree;
}

//----- (0810C17E) --------------------------------------------------------
void __cdecl HTBTElement_free(HTBTElement *element)
{
  if ( element )
  {
    if ( element->left )
      HTBTElement_free(element->left);
    if ( element->right )
      HTBTElement_free(element->right);
    free(element);
  }
}
// 810C1BE: conditional instruction was optimized away because %element.4!=0

//----- (0810C1D4) --------------------------------------------------------
void __cdecl HTBTree_free(HTBTree *tree)
{
  HTBTElement_free(tree->top);
  if ( tree )
    free(tree);
}

//----- (0810C202) --------------------------------------------------------
void __cdecl HTBTElementAndObject_free(HTBTElement *element)
{
  if ( element )
  {
    if ( element->left )
      HTBTElementAndObject_free(element->left);
    if ( element->right )
      HTBTElementAndObject_free(element->right);
    if ( element->object )
    {
      free(element->object);
      element->object = 0;
    }
    free(element);
  }
}
// 810C261: conditional instruction was optimized away because %element.4!=0

//----- (0810C277) --------------------------------------------------------
void __cdecl HTBTreeAndObject_free(HTBTree *tree)
{
  HTBTElementAndObject_free(tree->top);
  if ( tree )
    free(tree);
}

//----- (0810C2A5) --------------------------------------------------------
void *__cdecl HTBTree_search(HTBTree *tree, void *object)
{
  int res; // [esp+20h] [ebp-8h]
  _HTBTree_element *cur; // [esp+24h] [ebp-4h]

  cur = tree->top;
  while ( cur )
  {
    res = tree->compare(object, cur->object);
    if ( !res )
      return cur->object;
    if ( res >= 0 )
    {
      if ( res > 0 )
        cur = cur->right;
    }
    else
    {
      cur = cur->left;
    }
  }
  return 0;
}

//----- (0810C311) --------------------------------------------------------
void __cdecl HTBTree_add(HTBTree *tree, void *object)
{
  int left_depth; // [esp+Ch] [ebp-8Ch]
  int right_depth; // [esp+14h] [ebp-84h]
  int v4; // [esp+1Ch] [ebp-7Ch]
  int v5; // [esp+24h] [ebp-74h]
  int v6; // [esp+2Ch] [ebp-6Ch]
  int v7; // [esp+34h] [ebp-64h]
  int v8; // [esp+3Ch] [ebp-5Ch]
  int v9; // [esp+44h] [ebp-54h]
  int v10; // [esp+4Ch] [ebp-4Ch]
  int v11; // [esp+54h] [ebp-44h]
  int v12; // [esp+5Ch] [ebp-3Ch]
  int v13; // [esp+64h] [ebp-34h]
  int corrections; // [esp+78h] [ebp-20h]
  int depth2; // [esp+7Ch] [ebp-1Ch]
  int depth2a; // [esp+7Ch] [ebp-1Ch]
  int depth2b; // [esp+7Ch] [ebp-1Ch]
  int depth; // [esp+80h] [ebp-18h]
  int deptha; // [esp+80h] [ebp-18h]
  int depthb; // [esp+80h] [ebp-18h]
  HTBTElement *father_of_forefather; // [esp+84h] [ebp-14h]
  HTBTElement *father_of_forefathera; // [esp+84h] [ebp-14h]
  HTBTElement *father_of_forefatherb; // [esp+84h] [ebp-14h]
  HTBTElement *father_of_forefatherc; // [esp+84h] [ebp-14h]
  HTBTElement *father_of_forefatherd; // [esp+84h] [ebp-14h]
  HTBTElement *forefather_of_element; // [esp+88h] [ebp-10h]
  HTBTElement *forefather_of_elementa; // [esp+88h] [ebp-10h]
  HTBTElement *forefather_of_elementb; // [esp+88h] [ebp-10h]
  HTBTElement *added_element; // [esp+8Ch] [ebp-Ch]
  HTBTElement *added_elementa; // [esp+8Ch] [ebp-Ch]
  HTBTElement *added_elementb; // [esp+8Ch] [ebp-Ch]
  _HTBTree_element *father_of_element; // [esp+90h] [ebp-8h]
  BOOLEAN first_time_0; // [esp+94h] [ebp-4h]
  BOOLEAN first_time; // [esp+95h] [ebp-3h]
  BOOLEAN top_found; // [esp+96h] [ebp-2h]
  BOOLEAN father_found; // [esp+97h] [ebp-1h]

  if ( tree->top )
  {
    father_found = 1;
    father_of_element = tree->top;
    added_element = 0;
    while ( father_found )
    {
      if ( tree->compare(object, father_of_element->object) >= 0 )
      {
        if ( father_of_element->right )
        {
          father_of_element = father_of_element->right;
        }
        else
        {
          father_found = 0;
          father_of_element->right = (_HTBTree_element *)malloc(0x18u);
          if ( !father_of_element->right )
            outofmem("../../../WWW/Library/Implementation/HTBTree.c", "HTBTree_add");
          added_element = father_of_element->right;
          added_element->up = father_of_element;
          added_element->object = object;
          added_element->left = 0;
          added_element->left_depth = 0;
          added_element->right = 0;
          added_element->right_depth = 0;
        }
      }
      else if ( father_of_element->left )
      {
        father_of_element = father_of_element->left;
      }
      else
      {
        father_found = 0;
        father_of_element->left = (_HTBTree_element *)malloc(0x18u);
        if ( !father_of_element->left )
          outofmem("../../../WWW/Library/Implementation/HTBTree.c", "HTBTree_add");
        added_element = father_of_element->left;
        added_element->up = father_of_element;
        added_element->object = object;
        added_element->left = 0;
        added_element->left_depth = 0;
        added_element->right = 0;
        added_element->right_depth = 0;
      }
    }
    father_of_forefather = father_of_element;
    forefather_of_element = added_element;
    do
    {
      if ( father_of_forefather->left == forefather_of_element )
      {
        depth = father_of_forefather->left_depth;
        left_depth = forefather_of_element->left_depth;
        if ( left_depth < forefather_of_element->right_depth )
          left_depth = forefather_of_element->right_depth;
        father_of_forefather->left_depth = left_depth + 1;
        depth2 = father_of_forefather->left_depth;
      }
      else
      {
        depth = father_of_forefather->right_depth;
        right_depth = forefather_of_element->left_depth;
        if ( right_depth < forefather_of_element->right_depth )
          right_depth = forefather_of_element->right_depth;
        father_of_forefather->right_depth = right_depth + 1;
        depth2 = father_of_forefather->right_depth;
      }
      forefather_of_element = father_of_forefather;
      father_of_forefather = father_of_forefather->up;
    }
    while ( depth != depth2 && father_of_forefather );
    top_found = 1;
    corrections = 0;
    while ( top_found && corrections <= 6 )
    {
      if ( father_of_element->left_depth - father_of_element->right_depth < -1
        || father_of_element->left_depth - father_of_element->right_depth > 1 )
      {
        ++corrections;
        if ( !father_of_element->left
          && !father_of_element->right->right
          && !father_of_element->right->left->left
          && !father_of_element->right->left->right )
        {
          corrections = 7;
        }
        if ( !father_of_element->right
          && !father_of_element->left->left
          && !father_of_element->left->right->right
          && !father_of_element->left->right->left )
        {
          corrections = 7;
        }
        if ( father_of_element->left_depth <= father_of_element->right_depth )
        {
          added_elementb = father_of_element->right;
          father_of_element->right_depth = added_elementb->left_depth;
          v9 = father_of_element->left_depth;
          if ( v9 < father_of_element->right_depth )
            v9 = father_of_element->right_depth;
          added_elementb->left_depth = v9 + 1;
          if ( father_of_element->up )
          {
            father_of_forefatherc = father_of_element->up;
            forefather_of_elementb = added_elementb;
            first_time_0 = 1;
            do
            {
              if ( father_of_forefatherc->left == forefather_of_elementb->up )
              {
                depthb = father_of_forefatherc->left_depth;
                if ( first_time_0 )
                {
                  v10 = forefather_of_elementb->right_depth;
                  if ( v10 < forefather_of_elementb->left_depth )
                    v10 = forefather_of_elementb->left_depth;
                  father_of_forefatherc->left_depth = v10 + 1;
                  first_time_0 = 0;
                }
                else
                {
                  v11 = forefather_of_elementb->up->right_depth;
                  if ( v11 < forefather_of_elementb->up->left_depth )
                    v11 = forefather_of_elementb->up->left_depth;
                  father_of_forefatherc->left_depth = v11 + 1;
                }
                depth2b = father_of_forefatherc->left_depth;
              }
              else
              {
                depthb = father_of_forefatherc->right_depth;
                if ( first_time_0 )
                {
                  v12 = forefather_of_elementb->right_depth;
                  if ( v12 < forefather_of_elementb->left_depth )
                    v12 = forefather_of_elementb->left_depth;
                  father_of_forefatherc->right_depth = v12 + 1;
                  first_time_0 = 0;
                }
                else
                {
                  v13 = forefather_of_elementb->up->right_depth;
                  if ( v13 < forefather_of_elementb->up->left_depth )
                    v13 = forefather_of_elementb->up->left_depth;
                  father_of_forefatherc->right_depth = v13 + 1;
                }
                depth2b = father_of_forefatherc->right_depth;
              }
              father_of_forefatherc = father_of_forefatherc->up;
              forefather_of_elementb = forefather_of_elementb->up;
            }
            while ( depthb != depth2b && father_of_forefatherc );
            father_of_forefatherd = father_of_element->up;
            if ( father_of_forefatherd->left == father_of_element )
            {
              father_of_forefatherd->left = added_elementb;
              father_of_element->right = added_elementb->left;
              added_elementb->left = father_of_element;
            }
            if ( father_of_forefatherd->right == father_of_element )
            {
              father_of_forefatherd->right = added_elementb;
              father_of_element->right = added_elementb->left;
              added_elementb->left = father_of_element;
            }
            added_elementb->up = father_of_forefatherd;
          }
          else
          {
            added_elementb->up = 0;
            father_of_element->right = added_elementb->left;
            added_elementb->left = father_of_element;
          }
          father_of_element->up = added_elementb;
          if ( father_of_element->right )
            father_of_element->right->up = father_of_element;
        }
        else
        {
          added_elementa = father_of_element->left;
          father_of_element->left_depth = added_elementa->right_depth;
          v4 = father_of_element->left_depth;
          if ( v4 < father_of_element->right_depth )
            v4 = father_of_element->right_depth;
          added_elementa->right_depth = v4 + 1;
          if ( father_of_element->up )
          {
            father_of_forefathera = father_of_element->up;
            forefather_of_elementa = added_elementa;
            first_time = 1;
            do
            {
              if ( father_of_forefathera->left == forefather_of_elementa->up )
              {
                deptha = father_of_forefathera->left_depth;
                if ( first_time )
                {
                  v5 = forefather_of_elementa->right_depth;
                  if ( v5 < forefather_of_elementa->left_depth )
                    v5 = forefather_of_elementa->left_depth;
                  father_of_forefathera->left_depth = v5 + 1;
                  first_time = 0;
                }
                else
                {
                  v6 = forefather_of_elementa->up->right_depth;
                  if ( v6 < forefather_of_elementa->up->left_depth )
                    v6 = forefather_of_elementa->up->left_depth;
                  father_of_forefathera->left_depth = v6 + 1;
                }
                depth2a = father_of_forefathera->left_depth;
              }
              else
              {
                deptha = father_of_forefathera->right_depth;
                if ( first_time )
                {
                  v7 = forefather_of_elementa->right_depth;
                  if ( v7 < forefather_of_elementa->left_depth )
                    v7 = forefather_of_elementa->left_depth;
                  father_of_forefathera->right_depth = v7 + 1;
                  first_time = 0;
                }
                else
                {
                  v8 = forefather_of_elementa->up->right_depth;
                  if ( v8 < forefather_of_elementa->up->left_depth )
                    v8 = forefather_of_elementa->up->left_depth;
                  father_of_forefathera->right_depth = v8 + 1;
                }
                depth2a = father_of_forefathera->right_depth;
              }
              forefather_of_elementa = forefather_of_elementa->up;
              father_of_forefathera = father_of_forefathera->up;
            }
            while ( deptha != depth2a && father_of_forefathera );
            father_of_forefatherb = father_of_element->up;
            if ( father_of_forefatherb->left == father_of_element )
            {
              father_of_forefatherb->left = added_elementa;
              father_of_element->left = added_elementa->right;
              added_elementa->right = father_of_element;
            }
            if ( father_of_forefatherb->right == father_of_element )
            {
              father_of_forefatherb->right = added_elementa;
              father_of_element->left = added_elementa->right;
              added_elementa->right = father_of_element;
            }
            added_elementa->up = father_of_forefatherb;
          }
          else
          {
            added_elementa->up = 0;
            father_of_element->left = added_elementa->right;
            added_elementa->right = father_of_element;
          }
          father_of_element->up = added_elementa;
          if ( father_of_element->left )
            father_of_element->left->up = father_of_element;
        }
      }
      else if ( father_of_element->up )
      {
        father_of_element = father_of_element->up;
      }
      else
      {
        top_found = 0;
      }
    }
    while ( father_of_element->up )
      father_of_element = father_of_element->up;
    tree->top = father_of_element;
  }
  else
  {
    tree->top = (_HTBTree_element *)malloc(0x18u);
    if ( !tree->top )
      outofmem("../../../WWW/Library/Implementation/HTBTree.c", "HTBTree_add");
    tree->top->up = 0;
    tree->top->object = object;
    tree->top->left = 0;
    tree->top->left_depth = 0;
    tree->top->right = 0;
    tree->top->right_depth = 0;
  }
}

//----- (0810CB95) --------------------------------------------------------
HTBTElement *__cdecl HTBTree_next(HTBTree *tree, HTBTElement *ele)
{
  _HTBTree_element *father_of_forefather; // [esp+8h] [ebp-8h]
  _HTBTree_element *father_of_element; // [esp+Ch] [ebp-4h]
  HTBTElement *father_of_elementa; // [esp+Ch] [ebp-4h]

  if ( ele )
  {
    father_of_elementa = ele;
    if ( ele->right )
    {
      for ( father_of_element = ele->right; father_of_element->left; father_of_element = father_of_element->left )
        ;
    }
    else
    {
      for ( father_of_forefather = ele->up;
            father_of_forefather && father_of_forefather->right == father_of_elementa;
            father_of_forefather = father_of_forefather->up )
      {
        father_of_elementa = father_of_forefather;
      }
      return father_of_forefather;
    }
  }
  else
  {
    father_of_element = tree->top;
    if ( father_of_element )
    {
      while ( father_of_element->left )
        father_of_element = father_of_element->left;
    }
  }
  return father_of_element;
}

//----- (0810CC30) --------------------------------------------------------
char *__cdecl HTVMS_name(const char *nn, const char *fn)
{
  size_t v2; // eax
  size_t v3; // eax
  size_t v4; // eax
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  char *p_0; // [esp+34h] [ebp-24h]
  char *r; // [esp+38h] [ebp-20h]
  const char *q; // [esp+3Ch] [ebp-1Ch]
  const char *p; // [esp+40h] [ebp-18h]
  char *hostname; // [esp+44h] [ebp-14h]
  char *last; // [esp+48h] [ebp-10h]
  char *second; // [esp+4Ch] [ebp-Ch]
  char *nodename; // [esp+50h] [ebp-8h]
  char *filename; // [esp+54h] [ebp-4h]

  v2 = strlen(fn);
  filename = (char *)malloc(v2 + 1);
  v3 = strlen(nn);
  nodename = (char *)malloc(v3 + 3);
  hostname = HTHostName();
  if ( !filename || !nodename )
    outofmem("../../../WWW/Library/Implementation/HTFTP.c", "HTVMSname");
  strcpy(filename, fn);
  memcpy(nodename, &::nn, sizeof(char));
  if ( strncmp(nn, "localhost", 9u) )
  {
    p = hostname;
    for ( q = nn; *p && *p != 46 && *q && *q != 46; ++q )
    {
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x200) != 0 )
        v6 = toupper(*(unsigned __int8 *)p);
      else
        v6 = *(unsigned __int8 *)p;
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)q] & 0x200) != 0 )
        v7 = toupper(*(unsigned __int8 *)q);
      else
        v7 = *(unsigned __int8 *)q;
      if ( v6 != v7 )
      {
        strcpy(nodename, nn);
        r = strchr(nodename, 46);
        if ( r )
          *r = 0;
        v4 = strlen(nodename);
        memcpy(&nodename[v4], "::", 3u);
        break;
      }
      ++p;
    }
  }
  second = strchr(filename + 1, 47);
  last = strrchr(filename, 47);
  if ( second )
  {
    if ( second == last )
    {
      *second = 0;
      HTSprintf0(&vmsname_10181, "%s%s:%s", nodename, filename + 1, second + 1);
      *second = 47;
    }
    else
    {
      *second = 0;
      *last = 0;
      HTSprintf0(&vmsname_10181, "%s%s:[%s]%s", nodename, filename + 1, second + 1, last + 1);
      *last = 47;
      *second = *last;
      for ( p_0 = strchr(vmsname_10181, 91); *p_0 != 93; ++p_0 )
      {
        if ( *p_0 == 47 )
          *p_0 = 46;
      }
    }
  }
  else
  {
    HTSprintf0(&vmsname_10181, "%s%s", nodename, filename + 1);
  }
  free(nodename);
  free(filename);
  return vmsname_10181;
}
// 810CF4E: conditional instruction was optimized away because %nodename.4!=0
// 810CF66: conditional instruction was optimized away because %filename.4!=0

//----- (0810CF81) --------------------------------------------------------
int next_data_char()
{
  int status; // [esp+24h] [ebp-4h]

  if ( data_read_pointer < data_write_pointer )
    return (unsigned __int8)*data_read_pointer++;
  status = HTDoRead(data_soc, data_buffer, 0x800u);
  if ( status == -29998 )
    interrupted_in_next_data_char = 1;
  if ( status > 0 )
  {
    data_write_pointer = (char *)(status + 136001376);
    data_read_pointer = data_buffer;
    return (unsigned __int8)*data_read_pointer++;
  }
  return -1;
}

//----- (0810D00B) --------------------------------------------------------
int __cdecl close_connection(connection *con)
{
  int socket; // ebx
  FILE *v2; // eax
  int *v3; // eax
  char *v4; // ebx
  FILE *v5; // eax
  int status; // [esp+1Ch] [ebp-Ch]
  connection *scan; // [esp+20h] [ebp-8h]

  if ( WWW_TraceFlag[0] )
  {
    socket = con->socket;
    v2 = TraceFP();
    fprintf(v2, "HTFTP: Closing control socket %d\n", socket);
  }
  status = close(con->socket);
  if ( WWW_TraceFlag[0] && status && WWW_TraceFlag[0] )
  {
    v3 = __errno_location();
    v4 = strerror(*v3);
    v5 = TraceFP();
    fprintf(v5, "HTFTP:close_connection: %s", v4);
  }
  con->socket = -1;
  if ( connections == con )
  {
    connections = con->next;
    return status;
  }
  else
  {
    for ( scan = connections; ; scan = scan->next )
    {
      if ( !scan )
        return -1;
      if ( scan->next == con )
        break;
    }
    scan->next = con->next;
    if ( control == con )
      control = 0;
    return status;
  }
}

//----- (0810D115) --------------------------------------------------------
void init_help_message_cache()
{
  if ( help_message_buffer )
  {
    free(help_message_buffer);
    help_message_buffer = 0;
  }
}

//----- (0810D13D) --------------------------------------------------------
void __cdecl help_message_cache_add(char *string)
{
  FILE *v1; // eax

  if ( help_message_buffer )
    HTSACat(&help_message_buffer, string);
  else
    HTSACopy(&help_message_buffer, string);
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "Adding message to help cache: %s\n", string);
  }
}

//----- (0810D19F) --------------------------------------------------------
char *help_message_cache_non_empty()
{
  return help_message_buffer;
}

//----- (0810D1A9) --------------------------------------------------------
char *help_message_cache_contents()
{
  return help_message_buffer;
}

//----- (0810D1B3) --------------------------------------------------------
int __cdecl write_cmd(const char *cmd)
{
  FILE *v1; // eax
  FILE *v2; // eax
  int socket; // ebx
  FILE *v4; // edx
  size_t v6; // [esp+8h] [ebp-20h]
  ssize_t status; // [esp+20h] [ebp-8h]

  if ( control )
  {
    if ( !cmd )
      return 1;
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "  Tx: %s", cmd);
    }
    v6 = strlen(cmd);
    status = write(control->socket, cmd, v6);
    if ( status < 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        socket = control->socket;
        v4 = TraceFP();
        fprintf(v4, "HTFTP: Error %d sending command: closing socket %d\n", status, socket);
      }
      close_connection(control);
      return status;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTFTP: No control connection set up!!\n");
    }
    return -99;
  }
}

//----- (0810D2B1) --------------------------------------------------------
BOOLEAN __cdecl find_response(HTList *list)
{
  const char *object; // [esp+14h] [ebp-14h]
  BOOLEAN result; // [esp+27h] [ebp-1h]

  result = 0;
  while ( 1 )
  {
    if ( list && (list = list->next) != 0 )
      object = (const char *)list->object;
    else
      object = 0;
    if ( !object )
      break;
    if ( LYstrstr(response_text, object) )
      return 1;
  }
  return result;
}

//----- (0810D318) --------------------------------------------------------
int __cdecl response(const char *cmd)
{
  bool v1; // al
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  int v7; // ebx
  FILE *v8; // eax
  int socket; // ebx
  FILE *v10; // eax
  int ich; // [esp+2Ch] [ebp-1Ch]
  char *p; // [esp+30h] [ebp-18h]
  int status; // [esp+34h] [ebp-14h]
  int continuation_response; // [esp+38h] [ebp-10h]
  int result; // [esp+3Ch] [ebp-Ch] BYREF
  char continuation; // [esp+43h] [ebp-5h] BYREF

  continuation_response = -1;
  status = write_cmd(cmd);
  if ( status < 0 )
    return status;
LABEL_3:
  p = response_text;
  do
  {
    ich = HTGetCharacter();
    *p = ich;
    v1 = *p++ == 10;
    if ( v1 || p == &response_text[256] )
    {
      if ( interrupted_in_htgetcharacter )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
        }
LABEL_9:
        close(control->socket);
        control->socket = -1;
        return -29998;
      }
      *p = 0;
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "    Rx: %s", response_text);
      }
      if ( !strncmp(response_text, "230-", 4u)
        || !strncmp(response_text, "250-", 4u)
        || !strncmp(response_text, "220-", 4u) )
      {
        help_message_cache_add(&response_text[4]);
      }
      sscanf(response_text, "%d%c", &result, &continuation);
      if ( continuation_response == -1 )
      {
        if ( continuation == 45 )
          continuation_response = result;
      }
      else if ( continuation_response == result && continuation == 32 )
      {
        continuation_response = -1;
      }
      if ( result == 220 )
      {
        if ( find_response(broken_ftp_retr) )
        {
          Broken_RETR = 1;
          if ( WWW_TraceFlag[0] )
          {
            v4 = TraceFP();
            fprintf(v4, "This server is broken (RETR)\n");
          }
        }
      }
      if ( result == 220 )
      {
        if ( find_response(broken_ftp_epsv) )
        {
          Broken_EPSV = 1;
          if ( WWW_TraceFlag[0] )
          {
            v5 = TraceFP();
            fprintf(v5, "This server is broken (EPSV)\n");
          }
        }
      }
      if ( continuation_response == -1 )
      {
        if ( result == 421 )
        {
          if ( WWW_TraceFlag[0] )
          {
            socket = control->socket;
            v10 = TraceFP();
            fprintf(v10, "HTFTP: They close so we close socket %d\n", socket);
          }
          close_connection(control);
          return -1;
        }
        else
        {
          if ( result == 255 && server_type == CMS_SERVER && (!strncasecomp(cmd, "CWD", 3) || !strcasecomp(cmd, "CDUP")) )
            result = 555;
          return result / 100;
        }
      }
      goto LABEL_3;
    }
    if ( interrupted_in_htgetcharacter )
    {
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "HTFTP: Interrupted in HTGetCharacter, apparently.\n");
      }
      goto LABEL_9;
    }
  }
  while ( ich != -1 );
  if ( WWW_TraceFlag[0] )
  {
    v7 = control->socket;
    v8 = TraceFP();
    fprintf(v8, "Error on rx: closing socket %d\n", v7);
  }
  memcpy(response_text, "000 *** TCP read error on response\n", 0x24u);
  close_connection(control);
  return -1;
}

//----- (0810D6DF) --------------------------------------------------------
int __cdecl send_cmd_1(const char *verb)
{
  char command[80]; // [esp+34h] [ebp-54h] BYREF
  unsigned int v3; // [esp+84h] [ebp-4h]

  v3 = __readgsdword(0x14u);
  sprintf(command, "%.*s%c%c", 76, verb, 13, 10);
  return response(command);
}

//----- (0810D749) --------------------------------------------------------
int __cdecl send_cmd_2(const char *verb, const char *param)
{
  int status; // [esp+20h] [ebp-8h]
  char *command; // [esp+24h] [ebp-4h] BYREF

  command = 0;
  HTSprintf0(&command, "%s %s%c%c", verb, param, 13, 10);
  status = response(command);
  if ( command )
  {
    free(command);
    command = 0;
  }
  return status;
}

//----- (0810D7B3) --------------------------------------------------------
int __cdecl set_mac_binary(eServerType ServerType)
{
  if ( ServerType == APPLESHARE_SERVER || ServerType == NETPRESENZ_SERVER )
    return response("MACB E\r\n") == 2;
  else
    return response("MACB\r\n") == 2;
}

//----- (0810D7FC) --------------------------------------------------------
void __cdecl get_ftp_pwd(eServerType *ServerType, BOOLEAN *UseList)
{
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  eServerType v7; // [esp+10h] [ebp-18h]
  const char *v8; // [esp+14h] [ebp-14h]
  char *cp; // [esp+24h] [ebp-4h]

  if ( response("PWD\r\n") < 0 )
    return;
  cp = strchr(&response_text[5], 34);
  if ( cp )
    *cp = 0;
  if ( *ServerType == TCPC_SERVER )
  {
    if ( response_text[5] == 47 )
      v7 = NCSA_SERVER;
    else
      v7 = TCPC_SERVER;
    *ServerType = v7;
    if ( WWW_TraceFlag[0] )
    {
      if ( *ServerType == NCSA_SERVER )
        v8 = "NCSA";
      else
        v8 = "TCPC";
      v2 = TraceFP();
      fprintf(v2, "HTFTP: Treating as %s server.\n", v8);
    }
LABEL_24:
    if ( *ServerType == NCSA_SERVER
      || *ServerType == TCPC_SERVER
      || *ServerType == PETER_LEWIS_SERVER
      || *ServerType == NETPRESENZ_SERVER )
    {
      set_mac_binary(*ServerType);
    }
    return;
  }
  if ( response_text[5] != 47 )
  {
    if ( response_text[strlen(response_text) - 1] == 93 )
    {
      *ServerType = VMS_SERVER;
      *UseList = 1;
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "HTFTP: Treating as VMS server.\n");
      }
    }
    else
    {
      *ServerType = GENERIC_SERVER;
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "HTFTP: Treating as Generic server.\n");
      }
    }
    goto LABEL_24;
  }
  if ( set_mac_binary(*ServerType) )
  {
    *ServerType = NCSA_SERVER;
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "HTFTP: Treating as NCSA server.\n");
    }
  }
  else
  {
    *ServerType = UNIX_SERVER;
    *UseList = 1;
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "HTFTP: Treating as Unix server.\n");
    }
  }
}

//----- (0810D9F0) --------------------------------------------------------
void __cdecl set_unix_dirstyle(eServerType *ServerType, BOOLEAN *UseList)
{
  FILE *v2; // eax
  const char *cp; // [esp+14h] [ebp-4h]

  if ( response("SITE DIRSTYLE\r\n") == 2 )
  {
    *UseList = 1;
    cp = strstr(&response_text[4], "MSDOS");
    if ( !cp || !strstr(cp, " off") )
      response("SITE DIRSTYLE\r\n");
  }
  else
  {
    *ServerType = GENERIC_SERVER;
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HTFTP: DIRSTYLE failed, treating as Generic server.\n");
    }
  }
}

//----- (0810DA80) --------------------------------------------------------
int __cdecl get_connection(const char *arg, HTParentAnchor *anchor)
{
  FILE *v2; // eax
  char *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  char *v6; // eax
  char *v7; // eax
  int socket; // ebx
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  char *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  FILE *v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  FILE *v22; // eax
  FILE *v23; // eax
  FILE *v24; // eax
  FILE *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  FILE *v28; // eax
  FILE *v29; // eax
  FILE *v30; // eax
  FILE *v31; // eax
  const char *param; // [esp+20h] [ebp-48h]
  char *tilde; // [esp+2Ch] [ebp-3Ch]
  char *cp_0; // [esp+30h] [ebp-38h]
  char *cp_0a; // [esp+30h] [ebp-38h]
  char *host; // [esp+34h] [ebp-34h]
  char *user; // [esp+38h] [ebp-30h] BYREF
  char *the_address; // [esp+3Ch] [ebp-2Ch]
  char *cp; // [esp+40h] [ebp-28h]
  char *pw; // [esp+44h] [ebp-24h]
  char *p2; // [esp+48h] [ebp-20h]
  char *p1; // [esp+4Ch] [ebp-1Ch]
  char *password; // [esp+50h] [ebp-18h]
  char *username; // [esp+54h] [ebp-14h]
  connection *con; // [esp+58h] [ebp-10h]
  char *command; // [esp+5Ch] [ebp-Ch] BYREF
  int status; // [esp+60h] [ebp-8h]

  command = 0;
  username = 0;
  password = 0;
  if ( firstuse_10755 )
    firstuse_10755 = 0;
  if ( control )
  {
    if ( control->socket != -1 )
      close(control->socket);
    con = control;
    control->addr = 0;
    con->binary = 0;
  }
  else
  {
    con = (connection *)calloc(1u, 0x10u);
    if ( !con )
      outofmem("../../../WWW/Library/Implementation/HTFTP.c", "get_connection");
  }
  con->socket = -1;
  if ( !arg )
    return -1;
  if ( !*arg )
    return -1;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "get_connection(%s)\n", arg);
  }
  p1 = HTParse(arg, &nn, 8);
  p2 = strrchr(p1, 64);
  pw = 0;
  if ( p2 )
  {
    username = p1;
    *p2 = 0;
    p1 = p2 + 1;
    pw = strchr(username, 58);
    if ( pw )
    {
      *pw++ = 0;
      password = HTUnEscape(pw);
    }
    if ( *username )
      HTUnEscape(username);
    if ( !password )
    {
      user = 0;
      HTSprintf0(&user, "%s@%s", username, p1);
      if ( !last_username_and_host || strcmp(user, last_username_and_host) || !user_entered_password )
      {
        HTSACopy(&last_username_and_host, user);
        v3 = gettext("Enter password for user %s@%s:");
        HTSprintf0(&user, v3, username, p1);
        if ( user_entered_password )
        {
          free(user_entered_password);
          user_entered_password = 0;
        }
        user_entered_password = HTPromptPassword(user);
      }
      password = user_entered_password;
      if ( user )
      {
        free(user);
        user = 0;
      }
    }
  }
  if ( !username && p1 )
  {
    free(p1);
    p1 = 0;
  }
  status = HTDoConnect(arg, "FTP", 21, &con->socket);
  if ( status < 0 )
  {
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "HTFTP: Interrupted on connect\n");
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "HTFTP: Unable to connect to remote host for `%s'.\n", arg);
    }
    if ( status == -29998 )
    {
      mustshow[0] = 1;
      v6 = gettext("Connection interrupted.");
      HTProgress(v6);
      status = -29999;
    }
    else
    {
      v7 = gettext("Unable to connect to FTP host.");
      HTAlert(v7);
    }
    if ( con->socket != -1 )
      close(con->socket);
    if ( username )
    {
      free(username);
      username = 0;
    }
    if ( control == con )
      control = 0;
    if ( con )
    {
      free(con);
      con = 0;
    }
    return status;
  }
  if ( WWW_TraceFlag[0] )
  {
    socket = con->socket;
    v9 = TraceFP();
    fprintf(v9, "FTP connected, socket %d  control %p\n", socket, con);
  }
  control = con;
  HTInitInput(con->socket);
  init_help_message_cache();
  status = response(0);
  if ( status == -29998 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v10 = TraceFP();
      fprintf(v10, "HTFTP: Interrupted at beginning of login.\n");
    }
LABEL_105:
    mustshow[0] = 1;
    v14 = gettext("Connection interrupted.");
    HTProgress(v14);
    close(control->socket);
    control->socket = -1;
    return -29998;
  }
  server_type = GENERIC_SERVER;
  if ( status == 2 )
  {
    if ( strlen(response_text) <= 4 )
    {
      cp = response_text;
    }
    else
    {
      cp = strstr(response_text, " awaits your command");
      if ( cp || (cp = strstr(response_text, " ready.")) != 0 )
        *cp = 0;
      cp = response_text + 4;
      if ( !strncasecomp(&response_text[4], "NetPresenz", 10) )
        server_type = NETPRESENZ_SERVER;
    }
    HTSACopy(&anchor->server, cp);
    if ( username && *username )
      param = username;
    else
      param = "anonymous";
    status = send_cmd_2("USER", param);
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v11 = TraceFP();
        fprintf(v11, "HTFTP: Interrupted while sending username.\n");
      }
      goto LABEL_105;
    }
  }
  if ( status == 3 )
  {
    if ( password )
    {
      HTSprintf0(&command, "PASS %s%c%c", password, 13, 10);
    }
    else
    {
      user = 0;
      the_address = anonftp_password;
      if ( !anonftp_password || !*the_address )
        the_address = personal_mail_address;
      if ( !the_address || !*the_address )
        the_address = LYGetEnv("USER");
      if ( !the_address || !*the_address )
        the_address = "WWWuser";
      HTSACopy(&user, the_address);
      cp_0 = strchr(user, 64);
      if ( cp_0 && (*cp_0 = 0, cp_0a = cp_0 + 1, *cp_0a) )
        host = cp_0a;
      else
        host = HTHostName();
      if ( !host || !strchr(host, 46) )
        host = (char *)&nn;
      HTSprintf0(&command, "PASS %s@%s%c%c", user, host, 13, 10);
      if ( user )
      {
        free(user);
        user = 0;
      }
    }
    status = response(command);
    if ( command )
    {
      free(command);
      command = 0;
    }
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "HTFTP: Interrupted while sending password.\n");
      }
      goto LABEL_105;
    }
  }
  if ( username )
  {
    free(username);
    username = 0;
  }
  if ( status == 3 )
  {
    status = send_cmd_1("ACCT noaccount");
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v13 = TraceFP();
        fprintf(v13, "HTFTP: Interrupted while sending password.\n");
      }
      goto LABEL_105;
    }
  }
  if ( status == 2 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v16 = TraceFP();
      fprintf(v16, "HTFTP: Logged in.\n");
    }
    if ( server_type != NETPRESENZ_SERVER )
      server_type = GENERIC_SERVER;
    use_list[0] = 0;
    status = response("SYST\r\n");
    if ( status != 2 )
    {
      get_ftp_pwd(&server_type, use_list);
      return con->socket;
    }
    if ( !strncmp(&response_text[4], "UNIX Type: L8 MAC-OS MachTen", 0x1Cu) )
    {
      server_type = MACHTEN_SERVER;
      use_list[0] = 1;
      if ( WWW_TraceFlag[0] )
      {
        v17 = TraceFP();
        fprintf(v17, "HTFTP: Treating as MachTen server.\n");
      }
      return con->socket;
    }
    if ( strstr(&response_text[4], "UNIX") || strstr(&response_text[4], "Unix") )
    {
      server_type = UNIX_SERVER;
      unsure_type = 0;
      use_list[0] = 1;
      if ( WWW_TraceFlag[0] )
      {
        v18 = TraceFP();
        fprintf(v18, "HTFTP: Treating as Unix server.\n");
      }
      return con->socket;
    }
    if ( strstr(&response_text[4], "MSDOS") )
    {
      server_type = MSDOS_SERVER;
      use_list[0] = 1;
      if ( WWW_TraceFlag[0] )
      {
        v19 = TraceFP();
        fprintf(v19, "HTFTP: Treating as MSDOS (Unix emulation) server.\n");
      }
      return con->socket;
    }
    if ( !strncmp(&response_text[4], "VMS", 3u) )
    {
      tilde = strstr(arg, "/~");
      use_list[0] = 1;
      if ( tilde && tilde[2] && strstr(&response_text[4], "MadGoat") )
      {
        server_type = UNIX_SERVER;
        if ( WWW_TraceFlag[0] )
        {
          v20 = TraceFP();
          fprintf(v20, "HTFTP: Treating VMS as UNIX server.\n");
        }
      }
      else
      {
        server_type = VMS_SERVER;
        if ( WWW_TraceFlag[0] )
        {
          v21 = TraceFP();
          fprintf(v21, "HTFTP: Treating as VMS server.\n");
        }
      }
      return con->socket;
    }
    if ( !strncmp(&response_text[4], "VM/CMS", 6u) || !strncmp(&response_text[4], "VM ", 3u) )
    {
      server_type = CMS_SERVER;
      use_list[0] = 1;
      if ( WWW_TraceFlag[0] )
      {
        v22 = TraceFP();
        fprintf(v22, "HTFTP: Treating as CMS server.\n");
      }
      return con->socket;
    }
    if ( !strncmp(&response_text[4], "DCTS", 4u) )
    {
      server_type = DCTS_SERVER;
      if ( WWW_TraceFlag[0] )
      {
        v23 = TraceFP();
        fprintf(v23, "HTFTP: Treating as DCTS server.\n");
      }
      return con->socket;
    }
    if ( strstr(&response_text[4], "MAC-OS TCP/Connect II") )
    {
      server_type = TCPC_SERVER;
      if ( WWW_TraceFlag[0] )
      {
        v24 = TraceFP();
        fprintf(v24, "HTFTP: Looks like a TCPC server.\n");
      }
LABEL_143:
      get_ftp_pwd(&server_type, use_list);
      unsure_type = 1;
      return con->socket;
    }
    if ( server_type == NETPRESENZ_SERVER )
    {
      use_list[0] = 1;
      set_mac_binary(server_type);
      if ( WWW_TraceFlag[0] )
      {
        v25 = TraceFP();
        fprintf(v25, "HTFTP: Treating as NetPresenz (MACOS) server.\n");
      }
      return con->socket;
    }
    if ( !strncmp(&response_text[4], "MACOS Peter's Server", 0x14u) )
    {
      server_type = PETER_LEWIS_SERVER;
      use_list[0] = 1;
      set_mac_binary(PETER_LEWIS_SERVER);
      if ( WWW_TraceFlag[0] )
      {
        v26 = TraceFP();
        fprintf(v26, "HTFTP: Treating as Peter Lewis (MACOS) server.\n");
      }
      return con->socket;
    }
    if ( !strncmp(&response_text[4], "Windows_NT", 0xAu) )
    {
      server_type = WINDOWS_NT_SERVER;
      if ( WWW_TraceFlag[0] )
      {
        v27 = TraceFP();
        fprintf(v27, "HTFTP: Treating as Window_NT server.\n");
      }
    }
    else
    {
      if ( strncmp(&response_text[4], "Windows2000", 0xBu) )
      {
        if ( !strncmp(&response_text[4], "MS Windows", 0xAu) )
        {
          server_type = MS_WINDOWS_SERVER;
          use_list[0] = 1;
          if ( WWW_TraceFlag[0] )
          {
            v29 = TraceFP();
            fprintf(v29, "HTFTP: Treating as MS Windows server.\n");
          }
          return con->socket;
        }
        if ( !strncmp(&response_text[4], "MACOS AppleShare IP FTP Server", 0x1Eu) )
        {
          server_type = APPLESHARE_SERVER;
          use_list[0] = 1;
          set_mac_binary(APPLESHARE_SERVER);
          if ( WWW_TraceFlag[0] )
          {
            v30 = TraceFP();
            fprintf(v30, "HTFTP: Treating as AppleShare server.\n");
          }
          return con->socket;
        }
        server_type = GENERIC_SERVER;
        if ( WWW_TraceFlag[0] )
        {
          v31 = TraceFP();
          fprintf(v31, "HTFTP: Ugh!  A Generic server.\n");
        }
        goto LABEL_143;
      }
      server_type = WINDOWS_2K_SERVER;
      if ( WWW_TraceFlag[0] )
      {
        v28 = TraceFP();
        fprintf(v28, "HTFTP: Treating as Window_2K server.\n");
      }
    }
    set_unix_dirstyle(&server_type, use_list);
    return con->socket;
  }
  if ( WWW_TraceFlag[0] )
  {
    v15 = TraceFP();
    fprintf(v15, "HTFTP: Login fail: %s", response_text);
  }
  return -1;
}

//----- (0810E98F) --------------------------------------------------------
void reset_master_socket()
{
  have_socket[0] = 0;
}

//----- (0810E99B) --------------------------------------------------------
void __cdecl set_master_socket(int value)
{
  have_socket[0] = value >= 0;
  if ( value >= 0 )
    master_socket = value;
}

//----- (0810E9C0) --------------------------------------------------------
int close_master_socket()
{
  unsigned int v0; // ebx
  FILE *v1; // eax
  char *v2; // eax
  int status; // [esp+20h] [ebp-8h]

  if ( have_socket[0] )
    open_sockets.fds_bits[master_socket >> 5] &= ~(1 << (master_socket & 0x1F));
  status = close(master_socket);
  if ( WWW_TraceFlag[0] )
  {
    v0 = master_socket;
    v1 = TraceFP();
    fprintf(v1, "HTFTP: Closed master socket %u\n", v0);
  }
  reset_master_socket();
  if ( status >= 0 )
    return status;
  v2 = gettext("close master socket");
  return HTInetStatus(v2);
}

//----- (0810EA6E) --------------------------------------------------------
unsigned int get_listen_socket()
{
  char *v0; // eax
  FILE *v1; // eax
  const char *v2; // ebx
  FILE *v3; // eax
  int v4; // eax
  const char *v5; // esi
  int v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  socklen_t address_length; // [esp+48h] [ebp-130h] BYREF
  int status; // [esp+4Ch] [ebp-12Ch]
  fd_set *__arr; // [esp+50h] [ebp-128h]
  unsigned int __i; // [esp+54h] [ebp-124h]
  int new_socket; // [esp+58h] [ebp-120h]
  socklen_t slen; // [esp+5Ch] [ebp-11Ch] BYREF
  int af_0; // [esp+60h] [ebp-118h]
  sockaddr_in *soc_in; // [esp+64h] [ebp-114h]
  sockaddr_storage soc_address; // [esp+68h] [ebp-110h] BYREF
  char portbuf[64]; // [esp+E8h] [ebp-90h] BYREF
  char hostbuf[64]; // [esp+128h] [ebp-50h] BYREF
  unsigned int v22; // [esp+168h] [ebp-10h]

  v22 = __readgsdword(0x14u);
  soc_in = (sockaddr_in *)&soc_address;
  __arr = &open_sockets;
  for ( __i = 0; __i <= 0x1F; ++__i )
    __arr->fds_bits[__i] = 0;
  num_sockets = 0;
  slen = 128;
  if ( getsockname(control->socket, (struct sockaddr *)&soc_address, &slen) < 0 )
    return HTInetStatus("getsockname failed");
  af_0 = soc_address.ss_family;
  memset(&soc_address, 0, sizeof(soc_address));
  new_socket = socket(af_0, 1, 6);
  if ( new_socket >= 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTFTP: Opened master socket number %d\n", new_socket);
    }
    memset(&soc_address, 0, sizeof(soc_address));
    soc_address.ss_family = af_0;
    if ( af_0 != 2 && af_0 != 10 )
      HTInetStatus("AF");
    address_length = 128;
    status = getsockname(control->socket, (struct sockaddr *)&soc_address, &address_length);
    if ( status < 0 )
      return HTInetStatus("getsockname");
    if ( WWW_TraceFlag[0] )
    {
      v2 = HTInetString((SockA *)soc_in);
      v3 = TraceFP();
      fprintf(v3, "HTFTP: This host is %s\n", v2);
    }
    soc_in->sin_port = 0;
    if ( soc_address.ss_family == 10 )
      v4 = bind(new_socket, (const struct sockaddr *)&soc_address, 0x1Cu);
    else
      v4 = bind(new_socket, (const struct sockaddr *)&soc_address, 0x10u);
    status = v4;
    if ( v4 < 0 )
      return HTInetStatus("bind");
    address_length = 128;
    status = getsockname(new_socket, (struct sockaddr *)&soc_address, &address_length);
    if ( status < 0 )
    {
      return HTInetStatus("getsockname");
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v5 = HTInetString((SockA *)soc_in);
        v6 = ntohs(soc_in->sin_port);
        v7 = TraceFP();
        fprintf(v7, "HTFTP: bound to port %d on %s\n", v6, v5);
      }
      if ( have_socket[0] )
        close_master_socket();
      set_master_socket(new_socket);
      HTHostName();
      if ( soc_address.ss_family == 2 )
      {
        sprintf(
          port_command,
          "PORT %d,%d,%d,%d,%d,%d%c%c",
          LOBYTE(soc_in->sin_addr.s_addr),
          BYTE1(soc_in->sin_addr.s_addr),
          BYTE2(soc_in->sin_addr.s_addr),
          HIBYTE(soc_in->sin_addr.s_addr),
          LOBYTE(soc_in->sin_port),
          HIBYTE(soc_in->sin_port),
          13,
          10);
      }
      else if ( soc_address.ss_family == 10 )
      {
        if ( soc_address.ss_family == 10 )
          getnameinfo((const struct sockaddr *)&soc_address, 0x1Cu, hostbuf, 0x40u, portbuf, 0x40u, 3u);
        else
          getnameinfo((const struct sockaddr *)&soc_address, 0x10u, hostbuf, 0x40u, portbuf, 0x40u, 3u);
        sprintf(port_command, "EPRT |%d|%s|%s|%c%c", 2, hostbuf, portbuf, 13, 10);
      }
      else
      {
        sprintf(port_command, "JUNK%c%c", 13, 10);
      }
      if ( listen(master_socket, 1) >= 0 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v8 = TraceFP();
          fprintf(v8, "TCP: Master socket(), bind() and listen() all OK\n");
        }
        open_sockets.fds_bits[master_socket >> 5] |= 1 << (master_socket & 0x1F);
        if ( master_socket + 1 > num_sockets )
          num_sockets = master_socket + 1;
        return master_socket;
      }
      else
      {
        reset_master_socket();
        return HTInetStatus("listen");
      }
    }
  }
  else
  {
    v0 = gettext("socket for master socket");
    return HTInetStatus(v0);
  }
}

//----- (0810F074) --------------------------------------------------------
void set_years_and_date()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  int i; // [esp+20h] [ebp-28h]
  time_t NowTime; // [esp+24h] [ebp-24h] BYREF
  char date[12]; // [esp+28h] [ebp-20h] BYREF
  char month[8]; // [esp+34h] [ebp-14h] BYREF
  char day[8]; // [esp+3Ch] [ebp-Ch] BYREF
  unsigned int v9; // [esp+44h] [ebp-4h]

  v9 = __readgsdword(0x14u);
  NowTime = time(0);
  v0 = ctime(&NowTime);
  strncpy(day, v0 + 8, 2u);
  day[2] = 0;
  if ( day[0] == 32 )
    day[0] = 48;
  v1 = ctime(&NowTime);
  strncpy(month, v1 + 4, 3u);
  month[3] = 0;
  for ( i = 0; i <= 11 && strcasecomp(month, months[i]); ++i )
    ;
  sprintf(date, "9999%02d%.2s", i + 1, day);
  TheDate = atoi(date);
  v2 = ctime(&NowTime);
  strcpy(ThisYear, v2 + 20);
  ThisYear[4] = 0;
  v3 = atoi(ThisYear);
  sprintf(LastYear, "%d", v3 - 1);
  HaveYears[0] = 1;
}

//----- (0810F1BD) --------------------------------------------------------
void __cdecl free_entryinfo_struct_contents(EntryInfo *entry_info)
{
  if ( entry_info )
  {
    if ( entry_info->filename )
    {
      free(entry_info->filename);
      entry_info->filename = 0;
    }
    if ( entry_info->linkname )
    {
      free(entry_info->linkname);
      entry_info->linkname = 0;
    }
    if ( entry_info->type )
    {
      free(entry_info->type);
      entry_info->type = 0;
    }
    if ( entry_info->date )
    {
      free(entry_info->date);
      entry_info->date = 0;
    }
  }
}

//----- (0810F254) --------------------------------------------------------
BOOLEAN __cdecl is_ls_date(char *s)
{
  bool v1; // al
  bool v2; // al
  bool v3; // al
  bool v4; // al
  bool v5; // al
  bool v6; // al
  bool v7; // al
  char *sa; // [esp+10h] [ebp+8h]
  char *sb; // [esp+10h] [ebp+8h]
  char *sc; // [esp+10h] [ebp+8h]
  char *sd; // [esp+10h] [ebp+8h]
  char *si; // [esp+10h] [ebp+8h]
  char *se; // [esp+10h] [ebp+8h]
  char *sf; // [esp+10h] [ebp+8h]
  char *sj; // [esp+10h] [ebp+8h]
  char *sg; // [esp+10h] [ebp+8h]
  char *sk; // [esp+10h] [ebp+8h]
  char *sh; // [esp+10h] [ebp+8h]

  v1 = ((*__ctype_b_loc())[(unsigned __int8)*s] & 0x400) == 0;
  sa = s + 1;
  if ( v1 )
    return 0;
  v2 = ((*__ctype_b_loc())[(unsigned __int8)*sa] & 0x400) == 0;
  sb = sa + 1;
  if ( v2 )
    return 0;
  v3 = ((*__ctype_b_loc())[(unsigned __int8)*sb] & 0x400) == 0;
  sc = sb + 1;
  if ( v3 )
    return 0;
  if ( *sc != 32 && *sc != 1 )
    return 0;
  sd = sc + 1;
  if ( *sd != 32 && ((*__ctype_b_loc())[(unsigned __int8)*sd] & 0x800) == 0 )
    return 0;
  si = sd + 1;
  v4 = ((*__ctype_b_loc())[(unsigned __int8)*si] & 0x800) == 0;
  se = si + 1;
  if ( v4 )
    return 0;
  v5 = *se != 32;
  sf = se + 1;
  if ( v5 )
    return 0;
  if ( *sf != 32 && ((*__ctype_b_loc())[(unsigned __int8)*sf] & 0x800) == 0 )
    return 0;
  sj = sf + 1;
  v6 = ((*__ctype_b_loc())[(unsigned __int8)*sj] & 0x800) == 0;
  sg = sj + 1;
  if ( v6 )
    return 0;
  if ( *sg != 58 && ((*__ctype_b_loc())[(unsigned __int8)*sg] & 0x800) == 0 )
    return 0;
  sk = sg + 1;
  v7 = ((*__ctype_b_loc())[(unsigned __int8)*sk] & 0x800) == 0;
  sh = sk + 1;
  return !v7 && (*sh == 32 || ((*__ctype_b_loc())[(unsigned __int8)*sh] & 0x800) != 0) && sh[1] == 32;
}

//----- (0810F4E6) --------------------------------------------------------
void __cdecl parse_eplf_line(char *line, EntryInfo *info)
{
  char *v2; // eax
  char *v3; // eax
  int v5; // [esp+Ch] [ebp-6Ch]
  tm t; // [esp+20h] [ebp-58h] BYREF
  time_t secs; // [esp+4Ch] [ebp-2Ch] BYREF
  unsigned int size; // [esp+50h] [ebp-28h]
  char *cp; // [esp+54h] [ebp-24h]
  char ct[26]; // [esp+5Ah] [ebp-1Eh] BYREF
  unsigned int v11; // [esp+74h] [ebp-4h]

  v11 = __readgsdword(0x14u);
  cp = line;
  if ( !flagbase_11668 )
  {
    t.tm_year = 70;
    memset(&t, 0, 20);
    t.tm_isdst = -1;
    base_11667 = mktime(&t);
    flagbase_11668 = 1;
  }
  while ( *cp )
  {
    v5 = *cp;
    if ( v5 == 109 )
    {
      for ( secs = 0; *++cp && *cp != 44; secs = 10 * secs + *cp - 48 )
        ;
      secs += base_11667;
      v2 = ctime(&secs);
      strcpy(ct, v2);
      ct[24] = 0;
      HTSACopy(&info->date, ct);
    }
    else if ( v5 > 109 )
    {
      if ( v5 != 115 )
        goto LABEL_23;
      for ( size = 0; *++cp && *cp != 44; size = 10 * size + *cp - 48 )
        ;
      info->size = size;
    }
    else
    {
      if ( v5 == 9 )
      {
        HTSACopy(&info->filename, cp + 1);
        return;
      }
      if ( v5 == 47 )
      {
        v3 = gettext("Directory");
        HTSACopy(&info->type, v3);
      }
      do
      {
LABEL_23:
        if ( !*cp )
          break;
      }
      while ( *cp++ != 44 );
    }
  }
}

//----- (0810F6ED) --------------------------------------------------------
void __cdecl parse_ls_line(char *line, EntryInfo *entry_info)
{
  int size_num; // [esp+8h] [ebp-10h]
  int base; // [esp+Ch] [ebp-Ch]
  int j; // [esp+10h] [ebp-8h]
  int ja; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  base = 1;
  size_num = 0;
  for ( i = strlen(line) - 1;
        i > 13 && (((*__ctype_b_loc())[(unsigned __int8)line[i]] & 0x2000) == 0 || !is_ls_date(&line[i - 12]));
        --i )
  {
    ;
  }
  line[i] = 0;
  if ( i > 13 )
  {
    HTSACopy(&entry_info->date, &line[i - 12]);
    if ( entry_info->date[4] == 32 || entry_info->date[4] == 48 )
      entry_info->date[4] = 1;
    if ( entry_info->date[11] == 32 )
    {
      for ( j = 11; j > 6; --j )
        entry_info->date[j] = entry_info->date[j - 1];
    }
  }
  for ( ja = i - 14; ((*__ctype_b_loc())[(unsigned __int8)line[ja]] & 0x800) != 0; --ja )
  {
    size_num += base * (line[ja] - 48);
    base *= 10;
  }
  entry_info->size = size_num;
  HTSACopy(&entry_info->filename, &line[i + 1]);
}

//----- (0810F877) --------------------------------------------------------
void __cdecl parse_dls_line(char *line, EntryInfo *entry_info, char **pspilledname)
{
  char *filename; // ebx
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *cps; // [esp+20h] [ebp-18h]
  char *cpsa; // [esp+20h] [ebp-18h]
  int len; // [esp+24h] [ebp-14h]
  int lena; // [esp+24h] [ebp-14h]
  int size_num; // [esp+28h] [ebp-10h]
  int base; // [esp+2Ch] [ebp-Ch]
  __int16 j; // [esp+32h] [ebp-6h]

  base = 1;
  size_num = 0;
  len = strlen(line);
  if ( !len )
  {
    if ( *pspilledname )
    {
      free(*pspilledname);
      *pspilledname = 0;
    }
    entry_info->display = 0;
    return;
  }
  cps = LYSkipNonBlanks(line);
  if ( !*cps )
  {
    HTSACopy(pspilledname, line);
    entry_info->display = 0;
    return;
  }
  if ( len > 23 && line[23] == 32 && (((*__ctype_b_loc())[(unsigned __int8)*line] & 0x2000) == 0 || *pspilledname) )
  {
    j = 22;
    if ( line[22] == 61 || line[22] == 45 )
    {
      v6 = gettext("Directory");
      HTSACopy(&entry_info->type, v6);
    }
    else
    {
      while ( ((*__ctype_b_loc())[(unsigned __int8)line[j]] & 0x800) != 0 )
      {
        size_num += base * (line[j] - 48);
        base *= 10;
        --j;
      }
    }
    entry_info->size = size_num;
    cpsa = LYSkipBlanks(line + 23);
    if ( !strncmp(cpsa, "-> ", 3u) && cpsa[3] && cpsa[3] != 32 )
    {
      v7 = gettext("Symbolic Link");
      HTSACopy(&entry_info->type, v7);
      v8 = LYSkipBlanks(cpsa + 3);
      HTSACopy(&entry_info->linkname, v8);
      entry_info->size = 0;
    }
    if ( j > 0 )
      line[j] = 0;
    LYTrimTrailing(line);
    lena = strlen(line);
    if ( !lena && *pspilledname && **pspilledname )
    {
      line = *pspilledname;
      lena = strlen(*pspilledname);
    }
    if ( lena > 0 && line[lena - 1] == 47 )
    {
      if ( lena > 1 )
        line[lena - 1] = 0;
      if ( !entry_info->type )
      {
        v9 = gettext("Directory");
        HTSACopy(&entry_info->type, v9);
      }
    }
    HTSACopy(&entry_info->filename, line);
    if ( *pspilledname )
      goto LABEL_47;
  }
  else
  {
    if ( ((*__ctype_b_loc())[(unsigned __int8)*line] & 0x2000) == 0 )
      *cps = 0;
    if ( *pspilledname && !*line )
    {
      entry_info->filename = *pspilledname;
      *pspilledname = 0;
      filename = entry_info->filename;
      if ( filename[strlen(entry_info->filename) - 1] == 47 )
      {
        v4 = gettext("Directory");
        HTSACopy(&entry_info->type, v4);
      }
      else
      {
        HTSACopy(&entry_info->type, &nn);
      }
      return;
    }
    HTSACopy(&entry_info->filename, line);
    if ( cps && cps != line && *(cps - 1) == 47 )
    {
      v5 = gettext("Directory");
      HTSACopy(&entry_info->type, v5);
    }
    else
    {
      HTSACopy(&entry_info->type, &nn);
    }
    if ( *pspilledname )
    {
LABEL_47:
      free(*pspilledname);
      *pspilledname = 0;
    }
  }
}

//----- (0810FCA0) --------------------------------------------------------
void __cdecl parse_vms_dir_entry(char *line, EntryInfo *entry_info)
{
  char *filename; // ebx
  FILE *v3; // eax
  char v4; // [esp+1Bh] [ebp-4Dh]
  char v5; // [esp+23h] [ebp-45h]
  unsigned int size; // [esp+24h] [ebp-44h]
  char *v7; // [esp+28h] [ebp-40h]
  char *cps; // [esp+38h] [ebp-30h]
  char *cpsa; // [esp+38h] [ebp-30h]
  char *cpsb; // [esp+38h] [ebp-30h]
  const char *cpsc; // [esp+38h] [ebp-30h]
  char *cpd; // [esp+3Ch] [ebp-2Ch]
  char *cpda; // [esp+3Ch] [ebp-2Ch]
  char *cpdb; // [esp+3Ch] [ebp-2Ch]
  char *cp; // [esp+40h] [ebp-28h]
  char *cpa; // [esp+40h] [ebp-28h]
  int j; // [esp+48h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-1Ch]
  int ia; // [esp+4Ch] [ebp-1Ch]
  int ib; // [esp+4Ch] [ebp-1Ch]
  int ic; // [esp+4Ch] [ebp-1Ch]
  char date[16]; // [esp+50h] [ebp-18h] BYREF
  unsigned int v23; // [esp+60h] [ebp-8h]

  v23 = __readgsdword(0x14u);
  if ( *line && (cp = strchr(line, 59)) != 0 )
  {
    *cp = 0;
    cpa = cp + 1;
    HTSACopy(&entry_info->filename, line);
    if ( strstr(entry_info->filename, "READ") )
    {
      ia = strstr(entry_info->filename, "READ") - entry_info->filename + 4;
      if ( !strncmp(&entry_info->filename[ia], "ME", 2u) )
      {
        for ( i = ia + 2; entry_info->filename[i] && entry_info->filename[i] != 46; ++i )
          ;
      }
      else if ( !strncmp(&entry_info->filename[ia], ".ME", 3u) )
      {
        i = strlen(entry_info->filename);
      }
      else
      {
        i = 0;
      }
      LYLowerCase(&entry_info->filename[i]);
    }
    else
    {
      LYLowerCase(entry_info->filename);
      i = strlen(entry_info->filename);
    }
    ib = i - 1;
    if ( ib > 2
      && entry_info->filename[ib] == 122
      && (entry_info->filename[ib - 1] == 46 || entry_info->filename[ib - 1] == 95) )
    {
      entry_info->filename[ib] = 90;
    }
    for ( cps = cpa - 1; ; *cps = 32 )
    {
      cps = strchr(cps + 1, 9);
      if ( !cps )
        break;
    }
    ic = 0;
    j = 1;
    while ( cpa[j] )
    {
      if ( cpa[ic] == 32 && cpa[j] == 32 )
        ++j;
      else
        cpa[++ic] = cpa[j++];
    }
    cpa[ic + 1] = 0;
    if ( !HaveYears[0] )
      set_years_and_date();
    cpd = strchr(cpa, 45);
    if ( cpd
      && strlen(cpd) > 9
      && ((*__ctype_b_loc())[(unsigned __int8)*(cpd - 1)] & 0x800) != 0
      && ((*__ctype_b_loc())[(unsigned __int8)cpd[1]] & 0x400) != 0
      && cpd[4] == 45 )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)cpd[2]] & 0x100) != 0 )
        v4 = tolower((unsigned __int8)cpd[2]);
      else
        v4 = cpd[2];
      cpd[2] = v4;
      if ( ((*__ctype_b_loc())[(unsigned __int8)cpd[3]] & 0x100) != 0 )
        v5 = tolower((unsigned __int8)cpd[3]);
      else
        v5 = cpd[3];
      cpd[3] = v5;
      sprintf(date, "%.3s ", cpd + 1);
      if ( ((*__ctype_b_loc())[(unsigned __int8)*(cpd - 2)] & 0x800) != 0 )
        sprintf(&date[4], "%.2s ", cpd - 2);
      else
        sprintf(&date[4], "%c%.1s ", 1, cpd - 1);
      if ( !strncmp(ThisYear, cpd + 5, 4u) && strlen(cpd) > 0xF && cpd[12] == 58 )
        sprintf(&date[7], "%.5s", cpd + 10);
      else
        sprintf(&date[7], " %.4s", cpd + 5);
      HTSACopy(&entry_info->date, date);
    }
    cpda = strchr(cpa, 47);
    if ( cpda )
    {
      for ( cpsa = cpda; ((*__ctype_b_loc())[(unsigned __int8)*(cpsa - 1)] & 0x800) != 0; --cpsa )
        ;
      if ( cpsa < cpda )
        *cpda = 0;
      entry_info->size = atoi(cpsa);
      for ( cpsb = cpda + 1; ((*__ctype_b_loc())[(unsigned __int8)*cpsb] & 0x800) != 0; ++cpsb )
        ;
      *cpsb = 0;
      if ( entry_info->size <= atoi(cpda + 1) )
        entry_info->size <<= 9;
    }
    else if ( strtok(cpa, " ") )
    {
      while ( 1 )
      {
        cpsc = strtok(0, " ");
        if ( !cpsc )
          break;
        for ( cpdb = (char *)cpsc; ((*__ctype_b_loc())[(unsigned __int8)*cpdb] & 0x800) != 0; ++cpdb )
          ;
        if ( !*cpdb )
        {
          entry_info->size = atoi(cpsc) << 9;
          break;
        }
      }
    }
    if ( WWW_TraceFlag[0] )
    {
      size = entry_info->size;
      if ( entry_info->date )
        v7 = entry_info->date;
      else
        v7 = (char *)&nn;
      filename = entry_info->filename;
      v3 = TraceFP();
      fprintf(v3, "HTFTP: VMS filename: %s  date: %s  size: %u\n", filename, v7, size);
    }
  }
  else
  {
    entry_info->display = 0;
  }
}

//----- (0811037D) --------------------------------------------------------
void __cdecl parse_ms_windows_dir_entry(char *line, EntryInfo *entry_info)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *filename; // ebx
  FILE *v6; // eax
  unsigned int size; // [esp+14h] [ebp-44h]
  char *v8; // [esp+18h] [ebp-40h]
  char *end; // [esp+30h] [ebp-28h]
  char *cpd; // [esp+34h] [ebp-24h]
  char *cpda; // [esp+34h] [ebp-24h]
  char *cps; // [esp+38h] [ebp-20h]
  char *cpsa; // [esp+38h] [ebp-20h]
  char *cp; // [esp+3Ch] [ebp-1Ch]
  char date[16]; // [esp+40h] [ebp-18h] BYREF
  unsigned int v16; // [esp+50h] [ebp-8h]

  v16 = __readgsdword(0x14u);
  end = &line[strlen(line)];
  cp = LYSkipBlanks(line);
  if ( *cp )
  {
    v2 = LYSkipNonBlanks(cp);
    *v2 = 0;
    cps = v2 + 1;
    cpd = v2 + 1;
    HTSACopy(&entry_info->filename, cp);
    if ( cps >= end )
    {
      HTSACopy(&entry_info->type, &nn);
    }
    else
    {
      cpsa = LYSkipBlanks(cps);
      v3 = LYSkipNonBlanks(cpsa);
      *v3 = 0;
      cpd = v3 + 1;
      if ( ((*__ctype_b_loc())[(unsigned __int8)*cpsa] & 0x800) != 0 )
      {
        entry_info->size = atoi(cpsa);
      }
      else
      {
        v4 = gettext("Directory");
        HTSACopy(&entry_info->type, v4);
      }
    }
    if ( !HaveYears[0] )
      set_years_and_date();
    if ( cpd < end )
    {
      cpda = LYSkipBlanks(cpd);
      if ( strlen(cpda) > 0x11 )
      {
        cpda[6] = 0;
        cpda[11] = 0;
        cpda[17] = 0;
        if ( !strcmp(ThisYear, cpda + 7) )
          sprintf(date, "%.6s %.5s", cpda, cpda + 12);
        else
          sprintf(date, "%.6s  %.4s", cpda, cpda + 7);
        HTSACopy(&entry_info->date, date);
        if ( entry_info->date[4] == 32 || entry_info->date[4] == 48 )
          entry_info->date[4] = 1;
      }
    }
    if ( WWW_TraceFlag[0] )
    {
      size = entry_info->size;
      if ( entry_info->date )
        v8 = entry_info->date;
      else
        v8 = (char *)&nn;
      filename = entry_info->filename;
      v6 = TraceFP();
      fprintf(v6, "HTFTP: MS Windows filename: %s  date: %s  size: %u\n", filename, v8, size);
    }
  }
  else
  {
    entry_info->display = 0;
  }
}

//----- (08110616) --------------------------------------------------------
void __cdecl parse_cms_dir_entry(char *line, EntryInfo *entry_info)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *filename; // ebx
  FILE *v9; // eax
  unsigned int size; // [esp+14h] [ebp-44h]
  char *v11; // [esp+18h] [ebp-40h]
  int i; // [esp+24h] [ebp-34h]
  int ia; // [esp+24h] [ebp-34h]
  int Records; // [esp+28h] [ebp-30h]
  int RecordLength; // [esp+2Ch] [ebp-2Ch]
  char *end; // [esp+30h] [ebp-28h]
  char *cpd; // [esp+34h] [ebp-24h]
  char *cpda; // [esp+34h] [ebp-24h]
  char *cpdb; // [esp+34h] [ebp-24h]
  char *cps; // [esp+38h] [ebp-20h]
  char *cpsa; // [esp+38h] [ebp-20h]
  unsigned __int8 *cpsb; // [esp+38h] [ebp-20h]
  char *cpsc; // [esp+38h] [ebp-20h]
  char *cpsd; // [esp+38h] [ebp-20h]
  char *cp; // [esp+3Ch] [ebp-1Ch]
  char *cpa; // [esp+3Ch] [ebp-1Ch]
  char *cpe; // [esp+3Ch] [ebp-1Ch]
  char *cpf; // [esp+3Ch] [ebp-1Ch]
  char *cpb; // [esp+3Ch] [ebp-1Ch]
  char *cpc; // [esp+3Ch] [ebp-1Ch]
  char date[16]; // [esp+40h] [ebp-18h] BYREF
  unsigned int v32; // [esp+50h] [ebp-8h]

  v32 = __readgsdword(0x14u);
  end = &line[strlen(line)];
  RecordLength = 0;
  Records = 0;
  cp = LYSkipBlanks(line);
  if ( *cp )
  {
    v2 = LYSkipNonBlanks(cp);
    *v2 = 0;
    cps = v2 + 1;
    HTSACopy(&entry_info->filename, cp);
    if ( !strchr(entry_info->filename, 46) )
    {
      cpa = LYSkipBlanks(cps);
      if ( *cpa )
      {
        v3 = LYSkipNonBlanks(cpa);
        *v3 = 0;
        cpsa = v3 + 1;
        if ( strcasecomp(cpa, "DIR") || cpa - line <= 17 )
        {
          cpe = cpa - 1;
          *cpe = 46;
          HTSACat(&entry_info->filename, cpe);
          if ( cpsa < end )
          {
            cpf = LYSkipBlanks(cpsa);
            v5 = LYSkipNonBlanks(cpf);
            *v5 = 0;
            cpsa = v5 + 1;
          }
        }
        else
        {
          v4 = gettext("Directory");
          HTSACopy(&entry_info->type, v4);
          entry_info->size = 0;
        }
        if ( cpsa < end )
        {
          cpb = LYSkipBlanks(cpsa);
          v6 = LYSkipNonBlanks(cpb);
          *v6 = 0;
          cpsa = v6 + 1;
          if ( ((*__ctype_b_loc())[(unsigned __int8)*cpb] & 0x800) != 0 )
            RecordLength = atoi(cpb);
        }
        if ( cpsa < end )
        {
          cpc = LYSkipBlanks(cpsa);
          v7 = LYSkipNonBlanks(cpc);
          *v7 = 0;
          cpsa = v7 + 1;
          if ( ((*__ctype_b_loc())[(unsigned __int8)*cpc] & 0x800) != 0 )
            Records = atoi(cpc);
          if ( Records > 0 && RecordLength > 0 )
            entry_info->size = RecordLength * Records;
        }
        if ( !HaveYears[0] )
          set_years_and_date();
        cpd = cpsa;
        if ( cpsa < end )
        {
          cpsb = (unsigned __int8 *)strchr(cpsa, 58);
          if ( cpsb )
          {
            if ( end - 3 > (char *)cpsb
              && ((*__ctype_b_loc())[cpsb[1]] & 0x800) != 0
              && ((*__ctype_b_loc())[cpsb[2]] & 0x800) != 0
              && cpsb[3] == 58 )
            {
              cpsc = (char *)(cpsb + 3);
              *cpsc = 0;
              if ( cpsc - cpd > 13 )
              {
                cpda = cpsc - 14;
                *(cpsc - 12) = 0;
                cpda[5] = 0;
                cpda[8] = 0;
                cpsd = cpsc - 5;
                if ( *cpda == 32 )
                  *cpda = 48;
                i = atoi(cpda) - 1;
                sprintf(date, "%.3s %.2s", months[i], cpda + 3);
                if ( date[4] == 48 )
                  date[4] = 32;
                cpdb = cpda + 6;
                if ( !strcmp(&ThisYear[2], cpdb) )
                {
                  cpsd[2] = 0;
                  ia = atoi(cpsd);
                  sprintf(&date[6], " %02d:%.2s", ia, cpsd + 3);
                }
                else if ( atoi(cpdb) > 69 )
                {
                  sprintf(&date[6], "  19%.2s", cpdb);
                }
                else
                {
                  sprintf(&date[6], "  20%.2s", cpdb);
                }
                HTSACopy(&entry_info->date, date);
                if ( entry_info->date[4] == 32 || entry_info->date[4] == 48 )
                  entry_info->date[4] = 1;
              }
            }
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          size = entry_info->size;
          if ( entry_info->date )
            v11 = entry_info->date;
          else
            v11 = (char *)&nn;
          filename = entry_info->filename;
          v9 = TraceFP();
          fprintf(v9, "HTFTP: VM/CMS filename: %s  date: %s  size: %u\n", filename, v11, size);
        }
      }
      else
      {
        if ( entry_info->filename )
        {
          free(entry_info->filename);
          entry_info->filename = 0;
        }
        if ( entry_info->type )
        {
          free(entry_info->type);
          entry_info->type = 0;
        }
        entry_info->display = 0;
      }
    }
  }
  else
  {
    entry_info->display = 0;
  }
}

//----- (08110B7C) --------------------------------------------------------
EntryInfo *__cdecl parse_dir_entry(char *entry, BOOLEAN *first, char **pspilledname)
{
  FILE *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  bool v11; // [esp+17h] [ebp-21h]
  HTAtom *encoding; // [esp+18h] [ebp-20h] BYREF
  HTFormat format; // [esp+1Ch] [ebp-1Ch]
  const char *cp2; // [esp+20h] [ebp-18h] BYREF
  char *cp; // [esp+24h] [ebp-14h]
  int len; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  EntryInfo *entry_info; // [esp+30h] [ebp-8h]
  BOOLEAN remove_size; // [esp+37h] [ebp-1h]

  remove_size = 0;
  entry_info = (EntryInfo *)malloc(0x18u);
  if ( !entry_info )
    outofmem("../../../WWW/Library/Implementation/HTFTP.c", "parse_dir_entry");
  entry_info->filename = 0;
  entry_info->linkname = 0;
  entry_info->type = 0;
  entry_info->date = 0;
  entry_info->size = 0;
  entry_info->display = 1;
  switch ( server_type )
  {
    case MACHTEN_SERVER:
    case UNIX_SERVER:
    case PETER_LEWIS_SERVER:
    case WINDOWS_NT_SERVER:
    case WINDOWS_2K_SERVER:
    case MSDOS_SERVER:
    case APPLESHARE_SERVER:
    case NETPRESENZ_SERVER:
      goto LABEL_26;
    case VMS_SERVER:
      parse_vms_dir_entry(entry, entry_info);
      if ( !entry_info->display )
        return entry_info;
      len = strlen(entry_info->filename);
      if ( len > 4 && !strcmp(&entry_info->filename[len - 4], ".dir") )
      {
        entry_info->filename[len - 4] = 0;
        v7 = gettext("Directory");
        HTSACopy(&entry_info->type, v7);
        remove_size = 1;
      }
      goto LABEL_76;
    case CMS_SERVER:
      parse_cms_dir_entry(entry, entry_info);
      if ( !entry_info->display )
        return entry_info;
      if ( !entry_info->type || *entry_info->type )
        goto LABEL_76;
      if ( entry_info->type )
      {
        free(entry_info->type);
        entry_info->type = 0;
      }
      return entry_info;
    case TCPC_SERVER:
    case NCSA_SERVER:
      HTSACopy(&entry_info->filename, entry);
      len = strlen(entry);
      if ( entry[len - 1] == 47 )
      {
        entry[len - 1] = 0;
        v8 = gettext("Directory");
        HTSACopy(&entry_info->type, v8);
        remove_size = 1;
      }
      goto LABEL_76;
    case MS_WINDOWS_SERVER:
      parse_ms_windows_dir_entry(entry, entry_info);
      if ( !entry_info->display )
        return entry_info;
      if ( !entry_info->type || *entry_info->type )
        goto LABEL_76;
      if ( entry_info->type )
      {
        free(entry_info->type);
        entry_info->type = 0;
      }
      return entry_info;
    case DLS_SERVER:
      if ( *first )
      {
        len = strlen(entry);
        if ( len && *entry != 32 && (len <= 23 || entry[23] == 32) && (len > 23 || !strchr(entry, 32)) )
        {
          *first = 0;
        }
        else
        {
          server_type = UNIX_SERVER;
          if ( WWW_TraceFlag[0] )
          {
            v3 = TraceFP();
            fprintf(v3, "HTFTP: Falling back to treating as Unix server.\n");
          }
        }
      }
      if ( server_type != DLS_SERVER )
      {
LABEL_26:
        if ( *entry == 43 )
        {
          parse_eplf_line(entry, entry_info);
        }
        else
        {
          len = strlen(entry);
          if ( *first )
          {
            if ( !strcmp(entry, "can not access directory .") )
            {
              entry_info->display = 0;
              return entry_info;
            }
            *first = 0;
            if ( !strncmp(entry, "total ", 6u) || strstr(entry, "not available") )
            {
              entry_info->display = 0;
              return entry_info;
            }
            if ( unsure_type )
            {
              server_type = GENERIC_SERVER;
              entry_info->display = 0;
              return entry_info;
            }
          }
          if ( ((*__ctype_b_loc())[(unsigned __int8)*entry] & 0x200) != 0 )
            v11 = toupper((unsigned __int8)*entry) == 68;
          else
            v11 = *entry == 68;
          if ( v11 )
          {
            v4 = gettext("Directory");
            HTSACopy(&entry_info->type, v4);
            remove_size = 1;
          }
          else if ( *entry == 108 )
          {
            v5 = gettext("Symbolic Link");
            HTSACopy(&entry_info->type, v5);
            remove_size = 1;
            for ( i = len - 1;
                  i > 3
               && (((*__ctype_b_loc())[(unsigned __int8)entry[i]] & 0x2000) == 0
                || entry[i - 1] != 62
                || entry[i - 2] != 45
                || entry[i - 3] != 32);
                  --i )
            {
              ;
            }
            if ( i > 3 )
            {
              entry[i - 3] = 0;
              len = i - 3;
              v6 = LYSkipBlanks(&entry[i]);
              HTSACopy(&entry_info->linkname, v6);
            }
          }
          parse_ls_line(entry, entry_info);
          if ( !strcmp(entry_info->filename, "..") || !strcmp(entry_info->filename, ".") )
            entry_info->display = 0;
        }
        goto LABEL_76;
      }
      parse_dls_line(entry, entry_info, pspilledname);
      if ( !entry_info->filename || !*entry_info->filename )
      {
        entry_info->display = 0;
        return entry_info;
      }
      if ( !strcmp(entry_info->filename, "..") || !strcmp(entry_info->filename, ".") )
        entry_info->display = 0;
      if ( !entry_info->type || *entry_info->type )
      {
LABEL_76:
        if ( remove_size && entry_info->size )
          entry_info->size = 0;
        if ( entry_info->filename )
        {
          if ( strlen(entry_info->filename) > 3 )
          {
            cp = strrchr(entry_info->filename, 46);
            if ( cp )
            {
              if ( !strncasecomp(cp, ".me", 3)
                && (!cp[3] || cp[3] == 59)
                && (server_type != UNIX_SERVER || entry_info->filename + 3 < cp && !strncasecomp(cp - 4, "read.me", 7)) )
              {
                HTSACopy(&entry_info->type, "text/plain");
              }
            }
          }
        }
        if ( !entry_info->type )
        {
          format = HTFileFormat(entry_info->filename, &encoding, &cp2);
          if ( !cp2 )
          {
            if ( !strncmp(format->name, "application", 0xBu) )
            {
              cp2 = format->name + 12;
              if ( !strncmp(cp2, "x-", 2u) )
                cp2 += 2;
            }
            else
            {
              cp2 = format->name;
            }
          }
          HTSACopy(&entry_info->type, cp2);
        }
        return entry_info;
      }
      if ( entry_info->type )
      {
        free(entry_info->type);
        entry_info->type = 0;
      }
      return entry_info;
    default:
      HTSACopy(&entry_info->filename, entry);
      return entry_info;
  }
}

//----- (0811138B) --------------------------------------------------------
int __cdecl compare_EntryInfo_structs(EntryInfo *entry1, EntryInfo *entry2)
{
  char month[4]; // [esp+28h] [ebp-40h] BYREF
  int status; // [esp+2Ch] [ebp-3Ch]
  int i; // [esp+30h] [ebp-38h]
  char date2[16]; // [esp+34h] [ebp-34h] BYREF
  char date1[16]; // [esp+44h] [ebp-24h] BYREF
  char time2[8]; // [esp+54h] [ebp-14h] BYREF
  char time1[8]; // [esp+5Ch] [ebp-Ch] BYREF
  unsigned int v11; // [esp+64h] [ebp-4h]

  v11 = __readgsdword(0x14u);
  if ( HTfileSortMethod != 2 )
  {
    if ( HTfileSortMethod != 3 )
    {
      if ( HTfileSortMethod == 1 )
      {
        if ( entry1->type )
        {
          if ( entry2->type )
          {
            status = strcasecomp(entry1->type, entry2->type);
            if ( status )
              return status;
          }
        }
      }
      return strcmp(entry1->filename, entry2->filename);
    }
    if ( entry1->date && entry2->date )
    {
      if ( strlen(entry1->date) != 12 || strlen(entry2->date) != 12 )
        return strcmp(entry1->filename, entry2->filename);
      if ( !HaveYears[0] )
        set_years_and_date();
      if ( entry1->date[9] == 58 )
      {
        memcpy(date1, "9999", 5u);
        strcpy(time1, (const char *)entry1->date + 7);
        if ( time1[0] == 32 )
          time1[0] = 48;
      }
      else
      {
        strcpy(date1, (const char *)entry1->date + 8);
        memcpy(time1, "00:00", 6u);
      }
      strncpy(month, entry1->date, 3u);
      month[3] = 0;
      for ( i = 0; i <= 11 && strcasecomp(month, months[i]); ++i )
        ;
      sprintf(month, "%02d", ++i);
      strcat(date1, month);
      strncat(date1, (const char *)entry1->date + 4, 2u);
      date1[8] = 0;
      if ( date1[6] == 32 || date1[6] == 1 )
        date1[6] = 48;
      if ( date1[0] == 57 && atoi(date1) > TheDate + 1 )
      {
        for ( i = 0; i <= 3; ++i )
          date1[i] = LastYear[i];
      }
      strcat(date1, time1);
      if ( entry2->date[9] == 58 )
      {
        memcpy(date2, "9999", 5u);
        strcpy(time2, (const char *)entry2->date + 7);
        if ( time2[0] == 32 )
          time2[0] = 48;
      }
      else
      {
        strcpy(date2, (const char *)entry2->date + 8);
        memcpy(time2, "00:00", 6u);
      }
      strncpy(month, entry2->date, 3u);
      month[3] = 0;
      for ( i = 0; i <= 11 && strcasecomp(month, months[i]); ++i )
        ;
      sprintf(month, "%02d", ++i);
      strcat(date2, month);
      strncat(date2, (const char *)entry2->date + 4, 2u);
      date2[8] = 0;
      if ( date2[6] == 32 || date2[6] == 1 )
        date2[6] = 48;
      if ( date2[0] == 57 && atoi(date2) > TheDate + 1 )
      {
        for ( i = 0; i <= 3; ++i )
          date2[i] = LastYear[i];
      }
      strcat(date2, time2);
      status = strcasecomp(date2, date1);
      if ( status )
        return status;
    }
    return strcmp(entry1->filename, entry2->filename);
  }
  if ( entry1->size == entry2->size )
    return strcmp(entry1->filename, entry2->filename);
  if ( entry1->size <= entry2->size )
    return -1;
  else
    return 1;
}

//----- (08111885) --------------------------------------------------------
int __cdecl read_directory(HTParentAnchor *parent, const char *address, HTFormat format_out, HTStream *sink)
{
  char *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  char *v7; // eax
  char *data; // ebx
  char *v9; // esi
  FILE *v10; // eax
  char *v11; // ebx
  FILE *v12; // eax
  char *v13; // eax
  int v14; // ebx
  FILE *v15; // eax
  char *v16; // eax
  void (*targetClass_4)(HTStructured *); // [esp+3Ch] [ebp-ECh]
  void (*targetClass_12)(HTStructured *, char); // [esp+44h] [ebp-E4h]
  void (*targetClass_16)(HTStructured *, const char *); // [esp+48h] [ebp-E0h]
  int (*targetClass_24)(HTStructured *, int, const BOOLEAN *, const char **, int, char **); // [esp+50h] [ebp-D8h]
  int (*targetClass_28)(HTStructured *, int, char **); // [esp+54h] [ebp-D4h]
  int i; // [esp+5Ch] [ebp-CCh]
  HTBTElement *ele; // [esp+60h] [ebp-C8h]
  char *spilledname; // [esp+64h] [ebp-C4h] BYREF
  int BytesReported; // [esp+68h] [ebp-C0h]
  int BytesReceived; // [esp+6Ch] [ebp-BCh]
  HTChunk *chunk; // [esp+70h] [ebp-B8h]
  int ic; // [esp+74h] [ebp-B4h]
  HTBTree *bt; // [esp+78h] [ebp-B0h]
  char *cp; // [esp+7Ch] [ebp-ACh]
  char *p; // [esp+80h] [ebp-A8h]
  char *lastpath; // [esp+84h] [ebp-A4h] BYREF
  EntryInfo *entry_info; // [esp+88h] [ebp-A0h]
  char *filename; // [esp+8Ch] [ebp-9Ch]
  HTStructured_1 *target; // [esp+90h] [ebp-98h]
  int status; // [esp+94h] [ebp-94h]
  BOOLEAN tildeIsTop; // [esp+98h] [ebp-90h]
  BOOLEAN need_parent_link; // [esp+99h] [ebp-8Fh]
  BOOLEAN first; // [esp+9Ah] [ebp-8Eh] BYREF
  BOOLEAN WasInterrupted; // [esp+9Bh] [ebp-8Dh]
  char NumBytes[64]; // [esp+9Ch] [ebp-8Ch] BYREF
  char string_buffer[64]; // [esp+DCh] [ebp-4Ch] BYREF
  unsigned int v45; // [esp+11Ch] [ebp-Ch]

  v45 = __readgsdword(0x14u);
  WasInterrupted = 0;
  target = (HTStructured_1 *)HTML_new(parent, format_out, (HTStream_0 *)sink);
  filename = HTParse(address, &nn, 5);
  first = 1;
  lastpath = 0;
  need_parent_link = 0;
  tildeIsTop = 0;
  targetClass_4 = target->isa->_free;
  targetClass_12 = target->isa->put_character;
  targetClass_16 = target->isa->put_string;
  targetClass_24 = target->isa->start_element;
  targetClass_28 = target->isa->end_element;
  mustshow[0] = 1;
  v4 = gettext("Receiving FTP directory.");
  HTProgress(v4);
  HaveYears[0] = 0;
  if ( server_type == VMS_SERVER )
    tildeIsTop = 1;
  need_parent_link = HTDirTitles(target, parent, format_out, tildeIsTop);
  data_write_pointer = data_buffer;
  data_read_pointer = data_buffer;
  if ( !*filename )
  {
    HTSACopy(&lastpath, "/");
    goto LABEL_25;
  }
  if ( !strcmp(filename, "/") )
  {
    HTSACopy(&lastpath, "/foo/..");
    goto LABEL_25;
  }
  p = strrchr(filename, 47);
  if ( server_type == CMS_SERVER )
    HTSACopy(&lastpath, filename);
  else
    HTSACopy(&lastpath, p + 1);
  cp = strrchr(lastpath, 59);
  if ( cp && !strncasecomp(cp + 1, "type=", 5) )
  {
    if ( ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 0x200) != 0 )
    {
      if ( toupper((unsigned __int8)cp[6]) == 68 )
        goto LABEL_24;
    }
    else if ( cp[6] == 68 )
    {
      goto LABEL_24;
    }
    if ( ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 0x200) != 0 )
    {
      if ( toupper((unsigned __int8)cp[6]) == 65 )
        goto LABEL_24;
    }
    else if ( cp[6] == 65 )
    {
      goto LABEL_24;
    }
    if ( ((*__ctype_b_loc())[(unsigned __int8)cp[6]] & 0x200) != 0 )
    {
      if ( toupper((unsigned __int8)cp[6]) != 73 )
        goto LABEL_25;
    }
    else if ( cp[6] != 73 )
    {
      goto LABEL_25;
    }
LABEL_24:
    *cp = 0;
  }
LABEL_25:
  if ( filename )
  {
    free(filename);
    filename = 0;
  }
  bt = HTBTree_new((HTComparer)compare_EntryInfo_structs);
  chunk = HTChunkCreate(128);
  BytesReceived = 0;
  BytesReported = 0;
  spilledname = 0;
  targetClass_12((HTStructured *)target, 10);
  ic = 0;
  while ( 2 )
  {
    if ( ic == -1 )
      goto unload_btree;
    HTChunkClear(chunk);
    if ( !HTCheckForInterrupt() )
    {
      interrupted_in_next_data_char = 0;
LABEL_36:
      while ( 2 )
      {
        ic = next_data_char();
        while ( 1 )
        {
          if ( interrupted_in_next_data_char )
          {
            if ( WWW_TraceFlag[0] )
            {
              v6 = TraceFP();
              fprintf(v6, "read_directory: interrupted_in_next_data_char after %d bytes\n", BytesReceived);
            }
            WasInterrupted = 1;
            if ( !BytesReceived )
            {
              targetClass_4((HTStructured *)target);
              HTBTreeAndObject_free(bt);
              if ( spilledname )
              {
                free(spilledname);
                spilledname = 0;
              }
              return -29998;
            }
            goto unload_btree;
          }
          if ( (_BYTE)ic != 13 && (_BYTE)ic != 10 )
            break;
          if ( !chunk->size )
            goto LABEL_36;
          if ( server_type != VMS_SERVER )
            goto LABEL_60;
          if ( data_read_pointer < data_write_pointer && data_read_pointer[1] == 32 )
          {
            ++data_read_pointer;
            goto LABEL_36;
          }
          if ( data_read_pointer < data_write_pointer )
            goto LABEL_60;
          status = HTDoRead(data_soc, data_buffer, 0x800u);
          if ( status != -29998 )
          {
            if ( status > 0 )
            {
              data_write_pointer = (char *)(status + 136001376);
              data_read_pointer = data_buffer;
              if ( data_buffer[0] == 32 )
              {
                ++data_read_pointer;
                goto LABEL_36;
              }
            }
            else
            {
              ic = -1;
            }
            goto LABEL_60;
          }
          interrupted_in_next_data_char = 1;
        }
        if ( ic != -1 )
        {
          HTChunkPutc(chunk, ic);
          continue;
        }
        break;
      }
LABEL_60:
      HTChunkTerminate(chunk);
      BytesReceived += chunk->size;
      if ( BytesReported + 1024 < BytesReceived )
      {
        v7 = gettext("Transferred %d bytes");
        sprintf(NumBytes, v7, BytesReceived);
        HTProgress(NumBytes);
        BytesReported = BytesReceived;
      }
      if ( ic != -1 || chunk->size != 1 )
      {
        if ( WWW_TraceFlag[0] )
        {
          data = chunk->data;
          v9 = lastpath;
          v10 = TraceFP();
          fprintf(v10, "HTFTP: Line in %s is %s\n", v9, data);
        }
        entry_info = parse_dir_entry(chunk->data, &first, &spilledname);
        if ( entry_info->display )
        {
          if ( spilledname )
          {
            free(spilledname);
            spilledname = 0;
          }
          if ( WWW_TraceFlag[0] )
          {
            v11 = entry_info->filename;
            v12 = TraceFP();
            fprintf(v12, "Adding file to BTree: %s\n", v11);
          }
          HTBTree_add(bt, entry_info);
        }
        else
        {
          free_entryinfo_struct_contents(entry_info);
          if ( entry_info )
          {
            free(entry_info);
            entry_info = 0;
          }
        }
        continue;
      }
      goto unload_btree;
    }
    break;
  }
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "read_directory: interrupted after %d bytes\n", BytesReceived);
  }
  WasInterrupted = 1;
  if ( BytesReceived )
  {
unload_btree:
    HTChunkFree(chunk);
    if ( spilledname )
    {
      free(spilledname);
      spilledname = 0;
    }
    if ( help_message_cache_non_empty() )
    {
      targetClass_24((HTStructured *)target, 86, 0, 0, -1, 0);
      targetClass_24((HTStructured *)target, 54, 0, 0, -1, 0);
      targetClass_12((HTStructured *)target, 10);
      v13 = help_message_cache_contents();
      targetClass_16((HTStructured *)target, v13);
      init_help_message_cache();
      targetClass_24((HTStructured *)target, 54, 0, 0, -1, 0);
    }
    else
    {
      targetClass_24((HTStructured *)target, 86, 0, 0, -1, 0);
    }
    targetClass_12((HTStructured *)target, 10);
    for ( ele = HTBTree_next(bt, 0); ele; ele = HTBTree_next(bt, ele) )
    {
      entry_info = (EntryInfo *)ele->object;
      if ( entry_info->date )
      {
        targetClass_16((HTStructured *)target, entry_info->date);
        targetClass_16((HTStructured *)target, "  ");
      }
      else
      {
        targetClass_16((HTStructured *)target, "     * ");
      }
      if ( entry_info->type )
      {
        for ( i = 0; entry_info->type[i] && i <= 15; ++i )
          targetClass_12((HTStructured *)target, entry_info->type[i]);
        while ( i <= 16 )
        {
          targetClass_12((HTStructured *)target, 32);
          ++i;
        }
      }
      HTDirEntry(target, lastpath, entry_info->filename);
      targetClass_16((HTStructured *)target, entry_info->filename);
      targetClass_28((HTStructured *)target, 0, 0);
      if ( entry_info->size )
      {
        if ( entry_info->size > 0x3FF )
          sprintf(string_buffer, "  %uKb", entry_info->size >> 10);
        else
          sprintf(string_buffer, "  %u bytes", entry_info->size);
        targetClass_16((HTStructured *)target, string_buffer);
      }
      else if ( entry_info->linkname )
      {
        targetClass_16((HTStructured *)target, " -> ");
        targetClass_16((HTStructured *)target, entry_info->linkname);
      }
      targetClass_12((HTStructured *)target, 10);
      free_entryinfo_struct_contents(entry_info);
    }
    targetClass_28((HTStructured *)target, 86, 0);
    targetClass_28((HTStructured *)target, 17, 0);
    targetClass_4((HTStructured *)target);
    HTBTreeAndObject_free(bt);
    if ( lastpath )
    {
      free(lastpath);
      lastpath = 0;
    }
    if ( WasInterrupted || data_soc != -1 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v14 = data_soc;
        v15 = TraceFP();
        fprintf(v15, "HTFTP: Closing data socket %d\n", v14);
      }
      status = close(data_soc);
      if ( status == -1 )
        HTInetStatus("close");
      data_soc = -1;
    }
    if ( WasInterrupted || HTCheckForInterrupt() )
    {
      mustshow[0] = 1;
      v16 = gettext("Data transfer interrupted.");
      HTProgress(v16);
    }
    return 200;
  }
  targetClass_4((HTStructured *)target);
  HTBTreeAndObject_free(bt);
  if ( spilledname )
  {
    free(spilledname);
    spilledname = 0;
  }
  return -29998;
}
// 91: found interdependent unknown calls

//----- (0811265A) --------------------------------------------------------
int __cdecl setup_connection(const char *name, HTParentAnchor *anchor)
{
  FILE *v2; // eax
  FILE *v3; // eax
  char *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  int v10; // ebx
  FILE *v11; // eax
  char *v12; // eax
  int v13; // ebx
  FILE *v14; // eax
  FILE *v15; // eax
  socklen_t sslen; // [esp+3Ch] [ebp-1BCh] BYREF
  int p1; // [esp+40h] [ebp-1B8h] BYREF
  int p0; // [esp+44h] [ebp-1B4h] BYREF
  int h3; // [esp+48h] [ebp-1B0h] BYREF
  int h2; // [esp+4Ch] [ebp-1ACh] BYREF
  int h1; // [esp+50h] [ebp-1A8h] BYREF
  int h0; // [esp+54h] [ebp-1A4h] BYREF
  const char *p; // [esp+58h] [ebp-1A0h]
  char *command; // [esp+5Ch] [ebp-19Ch] BYREF
  int status; // [esp+60h] [ebp-198h]
  int retry; // [esp+64h] [ebp-194h]
  char c3; // [esp+6Bh] [ebp-18Dh] BYREF
  char c2; // [esp+6Ch] [ebp-18Ch] BYREF
  char c1; // [esp+6Dh] [ebp-18Bh] BYREF
  char c0; // [esp+6Eh] [ebp-18Ah] BYREF
  char dst[257]; // [esp+6Fh] [ebp-189h] BYREF
  sockaddr_storage ss_0; // [esp+170h] [ebp-88h] BYREF
  unsigned int v34; // [esp+1F0h] [ebp-8h]

  v34 = __readgsdword(0x14u);
  status = -99;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "setup_connection(%s)\n", name);
  }
  use_list[0] = 0;
  server_type = GENERIC_SERVER;
  Broken_RETR = 0;
  Broken_EPSV = 0;
  for ( retry = 0; ; ++retry )
  {
    if ( retry > 1 )
      goto LABEL_63;
    status = get_connection(name, anchor);
    if ( status < 0 )
      goto LABEL_63;
    if ( !ftp_local_passive[0] )
      break;
    command = 0;
    p = "?";
    data_soc = status;
    if ( Broken_EPSV )
    {
      status = 1;
    }
    else
    {
      p = "EPSV";
      status = send_cmd_1("EPSV");
    }
    if ( status >= 0 )
    {
      if ( status == 2 )
        goto LABEL_26;
      p = "PASV";
      status = send_cmd_1("PASV");
      if ( status >= 0 )
      {
        if ( status != 2 )
        {
          status = -status;
          goto LABEL_63;
        }
LABEL_26:
        if ( !strcmp(p, "PASV") )
        {
          for ( p = response_text; *p && *p != 44; ++p )
            ;
          do
            --p;
          while ( p > response_text && *p > 47 && *p <= 57 );
          status = sscanf(p + 1, "%d,%d,%d,%d,%d,%d", &h0, &h1, &h2, &h3, &p0, &p1);
          if ( status <= 3 )
          {
            v6 = TraceFP();
            fwrite("HTFTP: PASV reply has no inet address!\n", 1u, 0x27u, v6);
            status = -99;
            goto LABEL_63;
          }
          passive_port = ((_WORD)p0 << 8) + p1;
          sprintf(dst, "%d.%d.%d.%d", h0, h1, h2, h3);
        }
        else if ( !strcmp(p, "EPSV") )
        {
          for ( p = response_text; *p && ((*__ctype_b_loc())[*p] & 0x2000) == 0; ++p )
            ;
          while ( *p && *p != 40 )
            ++p;
          status = sscanf(p, "(%c%c%c%d%c)", &c0, &c1, &c2, &p0, &c3);
          if ( status != 5 )
          {
            v7 = TraceFP();
            fwrite("HTFTP: EPSV reply has invalid format!\n", 1u, 0x26u, v7);
            status = -99;
            goto LABEL_63;
          }
          passive_port = p0;
          sslen = 128;
          if ( getpeername(control->socket, (struct sockaddr *)&ss_0, &sslen) < 0 )
          {
            v8 = TraceFP();
            fwrite("HTFTP: getpeername(control) failed\n", 1u, 0x23u, v8);
            status = -99;
            goto LABEL_63;
          }
          if ( getnameinfo((const struct sockaddr *)&ss_0, sslen, dst, 0x101u, 0, 0, 1u) )
          {
            v9 = TraceFP();
            fwrite("HTFTP: getnameinfo failed\n", 1u, 0x1Au, v9);
            status = -99;
            goto LABEL_63;
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          v10 = passive_port;
          v11 = TraceFP();
          fprintf(v11, "HTFTP: Server is listening on port %d\n", v10);
        }
        HTSprintf0(&command, "%s//%s:%d/", "ftp:", dst, passive_port);
        status = HTDoConnect(command, "FTP data", passive_port, &data_soc);
        if ( command )
        {
          free(command);
          command = 0;
        }
        if ( status < 0 )
        {
          v12 = gettext("connect for data");
          HTInetStatus(v12);
          close(data_soc);
          goto LABEL_63;
        }
        if ( WWW_TraceFlag[0] )
        {
          v13 = data_soc;
          v14 = TraceFP();
          fprintf(v14, "FTP data connected, socket %d\n", v13);
        }
LABEL_60:
        status = 0;
        goto LABEL_63;
      }
    }
LABEL_61:
    ;
  }
  status = get_listen_socket();
  if ( status < 0 )
  {
    close(control->socket);
    control->socket = -1;
    if ( have_socket[0] )
      close_master_socket();
    goto LABEL_63;
  }
  status = response(port_command);
  if ( status != -29998 )
  {
    if ( status == 2 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "HTFTP: Port defined.\n");
      }
      goto LABEL_60;
    }
    if ( status >= 0 )
    {
      status = -status;
      goto LABEL_63;
    }
    goto LABEL_61;
  }
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTFTP: Interrupted in response (port_command)\n");
  }
  mustshow[0] = 1;
  v4 = gettext("Connection interrupted.");
  HTProgress(v4);
  close(control->socket);
  control->socket = -1;
  close_master_socket();
  status = -29998;
LABEL_63:
  if ( WWW_TraceFlag[0] )
  {
    v15 = TraceFP();
    fprintf(v15, "setup_connection returns %d\n", status);
  }
  return status;
}

//----- (08112DEA) --------------------------------------------------------
int __cdecl HTFTPLoad(const char *name, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink)
{
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  int v9; // ebx
  HTAtom *v10; // eax
  HTAtom *v11; // eax
  FILE *v12; // eax
  char *v13; // ebx
  FILE *v14; // eax
  FILE *v15; // eax
  char *v16; // ebx
  FILE *v17; // eax
  char *v18; // ebx
  FILE *v19; // eax
  char *v20; // ebx
  char *v21; // ebx
  char *v22; // ebx
  FILE *v23; // eax
  const char *v24; // ebx
  FILE *v25; // eax
  const char *v26; // ebx
  FILE *v27; // eax
  FILE *v28; // eax
  FILE *v29; // eax
  FILE *v30; // eax
  FILE *v31; // eax
  int v33; // ebx
  FILE *v34; // eax
  HTAtom *v35; // eax
  HTAtom *v36; // eax
  HTAtom *v37; // eax
  HTAtom *v38; // eax
  char *v39; // eax
  int v40; // ebx
  FILE *v41; // eax
  FILE *v44; // eax
  int v45; // ebx
  FILE *v46; // eax
  int socket; // ebx
  FILE *v48; // eax
  const char *v50; // [esp+18h] [ebp-120h]
  int v53; // [esp+24h] [ebp-114h]
  BOOLEAN v54; // [esp+28h] [ebp-110h]
  const char *v55; // [esp+2Ch] [ebp-10Ch]
  CompressFileType cft; // [esp+50h] [ebp-E8h]
  int rootlen; // [esp+54h] [ebp-E4h] BYREF
  char *FileName; // [esp+58h] [ebp-E0h]
  int rv; // [esp+5Ch] [ebp-DCh]
  int check; // [esp+60h] [ebp-D8h]
  int cplen; // [esp+64h] [ebp-D4h]
  int i; // [esp+68h] [ebp-D0h]
  char *cp2_1; // [esp+6Ch] [ebp-CCh]
  char *cp1; // [esp+70h] [ebp-C8h]
  const char *mode; // [esp+74h] [ebp-C4h]
  char *cp2_0; // [esp+78h] [ebp-C0h]
  char *cp2; // [esp+7Ch] [ebp-BCh]
  char *cp; // [esp+80h] [ebp-B8h]
  char *types; // [esp+84h] [ebp-B4h]
  const char *type; // [esp+88h] [ebp-B0h]
  char *vmsname; // [esp+8Ch] [ebp-ACh] BYREF
  char *fname; // [esp+90h] [ebp-A8h]
  char *filename; // [esp+94h] [ebp-A4h] BYREF
  HTFormat format; // [esp+98h] [ebp-A0h]
  int outstanding; // [esp+9Ch] [ebp-9Ch]
  int final_status; // [esp+A0h] [ebp-98h]
  int status; // [esp+A4h] [ebp-94h]
  HTAtom *encoding; // [esp+A8h] [ebp-90h] BYREF
  BOOLEAN found_tilde; // [esp+ACh] [ebp-8Ch]
  BOOLEAN included_device; // [esp+ADh] [ebp-8Bh]
  BOOLEAN binary; // [esp+AEh] [ebp-8Ah]
  BOOLEAN isDirectory; // [esp+AFh] [ebp-89h]
  sockaddr_storage soc_address; // [esp+B0h] [ebp-88h] BYREF
  unsigned int v84; // [esp+130h] [ebp-8h]

  v84 = __readgsdword(0x14u);
  isDirectory = 0;
  encoding = 0;
  outstanding = 1;
  if ( WWW_TraceFlag[0] )
  {
    if ( ftp_local_passive[0] )
      v50 = "passive";
    else
      v50 = "normal";
    v4 = TraceFP();
    fprintf(v4, "HTFTPLoad(%s) %s connection\n", name, v50);
  }
  HTReadProgress(0LL, 0LL);
  status = setup_connection(name, anchor);
  if ( status < 0 )
    return status;
  filename = HTParse(name, &nn, 5);
  fname = filename;
  vmsname = 0;
  type = 0;
  types = 0;
  if ( server_type == CMS_SERVER )
  {
    cp = strstr(filename, "%2");
    if ( cp )
    {
      if ( ((*__ctype_b_loc())[(unsigned __int8)cp[2]] & 0x200) != 0 ? toupper((unsigned __int8)cp[2]) == 70 : cp[2] == 70 )
      {
        if ( fname )
        {
          free(fname);
          fname = 0;
        }
        init_help_message_cache();
        close(control->socket);
        control->socket = -1;
        if ( WWW_TraceFlag[0] )
        {
          v5 = TraceFP();
          fprintf(v5, "HTFTP: Rejecting path due to illegal escaped slash.\n");
        }
        return -1;
      }
    }
  }
  if ( *filename )
  {
    types = strrchr(filename, 59);
    type = types;
    if ( types )
    {
      if ( !strncasecomp(type + 1, "type=", 5) )
      {
        v53 = ((*__ctype_b_loc())[*((unsigned __int8 *)type + 6)] & 0x200) != 0 ? toupper(*((unsigned __int8 *)type + 6)) : *((unsigned __int8 *)type + 6);
        switch ( v53 )
        {
          case 'D':
            *types = 0;
            type = "D";
            break;
          case 'I':
            *types = 0;
            type = "I";
            break;
          case 'A':
            *types = 0;
            type = "A";
            break;
          default:
            type = &nn;
            break;
        }
        if ( !*filename )
        {
          *filename = 47;
          filename[1] = 0;
        }
      }
      if ( *type && WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "HTFTP: type=%s\n", type);
      }
    }
  }
  else
  {
    HTSACopy(&filename, "/");
    type = "D";
  }
  HTUnEscape(filename);
  if ( WWW_TraceFlag[0] )
  {
    v7 = filename;
    v8 = TraceFP();
    fprintf(v8, "HTFTP: UnEscaped %s\n", v7);
  }
  if ( filename[1] == 126 )
  {
    rootlen = 0;
    cp2 = strchr(filename + 1, 47);
    if ( cp2 )
      *cp2 = 0;
    status = send_cmd_1("PWD");
    if ( status == 2 && response_text[5] == 47 )
    {
      status = send_cmd_2("CWD", filename + 1);
      if ( status == 2 )
      {
        HTSACopy((char **)&rootlen, filename + 1);
        if ( cp2 )
        {
          *cp2 = 47;
          v9 = rootlen;
          if ( *(_BYTE *)(v9 + strlen((const char *)rootlen) - 1) == 47 )
            HTSACat((char **)&rootlen, cp2 + 1);
          else
            HTSACat((char **)&rootlen, cp2);
          cp2 = 0;
        }
        if ( fname )
        {
          free(fname);
          fname = 0;
        }
        filename = (char *)rootlen;
        fname = (char *)rootlen;
      }
    }
    if ( cp2 )
      *cp2 = 47;
  }
  if ( strlen(filename) <= 3
    || (cp2_0 = strrchr(filename, 46)) == 0
    || strncasecomp(cp2_0, ".me", 3)
    || cp2_0[3] && cp2_0[3] != 59
    || server_type == UNIX_SERVER && (filename + 3 >= cp2_0 || strncasecomp(cp2_0 - 4, "read.me", 7)) )
  {
    format = HTFileFormat(filename, &encoding, 0);
  }
  else
  {
    *cp2_0 = 0;
    format = HTFileFormat(filename, &encoding, 0);
    *cp2_0 = 46;
  }
  format = HTCharsetFormat(format, anchor, -1);
  v10 = HTAtom_for("8bit");
  v54 = 0;
  if ( v10 != encoding )
  {
    v11 = HTAtom_for("7bit");
    if ( v11 != encoding )
      v54 = 1;
  }
  binary = v54;
  if ( !v54
    && (format_out == WWW_SOURCE || HTAtom_for("www/download") == format_out || HTAtom_for("www/dump") == format_out)
    && server_type != CMS_SERVER )
  {
    binary = 1;
  }
  if ( !binary && type && *type == 73 )
  {
    binary = 1;
  }
  else if ( binary && type && *type == 65 )
  {
    binary = 0;
  }
  if ( control->binary != binary )
  {
    if ( binary )
      v55 = "I";
    else
      v55 = "A";
    mode = v55;
    status = send_cmd_2("TYPE", v55);
    if ( status != 2 )
    {
      init_help_message_cache();
      return -abs32(status);
    }
    control->binary = binary;
  }
  if ( server_type == VMS_SERVER )
  {
    included_device = 0;
    found_tilde = 0;
    if ( strchr(filename, 58) || strchr(filename, 91) )
    {
      if ( fname )
      {
        free(fname);
        fname = 0;
      }
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if ( WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "HTFTP: Rejecting path due to non-Unix-style syntax.\n");
      }
      return -1;
    }
    if ( strncmp(filename, "//", 2u) )
      goto LABEL_147;
    included_device = 1;
    for ( i = 0; filename[i + 1]; ++i )
      filename[i] = filename[i + 1];
    filename[i] = 0;
    if ( WWW_TraceFlag[0] )
    {
      v13 = filename;
      v14 = TraceFP();
      fprintf(v14, "HTFTP: Trimmed '%s'\n", v13);
    }
    cp = HTVMS_name(&nn, filename);
    if ( WWW_TraceFlag[0] )
    {
      v15 = TraceFP();
      fprintf(v15, "HTFTP: VMSized '%s'\n", cp);
    }
    cp1 = strrchr(cp, 93);
    if ( cp1 )
    {
      strcpy(filename, ++cp1);
      if ( WWW_TraceFlag[0] )
      {
        v16 = filename;
        v17 = TraceFP();
        fprintf(v17, "HTFTP: Filename '%s'\n", v16);
      }
      *cp1 = 0;
      status = send_cmd_2("CWD", cp);
      if ( status != 2 )
      {
        rootlen = 0;
        cp1 = strchr(cp, 91);
        if ( !cp1 )
        {
          if ( fname )
          {
            free(fname);
            fname = 0;
          }
          goto LABEL_208;
        }
        *cp1++ = 0;
        status = send_cmd_2("CWD", cp);
        if ( status != 2 )
        {
          if ( fname )
          {
            free(fname);
            fname = 0;
          }
          goto LABEL_208;
        }
        HTSprintf0((char **)&rootlen, "[.%s", cp1);
        status = send_cmd_2("CWD", (const char *)rootlen);
        if ( rootlen )
        {
          free((void *)rootlen);
          rootlen = 0;
        }
        if ( status != 2 )
        {
          if ( fname )
          {
            free(fname);
            fname = 0;
          }
          goto LABEL_208;
        }
      }
      goto LABEL_147;
    }
    cp1 = strchr(cp, 58);
    if ( !cp1 || strchr(cp, 91) || strchr(cp, 93) )
    {
      if ( strcmp(cp, filename + 1) )
        goto LABEL_147;
      status = send_cmd_2("CWD", cp);
      if ( status != 2 )
      {
        HTSprintf0(&vmsname, "%s:", cp);
        status = send_cmd_2("CWD", vmsname);
        if ( status != 2 )
        {
          if ( fname )
          {
            free(fname);
            fname = 0;
          }
          goto LABEL_208;
        }
      }
    }
    else
    {
      if ( !*++cp1 )
        goto LABEL_147;
      cplen = cp1 - cp;
      strcpy(filename, cp1);
      if ( WWW_TraceFlag[0] )
      {
        v18 = filename;
        v19 = TraceFP();
        fprintf(v19, "HTFTP: Filename '%s'\n", v18);
      }
      HTSprintf0(&vmsname, "%.*s[%s]", cplen, cp, filename);
      status = send_cmd_2("CWD", vmsname);
      if ( status != 2 )
      {
        HTSprintf(&vmsname, "%.*s[000000]", cplen, cp);
        status = send_cmd_2("CWD", vmsname);
        if ( status != 2 )
        {
          HTSprintf(&vmsname, "%.*s", cplen, cp);
          status = send_cmd_2("CWD", vmsname);
          if ( status != 2 )
          {
            if ( fname )
            {
              free(fname);
              fname = 0;
            }
            goto LABEL_208;
          }
        }
        goto LABEL_147;
      }
    }
    HTSprintf0(&vmsname, "000000");
    filename = vmsname;
LABEL_147:
    if ( strlen(filename) > 1 )
    {
      v20 = filename;
      if ( v20[strlen(filename) - 1] == 47 )
      {
        v21 = filename;
        v21[strlen(filename) - 1] = 0;
      }
    }
    if ( !strcmp(filename, "/~")
      || included_device && !strcmp(filename, "000000")
      || strlen(filename) == 1 && *filename == 47 )
    {
      isDirectory = 1;
      status = send_cmd_1("LIST");
      if ( fname )
      {
        free(fname);
        fname = 0;
      }
      if ( status != 1 )
        goto LABEL_208;
      goto listen;
    }
    if ( !strncmp(filename, "/~", 2u) )
    {
      filename += 2;
      found_tilde = 1;
    }
    if ( WWW_TraceFlag[0] )
    {
      v22 = filename;
      v23 = TraceFP();
      fprintf(v23, "check '%s' to translate x/y/ to [.x.y]\n", v22);
    }
    if ( !included_device )
    {
      cp = strchr(filename, 47);
      if ( cp )
      {
        cp1 = strrchr(cp, 47);
        if ( cp1 )
        {
          if ( cp1 - cp > 1 )
          {
            rootlen = 0;
            HTSprintf0((char **)&rootlen, "[.%.*s]", cp1 - cp - 1, cp + 1);
            if ( WWW_TraceFlag[0] )
            {
              v24 = (const char *)rootlen;
              v25 = TraceFP();
              fprintf(v25, "change path '%s'\n", v24);
            }
            while ( 1 )
            {
              cp2_1 = strrchr((const char *)rootlen, 47);
              if ( !cp2_1 )
                break;
              *cp2_1 = 46;
            }
            if ( WWW_TraceFlag[0] )
            {
              v26 = (const char *)rootlen;
              v27 = TraceFP();
              fprintf(v27, "...to  path '%s'\n", v26);
            }
            status = send_cmd_2("CWD", (const char *)rootlen);
            if ( rootlen )
            {
              free((void *)rootlen);
              rootlen = 0;
            }
            if ( status == 2 )
            {
              filename = cp1 + 1;
              goto LABEL_215;
            }
            if ( fname )
            {
              free(fname);
              fname = 0;
            }
LABEL_208:
            init_help_message_cache();
            close(control->socket);
            control->socket = -1;
            return -abs32(status);
          }
        }
      }
    }
    if ( !included_device && !found_tilde )
      ++filename;
LABEL_215:
    if ( type && *type == 68 )
    {
      status = 5;
    }
    else
    {
      status = send_cmd_2("RETR", filename);
      if ( status > 4 && Broken_RETR )
      {
        if ( WWW_TraceFlag[0] )
        {
          v28 = TraceFP();
          fprintf(v28, "{{reconnecting...\n");
        }
        close_connection(control);
        check = setup_connection(name, anchor);
        if ( WWW_TraceFlag[0] )
        {
          v29 = TraceFP();
          fprintf(v29, "...done }}reconnecting\n");
        }
        if ( check < 0 )
          return check;
      }
    }
    if ( status != 1 )
    {
      if ( strcmp(filename, "/") )
        init_help_message_cache();
      status = send_cmd_2("CWD", filename);
      if ( status == 2 )
      {
        isDirectory = 1;
        if ( use_list[0] )
          status = send_cmd_1("LIST");
        else
          status = send_cmd_1("NLST");
      }
    }
    if ( fname )
    {
      free(fname);
      fname = 0;
    }
    if ( vmsname )
    {
      free(vmsname);
      vmsname = 0;
    }
    if ( status != 1 )
    {
      init_help_message_cache();
      close(control->socket);
      control->socket = -1;
      if ( status >= 0 )
        return -status;
      else
        return status;
    }
    goto listen;
  }
  if ( server_type != CMS_SERVER )
  {
    if ( !strncmp(filename, "//", 2u) )
      ++filename;
    goto LABEL_215;
  }
  if ( (strlen(filename) != 1 || *filename != 47)
    && (strncasecomp(filename + 1, "vmsysu:", 7) || (cp = strchr(filename + 1, 46)) == 0 || strchr(cp, 47))
    && (strncasecomp(filename + 1, "anonymou.", 9) || strchr(filename + 1, 47)) )
  {
    ++filename;
    while ( 1 )
    {
      cp = strchr(filename, 47);
      if ( !cp )
        goto LABEL_215;
      *cp++ = 0;
      status = send_cmd_2("CWD", filename);
      if ( status == 2 )
      {
        if ( !*cp )
        {
          isDirectory = 1;
          if ( use_list[0] )
            status = send_cmd_1("LIST");
          else
            status = send_cmd_1("NLST");
          if ( fname )
          {
            free(fname);
            fname = 0;
          }
          if ( status == 1 )
          {
            init_help_message_cache();
            goto listen;
          }
          goto LABEL_208;
        }
        filename = cp;
      }
    }
  }
  if ( filename[1] )
  {
    status = send_cmd_2("CWD", filename + 1);
    if ( status != 2 )
      goto LABEL_208;
  }
  isDirectory = 1;
  if ( use_list[0] )
    status = send_cmd_1("LIST");
  else
    status = send_cmd_1("NLST");
  if ( fname )
  {
    free(fname);
    fname = 0;
  }
  if ( status != 1 )
    goto LABEL_208;
listen:
  if ( !ftp_local_passive[0] )
  {
    rootlen = 128;
    status = accept(master_socket, (struct sockaddr *)&soc_address, (socklen_t *)&rootlen);
    if ( status < 0 )
    {
      init_help_message_cache();
      return HTInetStatus("accept");
    }
    if ( WWW_TraceFlag[0] )
    {
      v30 = TraceFP();
      fprintf(v30, "TCP: Accepted new socket %d\n", status);
    }
    data_soc = status;
  }
  if ( isDirectory )
  {
    if ( server_type == UNIX_SERVER
      && !unsure_type
      && !strcmp(response_text, "150 Opening ASCII mode data connection for /bin/dl.\n") )
    {
      if ( WWW_TraceFlag[0] )
      {
        v31 = TraceFP();
        fprintf(v31, "HTFTP: Treating as \"dls\" server.\n");
      }
      server_type = DLS_SERVER;
    }
    final_status = read_directory(anchor, name, format_out, sink);
    if ( final_status <= 0 )
    {
      outstanding = 0;
    }
    else if ( server_type != CMS_SERVER && outstanding-- > 0 )
    {
      status = response(0);
      if ( status < 0 || status == 2 && !strncmp(response_text, "221", 3u) )
        outstanding = 0;
    }
    if ( data_soc != -1 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v33 = data_soc;
        v34 = TraceFP();
        fprintf(v34, "HTFTP: Closing data socket %d\n", v33);
      }
      status = close(data_soc);
      if ( status == -1 )
        HTInetStatus("close");
    }
    status = final_status;
  }
  else
  {
    FileName = HTParse(name, &nn, 5);
    init_help_message_cache();
    HTUnEscape(FileName);
    if ( !encoding
      || (v35 = HTAtom_for("identity"), v35 == encoding)
      || (v36 = HTAtom_for("8bit"), v36 == encoding)
      || (v37 = HTAtom_for("binary"), v37 == encoding)
      || (v38 = HTAtom_for("7bit"), v38 == encoding) )
    {
      cft = HTCompressFileType(FileName, "._-", &rootlen);
      if ( cft )
      {
        FileName[rootlen] = 0;
        format = HTFileFormat(FileName, &encoding, 0);
        format = HTCharsetFormat(format, anchor, -1);
        HTSACopy(&anchor->content_type, format->name);
        format = HTAtom_for("www/compressed");
        if ( cft == cftGzip )
        {
          HTSACopy(&anchor->content_encoding, "x-gzip");
        }
        else if ( (unsigned int)cft > cftGzip )
        {
          if ( cft == cftBzip2 )
          {
            HTSACopy(&anchor->content_encoding, "x-bzip2");
          }
          else if ( cft == cftDeflate )
          {
            HTSACopy(&anchor->content_encoding, "x-deflate");
          }
        }
        else
        {
          HTSACopy(&anchor->content_encoding, "x-compress");
        }
      }
    }
    else
    {
      HTSACopy(&anchor->content_type, format->name);
      HTSACopy(&anchor->content_encoding, encoding->name);
      format = HTAtom_for("www/compressed");
    }
    if ( FileName )
    {
      free(FileName);
      FileName = 0;
    }
    mustshow[0] = 1;
    v39 = gettext("Receiving FTP file.");
    HTProgress(v39);
    rv = HTParseSocket(format, format_out, anchor, data_soc, (HTStream_5 *)sink);
    HTInitInput(control->socket);
    if ( rv >= 0 )
    {
      status = 2;
    }
    else
    {
      if ( rv == -2 )
      {
        --outstanding;
      }
      else if ( rv == -29998 || rv == -1 )
      {
        outstanding = 0;
      }
      if ( WWW_TraceFlag[0] )
      {
        v40 = data_soc;
        v41 = TraceFP();
        fprintf(v41, "HTFTP: Closing data socket %d\n", v40);
      }
      status = close(data_soc);
    }
    if ( status >= 0 || rv == -29998 || rv == -1 )
    {
      if ( rv != 200 && outstanding-- != 0 )
      {
        status = response(0);
        if ( status != 2 && rv != -29998 && rv != -1 )
        {
          data_soc = -1;
          init_help_message_cache();
          return HTLoadError((HTStream_0 *)sink, 500, response_text);
        }
        if ( status > 0 )
        {
          if ( status == 2 && !strncmp(response_text, "221", 3u) )
            outstanding = 0;
        }
        else
        {
          outstanding = 0;
        }
      }
    }
    else
    {
      HTInetStatus("close");
    }
    final_status = 200;
  }
  do
  {
    if ( outstanding-- <= 0 )
      break;
    if ( status <= 0 )
      break;
    status = response(0);
  }
  while ( status != 2 || strncmp(response_text, "221", 3u) );
  data_soc = -1;
  if ( WWW_TraceFlag[0] )
  {
    v44 = TraceFP();
    fprintf(v44, "HTFTPLoad: normal end; ");
  }
  if ( control->socket >= 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      socket = control->socket;
      v48 = TraceFP();
      fprintf(v48, "closing control socket %d\n", socket);
    }
    status = close(control->socket);
    if ( status == -1 )
      HTInetStatus("control connection close");
  }
  else if ( WWW_TraceFlag[0] )
  {
    v45 = control->socket;
    v46 = TraceFP();
    fprintf(v46, "control socket is %d\n", v45);
  }
  control->socket = -1;
  init_help_message_cache();
  return final_status;
}
// 8114661: conditional instruction was optimized away because %type.4!=0
// 8114C71: conditional instruction was optimized away because %cft.4==1

//----- (0811506E) --------------------------------------------------------
void HTClearFTPPassword()
{
  if ( user_entered_password )
  {
    free(user_entered_password);
    user_entered_password = 0;
  }
}

//----- (08115098) --------------------------------------------------------
int __cdecl HTInetStatus(const char *where)
{
  int *v1; // eax
  char *v2; // ebx
  int v3; // esi
  FILE *v4; // edx
  int saved_errno; // [esp+28h] [ebp-10h]

  saved_errno = *__errno_location();
  if ( WWW_TraceFlag[0] )
  {
    v1 = __errno_location();
    v2 = strerror(*v1);
    v3 = *__errno_location();
    v4 = TraceFP();
    fprintf(v4, "TCP: Error %d in `SOCKET_ERRNO' after call to %s() failed.\n\t%s\n", v3, where, v2);
  }
  *__errno_location() = saved_errno;
  return -*__errno_location();
}

//----- (08115117) --------------------------------------------------------
unsigned int __cdecl HTCardinal(int *pstatus, char **pp, unsigned int max_value)
{
  unsigned int n; // [esp+10h] [ebp-4h]

  if ( **pp > 47 && **pp <= 57 )
  {
    n = 0;
    while ( **pp > 47 && **pp <= 57 )
      n = 10 * n + *(*pp)++ - 48;
    if ( n <= max_value )
    {
      return n;
    }
    else
    {
      *pstatus = -4;
      return 0;
    }
  }
  else
  {
    *pstatus = -3;
    return 0;
  }
}

//----- (081151B7) --------------------------------------------------------
const char *__cdecl HTInetString(SockA *soc_in)
{
  socklen_t salen; // [esp+24h] [ebp-4h]

  if ( (_WORD)soc_in == 10 )
    salen = 28;
  else
    salen = 16;
  getnameinfo((const struct sockaddr *)soc_in, salen, hostbuf_9499, 0x40u, 0, 0, 1u);
  return hostbuf_9499;
}

//----- (0811521A) --------------------------------------------------------
BOOLEAN __cdecl valid_hostname(char *name)
{
  char *cp; // [esp+Ch] [ebp-Ch]
  int iseg; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  i = 1;
  iseg = 0;
  cp = name;
  if ( !name || !*name )
    return 0;
  while ( *cp && i <= 253 )
  {
    if ( *cp == 46 )
    {
      if ( !iseg )
        return 0;
      iseg = 0;
    }
    else
    {
      if ( !iseg && (*cp == 45 || *cp == 43) )
        return 0;
      if ( ++iseg > 63 )
        return 0;
      if ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 8) == 0 && *cp != 45 && *cp != 95 && *cp != 36 && *cp != 43 )
        return 0;
    }
    ++cp;
    ++i;
  }
  return !*cp || *cp == 46 && iseg && !cp[1];
}

//----- (0811535F) --------------------------------------------------------
void __cdecl __noreturn quench(int sig)
{
  _exit(2);
}

//----- (08115371) --------------------------------------------------------
void __cdecl dump_hostent(const char *msgprefix, const hostent *phost)
{
  FILE *v2; // edx
  char *h_name; // ebx
  FILE *v4; // eax
  char *v5; // ebx
  FILE *v6; // eax
  FILE *v7; // eax
  char **h_aliases; // ebx
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  int h_addrtype; // ebx
  FILE *v15; // eax
  int h_length; // ebx
  FILE *v17; // eax
  char **h_addr_list; // ebx
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  FILE *v22; // eax
  FILE *v23; // eax
  FILE *v24; // eax
  FILE *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  const char *v28; // [esp+20h] [ebp-38h]
  char *v29; // [esp+24h] [ebp-34h]
  const char *v30; // [esp+28h] [ebp-30h]
  const char *v31; // [esp+2Ch] [ebp-2Ch]
  char *v32; // [esp+30h] [ebp-28h]
  const char *v33; // [esp+34h] [ebp-24h]
  const char *v34; // [esp+38h] [ebp-20h]
  int v35; // [esp+3Ch] [ebp-1Ch]
  const char *v36; // [esp+40h] [ebp-18h]
  char **pcnt; // [esp+4Ch] [ebp-Ch]
  char **pcnta; // [esp+4Ch] [ebp-Ch]
  int i; // [esp+50h] [ebp-8h]

  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "%s: %p ", msgprefix, phost);
    if ( phost )
    {
      if ( WWW_TraceFlag[0] )
      {
        h_name = phost->h_name;
        v4 = TraceFP();
        fprintf(v4, "{ h_name = %p", h_name);
      }
      if ( phost->h_name )
      {
        if ( WWW_TraceFlag[0] )
        {
          v5 = phost->h_name;
          v6 = TraceFP();
          fprintf(v6, " \"%s\",", v5);
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, ",");
      }
      if ( WWW_TraceFlag[0] )
      {
        h_aliases = phost->h_aliases;
        v9 = TraceFP();
        fprintf(v9, "\n\t h_aliases = %p", h_aliases);
      }
      if ( phost->h_aliases )
      {
        if ( WWW_TraceFlag[0] )
        {
          v10 = TraceFP();
          fprintf(v10, " {");
        }
        for ( pcnt = phost->h_aliases; *pcnt; ++pcnt )
        {
          if ( WWW_TraceFlag[0] )
          {
            v28 = *pcnt;
            v29 = *pcnt;
            if ( phost->h_aliases == pcnt )
              v30 = " ";
            else
              v30 = ", ";
            v11 = TraceFP();
            fprintf(v11, "%s %p \"%s\"", v30, v29, v28);
          }
        }
        if ( WWW_TraceFlag[0] )
        {
          if ( *phost->h_aliases )
            v31 = ", ";
          else
            v31 = " ";
          v12 = TraceFP();
          fprintf(v12, "%s0x0 },\n\t", v31);
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v13 = TraceFP();
        fprintf(v13, ",\n\t");
      }
      if ( WWW_TraceFlag[0] )
      {
        h_addrtype = phost->h_addrtype;
        v15 = TraceFP();
        fprintf(v15, " h_addrtype = %d,", h_addrtype);
      }
      if ( WWW_TraceFlag[0] )
      {
        h_length = phost->h_length;
        v17 = TraceFP();
        fprintf(v17, " h_length = %d,\n\t", h_length);
      }
      if ( WWW_TraceFlag[0] )
      {
        h_addr_list = phost->h_addr_list;
        v19 = TraceFP();
        fprintf(v19, " h_addr_list = %p", h_addr_list);
      }
      if ( phost->h_addr_list )
      {
        if ( WWW_TraceFlag[0] )
        {
          v20 = TraceFP();
          fprintf(v20, " {");
        }
        for ( pcnta = phost->h_addr_list; *pcnta; ++pcnta )
        {
          if ( WWW_TraceFlag[0] )
          {
            v32 = *pcnta;
            if ( phost->h_addr_list == pcnta )
              v33 = &byte_81822F1;
            else
              v33 = ",";
            v21 = TraceFP();
            fprintf(v21, "%s %p", v33, v32);
          }
          for ( i = 0; phost->h_length > i; ++i )
          {
            if ( WWW_TraceFlag[0] )
            {
              if ( i + 1 == phost->h_length )
                v34 = "\"";
              else
                v34 = &byte_81822F1;
              v35 = (unsigned __int8)(*pcnta)[i];
              if ( i )
                v36 = ".";
              else
                v36 = " \"";
              v22 = TraceFP();
              fprintf(v22, "%s%d%s", v36, v35, v34);
            }
          }
        }
        if ( *phost->h_addr_list )
        {
          if ( WWW_TraceFlag[0] )
          {
            v23 = TraceFP();
            fprintf(v23, ", 0x0 } }");
          }
        }
        else if ( WWW_TraceFlag[0] )
        {
          v24 = TraceFP();
          fprintf(v24, " 0x0 } }");
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v25 = TraceFP();
        fprintf(v25, "}");
      }
    }
    if ( WWW_TraceFlag[0] )
    {
      v26 = TraceFP();
      fprintf(v26, "\n");
    }
    v27 = TraceFP();
    fflush(v27);
  }
}

//----- (081157F8) --------------------------------------------------------
size_t __cdecl fill_rehostent(char *rehostent, size_t rehostentsize, const hostent *phost)
{
  size_t v3; // eax
  int i_alias; // [esp+1Ch] [ebp-3Ch]
  int i_addr; // [esp+20h] [ebp-38h]
  size_t required_this_alias; // [esp+24h] [ebp-34h]
  size_t mem_this_alias; // [esp+28h] [ebp-30h]
  size_t chk_available; // [esp+2Ch] [ebp-2Ch]
  size_t available; // [esp+30h] [ebp-28h]
  size_t required_per_addr; // [esp+38h] [ebp-20h]
  size_t name_len; // [esp+3Ch] [ebp-1Ch]
  char **p_next_charptr; // [esp+40h] [ebp-18h]
  char *p_next_char; // [esp+44h] [ebp-14h]
  char **pcnt; // [esp+48h] [ebp-10h]
  char **pcnta; // [esp+48h] [ebp-10h]
  char **pcntb; // [esp+48h] [ebp-10h]
  char **pcntc; // [esp+48h] [ebp-10h]
  int num_aliases; // [esp+4Ch] [ebp-Ch]
  int num_addrs; // [esp+50h] [ebp-8h]

  num_addrs = 0;
  num_aliases = 0;
  name_len = 0;
  available = rehostentsize - 20;
  if ( !phost )
    return 0;
  required_per_addr = phost->h_length + 4;
  if ( phost->h_addr_list )
    available = rehostentsize - 24;
  if ( phost->h_aliases )
    available -= 4;
  if ( phost->h_name )
    --available;
  if ( phost->h_addr_list && *phost->h_addr_list && available >= required_per_addr )
  {
    num_addrs = 1;
    available -= required_per_addr;
  }
  if ( phost->h_name )
  {
    name_len = strlen(phost->h_name);
    if ( available < name_len )
      name_len = 0;
    else
      available -= name_len;
  }
  if ( num_addrs )
  {
    for ( pcnt = phost->h_addr_list + 1; *pcnt && available >= required_per_addr; ++pcnt )
    {
      ++num_addrs;
      available -= required_per_addr;
    }
  }
  chk_available = available;
  if ( phost->h_aliases )
  {
    for ( pcnta = phost->h_aliases; *pcnta; ++pcnta )
    {
      required_this_alias = strlen(*pcnta) + 5;
      if ( chk_available >= required_this_alias )
      {
        ++num_aliases;
        chk_available -= required_this_alias;
      }
    }
  }
  *((_DWORD *)rehostent + 2) = phost->h_addrtype;
  *((_DWORD *)rehostent + 3) = phost->h_length;
  p_next_charptr = (char **)(rehostent + 20);
  p_next_char = rehostent + 20;
  if ( phost->h_addr_list )
    p_next_char += 4 * num_addrs + 4;
  if ( phost->h_aliases )
    p_next_char += 4 * num_aliases + 4;
  if ( phost->h_addr_list )
  {
    *((_DWORD *)rehostent + 4) = p_next_charptr;
    pcntb = phost->h_addr_list;
    for ( i_addr = 0; i_addr < num_addrs; ++i_addr )
    {
      memcpy(p_next_char, *pcntb, 4u);
      *p_next_charptr++ = p_next_char;
      p_next_char += 4;
      ++pcntb;
    }
    *p_next_charptr++ = 0;
  }
  else
  {
    *((_DWORD *)rehostent + 4) = 0;
  }
  if ( phost->h_name )
  {
    *(_DWORD *)rehostent = p_next_char;
    if ( name_len )
    {
      strcpy(p_next_char, phost->h_name);
      p_next_char += name_len + 1;
    }
    else
    {
      *p_next_char++ = 0;
    }
  }
  else
  {
    *(_DWORD *)rehostent = 0;
  }
  if ( phost->h_aliases )
  {
    *((_DWORD *)rehostent + 1) = p_next_charptr;
    pcntc = phost->h_aliases;
    for ( i_alias = 0; *pcntc && i_alias < num_addrs; ++i_alias )
    {
      v3 = strlen(*pcntc);
      mem_this_alias = v3 + 1;
      if ( available >= v3 + 5 )
      {
        ++i_alias;
        available -= v3 + 5;
        strcpy(p_next_char, *pcntc);
        *p_next_charptr++ = p_next_char;
        p_next_char += mem_this_alias;
      }
      p_next_char += 4;
      ++pcntc;
    }
    *p_next_charptr = 0;
  }
  else
  {
    *((_DWORD *)rehostent + 1) = 0;
  }
  return p_next_char - rehostent;
}

//----- (08115B30) --------------------------------------------------------
unsigned int __cdecl readit(int fd, char *buffer, unsigned int length)
{
  unsigned int got; // [esp+20h] [ebp-8h]
  unsigned int result; // [esp+24h] [ebp-4h]

  result = 0;
  while ( length )
  {
    got = read(fd, buffer, length);
    if ( !got )
      break;
    result += got;
    buffer += got;
    length -= got;
  }
  return result;
}

//----- (08115B7E) --------------------------------------------------------
hostent *__cdecl LYGetHostByName(char *str)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  int v6; // ebx
  FILE *v7; // eax
  int v8; // ebx
  FILE *v9; // eax
  FILE *v10; // eax
  int v11; // ebx
  FILE *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  fd_set readfds; // [esp+28h] [ebp-210h] BYREF
  sigset_t new_sigset; // [esp+A8h] [ebp-190h] BYREF
  sigset_t old_sigset; // [esp+128h] [ebp-110h] BYREF
  LYGetHostByName::_statuses statuses; // [esp+1A8h] [ebp-90h] BYREF
  timeval one_second; // [esp+1BCh] [ebp-7Ch] BYREF
  int pfd[2]; // [esp+1C4h] [ebp-74h] BYREF
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_7; // [esp+1CCh] [ebp-6Ch]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_6; // [esp+1D0h] [ebp-68h]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_5; // [esp+1D4h] [ebp-64h]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_4; // [esp+1D8h] [ebp-60h]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_3; // [esp+1DCh] [ebp-5Ch]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_2; // [esp+1E0h] [ebp-58h]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_1; // [esp+1E4h] [ebp-54h]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u_0; // [esp+1E8h] [ebp-50h]
  LYGetHostByName::$282D118E43687E1C7640A6922C6B4310 __u; // [esp+1ECh] [ebp-4Ch]
  int kbd_fd; // [esp+1F0h] [ebp-48h]
  fd_set *__arr; // [esp+1F4h] [ebp-44h]
  unsigned int __i; // [esp+1F8h] [ebp-40h]
  hostent *phost; // [esp+1FCh] [ebp-3Ch]
  int child_exited; // [esp+200h] [ebp-38h]
  int dns_patience; // [esp+204h] [ebp-34h]
  time_t start_time; // [esp+208h] [ebp-30h]
  int waitstat; // [esp+20Ch] [ebp-2Ch] BYREF
  int readret; // [esp+210h] [ebp-28h]
  int selret; // [esp+214h] [ebp-24h]
  int waitret; // [esp+218h] [ebp-20h]
  int fpid; // [esp+21Ch] [ebp-1Ch]
  int got_rehostent; // [esp+220h] [ebp-18h]
  hostent *result_phost; // [esp+224h] [ebp-14h]
  size_t rehostentlen; // [esp+228h] [ebp-10h]
  char *rehostent; // [esp+22Ch] [ebp-Ch]
  char *host; // [esp+230h] [ebp-8h]

  host = str;
  rehostent = (char *)&aligned_full_rehostent_9956;
  rehostentlen = 0;
  result_phost = 0;
  if ( str )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "LYGetHostByName: parsing `%s'.\n", str);
    }
    if ( HTCheckForInterrupt() )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "LYGetHostByName: INTERRUPTED for '%s'.\n", str);
      }
      lynx_nsl_status = -29998;
      return 0;
    }
    else if ( valid_hostname(host) )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fflush(v4);
      }
      lynx_nsl_status = -900;
      statuses.h_errno_valid = 0;
      got_rehostent = 0;
      waitstat = 0;
      start_time = time(0);
      dns_patience = 30;
      child_exited = 0;
      do
      {
        do
          waitret = waitpid(-1, 0, 1);
        while ( waitret > 0 );
      }
      while ( waitret == -1 && *__errno_location() == 4 );
      waitret = 0;
      pipe(pfd);
      sigemptyset(&new_sigset);
      sigaddset(&new_sigset, 15);
      sigaddset(&new_sigset, 2);
      sigaddset(&new_sigset, 1);
      sigaddset(&new_sigset, 20);
      sigaddset(&new_sigset, 28);
      sigprocmask(0, &new_sigset, &old_sigset);
      fpid = fork();
      if ( !fpid )
      {
        signal(15, quench);
        signal(2, quench);
        signal(1, quench);
        if ( no_suspend )
          signal(20, (__sighandler_t)1);
        else
          signal(20, 0);
        signal(28, (__sighandler_t)1);
        signal(11, 0);
        signal(4, 0);
        sigprocmask(2, &old_sigset, 0);
        close(pfd[0]);
        *__errno_location() = 0;
        phost = gethostbyname(host);
        statuses.child_errno = *__errno_location();
        statuses.child_h_errno = my_errno;
        dump_hostent("CHILD gethostbyname", phost);
        if ( phost && phost->h_length )
        {
          rehostentlen = fill_rehostent(rehostent, 0x80u, phost);
          dump_hostent("CHILD fill_rehostent", (const hostent *)rehostent);
        }
        if ( rehostentlen > 0x14 && rehostent && *((_DWORD *)rehostent + 3) )
        {
          statuses.h_length = *((_DWORD *)rehostent + 3);
        }
        else
        {
          rehostentlen = 0;
          statuses.h_length = 0;
        }
        if ( !statuses.child_errno )
          statuses.child_errno = *__errno_location();
        statuses.rehostentlen = rehostentlen;
        write(pfd[1], &statuses, 0x14u);
        if ( rehostentlen )
        {
          write(pfd[1], rehostent, rehostentlen);
          close(pfd[1]);
          _exit(0);
        }
        _exit(1);
      }
      sigprocmask(2, &old_sigset, 0);
      close(pfd[1]);
      if ( fpid >= 0 )
      {
        while ( child_exited || time(0) - start_time < dns_patience )
        {
          __arr = &readfds;
          for ( __i = 0; __i <= 0x1F; ++__i )
            __arr->fds_bits[__i] = 0;
          kbd_fd = LYConsoleInputFD(1);
          if ( kbd_fd != -1 )
            readfds.fds_bits[(unsigned int)kbd_fd >> 5] |= 1 << (kbd_fd & 0x1F);
          one_second.tv_sec = 1;
          one_second.tv_usec = 0;
          readfds.fds_bits[(unsigned int)pfd[0] >> 5] |= 1 << (pfd[0] & 0x1F);
          selret = select(pfd[0] + 1, &readfds, 0, 0, &one_second);
          if ( selret > 0 && ((readfds.fds_bits[(unsigned int)pfd[0] >> 5] >> (pfd[0] & 0x1F)) & 1) != 0 )
          {
            readret = readit(pfd[0], (char *)&statuses, 0x14u);
            if ( readret == 20 )
            {
              my_errno = statuses.child_h_errno;
              *__errno_location() = statuses.child_errno;
              if ( statuses.rehostentlen > 0x14 )
              {
                readret = readit(pfd[0], rehostent, statuses.rehostentlen);
                dump_hostent("Read from pipe", (const hostent *)rehostent);
                if ( statuses.rehostentlen == readret )
                {
                  got_rehostent = 1;
                  result_phost = (hostent *)rehostent;
                  lynx_nsl_status = 0;
                }
                else if ( !statuses.h_errno_valid )
                {
                  lynx_nsl_status = -900;
                }
              }
            }
            else
            {
              lynx_nsl_status = -1;
            }
            if ( !child_exited )
              waitret = waitpid(fpid, &waitstat, 1);
            __u.__in = waitstat;
            if ( (waitstat & 0x7F) != 0 )
            {
              __u_0.__in = waitstat;
              if ( (char)((waitstat & 0x7F) + 1) >> 1 <= 0 )
              {
                kill(fpid, 15);
                waitret = waitpid(fpid, &waitstat, 1);
              }
            }
            break;
          }
          if ( child_exited )
          {
            waitret = waitpid(fpid, &waitstat, 1);
            break;
          }
          waitret = waitpid(fpid, &waitstat, 1);
          if ( waitret <= 0 )
          {
            if ( HTCheckForInterrupt() )
            {
              if ( WWW_TraceFlag[0] )
              {
                v5 = TraceFP();
                fprintf(v5, "LYGetHostByName: INTERRUPTED gethostbyname.\n");
              }
              kill(fpid, 15);
              waitpid(fpid, 0, 1);
              close(pfd[0]);
              lynx_nsl_status = -29998;
              return 0;
            }
          }
          else
          {
            child_exited = 1;
          }
        }
        close(pfd[0]);
        if ( waitret <= 0 )
        {
          kill(fpid, 15);
          waitret = waitpid(fpid, &waitstat, 1);
        }
        if ( waitret > 0 )
        {
          __u_1.__in = waitstat;
          if ( (waitstat & 0x7F) != 0 )
          {
            __u_3.__in = waitstat;
            if ( (char)((waitstat & 0x7F) + 1) >> 1 <= 0 )
            {
              __u_6.__in = waitstat;
              if ( (unsigned __int8)waitstat == 127 && WWW_TraceFlag[0] )
              {
                __u_7.__in = waitstat;
                v11 = (waitstat & 0xFF00) >> 8;
                v12 = TraceFP();
                fprintf(v12, "LYGetHostByName: NSL_FORK child %d is stopped, status 0x%x!\n", waitret, v11);
              }
            }
            else
            {
              if ( WWW_TraceFlag[0] )
              {
                __u_4.__in = waitstat;
                v8 = waitstat & 0x7F;
                v9 = TraceFP();
                fprintf(v9, "LYGetHostByName: NSL_FORK child %d got signal, status 0x%x!\n", waitret, v8);
              }
              __u_5.__in = waitstat;
              if ( (waitstat & 0x80) != 0 && WWW_TraceFlag[0] )
              {
                v10 = TraceFP();
                fprintf(v10, "LYGetHostByName: NSL_FORK child %d dumped core!\n", waitret);
              }
            }
          }
          else if ( WWW_TraceFlag[0] )
          {
            __u_2.__in = waitstat;
            v6 = (waitstat & 0xFF00) >> 8;
            v7 = TraceFP();
            fprintf(v7, "LYGetHostByName: NSL_FORK child %d exited, status 0x%x.\n", waitret, v6);
          }
        }
        if ( got_rehostent )
        {
          dump_hostent("End of LYGetHostByName", result_phost);
          if ( WWW_TraceFlag[0] )
          {
            v13 = TraceFP();
            fprintf(v13, "LYGetHostByName: Resolved name to a hostent.\n");
          }
          return result_phost;
        }
      }
      else
      {
        close(pfd[0]);
      }
      if ( WWW_TraceFlag[0] )
      {
        v14 = TraceFP();
        fprintf(v14, "LYGetHostByName: Can't find internet node name `%s'.\n", host);
      }
      return 0;
    }
    else
    {
      lynx_nsl_status = -406;
      my_errno = 3;
      return 0;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "LYGetHostByName: Can't parse `NULL'.\n");
    }
    lynx_nsl_status = -900;
    return 0;
  }
}

//----- (0811656F) --------------------------------------------------------
addrinfo *__cdecl HTGetAddrInfo(const char *str, const int defport)
{
  const char *v2; // ebx
  FILE *v3; // eax
  addrinfo hints; // [esp+28h] [ebp-90h] BYREF
  char *port; // [esp+48h] [ebp-70h]
  char *host; // [esp+4Ch] [ebp-6Ch]
  char *s; // [esp+50h] [ebp-68h] BYREF
  char *p; // [esp+54h] [ebp-64h]
  int error; // [esp+58h] [ebp-60h]
  addrinfo *res; // [esp+5Ch] [ebp-5Ch] BYREF
  char pbuf[80]; // [esp+60h] [ebp-58h] BYREF
  unsigned int v13; // [esp+B0h] [ebp-8h]

  v13 = __readgsdword(0x14u);
  s = 0;
  HTSACopy(&s, str);
  if ( *s == 91 && (p = strchr(s, 93)) != 0 )
  {
    *p++ = 0;
    host = s + 1;
  }
  else
  {
    p = s;
    host = s;
  }
  port = strrchr(p, 58);
  if ( port )
  {
    *port++ = 0;
  }
  else
  {
    sprintf(pbuf, "%d", defport);
    port = pbuf;
  }
  memset(&hints, 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  error = getaddrinfo(host, port, &hints, &res);
  if ( error || !res )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = gai_strerror(error);
      v3 = TraceFP();
      fprintf(v3, "HTGetAddrInfo: getaddrinfo(%s, %s): %s\n", host, port, v2);
    }
    res = 0;
  }
  free(s);
  return res;
}

//----- (0811670F) --------------------------------------------------------
void get_host_details()
{
  const char *v0; // ebx
  FILE *v1; // eax
  char name[65]; // [esp+1Fh] [ebp-49h] BYREF
  unsigned int v3; // [esp+60h] [ebp-8h]

  v3 = __readgsdword(0x14u);
  if ( !hostname )
  {
    gethostname(name, 0x41u);
    HTSACopy(&hostname, name);
    if ( WWW_TraceFlag[0] )
    {
      v0 = hostname;
      v1 = TraceFP();
      fprintf(v1, "TCP: Local host name is %s\n", v0);
    }
  }
}

//----- (08116799) --------------------------------------------------------
char *HTHostName()
{
  get_host_details();
  return hostname;
}

//----- (081167AB) --------------------------------------------------------
BOOLEAN __cdecl HTWasInterrupted(int *status)
{
  BOOLEAN result; // [esp+17h] [ebp-1h]

  result = 0;
  if ( HTCheckForInterrupt() )
  {
    result = 1;
    *status = -29998;
    *__errno_location() = 4;
  }
  return result;
}

//----- (081167DC) --------------------------------------------------------
void __cdecl set_timeout(timeval *timeoutp)
{
  timeoutp->tv_sec = 0;
  timeoutp->tv_usec = 100000;
}

//----- (081167F4) --------------------------------------------------------
int __cdecl HTDoConnect(const char *url, const char *protocol, int default_port, int *s)
{
  char *v4; // ebx
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  int ai_family; // ebx
  char *v11; // eax
  char *v12; // eax
  bool v13; // al
  char *v14; // eax
  FILE *v15; // eax
  char *v16; // eax
  fd_set writefds; // [esp+40h] [ebp-8C8h] BYREF
  timeval select_timeout; // [esp+C0h] [ebp-848h] BYREF
  int ret_1; // [esp+C8h] [ebp-840h]
  int val; // [esp+CCh] [ebp-83Ch] BYREF
  fd_set *__arr; // [esp+D0h] [ebp-838h]
  unsigned int __i; // [esp+D4h] [ebp-834h]
  int tries; // [esp+D8h] [ebp-830h]
  int ret_0; // [esp+DCh] [ebp-82Ch]
  int ret; // [esp+E0h] [ebp-828h]
  addrinfo *res0; // [esp+E4h] [ebp-824h]
  addrinfo *res; // [esp+E8h] [ebp-820h]
  char *host; // [esp+ECh] [ebp-81Ch] BYREF
  char *at_sign; // [esp+F0h] [ebp-818h]
  char *p1; // [esp+F4h] [ebp-814h]
  char *line; // [esp+F8h] [ebp-810h] BYREF
  int status; // [esp+FCh] [ebp-80Ch] BYREF
  char portbuf[1024]; // [esp+100h] [ebp-808h] BYREF
  char hostbuf[1024]; // [esp+500h] [ebp-408h] BYREF
  unsigned int v37; // [esp+900h] [ebp-8h]

  v37 = __readgsdword(0x14u);
  status = 0;
  line = 0;
  host = 0;
  res = 0;
  res0 = 0;
  p1 = HTParse(url, &byte_81822F1, 8);
  at_sign = strchr(p1, 64);
  if ( at_sign )
    HTSACopy(&host, at_sign + 1);
  else
    HTSACopy(&host, p1);
  if ( p1 )
  {
    free(p1);
    p1 = 0;
  }
  v4 = host;
  v5 = gettext("Looking up ");
  HTSprintf0(&line, "%s%s", v5, v4);
  mustshow[0] = 1;
  HTProgress(line);
  res0 = HTGetAddrInfo(host, default_port);
  if ( res0 )
  {
    v8 = host;
    v9 = gettext("Making %s connection to %s");
    HTSprintf0(&line, v9, protocol, v8);
    mustshow[0] = 1;
    HTProgress(line);
    if ( host )
    {
      free(host);
      host = 0;
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
    for ( res = res0; res; res = res->ai_next )
    {
      *s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
      if ( *s == -1 )
      {
        getnameinfo(res->ai_addr, res->ai_addrlen, hostbuf, 0x400u, portbuf, 0x400u, 3u);
        ai_family = res->ai_family;
        v11 = gettext("socket failed: family %d addr %s port %s.");
        HTSprintf0(&line, v11, ai_family, hostbuf, portbuf);
        mustshow[0] = 1;
        HTProgress(line);
        if ( line )
        {
          free(line);
          line = 0;
        }
      }
      else
      {
        val = 1;
        ret = ioctl(*s, 0x5421u, &val);
        if ( ret == -1 )
        {
          mustshow[0] = 1;
          v12 = gettext("Could not make connection non-blocking.");
          HTProgress(v12);
        }
        status = connect(*s, res->ai_addr, res->ai_addrlen);
        if ( status < 0 && (*__errno_location() == 115 || *__errno_location() == 11) )
        {
          tries = 0;
          HTInetStatus("this socket's first connect");
          ret_0 = 0;
          while ( ret_0 <= 0 )
          {
            v13 = tries / 10 >= connect_timeout;
            ++tries;
            if ( v13 )
            {
              v14 = gettext("Connection failed (too many retries).");
              HTAlert(v14);
              if ( line )
              {
                free(line);
                line = 0;
              }
              if ( res0 )
                freeaddrinfo(res0);
              return -204;
            }
            set_timeout(&select_timeout);
            __arr = &writefds;
            for ( __i = 0; __i <= 0x1F; ++__i )
              __arr->fds_bits[__i] = 0;
            writefds.fds_bits[(unsigned int)*s >> 5] |= 1 << (*(_BYTE *)s & 0x1F);
            ret_0 = select(*s + 1, 0, &writefds, 0, &select_timeout);
            if ( tries == 1 )
              HTInetStatus("this socket's first select");
            if ( ret_0 != -1 || *__errno_location() != 4 )
            {
              if ( ret_0 < 0 )
                HTInetStatus("failed select");
              if ( ret_0 < 0 && *__errno_location() != 114 )
              {
                status = ret_0;
                break;
              }
              if ( ret_0 <= 0 )
              {
                status = connect(*s, res->ai_addr, res->ai_addrlen);
                if ( status < 0 && *__errno_location() != 114 && *__errno_location() != 11 && *__errno_location() != 106 )
                {
                  HTInetStatus("confirm-not-ready connect");
                  break;
                }
              }
              else
              {
                status = connect(*s, res->ai_addr, res->ai_addrlen);
                if ( status < 0 && *__errno_location() == 106 )
                  status = 0;
                if ( !status || *__errno_location() != 114 )
                {
                  if ( status < 0 )
                    HTInetStatus("confirm-ready connect");
                  break;
                }
                ret_0 = 0;
              }
              if ( HTWasInterrupted(&status) )
              {
                if ( WWW_TraceFlag[0] )
                {
                  v15 = TraceFP();
                  fprintf(v15, "*** INTERRUPTED in middle of connect.\n");
                }
                break;
              }
            }
          }
        }
        else if ( status < 0 )
        {
          HTInetStatus("this socket's first and only connect");
        }
        if ( status >= 0 )
          break;
        close(*s);
        *s = -1;
      }
    }
    if ( *s >= 0 )
    {
      val = 0;
      ret_1 = ioctl(*s, 0x5421u, &val);
      if ( ret_1 == -1 )
      {
        mustshow[0] = 1;
        v16 = gettext("Could not restore socket to blocking.");
        HTProgress(v16);
      }
    }
    else
    {
      close(*s);
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
    if ( res0 )
      freeaddrinfo(res0);
    return status;
  }
  else
  {
    v6 = host;
    v7 = gettext("Unable to locate remote host %s.");
    HTSprintf0(&line, v7, v6);
    mustshow[0] = 1;
    HTProgress(line);
    if ( host )
    {
      free(host);
      host = 0;
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
    return -204;
  }
}

//----- (081170D7) --------------------------------------------------------
int __cdecl HTDoRead(int fildes, void *buf, unsigned int nbyte)
{
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  bool v6; // al
  char *v7; // eax
  int v8; // ebx
  int v9; // esi
  FILE *v10; // eax
  fd_set readfds; // [esp+20h] [ebp-B8h] BYREF
  timeval select_timeout; // [esp+A0h] [ebp-38h] BYREF
  fd_set *__arr; // [esp+A8h] [ebp-30h]
  unsigned int __i; // [esp+ACh] [ebp-2Ch]
  time_t t; // [esp+B0h] [ebp-28h]
  time_t start; // [esp+B4h] [ebp-24h]
  time_t otime; // [esp+B8h] [ebp-20h]
  int otries; // [esp+BCh] [ebp-1Ch]
  int tries; // [esp+C0h] [ebp-18h]
  int ret; // [esp+C4h] [ebp-14h]
  int result; // [esp+C8h] [ebp-10h] BYREF
  BOOLEAN ready; // [esp+CFh] [ebp-9h]

  tries = 0;
  otries = 0;
  otime = time(0);
  start = otime;
  if ( fildes )
  {
    if ( fildes <= 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "HTDoRead - no file descriptor!\n");
      }
      return -1;
    }
  }
  else if ( isatty(0) )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "HTDoRead - refusing to read fd 0 which is a tty!\n");
    }
    return -1;
  }
  if ( HTWasInterrupted(&result) )
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "HTDoRead - interrupted before starting!\n");
    }
    return result;
  }
  else
  {
    ready = 0;
    while ( !ready )
    {
      v6 = tries / 10 >= reading_timeout;
      ++tries;
      if ( v6 )
      {
        v7 = gettext("Socket read failed (too many tries).");
        HTAlert(v7);
        *__errno_location() = 4;
        result = -29998;
        break;
      }
      if ( tries - otries > 10 )
      {
        t = time(0);
        otries = tries;
        if ( t - otime > 4 )
        {
          otime = t;
          HTReadProgress(-1LL, 0LL);
        }
      }
      do
      {
        set_timeout(&select_timeout);
        __arr = &readfds;
        for ( __i = 0; __i <= 0x1F; ++__i )
          __arr->fds_bits[__i] = 0;
        readfds.fds_bits[(unsigned int)fildes >> 5] |= 1 << (fildes & 0x1F);
        ret = select(fildes + 1, &readfds, 0, 0, &select_timeout);
      }
      while ( ret == -1 && *__errno_location() == 4 );
      if ( ret < 0 )
      {
        result = -1;
        break;
      }
      if ( ret <= 0 )
      {
        if ( HTWasInterrupted(&result) )
          break;
      }
      else
      {
        ready = 1;
      }
    }
    if ( ready )
    {
      while ( 1 )
      {
        result = read(fildes, buf, nbyte);
        if ( result != -1 )
          break;
        if ( *__errno_location() != 4 )
        {
          HTInetStatus("read");
          break;
        }
      }
    }
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x100) != 0 )
    {
      v8 = time(0) - start;
      v9 = result;
      v10 = TraceFP();
      fprintf(v10, "...HTDoRead returns %d (%d seconds)\n", v9, v8);
    }
    return result;
  }
}

//----- (08117408) --------------------------------------------------------
void __cdecl fake_put_character(void *p, char c)
{
  ;
}

//----- (08117416) --------------------------------------------------------
const char *__cdecl state_name(sgml_state n)
{
  const char *result; // [esp+Ch] [ebp-4h]

  result = "?";
  switch ( n )
  {
    case S_text_2:
      result = "S_text";
      break;
    case S_attr:
      result = "S_attr";
      break;
    case S_attr_gap:
      result = "S_attr_gap";
      break;
    case S_comment:
      result = "S_comment";
      break;
    case S_cro:
      result = "S_cro";
      break;
    case S_doctype:
      result = "S_doctype";
      break;
    case S_dollar_2:
      result = "S_dollar";
      break;
    case S_dollar_dq:
      result = "S_dollar_dq";
      break;
    case S_dollar_paren_2:
      result = "S_dollar_paren";
      break;
    case S_dollar_paren_dq:
      result = "S_dollar_paren_dq";
      break;
    case S_dollar_paren_sq:
      result = "S_dollar_paren_sq";
      break;
    case S_dollar_sq:
      result = "S_dollar_sq";
      break;
    case S_dquoted:
      result = "S_dquoted";
      break;
    case S_end:
      result = "S_end";
      break;
    case S_entity:
      result = "S_entity";
      break;
    case S_equals:
      result = "S_equals";
      break;
    case S_ero:
      result = "S_ero";
      break;
    case S_esc_2:
      result = "S_esc";
      break;
    case S_esc_dq:
      result = "S_esc_dq";
      break;
    case S_esc_sq:
      result = "S_esc_sq";
      break;
    case S_exclamation:
      result = "S_exclamation";
      break;
    case S_in_kanji:
      result = "S_in_kanji";
      break;
    case S_incro:
      result = "S_incro";
      break;
    case S_junk_tag:
      result = "S_junk_tag";
      break;
    case S_litteral:
      result = "S_litteral";
      break;
    case S_marked:
      result = "S_marked";
      break;
    case S_nonascii_text_2:
      result = "S_nonascii_text";
      break;
    case S_nonascii_text_dq:
      result = "S_nonascii_text_dq";
      break;
    case S_nonascii_text_sq:
      result = "S_nonascii_text_sq";
      break;
    case S_paren_2:
      result = "S_paren";
      break;
    case S_paren_dq:
      result = "S_paren_dq";
      break;
    case S_paren_sq:
      result = "S_paren_sq";
      break;
    case S_pcdata:
      result = "S_pcdata";
      break;
    case S_pi:
      result = "S_pi";
      break;
    case S_script:
      result = "S_script";
      break;
    case S_sgmlatt:
      result = "S_sgmlatt";
      break;
    case S_sgmlele:
      result = "S_sgmlele";
      break;
    case S_sgmlent:
      result = "S_sgmlent";
      break;
    case S_squoted:
      result = "S_squoted";
      break;
    case S_tag:
      result = "S_tag";
      break;
    case S_tag_gap:
      result = "S_tag_gap";
      break;
    case S_tagname_slash:
      result = "S_tagname_slash";
      break;
    case S_value:
      result = "S_value";
      break;
    default:
      return result;
  }
  return result;
}

//----- (08117615) --------------------------------------------------------
HTElement *pool_alloc()
{
  if ( ++depth <= 10 )
    return (HTElement *)(-8 * (1 - depth) + 136004096);
  else
    return (HTElement *)malloc(8u);
}

//----- (08117663) --------------------------------------------------------
void __cdecl pool_free(HTElement *e)
{
  if ( depth > 10 && e )
    free(e);
  --depth;
}

//----- (0811769A) --------------------------------------------------------
void __cdecl HTMLSRC_apply_markup_0(HTStream_2 *context, HTlexeme lexeme, BOOLEAN start)
{
  FILE *v3; // eax
  HT_tagspec **v4; // [esp+18h] [ebp-30h]
  char *format; // [esp+20h] [ebp-28h]
  HT_tagspec *ts; // [esp+38h] [ebp-10h]

  if ( start )
    v4 = lexeme_start;
  else
    v4 = lexeme_end;
  for ( ts = v4[lexeme]; ts; ts = ts->next )
  {
    if ( ts->start )
    {
      current_tag_style = ts->style;
      force_current_tag_style[0] = 1;
      forced_classname = ts->class_name;
      force_classname[0] = 1;
    }
    if ( WWW_TraceFlag[0] )
    {
      if ( ts->start )
        format = "SRCSTART %d\n";
      else
        format = "SRCSTOP %d\n";
      v3 = TraceFP();
      fprintf(v3, format, lexeme);
    }
    if ( ts->start )
      context->actions->start_element(
        context->target,
        ts->element,
        ts->present,
        (const char **)ts->value,
        context->current_tag_charset,
        &context->include);
    else
      context->actions->end_element(context->target, ts->element, &context->include);
  }
}

//----- (081177F2) --------------------------------------------------------
void __cdecl set_chartrans_handling(HTStream_2 *context, HTParentAnchor *anchor, int chndl)
{
  int chndla; // [esp+38h] [ebp+10h]

  if ( chndl < 0 )
  {
    chndla = HTAnchor_getUCLYhndl(anchor, 2);
    if ( chndla < 0 )
      chndla = HTAnchor_getUCLYhndl(anchor, 3);
    if ( chndla < 0 )
      chndla = current_char_set;
    HTAnchor_setUCInfoStage(anchor, chndla, 3, 1);
    HTAnchor_setUCInfoStage(anchor, chndla, 2, 1);
    context->outUCI = HTAnchor_getUCInfoStage(anchor, 2);
    context->outUCLYhndl = HTAnchor_getUCLYhndl(context->node_anchor, 2);
  }
  UCSetTransParams(&context->T, context->inUCLYhndl, context->inUCI, context->outUCLYhndl, context->outUCI);
  if ( context->T.transp )
  {
    context->current_tag_charset = context->inUCLYhndl;
  }
  else if ( context->T.decode_utf8 )
  {
    context->current_tag_charset = context->inUCLYhndl;
  }
  else if ( context->T.do_8bitraw || context->T.use_raw_char_in )
  {
    context->current_tag_charset = context->inUCLYhndl;
  }
  else if ( context->T.output_utf8 || context->T.trans_from_uni )
  {
    context->current_tag_charset = UCGetLYhndl_byMIME("utf-8");
  }
  else
  {
    context->current_tag_charset = LATIN1;
  }
}

//----- (081179D0) --------------------------------------------------------
void __cdecl change_chartrans_handling(HTStream_2 *context)
{
  int next_LYhndl; // [esp+18h] [ebp-10h]
  LYUCcharset *next_UCI; // [esp+1Ch] [ebp-Ch]
  LYUCcharset *new_UCI; // [esp+20h] [ebp-8h]
  int new_LYhndl; // [esp+24h] [ebp-4h]

  new_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor, 1);
  if ( context->inUCLYhndl != new_LYhndl && new_LYhndl >= 0 )
  {
    new_UCI = HTAnchor_getUCInfoStage(context->node_anchor, 1);
    if ( new_UCI )
    {
      next_UCI = HTAnchor_getUCInfoStage(context->node_anchor, 2);
      next_LYhndl = HTAnchor_getUCLYhndl(context->node_anchor, 2);
      context->inUCI = new_UCI;
      context->inUCLYhndl = new_LYhndl;
      context->outUCI = next_UCI;
      context->outUCLYhndl = next_LYhndl;
      set_chartrans_handling(context, context->node_anchor, next_LYhndl);
    }
  }
}

//----- (08117ABD) --------------------------------------------------------
void __cdecl handle_attribute_name(HTStream_2 *context, const char *s)
{
  int v2; // ebx
  FILE *v3; // edx
  FILE *v4; // eax
  int v5; // [esp+1Ch] [ebp-3Ch]
  int v6; // [esp+20h] [ebp-38h]
  int v7; // [esp+24h] [ebp-34h]
  int v8; // [esp+28h] [ebp-30h]
  int v9; // [esp+2Ch] [ebp-2Ch]
  const char *name; // [esp+30h] [ebp-28h]
  int i; // [esp+40h] [ebp-18h]
  int low; // [esp+44h] [ebp-14h]
  int high; // [esp+48h] [ebp-10h]
  const attr *attributes; // [esp+4Ch] [ebp-Ch]
  HTTag *tag; // [esp+50h] [ebp-8h]

  tag = context->current_tag;
  attributes = tag->attributes;
  if ( psrc_view )
  {
    context->cur_attr_is_href = 0;
    context->cur_attr_is_name = 0;
  }
  if ( context->unknown_tag == tag )
  {
    if ( psrc_view )
      context->current_attribute_number = 1;
  }
  else
  {
    low = 0;
    high = tag->number_of_attributes;
    while ( 1 )
    {
      if ( high <= low )
      {
        if ( WWW_TraceFlag[0] )
        {
          if ( context->current_tag->name )
            name = context->current_tag->name;
          else
            name = (const char *)&unk_8182AE5;
          v4 = TraceFP();
          fprintf(v4, "SGML: Unknown attribute %s for tag %s\n", s, name);
        }
        context->current_attribute_number = -1;
        return;
      }
      i = low + (high - low) / 2;
      v6 = ((*__ctype_b_loc())[*(unsigned __int8 *)attributes[i].name] & 0x200) != 0 ? toupper(*(unsigned __int8 *)attributes[i].name) : *(unsigned __int8 *)attributes[i].name;
      v7 = ((*__ctype_b_loc())[*(unsigned __int8 *)s] & 0x200) != 0 ? toupper(*(unsigned __int8 *)s) : *(unsigned __int8 *)s;
      if ( v6 == v7 )
      {
        v5 = strcasecomp(attributes[i].name, s);
      }
      else
      {
        v8 = ((*__ctype_b_loc())[*(unsigned __int8 *)attributes[i].name] & 0x200) != 0 ? toupper(*(unsigned __int8 *)attributes[i].name) : *(unsigned __int8 *)attributes[i].name;
        v9 = ((*__ctype_b_loc())[*(unsigned __int8 *)s] & 0x200) != 0 ? toupper(*(unsigned __int8 *)s) : *(unsigned __int8 *)s;
        v5 = v8 - v9;
      }
      if ( !v5 )
        break;
      if ( v5 >= 0 )
        high = low + (high - low) / 2;
      else
        low = i + 1;
    }
    context->current_attribute_number = i;
    if ( psrc_view )
    {
      context->cur_attr_is_name = attributes[i].type == 1;
      context->cur_attr_is_href = attributes[i].type == 2;
    }
    else
    {
      context->present[i] = 1;
      if ( context->value[i] )
        *context->value[i] = 0;
      current_is_class = attributes[i].type == 4;
      if ( WWW_TraceFlag[0] )
      {
        v2 = current_is_class;
        v3 = TraceFP();
        fprintf(v3, "SGML: found attribute %s, %d\n", s, v2);
      }
    }
  }
}

//----- (08117E2A) --------------------------------------------------------
void __cdecl handle_attribute_value(HTStream_2 *context, const char *s)
{
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax

  if ( context->current_attribute_number == -1 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "SGML: Attribute value %s ***ignored\n", s);
    }
  }
  else
  {
    HTSACopy_extra(&context->value[context->current_attribute_number], s);
    if ( current_is_class )
    {
      strncpy(class_string, s, 0x100u);
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "SGML: class is '%s'\n", s);
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "SGML: attribute value is '%s'\n", s);
    }
  }
  context->current_attribute_number = -1;
}

//----- (08117F0E) --------------------------------------------------------
BOOLEAN __cdecl put_special_unicodes(HTStream_2 *context, UCode_t code)
{
  if ( !context->no_lynx_specialcodes )
  {
    switch ( code )
    {
      case 160:
        if ( !psrc_view )
          context->actions->put_character(context->target, 1);
        return 1;
      case 173:
        if ( !psrc_view )
          context->actions->put_character(context->target, 7);
        return 1;
      case 8194:
      case 8201:
        if ( !psrc_view )
LABEL_12:
          context->actions->put_character(context->target, 2);
        break;
      case 8195:
        if ( !psrc_view )
          goto LABEL_12;
        break;
      default:
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (08118014) --------------------------------------------------------
void __cdecl put_pretty_entity(HTStream_2 *context, int term)
{
  HTMLSRC_apply_markup_0(context, HTL_entity, 1);
  context->actions->put_character(context->target, 38);
  context->actions->put_string(context->target, entity_string);
  if ( term )
    context->actions->put_character(context->target, term);
  HTMLSRC_apply_markup_0(context, HTL_entity, 0);
}

//----- (081180B0) --------------------------------------------------------
void __cdecl put_pretty_number(HTStream_2 *context)
{
  const char *v1; // [esp+14h] [ebp-4h]

  HTMLSRC_apply_markup_0(context, HTL_entity, 1);
  if ( context->isHex )
    v1 = "&#x";
  else
    v1 = "&#";
  context->actions->put_string(context->target, v1);
  context->actions->put_string(context->target, entity_string);
  context->actions->put_character(context->target, 59);
  HTMLSRC_apply_markup_0(context, HTL_entity, 0);
}

//----- (08118165) --------------------------------------------------------
void __cdecl handle_entity(HTStream_2 *context, char term)
{
  int v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // edx
  char *s; // [esp+2Ch] [ebp-Ch]
  int uck; // [esp+30h] [ebp-8h]
  int code; // [esp+34h] [ebp-4h]

  uck = -1;
  s = context->string->data;
  FoundEntity[0] = 0;
  code = HTMLGetEntityUCValue(s);
  if ( !code )
    goto LABEL_51;
  if ( put_special_unicodes(context, code) )
  {
    if ( psrc_view )
      put_pretty_entity(context, term);
    FoundEntity[0] = 1;
    return;
  }
  uck = UCTransUniChar(code, context->outUCLYhndl);
  if ( uck > 31 && uck <= 255 && (uck <= 126 || LYlowest_eightbit[context->outUCLYhndl] <= uck) )
  {
    if ( psrc_view )
      put_pretty_entity(context, term);
    else
      context->actions->put_character(context->target, uck);
    FoundEntity[0] = 1;
    return;
  }
  if ( uck == -4 || context->T.repl_translated_C0 && uck > 0 && uck <= 31 )
  {
    v2 = UCTransUniCharStr(replace_buf, 60, code, context->outUCLYhndl, 0);
    uck = v2 >= 0;
    if ( v2 >= 0 )
    {
      if ( psrc_view )
        put_pretty_entity(context, term);
      else
        context->actions->put_string(context->target, replace_buf);
      FoundEntity[0] = 1;
      return;
    }
  }
  if ( context->T.output_utf8 )
  {
    if ( psrc_view ? UCPutUtf8_charstring((HTStream *)context->target, (putc_func_t *)fake_put_character, code) != 0 : UCPutUtf8_charstring((HTStream *)context->target, (putc_func_t *)context->actions->put_character, code) != 0 )
    {
      if ( psrc_view )
        put_pretty_entity(context, term);
      FoundEntity[0] = 1;
      return;
    }
  }
  if ( code > 31 && code <= 126 )
  {
    if ( psrc_view )
      put_pretty_entity(context, term);
    else
      context->actions->put_character(context->target, code);
    FoundEntity[0] = 1;
    return;
  }
  if ( !strcmp(s, "zwnj") || !strcmp(s, "zwj") )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "handle_entity: Ignoring '%s'.\n", s);
    }
    if ( psrc_view )
      put_pretty_entity(context, term);
    FoundEntity[0] = 1;
    return;
  }
  if ( !strcmp(s, "lrm") || !strcmp(s, "rlm") )
  {
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "handle_entity: Ignoring '%s'.\n", s);
    }
    if ( psrc_view )
      put_pretty_entity(context, term);
    FoundEntity[0] = 1;
  }
  else
  {
LABEL_51:
    if ( psrc_view )
      HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "SGML: Unknown entity '%s' %ld %ld\n", s, code, uck);
    }
    context->actions->put_character(context->target, 38);
    context->actions->put_string(context->target, s);
    if ( term )
      context->actions->put_character(context->target, term);
    if ( psrc_view )
      HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
  }
}

//----- (081185FD) --------------------------------------------------------
void __cdecl handle_comment(HTStream_2 *context)
{
  FILE *v1; // eax
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Comment:\n<%s>\n", s);
  }
  if ( !context->csi && !strncmp(s, "!--#", 4u) && LYCheckForCSI(context->node_anchor, &context->url) == 1 )
    LYDoCSI(context->url, s, &context->csi);
  else
    LYCommentHacks(context->node_anchor, context->string->data);
}

//----- (081186CD) --------------------------------------------------------
void __cdecl handle_identifier(HTStream_2 *context)
{
  FILE *v1; // eax
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Identifier:\n<%s>\n", s);
  }
}

//----- (0811870A) --------------------------------------------------------
void __cdecl handle_doctype(HTStream_2 *context)
{
  FILE *v1; // eax
  FILE *v2; // eax
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Doctype:\n<%s>\n", s);
  }
  if ( strstr(s, "DTD XHTML ") )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "...processing extended HTML\n");
    }
    context->extended_html = 1;
  }
}

//----- (08118787) --------------------------------------------------------
void __cdecl handle_marked(HTStream_2 *context)
{
  FILE *v1; // eax
  char *s; // [esp+20h] [ebp-8h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Marked Section:\n<%s>\n", s);
  }
  if ( !strncmp(context->string->data, "![INCLUDE[", 0xAu) )
  {
    context->string->data[context->string->size - 3] = 0;
    HTSACat(&context->include, (const char *)context->string->data + 10);
  }
  else if ( !strncmp(context->string->data, "![CDATA[", 8u) )
  {
    context->actions->put_block(context->target, context->string->data + 8, context->string->size - 11);
  }
}

//----- (08118882) --------------------------------------------------------
void __cdecl handle_processing_instruction(HTStream_2 *context)
{
  FILE *v1; // eax
  FILE *v2; // eax
  char *t; // [esp+1Ch] [ebp-Ch]
  char *ta; // [esp+1Ch] [ebp-Ch]
  int flag; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Processing instruction:\n<%s>\n", s);
  }
  if ( !strncmp(s, "?xml ", 5u) )
  {
    flag = context->T.decode_utf8;
    context->strict_xml = 1;
    if ( !flag )
    {
      t = strstr(s, "encoding=");
      if ( t )
      {
        ta = t + 9;
        if ( *ta == 34 )
          ++ta;
        flag = strncmp(ta, "utf-8", 5u) == 0;
      }
      if ( flag )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "...Use UTF-8 for XML\n");
        }
        context->T.decode_utf8 = 1;
      }
    }
  }
}

//----- (08118989) --------------------------------------------------------
void __cdecl handle_sgmlent(HTStream_2 *context)
{
  FILE *v1; // eax
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Entity Declaration:\n<%s>\n", s);
  }
}

//----- (081189C6) --------------------------------------------------------
void __cdecl handle_sgmlele(HTStream_2 *context)
{
  FILE *v1; // eax
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Element Declaration:\n<%s>\n", s);
  }
}

//----- (08118A03) --------------------------------------------------------
void __cdecl handle_sgmlatt(HTStream_2 *context)
{
  FILE *v1; // eax
  char *s; // [esp+24h] [ebp-4h]

  s = context->string->data;
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "SGML Attribute Declaration:\n<%s>\n", s);
  }
}

//----- (08118A40) --------------------------------------------------------
BOOLEAN __cdecl element_valid_within(HTTag *new_tag, HTTag *stacked_tag, BOOLEAN direct)
{
  TagClass contains; // [esp+4h] [ebp-24h]
  TagClass contained; // [esp+8h] [ebp-20h]

  if ( !stacked_tag || !new_tag )
    return 1;
  if ( direct )
    contains = stacked_tag->contains;
  else
    contains = stacked_tag->icontains;
  if ( direct )
    contained = new_tag->contained;
  else
    contained = new_tag->icontained;
  if ( new_tag == stacked_tag )
    return (contains & 0x80000) != 0 && (contained & 0x80000) != 0;
  else
    return (contains & new_tag->tagclass) != 0 && (contained & stacked_tag->tagclass) != 0;
}

//----- (08118B11) --------------------------------------------------------
canclose_t __cdecl can_close(HTTag *new_tag, HTTag *stacked_tag)
{
  int v2; // eax

  if ( !stacked_tag )
    return 0;
  if ( (stacked_tag->flags & 1) != 0 )
    return 2;
  if ( new_tag == stacked_tag )
    v2 = new_tag->canclose & 0x80000;
  else
    v2 = stacked_tag->tagclass & new_tag->canclose;
  return v2 != 0;
}

//----- (08118B7A) --------------------------------------------------------
void __cdecl do_close_stacked(HTStream_2 *context)
{
  int v1; // [esp+Ch] [ebp-1Ch]
  BOOLEAN v2; // [esp+13h] [ebp-15h]
  HTElement *stacked; // [esp+20h] [ebp-8h]

  stacked = context->element_stack;
  if ( stacked )
  {
    if ( context->inSELECT && !strcasecomp(stacked->tag->name, "SELECT") )
      context->inSELECT = 0;
    if ( (char *)stacked->tag - (char *)context->dtd->tags > 6607 )
      v1 = 79;
    else
      v1 = -1227133513 * (((char *)stacked->tag - (char *)context->dtd->tags) >> 3);
    if ( !psrc_view )
      context->actions->end_element(context->target, v1, &context->include);
    context->element_stack = stacked->next;
    pool_free(stacked);
    if ( context->element_stack )
      v2 = context->element_stack->tag->flags & 0x40;
    else
      v2 = 0;
    context->no_lynx_specialcodes = v2;
  }
}

//----- (08118C8D) --------------------------------------------------------
int __cdecl is_on_stack(HTStream_2 *context, HTTag *old_tag)
{
  int v3; // [esp+8h] [ebp-18h]
  int i; // [esp+18h] [ebp-8h]
  HTElement *stacked; // [esp+1Ch] [ebp-4h]

  stacked = context->element_stack;
  i = 1;
  while ( stacked )
  {
    if ( stacked->tag == old_tag )
      return i;
    v3 = (unsigned int)((char *)old_tag - (char *)context->dtd->tags - 4424) <= 0x37 ? 6608 : 8
                                                                                            * (((char *)old_tag
                                                                                              - (char *)context->dtd->tags) >> 3);
    if ( stacked->tag == (HTTag *)((char *)context->dtd->tags + v3) )
      return i;
    stacked = stacked->next;
    ++i;
  }
  return 0;
}

//----- (08118D4F) --------------------------------------------------------
void __cdecl end_element(HTStream_2 *context, HTTag *old_tag)
{
  const char *v2; // ebx
  FILE *v3; // eax
  const char *v4; // ebx
  FILE *v5; // eax
  FILE *v6; // eax
  const char *v7; // esi
  const char *v8; // edi
  const char *v9; // ebx
  FILE *v10; // eax
  const char *name; // ebx
  FILE *v12; // eax
  const char *v13; // ebx
  FILE *v14; // eax
  const char *v15; // ebx
  FILE *v16; // eax
  const char *v17; // esi
  const char *v18; // edi
  const char *v19; // ebx
  FILE *v20; // eax
  const char *v21; // esi
  const char *v22; // edi
  const char *v23; // ebx
  FILE *v24; // eax
  FILE *v25; // edx
  const char *v26; // ebx
  FILE *v27; // eax
  const char *v28; // ebx
  FILE *v29; // eax
  const char *v30; // ebx
  FILE *v31; // eax
  const char *v32; // [esp+18h] [ebp-60h]
  const char *v33; // [esp+1Ch] [ebp-5Ch]
  const char *v34; // [esp+20h] [ebp-58h]
  const char *v35; // [esp+24h] [ebp-54h]
  const char *v36; // [esp+28h] [ebp-50h]
  HTTag *tag; // [esp+2Ch] [ebp-4Ch]
  int v38; // [esp+34h] [ebp-44h]
  int v39; // [esp+38h] [ebp-40h]
  int v40; // [esp+44h] [ebp-34h]
  BOOLEAN v41; // [esp+4Bh] [ebp-2Dh]
  HTElement *N; // [esp+54h] [ebp-24h]
  int status; // [esp+5Ch] [ebp-1Ch]
  int stackpos; // [esp+60h] [ebp-18h]
  canclose_t canclose_check; // [esp+64h] [ebp-14h]
  BOOLEAN extra_action_taken; // [esp+6Bh] [ebp-Dh]

  extra_action_taken = 0;
  canclose_check = close_valid;
  stackpos = is_on_stack(context, old_tag);
  if ( Old_DTD )
  {
LABEL_30:
    if ( context->inSELECT )
    {
      if ( strcasecomp(old_tag->name, "SELECT") )
      {
        if ( WWW_TraceFlag[0] )
        {
          name = old_tag->name;
          v12 = TraceFP();
          fprintf(v12, "SGML: ***Ignoring end tag </%s> in SELECT block.\n", name);
        }
        return;
      }
      context->inSELECT = 0;
    }
    if ( WWW_TraceFlag[0] )
    {
      v13 = old_tag->name;
      v14 = TraceFP();
      fprintf(v14, "SGML: End </%s>\n", v13);
    }
    if ( old_tag->contents == SGML_EMPTY )
    {
      if ( WWW_TraceFlag[0] )
      {
        v15 = old_tag->name;
        v16 = TraceFP();
        fprintf(v16, "SGML: ***Illegal end tag </%s> found.\n", v15);
      }
      return;
    }
    if ( context->element_stack )
    {
      status = 0;
      N = context->element_stack;
      if ( N->tag == old_tag )
      {
        tag = N->tag;
      }
      else
      {
        if ( (char *)N->tag - (char *)context->dtd->tags > 6607 )
          v38 = 4424;
        else
          v38 = 8 * (((char *)N->tag - (char *)context->dtd->tags) >> 3);
        tag = (HTTag *)((char *)context->dtd->tags + v38);
      }
      if ( old_tag != tag )
      {
        if ( !context->element_stack->next )
        {
          if ( WWW_TraceFlag[0] )
          {
            v21 = old_tag->name;
            v22 = tag->name;
            v23 = old_tag->name;
            v24 = TraceFP();
            fprintf(v24, "SGML: Found </%s> when expecting </%s>. </%s> ***Ignored.\n", v23, v22, v21);
          }
          return;
        }
        if ( WWW_TraceFlag[0] )
        {
          v17 = tag->name;
          v18 = tag->name;
          v19 = old_tag->name;
          v20 = TraceFP();
          fprintf(v20, "SGML: Found </%s> when expecting </%s>. </%s> ***assumed.\n", v19, v18, v17);
        }
      }
      if ( (char *)tag - (char *)context->dtd->tags > 6607 )
        v39 = 79;
      else
        v39 = -1227133513 * (((char *)tag - (char *)context->dtd->tags) >> 3);
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 1) != 0 )
      {
        v25 = TraceFP();
        fprintf(v25, "tagnum(%p) = %d\n", tag, v39);
      }
      if ( !psrc_view )
        status = context->actions->end_element(context->target, v39, &context->include);
      if ( status == 700 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v26 = tag->name;
          v27 = TraceFP();
          fprintf(v27, "SGML: Restart <%s>\n", v26);
        }
        context->actions->start_element(context->target, v39, 0, 0, context->current_tag_charset, &context->include);
      }
      else if ( status == 701 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v28 = tag->name;
          v29 = TraceFP();
          fprintf(v29, "SGML: Continue with other content model for <%s>\n", v28);
        }
        if ( v39 == 79 )
          v40 = 118;
        else
          v40 = v39;
        context->element_stack->tag = &context->dtd->tags[v40];
      }
      else
      {
        context->element_stack = N->next;
        pool_free(N);
      }
      if ( context->element_stack )
        v41 = context->element_stack->tag->flags & 0x40;
      else
        v41 = 0;
      context->no_lynx_specialcodes = v41;
      return;
    }
    if ( WWW_TraceFlag[0] )
    {
      v30 = old_tag->name;
      v31 = TraceFP();
      fprintf(v31, "SGML: Extra end tag </%s> found and ignored.\n", v30);
    }
  }
  else
  {
    while ( canclose_check && context->element_stack && (stackpos > 1 || !extra_action_taken && !stackpos) )
    {
      if ( !stackpos && (old_tag->flags & 2) != 0 && element_valid_within(old_tag, context->element_stack->tag, 1) )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = old_tag->name;
          v3 = TraceFP();
          fprintf(v3, "SGML: </%s> ignored\n", v2);
        }
        return;
      }
      canclose_check = can_close(old_tag, context->element_stack->tag);
      if ( canclose_check )
      {
        if ( WWW_TraceFlag[0] )
        {
          v32 = old_tag->name;
          if ( canclose_check == close_valid )
            v33 = "supplied,";
          else
            v33 = "***forced by";
          v4 = context->element_stack->tag->name;
          v5 = TraceFP();
          fprintf(v5, "SGML: End </%s> \t<- %s end </%s>\n", v4, v33, v32);
        }
        do_close_stacked(context);
        extra_action_taken = 1;
        stackpos = is_on_stack(context, old_tag);
      }
    }
    if ( stackpos || old_tag->contents == SGML_EMPTY )
    {
      if ( stackpos <= 1 )
        goto LABEL_30;
      if ( WWW_TraceFlag[0] )
      {
        v7 = old_tag->name;
        v8 = context->element_stack->tag->name;
        v9 = old_tag->name;
        v10 = TraceFP();
        fprintf(v10, "SGML: Nesting <%s>...<%s> \t<- ***invalid end </%s>\n", v9, v8, v7);
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      v34 = old_tag->name;
      v35 = old_tag->name;
      if ( context->element_stack )
        v36 = context->element_stack->tag->name;
      else
        v36 = "none";
      v6 = TraceFP();
      fprintf(v6, "SGML: Still open %s, ***no open %s for </%s>\n", v36, v35, v34);
    }
  }
}

//----- (081193D6) --------------------------------------------------------
void __cdecl start_element(HTStream_2 *context)
{
  const char *v1; // ebx
  FILE *v2; // eax
  const char *v3; // esi
  const char *v4; // ebx
  FILE *v5; // eax
  const char *v6; // esi
  const char *v7; // ebx
  FILE *v8; // eax
  const char *v9; // esi
  const char *v10; // edi
  const char *v11; // ebx
  FILE *v12; // eax
  const char *v13; // esi
  const char *v14; // ebx
  FILE *v15; // eax
  const char *v16; // ebx
  FILE *v17; // eax
  const char *v18; // ebx
  FILE *v19; // eax
  const char *v20; // ebx
  FILE *v21; // eax
  HTTag *v22; // [esp+4h] [ebp-74h]
  const char *name; // [esp+24h] [ebp-54h]
  const char *v24; // [esp+28h] [ebp-50h]
  bool v25; // [esp+2Fh] [ebp-49h]
  int v26; // [esp+30h] [ebp-48h]
  int v27; // [esp+34h] [ebp-44h]
  int v28; // [esp+38h] [ebp-40h]
  int v29; // [esp+3Ch] [ebp-3Ch]
  int v30; // [esp+48h] [ebp-30h]
  HTElement *N; // [esp+4Ch] [ebp-2Ch]
  int i; // [esp+50h] [ebp-28h]
  canclose_t canclose_check; // [esp+54h] [ebp-24h]
  HTMLElement e; // [esp+58h] [ebp-20h]
  HTTag *new_tag; // [esp+5Ch] [ebp-1Ch]
  BOOLEAN has_attributes; // [esp+67h] [ebp-11h]
  BOOLEAN extra_action_taken; // [esp+68h] [ebp-10h]
  BOOLEAN direct_container; // [esp+69h] [ebp-Fh]
  BOOLEAN valid; // [esp+6Ah] [ebp-Eh]
  BOOLEAN ok; // [esp+6Bh] [ebp-Dh]

  new_tag = context->current_tag;
  e = -1227133513 * (((char *)new_tag - (char *)context->dtd->tags) >> 3);
  ok = 0;
  valid = 1;
  direct_container = 1;
  extra_action_taken = 0;
  canclose_check = close_valid;
  if ( !Old_DTD )
  {
    while ( context->element_stack
         && (canclose_check == close_valid || canclose_check == close_error && context->element_stack->tag == new_tag) )
    {
      valid = element_valid_within(new_tag, context->element_stack->tag, direct_container);
      if ( valid )
        break;
      canclose_check = can_close(new_tag, context->element_stack->tag);
      if ( canclose_check )
      {
        if ( WWW_TraceFlag[0] )
        {
          name = new_tag->name;
          if ( canclose_check == close_valid )
            v24 = "supplied,";
          else
            v24 = "***forced by";
          v1 = context->element_stack->tag->name;
          v2 = TraceFP();
          fprintf(v2, "SGML: End </%s> \t<- %s start <%s>\n", v1, v24, name);
        }
        do_close_stacked(context);
        extra_action_taken = 1;
        if ( canclose_check == close_error )
          direct_container = 0;
      }
      else if ( WWW_TraceFlag[0] )
      {
        v3 = new_tag->name;
        v4 = context->element_stack->tag->name;
        v5 = TraceFP();
        fprintf(v5, "SGML: Still open %s \t<- ***invalid start <%s>\n", v4, v3);
      }
    }
    if ( context->element_stack )
    {
      if ( !valid && (context->element_stack->tag->flags & 8) != 0 )
      {
        valid = element_valid_within(new_tag, context->element_stack->tag, direct_container);
        if ( !valid )
        {
          if ( WWW_TraceFlag[0] )
          {
            v6 = new_tag->name;
            v7 = context->element_stack->tag->name;
            v8 = TraceFP();
            fprintf(v8, "SGML: Still open %s \t<- ***ignoring start <%s>\n", v7, v6);
          }
          return;
        }
      }
    }
    if ( context->element_stack
      && !extra_action_taken
      && canclose_check == close_NO
      && !valid
      && (new_tag->flags & 4) != 0 )
    {
      has_attributes = 0;
      for ( i = 0; new_tag->number_of_attributes > i && !has_attributes; ++i )
        has_attributes = context->present[i];
      if ( !has_attributes )
      {
        if ( WWW_TraceFlag[0] )
        {
          v9 = new_tag->name;
          v10 = new_tag->name;
          v11 = context->element_stack->tag->name;
          v12 = TraceFP();
          fprintf(v12, "SGML: Still open %s, ***converting invalid <%s> to </%s>\n", v11, v10, v9);
        }
        end_element(context, new_tag);
        return;
      }
    }
    if ( context->element_stack
      && canclose_check == close_error
      && !element_valid_within(new_tag, context->element_stack->tag, direct_container)
      && WWW_TraceFlag[0] )
    {
      v13 = new_tag->name;
      v14 = context->element_stack->tag->name;
      v15 = TraceFP();
      fprintf(v15, "SGML: Still open %s \t<- ***invalid start <%s>\n", v14, v13);
    }
  }
  if ( !context->inSELECT )
  {
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)new_tag->name] & 0x200) != 0 )
      v26 = toupper(*(unsigned __int8 *)new_tag->name);
    else
      v26 = *(unsigned __int8 *)new_tag->name;
    if ( ((*__ctype_b_loc())[83] & 0x200) != 0 )
      v27 = toupper(83);
    else
      v27 = 83;
    if ( v26 == v27 )
    {
      v25 = strcasecomp(new_tag->name, "SELECT") == 0;
    }
    else
    {
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)new_tag->name] & 0x200) != 0 )
        v28 = toupper(*(unsigned __int8 *)new_tag->name);
      else
        v28 = *(unsigned __int8 *)new_tag->name;
      if ( ((*__ctype_b_loc())[83] & 0x200) != 0 )
        v29 = toupper(83);
      else
        v29 = 83;
      v25 = v28 == v29;
    }
    if ( v25 )
      context->inSELECT = 1;
    goto LABEL_79;
  }
  if ( !strcasecomp(new_tag->name, "OPTION") )
  {
LABEL_79:
    if ( WWW_TraceFlag[0] )
    {
      v20 = new_tag->name;
      v21 = TraceFP();
      fprintf(v21, "SGML: Start <%s>\n", v20);
    }
    if ( context->actions->start_element(
           context->target,
           -1227133513 * (((char *)new_tag - (char *)context->dtd->tags) >> 3),
           context->present,
           (const char **)context->value,
           context->current_tag_charset,
           &context->include) == 701 )
    {
      if ( (unsigned int)((char *)new_tag - (char *)context->dtd->tags - 4424) <= 0x37 )
        v30 = 6608;
      else
        v30 = 8 * (((char *)new_tag - (char *)context->dtd->tags) >> 3);
      new_tag = (HTTag *)((char *)context->dtd->tags + v30);
    }
    if ( new_tag->contents )
    {
      N = pool_alloc();
      if ( !N )
        outofmem("../../../WWW/Library/Implementation/SGML.c", "start_element");
      N->next = context->element_stack;
      N->tag = new_tag;
      context->element_stack = N;
      context->no_lynx_specialcodes = new_tag->flags & 0x40;
    }
    else if ( e == HTML_META )
    {
      change_chartrans_handling(context);
    }
    return;
  }
  if ( e == HTML_INPUT )
    goto LABEL_72;
  if ( (unsigned int)e > HTML_INPUT )
  {
    if ( e != HTML_SELECT )
    {
      if ( (unsigned int)e > HTML_SELECT )
      {
        if ( e != HTML_TEXTAREA )
          goto LABEL_73;
      }
      else if ( (unsigned int)(e - 65) > 1 )
      {
        goto LABEL_73;
      }
    }
    goto LABEL_72;
  }
  if ( e == HTML_FIELDSET || e == HTML_FORM || e == HTML_BUTTON )
LABEL_72:
    ok = 1;
LABEL_73:
  if ( ok )
  {
    if ( WWW_TraceFlag[0] )
    {
      v16 = new_tag->name;
      v17 = TraceFP();
      fprintf(v17, "SGML: ***Faking SELECT end tag before <%s> start tag.\n", v16);
    }
    v22 = SGMLFindTag(context->dtd, "SELECT");
    end_element(context, v22);
    goto LABEL_79;
  }
  if ( WWW_TraceFlag[0] )
  {
    v18 = new_tag->name;
    v19 = TraceFP();
    fprintf(v19, "SGML: ***Ignoring start tag <%s> in SELECT block.\n", v18);
  }
}

//----- (08119B0B) --------------------------------------------------------
HTTag *__cdecl SGMLFindTag(const SGML_dtd *dtd, const char *s)
{
  int v4; // [esp+10h] [ebp-38h]
  int v5; // [esp+14h] [ebp-34h]
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  HTTag **res; // [esp+30h] [ebp-18h]
  int i; // [esp+38h] [ebp-10h]
  int low; // [esp+3Ch] [ebp-Ch]
  int high; // [esp+40h] [ebp-8h]

  res = (HTTag **)(4 * (*s & 0x3F) + 136003744);
  if ( last_11978[*s & 0x3F] )
  {
    if ( !last_11978[*s & 0x3F]->name )
      return 0;
    if ( !strcasecomp(last_11978[*s & 0x3F]->name, s) )
      return *res;
  }
  low = 0;
  high = dtd->number_of_tags;
  while ( high > low )
  {
    i = low + (high - low) / 2;
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)dtd->tags[i].name] & 0x200) != 0 )
      v5 = toupper(*(unsigned __int8 *)dtd->tags[i].name);
    else
      v5 = *(unsigned __int8 *)dtd->tags[i].name;
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)s] & 0x200) != 0 )
      v6 = toupper(*(unsigned __int8 *)s);
    else
      v6 = *(unsigned __int8 *)s;
    if ( v5 == v6 )
    {
      v4 = strcasecomp(dtd->tags[i].name, s);
    }
    else
    {
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)dtd->tags[i].name] & 0x200) != 0 )
        v7 = toupper(*(unsigned __int8 *)dtd->tags[i].name);
      else
        v7 = *(unsigned __int8 *)dtd->tags[i].name;
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)s] & 0x200) != 0 )
        v8 = toupper(*(unsigned __int8 *)s);
      else
        v8 = *(unsigned __int8 *)s;
      v4 = v7 - v8;
    }
    if ( !v4 )
    {
      *res = &dtd->tags[i];
      return *res;
    }
    if ( v4 >= 0 )
      high = low + (high - low) / 2;
    else
      low = i + 1;
  }
  if ( ((*__ctype_b_loc())[*(unsigned __int8 *)s] & 0x400) != 0 )
    return &HTTag_unrecognized;
  else
    return 0;
}

//----- (08119E2F) --------------------------------------------------------
void __cdecl SGML_free(HTStream_2 *context)
{
  int v1; // [esp+14h] [ebp-14h]
  HTTag *t; // [esp+1Ch] [ebp-Ch]
  HTElement *cur; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( context->recover )
  {
    free(context->recover);
    context->recover = 0;
  }
  if ( context->url )
  {
    free(context->url);
    context->url = 0;
  }
  if ( context->csi )
  {
    free(context->csi);
    context->csi = 0;
  }
  if ( context->include )
  {
    free(context->include);
    context->include = 0;
  }
  if ( context->active_include )
  {
    free(context->active_include);
    context->active_include = 0;
  }
  while ( context->element_stack )
  {
    cur = context->element_stack;
    t = cur->tag;
    context->element_stack = cur->next;
    pool_free(cur);
    if ( !psrc_view )
    {
      if ( (char *)t - (char *)context->dtd->tags > 6607 )
        v1 = 79;
      else
        v1 = -1227133513 * (((char *)t - (char *)context->dtd->tags) >> 3);
      context->actions->end_element(context->target, v1, &context->include);
    }
    if ( context->include )
    {
      free(context->include);
      context->include = 0;
    }
  }
  context->actions->_free(context->target);
  HTChunkFree(context->string);
  for ( i = 0; i <= 35; ++i )
  {
    if ( context->value[i] )
    {
      HTSAFree_extra(context->value[i]);
      context->value[i] = 0;
    }
  }
  if ( context )
    free(context);
  sgml_in_psrc_was_initialized[0] = 0;
}

//----- (0811A07A) --------------------------------------------------------
void __cdecl SGML_abort(HTStream_2 *context, HTError e)
{
  HTElement *cur; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  context->actions->_abort(context->target, e);
  if ( context->recover )
  {
    free(context->recover);
    context->recover = 0;
  }
  if ( context->include )
  {
    free(context->include);
    context->include = 0;
  }
  if ( context->active_include )
  {
    free(context->active_include);
    context->active_include = 0;
  }
  if ( context->url )
  {
    free(context->url);
    context->url = 0;
  }
  if ( context->csi )
  {
    free(context->csi);
    context->csi = 0;
  }
  while ( context->element_stack )
  {
    cur = context->element_stack;
    context->element_stack = cur->next;
    pool_free(cur);
  }
  HTChunkFree(context->string);
  for ( i = 0; i <= 35; ++i )
  {
    if ( context->value[i] )
    {
      HTSAFree_extra(context->value[i]);
      context->value[i] = 0;
    }
  }
  if ( context )
    free(context);
  sgml_in_psrc_was_initialized[0] = 0;
}

//----- (0811A213) --------------------------------------------------------
void __cdecl transform_tag(HTStream_2 *context, HTChunk *string)
{
  if ( !context->strict_xml && tagname_transform != 1 )
  {
    if ( tagname_transform )
      LYUpperCase(string->data);
    else
      LYLowerCase(string->data);
  }
}

//----- (0811A257) --------------------------------------------------------
BOOLEAN __cdecl ignore_when_empty(HTTag *tag)
{
  FILE *v1; // eax
  const char *name; // [esp+10h] [ebp-18h]
  const char *v4; // [esp+14h] [ebp-14h]
  BOOLEAN result; // [esp+27h] [ebp-1h]

  result = 0;
  if ( !LYPreparsedSource
    && LYxhtml_parsing
    && tag->name
    && (tag->flags & 4) == 0
    && tag->contents
    && tag->tagclass != 256
    && (tag->tagclass == 64 || tag->contains && tag->icontains) )
  {
    result = 1;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( tag->name )
      name = tag->name;
    else
      name = (const char *)&unk_8182AE5;
    if ( result )
      v4 = (const char *)&unk_8182AE5;
    else
      v4 = " not";
    v1 = TraceFP();
    fprintf(v1, "SGML Do%s ignore_when_empty:%s\n", v4, name);
  }
  return result;
}

//----- (0811A32D) --------------------------------------------------------
void __cdecl discard_empty(HTStream_2 *context)
{
  FILE *v1; // eax
  FILE *v2; // eax
  const char *name; // [esp+14h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    if ( context->current_tag->name )
      name = context->current_tag->name;
    else
      name = (const char *)&unk_8182AE5;
    v1 = TraceFP();
    fprintf(v1, "SGML discarding empty %s\n", name);
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fflush(v2);
  }
  memset(&empty_tag_12329, 0, sizeof(empty_tag_12329));
  context->current_tag = &empty_tag_12329;
  context->string->size = 0;
}

//----- (0811A3C8) --------------------------------------------------------
BOOLEAN __cdecl end_if_prettysrc(HTStream_2 *context, HTChunk *string, char end_ch)
{
  BOOLEAN result; // [esp+27h] [ebp-1h]

  result = psrc_view;
  if ( psrc_view )
  {
    if ( context->cur_attr_is_name )
    {
      HTStartAnchor((HTStructured_1 *)context->target, string->data, 0);
      context->actions->end_element(context->target, 0, &context->include);
    }
    else if ( context->cur_attr_is_href )
    {
      HTMLSRC_apply_markup_0(context, HTL_href, 1);
      HTStartAnchor((HTStructured_1 *)context->target, 0, string->data);
    }
    psrc_convert_string = 1;
    context->actions->put_string(context->target, string->data);
    if ( context->cur_attr_is_href )
    {
      context->actions->end_element(context->target, 0, &context->include);
      HTMLSRC_apply_markup_0(context, HTL_href, 0);
    }
    if ( end_ch )
      context->actions->put_character(context->target, end_ch);
    HTMLSRC_apply_markup_0(context, HTL_attrval, 0);
  }
  return result;
}

//----- (0811A549) --------------------------------------------------------
void __cdecl SGML_character(HTStream_2 *context, char c_in)
{
  int size; // ebx
  const char *v3; // esi
  FILE *v4; // eax
  int v5; // ecx
  int v6; // ebx
  FILE *v7; // eax
  int v8; // eax
  FILE *v9; // eax
  int leading_spaces; // ebx
  FILE *v11; // eax
  int trailing_spaces; // ebx
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  int v16; // eax
  FILE *v17; // eax
  char *v18; // ebx
  int v19; // esi
  FILE *v20; // eax
  int v21; // ebx
  char *v22; // esi
  FILE *v23; // eax
  FILE *v24; // eax
  char *v25; // ebx
  FILE *v26; // eax
  char *v27; // ebx
  FILE *v28; // eax
  int v29; // ecx
  FILE *v30; // eax
  int v31; // ecx
  int v32; // ecx
  UCode_t v33; // eax
  int v34; // ecx
  char *v35; // ebx
  FILE *v36; // eax
  int v37; // ebx
  char *v38; // esi
  FILE *v39; // eax
  char *v40; // ebx
  FILE *v41; // eax
  char *v42; // ebx
  FILE *v43; // eax
  char *v44; // ebx
  FILE *v45; // eax
  int v46; // ebx
  char *v47; // esi
  int v48; // edi
  FILE *v49; // eax
  char *v50; // ebx
  FILE *v51; // eax
  int v52; // ebx
  char *v53; // esi
  FILE *v54; // eax
  int v55; // ebx
  const char *v56; // esi
  FILE *v57; // eax
  HTTag *v58; // [esp+4h] [ebp-114h]
  int v59; // [esp+1Ch] [ebp-FCh]
  char *data; // [esp+20h] [ebp-F8h]
  HTTag *v61; // [esp+28h] [ebp-F0h]
  bool v62; // [esp+2Ch] [ebp-ECh]
  HTTag *tag; // [esp+30h] [ebp-E8h]
  int v64; // [esp+34h] [ebp-E4h]
  int v65; // [esp+38h] [ebp-E0h]
  bool v66; // [esp+3Fh] [ebp-D9h]
  bool v67; // [esp+40h] [ebp-D8h]
  bool v68; // [esp+47h] [ebp-D1h]
  const char *v69; // [esp+50h] [ebp-C8h]
  int n; // [esp+54h] [ebp-C4h]
  const char *v71; // [esp+58h] [ebp-C0h]
  const char *v72; // [esp+60h] [ebp-B8h]
  sgml_state v74; // [esp+68h] [ebp-B0h]
  sgml_state v75; // [esp+6Ch] [ebp-ACh]
  sgml_state v76; // [esp+70h] [ebp-A8h]
  int v77; // [esp+74h] [ebp-A4h]
  sgml_state v78; // [esp+78h] [ebp-A0h]
  bool v80; // [esp+80h] [ebp-98h]
  int v81; // [esp+88h] [ebp-90h]
  int v82; // [esp+94h] [ebp-84h]
  int v83; // [esp+9Ch] [ebp-7Ch]
  char *v84; // [esp+A0h] [ebp-78h]
  char *puni; // [esp+B8h] [ebp-60h] BYREF
  int i_1; // [esp+BCh] [ebp-5Ch]
  int branch; // [esp+C0h] [ebp-58h]
  HTMLElement e; // [esp+C4h] [ebp-54h]
  HTTag *t_0; // [esp+C8h] [ebp-50h]
  HTTag *t; // [esp+CCh] [ebp-4Ch]
  int i_0; // [esp+D0h] [ebp-48h]
  int i; // [esp+D4h] [ebp-44h]
  int psrc_view_backup; // [esp+D8h] [ebp-40h]
  int testlast; // [esp+DCh] [ebp-3Ch]
  UCode_t uck; // [esp+E0h] [ebp-38h]
  UCode_t clong; // [esp+E4h] [ebp-34h]
  HTTag *testtag; // [esp+E8h] [ebp-30h]
  const char *EntityName; // [esp+ECh] [ebp-2Ch]
  HTChunk *string; // [esp+F0h] [ebp-28h]
  const SGML_dtd *dtd; // [esp+F4h] [ebp-24h]
  BOOLEAN tag_OK; // [esp+FAh] [ebp-1Eh]
  BOOLEAN psrc_tagname_processed; // [esp+FBh] [ebp-1Dh]
  unsigned __int8 sjis_hi; // [esp+FCh] [ebp-1Ch] BYREF
  char saved_char_in; // [esp+FDh] [ebp-1Bh]
  unsigned __int8 c; // [esp+FEh] [ebp-1Ah]
  BOOLEAN chk; // [esp+FFh] [ebp-19h]
  char temp[8]; // [esp+100h] [ebp-18h] BYREF
  unsigned int v108; // [esp+108h] [ebp-10h]

  v108 = __readgsdword(0x14u);
  dtd = context->dtd;
  string = context->string;
  testtag = 0;
  uck = 0;
  saved_char_in = 0;
  ++sgml_offset;
  c = c_in;
  clong = (unsigned __int8)c_in;
  if ( !context->T.decode_utf8 )
    goto LABEL_20;
  if ( (c & 0x80u) == 0 )
  {
    context->utf_count = 0;
    context->utf_buf_p = context->utf_buf;
    *context->utf_buf_p = 0;
LABEL_20:
    if ( context->T.trans_to_uni
      && (!strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname, "euc-jp")
       || !strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname, "shift_jis")) )
    {
      if ( !strcmp(LYCharSet_UC[context->inUCLYhndl].MIMEname, "shift_jis") )
      {
        if ( context->utf_count )
        {
          if ( c > 0x3Fu && c != 127 && c <= 0xFCu )
          {
            context->utf_buf[1] = c;
            clong = UCTransJPToUni(context->utf_buf, 2, context->inUCLYhndl);
          }
          context->utf_count = 0;
        }
        else if ( c > 0x80u && c <= 0x9Fu || c > 0xDFu && c <= 0xEFu )
        {
          context->utf_buf[0] = c;
          context->utf_count = 1;
          clong = -11;
        }
      }
      else if ( context->utf_count )
      {
        if ( c > 0xA0u && c != 0xFF )
        {
          context->utf_buf[1] = c;
          clong = UCTransJPToUni(context->utf_buf, 2, context->inUCLYhndl);
        }
        context->utf_count = 0;
      }
      else if ( c > 0xA0u && c != 0xFF )
      {
        context->utf_buf[0] = c;
        context->utf_count = 1;
        clong = -11;
      }
      goto top1;
    }
    if ( context->T.trans_to_uni
      && (LYlowest_eightbit[context->inUCLYhndl] <= clong || clong <= 31 && clong && context->T.trans_C0_to_uni) )
    {
      clong = UCTransToUni(c, context->inUCLYhndl);
      if ( clong > 0 )
      {
        saved_char_in = c;
        if ( clong <= 255 )
          c = clong;
      }
      goto top1;
    }
    if ( clong > 31 || !clong || !context->T.trans_C0_to_uni )
      goto top0a;
    if ( !context->T.trans_from_uni
      || (clong = UCTransToUni(c, context->inUCLYhndl), clong <= 31)
      && (!context->T.transp || (clong = UCTransToUni(c, context->inUCLYhndl), clong <= 0)) )
    {
      uck = -1;
      if ( context->T.transp )
        uck = UCTransCharStr(replace_buf, 60, c, context->inUCLYhndl, context->inUCLYhndl, 0);
      if ( !context->T.transp || uck < 0 )
        uck = UCTransCharStr(replace_buf, 60, c, context->inUCLYhndl, context->outUCLYhndl, 1);
      if ( uck )
      {
        if ( uck < 0 )
          goto top0a;
        c = replace_buf[0];
        if ( !replace_buf[0] || !replace_buf[1] )
          goto top0a;
        if ( context->state )
        {
          HTSACat(&context->recover, &replace_buf[1]);
          goto top0a;
        }
        context->actions->put_string(context->target, replace_buf);
      }
      return;
    }
    saved_char_in = c;
    if ( clong <= 255 )
      c = clong;
    while ( 1 )
    {
top1:
      while ( clong <= 31 && c != 9 && c != 10 && c != 13 && HTCJK == NOCJK
           || c == 127 && !context->T.transp && LYlowest_eightbit[context->inUCLYhndl] > clong && HTCJK == NOCJK
           || clong > 127
           && clong <= 159
           && !context->T.transp
           && LYlowest_eightbit[context->inUCLYhndl] > clong
           && HTCJK == NOCJK )
      {
after_switch:
        if ( context->include )
        {
          if ( *context->include )
          {
            if ( context->active_include && context->active_include[context->include_index] )
              HTSACat(&context->include, &context->active_include[context->include_index]);
            if ( context->active_include )
            {
              free(context->active_include);
              context->active_include = 0;
            }
            context->active_include = context->include;
            context->include_index = 0;
            context->include = 0;
          }
          else if ( context->include )
          {
            free(context->include);
            context->include = 0;
          }
        }
        if ( context->recover )
        {
          if ( context->recover[context->recover_index] )
          {
            c = context->recover[context->recover_index++];
            goto top;
          }
          if ( context->recover )
          {
            free(context->recover);
            context->recover = 0;
          }
          context->recover_index = 0;
        }
        if ( context->active_include )
        {
          if ( !context->active_include[context->include_index] )
          {
            if ( context->active_include )
            {
              free(context->active_include);
              context->active_include = 0;
            }
            context->include_index = 0;
            goto LABEL_1162;
          }
          if ( context->current_tag_charset != UTF8_handle && !context->T.trans_from_uni )
          {
            c = context->active_include[context->include_index++];
            goto top;
          }
          puni = &context->active_include[context->include_index];
          c = *puni;
          clong = UCGetUniFromUtf8String(&puni);
          if ( clong <= 255 && clong >= 0 )
            c = clong;
          saved_char_in = 0;
          context->include_index = puni - context->active_include + 1;
        }
        else
        {
LABEL_1162:
          if ( !context->csi )
            return;
          if ( !context->csi[context->csi_index] )
          {
            if ( context->csi )
            {
              free(context->csi);
              context->csi = 0;
            }
            context->csi_index = 0;
            return;
          }
          c = context->csi[context->csi_index++];
top:
          saved_char_in = 0;
top0a:
          context->utf_buf[0] = 0;
          clong = c;
        }
      }
      if ( HTCJK == JAPANESE
        && context->state == S_in_kanji
        && (c <= 0x3Fu
         || c == 127
         || c > 0xFCu
         || (context->kanji_buf <= 0x80u || context->kanji_buf > 0x9Fu)
         && (context->kanji_buf <= 0xDFu || context->kanji_buf > 0xEFu))
        && (context->kanji_buf <= 0xA0u || context->kanji_buf == 0xFF || c <= 0xA0u || c == 0xFF)
        && (context->kanji_buf != 0x8E || c <= 0xA0u || c > 0xDFu)
        && !context->T.decode_utf8 )
      {
        if ( context->kanji_buf <= 0xA0u || context->kanji_buf > 0xDFu )
        {
          context->actions->put_character(context->target, context->kanji_buf);
        }
        else
        {
          JISx0201TO0208_SJIS(context->kanji_buf, &sjis_hi, (unsigned __int8 *)&puni);
          context->actions->put_character(context->target, sjis_hi);
          context->actions->put_character(context->target, (char)puni);
        }
        context->state = S_text_2;
      }
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 1) != 0 )
      {
        v59 = c;
        if ( string->data )
          data = string->data;
        else
          data = (char *)&unk_8182AE5;
        size = string->size;
        v3 = state_name(context->state);
        v4 = TraceFP();
        fprintf(v4, "SGML before %s|%.*s|%c|\n", v3, size, data, v59);
      }
      switch ( context->state )
      {
        case S_text_2:
          goto LABEL_122;
        case S_attr:
          if ( c > 0x20u && c != 62 && c != 61 )
            goto LABEL_1117;
          if ( c == 62 && string->size == 1 && *string->data == 47 )
          {
            if ( context->extended_html && ignore_when_empty(context->current_tag) )
              discard_empty(context);
          }
          else
          {
            HTChunkTerminate(string);
            handle_attribute_name(context, string->data);
          }
          if ( psrc_view )
          {
            context->actions->put_character(context->target, 32);
            if ( context->current_attribute_number == -1 )
              HTMLSRC_apply_markup_0(context, HTL_badattr, 1);
            else
              HTMLSRC_apply_markup_0(context, HTL_attrib, 1);
            if ( attrname_transform != 1 )
            {
              if ( attrname_transform )
                LYUpperCase(string->data);
              else
                LYLowerCase(string->data);
            }
            context->actions->put_string(context->target, string->data);
            if ( c == 61 || c <= 0x20u )
              context->actions->put_character(context->target, c);
            if ( c == 61 || c == 62 || c <= 0x20u )
            {
              if ( context->current_attribute_number == -1 )
                HTMLSRC_apply_markup_0(context, HTL_badattr, 0);
              else
                HTMLSRC_apply_markup_0(context, HTL_attrib, 0);
            }
            if ( c == 62 )
            {
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
              context->state = S_text_2;
              goto LABEL_1128;
            }
            string->size = 0;
LABEL_819:
            if ( c == 61 )
              v78 = S_equals;
            else
              v78 = S_attr_gap;
            context->state = v78;
            goto LABEL_1128;
          }
          string->size = 0;
          if ( c != 62 )
            goto LABEL_819;
          if ( context->current_tag->name )
            start_element(context);
          context->state = S_text_2;
          goto LABEL_1128;
        case S_attr_gap:
          if ( c <= 0x20u )
            goto LABEL_1127;
          if ( c == 62 )
          {
            if ( psrc_view )
            {
              if ( context->current_attribute_number == -1 )
                HTMLSRC_apply_markup_0(context, HTL_badattr, 0);
              else
                HTMLSRC_apply_markup_0(context, HTL_attrib, 0);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
            }
            else if ( context->current_tag->name )
            {
              start_element(context);
            }
            context->state = S_text_2;
          }
          else if ( c == 61 )
          {
            if ( psrc_view )
            {
              context->actions->put_character(context->target, 61);
              if ( context->current_attribute_number == -1 )
                HTMLSRC_apply_markup_0(context, HTL_badattr, 0);
              else
                HTMLSRC_apply_markup_0(context, HTL_attrib, 0);
            }
            context->state = S_equals;
          }
          else
          {
LABEL_784:
            HTChunkPutc(string, c);
            context->state = S_attr;
          }
          goto LABEL_1128;
        case S_comment:
          if ( historical_comments )
          {
            if ( c == 62 )
            {
              HTChunkTerminate(string);
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_comm, 1);
                context->actions->put_character(context->target, 60);
                psrc_convert_string = 1;
                context->actions->put_string(context->target, string->data);
                context->actions->put_character(context->target, 62);
                HTMLSRC_apply_markup_0(context, HTL_comm, 0);
              }
              else
              {
                handle_comment(context);
              }
              string->size = 0;
              context->end_comment = 0;
              context->first_dash = 0;
              context->state = S_text_2;
              goto LABEL_1128;
            }
          }
          else
          {
            if ( !context->first_dash && c == 45 )
            {
LABEL_763:
              HTChunkPutc(string, 45);
              context->first_dash = 1;
              goto LABEL_1128;
            }
            if ( context->first_dash && c == 45 )
            {
              HTChunkPutc(string, 45);
              context->first_dash = 0;
              if ( context->end_comment )
              {
                if ( !minimal_comments )
                  context->end_comment = 0;
              }
              else
              {
                context->end_comment = 1;
              }
              goto LABEL_1128;
            }
            if ( context->end_comment && c == 62 )
            {
              HTChunkTerminate(string);
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_comm, 1);
                context->actions->put_character(context->target, 60);
                psrc_convert_string = 1;
                context->actions->put_string(context->target, string->data);
                context->actions->put_character(context->target, 62);
                HTMLSRC_apply_markup_0(context, HTL_comm, 0);
              }
              else
              {
                handle_comment(context);
              }
              string->size = 0;
              context->end_comment = 0;
              context->first_dash = 0;
              context->state = S_text_2;
              goto LABEL_1128;
            }
            context->first_dash = 0;
            if ( context->end_comment && ((*__ctype_b_loc())[c] & 0x2000) == 0 )
              context->end_comment = 0;
          }
          if ( context->T.decode_utf8 && context->utf_buf[0] )
            goto LABEL_928;
          if ( HTCJK == NOCJK && (context->T.output_utf8 || context->T.trans_from_uni) )
          {
            if ( clong == 65533
              && saved_char_in
              && HTPassEightBitRaw
              && (unsigned __int8)saved_char_in >= LYlowest_eightbit[context->outUCLYhndl] )
            {
              goto LABEL_936;
            }
            if ( clong <= 127 && string->size < string->allocated )
            {
              v29 = string->size;
              string->data[string->size] = clong;
              string->size = v29 + 1;
              goto LABEL_1128;
            }
            goto LABEL_940;
          }
          if ( !saved_char_in || !context->T.use_raw_char_in )
            goto LABEL_1117;
          goto LABEL_943;
        case S_cro:
          if ( clong > 126 )
            goto LABEL_370;
          if ( ((*__ctype_b_loc())[c] & 0x100) != 0 )
          {
            if ( tolower(c) == 120 )
              goto LABEL_369;
          }
          else if ( c == 120 )
          {
LABEL_369:
            context->isHex = 1;
            context->state = S_incro;
            goto LABEL_1128;
          }
LABEL_370:
          if ( clong <= 126 && ((*__ctype_b_loc())[c] & 0x800) != 0 )
          {
            HTChunkPutc(string, c);
            context->isHex = 0;
            context->state = S_incro;
            goto LABEL_1128;
          }
          if ( string->size )
            goto LABEL_1128;
          if ( psrc_view )
            HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
          context->actions->put_character(context->target, 38);
          context->actions->put_character(context->target, 35);
          if ( psrc_view )
            HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
          context->state = S_text_2;
          continue;
        case S_doctype:
          if ( context->doctype_bracket )
          {
            HTChunkPutc(string, c);
            if ( c == 93 )
              context->doctype_bracket = 0;
            goto LABEL_1128;
          }
          if ( c == 91 && string->data[string->size - 1] <= 0x20u )
          {
            HTChunkPutc(string, c);
            context->doctype_bracket = 1;
            goto LABEL_1128;
          }
          if ( c == 62 )
          {
            HTChunkTerminate(string);
            if ( psrc_view )
            {
              HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 1);
              context->actions->put_character(context->target, 60);
              context->actions->put_string(context->target, string->data);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 0);
            }
            else
            {
              handle_doctype(context);
            }
            string->size = 0;
            context->state = S_text_2;
            goto LABEL_1128;
          }
          goto LABEL_1117;
        case S_dollar_2:
          if ( c == 64 || c == 66 || c == 65 )
          {
            context->state = S_nonascii_text_2;
          }
          else if ( c == 40 )
          {
            context->state = S_dollar_paren_2;
          }
          goto LABEL_1127;
        case S_dollar_dq:
          if ( c == 64 || c == 66 || c == 65 )
          {
            context->state = S_nonascii_text_dq;
          }
          else if ( c == 40 )
          {
            context->state = S_dollar_paren_dq;
          }
          goto LABEL_1117;
        case S_dollar_paren_2:
          if ( c == 67 )
            context->state = S_nonascii_text_2;
          else
            context->state = S_text_2;
          goto LABEL_1127;
        case S_dollar_paren_dq:
          if ( c == 67 )
            context->state = S_nonascii_text_dq;
          else
            context->state = S_dquoted;
          goto LABEL_1117;
        case S_dollar_paren_sq:
          if ( c == 67 )
            context->state = S_nonascii_text_sq;
          else
            context->state = S_squoted;
          goto LABEL_1117;
        case S_dollar_sq:
          if ( c == 64 || c == 66 || c == 65 )
          {
            context->state = S_nonascii_text_sq;
          }
          else if ( c == 40 )
          {
            context->state = S_dollar_paren_sq;
          }
          goto LABEL_1117;
        case S_dquoted:
          if ( c != 34 && (!soft_dquotes || c != 62) )
          {
            if ( c == 27 )
            {
              context->state = S_esc_dq;
              HTChunkPutc(string, c);
              goto LABEL_1128;
            }
            if ( context->T.decode_utf8 && context->utf_buf[0] )
            {
LABEL_928:
              HTChunkPuts(string, context->utf_buf);
              context->utf_buf_p = context->utf_buf;
              *context->utf_buf_p = 0;
              goto LABEL_1128;
            }
            if ( HTCJK == NOCJK && (context->T.output_utf8 || context->T.trans_from_uni) )
            {
              if ( clong == 65533
                && saved_char_in
                && HTPassEightBitRaw
                && (unsigned __int8)saved_char_in >= LYlowest_eightbit[context->outUCLYhndl] )
              {
LABEL_936:
                v33 = (unsigned __int8)saved_char_in;
                BYTE1(v33) = -16;
                HTChunkPutUtf8Char(string, v33);
              }
              else if ( clong > 127 || string->size >= string->allocated )
              {
LABEL_940:
                HTChunkPutUtf8Char(string, clong);
              }
              else
              {
                v34 = string->size;
                string->data[string->size] = clong;
                string->size = v34 + 1;
              }
              goto LABEL_1128;
            }
            if ( saved_char_in && context->T.use_raw_char_in )
            {
LABEL_943:
              HTChunkPutc(string, saved_char_in);
              goto LABEL_1128;
            }
LABEL_1117:
            HTChunkPutc(string, c);
            goto LABEL_1128;
          }
          HTChunkTerminate(string);
          if ( !end_if_prettysrc(context, string, c) )
            handle_attribute_value(context, string->data);
          string->size = 0;
          context->state = S_tag_gap;
          if ( c != 62 )
            goto LABEL_1128;
          continue;
        case S_end:
          if ( clong > 126 )
            goto LABEL_958;
          if ( string->size )
          {
            if ( ((*__ctype_b_loc())[c] & 8) != 0 || c == 95 || c == 45 || c == 46 || c == 58 )
              goto LABEL_1117;
          }
          else if ( ((*__ctype_b_loc())[c] & 0x400) != 0 )
          {
            goto LABEL_1117;
          }
LABEL_958:
          t_0 = 0;
          psrc_tagname_processed = 0;
          HTChunkTerminate(string);
          if ( *string->data )
          {
            t_0 = SGMLFindTag(dtd, string->data);
          }
          else if ( context->element_stack )
          {
            t_0 = context->element_stack->tag;
          }
          if ( t_0 && context->unknown_tag != t_0 )
          {
            if ( !psrc_view )
            {
              v80 = c == 62 || c <= 0x20u;
              tag_OK = v80;
              e = -1227133513 * (((char *)t_0 - (char *)context->dtd->tags) >> 3);
              branch = 2;
              context->current_tag = t_0;
              if ( (unsigned int)((char *)t_0 - (char *)context->dtd->tags - 4424) <= 0x37 && context->element_stack )
              {
                v81 = (unsigned int)((char *)t_0 - (char *)context->dtd->tags - 4424) <= 0x37 ? 6608 : 8 * (((char *)t_0 - (char *)context->dtd->tags) >> 3);
                if ( (char *)context->dtd->tags + v81 == (char *)context->element_stack->tag )
                {
                  if ( (char *)context->element_stack->tag - (char *)context->dtd->tags > 6607 )
                    v82 = 4424;
                  else
                    v82 = 8 * (((char *)context->element_stack->tag - (char *)context->dtd->tags) >> 3);
                  context->element_stack->tag = (HTTag *)((char *)context->dtd->tags + v82);
                }
              }
              if ( tag_OK && Old_DTD )
              {
                switch ( e )
                {
                  case HTML_A:
                  case HTML_B:
                  case HTML_BLINK:
                  case HTML_CITE:
                  case HTML_EM:
                  case HTML_FONT:
                  case HTML_FORM:
                  case HTML_I:
                  case HTML_P:
                  case HTML_STRONG:
                  case HTML_TT:
                  case HTML_U:
                    branch = 1;
                    break;
                  case HTML_COLGROUP:
                  case HTML_DD:
                  case HTML_DT:
                  case HTML_LH:
                  case HTML_LI:
                  case HTML_TBODY:
                  case HTML_TD:
                  case HTML_TFOOT:
                  case HTML_TH:
                  case HTML_THEAD:
                  case HTML_TR:
                    branch = 0;
                    break;
                  default:
                    break;
                }
              }
              if ( Old_DTD )
              {
                if ( tag_OK && !branch )
                {
                  if ( WWW_TraceFlag[0] )
                  {
                    v37 = c;
                    v38 = string->data;
                    v39 = TraceFP();
                    fprintf(v39, "SGML: `</%s%c' found!  Ignoring it.\n", v38, v37);
                  }
                  string->size = 0;
                  context->current_attribute_number = -1;
                  if ( c == 62 )
                  {
                    context->current_tag = 0;
                    context->state = S_text_2;
                  }
                  else
                  {
                    context->state = S_junk_tag;
                  }
                  goto LABEL_1128;
                }
                if ( tag_OK && branch == 1 )
                {
                  if ( context->inSELECT )
                  {
                    if ( strcasecomp(string->data, "FORM") )
                    {
                      if ( WWW_TraceFlag[0] )
                      {
                        v40 = string->data;
                        v41 = TraceFP();
                        fprintf(v41, "SGML: ***Ignoring end tag </%s> in SELECT block.\n", v40);
                      }
                      goto LABEL_1023;
                    }
                    if ( WWW_TraceFlag[0] )
                    {
                      v42 = string->data;
                      v43 = TraceFP();
                      fprintf(v43, "SGML: ***Faking SELECT end tag before </%s> end tag.\n", v42);
                    }
                    v58 = SGMLFindTag(context->dtd, "SELECT");
                    end_element(context, v58);
                    if ( WWW_TraceFlag[0] )
                    {
                      v44 = string->data;
                      v45 = TraceFP();
                      fprintf(v45, "SGML: End </%s>\n", v44);
                    }
                    if ( psrc_view )
                      goto LABEL_1023;
                  }
                  else
                  {
                    if ( !strcasecomp(string->data, "P") )
                    {
                      if ( WWW_TraceFlag[0] )
                      {
                        v46 = c;
                        v47 = string->data;
                        v48 = c;
                        v49 = TraceFP();
                        fprintf(v49, "SGML: `</%s%c' found!  Treating as '<%s%c'.\n", v47, v48, v47, v46);
                      }
                      for ( i_1 = 0; context->current_tag->number_of_attributes > i_1; ++i_1 )
                        context->present[i_1] = 0;
                      if ( context->current_tag->name )
                        start_element(context);
                      goto LABEL_1023;
                    }
                    if ( WWW_TraceFlag[0] )
                    {
                      v50 = string->data;
                      v51 = TraceFP();
                      fprintf(v51, "SGML: End </%s>\n", v50);
                    }
                    if ( psrc_view )
                      goto LABEL_1023;
                  }
                  context->actions->end_element(
                    context->target,
                    -1227133513 * (((char *)context->current_tag - (char *)context->dtd->tags) >> 3),
                    &context->include);
LABEL_1023:
                  string->size = 0;
                  context->current_attribute_number = -1;
                  if ( c == 62 )
                  {
                    context->current_tag = 0;
                    context->state = S_text_2;
                  }
                  else
                  {
                    context->state = S_junk_tag;
                  }
                  goto LABEL_1128;
                }
              }
              end_element(context, context->current_tag);
            }
          }
          else
          {
            if ( WWW_TraceFlag[0] )
            {
              v35 = string->data;
              v36 = TraceFP();
              fprintf(v36, "Unknown end tag </%s>\n", v35);
            }
            if ( psrc_view )
            {
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_string(context->target, "</");
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
              HTMLSRC_apply_markup_0(context, HTL_badtag, 1);
              transform_tag(context, string);
              context->actions->put_string(context->target, string->data);
              if ( c == 62 )
              {
                HTMLSRC_apply_markup_0(context, HTL_badtag, 0);
                HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                context->actions->put_character(context->target, 62);
                HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
              }
              else
              {
                context->actions->put_character(context->target, c);
              }
              psrc_tagname_processed = 1;
            }
          }
          if ( psrc_view && !psrc_tagname_processed )
          {
            HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
            context->actions->put_string(context->target, "</");
            HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
            HTMLSRC_apply_markup_0(context, HTL_tag, 1);
            if ( tagname_transform != 1 )
            {
              if ( tagname_transform )
                LYUpperCase(string->data);
              else
                LYLowerCase(string->data);
            }
            context->actions->put_string(context->target, string->data);
            HTMLSRC_apply_markup_0(context, HTL_tag, 0);
            if ( c == 62 )
            {
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
            }
            else
            {
              HTMLSRC_apply_markup_0(context, HTL_badtag, 1);
              context->actions->put_character(context->target, c);
            }
          }
          string->size = 0;
          context->current_attribute_number = -1;
          if ( c == 62 )
          {
            context->current_tag = 0;
            context->state = S_text_2;
          }
          else
          {
            if ( c > 0x20u && WWW_TraceFlag[0] )
            {
              v52 = c;
              v53 = string->data;
              v54 = TraceFP();
              fprintf(v54, "SGML: `</%s%c' found!\n", v53, v52);
            }
            context->state = S_junk_tag;
          }
LABEL_1128:
          if ( WWW_TraceFlag[0] && (WWW_TraceMask & 1) != 0 )
          {
            v83 = c;
            if ( string->data )
              v84 = string->data;
            else
              v84 = (char *)&unk_8182AE5;
            v55 = string->size;
            v56 = state_name(context->state);
            v57 = TraceFP();
            fprintf(v57, "SGML after  %s|%.*s|%c|\n", v56, v55, v84, v83);
          }
          goto after_switch;
        case S_entity:
          goto LABEL_332;
        case S_equals:
          if ( c <= 0x20u )
            goto LABEL_1127;
          switch ( c )
          {
            case '>':
              if ( WWW_TraceFlag[0] )
              {
                v30 = TraceFP();
                fprintf(v30, "SGML: found = but no value\n");
              }
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                context->actions->put_character(context->target, 62);
                HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
              }
              else if ( context->current_tag->name )
              {
                start_element(context);
              }
              context->state = S_text_2;
              goto LABEL_1128;
            case '\'':
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_attrval, 1);
                context->actions->put_character(context->target, c);
              }
              context->state = S_squoted;
              goto LABEL_1128;
            case '"':
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_attrval, 1);
                context->actions->put_character(context->target, c);
              }
              context->state = S_dquoted;
              goto LABEL_1128;
          }
          if ( psrc_view )
            HTMLSRC_apply_markup_0(context, HTL_attrval, 1);
          context->state = S_value;
LABEL_862:
          if ( c <= 0x20u || c == 62 )
          {
            HTChunkTerminate(string);
            if ( !end_if_prettysrc(context, string, 0) )
            {
              if ( HTCJK && *string->data == 36 && (string->data[1] == 66 || string->data[1] == 64) )
              {
                puni = 0;
                HTSprintf0(&puni, "\x1B%s", string->data);
                TO_EUC((const unsigned __int8 *)puni, (unsigned __int8 *)string->data);
                if ( puni )
                {
                  free(puni);
                  puni = 0;
                }
              }
              handle_attribute_value(context, string->data);
            }
            string->size = 0;
            if ( c == 62 )
            {
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                context->actions->put_character(context->target, 62);
                HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
              }
              else if ( context->current_tag->name )
              {
                start_element(context);
              }
              context->state = S_text_2;
            }
            else
            {
              context->state = S_tag_gap;
            }
            goto LABEL_1128;
          }
          if ( context->T.decode_utf8 && context->utf_buf[0] )
            goto LABEL_928;
          if ( HTCJK == NOCJK && (context->T.output_utf8 || context->T.trans_from_uni) )
          {
            if ( clong == 65533
              && saved_char_in
              && HTPassEightBitRaw
              && (unsigned __int8)saved_char_in >= LYlowest_eightbit[context->outUCLYhndl] )
            {
              goto LABEL_936;
            }
            if ( clong <= 127 && string->size < string->allocated )
            {
              v31 = string->size;
              string->data[string->size] = clong;
              string->size = v31 + 1;
              goto LABEL_1128;
            }
            goto LABEL_940;
          }
          if ( saved_char_in && context->T.use_raw_char_in )
            goto LABEL_943;
          goto LABEL_1117;
        case S_ero:
          if ( c == 35 )
          {
            context->state = S_cro;
            goto LABEL_1128;
          }
          context->state = S_entity;
LABEL_332:
          if ( clong <= 126 )
          {
            if ( string->size )
            {
              if ( ((*__ctype_b_loc())[c] & 8) != 0 )
                goto LABEL_1117;
            }
            else if ( ((*__ctype_b_loc())[c] & 0x400) != 0 )
            {
              goto LABEL_1117;
            }
          }
          if ( string->size )
          {
            HTChunkTerminate(string);
            entity_string = string->data;
            if ( !strcmp(string->data, "zwnj")
              && (!context->element_stack
               || context->element_stack->tag && context->element_stack->tag->contents == SGML_MIXED) )
            {
              if ( WWW_TraceFlag[0] )
              {
                v14 = TraceFP();
                fprintf(v14, "SGML_character: Handling 'zwnj' entity as 'WBR' element.\n");
              }
              if ( c == 59 )
                memcpy(temp, "<WBR>", 6u);
              else
                sprintf(temp, "<WBR>%c", c);
              if ( context->recover )
              {
                HTSACat(&context->recover, temp);
              }
              else
              {
                HTSACopy(&context->recover, temp);
                context->recover_index = 0;
              }
              string->size = 0;
              context->state = S_text_2;
              goto LABEL_1128;
            }
            handle_entity(context, 0);
            string->size = 0;
            context->state = S_text_2;
            if ( psrc_view && FoundEntity[0] && c == 59 )
            {
              HTMLSRC_apply_markup_0(context, HTL_entity, 1);
              context->actions->put_character(context->target, c);
              HTMLSRC_apply_markup_0(context, HTL_entity, 0);
            }
            if ( FoundEntity[0] && c == 59 )
              goto LABEL_1128;
          }
          else
          {
            if ( psrc_view )
              HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
            context->actions->put_character(context->target, 38);
            if ( psrc_view )
              HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
            context->state = S_text_2;
          }
          continue;
        case S_esc_2:
          if ( c == 36 )
          {
            context->state = S_dollar_2;
          }
          else if ( c == 40 )
          {
            context->state = S_paren_2;
          }
          else
          {
            context->state = S_text_2;
          }
          goto LABEL_1127;
        case S_esc_dq:
          if ( c == 36 )
          {
            context->state = S_dollar_dq;
          }
          else if ( c == 40 )
          {
            context->state = S_paren_dq;
          }
          else
          {
            context->state = S_dquoted;
          }
          goto LABEL_1117;
        case S_esc_sq:
          if ( c == 36 )
          {
            context->state = S_dollar_sq;
          }
          else if ( c == 40 )
          {
            context->state = S_paren_sq;
          }
          else
          {
            context->state = S_squoted;
          }
          goto LABEL_1117;
        case S_exclamation:
          if ( context->lead_exclamation && c == 45 )
          {
            context->lead_exclamation = 0;
            context->first_dash = 1;
            HTChunkPutc(string, c);
            goto LABEL_1128;
          }
          if ( context->lead_exclamation && c == 91 )
          {
            context->lead_exclamation = 0;
            context->first_bracket = 1;
            context->second_bracket = 0;
            HTChunkPutc(string, c);
            context->state = S_marked;
            goto LABEL_1128;
          }
          if ( context->first_dash && c == 45 )
          {
            context->lead_exclamation = 0;
            context->first_dash = 0;
            context->end_comment = 0;
            HTChunkPutc(string, c);
            context->state = S_comment;
            goto LABEL_1128;
          }
          context->lead_exclamation = 0;
          context->first_dash = 0;
          if ( c == 62 )
          {
            HTChunkTerminate(string);
            if ( psrc_view )
            {
              HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 1);
              context->actions->put_character(context->target, 60);
              context->actions->put_string(context->target, string->data);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 0);
            }
            else
            {
              handle_identifier(context);
            }
            string->size = 0;
            context->state = S_text_2;
            goto LABEL_1128;
          }
          if ( c > 0x20u )
            goto LABEL_1117;
          if ( string->size == 8 && !strncasecomp(string->data, "!DOCTYPE", 8) )
          {
            HTChunkPutc(string, c);
            context->doctype_bracket = 0;
            context->state = S_doctype;
            goto LABEL_1128;
          }
          if ( string->size == 7 && !strncasecomp(string->data, "!ENTITY", 7) )
          {
            HTChunkPutc(string, c);
            context->first_dash = 0;
            context->end_comment = 1;
            context->state = S_sgmlent;
            goto LABEL_1128;
          }
          if ( string->size == 8 && !strncasecomp(string->data, "!ELEMENT", 8) )
          {
            HTChunkPutc(string, c);
            context->first_dash = 0;
            context->end_comment = 1;
            context->state = S_sgmlele;
            goto LABEL_1128;
          }
          if ( string->size == 8 && !strncasecomp(string->data, "!ATTLIST", 8) )
          {
            HTChunkPutc(string, c);
            context->first_dash = 0;
            context->end_comment = 1;
            context->state = S_sgmlatt;
            goto LABEL_1128;
          }
          goto LABEL_1117;
        case S_in_kanji:
          context->state = S_text_2;
          context->actions->put_character(context->target, context->kanji_buf);
          context->actions->put_character(context->target, c);
          goto LABEL_1128;
        case S_incro:
          if ( clong > 126 )
            goto LABEL_384;
          if ( context->isHex )
          {
            if ( ((*__ctype_b_loc())[c] & 0x1000) != 0 )
              goto LABEL_1117;
          }
          else if ( ((*__ctype_b_loc())[c] & 0x800) != 0 )
          {
            goto LABEL_1117;
          }
LABEL_384:
          if ( string->size )
          {
            HTChunkTerminate(string);
            entity_string = string->data;
            if ( context->isHex )
              v68 = sscanf(string->data, "%lx", &puni) == 1;
            else
              v68 = sscanf(string->data, "%lu", &puni) == 1;
            if ( !v68 )
            {
              --string->size;
              HTChunkPutc(string, c);
              HTChunkTerminate(string);
              if ( psrc_view )
                HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
              if ( context->isHex )
              {
                context->actions->put_string(context->target, "&#x");
                context->isHex = 0;
              }
              else
              {
                context->actions->put_string(context->target, "&#");
              }
              if ( psrc_view )
                HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
              if ( context->recover )
              {
                HTSACat(&context->recover, string->data);
              }
              else
              {
                HTSACopy(&context->recover, string->data);
                context->recover_index = 0;
              }
              string->size = 0;
              context->isHex = 0;
              context->state = S_text_2;
              goto LABEL_1128;
            }
            if ( puni == (char *)1 || (unsigned int)puni > 0x7F && (unsigned int)puni <= 0x9B )
            {
              switch ( (unsigned int)puni )
              {
                case 1u:
                  puni = (char *)9786;
                  break;
                case 0x80u:
                  puni = (char *)8364;
                  break;
                case 0x82u:
                  puni = (char *)8218;
                  break;
                case 0x84u:
                  puni = (char *)8222;
                  break;
                case 0x85u:
                  puni = (char *)8230;
                  break;
                case 0x86u:
                  puni = (char *)8224;
                  break;
                case 0x87u:
                  puni = (char *)8225;
                  break;
                case 0x89u:
                  puni = (char *)8240;
                  break;
                case 0x8Bu:
                  puni = (char *)8249;
                  break;
                case 0x91u:
                  puni = (char *)8216;
                  break;
                case 0x92u:
                  puni = (char *)8217;
                  break;
                case 0x93u:
                  puni = (char *)8220;
                  break;
                case 0x94u:
                  puni = (char *)8221;
                  break;
                case 0x95u:
                  puni = (char *)8226;
                  break;
                case 0x96u:
                  puni = (char *)8211;
                  break;
                case 0x97u:
                  puni = (char *)8212;
                  break;
                case 0x98u:
                  puni = (char *)732;
                  break;
                case 0x99u:
                  puni = (char *)8482;
                  break;
                case 0x9Bu:
                  puni = (char *)8250;
                  break;
                default:
                  break;
              }
            }
            if ( puni == (char *)8204
              && (!context->element_stack
               || context->element_stack->tag && context->element_stack->tag->contents == SGML_MIXED) )
            {
              if ( WWW_TraceFlag[0] )
              {
                v15 = TraceFP();
                fprintf(v15, "SGML_character: Handling '8204' (zwnj) reference as 'WBR' element.\n");
              }
              if ( c == 59 )
                memcpy(temp, "<WBR>", 6u);
              else
                sprintf(temp, "<WBR>%c", c);
              if ( context->recover )
              {
                HTSACat(&context->recover, temp);
              }
              else
              {
                HTSACopy(&context->recover, temp);
                context->recover_index = 0;
              }
              string->size = 0;
              context->isHex = 0;
              context->state = S_text_2;
              goto LABEL_1128;
            }
            if ( put_special_unicodes(context, (UCode_t)puni) )
            {
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_entity, 1);
                if ( context->isHex )
                  v69 = "&#x";
                else
                  v69 = "&#";
                context->actions->put_string(context->target, v69);
                context->actions->put_string(context->target, entity_string);
                if ( c == 59 )
                  context->actions->put_character(context->target, 59);
                HTMLSRC_apply_markup_0(context, HTL_entity, 0);
              }
              string->size = 0;
              context->isHex = 0;
              context->state = S_text_2;
              if ( c == 59 )
                goto LABEL_1128;
            }
            else
            {
              uck = UCTransUniChar((int)puni, context->outUCLYhndl);
              if ( uck > 31 && uck <= 255 && (uck <= 126 || LYlowest_eightbit[context->outUCLYhndl] <= uck) )
              {
                if ( psrc_view )
                  goto LABEL_504;
                context->actions->put_character(context->target, uck);
                goto LABEL_521;
              }
              if ( (uck == -4 || context->T.repl_translated_C0 && uck > 0 && uck <= 31)
                && (v16 = UCTransUniCharStr(replace_buf, 60, (int)puni, context->outUCLYhndl, 0), (uck = v16 >= 0) != 0) )
              {
                if ( psrc_view )
                  goto LABEL_504;
                context->actions->put_string(context->target, replace_buf);
LABEL_521:
                string->size = 0;
                context->isHex = 0;
                context->state = S_text_2;
                if ( c == 59 )
                  goto LABEL_1128;
              }
              else
              {
                if ( context->T.output_utf8
                  && UCPutUtf8_charstring(
                       (HTStream *)context->target,
                       (putc_func_t *)context->actions->put_character,
                       (int)puni) )
                {
                  goto LABEL_521;
                }
                if ( puni == (char *)8205 || puni == (char *)8206 || puni == (char *)8207 )
                {
                  if ( WWW_TraceFlag[0] )
                  {
                    n = --string->size;
                    if ( string->size > 63 )
                      n = 63;
                    LYstrncpy(replace_buf, string->data, n);
                    if ( context->isHex )
                      v71 = "&#x";
                    else
                      v71 = "&#";
                    v17 = TraceFP();
                    fprintf(v17, "SGML_character: Ignoring '%s%s'.\n", v71, replace_buf);
                  }
                  if ( psrc_view )
                  {
                    HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
                    if ( context->isHex )
                      v72 = "&#x";
                    else
                      v72 = "&#";
                    context->actions->put_string(context->target, v72);
                    context->actions->put_string(context->target, entity_string);
                    if ( c == 59 )
                      context->actions->put_character(context->target, 59);
                    HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
                  }
                  string->size = 0;
                  context->isHex = 0;
                  context->state = S_text_2;
                  if ( c == 59 )
                    goto LABEL_1128;
                }
                else if ( (unsigned int)puni <= 0xFF
                       && ((unsigned int)puni > 0x1F
                        || puni == (char *)9
                        || puni == (char *)10
                        || puni == (char *)13
                        || HTCJK)
                       && (puni != (char *)127 || HTPassHighCtrlRaw || HTCJK)
                       && ((unsigned int)puni <= 0x7F || (unsigned int)puni > 0x9F || HTPassHighCtrlNum) )
                {
                  if ( (unsigned int)puni <= 0xA0
                    || HTPassEightBitNum
                    || context->outUCLYhndl == LATIN1
                    || context->outUCI && (context->outUCI->enc & 2) != 0 )
                  {
                    if ( !psrc_view )
                    {
                      context->actions->put_character(context->target, (char)puni);
                      goto LABEL_521;
                    }
LABEL_504:
                    put_pretty_number(context);
                    goto LABEL_521;
                  }
                  puni -= 160;
                  EntityName = HTMLGetEntityName((UCode_t)puni);
                  if ( EntityName && *EntityName )
                  {
                    string->size = 0;
                    HTChunkPuts(string, EntityName);
                    HTChunkTerminate(string);
                    handle_entity(context, 0);
                    if ( !FoundEntity[0] )
                      context->actions->put_character(context->target, 59);
                    goto LABEL_521;
                  }
                  if ( psrc_view )
                    HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
                  if ( context->isHex )
                  {
                    context->actions->put_string(context->target, "&#x");
                    context->isHex = 0;
                  }
                  else
                  {
                    context->actions->put_string(context->target, "&#");
                  }
                  --string->size;
                  for ( i_0 = 0; string->size > i_0; ++i_0 )
                    context->actions->put_character(context->target, string->data[i_0]);
                  if ( psrc_view )
                    HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
                  string->size = 0;
                  context->isHex = 0;
                  context->state = S_text_2;
                }
                else
                {
                  if ( psrc_view )
                    HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
                  if ( context->isHex )
                  {
                    context->actions->put_string(context->target, "&#x");
                    context->isHex = 0;
                  }
                  else
                  {
                    context->actions->put_string(context->target, "&#");
                  }
                  --string->size;
                  for ( i_0 = 0; string->size > i_0; ++i_0 )
                    context->actions->put_character(context->target, string->data[i_0]);
                  if ( psrc_view )
                    HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
                  string->size = 0;
                  context->isHex = 0;
                  context->state = S_text_2;
                }
              }
            }
          }
          else
          {
            if ( psrc_view )
              HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
            context->actions->put_string(context->target, "&#x");
            if ( psrc_view )
              HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
            context->isHex = 0;
            context->state = S_text_2;
          }
          break;
        case S_junk_tag:
        case S_pi:
          if ( c == 62 )
          {
            HTChunkTerminate(string);
            if ( psrc_view )
            {
              if ( context->state == S_junk_tag )
                HTMLSRC_apply_markup_0(context, HTL_badtag, 0);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
            }
            if ( context->state == S_pi )
              handle_processing_instruction(context);
            string->size = 0;
            context->current_tag = 0;
            context->state = S_text_2;
            goto LABEL_1128;
          }
          HTChunkPutc(string, c);
          if ( !psrc_view )
            goto LABEL_1128;
          goto LABEL_1127;
        case S_litteral:
          goto case_S_litteral;
        case S_marked:
          if ( context->first_bracket && c == 91 )
          {
            HTChunkPutc(string, 91);
            context->first_bracket = 0;
            context->second_bracket = 1;
            goto LABEL_1128;
          }
          if ( context->second_bracket && c == 93 && string->data[string->size - 1] == 93 )
          {
            HTChunkPutc(string, c);
            context->second_bracket = 0;
            goto LABEL_1128;
          }
          if ( context->second_bracket || c != 62 )
            goto LABEL_1117;
          HTChunkTerminate(string);
          if ( psrc_view )
          {
            HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 1);
            context->actions->put_character(context->target, 60);
            context->actions->put_string(context->target, string->data);
            context->actions->put_character(context->target, 62);
            HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 0);
          }
          else
          {
            handle_marked(context);
          }
          string->size = 0;
          context->state = S_text_2;
          goto LABEL_1128;
        case S_nonascii_text_2:
          if ( c == 27 )
            context->state = S_esc_2;
          context->actions->put_character(context->target, c);
          if ( c <= 0x1Fu )
            context->state = S_text_2;
          goto LABEL_1128;
        case S_nonascii_text_dq:
          if ( c == 27 )
            context->state = S_esc_dq;
          goto LABEL_1117;
        case S_nonascii_text_sq:
          if ( c == 27 )
            context->state = S_esc_sq;
          goto LABEL_1117;
        case S_paren_2:
          if ( c == 66 || c == 74 || c == 84 )
          {
            context->state = S_text_2;
          }
          else if ( c == 73 )
          {
            context->state = S_nonascii_text_2;
          }
          else
          {
            context->state = S_text_2;
          }
          goto LABEL_1127;
        case S_paren_dq:
          if ( c == 66 || c == 74 || c == 84 )
          {
            context->state = S_dquoted;
          }
          else if ( c == 73 )
          {
            context->state = S_nonascii_text_dq;
          }
          else
          {
            context->state = S_dquoted;
          }
          goto LABEL_1117;
        case S_paren_sq:
          if ( c == 66 || c == 74 || c == 84 )
          {
            context->state = S_squoted;
          }
          else if ( c == 73 )
          {
            context->state = S_nonascii_text_sq;
          }
          else
          {
            context->state = S_squoted;
          }
          goto LABEL_1117;
        case S_pcdata:
          if ( string->size || clong > 126 )
            goto case_S_litteral;
          if ( c == 33 )
            goto LABEL_264;
          if ( c == 63 )
          {
            if ( WWW_TraceFlag[0] )
            {
              v9 = TraceFP();
              fprintf(v9, "SGML: Found PI in PCDATA, junking it until '>'\n");
            }
            if ( psrc_view )
            {
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_string(context->target, "<?");
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
            }
            context->state = S_pi;
            goto LABEL_1128;
          }
case_S_litteral:
          HTChunkPutc(string, c);
          if ( psrc_view )
          {
            testtag = context->current_tag;
          }
          else
          {
            if ( context->element_stack )
              tag = context->element_stack->tag;
            else
              tag = 0;
            testtag = tag;
          }
          if ( testtag && testtag->name )
          {
            testlast = string->size - 2 - context->trailing_spaces - context->leading_spaces;
            if ( ((*__ctype_b_loc())[c] & 0x200) != 0 )
              v64 = toupper(c);
            else
              v64 = c;
            if ( testlast < 0 )
              v65 = 47;
            else
              v65 = testtag->name[testlast];
            if ( v64 == v65 )
              goto LABEL_1128;
            if ( c == 62 && testlast >= 0 && !testtag->name[testlast] )
            {
              if ( psrc_view )
              {
                HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                context->actions->put_string(context->target, "</");
                HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                HTMLSRC_apply_markup_0(context, HTL_tag, 1);
                strcpy(string->data, context->current_tag->name);
                transform_tag(context, string);
                context->actions->put_string(context->target, string->data);
                HTMLSRC_apply_markup_0(context, HTL_tag, 0);
                HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                context->actions->put_character(context->target, 62);
                HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                context->current_tag = 0;
              }
              else
              {
                end_element(context, context->element_stack->tag);
              }
              string->size = 0;
              context->current_attribute_number = -1;
              context->state = S_text_2;
              context->leading_spaces = 0;
              context->trailing_spaces = 0;
              goto LABEL_1128;
            }
            if ( ((*__ctype_b_loc())[c] & 0x2000) != 0 )
            {
              if ( testlast == -1 )
              {
                ++context->leading_spaces;
                if ( WWW_TraceFlag[0] && (WWW_TraceMask & 1) != 0 )
                {
                  leading_spaces = context->leading_spaces;
                  v11 = TraceFP();
                  fprintf(v11, "leading spaces: %d\n", leading_spaces);
                }
                goto LABEL_1128;
              }
              if ( testlast > 0 )
              {
                ++context->trailing_spaces;
                if ( WWW_TraceFlag[0] && (WWW_TraceMask & 1) != 0 )
                {
                  trailing_spaces = context->trailing_spaces;
                  v13 = TraceFP();
                  fprintf(v13, "trailing spaces: %d\n", trailing_spaces);
                }
                goto LABEL_1128;
              }
            }
            context->leading_spaces = 0;
            context->trailing_spaces = 0;
            if ( (testtag->contents != SGML_LITTERAL && (testtag->flags & 8) != 0
               || context->state == S_pcdata && (testtag->flags & 9) != 0)
              && testlast >= 0
              && (c == 62 || testlast > 0 || ((*__ctype_b_loc())[c] & 0x400) != 0) )
            {
              context->state = S_end;
              --string->size;
              for ( i = 0; string->size > i; ++i )
                string->data[i] = string->data[i + 1];
              if ( string->size == 1 )
              {
                v66 = ((*__ctype_b_loc())[c] & 0x400) != 0;
              }
              else
              {
                v67 = ((*__ctype_b_loc())[c] & 8) != 0 || c == 95 || c == 45 || c == 46 || c == 58;
                v66 = v67;
              }
              if ( v66 )
                goto LABEL_1128;
              --string->size;
            }
            else
            {
              if ( context->state == S_pcdata
                && (testtag->flags & 9) != 0
                && testlast < 0
                && ((*__ctype_b_loc())[c] & 0x400) != 0 )
              {
                context->state = S_tag;
                goto LABEL_1128;
              }
              context->actions->put_character(context->target, 60);
              for ( i = 0; string->size - 1 > i; ++i )
                context->actions->put_character(context->target, string->data[i]);
              string->size = 0;
              context->state = S_text_2;
            }
          }
          else
          {
            --string->size;
            context->state = S_text_2;
          }
          continue;
        case S_script:
          if ( !string->size && clong <= 126 && c == 33 )
            goto LABEL_264;
          goto case_S_litteral;
        case S_sgmlatt:
          if ( !context->first_dash && c == 45 )
            goto LABEL_763;
          if ( context->first_dash && c == 45 )
          {
            HTChunkPutc(string, 45);
            context->first_dash = 0;
            if ( context->end_comment )
              context->end_comment = 0;
            else
              context->end_comment = 1;
            goto LABEL_1128;
          }
          if ( !context->end_comment || c != 62 )
            goto LABEL_775;
          HTChunkTerminate(string);
          if ( psrc_view )
          {
            HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 1);
            context->actions->put_character(context->target, 60);
            context->actions->put_string(context->target, string->data);
            context->actions->put_character(context->target, 62);
            HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 0);
          }
          else
          {
            handle_sgmlatt(context);
          }
          string->size = 0;
          context->end_comment = 0;
          context->first_dash = 0;
          context->state = S_text_2;
          goto LABEL_1128;
        case S_sgmlele:
          if ( !context->first_dash && c == 45 )
            goto LABEL_763;
          if ( context->first_dash && c == 45 )
          {
            HTChunkPutc(string, 45);
            context->first_dash = 0;
            if ( context->end_comment )
              context->end_comment = 0;
            else
              context->end_comment = 1;
            goto LABEL_1128;
          }
          if ( !context->end_comment || c != 62 )
            goto LABEL_775;
          HTChunkTerminate(string);
          if ( psrc_view )
          {
            HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 1);
            context->actions->put_character(context->target, 60);
            context->actions->put_string(context->target, string->data);
            context->actions->put_character(context->target, 62);
            HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 0);
          }
          else
          {
            handle_sgmlele(context);
          }
          string->size = 0;
          context->end_comment = 0;
          context->first_dash = 0;
          context->state = S_text_2;
          goto LABEL_1128;
        case S_sgmlent:
          if ( !context->first_dash && c == 45 )
            goto LABEL_763;
          if ( context->first_dash && c == 45 )
          {
            HTChunkPutc(string, 45);
            context->first_dash = 0;
            if ( context->end_comment )
              context->end_comment = 0;
            else
              context->end_comment = 1;
          }
          else if ( context->end_comment && c == 62 )
          {
            HTChunkTerminate(string);
            if ( psrc_view )
            {
              HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 1);
              context->actions->put_character(context->target, 60);
              context->actions->put_string(context->target, string->data);
              context->actions->put_character(context->target, 62);
              HTMLSRC_apply_markup_0(context, HTL_sgmlspecial, 0);
            }
            else
            {
              handle_sgmlent(context);
            }
            string->size = 0;
            context->end_comment = 0;
            context->first_dash = 0;
            context->state = S_text_2;
          }
          else
          {
LABEL_775:
            context->first_dash = 0;
            HTChunkPutc(string, c);
          }
          goto LABEL_1128;
        case S_squoted:
          if ( c == 39 )
          {
            HTChunkTerminate(string);
            if ( !end_if_prettysrc(context, string, 39) )
              handle_attribute_value(context, string->data);
            string->size = 0;
            context->state = S_tag_gap;
            goto LABEL_1128;
          }
          if ( c == 27 )
          {
            context->state = S_esc_sq;
            HTChunkPutc(string, c);
            goto LABEL_1128;
          }
          if ( context->T.decode_utf8 && context->utf_buf[0] )
            goto LABEL_928;
          if ( HTCJK == NOCJK && (context->T.output_utf8 || context->T.trans_from_uni) )
          {
            if ( clong == 65533
              && saved_char_in
              && HTPassEightBitRaw
              && (unsigned __int8)saved_char_in >= LYlowest_eightbit[context->outUCLYhndl] )
            {
              goto LABEL_936;
            }
            if ( clong <= 127 && string->size < string->allocated )
            {
              v32 = string->size;
              string->data[string->size] = clong;
              string->size = v32 + 1;
              goto LABEL_1128;
            }
            goto LABEL_940;
          }
          if ( saved_char_in && context->T.use_raw_char_in )
            goto LABEL_943;
          goto LABEL_1117;
        case S_tag:
          if ( clong > 126 )
            goto LABEL_546;
          if ( string->size )
          {
            if ( ((*__ctype_b_loc())[c] & 8) != 0 || c == 95 || c == 45 || c == 46 || c == 58 )
              goto LABEL_1117;
          }
          else if ( ((*__ctype_b_loc())[c] & 0x400) != 0 )
          {
            goto LABEL_1117;
          }
LABEL_546:
          if ( c == 33 && !string->size )
          {
LABEL_264:
            context->state = S_exclamation;
            context->lead_exclamation = 1;
            context->doctype_bracket = 0;
            context->first_bracket = 0;
            HTChunkPutc(string, c);
            goto LABEL_1128;
          }
          if ( string->size || clong > 160 || c == 47 || c == 63 || c == 95 || c == 58 )
          {
            if ( c == 47 )
            {
              if ( !string->size )
              {
                context->state = S_end;
                goto LABEL_1128;
              }
              if ( WWW_TraceFlag[0] )
              {
                v18 = string->data;
                v19 = string->size;
                v20 = TraceFP();
                fprintf(v20, "SGML: `<%.*s/' found!\n", v19, v18);
              }
            }
            HTChunkTerminate(string);
            t = SGMLFindTag(dtd, string->data);
            if ( context->unknown_tag == t
              && (c == 58 && string->size == 4 && !strcasecomp(string->data, "URL")
               || string->size > 4 && !strncasecomp(string->data, "URL:", 4)) )
            {
              if ( psrc_view )
                HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
              context->actions->put_character(context->target, 60);
              context->actions->put_string(context->target, string->data);
              context->actions->put_character(context->target, c);
              if ( psrc_view )
                HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
              if ( WWW_TraceFlag[0] )
              {
                v21 = c;
                v22 = string->data;
                v23 = TraceFP();
                fprintf(v23, "SGML: Treating <%s%c as text\n", v22, v21);
              }
              string->size = 0;
              context->state = S_text_2;
            }
            else
            {
              if ( c == 47 && t )
                context->slashedtag = t;
              if ( t )
              {
                if ( context->unknown_tag == t && WWW_TraceFlag[0] )
                {
                  v27 = string->data;
                  v28 = TraceFP();
                  fprintf(v28, "SGML: *** Unknown element %s\n", v27);
                }
                context->current_tag = t;
                if ( psrc_view )
                {
                  HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                  context->actions->put_character(context->target, 60);
                  HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                  if ( context->unknown_tag == t )
                    HTMLSRC_apply_markup_0(context, HTL_badtag, 1);
                  else
                    HTMLSRC_apply_markup_0(context, HTL_tag, 1);
                  transform_tag(context, string);
                  context->actions->put_string(context->target, string->data);
                  if ( context->unknown_tag == t )
                    HTMLSRC_apply_markup_0(context, HTL_badtag, 0);
                  else
                    HTMLSRC_apply_markup_0(context, HTL_tag, 0);
                }
                if ( !psrc_view )
                  memset(context->present, 0, context->current_tag->number_of_attributes);
                string->size = 0;
                context->current_attribute_number = -1;
                if ( psrc_view )
                {
                  if ( c == 62 || c == 60 || c == 47 && context->slashedtag )
                  {
                    if ( c == 60 )
                    {
                      context->state = S_tag;
                    }
                    else
                    {
                      HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                      context->actions->put_character(context->target, c);
                      HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                      if ( c == 62 )
                        v75 = S_text_2;
                      else
                        v75 = S_tagname_slash;
                      context->state = v75;
                    }
                  }
                  else
                  {
                    if ( c > 0x20u )
                      context->actions->put_character(context->target, c);
                    context->state = S_tag_gap;
                  }
                }
                else if ( c == 62 || c == 60 || c == 47 && context->slashedtag )
                {
                  if ( context->current_tag->name )
                    start_element(context);
                  if ( c == 62 )
                  {
                    v76 = S_text_2;
                  }
                  else
                  {
                    if ( c == 60 )
                      v77 = 39;
                    else
                      v77 = 41;
                    v76 = v77;
                  }
                  context->state = v76;
                }
                else
                {
                  context->state = S_tag_gap;
                }
              }
              else if ( c == 63 && string->size <= 1 )
              {
                if ( WWW_TraceFlag[0] )
                {
                  v24 = TraceFP();
                  fprintf(v24, "SGML: Found PI, looking for '>'\n");
                }
                if ( psrc_view )
                {
                  HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                  context->actions->put_string(context->target, "<?");
                  HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                }
                string->size = 0;
                context->state = S_pi;
                HTChunkPutc(string, c);
              }
              else
              {
                if ( WWW_TraceFlag[0] )
                {
                  v25 = string->data;
                  v26 = TraceFP();
                  fprintf(v26, "SGML: *** Invalid element %s\n", v25);
                }
                if ( psrc_view )
                {
                  HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                  context->actions->put_character(context->target, 60);
                  HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                  HTMLSRC_apply_markup_0(context, HTL_badtag, 1);
                  transform_tag(context, string);
                  context->actions->put_string(context->target, string->data);
                  if ( c == 62 )
                  {
                    HTMLSRC_apply_markup_0(context, HTL_badtag, 0);
                    HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
                    context->actions->put_character(context->target, 62);
                    HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
                  }
                  else
                  {
                    context->actions->put_character(context->target, c);
                  }
                }
                if ( c == 62 )
                  v74 = S_text_2;
                else
                  v74 = S_junk_tag;
                context->state = v74;
              }
            }
            goto LABEL_1128;
          }
          context->state = S_text_2;
          if ( psrc_view )
            HTMLSRC_apply_markup_0(context, HTL_badseq, 1);
          context->actions->put_character(context->target, 60);
          if ( psrc_view )
            HTMLSRC_apply_markup_0(context, HTL_badseq, 0);
          continue;
        case S_tag_gap:
          if ( c <= 0x20u )
            goto LABEL_1128;
          if ( c != 62 )
            goto LABEL_784;
          if ( !psrc_view && context->current_tag->name )
            start_element(context);
          if ( psrc_view )
          {
            HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
            context->actions->put_character(context->target, 62);
            HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
          }
          context->state = S_text_2;
          goto LABEL_1128;
        case S_tagname_slash:
          if ( c != 62 || !context->slashedtag || clong > 126 )
            context->state = S_text_2;
LABEL_122:
          if ( HTCJK && (c & 0x80u) != 0 && !context->T.decode_utf8 )
          {
            context->state = S_in_kanji;
            context->kanji_buf = c;
            goto LABEL_1128;
          }
          if ( HTCJK && c == 27 )
          {
            context->state = S_esc_2;
            context->actions->put_character(context->target, c);
            goto LABEL_1128;
          }
          if ( c == 38 || c == 60 )
          {
            if ( psrc_view )
            {
              testtag = context->current_tag;
            }
            else
            {
              if ( context->element_stack )
                v61 = context->element_stack->tag;
              else
                v61 = 0;
              testtag = v61;
            }
          }
          if ( c == 38
            && clong <= 126
            && (!testtag
             || testtag->contents == SGML_MIXED
             || testtag->contents == SGML_ELEMENT
             || testtag->contents == SGML_PCDATA
             || testtag->contents == SGML_EMPTY
             || testtag->contents == SGML_RCDATA) )
          {
            string->size = 0;
            context->state = S_ero;
            goto LABEL_1128;
          }
          if ( c == 60 && clong <= 126 )
          {
            string->size = 0;
            if ( testtag && testtag->contents == SGML_PCDATA )
            {
              context->state = S_pcdata;
            }
            else if ( testtag && (testtag->contents == SGML_LITTERAL || testtag->contents == SGML_CDATA) )
            {
              context->state = S_litteral;
            }
            else if ( testtag && testtag->contents == SGML_SCRIPT )
            {
              context->state = S_script;
            }
            else
            {
              context->state = S_tag;
            }
            context->slashedtag = 0;
          }
          else if ( context->slashedtag
                 && context->slashedtag->name
                 && (c == 47 || c == 62 && context->state == S_tagname_slash)
                 && clong <= 126 )
          {
            if ( psrc_view )
            {
              HTMLSRC_apply_markup_0(context, HTL_abracket, 1);
              context->actions->put_character(context->target, c);
              HTMLSRC_apply_markup_0(context, HTL_abracket, 0);
            }
            else if ( context->slashedtag != context->unknown_tag
                   && (context->slashedtag->contents || (context->slashedtag->flags & 0x10) != 0) )
            {
              if ( context->recover )
              {
                HTSACat(&context->recover, "</");
              }
              else
              {
                HTSACopy(&context->recover, "</");
                context->recover_index = 0;
              }
              HTSACat(&context->recover, context->slashedtag->name);
              HTSACat(&context->recover, ">");
            }
            context->slashedtag = 0;
          }
          else if ( context->element_stack && (context->element_stack->tag->flags & 0x20) != 0 )
          {
            if ( context->T.decode_utf8 && context->utf_buf[0] )
              goto LABEL_180;
            if ( HTCJK || !context->T.output_utf8 && !context->T.trans_from_uni )
            {
              if ( saved_char_in && context->T.use_raw_char_in )
              {
                context->actions->put_character(context->target, saved_char_in);
                goto LABEL_1128;
              }
LABEL_1127:
              context->actions->put_character(context->target, c);
              goto LABEL_1128;
            }
            if ( (clong & 0x80u) == 0 )
              goto LABEL_1127;
            if ( clong == 65533
              && saved_char_in
              && HTPassEightBitRaw
              && (unsigned __int8)saved_char_in >= LYlowest_eightbit[context->outUCLYhndl] )
            {
              v5 = (unsigned __int8)saved_char_in;
              BYTE1(v5) = -16;
              UCPutUtf8_charstring((HTStream *)context->target, (putc_func_t *)context->actions->put_character, v5);
            }
            else
            {
              UCPutUtf8_charstring((HTStream *)context->target, (putc_func_t *)context->actions->put_character, clong);
            }
          }
          else
          {
            if ( clong == 160 && !context->no_lynx_specialcodes && !context->T.pass_160_173_raw && HTCJK == NOCJK )
            {
              context->actions->put_character(context->target, 1);
              goto LABEL_1128;
            }
            if ( clong == 173 && !context->no_lynx_specialcodes && !context->T.pass_160_173_raw && HTCJK == NOCJK )
            {
              context->actions->put_character(context->target, 7);
              goto LABEL_1128;
            }
            if ( context->T.use_raw_char_in && saved_char_in )
            {
              context->actions->put_character(context->target, saved_char_in);
              saved_char_in = 0;
              goto LABEL_1128;
            }
            v62 = context->T.trans_from_uni && clong > 159;
            chk = v62;
            if ( v62 && (uck = UCTransUniChar(clong, context->outUCLYhndl), uck > 31) && uck <= 255 )
            {
              if ( WWW_TraceFlag[0] )
              {
                v6 = (char)uck;
                v7 = TraceFP();
                fprintf(v7, "UCTransUniChar returned 0x%.2lX:'%c'.\n", uck, v6);
              }
              context->actions->put_character(context->target, uck);
            }
            else
            {
              if ( chk && (uck == -4 || context->T.repl_translated_C0 && uck > 0 && uck <= 31) )
              {
                v8 = UCTransUniCharStr(replace_buf, 60, clong, context->outUCLYhndl, 0);
                uck = v8 >= 0;
                if ( v8 >= 0 )
                {
                  context->actions->put_string(context->target, replace_buf);
                  goto LABEL_1128;
                }
              }
              if ( !context->T.output_utf8
                || !UCPutUtf8_charstring(
                      (HTStream *)context->target,
                      (putc_func_t *)context->actions->put_character,
                      clong) )
              {
                if ( clong <= 160
                  || clong > 255
                  || HTPassEightBitRaw
                  || context->T.do_8bitraw && !context->T.trans_from_uni
                  || HTCJK
                  || context->outUCLYhndl == LATIN1
                  || context->outUCI && (context->outUCI->enc & 2) != 0 )
                {
                  if ( clong <= 126 && clong > 0 )
                    goto LABEL_1127;
                  if ( context->T.output_utf8 && context->utf_buf[0] )
                  {
LABEL_180:
                    context->actions->put_string(context->target, context->utf_buf);
                    context->utf_buf_p = context->utf_buf;
                    *context->utf_buf_p = 0;
                    goto LABEL_1128;
                  }
                  if ( c >= LYlowest_eightbit[context->outUCLYhndl] && (!context->T.trans_from_uni || HTPassEightBitRaw) )
                    goto LABEL_1127;
                }
                else
                {
                  psrc_view_backup = 0;
                  string->size = 0;
                  EntityName = HTMLGetEntityName(clong - 160);
                  HTChunkPuts(string, EntityName);
                  HTChunkTerminate(string);
                  if ( psrc_view )
                  {
                    psrc_view_backup = 1;
                    psrc_view = 0;
                  }
                  handle_entity(context, 0);
                  if ( psrc_view_backup )
                    psrc_view = 1;
                  string->size = 0;
                  if ( !FoundEntity[0] )
                    context->actions->put_character(context->target, 59);
                }
              }
            }
          }
          goto LABEL_1128;
        case S_value:
          goto LABEL_862;
        default:
          goto LABEL_1128;
      }
    }
  }
  if ( context->utf_count > 0 && (c & 0xC0) == 128 )
  {
    context->utf_char = c & 0x3F | (context->utf_char << 6);
    --context->utf_count;
    *context->utf_buf_p++ = c;
    if ( !context->utf_count )
    {
      *context->utf_buf_p = 0;
      clong = context->utf_char;
      if ( clong <= 255 )
        c = clong;
      goto top1;
    }
  }
  else
  {
    context->utf_buf_p = context->utf_buf;
    *context->utf_buf_p++ = c;
    if ( (c & 0xE0) == 192 )
    {
      context->utf_count = 1;
      context->utf_char = c & 0x1F;
    }
    else if ( (c & 0xF0) == 224 )
    {
      context->utf_count = 2;
      context->utf_char = c & 0xF;
    }
    else if ( (c & 0xF8) == 240 )
    {
      context->utf_count = 3;
      context->utf_char = c & 7;
    }
    else if ( (c & 0xFC) == 248 )
    {
      context->utf_count = 4;
      context->utf_char = c & 3;
    }
    else if ( (c & 0xFE) == 252 )
    {
      context->utf_count = 5;
      context->utf_char = c & 1;
    }
    else
    {
      context->utf_count = 0;
      context->utf_buf_p = context->utf_buf;
      *context->utf_buf_p = 0;
    }
  }
}
// 811E182: conditional instruction was optimized away because eax.4 is in (F001..F0FF)
// 811F3BD: conditional instruction was optimized away because eax.4 is in (F001..F0FF)
// 811F5F6: conditional instruction was optimized away because eax.4 is in (F001..F0FF)
// 811F84D: conditional instruction was optimized away because eax.4 is in (F001..F0FF)

//----- (08120C29) --------------------------------------------------------
void __cdecl SGML_string(HTStream_2 *context, const char *str)
{
  while ( *str )
    SGML_character(context, *str++);
}

//----- (08120C5F) --------------------------------------------------------
void __cdecl SGML_write(HTStream_2 *context, const char *str, int l)
{
  char *p; // [esp+14h] [ebp-4h]

  for ( p = (char *)str; p < &str[l]; ++p )
    SGML_character(context, *p);
}

//----- (08120C9C) --------------------------------------------------------
HTStream_2 *__cdecl SGML_new(const SGML_dtd *dtd, HTParentAnchor *anchor, HTStructured *target)
{
  HTStream_2 *context; // [esp+24h] [ebp-4h]

  context = (HTStream_2 *)calloc(1u, 0x154u);
  if ( !context )
    outofmem("../../../WWW/Library/Implementation/SGML.c", "SGML_begin");
  context->isa = &SGMLParser;
  context->string = HTChunkCreate(128);
  context->dtd = dtd;
  context->target = target;
  context->actions = target->isa;
  context->unknown_tag = &HTTag_unrecognized;
  context->slashedtag = 0;
  context->current_tag = context->slashedtag;
  context->state = S_text_2;
  context->node_anchor = anchor;
  context->utf_buf_p = context->utf_buf;
  UCTransParams_clear(&context->T);
  context->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, 1);
  if ( context->inUCLYhndl < 0 )
  {
    HTAnchor_copyUCInfoStage(anchor, 1, 0, -1);
    context->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, 1);
  }
  context->inUCI = HTAnchor_getUCInfoStage(anchor, 1);
  set_chartrans_handling(context, anchor, -1);
  context->recover = 0;
  context->recover_index = 0;
  context->include = 0;
  context->active_include = 0;
  context->include_index = 0;
  context->url = 0;
  context->csi = 0;
  context->csi_index = 0;
  if ( psrc_view )
  {
    psrc_view = 0;
    mark_htext_as_source = 1;
    SGML_string(context, "<HTML><HEAD><TITLE>source</TITLE></HEAD><BODY><PRE>");
    psrc_view = 1;
    psrc_convert_string = 0;
    sgml_in_psrc_was_initialized[0] = 1;
  }
  sgml_offset = 0;
  return context;
}

//----- (08120EC3) --------------------------------------------------------
int SGML_offset()
{
  return psrc_view + sgml_offset;
}

//----- (08120EDA) --------------------------------------------------------
void __cdecl JISx0201TO0208_EUC(unsigned __int8 IHI, unsigned __int8 ILO, unsigned __int8 *OHI, unsigned __int8 *OLO)
{
  if ( IHI == 0x8E && ILO > 0xA0u && ILO <= 0xDFu )
  {
    *OHI = *table_15794[ILO - 161];
    *OLO = table_15794[ILO - 161][1];
  }
  else
  {
    *OHI = IHI;
    *OLO = ILO;
  }
}

//----- (08120F4B) --------------------------------------------------------
int __cdecl IS_SJIS_STR(const unsigned __int8 *str)
{
  char v2; // [esp+2h] [ebp-1Ah]
  char v3; // [esp+3h] [ebp-19h]
  bool v4; // [esp+4h] [ebp-18h]
  int is_sjis; // [esp+10h] [ebp-Ch]
  signed __int8 ch_0; // [esp+1Bh] [ebp-1h]

  is_sjis = 0;
  while ( 1 )
  {
    ch_0 = *str++;
    if ( !ch_0 )
      break;
    if ( ch_0 < 0 )
    {
      if ( *str <= 0x3Fu || *str == 127 || *str > 0xFCu )
      {
        v2 = 0;
      }
      else
      {
        if ( (unsigned __int8)ch_0 <= 0x80u || (unsigned __int8)ch_0 > 0x9Fu )
        {
          v4 = is_sjis && (unsigned __int8)ch_0 > 0xDFu && (unsigned __int8)ch_0 <= 0xEFu;
          v3 = v4;
        }
        else
        {
          is_sjis = 1;
          v3 = 1;
        }
        v2 = v3;
      }
      if ( v2 )
        return 1;
    }
  }
  return 0;
}

//----- (0812100F) --------------------------------------------------------
unsigned __int8 *__cdecl SJIS_TO_JIS1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *JCODE)
{
  unsigned __int8 LOa; // [esp+1h] [ebp-3h]
  unsigned __int8 LOb; // [esp+1h] [ebp-3h]
  unsigned __int8 HIa; // [esp+2h] [ebp-2h]
  char v7; // [esp+3h] [ebp-1h]

  LOa = LO;
  if ( HI > 0x9Fu )
    v7 = -79;
  else
    v7 = 113;
  HIa = 2 * (HI - v7) + 1;
  if ( (LO & 0x80u) != 0 )
    LOa = LO - 1;
  if ( LOa <= 0x9Du )
  {
    LOb = LOa - 31;
  }
  else
  {
    LOb = LOa - 125;
    HIa = 2 * (HI - v7) + 2;
  }
  *JCODE = HIa;
  JCODE[1] = LOb;
  return JCODE;
}

//----- (0812107E) --------------------------------------------------------
unsigned __int8 *__cdecl JIS_TO_SJIS1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *SJCODE)
{
  unsigned __int8 LOa; // [esp+2h] [ebp-2h]
  unsigned __int8 HIa; // [esp+3h] [ebp-1h]

  if ( (HI & 1) != 0 )
    LOa = LO + 31;
  else
    LOa = LO + 125;
  if ( LOa > 0x7Eu )
    ++LOa;
  HIa = ((HI - 33) >> 1) - 127;
  if ( HIa > 0x9Fu )
    HIa += 64;
  *SJCODE = HIa;
  SJCODE[1] = LOa;
  return SJCODE;
}

//----- (081210E2) --------------------------------------------------------
unsigned __int8 *__cdecl EUC_TO_SJIS1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *SJCODE)
{
  char LOa[4]; // [esp+10h] [ebp-8h] BYREF
  char HIa[4]; // [esp+14h] [ebp-4h] BYREF

  HIa[0] = HI;
  LOa[0] = LO;
  if ( HI == 0x8E )
    JISx0201TO0208_EUC(0x8Eu, LOa[0], (unsigned __int8 *)HIa, (unsigned __int8 *)LOa);
  JIS_TO_SJIS1(HIa[0] & 0x7F, LOa[0] & 0x7F, SJCODE);
  return SJCODE;
}
// 81210E2: using guessed type unsigned __int8 HI[4];
// 81210E2: using guessed type unsigned __int8 LO[4];

//----- (08121152) --------------------------------------------------------
void __cdecl JISx0201TO0208_SJIS(unsigned __int8 a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 SJCODE[2]; // [esp+1Eh] [ebp-Ah] BYREF

  JISx0201TO0208_EUC(0x8Eu, a1, a2, a3);
  JIS_TO_SJIS1(*a2 & 0x7F, *a3 & 0x7F, SJCODE);
  *a2 = SJCODE[0];
  *a3 = SJCODE[1];
}

//----- (081211BA) --------------------------------------------------------
unsigned __int8 *__cdecl SJIS_TO_EUC1(unsigned __int8 HI, unsigned __int8 LO, unsigned __int8 *data)
{
  SJIS_TO_JIS1(HI, LO, data);
  *data |= 0x80u;
  data[1] |= 0x80u;
  return data;
}

//----- (08121210) --------------------------------------------------------
unsigned __int8 *__cdecl SJIS_TO_EUC(unsigned __int8 *src, unsigned __int8 *dst)
{
  unsigned __int8 hi; // [esp+12h] [ebp-Eh]
  unsigned __int8 lo; // [esp+13h] [ebp-Dh]
  unsigned __int8 *sp_0; // [esp+14h] [ebp-Ch]
  unsigned __int8 *dp; // [esp+18h] [ebp-8h]
  int in_sjis; // [esp+1Ch] [ebp-4h]

  in_sjis = IS_SJIS_STR(src);
  sp_0 = src;
  dp = dst;
  while ( 1 )
  {
    hi = *sp_0;
    if ( !*sp_0 )
      break;
    lo = sp_0[1];
    if ( !TREAT_SJIS || lo <= 0x3Fu || lo == 127 || lo > 0xFCu )
      goto LABEL_16;
    if ( hi > 0x80u && hi <= 0x9Fu )
    {
      in_sjis = 1;
      goto LABEL_15;
    }
    if ( !in_sjis || hi <= 0xDFu || hi > 0xEFu )
    {
LABEL_16:
      *dp++ = *sp_0++;
    }
    else
    {
LABEL_15:
      SJIS_TO_JIS1(hi, lo, dp);
      *dp |= 0x80u;
      dp[1] |= 0x80u;
      dp += 2;
      sp_0 += 2;
    }
  }
  *dp = 0;
  return dst;
}

//----- (0812132D) --------------------------------------------------------
unsigned __int8 *__cdecl EUC_TO_SJIS(unsigned __int8 *src, unsigned __int8 *dst)
{
  unsigned __int8 *dp; // [esp+10h] [ebp-4h]

  dp = dst;
  while ( *src )
  {
    if ( (*src & 0x80u) == 0 )
    {
      *dp++ = *src++;
    }
    else if ( src[1] && (src[1] & 0x80u) != 0 )
    {
      JIS_TO_SJIS1(*src & 0x7F, src[1] & 0x7F, dp);
      dp += 2;
      src += 2;
    }
    else
    {
      ++src;
    }
  }
  *dp = 0;
  return dst;
}

//----- (081213D1) --------------------------------------------------------
unsigned __int8 *__cdecl EUC_TO_JIS(unsigned __int8 *src, unsigned __int8 *dst, const char *toK, const char *toA)
{
  unsigned __int8 kana_mode; // [esp+Eh] [ebp-1Ah]
  signed __int8 cch; // [esp+Fh] [ebp-19h]
  unsigned __int8 *dp; // [esp+14h] [ebp-14h]
  int is_JIS; // [esp+24h] [ebp-4h]

  kana_mode = 0;
  dp = dst;
  is_JIS = 0;
  while ( 1 )
  {
    cch = *src++;
    if ( !cch )
      break;
    if ( cch >= 0 )
    {
      if ( kana_mode )
      {
        kana_mode = ~kana_mode;
        strcpy((char *)dp, toA);
        dp += strlen((const char *)dp);
      }
      *dp++ = cch;
    }
    else if ( ((unsigned __int8)cch <= 0xA0u || cch == -1 || *src <= 0xA0u || *src == 0xFF)
           && (cch != -114 || *src <= 0xA0u || *src > 0xDFu) )
    {
      if ( cch != -96 || !is_JIS )
      {
        ++is_JIS;
        *dp++ = cch;
      }
    }
    else
    {
      if ( !kana_mode )
      {
        kana_mode = -1;
        strcpy((char *)dp, toK);
        dp += strlen((const char *)dp);
      }
      if ( (*src & 0x80u) != 0 )
      {
        *dp = cch & 0x7F;
        dp[1] = *src & 0x7F;
        dp += 2;
        ++src;
      }
    }
  }
  if ( kana_mode )
  {
    strcpy((char *)dp, toA);
    dp += strlen((const char *)dp);
  }
  if ( dp )
    *dp = 0;
  return dst;
}

//----- (08121543) --------------------------------------------------------
const unsigned __int8 *__cdecl repairJIStoEUC(const unsigned __int8 *src, unsigned __int8 **dstp)
{
  unsigned __int8 *d; // [esp+8h] [ebp-Ch]
  unsigned __int8 ch2; // [esp+12h] [ebp-2h]
  unsigned __int8 ch1; // [esp+13h] [ebp-1h]

  for ( d = *dstp; ; d += 2 )
  {
    ch1 = *src;
    if ( !*src )
      break;
    ch2 = src[1];
    if ( !ch2 )
      break;
    src += 2;
    if ( ch1 == 40 && (ch2 == 66 || ch2 == 74) )
    {
      *dstp = d;
      return src;
    }
    if ( ch1 <= 0x20u || ch1 > 0x7Eu || ch2 <= 0x20u || ch2 > 0x7Eu )
      return 0;
    *d = ch1 | 0x80;
    d[1] = ch2 | 0x80;
  }
  return 0;
}

//----- (081215F5) --------------------------------------------------------
unsigned __int8 *__cdecl TO_EUC(const unsigned __int8 *jis, unsigned __int8 *euc)
{
  unsigned __int8 *v2; // eax
  unsigned __int8 *v3; // edx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // eax
  char v7; // [esp+Eh] [ebp-2Ah]
  char v8; // [esp+Fh] [ebp-29h]
  bool v9; // [esp+10h] [ebp-28h]
  const unsigned __int8 *s; // [esp+14h] [ebp-24h]
  char c; // [esp+1Ah] [ebp-1Eh]
  unsigned __int8 jis_stat; // [esp+1Bh] [ebp-1Dh]
  int in_sjis; // [esp+24h] [ebp-14h]
  const unsigned __int8 *ts; // [esp+28h] [ebp-10h]
  int is_JIS; // [esp+2Ch] [ebp-Ch]
  int n8bits; // [esp+30h] [ebp-8h]
  unsigned __int8 *d; // [esp+34h] [ebp-4h] BYREF

  ++nje_16124;
  n8bits = 0;
  s = jis;
  d = euc;
  jis_stat = 0;
  in_sjis = IS_SJIS_STR(jis);
  is_JIS = 0;
  while ( 1 )
  {
    c = *s++;
    if ( !c )
      break;
    if ( c != (char)0x80 && (c != -96 || !is_JIS) )
    {
      if ( c == 36 && !jis_stat && repair_JIS && (*s == 66 || *s == 64) && (ts = repairJIStoEUC(s + 1, &d)) != 0 )
      {
        s = ts;
      }
      else
      {
        if ( c != 27 )
          goto LABEL_25;
        if ( *s == 36 )
        {
          if ( s[1] != 66 && s[1] != 64 )
          {
            jis_stat = 0;
            goto LABEL_25;
          }
          jis_stat = 0x80;
          s += 2;
          ++is_JIS;
        }
        else if ( *s == 40 )
        {
          jis_stat = 0;
          if ( s[1] != 66 && s[1] != 74 && s[1] != 72 )
            goto LABEL_25;
          s += 2;
        }
        else
        {
          if ( *s == 44 )
            jis_stat = 0;
LABEL_25:
          if ( c < 0 )
            ++n8bits;
          if ( *s <= 0x3Fu || *s == 127 || *s > 0xFCu )
          {
            v7 = 0;
          }
          else
          {
            if ( (unsigned __int8)c <= 0x80u || (unsigned __int8)c > 0x9Fu )
            {
              v9 = in_sjis && (unsigned __int8)c > 0xDFu && (unsigned __int8)c <= 0xEFu;
              v8 = v9;
            }
            else
            {
              in_sjis = 1;
              v8 = 1;
            }
            v7 = v8;
          }
          if ( v7 )
          {
            SJIS_TO_EUC1(c, *s, d);
            d += 2;
            ++s;
            ++is_JIS;
          }
          else if ( jis_stat )
          {
            if ( (unsigned __int8)c > 0x20u && (unsigned __int8)c <= 0x7Eu )
            {
              if ( *s <= 0x20u || *s > 0x7Eu )
              {
                v4 = d;
                *d = c;
                d = v4 + 1;
              }
              else
              {
                v3 = d;
                *d = c | jis_stat;
                d = ++v3;
                *v3 = jis_stat | *s;
                d = v3 + 1;
                ++s;
              }
            }
            else
            {
              v2 = d;
              *d = c;
              d = v2 + 1;
              if ( c == 10 )
                jis_stat = 0;
            }
          }
          else if ( n8bits || c != 15 && c != 14 )
          {
            v5 = d;
            *d = c;
            d = v5 + 1;
          }
        }
      }
    }
  }
  *d = 0;
  return euc;
}
// 8121844: conditional instruction was optimized away because %c.1 is in (21..7E)
// 812184A: conditional instruction was optimized away because %c.1 is in (21..7E)

//----- (081218E5) --------------------------------------------------------
int __cdecl is_EUC_JP(unsigned __int8 *euc)
{
  unsigned __int8 ch2; // [esp+8h] [ebp-Ch]
  unsigned __int8 ch1; // [esp+Ch] [ebp-8h]

  while ( 1 )
  {
    ch1 = *euc;
    if ( !*euc )
      break;
    if ( (ch1 & 0x80) != 0 )
    {
      ch2 = euc[1];
      if ( (ch2 & 0x80) == 0 )
        return 0;
      if ( (ch1 & 0x7Fu) <= 0x20 || (ch1 & 0x7F) == 127 || (ch2 & 0x7Fu) <= 0x20 || (ch2 & 0x7F) == 127 )
        return 0;
      ++euc;
    }
    ++euc;
  }
  return 1;
}

//----- (0812197E) --------------------------------------------------------
void __cdecl TO_SJIS(const unsigned __int8 *arg, unsigned __int8 *sjis)
{
  size_t v2; // eax
  unsigned __int8 *euc; // [esp+14h] [ebp-4h]

  v2 = strlen((const char *)arg);
  euc = (unsigned __int8 *)malloc(v2 + 1);
  if ( !euc )
    outofmem("../../../WWW/Library/Implementation/SGML.c", "TO_SJIS");
  TO_EUC(arg, euc);
  if ( is_EUC_JP(euc) )
    EUC_TO_SJIS(euc, sjis);
  else
    strcpy((char *)sjis, (const char *)arg);
  free(euc);
}

//----- (08121A0B) --------------------------------------------------------
void __cdecl TO_JIS(const unsigned __int8 *arg, unsigned __int8 *jis)
{
  size_t v2; // eax
  unsigned __int8 *euc; // [esp+24h] [ebp-4h]

  if ( *arg )
  {
    v2 = strlen((const char *)arg);
    euc = (unsigned __int8 *)malloc(v2 + 1);
    if ( !euc )
      outofmem("../../../WWW/Library/Implementation/SGML.c", "TO_JIS");
    TO_EUC(arg, euc);
    is_EUC_JP(euc);
    EUC_TO_JIS(euc, jis, "\x1B$B", "\x1B(B");
    free(euc);
  }
  else
  {
    *jis = 0;
  }
}

//----- (08121AA4) --------------------------------------------------------
void __cdecl HTSwitchDTD(int new_flag)
{
  FILE *v1; // eax
  const char *v2; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] )
  {
    if ( new_flag )
      v2 = "strict";
    else
      v2 = "tagsoup";
    v1 = TraceFP();
    fprintf(v1, "HTMLDTD: Copying %s DTD element info of size %d, %d * %d\n", v2, 6664, 119, 56);
  }
  if ( new_flag )
    memcpy(tags, tags_table1, sizeof(tags));
  else
    memcpy(tags, tags_table0, sizeof(tags));
}

//----- (08121B4E) --------------------------------------------------------
void __cdecl HTStartAnchor(HTStructured_1 *obj, const char *name, const char *href)
{
  const char *value[25]; // [esp+30h] [ebp-88h] BYREF
  int i; // [esp+94h] [ebp-24h]
  BOOLEAN present[25]; // [esp+9Bh] [ebp-1Dh] BYREF
  unsigned int v6; // [esp+B4h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  for ( i = 0; i <= 24; ++i )
    present[i] = 0;
  if ( name && *name )
  {
    present[12] = 1;
    value[12] = name;
  }
  if ( href )
  {
    present[6] = 1;
    value[6] = href;
  }
  obj->isa->start_element((HTStructured *)obj, 0, present, value, -1, 0);
}

//----- (08121C23) --------------------------------------------------------
void __cdecl HTStartAnchor5(
        HTStructured_1 *obj,
        const char *name,
        const char *href,
        const char *linktype,
        int tag_charset)
{
  const char *value[25]; // [esp+30h] [ebp-88h] BYREF
  int i; // [esp+94h] [ebp-24h]
  BOOLEAN present[25]; // [esp+9Bh] [ebp-1Dh] BYREF
  unsigned int v8; // [esp+B4h] [ebp-4h]

  v8 = __readgsdword(0x14u);
  for ( i = 0; i <= 24; ++i )
    present[i] = 0;
  if ( name && *name )
  {
    present[12] = 1;
    value[12] = name;
  }
  if ( href && *href )
  {
    present[6] = 1;
    value[6] = href;
  }
  if ( linktype && *linktype )
  {
    present[23] = 1;
    value[23] = linktype;
  }
  obj->isa->start_element((HTStructured *)obj, 0, present, value, tag_charset, 0);
}

//----- (08121D30) --------------------------------------------------------
void __cdecl HTStartIsIndex(HTStructured_1 *obj, const char *prompt, const char *href)
{
  const char *value[9]; // [esp+30h] [ebp-38h] BYREF
  int i; // [esp+54h] [ebp-14h]
  BOOLEAN present[9]; // [esp+5Bh] [ebp-Dh] BYREF
  unsigned int v6; // [esp+64h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  for ( i = 0; i <= 8; ++i )
    present[i] = 0;
  if ( prompt && *prompt )
  {
    present[6] = 1;
    value[6] = prompt;
  }
  if ( href )
  {
    present[3] = 1;
    value[3] = href;
  }
  obj->isa->start_element((HTStructured *)obj, 62, present, value, -1, 0);
}

//----- (08121DE4) --------------------------------------------------------
void __cdecl HTChunkInit(HTChunk *ch_0, int grow)
{
  ch_0->data = 0;
  ch_0->growby = grow;
  ch_0->size = 0;
  ch_0->allocated = 0;
}

//----- (08121E0F) --------------------------------------------------------
HTChunk *__cdecl HTChunkCreate(int grow)
{
  HTChunk *ch_0; // [esp+14h] [ebp-4h]

  ch_0 = (HTChunk *)calloc(1u, 0x18u);
  if ( !ch_0 )
    outofmem("../../../WWW/Library/Implementation/HTChunk.c", "creation of chunk");
  HTChunkInit(ch_0, grow);
  return ch_0;
}

//----- (08121E5D) --------------------------------------------------------
HTChunk *__cdecl HTChunkCreateMayFail(int grow, int failok)
{
  HTChunk *ch_0; // [esp+24h] [ebp-4h]

  ch_0 = (HTChunk *)calloc(1u, 0x18u);
  if ( ch_0 )
  {
    HTChunkInit(ch_0, grow);
    ch_0->failok = failok;
    return ch_0;
  }
  else
  {
    if ( !failok )
      outofmem("../../../WWW/Library/Implementation/HTChunk.c", "creation of chunk");
    return 0;
  }
}

//----- (08121ECA) --------------------------------------------------------
HTChunk *__cdecl HTChunkCreate2(int grow, size_t needed)
{
  int allocated; // ebx
  FILE *v3; // eax
  HTChunk *ch_0; // [esp+2Ch] [ebp-Ch]

  ch_0 = (HTChunk *)calloc(1u, 0x18u);
  if ( !ch_0 )
    outofmem("../../../WWW/Library/Implementation/HTChunk.c", "HTChunkCreate2");
  HTChunkInit(ch_0, grow);
  if ( needed )
  {
    ch_0->allocated = needed - (needed - 1) % ch_0->growby + ch_0->growby - 1;
    if ( WWW_TraceFlag[0] )
    {
      allocated = ch_0->allocated;
      v3 = TraceFP();
      fprintf(v3, "HTChunkCreate2: requested %d, allocate %d\n", needed, allocated);
    }
    ch_0->data = (char *)calloc(ch_0->allocated, 1u);
    if ( !ch_0->data )
      outofmem("../../../WWW/Library/Implementation/HTChunk.c", "HTChunkCreate2 data");
  }
  return ch_0;
}

//----- (08121FCE) --------------------------------------------------------
void __cdecl HTChunkClear(HTChunk *ch_0)
{
  if ( ch_0->data )
  {
    free(ch_0->data);
    ch_0->data = 0;
  }
  ch_0->size = 0;
  ch_0->allocated = 0;
}

//----- (0812200B) --------------------------------------------------------
void __cdecl HTChunkFree(HTChunk *ch_0)
{
  HTChunk *next; // [esp+14h] [ebp-4h]

  do
  {
    next = ch_0->next;
    if ( ch_0->data )
    {
      free(ch_0->data);
      ch_0->data = 0;
    }
    if ( ch_0 )
      free(ch_0);
    ch_0 = next;
  }
  while ( next );
}

//----- (08122062) --------------------------------------------------------
BOOLEAN __cdecl HTChunkRealloc(HTChunk *ch_0, int growby)
{
  char *v3; // [esp+10h] [ebp-18h]

  ch_0->allocated += growby;
  if ( ch_0->data )
    v3 = (char *)realloc(ch_0->data, ch_0->allocated);
  else
    v3 = (char *)calloc(ch_0->allocated, 1u);
  if ( v3 )
  {
    ch_0->data = v3;
    return 1;
  }
  else
  {
    if ( !ch_0->failok )
      outofmem("../../../WWW/Library/Implementation/HTChunk.c", "HTChunkRealloc");
    HTChunkClear(ch_0);
    return 0;
  }
}

//----- (0812210B) --------------------------------------------------------
void __cdecl HTChunkPutc(HTChunk *ch_0, char c)
{
  int size; // ecx

  if ( ch_0->size < ch_0->allocated || HTChunkRealloc(ch_0, ch_0->growby) )
  {
    size = ch_0->size;
    ch_0->data[ch_0->size] = c;
    ch_0->size = size + 1;
  }
}

//----- (0812215E) --------------------------------------------------------
HTChunk *__cdecl HTChunkPutc2(HTChunk *ch_0, char c)
{
  int size; // ecx
  HTChunk *chunk; // [esp+24h] [ebp-4h]

  if ( ch_0->size < ch_0->allocated )
  {
    size = ch_0->size;
    ch_0->data[ch_0->size] = c;
    ch_0->size = size + 1;
    return ch_0;
  }
  else
  {
    chunk = HTChunkCreateMayFail(ch_0->growby, ch_0->failok);
    ch_0->next = chunk;
    HTChunkPutc(chunk, c);
    return chunk;
  }
}

//----- (081221E0) --------------------------------------------------------
void __cdecl HTChunkEnsure(HTChunk *ch_0, int needed)
{
  char *v2; // [esp+14h] [ebp-4h]

  if ( ch_0->allocated < needed )
  {
    ch_0->allocated = ch_0->growby + needed - 1 - (needed - 1) % ch_0->growby;
    if ( ch_0->data )
      v2 = (char *)realloc(ch_0->data, ch_0->allocated);
    else
      v2 = (char *)calloc(ch_0->allocated, 1u);
    ch_0->data = v2;
    if ( !ch_0->data )
      outofmem("../../../WWW/Library/Implementation/HTChunk.c", "HTChunkEnsure");
  }
}

//----- (08122291) --------------------------------------------------------
void __cdecl HTChunkPutb(HTChunk *ch_0, const char *b, int l)
{
  if ( l > 0 && (l + ch_0->size <= ch_0->allocated || HTChunkRealloc(ch_0, l - l % ch_0->growby + ch_0->growby)) )
  {
    memcpy(&ch_0->data[ch_0->size], b, l);
    ch_0->size += l;
  }
}

//----- (08122328) --------------------------------------------------------
HTChunk *__cdecl HTChunkPutb2(HTChunk *ch_0, const char *b, int l)
{
  int m; // [esp+20h] [ebp-8h]
  HTChunk *chunk; // [esp+24h] [ebp-4h]

  if ( l <= 0 )
    return ch_0;
  if ( l + ch_0->size <= ch_0->allocated )
  {
    memcpy(&ch_0->data[ch_0->size], b, l);
    ch_0->size += l;
    return ch_0;
  }
  else
  {
    m = ch_0->allocated - ch_0->size;
    memcpy(&ch_0->data[ch_0->size], b, m);
    ch_0->size += m;
    chunk = HTChunkCreateMayFail(ch_0->growby, ch_0->failok);
    ch_0->next = chunk;
    HTChunkPutb(chunk, &b[m], l - m);
    return chunk;
  }
}

//----- (0812242B) --------------------------------------------------------
void __cdecl HTChunkPutUtf8Char(HTChunk *ch_0, UCode_t code)
{
  int size; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int growby; // [esp+14h] [ebp-14h]
  int utflen; // [esp+24h] [ebp-4h]

  if ( code > 127 )
  {
    if ( code > 2047 )
    {
      if ( code > 0xFFFF )
      {
        if ( code > 0x1FFFFF )
        {
          if ( code > 0x3FFFFFF )
            utflen = 6;
          else
            utflen = 5;
        }
        else
        {
          utflen = 4;
        }
      }
      else
      {
        utflen = 3;
      }
    }
    else
    {
      utflen = 2;
    }
  }
  else
  {
    utflen = 1;
  }
  if ( utflen + ch_0->size <= ch_0->allocated )
    goto LABEL_16;
  growby = ch_0->growby;
  if ( growby < utflen )
    growby = utflen;
  if ( HTChunkRealloc(ch_0, growby) )
  {
LABEL_16:
    switch ( utflen )
    {
      case 0:
        return;
      case 1:
        size = ch_0->size;
        ch_0->data[ch_0->size] = code;
        ch_0->size = size + 1;
        return;
      case 2:
        v3 = ch_0->size;
        ch_0->data[ch_0->size] = (code >> 6) | 0xC0;
        ch_0->size = v3 + 1;
        goto LABEL_23;
      case 3:
        v4 = ch_0->size;
        ch_0->data[ch_0->size] = (code >> 12) | 0xE0;
        ch_0->size = v4 + 1;
        goto LABEL_23;
      case 4:
        v5 = ch_0->size;
        ch_0->data[ch_0->size] = (code >> 18) | 0xF0;
        ch_0->size = v5 + 1;
        goto LABEL_23;
      case 5:
        v6 = ch_0->size;
        ch_0->data[ch_0->size] = HIBYTE(code) | 0xF8;
        ch_0->size = v6 + 1;
        goto LABEL_23;
      case 6:
        v7 = ch_0->size;
        ch_0->data[ch_0->size] = (code >> 30) | 0xFC;
        ch_0->size = v7 + 1;
        goto LABEL_23;
      default:
LABEL_23:
        switch ( utflen )
        {
          case 2:
            goto LABEL_28;
          case 3:
            goto LABEL_27;
          case 4:
            goto LABEL_26;
          case 5:
            goto LABEL_25;
          case 6:
            v8 = ch_0->size;
            ch_0->data[ch_0->size] = HIBYTE(code) & 0x3F | 0x80;
            ch_0->size = v8 + 1;
LABEL_25:
            v9 = ch_0->size;
            ch_0->data[ch_0->size] = (code >> 18) & 0x3F | 0x80;
            ch_0->size = v9 + 1;
LABEL_26:
            v10 = ch_0->size;
            ch_0->data[ch_0->size] = (code >> 12) & 0x3F | 0x80;
            ch_0->size = v10 + 1;
LABEL_27:
            v11 = ch_0->size;
            ch_0->data[ch_0->size] = (code >> 6) & 0x3F | 0x80;
            ch_0->size = v11 + 1;
LABEL_28:
            v12 = ch_0->size;
            ch_0->data[ch_0->size] = code & 0x3F | 0x80;
            ch_0->size = v12 + 1;
            break;
          default:
            return;
        }
        break;
    }
  }
}

//----- (0812269E) --------------------------------------------------------
void __cdecl HTChunkTerminate(HTChunk *ch_0)
{
  HTChunkPutc(ch_0, 0);
}

//----- (081226B9) --------------------------------------------------------
void __cdecl HTChunkPuts(HTChunk *ch_0, const char *s)
{
  int size; // ecx
  char *p; // [esp+14h] [ebp-4h]

  if ( s )
  {
    for ( p = (char *)s; *p && (ch_0->size < ch_0->allocated || HTChunkRealloc(ch_0, ch_0->growby)); ++p )
    {
      size = ch_0->size;
      ch_0->data[ch_0->size] = *p;
      ch_0->size = size + 1;
    }
  }
}

//----- (08122724) --------------------------------------------------------
HTChunk *__cdecl HTChunkPuts2(HTChunk *ch_0, const char *s)
{
  int size; // ecx
  HTChunk *chunk; // [esp+20h] [ebp-8h]
  const char *p; // [esp+24h] [ebp-4h]

  if ( s )
  {
    for ( p = s; *p; ++p )
    {
      if ( ch_0->size >= ch_0->allocated )
      {
        chunk = HTChunkCreateMayFail(ch_0->growby, ch_0->failok);
        ch_0->next = chunk;
        HTChunkPuts(chunk, p);
        return chunk;
      }
      size = ch_0->size;
      ch_0->data[ch_0->size] = *p;
      ch_0->size = size + 1;
    }
  }
  return ch_0;
}

//----- (081227C4) --------------------------------------------------------
void __cdecl HTPlain_getChartransInfo(HTStream_3 *me, HTParentAnchor *anchor)
{
  int chndl; // [esp+24h] [ebp-4h]

  if ( me->inUCLYhndl < 0 )
  {
    HTAnchor_copyUCInfoStage(anchor, 1, 0, 4);
    me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, 1);
  }
  if ( me->outUCLYhndl < 0 )
  {
    chndl = HTAnchor_getUCLYhndl(anchor, 3);
    if ( chndl < 0 )
    {
      chndl = current_char_set;
      HTAnchor_setUCInfoStage(anchor, current_char_set, 3, 1);
    }
    HTAnchor_setUCInfoStage(anchor, chndl, 3, 1);
    me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, 3);
  }
  me->inUCI = HTAnchor_getUCInfoStage(anchor, 1);
  me->outUCI = HTAnchor_getUCInfoStage(anchor, 3);
}

//----- (081228DB) --------------------------------------------------------
void __cdecl HTPlain_put_character(HTStream_3 *me, char c)
{
  char ca[8]; // [esp+14h] [ebp-24h] BYREF

  ca[0] = c;
  if ( HTPlain_lastraw == 13 && ca[0] == 10 )
  {
    HTPlain_lastraw = -1;
    return;
  }
  if ( ca[0] == 8 || ca[0] == 95 || HTPlain_bs_pending )
    goto LABEL_11;
  HTPlain_lastraw = (unsigned __int8)ca[0];
  if ( ca[0] == 13 )
  {
    HText_appendCharacter(me->text, 10);
    return;
  }
  if ( ca[0] > 0x7Eu )
  {
LABEL_11:
    HTPlain_write(me, ca, 1);
  }
  else if ( HTCJK || ca[0] > 0x1Fu || ca[0] == 10 || ca[0] == 9 )
  {
    HText_appendCharacter(me->text, ca[0]);
  }
}
// 81229C3: conditional instruction was optimized away because %c.1 is in (<8u|9..C|E..5E|60..7E)
// 81229FC: conditional instruction was optimized away because %c.1 is in (<8u|9..C|E..5E|60..7E)
// 8122A1F: conditional instruction was optimized away because %c.1 is in (<8u|9..C|E..5E|60..7E)
// 8122A33: conditional instruction was optimized away because %c.1 is in (20..5E|60..7E)
// 8122A69: conditional instruction was optimized away because %c.1 is in (<8u|B..C|E..1F)
// 81228DB: using guessed type char c[8];

//----- (08122BC1) --------------------------------------------------------
void __cdecl HTPlain_put_string(HTStream_3 *me, const char *s)
{
  char *p; // [esp+14h] [ebp-4h]

  if ( s )
  {
    for ( p = (char *)s; *p; ++p )
      HTPlain_put_character(me, *p);
  }
}

//----- (08122BFD) --------------------------------------------------------
void __cdecl HTPlain_write(HTStream_3 *me, const char *s, int l)
{
  FILE *v3; // edx
  int v4; // eax
  int outUCLYhndl; // ebx
  int v6; // eax
  int v7; // eax
  FILE *v8; // eax
  int v9; // [esp+4h] [ebp-44h]
  int v10; // [esp+Ch] [ebp-3Ch]
  bool v11; // [esp+20h] [ebp-28h]
  UCode_t uck; // [esp+2Ch] [ebp-1Ch]
  int code; // [esp+30h] [ebp-18h]
  unsigned int c_unsign; // [esp+34h] [ebp-14h]
  const char *p; // [esp+3Ch] [ebp-Ch]
  char saved_char_in; // [esp+41h] [ebp-7h]
  bool chk; // [esp+42h] [ebp-6h]
  char c; // [esp+43h] [ebp-5h]

  uck = -1;
  for ( p = s; p < &s[l]; ++p )
  {
    if ( *p == 8 )
    {
      if ( HTPlain_lastraw > 31 && HTPlain_lastraw != 13 && HTPlain_lastraw != 10 )
      {
        if ( !HTPlain_bs_pending )
        {
          HTPlain_bs_pending = 1;
          continue;
        }
        if ( HTPlain_bs_pending == 2 )
        {
          HTPlain_bs_pending = 3;
          continue;
        }
      }
      if ( HTPlain_bs_pending > 1 )
        HText_appendCharacter(me->text, 95);
      HTPlain_bs_pending = 0;
    }
    else if ( *p == 95 && !HTPlain_bs_pending )
    {
      HTPlain_bs_pending = 2;
      HTPlain_lastraw = *(unsigned __int8 *)p;
      continue;
    }
    if ( HTPlain_lastraw == 13 && *p == 10 )
    {
      HTPlain_lastraw = -1;
      continue;
    }
    if ( !HTPlain_bs_pending
      || *p > 0x1Fu
      && *p != 13
      && *p != 10
      && (*(unsigned __int8 *)p == HTPlain_lastraw || HTPlain_lastraw == 95 || *p == 95) )
    {
      switch ( HTPlain_bs_pending )
      {
        case 1:
          HTPlain_bs_pending = 0;
          continue;
        case 3:
          if ( *p == 95 )
          {
            HTPlain_bs_pending = 2;
            continue;
          }
          HTPlain_bs_pending = 0;
          break;
        case 2:
          HText_appendCharacter(me->text, 95);
          if ( *p == 95 )
            continue;
          HTPlain_bs_pending = 0;
          break;
        default:
          HTPlain_bs_pending = 0;
          break;
      }
    }
    else
    {
      if ( HTPlain_bs_pending > 1 )
        HText_appendCharacter(me->text, 95);
      HTPlain_bs_pending = 0;
    }
    HTPlain_lastraw = *(unsigned __int8 *)p;
    if ( *p == 13 )
    {
      HText_appendCharacter(me->text, 10);
      continue;
    }
    c = *p;
    c_unsign = *(unsigned __int8 *)p;
    code = c_unsign;
    saved_char_in = 0;
    if ( me->T.decode_utf8 )
    {
      if ( c_unsign <= 0x7F )
      {
        if ( me->utf_count > 0 )
        {
          me->utf_count = 0;
          me->utf_buf[0] = 0;
          me->utf_buf_p = me->utf_buf;
        }
        code = c_unsign;
      }
      else
      {
        if ( me->utf_count <= 0 || (c & 0xC0) != 128 )
        {
          *me->utf_buf_p = c;
          me->utf_buf_p = &me->utf_buf[1];
          if ( (*p & 0xE0) == 192 )
          {
            me->utf_count = 1;
            me->utf_char = c & 0x1F;
          }
          else if ( (*p & 0xF0) == 224 )
          {
            me->utf_count = 2;
            me->utf_char = c & 0xF;
          }
          else if ( (*p & 0xF8) == 240 )
          {
            me->utf_count = 3;
            me->utf_char = c & 7;
          }
          else if ( (*p & 0xFC) == 248 )
          {
            me->utf_count = 4;
            me->utf_char = c & 3;
          }
          else if ( (*p & 0xFE) == 252 )
          {
            me->utf_count = 5;
            me->utf_char = c & 1;
          }
          else
          {
            me->utf_count = 0;
            *me->utf_buf_p = 0;
            me->utf_buf_p = me->utf_buf;
          }
          continue;
        }
        me->utf_char = c & 0x3F | (me->utf_char << 6);
        --me->utf_count;
        *me->utf_buf_p++ = c;
        if ( me->utf_count )
          continue;
        *me->utf_buf_p = 0;
        code = me->utf_char;
        if ( code > 0 && code <= 255 )
        {
          c = me->utf_char;
          c_unsign = (unsigned __int8)code;
        }
      }
    }
    if ( !me->T.decode_utf8 || *p >= 0 )
    {
      if ( me->T.trans_to_uni
        && (LYlowest_eightbit[me->inUCLYhndl] <= code || code <= 31 && code && me->T.trans_C0_to_uni) )
      {
        code = UCTransToUni(c, me->inUCLYhndl);
        if ( code > 0 )
        {
          saved_char_in = c;
          if ( code <= 255 )
          {
            c = code;
            c_unsign = (unsigned __int8)code;
          }
        }
      }
      else if ( code <= 31 && code && me->T.trans_C0_to_uni )
      {
        if ( me->T.trans_from_uni
          && ((code = UCTransToUni(c, me->inUCLYhndl), code > 31)
           || me->T.transp && (code = UCTransToUni(c, me->inUCLYhndl), code > 0)) )
        {
          saved_char_in = c;
          if ( code <= 255 )
          {
            c = code;
            c_unsign = (unsigned __int8)code;
          }
        }
        else
        {
          uck = -1;
          if ( me->T.transp )
            uck = UCTransCharStr(replace_buf_0, 60, c, me->inUCLYhndl, me->inUCLYhndl, 0);
          if ( !me->T.transp || uck < 0 )
            uck = UCTransCharStr(replace_buf_0, 60, c, me->inUCLYhndl, me->outUCLYhndl, 1);
          if ( !uck )
            continue;
          if ( uck >= 0 )
          {
            c = replace_buf_0[0];
            if ( replace_buf_0[0] && replace_buf_0[1] )
              goto LABEL_159;
          }
          else
          {
            me->utf_buf[0] = 0;
          }
          me->utf_buf[0] = 0;
          code = (unsigned __int8)c;
        }
      }
      else
      {
        me->utf_buf[0] = 0;
        code = (unsigned __int8)c;
      }
    }
    if ( HTCJK
      || code > 126
      && code <= 160
      && (me->T.transp || LYlowest_eightbit[me->inUCLYhndl] <= code)
      && me->T.pass_160_173_raw
      || code == 173 && me->T.pass_160_173_raw )
    {
      goto LABEL_169;
    }
    if ( code == 160 )
      goto LABEL_106;
    if ( code != 173 )
    {
      if ( code > 31 && code <= 126
        || (HTPassEightBitRaw || me->T.do_8bitraw && !me->T.trans_from_uni) && c >= LYlowest_eightbit[me->outUCLYhndl]
        || *p == 10
        || *p == 9 )
      {
        goto LABEL_169;
      }
      if ( code == 8194 || code == 8195 || code == 8201 )
      {
LABEL_106:
        HText_appendCharacter(me->text, 32);
        continue;
      }
      if ( me->T.use_raw_char_in && saved_char_in )
      {
        HText_appendCharacter(me->text, saved_char_in);
        continue;
      }
      v11 = me->T.trans_from_uni && code > 159;
      if ( v11 )
      {
        uck = UCTransUniChar(code, me->outUCLYhndl);
        if ( uck > 31 && uck <= 255 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v3 = TraceFP();
            fprintf(v3, "UCTransUniChar returned 0x%.2lX:'%c'.\n", uck, (char)uck);
          }
LABEL_155:
          HText_appendCharacter(me->text, (char)uck);
          continue;
        }
      }
      if ( v11 && (uck == -4 || me->T.repl_translated_C0 && uck > 0 && uck <= 31) )
      {
        v4 = UCTransUniCharStr(replace_buf_0, 60, code, me->outUCLYhndl, 0);
        uck = v4 >= 0;
        if ( v4 >= 0 )
          goto LABEL_159;
      }
      if ( v11 && code > 127 && me->T.output_utf8 )
      {
        if ( me->utf_buf[0] )
        {
          HText_appendText(me->text, me->utf_buf);
          me->utf_buf[0] = 0;
          me->utf_buf_p = me->utf_buf;
          continue;
        }
        if ( !UCConvertUniToUtf8(code, replace_buf_0) )
          sprintf(replace_buf_0, "U%.2lX", code);
LABEL_159:
        HText_appendText(me->text, replace_buf_0);
        continue;
      }
      if ( (!c_unsign || (int)c_unsign >= LYlowest_eightbit[me->outUCLYhndl])
        && (!me->T.trans_from_uni || HTPassEightBitRaw) )
      {
        if ( !c_unsign )
          continue;
LABEL_169:
        HText_appendCharacter(me->text, c);
        continue;
      }
      outUCLYhndl = me->outUCLYhndl;
      v6 = UCGetLYhndl_byMIME("us-ascii");
      chk = outUCLYhndl != v6;
      if ( outUCLYhndl != v6 )
      {
        v9 = UCGetLYhndl_byMIME("us-ascii");
        uck = UCTransUniChar(code, v9);
        if ( uck > 31 && uck <= 126 )
          goto LABEL_155;
      }
      if ( chk && uck == -4 )
      {
        v10 = UCGetLYhndl_byMIME("us-ascii");
        v7 = UCTransUniCharStr(replace_buf_0, 60, code, v10, 0);
        uck = v7 >= 0;
        if ( v7 >= 0 )
          goto LABEL_159;
      }
      if ( code == 8204 || code == 8205 )
      {
        if ( !WWW_TraceFlag[0] )
          continue;
LABEL_163:
        v8 = TraceFP();
        fprintf(v8, "HTPlain_write: Ignoring '%ld'.\n", code);
        continue;
      }
      if ( (code == 8206 || code == 8207) && WWW_TraceFlag[0] )
        goto LABEL_163;
    }
  }
}
// 81237F4: conditional instruction was optimized away because %c_unsign.4 is in (1..FF)

//----- (08123822) --------------------------------------------------------
void __cdecl HTPlain_free(HTStream_3 *me)
{
  if ( HTPlain_bs_pending > 1 )
    HText_appendCharacter(me->text, 95);
  if ( me )
    free(me);
}

//----- (08123862) --------------------------------------------------------
void __cdecl HTPlain_abort(HTStream_3 *me, HTError e)
{
  HTPlain_free(me);
}

//----- (08123875) --------------------------------------------------------
HTStream_3 *__cdecl HTPlainPresent(HTPresentation *pres, HTParentAnchor *anchor, HTStream_3 *sink)
{
  LYUCcharset *UCInfoStage; // eax
  HTStyle *v4; // eax
  HTStream_3 *me; // [esp+2Ch] [ebp-Ch]

  me = (HTStream_3 *)malloc(0x38u);
  if ( !me )
    outofmem("../../../WWW/Library/Implementation/HTPlain.c", "HTPlain_new");
  me->isa = &HTPlain;
  HTPlain_lastraw = -1;
  me->utf_count = 0;
  me->utf_char = 0;
  me->utf_buf[7] = 0;
  me->utf_buf[6] = me->utf_buf[7];
  me->utf_buf[0] = me->utf_buf[6];
  me->utf_buf_p = me->utf_buf;
  me->outUCLYhndl = HTAnchor_getUCLYhndl(anchor, 3);
  me->inUCLYhndl = HTAnchor_getUCLYhndl(anchor, 1);
  HTPlain_getChartransInfo(me, anchor);
  UCInfoStage = HTAnchor_getUCInfoStage(anchor, 3);
  UCSetTransParams(&me->T, me->inUCLYhndl, me->inUCI, me->outUCLYhndl, UCInfoStage);
  me->text = HText_new(anchor);
  v4 = LYstyles(117);
  HText_setStyle(me->text, v4);
  HText_beginAppend(me->text);
  return me;
}

//----- (081239D0) --------------------------------------------------------
void __cdecl flush_breaks(HTStructured_2 *me)
{
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; i <= 20; ++i )
    me->line_break[i] = 0;
}

//----- (081239FC) --------------------------------------------------------
void __cdecl HTMLGen_flush(HTStructured_2 *me)
{
  me->targetClass.put_block((HTStream *)me->target, me->buffer, me->write_pointer - me->buffer);
  me->write_pointer = me->buffer;
  flush_breaks(me);
  me->cleanness = 0;
  me->delete_line_break_char[0] = 0;
}

//----- (08123A6C) --------------------------------------------------------
void __cdecl do_cstyle_flush(HTStructured_2 *me)
{
  if ( !me->text && LYPreparsedSource )
    me->text = HTMainText;
  if ( me->text )
    HTMLGen_flush(me);
}

//----- (08123AB3) --------------------------------------------------------
void __cdecl allow_break(HTStructured_2 *me, int new_cleanness, BOOLEAN dlbc)
{
  char *write_pointer; // [esp+4h] [ebp-8h]
  BOOLEAN dlbca; // [esp+8h] [ebp-4h]

  dlbca = dlbc;
  if ( dlbc && me->write_pointer == me->buffer )
    dlbca = 0;
  if ( dlbca )
    write_pointer = me->write_pointer - 1;
  else
    write_pointer = me->write_pointer;
  me->line_break[new_cleanness] = write_pointer;
  me->delete_line_break_char[new_cleanness] = dlbca;
  if ( me->cleanness <= new_cleanness && (me->overflowed || me->line_break[new_cleanness] > me->buffer) )
    me->cleanness = new_cleanness;
}

//----- (08123B67) --------------------------------------------------------
void __cdecl HTMLGen_put_character(HTStructured_2 *me, char c)
{
  char *write_pointer; // edx
  char ca; // [esp+1Ch] [ebp-3Ch]
  char delims[5]; // [esp+2Fh] [ebp-29h] BYREF
  int i; // [esp+34h] [ebp-24h]
  char *q; // [esp+38h] [ebp-20h]
  char *p_0; // [esp+3Ch] [ebp-1Ch]
  char *saved; // [esp+40h] [ebp-18h]
  char *p; // [esp+44h] [ebp-14h]
  int new_cleanness; // [esp+48h] [ebp-10h]
  char line_break_char; // [esp+4Fh] [ebp-9h]

  ca = c;
  if ( me->escape_specials && (unsigned __int8)c <= 0x1Fu && (c == 1 || c == 2 || c == 7) )
  {
    HTMLGen_put_character(me, 38);
    HTMLGen_put_character(me, 35);
    HTMLGen_put_character(me, 120);
    switch ( c )
    {
      case 2:
        HTMLGen_put_character(me, 50);
        HTMLGen_put_character(me, 48);
        HTMLGen_put_character(me, 48);
        HTMLGen_put_character(me, 50);
        break;
      case 7:
        HTMLGen_put_character(me, 65);
        HTMLGen_put_character(me, 68);
        break;
      case 1:
        HTMLGen_put_character(me, 65);
        HTMLGen_put_character(me, 48);
        break;
    }
    ca = 59;
  }
  write_pointer = me->write_pointer;
  *write_pointer = ca;
  me->write_pointer = write_pointer + 1;
  if ( ca == 10 )
  {
    HTMLGen_flush(me);
  }
  else
  {
    if ( !me->preformatted && (ca == 32 || ca == 9) )
    {
      new_cleanness = 3;
      if ( me->write_pointer > &me->buffer[1] )
      {
        memcpy(delims, ",;:.", sizeof(delims));
        p = strchr(delims, *(me->write_pointer - 2));
        if ( p )
          new_cleanness = p - delims + 6;
        if ( !me->in_attrval )
          new_cleanness += 10;
      }
      allow_break(me, new_cleanness, 1);
    }
    if ( me->write_pointer >= &me->buffer[me->buffer_maxchars] || me->overflowed && me->cleanness )
    {
      if ( me->cleanness )
      {
        line_break_char = *me->line_break[me->cleanness];
        saved = me->line_break[me->cleanness];
        if ( me->delete_line_break_char[me->cleanness] )
          ++saved;
        *me->line_break[me->cleanness] = 10;
        me->targetClass.put_block((HTStream *)me->target, me->buffer, me->line_break[me->cleanness] - me->buffer + 1);
        *me->line_break[me->cleanness] = line_break_char;
        p_0 = saved;
        q = me->buffer;
        while ( me->write_pointer > p_0 )
          *q++ = *p_0++;
        me->cleanness = 0;
        for ( i = 0; i <= 20; ++i )
        {
          if ( me->line_break[i] && me->line_break[i] > saved )
          {
            me->line_break[i] += me->buffer - saved;
            me->cleanness = i;
          }
          else
          {
            me->line_break[i] = 0;
          }
        }
        me->delete_line_break_char[0] = 0;
        me->write_pointer += me->buffer - saved;
        me->overflowed = 0;
      }
      else
      {
        me->targetClass.put_block((HTStream *)me->target, me->buffer, me->buffer_maxchars);
        me->write_pointer = me->buffer;
        flush_breaks(me);
        me->overflowed = 1;
      }
    }
  }
}

//----- (08123FF3) --------------------------------------------------------
void __cdecl HTMLGen_put_string(HTStructured_2 *me, const char *s)
{
  while ( *s )
    HTMLGen_put_character(me, *s++);
}

//----- (08124029) --------------------------------------------------------
void __cdecl HTMLGen_write(HTStructured_2 *me, const char *s, int l)
{
  char *p; // [esp+14h] [ebp-4h]

  for ( p = (char *)s; &s[l] > p; ++p )
    HTMLGen_put_character(me, *p);
}

//----- (08124060) --------------------------------------------------------
int __cdecl HTMLGen_start_element(
        HTStructured_2 *me,
        int element_number,
        const BOOLEAN *present,
        const char **value,
        int charset,
        char **insert)
{
  int v6; // ebx
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // edx
  FILE *v10; // eax
  int v11; // ebx
  FILE *v12; // eax
  int color; // ebx
  FILE *v14; // eax
  const char *name; // ebx
  FILE *v16; // eax
  char *v17; // ebx
  FILE *v18; // eax
  int v19; // eax
  int v20; // eax
  FILE *v21; // eax
  BOOLEAN v23; // [esp+1Fh] [ebp-39h]
  char *p; // [esp+30h] [ebp-28h]
  int hcd; // [esp+34h] [ebp-24h]
  char *rp; // [esp+38h] [ebp-20h]
  int len; // [esp+3Ch] [ebp-1Ch]
  char *title_tmp; // [esp+40h] [ebp-18h] BYREF
  char *title; // [esp+44h] [ebp-14h] BYREF
  HTTag *tag; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]
  BOOLEAN had_attr; // [esp+52h] [ebp-6h]
  BOOLEAN was_preformatted; // [esp+53h] [ebp-5h]

  was_preformatted = me->preformatted;
  tag = &HTML_dtd.tags[element_number];
  title = 0;
  title_tmp = 0;
  if ( LYPreparsedSource )
  {
    HTSprintf(&Style_className_0, ";%s", HTML_dtd.tags[element_number].name);
    strcpy(myHash, HTML_dtd.tags[element_number].name);
    if ( class_string[0] )
    {
      len = strlen(myHash);
      sprintf((char *)(len + 136011136), ".%.*s", 126 - len, class_string);
      HTSprintf(&Style_className_0, ".%s", class_string);
    }
    class_string[0] = 0;
    strtolower(myHash);
    hcode_0 = hash_code(myHash);
    strtolower(Style_className_0);
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v6 = hcode_0;
      v7 = TraceFP();
      fprintf(v7, "CSSTRIM:%s -> %d", myHash, v6);
      if ( hashStyles[hcode_0].code == hcode_0 )
      {
        color = hashStyles[hcode_0].color;
        v14 = TraceFP();
        fprintf(v14, " ca=%d\n", color);
      }
      else
      {
        rp = strrchr(myHash, 46);
        v8 = TraceFP();
        fprintf(v8, " (undefined) %s\n", myHash);
        if ( rp )
        {
          *rp = 0;
          hcd = hash_code(myHash);
          v9 = TraceFP();
          fprintf(v9, "CSS:%s -> %d", myHash, hcd);
          if ( hashStyles[hcd].code == hcd )
          {
            v11 = hashStyles[hcd].color;
            v12 = TraceFP();
            fprintf(v12, " ca=%d\n", v11);
          }
          else
          {
            v10 = TraceFP();
            fprintf(v10, " (undefined) %s\n", myHash);
          }
        }
      }
    }
    if ( displayStyles[element_number + 8].color > -2 )
    {
      if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
      {
        name = HTML_dtd.tags[element_number].name;
        v16 = TraceFP();
        fprintf(v16, "CSSTRIM: start_element: top <%s>\n", name);
      }
      do_cstyle_flush(me);
      internal_HTC(me->text, hcode_0, 1);
    }
  }
  me->preformatted = 1;
  HTMLGen_put_character(me, 60);
  HTMLGen_put_string(me, tag->name);
  if ( present )
  {
    had_attr = 0;
    for ( i = 0; tag->number_of_attributes > i; ++i )
    {
      if ( present[i] )
      {
        had_attr = 1;
        HTMLGen_put_character(me, 32);
        allow_break(me, 11, 1);
        if ( LYPreparsedSource
          && element_number == 69
          && !title
          && present[1]
          && value
          && *value[1]
          && !present[9]
          && (present[8] || present[3]) )
        {
          if ( present[12] && *value[12] )
          {
            HTSACopy(&title, value[12]);
            LYTrimHead(title);
            LYTrimTail(title);
          }
          if ( (!title || !*title) && present[8] )
            HTSACopy(&title, value[8]);
          if ( title && *title )
          {
            HTSprintf0(&title_tmp, "link.%s.%s", value[1], title);
            if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
            {
              v17 = title_tmp;
              v18 = TraceFP();
              fprintf(v18, "CSSTRIM:link=%s\n", v17);
            }
            do_cstyle_flush(me);
            v19 = hash_code(title_tmp);
            internal_HTC(me->text, v19, 1);
          }
        }
        HTMLGen_put_string(me, tag->attributes[i].name);
        if ( value[i] )
        {
          me->preformatted = was_preformatted;
          me->in_attrval = 1;
          if ( strchr(value[i], 34) )
          {
            if ( strchr(value[i], 39) )
            {
              HTMLGen_put_string(me, "=\"");
              for ( p = (char *)value[i]; *p; ++p )
              {
                if ( *p == 34 )
                  HTMLGen_put_string(me, "&#34;");
                else
                  HTMLGen_put_character(me, *p);
              }
              HTMLGen_put_character(me, 34);
            }
            else
            {
              HTMLGen_put_string(me, "='");
              HTMLGen_put_string(me, value[i]);
              HTMLGen_put_character(me, 39);
            }
          }
          else
          {
            HTMLGen_put_string(me, "=\"");
            HTMLGen_put_string(me, value[i]);
            HTMLGen_put_character(me, 34);
          }
          me->preformatted = 1;
          me->in_attrval = 0;
        }
      }
    }
    if ( had_attr && LYPreparsedSource && element_number == 69 )
    {
      if ( title )
      {
        if ( *title )
        {
          do_cstyle_flush(me);
          v20 = hash_code(title_tmp);
          internal_HTC(me->text, v20, 0);
          if ( title_tmp )
          {
            free(title_tmp);
            title_tmp = 0;
          }
        }
      }
      if ( title )
      {
        free(title);
        title = 0;
      }
    }
    if ( had_attr )
      allow_break(me, 12, 0);
  }
  HTMLGen_put_string(me, ">");
  if ( element_number == 86 )
    v23 = 1;
  else
    v23 = was_preformatted;
  me->preformatted = v23;
  if ( !me->preformatted && tag->contents )
  {
    if ( HTML_dtd.tags[element_number].contents == SGML_ELEMENT )
      allow_break(me, 15, 0);
    else
      allow_break(me, 2, 0);
  }
  if ( LYPreparsedSource
    && HTML_dtd.tags[element_number].contents == SGML_EMPTY
    && (HTML_dtd.tags[element_number].flags & 0x10) == 0 )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v21 = TraceFP();
      fprintf(v21, "STYLE:begin_element:ending EMPTY element style\n");
    }
    do_cstyle_flush(me);
    internal_HTC(me->text, hcode_0, 0);
    TrimColorClass(HTML_dtd.tags[element_number].name, Style_className_0, &hcode_0);
  }
  if ( element_number != 79 || tag->contents != SGML_LITTERAL )
    return 0;
  if ( present )
  {
    if ( !present[8]
      && (!present[15] || !value[15] || !*value[15])
      && (present[17] || !present[23] || !value[23] || !*value[23]) )
    {
      return 701;
    }
    return 0;
  }
  return 701;
}

//----- (08124A94) --------------------------------------------------------
int __cdecl HTMLGen_end_element(HTStructured_2 *me, int element_number, char **insert)
{
  FILE *v3; // eax

  if ( !me->preformatted && HTML_dtd.tags[element_number].contents )
  {
    if ( HTML_dtd.tags[element_number].contents == SGML_ELEMENT )
      allow_break(me, 14, 0);
    else
      allow_break(me, 1, 0);
  }
  HTMLGen_put_string(me, "</");
  HTMLGen_put_string(me, HTML_dtd.tags[element_number].name);
  HTMLGen_put_character(me, 62);
  if ( element_number == 86 )
    me->preformatted = 0;
  TrimColorClass(HTML_dtd.tags[element_number].name, Style_className_0, &hcode_0);
  if ( LYPreparsedSource
    && (HTML_dtd.tags[element_number].contents || (HTML_dtd.tags[element_number].flags & 0x10) != 0) )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 2) != 0 )
    {
      v3 = TraceFP();
      fprintf(v3, "STYLE:end_element: ending non-EMPTY style\n");
    }
    do_cstyle_flush(me);
    internal_HTC(me->text, hcode_0, 0);
  }
  return 0;
}

//----- (08124C82) --------------------------------------------------------
int __cdecl HTMLGen_put_entity(HTStructured_2 *me, int entity_number)
{
  HTMLGen_put_character(me, 38);
  if ( entity_number < (int)HTML_dtd.number_of_entities )
    HTMLGen_put_string(me, HTML_dtd.entity_names[entity_number]);
  HTMLGen_put_character(me, 59);
  return 0;
}

//----- (08124CE5) --------------------------------------------------------
void __cdecl HTMLGen_free(HTStructured_2 *me)
{
  me->targetClass.put_character((HTStream *)me->target, 10);
  HTMLGen_flush(me);
  me->targetClass._free((HTStream *)me->target);
  if ( Style_className_0 )
  {
    free(Style_className_0);
    Style_className_0 = 0;
  }
  if ( me )
    free(me);
}

//----- (08124D5A) --------------------------------------------------------
void __cdecl PlainToHTML_free(HTStructured_2 *me)
{
  HTMLGen_end_element(me, 86, 0);
  HTMLGen_free(me);
}

//----- (08124D88) --------------------------------------------------------
void __cdecl HTMLGen_abort(HTStructured_2 *me, HTError e)
{
  HTMLGen_free(me);
  if ( Style_className_0 )
  {
    free(Style_className_0);
    Style_className_0 = 0;
  }
}

//----- (08124DBB) --------------------------------------------------------
void __cdecl PlainToHTML_abort(HTStructured_2 *me, HTError e)
{
  PlainToHTML_free(me);
}

//----- (08124DCE) --------------------------------------------------------
HTStructured_2 *__cdecl HTMLGenerator(HTStream_4 *output)
{
  const HTStreamClass *isa; // edx
  HTStructured_2 *me; // [esp+14h] [ebp-4h]

  me = (HTStructured_2 *)malloc(0x16Cu);
  if ( !me )
    outofmem("../../../WWW/Library/Implementation/HTMLGen.c", "HTMLGenerator");
  me->isa = &HTMLGeneration;
  me->target = output;
  isa = me->target->isa;
  me->targetClass.name = isa->name;
  me->targetClass._free = isa->_free;
  me->targetClass._abort = isa->_abort;
  me->targetClass.put_character = isa->put_character;
  me->targetClass.put_string = isa->put_string;
  me->targetClass.put_block = isa->put_block;
  me->write_pointer = me->buffer;
  flush_breaks(me);
  me->line_break[0] = me->buffer;
  me->cleanness = 0;
  me->overflowed = 0;
  me->delete_line_break_char[0] = 0;
  me->preformatted = 0;
  me->in_attrval = 0;
  if ( LYPreparsedSource )
  {
    if ( dump_output_width <= 1 )
    {
      if ( dump_output_immediately )
      {
        me->buffer_maxchars = 80;
      }
      else
      {
        me->buffer_maxchars = LYcols - (LYShowScrollbar != 0) - 1;
        if ( me->buffer_maxchars <= 37 )
          me->buffer_maxchars = 40;
      }
    }
    else
    {
      me->buffer_maxchars = dump_output_width;
    }
  }
  else
  {
    me->buffer_maxchars = 80;
  }
  if ( me->buffer_maxchars > 900 )
    me->buffer_maxchars = 78;
  if ( me->buffer_maxchars > 200 )
    me->buffer_maxchars = 198;
  me->escape_specials = LYPreparsedSource;
  me->text = 0;
  if ( Style_className_0 )
  {
    free(Style_className_0);
    Style_className_0 = 0;
  }
  class_string[0] = 0;
  return me;
}

//----- (08124FAF) --------------------------------------------------------
HTStream_4 *__cdecl HTPlainToHTML(HTPresentation *pres, HTParentAnchor *anchor, HTStream_4 *sink)
{
  const HTStreamClass *isa; // edx
  int v5; // [esp+14h] [ebp-14h]
  HTStructured_2 *me; // [esp+24h] [ebp-4h]

  me = (HTStructured_2 *)malloc(0x16Cu);
  if ( !me )
    outofmem("../../../WWW/Library/Implementation/HTMLGen.c", "PlainToHTML");
  me->isa = &PlainToHTMLConversion;
  me->target = sink;
  isa = me->target->isa;
  me->targetClass.name = isa->name;
  me->targetClass._free = isa->_free;
  me->targetClass._abort = isa->_abort;
  me->targetClass.put_character = isa->put_character;
  me->targetClass.put_string = isa->put_string;
  me->targetClass.put_block = isa->put_block;
  me->write_pointer = me->buffer;
  flush_breaks(me);
  me->cleanness = 0;
  me->overflowed = 0;
  me->delete_line_break_char[0] = 0;
  if ( dump_output_width <= 1 )
    v5 = 80;
  else
    v5 = dump_output_width;
  me->buffer_maxchars = v5;
  HTMLGen_put_string(me, "<HTML>\n<BODY>\n<PRE>\n");
  me->preformatted = 1;
  me->escape_specials = 0;
  me->in_attrval = 0;
  return (HTStream_4 *)me;
}

//----- (081250B8) --------------------------------------------------------
HTAtom *__cdecl HTAtom_for(const char *string)
{
  size_t v1; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  HTAtom *a; // [esp+20h] [ebp-8h]
  HTAtom *aa; // [esp+20h] [ebp-8h]
  int hash; // [esp+24h] [ebp-4h]

  if ( !initialised[0] )
  {
    for ( i = 0; i <= 100; ++i )
      hash_table[i] = 0;
    initialised[0] = 1;
  }
  hash = *(unsigned __int8 *)string * strlen(string) % 0x65;
  for ( a = hash_table[hash]; a; a = a->next )
  {
    if ( !strcasecomp(a->name, string) )
      return a;
  }
  aa = (HTAtom *)malloc(8u);
  if ( !aa )
    outofmem("../../../WWW/Library/Implementation/HTAtom.c", "HTAtom_for");
  v1 = strlen(string);
  aa->name = (char *)malloc(v1 + 1);
  if ( !aa->name )
    outofmem("../../../WWW/Library/Implementation/HTAtom.c", "HTAtom_for");
  strcpy(aa->name, string);
  aa->next = hash_table[hash];
  hash_table[hash] = aa;
  return aa;
}

//----- (08125224) --------------------------------------------------------
BOOLEAN __cdecl mime_match(const char *name, const char *templ)
{
  char *t2; // [esp+20h] [ebp-8h]
  char *t2a; // [esp+20h] [ebp-8h]
  char *n2; // [esp+24h] [ebp-4h]
  char *n2a; // [esp+24h] [ebp-4h]

  if ( !name || !templ )
    return 0;
  HTSACopy(&n1_4973, name);
  HTSACopy(&t1_4974, templ);
  n2 = strchr(n1_4973, 47);
  if ( n2 )
  {
    t2 = strchr(t1_4974, 47);
    if ( t2 )
    {
      *n2 = 0;
      n2a = n2 + 1;
      *t2 = 0;
      t2a = t2 + 1;
      return (!strcmp(t1_4974, "*") || !strcmp(t1_4974, n1_4973)) && (!strcmp(t2a, "*") || !strcmp(t2a, n2a));
    }
  }
  return 0;
}

//----- (0812532B) --------------------------------------------------------
HTList *__cdecl HTAtom_templateMatches(const char *templ)
{
  HTAtom *cur; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  HTList *matches; // [esp+14h] [ebp-4h]

  matches = HTList_new();
  if ( initialised[0] && templ )
  {
    for ( i = 0; i <= 100; ++i )
    {
      for ( cur = hash_table[i]; cur; cur = cur->next )
      {
        if ( mime_match(cur->name, templ) )
          HTList_addObject(matches, cur);
      }
    }
  }
  return matches;
}

//----- (081253AC) --------------------------------------------------------
unsigned __int16 __cdecl HASH_FUNCTION(const char *cp_address)
{
  unsigned __int16 hash; // [esp+16h] [ebp-6h]

  hash = 0;
  while ( *cp_address )
    hash = (3 * hash + *(unsigned __int8 *)cp_address++) % 1001;
  return hash;
}

//----- (08125421) --------------------------------------------------------
HTParentAnchor0 *__cdecl HTParentAnchor0_new(const char *address, unsigned __int16 hash)
{
  HTParentAnchor0 *newAnchor; // [esp+24h] [ebp-4h]

  newAnchor = (HTParentAnchor0 *)calloc(1u, 0x24u);
  if ( !newAnchor )
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c", "HTParentAnchor0_new");
  newAnchor->parent = newAnchor;
  HTSACopy(&newAnchor->address, address);
  newAnchor->adult_hash = hash;
  return newAnchor;
}

//----- (0812548C) --------------------------------------------------------
HTParentAnchor *__cdecl HTParentAnchor_new(HTParentAnchor0 *parent)
{
  HTParentAnchor *newAnchor; // [esp+14h] [ebp-4h]

  newAnchor = (HTParentAnchor *)calloc(1u, 0xB8u);
  if ( !newAnchor )
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c", "HTParentAnchor_new");
  newAnchor->parent = parent;
  parent->info = newAnchor;
  newAnchor->address = parent->address;
  newAnchor->isISMAPScript = 0;
  newAnchor->isHEAD = 0;
  newAnchor->safe = 0;
  newAnchor->no_cache = 0;
  newAnchor->inBASE = 0;
  newAnchor->content_length = 0;
  return newAnchor;
}

//----- (08125515) --------------------------------------------------------
HTChildAnchor *__cdecl HTChildAnchor_new(HTParentAnchor0 *parent)
{
  HTChildAnchor *p; // [esp+14h] [ebp-4h]

  p = (HTChildAnchor *)calloc(1u, 0x20u);
  if ( !p )
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c", "HTChildAnchor_new");
  p->parent = parent;
  return p;
}

//----- (08125559) --------------------------------------------------------
HTChildAnchor *__cdecl HText_pool_ChildAnchor_new(HTParentAnchor *parent)
{
  HTChildAnchor *p; // [esp+14h] [ebp-4h]

  p = (HTChildAnchor *)HText_pool_calloc((HText *)parent->document, 0x20u);
  if ( !p )
    outofmem("../../../WWW/Library/Implementation/HTAnchor.c", "HText_pool_ChildAnchor_new");
  p->parent = parent->parent;
  return p;
}

//----- (081255A1) --------------------------------------------------------
BOOLEAN __cdecl HTSEquivalent(const char *s, const char *t)
{
  if ( !s || !t )
    return s == t;
  while ( *s && *t )
  {
    if ( *s != *t )
      return 0;
    ++s;
    ++t;
  }
  return *s == *t;
}

//----- (0812560B) --------------------------------------------------------
BOOLEAN __cdecl HTBEquivalent(const bstring *s, const bstring *t)
{
  int j; // [esp+28h] [ebp-4h]

  if ( !s || !t || s->len != t->len )
    return s == t;
  for ( j = 0; j < s->len; ++j )
  {
    if ( s->str[j] != t->str[j] )
      return 0;
  }
  return 1;
}
// 8125629: conditional instruction was optimized away because %s.4!=0
// 8125641: conditional instruction was optimized away because %t.4!=0
// 8125665: conditional instruction was optimized away because %s.4!=0
// 812568C: conditional instruction was optimized away because %s.4!=0
// 81256AF: conditional instruction was optimized away because %t.4!=0

//----- (081256F8) --------------------------------------------------------
int __cdecl compare_anchors(void *l, void *r)
{
  return strcmp(*((const char **)l + 1), *((const char **)r + 1));
}

//----- (08125724) --------------------------------------------------------
HTChildAnchor *__cdecl HTAnchor_findNamedChild(HTParentAnchor0 *parent, const char *tag)
{
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  HTParentAnchor0 *v7; // [esp+20h] [ebp-38h]
  HTChildAnchor sample; // [esp+34h] [ebp-24h] BYREF
  HTChildAnchor *child; // [esp+54h] [ebp-4h]

  if ( parent && tag && *tag )
  {
    if ( parent->children )
    {
      sample.tag = (char *)tag;
      child = (HTChildAnchor *)HTBTree_search(parent->children, &sample);
      if ( child )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "Child anchor %p of parent %p with name `%s' already exists.\n", child, parent, tag);
        }
        return child;
      }
    }
    else
    {
      parent->children = HTBTree_new(compare_anchors);
    }
    child = HTChildAnchor_new(parent);
    if ( WWW_TraceFlag[0] )
    {
      v7 = child->parent;
      v3 = TraceFP();
      fprintf(v3, "HTAnchor: New Anchor %p named `%s' is child of %p\n", child, tag, v7);
    }
    HTSACopy(&child->tag, tag);
    HTBTree_add(parent->children, child);
    return child;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "HTAnchor_findNamedChild called with NULL parent.\n");
    }
    return 0;
  }
}
// 81257F7: conditional instruction was optimized away because %tag.4!=0

//----- (08125894) --------------------------------------------------------
HTChildAnchor *__cdecl HTAnchor_addChild(HTParentAnchor *parent)
{
  FILE *v1; // eax
  HTParentAnchor0 *v2; // ebx
  FILE *v3; // edx
  HTChildAnchor *child; // [esp+20h] [ebp-8h]

  if ( parent )
  {
    child = HText_pool_ChildAnchor_new(parent);
    if ( WWW_TraceFlag[0] )
    {
      v2 = child->parent;
      v3 = TraceFP();
      fprintf(v3, "HTAnchor: New unnamed Anchor %p is child of %p\n", child, v2);
    }
    child->tag = 0;
    HTList_linkObject(&parent->children_notag, child, &child->_add_children_notag);
    return child;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTAnchor_addChild called with NULL parent.\n");
    }
    return 0;
  }
}

//----- (08125946) --------------------------------------------------------
HTChildAnchor *__cdecl HTAnchor_findChildAndLink(
        HTParentAnchor *parent,
        const char *tag,
        const char *href,
        HTLinkType *ltype)
{
  FILE *v4; // eax
  FILE *v5; // eax
  HTAnchor *v6; // ebx
  FILE *v7; // eax
  const char *v9; // [esp+20h] [ebp-48h]
  const char *v10; // [esp+24h] [ebp-44h]
  const char *v11; // [esp+28h] [ebp-40h]
  char *address; // [esp+2Ch] [ebp-3Ch]
  const char *v13; // [esp+30h] [ebp-38h]
  DocAddress parsed_doc; // [esp+40h] [ebp-28h] BYREF
  const char *relative_to; // [esp+54h] [ebp-14h]
  HTParentAnchor0 *dest; // [esp+58h] [ebp-10h]
  const char *fragment; // [esp+5Ch] [ebp-Ch]
  HTChildAnchor *child; // [esp+60h] [ebp-8h]

  if ( WWW_TraceFlag[0] )
  {
    if ( href )
      v9 = href;
    else
      v9 = byte_818B605;
    if ( ltype == HTInternalLink )
      v10 = " (internal link)";
    else
      v10 = byte_818B605;
    if ( tag )
      v11 = tag;
    else
      v11 = byte_818B605;
    v4 = TraceFP();
    fprintf(v4, "Entered HTAnchor_findChildAndLink:  tag=`%s',%s href=`%s'\n", v11, v10, v9);
  }
  if ( tag && *tag )
    child = HTAnchor_findNamedChild(parent->parent, tag);
  else
    child = HTAnchor_addChild(parent);
  if ( href && *href )
  {
    fragment = 0;
    if ( ltype == HTInternalLink && *href == 35 )
    {
      dest = parent->parent;
    }
    else
    {
      if ( !parent->inBASE || *href == 35 )
        address = parent->address;
      else
        address = parent->content_base;
      relative_to = address;
      parsed_doc.address = HTParse(href, address, 29);
      parsed_doc.post_data = 0;
      parsed_doc.post_content_type = 0;
      if ( ltype && parent->post_data && ltype == HTInternalLink )
      {
        parsed_doc.post_data = parent->post_data;
        parsed_doc.post_content_type = parent->post_content_type;
      }
      parsed_doc.bookmark = 0;
      parsed_doc.isHEAD = 0;
      parsed_doc.safe = 0;
      dest = HTAnchor_findAddress_in_adult_table(&parsed_doc);
      if ( parsed_doc.address )
      {
        free(parsed_doc.address);
        parsed_doc.address = 0;
      }
    }
    if ( *href == 35 )
      v13 = href + 1;
    else
      v13 = HTParseAnchor(href);
    fragment = v13;
    if ( *v13 )
      dest = (HTParentAnchor0 *)HTAnchor_findNamedChild(dest, fragment);
    if ( tag && *tag && child->dest )
    {
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "*** Duplicate ChildAnchor %p named `%s'", child, tag);
      }
      if ( (HTParentAnchor0 *)child->dest != dest || child->type != ltype )
      {
        if ( WWW_TraceFlag[0] )
        {
          v6 = child->dest;
          v7 = TraceFP();
          fprintf(v7, ", different dest %p or type, creating unnamed child\n", v6);
        }
        child = HTAnchor_addChild(parent);
      }
    }
    HTAnchor_link(child, (HTAnchor *)dest, ltype);
  }
  return child;
}

//----- (08125C12) --------------------------------------------------------
HTParentAnchor *__cdecl HTAnchor_findAddress(const DocAddress *newdoc)
{
  FILE *v1; // eax
  HTParentAnchor0 *Address_in_adult_table; // eax
  DocAddress parsed_doc; // [esp+18h] [ebp-20h] BYREF
  HTChildAnchor *foundAnchor; // [esp+2Ch] [ebp-Ch]
  HTParentAnchor0 *foundParent; // [esp+30h] [ebp-8h]
  const char *tag; // [esp+34h] [ebp-4h]

  tag = HTParseAnchor(newdoc->address);
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "Entered HTAnchor_findAddress\n");
  }
  if ( *tag )
  {
    parsed_doc.address = HTParse(newdoc->address, byte_818B605, 29);
    parsed_doc.post_data = newdoc->post_data;
    parsed_doc.post_content_type = newdoc->post_content_type;
    parsed_doc.bookmark = newdoc->bookmark;
    parsed_doc.isHEAD = newdoc->isHEAD;
    parsed_doc.safe = newdoc->safe;
    foundParent = HTAnchor_findAddress_in_adult_table(&parsed_doc);
    foundAnchor = HTAnchor_findNamedChild(foundParent, tag);
    if ( parsed_doc.address )
    {
      free(parsed_doc.address);
      parsed_doc.address = 0;
    }
    return HTAnchor_parent((HTAnchor *)foundParent);
  }
  else
  {
    Address_in_adult_table = HTAnchor_findAddress_in_adult_table(newdoc);
    return HTAnchor_parent((HTAnchor *)Address_in_adult_table);
  }
}

//----- (08125D0E) --------------------------------------------------------
HTParentAnchor0 *__cdecl HTAnchor_findAddress_in_adult_table(const DocAddress *newdoc)
{
  char *v1; // ebx
  FILE *v2; // edx
  char *address; // ebx
  FILE *v4; // edx
  bool v6; // [esp+1Ch] [ebp-3Ch]
  HTParentAnchor0 *object; // [esp+24h] [ebp-34h]
  int len; // [esp+28h] [ebp-30h]
  HTParentAnchor *p; // [esp+3Ch] [ebp-1Ch]
  HTParentAnchor0 *foundAnchor; // [esp+40h] [ebp-18h]
  HTList *grownups; // [esp+44h] [ebp-14h]
  unsigned __int16 hash; // [esp+4Ch] [ebp-Ch]

  v6 = newdoc->post_data || newdoc->post_content_type || newdoc->bookmark || newdoc->isHEAD || newdoc->safe;
  hash = HASH_FUNCTION(newdoc->address);
  grownups = (HTList *)(8 * hash + 136011744);
  do
  {
    if ( grownups && (grownups = grownups->next) != 0 )
      object = (HTParentAnchor0 *)grownups->object;
    else
      object = 0;
    if ( !object )
    {
      foundAnchor = HTParentAnchor0_new(newdoc->address, hash);
      if ( WWW_TraceFlag[0] )
      {
        address = newdoc->address;
        v4 = TraceFP();
        fprintf(v4, "New anchor %p has hash %d and address `%s'\n", foundAnchor, hash, address);
      }
      if ( v6 )
      {
        p = HTParentAnchor_new(foundAnchor);
        if ( newdoc->post_data )
        {
          len = newdoc->post_data->len;
          if ( newdoc->post_data )
            HTSABCopy(&p->post_data, newdoc->post_data->str, len);
          else
            HTSABCopy(&p->post_data, 0, len);
        }
        if ( newdoc->post_content_type )
          HTSACopy(&p->post_content_type, newdoc->post_content_type);
        if ( newdoc->bookmark )
          HTSACopy(&p->bookmark, newdoc->bookmark);
        p->isHEAD = newdoc->isHEAD;
        p->safe = newdoc->safe;
      }
      HTList_linkObject((HTList *)(8 * hash + 136011744), foundAnchor, &foundAnchor->_add_adult);
      return foundAnchor;
    }
  }
  while ( !HTSEquivalent(object->address, newdoc->address)
       || (object->info || v6)
       && (!object->info
        || !HTBEquivalent(object->info->post_data, newdoc->post_data)
        || object->info->isHEAD != newdoc->isHEAD) );
  if ( WWW_TraceFlag[0] )
  {
    v1 = newdoc->address;
    v2 = TraceFP();
    fprintf(v2, "Anchor %p with address `%s' already exists.\n", object, v1);
  }
  return object;
}

//----- (08125FC7) --------------------------------------------------------
HTParentAnchor *__cdecl HTAnchor_findSimpleAddress(const char *url)
{
  DocAddress urldoc; // [esp+14h] [ebp-14h] BYREF

  urldoc.address = (char *)url;
  memset(&urldoc.post_data, 0, 14);
  return HTAnchor_findAddress(&urldoc);
}

//----- (08125FFD) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_link(HTChildAnchor *child, HTAnchor *destination, HTLinkType *type)
{
  FILE *v3; // edx
  FILE *v4; // eax

  if ( !child || !destination )
    return 0;
  if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "Linking child %p to anchor %p\n", child, destination);
  }
  if ( child->dest )
  {
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "*** child anchor already has destination, exiting!\n");
    }
    return 0;
  }
  else
  {
    child->dest = destination;
    child->type = type;
    if ( child->parent != destination->parent )
      HTList_linkObject(&destination->parent->sources, child, &child->_add_sources);
    return 1;
  }
}

//----- (081260C7) --------------------------------------------------------
void __cdecl deleteLinks(HTChildAnchor *me)
{
  HTParentAnchor0 *parent; // [esp+14h] [ebp-4h]

  if ( me->dest )
  {
    parent = me->dest->parent;
    me->dest = 0;
    if ( me->parent != parent && parent->sources.next )
      HTList_unlinkObject(&parent->sources, me);
    if ( me->parent != parent && !parent->underway && (!parent->info || !parent->info->document) )
      HTAnchor_delete(parent);
    me->type = 0;
  }
}

//----- (08126158) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_delete(HTParentAnchor0 *me)
{
  HTChildAnchor *child; // [esp+20h] [ebp-8h]
  HTBTElement *ele; // [esp+24h] [ebp-4h]
  HTBTElement *elea; // [esp+24h] [ebp-4h]

  if ( !me )
    return 0;
  if ( me->underway || me->info && me->info->document )
    return 0;
  me->underway = 1;
  if ( me->children )
  {
    for ( ele = HTBTree_next(me->children, 0); ele; ele = HTBTree_next(me->children, ele) )
    {
      if ( *((_DWORD *)ele->object + 2) )
        deleteLinks((HTChildAnchor *)ele->object);
    }
  }
  me->underway = 0;
  if ( me->sources.next )
    return 0;
  if ( me->children )
  {
    for ( elea = HTBTree_next(me->children, 0); elea; elea = HTBTree_next(me->children, elea) )
    {
      child = (HTChildAnchor *)elea->object;
      if ( *((_DWORD *)elea->object + 1) )
      {
        free(child->tag);
        child->tag = 0;
      }
      if ( child )
        free(child);
    }
    HTBTree_free(me->children);
  }
  if ( me->info )
  {
    HTParentAnchor_free(me->info);
    if ( me->info )
    {
      free(me->info);
      me->info = 0;
    }
  }
  HTList_unlinkObject(&adult_table[me->adult_hash], me);
  if ( me->address )
  {
    free(me->address);
    me->address = 0;
  }
  free(me);
  return 1;
}
// 8126330: conditional instruction was optimized away because %me.4!=0

//----- (0812634E) --------------------------------------------------------
void __cdecl HTAnchor_delete_links(HTParentAnchor *me)
{
  HTChildAnchor *child; // [esp+10h] [ebp-8h]

  if ( me && me->document )
  {
    me->parent->underway = 1;
    if ( me->children_notag.next )
    {
      while ( 1 )
      {
        child = (HTChildAnchor *)HTList_unlinkLastObject(&me->children_notag);
        if ( !child )
          break;
        deleteLinks(child);
      }
    }
    me->parent->underway = 0;
  }
}

//----- (081263AC) --------------------------------------------------------
void __cdecl HTParentAnchor_free(HTParentAnchor *me)
{
  FILE *fd; // [esp+14h] [ebp-4h]

  if ( me->methods )
  {
    HTList_delete(me->methods);
    me->methods = 0;
  }
  if ( me->charset )
  {
    free(me->charset);
    me->charset = 0;
  }
  if ( me->isIndexAction )
  {
    free(me->isIndexAction);
    me->isIndexAction = 0;
  }
  if ( me->isIndexPrompt )
  {
    free(me->isIndexPrompt);
    me->isIndexPrompt = 0;
  }
  if ( me->title )
  {
    free(me->title);
    me->title = 0;
  }
  if ( me->physical )
  {
    free(me->physical);
    me->physical = 0;
  }
  HTSABFree(&me->post_data);
  if ( me->post_content_type )
  {
    free(me->post_content_type);
    me->post_content_type = 0;
  }
  if ( me->bookmark )
  {
    free(me->bookmark);
    me->bookmark = 0;
  }
  if ( me->owner )
  {
    free(me->owner);
    me->owner = 0;
  }
  if ( me->RevTitle )
  {
    free(me->RevTitle);
    me->RevTitle = 0;
  }
  if ( me->citehost )
  {
    free(me->citehost);
    me->citehost = 0;
  }
  HTAnchor_clearSourceCache(me);
  if ( me->FileCache )
  {
    fd = (FILE *)fopen64(me->FileCache, "r");
    if ( fd )
    {
      fclose(fd);
      remove(me->FileCache);
    }
    if ( me->FileCache )
    {
      free(me->FileCache);
      me->FileCache = 0;
    }
  }
  if ( me->SugFname )
  {
    free(me->SugFname);
    me->SugFname = 0;
  }
  if ( me->cache_control )
  {
    free(me->cache_control);
    me->cache_control = 0;
  }
  if ( me->content_type_params )
  {
    free(me->content_type_params);
    me->content_type_params = 0;
  }
  if ( me->content_type )
  {
    free(me->content_type);
    me->content_type = 0;
  }
  if ( me->content_language )
  {
    free(me->content_language);
    me->content_language = 0;
  }
  if ( me->content_encoding )
  {
    free(me->content_encoding);
    me->content_encoding = 0;
  }
  if ( me->content_base )
  {
    free(me->content_base);
    me->content_base = 0;
  }
  if ( me->content_disposition )
  {
    free(me->content_disposition);
    me->content_disposition = 0;
  }
  if ( me->content_location )
  {
    free(me->content_location);
    me->content_location = 0;
  }
  if ( me->content_md5 )
  {
    free(me->content_md5);
    me->content_md5 = 0;
  }
  if ( me->message_id )
  {
    free(me->message_id);
    me->message_id = 0;
  }
  if ( me->subject )
  {
    free(me->subject);
    me->subject = 0;
  }
  if ( me->date )
  {
    free(me->date);
    me->date = 0;
  }
  if ( me->expires )
  {
    free(me->expires);
    me->expires = 0;
  }
  if ( me->last_modified )
  {
    free(me->last_modified);
    me->last_modified = 0;
  }
  if ( me->ETag )
  {
    free(me->ETag);
    me->ETag = 0;
  }
  if ( me->server )
  {
    free(me->server);
    me->server = 0;
  }
  if ( me->style )
  {
    free(me->style);
    me->style = 0;
  }
  if ( me->UCStages )
  {
    free(me->UCStages);
    me->UCStages = 0;
  }
  ImageMapList_free(me->imaps);
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (081268AA) --------------------------------------------------------
void __cdecl HTAnchor_clearSourceCache(HTParentAnchor *me)
{
  char *source_cache_file; // ebx
  FILE *v2; // eax
  HTChunk *source_cache_chunk; // ebx
  FILE *v4; // eax

  if ( me->source_cache_file )
  {
    if ( WWW_TraceFlag[0] )
    {
      source_cache_file = me->source_cache_file;
      v2 = TraceFP();
      fprintf(v2, "SourceCache: Removing file %s\n", source_cache_file);
    }
    LYRemoveTemp(me->source_cache_file);
    if ( me->source_cache_file )
    {
      free(me->source_cache_file);
      me->source_cache_file = 0;
    }
  }
  if ( me->source_cache_chunk )
  {
    if ( WWW_TraceFlag[0] )
    {
      source_cache_chunk = me->source_cache_chunk;
      v4 = TraceFP();
      fprintf(v4, "SourceCache: Removing memory chunk %p\n", source_cache_chunk);
    }
    HTChunkFree(me->source_cache_chunk);
    me->source_cache_chunk = 0;
  }
}

//----- (0812696B) --------------------------------------------------------
HTParentAnchor *__cdecl HTAnchor_parent(HTAnchor *me)
{
  if ( !me )
    return 0;
  if ( me->parent->info )
    return me->parent->info;
  return HTParentAnchor_new(me->parent);
}

//----- (081269AE) --------------------------------------------------------
void __cdecl HTAnchor_setDocument(HTParentAnchor *me, HyperDoc *doc)
{
  if ( me )
    me->document = doc;
}

//----- (081269C2) --------------------------------------------------------
HyperDoc *__cdecl HTAnchor_document(HTParentAnchor *me)
{
  if ( me )
    return me->document;
  else
    return 0;
}

//----- (081269E5) --------------------------------------------------------
char *__cdecl HTAnchor_address(HTAnchor *me)
{
  char *addr; // [esp+24h] [ebp-4h] BYREF

  addr = 0;
  if ( me )
  {
    if ( (HTAnchor *)me->parent == me || (HTAnchor *)me->parent->info == me || !me[1].parent )
      HTSACopy(&addr, me->parent->address);
    else
      HTSprintf0(&addr, "%s#%s", me->parent->address, (const char *)me[1].parent);
  }
  return addr;
}

//----- (08126A64) --------------------------------------------------------
void __cdecl HTAnchor_setFormat(HTParentAnchor *me, HTFormat form)
{
  if ( me )
    me->format = form;
}

//----- (08126A78) --------------------------------------------------------
HTFormat __cdecl HTAnchor_format(HTParentAnchor *me)
{
  if ( me )
    return me->format;
  else
    return 0;
}

//----- (08126A9B) --------------------------------------------------------
void __cdecl HTAnchor_setIndex(HTParentAnchor *me, const char *address)
{
  if ( me )
  {
    me->isIndex = 1;
    HTSACopy(&me->isIndexAction, address);
  }
}

//----- (08126AC5) --------------------------------------------------------
void __cdecl HTAnchor_setPrompt(HTParentAnchor *me, const char *prompt)
{
  if ( me )
    HTSACopy(&me->isIndexPrompt, prompt);
}

//----- (08126AE8) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_isIndex(HTParentAnchor *me)
{
  if ( me )
    return me->isIndex;
  else
    return 0;
}

//----- (08126B0A) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_isISMAPScript(HTAnchor *me)
{
  if ( me && me->parent->info )
    return me->parent->info->isISMAPScript;
  else
    return 0;
}

//----- (08126B3D) --------------------------------------------------------
const char *__cdecl HTAnchor_style(HTParentAnchor *me)
{
  if ( me )
    return me->style;
  else
    return 0;
}

//----- (08126B60) --------------------------------------------------------
void __cdecl HTAnchor_setStyle(HTParentAnchor *me, const char *style)
{
  if ( me )
    HTSACopy(&me->style, style);
}

//----- (08126B83) --------------------------------------------------------
const char *__cdecl HTAnchor_title(HTParentAnchor *me)
{
  if ( me )
    return me->title;
  else
    return 0;
}

//----- (08126BA6) --------------------------------------------------------
void __cdecl HTAnchor_setTitle(HTParentAnchor *me, const char *title)
{
  FILE *v2; // eax
  char *v3; // ebx
  FILE *v4; // eax
  FILE *v5; // eax
  int i; // [esp+20h] [ebp-8h]

  if ( me )
  {
    if ( title )
    {
      HTSACopy(&me->title, title);
      for ( i = 0; me->title[i]; ++i )
      {
        if ( me->title[i] == 1 || me->title[i] == 2 )
          me->title[i] = 32;
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "HTAnchor_setTitle: New title is NULL! ");
      }
      if ( me->title )
      {
        if ( WWW_TraceFlag[0] )
        {
          v3 = me->title;
          v4 = TraceFP();
          fprintf(v4, "Old title was \"%s\".\n", v3);
        }
        if ( me->title )
        {
          free(me->title);
          me->title = 0;
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "Old title was NULL.\n");
      }
    }
  }
}

//----- (08126CD0) --------------------------------------------------------
void __cdecl HTAnchor_appendTitle(HTParentAnchor *me, const char *title)
{
  int i; // [esp+14h] [ebp-4h]

  if ( me )
  {
    HTSACat(&me->title, title);
    for ( i = 0; me->title[i]; ++i )
    {
      if ( me->title[i] == 1 || me->title[i] == 2 )
        me->title[i] = 32;
    }
  }
}

//----- (08126D48) --------------------------------------------------------
const char *__cdecl HTAnchor_bookmark(HTParentAnchor *me)
{
  if ( me )
    return me->bookmark;
  else
    return 0;
}

//----- (08126D6B) --------------------------------------------------------
void __cdecl HTAnchor_setBookmark(HTParentAnchor *me, const char *bookmark)
{
  if ( me )
    HTSACopy(&me->bookmark, bookmark);
}

//----- (08126D8E) --------------------------------------------------------
const char *__cdecl HTAnchor_owner(HTParentAnchor *me)
{
  if ( me )
    return me->owner;
  else
    return 0;
}

//----- (08126DB1) --------------------------------------------------------
void __cdecl HTAnchor_setOwner(HTParentAnchor *me, const char *owner)
{
  if ( me )
    HTSACopy(&me->owner, owner);
}

//----- (08126DD4) --------------------------------------------------------
const char *__cdecl HTAnchor_RevTitle(HTParentAnchor *me)
{
  if ( me )
    return me->RevTitle;
  else
    return 0;
}

//----- (08126DF7) --------------------------------------------------------
void __cdecl HTAnchor_setRevTitle(HTParentAnchor *me, const char *title)
{
  int i; // [esp+14h] [ebp-4h]

  if ( me )
  {
    HTSACopy(&me->RevTitle, title);
    for ( i = 0; me->RevTitle[i]; ++i )
    {
      if ( me->RevTitle[i] == 1 || me->RevTitle[i] == 2 )
        me->RevTitle[i] = 32;
    }
  }
}

//----- (08126E6F) --------------------------------------------------------
const char *__cdecl HTAnchor_citehost(HTParentAnchor *me)
{
  if ( me )
    return me->citehost;
  else
    return 0;
}

//----- (08126E92) --------------------------------------------------------
void __cdecl HTAnchor_setCitehost(HTParentAnchor *me, const char *citehost)
{
  if ( me )
    HTSACopy(&me->citehost, citehost);
}

//----- (08126EB5) --------------------------------------------------------
const char *__cdecl HTAnchor_SugFname(HTParentAnchor *me)
{
  if ( me )
    return me->SugFname;
  else
    return 0;
}

//----- (08126ED8) --------------------------------------------------------
const char *__cdecl HTAnchor_content_type_params(HTParentAnchor *me)
{
  if ( me )
    return me->content_type_params;
  else
    return 0;
}

//----- (08126EFB) --------------------------------------------------------
const char *__cdecl HTAnchor_content_encoding(HTParentAnchor *me)
{
  if ( me )
    return me->content_encoding;
  else
    return 0;
}

//----- (08126F1E) --------------------------------------------------------
const char *__cdecl HTAnchor_content_type(HTParentAnchor *me)
{
  if ( me )
    return me->content_type;
  else
    return 0;
}

//----- (08126F41) --------------------------------------------------------
const char *__cdecl HTAnchor_last_modified(HTParentAnchor *me)
{
  if ( me )
    return me->last_modified;
  else
    return 0;
}

//----- (08126F67) --------------------------------------------------------
const char *__cdecl HTAnchor_date(HTParentAnchor *me)
{
  if ( me )
    return me->date;
  else
    return 0;
}

//----- (08126F8D) --------------------------------------------------------
const char *__cdecl HTAnchor_server(HTParentAnchor *me)
{
  if ( me )
    return me->server;
  else
    return 0;
}

//----- (08126FB3) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_safe(HTParentAnchor *me)
{
  if ( me )
    return me->safe;
  else
    return 0;
}

//----- (08126FD5) --------------------------------------------------------
const char *__cdecl HTAnchor_content_base(HTParentAnchor *me)
{
  if ( me )
    return me->content_base;
  else
    return 0;
}

//----- (08126FFB) --------------------------------------------------------
const char *__cdecl HTAnchor_content_location(HTParentAnchor *me)
{
  if ( me )
    return me->content_location;
  else
    return 0;
}

//----- (08127021) --------------------------------------------------------
const char *__cdecl HTAnchor_messageID(HTParentAnchor *me)
{
  if ( me )
    return me->message_id;
  else
    return 0;
}

//----- (08127047) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_setMessageID(HTParentAnchor *me, const char *messageid)
{
  if ( !me || !messageid || !*messageid )
    return 0;
  HTSACopy(&me->message_id, messageid);
  return 1;
}

//----- (0812708B) --------------------------------------------------------
const char *__cdecl HTAnchor_subject(HTParentAnchor *me)
{
  if ( me )
    return me->subject;
  else
    return 0;
}

//----- (081270B1) --------------------------------------------------------
BOOLEAN __cdecl HTAnchor_setSubject(HTParentAnchor *me, const char *subject)
{
  if ( !me || !subject || !*subject )
    return 0;
  HTSACopy(&me->subject, subject);
  return 1;
}

//----- (081270F5) --------------------------------------------------------
HTAnchor *__cdecl HTAnchor_followLink(HTChildAnchor *me)
{
  return me->dest;
}

//----- (08127100) --------------------------------------------------------
HTAnchor *__cdecl HTAnchor_followTypedLink(HTChildAnchor *me, HTLinkType *type)
{
  if ( me->type == type )
    return me->dest;
  else
    return 0;
}

//----- (08127128) --------------------------------------------------------
HTList *__cdecl HTAnchor_methods(HTParentAnchor *me)
{
  if ( !me->methods )
    me->methods = HTList_new();
  return me->methods;
}

//----- (0812714D) --------------------------------------------------------
void *__cdecl HTAnchor_protocol(HTParentAnchor *me)
{
  return me->protocol;
}

//----- (08127158) --------------------------------------------------------
void __cdecl HTAnchor_setProtocol(HTParentAnchor *me, void *protocol)
{
  me->protocol = protocol;
}

//----- (08127166) --------------------------------------------------------
char *__cdecl HTAnchor_physical(HTParentAnchor *me)
{
  return me->physical;
}

//----- (08127171) --------------------------------------------------------
void __cdecl HTAnchor_setPhysical(HTParentAnchor *me, char *physical)
{
  if ( me )
    HTSACopy(&me->physical, physical);
}

//----- (08127194) --------------------------------------------------------
LYUCcharset *__cdecl HTAnchor_getUCInfoStage(HTParentAnchor *me, int which_stage)
{
  UCAnchorInfo *stages; // [esp+1Ch] [ebp-Ch]
  int chndl; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  if ( me && !me->UCStages )
  {
    chndl = UCLYhndl_for_unspec;
    stages = (UCAnchorInfo *)calloc(1u, 0xA0u);
    if ( !stages )
      outofmem("../../../WWW/Library/Implementation/HTAnchor.c", "HTAnchor_getUCInfoStage");
    for ( i = 0; i <= 3; ++i )
    {
      stages->s[i].C.MIMEname = byte_818B605;
      stages->s[i].LYhndl = -1;
    }
    if ( me->charset )
    {
      chndl = UCGetLYhndl_byMIME(me->charset);
      if ( chndl < 0 )
        chndl = UCLYhndl_for_unrec;
      if ( chndl < 0 )
        chndl = UCLYhndl_for_unspec;
    }
    memcpy(&stages->s[0].C, &LYCharSet_UC[chndl], sizeof(stages->s[0].C));
    stages->s[0].lock = 1;
    stages->s[0].LYhndl = chndl;
    me->UCStages = stages;
  }
  if ( me )
    return &me->UCStages->s[which_stage].C;
  else
    return 0;
}

//----- (081272E7) --------------------------------------------------------
int __cdecl HTAnchor_getUCLYhndl(HTParentAnchor *me, int which_stage)
{
  if ( !me )
    return -1;
  if ( !me->UCStages )
    HTAnchor_getUCInfoStage(me, which_stage);
  if ( me->UCStages->s[which_stage].lock > 0 )
    return me->UCStages->s[which_stage].LYhndl;
  else
    return -1;
}

//----- (0812735E) --------------------------------------------------------
LYUCcharset *__cdecl HTAnchor_setUCInfoStage(HTParentAnchor *me, int LYhndl, int which_stage, int set_by)
{
  LYUCcharset *p; // [esp+24h] [ebp-4h]

  if ( !me )
    return 0;
  p = HTAnchor_getUCInfoStage(me, which_stage);
  if ( me->UCStages->s[which_stage].lock > set_by )
    return 0;
  me->UCStages->s[which_stage].lock = set_by;
  me->UCStages->s[which_stage].LYhndl = LYhndl;
  if ( LYhndl < 0 )
    p->UChndl = -1;
  else
    memcpy(p, (const void *)(32 * LYhndl + 135902080), sizeof(LYUCcharset));
  return p;
}

//----- (08127429) --------------------------------------------------------
LYUCcharset *__cdecl HTAnchor_resetUCInfoStage(HTParentAnchor *me, int LYhndl, int which_stage, int set_by)
{
  if ( !me || !me->UCStages )
    return 0;
  me->UCStages->s[which_stage].lock = set_by;
  me->UCStages->s[which_stage].LYhndl = LYhndl;
  return &me->UCStages->s[which_stage].C;
}

//----- (081274D4) --------------------------------------------------------
LYUCcharset *__cdecl HTAnchor_copyUCInfoStage(HTParentAnchor *me, int to_stage, int from_stage, int set_by)
{
  LYUCcharset *p_to; // [esp+18h] [ebp-10h]
  LYUCcharset *p_from; // [esp+1Ch] [ebp-Ch]

  if ( !me )
    return 0;
  p_from = HTAnchor_getUCInfoStage(me, from_stage);
  p_to = HTAnchor_getUCInfoStage(me, to_stage);
  if ( set_by == -1 )
    set_by = me->UCStages->s[from_stage].lock;
  if ( !set_by )
    set_by = 1;
  if ( me->UCStages->s[to_stage].lock > set_by )
    return 0;
  me->UCStages->s[to_stage].lock = set_by;
  me->UCStages->s[to_stage].LYhndl = me->UCStages->s[from_stage].LYhndl;
  if ( p_to != p_from )
    memcpy(p_to, p_from, sizeof(LYUCcharset));
  return p_to;
}

//----- (081275F8) --------------------------------------------------------
HTStyle *HTStyleNew()
{
  HTStyle *self; // [esp+14h] [ebp-4h]

  self = (HTStyle *)calloc(1u, 0x50u);
  if ( !self )
    outofmem("../../../WWW/Library/Implementation/HTStyle.c", "HTStyleNew");
  return self;
}

//----- (08127634) --------------------------------------------------------
HTStyle *__cdecl HTStyleNewNamed(const char *name)
{
  HTStyle *self; // [esp+14h] [ebp-4h]

  self = HTStyleNew();
  HTSACopy(&self->name, name);
  self->id = -1;
  return self;
}

//----- (08127666) --------------------------------------------------------
HTStyle *__cdecl HTStyleFree(HTStyle *self)
{
  if ( self->name )
  {
    free(self->name);
    self->name = 0;
  }
  if ( self->SGMLTag )
  {
    free(self->SGMLTag);
    self->SGMLTag = 0;
  }
  if ( self )
    free(self);
  return 0;
}

//----- (081276CF) --------------------------------------------------------
HTStyle *__cdecl HTStyleNamed(HTStyleSheet *self, const char *name)
{
  FILE *v2; // edx
  HTStyle *scan; // [esp+24h] [ebp-4h]

  for ( scan = self->styles; scan; scan = scan->next )
  {
    if ( !strcmp(scan->name, name) )
      return scan;
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "StyleSheet: No style named `%s'\n", name);
  }
  return 0;
}

//----- (08127746) --------------------------------------------------------
HTStyleSheet *__cdecl HTStyleSheetAddStyle(HTStyleSheet *self, HTStyle *style)
{
  HTStyle *scan; // [esp+Ch] [ebp-4h]

  style->next = 0;
  if ( self->styles )
  {
    for ( scan = self->styles; scan->next; scan = scan->next )
      ;
    scan->next = style;
  }
  else
  {
    self->styles = style;
  }
  return self;
}

//----- (08127793) --------------------------------------------------------
HTStyleSheet *__cdecl HTStyleSheetRemoveStyle(HTStyleSheet *self, HTStyle *style)
{
  HTStyle *scan; // [esp+10h] [ebp-4h]

  if ( self->styles == style )
  {
    self->styles = style->next;
    return self;
  }
  else
  {
    for ( scan = self->styles; scan; scan = scan->next )
    {
      if ( scan->next == style )
      {
        scan->next = style->next;
        return self;
      }
    }
    return 0;
  }
}

//----- (081277F8) --------------------------------------------------------
HTStyleSheet *HTStyleSheetNew()
{
  HTStyleSheet *self; // [esp+14h] [ebp-4h]

  self = (HTStyleSheet *)calloc(1u, 8u);
  if ( !self )
    outofmem("../../../WWW/Library/Implementation/HTStyle.c", "HTStyleSheetNew");
  return self;
}

//----- (08127834) --------------------------------------------------------
HTStyleSheet *__cdecl HTStyleSheetFree(HTStyleSheet *self)
{
  HTStyle *style; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    style = self->styles;
    if ( !style )
      break;
    self->styles = style->next;
    HTStyleFree(style);
  }
  if ( self )
    free(self);
  return 0;
}

//----- (08127880) --------------------------------------------------------
HTList *HTList_new()
{
  HTList *newList; // [esp+14h] [ebp-4h]

  newList = (HTList *)malloc(8u);
  if ( !newList )
    outofmem("../../../WWW/Library/Implementation/HTList.c", "HTList_new");
  newList->object = 0;
  newList->next = 0;
  return newList;
}

//----- (081278C7) --------------------------------------------------------
void __cdecl HTList_delete(HTList *me)
{
  HTList *current; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    current = me;
    if ( !me )
      break;
    me = me->next;
    if ( current )
      free(current);
  }
}

//----- (081278FE) --------------------------------------------------------
HTList *__cdecl HTList_reverse(HTList *start)
{
  HTList *succ; // [esp+Ch] [ebp-8h]
  HTList *cur; // [esp+10h] [ebp-4h]

  if ( !start )
    return start;
  if ( !start->next )
    return start;
  cur = start->next->next;
  if ( !cur )
    return start;
  start->next->next = 0;
  while ( cur )
  {
    succ = cur->next;
    cur->next = start->next;
    start->next = cur;
    cur = succ;
  }
  return start;
}

//----- (08127972) --------------------------------------------------------
HTList *__cdecl HTList_appendList(HTList *start, HTList *tail)
{
  FILE *v2; // edx
  HTList *temp; // [esp+24h] [ebp-4h]

  temp = start;
  if ( start )
  {
    if ( tail && tail->next )
    {
      while ( temp->next )
        temp = temp->next;
      temp->next = tail->next;
      tail->next = 0;
      return start;
    }
    else
    {
      return start;
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HTList: Trying to append list %p to a nonexisting list\n", tail);
    }
    return 0;
  }
}

//----- (08127A04) --------------------------------------------------------
void __cdecl HTList_linkObject(HTList *me, void *newObject, HTList *newNode)
{
  FILE *v3; // eax
  FILE *v4; // edx
  FILE *v5; // eax

  if ( me )
  {
    if ( newNode->object || newNode->next )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "*** HTList: Refuse linking already linked obj ");
      }
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "%p, node %p, list %p\n", newObject, newNode, me);
      }
    }
    else
    {
      newNode->object = newObject;
      newNode->next = me->next;
      me->next = newNode;
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "HTList: Trying to link object %p to a nonexisting list\n", newObject);
  }
}

//----- (08127AD1) --------------------------------------------------------
void __cdecl HTList_addObject(HTList *me, void *newObject)
{
  FILE *v2; // eax
  HTList *newNode; // [esp+24h] [ebp-4h]

  if ( me )
  {
    newNode = (HTList *)malloc(8u);
    if ( !newNode )
      outofmem("../../../WWW/Library/Implementation/HTList.c", "HTList_addObject");
    newNode->object = newObject;
    newNode->next = me->next;
    me->next = newNode;
  }
  else if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "HTList: Trying to add object %p to a nonexisting list\n", newObject);
  }
}

//----- (08127B50) --------------------------------------------------------
void __cdecl HTList_appendObject(HTList *me, void *newObject)
{
  HTList *temp; // [esp+14h] [ebp-4h]

  temp = me;
  if ( me && newObject )
  {
    while ( temp->next )
      temp = temp->next;
    HTList_addObject(temp, newObject);
  }
}

//----- (08127B91) --------------------------------------------------------
void __cdecl HTList_insertObjectAt(HTList *me, void *newObject, int pos)
{
  FILE *v3; // eax
  FILE *v4; // edx
  int Pos; // [esp+18h] [ebp-10h]
  HTList *prevNode; // [esp+1Ch] [ebp-Ch]
  HTList *temp; // [esp+20h] [ebp-8h]
  HTList *newNode; // [esp+24h] [ebp-4h]

  temp = me;
  Pos = pos;
  if ( me )
  {
    if ( pos < 0 )
    {
      Pos = 0;
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "HTList: Treating negative object position %d as %d.\n", pos, 0);
      }
    }
    prevNode = me;
    while ( 1 )
    {
      temp = temp->next;
      if ( !temp )
      {
        if ( Pos >= 0 )
          HTList_addObject(prevNode, newObject);
        return;
      }
      if ( !Pos )
        break;
      prevNode = temp;
      --Pos;
    }
    newNode = (HTList *)malloc(8u);
    if ( !newNode )
      outofmem("../../../WWW/Library/Implementation/HTList.c", "HTList_addObjectAt");
    newNode->object = newObject;
    newNode->next = temp;
    prevNode->next = newNode;
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTList: Trying to add object %p to a nonexisting list\n", newObject);
  }
}
// 8127C66: conditional instruction was optimized away because %prevNode.4!=0

//----- (08127CA6) --------------------------------------------------------
BOOLEAN __cdecl HTList_unlinkObject(HTList *me, void *oldObject)
{
  HTList *prevNode; // [esp+Ch] [ebp-8h]
  HTList *temp; // [esp+10h] [ebp-4h]

  temp = me;
  if ( me && oldObject )
  {
    while ( temp->next )
    {
      prevNode = temp;
      temp = temp->next;
      if ( temp->object == oldObject )
      {
        prevNode->next = temp->next;
        temp->next = 0;
        temp->object = 0;
        return 1;
      }
    }
  }
  return 0;
}

//----- (08127D12) --------------------------------------------------------
BOOLEAN __cdecl HTList_removeObject(HTList *me, void *oldObject)
{
  HTList *prevNode; // [esp+10h] [ebp-8h]
  HTList *temp; // [esp+14h] [ebp-4h]

  temp = me;
  if ( me && oldObject )
  {
    while ( temp->next )
    {
      prevNode = temp;
      temp = temp->next;
      if ( temp->object == oldObject )
      {
        prevNode->next = temp->next;
        if ( temp )
          free(temp);
        return 1;
      }
    }
  }
  return 0;
}

//----- (08127D83) --------------------------------------------------------
void *__cdecl HTList_removeObjectAt(HTList *me, int position)
{
  int pos; // [esp+Ch] [ebp-Ch]
  HTList *prevNode; // [esp+10h] [ebp-8h]
  HTList *temp; // [esp+14h] [ebp-4h]

  temp = me;
  pos = position;
  if ( !me || position < 0 )
    return 0;
  prevNode = me;
  while ( 1 )
  {
    temp = temp->next;
    if ( !temp )
      return 0;
    if ( !pos )
      break;
    prevNode = temp;
    --pos;
  }
  prevNode->next = temp->next;
  free(temp);
  return temp->object;
}
// 8127DCE: conditional instruction was optimized away because %temp.4!=0

//----- (08127E11) --------------------------------------------------------
void *__cdecl HTList_unlinkLastObject(HTList *me)
{
  void *lastObject; // [esp+Ch] [ebp-8h]
  HTList *lastNode; // [esp+10h] [ebp-4h]

  if ( !me || !me->next )
    return 0;
  lastNode = me->next;
  lastObject = lastNode->object;
  me->next = lastNode->next;
  lastNode->next = 0;
  lastNode->object = 0;
  return lastObject;
}

//----- (08127E6B) --------------------------------------------------------
void *__cdecl HTList_removeLastObject(HTList *me)
{
  void *lastObject; // [esp+10h] [ebp-8h]
  HTList *lastNode; // [esp+14h] [ebp-4h]

  if ( !me || !me->next )
    return 0;
  lastNode = me->next;
  lastObject = lastNode->object;
  me->next = lastNode->next;
  if ( lastNode )
    free(lastNode);
  return lastObject;
}

//----- (08127ECA) --------------------------------------------------------
void *__cdecl HTList_removeFirstObject(HTList *me)
{
  void *firstObject; // [esp+Ch] [ebp-Ch]
  HTList *prevNode; // [esp+10h] [ebp-8h]
  HTList *temp; // [esp+14h] [ebp-4h]

  temp = me;
  if ( !me )
    return 0;
  prevNode = me;
  if ( !me->next )
    return 0;
  while ( temp->next )
  {
    prevNode = temp;
    temp = temp->next;
  }
  firstObject = temp->object;
  prevNode->next = 0;
  if ( temp )
    free(temp);
  return firstObject;
}

//----- (08127F4E) --------------------------------------------------------
int __cdecl HTList_count(HTList *me)
{
  int count; // [esp+8h] [ebp-8h]
  HTList *temp; // [esp+Ch] [ebp-4h]

  temp = me;
  count = 0;
  if ( me )
  {
    while ( 1 )
    {
      temp = temp->next;
      if ( !temp )
        break;
      ++count;
    }
  }
  return count;
}

//----- (08127F81) --------------------------------------------------------
int __cdecl HTList_indexOf(HTList *me, void *object)
{
  int position; // [esp+Ch] [ebp-8h]
  HTList *temp; // [esp+10h] [ebp-4h]

  temp = me;
  position = 0;
  if ( me )
  {
    while ( 1 )
    {
      temp = temp->next;
      if ( !temp )
        break;
      if ( temp->object == object )
        return position;
      ++position;
    }
  }
  return -1;
}

//----- (08127FCD) --------------------------------------------------------
void *__cdecl HTList_objectAt(HTList *me, int position)
{
  int pos; // [esp+Ch] [ebp-8h]
  HTList *temp; // [esp+10h] [ebp-4h]

  temp = me;
  pos = position;
  if ( !me || position < 0 )
    return 0;
  while ( 1 )
  {
    temp = temp->next;
    if ( !temp )
      break;
    if ( !pos )
      return temp->object;
    --pos;
  }
  return 0;
}

//----- (08128024) --------------------------------------------------------
int __cdecl strcasecomp8(const char *a, const char *b)
{
  int diff; // [esp+1Ch] [ebp-Ch]

  while ( *a && *b )
  {
    diff = UPPER8(*a, *b);
    if ( diff )
      return diff;
    ++a;
    ++b;
  }
  if ( *a )
    return 1;
  if ( *b )
    return -1;
  return 0;
}

//----- (081280B5) --------------------------------------------------------
int __cdecl strncasecomp8(const char *a, const char *b, int n)
{
  int diff; // [esp+1Ch] [ebp-Ch]
  const char *p; // [esp+24h] [ebp-4h]

  for ( p = a; ; ++p )
  {
    if ( &a[n] == p )
      return 0;
    if ( !*p || !*b )
      return *p - *b;
    diff = UPPER8(*p, *b);
    if ( diff )
      break;
    ++b;
  }
  return diff;
}

//----- (08128148) --------------------------------------------------------
int __cdecl strcasecomp(const char *a, const char *b)
{
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]

  while ( *a && *b )
  {
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)a] & 0x100) != 0 )
      v3 = tolower(*(unsigned __int8 *)a);
    else
      v3 = *(unsigned __int8 *)a;
    if ( ((*__ctype_b_loc())[*(unsigned __int8 *)b] & 0x100) != 0 )
      v4 = tolower(*(unsigned __int8 *)b);
    else
      v4 = *(unsigned __int8 *)b;
    if ( v3 != v4 )
      return v3 - v4;
    ++a;
    ++b;
  }
  if ( *a )
    return 1;
  if ( *b )
    return -1;
  return 0;
}

//----- (08128254) --------------------------------------------------------
int __cdecl strncasecomp(const char *a, const char *b, int n)
{
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  const char *p; // [esp+24h] [ebp-4h]

  for ( p = a; ; ++p )
  {
    if ( &a[n] == p )
      return 0;
    if ( !*p || !*b )
      return *p - *b;
    v5 = ((*__ctype_b_loc())[*(unsigned __int8 *)p] & 0x100) != 0 ? tolower(*(unsigned __int8 *)p) : *(unsigned __int8 *)p;
    v6 = ((*__ctype_b_loc())[*(unsigned __int8 *)b] & 0x100) != 0 ? tolower(*(unsigned __int8 *)b) : *(unsigned __int8 *)b;
    if ( v5 != v6 )
      break;
    ++b;
  }
  return v5 - v6;
}

//----- (08128364) --------------------------------------------------------
int __cdecl strcasecomp_asterisk(const char *a, const char *b)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int done; // [esp+1Ch] [ebp-Ch]
  int result; // [esp+20h] [ebp-8h]
  const char *p; // [esp+24h] [ebp-4h]

  result = 0;
  done = 0;
  while ( !result && !done )
  {
    if ( *a == 42 )
    {
      for ( p = b; *p != 46 && *p; ++p )
      {
        if ( !strcasecomp_asterisk(a + 1, p) )
        {
          b = p - 1;
          result = 0;
          done = 1;
          goto LABEL_26;
        }
      }
      if ( a[1] != 46 && a[1] )
      {
        result = 1;
      }
      else
      {
        b = p - 1;
        result = 0;
      }
    }
    else if ( *b == 42 )
    {
      result = strcasecomp_asterisk(b, a);
      done = result == 0;
    }
    else
    {
      if ( !*a || !*b )
        return *a != *b;
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)a] & 0x100) != 0 )
        v3 = tolower(*(unsigned __int8 *)a);
      else
        v3 = *(unsigned __int8 *)a;
      if ( ((*__ctype_b_loc())[*(unsigned __int8 *)b] & 0x100) != 0 )
        v4 = tolower(*(unsigned __int8 *)b);
      else
        v4 = *(unsigned __int8 *)b;
      if ( v3 != v4 )
        return 1;
    }
LABEL_26:
    ++a;
    ++b;
  }
  return result;
}

//----- (0812853D) --------------------------------------------------------
char *__cdecl HTSACopy(char **dest, const char *src)
{
  size_t size; // [esp+24h] [ebp-4h]

  if ( src )
  {
    if ( *dest != src )
    {
      size = strlen(src) + 1;
      if ( *dest )
      {
        free(*dest);
        *dest = 0;
      }
      *dest = (char *)malloc(size);
      if ( !*dest )
        outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACopy");
      memcpy(*dest, src, size);
    }
  }
  else if ( *dest )
  {
    free(*dest);
    *dest = 0;
  }
  return *dest;
}

//----- (081285FD) --------------------------------------------------------
char *__cdecl HTSACat(char **dest, const char *src)
{
  size_t v2; // eax
  size_t v3; // eax
  size_t length; // [esp+14h] [ebp-4h]

  if ( src && *src && *dest != src )
  {
    if ( *dest )
    {
      length = strlen(*dest);
      v2 = strlen(src);
      *dest = (char *)realloc(*dest, length + v2 + 1);
      if ( !*dest )
        outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACat");
      strcpy(&(*dest)[length], src);
    }
    else
    {
      v3 = strlen(src);
      *dest = (char *)malloc(v3 + 1);
      if ( !*dest )
        outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACat");
      strcpy(*dest, src);
    }
  }
  return *dest;
}

//----- (081286F8) --------------------------------------------------------
void __cdecl HTSAFree_extra(char *s)
{
  free(s - 4);
}

//----- (0812870E) --------------------------------------------------------
char *__cdecl HTSACopy_extra(char **dest, const char *src)
{
  size_t size; // [esp+20h] [ebp-8h]
  size_t srcsize; // [esp+24h] [ebp-4h]

  if ( src )
  {
    srcsize = strlen(src) + 1;
    size = 0;
    if ( *dest )
      size = *((_DWORD *)*dest - 1);
    if ( size < srcsize )
    {
      if ( *dest )
      {
        HTSAFree_extra(*dest);
        *dest = 0;
      }
      *dest = (char *)malloc(2 * srcsize + 4);
      if ( !*dest )
        outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACopy_extra");
      *(_DWORD *)*dest = 2 * srcsize;
      *dest += 4;
    }
    memcpy(*dest, src, srcsize);
  }
  else if ( *dest )
  {
    **dest = 0;
  }
  return *dest;
}

//----- (081287FB) --------------------------------------------------------
char *__cdecl HTNextField(char **pstr)
{
  char *start; // [esp+Ch] [ebp-8h]
  char *p; // [esp+10h] [ebp-4h]

  for ( p = *pstr; *p && (unsigned __int8)*p <= 0x20u; ++p )
    ;
  if ( *p )
  {
    if ( *p == 34 )
    {
      start = ++p;
      while ( *p && *p != 34 )
      {
        if ( *p == 92 && p[1] )
          ++p;
        ++p;
      }
    }
    else
    {
      start = p;
      while ( *p && (unsigned __int8)*p > 0x20u )
        ++p;
    }
    if ( *p )
      *p++ = 0;
    *pstr = p;
    return start;
  }
  else
  {
    *pstr = p;
    return 0;
  }
}

//----- (081288D3) --------------------------------------------------------
char *__cdecl HTNextTok(char **pstr, const char *delims, const char *bracks, char *found)
{
  char *v4; // eax
  bool v7; // [esp+1Ch] [ebp-2Ch]
  bool v8; // [esp+20h] [ebp-28h]
  int v9; // [esp+24h] [ebp-24h]
  int comment_level; // [esp+34h] [ebp-14h]
  char *start; // [esp+38h] [ebp-10h]
  char *p; // [esp+3Ch] [ebp-Ch]
  char closer; // [esp+43h] [ebp-5h]
  bool get_closing_char_too; // [esp+44h] [ebp-4h]
  bool get_comments; // [esp+45h] [ebp-3h]

  p = *pstr;
  start = 0;
  get_closing_char_too = 0;
  if ( !pstr || !*pstr )
    return 0;
  if ( !delims )
    delims = " ;,=";
  if ( !bracks )
    bracks = "<\"";
  v7 = !strchr(delims, 32) && !strchr(bracks, 32);
  v4 = strchr(bracks, 40);
  get_comments = v4 != 0;
  v8 = !v4 && !strchr(delims, 40) && !v7;
  while ( *p && !v7 && (unsigned __int8)*p <= 0x20u )
    ++p;
  if ( !*p )
  {
    *pstr = p;
    if ( found )
      *found = 0;
    return 0;
  }
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( *p && (!v7 && (unsigned __int8)*p <= 0x20u || strchr(delims, *p)) )
          ++p;
        if ( !*p )
        {
          *pstr = p;
          if ( found )
            *found = *(p - 1);
          return 0;
        }
        if ( *p != 40 || !v8 && !get_comments )
          break;
        comment_level = 0;
        if ( get_comments && !start )
          start = p + 1;
        while ( *p )
        {
          if ( *p == 41 && --comment_level <= 0 )
            break;
          if ( *p == 40 )
          {
            ++comment_level;
          }
          else if ( *p == 34 )
          {
            ++p;
            while ( *p && *p != 34 )
            {
              if ( *p == 92 && p[1] )
                ++p;
              ++p;
            }
            if ( !*p )
              break;
          }
          if ( *p == 92 && p[1] )
            ++p;
          ++p;
        }
        if ( get_comments )
          goto LABEL_109;
        if ( *p )
          ++p;
        if ( get_closing_char_too )
        {
          if ( !*p || !strchr(bracks, *p) && strchr(delims, *p) )
            goto LABEL_109;
          goto LABEL_65;
        }
      }
      if ( !strchr(bracks, *p) )
        break;
      v9 = *p;
      if ( v9 == 60 )
      {
        closer = 62;
        goto LABEL_79;
      }
      if ( v9 > 60 )
      {
        if ( v9 == 91 )
        {
          closer = 93;
          goto LABEL_79;
        }
        if ( v9 == 123 )
        {
          closer = 125;
          goto LABEL_79;
        }
      }
      else if ( v9 == 58 )
      {
        closer = 59;
        goto LABEL_79;
      }
      closer = *p;
LABEL_79:
      if ( !start )
        start = ++p;
      while ( *p && *p != closer )
      {
        if ( *p == 92 && p[1] )
          ++p;
        ++p;
      }
      if ( !get_closing_char_too )
        goto LABEL_109;
      if ( !*++p || !strchr(bracks, *p) && strchr(delims, *p) )
        goto LABEL_109;
LABEL_65:
      get_closing_char_too = strchr(bracks, *p) != 0;
    }
    if ( !start )
      start = p;
    while ( *p && (v7 || (unsigned __int8)*p > 0x20u) && !strchr(bracks, *p) && !strchr(delims, *p) )
      ++p;
    if ( !*p || !strchr(bracks, *p) )
      break;
    get_closing_char_too = 1;
  }
  if ( *p != 40 || !v8 )
  {
LABEL_109:
    if ( found )
      *found = *p;
    if ( *p )
      *p++ = 0;
    *pstr = p;
    return start;
  }
  *pstr = p;
  HTNextTok(pstr, 0, "(", found);
  *p = 0;
  if ( *pstr && **pstr )
    ++*pstr;
  return start;
}

//----- (08128E4F) --------------------------------------------------------
char *__cdecl HTAlloc(char *ptr, size_t length)
{
  char *ptra; // [esp+10h] [ebp+8h]

  if ( ptr )
    ptra = (char *)realloc(ptr, length);
  else
    ptra = (char *)malloc(length);
  if ( !ptra )
    outofmem("../../../WWW/Library/Implementation/HTString.c", "HTAlloc");
  return ptra;
}

//----- (08128E9F) --------------------------------------------------------
char *__cdecl StrAllocVsprintf(char **pstr, size_t dst_len, const char *fmt, va_list *ap)
{
  size_t length; // [esp+10h] [ebp-18h]
  char *ptr; // [esp+14h] [ebp-14h]
  char *temp; // [esp+20h] [ebp-8h] BYREF
  char *result; // [esp+24h] [ebp-4h]

  result = 0;
  temp = 0;
  if ( pstr && !dst_len && *pstr )
  {
    free(*pstr);
    *pstr = 0;
  }
  if ( vasprintf(&temp, fmt, *ap) >= 0 )
  {
    if ( dst_len )
    {
      length = dst_len + strlen(temp) + 1;
      if ( pstr )
        ptr = *pstr;
      else
        ptr = 0;
      result = HTAlloc(ptr, length);
      if ( result )
        strcpy(&result[dst_len], temp);
      free(temp);
    }
    else
    {
      result = temp;
    }
  }
  if ( pstr )
    *pstr = result;
  return result;
}

//----- (08128F9F) --------------------------------------------------------
char *HTSprintf(char **pstr, const char *fmt, ...)
{
  va_list ap; // [esp+1Ch] [ebp-Ch] BYREF
  size_t inuse; // [esp+20h] [ebp-8h]
  char *result; // [esp+24h] [ebp-4h]
  va_list va; // [esp+38h] [ebp+10h] BYREF

  va_start(va, fmt);
  result = 0;
  inuse = 0;
  va_copy(ap, va);
  if ( pstr && *pstr )
    inuse = strlen(*pstr);
  return StrAllocVsprintf(pstr, inuse, fmt, &ap);
}

//----- (08129000) --------------------------------------------------------
char *HTSprintf0(char **pstr, const char *fmt, ...)
{
  va_list ap; // [esp+20h] [ebp-8h] BYREF
  char *result; // [esp+24h] [ebp-4h]
  va_list va; // [esp+38h] [ebp+10h] BYREF

  va_start(va, fmt);
  result = 0;
  va_copy(ap, va);
  return StrAllocVsprintf(pstr, 0, fmt, &ap);
}

//----- (0812903C) --------------------------------------------------------
char *__cdecl HTQuoteParameter(const char *parameter)
{
  char *result; // [esp+14h] [ebp-14h]
  size_t quoted; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+1Ch] [ebp-Ch]
  size_t last; // [esp+20h] [ebp-8h]
  size_t i; // [esp+24h] [ebp-4h]
  size_t ia; // [esp+24h] [ebp-4h]

  quoted = 0;
  if ( !parameter )
    parameter = (const char *)&unk_818BB68;
  last = strlen(parameter);
  for ( i = 0; i < last; ++i )
  {
    if ( strchr("\\&#$^*?(){}<>\"';`|", parameter[i])
      || ((*__ctype_b_loc())[(unsigned __int8)parameter[i]] & 0x2000) != 0 )
    {
      ++quoted;
    }
  }
  result = (char *)malloc(last + 5 * quoted + 3);
  if ( !result )
    outofmem("../../../WWW/Library/Implementation/HTString.c", "HTQuoteParameter");
  n = 0;
  if ( quoted )
  {
    *result = 39;
    n = 1;
  }
  for ( ia = 0; ia < last; ++ia )
  {
    if ( parameter[ia] == 39 )
    {
      result[n] = 39;
      na = n + 1;
      result[na++] = 34;
      result[na++] = parameter[ia];
      result[na] = 34;
      n = na + 1;
      result[n] = 39;
    }
    else
    {
      result[n] = parameter[ia];
    }
    ++n;
  }
  if ( quoted )
    result[n++] = 39;
  result[n] = 0;
  return result;
}

//----- (081291E4) --------------------------------------------------------
int __cdecl HTCountCommandArgs(const char *command)
{
  int number; // [esp+Ch] [ebp-4h]

  number = 0;
  while ( *command )
  {
    if ( *command == 37 && command[1] == 115 )
      ++number;
    ++command;
  }
  return number;
}

//----- (08129221) --------------------------------------------------------
const char *__cdecl HTAfterCommandArg(const char *command, int number)
{
  while ( number > 0 && *command )
  {
    if ( *command == 37 && command[1] == 115 )
    {
      --number;
      ++command;
    }
    ++command;
  }
  return command;
}

//----- (0812925E) --------------------------------------------------------
void __cdecl HTAddXpand(char **result, const char *command, int number, const char *parameter)
{
  char *v4; // ebx
  FILE *v5; // eax
  size_t v6; // [esp+10h] [ebp-18h]
  const char *next; // [esp+1Ch] [ebp-Ch]
  const char *last; // [esp+20h] [ebp-8h]

  if ( number > 0 )
  {
    last = HTAfterCommandArg(command, number - 1);
    next = last;
    if ( number <= 1 && *result )
    {
      free(*result);
      *result = 0;
    }
    while ( *next )
    {
      if ( *next == 37 && next[1] == 115 )
      {
        if ( next != last )
        {
          if ( *result )
            v6 = strlen(*result);
          else
            v6 = 0;
          HTSACat(result, last);
          (*result)[v6 + next - last] = 0;
        }
        HTSACat(result, parameter);
        if ( WWW_TraceFlag[0] )
        {
          v4 = *result;
          v5 = TraceFP();
          fprintf(v5, "PARAM-EXP:%s\n", v4);
        }
        return;
      }
      ++next;
    }
  }
}

//----- (08129394) --------------------------------------------------------
void __cdecl HTAddToCmd(char **result, const char *command, int number, const char *string)
{
  char *v4; // ebx
  FILE *v5; // eax
  size_t v6; // [esp+10h] [ebp-18h]
  const char *next; // [esp+1Ch] [ebp-Ch]
  const char *last; // [esp+20h] [ebp-8h]

  if ( number > 0 )
  {
    last = HTAfterCommandArg(command, number - 1);
    next = last;
    if ( number <= 1 && *result )
    {
      free(*result);
      *result = 0;
    }
    if ( !string )
      string = (const char *)&unk_818BB68;
    while ( *next )
    {
      if ( *next == 37 && next[1] == 115 )
      {
        if ( next != last )
        {
          if ( *result )
            v6 = strlen(*result);
          else
            v6 = 0;
          HTSACat(result, last);
          (*result)[v6 + next - last] = 0;
        }
        HTSACat(result, string);
        if ( WWW_TraceFlag[0] )
        {
          v4 = *result;
          v5 = TraceFP();
          fprintf(v5, "PARAM-ADD:%s\n", v4);
        }
        return;
      }
      ++next;
    }
  }
}

//----- (081294D3) --------------------------------------------------------
void __cdecl HTAddParam(char **result, const char *command, int number, const char *parameter)
{
  char *quoted; // [esp+24h] [ebp-4h]

  if ( number > 0 )
  {
    quoted = HTQuoteParameter(parameter);
    HTAddToCmd(result, command, number, quoted);
    if ( quoted )
      free(quoted);
  }
}

//----- (08129527) --------------------------------------------------------
void __cdecl HTEndParam(char **result, const char *command, int number)
{
  char *v3; // ebx
  FILE *v4; // eax
  int count; // [esp+1Ch] [ebp-Ch]
  const char *last; // [esp+20h] [ebp-8h]

  count = HTCountCommandArgs(command);
  if ( count < number )
    number = count;
  last = HTAfterCommandArg(command, number);
  if ( *last )
    HTSACat(result, last);
  if ( WWW_TraceFlag[0] )
  {
    v3 = *result;
    v4 = TraceFP();
    fprintf(v4, "PARAM-END:%s\n", v3);
  }
}

//----- (081295AC) --------------------------------------------------------
void __cdecl HTSABCopy(bstring **dest, const char *src, int len)
{
  FILE *v3; // edx
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  int v8; // [esp+14h] [ebp-14h]
  bstring *t; // [esp+24h] [ebp-4h]

  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x10) != 0 )
  {
    v3 = TraceFP();
    fprintf(v3, "HTSABCopy(%p, %p, %d)\n", dest, src, len);
  }
  HTSABFree(dest);
  if ( src )
  {
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x10) != 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "===    %4d:", len);
      }
      trace_bstring2(src, len);
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "\n");
      }
    }
    t = (bstring *)malloc(8u);
    if ( !t )
      outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSABCopy");
    t->str = (char *)malloc(len + 1);
    if ( !t->str )
      outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSABCopy");
    memcpy(t->str, src, len);
    t->len = len;
    t->str[t->len] = 0;
    *dest = t;
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x10) != 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( *dest )
        v8 = (*dest)->len;
      else
        v8 = 0;
      v6 = TraceFP();
      fprintf(v6, "=>     %4d:", v8);
    }
    trace_bstring(*dest);
    if ( WWW_TraceFlag[0] )
    {
      v7 = TraceFP();
      fprintf(v7, "\n");
    }
  }
}

//----- (081297B0) --------------------------------------------------------
void __cdecl HTSABCopy0(bstring **dest, const char *src)
{
  int v2; // [esp+8h] [ebp-10h]

  v2 = strlen(src);
  HTSABCopy(dest, src, v2);
}

//----- (081297D9) --------------------------------------------------------
void __cdecl HTSABCat(bstring **dest, const char *src, int len)
{
  FILE *v3; // edx
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  int v8; // [esp+14h] [ebp-14h]
  unsigned int need; // [esp+20h] [ebp-8h]
  bstring *t; // [esp+24h] [ebp-4h]

  t = *dest;
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x10) != 0 )
  {
    v3 = TraceFP();
    fprintf(v3, "HTSABCat(%p, %p, %d)\n", dest, src, len);
  }
  if ( src )
  {
    need = len + 1;
    if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x10) != 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "===    %4d:", len);
      }
      trace_bstring2(src, len);
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "\n");
      }
    }
    if ( t )
    {
      t->str = (char *)realloc(t->str, need + t->len);
      if ( !t->str )
        outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACat");
    }
    else
    {
      t = (bstring *)calloc(1u, 8u);
      if ( !t )
        outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACat");
      t->str = (char *)malloc(need);
    }
    if ( !t->str )
      outofmem("../../../WWW/Library/Implementation/HTString.c", "HTSACat");
    memcpy(&t->str[t->len], src, len);
    t->len += len;
    t->str[t->len] = 0;
    *dest = t;
  }
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 0x10) != 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( *dest )
        v8 = (*dest)->len;
      else
        v8 = 0;
      v6 = TraceFP();
      fprintf(v6, "=>     %4d:", v8);
    }
    trace_bstring(*dest);
    if ( WWW_TraceFlag[0] )
    {
      v7 = TraceFP();
      fprintf(v7, "\n");
    }
  }
}

//----- (08129A3E) --------------------------------------------------------
void __cdecl HTSABCat0(bstring **dest, const char *src)
{
  int v2; // [esp+8h] [ebp-10h]

  v2 = strlen(src);
  HTSABCat(dest, src, v2);
}

//----- (08129A67) --------------------------------------------------------
BOOLEAN __cdecl HTSABEql(bstring *a, bstring *b)
{
  int len; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]

  if ( a )
    len = a->len;
  else
    len = 0;
  if ( b )
    v4 = b->len;
  else
    v4 = 0;
  return len == v4 && (!len || !memcmp(a->str, b->str, a->len));
}

//----- (08129AED) --------------------------------------------------------
void __cdecl HTSABFree(bstring **ptr)
{
  if ( *ptr )
  {
    if ( (*ptr)->str )
    {
      free((*ptr)->str);
      (*ptr)->str = 0;
    }
    if ( *ptr )
    {
      free(*ptr);
      *ptr = 0;
    }
    *ptr = 0;
  }
}

//----- (08129B4B) --------------------------------------------------------
bstring *HTBprintf(bstring **pstr, const char *fmt, ...)
{
  int v3; // [esp+8h] [ebp-20h]
  va_list ap; // [esp+1Ch] [ebp-Ch] BYREF
  char *temp; // [esp+20h] [ebp-8h] BYREF
  bstring *result; // [esp+24h] [ebp-4h]
  va_list va; // [esp+38h] [ebp+10h] BYREF

  va_start(va, fmt);
  result = 0;
  temp = 0;
  va_copy(ap, va);
  temp = StrAllocVsprintf(&temp, 0, fmt, &ap);
  if ( temp && *temp )
  {
    v3 = strlen(temp);
    HTSABCat(pstr, temp, v3);
  }
  if ( temp )
  {
    free(temp);
    temp = 0;
  }
  return *pstr;
}

//----- (08129BE1) --------------------------------------------------------
void __cdecl trace_bstring2(const char *text, int size)
{
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // edx
  FILE *v7; // [esp+4h] [ebp-24h]
  int ch_0; // [esp+20h] [ebp-8h]
  int n; // [esp+24h] [ebp-4h]

  if ( text )
  {
    for ( n = 0; ; ++n )
    {
      if ( n >= size )
        return;
      ch_0 = (unsigned __int8)text[n];
      if ( ch_0 == 12 )
      {
        v5 = TraceFP();
        fwrite("\\f", 1u, 2u, v5);
      }
      else
      {
        if ( (unsigned __int8)text[n] > 0xCu )
        {
          if ( ch_0 == 13 )
          {
            v3 = TraceFP();
            fwrite("\\r", 1u, 2u, v3);
            continue;
          }
          if ( ch_0 == 92 )
          {
            v2 = TraceFP();
            fwrite("\\\\", 1u, 2u, v2);
            continue;
          }
        }
        else if ( ch_0 == 9 )
        {
          v4 = TraceFP();
          fwrite("\\t", 1u, 2u, v4);
          continue;
        }
        if ( ((*__ctype_b_loc())[ch_0] & 0x4000) != 0 || ((*__ctype_b_loc())[ch_0] & 0x2000) != 0 )
        {
          v7 = TraceFP();
          fputc(ch_0, v7);
        }
        else
        {
          v6 = TraceFP();
          fprintf(v6, "\\%03o", ch_0);
        }
      }
    }
  }
}

//----- (08129D64) --------------------------------------------------------
void __cdecl trace_bstring(bstring *data)
{
  int size; // [esp+10h] [ebp-8h]
  const char *text; // [esp+14h] [ebp-4h]

  if ( data )
    size = data->len;
  else
    size = 0;
  if ( data )
    text = data->str;
  else
    text = 0;
  trace_bstring2(text, size);
}

//----- (08129DB0) --------------------------------------------------------
int __cdecl HTAddRule(HTRuleOp op, const char *pattern, const char *equiv, const char *cond_op, const char *cond)
{
  FILE *v5; // edx
  FILE *v6; // edx
  FILE *v7; // eax
  FILE *v8; // eax
  const char *v10; // [esp+20h] [ebp-18h]
  char *pEquiv; // [esp+28h] [ebp-10h] BYREF
  char *pPattern; // [esp+2Ch] [ebp-Ch] BYREF
  rule *temp; // [esp+30h] [ebp-8h]

  pPattern = 0;
  temp = (rule *)calloc(1u, 0x18u);
  if ( !temp )
    outofmem("../../../WWW/Library/Implementation/HTRules.c", "HTAddRule");
  if ( equiv )
  {
    pEquiv = 0;
    HTSACopy(&pEquiv, equiv);
    temp->equiv = pEquiv;
  }
  else
  {
    temp->equiv = 0;
  }
  if ( cond_op )
  {
    HTSACopy(&temp->condition_op, cond_op);
    HTSACopy(&temp->condition, cond);
  }
  HTSACopy(&pPattern, pattern);
  temp->pattern = pPattern;
  temp->op = op;
  if ( equiv )
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "Rule: For `%s' op %d `%s'", pattern, op, equiv);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v6 = TraceFP();
    fprintf(v6, "Rule: For `%s' op %d", pattern, op);
  }
  if ( cond_op )
  {
    if ( WWW_TraceFlag[0] )
    {
      if ( cond )
        v10 = cond;
      else
        v10 = "(null)";
      v7 = TraceFP();
      fprintf(v7, "\t%s %s\n", cond_op, v10);
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v8 = TraceFP();
    fprintf(v8, "\n");
  }
  temp->next = 0;
  if ( rule_tail )
    rule_tail->next = temp;
  else
    rules = temp;
  rule_tail = temp;
  return 0;
}

//----- (08129F93) --------------------------------------------------------
void HTClearRules()
{
  rule *temp; // [esp+14h] [ebp-4h]

  while ( rules )
  {
    temp = rules;
    rules = rules->next;
    if ( temp->pattern )
    {
      free(temp->pattern);
      temp->pattern = 0;
    }
    if ( temp->equiv )
    {
      free(temp->equiv);
      temp->equiv = 0;
    }
    if ( temp->condition_op )
    {
      free(temp->condition_op);
      temp->condition_op = 0;
    }
    if ( temp->condition )
    {
      free(temp->condition);
      temp->condition = 0;
    }
    if ( temp )
      free(temp);
  }
  rule_tail = 0;
}

//----- (0812A069) --------------------------------------------------------
BOOLEAN __cdecl rule_cond_ok(rule *r)
{
  char *condition_op; // ebx
  FILE *v2; // eax
  char *v3; // ebx
  FILE *v4; // eax
  char *condition; // [esp+20h] [ebp-18h]
  BOOLEAN result; // [esp+33h] [ebp-5h]

  if ( !r->condition_op )
    return 1;
  if ( strcmp(r->condition_op, "if") && strcmp(r->condition_op, "unless") )
  {
    if ( WWW_TraceFlag[0] )
    {
      condition_op = r->condition_op;
      v2 = TraceFP();
      fprintf(v2, "....... rule ignored, unrecognized `%s'!\n", condition_op);
    }
    return 0;
  }
  if ( !strcmp(r->condition, "redirected") )
  {
    result = redirection_attempts > 0;
    goto LABEL_18;
  }
  if ( !strcmp(r->condition, "userspec") )
  {
    result = LYUserSpecifiedURL;
LABEL_18:
    if ( !strcmp(r->condition_op, "if") )
      return result;
    else
      return result == 0;
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( r->condition )
      condition = r->condition;
    else
      condition = "(null)";
    v3 = r->condition_op;
    v4 = TraceFP();
    fprintf(v4, "....... rule ignored, unrecognized `%s %s'!\n", v3, condition);
  }
  return 0;
}

//----- (0812A1C5) --------------------------------------------------------
char *__cdecl HTTranslate(const char *required)
{
  size_t v1; // ebx
  char *v2; // ebx
  FILE *v3; // eax
  FILE *v4; // eax
  char *v5; // ebx
  FILE *v6; // eax
  char *equiv; // ebx
  char *v8; // esi
  FILE *v9; // eax
  char *v10; // ebx
  char *v11; // esi
  FILE *v12; // eax
  char *v13; // ebx
  char *v14; // esi
  FILE *v15; // eax
  char *v16; // ebx
  FILE *v17; // eax
  char *v18; // ebx
  FILE *v19; // eax
  char *v20; // ebx
  FILE *v21; // eax
  char *v22; // ebx
  FILE *v23; // eax
  char *v24; // ebx
  FILE *v25; // eax
  FILE *v26; // eax
  char *v27; // ebx
  FILE *v28; // eax
  char *v30; // [esp+24h] [ebp-74h]
  const char *v31; // [esp+28h] [ebp-70h]
  const char *v32; // [esp+2Ch] [ebp-6Ch]
  const char *Msg2; // [esp+34h] [ebp-64h]
  char *v34; // [esp+38h] [ebp-60h]
  const char *v35; // [esp+3Ch] [ebp-5Ch]
  HTRuleOp op; // [esp+40h] [ebp-58h]
  char *v38; // [esp+48h] [ebp-50h]
  char *v39; // [esp+4Ch] [ebp-4Ch]
  char *temp; // [esp+58h] [ebp-40h] BYREF
  char *ins; // [esp+5Ch] [ebp-3Ch]
  char *prot_file; // [esp+60h] [ebp-38h]
  char *eff_ids; // [esp+64h] [ebp-34h]
  char *local_copy; // [esp+68h] [ebp-30h] BYREF
  const char *q; // [esp+6Ch] [ebp-2Ch]
  int m; // [esp+70h] [ebp-28h]
  char *p; // [esp+74h] [ebp-24h]
  int permitredir_flag; // [esp+78h] [ebp-20h]
  int proxy_none_flag; // [esp+7Ch] [ebp-1Ch]
  const char *pMsg; // [esp+80h] [ebp-18h]
  char *msgtmp; // [esp+84h] [ebp-14h] BYREF
  char *current; // [esp+88h] [ebp-10h] BYREF
  rule *r; // [esp+8Ch] [ebp-Ch]

  current = 0;
  msgtmp = 0;
  proxy_none_flag = 0;
  permitredir_flag = 0;
  HTSACopy(&current, required);
  HTAA_clearProtections();
  r = rules;
  while ( 2 )
  {
    if ( !r )
    {
      if ( !proxy_none_flag )
        return current;
      temp = 0;
      HTSACopy(&temp, "NoProxy=");
      HTSACat(&temp, current);
      if ( current )
      {
        free(current);
        current = 0;
      }
      return temp;
    }
    p = r->pattern;
    m = 0;
    for ( q = current; *p && *q && *p == *q; ++q )
      ++p;
    if ( *p == 42 )
    {
      v1 = strlen(q);
      m = v1 - strlen(p + 1);
      if ( m < 0 || strcmp(&q[m], p + 1) )
        goto LABEL_123;
    }
    else if ( *p != *q )
    {
      goto LABEL_123;
    }
    if ( !rule_cond_ok(r) )
      goto LABEL_123;
    switch ( r->op )
    {
      case HT_Invalid:
      case HT_Fail:
        if ( WWW_TraceFlag[0] )
        {
          v27 = current;
          v28 = TraceFP();
          fprintf(v28, "HTRule: *** FAIL `%s'\n", v27);
        }
        if ( current )
        {
          free(current);
          current = 0;
        }
        return 0;
      case HT_Map:
      case HT_Redirect:
      case HT_RedirectPerm:
        goto LABEL_68;
      case HT_Pass:
        if ( !r->equiv )
        {
          if ( proxy_none_flag )
          {
            temp = 0;
            HTSACopy(&temp, "NoProxy=");
            HTSACat(&temp, current);
            if ( current )
            {
              free(current);
              current = 0;
            }
            current = temp;
          }
          if ( WWW_TraceFlag[0] )
          {
            v5 = current;
            v6 = TraceFP();
            fprintf(v6, "HTRule: Pass `%s'\n", v5);
          }
          return current;
        }
LABEL_68:
        if ( *p == *q )
        {
          if ( WWW_TraceFlag[0] )
          {
            equiv = r->equiv;
            v8 = current;
            v9 = TraceFP();
            fprintf(v9, "For `%s' using `%s'\n", v8, equiv);
          }
          HTSACopy(&current, r->equiv);
        }
        else
        {
          ins = strchr(r->equiv, 42);
          if ( ins )
          {
            temp = 0;
            HTSprintf0(&temp, "%.*s%.*s%s", ins - r->equiv, r->equiv, m, q, ins + 1);
            if ( WWW_TraceFlag[0] )
            {
              v10 = temp;
              v11 = current;
              v12 = TraceFP();
              fprintf(v12, "For `%s' using `%s'\n", v11, v10);
            }
            if ( current )
            {
              free(current);
              current = 0;
            }
            current = temp;
          }
          else
          {
            temp = 0;
            HTSACopy(&temp, r->equiv);
            if ( WWW_TraceFlag[0] )
            {
              v13 = temp;
              v14 = current;
              v15 = TraceFP();
              fprintf(v15, "For `%s' using `%s'\n", v14, v13);
            }
            if ( current )
            {
              free(current);
              current = 0;
            }
            current = temp;
          }
        }
        switch ( r->op )
        {
          case HT_Pass:
            if ( proxy_none_flag )
            {
              temp = 0;
              HTSACopy(&temp, "NoProxy=");
              HTSACat(&temp, current);
              if ( current )
              {
                free(current);
                current = 0;
              }
              current = temp;
            }
            if ( WWW_TraceFlag[0] )
            {
              v16 = current;
              v17 = TraceFP();
              fprintf(v17, "HTRule: ...and pass `%s'\n", v16);
            }
            return current;
          case HT_Redirect:
            if ( WWW_TraceFlag[0] )
            {
              v18 = current;
              v19 = TraceFP();
              fprintf(v19, "HTRule: ...and redirect to `%s'\n", v18);
            }
            redirecting_url = current;
            HTPermitRedir = permitredir_flag == 1;
            return 0;
          case HT_RedirectPerm:
            if ( WWW_TraceFlag[0] )
            {
              v20 = current;
              v21 = TraceFP();
              fprintf(v21, "HTRule: ...and redirect like 301 to `%s'\n", v20);
            }
            redirecting_url = current;
            permanent_redirection = 1;
            HTPermitRedir = permitredir_flag == 1;
            return 0;
        }
        goto LABEL_123;
      case HT_DefProt:
      case HT_Protect:
        local_copy = 0;
        eff_ids = 0;
        prot_file = 0;
        if ( WWW_TraceFlag[0] )
        {
          if ( r->equiv )
          {
            v30 = r->equiv;
          }
          else
          {
            if ( r->op == HT_Protect )
              v31 = "DEFAULT";
            else
              v31 = "NULL!!";
            v30 = (char *)v31;
          }
          if ( r->op == HT_Protect )
            v32 = "Protect";
          else
            v32 = "DefProt";
          v2 = current;
          v3 = TraceFP();
          fprintf(v3, "HTRule: `%s' matched %s %s: `%s'\n", v2, v32, "rule, setup", v30);
        }
        if ( r->equiv )
        {
          HTSACopy(&local_copy, r->equiv);
          temp = local_copy;
          prot_file = HTNextField(&temp);
          eff_ids = HTNextField(&temp);
        }
        if ( r->op == HT_Protect )
          HTAA_setCurrentProtection(current, prot_file, eff_ids);
        else
          HTAA_setDefaultProtection(current, prot_file, eff_ids);
        if ( local_copy )
        {
          free(local_copy);
          local_copy = 0;
        }
        goto LABEL_123;
      case HT_Progress:
      case HT_InfoMsg:
      case HT_Alert:
        LYFixCursesOn("show rule message:");
        goto LABEL_37;
      case HT_UserMsg:
        LYFixCursesOn("show rule message:");
        if ( r->equiv )
          Msg2 = r->equiv;
        else
          Msg2 = "Rule: %s";
        HTUserMsg2(Msg2, current);
        goto LABEL_123;
      case HT_AlwaysAlert:
LABEL_37:
        if ( r->equiv )
        {
          v34 = r->equiv;
        }
        else
        {
          if ( r->op == HT_AlwaysAlert )
            v35 = "%s";
          else
            v35 = "Rule: %s";
          v34 = (char *)v35;
        }
        pMsg = v34;
        if ( strchr(v34, 37) )
        {
          HTSprintf0(&msgtmp, pMsg, current);
          pMsg = msgtmp;
        }
        op = r->op;
        if ( op == HT_InfoMsg )
        {
          HTInfoMsg(pMsg);
        }
        else if ( (unsigned int)op > HT_InfoMsg )
        {
          if ( op == HT_Alert )
          {
            HTAlert(pMsg);
          }
          else if ( op == HT_AlwaysAlert )
          {
            HTAlwaysAlert("Rule alert:", pMsg);
          }
        }
        else if ( op == HT_Progress )
        {
          HTProgress(pMsg);
        }
        if ( msgtmp )
        {
          free(msgtmp);
          msgtmp = 0;
        }
        goto LABEL_123;
      case HT_PermitRedir:
        permitredir_flag = 1;
        if ( WWW_TraceFlag[0] )
        {
          v4 = TraceFP();
          fprintf(v4, "HTRule: Mark for redirection permitted\n");
        }
        goto LABEL_123;
      case HT_UseProxy:
        if ( r->equiv && !strcasecomp(r->equiv, "none") )
        {
          if ( WWW_TraceFlag[0] )
          {
            v22 = current;
            v23 = TraceFP();
            fprintf(v23, "For `%s' will not use proxy\n", v22);
          }
          proxy_none_flag = 1;
          goto LABEL_123;
        }
        if ( proxy_none_flag )
        {
          if ( WWW_TraceFlag[0] )
          {
            if ( r->equiv )
              v38 = r->equiv;
            else
              v38 = "(null)";
            v24 = current;
            v25 = TraceFP();
            fprintf(v25, "For `%s' proxy server ignored: %s\n", v24, v38);
          }
LABEL_123:
          r = r->next;
          continue;
        }
        temp = 0;
        HTSACopy(&temp, "Proxied=");
        HTSACat(&temp, r->equiv);
        HTSACat(&temp, current);
        if ( WWW_TraceFlag[0] )
        {
          if ( r->equiv )
            v39 = r->equiv;
          else
            v39 = "(null)";
          v26 = TraceFP();
          fprintf(v26, "HTRule: proxy server found: %s\n", v39);
        }
        if ( current )
        {
          free(current);
          current = 0;
        }
        return temp;
      default:
        goto LABEL_123;
    }
  }
}

//----- (0812AB3D) --------------------------------------------------------
int __cdecl HTSetConfiguration(char *config)
{
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  FILE *v4; // eax
  char *v5; // edx
  int v6; // eax
  int v7; // eax
  double v10; // [esp+38h] [ebp-C0h]
  int v11; // [esp+44h] [ebp-B4h]
  double v12; // [esp+48h] [ebp-B0h]
  double v13; // [esp+50h] [ebp-A8h]
  HTRuleOp v14; // [esp+64h] [ebp-94h]
  int v15; // [esp+68h] [ebp-90h]
  int v16; // [esp+6Ch] [ebp-8Ch]
  int v17; // [esp+70h] [ebp-88h]
  int v18; // [esp+74h] [ebp-84h]
  int v19; // [esp+78h] [ebp-80h]
  int v20; // [esp+7Ch] [ebp-7Ch]
  int v21; // [esp+80h] [ebp-78h]
  int v22; // [esp+84h] [ebp-74h]
  int v23; // [esp+88h] [ebp-70h]
  int v24; // [esp+8Ch] [ebp-6Ch]
  int v25; // [esp+90h] [ebp-68h]
  int v26; // [esp+94h] [ebp-64h]
  int v27; // [esp+98h] [ebp-60h]
  int v28; // [esp+9Ch] [ebp-5Ch]
  off_t maxbytes; // [esp+A0h] [ebp-58h] BYREF
  char *cp2; // [esp+ACh] [ebp-4Ch]
  char *cp1; // [esp+B0h] [ebp-48h]
  const char *cp; // [esp+B4h] [ebp-44h]
  char *encoding; // [esp+B8h] [ebp-40h]
  char *p; // [esp+BCh] [ebp-3Ch]
  int status; // [esp+C0h] [ebp-38h]
  float secs_per_byte; // [esp+C4h] [ebp-34h] BYREF
  float secs; // [esp+C8h] [ebp-30h] BYREF
  float quality; // [esp+CCh] [ebp-2Ch] BYREF
  const char *cond; // [esp+D0h] [ebp-28h]
  const char *cond_op; // [esp+D4h] [ebp-24h]
  const char *word3; // [esp+D8h] [ebp-20h]
  const char *word2; // [esp+DCh] [ebp-1Ch]
  char *word1; // [esp+E0h] [ebp-18h]
  char *pointer; // [esp+E4h] [ebp-14h] BYREF
  char *line; // [esp+E8h] [ebp-10h] BYREF
  HTRuleOp op; // [esp+ECh] [ebp-Ch]

  line = 0;
  pointer = 0;
  cond_op = 0;
  cond = 0;
  HTSACopy(&line, config);
  p = strchr(line, 35);
  if ( p )
    *p = 0;
  pointer = line;
  word1 = HTNextField(&pointer);
  if ( !word1 )
  {
    if ( line )
    {
      free(line);
      line = 0;
    }
    return 0;
  }
  word2 = HTNextField(&pointer);
  if ( strcasecomp(word1, "defprot") && strcasecomp(word1, "protect") )
    word3 = HTNextField(&pointer);
  else
    word3 = pointer;
  if ( !word2 )
  {
    v1 = line;
    v2 = gettext("Insufficient operands:");
    fprintf(stderr, "HTRule: %s %s\n", v2, v1);
    if ( line )
    {
      free(line);
      line = 0;
    }
    return -2;
  }
  if ( !strcasecomp(word1, "suffix") )
  {
    encoding = HTNextField(&pointer);
    if ( pointer )
      status = sscanf(pointer, "%f", &quality);
    else
      status = 0;
    if ( status <= 0 )
      v10 = 1.0;
    else
      v10 = quality;
    if ( encoding )
      HTSetSuffix5(word2, word3, encoding, 0, v10);
    else
      HTSetSuffix5(word2, word3, "binary", 0, v10);
    goto LABEL_159;
  }
  if ( !strcasecomp(word1, "presentation") )
  {
    if ( pointer )
      status = sscanf(pointer, "%f%f%f%lld", &quality, &secs, &secs_per_byte, &maxbytes);
    else
      status = 0;
    if ( status <= 3 )
      v11 = 0;
    else
      v11 = maxbytes;
    if ( status <= 2 )
      v12 = 0.0;
    else
      v12 = secs_per_byte;
    if ( status <= 1 )
      v13 = 0.0;
    else
      v13 = secs;
    if ( status <= 0 )
      HTSetPresentation(word2, word3, 0, 1.0, v13, v12, v11, mediaCFG_0);
    else
      HTSetPresentation(word2, word3, 0, quality, v13, v12, v11, mediaCFG_0);
    goto LABEL_159;
  }
  if ( !strncasecomp(word1, "htbin", 5) || !strncasecomp(word1, "bindir", 6) )
  {
    HTSACopy(&HTBinDir, word2);
LABEL_159:
    if ( line )
    {
      free(line);
      line = 0;
    }
    return 0;
  }
  if ( !strncasecomp(word1, "search", 6) )
  {
    HTSACopy(&HTSearchScript, word2);
    goto LABEL_159;
  }
  if ( strcasecomp(word1, "map") )
  {
    if ( strcasecomp(word1, "pass") )
    {
      if ( strcasecomp(word1, "fail") )
      {
        if ( strcasecomp(word1, "redirect") )
        {
          if ( strncasecomp(word1, "redirectperm", 12) )
          {
            if ( strcasecomp(word1, "redirecttemp") )
            {
              if ( strcasecomp(word1, "permitredirection") )
              {
                if ( strcasecomp(word1, "useproxy") )
                {
                  if ( strcasecomp(word1, "alert") )
                  {
                    if ( strcasecomp(word1, "alwaysalert") )
                    {
                      if ( strcasecomp(word1, "progress") )
                      {
                        if ( strcasecomp(word1, "usermsg") )
                        {
                          if ( strcasecomp(word1, "infomsg") )
                          {
                            if ( strcasecomp(word1, "defprot") )
                            {
                              if ( strcasecomp(word1, "protect") )
                                v28 = 0;
                              else
                                v28 = 5;
                              v27 = v28;
                            }
                            else
                            {
                              v27 = 4;
                            }
                            v26 = v27;
                          }
                          else
                          {
                            v26 = 7;
                          }
                          v25 = v26;
                        }
                        else
                        {
                          v25 = 8;
                        }
                        v24 = v25;
                      }
                      else
                      {
                        v24 = 6;
                      }
                      v23 = v24;
                    }
                    else
                    {
                      v23 = 10;
                    }
                    v22 = v23;
                  }
                  else
                  {
                    v22 = 9;
                  }
                  v21 = v22;
                }
                else
                {
                  v21 = 14;
                }
                v20 = v21;
              }
              else
              {
                v20 = 13;
              }
              v19 = v20;
            }
            else
            {
              v19 = 11;
            }
            v18 = v19;
          }
          else
          {
            v18 = 12;
          }
          v17 = v18;
        }
        else
        {
          v17 = 11;
        }
        v16 = v17;
      }
      else
      {
        v16 = 3;
      }
      v15 = v16;
    }
    else
    {
      v15 = 2;
    }
    v14 = v15;
  }
  else
  {
    v14 = HT_Map;
  }
  op = v14;
  if ( v14 == HT_Invalid )
  {
    v3 = gettext("Bad rule");
    fprintf(stderr, "HTRule: %s '%s'\n", v3, config);
    goto LABEL_159;
  }
  switch ( op )
  {
    case HT_Map:
    case HT_Redirect:
    case HT_RedirectPerm:
    case HT_UseProxy:
      goto LABEL_101;
    case HT_Pass:
      if ( !word3 || strcasecomp(word3, "if") && strcasecomp(word3, "unless") )
      {
LABEL_101:
        cond_op = HTNextField(&pointer);
        if ( op == HT_Redirect
          && !strcasecomp(word1, "redirect")
          && cond_op
          && strcasecomp(cond_op, "if")
          && strcasecomp(cond_op, "unless") )
        {
          if ( strcmp(word2, "301") && strcasecomp(word2, "permanent") )
          {
            if ( strcmp(word2, "302")
              && strcmp(word2, "303")
              && strcasecomp(word2, "temp")
              && strcasecomp(word2, "seeother")
              && WWW_TraceFlag[0] )
            {
              v4 = TraceFP();
              fprintf(v4, "Rule: Ignoring `%s' in Redirect\n", word2);
            }
          }
          else
          {
            op = HT_RedirectPerm;
          }
          word2 = word3;
          word3 = cond_op;
          cond_op = HTNextField(&pointer);
        }
        if ( cond_op && *cond_op )
          cond = HTNextField(&pointer);
      }
      else
      {
        cond_op = word3;
        word3 = 0;
        cond = HTNextField(&pointer);
      }
      goto LABEL_136;
    case HT_Fail:
    case HT_PermitRedir:
      cond_op = word3;
      if ( word3 && *cond_op )
      {
        word3 = 0;
        cond = HTNextField(&pointer);
      }
      goto LABEL_136;
    case HT_Progress:
    case HT_InfoMsg:
    case HT_UserMsg:
    case HT_Alert:
    case HT_AlwaysAlert:
      cond_op = HTNextField(&pointer);
      if ( cond_op && *cond_op )
        cond = HTNextField(&pointer);
      if ( !word3 )
        goto LABEL_136;
      cp = word3;
      break;
    default:
      goto LABEL_136;
  }
  while ( 1 )
  {
    cp1 = strchr(cp, 37);
    if ( !cp1 )
      break;
    if ( !cp1[1] )
    {
      *cp1 = 0;
      break;
    }
    if ( cp1[1] != 37 )
    {
      while ( 1 )
      {
        cp2 = strchr(cp1 + 2, 37);
        if ( !cp2 )
          goto LABEL_136;
        if ( !cp2[1] )
        {
          *cp2 = 0;
          goto LABEL_136;
        }
        if ( cp2[1] != 37 )
          *cp2 = 63;
        cp1 = cp2;
      }
    }
    cp = cp1 + 2;
  }
LABEL_136:
  if ( cond_op && cond && *cond && !strcasecomp(cond_op, "unless") )
  {
    cond_op = "unless";
    goto LABEL_151;
  }
  if ( cond_op && cond && *cond && !strcasecomp(cond_op, "if") )
  {
    cond_op = "if";
LABEL_151:
    if ( !cond || (v6 = strlen(cond), strncasecomp(cond, "redirected", v6)) )
    {
      if ( cond )
      {
        if ( strlen(cond) > 7 )
        {
          v7 = strlen(cond);
          if ( !strncasecomp(cond, "userspecified", v7) )
            cond = "userspec";
        }
      }
    }
    else
    {
      cond = "redirected";
    }
    HTAddRule(op, word2, word3, cond_op, cond);
    goto LABEL_159;
  }
  if ( !cond_op && !cond )
    goto LABEL_151;
  v5 = gettext("Bad rule");
  fprintf(stderr, "HTRule: %s '%s'\n", v5, config);
  if ( line )
  {
    free(line);
    line = 0;
  }
  return -2;
}

//----- (0812B664) --------------------------------------------------------
int __cdecl HTLoadRules(const char *filename)
{
  FILE *v1; // eax
  FILE *fp; // [esp+1Ch] [ebp-10Ch]
  char line[257]; // [esp+23h] [ebp-105h] BYREF
  unsigned int v6; // [esp+124h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  fp = (FILE *)fopen64(filename, &unk_818C0AC);
  if ( fp )
  {
    while ( fgets(line, 257, fp) )
      HTSetConfiguration(line);
    fclose(fp);
    return 0;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTRules: Can't open rules file %s\n", filename);
    }
    return -1;
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0812B744) --------------------------------------------------------
void __cdecl HTSetPresentation(
        const char *representation,
        const char *command,
        const char *testcommand,
        double quality,
        double secs,
        double secs_per_byte,
        int maxbytes,
        AcceptMedia media)
{
  FILE *v8; // eax
  const char *v9; // [esp+20h] [ebp-38h]
  const char *v10; // [esp+24h] [ebp-34h]
  const char *v11; // [esp+28h] [ebp-30h]
  float v12; // [esp+2Ch] [ebp-2Ch]
  float v13; // [esp+2Ch] [ebp-2Ch]
  float v14; // [esp+2Ch] [ebp-2Ch]
  HTPresentation *pres; // [esp+54h] [ebp-4h]

  pres = (HTPresentation *)calloc(1u, 0x30u);
  if ( !pres )
    outofmem("../../../WWW/Library/Implementation/HTFormat.c", "HTSetPresentation");
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    if ( testcommand )
      v9 = testcommand;
    else
      v9 = (const char *)&unk_818C117;
    if ( command )
      v10 = command;
    else
      v10 = (const char *)&unk_818C117;
    if ( representation )
      v11 = representation;
    else
      v11 = (const char *)&unk_818C117;
    v8 = TraceFP();
    fprintf(v8, "HTSetPresentation rep=%s, command=%s, test=%s, qual=%f\n", v11, v10, v9, quality);
  }
  pres->rep = HTAtom_for(representation);
  pres->rep_out = HTAtom_for("www/present");
  pres->converter = (HTConverter *)HTSaveAndExecute;
  v12 = quality;
  pres->quality = v12;
  v13 = secs;
  pres->secs = v13;
  v14 = secs_per_byte;
  pres->secs_per_byte = v14;
  pres->maxbytes = maxbytes;
  pres->get_accept = 0;
  pres->accept_opt = media;
  pres->command = 0;
  HTSACopy(&pres->command, command);
  pres->testcommand = 0;
  HTSACopy(&pres->testcommand, testcommand);
  if ( !HTPresentations )
    HTPresentations = HTList_new();
  if ( !strcmp(representation, "*") )
  {
    if ( default_presentation )
    {
      free(default_presentation);
      default_presentation = 0;
    }
    default_presentation = pres;
  }
  else
  {
    HTList_addObject(HTPresentations, pres);
  }
}

//----- (0812B94F) --------------------------------------------------------
void __cdecl HTSetConversion(
        const char *representation_in,
        const char *representation_out,
        HTConverter *converter,
        float quality,
        float secs,
        float secs_per_byte,
        int maxbytes,
        AcceptMedia media)
{
  FILE *v8; // eax
  const char *v9; // [esp+20h] [ebp-18h]
  const char *v10; // [esp+24h] [ebp-14h]
  HTPresentation *pres; // [esp+34h] [ebp-4h]

  pres = (HTPresentation *)calloc(1u, 0x30u);
  if ( !pres )
    outofmem("../../../WWW/Library/Implementation/HTFormat.c", "HTSetConversion");
  if ( WWW_TraceFlag[0] && (WWW_TraceMask & 8) != 0 )
  {
    if ( representation_out )
      v9 = representation_out;
    else
      v9 = (const char *)&unk_818C117;
    if ( representation_in )
      v10 = representation_in;
    else
      v10 = (const char *)&unk_818C117;
    v8 = TraceFP();
    fprintf(v8, "HTSetConversion rep_in=%s, rep_out=%s, qual=%f\n", v10, v9, quality);
  }
  pres->rep = HTAtom_for(representation_in);
  pres->rep_out = HTAtom_for(representation_out);
  pres->converter = converter;
  pres->command = 0;
  pres->testcommand = 0;
  pres->quality = quality;
  pres->secs = secs;
  pres->secs_per_byte = secs_per_byte;
  pres->maxbytes = maxbytes;
  pres->get_accept = 1;
  pres->accept_opt = media;
  if ( !HTPresentations )
    HTPresentations = HTList_new();
  HTList_addObject(HTPresentations, pres);
}

//----- (0812BAA1) --------------------------------------------------------
void __cdecl HTInitInput(int file_number)
{
  input_file_number = file_number;
  input_limit = input_buffer;
  input_pointer = input_buffer;
}

//----- (0812BAC2) --------------------------------------------------------
int HTGetCharacter()
{
  FILE *v0; // eax
  FILE *v1; // eax
  int status; // [esp+20h] [ebp-8h]
  unsigned __int8 ch_0; // [esp+27h] [ebp-1h]

  interrupted_in_htgetcharacter = 0;
  while ( input_pointer < input_limit )
  {
LABEL_14:
    ch_0 = *input_pointer++;
    if ( ch_0 != 13 )
      return ch_0;
  }
  status = HTDoRead(input_file_number, input_buffer, 0x1000u);
  if ( status > 0 )
  {
    input_pointer = input_buffer;
    input_limit = (char *)(status + 136019904);
    goto LABEL_14;
  }
  if ( !status )
    return -1;
  if ( status == -29998 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v0 = TraceFP();
      fprintf(v0, "HTFormat: Interrupted in HTGetCharacter\n");
    }
    interrupted_in_htgetcharacter = 1;
    return -1;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTFormat: File read error %d\n", status);
    }
    return -1;
  }
}

//----- (0812BBD4) --------------------------------------------------------
int __cdecl half_match(char *trial_type, char *target)
{
  FILE *v2; // edx
  char *cp; // [esp+24h] [ebp-4h]

  cp = strchr(trial_type, 47);
  if ( !cp || cp[1] != 42 )
    return 0;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "HTFormat: comparing %s and %s for half match\n", trial_type, target);
  }
  return strncmp(trial_type, target, cp - trial_type - 1) == 0;
}

//----- (0812BC7C) --------------------------------------------------------
BOOLEAN __cdecl failsMailcap(HTPresentation *pres, HTParentAnchor *anchor)
{
  return pres->testcommand && LYTestMailcapCommand(pres->testcommand, anchor->content_type_params);
}

//----- (0812BCB8) --------------------------------------------------------
HTPresentation *__cdecl HTFindPresentation(
        HTFormat rep_in,
        HTFormat rep_out,
        HTPresentation *fill_in,
        HTParentAnchor *anchor)
{
  char *name; // ebx
  char *v5; // esi
  FILE *v6; // eax
  const char *v7; // esi
  const char *v8; // ebx
  FILE *v9; // eax
  const char *v10; // esi
  const char *v11; // ebx
  FILE *v12; // eax
  const char *v13; // esi
  const char *v14; // ebx
  FILE *v15; // eax
  const char *v16; // ebx
  FILE *v17; // eax
  HTPresentation *v20; // [esp+14h] [ebp-44h]
  HTPresentation *v21; // [esp+18h] [ebp-40h]
  HTPresentation *v22; // [esp+1Ch] [ebp-3Ch]
  HTPresentation *strong_subtype_wildcard_match; // [esp+2Ch] [ebp-2Ch]
  HTPresentation *last_default_match; // [esp+30h] [ebp-28h]
  HTPresentation *weak_wildcard_match; // [esp+34h] [ebp-24h]
  HTPresentation *strong_wildcard_match; // [esp+38h] [ebp-20h]
  HTPresentation *pres; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  int n; // [esp+48h] [ebp-10h]
  HTAtom *wildcard; // [esp+4Ch] [ebp-Ch]

  wildcard = 0;
  strong_wildcard_match = 0;
  weak_wildcard_match = 0;
  last_default_match = 0;
  strong_subtype_wildcard_match = 0;
  if ( WWW_TraceFlag[0] )
  {
    name = rep_out->name;
    v5 = rep_in->name;
    v6 = TraceFP();
    fprintf(v6, "HTFormat: Looking up presentation for %s to %s\n", v5, name);
  }
  n = HTList_count(HTPresentations);
  for ( i = 0; ; ++i )
  {
    if ( i >= n )
    {
      if ( strong_subtype_wildcard_match )
      {
        v20 = strong_subtype_wildcard_match;
      }
      else
      {
        if ( strong_wildcard_match )
        {
          v21 = strong_wildcard_match;
        }
        else
        {
          if ( weak_wildcard_match )
            v22 = weak_wildcard_match;
          else
            v22 = last_default_match;
          v21 = v22;
        }
        v20 = v21;
      }
      if ( !v20 )
        return 0;
      *fill_in = *v20;
      fill_in->rep = rep_in;
      fill_in->rep_out = rep_out;
      return fill_in;
    }
    pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
    if ( pres->rep == rep_in )
      break;
    if ( !fill_in )
      continue;
    if ( half_match(pres->rep->name, rep_in->name) && pres->rep_out == rep_out )
    {
      if ( failsMailcap(pres, anchor) )
        continue;
      if ( !strong_subtype_wildcard_match )
        strong_subtype_wildcard_match = pres;
      if ( WWW_TraceFlag[0] )
      {
        v13 = pres->rep_out->name;
        v14 = pres->rep->name;
        v15 = TraceFP();
        fprintf(v15, "StreamStack: found strong subtype wildcard match: %s -> %s\n", v14, v13);
      }
    }
LABEL_27:
    if ( pres->rep == WWW_SOURCE )
    {
      if ( pres->rep_out == rep_out )
      {
        if ( !failsMailcap(pres, anchor) )
        {
          if ( !weak_wildcard_match )
            weak_wildcard_match = pres;
          if ( WWW_TraceFlag[0] )
          {
            v16 = pres->rep_out->name;
            v17 = TraceFP();
            fprintf(v17, "StreamStack: found weak wildcard match: %s\n", v16);
          }
        }
      }
      else if ( !last_default_match )
      {
        if ( !wildcard )
          wildcard = HTAtom_for("*");
        if ( pres->rep_out == wildcard && !failsMailcap(pres, anchor) )
          last_default_match = pres;
      }
    }
LABEL_40:
    ;
  }
  if ( pres->rep_out != rep_out )
  {
    if ( !fill_in )
      goto LABEL_40;
    if ( !wildcard )
      wildcard = HTAtom_for("*");
    if ( pres->rep_out == wildcard )
    {
      if ( failsMailcap(pres, anchor) )
        goto LABEL_40;
      if ( !strong_wildcard_match )
        strong_wildcard_match = pres;
      if ( WWW_TraceFlag[0] )
      {
        v10 = pres->rep_out->name;
        v11 = pres->rep->name;
        v12 = TraceFP();
        fprintf(v12, "StreamStack: found strong wildcard match: %s -> %s\n", v11, v10);
      }
    }
    goto LABEL_27;
  }
  if ( failsMailcap(pres, anchor) )
    goto LABEL_40;
  if ( WWW_TraceFlag[0] )
  {
    v7 = pres->rep_out->name;
    v8 = pres->rep->name;
    v9 = TraceFP();
    fprintf(v9, "FindPresentation: found exact match: %s -> %s\n", v8, v7);
  }
  return pres;
}

//----- (0812C072) --------------------------------------------------------
HTStream_5 *__cdecl HTStreamStack(HTFormat rep_in, HTFormat rep_out, HTStream_5 *sink, HTParentAnchor *anchor)
{
  char *name; // esi
  char *v5; // ebx
  FILE *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  char *v9; // esi
  char *v10; // ebx
  FILE *v11; // eax
  const char *v12; // ebx
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  char *content_type_params; // [esp+1Ch] [ebp-4Ch]
  HTPresentation temp; // [esp+28h] [ebp-40h] BYREF
  HTStream_5 *result; // [esp+58h] [ebp-10h]
  HTPresentation *match; // [esp+5Ch] [ebp-Ch]

  if ( WWW_TraceFlag[0] )
  {
    if ( anchor->content_type_params )
      content_type_params = anchor->content_type_params;
    else
      content_type_params = "(null)";
    name = rep_out->name;
    v5 = rep_in->name;
    v6 = TraceFP();
    fprintf(v6, "HTFormat: Constructing stream stack for %s to %s (%s)\n", v5, name, content_type_params);
  }
  if ( rep_out == rep_in )
  {
    result = sink;
  }
  else
  {
    match = HTFindPresentation(rep_in, rep_out, &temp, anchor);
    if ( match )
    {
      if ( match == &temp )
      {
        if ( WWW_TraceFlag[0] )
        {
          v7 = temp.rep_out->name;
          v8 = TraceFP();
          fprintf(v8, "StreamStack: Using %s\n", v7);
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v9 = match->rep_out->name;
        v10 = match->rep->name;
        v11 = TraceFP();
        fprintf(v11, "StreamStack: found exact match: %s -> %s\n", v10, v9);
      }
      result = (HTStream_5 *)match->converter(match, anchor, sink);
    }
    else
    {
      result = 0;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( result && result->isa && result->isa->name )
    {
      if ( WWW_TraceFlag[0] )
      {
        v12 = result->isa->name;
        v13 = TraceFP();
        fprintf(v13, "StreamStack: Returning \"%s\"\n", v12);
      }
    }
    else if ( result )
    {
      if ( WWW_TraceFlag[0] )
      {
        v14 = TraceFP();
        fprintf(v14, "StreamStack: Returning *unknown* stream!\n");
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v15 = TraceFP();
        fprintf(v15, "StreamStack: Returning NULL!\n");
      }
      if ( WWW_TraceFlag[0] )
      {
        v16 = TraceFP();
        fflush(v16);
      }
    }
  }
  return result;
}

//----- (0812C276) --------------------------------------------------------
void __cdecl HTReorderPresentation(HTFormat rep_in, HTFormat rep_out)
{
  HTPresentation *match; // [esp+24h] [ebp-4h]

  match = HTFindPresentation(rep_in, rep_out, 0, 0);
  if ( match )
  {
    HTList_removeObject(HTPresentations, match);
    HTList_addObject(HTPresentations, match);
  }
}

//----- (0812C2D3) --------------------------------------------------------
void HTFilterPresentations()
{
  int v0; // ebx
  FILE *v1; // eax
  HTAtom *rep_out; // ebx
  FILE *v3; // eax
  char *t; // [esp+14h] [ebp-24h]
  char *s; // [esp+18h] [ebp-20h]
  HTPresentation *p; // [esp+20h] [ebp-18h]
  int n; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  BOOLEAN matched; // [esp+33h] [ebp-5h]

  n = HTList_count(HTPresentations);
  if ( WWW_TraceFlag[0] )
  {
    v0 = LYAcceptMedia;
    v1 = TraceFP();
    fprintf(v1, "HTFilterPresentations (AcceptMedia %#x)\n", v0);
  }
  for ( i = 0; i < n; ++i )
  {
    p = (HTPresentation *)HTList_objectAt(HTPresentations, i);
    s = p->rep->name;
    p->get_accept = 0;
    if ( (p->accept_opt & LYAcceptMedia) != 0 )
    {
      rep_out = p->rep_out;
      if ( rep_out == HTAtom_for("www/present")
        && p->rep != WWW_SOURCE
        && strcasecomp(s, "www/mime")
        && strcasecomp(s, "www/compressed")
        && p->quality <= 1.0
        && p->quality >= 0.0 )
      {
        matched = 1;
        for ( j = 0; j < i; ++j )
        {
          t = *(char **)(*(_DWORD *)HTList_objectAt(HTPresentations, j) + 4);
          if ( !strcasecomp(s, t) )
          {
            matched = 0;
            if ( WWW_TraceFlag[0] )
            {
              v3 = TraceFP();
              fprintf(v3, "  match %s %s\n", s, t);
            }
            break;
          }
        }
        p->get_accept = matched;
      }
    }
  }
}

//----- (0812C495) --------------------------------------------------------
float __cdecl HTStackValue(HTFormat rep_in, HTFormat rep_out, float initial_value, int length)
{
  char *name; // esi
  char *v5; // ebx
  FILE *v6; // eax
  float value; // [esp+3Ch] [ebp-1Ch]
  HTPresentation *pres; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  int n; // [esp+48h] [ebp-10h]
  HTAtom *wildcard; // [esp+4Ch] [ebp-Ch]

  wildcard = HTAtom_for("*");
  if ( WWW_TraceFlag[0] )
  {
    name = rep_out->name;
    v5 = rep_in->name;
    v6 = TraceFP();
    fprintf(v6, "HTFormat: Evaluating stream stack for %s worth %.3f to %s\n", v5, initial_value, name);
  }
  if ( rep_out == WWW_SOURCE || rep_out == rep_in )
  {
    return 0.0;
  }
  else
  {
    n = HTList_count(HTPresentations);
    for ( i = 0; ; ++i )
    {
      if ( i >= n )
        return -1.0e30;
      pres = (HTPresentation *)HTList_objectAt(HTPresentations, i);
      if ( pres->rep == rep_in && (pres->rep_out == rep_out || pres->rep_out == wildcard) )
        break;
    }
    value = pres->quality * initial_value;
    if ( HTMaxSecs > 0.0 )
      return value - ((long double)length * pres->secs_per_byte + pres->secs) / HTMaxSecs;
    return value;
  }
}

//----- (0812C5CA) --------------------------------------------------------
void HTDisplayPartial()
{
  int v0; // ebx
  int Newline_partial; // [esp+20h] [ebp-8h]

  if ( display_partial[0] )
  {
    Newline_partial = LYGetNewline();
    if ( Newline_partial + display_lines - 1 > NumOfLines_partial )
    {
      if ( partial_threshold <= 0 )
        v0 = Newline_partial + display_lines - 1;
      else
        v0 = Newline_partial + partial_threshold - 1;
      if ( v0 <= HText_getNumOfLines() )
      {
        if ( LYMainLoop_pageDisplay(Newline_partial) )
          NumOfLines_partial = HText_getNumOfLines();
      }
    }
  }
}

//----- (0812C654) --------------------------------------------------------
void HTFinishDisplayPartial()
{
  display_partial[0] = 0;
}

//----- (0812C660) --------------------------------------------------------
int __cdecl HTCopy(HTParentAnchor *anchor, int file_number, void *handle, HTStream_5 *sink)
{
  char *v4; // eax
  char *v5; // eax
  FILE *v6; // eax
  char *v7; // eax
  bool v9; // [esp+14h] [ebp-44h]
  off_t total; // [esp+18h] [ebp-40h]
  void (*targetClass_8)(HTStream *, HTError); // [esp+30h] [ebp-28h]
  void (*targetClass_20)(HTStream *, const char *, int); // [esp+3Ch] [ebp-1Ch]
  int status; // [esp+40h] [ebp-18h]
  int rv; // [esp+44h] [ebp-14h]
  int bytes; // [esp+48h] [ebp-10h]

  targetClass_8 = sink->isa->_abort;
  targetClass_20 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0LL, 0LL);
  while ( 1 )
  {
    if ( LYCancelDownload[0] )
    {
      LYCancelDownload[0] = 0;
      targetClass_8((HTStream *)sink, 0);
      rv = -1;
      goto finished;
    }
    if ( HTCheckForInterrupt() )
    {
      mustshow[0] = 1;
      v4 = gettext("Data transfer interrupted.");
      HTProgress(v4);
      targetClass_8((HTStream *)sink, 0);
      if ( bytes )
        rv = -29998;
      else
        rv = -1;
      goto finished;
    }
    status = HTDoRead(file_number, input_buffer, 0x1000u);
    if ( status <= 0 )
      break;
    v9 = anchor && anchor->content_type && !strcmp(anchor->content_type, "message/x-http-redirection");
    targetClass_20((HTStream *)sink, input_buffer, status);
    bytes += status;
    if ( !v9 )
    {
      if ( anchor )
        total = anchor->content_length;
      else
        total = 0LL;
      HTReadProgress(bytes, total);
    }
    HTDisplayPartial();
  }
  if ( !status )
  {
LABEL_36:
    mustshow[0] = 1;
    v7 = gettext("Data transfer complete");
    HTProgress(v7);
    close(file_number);
    rv = 200;
    goto finished;
  }
  if ( status == -29998 )
  {
    mustshow[0] = 1;
    v5 = gettext("Data transfer interrupted.");
    HTProgress(v5);
    targetClass_8((HTStream *)sink, 0);
    if ( bytes )
      rv = -29998;
    else
      rv = -1;
    goto finished;
  }
  if ( *__errno_location() == 107 || *__errno_location() == 104 || *__errno_location() == 32 )
  {
    if ( bytes <= 0 )
    {
      rv = -2;
      goto finished;
    }
    HTInetStatus("NETREAD");
    HTAlert("Unexpected server disconnect.");
    if ( WWW_TraceFlag[0] )
    {
      v6 = TraceFP();
      fprintf(v6, "HTCopy: Unexpected server disconnect. Treating as completed.\n");
    }
    goto LABEL_36;
  }
  HTInetStatus("NETREAD");
  HTAlert("Unexpected read error.");
  if ( bytes )
  {
    close(file_number);
    rv = 200;
  }
  else
  {
    targetClass_8((HTStream *)sink, 0);
    rv = -1;
  }
finished:
  HTFinishDisplayPartial();
  return rv;
}

//----- (0812C99A) --------------------------------------------------------
int __cdecl HTFileCopy(FILE *fp, HTStream_5 *sink)
{
  int v2; // ebx
  FILE *v3; // eax
  char *v4; // eax
  void (*targetClass_20)(HTStream *, const char *, int); // [esp+34h] [ebp-14h]
  int rv; // [esp+38h] [ebp-10h]
  int bytes; // [esp+3Ch] [ebp-Ch]
  int status; // [esp+40h] [ebp-8h]

  targetClass_20 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0LL, 0LL);
  while ( 1 )
  {
    status = fread(input_buffer, 1u, 0x1000u, fp);
    if ( !status )
      break;
    targetClass_20((HTStream *)sink, input_buffer, status);
    bytes += status;
    HTReadProgress(bytes, 0LL);
    if ( display_partial[0] && HTMainAnchor->content_length != bytes )
      HTDisplayPartial();
    if ( HTCheckForInterrupt() )
    {
      mustshow[0] = 1;
      v4 = gettext("Data transfer interrupted.");
      HTProgress(v4);
      if ( bytes )
        rv = -29998;
      else
        rv = -1;
      goto LABEL_17;
    }
  }
  if ( ferror(fp) )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = ferror(fp);
      v3 = TraceFP();
      fprintf(v3, "HTFormat: Read error, read returns %d\n", v2);
    }
    if ( bytes )
      rv = 206;
    else
      rv = -1;
  }
  else
  {
    rv = 200;
  }
LABEL_17:
  HTFinishDisplayPartial();
  return rv;
}

//----- (0812CB43) --------------------------------------------------------
int __cdecl HTMemCopy(HTChunk *chunk, HTStream_5 *sink)
{
  char *v2; // eax
  void (*targetClass_20)(HTStream *, const char *, int); // [esp+2Ch] [ebp-Ch]
  int rv; // [esp+30h] [ebp-8h]
  int bytes; // [esp+34h] [ebp-4h]

  bytes = 0;
  rv = 0;
  targetClass_20 = sink->isa->put_block;
  HTReadProgress(0LL, 0LL);
  while ( chunk )
  {
    targetClass_20((HTStream *)sink, chunk->data, chunk->size);
    bytes += chunk->size;
    HTReadProgress(bytes, 0LL);
    HTDisplayPartial();
    if ( HTCheckForInterrupt() )
    {
      mustshow[0] = 1;
      v2 = gettext("Data transfer interrupted.");
      HTProgress(v2);
      if ( bytes )
        rv = -29998;
      else
        rv = -1;
      break;
    }
    chunk = chunk->next;
  }
  HTFinishDisplayPartial();
  return rv;
}

//----- (0812CC50) --------------------------------------------------------
int __cdecl HTGzFileCopy(gzFile gzfp, HTStream_5 *sink)
{
  FILE *v2; // eax
  const char *v3; // ebx
  FILE *v4; // eax
  char *v5; // eax
  void (*targetClass_20)(HTStream *, const char *, int); // [esp+30h] [ebp-18h]
  int rv; // [esp+34h] [ebp-14h]
  int gzerrnum; // [esp+38h] [ebp-10h] BYREF
  int bytes; // [esp+3Ch] [ebp-Ch]
  int status; // [esp+40h] [ebp-8h]

  targetClass_20 = sink->isa->put_block;
  bytes = 0;
  HTReadProgress(0LL, 0LL);
  while ( 1 )
  {
    status = gzread(gzfp, input_buffer, 0x1000u);
    if ( status <= 0 )
      break;
    targetClass_20((HTStream *)sink, input_buffer, status);
    bytes += status;
    HTReadProgress(bytes, -1LL);
    HTDisplayPartial();
    if ( HTCheckForInterrupt() )
    {
      mustshow[0] = 1;
      v5 = gettext("Data transfer interrupted.");
      HTProgress(v5);
      if ( bytes )
        rv = -29998;
      else
        rv = -1;
      goto LABEL_19;
    }
  }
  if ( status )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HTGzFileCopy: Read error, gzread returns %d\n", status);
    }
    if ( WWW_TraceFlag[0] )
    {
      v3 = gzerror(gzfp, &gzerrnum);
      v4 = TraceFP();
      fprintf(v4, "gzerror   : %s\n", v3);
    }
    if ( WWW_TraceFlag[0] && gzerrnum == -1 )
      perror("gzerror   ");
    if ( bytes )
      rv = 206;
    else
      rv = -1;
  }
  else
  {
    rv = 200;
  }
LABEL_19:
  HTFinishDisplayPartial();
  return rv;
}

//----- (0812CE20) --------------------------------------------------------
const char *__cdecl LynxZError(int status)
{
  sprintf(result_11300, "zlib error %d", status);
  return result_11300;
}

//----- (0812CE48) --------------------------------------------------------
int __cdecl HTZzFileCopy(FILE *zzfp, HTStream_5 *sink)
{
  const HTStreamClass *isa; // edx
  const char *v3; // ebx
  FILE *v4; // eax
  const char *v6; // ebx
  FILE *v7; // eax
  const char *v8; // ebx
  FILE *v9; // eax
  char *v10; // eax
  int v12; // [esp+10h] [ebp-1088h]
  int v13; // [esp+14h] [ebp-1084h]
  int v14; // [esp+18h] [ebp-1080h]
  z_stream s; // [esp+28h] [ebp-1070h] BYREF
  HTStreamClass targetClass; // [esp+60h] [ebp-1038h]
  int len; // [esp+78h] [ebp-1020h]
  int retry; // [esp+7Ch] [ebp-101Ch]
  int flush; // [esp+80h] [ebp-1018h]
  int status; // [esp+84h] [ebp-1014h]
  int rv; // [esp+88h] [ebp-1010h]
  int bytes; // [esp+8Ch] [ebp-100Ch]
  char output_buffer[4096]; // [esp+90h] [ebp-1008h] BYREF
  unsigned int v24; // [esp+1090h] [ebp-8h]

  v24 = __readgsdword(0x14u);
  rv = 0;
  retry = 0;
  len = 0;
  isa = sink->isa;
  targetClass.name = sink->isa->name;
  targetClass._free = isa->_free;
  targetClass._abort = isa->_abort;
  targetClass.put_character = isa->put_character;
  targetClass.put_string = isa->put_string;
  targetClass.put_block = isa->put_block;
  memset(&s.zalloc, 0, 12);
  status = inflateInit_(&s, "1.2.3.3", 56);
  if ( status )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = LynxZError(status);
      v4 = TraceFP();
      fprintf(v4, "HTZzFileCopy inflateInit() %s\n", v3);
    }
    exit_immediately(1);
  }
  s.avail_in = 0;
  s.next_out = (Bytef *)output_buffer;
  s.avail_out = 4096;
  flush = 0;
  bytes = 0;
  HTReadProgress(0LL, 0LL);
  while ( 1 )
  {
    while ( 1 )
    {
      if ( !s.avail_in )
      {
        s.next_in = (Bytef *)input_buffer;
        s.avail_in = fread(input_buffer, 1u, 0x1000u, zzfp);
        len = s.avail_in;
      }
      status = inflate(&s, flush);
      if ( status == 1 || status == -5 )
      {
        len = 4096 - s.avail_out;
        if ( (signed int)(4096 - s.avail_out) > 0 )
        {
          targetClass.put_block((HTStream *)sink, output_buffer, len);
          bytes += len;
          HTReadProgress(bytes, -1LL);
          HTDisplayPartial();
        }
        rv = 200;
        goto LABEL_37;
      }
      if ( status != -3 )
        break;
      if ( retry++ != 0 )
        break;
      status = inflateReset(&s);
      if ( status )
      {
        if ( WWW_TraceFlag[0] )
        {
          v6 = LynxZError(status);
          v7 = TraceFP();
          fprintf(v7, "HTZzFileCopy inflateReset() %s\n", v6);
        }
        if ( bytes )
          v12 = 206;
        else
          v12 = -1;
        rv = v12;
        goto LABEL_37;
      }
      s.next_in = (Bytef *)dummy_head_11307;
      s.avail_in = 2;
      status = inflate(&s, flush);
      s.next_in = (Bytef *)input_buffer;
      s.avail_in = len;
    }
    if ( status )
      break;
    if ( !s.avail_out )
    {
      len = 4096;
      s.next_out = (Bytef *)output_buffer;
      s.avail_out = 4096;
      targetClass.put_block((HTStream *)sink, output_buffer, 4096);
      bytes += len;
      HTReadProgress(bytes, -1LL);
      HTDisplayPartial();
      if ( HTCheckForInterrupt() )
      {
        mustshow[0] = 1;
        v10 = gettext("Data transfer interrupted.");
        HTProgress(v10);
        if ( bytes )
          v14 = -29998;
        else
          v14 = -1;
        rv = v14;
        goto LABEL_37;
      }
    }
    retry = 1;
  }
  if ( WWW_TraceFlag[0] )
  {
    v8 = LynxZError(status);
    v9 = TraceFP();
    fprintf(v9, "HTZzFileCopy inflate() %s\n", v8);
  }
  if ( bytes )
    v13 = 206;
  else
    v13 = -1;
  rv = v13;
LABEL_37:
  inflateEnd(&s);
  HTFinishDisplayPartial();
  return rv;
}

//----- (0812D344) --------------------------------------------------------
void __cdecl HTCopyNoCR(HTParentAnchor *anchor, int file_number, HTStream_5 *sink)
{
  void (*targetClass_12)(HTStream *, char); // [esp+18h] [ebp-10h]
  int character; // [esp+24h] [ebp-4h]

  targetClass_12 = sink->isa->put_character;
  HTInitInput(file_number);
  while ( 1 )
  {
    character = HTGetCharacter();
    if ( character == -1 )
      break;
    targetClass_12((HTStream *)sink, character);
  }
}

//----- (0812D3A4) --------------------------------------------------------
int __cdecl HTParseSocket(
        HTFormat rep_in,
        HTFormat format_out,
        HTParentAnchor *anchor,
        int file_number,
        HTStream_5 *sink)
{
  char *name; // esi
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  void (*targetClass_4)(HTStream *); // [esp+30h] [ebp-28h]
  char *buffer; // [esp+44h] [ebp-14h] BYREF
  int rv; // [esp+48h] [ebp-10h]
  HTStream_5 *stream; // [esp+4Ch] [ebp-Ch]

  stream = HTStreamStack(rep_in, format_out, sink, anchor);
  if ( stream )
  {
    targetClass_4 = stream->isa->_free;
    rv = HTCopy(anchor, file_number, 0, stream);
    if ( rv != -1 && rv != -29998 )
      targetClass_4((HTStream *)stream);
    return rv;
  }
  buffer = 0;
  if ( !LYCancelDownload[0] )
  {
    name = format_out->name;
    v6 = rep_in->name;
    v7 = gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buffer, v7, v6, name);
    if ( WWW_TraceFlag[0] )
    {
      v8 = buffer;
      v9 = TraceFP();
      fprintf(v9, "HTFormat: %s\n", v8);
    }
    rv = HTLoadError((HTStream_0 *)sink, 501, buffer);
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
    return rv;
  }
  LYCancelDownload[0] = 0;
  return -1;
}

//----- (0812D504) --------------------------------------------------------
int __cdecl HTParseFile(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, FILE *fp, HTStream_5 *sink)
{
  char *name; // esi
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  void (*targetClass_4)(HTStream *); // [esp+30h] [ebp-28h]
  void (*targetClass_8)(HTStream *, HTError); // [esp+34h] [ebp-24h]
  char *buffer; // [esp+44h] [ebp-14h] BYREF
  int rv; // [esp+48h] [ebp-10h]
  HTStream_5 *stream; // [esp+4Ch] [ebp-Ch]

  stream = HTStreamStack(rep_in, format_out, sink, anchor);
  if ( stream )
  {
    targetClass_4 = stream->isa->_free;
    targetClass_8 = stream->isa->_abort;
    rv = HTFileCopy(fp, stream);
    if ( rv == -1 || rv == -29998 )
      targetClass_8((HTStream *)stream, 0);
    else
      targetClass_4((HTStream *)stream);
    if ( rv == -1 )
    {
      return -204;
    }
    else if ( rv != -29998 && (rv <= 0 || rv == 200) )
    {
      return 200;
    }
    else
    {
      return 206;
    }
  }
  else
  {
    buffer = 0;
    if ( LYCancelDownload[0] )
    {
      LYCancelDownload[0] = 0;
      return -1;
    }
    else
    {
      name = format_out->name;
      v6 = rep_in->name;
      v7 = gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer, v7, v6, name);
      if ( WWW_TraceFlag[0] )
      {
        v8 = buffer;
        v9 = TraceFP();
        fprintf(v9, "HTFormat(in HTParseFile): %s\n", v8);
      }
      rv = HTLoadError((HTStream_0 *)sink, 501, buffer);
      if ( buffer )
      {
        free(buffer);
        buffer = 0;
      }
      return rv;
    }
  }
}

//----- (0812D6A4) --------------------------------------------------------
int __cdecl HTParseMem(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, HTChunk *chunk, HTStream_5 *sink)
{
  char *name; // esi
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  void (*targetClass_4)(HTStream *); // [esp+30h] [ebp-28h]
  char *buffer; // [esp+44h] [ebp-14h] BYREF
  int rv; // [esp+48h] [ebp-10h]
  HTStream_5 *stream; // [esp+4Ch] [ebp-Ch]

  stream = HTStreamStack(rep_in, format_out, sink, anchor);
  if ( stream )
  {
    targetClass_4 = stream->isa->_free;
    rv = HTMemCopy(chunk, stream);
    targetClass_4((HTStream *)stream);
    return 200;
  }
  else
  {
    buffer = 0;
    name = format_out->name;
    v6 = rep_in->name;
    v7 = gettext("Sorry, no known way of converting %s to %s.");
    HTSprintf0(&buffer, v7, v6, name);
    if ( WWW_TraceFlag[0] )
    {
      v8 = buffer;
      v9 = TraceFP();
      fprintf(v9, "HTFormat(in HTParseMem): %s\n", v8);
    }
    rv = HTLoadError((HTStream_0 *)sink, 501, buffer);
    if ( buffer )
    {
      free(buffer);
      buffer = 0;
    }
    return rv;
  }
}

//----- (0812D7CF) --------------------------------------------------------
int __cdecl HTCloseGzFile(gzFile gzfp)
{
  FILE *v1; // eax
  int gzres; // [esp+24h] [ebp-4h]

  if ( !gzfp )
    return 0;
  gzres = gzclose(gzfp);
  if ( WWW_TraceFlag[0] )
  {
    if ( gzres == -1 )
    {
      perror("gzclose   ");
    }
    else if ( gzres && WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "gzclose   : error number %d\n", gzres);
    }
  }
  return gzres;
}

//----- (0812D84B) --------------------------------------------------------
int __cdecl HTParseGzFile(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, gzFile gzfp, HTStream_5 *sink)
{
  char *name; // esi
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  void (*targetClass_4)(HTStream *); // [esp+30h] [ebp-28h]
  void (*targetClass_8)(HTStream *, HTError); // [esp+34h] [ebp-24h]
  char *buffer; // [esp+44h] [ebp-14h] BYREF
  int rv; // [esp+48h] [ebp-10h]
  HTStream_5 *stream; // [esp+4Ch] [ebp-Ch]

  stream = HTStreamStack(rep_in, format_out, sink, anchor);
  if ( stream )
  {
    targetClass_4 = stream->isa->_free;
    targetClass_8 = stream->isa->_abort;
    rv = HTGzFileCopy(gzfp, stream);
    if ( rv == -1 || rv == -29998 )
      targetClass_8((HTStream *)stream, 0);
    else
      targetClass_4((HTStream *)stream);
    HTCloseGzFile(gzfp);
    if ( rv == -1 )
    {
      return -204;
    }
    else if ( rv != -29998 && (rv <= 0 || rv == 200) )
    {
      return 200;
    }
    else
    {
      return 206;
    }
  }
  else
  {
    buffer = 0;
    HTCloseGzFile(gzfp);
    if ( LYCancelDownload[0] )
    {
      LYCancelDownload[0] = 0;
      return -1;
    }
    else
    {
      name = format_out->name;
      v6 = rep_in->name;
      v7 = gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer, v7, v6, name);
      if ( WWW_TraceFlag[0] )
      {
        v8 = buffer;
        v9 = TraceFP();
        fprintf(v9, "HTFormat(in HTParseGzFile): %s\n", v8);
      }
      rv = HTLoadError((HTStream_0 *)sink, 501, buffer);
      if ( buffer )
      {
        free(buffer);
        buffer = 0;
      }
      return rv;
    }
  }
}

//----- (0812DA01) --------------------------------------------------------
int __cdecl HTParseZzFile(HTFormat rep_in, HTFormat format_out, HTParentAnchor *anchor, FILE *zzfp, HTStream_5 *sink)
{
  char *name; // esi
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  FILE *v9; // eax
  void (*targetClass_4)(HTStream *); // [esp+30h] [ebp-28h]
  void (*targetClass_8)(HTStream *, HTError); // [esp+34h] [ebp-24h]
  char *buffer; // [esp+44h] [ebp-14h] BYREF
  int rv; // [esp+48h] [ebp-10h]
  HTStream_5 *stream; // [esp+4Ch] [ebp-Ch]

  stream = HTStreamStack(rep_in, format_out, sink, anchor);
  if ( stream )
  {
    targetClass_4 = stream->isa->_free;
    targetClass_8 = stream->isa->_abort;
    rv = HTZzFileCopy(zzfp, stream);
    if ( rv == -1 || rv == -29998 )
      targetClass_8((HTStream *)stream, 0);
    else
      targetClass_4((HTStream *)stream);
    fclose(zzfp);
    if ( rv == -1 )
    {
      return -204;
    }
    else if ( rv != -29998 && (rv <= 0 || rv == 200) )
    {
      return 200;
    }
    else
    {
      return 206;
    }
  }
  else
  {
    buffer = 0;
    fclose(zzfp);
    if ( LYCancelDownload[0] )
    {
      LYCancelDownload[0] = 0;
      return -1;
    }
    else
    {
      name = format_out->name;
      v6 = rep_in->name;
      v7 = gettext("Sorry, no known way of converting %s to %s.");
      HTSprintf0(&buffer, v7, v6, name);
      if ( WWW_TraceFlag[0] )
      {
        v8 = buffer;
        v9 = TraceFP();
        fprintf(v9, "HTFormat(in HTParseGzFile): %s\n", v8);
      }
      rv = HTLoadError((HTStream_0 *)sink, 501, buffer);
      if ( buffer )
      {
        free(buffer);
        buffer = 0;
      }
      return rv;
    }
  }
}

//----- (0812DBB7) --------------------------------------------------------
void __cdecl NetToText_put_character(HTStream_5 *me, char net_char)
{
  if ( me->had_cr )
  {
    if ( net_char == 10 )
    {
      me->sink->isa->put_character((HTStream *)me->sink, 10);
      me->had_cr = 0;
      return;
    }
    me->sink->isa->put_character((HTStream *)me->sink, 13);
  }
  me->had_cr = net_char == 13;
  if ( !me->had_cr )
    me->sink->isa->put_character((HTStream *)me->sink, net_char);
}

//----- (0812DC58) --------------------------------------------------------
void __cdecl NetToText_put_string(HTStream_5 *me, const char *s)
{
  while ( *s )
    NetToText_put_character(me, *s++);
}

//----- (0812DC8E) --------------------------------------------------------
void __cdecl NetToText_put_block(HTStream_5 *me, const char *s, int l)
{
  char *p; // [esp+14h] [ebp-4h]

  for ( p = (char *)s; &s[l] > p; ++p )
    NetToText_put_character(me, *p);
}

//----- (0812DCC5) --------------------------------------------------------
void __cdecl NetToText_free(HTStream_5 *me)
{
  me->sink->isa->_free((HTStream *)me->sink);
  if ( me )
    free(me);
}

//----- (0812DCFB) --------------------------------------------------------
void __cdecl NetToText_abort(HTStream_5 *me, HTError e)
{
  me->sink->isa->_abort((HTStream *)me->sink, e);
  if ( me )
    free(me);
}

//----- (0812DD38) --------------------------------------------------------
HTStream_5 *__cdecl HTNetToText(HTStream_5 *sink)
{
  HTStream_5 *me; // [esp+14h] [ebp-4h]

  me = (HTStream_5 *)calloc(1u, 0xCu);
  if ( !me )
    outofmem("../../../WWW/Library/Implementation/HTFormat.c", "NetToText");
  me->isa = &NetToTextClass;
  me->had_cr = 0;
  me->sink = sink;
  return me;
}

//----- (0812DD8D) --------------------------------------------------------
void __cdecl HTErrorStream_put_character(HTStream_5 *me, char c)
{
  LYCancelDownload[0] = 1;
}

//----- (0812DDA2) --------------------------------------------------------
void __cdecl HTErrorStream_put_string(HTStream_5 *me, const char *s)
{
  if ( s )
  {
    if ( *s )
      LYCancelDownload[0] = 1;
  }
}

//----- (0812DDBE) --------------------------------------------------------
void __cdecl HTErrorStream_write(HTStream_5 *me, const char *s, int l)
{
  if ( l )
  {
    if ( s )
      LYCancelDownload[0] = 1;
  }
}

//----- (0812DDD6) --------------------------------------------------------
void __cdecl HTErrorStream_free(HTStream_5 *me)
{
  ;
}

//----- (0812DDDB) --------------------------------------------------------
void __cdecl HTErrorStream_abort(HTStream_5 *me, HTError e)
{
  ;
}

//----- (0812DDE0) --------------------------------------------------------
HTStream_5 *HTErrorStream()
{
  FILE *v0; // eax

  if ( WWW_TraceFlag[0] )
  {
    v0 = TraceFP();
    fprintf(v0, "ErrorStream. Created\n");
  }
  HTBaseStreamInstance.isa = &HTErrorStreamClass;
  return &HTBaseStreamInstance;
}

//----- (0812DE1C) --------------------------------------------------------
void __cdecl HTMIME_TrimDoubleQuotes(char *value)
{
  int i; // [esp+14h] [ebp-4h]
  int ia; // [esp+14h] [ebp-4h]

  if ( value )
  {
    if ( *value )
    {
      if ( *value == 34 )
      {
        i = strlen(value);
        if ( value[i - 1] == 34 )
        {
          value[i - 1] = 0;
          for ( ia = 0; value[ia]; ++ia )
            value[ia] = value[ia + 1];
        }
      }
    }
  }
}

//----- (0812DE9E) --------------------------------------------------------
BOOLEAN __cdecl content_is_compressed(HTStream_6 *me)
{
  FILE *v1; // eax
  const char *v3; // [esp+14h] [ebp-14h]
  bool result; // [esp+27h] [ebp-1h]

  result = HTEncodingToCompressType(me->anchor->content_encoding) != cftNone;
  if ( WWW_TraceFlag[0] )
  {
    if ( result )
      v3 = (const char *)&unk_818C740;
    else
      v3 = " NOT";
    v1 = TraceFP();
    fprintf(v1, "content is%s compressed\n", v3);
  }
  return result;
}

//----- (0812DF0B) --------------------------------------------------------
void __cdecl dequote(char *url)
{
  int len; // [esp+14h] [ebp-4h]

  len = strlen(url);
  if ( *url == 39 && len > 1 && url[len - 1] == *url )
  {
    url[len - 1] = 0;
    while ( 1 )
    {
      *url = url[1];
      if ( !*url )
        break;
      ++url;
    }
  }
}

//----- (0812DF71) --------------------------------------------------------
const char *__cdecl UncompressedContentType(HTStream_6 *me, CompressFileType method)
{
  const char *description; // [esp+1Ch] [ebp-1Ch] BYREF
  HTAtom *pencoding; // [esp+20h] [ebp-18h] BYREF
  HTFormat format; // [esp+24h] [ebp-14h]
  const char *actual; // [esp+28h] [ebp-10h]
  const char *expected; // [esp+2Ch] [ebp-Ch]
  char *address; // [esp+30h] [ebp-8h]
  const char *result; // [esp+34h] [ebp-4h]

  result = 0;
  address = me->anchor->address;
  expected = HTCompressTypeToSuffix(method);
  actual = strrchr(address, 46);
  if ( actual && !strcasecomp(actual, expected) )
  {
    pencoding = 0;
    description = 0;
    format = HTFileFormat(address, &pencoding, &description);
    return format->name;
  }
  return result;
}

//----- (0812E005) --------------------------------------------------------
int __cdecl pumpData(HTStream_6 *me)
{
  FILE *v1; // eax
  char *address; // ebx
  FILE *v3; // eax
  FILE *v4; // eax
  char *name; // ebx
  FILE *v6; // eax
  int UCLYhndl; // eax
  int v8; // eax
  time_t v9; // ebx
  HTAtom *targetRep; // ebx
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  char *v14; // esi
  char *v15; // ebx
  FILE *v16; // eax
  char *v17; // ebx
  FILE *v18; // eax
  char *v19; // esi
  char *v20; // ebx
  FILE *v21; // eax
  FILE *v22; // eax
  const HTStreamClass *isa; // edx
  HTAtom *format; // ebx
  FILE *v25; // eax
  char *v26; // eax
  char *v27; // ebx
  char *v28; // eax
  char *v29; // ebx
  FILE *v30; // edx
  FILE *v31; // eax
  bool v33; // [esp+20h] [ebp-58h]
  bool v34; // [esp+24h] [ebp-54h]
  bool v35; // [esp+28h] [ebp-50h]
  char *txt; // [esp+3Ch] [ebp-3Ch] BYREF
  char *num; // [esp+40h] [ebp-38h] BYREF
  char *url; // [esp+44h] [ebp-34h] BYREF
  LYUCcharset *p_out; // [esp+48h] [ebp-30h]
  LYUCcharset *p_in; // [esp+4Ch] [ebp-2Ch]
  int chndl; // [esp+50h] [ebp-28h]
  char *cp4; // [esp+54h] [ebp-24h]
  char *cp2; // [esp+58h] [ebp-20h]
  char *cp1; // [esp+5Ch] [ebp-1Ch]
  const char *new_content; // [esp+60h] [ebp-18h]
  const char *new_encoding; // [esp+64h] [ebp-14h]
  CompressFileType method; // [esp+68h] [ebp-10h]
  BOOLEAN given_and_display_8859like; // [esp+6Ch] [ebp-Ch]
  BOOLEAN given_is_8859like; // [esp+6Dh] [ebp-Bh]
  BOOLEAN given_is_8859; // [esp+6Eh] [ebp-Ah]
  BOOLEAN chartrans_ok; // [esp+6Fh] [ebp-9h]

  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "Begin pumpData\n");
  }
  if ( WWW_TraceFlag[0] )
  {
    address = me->anchor->address;
    v3 = TraceFP();
    fprintf(v3, "...address{%s}\n", address);
  }
  method = HTContentTypeToCompressType(me->anchor->content_type_params);
  if ( method && (!me->anchor->content_encoding || !*me->anchor->content_encoding) )
  {
    new_content = UncompressedContentType(me, method);
    if ( new_content )
    {
      new_encoding = HTCompressTypeToEncoding(method);
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "reinterpreting as content-type:%s, encoding:%s\n", new_content, new_encoding);
      }
      HTSACopy(&me->anchor->content_encoding, new_encoding);
      if ( me->compression_encoding )
      {
        free(me->compression_encoding);
        me->compression_encoding = 0;
      }
      HTSACopy(&me->compression_encoding, new_encoding);
      strcpy(me->value, new_content);
      HTSACopy(&me->anchor->content_type_params, me->value);
      me->format = HTAtom_for(me->value);
    }
  }
  if ( strchr(me->format->name, 59) )
  {
    num = 0;
    url = 0;
    if ( WWW_TraceFlag[0] )
    {
      name = me->format->name;
      v6 = TraceFP();
      fprintf(v6, "HTMIME: Extended MIME Content-Type is %s\n", name);
    }
    HTSACopy(&num, me->format->name);
    LYLowerCase(num);
    cp1 = strchr(num, 59);
    if ( cp1 )
    {
      chartrans_ok = 0;
      cp2 = strstr(cp1, "charset");
      if ( cp2 )
      {
        for ( cp2 += 7; *cp2 == 32 || *cp2 == 61 || *cp2 == 34; ++cp2 )
          ;
        HTSACopy(&url, cp2);
        for ( cp4 = url; *cp4 && *cp4 != 34 && *cp4 != 59 && *cp4 != 58 && (unsigned __int8)*cp4 > 0x20u; ++cp4 )
          ;
        *cp4 = 0;
        cp4 = url;
        chndl = UCGetLYhndl_byMIME(url);
        if ( UCCanTranslateFromTo(chndl, current_char_set) )
        {
          chartrans_ok = 1;
          *cp1 = 0;
          me->format = HTAtom_for(num);
          HTSACopy(&me->anchor->charset, cp4);
          HTAnchor_setUCInfoStage(me->anchor, chndl, 0, 5);
        }
        else if ( chndl >= 0 )
        {
          *cp1 = 0;
          me->format = HTAtom_for(num);
          HTSACopy(&me->anchor->charset, cp4);
          HTAnchor_setUCInfoStage(me->anchor, chndl, 0, 5);
        }
        else
        {
          chndl = UCLYhndl_for_unrec;
          if ( UCLYhndl_for_unrec < 0 )
            chndl = UCLYhndl_for_unspec;
          if ( UCCanTranslateFromTo(chndl, current_char_set) )
          {
            chartrans_ok = 1;
            *cp1 = 0;
            me->format = HTAtom_for(num);
            HTAnchor_setUCInfoStage(me->anchor, chndl, 0, 1);
          }
        }
        if ( chartrans_ok )
        {
          p_in = HTAnchor_getUCInfoStage(me->anchor, 0);
          p_out = HTAnchor_setUCInfoStage(me->anchor, current_char_set, 3, 1);
          if ( !p_out )
            p_out = HTAnchor_getUCInfoStage(me->anchor, 3);
          if ( !strcmp(p_in->MIMEname, "x-transparent") )
          {
            HTPassEightBitRaw = 1;
            UCLYhndl = HTAnchor_getUCLYhndl(me->anchor, 3);
            HTAnchor_setUCInfoStage(me->anchor, UCLYhndl, 0, 1);
          }
          if ( !strcmp(p_out->MIMEname, "x-transparent") )
          {
            HTPassEightBitRaw = 1;
            v8 = HTAnchor_getUCLYhndl(me->anchor, 0);
            HTAnchor_setUCInfoStage(me->anchor, v8, 3, 1);
          }
          if ( p_in->enc == 5 || p_in->enc == 7 && p_out->enc == 5 )
          {
            if ( p_out->enc == 5 )
              Set_HTCJK(p_in->MIMEname, p_out->MIMEname);
          }
          else
          {
            HTCJK = NOCJK;
            if ( (p_in->codepoints & 1) == 0 && chndl == current_char_set )
              HTPassEightBitRaw = 1;
          }
        }
        else
        {
          v33 = !strncmp(cp4, "iso-8859-", 9u) && ((*__ctype_b_loc())[(unsigned __int8)cp4[9]] & 0x800) != 0;
          given_is_8859 = v33;
          v34 = v33 || !strncmp(cp4, "windows-", 8u) || !strncmp(cp4, "cp12", 4u) || !strncmp(cp4, "cp-12", 5u);
          given_is_8859like = v34;
          v35 = v34
             && (strstr(LYchar_set_names[current_char_set], "ISO-8859")
              || strstr(LYchar_set_names[current_char_set], "windows-"));
          given_and_display_8859like = v35;
          if ( v35 )
          {
            *cp1 = 0;
            me->format = HTAtom_for(num);
          }
          if ( given_is_8859 )
          {
            for ( cp1 = cp4 + 10; *cp1 && ((*__ctype_b_loc())[(unsigned __int8)*cp1] & 0x800) != 0; ++cp1 )
              ;
            *cp1 = 0;
          }
          if ( given_and_display_8859like )
          {
            HTSACopy(&me->anchor->charset, cp4);
            HTPassEightBitRaw = 1;
          }
          if ( *cp4 )
            HTAlert(cp4);
          else
            HTAlert(me->anchor->charset);
        }
        if ( url )
        {
          free(url);
          url = 0;
        }
      }
      else
      {
        *cp1 = 0;
        me->format = HTAtom_for(num);
      }
    }
    if ( num )
    {
      free(num);
      num = 0;
    }
  }
  if ( !me->anchor->no_cache && me->anchor->expires )
  {
    if ( !strcmp(me->anchor->expires, "0") )
    {
      me->anchor->no_cache = 1;
    }
    else if ( me->anchor->date )
    {
      v9 = LYmktime(me->anchor->expires, 1);
      if ( v9 <= LYmktime(me->anchor->date, 1) )
        me->anchor->no_cache = 1;
    }
    else if ( !LYmktime(me->anchor->expires, 0) )
    {
      me->anchor->no_cache = 1;
    }
  }
  HTSACopy(&me->anchor->content_type, me->format->name);
  if ( me->set_cookie || me->set_cookie2 )
  {
    LYSetCookie(me->set_cookie, me->set_cookie2, me->anchor->address);
    if ( me->set_cookie )
    {
      free(me->set_cookie);
      me->set_cookie = 0;
    }
    if ( me->set_cookie2 )
    {
      free(me->set_cookie2);
      me->set_cookie2 = 0;
    }
  }
  if ( me->pickup_redirection )
  {
    if ( me->location && *me->location )
    {
      redirecting_url = me->location;
      me->location = 0;
      targetRep = me->targetRep;
      if ( targetRep != HTAtom_for("www/debug") || me->sink )
        me->head_only = 1;
    }
    else
    {
      permanent_redirection = 0;
      if ( me->location )
      {
        if ( WWW_TraceFlag[0] )
        {
          v11 = TraceFP();
          fprintf(v11, "HTTP: 'Location:' is zero-length!\n");
        }
        HTAlert("Got redirection with a bad Location header.");
      }
      if ( WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "HTTP: Failed to pick up location.\n");
      }
      if ( me->location )
      {
        free(me->location);
        me->location = 0;
      }
      else
      {
        HTAlert("Got redirection with no Location header.");
      }
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v13 = TraceFP();
    fprintf(v13, "...pumpData finished reading header\n");
  }
  if ( me->head_only )
  {
    me->state = MIME_IGNORE;
  }
  else
  {
    if ( me->no_streamstack )
    {
      me->target = me->sink;
    }
    else
    {
      if ( me->compression_encoding )
      {
        if ( WWW_TraceFlag[0] )
        {
          v17 = me->format->name;
          v18 = TraceFP();
          fprintf(v18, "HTMIME: MIME Content-Type is '%s',\n", v17);
        }
        me->format = HTAtom_for("www/compressed");
        if ( WWW_TraceFlag[0] )
        {
          v19 = me->targetRep->name;
          v20 = me->format->name;
          v21 = TraceFP();
          fprintf(v21, "        Treating as '%s'.  Converting to '%s'\n", v20, v19);
        }
        if ( me->compression_encoding )
        {
          free(me->compression_encoding);
          me->compression_encoding = 0;
        }
      }
      else if ( WWW_TraceFlag[0] )
      {
        v14 = me->targetRep->name;
        v15 = me->format->name;
        v16 = TraceFP();
        fprintf(v16, "HTMIME: MIME Content-Type is '%s', converting to '%s'\n", v15, v14);
      }
      me->target = (HTStream_6 *)HTStreamStack(me->format, me->targetRep, (HTStream_5 *)me->sink, me->anchor);
      if ( !me->target )
      {
        if ( WWW_TraceFlag[0] )
        {
          v22 = TraceFP();
          fprintf(v22, "HTMIME: Can't translate! ** \n");
        }
        me->target = me->sink;
      }
    }
    if ( me->target )
    {
      isa = me->target->isa;
      me->targetClass.name = isa->name;
      me->targetClass._free = isa->_free;
      me->targetClass._abort = isa->_abort;
      me->targetClass.put_character = isa->put_character;
      me->targetClass.put_string = isa->put_string;
      me->targetClass.put_block = isa->put_block;
      me->state = me->chunked_encoding != 0;
    }
    else
    {
      me->state = MIME_IGNORE;
    }
    if ( me->refresh_url && !content_is_compressed(me) )
    {
      url = 0;
      num = 0;
      txt = 0;
      LYParseRefreshURL(me->refresh_url, &num, &url);
      if ( url )
      {
        format = me->format;
        if ( format == HTAtom_for("text/html") )
        {
          if ( WWW_TraceFlag[0] )
          {
            v25 = TraceFP();
            fprintf(v25, "Formatting refresh-url as first line of result\n");
          }
          v26 = gettext("Refresh: ");
          HTSprintf0(&txt, v26);
          v27 = num;
          v28 = gettext("%s seconds ");
          HTSprintf(&txt, v28, v27);
          dequote(url);
          HTSprintf(&txt, "<a href=\"%s%s\">%s</a><br>", (const char *)&unk_818C740, url, url);
          if ( WWW_TraceFlag[0] )
          {
            v29 = url;
            v30 = TraceFP();
            fprintf(v30, "URL %s%s\n", (const char *)&unk_818C740, v29);
          }
          me->isa->put_string((HTStream *)me, txt);
          free(txt);
        }
      }
      if ( num )
      {
        free(num);
        num = 0;
      }
      if ( url )
      {
        free(url);
        url = 0;
      }
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v31 = TraceFP();
    fprintf(v31, "...end of pumpData\n");
  }
  return 0;
}

//----- (0812EF83) --------------------------------------------------------
int __cdecl dispatchField(HTStream_6 *me)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  HTParentAnchor *anchor; // ebx
  int content_length; // ebx
  FILE *v17; // eax
  FILE *v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  FILE *v22; // eax
  FILE *v23; // eax
  FILE *v24; // eax
  FILE *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  FILE *v28; // eax
  FILE *v29; // eax
  FILE *v30; // eax
  FILE *v31; // eax
  FILE *v32; // eax
  FILE *v33; // eax
  FILE *v34; // eax
  FILE *v35; // eax
  FILE *v36; // eax
  FILE *v37; // eax
  FILE *v38; // eax
  FILE *v39; // eax
  FILE *v40; // eax
  FILE *v41; // eax
  FILE *v42; // eax
  FILE *v43; // eax
  FILE *v44; // eax
  FILE *v45; // eax
  FILE *v46; // eax
  FILE *v47; // eax
  char v49; // [esp+1Fh] [ebp-29h]
  const char *cp0; // [esp+30h] [ebp-18h]
  const char *cp0a; // [esp+30h] [ebp-18h]
  char *cp0b; // [esp+30h] [ebp-18h]
  char *cp1; // [esp+34h] [ebp-14h]
  char *cp1a; // [esp+34h] [ebp-14h]
  char *cp1b; // [esp+34h] [ebp-14h]
  char *cp1c; // [esp+34h] [ebp-14h]
  char *cp; // [esp+38h] [ebp-10h]
  char *cpa; // [esp+38h] [ebp-10h]
  char *cpb; // [esp+38h] [ebp-10h]
  char *cpc; // [esp+38h] [ebp-10h]
  char *cpd; // [esp+38h] [ebp-10h]
  int j; // [esp+3Ch] [ebp-Ch]
  int i; // [esp+40h] [ebp-8h]

  *me->value_pointer = 0;
  for ( cp = me->value_pointer; me->value < cp; *cp = 0 )
  {
    if ( *--cp != 32 )
      break;
  }
  switch ( me->field )
  {
    case miACCEPT_RANGES:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v1 = TraceFP();
        fprintf(v1, "HTMIME: PICKED UP Accept-Ranges: '%s'\n", me->value);
      }
      return 0;
    case miAGE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "HTMIME: PICKED UP Age: '%s'\n", me->value);
      }
      return 0;
    case miALLOW:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "HTMIME: PICKED UP Allow: '%s'\n", me->value);
      }
      return 0;
    case miALTERNATES:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v4 = TraceFP();
        fprintf(v4, "HTMIME: PICKED UP Alternates: '%s'\n", me->value);
      }
      return 0;
    case miCACHE_CONTROL:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "HTMIME: PICKED UP Cache-Control: '%s'\n", me->value);
      }
      if ( !me->value[0] )
        return 0;
      LYLowerCase(me->value);
      HTSACopy(&me->anchor->cache_control, me->value);
      cp0 = me->value;
      while ( 2 )
      {
        cp1a = strstr(cp0, "no-cache");
        if ( cp1a )
        {
          for ( cp1 = cp1a + 8; *cp1 && (unsigned __int8)*cp1 <= 0x20u; ++cp1 )
            ;
          if ( *cp1 && *cp1 != 59 )
          {
            cp0 = cp1;
            continue;
          }
          me->anchor->no_cache = 1;
        }
        break;
      }
      if ( me->anchor->no_cache == 1 )
        return 0;
      cp0a = me->value;
      while ( 2 )
      {
        cp1c = strstr(cp0a, "max-age");
        if ( cp1c )
        {
          for ( cp1b = cp1c + 7; *cp1b && (unsigned __int8)*cp1b <= 0x20u; ++cp1b )
            ;
          if ( *cp1b != 61 )
            goto LABEL_45;
          ++cp1b;
          while ( *cp1b && (unsigned __int8)*cp1b <= 0x20u )
            ++cp1b;
          if ( ((*__ctype_b_loc())[(unsigned __int8)*cp1b] & 0x800) == 0 )
            goto LABEL_45;
          cp0b = cp1b;
          while ( ((*__ctype_b_loc())[(unsigned __int8)*cp1b] & 0x800) != 0 )
            ++cp1b;
          if ( *cp0b != 48 || cp0b + 1 != cp1b )
          {
LABEL_45:
            cp0a = cp1b;
            continue;
          }
          me->anchor->no_cache = 1;
        }
        return 0;
      }
    case miCOOKIE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "HTMIME: PICKED UP Cookie: '%s'\n", me->value);
      }
      return 0;
    case miCONNECTION:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, "HTMIME: PICKED UP Connection: '%s'\n", me->value);
      }
      return 0;
    case miCONTENT_BASE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v8 = TraceFP();
        fprintf(v8, "HTMIME: PICKED UP Content-Base: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->content_base, me->value);
      return 0;
    case miCONTENT_DISPOSITION:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v9 = TraceFP();
        fprintf(v9, "HTMIME: PICKED UP Content-Disposition: '%s'\n", me->value);
      }
      if ( !me->value[0] )
        return 0;
      HTSACopy(&me->anchor->content_disposition, me->value);
      for ( cpa = me->anchor->content_disposition; *cpa && strncasecomp(cpa, "filename", 8); ++cpa )
        ;
      if ( !*cpa )
        return 0;
      for ( cpb = cpa + 8; *cpb && ((unsigned __int8)*cpb <= 0x20u || *cpb == 61); ++cpb )
        ;
      if ( !*cpb )
        return 0;
      while ( *cpb && (unsigned __int8)*cpb <= 0x20u )
        ++cpb;
      if ( !*cpb )
        return 0;
      HTSACopy(&me->anchor->SugFname, cpb);
      if ( *me->anchor->SugFname != 34 )
        goto LABEL_80;
      cpc = strchr((const char *)me->anchor->SugFname + 1, 34);
      if ( !cpc )
      {
        if ( !me->anchor->SugFname )
          return 0;
        goto LABEL_79;
      }
      cpc[1] = 0;
      HTMIME_TrimDoubleQuotes(me->anchor->SugFname);
LABEL_80:
      for ( cpd = me->anchor->SugFname; *cpd && (unsigned __int8)*cpd > 0x20u; ++cpd )
        ;
      *cpd = 0;
      if ( !*me->anchor->SugFname && me->anchor->SugFname )
      {
LABEL_79:
        free(me->anchor->SugFname);
        me->anchor->SugFname = 0;
      }
      return 0;
    case miCONTENT_ENCODING:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v10 = TraceFP();
        fprintf(v10, "HTMIME: PICKED UP Content-Encoding: '%s'\n", me->value);
      }
      if ( me->value[0] && strcasecomp(me->value, "identity") )
      {
        LYLowerCase(me->value);
        HTSACopy(&me->anchor->content_encoding, me->value);
        if ( me->compression_encoding )
        {
          free(me->compression_encoding);
          me->compression_encoding = 0;
        }
        if ( content_is_compressed(me) )
        {
          HTSACopy(&me->compression_encoding, me->value);
        }
        else if ( WWW_TraceFlag[0] )
        {
          v11 = TraceFP();
          fprintf(v11, "                Ignoring it!\n");
        }
      }
      return 0;
    case miCONTENT_FEATURES:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "HTMIME: PICKED UP Content-Features: '%s'\n", me->value);
      }
      return 0;
    case miCONTENT_LANGUAGE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v13 = TraceFP();
        fprintf(v13, "HTMIME: PICKED UP Content-Language: '%s'\n", me->value);
      }
      if ( me->value[0] )
      {
        LYLowerCase(me->value);
        HTSACopy(&me->anchor->content_language, me->value);
      }
      return 0;
    case miCONTENT_LENGTH:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v14 = TraceFP();
        fprintf(v14, "HTMIME: PICKED UP Content-Length: '%s'\n", me->value);
      }
      if ( me->value[0] )
      {
        anchor = me->anchor;
        anchor->content_length = atoi(me->value);
        if ( me->anchor->content_length < 0 )
          me->anchor->content_length = 0;
        if ( WWW_TraceFlag[0] )
        {
          content_length = me->anchor->content_length;
          v17 = TraceFP();
          fprintf(v17, "        Converted to integer: '%d'\n", content_length);
        }
      }
      return 0;
    case miCONTENT_LOCATION:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v18 = TraceFP();
        fprintf(v18, "HTMIME: PICKED UP Content-Location: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->content_location, me->value);
      return 0;
    case miCONTENT_MD5:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v19 = TraceFP();
        fprintf(v19, "HTMIME: PICKED UP Content-MD5: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->content_md5, me->value);
      return 0;
    case miCONTENT_RANGE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v20 = TraceFP();
        fprintf(v20, "HTMIME: PICKED UP Content-Range: '%s'\n", me->value);
      }
      return 0;
    case miCONTENT_TRANSFER_ENCODING:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v21 = TraceFP();
        fprintf(v21, "HTMIME: PICKED UP Content-Transfer-Encoding: '%s'\n", me->value);
      }
      if ( me->value[0] )
      {
        LYLowerCase(me->value);
        me->c_t_encoding = HTAtom_for(me->value);
      }
      return 0;
    case miCONTENT_TYPE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v22 = TraceFP();
        fprintf(v22, "HTMIME: PICKED UP Content-Type: '%s'\n", me->value);
      }
      if ( me->value[0] )
      {
        i = 0;
        j = 0;
        while ( me->value[i] )
        {
          if ( me->value[i] != 32 && me->value[i] != 34 )
          {
            if ( ((*__ctype_b_loc())[(unsigned __int8)me->value[i]] & 0x100) != 0 )
              v49 = tolower((unsigned __int8)me->value[i]);
            else
              v49 = me->value[i];
            me->value[j++] = v49;
          }
          ++i;
        }
        me->value[j] = 0;
        me->format = HTAtom_for(me->value);
        HTSACopy(&me->anchor->content_type_params, me->value);
      }
      return 0;
    case miDATE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v23 = TraceFP();
        fprintf(v23, "HTMIME: PICKED UP Date: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->date, me->value);
      return 0;
    case miETAG:
      if ( WWW_TraceFlag[0] )
      {
        v24 = TraceFP();
        fprintf(v24, "HTMIME: PICKED UP ETag: %s\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->ETag, me->value);
      return 0;
    case miEXPIRES:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v25 = TraceFP();
        fprintf(v25, "HTMIME: PICKED UP Expires: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->expires, me->value);
      return 0;
    case miKEEP_ALIVE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v26 = TraceFP();
        fprintf(v26, "HTMIME: PICKED UP Keep-Alive: '%s'\n", me->value);
      }
      return 0;
    case miLAST_MODIFIED:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v27 = TraceFP();
        fprintf(v27, "HTMIME: PICKED UP Last-Modified: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->last_modified, me->value);
      return 0;
    case miLINK:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v28 = TraceFP();
        fprintf(v28, "HTMIME: PICKED UP Link: '%s'\n", me->value);
      }
      return 0;
    case miLOCATION:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v29 = TraceFP();
        fprintf(v29, "HTMIME: PICKED UP Location: '%s'\n", me->value);
      }
      if ( !me->pickup_redirection || me->location )
      {
        if ( WWW_TraceFlag[0] )
        {
          v30 = TraceFP();
          fprintf(v30, "HTMIME: *** Ignoring Location!\n");
        }
      }
      else
      {
        HTSACopy(&me->location, me->value);
      }
      return 0;
    case miPRAGMA:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v31 = TraceFP();
        fprintf(v31, "HTMIME: PICKED UP Pragma: '%s'\n", me->value);
      }
      if ( me->value[0] && !strcmp(me->value, "no-cache") )
        me->anchor->no_cache = 1;
      return 0;
    case miPROXY_AUTHENTICATE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v32 = TraceFP();
        fprintf(v32, "HTMIME: PICKED UP Proxy-Authenticate: '%s'\n", me->value);
      }
      return 0;
    case miPUBLIC:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v33 = TraceFP();
        fprintf(v33, "HTMIME: PICKED UP Public: '%s'\n", me->value);
      }
      return 0;
    case miREFRESH:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v34 = TraceFP();
        fprintf(v34, "HTMIME: PICKED UP Refresh: '%s'\n", me->value);
      }
      HTSACopy(&me->refresh_url, me->value);
      return 0;
    case miRETRY_AFTER:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v35 = TraceFP();
        fprintf(v35, "HTMIME: PICKED UP Retry-After: '%s'\n", me->value);
      }
      return 0;
    case miSAFE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v36 = TraceFP();
        fprintf(v36, "HTMIME: PICKED UP Safe: '%s'\n", me->value);
      }
      if ( me->value[0] )
      {
        if ( strcasecomp(me->value, "YES") && strcasecomp(me->value, "TRUE") )
        {
          if ( !strcasecomp(me->value, "NO") || !strcasecomp(me->value, "FALSE") )
            me->anchor->safe = 0;
        }
        else
        {
          me->anchor->safe = 1;
        }
      }
      return 0;
    case miSERVER:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v37 = TraceFP();
        fprintf(v37, "HTMIME: PICKED UP Server: '%s'\n", me->value);
      }
      if ( me->value[0] )
        HTSACopy(&me->anchor->server, me->value);
      return 0;
    case miSET_COOKIE1:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v38 = TraceFP();
        fprintf(v38, "HTMIME: PICKED UP Set-Cookie: '%s'\n", me->value);
      }
      if ( me->set_cookie )
      {
        HTSACat(&me->set_cookie, ", ");
        HTSACat(&me->set_cookie, me->value);
      }
      else
      {
        HTSACopy(&me->set_cookie, me->value);
      }
      return 0;
    case miSET_COOKIE2:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v39 = TraceFP();
        fprintf(v39, "HTMIME: PICKED UP Set-Cookie2: '%s'\n", me->value);
      }
      if ( me->set_cookie2 )
      {
        HTSACat(&me->set_cookie2, ", ");
        HTSACat(&me->set_cookie2, me->value);
      }
      else
      {
        HTSACopy(&me->set_cookie2, me->value);
      }
      return 0;
    case miTITLE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v40 = TraceFP();
        fprintf(v40, "HTMIME: PICKED UP Title: '%s'\n", me->value);
      }
      return 0;
    case miTRANSFER_ENCODING:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v41 = TraceFP();
        fprintf(v41, "HTMIME: PICKED UP Transfer-Encoding: '%s'\n", me->value);
      }
      if ( !strcmp(me->value, "chunked") )
        me->chunked_encoding = 1;
      return 0;
    case miUPGRADE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v42 = TraceFP();
        fprintf(v42, "HTMIME: PICKED UP Upgrade: '%s'\n", me->value);
      }
      return 0;
    case miURI:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v43 = TraceFP();
        fprintf(v43, "HTMIME: PICKED UP URI: '%s'\n", me->value);
      }
      return 0;
    case miVARY:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v44 = TraceFP();
        fprintf(v44, "HTMIME: PICKED UP Vary: '%s'\n", me->value);
      }
      return 0;
    case miVIA:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v45 = TraceFP();
        fprintf(v45, "HTMIME: PICKED UP Via: '%s'\n", me->value);
      }
      return 0;
    case miWARNING:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v46 = TraceFP();
        fprintf(v46, "HTMIME: PICKED UP Warning: '%s'\n", me->value);
      }
      return 0;
    case miWWW_AUTHENTICATE:
      HTMIME_TrimDoubleQuotes(me->value);
      if ( WWW_TraceFlag[0] )
      {
        v47 = TraceFP();
        fprintf(v47, "HTMIME: PICKED UP WWW-Authenticate: '%s'\n", me->value);
      }
      return 0;
    default:
      return -1;
  }
}

//----- (081304C5) --------------------------------------------------------
void __cdecl HTMIME_put_character(HTStream_6 *me, char c)
{
  FILE *v2; // eax
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  FILE *v14; // eax
  FILE *v15; // eax
  FILE *v16; // eax
  FILE *v17; // eax
  FILE *v18; // eax
  FILE *v19; // eax
  FILE *v20; // eax
  FILE *v21; // eax
  FILE *v22; // eax
  FILE *v23; // eax
  FILE *v24; // eax
  FILE *v25; // eax
  FILE *v26; // eax
  FILE *v27; // eax
  FILE *v28; // eax
  FILE *v29; // eax
  FILE *v30; // eax
  FILE *v31; // eax
  FILE *v32; // eax
  FILE *v33; // eax
  FILE *v34; // eax
  FILE *v35; // eax
  FILE *v36; // eax
  FILE *v37; // eax
  FILE *v38; // eax
  FILE *v39; // eax
  FILE *v40; // eax
  FILE *v41; // eax
  FILE *v42; // eax
  FILE *v43; // eax
  FILE *v44; // eax
  FILE *v45; // eax
  const char *v46; // ebx
  FILE *v47; // eax
  const char *check_pointer; // ebx
  FILE *v49; // eax
  FILE *v50; // eax
  FILE *v51; // eax
  FILE *v52; // eax
  FILE *v53; // eax
  FILE *v54; // eax
  FILE *v55; // eax
  FILE *v56; // eax
  FILE *v57; // eax
  FILE *v58; // eax
  FILE *v59; // eax
  FILE *v60; // eax
  FILE *v61; // eax
  FILE *v62; // eax
  FILE *v63; // eax
  FILE *v64; // eax
  FILE *v65; // eax
  FILE *v66; // eax
  FILE *v67; // eax
  FILE *v68; // eax
  FILE *v69; // eax
  FILE *v70; // eax
  FILE *v71; // eax
  const char *v72; // edx
  bool v73; // cl
  const char *v74; // ebx
  FILE *v75; // eax
  FILE *v76; // eax
  FILE *v77; // eax
  FILE *v78; // eax
  FILE *v79; // eax
  FILE *v80; // eax
  FILE *v81; // eax
  FILE *v82; // eax
  FILE *v83; // eax
  FILE *v84; // eax
  FILE *v85; // eax
  FILE *v86; // eax
  FILE *v87; // eax
  FILE *v88; // eax
  FILE *v89; // eax
  FILE *v90; // eax
  FILE *v91; // eax
  FILE *v92; // eax
  FILE *v93; // eax
  FILE *v94; // eax
  char *value_pointer; // edx
  FILE *v96; // eax
  int chunked_size; // [esp+34h] [ebp-64h]
  int v98; // [esp+38h] [ebp-60h]
  MIME_state v99; // [esp+3Ch] [ebp-5Ch]
  int v100; // [esp+84h] [ebp-14h]
  char ca; // [esp+8Ch] [ebp-Ch]

  ca = c;
  switch ( me->state )
  {
    case MIME_TRANSPARENT:
      goto LABEL_33;
    case MIME_CHUNKED:
      goto begin_chunked;
    case mcCHUNKED_COUNT_DIGIT:
      goto LABEL_10;
    case mcCHUNKED_COUNT_CR:
      goto LABEL_22;
    case mcCHUNKED_COUNT_LF:
      goto LABEL_23;
    case mcCHUNKED_EXTENSION:
      while ( 2 )
      {
        if ( c == 13 || c == 10 )
        {
          me->state = mcCHUNKED_COUNT_CR;
LABEL_22:
          me->state = mcCHUNKED_COUNT_LF;
          if ( c != 13 )
          {
LABEL_23:
            if ( me->chunked_size )
              v99 = mcCHUNKED_DATA;
            else
              v99 = MIME_CHUNKED;
            me->state = v99;
            if ( c != 10 )
            {
begin_chunked:
              me->chunked_size = 0;
              me->state = mcCHUNKED_COUNT_DIGIT;
LABEL_10:
              if ( ((*__ctype_b_loc())[(unsigned __int8)c] & 0x1000) == 0 )
              {
                if ( c == 59 )
                  me->state = mcCHUNKED_EXTENSION;
                continue;
              }
              me->chunked_size *= 16;
              if ( ((*__ctype_b_loc())[(unsigned __int8)c] & 0x800) != 0 )
              {
                me->chunked_size += (unsigned __int8)c - 48;
              }
              else
              {
                chunked_size = me->chunked_size;
                if ( ((*__ctype_b_loc())[(unsigned __int8)c] & 0x200) != 0 )
                  v98 = toupper((unsigned __int8)c) - 55;
                else
                  v98 = (unsigned __int8)c - 55;
                me->chunked_size = v98 + chunked_size;
              }
            }
          }
        }
        break;
      }
      return;
    case mcCHUNKED_DATA:
      me->targetClass.put_character((HTStream *)me->target, c);
      if ( --me->chunked_size <= 0 )
        me->state = mcCHUNKED_DATA_CR;
      return;
    case mcCHUNKED_DATA_CR:
      me->state = mcCHUNKED_DATA_LF;
      if ( c != 13 )
        goto LABEL_5;
      return;
    case mcCHUNKED_DATA_LF:
LABEL_5:
      me->state = MIME_CHUNKED;
      if ( c != 10 )
      {
        if ( WWW_TraceFlag[0] )
        {
          v2 = TraceFP();
          fprintf(v2, "HTIME_put_character expected LF in chunked data\n");
        }
        me->state = MIME_TRANSPARENT;
LABEL_33:
        me->targetClass.put_character((HTStream *)me->target, ca);
      }
      return;
    default:
      if ( !me->net_ascii )
        break;
      if ( c == 13 )
        return;
      if ( c == 10 )
        ca = 10;
      break;
  }
  switch ( me->state )
  {
    case miBEGINNING_OF_LINE:
      goto LABEL_43;
    case miA:
      switch ( ca )
      {
        case 'C':
        case 'c':
          me->check_pointer = "cept-ranges:";
          me->if_ok = miACCEPT_RANGES;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v16 = TraceFP();
            fprintf(v16, "HTMIME: Was A, found C, checking for 'cept-ranges:'\n");
          }
          break;
        case 'G':
        case 'g':
          me->check_pointer = "e:";
          me->if_ok = miAGE;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v17 = TraceFP();
            fprintf(v17, "HTMIME: Was A, found G, checking for 'e:'\n");
          }
          break;
        case 'L':
        case 'l':
          me->state = miAL;
          if ( WWW_TraceFlag[0] )
          {
            v18 = TraceFP();
            fprintf(v18, "HTMIME: Was A, found L, state now AL'\n");
          }
          break;
        default:
          if ( WWW_TraceFlag[0] )
          {
            v19 = TraceFP();
            fprintf(v19, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'g' or 'l'");
          }
          goto bad_field_name;
      }
      return;
    case miACCEPT_RANGES:
    case miAGE:
    case miALLOW:
    case miALTERNATES:
    case miCACHE_CONTROL:
    case miCOOKIE:
    case miCONNECTION:
    case miCONTENT_BASE:
    case miCONTENT_DISPOSITION:
    case miCONTENT_ENCODING:
    case miCONTENT_FEATURES:
    case miCONTENT_LANGUAGE:
    case miCONTENT_LENGTH:
    case miCONTENT_LOCATION:
    case miCONTENT_MD5:
    case miCONTENT_RANGE:
    case miCONTENT_TRANSFER_ENCODING:
    case miCONTENT_TYPE:
    case miDATE:
    case miETAG:
    case miEXPIRES:
    case miKEEP_ALIVE:
    case miLAST_MODIFIED:
    case miLINK:
    case miLOCATION:
    case miPRAGMA:
    case miPROXY_AUTHENTICATE:
    case miPUBLIC:
    case miREFRESH:
    case miRETRY_AFTER:
    case miSAFE:
    case miSERVER:
    case miSET_COOKIE1:
    case miSET_COOKIE2:
    case miTITLE:
    case miTRANSFER_ENCODING:
    case miUPGRADE:
    case miURI:
    case miVARY:
    case miVIA:
    case miWARNING:
    case miWWW_AUTHENTICATE:
      me->field = me->state;
      me->state = miSKIP_GET_VALUE;
      goto LABEL_341;
    case miAL:
      if ( ca == 84 )
        goto LABEL_89;
      if ( ca <= 84 )
      {
        if ( ca != 76 )
          goto LABEL_91;
        goto LABEL_87;
      }
      if ( ca == 108 )
      {
LABEL_87:
        me->check_pointer = "ow:";
        me->if_ok = miALLOW;
        me->state = miCHECK;
        if ( WWW_TraceFlag[0] )
        {
          v20 = TraceFP();
          fprintf(v20, "HTMIME: Was AL, found L, checking for 'ow:'\n");
        }
        return;
      }
      if ( ca != 116 )
      {
LABEL_91:
        if ( WWW_TraceFlag[0] )
        {
          v22 = TraceFP();
          fprintf(v22, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'l' or 't'");
        }
        goto bad_field_name;
      }
LABEL_89:
      me->check_pointer = "ernates:";
      me->if_ok = miALTERNATES;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v21 = TraceFP();
        fprintf(v21, "HTMIME: Was AL, found T, checking for 'ernates:'\n");
      }
      return;
    case miC:
      if ( ca == 79 )
        goto LABEL_102;
      if ( ca > 79 )
      {
        if ( ca != 97 )
        {
          if ( ca == 111 )
          {
LABEL_102:
            me->state = miCO;
            if ( WWW_TraceFlag[0] )
            {
              v24 = TraceFP();
              fprintf(v24, "HTMIME: Was C, found O, state now CO'\n");
            }
            return;
          }
          goto LABEL_104;
        }
      }
      else if ( ca != 65 )
      {
LABEL_104:
        if ( !WWW_TraceFlag[0] )
          goto bad_field_name;
        goto LABEL_105;
      }
      me->check_pointer = "che-control:";
      me->if_ok = miCACHE_CONTROL;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v23 = TraceFP();
        fprintf(v23, "HTMIME: Was C, found A, checking for 'che-control:'\n");
      }
      return;
    case miCO:
      if ( ca == 79 )
        goto LABEL_115;
      if ( ca > 79 )
      {
        if ( ca != 110 )
        {
          if ( ca == 111 )
          {
LABEL_115:
            me->check_pointer = "kie:";
            me->if_ok = miCOOKIE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v27 = TraceFP();
              fprintf(v27, "HTMIME: Was CO, found O, checking for 'kie:'\n");
            }
            return;
          }
LABEL_117:
          if ( WWW_TraceFlag[0] )
          {
            v28 = TraceFP();
            fprintf(v28, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'n' or 'o'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 78 )
      {
        goto LABEL_117;
      }
      me->state = miCON;
      if ( WWW_TraceFlag[0] )
      {
        v26 = TraceFP();
        fprintf(v26, "HTMIME: Was CO, found N, state now CON\n");
      }
      return;
    case miCON:
      if ( ca == 84 )
        goto LABEL_128;
      if ( ca > 84 )
      {
        if ( ca != 110 )
        {
          if ( ca == 116 )
          {
LABEL_128:
            me->check_pointer = "ent-";
            me->if_ok = miCONTENT_;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v30 = TraceFP();
              fprintf(v30, "HTMIME: Was CON, found T, checking for 'ent-'\n");
            }
            return;
          }
LABEL_130:
          if ( WWW_TraceFlag[0] )
          {
            v31 = TraceFP();
            fprintf(v31, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'n' or 't'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 78 )
      {
        goto LABEL_130;
      }
      me->check_pointer = "ection:";
      me->if_ok = miCONNECTION;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v29 = TraceFP();
        fprintf(v29, "HTMIME: Was CON, found N, checking for 'ection:'\n");
      }
      return;
    case miCONTENT_:
      if ( WWW_TraceFlag[0] )
      {
        v76 = TraceFP();
        fprintf(v76, "HTMIME: in case CONTENT_\n");
      }
      switch ( ca )
      {
        case 'B':
        case 'b':
          me->check_pointer = "ase:";
          me->if_ok = miCONTENT_BASE;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v77 = TraceFP();
            fprintf(v77, "HTMIME: Was CONTENT_, found B, checking for 'ase:'\n");
          }
          break;
        case 'D':
        case 'd':
          me->check_pointer = "isposition:";
          me->if_ok = miCONTENT_DISPOSITION;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v78 = TraceFP();
            fprintf(v78, "HTMIME: Was CONTENT_, found D, checking for 'isposition:'\n");
          }
          break;
        case 'E':
        case 'e':
          me->check_pointer = "ncoding:";
          me->if_ok = miCONTENT_ENCODING;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v79 = TraceFP();
            fprintf(v79, "HTMIME: Was CONTENT_, found E, checking for 'ncoding:'\n");
          }
          break;
        case 'F':
        case 'f':
          me->check_pointer = "eatures:";
          me->if_ok = miCONTENT_FEATURES;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v80 = TraceFP();
            fprintf(v80, "HTMIME: Was CONTENT_, found F, checking for 'eatures:'\n");
          }
          break;
        case 'L':
        case 'l':
          me->state = miCONTENT_L;
          if ( WWW_TraceFlag[0] )
          {
            v81 = TraceFP();
            fprintf(v81, "HTMIME: Was CONTENT_, found L, state now CONTENT_L\n");
          }
          break;
        case 'M':
        case 'm':
          me->check_pointer = "d5:";
          me->if_ok = miCONTENT_MD5;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v82 = TraceFP();
            fprintf(v82, "HTMIME: Was CONTENT_, found M, checking for 'd5:'\n");
          }
          break;
        case 'R':
        case 'r':
          me->check_pointer = "ange:";
          me->if_ok = miCONTENT_RANGE;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v83 = TraceFP();
            fprintf(v83, "HTMIME: Was CONTENT_, found R, checking for 'ange:'\n");
          }
          break;
        case 'T':
        case 't':
          me->state = miCONTENT_T;
          if ( WWW_TraceFlag[0] )
          {
            v84 = TraceFP();
            fprintf(v84, "HTMIME: Was CONTENT_, found T, state now CONTENT_T\n");
          }
          break;
        default:
          if ( WWW_TraceFlag[0] )
          {
            v85 = TraceFP();
            fprintf(v85, "HTMIME: Was CONTENT_, found nothing; bleah\n");
          }
          goto bad_field_name;
      }
      return;
    case miCONTENT_L:
      if ( WWW_TraceFlag[0] )
      {
        v86 = TraceFP();
        fprintf(v86, "HTMIME: in case CONTENT_L\n");
      }
      switch ( ca )
      {
        case 'A':
        case 'a':
          me->check_pointer = "nguage:";
          me->if_ok = miCONTENT_LANGUAGE;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v87 = TraceFP();
            fprintf(v87, "HTMIME: Was CONTENT_L, found A, checking for 'nguage:'\n");
          }
          break;
        case 'E':
        case 'e':
          me->check_pointer = "ngth:";
          me->if_ok = miCONTENT_LENGTH;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v88 = TraceFP();
            fprintf(v88, "HTMIME: Was CONTENT_L, found E, checking for 'ngth:'\n");
          }
          break;
        case 'O':
        case 'o':
          me->check_pointer = "cation:";
          me->if_ok = miCONTENT_LOCATION;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v89 = TraceFP();
            fprintf(v89, "HTMIME: Was CONTENT_L, found O, checking for 'cation:'\n");
          }
          break;
        default:
          if ( WWW_TraceFlag[0] )
          {
            v90 = TraceFP();
            fprintf(v90, "HTMIME: Was CONTENT_L, found nothing; bleah\n");
          }
          goto bad_field_name;
      }
      return;
    case miCONTENT_T:
      if ( WWW_TraceFlag[0] )
      {
        v91 = TraceFP();
        fprintf(v91, "HTMIME: in case CONTENT_T\n");
      }
      if ( ca == 89 )
        goto LABEL_336;
      if ( ca > 89 )
      {
        if ( ca != 114 )
        {
          if ( ca == 121 )
          {
LABEL_336:
            me->check_pointer = "pe:";
            me->if_ok = miCONTENT_TYPE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v93 = TraceFP();
              fprintf(v93, "HTMIME: Was CONTENT_T, found Y, checking for 'pe:'\n");
            }
            return;
          }
LABEL_338:
          if ( WWW_TraceFlag[0] )
          {
            v94 = TraceFP();
            fprintf(v94, "HTMIME: Was CONTENT_T, found nothing; bleah\n");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 82 )
      {
        goto LABEL_338;
      }
      me->check_pointer = "ansfer-encoding:";
      me->if_ok = miCONTENT_TRANSFER_ENCODING;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v92 = TraceFP();
        fprintf(v92, "HTMIME: Was CONTENT_T, found R, checking for 'ansfer-encoding:'\n");
      }
      return;
    case miE:
      if ( ca == 88 )
        goto LABEL_141;
      if ( ca > 88 )
      {
        if ( ca != 116 )
        {
          if ( ca == 120 )
          {
LABEL_141:
            me->check_pointer = "pires:";
            me->if_ok = miEXPIRES;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v33 = TraceFP();
              fprintf(v33, "HTMIME: Was E, found X, checking for 'pires:'\n");
            }
            return;
          }
LABEL_143:
          if ( WWW_TraceFlag[0] )
          {
            v34 = TraceFP();
            fprintf(v34, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'t' or 'x'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 84 )
      {
        goto LABEL_143;
      }
      me->check_pointer = "ag:";
      me->if_ok = miETAG;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v32 = TraceFP();
        fprintf(v32, "HTMIME: Was E, found T, checking for 'ag:'\n");
      }
      return;
    case miL:
      switch ( ca )
      {
        case 'A':
        case 'a':
          me->check_pointer = "st-modified:";
          me->if_ok = miLAST_MODIFIED;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v35 = TraceFP();
            fprintf(v35, "HTMIME: Was L, found A, checking for 'st-modified:'\n");
          }
          break;
        case 'I':
        case 'i':
          me->check_pointer = "nk:";
          me->if_ok = miLINK;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v36 = TraceFP();
            fprintf(v36, "HTMIME: Was L, found I, checking for 'nk:'\n");
          }
          break;
        case 'O':
        case 'o':
          me->check_pointer = "cation:";
          me->if_ok = miLOCATION;
          me->state = miCHECK;
          if ( WWW_TraceFlag[0] )
          {
            v37 = TraceFP();
            fprintf(v37, "HTMIME: Was L, found O, checking for 'cation:'\n");
          }
          break;
        default:
          if ( WWW_TraceFlag[0] )
          {
            v38 = TraceFP();
            fprintf(v38, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'a', 'i' or 'o'");
          }
          goto bad_field_name;
      }
      return;
    case miP:
      if ( ca == 85 )
        goto LABEL_163;
      if ( ca > 85 )
      {
        if ( ca != 114 )
        {
          if ( ca == 117 )
          {
LABEL_163:
            me->check_pointer = "blic:";
            me->if_ok = miPUBLIC;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v40 = TraceFP();
              fprintf(v40, "HTMIME: Was P, found U, checking for 'blic:'\n");
            }
            return;
          }
LABEL_165:
          if ( WWW_TraceFlag[0] )
          {
            v41 = TraceFP();
            fprintf(v41, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'r' or 'u'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 82 )
      {
        goto LABEL_165;
      }
      me->state = miPR;
      if ( WWW_TraceFlag[0] )
      {
        v39 = TraceFP();
        fprintf(v39, "HTMIME: Was P, found R, state now PR'\n");
      }
      return;
    case miPR:
      if ( ca == 79 )
        goto LABEL_176;
      if ( ca > 79 )
      {
        if ( ca != 97 )
        {
          if ( ca == 111 )
          {
LABEL_176:
            me->check_pointer = "xy-authenticate:";
            me->if_ok = miPROXY_AUTHENTICATE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v43 = TraceFP();
              fprintf(v43, "HTMIME: Was PR, found O, checking for 'xy-authenticate'\n");
            }
            return;
          }
          goto LABEL_178;
        }
LABEL_174:
        me->check_pointer = "gma:";
        me->if_ok = miPRAGMA;
        me->state = miCHECK;
        if ( WWW_TraceFlag[0] )
        {
          v42 = TraceFP();
          fprintf(v42, "HTMIME: Was PR, found A, checking for 'gma'\n");
        }
        return;
      }
      if ( ca == 65 )
        goto LABEL_174;
LABEL_178:
      if ( !WWW_TraceFlag[0] )
        goto bad_field_name;
LABEL_105:
      v25 = TraceFP();
      fprintf(v25, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'a' or 'o'");
bad_field_name:
      me->state = miJUNK_LINE;
      return;
    case miR:
      if ( ca == 69 || ca == 101 )
      {
        me->state = miRE;
        if ( WWW_TraceFlag[0] )
        {
          v44 = TraceFP();
          fprintf(v44, "HTMIME: Was R, found E\n");
        }
        return;
      }
      if ( WWW_TraceFlag[0] )
      {
        v45 = TraceFP();
        fprintf(v45, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'e'");
      }
      goto bad_field_name;
    case miRE:
      if ( ca == 84 )
        goto LABEL_195;
      if ( ca > 84 )
      {
        if ( ca != 102 )
        {
          if ( ca == 116 )
          {
LABEL_195:
            me->check_pointer = "ry-after:";
            me->if_ok = miRETRY_AFTER;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              check_pointer = me->check_pointer;
              v49 = TraceFP();
              fprintf(v49, "HTMIME: Was RE, found T, checking for '%s'\n", check_pointer);
            }
            return;
          }
LABEL_197:
          if ( WWW_TraceFlag[0] )
          {
            v50 = TraceFP();
            fprintf(v50, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'f' or 't'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 70 )
      {
        goto LABEL_197;
      }
      me->check_pointer = "resh:";
      me->if_ok = miREFRESH;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v46 = me->check_pointer;
        v47 = TraceFP();
        fprintf(v47, "HTMIME: Was RE, found F, checking for '%s'\n", v46);
      }
      return;
    case miS:
      if ( ca == 69 )
        goto LABEL_208;
      if ( ca > 69 )
      {
        if ( ca != 97 )
        {
          if ( ca == 101 )
          {
LABEL_208:
            me->state = miSE;
            if ( WWW_TraceFlag[0] )
            {
              v52 = TraceFP();
              fprintf(v52, "HTMIME: Was S, found E, state now SE'\n");
            }
            return;
          }
LABEL_210:
          if ( WWW_TraceFlag[0] )
          {
            v53 = TraceFP();
            fprintf(v53, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'a' or 'e'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 65 )
      {
        goto LABEL_210;
      }
      me->check_pointer = "fe:";
      me->if_ok = miSAFE;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v51 = TraceFP();
        fprintf(v51, "HTMIME: Was S, found A, checking for 'fe:'\n");
      }
      return;
    case miSE:
      if ( ca == 84 )
        goto LABEL_221;
      if ( ca > 84 )
      {
        if ( ca != 114 )
        {
          if ( ca == 116 )
          {
LABEL_221:
            me->check_pointer = "-cookie";
            me->if_ok = miSET_COOKIE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v55 = TraceFP();
              fprintf(v55, "HTMIME: Was SE, found T, checking for '-cookie'\n");
            }
            return;
          }
LABEL_223:
          if ( WWW_TraceFlag[0] )
          {
            v56 = TraceFP();
            fprintf(v56, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'r' or 't'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 82 )
      {
        goto LABEL_223;
      }
      me->check_pointer = "ver:";
      me->if_ok = miSERVER;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v54 = TraceFP();
        fprintf(v54, "HTMIME: Was SE, found R, checking for 'ver'\n");
      }
      return;
    case miSET_COOKIE:
      if ( ca == 50 )
      {
        me->check_pointer = ":";
        me->if_ok = miSET_COOKIE2;
        me->state = miCHECK;
        if ( WWW_TraceFlag[0] )
        {
          v58 = TraceFP();
          fprintf(v58, "HTMIME: Was SET_COOKIE, found 2, checking for ':'\n");
        }
        return;
      }
      if ( ca == 58 )
      {
        me->field = miSET_COOKIE1;
        me->state = miSKIP_GET_VALUE;
        if ( WWW_TraceFlag[0] )
        {
          v57 = TraceFP();
          fprintf(v57, "HTMIME: Was SET_COOKIE, found :, processing\n");
        }
        return;
      }
      if ( WWW_TraceFlag[0] )
      {
        v59 = TraceFP();
        fprintf(v59, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "':' or '2'");
      }
      goto bad_field_name;
    case miT:
      if ( ca == 82 )
        goto LABEL_242;
      if ( ca > 82 )
      {
        if ( ca != 105 )
        {
          if ( ca == 114 )
          {
LABEL_242:
            me->check_pointer = "ansfer-encoding:";
            me->if_ok = miTRANSFER_ENCODING;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v61 = TraceFP();
              fprintf(v61, "HTMIME: Was T, found R, checking for 'ansfer-encoding'\n");
            }
            return;
          }
LABEL_244:
          if ( WWW_TraceFlag[0] )
          {
            v62 = TraceFP();
            fprintf(v62, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'i' or 'r'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 73 )
      {
        goto LABEL_244;
      }
      me->check_pointer = "tle:";
      me->if_ok = miTITLE;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v60 = TraceFP();
        fprintf(v60, "HTMIME: Was T, found I, checking for 'tle:'\n");
      }
      return;
    case miU:
      if ( ca == 82 )
        goto LABEL_255;
      if ( ca > 82 )
      {
        if ( ca != 112 )
        {
          if ( ca == 114 )
          {
LABEL_255:
            me->check_pointer = "i:";
            me->if_ok = miURI;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v64 = TraceFP();
              fprintf(v64, "HTMIME: Was U, found R, checking for 'i:'\n");
            }
            return;
          }
LABEL_257:
          if ( WWW_TraceFlag[0] )
          {
            v65 = TraceFP();
            fprintf(v65, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'p' or 'r'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 80 )
      {
        goto LABEL_257;
      }
      me->check_pointer = "grade:";
      me->if_ok = miUPGRADE;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v63 = TraceFP();
        fprintf(v63, "HTMIME: Was U, found P, checking for 'grade:'\n");
      }
      return;
    case miV:
      if ( ca == 73 )
        goto LABEL_268;
      if ( ca > 73 )
      {
        if ( ca != 97 )
        {
          if ( ca == 105 )
          {
LABEL_268:
            me->check_pointer = "a:";
            me->if_ok = miVIA;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v67 = TraceFP();
              fprintf(v67, "HTMIME: Was V, found I, checking for 'a:'\n");
            }
            return;
          }
LABEL_270:
          if ( WWW_TraceFlag[0] )
          {
            v68 = TraceFP();
            fprintf(v68, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'a' or 'i'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 65 )
      {
        goto LABEL_270;
      }
      me->check_pointer = "ry:";
      me->if_ok = miVARY;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v66 = TraceFP();
        fprintf(v66, "HTMIME: Was V, found A, checking for 'ry:'\n");
      }
      return;
    case miW:
      if ( ca == 87 )
        goto LABEL_281;
      if ( ca > 87 )
      {
        if ( ca != 97 )
        {
          if ( ca == 119 )
          {
LABEL_281:
            me->check_pointer = "w-authenticate:";
            me->if_ok = miWWW_AUTHENTICATE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v70 = TraceFP();
              fprintf(v70, "HTMIME: Was W, found W, checking for 'w-authenticate:'\n");
            }
            return;
          }
LABEL_283:
          if ( WWW_TraceFlag[0] )
          {
            v71 = TraceFP();
            fprintf(v71, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, "'a' or 'w'");
          }
          goto bad_field_name;
        }
      }
      else if ( ca != 65 )
      {
        goto LABEL_283;
      }
      me->check_pointer = "rning:";
      me->if_ok = miWARNING;
      me->state = miCHECK;
      if ( WWW_TraceFlag[0] )
      {
        v69 = TraceFP();
        fprintf(v69, "HTMIME: Was W, found A, checking for 'rning:'\n");
      }
      return;
    case miSKIP_GET_VALUE:
LABEL_341:
      if ( ca == 10 )
      {
        me->fold_state = me->state;
        me->state = miNEWLINE;
        return;
      }
      if ( (unsigned __int8)ca <= 0x20u )
        return;
      me->value_pointer = me->value;
      me->state = miGET_VALUE;
      goto GET_VALUE;
    case miGET_VALUE:
      goto GET_VALUE;
    case miJUNK_LINE:
      goto LABEL_348;
    case miNEWLINE:
      if ( ca == 10 || (unsigned __int8)ca > 0x20u )
      {
        if ( me->fold_state == miGET_VALUE )
          dispatchField(me);
LABEL_43:
        me->net_ascii = 1;
        switch ( ca )
        {
          case 10:
            me->net_ascii = 0;
            pumpData(me);
            break;
          case 65:
          case 97:
            me->state = miA;
            if ( WWW_TraceFlag[0] )
            {
              v3 = TraceFP();
              fprintf(v3, "HTMIME: Got 'A' at beginning of line, state now A\n");
            }
            break;
          case 67:
          case 99:
            me->state = miC;
            if ( WWW_TraceFlag[0] )
            {
              v4 = TraceFP();
              fprintf(v4, "HTMIME: Got 'C' at beginning of line, state now C\n");
            }
            break;
          case 68:
          case 100:
            me->check_pointer = "ate:";
            me->if_ok = miDATE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v5 = TraceFP();
              fprintf(v5, "HTMIME: Got 'D' at beginning of line, checking for 'ate:'\n");
            }
            break;
          case 69:
          case 101:
            me->state = miE;
            if ( WWW_TraceFlag[0] )
            {
              v6 = TraceFP();
              fprintf(v6, "HTMIME: Got 'E' at beginning of line, state now E\n");
            }
            break;
          case 75:
          case 107:
            me->check_pointer = "eep-alive:";
            me->if_ok = miKEEP_ALIVE;
            me->state = miCHECK;
            if ( WWW_TraceFlag[0] )
            {
              v7 = TraceFP();
              fprintf(v7, "HTMIME: Got 'K' at beginning of line, checking for 'eep-alive:'\n");
            }
            break;
          case 76:
          case 108:
            me->state = miL;
            if ( WWW_TraceFlag[0] )
            {
              v8 = TraceFP();
              fprintf(v8, "HTMIME: Got 'L' at beginning of line, state now L\n");
            }
            break;
          case 80:
          case 112:
            me->state = miP;
            if ( WWW_TraceFlag[0] )
            {
              v9 = TraceFP();
              fprintf(v9, "HTMIME: Got 'P' at beginning of line, state now P\n");
            }
            break;
          case 82:
          case 114:
            me->state = miR;
            if ( WWW_TraceFlag[0] )
            {
              v10 = TraceFP();
              fprintf(v10, "HTMIME: Got 'R' at beginning of line, state now R\n");
            }
            break;
          case 83:
          case 115:
            me->state = miS;
            if ( WWW_TraceFlag[0] )
            {
              v11 = TraceFP();
              fprintf(v11, "HTMIME: Got 'S' at beginning of line, state now S\n");
            }
            break;
          case 84:
          case 116:
            me->state = miT;
            if ( WWW_TraceFlag[0] )
            {
              v12 = TraceFP();
              fprintf(v12, "HTMIME: Got 'T' at beginning of line, state now T\n");
            }
            break;
          case 85:
          case 117:
            me->state = miU;
            if ( WWW_TraceFlag[0] )
            {
              v13 = TraceFP();
              fprintf(v13, "HTMIME: Got 'U' at beginning of line, state now U\n");
            }
            break;
          case 86:
          case 118:
            me->state = miV;
            if ( WWW_TraceFlag[0] )
            {
              v14 = TraceFP();
              fprintf(v14, "HTMIME: Got 'V' at beginning of line, state now V\n");
            }
            break;
          case 87:
          case 119:
            me->state = miW;
            if ( WWW_TraceFlag[0] )
            {
              v15 = TraceFP();
              fprintf(v15, "HTMIME: Got 'W' at beginning of line, state now W\n");
            }
            break;
          default:
            goto bad_field_name;
        }
        return;
      }
      me->state = me->fold_state;
      if ( me->state != miGET_VALUE
        || !me->value_pointer
        || me->value_pointer == me->value
        || *(me->value_pointer - 1) <= 0x20u )
      {
        return;
      }
      ca = 32;
GET_VALUE:
      if ( ca == 10 )
      {
LABEL_348:
        if ( ca == 10 )
        {
          me->fold_state = me->state;
          me->state = miNEWLINE;
        }
        return;
      }
      if ( me->value_pointer < &me->value[5119] )
      {
        value_pointer = me->value_pointer;
        *value_pointer = ca;
        me->value_pointer = value_pointer + 1;
        return;
      }
      if ( WWW_TraceFlag[0] )
      {
        v96 = TraceFP();
        fprintf(v96, "HTMIME: *** Syntax error. (string too long)\n");
      }
      goto bad_field_name;
    case miCHECK:
      if ( ((*__ctype_b_loc())[(unsigned __int8)ca] & 0x100) != 0 )
        v100 = tolower((unsigned __int8)ca);
      else
        v100 = (unsigned __int8)ca;
      v72 = me->check_pointer;
      v73 = v100 == *v72;
      me->check_pointer = v72 + 1;
      if ( v73 )
      {
        if ( !*me->check_pointer )
          me->state = me->if_ok;
        return;
      }
      if ( WWW_TraceFlag[0] )
      {
        v74 = me->check_pointer - 1;
        v75 = TraceFP();
        fprintf(v75, "HTMIME: Bad character `%c' found where `%s' expected\n", ca, v74);
      }
      goto bad_field_name;
    case MIME_NET_ASCII:
      goto LABEL_33;
    default:
      return;
  }
}

//----- (081322E4) --------------------------------------------------------
void __cdecl HTMIME_put_string(HTStream_6 *me, const char *s)
{
  FILE *v2; // eax
  char *p; // [esp+24h] [ebp-4h]

  if ( me->state )
  {
    if ( me->state != MIME_IGNORE )
    {
      if ( WWW_TraceFlag[0] )
      {
        v2 = TraceFP();
        fprintf(v2, "HTMIME:  %s\n", s);
      }
      for ( p = (char *)s; *p; ++p )
        HTMIME_put_character(me, *p);
    }
  }
  else
  {
    me->targetClass.put_string((HTStream *)me->target, s);
  }
}

//----- (08132378) --------------------------------------------------------
void __cdecl HTMIME_write(HTStream_6 *me, const char *s, int l)
{
  FILE *v3; // edx
  char *p; // [esp+24h] [ebp-4h]

  if ( me->state )
  {
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "HTMIME:  %.*s\n", l, s);
    }
    for ( p = (char *)s; &s[l] > p; ++p )
      HTMIME_put_character(me, *p);
  }
  else
  {
    me->targetClass.put_block((HTStream *)me->target, s, l);
  }
}

//----- (08132412) --------------------------------------------------------
void __cdecl HTMIME_free(HTStream_6 *me)
{
  if ( me )
  {
    if ( me->location )
    {
      free(me->location);
      me->location = 0;
    }
    if ( me->compression_encoding )
    {
      free(me->compression_encoding);
      me->compression_encoding = 0;
    }
    if ( me->target )
      me->targetClass._free((HTStream *)me->target);
    free(me);
  }
}
// 81324A0: conditional instruction was optimized away because %me.4!=0

//----- (081324B6) --------------------------------------------------------
void __cdecl HTMIME_abort(HTStream_6 *me, HTError e)
{
  if ( me )
  {
    if ( me->location )
    {
      free(me->location);
      me->location = 0;
    }
    if ( me->compression_encoding )
    {
      free(me->compression_encoding);
      me->compression_encoding = 0;
    }
    if ( me->target )
      me->targetClass._abort((HTStream *)me->target, e);
    free(me);
  }
}
// 813254B: conditional instruction was optimized away because %me.4!=0

//----- (08132561) --------------------------------------------------------
HTStream_6 *__cdecl HTMIMEConvert(HTPresentation *pres, HTParentAnchor *anchor, HTStream_6 *sink)
{
  HTStream_6 *me; // [esp+24h] [ebp-4h]

  me = (HTStream_6 *)calloc(1u, 0x1474u);
  if ( !me )
    outofmem("../../../WWW/Library/Implementation/HTMIME.c", "HTMIMEConvert");
  me->isa = &HTMIME;
  me->sink = sink;
  me->anchor = anchor;
  me->anchor->safe = 0;
  me->anchor->no_cache = 0;
  if ( me->anchor->cache_control )
  {
    free(me->anchor->cache_control);
    me->anchor->cache_control = 0;
  }
  if ( me->anchor->SugFname )
  {
    free(me->anchor->SugFname);
    me->anchor->SugFname = 0;
  }
  if ( me->anchor->charset )
  {
    free(me->anchor->charset);
    me->anchor->charset = 0;
  }
  if ( me->anchor->content_type_params )
  {
    free(me->anchor->content_type_params);
    me->anchor->content_type_params = 0;
  }
  if ( me->anchor->content_language )
  {
    free(me->anchor->content_language);
    me->anchor->content_language = 0;
  }
  if ( me->anchor->content_encoding )
  {
    free(me->anchor->content_encoding);
    me->anchor->content_encoding = 0;
  }
  if ( me->anchor->content_base )
  {
    free(me->anchor->content_base);
    me->anchor->content_base = 0;
  }
  if ( me->anchor->content_disposition )
  {
    free(me->anchor->content_disposition);
    me->anchor->content_disposition = 0;
  }
  if ( me->anchor->content_location )
  {
    free(me->anchor->content_location);
    me->anchor->content_location = 0;
  }
  if ( me->anchor->content_md5 )
  {
    free(me->anchor->content_md5);
    me->anchor->content_md5 = 0;
  }
  me->anchor->content_length = 0;
  if ( me->anchor->date )
  {
    free(me->anchor->date);
    me->anchor->date = 0;
  }
  if ( me->anchor->expires )
  {
    free(me->anchor->expires);
    me->anchor->expires = 0;
  }
  if ( me->anchor->last_modified )
  {
    free(me->anchor->last_modified);
    me->anchor->last_modified = 0;
  }
  if ( me->anchor->ETag )
  {
    free(me->anchor->ETag);
    me->anchor->ETag = 0;
  }
  if ( me->anchor->server )
  {
    free(me->anchor->server);
    me->anchor->server = 0;
  }
  me->target = 0;
  me->state = miBEGINNING_OF_LINE;
  me->format = HTAtom_for("text/html");
  me->targetRep = pres->rep_out;
  me->boundary = 0;
  me->set_cookie = 0;
  me->set_cookie2 = 0;
  me->refresh_url = 0;
  me->c_t_encoding = 0;
  me->compression_encoding = 0;
  me->net_ascii = 0;
  HTAnchor_setUCInfoStage(me->anchor, current_char_set, 2, 1);
  HTAnchor_setUCInfoStage(me->anchor, current_char_set, 3, 1);
  return me;
}

//----- (08132A30) --------------------------------------------------------
HTStream_6 *__cdecl HTNetMIME(HTPresentation *pres, HTParentAnchor *anchor, HTStream_6 *sink)
{
  HTStream_6 *me; // [esp+24h] [ebp-4h]

  me = HTMIMEConvert(pres, anchor, sink);
  if ( !me )
    return 0;
  me->net_ascii = 1;
  return me;
}

//----- (08132A73) --------------------------------------------------------
HTStream_6 *__cdecl HTMIMERedirect(HTPresentation *pres, HTParentAnchor *anchor, HTStream_6 *sink)
{
  HTAtom *targetRep; // ebx
  HTStream_6 *me; // [esp+20h] [ebp-8h]

  me = HTMIMEConvert(pres, anchor, sink);
  if ( !me )
    return 0;
  me->pickup_redirection = 1;
  targetRep = me->targetRep;
  if ( targetRep == HTAtom_for("www/debug") && sink )
    me->no_streamstack = 1;
  return me;
}

//----- (08132AE1) --------------------------------------------------------
void __cdecl HTmmdec_base64(char **t, char *s)
{
  size_t v2; // eax
  char *p; // [esp+8h] [ebp-20h]
  char nw[4]; // [esp+Ch] [ebp-1Ch]
  char *bp_0; // [esp+10h] [ebp-18h]
  char *buf; // [esp+14h] [ebp-14h]
  int val; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int count; // [esp+20h] [ebp-8h]
  int d; // [esp+24h] [ebp-4h]

  v2 = strlen(s);
  buf = (char *)malloc(3 * v2 + 1);
  if ( !buf )
    outofmem("../../../WWW/Library/Implementation/HTMIME.c", "HTmmdec_base64");
  bp_0 = buf;
  while ( *s )
  {
    val = 0;
    if ( s[2] == 61 )
    {
      count = 1;
    }
    else if ( s[3] == 61 )
    {
      count = 2;
    }
    else
    {
      count = 3;
    }
    for ( j = 0; j <= count; ++j )
    {
      p = strchr(HTmm64, s[j]);
      if ( !p )
        return;
      d = (p - HTmm64) << (6 * (3 - j));
      val += d;
    }
    for ( j = 2; j >= 0; --j )
    {
      nw[j] = val;
      val >>= 8;
    }
    if ( count-- != 0 )
      *bp_0++ = nw[0];
    if ( count-- != 0 )
      *bp_0++ = nw[1];
    if ( count )
      *bp_0++ = nw[2];
    s += 4;
  }
  *bp_0 = 0;
  HTSACopy(t, buf);
  if ( buf )
    free(buf);
}

//----- (08132C83) --------------------------------------------------------
void __cdecl HTmmdec_quote(char **t, char *s)
{
  size_t v2; // eax
  char *v3; // eax
  char *p; // [esp+8h] [ebp-10h]
  char *bp_0; // [esp+Ch] [ebp-Ch]
  char *buf; // [esp+10h] [ebp-8h]

  v2 = strlen(s);
  buf = (char *)malloc(v2 + 1);
  if ( !buf )
    outofmem("../../../WWW/Library/Implementation/HTMIME.c", "HTmmdec_quote");
  bp_0 = buf;
  while ( *s )
  {
    if ( *s == 61 )
    {
      if ( s[1] && (p = strchr(HTmmquote, s[1])) != 0 )
      {
        if ( s[2] && (v3 = strchr(HTmmquote, s[2])) != 0 )
        {
          *bp_0++ = 16 * ((_BYTE)p - (unsigned __int8)HTmmquote) + (_BYTE)v3 - (unsigned __int8)HTmmquote;
          s += 3;
        }
        else
        {
          *bp_0++ = *s++;
        }
      }
      else
      {
        *bp_0++ = *s++;
      }
    }
    else
    {
      if ( *s == 95 )
        *bp_0 = 32;
      else
        *bp_0 = *s;
      ++bp_0;
      ++s;
    }
  }
  *bp_0 = 0;
  HTSACopy(t, buf);
  free(buf);
}
// 8132E12: conditional instruction was optimized away because %buf.4!=0

//----- (08132E28) --------------------------------------------------------
void __cdecl HTmmdecode(char **target, char *source)
{
  size_t v2; // eax
  int quote; // [esp+18h] [ebp-20h]
  int base64; // [esp+1Ch] [ebp-1Ch]
  char *u; // [esp+20h] [ebp-18h]
  char *t; // [esp+24h] [ebp-14h]
  char *ta; // [esp+24h] [ebp-14h]
  char *tb; // [esp+24h] [ebp-14h]
  const char *s; // [esp+28h] [ebp-10h]
  char *sa; // [esp+28h] [ebp-10h]
  char *m2buf; // [esp+2Ch] [ebp-Ch] BYREF
  char *mmbuf; // [esp+30h] [ebp-8h] BYREF
  char *buf; // [esp+34h] [ebp-4h]

  mmbuf = 0;
  m2buf = 0;
  v2 = strlen(source);
  buf = (char *)malloc(v2 + 1);
  if ( !buf )
    outofmem("../../../WWW/Library/Implementation/HTMIME.c", "HTmmdecode");
  s = source;
  u = buf;
  while ( *s )
  {
    base64 = strncasecomp(s, "=?ISO-2022-JP?B?", 16) == 0;
    quote = strncasecomp(s, "=?ISO-2022-JP?Q?", 16) == 0;
    if ( base64 || quote )
    {
      if ( HTmmcont )
      {
        for ( t = (char *)(s - 1); t >= source && (*t == 32 || *t == 9); --t )
          --u;
      }
      if ( !mmbuf )
        HTSACopy(&mmbuf, source);
      sa = (char *)(s + 16);
      ta = mmbuf;
      while ( *sa && (*sa != 63 || sa[1] != 61) )
      {
        *ta++ = *sa++;
        *ta = 0;
      }
      if ( *sa != 63 || sa[1] != 61 )
        goto end;
      s = sa + 2;
      *ta = 0;
      if ( base64 )
        HTmmdec_base64(&m2buf, mmbuf);
      if ( quote )
        HTmmdec_quote(&m2buf, mmbuf);
      for ( tb = m2buf; *tb; ++tb )
        *u++ = *tb;
      HTmmcont = 1;
    }
    else
    {
      if ( *s != 32 && *s != 9 )
        HTmmcont = 0;
      *u++ = *s++;
    }
  }
  *u = 0;
end:
  HTSACopy(target, buf);
  if ( m2buf )
  {
    free(m2buf);
    m2buf = 0;
  }
  if ( mmbuf )
  {
    free(mmbuf);
    mmbuf = 0;
  }
  if ( buf )
    free(buf);
}

//----- (081330B2) --------------------------------------------------------
int __cdecl HTrjis(char **t, char *s)
{
  size_t v2; // eax
  int kanji; // [esp+1Ch] [ebp-Ch]
  char *buf; // [esp+20h] [ebp-8h]
  char *p; // [esp+24h] [ebp-4h]
  char *pa; // [esp+24h] [ebp-4h]
  char *pb; // [esp+24h] [ebp-4h]
  char *sa; // [esp+34h] [ebp+Ch]
  char *sb; // [esp+34h] [ebp+Ch]

  kanji = 0;
  if ( !strchr(s, 27) && strchr(s, 36) )
  {
    v2 = strlen(s);
    buf = (char *)malloc(2 * v2 + 1);
    if ( !buf )
      outofmem("../../../WWW/Library/Implementation/HTMIME.c", "HTrjis");
    p = buf;
    while ( *s )
    {
      if ( !kanji && *s == 36 && (s[1] == 64 || s[1] == 66) )
      {
        if ( HTmaybekanji(s[2], s[3]) )
        {
          kanji = 1;
          *p = 27;
          pa = p + 1;
          *pa++ = *s;
          sa = s + 1;
          *pa++ = *sa;
          *pa = *++sa;
          p = pa + 1;
          s = sa + 1;
        }
        *p++ = *s++;
      }
      else if ( kanji && *s == 40 && (s[1] == 74 || s[1] == 66) )
      {
        kanji = 0;
        *p = 27;
        pb = p + 1;
        *pb = *s;
        sb = s + 1;
        pb[1] = *sb;
        p = pb + 2;
        s = sb + 1;
      }
      else
      {
        *p++ = *s++;
      }
    }
    *p = *s;
    HTSACopy(t, buf);
    free(buf);
    return 0;
  }
  else
  {
    if ( *t != s )
      HTSACopy(t, s);
    return 1;
  }
}
// 81332D6: conditional instruction was optimized away because %buf.4!=0

//----- (081332F6) --------------------------------------------------------
int __cdecl HTmaybekanji(int c1, int c2)
{
  int v3; // [esp+0h] [ebp-8h]
  int c2a; // [esp+14h] [ebp+Ch]

  if ( c2 <= 32 || c2 > 126 )
    return 0;
  if ( c1 <= 32 || c1 > 40 && c1 <= 47 || c1 > 116 )
    return 0;
  c2a = c2 - 32;
  switch ( c1 )
  {
    case '"':
      if ( c2a <= 14 || c2a > 25 )
      {
        if ( c2a <= 33 || c2a > 41 )
        {
          if ( c2a <= 48 || c2a > 59 )
          {
            if ( c2a <= 74 || c2a > 81 )
            {
              if ( c2a <= 89 || c2a > 93 )
                goto LABEL_55;
              v3 = 0;
            }
            else
            {
              v3 = 0;
            }
          }
          else
          {
            v3 = 0;
          }
        }
        else
        {
          v3 = 0;
        }
      }
      else
      {
        v3 = 0;
      }
      break;
    case '#':
      if ( c2a > 15 )
      {
        if ( c2a <= 25 || c2a > 32 )
        {
          if ( c2a <= 58 || c2a > 64 )
          {
            if ( c2a <= 90 )
              goto LABEL_55;
            v3 = 0;
          }
          else
          {
            v3 = 0;
          }
        }
        else
        {
          v3 = 0;
        }
      }
      else
      {
        v3 = 0;
      }
      break;
    case '$':
      if ( c2a <= 83 )
        goto LABEL_55;
      v3 = 0;
      break;
    case '%':
      if ( c2a <= 86 )
        goto LABEL_55;
      v3 = 0;
      break;
    case '&':
      if ( c2a <= 24 || c2a > 32 )
      {
        if ( c2a <= 56 )
          goto LABEL_55;
        v3 = 0;
      }
      else
      {
        v3 = 0;
      }
      break;
    case '\'':
      if ( c2a <= 33 || c2a > 48 )
      {
        if ( c2a <= 81 )
          goto LABEL_55;
        v3 = 0;
      }
      else
      {
        v3 = 0;
      }
      break;
    case '(':
      if ( c2a <= 32 )
        goto LABEL_55;
      v3 = 0;
      break;
    case 'O':
      if ( c2a <= 51 )
        goto LABEL_55;
      v3 = 0;
      break;
    case 't':
      if ( c2a <= 6 )
        goto LABEL_55;
      v3 = 0;
      break;
    default:
LABEL_55:
      v3 = 1;
      break;
  }
  return v3;
}

//----- (081334DC) --------------------------------------------------------
void free_NNTP_AuthInfo()
{
  void **object; // [esp+4h] [ebp-14h]
  HTList *cur; // [esp+14h] [ebp-4h]

  cur = NNTP_AuthInfo;
  if ( NNTP_AuthInfo )
  {
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (void **)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( *object )
      {
        free(*object);
        *object = 0;
      }
      if ( object[1] )
      {
        free(object[1]);
        object[1] = 0;
      }
      if ( object[2] )
      {
        free(object[2]);
        object[2] = 0;
      }
      free(object);
    }
    HTList_delete(NNTP_AuthInfo);
    NNTP_AuthInfo = 0;
  }
}
// 8133564: conditional instruction was optimized away because %var_14.4!=0

//----- (081335C7) --------------------------------------------------------
void load_NNTP_AuthInfo()
{
  NNTPAuth *auth; // [esp+18h] [ebp-910h]
  FILE *fp; // [esp+1Ch] [ebp-90Ch]
  char the_user[513]; // [esp+20h] [ebp-908h] BYREF
  char the_pass[513]; // [esp+221h] [ebp-707h] BYREF
  char the_host[513]; // [esp+422h] [ebp-506h] BYREF
  char buffer[513]; // [esp+623h] [ebp-305h] BYREF
  char fname[256]; // [esp+824h] [ebp-104h] BYREF
  unsigned int v7; // [esp+924h] [ebp-4h]

  v7 = __readgsdword(0x14u);
  LYAddPathToHome(fname, 0x100u, ".newsauth");
  fp = (FILE *)fopen64(fname, "r");
  if ( fp )
  {
    while ( fgets(buffer, 513, fp) )
    {
      if ( sscanf(buffer, "%s%s%s", the_host, the_pass, the_user) == 3 && the_host[0] && the_pass[0] && the_user[0] )
      {
        auth = (NNTPAuth *)calloc(1u, 0xCu);
        if ( !auth )
          break;
        HTSACopy(&auth->host, the_host);
        HTSACopy(&auth->pass, the_pass);
        HTSACopy(&auth->user, the_user);
        HTList_appendObject(NNTP_AuthInfo, auth);
      }
    }
    fclose(fp);
  }
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0813376D) --------------------------------------------------------
char *HTGetNewsHost()
{
  return HTNewsHost;
}

//----- (08133777) --------------------------------------------------------
void __cdecl HTSetNewsHost(const char *value)
{
  HTSACopy(&HTNewsHost, value);
}

//----- (08133792) --------------------------------------------------------
int initialize()
{
  char *v0; // eax
  const char *v1; // ebx
  FILE *v2; // eax
  const char *v3; // ebx
  FILE *v4; // eax
  char *p; // [esp+14h] [ebp-54h]
  FILE *fp; // [esp+18h] [ebp-50h]
  char server_name[65]; // [esp+1Fh] [ebp-49h] BYREF
  unsigned int v9; // [esp+60h] [ebp-8h]

  v9 = __readgsdword(0x14u);
  if ( LYGetEnv("NNTPSERVER") )
  {
    v0 = LYGetEnv("NNTPSERVER");
    HTSACopy(&HTNewsHost, v0);
    if ( WWW_TraceFlag[0] )
    {
      v1 = HTNewsHost;
      v2 = TraceFP();
      fprintf(v2, "HTNews: NNTPSERVER defined as `%s'\n", v1);
    }
  }
  else
  {
    fp = (FILE *)fopen64("/usr/local/lib/rn/server", "r");
    if ( fp )
    {
      if ( fgets(server_name, 65, fp) )
      {
        p = strchr(server_name, 10);
        if ( p )
          *p = 0;
        HTSACopy(&HTNewsHost, server_name);
        if ( WWW_TraceFlag[0] )
        {
          v3 = HTNewsHost;
          v4 = TraceFP();
          fprintf(v4, "HTNews: File %s defines news host as `%s'\n", "/usr/local/lib/rn/server", v3);
        }
      }
      fclose(fp);
    }
  }
  if ( !HTNewsHost )
    HTSACopy(&HTNewsHost, "news");
  s = -1;
  return 1;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (081338FB) --------------------------------------------------------
int __cdecl response_0(char *command)
{
  FILE *v1; // eax
  FILE *v2; // eax
  bool v3; // al
  FILE *v4; // eax
  int v5; // ebx
  FILE *v6; // eax
  int v7; // ebx
  FILE *v8; // eax
  int length; // [esp+20h] [ebp-18h]
  ssize_t status; // [esp+24h] [ebp-14h]
  int ich; // [esp+28h] [ebp-10h]
  char *p; // [esp+2Ch] [ebp-Ch]
  int result; // [esp+30h] [ebp-8h] BYREF

  p = response_text_0;
  if ( !command )
    goto LABEL_13;
  length = strlen(command);
  if ( WWW_TraceFlag[0] )
  {
    v1 = TraceFP();
    fprintf(v1, "NNTP command to be sent: %s", command);
  }
  status = write(s, command, length);
  if ( status < 0 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HTNews: Unable to send command. Disconnecting.\n");
    }
    close(s);
    s = -1;
    return status;
  }
  else
  {
LABEL_13:
    do
    {
      ich = HTGetCharacter();
      *p = ich;
      v3 = *p++ == 10;
      if ( v3 || p == &response_text_0[512] )
      {
        *(p - 1) = 0;
        if ( WWW_TraceFlag[0] )
        {
          v4 = TraceFP();
          fprintf(v4, "NNTP Response: %s\n", response_text_0);
        }
        sscanf(response_text_0, "%d", &result);
        return result;
      }
    }
    while ( ich != -1 );
    *(p - 1) = 0;
    if ( interrupted_in_htgetcharacter )
    {
      if ( WWW_TraceFlag[0] )
      {
        v5 = s;
        v6 = TraceFP();
        fprintf(v6, "HTNews: Interrupted on read, closing socket %d\n", v5);
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      v7 = s;
      v8 = TraceFP();
      fprintf(v8, "HTNews: EOF on read, closing socket %d\n", v7);
    }
    close(s);
    s = -1;
    if ( interrupted_in_htgetcharacter )
    {
      interrupted_in_htgetcharacter = 0;
      return -29998;
    }
    else
    {
      return -1;
    }
  }
}

//----- (08133AF4) --------------------------------------------------------
BOOLEAN __cdecl match(const char *unknown, const char *ctemplate)
{
  int v3; // [esp+4h] [ebp-14h]

  while ( *unknown && *ctemplate )
  {
    v3 = ((*__ctype_b_loc())[*(unsigned __int8 *)unknown] & 0x200) != 0 ? toupper(*(unsigned __int8 *)unknown) : *(unsigned __int8 *)unknown;
    if ( v3 != *ctemplate )
      break;
    ++unknown;
    ++ctemplate;
  }
  return *ctemplate == 0;
}

//----- (08133B85) --------------------------------------------------------
NNTPAuthResult __cdecl HTHandleAuthInfo(char *host)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  NNTPAuth *object; // [esp+20h] [ebp-228h]
  int tries; // [esp+28h] [ebp-220h]
  int triesa; // [esp+28h] [ebp-220h]
  int status; // [esp+2Ch] [ebp-21Ch]
  int statusa; // [esp+2Ch] [ebp-21Ch]
  char *msg; // [esp+30h] [ebp-218h] BYREF
  char *PassWord; // [esp+34h] [ebp-214h]
  char *UserName; // [esp+38h] [ebp-210h]
  NNTPAuth *auth; // [esp+3Ch] [ebp-20Ch]
  HTList *cur; // [esp+40h] [ebp-208h]
  char buffer[512]; // [esp+44h] [ebp-204h] BYREF
  unsigned int v23; // [esp+244h] [ebp-4h]

  v23 = __readgsdword(0x14u);
  cur = 0;
  auth = 0;
  UserName = 0;
  PassWord = 0;
  msg = 0;
  if ( dump_output_immediately || !host || !*host )
    return 0;
  if ( !NNTP_AuthInfo )
  {
    NNTP_AuthInfo = HTList_new();
    load_NNTP_AuthInfo();
  }
  cur = NNTP_AuthInfo;
  while ( 1 )
  {
    if ( cur && (cur = cur->next) != 0 )
      object = (NNTPAuth *)cur->object;
    else
      object = 0;
    auth = object;
    if ( !object )
      break;
    if ( !strcmp(auth->host, host) )
    {
      UserName = auth->user;
      PassWord = auth->pass;
      break;
    }
  }
  buffer[511] = 0;
  tries = 3;
  while ( 1 )
  {
    if ( !UserName )
    {
      v1 = gettext("Username for news host '%s':");
      HTSprintf0(&msg, v1, host);
      UserName = HTPrompt(msg, 0);
      if ( msg )
      {
        free(msg);
        msg = 0;
      }
      if ( !UserName || !*UserName )
      {
        if ( UserName )
        {
          free(UserName);
          UserName = 0;
        }
        return 0;
      }
    }
    sprintf(buffer, "AUTHINFO USER %.*s%c%c", 495, UserName, 13, 10);
    status = response_0(buffer);
    if ( status < 0 )
    {
      if ( status == -29998 )
      {
        mustshow[0] = 1;
        v2 = gettext("Connection interrupted.");
        HTProgress(v2);
      }
      else
      {
        v3 = gettext("Connection closed ???");
        HTAlert(v3);
      }
      if ( auth )
      {
        if ( auth->user != UserName )
        {
          if ( auth->user )
          {
            free(auth->user);
            auth->user = 0;
          }
          auth->user = UserName;
        }
      }
      else if ( UserName )
      {
        free(UserName);
        UserName = 0;
      }
      return 502;
    }
    if ( status == 281 )
    {
      if ( auth )
      {
        if ( auth->user != UserName )
        {
          if ( auth->user )
          {
            free(auth->user);
            auth->user = 0;
          }
          auth->user = UserName;
        }
      }
      else
      {
        auth = (NNTPAuth *)calloc(1u, 0xCu);
        if ( auth )
        {
          HTSACopy(&auth->host, host);
          auth->user = UserName;
          HTList_appendObject(NNTP_AuthInfo, auth);
        }
      }
      return 281;
    }
    if ( status == 381 )
      break;
    HTAlert(response_text_0);
    if ( --tries > 0 )
    {
      v4 = gettext("Change username?");
      if ( HTConfirm(v4) )
      {
        if ( (!auth || auth->user != UserName) && UserName )
        {
          free(UserName);
          UserName = 0;
        }
        v5 = gettext("Username:");
        UserName = HTPrompt(v5, UserName);
        if ( UserName )
        {
          if ( *UserName )
            continue;
        }
      }
    }
    if ( auth )
    {
      if ( auth->user != UserName && auth->user )
      {
        free(auth->user);
        auth->user = 0;
      }
      if ( auth->pass )
      {
        free(auth->pass);
        auth->pass = 0;
      }
    }
    if ( UserName )
    {
      free(UserName);
      UserName = 0;
    }
    return 0;
  }
  triesa = 3;
  do
  {
    if ( !PassWord )
    {
      v6 = gettext("Password for news host '%s':");
      HTSprintf0(&msg, v6, host);
      PassWord = HTPromptPassword(msg);
      if ( msg )
      {
        free(msg);
        msg = 0;
      }
      if ( !PassWord || !*PassWord )
      {
        if ( PassWord )
        {
          free(PassWord);
          PassWord = 0;
        }
        return 0;
      }
    }
    sprintf(buffer, "AUTHINFO PASS %.*s%c%c", 495, PassWord, 13, 10);
    statusa = response_0(buffer);
    if ( statusa < 0 )
    {
      if ( statusa == -29998 )
      {
        mustshow[0] = 1;
        v7 = gettext("Connection interrupted.");
        HTProgress(v7);
      }
      else
      {
        v8 = gettext("Connection closed ???");
        HTAlert(v8);
      }
      if ( auth )
      {
        if ( auth->user != UserName )
        {
          if ( auth->user )
          {
            free(auth->user);
            auth->user = 0;
          }
          auth->user = UserName;
        }
        if ( auth->pass != PassWord )
        {
          if ( auth->pass )
          {
            free(auth->pass);
            auth->pass = 0;
          }
          auth->pass = PassWord;
        }
      }
      else
      {
        if ( UserName )
        {
          free(UserName);
          UserName = 0;
        }
        if ( PassWord )
        {
          free(PassWord);
          PassWord = 0;
        }
      }
      return 502;
    }
    if ( statusa == 502 )
    {
      HTAlert(response_text_0);
      if ( auth )
      {
        if ( auth->user == UserName )
          UserName = 0;
        if ( auth->user )
        {
          free(auth->user);
          auth->user = 0;
        }
        if ( auth->pass == PassWord )
          PassWord = 0;
        if ( auth->pass )
        {
          free(auth->pass);
          auth->pass = 0;
        }
      }
      if ( UserName )
      {
        free(UserName);
        UserName = 0;
      }
      if ( PassWord )
      {
        free(PassWord);
        PassWord = 0;
      }
      return 502;
    }
    if ( statusa == 281 )
    {
      if ( auth )
      {
        if ( auth->user != UserName )
        {
          if ( auth->user )
          {
            free(auth->user);
            auth->user = 0;
          }
          auth->user = UserName;
        }
        if ( auth->pass != PassWord )
        {
          if ( auth->pass )
          {
            free(auth->pass);
            auth->pass = 0;
          }
          auth->pass = PassWord;
        }
      }
      else
      {
        auth = (NNTPAuth *)calloc(1u, 0xCu);
        if ( auth )
        {
          HTSACopy(&auth->host, host);
          auth->user = UserName;
          auth->pass = PassWord;
          HTList_appendObject(NNTP_AuthInfo, auth);
        }
      }
      return 281;
    }
    HTAlert(response_text_0);
    if ( auth && auth->pass == PassWord )
    {
      PassWord = 0;
    }
    else if ( PassWord )
    {
      free(PassWord);
      PassWord = 0;
    }
    if ( --triesa <= 0 )
      break;
    v9 = gettext("Change password?");
  }
  while ( HTConfirm(v9) );
  if ( auth )
  {
    if ( auth->user == UserName )
      UserName = 0;
    if ( auth->user )
    {
      free(auth->user);
      auth->user = 0;
    }
    if ( auth->pass )
    {
      free(auth->pass);
      auth->pass = 0;
    }
  }
  if ( UserName )
  {
    free(UserName);
    UserName = 0;
  }
  return 0;
}
// 81340E8: conditional instruction was optimized away because %tries.4>=1
// 81340F8: conditional instruction was optimized away because %status.4==17D
// 81346AE: conditional instruction was optimized away because %tries.4>=1

//----- (081346D7) --------------------------------------------------------
char *__cdecl author_name(char *email)
{
  const char *v1; // ebx
  FILE *v2; // eax
  bool v3; // al
  bool v4; // al
  char *e; // [esp+1Ch] [ebp-Ch]
  char *ea; // [esp+1Ch] [ebp-Ch]
  char *eb; // [esp+1Ch] [ebp-Ch]
  char *p; // [esp+20h] [ebp-8h]
  char *pa; // [esp+20h] [ebp-8h]

  HTSACopy(&name, email);
  if ( WWW_TraceFlag[0] )
  {
    v1 = name;
    v2 = TraceFP();
    fprintf(v2, "Trying to find name in: %s\n", v1);
  }
  p = strrchr(name, 40);
  if ( p && (e = strrchr(name, 41)) != 0 && e > p )
  {
    *e = 0;
    return HTStrip(p + 1);
  }
  else
  {
    pa = strrchr(name, 60);
    if ( pa )
    {
      ea = strrchr(name, 62);
      if ( ea )
      {
        v3 = ea > pa;
        eb = ea + 1;
        if ( v3 )
        {
          do
          {
            *pa = *eb;
            v4 = *pa++ != 0;
            ++eb;
          }
          while ( v4 );
        }
      }
    }
    return HTStrip(name);
  }
}

//----- (08134817) --------------------------------------------------------
char *__cdecl author_address(char *email)
{
  const char *v1; // ebx
  FILE *v2; // eax
  char *e; // [esp+18h] [ebp-10h]
  char *ea; // [esp+18h] [ebp-10h]
  char *eb; // [esp+18h] [ebp-10h]
  char *ec; // [esp+18h] [ebp-10h]
  char *at; // [esp+1Ch] [ebp-Ch]
  char *ata; // [esp+1Ch] [ebp-Ch]
  char *atb; // [esp+1Ch] [ebp-Ch]
  char *p; // [esp+20h] [ebp-8h]
  char *pa; // [esp+20h] [ebp-8h]
  char *pb; // [esp+20h] [ebp-8h]
  char *pc; // [esp+20h] [ebp-8h]

  HTSACopy(&address, email);
  if ( WWW_TraceFlag[0] )
  {
    v1 = address;
    v2 = TraceFP();
    fprintf(v2, "Trying to find address in: %s\n", v1);
  }
  p = strrchr(address, 60);
  if ( p && (e = strrchr(p, 62)) != 0 && (at = strrchr(p, 64)) != 0 && at < e )
  {
    *e = 0;
    return HTStrip(p + 1);
  }
  else
  {
    pa = strrchr(address, 40);
    if ( pa && (ea = strrchr(address, 41)) != 0 && (ata = strchr(address, 64)) != 0 && ea > pa && ata < ea )
    {
      *pa = 0;
      return HTStrip(address);
    }
    else
    {
      atb = strrchr(address, 64);
      if ( atb && atb > address )
      {
        pb = atb - 1;
        eb = atb + 1;
        while ( pb > address && ((*__ctype_b_loc())[(unsigned __int8)*pb] & 0x2000) == 0 )
          --pb;
        while ( *eb && ((*__ctype_b_loc())[(unsigned __int8)*eb] & 0x2000) == 0 )
          ++eb;
        *eb = 0;
        return HTStrip(pb);
      }
      else
      {
        for ( pc = address; ((*__ctype_b_loc())[(unsigned __int8)*pc] & 0x2000) != 0; ++pc )
          ;
        for ( ec = pc; ((*__ctype_b_loc())[(unsigned __int8)*ec] & 0x2000) == 0 && *ec; ++ec )
          ;
        *ec = 0;
        return pc;
      }
    }
  }
}

//----- (08134A9D) --------------------------------------------------------
void __cdecl start_anchor(const char *href)
{
  const char *value[25]; // [esp+30h] [ebp-88h] BYREF
  int i; // [esp+94h] [ebp-24h]
  BOOLEAN present[25]; // [esp+9Bh] [ebp-1Dh] BYREF
  unsigned int v4; // [esp+B4h] [ebp-4h]

  v4 = __readgsdword(0x14u);
  for ( i = 0; i <= 24; ++i )
    present[i] = i == 6;
  value[6] = href;
  targetClass.start_element((HTStructured *)target, 0, present, value, -1, 0);
}

//----- (08134B31) --------------------------------------------------------
void __cdecl start_link(const char *href, const char *rev)
{
  bool v2; // [esp+1Ch] [ebp-5Ch]
  const char *value[14]; // [esp+28h] [ebp-50h] BYREF
  int i; // [esp+60h] [ebp-18h]
  BOOLEAN present[14]; // [esp+66h] [ebp-12h] BYREF
  unsigned int v6; // [esp+74h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  for ( i = 0; i <= 13; ++i )
  {
    v2 = i == 3 || i == 9;
    present[i] = v2;
  }
  value[3] = href;
  value[9] = rev;
  targetClass.start_element((HTStructured *)target, 69, present, value, -1, 0);
}

//----- (08134BE4) --------------------------------------------------------
void __cdecl start_list(int seqnum)
{
  bool v1; // [esp+24h] [ebp-64h]
  const char *value[12]; // [esp+30h] [ebp-58h] BYREF
  int i; // [esp+60h] [ebp-28h]
  char SeqNum[20]; // [esp+64h] [ebp-24h] BYREF
  BOOLEAN present[12]; // [esp+78h] [ebp-10h] BYREF
  unsigned int v6; // [esp+84h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  for ( i = 0; i <= 11; ++i )
  {
    v1 = i == 7 || i == 8;
    present[i] = v1;
  }
  sprintf(SeqNum, "%d", seqnum);
  value[7] = SeqNum;
  value[8] = SeqNum;
  targetClass.start_element((HTStructured *)target, 80, present, value, -1, 0);
}

//----- (08134CA8) --------------------------------------------------------
void __cdecl write_anchor(const char *text, const char *addr)
{
  char *q; // [esp+24h] [ebp-214h] BYREF
  const char *p; // [esp+28h] [ebp-210h]
  char href[513]; // [esp+2Fh] [ebp-209h] BYREF
  unsigned int v5; // [esp+230h] [ebp-8h]

  v5 = __readgsdword(0x14u);
  for ( p = addr; *p && *p != 62 && *p > 0x20u && *p != 44; ++p )
    ;
  if ( strlen(NewsHREF) + p - addr + 1 > 0x200 )
  {
    q = 0;
    HTSprintf0(&q, "%s%.*s", NewsHREF, p - addr, addr);
  }
  else
  {
    q = href;
    strcpy(href, NewsHREF);
    strncat(href, addr, p - addr);
  }
  start_anchor(q);
  targetClass.put_string((HTStructured *)target, text);
  targetClass.end_element((HTStructured *)target, 0, 0);
  if ( q != href )
  {
    if ( q )
      free(q);
  }
}

//----- (08134E74) --------------------------------------------------------
void __cdecl write_anchors(char *text)
{
  char *end; // [esp+1Ch] [ebp-Ch]
  char c; // [esp+27h] [ebp-1h]

  while ( 1 )
  {
    while ( *text && (unsigned __int8)*text <= 0x20u )
      ++text;
    if ( !*text )
      break;
    for ( end = text; *end && *end != 32 && *end != 44; ++end )
      ;
    if ( *end )
      ++end;
    c = *end;
    *end = 0;
    if ( *text == 60 )
      write_anchor(text, text + 1);
    else
      write_anchor(text, text);
    targetClass.start_element((HTStructured *)target, 20, 0, 0, -1, 0);
    *end = c;
    text = end;
  }
}

//----- (08134F70) --------------------------------------------------------
void abort_socket()
{
  int v0; // ebx
  FILE *v1; // eax

  if ( WWW_TraceFlag[0] )
  {
    v0 = s;
    v1 = TraceFP();
    fprintf(v1, "HTNews: EOF on read, closing socket %d\n", v0);
  }
  close(s);
  if ( rawtext[0] )
  {
    rawtargetClass.put_string(rawtarget, "Network Error: connection lost\n");
  }
  else
  {
    targetClass.put_string((HTStructured *)target, "Network Error: connection lost");
    targetClass.put_character((HTStructured *)target, 10);
  }
  s = -1;
}

//----- (08135015) --------------------------------------------------------
BOOLEAN __cdecl valid_header(char *line)
{
  char *space; // [esp+20h] [ebp-8h]
  char *colon; // [esp+24h] [ebp-4h]

  if ( *line == 32 || *line == 9 )
    return 1;
  colon = strchr(line, 58);
  space = strchr(line, 32);
  return ((*__ctype_b_loc())[(unsigned __int8)*line] & 0x400) != 0 && colon && colon + 1 == space;
}

//----- (081350A6) --------------------------------------------------------
void __cdecl post_article(char *postfile)
{
  char *v1; // eax
  size_t v2; // eax
  size_t v3; // eax
  char *v4; // [esp+1Ch] [ebp-43Ch]
  int llen; // [esp+2Ch] [ebp-42Ch]
  int llena; // [esp+2Ch] [ebp-42Ch]
  int blen; // [esp+30h] [ebp-428h]
  int seen_fromline; // [esp+34h] [ebp-424h]
  int seen_header; // [esp+38h] [ebp-420h]
  int in_header; // [esp+3Ch] [ebp-41Ch]
  FILE *fd; // [esp+40h] [ebp-418h]
  char *cp; // [esp+48h] [ebp-410h]
  char crlf[3]; // [esp+4Dh] [ebp-40Bh] BYREF
  char buf[512]; // [esp+50h] [ebp-408h] BYREF
  char line[512]; // [esp+250h] [ebp-208h] BYREF
  unsigned int v16; // [esp+450h] [ebp-8h]

  v16 = __readgsdword(0x14u);
  in_header = 1;
  seen_header = 0;
  seen_fromline = 0;
  blen = 0;
  if ( postfile )
    v4 = postfile;
  else
    v4 = (char *)&byte_818EC67;
  fd = (FILE *)fopen64(v4, "r");
  if ( !fd )
  {
    v1 = gettext("Cannot open temporary file for news POST.");
    HTAlert(v1);
    return;
  }
  buf[0] = 0;
  sprintf(crlf, "%c%c", 13, 10);
  while ( fgets(line, 510, fd) )
  {
    cp = strchr(line, 10);
    if ( cp )
      *cp = 0;
    if ( line[0] == 46 )
    {
      v2 = strlen(buf);
      memcpy(&buf[v2], ".", 2u);
      ++blen;
    }
    llen = strlen(line);
    if ( in_header && !strncasecomp(line, "From:", 5) )
    {
      seen_header = 1;
      seen_fromline = 1;
    }
    if ( !in_header || line[0] )
    {
      if ( !in_header )
        goto LABEL_24;
      if ( valid_header(line) )
      {
        seen_header = 1;
        goto LABEL_24;
      }
    }
    else if ( seen_header )
    {
      in_header = 0;
      if ( !seen_fromline )
      {
        if ( blen > 476 )
        {
          write(s, buf, blen);
          blen = 0;
          buf[0] = 0;
        }
        v3 = strlen(buf);
        memcpy(&buf[v3], "From: anonymous@nowhere.you.know", 0x21u);
        strcat(buf, crlf);
        blen += 34;
      }
LABEL_24:
      strcat(line, crlf);
      llena = llen + 2;
      if ( llena + blen > 510 )
      {
        write(s, buf, blen);
        blen = 0;
        buf[0] = 0;
      }
      strcat(buf, line);
      blen += llena;
    }
  }
  fclose(fd);
  remove(postfile);
  if ( blen > 507 )
  {
    write(s, buf, blen);
    blen = 0;
    buf[0] = 0;
  }
  strcat(buf, ".");
  strcat(buf, crlf);
  write(s, buf, blen + 3);
  if ( response_0(0) == 240 )
    HTProgress(response_text_0);
  else
    HTAlert(response_text_0);
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (0813550D) --------------------------------------------------------
char *__cdecl decode_mime(char **str)
{
  HTmmdecode(str, *str);
  if ( HTrjis(str, *str) )
    return *str;
  else
    return empty_11029;
}

//----- (08135555) --------------------------------------------------------
int __cdecl read_article(HTParentAnchor *thisanchor)
{
  int v1; // ebx
  FILE *v2; // eax
  FILE *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v22; // eax
  int v23; // ebx
  FILE *v24; // eax
  FILE *v25; // eax
  char v26; // dl
  char *v27; // eax
  char v28; // dl
  char v29; // dl
  char *v30; // eax
  char v31; // dl
  char *email; // [esp+24h] [ebp-284h]
  const char *s; // [esp+2Ch] [ebp-27Ch]
  char *at; // [esp+40h] [ebp-268h]
  char *q; // [esp+44h] [ebp-264h]
  char *p2; // [esp+48h] [ebp-260h]
  const char *p2a; // [esp+48h] [ebp-260h]
  const char *l; // [esp+4Ch] [ebp-25Ch]
  int ich_0; // [esp+50h] [ebp-258h]
  char *cp1; // [esp+54h] [ebp-254h]
  char *temp; // [esp+58h] [ebp-250h] BYREF
  char *msgid; // [esp+5Ch] [ebp-24Ch]
  int i; // [esp+60h] [ebp-248h]
  int ich; // [esp+64h] [ebp-244h]
  const char *ccp; // [esp+68h] [ebp-240h]
  char *cp; // [esp+6Ch] [ebp-23Ch]
  char *p; // [esp+70h] [ebp-238h]
  char *href; // [esp+74h] [ebp-234h] BYREF
  char *followupto; // [esp+78h] [ebp-230h] BYREF
  char *newsgroups; // [esp+7Ch] [ebp-22Ch] BYREF
  char *references; // [esp+80h] [ebp-228h] BYREF
  char *organization; // [esp+84h] [ebp-224h] BYREF
  char *date; // [esp+88h] [ebp-220h] BYREF
  char *replyto; // [esp+8Ch] [ebp-21Ch] BYREF
  char *from; // [esp+90h] [ebp-218h] BYREF
  char *subject; // [esp+94h] [ebp-214h] BYREF
  char *full_line; // [esp+98h] [ebp-210h] BYREF
  char c; // [esp+9Dh] [ebp-20Bh]
  BOOLEAN done; // [esp+9Eh] [ebp-20Ah]
  char line[513]; // [esp+9Fh] [ebp-209h] BYREF
  unsigned int v63; // [esp+2A0h] [ebp-8h]

  v63 = __readgsdword(0x14u);
  full_line = 0;
  subject = 0;
  from = 0;
  replyto = 0;
  date = 0;
  organization = 0;
  references = 0;
  newsgroups = 0;
  followupto = 0;
  href = 0;
  p = line;
  done = 0;
  if ( diagnostic || rawtext[0] )
  {
LABEL_175:
    if ( !rawtext[0] )
    {
      if ( diagnostic )
        targetClass.start_element((HTStructured *)target, 117, 0, 0, -1, 0);
      else
        targetClass.start_element((HTStructured *)target, 86, 0, 0, -1, 0);
      targetClass.put_character((HTStructured *)target, 10);
    }
    p = line;
    while ( 1 )
    {
      if ( done )
        goto LABEL_260;
      ich_0 = HTGetCharacter();
      *p++ = ich_0;
      if ( ich_0 == -1 )
        break;
      if ( (_BYTE)ich_0 == 10 || p == &line[512] )
      {
        *p++ = 0;
        if ( WWW_TraceFlag[0] )
        {
          v25 = TraceFP();
          fprintf(v25, "B %s", line);
        }
        if ( line[0] == 46 )
        {
          if ( line[1] <= 0x1Fu )
          {
            done = 1;
LABEL_260:
            if ( rawtext[0] )
              return 200;
            if ( diagnostic )
              targetClass.end_element((HTStructured *)target, 117, 0);
            else
              targetClass.end_element((HTStructured *)target, 86, 0);
            targetClass.put_character((HTStructured *)target, 10);
            return 200;
          }
          if ( rawtext[0] )
            rawtargetClass.put_string(rawtarget, &line[1]);
          else
            targetClass.put_string((HTStructured *)target, &line[1]);
        }
        else if ( rawtext[0] )
        {
          rawtargetClass.put_string(rawtarget, line);
        }
        else if ( !diagnostic && scan_for_buried_news_references )
        {
          for ( l = line; ; l = q + 1 )
          {
            p2a = strstr(l, "rticle <");
            if ( !p2a )
              break;
            q = strrchr(p2a, 62);
            at = strrchr(p2a, 64);
            if ( !q || !at || at >= q )
              break;
            c = q[1];
            q[1] = 0;
            p2 = (char *)(p2a + 7);
            *p2 = 0;
            while ( *l )
            {
              if ( !strncmp(l, "news:", 5u)
                || !strncmp(l, "snews://", 8u)
                || !strncmp(l, "nntp://", 7u)
                || !strncmp(l, "snewspost:", 0xAu)
                || !strncmp(l, "snewsreply:", 0xBu)
                || !strncmp(l, "newspost:", 9u)
                || !strncmp(l, "newsreply:", 0xAu)
                || !strncmp(l, "ftp://", 6u)
                || !strncmp(l, "file:/", 6u)
                || !strncmp(l, "finger://", 9u)
                || !strncmp(l, "http://", 7u)
                || !strncmp(l, "https://", 8u)
                || !strncmp(l, "wais://", 7u)
                || !strncmp(l, "mailto:", 7u)
                || !strncmp(l, "cso://", 6u)
                || !strncmp(l, "gopher://", 9u) )
              {
                HTSACopy(&href, l);
                v27 = strtok(href, " \r\n\t,>)\"");
                start_anchor(v27);
                while ( *l && !strchr(" \r\n\t,>)\"", *l) )
                {
                  v28 = *l++;
                  targetClass.put_character((HTStructured *)target, v28);
                }
                targetClass.end_element((HTStructured *)target, 0, 0);
                if ( href )
                {
                  free(href);
                  href = 0;
                }
              }
              else
              {
                v26 = *l++;
                targetClass.put_character((HTStructured *)target, v26);
              }
            }
            *p2 = 60;
            *q = 0;
            start_anchor(p2 + 1);
            *q = 62;
            targetClass.put_string((HTStructured *)target, p2);
            targetClass.end_element((HTStructured *)target, 0, 0);
            q[1] = c;
          }
          while ( *l )
          {
            if ( !strncmp(l, "news:", 5u)
              || !strncmp(l, "snews://", 8u)
              || !strncmp(l, "nntp://", 7u)
              || !strncmp(l, "snewspost:", 0xAu)
              || !strncmp(l, "snewsreply:", 0xBu)
              || !strncmp(l, "newspost:", 9u)
              || !strncmp(l, "newsreply:", 0xAu)
              || !strncmp(l, "ftp://", 6u)
              || !strncmp(l, "file:/", 6u)
              || !strncmp(l, "finger://", 9u)
              || !strncmp(l, "http://", 7u)
              || !strncmp(l, "https://", 8u)
              || !strncmp(l, "wais://", 7u)
              || !strncmp(l, "mailto:", 7u)
              || !strncmp(l, "cso://", 6u)
              || !strncmp(l, "gopher://", 9u) )
            {
              HTSACopy(&href, l);
              v30 = strtok(href, " \r\n\t,>)\"");
              start_anchor(v30);
              while ( *l && !strchr(" \r\n\t,>)\"", *l) )
              {
                v31 = *l++;
                targetClass.put_character((HTStructured *)target, v31);
              }
              targetClass.end_element((HTStructured *)target, 0, 0);
              if ( href )
              {
                free(href);
                href = 0;
              }
            }
            else
            {
              v29 = *l++;
              targetClass.put_character((HTStructured *)target, v29);
            }
          }
        }
        else
        {
          targetClass.put_string((HTStructured *)target, line);
        }
        p = line;
      }
    }
    if ( interrupted_in_htgetcharacter )
    {
      interrupted_in_htgetcharacter = 0;
      if ( WWW_TraceFlag[0] )
      {
        v23 = ::s;
        v24 = TraceFP();
        fprintf(v24, "HTNews: Interrupted on read, closing socket %d\n", v23);
      }
      close(::s);
      ::s = -1;
      return -29998;
    }
    else
    {
      abort_socket();
      return 200;
    }
  }
  else
  {
    while ( 1 )
    {
      if ( done )
        goto LABEL_50;
      ich = HTGetCharacter();
      *p++ = ich;
      if ( ich == -1 )
        break;
      if ( (_BYTE)ich == 10 || p == &line[512] )
      {
        *--p = 0;
        if ( WWW_TraceFlag[0] )
        {
          v3 = TraceFP();
          fprintf(v3, "H %s\n", line);
        }
        if ( line[0] != 9 && line[0] != 32 )
          goto LABEL_23;
        for ( i = 0; line[i]; ++i )
        {
          if ( line[i] == 9 )
            line[i] = 32;
        }
        if ( full_line )
          HTSACat(&full_line, line);
        else
LABEL_23:
          HTSACopy(&full_line, line);
        if ( *full_line == 46 )
        {
          if ( (unsigned __int8)full_line[1] <= 0x1Fu )
          {
            done = 1;
LABEL_50:
            if ( full_line )
            {
              free(full_line);
              full_line = 0;
            }
            targetClass.start_element((HTStructured *)target, 53, 0, 0, -1, 0);
            targetClass.put_character((HTStructured *)target, 10);
            targetClass.start_element((HTStructured *)target, 110, 0, 0, -1, 0);
            if ( subject && *subject )
              targetClass.put_string((HTStructured *)target, subject);
            else
              targetClass.put_string((HTStructured *)target, "No Subject");
            targetClass.end_element((HTStructured *)target, 110, 0);
            targetClass.put_character((HTStructured *)target, 10);
            if ( from || replyto )
            {
              temp = 0;
              if ( replyto )
                email = replyto;
              else
                email = from;
              v20 = author_address(email);
              HTSACopy(&temp, v20);
              HTSACopy(&href, "mailto:");
              if ( strchr(temp, 37) || strchr(temp, 63) )
              {
                cp = HTEscape(temp, 2u);
                HTSACat(&href, cp);
                if ( cp )
                {
                  free(cp);
                  cp = 0;
                }
              }
              else
              {
                HTSACat(&href, temp);
              }
              start_link(href, "made");
              targetClass.put_character((HTStructured *)target, 10);
              if ( temp )
              {
                free(temp);
                temp = 0;
              }
            }
            targetClass.end_element((HTStructured *)target, 53, 0);
            targetClass.put_character((HTStructured *)target, 10);
            targetClass.start_element((HTStructured *)target, 47, 0, 0, -1, 0);
            if ( subject && *subject )
              targetClass.put_string((HTStructured *)target, subject);
            else
              targetClass.put_string((HTStructured *)target, "No Subject");
            targetClass.end_element((HTStructured *)target, 47, 0);
            targetClass.put_character((HTStructured *)target, 10);
            if ( subject )
            {
              free(subject);
              subject = 0;
            }
            targetClass.start_element((HTStructured *)target, 36, 0, 0, -1, 0);
            targetClass.put_character((HTStructured *)target, 10);
            if ( from || replyto )
            {
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "From:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 32);
              if ( from )
                targetClass.put_string((HTStructured *)target, from);
              else
                targetClass.put_string((HTStructured *)target, replyto);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( !replyto )
                HTSACopy(&replyto, from);
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "Reply to:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 32);
              start_anchor(href);
              put_string = targetClass.put_string;
              if ( *replyto == 60 )
                v22 = author_address(replyto);
              else
                v22 = author_name(replyto);
              put_string((HTStructured *)target, v22);
              targetClass.end_element((HTStructured *)target, 0, 0);
              targetClass.start_element((HTStructured *)target, 20, 0, 0, -1, 0);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( from )
              {
                free(from);
                from = 0;
              }
              if ( replyto )
              {
                free(replyto);
                replyto = 0;
              }
            }
            if ( date )
            {
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "Date:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 32);
              targetClass.put_string((HTStructured *)target, date);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( date )
              {
                free(date);
                date = 0;
              }
            }
            if ( organization )
            {
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "Organization:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 32);
              targetClass.put_string((HTStructured *)target, organization);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( organization )
              {
                free(organization);
                organization = 0;
              }
            }
            if ( newsgroups )
            {
              cp = strchr(newsgroups, 47);
              if ( cp || (cp = strchr(newsgroups, 40)) != 0 )
                *cp = 0;
            }
            if ( newsgroups && !*newsgroups )
            {
              free(newsgroups);
              newsgroups = 0;
            }
            if ( followupto )
            {
              cp = strchr(followupto, 47);
              if ( cp || (cp = strchr(followupto, 40)) != 0 )
                *cp = 0;
            }
            if ( followupto && !*followupto )
            {
              free(followupto);
              followupto = 0;
            }
            if ( newsgroups && HTCanPost )
            {
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "Newsgroups:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.start_element((HTStructured *)target, 30, 0, 0, -1, 0);
              write_anchors(newsgroups);
              if ( HTML_dtd.tags[30].contents )
                targetClass.end_element((HTStructured *)target, 30, 0);
              targetClass.put_character((HTStructured *)target, 10);
            }
            if ( followupto && !strcasecomp(followupto, "poster") )
            {
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "Followup to:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 32);
              if ( href )
              {
                start_anchor(href);
                targetClass.put_string((HTStructured *)target, "poster");
                targetClass.end_element((HTStructured *)target, 0, 0);
              }
              else
              {
                targetClass.put_string((HTStructured *)target, "poster");
              }
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( followupto )
              {
                free(followupto);
                followupto = 0;
              }
            }
            if ( newsgroups && HTCanPost )
            {
              if ( strncasecomp(NewsHREF, "snews:", 6) )
                HTSACopy(&href, "newsreply://");
              else
                HTSACopy(&href, "snewsreply://");
              HTSACat(&href, NewsHost);
              HTSACat(&href, "/");
              if ( followupto )
                HTSACat(&href, followupto);
              else
                HTSACat(&href, newsgroups);
              if ( *href == 110 )
              {
                ccp = HTAnchor_messageID(thisanchor);
                if ( ccp )
                {
                  if ( *ccp )
                  {
                    HTSACat(&href, ";ref=");
                    if ( strchr(ccp, 60)
                      || strchr(ccp, 38)
                      || strchr(ccp, 32)
                      || strchr(ccp, 58)
                      || strchr(ccp, 47)
                      || strchr(ccp, 37)
                      || strchr(ccp, 59) )
                    {
                      cp1 = HTEscape(ccp, 2u);
                      HTSACat(&href, cp1);
                      if ( cp1 )
                        free(cp1);
                    }
                    else
                    {
                      HTSACat(&href, ccp);
                    }
                  }
                }
              }
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "Followup to:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              targetClass.put_character((HTStructured *)target, 32);
              start_anchor(href);
              if ( followupto )
                s = followupto;
              else
                s = newsgroups;
              if ( strchr(s, 44) )
                targetClass.put_string((HTStructured *)target, "newsgroups");
              else
                targetClass.put_string((HTStructured *)target, "newsgroup");
              targetClass.end_element((HTStructured *)target, 0, 0);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
            }
            if ( newsgroups )
            {
              free(newsgroups);
              newsgroups = 0;
            }
            if ( followupto )
            {
              free(followupto);
              followupto = 0;
            }
            if ( references )
            {
              targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
              targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
              targetClass.put_string((HTStructured *)target, "References:");
              targetClass.end_element((HTStructured *)target, 8, 0);
              if ( HTML_dtd.tags[37].contents )
                targetClass.end_element((HTStructured *)target, 37, 0);
              targetClass.put_character((HTStructured *)target, 10);
              targetClass.start_element((HTStructured *)target, 30, 0, 0, -1, 0);
              write_anchors(references);
              if ( HTML_dtd.tags[30].contents )
                targetClass.end_element((HTStructured *)target, 30, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( references )
              {
                free(references);
                references = 0;
              }
            }
            targetClass.end_element((HTStructured *)target, 36, 0);
            targetClass.put_character((HTStructured *)target, 10);
            if ( href )
            {
              free(href);
              href = 0;
            }
            goto LABEL_175;
          }
        }
        else
        {
          if ( (unsigned __int8)*full_line <= 0x1Fu )
            goto LABEL_50;
          if ( match(full_line, "SUBJECT:") )
          {
            v4 = strchr(full_line, 58);
            v5 = HTStrip(v4 + 1);
            HTSACopy(&subject, v5);
            decode_mime(&subject);
          }
          else if ( match(full_line, "DATE:") )
          {
            v6 = strchr(full_line, 58);
            v7 = HTStrip(v6 + 1);
            HTSACopy(&date, v7);
          }
          else if ( match(full_line, "ORGANIZATION:") )
          {
            v8 = strchr(full_line, 58);
            v9 = HTStrip(v8 + 1);
            HTSACopy(&organization, v9);
            decode_mime(&organization);
          }
          else if ( match(full_line, "FROM:") )
          {
            v10 = strchr(full_line, 58);
            v11 = HTStrip(v10 + 1);
            HTSACopy(&from, v11);
            decode_mime(&from);
          }
          else if ( match(full_line, "REPLY-TO:") )
          {
            v12 = strchr(full_line, 58);
            v13 = HTStrip(v12 + 1);
            HTSACopy(&replyto, v13);
            decode_mime(&replyto);
          }
          else if ( match(full_line, "NEWSGROUPS:") )
          {
            v14 = strchr(full_line, 58);
            v15 = HTStrip(v14 + 1);
            HTSACopy(&newsgroups, v15);
          }
          else if ( match(full_line, "REFERENCES:") )
          {
            v16 = strchr(full_line, 58);
            v17 = HTStrip(v16 + 1);
            HTSACopy(&references, v17);
          }
          else if ( match(full_line, "FOLLOWUP-TO:") )
          {
            v18 = strchr(full_line, 58);
            v19 = HTStrip(v18 + 1);
            HTSACopy(&followupto, v19);
          }
          else if ( match(full_line, "MESSAGE-ID:") )
          {
            msgid = HTStrip(full_line + 11);
            if ( *msgid == 60 && msgid[strlen(msgid) - 1] == 62 )
            {
              msgid[strlen(msgid) - 1] = 0;
              HTAnchor_setMessageID(thisanchor, ++msgid);
            }
          }
        }
        p = line;
      }
    }
    if ( interrupted_in_htgetcharacter )
    {
      interrupted_in_htgetcharacter = 0;
      if ( WWW_TraceFlag[0] )
      {
        v1 = ::s;
        v2 = TraceFP();
        fprintf(v2, "HTNews: Interrupted on read, closing socket %d\n", v1);
      }
      close(::s);
      ::s = -1;
      return -29998;
    }
    else
    {
      abort_socket();
      return 200;
    }
  }
}
// 8135F16: conditional instruction was optimized away because %subject.4!=0
// 813662F: conditional instruction was optimized away because %newsgroups.4!=0
// 81366C5: conditional instruction was optimized away because %followupto.4!=0

//----- (08137C00) --------------------------------------------------------
int __cdecl read_list(char *arg)
{
  char *v1; // ebx
  int v2; // ebx
  FILE *v3; // eax
  int v4; // ebx
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  char *msg; // [esp+2Ch] [ebp-22Ch] BYREF
  int i; // [esp+30h] [ebp-228h]
  int ich; // [esp+34h] [ebp-224h]
  int len; // [esp+38h] [ebp-220h]
  char *pattern; // [esp+3Ch] [ebp-21Ch] BYREF
  int listing; // [esp+40h] [ebp-218h]
  char *p; // [esp+44h] [ebp-214h]
  char ch_0; // [esp+49h] [ebp-20Fh]
  BOOLEAN skip_rest_of_line; // [esp+4Ah] [ebp-20Eh]
  BOOLEAN skip_this_line; // [esp+4Bh] [ebp-20Dh]
  BOOLEAN tail; // [esp+4Ch] [ebp-20Ch]
  BOOLEAN head; // [esp+4Dh] [ebp-20Bh]
  BOOLEAN done; // [esp+4Eh] [ebp-20Ah]
  char line[513]; // [esp+4Fh] [ebp-209h] BYREF
  unsigned int v25; // [esp+250h] [ebp-8h]

  v25 = __readgsdword(0x14u);
  done = 0;
  head = 0;
  tail = 0;
  skip_this_line = 0;
  skip_rest_of_line = 0;
  listing = 0;
  pattern = 0;
  len = 0;
  if ( arg && strlen(arg) > 1 )
  {
    if ( *arg == 42 )
    {
      tail = 1;
      HTSACopy(&pattern, arg + 1);
    }
    else if ( arg[strlen(arg) - 1] == 42 )
    {
      head = 1;
      HTSACopy(&pattern, arg);
      v1 = pattern;
      v1[strlen(pattern) - 1] = 0;
    }
    if ( tail || head )
      len = strlen(pattern);
  }
  targetClass.start_element((HTStructured *)target, 53, 0, 0, -1, 0);
  targetClass.put_character((HTStructured *)target, 10);
  targetClass.start_element((HTStructured *)target, 110, 0, 0, -1, 0);
  targetClass.put_string((HTStructured *)target, "Newsgroups");
  targetClass.end_element((HTStructured *)target, 110, 0);
  targetClass.put_character((HTStructured *)target, 10);
  targetClass.end_element((HTStructured *)target, 53, 0);
  targetClass.put_character((HTStructured *)target, 10);
  targetClass.start_element((HTStructured *)target, 47, 0, 0, -1, 0);
  targetClass.put_string((HTStructured *)target, "Newsgroups");
  targetClass.end_element((HTStructured *)target, 47, 0);
  targetClass.put_character((HTStructured *)target, 10);
  p = line;
  targetClass.start_element((HTStructured *)target, 36, 0, 0, -1, 0);
  targetClass.put_character((HTStructured *)target, 10);
  while ( 1 )
  {
    if ( done )
      goto LABEL_74;
    ich = HTGetCharacter();
    ch_0 = ich;
    if ( ich == -1 )
      break;
    if ( skip_this_line )
    {
      if ( ch_0 == 10 )
      {
        skip_rest_of_line = 0;
        skip_this_line = 0;
        p = line;
      }
    }
    else if ( skip_rest_of_line )
    {
      if ( ch_0 == 10 )
        goto LABEL_38;
    }
    else
    {
      if ( p != &line[512] )
      {
        *p++ = ch_0;
        goto LABEL_38;
      }
      if ( WWW_TraceFlag[0] )
      {
        v4 = ch_0;
        v5 = TraceFP();
        fprintf(v5, "b %.*s%c[...]\n", 512, line, v4);
      }
      *p = 0;
      if ( ch_0 == 10 )
        goto LABEL_38;
      if ( (unsigned __int8)ch_0 > 0x20u )
      {
        if ( strchr(line, 32) || strchr(line, 9) )
        {
          skip_rest_of_line = 1;
          goto LABEL_38;
        }
        if ( WWW_TraceFlag[0] )
        {
          v6 = TraceFP();
          fprintf(v6, "HTNews..... group name too long, discarding.\n");
        }
        skip_this_line = 1;
      }
      else
      {
        ch_0 = 10;
        skip_this_line = 1;
LABEL_38:
        if ( ch_0 == 10 )
        {
          skip_rest_of_line = 0;
          *p = 0;
          if ( WWW_TraceFlag[0] )
          {
            v7 = TraceFP();
            fprintf(v7, "B %s", line);
          }
          if ( line[0] == 46 )
          {
            if ( line[1] <= 0x1Fu )
            {
              done = 1;
LABEL_74:
              if ( !listing )
              {
                msg = 0;
                targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
                v8 = gettext("No matches for: %s");
                HTSprintf0(&msg, v8, arg);
                targetClass.put_string((HTStructured *)target, msg);
                if ( HTML_dtd.tags[37].contents )
                  targetClass.end_element((HTStructured *)target, 37, 0);
                if ( msg )
                {
                  free(msg);
                  msg = 0;
                }
              }
              targetClass.end_element((HTStructured *)target, 36, 0);
              targetClass.put_character((HTStructured *)target, 10);
              if ( pattern )
              {
                free(pattern);
                pattern = 0;
              }
              return 200;
            }
            targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
            targetClass.put_string((HTStructured *)target, &line[1]);
            if ( HTML_dtd.tags[37].contents )
              targetClass.end_element((HTStructured *)target, 37, 0);
LABEL_72:
            p = line;
          }
          else if ( line[0] == 35 )
          {
            p = line;
          }
          else
          {
            for ( i = 0; line[i] && (unsigned __int8)line[i] > 0x20u; ++i )
              ;
            if ( line[i] )
            {
              line[i] = 0;
              if ( (!head || !strncasecomp(line, pattern, len))
                && (!tail || i >= len && !strcasecomp(&line[i - len], pattern)) )
              {
                targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
                write_anchor(line, line);
                ++listing;
                if ( HTML_dtd.tags[37].contents )
                  targetClass.end_element((HTStructured *)target, 37, 0);
                targetClass.put_character((HTStructured *)target, 10);
                targetClass.start_element((HTStructured *)target, 30, 0, 0, -1, 0);
                targetClass.put_string((HTStructured *)target, &line[i + 1]);
                if ( HTML_dtd.tags[30].contents )
                  targetClass.end_element((HTStructured *)target, 30, 0);
                goto LABEL_72;
              }
              p = line;
            }
            else
            {
              if ( (!head || !strncasecomp(line, pattern, len))
                && (!tail || i >= len && !strcasecomp(&line[i - len], pattern)) )
              {
                targetClass.start_element((HTStructured *)target, 37, 0, 0, -1, 0);
                write_anchor(line, line);
                if ( HTML_dtd.tags[37].contents )
                  targetClass.end_element((HTStructured *)target, 37, 0);
                ++listing;
                goto LABEL_72;
              }
              p = line;
            }
          }
        }
      }
    }
  }
  if ( interrupted_in_htgetcharacter )
  {
    interrupted_in_htgetcharacter = 0;
    if ( WWW_TraceFlag[0] )
    {
      v2 = s;
      v3 = TraceFP();
      fprintf(v3, "HTNews: Interrupted on read, closing socket %d\n", v2);
    }
    close(s);
    s = -1;
    return -29998;
  }
  else
  {
    abort_socket();
    if ( pattern )
    {
      free(pattern);
      pattern = 0;
    }
    return 200;
  }
}

//----- (08138713) --------------------------------------------------------
int __cdecl read_group(const char *groupName, int first_required, int last_required)
{
  int v3; // ebx
  int v4; // esi
  int v5; // edi
  FILE *v6; // edx
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v8; // eax
  void (*v9)(HTStructured *, const char *); // ebx
  char *v10; // eax
  FILE *v11; // edx
  char *v12; // eax
  const char *v13; // ebx
  FILE *v14; // eax
  void (*v15)(HTStructured *, const char *); // ebx
  char *v16; // eax
  void (*v17)(HTStructured *, const char *); // ebx
  char *v18; // eax
  int v19; // ebx
  FILE *v20; // eax
  FILE *v21; // eax
  char *v22; // eax
  char *v23; // ebx
  char *v24; // eax
  char *v25; // eax
  void (*v26)(HTStructured *, const char *); // ebx
  char *v27; // eax
  int v28; // ebx
  FILE *v29; // eax
  const char *v30; // ebx
  FILE *v31; // eax
  void (*v32)(HTStructured *, const char *); // ebx
  char *v33; // eax
  void (*v34)(HTStructured *, const char *); // ebx
  char *v35; // eax
  int v37; // [esp+2Ch] [ebp-46Ch]
  char *href; // [esp+3Ch] [ebp-45Ch] BYREF
  int after; // [esp+40h] [ebp-458h]
  char *p2; // [esp+44h] [ebp-454h]
  char *addr; // [esp+48h] [ebp-450h]
  int ich; // [esp+4Ch] [ebp-44Ch]
  int before; // [esp+50h] [ebp-448h]
  int last; // [esp+54h] [ebp-444h] BYREF
  int first; // [esp+58h] [ebp-440h] BYREF
  int count; // [esp+5Ch] [ebp-43Ch] BYREF
  int status; // [esp+60h] [ebp-438h] BYREF
  int art; // [esp+64h] [ebp-434h]
  char *reference; // [esp+68h] [ebp-430h] BYREF
  char *temp; // [esp+6Ch] [ebp-42Ch] BYREF
  char *p; // [esp+70h] [ebp-428h]
  int i; // [esp+74h] [ebp-424h]
  char *date; // [esp+78h] [ebp-420h] BYREF
  char *subject; // [esp+7Ch] [ebp-41Ch] BYREF
  char *author; // [esp+80h] [ebp-418h] BYREF
  BOOLEAN done; // [esp+85h] [ebp-413h]
  char buffer[513]; // [esp+86h] [ebp-412h] BYREF
  char line[513]; // [esp+287h] [ebp-211h] BYREF
  unsigned int v60; // [esp+488h] [ebp-10h]

  v60 = __readgsdword(0x14u);
  author = 0;
  subject = 0;
  date = 0;
  temp = 0;
  reference = 0;
  targetClass.start_element((HTStructured *)target, 53, 0, 0, -1, 0);
  targetClass.put_character((HTStructured *)target, 10);
  targetClass.start_element((HTStructured *)target, 110, 0, 0, -1, 0);
  targetClass.put_string((HTStructured *)target, "Newsgroup ");
  targetClass.put_string((HTStructured *)target, groupName);
  targetClass.end_element((HTStructured *)target, 110, 0);
  targetClass.put_character((HTStructured *)target, 10);
  targetClass.end_element((HTStructured *)target, 53, 0);
  targetClass.put_character((HTStructured *)target, 10);
  sscanf(response_text_0, " %d %d %d %d", &status, &count, &first, &last);
  if ( WWW_TraceFlag[0] )
  {
    v3 = last;
    v4 = first;
    v5 = count;
    v37 = status;
    v6 = TraceFP();
    fprintf(
      v6,
      "Newsgroup status=%d, count=%d, (%d-%d) required:(%d-%d)\n",
      v37,
      v5,
      v4,
      v3,
      first_required,
      last_required);
  }
  if ( !last )
  {
    put_string = targetClass.put_string;
    v8 = gettext("\nNo articles in this group.\n");
    put_string((HTStructured *)target, v8);
add_post:
    if ( HTCanPost )
    {
      href = 0;
      targetClass.start_element((HTStructured *)target, 54, 0, 0, -1, 0);
      targetClass.put_character((HTStructured *)target, 10);
      if ( strncasecomp(NewsHREF, "snews:", 6) )
        HTSACopy(&href, "newspost://");
      else
        HTSACopy(&href, "snewspost://");
      HTSACat(&href, NewsHost);
      HTSACat(&href, "/");
      HTSACat(&href, groupName);
      start_anchor(href);
      v34 = targetClass.put_string;
      v35 = gettext("Post to ");
      v34((HTStructured *)target, v35);
      targetClass.put_string((HTStructured *)target, groupName);
      targetClass.end_element((HTStructured *)target, 0, 0);
      if ( href )
      {
        free(href);
        href = 0;
      }
    }
    else
    {
      targetClass.start_element((HTStructured *)target, 54, 0, 0, -1, 0);
    }
    targetClass.put_character((HTStructured *)target, 10);
    return 200;
  }
  if ( first_required < first )
    first_required = first;
  if ( !last_required || last_required > last )
    last_required = last;
  if ( last_required < first_required )
  {
    v9 = targetClass.put_string;
    v10 = gettext("\nNo articles in this range.\n");
    v9((HTStructured *)target, v10);
    goto add_post;
  }
  if ( last_required - first_required + 1 > HTNewsMaxChunk )
    first_required = last_required - HTNewsChunkSize + 1;
  if ( WWW_TraceFlag[0] )
  {
    v11 = TraceFP();
    fprintf(v11, "    Chunk will be (%d-%d)\n", first_required, last_required);
  }
  v12 = gettext("%s,  Articles %d-%d");
  HTSprintf0(&temp, v12, groupName, first_required, last_required);
  targetClass.start_element((HTStructured *)target, 47, 0, 0, -1, 0);
  targetClass.put_string((HTStructured *)target, temp);
  if ( temp )
  {
    free(temp);
    temp = 0;
  }
  targetClass.end_element((HTStructured *)target, 47, 0);
  targetClass.put_character((HTStructured *)target, 10);
  if ( first_required > first )
  {
    if ( first_required - HTNewsMaxChunk > first )
      before = first_required - HTNewsChunkSize;
    else
      before = first;
    HTSprintf0(&dbuf, "%s%s/%d-%d", NewsHREF, groupName, before, first_required - 1);
    if ( WWW_TraceFlag[0] )
    {
      v13 = dbuf;
      v14 = TraceFP();
      fprintf(v14, "    Block before is %s\n", v13);
    }
    targetClass.put_character((HTStructured *)target, 40);
    start_anchor(dbuf);
    v15 = targetClass.put_string;
    v16 = gettext("Earlier articles");
    v15((HTStructured *)target, v16);
    targetClass.end_element((HTStructured *)target, 0, 0);
    targetClass.put_string((HTStructured *)target, "...)\n");
    targetClass.start_element((HTStructured *)target, 83, 0, 0, -1, 0);
    targetClass.put_character((HTStructured *)target, 10);
  }
  done = 0;
  targetClass.start_element((HTStructured *)target, 8, 0, 0, -1, 0);
  if ( first == first_required && last == last_required )
  {
    v17 = targetClass.put_string;
    v18 = gettext("All available articles in ");
    v17((HTStructured *)target, v18);
  }
  else
  {
    targetClass.put_string((HTStructured *)target, "Articles in ");
  }
  targetClass.put_string((HTStructured *)target, groupName);
  targetClass.end_element((HTStructured *)target, 8, 0);
  targetClass.put_character((HTStructured *)target, 10);
  if ( LYListNewsNumbers )
    start_list(first_required);
  else
    targetClass.start_element((HTStructured *)target, 114, 0, 0, -1, 0);
  for ( art = first_required; ; ++art )
  {
    if ( art > last_required )
    {
      if ( author )
      {
        free(author);
        author = 0;
      }
      if ( subject )
      {
        free(subject);
        subject = 0;
      }
      targetClass.put_character((HTStructured *)target, 10);
      if ( LYListNewsNumbers )
        targetClass.end_element((HTStructured *)target, 80, 0);
      else
        targetClass.end_element((HTStructured *)target, 114, 0);
      targetClass.put_character((HTStructured *)target, 10);
      if ( last_required < last )
      {
        after = last_required + HTNewsChunkSize;
        if ( last_required + HTNewsChunkSize == last )
          HTSprintf0(&dbuf, "%s%s", NewsHREF, groupName);
        else
          HTSprintf0(&dbuf, "%s%s/%d-%d", NewsHREF, groupName, last_required + 1, after);
        if ( WWW_TraceFlag[0] )
        {
          v30 = dbuf;
          v31 = TraceFP();
          fprintf(v31, "    Block after is %s\n", v30);
        }
        targetClass.put_character((HTStructured *)target, 40);
        start_anchor(dbuf);
        v32 = targetClass.put_string;
        v33 = gettext("Later articles");
        v32((HTStructured *)target, v33);
        targetClass.end_element((HTStructured *)target, 0, 0);
        targetClass.put_string((HTStructured *)target, "...)\n");
      }
      goto add_post;
    }
    sprintf(buffer, "HEAD %d%c%c", art, 13, 10);
    status = response_0(buffer);
    if ( status == 221 )
    {
      p = line;
      done = 0;
LABEL_57:
      while ( !done )
      {
        ich = HTGetCharacter();
        *p++ = ich;
        if ( ich == -1 )
        {
          if ( !interrupted_in_htgetcharacter )
          {
            abort_socket();
            return 200;
          }
          interrupted_in_htgetcharacter = 0;
          if ( WWW_TraceFlag[0] )
          {
            v19 = s;
            v20 = TraceFP();
            fprintf(v20, "HTNews: Interrupted on read, closing socket %d\n", v19);
          }
          goto LABEL_39;
        }
        if ( (_BYTE)ich == 10 || p == &line[512] )
        {
          *--p = 0;
          p = line;
          if ( WWW_TraceFlag[0] )
          {
            v21 = TraceFP();
            fprintf(v21, "G %s\n", line);
          }
          switch ( line[0] )
          {
            case '.':
              done = line[1] <= 0x1Fu;
              break;
            case 'D':
            case 'd':
              if ( LYListNewsDates && match(line, "DATE:") )
              {
                v24 = strchr(line, 58);
                v25 = HTStrip(v24 + 1);
                HTSACopy(&date, v25);
              }
              break;
            case 'F':
            case 'f':
              if ( match(line, "FROM:") )
              {
                v22 = strchr(line, 58);
                HTSACopy(&author, v22 + 1);
                decode_mime(&author);
                v23 = author;
                p2 = &v23[strlen(author) - 1];
                if ( *p2 == 10 )
                  *p2 = 0;
              }
              break;
            case 'M':
            case 'm':
              if ( match(line, "MESSAGE-ID:") )
              {
                addr = HTStrip(&line[11]) + 1;
                addr[strlen(addr) - 1] = 0;
                HTSACopy(&reference, addr);
              }
              break;
            case 'S':
            case 's':
              if ( match(line, "SUBJECT:") )
              {
                HTSACopy(&subject, &line[9]);
                decode_mime(&subject);
              }
              break;
            default:
              goto LABEL_57;
          }
        }
      }
      targetClass.put_character((HTStructured *)target, 10);
      targetClass.start_element((HTStructured *)target, 68, 0, 0, -1, 0);
      p = decode_mime(&subject);
      if ( p )
        HTSprintf0(&temp, "\"%s\"", p);
      else
        HTSprintf0(&temp, "\"%s\"", &byte_818EC67);
      if ( reference )
      {
        write_anchor(temp, reference);
        if ( reference )
        {
          free(reference);
          reference = 0;
        }
      }
      else
      {
        targetClass.put_string((HTStructured *)target, temp);
      }
      if ( temp )
      {
        free(temp);
        temp = 0;
      }
      if ( author )
      {
        targetClass.put_string((HTStructured *)target, " - ");
        if ( LYListNewsDates )
          targetClass.start_element((HTStructured *)target, 57, 0, 0, -1, 0);
        v26 = targetClass.put_string;
        v27 = decode_mime(&author);
        v26((HTStructured *)target, v27);
        if ( LYListNewsDates )
          targetClass.end_element((HTStructured *)target, 57, 0);
        if ( author )
        {
          free(author);
          author = 0;
        }
      }
      if ( date )
      {
        if ( !diagnostic )
        {
          for ( i = 0; date[i]; ++i )
          {
            if ( date[i] == 32 )
              date[i] = 1;
          }
        }
        sprintf(buffer, " [%.*s]", 509, date);
        targetClass.put_string((HTStructured *)target, buffer);
        if ( date )
        {
          free(date);
          date = 0;
        }
      }
      if ( HTML_dtd.tags[68].contents == SGML_EMPTY )
        continue;
LABEL_93:
      targetClass.end_element((HTStructured *)target, 68, 0);
      continue;
    }
    if ( status == -29998 )
      break;
    targetClass.put_character((HTStructured *)target, 10);
    targetClass.start_element((HTStructured *)target, 68, 0, 0, -1, 0);
    targetClass.start_element((HTStructured *)target, 57, 0, 0, -1, 0);
    if ( LYListNewsNumbers )
      LYstrncpy(buffer, "Status:", 512);
    else
      sprintf(buffer, "Status (ARTICLE %d):", art);
    targetClass.put_string((HTStructured *)target, buffer);
    targetClass.end_element((HTStructured *)target, 57, 0);
    targetClass.put_character((HTStructured *)target, 32);
    targetClass.put_string((HTStructured *)target, response_text_0);
    if ( HTML_dtd.tags[68].contents )
      goto LABEL_93;
  }
  interrupted_in_htgetcharacter = 0;
  if ( WWW_TraceFlag[0] )
  {
    v28 = s;
    v29 = TraceFP();
    fprintf(v29, "HTNews: Interrupted on read, closing socket %d\n", v28);
  }
LABEL_39:
  close(s);
  s = -1;
  return -29998;
}

//----- (08139A2C) --------------------------------------------------------
int __cdecl HTLoadNews(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *stream)
{
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  size_t v8; // ebx
  FILE *v9; // eax
  char *v10; // eax
  size_t v11; // eax
  HTAtom *v12; // edx
  char *v13; // eax
  const HTStreamClass *isa; // edx
  const HTStructuredClass *v15; // edx
  FILE *v16; // eax
  char *v17; // eax
  FILE *v18; // eax
  char *v19; // eax
  FILE *v20; // eax
  char *v21; // ebx
  char *v22; // eax
  const char *v23; // ebx
  FILE *v24; // eax
  size_t v25; // eax
  FILE *v26; // eax
  char *v27; // eax
  char *v28; // ebx
  char *v29; // eax
  char *v30; // eax
  char *v31; // eax
  char *v32; // eax
  char *v33; // eax
  char *v34; // eax
  char *v35; // eax
  char *v36; // eax
  char *v37; // eax
  char *v38; // eax
  char *v39; // eax
  char *v40; // eax
  _BOOL4 v42; // [esp+24h] [ebp-4C4h]
  bool v44; // [esp+2Ch] [ebp-4BCh]
  bool v45; // [esp+30h] [ebp-4B8h]
  bool v46; // [esp+34h] [ebp-4B4h]
  bool v47; // [esp+38h] [ebp-4B0h]
  bool v48; // [esp+3Ch] [ebp-4ACh]
  bool v49; // [esp+40h] [ebp-4A8h]
  bool v50; // [esp+44h] [ebp-4A4h]
  const char *v51; // [esp+4Ch] [ebp-49Ch]
  const char *v52; // [esp+50h] [ebp-498h]
  const char *v53; // [esp+54h] [ebp-494h]
  const char *v54; // [esp+58h] [ebp-490h]
  bool v55; // [esp+64h] [ebp-484h]
  const char *v56; // [esp+70h] [ebp-478h]
  NNTPAuthResult auth_result_0; // [esp+88h] [ebp-460h]
  NNTPAuthResult auth_result; // [esp+8Ch] [ebp-45Ch]
  int add_close; // [esp+94h] [ebp-454h]
  int add_open; // [esp+98h] [ebp-450h]
  char *slash; // [esp+9Ch] [ebp-44Ch]
  char *p1; // [esp+A0h] [ebp-448h]
  char *p1a; // [esp+A0h] [ebp-448h]
  char *p1b; // [esp+A0h] [ebp-448h]
  char *postfile; // [esp+A4h] [ebp-444h]
  char *ProxyHREF; // [esp+A8h] [ebp-440h] BYREF
  char *ProxyHost; // [esp+ACh] [ebp-43Ch] BYREF
  char *ListArg; // [esp+B0h] [ebp-438h] BYREF
  char *cp; // [esp+B4h] [ebp-434h]
  int last; // [esp+B8h] [ebp-430h] BYREF
  int first; // [esp+BCh] [ebp-42Ch] BYREF
  int retries; // [esp+C0h] [ebp-428h]
  int status; // [esp+C4h] [ebp-424h]
  BOOLEAN head_wanted; // [esp+CAh] [ebp-41Eh]
  BOOLEAN sreply_wanted; // [esp+CBh] [ebp-41Dh]
  BOOLEAN spost_wanted; // [esp+CCh] [ebp-41Ch]
  BOOLEAN reply_wanted; // [esp+CDh] [ebp-41Bh]
  BOOLEAN post_wanted; // [esp+CEh] [ebp-41Ah]
  BOOLEAN list_wanted; // [esp+CFh] [ebp-419h]
  BOOLEAN group_wanted; // [esp+D0h] [ebp-418h]
  BOOLEAN normal_url; // [esp+D1h] [ebp-417h]
  char command[262]; // [esp+D2h] [ebp-416h] BYREF
  char buffer[20]; // [esp+1D8h] [ebp-310h] BYREF
  char proxycmd[260]; // [esp+2DCh] [ebp-20Ch] BYREF
  char groupName[256]; // [esp+3E0h] [ebp-108h] BYREF
  unsigned int v86; // [esp+4E0h] [ebp-8h]

  v86 = __readgsdword(0x14u);
  head_wanted = 0;
  cp = 0;
  ListArg = 0;
  ProxyHost = 0;
  ProxyHREF = 0;
  postfile = 0;
  v42 = format_out == WWW_SOURCE || HTAtom_for("www/download") == format_out || HTAtom_for("www/dump") == format_out;
  diagnostic = v42;
  rawtext[0] = 0;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "HTNews: Looking for %s\n", arg);
  }
  if ( !initialized[0] )
    initialized[0] = initialize();
  if ( !initialized[0] )
    return -1;
  if ( NewsHREF )
  {
    free(NewsHREF);
    NewsHREF = 0;
  }
  command[0] = 0;
  command[261] = 0;
  proxycmd[0] = 0;
  proxycmd[259] = 0;
  v44 = !strncmp(arg, "news:", 5u) || !strncmp(arg, "nntp:", 5u);
  normal_url = v44;
  v45 = !v44 && strstr(arg, "snewspost:");
  spost_wanted = v45;
  v46 = !normal_url && !spost_wanted && strstr(arg, "snewsreply:");
  sreply_wanted = v46;
  v47 = !normal_url && !spost_wanted && !sreply_wanted && strstr(arg, "newspost:");
  post_wanted = v47;
  v48 = !normal_url && !spost_wanted && !sreply_wanted && !post_wanted && strstr(arg, "newsreply:");
  reply_wanted = v48;
  v49 = !spost_wanted && !sreply_wanted && !post_wanted && !reply_wanted && !strchr(arg, 64) && !strchr(arg, 42);
  group_wanted = v49;
  v50 = !spost_wanted
     && !sreply_wanted
     && !post_wanted
     && !reply_wanted
     && !group_wanted
     && !strchr(arg, 64)
     && strchr(arg, 42);
  list_wanted = v50;
  if ( !strncasecomp(arg, "snewspost:", 10) || !strncasecomp(arg, "snewsreply:", 11) )
  {
    v5 = gettext("This client does not contain support for posting to news with SSL.");
    HTAlert(v5);
    return -29999;
  }
  if ( post_wanted || reply_wanted || spost_wanted || sreply_wanted )
  {
    p1 = strrchr(arg, 47);
    if ( p1 )
    {
      p1a = p1 + 1;
    }
    else
    {
      p1a = strrchr(arg, 58);
      if ( p1a )
        ++p1a;
    }
    if ( !p1a || !*p1a )
    {
      v6 = gettext("Illegal URL: %s");
      HTAlert(v6);
      return -204;
    }
    cp = HTParse(arg, &byte_818EC67, 8);
    if ( cp && *cp )
    {
      if ( s >= 0 && NewsHost && strcasecomp(NewsHost, cp) )
      {
        close(s);
        s = -1;
      }
      HTSACopy(&NewsHost, cp);
    }
    else
    {
      if ( s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost) )
      {
        close(s);
        s = -1;
      }
      HTSACopy(&NewsHost, HTNewsHost);
    }
    if ( cp )
    {
      free(cp);
      cp = 0;
    }
    if ( post_wanted )
    {
      v51 = "newspost";
    }
    else
    {
      if ( reply_wanted )
      {
        v52 = "newreply";
      }
      else
      {
        if ( spost_wanted )
          v53 = "snewspost";
        else
          v53 = "snewsreply";
        v52 = v53;
      }
      v51 = v52;
    }
    HTSprintf0(&NewsHREF, "%s://%.*s/", v51, 247, NewsHost);
    if ( spost_wanted && strncasecomp(arg, "snewspost:", 10) )
      p1a = strstr(arg, "snewspost:");
    if ( sreply_wanted && strncasecomp(arg, "snewsreply:", 11) )
      p1a = strstr(arg, "snewsreply:");
  }
  else if ( strncasecomp(arg, "nntp:", 5) )
  {
    if ( !strncasecomp(arg, "snews:", 6) )
    {
      v7 = gettext("This client does not contain support for SNEWS URLs.");
      HTAlert(v7);
      return -29999;
    }
    if ( strncasecomp(arg, "news:/", 6) )
    {
      p1a = (char *)(arg + 5);
      if ( !arg[5] )
      {
        p1a = "*";
        group_wanted = 0;
        list_wanted = 1;
      }
      if ( s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost) )
      {
        close(s);
        s = -1;
      }
      HTSACopy(&NewsHost, HTNewsHost);
      HTSACopy(&NewsHREF, "news:");
    }
    else
    {
      if ( arg[6]
        && strcmp(arg + 6, "/")
        && strcmp(arg + 6, "//")
        && (arg[6] != 47 || (cp = strchr(arg + 7, 47)) != 0 && cp[1]) )
      {
        if ( arg[6] == 47 )
          p1a = cp + 1;
        else
          p1a = (char *)(arg + 6);
      }
      else
      {
        p1a = "*";
        group_wanted = 0;
        list_wanted = 1;
      }
      cp = HTParse(arg, &byte_818EC67, 8);
      if ( cp && *cp )
      {
        if ( s >= 0 && NewsHost && strcasecomp(NewsHost, cp) )
        {
          close(s);
          s = -1;
        }
        HTSACopy(&NewsHost, cp);
      }
      else
      {
        if ( s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost) )
        {
          close(s);
          s = -1;
        }
        HTSACopy(&NewsHost, HTNewsHost);
      }
      if ( cp )
      {
        free(cp);
        cp = 0;
      }
      sprintf(command, "news://%.*s/", 253, NewsHost);
      HTSACopy(&NewsHREF, command);
    }
  }
  else
  {
    if ( !arg[5]
      || !strcmp(arg + 5, "/")
      || !strcmp(arg + 5, "//")
      || !strcmp(arg + 5, "///")
      || !strncmp(arg + 5, "//", 2u) && ((cp = strchr(arg + 7, 47)) == 0 || !cp[1]) )
    {
      p1a = "*";
      group_wanted = 0;
      list_wanted = 1;
    }
    else if ( arg[5] == 47 )
    {
      if ( arg[6] == 47 )
        p1a = cp + 1;
      else
        p1a = (char *)(arg + 6);
    }
    else
    {
      p1a = (char *)(arg + 5);
    }
    cp = HTParse(arg, &byte_818EC67, 8);
    if ( cp && *cp )
    {
      if ( s >= 0 && NewsHost && strcasecomp(NewsHost, cp) )
      {
        close(s);
        s = -1;
      }
      HTSACopy(&NewsHost, cp);
    }
    else
    {
      if ( s >= 0 && NewsHost && strcasecomp(NewsHost, HTNewsHost) )
      {
        close(s);
        s = -1;
      }
      HTSACopy(&NewsHost, HTNewsHost);
    }
    if ( cp )
    {
      free(cp);
      cp = 0;
    }
    sprintf(command, "%s//%.*s/", "nntp:", 253, NewsHost);
    HTSACopy(&NewsHREF, command);
  }
  if ( !strncasecomp(p1a, "snews:", 6) || !strncasecomp(p1a, "snewspost:", 10) || !strncasecomp(p1a, "snewsreply:", 11) )
  {
    HTSACopy(&ProxyHost, NewsHost);
    cp = HTParse(p1a, &byte_818EC67, 8);
    if ( cp && *cp )
    {
      sprintf(command, "%s//%.*s", "snews:", 252, cp);
      HTSACopy(&NewsHost, cp);
    }
    else
    {
      sprintf(command, "%s//%.*s", "snews:", 252, NewsHost);
    }
    command[260] = 0;
    if ( cp )
    {
      free(cp);
      cp = 0;
    }
    sprintf(proxycmd, "GET %.*s%c%c%c%c", 251, command, 13, 10, 13, 10);
    if ( WWW_TraceFlag[0] )
    {
      v8 = strlen(proxycmd) - 4;
      v9 = TraceFP();
      fprintf(v9, "HTNews: Proxy command is '%.*s'\n", v8, proxycmd);
    }
    strcat(command, "/");
    HTSACopy(&ProxyHREF, NewsHREF);
    HTSACopy(&NewsHREF, command);
    if ( spost_wanted || sreply_wanted )
    {
      p1b = strrchr(arg, 47);
      if ( p1b )
        p1a = p1b + 1;
      else
        p1a = strrchr(arg, 58) + 1;
    }
    else
    {
      cp = strrchr(p1a + 6, 47);
      if ( cp && cp[1] )
      {
        p1a = cp + 1;
      }
      else
      {
        p1a = "*";
        group_wanted = 0;
        list_wanted = 1;
      }
    }
  }
  if ( post_wanted || reply_wanted || spost_wanted || sreply_wanted )
  {
    memcpy(command, "POST", 5u);
    goto LABEL_230;
  }
  if ( list_wanted )
  {
    if ( strlen(p1a) > 0xF9 )
    {
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
LABEL_223:
      v10 = gettext("URL too long");
      HTAlert(v10);
      return -400;
    }
    sprintf(command, "XGTITLE %.*s", 251, p1a);
  }
  else if ( group_wanted )
  {
    slash = strchr(p1a, 47);
    first = 0;
    last = 0;
    if ( slash )
    {
      *slash = 0;
      if ( strlen(p1a) > 0xFF )
      {
        if ( ProxyHost )
        {
          free(ProxyHost);
          ProxyHost = 0;
        }
        if ( ProxyHREF )
        {
          free(ProxyHREF);
          ProxyHREF = 0;
        }
        goto LABEL_223;
      }
      LYstrncpy(groupName, p1a, 255);
      *slash = 47;
      sscanf(slash + 1, "%d-%d", &first, &last);
      if ( first > 0
        && ((*__ctype_b_loc())[(unsigned __int8)slash[1]] & 0x800) != 0
        && (!strchr(slash + 1, 45) || first == last) )
      {
        last = -1;
      }
    }
    else
    {
      if ( strlen(p1a) > 0xFF )
      {
        if ( ProxyHost )
        {
          free(ProxyHost);
          ProxyHost = 0;
        }
        if ( ProxyHREF )
        {
          free(ProxyHREF);
          ProxyHREF = 0;
        }
        goto LABEL_223;
      }
      LYstrncpy(groupName, p1a, 255);
    }
    sprintf(command, "GROUP %.*s", 253, groupName);
  }
  else
  {
    add_open = strchr(p1a, 60) == 0;
    add_close = strchr(p1a, 62) == 0;
    if ( add_open + strlen(p1a) + add_close > 0xFB )
    {
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
      goto LABEL_223;
    }
    if ( add_close )
      v54 = ">";
    else
      v54 = &byte_818EC67;
    if ( add_open )
      sprintf(command, "ARTICLE %s%.*s%s", "<", -11 - add_open - add_close + 262, p1a, v54);
    else
      sprintf(command, "ARTICLE %s%.*s%s", &byte_818EC67, -11 - add_open - add_close + 262, p1a, v54);
  }
LABEL_230:
  v11 = strlen(command);
  command[v11] = 13;
  command[v11 + 1] = 10;
  command[v11 + 2] = 0;
  HTSACopy(&ListArg, p1a);
  if ( !*arg )
  {
    if ( NewsHREF )
    {
      free(NewsHREF);
      NewsHREF = 0;
    }
    if ( ProxyHost )
    {
      free(ProxyHost);
      ProxyHost = 0;
    }
    if ( ProxyHREF )
    {
      free(ProxyHREF);
      ProxyHREF = 0;
    }
    if ( ListArg )
    {
      free(ListArg);
      ListArg = 0;
    }
    return 0;
  }
  if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted && (!group_wanted || last == -1) && !list_wanted )
  {
    head_wanted = anAnchor->isHEAD;
    if ( head_wanted && !strncmp(command, "ARTICLE ", 8u) )
    {
      memcpy(command, "HEAD ", 6u);
      for ( cp = &command[5]; ; ++cp )
      {
        *cp = cp[3];
        if ( !*cp )
          break;
      }
    }
    v55 = head_wanted || keep_mime_headers;
    rawtext[0] = v55;
  }
  if ( rawtext[0] )
  {
    node_anchor = anAnchor;
    v12 = HTAtom_for("text/plain");
    rawtarget = (HTStream *)HTStreamStack(v12, format_out, (HTStream_5 *)stream, anAnchor);
    if ( !rawtarget )
    {
      if ( NewsHost )
      {
        free(NewsHost);
        NewsHost = 0;
      }
      if ( NewsHREF )
      {
        free(NewsHREF);
        NewsHREF = 0;
      }
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
      if ( ListArg )
      {
        free(ListArg);
        ListArg = 0;
      }
      v13 = gettext("No target for raw text!");
      HTAlert(v13);
      return -29999;
    }
    isa = rawtarget->isa;
    rawtargetClass.name = rawtarget->isa->name;
    rawtargetClass._free = isa->_free;
    rawtargetClass._abort = isa->_abort;
    rawtargetClass.put_character = isa->put_character;
    rawtargetClass.put_string = isa->put_string;
    rawtargetClass.put_block = isa->put_block;
  }
  else if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
  {
    node_anchor = anAnchor;
    target = (HTStructured_1 *)HTML_new(anAnchor, format_out, (HTStream_0 *)stream);
    v15 = target->isa;
    targetClass.name = target->isa->name;
    targetClass._free = v15->_free;
    targetClass._abort = v15->_abort;
    targetClass.put_character = v15->put_character;
    targetClass.put_string = v15->put_string;
    targetClass.put_block = v15->put_block;
    targetClass.start_element = v15->start_element;
    targetClass.end_element = v15->end_element;
    targetClass.put_entity = v15->put_entity;
  }
  for ( retries = 0; ; ++retries )
  {
    if ( retries > 1 )
      goto LABEL_527;
    if ( s >= 0 )
      break;
    if ( !strcmp(NewsHREF, "news:") )
    {
      sprintf(buffer, "lose://%.*s/", 251, NewsHost);
    }
    else if ( ProxyHREF )
    {
      sprintf(buffer, "%.*s", 259, ProxyHREF);
    }
    else
    {
      sprintf(buffer, "%.*s", 259, NewsHREF);
    }
    if ( WWW_TraceFlag[0] )
    {
      v16 = TraceFP();
      fprintf(v16, "News: doing HTDoConnect on '%s'\n", buffer);
    }
    mustshow[0] = 1;
    v17 = gettext("Connecting to NewsHost ...");
    HTProgress(v17);
    status = HTDoConnect(buffer, "NNTP", 119, &s);
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v18 = TraceFP();
        fprintf(v18, "HTNews: Interrupted on connect; recovering cleanly.\n");
      }
      mustshow[0] = 1;
      v19 = gettext("Connection interrupted.");
      HTProgress(v19);
      if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
      {
        if ( rawtext[0] )
          rawtargetClass._abort(rawtarget, 0);
        else
          targetClass._abort((HTStructured *)target, 0);
      }
      if ( NewsHost )
      {
        free(NewsHost);
        NewsHost = 0;
      }
      if ( NewsHREF )
      {
        free(NewsHREF);
        NewsHREF = 0;
      }
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
      if ( ListArg )
      {
        free(ListArg);
        ListArg = 0;
      }
      if ( postfile )
      {
        remove(postfile);
        free(postfile);
      }
      return -29999;
    }
    if ( status >= 0 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v23 = NewsHost;
        v24 = TraceFP();
        fprintf(v24, "HTNews: Connected to news host %s.\n", v23);
      }
      HTInitInput(s);
      if ( proxycmd[0] )
      {
        v25 = strlen(proxycmd);
        status = write(s, proxycmd, v25);
        if ( WWW_TraceFlag[0] )
        {
          v26 = TraceFP();
          fprintf(v26, "HTNews: Proxy command returned status '%d'.\n", status);
        }
      }
      status = response_0(0);
      if ( (unsigned int)(status - 200) <= 0x63 )
      {
        if ( status == 200 )
        {
          HTCanPost = 1;
        }
        else
        {
          HTCanPost = 0;
          if ( post_wanted || reply_wanted || spost_wanted || sreply_wanted )
          {
            v31 = gettext("Cannot POST to this host.");
            HTAlert(v31);
            if ( NewsHREF )
            {
              free(NewsHREF);
              NewsHREF = 0;
            }
            if ( ProxyHREF )
            {
              HTSACopy(&NewsHost, ProxyHost);
              if ( ProxyHost )
              {
                free(ProxyHost);
                ProxyHost = 0;
              }
              if ( ProxyHREF )
              {
                free(ProxyHREF);
                ProxyHREF = 0;
              }
            }
            if ( ListArg )
            {
              free(ListArg);
              ListArg = 0;
            }
            if ( postfile )
            {
              remove(postfile);
              free(postfile);
            }
            return -29999;
          }
        }
        break;
      }
      close(s);
      s = -1;
      if ( status == -29998 )
      {
        mustshow[0] = 1;
        v27 = gettext("Connection interrupted.");
        HTProgress(v27);
        if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
        {
          if ( rawtext[0] )
            rawtargetClass._abort(rawtarget, 0);
          else
            targetClass._abort((HTStructured *)target, 0);
        }
        if ( NewsHost )
        {
          free(NewsHost);
          NewsHost = 0;
        }
        if ( NewsHREF )
        {
          free(NewsHREF);
          NewsHREF = 0;
        }
        if ( ProxyHost )
        {
          free(ProxyHost);
          ProxyHost = 0;
        }
        if ( ProxyHREF )
        {
          free(ProxyHREF);
          ProxyHREF = 0;
        }
        if ( ListArg )
        {
          free(ListArg);
          ListArg = 0;
        }
        if ( postfile )
        {
          remove(postfile);
          free(postfile);
        }
        return -29999;
      }
      if ( retries > 0 )
      {
        if ( ProxyHost )
        {
          free(ProxyHost);
          ProxyHost = 0;
        }
        if ( ProxyHREF )
        {
          free(ProxyHREF);
          ProxyHREF = 0;
        }
        if ( ListArg )
        {
          free(ListArg);
          ListArg = 0;
        }
        if ( postfile )
          free(postfile);
        if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
        {
          if ( rawtext[0] )
            rawtargetClass._abort(rawtarget, 0);
          else
            targetClass._abort((HTStructured *)target, 0);
        }
        v28 = NewsHost;
        if ( response_text_0[0] )
        {
          v29 = gettext("Can't read news info.  News host %.20s responded: %.200s");
          HTSprintf0(&dbuf, v29, v28, response_text_0);
        }
        else
        {
          v30 = gettext("Can't read news info, empty response from host %s");
          HTSprintf0(&dbuf, v30, v28);
        }
        return HTLoadError((HTStream_0 *)stream, 500, dbuf);
      }
    }
    else
    {
      close(s);
      s = -1;
      if ( WWW_TraceFlag[0] )
      {
        v20 = TraceFP();
        fprintf(v20, "HTNews: Unable to connect to news host.\n");
      }
      if ( retries > 0 )
      {
        if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
        {
          if ( rawtext[0] )
            rawtargetClass._abort(rawtarget, 0);
          else
            targetClass._abort((HTStructured *)target, 0);
        }
        v21 = NewsHost;
        v22 = gettext("Could not access %s.");
        HTSprintf0(&dbuf, v22, v21);
        if ( NewsHost )
        {
          free(NewsHost);
          NewsHost = 0;
        }
        if ( NewsHREF )
        {
          free(NewsHREF);
          NewsHREF = 0;
        }
        if ( ProxyHost )
        {
          free(ProxyHost);
          ProxyHost = 0;
        }
        if ( ProxyHREF )
        {
          free(ProxyHREF);
          ProxyHREF = 0;
        }
        if ( ListArg )
        {
          free(ListArg);
          ListArg = 0;
        }
        if ( postfile )
        {
          remove(postfile);
          free(postfile);
        }
        return HTLoadError((HTStream_0 *)stream, 500, dbuf);
      }
    }
LABEL_525:
    ;
  }
  if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
  {
    sprintf(buffer, "mode reader%c%c", 13, 10);
    status = response_0(buffer);
    if ( status == -29998 )
      goto LABEL_440;
    if ( status != 480 )
      goto Send_NNTP_command;
    auth_result = HTHandleAuthInfo(NewsHost);
    if ( auth_result == NNTPAUTH_CLOSE && s != -1 && !ProxyHost && !ProxyHREF )
    {
      close(s);
      s = -1;
    }
    if ( auth_result == NNTPAUTH_OK )
    {
      status = response_0(buffer);
      if ( status != -29998 )
        goto Send_NNTP_command;
LABEL_440:
      mustshow[0] = 1;
      v35 = gettext("Connection interrupted.");
      HTProgress(v35);
    }
LABEL_527:
    if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
    {
      if ( rawtext[0] )
        rawtargetClass._abort(rawtarget, 0);
      else
        targetClass._abort((HTStructured *)target, 0);
    }
    if ( NewsHREF )
    {
      free(NewsHREF);
      NewsHREF = 0;
    }
    if ( ProxyHREF )
    {
      HTSACopy(&NewsHost, ProxyHost);
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
    }
    if ( ListArg )
    {
      free(ListArg);
      ListArg = 0;
    }
    if ( postfile )
    {
      remove(postfile);
      free(postfile);
    }
    return -29999;
  }
  if ( !HTCanPost )
  {
    v32 = gettext("Cannot POST to this host.");
    HTAlert(v32);
    if ( NewsHREF )
    {
      free(NewsHREF);
      NewsHREF = 0;
    }
    if ( ProxyHREF )
    {
      HTSACopy(&NewsHost, ProxyHost);
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
    }
    if ( ListArg )
    {
      free(ListArg);
      ListArg = 0;
    }
    if ( postfile )
    {
      remove(postfile);
      free(postfile);
    }
    return -29999;
  }
  if ( !postfile )
  {
    if ( reply_wanted || sreply_wanted )
      v33 = LYNewsPost(ListArg, 1);
    else
      v33 = LYNewsPost(ListArg, 0);
    postfile = v33;
  }
  if ( !postfile )
  {
    v34 = gettext("Cancelled!!!");
    HTProgress(v34);
    if ( NewsHREF )
    {
      free(NewsHREF);
      NewsHREF = 0;
    }
    if ( ProxyHREF )
    {
      HTSACopy(&NewsHost, ProxyHost);
      if ( ProxyHost )
      {
        free(ProxyHost);
        ProxyHost = 0;
      }
      if ( ProxyHREF )
      {
        free(ProxyHREF);
        ProxyHREF = 0;
      }
    }
    if ( ListArg )
    {
      free(ListArg);
      ListArg = 0;
    }
    return -29999;
  }
  while ( 1 )
  {
    while ( 1 )
    {
Send_NNTP_command:
      status = response_0(command);
      if ( status == -29998 )
        goto LABEL_440;
      if ( status < 0 )
      {
        if ( retries <= 0 )
          goto LABEL_525;
        goto LABEL_527;
      }
      if ( status == 411
        && group_wanted
        && !strncmp(command, "GROUP ", 6u)
        && !strncasecomp(&response_text_0[3], " No such group ", 15)
        && !strcmp(&response_text_0[18], groupName)
        || status == 430
        && !group_wanted
        && !list_wanted
        && !strncmp(command, "ARTICLE <", 9u)
        && !strcasecomp(&response_text_0[3], " No such article") )
      {
        HTAlert(response_text_0);
        goto LABEL_527;
      }
      if ( (unsigned int)(status - 200) > 0x63 && status != 340 && status != 480 )
      {
        if ( retries )
        {
          if ( list_wanted && !strncmp(command, "XGTITLE", 7u) )
            goto LABEL_462;
          HTAlert(response_text_0);
        }
        else
        {
          mustshow[0] = 1;
          HTProgress(response_text_0);
        }
        close(s);
        s = -1;
        goto LABEL_525;
      }
      if ( status != 480 )
        break;
      if ( list_wanted
        && !strncmp(command, "XGTITLE", 7u)
        && !strstr(response_text_0, "uthenticat")
        && !strstr(response_text_0, "uthor") )
      {
LABEL_462:
        sprintf(command, "LIST NEWSGROUPS%c%c", 13, 10);
      }
      else
      {
        auth_result_0 = HTHandleAuthInfo(NewsHost);
        if ( auth_result_0 != NNTPAUTH_OK )
        {
          if ( auth_result_0 != NNTPAUTH_CLOSE )
            goto LABEL_478;
          if ( s != -1 && !ProxyHost && !ProxyHREF )
          {
            close(s);
            s = -1;
          }
          if ( retries > 0 )
          {
LABEL_478:
            status = -29999;
            goto LABEL_500;
          }
          goto LABEL_525;
        }
      }
    }
    if ( post_wanted || reply_wanted || spost_wanted || sreply_wanted )
      break;
    if ( list_wanted )
    {
      mustshow[0] = 1;
      v37 = gettext("Reading list of available newsgroups.");
      HTProgress(v37);
      status = read_list(ListArg);
      goto LABEL_500;
    }
    if ( !group_wanted )
    {
      mustshow[0] = 1;
      v39 = gettext("Reading news article.");
      HTProgress(v39);
      status = read_article(anAnchor);
      goto LABEL_500;
    }
    if ( last >= 0 )
    {
      mustshow[0] = 1;
      v38 = gettext("Reading list of articles in newsgroup.");
      HTProgress(v38);
      status = read_group(groupName, first, last);
      goto LABEL_500;
    }
    if ( head_wanted )
      v56 = "HEAD";
    else
      v56 = "ARTICLE";
    sprintf(command, "%s %d%c%c", v56, first, 13, 10);
    group_wanted = 0;
    retries = 2;
  }
  if ( status == 340 )
  {
    post_article(postfile);
  }
  else
  {
    v36 = gettext("Cannot POST to this host.");
    HTAlert(v36);
    if ( postfile )
      remove(postfile);
  }
  if ( postfile )
  {
    free(postfile);
    postfile = 0;
  }
  status = -29999;
LABEL_500:
  if ( status == -29998 )
  {
    mustshow[0] = 1;
    v40 = gettext("Connection interrupted.");
    HTProgress(v40);
    status = 200;
  }
  if ( !post_wanted && !reply_wanted && !spost_wanted && !sreply_wanted )
  {
    if ( status == -29999 )
    {
      if ( rawtext[0] )
        rawtargetClass._abort(rawtarget, 0);
      else
        targetClass._abort((HTStructured *)target, 0);
    }
    else if ( rawtext[0] )
    {
      rawtargetClass._free(rawtarget);
    }
    else
    {
      targetClass._free((HTStructured *)target);
    }
  }
  if ( NewsHREF )
  {
    free(NewsHREF);
    NewsHREF = 0;
  }
  if ( ProxyHREF )
  {
    HTSACopy(&NewsHost, ProxyHost);
    if ( ProxyHost )
    {
      free(ProxyHost);
      ProxyHost = 0;
    }
    if ( ProxyHREF )
    {
      free(ProxyHREF);
      ProxyHREF = 0;
    }
  }
  if ( ListArg )
  {
    free(ListArg);
    ListArg = 0;
  }
  if ( postfile )
  {
    remove(postfile);
    free(postfile);
  }
  return status;
}
// 813B66A: conditional instruction was optimized away because %postfile.4!=0
// 813B831: conditional instruction was optimized away because %postfile.4!=0
// 813BAA2: conditional instruction was optimized away because %postfile.4!=0
// 813BD70: conditional instruction was optimized away because %postfile.4!=0
// 813BEA6: conditional instruction was optimized away because %postfile.4!=0
// 813C7B9: conditional instruction was optimized away because %postfile.4!=0
// 813C91D: conditional instruction was optimized away because %postfile.4!=0

//----- (0813C961) --------------------------------------------------------
void HTClearNNTPAuthInfo()
{
  free_NNTP_AuthInfo();
}

//----- (0813C970) --------------------------------------------------------
void init_acceptable()
{
  const char *good; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  good = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./-_$";
  for ( i = 0; i <= 0xFF; ++i )
    acceptable[i] = 0;
  while ( *good )
    acceptable[*good++] = 1;
  acceptable_inited[0] = 1;
}

//----- (0813C9C6) --------------------------------------------------------
char __cdecl from_hex_0(char c)
{
  if ( c > 47 && c <= 57 )
    return c - 48;
  if ( c > 64 && c <= 70 )
    return c - 55;
  if ( c <= 96 || c > 102 )
    return 0;
  else
    return c - 87;
}

//----- (0813CA32) --------------------------------------------------------
void __cdecl write_anchor_0(const char *text, const char *addr)
{
  FILE *v2; // edx
  const char *value[25]; // [esp+30h] [ebp-88h] BYREF
  int i; // [esp+94h] [ebp-24h]
  BOOLEAN present[25]; // [esp+9Bh] [ebp-1Dh] BYREF
  unsigned int v6; // [esp+B4h] [ebp-4h]

  v6 = __readgsdword(0x14u);
  for ( i = 0; i <= 24; ++i )
    present[i] = 0;
  present[6] = 1;
  value[6] = addr;
  present[22] = 1;
  value[22] = text;
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "HTGopher: adding URL: %s\n", addr);
  }
  HT_Is_Gopher_URL[0] = 1;
  targetClass_0.start_element((HTStructured *)target_0, 0, present, value, -1, 0);
  targetClass_0.put_string((HTStructured *)target_0, text);
  targetClass_0.end_element((HTStructured *)target_0, 0, 0);
}

//----- (0813CB5A) --------------------------------------------------------
void __cdecl parse_menu(const char *arg, HTParentAnchor *anAnchor)
{
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v3; // eax
  void (*v4)(HTStructured *, const char *); // ebx
  char *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  char *v8; // eax
  FILE *v9; // eax
  const char *v10; // [esp+28h] [ebp-4D0h]
  char *r; // [esp+34h] [ebp-4C4h]
  char *address; // [esp+3Ch] [ebp-4BCh] BYREF
  int i; // [esp+40h] [ebp-4B8h]
  char *junk; // [esp+44h] [ebp-4B4h]
  int BytesReported; // [esp+48h] [ebp-4B0h]
  int bytes; // [esp+4Ch] [ebp-4ACh]
  const char *title; // [esp+50h] [ebp-4A8h]
  char *p; // [esp+54h] [ebp-4A4h]
  char *port; // [esp+58h] [ebp-4A0h]
  char *host; // [esp+5Ch] [ebp-49Ch]
  char *selector; // [esp+60h] [ebp-498h]
  char *name; // [esp+64h] [ebp-494h]
  int ich; // [esp+68h] [ebp-490h]
  char gtype; // [esp+6Fh] [ebp-489h]
  char line[1024]; // [esp+70h] [ebp-488h] BYREF
  char buffer[128]; // [esp+470h] [ebp-88h] BYREF
  unsigned int v27; // [esp+4F0h] [ebp-8h]

  v27 = __readgsdword(0x14u);
  name = 0;
  selector = 0;
  host = 0;
  p = line;
  bytes = 0;
  BytesReported = 0;
  targetClass_0.start_element((HTStructured *)target_0, 55, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 53, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 110, 0, 0, -1, 0);
  title = HTAnchor_title(anAnchor);
  if ( title )
  {
    targetClass_0.put_string((HTStructured *)target_0, title);
  }
  else
  {
    put_string = targetClass_0.put_string;
    v3 = gettext("Gopher Menu");
    put_string((HTStructured *)target_0, v3);
  }
  targetClass_0.end_element((HTStructured *)target_0, 110, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 53, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 17, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 47, 0, 0, -1, 0);
  title = HTAnchor_title(anAnchor);
  if ( title )
  {
    targetClass_0.put_string((HTStructured *)target_0, title);
  }
  else
  {
    v4 = targetClass_0.put_string;
    v5 = gettext("Gopher Menu");
    v4((HTStructured *)target_0, v5);
  }
  targetClass_0.end_element((HTStructured *)target_0, 47, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 86, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  while ( 1 )
  {
    ich = HTGetCharacter();
    if ( ich == -1 )
      break;
    if ( interrupted_in_htgetcharacter )
    {
      if ( WWW_TraceFlag[0] )
      {
        v6 = TraceFP();
        fprintf(v6, "HTGopher: Interrupted in HTGetCharacter, apparently.\n");
      }
      break;
    }
    if ( (_BYTE)ich == 10 )
    {
      *p++ = 0;
      bytes += p - line;
      p = line;
      port = 0;
      if ( WWW_TraceFlag[0] )
      {
        v7 = TraceFP();
        fprintf(v7, "HTGopher: Menu item: %s\n", line);
      }
      gtype = *p++;
      if ( BytesReported + 1024 < bytes )
      {
        v8 = gettext("Transferred %d bytes");
        sprintf(buffer, v8, bytes);
        HTProgress(buffer);
        BytesReported = bytes;
      }
      if ( gtype == 46 && (*p == 13 || !*p) )
        break;
      if ( gtype )
      {
        if ( *p )
        {
          name = p;
          selector = strchr(p, 9);
          if ( selector )
          {
            *selector++ = 0;
            if ( gtype == 48 && (*selector == 57 || *selector == 53) )
              gtype = *selector;
            host = strchr(selector, 9);
            if ( host )
            {
              *host++ = 0;
              port = strchr(host, 9);
              if ( port )
              {
                *port = 58;
                junk = strchr(port, 9);
                if ( junk )
                  *junk++ = 0;
                if ( port[1] == 48 && !port[2] )
                  *port = 0;
              }
            }
          }
        }
      }
      if ( gtype == 48 )
      {
        for ( i = strlen(name) - 1; name[i] == 32 && i >= 0; --i )
          name[i] = 0;
        if ( i < 0 )
          gtype = 105;
      }
      if ( gtype == 119 )
      {
        targetClass_0.put_string((HTStructured *)target_0, "(HTML) ");
        write_anchor_0(name, selector);
      }
      else if ( gtype == 105 )
      {
        targetClass_0.put_string((HTStructured *)target_0, "       ");
        targetClass_0.put_string((HTStructured *)target_0, name);
      }
      else if ( port )
      {
        address = 0;
        if ( *selector )
          v10 = "%s//%s@%s/";
        else
          v10 = "%s//%s/";
        if ( gtype == 56 )
        {
          targetClass_0.put_string((HTStructured *)target_0, " (TEL) ");
          HTSprintf0(&address, v10, "telnet:", selector, host);
        }
        else if ( gtype == 84 )
        {
          targetClass_0.put_string((HTStructured *)target_0, "(3270) ");
          HTSprintf0(&address, v10, "tn3270:", selector, host);
        }
        else
        {
          switch ( gtype )
          {
            case '0':
              targetClass_0.put_string((HTStructured *)target_0, "(FILE) ");
              break;
            case '1':
              targetClass_0.put_string((HTStructured *)target_0, " (DIR) ");
              break;
            case '2':
              targetClass_0.put_string((HTStructured *)target_0, " (CSO) ");
              break;
            case '4':
              targetClass_0.put_string((HTStructured *)target_0, " (HQX) ");
              break;
            case '5':
            case '9':
              targetClass_0.put_string((HTStructured *)target_0, " (BIN) ");
              break;
            case '6':
              targetClass_0.put_string((HTStructured *)target_0, " (UUE) ");
              break;
            case '7':
              targetClass_0.put_string((HTStructured *)target_0, "  (?)  ");
              break;
            case ':':
            case 'I':
            case 'g':
              targetClass_0.put_string((HTStructured *)target_0, " (IMG) ");
              break;
            case ';':
              targetClass_0.put_string((HTStructured *)target_0, " (MOV) ");
              break;
            case '<':
            case 's':
              targetClass_0.put_string((HTStructured *)target_0, " (SND) ");
              break;
            case 'H':
            case 'h':
              targetClass_0.put_string((HTStructured *)target_0, "(HTML) ");
              break;
            case 'P':
              targetClass_0.put_string((HTStructured *)target_0, " (PDF) ");
              break;
            case 'm':
              targetClass_0.put_string((HTStructured *)target_0, "(MIME) ");
              break;
            default:
              targetClass_0.put_string((HTStructured *)target_0, "(UNKN) ");
              break;
          }
          HTSprintf0(&address, "//%s/%c", host, gtype);
          for ( r = selector; *r; ++r )
          {
            if ( acceptable[(unsigned __int8)*r] )
              HTSprintf(&address, "%c", *r);
            else
              HTSprintf(&address, "%c%c%c", 37, hex_2[*r >> 4], hex_2[*r & 0xF]);
          }
        }
        if ( !strcmp(address, "gopher://error.host:1/0") )
          targetClass_0.put_string((HTStructured *)target_0, name);
        else
          write_anchor_0(name, address);
        if ( address )
        {
          free(address);
          address = 0;
        }
      }
      else
      {
        if ( WWW_TraceFlag[0] )
        {
          v9 = TraceFP();
          fprintf(v9, "HTGopher: Bad menu item.\n");
        }
        targetClass_0.put_string((HTStructured *)target_0, line);
      }
      targetClass_0.put_character((HTStructured *)target_0, 10);
      p = line;
    }
    else
    {
      *p = ich;
      if ( p < &line[1023] )
        ++p;
    }
  }
  targetClass_0.end_element((HTStructured *)target_0, 86, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 17, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 55, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0._free((HTStructured *)target_0);
}

//----- (0813D7F3) --------------------------------------------------------
void __cdecl parse_cso(const char *arg, HTParentAnchor *anAnchor)
{
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v3; // eax
  void (*v4)(HTStructured *, const char *); // ebx
  char *v5; // eax
  const char *title; // [esp+28h] [ebp-420h]
  const char *titlea; // [esp+28h] [ebp-420h]
  char *second_colon; // [esp+2Ch] [ebp-41Ch]
  char *first_colon; // [esp+30h] [ebp-418h]
  char *p; // [esp+34h] [ebp-414h]
  int ich; // [esp+38h] [ebp-410h]
  char last_char; // [esp+3Fh] [ebp-409h]
  char line[1024]; // [esp+40h] [ebp-408h] BYREF
  unsigned int v14; // [esp+440h] [ebp-8h]

  v14 = __readgsdword(0x14u);
  p = line;
  last_char = 0;
  targetClass_0.start_element((HTStructured *)target_0, 53, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 110, 0, 0, -1, 0);
  title = HTAnchor_title(anAnchor);
  if ( title )
  {
    targetClass_0.put_string((HTStructured *)target_0, title);
  }
  else
  {
    put_string = targetClass_0.put_string;
    v3 = gettext("CSO Search Results");
    put_string((HTStructured *)target_0, v3);
  }
  targetClass_0.end_element((HTStructured *)target_0, 110, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 53, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 47, 0, 0, -1, 0);
  titlea = HTAnchor_title(anAnchor);
  if ( titlea )
  {
    targetClass_0.put_string((HTStructured *)target_0, titlea);
  }
  else
  {
    targetClass_0.put_string((HTStructured *)target_0, arg);
    v4 = targetClass_0.put_string;
    v5 = gettext(" Search Results");
    v4((HTStructured *)target_0, v5);
  }
  targetClass_0.end_element((HTStructured *)target_0, 47, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 86, 0, 0, -1, 0);
  while ( 1 )
  {
    ich = HTGetCharacter();
    if ( ich == -1 )
      break;
    if ( (_BYTE)ich == 10 )
    {
      *p = 0;
      p = line;
      switch ( line[0] )
      {
        case '2':
          goto LABEL_24;
        case '5':
          targetClass_0.start_element((HTStructured *)target_0, 48, 0, 0, -1, 0);
          targetClass_0.put_string((HTStructured *)target_0, &line[4]);
          targetClass_0.end_element((HTStructured *)target_0, 48, 0);
          goto LABEL_24;
        case '-':
          second_colon = 0;
          first_colon = strchr(line, 58);
          if ( first_colon )
            second_colon = strchr(first_colon + 1, 58);
          if ( second_colon )
          {
            if ( *(second_colon - 1) != last_char )
            {
              targetClass_0.end_element((HTStructured *)target_0, 86, 0);
              targetClass_0.start_element((HTStructured *)target_0, 48, 0, 0, -1, 0);
            }
            targetClass_0.put_string((HTStructured *)target_0, second_colon + 1);
            targetClass_0.put_character((HTStructured *)target_0, 10);
            if ( *(second_colon - 1) != last_char )
            {
              targetClass_0.end_element((HTStructured *)target_0, 48, 0);
              targetClass_0.start_element((HTStructured *)target_0, 86, 0, 0, -1, 0);
            }
            last_char = *(second_colon - 1);
          }
          break;
      }
    }
    else
    {
      *p = ich;
      if ( p < &line[1023] )
        ++p;
    }
  }
LABEL_24:
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 86, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0._free((HTStructured *)target_0);
}

//----- (0813DDAC) --------------------------------------------------------
void __cdecl display_cso(const char *arg, HTParentAnchor *anAnchor)
{
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v3; // eax
  void (*v4)(HTStructured *, const char *); // ebx
  char *v5; // eax
  void (*v6)(HTStructured *, const char *); // ebx
  char *v7; // eax
  void (*v8)(HTStructured *, const char *); // ebx
  char *v9; // eax
  void (*v10)(HTStructured *, const char *); // ebx
  char *v11; // eax
  void (*v12)(HTStructured *, const char *); // ebx
  char *v13; // eax
  const char *title; // [esp+30h] [ebp-8h]
  const char *titlea; // [esp+30h] [ebp-8h]

  targetClass_0.start_element((HTStructured *)target_0, 53, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 110, 0, 0, -1, 0);
  title = HTAnchor_title(anAnchor);
  if ( title )
  {
    targetClass_0.put_string((HTStructured *)target_0, title);
  }
  else
  {
    put_string = targetClass_0.put_string;
    v3 = gettext("CSO index");
    put_string((HTStructured *)target_0, v3);
  }
  targetClass_0.end_element((HTStructured *)target_0, 110, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 62, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 53, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 47, 0, 0, -1, 0);
  titlea = HTAnchor_title(anAnchor);
  if ( titlea )
  {
    targetClass_0.put_string((HTStructured *)target_0, titlea);
  }
  else
  {
    targetClass_0.put_string((HTStructured *)target_0, arg);
    v4 = targetClass_0.put_string;
    v5 = gettext(" index");
    v4((HTStructured *)target_0, v5);
  }
  targetClass_0.end_element((HTStructured *)target_0, 47, 0);
  v6 = targetClass_0.put_string;
  v7 = gettext("\nThis is a searchable index of a CSO database.\n");
  v6((HTStructured *)target_0, v7);
  targetClass_0.start_element((HTStructured *)target_0, 83, 0, 0, -1, 0);
  v8 = targetClass_0.put_string;
  v9 = gettext("\nPress the 's' key and enter search keywords.\n");
  v8((HTStructured *)target_0, v9);
  targetClass_0.start_element((HTStructured *)target_0, 83, 0, 0, -1, 0);
  v10 = targetClass_0.put_string;
  v11 = gettext("\nThe keywords that you enter will allow you to search on a");
  v10((HTStructured *)target_0, v11);
  v12 = targetClass_0.put_string;
  v13 = gettext(" person's name in the database.\n");
  v12((HTStructured *)target_0, v13);
  if ( !HTAnchor_title(anAnchor) )
    HTAnchor_setTitle(anAnchor, arg);
  targetClass_0._free((HTStructured *)target_0);
}

//----- (0813E134) --------------------------------------------------------
void __cdecl display_index(const char *arg, HTParentAnchor *anAnchor)
{
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v3; // eax
  void (*v4)(HTStructured *, const char *); // ebx
  char *v5; // eax
  void (*v6)(HTStructured *, const char *); // ebx
  char *v7; // eax
  void (*v8)(HTStructured *, const char *); // ebx
  char *v9; // eax
  const char *title; // [esp+30h] [ebp-8h]
  const char *titlea; // [esp+30h] [ebp-8h]

  targetClass_0.start_element((HTStructured *)target_0, 53, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 110, 0, 0, -1, 0);
  title = HTAnchor_title(anAnchor);
  if ( title )
  {
    targetClass_0.put_string((HTStructured *)target_0, title);
  }
  else
  {
    put_string = targetClass_0.put_string;
    v3 = gettext("Gopher index");
    put_string((HTStructured *)target_0, v3);
  }
  targetClass_0.end_element((HTStructured *)target_0, 110, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 62, 0, 0, -1, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.end_element((HTStructured *)target_0, 53, 0);
  targetClass_0.put_character((HTStructured *)target_0, 10);
  targetClass_0.start_element((HTStructured *)target_0, 47, 0, 0, -1, 0);
  titlea = HTAnchor_title(anAnchor);
  if ( titlea )
  {
    targetClass_0.put_string((HTStructured *)target_0, titlea);
  }
  else
  {
    targetClass_0.put_string((HTStructured *)target_0, arg);
    v4 = targetClass_0.put_string;
    v5 = gettext(" index");
    v4((HTStructured *)target_0, v5);
  }
  targetClass_0.end_element((HTStructured *)target_0, 47, 0);
  v6 = targetClass_0.put_string;
  v7 = gettext("\nThis is a searchable Gopher index.\n");
  v6((HTStructured *)target_0, v7);
  targetClass_0.start_element((HTStructured *)target_0, 83, 0, 0, -1, 0);
  v8 = targetClass_0.put_string;
  v9 = gettext("\nPlease enter search keywords.\n");
  v8((HTStructured *)target_0, v9);
  if ( !HTAnchor_title(anAnchor) )
    HTAnchor_setTitle(anAnchor, arg);
  targetClass_0._free((HTStructured *)target_0);
}

//----- (0813E45A) --------------------------------------------------------
void __cdecl de_escape(char *command, const char *selector)
{
  char b; // [esp+14h] [ebp-14h]
  char *q; // [esp+18h] [ebp-10h]
  const char *pa; // [esp+1Ch] [ebp-Ch]
  char ca; // [esp+23h] [ebp-5h]
  char c; // [esp+23h] [ebp-5h]

  q = command;
  if ( !command )
    outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadGopher");
  while ( *selector )
  {
    if ( *selector == 37 )
    {
      pa = selector + 1;
      ca = *pa++;
      b = from_hex_0(ca);
      c = *pa;
      selector = pa + 1;
      if ( !c )
        break;
      *q++ = 16 * b + from_hex_0(c);
    }
    else
    {
      *q++ = *selector++;
    }
  }
  *q = 0;
}

//----- (0813E522) --------------------------------------------------------
void free_CSOfields()
{
  CSOfield_info *prev; // [esp+10h] [ebp-8h]
  CSOfield_info *cur; // [esp+14h] [ebp-4h]

  cur = CSOfields;
  while ( cur )
  {
    if ( cur->name != cur->name_buf && cur->name )
    {
      free(cur->name);
      cur->name = 0;
    }
    if ( cur->attributes != cur->attr_buf && cur->attributes )
    {
      free(cur->attributes);
      cur->attributes = 0;
    }
    if ( cur->description != cur->desc_buf && cur->description )
    {
      free(cur->description);
      cur->description = 0;
    }
    prev = cur;
    cur = cur->next;
    free(prev);
  }
}
// 813E5DD: conditional instruction was optimized away because %prev.4!=0

//----- (0813E5FD) --------------------------------------------------------
void __cdecl interpret_cso_key(const char *key, char *buf, int *length, CSOformgen_context *ctx, HTStream *Target)
{
  void (*put_block)(HTStream *, const char *, int); // ebx
  size_t v6; // [esp+8h] [ebp-40h]
  char *src; // [esp+1Ch] [ebp-2Ch]
  char *v8; // [esp+20h] [ebp-28h]
  int max_size; // [esp+28h] [ebp-20h]
  int field_select; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  size_t out; // [esp+38h] [ebp-10h]
  int error; // [esp+3Ch] [ebp-Ch]
  CSOfield_info *fld; // [esp+40h] [ebp-8h]
  _CSOfield_info *flda; // [esp+40h] [ebp-8h]
  CSOfield_info *fldb; // [esp+40h] [ebp-8h]

  fld = ctx->fld;
  if ( fld )
  {
    error = 0;
    if ( !strncmp(key, "$(FID)", 6u) )
    {
      sprintf(buf, "%d", fld->id);
    }
    else if ( !strncmp(key, "$(FDESC)", 8u) )
    {
      sprintf(buf, "%.2046s", fld->description);
    }
    else if ( !strncmp(key, "$(FDEF)", 7u) )
    {
      src = fld->defreturn ? " checked" : (char *)&byte_818FA9B;
      strcpy(buf, src);
    }
    else if ( !strncmp(key, "$(FNDX)", 7u) )
    {
      v8 = fld->indexed ? "*" : (char *)&byte_818FA9B;
      strcpy(buf, v8);
    }
    else if ( !strncmp(key, "$(FSIZE)", 8u) )
    {
      max_size = fld->max_size;
      if ( max_size > 55 )
        max_size = 55;
      sprintf(buf, " size=%d maxlength=%d", max_size, fld->max_size);
    }
    else if ( !strncmp(key, "$(FSIZE2)", 9u) )
    {
      sprintf(buf, " maxlength=%d", fld->max_size);
    }
    else
    {
      error = 1;
    }
    if ( !error )
      goto LABEL_73;
  }
  *buf = 0;
  if ( !strncmp(key, "$(NEXTFLD)", 0xAu) )
  {
    if ( ctx->fld )
      flda = ctx->fld->next;
    else
      flda = CSOfields;
    field_select = ctx->field_select;
    switch ( field_select )
    {
      case 1:
        while ( flda && flda->lookup != 1 )
          flda = flda->next;
        break;
      case 2:
        while ( flda && !flda->gpublic )
          flda = flda->next;
        break;
      case 0:
        while ( flda && (!flda->gpublic || flda->lookup != 1) )
          flda = flda->next;
        break;
    }
    if ( flda )
    {
      ctx->cur_line = ctx->rep_line;
      ctx->cur_off = ctx->rep_off;
    }
    ctx->fld = flda;
    goto LABEL_73;
  }
  if ( !strncmp(key, "$(QFIELDS)", 0xAu) || !strncmp(key, "$(RFIELDS)", 0xAu) )
  {
    ctx->rep_line = ctx->cur_line;
    ctx->rep_off = ctx->cur_off;
    ctx->fld = 0;
    ctx->seek = "$(NEXTFLD)";
    if ( key[2] == 81 )
      v11 = 0;
    else
      v11 = 2;
    ctx->field_select = v11;
    if ( ctx->public_override )
      ++ctx->field_select;
    goto LABEL_73;
  }
  if ( !strncmp(key, "$(NAMEFLD)", 0xAu) )
  {
    for ( fldb = CSOfields; fldb; fldb = fldb->next )
    {
      if ( !strcmp(fldb->name, "name") || !strcmp(fldb->name, "Name") )
      {
        if ( fldb->lookup )
          fldb->lookup = 2;
        break;
      }
    }
    ctx->fld = fldb;
    goto LABEL_73;
  }
  if ( !strncmp(key, "$(HOST)", 7u) )
  {
    strcpy(buf, ctx->host);
LABEL_73:
    *length = strlen(buf);
    return;
  }
  if ( !strncmp(key, "$(PORT)", 7u) )
  {
    sprintf(buf, "%d", ctx->port);
    goto LABEL_73;
  }
  out = 0;
  while ( *key && *key != 41 )
  {
    buf[out++] = *key++;
    if ( out > 2 )
    {
      buf[out] = 0;
      put_block = Target->isa->put_block;
      v6 = strlen(buf);
      put_block(Target, buf, v6);
      out = 0;
    }
  }
  buf[out] = 41;
  buf[out + 1] = 0;
  *length = strlen(buf);
}

//----- (0813EB60) --------------------------------------------------------
int __cdecl parse_cso_field_info(CSOfield_info *blk)
{
  char *max_spec; // [esp+20h] [ebp-8h]
  char *info; // [esp+24h] [ebp-4h]

  blk->url = 0;
  blk->max_size = blk->url;
  blk->reserved = blk->max_size;
  blk->lookup = blk->reserved;
  blk->indexed = blk->lookup;
  blk->gpublic = 0;
  blk->explicit_return = blk->gpublic;
  blk->defreturn = blk->explicit_return;
  info = blk->attributes;
  LYLowerCase(info);
  if ( strstr(info, "indexed ") )
    blk->indexed = 1;
  if ( strstr(info, "default ") )
    blk->defreturn = 1;
  if ( strstr(info, "public ") )
    blk->gpublic = 1;
  if ( strstr(info, "lookup ") )
    blk->lookup = 1;
  if ( strstr(info, "url ") )
  {
    blk->url = 1;
    blk->defreturn = 1;
  }
  max_spec = strstr(info, "max ");
  if ( max_spec )
    sscanf(max_spec + 4, "%d", &blk->max_size);
  else
    blk->max_size = 32;
  return 0;
}

//----- (0813ECD4) --------------------------------------------------------
int __cdecl parse_cso_fields(char *buf, int size)
{
  FILE *v2; // eax
  CSOfield_info *newf; // [esp+20h] [ebp-28h]
  CSOfield_info *last; // [esp+24h] [ebp-24h]
  char *name; // [esp+28h] [ebp-20h]
  char *indx; // [esp+2Ch] [ebp-1Ch]
  size_t alen; // [esp+30h] [ebp-18h]
  size_t alena; // [esp+30h] [ebp-18h]
  size_t alenb; // [esp+30h] [ebp-18h]
  int prev_code; // [esp+34h] [ebp-14h]
  int code; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  char *p; // [esp+40h] [ebp-8h]
  int ich; // [esp+44h] [ebp-4h]

  p = buf;
  code = 0;
  CSOfields = 0;
  last = 0;
  prev_code = -2555;
  *buf = 0;
  while ( 1 )
  {
    ich = HTGetCharacter();
    if ( ich == -1 )
    {
LABEL_46:
      if ( !*buf )
        return -1;
      *buf = 0;
      return 0;
    }
    if ( interrupted_in_htgetcharacter )
      break;
    if ( (_BYTE)ich == 10 )
    {
      *p = 0;
      p = buf;
      if ( *buf == 50 )
        goto LABEL_46;
      if ( *buf == 53 )
      {
        strcpy(buf, buf);
        return 5;
      }
      if ( *buf == 45 && buf[1] == 50 )
      {
        indx = 0;
        name = 0;
        for ( i = 0; buf[i]; ++i )
        {
          if ( buf[i] == 58 )
          {
            buf[i] = 0;
            if ( indx )
            {
              if ( name )
              {
                ++i;
                break;
              }
              name = &buf[i + 1];
            }
            else
            {
              indx = &buf[i + 1];
              code = atoi(indx);
            }
          }
        }
        if ( !name )
          goto LABEL_46;
        if ( code == prev_code )
        {
          alen = strlen(&buf[i]) + 1;
          if ( alen > 0x20 )
          {
            if ( last->description != last->desc_buf && last->description )
            {
              free(last->description);
              last->description = 0;
            }
            last->description = (char *)malloc(alen);
            if ( !last->description )
              outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadCSO");
          }
          strcpy(last->description, &buf[i]);
        }
        else
        {
          newf = (CSOfield_info *)calloc(1u, 0xB4u);
          if ( !newf )
            outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadCSO");
          if ( last )
            last->next = newf;
          else
            CSOfields = newf;
          last = newf;
          newf->next = 0;
          newf->name = newf->name_buf;
          alena = strlen(name) + 1;
          if ( alena > 0x10 )
          {
            newf->name = (char *)malloc(alena);
            if ( !newf->name )
              outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadCSO");
          }
          strcpy(newf->name, name);
          newf->attributes = newf->attr_buf;
          alenb = strlen(&buf[i]) + 2;
          if ( alenb > 0x50 )
          {
            newf->attributes = (char *)malloc(alenb);
            if ( !newf->attributes )
              outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadCSO");
          }
          strcpy(newf->attributes, &buf[i]);
          memcpy(&newf->attributes[alenb - 2], " ", 2u);
          newf->description = newf->desc_buf;
          newf->desc_buf[0] = 0;
          newf->id = atoi(indx);
          parse_cso_field_info(newf);
        }
        prev_code = code;
      }
    }
    else
    {
      *p = ich;
      if ( &buf[size - 1] > p )
        ++p;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v2 = TraceFP();
    fprintf(v2, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
  }
  free_CSOfields();
  *buf = 0;
  return -29998;
}

//----- (0813F0CD) --------------------------------------------------------
int __cdecl generate_cso_form(char *host, int port, char *buf, HTStream *Target)
{
  void (*put_block)(HTStream *, const char *, int); // ebx
  char *seek; // ebx
  char *v6; // eax
  void (*v7)(HTStream *, const char *, int); // ebx
  bool v8; // cf
  void (*v9)(HTStream *, const char *, int); // ebx
  void (*v10)(HTStream *, const char *, int); // ebx
  size_t v12; // [esp+8h] [ebp-60h]
  size_t v13; // [esp+8h] [ebp-60h]
  size_t v14; // [esp+8h] [ebp-60h]
  size_t v15; // [esp+8h] [ebp-60h]
  CSOformgen_context ctx; // [esp+18h] [ebp-50h] BYREF
  char *temp; // [esp+40h] [ebp-28h] BYREF
  int slen; // [esp+44h] [ebp-24h]
  const char *line; // [esp+48h] [ebp-20h]
  const char *key; // [esp+4Ch] [ebp-1Ch]
  int full_flag; // [esp+50h] [ebp-18h]
  size_t out; // [esp+54h] [ebp-14h]
  int length; // [esp+58h] [ebp-10h] BYREF
  int j; // [esp+5Ch] [ebp-Ch]
  int i; // [esp+60h] [ebp-8h]

  full_flag = 1;
  out = 0;
  memset(&ctx, 0, sizeof(ctx));
  ctx.host = host;
  ctx.seek = 0;
  ctx.port = port;
  ctx.fld = 0;
  ctx.public_override = full_flag;
  out = 0;
  *buf = 0;
  for ( i = 0; ctemplate_10585[i]; ++i )
  {
    line = ctemplate_10585[i];
    for ( j = 0; line[j]; ++j )
    {
      if ( line[j] == 36 && line[j + 1] == 40 )
      {
        buf[out] = 0;
        if ( out )
        {
          put_block = Target->isa->put_block;
          v12 = strlen(buf);
          put_block(Target, buf, v12);
        }
        out = 0;
        key = &line[j];
        while ( line[j + 1] && line[j] != 41 )
          ++j;
        ctx.cur_line = i;
        ctx.cur_off = j;
        interpret_cso_key(key, buf, &length, &ctx, Target);
        i = ctx.cur_line;
        j = ctx.cur_off;
        line = ctemplate_10585[ctx.cur_line];
        out = length;
        if ( ctx.seek )
        {
          slen = strlen(ctx.seek);
          while ( ctemplate_10585[i] )
          {
            line = ctemplate_10585[i];
            while ( line[j] )
            {
              if ( line[j] == 36 && !strncmp(ctx.seek, &line[j], slen) )
              {
                if ( j )
                  --j;
                else
                  j = strlen(ctemplate_10585[--i]) - 1;
                line = ctemplate_10585[i];
                ctx.seek = 0;
                break;
              }
              ++j;
            }
            if ( !ctx.seek )
              break;
            j = 0;
            ++i;
          }
          if ( ctx.seek )
          {
            temp = 0;
            seek = ctx.seek;
            v6 = gettext("Seek fail on %s\n");
            HTSprintf0(&temp, v6, seek);
            v7 = Target->isa->put_block;
            v13 = strlen(temp);
            v7(Target, temp, v13);
            if ( temp )
            {
              free(temp);
              temp = 0;
            }
          }
        }
      }
      else
      {
        buf[out] = line[j];
        v8 = out++ == -1;
        if ( !v8 && out != 1 )
        {
          buf[out] = 0;
          v9 = Target->isa->put_block;
          v14 = strlen(buf);
          v9(Target, buf, v14);
          out = 0;
        }
      }
    }
    buf[out] = 10;
    buf[++out] = 0;
  }
  if ( out )
  {
    v10 = Target->isa->put_block;
    v15 = strlen(buf);
    v10(Target, buf, v15);
  }
  return 0;
}

//----- (0813F44A) --------------------------------------------------------
int __cdecl generate_cso_report(HTStream *Target)
{
  FILE *v1; // eax
  char *v2; // eax
  void (*put_block)(HTStream *, const char *, int); // ebx
  void (*v4)(HTStream *, const char *, int); // ebx
  void (*v5)(HTStream *, const char *, int); // ebx
  void (*v6)(HTStream *, const char *, int); // ebx
  void (*v7)(HTStream *, const char *, int); // ebx
  int v8; // eax
  char *v9; // eax
  int v10; // eax
  void (*v11)(HTStream *, const char *, int); // ebx
  void (*v12)(HTStream *, const char *, int); // ebx
  int v13; // eax
  char *v14; // eax
  int v15; // eax
  void (*v16)(HTStream *, const char *, int); // ebx
  void (*v17)(HTStream *, const char *, int); // ebx
  size_t v19; // [esp+8h] [ebp-460h]
  size_t v20; // [esp+8h] [ebp-460h]
  size_t v21; // [esp+8h] [ebp-460h]
  size_t v22; // [esp+8h] [ebp-460h]
  size_t v23; // [esp+8h] [ebp-460h]
  size_t v24; // [esp+8h] [ebp-460h]
  size_t v25; // [esp+8h] [ebp-460h]
  size_t v26; // [esp+8h] [ebp-460h]
  size_t v27; // [esp+8h] [ebp-460h]
  char *v28; // [esp+18h] [ebp-450h]
  const char *v29; // [esp+1Ch] [ebp-44Ch]
  CSOfield_info *fld; // [esp+24h] [ebp-444h]
  char *l; // [esp+28h] [ebp-440h]
  char *la; // [esp+28h] [ebp-440h]
  char *fvalue; // [esp+2Ch] [ebp-43Ch]
  char *fname; // [esp+30h] [ebp-438h]
  char *ndx_str; // [esp+34h] [ebp-434h]
  int ndx; // [esp+3Ch] [ebp-42Ch]
  int prev_ndx; // [esp+40h] [ebp-428h]
  int i; // [esp+44h] [ebp-424h]
  int ia; // [esp+44h] [ebp-424h]
  int len; // [esp+48h] [ebp-420h]
  char *href; // [esp+4Ch] [ebp-41Ch] BYREF
  char *p; // [esp+50h] [ebp-418h]
  char *buf; // [esp+54h] [ebp-414h] BYREF
  int ich; // [esp+58h] [ebp-410h]
  BOOLEAN stop; // [esp+5Fh] [ebp-409h]
  char line[1024]; // [esp+60h] [ebp-408h] BYREF
  unsigned int v47; // [esp+460h] [ebp-8h]

  v47 = __readgsdword(0x14u);
  buf = 0;
  p = line;
  href = 0;
  stop = 0;
  prev_ndx = -100;
  while ( !stop )
  {
    ich = HTGetCharacter();
    if ( ich == -1 )
      break;
    if ( interrupted_in_htgetcharacter )
    {
      if ( WWW_TraceFlag[0] )
      {
        v1 = TraceFP();
        fprintf(v1, "HTLoadCSO: Interrupted in HTGetCharacter, apparently.\n");
      }
      mustshow[0] = 1;
      v2 = gettext("Connection interrupted.");
      HTProgress(v2);
      break;
    }
    if ( (_BYTE)ich == 10 )
    {
      *p = 0;
      p = line;
      if ( line[0] != 45 && *p != 49 )
        stop = 1;
      if ( *p == 45 )
        v28 = p + 1;
      else
        v28 = p;
      fname = 0;
      ndx_str = 0;
      len = strlen(p);
      for ( i = 0; i < len; ++i )
      {
        if ( p[i] == 58 )
        {
          p[i] = 0;
          if ( ndx_str )
          {
            fname = &p[i + 1];
            break;
          }
          ndx_str = &p[i + 1];
          fname = ndx_str;
        }
      }
      if ( ndx_str )
      {
        ndx = atoi(ndx_str);
        if ( prev_ndx != ndx )
        {
          if ( prev_ndx != -100 )
          {
            HTSprintf0(&buf, "</DL></DL>\n");
            put_block = Target->isa->put_block;
            v19 = strlen(buf);
            put_block(Target, buf, v19);
          }
          if ( ndx )
            HTSprintf0(&buf, "<HR><DL><DT>Entry %d:<DD><DL COMPACT><DT>\n", ndx);
          else
            HTSprintf0(&buf, "<HR><DL><DT>Information/status<DD><DL><DT>\n");
          v4 = Target->isa->put_block;
          v20 = strlen(buf);
          v4(Target, buf, v20);
          prev_ndx = ndx;
        }
        if ( *v28 <= 49 || *v28 > 53 || fname == ndx_str )
        {
          if ( fname )
            v29 = fname;
          else
            v29 = v28;
          HTSprintf0(&buf, "<DD>%s\n", v29);
          v16 = Target->isa->put_block;
          v26 = strlen(buf);
          v16(Target, buf, v26);
        }
        else
        {
          while ( *fname == 32 )
            ++fname;
          for ( fvalue = fname; *fvalue; ++fvalue )
          {
            if ( *fvalue == 58 )
            {
              *fvalue++ = 0;
              for ( ia = strlen(fname) - 1; ia >= 0 && fname[ia] == 32; --ia )
                fname[ia] = 0;
              break;
            }
          }
          if ( fvalue )
          {
            while ( *fvalue == 32 )
              ++fvalue;
          }
          if ( *fname )
          {
            for ( fld = CSOfields; fld; fld = fld->next )
            {
              if ( !strcmp(fld->name, fname) )
              {
                if ( fld->description )
                  fname = fld->description;
                break;
              }
            }
            if ( !fld || !fld->url )
            {
              HTSprintf0(&buf, "<DT><I>%s</I><DD>", fname);
              v7 = Target->isa->put_block;
              v23 = strlen(buf);
              v7(Target, buf, v23);
              *buf = 0;
              l = fvalue;
              while ( *l )
              {
                if ( *l == 60 )
                {
                  HTSACat(&buf, "&lt;");
                  ++l;
                }
                else if ( *l == 62 )
                {
                  HTSACat(&buf, "&gt;");
                  ++l;
                }
                else if ( !strncmp(l, "news:", 5u)
                       || !strncmp(l, "snews://", 8u)
                       || !strncmp(l, "nntp://", 7u)
                       || !strncmp(l, "snewspost:", 0xAu)
                       || !strncmp(l, "snewsreply:", 0xBu)
                       || !strncmp(l, "newspost:", 9u)
                       || !strncmp(l, "newsreply:", 0xAu)
                       || !strncmp(l, "ftp://", 6u)
                       || !strncmp(l, "file:/", 6u)
                       || !strncmp(l, "finger://", 9u)
                       || !strncmp(l, "http://", 7u)
                       || !strncmp(l, "https://", 8u)
                       || !strncmp(l, "wais://", 7u)
                       || !strncmp(l, "mailto:", 7u)
                       || !strncmp(l, "cso://", 6u)
                       || !strncmp(l, "gopher://", 9u) )
                {
                  HTSACat(&buf, "<a href=\"");
                  HTSACopy(&href, l);
                  v9 = strtok(href, " \r\n\t,>)\"");
                  HTSACat(&buf, v9);
                  HTSACat(&buf, "\">");
                  while ( *l && !strchr(" \r\n\t,>)\"", *l) )
                  {
                    v10 = *l++;
                    HTSprintf(&buf, "%c", v10);
                  }
                  HTSACat(&buf, "</a>");
                  if ( href )
                  {
                    free(href);
                    href = 0;
                  }
                }
                else
                {
                  v8 = *l++;
                  HTSprintf(&buf, "%c", v8);
                }
              }
              goto LABEL_90;
            }
            HTSprintf0(&buf, "<DT><I>%s</I><DD><A HREF=\"%s\">%s</A>\n", fname, fvalue, fvalue);
            v6 = Target->isa->put_block;
            v22 = strlen(buf);
            v6(Target, buf, v22);
          }
          else
          {
            HTSprintf0(&buf, "<DD>");
            v12 = Target->isa->put_block;
            v25 = strlen(buf);
            v12(Target, buf, v25);
            *buf = 0;
            la = fvalue;
            while ( *la )
            {
              if ( *la == 60 )
              {
                HTSACat(&buf, "&lt;");
                ++la;
              }
              else if ( *la == 62 )
              {
                HTSACat(&buf, "&gt;");
                ++la;
              }
              else if ( !strncmp(la, "news:", 5u)
                     || !strncmp(la, "snews://", 8u)
                     || !strncmp(la, "nntp://", 7u)
                     || !strncmp(la, "snewspost:", 0xAu)
                     || !strncmp(la, "snewsreply:", 0xBu)
                     || !strncmp(la, "newspost:", 9u)
                     || !strncmp(la, "newsreply:", 0xAu)
                     || !strncmp(la, "ftp://", 6u)
                     || !strncmp(la, "file:/", 6u)
                     || !strncmp(la, "finger://", 9u)
                     || !strncmp(la, "http://", 7u)
                     || !strncmp(la, "https://", 8u)
                     || !strncmp(la, "wais://", 7u)
                     || !strncmp(la, "mailto:", 7u)
                     || !strncmp(la, "cso://", 6u)
                     || !strncmp(la, "gopher://", 9u) )
              {
                HTSACat(&buf, "<a href=\"");
                HTSACopy(&href, la);
                v14 = strtok(href, " \r\n\t,>)\"");
                HTSACat(&buf, v14);
                HTSACat(&buf, "\">");
                while ( *la && !strchr(" \r\n\t,>)\"", *la) )
                {
                  v15 = *la++;
                  HTSprintf(&buf, "%c", v15);
                }
                HTSACat(&buf, "</a>");
                if ( href )
                {
                  free(href);
                  href = 0;
                }
              }
              else
              {
                v13 = *la++;
                HTSprintf(&buf, "%c", v13);
              }
            }
LABEL_90:
            HTSACat(&buf, "\n");
            v11 = Target->isa->put_block;
            v24 = strlen(buf);
            v11(Target, buf, v24);
          }
        }
      }
      else
      {
        HTSprintf0(&buf, "<DD>%s\n", v28);
        v5 = Target->isa->put_block;
        v21 = strlen(buf);
        v5(Target, buf, v21);
      }
    }
    else
    {
      *p = ich;
      if ( p < &line[1023] )
        ++p;
    }
  }
  if ( prev_ndx != -100 )
  {
    HTSprintf0(&buf, "</DL></DL>\n");
    v17 = Target->isa->put_block;
    v27 = strlen(buf);
    v17(Target, buf, v27);
  }
  if ( buf )
  {
    free(buf);
    buf = 0;
  }
  return 0;
}

//----- (0814042F) --------------------------------------------------------
int __cdecl HTLoadCSO(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  FILE *v4; // eax
  FILE *v5; // eax
  char *v6; // eax
  FILE *v7; // eax
  FILE *v8; // eax
  int v9; // ebx
  FILE *v10; // eax
  char *v11; // eax
  FILE *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *name; // esi
  char *v17; // ebx
  char *v18; // eax
  void (*put_block)(HTStream *, const char *, int); // ebx
  size_t v20; // eax
  void (*v21)(HTStream *, const char *, int); // ebx
  size_t v22; // eax
  void (*v23)(HTStream *, const char *, int); // ebx
  size_t v24; // eax
  void (*v25)(HTStream *, const char *, int); // ebx
  size_t v26; // eax
  void (*v27)(HTStream *, const char *, int); // ebx
  size_t v28; // eax
  FILE *v29; // eax
  int v30; // ebx
  FILE *v31; // eax
  FILE *v32; // eax
  int n; // [esp+18h] [ebp-8C0h]
  char *str; // [esp+1Ch] [ebp-8BCh]
  int v37; // [esp+24h] [ebp-8B4h]
  char *v38; // [esp+28h] [ebp-8B0h]
  int v39; // [esp+2Ch] [ebp-8ACh]
  const char *src; // [esp+30h] [ebp-8A8h]
  char *v41; // [esp+34h] [ebp-8A4h]
  int v42; // [esp+38h] [ebp-8A0h]
  char *v43; // [esp+3Ch] [ebp-89Ch]
  int v44; // [esp+40h] [ebp-898h]
  char *v45; // [esp+44h] [ebp-894h]
  int v46; // [esp+48h] [ebp-890h]
  int v47; // [esp+50h] [ebp-888h]
  char *v48; // [esp+54h] [ebp-884h]
  int v49; // [esp+58h] [ebp-880h]
  char *v50; // [esp+5Ch] [ebp-87Ch]
  char *temp; // [esp+7Ch] [ebp-85Ch] BYREF
  HTStream *Target; // [esp+80h] [ebp-858h]
  HTFormat format_in; // [esp+84h] [ebp-854h]
  CSOfield_info *fld; // [esp+88h] [ebp-850h]
  int has_indexed; // [esp+8Ch] [ebp-84Ch]
  int return_type; // [esp+90h] [ebp-848h]
  int ndx; // [esp+94h] [ebp-844h] BYREF
  int flen; // [esp+98h] [ebp-840h]
  int finish; // [esp+9Ch] [ebp-83Ch]
  int start; // [esp+A0h] [ebp-838h]
  int j; // [esp+A4h] [ebp-834h]
  int i; // [esp+A8h] [ebp-830h]
  int len; // [esp+ACh] [ebp-82Ch]
  bstring *content; // [esp+B0h] [ebp-828h] BYREF
  bstring *command; // [esp+B4h] [ebp-824h] BYREF
  int status; // [esp+B8h] [ebp-820h]
  int port; // [esp+BCh] [ebp-81Ch]
  char *data; // [esp+C0h] [ebp-818h]
  char *cp; // [esp+C4h] [ebp-814h]
  char *host; // [esp+C8h] [ebp-810h]
  char buf[2048]; // [esp+CCh] [ebp-80Ch] BYREF
  unsigned int v72; // [esp+8CCh] [ebp-Ch]

  v72 = __readgsdword(0x14u);
  port = 105;
  command = 0;
  content = 0;
  format_in = HTAtom_for("text/html");
  Target = 0;
  if ( !acceptable_inited[0] )
    init_acceptable();
  if ( !arg )
    return -3;
  if ( !*arg )
    return -2;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "HTLoadCSO: Looking for %s\n", arg);
  }
  status = HTDoConnect(arg, "cso", 105, &s_0);
  if ( status == -29998 )
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "HTLoadCSO: Interrupted on connect; recovering cleanly.\n");
    }
    mustshow[0] = 1;
    v6 = gettext("Connection interrupted.");
    HTProgress(v6);
    return -29999;
  }
  else if ( status >= 0 )
  {
    HTInitInput(s_0);
    HTBprintf(&command, "fields%c%c", 13, 10);
    if ( WWW_TraceFlag[0] )
    {
      v8 = TraceFP();
      fprintf(v8, "HTLoadCSO: Connected, writing command `");
      trace_bstring(command);
      if ( WWW_TraceFlag[0] )
      {
        v9 = s_0;
        v10 = TraceFP();
        fprintf(v10, "' to socket %d\n", v9);
      }
    }
    mustshow[0] = 1;
    v11 = gettext("Sending CSO/PH request.");
    HTProgress(v11);
    if ( command )
      n = command->len;
    else
      n = 0;
    if ( command )
      str = command->str;
    else
      str = 0;
    status = write(s_0, str, n);
    HTSABFree(&command);
    if ( status >= 0 )
    {
      mustshow[0] = 1;
      v13 = gettext("CSO/PH request sent; waiting for response.");
      HTProgress(v13);
      status = parse_cso_fields(buf, 2048);
      if ( status )
      {
        close(s_0);
        if ( status == -29998 )
        {
          mustshow[0] = 1;
          v14 = gettext("Connection interrupted.");
          HTProgress(v14);
        }
        else if ( buf[0] )
        {
          HTAlert(buf);
        }
        else
        {
          v15 = gettext("No response from server!");
          HTAlert(v15);
        }
        return -29999;
      }
      else
      {
        Target = (HTStream *)HTStreamStack(format_in, format_out, (HTStream_5 *)sink, anAnchor);
        if ( Target )
        {
          host = HTParse(arg, &byte_818FA9B, 8);
          cp = strchr(host, 58);
          if ( cp )
          {
            if ( cp[1] > 47 && cp[1] <= 57 )
            {
              port = atoi(cp + 1);
              if ( port == 105 )
                *cp = 0;
            }
          }
          anAnchor->safe = 1;
          if ( anAnchor->post_data && anAnchor->post_data->len )
          {
            HTBprintf(&command, "<HTML>\n<HEAD>\n<TITLE>CSO/PH Results on %s</TITLE>\n</HEAD>\n<BODY>\n", host);
            if ( command )
              v37 = command->len;
            else
              v37 = 0;
            if ( command )
              v38 = command->str;
            else
              v38 = 0;
            Target->isa->put_block(Target, v38, v37);
            HTSABFree(&command);
            if ( host )
            {
              free(host);
              host = 0;
            }
            if ( anAnchor->post_data )
              v39 = anAnchor->post_data->len;
            else
              v39 = 0;
            if ( anAnchor->post_data )
              src = anAnchor->post_data->str;
            else
              src = 0;
            HTSABCopy(&content, src, v39);
            if ( content )
              v41 = content->str;
            else
              v41 = 0;
            if ( content )
              v42 = content->len - 1;
            else
              v42 = -1;
            if ( v41[v42] != 38 )
              HTSABCat0(&content, "&");
            if ( content )
              v43 = content->str;
            else
              v43 = 0;
            data = v43;
            if ( content )
              v44 = content->len;
            else
              v44 = 0;
            len = v44;
            for ( i = 0; i < len; ++i )
            {
              if ( data[i] == 43 )
                data[i] = 32;
            }
            if ( content )
              v45 = content->str;
            else
              v45 = 0;
            data = v45;
            HTUnEscape(v45);
            if ( content )
              v46 = content->len;
            else
              v46 = 0;
            len = v46;
            return_type = 0;
            has_indexed = 0;
            finish = 0;
            start = 0;
            for ( i = 0; i < len; ++i )
            {
              if ( !data[i] || data[i] == 38 )
              {
                flen = i - start;
                finish = i;
                data[i] = 0;
                for ( j = start; j < finish; ++j )
                {
                  if ( data[j] == 61 )
                  {
                    if ( data[start + 1] == 95 && (data[start] == 114 || data[start] == 113) )
                    {
                      sscanf(&data[start + 2], "%d=", &ndx);
                      for ( fld = CSOfields; fld; fld = fld->next )
                      {
                        if ( fld->id == ndx )
                        {
                          if ( j + 1 < finish )
                          {
                            if ( data[start] == 113 )
                            {
                              if ( fld->lookup )
                              {
                                if ( fld->indexed )
                                  has_indexed = 1;
                                if ( command && command->len )
                                  HTSABCat0(&command, " ");
                                else
                                  HTSABCopy0(&command, "query ");
                                HTBprintf(&command, "%s=\"%s\"", fld->name, &data[j + 1]);
                              }
                              else
                              {
                                memcpy(buf, "Warning: non-lookup field ignored<BR>\n", 0x27u);
                                put_block = Target->isa->put_block;
                                v20 = strlen(buf);
                                put_block(Target, buf, v20);
                              }
                            }
                            else if ( data[start] == 114 )
                            {
                              fld->explicit_return = 1;
                            }
                          }
                          break;
                        }
                      }
                    }
                    else if ( !strncmp(&data[start], "return=", 7u) )
                    {
                      if ( !strcmp(&data[start + 7], "all") )
                      {
                        return_type = 1;
                      }
                      else if ( !strcmp(&data[start + 7], "selected") )
                      {
                        return_type = 2;
                      }
                    }
                  }
                }
                start = i + 1;
              }
            }
            HTSABFree(&content);
            if ( command && command->len && has_indexed )
            {
              if ( return_type == 1 )
              {
                HTSABCat0(&command, " return all");
              }
              else if ( return_type == 2 )
              {
                HTSABCat0(&command, " return");
                for ( fld = CSOfields; fld; fld = fld->next )
                {
                  if ( fld->explicit_return )
                    HTBprintf(&command, " %s", fld->name);
                }
              }
              HTBprintf(&command, "%c%c", 13, 10);
              memcpy(buf, "<H2>\n<EM>CSO/PH command:</EM> ", 0x1Fu);
              v25 = Target->isa->put_block;
              v26 = strlen(buf);
              v25(Target, buf, v26);
              if ( command )
                v47 = command->len;
              else
                v47 = 0;
              if ( command )
                v48 = command->str;
              else
                v48 = 0;
              Target->isa->put_block(Target, v48, v47);
              memcpy(buf, "</H2>\n", 7u);
              v27 = Target->isa->put_block;
              v28 = strlen(buf);
              v27(Target, buf, v28);
              if ( WWW_TraceFlag[0] )
              {
                v29 = TraceFP();
                fprintf(v29, "HTLoadCSO: Writing command `");
                trace_bstring(command);
                if ( WWW_TraceFlag[0] )
                {
                  v30 = s_0;
                  v31 = TraceFP();
                  fprintf(v31, "' to socket %d\n", v30);
                }
              }
              if ( command )
                v49 = command->len;
              else
                v49 = 0;
              if ( command )
                v50 = command->str;
              else
                v50 = 0;
              status = write(s_0, v50, v49);
              HTSABFree(&command);
              if ( status >= 0 )
              {
                generate_cso_report(Target);
                close(s_0);
                Target->isa->put_block(Target, "</BODY>\n</HTML>\n", 16);
                Target->isa->_free(Target);
                if ( host )
                {
                  free(host);
                  host = 0;
                }
                free_CSOfields();
                return 200;
              }
              else
              {
                if ( WWW_TraceFlag[0] )
                {
                  v32 = TraceFP();
                  fprintf(v32, "HTLoadCSO: Unable to send command.\n");
                }
                free_CSOfields();
                return HTInetStatus("send");
              }
            }
            else
            {
              close(s_0);
              memcpy(buf, "<EM>Error:</EM> At least one indexed field value must be specified!\n", 0x45u);
              v21 = Target->isa->put_block;
              v22 = strlen(buf);
              v21(Target, buf, v22);
              memcpy(buf, "</BODY>\n</HTML>\n", 0x11u);
              v23 = Target->isa->put_block;
              v24 = strlen(buf);
              v23(Target, buf, v24);
              Target->isa->_free(Target);
              free_CSOfields();
              return 200;
            }
          }
          else
          {
            generate_cso_form(host, port, buf, Target);
            Target->isa->_free(Target);
            if ( host )
            {
              free(host);
              host = 0;
            }
            close(s_0);
            free_CSOfields();
            return 200;
          }
        }
        else
        {
          temp = 0;
          name = format_out->name;
          v17 = format_in->name;
          v18 = gettext("Sorry, no known way of converting %s to %s.");
          HTSprintf0(&temp, v18, v17, name);
          HTAlert(temp);
          if ( temp )
          {
            free(temp);
            temp = 0;
          }
          close(s_0);
          return -29999;
        }
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v12 = TraceFP();
        fprintf(v12, "HTLoadCSO: Unable to send command.\n");
      }
      return HTInetStatus("send");
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v7 = TraceFP();
      fprintf(v7, "HTLoadCSO: Unable to connect to remote host for `%s'.\n", arg);
    }
    return HTInetStatus("connect");
  }
}
// 8140EB9: conditional instruction was optimized away because %command.4!=0
// 81410B6: conditional instruction was optimized away because %command.4!=0

//----- (08141554) --------------------------------------------------------
int __cdecl HTLoadGopher(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  const HTStructuredClass *isa; // edx
  size_t v8; // ebx
  size_t v9; // eax
  size_t v10; // eax
  char *v11; // edx
  const HTStructuredClass *v12; // edx
  size_t v13; // eax
  char *v14; // edx
  size_t v15; // eax
  size_t v16; // eax
  FILE *v17; // eax
  char *v18; // eax
  FILE *v19; // eax
  int v20; // ebx
  FILE *v21; // edx
  char *v22; // eax
  FILE *v23; // eax
  char *v24; // eax
  int v25; // ebx
  HTAtom *v26; // edx
  int v27; // ebx
  HTAtom *v28; // edx
  int v29; // ebx
  HTAtom *v30; // edx
  const HTStructuredClass *v31; // edx
  const HTStructuredClass *v32; // edx
  int v33; // ebx
  HTAtom *v34; // edx
  int v35; // ebx
  HTAtom *v36; // edx
  int v37; // ebx
  HTAtom *v38; // edx
  int v39; // ebx
  HTAtom *v40; // edx
  size_t v42; // [esp+8h] [ebp-50h]
  char *p_0; // [esp+2Ch] [ebp-2Ch]
  char *query_0; // [esp+30h] [ebp-28h]
  char *query_0a; // [esp+30h] [ebp-28h]
  char *p; // [esp+34h] [ebp-24h]
  char *query; // [esp+38h] [ebp-20h]
  char *querya; // [esp+38h] [ebp-20h]
  char *p1; // [esp+3Ch] [ebp-1Ch]
  int len; // [esp+40h] [ebp-18h]
  char *selector; // [esp+44h] [ebp-14h]
  int status; // [esp+48h] [ebp-10h]
  int statusa; // [esp+48h] [ebp-10h]
  char *command; // [esp+4Ch] [ebp-Ch]
  char gtype; // [esp+53h] [ebp-5h]

  if ( !acceptable_inited[0] )
    init_acceptable();
  if ( !arg )
    return -3;
  if ( !*arg )
    return -2;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "HTGopher: Looking for %s\n", arg);
  }
  len = strlen(arg);
  if ( len > 5 && !strcmp(&arg[len - 6], ":105/2") )
  {
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "HTGopher: Passing to CSO/PH gateway.\n");
    }
    return HTLoadCSO(arg, anAnchor, format_out, sink);
  }
  else if ( strstr(arg, ":79/0") )
  {
    if ( WWW_TraceFlag[0] )
    {
      v6 = TraceFP();
      fprintf(v6, "HTGopher: Passing to finger gateway.\n");
    }
    return HTLoadFinger(arg, anAnchor, format_out, sink);
  }
  else
  {
    p1 = HTParse(arg, &byte_818FA9B, 5);
    gtype = 49;
    selector = p1 + 1;
    if ( *p1 == 47 && *selector )
    {
      gtype = *selector;
      selector = p1 + 2;
    }
    if ( gtype == 55 )
    {
      HTAnchor_setIndex(anAnchor, anAnchor->address);
      query = strchr(selector, 63);
      if ( !query || !query[1] )
      {
        target_0 = (HTStructured_1 *)HTML_new(anAnchor, format_out, (HTStream_0 *)sink);
        isa = target_0->isa;
        targetClass_0.name = target_0->isa->name;
        targetClass_0._free = isa->_free;
        targetClass_0._abort = isa->_abort;
        targetClass_0.put_character = isa->put_character;
        targetClass_0.put_string = isa->put_string;
        targetClass_0.put_block = isa->put_block;
        targetClass_0.start_element = isa->start_element;
        targetClass_0.end_element = isa->end_element;
        targetClass_0.put_entity = isa->put_entity;
        display_index(arg, anAnchor);
        return 200;
      }
      *query = 0;
      querya = query + 1;
      v8 = strlen(selector);
      v9 = strlen(querya);
      command = (char *)malloc(v8 + v9 + 4);
      if ( !command )
        outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadGopher");
      de_escape(command, selector);
      v10 = strlen(command);
      memcpy(&command[v10], "\t", 2u);
      for ( p = querya; *p; ++p )
      {
        if ( *p == 43 )
          *p = 32;
      }
      v11 = &command[strlen(command)];
      de_escape(v11, querya);
    }
    else if ( gtype == 50 )
    {
      query_0 = strchr(selector, 63);
      if ( !query_0 || !query_0[1] )
      {
        target_0 = (HTStructured_1 *)HTML_new(anAnchor, format_out, (HTStream_0 *)sink);
        v12 = target_0->isa;
        targetClass_0.name = target_0->isa->name;
        targetClass_0._free = v12->_free;
        targetClass_0._abort = v12->_abort;
        targetClass_0.put_character = v12->put_character;
        targetClass_0.put_string = v12->put_string;
        targetClass_0.put_block = v12->put_block;
        targetClass_0.start_element = v12->start_element;
        targetClass_0.end_element = v12->end_element;
        targetClass_0.put_entity = v12->put_entity;
        display_cso(arg, anAnchor);
        return 200;
      }
      HTAnchor_setIndex(anAnchor, anAnchor->address);
      *query_0 = 0;
      query_0a = query_0 + 1;
      v13 = strlen(query_0a);
      command = (char *)malloc(v13 + 9);
      if ( !command )
        outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadGopher");
      de_escape(command, selector);
      memcpy(command, "query ", 7u);
      for ( p_0 = query_0a; *p_0; ++p_0 )
      {
        if ( *p_0 == 43 )
          *p_0 = 32;
      }
      v14 = &command[strlen(command)];
      de_escape(v14, query_0a);
    }
    else
    {
      v15 = strlen(selector);
      command = (char *)malloc(v15 + 3);
      if ( !command )
        outofmem("../../../WWW/Library/Implementation/HTGopher.c", "HTLoadGopher");
      de_escape(command, selector);
    }
    if ( p1 )
      free(p1);
    v16 = strlen(command);
    command[v16] = 13;
    command[v16 + 1] = 10;
    command[v16 + 2] = 0;
    status = HTDoConnect(arg, "gopher", 70, &s_0);
    if ( status == -29998 )
    {
      if ( WWW_TraceFlag[0] )
      {
        v17 = TraceFP();
        fprintf(v17, "HTGopher: Interrupted on connect; recovering cleanly.\n");
      }
      mustshow[0] = 1;
      v18 = gettext("Connection interrupted.");
      HTProgress(v18);
      free(command);
      return -29999;
    }
    else if ( status >= 0 )
    {
      HTInitInput(s_0);
      if ( WWW_TraceFlag[0] )
      {
        v20 = s_0;
        v21 = TraceFP();
        fprintf(v21, "HTGopher: Connected, writing command `%s' to socket %d\n", command, v20);
      }
      mustshow[0] = 1;
      v22 = gettext("Sending Gopher request.");
      HTProgress(v22);
      v42 = strlen(command);
      statusa = write(s_0, command, v42);
      free(command);
      if ( statusa >= 0 )
      {
        mustshow[0] = 1;
        v24 = gettext("Gopher request sent; waiting for response.");
        HTProgress(v24);
        switch ( gtype )
        {
          case '0':
            v25 = s_0;
            v26 = HTAtom_for("text/plain");
            HTParseSocket(v26, format_out, anAnchor, v25, (HTStream_5 *)sink);
            break;
          case '1':
          case '7':
            target_0 = (HTStructured_1 *)HTML_new(anAnchor, format_out, (HTStream_0 *)sink);
            v31 = target_0->isa;
            targetClass_0.name = target_0->isa->name;
            targetClass_0._free = v31->_free;
            targetClass_0._abort = v31->_abort;
            targetClass_0.put_character = v31->put_character;
            targetClass_0.put_string = v31->put_string;
            targetClass_0.put_block = v31->put_block;
            targetClass_0.start_element = v31->start_element;
            targetClass_0.end_element = v31->end_element;
            targetClass_0.put_entity = v31->put_entity;
            parse_menu(arg, anAnchor);
            break;
          case '2':
            target_0 = (HTStructured_1 *)HTML_new(anAnchor, format_out, (HTStream_0 *)sink);
            v32 = target_0->isa;
            targetClass_0.name = target_0->isa->name;
            targetClass_0._free = v32->_free;
            targetClass_0._abort = v32->_abort;
            targetClass_0.put_character = v32->put_character;
            targetClass_0.put_string = v32->put_string;
            targetClass_0.put_block = v32->put_block;
            targetClass_0.start_element = v32->start_element;
            targetClass_0.end_element = v32->end_element;
            targetClass_0.put_entity = v32->put_entity;
            parse_cso(arg, anAnchor);
            break;
          case ':':
          case 'I':
          case 'g':
            v29 = s_0;
            v30 = HTAtom_for("image/gif");
            HTParseSocket(v30, format_out, anAnchor, v29, (HTStream_5 *)sink);
            break;
          case ';':
            v35 = s_0;
            v36 = HTAtom_for("video/mpeg");
            HTParseSocket(v36, format_out, anAnchor, v35, (HTStream_5 *)sink);
            break;
          case '<':
          case 's':
            v33 = s_0;
            v34 = HTAtom_for("audio/basic");
            HTParseSocket(v34, format_out, anAnchor, v33, (HTStream_5 *)sink);
            break;
          case 'H':
          case 'h':
            v27 = s_0;
            v28 = HTAtom_for("text/html");
            HTParseSocket(v28, format_out, anAnchor, v27, (HTStream_5 *)sink);
            break;
          case 'P':
            v37 = s_0;
            v38 = HTAtom_for("application/pdf");
            HTParseSocket(v38, format_out, anAnchor, v37, (HTStream_5 *)sink);
            break;
          default:
            v39 = s_0;
            v40 = HTAtom_for("www/unknown");
            HTParseSocket(v40, format_out, anAnchor, v39, (HTStream_5 *)sink);
            break;
        }
        close(s_0);
        return 200;
      }
      else
      {
        if ( WWW_TraceFlag[0] )
        {
          v23 = TraceFP();
          fprintf(v23, "HTGopher: Unable to send command.\n");
        }
        return HTInetStatus("send");
      }
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v19 = TraceFP();
        fprintf(v19, "HTGopher: Unable to connect to remote host for `%s'.\n", arg);
      }
      free(command);
      return HTInetStatus("connect");
    }
  }
}
// 8141B12: conditional instruction was optimized away because %command.4!=0
// 8141B65: conditional instruction was optimized away because %command.4!=0
// 8141C15: conditional instruction was optimized away because %command.4!=0

//----- (08141F50) --------------------------------------------------------
void __cdecl do_system(char *command)
{
  FILE *v1; // edx

  if ( command && *command )
  {
    if ( WWW_TraceFlag[0] )
    {
      v1 = TraceFP();
      fprintf(v1, "HTTelnet: Command is: %s\n\n", command);
    }
    LYSystem(command);
    free(command);
  }
}
// 8141FA0: conditional instruction was optimized away because %command.4!=0

//----- (08141FB6) --------------------------------------------------------
int __cdecl remote_session(char *acc_method, char *host)
{
  FILE *v2; // eax
  FILE *v3; // eax
  char *v4; // eax
  char *v5; // eax
  remote_session::_login_protocol v7; // [esp+14h] [ebp-44h]
  int v8; // [esp+18h] [ebp-40h]
  char *v9; // [esp+1Ch] [ebp-3Ch]
  char *line; // [esp+30h] [ebp-28h] BYREF
  char *prefix; // [esp+34h] [ebp-24h] BYREF
  remote_session::_login_protocol login_protocol; // [esp+38h] [ebp-20h]
  char *command; // [esp+3Ch] [ebp-1Ch] BYREF
  char *port; // [esp+40h] [ebp-18h]
  char *hostname; // [esp+44h] [ebp-14h]
  char *cp; // [esp+48h] [ebp-10h]
  char *password; // [esp+4Ch] [ebp-Ch]
  char *user; // [esp+50h] [ebp-8h]
  const char *program; // [esp+54h] [ebp-4h]

  user = host;
  password = 0;
  command = 0;
  if ( !strcmp(acc_method, "rlogin") )
  {
    v7 = rlogin;
  }
  else
  {
    if ( !strcmp(acc_method, "tn3270") )
      v8 = 2;
    else
      v8 = 0;
    v7 = v8;
  }
  login_protocol = v7;
  if ( strchr(host, 64) )
    v9 = strchr(host, 64);
  else
    v9 = host;
  for ( cp = v9; *cp; ++cp )
  {
    if ( ((*__ctype_b_loc())[(unsigned __int8)*cp] & 8) == 0
      && *cp != 95
      && *cp != 45
      && *cp != 58
      && *cp != 46
      && *cp != 64 )
    {
      *cp = 0;
      break;
    }
  }
  hostname = strchr(host, 64);
  if ( hostname )
  {
    *hostname++ = 0;
  }
  else
  {
    hostname = host;
    user = 0;
  }
  port = strchr(hostname, 58);
  if ( port )
    *port++ = 0;
  if ( !hostname || !*hostname )
  {
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, "HTTelnet: No host specified!\n");
    }
    return -204;
  }
  if ( !valid_hostname(hostname) )
  {
    prefix = 0;
    line = 0;
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "HTTelnet: Invalid hostname %s!\n", host);
    }
    v4 = gettext("remote %s session:");
    HTSprintf0(&prefix, v4, acc_method);
    v5 = gettext("Invalid hostname %s");
    HTSprintf0(&line, v5, host);
    HTAlwaysAlert(prefix, line);
    if ( prefix )
    {
      free(prefix);
      prefix = 0;
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
    return -204;
  }
  if ( user )
  {
    password = strchr(user, 58);
    if ( password )
      *password++ = 0;
  }
  if ( !HTSecure )
  {
    if ( user && login_protocol != rlogin )
      printf("When you are connected, log in as:  %s\n", user);
    if ( password && login_protocol != rlogin )
      printf("                  The password is:  %s\n", password);
    fflush(stdout);
    if ( login_protocol == rlogin )
    {
      program = HTGetProgramPath(ppRLOGIN_0);
      if ( program )
      {
        HTAddParam(&command, "%s %s%s%s", 1, program);
        HTAddParam(&command, "%s %s%s%s", 2, hostname);
        if ( user )
          HTSACat(&command, " -l ");
        else
          HTSACat(&command, &byte_81909DB);
        HTAddParam(&command, "%s %s%s%s", 4, user);
        HTEndParam(&command, "%s %s%s%s", 4);
      }
      goto LABEL_68;
    }
    if ( login_protocol )
    {
      if ( login_protocol != tn3270 )
        goto LABEL_68;
      program = HTGetProgramPath(ppTN3270_0);
      if ( !program )
        goto LABEL_68;
    }
    else
    {
      program = HTGetProgramPath(ppTELNET_0);
      if ( !program )
      {
LABEL_68:
        LYSystem(command);
        return -204;
      }
    }
    HTAddParam(&command, "%s %s %s", 1, program);
    HTAddParam(&command, "%s %s %s", 2, hostname);
    HTAddParam(&command, "%s %s %s", 3, port);
    HTEndParam(&command, "%s %s %s", 3);
    goto LABEL_68;
  }
  puts("\n\nSorry, but the service you have selected is one");
  puts("to which you have to log in.  If you were running www");
  puts("on your own computer, you would be automatically connected.");
  puts("For security reasons, this is not allowed when");
  puts("you log in to this information service remotely.\n");
  printf("You can manually connect to this service using %s\n", acc_method);
  printf("to host %s", hostname);
  if ( user )
    printf(", user name %s", user);
  if ( password )
    printf(", password %s", password);
  if ( port )
    printf(", port %s", port);
  puts(".\n");
  return -204;
}

//----- (081425CC) --------------------------------------------------------
int __cdecl HTLoadTelnet(const char *addr, HTParentAnchor *anchor, HTFormat format_out, HTStream *sink)
{
  FILE *v4; // eax
  FILE *v5; // eax
  int status; // [esp+1Ch] [ebp-Ch]
  char *host; // [esp+20h] [ebp-8h]
  char *acc_method; // [esp+24h] [ebp-4h]

  if ( sink )
  {
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "HTTelnet: Can't output a live session -- must be interactive!\n");
    }
    return -204;
  }
  else
  {
    acc_method = HTParse(addr, "file:", 16);
    host = HTParse(addr, &byte_81909DB, 8);
    if ( host && *host )
    {
      status = remote_session(acc_method, host);
    }
    else
    {
      status = -204;
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "HTTelnet: No host specified!\n");
      }
    }
    if ( host )
      free(host);
    if ( acc_method )
      free(acc_method);
    return status;
  }
}

//----- (081426D0) --------------------------------------------------------
int initialize_0()
{
  finger_fd = -1;
  return 1;
}

//----- (081426E4) --------------------------------------------------------
void __cdecl start_anchor_0(const char *href)
{
  const char *value[25]; // [esp+30h] [ebp-88h] BYREF
  int i; // [esp+94h] [ebp-24h]
  BOOLEAN present[25]; // [esp+9Bh] [ebp-1Dh] BYREF
  unsigned int v4; // [esp+B4h] [ebp-4h]

  v4 = __readgsdword(0x14u);
  for ( i = 0; i <= 24; ++i )
    present[i] = i == 6;
  value[6] = href;
  targetClass_1.start_element((HTStructured *)target_1, 0, present, value, -1, 0);
}

//----- (08142780) --------------------------------------------------------
int __cdecl response_1(char *command, char *sitename, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *sink)
{
  FILE *v5; // edx
  FILE *v6; // eax
  const HTStructuredClass *isa; // edx
  FILE *v8; // eax
  FILE *v9; // eax
  char *v10; // eax
  char v11; // dl
  char *v12; // eax
  char v13; // dl
  char *href; // [esp+44h] [ebp-424h] BYREF
  char *p; // [esp+48h] [ebp-420h]
  char *cmd; // [esp+4Ch] [ebp-41Ch] BYREF
  char *l; // [esp+50h] [ebp-418h]
  int i; // [esp+54h] [ebp-414h]
  int ch_0; // [esp+58h] [ebp-410h]
  int length; // [esp+5Ch] [ebp-40Ch]
  int status; // [esp+60h] [ebp-408h]
  char line[1024]; // [esp+64h] [ebp-404h] BYREF
  unsigned int v25; // [esp+464h] [ebp-4h]

  v25 = __readgsdword(0x14u);
  length = strlen(command);
  cmd = 0;
  p = line;
  href = 0;
  if ( !length )
    return -1;
  HTInitInput(finger_fd);
  if ( WWW_TraceFlag[0] )
  {
    v5 = TraceFP();
    fprintf(v5, "HTFinger command to be sent: %s", command);
  }
  status = write(finger_fd, command, length);
  if ( status >= 0 )
  {
    target_1 = (HTStructured_1 *)HTML_new(anAnchor, format_out, (HTStream_0 *)sink);
    isa = target_1->isa;
    targetClass_1.name = target_1->isa->name;
    targetClass_1._free = isa->_free;
    targetClass_1._abort = isa->_abort;
    targetClass_1.put_character = isa->put_character;
    targetClass_1.put_string = isa->put_string;
    targetClass_1.put_block = isa->put_block;
    targetClass_1.start_element = isa->start_element;
    targetClass_1.end_element = isa->end_element;
    targetClass_1.put_entity = isa->put_entity;
    if ( WWW_TraceFlag[0] )
    {
      v8 = TraceFP();
      fprintf(v8, "HTFinger: Reading finger information\n");
    }
    targetClass_1.start_element((HTStructured *)target_1, 55, 0, 0, -1, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.start_element((HTStructured *)target_1, 53, 0, 0, -1, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.start_element((HTStructured *)target_1, 110, 0, 0, -1, 0);
    targetClass_1.put_string((HTStructured *)target_1, "Finger server on ");
    targetClass_1.put_string((HTStructured *)target_1, sitename);
    targetClass_1.end_element((HTStructured *)target_1, 110, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.end_element((HTStructured *)target_1, 53, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.start_element((HTStructured *)target_1, 17, 0, 0, -1, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.start_element((HTStructured *)target_1, 47, 0, 0, -1, 0);
    targetClass_1.put_string((HTStructured *)target_1, "Finger server on ");
    targetClass_1.start_element((HTStructured *)target_1, 38, 0, 0, -1, 0);
    targetClass_1.put_string((HTStructured *)target_1, sitename);
    targetClass_1.end_element((HTStructured *)target_1, 38, 0);
    targetClass_1.put_string((HTStructured *)target_1, ": ");
    if ( command )
      HTSACopy(&cmd, command);
    else
      HTSACopy(&cmd, &byte_8190AC3);
    for ( i = strlen(cmd) - 1; i >= 0 && (cmd[i] == 10 || cmd[i] == 13); --i )
      cmd[i] = 0;
    targetClass_1.put_string((HTStructured *)target_1, cmd);
    if ( cmd )
    {
      free(cmd);
      cmd = 0;
    }
    targetClass_1.end_element((HTStructured *)target_1, 47, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.start_element((HTStructured *)target_1, 86, 0, 0, -1, 0);
    while ( 1 )
    {
      ch_0 = HTGetCharacter();
      if ( ch_0 == -1 )
      {
        close(finger_fd);
        finger_fd = -1;
        goto end_html;
      }
      if ( interrupted_in_htgetcharacter )
        break;
      if ( ch_0 == 10 )
      {
        *p = 0;
        l = line;
        p = line;
        while ( *l )
        {
          if ( !strncmp(l, "news:", 5u)
            || !strncmp(l, "snews://", 8u)
            || !strncmp(l, "nntp://", 7u)
            || !strncmp(l, "snewspost:", 0xAu)
            || !strncmp(l, "snewsreply:", 0xBu)
            || !strncmp(l, "newspost:", 9u)
            || !strncmp(l, "newsreply:", 0xAu)
            || !strncmp(l, "ftp://", 6u)
            || !strncmp(l, "file:/", 6u)
            || !strncmp(l, "finger://", 9u)
            || !strncmp(l, "http://", 7u)
            || !strncmp(l, "https://", 8u)
            || !strncmp(l, "wais://", 7u)
            || !strncmp(l, "mailto:", 7u)
            || !strncmp(l, "cso://", 6u)
            || !strncmp(l, "gopher://", 9u) )
          {
            HTSACopy(&href, l);
            v12 = strtok(href, " \r\n\t,>)\"");
            start_anchor_0(v12);
            while ( *l && !strchr(" \r\n\t,>)\"", *l) )
            {
              v13 = *l++;
              targetClass_1.put_character((HTStructured *)target_1, v13);
            }
            targetClass_1.end_element((HTStructured *)target_1, 0, 0);
            if ( href )
            {
              free(href);
              href = 0;
            }
          }
          else
          {
            v11 = *l++;
            targetClass_1.put_character((HTStructured *)target_1, v11);
          }
        }
        targetClass_1.put_character((HTStructured *)target_1, 10);
      }
      else
      {
        *p = ch_0;
        if ( p < &line[1023] )
          ++p;
      }
    }
    if ( WWW_TraceFlag[0] )
    {
      v9 = TraceFP();
      fprintf(v9, "HTFinger: Interrupted in HTGetCharacter, apparently.\n");
    }
    mustshow[0] = 1;
    v10 = gettext("Connection interrupted.");
    HTProgress(v10);
end_html:
    targetClass_1.end_element((HTStructured *)target_1, 86, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.end_element((HTStructured *)target_1, 17, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1.end_element((HTStructured *)target_1, 55, 0);
    targetClass_1.put_character((HTStructured *)target_1, 10);
    targetClass_1._free((HTStructured *)target_1);
    return 0;
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v6 = TraceFP();
      fprintf(v6, "HTFinger: Unable to send command. Disconnecting.\n");
    }
    close(finger_fd);
    finger_fd = -1;
    return status;
  }
}

//----- (0814327F) --------------------------------------------------------
int __cdecl HTLoadFinger(const char *arg, HTParentAnchor *anAnchor, HTFormat format_out, HTStream *stream)
{
  FILE *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // ebx
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  char *v14; // eax
  FILE *v15; // eax
  char *v16; // eax
  char *v17; // ebx
  FILE *v18; // eax
  char *v19; // eax
  const char *v21; // [esp+1Ch] [ebp-4Ch]
  const char *p1; // [esp+30h] [ebp-38h]
  int result; // [esp+34h] [ebp-34h]
  int status; // [esp+38h] [ebp-30h]
  char *param; // [esp+40h] [ebp-28h] BYREF
  char *str; // [esp+44h] [ebp-24h] BYREF
  char *command; // [esp+48h] [ebp-20h] BYREF
  char *at_sign; // [esp+4Ch] [ebp-1Ch]
  char *slash; // [esp+50h] [ebp-18h]
  char *colon; // [esp+54h] [ebp-14h]
  char *sitename; // [esp+58h] [ebp-10h]
  char *username; // [esp+5Ch] [ebp-Ch]
  BOOLEAN IsGopherURL; // [esp+63h] [ebp-5h]

  result = 200;
  IsGopherURL = 0;
  p1 = arg;
  if ( WWW_TraceFlag[0] )
  {
    if ( arg )
      v21 = arg;
    else
      v21 = "NULL";
    v4 = TraceFP();
    fprintf(v4, "HTFinger: Looking for %s\n", v21);
  }
  if ( !arg || !*arg )
  {
    v5 = gettext("Could not load data.");
    HTAlert(v5);
    return -29999;
  }
  if ( !initialized_0[0] )
    initialized_0[0] = initialize_0();
  if ( !initialized_0[0] )
  {
    v6 = gettext("Could not set up finger connection.");
    HTAlert(v6);
    return -29999;
  }
  if ( strncasecomp(arg, "finger://", 9) )
  {
    if ( !strncasecomp(arg, "gopher://", 9) )
    {
      p1 = arg + 9;
      IsGopherURL = 1;
    }
  }
  else
  {
    p1 = arg + 9;
  }
  param = 0;
  sitename = HTSACopy(&param, p1);
  if ( !param )
  {
LABEL_25:
    v7 = gettext("Could not load data.");
    HTAlert(v7);
    return -29999;
  }
  slash = strchr(sitename, 47);
  if ( slash )
  {
    *slash++ = 0;
    HTUnEscape(slash);
    if ( IsGopherURL )
    {
      if ( *slash != 48 )
        goto LABEL_25;
      *slash++ = 0;
    }
  }
  at_sign = strchr(sitename, 64);
  if ( at_sign )
  {
    if ( IsGopherURL )
      goto LABEL_25;
    *at_sign++ = 0;
    username = sitename;
    sitename = at_sign;
    HTUnEscape(username);
  }
  else if ( slash )
  {
    username = slash;
  }
  else
  {
    username = (char *)&byte_8190AC3;
  }
  if ( *sitename )
  {
    colon = strchr(sitename, 58);
    if ( colon )
    {
      *colon++ = 0;
      if ( atoi(colon) != 79 )
      {
        v9 = gettext("Invalid port number - will only use port 79!");
        HTAlert(v9);
        result = -29999;
      }
    }
  }
  else
  {
    v8 = gettext("Could not load data (no sitename in finger URL)");
    HTAlert(v8);
    result = -29999;
  }
  if ( result == 200 )
  {
    str = 0;
    HTSprintf0(&str, "lose://%s/", sitename);
    command = 0;
    if ( at_sign && slash )
    {
      if ( *slash == 119 || *slash == 87 )
      {
LABEL_40:
        HTSprintf0(&command, "/w %s%c%c", username, 13, 10);
LABEL_62:
        if ( WWW_TraceFlag[0] )
        {
          v10 = str;
          v11 = TraceFP();
          fprintf(v11, "HTFinger: doing HTDoConnect on '%s'\n", v10);
        }
        status = HTDoConnect(str, "finger", 79, &finger_fd);
        if ( WWW_TraceFlag[0] )
        {
          v12 = TraceFP();
          fprintf(v12, "HTFinger: Done DoConnect; status %d\n", status);
        }
        if ( status == -29998 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v13 = TraceFP();
            fprintf(v13, "HTFinger: Interrupted on connect; recovering cleanly.\n");
          }
          v14 = gettext("Connection interrupted.");
          HTProgress(v14);
          result = -29999;
        }
        else if ( status >= 0 )
        {
          if ( WWW_TraceFlag[0] )
          {
            v17 = str;
            v18 = TraceFP();
            fprintf(v18, "HTFinger: Connected to finger host '%s'.\n", v17);
          }
          if ( response_1(command, sitename, anAnchor, format_out, stream) )
          {
            v19 = gettext("No response from finger server.");
            HTAlert(v19);
            result = -29999;
          }
        }
        else
        {
          close(finger_fd);
          finger_fd = -1;
          if ( WWW_TraceFlag[0] )
          {
            v15 = TraceFP();
            fprintf(v15, "HTFinger: Unable to connect to finger host.\n");
          }
          v16 = gettext("Could not access finger host.");
          HTAlert(v16);
          result = -29999;
        }
        if ( str )
        {
          free(str);
          str = 0;
        }
        if ( command )
        {
          free(command);
          command = 0;
        }
        goto LABEL_82;
      }
LABEL_61:
      HTSprintf0(&command, "%s%c%c", username, 13, 10);
      goto LABEL_62;
    }
    if ( at_sign )
      goto LABEL_61;
    if ( *username == 47 )
    {
      slash = strchr(username + 1, 47);
      if ( slash )
        *slash = 32;
      goto LABEL_61;
    }
    if ( (*username == 119 || *username == 87) && username[1] == 47 )
    {
      if ( *username == -2 )
        username[1] = 0;
      else
        username[1] = 32;
    }
    else if ( *username != 119 && *username != 87 || username[1] )
    {
      slash = strchr(username, 47);
      if ( slash )
      {
        *slash = 0;
        if ( *++slash == 119 || *slash == 87 )
          goto LABEL_40;
      }
      goto LABEL_61;
    }
    HTSprintf0(&command, "/%s%c%c", username, 13, 10);
    goto LABEL_62;
  }
LABEL_82:
  if ( param )
  {
    free(param);
    param = 0;
  }
  return result;
}

//----- (081439E8) --------------------------------------------------------
char __cdecl from_hex_1(char c)
{
  if ( c > 47 && c <= 57 )
    return c - 48;
  if ( c > 64 && c <= 70 )
    return c - 55;
  if ( c <= 96 || c > 102 )
    return 0;
  else
    return c - 87;
}

//----- (08143A54) --------------------------------------------------------
void __cdecl WSRCParser_put_character(HTStream_7 *me, char c)
{
  int v2; // edx
  FILE *v3; // eax
  int param_count; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  tokenstate v9; // [esp+1Ch] [ebp-Ch]

  switch ( me->state )
  {
    case beginning:
      if ( c == 40 )
        me->state = before_tag;
      break;
    case before_tag:
      if ( c == 41 )
      {
        me->state = done;
      }
      else if ( c == 58 )
      {
        me->param_count = 0;
        me->state = colon;
      }
      break;
    case colon:
      if ( (unsigned __int8)c > 0x20u )
      {
        if ( me->param_count <= 9999 )
        {
          param_count = me->param_count;
          me->param[param_count] = c;
          me->param_count = param_count + 1;
        }
      }
      else
      {
        v2 = me->param_count;
        me->param[v2] = 0;
        me->param_count = v2 + 1;
        for ( me->param_number = 0;
              par_name[me->param_number] && strcmp(par_name[me->param_number], me->param);
              ++me->param_number )
        {
          ;
        }
        if ( par_name[me->param_number] )
        {
          me->state = before_value;
        }
        else
        {
          if ( WWW_TraceFlag[0] )
          {
            v3 = TraceFP();
            fprintf(v3, "HTWSRC: Unknown field `%s' in source file\n", me->param);
          }
          me->param_number = 22;
          me->state = before_value;
        }
      }
      break;
    case before_value:
      if ( c == 41 )
      {
        me->state = done;
      }
      else if ( (unsigned __int8)c > 0x20u )
      {
        me->param_count = 0;
        if ( c == 34 )
        {
          me->state = quoted_value;
        }
        else
        {
          if ( c == 40 )
            v9 = bracketed_value;
          else
            v9 = value;
          me->state = v9;
          v5 = me->param_count;
          me->param[v5] = c;
          me->param_count = v5 + 1;
        }
      }
      break;
    case value:
      if ( (unsigned __int8)c <= 0x20u )
        goto LABEL_37;
      if ( me->param_count <= 9999 )
      {
        v6 = me->param_count;
        me->param[v6] = c;
        me->param_count = v6 + 1;
      }
      break;
    case bracketed_value:
      if ( c == 41 )
        goto LABEL_37;
      if ( me->param_count <= 9999 )
      {
        v7 = me->param_count;
        me->param[v7] = c;
        me->param_count = v7 + 1;
      }
      break;
    case quoted_value:
      if ( c == 34 )
      {
LABEL_37:
        me->param[me->param_count] = 0;
        HTSACopy(&me->par_value[me->param_number], me->param);
        me->state = before_tag;
      }
      else
      {
        if ( c != 92 )
          goto LABEL_40;
        me->state = escape_in_quoted;
      }
      break;
    case escape_in_quoted:
LABEL_40:
      if ( me->param_count <= 9999 )
      {
        v8 = me->param_count;
        me->param[v8] = c;
        me->param_count = v8 + 1;
      }
      me->state = quoted_value;
      break;
    default:
      return;
  }
}
// 8143C46: conditional instruction was optimized away because %c.1 is in (==21|23..28|>=2Au)

//----- (08143E45) --------------------------------------------------------
void __cdecl give_parameter(HTStream_7 *me, int p)
{
  void (*put_string)(HTStructured *, const char *); // ebx
  char *v3; // eax

  me->target->isa->put_string((HTStructured *)me->target, par_name[p]);
  if ( me->par_value[p] )
  {
    me->target->isa->put_string((HTStructured *)me->target, (const char *)&unk_8190EEC);
    me->target->isa->put_string((HTStructured *)me->target, me->par_value[p]);
    me->target->isa->put_string((HTStructured *)me->target, (const char *)&unk_8190EEF);
  }
  else
  {
    put_string = me->target->isa->put_string;
    v3 = gettext(" NOT GIVEN in source file; ");
    put_string((HTStructured *)me->target, v3);
  }
}

//----- (08143F0E) --------------------------------------------------------
void __cdecl WSRC_gen_html(HTStream_7 *me, BOOLEAN source_file)
{
  void (*v2)(HTStructured *, const char *); // ebx
  char *v3; // eax
  void (*v4)(HTStructured *, const char *); // ebx
  char *v5; // eax
  void (*v6)(HTStructured *, const char *); // ebx
  char *v7; // eax
  void (*v8)(HTStructured *, const char *); // ebx
  char *v9; // eax
  void (*v10)(HTStructured *, const char *); // ebx
  char *v11; // eax
  void (*put_string)(HTStructured *, const char *); // [esp+28h] [ebp-30h]
  char *v13; // [esp+2Ch] [ebp-2Ch]
  void (*v14)(HTStructured *, const char *); // [esp+30h] [ebp-28h]
  char *v15; // [esp+34h] [ebp-24h]
  const char *v16; // [esp+38h] [ebp-20h]
  char *www_database; // [esp+48h] [ebp-10h]
  char *WSRC_address; // [esp+4Ch] [ebp-Ch] BYREF
  int l; // [esp+50h] [ebp-8h]

  if ( me->par_value[4] )
  {
    WSRC_address = 0;
    HTSACopy(&WSRC_address, me->par_value[4]);
    l = strlen(WSRC_address);
    if ( l > 4 && !strcasecomp(&WSRC_address[l - 4], ".src") )
      WSRC_address[l - 4] = 0;
    me->target->isa->start_element((HTStructured *)me->target, 53, 0, 0, -1, 0);
    me->target->isa->put_character((HTStructured *)me->target, 10);
    me->target->isa->start_element((HTStructured *)me->target, 110, 0, 0, -1, 0);
    me->target->isa->put_string((HTStructured *)me->target, WSRC_address);
    put_string = me->target->isa->put_string;
    if ( source_file )
      v13 = gettext(" WAIS source file");
    else
      v13 = gettext(" index");
    put_string((HTStructured *)me->target, v13);
    me->target->isa->end_element((HTStructured *)me->target, 110, 0);
    me->target->isa->put_character((HTStructured *)me->target, 10);
    me->target->isa->end_element((HTStructured *)me->target, 53, 0);
    me->target->isa->start_element((HTStructured *)me->target, 47, 0, 0, -1, 0);
    me->target->isa->put_string((HTStructured *)me->target, WSRC_address);
    v14 = me->target->isa->put_string;
    if ( source_file )
      v15 = gettext(" description");
    else
      v15 = gettext(" index");
    v14((HTStructured *)me->target, v15);
    me->target->isa->end_element((HTStructured *)me->target, 47, 0);
    me->target->isa->put_character((HTStructured *)me->target, 10);
    if ( WSRC_address )
    {
      free(WSRC_address);
      WSRC_address = 0;
    }
  }
  me->target->isa->start_element((HTStructured *)me->target, 35, 0, 0, -1, 0);
  if ( source_file )
  {
    me->target->isa->start_element((HTStructured *)me->target, 37, 0, 0, -1, 0);
    v2 = me->target->isa->put_string;
    v3 = gettext("Access links");
    v2((HTStructured *)me->target, v3);
    if ( HTML_dtd.tags[37].contents )
      me->target->isa->end_element((HTStructured *)me->target, 37, 0);
    me->target->isa->start_element((HTStructured *)me->target, 30, 0, 0, -1, 0);
    if ( me->par_value[2] && me->par_value[4] )
    {
      WSRC_address = 0;
      www_database = HTEscape(me->par_value[4], 1u);
      if ( me->par_value[3] )
        v16 = me->par_value[3];
      else
        v16 = (const char *)&unk_8190F46;
      if ( me->par_value[3] )
        HTSprintf0(&WSRC_address, "%s//%s%s%s/%s", "wais:", me->par_value[2], ":", v16, www_database);
      else
        HTSprintf0(
          &WSRC_address,
          "%s//%s%s%s/%s",
          "wais:",
          me->par_value[2],
          (const char *)&unk_8190F46,
          v16,
          www_database);
      HTStartAnchor(me->target, 0, WSRC_address);
      v4 = me->target->isa->put_string;
      v5 = gettext("Direct access");
      v4((HTStructured *)me->target, v5);
      me->target->isa->end_element((HTStructured *)me->target, 0, 0);
      v6 = me->target->isa->put_string;
      v7 = gettext(" (or via proxy server, if defined)");
      v6((HTStructured *)me->target, v7);
      if ( www_database )
        free(www_database);
      if ( WSRC_address )
      {
        free(WSRC_address);
        WSRC_address = 0;
      }
    }
    else
    {
      give_parameter(me, 2);
      give_parameter(me, 4);
    }
    if ( HTML_dtd.tags[30].contents )
      me->target->isa->end_element((HTStructured *)me->target, 30, 0);
  }
  if ( me->par_value[8] )
  {
    me->target->isa->start_element((HTStructured *)me->target, 37, 0, 0, -1, 0);
    v8 = me->target->isa->put_string;
    v9 = gettext("Maintainer");
    v8((HTStructured *)me->target, v9);
    if ( HTML_dtd.tags[37].contents )
      me->target->isa->end_element((HTStructured *)me->target, 37, 0);
    me->target->isa->start_element((HTStructured *)me->target, 30, 0, 0, -1, 0);
    me->target->isa->put_string((HTStructured *)me->target, me->par_value[8]);
    if ( HTML_dtd.tags[30].contents )
      me->target->isa->end_element((HTStructured *)me->target, 30, 0);
  }
  if ( me->par_value[2] )
  {
    me->target->isa->start_element((HTStructured *)me->target, 37, 0, 0, -1, 0);
    v10 = me->target->isa->put_string;
    v11 = gettext("Host");
    v10((HTStructured *)me->target, v11);
    if ( HTML_dtd.tags[37].contents )
      me->target->isa->end_element((HTStructured *)me->target, 37, 0);
    me->target->isa->start_element((HTStructured *)me->target, 30, 0, 0, -1, 0);
    me->target->isa->put_string((HTStructured *)me->target, me->par_value[2]);
    if ( HTML_dtd.tags[30].contents )
      me->target->isa->end_element((HTStructured *)me->target, 30, 0);
  }
  me->target->isa->end_element((HTStructured *)me->target, 35, 0);
  if ( me->par_value[9] )
  {
    me->target->isa->start_element((HTStructured *)me->target, 86, 0, 0, -1, 0);
    me->target->isa->put_string((HTStructured *)me->target, me->par_value[9]);
    me->target->isa->end_element((HTStructured *)me->target, 86, 0);
  }
  me->target->isa->_free((HTStructured *)me->target);
}

//----- (08144835) --------------------------------------------------------
void __cdecl WSRCParser_put_string(HTStream_7 *context, const char *str)
{
  while ( *str )
    WSRCParser_put_character(context, *str++);
}

//----- (0814486B) --------------------------------------------------------
void __cdecl WSRCParser_write(HTStream_7 *context, const char *str, int l)
{
  char *p; // [esp+14h] [ebp-4h]

  for ( p = (char *)str; p < &str[l]; ++p )
    WSRCParser_put_character(context, *p);
}

//----- (081448A8) --------------------------------------------------------
void __cdecl WSRCParser_free(HTStream_7 *me)
{
  int p; // [esp+14h] [ebp-4h]

  WSRC_gen_html(me, 1);
  for ( p = 0; par_name[p]; ++p )
  {
    if ( me->par_value[p] )
    {
      free(me->par_value[p]);
      me->par_value[p] = 0;
    }
  }
  if ( me )
    free(me);
}

//----- (08144924) --------------------------------------------------------
void __cdecl WSRCParser_abort(HTStream_7 *me, HTError e)
{
  WSRCParser_free(me);
}

//----- (08144937) --------------------------------------------------------
HTStream_7 *__cdecl HTWSRCConvert(HTPresentation *pres, HTParentAnchor *anchor, HTStream_7 *sink)
{
  int p; // [esp+20h] [ebp-8h]
  HTStream_7 *me; // [esp+24h] [ebp-4h]

  me = (HTStream_7 *)malloc(0x2784u);
  if ( !me )
    outofmem("../../../WWW/Library/Implementation/HTWSRC.c", "HTWSRCConvert");
  me->isa = &WSRCParserClass;
  me->target = (HTStructured_1 *)HTML_new(anchor, pres->rep_out, (HTStream_0 *)sink);
  for ( p = 0; p <= 22; ++p )
    me->par_value[p] = 0;
  me->state = beginning;
  return me;
}

//----- (081449C4) --------------------------------------------------------
void __cdecl HTAAForwardAuth_set(const char *scheme_name, const char *scheme_specifics)
{
  size_t v2; // [esp+10h] [ebp-18h]
  size_t v3; // [esp+14h] [ebp-14h]

  if ( scheme_name )
    v2 = strlen(scheme_name) + 20;
  else
    v2 = 20;
  if ( scheme_specifics )
    v3 = strlen(scheme_specifics);
  else
    v3 = 0;
  if ( HTAAForwardAuth )
  {
    free(HTAAForwardAuth);
    HTAAForwardAuth = 0;
  }
  HTAAForwardAuth = (char *)calloc(v3 + v2, 1u);
  if ( !HTAAForwardAuth )
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAAForwardAuth_set");
  memcpy(HTAAForwardAuth, "Authorization: ", 0x10u);
  if ( scheme_name )
  {
    strcat(HTAAForwardAuth, scheme_name);
    strcat(HTAAForwardAuth, " ");
    if ( scheme_specifics )
      strcat(HTAAForwardAuth, scheme_specifics);
  }
}

//----- (08144ACE) --------------------------------------------------------
void HTAAForwardAuth_reset()
{
  if ( HTAAForwardAuth )
  {
    free(HTAAForwardAuth);
    HTAAForwardAuth = 0;
  }
}

//----- (08144AF6) --------------------------------------------------------
HTAAServer *__cdecl HTAAServer_new(const char *hostname, int portnumber, BOOLEAN IsProxy)
{
  int v4; // [esp+10h] [ebp-18h]
  HTAAServer *server; // [esp+24h] [ebp-4h]

  server = (HTAAServer *)calloc(1u, 0x14u);
  if ( !server )
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAAServer_new");
  server->hostname = 0;
  if ( portnumber <= 0 )
    v4 = 80;
  else
    v4 = portnumber;
  server->portnumber = v4;
  server->IsProxy = IsProxy;
  server->setups = HTList_new();
  server->realms = HTList_new();
  if ( hostname )
    HTSACopy(&server->hostname, hostname);
  if ( !server_table )
    server_table = HTList_new();
  HTList_addObject(server_table, server);
  return server;
}

//----- (08144BC3) --------------------------------------------------------
void __cdecl HTAAServer_delete(HTAAServer *killme)
{
  void **object; // [esp+14h] [ebp-24h]
  HTList *cur; // [esp+24h] [ebp-14h]
  HTAASetup *setup; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  if ( killme )
  {
    if ( killme->setups )
    {
      for ( i = HTList_count(killme->setups) - 1; i >= 0; --i )
      {
        setup = (HTAASetup *)HTList_objectAt(killme->setups, i);
        if ( setup )
          HTAASetup_delete(setup);
      }
      HTList_delete(killme->setups);
      killme->setups = 0;
    }
    cur = killme->realms;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (void **)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( *object )
      {
        free(*object);
        *object = 0;
      }
      if ( object[1] )
      {
        free(object[1]);
        object[1] = 0;
      }
      if ( object[2] )
      {
        free(object[2]);
        object[2] = 0;
      }
      free(object);
    }
    HTList_delete(killme->realms);
    killme->realms = 0;
    if ( killme->hostname )
    {
      free(killme->hostname);
      killme->hostname = 0;
    }
    HTList_removeObject(server_table, killme);
    free(killme);
  }
}
// 8144D57: conditional instruction was optimized away because %killme.4!=0
// 8144CBD: conditional instruction was optimized away because %var_24.4!=0

//----- (08144D6D) --------------------------------------------------------
HTAAServer *__cdecl HTAAServer_lookup(const char *hostname, int portnumber, BOOLEAN IsProxy)
{
  HTAAServer *object; // [esp+10h] [ebp-18h]
  HTList *cur; // [esp+24h] [ebp-4h]

  if ( hostname )
  {
    cur = server_table;
    if ( portnumber <= 0 )
      portnumber = 80;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (HTAAServer *)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( object->portnumber == portnumber && !strcmp(object->hostname, hostname) && object->IsProxy == IsProxy )
        return object;
    }
  }
  return 0;
}

//----- (08144E0F) --------------------------------------------------------
HTAASetup *__cdecl HTAASetup_lookup(const char *hostname, int portnumber, const char *docname, BOOLEAN IsProxy)
{
  FILE *v4; // edx
  const char *ctemplate; // ebx
  FILE *v6; // edx
  const char *v7; // ebx
  FILE *v8; // edx
  FILE *v9; // eax
  const char *v11; // [esp+20h] [ebp-28h]
  HTAASetup *object; // [esp+28h] [ebp-20h]
  const char *v14; // [esp+2Ch] [ebp-1Ch]
  HTList *cur; // [esp+38h] [ebp-10h]
  HTAAServer *server; // [esp+40h] [ebp-8h]

  if ( portnumber <= 0 )
    portnumber = 80;
  if ( hostname )
  {
    if ( docname )
    {
      if ( *hostname )
      {
        if ( *docname )
        {
          server = HTAAServer_lookup(hostname, portnumber, IsProxy);
          if ( server )
          {
            cur = server->setups;
            if ( WWW_TraceFlag[0] )
            {
              if ( IsProxy )
                v11 = "proxy";
              else
                v11 = "server";
              v4 = TraceFP();
              fprintf(
                v4,
                "%s %s (%s:%d:%s)\n",
                "HTAASetup_lookup: resolving setup for",
                v11,
                hostname,
                portnumber,
                docname);
            }
            while ( 1 )
            {
              if ( cur && (cur = cur->next) != 0 )
                object = (HTAASetup *)cur->object;
              else
                object = 0;
              if ( !object )
                break;
              if ( HTAA_templateMatch(object->ctemplate, docname) )
              {
                if ( WWW_TraceFlag[0] )
                {
                  ctemplate = object->ctemplate;
                  v6 = TraceFP();
                  fprintf(v6, "%s `%s' %s `%s'\n", "HTAASetup_lookup:", docname, "matched template", ctemplate);
                }
                return object;
              }
              if ( WWW_TraceFlag[0] )
              {
                v7 = object->ctemplate;
                v8 = TraceFP();
                fprintf(v8, "%s `%s' %s `%s'\n", "HTAASetup_lookup:", docname, "did NOT match template", v7);
              }
            }
          }
        }
      }
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    if ( docname )
      v14 = docname;
    else
      v14 = "(null)";
    v9 = TraceFP();
    fprintf(v9, "%s `%s' %s\n", "HTAASetup_lookup: No template matched", v14, "(so probably not protected)");
  }
  return 0;
}

//----- (08145032) --------------------------------------------------------
HTAASetup *__cdecl HTAASetup_new(
        HTAAServer *server,
        char *ctemplate,
        HTList *valid_schemes,
        HTAssocList **scheme_specifics)
{
  HTAASetup *setup; // [esp+24h] [ebp-4h]

  if ( !server || !ctemplate || !*ctemplate )
    return 0;
  setup = (HTAASetup *)calloc(1u, 0x14u);
  if ( !setup )
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAASetup_new");
  setup->retry = 0;
  setup->server = server;
  setup->ctemplate = 0;
  HTSACopy(&setup->ctemplate, ctemplate);
  setup->valid_schemes = valid_schemes;
  setup->scheme_specifics = scheme_specifics;
  HTList_addObject(server->setups, setup);
  return setup;
}
// 81450A8: conditional instruction was optimized away because %ctemplate.4!=0

//----- (081450F1) --------------------------------------------------------
void __cdecl HTAASetup_delete(HTAASetup *killme)
{
  int scheme; // [esp+14h] [ebp-4h]

  if ( killme )
  {
    if ( killme->ctemplate )
    {
      free(killme->ctemplate);
      killme->ctemplate = 0;
    }
    if ( killme->valid_schemes )
    {
      HTList_delete(killme->valid_schemes);
      killme->valid_schemes = 0;
    }
    for ( scheme = 0; scheme <= 5; ++scheme )
    {
      if ( killme->scheme_specifics[scheme] )
        HTAssocList_delete(killme->scheme_specifics[scheme]);
    }
    if ( killme->scheme_specifics )
    {
      free(killme->scheme_specifics);
      killme->scheme_specifics = 0;
    }
    free(killme);
  }
}
// 81451AC: conditional instruction was optimized away because %killme.4!=0

//----- (081451C2) --------------------------------------------------------
void __cdecl HTAASetup_updateSpecifics(HTAASetup *setup, HTAssocList **specifics)
{
  int scheme; // [esp+14h] [ebp-4h]

  if ( setup )
  {
    if ( setup->scheme_specifics )
    {
      for ( scheme = 0; scheme <= 5; ++scheme )
      {
        if ( setup->scheme_specifics[scheme] )
          HTAssocList_delete(setup->scheme_specifics[scheme]);
      }
      if ( setup->scheme_specifics )
      {
        free(setup->scheme_specifics);
        setup->scheme_specifics = 0;
      }
    }
    setup->scheme_specifics = specifics;
  }
}

//----- (08145246) --------------------------------------------------------
HTAARealm *__cdecl HTAARealm_lookup(HTList *realm_table, const char *realmname)
{
  HTAARealm *object; // [esp+14h] [ebp-14h]
  HTList *cur; // [esp+24h] [ebp-4h]

  if ( realm_table && realmname )
  {
    cur = realm_table;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (HTAARealm *)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( !strcmp(object->realmname, realmname) )
        return object;
    }
  }
  return 0;
}

//----- (081452BE) --------------------------------------------------------
HTAARealm *__cdecl HTAARealm_new(
        HTList *realm_table,
        const char *realmname,
        const char *username,
        const char *password)
{
  HTAARealm *realm; // [esp+14h] [ebp-4h]

  realm = HTAARealm_lookup(realm_table, realmname);
  if ( !realm )
  {
    realm = (HTAARealm *)calloc(1u, 0xCu);
    if ( !realm )
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAARealm_new");
    realm->realmname = 0;
    realm->username = 0;
    realm->password = 0;
    HTSACopy(&realm->realmname, realmname);
    if ( realm_table )
      HTList_addObject(realm_table, realm);
  }
  if ( username )
    HTSACopy(&realm->username, username);
  if ( password )
    HTSACopy(&realm->password, password);
  return realm;
}

//----- (08145392) --------------------------------------------------------
char *__cdecl compose_auth_string(HTAAScheme scheme, HTAASetup *setup, BOOLEAN IsProxy)
{
  FILE *v3; // eax
  const char *v4; // ebx
  char *v5; // eax
  size_t v6; // eax
  char *v7; // ebx
  unsigned int v8; // eax
  size_t v11; // [esp+2Ch] [ebp-6Ch]
  const char *s; // [esp+30h] [ebp-68h]
  char *v13; // [esp+34h] [ebp-64h]
  char *v14; // [esp+38h] [ebp-60h]
  const char *v15; // [esp+3Ch] [ebp-5Ch]
  char *v16; // [esp+40h] [ebp-58h]
  size_t v17; // [esp+44h] [ebp-54h]
  char *v18; // [esp+48h] [ebp-50h]
  char *v19; // [esp+4Ch] [ebp-4Ch]
  HTAARealm *realm; // [esp+68h] [ebp-30h]
  char *thePort; // [esp+6Ch] [ebp-2Ch] BYREF
  char *proxiedHost; // [esp+70h] [ebp-28h]
  char *theHost; // [esp+74h] [ebp-24h]
  char *realmname; // [esp+78h] [ebp-20h]
  char *password; // [esp+7Ch] [ebp-1Ch] BYREF
  char *username; // [esp+80h] [ebp-18h] BYREF
  char *msg; // [esp+84h] [ebp-14h] BYREF
  int len; // [esp+88h] [ebp-10h]
  char *ciphertext; // [esp+8Ch] [ebp-Ch]
  char *cleartext; // [esp+90h] [ebp-8h]

  cleartext = 0;
  ciphertext = 0;
  msg = 0;
  username = 0;
  password = 0;
  realmname = 0;
  theHost = 0;
  proxiedHost = 0;
  thePort = 0;
  if ( compose_auth_stringResult )
  {
    free(compose_auth_stringResult);
    compose_auth_stringResult = 0;
  }
  if ( scheme != HTAA_BASIC && scheme != HTAA_PUBKEY
    || !setup
    || !setup->scheme_specifics
    || !setup->scheme_specifics[scheme]
    || !setup->server
    || !setup->server->realms )
  {
    return 0;
  }
  realmname = HTAssocList_lookup(setup->scheme_specifics[scheme], "realm");
  if ( !realmname )
    return 0;
  realm = HTAARealm_lookup(setup->server->realms, realmname);
  if ( !realm || !realm->username || !*realm->username || !realm->password || setup->retry )
  {
    if ( !realm )
    {
      if ( WWW_TraceFlag[0] )
      {
        v3 = TraceFP();
        fprintf(v3, "%s `%s' %s\n", "compose_auth_string: realm:", realmname, "not found -- creating");
      }
      realm = HTAARealm_new(setup->server->realms, realmname, 0, 0);
    }
    if ( !IsProxy )
    {
      if ( using_proxy[0] )
      {
        if ( setup->ctemplate )
        {
          proxiedHost = HTParse(setup->ctemplate, &byte_8191195, 8);
          if ( proxiedHost )
          {
            if ( *proxiedHost )
              theHost = proxiedHost;
          }
        }
      }
    }
    if ( !theHost )
      theHost = setup->server->hostname;
    if ( setup->server->portnumber > 0 && setup->server->portnumber != 80 )
      HTSprintf0(&thePort, ":%d", setup->server->portnumber);
    v11 = strlen(realm->realmname);
    if ( theHost )
      s = theHost;
    else
      s = "??";
    len = v11 + strlen(s) + 50;
    if ( thePort )
      v13 = thePort;
    else
      v13 = (char *)&byte_8191195;
    if ( theHost )
      v14 = theHost;
    else
      v14 = "??";
    if ( IsProxy )
      v15 = "proxy";
    else
      v15 = "server";
    v4 = realm->realmname;
    v5 = gettext("Username for '%s' at %s '%s%s':");
    HTSprintf0(&msg, v5, v4, v15, v14, v13);
    if ( proxiedHost )
    {
      free(proxiedHost);
      proxiedHost = 0;
    }
    if ( thePort )
    {
      free(thePort);
      thePort = 0;
    }
    username = realm->username;
    password = 0;
    HTPromptUsernameAndPassword(msg, &username, &password, IsProxy);
    if ( msg )
    {
      free(msg);
      msg = 0;
    }
    if ( realm->username )
    {
      free(realm->username);
      realm->username = 0;
    }
    if ( realm->password )
    {
      free(realm->password);
      realm->password = 0;
    }
    realm->username = username;
    realm->password = password;
    if ( !realm->username || !realm->password )
      return 0;
    if ( !*realm->username )
    {
      HTSACopy(&compose_auth_stringResult, &byte_8191195);
      return compose_auth_stringResult;
    }
  }
  if ( realm->username )
    v16 = realm->username;
  else
    v16 = (char *)&byte_8191195;
  v17 = strlen(v16);
  if ( realm->password )
    v18 = realm->password;
  else
    v18 = (char *)&byte_8191195;
  len = v17 + strlen(v18) + 3;
  if ( scheme == HTAA_PUBKEY )
  {
    if ( secret_key )
      v19 = secret_key;
    else
      v19 = (char *)&byte_8191195;
    v6 = strlen(v19);
    len += v6 + 30;
  }
  else if ( secret_key )
  {
    free(secret_key);
    secret_key = 0;
  }
  cleartext = (char *)calloc(len, 1u);
  if ( !cleartext )
    outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "compose_auth_string");
  if ( realm->username )
    strcpy(cleartext, realm->username);
  else
    *cleartext = 0;
  strcat(cleartext, ":");
  if ( realm->password )
    strcat(cleartext, realm->password);
  if ( scheme == HTAA_PUBKEY )
  {
    strcat(cleartext, ":");
    strcat(cleartext, "0.0.0.0");
    strcat(cleartext, ":");
    strcat(cleartext, "42");
    strcat(cleartext, ":");
    if ( secret_key )
      strcat(cleartext, secret_key);
    ciphertext = (char *)calloc(2 * len, 1u);
    if ( !ciphertext || (compose_auth_stringResult = (char *)calloc(3 * len, 1u)) == 0 )
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "compose_auth_string");
    if ( cleartext )
    {
      free(cleartext);
      cleartext = 0;
    }
    if ( ciphertext )
    {
      free(ciphertext);
      ciphertext = 0;
    }
  }
  else
  {
    compose_auth_stringResult = (char *)calloc(4 * ((len + 2) / 3) + 1, 1u);
    if ( !compose_auth_stringResult )
      outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "compose_auth_string");
    v7 = compose_auth_stringResult;
    v8 = strlen(cleartext);
    HTUU_encode((unsigned __int8 *)cleartext, v8, v7);
    if ( cleartext )
    {
      free(cleartext);
      cleartext = 0;
    }
  }
  return compose_auth_stringResult;
}

//----- (08145ABD) --------------------------------------------------------
HTAAScheme __cdecl HTAA_selectScheme(HTAASetup *setup)
{
  int scheme; // [esp+24h] [ebp-4h]

  if ( setup && setup->valid_schemes )
  {
    for ( scheme = 2; scheme <= 5; ++scheme )
    {
      if ( HTList_indexOf(setup->valid_schemes, (void *)scheme) >= 0 )
        return scheme;
    }
  }
  return 2;
}

//----- (08145B19) --------------------------------------------------------
void free_HTAAGlobals()
{
  int i; // [esp+Ch] [ebp-Ch]
  HTAAServer *server; // [esp+14h] [ebp-4h]

  if ( server_table )
  {
    for ( i = HTList_count(server_table) - 1; i >= 0; --i )
    {
      server = (HTAAServer *)HTList_objectAt(server_table, i);
      if ( server )
        HTAAServer_delete(server);
    }
    HTList_delete(server_table);
    server_table = 0;
  }
  HTAAForwardAuth_reset();
  if ( HTAA_composeAuthResult )
  {
    free(HTAA_composeAuthResult);
    HTAA_composeAuthResult = 0;
  }
  if ( current_hostname )
  {
    free(current_hostname);
    current_hostname = 0;
  }
  if ( current_docname )
  {
    free(current_docname);
    current_docname = 0;
  }
  if ( proxy_hostname )
  {
    free(proxy_hostname);
    proxy_hostname = 0;
  }
  if ( proxy_docname )
  {
    free(proxy_docname);
    proxy_docname = 0;
  }
  if ( compose_auth_stringResult )
  {
    free(compose_auth_stringResult);
    compose_auth_stringResult = 0;
  }
  if ( secret_key )
  {
    free(secret_key);
    secret_key = 0;
  }
}

//----- (08145C7A) --------------------------------------------------------
char *__cdecl HTAA_composeAuth(const char *hostname, const int portnumber, const char *docname, BOOLEAN IsProxy)
{
  FILE *v4; // eax
  FILE *v5; // edx
  const char *v6; // ebx
  char *v7; // eax
  size_t v8; // ebx
  const char *v9; // eax
  FILE *v10; // edx
  const char *v11; // ebx
  char *v12; // eax
  size_t v13; // ebx
  const char *v14; // eax
  const char *v15; // eax
  char *msg; // [esp+30h] [ebp-18h] BYREF
  int len; // [esp+34h] [ebp-14h]
  HTAAScheme scheme; // [esp+38h] [ebp-10h]
  char *auth_string; // [esp+3Ch] [ebp-Ch]
  BOOLEAN retry; // [esp+43h] [ebp-5h]

  if ( !free_HTAAGlobalsSet[0] )
    free_HTAAGlobalsSet[0] = 1;
  if ( !HTAAForwardAuth )
  {
    if ( HTAA_composeAuthResult )
    {
      free(HTAA_composeAuthResult);
      HTAA_composeAuthResult = 0;
    }
    if ( IsProxy )
    {
      if ( WWW_TraceFlag[0] )
      {
        v5 = TraceFP();
        fprintf(v5, "Composing Proxy Authorization for %s:%d/%s\n", hostname, portnumber, docname);
      }
      if ( proxy_portnumber == portnumber
        && proxy_hostname
        && proxy_docname
        && hostname
        && docname
        && !strcmp(proxy_hostname, hostname)
        && !strcmp(proxy_docname, docname) )
      {
        retry = 1;
      }
      else
      {
        retry = 0;
        proxy_portnumber = portnumber;
        if ( hostname )
        {
          HTSACopy(&proxy_hostname, hostname);
        }
        else if ( proxy_hostname )
        {
          free(proxy_hostname);
          proxy_hostname = 0;
        }
        if ( docname )
        {
          HTSACopy(&proxy_docname, docname);
        }
        else if ( proxy_docname )
        {
          free(proxy_docname);
          proxy_docname = 0;
        }
      }
      if ( !proxy_setup || !retry )
        proxy_setup = HTAASetup_lookup(hostname, portnumber, docname, IsProxy);
      if ( !proxy_setup )
        return 0;
      scheme = HTAA_selectScheme(proxy_setup);
      if ( (unsigned int)(scheme - 2) > 1 )
      {
        msg = 0;
        v6 = HTAAScheme_name(scheme);
        v7 = gettext("This client doesn't know how to compose proxy authorization information for scheme");
        HTSprintf0(&msg, "%s `%s'", v7, v6);
        HTAlert(msg);
        if ( msg )
        {
          free(msg);
          msg = 0;
        }
        auth_string = 0;
      }
      else
      {
        auth_string = compose_auth_string(scheme, proxy_setup, IsProxy);
      }
      proxy_setup->retry = 0;
      if ( !auth_string )
        return 0;
      if ( !*auth_string )
      {
LABEL_41:
        HTSACopy(&HTAA_composeAuthResult, &byte_8191195);
        return HTAA_composeAuthResult;
      }
      v8 = strlen(auth_string);
      v9 = HTAAScheme_name(scheme);
      len = v8 + strlen(v9) + 26;
      HTAA_composeAuthResult = (char *)calloc(len, 1u);
      if ( !HTAA_composeAuthResult )
        outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAA_composeAuth");
      memcpy(HTAA_composeAuthResult, "Proxy-Authorization: ", 0x16u);
    }
    else
    {
      if ( WWW_TraceFlag[0] )
      {
        v10 = TraceFP();
        fprintf(v10, "Composing Authorization for %s:%d/%s\n", hostname, portnumber, docname);
      }
      if ( current_portnumber == portnumber
        && current_hostname
        && current_docname
        && hostname
        && docname
        && !strcmp(current_hostname, hostname)
        && !strcmp(current_docname, docname) )
      {
        retry = 1;
      }
      else
      {
        retry = 0;
        current_portnumber = portnumber;
        if ( hostname )
        {
          HTSACopy(&current_hostname, hostname);
        }
        else if ( current_hostname )
        {
          free(current_hostname);
          current_hostname = 0;
        }
        if ( docname )
        {
          HTSACopy(&current_docname, docname);
        }
        else if ( current_docname )
        {
          free(current_docname);
          current_docname = 0;
        }
      }
      if ( !current_setup || !retry )
        current_setup = HTAASetup_lookup(hostname, portnumber, docname, 0);
      if ( !current_setup )
        return 0;
      scheme = HTAA_selectScheme(current_setup);
      if ( (unsigned int)(scheme - 2) > 1 )
      {
        msg = 0;
        v11 = HTAAScheme_name(scheme);
        v12 = gettext("This client doesn't know how to compose authorization information for scheme");
        HTSprintf0(&msg, "%s `%s'", v12, v11);
        HTAlert(msg);
        if ( msg )
        {
          free(msg);
          msg = 0;
        }
        auth_string = 0;
      }
      else
      {
        auth_string = compose_auth_string(scheme, current_setup, 0);
      }
      current_setup->retry = 0;
      if ( !auth_string )
        return 0;
      if ( !*auth_string )
        goto LABEL_41;
      v13 = strlen(auth_string);
      v14 = HTAAScheme_name(scheme);
      len = v13 + strlen(v14) + 20;
      HTAA_composeAuthResult = (char *)calloc(len, 1u);
      if ( !HTAA_composeAuthResult )
        outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAA_composeAuth");
      memcpy(HTAA_composeAuthResult, "Authorization: ", 0x10u);
    }
    v15 = HTAAScheme_name(scheme);
    strcat(HTAA_composeAuthResult, v15);
    strcat(HTAA_composeAuthResult, " ");
    strcat(HTAA_composeAuthResult, auth_string);
    return HTAA_composeAuthResult;
  }
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "HTAA_composeAuth: %s\n", "Forwarding received authorization");
  }
  HTSACopy(&HTAA_composeAuthResult, HTAAForwardAuth);
  HTAAForwardAuth_reset();
  return HTAA_composeAuthResult;
}

//----- (08146310) --------------------------------------------------------
BOOLEAN __cdecl HTAA_shouldRetryWithAuth(char *start_of_headers, int length, int soc, BOOLEAN IsProxy)
{
  FILE *v4; // eax
  FILE *v5; // eax
  char *v6; // eax
  HTAssocList **v7; // ebx
  FILE *v8; // eax
  FILE *v9; // eax
  FILE *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  const char *v16; // [esp+24h] [ebp-64h]
  const char *v17; // [esp+28h] [ebp-60h]
  const char *v18; // [esp+2Ch] [ebp-5Ch]
  const char *v19; // [esp+30h] [ebp-58h]
  const char *v20; // [esp+34h] [ebp-54h]
  HTAAServer *server_0; // [esp+4Ch] [ebp-3Ch]
  HTAAServer *server; // [esp+50h] [ebp-38h]
  int i; // [esp+54h] [ebp-34h]
  char *args; // [esp+58h] [ebp-30h]
  const char *arg1; // [esp+5Ch] [ebp-2Ch]
  const char *fieldname; // [esp+60h] [ebp-28h]
  char *p; // [esp+64h] [ebp-24h] BYREF
  char *temp; // [esp+68h] [ebp-20h] BYREF
  char *ctemplate; // [esp+6Ch] [ebp-1Ch] BYREF
  HTAssocList **scheme_specifics; // [esp+70h] [ebp-18h]
  HTList *valid_schemes; // [esp+74h] [ebp-14h]
  int num_schemes; // [esp+78h] [ebp-10h]
  char *line; // [esp+7Ch] [ebp-Ch]
  HTAAScheme scheme; // [esp+80h] [ebp-8h]

  line = 0;
  num_schemes = 0;
  valid_schemes = HTList_new();
  scheme_specifics = 0;
  ctemplate = 0;
  temp = 0;
  if ( !free_HTAAGlobalsSet[0] )
    free_HTAAGlobalsSet[0] = 1;
  if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(v4, "Server reply header lines:\n");
  }
  HTAA_setupReader(start_of_headers, length, soc);
  while ( 1 )
  {
    line = HTAA_getUnfoldedLine();
    if ( !line || !*line )
      break;
    if ( WWW_TraceFlag[0] )
    {
      v5 = TraceFP();
      fprintf(v5, "%s\n", line);
    }
    if ( strchr(line, 58) )
    {
      p = line;
      fieldname = HTNextField(&p);
      arg1 = HTNextField(&p);
      args = p;
      if ( (!IsProxy || strcasecomp(fieldname, "Proxy-Authenticate:"))
        && (IsProxy || strcasecomp(fieldname, "WWW-Authenticate:")) )
      {
        if ( !IsProxy && !strcasecomp(fieldname, "WWW-Protection-Template:") )
        {
          if ( WWW_TraceFlag[0] )
          {
            v9 = TraceFP();
            fprintf(v9, "Protection template set to `%s'\n", arg1);
          }
          HTSACopy(&ctemplate, arg1);
        }
      }
      else if ( arg1 && *arg1 && args && *args )
      {
        scheme = HTAAScheme_enum(arg1);
        if ( scheme )
        {
          HTList_addObject(valid_schemes, (void *)scheme);
          if ( !scheme_specifics )
          {
            scheme_specifics = (HTAssocList **)calloc(6u, 4u);
            if ( !scheme_specifics )
              outofmem("../../../WWW/Library/Implementation/HTAABrow.c", "HTAA_shouldRetryWithAuth");
            for ( i = 0; i <= 5; ++i )
              scheme_specifics[i] = 0;
          }
          v7 = &scheme_specifics[scheme];
          *v7 = HTAA_parseArgList(args);
          ++num_schemes;
        }
        else if ( WWW_TraceFlag[0] )
        {
          if ( IsProxy )
            v20 = "in Proxy-Authenticate: field";
          else
            v20 = "in WWW-Authenticate: field";
          v8 = TraceFP();
          fprintf(v8, "Unknown scheme `%s' %s\n", arg1, v20);
        }
      }
      else
      {
        if ( args && *args )
          v16 = args;
        else
          v16 = &byte_8191195;
        if ( args && *args )
          v17 = " ";
        else
          v17 = &byte_8191195;
        if ( arg1 && *arg1 )
          v18 = arg1;
        else
          v18 = &byte_8191195;
        if ( arg1 && *arg1 )
          v19 = " ";
        else
          v19 = &byte_8191195;
        v6 = gettext("Invalid header '%s%s%s%s%s'");
        HTSprintf0(&temp, v6, line, v19, v18, v17, v16);
        HTAlert(temp);
        if ( temp )
        {
          free(temp);
          temp = 0;
        }
      }
    }
    else if ( WWW_TraceFlag[0] )
    {
      v10 = TraceFP();
      fprintf(v10, "Invalid header line `%s' ignored\n", line);
    }
    if ( line )
    {
      free(line);
      line = 0;
    }
  }
  if ( line )
  {
    free(line);
    line = 0;
  }
  if ( IsProxy )
  {
    if ( num_schemes )
    {
      if ( proxy_setup && proxy_setup->server )
      {
        HTAASetup_updateSpecifics(proxy_setup, scheme_specifics);
        v11 = gettext("Authorization failed.  Retry?");
        if ( HTConfirm(v11) )
        {
          proxy_setup->retry = 1;
          return 1;
        }
        else
        {
          proxy_setup = 0;
          return 0;
        }
      }
      else
      {
        server = HTAAServer_lookup(proxy_hostname, proxy_portnumber, IsProxy);
        if ( !server )
          server = HTAAServer_new(proxy_hostname, proxy_portnumber, IsProxy);
        if ( !ctemplate )
          HTSACopy(&ctemplate, "*");
        proxy_setup = HTAASetup_new(server, ctemplate, valid_schemes, scheme_specifics);
        if ( ctemplate )
        {
          free(ctemplate);
          ctemplate = 0;
        }
        v12 = gettext("Proxy authorization required -- retrying");
        HTAlert(v12);
        return 1;
      }
    }
    else
    {
      proxy_setup = 0;
      return 0;
    }
  }
  else if ( num_schemes )
  {
    if ( current_setup && current_setup->server )
    {
      HTAASetup_updateSpecifics(current_setup, scheme_specifics);
      v13 = gettext("Authorization failed.  Retry?");
      if ( HTConfirm(v13) )
      {
        current_setup->retry = 1;
        return 1;
      }
      else
      {
        current_setup = 0;
        return 0;
      }
    }
    else
    {
      server_0 = HTAAServer_lookup(current_hostname, current_portnumber, 0);
      if ( !server_0 )
        server_0 = HTAAServer_new(current_hostname, current_portnumber, 0);
      if ( !ctemplate )
        ctemplate = HTAA_makeProtectionTemplate(current_docname);
      current_setup = HTAASetup_new(server_0, ctemplate, valid_schemes, scheme_specifics);
      if ( ctemplate )
      {
        free(ctemplate);
        ctemplate = 0;
      }
      v14 = gettext("Access without authorization denied -- retrying");
      HTAlert(v14);
      return 1;
    }
  }
  else
  {
    current_setup = 0;
    return 0;
  }
}
// 8146627: conditional instruction was optimized away because %arg1.4!=0

//----- (081469C0) --------------------------------------------------------
void HTClearHTTPAuthInfo()
{
  free_HTAAGlobals();
  free_HTAAGlobalsSet[0] = 0;
}

//----- (081469D4) --------------------------------------------------------
BOOLEAN __cdecl isNumber(const char *s)
{
  char *cur; // [esp+10h] [ebp-4h]

  cur = (char *)s;
  if ( !s || !*s )
    return 0;
  if ( *s == 45 )
    cur = (char *)(s + 1);
  while ( *cur )
  {
    if ( *cur <= 47 || *cur > 57 )
      return 0;
    ++cur;
  }
  return 1;
}

//----- (08146A38) --------------------------------------------------------
int HTAA_getUid()
{
  int uid; // [esp+14h] [ebp-4h]
  int uida; // [esp+14h] [ebp-4h]
  int uidb; // [esp+14h] [ebp-4h]

  if ( current_prot && current_prot->uid_name )
  {
    if ( isNumber(current_prot->uid_name) )
    {
      uid = atoi(current_prot->uid_name);
      if ( *HTAA_UidToName(uid) )
        return uid;
    }
    else
    {
      uida = HTAA_NameToUid(current_prot->uid_name);
      if ( uida != 65533 )
        return uida;
    }
  }
  uidb = HTAA_NameToUid("nobody");
  if ( uidb == 65533 )
    return 65534;
  else
    return uidb;
}

//----- (08146AE4) --------------------------------------------------------
int HTAA_getGid()
{
  int gid; // [esp+14h] [ebp-4h]
  int gida; // [esp+14h] [ebp-4h]
  int gidb; // [esp+14h] [ebp-4h]

  if ( current_prot && current_prot->gid_name )
  {
    if ( isNumber(current_prot->gid_name) )
    {
      gid = atoi(current_prot->gid_name);
      if ( *HTAA_GidToName(gid) )
        return gid;
    }
    else
    {
      gida = HTAA_NameToGid(current_prot->gid_name);
      if ( gida != 65533 )
        return gida;
    }
  }
  gidb = HTAA_NameToGid("nogroup");
  if ( gidb == 65533 )
    return 65534;
  else
    return gidb;
}

//----- (08146B90) --------------------------------------------------------
void __cdecl HTAA_setIds(HTAAProt *prot, const char *ids)
{
  char *point; // [esp+10h] [ebp-8h]
  char *local_copy; // [esp+14h] [ebp-4h] BYREF

  if ( ids )
  {
    local_copy = 0;
    HTSACopy(&local_copy, ids);
    point = strchr(local_copy, 46);
    if ( point )
    {
      *point = 0;
      HTSACopy(&prot->gid_name, point + 1);
    }
    else
    {
      HTSACopy(&prot->gid_name, "nogroup");
    }
    HTSACopy(&prot->uid_name, local_copy);
    if ( local_copy )
    {
      free(local_copy);
      local_copy = 0;
    }
  }
  else
  {
    HTSACopy(&prot->uid_name, "nobody");
    HTSACopy(&prot->gid_name, "nogroup");
  }
}

//----- (08146C6A) --------------------------------------------------------
void __cdecl HTAA_parseProtFile(HTAAProt *prot, FILE *fp)
{
  const char *v2; // ebx
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  FILE *v6; // eax
  char *v7; // ebx
  FILE *v8; // eax
  int v9; // ebx
  FILE *v10; // eax
  void *scheme; // [esp+18h] [ebp-10h]
  char *fieldname; // [esp+1Ch] [ebp-Ch] BYREF
  LexItem lex_item; // [esp+20h] [ebp-8h]

  if ( prot && fp )
  {
    fieldname = 0;
    while ( 1 )
    {
      lex_item = lex(fp);
      if ( lex_item == LEX_EOF )
        break;
      while ( lex_item == LEX_REC_SEP )
        lex_item = lex(fp);
      if ( lex_item == LEX_EOF )
        break;
      if ( lex_item == LEX_ALPH_STR )
      {
        HTSACopy(&fieldname, HTlex_buffer);
        lex_item = lex(fp);
        if ( lex_item != LEX_FIELD_SEP )
          unlex(lex_item);
        if ( strncasecomp(fieldname, "Auth", 4) )
        {
          if ( strncasecomp(fieldname, "mask", 4) )
          {
            lex_item = lex(fp);
            if ( lex_item == LEX_ALPH_STR )
            {
              if ( !prot->values )
                prot->values = HTAssocList_new();
              HTAssocList_add(prot->values, fieldname, HTlex_buffer);
              lex_item = lex(fp);
              if ( WWW_TraceFlag[0] )
              {
                v7 = fieldname;
                v8 = TraceFP();
                fprintf(v8, "%s `%s' bound to value `%s'\n", "HTAA_parseProtFile: Name", v7, HTlex_buffer);
              }
            }
          }
          else
          {
            prot->mask_group = HTAA_parseGroupDef(fp);
            lex_item = LEX_REC_SEP;
            if ( WWW_TraceFlag[0] )
            {
              if ( prot->mask_group )
              {
                v5 = TraceFP();
                fwrite("HTAA_parseProtFile: Mask group:\n", 1u, 0x20u, v5);
                HTAA_printGroupDef(prot->mask_group);
              }
              else
              {
                v6 = TraceFP();
                fwrite("HTAA_parseProtFile: Mask group syntax error\n", 1u, 0x2Cu, v6);
              }
            }
          }
        }
        else
        {
          lex_item = lex(fp);
          while ( lex_item == LEX_ALPH_STR )
          {
            scheme = (void *)HTAAScheme_enum(HTlex_buffer);
            if ( scheme )
            {
              if ( !prot->valid_schemes )
                prot->valid_schemes = HTList_new();
              HTList_addObject(prot->valid_schemes, scheme);
              if ( WWW_TraceFlag[0] )
              {
                v2 = HTAAScheme_name((HTAAScheme)scheme);
                v3 = TraceFP();
                fprintf(v3, "%s %s `%s'\n", "HTAA_parseProtFile: valid", "authentication scheme:", v2);
              }
            }
            else if ( WWW_TraceFlag[0] )
            {
              v4 = TraceFP();
              fprintf(v4, "%s %s `%s'\n", "HTAA_parseProtFile: unknown", "authentication scheme:", HTlex_buffer);
            }
            lex_item = lex(fp);
            if ( lex_item != LEX_ITEM_SEP )
              break;
            do
              lex_item = lex(fp);
            while ( lex_item == LEX_REC_SEP );
          }
        }
      }
      if ( lex_item != LEX_EOF && lex_item != LEX_REC_SEP )
      {
        if ( WWW_TraceFlag[0] )
        {
          v9 = HTlex_line;
          v10 = TraceFP();
          fprintf(
            v10,
            "%s %s %d (that line ignored)\n",
            "HTAA_parseProtFile: Syntax error",
            "in protection setup file at line",
            v9);
        }
        do
          lex_item = lex(fp);
        while ( lex_item != LEX_EOF && lex_item != LEX_REC_SEP );
      }
    }
    if ( fieldname )
      free(fieldname);
  }
}

//----- (08146FFC) --------------------------------------------------------
HTAAProt *__cdecl HTAAProt_new(const char *cur_docname, const char *prot_filename, const char *ids)
{
  FILE *v3; // eax
  FILE *v4; // eax
  FILE *v5; // eax
  void *object; // [esp+10h] [ebp-18h]
  const char *v8; // [esp+14h] [ebp-14h]
  FILE *fp; // [esp+18h] [ebp-10h]
  HTAAProt *prot; // [esp+1Ch] [ebp-Ch]
  HTAAProtCache *cache_item; // [esp+20h] [ebp-8h]
  HTList *cur; // [esp+24h] [ebp-4h]

  cur = prot_cache;
  if ( !prot_cache )
    prot_cache = HTList_new();
  do
  {
    if ( cur && (cur = cur->next) != 0 )
      object = cur->object;
    else
      object = 0;
  }
  while ( object && strcmp(*(const char **)object, prot_filename) );
  if ( object )
  {
    prot = (HTAAProt *)*((_DWORD *)object + 1);
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(v3, "%s `%s' already in cache\n", "HTAAProt_new: Protection file", prot_filename);
    }
  }
  else
  {
    if ( WWW_TraceFlag[0] )
    {
      v4 = TraceFP();
      fprintf(v4, "HTAAProt_new: Loading protection file `%s'\n", prot_filename);
    }
    prot = (HTAAProt *)calloc(1u, 0x1Cu);
    if ( !prot )
      outofmem("../../../WWW/Library/Implementation/HTAAProt.c", "HTAAProt_new");
    prot->ctemplate = 0;
    prot->filename = 0;
    prot->uid_name = 0;
    prot->gid_name = 0;
    prot->valid_schemes = HTList_new();
    prot->mask_group = 0;
    prot->values = HTAssocList_new();
    if ( prot_filename && (fp = (FILE *)fopen64(prot_filename, "r")) != 0 )
    {
      HTAA_parseProtFile(prot, fp);
      fclose(fp);
      cache_item = (HTAAProtCache *)calloc(1u, 8u);
      if ( !cache_item )
        outofmem("../../../WWW/Library/Implementation/HTAAProt.c", "HTAAProt_new");
      cache_item->prot = prot;
      cache_item->prot_filename = 0;
      HTSACopy(&cache_item->prot_filename, prot_filename);
      HTList_addObject(prot_cache, cache_item);
    }
    else if ( WWW_TraceFlag[0] )
    {
      if ( prot_filename )
        v8 = prot_filename;
      else
        v8 = "(null)";
      v5 = TraceFP();
      fprintf(v5, "HTAAProt_new: %s `%s'\n", "Unable to open protection setup file", v8);
    }
  }
  if ( cur_docname )
    HTSACopy(&prot->filename, cur_docname);
  HTAA_setIds(prot, ids);
  return prot;
}
// 804AB04: using guessed type int __cdecl fopen64(_DWORD, _DWORD);

//----- (08147289) --------------------------------------------------------
void __cdecl HTAA_setDefaultProtection(const char *cur_docname, const char *prot_filename, const char *ids)
{
  FILE *v3; // eax

  default_prot = 0;
  if ( prot_filename )
  {
    default_prot = HTAAProt_new(cur_docname, prot_filename, ids);
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(
      v3,
      "%s %s\n",
      "HTAA_setDefaultProtection: ERROR: Protection file",
      "not specified (obligatory for DefProt rule)!!\n");
  }
}

//----- (081472F3) --------------------------------------------------------
void __cdecl HTAA_setCurrentProtection(const char *cur_docname, const char *prot_filename, const char *ids)
{
  FILE *v3; // eax
  FILE *v4; // eax

  current_prot = 0;
  if ( prot_filename )
  {
    current_prot = HTAAProt_new(cur_docname, prot_filename, ids);
  }
  else if ( default_prot )
  {
    current_prot = default_prot;
    HTAA_setIds(default_prot, ids);
    if ( WWW_TraceFlag[0] )
    {
      v3 = TraceFP();
      fprintf(
        v3,
        "%s %s %s\n",
        "HTAA_setCurrentProtection: Protection file",
        "not specified for Protect rule",
        "-- using default protection");
    }
  }
  else if ( WWW_TraceFlag[0] )
  {
    v4 = TraceFP();
    fprintf(
      v4,
      "%s %s %s\n",
      "HTAA_setCurrentProtection: ERROR: Protection",
      "file not specified for Protect rule, and",
      "default protection is not set!!");
  }
}

//----- (081473CC) --------------------------------------------------------
HTAAProt *HTAA_getCurrentProtection()
{
  return current_prot;
}

//----- (081473D6) --------------------------------------------------------
HTAAProt *HTAA_getDefaultProtection()
{
  if ( !current_prot )
  {
    current_prot = default_prot;
    default_prot = 0;
  }
  return current_prot;
}

//----- (081473FD) --------------------------------------------------------
void HTAA_clearProtections()
{
  current_prot = 0;
  default_prot = 0;
}

//----- (08147416) --------------------------------------------------------
void __cdecl save_gid_info(const char *name, int user)
{
  USER_DATA *data; // [esp+14h] [ebp-4h]

  data = (USER_DATA *)calloc(1u, 8u);
  if ( data )
  {
    if ( !known_grp )
    {
      known_grp = HTList_new();
      if ( !uidgid_cache_inited[0] )
        uidgid_cache_inited[0] = 1;
    }
    HTSACopy(&data->name, name);
    data->user = user;
    HTList_addObject(known_grp, data);
  }
}

//----- (08147490) --------------------------------------------------------
void __cdecl save_uid_info(const char *name, int user)
{
  USER_DATA *data; // [esp+14h] [ebp-4h]

  data = (USER_DATA *)calloc(1u, 8u);
  if ( data )
  {
    if ( !known_pwd )
    {
      known_pwd = HTList_new();
      if ( !uidgid_cache_inited[0] )
        uidgid_cache_inited[0] = 1;
    }
    HTSACopy(&data->name, name);
    data->user = user;
    HTList_addObject(known_pwd, data);
  }
}

//----- (0814750A) --------------------------------------------------------
const char *__cdecl HTAA_UidToName(int uid)
{
  __uid_t pw_uid; // ebx
  const char *pw_name; // esi
  FILE *v3; // edx
  HTList *me; // [esp+28h] [ebp-10h]
  struct passwd *pw; // [esp+2Ch] [ebp-Ch]

  me = known_pwd;
  while ( me )
  {
    me = me->next;
    if ( !me || !me->object )
      break;
    if ( *((_DWORD *)me->object + 1) == uid )
      return *(const char **)me->object;
  }
  pw = getpwuid(uid);
  if ( !pw || !pw->pw_name )
    return (const char *)&unk_81918B7;
  if ( WWW_TraceFlag[0] )
  {
    pw_uid = pw->pw_uid;
    pw_name = pw->pw_name;
    v3 = TraceFP();
    fprintf(v3, "%s(%d) returned (%s:%d:...)\n", "HTAA_UidToName: getpwuid", uid, pw_name, pw_uid);
  }
  save_uid_info(pw->pw_name, pw->pw_uid);
  return pw->pw_name;
}

//----- (081475F3) --------------------------------------------------------
int __cdecl HTAA_NameToUid(const char *name)
{
  __uid_t pw_uid; // ebx
  const char *pw_name; // esi
  FILE *v3; // edx
  USER_DATA *data; // [esp+24h] [ebp-14h]
  HTList *me; // [esp+28h] [ebp-10h]
  struct passwd *pw; // [esp+2Ch] [ebp-Ch]

  me = known_pwd;
  while ( me )
  {
    me = me->next;
    if ( !me || !me->object )
      break;
    data = (USER_DATA *)me->object;
    if ( !strcmp(name, *(const char **)me->object) )
      return data->user;
  }
  pw = getpwnam(name);
  if ( !pw )
    return 65533;
  if ( WWW_TraceFlag[0] )
  {
    pw_uid = pw->pw_uid;
    pw_name = pw->pw_name;
    v3 = TraceFP();
    fprintf(v3, "%s(%s) returned (%s:%d:...)\n", "HTAA_NameToUid: getpwnam", name, pw_name, pw_uid);
  }
  save_uid_info(pw->pw_name, pw->pw_uid);
  return pw->pw_uid;
}

//----- (081476E2) --------------------------------------------------------
const char *__cdecl HTAA_GidToName(int gid)
{
  __gid_t gr_gid; // ebx
  const char *gr_name; // esi
  FILE *v3; // edx
  HTList *me; // [esp+28h] [ebp-10h]
  struct group *gr; // [esp+2Ch] [ebp-Ch]

  me = known_grp;
  while ( me )
  {
    me = me->next;
    if ( !me || !me->object )
      break;
    if ( *((_DWORD *)me->object + 1) == gid )
      return *(const char **)me->object;
  }
  gr = getgrgid(gid);
  if ( !gr || !gr->gr_name )
    return (const char *)&unk_81918B7;
  if ( WWW_TraceFlag[0] )
  {
    gr_gid = gr->gr_gid;
    gr_name = gr->gr_name;
    v3 = TraceFP();
    fprintf(v3, "%s(%d) returned (%s:%d:...)\n", "HTAA_GidToName: getgrgid", gid, gr_name, gr_gid);
  }
  save_gid_info(gr->gr_name, gr->gr_gid);
  return gr->gr_name;
}

//----- (081477CB) --------------------------------------------------------
int __cdecl HTAA_NameToGid(const char *name)
{
  __gid_t gr_gid; // ebx
  const char *gr_name; // esi
  FILE *v3; // edx
  USER_DATA *data; // [esp+24h] [ebp-14h]
  HTList *me; // [esp+28h] [ebp-10h]
  struct group *gr; // [esp+2Ch] [ebp-Ch]

  me = known_grp;
  while ( me )
  {
    me = me->next;
    if ( !me || !me->object )
      break;
    data = (USER_DATA *)me->object;
    if ( !strcmp(name, *(const char **)me->object) )
      return data->user;
  }
  gr = getgrnam(name);
  if ( !gr )
    return 65533;
  if ( WWW_TraceFlag[0] )
  {
    gr_gid = gr->gr_gid;
    gr_name = gr->gr_name;
    v3 = TraceFP();
    fprintf(v3, "%s(%s) returned (%s:%d:...)\n", "HTAA_NameToGid: getgrnam", name, gr_name, gr_gid);
  }
  save_gid_info(gr->gr_name, gr->gr_gid);
  return gr->gr_gid;
}

//----- (081478BC) --------------------------------------------------------
HTAssocList *HTAssocList_new()
{
  return HTList_new();
}

//----- (081478C9) --------------------------------------------------------
void __cdecl HTAssocList_delete(HTAssocList *alist)
{
  void **object; // [esp+4h] [ebp-14h]
  HTAssocList *cur; // [esp+14h] [ebp-4h]

  if ( alist )
  {
    cur = alist;
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (void **)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      if ( *object )
      {
        free(*object);
        *object = 0;
      }
      if ( object[1] )
      {
        free(object[1]);
        object[1] = 0;
      }
      free(object);
    }
    HTList_delete(alist);
  }
}
// 8147926: conditional instruction was optimized away because %var_14.4!=0

//----- (08147984) --------------------------------------------------------
void __cdecl HTAssocList_add(HTAssocList *alist, const char *name, const char *value)
{
  FILE *v3; // eax
  HTAssoc *assoc; // [esp+14h] [ebp-4h]

  if ( alist )
  {
    assoc = (HTAssoc *)malloc(8u);
    if ( !assoc )
      outofmem("../../../WWW/Library/Implementation/HTAssoc.c", "HTAssoc_add");
    assoc->name = 0;
    assoc->value = 0;
    if ( name )
      HTSACopy(&assoc->name, name);
    if ( value )
      HTSACopy(&assoc->value, value);
    HTList_addObject(alist, assoc);
  }
  else if ( WWW_TraceFlag[0] )
  {
    v3 = TraceFP();
    fprintf(v3, "HTAssoc_add: ERROR: assoc list NULL!!\n");
  }
}

//----- (08147A3B) --------------------------------------------------------
char *__cdecl HTAssocList_lookup(HTAssocList *alist, const char *name)
{
  int v3; // [esp+8h] [ebp-20h]
  void *object; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    if ( alist && (alist = alist->next) != 0 )
      object = alist->object;
    else
      object = 0;
    if ( !object )
      break;
    v3 = strlen(name);
    if ( !strncasecomp(*(const char **)object, name, v3) )
      return (char *)*((_DWORD *)object + 1);
  }
  return 0;
}

//----- (08147ABC) --------------------------------------------------------
void __cdecl unlex(LexItem lex_item)
{
  lex_pushed_back = lex_item;
}

//----- (08147AC9) --------------------------------------------------------
LexItem __cdecl lex(FILE *fp)
{
  int v1; // edx
  LexItem v3; // [esp+14h] [ebp-14h]
  LexItem ret; // [esp+20h] [ebp-8h]
  int ch_0; // [esp+24h] [ebp-4h]

  if ( fp != cache )
  {
    cache = fp;
    HTlex_line = 1;
  }
  if ( lex_pushed_back )
  {
    ret = lex_pushed_back;
    lex_pushed_back = LEX_NONE;
    return ret;
  }
  else
  {
    lex_cnt = 0;
    lex_template[0] = 0;
    while ( 2 )
    {
      ch_0 = _IO_getc(fp);
      switch ( ch_0 )
      {
        case -1:
        case 9:
        case 10:
        case 13:
        case 32:
        case 40:
        case 41:
        case 44:
        case 58:
        case 64:
          if ( lex_cnt <= 0 )
          {
            switch ( ch_0 )
            {
              case -1:
                v3 = LEX_EOF;
                break;
              case 10:
                ++HTlex_line;
                v3 = LEX_REC_SEP;
                break;
              case 40:
                v3 = LEX_OPEN_PAREN;
                break;
              case 41:
                v3 = LEX_CLOSE_PAREN;
                break;
              case 44:
                v3 = LEX_ITEM_SEP;
                break;
              case 58:
                v3 = LEX_FIELD_SEP;
                break;
              case 64:
                v3 = LEX_AT_SIGN;
                break;
              default:
                continue;
            }
          }
          else
          {
            if ( ch_0 != -1 )
              ungetc(ch_0, fp);
            if ( lex_template[0] )
              v3 = LEX_TMPL_STR;
            else
              v3 = LEX_ALPH_STR;
          }
          break;
        default:
          if ( lex_cnt <= 38 )
          {
            v1 = lex_cnt;
            HTlex_buffer[lex_cnt] = ch_0;
            lex_cnt = v1 + 1;
          }
          HTlex_buffer[lex_cnt] = 0;
          if ( ch_0 == 42 )
            lex_template[0] = 1;
          continue;
      }
      break;
    }
  }
  return v3;
}

//----- (08147C4C) --------------------------------------------------------
const char *__cdecl lex_verbose(LexItem lex_item)
{
  const char *v2; // [esp+14h] [ebp-4h]

  switch ( lex_item )
  {
    case LEX_NONE:
      v2 = "NO-LEX-ITEM";
      break;
    case LEX_EOF:
      v2 = "end-of-file";
      break;
    case LEX_REC_SEP:
      v2 = "record separator (newline)";
      break;
    case LEX_FIELD_SEP:
      v2 = "field separator ':'";
      break;
    case LEX_ITEM_SEP:
      v2 = "item separator ','";
      break;
    case LEX_OPEN_PAREN:
      v2 = "'('";
      break;
    case LEX_CLOSE_PAREN:
      v2 = "')'";
      break;
    case LEX_AT_SIGN:
      v2 = "address qualifier '@'";
      break;
    case LEX_ALPH_STR:
      sprintf(msg_4952, "alphanumeric string '%.*s'", 40, HTlex_buffer);
      v2 = msg_4952;
      break;
    case LEX_TMPL_STR:
      sprintf(msg_4952, "template string '%.*s'", 40, HTlex_buffer);
      v2 = msg_4952;
      break;
    default:
      v2 = "UNKNOWN-LEX-ITEM";
      break;
  }
  return v2;
}

//----- (08147D24) --------------------------------------------------------
int __cdecl HTUU_encode(unsigned __int8 *bufin, unsigned int nbytes, char *bufcoded)
{
  char *outptr; // [esp+0h] [ebp-14h]
  char *outptra; // [esp+0h] [ebp-14h]
  unsigned int i; // [esp+10h] [ebp-4h]

  outptr = bufcoded;
  for ( i = 0; i < nbytes; i += 3 )
  {
    *outptr = six2pr[*bufin >> 2];
    outptra = outptr + 1;
    *outptra = six2pr[(16 * *bufin) & 0x30 | (bufin[1] >> 4)];
    outptra[1] = six2pr[(4 * bufin[1]) & 0x3C | (bufin[2] >> 6)];
    outptra[2] = six2pr[bufin[2] & 0x3F];
    outptr = outptra + 3;
    bufin += 3;
  }
  if ( nbytes + 1 == i )
  {
    *(outptr - 1) = 61;
  }
  else if ( nbytes + 2 == i )
  {
    *(outptr - 1) = 61;
    *(outptr - 2) = 61;
  }
  *outptr = 0;
  return outptr - bufcoded;
}

//----- (08147E39) --------------------------------------------------------
int __cdecl HTUU_decode(char *bufcoded, unsigned __int8 *bufplain, int outbufsize)
{
  char *bufin; // [esp+8h] [ebp-1Ch]
  char *bufina; // [esp+8h] [ebp-1Ch]
  unsigned __int8 *bufouta; // [esp+Ch] [ebp-18h]
  int nprbytes; // [esp+10h] [ebp-14h]
  int j; // [esp+1Ch] [ebp-8h]
  int ja; // [esp+1Ch] [ebp-8h]
  int nbytesdecoded; // [esp+20h] [ebp-4h]

  if ( first_4934 )
  {
    first_4934 = 0;
    for ( j = 0; j <= 255; ++j )
      pr2six[j] = 64;
    for ( ja = 0; ja <= 63; ++ja )
      pr2six[(unsigned __int8)six2pr[ja]] = ja;
  }
  while ( *bufcoded == 32 || *bufcoded == 9 )
    ++bufcoded;
  bufin = bufcoded;
  while ( pr2six[(unsigned __int8)*bufin++] <= 0x3Fu )
    ;
  nprbytes = bufin - bufcoded - 1;
  nbytesdecoded = 3 * ((nprbytes + 3) / 4);
  if ( nbytesdecoded > outbufsize )
    nprbytes = 4 * outbufsize / 3;
  bufina = bufcoded;
  while ( nprbytes > 0 )
  {
    *bufplain = (4 * pr2six[*bufina]) | (pr2six[bufina[1]] >> 4);
    bufouta = bufplain + 1;
    *bufouta = (16 * pr2six[bufina[1]]) | (pr2six[bufina[2]] >> 2);
    bufouta[1] = (pr2six[bufina[2]] << 6) | pr2six[bufina[3]];
    bufplain = bufouta + 2;
    bufina += 4;
    nprbytes -= 4;
  }
  if ( (nprbytes & 3) != 0 )
  {
    if ( pr2six[*(bufina - 2)] <= 0x3Fu )
      --nbytesdecoded;
    else
      nbytesdecoded -= 2;
  }
  return nbytesdecoded;
}

//----- (0814803C) --------------------------------------------------------
HTAAScheme __cdecl HTAAScheme_enum(const char *name)
{
  char *upcased; // [esp+24h] [ebp-4h] BYREF

  upcased = 0;
  if ( !name )
    return 0;
  HTSACopy(&upcased, name);
  LYUpperCase(upcased);
  if ( !strncmp(upcased, "NONE", 4u) )
  {
    if ( upcased )
    {
      free(upcased);
      upcased = 0;
    }
    return 1;
  }
  else if ( !strncmp(upcased, "BASIC", 5u) )
  {
    if ( upcased )
    {
      free(upcased);
      upcased = 0;
    }
    return 2;
  }
  else if ( !strncmp(upcased, "PUBKEY", 6u) )
  {
    if ( upcased )
    {
      free(upcased);
      upcased = 0;
    }
    return 3;
  }
  else if ( !strncmp(upcased, "KERBEROSV4", 0xAu) )
  {
    if ( upcased )
    {
      free(upcased);
      upcased = 0;
    }
    return 4;
  }
  else if ( !strncmp(upcased, "KERBEROSV5", 0xAu) )
  {
    if ( upcased )
    {
      free(upcased);
      upcased = 0;
    }
    return 5;
  }
  else
  {
    if ( upcased )
    {
      free(upcased);
      upcased = 0;
    }
    return 0;
  }
}

//----- (081481EB) --------------------------------------------------------
const char *__cdecl HTAAScheme_name(HTAAScheme scheme)
{
  const char *v2; // [esp+0h] [ebp-4h]

  switch ( scheme )
  {
    case HTAA_UNKNOWN:
      v2 = "UNKNOWN";
      break;
    case HTAA_NONE:
      v2 = "None";
      break;
    case HTAA_BASIC:
      v2 = "Basic";
      break;
    case HTAA_PUBKEY:
      v2 = "Pubkey";
      break;
    case HTAA_KERBEROS_V4:
      v2 = "KerberosV4";
      break;
    case HTAA_KERBEROS_V5:
      v2 = "KerberosV5";
      break;
    default:
      v2 = "THIS-IS-A-BUG";
      break;
  }
  return v2;
}

//----- (08148247) --------------------------------------------------------
HTAAMethod __cdecl HTAAMethod_enum(const char *name)
{
  if ( !name )
    return 0;
  if ( !strcasecomp(name, "GET") )
    return 1;
  if ( strcasecomp(name, "PUT") )
    return 0;
  return 2;
}

//----- (081482A8) --------------------------------------------------------
const char *__cdecl HTAAMethod_name(HTAAMethod method)
{
  switch ( method )
  {
    case METHOD_GET:
      return "GET";
    case METHOD_UNKNOWN:
      return "UNKNOWN";
    case METHOD_PUT:
      return "PUT";
  }
  return "THIS-IS-A-BUG";
}

//----- (081482EF) --------------------------------------------------------
BOOLEAN __cdecl HTAAMethod_inList(HTAAMethod method, HTList *list)
{
  FILE *v2; // edx
  const char *object; // [esp+14h] [ebp-14h]

  while ( 1 )
  {
    if ( list && (list = list->next) != 0 )
      object = (const char *)list->object;
    else
      object = 0;
    if ( !object )
      break;
    if ( WWW_TraceFlag[0] )
    {
      v2 = TraceFP();
      fprintf(v2, " %s", object);
    }
    if ( HTAAMethod_enum(object) == method )
      return 1;
  }
  return 0;
}

//----- (0814837A) --------------------------------------------------------
BOOLEAN __cdecl HTAA_templateMatch(const char *ctemplate, const char *filename)
{
  size_t v2; // ebx
  int m; // [esp+18h] [ebp-10h]
  const char *pa; // [esp+20h] [ebp-8h]

  while ( *ctemplate && *filename && *ctemplate == *filename )
  {
    ++ctemplate;
    ++filename;
  }
  if ( !*ctemplate && !*filename )
    return 1;
  if ( *ctemplate != 42 )
    return 0;
  pa = ctemplate + 1;
  v2 = strlen(filename);
  m = v2 - strlen(pa);
  return m >= 0 && strcmp(pa, &filename[m]) == 0;
}

//----- (08148443) --------------------------------------------------------
BOOLEAN __cdecl HTAA_templateCaseMatch(const char *ctemplate, const char *filename)
{
  size_t v2; // ebx
  int v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int m; // [esp+18h] [ebp-10h]
  const char *pa; // [esp+20h] [ebp-8h]

  while ( *ctemplate && *filename )
  {
    v4 = ((*__ctype_b_loc())[*(unsigned __int8 *)ctemplate] & 0x200) != 0 ? toupper(*(unsigned __int8 *)ctemplate) : *(unsigned __int8 *)ctemplate;
    v5 = ((*__ctype_b_loc())[*(unsigned __int8 *)filename] & 0x200) != 0 ? toupper(*(unsigned __int8 *)filename) : *(unsigned __int8 *)filename;
    if ( v4 != v5 )
      break;
    ++ctemplate;
    ++filename;
  }
  if ( !*ctemplate && !*filename )
    return 1;
  if ( *ctemplate != 42 )
    return 0;
  pa = ctemplate + 1;
  v2 = strlen(filename);
  m = v2 - strlen(pa);
  return m >= 0 && strcasecomp(pa, &filename[m]) == 0;
}

//----- (0814859C) --------------------------------------------------------
char *__cdecl HTAA_makeProtectionTemplate(const char *docname)
{
  const char *v1; // ebx
  FILE *v2; // edx
  char *slash; // [esp+1Ch] [ebp-Ch]
  char *slasha; // [esp+1Ch] [ebp-Ch]
  char *ctemplate[2]; // [esp+20h] [ebp-8h] BYREF

  ctemplate[0] = 0;
  if ( docname )
  {
    HTSACopy(ctemplate, docname);
    slash = strrchr(ctemplate[0], 47);
    if ( slash )
      slasha = slash + 1;
    else
      slasha = ctemplate[0];
    *slasha = 0;
    HTSACat(ctemplate, "*");
  }
  else
  {
    HTSACopy(ctemplate, "*");
  }
  if ( WWW_TraceFlag[0] )
  {
    v1 = ctemplate[0];
    v2 = TraceFP();
    fprintf(v2, "make_template: made template `%s' for file `%s'\n", v1, docname);
  }
  return ctemplate[0];
}

//----- (0814865A) --------------------------------------------------------
HTList *__cdecl HTAA_parseArgList(char *str)
{
  char *c_0; // [esp+20h] [ebp-18h]
  char *c; // [esp+24h] [ebp-14h]
  int n; // [esp+28h] [ebp-10h]
  char *name; // [esp+2Ch] [ebp-Ch] BYREF
  char *cur; // [esp+30h] [ebp-8h]
  HTAssocList *assoc_list; // [esp+34h] [ebp-4h]

  assoc_list = HTAssocList_new();
  cur = 0;
  name = 0;
  n = 0;
  if ( !str )
    return assoc_list;
  while ( *str )
  {
    while ( *str == 32 || *str == 9 )
      ++str;
    cur = str;
    ++n;
    while ( *cur && *cur != 61 && *cur != 44 )
      ++cur;
    for ( c = cur - 1; *c == 32 || *c == 9; --c )
      *c = 0;
    if ( *cur == 61 )
    {
      *cur++ = 0;
      HTSACopy(&name, str);
      while ( *cur == 32 || *cur == 9 )
        ++cur;
      str = cur;
      if ( *cur == 34 )
      {
        str = ++cur;
        while ( *cur && *cur != 34 )
          ++cur;
        if ( *cur == 34 )
          *cur++ = 0;
        while ( *cur == 32 || *cur == 9 )
          ++cur;
        if ( *cur == 44 )
          ++cur;
      }
      else
      {
        while ( *cur && *cur != 44 )
          ++cur;
        for ( c_0 = cur - 1; *c_0 == 32 || *c_0 == 9; --c_0 )
          *c_0 = 0;
        if ( *cur == 44 )
          *cur++ = 0;
      }
    }
    else
    {
      if ( *cur == 44 )
        *cur++ = 0;
      HTSprintf0(&name, "%d", n);
    }
    HTAssocList_add(assoc_list, name, str);
    str = cur;
  }
  if ( name )
  {
    free(name);
    name = 0;
  }
  return assoc_list;
}

//----- (08148894) --------------------------------------------------------
void __cdecl HTAA_setupReader(char *start_of_headers, int length, int soc)
{
  if ( !start_of_headers )
    length = 0;
  if ( buffer )
  {
    if ( (int)buffer_length < length )
    {
      buffer_length = length;
      buffer = (char *)realloc(buffer, length + 1);
    }
  }
  else
  {
    buffer_length = length;
    if ( (unsigned int)length <= 0x3FF )
      buffer_length = 1024;
    buffer = (char *)malloc(buffer_length + 1);
  }
  if ( !buffer )
    outofmem("../../../WWW/Library/Implementation/HTAAUtil.c", "HTAA_setupReader");
  start_pointer = buffer;
  if ( start_of_headers )
  {
    strncpy(buffer, start_of_headers, length);
    buffer[length] = 0;
    end_pointer = &buffer[length];
  }
  else
  {
    *start_pointer = 0;
    end_pointer = start_pointer;
  }
  in_soc = soc;
}

//----- (0814899D) --------------------------------------------------------
char *HTAA_getUnfoldedLine()
{
  FILE *v0; // eax
  int count; // [esp+18h] [ebp-10h]
  char *cur; // [esp+1Ch] [ebp-Ch]
  char *line; // [esp+20h] [ebp-8h] BYREF
  BOOLEAN peek_for_folding; // [esp+27h] [ebp-1h]

  line = 0;
  peek_for_folding = 0;
  if ( in_soc >= 0 )
  {
    while ( 1 )
    {
      if ( start_pointer >= end_pointer )
      {
        count = HTDoRead(in_soc, buffer, 0x400u);
        if ( count <= 0 )
        {
          in_soc = -1;
          return line;
        }
        start_pointer = buffer;
        end_pointer = &buffer[count];
        buffer[count] = 0;
      }
      cur = start_pointer;
      if ( peek_for_folding )
      {
        if ( *start_pointer != 32 && *start_pointer != 9 )
          return line;
        peek_for_folding = 0;
      }
      while ( cur < end_pointer && *cur != 10 )
        ++cur;
      if ( cur < end_pointer )
      {
        *cur = 0;
        if ( *(cur - 1) == 13 )
          *(cur - 1) = 0;
        peek_for_folding = 1;
      }
      if ( line )
        HTSACat(&line, start_pointer);
      else
        HTSACopy(&line, start_pointer);
      start_pointer = cur + 1;
    }
  }
  if ( WWW_TraceFlag[0] )
  {
    v0 = TraceFP();
    fprintf(v0, "%s %s\n", "HTAA_getUnfoldedLine: buffer not initialized", "with function HTAA_setupReader()");
  }
  return 0;
}

//----- (08148B20) --------------------------------------------------------
void __cdecl syntax_error(FILE *fp, const char *msg, LexItem lex_item)
{
  const char *v3; // ebx
  int v4; // esi
  FILE *v5; // eax
  int ch_0; // [esp+38h] [ebp-40h]
  int cnt; // [esp+3Ch] [ebp-3Ch]
  char buffer[41]; // [esp+43h] [ebp-35h] BYREF
  unsigned int v9; // [esp+6Ch] [ebp-Ch]

  v9 = __readgsdword(0x14u);
  cnt = 0;
  while ( 1 )
  {
    ch_0 = _IO_getc(fp);
    if ( ch_0 == -1 || ch_0 == 10 )
      break;
    if ( cnt <= 39 )
      buffer[cnt++] = ch_0;
  }
  buffer[cnt] = 0;
  if ( WWW_TraceFlag[0] )
  {
    v3 = lex_verbose(lex_item);
    v4 = HTlex_line;
    v5 = TraceFP();
    fprintf(
      v5,
      "%s %d before: '%s'\nHTGroup.c: %s (got %s)\n",
      "HTGroup.c: Syntax error in rule file at line",
      v4,
      buffer,
      msg,
      v3);
  }
  ++HTlex_line;
}

//----- (08148BF8) --------------------------------------------------------
AddressDefList *__cdecl parse_address_part(FILE *fp)
{
  Ref *ref; // [esp+18h] [ebp-10h]
  LexItem lex_item; // [esp+1Ch] [ebp-Ch]
  AddressDefList *address_def_list; // [esp+20h] [ebp-8h]
  BOOLEAN only_one; // [esp+27h] [ebp-1h]

  only_one = 0;
  lex_item = lex(fp);
  if ( lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR )
  {
    only_one = 1;
  }
  else if ( lex_item != LEX_OPEN_PAREN || (lex_item = lex(fp), lex_item != LEX_ALPH_STR) && lex_item != LEX_TMPL_STR )
  {
    syntax_error(fp, "Expecting a single address or '(' beginning list", lex_item);
    return 0;
  }
  address_def_list = HTList_new();
  while ( 1 )
  {
    ref = (Ref *)calloc(1u, 8u);
    if ( !ref )
      outofmem("../../../WWW/Library/Implementation/HTGroup.c", "parse_address_part");
    ref->name = 0;
    ref->translation = 0;
    HTSACopy(&ref->name, HTlex_buffer);
    HTList_addObject(address_def_list, ref);
    if ( only_one )
      break;
    lex_item = lex(fp);
    if ( lex_item != LEX_ITEM_SEP )
      break;
    do
      lex_item = lex(fp);
    while ( lex_item == LEX_REC_SEP );
    if ( lex_item != LEX_ALPH_STR && lex_item != LEX_TMPL_STR )
    {
      syntax_error(fp, "Expecting an address template", lex_item);
      HTList_delete(address_def_list);
      return 0;
    }
  }
  if ( only_one || lex_item == LEX_CLOSE_PAREN )
    return address_def_list;
  HTList_delete(address_def_list);
  syntax_error(fp, "Expecting ')' closing address list", lex_item);
  return 0;
}

//----- (08148DA3) --------------------------------------------------------
UserDefList *__cdecl parse_user_part(FILE *fp)
{
  Ref *ref; // [esp+18h] [ebp-10h]
  LexItem lex_item; // [esp+1Ch] [ebp-Ch]
  UserDefList *user_def_list; // [esp+20h] [ebp-8h]
  BOOLEAN only_one; // [esp+27h] [ebp-1h]

  only_one = 0;
  lex_item = lex(fp);
  if ( lex_item == LEX_ALPH_STR )
  {
    only_one = 1;
  }
  else if ( lex_item != LEX_OPEN_PAREN || (lex_item = lex(fp), lex_item != LEX_ALPH_STR) )
  {
    syntax_error(fp, "Expecting a single name or '(' beginning list", lex_item);
    return 0;
  }
  user_def_list = HTList_new();
  while ( 1 )
  {
    ref = (Ref *)calloc(1u, 8u);
    if ( !ref )
      outofmem("../../../WWW/Library/Implementation/HTGroup.c", "parse_user_part");
    ref->name = 0;
    ref->translation = 0;
    HTSACopy(&ref->name, HTlex_buffer);
    HTList_addObject(user_def_list, ref);
    if ( only_one )
      break;
    lex_item = lex(fp);
    if ( lex_item != LEX_ITEM_SEP )
      break;
    do
      lex_item = lex(fp);
    while ( lex_item == LEX_REC_SEP );
    if ( lex_item != LEX_ALPH_STR )
    {
      syntax_error(fp, "Expecting user or group name", lex_item);
      HTList_delete(user_def_list);
      return 0;
    }
  }
  if ( only_one || lex_item == LEX_CLOSE_PAREN )
    return user_def_list;
  HTList_delete(user_def_list);
  syntax_error(fp, "Expecting ')' closing user/group list", lex_item);
  return 0;
}

//----- (08148F38) --------------------------------------------------------
Item *__cdecl parse_item(FILE *fp)
{
  LexItem lex_item; // [esp+18h] [ebp-10h]
  AddressDefList *address_def_list; // [esp+1Ch] [ebp-Ch]
  HTList *user_def_list; // [esp+20h] [ebp-8h]
  Item *item; // [esp+24h] [ebp-4h]

  user_def_list = 0;
  address_def_list = 0;
  lex_item = lex(fp);
  if ( lex_item == LEX_ALPH_STR || lex_item == LEX_OPEN_PAREN )
  {
    unlex(lex_item);
    user_def_list = parse_user_part(fp);
    lex_item = lex(fp);
  }
  if ( lex_item != LEX_AT_SIGN )
  {
    unlex(lex_item);
    goto LABEL_13;
  }
  lex_item = lex(fp);
  if ( lex_item == LEX_ALPH_STR || lex_item == LEX_TMPL_STR || lex_item == LEX_OPEN_PAREN )
  {
    unlex(lex_item);
    address_def_list = parse_address_part(fp);
LABEL_13:
    if ( user_def_list || address_def_list )
    {
      item = (Item *)calloc(1u, 8u);
      if ( !item )
        outofmem("../../../WWW/Library/Implementation/HTGroup.c", "parse_item");
      item->user_def_list = user_def_list;
      item->address_def_list = address_def_list;
      return item;
    }
    else
    {
      syntax_error(fp, "Empty item not allowed", lex_item);
      return 0;
    }
  }
  if ( user_def_list )
    HTList_delete(user_def_list);
  syntax_error(fp, "Expected address part (single address or list)", lex_item);
  return 0;
}

//----- (0814909A) --------------------------------------------------------
ItemList *__cdecl parse_item_list(FILE *fp)
{
  LexItem lex_item; // [esp+1Ch] [ebp-Ch]
  LexItem lex_itema; // [esp+1Ch] [ebp-Ch]
  Item *item; // [esp+20h] [ebp-8h]
  HTList *item_list; // [esp+24h] [ebp-4h]

  item_list = HTList_new();
  while ( 1 )
  {
    item = parse_item(fp);
    if ( !item )
    {
      HTList_delete(item_list);
      return 0;
    }
    HTList_addObject(item_list, item);
    lex_item = lex(fp);
    if ( lex_item != LEX_ITEM_SEP )
      break;
    do
      lex_itema = lex(fp);
    while ( lex_itema == LEX_REC_SEP );
    unlex(lex_itema);
  }
  unlex(lex_item);
  return item_list;
}

//----- (08149139) --------------------------------------------------------
GroupDef *__cdecl HTAA_parseGroupDef(FILE *fp)
{
  LexItem lex_item; // [esp+1Ch] [ebp-Ch]
  GroupDef *group_def; // [esp+20h] [ebp-8h]
  ItemList *item_list; // [esp+24h] [ebp-4h]

  item_list = parse_item_list(fp);
  if ( !item_list )
    return 0;
  group_def = (GroupDef *)calloc(1u, 8u);
  if ( !group_def )
    outofmem("../../../WWW/Library/Implementation/HTGroup.c", "HTAA_parseGroupDef");
  group_def->group_name = 0;
  group_def->item_list = item_list;
  lex_item = lex(fp);
  if ( lex_item != LEX_REC_SEP )
    syntax_error(fp, "Garbage after group definition", lex_item);
  return group_def;
}

//----- (081491E6) --------------------------------------------------------
void __cdecl print_item(Item *item)
{
  FILE *v1; // eax
  const char *v2; // ebx
  FILE *v3; // eax
  const char *v4; // ebx
  FILE *v5; // eax
  FILE *v6; // eax
  FILE *v7; // eax
  const char *v8; // ebx
  FILE *v9; // eax
  const char *v10; // ebx
  FILE *v11; // eax
  FILE *v12; // eax
  FILE *v13; // eax
  const char **object; // [esp+1Ch] [ebp-2Ch]
  const char **v15; // [esp+20h] [ebp-28h]
  const char *v16; // [esp+24h] [ebp-24h]
  const char *v17; // [esp+28h] [ebp-20h]
  const char **v18; // [esp+2Ch] [ebp-1Ch]
  const char **v19; // [esp+30h] [ebp-18h]
  AddressDefList *cur2; // [esp+3Ch] [ebp-Ch]
  UserDefList *cur1; // [esp+40h] [ebp-8h]

  if ( item )
  {
    cur1 = item->user_def_list;
    cur2 = item->address_def_list;
    if ( item->user_def_list && (cur1 = cur1->next) != 0 )
      object = (const char **)cur1->object;
    else
      object = 0;
    if ( cur2 && (cur2 = cur2->next) != 0 )
      v15 = (const char **)cur2->object;
    else
      v15 = 0;
    if ( object )
    {
      if ( object[1] )
        v16 = "*REF*";
      else
        v16 = (const char *)&unk_8192001;
      v2 = *object;
      v3 = TraceFP();
      fprintf(v3, "\t[%s%s", v2, v16);
      while ( 1 )
      {
        if ( cur1 && (cur1 = cur1->next) != 0 )
          v18 = (const char **)cur1->object;
        else
          v18 = 0;
        if ( !v18 )
          break;
        if ( v18[1] )
          v17 = "*REF*";
        else
          v17 = (const char *)&unk_8192001;
        v4 = *v18;
        v5 = TraceFP();
        fprintf(v5, "; %s%s", v4, v17);
      }
      v6 = TraceFP();
      fwrite("] ", 1u, 2u, v6);
    }
    else
    {
      v7 = TraceFP();
      fwrite("\tANYBODY ", 1u, 9u, v7);
    }
    if ( v15 )
    {
      v8 = *v15;
      v9 = TraceFP();
      fprintf(v9, "@ [%s", v8);
      while ( 1 )
      {
        if ( cur2 && (cur2 = cur2->next) != 0 )
          v19 = (const char **)cur2->object;
        else
          v19 = 0;
        if ( !v19 )
          break;
        v10 = *v19;
        v11 = TraceFP();
        fprintf(v11, "; %s", v10);
      }
      v12 = TraceFP();
      fwrite("]\n", 1u, 2u, v12);
    }
    else
    {
      v13 = TraceFP();
      fwrite("@ ANYADDRESS\n", 1u, 0xDu, v13);
    }
  }
  else
  {
    v1 = TraceFP();
    fwrite("\tNULL-ITEM\n", 1u, 0xBu, v1);
  }
}

//----- (0814945A) --------------------------------------------------------
void __cdecl print_item_list(ItemList *item_list)
{
  FILE *v1; // eax
  Item *object; // [esp+14h] [ebp-14h]
  ItemList *cur; // [esp+24h] [ebp-4h]

  cur = item_list;
  if ( item_list )
  {
    while ( 1 )
    {
      if ( cur && (cur = cur->next) != 0 )
        object = (Item *)cur->object;
      else
        object = 0;
      if ( !object )
        break;
      print_item(object);
    }
  }
  else
  {
    v1 = TraceFP();
    fwrite("EMPTY", 1u, 5u, v1);
  }
}

//----- (081494D2) --------------------------------------------------------
void __cdecl HTAA_printGroupDef(GroupDef *group_def)
{
  FILE *v1; // eax
  FILE *v2; // eax
  FILE *v3; // eax
  char *group_name; // [esp+14h] [ebp-4h]

  if ( group_def )
  {
    if ( group_def->group_name )
      group_name = group_def->group_name;
    else
      group_name = "NULL";
    v2 = TraceFP();
    fprintf(v2, "\nGroup %s:\n", group_name);
    print_item_list(group_def->item_list);
    v3 = TraceFP();
    fputc(10, v3);
  }
  else
  {
    v1 = TraceFP();
    fwrite("\nNULL RECORD\n", 1u, 0xDu, v1);
  }
}

//----- (08149760) --------------------------------------------------------
int __cdecl stat64(int a1, int a2)
{
  return __xstat64(3, a1, a2);
}
// 804A9A4: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);

//----- (081497A0) --------------------------------------------------------
int __cdecl lstat64(int a1, int a2)
{
  return __lxstat64(3, a1, a2);
}
// 804AC84: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);

// nfuncs=2237 queued=1821 decompiled=1821 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1821 function(s)"
